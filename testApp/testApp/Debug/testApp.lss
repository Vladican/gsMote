
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007ce6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00802000  00007ce6  00007d7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa5  00802138  00802138  00007eb2  2**0
                  ALLOC
  3 .stab         000029b8  00000000  00000000  00007eb4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2d  00000000  00000000  0000a86c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000400  00000000  00000000  0000b2a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000caeb  00000000  00000000  0000b6a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002698  00000000  00000000  0001818b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005553  00000000  00000000  0001a823  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ca4  00000000  00000000  0001fd78  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004695  00000000  00000000  00021a1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008305  00000000  00000000  000260b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b166  00000000  00000000  0002e3b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000190  00000000  00000000  0018951c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 e6 08 	jmp	0x11cc	; 0x11cc <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 ab 0d 	jmp	0x1b56	; 0x1b56 <__vector_16>
      44:	0c 94 83 0d 	jmp	0x1b06	; 0x1b06 <__vector_17>
      48:	0c 94 5b 0d 	jmp	0x1ab6	; 0x1ab6 <__vector_18>
      4c:	0c 94 15 0d 	jmp	0x1a2a	; 0x1a2a <__vector_19>
      50:	0c 94 38 07 	jmp	0xe70	; 0xe70 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 9b 20 	jmp	0x4136	; 0x4136 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 83 1a 	jmp	0x3506	; 0x3506 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 8e 0a 	jmp	0x151c	; 0x151c <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 ed 0c 	jmp	0x19da	; 0x19da <__vector_79>
     140:	0c 94 c5 0c 	jmp	0x198a	; 0x198a <__vector_80>
     144:	0c 94 9d 0c 	jmp	0x193a	; 0x193a <__vector_81>
     148:	0c 94 73 0c 	jmp	0x18e6	; 0x18e6 <__vector_82>
     14c:	0c 94 56 03 	jmp	0x6ac	; 0x6ac <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e6 ee       	ldi	r30, 0xE6	; 230
     244:	fc e7       	ldi	r31, 0x7C	; 124
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 33       	cpi	r26, 0x38	; 56
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e3       	ldi	r26, 0x38	; 56
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ad 3d       	cpi	r26, 0xDD	; 221
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 01 02 	call	0x402	; 0x402 <main>
     26a:	0c 94 71 3e 	jmp	0x7ce2	; 0x7ce2 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	6b 01       	movw	r12, r22
     284:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     286:	dc 01       	movw	r26, r24
     288:	cb 01       	movw	r24, r22
     28a:	88 55       	subi	r24, 0x58	; 88
     28c:	92 40       	sbci	r25, 0x02	; 2
     28e:	a0 40       	sbci	r26, 0x00	; 0
     290:	b0 40       	sbci	r27, 0x00	; 0
     292:	89 3e       	cpi	r24, 0xE9	; 233
     294:	2f e3       	ldi	r18, 0x3F	; 63
     296:	92 07       	cpc	r25, r18
     298:	2f e0       	ldi	r18, 0x0F	; 15
     29a:	a2 07       	cpc	r26, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	b2 07       	cpc	r27, r18
     2a0:	08 f0       	brcs	.+2      	; 0x2a4 <StartSerial+0x32>
     2a2:	5c c0       	rjmp	.+184    	; 0x35c <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2a4:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2a8:	e0 e4       	ldi	r30, 0x40	; 64
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2b0:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2b2:	84 e0       	ldi	r24, 0x04	; 4
     2b4:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2b6:	cc 0c       	add	r12, r12
     2b8:	dd 1c       	adc	r13, r13
     2ba:	ee 1c       	adc	r14, r14
     2bc:	ff 1c       	adc	r15, r15
     2be:	cc 0c       	add	r12, r12
     2c0:	dd 1c       	adc	r13, r13
     2c2:	ee 1c       	adc	r14, r14
     2c4:	ff 1c       	adc	r15, r15
     2c6:	c7 01       	movw	r24, r14
     2c8:	b6 01       	movw	r22, r12
     2ca:	66 0f       	add	r22, r22
     2cc:	77 1f       	adc	r23, r23
     2ce:	88 1f       	adc	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	66 0f       	add	r22, r22
     2d4:	77 1f       	adc	r23, r23
     2d6:	88 1f       	adc	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	0e 94 bf 39 	call	0x737e	; 0x737e <__floatunsisf>
     2de:	9b 01       	movw	r18, r22
     2e0:	ac 01       	movw	r20, r24
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	74 e2       	ldi	r23, 0x24	; 36
     2e6:	84 ef       	ldi	r24, 0xF4	; 244
     2e8:	9b e4       	ldi	r25, 0x4B	; 75
     2ea:	0e 94 2b 39 	call	0x7256	; 0x7256 <__divsf3>
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	40 e8       	ldi	r20, 0x80	; 128
     2f4:	5f e3       	ldi	r21, 0x3F	; 63
     2f6:	0e 94 c6 38 	call	0x718c	; 0x718c <__subsf3>
     2fa:	c6 2f       	mov	r28, r22
     2fc:	d7 2f       	mov	r29, r23
     2fe:	18 2f       	mov	r17, r24
     300:	09 2f       	mov	r16, r25
     302:	86 2f       	mov	r24, r22
     304:	9d 2f       	mov	r25, r29
     306:	a1 2f       	mov	r26, r17
     308:	b0 2f       	mov	r27, r16
     30a:	bc 01       	movw	r22, r24
     30c:	cd 01       	movw	r24, r26
     30e:	0e 94 93 39 	call	0x7326	; 0x7326 <__fixunssfsi>
     312:	6b 01       	movw	r12, r22
     314:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 bf 39 	call	0x737e	; 0x737e <__floatunsisf>
     31e:	9b 01       	movw	r18, r22
     320:	ac 01       	movw	r20, r24
     322:	8c 2f       	mov	r24, r28
     324:	9d 2f       	mov	r25, r29
     326:	a1 2f       	mov	r26, r17
     328:	b0 2f       	mov	r27, r16
     32a:	bc 01       	movw	r22, r24
     32c:	cd 01       	movw	r24, r26
     32e:	0e 94 c6 38 	call	0x718c	; 0x718c <__subsf3>
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	40 e0       	ldi	r20, 0x00	; 0
     338:	5f e3       	ldi	r21, 0x3F	; 63
     33a:	0e 94 4d 3a 	call	0x749a	; 0x749a <__gesf2>
     33e:	88 23       	and	r24, r24
     340:	1c f0       	brlt	.+6      	; 0x348 <StartSerial+0xd6>
     342:	08 94       	sec
     344:	c1 1c       	adc	r12, r1
     346:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     348:	e0 ea       	ldi	r30, 0xA0	; 160
     34a:	f8 e0       	ldi	r31, 0x08	; 8
     34c:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     34e:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     354:	88 e1       	ldi	r24, 0x18	; 24
     356:	84 83       	std	Z+4, r24	; 0x04
	return true;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	01 c0       	rjmp	.+2      	; 0x35e <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     35c:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	1f 91       	pop	r17
     364:	0f 91       	pop	r16
     366:	ff 90       	pop	r15
     368:	ef 90       	pop	r14
     36a:	df 90       	pop	r13
     36c:	cf 90       	pop	r12
     36e:	08 95       	ret

00000370 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     370:	e0 ea       	ldi	r30, 0xA0	; 160
     372:	f8 e0       	ldi	r31, 0x08	; 8
     374:	91 81       	ldd	r25, Z+1	; 0x01
     376:	95 ff       	sbrs	r25, 5
     378:	fd cf       	rjmp	.-6      	; 0x374 <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     37a:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     37e:	08 95       	ret

00000380 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     380:	e0 ea       	ldi	r30, 0xA0	; 160
     382:	f8 e0       	ldi	r31, 0x08	; 8
     384:	81 81       	ldd	r24, Z+1	; 0x01
     386:	88 23       	and	r24, r24
     388:	ec f7       	brge	.-6      	; 0x384 <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     38a:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     38e:	08 95       	ret

00000390 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     390:	8f 92       	push	r8
     392:	9f 92       	push	r9
     394:	af 92       	push	r10
     396:	bf 92       	push	r11
     398:	cf 92       	push	r12
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	6a 01       	movw	r12, r20
     3a6:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     3a8:	41 15       	cp	r20, r1
     3aa:	51 05       	cpc	r21, r1
     3ac:	61 05       	cpc	r22, r1
     3ae:	71 05       	cpc	r23, r1
     3b0:	91 f0       	breq	.+36     	; 0x3d6 <SerialWriteBuffer+0x46>
     3b2:	c8 2f       	mov	r28, r24
     3b4:	d9 2f       	mov	r29, r25
     3b6:	88 24       	eor	r8, r8
     3b8:	99 24       	eor	r9, r9
     3ba:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     3bc:	89 91       	ld	r24, Y+
     3be:	0e 94 b8 01 	call	0x370	; 0x370 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     3c2:	08 94       	sec
     3c4:	81 1c       	adc	r8, r1
     3c6:	91 1c       	adc	r9, r1
     3c8:	a1 1c       	adc	r10, r1
     3ca:	b1 1c       	adc	r11, r1
     3cc:	8c 14       	cp	r8, r12
     3ce:	9d 04       	cpc	r9, r13
     3d0:	ae 04       	cpc	r10, r14
     3d2:	bf 04       	cpc	r11, r15
     3d4:	99 f7       	brne	.-26     	; 0x3bc <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	ff 90       	pop	r15
     3dc:	ef 90       	pop	r14
     3de:	df 90       	pop	r13
     3e0:	cf 90       	pop	r12
     3e2:	bf 90       	pop	r11
     3e4:	af 90       	pop	r10
     3e6:	9f 90       	pop	r9
     3e8:	8f 90       	pop	r8
     3ea:	08 95       	ret

000003ec <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     3ec:	e0 ea       	ldi	r30, 0xA0	; 160
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	84 81       	ldd	r24, Z+4	; 0x04
     3f2:	87 7e       	andi	r24, 0xE7	; 231
     3f4:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     3f6:	e0 e4       	ldi	r30, 0x40	; 64
     3f8:	f6 e0       	ldi	r31, 0x06	; 6
     3fa:	88 e0       	ldi	r24, 0x08	; 8
     3fc:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     3fe:	82 83       	std	Z+2, r24	; 0x02
     400:	08 95       	ret

00000402 <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
     40a:	69 97       	sbiw	r28, 0x19	; 25
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
	volatile uint32_t samples = 0;
     410:	19 82       	std	Y+1, r1	; 0x01
     412:	1a 82       	std	Y+2, r1	; 0x02
     414:	1b 82       	std	Y+3, r1	; 0x03
     416:	1c 82       	std	Y+4, r1	; 0x04
	DataAvailable = 0;
     418:	10 92 d5 21 	sts	0x21D5, r1
	ADC_Sampling_Finished = 1;
     41c:	81 e0       	ldi	r24, 0x01	; 1
     41e:	80 93 cd 50 	sts	0x50CD, r24
	uint8_t RadioMessageBuffer[20];
	set_32MHz();
     422:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <set_32MHz>
	chb_init();
     426:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <chb_init>
	chb_set_channel(1);
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	0e 94 af 19 	call	0x335e	; 0x335e <chb_set_channel>
	chb_set_short_addr(0x0002);
     430:	82 e0       	ldi	r24, 0x02	; 2
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 71 18 	call	0x30e2	; 0x30e2 <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     438:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <chb_get_pcb>
     43c:	3c 01       	movw	r6, r24

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
     43e:	0f 2e       	mov	r0, r31
     440:	f8 ee       	ldi	r31, 0xE8	; 232
     442:	4f 2e       	mov	r4, r31
     444:	f3 e0       	ldi	r31, 0x03	; 3
     446:	5f 2e       	mov	r5, r31
     448:	f0 2d       	mov	r31, r0
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     44a:	10 e0       	ldi	r17, 0x00	; 0
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
						//CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     44c:	0f 2e       	mov	r0, r31
     44e:	ff ed       	ldi	r31, 0xDF	; 223
     450:	2f 2e       	mov	r2, r31
     452:	f3 e2       	ldi	r31, 0x23	; 35
     454:	3f 2e       	mov	r3, r31
     456:	f0 2d       	mov	r31, r0
     458:	01 c0       	rjmp	.+2      	; 0x45c <main+0x5a>
					switch(RadioMessageBuffer[1]){
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     45a:	11 e0       	ldi	r17, 0x01	; 1
	chb_init();
	chb_set_channel(1);
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
     45c:	f3 01       	movw	r30, r6
     45e:	83 81       	ldd	r24, Z+3	; 0x03
     460:	88 23       	and	r24, r24
     462:	e1 f3       	breq	.-8      	; 0x45c <main+0x5a>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     464:	ce 01       	movw	r24, r28
     466:	05 96       	adiw	r24, 0x05	; 5
     468:	0e 94 12 17 	call	0x2e24	; 0x2e24 <chb_read>
			
			if(length == 1){
     46c:	81 30       	cpi	r24, 0x01	; 1
     46e:	b1 f7       	brne	.-20     	; 0x45c <main+0x5a>
				switch ( RadioMessageBuffer[0])
     470:	8d 81       	ldd	r24, Y+5	; 0x05
     472:	82 35       	cpi	r24, 0x52	; 82
     474:	71 f0       	breq	.+28     	; 0x492 <main+0x90>
     476:	83 35       	cpi	r24, 0x53	; 83
     478:	30 f4       	brcc	.+12     	; 0x486 <main+0x84>
     47a:	86 34       	cpi	r24, 0x46	; 70
     47c:	09 f4       	brne	.+2      	; 0x480 <main+0x7e>
     47e:	65 c0       	rjmp	.+202    	; 0x54a <main+0x148>
     480:	87 34       	cpi	r24, 0x47	; 71
     482:	61 f7       	brne	.-40     	; 0x45c <main+0x5a>
     484:	30 c0       	rjmp	.+96     	; 0x4e6 <main+0xe4>
     486:	83 35       	cpi	r24, 0x53	; 83
     488:	09 f4       	brne	.+2      	; 0x48c <main+0x8a>
     48a:	62 c0       	rjmp	.+196    	; 0x550 <main+0x14e>
     48c:	84 35       	cpi	r24, 0x54	; 84
     48e:	31 f7       	brne	.-52     	; 0x45c <main+0x5a>
     490:	67 c0       	rjmp	.+206    	; 0x560 <main+0x15e>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     492:	80 91 cd 50 	lds	r24, 0x50CD
     496:	88 23       	and	r24, r24
     498:	09 f3       	breq	.-62     	; 0x45c <main+0x5a>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     49a:	00 d0       	rcall	.+0      	; 0x49c <main+0x9a>
     49c:	0f 92       	push	r0
     49e:	8c e1       	ldi	r24, 0x1C	; 28
     4a0:	97 e0       	ldi	r25, 0x07	; 7
     4a2:	ed b7       	in	r30, 0x3d	; 61
     4a4:	fe b7       	in	r31, 0x3e	; 62
     4a6:	81 83       	std	Z+1, r24	; 0x01
     4a8:	92 83       	std	Z+2, r25	; 0x02
     4aa:	23 82       	std	Z+3, r2	; 0x03
     4ac:	34 82       	std	Z+4, r3	; 0x04
     4ae:	87 e0       	ldi	r24, 0x07	; 7
     4b0:	61 2f       	mov	r22, r17
     4b2:	a2 01       	movw	r20, r4
     4b4:	26 e0       	ldi	r18, 0x06	; 6
     4b6:	01 e0       	ldi	r16, 0x01	; 1
     4b8:	ee 24       	eor	r14, r14
     4ba:	ff 24       	eor	r15, r15
     4bc:	e3 94       	inc	r14
     4be:	cc 24       	eor	r12, r12
     4c0:	dd 24       	eor	r13, r13
     4c2:	68 94       	set
     4c4:	c1 f8       	bld	r12, 1
     4c6:	0f 2e       	mov	r0, r31
     4c8:	f3 e0       	ldi	r31, 0x03	; 3
     4ca:	af 2e       	mov	r10, r31
     4cc:	bb 24       	eor	r11, r11
     4ce:	f0 2d       	mov	r31, r0
     4d0:	88 24       	eor	r8, r8
     4d2:	99 24       	eor	r9, r9
     4d4:	68 94       	set
     4d6:	82 f8       	bld	r8, 2
     4d8:	0e 94 57 13 	call	0x26ae	; 0x26ae <CO_collectSeismic1Channel>
     4dc:	0f 90       	pop	r0
     4de:	0f 90       	pop	r0
     4e0:	0f 90       	pop	r0
     4e2:	0f 90       	pop	r0
     4e4:	bb cf       	rjmp	.-138    	; 0x45c <main+0x5a>
					}						
					break;
				case 'G':
					//set gain to what is specified
					switch(RadioMessageBuffer[1]){
     4e6:	8e 81       	ldd	r24, Y+6	; 0x06
     4e8:	88 30       	cpi	r24, 0x08	; 8
     4ea:	d1 f0       	breq	.+52     	; 0x520 <main+0x11e>
     4ec:	89 30       	cpi	r24, 0x09	; 9
     4ee:	40 f4       	brcc	.+16     	; 0x500 <main+0xfe>
     4f0:	82 30       	cpi	r24, 0x02	; 2
     4f2:	09 f4       	brne	.+2      	; 0x4f6 <main+0xf4>
     4f4:	b2 cf       	rjmp	.-156    	; 0x45a <main+0x58>
     4f6:	84 30       	cpi	r24, 0x04	; 4
     4f8:	89 f0       	breq	.+34     	; 0x51c <main+0x11a>
     4fa:	81 30       	cpi	r24, 0x01	; 1
     4fc:	d9 f4       	brne	.+54     	; 0x534 <main+0x132>
     4fe:	0c c0       	rjmp	.+24     	; 0x518 <main+0x116>
     500:	80 32       	cpi	r24, 0x20	; 32
     502:	91 f0       	breq	.+36     	; 0x528 <main+0x126>
     504:	81 32       	cpi	r24, 0x21	; 33
     506:	18 f4       	brcc	.+6      	; 0x50e <main+0x10c>
     508:	80 31       	cpi	r24, 0x10	; 16
     50a:	a1 f4       	brne	.+40     	; 0x534 <main+0x132>
     50c:	0b c0       	rjmp	.+22     	; 0x524 <main+0x122>
     50e:	80 34       	cpi	r24, 0x40	; 64
     510:	69 f0       	breq	.+26     	; 0x52c <main+0x12a>
     512:	80 38       	cpi	r24, 0x80	; 128
     514:	79 f4       	brne	.+30     	; 0x534 <main+0x132>
     516:	0c c0       	rjmp	.+24     	; 0x530 <main+0x12e>
						case 1:
							gain = GAIN_1_gc;
     518:	10 e0       	ldi	r17, 0x00	; 0
     51a:	a0 cf       	rjmp	.-192    	; 0x45c <main+0x5a>
							break;
						case 2:
							gain = GAIN_2_gc;
							break;
						case 4:
							gain = GAIN_4_gc;
     51c:	12 e0       	ldi	r17, 0x02	; 2
							break;
     51e:	9e cf       	rjmp	.-196    	; 0x45c <main+0x5a>
						case 8:
							gain = GAIN_8_gc;
     520:	13 e0       	ldi	r17, 0x03	; 3
							break;
     522:	9c cf       	rjmp	.-200    	; 0x45c <main+0x5a>
						case 16:
							gain = GAIN_16_gc;
     524:	14 e0       	ldi	r17, 0x04	; 4
							break;
     526:	9a cf       	rjmp	.-204    	; 0x45c <main+0x5a>
						case 32:
							gain = GAIN_32_gc;
     528:	15 e0       	ldi	r17, 0x05	; 5
							break;
     52a:	98 cf       	rjmp	.-208    	; 0x45c <main+0x5a>
						case 64:
							gain = GAIN_64_gc;
     52c:	16 e0       	ldi	r17, 0x06	; 6
							break;
     52e:	96 cf       	rjmp	.-212    	; 0x45c <main+0x5a>
						case 128:
							gain = GAIN_128_gc;
     530:	17 e0       	ldi	r17, 0x07	; 7
							break;
     532:	94 cf       	rjmp	.-216    	; 0x45c <main+0x5a>
						default:
							chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	60 e0       	ldi	r22, 0x00	; 0
     53a:	70 e2       	ldi	r23, 0x20	; 32
     53c:	2c e0       	ldi	r18, 0x0C	; 12
     53e:	30 e0       	ldi	r19, 0x00	; 0
     540:	40 e0       	ldi	r20, 0x00	; 0
     542:	50 e0       	ldi	r21, 0x00	; 0
     544:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <chb_write>
							break;
     548:	89 cf       	rjmp	.-238    	; 0x45c <main+0x5a>
					}					
					break;
				case 'F':
					//set sampling frequency to what is specified
					freq = *(uint16_t*)(RadioMessageBuffer+1);
     54a:	4e 80       	ldd	r4, Y+6	; 0x06
     54c:	5f 80       	ldd	r5, Y+7	; 0x07
					break;
     54e:	86 cf       	rjmp	.-244    	; 0x45c <main+0x5a>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     550:	80 91 cd 50 	lds	r24, 0x50CD
     554:	88 23       	and	r24, r24
     556:	09 f0       	breq	.+2      	; 0x55a <main+0x158>
     558:	81 cf       	rjmp	.-254    	; 0x45c <main+0x5a>
						ADC_Stop_Sampling();
     55a:	0e 94 7e 07 	call	0xefc	; 0xefc <ADC_Stop_Sampling>
     55e:	7e cf       	rjmp	.-260    	; 0x45c <main+0x5a>
					}
					//otherwise, the ADC has finished sampling on its own and the data will be transmitted after this switch statement
					break;
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     560:	80 91 cd 50 	lds	r24, 0x50CD
     564:	88 23       	and	r24, r24
     566:	09 f4       	brne	.+2      	; 0x56a <main+0x168>
     568:	79 cf       	rjmp	.-270    	; 0x45c <main+0x5a>
     56a:	80 91 d5 21 	lds	r24, 0x21D5
     56e:	88 23       	and	r24, r24
     570:	09 f4       	brne	.+2      	; 0x574 <main+0x172>
     572:	74 cf       	rjmp	.-280    	; 0x45c <main+0x5a>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     574:	0e 94 9f 07 	call	0xf3e	; 0xf3e <ADC_Get_Num_Samples>
     578:	a0 e0       	ldi	r26, 0x00	; 0
     57a:	b0 e0       	ldi	r27, 0x00	; 0
     57c:	89 83       	std	Y+1, r24	; 0x01
     57e:	9a 83       	std	Y+2, r25	; 0x02
     580:	ab 83       	std	Y+3, r26	; 0x03
     582:	bc 83       	std	Y+4, r27	; 0x04
						if(samples > 0){
     584:	89 81       	ldd	r24, Y+1	; 0x01
     586:	9a 81       	ldd	r25, Y+2	; 0x02
     588:	ab 81       	ldd	r26, Y+3	; 0x03
     58a:	bc 81       	ldd	r27, Y+4	; 0x04
     58c:	00 97       	sbiw	r24, 0x00	; 0
     58e:	a1 05       	cpc	r26, r1
     590:	b1 05       	cpc	r27, r1
     592:	09 f4       	brne	.+2      	; 0x596 <main+0x194>
     594:	50 c0       	rjmp	.+160    	; 0x636 <main+0x234>
								//if((samples*4-i) >= 100) chb_write(0x0000,(FRAMReadBuffer+i),100);
								//else chb_write(0x0000,(FRAMReadBuffer+i),(samples*4-i));
								//add 1 ms delay between messages
								//delay_us(10000);
							//}		
							uint8_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     596:	89 81       	ldd	r24, Y+1	; 0x01
     598:	9a 81       	ldd	r25, Y+2	; 0x02
     59a:	ab 81       	ldd	r26, Y+3	; 0x03
     59c:	bc 81       	ldd	r27, Y+4	; 0x04
     59e:	bc 01       	movw	r22, r24
     5a0:	cd 01       	movw	r24, r26
     5a2:	66 0f       	add	r22, r22
     5a4:	77 1f       	adc	r23, r23
     5a6:	88 1f       	adc	r24, r24
     5a8:	99 1f       	adc	r25, r25
     5aa:	66 0f       	add	r22, r22
     5ac:	77 1f       	adc	r23, r23
     5ae:	88 1f       	adc	r24, r24
     5b0:	99 1f       	adc	r25, r25
     5b2:	24 e6       	ldi	r18, 0x64	; 100
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	40 e0       	ldi	r20, 0x00	; 0
     5b8:	50 e0       	ldi	r21, 0x00	; 0
     5ba:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     5be:	02 2f       	mov	r16, r18
     5c0:	29 8f       	std	Y+25, r18	; 0x19
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
     5c2:	89 81       	ldd	r24, Y+1	; 0x01
     5c4:	9a 81       	ldd	r25, Y+2	; 0x02
     5c6:	ab 81       	ldd	r26, Y+3	; 0x03
     5c8:	bc 81       	ldd	r27, Y+4	; 0x04
     5ca:	bc 01       	movw	r22, r24
     5cc:	cd 01       	movw	r24, r26
     5ce:	66 0f       	add	r22, r22
     5d0:	77 1f       	adc	r23, r23
     5d2:	88 1f       	adc	r24, r24
     5d4:	99 1f       	adc	r25, r25
     5d6:	66 0f       	add	r22, r22
     5d8:	77 1f       	adc	r23, r23
     5da:	88 1f       	adc	r24, r24
     5dc:	99 1f       	adc	r25, r25
     5de:	24 e6       	ldi	r18, 0x64	; 100
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	40 e0       	ldi	r20, 0x00	; 0
     5e4:	50 e0       	ldi	r21, 0x00	; 0
     5e6:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     5ea:	dc 01       	movw	r26, r24
     5ec:	cb 01       	movw	r24, r22
     5ee:	00 97       	sbiw	r24, 0x00	; 0
     5f0:	a1 05       	cpc	r26, r1
     5f2:	b1 05       	cpc	r27, r1
     5f4:	11 f0       	breq	.+4      	; 0x5fa <main+0x1f8>
     5f6:	0f 5f       	subi	r16, 0xFF	; 255
     5f8:	09 8f       	std	Y+25, r16	; 0x19
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,1);  
     5fa:	80 e0       	ldi	r24, 0x00	; 0
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	be 01       	movw	r22, r28
     600:	67 5e       	subi	r22, 0xE7	; 231
     602:	7f 4f       	sbci	r23, 0xFF	; 255
     604:	21 e0       	ldi	r18, 0x01	; 1
     606:	30 e0       	ldi	r19, 0x00	; 0
     608:	40 e0       	ldi	r20, 0x00	; 0
     60a:	50 e0       	ldi	r21, 0x00	; 0
     60c:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <chb_write>
							//send the data
							chb_write(0x0000,FRAMReadBuffer,samples*4);					
     610:	89 81       	ldd	r24, Y+1	; 0x01
     612:	9a 81       	ldd	r25, Y+2	; 0x02
     614:	ab 81       	ldd	r26, Y+3	; 0x03
     616:	bc 81       	ldd	r27, Y+4	; 0x04
     618:	9c 01       	movw	r18, r24
     61a:	ad 01       	movw	r20, r26
     61c:	22 0f       	add	r18, r18
     61e:	33 1f       	adc	r19, r19
     620:	44 1f       	adc	r20, r20
     622:	55 1f       	adc	r21, r21
     624:	22 0f       	add	r18, r18
     626:	33 1f       	adc	r19, r19
     628:	44 1f       	adc	r20, r20
     62a:	55 1f       	adc	r21, r21
     62c:	80 e0       	ldi	r24, 0x00	; 0
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	b1 01       	movw	r22, r2
     632:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <chb_write>
						}							
						DataAvailable = 0;
     636:	10 92 d5 21 	sts	0x21D5, r1
     63a:	10 cf       	rjmp	.-480    	; 0x45c <main+0x5a>

0000063c <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     63c:	0f 93       	push	r16
     63e:	1f 93       	push	r17
     640:	cf 93       	push	r28
     642:	8c 01       	movw	r16, r24
	moteID = 1;
     644:	c1 e0       	ldi	r28, 0x01	; 1
     646:	c0 93 c8 50 	sts	0x50C8, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     64a:	83 e0       	ldi	r24, 0x03	; 3
     64c:	80 93 5e 40 	sts	0x405E, r24
	chb_init();
     650:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <chb_init>
	chb_set_short_addr(moteID);
     654:	80 91 c8 50 	lds	r24, 0x50C8
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 71 18 	call	0x30e2	; 0x30e2 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     65e:	88 ec       	ldi	r24, 0xC8	; 200
     660:	e0 e8       	ldi	r30, 0x80	; 128
     662:	f1 e0       	ldi	r31, 0x01	; 1
     664:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     666:	e0 e4       	ldi	r30, 0x40	; 64
     668:	f9 e0       	ldi	r31, 0x09	; 9
     66a:	89 e0       	ldi	r24, 0x09	; 9
     66c:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     66e:	82 e0       	ldi	r24, 0x02	; 2
     670:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     672:	24 ef       	ldi	r18, 0xF4	; 244
     674:	31 e0       	ldi	r19, 0x01	; 1
     676:	02 9f       	mul	r16, r18
     678:	c0 01       	movw	r24, r0
     67a:	03 9f       	mul	r16, r19
     67c:	90 0d       	add	r25, r0
     67e:	12 9f       	mul	r17, r18
     680:	90 0d       	add	r25, r0
     682:	11 24       	eor	r1, r1
     684:	86 a3       	lds	r24, 0x56
     686:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     688:	e0 e4       	ldi	r30, 0x40	; 64
     68a:	f8 e0       	ldi	r31, 0x08	; 8
     68c:	80 e0       	ldi	r24, 0x00	; 0
     68e:	9a ef       	ldi	r25, 0xFA	; 250
     690:	86 a3       	lds	r24, 0x56
     692:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     694:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     696:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     698:	e0 ea       	ldi	r30, 0xA0	; 160
     69a:	f0 e0       	ldi	r31, 0x00	; 0
     69c:	82 81       	ldd	r24, Z+2	; 0x02
     69e:	87 60       	ori	r24, 0x07	; 7
     6a0:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     6a2:	78 94       	sei
}
     6a4:	cf 91       	pop	r28
     6a6:	1f 91       	pop	r17
     6a8:	0f 91       	pop	r16
     6aa:	08 95       	ret

000006ac <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     6ac:	78 94       	sei
     6ae:	1f 92       	push	r1
     6b0:	0f 92       	push	r0
     6b2:	0f b6       	in	r0, 0x3f	; 63
     6b4:	0f 92       	push	r0
     6b6:	0b b6       	in	r0, 0x3b	; 59
     6b8:	0f 92       	push	r0
     6ba:	11 24       	eor	r1, r1
     6bc:	ef 92       	push	r14
     6be:	ff 92       	push	r15
     6c0:	0f 93       	push	r16
     6c2:	1f 93       	push	r17
     6c4:	2f 93       	push	r18
     6c6:	3f 93       	push	r19
     6c8:	4f 93       	push	r20
     6ca:	5f 93       	push	r21
     6cc:	6f 93       	push	r22
     6ce:	7f 93       	push	r23
     6d0:	8f 93       	push	r24
     6d2:	9f 93       	push	r25
     6d4:	af 93       	push	r26
     6d6:	bf 93       	push	r27
     6d8:	ef 93       	push	r30
     6da:	ff 93       	push	r31
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	cd b7       	in	r28, 0x3d	; 61
     6e2:	de b7       	in	r29, 0x3e	; 62
     6e4:	28 97       	sbiw	r28, 0x08	; 8
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     6ea:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
     6ee:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     6f2:	82 e0       	ldi	r24, 0x02	; 2
     6f4:	80 93 5e 40 	sts	0x405E, r24
	char message[8];
	strcpy(message,"reset");
     6f8:	de 01       	movw	r26, r28
     6fa:	11 96       	adiw	r26, 0x01	; 1
     6fc:	ed e0       	ldi	r30, 0x0D	; 13
     6fe:	f0 e2       	ldi	r31, 0x20	; 32
     700:	86 e0       	ldi	r24, 0x06	; 6
     702:	01 90       	ld	r0, Z+
     704:	0d 92       	st	X+, r0
     706:	81 50       	subi	r24, 0x01	; 1
     708:	e1 f7       	brne	.-8      	; 0x702 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
     70a:	0f ec       	ldi	r16, 0xCF	; 207
     70c:	10 e5       	ldi	r17, 0x50	; 80
     70e:	80 91 c8 50 	lds	r24, 0x50C8
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	b8 01       	movw	r22, r16
     716:	4a e0       	ldi	r20, 0x0A	; 10
     718:	50 e0       	ldi	r21, 0x00	; 0
     71a:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <itoa>
	strcat(message,buff);
     71e:	7e 01       	movw	r14, r28
     720:	08 94       	sec
     722:	e1 1c       	adc	r14, r1
     724:	f1 1c       	adc	r15, r1
     726:	c7 01       	movw	r24, r14
     728:	b8 01       	movw	r22, r16
     72a:	0e 94 42 3b 	call	0x7684	; 0x7684 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     72e:	0e 94 c1 07 	call	0xf82	; 0xf82 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     732:	f7 01       	movw	r30, r14
     734:	01 90       	ld	r0, Z+
     736:	00 20       	and	r0, r0
     738:	e9 f7       	brne	.-6      	; 0x734 <__vector_83+0x88>
     73a:	31 97       	sbiw	r30, 0x01	; 1
     73c:	ee 19       	sub	r30, r14
     73e:	ff 09       	sbc	r31, r15
     740:	9f 01       	movw	r18, r30
     742:	40 e0       	ldi	r20, 0x00	; 0
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	80 e0       	ldi	r24, 0x00	; 0
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	b7 01       	movw	r22, r14
     74c:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <chb_write>
}	
     750:	28 96       	adiw	r28, 0x08	; 8
     752:	cd bf       	out	0x3d, r28	; 61
     754:	de bf       	out	0x3e, r29	; 62
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	ff 91       	pop	r31
     75c:	ef 91       	pop	r30
     75e:	bf 91       	pop	r27
     760:	af 91       	pop	r26
     762:	9f 91       	pop	r25
     764:	8f 91       	pop	r24
     766:	7f 91       	pop	r23
     768:	6f 91       	pop	r22
     76a:	5f 91       	pop	r21
     76c:	4f 91       	pop	r20
     76e:	3f 91       	pop	r19
     770:	2f 91       	pop	r18
     772:	1f 91       	pop	r17
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	0f 90       	pop	r0
     77c:	0b be       	out	0x3b, r0	; 59
     77e:	0f 90       	pop	r0
     780:	0f be       	out	0x3f, r0	; 63
     782:	0f 90       	pop	r0
     784:	1f 90       	pop	r1
     786:	18 95       	reti

00000788 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     788:	cf 93       	push	r28
     78a:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     78c:	21 e0       	ldi	r18, 0x01	; 1
     78e:	30 e0       	ldi	r19, 0x00	; 0
     790:	a9 01       	movw	r20, r18
     792:	02 c0       	rjmp	.+4      	; 0x798 <set_ampGain+0x10>
     794:	44 0f       	add	r20, r20
     796:	55 1f       	adc	r21, r21
     798:	8a 95       	dec	r24
     79a:	e2 f7       	brpl	.-8      	; 0x794 <set_ampGain+0xc>
     79c:	ca 01       	movw	r24, r20
     79e:	61 e0       	ldi	r22, 0x01	; 1
     7a0:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     7a4:	c0 ff       	sbrs	r28, 0
     7a6:	05 c0       	rjmp	.+10     	; 0x7b2 <set_ampGain+0x2a>
     7a8:	80 e4       	ldi	r24, 0x40	; 64
     7aa:	e0 e0       	ldi	r30, 0x00	; 0
     7ac:	f6 e0       	ldi	r31, 0x06	; 6
     7ae:	85 83       	std	Z+5, r24	; 0x05
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
     7b2:	80 e4       	ldi	r24, 0x40	; 64
     7b4:	e0 e0       	ldi	r30, 0x00	; 0
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     7ba:	c1 ff       	sbrs	r28, 1
     7bc:	05 c0       	rjmp	.+10     	; 0x7c8 <set_ampGain+0x40>
     7be:	82 e0       	ldi	r24, 0x02	; 2
     7c0:	e0 e2       	ldi	r30, 0x20	; 32
     7c2:	f6 e0       	ldi	r31, 0x06	; 6
     7c4:	85 83       	std	Z+5, r24	; 0x05
     7c6:	04 c0       	rjmp	.+8      	; 0x7d0 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
     7c8:	82 e0       	ldi	r24, 0x02	; 2
     7ca:	e0 e2       	ldi	r30, 0x20	; 32
     7cc:	f6 e0       	ldi	r31, 0x06	; 6
     7ce:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     7d0:	c2 ff       	sbrs	r28, 2
     7d2:	05 c0       	rjmp	.+10     	; 0x7de <set_ampGain+0x56>
     7d4:	84 e0       	ldi	r24, 0x04	; 4
     7d6:	e0 e2       	ldi	r30, 0x20	; 32
     7d8:	f6 e0       	ldi	r31, 0x06	; 6
     7da:	85 83       	std	Z+5, r24	; 0x05
     7dc:	04 c0       	rjmp	.+8      	; 0x7e6 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
     7de:	84 e0       	ldi	r24, 0x04	; 4
     7e0:	e0 e2       	ldi	r30, 0x20	; 32
     7e2:	f6 e0       	ldi	r31, 0x06	; 6
     7e4:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7e6:	5a e0       	ldi	r21, 0x0A	; 10
     7e8:	5a 95       	dec	r21
     7ea:	f1 f7       	brne	.-4      	; 0x7e8 <set_ampGain+0x60>
     7ec:	00 c0       	rjmp	.+0      	; 0x7ee <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     7ee:	8f ef       	ldi	r24, 0xFF	; 255
     7f0:	61 e0       	ldi	r22, 0x01	; 1
     7f2:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     7f6:	cf 91       	pop	r28
     7f8:	08 95       	ret

000007fa <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     7fe:	c8 2f       	mov	r28, r24
     800:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     802:	d8 2f       	mov	r29, r24
     804:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	a9 01       	movw	r20, r18
     80c:	45 70       	andi	r20, 0x05	; 5
     80e:	50 70       	andi	r21, 0x00	; 0
     810:	41 15       	cp	r20, r1
     812:	51 05       	cpc	r21, r1
     814:	49 f0       	breq	.+18     	; 0x828 <set_filter+0x2e>
     816:	90 91 81 50 	lds	r25, 0x5081
     81a:	48 2f       	mov	r20, r24
     81c:	42 95       	swap	r20
     81e:	4f 70       	andi	r20, 0x0F	; 15
     820:	90 7f       	andi	r25, 0xF0	; 240
     822:	94 2b       	or	r25, r20
     824:	90 93 81 50 	sts	0x5081, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     828:	2a 70       	andi	r18, 0x0A	; 10
     82a:	30 70       	andi	r19, 0x00	; 0
     82c:	21 15       	cp	r18, r1
     82e:	31 05       	cpc	r19, r1
     830:	39 f0       	breq	.+14     	; 0x840 <set_filter+0x46>
     832:	90 91 81 50 	lds	r25, 0x5081
     836:	80 7f       	andi	r24, 0xF0	; 240
     838:	9f 70       	andi	r25, 0x0F	; 15
     83a:	89 2b       	or	r24, r25
     83c:	80 93 81 50 	sts	0x5081, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     840:	84 e0       	ldi	r24, 0x04	; 4
     842:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     846:	80 91 81 50 	lds	r24, 0x5081
     84a:	80 93 65 50 	sts	0x5065, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     84e:	cc 23       	and	r28, r28
     850:	19 f0       	breq	.+6      	; 0x858 <set_filter+0x5e>
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     858:	dd 23       	and	r29, r29
     85a:	19 f0       	breq	.+6      	; 0x862 <set_filter+0x68>
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <upperMuxCS>

	SPICS(TRUE);
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     868:	8f ef       	ldi	r24, 0xFF	; 255
     86a:	e0 ec       	ldi	r30, 0xC0	; 192
     86c:	f8 e0       	ldi	r31, 0x08	; 8
     86e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     870:	82 81       	ldd	r24, Z+2	; 0x02
     872:	88 23       	and	r24, r24
     874:	ec f7       	brge	.-6      	; 0x870 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     876:	e0 ec       	ldi	r30, 0xC0	; 192
     878:	f8 e0       	ldi	r31, 0x08	; 8
     87a:	83 81       	ldd	r24, Z+3	; 0x03
     87c:	80 93 71 50 	sts	0x5071, r24

	nop();
     880:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     882:	a1 e7       	ldi	r26, 0x71	; 113
     884:	b0 e5       	ldi	r27, 0x50	; 80
     886:	1c 97       	sbiw	r26, 0x0c	; 12
     888:	8c 91       	ld	r24, X
     88a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     88c:	82 81       	ldd	r24, Z+2	; 0x02
     88e:	88 23       	and	r24, r24
     890:	ec f7       	brge	.-6      	; 0x88c <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     892:	e0 ec       	ldi	r30, 0xC0	; 192
     894:	f8 e0       	ldi	r31, 0x08	; 8
     896:	83 81       	ldd	r24, Z+3	; 0x03
     898:	80 93 71 50 	sts	0x5071, r24
	SPICS(FALSE);
     89c:	80 e0       	ldi	r24, 0x00	; 0
     89e:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     8a2:	cc 23       	and	r28, r28
     8a4:	19 f0       	breq	.+6      	; 0x8ac <set_filter+0xb2>
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     8ac:	dd 23       	and	r29, r29
     8ae:	19 f0       	breq	.+6      	; 0x8b6 <set_filter+0xbc>
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <upperMuxCS>
	SPIDisable();
     8b6:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
}
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	08 95       	ret

000008c0 <ADCPower>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void ADCPower(uint8_t on) {
     8c0:	0f 93       	push	r16
     8c2:	1f 93       	push	r17
     8c4:	cf 93       	push	r28
     8c6:	df 93       	push	r29
	
	if (on) {
     8c8:	88 23       	and	r24, r24
     8ca:	09 f4       	brne	.+2      	; 0x8ce <ADCPower+0xe>
     8cc:	46 c0       	rjmp	.+140    	; 0x95a <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     8ce:	00 e0       	ldi	r16, 0x00	; 0
     8d0:	16 e0       	ldi	r17, 0x06	; 6
     8d2:	8e ed       	ldi	r24, 0xDE	; 222
     8d4:	d8 01       	movw	r26, r16
     8d6:	11 96       	adiw	r26, 0x01	; 1
     8d8:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     8da:	c0 e2       	ldi	r28, 0x20	; 32
     8dc:	d6 e0       	ldi	r29, 0x06	; 6
     8de:	4e e0       	ldi	r20, 0x0E	; 14
     8e0:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     8e2:	e0 e4       	ldi	r30, 0x40	; 64
     8e4:	f6 e0       	ldi	r31, 0x06	; 6
     8e6:	63 e0       	ldi	r22, 0x03	; 3
     8e8:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     8ea:	80 e8       	ldi	r24, 0x80	; 128
     8ec:	96 e0       	ldi	r25, 0x06	; 6
     8ee:	50 e1       	ldi	r21, 0x10	; 16
     8f0:	dc 01       	movw	r26, r24
     8f2:	11 96       	adiw	r26, 0x01	; 1
     8f4:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     8f6:	20 ea       	ldi	r18, 0xA0	; 160
     8f8:	36 e0       	ldi	r19, 0x06	; 6
     8fa:	d9 01       	movw	r26, r18
     8fc:	11 96       	adiw	r26, 0x01	; 1
     8fe:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     900:	7e e9       	ldi	r23, 0x9E	; 158
     902:	d8 01       	movw	r26, r16
     904:	15 96       	adiw	r26, 0x05	; 5
     906:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     908:	78 e0       	ldi	r23, 0x08	; 8
     90a:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     90c:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     90e:	ec 01       	movw	r28, r24
     910:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     912:	d9 01       	movw	r26, r18
     914:	15 96       	adiw	r26, 0x05	; 5
     916:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     918:	10 92 81 50 	sts	0x5081, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     91c:	8f ef       	ldi	r24, 0xFF	; 255
     91e:	93 ec       	ldi	r25, 0xC3	; 195
     920:	a9 e0       	ldi	r26, 0x09	; 9
     922:	81 50       	subi	r24, 0x01	; 1
     924:	90 40       	sbci	r25, 0x00	; 0
     926:	a0 40       	sbci	r26, 0x00	; 0
     928:	e1 f7       	brne	.-8      	; 0x922 <ADCPower+0x62>
     92a:	00 c0       	rjmp	.+0      	; 0x92c <ADCPower+0x6c>
     92c:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     92e:	80 e4       	ldi	r24, 0x40	; 64
     930:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     932:	10 92 82 50 	sts	0x5082, r1
     936:	10 92 ce 50 	sts	0x50CE, r1
     93a:	10 92 d6 23 	sts	0x23D6, r1
     93e:	10 92 7a 50 	sts	0x507A, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     942:	8f ef       	ldi	r24, 0xFF	; 255
     944:	61 e0       	ldi	r22, 0x01	; 1
     946:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     94a:	8f ef       	ldi	r24, 0xFF	; 255
     94c:	61 e0       	ldi	r22, 0x01	; 1
     94e:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     952:	8f ef       	ldi	r24, 0xFF	; 255
     954:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
     958:	32 c0       	rjmp	.+100    	; 0x9be <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     95a:	00 e0       	ldi	r16, 0x00	; 0
     95c:	16 e0       	ldi	r17, 0x06	; 6
     95e:	7e ed       	ldi	r23, 0xDE	; 222
     960:	d8 01       	movw	r26, r16
     962:	16 96       	adiw	r26, 0x06	; 6
     964:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     966:	a0 e2       	ldi	r26, 0x20	; 32
     968:	b6 e0       	ldi	r27, 0x06	; 6
     96a:	4e e0       	ldi	r20, 0x0E	; 14
     96c:	16 96       	adiw	r26, 0x06	; 6
     96e:	4c 93       	st	X, r20
     970:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     972:	20 e4       	ldi	r18, 0x40	; 64
     974:	36 e0       	ldi	r19, 0x06	; 6
     976:	63 e0       	ldi	r22, 0x03	; 3
     978:	e9 01       	movw	r28, r18
     97a:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     97c:	c0 e8       	ldi	r28, 0x80	; 128
     97e:	d6 e0       	ldi	r29, 0x06	; 6
     980:	50 e1       	ldi	r21, 0x10	; 16
     982:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     984:	80 ea       	ldi	r24, 0xA0	; 160
     986:	96 e0       	ldi	r25, 0x06	; 6
     988:	fc 01       	movw	r30, r24
     98a:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     98c:	f8 01       	movw	r30, r16
     98e:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     990:	12 96       	adiw	r26, 0x02	; 2
     992:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     994:	d9 01       	movw	r26, r18
     996:	12 96       	adiw	r26, 0x02	; 2
     998:	6c 93       	st	X, r22
     99a:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     99c:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     99e:	ec 01       	movw	r28, r24
     9a0:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     9a2:	80 e4       	ldi	r24, 0x40	; 64
     9a4:	12 96       	adiw	r26, 0x02	; 2
     9a6:	8c 93       	st	X, r24
     9a8:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     9aa:	10 92 82 50 	sts	0x5082, r1
     9ae:	10 92 ce 50 	sts	0x50CE, r1
     9b2:	10 92 d6 23 	sts	0x23D6, r1
     9b6:	10 92 7a 50 	sts	0x507A, r1
		channelStatus = 0x00;
     9ba:	10 92 81 50 	sts	0x5081, r1
		
	}
}
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	08 95       	ret

000009c8 <CO_collectBatt>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     9c8:	4f 92       	push	r4
     9ca:	5f 92       	push	r5
     9cc:	6f 92       	push	r6
     9ce:	7f 92       	push	r7
     9d0:	8f 92       	push	r8
     9d2:	9f 92       	push	r9
     9d4:	af 92       	push	r10
     9d6:	bf 92       	push	r11
     9d8:	ef 92       	push	r14
     9da:	ff 92       	push	r15
     9dc:	0f 93       	push	r16
     9de:	1f 93       	push	r17
     9e0:	cf 93       	push	r28
     9e2:	df 93       	push	r29
     9e4:	cd b7       	in	r28, 0x3d	; 61
     9e6:	de b7       	in	r29, 0x3e	; 62
     9e8:	2b 97       	sbiw	r28, 0x0b	; 11
     9ea:	cd bf       	out	0x3d, r28	; 61
     9ec:	de bf       	out	0x3e, r29	; 62
     9ee:	8e 83       	std	Y+6, r24	; 0x06
     9f0:	9f 83       	std	Y+7, r25	; 0x07
     9f2:	68 87       	std	Y+8, r22	; 0x08
     9f4:	79 87       	std	Y+9, r23	; 0x09
     9f6:	4a 87       	std	Y+10, r20	; 0x0a
     9f8:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     9fa:	81 e0       	ldi	r24, 0x01	; 1
     9fc:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     a00:	84 e0       	ldi	r24, 0x04	; 4
     a02:	60 e0       	ldi	r22, 0x00	; 0
     a04:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     a08:	84 e0       	ldi	r24, 0x04	; 4
     a0a:	60 e0       	ldi	r22, 0x00	; 0
     a0c:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
     a10:	2f ef       	ldi	r18, 0xFF	; 255
     a12:	33 ec       	ldi	r19, 0xC3	; 195
     a14:	49 e0       	ldi	r20, 0x09	; 9
     a16:	21 50       	subi	r18, 0x01	; 1
     a18:	30 40       	sbci	r19, 0x00	; 0
     a1a:	40 40       	sbci	r20, 0x00	; 0
     a1c:	e1 f7       	brne	.-8      	; 0xa16 <CO_collectBatt+0x4e>
     a1e:	00 c0       	rjmp	.+0      	; 0xa20 <CO_collectBatt+0x58>
     a20:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     a22:	80 e4       	ldi	r24, 0x40	; 64
     a24:	92 e0       	ldi	r25, 0x02	; 2
     a26:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     a2a:	00 e4       	ldi	r16, 0x40	; 64
     a2c:	12 e0       	ldi	r17, 0x02	; 2
     a2e:	d8 01       	movw	r26, r16
     a30:	11 96       	adiw	r26, 0x01	; 1
     a32:	8c 91       	ld	r24, X
     a34:	11 97       	sbiw	r26, 0x01	; 1
     a36:	89 7e       	andi	r24, 0xE9	; 233
     a38:	11 96       	adiw	r26, 0x01	; 1
     a3a:	8c 93       	st	X, r24
     a3c:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     a3e:	14 96       	adiw	r26, 0x04	; 4
     a40:	8c 91       	ld	r24, X
     a42:	14 97       	sbiw	r26, 0x04	; 4
     a44:	88 7f       	andi	r24, 0xF8	; 248
     a46:	83 60       	ori	r24, 0x03	; 3
     a48:	14 96       	adiw	r26, 0x04	; 4
     a4a:	8c 93       	st	X, r24
     a4c:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     a4e:	12 96       	adiw	r26, 0x02	; 2
     a50:	8c 91       	ld	r24, X
     a52:	12 97       	sbiw	r26, 0x02	; 2
     a54:	8f 7c       	andi	r24, 0xCF	; 207
     a56:	12 96       	adiw	r26, 0x02	; 2
     a58:	8c 93       	st	X, r24
     a5a:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     a5c:	0f 2e       	mov	r0, r31
     a5e:	f0 e6       	ldi	r31, 0x60	; 96
     a60:	ef 2e       	mov	r14, r31
     a62:	f2 e0       	ldi	r31, 0x02	; 2
     a64:	ff 2e       	mov	r15, r31
     a66:	f0 2d       	mov	r31, r0
     a68:	f7 01       	movw	r30, r14
     a6a:	80 81       	ld	r24, Z
     a6c:	80 7e       	andi	r24, 0xE0	; 224
     a6e:	81 60       	ori	r24, 0x01	; 1
     a70:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     a72:	89 e0       	ldi	r24, 0x09	; 9
     a74:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
     a76:	8c 91       	ld	r24, X
     a78:	81 60       	ori	r24, 0x01	; 1
     a7a:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     a7c:	80 e4       	ldi	r24, 0x40	; 64
     a7e:	92 e0       	ldi	r25, 0x02	; 2
     a80:	0e 94 91 15 	call	0x2b22	; 0x2b22 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     a84:	80 e4       	ldi	r24, 0x40	; 64
     a86:	92 e0       	ldi	r25, 0x02	; 2
     a88:	60 e6       	ldi	r22, 0x60	; 96
     a8a:	72 e0       	ldi	r23, 0x02	; 2
     a8c:	40 e0       	ldi	r20, 0x00	; 0
     a8e:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <ADC_Offset_Get_Unsigned>
     a92:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
     a94:	d8 01       	movw	r26, r16
     a96:	8c 91       	ld	r24, X
     a98:	8e 7f       	andi	r24, 0xFE	; 254
     a9a:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     a9c:	f7 01       	movw	r30, r14
     a9e:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     aa0:	13 96       	adiw	r26, 0x03	; 3
     aa2:	8c 91       	ld	r24, X
     aa4:	13 97       	sbiw	r26, 0x03	; 3
     aa6:	8f 73       	andi	r24, 0x3F	; 63
     aa8:	13 96       	adiw	r26, 0x03	; 3
     aaa:	8c 93       	st	X, r24
     aac:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     aae:	8c 91       	ld	r24, X
     ab0:	81 60       	ori	r24, 0x01	; 1
     ab2:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     ab4:	80 e4       	ldi	r24, 0x40	; 64
     ab6:	92 e0       	ldi	r25, 0x02	; 2
     ab8:	0e 94 91 15 	call	0x2b22	; 0x2b22 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     abc:	d8 01       	movw	r26, r16
     abe:	11 96       	adiw	r26, 0x01	; 1
     ac0:	8c 91       	ld	r24, X
     ac2:	11 97       	sbiw	r26, 0x01	; 1
     ac4:	88 60       	ori	r24, 0x08	; 8
     ac6:	11 96       	adiw	r26, 0x01	; 1
     ac8:	8c 93       	st	X, r24
     aca:	ee 24       	eor	r14, r14
     acc:	ff 24       	eor	r15, r15
     ace:	68 94       	set
     ad0:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     ad2:	44 24       	eor	r4, r4
     ad4:	55 24       	eor	r5, r5
     ad6:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     ad8:	20 e0       	ldi	r18, 0x00	; 0
     ada:	30 e1       	ldi	r19, 0x10	; 16
     adc:	40 e0       	ldi	r20, 0x00	; 0
     ade:	50 e0       	ldi	r21, 0x00	; 0
     ae0:	2a 83       	std	Y+2, r18	; 0x02
     ae2:	3b 83       	std	Y+3, r19	; 0x03
     ae4:	4c 83       	std	Y+4, r20	; 0x04
     ae6:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     ae8:	88 24       	eor	r8, r8
     aea:	99 24       	eor	r9, r9
     aec:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     aee:	00 e6       	ldi	r16, 0x60	; 96
     af0:	12 e0       	ldi	r17, 0x02	; 2
     af2:	d8 01       	movw	r26, r16
     af4:	13 96       	adiw	r26, 0x03	; 3
     af6:	8c 91       	ld	r24, X
     af8:	13 97       	sbiw	r26, 0x03	; 3
     afa:	80 ff       	sbrs	r24, 0
     afc:	fa cf       	rjmp	.-12     	; 0xaf2 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     afe:	69 81       	ldd	r22, Y+1	; 0x01
     b00:	c8 01       	movw	r24, r16
     b02:	0e 94 6d 15 	call	0x2ada	; 0x2ada <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
     b06:	a0 e0       	ldi	r26, 0x00	; 0
     b08:	b0 e0       	ldi	r27, 0x00	; 0
     b0a:	88 0e       	add	r8, r24
     b0c:	99 1e       	adc	r9, r25
     b0e:	aa 1e       	adc	r10, r26
     b10:	bb 1e       	adc	r11, r27
     b12:	48 16       	cp	r4, r24
     b14:	59 06       	cpc	r5, r25
     b16:	6a 06       	cpc	r6, r26
     b18:	7b 06       	cpc	r7, r27
     b1a:	10 f4       	brcc	.+4      	; 0xb20 <CO_collectBatt+0x158>
     b1c:	2c 01       	movw	r4, r24
     b1e:	3d 01       	movw	r6, r26
     b20:	2a 81       	ldd	r18, Y+2	; 0x02
     b22:	3b 81       	ldd	r19, Y+3	; 0x03
     b24:	4c 81       	ldd	r20, Y+4	; 0x04
     b26:	5d 81       	ldd	r21, Y+5	; 0x05
     b28:	82 17       	cp	r24, r18
     b2a:	93 07       	cpc	r25, r19
     b2c:	a4 07       	cpc	r26, r20
     b2e:	b5 07       	cpc	r27, r21
     b30:	20 f4       	brcc	.+8      	; 0xb3a <CO_collectBatt+0x172>
     b32:	8a 83       	std	Y+2, r24	; 0x02
     b34:	9b 83       	std	Y+3, r25	; 0x03
     b36:	ac 83       	std	Y+4, r26	; 0x04
     b38:	bd 83       	std	Y+5, r27	; 0x05
     b3a:	08 94       	sec
     b3c:	e1 08       	sbc	r14, r1
     b3e:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     b40:	e1 14       	cp	r14, r1
     b42:	f1 04       	cpc	r15, r1
     b44:	b1 f6       	brne	.-84     	; 0xaf2 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     b46:	e0 e4       	ldi	r30, 0x40	; 64
     b48:	f2 e0       	ldi	r31, 0x02	; 2
     b4a:	81 81       	ldd	r24, Z+1	; 0x01
     b4c:	87 7f       	andi	r24, 0xF7	; 247
     b4e:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
     b50:	80 81       	ld	r24, Z
     b52:	8e 7f       	andi	r24, 0xFE	; 254
     b54:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     b56:	84 e0       	ldi	r24, 0x04	; 4
     b58:	60 e0       	ldi	r22, 0x00	; 0
     b5a:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
     b64:	c5 01       	movw	r24, r10
     b66:	b4 01       	movw	r22, r8
     b68:	05 2e       	mov	r0, r21
     b6a:	5a e0       	ldi	r21, 0x0A	; 10
     b6c:	96 95       	lsr	r25
     b6e:	87 95       	ror	r24
     b70:	77 95       	ror	r23
     b72:	67 95       	ror	r22
     b74:	5a 95       	dec	r21
     b76:	d1 f7       	brne	.-12     	; 0xb6c <CO_collectBatt+0x1a4>
     b78:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b7a:	28 ee       	ldi	r18, 0xE8	; 232
     b7c:	33 e0       	ldi	r19, 0x03	; 3
     b7e:	40 e0       	ldi	r20, 0x00	; 0
     b80:	50 e0       	ldi	r21, 0x00	; 0
     b82:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
     b86:	0f 2e       	mov	r0, r31
     b88:	ff ef       	ldi	r31, 0xFF	; 255
     b8a:	8f 2e       	mov	r8, r31
     b8c:	ff e0       	ldi	r31, 0x0F	; 15
     b8e:	9f 2e       	mov	r9, r31
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	af 2e       	mov	r10, r31
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	bf 2e       	mov	r11, r31
     b98:	f0 2d       	mov	r31, r0
     b9a:	a5 01       	movw	r20, r10
     b9c:	94 01       	movw	r18, r8
     b9e:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     ba2:	c9 01       	movw	r24, r18
     ba4:	c2 97       	sbiw	r24, 0x32	; 50
     ba6:	ae 81       	ldd	r26, Y+6	; 0x06
     ba8:	bf 81       	ldd	r27, Y+7	; 0x07
     baa:	8d 93       	st	X+, r24
     bac:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     bae:	c3 01       	movw	r24, r6
     bb0:	b2 01       	movw	r22, r4
     bb2:	28 ee       	ldi	r18, 0xE8	; 232
     bb4:	33 e0       	ldi	r19, 0x03	; 3
     bb6:	40 e0       	ldi	r20, 0x00	; 0
     bb8:	50 e0       	ldi	r21, 0x00	; 0
     bba:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
     bbe:	a5 01       	movw	r20, r10
     bc0:	94 01       	movw	r18, r8
     bc2:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     bc6:	c9 01       	movw	r24, r18
     bc8:	c2 97       	sbiw	r24, 0x32	; 50
     bca:	ea 85       	ldd	r30, Y+10	; 0x0a
     bcc:	fb 85       	ldd	r31, Y+11	; 0x0b
     bce:	80 83       	st	Z, r24
     bd0:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     bd2:	6a 81       	ldd	r22, Y+2	; 0x02
     bd4:	7b 81       	ldd	r23, Y+3	; 0x03
     bd6:	8c 81       	ldd	r24, Y+4	; 0x04
     bd8:	9d 81       	ldd	r25, Y+5	; 0x05
     bda:	28 ee       	ldi	r18, 0xE8	; 232
     bdc:	33 e0       	ldi	r19, 0x03	; 3
     bde:	40 e0       	ldi	r20, 0x00	; 0
     be0:	50 e0       	ldi	r21, 0x00	; 0
     be2:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
     be6:	a5 01       	movw	r20, r10
     be8:	94 01       	movw	r18, r8
     bea:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     bee:	22 53       	subi	r18, 0x32	; 50
     bf0:	30 40       	sbci	r19, 0x00	; 0
     bf2:	a8 85       	ldd	r26, Y+8	; 0x08
     bf4:	b9 85       	ldd	r27, Y+9	; 0x09
     bf6:	2d 93       	st	X+, r18
     bf8:	3c 93       	st	X, r19
     bfa:	11 97       	sbiw	r26, 0x01	; 1
}
     bfc:	2b 96       	adiw	r28, 0x0b	; 11
     bfe:	cd bf       	out	0x3d, r28	; 61
     c00:	de bf       	out	0x3e, r29	; 62
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	0f 91       	pop	r16
     c0a:	ff 90       	pop	r15
     c0c:	ef 90       	pop	r14
     c0e:	bf 90       	pop	r11
     c10:	af 90       	pop	r10
     c12:	9f 90       	pop	r9
     c14:	8f 90       	pop	r8
     c16:	7f 90       	pop	r7
     c18:	6f 90       	pop	r6
     c1a:	5f 90       	pop	r5
     c1c:	4f 90       	pop	r4
     c1e:	08 95       	ret

00000c20 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     c20:	4f 92       	push	r4
     c22:	5f 92       	push	r5
     c24:	6f 92       	push	r6
     c26:	7f 92       	push	r7
     c28:	8f 92       	push	r8
     c2a:	9f 92       	push	r9
     c2c:	af 92       	push	r10
     c2e:	bf 92       	push	r11
     c30:	ef 92       	push	r14
     c32:	ff 92       	push	r15
     c34:	0f 93       	push	r16
     c36:	1f 93       	push	r17
     c38:	cf 93       	push	r28
     c3a:	df 93       	push	r29
     c3c:	cd b7       	in	r28, 0x3d	; 61
     c3e:	de b7       	in	r29, 0x3e	; 62
     c40:	2b 97       	sbiw	r28, 0x0b	; 11
     c42:	cd bf       	out	0x3d, r28	; 61
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	8e 83       	std	Y+6, r24	; 0x06
     c48:	9f 83       	std	Y+7, r25	; 0x07
     c4a:	68 87       	std	Y+8, r22	; 0x08
     c4c:	79 87       	std	Y+9, r23	; 0x09
     c4e:	4a 87       	std	Y+10, r20	; 0x0a
     c50:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	92 e0       	ldi	r25, 0x02	; 2
     c5c:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     c60:	00 e0       	ldi	r16, 0x00	; 0
     c62:	12 e0       	ldi	r17, 0x02	; 2
     c64:	d8 01       	movw	r26, r16
     c66:	11 96       	adiw	r26, 0x01	; 1
     c68:	8c 91       	ld	r24, X
     c6a:	11 97       	sbiw	r26, 0x01	; 1
     c6c:	89 7e       	andi	r24, 0xE9	; 233
     c6e:	11 96       	adiw	r26, 0x01	; 1
     c70:	8c 93       	st	X, r24
     c72:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     c74:	14 96       	adiw	r26, 0x04	; 4
     c76:	8c 91       	ld	r24, X
     c78:	14 97       	sbiw	r26, 0x04	; 4
     c7a:	88 7f       	andi	r24, 0xF8	; 248
     c7c:	83 60       	ori	r24, 0x03	; 3
     c7e:	14 96       	adiw	r26, 0x04	; 4
     c80:	8c 93       	st	X, r24
     c82:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     c84:	12 96       	adiw	r26, 0x02	; 2
     c86:	8c 91       	ld	r24, X
     c88:	12 97       	sbiw	r26, 0x02	; 2
     c8a:	8f 7c       	andi	r24, 0xCF	; 207
     c8c:	12 96       	adiw	r26, 0x02	; 2
     c8e:	8c 93       	st	X, r24
     c90:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     c92:	0f 2e       	mov	r0, r31
     c94:	f0 e2       	ldi	r31, 0x20	; 32
     c96:	ef 2e       	mov	r14, r31
     c98:	f2 e0       	ldi	r31, 0x02	; 2
     c9a:	ff 2e       	mov	r15, r31
     c9c:	f0 2d       	mov	r31, r0
     c9e:	f7 01       	movw	r30, r14
     ca0:	80 81       	ld	r24, Z
     ca2:	80 7e       	andi	r24, 0xE0	; 224
     ca4:	81 60       	ori	r24, 0x01	; 1
     ca6:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     ca8:	89 e0       	ldi	r24, 0x09	; 9
     caa:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     cac:	8c 91       	ld	r24, X
     cae:	81 60       	ori	r24, 0x01	; 1
     cb0:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     cb2:	80 e0       	ldi	r24, 0x00	; 0
     cb4:	92 e0       	ldi	r25, 0x02	; 2
     cb6:	0e 94 91 15 	call	0x2b22	; 0x2b22 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     cba:	80 e0       	ldi	r24, 0x00	; 0
     cbc:	92 e0       	ldi	r25, 0x02	; 2
     cbe:	60 e2       	ldi	r22, 0x20	; 32
     cc0:	72 e0       	ldi	r23, 0x02	; 2
     cc2:	40 e0       	ldi	r20, 0x00	; 0
     cc4:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <ADC_Offset_Get_Unsigned>
     cc8:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     cca:	d8 01       	movw	r26, r16
     ccc:	8c 91       	ld	r24, X
     cce:	8e 7f       	andi	r24, 0xFE	; 254
     cd0:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     cd2:	f7 01       	movw	r30, r14
     cd4:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     cd6:	13 96       	adiw	r26, 0x03	; 3
     cd8:	8c 91       	ld	r24, X
     cda:	13 97       	sbiw	r26, 0x03	; 3
     cdc:	8f 73       	andi	r24, 0x3F	; 63
     cde:	13 96       	adiw	r26, 0x03	; 3
     ce0:	8c 93       	st	X, r24
     ce2:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     ce4:	8c 91       	ld	r24, X
     ce6:	81 60       	ori	r24, 0x01	; 1
     ce8:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     cea:	80 e0       	ldi	r24, 0x00	; 0
     cec:	92 e0       	ldi	r25, 0x02	; 2
     cee:	0e 94 91 15 	call	0x2b22	; 0x2b22 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     cf2:	d8 01       	movw	r26, r16
     cf4:	11 96       	adiw	r26, 0x01	; 1
     cf6:	8c 91       	ld	r24, X
     cf8:	11 97       	sbiw	r26, 0x01	; 1
     cfa:	88 60       	ori	r24, 0x08	; 8
     cfc:	11 96       	adiw	r26, 0x01	; 1
     cfe:	8c 93       	st	X, r24
     d00:	ee 24       	eor	r14, r14
     d02:	ff 24       	eor	r15, r15
     d04:	68 94       	set
     d06:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     d08:	44 24       	eor	r4, r4
     d0a:	55 24       	eor	r5, r5
     d0c:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     d0e:	20 e0       	ldi	r18, 0x00	; 0
     d10:	30 e1       	ldi	r19, 0x10	; 16
     d12:	40 e0       	ldi	r20, 0x00	; 0
     d14:	50 e0       	ldi	r21, 0x00	; 0
     d16:	2a 83       	std	Y+2, r18	; 0x02
     d18:	3b 83       	std	Y+3, r19	; 0x03
     d1a:	4c 83       	std	Y+4, r20	; 0x04
     d1c:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     d1e:	88 24       	eor	r8, r8
     d20:	99 24       	eor	r9, r9
     d22:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     d24:	00 e2       	ldi	r16, 0x20	; 32
     d26:	12 e0       	ldi	r17, 0x02	; 2
     d28:	d8 01       	movw	r26, r16
     d2a:	13 96       	adiw	r26, 0x03	; 3
     d2c:	8c 91       	ld	r24, X
     d2e:	13 97       	sbiw	r26, 0x03	; 3
     d30:	80 ff       	sbrs	r24, 0
     d32:	fa cf       	rjmp	.-12     	; 0xd28 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     d34:	69 81       	ldd	r22, Y+1	; 0x01
     d36:	c8 01       	movw	r24, r16
     d38:	0e 94 6d 15 	call	0x2ada	; 0x2ada <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
     d3c:	a0 e0       	ldi	r26, 0x00	; 0
     d3e:	b0 e0       	ldi	r27, 0x00	; 0
     d40:	88 0e       	add	r8, r24
     d42:	99 1e       	adc	r9, r25
     d44:	aa 1e       	adc	r10, r26
     d46:	bb 1e       	adc	r11, r27
     d48:	48 16       	cp	r4, r24
     d4a:	59 06       	cpc	r5, r25
     d4c:	6a 06       	cpc	r6, r26
     d4e:	7b 06       	cpc	r7, r27
     d50:	10 f4       	brcc	.+4      	; 0xd56 <CO_collectTemp+0x136>
     d52:	2c 01       	movw	r4, r24
     d54:	3d 01       	movw	r6, r26
     d56:	2a 81       	ldd	r18, Y+2	; 0x02
     d58:	3b 81       	ldd	r19, Y+3	; 0x03
     d5a:	4c 81       	ldd	r20, Y+4	; 0x04
     d5c:	5d 81       	ldd	r21, Y+5	; 0x05
     d5e:	82 17       	cp	r24, r18
     d60:	93 07       	cpc	r25, r19
     d62:	a4 07       	cpc	r26, r20
     d64:	b5 07       	cpc	r27, r21
     d66:	20 f4       	brcc	.+8      	; 0xd70 <CO_collectTemp+0x150>
     d68:	8a 83       	std	Y+2, r24	; 0x02
     d6a:	9b 83       	std	Y+3, r25	; 0x03
     d6c:	ac 83       	std	Y+4, r26	; 0x04
     d6e:	bd 83       	std	Y+5, r27	; 0x05
     d70:	08 94       	sec
     d72:	e1 08       	sbc	r14, r1
     d74:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     d76:	e1 14       	cp	r14, r1
     d78:	f1 04       	cpc	r15, r1
     d7a:	b1 f6       	brne	.-84     	; 0xd28 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     d7c:	e0 e0       	ldi	r30, 0x00	; 0
     d7e:	f2 e0       	ldi	r31, 0x02	; 2
     d80:	81 81       	ldd	r24, Z+1	; 0x01
     d82:	87 7f       	andi	r24, 0xF7	; 247
     d84:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     d86:	80 81       	ld	r24, Z
     d88:	82 60       	ori	r24, 0x02	; 2
     d8a:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
     d8c:	80 81       	ld	r24, Z
     d8e:	8e 7f       	andi	r24, 0xFE	; 254
     d90:	80 83       	st	Z, r24

	ADCPower(FALSE);
     d92:	80 e0       	ldi	r24, 0x00	; 0
     d94:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>

	average = sum / NUM_SAMPLES;
     d98:	c5 01       	movw	r24, r10
     d9a:	b4 01       	movw	r22, r8
     d9c:	05 2e       	mov	r0, r21
     d9e:	5a e0       	ldi	r21, 0x0A	; 10
     da0:	96 95       	lsr	r25
     da2:	87 95       	ror	r24
     da4:	77 95       	ror	r23
     da6:	67 95       	ror	r22
     da8:	5a 95       	dec	r21
     daa:	d1 f7       	brne	.-12     	; 0xda0 <CO_collectTemp+0x180>
     dac:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     dae:	28 ee       	ldi	r18, 0xE8	; 232
     db0:	33 e0       	ldi	r19, 0x03	; 3
     db2:	40 e0       	ldi	r20, 0x00	; 0
     db4:	50 e0       	ldi	r21, 0x00	; 0
     db6:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
     dba:	0f 2e       	mov	r0, r31
     dbc:	ff ef       	ldi	r31, 0xFF	; 255
     dbe:	8f 2e       	mov	r8, r31
     dc0:	ff e0       	ldi	r31, 0x0F	; 15
     dc2:	9f 2e       	mov	r9, r31
     dc4:	f0 e0       	ldi	r31, 0x00	; 0
     dc6:	af 2e       	mov	r10, r31
     dc8:	f0 e0       	ldi	r31, 0x00	; 0
     dca:	bf 2e       	mov	r11, r31
     dcc:	f0 2d       	mov	r31, r0
     dce:	a5 01       	movw	r20, r10
     dd0:	94 01       	movw	r18, r8
     dd2:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     dd6:	c9 01       	movw	r24, r18
     dd8:	c2 97       	sbiw	r24, 0x32	; 50
     dda:	ae 81       	ldd	r26, Y+6	; 0x06
     ddc:	bf 81       	ldd	r27, Y+7	; 0x07
     dde:	8d 93       	st	X+, r24
     de0:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     de2:	c3 01       	movw	r24, r6
     de4:	b2 01       	movw	r22, r4
     de6:	28 ee       	ldi	r18, 0xE8	; 232
     de8:	33 e0       	ldi	r19, 0x03	; 3
     dea:	40 e0       	ldi	r20, 0x00	; 0
     dec:	50 e0       	ldi	r21, 0x00	; 0
     dee:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
     df2:	a5 01       	movw	r20, r10
     df4:	94 01       	movw	r18, r8
     df6:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     dfa:	c9 01       	movw	r24, r18
     dfc:	c2 97       	sbiw	r24, 0x32	; 50
     dfe:	ea 85       	ldd	r30, Y+10	; 0x0a
     e00:	fb 85       	ldd	r31, Y+11	; 0x0b
     e02:	80 83       	st	Z, r24
     e04:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     e06:	6a 81       	ldd	r22, Y+2	; 0x02
     e08:	7b 81       	ldd	r23, Y+3	; 0x03
     e0a:	8c 81       	ldd	r24, Y+4	; 0x04
     e0c:	9d 81       	ldd	r25, Y+5	; 0x05
     e0e:	28 ee       	ldi	r18, 0xE8	; 232
     e10:	33 e0       	ldi	r19, 0x03	; 3
     e12:	40 e0       	ldi	r20, 0x00	; 0
     e14:	50 e0       	ldi	r21, 0x00	; 0
     e16:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
     e1a:	a5 01       	movw	r20, r10
     e1c:	94 01       	movw	r18, r8
     e1e:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
     e22:	22 53       	subi	r18, 0x32	; 50
     e24:	30 40       	sbci	r19, 0x00	; 0
     e26:	a8 85       	ldd	r26, Y+8	; 0x08
     e28:	b9 85       	ldd	r27, Y+9	; 0x09
     e2a:	2d 93       	st	X+, r18
     e2c:	3c 93       	st	X, r19
     e2e:	11 97       	sbiw	r26, 0x01	; 1
}
     e30:	2b 96       	adiw	r28, 0x0b	; 11
     e32:	cd bf       	out	0x3d, r28	; 61
     e34:	de bf       	out	0x3e, r29	; 62
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	ff 90       	pop	r15
     e40:	ef 90       	pop	r14
     e42:	bf 90       	pop	r11
     e44:	af 90       	pop	r10
     e46:	9f 90       	pop	r9
     e48:	8f 90       	pop	r8
     e4a:	7f 90       	pop	r7
     e4c:	6f 90       	pop	r6
     e4e:	5f 90       	pop	r5
     e50:	4f 90       	pop	r4
     e52:	08 95       	ret

00000e54 <enableADCMUX>:
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	
	if(on) {
     e54:	88 23       	and	r24, r24
     e56:	31 f0       	breq	.+12     	; 0xe64 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
     e58:	e0 e0       	ldi	r30, 0x00	; 0
     e5a:	f6 e0       	ldi	r31, 0x06	; 6
     e5c:	80 e2       	ldi	r24, 0x20	; 32
     e5e:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
     e60:	85 83       	std	Z+5, r24	; 0x05
     e62:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
     e64:	e0 e0       	ldi	r30, 0x00	; 0
     e66:	f6 e0       	ldi	r31, 0x06	; 6
     e68:	80 e2       	ldi	r24, 0x20	; 32
     e6a:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     e6c:	82 83       	std	Z+2, r24	; 0x02
     e6e:	08 95       	ret

00000e70 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
     e70:	1f 92       	push	r1
     e72:	0f 92       	push	r0
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	0f 92       	push	r0
     e78:	0b b6       	in	r0, 0x3b	; 59
     e7a:	0f 92       	push	r0
     e7c:	11 24       	eor	r1, r1
     e7e:	2f 93       	push	r18
     e80:	3f 93       	push	r19
     e82:	4f 93       	push	r20
     e84:	5f 93       	push	r21
     e86:	6f 93       	push	r22
     e88:	7f 93       	push	r23
     e8a:	8f 93       	push	r24
     e8c:	9f 93       	push	r25
     e8e:	af 93       	push	r26
     e90:	bf 93       	push	r27
     e92:	ef 93       	push	r30
     e94:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     e96:	e0 e4       	ldi	r30, 0x40	; 64
     e98:	fa e0       	ldi	r31, 0x0A	; 10
     e9a:	80 81       	ld	r24, Z
     e9c:	80 7f       	andi	r24, 0xF0	; 240
     e9e:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     ea0:	a0 e0       	ldi	r26, 0x00	; 0
     ea2:	b8 e0       	ldi	r27, 0x08	; 8
     ea4:	8c 91       	ld	r24, X
     ea6:	80 7f       	andi	r24, 0xF0	; 240
     ea8:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     eaa:	a0 e0       	ldi	r26, 0x00	; 0
     eac:	b9 e0       	ldi	r27, 0x09	; 9
     eae:	8c 91       	ld	r24, X
     eb0:	80 7f       	andi	r24, 0xF0	; 240
     eb2:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     eb4:	80 81       	ld	r24, Z
     eb6:	80 7f       	andi	r24, 0xF0	; 240
     eb8:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
     ec2:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	enableADCMUX(FALSE);
     ec6:	80 e0       	ldi	r24, 0x00	; 0
     ec8:	0e 94 2a 07 	call	0xe54	; 0xe54 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
     ecc:	81 e0       	ldi	r24, 0x01	; 1
     ece:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     ed2:	80 93 d5 21 	sts	0x21D5, r24
}
     ed6:	ff 91       	pop	r31
     ed8:	ef 91       	pop	r30
     eda:	bf 91       	pop	r27
     edc:	af 91       	pop	r26
     ede:	9f 91       	pop	r25
     ee0:	8f 91       	pop	r24
     ee2:	7f 91       	pop	r23
     ee4:	6f 91       	pop	r22
     ee6:	5f 91       	pop	r21
     ee8:	4f 91       	pop	r20
     eea:	3f 91       	pop	r19
     eec:	2f 91       	pop	r18
     eee:	0f 90       	pop	r0
     ef0:	0b be       	out	0x3b, r0	; 59
     ef2:	0f 90       	pop	r0
     ef4:	0f be       	out	0x3f, r0	; 63
     ef6:	0f 90       	pop	r0
     ef8:	1f 90       	pop	r1
     efa:	18 95       	reti

00000efc <ADC_Stop_Sampling>:
//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     efc:	e0 e4       	ldi	r30, 0x40	; 64
     efe:	fa e0       	ldi	r31, 0x0A	; 10
     f00:	80 81       	ld	r24, Z
     f02:	80 7f       	andi	r24, 0xF0	; 240
     f04:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f06:	a0 e0       	ldi	r26, 0x00	; 0
     f08:	b8 e0       	ldi	r27, 0x08	; 8
     f0a:	8c 91       	ld	r24, X
     f0c:	80 7f       	andi	r24, 0xF0	; 240
     f0e:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f10:	a0 e0       	ldi	r26, 0x00	; 0
     f12:	b9 e0       	ldi	r27, 0x09	; 9
     f14:	8c 91       	ld	r24, X
     f16:	80 7f       	andi	r24, 0xF0	; 240
     f18:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f1a:	80 81       	ld	r24, Z
     f1c:	80 7f       	andi	r24, 0xF0	; 240
     f1e:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     f22:	80 e0       	ldi	r24, 0x00	; 0
     f24:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
     f28:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	enableADCMUX(FALSE);
     f2c:	80 e0       	ldi	r24, 0x00	; 0
     f2e:	0e 94 2a 07 	call	0xe54	; 0xe54 <enableADCMUX>
	ADC_Sampling_Finished = 1;
     f32:	81 e0       	ldi	r24, 0x01	; 1
     f34:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     f38:	80 93 d5 21 	sts	0x21D5, r24
}
     f3c:	08 95       	ret

00000f3e <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
     f42:	0f 92       	push	r0
     f44:	0f 92       	push	r0
     f46:	cd b7       	in	r28, 0x3d	; 61
     f48:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
     f4a:	80 91 cd 50 	lds	r24, 0x50CD
     f4e:	88 23       	and	r24, r24
     f50:	89 f0       	breq	.+34     	; 0xf74 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
     f52:	e0 e4       	ldi	r30, 0x40	; 64
     f54:	f8 e0       	ldi	r31, 0x08	; 8
     f56:	80 a1       	lds	r24, 0x40
     f58:	91 a1       	lds	r25, 0x41
     f5a:	89 83       	std	Y+1, r24	; 0x01
     f5c:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
     f5e:	89 81       	ldd	r24, Y+1	; 0x01
     f60:	9a 81       	ldd	r25, Y+2	; 0x02
     f62:	00 97       	sbiw	r24, 0x00	; 0
     f64:	21 f4       	brne	.+8      	; 0xf6e <ADC_Get_Num_Samples+0x30>
     f66:	86 a1       	lds	r24, 0x46
     f68:	97 a1       	lds	r25, 0x47
     f6a:	89 83       	std	Y+1, r24	; 0x01
     f6c:	9a 83       	std	Y+2, r25	; 0x02
		return count;
     f6e:	89 81       	ldd	r24, Y+1	; 0x01
     f70:	9a 81       	ldd	r25, Y+2	; 0x02
     f72:	02 c0       	rjmp	.+4      	; 0xf78 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	90 e0       	ldi	r25, 0x00	; 0
}
     f78:	0f 90       	pop	r0
     f7a:	0f 90       	pop	r0
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	08 95       	ret

00000f82 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
     f82:	e0 ea       	ldi	r30, 0xA0	; 160
     f84:	f6 e0       	ldi	r31, 0x06	; 6
     f86:	13 86       	std	Z+11, r1	; 0x0b
}
     f88:	08 95       	ret

00000f8a <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
     f8a:	81 e0       	ldi	r24, 0x01	; 1
     f8c:	e0 ea       	ldi	r30, 0xA0	; 160
     f8e:	f6 e0       	ldi	r31, 0x06	; 6
     f90:	83 87       	std	Z+11, r24	; 0x0b
}	
     f92:	08 95       	ret

00000f94 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
     f94:	1f 92       	push	r1
     f96:	0f 92       	push	r0
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	0f 92       	push	r0
     f9c:	0b b6       	in	r0, 0x3b	; 59
     f9e:	0f 92       	push	r0
     fa0:	11 24       	eor	r1, r1
     fa2:	6f 92       	push	r6
     fa4:	7f 92       	push	r7
     fa6:	8f 92       	push	r8
     fa8:	9f 92       	push	r9
     faa:	af 92       	push	r10
     fac:	bf 92       	push	r11
     fae:	cf 92       	push	r12
     fb0:	df 92       	push	r13
     fb2:	ef 92       	push	r14
     fb4:	ff 92       	push	r15
     fb6:	0f 93       	push	r16
     fb8:	1f 93       	push	r17
     fba:	2f 93       	push	r18
     fbc:	3f 93       	push	r19
     fbe:	4f 93       	push	r20
     fc0:	5f 93       	push	r21
     fc2:	6f 93       	push	r22
     fc4:	7f 93       	push	r23
     fc6:	8f 93       	push	r24
     fc8:	9f 93       	push	r25
     fca:	af 93       	push	r26
     fcc:	bf 93       	push	r27
     fce:	ef 93       	push	r30
     fd0:	ff 93       	push	r31
     fd2:	cf 93       	push	r28
     fd4:	df 93       	push	r29
     fd6:	cd b7       	in	r28, 0x3d	; 61
     fd8:	de b7       	in	r29, 0x3e	; 62
     fda:	2c 97       	sbiw	r28, 0x0c	; 12
     fdc:	cd bf       	out	0x3d, r28	; 61
     fde:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
     fe0:	80 91 5d 40 	lds	r24, 0x405D
     fe4:	88 23       	and	r24, r24
     fe6:	8c f0       	brlt	.+34     	; 0x100a <__vector_104+0x76>
		discardCount++;
     fe8:	80 91 5d 40 	lds	r24, 0x405D
     fec:	8f 5f       	subi	r24, 0xFF	; 255
     fee:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
     ff2:	80 91 5d 40 	lds	r24, 0x405D
     ff6:	80 38       	cpi	r24, 0x80	; 128
     ff8:	09 f0       	breq	.+2      	; 0xffc <__vector_104+0x68>
     ffa:	b4 c0       	rjmp	.+360    	; 0x1164 <__vector_104+0x1d0>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
     ffc:	e0 e4       	ldi	r30, 0x40	; 64
     ffe:	f8 e0       	ldi	r31, 0x08	; 8
    1000:	80 81       	ld	r24, Z
    1002:	80 7f       	andi	r24, 0xF0	; 240
    1004:	89 60       	ori	r24, 0x09	; 9
    1006:	80 83       	st	Z, r24
    1008:	ad c0       	rjmp	.+346    	; 0x1164 <__vector_104+0x1d0>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1010:	82 e0       	ldi	r24, 0x02	; 2
    1012:	e0 ea       	ldi	r30, 0xA0	; 160
    1014:	f6 e0       	ldi	r31, 0x06	; 6
    1016:	86 83       	std	Z+6, r24	; 0x06
    1018:	80 e0       	ldi	r24, 0x00	; 0
    101a:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    101c:	e0 ec       	ldi	r30, 0xC0	; 192
    101e:	f8 e0       	ldi	r31, 0x08	; 8
    1020:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1022:	25 e6       	ldi	r18, 0x65	; 101
    1024:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1026:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1028:	42 81       	ldd	r20, Z+2	; 0x02
    102a:	44 23       	and	r20, r20
    102c:	ec f7       	brge	.-6      	; 0x1028 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    102e:	43 81       	ldd	r20, Z+3	; 0x03
    1030:	d9 01       	movw	r26, r18
    1032:	a8 0f       	add	r26, r24
    1034:	b9 1f       	adc	r27, r25
    1036:	4c 93       	st	X, r20
    1038:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	99 f7       	brne	.-26     	; 0x1026 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1040:	82 e0       	ldi	r24, 0x02	; 2
    1042:	e0 ea       	ldi	r30, 0xA0	; 160
    1044:	f6 e0       	ldi	r31, 0x06	; 6
    1046:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1048:	80 e0       	ldi	r24, 0x00	; 0
    104a:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    104e:	80 91 65 50 	lds	r24, 0x5065
    1052:	88 23       	and	r24, r24
    1054:	1c f4       	brge	.+6      	; 0x105c <__vector_104+0xc8>
    1056:	8f ef       	ldi	r24, 0xFF	; 255
    1058:	8c 83       	std	Y+4, r24	; 0x04
    105a:	01 c0       	rjmp	.+2      	; 0x105e <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    105c:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    105e:	80 91 65 50 	lds	r24, 0x5065
    1062:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1064:	80 91 66 50 	lds	r24, 0x5066
    1068:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    106a:	80 91 67 50 	lds	r24, 0x5067
    106e:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1070:	89 81       	ldd	r24, Y+1	; 0x01
    1072:	9a 81       	ldd	r25, Y+2	; 0x02
    1074:	ab 81       	ldd	r26, Y+3	; 0x03
    1076:	bc 81       	ldd	r27, Y+4	; 0x04
    1078:	ac 01       	movw	r20, r24
    107a:	bd 01       	movw	r22, r26
    107c:	77 0f       	add	r23, r23
    107e:	44 0b       	sbc	r20, r20
    1080:	54 2f       	mov	r21, r20
    1082:	ba 01       	movw	r22, r20
    1084:	8d 83       	std	Y+5, r24	; 0x05
    1086:	9e 83       	std	Y+6, r25	; 0x06
    1088:	af 83       	std	Y+7, r26	; 0x07
    108a:	b8 87       	std	Y+8, r27	; 0x08
    108c:	49 87       	std	Y+9, r20	; 0x09
    108e:	4a 87       	std	Y+10, r20	; 0x0a
    1090:	4b 87       	std	Y+11, r20	; 0x0b
    1092:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1094:	80 90 74 50 	lds	r8, 0x5074
    1098:	90 90 75 50 	lds	r9, 0x5075
    109c:	a0 90 76 50 	lds	r10, 0x5076
    10a0:	b0 90 77 50 	lds	r11, 0x5077
    10a4:	2d 81       	ldd	r18, Y+5	; 0x05
    10a6:	3e 81       	ldd	r19, Y+6	; 0x06
    10a8:	4f 81       	ldd	r20, Y+7	; 0x07
    10aa:	58 85       	ldd	r21, Y+8	; 0x08
    10ac:	69 85       	ldd	r22, Y+9	; 0x09
    10ae:	7a 85       	ldd	r23, Y+10	; 0x0a
    10b0:	8b 85       	ldd	r24, Y+11	; 0x0b
    10b2:	9c 85       	ldd	r25, Y+12	; 0x0c
    10b4:	f4 01       	movw	r30, r8
    10b6:	ee 0f       	add	r30, r30
    10b8:	ff 1f       	adc	r31, r31
    10ba:	ee 0f       	add	r30, r30
    10bc:	ff 1f       	adc	r31, r31
    10be:	60 90 72 50 	lds	r6, 0x5072
    10c2:	70 90 73 50 	lds	r7, 0x5073
    10c6:	6e 0e       	add	r6, r30
    10c8:	7f 1e       	adc	r7, r31
    10ca:	0f 2e       	mov	r0, r31
    10cc:	f0 ea       	ldi	r31, 0xA0	; 160
    10ce:	af 2e       	mov	r10, r31
    10d0:	f0 2d       	mov	r31, r0
    10d2:	0f 2e       	mov	r0, r31
    10d4:	f5 e2       	ldi	r31, 0x25	; 37
    10d6:	bf 2e       	mov	r11, r31
    10d8:	f0 2d       	mov	r31, r0
    10da:	0f 2e       	mov	r0, r31
    10dc:	f6 e2       	ldi	r31, 0x26	; 38
    10de:	cf 2e       	mov	r12, r31
    10e0:	f0 2d       	mov	r31, r0
    10e2:	dd 24       	eor	r13, r13
    10e4:	ee 24       	eor	r14, r14
    10e6:	ff 24       	eor	r15, r15
    10e8:	00 e0       	ldi	r16, 0x00	; 0
    10ea:	10 e0       	ldi	r17, 0x00	; 0
    10ec:	0e 94 5b 2f 	call	0x5eb6	; 0x5eb6 <__muldi3>
    10f0:	aa 24       	eor	r10, r10
    10f2:	aa 94       	dec	r10
    10f4:	bb 24       	eor	r11, r11
    10f6:	ba 94       	dec	r11
    10f8:	0f 2e       	mov	r0, r31
    10fa:	ff e7       	ldi	r31, 0x7F	; 127
    10fc:	cf 2e       	mov	r12, r31
    10fe:	f0 2d       	mov	r31, r0
    1100:	0e 94 0a 31 	call	0x6214	; 0x6214 <__divdi3>
    1104:	01 e0       	ldi	r16, 0x01	; 1
    1106:	0e 94 2e 30 	call	0x605c	; 0x605c <__ashldi3>
    110a:	0f 2e       	mov	r0, r31
    110c:	f3 e0       	ldi	r31, 0x03	; 3
    110e:	af 2e       	mov	r10, r31
    1110:	f0 2d       	mov	r31, r0
    1112:	bb 24       	eor	r11, r11
    1114:	cc 24       	eor	r12, r12
    1116:	00 e0       	ldi	r16, 0x00	; 0
    1118:	0e 94 0a 31 	call	0x6214	; 0x6214 <__divdi3>
    111c:	82 2e       	mov	r8, r18
    111e:	93 2e       	mov	r9, r19
    1120:	a4 2e       	mov	r10, r20
    1122:	b5 2e       	mov	r11, r21
    1124:	b0 94       	com	r11
    1126:	a0 94       	com	r10
    1128:	90 94       	com	r9
    112a:	80 94       	com	r8
    112c:	81 1c       	adc	r8, r1
    112e:	91 1c       	adc	r9, r1
    1130:	a1 1c       	adc	r10, r1
    1132:	b1 1c       	adc	r11, r1
    1134:	f3 01       	movw	r30, r6
    1136:	80 82       	st	Z, r8
    1138:	91 82       	std	Z+1, r9	; 0x01
    113a:	a2 82       	std	Z+2, r10	; 0x02
    113c:	b3 82       	std	Z+3, r11	; 0x03
		sampleCount++;
    113e:	80 91 74 50 	lds	r24, 0x5074
    1142:	90 91 75 50 	lds	r25, 0x5075
    1146:	a0 91 76 50 	lds	r26, 0x5076
    114a:	b0 91 77 50 	lds	r27, 0x5077
    114e:	01 96       	adiw	r24, 0x01	; 1
    1150:	a1 1d       	adc	r26, r1
    1152:	b1 1d       	adc	r27, r1
    1154:	80 93 74 50 	sts	0x5074, r24
    1158:	90 93 75 50 	sts	0x5075, r25
    115c:	a0 93 76 50 	sts	0x5076, r26
    1160:	b0 93 77 50 	sts	0x5077, r27
	}
}
    1164:	2c 96       	adiw	r28, 0x0c	; 12
    1166:	cd bf       	out	0x3d, r28	; 61
    1168:	de bf       	out	0x3e, r29	; 62
    116a:	df 91       	pop	r29
    116c:	cf 91       	pop	r28
    116e:	ff 91       	pop	r31
    1170:	ef 91       	pop	r30
    1172:	bf 91       	pop	r27
    1174:	af 91       	pop	r26
    1176:	9f 91       	pop	r25
    1178:	8f 91       	pop	r24
    117a:	7f 91       	pop	r23
    117c:	6f 91       	pop	r22
    117e:	5f 91       	pop	r21
    1180:	4f 91       	pop	r20
    1182:	3f 91       	pop	r19
    1184:	2f 91       	pop	r18
    1186:	1f 91       	pop	r17
    1188:	0f 91       	pop	r16
    118a:	ff 90       	pop	r15
    118c:	ef 90       	pop	r14
    118e:	df 90       	pop	r13
    1190:	cf 90       	pop	r12
    1192:	bf 90       	pop	r11
    1194:	af 90       	pop	r10
    1196:	9f 90       	pop	r9
    1198:	8f 90       	pop	r8
    119a:	7f 90       	pop	r7
    119c:	6f 90       	pop	r6
    119e:	0f 90       	pop	r0
    11a0:	0b be       	out	0x3b, r0	; 59
    11a2:	0f 90       	pop	r0
    11a4:	0f be       	out	0x3f, r0	; 63
    11a6:	0f 90       	pop	r0
    11a8:	1f 90       	pop	r1
    11aa:	18 95       	reti

000011ac <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    11ac:	88 23       	and	r24, r24
    11ae:	49 f0       	breq	.+18     	; 0x11c2 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    11b0:	80 e2       	ldi	r24, 0x20	; 32
    11b2:	60 e0       	ldi	r22, 0x00	; 0
    11b4:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    11b8:	80 e2       	ldi	r24, 0x20	; 32
    11ba:	60 e0       	ldi	r22, 0x00	; 0
    11bc:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
    11c0:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    11c2:	80 e2       	ldi	r24, 0x20	; 32
    11c4:	60 e0       	ldi	r22, 0x00	; 0
    11c6:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <PortEx_DIRCLR>
    11ca:	08 95       	ret

000011cc <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    11cc:	1f 92       	push	r1
    11ce:	0f 92       	push	r0
    11d0:	0f b6       	in	r0, 0x3f	; 63
    11d2:	0f 92       	push	r0
    11d4:	0b b6       	in	r0, 0x3b	; 59
    11d6:	0f 92       	push	r0
    11d8:	11 24       	eor	r1, r1
    11da:	6f 92       	push	r6
    11dc:	7f 92       	push	r7
    11de:	8f 92       	push	r8
    11e0:	9f 92       	push	r9
    11e2:	af 92       	push	r10
    11e4:	bf 92       	push	r11
    11e6:	cf 92       	push	r12
    11e8:	df 92       	push	r13
    11ea:	ef 92       	push	r14
    11ec:	ff 92       	push	r15
    11ee:	0f 93       	push	r16
    11f0:	1f 93       	push	r17
    11f2:	2f 93       	push	r18
    11f4:	3f 93       	push	r19
    11f6:	4f 93       	push	r20
    11f8:	5f 93       	push	r21
    11fa:	6f 93       	push	r22
    11fc:	7f 93       	push	r23
    11fe:	8f 93       	push	r24
    1200:	9f 93       	push	r25
    1202:	af 93       	push	r26
    1204:	bf 93       	push	r27
    1206:	ef 93       	push	r30
    1208:	ff 93       	push	r31
    120a:	cf 93       	push	r28
    120c:	df 93       	push	r29
    120e:	cd b7       	in	r28, 0x3d	; 61
    1210:	de b7       	in	r29, 0x3e	; 62
    1212:	2c 97       	sbiw	r28, 0x0c	; 12
    1214:	cd bf       	out	0x3d, r28	; 61
    1216:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1218:	19 82       	std	Y+1, r1	; 0x01
    121a:	1a 82       	std	Y+2, r1	; 0x02
    121c:	1b 82       	std	Y+3, r1	; 0x03
    121e:	1c 82       	std	Y+4, r1	; 0x04
    1220:	1d 82       	std	Y+5, r1	; 0x05
    1222:	1e 82       	std	Y+6, r1	; 0x06
    1224:	1f 82       	std	Y+7, r1	; 0x07
    1226:	18 86       	std	Y+8, r1	; 0x08
    1228:	80 e0       	ldi	r24, 0x00	; 0
    122a:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    122c:	25 e6       	ldi	r18, 0x65	; 101
    122e:	30 e5       	ldi	r19, 0x50	; 80
    1230:	aa 24       	eor	r10, r10
    1232:	aa 94       	dec	r10
    1234:	ac 01       	movw	r20, r24
    1236:	f9 01       	movw	r30, r18
    1238:	e8 0f       	add	r30, r24
    123a:	f9 1f       	adc	r31, r25
    123c:	60 81       	ld	r22, Z
    123e:	66 23       	and	r22, r22
    1240:	14 f4       	brge	.+4      	; 0x1246 <__vector_14+0x7a>
    1242:	ac 86       	std	Y+12, r10	; 0x0c
    1244:	01 c0       	rjmp	.+2      	; 0x1248 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1246:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1248:	42 0f       	add	r20, r18
    124a:	53 1f       	adc	r21, r19
    124c:	fa 01       	movw	r30, r20
    124e:	40 81       	ld	r20, Z
    1250:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1252:	fc 01       	movw	r30, r24
    1254:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1256:	e2 0f       	add	r30, r18
    1258:	f3 1f       	adc	r31, r19
    125a:	40 81       	ld	r20, Z
    125c:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    125e:	fc 01       	movw	r30, r24
    1260:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1262:	e2 0f       	add	r30, r18
    1264:	f3 1f       	adc	r31, r19
    1266:	40 81       	ld	r20, Z
    1268:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    126a:	49 85       	ldd	r20, Y+9	; 0x09
    126c:	5a 85       	ldd	r21, Y+10	; 0x0a
    126e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1270:	7c 85       	ldd	r23, Y+12	; 0x0c
    1272:	b9 80       	ldd	r11, Y+1	; 0x01
    1274:	ca 80       	ldd	r12, Y+2	; 0x02
    1276:	db 80       	ldd	r13, Y+3	; 0x03
    1278:	ec 80       	ldd	r14, Y+4	; 0x04
    127a:	fd 80       	ldd	r15, Y+5	; 0x05
    127c:	0e 81       	ldd	r16, Y+6	; 0x06
    127e:	1f 81       	ldd	r17, Y+7	; 0x07
    1280:	88 84       	ldd	r8, Y+8	; 0x08
    1282:	b4 2f       	mov	r27, r20
    1284:	a5 2f       	mov	r26, r21
    1286:	f6 2f       	mov	r31, r22
    1288:	e7 2f       	mov	r30, r23
    128a:	77 0f       	add	r23, r23
    128c:	44 0b       	sbc	r20, r20
    128e:	54 2f       	mov	r21, r20
    1290:	ba 01       	movw	r22, r20
    1292:	64 2e       	mov	r6, r20
    1294:	74 2e       	mov	r7, r20
    1296:	94 2e       	mov	r9, r20
    1298:	bb 0e       	add	r11, r27
    129a:	61 e0       	ldi	r22, 0x01	; 1
    129c:	bb 16       	cp	r11, r27
    129e:	08 f0       	brcs	.+2      	; 0x12a2 <__vector_14+0xd6>
    12a0:	60 e0       	ldi	r22, 0x00	; 0
    12a2:	ca 0e       	add	r12, r26
    12a4:	51 e0       	ldi	r21, 0x01	; 1
    12a6:	ca 16       	cp	r12, r26
    12a8:	08 f0       	brcs	.+2      	; 0x12ac <__vector_14+0xe0>
    12aa:	50 e0       	ldi	r21, 0x00	; 0
    12ac:	a6 2f       	mov	r26, r22
    12ae:	ac 0d       	add	r26, r12
    12b0:	61 e0       	ldi	r22, 0x01	; 1
    12b2:	ac 15       	cp	r26, r12
    12b4:	08 f0       	brcs	.+2      	; 0x12b8 <__vector_14+0xec>
    12b6:	60 e0       	ldi	r22, 0x00	; 0
    12b8:	56 2b       	or	r21, r22
    12ba:	df 0e       	add	r13, r31
    12bc:	61 e0       	ldi	r22, 0x01	; 1
    12be:	df 16       	cp	r13, r31
    12c0:	08 f0       	brcs	.+2      	; 0x12c4 <__vector_14+0xf8>
    12c2:	60 e0       	ldi	r22, 0x00	; 0
    12c4:	f5 2f       	mov	r31, r21
    12c6:	fd 0d       	add	r31, r13
    12c8:	51 e0       	ldi	r21, 0x01	; 1
    12ca:	fd 15       	cp	r31, r13
    12cc:	08 f0       	brcs	.+2      	; 0x12d0 <__vector_14+0x104>
    12ce:	50 e0       	ldi	r21, 0x00	; 0
    12d0:	65 2b       	or	r22, r21
    12d2:	ee 0e       	add	r14, r30
    12d4:	51 e0       	ldi	r21, 0x01	; 1
    12d6:	ee 16       	cp	r14, r30
    12d8:	08 f0       	brcs	.+2      	; 0x12dc <__vector_14+0x110>
    12da:	50 e0       	ldi	r21, 0x00	; 0
    12dc:	e6 2f       	mov	r30, r22
    12de:	ee 0d       	add	r30, r14
    12e0:	61 e0       	ldi	r22, 0x01	; 1
    12e2:	ee 15       	cp	r30, r14
    12e4:	08 f0       	brcs	.+2      	; 0x12e8 <__vector_14+0x11c>
    12e6:	60 e0       	ldi	r22, 0x00	; 0
    12e8:	56 2b       	or	r21, r22
    12ea:	f6 0c       	add	r15, r6
    12ec:	71 e0       	ldi	r23, 0x01	; 1
    12ee:	f6 14       	cp	r15, r6
    12f0:	08 f0       	brcs	.+2      	; 0x12f4 <__vector_14+0x128>
    12f2:	70 e0       	ldi	r23, 0x00	; 0
    12f4:	b5 2f       	mov	r27, r21
    12f6:	bf 0d       	add	r27, r15
    12f8:	51 e0       	ldi	r21, 0x01	; 1
    12fa:	bf 15       	cp	r27, r15
    12fc:	08 f0       	brcs	.+2      	; 0x1300 <__vector_14+0x134>
    12fe:	50 e0       	ldi	r21, 0x00	; 0
    1300:	75 2b       	or	r23, r21
    1302:	07 0d       	add	r16, r7
    1304:	61 e0       	ldi	r22, 0x01	; 1
    1306:	07 15       	cp	r16, r7
    1308:	08 f0       	brcs	.+2      	; 0x130c <__vector_14+0x140>
    130a:	60 e0       	ldi	r22, 0x00	; 0
    130c:	70 0f       	add	r23, r16
    130e:	51 e0       	ldi	r21, 0x01	; 1
    1310:	70 17       	cp	r23, r16
    1312:	08 f0       	brcs	.+2      	; 0x1316 <__vector_14+0x14a>
    1314:	50 e0       	ldi	r21, 0x00	; 0
    1316:	65 2b       	or	r22, r21
    1318:	19 0d       	add	r17, r9
    131a:	51 e0       	ldi	r21, 0x01	; 1
    131c:	19 15       	cp	r17, r9
    131e:	08 f0       	brcs	.+2      	; 0x1322 <__vector_14+0x156>
    1320:	50 e0       	ldi	r21, 0x00	; 0
    1322:	61 0f       	add	r22, r17
    1324:	01 e0       	ldi	r16, 0x01	; 1
    1326:	61 17       	cp	r22, r17
    1328:	08 f0       	brcs	.+2      	; 0x132c <__vector_14+0x160>
    132a:	00 e0       	ldi	r16, 0x00	; 0
    132c:	50 2b       	or	r21, r16
    132e:	48 0d       	add	r20, r8
    1330:	54 0f       	add	r21, r20
    1332:	b9 82       	std	Y+1, r11	; 0x01
    1334:	aa 83       	std	Y+2, r26	; 0x02
    1336:	fb 83       	std	Y+3, r31	; 0x03
    1338:	ec 83       	std	Y+4, r30	; 0x04
    133a:	bd 83       	std	Y+5, r27	; 0x05
    133c:	7e 83       	std	Y+6, r23	; 0x06
    133e:	6f 83       	std	Y+7, r22	; 0x07
    1340:	58 87       	std	Y+8, r21	; 0x08
    1342:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1344:	8c 30       	cpi	r24, 0x0C	; 12
    1346:	91 05       	cpc	r25, r1
    1348:	09 f0       	breq	.+2      	; 0x134c <__vector_14+0x180>
    134a:	74 cf       	rjmp	.-280    	; 0x1234 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    134c:	e9 80       	ldd	r14, Y+1	; 0x01
    134e:	fa 80       	ldd	r15, Y+2	; 0x02
    1350:	0b 81       	ldd	r16, Y+3	; 0x03
    1352:	1c 81       	ldd	r17, Y+4	; 0x04
    1354:	bd 81       	ldd	r27, Y+5	; 0x05
    1356:	ae 81       	ldd	r26, Y+6	; 0x06
    1358:	ff 81       	ldd	r31, Y+7	; 0x07
    135a:	e8 85       	ldd	r30, Y+8	; 0x08
    135c:	2e 2d       	mov	r18, r14
    135e:	3f 2d       	mov	r19, r15
    1360:	40 2f       	mov	r20, r16
    1362:	51 2f       	mov	r21, r17
    1364:	6b 2f       	mov	r22, r27
    1366:	7a 2f       	mov	r23, r26
    1368:	8f 2f       	mov	r24, r31
    136a:	9e 2f       	mov	r25, r30
    136c:	ee 23       	and	r30, r30
    136e:	0c f0       	brlt	.+2      	; 0x1372 <__vector_14+0x1a6>
    1370:	4a c0       	rjmp	.+148    	; 0x1406 <__vector_14+0x23a>
    1372:	93 e0       	ldi	r25, 0x03	; 3
    1374:	e9 0e       	add	r14, r25
    1376:	91 e0       	ldi	r25, 0x01	; 1
    1378:	e2 16       	cp	r14, r18
    137a:	08 f0       	brcs	.+2      	; 0x137e <__vector_14+0x1b2>
    137c:	90 e0       	ldi	r25, 0x00	; 0
    137e:	21 e0       	ldi	r18, 0x01	; 1
    1380:	f3 16       	cp	r15, r19
    1382:	08 f0       	brcs	.+2      	; 0x1386 <__vector_14+0x1ba>
    1384:	20 e0       	ldi	r18, 0x00	; 0
    1386:	39 2f       	mov	r19, r25
    1388:	3f 0d       	add	r19, r15
    138a:	91 e0       	ldi	r25, 0x01	; 1
    138c:	3f 15       	cp	r19, r15
    138e:	08 f0       	brcs	.+2      	; 0x1392 <__vector_14+0x1c6>
    1390:	90 e0       	ldi	r25, 0x00	; 0
    1392:	29 2b       	or	r18, r25
    1394:	91 e0       	ldi	r25, 0x01	; 1
    1396:	04 17       	cp	r16, r20
    1398:	08 f0       	brcs	.+2      	; 0x139c <__vector_14+0x1d0>
    139a:	90 e0       	ldi	r25, 0x00	; 0
    139c:	42 2f       	mov	r20, r18
    139e:	40 0f       	add	r20, r16
    13a0:	21 e0       	ldi	r18, 0x01	; 1
    13a2:	40 17       	cp	r20, r16
    13a4:	08 f0       	brcs	.+2      	; 0x13a8 <__vector_14+0x1dc>
    13a6:	20 e0       	ldi	r18, 0x00	; 0
    13a8:	92 2b       	or	r25, r18
    13aa:	21 e0       	ldi	r18, 0x01	; 1
    13ac:	15 17       	cp	r17, r21
    13ae:	08 f0       	brcs	.+2      	; 0x13b2 <__vector_14+0x1e6>
    13b0:	20 e0       	ldi	r18, 0x00	; 0
    13b2:	59 2f       	mov	r21, r25
    13b4:	51 0f       	add	r21, r17
    13b6:	91 e0       	ldi	r25, 0x01	; 1
    13b8:	51 17       	cp	r21, r17
    13ba:	08 f0       	brcs	.+2      	; 0x13be <__vector_14+0x1f2>
    13bc:	90 e0       	ldi	r25, 0x00	; 0
    13be:	29 2b       	or	r18, r25
    13c0:	91 e0       	ldi	r25, 0x01	; 1
    13c2:	b6 17       	cp	r27, r22
    13c4:	08 f0       	brcs	.+2      	; 0x13c8 <__vector_14+0x1fc>
    13c6:	90 e0       	ldi	r25, 0x00	; 0
    13c8:	62 2f       	mov	r22, r18
    13ca:	6b 0f       	add	r22, r27
    13cc:	21 e0       	ldi	r18, 0x01	; 1
    13ce:	6b 17       	cp	r22, r27
    13d0:	08 f0       	brcs	.+2      	; 0x13d4 <__vector_14+0x208>
    13d2:	20 e0       	ldi	r18, 0x00	; 0
    13d4:	92 2b       	or	r25, r18
    13d6:	21 e0       	ldi	r18, 0x01	; 1
    13d8:	a7 17       	cp	r26, r23
    13da:	08 f0       	brcs	.+2      	; 0x13de <__vector_14+0x212>
    13dc:	20 e0       	ldi	r18, 0x00	; 0
    13de:	79 2f       	mov	r23, r25
    13e0:	7a 0f       	add	r23, r26
    13e2:	91 e0       	ldi	r25, 0x01	; 1
    13e4:	7a 17       	cp	r23, r26
    13e6:	08 f0       	brcs	.+2      	; 0x13ea <__vector_14+0x21e>
    13e8:	90 e0       	ldi	r25, 0x00	; 0
    13ea:	29 2b       	or	r18, r25
    13ec:	91 e0       	ldi	r25, 0x01	; 1
    13ee:	f8 17       	cp	r31, r24
    13f0:	08 f0       	brcs	.+2      	; 0x13f4 <__vector_14+0x228>
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	82 2f       	mov	r24, r18
    13f6:	8f 0f       	add	r24, r31
    13f8:	21 e0       	ldi	r18, 0x01	; 1
    13fa:	8f 17       	cp	r24, r31
    13fc:	08 f0       	brcs	.+2      	; 0x1400 <__vector_14+0x234>
    13fe:	20 e0       	ldi	r18, 0x00	; 0
    1400:	92 2b       	or	r25, r18
    1402:	2e 2d       	mov	r18, r14
    1404:	9e 0f       	add	r25, r30
    1406:	02 e0       	ldi	r16, 0x02	; 2
    1408:	0e 94 a2 30 	call	0x6144	; 0x6144 <__ashrdi3>
    140c:	29 83       	std	Y+1, r18	; 0x01
    140e:	3a 83       	std	Y+2, r19	; 0x02
    1410:	4b 83       	std	Y+3, r20	; 0x03
    1412:	5c 83       	std	Y+4, r21	; 0x04
    1414:	6d 83       	std	Y+5, r22	; 0x05
    1416:	7e 83       	std	Y+6, r23	; 0x06
    1418:	8f 83       	std	Y+7, r24	; 0x07
    141a:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    141c:	80 90 74 50 	lds	r8, 0x5074
    1420:	90 90 75 50 	lds	r9, 0x5075
    1424:	a0 90 76 50 	lds	r10, 0x5076
    1428:	b0 90 77 50 	lds	r11, 0x5077
    142c:	29 81       	ldd	r18, Y+1	; 0x01
    142e:	3a 81       	ldd	r19, Y+2	; 0x02
    1430:	4b 81       	ldd	r20, Y+3	; 0x03
    1432:	5c 81       	ldd	r21, Y+4	; 0x04
    1434:	6d 81       	ldd	r22, Y+5	; 0x05
    1436:	7e 81       	ldd	r23, Y+6	; 0x06
    1438:	8f 81       	ldd	r24, Y+7	; 0x07
    143a:	98 85       	ldd	r25, Y+8	; 0x08
    143c:	f4 01       	movw	r30, r8
    143e:	ee 0f       	add	r30, r30
    1440:	ff 1f       	adc	r31, r31
    1442:	ee 0f       	add	r30, r30
    1444:	ff 1f       	adc	r31, r31
    1446:	80 90 72 50 	lds	r8, 0x5072
    144a:	90 90 73 50 	lds	r9, 0x5073
    144e:	8e 0e       	add	r8, r30
    1450:	9f 1e       	adc	r9, r31
    1452:	0f 2e       	mov	r0, r31
    1454:	f0 ea       	ldi	r31, 0xA0	; 160
    1456:	af 2e       	mov	r10, r31
    1458:	f0 2d       	mov	r31, r0
    145a:	0f 2e       	mov	r0, r31
    145c:	f5 e2       	ldi	r31, 0x25	; 37
    145e:	bf 2e       	mov	r11, r31
    1460:	f0 2d       	mov	r31, r0
    1462:	0f 2e       	mov	r0, r31
    1464:	f6 e2       	ldi	r31, 0x26	; 38
    1466:	cf 2e       	mov	r12, r31
    1468:	f0 2d       	mov	r31, r0
    146a:	dd 24       	eor	r13, r13
    146c:	ee 24       	eor	r14, r14
    146e:	ff 24       	eor	r15, r15
    1470:	00 e0       	ldi	r16, 0x00	; 0
    1472:	10 e0       	ldi	r17, 0x00	; 0
    1474:	0e 94 5b 2f 	call	0x5eb6	; 0x5eb6 <__muldi3>
    1478:	aa 24       	eor	r10, r10
    147a:	aa 94       	dec	r10
    147c:	bb 24       	eor	r11, r11
    147e:	ba 94       	dec	r11
    1480:	0f 2e       	mov	r0, r31
    1482:	ff e7       	ldi	r31, 0x7F	; 127
    1484:	cf 2e       	mov	r12, r31
    1486:	f0 2d       	mov	r31, r0
    1488:	0e 94 0a 31 	call	0x6214	; 0x6214 <__divdi3>
    148c:	01 e0       	ldi	r16, 0x01	; 1
    148e:	0e 94 2e 30 	call	0x605c	; 0x605c <__ashldi3>
    1492:	0f 2e       	mov	r0, r31
    1494:	f3 e0       	ldi	r31, 0x03	; 3
    1496:	af 2e       	mov	r10, r31
    1498:	f0 2d       	mov	r31, r0
    149a:	bb 24       	eor	r11, r11
    149c:	cc 24       	eor	r12, r12
    149e:	00 e0       	ldi	r16, 0x00	; 0
    14a0:	0e 94 0a 31 	call	0x6214	; 0x6214 <__divdi3>
    14a4:	f4 01       	movw	r30, r8
    14a6:	20 83       	st	Z, r18
    14a8:	31 83       	std	Z+1, r19	; 0x01
    14aa:	42 83       	std	Z+2, r20	; 0x02
    14ac:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    14ae:	80 91 74 50 	lds	r24, 0x5074
    14b2:	90 91 75 50 	lds	r25, 0x5075
    14b6:	a0 91 76 50 	lds	r26, 0x5076
    14ba:	b0 91 77 50 	lds	r27, 0x5077
    14be:	01 96       	adiw	r24, 0x01	; 1
    14c0:	a1 1d       	adc	r26, r1
    14c2:	b1 1d       	adc	r27, r1
    14c4:	80 93 74 50 	sts	0x5074, r24
    14c8:	90 93 75 50 	sts	0x5075, r25
    14cc:	a0 93 76 50 	sts	0x5076, r26
    14d0:	b0 93 77 50 	sts	0x5077, r27

}
    14d4:	2c 96       	adiw	r28, 0x0c	; 12
    14d6:	cd bf       	out	0x3d, r28	; 61
    14d8:	de bf       	out	0x3e, r29	; 62
    14da:	df 91       	pop	r29
    14dc:	cf 91       	pop	r28
    14de:	ff 91       	pop	r31
    14e0:	ef 91       	pop	r30
    14e2:	bf 91       	pop	r27
    14e4:	af 91       	pop	r26
    14e6:	9f 91       	pop	r25
    14e8:	8f 91       	pop	r24
    14ea:	7f 91       	pop	r23
    14ec:	6f 91       	pop	r22
    14ee:	5f 91       	pop	r21
    14f0:	4f 91       	pop	r20
    14f2:	3f 91       	pop	r19
    14f4:	2f 91       	pop	r18
    14f6:	1f 91       	pop	r17
    14f8:	0f 91       	pop	r16
    14fa:	ff 90       	pop	r15
    14fc:	ef 90       	pop	r14
    14fe:	df 90       	pop	r13
    1500:	cf 90       	pop	r12
    1502:	bf 90       	pop	r11
    1504:	af 90       	pop	r10
    1506:	9f 90       	pop	r9
    1508:	8f 90       	pop	r8
    150a:	7f 90       	pop	r7
    150c:	6f 90       	pop	r6
    150e:	0f 90       	pop	r0
    1510:	0b be       	out	0x3b, r0	; 59
    1512:	0f 90       	pop	r0
    1514:	0f be       	out	0x3f, r0	; 63
    1516:	0f 90       	pop	r0
    1518:	1f 90       	pop	r1
    151a:	18 95       	reti

0000151c <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    151c:	1f 92       	push	r1
    151e:	0f 92       	push	r0
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	0f 92       	push	r0
    1524:	0b b6       	in	r0, 0x3b	; 59
    1526:	0f 92       	push	r0
    1528:	11 24       	eor	r1, r1
    152a:	6f 92       	push	r6
    152c:	7f 92       	push	r7
    152e:	8f 92       	push	r8
    1530:	9f 92       	push	r9
    1532:	af 92       	push	r10
    1534:	bf 92       	push	r11
    1536:	cf 92       	push	r12
    1538:	df 92       	push	r13
    153a:	ef 92       	push	r14
    153c:	ff 92       	push	r15
    153e:	0f 93       	push	r16
    1540:	1f 93       	push	r17
    1542:	2f 93       	push	r18
    1544:	3f 93       	push	r19
    1546:	4f 93       	push	r20
    1548:	5f 93       	push	r21
    154a:	6f 93       	push	r22
    154c:	7f 93       	push	r23
    154e:	8f 93       	push	r24
    1550:	9f 93       	push	r25
    1552:	af 93       	push	r26
    1554:	bf 93       	push	r27
    1556:	ef 93       	push	r30
    1558:	ff 93       	push	r31
    155a:	cf 93       	push	r28
    155c:	df 93       	push	r29
    155e:	cd b7       	in	r28, 0x3d	; 61
    1560:	de b7       	in	r29, 0x3e	; 62
    1562:	2c 97       	sbiw	r28, 0x0c	; 12
    1564:	cd bf       	out	0x3d, r28	; 61
    1566:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    1568:	19 82       	std	Y+1, r1	; 0x01
    156a:	1a 82       	std	Y+2, r1	; 0x02
    156c:	1b 82       	std	Y+3, r1	; 0x03
    156e:	1c 82       	std	Y+4, r1	; 0x04
    1570:	1d 82       	std	Y+5, r1	; 0x05
    1572:	1e 82       	std	Y+6, r1	; 0x06
    1574:	1f 82       	std	Y+7, r1	; 0x07
    1576:	18 86       	std	Y+8, r1	; 0x08
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    157c:	25 e6       	ldi	r18, 0x65	; 101
    157e:	30 e5       	ldi	r19, 0x50	; 80
    1580:	aa 24       	eor	r10, r10
    1582:	aa 94       	dec	r10
    1584:	ac 01       	movw	r20, r24
    1586:	f9 01       	movw	r30, r18
    1588:	e8 0f       	add	r30, r24
    158a:	f9 1f       	adc	r31, r25
    158c:	60 81       	ld	r22, Z
    158e:	66 23       	and	r22, r22
    1590:	14 f4       	brge	.+4      	; 0x1596 <__vector_77+0x7a>
    1592:	ac 86       	std	Y+12, r10	; 0x0c
    1594:	01 c0       	rjmp	.+2      	; 0x1598 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1596:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1598:	42 0f       	add	r20, r18
    159a:	53 1f       	adc	r21, r19
    159c:	fa 01       	movw	r30, r20
    159e:	40 81       	ld	r20, Z
    15a0:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    15a2:	fc 01       	movw	r30, r24
    15a4:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    15a6:	e2 0f       	add	r30, r18
    15a8:	f3 1f       	adc	r31, r19
    15aa:	40 81       	ld	r20, Z
    15ac:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    15ae:	fc 01       	movw	r30, r24
    15b0:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    15b2:	e2 0f       	add	r30, r18
    15b4:	f3 1f       	adc	r31, r19
    15b6:	40 81       	ld	r20, Z
    15b8:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    15ba:	49 85       	ldd	r20, Y+9	; 0x09
    15bc:	5a 85       	ldd	r21, Y+10	; 0x0a
    15be:	6b 85       	ldd	r22, Y+11	; 0x0b
    15c0:	7c 85       	ldd	r23, Y+12	; 0x0c
    15c2:	b9 80       	ldd	r11, Y+1	; 0x01
    15c4:	ca 80       	ldd	r12, Y+2	; 0x02
    15c6:	db 80       	ldd	r13, Y+3	; 0x03
    15c8:	ec 80       	ldd	r14, Y+4	; 0x04
    15ca:	fd 80       	ldd	r15, Y+5	; 0x05
    15cc:	0e 81       	ldd	r16, Y+6	; 0x06
    15ce:	1f 81       	ldd	r17, Y+7	; 0x07
    15d0:	88 84       	ldd	r8, Y+8	; 0x08
    15d2:	b4 2f       	mov	r27, r20
    15d4:	a5 2f       	mov	r26, r21
    15d6:	f6 2f       	mov	r31, r22
    15d8:	e7 2f       	mov	r30, r23
    15da:	77 0f       	add	r23, r23
    15dc:	44 0b       	sbc	r20, r20
    15de:	54 2f       	mov	r21, r20
    15e0:	ba 01       	movw	r22, r20
    15e2:	64 2e       	mov	r6, r20
    15e4:	74 2e       	mov	r7, r20
    15e6:	94 2e       	mov	r9, r20
    15e8:	bb 0e       	add	r11, r27
    15ea:	61 e0       	ldi	r22, 0x01	; 1
    15ec:	bb 16       	cp	r11, r27
    15ee:	08 f0       	brcs	.+2      	; 0x15f2 <__vector_77+0xd6>
    15f0:	60 e0       	ldi	r22, 0x00	; 0
    15f2:	ca 0e       	add	r12, r26
    15f4:	51 e0       	ldi	r21, 0x01	; 1
    15f6:	ca 16       	cp	r12, r26
    15f8:	08 f0       	brcs	.+2      	; 0x15fc <__vector_77+0xe0>
    15fa:	50 e0       	ldi	r21, 0x00	; 0
    15fc:	a6 2f       	mov	r26, r22
    15fe:	ac 0d       	add	r26, r12
    1600:	61 e0       	ldi	r22, 0x01	; 1
    1602:	ac 15       	cp	r26, r12
    1604:	08 f0       	brcs	.+2      	; 0x1608 <__vector_77+0xec>
    1606:	60 e0       	ldi	r22, 0x00	; 0
    1608:	56 2b       	or	r21, r22
    160a:	df 0e       	add	r13, r31
    160c:	61 e0       	ldi	r22, 0x01	; 1
    160e:	df 16       	cp	r13, r31
    1610:	08 f0       	brcs	.+2      	; 0x1614 <__vector_77+0xf8>
    1612:	60 e0       	ldi	r22, 0x00	; 0
    1614:	f5 2f       	mov	r31, r21
    1616:	fd 0d       	add	r31, r13
    1618:	51 e0       	ldi	r21, 0x01	; 1
    161a:	fd 15       	cp	r31, r13
    161c:	08 f0       	brcs	.+2      	; 0x1620 <__vector_77+0x104>
    161e:	50 e0       	ldi	r21, 0x00	; 0
    1620:	65 2b       	or	r22, r21
    1622:	ee 0e       	add	r14, r30
    1624:	51 e0       	ldi	r21, 0x01	; 1
    1626:	ee 16       	cp	r14, r30
    1628:	08 f0       	brcs	.+2      	; 0x162c <__vector_77+0x110>
    162a:	50 e0       	ldi	r21, 0x00	; 0
    162c:	e6 2f       	mov	r30, r22
    162e:	ee 0d       	add	r30, r14
    1630:	61 e0       	ldi	r22, 0x01	; 1
    1632:	ee 15       	cp	r30, r14
    1634:	08 f0       	brcs	.+2      	; 0x1638 <__vector_77+0x11c>
    1636:	60 e0       	ldi	r22, 0x00	; 0
    1638:	56 2b       	or	r21, r22
    163a:	f6 0c       	add	r15, r6
    163c:	71 e0       	ldi	r23, 0x01	; 1
    163e:	f6 14       	cp	r15, r6
    1640:	08 f0       	brcs	.+2      	; 0x1644 <__vector_77+0x128>
    1642:	70 e0       	ldi	r23, 0x00	; 0
    1644:	b5 2f       	mov	r27, r21
    1646:	bf 0d       	add	r27, r15
    1648:	51 e0       	ldi	r21, 0x01	; 1
    164a:	bf 15       	cp	r27, r15
    164c:	08 f0       	brcs	.+2      	; 0x1650 <__vector_77+0x134>
    164e:	50 e0       	ldi	r21, 0x00	; 0
    1650:	75 2b       	or	r23, r21
    1652:	07 0d       	add	r16, r7
    1654:	61 e0       	ldi	r22, 0x01	; 1
    1656:	07 15       	cp	r16, r7
    1658:	08 f0       	brcs	.+2      	; 0x165c <__vector_77+0x140>
    165a:	60 e0       	ldi	r22, 0x00	; 0
    165c:	70 0f       	add	r23, r16
    165e:	51 e0       	ldi	r21, 0x01	; 1
    1660:	70 17       	cp	r23, r16
    1662:	08 f0       	brcs	.+2      	; 0x1666 <__vector_77+0x14a>
    1664:	50 e0       	ldi	r21, 0x00	; 0
    1666:	65 2b       	or	r22, r21
    1668:	19 0d       	add	r17, r9
    166a:	51 e0       	ldi	r21, 0x01	; 1
    166c:	19 15       	cp	r17, r9
    166e:	08 f0       	brcs	.+2      	; 0x1672 <__vector_77+0x156>
    1670:	50 e0       	ldi	r21, 0x00	; 0
    1672:	61 0f       	add	r22, r17
    1674:	01 e0       	ldi	r16, 0x01	; 1
    1676:	61 17       	cp	r22, r17
    1678:	08 f0       	brcs	.+2      	; 0x167c <__vector_77+0x160>
    167a:	00 e0       	ldi	r16, 0x00	; 0
    167c:	50 2b       	or	r21, r16
    167e:	48 0d       	add	r20, r8
    1680:	54 0f       	add	r21, r20
    1682:	b9 82       	std	Y+1, r11	; 0x01
    1684:	aa 83       	std	Y+2, r26	; 0x02
    1686:	fb 83       	std	Y+3, r31	; 0x03
    1688:	ec 83       	std	Y+4, r30	; 0x04
    168a:	bd 83       	std	Y+5, r27	; 0x05
    168c:	7e 83       	std	Y+6, r23	; 0x06
    168e:	6f 83       	std	Y+7, r22	; 0x07
    1690:	58 87       	std	Y+8, r21	; 0x08
    1692:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1694:	8c 30       	cpi	r24, 0x0C	; 12
    1696:	91 05       	cpc	r25, r1
    1698:	09 f0       	breq	.+2      	; 0x169c <__vector_77+0x180>
    169a:	74 cf       	rjmp	.-280    	; 0x1584 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    169c:	e9 80       	ldd	r14, Y+1	; 0x01
    169e:	fa 80       	ldd	r15, Y+2	; 0x02
    16a0:	0b 81       	ldd	r16, Y+3	; 0x03
    16a2:	1c 81       	ldd	r17, Y+4	; 0x04
    16a4:	bd 81       	ldd	r27, Y+5	; 0x05
    16a6:	ae 81       	ldd	r26, Y+6	; 0x06
    16a8:	ff 81       	ldd	r31, Y+7	; 0x07
    16aa:	e8 85       	ldd	r30, Y+8	; 0x08
    16ac:	2e 2d       	mov	r18, r14
    16ae:	3f 2d       	mov	r19, r15
    16b0:	40 2f       	mov	r20, r16
    16b2:	51 2f       	mov	r21, r17
    16b4:	6b 2f       	mov	r22, r27
    16b6:	7a 2f       	mov	r23, r26
    16b8:	8f 2f       	mov	r24, r31
    16ba:	9e 2f       	mov	r25, r30
    16bc:	ee 23       	and	r30, r30
    16be:	0c f0       	brlt	.+2      	; 0x16c2 <__vector_77+0x1a6>
    16c0:	4a c0       	rjmp	.+148    	; 0x1756 <__vector_77+0x23a>
    16c2:	93 e0       	ldi	r25, 0x03	; 3
    16c4:	e9 0e       	add	r14, r25
    16c6:	91 e0       	ldi	r25, 0x01	; 1
    16c8:	e2 16       	cp	r14, r18
    16ca:	08 f0       	brcs	.+2      	; 0x16ce <__vector_77+0x1b2>
    16cc:	90 e0       	ldi	r25, 0x00	; 0
    16ce:	21 e0       	ldi	r18, 0x01	; 1
    16d0:	f3 16       	cp	r15, r19
    16d2:	08 f0       	brcs	.+2      	; 0x16d6 <__vector_77+0x1ba>
    16d4:	20 e0       	ldi	r18, 0x00	; 0
    16d6:	39 2f       	mov	r19, r25
    16d8:	3f 0d       	add	r19, r15
    16da:	91 e0       	ldi	r25, 0x01	; 1
    16dc:	3f 15       	cp	r19, r15
    16de:	08 f0       	brcs	.+2      	; 0x16e2 <__vector_77+0x1c6>
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	29 2b       	or	r18, r25
    16e4:	91 e0       	ldi	r25, 0x01	; 1
    16e6:	04 17       	cp	r16, r20
    16e8:	08 f0       	brcs	.+2      	; 0x16ec <__vector_77+0x1d0>
    16ea:	90 e0       	ldi	r25, 0x00	; 0
    16ec:	42 2f       	mov	r20, r18
    16ee:	40 0f       	add	r20, r16
    16f0:	21 e0       	ldi	r18, 0x01	; 1
    16f2:	40 17       	cp	r20, r16
    16f4:	08 f0       	brcs	.+2      	; 0x16f8 <__vector_77+0x1dc>
    16f6:	20 e0       	ldi	r18, 0x00	; 0
    16f8:	92 2b       	or	r25, r18
    16fa:	21 e0       	ldi	r18, 0x01	; 1
    16fc:	15 17       	cp	r17, r21
    16fe:	08 f0       	brcs	.+2      	; 0x1702 <__vector_77+0x1e6>
    1700:	20 e0       	ldi	r18, 0x00	; 0
    1702:	59 2f       	mov	r21, r25
    1704:	51 0f       	add	r21, r17
    1706:	91 e0       	ldi	r25, 0x01	; 1
    1708:	51 17       	cp	r21, r17
    170a:	08 f0       	brcs	.+2      	; 0x170e <__vector_77+0x1f2>
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	29 2b       	or	r18, r25
    1710:	91 e0       	ldi	r25, 0x01	; 1
    1712:	b6 17       	cp	r27, r22
    1714:	08 f0       	brcs	.+2      	; 0x1718 <__vector_77+0x1fc>
    1716:	90 e0       	ldi	r25, 0x00	; 0
    1718:	62 2f       	mov	r22, r18
    171a:	6b 0f       	add	r22, r27
    171c:	21 e0       	ldi	r18, 0x01	; 1
    171e:	6b 17       	cp	r22, r27
    1720:	08 f0       	brcs	.+2      	; 0x1724 <__vector_77+0x208>
    1722:	20 e0       	ldi	r18, 0x00	; 0
    1724:	92 2b       	or	r25, r18
    1726:	21 e0       	ldi	r18, 0x01	; 1
    1728:	a7 17       	cp	r26, r23
    172a:	08 f0       	brcs	.+2      	; 0x172e <__vector_77+0x212>
    172c:	20 e0       	ldi	r18, 0x00	; 0
    172e:	79 2f       	mov	r23, r25
    1730:	7a 0f       	add	r23, r26
    1732:	91 e0       	ldi	r25, 0x01	; 1
    1734:	7a 17       	cp	r23, r26
    1736:	08 f0       	brcs	.+2      	; 0x173a <__vector_77+0x21e>
    1738:	90 e0       	ldi	r25, 0x00	; 0
    173a:	29 2b       	or	r18, r25
    173c:	91 e0       	ldi	r25, 0x01	; 1
    173e:	f8 17       	cp	r31, r24
    1740:	08 f0       	brcs	.+2      	; 0x1744 <__vector_77+0x228>
    1742:	90 e0       	ldi	r25, 0x00	; 0
    1744:	82 2f       	mov	r24, r18
    1746:	8f 0f       	add	r24, r31
    1748:	21 e0       	ldi	r18, 0x01	; 1
    174a:	8f 17       	cp	r24, r31
    174c:	08 f0       	brcs	.+2      	; 0x1750 <__vector_77+0x234>
    174e:	20 e0       	ldi	r18, 0x00	; 0
    1750:	92 2b       	or	r25, r18
    1752:	2e 2d       	mov	r18, r14
    1754:	9e 0f       	add	r25, r30
    1756:	02 e0       	ldi	r16, 0x02	; 2
    1758:	0e 94 a2 30 	call	0x6144	; 0x6144 <__ashrdi3>
    175c:	29 83       	std	Y+1, r18	; 0x01
    175e:	3a 83       	std	Y+2, r19	; 0x02
    1760:	4b 83       	std	Y+3, r20	; 0x03
    1762:	5c 83       	std	Y+4, r21	; 0x04
    1764:	6d 83       	std	Y+5, r22	; 0x05
    1766:	7e 83       	std	Y+6, r23	; 0x06
    1768:	8f 83       	std	Y+7, r24	; 0x07
    176a:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    176c:	80 90 74 50 	lds	r8, 0x5074
    1770:	90 90 75 50 	lds	r9, 0x5075
    1774:	a0 90 76 50 	lds	r10, 0x5076
    1778:	b0 90 77 50 	lds	r11, 0x5077
    177c:	29 81       	ldd	r18, Y+1	; 0x01
    177e:	3a 81       	ldd	r19, Y+2	; 0x02
    1780:	4b 81       	ldd	r20, Y+3	; 0x03
    1782:	5c 81       	ldd	r21, Y+4	; 0x04
    1784:	6d 81       	ldd	r22, Y+5	; 0x05
    1786:	7e 81       	ldd	r23, Y+6	; 0x06
    1788:	8f 81       	ldd	r24, Y+7	; 0x07
    178a:	98 85       	ldd	r25, Y+8	; 0x08
    178c:	f4 01       	movw	r30, r8
    178e:	ee 0f       	add	r30, r30
    1790:	ff 1f       	adc	r31, r31
    1792:	ee 0f       	add	r30, r30
    1794:	ff 1f       	adc	r31, r31
    1796:	80 90 72 50 	lds	r8, 0x5072
    179a:	90 90 73 50 	lds	r9, 0x5073
    179e:	8e 0e       	add	r8, r30
    17a0:	9f 1e       	adc	r9, r31
    17a2:	0f 2e       	mov	r0, r31
    17a4:	f0 ea       	ldi	r31, 0xA0	; 160
    17a6:	af 2e       	mov	r10, r31
    17a8:	f0 2d       	mov	r31, r0
    17aa:	0f 2e       	mov	r0, r31
    17ac:	f5 e2       	ldi	r31, 0x25	; 37
    17ae:	bf 2e       	mov	r11, r31
    17b0:	f0 2d       	mov	r31, r0
    17b2:	0f 2e       	mov	r0, r31
    17b4:	f6 e2       	ldi	r31, 0x26	; 38
    17b6:	cf 2e       	mov	r12, r31
    17b8:	f0 2d       	mov	r31, r0
    17ba:	dd 24       	eor	r13, r13
    17bc:	ee 24       	eor	r14, r14
    17be:	ff 24       	eor	r15, r15
    17c0:	00 e0       	ldi	r16, 0x00	; 0
    17c2:	10 e0       	ldi	r17, 0x00	; 0
    17c4:	0e 94 5b 2f 	call	0x5eb6	; 0x5eb6 <__muldi3>
    17c8:	aa 24       	eor	r10, r10
    17ca:	aa 94       	dec	r10
    17cc:	bb 24       	eor	r11, r11
    17ce:	ba 94       	dec	r11
    17d0:	0f 2e       	mov	r0, r31
    17d2:	ff e7       	ldi	r31, 0x7F	; 127
    17d4:	cf 2e       	mov	r12, r31
    17d6:	f0 2d       	mov	r31, r0
    17d8:	0e 94 0a 31 	call	0x6214	; 0x6214 <__divdi3>
    17dc:	01 e0       	ldi	r16, 0x01	; 1
    17de:	0e 94 2e 30 	call	0x605c	; 0x605c <__ashldi3>
    17e2:	0f 2e       	mov	r0, r31
    17e4:	f3 e0       	ldi	r31, 0x03	; 3
    17e6:	af 2e       	mov	r10, r31
    17e8:	f0 2d       	mov	r31, r0
    17ea:	bb 24       	eor	r11, r11
    17ec:	cc 24       	eor	r12, r12
    17ee:	00 e0       	ldi	r16, 0x00	; 0
    17f0:	0e 94 0a 31 	call	0x6214	; 0x6214 <__divdi3>
    17f4:	f4 01       	movw	r30, r8
    17f6:	20 83       	st	Z, r18
    17f8:	31 83       	std	Z+1, r19	; 0x01
    17fa:	42 83       	std	Z+2, r20	; 0x02
    17fc:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    17fe:	80 91 74 50 	lds	r24, 0x5074
    1802:	90 91 75 50 	lds	r25, 0x5075
    1806:	a0 91 76 50 	lds	r26, 0x5076
    180a:	b0 91 77 50 	lds	r27, 0x5077
    180e:	01 96       	adiw	r24, 0x01	; 1
    1810:	a1 1d       	adc	r26, r1
    1812:	b1 1d       	adc	r27, r1
    1814:	80 93 74 50 	sts	0x5074, r24
    1818:	90 93 75 50 	sts	0x5075, r25
    181c:	a0 93 76 50 	sts	0x5076, r26
    1820:	b0 93 77 50 	sts	0x5077, r27
}
    1824:	2c 96       	adiw	r28, 0x0c	; 12
    1826:	cd bf       	out	0x3d, r28	; 61
    1828:	de bf       	out	0x3e, r29	; 62
    182a:	df 91       	pop	r29
    182c:	cf 91       	pop	r28
    182e:	ff 91       	pop	r31
    1830:	ef 91       	pop	r30
    1832:	bf 91       	pop	r27
    1834:	af 91       	pop	r26
    1836:	9f 91       	pop	r25
    1838:	8f 91       	pop	r24
    183a:	7f 91       	pop	r23
    183c:	6f 91       	pop	r22
    183e:	5f 91       	pop	r21
    1840:	4f 91       	pop	r20
    1842:	3f 91       	pop	r19
    1844:	2f 91       	pop	r18
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	ff 90       	pop	r15
    184c:	ef 90       	pop	r14
    184e:	df 90       	pop	r13
    1850:	cf 90       	pop	r12
    1852:	bf 90       	pop	r11
    1854:	af 90       	pop	r10
    1856:	9f 90       	pop	r9
    1858:	8f 90       	pop	r8
    185a:	7f 90       	pop	r7
    185c:	6f 90       	pop	r6
    185e:	0f 90       	pop	r0
    1860:	0b be       	out	0x3b, r0	; 59
    1862:	0f 90       	pop	r0
    1864:	0f be       	out	0x3f, r0	; 63
    1866:	0f 90       	pop	r0
    1868:	1f 90       	pop	r1
    186a:	18 95       	reti

0000186c <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    186c:	82 e0       	ldi	r24, 0x02	; 2
    186e:	e0 ea       	ldi	r30, 0xA0	; 160
    1870:	f6 e0       	ldi	r31, 0x06	; 6
    1872:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1874:	8a ea       	ldi	r24, 0xAA	; 170
    1876:	e0 ec       	ldi	r30, 0xC0	; 192
    1878:	f8 e0       	ldi	r31, 0x08	; 8
    187a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    187c:	82 81       	ldd	r24, Z+2	; 0x02
    187e:	88 23       	and	r24, r24
    1880:	ec f7       	brge	.-6      	; 0x187c <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    1882:	90 91 c6 50 	lds	r25, 0x50C6
    1886:	e0 ec       	ldi	r30, 0xC0	; 192
    1888:	f8 e0       	ldi	r31, 0x08	; 8
    188a:	83 81       	ldd	r24, Z+3	; 0x03
    188c:	a5 e6       	ldi	r26, 0x65	; 101
    188e:	b0 e5       	ldi	r27, 0x50	; 80
    1890:	a9 0f       	add	r26, r25
    1892:	b1 1d       	adc	r27, r1
    1894:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1896:	8a ea       	ldi	r24, 0xAA	; 170
    1898:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    189a:	82 81       	ldd	r24, Z+2	; 0x02
    189c:	88 23       	and	r24, r24
    189e:	ec f7       	brge	.-6      	; 0x189a <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    18a0:	a0 91 c6 50 	lds	r26, 0x50C6
    18a4:	b0 e0       	ldi	r27, 0x00	; 0
    18a6:	e0 ec       	ldi	r30, 0xC0	; 192
    18a8:	f8 e0       	ldi	r31, 0x08	; 8
    18aa:	83 81       	ldd	r24, Z+3	; 0x03
    18ac:	aa 59       	subi	r26, 0x9A	; 154
    18ae:	bf 4a       	sbci	r27, 0xAF	; 175
    18b0:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    18b2:	8a ea       	ldi	r24, 0xAA	; 170
    18b4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    18b6:	82 81       	ldd	r24, Z+2	; 0x02
    18b8:	88 23       	and	r24, r24
    18ba:	ec f7       	brge	.-6      	; 0x18b6 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    18bc:	e0 91 c6 50 	lds	r30, 0x50C6
    18c0:	f0 e0       	ldi	r31, 0x00	; 0
    18c2:	a0 ec       	ldi	r26, 0xC0	; 192
    18c4:	b8 e0       	ldi	r27, 0x08	; 8
    18c6:	13 96       	adiw	r26, 0x03	; 3
    18c8:	8c 91       	ld	r24, X
    18ca:	13 97       	sbiw	r26, 0x03	; 3
    18cc:	e9 59       	subi	r30, 0x99	; 153
    18ce:	ff 4a       	sbci	r31, 0xAF	; 175
    18d0:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    18d2:	82 e0       	ldi	r24, 0x02	; 2
    18d4:	e0 ea       	ldi	r30, 0xA0	; 160
    18d6:	f6 e0       	ldi	r31, 0x06	; 6
    18d8:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    18da:	80 91 c6 50 	lds	r24, 0x50C6
    18de:	8d 5f       	subi	r24, 0xFD	; 253
    18e0:	80 93 c6 50 	sts	0x50C6, r24
}
    18e4:	08 95       	ret

000018e6 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    18e6:	1f 92       	push	r1
    18e8:	0f 92       	push	r0
    18ea:	0f b6       	in	r0, 0x3f	; 63
    18ec:	0f 92       	push	r0
    18ee:	0b b6       	in	r0, 0x3b	; 59
    18f0:	0f 92       	push	r0
    18f2:	11 24       	eor	r1, r1
    18f4:	2f 93       	push	r18
    18f6:	3f 93       	push	r19
    18f8:	4f 93       	push	r20
    18fa:	5f 93       	push	r21
    18fc:	6f 93       	push	r22
    18fe:	7f 93       	push	r23
    1900:	8f 93       	push	r24
    1902:	9f 93       	push	r25
    1904:	af 93       	push	r26
    1906:	bf 93       	push	r27
    1908:	ef 93       	push	r30
    190a:	ff 93       	push	r31
	sampleCurrentChannel();
    190c:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
	SPICount = 0;
    1910:	10 92 c6 50 	sts	0x50C6, r1
}
    1914:	ff 91       	pop	r31
    1916:	ef 91       	pop	r30
    1918:	bf 91       	pop	r27
    191a:	af 91       	pop	r26
    191c:	9f 91       	pop	r25
    191e:	8f 91       	pop	r24
    1920:	7f 91       	pop	r23
    1922:	6f 91       	pop	r22
    1924:	5f 91       	pop	r21
    1926:	4f 91       	pop	r20
    1928:	3f 91       	pop	r19
    192a:	2f 91       	pop	r18
    192c:	0f 90       	pop	r0
    192e:	0b be       	out	0x3b, r0	; 59
    1930:	0f 90       	pop	r0
    1932:	0f be       	out	0x3f, r0	; 63
    1934:	0f 90       	pop	r0
    1936:	1f 90       	pop	r1
    1938:	18 95       	reti

0000193a <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    193a:	1f 92       	push	r1
    193c:	0f 92       	push	r0
    193e:	0f b6       	in	r0, 0x3f	; 63
    1940:	0f 92       	push	r0
    1942:	0b b6       	in	r0, 0x3b	; 59
    1944:	0f 92       	push	r0
    1946:	11 24       	eor	r1, r1
    1948:	2f 93       	push	r18
    194a:	3f 93       	push	r19
    194c:	4f 93       	push	r20
    194e:	5f 93       	push	r21
    1950:	6f 93       	push	r22
    1952:	7f 93       	push	r23
    1954:	8f 93       	push	r24
    1956:	9f 93       	push	r25
    1958:	af 93       	push	r26
    195a:	bf 93       	push	r27
    195c:	ef 93       	push	r30
    195e:	ff 93       	push	r31
	sampleCurrentChannel();
    1960:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
}
    1964:	ff 91       	pop	r31
    1966:	ef 91       	pop	r30
    1968:	bf 91       	pop	r27
    196a:	af 91       	pop	r26
    196c:	9f 91       	pop	r25
    196e:	8f 91       	pop	r24
    1970:	7f 91       	pop	r23
    1972:	6f 91       	pop	r22
    1974:	5f 91       	pop	r21
    1976:	4f 91       	pop	r20
    1978:	3f 91       	pop	r19
    197a:	2f 91       	pop	r18
    197c:	0f 90       	pop	r0
    197e:	0b be       	out	0x3b, r0	; 59
    1980:	0f 90       	pop	r0
    1982:	0f be       	out	0x3f, r0	; 63
    1984:	0f 90       	pop	r0
    1986:	1f 90       	pop	r1
    1988:	18 95       	reti

0000198a <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    198a:	1f 92       	push	r1
    198c:	0f 92       	push	r0
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	0f 92       	push	r0
    1992:	0b b6       	in	r0, 0x3b	; 59
    1994:	0f 92       	push	r0
    1996:	11 24       	eor	r1, r1
    1998:	2f 93       	push	r18
    199a:	3f 93       	push	r19
    199c:	4f 93       	push	r20
    199e:	5f 93       	push	r21
    19a0:	6f 93       	push	r22
    19a2:	7f 93       	push	r23
    19a4:	8f 93       	push	r24
    19a6:	9f 93       	push	r25
    19a8:	af 93       	push	r26
    19aa:	bf 93       	push	r27
    19ac:	ef 93       	push	r30
    19ae:	ff 93       	push	r31
	sampleCurrentChannel();
    19b0:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
}
    19b4:	ff 91       	pop	r31
    19b6:	ef 91       	pop	r30
    19b8:	bf 91       	pop	r27
    19ba:	af 91       	pop	r26
    19bc:	9f 91       	pop	r25
    19be:	8f 91       	pop	r24
    19c0:	7f 91       	pop	r23
    19c2:	6f 91       	pop	r22
    19c4:	5f 91       	pop	r21
    19c6:	4f 91       	pop	r20
    19c8:	3f 91       	pop	r19
    19ca:	2f 91       	pop	r18
    19cc:	0f 90       	pop	r0
    19ce:	0b be       	out	0x3b, r0	; 59
    19d0:	0f 90       	pop	r0
    19d2:	0f be       	out	0x3f, r0	; 63
    19d4:	0f 90       	pop	r0
    19d6:	1f 90       	pop	r1
    19d8:	18 95       	reti

000019da <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    19da:	1f 92       	push	r1
    19dc:	0f 92       	push	r0
    19de:	0f b6       	in	r0, 0x3f	; 63
    19e0:	0f 92       	push	r0
    19e2:	0b b6       	in	r0, 0x3b	; 59
    19e4:	0f 92       	push	r0
    19e6:	11 24       	eor	r1, r1
    19e8:	2f 93       	push	r18
    19ea:	3f 93       	push	r19
    19ec:	4f 93       	push	r20
    19ee:	5f 93       	push	r21
    19f0:	6f 93       	push	r22
    19f2:	7f 93       	push	r23
    19f4:	8f 93       	push	r24
    19f6:	9f 93       	push	r25
    19f8:	af 93       	push	r26
    19fa:	bf 93       	push	r27
    19fc:	ef 93       	push	r30
    19fe:	ff 93       	push	r31
	sampleCurrentChannel();
    1a00:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
}
    1a04:	ff 91       	pop	r31
    1a06:	ef 91       	pop	r30
    1a08:	bf 91       	pop	r27
    1a0a:	af 91       	pop	r26
    1a0c:	9f 91       	pop	r25
    1a0e:	8f 91       	pop	r24
    1a10:	7f 91       	pop	r23
    1a12:	6f 91       	pop	r22
    1a14:	5f 91       	pop	r21
    1a16:	4f 91       	pop	r20
    1a18:	3f 91       	pop	r19
    1a1a:	2f 91       	pop	r18
    1a1c:	0f 90       	pop	r0
    1a1e:	0b be       	out	0x3b, r0	; 59
    1a20:	0f 90       	pop	r0
    1a22:	0f be       	out	0x3f, r0	; 63
    1a24:	0f 90       	pop	r0
    1a26:	1f 90       	pop	r1
    1a28:	18 95       	reti

00001a2a <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    1a2a:	1f 92       	push	r1
    1a2c:	0f 92       	push	r0
    1a2e:	0f b6       	in	r0, 0x3f	; 63
    1a30:	0f 92       	push	r0
    1a32:	0b b6       	in	r0, 0x3b	; 59
    1a34:	0f 92       	push	r0
    1a36:	11 24       	eor	r1, r1
    1a38:	2f 93       	push	r18
    1a3a:	3f 93       	push	r19
    1a3c:	4f 93       	push	r20
    1a3e:	5f 93       	push	r21
    1a40:	6f 93       	push	r22
    1a42:	7f 93       	push	r23
    1a44:	8f 93       	push	r24
    1a46:	9f 93       	push	r25
    1a48:	af 93       	push	r26
    1a4a:	bf 93       	push	r27
    1a4c:	ef 93       	push	r30
    1a4e:	ff 93       	push	r31
	sampleCurrentChannel();
    1a50:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
	SPICount = 0;
    1a54:	10 92 c6 50 	sts	0x50C6, r1
	if(PORTB.OUT & PIN1_bm) {
    1a58:	e0 e2       	ldi	r30, 0x20	; 32
    1a5a:	f6 e0       	ldi	r31, 0x06	; 6
    1a5c:	84 81       	ldd	r24, Z+4	; 0x04
    1a5e:	81 ff       	sbrs	r24, 1
    1a60:	0f c0       	rjmp	.+30     	; 0x1a80 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    1a62:	e0 e0       	ldi	r30, 0x00	; 0
    1a64:	f6 e0       	ldi	r31, 0x06	; 6
    1a66:	84 81       	ldd	r24, Z+4	; 0x04
    1a68:	86 ff       	sbrs	r24, 6
    1a6a:	05 c0       	rjmp	.+10     	; 0x1a76 <__vector_19+0x4c>
    1a6c:	82 e0       	ldi	r24, 0x02	; 2
    1a6e:	e0 e2       	ldi	r30, 0x20	; 32
    1a70:	f6 e0       	ldi	r31, 0x06	; 6
    1a72:	87 83       	std	Z+7, r24	; 0x07
    1a74:	0d c0       	rjmp	.+26     	; 0x1a90 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    1a76:	80 e4       	ldi	r24, 0x40	; 64
    1a78:	e0 e0       	ldi	r30, 0x00	; 0
    1a7a:	f6 e0       	ldi	r31, 0x06	; 6
    1a7c:	87 83       	std	Z+7, r24	; 0x07
    1a7e:	08 c0       	rjmp	.+16     	; 0x1a90 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    1a80:	80 e4       	ldi	r24, 0x40	; 64
    1a82:	e0 e0       	ldi	r30, 0x00	; 0
    1a84:	f6 e0       	ldi	r31, 0x06	; 6
    1a86:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    1a88:	82 e0       	ldi	r24, 0x02	; 2
    1a8a:	e0 e2       	ldi	r30, 0x20	; 32
    1a8c:	f6 e0       	ldi	r31, 0x06	; 6
    1a8e:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    1a90:	ff 91       	pop	r31
    1a92:	ef 91       	pop	r30
    1a94:	bf 91       	pop	r27
    1a96:	af 91       	pop	r26
    1a98:	9f 91       	pop	r25
    1a9a:	8f 91       	pop	r24
    1a9c:	7f 91       	pop	r23
    1a9e:	6f 91       	pop	r22
    1aa0:	5f 91       	pop	r21
    1aa2:	4f 91       	pop	r20
    1aa4:	3f 91       	pop	r19
    1aa6:	2f 91       	pop	r18
    1aa8:	0f 90       	pop	r0
    1aaa:	0b be       	out	0x3b, r0	; 59
    1aac:	0f 90       	pop	r0
    1aae:	0f be       	out	0x3f, r0	; 63
    1ab0:	0f 90       	pop	r0
    1ab2:	1f 90       	pop	r1
    1ab4:	18 95       	reti

00001ab6 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    1ab6:	1f 92       	push	r1
    1ab8:	0f 92       	push	r0
    1aba:	0f b6       	in	r0, 0x3f	; 63
    1abc:	0f 92       	push	r0
    1abe:	0b b6       	in	r0, 0x3b	; 59
    1ac0:	0f 92       	push	r0
    1ac2:	11 24       	eor	r1, r1
    1ac4:	2f 93       	push	r18
    1ac6:	3f 93       	push	r19
    1ac8:	4f 93       	push	r20
    1aca:	5f 93       	push	r21
    1acc:	6f 93       	push	r22
    1ace:	7f 93       	push	r23
    1ad0:	8f 93       	push	r24
    1ad2:	9f 93       	push	r25
    1ad4:	af 93       	push	r26
    1ad6:	bf 93       	push	r27
    1ad8:	ef 93       	push	r30
    1ada:	ff 93       	push	r31
	sampleCurrentChannel();
    1adc:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
}
    1ae0:	ff 91       	pop	r31
    1ae2:	ef 91       	pop	r30
    1ae4:	bf 91       	pop	r27
    1ae6:	af 91       	pop	r26
    1ae8:	9f 91       	pop	r25
    1aea:	8f 91       	pop	r24
    1aec:	7f 91       	pop	r23
    1aee:	6f 91       	pop	r22
    1af0:	5f 91       	pop	r21
    1af2:	4f 91       	pop	r20
    1af4:	3f 91       	pop	r19
    1af6:	2f 91       	pop	r18
    1af8:	0f 90       	pop	r0
    1afa:	0b be       	out	0x3b, r0	; 59
    1afc:	0f 90       	pop	r0
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	0f 90       	pop	r0
    1b02:	1f 90       	pop	r1
    1b04:	18 95       	reti

00001b06 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    1b06:	1f 92       	push	r1
    1b08:	0f 92       	push	r0
    1b0a:	0f b6       	in	r0, 0x3f	; 63
    1b0c:	0f 92       	push	r0
    1b0e:	0b b6       	in	r0, 0x3b	; 59
    1b10:	0f 92       	push	r0
    1b12:	11 24       	eor	r1, r1
    1b14:	2f 93       	push	r18
    1b16:	3f 93       	push	r19
    1b18:	4f 93       	push	r20
    1b1a:	5f 93       	push	r21
    1b1c:	6f 93       	push	r22
    1b1e:	7f 93       	push	r23
    1b20:	8f 93       	push	r24
    1b22:	9f 93       	push	r25
    1b24:	af 93       	push	r26
    1b26:	bf 93       	push	r27
    1b28:	ef 93       	push	r30
    1b2a:	ff 93       	push	r31
	sampleCurrentChannel();
    1b2c:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
}
    1b30:	ff 91       	pop	r31
    1b32:	ef 91       	pop	r30
    1b34:	bf 91       	pop	r27
    1b36:	af 91       	pop	r26
    1b38:	9f 91       	pop	r25
    1b3a:	8f 91       	pop	r24
    1b3c:	7f 91       	pop	r23
    1b3e:	6f 91       	pop	r22
    1b40:	5f 91       	pop	r21
    1b42:	4f 91       	pop	r20
    1b44:	3f 91       	pop	r19
    1b46:	2f 91       	pop	r18
    1b48:	0f 90       	pop	r0
    1b4a:	0b be       	out	0x3b, r0	; 59
    1b4c:	0f 90       	pop	r0
    1b4e:	0f be       	out	0x3f, r0	; 63
    1b50:	0f 90       	pop	r0
    1b52:	1f 90       	pop	r1
    1b54:	18 95       	reti

00001b56 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    1b56:	1f 92       	push	r1
    1b58:	0f 92       	push	r0
    1b5a:	0f b6       	in	r0, 0x3f	; 63
    1b5c:	0f 92       	push	r0
    1b5e:	0b b6       	in	r0, 0x3b	; 59
    1b60:	0f 92       	push	r0
    1b62:	11 24       	eor	r1, r1
    1b64:	2f 93       	push	r18
    1b66:	3f 93       	push	r19
    1b68:	4f 93       	push	r20
    1b6a:	5f 93       	push	r21
    1b6c:	6f 93       	push	r22
    1b6e:	7f 93       	push	r23
    1b70:	8f 93       	push	r24
    1b72:	9f 93       	push	r25
    1b74:	af 93       	push	r26
    1b76:	bf 93       	push	r27
    1b78:	ef 93       	push	r30
    1b7a:	ff 93       	push	r31
	sampleCurrentChannel();
    1b7c:	0e 94 36 0c 	call	0x186c	; 0x186c <sampleCurrentChannel>
}
    1b80:	ff 91       	pop	r31
    1b82:	ef 91       	pop	r30
    1b84:	bf 91       	pop	r27
    1b86:	af 91       	pop	r26
    1b88:	9f 91       	pop	r25
    1b8a:	8f 91       	pop	r24
    1b8c:	7f 91       	pop	r23
    1b8e:	6f 91       	pop	r22
    1b90:	5f 91       	pop	r21
    1b92:	4f 91       	pop	r20
    1b94:	3f 91       	pop	r19
    1b96:	2f 91       	pop	r18
    1b98:	0f 90       	pop	r0
    1b9a:	0b be       	out	0x3b, r0	; 59
    1b9c:	0f 90       	pop	r0
    1b9e:	0f be       	out	0x3f, r0	; 63
    1ba0:	0f 90       	pop	r0
    1ba2:	1f 90       	pop	r1
    1ba4:	18 95       	reti

00001ba6 <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1ba6:	ff 92       	push	r15
    1ba8:	0f 93       	push	r16
    1baa:	1f 93       	push	r17
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	cd b7       	in	r28, 0x3d	; 61
    1bb2:	de b7       	in	r29, 0x3e	; 62
    1bb4:	28 97       	sbiw	r28, 0x08	; 8
    1bb6:	cd bf       	out	0x3d, r28	; 61
    1bb8:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1bba:	19 82       	std	Y+1, r1	; 0x01
    1bbc:	1a 82       	std	Y+2, r1	; 0x02
    1bbe:	1b 82       	std	Y+3, r1	; 0x03
    1bc0:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    1bc2:	80 91 74 50 	lds	r24, 0x5074
    1bc6:	90 91 75 50 	lds	r25, 0x5075
    1bca:	a0 91 76 50 	lds	r26, 0x5076
    1bce:	b0 91 77 50 	lds	r27, 0x5077
    1bd2:	01 96       	adiw	r24, 0x01	; 1
    1bd4:	a1 1d       	adc	r26, r1
    1bd6:	b1 1d       	adc	r27, r1
    1bd8:	80 93 74 50 	sts	0x5074, r24
    1bdc:	90 93 75 50 	sts	0x5075, r25
    1be0:	a0 93 76 50 	sts	0x5076, r26
    1be4:	b0 93 77 50 	sts	0x5077, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1be8:	80 ed       	ldi	r24, 0xD0	; 208
    1bea:	80 93 c0 08 	sts	0x08C0, r24
    1bee:	20 e0       	ldi	r18, 0x00	; 0
    1bf0:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1bf2:	05 e6       	ldi	r16, 0x65	; 101
    1bf4:	10 e5       	ldi	r17, 0x50	; 80
    1bf6:	ff 24       	eor	r15, r15
    1bf8:	fa 94       	dec	r15
    1bfa:	c9 01       	movw	r24, r18
    1bfc:	f8 01       	movw	r30, r16
    1bfe:	e2 0f       	add	r30, r18
    1c00:	f3 1f       	adc	r31, r19
    1c02:	40 81       	ld	r20, Z
    1c04:	44 23       	and	r20, r20
    1c06:	14 f4       	brge	.+4      	; 0x1c0c <writeSE2FRAM+0x66>
    1c08:	f8 86       	std	Y+8, r15	; 0x08
    1c0a:	01 c0       	rjmp	.+2      	; 0x1c0e <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1c0c:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1c0e:	80 0f       	add	r24, r16
    1c10:	91 1f       	adc	r25, r17
    1c12:	fc 01       	movw	r30, r24
    1c14:	80 81       	ld	r24, Z
    1c16:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1c18:	f9 01       	movw	r30, r18
    1c1a:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1c1c:	e0 0f       	add	r30, r16
    1c1e:	f1 1f       	adc	r31, r17
    1c20:	80 81       	ld	r24, Z
    1c22:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1c24:	f9 01       	movw	r30, r18
    1c26:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1c28:	e0 0f       	add	r30, r16
    1c2a:	f1 1f       	adc	r31, r17
    1c2c:	80 81       	ld	r24, Z
    1c2e:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    1c30:	49 81       	ldd	r20, Y+1	; 0x01
    1c32:	5a 81       	ldd	r21, Y+2	; 0x02
    1c34:	6b 81       	ldd	r22, Y+3	; 0x03
    1c36:	7c 81       	ldd	r23, Y+4	; 0x04
    1c38:	8d 81       	ldd	r24, Y+5	; 0x05
    1c3a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c3c:	af 81       	ldd	r26, Y+7	; 0x07
    1c3e:	b8 85       	ldd	r27, Y+8	; 0x08
    1c40:	84 0f       	add	r24, r20
    1c42:	95 1f       	adc	r25, r21
    1c44:	a6 1f       	adc	r26, r22
    1c46:	b7 1f       	adc	r27, r23
    1c48:	89 83       	std	Y+1, r24	; 0x01
    1c4a:	9a 83       	std	Y+2, r25	; 0x02
    1c4c:	ab 83       	std	Y+3, r26	; 0x03
    1c4e:	bc 83       	std	Y+4, r27	; 0x04
    1c50:	2d 5f       	subi	r18, 0xFD	; 253
    1c52:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    1c54:	2c 30       	cpi	r18, 0x0C	; 12
    1c56:	31 05       	cpc	r19, r1
    1c58:	81 f6       	brne	.-96     	; 0x1bfa <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    1c5a:	69 81       	ldd	r22, Y+1	; 0x01
    1c5c:	7a 81       	ldd	r23, Y+2	; 0x02
    1c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c60:	9c 81       	ldd	r25, Y+4	; 0x04
    1c62:	24 e0       	ldi	r18, 0x04	; 4
    1c64:	30 e0       	ldi	r19, 0x00	; 0
    1c66:	40 e0       	ldi	r20, 0x00	; 0
    1c68:	50 e0       	ldi	r21, 0x00	; 0
    1c6a:	0e 94 dd 3a 	call	0x75ba	; 0x75ba <__divmodsi4>
    1c6e:	29 83       	std	Y+1, r18	; 0x01
    1c70:	3a 83       	std	Y+2, r19	; 0x02
    1c72:	4b 83       	std	Y+3, r20	; 0x03
    1c74:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    1c76:	29 81       	ldd	r18, Y+1	; 0x01
    1c78:	87 e6       	ldi	r24, 0x67	; 103
    1c7a:	90 e5       	ldi	r25, 0x50	; 80
    1c7c:	20 93 67 50 	sts	0x5067, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    1c80:	2a 81       	ldd	r18, Y+2	; 0x02
    1c82:	fc 01       	movw	r30, r24
    1c84:	31 97       	sbiw	r30, 0x01	; 1
    1c86:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    1c88:	2b 81       	ldd	r18, Y+3	; 0x03
    1c8a:	02 97       	sbiw	r24, 0x02	; 2
    1c8c:	fc 01       	movw	r30, r24
    1c8e:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1c90:	80 e1       	ldi	r24, 0x10	; 16
    1c92:	e0 e4       	ldi	r30, 0x40	; 64
    1c94:	f6 e0       	ldi	r31, 0x06	; 6
    1c96:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1c98:	88 e0       	ldi	r24, 0x08	; 8
    1c9a:	e0 e2       	ldi	r30, 0x20	; 32
    1c9c:	f6 e0       	ldi	r31, 0x06	; 6
    1c9e:	86 83       	std	Z+6, r24	; 0x06
	nop();
    1ca0:	00 00       	nop
	SPIC.DATA = FR_WREN;
    1ca2:	86 e0       	ldi	r24, 0x06	; 6
    1ca4:	e0 ec       	ldi	r30, 0xC0	; 192
    1ca6:	f8 e0       	ldi	r31, 0x08	; 8
    1ca8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1caa:	82 81       	ldd	r24, Z+2	; 0x02
    1cac:	88 23       	and	r24, r24
    1cae:	ec f7       	brge	.-6      	; 0x1caa <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    1cb0:	e0 ec       	ldi	r30, 0xC0	; 192
    1cb2:	f8 e0       	ldi	r31, 0x08	; 8
    1cb4:	83 81       	ldd	r24, Z+3	; 0x03
    1cb6:	80 93 71 50 	sts	0x5071, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    1cba:	a0 e2       	ldi	r26, 0x20	; 32
    1cbc:	b6 e0       	ldi	r27, 0x06	; 6
    1cbe:	88 e0       	ldi	r24, 0x08	; 8
    1cc0:	15 96       	adiw	r26, 0x05	; 5
    1cc2:	8c 93       	st	X, r24
    1cc4:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    1cc6:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1cc8:	16 96       	adiw	r26, 0x06	; 6
    1cca:	8c 93       	st	X, r24
    1ccc:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    1cce:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    1cd0:	82 e0       	ldi	r24, 0x02	; 2
    1cd2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1cd4:	82 81       	ldd	r24, Z+2	; 0x02
    1cd6:	88 23       	and	r24, r24
    1cd8:	ec f7       	brge	.-6      	; 0x1cd4 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    1cda:	e0 ec       	ldi	r30, 0xC0	; 192
    1cdc:	f8 e0       	ldi	r31, 0x08	; 8
    1cde:	83 81       	ldd	r24, Z+3	; 0x03
    1ce0:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1ce4:	80 91 58 40 	lds	r24, 0x4058
    1ce8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1cea:	82 81       	ldd	r24, Z+2	; 0x02
    1cec:	88 23       	and	r24, r24
    1cee:	ec f7       	brge	.-6      	; 0x1cea <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    1cf0:	e0 ec       	ldi	r30, 0xC0	; 192
    1cf2:	f8 e0       	ldi	r31, 0x08	; 8
    1cf4:	83 81       	ldd	r24, Z+3	; 0x03
    1cf6:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1cfa:	80 91 57 40 	lds	r24, 0x4057
    1cfe:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d00:	82 81       	ldd	r24, Z+2	; 0x02
    1d02:	88 23       	and	r24, r24
    1d04:	ec f7       	brge	.-6      	; 0x1d00 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    1d06:	e0 ec       	ldi	r30, 0xC0	; 192
    1d08:	f8 e0       	ldi	r31, 0x08	; 8
    1d0a:	83 81       	ldd	r24, Z+3	; 0x03
    1d0c:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[0];
    1d10:	80 91 65 50 	lds	r24, 0x5065
    1d14:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d16:	82 81       	ldd	r24, Z+2	; 0x02
    1d18:	88 23       	and	r24, r24
    1d1a:	ec f7       	brge	.-6      	; 0x1d16 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    1d1c:	e0 ec       	ldi	r30, 0xC0	; 192
    1d1e:	f8 e0       	ldi	r31, 0x08	; 8
    1d20:	83 81       	ldd	r24, Z+3	; 0x03
    1d22:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[1];
    1d26:	80 91 66 50 	lds	r24, 0x5066
    1d2a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d2c:	82 81       	ldd	r24, Z+2	; 0x02
    1d2e:	88 23       	and	r24, r24
    1d30:	ec f7       	brge	.-6      	; 0x1d2c <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    1d32:	e0 ec       	ldi	r30, 0xC0	; 192
    1d34:	f8 e0       	ldi	r31, 0x08	; 8
    1d36:	83 81       	ldd	r24, Z+3	; 0x03
    1d38:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[2];
    1d3c:	80 91 67 50 	lds	r24, 0x5067
    1d40:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d42:	82 81       	ldd	r24, Z+2	; 0x02
    1d44:	88 23       	and	r24, r24
    1d46:	ec f7       	brge	.-6      	; 0x1d42 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    1d48:	a0 ec       	ldi	r26, 0xC0	; 192
    1d4a:	b8 e0       	ldi	r27, 0x08	; 8
    1d4c:	13 96       	adiw	r26, 0x03	; 3
    1d4e:	8c 91       	ld	r24, X
    1d50:	13 97       	sbiw	r26, 0x03	; 3
    1d52:	80 93 71 50 	sts	0x5071, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    1d56:	88 e0       	ldi	r24, 0x08	; 8
    1d58:	e0 e2       	ldi	r30, 0x20	; 32
    1d5a:	f6 e0       	ldi	r31, 0x06	; 6
    1d5c:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1d5e:	e0 e4       	ldi	r30, 0x40	; 64
    1d60:	f6 e0       	ldi	r31, 0x06	; 6
    1d62:	80 e1       	ldi	r24, 0x10	; 16
    1d64:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1d66:	94 e5       	ldi	r25, 0x54	; 84
    1d68:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1d6a:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    1d6c:	80 91 57 40 	lds	r24, 0x4057
    1d70:	90 91 58 40 	lds	r25, 0x4058
    1d74:	03 96       	adiw	r24, 0x03	; 3
    1d76:	80 93 57 40 	sts	0x4057, r24
    1d7a:	90 93 58 40 	sts	0x4058, r25
	checksumADC[0] += SPIBuffer[0];
    1d7e:	80 91 3b 21 	lds	r24, 0x213B
    1d82:	e5 e6       	ldi	r30, 0x65	; 101
    1d84:	f0 e5       	ldi	r31, 0x50	; 80
    1d86:	90 81       	ld	r25, Z
    1d88:	89 0f       	add	r24, r25
    1d8a:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[1] += SPIBuffer[1];
    1d8e:	80 91 3c 21 	lds	r24, 0x213C
    1d92:	91 81       	ldd	r25, Z+1	; 0x01
    1d94:	89 0f       	add	r24, r25
    1d96:	80 93 3c 21 	sts	0x213C, r24
	checksumADC[2] += SPIBuffer[2];
    1d9a:	80 91 3d 21 	lds	r24, 0x213D
    1d9e:	92 81       	ldd	r25, Z+2	; 0x02
    1da0:	89 0f       	add	r24, r25
    1da2:	80 93 3d 21 	sts	0x213D, r24
}
    1da6:	28 96       	adiw	r28, 0x08	; 8
    1da8:	cd bf       	out	0x3d, r28	; 61
    1daa:	de bf       	out	0x3e, r29	; 62
    1dac:	df 91       	pop	r29
    1dae:	cf 91       	pop	r28
    1db0:	1f 91       	pop	r17
    1db2:	0f 91       	pop	r16
    1db4:	ff 90       	pop	r15
    1db6:	08 95       	ret

00001db8 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1db8:	2f 92       	push	r2
    1dba:	3f 92       	push	r3
    1dbc:	4f 92       	push	r4
    1dbe:	5f 92       	push	r5
    1dc0:	6f 92       	push	r6
    1dc2:	7f 92       	push	r7
    1dc4:	8f 92       	push	r8
    1dc6:	9f 92       	push	r9
    1dc8:	af 92       	push	r10
    1dca:	bf 92       	push	r11
    1dcc:	cf 92       	push	r12
    1dce:	df 92       	push	r13
    1dd0:	ef 92       	push	r14
    1dd2:	ff 92       	push	r15
    1dd4:	0f 93       	push	r16
    1dd6:	1f 93       	push	r17
    1dd8:	cf 93       	push	r28
    1dda:	df 93       	push	r29
    1ddc:	00 d0       	rcall	.+0      	; 0x1dde <calcChecksumFRAM+0x26>
    1dde:	0f 92       	push	r0
    1de0:	cd b7       	in	r28, 0x3d	; 61
    1de2:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    1de4:	eb e9       	ldi	r30, 0x9B	; 155
    1de6:	f0 e5       	ldi	r31, 0x50	; 80
    1de8:	10 92 9b 50 	sts	0x509B, r1
    1dec:	10 92 9c 50 	sts	0x509C, r1
    1df0:	10 92 9d 50 	sts	0x509D, r1
    1df4:	10 92 9e 50 	sts	0x509E, r1
    1df8:	10 92 9f 50 	sts	0x509F, r1
    1dfc:	10 92 a0 50 	sts	0x50A0, r1
    1e00:	10 92 a1 50 	sts	0x50A1, r1
    1e04:	10 92 a2 50 	sts	0x50A2, r1
    1e08:	df 01       	movw	r26, r30
    1e0a:	18 97       	sbiw	r26, 0x08	; 8
    1e0c:	1c 92       	st	X, r1
    1e0e:	11 96       	adiw	r26, 0x01	; 1
    1e10:	1c 92       	st	X, r1
    1e12:	11 97       	sbiw	r26, 0x01	; 1
    1e14:	12 96       	adiw	r26, 0x02	; 2
    1e16:	1c 92       	st	X, r1
    1e18:	12 97       	sbiw	r26, 0x02	; 2
    1e1a:	13 96       	adiw	r26, 0x03	; 3
    1e1c:	1c 92       	st	X, r1
    1e1e:	13 97       	sbiw	r26, 0x03	; 3
    1e20:	14 96       	adiw	r26, 0x04	; 4
    1e22:	1c 92       	st	X, r1
    1e24:	14 97       	sbiw	r26, 0x04	; 4
    1e26:	15 96       	adiw	r26, 0x05	; 5
    1e28:	1c 92       	st	X, r1
    1e2a:	15 97       	sbiw	r26, 0x05	; 5
    1e2c:	16 96       	adiw	r26, 0x06	; 6
    1e2e:	1c 92       	st	X, r1
    1e30:	16 97       	sbiw	r26, 0x06	; 6
    1e32:	17 96       	adiw	r26, 0x07	; 7
    1e34:	1c 92       	st	X, r1
    1e36:	70 97       	sbiw	r30, 0x10	; 16
    1e38:	10 82       	st	Z, r1
    1e3a:	11 82       	std	Z+1, r1	; 0x01
    1e3c:	12 82       	std	Z+2, r1	; 0x02
    1e3e:	13 82       	std	Z+3, r1	; 0x03
    1e40:	14 82       	std	Z+4, r1	; 0x04
    1e42:	15 82       	std	Z+5, r1	; 0x05
    1e44:	16 82       	std	Z+6, r1	; 0x06
    1e46:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    1e48:	8a e3       	ldi	r24, 0x3A	; 58
    1e4a:	91 e2       	ldi	r25, 0x21	; 33
    1e4c:	10 92 3a 21 	sts	0x213A, r1
    1e50:	fc 01       	movw	r30, r24
    1e52:	31 97       	sbiw	r30, 0x01	; 1
    1e54:	10 82       	st	Z, r1
    1e56:	02 97       	sbiw	r24, 0x02	; 2
    1e58:	dc 01       	movw	r26, r24
    1e5a:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    1e5c:	10 92 57 40 	sts	0x4057, r1
    1e60:	10 92 58 40 	sts	0x4058, r1
    1e64:	e9 e0       	ldi	r30, 0x09	; 9
    1e66:	f0 e0       	ldi	r31, 0x00	; 0
    1e68:	e9 83       	std	Y+1, r30	; 0x01
    1e6a:	fa 83       	std	Y+2, r31	; 0x02
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1e6c:	99 24       	eor	r9, r9
    1e6e:	9a 94       	dec	r9
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    1e70:	0f 2e       	mov	r0, r31
    1e72:	fb e9       	ldi	r31, 0x9B	; 155
    1e74:	ef 2e       	mov	r14, r31
    1e76:	f0 e5       	ldi	r31, 0x50	; 80
    1e78:	ff 2e       	mov	r15, r31
    1e7a:	f0 2d       	mov	r31, r0
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    1e7c:	0f 2e       	mov	r0, r31
    1e7e:	f3 e9       	ldi	r31, 0x93	; 147
    1e80:	cf 2e       	mov	r12, r31
    1e82:	f0 e5       	ldi	r31, 0x50	; 80
    1e84:	df 2e       	mov	r13, r31
    1e86:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1e88:	0f 2e       	mov	r0, r31
    1e8a:	fb e8       	ldi	r31, 0x8B	; 139
    1e8c:	af 2e       	mov	r10, r31
    1e8e:	f0 e5       	ldi	r31, 0x50	; 80
    1e90:	bf 2e       	mov	r11, r31
    1e92:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    1e94:	81 e7       	ldi	r24, 0x71	; 113
    1e96:	9c e1       	ldi	r25, 0x1C	; 28
    1e98:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    1e9c:	80 91 57 40 	lds	r24, 0x4057
    1ea0:	90 91 58 40 	lds	r25, 0x4058
    1ea4:	8f 58       	subi	r24, 0x8F	; 143
    1ea6:	93 4e       	sbci	r25, 0xE3	; 227
    1ea8:	80 93 57 40 	sts	0x4057, r24
    1eac:	90 93 58 40 	sts	0x4058, r25
    1eb0:	0f ed       	ldi	r16, 0xDF	; 223
    1eb2:	13 e2       	ldi	r17, 0x23	; 35
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1eb4:	80 e0       	ldi	r24, 0x00	; 0
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1eb8:	0f 2e       	mov	r0, r31
    1eba:	f9 e0       	ldi	r31, 0x09	; 9
    1ebc:	2f 2e       	mov	r2, r31
    1ebe:	33 24       	eor	r3, r3
    1ec0:	f0 2d       	mov	r31, r0
    1ec2:	8b 83       	std	Y+3, r24	; 0x03
    1ec4:	9c 83       	std	Y+4, r25	; 0x04
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eca:	63 e0       	ldi	r22, 0x03	; 3
    1ecc:	70 e0       	ldi	r23, 0x00	; 0
    1ece:	0e 94 94 3a 	call	0x7528	; 0x7528 <__udivmodhi4>
    1ed2:	9c 01       	movw	r18, r24
    1ed4:	e8 e3       	ldi	r30, 0x38	; 56
    1ed6:	f1 e2       	ldi	r31, 0x21	; 33
    1ed8:	e8 0f       	add	r30, r24
    1eda:	f9 1f       	adc	r31, r25
    1edc:	90 81       	ld	r25, Z
	checksumADC[1] += SPIBuffer[1];
	checksumADC[2] += SPIBuffer[2];
}

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1ede:	a8 01       	movw	r20, r16
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1ee0:	d8 01       	movw	r26, r16
    1ee2:	8c 91       	ld	r24, X
    1ee4:	98 0f       	add	r25, r24
    1ee6:	90 83       	st	Z, r25
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    1ee8:	21 15       	cp	r18, r1
    1eea:	31 05       	cpc	r19, r1
    1eec:	19 f5       	brne	.+70     	; 0x1f34 <calcChecksumFRAM+0x17c>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1eee:	88 23       	and	r24, r24
    1ef0:	6c f4       	brge	.+26     	; 0x1f0c <calcChecksumFRAM+0x154>
    1ef2:	e0 91 63 50 	lds	r30, 0x5063
    1ef6:	f0 91 64 50 	lds	r31, 0x5064
    1efa:	10 82       	st	Z, r1
    1efc:	11 82       	std	Z+1, r1	; 0x01
    1efe:	12 82       	std	Z+2, r1	; 0x02
    1f00:	93 82       	std	Z+3, r9	; 0x03
    1f02:	94 82       	std	Z+4, r9	; 0x04
    1f04:	95 82       	std	Z+5, r9	; 0x05
    1f06:	96 82       	std	Z+6, r9	; 0x06
    1f08:	97 82       	std	Z+7, r9	; 0x07
    1f0a:	0c c0       	rjmp	.+24     	; 0x1f24 <calcChecksumFRAM+0x16c>
				else *temp64 = 0x0000000000000000;
    1f0c:	e0 91 63 50 	lds	r30, 0x5063
    1f10:	f0 91 64 50 	lds	r31, 0x5064
    1f14:	10 82       	st	Z, r1
    1f16:	11 82       	std	Z+1, r1	; 0x01
    1f18:	12 82       	std	Z+2, r1	; 0x02
    1f1a:	13 82       	std	Z+3, r1	; 0x03
    1f1c:	14 82       	std	Z+4, r1	; 0x04
    1f1e:	15 82       	std	Z+5, r1	; 0x05
    1f20:	16 82       	std	Z+6, r1	; 0x06
    1f22:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    1f24:	fa 01       	movw	r30, r20
    1f26:	80 81       	ld	r24, Z
    1f28:	e0 91 63 50 	lds	r30, 0x5063
    1f2c:	f0 91 64 50 	lds	r31, 0x5064
    1f30:	82 83       	std	Z+2, r24	; 0x02
    1f32:	10 c0       	rjmp	.+32     	; 0x1f54 <calcChecksumFRAM+0x19c>
			} else if(k%3 == 1) {
    1f34:	21 30       	cpi	r18, 0x01	; 1
    1f36:	31 05       	cpc	r19, r1
    1f38:	31 f4       	brne	.+12     	; 0x1f46 <calcChecksumFRAM+0x18e>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    1f3a:	e0 91 63 50 	lds	r30, 0x5063
    1f3e:	f0 91 64 50 	lds	r31, 0x5064
    1f42:	81 83       	std	Z+1, r24	; 0x01
    1f44:	07 c0       	rjmp	.+14     	; 0x1f54 <calcChecksumFRAM+0x19c>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    1f46:	e0 91 63 50 	lds	r30, 0x5063
    1f4a:	f0 91 64 50 	lds	r31, 0x5064
    1f4e:	d8 01       	movw	r26, r16
    1f50:	8c 91       	ld	r24, X
    1f52:	80 83       	st	Z, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1f54:	8b 81       	ldd	r24, Y+3	; 0x03
    1f56:	9c 81       	ldd	r25, Y+4	; 0x04
    1f58:	b1 01       	movw	r22, r2
    1f5a:	0e 94 94 3a 	call	0x7528	; 0x7528 <__udivmodhi4>
    1f5e:	82 30       	cpi	r24, 0x02	; 2
    1f60:	91 05       	cpc	r25, r1
    1f62:	09 f0       	breq	.+2      	; 0x1f66 <calcChecksumFRAM+0x1ae>
    1f64:	76 c0       	rjmp	.+236    	; 0x2052 <calcChecksumFRAM+0x29a>
    1f66:	f5 01       	movw	r30, r10
    1f68:	60 81       	ld	r22, Z
    1f6a:	51 81       	ldd	r21, Z+1	; 0x01
    1f6c:	42 81       	ldd	r20, Z+2	; 0x02
    1f6e:	33 81       	ldd	r19, Z+3	; 0x03
    1f70:	24 81       	ldd	r18, Z+4	; 0x04
    1f72:	95 81       	ldd	r25, Z+5	; 0x05
    1f74:	86 81       	ldd	r24, Z+6	; 0x06
    1f76:	47 80       	ldd	r4, Z+7	; 0x07
    1f78:	e0 91 63 50 	lds	r30, 0x5063
    1f7c:	f0 91 64 50 	lds	r31, 0x5064
    1f80:	70 81       	ld	r23, Z
    1f82:	a1 81       	ldd	r26, Z+1	; 0x01
    1f84:	b2 81       	ldd	r27, Z+2	; 0x02
    1f86:	83 80       	ldd	r8, Z+3	; 0x03
    1f88:	74 80       	ldd	r7, Z+4	; 0x04
    1f8a:	65 80       	ldd	r6, Z+5	; 0x05
    1f8c:	56 80       	ldd	r5, Z+6	; 0x06
    1f8e:	e7 81       	ldd	r30, Z+7	; 0x07
    1f90:	76 0f       	add	r23, r22
    1f92:	f1 e0       	ldi	r31, 0x01	; 1
    1f94:	76 17       	cp	r23, r22
    1f96:	08 f0       	brcs	.+2      	; 0x1f9a <calcChecksumFRAM+0x1e2>
    1f98:	f0 e0       	ldi	r31, 0x00	; 0
    1f9a:	a5 0f       	add	r26, r21
    1f9c:	61 e0       	ldi	r22, 0x01	; 1
    1f9e:	a5 17       	cp	r26, r21
    1fa0:	08 f0       	brcs	.+2      	; 0x1fa4 <calcChecksumFRAM+0x1ec>
    1fa2:	60 e0       	ldi	r22, 0x00	; 0
    1fa4:	fa 0f       	add	r31, r26
    1fa6:	51 e0       	ldi	r21, 0x01	; 1
    1fa8:	fa 17       	cp	r31, r26
    1faa:	08 f0       	brcs	.+2      	; 0x1fae <calcChecksumFRAM+0x1f6>
    1fac:	50 e0       	ldi	r21, 0x00	; 0
    1fae:	65 2b       	or	r22, r21
    1fb0:	b4 0f       	add	r27, r20
    1fb2:	51 e0       	ldi	r21, 0x01	; 1
    1fb4:	b4 17       	cp	r27, r20
    1fb6:	08 f0       	brcs	.+2      	; 0x1fba <calcChecksumFRAM+0x202>
    1fb8:	50 e0       	ldi	r21, 0x00	; 0
    1fba:	6b 0f       	add	r22, r27
    1fbc:	41 e0       	ldi	r20, 0x01	; 1
    1fbe:	6b 17       	cp	r22, r27
    1fc0:	08 f0       	brcs	.+2      	; 0x1fc4 <calcChecksumFRAM+0x20c>
    1fc2:	40 e0       	ldi	r20, 0x00	; 0
    1fc4:	54 2b       	or	r21, r20
    1fc6:	83 0e       	add	r8, r19
    1fc8:	41 e0       	ldi	r20, 0x01	; 1
    1fca:	83 16       	cp	r8, r19
    1fcc:	08 f0       	brcs	.+2      	; 0x1fd0 <calcChecksumFRAM+0x218>
    1fce:	40 e0       	ldi	r20, 0x00	; 0
    1fd0:	58 0d       	add	r21, r8
    1fd2:	31 e0       	ldi	r19, 0x01	; 1
    1fd4:	58 15       	cp	r21, r8
    1fd6:	08 f0       	brcs	.+2      	; 0x1fda <calcChecksumFRAM+0x222>
    1fd8:	30 e0       	ldi	r19, 0x00	; 0
    1fda:	43 2b       	or	r20, r19
    1fdc:	72 0e       	add	r7, r18
    1fde:	31 e0       	ldi	r19, 0x01	; 1
    1fe0:	72 16       	cp	r7, r18
    1fe2:	08 f0       	brcs	.+2      	; 0x1fe6 <calcChecksumFRAM+0x22e>
    1fe4:	30 e0       	ldi	r19, 0x00	; 0
    1fe6:	47 0d       	add	r20, r7
    1fe8:	21 e0       	ldi	r18, 0x01	; 1
    1fea:	47 15       	cp	r20, r7
    1fec:	08 f0       	brcs	.+2      	; 0x1ff0 <calcChecksumFRAM+0x238>
    1fee:	20 e0       	ldi	r18, 0x00	; 0
    1ff0:	32 2b       	or	r19, r18
    1ff2:	69 0e       	add	r6, r25
    1ff4:	21 e0       	ldi	r18, 0x01	; 1
    1ff6:	69 16       	cp	r6, r25
    1ff8:	08 f0       	brcs	.+2      	; 0x1ffc <calcChecksumFRAM+0x244>
    1ffa:	20 e0       	ldi	r18, 0x00	; 0
    1ffc:	36 0d       	add	r19, r6
    1ffe:	91 e0       	ldi	r25, 0x01	; 1
    2000:	36 15       	cp	r19, r6
    2002:	08 f0       	brcs	.+2      	; 0x2006 <calcChecksumFRAM+0x24e>
    2004:	90 e0       	ldi	r25, 0x00	; 0
    2006:	29 2b       	or	r18, r25
    2008:	58 0e       	add	r5, r24
    200a:	91 e0       	ldi	r25, 0x01	; 1
    200c:	58 16       	cp	r5, r24
    200e:	08 f0       	brcs	.+2      	; 0x2012 <calcChecksumFRAM+0x25a>
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	25 0d       	add	r18, r5
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	25 15       	cp	r18, r5
    2018:	08 f0       	brcs	.+2      	; 0x201c <calcChecksumFRAM+0x264>
    201a:	80 e0       	ldi	r24, 0x00	; 0
    201c:	98 2b       	or	r25, r24
    201e:	e4 0d       	add	r30, r4
    2020:	9e 0f       	add	r25, r30
    2022:	d5 01       	movw	r26, r10
    2024:	7c 93       	st	X, r23
    2026:	11 96       	adiw	r26, 0x01	; 1
    2028:	fc 93       	st	X, r31
    202a:	11 97       	sbiw	r26, 0x01	; 1
    202c:	12 96       	adiw	r26, 0x02	; 2
    202e:	6c 93       	st	X, r22
    2030:	12 97       	sbiw	r26, 0x02	; 2
    2032:	13 96       	adiw	r26, 0x03	; 3
    2034:	5c 93       	st	X, r21
    2036:	13 97       	sbiw	r26, 0x03	; 3
    2038:	14 96       	adiw	r26, 0x04	; 4
    203a:	4c 93       	st	X, r20
    203c:	14 97       	sbiw	r26, 0x04	; 4
    203e:	15 96       	adiw	r26, 0x05	; 5
    2040:	3c 93       	st	X, r19
    2042:	15 97       	sbiw	r26, 0x05	; 5
    2044:	16 96       	adiw	r26, 0x06	; 6
    2046:	2c 93       	st	X, r18
    2048:	16 97       	sbiw	r26, 0x06	; 6
    204a:	17 96       	adiw	r26, 0x07	; 7
    204c:	9c 93       	st	X, r25
    204e:	17 97       	sbiw	r26, 0x07	; 7
    2050:	f3 c0       	rjmp	.+486    	; 0x2238 <calcChecksumFRAM+0x480>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    2052:	85 30       	cpi	r24, 0x05	; 5
    2054:	91 05       	cpc	r25, r1
    2056:	09 f0       	breq	.+2      	; 0x205a <calcChecksumFRAM+0x2a2>
    2058:	76 c0       	rjmp	.+236    	; 0x2146 <calcChecksumFRAM+0x38e>
    205a:	f6 01       	movw	r30, r12
    205c:	60 81       	ld	r22, Z
    205e:	51 81       	ldd	r21, Z+1	; 0x01
    2060:	42 81       	ldd	r20, Z+2	; 0x02
    2062:	33 81       	ldd	r19, Z+3	; 0x03
    2064:	24 81       	ldd	r18, Z+4	; 0x04
    2066:	95 81       	ldd	r25, Z+5	; 0x05
    2068:	86 81       	ldd	r24, Z+6	; 0x06
    206a:	47 80       	ldd	r4, Z+7	; 0x07
    206c:	e0 91 63 50 	lds	r30, 0x5063
    2070:	f0 91 64 50 	lds	r31, 0x5064
    2074:	70 81       	ld	r23, Z
    2076:	a1 81       	ldd	r26, Z+1	; 0x01
    2078:	b2 81       	ldd	r27, Z+2	; 0x02
    207a:	83 80       	ldd	r8, Z+3	; 0x03
    207c:	74 80       	ldd	r7, Z+4	; 0x04
    207e:	65 80       	ldd	r6, Z+5	; 0x05
    2080:	56 80       	ldd	r5, Z+6	; 0x06
    2082:	e7 81       	ldd	r30, Z+7	; 0x07
    2084:	76 0f       	add	r23, r22
    2086:	f1 e0       	ldi	r31, 0x01	; 1
    2088:	76 17       	cp	r23, r22
    208a:	08 f0       	brcs	.+2      	; 0x208e <calcChecksumFRAM+0x2d6>
    208c:	f0 e0       	ldi	r31, 0x00	; 0
    208e:	a5 0f       	add	r26, r21
    2090:	61 e0       	ldi	r22, 0x01	; 1
    2092:	a5 17       	cp	r26, r21
    2094:	08 f0       	brcs	.+2      	; 0x2098 <calcChecksumFRAM+0x2e0>
    2096:	60 e0       	ldi	r22, 0x00	; 0
    2098:	fa 0f       	add	r31, r26
    209a:	51 e0       	ldi	r21, 0x01	; 1
    209c:	fa 17       	cp	r31, r26
    209e:	08 f0       	brcs	.+2      	; 0x20a2 <calcChecksumFRAM+0x2ea>
    20a0:	50 e0       	ldi	r21, 0x00	; 0
    20a2:	65 2b       	or	r22, r21
    20a4:	b4 0f       	add	r27, r20
    20a6:	51 e0       	ldi	r21, 0x01	; 1
    20a8:	b4 17       	cp	r27, r20
    20aa:	08 f0       	brcs	.+2      	; 0x20ae <calcChecksumFRAM+0x2f6>
    20ac:	50 e0       	ldi	r21, 0x00	; 0
    20ae:	6b 0f       	add	r22, r27
    20b0:	41 e0       	ldi	r20, 0x01	; 1
    20b2:	6b 17       	cp	r22, r27
    20b4:	08 f0       	brcs	.+2      	; 0x20b8 <calcChecksumFRAM+0x300>
    20b6:	40 e0       	ldi	r20, 0x00	; 0
    20b8:	54 2b       	or	r21, r20
    20ba:	83 0e       	add	r8, r19
    20bc:	41 e0       	ldi	r20, 0x01	; 1
    20be:	83 16       	cp	r8, r19
    20c0:	08 f0       	brcs	.+2      	; 0x20c4 <calcChecksumFRAM+0x30c>
    20c2:	40 e0       	ldi	r20, 0x00	; 0
    20c4:	58 0d       	add	r21, r8
    20c6:	31 e0       	ldi	r19, 0x01	; 1
    20c8:	58 15       	cp	r21, r8
    20ca:	08 f0       	brcs	.+2      	; 0x20ce <calcChecksumFRAM+0x316>
    20cc:	30 e0       	ldi	r19, 0x00	; 0
    20ce:	43 2b       	or	r20, r19
    20d0:	72 0e       	add	r7, r18
    20d2:	31 e0       	ldi	r19, 0x01	; 1
    20d4:	72 16       	cp	r7, r18
    20d6:	08 f0       	brcs	.+2      	; 0x20da <calcChecksumFRAM+0x322>
    20d8:	30 e0       	ldi	r19, 0x00	; 0
    20da:	47 0d       	add	r20, r7
    20dc:	21 e0       	ldi	r18, 0x01	; 1
    20de:	47 15       	cp	r20, r7
    20e0:	08 f0       	brcs	.+2      	; 0x20e4 <calcChecksumFRAM+0x32c>
    20e2:	20 e0       	ldi	r18, 0x00	; 0
    20e4:	32 2b       	or	r19, r18
    20e6:	69 0e       	add	r6, r25
    20e8:	21 e0       	ldi	r18, 0x01	; 1
    20ea:	69 16       	cp	r6, r25
    20ec:	08 f0       	brcs	.+2      	; 0x20f0 <calcChecksumFRAM+0x338>
    20ee:	20 e0       	ldi	r18, 0x00	; 0
    20f0:	36 0d       	add	r19, r6
    20f2:	91 e0       	ldi	r25, 0x01	; 1
    20f4:	36 15       	cp	r19, r6
    20f6:	08 f0       	brcs	.+2      	; 0x20fa <calcChecksumFRAM+0x342>
    20f8:	90 e0       	ldi	r25, 0x00	; 0
    20fa:	29 2b       	or	r18, r25
    20fc:	58 0e       	add	r5, r24
    20fe:	91 e0       	ldi	r25, 0x01	; 1
    2100:	58 16       	cp	r5, r24
    2102:	08 f0       	brcs	.+2      	; 0x2106 <calcChecksumFRAM+0x34e>
    2104:	90 e0       	ldi	r25, 0x00	; 0
    2106:	25 0d       	add	r18, r5
    2108:	81 e0       	ldi	r24, 0x01	; 1
    210a:	25 15       	cp	r18, r5
    210c:	08 f0       	brcs	.+2      	; 0x2110 <calcChecksumFRAM+0x358>
    210e:	80 e0       	ldi	r24, 0x00	; 0
    2110:	98 2b       	or	r25, r24
    2112:	e4 0d       	add	r30, r4
    2114:	9e 0f       	add	r25, r30
    2116:	d6 01       	movw	r26, r12
    2118:	7c 93       	st	X, r23
    211a:	11 96       	adiw	r26, 0x01	; 1
    211c:	fc 93       	st	X, r31
    211e:	11 97       	sbiw	r26, 0x01	; 1
    2120:	12 96       	adiw	r26, 0x02	; 2
    2122:	6c 93       	st	X, r22
    2124:	12 97       	sbiw	r26, 0x02	; 2
    2126:	13 96       	adiw	r26, 0x03	; 3
    2128:	5c 93       	st	X, r21
    212a:	13 97       	sbiw	r26, 0x03	; 3
    212c:	14 96       	adiw	r26, 0x04	; 4
    212e:	4c 93       	st	X, r20
    2130:	14 97       	sbiw	r26, 0x04	; 4
    2132:	15 96       	adiw	r26, 0x05	; 5
    2134:	3c 93       	st	X, r19
    2136:	15 97       	sbiw	r26, 0x05	; 5
    2138:	16 96       	adiw	r26, 0x06	; 6
    213a:	2c 93       	st	X, r18
    213c:	16 97       	sbiw	r26, 0x06	; 6
    213e:	17 96       	adiw	r26, 0x07	; 7
    2140:	9c 93       	st	X, r25
    2142:	17 97       	sbiw	r26, 0x07	; 7
    2144:	79 c0       	rjmp	.+242    	; 0x2238 <calcChecksumFRAM+0x480>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    2146:	88 30       	cpi	r24, 0x08	; 8
    2148:	91 05       	cpc	r25, r1
    214a:	09 f0       	breq	.+2      	; 0x214e <calcChecksumFRAM+0x396>
    214c:	75 c0       	rjmp	.+234    	; 0x2238 <calcChecksumFRAM+0x480>
    214e:	f7 01       	movw	r30, r14
    2150:	60 81       	ld	r22, Z
    2152:	51 81       	ldd	r21, Z+1	; 0x01
    2154:	42 81       	ldd	r20, Z+2	; 0x02
    2156:	33 81       	ldd	r19, Z+3	; 0x03
    2158:	24 81       	ldd	r18, Z+4	; 0x04
    215a:	95 81       	ldd	r25, Z+5	; 0x05
    215c:	86 81       	ldd	r24, Z+6	; 0x06
    215e:	47 80       	ldd	r4, Z+7	; 0x07
    2160:	e0 91 63 50 	lds	r30, 0x5063
    2164:	f0 91 64 50 	lds	r31, 0x5064
    2168:	70 81       	ld	r23, Z
    216a:	a1 81       	ldd	r26, Z+1	; 0x01
    216c:	b2 81       	ldd	r27, Z+2	; 0x02
    216e:	83 80       	ldd	r8, Z+3	; 0x03
    2170:	74 80       	ldd	r7, Z+4	; 0x04
    2172:	65 80       	ldd	r6, Z+5	; 0x05
    2174:	56 80       	ldd	r5, Z+6	; 0x06
    2176:	e7 81       	ldd	r30, Z+7	; 0x07
    2178:	76 0f       	add	r23, r22
    217a:	f1 e0       	ldi	r31, 0x01	; 1
    217c:	76 17       	cp	r23, r22
    217e:	08 f0       	brcs	.+2      	; 0x2182 <calcChecksumFRAM+0x3ca>
    2180:	f0 e0       	ldi	r31, 0x00	; 0
    2182:	a5 0f       	add	r26, r21
    2184:	61 e0       	ldi	r22, 0x01	; 1
    2186:	a5 17       	cp	r26, r21
    2188:	08 f0       	brcs	.+2      	; 0x218c <calcChecksumFRAM+0x3d4>
    218a:	60 e0       	ldi	r22, 0x00	; 0
    218c:	fa 0f       	add	r31, r26
    218e:	51 e0       	ldi	r21, 0x01	; 1
    2190:	fa 17       	cp	r31, r26
    2192:	08 f0       	brcs	.+2      	; 0x2196 <calcChecksumFRAM+0x3de>
    2194:	50 e0       	ldi	r21, 0x00	; 0
    2196:	65 2b       	or	r22, r21
    2198:	b4 0f       	add	r27, r20
    219a:	51 e0       	ldi	r21, 0x01	; 1
    219c:	b4 17       	cp	r27, r20
    219e:	08 f0       	brcs	.+2      	; 0x21a2 <calcChecksumFRAM+0x3ea>
    21a0:	50 e0       	ldi	r21, 0x00	; 0
    21a2:	6b 0f       	add	r22, r27
    21a4:	41 e0       	ldi	r20, 0x01	; 1
    21a6:	6b 17       	cp	r22, r27
    21a8:	08 f0       	brcs	.+2      	; 0x21ac <calcChecksumFRAM+0x3f4>
    21aa:	40 e0       	ldi	r20, 0x00	; 0
    21ac:	54 2b       	or	r21, r20
    21ae:	83 0e       	add	r8, r19
    21b0:	41 e0       	ldi	r20, 0x01	; 1
    21b2:	83 16       	cp	r8, r19
    21b4:	08 f0       	brcs	.+2      	; 0x21b8 <calcChecksumFRAM+0x400>
    21b6:	40 e0       	ldi	r20, 0x00	; 0
    21b8:	58 0d       	add	r21, r8
    21ba:	31 e0       	ldi	r19, 0x01	; 1
    21bc:	58 15       	cp	r21, r8
    21be:	08 f0       	brcs	.+2      	; 0x21c2 <calcChecksumFRAM+0x40a>
    21c0:	30 e0       	ldi	r19, 0x00	; 0
    21c2:	43 2b       	or	r20, r19
    21c4:	72 0e       	add	r7, r18
    21c6:	31 e0       	ldi	r19, 0x01	; 1
    21c8:	72 16       	cp	r7, r18
    21ca:	08 f0       	brcs	.+2      	; 0x21ce <calcChecksumFRAM+0x416>
    21cc:	30 e0       	ldi	r19, 0x00	; 0
    21ce:	47 0d       	add	r20, r7
    21d0:	21 e0       	ldi	r18, 0x01	; 1
    21d2:	47 15       	cp	r20, r7
    21d4:	08 f0       	brcs	.+2      	; 0x21d8 <calcChecksumFRAM+0x420>
    21d6:	20 e0       	ldi	r18, 0x00	; 0
    21d8:	32 2b       	or	r19, r18
    21da:	69 0e       	add	r6, r25
    21dc:	21 e0       	ldi	r18, 0x01	; 1
    21de:	69 16       	cp	r6, r25
    21e0:	08 f0       	brcs	.+2      	; 0x21e4 <calcChecksumFRAM+0x42c>
    21e2:	20 e0       	ldi	r18, 0x00	; 0
    21e4:	36 0d       	add	r19, r6
    21e6:	91 e0       	ldi	r25, 0x01	; 1
    21e8:	36 15       	cp	r19, r6
    21ea:	08 f0       	brcs	.+2      	; 0x21ee <calcChecksumFRAM+0x436>
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	29 2b       	or	r18, r25
    21f0:	58 0e       	add	r5, r24
    21f2:	91 e0       	ldi	r25, 0x01	; 1
    21f4:	58 16       	cp	r5, r24
    21f6:	08 f0       	brcs	.+2      	; 0x21fa <calcChecksumFRAM+0x442>
    21f8:	90 e0       	ldi	r25, 0x00	; 0
    21fa:	25 0d       	add	r18, r5
    21fc:	81 e0       	ldi	r24, 0x01	; 1
    21fe:	25 15       	cp	r18, r5
    2200:	08 f0       	brcs	.+2      	; 0x2204 <calcChecksumFRAM+0x44c>
    2202:	80 e0       	ldi	r24, 0x00	; 0
    2204:	98 2b       	or	r25, r24
    2206:	e4 0d       	add	r30, r4
    2208:	9e 0f       	add	r25, r30
    220a:	d7 01       	movw	r26, r14
    220c:	7c 93       	st	X, r23
    220e:	11 96       	adiw	r26, 0x01	; 1
    2210:	fc 93       	st	X, r31
    2212:	11 97       	sbiw	r26, 0x01	; 1
    2214:	12 96       	adiw	r26, 0x02	; 2
    2216:	6c 93       	st	X, r22
    2218:	12 97       	sbiw	r26, 0x02	; 2
    221a:	13 96       	adiw	r26, 0x03	; 3
    221c:	5c 93       	st	X, r21
    221e:	13 97       	sbiw	r26, 0x03	; 3
    2220:	14 96       	adiw	r26, 0x04	; 4
    2222:	4c 93       	st	X, r20
    2224:	14 97       	sbiw	r26, 0x04	; 4
    2226:	15 96       	adiw	r26, 0x05	; 5
    2228:	3c 93       	st	X, r19
    222a:	15 97       	sbiw	r26, 0x05	; 5
    222c:	16 96       	adiw	r26, 0x06	; 6
    222e:	2c 93       	st	X, r18
    2230:	16 97       	sbiw	r26, 0x06	; 6
    2232:	17 96       	adiw	r26, 0x07	; 7
    2234:	9c 93       	st	X, r25
    2236:	17 97       	sbiw	r26, 0x07	; 7
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2238:	eb 81       	ldd	r30, Y+3	; 0x03
    223a:	fc 81       	ldd	r31, Y+4	; 0x04
    223c:	31 96       	adiw	r30, 0x01	; 1
    223e:	eb 83       	std	Y+3, r30	; 0x03
    2240:	fc 83       	std	Y+4, r31	; 0x04
    2242:	0f 5f       	subi	r16, 0xFF	; 255
    2244:	1f 4f       	sbci	r17, 0xFF	; 255
    2246:	2c e1       	ldi	r18, 0x1C	; 28
    2248:	e1 37       	cpi	r30, 0x71	; 113
    224a:	f2 07       	cpc	r31, r18
    224c:	09 f0       	breq	.+2      	; 0x2250 <calcChecksumFRAM+0x498>
    224e:	3b ce       	rjmp	.-906    	; 0x1ec6 <calcChecksumFRAM+0x10e>
    2250:	89 81       	ldd	r24, Y+1	; 0x01
    2252:	9a 81       	ldd	r25, Y+2	; 0x02
    2254:	01 97       	sbiw	r24, 0x01	; 1
    2256:	89 83       	std	Y+1, r24	; 0x01
    2258:	9a 83       	std	Y+2, r25	; 0x02
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    225a:	00 97       	sbiw	r24, 0x00	; 0
    225c:	09 f0       	breq	.+2      	; 0x2260 <calcChecksumFRAM+0x4a8>
    225e:	1a ce       	rjmp	.-972    	; 0x1e94 <calcChecksumFRAM+0xdc>
			
		}
		
	}
	
}
    2260:	24 96       	adiw	r28, 0x04	; 4
    2262:	cd bf       	out	0x3d, r28	; 61
    2264:	de bf       	out	0x3e, r29	; 62
    2266:	df 91       	pop	r29
    2268:	cf 91       	pop	r28
    226a:	1f 91       	pop	r17
    226c:	0f 91       	pop	r16
    226e:	ff 90       	pop	r15
    2270:	ef 90       	pop	r14
    2272:	df 90       	pop	r13
    2274:	cf 90       	pop	r12
    2276:	bf 90       	pop	r11
    2278:	af 90       	pop	r10
    227a:	9f 90       	pop	r9
    227c:	8f 90       	pop	r8
    227e:	7f 90       	pop	r7
    2280:	6f 90       	pop	r6
    2282:	5f 90       	pop	r5
    2284:	4f 90       	pop	r4
    2286:	3f 90       	pop	r3
    2288:	2f 90       	pop	r2
    228a:	08 95       	ret

0000228c <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    228c:	2f 92       	push	r2
    228e:	3f 92       	push	r3
    2290:	4f 92       	push	r4
    2292:	5f 92       	push	r5
    2294:	6f 92       	push	r6
    2296:	7f 92       	push	r7
    2298:	8f 92       	push	r8
    229a:	9f 92       	push	r9
    229c:	af 92       	push	r10
    229e:	bf 92       	push	r11
    22a0:	cf 92       	push	r12
    22a2:	df 92       	push	r13
    22a4:	ef 92       	push	r14
    22a6:	ff 92       	push	r15
    22a8:	0f 93       	push	r16
    22aa:	1f 93       	push	r17
    22ac:	cf 93       	push	r28
    22ae:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    22b0:	10 92 57 40 	sts	0x4057, r1
    22b4:	10 92 58 40 	sts	0x4058, r1
	sampleCount = 0;
    22b8:	10 92 74 50 	sts	0x5074, r1
    22bc:	10 92 75 50 	sts	0x5075, r1
    22c0:	10 92 76 50 	sts	0x5076, r1
    22c4:	10 92 77 50 	sts	0x5077, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    22c8:	8d e3       	ldi	r24, 0x3D	; 61
    22ca:	91 e2       	ldi	r25, 0x21	; 33
    22cc:	10 92 3d 21 	sts	0x213D, r1
    22d0:	fc 01       	movw	r30, r24
    22d2:	31 97       	sbiw	r30, 0x01	; 1
    22d4:	10 82       	st	Z, r1
    22d6:	02 97       	sbiw	r24, 0x02	; 2
    22d8:	dc 01       	movw	r26, r24
    22da:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    22dc:	81 e0       	ldi	r24, 0x01	; 1
    22de:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    22e2:	84 e0       	ldi	r24, 0x04	; 4
    22e4:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    22e8:	80 ed       	ldi	r24, 0xD0	; 208
    22ea:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    22ee:	8d e0       	ldi	r24, 0x0D	; 13
    22f0:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[1] = 0xF3;
    22f4:	83 ef       	ldi	r24, 0xF3	; 243
    22f6:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[2] = 0x57;
    22fa:	87 e5       	ldi	r24, 0x57	; 87
    22fc:	80 93 67 50 	sts	0x5067, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2300:	80 91 74 50 	lds	r24, 0x5074
    2304:	90 91 75 50 	lds	r25, 0x5075
    2308:	a0 91 76 50 	lds	r26, 0x5076
    230c:	b0 91 77 50 	lds	r27, 0x5077
    2310:	83 35       	cpi	r24, 0x53	; 83
    2312:	e5 e5       	ldi	r30, 0x55	; 85
    2314:	9e 07       	cpc	r25, r30
    2316:	e0 e0       	ldi	r30, 0x00	; 0
    2318:	ae 07       	cpc	r26, r30
    231a:	e0 e0       	ldi	r30, 0x00	; 0
    231c:	be 07       	cpc	r27, r30
    231e:	08 f0       	brcs	.+2      	; 0x2322 <FRAMWriteKnowns+0x96>
    2320:	cc c0       	rjmp	.+408    	; 0x24ba <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2322:	0f 2e       	mov	r0, r31
    2324:	f0 e4       	ldi	r31, 0x40	; 64
    2326:	ef 2e       	mov	r14, r31
    2328:	f6 e0       	ldi	r31, 0x06	; 6
    232a:	ff 2e       	mov	r15, r31
    232c:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    232e:	40 e2       	ldi	r20, 0x20	; 32
    2330:	56 e0       	ldi	r21, 0x06	; 6
    2332:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2334:	e0 ec       	ldi	r30, 0xC0	; 192
    2336:	f8 e0       	ldi	r31, 0x08	; 8
    2338:	0f 2e       	mov	r0, r31
    233a:	f6 e0       	ldi	r31, 0x06	; 6
    233c:	7f 2e       	mov	r7, r31
    233e:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    2340:	c1 e7       	ldi	r28, 0x71	; 113
    2342:	d0 e5       	ldi	r29, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2344:	66 24       	eor	r6, r6
    2346:	68 94       	set
    2348:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    234a:	0f 2e       	mov	r0, r31
    234c:	f7 e5       	ldi	r31, 0x57	; 87
    234e:	cf 2e       	mov	r12, r31
    2350:	f0 e4       	ldi	r31, 0x40	; 64
    2352:	df 2e       	mov	r13, r31
    2354:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2356:	8e 01       	movw	r16, r28
    2358:	0c 50       	subi	r16, 0x0C	; 12
    235a:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    235c:	0f 2e       	mov	r0, r31
    235e:	f5 ef       	ldi	r31, 0xF5	; 245
    2360:	4f 2e       	mov	r4, r31
    2362:	ff ef       	ldi	r31, 0xFF	; 255
    2364:	5f 2e       	mov	r5, r31
    2366:	f0 2d       	mov	r31, r0
    2368:	4c 0e       	add	r4, r28
    236a:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    236c:	0f 2e       	mov	r0, r31
    236e:	f6 ef       	ldi	r31, 0xF6	; 246
    2370:	2f 2e       	mov	r2, r31
    2372:	ff ef       	ldi	r31, 0xFF	; 255
    2374:	3f 2e       	mov	r3, r31
    2376:	f0 2d       	mov	r31, r0
    2378:	2c 0e       	add	r2, r28
    237a:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    237c:	6b e3       	ldi	r22, 0x3B	; 59
    237e:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    2380:	5b 01       	movw	r10, r22
    2382:	08 94       	sec
    2384:	a1 1c       	adc	r10, r1
    2386:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2388:	88 24       	eor	r8, r8
    238a:	99 24       	eor	r9, r9
    238c:	68 94       	set
    238e:	81 f8       	bld	r8, 1
    2390:	86 0e       	add	r8, r22
    2392:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2394:	30 e1       	ldi	r19, 0x10	; 16
    2396:	d7 01       	movw	r26, r14
    2398:	16 96       	adiw	r26, 0x06	; 6
    239a:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    239c:	da 01       	movw	r26, r20
    239e:	16 96       	adiw	r26, 0x06	; 6
    23a0:	2c 93       	st	X, r18
    23a2:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    23a4:	00 00       	nop
		SPIC.DATA = FR_WREN;
    23a6:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23a8:	82 81       	ldd	r24, Z+2	; 0x02
    23aa:	88 23       	and	r24, r24
    23ac:	ec f7       	brge	.-6      	; 0x23a8 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    23ae:	83 81       	ldd	r24, Z+3	; 0x03
    23b0:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    23b2:	da 01       	movw	r26, r20
    23b4:	15 96       	adiw	r26, 0x05	; 5
    23b6:	2c 93       	st	X, r18
    23b8:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    23ba:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    23bc:	16 96       	adiw	r26, 0x06	; 6
    23be:	2c 93       	st	X, r18
    23c0:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    23c2:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    23c4:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23c6:	82 81       	ldd	r24, Z+2	; 0x02
    23c8:	88 23       	and	r24, r24
    23ca:	ec f7       	brge	.-6      	; 0x23c6 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    23cc:	83 81       	ldd	r24, Z+3	; 0x03
    23ce:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    23d0:	d6 01       	movw	r26, r12
    23d2:	11 96       	adiw	r26, 0x01	; 1
    23d4:	8c 91       	ld	r24, X
    23d6:	11 97       	sbiw	r26, 0x01	; 1
    23d8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23da:	82 81       	ldd	r24, Z+2	; 0x02
    23dc:	88 23       	and	r24, r24
    23de:	ec f7       	brge	.-6      	; 0x23da <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    23e0:	83 81       	ldd	r24, Z+3	; 0x03
    23e2:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    23e4:	d6 01       	movw	r26, r12
    23e6:	8c 91       	ld	r24, X
    23e8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23ea:	82 81       	ldd	r24, Z+2	; 0x02
    23ec:	88 23       	and	r24, r24
    23ee:	ec f7       	brge	.-6      	; 0x23ea <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    23f0:	83 81       	ldd	r24, Z+3	; 0x03
    23f2:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    23f4:	d8 01       	movw	r26, r16
    23f6:	8c 91       	ld	r24, X
    23f8:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23fa:	82 81       	ldd	r24, Z+2	; 0x02
    23fc:	88 23       	and	r24, r24
    23fe:	ec f7       	brge	.-6      	; 0x23fa <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    2400:	83 81       	ldd	r24, Z+3	; 0x03
    2402:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2404:	d2 01       	movw	r26, r4
    2406:	8c 91       	ld	r24, X
    2408:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    240a:	82 81       	ldd	r24, Z+2	; 0x02
    240c:	88 23       	and	r24, r24
    240e:	ec f7       	brge	.-6      	; 0x240a <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    2410:	83 81       	ldd	r24, Z+3	; 0x03
    2412:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    2414:	d1 01       	movw	r26, r2
    2416:	8c 91       	ld	r24, X
    2418:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    241a:	82 81       	ldd	r24, Z+2	; 0x02
    241c:	88 23       	and	r24, r24
    241e:	ec f7       	brge	.-6      	; 0x241a <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    2420:	83 81       	ldd	r24, Z+3	; 0x03
    2422:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2424:	da 01       	movw	r26, r20
    2426:	15 96       	adiw	r26, 0x05	; 5
    2428:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    242a:	30 e1       	ldi	r19, 0x10	; 16
    242c:	d7 01       	movw	r26, r14
    242e:	15 96       	adiw	r26, 0x05	; 5
    2430:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    2432:	80 91 57 40 	lds	r24, 0x4057
    2436:	90 91 58 40 	lds	r25, 0x4058
    243a:	03 96       	adiw	r24, 0x03	; 3
    243c:	80 93 57 40 	sts	0x4057, r24
    2440:	90 93 58 40 	sts	0x4058, r25
		checksumADC[0] += SPIBuffer[0];
    2444:	db 01       	movw	r26, r22
    2446:	8c 91       	ld	r24, X
    2448:	d8 01       	movw	r26, r16
    244a:	9c 91       	ld	r25, X
    244c:	89 0f       	add	r24, r25
    244e:	db 01       	movw	r26, r22
    2450:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2452:	d5 01       	movw	r26, r10
    2454:	8c 91       	ld	r24, X
    2456:	a6 e6       	ldi	r26, 0x66	; 102
    2458:	b0 e5       	ldi	r27, 0x50	; 80
    245a:	9c 91       	ld	r25, X
    245c:	89 0f       	add	r24, r25
    245e:	d5 01       	movw	r26, r10
    2460:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2462:	d4 01       	movw	r26, r8
    2464:	8c 91       	ld	r24, X
    2466:	a7 e6       	ldi	r26, 0x67	; 103
    2468:	b0 e5       	ldi	r27, 0x50	; 80
    246a:	9c 91       	ld	r25, X
    246c:	89 0f       	add	r24, r25
    246e:	d4 01       	movw	r26, r8
    2470:	8c 93       	st	X, r24
		
		sampleCount++;
    2472:	80 91 74 50 	lds	r24, 0x5074
    2476:	90 91 75 50 	lds	r25, 0x5075
    247a:	a0 91 76 50 	lds	r26, 0x5076
    247e:	b0 91 77 50 	lds	r27, 0x5077
    2482:	01 96       	adiw	r24, 0x01	; 1
    2484:	a1 1d       	adc	r26, r1
    2486:	b1 1d       	adc	r27, r1
    2488:	80 93 74 50 	sts	0x5074, r24
    248c:	90 93 75 50 	sts	0x5075, r25
    2490:	a0 93 76 50 	sts	0x5076, r26
    2494:	b0 93 77 50 	sts	0x5077, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2498:	80 91 74 50 	lds	r24, 0x5074
    249c:	90 91 75 50 	lds	r25, 0x5075
    24a0:	a0 91 76 50 	lds	r26, 0x5076
    24a4:	b0 91 77 50 	lds	r27, 0x5077
    24a8:	83 35       	cpi	r24, 0x53	; 83
    24aa:	35 e5       	ldi	r19, 0x55	; 85
    24ac:	93 07       	cpc	r25, r19
    24ae:	30 e0       	ldi	r19, 0x00	; 0
    24b0:	a3 07       	cpc	r26, r19
    24b2:	30 e0       	ldi	r19, 0x00	; 0
    24b4:	b3 07       	cpc	r27, r19
    24b6:	08 f4       	brcc	.+2      	; 0x24ba <FRAMWriteKnowns+0x22e>
    24b8:	6d cf       	rjmp	.-294    	; 0x2394 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    24ba:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	ADCPower(FALSE);
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
}
    24c4:	df 91       	pop	r29
    24c6:	cf 91       	pop	r28
    24c8:	1f 91       	pop	r17
    24ca:	0f 91       	pop	r16
    24cc:	ff 90       	pop	r15
    24ce:	ef 90       	pop	r14
    24d0:	df 90       	pop	r13
    24d2:	cf 90       	pop	r12
    24d4:	bf 90       	pop	r11
    24d6:	af 90       	pop	r10
    24d8:	9f 90       	pop	r9
    24da:	8f 90       	pop	r8
    24dc:	7f 90       	pop	r7
    24de:	6f 90       	pop	r6
    24e0:	5f 90       	pop	r5
    24e2:	4f 90       	pop	r4
    24e4:	3f 90       	pop	r3
    24e6:	2f 90       	pop	r2
    24e8:	08 95       	ret

000024ea <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    24ea:	80 ff       	sbrs	r24, 0
    24ec:	05 c0       	rjmp	.+10     	; 0x24f8 <setADCInput+0xe>
    24ee:	20 e4       	ldi	r18, 0x40	; 64
    24f0:	e0 e0       	ldi	r30, 0x00	; 0
    24f2:	f6 e0       	ldi	r31, 0x06	; 6
    24f4:	25 83       	std	Z+5, r18	; 0x05
    24f6:	04 c0       	rjmp	.+8      	; 0x2500 <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    24f8:	20 e4       	ldi	r18, 0x40	; 64
    24fa:	e0 e0       	ldi	r30, 0x00	; 0
    24fc:	f6 e0       	ldi	r31, 0x06	; 6
    24fe:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2500:	81 ff       	sbrs	r24, 1
    2502:	05 c0       	rjmp	.+10     	; 0x250e <setADCInput+0x24>
    2504:	22 e0       	ldi	r18, 0x02	; 2
    2506:	e0 e2       	ldi	r30, 0x20	; 32
    2508:	f6 e0       	ldi	r31, 0x06	; 6
    250a:	25 83       	std	Z+5, r18	; 0x05
    250c:	04 c0       	rjmp	.+8      	; 0x2516 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    250e:	22 e0       	ldi	r18, 0x02	; 2
    2510:	e0 e2       	ldi	r30, 0x20	; 32
    2512:	f6 e0       	ldi	r31, 0x06	; 6
    2514:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2516:	82 ff       	sbrs	r24, 2
    2518:	05 c0       	rjmp	.+10     	; 0x2524 <setADCInput+0x3a>
    251a:	84 e0       	ldi	r24, 0x04	; 4
    251c:	e0 e2       	ldi	r30, 0x20	; 32
    251e:	f6 e0       	ldi	r31, 0x06	; 6
    2520:	85 83       	std	Z+5, r24	; 0x05
    2522:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2524:	84 e0       	ldi	r24, 0x04	; 4
    2526:	e0 e2       	ldi	r30, 0x20	; 32
    2528:	f6 e0       	ldi	r31, 0x06	; 6
    252a:	86 83       	std	Z+6, r24	; 0x06
    252c:	08 95       	ret

0000252e <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    252e:	2f 92       	push	r2
    2530:	3f 92       	push	r3
    2532:	4f 92       	push	r4
    2534:	5f 92       	push	r5
    2536:	7f 92       	push	r7
    2538:	8f 92       	push	r8
    253a:	9f 92       	push	r9
    253c:	af 92       	push	r10
    253e:	bf 92       	push	r11
    2540:	cf 92       	push	r12
    2542:	df 92       	push	r13
    2544:	ef 92       	push	r14
    2546:	ff 92       	push	r15
    2548:	0f 93       	push	r16
    254a:	1f 93       	push	r17
    254c:	cf 93       	push	r28
    254e:	df 93       	push	r29
    2550:	cd b7       	in	r28, 0x3d	; 61
    2552:	de b7       	in	r29, 0x3e	; 62
    2554:	18 2f       	mov	r17, r24
    2556:	76 2e       	mov	r7, r22
    2558:	f4 2e       	mov	r15, r20
    255a:	19 01       	movw	r2, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER=DataArray;
    255c:	89 8d       	ldd	r24, Y+25	; 0x19
    255e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2560:	80 93 72 50 	sts	0x5072, r24
    2564:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    2568:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    256c:	81 e0       	ldi	r24, 0x01	; 1
    256e:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2572:	81 2f       	mov	r24, r17
    2574:	6f 2d       	mov	r22, r15
    2576:	0e 94 c4 03 	call	0x788	; 0x788 <set_ampGain>
	set_filter(filterConfig);
    257a:	87 2d       	mov	r24, r7
    257c:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2580:	8e 2d       	mov	r24, r14
    2582:	0e 94 d6 08 	call	0x11ac	; 0x11ac <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2586:	84 e0       	ldi	r24, 0x04	; 4
    2588:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    258c:	84 e5       	ldi	r24, 0x54	; 84
    258e:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	0e 94 2a 07 	call	0xe54	; 0xe54 <enableADCMUX>
	setADCInput(channel);
    2598:	81 2f       	mov	r24, r17
    259a:	0e 94 75 12 	call	0x24ea	; 0x24ea <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    259e:	e0 ea       	ldi	r30, 0xA0	; 160
    25a0:	f6 e0       	ldi	r31, 0x06	; 6
    25a2:	22 e0       	ldi	r18, 0x02	; 2
    25a4:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    25a6:	77 24       	eor	r7, r7
    25a8:	73 94       	inc	r7
    25aa:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    25ac:	0f 2e       	mov	r0, r31
    25ae:	f0 e8       	ldi	r31, 0x80	; 128
    25b0:	4f 2e       	mov	r4, r31
    25b2:	f1 e0       	ldi	r31, 0x01	; 1
    25b4:	5f 2e       	mov	r5, r31
    25b6:	f0 2d       	mov	r31, r0
    25b8:	88 e7       	ldi	r24, 0x78	; 120
    25ba:	d2 01       	movw	r26, r4
    25bc:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    25be:	e0 e0       	ldi	r30, 0x00	; 0
    25c0:	f9 e0       	ldi	r31, 0x09	; 9
    25c2:	80 ef       	ldi	r24, 0xF0	; 240
    25c4:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    25c6:	c0 a6       	lds	r28, 0xb0
    25c8:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    25ca:	a2 a6       	lds	r26, 0xb2
    25cc:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    25ce:	84 a6       	lds	r24, 0xb4
    25d0:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    25d2:	8d 89       	ldd	r24, Y+21	; 0x15
    25d4:	9e 89       	ldd	r25, Y+22	; 0x16
    25d6:	86 a7       	lds	r24, 0x76
    25d8:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    25da:	80 2f       	mov	r24, r16
    25dc:	90 e0       	ldi	r25, 0x00	; 0
    25de:	01 97       	sbiw	r24, 0x01	; 1
    25e0:	86 a3       	lds	r24, 0x56
    25e2:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    25e4:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    25e6:	8f ef       	ldi	r24, 0xFF	; 255
    25e8:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    25ea:	80 81       	ld	r24, Z
    25ec:	80 7f       	andi	r24, 0xF0	; 240
    25ee:	88 60       	ori	r24, 0x08	; 8
    25f0:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    25f2:	10 92 74 50 	sts	0x5074, r1
    25f6:	10 92 75 50 	sts	0x5075, r1
    25fa:	10 92 76 50 	sts	0x5076, r1
    25fe:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    2602:	10 92 c6 50 	sts	0x50C6, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2606:	e0 ea       	ldi	r30, 0xA0	; 160
    2608:	f0 e0       	ldi	r31, 0x00	; 0
    260a:	82 81       	ldd	r24, Z+2	; 0x02
    260c:	87 60       	ori	r24, 0x07	; 7
    260e:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2610:	78 94       	sei

	SPICS(TRUE);
    2612:	81 e0       	ldi	r24, 0x01	; 1
    2614:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2618:	80 e2       	ldi	r24, 0x20	; 32
    261a:	e0 e8       	ldi	r30, 0x80	; 128
    261c:	f6 e0       	ldi	r31, 0x06	; 6
    261e:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2620:	00 e4       	ldi	r16, 0x40	; 64
    2622:	1a e0       	ldi	r17, 0x0A	; 10
    2624:	83 e2       	ldi	r24, 0x23	; 35
    2626:	f8 01       	movw	r30, r16
    2628:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    262a:	61 01       	movw	r12, r2
    262c:	ee 24       	eor	r14, r14
    262e:	ff 24       	eor	r15, r15
    2630:	60 e8       	ldi	r22, 0x80	; 128
    2632:	74 e8       	ldi	r23, 0x84	; 132
    2634:	8e e1       	ldi	r24, 0x1E	; 30
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	a7 01       	movw	r20, r14
    263a:	96 01       	movw	r18, r12
    263c:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    2640:	d8 01       	movw	r26, r16
    2642:	96 96       	adiw	r26, 0x26	; 38
    2644:	2d 93       	st	X+, r18
    2646:	3c 93       	st	X, r19
    2648:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    264a:	60 e4       	ldi	r22, 0x40	; 64
    264c:	72 e4       	ldi	r23, 0x42	; 66
    264e:	8f e0       	ldi	r24, 0x0F	; 15
    2650:	90 e0       	ldi	r25, 0x00	; 0
    2652:	a7 01       	movw	r20, r14
    2654:	96 01       	movw	r18, r12
    2656:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    265a:	f8 01       	movw	r30, r16
    265c:	22 af       	sts	0x72, r18
    265e:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2660:	e0 e4       	ldi	r30, 0x40	; 64
    2662:	f8 e0       	ldi	r31, 0x08	; 8
    2664:	8f 89       	ldd	r24, Y+23	; 0x17
    2666:	98 8d       	ldd	r25, Y+24	; 0x18
    2668:	86 a3       	lds	r24, 0x56
    266a:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    266c:	80 ed       	ldi	r24, 0xD0	; 208
    266e:	d2 01       	movw	r26, r4
    2670:	11 96       	adiw	r26, 0x01	; 1
    2672:	8c 93       	st	X, r24
    2674:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2676:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2678:	80 81       	ld	r24, Z
    267a:	80 7f       	andi	r24, 0xF0	; 240
    267c:	89 60       	ori	r24, 0x09	; 9
    267e:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2680:	f8 01       	movw	r30, r16
    2682:	80 81       	ld	r24, Z
    2684:	80 7f       	andi	r24, 0xF0	; 240
    2686:	81 60       	ori	r24, 0x01	; 1
    2688:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    268a:	df 91       	pop	r29
    268c:	cf 91       	pop	r28
    268e:	1f 91       	pop	r17
    2690:	0f 91       	pop	r16
    2692:	ff 90       	pop	r15
    2694:	ef 90       	pop	r14
    2696:	df 90       	pop	r13
    2698:	cf 90       	pop	r12
    269a:	bf 90       	pop	r11
    269c:	af 90       	pop	r10
    269e:	9f 90       	pop	r9
    26a0:	8f 90       	pop	r8
    26a2:	7f 90       	pop	r7
    26a4:	5f 90       	pop	r5
    26a6:	4f 90       	pop	r4
    26a8:	3f 90       	pop	r3
    26aa:	2f 90       	pop	r2
    26ac:	08 95       	ret

000026ae <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    26ae:	2f 92       	push	r2
    26b0:	3f 92       	push	r3
    26b2:	4f 92       	push	r4
    26b4:	5f 92       	push	r5
    26b6:	6f 92       	push	r6
    26b8:	7f 92       	push	r7
    26ba:	8f 92       	push	r8
    26bc:	9f 92       	push	r9
    26be:	af 92       	push	r10
    26c0:	bf 92       	push	r11
    26c2:	cf 92       	push	r12
    26c4:	df 92       	push	r13
    26c6:	ef 92       	push	r14
    26c8:	ff 92       	push	r15
    26ca:	0f 93       	push	r16
    26cc:	cf 93       	push	r28
    26ce:	df 93       	push	r29
    26d0:	cd b7       	in	r28, 0x3d	; 61
    26d2:	de b7       	in	r29, 0x3e	; 62
    26d4:	96 2f       	mov	r25, r22
    26d6:	1a 01       	movw	r2, r20
    26d8:	52 2f       	mov	r21, r18
    26da:	70 2f       	mov	r23, r16
    26dc:	d7 01       	movw	r26, r14
    26de:	36 01       	movw	r6, r12
    26e0:	25 01       	movw	r4, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    26e2:	00 d0       	rcall	.+0      	; 0x26e4 <CO_collectSeismic1Channel+0x36>
    26e4:	00 d0       	rcall	.+0      	; 0x26e6 <CO_collectSeismic1Channel+0x38>
    26e6:	2d b7       	in	r18, 0x3d	; 61
    26e8:	3e b7       	in	r19, 0x3e	; 62
    26ea:	2f 5f       	subi	r18, 0xFF	; 255
    26ec:	3f 4f       	sbci	r19, 0xFF	; 255
    26ee:	ed b7       	in	r30, 0x3d	; 61
    26f0:	fe b7       	in	r31, 0x3e	; 62
    26f2:	81 82       	std	Z+1, r8	; 0x01
    26f4:	92 82       	std	Z+2, r9	; 0x02
    26f6:	8d 88       	ldd	r8, Y+21	; 0x15
    26f8:	9e 88       	ldd	r9, Y+22	; 0x16
    26fa:	f9 01       	movw	r30, r18
    26fc:	82 82       	std	Z+2, r8	; 0x02
    26fe:	93 82       	std	Z+3, r9	; 0x03
    2700:	8f 88       	ldd	r8, Y+23	; 0x17
    2702:	98 8c       	ldd	r9, Y+24	; 0x18
    2704:	84 82       	std	Z+4, r8	; 0x04
    2706:	95 82       	std	Z+5, r9	; 0x05
    2708:	64 ec       	ldi	r22, 0xC4	; 196
    270a:	49 2f       	mov	r20, r25
    270c:	91 01       	movw	r18, r2
    270e:	05 2f       	mov	r16, r21
    2710:	e7 2e       	mov	r14, r23
    2712:	6d 01       	movw	r12, r26
    2714:	53 01       	movw	r10, r6
    2716:	42 01       	movw	r8, r4
    2718:	0e 94 97 12 	call	0x252e	; 0x252e <CO_collectSeismic1Channel_ext>
    271c:	8d b7       	in	r24, 0x3d	; 61
    271e:	9e b7       	in	r25, 0x3e	; 62
    2720:	06 96       	adiw	r24, 0x06	; 6
    2722:	8d bf       	out	0x3d, r24	; 61
    2724:	9e bf       	out	0x3e, r25	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    2726:	df 91       	pop	r29
    2728:	cf 91       	pop	r28
    272a:	0f 91       	pop	r16
    272c:	ff 90       	pop	r15
    272e:	ef 90       	pop	r14
    2730:	df 90       	pop	r13
    2732:	cf 90       	pop	r12
    2734:	bf 90       	pop	r11
    2736:	af 90       	pop	r10
    2738:	9f 90       	pop	r9
    273a:	8f 90       	pop	r8
    273c:	7f 90       	pop	r7
    273e:	6f 90       	pop	r6
    2740:	5f 90       	pop	r5
    2742:	4f 90       	pop	r4
    2744:	3f 90       	pop	r3
    2746:	2f 90       	pop	r2
    2748:	08 95       	ret

0000274a <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    274a:	2f 92       	push	r2
    274c:	3f 92       	push	r3
    274e:	5f 92       	push	r5
    2750:	6f 92       	push	r6
    2752:	7f 92       	push	r7
    2754:	8f 92       	push	r8
    2756:	9f 92       	push	r9
    2758:	af 92       	push	r10
    275a:	bf 92       	push	r11
    275c:	cf 92       	push	r12
    275e:	df 92       	push	r13
    2760:	ef 92       	push	r14
    2762:	ff 92       	push	r15
    2764:	0f 93       	push	r16
    2766:	1f 93       	push	r17
    2768:	cf 93       	push	r28
    276a:	df 93       	push	r29
    276c:	0f 92       	push	r0
    276e:	0f 92       	push	r0
    2770:	cd b7       	in	r28, 0x3d	; 61
    2772:	de b7       	in	r29, 0x3e	; 62
    2774:	18 2f       	mov	r17, r24
    2776:	3b 01       	movw	r6, r22
    2778:	49 83       	std	Y+1, r20	; 0x01
    277a:	5a 83       	std	Y+2, r21	; 0x02
    277c:	52 2e       	mov	r5, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER = DataArray;
    277e:	89 8d       	ldd	r24, Y+25	; 0x19
    2780:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2782:	80 93 72 50 	sts	0x5072, r24
    2786:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    278a:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    278e:	81 e0       	ldi	r24, 0x01	; 1
    2790:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2794:	85 e0       	ldi	r24, 0x05	; 5
    2796:	d3 01       	movw	r26, r6
    2798:	6c 91       	ld	r22, X
    279a:	0e 94 c4 03 	call	0x788	; 0x788 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    279e:	86 e0       	ldi	r24, 0x06	; 6
    27a0:	f3 01       	movw	r30, r6
    27a2:	61 81       	ldd	r22, Z+1	; 0x01
    27a4:	0e 94 c4 03 	call	0x788	; 0x788 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    27a8:	87 e0       	ldi	r24, 0x07	; 7
    27aa:	d3 01       	movw	r26, r6
    27ac:	12 96       	adiw	r26, 0x02	; 2
    27ae:	6c 91       	ld	r22, X
    27b0:	0e 94 c4 03 	call	0x788	; 0x788 <set_ampGain>
	set_filter(filterConfig);
    27b4:	81 2f       	mov	r24, r17
    27b6:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    27ba:	80 2f       	mov	r24, r16
    27bc:	0e 94 d6 08 	call	0x11ac	; 0x11ac <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    27c0:	84 e0       	ldi	r24, 0x04	; 4
    27c2:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    27c6:	84 e5       	ldi	r24, 0x54	; 84
    27c8:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    27cc:	81 e0       	ldi	r24, 0x01	; 1
    27ce:	0e 94 2a 07 	call	0xe54	; 0xe54 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    27d2:	85 e0       	ldi	r24, 0x05	; 5
    27d4:	0e 94 75 12 	call	0x24ea	; 0x24ea <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    27d8:	e0 ea       	ldi	r30, 0xA0	; 160
    27da:	f6 e0       	ldi	r31, 0x06	; 6
    27dc:	22 e0       	ldi	r18, 0x02	; 2
    27de:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    27e0:	66 24       	eor	r6, r6
    27e2:	63 94       	inc	r6
    27e4:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    27e6:	0f 2e       	mov	r0, r31
    27e8:	f0 e8       	ldi	r31, 0x80	; 128
    27ea:	2f 2e       	mov	r2, r31
    27ec:	f1 e0       	ldi	r31, 0x01	; 1
    27ee:	3f 2e       	mov	r3, r31
    27f0:	f0 2d       	mov	r31, r0
    27f2:	88 e7       	ldi	r24, 0x78	; 120
    27f4:	f1 01       	movw	r30, r2
    27f6:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    27f8:	e0 e0       	ldi	r30, 0x00	; 0
    27fa:	f8 e0       	ldi	r31, 0x08	; 8
    27fc:	80 ef       	ldi	r24, 0xF0	; 240
    27fe:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2800:	e0 a6       	lds	r30, 0xb0
    2802:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2804:	c2 a6       	lds	r28, 0xb2
    2806:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2808:	a4 a6       	lds	r26, 0xb4
    280a:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    280c:	86 a6       	lds	r24, 0xb6
    280e:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2810:	85 2d       	mov	r24, r5
    2812:	90 e0       	ldi	r25, 0x00	; 0
    2814:	01 97       	sbiw	r24, 0x01	; 1
    2816:	86 a3       	lds	r24, 0x56
    2818:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    281a:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    281c:	8f ef       	ldi	r24, 0xFF	; 255
    281e:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2820:	80 81       	ld	r24, Z
    2822:	80 7f       	andi	r24, 0xF0	; 240
    2824:	88 60       	ori	r24, 0x08	; 8
    2826:	80 83       	st	Z, r24

	sampleCount = 0;
    2828:	10 92 74 50 	sts	0x5074, r1
    282c:	10 92 75 50 	sts	0x5075, r1
    2830:	10 92 76 50 	sts	0x5076, r1
    2834:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    2838:	10 92 c6 50 	sts	0x50C6, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    283c:	8d e3       	ldi	r24, 0x3D	; 61
    283e:	91 e2       	ldi	r25, 0x21	; 33
    2840:	10 92 3d 21 	sts	0x213D, r1
    2844:	fc 01       	movw	r30, r24
    2846:	31 97       	sbiw	r30, 0x01	; 1
    2848:	10 82       	st	Z, r1
    284a:	02 97       	sbiw	r24, 0x02	; 2
    284c:	dc 01       	movw	r26, r24
    284e:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    2850:	e0 ea       	ldi	r30, 0xA0	; 160
    2852:	f0 e0       	ldi	r31, 0x00	; 0
    2854:	82 81       	ldd	r24, Z+2	; 0x02
    2856:	87 60       	ori	r24, 0x07	; 7
    2858:	82 83       	std	Z+2, r24	; 0x02
	sei();
    285a:	78 94       	sei

	SPICS(TRUE);
    285c:	81 e0       	ldi	r24, 0x01	; 1
    285e:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2862:	80 e2       	ldi	r24, 0x20	; 32
    2864:	e0 e8       	ldi	r30, 0x80	; 128
    2866:	f6 e0       	ldi	r31, 0x06	; 6
    2868:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    286a:	00 e4       	ldi	r16, 0x40	; 64
    286c:	1a e0       	ldi	r17, 0x0A	; 10
    286e:	83 e2       	ldi	r24, 0x23	; 35
    2870:	f8 01       	movw	r30, r16
    2872:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2874:	89 81       	ldd	r24, Y+1	; 0x01
    2876:	9a 81       	ldd	r25, Y+2	; 0x02
    2878:	6c 01       	movw	r12, r24
    287a:	ee 24       	eor	r14, r14
    287c:	ff 24       	eor	r15, r15
    287e:	60 e8       	ldi	r22, 0x80	; 128
    2880:	74 e8       	ldi	r23, 0x84	; 132
    2882:	8e e1       	ldi	r24, 0x1E	; 30
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	a7 01       	movw	r20, r14
    2888:	96 01       	movw	r18, r12
    288a:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    288e:	d8 01       	movw	r26, r16
    2890:	96 96       	adiw	r26, 0x26	; 38
    2892:	2d 93       	st	X+, r18
    2894:	3c 93       	st	X, r19
    2896:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2898:	60 e4       	ldi	r22, 0x40	; 64
    289a:	72 e4       	ldi	r23, 0x42	; 66
    289c:	8f e0       	ldi	r24, 0x0F	; 15
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	a7 01       	movw	r20, r14
    28a2:	96 01       	movw	r18, r12
    28a4:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    28a8:	f8 01       	movw	r30, r16
    28aa:	22 af       	sts	0x72, r18
    28ac:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    28ae:	e0 e4       	ldi	r30, 0x40	; 64
    28b0:	f8 e0       	ldi	r31, 0x08	; 8
    28b2:	8f 89       	ldd	r24, Y+23	; 0x17
    28b4:	98 8d       	ldd	r25, Y+24	; 0x18
    28b6:	86 a3       	lds	r24, 0x56
    28b8:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    28ba:	80 ec       	ldi	r24, 0xC0	; 192
    28bc:	d1 01       	movw	r26, r2
    28be:	11 96       	adiw	r26, 0x01	; 1
    28c0:	8c 93       	st	X, r24
    28c2:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    28c4:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    28c6:	80 81       	ld	r24, Z
    28c8:	80 7f       	andi	r24, 0xF0	; 240
    28ca:	89 60       	ori	r24, 0x09	; 9
    28cc:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    28ce:	f8 01       	movw	r30, r16
    28d0:	80 81       	ld	r24, Z
    28d2:	80 7f       	andi	r24, 0xF0	; 240
    28d4:	81 60       	ori	r24, 0x01	; 1
    28d6:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    28d8:	0f 90       	pop	r0
    28da:	0f 90       	pop	r0
    28dc:	df 91       	pop	r29
    28de:	cf 91       	pop	r28
    28e0:	1f 91       	pop	r17
    28e2:	0f 91       	pop	r16
    28e4:	ff 90       	pop	r15
    28e6:	ef 90       	pop	r14
    28e8:	df 90       	pop	r13
    28ea:	cf 90       	pop	r12
    28ec:	bf 90       	pop	r11
    28ee:	af 90       	pop	r10
    28f0:	9f 90       	pop	r9
    28f2:	8f 90       	pop	r8
    28f4:	7f 90       	pop	r7
    28f6:	6f 90       	pop	r6
    28f8:	5f 90       	pop	r5
    28fa:	3f 90       	pop	r3
    28fc:	2f 90       	pop	r2
    28fe:	08 95       	ret

00002900 <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2900:	2f 92       	push	r2
    2902:	3f 92       	push	r3
    2904:	4f 92       	push	r4
    2906:	5f 92       	push	r5
    2908:	6f 92       	push	r6
    290a:	7f 92       	push	r7
    290c:	8f 92       	push	r8
    290e:	9f 92       	push	r9
    2910:	af 92       	push	r10
    2912:	bf 92       	push	r11
    2914:	cf 92       	push	r12
    2916:	df 92       	push	r13
    2918:	ef 92       	push	r14
    291a:	ff 92       	push	r15
    291c:	0f 93       	push	r16
    291e:	1f 93       	push	r17
    2920:	cf 93       	push	r28
    2922:	df 93       	push	r29
    2924:	00 d0       	rcall	.+0      	; 0x2926 <CO_collectSeismic3Axises+0x26>
    2926:	0f 92       	push	r0
    2928:	cd b7       	in	r28, 0x3d	; 61
    292a:	de b7       	in	r29, 0x3e	; 62
    292c:	8b 83       	std	Y+3, r24	; 0x03
    292e:	9c 83       	std	Y+4, r25	; 0x04
    2930:	db 01       	movw	r26, r22
    2932:	94 2f       	mov	r25, r20
    2934:	32 2f       	mov	r19, r18
    2936:	38 01       	movw	r6, r16
    2938:	27 01       	movw	r4, r14
    293a:	16 01       	movw	r2, r12
    293c:	a9 82       	std	Y+1, r10	; 0x01
    293e:	ba 82       	std	Y+2, r11	; 0x02
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    2940:	00 d0       	rcall	.+0      	; 0x2942 <CO_collectSeismic3Axises+0x42>
    2942:	0f 92       	push	r0
    2944:	ed b7       	in	r30, 0x3d	; 61
    2946:	fe b7       	in	r31, 0x3e	; 62
    2948:	81 82       	std	Z+1, r8	; 0x01
    294a:	92 82       	std	Z+2, r9	; 0x02
    294c:	4a 8d       	ldd	r20, Y+26	; 0x1a
    294e:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2950:	43 83       	std	Z+3, r20	; 0x03
    2952:	54 83       	std	Z+4, r21	; 0x04
    2954:	84 ec       	ldi	r24, 0xC4	; 196
    2956:	6b 81       	ldd	r22, Y+3	; 0x03
    2958:	7c 81       	ldd	r23, Y+4	; 0x04
    295a:	ad 01       	movw	r20, r26
    295c:	29 2f       	mov	r18, r25
    295e:	03 2f       	mov	r16, r19
    2960:	73 01       	movw	r14, r6
    2962:	62 01       	movw	r12, r4
    2964:	51 01       	movw	r10, r2
    2966:	89 80       	ldd	r8, Y+1	; 0x01
    2968:	9a 80       	ldd	r9, Y+2	; 0x02
    296a:	0e 94 a5 13 	call	0x274a	; 0x274a <CO_collectSeismic3Axises_ext>
    296e:	0f 90       	pop	r0
    2970:	0f 90       	pop	r0
    2972:	0f 90       	pop	r0
    2974:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    2976:	24 96       	adiw	r28, 0x04	; 4
    2978:	cd bf       	out	0x3d, r28	; 61
    297a:	de bf       	out	0x3e, r29	; 62
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	1f 91       	pop	r17
    2982:	0f 91       	pop	r16
    2984:	ff 90       	pop	r15
    2986:	ef 90       	pop	r14
    2988:	df 90       	pop	r13
    298a:	cf 90       	pop	r12
    298c:	bf 90       	pop	r11
    298e:	af 90       	pop	r10
    2990:	9f 90       	pop	r9
    2992:	8f 90       	pop	r8
    2994:	7f 90       	pop	r7
    2996:	6f 90       	pop	r6
    2998:	5f 90       	pop	r5
    299a:	4f 90       	pop	r4
    299c:	3f 90       	pop	r3
    299e:	2f 90       	pop	r2
    29a0:	08 95       	ret

000029a2 <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    29a2:	8f 92       	push	r8
    29a4:	9f 92       	push	r9
    29a6:	af 92       	push	r10
    29a8:	bf 92       	push	r11
    29aa:	df 92       	push	r13
    29ac:	ef 92       	push	r14
    29ae:	ff 92       	push	r15
    29b0:	0f 93       	push	r16
    29b2:	1f 93       	push	r17
    29b4:	cf 93       	push	r28
    29b6:	df 93       	push	r29
    29b8:	c8 2f       	mov	r28, r24
    29ba:	d6 2e       	mov	r13, r22
    29bc:	d4 2f       	mov	r29, r20
    29be:	59 01       	movw	r10, r18
    29c0:	48 01       	movw	r8, r16
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif

	uint16_t period;
	ADC_BUFFER = DataArray;
    29c2:	e0 92 72 50 	sts	0x5072, r14
    29c6:	f0 92 73 50 	sts	0x5073, r15
	ADC_Sampling_Finished = 0;
    29ca:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    29ce:	81 e0       	ldi	r24, 0x01	; 1
    29d0:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    29d4:	8c 2f       	mov	r24, r28
    29d6:	6d 2f       	mov	r22, r29
    29d8:	0e 94 c4 03 	call	0x788	; 0x788 <set_ampGain>
	set_filter(filterConfig);
    29dc:	8d 2d       	mov	r24, r13
    29de:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    29e2:	8c 2f       	mov	r24, r28
    29e4:	85 50       	subi	r24, 0x05	; 5
    29e6:	83 30       	cpi	r24, 0x03	; 3
    29e8:	18 f4       	brcc	.+6      	; 0x29f0 <CO_collectADC_ext+0x4e>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	0e 94 d6 08 	call	0x11ac	; 0x11ac <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    29f0:	81 e0       	ldi	r24, 0x01	; 1
    29f2:	0e 94 2a 07 	call	0xe54	; 0xe54 <enableADCMUX>
	setADCInput(channel);
    29f6:	8c 2f       	mov	r24, r28
    29f8:	0e 94 75 12 	call	0x24ea	; 0x24ea <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    29fc:	84 e0       	ldi	r24, 0x04	; 4
    29fe:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2a02:	84 e5       	ldi	r24, 0x54	; 84
    2a04:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2a08:	e0 ea       	ldi	r30, 0xA0	; 160
    2a0a:	f6 e0       	ldi	r31, 0x06	; 6
    2a0c:	dd 24       	eor	r13, r13
    2a0e:	d3 94       	inc	r13
    2a10:	d2 82       	std	Z+2, r13	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2a12:	82 e0       	ldi	r24, 0x02	; 2
    2a14:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    2a16:	d2 86       	std	Z+10, r13	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2a18:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2a1a:	80 e2       	ldi	r24, 0x20	; 32
    2a1c:	e0 e8       	ldi	r30, 0x80	; 128
    2a1e:	f6 e0       	ldi	r31, 0x06	; 6
    2a20:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a22:	c0 e4       	ldi	r28, 0x40	; 64
    2a24:	da e0       	ldi	r29, 0x0A	; 10
    2a26:	83 e2       	ldi	r24, 0x23	; 35
    2a28:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2a2a:	95 01       	movw	r18, r10
    2a2c:	40 e0       	ldi	r20, 0x00	; 0
    2a2e:	50 e0       	ldi	r21, 0x00	; 0
    2a30:	60 e8       	ldi	r22, 0x80	; 128
    2a32:	74 e8       	ldi	r23, 0x84	; 132
    2a34:	8e e1       	ldi	r24, 0x1E	; 30
    2a36:	90 e0       	ldi	r25, 0x00	; 0
    2a38:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    2a3c:	89 01       	movw	r16, r18
    2a3e:	9a 01       	movw	r18, r20
    2a40:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    2a42:	0e a3       	lds	r16, 0x5e
    2a44:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    2a46:	96 95       	lsr	r25
    2a48:	87 95       	ror	r24
    2a4a:	8a af       	sts	0x7a, r24
    2a4c:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    2a4e:	e0 e4       	ldi	r30, 0x40	; 64
    2a50:	f8 e0       	ldi	r31, 0x08	; 8
    2a52:	86 a2       	lds	r24, 0x96
    2a54:	97 a2       	lds	r25, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2a56:	88 e7       	ldi	r24, 0x78	; 120
    2a58:	a0 e8       	ldi	r26, 0x80	; 128
    2a5a:	b1 e0       	ldi	r27, 0x01	; 1
    2a5c:	11 96       	adiw	r26, 0x01	; 1
    2a5e:	8c 93       	st	X, r24
    2a60:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2a62:	d6 82       	std	Z+6, r13	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2a64:	88 81       	ld	r24, Y
    2a66:	80 7f       	andi	r24, 0xF0	; 240
    2a68:	81 60       	ori	r24, 0x01	; 1
    2a6a:	88 83       	st	Y, r24
	
	sampleCount = 0;
    2a6c:	10 92 74 50 	sts	0x5074, r1
    2a70:	10 92 75 50 	sts	0x5075, r1
    2a74:	10 92 76 50 	sts	0x5076, r1
    2a78:	10 92 77 50 	sts	0x5077, r1
	discardCount = 0;
    2a7c:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2a80:	e0 ea       	ldi	r30, 0xA0	; 160
    2a82:	f0 e0       	ldi	r31, 0x00	; 0
    2a84:	82 81       	ldd	r24, Z+2	; 0x02
    2a86:	83 60       	ori	r24, 0x03	; 3
    2a88:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2a8a:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2a8c:	df 91       	pop	r29
    2a8e:	cf 91       	pop	r28
    2a90:	1f 91       	pop	r17
    2a92:	0f 91       	pop	r16
    2a94:	ff 90       	pop	r15
    2a96:	ef 90       	pop	r14
    2a98:	df 90       	pop	r13
    2a9a:	bf 90       	pop	r11
    2a9c:	af 90       	pop	r10
    2a9e:	9f 90       	pop	r9
    2aa0:	8f 90       	pop	r8
    2aa2:	08 95       	ret

00002aa4 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2aa4:	ef 92       	push	r14
    2aa6:	ff 92       	push	r15
    2aa8:	0f 93       	push	r16
    2aaa:	1f 93       	push	r17
    2aac:	96 2f       	mov	r25, r22
    2aae:	fa 01       	movw	r30, r20
    2ab0:	d9 01       	movw	r26, r18
    2ab2:	78 01       	movw	r14, r16
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    2ab4:	64 ec       	ldi	r22, 0xC4	; 196
    2ab6:	49 2f       	mov	r20, r25
    2ab8:	9f 01       	movw	r18, r30
    2aba:	8d 01       	movw	r16, r26
    2abc:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <CO_collectADC_ext>
}
    2ac0:	1f 91       	pop	r17
    2ac2:	0f 91       	pop	r16
    2ac4:	ff 90       	pop	r15
    2ac6:	ef 90       	pop	r14
    2ac8:	08 95       	ret

00002aca <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2aca:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2acc:	81 e0       	ldi	r24, 0x01	; 1
    2ace:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2ad0:	84 81       	ldd	r24, Z+4	; 0x04
    2ad2:	95 81       	ldd	r25, Z+5	; 0x05
    2ad4:	86 1b       	sub	r24, r22
    2ad6:	91 09       	sbc	r25, r1

	return answer;
}
    2ad8:	08 95       	ret

00002ada <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2ada:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2adc:	81 e0       	ldi	r24, 0x01	; 1
    2ade:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2ae0:	84 81       	ldd	r24, Z+4	; 0x04
    2ae2:	95 81       	ldd	r25, Z+5	; 0x05
    2ae4:	77 27       	eor	r23, r23
    2ae6:	67 fd       	sbrc	r22, 7
    2ae8:	70 95       	com	r23
    2aea:	86 1b       	sub	r24, r22
    2aec:	97 0b       	sbc	r25, r23

	return answer;
}
    2aee:	08 95       	ret

00002af0 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2af0:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2af2:	81 e0       	ldi	r24, 0x01	; 1
    2af4:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    2af6:	84 81       	ldd	r24, Z+4	; 0x04
    2af8:	95 81       	ldd	r25, Z+5	; 0x05
}
    2afa:	08 95       	ret

00002afc <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2afc:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2afe:	81 e0       	ldi	r24, 0x01	; 1
    2b00:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2b02:	84 81       	ldd	r24, Z+4	; 0x04
}
    2b04:	08 95       	ret

00002b06 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    2b06:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b08:	81 e0       	ldi	r24, 0x01	; 1
    2b0a:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2b0c:	85 81       	ldd	r24, Z+5	; 0x05
}
    2b0e:	08 95       	ret

00002b10 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2b10:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2b12:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    2b14:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2b16:	9a e2       	ldi	r25, 0x2A	; 42
    2b18:	9a 95       	dec	r25
    2b1a:	f1 f7       	brne	.-4      	; 0x2b18 <ADC_Wait_8MHz+0x8>
    2b1c:	00 c0       	rjmp	.+0      	; 0x2b1e <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2b1e:	84 83       	std	Z+4, r24	; 0x04
}
    2b20:	08 95       	ret

00002b22 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2b22:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2b24:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    2b26:	91 e0       	ldi	r25, 0x01	; 1
    2b28:	94 83       	std	Z+4, r25	; 0x04
    2b2a:	95 e5       	ldi	r25, 0x55	; 85
    2b2c:	9a 95       	dec	r25
    2b2e:	f1 f7       	brne	.-4      	; 0x2b2c <ADC_Wait_32MHz+0xa>
    2b30:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2b32:	84 83       	std	Z+4, r24	; 0x04
}
    2b34:	08 95       	ret

00002b36 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2b36:	ef 92       	push	r14
    2b38:	ff 92       	push	r15
    2b3a:	0f 93       	push	r16
    2b3c:	1f 93       	push	r17
    2b3e:	cf 93       	push	r28
    2b40:	df 93       	push	r29
    2b42:	eb 01       	movw	r28, r22
    if (oversampling)
    2b44:	44 23       	and	r20, r20
    2b46:	c9 f0       	breq	.+50     	; 0x2b7a <ADC_Offset_Get_Unsigned+0x44>
    2b48:	04 e0       	ldi	r16, 0x04	; 4
    2b4a:	10 e0       	ldi	r17, 0x00	; 0
    2b4c:	ee 24       	eor	r14, r14
    2b4e:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2b50:	88 81       	ld	r24, Y
    2b52:	80 68       	ori	r24, 0x80	; 128
    2b54:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2b56:	8b 81       	ldd	r24, Y+3	; 0x03
    2b58:	80 ff       	sbrs	r24, 0
    2b5a:	fd cf       	rjmp	.-6      	; 0x2b56 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    2b5c:	ce 01       	movw	r24, r28
    2b5e:	60 e0       	ldi	r22, 0x00	; 0
    2b60:	0e 94 65 15 	call	0x2aca	; 0x2aca <ADC_ResultCh_GetWord_Unsigned>
    2b64:	e8 0e       	add	r14, r24
    2b66:	f9 1e       	adc	r15, r25
    2b68:	01 50       	subi	r16, 0x01	; 1
    2b6a:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    2b6c:	89 f7       	brne	.-30     	; 0x2b50 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    2b6e:	c7 01       	movw	r24, r14
    2b70:	96 95       	lsr	r25
    2b72:	87 95       	ror	r24
    2b74:	96 95       	lsr	r25
    2b76:	87 95       	ror	r24
    2b78:	09 c0       	rjmp	.+18     	; 0x2b8c <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2b7a:	88 81       	ld	r24, Y
    2b7c:	80 68       	ori	r24, 0x80	; 128
    2b7e:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2b80:	8b 81       	ldd	r24, Y+3	; 0x03
    2b82:	80 ff       	sbrs	r24, 0
    2b84:	fd cf       	rjmp	.-6      	; 0x2b80 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    2b86:	ce 01       	movw	r24, r28
    2b88:	0e 94 78 15 	call	0x2af0	; 0x2af0 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    2b8c:	df 91       	pop	r29
    2b8e:	cf 91       	pop	r28
    2b90:	1f 91       	pop	r17
    2b92:	0f 91       	pop	r16
    2b94:	ff 90       	pop	r15
    2b96:	ef 90       	pop	r14
    2b98:	08 95       	ret

00002b9a <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2b9a:	ef 92       	push	r14
    2b9c:	ff 92       	push	r15
    2b9e:	0f 93       	push	r16
    2ba0:	1f 93       	push	r17
    2ba2:	cf 93       	push	r28
    2ba4:	df 93       	push	r29
    2ba6:	eb 01       	movw	r28, r22
    if (oversampling)
    2ba8:	44 23       	and	r20, r20
    2baa:	e1 f0       	breq	.+56     	; 0x2be4 <ADC_Offset_Get_Signed+0x4a>
    2bac:	04 e0       	ldi	r16, 0x04	; 4
    2bae:	10 e0       	ldi	r17, 0x00	; 0
    2bb0:	ee 24       	eor	r14, r14
    2bb2:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2bb4:	88 81       	ld	r24, Y
    2bb6:	80 68       	ori	r24, 0x80	; 128
    2bb8:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2bba:	8b 81       	ldd	r24, Y+3	; 0x03
    2bbc:	80 ff       	sbrs	r24, 0
    2bbe:	fd cf       	rjmp	.-6      	; 0x2bba <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2bc0:	ce 01       	movw	r24, r28
    2bc2:	60 e0       	ldi	r22, 0x00	; 0
    2bc4:	0e 94 6d 15 	call	0x2ada	; 0x2ada <ADC_ResultCh_GetWord_Signed>
    2bc8:	e8 0e       	add	r14, r24
    2bca:	f9 1e       	adc	r15, r25
    2bcc:	01 50       	subi	r16, 0x01	; 1
    2bce:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2bd0:	89 f7       	brne	.-30     	; 0x2bb4 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    2bd2:	c7 01       	movw	r24, r14
    2bd4:	99 23       	and	r25, r25
    2bd6:	0c f4       	brge	.+2      	; 0x2bda <ADC_Offset_Get_Signed+0x40>
    2bd8:	03 96       	adiw	r24, 0x03	; 3
    2bda:	95 95       	asr	r25
    2bdc:	87 95       	ror	r24
    2bde:	95 95       	asr	r25
    2be0:	87 95       	ror	r24
    2be2:	0a c0       	rjmp	.+20     	; 0x2bf8 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2be4:	88 81       	ld	r24, Y
    2be6:	80 68       	ori	r24, 0x80	; 128
    2be8:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2bea:	8b 81       	ldd	r24, Y+3	; 0x03
    2bec:	80 ff       	sbrs	r24, 0
    2bee:	fd cf       	rjmp	.-6      	; 0x2bea <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2bf0:	ce 01       	movw	r24, r28
    2bf2:	60 e0       	ldi	r22, 0x00	; 0
    2bf4:	0e 94 6d 15 	call	0x2ada	; 0x2ada <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    2bf8:	df 91       	pop	r29
    2bfa:	cf 91       	pop	r28
    2bfc:	1f 91       	pop	r17
    2bfe:	0f 91       	pop	r16
    2c00:	ff 90       	pop	r15
    2c02:	ef 90       	pop	r14
    2c04:	08 95       	ret

00002c06 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    2c06:	aa ec       	ldi	r26, 0xCA	; 202
    2c08:	b1 e0       	ldi	r27, 0x01	; 1
    2c0a:	92 e0       	ldi	r25, 0x02	; 2
    2c0c:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    2c0e:	e8 2f       	mov	r30, r24
    2c10:	f0 e0       	ldi	r31, 0x00	; 0
    2c12:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    2c14:	1c 92       	st	X, r1

	return result;
}
    2c16:	08 95       	ret

00002c18 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    2c18:	cf 93       	push	r28
    2c1a:	df 93       	push	r29
    2c1c:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    2c1e:	82 e0       	ldi	r24, 0x02	; 2
    2c20:	c0 30       	cpi	r28, 0x00	; 0
    2c22:	d8 07       	cpc	r29, r24
    2c24:	59 f4       	brne	.+22     	; 0x2c3c <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    2c26:	80 e2       	ldi	r24, 0x20	; 32
    2c28:	0e 94 03 16 	call	0x2c06	; 0x2c06 <SP_ReadCalibrationByte>
    2c2c:	c0 e0       	ldi	r28, 0x00	; 0
    2c2e:	d2 e0       	ldi	r29, 0x02	; 2
    2c30:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    2c32:	81 e2       	ldi	r24, 0x21	; 33
    2c34:	0e 94 03 16 	call	0x2c06	; 0x2c06 <SP_ReadCalibrationByte>
    2c38:	8d 87       	std	Y+13, r24	; 0x0d
    2c3a:	08 c0       	rjmp	.+16     	; 0x2c4c <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    2c3c:	84 e2       	ldi	r24, 0x24	; 36
    2c3e:	0e 94 03 16 	call	0x2c06	; 0x2c06 <SP_ReadCalibrationByte>
    2c42:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    2c44:	85 e2       	ldi	r24, 0x25	; 37
    2c46:	0e 94 03 16 	call	0x2c06	; 0x2c06 <SP_ReadCalibrationByte>
    2c4a:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	08 95       	ret

00002c52 <radio_msg_received_int_enable>:
	radio_msg_received_int_enable();
}

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    2c52:	e0 e8       	ldi	r30, 0x80	; 128
    2c54:	f6 e0       	ldi	r31, 0x06	; 6
    2c56:	84 e0       	ldi	r24, 0x04	; 4
    2c58:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    2c5a:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2c5c:	92 e0       	ldi	r25, 0x02	; 2
    2c5e:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    2c60:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    2c62:	83 e0       	ldi	r24, 0x03	; 3
    2c64:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    2c66:	e0 ea       	ldi	r30, 0xA0	; 160
    2c68:	f0 e0       	ldi	r31, 0x00	; 0
    2c6a:	82 81       	ldd	r24, Z+2	; 0x02
    2c6c:	84 60       	ori	r24, 0x04	; 4
    2c6e:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2c70:	78 94       	sei
}
    2c72:	08 95       	ret

00002c74 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    2c74:	84 e1       	ldi	r24, 0x14	; 20
    2c76:	ee e3       	ldi	r30, 0x3E	; 62
    2c78:	f1 e2       	ldi	r31, 0x21	; 33
    2c7a:	df 01       	movw	r26, r30
    2c7c:	1d 92       	st	X+, r1
    2c7e:	8a 95       	dec	r24
    2c80:	e9 f7       	brne	.-6      	; 0x2c7c <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    2c82:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <chb_get_short_addr>
    2c86:	80 93 3e 21 	sts	0x213E, r24
    2c8a:	90 93 3f 21 	sts	0x213F, r25
    chb_drvr_init();
    2c8e:	0e 94 01 1a 	call	0x3402	; 0x3402 <chb_drvr_init>
	radio_msg_received_int_enable();
    2c92:	0e 94 29 16 	call	0x2c52	; 0x2c52 <radio_msg_received_int_enable>
}
    2c96:	08 95       	ret

00002c98 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    2c98:	8e e3       	ldi	r24, 0x3E	; 62
    2c9a:	91 e2       	ldi	r25, 0x21	; 33
    2c9c:	08 95       	ret

00002c9e <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    2c9e:	2f 92       	push	r2
    2ca0:	3f 92       	push	r3
    2ca2:	4f 92       	push	r4
    2ca4:	5f 92       	push	r5
    2ca6:	6f 92       	push	r6
    2ca8:	7f 92       	push	r7
    2caa:	8f 92       	push	r8
    2cac:	9f 92       	push	r9
    2cae:	af 92       	push	r10
    2cb0:	bf 92       	push	r11
    2cb2:	cf 92       	push	r12
    2cb4:	df 92       	push	r13
    2cb6:	ef 92       	push	r14
    2cb8:	ff 92       	push	r15
    2cba:	0f 93       	push	r16
    2cbc:	1f 93       	push	r17
    2cbe:	cf 93       	push	r28
    2cc0:	df 93       	push	r29
    2cc2:	cd b7       	in	r28, 0x3d	; 61
    2cc4:	de b7       	in	r29, 0x3e	; 62
    2cc6:	2e 97       	sbiw	r28, 0x0e	; 14
    2cc8:	cd bf       	out	0x3d, r28	; 61
    2cca:	de bf       	out	0x3e, r29	; 62
    2ccc:	8b 87       	std	Y+11, r24	; 0x0b
    2cce:	9c 87       	std	Y+12, r25	; 0x0c
    2cd0:	6d 87       	std	Y+13, r22	; 0x0d
    2cd2:	7e 87       	std	Y+14, r23	; 0x0e
    2cd4:	49 01       	movw	r8, r18
    2cd6:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2cd8:	21 15       	cp	r18, r1
    2cda:	31 05       	cpc	r19, r1
    2cdc:	41 05       	cpc	r20, r1
    2cde:	51 05       	cpc	r21, r1
    2ce0:	09 f4       	brne	.+2      	; 0x2ce4 <chb_write+0x46>
    2ce2:	88 c0       	rjmp	.+272    	; 0x2df4 <chb_write+0x156>
{
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    2ce4:	ee 24       	eor	r14, r14
                 pcb.txd_noack++;
				 rtry++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2ce6:	0f 2e       	mov	r0, r31
    2ce8:	f9 e4       	ldi	r31, 0x49	; 73
    2cea:	6f 2e       	mov	r6, r31
    2cec:	f1 e2       	ldi	r31, 0x21	; 33
    2cee:	7f 2e       	mov	r7, r31
    2cf0:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2cf2:	0f 2e       	mov	r0, r31
    2cf4:	f5 e4       	ldi	r31, 0x45	; 69
    2cf6:	4f 2e       	mov	r4, r31
    2cf8:	f1 e2       	ldi	r31, 0x21	; 33
    2cfa:	5f 2e       	mov	r5, r31
    2cfc:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2cfe:	0f 2e       	mov	r0, r31
    2d00:	f7 e4       	ldi	r31, 0x47	; 71
    2d02:	2f 2e       	mov	r2, r31
    2d04:	f1 e2       	ldi	r31, 0x21	; 33
    2d06:	3f 2e       	mov	r3, r31
    2d08:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    2d0a:	f8 2c       	mov	r15, r8
    2d0c:	25 e6       	ldi	r18, 0x65	; 101
    2d0e:	82 16       	cp	r8, r18
    2d10:	91 04       	cpc	r9, r1
    2d12:	a1 04       	cpc	r10, r1
    2d14:	b1 04       	cpc	r11, r1
    2d16:	20 f0       	brcs	.+8      	; 0x2d20 <chb_write+0x82>
    2d18:	0f 2e       	mov	r0, r31
    2d1a:	f4 e6       	ldi	r31, 0x64	; 100
    2d1c:	ff 2e       	mov	r15, r31
    2d1e:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    2d20:	8f 2d       	mov	r24, r15
    2d22:	85 5f       	subi	r24, 0xF5	; 245
    2d24:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    2d26:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d28:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d2a:	ef ef       	ldi	r30, 0xFF	; 255
    2d2c:	8f 3f       	cpi	r24, 0xFF	; 255
    2d2e:	9e 07       	cpc	r25, r30
    2d30:	11 f0       	breq	.+4      	; 0x2d36 <chb_write+0x98>
    2d32:	81 e6       	ldi	r24, 0x61	; 97
    2d34:	01 c0       	rjmp	.+2      	; 0x2d38 <chb_write+0x9a>
    2d36:	81 e4       	ldi	r24, 0x41	; 65
    2d38:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    2d3a:	88 e9       	ldi	r24, 0x98	; 152
    2d3c:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
    2d3e:	e0 e4       	ldi	r30, 0x40	; 64
    2d40:	f1 e2       	ldi	r31, 0x21	; 33
    2d42:	80 81       	ld	r24, Z
    2d44:	8c 83       	std	Y+4, r24	; 0x04
    2d46:	8f 5f       	subi	r24, 0xFF	; 255
    2d48:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    2d4a:	84 e3       	ldi	r24, 0x34	; 52
    2d4c:	92 e1       	ldi	r25, 0x12	; 18
    2d4e:	8d 83       	std	Y+5, r24	; 0x05
    2d50:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    2d52:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d54:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d56:	8f 83       	std	Y+7, r24	; 0x07
    2d58:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    2d5a:	32 97       	sbiw	r30, 0x02	; 2
    2d5c:	80 81       	ld	r24, Z
    2d5e:	91 81       	ldd	r25, Z+1	; 0x01
    2d60:	89 87       	std	Y+9, r24	; 0x09
    2d62:	9a 87       	std	Y+10, r25	; 0x0a
        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
    2d64:	00 e0       	ldi	r16, 0x00	; 0
    2d66:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    2d68:	cd 84       	ldd	r12, Y+13	; 0x0d
    2d6a:	de 84       	ldd	r13, Y+14	; 0x0e
    2d6c:	ce 0c       	add	r12, r14
    2d6e:	d1 1c       	adc	r13, r1
    2d70:	ce 01       	movw	r24, r28
    2d72:	01 96       	adiw	r24, 0x01	; 1
    2d74:	b6 01       	movw	r22, r12
    2d76:	4f 2d       	mov	r20, r15
    2d78:	0e 94 3d 19 	call	0x327a	; 0x327a <chb_tx>
    2d7c:	28 2f       	mov	r18, r24

             switch (status)
    2d7e:	83 30       	cpi	r24, 0x03	; 3
    2d80:	c9 f0       	breq	.+50     	; 0x2db4 <chb_write+0x116>
    2d82:	84 30       	cpi	r24, 0x04	; 4
    2d84:	18 f4       	brcc	.+6      	; 0x2d8c <chb_write+0xee>
    2d86:	81 30       	cpi	r24, 0x01	; 1
    2d88:	e9 f4       	brne	.+58     	; 0x2dc4 <chb_write+0x126>
    2d8a:	04 c0       	rjmp	.+8      	; 0x2d94 <chb_write+0xf6>
    2d8c:	85 30       	cpi	r24, 0x05	; 5
    2d8e:	49 f0       	breq	.+18     	; 0x2da2 <chb_write+0x104>
    2d90:	80 34       	cpi	r24, 0x40	; 64
    2d92:	c1 f4       	brne	.+48     	; 0x2dc4 <chb_write+0x126>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2d94:	f2 01       	movw	r30, r4
    2d96:	80 81       	ld	r24, Z
    2d98:	91 81       	ldd	r25, Z+1	; 0x01
    2d9a:	01 96       	adiw	r24, 0x01	; 1
    2d9c:	80 83       	st	Z, r24
    2d9e:	91 83       	std	Z+1, r25	; 0x01
                 break;
    2da0:	11 c0       	rjmp	.+34     	; 0x2dc4 <chb_write+0x126>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2da2:	f1 01       	movw	r30, r2
    2da4:	80 81       	ld	r24, Z
    2da6:	91 81       	ldd	r25, Z+1	; 0x01
    2da8:	01 96       	adiw	r24, 0x01	; 1
    2daa:	80 83       	st	Z, r24
    2dac:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2dae:	0f 5f       	subi	r16, 0xFF	; 255
    2db0:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
    2db2:	08 c0       	rjmp	.+16     	; 0x2dc4 <chb_write+0x126>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2db4:	f3 01       	movw	r30, r6
    2db6:	80 81       	ld	r24, Z
    2db8:	91 81       	ldd	r25, Z+1	; 0x01
    2dba:	01 96       	adiw	r24, 0x01	; 1
    2dbc:	80 83       	st	Z, r24
    2dbe:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2dc0:	0f 5f       	subi	r16, 0xFF	; 255
    2dc2:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
 
             default:
                 break;
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    2dc4:	10 16       	cp	r1, r16
    2dc6:	11 06       	cpc	r1, r17
    2dc8:	24 f4       	brge	.+8      	; 0x2dd2 <chb_write+0x134>
    2dca:	fa e6       	ldi	r31, 0x6A	; 106
    2dcc:	fa 95       	dec	r31
    2dce:	f1 f7       	brne	.-4      	; 0x2dcc <chb_write+0x12e>
    2dd0:	00 c0       	rjmp	.+0      	; 0x2dd2 <chb_write+0x134>
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    2dd2:	04 31       	cpi	r16, 0x14	; 20
    2dd4:	11 05       	cpc	r17, r1
    2dd6:	79 f0       	breq	.+30     	; 0x2df6 <chb_write+0x158>
		} while(status != CHB_SUCCESS);			
    2dd8:	22 23       	and	r18, r18
    2dda:	51 f6       	brne	.-108    	; 0x2d70 <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
    2ddc:	ef 0c       	add	r14, r15
        len = len - frm_len;
    2dde:	8f 18       	sub	r8, r15
    2de0:	91 08       	sbc	r9, r1
    2de2:	a1 08       	sbc	r10, r1
    2de4:	b1 08       	sbc	r11, r1
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2de6:	81 14       	cp	r8, r1
    2de8:	91 04       	cpc	r9, r1
    2dea:	a1 04       	cpc	r10, r1
    2dec:	b1 04       	cpc	r11, r1
    2dee:	09 f0       	breq	.+2      	; 0x2df2 <chb_write+0x154>
    2df0:	8c cf       	rjmp	.-232    	; 0x2d0a <chb_write+0x6c>
    2df2:	01 c0       	rjmp	.+2      	; 0x2df6 <chb_write+0x158>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    2df4:	20 e0       	ldi	r18, 0x00	; 0
}
    2df6:	82 2f       	mov	r24, r18
    2df8:	2e 96       	adiw	r28, 0x0e	; 14
    2dfa:	cd bf       	out	0x3d, r28	; 61
    2dfc:	de bf       	out	0x3e, r29	; 62
    2dfe:	df 91       	pop	r29
    2e00:	cf 91       	pop	r28
    2e02:	1f 91       	pop	r17
    2e04:	0f 91       	pop	r16
    2e06:	ff 90       	pop	r15
    2e08:	ef 90       	pop	r14
    2e0a:	df 90       	pop	r13
    2e0c:	cf 90       	pop	r12
    2e0e:	bf 90       	pop	r11
    2e10:	af 90       	pop	r10
    2e12:	9f 90       	pop	r9
    2e14:	8f 90       	pop	r8
    2e16:	7f 90       	pop	r7
    2e18:	6f 90       	pop	r6
    2e1a:	5f 90       	pop	r5
    2e1c:	4f 90       	pop	r4
    2e1e:	3f 90       	pop	r3
    2e20:	2f 90       	pop	r2
    2e22:	08 95       	ret

00002e24 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    2e24:	df 92       	push	r13
    2e26:	ef 92       	push	r14
    2e28:	ff 92       	push	r15
    2e2a:	0f 93       	push	r16
    2e2c:	1f 93       	push	r17
    2e2e:	cf 93       	push	r28
    2e30:	df 93       	push	r29
    2e32:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    2e34:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <chb_buf_read>
    2e38:	d8 2e       	mov	r13, r24
    2e3a:	88 23       	and	r24, r24
    2e3c:	0c f4       	brge	.+2      	; 0x2e40 <chb_read+0x1c>
    2e3e:	46 c0       	rjmp	.+140    	; 0x2ecc <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    2e40:	f7 01       	movw	r30, r14
    2e42:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2e44:	88 23       	and	r24, r24
    2e46:	71 f0       	breq	.+28     	; 0x2e64 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    2e48:	e7 01       	movw	r28, r14
    2e4a:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    2e4c:	87 01       	movw	r16, r14
    2e4e:	09 5f       	subi	r16, 0xF9	; 249
    2e50:	1f 4f       	sbci	r17, 0xFF	; 255
    2e52:	81 50       	subi	r24, 0x01	; 1
    2e54:	08 0f       	add	r16, r24
    2e56:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    2e58:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <chb_buf_read>
    2e5c:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2e5e:	c0 17       	cp	r28, r16
    2e60:	d1 07       	cpc	r29, r17
    2e62:	d1 f7       	brne	.-12     	; 0x2e58 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    2e64:	f7 01       	movw	r30, r14
    2e66:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    2e68:	83 85       	ldd	r24, Z+11	; 0x0b
    2e6a:	94 85       	ldd	r25, Z+12	; 0x0c
    2e6c:	83 83       	std	Z+3, r24	; 0x03
    2e6e:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    2e70:	85 85       	ldd	r24, Z+13	; 0x0d
    2e72:	96 85       	ldd	r25, Z+14	; 0x0e
    2e74:	81 83       	std	Z+1, r24	; 0x01
    2e76:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    2e78:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <chb_buf_get_len>
    2e7c:	88 23       	and	r24, r24
    2e7e:	11 f4       	brne	.+4      	; 0x2e84 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    2e80:	10 92 41 21 	sts	0x2141, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    2e84:	80 91 13 20 	lds	r24, 0x2013
    2e88:	c8 17       	cp	r28, r24
    2e8a:	51 f4       	brne	.+20     	; 0x2ea0 <chb_read+0x7c>
    2e8c:	f7 01       	movw	r30, r14
    2e8e:	21 81       	ldd	r18, Z+1	; 0x01
    2e90:	32 81       	ldd	r19, Z+2	; 0x02
    2e92:	80 91 14 20 	lds	r24, 0x2014
    2e96:	90 91 15 20 	lds	r25, 0x2015
    2e9a:	28 17       	cp	r18, r24
    2e9c:	39 07       	cpc	r19, r25
    2e9e:	c1 f0       	breq	.+48     	; 0x2ed0 <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    2ea0:	c0 93 13 20 	sts	0x2013, r28
        prev_src_addr = rx->src_addr;
    2ea4:	f7 01       	movw	r30, r14
    2ea6:	81 81       	ldd	r24, Z+1	; 0x01
    2ea8:	92 81       	ldd	r25, Z+2	; 0x02
    2eaa:	80 93 14 20 	sts	0x2014, r24
    2eae:	90 93 15 20 	sts	0x2015, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    2eb2:	b7 01       	movw	r22, r14
    2eb4:	61 5f       	subi	r22, 0xF1	; 241
    2eb6:	7f 4f       	sbci	r23, 0xFF	; 255
    2eb8:	4d 2d       	mov	r20, r13
    2eba:	50 e0       	ldi	r21, 0x00	; 0
    2ebc:	49 50       	subi	r20, 0x09	; 9
    2ebe:	50 40       	sbci	r21, 0x00	; 0
    2ec0:	c7 01       	movw	r24, r14
    2ec2:	0e 94 30 3b 	call	0x7660	; 0x7660 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2ec6:	8d 2d       	mov	r24, r13
    2ec8:	8b 50       	subi	r24, 0x0B	; 11
    2eca:	03 c0       	rjmp	.+6      	; 0x2ed2 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2ecc:	80 e0       	ldi	r24, 0x00	; 0
    2ece:	01 c0       	rjmp	.+2      	; 0x2ed2 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    2ed0:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    2ed2:	df 91       	pop	r29
    2ed4:	cf 91       	pop	r28
    2ed6:	1f 91       	pop	r17
    2ed8:	0f 91       	pop	r16
    2eda:	ff 90       	pop	r15
    2edc:	ef 90       	pop	r14
    2ede:	df 90       	pop	r13
    2ee0:	08 95       	ret

00002ee2 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    2ee2:	10 92 52 21 	sts	0x2152, r1
    wr_ptr = 0;
    2ee6:	10 92 53 21 	sts	0x2153, r1
    len = 0;
    2eea:	10 92 54 21 	sts	0x2154, r1
}
    2eee:	08 95       	ret

00002ef0 <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    2ef0:	20 91 53 21 	lds	r18, 0x2153
    2ef4:	30 e0       	ldi	r19, 0x00	; 0
    2ef6:	f9 01       	movw	r30, r18
    2ef8:	eb 5a       	subi	r30, 0xAB	; 171
    2efa:	fe 4d       	sbci	r31, 0xDE	; 222
    2efc:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2efe:	c9 01       	movw	r24, r18
    2f00:	01 96       	adiw	r24, 0x01	; 1
    2f02:	60 e8       	ldi	r22, 0x80	; 128
    2f04:	70 e0       	ldi	r23, 0x00	; 0
    2f06:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    2f0a:	80 93 53 21 	sts	0x2153, r24
    len++;
    2f0e:	80 91 54 21 	lds	r24, 0x2154
    2f12:	8f 5f       	subi	r24, 0xFF	; 255
    2f14:	80 93 54 21 	sts	0x2154, r24
}
    2f18:	08 95       	ret

00002f1a <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    2f1a:	20 91 52 21 	lds	r18, 0x2152
    2f1e:	30 e0       	ldi	r19, 0x00	; 0
    2f20:	f9 01       	movw	r30, r18
    2f22:	eb 5a       	subi	r30, 0xAB	; 171
    2f24:	fe 4d       	sbci	r31, 0xDE	; 222
    2f26:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    2f28:	2f 5f       	subi	r18, 0xFF	; 255
    2f2a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f2c:	c9 01       	movw	r24, r18
    2f2e:	60 e8       	ldi	r22, 0x80	; 128
    2f30:	70 e0       	ldi	r23, 0x00	; 0
    2f32:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    2f36:	80 93 52 21 	sts	0x2152, r24
    len--;
    2f3a:	80 91 54 21 	lds	r24, 0x2154
    2f3e:	81 50       	subi	r24, 0x01	; 1
    2f40:	80 93 54 21 	sts	0x2154, r24
    return data;
}
    2f44:	84 2f       	mov	r24, r20
    2f46:	08 95       	ret

00002f48 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    2f48:	80 91 54 21 	lds	r24, 0x2154
    2f4c:	08 95       	ret

00002f4e <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    2f4e:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    2f50:	80 e0       	ldi	r24, 0x00	; 0
    2f52:	90 e0       	ldi	r25, 0x00	; 0
    2f54:	48 e0       	ldi	r20, 0x08	; 8
    2f56:	50 e0       	ldi	r21, 0x00	; 0
    2f58:	0e 94 10 1c 	call	0x3820	; 0x3820 <chb_eeprom_read>
}
    2f5c:	08 95       	ret

00002f5e <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    2f5e:	cf 93       	push	r28
    2f60:	df 93       	push	r29
    2f62:	0f 92       	push	r0
    2f64:	0f 92       	push	r0
    2f66:	cd b7       	in	r28, 0x3d	; 61
    2f68:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    2f6a:	89 e0       	ldi	r24, 0x09	; 9
    2f6c:	90 e0       	ldi	r25, 0x00	; 0
    2f6e:	be 01       	movw	r22, r28
    2f70:	6f 5f       	subi	r22, 0xFF	; 255
    2f72:	7f 4f       	sbci	r23, 0xFF	; 255
    2f74:	42 e0       	ldi	r20, 0x02	; 2
    2f76:	50 e0       	ldi	r21, 0x00	; 0
    2f78:	0e 94 10 1c 	call	0x3820	; 0x3820 <chb_eeprom_read>
    return *(U16 *)addr;
}
    2f7c:	89 81       	ldd	r24, Y+1	; 0x01
    2f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f80:	0f 90       	pop	r0
    2f82:	0f 90       	pop	r0
    2f84:	df 91       	pop	r29
    2f86:	cf 91       	pop	r28
    2f88:	08 95       	ret

00002f8a <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    2f8a:	88 23       	and	r24, r24
    2f8c:	29 f0       	breq	.+10     	; 0x2f98 <RadioCS+0xe>
    2f8e:	80 e1       	ldi	r24, 0x10	; 16
    2f90:	e0 e6       	ldi	r30, 0x60	; 96
    2f92:	f6 e0       	ldi	r31, 0x06	; 6
    2f94:	86 83       	std	Z+6, r24	; 0x06
    2f96:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    2f98:	80 e1       	ldi	r24, 0x10	; 16
    2f9a:	e0 e6       	ldi	r30, 0x60	; 96
    2f9c:	f6 e0       	ldi	r31, 0x06	; 6
    2f9e:	85 83       	std	Z+5, r24	; 0x05
    2fa0:	08 95       	ret

00002fa2 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    2fa2:	df 92       	push	r13
    2fa4:	ef 92       	push	r14
    2fa6:	ff 92       	push	r15
    2fa8:	0f 93       	push	r16
    2faa:	1f 93       	push	r17
    2fac:	cf 93       	push	r28
    2fae:	df 93       	push	r29
    2fb0:	8c 01       	movw	r16, r24
    2fb2:	c6 2f       	mov	r28, r22
    2fb4:	7a 01       	movw	r14, r20
    2fb6:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    2fb8:	82 2f       	mov	r24, r18
    2fba:	90 e0       	ldi	r25, 0x00	; 0
    2fbc:	86 0f       	add	r24, r22
    2fbe:	91 1d       	adc	r25, r1
    2fc0:	80 38       	cpi	r24, 0x80	; 128
    2fc2:	91 05       	cpc	r25, r1
    2fc4:	8c f5       	brge	.+98     	; 0x3028 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    2fc6:	8f b7       	in	r24, 0x3f	; 63
    2fc8:	80 93 56 40 	sts	0x4056, r24
    2fcc:	f8 94       	cli
    RadioCS(TRUE); 
    2fce:	81 e0       	ldi	r24, 0x01	; 1
    2fd0:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    2fd4:	80 e6       	ldi	r24, 0x60	; 96
    2fd6:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2fda:	cc 23       	and	r28, r28
    2fdc:	79 f0       	breq	.+30     	; 0x2ffc <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2fde:	c8 01       	movw	r24, r16
    2fe0:	01 96       	adiw	r24, 0x01	; 1
    2fe2:	c1 50       	subi	r28, 0x01	; 1
    2fe4:	9c 01       	movw	r18, r24
    2fe6:	2c 0f       	add	r18, r28
    2fe8:	31 1d       	adc	r19, r1
    2fea:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    2fec:	f8 01       	movw	r30, r16
    2fee:	81 91       	ld	r24, Z+
    2ff0:	8f 01       	movw	r16, r30
    2ff2:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2ff6:	0c 17       	cp	r16, r28
    2ff8:	1d 07       	cpc	r17, r29
    2ffa:	c1 f7       	brne	.-16     	; 0x2fec <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2ffc:	dd 20       	and	r13, r13
    2ffe:	69 f0       	breq	.+26     	; 0x301a <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    3000:	e7 01       	movw	r28, r14
    3002:	21 96       	adiw	r28, 0x01	; 1
    3004:	da 94       	dec	r13
    3006:	cd 0d       	add	r28, r13
    3008:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    300a:	f7 01       	movw	r30, r14
    300c:	81 91       	ld	r24, Z+
    300e:	7f 01       	movw	r14, r30
    3010:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3014:	ec 16       	cp	r14, r28
    3016:	fd 06       	cpc	r15, r29
    3018:	c1 f7       	brne	.-16     	; 0x300a <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    301a:	80 e0       	ldi	r24, 0x00	; 0
    301c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>
    CHB_LEAVE_CRIT();
    3020:	80 91 56 40 	lds	r24, 0x4056
    3024:	8f bf       	out	0x3f, r24	; 63
    3026:	78 94       	sei
}
    3028:	df 91       	pop	r29
    302a:	cf 91       	pop	r28
    302c:	1f 91       	pop	r17
    302e:	0f 91       	pop	r16
    3030:	ff 90       	pop	r15
    3032:	ef 90       	pop	r14
    3034:	df 90       	pop	r13
    3036:	08 95       	ret

00003038 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    3038:	cf 93       	push	r28
    303a:	df 93       	push	r29
    303c:	d8 2f       	mov	r29, r24
    303e:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    3040:	8f b7       	in	r24, 0x3f	; 63
    3042:	80 93 56 40 	sts	0x4056, r24
    3046:	f8 94       	cli
    RadioCS(TRUE);
    3048:	81 e0       	ldi	r24, 0x01	; 1
    304a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    304e:	8d 2f       	mov	r24, r29
    3050:	80 6c       	ori	r24, 0xC0	; 192
    3052:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    3056:	8c 2f       	mov	r24, r28
    3058:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>

    RadioCS(FALSE);
    305c:	80 e0       	ldi	r24, 0x00	; 0
    305e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>
    CHB_LEAVE_CRIT();
    3062:	80 91 56 40 	lds	r24, 0x4056
    3066:	8f bf       	out	0x3f, r24	; 63
    3068:	78 94       	sei
}
    306a:	df 91       	pop	r29
    306c:	cf 91       	pop	r28
    306e:	08 95       	ret

00003070 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    3070:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    3072:	85 e0       	ldi	r24, 0x05	; 5
    3074:	0e 94 1c 18 	call	0x3038	; 0x3038 <chb_reg_write>
}
    3078:	08 95       	ret

0000307a <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    307a:	0f 93       	push	r16
    307c:	1f 93       	push	r17
    307e:	cf 93       	push	r28
    3080:	df 93       	push	r29
    3082:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    3084:	c6 2f       	mov	r28, r22
    3086:	d7 2f       	mov	r29, r23
    3088:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    308a:	69 91       	ld	r22, Y+
    308c:	81 2f       	mov	r24, r17
    308e:	80 0f       	add	r24, r16
    3090:	0e 94 1c 18 	call	0x3038	; 0x3038 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    3094:	1f 5f       	subi	r17, 0xFF	; 255
    3096:	18 30       	cpi	r17, 0x08	; 8
    3098:	c1 f7       	brne	.-16     	; 0x308a <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    309a:	df 91       	pop	r29
    309c:	cf 91       	pop	r28
    309e:	1f 91       	pop	r17
    30a0:	0f 91       	pop	r16
    30a2:	08 95       	ret

000030a4 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    30a4:	cf 93       	push	r28
    30a6:	df 93       	push	r29
    30a8:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    30aa:	80 e0       	ldi	r24, 0x00	; 0
    30ac:	90 e0       	ldi	r25, 0x00	; 0
    30ae:	be 01       	movw	r22, r28
    30b0:	48 e0       	ldi	r20, 0x08	; 8
    30b2:	50 e0       	ldi	r21, 0x00	; 0
    30b4:	0e 94 ad 1b 	call	0x375a	; 0x375a <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    30b8:	84 e2       	ldi	r24, 0x24	; 36
    30ba:	be 01       	movw	r22, r28
    30bc:	0e 94 3d 18 	call	0x307a	; 0x307a <chb_reg_write64>
}
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	08 95       	ret

000030c6 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    30c6:	cf 93       	push	r28
    30c8:	df 93       	push	r29
    30ca:	c8 2f       	mov	r28, r24
    30cc:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    30ce:	0e 94 1c 18 	call	0x3038	; 0x3038 <chb_reg_write>
    30d2:	8c 2f       	mov	r24, r28
    30d4:	8f 5f       	subi	r24, 0xFF	; 255
    30d6:	6d 2f       	mov	r22, r29
    30d8:	0e 94 1c 18 	call	0x3038	; 0x3038 <chb_reg_write>
    }
}
    30dc:	df 91       	pop	r29
    30de:	cf 91       	pop	r28
    30e0:	08 95       	ret

000030e2 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    30e2:	0f 93       	push	r16
    30e4:	1f 93       	push	r17
    30e6:	cf 93       	push	r28
    30e8:	df 93       	push	r29
    30ea:	0f 92       	push	r0
    30ec:	0f 92       	push	r0
    30ee:	cd b7       	in	r28, 0x3d	; 61
    30f0:	de b7       	in	r29, 0x3e	; 62
    30f2:	89 83       	std	Y+1, r24	; 0x01
    30f4:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    30f6:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <chb_get_pcb>
    30fa:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    30fc:	89 e0       	ldi	r24, 0x09	; 9
    30fe:	90 e0       	ldi	r25, 0x00	; 0
    3100:	be 01       	movw	r22, r28
    3102:	6f 5f       	subi	r22, 0xFF	; 255
    3104:	7f 4f       	sbci	r23, 0xFF	; 255
    3106:	42 e0       	ldi	r20, 0x02	; 2
    3108:	50 e0       	ldi	r21, 0x00	; 0
    310a:	0e 94 ad 1b 	call	0x375a	; 0x375a <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    310e:	69 81       	ldd	r22, Y+1	; 0x01
    3110:	7a 81       	ldd	r23, Y+2	; 0x02
    3112:	80 e2       	ldi	r24, 0x20	; 32
    3114:	0e 94 63 18 	call	0x30c6	; 0x30c6 <chb_reg_write16>
    pcb->src_addr = addr;
    3118:	89 81       	ldd	r24, Y+1	; 0x01
    311a:	9a 81       	ldd	r25, Y+2	; 0x02
    311c:	f8 01       	movw	r30, r16
    311e:	80 83       	st	Z, r24
    3120:	91 83       	std	Z+1, r25	; 0x01
}
    3122:	0f 90       	pop	r0
    3124:	0f 90       	pop	r0
    3126:	df 91       	pop	r29
    3128:	cf 91       	pop	r28
    312a:	1f 91       	pop	r17
    312c:	0f 91       	pop	r16
    312e:	08 95       	ret

00003130 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    3130:	cf 93       	push	r28
    3132:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3134:	8f b7       	in	r24, 0x3f	; 63
    3136:	80 93 56 40 	sts	0x4056, r24
    313a:	f8 94       	cli
    RadioCS(TRUE);
    313c:	81 e0       	ldi	r24, 0x01	; 1
    313e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    3142:	8c 2f       	mov	r24, r28
    3144:	80 68       	ori	r24, 0x80	; 128
    3146:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    val = SPID_write(val);
    314a:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    314e:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    3150:	80 e0       	ldi	r24, 0x00	; 0
    3152:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>
    CHB_LEAVE_CRIT();
    3156:	80 91 56 40 	lds	r24, 0x4056
    315a:	8f bf       	out	0x3f, r24	; 63
    315c:	78 94       	sei

    return val;
}
    315e:	8c 2f       	mov	r24, r28
    3160:	cf 91       	pop	r28
    3162:	08 95       	ret

00003164 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    3164:	81 e0       	ldi	r24, 0x01	; 1
    3166:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
}
    316a:	8f 71       	andi	r24, 0x1F	; 31
    316c:	08 95       	ret

0000316e <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    316e:	1f 93       	push	r17
    3170:	cf 93       	push	r28
    3172:	df 93       	push	r29
    3174:	c8 2f       	mov	r28, r24
    3176:	16 2f       	mov	r17, r22
    3178:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    317a:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    317e:	6d 2f       	mov	r22, r29
    3180:	60 95       	com	r22
    3182:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    3184:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3186:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    3188:	8c 2f       	mov	r24, r28
    318a:	0e 94 1c 18 	call	0x3038	; 0x3038 <chb_reg_write>
}
    318e:	df 91       	pop	r29
    3190:	cf 91       	pop	r28
    3192:	1f 91       	pop	r17
    3194:	08 95       	ret

00003196 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3196:	cf 93       	push	r28
    3198:	df 93       	push	r29
    319a:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    319c:	80 91 64 06 	lds	r24, 0x0664
    31a0:	81 fd       	sbrc	r24, 1
    31a2:	4b c0       	rjmp	.+150    	; 0x323a <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    31a4:	0e 94 b2 18 	call	0x3164	; 0x3164 <chb_get_state>
    31a8:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    31aa:	81 51       	subi	r24, 0x11	; 17
    31ac:	82 30       	cpi	r24, 0x02	; 2
    31ae:	20 f0       	brcs	.+8      	; 0x31b8 <chb_set_state+0x22>
    31b0:	c1 30       	cpi	r28, 0x01	; 1
    31b2:	11 f0       	breq	.+4      	; 0x31b8 <chb_set_state+0x22>
    31b4:	c2 30       	cpi	r28, 0x02	; 2
    31b6:	21 f4       	brne	.+8      	; 0x31c0 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    31b8:	0e 94 b2 18 	call	0x3164	; 0x3164 <chb_get_state>
    31bc:	8c 17       	cp	r24, r28
    31be:	e1 f3       	breq	.-8      	; 0x31b8 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    31c0:	d6 31       	cpi	r29, 0x16	; 22
    31c2:	f9 f0       	breq	.+62     	; 0x3202 <chb_set_state+0x6c>
    31c4:	d9 31       	cpi	r29, 0x19	; 25
    31c6:	89 f0       	breq	.+34     	; 0x31ea <chb_set_state+0x54>
    31c8:	d8 30       	cpi	r29, 0x08	; 8
    31ca:	31 f5       	brne	.+76     	; 0x3218 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    31cc:	e4 e6       	ldi	r30, 0x64	; 100
    31ce:	f6 e0       	ldi	r31, 0x06	; 6
    31d0:	80 81       	ld	r24, Z
    31d2:	8d 7f       	andi	r24, 0xFD	; 253
    31d4:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    31d6:	82 e0       	ldi	r24, 0x02	; 2
    31d8:	63 e0       	ldi	r22, 0x03	; 3
    31da:	4f e1       	ldi	r20, 0x1F	; 31
    31dc:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
    31e0:	8a e0       	ldi	r24, 0x0A	; 10
    31e2:	8a 95       	dec	r24
    31e4:	f1 f7       	brne	.-4      	; 0x31e2 <chb_set_state+0x4c>
    31e6:	00 c0       	rjmp	.+0      	; 0x31e8 <chb_set_state+0x52>
    31e8:	17 c0       	rjmp	.+46     	; 0x3218 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    31ea:	c6 31       	cpi	r28, 0x16	; 22
    31ec:	a9 f4       	brne	.+42     	; 0x3218 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    31ee:	82 e0       	ldi	r24, 0x02	; 2
    31f0:	69 e0       	ldi	r22, 0x09	; 9
    31f2:	4f e1       	ldi	r20, 0x1F	; 31
    31f4:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
    31f8:	9a e0       	ldi	r25, 0x0A	; 10
    31fa:	9a 95       	dec	r25
    31fc:	f1 f7       	brne	.-4      	; 0x31fa <chb_set_state+0x64>
    31fe:	00 c0       	rjmp	.+0      	; 0x3200 <chb_set_state+0x6a>
    3200:	0b c0       	rjmp	.+22     	; 0x3218 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    3202:	c9 31       	cpi	r28, 0x19	; 25
    3204:	49 f4       	brne	.+18     	; 0x3218 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3206:	82 e0       	ldi	r24, 0x02	; 2
    3208:	69 e0       	ldi	r22, 0x09	; 9
    320a:	4f e1       	ldi	r20, 0x1F	; 31
    320c:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
    3210:	8a e0       	ldi	r24, 0x0A	; 10
    3212:	8a 95       	dec	r24
    3214:	f1 f7       	brne	.-4      	; 0x3212 <chb_set_state+0x7c>
    3216:	00 c0       	rjmp	.+0      	; 0x3218 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3218:	82 e0       	ldi	r24, 0x02	; 2
    321a:	6d 2f       	mov	r22, r29
    321c:	4f e1       	ldi	r20, 0x1F	; 31
    321e:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
    3222:	8f e6       	ldi	r24, 0x6F	; 111
    3224:	93 e0       	ldi	r25, 0x03	; 3
    3226:	01 97       	sbiw	r24, 0x01	; 1
    3228:	f1 f7       	brne	.-4      	; 0x3226 <chb_set_state+0x90>
    322a:	00 c0       	rjmp	.+0      	; 0x322c <chb_set_state+0x96>
    322c:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    322e:	0e 94 b2 18 	call	0x3164	; 0x3164 <chb_get_state>
    3232:	8d 17       	cp	r24, r29
    3234:	21 f4       	brne	.+8      	; 0x323e <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    3236:	80 e4       	ldi	r24, 0x40	; 64
    3238:	03 c0       	rjmp	.+6      	; 0x3240 <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    323a:	84 e4       	ldi	r24, 0x44	; 68
    323c:	01 c0       	rjmp	.+2      	; 0x3240 <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    323e:	83 e4       	ldi	r24, 0x43	; 67
}
    3240:	df 91       	pop	r29
    3242:	cf 91       	pop	r28
    3244:	08 95       	ret

00003246 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    3246:	88 23       	and	r24, r24
    3248:	49 f0       	breq	.+18     	; 0x325c <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    324a:	88 e0       	ldi	r24, 0x08	; 8
    324c:	0e 94 cb 18 	call	0x3196	; 0x3196 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    3250:	e4 e6       	ldi	r30, 0x64	; 100
    3252:	f6 e0       	ldi	r31, 0x06	; 6
    3254:	80 81       	ld	r24, Z
    3256:	82 60       	ori	r24, 0x02	; 2
    3258:	80 83       	st	Z, r24
    325a:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    325c:	e4 e6       	ldi	r30, 0x64	; 100
    325e:	f6 e0       	ldi	r31, 0x06	; 6
    3260:	80 81       	ld	r24, Z
    3262:	8d 7f       	andi	r24, 0xFD	; 253
    3264:	80 83       	st	Z, r24
    3266:	8f e7       	ldi	r24, 0x7F	; 127
    3268:	97 e0       	ldi	r25, 0x07	; 7
    326a:	01 97       	sbiw	r24, 0x01	; 1
    326c:	f1 f7       	brne	.-4      	; 0x326a <chb_sleep+0x24>
    326e:	00 c0       	rjmp	.+0      	; 0x3270 <chb_sleep+0x2a>
    3270:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    3272:	86 e1       	ldi	r24, 0x16	; 22
    3274:	0e 94 cb 18 	call	0x3196	; 0x3196 <chb_set_state>
    3278:	08 95       	ret

0000327a <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    327a:	cf 92       	push	r12
    327c:	df 92       	push	r13
    327e:	ef 92       	push	r14
    3280:	ff 92       	push	r15
    3282:	0f 93       	push	r16
    3284:	1f 93       	push	r17
    3286:	cf 93       	push	r28
    3288:	df 93       	push	r29
    328a:	7c 01       	movw	r14, r24
    328c:	6b 01       	movw	r12, r22
    328e:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    3290:	0e 94 b2 18 	call	0x3164	; 0x3164 <chb_get_state>
    3294:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3296:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <chb_get_pcb>
    329a:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    329c:	12 30       	cpi	r17, 0x02	; 2
    329e:	f1 f0       	breq	.+60     	; 0x32dc <chb_tx+0x62>
    32a0:	12 31       	cpi	r17, 0x12	; 18
    32a2:	f1 f0       	breq	.+60     	; 0x32e0 <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    32a4:	88 e0       	ldi	r24, 0x08	; 8
    32a6:	0e 94 cb 18 	call	0x3196	; 0x3196 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    32aa:	89 e1       	ldi	r24, 0x19	; 25
    32ac:	0e 94 cb 18 	call	0x3196	; 0x3196 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    32b0:	c7 01       	movw	r24, r14
    32b2:	6a e0       	ldi	r22, 0x0A	; 10
    32b4:	a6 01       	movw	r20, r12
    32b6:	20 2f       	mov	r18, r16
    32b8:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    32bc:	82 e0       	ldi	r24, 0x02	; 2
    32be:	62 e0       	ldi	r22, 0x02	; 2
    32c0:	4f e1       	ldi	r20, 0x1F	; 31
    32c2:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    32c6:	8c 81       	ldd	r24, Y+4	; 0x04
    32c8:	88 23       	and	r24, r24
    32ca:	e9 f3       	breq	.-6      	; 0x32c6 <chb_tx+0x4c>
    pcb->tx_end = false;
    32cc:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    32ce:	82 e0       	ldi	r24, 0x02	; 2
    32d0:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    32d4:	82 95       	swap	r24
    32d6:	86 95       	lsr	r24
    32d8:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    32da:	03 c0       	rjmp	.+6      	; 0x32e2 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    32dc:	84 e4       	ldi	r24, 0x44	; 68
    32de:	01 c0       	rjmp	.+2      	; 0x32e2 <chb_tx+0x68>
    32e0:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    32e2:	df 91       	pop	r29
    32e4:	cf 91       	pop	r28
    32e6:	1f 91       	pop	r17
    32e8:	0f 91       	pop	r16
    32ea:	ff 90       	pop	r15
    32ec:	ef 90       	pop	r14
    32ee:	df 90       	pop	r13
    32f0:	cf 90       	pop	r12
    32f2:	08 95       	ret

000032f4 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    32f4:	81 30       	cpi	r24, 0x01	; 1
    32f6:	91 f0       	breq	.+36     	; 0x331c <chb_set_mode+0x28>
    32f8:	81 30       	cpi	r24, 0x01	; 1
    32fa:	28 f0       	brcs	.+10     	; 0x3306 <chb_set_mode+0x12>
    32fc:	82 30       	cpi	r24, 0x02	; 2
    32fe:	c9 f0       	breq	.+50     	; 0x3332 <chb_set_mode+0x3e>
    3300:	83 30       	cpi	r24, 0x03	; 3
    3302:	61 f5       	brne	.+88     	; 0x335c <chb_set_mode+0x68>
    3304:	21 c0       	rjmp	.+66     	; 0x3348 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3306:	8c e0       	ldi	r24, 0x0C	; 12
    3308:	68 e0       	ldi	r22, 0x08	; 8
    330a:	4f e3       	ldi	r20, 0x3F	; 63
    330c:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3310:	86 e1       	ldi	r24, 0x16	; 22
    3312:	62 e0       	ldi	r22, 0x02	; 2
    3314:	43 e0       	ldi	r20, 0x03	; 3
    3316:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
        break;
    331a:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    331c:	8c e0       	ldi	r24, 0x0C	; 12
    331e:	6c e0       	ldi	r22, 0x0C	; 12
    3320:	4f e3       	ldi	r20, 0x3F	; 63
    3322:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3326:	86 e1       	ldi	r24, 0x16	; 22
    3328:	62 e0       	ldi	r22, 0x02	; 2
    332a:	43 e0       	ldi	r20, 0x03	; 3
    332c:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
        break;
    3330:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3332:	8c e0       	ldi	r24, 0x0C	; 12
    3334:	6c e1       	ldi	r22, 0x1C	; 28
    3336:	4f e3       	ldi	r20, 0x3F	; 63
    3338:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    333c:	86 e1       	ldi	r24, 0x16	; 22
    333e:	62 e0       	ldi	r22, 0x02	; 2
    3340:	43 e0       	ldi	r20, 0x03	; 3
    3342:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
        break;
    3346:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    3348:	8c e0       	ldi	r24, 0x0C	; 12
    334a:	60 e0       	ldi	r22, 0x00	; 0
    334c:	4f e3       	ldi	r20, 0x3F	; 63
    334e:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    3352:	86 e1       	ldi	r24, 0x16	; 22
    3354:	63 e0       	ldi	r22, 0x03	; 3
    3356:	43 e0       	ldi	r20, 0x03	; 3
    3358:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
    335c:	08 95       	ret

0000335e <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    335e:	cf 93       	push	r28
    3360:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    3362:	88 e0       	ldi	r24, 0x08	; 8
    3364:	6c 2f       	mov	r22, r28
    3366:	4f e1       	ldi	r20, 0x1F	; 31
    3368:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    336c:	0e 94 b2 18 	call	0x3164	; 0x3164 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    3370:	86 30       	cpi	r24, 0x06	; 6
    3372:	11 f0       	breq	.+4      	; 0x3378 <chb_set_channel+0x1a>
    3374:	89 30       	cpi	r24, 0x09	; 9
    3376:	31 f4       	brne	.+12     	; 0x3384 <chb_set_channel+0x26>
    3378:	8f e6       	ldi	r24, 0x6F	; 111
    337a:	93 e0       	ldi	r25, 0x03	; 3
    337c:	01 97       	sbiw	r24, 0x01	; 1
    337e:	f1 f7       	brne	.-4      	; 0x337c <chb_set_channel+0x1e>
    3380:	00 c0       	rjmp	.+0      	; 0x3382 <chb_set_channel+0x24>
    3382:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3384:	88 e0       	ldi	r24, 0x08	; 8
    3386:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    338a:	90 e0       	ldi	r25, 0x00	; 0
    338c:	8f 71       	andi	r24, 0x1F	; 31
    338e:	90 70       	andi	r25, 0x00	; 0
    3390:	6c 2f       	mov	r22, r28
    3392:	70 e0       	ldi	r23, 0x00	; 0
    3394:	86 17       	cp	r24, r22
    3396:	97 07       	cpc	r25, r23
    3398:	11 f4       	brne	.+4      	; 0x339e <chb_set_channel+0x40>
    339a:	80 e4       	ldi	r24, 0x40	; 64
    339c:	01 c0       	rjmp	.+2      	; 0x33a0 <chb_set_channel+0x42>
    339e:	83 e4       	ldi	r24, 0x43	; 67
}
    33a0:	cf 91       	pop	r28
    33a2:	08 95       	ret

000033a4 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    33a4:	cf 93       	push	r28
    33a6:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    33a8:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    33ac:	8c 2b       	or	r24, r28
    33ae:	8f 5f       	subi	r24, 0xFF	; 255
    33b0:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    }
    return val;
}
    33b4:	80 e0       	ldi	r24, 0x00	; 0
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	cf 91       	pop	r28
    33ba:	08 95       	ret

000033bc <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    33bc:	e4 e6       	ldi	r30, 0x64	; 100
    33be:	f6 e0       	ldi	r31, 0x06	; 6
    33c0:	80 81       	ld	r24, Z
    33c2:	81 60       	ori	r24, 0x01	; 1
    33c4:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    33c6:	80 81       	ld	r24, Z
    33c8:	8d 7f       	andi	r24, 0xFD	; 253
    33ca:	80 83       	st	Z, r24
    33cc:	8f ed       	ldi	r24, 0xDF	; 223
    33ce:	9b e0       	ldi	r25, 0x0B	; 11
    33d0:	01 97       	sbiw	r24, 0x01	; 1
    33d2:	f1 f7       	brne	.-4      	; 0x33d0 <chb_reset+0x14>
    33d4:	00 c0       	rjmp	.+0      	; 0x33d6 <chb_reset+0x1a>
    33d6:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    33d8:	80 81       	ld	r24, Z
    33da:	8e 7f       	andi	r24, 0xFE	; 254
    33dc:	80 83       	st	Z, r24
    33de:	9a e0       	ldi	r25, 0x0A	; 10
    33e0:	9a 95       	dec	r25
    33e2:	f1 f7       	brne	.-4      	; 0x33e0 <chb_reset+0x24>
    33e4:	00 c0       	rjmp	.+0      	; 0x33e6 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    33e6:	80 81       	ld	r24, Z
    33e8:	81 60       	ori	r24, 0x01	; 1
    33ea:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    33ec:	8d e1       	ldi	r24, 0x1D	; 29
    33ee:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    33f2:	81 30       	cpi	r24, 0x01	; 1
    33f4:	d9 f7       	brne	.-10     	; 0x33ec <chb_reset+0x30>
    33f6:	8c e1       	ldi	r24, 0x1C	; 28
    33f8:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    33fc:	87 30       	cpi	r24, 0x07	; 7
    33fe:	b1 f7       	brne	.-20     	; 0x33ec <chb_reset+0x30>
            break;
        }
    }
	

}
    3400:	08 95       	ret

00003402 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3402:	0f 93       	push	r16
    3404:	1f 93       	push	r17
    3406:	cf 93       	push	r28
    3408:	df 93       	push	r29
    340a:	cd b7       	in	r28, 0x3d	; 61
    340c:	de b7       	in	r29, 0x3e	; 62
    340e:	ea 97       	sbiw	r28, 0x3a	; 58
    3410:	cd bf       	out	0x3d, r28	; 61
    3412:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3414:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3418:	e0 e6       	ldi	r30, 0x60	; 96
    341a:	f6 e0       	ldi	r31, 0x06	; 6
    341c:	80 81       	ld	r24, Z
    341e:	82 60       	ori	r24, 0x02	; 2
    3420:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3422:	80 81       	ld	r24, Z
    3424:	81 60       	ori	r24, 0x01	; 1
    3426:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    3428:	0e 94 de 19 	call	0x33bc	; 0x33bc <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    342c:	8e e0       	ldi	r24, 0x0E	; 14
    342e:	60 e0       	ldi	r22, 0x00	; 0
    3430:	0e 94 1c 18 	call	0x3038	; 0x3038 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3434:	82 e0       	ldi	r24, 0x02	; 2
    3436:	63 e0       	ldi	r22, 0x03	; 3
    3438:	4f e1       	ldi	r20, 0x1F	; 31
    343a:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    343e:	81 e0       	ldi	r24, 0x01	; 1
    3440:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    3444:	8f 71       	andi	r24, 0x1F	; 31
    3446:	88 30       	cpi	r24, 0x08	; 8
    3448:	d1 f7       	brne	.-12     	; 0x343e <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    344a:	8e e2       	ldi	r24, 0x2E	; 46
    344c:	60 e4       	ldi	r22, 0x40	; 64
    344e:	40 ec       	ldi	r20, 0xC0	; 192
    3450:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3454:	8e e0       	ldi	r24, 0x0E	; 14
    3456:	6c e0       	ldi	r22, 0x0C	; 12
    3458:	0e 94 1c 18 	call	0x3038	; 0x3038 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    345c:	84 e0       	ldi	r24, 0x04	; 4
    345e:	60 e2       	ldi	r22, 0x20	; 32
    3460:	40 e2       	ldi	r20, 0x20	; 32
    3462:	0e 94 b7 18 	call	0x316e	; 0x316e <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3466:	81 e0       	ldi	r24, 0x01	; 1
    3468:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    346c:	81 e0       	ldi	r24, 0x01	; 1
    346e:	0e 94 af 19 	call	0x335e	; 0x335e <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3472:	86 e1       	ldi	r24, 0x16	; 22
    3474:	0e 94 cb 18 	call	0x3196	; 0x3196 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3478:	82 e2       	ldi	r24, 0x22	; 34
    347a:	64 e3       	ldi	r22, 0x34	; 52
    347c:	72 e1       	ldi	r23, 0x12	; 18
    347e:	0e 94 63 18 	call	0x30c6	; 0x30c6 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3482:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <chb_get_short_addr>
    3486:	bc 01       	movw	r22, r24
    3488:	80 e2       	ldi	r24, 0x20	; 32
    348a:	0e 94 63 18 	call	0x30c6	; 0x30c6 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    348e:	ce 01       	movw	r24, r28
    3490:	01 96       	adiw	r24, 0x01	; 1
    3492:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3496:	84 e2       	ldi	r24, 0x24	; 36
    3498:	be 01       	movw	r22, r28
    349a:	6f 5f       	subi	r22, 0xFF	; 255
    349c:	7f 4f       	sbci	r23, 0xFF	; 255
    349e:	0e 94 3d 18 	call	0x307a	; 0x307a <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    34a2:	e2 e7       	ldi	r30, 0x72	; 114
    34a4:	f6 e0       	ldi	r31, 0x06	; 6
    34a6:	80 81       	ld	r24, Z
    34a8:	81 60       	ori	r24, 0x01	; 1
    34aa:	80 83       	st	Z, r24
    34ac:	e9 e6       	ldi	r30, 0x69	; 105
    34ae:	f6 e0       	ldi	r31, 0x06	; 6
    34b0:	80 81       	ld	r24, Z
    34b2:	83 60       	ori	r24, 0x03	; 3
    34b4:	80 83       	st	Z, r24
    34b6:	ea e6       	ldi	r30, 0x6A	; 106
    34b8:	f6 e0       	ldi	r31, 0x06	; 6
    34ba:	80 81       	ld	r24, Z
    34bc:	84 60       	ori	r24, 0x04	; 4
    34be:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    34c0:	e0 ea       	ldi	r30, 0xA0	; 160
    34c2:	f0 e0       	ldi	r31, 0x00	; 0
    34c4:	82 81       	ldd	r24, Z+2	; 0x02
    34c6:	87 60       	ori	r24, 0x07	; 7
    34c8:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    34ca:	0e 94 b2 18 	call	0x3164	; 0x3164 <chb_get_state>
    34ce:	86 31       	cpi	r24, 0x16	; 22
    34d0:	91 f0       	breq	.+36     	; 0x34f6 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    34d2:	8e 01       	movw	r16, r28
    34d4:	07 5f       	subi	r16, 0xF7	; 247
    34d6:	1f 4f       	sbci	r17, 0xFF	; 255
    34d8:	c8 01       	movw	r24, r16
    34da:	68 ee       	ldi	r22, 0xE8	; 232
    34dc:	71 e0       	ldi	r23, 0x01	; 1
    34de:	0e 94 29 3b 	call	0x7652	; 0x7652 <strcpy_P>
        printf(buf);
    34e2:	0f 92       	push	r0
    34e4:	0f 92       	push	r0
    34e6:	ed b7       	in	r30, 0x3d	; 61
    34e8:	fe b7       	in	r31, 0x3e	; 62
    34ea:	01 83       	std	Z+1, r16	; 0x01
    34ec:	12 83       	std	Z+2, r17	; 0x02
    34ee:	0e 94 7c 3b 	call	0x76f8	; 0x76f8 <printf>
    34f2:	0f 90       	pop	r0
    34f4:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    34f6:	ea 96       	adiw	r28, 0x3a	; 58
    34f8:	cd bf       	out	0x3d, r28	; 61
    34fa:	de bf       	out	0x3e, r29	; 62
    34fc:	df 91       	pop	r29
    34fe:	cf 91       	pop	r28
    3500:	1f 91       	pop	r17
    3502:	0f 91       	pop	r16
    3504:	08 95       	ret

00003506 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3506:	1f 92       	push	r1
    3508:	0f 92       	push	r0
    350a:	0f b6       	in	r0, 0x3f	; 63
    350c:	0f 92       	push	r0
    350e:	0b b6       	in	r0, 0x3b	; 59
    3510:	0f 92       	push	r0
    3512:	11 24       	eor	r1, r1
    3514:	4f 92       	push	r4
    3516:	5f 92       	push	r5
    3518:	6f 92       	push	r6
    351a:	7f 92       	push	r7
    351c:	8f 92       	push	r8
    351e:	9f 92       	push	r9
    3520:	af 92       	push	r10
    3522:	bf 92       	push	r11
    3524:	cf 92       	push	r12
    3526:	df 92       	push	r13
    3528:	ef 92       	push	r14
    352a:	ff 92       	push	r15
    352c:	0f 93       	push	r16
    352e:	1f 93       	push	r17
    3530:	2f 93       	push	r18
    3532:	3f 93       	push	r19
    3534:	4f 93       	push	r20
    3536:	5f 93       	push	r21
    3538:	6f 93       	push	r22
    353a:	7f 93       	push	r23
    353c:	8f 93       	push	r24
    353e:	9f 93       	push	r25
    3540:	af 93       	push	r26
    3542:	bf 93       	push	r27
    3544:	ef 93       	push	r30
    3546:	ff 93       	push	r31
    3548:	cf 93       	push	r28
    354a:	df 93       	push	r29
    354c:	cd b7       	in	r28, 0x3d	; 61
    354e:	de b7       	in	r29, 0x3e	; 62
    3550:	e2 97       	sbiw	r28, 0x32	; 50
    3552:	cd bf       	out	0x3d, r28	; 61
    3554:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3556:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <chb_get_pcb>
    355a:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    355c:	8f b7       	in	r24, 0x3f	; 63
    355e:	80 93 56 40 	sts	0x4056, r24
    3562:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3564:	81 e0       	ldi	r24, 0x01	; 1
    3566:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    356a:	8f e8       	ldi	r24, 0x8F	; 143
    356c:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    intp_src = SPID_write(0);
    3570:	80 e0       	ldi	r24, 0x00	; 0
    3572:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    3576:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3578:	80 e0       	ldi	r24, 0x00	; 0
    357a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>

    while (intp_src)
    357e:	11 23       	and	r17, r17
    3580:	09 f4       	brne	.+2      	; 0x3584 <__vector_64+0x7e>
    3582:	be c0       	rjmp	.+380    	; 0x3700 <__vector_64+0x1fa>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3584:	aa 24       	eor	r10, r10
    3586:	bb 24       	eor	r11, r11
    3588:	68 94       	set
    358a:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    358c:	0f 2e       	mov	r0, r31
    358e:	f8 e0       	ldi	r31, 0x08	; 8
    3590:	6f 2e       	mov	r6, r31
    3592:	f2 e0       	ldi	r31, 0x02	; 2
    3594:	7f 2e       	mov	r7, r31
    3596:	f0 2d       	mov	r31, r0
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    3598:	0f 2e       	mov	r0, r31
    359a:	f0 e8       	ldi	r31, 0x80	; 128
    359c:	8f 2e       	mov	r8, r31
    359e:	f6 e0       	ldi	r31, 0x06	; 6
    35a0:	9f 2e       	mov	r9, r31
    35a2:	f0 2d       	mov	r31, r0
    35a4:	cc 24       	eor	r12, r12
    35a6:	68 94       	set
    35a8:	c2 f8       	bld	r12, 2
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    35aa:	12 ff       	sbrs	r17, 2
    35ac:	02 c0       	rjmp	.+4      	; 0x35b2 <__vector_64+0xac>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    35ae:	1b 7f       	andi	r17, 0xFB	; 251
    35b0:	a4 c0       	rjmp	.+328    	; 0x36fa <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    35b2:	13 ff       	sbrs	r17, 3
    35b4:	89 c0       	rjmp	.+274    	; 0x36c8 <__vector_64+0x1c2>
        {
            state = chb_get_state();
    35b6:	0e 94 b2 18 	call	0x3164	; 0x3164 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    35ba:	86 30       	cpi	r24, 0x06	; 6
    35bc:	29 f0       	breq	.+10     	; 0x35c8 <__vector_64+0xc2>
    35be:	86 31       	cpi	r24, 0x16	; 22
    35c0:	19 f0       	breq	.+6      	; 0x35c8 <__vector_64+0xc2>
    35c2:	81 31       	cpi	r24, 0x11	; 17
    35c4:	09 f0       	breq	.+2      	; 0x35c8 <__vector_64+0xc2>
    35c6:	76 c0       	rjmp	.+236    	; 0x36b4 <__vector_64+0x1ae>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    35c8:	88 e0       	ldi	r24, 0x08	; 8
    35ca:	0e 94 cb 18 	call	0x3196	; 0x3196 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    35ce:	87 e0       	ldi	r24, 0x07	; 7
    35d0:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    35d4:	f7 01       	movw	r30, r14
    35d6:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    35d8:	86 e0       	ldi	r24, 0x06	; 6
    35da:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
    35de:	88 1f       	adc	r24, r24
    35e0:	88 27       	eor	r24, r24
    35e2:	88 1f       	adc	r24, r24
    35e4:	f7 01       	movw	r30, r14
    35e6:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    35e8:	88 23       	and	r24, r24
    35ea:	09 f4       	brne	.+2      	; 0x35ee <__vector_64+0xe8>
    35ec:	66 c0       	rjmp	.+204    	; 0x36ba <__vector_64+0x1b4>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    35ee:	8f b7       	in	r24, 0x3f	; 63
    35f0:	80 93 56 40 	sts	0x4056, r24
    35f4:	f8 94       	cli
    RadioCS(TRUE);
    35f6:	81 e0       	ldi	r24, 0x01	; 1
    35f8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    35fc:	80 e2       	ldi	r24, 0x20	; 32
    35fe:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    len = SPID_write(0);
    3602:	80 e0       	ldi	r24, 0x00	; 0
    3604:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
    3608:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    360a:	83 50       	subi	r24, 0x03	; 3
    360c:	8d 37       	cpi	r24, 0x7D	; 125
    360e:	08 f0       	brcs	.+2      	; 0x3612 <__vector_64+0x10c>
    3610:	41 c0       	rjmp	.+130    	; 0x3694 <__vector_64+0x18e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3612:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <chb_buf_get_len>
    3616:	2d 2d       	mov	r18, r13
    3618:	30 e0       	ldi	r19, 0x00	; 0
    361a:	a5 01       	movw	r20, r10
    361c:	48 1b       	sub	r20, r24
    361e:	51 09       	sbc	r21, r1
    3620:	24 17       	cp	r18, r20
    3622:	35 07       	cpc	r19, r21
    3624:	94 f4       	brge	.+36     	; 0x364a <__vector_64+0x144>
        {
            chb_buf_write(len);
    3626:	8d 2d       	mov	r24, r13
    3628:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <chb_buf_write>
            
            for (i=0; i<len; i++)
    362c:	dd 20       	and	r13, r13
    362e:	49 f0       	breq	.+18     	; 0x3642 <__vector_64+0x13c>
    3630:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3632:	80 e0       	ldi	r24, 0x00	; 0
    3634:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
                chb_buf_write(data);
    3638:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    363c:	0f 5f       	subi	r16, 0xFF	; 255
    363e:	0d 15       	cp	r16, r13
    3640:	c1 f7       	brne	.-16     	; 0x3632 <__vector_64+0x12c>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    3642:	f4 01       	movw	r30, r8
    3644:	c5 82       	std	Z+5, r12	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    3646:	c6 82       	std	Z+6, r12	; 0x06
    3648:	25 c0       	rjmp	.+74     	; 0x3694 <__vector_64+0x18e>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    364a:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <chb_get_pcb>
    364e:	2c 01       	movw	r4, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3650:	dd 20       	and	r13, r13
    3652:	39 f0       	breq	.+14     	; 0x3662 <__vector_64+0x15c>
    3654:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3656:	80 e0       	ldi	r24, 0x00	; 0
    3658:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    365c:	0f 5f       	subi	r16, 0xFF	; 255
    365e:	0d 15       	cp	r16, r13
    3660:	d1 f7       	brne	.-12     	; 0x3656 <__vector_64+0x150>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3662:	f2 01       	movw	r30, r4
    3664:	85 85       	ldd	r24, Z+13	; 0x0d
    3666:	96 85       	ldd	r25, Z+14	; 0x0e
    3668:	01 96       	adiw	r24, 0x01	; 1
    366a:	85 87       	std	Z+13, r24	; 0x0d
    366c:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    366e:	ce 01       	movw	r24, r28
    3670:	01 96       	adiw	r24, 0x01	; 1
    3672:	b3 01       	movw	r22, r6
    3674:	0e 94 29 3b 	call	0x7652	; 0x7652 <strcpy_P>
            printf(buf);
    3678:	0f 92       	push	r0
    367a:	0f 92       	push	r0
    367c:	41 e0       	ldi	r20, 0x01	; 1
    367e:	50 e0       	ldi	r21, 0x00	; 0
    3680:	4c 0f       	add	r20, r28
    3682:	5d 1f       	adc	r21, r29
    3684:	ed b7       	in	r30, 0x3d	; 61
    3686:	fe b7       	in	r31, 0x3e	; 62
    3688:	41 83       	std	Z+1, r20	; 0x01
    368a:	52 83       	std	Z+2, r21	; 0x02
    368c:	0e 94 7c 3b 	call	0x76f8	; 0x76f8 <printf>
    3690:	0f 90       	pop	r0
    3692:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3694:	80 e0       	ldi	r24, 0x00	; 0
    3696:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <RadioCS>
    CHB_LEAVE_CRIT();
    369a:	80 91 56 40 	lds	r24, 0x4056
    369e:	8f bf       	out	0x3f, r24	; 63
    36a0:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    36a2:	f7 01       	movw	r30, r14
    36a4:	85 81       	ldd	r24, Z+5	; 0x05
    36a6:	96 81       	ldd	r25, Z+6	; 0x06
    36a8:	01 96       	adiw	r24, 0x01	; 1
    36aa:	85 83       	std	Z+5, r24	; 0x05
    36ac:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    36ae:	81 e0       	ldi	r24, 0x01	; 1
    36b0:	83 83       	std	Z+3, r24	; 0x03
    36b2:	03 c0       	rjmp	.+6      	; 0x36ba <__vector_64+0x1b4>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    36b4:	81 e0       	ldi	r24, 0x01	; 1
    36b6:	f7 01       	movw	r30, r14
    36b8:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    36ba:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    36bc:	86 e1       	ldi	r24, 0x16	; 22
    36be:	0e 94 cb 18 	call	0x3196	; 0x3196 <chb_set_state>
    36c2:	80 34       	cpi	r24, 0x40	; 64
    36c4:	d9 f7       	brne	.-10     	; 0x36bc <__vector_64+0x1b6>
    36c6:	19 c0       	rjmp	.+50     	; 0x36fa <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    36c8:	16 ff       	sbrs	r17, 6
    36ca:	08 c0       	rjmp	.+16     	; 0x36dc <__vector_64+0x1d6>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    36cc:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    36ce:	f7 01       	movw	r30, r14
    36d0:	87 85       	ldd	r24, Z+15	; 0x0f
    36d2:	90 89       	ldd	r25, Z+16	; 0x10
    36d4:	01 96       	adiw	r24, 0x01	; 1
    36d6:	87 87       	std	Z+15, r24	; 0x0f
    36d8:	90 8b       	std	Z+16, r25	; 0x10
    36da:	0f c0       	rjmp	.+30     	; 0x36fa <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    36dc:	11 ff       	sbrs	r17, 1
    36de:	02 c0       	rjmp	.+4      	; 0x36e4 <__vector_64+0x1de>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    36e0:	1d 7f       	andi	r17, 0xFD	; 253
    36e2:	0b c0       	rjmp	.+22     	; 0x36fa <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    36e4:	10 ff       	sbrs	r17, 0
    36e6:	02 c0       	rjmp	.+4      	; 0x36ec <__vector_64+0x1e6>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    36e8:	1e 7f       	andi	r17, 0xFE	; 254
    36ea:	07 c0       	rjmp	.+14     	; 0x36fa <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    36ec:	11 23       	and	r17, r17
    36ee:	2c f4       	brge	.+10     	; 0x36fa <__vector_64+0x1f4>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    36f0:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    36f2:	f7 01       	movw	r30, r14
    36f4:	81 89       	ldd	r24, Z+17	; 0x11
    36f6:	8f 5f       	subi	r24, 0xFF	; 255
    36f8:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    36fa:	11 23       	and	r17, r17
    36fc:	09 f0       	breq	.+2      	; 0x3700 <__vector_64+0x1fa>
    36fe:	55 cf       	rjmp	.-342    	; 0x35aa <__vector_64+0xa4>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3700:	80 91 56 40 	lds	r24, 0x4056
    3704:	8f bf       	out	0x3f, r24	; 63
    3706:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3708:	8f e0       	ldi	r24, 0x0F	; 15
    370a:	0e 94 98 18 	call	0x3130	; 0x3130 <chb_reg_read>
}
    370e:	e2 96       	adiw	r28, 0x32	; 50
    3710:	cd bf       	out	0x3d, r28	; 61
    3712:	de bf       	out	0x3e, r29	; 62
    3714:	df 91       	pop	r29
    3716:	cf 91       	pop	r28
    3718:	ff 91       	pop	r31
    371a:	ef 91       	pop	r30
    371c:	bf 91       	pop	r27
    371e:	af 91       	pop	r26
    3720:	9f 91       	pop	r25
    3722:	8f 91       	pop	r24
    3724:	7f 91       	pop	r23
    3726:	6f 91       	pop	r22
    3728:	5f 91       	pop	r21
    372a:	4f 91       	pop	r20
    372c:	3f 91       	pop	r19
    372e:	2f 91       	pop	r18
    3730:	1f 91       	pop	r17
    3732:	0f 91       	pop	r16
    3734:	ff 90       	pop	r15
    3736:	ef 90       	pop	r14
    3738:	df 90       	pop	r13
    373a:	cf 90       	pop	r12
    373c:	bf 90       	pop	r11
    373e:	af 90       	pop	r10
    3740:	9f 90       	pop	r9
    3742:	8f 90       	pop	r8
    3744:	7f 90       	pop	r7
    3746:	6f 90       	pop	r6
    3748:	5f 90       	pop	r5
    374a:	4f 90       	pop	r4
    374c:	0f 90       	pop	r0
    374e:	0b be       	out	0x3b, r0	; 59
    3750:	0f 90       	pop	r0
    3752:	0f be       	out	0x3f, r0	; 63
    3754:	0f 90       	pop	r0
    3756:	1f 90       	pop	r1
    3758:	18 95       	reti

0000375a <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    375a:	0f 93       	push	r16
    375c:	1f 93       	push	r17
    375e:	cf 93       	push	r28
    3760:	df 93       	push	r29
    3762:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3764:	e0 ec       	ldi	r30, 0xC0	; 192
    3766:	f1 e0       	ldi	r31, 0x01	; 1
    3768:	84 85       	ldd	r24, Z+12	; 0x0c
    376a:	87 7f       	andi	r24, 0xF7	; 247
    376c:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    376e:	41 15       	cp	r20, r1
    3770:	51 05       	cpc	r21, r1
    3772:	09 f4       	brne	.+2      	; 0x3776 <chb_eeprom_write+0x1c>
    3774:	50 c0       	rjmp	.+160    	; 0x3816 <chb_eeprom_write+0xbc>
    3776:	e0 e0       	ldi	r30, 0x00	; 0
    3778:	f0 e0       	ldi	r31, 0x00	; 0
    377a:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    377c:	a0 ec       	ldi	r26, 0xC0	; 192
    377e:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3780:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3782:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3784:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3786:	cf 01       	movw	r24, r30
    3788:	80 0f       	add	r24, r16
    378a:	91 1f       	adc	r25, r17
    378c:	e6 0f       	add	r30, r22
    378e:	f7 1f       	adc	r31, r23
    3790:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3792:	1f 96       	adiw	r26, 0x0f	; 15
    3794:	ec 91       	ld	r30, X
    3796:	1f 97       	sbiw	r26, 0x0f	; 15
    3798:	ee 23       	and	r30, r30
    379a:	dc f3       	brlt	.-10     	; 0x3792 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    379c:	1f 96       	adiw	r26, 0x0f	; 15
    379e:	ec 91       	ld	r30, X
    37a0:	1f 97       	sbiw	r26, 0x0f	; 15
    37a2:	e1 ff       	sbrs	r30, 1
    37a4:	11 c0       	rjmp	.+34     	; 0x37c8 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    37a6:	1a 96       	adiw	r26, 0x0a	; 10
    37a8:	dc 93       	st	X, r29
    37aa:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    37ac:	ef 93       	push	r30
    37ae:	ff 93       	push	r31
    37b0:	0f 93       	push	r16
    37b2:	2f 93       	push	r18
    37b4:	eb ec       	ldi	r30, 0xCB	; 203
    37b6:	f1 e0       	ldi	r31, 0x01	; 1
    37b8:	08 ed       	ldi	r16, 0xD8	; 216
    37ba:	21 e0       	ldi	r18, 0x01	; 1
    37bc:	04 bf       	out	0x34, r16	; 52
    37be:	20 83       	st	Z, r18
    37c0:	2f 91       	pop	r18
    37c2:	0f 91       	pop	r16
    37c4:	ff 91       	pop	r31
    37c6:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    37c8:	1a 96       	adiw	r26, 0x0a	; 10
    37ca:	cc 93       	st	X, r28
    37cc:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    37ce:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    37d0:	89 2f       	mov	r24, r25
    37d2:	8f 71       	andi	r24, 0x1F	; 31
    37d4:	11 96       	adiw	r26, 0x01	; 1
    37d6:	8c 93       	st	X, r24
    37d8:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    37da:	12 96       	adiw	r26, 0x02	; 2
    37dc:	1c 92       	st	X, r1
    37de:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    37e0:	14 96       	adiw	r26, 0x04	; 4
    37e2:	fc 93       	st	X, r31
    37e4:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    37e6:	1a 96       	adiw	r26, 0x0a	; 10
    37e8:	3c 93       	st	X, r19
    37ea:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    37ec:	ef 93       	push	r30
    37ee:	ff 93       	push	r31
    37f0:	0f 93       	push	r16
    37f2:	2f 93       	push	r18
    37f4:	eb ec       	ldi	r30, 0xCB	; 203
    37f6:	f1 e0       	ldi	r31, 0x01	; 1
    37f8:	08 ed       	ldi	r16, 0xD8	; 216
    37fa:	21 e0       	ldi	r18, 0x01	; 1
    37fc:	04 bf       	out	0x34, r16	; 52
    37fe:	20 83       	st	Z, r18
    3800:	2f 91       	pop	r18
    3802:	0f 91       	pop	r16
    3804:	ff 91       	pop	r31
    3806:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3808:	2f 5f       	subi	r18, 0xFF	; 255
    380a:	e2 2f       	mov	r30, r18
    380c:	f0 e0       	ldi	r31, 0x00	; 0
    380e:	e4 17       	cp	r30, r20
    3810:	f5 07       	cpc	r31, r21
    3812:	08 f4       	brcc	.+2      	; 0x3816 <chb_eeprom_write+0xbc>
    3814:	b8 cf       	rjmp	.-144    	; 0x3786 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3816:	df 91       	pop	r29
    3818:	cf 91       	pop	r28
    381a:	1f 91       	pop	r17
    381c:	0f 91       	pop	r16
    381e:	08 95       	ret

00003820 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3820:	1f 93       	push	r17
    3822:	cf 93       	push	r28
    3824:	df 93       	push	r29
    3826:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3828:	e0 ec       	ldi	r30, 0xC0	; 192
    382a:	f1 e0       	ldi	r31, 0x01	; 1
    382c:	84 85       	ldd	r24, Z+12	; 0x0c
    382e:	87 7f       	andi	r24, 0xF7	; 247
    3830:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3832:	41 15       	cp	r20, r1
    3834:	51 05       	cpc	r21, r1
    3836:	41 f1       	breq	.+80     	; 0x3888 <chb_eeprom_read+0x68>
    3838:	80 e0       	ldi	r24, 0x00	; 0
    383a:	90 e0       	ldi	r25, 0x00	; 0
    383c:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    383e:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3840:	db 01       	movw	r26, r22
    3842:	a8 0f       	add	r26, r24
    3844:	b9 1f       	adc	r27, r25
    3846:	82 0f       	add	r24, r18
    3848:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    384a:	17 85       	ldd	r17, Z+15	; 0x0f
    384c:	11 23       	and	r17, r17
    384e:	ec f3       	brlt	.-6      	; 0x384a <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3850:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3852:	89 2f       	mov	r24, r25
    3854:	8f 71       	andi	r24, 0x1F	; 31
    3856:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3858:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    385a:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    385c:	ef 93       	push	r30
    385e:	ff 93       	push	r31
    3860:	0f 93       	push	r16
    3862:	2f 93       	push	r18
    3864:	eb ec       	ldi	r30, 0xCB	; 203
    3866:	f1 e0       	ldi	r31, 0x01	; 1
    3868:	08 ed       	ldi	r16, 0xD8	; 216
    386a:	21 e0       	ldi	r18, 0x01	; 1
    386c:	04 bf       	out	0x34, r16	; 52
    386e:	20 83       	st	Z, r18
    3870:	2f 91       	pop	r18
    3872:	0f 91       	pop	r16
    3874:	ff 91       	pop	r31
    3876:	ef 91       	pop	r30

    return NVM.DATA0;
    3878:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    387a:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    387c:	cf 5f       	subi	r28, 0xFF	; 255
    387e:	8c 2f       	mov	r24, r28
    3880:	90 e0       	ldi	r25, 0x00	; 0
    3882:	84 17       	cp	r24, r20
    3884:	95 07       	cpc	r25, r21
    3886:	e0 f2       	brcs	.-72     	; 0x3840 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3888:	df 91       	pop	r29
    388a:	cf 91       	pop	r28
    388c:	1f 91       	pop	r17
    388e:	08 95       	ret

00003890 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3890:	e0 e6       	ldi	r30, 0x60	; 96
    3892:	f6 e0       	ldi	r31, 0x06	; 6
    3894:	80 81       	ld	r24, Z
    3896:	80 6b       	ori	r24, 0xB0	; 176
    3898:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    389a:	e4 e6       	ldi	r30, 0x64	; 100
    389c:	f6 e0       	ldi	r31, 0x06	; 6
    389e:	80 81       	ld	r24, Z
    38a0:	80 61       	ori	r24, 0x10	; 16
    38a2:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    38a4:	a0 ec       	ldi	r26, 0xC0	; 192
    38a6:	b9 e0       	ldi	r27, 0x09	; 9
    38a8:	8c 91       	ld	r24, X
    38aa:	81 65       	ori	r24, 0x51	; 81
    38ac:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    38ae:	80 81       	ld	r24, Z
    38b0:	80 61       	ori	r24, 0x10	; 16
    38b2:	80 83       	st	Z, r24
}
    38b4:	08 95       	ret

000038b6 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    38b6:	e0 ec       	ldi	r30, 0xC0	; 192
    38b8:	f9 e0       	ldi	r31, 0x09	; 9
    38ba:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    38bc:	82 81       	ldd	r24, Z+2	; 0x02
    38be:	88 23       	and	r24, r24
    38c0:	ec f7       	brge	.-6      	; 0x38bc <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    38c2:	e0 ec       	ldi	r30, 0xC0	; 192
    38c4:	f9 e0       	ldi	r31, 0x09	; 9
    38c6:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    38c8:	08 95       	ret

000038ca <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    38ca:	0f 93       	push	r16
    38cc:	cf 93       	push	r28
    38ce:	df 93       	push	r29
    38d0:	0f 92       	push	r0
    38d2:	cd b7       	in	r28, 0x3d	; 61
    38d4:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    38d6:	2f b7       	in	r18, 0x3f	; 63
    38d8:	29 83       	std	Y+1, r18	; 0x01
    38da:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    38dc:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    38de:	fc 01       	movw	r30, r24
    38e0:	08 ed       	ldi	r16, 0xD8	; 216
    38e2:	04 bf       	out	0x34, r16	; 52
    38e4:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    38e6:	89 81       	ldd	r24, Y+1	; 0x01
    38e8:	8f bf       	out	0x3f, r24	; 63
#endif
}
    38ea:	0f 90       	pop	r0
    38ec:	df 91       	pop	r29
    38ee:	cf 91       	pop	r28
    38f0:	0f 91       	pop	r16
    38f2:	08 95       	ret

000038f4 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    38f4:	66 23       	and	r22, r22
    38f6:	11 f0       	breq	.+4      	; 0x38fc <CLKSYS_XOSC_Config+0x8>
    38f8:	90 e2       	ldi	r25, 0x20	; 32
    38fa:	01 c0       	rjmp	.+2      	; 0x38fe <CLKSYS_XOSC_Config+0xa>
    38fc:	90 e0       	ldi	r25, 0x00	; 0
    38fe:	84 2b       	or	r24, r20
    3900:	89 2b       	or	r24, r25
    3902:	e0 e5       	ldi	r30, 0x50	; 80
    3904:	f0 e0       	ldi	r31, 0x00	; 0
    3906:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3908:	08 95       	ret

0000390a <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    390a:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    390c:	86 2b       	or	r24, r22
    390e:	e0 e5       	ldi	r30, 0x50	; 80
    3910:	f0 e0       	ldi	r31, 0x00	; 0
    3912:	85 83       	std	Z+5, r24	; 0x05
}
    3914:	08 95       	ret

00003916 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    3916:	e0 e5       	ldi	r30, 0x50	; 80
    3918:	f0 e0       	ldi	r31, 0x00	; 0
    391a:	90 81       	ld	r25, Z
    391c:	28 2f       	mov	r18, r24
    391e:	20 95       	com	r18
    3920:	92 23       	and	r25, r18
    3922:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    3924:	90 81       	ld	r25, Z
	return clkEnabled;
}
    3926:	89 23       	and	r24, r25
    3928:	08 95       	ret

0000392a <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    392a:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    392c:	81 e4       	ldi	r24, 0x41	; 65
    392e:	90 e0       	ldi	r25, 0x00	; 0
    3930:	0e 94 65 1c 	call	0x38ca	; 0x38ca <CCPWrite>
}
    3934:	08 95       	ret

00003936 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    3936:	1f 93       	push	r17
    3938:	cf 93       	push	r28
    393a:	df 93       	push	r29
    393c:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    393e:	c0 e4       	ldi	r28, 0x40	; 64
    3940:	d0 e0       	ldi	r29, 0x00	; 0
    3942:	68 81       	ld	r22, Y
    3944:	68 7f       	andi	r22, 0xF8	; 248
    3946:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    3948:	80 e4       	ldi	r24, 0x40	; 64
    394a:	90 e0       	ldi	r25, 0x00	; 0
    394c:	0e 94 65 1c 	call	0x38ca	; 0x38ca <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    3950:	88 81       	ld	r24, Y
	return clkCtrl;
}
    3952:	81 23       	and	r24, r17
    3954:	df 91       	pop	r29
    3956:	cf 91       	pop	r28
    3958:	1f 91       	pop	r17
    395a:	08 95       	ret

0000395c <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    395c:	e0 e4       	ldi	r30, 0x40	; 64
    395e:	f0 e0       	ldi	r31, 0x00	; 0
    3960:	93 81       	ldd	r25, Z+3	; 0x03
    3962:	91 7f       	andi	r25, 0xF1	; 241
    3964:	91 60       	ori	r25, 0x01	; 1
    3966:	89 2b       	or	r24, r25
    3968:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    396a:	08 95       	ret

0000396c <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    396c:	e0 e5       	ldi	r30, 0x50	; 80
    396e:	f0 e0       	ldi	r31, 0x00	; 0
    3970:	26 81       	ldd	r18, Z+6	; 0x06
    3972:	98 2f       	mov	r25, r24
    3974:	38 2f       	mov	r19, r24
    3976:	30 95       	com	r19
    3978:	23 23       	and	r18, r19
    397a:	66 23       	and	r22, r22
    397c:	09 f4       	brne	.+2      	; 0x3980 <CLKSYS_AutoCalibration_Enable+0x14>
    397e:	90 e0       	ldi	r25, 0x00	; 0
    3980:	92 2b       	or	r25, r18
    3982:	e0 e5       	ldi	r30, 0x50	; 80
    3984:	f0 e0       	ldi	r31, 0x00	; 0
    3986:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3988:	81 30       	cpi	r24, 0x01	; 1
    398a:	31 f4       	brne	.+12     	; 0x3998 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    398c:	e8 e6       	ldi	r30, 0x68	; 104
    398e:	f0 e0       	ldi	r31, 0x00	; 0
    3990:	80 81       	ld	r24, Z
    3992:	81 60       	ori	r24, 0x01	; 1
    3994:	80 83       	st	Z, r24
    3996:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3998:	82 30       	cpi	r24, 0x02	; 2
    399a:	29 f4       	brne	.+10     	; 0x39a6 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    399c:	e0 e6       	ldi	r30, 0x60	; 96
    399e:	f0 e0       	ldi	r31, 0x00	; 0
    39a0:	80 81       	ld	r24, Z
    39a2:	81 60       	ori	r24, 0x01	; 1
    39a4:	80 83       	st	Z, r24
    39a6:	08 95       	ret

000039a8 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    39a8:	83 e5       	ldi	r24, 0x53	; 83
    39aa:	90 e0       	ldi	r25, 0x00	; 0
    39ac:	63 e0       	ldi	r22, 0x03	; 3
    39ae:	0e 94 65 1c 	call	0x38ca	; 0x38ca <CCPWrite>
}
    39b2:	08 95       	ret

000039b4 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    39b4:	82 e4       	ldi	r24, 0x42	; 66
    39b6:	90 e0       	ldi	r25, 0x00	; 0
    39b8:	61 e0       	ldi	r22, 0x01	; 1
    39ba:	0e 94 65 1c 	call	0x38ca	; 0x38ca <CCPWrite>
}
    39be:	08 95       	ret

000039c0 <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    39c0:	80 ec       	ldi	r24, 0xC0	; 192
    39c2:	60 e0       	ldi	r22, 0x00	; 0
    39c4:	4b e0       	ldi	r20, 0x0B	; 11
    39c6:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    39ca:	e0 e5       	ldi	r30, 0x50	; 80
    39cc:	f0 e0       	ldi	r31, 0x00	; 0
    39ce:	80 81       	ld	r24, Z
    39d0:	88 60       	ori	r24, 0x08	; 8
    39d2:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    39d4:	81 81       	ldd	r24, Z+1	; 0x01
    39d6:	83 ff       	sbrs	r24, 3
    39d8:	fd cf       	rjmp	.-6      	; 0x39d4 <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    39da:	80 ec       	ldi	r24, 0xC0	; 192
    39dc:	62 e0       	ldi	r22, 0x02	; 2
    39de:	0e 94 85 1c 	call	0x390a	; 0x390a <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    39e2:	e0 e5       	ldi	r30, 0x50	; 80
    39e4:	f0 e0       	ldi	r31, 0x00	; 0
    39e6:	80 81       	ld	r24, Z
    39e8:	80 61       	ori	r24, 0x10	; 16
    39ea:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    39ec:	81 81       	ldd	r24, Z+1	; 0x01
    39ee:	84 ff       	sbrs	r24, 4
    39f0:	fd cf       	rjmp	.-6      	; 0x39ec <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    39f2:	84 e0       	ldi	r24, 0x04	; 4
    39f4:	0e 94 9b 1c 	call	0x3936	; 0x3936 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    39f8:	81 e0       	ldi	r24, 0x01	; 1
    39fa:	0e 94 8b 1c 	call	0x3916	; 0x3916 <CLKSYS_Disable>
}
    39fe:	08 95       	ret

00003a00 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3a00:	e0 e5       	ldi	r30, 0x50	; 80
    3a02:	f0 e0       	ldi	r31, 0x00	; 0
    3a04:	80 81       	ld	r24, Z
    3a06:	82 60       	ori	r24, 0x02	; 2
    3a08:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    3a0a:	80 e0       	ldi	r24, 0x00	; 0
    3a0c:	61 e0       	ldi	r22, 0x01	; 1
    3a0e:	0e 94 95 1c 	call	0x392a	; 0x392a <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3a12:	e0 e5       	ldi	r30, 0x50	; 80
    3a14:	f0 e0       	ldi	r31, 0x00	; 0
    3a16:	81 81       	ldd	r24, Z+1	; 0x01
    3a18:	81 ff       	sbrs	r24, 1
    3a1a:	fd cf       	rjmp	.-6      	; 0x3a16 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	0e 94 9b 1c 	call	0x3936	; 0x3936 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3a22:	81 e0       	ldi	r24, 0x01	; 1
    3a24:	0e 94 8b 1c 	call	0x3916	; 0x3916 <CLKSYS_Disable>
	
}
    3a28:	08 95       	ret

00003a2a <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3a2a:	e0 e5       	ldi	r30, 0x50	; 80
    3a2c:	f0 e0       	ldi	r31, 0x00	; 0
    3a2e:	80 81       	ld	r24, Z
    3a30:	82 60       	ori	r24, 0x02	; 2
    3a32:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    3a34:	80 e0       	ldi	r24, 0x00	; 0
    3a36:	60 e0       	ldi	r22, 0x00	; 0
    3a38:	0e 94 95 1c 	call	0x392a	; 0x392a <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3a3c:	e0 e5       	ldi	r30, 0x50	; 80
    3a3e:	f0 e0       	ldi	r31, 0x00	; 0
    3a40:	81 81       	ldd	r24, Z+1	; 0x01
    3a42:	81 ff       	sbrs	r24, 1
    3a44:	fd cf       	rjmp	.-6      	; 0x3a40 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3a46:	81 e0       	ldi	r24, 0x01	; 1
    3a48:	0e 94 9b 1c 	call	0x3936	; 0x3936 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3a4c:	81 e0       	ldi	r24, 0x01	; 1
    3a4e:	0e 94 8b 1c 	call	0x3916	; 0x3916 <CLKSYS_Disable>
	
}
    3a52:	08 95       	ret

00003a54 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    3a54:	88 23       	and	r24, r24
    3a56:	29 f0       	breq	.+10     	; 0x3a62 <portExCS+0xe>
    3a58:	88 e0       	ldi	r24, 0x08	; 8
    3a5a:	e0 e0       	ldi	r30, 0x00	; 0
    3a5c:	f6 e0       	ldi	r31, 0x06	; 6
    3a5e:	86 83       	std	Z+6, r24	; 0x06
    3a60:	04 c0       	rjmp	.+8      	; 0x3a6a <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    3a62:	88 e0       	ldi	r24, 0x08	; 8
    3a64:	e0 e0       	ldi	r30, 0x00	; 0
    3a66:	f6 e0       	ldi	r31, 0x06	; 6
    3a68:	85 83       	std	Z+5, r24	; 0x05
    3a6a:	8a e6       	ldi	r24, 0x6A	; 106
    3a6c:	8a 95       	dec	r24
    3a6e:	f1 f7       	brne	.-4      	; 0x3a6c <portExCS+0x18>
    3a70:	00 c0       	rjmp	.+0      	; 0x3a72 <portExCS+0x1e>
	}
	_delay_us(10);
}
    3a72:	08 95       	ret

00003a74 <Ext1Power>:
*/


void Ext1Power(uint8_t on) {
	
	if (on) {
    3a74:	88 23       	and	r24, r24
    3a76:	79 f0       	breq	.+30     	; 0x3a96 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    3a78:	e0 ea       	ldi	r30, 0xA0	; 160
    3a7a:	f6 e0       	ldi	r31, 0x06	; 6
    3a7c:	80 e2       	ldi	r24, 0x20	; 32
    3a7e:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    3a80:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3a82:	8f ef       	ldi	r24, 0xFF	; 255
    3a84:	93 ec       	ldi	r25, 0xC3	; 195
    3a86:	a9 e0       	ldi	r26, 0x09	; 9
    3a88:	81 50       	subi	r24, 0x01	; 1
    3a8a:	90 40       	sbci	r25, 0x00	; 0
    3a8c:	a0 40       	sbci	r26, 0x00	; 0
    3a8e:	e1 f7       	brne	.-8      	; 0x3a88 <Ext1Power+0x14>
    3a90:	00 c0       	rjmp	.+0      	; 0x3a92 <Ext1Power+0x1e>
    3a92:	00 00       	nop
    3a94:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    3a96:	e0 ea       	ldi	r30, 0xA0	; 160
    3a98:	f6 e0       	ldi	r31, 0x06	; 6
    3a9a:	80 e2       	ldi	r24, 0x20	; 32
    3a9c:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    3a9e:	82 83       	std	Z+2, r24	; 0x02
    3aa0:	08 95       	ret

00003aa2 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
    3aa2:	88 23       	and	r24, r24
    3aa4:	79 f0       	breq	.+30     	; 0x3ac4 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    3aa6:	e0 ea       	ldi	r30, 0xA0	; 160
    3aa8:	f6 e0       	ldi	r31, 0x06	; 6
    3aaa:	80 e4       	ldi	r24, 0x40	; 64
    3aac:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    3aae:	85 83       	std	Z+5, r24	; 0x05
    3ab0:	8f ef       	ldi	r24, 0xFF	; 255
    3ab2:	93 ec       	ldi	r25, 0xC3	; 195
    3ab4:	a9 e0       	ldi	r26, 0x09	; 9
    3ab6:	81 50       	subi	r24, 0x01	; 1
    3ab8:	90 40       	sbci	r25, 0x00	; 0
    3aba:	a0 40       	sbci	r26, 0x00	; 0
    3abc:	e1 f7       	brne	.-8      	; 0x3ab6 <Ext2Power+0x14>
    3abe:	00 c0       	rjmp	.+0      	; 0x3ac0 <Ext2Power+0x1e>
    3ac0:	00 00       	nop
    3ac2:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    3ac4:	e0 ea       	ldi	r30, 0xA0	; 160
    3ac6:	f6 e0       	ldi	r31, 0x06	; 6
    3ac8:	80 e4       	ldi	r24, 0x40	; 64
    3aca:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    3acc:	82 83       	std	Z+2, r24	; 0x02
    3ace:	08 95       	ret

00003ad0 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
    3ad0:	88 23       	and	r24, r24
    3ad2:	79 f0       	breq	.+30     	; 0x3af2 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    3ad4:	e0 ea       	ldi	r30, 0xA0	; 160
    3ad6:	f6 e0       	ldi	r31, 0x06	; 6
    3ad8:	80 e8       	ldi	r24, 0x80	; 128
    3ada:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    3adc:	85 83       	std	Z+5, r24	; 0x05
    3ade:	8f ef       	ldi	r24, 0xFF	; 255
    3ae0:	93 ec       	ldi	r25, 0xC3	; 195
    3ae2:	a9 e0       	ldi	r26, 0x09	; 9
    3ae4:	81 50       	subi	r24, 0x01	; 1
    3ae6:	90 40       	sbci	r25, 0x00	; 0
    3ae8:	a0 40       	sbci	r26, 0x00	; 0
    3aea:	e1 f7       	brne	.-8      	; 0x3ae4 <HVPower+0x14>
    3aec:	00 c0       	rjmp	.+0      	; 0x3aee <HVPower+0x1e>
    3aee:	00 00       	nop
    3af0:	05 c0       	rjmp	.+10     	; 0x3afc <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    3af2:	e0 ea       	ldi	r30, 0xA0	; 160
    3af4:	f6 e0       	ldi	r31, 0x06	; 6
    3af6:	80 e8       	ldi	r24, 0x80	; 128
    3af8:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    3afa:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3afc:	af e3       	ldi	r26, 0x3F	; 63
    3afe:	bf e1       	ldi	r27, 0x1F	; 31
    3b00:	11 97       	sbiw	r26, 0x01	; 1
    3b02:	f1 f7       	brne	.-4      	; 0x3b00 <HVPower+0x30>
    3b04:	00 c0       	rjmp	.+0      	; 0x3b06 <HVPower+0x36>
    3b06:	00 00       	nop
	}
	_delay_us(1000);
}
    3b08:	08 95       	ret

00003b0a <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    3b0a:	88 23       	and	r24, r24
    3b0c:	29 f0       	breq	.+10     	; 0x3b18 <lowerMuxCS+0xe>
    3b0e:	80 e1       	ldi	r24, 0x10	; 16
    3b10:	e0 e8       	ldi	r30, 0x80	; 128
    3b12:	f6 e0       	ldi	r31, 0x06	; 6
    3b14:	86 83       	std	Z+6, r24	; 0x06
    3b16:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    3b18:	80 e1       	ldi	r24, 0x10	; 16
    3b1a:	e0 e8       	ldi	r30, 0x80	; 128
    3b1c:	f6 e0       	ldi	r31, 0x06	; 6
    3b1e:	85 83       	std	Z+5, r24	; 0x05
    3b20:	08 95       	ret

00003b22 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    3b22:	88 23       	and	r24, r24
    3b24:	29 f0       	breq	.+10     	; 0x3b30 <upperMuxCS+0xe>
    3b26:	82 e0       	ldi	r24, 0x02	; 2
    3b28:	e0 e4       	ldi	r30, 0x40	; 64
    3b2a:	f6 e0       	ldi	r31, 0x06	; 6
    3b2c:	86 83       	std	Z+6, r24	; 0x06
    3b2e:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    3b30:	82 e0       	ldi	r24, 0x02	; 2
    3b32:	e0 e4       	ldi	r30, 0x40	; 64
    3b34:	f6 e0       	ldi	r31, 0x06	; 6
    3b36:	85 83       	std	Z+5, r24	; 0x05
    3b38:	08 95       	ret

00003b3a <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3b3a:	e0 e4       	ldi	r30, 0x40	; 64
    3b3c:	f6 e0       	ldi	r31, 0x06	; 6
    3b3e:	90 e1       	ldi	r25, 0x10	; 16
    3b40:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3b42:	28 e3       	ldi	r18, 0x38	; 56
    3b44:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3b46:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    3b48:	81 65       	ori	r24, 0x51	; 81
    3b4a:	a0 ec       	ldi	r26, 0xC0	; 192
    3b4c:	b8 e0       	ldi	r27, 0x08	; 8
    3b4e:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3b50:	11 96       	adiw	r26, 0x01	; 1
    3b52:	1c 92       	st	X, r1
    3b54:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3b56:	80 ea       	ldi	r24, 0xA0	; 160
    3b58:	81 83       	std	Z+1, r24	; 0x01

	
}
    3b5a:	08 95       	ret

00003b5c <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3b5c:	e0 e4       	ldi	r30, 0x40	; 64
    3b5e:	f6 e0       	ldi	r31, 0x06	; 6
    3b60:	90 e1       	ldi	r25, 0x10	; 16
    3b62:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3b64:	28 e3       	ldi	r18, 0x38	; 56
    3b66:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3b68:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    3b6a:	80 65       	ori	r24, 0x50	; 80
    3b6c:	68 2b       	or	r22, r24
    3b6e:	a0 ec       	ldi	r26, 0xC0	; 192
    3b70:	b8 e0       	ldi	r27, 0x08	; 8
    3b72:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3b74:	11 96       	adiw	r26, 0x01	; 1
    3b76:	1c 92       	st	X, r1
    3b78:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3b7a:	80 ea       	ldi	r24, 0xA0	; 160
    3b7c:	81 83       	std	Z+1, r24	; 0x01
}
    3b7e:	08 95       	ret

00003b80 <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    3b80:	88 23       	and	r24, r24
    3b82:	29 f0       	breq	.+10     	; 0x3b8e <SPICS+0xe>
    3b84:	80 e1       	ldi	r24, 0x10	; 16
    3b86:	e0 e4       	ldi	r30, 0x40	; 64
    3b88:	f6 e0       	ldi	r31, 0x06	; 6
    3b8a:	86 83       	std	Z+6, r24	; 0x06
    3b8c:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    3b8e:	80 e1       	ldi	r24, 0x10	; 16
    3b90:	e0 e4       	ldi	r30, 0x40	; 64
    3b92:	f6 e0       	ldi	r31, 0x06	; 6
    3b94:	85 83       	std	Z+5, r24	; 0x05
    3b96:	08 95       	ret

00003b98 <SPIDisable>:
	}	
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
    3b98:	e0 e4       	ldi	r30, 0x40	; 64
    3b9a:	f6 e0       	ldi	r31, 0x06	; 6
    3b9c:	80 e1       	ldi	r24, 0x10	; 16
    3b9e:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    3ba0:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    3ba4:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    3ba6:	80 eb       	ldi	r24, 0xB0	; 176
    3ba8:	82 83       	std	Z+2, r24	; 0x02

}
    3baa:	08 95       	ret

00003bac <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3bac:	cf 93       	push	r28
    3bae:	df 93       	push	r29
    3bb0:	c8 2f       	mov	r28, r24
    3bb2:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3bb4:	80 e0       	ldi	r24, 0x00	; 0
    3bb6:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    3bba:	81 e0       	ldi	r24, 0x01	; 1
    3bbc:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	portExCS(TRUE);
    3bc0:	81 e0       	ldi	r24, 0x01	; 1
    3bc2:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    3bc6:	dd 23       	and	r29, r29
    3bc8:	89 f0       	breq	.+34     	; 0x3bec <PortEx_OUTCLR+0x40>
    3bca:	80 91 d6 23 	lds	r24, 0x23D6
    3bce:	c0 95       	com	r28
    3bd0:	c8 23       	and	r28, r24
    3bd2:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    3bd6:	80 e4       	ldi	r24, 0x40	; 64
    3bd8:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3bdc:	84 e1       	ldi	r24, 0x14	; 20
    3bde:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3be2:	80 91 d6 23 	lds	r24, 0x23D6
    3be6:	80 93 67 50 	sts	0x5067, r24
    3bea:	10 c0       	rjmp	.+32     	; 0x3c0c <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    3bec:	80 91 82 50 	lds	r24, 0x5082
    3bf0:	c0 95       	com	r28
    3bf2:	c8 23       	and	r28, r24
    3bf4:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3bf8:	80 e4       	ldi	r24, 0x40	; 64
    3bfa:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3bfe:	85 e1       	ldi	r24, 0x15	; 21
    3c00:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3c04:	80 91 82 50 	lds	r24, 0x5082
    3c08:	80 93 67 50 	sts	0x5067, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3c0c:	80 e0       	ldi	r24, 0x00	; 0
    3c0e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3c10:	25 e6       	ldi	r18, 0x65	; 101
    3c12:	30 e5       	ldi	r19, 0x50	; 80
    3c14:	a0 ec       	ldi	r26, 0xC0	; 192
    3c16:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3c18:	c1 e7       	ldi	r28, 0x71	; 113
    3c1a:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3c1c:	f9 01       	movw	r30, r18
    3c1e:	e8 0f       	add	r30, r24
    3c20:	f9 1f       	adc	r31, r25
    3c22:	40 81       	ld	r20, Z
    3c24:	13 96       	adiw	r26, 0x03	; 3
    3c26:	4c 93       	st	X, r20
    3c28:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3c2a:	12 96       	adiw	r26, 0x02	; 2
    3c2c:	4c 91       	ld	r20, X
    3c2e:	12 97       	sbiw	r26, 0x02	; 2
    3c30:	44 23       	and	r20, r20
    3c32:	dc f7       	brge	.-10     	; 0x3c2a <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    3c34:	13 96       	adiw	r26, 0x03	; 3
    3c36:	4c 91       	ld	r20, X
    3c38:	13 97       	sbiw	r26, 0x03	; 3
    3c3a:	48 83       	st	Y, r20
    3c3c:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3c3e:	83 30       	cpi	r24, 0x03	; 3
    3c40:	91 05       	cpc	r25, r1
    3c42:	61 f7       	brne	.-40     	; 0x3c1c <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3c44:	80 e0       	ldi	r24, 0x00	; 0
    3c46:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	portExCS(FALSE);
    3c4a:	80 e0       	ldi	r24, 0x00	; 0
    3c4c:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>
	SPIDisable();
    3c50:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
}
    3c54:	df 91       	pop	r29
    3c56:	cf 91       	pop	r28
    3c58:	08 95       	ret

00003c5a <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3c5a:	cf 93       	push	r28
    3c5c:	df 93       	push	r29
    3c5e:	c8 2f       	mov	r28, r24
    3c60:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3c62:	80 e0       	ldi	r24, 0x00	; 0
    3c64:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    3c68:	81 e0       	ldi	r24, 0x01	; 1
    3c6a:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	portExCS(TRUE);
    3c6e:	81 e0       	ldi	r24, 0x01	; 1
    3c70:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    3c74:	dd 23       	and	r29, r29
    3c76:	81 f0       	breq	.+32     	; 0x3c98 <PortEx_OUTSET+0x3e>
    3c78:	80 91 d6 23 	lds	r24, 0x23D6
    3c7c:	c8 2b       	or	r28, r24
    3c7e:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    3c82:	80 e4       	ldi	r24, 0x40	; 64
    3c84:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3c88:	84 e1       	ldi	r24, 0x14	; 20
    3c8a:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3c8e:	80 91 d6 23 	lds	r24, 0x23D6
    3c92:	80 93 67 50 	sts	0x5067, r24
    3c96:	0f c0       	rjmp	.+30     	; 0x3cb6 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    3c98:	80 91 82 50 	lds	r24, 0x5082
    3c9c:	c8 2b       	or	r28, r24
    3c9e:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3ca2:	80 e4       	ldi	r24, 0x40	; 64
    3ca4:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3ca8:	85 e1       	ldi	r24, 0x15	; 21
    3caa:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3cae:	80 91 82 50 	lds	r24, 0x5082
    3cb2:	80 93 67 50 	sts	0x5067, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3cb6:	80 e0       	ldi	r24, 0x00	; 0
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3cba:	25 e6       	ldi	r18, 0x65	; 101
    3cbc:	30 e5       	ldi	r19, 0x50	; 80
    3cbe:	a0 ec       	ldi	r26, 0xC0	; 192
    3cc0:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3cc2:	c1 e7       	ldi	r28, 0x71	; 113
    3cc4:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3cc6:	f9 01       	movw	r30, r18
    3cc8:	e8 0f       	add	r30, r24
    3cca:	f9 1f       	adc	r31, r25
    3ccc:	40 81       	ld	r20, Z
    3cce:	13 96       	adiw	r26, 0x03	; 3
    3cd0:	4c 93       	st	X, r20
    3cd2:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3cd4:	12 96       	adiw	r26, 0x02	; 2
    3cd6:	4c 91       	ld	r20, X
    3cd8:	12 97       	sbiw	r26, 0x02	; 2
    3cda:	44 23       	and	r20, r20
    3cdc:	dc f7       	brge	.-10     	; 0x3cd4 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3cde:	13 96       	adiw	r26, 0x03	; 3
    3ce0:	4c 91       	ld	r20, X
    3ce2:	13 97       	sbiw	r26, 0x03	; 3
    3ce4:	48 83       	st	Y, r20
    3ce6:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3ce8:	83 30       	cpi	r24, 0x03	; 3
    3cea:	91 05       	cpc	r25, r1
    3cec:	61 f7       	brne	.-40     	; 0x3cc6 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3cee:	80 e0       	ldi	r24, 0x00	; 0
    3cf0:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	portExCS(FALSE);
    3cf4:	80 e0       	ldi	r24, 0x00	; 0
    3cf6:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>
	SPIDisable();
    3cfa:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
}
    3cfe:	df 91       	pop	r29
    3d00:	cf 91       	pop	r28
    3d02:	08 95       	ret

00003d04 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3d04:	cf 93       	push	r28
    3d06:	df 93       	push	r29
    3d08:	c8 2f       	mov	r28, r24
    3d0a:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3d0c:	80 e0       	ldi	r24, 0x00	; 0
    3d0e:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    3d12:	81 e0       	ldi	r24, 0x01	; 1
    3d14:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	portExCS(TRUE);
    3d18:	81 e0       	ldi	r24, 0x01	; 1
    3d1a:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    3d1e:	dd 23       	and	r29, r29
    3d20:	89 f0       	breq	.+34     	; 0x3d44 <PortEx_DIRCLR+0x40>
    3d22:	80 91 7a 50 	lds	r24, 0x507A
    3d26:	80 95       	com	r24
    3d28:	c8 23       	and	r28, r24
    3d2a:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3d2e:	80 e4       	ldi	r24, 0x40	; 64
    3d30:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3d34:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3d38:	80 91 7a 50 	lds	r24, 0x507A
    3d3c:	80 95       	com	r24
    3d3e:	80 93 67 50 	sts	0x5067, r24
    3d42:	11 c0       	rjmp	.+34     	; 0x3d66 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    3d44:	80 91 ce 50 	lds	r24, 0x50CE
    3d48:	80 95       	com	r24
    3d4a:	c8 23       	and	r28, r24
    3d4c:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3d50:	80 e4       	ldi	r24, 0x40	; 64
    3d52:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3d56:	81 e0       	ldi	r24, 0x01	; 1
    3d58:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3d5c:	80 91 ce 50 	lds	r24, 0x50CE
    3d60:	80 95       	com	r24
    3d62:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3d66:	80 e0       	ldi	r24, 0x00	; 0
    3d68:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3d6a:	25 e6       	ldi	r18, 0x65	; 101
    3d6c:	30 e5       	ldi	r19, 0x50	; 80
    3d6e:	a0 ec       	ldi	r26, 0xC0	; 192
    3d70:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3d72:	c1 e7       	ldi	r28, 0x71	; 113
    3d74:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3d76:	f9 01       	movw	r30, r18
    3d78:	e8 0f       	add	r30, r24
    3d7a:	f9 1f       	adc	r31, r25
    3d7c:	40 81       	ld	r20, Z
    3d7e:	13 96       	adiw	r26, 0x03	; 3
    3d80:	4c 93       	st	X, r20
    3d82:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3d84:	12 96       	adiw	r26, 0x02	; 2
    3d86:	4c 91       	ld	r20, X
    3d88:	12 97       	sbiw	r26, 0x02	; 2
    3d8a:	44 23       	and	r20, r20
    3d8c:	dc f7       	brge	.-10     	; 0x3d84 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    3d8e:	13 96       	adiw	r26, 0x03	; 3
    3d90:	4c 91       	ld	r20, X
    3d92:	13 97       	sbiw	r26, 0x03	; 3
    3d94:	48 83       	st	Y, r20
    3d96:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3d98:	83 30       	cpi	r24, 0x03	; 3
    3d9a:	91 05       	cpc	r25, r1
    3d9c:	61 f7       	brne	.-40     	; 0x3d76 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3d9e:	80 e0       	ldi	r24, 0x00	; 0
    3da0:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	portExCS(FALSE);
    3da4:	80 e0       	ldi	r24, 0x00	; 0
    3da6:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>
	SPIDisable();
    3daa:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
}
    3dae:	df 91       	pop	r29
    3db0:	cf 91       	pop	r28
    3db2:	08 95       	ret

00003db4 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3db4:	cf 93       	push	r28
    3db6:	df 93       	push	r29
    3db8:	c8 2f       	mov	r28, r24
    3dba:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3dbc:	80 e0       	ldi	r24, 0x00	; 0
    3dbe:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    3dc2:	81 e0       	ldi	r24, 0x01	; 1
    3dc4:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	portExCS(TRUE);
    3dc8:	81 e0       	ldi	r24, 0x01	; 1
    3dca:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    3dce:	dd 23       	and	r29, r29
    3dd0:	81 f0       	breq	.+32     	; 0x3df2 <PortEx_DIRSET+0x3e>
    3dd2:	80 91 7a 50 	lds	r24, 0x507A
    3dd6:	c8 2b       	or	r28, r24
    3dd8:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3ddc:	80 e4       	ldi	r24, 0x40	; 64
    3dde:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3de2:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3de6:	80 91 7a 50 	lds	r24, 0x507A
    3dea:	80 95       	com	r24
    3dec:	80 93 67 50 	sts	0x5067, r24
    3df0:	10 c0       	rjmp	.+32     	; 0x3e12 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    3df2:	80 91 ce 50 	lds	r24, 0x50CE
    3df6:	c8 2b       	or	r28, r24
    3df8:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3dfc:	80 e4       	ldi	r24, 0x40	; 64
    3dfe:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3e02:	81 e0       	ldi	r24, 0x01	; 1
    3e04:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3e08:	80 91 ce 50 	lds	r24, 0x50CE
    3e0c:	80 95       	com	r24
    3e0e:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3e12:	80 e0       	ldi	r24, 0x00	; 0
    3e14:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3e16:	25 e6       	ldi	r18, 0x65	; 101
    3e18:	30 e5       	ldi	r19, 0x50	; 80
    3e1a:	a0 ec       	ldi	r26, 0xC0	; 192
    3e1c:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3e1e:	c1 e7       	ldi	r28, 0x71	; 113
    3e20:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3e22:	f9 01       	movw	r30, r18
    3e24:	e8 0f       	add	r30, r24
    3e26:	f9 1f       	adc	r31, r25
    3e28:	40 81       	ld	r20, Z
    3e2a:	13 96       	adiw	r26, 0x03	; 3
    3e2c:	4c 93       	st	X, r20
    3e2e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    3e30:	12 96       	adiw	r26, 0x02	; 2
    3e32:	4c 91       	ld	r20, X
    3e34:	12 97       	sbiw	r26, 0x02	; 2
    3e36:	44 23       	and	r20, r20
    3e38:	dc f7       	brge	.-10     	; 0x3e30 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3e3a:	13 96       	adiw	r26, 0x03	; 3
    3e3c:	4c 91       	ld	r20, X
    3e3e:	13 97       	sbiw	r26, 0x03	; 3
    3e40:	48 83       	st	Y, r20
    3e42:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3e44:	83 30       	cpi	r24, 0x03	; 3
    3e46:	91 05       	cpc	r25, r1
    3e48:	61 f7       	brne	.-40     	; 0x3e22 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    3e4a:	80 e0       	ldi	r24, 0x00	; 0
    3e4c:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <portExCS>
	SPICS(FALSE);
    3e50:	80 e0       	ldi	r24, 0x00	; 0
    3e52:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    3e56:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>


}
    3e5a:	df 91       	pop	r29
    3e5c:	cf 91       	pop	r28
    3e5e:	08 95       	ret

00003e60 <readFRAM>:

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3e60:	0f 93       	push	r16
    3e62:	1f 93       	push	r17
    3e64:	cf 93       	push	r28
    3e66:	df 93       	push	r29
    3e68:	8c 01       	movw	r16, r24
	
	SPIInit(SPI_MODE_0_gc);
    3e6a:	80 e0       	ldi	r24, 0x00	; 0
    3e6c:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3e70:	c0 ec       	ldi	r28, 0xC0	; 192
    3e72:	d8 e0       	ldi	r29, 0x08	; 8
    3e74:	80 ed       	ldi	r24, 0xD0	; 208
    3e76:	88 83       	st	Y, r24
	SPICS(TRUE);
    3e78:	81 e0       	ldi	r24, 0x01	; 1
    3e7a:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3e7e:	88 e0       	ldi	r24, 0x08	; 8
    3e80:	e0 e2       	ldi	r30, 0x20	; 32
    3e82:	f6 e0       	ldi	r31, 0x06	; 6
    3e84:	86 83       	std	Z+6, r24	; 0x06
	nop();
    3e86:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    3e88:	83 e0       	ldi	r24, 0x03	; 3
    3e8a:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3e8c:	e0 ec       	ldi	r30, 0xC0	; 192
    3e8e:	f8 e0       	ldi	r31, 0x08	; 8
    3e90:	82 81       	ldd	r24, Z+2	; 0x02
    3e92:	88 23       	and	r24, r24
    3e94:	ec f7       	brge	.-6      	; 0x3e90 <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    3e96:	e0 ec       	ldi	r30, 0xC0	; 192
    3e98:	f8 e0       	ldi	r31, 0x08	; 8
    3e9a:	83 81       	ldd	r24, Z+3	; 0x03
    3e9c:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    3ea0:	80 91 58 40 	lds	r24, 0x4058
    3ea4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3ea6:	82 81       	ldd	r24, Z+2	; 0x02
    3ea8:	88 23       	and	r24, r24
    3eaa:	ec f7       	brge	.-6      	; 0x3ea6 <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    3eac:	e0 ec       	ldi	r30, 0xC0	; 192
    3eae:	f8 e0       	ldi	r31, 0x08	; 8
    3eb0:	83 81       	ldd	r24, Z+3	; 0x03
    3eb2:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    3eb6:	80 91 57 40 	lds	r24, 0x4057
    3eba:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3ebc:	82 81       	ldd	r24, Z+2	; 0x02
    3ebe:	88 23       	and	r24, r24
    3ec0:	ec f7       	brge	.-6      	; 0x3ebc <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3ec2:	e0 ec       	ldi	r30, 0xC0	; 192
    3ec4:	f8 e0       	ldi	r31, 0x08	; 8
    3ec6:	83 81       	ldd	r24, Z+3	; 0x03
    3ec8:	80 93 71 50 	sts	0x5071, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3ecc:	01 15       	cp	r16, r1
    3ece:	11 05       	cpc	r17, r1
    3ed0:	b1 f0       	breq	.+44     	; 0x3efe <readFRAM+0x9e>
    3ed2:	ef ed       	ldi	r30, 0xDF	; 223
    3ed4:	f3 e2       	ldi	r31, 0x23	; 35

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3ed6:	0e 0f       	add	r16, r30
    3ed8:	1f 1f       	adc	r17, r31
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    3eda:	a0 ec       	ldi	r26, 0xC0	; 192
    3edc:	b8 e0       	ldi	r27, 0x08	; 8
    3ede:	9a ea       	ldi	r25, 0xAA	; 170
    3ee0:	13 96       	adiw	r26, 0x03	; 3
    3ee2:	9c 93       	st	X, r25
    3ee4:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3ee6:	12 96       	adiw	r26, 0x02	; 2
    3ee8:	8c 91       	ld	r24, X
    3eea:	12 97       	sbiw	r26, 0x02	; 2
    3eec:	88 23       	and	r24, r24
    3eee:	dc f7       	brge	.-10     	; 0x3ee6 <readFRAM+0x86>
		FRAMReadBuffer[i] = SPIC.DATA;
    3ef0:	13 96       	adiw	r26, 0x03	; 3
    3ef2:	8c 91       	ld	r24, X
    3ef4:	13 97       	sbiw	r26, 0x03	; 3
    3ef6:	81 93       	st	Z+, r24
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3ef8:	e0 17       	cp	r30, r16
    3efa:	f1 07       	cpc	r31, r17
    3efc:	89 f7       	brne	.-30     	; 0x3ee0 <readFRAM+0x80>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    3efe:	88 e0       	ldi	r24, 0x08	; 8
    3f00:	e0 e2       	ldi	r30, 0x20	; 32
    3f02:	f6 e0       	ldi	r31, 0x06	; 6
    3f04:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    3f06:	80 e0       	ldi	r24, 0x00	; 0
    3f08:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    3f0c:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>

}
    3f10:	df 91       	pop	r29
    3f12:	cf 91       	pop	r28
    3f14:	1f 91       	pop	r17
    3f16:	0f 91       	pop	r16
    3f18:	08 95       	ret

00003f1a <FRAMTest3Channel>:
//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3f1a:	81 e0       	ldi	r24, 0x01	; 1
    3f1c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
    3f20:	8f ec       	ldi	r24, 0xCF	; 207
    3f22:	97 e0       	ldi	r25, 0x07	; 7
    3f24:	01 97       	sbiw	r24, 0x01	; 1
    3f26:	f1 f7       	brne	.-4      	; 0x3f24 <FRAMTest3Channel+0xa>
    3f28:	00 c0       	rjmp	.+0      	; 0x3f2a <FRAMTest3Channel+0x10>
    3f2a:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3f2c:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <calcChecksumFRAM>

	ADCPower(FALSE);
    3f30:	80 e0       	ldi	r24, 0x00	; 0
    3f32:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	
}
    3f36:	08 95       	ret

00003f38 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3f38:	81 e0       	ldi	r24, 0x01	; 1
    3f3a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
    3f3e:	8f ec       	ldi	r24, 0xCF	; 207
    3f40:	97 e0       	ldi	r25, 0x07	; 7
    3f42:	01 97       	sbiw	r24, 0x01	; 1
    3f44:	f1 f7       	brne	.-4      	; 0x3f42 <FRAMTest1Channel+0xa>
    3f46:	00 c0       	rjmp	.+0      	; 0x3f48 <FRAMTest1Channel+0x10>
    3f48:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3f4a:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <calcChecksumFRAM>

	ADCPower(FALSE);
    3f4e:	80 e0       	ldi	r24, 0x00	; 0
    3f50:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>

}
    3f54:	08 95       	ret

00003f56 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
	
	FRAMWriteKnowns();
    3f56:	0e 94 46 11 	call	0x228c	; 0x228c <FRAMWriteKnowns>
	ADCPower(TRUE);
    3f5a:	81 e0       	ldi	r24, 0x01	; 1
    3f5c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
    3f60:	8f ec       	ldi	r24, 0xCF	; 207
    3f62:	97 e0       	ldi	r25, 0x07	; 7
    3f64:	01 97       	sbiw	r24, 0x01	; 1
    3f66:	f1 f7       	brne	.-4      	; 0x3f64 <FRAMWriteKnownsCheck+0xe>
    3f68:	00 c0       	rjmp	.+0      	; 0x3f6a <FRAMWriteKnownsCheck+0x14>
    3f6a:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    3f6c:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <calcChecksumFRAM>

	ADCPower(FALSE);
    3f70:	80 e0       	ldi	r24, 0x00	; 0
    3f72:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>

}
    3f76:	08 95       	ret

00003f78 <checkMote>:

//random function for testing stuff	
void checkMote(){
	
	ADCPower(TRUE);
    3f78:	81 e0       	ldi	r24, 0x01	; 1
    3f7a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	Ext1Power(TRUE);
    3f7e:	81 e0       	ldi	r24, 0x01	; 1
    3f80:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3f84:	8f ef       	ldi	r24, 0xFF	; 255
    3f86:	93 ec       	ldi	r25, 0xC3	; 195
    3f88:	a9 e0       	ldi	r26, 0x09	; 9
    3f8a:	81 50       	subi	r24, 0x01	; 1
    3f8c:	90 40       	sbci	r25, 0x00	; 0
    3f8e:	a0 40       	sbci	r26, 0x00	; 0
    3f90:	e1 f7       	brne	.-8      	; 0x3f8a <checkMote+0x12>
    3f92:	00 c0       	rjmp	.+0      	; 0x3f94 <checkMote+0x1c>
    3f94:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3f96:	88 e0       	ldi	r24, 0x08	; 8
    3f98:	60 e0       	ldi	r22, 0x00	; 0
    3f9a:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3f9e:	88 e0       	ldi	r24, 0x08	; 8
    3fa0:	60 e0       	ldi	r22, 0x00	; 0
    3fa2:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
    3fa6:	8a ea       	ldi	r24, 0xAA	; 170
    3fa8:	96 ee       	ldi	r25, 0xE6	; 230
    3faa:	a6 e9       	ldi	r26, 0x96	; 150
    3fac:	b1 e0       	ldi	r27, 0x01	; 1
    3fae:	81 50       	subi	r24, 0x01	; 1
    3fb0:	90 40       	sbci	r25, 0x00	; 0
    3fb2:	a0 40       	sbci	r26, 0x00	; 0
    3fb4:	b0 40       	sbci	r27, 0x00	; 0
    3fb6:	d9 f7       	brne	.-10     	; 0x3fae <checkMote+0x36>
    3fb8:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3fba:	88 e0       	ldi	r24, 0x08	; 8
    3fbc:	60 e0       	ldi	r22, 0x00	; 0
    3fbe:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <PortEx_OUTCLR>
    3fc2:	8a ea       	ldi	r24, 0xAA	; 170
    3fc4:	96 ee       	ldi	r25, 0xE6	; 230
    3fc6:	a6 e9       	ldi	r26, 0x96	; 150
    3fc8:	b1 e0       	ldi	r27, 0x01	; 1
    3fca:	81 50       	subi	r24, 0x01	; 1
    3fcc:	90 40       	sbci	r25, 0x00	; 0
    3fce:	a0 40       	sbci	r26, 0x00	; 0
    3fd0:	b0 40       	sbci	r27, 0x00	; 0
    3fd2:	d9 f7       	brne	.-10     	; 0x3fca <checkMote+0x52>
    3fd4:	00 00       	nop
    3fd6:	e3 cf       	rjmp	.-58     	; 0x3f9e <checkMote+0x26>

00003fd8 <SD_write_and_read_knowns>:
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3fd8:	0f 93       	push	r16
    3fda:	1f 93       	push	r17
    3fdc:	cf 93       	push	r28
    3fde:	df 93       	push	r29
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3fe0:	0f ed       	ldi	r16, 0xDF	; 223
    3fe2:	13 e2       	ldi	r17, 0x23	; 35
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3fe4:	f8 01       	movw	r30, r16
    3fe6:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3fe8:	81 93       	st	Z+, r24
    3fea:	8f 5f       	subi	r24, 0xFF	; 255
    3fec:	88 31       	cpi	r24, 0x18	; 24
    3fee:	e1 f7       	brne	.-8      	; 0x3fe8 <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    3ff0:	cf ed       	ldi	r28, 0xDF	; 223
    3ff2:	d3 e2       	ldi	r29, 0x23	; 35
    3ff4:	64 e1       	ldi	r22, 0x14	; 20
    3ff6:	70 e0       	ldi	r23, 0x00	; 0
    3ff8:	80 e0       	ldi	r24, 0x00	; 0
    3ffa:	90 e0       	ldi	r25, 0x00	; 0
    3ffc:	ae 01       	movw	r20, r28
    3ffe:	28 e1       	ldi	r18, 0x18	; 24
    4000:	30 e0       	ldi	r19, 0x00	; 0
    4002:	0e 94 1a 2c 	call	0x5834	; 0x5834 <SD_write_block>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    4006:	68 96       	adiw	r28, 0x18	; 24
    4008:	f8 01       	movw	r30, r16
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    400a:	11 92       	st	Z+, r1
    400c:	ec 17       	cp	r30, r28
    400e:	fd 07       	cpc	r31, r29
    4010:	e1 f7       	brne	.-8      	; 0x400a <SD_write_and_read_knowns+0x32>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    4012:	64 e1       	ldi	r22, 0x14	; 20
    4014:	70 e0       	ldi	r23, 0x00	; 0
    4016:	80 e0       	ldi	r24, 0x00	; 0
    4018:	90 e0       	ldi	r25, 0x00	; 0
    401a:	4f ed       	ldi	r20, 0xDF	; 223
    401c:	53 e2       	ldi	r21, 0x23	; 35
    401e:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
    4022:	f8 01       	movw	r30, r16
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    4024:	20 e0       	ldi	r18, 0x00	; 0
    4026:	30 e0       	ldi	r19, 0x00	; 0
    4028:	c4 e6       	ldi	r28, 0x64	; 100
    402a:	d0 e0       	ldi	r29, 0x00	; 0
    402c:	c9 01       	movw	r24, r18
    402e:	be 01       	movw	r22, r28
    4030:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    4034:	81 93       	st	Z+, r24
    4036:	2f 5f       	subi	r18, 0xFF	; 255
    4038:	3f 4f       	sbci	r19, 0xFF	; 255
    403a:	84 e0       	ldi	r24, 0x04	; 4
    403c:	22 3e       	cpi	r18, 0xE2	; 226
    403e:	38 07       	cpc	r19, r24
    4040:	a9 f7       	brne	.-22     	; 0x402c <SD_write_and_read_knowns+0x54>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    4042:	60 e5       	ldi	r22, 0x50	; 80
    4044:	70 e0       	ldi	r23, 0x00	; 0
    4046:	80 e0       	ldi	r24, 0x00	; 0
    4048:	90 e0       	ldi	r25, 0x00	; 0
    404a:	4f ed       	ldi	r20, 0xDF	; 223
    404c:	53 e2       	ldi	r21, 0x23	; 35
    404e:	22 ee       	ldi	r18, 0xE2	; 226
    4050:	34 e0       	ldi	r19, 0x04	; 4
    4052:	0e 94 36 2d 	call	0x5a6c	; 0x5a6c <SD_write_multiple_blocks>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    4056:	81 ec       	ldi	r24, 0xC1	; 193
    4058:	98 e2       	ldi	r25, 0x28	; 40
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    405a:	f8 01       	movw	r30, r16
    405c:	11 92       	st	Z+, r1
    405e:	8f 01       	movw	r16, r30
    4060:	e8 17       	cp	r30, r24
    4062:	f9 07       	cpc	r31, r25
    4064:	d1 f7       	brne	.-12     	; 0x405a <SD_write_and_read_knowns+0x82>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    4066:	60 e5       	ldi	r22, 0x50	; 80
    4068:	70 e0       	ldi	r23, 0x00	; 0
    406a:	80 e0       	ldi	r24, 0x00	; 0
    406c:	90 e0       	ldi	r25, 0x00	; 0
    406e:	4f ed       	ldi	r20, 0xDF	; 223
    4070:	53 e2       	ldi	r21, 0x23	; 35
    4072:	23 e0       	ldi	r18, 0x03	; 3
    4074:	30 e0       	ldi	r19, 0x00	; 0
    4076:	0e 94 90 2e 	call	0x5d20	; 0x5d20 <SD_read_multiple_blocks>
}
    407a:	df 91       	pop	r29
    407c:	cf 91       	pop	r28
    407e:	1f 91       	pop	r17
    4080:	0f 91       	pop	r16
    4082:	08 95       	ret

00004084 <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    4084:	0f 93       	push	r16
    4086:	1f 93       	push	r17
    4088:	cf 93       	push	r28
    408a:	df 93       	push	r29
    408c:	0f ed       	ldi	r16, 0xDF	; 223
    408e:	13 e2       	ldi	r17, 0x23	; 35
    4090:	f8 01       	movw	r30, r16
    4092:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    4094:	81 93       	st	Z+, r24
    4096:	8f 5f       	subi	r24, 0xFF	; 255
    4098:	88 31       	cpi	r24, 0x18	; 24
    409a:	e1 f7       	brne	.-8      	; 0x4094 <SD_write_and_read_knowns_FAT+0x10>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    409c:	cf ed       	ldi	r28, 0xDF	; 223
    409e:	d3 e2       	ldi	r29, 0x23	; 35
    40a0:	86 e1       	ldi	r24, 0x16	; 22
    40a2:	90 e2       	ldi	r25, 0x20	; 32
    40a4:	be 01       	movw	r22, r28
    40a6:	20 e0       	ldi	r18, 0x00	; 0
    40a8:	32 e0       	ldi	r19, 0x02	; 2
    40aa:	40 e0       	ldi	r20, 0x00	; 0
    40ac:	50 e0       	ldi	r21, 0x00	; 0
    40ae:	0e 94 07 28 	call	0x500e	; 0x500e <writeFile>
    40b2:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
}

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    40b6:	68 96       	adiw	r28, 0x18	; 24
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    40b8:	f8 01       	movw	r30, r16
    40ba:	11 92       	st	Z+, r1
    40bc:	8f 01       	movw	r16, r30
    40be:	ec 17       	cp	r30, r28
    40c0:	fd 07       	cpc	r31, r29
    40c2:	d1 f7       	brne	.-12     	; 0x40b8 <SD_write_and_read_knowns_FAT+0x34>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    40c4:	80 e0       	ldi	r24, 0x00	; 0
    40c6:	66 e1       	ldi	r22, 0x16	; 22
    40c8:	70 e2       	ldi	r23, 0x20	; 32
    40ca:	0e 94 8b 27 	call	0x4f16	; 0x4f16 <readFile>
    40ce:	80 93 a3 50 	sts	0x50A3, r24
}
    40d2:	df 91       	pop	r29
    40d4:	cf 91       	pop	r28
    40d6:	1f 91       	pop	r17
    40d8:	0f 91       	pop	r16
    40da:	08 95       	ret

000040dc <chibi_test_radio>:


//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    40dc:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <chb_init>
	chb_set_short_addr(0x0002);
    40e0:	82 e0       	ldi	r24, 0x02	; 2
    40e2:	90 e0       	ldi	r25, 0x00	; 0
    40e4:	0e 94 71 18 	call	0x30e2	; 0x30e2 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    40e8:	00 00       	nop
    40ea:	fe cf       	rjmp	.-4      	; 0x40e8 <chibi_test_radio+0xc>

000040ec <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    40ec:	cf 93       	push	r28
    40ee:	df 93       	push	r29
	
	SD_init();
    40f0:	0e 94 40 2b 	call	0x5680	; 0x5680 <SD_init>
	getBootSectorData();
    40f4:	0e 94 20 23 	call	0x4640	; 0x4640 <getBootSectorData>
    40f8:	ef ed       	ldi	r30, 0xDF	; 223
    40fa:	f3 e2       	ldi	r31, 0x23	; 35
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    40fc:	20 e0       	ldi	r18, 0x00	; 0
    40fe:	30 e0       	ldi	r19, 0x00	; 0
    4100:	c9 e7       	ldi	r28, 0x79	; 121
    4102:	d0 e0       	ldi	r29, 0x00	; 0
    4104:	c9 01       	movw	r24, r18
    4106:	be 01       	movw	r22, r28
    4108:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    410c:	81 93       	st	Z+, r24
    410e:	2f 5f       	subi	r18, 0xFF	; 255
    4110:	3f 4f       	sbci	r19, 0xFF	; 255
    4112:	82 e0       	ldi	r24, 0x02	; 2
    4114:	20 30       	cpi	r18, 0x00	; 0
    4116:	38 07       	cpc	r19, r24
    4118:	a9 f7       	brne	.-22     	; 0x4104 <TestCard+0x18>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    411a:	86 e1       	ldi	r24, 0x16	; 22
    411c:	90 e2       	ldi	r25, 0x20	; 32
    411e:	6f ed       	ldi	r22, 0xDF	; 223
    4120:	73 e2       	ldi	r23, 0x23	; 35
    4122:	20 e0       	ldi	r18, 0x00	; 0
    4124:	32 e0       	ldi	r19, 0x02	; 2
    4126:	40 e0       	ldi	r20, 0x00	; 0
    4128:	50 e0       	ldi	r21, 0x00	; 0
    412a:	0e 94 07 28 	call	0x500e	; 0x500e <writeFile>
	nop();
    412e:	00 00       	nop
}
    4130:	df 91       	pop	r29
    4132:	cf 91       	pop	r28
    4134:	08 95       	ret

00004136 <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    4136:	1f 92       	push	r1
    4138:	0f 92       	push	r0
    413a:	0f b6       	in	r0, 0x3f	; 63
    413c:	0f 92       	push	r0
    413e:	0b b6       	in	r0, 0x3b	; 59
    4140:	0f 92       	push	r0
    4142:	11 24       	eor	r1, r1
    4144:	2f 93       	push	r18
    4146:	3f 93       	push	r19
    4148:	4f 93       	push	r20
    414a:	5f 93       	push	r21
    414c:	6f 93       	push	r22
    414e:	7f 93       	push	r23
    4150:	8f 93       	push	r24
    4152:	9f 93       	push	r25
    4154:	af 93       	push	r26
    4156:	bf 93       	push	r27
    4158:	ef 93       	push	r30
    415a:	ff 93       	push	r31
	
	chb_rx_data_t* msg = NULL;
	switch (RadioMonitorMode) {
    415c:	80 91 5e 40 	lds	r24, 0x405E
    4160:	81 30       	cpi	r24, 0x01	; 1
    4162:	21 f0       	breq	.+8      	; 0x416c <__vector_43+0x36>
    4164:	82 30       	cpi	r24, 0x02	; 2
    4166:	09 f0       	breq	.+2      	; 0x416a <__vector_43+0x34>
    4168:	72 c0       	rjmp	.+228    	; 0x424e <__vector_43+0x118>
    416a:	55 c0       	rjmp	.+170    	; 0x4216 <__vector_43+0xe0>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    416c:	80 e0       	ldi	r24, 0x00	; 0
    416e:	90 e0       	ldi	r25, 0x00	; 0
    4170:	0e 94 12 17 	call	0x2e24	; 0x2e24 <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    4174:	85 e0       	ldi	r24, 0x05	; 5
    4176:	90 e0       	ldi	r25, 0x00	; 0
    4178:	6e e1       	ldi	r22, 0x1E	; 30
    417a:	70 e2       	ldi	r23, 0x20	; 32
    417c:	45 e0       	ldi	r20, 0x05	; 5
    417e:	50 e0       	ldi	r21, 0x00	; 0
    4180:	0e 94 4d 3b 	call	0x769a	; 0x769a <strncmp>
    4184:	28 2f       	mov	r18, r24
    4186:	39 2f       	mov	r19, r25
    4188:	21 15       	cp	r18, r1
    418a:	31 05       	cpc	r19, r1
    418c:	51 f4       	brne	.+20     	; 0x41a2 <__vector_43+0x6c>
				MotesReadyToSynch++;
    418e:	80 91 78 50 	lds	r24, 0x5078
    4192:	90 91 79 50 	lds	r25, 0x5079
    4196:	01 96       	adiw	r24, 0x01	; 1
    4198:	80 93 78 50 	sts	0x5078, r24
    419c:	90 93 79 50 	sts	0x5079, r25
    41a0:	56 c0       	rjmp	.+172    	; 0x424e <__vector_43+0x118>
    41a2:	e5 e0       	ldi	r30, 0x05	; 5
    41a4:	f0 e0       	ldi	r31, 0x00	; 0
    41a6:	af ed       	ldi	r26, 0xDF	; 223
    41a8:	b3 e2       	ldi	r27, 0x23	; 35
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    41aa:	81 91       	ld	r24, Z+
    41ac:	8d 93       	st	X+, r24
    41ae:	e5 38       	cpi	r30, 0x85	; 133
    41b0:	f1 05       	cpc	r31, r1
    41b2:	d9 f7       	brne	.-10     	; 0x41aa <__vector_43+0x74>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    41b4:	80 91 c2 50 	lds	r24, 0x50C2
    41b8:	90 91 c3 50 	lds	r25, 0x50C3
    41bc:	a0 91 c4 50 	lds	r26, 0x50C4
    41c0:	b0 91 c5 50 	lds	r27, 0x50C5
    41c4:	80 58       	subi	r24, 0x80	; 128
    41c6:	9f 4f       	sbci	r25, 0xFF	; 255
    41c8:	af 4f       	sbci	r26, 0xFF	; 255
    41ca:	bf 4f       	sbci	r27, 0xFF	; 255
    41cc:	80 93 c2 50 	sts	0x50C2, r24
    41d0:	90 93 c3 50 	sts	0x50C3, r25
    41d4:	a0 93 c4 50 	sts	0x50C4, r26
    41d8:	b0 93 c5 50 	sts	0x50C5, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    41dc:	80 91 c2 50 	lds	r24, 0x50C2
    41e0:	90 91 c3 50 	lds	r25, 0x50C3
    41e4:	a0 91 c4 50 	lds	r26, 0x50C4
    41e8:	b0 91 c5 50 	lds	r27, 0x50C5
    41ec:	80 58       	subi	r24, 0x80	; 128
    41ee:	9f 4f       	sbci	r25, 0xFF	; 255
    41f0:	af 4f       	sbci	r26, 0xFF	; 255
    41f2:	bf 4f       	sbci	r27, 0xFF	; 255
    41f4:	81 37       	cpi	r24, 0x71	; 113
    41f6:	2c e1       	ldi	r18, 0x1C	; 28
    41f8:	92 07       	cpc	r25, r18
    41fa:	20 e0       	ldi	r18, 0x00	; 0
    41fc:	a2 07       	cpc	r26, r18
    41fe:	20 e0       	ldi	r18, 0x00	; 0
    4200:	b2 07       	cpc	r27, r18
    4202:	28 f1       	brcs	.+74     	; 0x424e <__vector_43+0x118>
    4204:	10 92 c2 50 	sts	0x50C2, r1
    4208:	10 92 c3 50 	sts	0x50C3, r1
    420c:	10 92 c4 50 	sts	0x50C4, r1
    4210:	10 92 c5 50 	sts	0x50C5, r1
    4214:	1c c0       	rjmp	.+56     	; 0x424e <__vector_43+0x118>
			}			
			break;
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    4216:	80 e0       	ldi	r24, 0x00	; 0
    4218:	90 e0       	ldi	r25, 0x00	; 0
    421a:	0e 94 12 17 	call	0x2e24	; 0x2e24 <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    421e:	85 e0       	ldi	r24, 0x05	; 5
    4220:	90 e0       	ldi	r25, 0x00	; 0
    4222:	64 e2       	ldi	r22, 0x24	; 36
    4224:	70 e2       	ldi	r23, 0x20	; 32
    4226:	4e e0       	ldi	r20, 0x0E	; 14
    4228:	50 e0       	ldi	r21, 0x00	; 0
    422a:	0e 94 4d 3b 	call	0x769a	; 0x769a <strncmp>
    422e:	28 2f       	mov	r18, r24
    4230:	39 2f       	mov	r19, r25
    4232:	21 15       	cp	r18, r1
    4234:	31 05       	cpc	r19, r1
    4236:	59 f4       	brne	.+22     	; 0x424e <__vector_43+0x118>
				RadioMonitorMode = SYNCHED;
    4238:	83 e0       	ldi	r24, 0x03	; 3
    423a:	80 93 5e 40 	sts	0x405E, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    423e:	89 e0       	ldi	r24, 0x09	; 9
    4240:	80 93 40 09 	sts	0x0940, r24
				TCC1.CTRLA = 0x01;  
    4244:	81 e0       	ldi	r24, 0x01	; 1
    4246:	80 93 40 08 	sts	0x0840, r24
				ADC_Resume_Sampling();	//resume sampling with the adc
    424a:	0e 94 c5 07 	call	0xf8a	; 0xf8a <ADC_Resume_Sampling>
			}
			break;
		default:
			break;
	}
}
    424e:	ff 91       	pop	r31
    4250:	ef 91       	pop	r30
    4252:	bf 91       	pop	r27
    4254:	af 91       	pop	r26
    4256:	9f 91       	pop	r25
    4258:	8f 91       	pop	r24
    425a:	7f 91       	pop	r23
    425c:	6f 91       	pop	r22
    425e:	5f 91       	pop	r21
    4260:	4f 91       	pop	r20
    4262:	3f 91       	pop	r19
    4264:	2f 91       	pop	r18
    4266:	0f 90       	pop	r0
    4268:	0b be       	out	0x3b, r0	; 59
    426a:	0f 90       	pop	r0
    426c:	0f be       	out	0x3f, r0	; 63
    426e:	0f 90       	pop	r0
    4270:	1f 90       	pop	r1
    4272:	18 95       	reti

00004274 <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    4274:	2f 92       	push	r2
    4276:	3f 92       	push	r3
    4278:	4f 92       	push	r4
    427a:	5f 92       	push	r5
    427c:	6f 92       	push	r6
    427e:	7f 92       	push	r7
    4280:	8f 92       	push	r8
    4282:	9f 92       	push	r9
    4284:	af 92       	push	r10
    4286:	bf 92       	push	r11
    4288:	cf 92       	push	r12
    428a:	df 92       	push	r13
    428c:	ef 92       	push	r14
    428e:	ff 92       	push	r15
    4290:	0f 93       	push	r16
    4292:	1f 93       	push	r17
    4294:	cf 93       	push	r28
    4296:	df 93       	push	r29
    4298:	cd b7       	in	r28, 0x3d	; 61
    429a:	de b7       	in	r29, 0x3e	; 62
    429c:	64 97       	sbiw	r28, 0x14	; 20
    429e:	cd bf       	out	0x3d, r28	; 61
    42a0:	de bf       	out	0x3e, r29	; 62
    42a2:	2a 01       	movw	r4, r20
    42a4:	3b 01       	movw	r6, r22
    42a6:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    42a8:	f9 01       	movw	r30, r18
    42aa:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    42ac:	41 15       	cp	r20, r1
    42ae:	51 05       	cpc	r21, r1
    42b0:	61 05       	cpc	r22, r1
    42b2:	71 05       	cpc	r23, r1
    42b4:	09 f4       	brne	.+2      	; 0x42b8 <DeciToString+0x44>
    42b6:	4d c0       	rjmp	.+154    	; 0x4352 <DeciToString+0xde>
    42b8:	88 2e       	mov	r8, r24
    42ba:	99 2e       	mov	r9, r25
    42bc:	cc 24       	eor	r12, r12
    42be:	dd 24       	eor	r13, r13
    42c0:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    42c2:	5e 01       	movw	r10, r28
    42c4:	08 94       	sec
    42c6:	a1 1c       	adc	r10, r1
    42c8:	b1 1c       	adc	r11, r1
    42ca:	0f 2e       	mov	r0, r31
    42cc:	f3 e3       	ldi	r31, 0x33	; 51
    42ce:	2f 2e       	mov	r2, r31
    42d0:	f0 e2       	ldi	r31, 0x20	; 32
    42d2:	3f 2e       	mov	r3, r31
    42d4:	f0 2d       	mov	r31, r0
    42d6:	f4 01       	movw	r30, r8
    42d8:	81 91       	ld	r24, Z+
    42da:	91 91       	ld	r25, Z+
    42dc:	a1 91       	ld	r26, Z+
    42de:	b1 91       	ld	r27, Z+
    42e0:	4f 01       	movw	r8, r30
    42e2:	2d b7       	in	r18, 0x3d	; 61
    42e4:	3e b7       	in	r19, 0x3e	; 62
    42e6:	28 50       	subi	r18, 0x08	; 8
    42e8:	30 40       	sbci	r19, 0x00	; 0
    42ea:	2d bf       	out	0x3d, r18	; 61
    42ec:	3e bf       	out	0x3e, r19	; 62
    42ee:	2f 5f       	subi	r18, 0xFF	; 255
    42f0:	3f 4f       	sbci	r19, 0xFF	; 255
    42f2:	ed b7       	in	r30, 0x3d	; 61
    42f4:	fe b7       	in	r31, 0x3e	; 62
    42f6:	a1 82       	std	Z+1, r10	; 0x01
    42f8:	b2 82       	std	Z+2, r11	; 0x02
    42fa:	f9 01       	movw	r30, r18
    42fc:	22 82       	std	Z+2, r2	; 0x02
    42fe:	33 82       	std	Z+3, r3	; 0x03
    4300:	84 83       	std	Z+4, r24	; 0x04
    4302:	95 83       	std	Z+5, r25	; 0x05
    4304:	a6 83       	std	Z+6, r26	; 0x06
    4306:	b7 83       	std	Z+7, r27	; 0x07
    4308:	0e 94 8e 3b 	call	0x771c	; 0x771c <sprintf>
		strcat(ReturnString,b);
    430c:	2d b7       	in	r18, 0x3d	; 61
    430e:	3e b7       	in	r19, 0x3e	; 62
    4310:	28 5f       	subi	r18, 0xF8	; 248
    4312:	3f 4f       	sbci	r19, 0xFF	; 255
    4314:	2d bf       	out	0x3d, r18	; 61
    4316:	3e bf       	out	0x3e, r19	; 62
    4318:	c8 01       	movw	r24, r16
    431a:	b5 01       	movw	r22, r10
    431c:	0e 94 42 3b 	call	0x7684	; 0x7684 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    4320:	a0 2f       	mov	r26, r16
    4322:	b1 2f       	mov	r27, r17
    4324:	fd 01       	movw	r30, r26
    4326:	01 90       	ld	r0, Z+
    4328:	00 20       	and	r0, r0
    432a:	e9 f7       	brne	.-6      	; 0x4326 <DeciToString+0xb2>
    432c:	31 97       	sbiw	r30, 0x01	; 1
    432e:	ea 1b       	sub	r30, r26
    4330:	fb 0b       	sbc	r31, r27
    4332:	e0 0f       	add	r30, r16
    4334:	f1 1f       	adc	r31, r17
    4336:	8a e0       	ldi	r24, 0x0A	; 10
    4338:	90 e0       	ldi	r25, 0x00	; 0
    433a:	80 83       	st	Z, r24
    433c:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    433e:	08 94       	sec
    4340:	c1 1c       	adc	r12, r1
    4342:	d1 1c       	adc	r13, r1
    4344:	e1 1c       	adc	r14, r1
    4346:	f1 1c       	adc	r15, r1
    4348:	c4 14       	cp	r12, r4
    434a:	d5 04       	cpc	r13, r5
    434c:	e6 04       	cpc	r14, r6
    434e:	f7 04       	cpc	r15, r7
    4350:	11 f6       	brne	.-124    	; 0x42d6 <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    4352:	64 96       	adiw	r28, 0x14	; 20
    4354:	cd bf       	out	0x3d, r28	; 61
    4356:	de bf       	out	0x3e, r29	; 62
    4358:	df 91       	pop	r29
    435a:	cf 91       	pop	r28
    435c:	1f 91       	pop	r17
    435e:	0f 91       	pop	r16
    4360:	ff 90       	pop	r15
    4362:	ef 90       	pop	r14
    4364:	df 90       	pop	r13
    4366:	cf 90       	pop	r12
    4368:	bf 90       	pop	r11
    436a:	af 90       	pop	r10
    436c:	9f 90       	pop	r9
    436e:	8f 90       	pop	r8
    4370:	7f 90       	pop	r7
    4372:	6f 90       	pop	r6
    4374:	5f 90       	pop	r5
    4376:	4f 90       	pop	r4
    4378:	3f 90       	pop	r3
    437a:	2f 90       	pop	r2
    437c:	08 95       	ret

0000437e <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    437e:	cf 92       	push	r12
    4380:	df 92       	push	r13
    4382:	ef 92       	push	r14
    4384:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    4386:	20 91 7b 50 	lds	r18, 0x507B
    438a:	30 91 7c 50 	lds	r19, 0x507C
    438e:	c0 90 db 23 	lds	r12, 0x23DB
    4392:	d0 90 dc 23 	lds	r13, 0x23DC
    4396:	e0 90 dd 23 	lds	r14, 0x23DD
    439a:	f0 90 de 23 	lds	r15, 0x23DE
    439e:	62 50       	subi	r22, 0x02	; 2
    43a0:	70 40       	sbci	r23, 0x00	; 0
    43a2:	80 40       	sbci	r24, 0x00	; 0
    43a4:	90 40       	sbci	r25, 0x00	; 0
    43a6:	40 e0       	ldi	r20, 0x00	; 0
    43a8:	50 e0       	ldi	r21, 0x00	; 0
    43aa:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    43ae:	dc 01       	movw	r26, r24
    43b0:	cb 01       	movw	r24, r22
    43b2:	c8 0e       	add	r12, r24
    43b4:	d9 1e       	adc	r13, r25
    43b6:	ea 1e       	adc	r14, r26
    43b8:	fb 1e       	adc	r15, r27
}
    43ba:	6c 2d       	mov	r22, r12
    43bc:	7d 2d       	mov	r23, r13
    43be:	8e 2d       	mov	r24, r14
    43c0:	9f 2d       	mov	r25, r15
    43c2:	ff 90       	pop	r15
    43c4:	ef 90       	pop	r14
    43c6:	df 90       	pop	r13
    43c8:	cf 90       	pop	r12
    43ca:	08 95       	ret

000043cc <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    43cc:	3f 92       	push	r3
    43ce:	4f 92       	push	r4
    43d0:	5f 92       	push	r5
    43d2:	6f 92       	push	r6
    43d4:	7f 92       	push	r7
    43d6:	8f 92       	push	r8
    43d8:	9f 92       	push	r9
    43da:	af 92       	push	r10
    43dc:	bf 92       	push	r11
    43de:	cf 92       	push	r12
    43e0:	df 92       	push	r13
    43e2:	ef 92       	push	r14
    43e4:	ff 92       	push	r15
    43e6:	0f 93       	push	r16
    43e8:	1f 93       	push	r17
    43ea:	cf 93       	push	r28
    43ec:	df 93       	push	r29
    43ee:	00 d0       	rcall	.+0      	; 0x43f0 <getSetNextCluster+0x24>
    43f0:	0f 92       	push	r0
    43f2:	cd b7       	in	r28, 0x3d	; 61
    43f4:	de b7       	in	r29, 0x3e	; 62
    43f6:	dc 01       	movw	r26, r24
    43f8:	cb 01       	movw	r24, r22
    43fa:	34 2e       	mov	r3, r20
    43fc:	09 83       	std	Y+1, r16	; 0x01
    43fe:	1a 83       	std	Y+2, r17	; 0x02
    4400:	2b 83       	std	Y+3, r18	; 0x03
    4402:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    4404:	80 90 83 50 	lds	r8, 0x5083
    4408:	90 90 84 50 	lds	r9, 0x5084
    440c:	2c 01       	movw	r4, r24
    440e:	3d 01       	movw	r6, r26
    4410:	44 0c       	add	r4, r4
    4412:	55 1c       	adc	r5, r5
    4414:	66 1c       	adc	r6, r6
    4416:	77 1c       	adc	r7, r7
    4418:	44 0c       	add	r4, r4
    441a:	55 1c       	adc	r5, r5
    441c:	66 1c       	adc	r6, r6
    441e:	77 1c       	adc	r7, r7
    4420:	20 91 54 40 	lds	r18, 0x4054
    4424:	30 91 55 40 	lds	r19, 0x4055
    4428:	aa 24       	eor	r10, r10
    442a:	bb 24       	eor	r11, r11
    442c:	80 91 7d 50 	lds	r24, 0x507D
    4430:	90 91 7e 50 	lds	r25, 0x507E
    4434:	a0 91 7f 50 	lds	r26, 0x507F
    4438:	b0 91 80 50 	lds	r27, 0x5080
    443c:	88 0e       	add	r8, r24
    443e:	99 1e       	adc	r9, r25
    4440:	aa 1e       	adc	r10, r26
    4442:	bb 1e       	adc	r11, r27
    4444:	40 e0       	ldi	r20, 0x00	; 0
    4446:	50 e0       	ldi	r21, 0x00	; 0
    4448:	c3 01       	movw	r24, r6
    444a:	b2 01       	movw	r22, r4
    444c:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    4450:	69 01       	movw	r12, r18
    4452:	7a 01       	movw	r14, r20
    4454:	c8 0c       	add	r12, r8
    4456:	d9 1c       	adc	r13, r9
    4458:	ea 1c       	adc	r14, r10
    445a:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    445c:	00 91 54 40 	lds	r16, 0x4054
    4460:	10 91 55 40 	lds	r17, 0x4055

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    4464:	c7 01       	movw	r24, r14
    4466:	b6 01       	movw	r22, r12
    4468:	46 ed       	ldi	r20, 0xD6	; 214
    446a:	51 e2       	ldi	r21, 0x21	; 33
    446c:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    4470:	98 01       	movw	r18, r16
    4472:	40 e0       	ldi	r20, 0x00	; 0
    4474:	50 e0       	ldi	r21, 0x00	; 0
    4476:	c3 01       	movw	r24, r6
    4478:	b2 01       	movw	r22, r4
    447a:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    447e:	6a 52       	subi	r22, 0x2A	; 42
    4480:	7e 4d       	sbci	r23, 0xDE	; 222

if(get_set == GET)
    4482:	33 20       	and	r3, r3
    4484:	41 f4       	brne	.+16     	; 0x4496 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    4486:	db 01       	movw	r26, r22
    4488:	0d 91       	ld	r16, X+
    448a:	1d 91       	ld	r17, X+
    448c:	2d 91       	ld	r18, X+
    448e:	3c 91       	ld	r19, X
    4490:	13 97       	sbiw	r26, 0x03	; 3
    4492:	3f 70       	andi	r19, 0x0F	; 15
    4494:	14 c0       	rjmp	.+40     	; 0x44be <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4496:	89 81       	ldd	r24, Y+1	; 0x01
    4498:	9a 81       	ldd	r25, Y+2	; 0x02
    449a:	ab 81       	ldd	r26, Y+3	; 0x03
    449c:	bc 81       	ldd	r27, Y+4	; 0x04
    449e:	fb 01       	movw	r30, r22
    44a0:	80 83       	st	Z, r24
    44a2:	91 83       	std	Z+1, r25	; 0x01
    44a4:	a2 83       	std	Z+2, r26	; 0x02
    44a6:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    44a8:	c7 01       	movw	r24, r14
    44aa:	b6 01       	movw	r22, r12
    44ac:	46 ed       	ldi	r20, 0xD6	; 214
    44ae:	51 e2       	ldi	r21, 0x21	; 33
    44b0:	20 e0       	ldi	r18, 0x00	; 0
    44b2:	32 e0       	ldi	r19, 0x02	; 2
    44b4:	0e 94 1a 2c 	call	0x5834	; 0x5834 <SD_write_block>

return (0);
    44b8:	00 e0       	ldi	r16, 0x00	; 0
    44ba:	10 e0       	ldi	r17, 0x00	; 0
    44bc:	98 01       	movw	r18, r16
}
    44be:	60 2f       	mov	r22, r16
    44c0:	71 2f       	mov	r23, r17
    44c2:	82 2f       	mov	r24, r18
    44c4:	93 2f       	mov	r25, r19
    44c6:	24 96       	adiw	r28, 0x04	; 4
    44c8:	cd bf       	out	0x3d, r28	; 61
    44ca:	de bf       	out	0x3e, r29	; 62
    44cc:	df 91       	pop	r29
    44ce:	cf 91       	pop	r28
    44d0:	1f 91       	pop	r17
    44d2:	0f 91       	pop	r16
    44d4:	ff 90       	pop	r15
    44d6:	ef 90       	pop	r14
    44d8:	df 90       	pop	r13
    44da:	cf 90       	pop	r12
    44dc:	bf 90       	pop	r11
    44de:	af 90       	pop	r10
    44e0:	9f 90       	pop	r9
    44e2:	8f 90       	pop	r8
    44e4:	7f 90       	pop	r7
    44e6:	6f 90       	pop	r6
    44e8:	5f 90       	pop	r5
    44ea:	4f 90       	pop	r4
    44ec:	3f 90       	pop	r3
    44ee:	08 95       	ret

000044f0 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    44f0:	cf 92       	push	r12
    44f2:	df 92       	push	r13
    44f4:	ef 92       	push	r14
    44f6:	ff 92       	push	r15
    44f8:	0f 93       	push	r16
    44fa:	1f 93       	push	r17
    44fc:	cf 93       	push	r28
    44fe:	c8 2f       	mov	r28, r24
    4500:	06 2f       	mov	r16, r22
    4502:	69 01       	movw	r12, r18
    4504:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4506:	80 91 7d 50 	lds	r24, 0x507D
    450a:	90 91 7e 50 	lds	r25, 0x507E
    450e:	a0 91 7f 50 	lds	r26, 0x507F
    4512:	b0 91 80 50 	lds	r27, 0x5080
    4516:	bc 01       	movw	r22, r24
    4518:	cd 01       	movw	r24, r26
    451a:	6f 5f       	subi	r22, 0xFF	; 255
    451c:	7f 4f       	sbci	r23, 0xFF	; 255
    451e:	8f 4f       	sbci	r24, 0xFF	; 255
    4520:	9f 4f       	sbci	r25, 0xFF	; 255
    4522:	46 ed       	ldi	r20, 0xD6	; 214
    4524:	51 e2       	ldi	r21, 0x21	; 33
    4526:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    452a:	80 91 d6 21 	lds	r24, 0x21D6
    452e:	90 91 d7 21 	lds	r25, 0x21D7
    4532:	a0 91 d8 21 	lds	r26, 0x21D8
    4536:	b0 91 d9 21 	lds	r27, 0x21D9
    453a:	82 35       	cpi	r24, 0x52	; 82
    453c:	22 e5       	ldi	r18, 0x52	; 82
    453e:	92 07       	cpc	r25, r18
    4540:	21 e6       	ldi	r18, 0x61	; 97
    4542:	a2 07       	cpc	r26, r18
    4544:	21 e4       	ldi	r18, 0x41	; 65
    4546:	b2 07       	cpc	r27, r18
    4548:	09 f0       	breq	.+2      	; 0x454c <getSetFreeCluster+0x5c>
    454a:	63 c0       	rjmp	.+198    	; 0x4612 <getSetFreeCluster+0x122>
    454c:	80 91 ba 23 	lds	r24, 0x23BA
    4550:	90 91 bb 23 	lds	r25, 0x23BB
    4554:	a0 91 bc 23 	lds	r26, 0x23BC
    4558:	b0 91 bd 23 	lds	r27, 0x23BD
    455c:	82 37       	cpi	r24, 0x72	; 114
    455e:	22 e7       	ldi	r18, 0x72	; 114
    4560:	92 07       	cpc	r25, r18
    4562:	21 e4       	ldi	r18, 0x41	; 65
    4564:	a2 07       	cpc	r26, r18
    4566:	21 e6       	ldi	r18, 0x61	; 97
    4568:	b2 07       	cpc	r27, r18
    456a:	09 f0       	breq	.+2      	; 0x456e <getSetFreeCluster+0x7e>
    456c:	56 c0       	rjmp	.+172    	; 0x461a <getSetFreeCluster+0x12a>
    456e:	80 91 d2 23 	lds	r24, 0x23D2
    4572:	90 91 d3 23 	lds	r25, 0x23D3
    4576:	a0 91 d4 23 	lds	r26, 0x23D4
    457a:	b0 91 d5 23 	lds	r27, 0x23D5
    457e:	80 30       	cpi	r24, 0x00	; 0
    4580:	20 e0       	ldi	r18, 0x00	; 0
    4582:	92 07       	cpc	r25, r18
    4584:	25 e5       	ldi	r18, 0x55	; 85
    4586:	a2 07       	cpc	r26, r18
    4588:	2a ea       	ldi	r18, 0xAA	; 170
    458a:	b2 07       	cpc	r27, r18
    458c:	09 f0       	breq	.+2      	; 0x4590 <getSetFreeCluster+0xa0>
    458e:	49 c0       	rjmp	.+146    	; 0x4622 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4590:	00 23       	and	r16, r16
    4592:	a1 f4       	brne	.+40     	; 0x45bc <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4594:	c1 30       	cpi	r28, 0x01	; 1
    4596:	49 f4       	brne	.+18     	; 0x45aa <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    4598:	00 91 be 23 	lds	r16, 0x23BE
    459c:	10 91 bf 23 	lds	r17, 0x23BF
    45a0:	20 91 c0 23 	lds	r18, 0x23C0
    45a4:	30 91 c1 23 	lds	r19, 0x23C1
    45a8:	3f c0       	rjmp	.+126    	; 0x4628 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    45aa:	00 91 c2 23 	lds	r16, 0x23C2
    45ae:	10 91 c3 23 	lds	r17, 0x23C3
    45b2:	20 91 c4 23 	lds	r18, 0x23C4
    45b6:	30 91 c5 23 	lds	r19, 0x23C5
    45ba:	36 c0       	rjmp	.+108    	; 0x4628 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    45bc:	c1 30       	cpi	r28, 0x01	; 1
    45be:	49 f4       	brne	.+18     	; 0x45d2 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    45c0:	c0 92 be 23 	sts	0x23BE, r12
    45c4:	d0 92 bf 23 	sts	0x23BF, r13
    45c8:	e0 92 c0 23 	sts	0x23C0, r14
    45cc:	f0 92 c1 23 	sts	0x23C1, r15
    45d0:	08 c0       	rjmp	.+16     	; 0x45e2 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    45d2:	c0 92 c2 23 	sts	0x23C2, r12
    45d6:	d0 92 c3 23 	sts	0x23C3, r13
    45da:	e0 92 c4 23 	sts	0x23C4, r14
    45de:	f0 92 c5 23 	sts	0x23C5, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    45e2:	80 91 7d 50 	lds	r24, 0x507D
    45e6:	90 91 7e 50 	lds	r25, 0x507E
    45ea:	a0 91 7f 50 	lds	r26, 0x507F
    45ee:	b0 91 80 50 	lds	r27, 0x5080
    45f2:	bc 01       	movw	r22, r24
    45f4:	cd 01       	movw	r24, r26
    45f6:	6f 5f       	subi	r22, 0xFF	; 255
    45f8:	7f 4f       	sbci	r23, 0xFF	; 255
    45fa:	8f 4f       	sbci	r24, 0xFF	; 255
    45fc:	9f 4f       	sbci	r25, 0xFF	; 255
    45fe:	46 ed       	ldi	r20, 0xD6	; 214
    4600:	51 e2       	ldi	r21, 0x21	; 33
    4602:	20 e0       	ldi	r18, 0x00	; 0
    4604:	32 e0       	ldi	r19, 0x02	; 2
    4606:	0e 94 1a 2c 	call	0x5834	; 0x5834 <SD_write_block>
 }
 return 0xffffffff;
    460a:	0f ef       	ldi	r16, 0xFF	; 255
    460c:	1f ef       	ldi	r17, 0xFF	; 255
    460e:	98 01       	movw	r18, r16
    4610:	0b c0       	rjmp	.+22     	; 0x4628 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    4612:	0f ef       	ldi	r16, 0xFF	; 255
    4614:	1f ef       	ldi	r17, 0xFF	; 255
    4616:	98 01       	movw	r18, r16
    4618:	07 c0       	rjmp	.+14     	; 0x4628 <getSetFreeCluster+0x138>
    461a:	0f ef       	ldi	r16, 0xFF	; 255
    461c:	1f ef       	ldi	r17, 0xFF	; 255
    461e:	98 01       	movw	r18, r16
    4620:	03 c0       	rjmp	.+6      	; 0x4628 <getSetFreeCluster+0x138>
    4622:	0f ef       	ldi	r16, 0xFF	; 255
    4624:	1f ef       	ldi	r17, 0xFF	; 255
    4626:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    4628:	60 2f       	mov	r22, r16
    462a:	71 2f       	mov	r23, r17
    462c:	82 2f       	mov	r24, r18
    462e:	93 2f       	mov	r25, r19
    4630:	cf 91       	pop	r28
    4632:	1f 91       	pop	r17
    4634:	0f 91       	pop	r16
    4636:	ff 90       	pop	r15
    4638:	ef 90       	pop	r14
    463a:	df 90       	pop	r13
    463c:	cf 90       	pop	r12
    463e:	08 95       	ret

00004640 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    4640:	ef 92       	push	r14
    4642:	ff 92       	push	r15
    4644:	0f 93       	push	r16
    4646:	1f 93       	push	r17
    4648:	cf 93       	push	r28
    464a:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    464c:	10 92 7d 50 	sts	0x507D, r1
    4650:	10 92 7e 50 	sts	0x507E, r1
    4654:	10 92 7f 50 	sts	0x507F, r1
    4658:	10 92 80 50 	sts	0x5080, r1

SD_read_block(0,SDBuffer);
    465c:	60 e0       	ldi	r22, 0x00	; 0
    465e:	70 e0       	ldi	r23, 0x00	; 0
    4660:	cb 01       	movw	r24, r22
    4662:	46 ed       	ldi	r20, 0xD6	; 214
    4664:	51 e2       	ldi	r21, 0x21	; 33
    4666:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    466a:	80 91 d6 21 	lds	r24, 0x21D6
    466e:	89 3e       	cpi	r24, 0xE9	; 233
    4670:	31 f1       	breq	.+76     	; 0x46be <getBootSectorData+0x7e>
    4672:	8b 3e       	cpi	r24, 0xEB	; 235
    4674:	21 f1       	breq	.+72     	; 0x46be <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4676:	80 91 d4 23 	lds	r24, 0x23D4
    467a:	90 91 d5 23 	lds	r25, 0x23D5
    467e:	2a ea       	ldi	r18, 0xAA	; 170
    4680:	85 35       	cpi	r24, 0x55	; 85
    4682:	92 07       	cpc	r25, r18
    4684:	09 f0       	breq	.+2      	; 0x4688 <getBootSectorData+0x48>
    4686:	b7 c0       	rjmp	.+366    	; 0x47f6 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    4688:	60 91 9c 23 	lds	r22, 0x239C
    468c:	70 91 9d 23 	lds	r23, 0x239D
    4690:	80 91 9e 23 	lds	r24, 0x239E
    4694:	90 91 9f 23 	lds	r25, 0x239F
    4698:	60 93 7d 50 	sts	0x507D, r22
    469c:	70 93 7e 50 	sts	0x507E, r23
    46a0:	80 93 7f 50 	sts	0x507F, r24
    46a4:	90 93 80 50 	sts	0x5080, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    46a8:	46 ed       	ldi	r20, 0xD6	; 214
    46aa:	51 e2       	ldi	r21, 0x21	; 33
    46ac:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    46b0:	80 91 d6 21 	lds	r24, 0x21D6
    46b4:	89 3e       	cpi	r24, 0xE9	; 233
    46b6:	19 f0       	breq	.+6      	; 0x46be <getBootSectorData+0x7e>
    46b8:	8b 3e       	cpi	r24, 0xEB	; 235
    46ba:	09 f0       	breq	.+2      	; 0x46be <getBootSectorData+0x7e>
    46bc:	9e c0       	rjmp	.+316    	; 0x47fa <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    46be:	80 91 e1 21 	lds	r24, 0x21E1
    46c2:	90 91 e2 21 	lds	r25, 0x21E2
    46c6:	80 93 54 40 	sts	0x4054, r24
    46ca:	90 93 55 40 	sts	0x4055, r25
sectorPerCluster = bpb->sectorPerCluster;
    46ce:	80 91 e3 21 	lds	r24, 0x21E3
    46d2:	90 e0       	ldi	r25, 0x00	; 0
    46d4:	80 93 7b 50 	sts	0x507B, r24
    46d8:	90 93 7c 50 	sts	0x507C, r25
reservedSectorCount = bpb->reservedSectorCount;
    46dc:	e0 90 e4 21 	lds	r14, 0x21E4
    46e0:	f0 90 e5 21 	lds	r15, 0x21E5
    46e4:	e0 92 83 50 	sts	0x5083, r14
    46e8:	f0 92 84 50 	sts	0x5084, r15
rootCluster = bpb->rootCluster;
    46ec:	80 91 02 22 	lds	r24, 0x2202
    46f0:	90 91 03 22 	lds	r25, 0x2203
    46f4:	a0 91 04 22 	lds	r26, 0x2204
    46f8:	b0 91 05 22 	lds	r27, 0x2205
    46fc:	80 93 5f 40 	sts	0x405F, r24
    4700:	90 93 60 40 	sts	0x4060, r25
    4704:	a0 93 61 40 	sts	0x4061, r26
    4708:	b0 93 62 40 	sts	0x4062, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    470c:	c0 91 83 50 	lds	r28, 0x5083
    4710:	d0 91 84 50 	lds	r29, 0x5084
    4714:	60 91 e6 21 	lds	r22, 0x21E6
    4718:	70 e0       	ldi	r23, 0x00	; 0
    471a:	80 e0       	ldi	r24, 0x00	; 0
    471c:	90 e0       	ldi	r25, 0x00	; 0
    471e:	20 91 fa 21 	lds	r18, 0x21FA
    4722:	30 91 fb 21 	lds	r19, 0x21FB
    4726:	40 91 fc 21 	lds	r20, 0x21FC
    472a:	50 91 fd 21 	lds	r21, 0x21FD
    472e:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    4732:	8b 01       	movw	r16, r22
    4734:	9c 01       	movw	r18, r24
    4736:	ae 01       	movw	r20, r28
    4738:	60 e0       	ldi	r22, 0x00	; 0
    473a:	70 e0       	ldi	r23, 0x00	; 0
    473c:	80 91 f2 21 	lds	r24, 0x21F2
    4740:	90 91 f3 21 	lds	r25, 0x21F3
    4744:	a0 91 f4 21 	lds	r26, 0x21F4
    4748:	b0 91 f5 21 	lds	r27, 0x21F5
    474c:	84 0f       	add	r24, r20
    474e:	95 1f       	adc	r25, r21
    4750:	a6 1f       	adc	r26, r22
    4752:	b7 1f       	adc	r27, r23
    4754:	80 0f       	add	r24, r16
    4756:	91 1f       	adc	r25, r17
    4758:	a2 1f       	adc	r26, r18
    475a:	b3 1f       	adc	r27, r19
    475c:	80 93 db 23 	sts	0x23DB, r24
    4760:	90 93 dc 23 	sts	0x23DC, r25
    4764:	a0 93 dd 23 	sts	0x23DD, r26
    4768:	b0 93 de 23 	sts	0x23DE, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    476c:	e0 91 7b 50 	lds	r30, 0x507B
    4770:	f0 91 7c 50 	lds	r31, 0x507C
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4774:	c7 01       	movw	r24, r14
    4776:	a0 e0       	ldi	r26, 0x00	; 0
    4778:	b0 e0       	ldi	r27, 0x00	; 0
    477a:	40 91 f6 21 	lds	r20, 0x21F6
    477e:	50 91 f7 21 	lds	r21, 0x21F7
    4782:	60 91 f8 21 	lds	r22, 0x21F8
    4786:	70 91 f9 21 	lds	r23, 0x21F9
    478a:	48 1b       	sub	r20, r24
    478c:	59 0b       	sbc	r21, r25
    478e:	6a 0b       	sbc	r22, r26
    4790:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4792:	cb 01       	movw	r24, r22
    4794:	ba 01       	movw	r22, r20
    4796:	60 1b       	sub	r22, r16
    4798:	71 0b       	sbc	r23, r17
    479a:	82 0b       	sbc	r24, r18
    479c:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    479e:	9f 01       	movw	r18, r30
    47a0:	40 e0       	ldi	r20, 0x00	; 0
    47a2:	50 e0       	ldi	r21, 0x00	; 0
    47a4:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    47a8:	20 93 59 40 	sts	0x4059, r18
    47ac:	30 93 5a 40 	sts	0x405A, r19
    47b0:	40 93 5b 40 	sts	0x405B, r20
    47b4:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    47b8:	81 e0       	ldi	r24, 0x01	; 1
    47ba:	60 e0       	ldi	r22, 0x00	; 0
    47bc:	20 e0       	ldi	r18, 0x00	; 0
    47be:	30 e0       	ldi	r19, 0x00	; 0
    47c0:	a9 01       	movw	r20, r18
    47c2:	0e 94 78 22 	call	0x44f0	; 0x44f0 <getSetFreeCluster>
    47c6:	ab 01       	movw	r20, r22
    47c8:	bc 01       	movw	r22, r24
    47ca:	80 91 59 40 	lds	r24, 0x4059
    47ce:	90 91 5a 40 	lds	r25, 0x405A
    47d2:	a0 91 5b 40 	lds	r26, 0x405B
    47d6:	b0 91 5c 40 	lds	r27, 0x405C
    47da:	84 17       	cp	r24, r20
    47dc:	95 07       	cpc	r25, r21
    47de:	a6 07       	cpc	r26, r22
    47e0:	b7 07       	cpc	r27, r23
    47e2:	20 f4       	brcc	.+8      	; 0x47ec <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    47e4:	10 92 c7 50 	sts	0x50C7, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    47e8:	80 e0       	ldi	r24, 0x00	; 0
    47ea:	08 c0       	rjmp	.+16     	; 0x47fc <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    47ec:	81 e0       	ldi	r24, 0x01	; 1
    47ee:	80 93 c7 50 	sts	0x50C7, r24
return 0;
    47f2:	80 e0       	ldi	r24, 0x00	; 0
    47f4:	03 c0       	rjmp	.+6      	; 0x47fc <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    47f6:	81 e0       	ldi	r24, 0x01	; 1
    47f8:	01 c0       	rjmp	.+2      	; 0x47fc <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    47fa:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    47fc:	df 91       	pop	r29
    47fe:	cf 91       	pop	r28
    4800:	1f 91       	pop	r17
    4802:	0f 91       	pop	r16
    4804:	ff 90       	pop	r15
    4806:	ef 90       	pop	r14
    4808:	08 95       	ret

0000480a <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    480a:	0f 93       	push	r16
    480c:	1f 93       	push	r17
    480e:	cf 93       	push	r28
    4810:	df 93       	push	r29
    4812:	cd b7       	in	r28, 0x3d	; 61
    4814:	de b7       	in	r29, 0x3e	; 62
    4816:	2b 97       	sbiw	r28, 0x0b	; 11
    4818:	cd bf       	out	0x3d, r28	; 61
    481a:	de bf       	out	0x3e, r29	; 62
    481c:	78 2f       	mov	r23, r24
    481e:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4820:	e8 2f       	mov	r30, r24
    4822:	f9 2f       	mov	r31, r25
    4824:	df 01       	movw	r26, r30
    4826:	0d 90       	ld	r0, X+
    4828:	00 20       	and	r0, r0
    482a:	e9 f7       	brne	.-6      	; 0x4826 <convertFileName+0x1c>
    482c:	11 97       	sbiw	r26, 0x01	; 1
    482e:	ae 1b       	sub	r26, r30
    4830:	bf 0b       	sbc	r27, r31
    4832:	a0 31       	cpi	r26, 0x10	; 16
    4834:	b1 05       	cpc	r27, r1
    4836:	08 f0       	brcs	.+2      	; 0x483a <convertFileName+0x30>
    4838:	9c c0       	rjmp	.+312    	; 0x4972 <convertFileName+0x168>
    483a:	28 2f       	mov	r18, r24
    483c:	39 2f       	mov	r19, r25
    483e:	03 eb       	ldi	r16, 0xB3	; 179
    4840:	10 e5       	ldi	r17, 0x50	; 80
    4842:	a8 01       	movw	r20, r16
    4844:	80 e0       	ldi	r24, 0x00	; 0
    4846:	90 e0       	ldi	r25, 0x00	; 0
    4848:	07 c0       	rjmp	.+14     	; 0x4858 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    484a:	d9 01       	movw	r26, r18
    484c:	ed 91       	ld	r30, X+
    484e:	9d 01       	movw	r18, r26
    4850:	da 01       	movw	r26, r20
    4852:	ed 93       	st	X+, r30
    4854:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    4856:	01 96       	adiw	r24, 0x01	; 1
    4858:	a7 2f       	mov	r26, r23
    485a:	b6 2f       	mov	r27, r22
    485c:	fd 01       	movw	r30, r26
    485e:	01 90       	ld	r0, Z+
    4860:	00 20       	and	r0, r0
    4862:	e9 f7       	brne	.-6      	; 0x485e <convertFileName+0x54>
    4864:	31 97       	sbiw	r30, 0x01	; 1
    4866:	ea 1b       	sub	r30, r26
    4868:	fb 0b       	sbc	r31, r27
    486a:	8e 17       	cp	r24, r30
    486c:	9f 07       	cpc	r25, r31
    486e:	68 f3       	brcs	.-38     	; 0x484a <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4870:	8f 30       	cpi	r24, 0x0F	; 15
    4872:	91 05       	cpc	r25, r1
    4874:	54 f4       	brge	.+20     	; 0x488a <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4876:	fc 01       	movw	r30, r24
    4878:	ed 54       	subi	r30, 0x4D	; 77
    487a:	ff 4a       	sbci	r31, 0xAF	; 175
    487c:	82 ec       	ldi	r24, 0xC2	; 194
    487e:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4880:	20 e2       	ldi	r18, 0x20	; 32
    4882:	21 93       	st	Z+, r18
    4884:	e8 17       	cp	r30, r24
    4886:	f9 07       	cpc	r31, r25
    4888:	e1 f7       	brne	.-8      	; 0x4882 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    488a:	80 91 b3 50 	lds	r24, 0x50B3
    488e:	8e 32       	cpi	r24, 0x2E	; 46
    4890:	91 f0       	breq	.+36     	; 0x48b6 <convertFileName+0xac>
    4892:	e4 eb       	ldi	r30, 0xB4	; 180
    4894:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4896:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    4898:	81 91       	ld	r24, Z+
    489a:	8e 32       	cpi	r24, 0x2E	; 46
    489c:	21 f0       	breq	.+8      	; 0x48a6 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    489e:	2f 5f       	subi	r18, 0xFF	; 255
    48a0:	2c 30       	cpi	r18, 0x0C	; 12
    48a2:	d1 f7       	brne	.-12     	; 0x4898 <convertFileName+0x8e>
    48a4:	05 c0       	rjmp	.+10     	; 0x48b0 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    48a6:	82 2f       	mov	r24, r18
    48a8:	89 50       	subi	r24, 0x09	; 9
    48aa:	83 30       	cpi	r24, 0x03	; 3
    48ac:	08 f4       	brcc	.+2      	; 0x48b0 <convertFileName+0xa6>
    48ae:	63 c0       	rjmp	.+198    	; 0x4976 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    48b0:	22 23       	and	r18, r18
    48b2:	29 f4       	brne	.+10     	; 0x48be <convertFileName+0xb4>
    48b4:	01 c0       	rjmp	.+2      	; 0x48b8 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    48b6:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    48b8:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    48ba:	90 e2       	ldi	r25, 0x20	; 32
    48bc:	10 c0       	rjmp	.+32     	; 0x48de <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    48be:	de 01       	movw	r26, r28
    48c0:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    48c2:	82 2f       	mov	r24, r18
    48c4:	81 50       	subi	r24, 0x01	; 1
    48c6:	90 e0       	ldi	r25, 0x00	; 0
    48c8:	8c 54       	subi	r24, 0x4C	; 76
    48ca:	9f 4a       	sbci	r25, 0xAF	; 175
    48cc:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    48ce:	31 91       	ld	r19, Z+
    48d0:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    48d2:	e8 17       	cp	r30, r24
    48d4:	f9 07       	cpc	r31, r25
    48d6:	d9 f7       	brne	.-10     	; 0x48ce <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    48d8:	28 30       	cpi	r18, 0x08	; 8
    48da:	70 f3       	brcs	.-36     	; 0x48b8 <convertFileName+0xae>
    48dc:	0a c0       	rjmp	.+20     	; 0x48f2 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    48de:	e1 e0       	ldi	r30, 0x01	; 1
    48e0:	f0 e0       	ldi	r31, 0x00	; 0
    48e2:	ec 0f       	add	r30, r28
    48e4:	fd 1f       	adc	r31, r29
    48e6:	e8 0f       	add	r30, r24
    48e8:	f1 1d       	adc	r31, r1
    48ea:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    48ec:	8f 5f       	subi	r24, 0xFF	; 255
    48ee:	88 30       	cpi	r24, 0x08	; 8
    48f0:	b0 f3       	brcs	.-20     	; 0x48de <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    48f2:	2c 30       	cpi	r18, 0x0C	; 12
    48f4:	09 f0       	breq	.+2      	; 0x48f8 <convertFileName+0xee>
    48f6:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    48f8:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    48fa:	83 eb       	ldi	r24, 0xB3	; 179
    48fc:	90 e5       	ldi	r25, 0x50	; 80
    48fe:	fc 01       	movw	r30, r24
    4900:	e2 0f       	add	r30, r18
    4902:	f1 1d       	adc	r31, r1
    4904:	40 81       	ld	r20, Z
    4906:	44 23       	and	r20, r20
    4908:	19 f4       	brne	.+6      	; 0x4910 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    490a:	3b 30       	cpi	r19, 0x0B	; 11
    490c:	50 f0       	brcs	.+20     	; 0x4922 <convertFileName+0x118>
    490e:	15 c0       	rjmp	.+42     	; 0x493a <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    4910:	e1 e0       	ldi	r30, 0x01	; 1
    4912:	f0 e0       	ldi	r31, 0x00	; 0
    4914:	ec 0f       	add	r30, r28
    4916:	fd 1f       	adc	r31, r29
    4918:	e3 0f       	add	r30, r19
    491a:	f1 1d       	adc	r31, r1
    491c:	40 83       	st	Z, r20
    491e:	2f 5f       	subi	r18, 0xFF	; 255
    4920:	0c c0       	rjmp	.+24     	; 0x493a <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4922:	80 e2       	ldi	r24, 0x20	; 32
    4924:	e1 e0       	ldi	r30, 0x01	; 1
    4926:	f0 e0       	ldi	r31, 0x00	; 0
    4928:	ec 0f       	add	r30, r28
    492a:	fd 1f       	adc	r31, r29
    492c:	e3 0f       	add	r30, r19
    492e:	f1 1d       	adc	r31, r1
    4930:	80 83       	st	Z, r24
    4932:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4934:	3b 30       	cpi	r19, 0x0B	; 11
    4936:	b1 f7       	brne	.-20     	; 0x4924 <convertFileName+0x11a>
    4938:	03 c0       	rjmp	.+6      	; 0x4940 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    493a:	3f 5f       	subi	r19, 0xFF	; 255
    493c:	3b 30       	cpi	r19, 0x0B	; 11
    493e:	f8 f2       	brcs	.-66     	; 0x48fe <convertFileName+0xf4>
    4940:	de 01       	movw	r26, r28
    4942:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4944:	ce 01       	movw	r24, r28
    4946:	0c 96       	adiw	r24, 0x0c	; 12
    4948:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    494a:	20 81       	ld	r18, Z
    494c:	32 2f       	mov	r19, r18
    494e:	31 56       	subi	r19, 0x61	; 97
    4950:	3a 31       	cpi	r19, 0x1A	; 26
    4952:	10 f4       	brcc	.+4      	; 0x4958 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    4954:	20 52       	subi	r18, 0x20	; 32
    4956:	20 83       	st	Z, r18
    4958:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    495a:	e8 17       	cp	r30, r24
    495c:	f9 07       	cpc	r31, r25
    495e:	a9 f7       	brne	.-22     	; 0x494a <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    4960:	2d 91       	ld	r18, X+
    4962:	f8 01       	movw	r30, r16
    4964:	21 93       	st	Z+, r18
    4966:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    4968:	a8 17       	cp	r26, r24
    496a:	b9 07       	cpc	r27, r25
    496c:	c9 f7       	brne	.-14     	; 0x4960 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    496e:	80 e0       	ldi	r24, 0x00	; 0
    4970:	03 c0       	rjmp	.+6      	; 0x4978 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4972:	81 e0       	ldi	r24, 0x01	; 1
    4974:	01 c0       	rjmp	.+2      	; 0x4978 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4976:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    4978:	2b 96       	adiw	r28, 0x0b	; 11
    497a:	cd bf       	out	0x3d, r28	; 61
    497c:	de bf       	out	0x3e, r29	; 62
    497e:	df 91       	pop	r29
    4980:	cf 91       	pop	r28
    4982:	1f 91       	pop	r17
    4984:	0f 91       	pop	r16
    4986:	08 95       	ret

00004988 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4988:	4f 92       	push	r4
    498a:	5f 92       	push	r5
    498c:	6f 92       	push	r6
    498e:	7f 92       	push	r7
    4990:	8f 92       	push	r8
    4992:	9f 92       	push	r9
    4994:	af 92       	push	r10
    4996:	bf 92       	push	r11
    4998:	cf 92       	push	r12
    499a:	df 92       	push	r13
    499c:	ef 92       	push	r14
    499e:	ff 92       	push	r15
    49a0:	cf 93       	push	r28
    49a2:	df 93       	push	r29
    49a4:	2b 01       	movw	r4, r22
    49a6:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    49a8:	20 e8       	ldi	r18, 0x80	; 128
    49aa:	3f ef       	ldi	r19, 0xFF	; 255
    49ac:	4f ef       	ldi	r20, 0xFF	; 255
    49ae:	5f ef       	ldi	r21, 0xFF	; 255
    49b0:	42 22       	and	r4, r18
    49b2:	53 22       	and	r5, r19
    49b4:	64 22       	and	r6, r20
    49b6:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    49b8:	80 91 59 40 	lds	r24, 0x4059
    49bc:	90 91 5a 40 	lds	r25, 0x405A
    49c0:	a0 91 5b 40 	lds	r26, 0x405B
    49c4:	b0 91 5c 40 	lds	r27, 0x405C
    49c8:	48 16       	cp	r4, r24
    49ca:	59 06       	cpc	r5, r25
    49cc:	6a 06       	cpc	r6, r26
    49ce:	7b 06       	cpc	r7, r27
    49d0:	08 f0       	brcs	.+2      	; 0x49d4 <searchNextFreeCluster+0x4c>
    49d2:	77 c0       	rjmp	.+238    	; 0x4ac2 <searchNextFreeCluster+0x13a>
    49d4:	53 01       	movw	r10, r6
    49d6:	42 01       	movw	r8, r4
    49d8:	88 0c       	add	r8, r8
    49da:	99 1c       	adc	r9, r9
    49dc:	aa 1c       	adc	r10, r10
    49de:	bb 1c       	adc	r11, r11
    49e0:	88 0c       	add	r8, r8
    49e2:	99 1c       	adc	r9, r9
    49e4:	aa 1c       	adc	r10, r10
    49e6:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    49e8:	c6 ed       	ldi	r28, 0xD6	; 214
    49ea:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    49ec:	c0 90 83 50 	lds	r12, 0x5083
    49f0:	d0 90 84 50 	lds	r13, 0x5084
    49f4:	20 91 54 40 	lds	r18, 0x4054
    49f8:	30 91 55 40 	lds	r19, 0x4055
    49fc:	ee 24       	eor	r14, r14
    49fe:	ff 24       	eor	r15, r15
    4a00:	80 91 7d 50 	lds	r24, 0x507D
    4a04:	90 91 7e 50 	lds	r25, 0x507E
    4a08:	a0 91 7f 50 	lds	r26, 0x507F
    4a0c:	b0 91 80 50 	lds	r27, 0x5080
    4a10:	c8 0e       	add	r12, r24
    4a12:	d9 1e       	adc	r13, r25
    4a14:	ea 1e       	adc	r14, r26
    4a16:	fb 1e       	adc	r15, r27
    4a18:	40 e0       	ldi	r20, 0x00	; 0
    4a1a:	50 e0       	ldi	r21, 0x00	; 0
    4a1c:	c5 01       	movw	r24, r10
    4a1e:	b4 01       	movw	r22, r8
    4a20:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    4a24:	c7 01       	movw	r24, r14
    4a26:	b6 01       	movw	r22, r12
    4a28:	62 0f       	add	r22, r18
    4a2a:	73 1f       	adc	r23, r19
    4a2c:	84 1f       	adc	r24, r20
    4a2e:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    4a30:	ae 01       	movw	r20, r28
    4a32:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    4a36:	88 81       	ld	r24, Y
    4a38:	99 81       	ldd	r25, Y+1	; 0x01
    4a3a:	aa 81       	ldd	r26, Y+2	; 0x02
    4a3c:	bb 81       	ldd	r27, Y+3	; 0x03
    4a3e:	bf 70       	andi	r27, 0x0F	; 15
    4a40:	00 97       	sbiw	r24, 0x00	; 0
    4a42:	a1 05       	cpc	r26, r1
    4a44:	b1 05       	cpc	r27, r1
    4a46:	99 f0       	breq	.+38     	; 0x4a6e <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4a48:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    4a4a:	e2 2f       	mov	r30, r18
    4a4c:	f0 e0       	ldi	r31, 0x00	; 0
    4a4e:	ee 0f       	add	r30, r30
    4a50:	ff 1f       	adc	r31, r31
    4a52:	ee 0f       	add	r30, r30
    4a54:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    4a56:	ea 52       	subi	r30, 0x2A	; 42
    4a58:	fe 4d       	sbci	r31, 0xDE	; 222
    4a5a:	80 81       	ld	r24, Z
    4a5c:	91 81       	ldd	r25, Z+1	; 0x01
    4a5e:	a2 81       	ldd	r26, Z+2	; 0x02
    4a60:	b3 81       	ldd	r27, Z+3	; 0x03
    4a62:	bf 70       	andi	r27, 0x0F	; 15
    4a64:	00 97       	sbiw	r24, 0x00	; 0
    4a66:	a1 05       	cpc	r26, r1
    4a68:	b1 05       	cpc	r27, r1
    4a6a:	39 f4       	brne	.+14     	; 0x4a7a <searchNextFreeCluster+0xf2>
    4a6c:	01 c0       	rjmp	.+2      	; 0x4a70 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4a6e:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4a70:	42 0e       	add	r4, r18
    4a72:	51 1c       	adc	r5, r1
    4a74:	61 1c       	adc	r6, r1
    4a76:	71 1c       	adc	r7, r1
    4a78:	27 c0       	rjmp	.+78     	; 0x4ac8 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4a7a:	2f 5f       	subi	r18, 0xFF	; 255
    4a7c:	32 f7       	brpl	.-52     	; 0x4a4a <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4a7e:	80 e8       	ldi	r24, 0x80	; 128
    4a80:	90 e0       	ldi	r25, 0x00	; 0
    4a82:	a0 e0       	ldi	r26, 0x00	; 0
    4a84:	b0 e0       	ldi	r27, 0x00	; 0
    4a86:	48 0e       	add	r4, r24
    4a88:	59 1e       	adc	r5, r25
    4a8a:	6a 1e       	adc	r6, r26
    4a8c:	7b 1e       	adc	r7, r27
    4a8e:	80 91 59 40 	lds	r24, 0x4059
    4a92:	90 91 5a 40 	lds	r25, 0x405A
    4a96:	a0 91 5b 40 	lds	r26, 0x405B
    4a9a:	b0 91 5c 40 	lds	r27, 0x405C
    4a9e:	20 e0       	ldi	r18, 0x00	; 0
    4aa0:	32 e0       	ldi	r19, 0x02	; 2
    4aa2:	40 e0       	ldi	r20, 0x00	; 0
    4aa4:	50 e0       	ldi	r21, 0x00	; 0
    4aa6:	82 0e       	add	r8, r18
    4aa8:	93 1e       	adc	r9, r19
    4aaa:	a4 1e       	adc	r10, r20
    4aac:	b5 1e       	adc	r11, r21
    4aae:	48 16       	cp	r4, r24
    4ab0:	59 06       	cpc	r5, r25
    4ab2:	6a 06       	cpc	r6, r26
    4ab4:	7b 06       	cpc	r7, r27
    4ab6:	08 f4       	brcc	.+2      	; 0x4aba <searchNextFreeCluster+0x132>
    4ab8:	99 cf       	rjmp	.-206    	; 0x49ec <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4aba:	44 24       	eor	r4, r4
    4abc:	55 24       	eor	r5, r5
    4abe:	32 01       	movw	r6, r4
    4ac0:	03 c0       	rjmp	.+6      	; 0x4ac8 <searchNextFreeCluster+0x140>
    4ac2:	44 24       	eor	r4, r4
    4ac4:	55 24       	eor	r5, r5
    4ac6:	32 01       	movw	r6, r4
}
    4ac8:	64 2d       	mov	r22, r4
    4aca:	75 2d       	mov	r23, r5
    4acc:	86 2d       	mov	r24, r6
    4ace:	97 2d       	mov	r25, r7
    4ad0:	df 91       	pop	r29
    4ad2:	cf 91       	pop	r28
    4ad4:	ff 90       	pop	r15
    4ad6:	ef 90       	pop	r14
    4ad8:	df 90       	pop	r13
    4ada:	cf 90       	pop	r12
    4adc:	bf 90       	pop	r11
    4ade:	af 90       	pop	r10
    4ae0:	9f 90       	pop	r9
    4ae2:	8f 90       	pop	r8
    4ae4:	7f 90       	pop	r7
    4ae6:	6f 90       	pop	r6
    4ae8:	5f 90       	pop	r5
    4aea:	4f 90       	pop	r4
    4aec:	08 95       	ret

00004aee <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4aee:	cf 92       	push	r12
    4af0:	df 92       	push	r13
    4af2:	ef 92       	push	r14
    4af4:	ff 92       	push	r15
    4af6:	cf 93       	push	r28
    4af8:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4afa:	db 01       	movw	r26, r22
    4afc:	ca 01       	movw	r24, r20
    4afe:	91 70       	andi	r25, 0x01	; 1
    4b00:	a0 70       	andi	r26, 0x00	; 0
    4b02:	b0 70       	andi	r27, 0x00	; 0
    4b04:	00 97       	sbiw	r24, 0x00	; 0
    4b06:	a1 05       	cpc	r26, r1
    4b08:	b1 05       	cpc	r27, r1
    4b0a:	51 f4       	brne	.+20     	; 0x4b20 <freeMemoryUpdate+0x32>
    4b0c:	03 2e       	mov	r0, r19
    4b0e:	39 e0       	ldi	r19, 0x09	; 9
    4b10:	76 95       	lsr	r23
    4b12:	67 95       	ror	r22
    4b14:	57 95       	ror	r21
    4b16:	47 95       	ror	r20
    4b18:	3a 95       	dec	r19
    4b1a:	d1 f7       	brne	.-12     	; 0x4b10 <freeMemoryUpdate+0x22>
    4b1c:	30 2d       	mov	r19, r0
    4b1e:	0d c0       	rjmp	.+26     	; 0x4b3a <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4b20:	03 2e       	mov	r0, r19
    4b22:	39 e0       	ldi	r19, 0x09	; 9
    4b24:	76 95       	lsr	r23
    4b26:	67 95       	ror	r22
    4b28:	57 95       	ror	r21
    4b2a:	47 95       	ror	r20
    4b2c:	3a 95       	dec	r19
    4b2e:	d1 f7       	brne	.-12     	; 0x4b24 <freeMemoryUpdate+0x36>
    4b30:	30 2d       	mov	r19, r0
    4b32:	4f 5f       	subi	r20, 0xFF	; 255
    4b34:	5f 4f       	sbci	r21, 0xFF	; 255
    4b36:	6f 4f       	sbci	r22, 0xFF	; 255
    4b38:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4b3a:	db 01       	movw	r26, r22
    4b3c:	ca 01       	movw	r24, r20
    4b3e:	87 70       	andi	r24, 0x07	; 7
    4b40:	90 70       	andi	r25, 0x00	; 0
    4b42:	a0 70       	andi	r26, 0x00	; 0
    4b44:	b0 70       	andi	r27, 0x00	; 0
    4b46:	00 97       	sbiw	r24, 0x00	; 0
    4b48:	a1 05       	cpc	r26, r1
    4b4a:	b1 05       	cpc	r27, r1
    4b4c:	59 f4       	brne	.+22     	; 0x4b64 <freeMemoryUpdate+0x76>
    4b4e:	6a 01       	movw	r12, r20
    4b50:	7b 01       	movw	r14, r22
    4b52:	68 94       	set
    4b54:	12 f8       	bld	r1, 2
    4b56:	f6 94       	lsr	r15
    4b58:	e7 94       	ror	r14
    4b5a:	d7 94       	ror	r13
    4b5c:	c7 94       	ror	r12
    4b5e:	16 94       	lsr	r1
    4b60:	d1 f7       	brne	.-12     	; 0x4b56 <freeMemoryUpdate+0x68>
    4b62:	0f c0       	rjmp	.+30     	; 0x4b82 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    4b64:	6a 01       	movw	r12, r20
    4b66:	7b 01       	movw	r14, r22
    4b68:	68 94       	set
    4b6a:	12 f8       	bld	r1, 2
    4b6c:	f6 94       	lsr	r15
    4b6e:	e7 94       	ror	r14
    4b70:	d7 94       	ror	r13
    4b72:	c7 94       	ror	r12
    4b74:	16 94       	lsr	r1
    4b76:	d1 f7       	brne	.-12     	; 0x4b6c <freeMemoryUpdate+0x7e>
    4b78:	08 94       	sec
    4b7a:	c1 1c       	adc	r12, r1
    4b7c:	d1 1c       	adc	r13, r1
    4b7e:	e1 1c       	adc	r14, r1
    4b80:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4b82:	80 91 c7 50 	lds	r24, 0x50C7
    4b86:	88 23       	and	r24, r24
    4b88:	d1 f0       	breq	.+52     	; 0x4bbe <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4b8a:	81 e0       	ldi	r24, 0x01	; 1
    4b8c:	60 e0       	ldi	r22, 0x00	; 0
    4b8e:	20 e0       	ldi	r18, 0x00	; 0
    4b90:	30 e0       	ldi	r19, 0x00	; 0
    4b92:	a9 01       	movw	r20, r18
    4b94:	0e 94 78 22 	call	0x44f0	; 0x44f0 <getSetFreeCluster>
	if(flag == ADD)
    4b98:	cc 23       	and	r28, r28
    4b9a:	39 f4       	brne	.+14     	; 0x4baa <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4b9c:	9b 01       	movw	r18, r22
    4b9e:	ac 01       	movw	r20, r24
    4ba0:	2c 0d       	add	r18, r12
    4ba2:	3d 1d       	adc	r19, r13
    4ba4:	4e 1d       	adc	r20, r14
    4ba6:	5f 1d       	adc	r21, r15
    4ba8:	06 c0       	rjmp	.+12     	; 0x4bb6 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4baa:	9b 01       	movw	r18, r22
    4bac:	ac 01       	movw	r20, r24
    4bae:	2c 19       	sub	r18, r12
    4bb0:	3d 09       	sbc	r19, r13
    4bb2:	4e 09       	sbc	r20, r14
    4bb4:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4bb6:	81 e0       	ldi	r24, 0x01	; 1
    4bb8:	61 e0       	ldi	r22, 0x01	; 1
    4bba:	0e 94 78 22 	call	0x44f0	; 0x44f0 <getSetFreeCluster>
  }
}
    4bbe:	cf 91       	pop	r28
    4bc0:	ff 90       	pop	r15
    4bc2:	ef 90       	pop	r14
    4bc4:	df 90       	pop	r13
    4bc6:	cf 90       	pop	r12
    4bc8:	08 95       	ret

00004bca <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4bca:	2f 92       	push	r2
    4bcc:	3f 92       	push	r3
    4bce:	4f 92       	push	r4
    4bd0:	5f 92       	push	r5
    4bd2:	6f 92       	push	r6
    4bd4:	7f 92       	push	r7
    4bd6:	8f 92       	push	r8
    4bd8:	9f 92       	push	r9
    4bda:	af 92       	push	r10
    4bdc:	bf 92       	push	r11
    4bde:	cf 92       	push	r12
    4be0:	df 92       	push	r13
    4be2:	ef 92       	push	r14
    4be4:	ff 92       	push	r15
    4be6:	0f 93       	push	r16
    4be8:	1f 93       	push	r17
    4bea:	cf 93       	push	r28
    4bec:	df 93       	push	r29
    4bee:	cd b7       	in	r28, 0x3d	; 61
    4bf0:	de b7       	in	r29, 0x3e	; 62
    4bf2:	2c 97       	sbiw	r28, 0x0c	; 12
    4bf4:	cd bf       	out	0x3d, r28	; 61
    4bf6:	de bf       	out	0x3e, r29	; 62
    4bf8:	88 2e       	mov	r8, r24
    4bfa:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4bfc:	80 91 5f 40 	lds	r24, 0x405F
    4c00:	90 91 60 40 	lds	r25, 0x4060
    4c04:	a0 91 61 40 	lds	r26, 0x4061
    4c08:	b0 91 62 40 	lds	r27, 0x4062
    4c0c:	89 87       	std	Y+9, r24	; 0x09
    4c0e:	9a 87       	std	Y+10, r25	; 0x0a
    4c10:	ab 87       	std	Y+11, r26	; 0x0b
    4c12:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c14:	0f 2e       	mov	r0, r31
    4c16:	f6 ed       	ldi	r31, 0xD6	; 214
    4c18:	2f 2e       	mov	r2, r31
    4c1a:	f1 e2       	ldi	r31, 0x21	; 33
    4c1c:	3f 2e       	mov	r3, r31
    4c1e:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4c20:	c8 2c       	mov	r12, r8
    4c22:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c24:	d2 2c       	mov	r13, r2
    4c26:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4c28:	5b 01       	movw	r10, r22
    4c2a:	08 94       	sec
    4c2c:	a1 1c       	adc	r10, r1
    4c2e:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4c30:	69 85       	ldd	r22, Y+9	; 0x09
    4c32:	7a 85       	ldd	r23, Y+10	; 0x0a
    4c34:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c36:	9c 85       	ldd	r25, Y+12	; 0x0c
    4c38:	0e 94 bf 21 	call	0x437e	; 0x437e <getFirstSector>
    4c3c:	6d 83       	std	Y+5, r22	; 0x05
    4c3e:	7e 83       	std	Y+6, r23	; 0x06
    4c40:	8f 83       	std	Y+7, r24	; 0x07
    4c42:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4c44:	80 91 7b 50 	lds	r24, 0x507B
    4c48:	90 91 7c 50 	lds	r25, 0x507C
    4c4c:	00 97       	sbiw	r24, 0x00	; 0
    4c4e:	09 f4       	brne	.+2      	; 0x4c52 <findFiles+0x88>
    4c50:	13 c1       	rjmp	.+550    	; 0x4e78 <findFiles+0x2ae>
    4c52:	44 24       	eor	r4, r4
    4c54:	55 24       	eor	r5, r5
    4c56:	32 01       	movw	r6, r4
    4c58:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c5a:	8d 81       	ldd	r24, Y+5	; 0x05
    4c5c:	9e 81       	ldd	r25, Y+6	; 0x06
    4c5e:	af 81       	ldd	r26, Y+7	; 0x07
    4c60:	b8 85       	ldd	r27, Y+8	; 0x08
    4c62:	84 0d       	add	r24, r4
    4c64:	95 1d       	adc	r25, r5
    4c66:	a6 1d       	adc	r26, r6
    4c68:	b7 1d       	adc	r27, r7
    4c6a:	89 83       	std	Y+1, r24	; 0x01
    4c6c:	9a 83       	std	Y+2, r25	; 0x02
    4c6e:	ab 83       	std	Y+3, r26	; 0x03
    4c70:	bc 83       	std	Y+4, r27	; 0x04
    4c72:	bc 01       	movw	r22, r24
    4c74:	cd 01       	movw	r24, r26
    4c76:	4d 2d       	mov	r20, r13
    4c78:	59 2d       	mov	r21, r9
    4c7a:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4c7e:	80 91 54 40 	lds	r24, 0x4054
    4c82:	90 91 55 40 	lds	r25, 0x4055
    4c86:	00 97       	sbiw	r24, 0x00	; 0
    4c88:	09 f4       	brne	.+2      	; 0x4c8c <findFiles+0xc2>
    4c8a:	e4 c0       	rjmp	.+456    	; 0x4e54 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4c8c:	d1 01       	movw	r26, r2
    4c8e:	8c 91       	ld	r24, X
    4c90:	88 23       	and	r24, r24
    4c92:	09 f4       	brne	.+2      	; 0x4c96 <findFiles+0xcc>
    4c94:	10 c1       	rjmp	.+544    	; 0x4eb6 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4c96:	4d 2d       	mov	r20, r13
    4c98:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4c9a:	20 e0       	ldi	r18, 0x00	; 0
    4c9c:	30 e0       	ldi	r19, 0x00	; 0
    4c9e:	08 c0       	rjmp	.+16     	; 0x4cb0 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4ca0:	a9 01       	movw	r20, r18
    4ca2:	4a 52       	subi	r20, 0x2A	; 42
    4ca4:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4ca6:	fa 01       	movw	r30, r20
    4ca8:	80 81       	ld	r24, Z
    4caa:	88 23       	and	r24, r24
    4cac:	09 f4       	brne	.+2      	; 0x4cb0 <findFiles+0xe6>
    4cae:	06 c1       	rjmp	.+524    	; 0x4ebc <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4cb0:	85 3e       	cpi	r24, 0xE5	; 229
    4cb2:	09 f4       	brne	.+2      	; 0x4cb6 <findFiles+0xec>
    4cb4:	c5 c0       	rjmp	.+394    	; 0x4e40 <findFiles+0x276>
    4cb6:	da 01       	movw	r26, r20
    4cb8:	1b 96       	adiw	r26, 0x0b	; 11
    4cba:	8c 91       	ld	r24, X
    4cbc:	1b 97       	sbiw	r26, 0x0b	; 11
    4cbe:	8f 30       	cpi	r24, 0x0F	; 15
    4cc0:	09 f4       	brne	.+2      	; 0x4cc4 <findFiles+0xfa>
    4cc2:	be c0       	rjmp	.+380    	; 0x4e40 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4cc4:	12 30       	cpi	r17, 0x02	; 2
    4cc6:	08 f0       	brcs	.+2      	; 0x4cca <findFiles+0x100>
    4cc8:	fc c0       	rjmp	.+504    	; 0x4ec2 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4cca:	9c 91       	ld	r25, X
    4ccc:	f7 01       	movw	r30, r14
    4cce:	80 81       	ld	r24, Z
    4cd0:	98 17       	cp	r25, r24
    4cd2:	09 f0       	breq	.+2      	; 0x4cd6 <findFiles+0x10c>
    4cd4:	b5 c0       	rjmp	.+362    	; 0x4e40 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4cd6:	fa 01       	movw	r30, r20
    4cd8:	31 96       	adiw	r30, 0x01	; 1
    4cda:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4cdc:	81 e0       	ldi	r24, 0x01	; 1
    4cde:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4ce0:	41 91       	ld	r20, Z+
    4ce2:	9d 91       	ld	r25, X+
    4ce4:	49 17       	cp	r20, r25
    4ce6:	31 f4       	brne	.+12     	; 0x4cf4 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4ce8:	8f 5f       	subi	r24, 0xFF	; 255
    4cea:	8b 30       	cpi	r24, 0x0B	; 11
    4cec:	c9 f7       	brne	.-14     	; 0x4ce0 <findFiles+0x116>
    4cee:	8b 01       	movw	r16, r22
    4cf0:	6b 01       	movw	r12, r22
    4cf2:	05 c0       	rjmp	.+10     	; 0x4cfe <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4cf4:	8b 30       	cpi	r24, 0x0B	; 11
    4cf6:	09 f0       	breq	.+2      	; 0x4cfa <findFiles+0x130>
    4cf8:	a3 c0       	rjmp	.+326    	; 0x4e40 <findFiles+0x276>
    4cfa:	8b 01       	movw	r16, r22
    4cfc:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4cfe:	f1 e0       	ldi	r31, 0x01	; 1
    4d00:	8f 16       	cp	r8, r31
    4d02:	09 f0       	breq	.+2      	; 0x4d06 <findFiles+0x13c>
    4d04:	41 c0       	rjmp	.+130    	; 0x4d88 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4d06:	89 81       	ldd	r24, Y+1	; 0x01
    4d08:	9a 81       	ldd	r25, Y+2	; 0x02
    4d0a:	ab 81       	ldd	r26, Y+3	; 0x03
    4d0c:	bc 81       	ldd	r27, Y+4	; 0x04
    4d0e:	80 93 c9 50 	sts	0x50C9, r24
    4d12:	90 93 ca 50 	sts	0x50CA, r25
    4d16:	a0 93 cb 50 	sts	0x50CB, r26
    4d1a:	b0 93 cc 50 	sts	0x50CC, r27
				appendFileLocation = i;
    4d1e:	c9 01       	movw	r24, r18
    4d20:	a0 e0       	ldi	r26, 0x00	; 0
    4d22:	b0 e0       	ldi	r27, 0x00	; 0
    4d24:	80 93 d7 23 	sts	0x23D7, r24
    4d28:	90 93 d8 23 	sts	0x23D8, r25
    4d2c:	a0 93 d9 23 	sts	0x23D9, r26
    4d30:	b0 93 da 23 	sts	0x23DA, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4d34:	d6 01       	movw	r26, r12
    4d36:	54 96       	adiw	r26, 0x14	; 20
    4d38:	4d 91       	ld	r20, X+
    4d3a:	5c 91       	ld	r21, X
    4d3c:	55 97       	sbiw	r26, 0x15	; 21
    4d3e:	60 e0       	ldi	r22, 0x00	; 0
    4d40:	70 e0       	ldi	r23, 0x00	; 0
    4d42:	ba 01       	movw	r22, r20
    4d44:	55 27       	eor	r21, r21
    4d46:	44 27       	eor	r20, r20
    4d48:	5a 96       	adiw	r26, 0x1a	; 26
    4d4a:	8d 91       	ld	r24, X+
    4d4c:	9c 91       	ld	r25, X
    4d4e:	5b 97       	sbiw	r26, 0x1b	; 27
    4d50:	a0 e0       	ldi	r26, 0x00	; 0
    4d52:	b0 e0       	ldi	r27, 0x00	; 0
    4d54:	84 2b       	or	r24, r20
    4d56:	95 2b       	or	r25, r21
    4d58:	a6 2b       	or	r26, r22
    4d5a:	b7 2b       	or	r27, r23
    4d5c:	80 93 87 50 	sts	0x5087, r24
    4d60:	90 93 88 50 	sts	0x5088, r25
    4d64:	a0 93 89 50 	sts	0x5089, r26
    4d68:	b0 93 8a 50 	sts	0x508A, r27
				fileSize = dir->fileSize;
    4d6c:	f6 01       	movw	r30, r12
    4d6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d70:	95 8d       	ldd	r25, Z+29	; 0x1d
    4d72:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4d74:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4d76:	80 93 50 40 	sts	0x4050, r24
    4d7a:	90 93 51 40 	sts	0x4051, r25
    4d7e:	a0 93 52 40 	sts	0x4052, r26
    4d82:	b0 93 53 40 	sts	0x4053, r27
			    return (dir);
    4d86:	a5 c0       	rjmp	.+330    	; 0x4ed2 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4d88:	d6 01       	movw	r26, r12
    4d8a:	54 96       	adiw	r26, 0x14	; 20
    4d8c:	8d 91       	ld	r24, X+
    4d8e:	9c 91       	ld	r25, X
    4d90:	55 97       	sbiw	r26, 0x15	; 21
    4d92:	a0 e0       	ldi	r26, 0x00	; 0
    4d94:	b0 e0       	ldi	r27, 0x00	; 0
    4d96:	3c 01       	movw	r6, r24
    4d98:	55 24       	eor	r5, r5
    4d9a:	44 24       	eor	r4, r4
    4d9c:	f6 01       	movw	r30, r12
    4d9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4da0:	93 8d       	ldd	r25, Z+27	; 0x1b
    4da2:	a0 e0       	ldi	r26, 0x00	; 0
    4da4:	b0 e0       	ldi	r27, 0x00	; 0
    4da6:	48 2a       	or	r4, r24
    4da8:	59 2a       	or	r5, r25
    4daa:	6a 2a       	or	r6, r26
    4dac:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4dae:	85 ee       	ldi	r24, 0xE5	; 229
    4db0:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4db2:	69 81       	ldd	r22, Y+1	; 0x01
    4db4:	7a 81       	ldd	r23, Y+2	; 0x02
    4db6:	8b 81       	ldd	r24, Y+3	; 0x03
    4db8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dba:	46 ed       	ldi	r20, 0xD6	; 214
    4dbc:	51 e2       	ldi	r21, 0x21	; 33
    4dbe:	20 e0       	ldi	r18, 0x00	; 0
    4dc0:	32 e0       	ldi	r19, 0x02	; 2
    4dc2:	0e 94 1a 2c 	call	0x5834	; 0x5834 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4dc6:	d6 01       	movw	r26, r12
    4dc8:	5c 96       	adiw	r26, 0x1c	; 28
    4dca:	4d 91       	ld	r20, X+
    4dcc:	5d 91       	ld	r21, X+
    4dce:	6d 91       	ld	r22, X+
    4dd0:	7c 91       	ld	r23, X
    4dd2:	5f 97       	sbiw	r26, 0x1f	; 31
    4dd4:	80 e0       	ldi	r24, 0x00	; 0
    4dd6:	0e 94 77 25 	call	0x4aee	; 0x4aee <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4dda:	82 e0       	ldi	r24, 0x02	; 2
    4ddc:	60 e0       	ldi	r22, 0x00	; 0
    4dde:	20 e0       	ldi	r18, 0x00	; 0
    4de0:	30 e0       	ldi	r19, 0x00	; 0
    4de2:	a9 01       	movw	r20, r18
    4de4:	0e 94 78 22 	call	0x44f0	; 0x44f0 <getSetFreeCluster>
    4de8:	dc 01       	movw	r26, r24
    4dea:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4dec:	48 16       	cp	r4, r24
    4dee:	59 06       	cpc	r5, r25
    4df0:	6a 06       	cpc	r6, r26
    4df2:	7b 06       	cpc	r7, r27
    4df4:	30 f4       	brcc	.+12     	; 0x4e02 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4df6:	82 e0       	ldi	r24, 0x02	; 2
    4df8:	61 e0       	ldi	r22, 0x01	; 1
    4dfa:	a3 01       	movw	r20, r6
    4dfc:	92 01       	movw	r18, r4
    4dfe:	0e 94 78 22 	call	0x44f0	; 0x44f0 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4e02:	c3 01       	movw	r24, r6
    4e04:	b2 01       	movw	r22, r4
    4e06:	40 e0       	ldi	r20, 0x00	; 0
    4e08:	00 e0       	ldi	r16, 0x00	; 0
    4e0a:	10 e0       	ldi	r17, 0x00	; 0
    4e0c:	98 01       	movw	r18, r16
    4e0e:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
    4e12:	6b 01       	movw	r12, r22
    4e14:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4e16:	c3 01       	movw	r24, r6
    4e18:	b2 01       	movw	r22, r4
    4e1a:	41 e0       	ldi	r20, 0x01	; 1
    4e1c:	00 e0       	ldi	r16, 0x00	; 0
    4e1e:	10 e0       	ldi	r17, 0x00	; 0
    4e20:	98 01       	movw	r18, r16
    4e22:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4e26:	b7 ef       	ldi	r27, 0xF7	; 247
    4e28:	cb 16       	cp	r12, r27
    4e2a:	bf ef       	ldi	r27, 0xFF	; 255
    4e2c:	db 06       	cpc	r13, r27
    4e2e:	bf ef       	ldi	r27, 0xFF	; 255
    4e30:	eb 06       	cpc	r14, r27
    4e32:	bf e0       	ldi	r27, 0x0F	; 15
    4e34:	fb 06       	cpc	r15, r27
    4e36:	08 f0       	brcs	.+2      	; 0x4e3a <findFiles+0x270>
    4e38:	47 c0       	rjmp	.+142    	; 0x4ec8 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4e3a:	26 01       	movw	r4, r12
    4e3c:	37 01       	movw	r6, r14
    4e3e:	e1 cf       	rjmp	.-62     	; 0x4e02 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4e40:	20 5e       	subi	r18, 0xE0	; 224
    4e42:	3f 4f       	sbci	r19, 0xFF	; 255
    4e44:	80 91 54 40 	lds	r24, 0x4054
    4e48:	90 91 55 40 	lds	r25, 0x4055
    4e4c:	28 17       	cp	r18, r24
    4e4e:	39 07       	cpc	r19, r25
    4e50:	08 f4       	brcc	.+2      	; 0x4e54 <findFiles+0x28a>
    4e52:	26 cf       	rjmp	.-436    	; 0x4ca0 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4e54:	08 94       	sec
    4e56:	41 1c       	adc	r4, r1
    4e58:	51 1c       	adc	r5, r1
    4e5a:	61 1c       	adc	r6, r1
    4e5c:	71 1c       	adc	r7, r1
    4e5e:	80 91 7b 50 	lds	r24, 0x507B
    4e62:	90 91 7c 50 	lds	r25, 0x507C
    4e66:	a0 e0       	ldi	r26, 0x00	; 0
    4e68:	b0 e0       	ldi	r27, 0x00	; 0
    4e6a:	48 16       	cp	r4, r24
    4e6c:	59 06       	cpc	r5, r25
    4e6e:	6a 06       	cpc	r6, r26
    4e70:	7b 06       	cpc	r7, r27
    4e72:	08 f4       	brcc	.+2      	; 0x4e76 <findFiles+0x2ac>
    4e74:	f2 ce       	rjmp	.-540    	; 0x4c5a <findFiles+0x90>
    4e76:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4e78:	69 85       	ldd	r22, Y+9	; 0x09
    4e7a:	7a 85       	ldd	r23, Y+10	; 0x0a
    4e7c:	8b 85       	ldd	r24, Y+11	; 0x0b
    4e7e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4e80:	40 e0       	ldi	r20, 0x00	; 0
    4e82:	00 e0       	ldi	r16, 0x00	; 0
    4e84:	10 e0       	ldi	r17, 0x00	; 0
    4e86:	98 01       	movw	r18, r16
    4e88:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
    4e8c:	69 87       	std	Y+9, r22	; 0x09
    4e8e:	7a 87       	std	Y+10, r23	; 0x0a
    4e90:	8b 87       	std	Y+11, r24	; 0x0b
    4e92:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4e94:	67 3f       	cpi	r22, 0xF7	; 247
    4e96:	ef ef       	ldi	r30, 0xFF	; 255
    4e98:	7e 07       	cpc	r23, r30
    4e9a:	ef ef       	ldi	r30, 0xFF	; 255
    4e9c:	8e 07       	cpc	r24, r30
    4e9e:	ef e0       	ldi	r30, 0x0F	; 15
    4ea0:	9e 07       	cpc	r25, r30
    4ea2:	a8 f4       	brcc	.+42     	; 0x4ece <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4ea4:	61 15       	cp	r22, r1
    4ea6:	71 05       	cpc	r23, r1
    4ea8:	81 05       	cpc	r24, r1
    4eaa:	91 05       	cpc	r25, r1
    4eac:	09 f0       	breq	.+2      	; 0x4eb0 <findFiles+0x2e6>
    4eae:	c0 ce       	rjmp	.-640    	; 0x4c30 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4eb0:	00 e0       	ldi	r16, 0x00	; 0
    4eb2:	10 e0       	ldi	r17, 0x00	; 0
    4eb4:	0e c0       	rjmp	.+28     	; 0x4ed2 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4eb6:	00 e0       	ldi	r16, 0x00	; 0
    4eb8:	10 e0       	ldi	r17, 0x00	; 0
    4eba:	0b c0       	rjmp	.+22     	; 0x4ed2 <findFiles+0x308>
    4ebc:	00 e0       	ldi	r16, 0x00	; 0
    4ebe:	10 e0       	ldi	r17, 0x00	; 0
    4ec0:	08 c0       	rjmp	.+16     	; 0x4ed2 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4ec2:	00 e0       	ldi	r16, 0x00	; 0
    4ec4:	10 e0       	ldi	r17, 0x00	; 0
    4ec6:	05 c0       	rjmp	.+10     	; 0x4ed2 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4ec8:	00 e0       	ldi	r16, 0x00	; 0
    4eca:	10 e0       	ldi	r17, 0x00	; 0
    4ecc:	02 c0       	rjmp	.+4      	; 0x4ed2 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4ece:	00 e0       	ldi	r16, 0x00	; 0
    4ed0:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4ed2:	80 2f       	mov	r24, r16
    4ed4:	91 2f       	mov	r25, r17
    4ed6:	2c 96       	adiw	r28, 0x0c	; 12
    4ed8:	cd bf       	out	0x3d, r28	; 61
    4eda:	de bf       	out	0x3e, r29	; 62
    4edc:	df 91       	pop	r29
    4ede:	cf 91       	pop	r28
    4ee0:	1f 91       	pop	r17
    4ee2:	0f 91       	pop	r16
    4ee4:	ff 90       	pop	r15
    4ee6:	ef 90       	pop	r14
    4ee8:	df 90       	pop	r13
    4eea:	cf 90       	pop	r12
    4eec:	bf 90       	pop	r11
    4eee:	af 90       	pop	r10
    4ef0:	9f 90       	pop	r9
    4ef2:	8f 90       	pop	r8
    4ef4:	7f 90       	pop	r7
    4ef6:	6f 90       	pop	r6
    4ef8:	5f 90       	pop	r5
    4efa:	4f 90       	pop	r4
    4efc:	3f 90       	pop	r3
    4efe:	2f 90       	pop	r2
    4f00:	08 95       	ret

00004f02 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4f02:	0e 94 05 24 	call	0x480a	; 0x480a <convertFileName>
  if(error) return;
    4f06:	88 23       	and	r24, r24
    4f08:	29 f4       	brne	.+10     	; 0x4f14 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4f0a:	82 e0       	ldi	r24, 0x02	; 2
    4f0c:	63 eb       	ldi	r22, 0xB3	; 179
    4f0e:	70 e5       	ldi	r23, 0x50	; 80
    4f10:	0e 94 e5 25 	call	0x4bca	; 0x4bca <findFiles>
    4f14:	08 95       	ret

00004f16 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4f16:	4f 92       	push	r4
    4f18:	5f 92       	push	r5
    4f1a:	6f 92       	push	r6
    4f1c:	7f 92       	push	r7
    4f1e:	af 92       	push	r10
    4f20:	bf 92       	push	r11
    4f22:	cf 92       	push	r12
    4f24:	df 92       	push	r13
    4f26:	ef 92       	push	r14
    4f28:	ff 92       	push	r15
    4f2a:	0f 93       	push	r16
    4f2c:	1f 93       	push	r17
    4f2e:	cf 93       	push	r28
    4f30:	c8 2f       	mov	r28, r24
    4f32:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4f34:	0e 94 05 24 	call	0x480a	; 0x480a <convertFileName>
if(error) return 2;
    4f38:	88 23       	and	r24, r24
    4f3a:	09 f0       	breq	.+2      	; 0x4f3e <readFile+0x28>
    4f3c:	57 c0       	rjmp	.+174    	; 0x4fec <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4f3e:	81 e0       	ldi	r24, 0x01	; 1
    4f40:	63 eb       	ldi	r22, 0xB3	; 179
    4f42:	70 e5       	ldi	r23, 0x50	; 80
    4f44:	0e 94 e5 25 	call	0x4bca	; 0x4bca <findFiles>
    4f48:	fc 01       	movw	r30, r24
if(dir == 0) 
    4f4a:	00 97       	sbiw	r24, 0x00	; 0
    4f4c:	31 f4       	brne	.+12     	; 0x4f5a <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4f4e:	81 e0       	ldi	r24, 0x01	; 1
    4f50:	cc 23       	and	r28, r28
    4f52:	09 f4       	brne	.+2      	; 0x4f56 <readFile+0x40>
    4f54:	4e c0       	rjmp	.+156    	; 0x4ff2 <readFile+0xdc>
    4f56:	80 e0       	ldi	r24, 0x00	; 0
    4f58:	4c c0       	rjmp	.+152    	; 0x4ff2 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4f5a:	c1 30       	cpi	r28, 0x01	; 1
    4f5c:	09 f4       	brne	.+2      	; 0x4f60 <readFile+0x4a>
    4f5e:	48 c0       	rjmp	.+144    	; 0x4ff0 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4f60:	44 88       	ldd	r4, Z+20	; 0x14
    4f62:	55 88       	ldd	r5, Z+21	; 0x15
    4f64:	66 24       	eor	r6, r6
    4f66:	77 24       	eor	r7, r7
    4f68:	32 01       	movw	r6, r4
    4f6a:	55 24       	eor	r5, r5
    4f6c:	44 24       	eor	r4, r4
    4f6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4f70:	93 8d       	ldd	r25, Z+27	; 0x1b
    4f72:	a0 e0       	ldi	r26, 0x00	; 0
    4f74:	b0 e0       	ldi	r27, 0x00	; 0
    4f76:	48 2a       	or	r4, r24
    4f78:	59 2a       	or	r5, r25
    4f7a:	6a 2a       	or	r6, r26
    4f7c:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4f7e:	0f 2e       	mov	r0, r31
    4f80:	ff ed       	ldi	r31, 0xDF	; 223
    4f82:	af 2e       	mov	r10, r31
    4f84:	f3 e2       	ldi	r31, 0x23	; 35
    4f86:	bf 2e       	mov	r11, r31
    4f88:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4f8a:	c3 01       	movw	r24, r6
    4f8c:	b2 01       	movw	r22, r4
    4f8e:	0e 94 bf 21 	call	0x437e	; 0x437e <getFirstSector>
    4f92:	6b 01       	movw	r12, r22
    4f94:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4f96:	80 91 7b 50 	lds	r24, 0x507B
    4f9a:	90 91 7c 50 	lds	r25, 0x507C
    4f9e:	00 97       	sbiw	r24, 0x00	; 0
    4fa0:	a1 f0       	breq	.+40     	; 0x4fca <readFile+0xb4>
    4fa2:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4fa4:	c7 01       	movw	r24, r14
    4fa6:	b6 01       	movw	r22, r12
    4fa8:	6c 0f       	add	r22, r28
    4faa:	71 1d       	adc	r23, r1
    4fac:	81 1d       	adc	r24, r1
    4fae:	91 1d       	adc	r25, r1
    4fb0:	a5 01       	movw	r20, r10
    4fb2:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4fb6:	cf 5f       	subi	r28, 0xFF	; 255
    4fb8:	80 91 7b 50 	lds	r24, 0x507B
    4fbc:	90 91 7c 50 	lds	r25, 0x507C
    4fc0:	2c 2f       	mov	r18, r28
    4fc2:	30 e0       	ldi	r19, 0x00	; 0
    4fc4:	28 17       	cp	r18, r24
    4fc6:	39 07       	cpc	r19, r25
    4fc8:	68 f3       	brcs	.-38     	; 0x4fa4 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4fca:	c3 01       	movw	r24, r6
    4fcc:	b2 01       	movw	r22, r4
    4fce:	40 e0       	ldi	r20, 0x00	; 0
    4fd0:	00 e0       	ldi	r16, 0x00	; 0
    4fd2:	10 e0       	ldi	r17, 0x00	; 0
    4fd4:	98 01       	movw	r18, r16
    4fd6:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
    4fda:	2b 01       	movw	r4, r22
    4fdc:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4fde:	61 15       	cp	r22, r1
    4fe0:	71 05       	cpc	r23, r1
    4fe2:	81 05       	cpc	r24, r1
    4fe4:	91 05       	cpc	r25, r1
    4fe6:	89 f6       	brne	.-94     	; 0x4f8a <readFile+0x74>
	  return 0;}
    4fe8:	80 e0       	ldi	r24, 0x00	; 0
    4fea:	03 c0       	rjmp	.+6      	; 0x4ff2 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4fec:	82 e0       	ldi	r24, 0x02	; 2
    4fee:	01 c0       	rjmp	.+2      	; 0x4ff2 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4ff0:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4ff2:	cf 91       	pop	r28
    4ff4:	1f 91       	pop	r17
    4ff6:	0f 91       	pop	r16
    4ff8:	ff 90       	pop	r15
    4ffa:	ef 90       	pop	r14
    4ffc:	df 90       	pop	r13
    4ffe:	cf 90       	pop	r12
    5000:	bf 90       	pop	r11
    5002:	af 90       	pop	r10
    5004:	7f 90       	pop	r7
    5006:	6f 90       	pop	r6
    5008:	5f 90       	pop	r5
    500a:	4f 90       	pop	r4
    500c:	08 95       	ret

0000500e <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    500e:	2f 92       	push	r2
    5010:	3f 92       	push	r3
    5012:	4f 92       	push	r4
    5014:	5f 92       	push	r5
    5016:	6f 92       	push	r6
    5018:	7f 92       	push	r7
    501a:	8f 92       	push	r8
    501c:	9f 92       	push	r9
    501e:	af 92       	push	r10
    5020:	bf 92       	push	r11
    5022:	cf 92       	push	r12
    5024:	df 92       	push	r13
    5026:	ef 92       	push	r14
    5028:	ff 92       	push	r15
    502a:	0f 93       	push	r16
    502c:	1f 93       	push	r17
    502e:	cf 93       	push	r28
    5030:	df 93       	push	r29
    5032:	cd b7       	in	r28, 0x3d	; 61
    5034:	de b7       	in	r29, 0x3e	; 62
    5036:	60 97       	sbiw	r28, 0x10	; 16
    5038:	cd bf       	out	0x3d, r28	; 61
    503a:	de bf       	out	0x3e, r29	; 62
    503c:	fc 01       	movw	r30, r24
    503e:	6d 83       	std	Y+5, r22	; 0x05
    5040:	7e 83       	std	Y+6, r23	; 0x06
    5042:	49 01       	movw	r8, r18
    5044:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    5046:	81 e0       	ldi	r24, 0x01	; 1
    5048:	bf 01       	movw	r22, r30
    504a:	0e 94 8b 27 	call	0x4f16	; 0x4f16 <readFile>

if(j == 1) 
    504e:	81 30       	cpi	r24, 0x01	; 1
    5050:	09 f0       	breq	.+2      	; 0x5054 <writeFile+0x46>
    5052:	7b c0       	rjmp	.+246    	; 0x514a <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    5054:	00 91 87 50 	lds	r16, 0x5087
    5058:	10 91 88 50 	lds	r17, 0x5088
    505c:	20 91 89 50 	lds	r18, 0x5089
    5060:	30 91 8a 50 	lds	r19, 0x508A
    5064:	09 83       	std	Y+1, r16	; 0x01
    5066:	1a 83       	std	Y+2, r17	; 0x02
    5068:	2b 83       	std	Y+3, r18	; 0x03
    506a:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    506c:	cc 24       	eor	r12, r12
    506e:	dd 24       	eor	r13, r13
    5070:	76 01       	movw	r14, r12
    5072:	24 01       	movw	r4, r8
    5074:	35 01       	movw	r6, r10
    5076:	48 01       	movw	r8, r16
    5078:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    507a:	c5 01       	movw	r24, r10
    507c:	b4 01       	movw	r22, r8
    507e:	40 e0       	ldi	r20, 0x00	; 0
    5080:	00 e0       	ldi	r16, 0x00	; 0
    5082:	10 e0       	ldi	r17, 0x00	; 0
    5084:	98 01       	movw	r18, r16
    5086:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
    508a:	dc 01       	movw	r26, r24
    508c:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    508e:	8f 3f       	cpi	r24, 0xFF	; 255
    5090:	1f ef       	ldi	r17, 0xFF	; 255
    5092:	91 07       	cpc	r25, r17
    5094:	1f ef       	ldi	r17, 0xFF	; 255
    5096:	a1 07       	cpc	r26, r17
    5098:	1f ef       	ldi	r17, 0xFF	; 255
    509a:	b1 07       	cpc	r27, r17
    509c:	41 f0       	breq	.+16     	; 0x50ae <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    509e:	08 94       	sec
    50a0:	c1 1c       	adc	r12, r1
    50a2:	d1 1c       	adc	r13, r1
    50a4:	e1 1c       	adc	r14, r1
    50a6:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    50a8:	4c 01       	movw	r8, r24
    50aa:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    50ac:	e6 cf       	rjmp	.-52     	; 0x507a <writeFile+0x6c>
    50ae:	89 82       	std	Y+1, r8	; 0x01
    50b0:	9a 82       	std	Y+2, r9	; 0x02
    50b2:	ab 82       	std	Y+3, r10	; 0x03
    50b4:	bc 82       	std	Y+4, r11	; 0x04
    50b6:	53 01       	movw	r10, r6
    50b8:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    50ba:	20 91 7b 50 	lds	r18, 0x507B
    50be:	30 91 7c 50 	lds	r19, 0x507C
    50c2:	80 91 54 40 	lds	r24, 0x4054
    50c6:	90 91 55 40 	lds	r25, 0x4055
    50ca:	60 90 54 40 	lds	r6, 0x4054
    50ce:	70 90 55 40 	lds	r7, 0x4055
    50d2:	bc 01       	movw	r22, r24
    50d4:	80 e0       	ldi	r24, 0x00	; 0
    50d6:	90 e0       	ldi	r25, 0x00	; 0
    50d8:	40 e0       	ldi	r20, 0x00	; 0
    50da:	50 e0       	ldi	r21, 0x00	; 0
    50dc:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    50e0:	a7 01       	movw	r20, r14
    50e2:	96 01       	movw	r18, r12
    50e4:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    50e8:	dc 01       	movw	r26, r24
    50ea:	cb 01       	movw	r24, r22
    50ec:	40 91 50 40 	lds	r20, 0x4050
    50f0:	50 91 51 40 	lds	r21, 0x4051
    50f4:	60 91 52 40 	lds	r22, 0x4052
    50f8:	70 91 53 40 	lds	r23, 0x4053
    50fc:	8a 01       	movw	r16, r20
    50fe:	9b 01       	movw	r18, r22
    5100:	08 1b       	sub	r16, r24
    5102:	19 0b       	sbc	r17, r25
    5104:	2a 0b       	sbc	r18, r26
    5106:	3b 0b       	sbc	r19, r27
    5108:	c9 01       	movw	r24, r18
    510a:	b8 01       	movw	r22, r16
    510c:	93 01       	movw	r18, r6
    510e:	40 e0       	ldi	r20, 0x00	; 0
    5110:	50 e0       	ldi	r21, 0x00	; 0
    5112:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    5116:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    5118:	69 81       	ldd	r22, Y+1	; 0x01
    511a:	7a 81       	ldd	r23, Y+2	; 0x02
    511c:	8b 81       	ldd	r24, Y+3	; 0x03
    511e:	9c 81       	ldd	r25, Y+4	; 0x04
    5120:	0e 94 bf 21 	call	0x437e	; 0x437e <getFirstSector>
    5124:	dc 01       	movw	r26, r24
    5126:	cb 01       	movw	r24, r22
    5128:	20 2e       	mov	r2, r16
    512a:	33 24       	eor	r3, r3
    512c:	28 0e       	add	r2, r24
    512e:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    5130:	b1 01       	movw	r22, r2
    5132:	80 e0       	ldi	r24, 0x00	; 0
    5134:	90 e0       	ldi	r25, 0x00	; 0
    5136:	46 ed       	ldi	r20, 0xD6	; 214
    5138:	51 e2       	ldi	r21, 0x21	; 33
    513a:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    513e:	1f 86       	std	Y+15, r1	; 0x0f
    5140:	18 8a       	std	Y+16, r1	; 0x10
    5142:	19 86       	std	Y+9, r1	; 0x09
    5144:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    5146:	11 e0       	ldi	r17, 0x01	; 1
    5148:	4c c0       	rjmp	.+152    	; 0x51e2 <writeFile+0x1d4>
}
else if(j == 2) 
    514a:	82 30       	cpi	r24, 0x02	; 2
    514c:	09 f4       	brne	.+2      	; 0x5150 <writeFile+0x142>
    514e:	0c c2       	rjmp	.+1048   	; 0x5568 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    5150:	82 e0       	ldi	r24, 0x02	; 2
    5152:	60 e0       	ldi	r22, 0x00	; 0
    5154:	20 e0       	ldi	r18, 0x00	; 0
    5156:	30 e0       	ldi	r19, 0x00	; 0
    5158:	a9 01       	movw	r20, r18
    515a:	0e 94 78 22 	call	0x44f0	; 0x44f0 <getSetFreeCluster>
  if(cluster > totalClusters)
    515e:	00 91 59 40 	lds	r16, 0x4059
    5162:	10 91 5a 40 	lds	r17, 0x405A
    5166:	20 91 5b 40 	lds	r18, 0x405B
    516a:	30 91 5c 40 	lds	r19, 0x405C
    516e:	06 17       	cp	r16, r22
    5170:	17 07       	cpc	r17, r23
    5172:	28 07       	cpc	r18, r24
    5174:	39 07       	cpc	r19, r25
    5176:	40 f4       	brcc	.+16     	; 0x5188 <writeFile+0x17a>
     cluster = rootCluster;
    5178:	60 91 5f 40 	lds	r22, 0x405F
    517c:	70 91 60 40 	lds	r23, 0x4060
    5180:	80 91 61 40 	lds	r24, 0x4061
    5184:	90 91 62 40 	lds	r25, 0x4062

  cluster = searchNextFreeCluster(cluster);
    5188:	0e 94 c4 24 	call	0x4988	; 0x4988 <searchNextFreeCluster>
    518c:	69 83       	std	Y+1, r22	; 0x01
    518e:	7a 83       	std	Y+2, r23	; 0x02
    5190:	8b 83       	std	Y+3, r24	; 0x03
    5192:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    5194:	61 15       	cp	r22, r1
    5196:	71 05       	cpc	r23, r1
    5198:	81 05       	cpc	r24, r1
    519a:	91 05       	cpc	r25, r1
    519c:	09 f4       	brne	.+2      	; 0x51a0 <writeFile+0x192>
    519e:	e6 c1       	rjmp	.+972    	; 0x556c <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    51a0:	41 e0       	ldi	r20, 0x01	; 1
    51a2:	0f ef       	ldi	r16, 0xFF	; 255
    51a4:	1f ef       	ldi	r17, 0xFF	; 255
    51a6:	98 01       	movw	r18, r16
    51a8:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    51ac:	2b 81       	ldd	r18, Y+3	; 0x03
    51ae:	3c 81       	ldd	r19, Y+4	; 0x04
    51b0:	29 87       	std	Y+9, r18	; 0x09
    51b2:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    51b4:	89 81       	ldd	r24, Y+1	; 0x01
    51b6:	9a 81       	ldd	r25, Y+2	; 0x02
    51b8:	8f 87       	std	Y+15, r24	; 0x0f
    51ba:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    51bc:	10 92 50 40 	sts	0x4050, r1
    51c0:	10 92 51 40 	sts	0x4051, r1
    51c4:	10 92 52 40 	sts	0x4052, r1
    51c8:	10 92 53 40 	sts	0x4053, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    51cc:	69 81       	ldd	r22, Y+1	; 0x01
    51ce:	7a 81       	ldd	r23, Y+2	; 0x02
    51d0:	8b 81       	ldd	r24, Y+3	; 0x03
    51d2:	9c 81       	ldd	r25, Y+4	; 0x04
    51d4:	0e 94 bf 21 	call	0x437e	; 0x437e <getFirstSector>
    51d8:	dc 01       	movw	r26, r24
    51da:	cb 01       	movw	r24, r22
    51dc:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    51de:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    51e0:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    51e2:	81 14       	cp	r8, r1
    51e4:	91 04       	cpc	r9, r1
    51e6:	a1 04       	cpc	r10, r1
    51e8:	b1 04       	cpc	r11, r1
    51ea:	09 f4       	brne	.+2      	; 0x51ee <writeFile+0x1e0>
    51ec:	8d c0       	rjmp	.+282    	; 0x5308 <writeFile+0x2fa>
    51ee:	44 24       	eor	r4, r4
    51f0:	55 24       	eor	r5, r5
    51f2:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    51f4:	c0 2e       	mov	r12, r16
    51f6:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    51f8:	90 e0       	ldi	r25, 0x00	; 0
    51fa:	89 16       	cp	r8, r25
    51fc:	92 e0       	ldi	r25, 0x02	; 2
    51fe:	99 06       	cpc	r9, r25
    5200:	90 e0       	ldi	r25, 0x00	; 0
    5202:	a9 06       	cpc	r10, r25
    5204:	90 e0       	ldi	r25, 0x00	; 0
    5206:	b9 06       	cpc	r11, r25
    5208:	88 f0       	brcs	.+34     	; 0x522c <writeFile+0x21e>
		 writtenData += 512;
    520a:	00 e0       	ldi	r16, 0x00	; 0
    520c:	12 e0       	ldi	r17, 0x02	; 2
    520e:	20 e0       	ldi	r18, 0x00	; 0
    5210:	30 e0       	ldi	r19, 0x00	; 0
    5212:	40 0e       	add	r4, r16
    5214:	51 1e       	adc	r5, r17
    5216:	62 1e       	adc	r6, r18
    5218:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    521a:	80 e0       	ldi	r24, 0x00	; 0
    521c:	9e ef       	ldi	r25, 0xFE	; 254
    521e:	af ef       	ldi	r26, 0xFF	; 255
    5220:	bf ef       	ldi	r27, 0xFF	; 255
    5222:	88 0e       	add	r8, r24
    5224:	99 1e       	adc	r9, r25
    5226:	aa 1e       	adc	r10, r26
    5228:	bb 1e       	adc	r11, r27
    522a:	0c c0       	rjmp	.+24     	; 0x5244 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    522c:	48 0c       	add	r4, r8
    522e:	59 1c       	adc	r5, r9
    5230:	6a 1c       	adc	r6, r10
    5232:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    5234:	95 01       	movw	r18, r10
    5236:	84 01       	movw	r16, r8
    5238:	11 70       	andi	r17, 0x01	; 1
    523a:	20 70       	andi	r18, 0x00	; 0
    523c:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    523e:	88 24       	eor	r8, r8
    5240:	99 24       	eor	r9, r9
    5242:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    5244:	80 91 50 40 	lds	r24, 0x4050
    5248:	90 91 51 40 	lds	r25, 0x4051
    524c:	a0 91 52 40 	lds	r26, 0x4052
    5250:	b0 91 53 40 	lds	r27, 0x4053
    5254:	80 50       	subi	r24, 0x00	; 0
    5256:	9e 4f       	sbci	r25, 0xFE	; 254
    5258:	af 4f       	sbci	r26, 0xFF	; 255
    525a:	bf 4f       	sbci	r27, 0xFF	; 255
    525c:	80 93 50 40 	sts	0x4050, r24
    5260:	90 93 51 40 	sts	0x4051, r25
    5264:	a0 93 52 40 	sts	0x4052, r26
    5268:	b0 93 53 40 	sts	0x4053, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    526c:	b1 01       	movw	r22, r2
    526e:	80 e0       	ldi	r24, 0x00	; 0
    5270:	90 e0       	ldi	r25, 0x00	; 0
    5272:	a2 01       	movw	r20, r4
    5274:	40 1b       	sub	r20, r16
    5276:	51 0b       	sbc	r21, r17
    5278:	ad 81       	ldd	r26, Y+5	; 0x05
    527a:	be 81       	ldd	r27, Y+6	; 0x06
    527c:	4a 0f       	add	r20, r26
    527e:	5b 1f       	adc	r21, r27
    5280:	98 01       	movw	r18, r16
    5282:	0e 94 1a 2c 	call	0x5834	; 0x5834 <SD_write_block>
	j++;
    5286:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    5288:	20 91 7b 50 	lds	r18, 0x507B
    528c:	30 91 7c 50 	lds	r19, 0x507C
    5290:	8c 2d       	mov	r24, r12
    5292:	90 e0       	ldi	r25, 0x00	; 0
    5294:	82 17       	cp	r24, r18
    5296:	93 07       	cpc	r25, r19
    5298:	29 f5       	brne	.+74     	; 0x52e4 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    529a:	69 81       	ldd	r22, Y+1	; 0x01
    529c:	7a 81       	ldd	r23, Y+2	; 0x02
    529e:	8b 81       	ldd	r24, Y+3	; 0x03
    52a0:	9c 81       	ldd	r25, Y+4	; 0x04
    52a2:	0e 94 c4 24 	call	0x4988	; 0x4988 <searchNextFreeCluster>
    52a6:	6b 01       	movw	r12, r22
    52a8:	7c 01       	movw	r14, r24
		if(cluster == 0){
    52aa:	61 15       	cp	r22, r1
    52ac:	71 05       	cpc	r23, r1
    52ae:	81 05       	cpc	r24, r1
    52b0:	91 05       	cpc	r25, r1
    52b2:	09 f4       	brne	.+2      	; 0x52b6 <writeFile+0x2a8>
    52b4:	5d c1       	rjmp	.+698    	; 0x5570 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    52b6:	69 81       	ldd	r22, Y+1	; 0x01
    52b8:	7a 81       	ldd	r23, Y+2	; 0x02
    52ba:	8b 81       	ldd	r24, Y+3	; 0x03
    52bc:	9c 81       	ldd	r25, Y+4	; 0x04
    52be:	41 e0       	ldi	r20, 0x01	; 1
    52c0:	97 01       	movw	r18, r14
    52c2:	86 01       	movw	r16, r12
    52c4:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    52c8:	c7 01       	movw	r24, r14
    52ca:	b6 01       	movw	r22, r12
    52cc:	41 e0       	ldi	r20, 0x01	; 1
    52ce:	0f ef       	ldi	r16, 0xFF	; 255
    52d0:	1f ef       	ldi	r17, 0xFF	; 255
    52d2:	98 01       	movw	r18, r16
    52d4:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    52d8:	c9 82       	std	Y+1, r12	; 0x01
    52da:	da 82       	std	Y+2, r13	; 0x02
    52dc:	eb 82       	std	Y+3, r14	; 0x03
    52de:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    52e0:	cc 24       	eor	r12, r12
    52e2:	03 c0       	rjmp	.+6      	; 0x52ea <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    52e4:	08 94       	sec
    52e6:	21 1c       	adc	r2, r1
    52e8:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    52ea:	82 e0       	ldi	r24, 0x02	; 2
    52ec:	61 e0       	ldi	r22, 0x01	; 1
    52ee:	29 81       	ldd	r18, Y+1	; 0x01
    52f0:	3a 81       	ldd	r19, Y+2	; 0x02
    52f2:	4b 81       	ldd	r20, Y+3	; 0x03
    52f4:	5c 81       	ldd	r21, Y+4	; 0x04
    52f6:	0e 94 78 22 	call	0x44f0	; 0x44f0 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    52fa:	81 14       	cp	r8, r1
    52fc:	91 04       	cpc	r9, r1
    52fe:	a1 04       	cpc	r10, r1
    5300:	b1 04       	cpc	r11, r1
    5302:	09 f0       	breq	.+2      	; 0x5306 <writeFile+0x2f8>
    5304:	79 cf       	rjmp	.-270    	; 0x51f8 <writeFile+0x1ea>
    5306:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    5308:	11 23       	and	r17, r17
    530a:	09 f4       	brne	.+2      	; 0x530e <writeFile+0x300>
    530c:	3f c0       	rjmp	.+126    	; 0x538c <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    530e:	60 91 c9 50 	lds	r22, 0x50C9
    5312:	70 91 ca 50 	lds	r23, 0x50CA
    5316:	80 91 cb 50 	lds	r24, 0x50CB
    531a:	90 91 cc 50 	lds	r25, 0x50CC
    531e:	06 ed       	ldi	r16, 0xD6	; 214
    5320:	11 e2       	ldi	r17, 0x21	; 33
    5322:	a8 01       	movw	r20, r16
    5324:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    5328:	e0 91 d7 23 	lds	r30, 0x23D7
    532c:	f0 91 d8 23 	lds	r31, 0x23D8
    5330:	e0 0f       	add	r30, r16
    5332:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    5334:	12 8a       	std	Z+18, r1	; 0x12
    5336:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    5338:	80 91 50 40 	lds	r24, 0x4050
    533c:	90 91 51 40 	lds	r25, 0x4051
    5340:	a0 91 52 40 	lds	r26, 0x4052
    5344:	b0 91 53 40 	lds	r27, 0x4053
    5348:	44 8d       	ldd	r20, Z+28	; 0x1c
    534a:	55 8d       	ldd	r21, Z+29	; 0x1d
    534c:	66 8d       	ldd	r22, Z+30	; 0x1e
    534e:	77 8d       	ldd	r23, Z+31	; 0x1f
    5350:	6c 01       	movw	r12, r24
    5352:	7d 01       	movw	r14, r26
    5354:	c4 1a       	sub	r12, r20
    5356:	d5 0a       	sbc	r13, r21
    5358:	e6 0a       	sbc	r14, r22
    535a:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    535c:	84 8f       	std	Z+28, r24	; 0x1c
    535e:	95 8f       	std	Z+29, r25	; 0x1d
    5360:	a6 8f       	std	Z+30, r26	; 0x1e
    5362:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    5364:	60 91 c9 50 	lds	r22, 0x50C9
    5368:	70 91 ca 50 	lds	r23, 0x50CA
    536c:	80 91 cb 50 	lds	r24, 0x50CB
    5370:	90 91 cc 50 	lds	r25, 0x50CC
    5374:	a8 01       	movw	r20, r16
    5376:	20 e0       	ldi	r18, 0x00	; 0
    5378:	32 e0       	ldi	r19, 0x02	; 2
    537a:	0e 94 1a 2c 	call	0x5834	; 0x5834 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    537e:	81 e0       	ldi	r24, 0x01	; 1
    5380:	b7 01       	movw	r22, r14
    5382:	a6 01       	movw	r20, r12
    5384:	0e 94 77 25 	call	0x4aee	; 0x4aee <freeMemoryUpdate>

 //File appended!
  return 0;
    5388:	80 e0       	ldi	r24, 0x00	; 0
    538a:	f9 c0       	rjmp	.+498    	; 0x557e <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    538c:	00 91 5f 40 	lds	r16, 0x405F
    5390:	10 91 60 40 	lds	r17, 0x4060
    5394:	20 91 61 40 	lds	r18, 0x4061
    5398:	30 91 62 40 	lds	r19, 0x4062
    539c:	0b 87       	std	Y+11, r16	; 0x0b
    539e:	1c 87       	std	Y+12, r17	; 0x0c
    53a0:	2d 87       	std	Y+13, r18	; 0x0d
    53a2:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    53a4:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    53a6:	83 eb       	ldi	r24, 0xB3	; 179
    53a8:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    53aa:	0f 2e       	mov	r0, r31
    53ac:	fb e0       	ldi	r31, 0x0B	; 11
    53ae:	af 2e       	mov	r10, r31
    53b0:	bb 24       	eor	r11, r11
    53b2:	f0 2d       	mov	r31, r0
    53b4:	a8 0e       	add	r10, r24
    53b6:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    53b8:	88 24       	eor	r8, r8
    53ba:	68 94       	set
    53bc:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    53be:	0f 2e       	mov	r0, r31
    53c0:	f6 ed       	ldi	r31, 0xD6	; 214
    53c2:	4f 2e       	mov	r4, r31
    53c4:	f1 e2       	ldi	r31, 0x21	; 33
    53c6:	5f 2e       	mov	r5, r31
    53c8:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    53ca:	28 2e       	mov	r2, r24
    53cc:	99 2e       	mov	r9, r25
    53ce:	37 2c       	mov	r3, r7
    53d0:	6f 84       	ldd	r6, Y+15	; 0x0f
    53d2:	78 88       	ldd	r7, Y+16	; 0x10
    53d4:	04 c0       	rjmp	.+8      	; 0x53de <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    53d6:	cb 86       	std	Y+11, r12	; 0x0b
    53d8:	dc 86       	std	Y+12, r13	; 0x0c
    53da:	ed 86       	std	Y+13, r14	; 0x0d
    53dc:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    53de:	6b 85       	ldd	r22, Y+11	; 0x0b
    53e0:	7c 85       	ldd	r23, Y+12	; 0x0c
    53e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    53e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    53e6:	0e 94 bf 21 	call	0x437e	; 0x437e <getFirstSector>
    53ea:	6d 83       	std	Y+5, r22	; 0x05
    53ec:	7e 83       	std	Y+6, r23	; 0x06
    53ee:	8f 83       	std	Y+7, r24	; 0x07
    53f0:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    53f2:	80 91 7b 50 	lds	r24, 0x507B
    53f6:	90 91 7c 50 	lds	r25, 0x507C
    53fa:	00 97       	sbiw	r24, 0x00	; 0
    53fc:	09 f4       	brne	.+2      	; 0x5400 <writeFile+0x3f2>
    53fe:	77 c0       	rjmp	.+238    	; 0x54ee <writeFile+0x4e0>
    5400:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5402:	cd 80       	ldd	r12, Y+5	; 0x05
    5404:	de 80       	ldd	r13, Y+6	; 0x06
    5406:	ef 80       	ldd	r14, Y+7	; 0x07
    5408:	f8 84       	ldd	r15, Y+8	; 0x08
    540a:	19 81       	ldd	r17, Y+1	; 0x01
    540c:	c1 0e       	add	r12, r17
    540e:	d1 1c       	adc	r13, r1
    5410:	e1 1c       	adc	r14, r1
    5412:	f1 1c       	adc	r15, r1
    5414:	c7 01       	movw	r24, r14
    5416:	b6 01       	movw	r22, r12
    5418:	a2 01       	movw	r20, r4
    541a:	0e 94 cf 2c 	call	0x599e	; 0x599e <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    541e:	80 91 54 40 	lds	r24, 0x4054
    5422:	90 91 55 40 	lds	r25, 0x4055
    5426:	00 97       	sbiw	r24, 0x00	; 0
    5428:	09 f4       	brne	.+2      	; 0x542c <writeFile+0x41e>
    542a:	54 c0       	rjmp	.+168    	; 0x54d4 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    542c:	33 20       	and	r3, r3
    542e:	09 f0       	breq	.+2      	; 0x5432 <writeFile+0x424>
    5430:	a1 c0       	rjmp	.+322    	; 0x5574 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    5432:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5434:	00 e0       	ldi	r16, 0x00	; 0
    5436:	10 e0       	ldi	r17, 0x00	; 0
    5438:	06 c0       	rjmp	.+12     	; 0x5446 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    543a:	a8 01       	movw	r20, r16
    543c:	4a 52       	subi	r20, 0x2A	; 42
    543e:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    5440:	22 23       	and	r18, r18
    5442:	09 f0       	breq	.+2      	; 0x5446 <writeFile+0x438>
    5444:	99 c0       	rjmp	.+306    	; 0x5578 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5446:	da 01       	movw	r26, r20
    5448:	8c 91       	ld	r24, X
    544a:	88 23       	and	r24, r24
    544c:	21 f4       	brne	.+8      	; 0x5456 <writeFile+0x448>
    544e:	e2 2d       	mov	r30, r2
    5450:	f9 2d       	mov	r31, r9
    5452:	da 01       	movw	r26, r20
    5454:	04 c0       	rjmp	.+8      	; 0x545e <writeFile+0x450>
    5456:	85 3e       	cpi	r24, 0xE5	; 229
    5458:	d1 f3       	breq	.-12     	; 0x544e <writeFile+0x440>
    545a:	23 2d       	mov	r18, r3
    545c:	30 c0       	rjmp	.+96     	; 0x54be <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    545e:	81 91       	ld	r24, Z+
    5460:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    5462:	ea 15       	cp	r30, r10
    5464:	fb 05       	cpc	r31, r11
    5466:	d9 f7       	brne	.-10     	; 0x545e <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    5468:	fa 01       	movw	r30, r20
    546a:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    546c:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    546e:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    5470:	12 8a       	std	Z+18, r1	; 0x12
    5472:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    5474:	29 85       	ldd	r18, Y+9	; 0x09
    5476:	3a 85       	ldd	r19, Y+10	; 0x0a
    5478:	24 8b       	std	Z+20, r18	; 0x14
    547a:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    547c:	62 8e       	std	Z+26, r6	; 0x1a
    547e:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    5480:	80 91 50 40 	lds	r24, 0x4050
    5484:	90 91 51 40 	lds	r25, 0x4051
    5488:	a0 91 52 40 	lds	r26, 0x4052
    548c:	b0 91 53 40 	lds	r27, 0x4053
    5490:	84 8f       	std	Z+28, r24	; 0x1c
    5492:	95 8f       	std	Z+29, r25	; 0x1d
    5494:	a6 8f       	std	Z+30, r26	; 0x1e
    5496:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    5498:	c7 01       	movw	r24, r14
    549a:	b6 01       	movw	r22, r12
    549c:	a2 01       	movw	r20, r4
    549e:	20 e0       	ldi	r18, 0x00	; 0
    54a0:	32 e0       	ldi	r19, 0x02	; 2
    54a2:	0e 94 1a 2c 	call	0x5834	; 0x5834 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    54a6:	40 91 50 40 	lds	r20, 0x4050
    54aa:	50 91 51 40 	lds	r21, 0x4051
    54ae:	60 91 52 40 	lds	r22, 0x4052
    54b2:	70 91 53 40 	lds	r23, 0x4053
    54b6:	81 e0       	ldi	r24, 0x01	; 1
    54b8:	0e 94 77 25 	call	0x4aee	; 0x4aee <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    54bc:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    54be:	00 5e       	subi	r16, 0xE0	; 224
    54c0:	1f 4f       	sbci	r17, 0xFF	; 255
    54c2:	80 91 54 40 	lds	r24, 0x4054
    54c6:	90 91 55 40 	lds	r25, 0x4055
    54ca:	08 17       	cp	r16, r24
    54cc:	19 07       	cpc	r17, r25
    54ce:	08 f4       	brcc	.+2      	; 0x54d2 <writeFile+0x4c4>
    54d0:	b4 cf       	rjmp	.-152    	; 0x543a <writeFile+0x42c>
    54d2:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    54d4:	09 81       	ldd	r16, Y+1	; 0x01
    54d6:	0f 5f       	subi	r16, 0xFF	; 255
    54d8:	09 83       	std	Y+1, r16	; 0x01
    54da:	20 91 7b 50 	lds	r18, 0x507B
    54de:	30 91 7c 50 	lds	r19, 0x507C
    54e2:	80 2f       	mov	r24, r16
    54e4:	90 e0       	ldi	r25, 0x00	; 0
    54e6:	82 17       	cp	r24, r18
    54e8:	93 07       	cpc	r25, r19
    54ea:	08 f4       	brcc	.+2      	; 0x54ee <writeFile+0x4e0>
    54ec:	8a cf       	rjmp	.-236    	; 0x5402 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    54ee:	6b 85       	ldd	r22, Y+11	; 0x0b
    54f0:	7c 85       	ldd	r23, Y+12	; 0x0c
    54f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    54f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    54f6:	40 e0       	ldi	r20, 0x00	; 0
    54f8:	00 e0       	ldi	r16, 0x00	; 0
    54fa:	10 e0       	ldi	r17, 0x00	; 0
    54fc:	98 01       	movw	r18, r16
    54fe:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
    5502:	6b 01       	movw	r12, r22
    5504:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5506:	67 3f       	cpi	r22, 0xF7	; 247
    5508:	1f ef       	ldi	r17, 0xFF	; 255
    550a:	71 07       	cpc	r23, r17
    550c:	1f ef       	ldi	r17, 0xFF	; 255
    550e:	81 07       	cpc	r24, r17
    5510:	1f e0       	ldi	r17, 0x0F	; 15
    5512:	91 07       	cpc	r25, r17
    5514:	08 f1       	brcs	.+66     	; 0x5558 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    5516:	6f 3f       	cpi	r22, 0xFF	; 255
    5518:	2f ef       	ldi	r18, 0xFF	; 255
    551a:	72 07       	cpc	r23, r18
    551c:	2f ef       	ldi	r18, 0xFF	; 255
    551e:	82 07       	cpc	r24, r18
    5520:	2f ef       	ldi	r18, 0xFF	; 255
    5522:	92 07       	cpc	r25, r18
    5524:	59 f5       	brne	.+86     	; 0x557c <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    5526:	6b 85       	ldd	r22, Y+11	; 0x0b
    5528:	7c 85       	ldd	r23, Y+12	; 0x0c
    552a:	8d 85       	ldd	r24, Y+13	; 0x0d
    552c:	9e 85       	ldd	r25, Y+14	; 0x0e
    552e:	0e 94 c4 24 	call	0x4988	; 0x4988 <searchNextFreeCluster>
    5532:	6b 01       	movw	r12, r22
    5534:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    5536:	6b 85       	ldd	r22, Y+11	; 0x0b
    5538:	7c 85       	ldd	r23, Y+12	; 0x0c
    553a:	8d 85       	ldd	r24, Y+13	; 0x0d
    553c:	9e 85       	ldd	r25, Y+14	; 0x0e
    553e:	41 e0       	ldi	r20, 0x01	; 1
    5540:	97 01       	movw	r18, r14
    5542:	86 01       	movw	r16, r12
    5544:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    5548:	c7 01       	movw	r24, r14
    554a:	b6 01       	movw	r22, r12
    554c:	41 e0       	ldi	r20, 0x01	; 1
    554e:	0f ef       	ldi	r16, 0xFF	; 255
    5550:	1f ef       	ldi	r17, 0xFF	; 255
    5552:	98 01       	movw	r18, r16
    5554:	0e 94 e6 21 	call	0x43cc	; 0x43cc <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    5558:	c1 14       	cp	r12, r1
    555a:	d1 04       	cpc	r13, r1
    555c:	e1 04       	cpc	r14, r1
    555e:	f1 04       	cpc	r15, r1
    5560:	09 f0       	breq	.+2      	; 0x5564 <writeFile+0x556>
    5562:	39 cf       	rjmp	.-398    	; 0x53d6 <writeFile+0x3c8>
	   return 4;
    5564:	84 e0       	ldi	r24, 0x04	; 4
    5566:	0b c0       	rjmp	.+22     	; 0x557e <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    5568:	81 e0       	ldi	r24, 0x01	; 1
    556a:	09 c0       	rjmp	.+18     	; 0x557e <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    556c:	82 e0       	ldi	r24, 0x02	; 2
    556e:	07 c0       	rjmp	.+14     	; 0x557e <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    5570:	82 e0       	ldi	r24, 0x02	; 2
    5572:	05 c0       	rjmp	.+10     	; 0x557e <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    5574:	80 e0       	ldi	r24, 0x00	; 0
    5576:	03 c0       	rjmp	.+6      	; 0x557e <writeFile+0x570>
    5578:	80 e0       	ldi	r24, 0x00	; 0
    557a:	01 c0       	rjmp	.+2      	; 0x557e <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    557c:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    557e:	60 96       	adiw	r28, 0x10	; 16
    5580:	cd bf       	out	0x3d, r28	; 61
    5582:	de bf       	out	0x3e, r29	; 62
    5584:	df 91       	pop	r29
    5586:	cf 91       	pop	r28
    5588:	1f 91       	pop	r17
    558a:	0f 91       	pop	r16
    558c:	ff 90       	pop	r15
    558e:	ef 90       	pop	r14
    5590:	df 90       	pop	r13
    5592:	cf 90       	pop	r12
    5594:	bf 90       	pop	r11
    5596:	af 90       	pop	r10
    5598:	9f 90       	pop	r9
    559a:	8f 90       	pop	r8
    559c:	7f 90       	pop	r7
    559e:	6f 90       	pop	r6
    55a0:	5f 90       	pop	r5
    55a2:	4f 90       	pop	r4
    55a4:	3f 90       	pop	r3
    55a6:	2f 90       	pop	r2
    55a8:	08 95       	ret

000055aa <SPI_write>:
}	

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    55aa:	e0 ec       	ldi	r30, 0xC0	; 192
    55ac:	f8 e0       	ldi	r31, 0x08	; 8
    55ae:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    55b0:	82 81       	ldd	r24, Z+2	; 0x02
    55b2:	88 23       	and	r24, r24
    55b4:	ec f7       	brge	.-6      	; 0x55b0 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    55b6:	e0 ec       	ldi	r30, 0xC0	; 192
    55b8:	f8 e0       	ldi	r31, 0x08	; 8
    55ba:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    55bc:	08 95       	ret

000055be <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    55be:	8f 92       	push	r8
    55c0:	9f 92       	push	r9
    55c2:	af 92       	push	r10
    55c4:	bf 92       	push	r11
    55c6:	cf 92       	push	r12
    55c8:	df 92       	push	r13
    55ca:	ef 92       	push	r14
    55cc:	ff 92       	push	r15
    55ce:	0f 93       	push	r16
    55d0:	1f 93       	push	r17
    55d2:	cf 93       	push	r28
    55d4:	df 93       	push	r29
    55d6:	84 2e       	mov	r8, r20
    55d8:	a5 2e       	mov	r10, r21
    55da:	c6 2e       	mov	r12, r22
    55dc:	c7 2f       	mov	r28, r23
    55de:	d2 2f       	mov	r29, r18
    55e0:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    55e2:	80 64       	ori	r24, 0x40	; 64
    55e4:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    55e8:	8c 2f       	mov	r24, r28
    55ea:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    55ee:	8c 2d       	mov	r24, r12
    55f0:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    55f4:	8a 2d       	mov	r24, r10
    55f6:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    55fa:	88 2d       	mov	r24, r8
    55fc:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
	SPI_write(crc);
    5600:	8d 2f       	mov	r24, r29
    5602:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
	
	for(int i=0; i<read; i++){
    5606:	10 16       	cp	r1, r16
    5608:	11 06       	cpc	r1, r17
    560a:	64 f5       	brge	.+88     	; 0x5664 <SD_command+0xa6>
    560c:	00 e0       	ldi	r16, 0x00	; 0
    560e:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    5610:	0f 2e       	mov	r0, r31
    5612:	fd e0       	ldi	r31, 0x0D	; 13
    5614:	cf 2e       	mov	r12, r31
    5616:	dd 24       	eor	r13, r13
    5618:	f0 2d       	mov	r31, r0
    561a:	0f 2e       	mov	r0, r31
    561c:	f6 ea       	ldi	r31, 0xA6	; 166
    561e:	af 2e       	mov	r10, r31
    5620:	f0 e5       	ldi	r31, 0x50	; 80
    5622:	bf 2e       	mov	r11, r31
    5624:	f0 2d       	mov	r31, r0
    5626:	c8 01       	movw	r24, r16
    5628:	b6 01       	movw	r22, r12
    562a:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    562e:	ec 01       	movw	r28, r24
    5630:	8f ef       	ldi	r24, 0xFF	; 255
    5632:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5636:	f5 01       	movw	r30, r10
    5638:	ec 0f       	add	r30, r28
    563a:	fd 1f       	adc	r31, r29
    563c:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    563e:	80 81       	ld	r24, Z
    5640:	8f 3f       	cpi	r24, 0xFF	; 255
    5642:	49 f0       	breq	.+18     	; 0x5656 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    5644:	fe 01       	movw	r30, r28
    5646:	ea 55       	subi	r30, 0x5A	; 90
    5648:	ff 4a       	sbci	r31, 0xAF	; 175
    564a:	80 81       	ld	r24, Z
    564c:	80 93 a7 50 	sts	0x50A7, r24
			return Buffer[1];
    5650:	80 91 a7 50 	lds	r24, 0x50A7
    5654:	08 c0       	rjmp	.+16     	; 0x5666 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    5656:	0f 5f       	subi	r16, 0xFF	; 255
    5658:	1f 4f       	sbci	r17, 0xFF	; 255
    565a:	0e 15       	cp	r16, r14
    565c:	1f 05       	cpc	r17, r15
    565e:	19 f7       	brne	.-58     	; 0x5626 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    5660:	8f ef       	ldi	r24, 0xFF	; 255
    5662:	01 c0       	rjmp	.+2      	; 0x5666 <SD_command+0xa8>
    5664:	8f ef       	ldi	r24, 0xFF	; 255
}
    5666:	df 91       	pop	r29
    5668:	cf 91       	pop	r28
    566a:	1f 91       	pop	r17
    566c:	0f 91       	pop	r16
    566e:	ff 90       	pop	r15
    5670:	ef 90       	pop	r14
    5672:	df 90       	pop	r13
    5674:	cf 90       	pop	r12
    5676:	bf 90       	pop	r11
    5678:	af 90       	pop	r10
    567a:	9f 90       	pop	r9
    567c:	8f 90       	pop	r8
    567e:	08 95       	ret

00005680 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    5680:	ff 92       	push	r15
    5682:	0f 93       	push	r16
    5684:	1f 93       	push	r17
    5686:	cf 93       	push	r28
    5688:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    568a:	81 e0       	ldi	r24, 0x01	; 1
    568c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    5690:	81 e0       	ldi	r24, 0x01	; 1
    5692:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <Ext1Power>
    5696:	8f ef       	ldi	r24, 0xFF	; 255
    5698:	93 ec       	ldi	r25, 0xC3	; 195
    569a:	a9 e0       	ldi	r26, 0x09	; 9
    569c:	81 50       	subi	r24, 0x01	; 1
    569e:	90 40       	sbci	r25, 0x00	; 0
    56a0:	a0 40       	sbci	r26, 0x00	; 0
    56a2:	e1 f7       	brne	.-8      	; 0x569c <SD_init+0x1c>
    56a4:	00 c0       	rjmp	.+0      	; 0x56a6 <SD_init+0x26>
    56a6:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    56a8:	88 e0       	ldi	r24, 0x08	; 8
    56aa:	60 e0       	ldi	r22, 0x00	; 0
    56ac:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    56b0:	88 e0       	ldi	r24, 0x08	; 8
    56b2:	60 e0       	ldi	r22, 0x00	; 0
    56b4:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    56b8:	80 e0       	ldi	r24, 0x00	; 0
    56ba:	63 e0       	ldi	r22, 0x03	; 3
    56bc:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <SPIInit2>
	SPICS(TRUE);
    56c0:	81 e0       	ldi	r24, 0x01	; 1
    56c2:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
    56c6:	8a e0       	ldi	r24, 0x0A	; 10
    56c8:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    56ca:	e0 ec       	ldi	r30, 0xC0	; 192
    56cc:	f8 e0       	ldi	r31, 0x08	; 8
    56ce:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    56d0:	a2 eb       	ldi	r26, 0xB2	; 178
    56d2:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    56d4:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    56d6:	22 81       	ldd	r18, Z+2	; 0x02
    56d8:	22 23       	and	r18, r18
    56da:	ec f7       	brge	.-6      	; 0x56d6 <SD_init+0x56>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    56dc:	23 81       	ldd	r18, Z+3	; 0x03
    56de:	2c 93       	st	X, r18
    56e0:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    56e2:	c1 f7       	brne	.-16     	; 0x56d4 <SD_init+0x54>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    56e4:	80 e0       	ldi	r24, 0x00	; 0
    56e6:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    56ea:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    56ee:	88 e0       	ldi	r24, 0x08	; 8
    56f0:	60 e0       	ldi	r22, 0x00	; 0
    56f2:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    56f6:	80 e0       	ldi	r24, 0x00	; 0
    56f8:	63 e0       	ldi	r22, 0x03	; 3
    56fa:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <SPIInit2>
	SPICS(TRUE);
    56fe:	81 e0       	ldi	r24, 0x01	; 1
    5700:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    5704:	cb e0       	ldi	r28, 0x0B	; 11
    5706:	d0 e0       	ldi	r29, 0x00	; 0
    5708:	02 c0       	rjmp	.+4      	; 0x570e <SD_init+0x8e>
    570a:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    570c:	69 f0       	breq	.+26     	; 0x5728 <SD_init+0xa8>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    570e:	80 e0       	ldi	r24, 0x00	; 0
    5710:	40 e0       	ldi	r20, 0x00	; 0
    5712:	50 e0       	ldi	r21, 0x00	; 0
    5714:	ba 01       	movw	r22, r20
    5716:	25 e9       	ldi	r18, 0x95	; 149
    5718:	08 e0       	ldi	r16, 0x08	; 8
    571a:	10 e0       	ldi	r17, 0x00	; 0
    571c:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
    5720:	81 30       	cpi	r24, 0x01	; 1
    5722:	99 f7       	brne	.-26     	; 0x570a <SD_init+0x8a>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    5724:	ff 24       	eor	r15, r15
    5726:	02 c0       	rjmp	.+4      	; 0x572c <SD_init+0xac>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    5728:	ff 24       	eor	r15, r15
    572a:	f3 94       	inc	r15
    572c:	8f ef       	ldi	r24, 0xFF	; 255
    572e:	93 ec       	ldi	r25, 0xC3	; 195
    5730:	a9 e0       	ldi	r26, 0x09	; 9
    5732:	81 50       	subi	r24, 0x01	; 1
    5734:	90 40       	sbci	r25, 0x00	; 0
    5736:	a0 40       	sbci	r26, 0x00	; 0
    5738:	e1 f7       	brne	.-8      	; 0x5732 <SD_init+0xb2>
    573a:	00 c0       	rjmp	.+0      	; 0x573c <SD_init+0xbc>
    573c:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    573e:	cb e0       	ldi	r28, 0x0B	; 11
    5740:	d0 e0       	ldi	r29, 0x00	; 0
    5742:	02 c0       	rjmp	.+4      	; 0x5748 <SD_init+0xc8>
    5744:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5746:	69 f0       	breq	.+26     	; 0x5762 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    5748:	88 e0       	ldi	r24, 0x08	; 8
    574a:	4a ea       	ldi	r20, 0xAA	; 170
    574c:	51 e0       	ldi	r21, 0x01	; 1
    574e:	60 e0       	ldi	r22, 0x00	; 0
    5750:	70 e0       	ldi	r23, 0x00	; 0
    5752:	27 e8       	ldi	r18, 0x87	; 135
    5754:	08 e0       	ldi	r16, 0x08	; 8
    5756:	10 e0       	ldi	r17, 0x00	; 0
    5758:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
    575c:	81 30       	cpi	r24, 0x01	; 1
    575e:	91 f7       	brne	.-28     	; 0x5744 <SD_init+0xc4>
    5760:	02 c0       	rjmp	.+4      	; 0x5766 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5762:	ff 24       	eor	r15, r15
    5764:	f3 94       	inc	r15
    5766:	c2 e0       	ldi	r28, 0x02	; 2
    5768:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    576a:	06 ea       	ldi	r16, 0xA6	; 166
    576c:	10 e5       	ldi	r17, 0x50	; 80
    576e:	8f ef       	ldi	r24, 0xFF	; 255
    5770:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5774:	f8 01       	movw	r30, r16
    5776:	ec 0f       	add	r30, r28
    5778:	fd 1f       	adc	r31, r29
    577a:	80 83       	st	Z, r24
    577c:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    577e:	c6 30       	cpi	r28, 0x06	; 6
    5780:	d1 05       	cpc	r29, r1
    5782:	a9 f7       	brne	.-22     	; 0x576e <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    5784:	80 91 aa 50 	lds	r24, 0x50AA
    5788:	81 30       	cpi	r24, 0x01	; 1
    578a:	29 f4       	brne	.+10     	; 0x5796 <SD_init+0x116>
    578c:	80 91 ab 50 	lds	r24, 0x50AB
    5790:	8a 3a       	cpi	r24, 0xAA	; 170
    5792:	21 f4       	brne	.+8      	; 0x579c <SD_init+0x11c>
    5794:	05 c0       	rjmp	.+10     	; 0x57a0 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    5796:	ff 24       	eor	r15, r15
    5798:	f3 94       	inc	r15
    579a:	02 c0       	rjmp	.+4      	; 0x57a0 <SD_init+0x120>
    579c:	ff 24       	eor	r15, r15
    579e:	f3 94       	inc	r15
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    57a0:	c7 ea       	ldi	r28, 0xA7	; 167
    57a2:	d0 e5       	ldi	r29, 0x50	; 80
		//broken card or voltage out of operating range bounds
		errorCode = 1;
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    57a4:	87 e3       	ldi	r24, 0x37	; 55
    57a6:	40 e0       	ldi	r20, 0x00	; 0
    57a8:	50 e0       	ldi	r21, 0x00	; 0
    57aa:	ba 01       	movw	r22, r20
    57ac:	2f ef       	ldi	r18, 0xFF	; 255
    57ae:	08 e0       	ldi	r16, 0x08	; 8
    57b0:	10 e0       	ldi	r17, 0x00	; 0
    57b2:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    57b6:	81 e0       	ldi	r24, 0x01	; 1
    57b8:	40 e0       	ldi	r20, 0x00	; 0
    57ba:	50 e0       	ldi	r21, 0x00	; 0
    57bc:	60 e0       	ldi	r22, 0x00	; 0
    57be:	70 e4       	ldi	r23, 0x40	; 64
    57c0:	2f ef       	ldi	r18, 0xFF	; 255
    57c2:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
	} while(Buffer[1]!= 0x00);
    57c6:	88 81       	ld	r24, Y
    57c8:	88 23       	and	r24, r24
    57ca:	61 f7       	brne	.-40     	; 0x57a4 <SD_init+0x124>
    57cc:	cb e0       	ldi	r28, 0x0B	; 11
    57ce:	d0 e0       	ldi	r29, 0x00	; 0
    57d0:	02 c0       	rjmp	.+4      	; 0x57d6 <SD_init+0x156>
    57d2:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    57d4:	61 f0       	breq	.+24     	; 0x57ee <SD_init+0x16e>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    57d6:	8a e3       	ldi	r24, 0x3A	; 58
    57d8:	40 e0       	ldi	r20, 0x00	; 0
    57da:	50 e0       	ldi	r21, 0x00	; 0
    57dc:	ba 01       	movw	r22, r20
    57de:	2f ef       	ldi	r18, 0xFF	; 255
    57e0:	08 e0       	ldi	r16, 0x08	; 8
    57e2:	10 e0       	ldi	r17, 0x00	; 0
    57e4:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
    57e8:	88 23       	and	r24, r24
    57ea:	99 f7       	brne	.-26     	; 0x57d2 <SD_init+0x152>
    57ec:	02 c0       	rjmp	.+4      	; 0x57f2 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    57ee:	ff 24       	eor	r15, r15
    57f0:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    57f2:	c0 e0       	ldi	r28, 0x00	; 0
    57f4:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    57f6:	06 ea       	ldi	r16, 0xA6	; 166
    57f8:	10 e5       	ldi	r17, 0x50	; 80
    57fa:	8f ef       	ldi	r24, 0xFF	; 255
    57fc:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5800:	f8 01       	movw	r30, r16
    5802:	ec 0f       	add	r30, r28
    5804:	fd 1f       	adc	r31, r29
    5806:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5808:	21 96       	adiw	r28, 0x01	; 1
    580a:	c4 30       	cpi	r28, 0x04	; 4
    580c:	d1 05       	cpc	r29, r1
    580e:	a9 f7       	brne	.-22     	; 0x57fa <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5810:	80 91 a6 50 	lds	r24, 0x50A6
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    5814:	80 e0       	ldi	r24, 0x00	; 0
    5816:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    581a:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    581e:	88 e0       	ldi	r24, 0x08	; 8
    5820:	60 e0       	ldi	r22, 0x00	; 0
    5822:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
	return errorCode;	
}	
    5826:	8f 2d       	mov	r24, r15
    5828:	df 91       	pop	r29
    582a:	cf 91       	pop	r28
    582c:	1f 91       	pop	r17
    582e:	0f 91       	pop	r16
    5830:	ff 90       	pop	r15
    5832:	08 95       	ret

00005834 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    5834:	6f 92       	push	r6
    5836:	7f 92       	push	r7
    5838:	8f 92       	push	r8
    583a:	9f 92       	push	r9
    583c:	af 92       	push	r10
    583e:	bf 92       	push	r11
    5840:	cf 92       	push	r12
    5842:	df 92       	push	r13
    5844:	ef 92       	push	r14
    5846:	ff 92       	push	r15
    5848:	0f 93       	push	r16
    584a:	1f 93       	push	r17
    584c:	cf 93       	push	r28
    584e:	df 93       	push	r29
    5850:	4b 01       	movw	r8, r22
    5852:	5c 01       	movw	r10, r24
    5854:	74 2e       	mov	r7, r20
    5856:	65 2e       	mov	r6, r21
    5858:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    585a:	88 e0       	ldi	r24, 0x08	; 8
    585c:	60 e0       	ldi	r22, 0x00	; 0
    585e:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5862:	80 e0       	ldi	r24, 0x00	; 0
    5864:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    5868:	81 e0       	ldi	r24, 0x01	; 1
    586a:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    586e:	80 e0       	ldi	r24, 0x00	; 0
    5870:	92 e0       	ldi	r25, 0x02	; 2
    5872:	7c 01       	movw	r14, r24
    5874:	ec 18       	sub	r14, r12
    5876:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5878:	80 e0       	ldi	r24, 0x00	; 0
    587a:	e8 16       	cp	r14, r24
    587c:	82 e0       	ldi	r24, 0x02	; 2
    587e:	f8 06       	cpc	r15, r24
    5880:	11 f4       	brne	.+4      	; 0x5886 <SD_write_block+0x52>
    5882:	ee 24       	eor	r14, r14
    5884:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5886:	cb e0       	ldi	r28, 0x0B	; 11
    5888:	d0 e0       	ldi	r29, 0x00	; 0
    588a:	03 c0       	rjmp	.+6      	; 0x5892 <SD_write_block+0x5e>
    588c:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    588e:	09 f4       	brne	.+2      	; 0x5892 <SD_write_block+0x5e>
    5890:	ff cf       	rjmp	.-2      	; 0x5890 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5892:	88 e1       	ldi	r24, 0x18	; 24
    5894:	b5 01       	movw	r22, r10
    5896:	a4 01       	movw	r20, r8
    5898:	2f ef       	ldi	r18, 0xFF	; 255
    589a:	08 e0       	ldi	r16, 0x08	; 8
    589c:	10 e0       	ldi	r17, 0x00	; 0
    589e:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
    58a2:	88 23       	and	r24, r24
    58a4:	99 f7       	brne	.-26     	; 0x588c <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    58a6:	8f ef       	ldi	r24, 0xFF	; 255
    58a8:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    58ac:	80 93 a6 50 	sts	0x50A6, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    58b0:	8e ef       	ldi	r24, 0xFE	; 254
    58b2:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    58b6:	1c 14       	cp	r1, r12
    58b8:	1d 04       	cpc	r1, r13
    58ba:	bc f4       	brge	.+46     	; 0x58ea <SD_write_block+0xb6>
    58bc:	87 2c       	mov	r8, r7
    58be:	96 2c       	mov	r9, r6
    58c0:	00 e0       	ldi	r16, 0x00	; 0
    58c2:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    58c4:	c8 01       	movw	r24, r16
    58c6:	6d e0       	ldi	r22, 0x0D	; 13
    58c8:	70 e0       	ldi	r23, 0x00	; 0
    58ca:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    58ce:	ec 01       	movw	r28, r24
    58d0:	f4 01       	movw	r30, r8
    58d2:	81 91       	ld	r24, Z+
    58d4:	4f 01       	movw	r8, r30
    58d6:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    58da:	ca 55       	subi	r28, 0x5A	; 90
    58dc:	df 4a       	sbci	r29, 0xAF	; 175
    58de:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    58e0:	0f 5f       	subi	r16, 0xFF	; 255
    58e2:	1f 4f       	sbci	r17, 0xFF	; 255
    58e4:	0c 15       	cp	r16, r12
    58e6:	1d 05       	cpc	r17, r13
    58e8:	69 f7       	brne	.-38     	; 0x58c4 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    58ea:	1e 14       	cp	r1, r14
    58ec:	1f 04       	cpc	r1, r15
    58ee:	ec f4       	brge	.+58     	; 0x592a <SD_write_block+0xf6>
    58f0:	00 e0       	ldi	r16, 0x00	; 0
    58f2:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    58f4:	0f 2e       	mov	r0, r31
    58f6:	fd e0       	ldi	r31, 0x0D	; 13
    58f8:	cf 2e       	mov	r12, r31
    58fa:	dd 24       	eor	r13, r13
    58fc:	f0 2d       	mov	r31, r0
    58fe:	0f 2e       	mov	r0, r31
    5900:	f6 ea       	ldi	r31, 0xA6	; 166
    5902:	8f 2e       	mov	r8, r31
    5904:	f0 e5       	ldi	r31, 0x50	; 80
    5906:	9f 2e       	mov	r9, r31
    5908:	f0 2d       	mov	r31, r0
    590a:	c8 01       	movw	r24, r16
    590c:	b6 01       	movw	r22, r12
    590e:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    5912:	ec 01       	movw	r28, r24
    5914:	80 e0       	ldi	r24, 0x00	; 0
    5916:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    591a:	c8 0d       	add	r28, r8
    591c:	d9 1d       	adc	r29, r9
    591e:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5920:	0f 5f       	subi	r16, 0xFF	; 255
    5922:	1f 4f       	sbci	r17, 0xFF	; 255
    5924:	0e 15       	cp	r16, r14
    5926:	1f 05       	cpc	r17, r15
    5928:	81 f7       	brne	.-32     	; 0x590a <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    592a:	8f ef       	ldi	r24, 0xFF	; 255
    592c:	80 93 a6 50 	sts	0x50A6, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5930:	c0 e0       	ldi	r28, 0x00	; 0
    5932:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    5934:	06 ea       	ldi	r16, 0xA6	; 166
    5936:	10 e5       	ldi	r17, 0x50	; 80
    5938:	8f ef       	ldi	r24, 0xFF	; 255
    593a:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    593e:	f8 01       	movw	r30, r16
    5940:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5942:	21 96       	adiw	r28, 0x01	; 1
    5944:	c2 30       	cpi	r28, 0x02	; 2
    5946:	d1 05       	cpc	r29, r1
    5948:	bc f3       	brlt	.-18     	; 0x5938 <SD_write_block+0x104>
    594a:	80 81       	ld	r24, Z
    594c:	8f 3f       	cpi	r24, 0xFF	; 255
    594e:	a1 f3       	breq	.-24     	; 0x5938 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    5950:	80 91 a6 50 	lds	r24, 0x50A6
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    5954:	80 91 a6 50 	lds	r24, 0x50A6
    5958:	8f 3f       	cpi	r24, 0xFF	; 255
    595a:	49 f0       	breq	.+18     	; 0x596e <SD_write_block+0x13a>
    595c:	c6 ea       	ldi	r28, 0xA6	; 166
    595e:	d0 e5       	ldi	r29, 0x50	; 80
    5960:	8f ef       	ldi	r24, 0xFF	; 255
    5962:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5966:	88 83       	st	Y, r24
    5968:	88 81       	ld	r24, Y
    596a:	8f 3f       	cpi	r24, 0xFF	; 255
    596c:	c9 f7       	brne	.-14     	; 0x5960 <SD_write_block+0x12c>
	SPICS(FALSE);
    596e:	80 e0       	ldi	r24, 0x00	; 0
    5970:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    5974:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    5978:	88 e0       	ldi	r24, 0x08	; 8
    597a:	60 e0       	ldi	r22, 0x00	; 0
    597c:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
}
    5980:	df 91       	pop	r29
    5982:	cf 91       	pop	r28
    5984:	1f 91       	pop	r17
    5986:	0f 91       	pop	r16
    5988:	ff 90       	pop	r15
    598a:	ef 90       	pop	r14
    598c:	df 90       	pop	r13
    598e:	cf 90       	pop	r12
    5990:	bf 90       	pop	r11
    5992:	af 90       	pop	r10
    5994:	9f 90       	pop	r9
    5996:	8f 90       	pop	r8
    5998:	7f 90       	pop	r7
    599a:	6f 90       	pop	r6
    599c:	08 95       	ret

0000599e <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    599e:	af 92       	push	r10
    59a0:	bf 92       	push	r11
    59a2:	cf 92       	push	r12
    59a4:	df 92       	push	r13
    59a6:	ef 92       	push	r14
    59a8:	ff 92       	push	r15
    59aa:	0f 93       	push	r16
    59ac:	1f 93       	push	r17
    59ae:	cf 93       	push	r28
    59b0:	df 93       	push	r29
    59b2:	6b 01       	movw	r12, r22
    59b4:	7c 01       	movw	r14, r24
    59b6:	b4 2e       	mov	r11, r20
    59b8:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    59ba:	88 e0       	ldi	r24, 0x08	; 8
    59bc:	60 e0       	ldi	r22, 0x00	; 0
    59be:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    59c2:	80 e0       	ldi	r24, 0x00	; 0
    59c4:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    59c8:	81 e0       	ldi	r24, 0x01	; 1
    59ca:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    59ce:	cb e0       	ldi	r28, 0x0B	; 11
    59d0:	d0 e0       	ldi	r29, 0x00	; 0
    59d2:	03 c0       	rjmp	.+6      	; 0x59da <SD_read_block+0x3c>
    59d4:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    59d6:	09 f4       	brne	.+2      	; 0x59da <SD_read_block+0x3c>
    59d8:	ff cf       	rjmp	.-2      	; 0x59d8 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    59da:	81 e1       	ldi	r24, 0x11	; 17
    59dc:	b7 01       	movw	r22, r14
    59de:	a6 01       	movw	r20, r12
    59e0:	2f ef       	ldi	r18, 0xFF	; 255
    59e2:	08 e0       	ldi	r16, 0x08	; 8
    59e4:	10 e0       	ldi	r17, 0x00	; 0
    59e6:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
    59ea:	88 23       	and	r24, r24
    59ec:	99 f7       	brne	.-26     	; 0x59d4 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    59ee:	80 91 a6 50 	lds	r24, 0x50A6
    59f2:	8e 3f       	cpi	r24, 0xFE	; 254
    59f4:	49 f0       	breq	.+18     	; 0x5a08 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    59f6:	c6 ea       	ldi	r28, 0xA6	; 166
    59f8:	d0 e5       	ldi	r29, 0x50	; 80
    59fa:	8f ef       	ldi	r24, 0xFF	; 255
    59fc:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5a00:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5a02:	88 81       	ld	r24, Y
    5a04:	8e 3f       	cpi	r24, 0xFE	; 254
    5a06:	c9 f7       	brne	.-14     	; 0x59fa <SD_read_block+0x5c>
    5a08:	0b 2d       	mov	r16, r11
    5a0a:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5a0c:	c0 e0       	ldi	r28, 0x00	; 0
    5a0e:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5a10:	8f ef       	ldi	r24, 0xFF	; 255
    5a12:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5a16:	f8 01       	movw	r30, r16
    5a18:	81 93       	st	Z+, r24
    5a1a:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5a1c:	21 96       	adiw	r28, 0x01	; 1
    5a1e:	f2 e0       	ldi	r31, 0x02	; 2
    5a20:	c0 30       	cpi	r28, 0x00	; 0
    5a22:	df 07       	cpc	r29, r31
    5a24:	a9 f7       	brne	.-22     	; 0x5a10 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    5a26:	10 92 b2 50 	sts	0x50B2, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5a2a:	80 91 b2 50 	lds	r24, 0x50B2
    5a2e:	8f 3f       	cpi	r24, 0xFF	; 255
    5a30:	49 f0       	breq	.+18     	; 0x5a44 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5a32:	c2 eb       	ldi	r28, 0xB2	; 178
    5a34:	d0 e5       	ldi	r29, 0x50	; 80
    5a36:	8f ef       	ldi	r24, 0xFF	; 255
    5a38:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5a3c:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5a3e:	88 81       	ld	r24, Y
    5a40:	8f 3f       	cpi	r24, 0xFF	; 255
    5a42:	c9 f7       	brne	.-14     	; 0x5a36 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    5a44:	80 e0       	ldi	r24, 0x00	; 0
    5a46:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    5a4a:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5a4e:	88 e0       	ldi	r24, 0x08	; 8
    5a50:	60 e0       	ldi	r22, 0x00	; 0
    5a52:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
}
    5a56:	df 91       	pop	r29
    5a58:	cf 91       	pop	r28
    5a5a:	1f 91       	pop	r17
    5a5c:	0f 91       	pop	r16
    5a5e:	ff 90       	pop	r15
    5a60:	ef 90       	pop	r14
    5a62:	df 90       	pop	r13
    5a64:	cf 90       	pop	r12
    5a66:	bf 90       	pop	r11
    5a68:	af 90       	pop	r10
    5a6a:	08 95       	ret

00005a6c <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5a6c:	2f 92       	push	r2
    5a6e:	3f 92       	push	r3
    5a70:	4f 92       	push	r4
    5a72:	5f 92       	push	r5
    5a74:	6f 92       	push	r6
    5a76:	7f 92       	push	r7
    5a78:	8f 92       	push	r8
    5a7a:	9f 92       	push	r9
    5a7c:	af 92       	push	r10
    5a7e:	bf 92       	push	r11
    5a80:	cf 92       	push	r12
    5a82:	df 92       	push	r13
    5a84:	ef 92       	push	r14
    5a86:	ff 92       	push	r15
    5a88:	0f 93       	push	r16
    5a8a:	1f 93       	push	r17
    5a8c:	cf 93       	push	r28
    5a8e:	df 93       	push	r29
    5a90:	cd b7       	in	r28, 0x3d	; 61
    5a92:	de b7       	in	r29, 0x3e	; 62
    5a94:	2a 97       	sbiw	r28, 0x0a	; 10
    5a96:	cd bf       	out	0x3d, r28	; 61
    5a98:	de bf       	out	0x3e, r29	; 62
    5a9a:	6b 01       	movw	r12, r22
    5a9c:	7c 01       	movw	r14, r24
    5a9e:	4f 83       	std	Y+7, r20	; 0x07
    5aa0:	58 87       	std	Y+8, r21	; 0x08
    5aa2:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5aa4:	88 e0       	ldi	r24, 0x08	; 8
    5aa6:	60 e0       	ldi	r22, 0x00	; 0
    5aa8:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5aac:	80 e0       	ldi	r24, 0x00	; 0
    5aae:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    5ab2:	81 e0       	ldi	r24, 0x01	; 1
    5ab4:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5ab8:	c8 01       	movw	r24, r16
    5aba:	11 23       	and	r17, r17
    5abc:	14 f4       	brge	.+4      	; 0x5ac2 <SD_write_multiple_blocks+0x56>
    5abe:	81 50       	subi	r24, 0x01	; 1
    5ac0:	9e 4f       	sbci	r25, 0xFE	; 254
    5ac2:	9c 01       	movw	r18, r24
    5ac4:	23 2f       	mov	r18, r19
    5ac6:	33 0f       	add	r19, r19
    5ac8:	33 0b       	sbc	r19, r19
    5aca:	25 95       	asr	r18
    5acc:	2b 83       	std	Y+3, r18	; 0x03
    5ace:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5ad0:	20 e0       	ldi	r18, 0x00	; 0
    5ad2:	32 e0       	ldi	r19, 0x02	; 2
    5ad4:	c8 01       	movw	r24, r16
    5ad6:	b9 01       	movw	r22, r18
    5ad8:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    5adc:	29 01       	movw	r4, r18
    5ade:	48 1a       	sub	r4, r24
    5ae0:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5ae2:	30 e0       	ldi	r19, 0x00	; 0
    5ae4:	43 16       	cp	r4, r19
    5ae6:	32 e0       	ldi	r19, 0x02	; 2
    5ae8:	53 06       	cpc	r5, r19
    5aea:	31 f0       	breq	.+12     	; 0x5af8 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5aec:	8b 81       	ldd	r24, Y+3	; 0x03
    5aee:	9c 81       	ldd	r25, Y+4	; 0x04
    5af0:	01 96       	adiw	r24, 0x01	; 1
    5af2:	8b 83       	std	Y+3, r24	; 0x03
    5af4:	9c 83       	std	Y+4, r25	; 0x04
    5af6:	02 c0       	rjmp	.+4      	; 0x5afc <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5af8:	44 24       	eor	r4, r4
    5afa:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5afc:	89 e1       	ldi	r24, 0x19	; 25
    5afe:	b7 01       	movw	r22, r14
    5b00:	a6 01       	movw	r20, r12
    5b02:	2f ef       	ldi	r18, 0xFF	; 255
    5b04:	08 e0       	ldi	r16, 0x08	; 8
    5b06:	10 e0       	ldi	r17, 0x00	; 0
    5b08:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
    5b0c:	88 23       	and	r24, r24
    5b0e:	b1 f7       	brne	.-20     	; 0x5afc <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5b10:	eb 81       	ldd	r30, Y+3	; 0x03
    5b12:	fc 81       	ldd	r31, Y+4	; 0x04
    5b14:	1e 16       	cp	r1, r30
    5b16:	1f 06       	cpc	r1, r31
    5b18:	0c f0       	brlt	.+2      	; 0x5b1c <SD_write_multiple_blocks+0xb0>
    5b1a:	ac c0       	rjmp	.+344    	; 0x5c74 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5b1c:	31 97       	sbiw	r30, 0x01	; 1
    5b1e:	ed 83       	std	Y+5, r30	; 0x05
    5b20:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5b22:	9f 01       	movw	r18, r30
    5b24:	32 2f       	mov	r19, r18
    5b26:	22 27       	eor	r18, r18
    5b28:	33 0f       	add	r19, r19
    5b2a:	8f 81       	ldd	r24, Y+7	; 0x07
    5b2c:	98 85       	ldd	r25, Y+8	; 0x08
    5b2e:	89 83       	std	Y+1, r24	; 0x01
    5b30:	9a 83       	std	Y+2, r25	; 0x02
    5b32:	66 24       	eor	r6, r6
    5b34:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5b36:	0f 2e       	mov	r0, r31
    5b38:	f7 ea       	ldi	r31, 0xA7	; 167
    5b3a:	8f 2e       	mov	r8, r31
    5b3c:	f0 e5       	ldi	r31, 0x50	; 80
    5b3e:	9f 2e       	mov	r9, r31
    5b40:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5b42:	0f 2e       	mov	r0, r31
    5b44:	fc e0       	ldi	r31, 0x0C	; 12
    5b46:	cf 2e       	mov	r12, r31
    5b48:	dd 24       	eor	r13, r13
    5b4a:	f0 2d       	mov	r31, r0
    5b4c:	0f 2e       	mov	r0, r31
    5b4e:	f6 ea       	ldi	r31, 0xA6	; 166
    5b50:	af 2e       	mov	r10, r31
    5b52:	f0 e5       	ldi	r31, 0x50	; 80
    5b54:	bf 2e       	mov	r11, r31
    5b56:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5b58:	80 e0       	ldi	r24, 0x00	; 0
    5b5a:	92 e0       	ldi	r25, 0x02	; 2
    5b5c:	1c 01       	movw	r2, r24
    5b5e:	24 18       	sub	r2, r4
    5b60:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5b62:	ef 81       	ldd	r30, Y+7	; 0x07
    5b64:	f8 85       	ldd	r31, Y+8	; 0x08
    5b66:	e2 0f       	add	r30, r18
    5b68:	f3 1f       	adc	r31, r19
    5b6a:	ef 83       	std	Y+7, r30	; 0x07
    5b6c:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5b6e:	8f ef       	ldi	r24, 0xFF	; 255
    5b70:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5b74:	f4 01       	movw	r30, r8
    5b76:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    5b78:	8c ef       	ldi	r24, 0xFC	; 252
    5b7a:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5b7e:	f4 01       	movw	r30, r8
    5b80:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    5b82:	2d 81       	ldd	r18, Y+5	; 0x05
    5b84:	3e 81       	ldd	r19, Y+6	; 0x06
    5b86:	26 15       	cp	r18, r6
    5b88:	37 05       	cpc	r19, r7
    5b8a:	09 f0       	breq	.+2      	; 0x5b8e <SD_write_multiple_blocks+0x122>
    5b8c:	41 c0       	rjmp	.+130    	; 0x5c10 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5b8e:	12 14       	cp	r1, r2
    5b90:	13 04       	cpc	r1, r3
    5b92:	cc f4       	brge	.+50     	; 0x5bc6 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5b94:	ef 80       	ldd	r14, Y+7	; 0x07
    5b96:	f8 84       	ldd	r15, Y+8	; 0x08
    5b98:	00 e0       	ldi	r16, 0x00	; 0
    5b9a:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5b9c:	c8 01       	movw	r24, r16
    5b9e:	b6 01       	movw	r22, r12
    5ba0:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    5ba4:	89 87       	std	Y+9, r24	; 0x09
    5ba6:	9a 87       	std	Y+10, r25	; 0x0a
    5ba8:	f7 01       	movw	r30, r14
    5baa:	81 91       	ld	r24, Z+
    5bac:	7f 01       	movw	r14, r30
    5bae:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5bb2:	e9 85       	ldd	r30, Y+9	; 0x09
    5bb4:	fa 85       	ldd	r31, Y+10	; 0x0a
    5bb6:	ea 0d       	add	r30, r10
    5bb8:	fb 1d       	adc	r31, r11
    5bba:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5bbc:	0f 5f       	subi	r16, 0xFF	; 255
    5bbe:	1f 4f       	sbci	r17, 0xFF	; 255
    5bc0:	02 15       	cp	r16, r2
    5bc2:	13 05       	cpc	r17, r3
    5bc4:	59 f7       	brne	.-42     	; 0x5b9c <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5bc6:	14 14       	cp	r1, r4
    5bc8:	15 04       	cpc	r1, r5
    5bca:	9c f4       	brge	.+38     	; 0x5bf2 <SD_write_multiple_blocks+0x186>
    5bcc:	00 e0       	ldi	r16, 0x00	; 0
    5bce:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5bd0:	c8 01       	movw	r24, r16
    5bd2:	b6 01       	movw	r22, r12
    5bd4:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    5bd8:	7c 01       	movw	r14, r24
    5bda:	80 e0       	ldi	r24, 0x00	; 0
    5bdc:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5be0:	f5 01       	movw	r30, r10
    5be2:	ee 0d       	add	r30, r14
    5be4:	ff 1d       	adc	r31, r15
    5be6:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5be8:	0f 5f       	subi	r16, 0xFF	; 255
    5bea:	1f 4f       	sbci	r17, 0xFF	; 255
    5bec:	04 15       	cp	r16, r4
    5bee:	15 05       	cpc	r17, r5
    5bf0:	79 f7       	brne	.-34     	; 0x5bd0 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5bf2:	8f ef       	ldi	r24, 0xFF	; 255
    5bf4:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5bf8:	f4 01       	movw	r30, r8
    5bfa:	80 83       	st	Z, r24
    5bfc:	8f ef       	ldi	r24, 0xFF	; 255
    5bfe:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5c02:	f4 01       	movw	r30, r8
    5c04:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5c06:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5c08:	80 81       	ld	r24, Z
    5c0a:	8f 3f       	cpi	r24, 0xFF	; 255
    5c0c:	e1 f4       	brne	.+56     	; 0x5c46 <SD_write_multiple_blocks+0x1da>
    5c0e:	23 c0       	rjmp	.+70     	; 0x5c56 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5c10:	e9 80       	ldd	r14, Y+1	; 0x01
    5c12:	fa 80       	ldd	r15, Y+2	; 0x02
    5c14:	00 e0       	ldi	r16, 0x00	; 0
    5c16:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5c18:	c8 01       	movw	r24, r16
    5c1a:	b6 01       	movw	r22, r12
    5c1c:	0e 94 a8 3a 	call	0x7550	; 0x7550 <__divmodhi4>
    5c20:	89 87       	std	Y+9, r24	; 0x09
    5c22:	9a 87       	std	Y+10, r25	; 0x0a
    5c24:	f7 01       	movw	r30, r14
    5c26:	81 91       	ld	r24, Z+
    5c28:	7f 01       	movw	r14, r30
    5c2a:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5c2e:	e9 85       	ldd	r30, Y+9	; 0x09
    5c30:	fa 85       	ldd	r31, Y+10	; 0x0a
    5c32:	ea 0d       	add	r30, r10
    5c34:	fb 1d       	adc	r31, r11
    5c36:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5c38:	0f 5f       	subi	r16, 0xFF	; 255
    5c3a:	1f 4f       	sbci	r17, 0xFF	; 255
    5c3c:	f2 e0       	ldi	r31, 0x02	; 2
    5c3e:	00 30       	cpi	r16, 0x00	; 0
    5c40:	1f 07       	cpc	r17, r31
    5c42:	51 f7       	brne	.-44     	; 0x5c18 <SD_write_multiple_blocks+0x1ac>
    5c44:	d6 cf       	rjmp	.-84     	; 0x5bf2 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5c46:	8f ef       	ldi	r24, 0xFF	; 255
    5c48:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5c4c:	f4 01       	movw	r30, r8
    5c4e:	80 83       	st	Z, r24
    5c50:	80 81       	ld	r24, Z
    5c52:	8f 3f       	cpi	r24, 0xFF	; 255
    5c54:	c1 f7       	brne	.-16     	; 0x5c46 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    5c56:	08 94       	sec
    5c58:	61 1c       	adc	r6, r1
    5c5a:	71 1c       	adc	r7, r1
    5c5c:	29 81       	ldd	r18, Y+1	; 0x01
    5c5e:	3a 81       	ldd	r19, Y+2	; 0x02
    5c60:	20 50       	subi	r18, 0x00	; 0
    5c62:	3e 4f       	sbci	r19, 0xFE	; 254
    5c64:	29 83       	std	Y+1, r18	; 0x01
    5c66:	3a 83       	std	Y+2, r19	; 0x02
    5c68:	8b 81       	ldd	r24, Y+3	; 0x03
    5c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    5c6c:	68 16       	cp	r6, r24
    5c6e:	79 06       	cpc	r7, r25
    5c70:	09 f0       	breq	.+2      	; 0x5c74 <SD_write_multiple_blocks+0x208>
    5c72:	7d cf       	rjmp	.-262    	; 0x5b6e <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5c74:	ee 24       	eor	r14, r14
    5c76:	ff 24       	eor	r15, r15
    5c78:	68 94       	set
    5c7a:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5c7c:	07 ea       	ldi	r16, 0xA7	; 167
    5c7e:	10 e5       	ldi	r17, 0x50	; 80
    5c80:	8f ef       	ldi	r24, 0xFF	; 255
    5c82:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5c86:	f8 01       	movw	r30, r16
    5c88:	80 83       	st	Z, r24
    5c8a:	08 94       	sec
    5c8c:	e1 08       	sbc	r14, r1
    5c8e:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5c90:	e1 14       	cp	r14, r1
    5c92:	f1 04       	cpc	r15, r1
    5c94:	a9 f7       	brne	.-22     	; 0x5c80 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5c96:	8d ef       	ldi	r24, 0xFD	; 253
    5c98:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5c9c:	80 93 a7 50 	sts	0x50A7, r24
    5ca0:	ee 24       	eor	r14, r14
    5ca2:	ff 24       	eor	r15, r15
    5ca4:	68 94       	set
    5ca6:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5ca8:	07 ea       	ldi	r16, 0xA7	; 167
    5caa:	10 e5       	ldi	r17, 0x50	; 80
    5cac:	8f ef       	ldi	r24, 0xFF	; 255
    5cae:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5cb2:	f8 01       	movw	r30, r16
    5cb4:	80 83       	st	Z, r24
    5cb6:	08 94       	sec
    5cb8:	e1 08       	sbc	r14, r1
    5cba:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5cbc:	e1 14       	cp	r14, r1
    5cbe:	f1 04       	cpc	r15, r1
    5cc0:	a9 f7       	brne	.-22     	; 0x5cac <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5cc2:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5cc6:	80 91 a7 50 	lds	r24, 0x50A7
    5cca:	8f 3f       	cpi	r24, 0xFF	; 255
    5ccc:	51 f0       	breq	.+20     	; 0x5ce2 <SD_write_multiple_blocks+0x276>
    5cce:	07 ea       	ldi	r16, 0xA7	; 167
    5cd0:	10 e5       	ldi	r17, 0x50	; 80
    5cd2:	8f ef       	ldi	r24, 0xFF	; 255
    5cd4:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5cd8:	f8 01       	movw	r30, r16
    5cda:	80 83       	st	Z, r24
    5cdc:	80 81       	ld	r24, Z
    5cde:	8f 3f       	cpi	r24, 0xFF	; 255
    5ce0:	c1 f7       	brne	.-16     	; 0x5cd2 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5ce2:	80 e0       	ldi	r24, 0x00	; 0
    5ce4:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    5ce8:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5cec:	88 e0       	ldi	r24, 0x08	; 8
    5cee:	60 e0       	ldi	r22, 0x00	; 0
    5cf0:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
}
    5cf4:	2a 96       	adiw	r28, 0x0a	; 10
    5cf6:	cd bf       	out	0x3d, r28	; 61
    5cf8:	de bf       	out	0x3e, r29	; 62
    5cfa:	df 91       	pop	r29
    5cfc:	cf 91       	pop	r28
    5cfe:	1f 91       	pop	r17
    5d00:	0f 91       	pop	r16
    5d02:	ff 90       	pop	r15
    5d04:	ef 90       	pop	r14
    5d06:	df 90       	pop	r13
    5d08:	cf 90       	pop	r12
    5d0a:	bf 90       	pop	r11
    5d0c:	af 90       	pop	r10
    5d0e:	9f 90       	pop	r9
    5d10:	8f 90       	pop	r8
    5d12:	7f 90       	pop	r7
    5d14:	6f 90       	pop	r6
    5d16:	5f 90       	pop	r5
    5d18:	4f 90       	pop	r4
    5d1a:	3f 90       	pop	r3
    5d1c:	2f 90       	pop	r2
    5d1e:	08 95       	ret

00005d20 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5d20:	2f 92       	push	r2
    5d22:	3f 92       	push	r3
    5d24:	4f 92       	push	r4
    5d26:	5f 92       	push	r5
    5d28:	6f 92       	push	r6
    5d2a:	7f 92       	push	r7
    5d2c:	8f 92       	push	r8
    5d2e:	9f 92       	push	r9
    5d30:	af 92       	push	r10
    5d32:	bf 92       	push	r11
    5d34:	cf 92       	push	r12
    5d36:	df 92       	push	r13
    5d38:	ef 92       	push	r14
    5d3a:	ff 92       	push	r15
    5d3c:	0f 93       	push	r16
    5d3e:	1f 93       	push	r17
    5d40:	cf 93       	push	r28
    5d42:	df 93       	push	r29
    5d44:	6b 01       	movw	r12, r22
    5d46:	7c 01       	movw	r14, r24
    5d48:	c4 2f       	mov	r28, r20
    5d4a:	85 2e       	mov	r8, r21
    5d4c:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5d4e:	88 e0       	ldi	r24, 0x08	; 8
    5d50:	60 e0       	ldi	r22, 0x00	; 0
    5d52:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5d56:	80 e0       	ldi	r24, 0x00	; 0
    5d58:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    5d5c:	81 e0       	ldi	r24, 0x01	; 1
    5d5e:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5d62:	82 e1       	ldi	r24, 0x12	; 18
    5d64:	b7 01       	movw	r22, r14
    5d66:	a6 01       	movw	r20, r12
    5d68:	2f ef       	ldi	r18, 0xFF	; 255
    5d6a:	08 e0       	ldi	r16, 0x08	; 8
    5d6c:	10 e0       	ldi	r17, 0x00	; 0
    5d6e:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
    5d72:	88 23       	and	r24, r24
    5d74:	b1 f7       	brne	.-20     	; 0x5d62 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5d76:	16 14       	cp	r1, r6
    5d78:	17 04       	cpc	r1, r7
    5d7a:	0c f0       	brlt	.+2      	; 0x5d7e <SD_read_multiple_blocks+0x5e>
    5d7c:	46 c0       	rjmp	.+140    	; 0x5e0a <SD_read_multiple_blocks+0xea>
    5d7e:	ac 2e       	mov	r10, r28
    5d80:	b8 2c       	mov	r11, r8
    5d82:	88 24       	eor	r8, r8
    5d84:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5d86:	0f 2e       	mov	r0, r31
    5d88:	f7 ea       	ldi	r31, 0xA7	; 167
    5d8a:	cf 2e       	mov	r12, r31
    5d8c:	f0 e5       	ldi	r31, 0x50	; 80
    5d8e:	df 2e       	mov	r13, r31
    5d90:	f0 2d       	mov	r31, r0
    5d92:	ff 24       	eor	r15, r15
    5d94:	fa 94       	dec	r15
    5d96:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5d98:	0f 2e       	mov	r0, r31
    5d9a:	f6 ea       	ldi	r31, 0xA6	; 166
    5d9c:	4f 2e       	mov	r4, r31
    5d9e:	f0 e5       	ldi	r31, 0x50	; 80
    5da0:	5f 2e       	mov	r5, r31
    5da2:	f0 2d       	mov	r31, r0
    5da4:	12 01       	movw	r2, r4
    5da6:	08 94       	sec
    5da8:	21 1c       	adc	r2, r1
    5daa:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5dac:	f6 01       	movw	r30, r12
    5dae:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5db0:	80 81       	ld	r24, Z
    5db2:	8e 3f       	cpi	r24, 0xFE	; 254
    5db4:	41 f0       	breq	.+16     	; 0x5dc6 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5db6:	8f 2d       	mov	r24, r15
    5db8:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5dbc:	f6 01       	movw	r30, r12
    5dbe:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5dc0:	80 81       	ld	r24, Z
    5dc2:	8e 3f       	cpi	r24, 0xFE	; 254
    5dc4:	c1 f7       	brne	.-16     	; 0x5db6 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5dc6:	85 01       	movw	r16, r10
    5dc8:	c0 e0       	ldi	r28, 0x00	; 0
    5dca:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5dcc:	8f 2d       	mov	r24, r15
    5dce:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5dd2:	f8 01       	movw	r30, r16
    5dd4:	81 93       	st	Z+, r24
    5dd6:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5dd8:	21 96       	adiw	r28, 0x01	; 1
    5dda:	f2 e0       	ldi	r31, 0x02	; 2
    5ddc:	c0 30       	cpi	r28, 0x00	; 0
    5dde:	df 07       	cpc	r29, r31
    5de0:	a9 f7       	brne	.-22     	; 0x5dcc <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5de2:	8f 2d       	mov	r24, r15
    5de4:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5de8:	f2 01       	movw	r30, r4
    5dea:	80 83       	st	Z, r24
    5dec:	8f 2d       	mov	r24, r15
    5dee:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5df2:	f1 01       	movw	r30, r2
    5df4:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5df6:	08 94       	sec
    5df8:	81 1c       	adc	r8, r1
    5dfa:	91 1c       	adc	r9, r1
    5dfc:	80 e0       	ldi	r24, 0x00	; 0
    5dfe:	92 e0       	ldi	r25, 0x02	; 2
    5e00:	a8 0e       	add	r10, r24
    5e02:	b9 1e       	adc	r11, r25
    5e04:	86 14       	cp	r8, r6
    5e06:	97 04       	cpc	r9, r7
    5e08:	89 f6       	brne	.-94     	; 0x5dac <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5e0a:	8c e0       	ldi	r24, 0x0C	; 12
    5e0c:	40 e0       	ldi	r20, 0x00	; 0
    5e0e:	50 e0       	ldi	r21, 0x00	; 0
    5e10:	ba 01       	movw	r22, r20
    5e12:	2f ef       	ldi	r18, 0xFF	; 255
    5e14:	08 e0       	ldi	r16, 0x08	; 8
    5e16:	10 e0       	ldi	r17, 0x00	; 0
    5e18:	0e 94 df 2a 	call	0x55be	; 0x55be <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5e1c:	8f ef       	ldi	r24, 0xFF	; 255
    5e1e:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5e22:	80 93 a6 50 	sts	0x50A6, r24
	Buffer[1] = FILLER_BYTE;
    5e26:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5e2a:	80 91 a7 50 	lds	r24, 0x50A7
    5e2e:	8f 3f       	cpi	r24, 0xFF	; 255
    5e30:	49 f0       	breq	.+18     	; 0x5e44 <SD_read_multiple_blocks+0x124>
    5e32:	c7 ea       	ldi	r28, 0xA7	; 167
    5e34:	d0 e5       	ldi	r29, 0x50	; 80
    5e36:	8f ef       	ldi	r24, 0xFF	; 255
    5e38:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
    5e3c:	88 83       	st	Y, r24
    5e3e:	88 81       	ld	r24, Y
    5e40:	8f 3f       	cpi	r24, 0xFF	; 255
    5e42:	c9 f7       	brne	.-14     	; 0x5e36 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5e44:	80 e0       	ldi	r24, 0x00	; 0
    5e46:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    5e4a:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5e4e:	88 e0       	ldi	r24, 0x08	; 8
    5e50:	60 e0       	ldi	r22, 0x00	; 0
    5e52:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
}
    5e56:	df 91       	pop	r29
    5e58:	cf 91       	pop	r28
    5e5a:	1f 91       	pop	r17
    5e5c:	0f 91       	pop	r16
    5e5e:	ff 90       	pop	r15
    5e60:	ef 90       	pop	r14
    5e62:	df 90       	pop	r13
    5e64:	cf 90       	pop	r12
    5e66:	bf 90       	pop	r11
    5e68:	af 90       	pop	r10
    5e6a:	9f 90       	pop	r9
    5e6c:	8f 90       	pop	r8
    5e6e:	7f 90       	pop	r7
    5e70:	6f 90       	pop	r6
    5e72:	5f 90       	pop	r5
    5e74:	4f 90       	pop	r4
    5e76:	3f 90       	pop	r3
    5e78:	2f 90       	pop	r2
    5e7a:	08 95       	ret

00005e7c <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5e7c:	88 e0       	ldi	r24, 0x08	; 8
    5e7e:	60 e0       	ldi	r22, 0x00	; 0
    5e80:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5e84:	88 e0       	ldi	r24, 0x08	; 8
    5e86:	60 e0       	ldi	r22, 0x00	; 0
    5e88:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5e8c:	80 e0       	ldi	r24, 0x00	; 0
    5e8e:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <SPIInit>
	SPICS(TRUE);
    5e92:	81 e0       	ldi	r24, 0x01	; 1
    5e94:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5e98:	8f ef       	ldi	r24, 0xFF	; 255
    5e9a:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <SPI_write>
	SPICS(FALSE);	//stop spi
    5e9e:	80 e0       	ldi	r24, 0x00	; 0
    5ea0:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <SPICS>
	SPIDisable();
    5ea4:	0e 94 cc 1d 	call	0x3b98	; 0x3b98 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5ea8:	80 e0       	ldi	r24, 0x00	; 0
    5eaa:	0e 94 60 04 	call	0x8c0	; 0x8c0 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5eae:	80 e0       	ldi	r24, 0x00	; 0
    5eb0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <Ext1Power>
}
    5eb4:	08 95       	ret

00005eb6 <__muldi3>:
    5eb6:	a0 e3       	ldi	r26, 0x30	; 48
    5eb8:	b0 e0       	ldi	r27, 0x00	; 0
    5eba:	e1 e6       	ldi	r30, 0x61	; 97
    5ebc:	ff e2       	ldi	r31, 0x2F	; 47
    5ebe:	0c 94 fa 3a 	jmp	0x75f4	; 0x75f4 <__prologue_saves__+0x4>
    5ec2:	29 8f       	std	Y+25, r18	; 0x19
    5ec4:	3a 8f       	std	Y+26, r19	; 0x1a
    5ec6:	4b 8f       	std	Y+27, r20	; 0x1b
    5ec8:	5c 8f       	std	Y+28, r21	; 0x1c
    5eca:	6d 8f       	std	Y+29, r22	; 0x1d
    5ecc:	7e 8f       	std	Y+30, r23	; 0x1e
    5ece:	8f 8f       	std	Y+31, r24	; 0x1f
    5ed0:	98 a3       	lds	r25, 0x58
    5ed2:	a9 8a       	std	Y+17, r10	; 0x11
    5ed4:	ba 8a       	std	Y+18, r11	; 0x12
    5ed6:	cb 8a       	std	Y+19, r12	; 0x13
    5ed8:	dc 8a       	std	Y+20, r13	; 0x14
    5eda:	ed 8a       	std	Y+21, r14	; 0x15
    5edc:	fe 8a       	std	Y+22, r15	; 0x16
    5ede:	0f 8b       	std	Y+23, r16	; 0x17
    5ee0:	18 8f       	std	Y+24, r17	; 0x18
    5ee2:	09 8d       	ldd	r16, Y+25	; 0x19
    5ee4:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5ee6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5ee8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5eea:	09 a3       	lds	r16, 0x59
    5eec:	1a a3       	lds	r17, 0x5a
    5eee:	2b a3       	lds	r18, 0x5b
    5ef0:	3c a3       	lds	r19, 0x5c
    5ef2:	68 01       	movw	r12, r16
    5ef4:	79 01       	movw	r14, r18
    5ef6:	8f ef       	ldi	r24, 0xFF	; 255
    5ef8:	9f ef       	ldi	r25, 0xFF	; 255
    5efa:	a0 e0       	ldi	r26, 0x00	; 0
    5efc:	b0 e0       	ldi	r27, 0x00	; 0
    5efe:	c8 22       	and	r12, r24
    5f00:	d9 22       	and	r13, r25
    5f02:	ea 22       	and	r14, r26
    5f04:	fb 22       	and	r15, r27
    5f06:	89 01       	movw	r16, r18
    5f08:	22 27       	eor	r18, r18
    5f0a:	33 27       	eor	r19, r19
    5f0c:	09 a7       	lds	r16, 0x79
    5f0e:	1a a7       	lds	r17, 0x7a
    5f10:	2b a7       	lds	r18, 0x7b
    5f12:	3c a7       	lds	r19, 0x7c
    5f14:	09 89       	ldd	r16, Y+17	; 0x11
    5f16:	1a 89       	ldd	r17, Y+18	; 0x12
    5f18:	2b 89       	ldd	r18, Y+19	; 0x13
    5f1a:	3c 89       	ldd	r19, Y+20	; 0x14
    5f1c:	0d a3       	lds	r16, 0x5d
    5f1e:	1e a3       	lds	r17, 0x5e
    5f20:	2f a3       	lds	r18, 0x5f
    5f22:	38 a7       	lds	r19, 0x78
    5f24:	48 01       	movw	r8, r16
    5f26:	59 01       	movw	r10, r18
    5f28:	88 22       	and	r8, r24
    5f2a:	99 22       	and	r9, r25
    5f2c:	aa 22       	and	r10, r26
    5f2e:	bb 22       	and	r11, r27
    5f30:	29 01       	movw	r4, r18
    5f32:	66 24       	eor	r6, r6
    5f34:	77 24       	eor	r7, r7
    5f36:	c5 01       	movw	r24, r10
    5f38:	b4 01       	movw	r22, r8
    5f3a:	a7 01       	movw	r20, r14
    5f3c:	96 01       	movw	r18, r12
    5f3e:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    5f42:	6d a7       	lds	r22, 0x7d
    5f44:	7e a7       	lds	r23, 0x7e
    5f46:	8f a7       	lds	r24, 0x7f
    5f48:	98 ab       	sts	0x58, r25
    5f4a:	c3 01       	movw	r24, r6
    5f4c:	b2 01       	movw	r22, r4
    5f4e:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    5f52:	6b 01       	movw	r12, r22
    5f54:	7c 01       	movw	r14, r24
    5f56:	c5 01       	movw	r24, r10
    5f58:	b4 01       	movw	r22, r8
    5f5a:	29 a5       	lds	r18, 0x69
    5f5c:	3a a5       	lds	r19, 0x6a
    5f5e:	4b a5       	lds	r20, 0x6b
    5f60:	5c a5       	lds	r21, 0x6c
    5f62:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    5f66:	4b 01       	movw	r8, r22
    5f68:	5c 01       	movw	r10, r24
    5f6a:	c3 01       	movw	r24, r6
    5f6c:	b2 01       	movw	r22, r4
    5f6e:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    5f72:	ab 01       	movw	r20, r22
    5f74:	bc 01       	movw	r22, r24
    5f76:	c8 0c       	add	r12, r8
    5f78:	d9 1c       	adc	r13, r9
    5f7a:	ea 1c       	adc	r14, r10
    5f7c:	fb 1c       	adc	r15, r11
    5f7e:	0d a5       	lds	r16, 0x6d
    5f80:	1e a5       	lds	r17, 0x6e
    5f82:	2f a5       	lds	r18, 0x6f
    5f84:	38 a9       	sts	0x48, r19
    5f86:	c9 01       	movw	r24, r18
    5f88:	aa 27       	eor	r26, r26
    5f8a:	bb 27       	eor	r27, r27
    5f8c:	c8 0e       	add	r12, r24
    5f8e:	d9 1e       	adc	r13, r25
    5f90:	ea 1e       	adc	r14, r26
    5f92:	fb 1e       	adc	r15, r27
    5f94:	c8 14       	cp	r12, r8
    5f96:	d9 04       	cpc	r13, r9
    5f98:	ea 04       	cpc	r14, r10
    5f9a:	fb 04       	cpc	r15, r11
    5f9c:	20 f4       	brcc	.+8      	; 0x5fa6 <__muldi3+0xf0>
    5f9e:	40 50       	subi	r20, 0x00	; 0
    5fa0:	50 40       	sbci	r21, 0x00	; 0
    5fa2:	6f 4f       	sbci	r22, 0xFF	; 255
    5fa4:	7f 4f       	sbci	r23, 0xFF	; 255
    5fa6:	c7 01       	movw	r24, r14
    5fa8:	aa 27       	eor	r26, r26
    5faa:	bb 27       	eor	r27, r27
    5fac:	84 0f       	add	r24, r20
    5fae:	95 1f       	adc	r25, r21
    5fb0:	a6 1f       	adc	r26, r22
    5fb2:	b7 1f       	adc	r27, r23
    5fb4:	8d 83       	std	Y+5, r24	; 0x05
    5fb6:	9e 83       	std	Y+6, r25	; 0x06
    5fb8:	af 83       	std	Y+7, r26	; 0x07
    5fba:	b8 87       	std	Y+8, r27	; 0x08
    5fbc:	76 01       	movw	r14, r12
    5fbe:	dd 24       	eor	r13, r13
    5fc0:	cc 24       	eor	r12, r12
    5fc2:	4d a5       	lds	r20, 0x6d
    5fc4:	5e a5       	lds	r21, 0x6e
    5fc6:	6f a5       	lds	r22, 0x6f
    5fc8:	78 a9       	sts	0x48, r23
    5fca:	60 70       	andi	r22, 0x00	; 0
    5fcc:	70 70       	andi	r23, 0x00	; 0
    5fce:	c4 0e       	add	r12, r20
    5fd0:	d5 1e       	adc	r13, r21
    5fd2:	e6 1e       	adc	r14, r22
    5fd4:	f7 1e       	adc	r15, r23
    5fd6:	c9 82       	std	Y+1, r12	; 0x01
    5fd8:	da 82       	std	Y+2, r13	; 0x02
    5fda:	eb 82       	std	Y+3, r14	; 0x03
    5fdc:	fc 82       	std	Y+4, r15	; 0x04
    5fde:	1c 2d       	mov	r17, r12
    5fe0:	0a 81       	ldd	r16, Y+2	; 0x02
    5fe2:	8b 80       	ldd	r8, Y+3	; 0x03
    5fe4:	4c 80       	ldd	r4, Y+4	; 0x04
    5fe6:	8d 87       	std	Y+13, r24	; 0x0d
    5fe8:	8e 81       	ldd	r24, Y+6	; 0x06
    5fea:	8e 87       	std	Y+14, r24	; 0x0e
    5fec:	8f 81       	ldd	r24, Y+7	; 0x07
    5fee:	8f 87       	std	Y+15, r24	; 0x0f
    5ff0:	88 85       	ldd	r24, Y+8	; 0x08
    5ff2:	88 8b       	std	Y+16, r24	; 0x10
    5ff4:	2d 89       	ldd	r18, Y+21	; 0x15
    5ff6:	3e 89       	ldd	r19, Y+22	; 0x16
    5ff8:	4f 89       	ldd	r20, Y+23	; 0x17
    5ffa:	58 8d       	ldd	r21, Y+24	; 0x18
    5ffc:	69 a1       	lds	r22, 0x49
    5ffe:	7a a1       	lds	r23, 0x4a
    6000:	8b a1       	lds	r24, 0x4b
    6002:	9c a1       	lds	r25, 0x4c
    6004:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6008:	6b 01       	movw	r12, r22
    600a:	7c 01       	movw	r14, r24
    600c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    600e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    6010:	4f 8d       	ldd	r20, Y+31	; 0x1f
    6012:	58 a1       	lds	r21, 0x48
    6014:	6d a1       	lds	r22, 0x4d
    6016:	7e a1       	lds	r23, 0x4e
    6018:	8f a1       	lds	r24, 0x4f
    601a:	98 a5       	lds	r25, 0x68
    601c:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6020:	dc 01       	movw	r26, r24
    6022:	cb 01       	movw	r24, r22
    6024:	c8 0e       	add	r12, r24
    6026:	d9 1e       	adc	r13, r25
    6028:	ea 1e       	adc	r14, r26
    602a:	fb 1e       	adc	r15, r27
    602c:	8d 85       	ldd	r24, Y+13	; 0x0d
    602e:	9e 85       	ldd	r25, Y+14	; 0x0e
    6030:	af 85       	ldd	r26, Y+15	; 0x0f
    6032:	b8 89       	ldd	r27, Y+16	; 0x10
    6034:	8c 0d       	add	r24, r12
    6036:	9d 1d       	adc	r25, r13
    6038:	ae 1d       	adc	r26, r14
    603a:	bf 1d       	adc	r27, r15
    603c:	8d 87       	std	Y+13, r24	; 0x0d
    603e:	9e 87       	std	Y+14, r25	; 0x0e
    6040:	af 87       	std	Y+15, r26	; 0x0f
    6042:	b8 8b       	std	Y+16, r27	; 0x10
    6044:	68 2f       	mov	r22, r24
    6046:	7e 85       	ldd	r23, Y+14	; 0x0e
    6048:	21 2f       	mov	r18, r17
    604a:	30 2f       	mov	r19, r16
    604c:	48 2d       	mov	r20, r8
    604e:	54 2d       	mov	r21, r4
    6050:	8f 85       	ldd	r24, Y+15	; 0x0f
    6052:	98 89       	ldd	r25, Y+16	; 0x10
    6054:	e0 96       	adiw	r28, 0x30	; 48
    6056:	e0 e1       	ldi	r30, 0x10	; 16
    6058:	0c 94 13 3b 	jmp	0x7626	; 0x7626 <__epilogue_restores__+0x4>

0000605c <__ashldi3>:
    605c:	cf 92       	push	r12
    605e:	df 92       	push	r13
    6060:	ef 92       	push	r14
    6062:	ff 92       	push	r15
    6064:	0f 93       	push	r16
    6066:	cf 93       	push	r28
    6068:	df 93       	push	r29
    606a:	cd b7       	in	r28, 0x3d	; 61
    606c:	de b7       	in	r29, 0x3e	; 62
    606e:	60 97       	sbiw	r28, 0x10	; 16
    6070:	cd bf       	out	0x3d, r28	; 61
    6072:	de bf       	out	0x3e, r29	; 62
    6074:	00 23       	and	r16, r16
    6076:	09 f4       	brne	.+2      	; 0x607a <__ashldi3+0x1e>
    6078:	5a c0       	rjmp	.+180    	; 0x612e <__ashldi3+0xd2>
    607a:	29 87       	std	Y+9, r18	; 0x09
    607c:	3a 87       	std	Y+10, r19	; 0x0a
    607e:	4b 87       	std	Y+11, r20	; 0x0b
    6080:	5c 87       	std	Y+12, r21	; 0x0c
    6082:	6d 87       	std	Y+13, r22	; 0x0d
    6084:	7e 87       	std	Y+14, r23	; 0x0e
    6086:	8f 87       	std	Y+15, r24	; 0x0f
    6088:	98 8b       	std	Y+16, r25	; 0x10
    608a:	80 e2       	ldi	r24, 0x20	; 32
    608c:	80 1b       	sub	r24, r16
    608e:	49 85       	ldd	r20, Y+9	; 0x09
    6090:	5a 85       	ldd	r21, Y+10	; 0x0a
    6092:	6b 85       	ldd	r22, Y+11	; 0x0b
    6094:	7c 85       	ldd	r23, Y+12	; 0x0c
    6096:	18 16       	cp	r1, r24
    6098:	b4 f0       	brlt	.+44     	; 0x60c6 <__ashldi3+0x6a>
    609a:	19 82       	std	Y+1, r1	; 0x01
    609c:	1a 82       	std	Y+2, r1	; 0x02
    609e:	1b 82       	std	Y+3, r1	; 0x03
    60a0:	1c 82       	std	Y+4, r1	; 0x04
    60a2:	99 27       	eor	r25, r25
    60a4:	87 fd       	sbrc	r24, 7
    60a6:	90 95       	com	r25
    60a8:	90 95       	com	r25
    60aa:	81 95       	neg	r24
    60ac:	9f 4f       	sbci	r25, 0xFF	; 255
    60ae:	04 c0       	rjmp	.+8      	; 0x60b8 <__ashldi3+0x5c>
    60b0:	44 0f       	add	r20, r20
    60b2:	55 1f       	adc	r21, r21
    60b4:	66 1f       	adc	r22, r22
    60b6:	77 1f       	adc	r23, r23
    60b8:	8a 95       	dec	r24
    60ba:	d2 f7       	brpl	.-12     	; 0x60b0 <__ashldi3+0x54>
    60bc:	4d 83       	std	Y+5, r20	; 0x05
    60be:	5e 83       	std	Y+6, r21	; 0x06
    60c0:	6f 83       	std	Y+7, r22	; 0x07
    60c2:	78 87       	std	Y+8, r23	; 0x08
    60c4:	2c c0       	rjmp	.+88     	; 0x611e <__ashldi3+0xc2>
    60c6:	6a 01       	movw	r12, r20
    60c8:	7b 01       	movw	r14, r22
    60ca:	00 2e       	mov	r0, r16
    60cc:	04 c0       	rjmp	.+8      	; 0x60d6 <__ashldi3+0x7a>
    60ce:	cc 0c       	add	r12, r12
    60d0:	dd 1c       	adc	r13, r13
    60d2:	ee 1c       	adc	r14, r14
    60d4:	ff 1c       	adc	r15, r15
    60d6:	0a 94       	dec	r0
    60d8:	d2 f7       	brpl	.-12     	; 0x60ce <__ashldi3+0x72>
    60da:	c9 82       	std	Y+1, r12	; 0x01
    60dc:	da 82       	std	Y+2, r13	; 0x02
    60de:	eb 82       	std	Y+3, r14	; 0x03
    60e0:	fc 82       	std	Y+4, r15	; 0x04
    60e2:	6a 01       	movw	r12, r20
    60e4:	7b 01       	movw	r14, r22
    60e6:	04 c0       	rjmp	.+8      	; 0x60f0 <__ashldi3+0x94>
    60e8:	f6 94       	lsr	r15
    60ea:	e7 94       	ror	r14
    60ec:	d7 94       	ror	r13
    60ee:	c7 94       	ror	r12
    60f0:	8a 95       	dec	r24
    60f2:	d2 f7       	brpl	.-12     	; 0x60e8 <__ashldi3+0x8c>
    60f4:	d7 01       	movw	r26, r14
    60f6:	c6 01       	movw	r24, r12
    60f8:	4d 85       	ldd	r20, Y+13	; 0x0d
    60fa:	5e 85       	ldd	r21, Y+14	; 0x0e
    60fc:	6f 85       	ldd	r22, Y+15	; 0x0f
    60fe:	78 89       	ldd	r23, Y+16	; 0x10
    6100:	04 c0       	rjmp	.+8      	; 0x610a <__ashldi3+0xae>
    6102:	44 0f       	add	r20, r20
    6104:	55 1f       	adc	r21, r21
    6106:	66 1f       	adc	r22, r22
    6108:	77 1f       	adc	r23, r23
    610a:	0a 95       	dec	r16
    610c:	d2 f7       	brpl	.-12     	; 0x6102 <__ashldi3+0xa6>
    610e:	84 2b       	or	r24, r20
    6110:	95 2b       	or	r25, r21
    6112:	a6 2b       	or	r26, r22
    6114:	b7 2b       	or	r27, r23
    6116:	8d 83       	std	Y+5, r24	; 0x05
    6118:	9e 83       	std	Y+6, r25	; 0x06
    611a:	af 83       	std	Y+7, r26	; 0x07
    611c:	b8 87       	std	Y+8, r27	; 0x08
    611e:	29 81       	ldd	r18, Y+1	; 0x01
    6120:	3a 81       	ldd	r19, Y+2	; 0x02
    6122:	4b 81       	ldd	r20, Y+3	; 0x03
    6124:	5c 81       	ldd	r21, Y+4	; 0x04
    6126:	6d 81       	ldd	r22, Y+5	; 0x05
    6128:	7e 81       	ldd	r23, Y+6	; 0x06
    612a:	8f 81       	ldd	r24, Y+7	; 0x07
    612c:	98 85       	ldd	r25, Y+8	; 0x08
    612e:	60 96       	adiw	r28, 0x10	; 16
    6130:	cd bf       	out	0x3d, r28	; 61
    6132:	de bf       	out	0x3e, r29	; 62
    6134:	df 91       	pop	r29
    6136:	cf 91       	pop	r28
    6138:	0f 91       	pop	r16
    613a:	ff 90       	pop	r15
    613c:	ef 90       	pop	r14
    613e:	df 90       	pop	r13
    6140:	cf 90       	pop	r12
    6142:	08 95       	ret

00006144 <__ashrdi3>:
    6144:	0f 93       	push	r16
    6146:	cf 93       	push	r28
    6148:	df 93       	push	r29
    614a:	cd b7       	in	r28, 0x3d	; 61
    614c:	de b7       	in	r29, 0x3e	; 62
    614e:	60 97       	sbiw	r28, 0x10	; 16
    6150:	cd bf       	out	0x3d, r28	; 61
    6152:	de bf       	out	0x3e, r29	; 62
    6154:	00 23       	and	r16, r16
    6156:	09 f4       	brne	.+2      	; 0x615a <__ashrdi3+0x16>
    6158:	56 c0       	rjmp	.+172    	; 0x6206 <__ashrdi3+0xc2>
    615a:	29 87       	std	Y+9, r18	; 0x09
    615c:	3a 87       	std	Y+10, r19	; 0x0a
    615e:	4b 87       	std	Y+11, r20	; 0x0b
    6160:	5c 87       	std	Y+12, r21	; 0x0c
    6162:	6d 87       	std	Y+13, r22	; 0x0d
    6164:	7e 87       	std	Y+14, r23	; 0x0e
    6166:	8f 87       	std	Y+15, r24	; 0x0f
    6168:	98 8b       	std	Y+16, r25	; 0x10
    616a:	20 e2       	ldi	r18, 0x20	; 32
    616c:	20 1b       	sub	r18, r16
    616e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6170:	9e 85       	ldd	r25, Y+14	; 0x0e
    6172:	af 85       	ldd	r26, Y+15	; 0x0f
    6174:	b8 89       	ldd	r27, Y+16	; 0x10
    6176:	ac 01       	movw	r20, r24
    6178:	bd 01       	movw	r22, r26
    617a:	12 16       	cp	r1, r18
    617c:	b4 f0       	brlt	.+44     	; 0x61aa <__ashrdi3+0x66>
    617e:	77 0f       	add	r23, r23
    6180:	44 0b       	sbc	r20, r20
    6182:	54 2f       	mov	r21, r20
    6184:	ba 01       	movw	r22, r20
    6186:	4d 83       	std	Y+5, r20	; 0x05
    6188:	5e 83       	std	Y+6, r21	; 0x06
    618a:	6f 83       	std	Y+7, r22	; 0x07
    618c:	78 87       	std	Y+8, r23	; 0x08
    618e:	33 27       	eor	r19, r19
    6190:	27 fd       	sbrc	r18, 7
    6192:	30 95       	com	r19
    6194:	30 95       	com	r19
    6196:	21 95       	neg	r18
    6198:	3f 4f       	sbci	r19, 0xFF	; 255
    619a:	04 c0       	rjmp	.+8      	; 0x61a4 <__ashrdi3+0x60>
    619c:	b5 95       	asr	r27
    619e:	a7 95       	ror	r26
    61a0:	97 95       	ror	r25
    61a2:	87 95       	ror	r24
    61a4:	2a 95       	dec	r18
    61a6:	d2 f7       	brpl	.-12     	; 0x619c <__ashrdi3+0x58>
    61a8:	22 c0       	rjmp	.+68     	; 0x61ee <__ashrdi3+0xaa>
    61aa:	00 2e       	mov	r0, r16
    61ac:	04 c0       	rjmp	.+8      	; 0x61b6 <__ashrdi3+0x72>
    61ae:	75 95       	asr	r23
    61b0:	67 95       	ror	r22
    61b2:	57 95       	ror	r21
    61b4:	47 95       	ror	r20
    61b6:	0a 94       	dec	r0
    61b8:	d2 f7       	brpl	.-12     	; 0x61ae <__ashrdi3+0x6a>
    61ba:	4d 83       	std	Y+5, r20	; 0x05
    61bc:	5e 83       	std	Y+6, r21	; 0x06
    61be:	6f 83       	std	Y+7, r22	; 0x07
    61c0:	78 87       	std	Y+8, r23	; 0x08
    61c2:	04 c0       	rjmp	.+8      	; 0x61cc <__ashrdi3+0x88>
    61c4:	88 0f       	add	r24, r24
    61c6:	99 1f       	adc	r25, r25
    61c8:	aa 1f       	adc	r26, r26
    61ca:	bb 1f       	adc	r27, r27
    61cc:	2a 95       	dec	r18
    61ce:	d2 f7       	brpl	.-12     	; 0x61c4 <__ashrdi3+0x80>
    61d0:	49 85       	ldd	r20, Y+9	; 0x09
    61d2:	5a 85       	ldd	r21, Y+10	; 0x0a
    61d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    61d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    61d8:	04 c0       	rjmp	.+8      	; 0x61e2 <__ashrdi3+0x9e>
    61da:	76 95       	lsr	r23
    61dc:	67 95       	ror	r22
    61de:	57 95       	ror	r21
    61e0:	47 95       	ror	r20
    61e2:	0a 95       	dec	r16
    61e4:	d2 f7       	brpl	.-12     	; 0x61da <__ashrdi3+0x96>
    61e6:	84 2b       	or	r24, r20
    61e8:	95 2b       	or	r25, r21
    61ea:	a6 2b       	or	r26, r22
    61ec:	b7 2b       	or	r27, r23
    61ee:	89 83       	std	Y+1, r24	; 0x01
    61f0:	9a 83       	std	Y+2, r25	; 0x02
    61f2:	ab 83       	std	Y+3, r26	; 0x03
    61f4:	bc 83       	std	Y+4, r27	; 0x04
    61f6:	29 81       	ldd	r18, Y+1	; 0x01
    61f8:	3a 81       	ldd	r19, Y+2	; 0x02
    61fa:	4b 81       	ldd	r20, Y+3	; 0x03
    61fc:	5c 81       	ldd	r21, Y+4	; 0x04
    61fe:	6d 81       	ldd	r22, Y+5	; 0x05
    6200:	7e 81       	ldd	r23, Y+6	; 0x06
    6202:	8f 81       	ldd	r24, Y+7	; 0x07
    6204:	98 85       	ldd	r25, Y+8	; 0x08
    6206:	60 96       	adiw	r28, 0x10	; 16
    6208:	cd bf       	out	0x3d, r28	; 61
    620a:	de bf       	out	0x3e, r29	; 62
    620c:	df 91       	pop	r29
    620e:	cf 91       	pop	r28
    6210:	0f 91       	pop	r16
    6212:	08 95       	ret

00006214 <__divdi3>:
    6214:	a8 e4       	ldi	r26, 0x48	; 72
    6216:	b0 e0       	ldi	r27, 0x00	; 0
    6218:	e0 e1       	ldi	r30, 0x10	; 16
    621a:	f1 e3       	ldi	r31, 0x31	; 49
    621c:	0c 94 f9 3a 	jmp	0x75f2	; 0x75f2 <__prologue_saves__+0x2>
    6220:	f5 01       	movw	r30, r10
    6222:	29 a3       	lds	r18, 0x59
    6224:	3a a3       	lds	r19, 0x5a
    6226:	4b a3       	lds	r20, 0x5b
    6228:	5c a3       	lds	r21, 0x5c
    622a:	6d a3       	lds	r22, 0x5d
    622c:	7e a3       	lds	r23, 0x5e
    622e:	8f a3       	lds	r24, 0x5f
    6230:	98 a7       	lds	r25, 0x78
    6232:	a9 8e       	std	Y+25, r10	; 0x19
    6234:	fa 8f       	std	Y+26, r31	; 0x1a
    6236:	cb 8e       	std	Y+27, r12	; 0x1b
    6238:	dc 8e       	std	Y+28, r13	; 0x1c
    623a:	ed 8e       	std	Y+29, r14	; 0x1d
    623c:	fe 8e       	std	Y+30, r15	; 0x1e
    623e:	0f 8f       	std	Y+31, r16	; 0x1f
    6240:	18 a3       	lds	r17, 0x58
    6242:	8d a0       	lds	r24, 0x8d
    6244:	9e a0       	lds	r25, 0x8e
    6246:	af a0       	lds	r26, 0x8f
    6248:	b8 a4       	lds	r27, 0xa8
    624a:	b7 fe       	sbrs	r11, 7
    624c:	67 c0       	rjmp	.+206    	; 0x631c <__divdi3+0x108>
    624e:	21 95       	neg	r18
    6250:	b1 e0       	ldi	r27, 0x01	; 1
    6252:	12 16       	cp	r1, r18
    6254:	08 f0       	brcs	.+2      	; 0x6258 <__divdi3+0x44>
    6256:	b0 e0       	ldi	r27, 0x00	; 0
    6258:	31 95       	neg	r19
    625a:	a1 e0       	ldi	r26, 0x01	; 1
    625c:	13 16       	cp	r1, r19
    625e:	08 f0       	brcs	.+2      	; 0x6262 <__divdi3+0x4e>
    6260:	a0 e0       	ldi	r26, 0x00	; 0
    6262:	b3 2e       	mov	r11, r19
    6264:	bb 1a       	sub	r11, r27
    6266:	bb 2d       	mov	r27, r11
    6268:	88 24       	eor	r8, r8
    626a:	83 94       	inc	r8
    626c:	3b 15       	cp	r19, r11
    626e:	08 f0       	brcs	.+2      	; 0x6272 <__divdi3+0x5e>
    6270:	88 24       	eor	r8, r8
    6272:	a8 29       	or	r26, r8
    6274:	41 95       	neg	r20
    6276:	31 e0       	ldi	r19, 0x01	; 1
    6278:	14 16       	cp	r1, r20
    627a:	08 f0       	brcs	.+2      	; 0x627e <__divdi3+0x6a>
    627c:	30 e0       	ldi	r19, 0x00	; 0
    627e:	b4 2e       	mov	r11, r20
    6280:	ba 1a       	sub	r11, r26
    6282:	ab 2d       	mov	r26, r11
    6284:	88 24       	eor	r8, r8
    6286:	83 94       	inc	r8
    6288:	4b 15       	cp	r20, r11
    628a:	08 f0       	brcs	.+2      	; 0x628e <__divdi3+0x7a>
    628c:	88 24       	eor	r8, r8
    628e:	38 29       	or	r19, r8
    6290:	51 95       	neg	r21
    6292:	41 e0       	ldi	r20, 0x01	; 1
    6294:	15 16       	cp	r1, r21
    6296:	08 f0       	brcs	.+2      	; 0x629a <__divdi3+0x86>
    6298:	40 e0       	ldi	r20, 0x00	; 0
    629a:	45 2e       	mov	r4, r21
    629c:	43 1a       	sub	r4, r19
    629e:	31 e0       	ldi	r19, 0x01	; 1
    62a0:	54 15       	cp	r21, r4
    62a2:	08 f0       	brcs	.+2      	; 0x62a6 <__divdi3+0x92>
    62a4:	30 e0       	ldi	r19, 0x00	; 0
    62a6:	43 2b       	or	r20, r19
    62a8:	61 95       	neg	r22
    62aa:	31 e0       	ldi	r19, 0x01	; 1
    62ac:	16 16       	cp	r1, r22
    62ae:	08 f0       	brcs	.+2      	; 0x62b2 <__divdi3+0x9e>
    62b0:	30 e0       	ldi	r19, 0x00	; 0
    62b2:	86 2e       	mov	r8, r22
    62b4:	84 1a       	sub	r8, r20
    62b6:	41 e0       	ldi	r20, 0x01	; 1
    62b8:	68 15       	cp	r22, r8
    62ba:	08 f0       	brcs	.+2      	; 0x62be <__divdi3+0xaa>
    62bc:	40 e0       	ldi	r20, 0x00	; 0
    62be:	34 2b       	or	r19, r20
    62c0:	71 95       	neg	r23
    62c2:	41 e0       	ldi	r20, 0x01	; 1
    62c4:	17 16       	cp	r1, r23
    62c6:	08 f0       	brcs	.+2      	; 0x62ca <__divdi3+0xb6>
    62c8:	40 e0       	ldi	r20, 0x00	; 0
    62ca:	57 2f       	mov	r21, r23
    62cc:	53 1b       	sub	r21, r19
    62ce:	31 e0       	ldi	r19, 0x01	; 1
    62d0:	75 17       	cp	r23, r21
    62d2:	08 f0       	brcs	.+2      	; 0x62d6 <__divdi3+0xc2>
    62d4:	30 e0       	ldi	r19, 0x00	; 0
    62d6:	43 2b       	or	r20, r19
    62d8:	81 95       	neg	r24
    62da:	31 e0       	ldi	r19, 0x01	; 1
    62dc:	18 16       	cp	r1, r24
    62de:	08 f0       	brcs	.+2      	; 0x62e2 <__divdi3+0xce>
    62e0:	30 e0       	ldi	r19, 0x00	; 0
    62e2:	68 2f       	mov	r22, r24
    62e4:	64 1b       	sub	r22, r20
    62e6:	46 2f       	mov	r20, r22
    62e8:	61 e0       	ldi	r22, 0x01	; 1
    62ea:	84 17       	cp	r24, r20
    62ec:	08 f0       	brcs	.+2      	; 0x62f0 <__divdi3+0xdc>
    62ee:	60 e0       	ldi	r22, 0x00	; 0
    62f0:	36 2b       	or	r19, r22
    62f2:	91 95       	neg	r25
    62f4:	93 1b       	sub	r25, r19
    62f6:	29 a3       	lds	r18, 0x59
    62f8:	ba a3       	lds	r27, 0x5a
    62fa:	ab a3       	lds	r26, 0x5b
    62fc:	4c a2       	lds	r20, 0x9c
    62fe:	8d a2       	lds	r24, 0x9d
    6300:	5e a3       	lds	r21, 0x5e
    6302:	4f a3       	lds	r20, 0x5f
    6304:	98 a7       	lds	r25, 0x78
    6306:	8f ef       	ldi	r24, 0xFF	; 255
    6308:	9f ef       	ldi	r25, 0xFF	; 255
    630a:	af ef       	ldi	r26, 0xFF	; 255
    630c:	bf ef       	ldi	r27, 0xFF	; 255
    630e:	25 96       	adiw	r28, 0x05	; 5
    6310:	8c af       	sts	0x7c, r24
    6312:	9d af       	sts	0x7d, r25
    6314:	ae af       	sts	0x7e, r26
    6316:	bf af       	sts	0x7f, r27
    6318:	25 97       	sbiw	r28, 0x05	; 5
    631a:	06 c0       	rjmp	.+12     	; 0x6328 <__divdi3+0x114>
    631c:	25 96       	adiw	r28, 0x05	; 5
    631e:	1c ae       	sts	0xbc, r17
    6320:	1d ae       	sts	0xbd, r17
    6322:	1e ae       	sts	0xbe, r17
    6324:	1f ae       	sts	0xbf, r17
    6326:	25 97       	sbiw	r28, 0x05	; 5
    6328:	8d 8d       	ldd	r24, Y+29	; 0x1d
    632a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    632c:	af 8d       	ldd	r26, Y+31	; 0x1f
    632e:	b8 a1       	lds	r27, 0x48
    6330:	b7 ff       	sbrs	r27, 7
    6332:	68 c0       	rjmp	.+208    	; 0x6404 <__divdi3+0x1f0>
    6334:	25 96       	adiw	r28, 0x05	; 5
    6336:	2c ad       	sts	0x6c, r18
    6338:	3d ad       	sts	0x6d, r19
    633a:	4e ad       	sts	0x6e, r20
    633c:	5f ad       	sts	0x6f, r21
    633e:	25 97       	sbiw	r28, 0x05	; 5
    6340:	20 95       	com	r18
    6342:	30 95       	com	r19
    6344:	40 95       	com	r20
    6346:	50 95       	com	r21
    6348:	25 96       	adiw	r28, 0x05	; 5
    634a:	2c af       	sts	0x7c, r18
    634c:	3d af       	sts	0x7d, r19
    634e:	4e af       	sts	0x7e, r20
    6350:	5f af       	sts	0x7f, r21
    6352:	25 97       	sbiw	r28, 0x05	; 5
    6354:	e1 95       	neg	r30
    6356:	81 e0       	ldi	r24, 0x01	; 1
    6358:	1e 16       	cp	r1, r30
    635a:	08 f0       	brcs	.+2      	; 0x635e <__divdi3+0x14a>
    635c:	80 e0       	ldi	r24, 0x00	; 0
    635e:	f1 95       	neg	r31
    6360:	91 e0       	ldi	r25, 0x01	; 1
    6362:	1f 16       	cp	r1, r31
    6364:	08 f0       	brcs	.+2      	; 0x6368 <__divdi3+0x154>
    6366:	90 e0       	ldi	r25, 0x00	; 0
    6368:	4f 2f       	mov	r20, r31
    636a:	48 1b       	sub	r20, r24
    636c:	81 e0       	ldi	r24, 0x01	; 1
    636e:	f4 17       	cp	r31, r20
    6370:	08 f0       	brcs	.+2      	; 0x6374 <__divdi3+0x160>
    6372:	80 e0       	ldi	r24, 0x00	; 0
    6374:	98 2b       	or	r25, r24
    6376:	c1 94       	neg	r12
    6378:	81 e0       	ldi	r24, 0x01	; 1
    637a:	1c 14       	cp	r1, r12
    637c:	08 f0       	brcs	.+2      	; 0x6380 <__divdi3+0x16c>
    637e:	80 e0       	ldi	r24, 0x00	; 0
    6380:	6c 2d       	mov	r22, r12
    6382:	69 1b       	sub	r22, r25
    6384:	91 e0       	ldi	r25, 0x01	; 1
    6386:	c6 16       	cp	r12, r22
    6388:	08 f0       	brcs	.+2      	; 0x638c <__divdi3+0x178>
    638a:	90 e0       	ldi	r25, 0x00	; 0
    638c:	89 2b       	or	r24, r25
    638e:	d1 94       	neg	r13
    6390:	91 e0       	ldi	r25, 0x01	; 1
    6392:	1d 14       	cp	r1, r13
    6394:	08 f0       	brcs	.+2      	; 0x6398 <__divdi3+0x184>
    6396:	90 e0       	ldi	r25, 0x00	; 0
    6398:	5d 2d       	mov	r21, r13
    639a:	58 1b       	sub	r21, r24
    639c:	81 e0       	ldi	r24, 0x01	; 1
    639e:	d5 16       	cp	r13, r21
    63a0:	08 f0       	brcs	.+2      	; 0x63a4 <__divdi3+0x190>
    63a2:	80 e0       	ldi	r24, 0x00	; 0
    63a4:	98 2b       	or	r25, r24
    63a6:	e1 94       	neg	r14
    63a8:	81 e0       	ldi	r24, 0x01	; 1
    63aa:	1e 14       	cp	r1, r14
    63ac:	08 f0       	brcs	.+2      	; 0x63b0 <__divdi3+0x19c>
    63ae:	80 e0       	ldi	r24, 0x00	; 0
    63b0:	3e 2d       	mov	r19, r14
    63b2:	39 1b       	sub	r19, r25
    63b4:	91 e0       	ldi	r25, 0x01	; 1
    63b6:	e3 16       	cp	r14, r19
    63b8:	08 f0       	brcs	.+2      	; 0x63bc <__divdi3+0x1a8>
    63ba:	90 e0       	ldi	r25, 0x00	; 0
    63bc:	89 2b       	or	r24, r25
    63be:	f1 94       	neg	r15
    63c0:	91 e0       	ldi	r25, 0x01	; 1
    63c2:	1f 14       	cp	r1, r15
    63c4:	08 f0       	brcs	.+2      	; 0x63c8 <__divdi3+0x1b4>
    63c6:	90 e0       	ldi	r25, 0x00	; 0
    63c8:	2f 2d       	mov	r18, r15
    63ca:	28 1b       	sub	r18, r24
    63cc:	81 e0       	ldi	r24, 0x01	; 1
    63ce:	f2 16       	cp	r15, r18
    63d0:	08 f0       	brcs	.+2      	; 0x63d4 <__divdi3+0x1c0>
    63d2:	80 e0       	ldi	r24, 0x00	; 0
    63d4:	98 2b       	or	r25, r24
    63d6:	01 95       	neg	r16
    63d8:	81 e0       	ldi	r24, 0x01	; 1
    63da:	10 16       	cp	r1, r16
    63dc:	08 f0       	brcs	.+2      	; 0x63e0 <__divdi3+0x1cc>
    63de:	80 e0       	ldi	r24, 0x00	; 0
    63e0:	70 2f       	mov	r23, r16
    63e2:	79 1b       	sub	r23, r25
    63e4:	97 2f       	mov	r25, r23
    63e6:	71 e0       	ldi	r23, 0x01	; 1
    63e8:	09 17       	cp	r16, r25
    63ea:	08 f0       	brcs	.+2      	; 0x63ee <__divdi3+0x1da>
    63ec:	70 e0       	ldi	r23, 0x00	; 0
    63ee:	87 2b       	or	r24, r23
    63f0:	11 95       	neg	r17
    63f2:	18 1b       	sub	r17, r24
    63f4:	e9 8f       	std	Y+25, r30	; 0x19
    63f6:	4a 8f       	std	Y+26, r20	; 0x1a
    63f8:	6b 8f       	std	Y+27, r22	; 0x1b
    63fa:	5c 8f       	std	Y+28, r21	; 0x1c
    63fc:	3d 8f       	std	Y+29, r19	; 0x1d
    63fe:	2e 8f       	std	Y+30, r18	; 0x1e
    6400:	9f 8f       	std	Y+31, r25	; 0x1f
    6402:	18 a3       	lds	r17, 0x58
    6404:	79 8d       	ldd	r23, Y+25	; 0x19
    6406:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6408:	5b 8d       	ldd	r21, Y+27	; 0x1b
    640a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    640c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    640e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    6410:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6412:	88 a1       	lds	r24, 0x48
    6414:	e9 a1       	lds	r30, 0x49
    6416:	e9 8b       	std	Y+17, r30	; 0x11
    6418:	ea a1       	lds	r30, 0x4a
    641a:	ea 8b       	std	Y+18, r30	; 0x12
    641c:	eb a1       	lds	r30, 0x4b
    641e:	eb 8b       	std	Y+19, r30	; 0x13
    6420:	ec a1       	lds	r30, 0x4c
    6422:	ec 8b       	std	Y+20, r30	; 0x14
    6424:	ed a1       	lds	r30, 0x4d
    6426:	ed 8b       	std	Y+21, r30	; 0x15
    6428:	ee a1       	lds	r30, 0x4e
    642a:	ee 8b       	std	Y+22, r30	; 0x16
    642c:	ef a1       	lds	r30, 0x4f
    642e:	ef 8b       	std	Y+23, r30	; 0x17
    6430:	e8 a5       	lds	r30, 0x68
    6432:	e8 8f       	std	Y+24, r30	; 0x18
    6434:	79 87       	std	Y+9, r23	; 0x09
    6436:	6a 87       	std	Y+10, r22	; 0x0a
    6438:	5b 87       	std	Y+11, r21	; 0x0b
    643a:	4c 87       	std	Y+12, r20	; 0x0c
    643c:	3d 87       	std	Y+13, r19	; 0x0d
    643e:	2e 87       	std	Y+14, r18	; 0x0e
    6440:	9f 87       	std	Y+15, r25	; 0x0f
    6442:	88 8b       	std	Y+16, r24	; 0x10
    6444:	89 84       	ldd	r8, Y+9	; 0x09
    6446:	9a 84       	ldd	r9, Y+10	; 0x0a
    6448:	ab 84       	ldd	r10, Y+11	; 0x0b
    644a:	bc 84       	ldd	r11, Y+12	; 0x0c
    644c:	8d 85       	ldd	r24, Y+13	; 0x0d
    644e:	9e 85       	ldd	r25, Y+14	; 0x0e
    6450:	af 85       	ldd	r26, Y+15	; 0x0f
    6452:	b8 89       	ldd	r27, Y+16	; 0x10
    6454:	e9 88       	ldd	r14, Y+17	; 0x11
    6456:	fa 88       	ldd	r15, Y+18	; 0x12
    6458:	0b 89       	ldd	r16, Y+19	; 0x13
    645a:	1c 89       	ldd	r17, Y+20	; 0x14
    645c:	ed aa       	sts	0x9d, r30
    645e:	fe aa       	sts	0x9e, r31
    6460:	0f ab       	sts	0x5f, r16
    6462:	18 af       	sts	0x78, r17
    6464:	cd 88       	ldd	r12, Y+21	; 0x15
    6466:	de 88       	ldd	r13, Y+22	; 0x16
    6468:	ef 88       	ldd	r14, Y+23	; 0x17
    646a:	f8 8c       	ldd	r15, Y+24	; 0x18
    646c:	00 97       	sbiw	r24, 0x00	; 0
    646e:	a1 05       	cpc	r26, r1
    6470:	b1 05       	cpc	r27, r1
    6472:	09 f0       	breq	.+2      	; 0x6476 <__divdi3+0x262>
    6474:	bd c3       	rjmp	.+1914   	; 0x6bf0 <__divdi3+0x9dc>
    6476:	c8 14       	cp	r12, r8
    6478:	d9 04       	cpc	r13, r9
    647a:	ea 04       	cpc	r14, r10
    647c:	fb 04       	cpc	r15, r11
    647e:	08 f0       	brcs	.+2      	; 0x6482 <__divdi3+0x26e>
    6480:	4d c1       	rjmp	.+666    	; 0x671c <__divdi3+0x508>
    6482:	00 e0       	ldi	r16, 0x00	; 0
    6484:	80 16       	cp	r8, r16
    6486:	00 e0       	ldi	r16, 0x00	; 0
    6488:	90 06       	cpc	r9, r16
    648a:	01 e0       	ldi	r16, 0x01	; 1
    648c:	a0 06       	cpc	r10, r16
    648e:	00 e0       	ldi	r16, 0x00	; 0
    6490:	b0 06       	cpc	r11, r16
    6492:	58 f4       	brcc	.+22     	; 0x64aa <__divdi3+0x296>
    6494:	1f ef       	ldi	r17, 0xFF	; 255
    6496:	81 16       	cp	r8, r17
    6498:	91 04       	cpc	r9, r1
    649a:	a1 04       	cpc	r10, r1
    649c:	b1 04       	cpc	r11, r1
    649e:	09 f0       	breq	.+2      	; 0x64a2 <__divdi3+0x28e>
    64a0:	90 f4       	brcc	.+36     	; 0x64c6 <__divdi3+0x2b2>
    64a2:	80 e0       	ldi	r24, 0x00	; 0
    64a4:	90 e0       	ldi	r25, 0x00	; 0
    64a6:	dc 01       	movw	r26, r24
    64a8:	17 c0       	rjmp	.+46     	; 0x64d8 <__divdi3+0x2c4>
    64aa:	20 e0       	ldi	r18, 0x00	; 0
    64ac:	82 16       	cp	r8, r18
    64ae:	20 e0       	ldi	r18, 0x00	; 0
    64b0:	92 06       	cpc	r9, r18
    64b2:	20 e0       	ldi	r18, 0x00	; 0
    64b4:	a2 06       	cpc	r10, r18
    64b6:	21 e0       	ldi	r18, 0x01	; 1
    64b8:	b2 06       	cpc	r11, r18
    64ba:	50 f4       	brcc	.+20     	; 0x64d0 <__divdi3+0x2bc>
    64bc:	80 e1       	ldi	r24, 0x10	; 16
    64be:	90 e0       	ldi	r25, 0x00	; 0
    64c0:	a0 e0       	ldi	r26, 0x00	; 0
    64c2:	b0 e0       	ldi	r27, 0x00	; 0
    64c4:	09 c0       	rjmp	.+18     	; 0x64d8 <__divdi3+0x2c4>
    64c6:	88 e0       	ldi	r24, 0x08	; 8
    64c8:	90 e0       	ldi	r25, 0x00	; 0
    64ca:	a0 e0       	ldi	r26, 0x00	; 0
    64cc:	b0 e0       	ldi	r27, 0x00	; 0
    64ce:	04 c0       	rjmp	.+8      	; 0x64d8 <__divdi3+0x2c4>
    64d0:	88 e1       	ldi	r24, 0x18	; 24
    64d2:	90 e0       	ldi	r25, 0x00	; 0
    64d4:	a0 e0       	ldi	r26, 0x00	; 0
    64d6:	b0 e0       	ldi	r27, 0x00	; 0
    64d8:	b5 01       	movw	r22, r10
    64da:	a4 01       	movw	r20, r8
    64dc:	08 2e       	mov	r0, r24
    64de:	04 c0       	rjmp	.+8      	; 0x64e8 <__divdi3+0x2d4>
    64e0:	76 95       	lsr	r23
    64e2:	67 95       	ror	r22
    64e4:	57 95       	ror	r21
    64e6:	47 95       	ror	r20
    64e8:	0a 94       	dec	r0
    64ea:	d2 f7       	brpl	.-12     	; 0x64e0 <__divdi3+0x2cc>
    64ec:	fa 01       	movw	r30, r20
    64ee:	e9 5c       	subi	r30, 0xC9	; 201
    64f0:	ff 4d       	sbci	r31, 0xDF	; 223
    64f2:	20 81       	ld	r18, Z
    64f4:	40 e2       	ldi	r20, 0x20	; 32
    64f6:	50 e0       	ldi	r21, 0x00	; 0
    64f8:	60 e0       	ldi	r22, 0x00	; 0
    64fa:	70 e0       	ldi	r23, 0x00	; 0
    64fc:	48 1b       	sub	r20, r24
    64fe:	59 0b       	sbc	r21, r25
    6500:	6a 0b       	sbc	r22, r26
    6502:	7b 0b       	sbc	r23, r27
    6504:	42 1b       	sub	r20, r18
    6506:	51 09       	sbc	r21, r1
    6508:	61 09       	sbc	r22, r1
    650a:	71 09       	sbc	r23, r1
    650c:	41 15       	cp	r20, r1
    650e:	51 05       	cpc	r21, r1
    6510:	61 05       	cpc	r22, r1
    6512:	71 05       	cpc	r23, r1
    6514:	a1 f1       	breq	.+104    	; 0x657e <__divdi3+0x36a>
    6516:	04 2e       	mov	r0, r20
    6518:	04 c0       	rjmp	.+8      	; 0x6522 <__divdi3+0x30e>
    651a:	88 0c       	add	r8, r8
    651c:	99 1c       	adc	r9, r9
    651e:	aa 1c       	adc	r10, r10
    6520:	bb 1c       	adc	r11, r11
    6522:	0a 94       	dec	r0
    6524:	d2 f7       	brpl	.-12     	; 0x651a <__divdi3+0x306>
    6526:	97 01       	movw	r18, r14
    6528:	86 01       	movw	r16, r12
    652a:	04 2e       	mov	r0, r20
    652c:	04 c0       	rjmp	.+8      	; 0x6536 <__divdi3+0x322>
    652e:	00 0f       	add	r16, r16
    6530:	11 1f       	adc	r17, r17
    6532:	22 1f       	adc	r18, r18
    6534:	33 1f       	adc	r19, r19
    6536:	0a 94       	dec	r0
    6538:	d2 f7       	brpl	.-12     	; 0x652e <__divdi3+0x31a>
    653a:	80 e2       	ldi	r24, 0x20	; 32
    653c:	90 e0       	ldi	r25, 0x00	; 0
    653e:	84 1b       	sub	r24, r20
    6540:	95 0b       	sbc	r25, r21
    6542:	cd a8       	sts	0x8d, r28
    6544:	de a8       	sts	0x8e, r29
    6546:	ef a8       	sts	0x8f, r30
    6548:	f8 ac       	sts	0xa8, r31
    654a:	04 c0       	rjmp	.+8      	; 0x6554 <__divdi3+0x340>
    654c:	f6 94       	lsr	r15
    654e:	e7 94       	ror	r14
    6550:	d7 94       	ror	r13
    6552:	c7 94       	ror	r12
    6554:	8a 95       	dec	r24
    6556:	d2 f7       	brpl	.-12     	; 0x654c <__divdi3+0x338>
    6558:	c0 2a       	or	r12, r16
    655a:	d1 2a       	or	r13, r17
    655c:	e2 2a       	or	r14, r18
    655e:	f3 2a       	or	r15, r19
    6560:	0d a9       	sts	0x4d, r16
    6562:	1e a9       	sts	0x4e, r17
    6564:	2f a9       	sts	0x4f, r18
    6566:	38 ad       	sts	0x68, r19
    6568:	04 c0       	rjmp	.+8      	; 0x6572 <__divdi3+0x35e>
    656a:	00 0f       	add	r16, r16
    656c:	11 1f       	adc	r17, r17
    656e:	22 1f       	adc	r18, r18
    6570:	33 1f       	adc	r19, r19
    6572:	4a 95       	dec	r20
    6574:	d2 f7       	brpl	.-12     	; 0x656a <__divdi3+0x356>
    6576:	0d ab       	sts	0x5d, r16
    6578:	1e ab       	sts	0x5e, r17
    657a:	2f ab       	sts	0x5f, r18
    657c:	38 af       	sts	0x78, r19
    657e:	25 01       	movw	r4, r10
    6580:	66 24       	eor	r6, r6
    6582:	77 24       	eor	r7, r7
    6584:	95 01       	movw	r18, r10
    6586:	84 01       	movw	r16, r8
    6588:	20 70       	andi	r18, 0x00	; 0
    658a:	30 70       	andi	r19, 0x00	; 0
    658c:	09 ab       	sts	0x59, r16
    658e:	1a ab       	sts	0x5a, r17
    6590:	2b ab       	sts	0x5b, r18
    6592:	3c ab       	sts	0x5c, r19
    6594:	c7 01       	movw	r24, r14
    6596:	b6 01       	movw	r22, r12
    6598:	a3 01       	movw	r20, r6
    659a:	92 01       	movw	r18, r4
    659c:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    65a0:	2d a7       	lds	r18, 0x7d
    65a2:	3e a7       	lds	r19, 0x7e
    65a4:	4f a7       	lds	r20, 0x7f
    65a6:	58 ab       	sts	0x58, r21
    65a8:	69 a7       	lds	r22, 0x79
    65aa:	7a a7       	lds	r23, 0x7a
    65ac:	8b a7       	lds	r24, 0x7b
    65ae:	9c a7       	lds	r25, 0x7c
    65b0:	c7 01       	movw	r24, r14
    65b2:	b6 01       	movw	r22, r12
    65b4:	a3 01       	movw	r20, r6
    65b6:	92 01       	movw	r18, r4
    65b8:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    65bc:	ca 01       	movw	r24, r20
    65be:	b9 01       	movw	r22, r18
    65c0:	29 a9       	sts	0x49, r18
    65c2:	3a a9       	sts	0x4a, r19
    65c4:	4b a9       	sts	0x4b, r20
    65c6:	5c a9       	sts	0x4c, r21
    65c8:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    65cc:	ab 01       	movw	r20, r22
    65ce:	bc 01       	movw	r22, r24
    65d0:	09 a5       	lds	r16, 0x69
    65d2:	1a a5       	lds	r17, 0x6a
    65d4:	2b a5       	lds	r18, 0x6b
    65d6:	3c a5       	lds	r19, 0x6c
    65d8:	78 01       	movw	r14, r16
    65da:	dd 24       	eor	r13, r13
    65dc:	cc 24       	eor	r12, r12
    65de:	0d a9       	sts	0x4d, r16
    65e0:	1e a9       	sts	0x4e, r17
    65e2:	2f a9       	sts	0x4f, r18
    65e4:	38 ad       	sts	0x68, r19
    65e6:	c9 01       	movw	r24, r18
    65e8:	aa 27       	eor	r26, r26
    65ea:	bb 27       	eor	r27, r27
    65ec:	c8 2a       	or	r12, r24
    65ee:	d9 2a       	or	r13, r25
    65f0:	ea 2a       	or	r14, r26
    65f2:	fb 2a       	or	r15, r27
    65f4:	0d a5       	lds	r16, 0x6d
    65f6:	1e a5       	lds	r17, 0x6e
    65f8:	2f a5       	lds	r18, 0x6f
    65fa:	38 a9       	sts	0x48, r19
    65fc:	c4 16       	cp	r12, r20
    65fe:	d5 06       	cpc	r13, r21
    6600:	e6 06       	cpc	r14, r22
    6602:	f7 06       	cpc	r15, r23
    6604:	38 f5       	brcc	.+78     	; 0x6654 <__divdi3+0x440>
    6606:	01 50       	subi	r16, 0x01	; 1
    6608:	10 40       	sbci	r17, 0x00	; 0
    660a:	20 40       	sbci	r18, 0x00	; 0
    660c:	30 40       	sbci	r19, 0x00	; 0
    660e:	09 a7       	lds	r16, 0x79
    6610:	1a a7       	lds	r17, 0x7a
    6612:	2b a7       	lds	r18, 0x7b
    6614:	3c a7       	lds	r19, 0x7c
    6616:	c8 0c       	add	r12, r8
    6618:	d9 1c       	adc	r13, r9
    661a:	ea 1c       	adc	r14, r10
    661c:	fb 1c       	adc	r15, r11
    661e:	c8 14       	cp	r12, r8
    6620:	d9 04       	cpc	r13, r9
    6622:	ea 04       	cpc	r14, r10
    6624:	fb 04       	cpc	r15, r11
    6626:	d0 f0       	brcs	.+52     	; 0x665c <__divdi3+0x448>
    6628:	c4 16       	cp	r12, r20
    662a:	d5 06       	cpc	r13, r21
    662c:	e6 06       	cpc	r14, r22
    662e:	f7 06       	cpc	r15, r23
    6630:	a8 f4       	brcc	.+42     	; 0x665c <__divdi3+0x448>
    6632:	0d a5       	lds	r16, 0x6d
    6634:	1e a5       	lds	r17, 0x6e
    6636:	2f a5       	lds	r18, 0x6f
    6638:	38 a9       	sts	0x48, r19
    663a:	02 50       	subi	r16, 0x02	; 2
    663c:	10 40       	sbci	r17, 0x00	; 0
    663e:	20 40       	sbci	r18, 0x00	; 0
    6640:	30 40       	sbci	r19, 0x00	; 0
    6642:	09 a7       	lds	r16, 0x79
    6644:	1a a7       	lds	r17, 0x7a
    6646:	2b a7       	lds	r18, 0x7b
    6648:	3c a7       	lds	r19, 0x7c
    664a:	c8 0c       	add	r12, r8
    664c:	d9 1c       	adc	r13, r9
    664e:	ea 1c       	adc	r14, r10
    6650:	fb 1c       	adc	r15, r11
    6652:	04 c0       	rjmp	.+8      	; 0x665c <__divdi3+0x448>
    6654:	09 a7       	lds	r16, 0x79
    6656:	1a a7       	lds	r17, 0x7a
    6658:	2b a7       	lds	r18, 0x7b
    665a:	3c a7       	lds	r19, 0x7c
    665c:	c4 1a       	sub	r12, r20
    665e:	d5 0a       	sbc	r13, r21
    6660:	e6 0a       	sbc	r14, r22
    6662:	f7 0a       	sbc	r15, r23
    6664:	c7 01       	movw	r24, r14
    6666:	b6 01       	movw	r22, r12
    6668:	a3 01       	movw	r20, r6
    666a:	92 01       	movw	r18, r4
    666c:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6670:	2d a7       	lds	r18, 0x7d
    6672:	3e a7       	lds	r19, 0x7e
    6674:	4f a7       	lds	r20, 0x7f
    6676:	58 ab       	sts	0x58, r21
    6678:	69 af       	sts	0x79, r22
    667a:	7a af       	sts	0x7a, r23
    667c:	8b af       	sts	0x7b, r24
    667e:	9c af       	sts	0x7c, r25
    6680:	c7 01       	movw	r24, r14
    6682:	b6 01       	movw	r22, r12
    6684:	a3 01       	movw	r20, r6
    6686:	92 01       	movw	r18, r4
    6688:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    668c:	ca 01       	movw	r24, r20
    668e:	b9 01       	movw	r22, r18
    6690:	29 a9       	sts	0x49, r18
    6692:	3a a9       	sts	0x4a, r19
    6694:	4b a9       	sts	0x4b, r20
    6696:	5c a9       	sts	0x4c, r21
    6698:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    669c:	6b 01       	movw	r12, r22
    669e:	7c 01       	movw	r14, r24
    66a0:	49 ad       	sts	0x69, r20
    66a2:	5a ad       	sts	0x6a, r21
    66a4:	6b ad       	sts	0x6b, r22
    66a6:	7c ad       	sts	0x6c, r23
    66a8:	9a 01       	movw	r18, r20
    66aa:	11 27       	eor	r17, r17
    66ac:	00 27       	eor	r16, r16
    66ae:	4d a9       	sts	0x4d, r20
    66b0:	5e a9       	sts	0x4e, r21
    66b2:	6f a9       	sts	0x4f, r22
    66b4:	78 ad       	sts	0x68, r23
    66b6:	60 70       	andi	r22, 0x00	; 0
    66b8:	70 70       	andi	r23, 0x00	; 0
    66ba:	04 2b       	or	r16, r20
    66bc:	15 2b       	or	r17, r21
    66be:	26 2b       	or	r18, r22
    66c0:	37 2b       	or	r19, r23
    66c2:	8d a5       	lds	r24, 0x6d
    66c4:	9e a5       	lds	r25, 0x6e
    66c6:	af a5       	lds	r26, 0x6f
    66c8:	b8 a9       	sts	0x48, r27
    66ca:	0c 15       	cp	r16, r12
    66cc:	1d 05       	cpc	r17, r13
    66ce:	2e 05       	cpc	r18, r14
    66d0:	3f 05       	cpc	r19, r15
    66d2:	c0 f4       	brcc	.+48     	; 0x6704 <__divdi3+0x4f0>
    66d4:	01 97       	sbiw	r24, 0x01	; 1
    66d6:	a1 09       	sbc	r26, r1
    66d8:	b1 09       	sbc	r27, r1
    66da:	08 0d       	add	r16, r8
    66dc:	19 1d       	adc	r17, r9
    66de:	2a 1d       	adc	r18, r10
    66e0:	3b 1d       	adc	r19, r11
    66e2:	08 15       	cp	r16, r8
    66e4:	19 05       	cpc	r17, r9
    66e6:	2a 05       	cpc	r18, r10
    66e8:	3b 05       	cpc	r19, r11
    66ea:	60 f0       	brcs	.+24     	; 0x6704 <__divdi3+0x4f0>
    66ec:	0c 15       	cp	r16, r12
    66ee:	1d 05       	cpc	r17, r13
    66f0:	2e 05       	cpc	r18, r14
    66f2:	3f 05       	cpc	r19, r15
    66f4:	38 f4       	brcc	.+14     	; 0x6704 <__divdi3+0x4f0>
    66f6:	8d a5       	lds	r24, 0x6d
    66f8:	9e a5       	lds	r25, 0x6e
    66fa:	af a5       	lds	r26, 0x6f
    66fc:	b8 a9       	sts	0x48, r27
    66fe:	02 97       	sbiw	r24, 0x02	; 2
    6700:	a1 09       	sbc	r26, r1
    6702:	b1 09       	sbc	r27, r1
    6704:	09 a5       	lds	r16, 0x69
    6706:	1a a5       	lds	r17, 0x6a
    6708:	2b a5       	lds	r18, 0x6b
    670a:	3c a5       	lds	r19, 0x6c
    670c:	78 01       	movw	r14, r16
    670e:	dd 24       	eor	r13, r13
    6710:	cc 24       	eor	r12, r12
    6712:	c8 2a       	or	r12, r24
    6714:	d9 2a       	or	r13, r25
    6716:	ea 2a       	or	r14, r26
    6718:	fb 2a       	or	r15, r27
    671a:	b7 c4       	rjmp	.+2414   	; 0x708a <__divdi3+0xe76>
    671c:	81 14       	cp	r8, r1
    671e:	91 04       	cpc	r9, r1
    6720:	a1 04       	cpc	r10, r1
    6722:	b1 04       	cpc	r11, r1
    6724:	51 f4       	brne	.+20     	; 0x673a <__divdi3+0x526>
    6726:	61 e0       	ldi	r22, 0x01	; 1
    6728:	70 e0       	ldi	r23, 0x00	; 0
    672a:	80 e0       	ldi	r24, 0x00	; 0
    672c:	90 e0       	ldi	r25, 0x00	; 0
    672e:	a5 01       	movw	r20, r10
    6730:	94 01       	movw	r18, r8
    6732:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6736:	49 01       	movw	r8, r18
    6738:	5a 01       	movw	r10, r20
    673a:	10 e0       	ldi	r17, 0x00	; 0
    673c:	81 16       	cp	r8, r17
    673e:	10 e0       	ldi	r17, 0x00	; 0
    6740:	91 06       	cpc	r9, r17
    6742:	11 e0       	ldi	r17, 0x01	; 1
    6744:	a1 06       	cpc	r10, r17
    6746:	10 e0       	ldi	r17, 0x00	; 0
    6748:	b1 06       	cpc	r11, r17
    674a:	58 f4       	brcc	.+22     	; 0x6762 <__divdi3+0x54e>
    674c:	2f ef       	ldi	r18, 0xFF	; 255
    674e:	82 16       	cp	r8, r18
    6750:	91 04       	cpc	r9, r1
    6752:	a1 04       	cpc	r10, r1
    6754:	b1 04       	cpc	r11, r1
    6756:	09 f0       	breq	.+2      	; 0x675a <__divdi3+0x546>
    6758:	90 f4       	brcc	.+36     	; 0x677e <__divdi3+0x56a>
    675a:	80 e0       	ldi	r24, 0x00	; 0
    675c:	90 e0       	ldi	r25, 0x00	; 0
    675e:	dc 01       	movw	r26, r24
    6760:	17 c0       	rjmp	.+46     	; 0x6790 <__divdi3+0x57c>
    6762:	30 e0       	ldi	r19, 0x00	; 0
    6764:	83 16       	cp	r8, r19
    6766:	30 e0       	ldi	r19, 0x00	; 0
    6768:	93 06       	cpc	r9, r19
    676a:	30 e0       	ldi	r19, 0x00	; 0
    676c:	a3 06       	cpc	r10, r19
    676e:	31 e0       	ldi	r19, 0x01	; 1
    6770:	b3 06       	cpc	r11, r19
    6772:	50 f4       	brcc	.+20     	; 0x6788 <__divdi3+0x574>
    6774:	80 e1       	ldi	r24, 0x10	; 16
    6776:	90 e0       	ldi	r25, 0x00	; 0
    6778:	a0 e0       	ldi	r26, 0x00	; 0
    677a:	b0 e0       	ldi	r27, 0x00	; 0
    677c:	09 c0       	rjmp	.+18     	; 0x6790 <__divdi3+0x57c>
    677e:	88 e0       	ldi	r24, 0x08	; 8
    6780:	90 e0       	ldi	r25, 0x00	; 0
    6782:	a0 e0       	ldi	r26, 0x00	; 0
    6784:	b0 e0       	ldi	r27, 0x00	; 0
    6786:	04 c0       	rjmp	.+8      	; 0x6790 <__divdi3+0x57c>
    6788:	88 e1       	ldi	r24, 0x18	; 24
    678a:	90 e0       	ldi	r25, 0x00	; 0
    678c:	a0 e0       	ldi	r26, 0x00	; 0
    678e:	b0 e0       	ldi	r27, 0x00	; 0
    6790:	b5 01       	movw	r22, r10
    6792:	a4 01       	movw	r20, r8
    6794:	08 2e       	mov	r0, r24
    6796:	04 c0       	rjmp	.+8      	; 0x67a0 <__divdi3+0x58c>
    6798:	76 95       	lsr	r23
    679a:	67 95       	ror	r22
    679c:	57 95       	ror	r21
    679e:	47 95       	ror	r20
    67a0:	0a 94       	dec	r0
    67a2:	d2 f7       	brpl	.-12     	; 0x6798 <__divdi3+0x584>
    67a4:	fa 01       	movw	r30, r20
    67a6:	e9 5c       	subi	r30, 0xC9	; 201
    67a8:	ff 4d       	sbci	r31, 0xDF	; 223
    67aa:	20 81       	ld	r18, Z
    67ac:	ac 01       	movw	r20, r24
    67ae:	bd 01       	movw	r22, r26
    67b0:	42 0f       	add	r20, r18
    67b2:	51 1d       	adc	r21, r1
    67b4:	61 1d       	adc	r22, r1
    67b6:	71 1d       	adc	r23, r1
    67b8:	80 e2       	ldi	r24, 0x20	; 32
    67ba:	90 e0       	ldi	r25, 0x00	; 0
    67bc:	a0 e0       	ldi	r26, 0x00	; 0
    67be:	b0 e0       	ldi	r27, 0x00	; 0
    67c0:	84 1b       	sub	r24, r20
    67c2:	95 0b       	sbc	r25, r21
    67c4:	a6 0b       	sbc	r26, r22
    67c6:	b7 0b       	sbc	r27, r23
    67c8:	51 f4       	brne	.+20     	; 0x67de <__divdi3+0x5ca>
    67ca:	c8 18       	sub	r12, r8
    67cc:	d9 08       	sbc	r13, r9
    67ce:	ea 08       	sbc	r14, r10
    67d0:	fb 08       	sbc	r15, r11
    67d2:	f1 e0       	ldi	r31, 0x01	; 1
    67d4:	4f 2e       	mov	r4, r31
    67d6:	51 2c       	mov	r5, r1
    67d8:	61 2c       	mov	r6, r1
    67da:	71 2c       	mov	r7, r1
    67dc:	28 c1       	rjmp	.+592    	; 0x6a2e <__divdi3+0x81a>
    67de:	08 2e       	mov	r0, r24
    67e0:	04 c0       	rjmp	.+8      	; 0x67ea <__divdi3+0x5d6>
    67e2:	88 0c       	add	r8, r8
    67e4:	99 1c       	adc	r9, r9
    67e6:	aa 1c       	adc	r10, r10
    67e8:	bb 1c       	adc	r11, r11
    67ea:	0a 94       	dec	r0
    67ec:	d2 f7       	brpl	.-12     	; 0x67e2 <__divdi3+0x5ce>
    67ee:	97 01       	movw	r18, r14
    67f0:	86 01       	movw	r16, r12
    67f2:	04 2e       	mov	r0, r20
    67f4:	04 c0       	rjmp	.+8      	; 0x67fe <__divdi3+0x5ea>
    67f6:	36 95       	lsr	r19
    67f8:	27 95       	ror	r18
    67fa:	17 95       	ror	r17
    67fc:	07 95       	ror	r16
    67fe:	0a 94       	dec	r0
    6800:	d2 f7       	brpl	.-12     	; 0x67f6 <__divdi3+0x5e2>
    6802:	09 ab       	sts	0x59, r16
    6804:	1a ab       	sts	0x5a, r17
    6806:	2b ab       	sts	0x5b, r18
    6808:	3c ab       	sts	0x5c, r19
    680a:	97 01       	movw	r18, r14
    680c:	86 01       	movw	r16, r12
    680e:	08 2e       	mov	r0, r24
    6810:	04 c0       	rjmp	.+8      	; 0x681a <__divdi3+0x606>
    6812:	00 0f       	add	r16, r16
    6814:	11 1f       	adc	r17, r17
    6816:	22 1f       	adc	r18, r18
    6818:	33 1f       	adc	r19, r19
    681a:	0a 94       	dec	r0
    681c:	d2 f7       	brpl	.-12     	; 0x6812 <__divdi3+0x5fe>
    681e:	0d a7       	lds	r16, 0x7d
    6820:	1e a7       	lds	r17, 0x7e
    6822:	2f a7       	lds	r18, 0x7f
    6824:	38 ab       	sts	0x58, r19
    6826:	ed a8       	sts	0x8d, r30
    6828:	fe a8       	sts	0x8e, r31
    682a:	0f a9       	sts	0x4f, r16
    682c:	18 ad       	sts	0x68, r17
    682e:	04 c0       	rjmp	.+8      	; 0x6838 <__divdi3+0x624>
    6830:	16 95       	lsr	r17
    6832:	07 95       	ror	r16
    6834:	f7 94       	ror	r15
    6836:	e7 94       	ror	r14
    6838:	4a 95       	dec	r20
    683a:	d2 f7       	brpl	.-12     	; 0x6830 <__divdi3+0x61c>
    683c:	b8 01       	movw	r22, r16
    683e:	a7 01       	movw	r20, r14
    6840:	0d a5       	lds	r16, 0x6d
    6842:	1e a5       	lds	r17, 0x6e
    6844:	2f a5       	lds	r18, 0x6f
    6846:	38 a9       	sts	0x48, r19
    6848:	04 2b       	or	r16, r20
    684a:	15 2b       	or	r17, r21
    684c:	26 2b       	or	r18, r22
    684e:	37 2b       	or	r19, r23
    6850:	0d a7       	lds	r16, 0x7d
    6852:	1e a7       	lds	r17, 0x7e
    6854:	2f a7       	lds	r18, 0x7f
    6856:	38 ab       	sts	0x58, r19
    6858:	ed a8       	sts	0x8d, r30
    685a:	fe a8       	sts	0x8e, r31
    685c:	0f a9       	sts	0x4f, r16
    685e:	18 ad       	sts	0x68, r17
    6860:	04 c0       	rjmp	.+8      	; 0x686a <__divdi3+0x656>
    6862:	ee 0c       	add	r14, r14
    6864:	ff 1c       	adc	r15, r15
    6866:	00 1f       	adc	r16, r16
    6868:	11 1f       	adc	r17, r17
    686a:	8a 95       	dec	r24
    686c:	d2 f7       	brpl	.-12     	; 0x6862 <__divdi3+0x64e>
    686e:	ed aa       	sts	0x9d, r30
    6870:	fe aa       	sts	0x9e, r31
    6872:	0f ab       	sts	0x5f, r16
    6874:	18 af       	sts	0x78, r17
    6876:	25 01       	movw	r4, r10
    6878:	66 24       	eor	r6, r6
    687a:	77 24       	eor	r7, r7
    687c:	95 01       	movw	r18, r10
    687e:	84 01       	movw	r16, r8
    6880:	20 70       	andi	r18, 0x00	; 0
    6882:	30 70       	andi	r19, 0x00	; 0
    6884:	09 af       	sts	0x79, r16
    6886:	1a af       	sts	0x7a, r17
    6888:	2b af       	sts	0x7b, r18
    688a:	3c af       	sts	0x7c, r19
    688c:	69 a9       	sts	0x49, r22
    688e:	7a a9       	sts	0x4a, r23
    6890:	8b a9       	sts	0x4b, r24
    6892:	9c a9       	sts	0x4c, r25
    6894:	a3 01       	movw	r20, r6
    6896:	92 01       	movw	r18, r4
    6898:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    689c:	29 a7       	lds	r18, 0x79
    689e:	3a a7       	lds	r19, 0x7a
    68a0:	4b a7       	lds	r20, 0x7b
    68a2:	5c a7       	lds	r21, 0x7c
    68a4:	6b 01       	movw	r12, r22
    68a6:	7c 01       	movw	r14, r24
    68a8:	69 a9       	sts	0x49, r22
    68aa:	7a a9       	sts	0x4a, r23
    68ac:	8b a9       	sts	0x4b, r24
    68ae:	9c a9       	sts	0x4c, r25
    68b0:	a3 01       	movw	r20, r6
    68b2:	92 01       	movw	r18, r4
    68b4:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    68b8:	ca 01       	movw	r24, r20
    68ba:	b9 01       	movw	r22, r18
    68bc:	29 ad       	sts	0x69, r18
    68be:	3a ad       	sts	0x6a, r19
    68c0:	4b ad       	sts	0x6b, r20
    68c2:	5c ad       	sts	0x6c, r21
    68c4:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    68c8:	ab 01       	movw	r20, r22
    68ca:	bc 01       	movw	r22, r24
    68cc:	76 01       	movw	r14, r12
    68ce:	dd 24       	eor	r13, r13
    68d0:	cc 24       	eor	r12, r12
    68d2:	0d a5       	lds	r16, 0x6d
    68d4:	1e a5       	lds	r17, 0x6e
    68d6:	2f a5       	lds	r18, 0x6f
    68d8:	38 a9       	sts	0x48, r19
    68da:	c9 01       	movw	r24, r18
    68dc:	aa 27       	eor	r26, r26
    68de:	bb 27       	eor	r27, r27
    68e0:	c8 2a       	or	r12, r24
    68e2:	d9 2a       	or	r13, r25
    68e4:	ea 2a       	or	r14, r26
    68e6:	fb 2a       	or	r15, r27
    68e8:	09 a5       	lds	r16, 0x69
    68ea:	1a a5       	lds	r17, 0x6a
    68ec:	2b a5       	lds	r18, 0x6b
    68ee:	3c a5       	lds	r19, 0x6c
    68f0:	c4 16       	cp	r12, r20
    68f2:	d5 06       	cpc	r13, r21
    68f4:	e6 06       	cpc	r14, r22
    68f6:	f7 06       	cpc	r15, r23
    68f8:	38 f5       	brcc	.+78     	; 0x6948 <__divdi3+0x734>
    68fa:	01 50       	subi	r16, 0x01	; 1
    68fc:	10 40       	sbci	r17, 0x00	; 0
    68fe:	20 40       	sbci	r18, 0x00	; 0
    6900:	30 40       	sbci	r19, 0x00	; 0
    6902:	09 ab       	sts	0x59, r16
    6904:	1a ab       	sts	0x5a, r17
    6906:	2b ab       	sts	0x5b, r18
    6908:	3c ab       	sts	0x5c, r19
    690a:	c8 0c       	add	r12, r8
    690c:	d9 1c       	adc	r13, r9
    690e:	ea 1c       	adc	r14, r10
    6910:	fb 1c       	adc	r15, r11
    6912:	c8 14       	cp	r12, r8
    6914:	d9 04       	cpc	r13, r9
    6916:	ea 04       	cpc	r14, r10
    6918:	fb 04       	cpc	r15, r11
    691a:	d0 f0       	brcs	.+52     	; 0x6950 <__divdi3+0x73c>
    691c:	c4 16       	cp	r12, r20
    691e:	d5 06       	cpc	r13, r21
    6920:	e6 06       	cpc	r14, r22
    6922:	f7 06       	cpc	r15, r23
    6924:	a8 f4       	brcc	.+42     	; 0x6950 <__divdi3+0x73c>
    6926:	09 a5       	lds	r16, 0x69
    6928:	1a a5       	lds	r17, 0x6a
    692a:	2b a5       	lds	r18, 0x6b
    692c:	3c a5       	lds	r19, 0x6c
    692e:	02 50       	subi	r16, 0x02	; 2
    6930:	10 40       	sbci	r17, 0x00	; 0
    6932:	20 40       	sbci	r18, 0x00	; 0
    6934:	30 40       	sbci	r19, 0x00	; 0
    6936:	09 ab       	sts	0x59, r16
    6938:	1a ab       	sts	0x5a, r17
    693a:	2b ab       	sts	0x5b, r18
    693c:	3c ab       	sts	0x5c, r19
    693e:	c8 0c       	add	r12, r8
    6940:	d9 1c       	adc	r13, r9
    6942:	ea 1c       	adc	r14, r10
    6944:	fb 1c       	adc	r15, r11
    6946:	04 c0       	rjmp	.+8      	; 0x6950 <__divdi3+0x73c>
    6948:	09 ab       	sts	0x59, r16
    694a:	1a ab       	sts	0x5a, r17
    694c:	2b ab       	sts	0x5b, r18
    694e:	3c ab       	sts	0x5c, r19
    6950:	c4 1a       	sub	r12, r20
    6952:	d5 0a       	sbc	r13, r21
    6954:	e6 0a       	sbc	r14, r22
    6956:	f7 0a       	sbc	r15, r23
    6958:	c7 01       	movw	r24, r14
    695a:	b6 01       	movw	r22, r12
    695c:	a3 01       	movw	r20, r6
    695e:	92 01       	movw	r18, r4
    6960:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6964:	29 a7       	lds	r18, 0x79
    6966:	3a a7       	lds	r19, 0x7a
    6968:	4b a7       	lds	r20, 0x7b
    696a:	5c a7       	lds	r21, 0x7c
    696c:	21 96       	adiw	r28, 0x01	; 1
    696e:	6c af       	sts	0x7c, r22
    6970:	7d af       	sts	0x7d, r23
    6972:	8e af       	sts	0x7e, r24
    6974:	9f af       	sts	0x7f, r25
    6976:	21 97       	sbiw	r28, 0x01	; 1
    6978:	c7 01       	movw	r24, r14
    697a:	b6 01       	movw	r22, r12
    697c:	a3 01       	movw	r20, r6
    697e:	92 01       	movw	r18, r4
    6980:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6984:	ca 01       	movw	r24, r20
    6986:	b9 01       	movw	r22, r18
    6988:	29 ad       	sts	0x69, r18
    698a:	3a ad       	sts	0x6a, r19
    698c:	4b ad       	sts	0x6b, r20
    698e:	5c ad       	sts	0x6c, r21
    6990:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6994:	8b 01       	movw	r16, r22
    6996:	9c 01       	movw	r18, r24
    6998:	21 96       	adiw	r28, 0x01	; 1
    699a:	4c ad       	sts	0x6c, r20
    699c:	5d ad       	sts	0x6d, r21
    699e:	6e ad       	sts	0x6e, r22
    69a0:	7f ad       	sts	0x6f, r23
    69a2:	21 97       	sbiw	r28, 0x01	; 1
    69a4:	da 01       	movw	r26, r20
    69a6:	99 27       	eor	r25, r25
    69a8:	88 27       	eor	r24, r24
    69aa:	4d a5       	lds	r20, 0x6d
    69ac:	5e a5       	lds	r21, 0x6e
    69ae:	6f a5       	lds	r22, 0x6f
    69b0:	78 a9       	sts	0x48, r23
    69b2:	60 70       	andi	r22, 0x00	; 0
    69b4:	70 70       	andi	r23, 0x00	; 0
    69b6:	84 2b       	or	r24, r20
    69b8:	95 2b       	or	r25, r21
    69ba:	a6 2b       	or	r26, r22
    69bc:	b7 2b       	or	r27, r23
    69be:	49 a5       	lds	r20, 0x69
    69c0:	5a a5       	lds	r21, 0x6a
    69c2:	6b a5       	lds	r22, 0x6b
    69c4:	7c a5       	lds	r23, 0x6c
    69c6:	80 17       	cp	r24, r16
    69c8:	91 07       	cpc	r25, r17
    69ca:	a2 07       	cpc	r26, r18
    69cc:	b3 07       	cpc	r27, r19
    69ce:	f0 f4       	brcc	.+60     	; 0x6a0c <__divdi3+0x7f8>
    69d0:	41 50       	subi	r20, 0x01	; 1
    69d2:	50 40       	sbci	r21, 0x00	; 0
    69d4:	60 40       	sbci	r22, 0x00	; 0
    69d6:	70 40       	sbci	r23, 0x00	; 0
    69d8:	88 0d       	add	r24, r8
    69da:	99 1d       	adc	r25, r9
    69dc:	aa 1d       	adc	r26, r10
    69de:	bb 1d       	adc	r27, r11
    69e0:	88 15       	cp	r24, r8
    69e2:	99 05       	cpc	r25, r9
    69e4:	aa 05       	cpc	r26, r10
    69e6:	bb 05       	cpc	r27, r11
    69e8:	88 f0       	brcs	.+34     	; 0x6a0c <__divdi3+0x7f8>
    69ea:	80 17       	cp	r24, r16
    69ec:	91 07       	cpc	r25, r17
    69ee:	a2 07       	cpc	r26, r18
    69f0:	b3 07       	cpc	r27, r19
    69f2:	60 f4       	brcc	.+24     	; 0x6a0c <__divdi3+0x7f8>
    69f4:	49 a5       	lds	r20, 0x69
    69f6:	5a a5       	lds	r21, 0x6a
    69f8:	6b a5       	lds	r22, 0x6b
    69fa:	7c a5       	lds	r23, 0x6c
    69fc:	42 50       	subi	r20, 0x02	; 2
    69fe:	50 40       	sbci	r21, 0x00	; 0
    6a00:	60 40       	sbci	r22, 0x00	; 0
    6a02:	70 40       	sbci	r23, 0x00	; 0
    6a04:	88 0d       	add	r24, r8
    6a06:	99 1d       	adc	r25, r9
    6a08:	aa 1d       	adc	r26, r10
    6a0a:	bb 1d       	adc	r27, r11
    6a0c:	6c 01       	movw	r12, r24
    6a0e:	7d 01       	movw	r14, r26
    6a10:	c0 1a       	sub	r12, r16
    6a12:	d1 0a       	sbc	r13, r17
    6a14:	e2 0a       	sbc	r14, r18
    6a16:	f3 0a       	sbc	r15, r19
    6a18:	09 a9       	sts	0x49, r16
    6a1a:	1a a9       	sts	0x4a, r17
    6a1c:	2b a9       	sts	0x4b, r18
    6a1e:	3c a9       	sts	0x4c, r19
    6a20:	38 01       	movw	r6, r16
    6a22:	55 24       	eor	r5, r5
    6a24:	44 24       	eor	r4, r4
    6a26:	44 2a       	or	r4, r20
    6a28:	55 2a       	or	r5, r21
    6a2a:	66 2a       	or	r6, r22
    6a2c:	77 2a       	or	r7, r23
    6a2e:	85 01       	movw	r16, r10
    6a30:	22 27       	eor	r18, r18
    6a32:	33 27       	eor	r19, r19
    6a34:	0d a7       	lds	r16, 0x7d
    6a36:	1e a7       	lds	r17, 0x7e
    6a38:	2f a7       	lds	r18, 0x7f
    6a3a:	38 ab       	sts	0x58, r19
    6a3c:	95 01       	movw	r18, r10
    6a3e:	84 01       	movw	r16, r8
    6a40:	20 70       	andi	r18, 0x00	; 0
    6a42:	30 70       	andi	r19, 0x00	; 0
    6a44:	09 af       	sts	0x79, r16
    6a46:	1a af       	sts	0x7a, r17
    6a48:	2b af       	sts	0x7b, r18
    6a4a:	3c af       	sts	0x7c, r19
    6a4c:	c7 01       	movw	r24, r14
    6a4e:	b6 01       	movw	r22, r12
    6a50:	2d a5       	lds	r18, 0x6d
    6a52:	3e a5       	lds	r19, 0x6e
    6a54:	4f a5       	lds	r20, 0x6f
    6a56:	58 a9       	sts	0x48, r21
    6a58:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6a5c:	29 a7       	lds	r18, 0x79
    6a5e:	3a a7       	lds	r19, 0x7a
    6a60:	4b a7       	lds	r20, 0x7b
    6a62:	5c a7       	lds	r21, 0x7c
    6a64:	69 ab       	sts	0x59, r22
    6a66:	7a ab       	sts	0x5a, r23
    6a68:	8b ab       	sts	0x5b, r24
    6a6a:	9c ab       	sts	0x5c, r25
    6a6c:	c7 01       	movw	r24, r14
    6a6e:	b6 01       	movw	r22, r12
    6a70:	2d a5       	lds	r18, 0x6d
    6a72:	3e a5       	lds	r19, 0x6e
    6a74:	4f a5       	lds	r20, 0x6f
    6a76:	58 a9       	sts	0x48, r21
    6a78:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6a7c:	ca 01       	movw	r24, r20
    6a7e:	b9 01       	movw	r22, r18
    6a80:	29 ad       	sts	0x69, r18
    6a82:	3a ad       	sts	0x6a, r19
    6a84:	4b ad       	sts	0x6b, r20
    6a86:	5c ad       	sts	0x6c, r21
    6a88:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6a8c:	ab 01       	movw	r20, r22
    6a8e:	bc 01       	movw	r22, r24
    6a90:	09 a9       	sts	0x49, r16
    6a92:	1a a9       	sts	0x4a, r17
    6a94:	2b a9       	sts	0x4b, r18
    6a96:	3c a9       	sts	0x4c, r19
    6a98:	78 01       	movw	r14, r16
    6a9a:	dd 24       	eor	r13, r13
    6a9c:	cc 24       	eor	r12, r12
    6a9e:	0d a9       	sts	0x4d, r16
    6aa0:	1e a9       	sts	0x4e, r17
    6aa2:	2f a9       	sts	0x4f, r18
    6aa4:	38 ad       	sts	0x68, r19
    6aa6:	c9 01       	movw	r24, r18
    6aa8:	aa 27       	eor	r26, r26
    6aaa:	bb 27       	eor	r27, r27
    6aac:	c8 2a       	or	r12, r24
    6aae:	d9 2a       	or	r13, r25
    6ab0:	ea 2a       	or	r14, r26
    6ab2:	fb 2a       	or	r15, r27
    6ab4:	09 a5       	lds	r16, 0x69
    6ab6:	1a a5       	lds	r17, 0x6a
    6ab8:	2b a5       	lds	r18, 0x6b
    6aba:	3c a5       	lds	r19, 0x6c
    6abc:	c4 16       	cp	r12, r20
    6abe:	d5 06       	cpc	r13, r21
    6ac0:	e6 06       	cpc	r14, r22
    6ac2:	f7 06       	cpc	r15, r23
    6ac4:	38 f5       	brcc	.+78     	; 0x6b14 <__divdi3+0x900>
    6ac6:	01 50       	subi	r16, 0x01	; 1
    6ac8:	10 40       	sbci	r17, 0x00	; 0
    6aca:	20 40       	sbci	r18, 0x00	; 0
    6acc:	30 40       	sbci	r19, 0x00	; 0
    6ace:	09 ab       	sts	0x59, r16
    6ad0:	1a ab       	sts	0x5a, r17
    6ad2:	2b ab       	sts	0x5b, r18
    6ad4:	3c ab       	sts	0x5c, r19
    6ad6:	c8 0c       	add	r12, r8
    6ad8:	d9 1c       	adc	r13, r9
    6ada:	ea 1c       	adc	r14, r10
    6adc:	fb 1c       	adc	r15, r11
    6ade:	c8 14       	cp	r12, r8
    6ae0:	d9 04       	cpc	r13, r9
    6ae2:	ea 04       	cpc	r14, r10
    6ae4:	fb 04       	cpc	r15, r11
    6ae6:	d0 f0       	brcs	.+52     	; 0x6b1c <__divdi3+0x908>
    6ae8:	c4 16       	cp	r12, r20
    6aea:	d5 06       	cpc	r13, r21
    6aec:	e6 06       	cpc	r14, r22
    6aee:	f7 06       	cpc	r15, r23
    6af0:	a8 f4       	brcc	.+42     	; 0x6b1c <__divdi3+0x908>
    6af2:	09 a5       	lds	r16, 0x69
    6af4:	1a a5       	lds	r17, 0x6a
    6af6:	2b a5       	lds	r18, 0x6b
    6af8:	3c a5       	lds	r19, 0x6c
    6afa:	02 50       	subi	r16, 0x02	; 2
    6afc:	10 40       	sbci	r17, 0x00	; 0
    6afe:	20 40       	sbci	r18, 0x00	; 0
    6b00:	30 40       	sbci	r19, 0x00	; 0
    6b02:	09 ab       	sts	0x59, r16
    6b04:	1a ab       	sts	0x5a, r17
    6b06:	2b ab       	sts	0x5b, r18
    6b08:	3c ab       	sts	0x5c, r19
    6b0a:	c8 0c       	add	r12, r8
    6b0c:	d9 1c       	adc	r13, r9
    6b0e:	ea 1c       	adc	r14, r10
    6b10:	fb 1c       	adc	r15, r11
    6b12:	04 c0       	rjmp	.+8      	; 0x6b1c <__divdi3+0x908>
    6b14:	09 ab       	sts	0x59, r16
    6b16:	1a ab       	sts	0x5a, r17
    6b18:	2b ab       	sts	0x5b, r18
    6b1a:	3c ab       	sts	0x5c, r19
    6b1c:	c4 1a       	sub	r12, r20
    6b1e:	d5 0a       	sbc	r13, r21
    6b20:	e6 0a       	sbc	r14, r22
    6b22:	f7 0a       	sbc	r15, r23
    6b24:	c7 01       	movw	r24, r14
    6b26:	b6 01       	movw	r22, r12
    6b28:	2d a5       	lds	r18, 0x6d
    6b2a:	3e a5       	lds	r19, 0x6e
    6b2c:	4f a5       	lds	r20, 0x6f
    6b2e:	58 a9       	sts	0x48, r21
    6b30:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6b34:	29 a7       	lds	r18, 0x79
    6b36:	3a a7       	lds	r19, 0x7a
    6b38:	4b a7       	lds	r20, 0x7b
    6b3a:	5c a7       	lds	r21, 0x7c
    6b3c:	21 96       	adiw	r28, 0x01	; 1
    6b3e:	6c af       	sts	0x7c, r22
    6b40:	7d af       	sts	0x7d, r23
    6b42:	8e af       	sts	0x7e, r24
    6b44:	9f af       	sts	0x7f, r25
    6b46:	21 97       	sbiw	r28, 0x01	; 1
    6b48:	c7 01       	movw	r24, r14
    6b4a:	b6 01       	movw	r22, r12
    6b4c:	2d a5       	lds	r18, 0x6d
    6b4e:	3e a5       	lds	r19, 0x6e
    6b50:	4f a5       	lds	r20, 0x6f
    6b52:	58 a9       	sts	0x48, r21
    6b54:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6b58:	ca 01       	movw	r24, r20
    6b5a:	b9 01       	movw	r22, r18
    6b5c:	29 ad       	sts	0x69, r18
    6b5e:	3a ad       	sts	0x6a, r19
    6b60:	4b ad       	sts	0x6b, r20
    6b62:	5c ad       	sts	0x6c, r21
    6b64:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6b68:	8b 01       	movw	r16, r22
    6b6a:	9c 01       	movw	r18, r24
    6b6c:	21 96       	adiw	r28, 0x01	; 1
    6b6e:	4c ad       	sts	0x6c, r20
    6b70:	5d ad       	sts	0x6d, r21
    6b72:	6e ad       	sts	0x6e, r22
    6b74:	7f ad       	sts	0x6f, r23
    6b76:	21 97       	sbiw	r28, 0x01	; 1
    6b78:	da 01       	movw	r26, r20
    6b7a:	99 27       	eor	r25, r25
    6b7c:	88 27       	eor	r24, r24
    6b7e:	4d a9       	sts	0x4d, r20
    6b80:	5e a9       	sts	0x4e, r21
    6b82:	6f a9       	sts	0x4f, r22
    6b84:	78 ad       	sts	0x68, r23
    6b86:	60 70       	andi	r22, 0x00	; 0
    6b88:	70 70       	andi	r23, 0x00	; 0
    6b8a:	84 2b       	or	r24, r20
    6b8c:	95 2b       	or	r25, r21
    6b8e:	a6 2b       	or	r26, r22
    6b90:	b7 2b       	or	r27, r23
    6b92:	49 a5       	lds	r20, 0x69
    6b94:	5a a5       	lds	r21, 0x6a
    6b96:	6b a5       	lds	r22, 0x6b
    6b98:	7c a5       	lds	r23, 0x6c
    6b9a:	80 17       	cp	r24, r16
    6b9c:	91 07       	cpc	r25, r17
    6b9e:	a2 07       	cpc	r26, r18
    6ba0:	b3 07       	cpc	r27, r19
    6ba2:	d0 f4       	brcc	.+52     	; 0x6bd8 <__divdi3+0x9c4>
    6ba4:	41 50       	subi	r20, 0x01	; 1
    6ba6:	50 40       	sbci	r21, 0x00	; 0
    6ba8:	60 40       	sbci	r22, 0x00	; 0
    6baa:	70 40       	sbci	r23, 0x00	; 0
    6bac:	88 0d       	add	r24, r8
    6bae:	99 1d       	adc	r25, r9
    6bb0:	aa 1d       	adc	r26, r10
    6bb2:	bb 1d       	adc	r27, r11
    6bb4:	88 15       	cp	r24, r8
    6bb6:	99 05       	cpc	r25, r9
    6bb8:	aa 05       	cpc	r26, r10
    6bba:	bb 05       	cpc	r27, r11
    6bbc:	68 f0       	brcs	.+26     	; 0x6bd8 <__divdi3+0x9c4>
    6bbe:	80 17       	cp	r24, r16
    6bc0:	91 07       	cpc	r25, r17
    6bc2:	a2 07       	cpc	r26, r18
    6bc4:	b3 07       	cpc	r27, r19
    6bc6:	40 f4       	brcc	.+16     	; 0x6bd8 <__divdi3+0x9c4>
    6bc8:	49 a5       	lds	r20, 0x69
    6bca:	5a a5       	lds	r21, 0x6a
    6bcc:	6b a5       	lds	r22, 0x6b
    6bce:	7c a5       	lds	r23, 0x6c
    6bd0:	42 50       	subi	r20, 0x02	; 2
    6bd2:	50 40       	sbci	r21, 0x00	; 0
    6bd4:	60 40       	sbci	r22, 0x00	; 0
    6bd6:	70 40       	sbci	r23, 0x00	; 0
    6bd8:	09 a9       	sts	0x49, r16
    6bda:	1a a9       	sts	0x4a, r17
    6bdc:	2b a9       	sts	0x4b, r18
    6bde:	3c a9       	sts	0x4c, r19
    6be0:	78 01       	movw	r14, r16
    6be2:	dd 24       	eor	r13, r13
    6be4:	cc 24       	eor	r12, r12
    6be6:	c4 2a       	or	r12, r20
    6be8:	d5 2a       	or	r13, r21
    6bea:	e6 2a       	or	r14, r22
    6bec:	f7 2a       	or	r15, r23
    6bee:	50 c2       	rjmp	.+1184   	; 0x7090 <__divdi3+0xe7c>
    6bf0:	c8 16       	cp	r12, r24
    6bf2:	d9 06       	cpc	r13, r25
    6bf4:	ea 06       	cpc	r14, r26
    6bf6:	fb 06       	cpc	r15, r27
    6bf8:	08 f4       	brcc	.+2      	; 0x6bfc <__divdi3+0x9e8>
    6bfa:	37 c2       	rjmp	.+1134   	; 0x706a <__divdi3+0xe56>
    6bfc:	80 30       	cpi	r24, 0x00	; 0
    6bfe:	10 e0       	ldi	r17, 0x00	; 0
    6c00:	91 07       	cpc	r25, r17
    6c02:	11 e0       	ldi	r17, 0x01	; 1
    6c04:	a1 07       	cpc	r26, r17
    6c06:	10 e0       	ldi	r17, 0x00	; 0
    6c08:	b1 07       	cpc	r27, r17
    6c0a:	50 f4       	brcc	.+20     	; 0x6c20 <__divdi3+0xa0c>
    6c0c:	8f 3f       	cpi	r24, 0xFF	; 255
    6c0e:	91 05       	cpc	r25, r1
    6c10:	a1 05       	cpc	r26, r1
    6c12:	b1 05       	cpc	r27, r1
    6c14:	09 f0       	breq	.+2      	; 0x6c18 <__divdi3+0xa04>
    6c16:	88 f4       	brcc	.+34     	; 0x6c3a <__divdi3+0xa26>
    6c18:	00 e0       	ldi	r16, 0x00	; 0
    6c1a:	10 e0       	ldi	r17, 0x00	; 0
    6c1c:	98 01       	movw	r18, r16
    6c1e:	16 c0       	rjmp	.+44     	; 0x6c4c <__divdi3+0xa38>
    6c20:	80 30       	cpi	r24, 0x00	; 0
    6c22:	20 e0       	ldi	r18, 0x00	; 0
    6c24:	92 07       	cpc	r25, r18
    6c26:	20 e0       	ldi	r18, 0x00	; 0
    6c28:	a2 07       	cpc	r26, r18
    6c2a:	21 e0       	ldi	r18, 0x01	; 1
    6c2c:	b2 07       	cpc	r27, r18
    6c2e:	50 f4       	brcc	.+20     	; 0x6c44 <__divdi3+0xa30>
    6c30:	00 e1       	ldi	r16, 0x10	; 16
    6c32:	10 e0       	ldi	r17, 0x00	; 0
    6c34:	20 e0       	ldi	r18, 0x00	; 0
    6c36:	30 e0       	ldi	r19, 0x00	; 0
    6c38:	09 c0       	rjmp	.+18     	; 0x6c4c <__divdi3+0xa38>
    6c3a:	08 e0       	ldi	r16, 0x08	; 8
    6c3c:	10 e0       	ldi	r17, 0x00	; 0
    6c3e:	20 e0       	ldi	r18, 0x00	; 0
    6c40:	30 e0       	ldi	r19, 0x00	; 0
    6c42:	04 c0       	rjmp	.+8      	; 0x6c4c <__divdi3+0xa38>
    6c44:	08 e1       	ldi	r16, 0x18	; 24
    6c46:	10 e0       	ldi	r17, 0x00	; 0
    6c48:	20 e0       	ldi	r18, 0x00	; 0
    6c4a:	30 e0       	ldi	r19, 0x00	; 0
    6c4c:	ac 01       	movw	r20, r24
    6c4e:	bd 01       	movw	r22, r26
    6c50:	00 2e       	mov	r0, r16
    6c52:	04 c0       	rjmp	.+8      	; 0x6c5c <__divdi3+0xa48>
    6c54:	76 95       	lsr	r23
    6c56:	67 95       	ror	r22
    6c58:	57 95       	ror	r21
    6c5a:	47 95       	ror	r20
    6c5c:	0a 94       	dec	r0
    6c5e:	d2 f7       	brpl	.-12     	; 0x6c54 <__divdi3+0xa40>
    6c60:	fa 01       	movw	r30, r20
    6c62:	e9 5c       	subi	r30, 0xC9	; 201
    6c64:	ff 4d       	sbci	r31, 0xDF	; 223
    6c66:	40 81       	ld	r20, Z
    6c68:	04 0f       	add	r16, r20
    6c6a:	11 1d       	adc	r17, r1
    6c6c:	21 1d       	adc	r18, r1
    6c6e:	31 1d       	adc	r19, r1
    6c70:	40 e2       	ldi	r20, 0x20	; 32
    6c72:	50 e0       	ldi	r21, 0x00	; 0
    6c74:	60 e0       	ldi	r22, 0x00	; 0
    6c76:	70 e0       	ldi	r23, 0x00	; 0
    6c78:	40 1b       	sub	r20, r16
    6c7a:	51 0b       	sbc	r21, r17
    6c7c:	62 0b       	sbc	r22, r18
    6c7e:	73 0b       	sbc	r23, r19
    6c80:	a1 f4       	brne	.+40     	; 0x6caa <__divdi3+0xa96>
    6c82:	8c 15       	cp	r24, r12
    6c84:	9d 05       	cpc	r25, r13
    6c86:	ae 05       	cpc	r26, r14
    6c88:	bf 05       	cpc	r27, r15
    6c8a:	08 f4       	brcc	.+2      	; 0x6c8e <__divdi3+0xa7a>
    6c8c:	f5 c1       	rjmp	.+1002   	; 0x7078 <__divdi3+0xe64>
    6c8e:	ed a8       	sts	0x8d, r30
    6c90:	fe a8       	sts	0x8e, r31
    6c92:	0f a9       	sts	0x4f, r16
    6c94:	18 ad       	sts	0x68, r17
    6c96:	44 24       	eor	r4, r4
    6c98:	55 24       	eor	r5, r5
    6c9a:	32 01       	movw	r6, r4
    6c9c:	e8 14       	cp	r14, r8
    6c9e:	f9 04       	cpc	r15, r9
    6ca0:	0a 05       	cpc	r16, r10
    6ca2:	1b 05       	cpc	r17, r11
    6ca4:	08 f0       	brcs	.+2      	; 0x6ca8 <__divdi3+0xa94>
    6ca6:	eb c1       	rjmp	.+982    	; 0x707e <__divdi3+0xe6a>
    6ca8:	e3 c1       	rjmp	.+966    	; 0x7070 <__divdi3+0xe5c>
    6caa:	34 2e       	mov	r3, r20
    6cac:	2c 01       	movw	r4, r24
    6cae:	3d 01       	movw	r6, r26
    6cb0:	04 c0       	rjmp	.+8      	; 0x6cba <__divdi3+0xaa6>
    6cb2:	44 0c       	add	r4, r4
    6cb4:	55 1c       	adc	r5, r5
    6cb6:	66 1c       	adc	r6, r6
    6cb8:	77 1c       	adc	r7, r7
    6cba:	4a 95       	dec	r20
    6cbc:	d2 f7       	brpl	.-12     	; 0x6cb2 <__divdi3+0xa9e>
    6cbe:	d5 01       	movw	r26, r10
    6cc0:	c4 01       	movw	r24, r8
    6cc2:	00 2e       	mov	r0, r16
    6cc4:	04 c0       	rjmp	.+8      	; 0x6cce <__divdi3+0xaba>
    6cc6:	b6 95       	lsr	r27
    6cc8:	a7 95       	ror	r26
    6cca:	97 95       	ror	r25
    6ccc:	87 95       	ror	r24
    6cce:	0a 94       	dec	r0
    6cd0:	d2 f7       	brpl	.-12     	; 0x6cc6 <__divdi3+0xab2>
    6cd2:	48 2a       	or	r4, r24
    6cd4:	59 2a       	or	r5, r25
    6cd6:	6a 2a       	or	r6, r26
    6cd8:	7b 2a       	or	r7, r27
    6cda:	a5 01       	movw	r20, r10
    6cdc:	94 01       	movw	r18, r8
    6cde:	03 2c       	mov	r0, r3
    6ce0:	04 c0       	rjmp	.+8      	; 0x6cea <__divdi3+0xad6>
    6ce2:	22 0f       	add	r18, r18
    6ce4:	33 1f       	adc	r19, r19
    6ce6:	44 1f       	adc	r20, r20
    6ce8:	55 1f       	adc	r21, r21
    6cea:	0a 94       	dec	r0
    6cec:	d2 f7       	brpl	.-12     	; 0x6ce2 <__divdi3+0xace>
    6cee:	29 af       	sts	0x79, r18
    6cf0:	3a af       	sts	0x7a, r19
    6cf2:	4b af       	sts	0x7b, r20
    6cf4:	5c af       	sts	0x7c, r21
    6cf6:	b7 01       	movw	r22, r14
    6cf8:	a6 01       	movw	r20, r12
    6cfa:	00 2e       	mov	r0, r16
    6cfc:	04 c0       	rjmp	.+8      	; 0x6d06 <__divdi3+0xaf2>
    6cfe:	76 95       	lsr	r23
    6d00:	67 95       	ror	r22
    6d02:	57 95       	ror	r21
    6d04:	47 95       	ror	r20
    6d06:	0a 94       	dec	r0
    6d08:	d2 f7       	brpl	.-12     	; 0x6cfe <__divdi3+0xaea>
    6d0a:	49 ab       	sts	0x59, r20
    6d0c:	5a ab       	sts	0x5a, r21
    6d0e:	6b ab       	sts	0x5b, r22
    6d10:	7c ab       	sts	0x5c, r23
    6d12:	c7 01       	movw	r24, r14
    6d14:	b6 01       	movw	r22, r12
    6d16:	03 2c       	mov	r0, r3
    6d18:	04 c0       	rjmp	.+8      	; 0x6d22 <__divdi3+0xb0e>
    6d1a:	66 0f       	add	r22, r22
    6d1c:	77 1f       	adc	r23, r23
    6d1e:	88 1f       	adc	r24, r24
    6d20:	99 1f       	adc	r25, r25
    6d22:	0a 94       	dec	r0
    6d24:	d2 f7       	brpl	.-12     	; 0x6d1a <__divdi3+0xb06>
    6d26:	6d a7       	lds	r22, 0x7d
    6d28:	7e a7       	lds	r23, 0x7e
    6d2a:	8f a7       	lds	r24, 0x7f
    6d2c:	98 ab       	sts	0x58, r25
    6d2e:	8d a9       	sts	0x4d, r24
    6d30:	9e a9       	sts	0x4e, r25
    6d32:	af a9       	sts	0x4f, r26
    6d34:	b8 ad       	sts	0x68, r27
    6d36:	04 c0       	rjmp	.+8      	; 0x6d40 <__divdi3+0xb2c>
    6d38:	b6 95       	lsr	r27
    6d3a:	a7 95       	ror	r26
    6d3c:	97 95       	ror	r25
    6d3e:	87 95       	ror	r24
    6d40:	0a 95       	dec	r16
    6d42:	d2 f7       	brpl	.-12     	; 0x6d38 <__divdi3+0xb24>
    6d44:	4d a5       	lds	r20, 0x6d
    6d46:	5e a5       	lds	r21, 0x6e
    6d48:	6f a5       	lds	r22, 0x6f
    6d4a:	78 a9       	sts	0x48, r23
    6d4c:	48 2b       	or	r20, r24
    6d4e:	59 2b       	or	r21, r25
    6d50:	6a 2b       	or	r22, r26
    6d52:	7b 2b       	or	r23, r27
    6d54:	4d a7       	lds	r20, 0x7d
    6d56:	5e a7       	lds	r21, 0x7e
    6d58:	6f a7       	lds	r22, 0x7f
    6d5a:	78 ab       	sts	0x58, r23
    6d5c:	43 01       	movw	r8, r6
    6d5e:	aa 24       	eor	r10, r10
    6d60:	bb 24       	eor	r11, r11
    6d62:	93 01       	movw	r18, r6
    6d64:	82 01       	movw	r16, r4
    6d66:	20 70       	andi	r18, 0x00	; 0
    6d68:	30 70       	andi	r19, 0x00	; 0
    6d6a:	21 96       	adiw	r28, 0x01	; 1
    6d6c:	0c af       	sts	0x7c, r16
    6d6e:	1d af       	sts	0x7d, r17
    6d70:	2e af       	sts	0x7e, r18
    6d72:	3f af       	sts	0x7f, r19
    6d74:	21 97       	sbiw	r28, 0x01	; 1
    6d76:	69 a9       	sts	0x49, r22
    6d78:	7a a9       	sts	0x4a, r23
    6d7a:	8b a9       	sts	0x4b, r24
    6d7c:	9c a9       	sts	0x4c, r25
    6d7e:	a5 01       	movw	r20, r10
    6d80:	94 01       	movw	r18, r8
    6d82:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6d86:	29 a7       	lds	r18, 0x79
    6d88:	3a a7       	lds	r19, 0x7a
    6d8a:	4b a7       	lds	r20, 0x7b
    6d8c:	5c a7       	lds	r21, 0x7c
    6d8e:	6b 01       	movw	r12, r22
    6d90:	7c 01       	movw	r14, r24
    6d92:	69 a9       	sts	0x49, r22
    6d94:	7a a9       	sts	0x4a, r23
    6d96:	8b a9       	sts	0x4b, r24
    6d98:	9c a9       	sts	0x4c, r25
    6d9a:	a5 01       	movw	r20, r10
    6d9c:	94 01       	movw	r18, r8
    6d9e:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6da2:	ca 01       	movw	r24, r20
    6da4:	b9 01       	movw	r22, r18
    6da6:	21 96       	adiw	r28, 0x01	; 1
    6da8:	2c ad       	sts	0x6c, r18
    6daa:	3d ad       	sts	0x6d, r19
    6dac:	4e ad       	sts	0x6e, r20
    6dae:	5f ad       	sts	0x6f, r21
    6db0:	21 97       	sbiw	r28, 0x01	; 1
    6db2:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6db6:	dc 01       	movw	r26, r24
    6db8:	cb 01       	movw	r24, r22
    6dba:	76 01       	movw	r14, r12
    6dbc:	dd 24       	eor	r13, r13
    6dbe:	cc 24       	eor	r12, r12
    6dc0:	0d a5       	lds	r16, 0x6d
    6dc2:	1e a5       	lds	r17, 0x6e
    6dc4:	2f a5       	lds	r18, 0x6f
    6dc6:	38 a9       	sts	0x48, r19
    6dc8:	a9 01       	movw	r20, r18
    6dca:	66 27       	eor	r22, r22
    6dcc:	77 27       	eor	r23, r23
    6dce:	c4 2a       	or	r12, r20
    6dd0:	d5 2a       	or	r13, r21
    6dd2:	e6 2a       	or	r14, r22
    6dd4:	f7 2a       	or	r15, r23
    6dd6:	09 a5       	lds	r16, 0x69
    6dd8:	1a a5       	lds	r17, 0x6a
    6dda:	2b a5       	lds	r18, 0x6b
    6ddc:	3c a5       	lds	r19, 0x6c
    6dde:	c8 16       	cp	r12, r24
    6de0:	d9 06       	cpc	r13, r25
    6de2:	ea 06       	cpc	r14, r26
    6de4:	fb 06       	cpc	r15, r27
    6de6:	38 f5       	brcc	.+78     	; 0x6e36 <__divdi3+0xc22>
    6de8:	01 50       	subi	r16, 0x01	; 1
    6dea:	10 40       	sbci	r17, 0x00	; 0
    6dec:	20 40       	sbci	r18, 0x00	; 0
    6dee:	30 40       	sbci	r19, 0x00	; 0
    6df0:	09 ab       	sts	0x59, r16
    6df2:	1a ab       	sts	0x5a, r17
    6df4:	2b ab       	sts	0x5b, r18
    6df6:	3c ab       	sts	0x5c, r19
    6df8:	c4 0c       	add	r12, r4
    6dfa:	d5 1c       	adc	r13, r5
    6dfc:	e6 1c       	adc	r14, r6
    6dfe:	f7 1c       	adc	r15, r7
    6e00:	c4 14       	cp	r12, r4
    6e02:	d5 04       	cpc	r13, r5
    6e04:	e6 04       	cpc	r14, r6
    6e06:	f7 04       	cpc	r15, r7
    6e08:	d0 f0       	brcs	.+52     	; 0x6e3e <__divdi3+0xc2a>
    6e0a:	c8 16       	cp	r12, r24
    6e0c:	d9 06       	cpc	r13, r25
    6e0e:	ea 06       	cpc	r14, r26
    6e10:	fb 06       	cpc	r15, r27
    6e12:	a8 f4       	brcc	.+42     	; 0x6e3e <__divdi3+0xc2a>
    6e14:	09 a5       	lds	r16, 0x69
    6e16:	1a a5       	lds	r17, 0x6a
    6e18:	2b a5       	lds	r18, 0x6b
    6e1a:	3c a5       	lds	r19, 0x6c
    6e1c:	02 50       	subi	r16, 0x02	; 2
    6e1e:	10 40       	sbci	r17, 0x00	; 0
    6e20:	20 40       	sbci	r18, 0x00	; 0
    6e22:	30 40       	sbci	r19, 0x00	; 0
    6e24:	09 ab       	sts	0x59, r16
    6e26:	1a ab       	sts	0x5a, r17
    6e28:	2b ab       	sts	0x5b, r18
    6e2a:	3c ab       	sts	0x5c, r19
    6e2c:	c4 0c       	add	r12, r4
    6e2e:	d5 1c       	adc	r13, r5
    6e30:	e6 1c       	adc	r14, r6
    6e32:	f7 1c       	adc	r15, r7
    6e34:	04 c0       	rjmp	.+8      	; 0x6e3e <__divdi3+0xc2a>
    6e36:	09 ab       	sts	0x59, r16
    6e38:	1a ab       	sts	0x5a, r17
    6e3a:	2b ab       	sts	0x5b, r18
    6e3c:	3c ab       	sts	0x5c, r19
    6e3e:	c8 1a       	sub	r12, r24
    6e40:	d9 0a       	sbc	r13, r25
    6e42:	ea 0a       	sbc	r14, r26
    6e44:	fb 0a       	sbc	r15, r27
    6e46:	c7 01       	movw	r24, r14
    6e48:	b6 01       	movw	r22, r12
    6e4a:	a5 01       	movw	r20, r10
    6e4c:	94 01       	movw	r18, r8
    6e4e:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6e52:	29 a7       	lds	r18, 0x79
    6e54:	3a a7       	lds	r19, 0x7a
    6e56:	4b a7       	lds	r20, 0x7b
    6e58:	5c a7       	lds	r21, 0x7c
    6e5a:	29 96       	adiw	r28, 0x09	; 9
    6e5c:	6c af       	sts	0x7c, r22
    6e5e:	7d af       	sts	0x7d, r23
    6e60:	8e af       	sts	0x7e, r24
    6e62:	9f af       	sts	0x7f, r25
    6e64:	29 97       	sbiw	r28, 0x09	; 9
    6e66:	c7 01       	movw	r24, r14
    6e68:	b6 01       	movw	r22, r12
    6e6a:	a5 01       	movw	r20, r10
    6e6c:	94 01       	movw	r18, r8
    6e6e:	0e 94 bb 3a 	call	0x7576	; 0x7576 <__udivmodsi4>
    6e72:	ca 01       	movw	r24, r20
    6e74:	b9 01       	movw	r22, r18
    6e76:	21 96       	adiw	r28, 0x01	; 1
    6e78:	2c ad       	sts	0x6c, r18
    6e7a:	3d ad       	sts	0x6d, r19
    6e7c:	4e ad       	sts	0x6e, r20
    6e7e:	5f ad       	sts	0x6f, r21
    6e80:	21 97       	sbiw	r28, 0x01	; 1
    6e82:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6e86:	4b 01       	movw	r8, r22
    6e88:	5c 01       	movw	r10, r24
    6e8a:	29 96       	adiw	r28, 0x09	; 9
    6e8c:	4c ad       	sts	0x6c, r20
    6e8e:	5d ad       	sts	0x6d, r21
    6e90:	6e ad       	sts	0x6e, r22
    6e92:	7f ad       	sts	0x6f, r23
    6e94:	29 97       	sbiw	r28, 0x09	; 9
    6e96:	9a 01       	movw	r18, r20
    6e98:	11 27       	eor	r17, r17
    6e9a:	00 27       	eor	r16, r16
    6e9c:	8d a5       	lds	r24, 0x6d
    6e9e:	9e a5       	lds	r25, 0x6e
    6ea0:	af a5       	lds	r26, 0x6f
    6ea2:	b8 a9       	sts	0x48, r27
    6ea4:	a0 70       	andi	r26, 0x00	; 0
    6ea6:	b0 70       	andi	r27, 0x00	; 0
    6ea8:	08 2b       	or	r16, r24
    6eaa:	19 2b       	or	r17, r25
    6eac:	2a 2b       	or	r18, r26
    6eae:	3b 2b       	or	r19, r27
    6eb0:	89 a5       	lds	r24, 0x69
    6eb2:	9a a5       	lds	r25, 0x6a
    6eb4:	ab a5       	lds	r26, 0x6b
    6eb6:	bc a5       	lds	r27, 0x6c
    6eb8:	08 15       	cp	r16, r8
    6eba:	19 05       	cpc	r17, r9
    6ebc:	2a 05       	cpc	r18, r10
    6ebe:	3b 05       	cpc	r19, r11
    6ec0:	e0 f4       	brcc	.+56     	; 0x6efa <__divdi3+0xce6>
    6ec2:	01 97       	sbiw	r24, 0x01	; 1
    6ec4:	a1 09       	sbc	r26, r1
    6ec6:	b1 09       	sbc	r27, r1
    6ec8:	04 0d       	add	r16, r4
    6eca:	15 1d       	adc	r17, r5
    6ecc:	26 1d       	adc	r18, r6
    6ece:	37 1d       	adc	r19, r7
    6ed0:	04 15       	cp	r16, r4
    6ed2:	15 05       	cpc	r17, r5
    6ed4:	26 05       	cpc	r18, r6
    6ed6:	37 05       	cpc	r19, r7
    6ed8:	80 f0       	brcs	.+32     	; 0x6efa <__divdi3+0xce6>
    6eda:	08 15       	cp	r16, r8
    6edc:	19 05       	cpc	r17, r9
    6ede:	2a 05       	cpc	r18, r10
    6ee0:	3b 05       	cpc	r19, r11
    6ee2:	58 f4       	brcc	.+22     	; 0x6efa <__divdi3+0xce6>
    6ee4:	89 a5       	lds	r24, 0x69
    6ee6:	9a a5       	lds	r25, 0x6a
    6ee8:	ab a5       	lds	r26, 0x6b
    6eea:	bc a5       	lds	r27, 0x6c
    6eec:	02 97       	sbiw	r24, 0x02	; 2
    6eee:	a1 09       	sbc	r26, r1
    6ef0:	b1 09       	sbc	r27, r1
    6ef2:	04 0d       	add	r16, r4
    6ef4:	15 1d       	adc	r17, r5
    6ef6:	26 1d       	adc	r18, r6
    6ef8:	37 1d       	adc	r19, r7
    6efa:	b9 01       	movw	r22, r18
    6efc:	a8 01       	movw	r20, r16
    6efe:	48 19       	sub	r20, r8
    6f00:	59 09       	sbc	r21, r9
    6f02:	6a 09       	sbc	r22, r10
    6f04:	7b 09       	sbc	r23, r11
    6f06:	4d a7       	lds	r20, 0x7d
    6f08:	5e a7       	lds	r21, 0x7e
    6f0a:	6f a7       	lds	r22, 0x7f
    6f0c:	78 ab       	sts	0x58, r23
    6f0e:	09 a9       	sts	0x49, r16
    6f10:	1a a9       	sts	0x4a, r17
    6f12:	2b a9       	sts	0x4b, r18
    6f14:	3c a9       	sts	0x4c, r19
    6f16:	78 01       	movw	r14, r16
    6f18:	dd 24       	eor	r13, r13
    6f1a:	cc 24       	eor	r12, r12
    6f1c:	c8 2a       	or	r12, r24
    6f1e:	d9 2a       	or	r13, r25
    6f20:	ea 2a       	or	r14, r26
    6f22:	fb 2a       	or	r15, r27
    6f24:	ff ef       	ldi	r31, 0xFF	; 255
    6f26:	8f 2e       	mov	r8, r31
    6f28:	ff ef       	ldi	r31, 0xFF	; 255
    6f2a:	9f 2e       	mov	r9, r31
    6f2c:	a1 2c       	mov	r10, r1
    6f2e:	b1 2c       	mov	r11, r1
    6f30:	8c 20       	and	r8, r12
    6f32:	9d 20       	and	r9, r13
    6f34:	ae 20       	and	r10, r14
    6f36:	bf 20       	and	r11, r15
    6f38:	87 01       	movw	r16, r14
    6f3a:	22 27       	eor	r18, r18
    6f3c:	33 27       	eor	r19, r19
    6f3e:	09 a7       	lds	r16, 0x79
    6f40:	1a a7       	lds	r17, 0x7a
    6f42:	2b a7       	lds	r18, 0x7b
    6f44:	3c a7       	lds	r19, 0x7c
    6f46:	49 ac       	sts	0xa9, r20
    6f48:	5a ac       	sts	0xaa, r21
    6f4a:	6b ac       	sts	0xab, r22
    6f4c:	7c ac       	sts	0xac, r23
    6f4e:	2f ef       	ldi	r18, 0xFF	; 255
    6f50:	3f ef       	ldi	r19, 0xFF	; 255
    6f52:	40 e0       	ldi	r20, 0x00	; 0
    6f54:	50 e0       	ldi	r21, 0x00	; 0
    6f56:	42 22       	and	r4, r18
    6f58:	53 22       	and	r5, r19
    6f5a:	64 22       	and	r6, r20
    6f5c:	75 22       	and	r7, r21
    6f5e:	29 ad       	sts	0x69, r18
    6f60:	3a ad       	sts	0x6a, r19
    6f62:	4b ad       	sts	0x6b, r20
    6f64:	5c ad       	sts	0x6c, r21
    6f66:	8a 01       	movw	r16, r20
    6f68:	22 27       	eor	r18, r18
    6f6a:	33 27       	eor	r19, r19
    6f6c:	09 ab       	sts	0x59, r16
    6f6e:	1a ab       	sts	0x5a, r17
    6f70:	2b ab       	sts	0x5b, r18
    6f72:	3c ab       	sts	0x5c, r19
    6f74:	c5 01       	movw	r24, r10
    6f76:	b4 01       	movw	r22, r8
    6f78:	a3 01       	movw	r20, r6
    6f7a:	92 01       	movw	r18, r4
    6f7c:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6f80:	69 af       	sts	0x79, r22
    6f82:	7a af       	sts	0x7a, r23
    6f84:	8b af       	sts	0x7b, r24
    6f86:	9c af       	sts	0x7c, r25
    6f88:	c5 01       	movw	r24, r10
    6f8a:	b4 01       	movw	r22, r8
    6f8c:	29 a9       	sts	0x49, r18
    6f8e:	3a a9       	sts	0x4a, r19
    6f90:	4b a9       	sts	0x4b, r20
    6f92:	5c a9       	sts	0x4c, r21
    6f94:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6f98:	4b 01       	movw	r8, r22
    6f9a:	5c 01       	movw	r10, r24
    6f9c:	69 a5       	lds	r22, 0x69
    6f9e:	7a a5       	lds	r23, 0x6a
    6fa0:	8b a5       	lds	r24, 0x6b
    6fa2:	9c a5       	lds	r25, 0x6c
    6fa4:	a3 01       	movw	r20, r6
    6fa6:	92 01       	movw	r18, r4
    6fa8:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6fac:	2b 01       	movw	r4, r22
    6fae:	3c 01       	movw	r6, r24
    6fb0:	69 a5       	lds	r22, 0x69
    6fb2:	7a a5       	lds	r23, 0x6a
    6fb4:	8b a5       	lds	r24, 0x6b
    6fb6:	9c a5       	lds	r25, 0x6c
    6fb8:	29 a9       	sts	0x49, r18
    6fba:	3a a9       	sts	0x4a, r19
    6fbc:	4b a9       	sts	0x4b, r20
    6fbe:	5c a9       	sts	0x4c, r21
    6fc0:	0e 94 75 3a 	call	0x74ea	; 0x74ea <__mulsi3>
    6fc4:	ab 01       	movw	r20, r22
    6fc6:	bc 01       	movw	r22, r24
    6fc8:	84 0c       	add	r8, r4
    6fca:	95 1c       	adc	r9, r5
    6fcc:	a6 1c       	adc	r10, r6
    6fce:	b7 1c       	adc	r11, r7
    6fd0:	09 ad       	sts	0x69, r16
    6fd2:	1a ad       	sts	0x6a, r17
    6fd4:	2b ad       	sts	0x6b, r18
    6fd6:	3c ad       	sts	0x6c, r19
    6fd8:	c9 01       	movw	r24, r18
    6fda:	aa 27       	eor	r26, r26
    6fdc:	bb 27       	eor	r27, r27
    6fde:	88 0e       	add	r8, r24
    6fe0:	99 1e       	adc	r9, r25
    6fe2:	aa 1e       	adc	r10, r26
    6fe4:	bb 1e       	adc	r11, r27
    6fe6:	84 14       	cp	r8, r4
    6fe8:	95 04       	cpc	r9, r5
    6fea:	a6 04       	cpc	r10, r6
    6fec:	b7 04       	cpc	r11, r7
    6fee:	20 f4       	brcc	.+8      	; 0x6ff8 <__divdi3+0xde4>
    6ff0:	40 50       	subi	r20, 0x00	; 0
    6ff2:	50 40       	sbci	r21, 0x00	; 0
    6ff4:	6f 4f       	sbci	r22, 0xFF	; 255
    6ff6:	7f 4f       	sbci	r23, 0xFF	; 255
    6ff8:	c5 01       	movw	r24, r10
    6ffa:	aa 27       	eor	r26, r26
    6ffc:	bb 27       	eor	r27, r27
    6ffe:	84 0f       	add	r24, r20
    7000:	95 1f       	adc	r25, r21
    7002:	a6 1f       	adc	r26, r22
    7004:	b7 1f       	adc	r27, r23
    7006:	0d a5       	lds	r16, 0x6d
    7008:	1e a5       	lds	r17, 0x6e
    700a:	2f a5       	lds	r18, 0x6f
    700c:	38 a9       	sts	0x48, r19
    700e:	08 17       	cp	r16, r24
    7010:	19 07       	cpc	r17, r25
    7012:	2a 07       	cpc	r18, r26
    7014:	3b 07       	cpc	r19, r27
    7016:	18 f1       	brcs	.+70     	; 0x705e <__divdi3+0xe4a>
    7018:	80 17       	cp	r24, r16
    701a:	91 07       	cpc	r25, r17
    701c:	a2 07       	cpc	r26, r18
    701e:	b3 07       	cpc	r27, r19
    7020:	a1 f5       	brne	.+104    	; 0x708a <__divdi3+0xe76>
    7022:	54 01       	movw	r10, r8
    7024:	99 24       	eor	r9, r9
    7026:	88 24       	eor	r8, r8
    7028:	89 ad       	sts	0x69, r24
    702a:	9a ad       	sts	0x6a, r25
    702c:	ab ad       	sts	0x6b, r26
    702e:	bc ad       	sts	0x6c, r27
    7030:	a0 70       	andi	r26, 0x00	; 0
    7032:	b0 70       	andi	r27, 0x00	; 0
    7034:	88 0e       	add	r8, r24
    7036:	99 1e       	adc	r9, r25
    7038:	aa 1e       	adc	r10, r26
    703a:	bb 1e       	adc	r11, r27
    703c:	4d a9       	sts	0x4d, r20
    703e:	5e a9       	sts	0x4e, r21
    7040:	6f a9       	sts	0x4f, r22
    7042:	78 ad       	sts	0x68, r23
    7044:	03 2c       	mov	r0, r3
    7046:	04 c0       	rjmp	.+8      	; 0x7050 <__divdi3+0xe3c>
    7048:	44 0f       	add	r20, r20
    704a:	55 1f       	adc	r21, r21
    704c:	66 1f       	adc	r22, r22
    704e:	77 1f       	adc	r23, r23
    7050:	0a 94       	dec	r0
    7052:	d2 f7       	brpl	.-12     	; 0x7048 <__divdi3+0xe34>
    7054:	48 15       	cp	r20, r8
    7056:	59 05       	cpc	r21, r9
    7058:	6a 05       	cpc	r22, r10
    705a:	7b 05       	cpc	r23, r11
    705c:	b0 f4       	brcc	.+44     	; 0x708a <__divdi3+0xe76>
    705e:	08 94       	sec
    7060:	c1 08       	sbc	r12, r1
    7062:	d1 08       	sbc	r13, r1
    7064:	e1 08       	sbc	r14, r1
    7066:	f1 08       	sbc	r15, r1
    7068:	10 c0       	rjmp	.+32     	; 0x708a <__divdi3+0xe76>
    706a:	44 24       	eor	r4, r4
    706c:	55 24       	eor	r5, r5
    706e:	32 01       	movw	r6, r4
    7070:	cc 24       	eor	r12, r12
    7072:	dd 24       	eor	r13, r13
    7074:	76 01       	movw	r14, r12
    7076:	0c c0       	rjmp	.+24     	; 0x7090 <__divdi3+0xe7c>
    7078:	44 24       	eor	r4, r4
    707a:	55 24       	eor	r5, r5
    707c:	32 01       	movw	r6, r4
    707e:	81 e0       	ldi	r24, 0x01	; 1
    7080:	c8 2e       	mov	r12, r24
    7082:	d1 2c       	mov	r13, r1
    7084:	e1 2c       	mov	r14, r1
    7086:	f1 2c       	mov	r15, r1
    7088:	03 c0       	rjmp	.+6      	; 0x7090 <__divdi3+0xe7c>
    708a:	44 24       	eor	r4, r4
    708c:	55 24       	eor	r5, r5
    708e:	32 01       	movw	r6, r4
    7090:	fe 01       	movw	r30, r28
    7092:	31 96       	adiw	r30, 0x01	; 1
    7094:	88 e0       	ldi	r24, 0x08	; 8
    7096:	df 01       	movw	r26, r30
    7098:	1d 92       	st	X+, r1
    709a:	8a 95       	dec	r24
    709c:	e9 f7       	brne	.-6      	; 0x7098 <__divdi3+0xe84>
    709e:	c9 82       	std	Y+1, r12	; 0x01
    70a0:	da 82       	std	Y+2, r13	; 0x02
    70a2:	eb 82       	std	Y+3, r14	; 0x03
    70a4:	fc 82       	std	Y+4, r15	; 0x04
    70a6:	4d 82       	std	Y+5, r4	; 0x05
    70a8:	5e 82       	std	Y+6, r5	; 0x06
    70aa:	6f 82       	std	Y+7, r6	; 0x07
    70ac:	78 86       	std	Y+8, r7	; 0x08
    70ae:	2c 2d       	mov	r18, r12
    70b0:	3a 81       	ldd	r19, Y+2	; 0x02
    70b2:	4b 81       	ldd	r20, Y+3	; 0x03
    70b4:	5c 81       	ldd	r21, Y+4	; 0x04
    70b6:	64 2d       	mov	r22, r4
    70b8:	7e 81       	ldd	r23, Y+6	; 0x06
    70ba:	8f 81       	ldd	r24, Y+7	; 0x07
    70bc:	98 85       	ldd	r25, Y+8	; 0x08
    70be:	25 96       	adiw	r28, 0x05	; 5
    70c0:	ec ac       	sts	0xac, r30
    70c2:	fd ac       	sts	0xad, r31
    70c4:	0e ad       	sts	0x6e, r16
    70c6:	1f ad       	sts	0x6f, r17
    70c8:	25 97       	sbiw	r28, 0x05	; 5
    70ca:	e1 14       	cp	r14, r1
    70cc:	f1 04       	cpc	r15, r1
    70ce:	01 05       	cpc	r16, r1
    70d0:	11 05       	cpc	r17, r1
    70d2:	09 f4       	brne	.+2      	; 0x70d6 <__divdi3+0xec2>
    70d4:	56 c0       	rjmp	.+172    	; 0x7182 <__divdi3+0xf6e>
    70d6:	21 95       	neg	r18
    70d8:	e1 e0       	ldi	r30, 0x01	; 1
    70da:	12 16       	cp	r1, r18
    70dc:	08 f0       	brcs	.+2      	; 0x70e0 <__divdi3+0xecc>
    70de:	e0 e0       	ldi	r30, 0x00	; 0
    70e0:	31 95       	neg	r19
    70e2:	f1 e0       	ldi	r31, 0x01	; 1
    70e4:	13 16       	cp	r1, r19
    70e6:	08 f0       	brcs	.+2      	; 0x70ea <__divdi3+0xed6>
    70e8:	f0 e0       	ldi	r31, 0x00	; 0
    70ea:	03 2f       	mov	r16, r19
    70ec:	0e 1b       	sub	r16, r30
    70ee:	e1 e0       	ldi	r30, 0x01	; 1
    70f0:	30 17       	cp	r19, r16
    70f2:	08 f0       	brcs	.+2      	; 0x70f6 <__divdi3+0xee2>
    70f4:	e0 e0       	ldi	r30, 0x00	; 0
    70f6:	fe 2b       	or	r31, r30
    70f8:	41 95       	neg	r20
    70fa:	e1 e0       	ldi	r30, 0x01	; 1
    70fc:	14 16       	cp	r1, r20
    70fe:	08 f0       	brcs	.+2      	; 0x7102 <__divdi3+0xeee>
    7100:	e0 e0       	ldi	r30, 0x00	; 0
    7102:	14 2f       	mov	r17, r20
    7104:	1f 1b       	sub	r17, r31
    7106:	31 e0       	ldi	r19, 0x01	; 1
    7108:	41 17       	cp	r20, r17
    710a:	08 f0       	brcs	.+2      	; 0x710e <__divdi3+0xefa>
    710c:	30 e0       	ldi	r19, 0x00	; 0
    710e:	e3 2b       	or	r30, r19
    7110:	51 95       	neg	r21
    7112:	f1 e0       	ldi	r31, 0x01	; 1
    7114:	15 16       	cp	r1, r21
    7116:	08 f0       	brcs	.+2      	; 0x711a <__divdi3+0xf06>
    7118:	f0 e0       	ldi	r31, 0x00	; 0
    711a:	b5 2f       	mov	r27, r21
    711c:	be 1b       	sub	r27, r30
    711e:	31 e0       	ldi	r19, 0x01	; 1
    7120:	5b 17       	cp	r21, r27
    7122:	08 f0       	brcs	.+2      	; 0x7126 <__divdi3+0xf12>
    7124:	30 e0       	ldi	r19, 0x00	; 0
    7126:	f3 2b       	or	r31, r19
    7128:	61 95       	neg	r22
    712a:	e1 e0       	ldi	r30, 0x01	; 1
    712c:	16 16       	cp	r1, r22
    712e:	08 f0       	brcs	.+2      	; 0x7132 <__divdi3+0xf1e>
    7130:	e0 e0       	ldi	r30, 0x00	; 0
    7132:	46 2e       	mov	r4, r22
    7134:	4f 1a       	sub	r4, r31
    7136:	31 e0       	ldi	r19, 0x01	; 1
    7138:	64 15       	cp	r22, r4
    713a:	08 f0       	brcs	.+2      	; 0x713e <__divdi3+0xf2a>
    713c:	30 e0       	ldi	r19, 0x00	; 0
    713e:	e3 2b       	or	r30, r19
    7140:	71 95       	neg	r23
    7142:	f1 e0       	ldi	r31, 0x01	; 1
    7144:	17 16       	cp	r1, r23
    7146:	08 f0       	brcs	.+2      	; 0x714a <__divdi3+0xf36>
    7148:	f0 e0       	ldi	r31, 0x00	; 0
    714a:	a7 2f       	mov	r26, r23
    714c:	ae 1b       	sub	r26, r30
    714e:	31 e0       	ldi	r19, 0x01	; 1
    7150:	7a 17       	cp	r23, r26
    7152:	08 f0       	brcs	.+2      	; 0x7156 <__divdi3+0xf42>
    7154:	30 e0       	ldi	r19, 0x00	; 0
    7156:	f3 2b       	or	r31, r19
    7158:	81 95       	neg	r24
    715a:	e1 e0       	ldi	r30, 0x01	; 1
    715c:	18 16       	cp	r1, r24
    715e:	08 f0       	brcs	.+2      	; 0x7162 <__divdi3+0xf4e>
    7160:	e0 e0       	ldi	r30, 0x00	; 0
    7162:	f8 2e       	mov	r15, r24
    7164:	ff 1a       	sub	r15, r31
    7166:	ff 2d       	mov	r31, r15
    7168:	31 e0       	ldi	r19, 0x01	; 1
    716a:	8f 15       	cp	r24, r15
    716c:	08 f0       	brcs	.+2      	; 0x7170 <__divdi3+0xf5c>
    716e:	30 e0       	ldi	r19, 0x00	; 0
    7170:	e3 2b       	or	r30, r19
    7172:	91 95       	neg	r25
    7174:	30 2f       	mov	r19, r16
    7176:	41 2f       	mov	r20, r17
    7178:	5b 2f       	mov	r21, r27
    717a:	64 2d       	mov	r22, r4
    717c:	7a 2f       	mov	r23, r26
    717e:	8f 2f       	mov	r24, r31
    7180:	9e 1b       	sub	r25, r30
    7182:	c8 5b       	subi	r28, 0xB8	; 184
    7184:	df 4f       	sbci	r29, 0xFF	; 255
    7186:	e1 e1       	ldi	r30, 0x11	; 17
    7188:	0c 94 12 3b 	jmp	0x7624	; 0x7624 <__epilogue_restores__+0x2>

0000718c <__subsf3>:
    718c:	50 58       	subi	r21, 0x80	; 128

0000718e <__addsf3>:
    718e:	bb 27       	eor	r27, r27
    7190:	aa 27       	eor	r26, r26
    7192:	0e d0       	rcall	.+28     	; 0x71b0 <__addsf3x>
    7194:	48 c1       	rjmp	.+656    	; 0x7426 <__fp_round>
    7196:	39 d1       	rcall	.+626    	; 0x740a <__fp_pscA>
    7198:	30 f0       	brcs	.+12     	; 0x71a6 <__addsf3+0x18>
    719a:	3e d1       	rcall	.+636    	; 0x7418 <__fp_pscB>
    719c:	20 f0       	brcs	.+8      	; 0x71a6 <__addsf3+0x18>
    719e:	31 f4       	brne	.+12     	; 0x71ac <__addsf3+0x1e>
    71a0:	9f 3f       	cpi	r25, 0xFF	; 255
    71a2:	11 f4       	brne	.+4      	; 0x71a8 <__addsf3+0x1a>
    71a4:	1e f4       	brtc	.+6      	; 0x71ac <__addsf3+0x1e>
    71a6:	2e c1       	rjmp	.+604    	; 0x7404 <__fp_nan>
    71a8:	0e f4       	brtc	.+2      	; 0x71ac <__addsf3+0x1e>
    71aa:	e0 95       	com	r30
    71ac:	e7 fb       	bst	r30, 7
    71ae:	24 c1       	rjmp	.+584    	; 0x73f8 <__fp_inf>

000071b0 <__addsf3x>:
    71b0:	e9 2f       	mov	r30, r25
    71b2:	4a d1       	rcall	.+660    	; 0x7448 <__fp_split3>
    71b4:	80 f3       	brcs	.-32     	; 0x7196 <__addsf3+0x8>
    71b6:	ba 17       	cp	r27, r26
    71b8:	62 07       	cpc	r22, r18
    71ba:	73 07       	cpc	r23, r19
    71bc:	84 07       	cpc	r24, r20
    71be:	95 07       	cpc	r25, r21
    71c0:	18 f0       	brcs	.+6      	; 0x71c8 <__addsf3x+0x18>
    71c2:	71 f4       	brne	.+28     	; 0x71e0 <__addsf3x+0x30>
    71c4:	9e f5       	brtc	.+102    	; 0x722c <__addsf3x+0x7c>
    71c6:	62 c1       	rjmp	.+708    	; 0x748c <__fp_zero>
    71c8:	0e f4       	brtc	.+2      	; 0x71cc <__addsf3x+0x1c>
    71ca:	e0 95       	com	r30
    71cc:	0b 2e       	mov	r0, r27
    71ce:	ba 2f       	mov	r27, r26
    71d0:	a0 2d       	mov	r26, r0
    71d2:	0b 01       	movw	r0, r22
    71d4:	b9 01       	movw	r22, r18
    71d6:	90 01       	movw	r18, r0
    71d8:	0c 01       	movw	r0, r24
    71da:	ca 01       	movw	r24, r20
    71dc:	a0 01       	movw	r20, r0
    71de:	11 24       	eor	r1, r1
    71e0:	ff 27       	eor	r31, r31
    71e2:	59 1b       	sub	r21, r25
    71e4:	99 f0       	breq	.+38     	; 0x720c <__addsf3x+0x5c>
    71e6:	59 3f       	cpi	r21, 0xF9	; 249
    71e8:	50 f4       	brcc	.+20     	; 0x71fe <__addsf3x+0x4e>
    71ea:	50 3e       	cpi	r21, 0xE0	; 224
    71ec:	68 f1       	brcs	.+90     	; 0x7248 <__addsf3x+0x98>
    71ee:	1a 16       	cp	r1, r26
    71f0:	f0 40       	sbci	r31, 0x00	; 0
    71f2:	a2 2f       	mov	r26, r18
    71f4:	23 2f       	mov	r18, r19
    71f6:	34 2f       	mov	r19, r20
    71f8:	44 27       	eor	r20, r20
    71fa:	58 5f       	subi	r21, 0xF8	; 248
    71fc:	f3 cf       	rjmp	.-26     	; 0x71e4 <__addsf3x+0x34>
    71fe:	46 95       	lsr	r20
    7200:	37 95       	ror	r19
    7202:	27 95       	ror	r18
    7204:	a7 95       	ror	r26
    7206:	f0 40       	sbci	r31, 0x00	; 0
    7208:	53 95       	inc	r21
    720a:	c9 f7       	brne	.-14     	; 0x71fe <__addsf3x+0x4e>
    720c:	7e f4       	brtc	.+30     	; 0x722c <__addsf3x+0x7c>
    720e:	1f 16       	cp	r1, r31
    7210:	ba 0b       	sbc	r27, r26
    7212:	62 0b       	sbc	r22, r18
    7214:	73 0b       	sbc	r23, r19
    7216:	84 0b       	sbc	r24, r20
    7218:	ba f0       	brmi	.+46     	; 0x7248 <__addsf3x+0x98>
    721a:	91 50       	subi	r25, 0x01	; 1
    721c:	a1 f0       	breq	.+40     	; 0x7246 <__addsf3x+0x96>
    721e:	ff 0f       	add	r31, r31
    7220:	bb 1f       	adc	r27, r27
    7222:	66 1f       	adc	r22, r22
    7224:	77 1f       	adc	r23, r23
    7226:	88 1f       	adc	r24, r24
    7228:	c2 f7       	brpl	.-16     	; 0x721a <__addsf3x+0x6a>
    722a:	0e c0       	rjmp	.+28     	; 0x7248 <__addsf3x+0x98>
    722c:	ba 0f       	add	r27, r26
    722e:	62 1f       	adc	r22, r18
    7230:	73 1f       	adc	r23, r19
    7232:	84 1f       	adc	r24, r20
    7234:	48 f4       	brcc	.+18     	; 0x7248 <__addsf3x+0x98>
    7236:	87 95       	ror	r24
    7238:	77 95       	ror	r23
    723a:	67 95       	ror	r22
    723c:	b7 95       	ror	r27
    723e:	f7 95       	ror	r31
    7240:	9e 3f       	cpi	r25, 0xFE	; 254
    7242:	08 f0       	brcs	.+2      	; 0x7246 <__addsf3x+0x96>
    7244:	b3 cf       	rjmp	.-154    	; 0x71ac <__addsf3+0x1e>
    7246:	93 95       	inc	r25
    7248:	88 0f       	add	r24, r24
    724a:	08 f0       	brcs	.+2      	; 0x724e <__addsf3x+0x9e>
    724c:	99 27       	eor	r25, r25
    724e:	ee 0f       	add	r30, r30
    7250:	97 95       	ror	r25
    7252:	87 95       	ror	r24
    7254:	08 95       	ret

00007256 <__divsf3>:
    7256:	0c d0       	rcall	.+24     	; 0x7270 <__divsf3x>
    7258:	e6 c0       	rjmp	.+460    	; 0x7426 <__fp_round>
    725a:	de d0       	rcall	.+444    	; 0x7418 <__fp_pscB>
    725c:	40 f0       	brcs	.+16     	; 0x726e <__divsf3+0x18>
    725e:	d5 d0       	rcall	.+426    	; 0x740a <__fp_pscA>
    7260:	30 f0       	brcs	.+12     	; 0x726e <__divsf3+0x18>
    7262:	21 f4       	brne	.+8      	; 0x726c <__divsf3+0x16>
    7264:	5f 3f       	cpi	r21, 0xFF	; 255
    7266:	19 f0       	breq	.+6      	; 0x726e <__divsf3+0x18>
    7268:	c7 c0       	rjmp	.+398    	; 0x73f8 <__fp_inf>
    726a:	51 11       	cpse	r21, r1
    726c:	10 c1       	rjmp	.+544    	; 0x748e <__fp_szero>
    726e:	ca c0       	rjmp	.+404    	; 0x7404 <__fp_nan>

00007270 <__divsf3x>:
    7270:	eb d0       	rcall	.+470    	; 0x7448 <__fp_split3>
    7272:	98 f3       	brcs	.-26     	; 0x725a <__divsf3+0x4>

00007274 <__divsf3_pse>:
    7274:	99 23       	and	r25, r25
    7276:	c9 f3       	breq	.-14     	; 0x726a <__divsf3+0x14>
    7278:	55 23       	and	r21, r21
    727a:	b1 f3       	breq	.-20     	; 0x7268 <__divsf3+0x12>
    727c:	95 1b       	sub	r25, r21
    727e:	55 0b       	sbc	r21, r21
    7280:	bb 27       	eor	r27, r27
    7282:	aa 27       	eor	r26, r26
    7284:	62 17       	cp	r22, r18
    7286:	73 07       	cpc	r23, r19
    7288:	84 07       	cpc	r24, r20
    728a:	38 f0       	brcs	.+14     	; 0x729a <__divsf3_pse+0x26>
    728c:	9f 5f       	subi	r25, 0xFF	; 255
    728e:	5f 4f       	sbci	r21, 0xFF	; 255
    7290:	22 0f       	add	r18, r18
    7292:	33 1f       	adc	r19, r19
    7294:	44 1f       	adc	r20, r20
    7296:	aa 1f       	adc	r26, r26
    7298:	a9 f3       	breq	.-22     	; 0x7284 <__divsf3_pse+0x10>
    729a:	33 d0       	rcall	.+102    	; 0x7302 <__divsf3_pse+0x8e>
    729c:	0e 2e       	mov	r0, r30
    729e:	3a f0       	brmi	.+14     	; 0x72ae <__divsf3_pse+0x3a>
    72a0:	e0 e8       	ldi	r30, 0x80	; 128
    72a2:	30 d0       	rcall	.+96     	; 0x7304 <__divsf3_pse+0x90>
    72a4:	91 50       	subi	r25, 0x01	; 1
    72a6:	50 40       	sbci	r21, 0x00	; 0
    72a8:	e6 95       	lsr	r30
    72aa:	00 1c       	adc	r0, r0
    72ac:	ca f7       	brpl	.-14     	; 0x72a0 <__divsf3_pse+0x2c>
    72ae:	29 d0       	rcall	.+82     	; 0x7302 <__divsf3_pse+0x8e>
    72b0:	fe 2f       	mov	r31, r30
    72b2:	27 d0       	rcall	.+78     	; 0x7302 <__divsf3_pse+0x8e>
    72b4:	66 0f       	add	r22, r22
    72b6:	77 1f       	adc	r23, r23
    72b8:	88 1f       	adc	r24, r24
    72ba:	bb 1f       	adc	r27, r27
    72bc:	26 17       	cp	r18, r22
    72be:	37 07       	cpc	r19, r23
    72c0:	48 07       	cpc	r20, r24
    72c2:	ab 07       	cpc	r26, r27
    72c4:	b0 e8       	ldi	r27, 0x80	; 128
    72c6:	09 f0       	breq	.+2      	; 0x72ca <__divsf3_pse+0x56>
    72c8:	bb 0b       	sbc	r27, r27
    72ca:	80 2d       	mov	r24, r0
    72cc:	bf 01       	movw	r22, r30
    72ce:	ff 27       	eor	r31, r31
    72d0:	93 58       	subi	r25, 0x83	; 131
    72d2:	5f 4f       	sbci	r21, 0xFF	; 255
    72d4:	2a f0       	brmi	.+10     	; 0x72e0 <__divsf3_pse+0x6c>
    72d6:	9e 3f       	cpi	r25, 0xFE	; 254
    72d8:	51 05       	cpc	r21, r1
    72da:	68 f0       	brcs	.+26     	; 0x72f6 <__divsf3_pse+0x82>
    72dc:	8d c0       	rjmp	.+282    	; 0x73f8 <__fp_inf>
    72de:	d7 c0       	rjmp	.+430    	; 0x748e <__fp_szero>
    72e0:	5f 3f       	cpi	r21, 0xFF	; 255
    72e2:	ec f3       	brlt	.-6      	; 0x72de <__divsf3_pse+0x6a>
    72e4:	98 3e       	cpi	r25, 0xE8	; 232
    72e6:	dc f3       	brlt	.-10     	; 0x72de <__divsf3_pse+0x6a>
    72e8:	86 95       	lsr	r24
    72ea:	77 95       	ror	r23
    72ec:	67 95       	ror	r22
    72ee:	b7 95       	ror	r27
    72f0:	f7 95       	ror	r31
    72f2:	9f 5f       	subi	r25, 0xFF	; 255
    72f4:	c9 f7       	brne	.-14     	; 0x72e8 <__divsf3_pse+0x74>
    72f6:	88 0f       	add	r24, r24
    72f8:	91 1d       	adc	r25, r1
    72fa:	96 95       	lsr	r25
    72fc:	87 95       	ror	r24
    72fe:	97 f9       	bld	r25, 7
    7300:	08 95       	ret
    7302:	e1 e0       	ldi	r30, 0x01	; 1
    7304:	66 0f       	add	r22, r22
    7306:	77 1f       	adc	r23, r23
    7308:	88 1f       	adc	r24, r24
    730a:	bb 1f       	adc	r27, r27
    730c:	62 17       	cp	r22, r18
    730e:	73 07       	cpc	r23, r19
    7310:	84 07       	cpc	r24, r20
    7312:	ba 07       	cpc	r27, r26
    7314:	20 f0       	brcs	.+8      	; 0x731e <__divsf3_pse+0xaa>
    7316:	62 1b       	sub	r22, r18
    7318:	73 0b       	sbc	r23, r19
    731a:	84 0b       	sbc	r24, r20
    731c:	ba 0b       	sbc	r27, r26
    731e:	ee 1f       	adc	r30, r30
    7320:	88 f7       	brcc	.-30     	; 0x7304 <__divsf3_pse+0x90>
    7322:	e0 95       	com	r30
    7324:	08 95       	ret

00007326 <__fixunssfsi>:
    7326:	98 d0       	rcall	.+304    	; 0x7458 <__fp_splitA>
    7328:	88 f0       	brcs	.+34     	; 0x734c <__fixunssfsi+0x26>
    732a:	9f 57       	subi	r25, 0x7F	; 127
    732c:	90 f0       	brcs	.+36     	; 0x7352 <__fixunssfsi+0x2c>
    732e:	b9 2f       	mov	r27, r25
    7330:	99 27       	eor	r25, r25
    7332:	b7 51       	subi	r27, 0x17	; 23
    7334:	a0 f0       	brcs	.+40     	; 0x735e <__fixunssfsi+0x38>
    7336:	d1 f0       	breq	.+52     	; 0x736c <__fixunssfsi+0x46>
    7338:	66 0f       	add	r22, r22
    733a:	77 1f       	adc	r23, r23
    733c:	88 1f       	adc	r24, r24
    733e:	99 1f       	adc	r25, r25
    7340:	1a f0       	brmi	.+6      	; 0x7348 <__fixunssfsi+0x22>
    7342:	ba 95       	dec	r27
    7344:	c9 f7       	brne	.-14     	; 0x7338 <__fixunssfsi+0x12>
    7346:	12 c0       	rjmp	.+36     	; 0x736c <__fixunssfsi+0x46>
    7348:	b1 30       	cpi	r27, 0x01	; 1
    734a:	81 f0       	breq	.+32     	; 0x736c <__fixunssfsi+0x46>
    734c:	9f d0       	rcall	.+318    	; 0x748c <__fp_zero>
    734e:	b1 e0       	ldi	r27, 0x01	; 1
    7350:	08 95       	ret
    7352:	9c c0       	rjmp	.+312    	; 0x748c <__fp_zero>
    7354:	67 2f       	mov	r22, r23
    7356:	78 2f       	mov	r23, r24
    7358:	88 27       	eor	r24, r24
    735a:	b8 5f       	subi	r27, 0xF8	; 248
    735c:	39 f0       	breq	.+14     	; 0x736c <__fixunssfsi+0x46>
    735e:	b9 3f       	cpi	r27, 0xF9	; 249
    7360:	cc f3       	brlt	.-14     	; 0x7354 <__fixunssfsi+0x2e>
    7362:	86 95       	lsr	r24
    7364:	77 95       	ror	r23
    7366:	67 95       	ror	r22
    7368:	b3 95       	inc	r27
    736a:	d9 f7       	brne	.-10     	; 0x7362 <__fixunssfsi+0x3c>
    736c:	3e f4       	brtc	.+14     	; 0x737c <__fixunssfsi+0x56>
    736e:	90 95       	com	r25
    7370:	80 95       	com	r24
    7372:	70 95       	com	r23
    7374:	61 95       	neg	r22
    7376:	7f 4f       	sbci	r23, 0xFF	; 255
    7378:	8f 4f       	sbci	r24, 0xFF	; 255
    737a:	9f 4f       	sbci	r25, 0xFF	; 255
    737c:	08 95       	ret

0000737e <__floatunsisf>:
    737e:	e8 94       	clt
    7380:	09 c0       	rjmp	.+18     	; 0x7394 <__floatsisf+0x12>

00007382 <__floatsisf>:
    7382:	97 fb       	bst	r25, 7
    7384:	3e f4       	brtc	.+14     	; 0x7394 <__floatsisf+0x12>
    7386:	90 95       	com	r25
    7388:	80 95       	com	r24
    738a:	70 95       	com	r23
    738c:	61 95       	neg	r22
    738e:	7f 4f       	sbci	r23, 0xFF	; 255
    7390:	8f 4f       	sbci	r24, 0xFF	; 255
    7392:	9f 4f       	sbci	r25, 0xFF	; 255
    7394:	99 23       	and	r25, r25
    7396:	a9 f0       	breq	.+42     	; 0x73c2 <__floatsisf+0x40>
    7398:	f9 2f       	mov	r31, r25
    739a:	96 e9       	ldi	r25, 0x96	; 150
    739c:	bb 27       	eor	r27, r27
    739e:	93 95       	inc	r25
    73a0:	f6 95       	lsr	r31
    73a2:	87 95       	ror	r24
    73a4:	77 95       	ror	r23
    73a6:	67 95       	ror	r22
    73a8:	b7 95       	ror	r27
    73aa:	f1 11       	cpse	r31, r1
    73ac:	f8 cf       	rjmp	.-16     	; 0x739e <__floatsisf+0x1c>
    73ae:	fa f4       	brpl	.+62     	; 0x73ee <__floatsisf+0x6c>
    73b0:	bb 0f       	add	r27, r27
    73b2:	11 f4       	brne	.+4      	; 0x73b8 <__floatsisf+0x36>
    73b4:	60 ff       	sbrs	r22, 0
    73b6:	1b c0       	rjmp	.+54     	; 0x73ee <__floatsisf+0x6c>
    73b8:	6f 5f       	subi	r22, 0xFF	; 255
    73ba:	7f 4f       	sbci	r23, 0xFF	; 255
    73bc:	8f 4f       	sbci	r24, 0xFF	; 255
    73be:	9f 4f       	sbci	r25, 0xFF	; 255
    73c0:	16 c0       	rjmp	.+44     	; 0x73ee <__floatsisf+0x6c>
    73c2:	88 23       	and	r24, r24
    73c4:	11 f0       	breq	.+4      	; 0x73ca <__floatsisf+0x48>
    73c6:	96 e9       	ldi	r25, 0x96	; 150
    73c8:	11 c0       	rjmp	.+34     	; 0x73ec <__floatsisf+0x6a>
    73ca:	77 23       	and	r23, r23
    73cc:	21 f0       	breq	.+8      	; 0x73d6 <__floatsisf+0x54>
    73ce:	9e e8       	ldi	r25, 0x8E	; 142
    73d0:	87 2f       	mov	r24, r23
    73d2:	76 2f       	mov	r23, r22
    73d4:	05 c0       	rjmp	.+10     	; 0x73e0 <__floatsisf+0x5e>
    73d6:	66 23       	and	r22, r22
    73d8:	71 f0       	breq	.+28     	; 0x73f6 <__floatsisf+0x74>
    73da:	96 e8       	ldi	r25, 0x86	; 134
    73dc:	86 2f       	mov	r24, r22
    73de:	70 e0       	ldi	r23, 0x00	; 0
    73e0:	60 e0       	ldi	r22, 0x00	; 0
    73e2:	2a f0       	brmi	.+10     	; 0x73ee <__floatsisf+0x6c>
    73e4:	9a 95       	dec	r25
    73e6:	66 0f       	add	r22, r22
    73e8:	77 1f       	adc	r23, r23
    73ea:	88 1f       	adc	r24, r24
    73ec:	da f7       	brpl	.-10     	; 0x73e4 <__floatsisf+0x62>
    73ee:	88 0f       	add	r24, r24
    73f0:	96 95       	lsr	r25
    73f2:	87 95       	ror	r24
    73f4:	97 f9       	bld	r25, 7
    73f6:	08 95       	ret

000073f8 <__fp_inf>:
    73f8:	97 f9       	bld	r25, 7
    73fa:	9f 67       	ori	r25, 0x7F	; 127
    73fc:	80 e8       	ldi	r24, 0x80	; 128
    73fe:	70 e0       	ldi	r23, 0x00	; 0
    7400:	60 e0       	ldi	r22, 0x00	; 0
    7402:	08 95       	ret

00007404 <__fp_nan>:
    7404:	9f ef       	ldi	r25, 0xFF	; 255
    7406:	80 ec       	ldi	r24, 0xC0	; 192
    7408:	08 95       	ret

0000740a <__fp_pscA>:
    740a:	00 24       	eor	r0, r0
    740c:	0a 94       	dec	r0
    740e:	16 16       	cp	r1, r22
    7410:	17 06       	cpc	r1, r23
    7412:	18 06       	cpc	r1, r24
    7414:	09 06       	cpc	r0, r25
    7416:	08 95       	ret

00007418 <__fp_pscB>:
    7418:	00 24       	eor	r0, r0
    741a:	0a 94       	dec	r0
    741c:	12 16       	cp	r1, r18
    741e:	13 06       	cpc	r1, r19
    7420:	14 06       	cpc	r1, r20
    7422:	05 06       	cpc	r0, r21
    7424:	08 95       	ret

00007426 <__fp_round>:
    7426:	09 2e       	mov	r0, r25
    7428:	03 94       	inc	r0
    742a:	00 0c       	add	r0, r0
    742c:	11 f4       	brne	.+4      	; 0x7432 <__fp_round+0xc>
    742e:	88 23       	and	r24, r24
    7430:	52 f0       	brmi	.+20     	; 0x7446 <__fp_round+0x20>
    7432:	bb 0f       	add	r27, r27
    7434:	40 f4       	brcc	.+16     	; 0x7446 <__fp_round+0x20>
    7436:	bf 2b       	or	r27, r31
    7438:	11 f4       	brne	.+4      	; 0x743e <__fp_round+0x18>
    743a:	60 ff       	sbrs	r22, 0
    743c:	04 c0       	rjmp	.+8      	; 0x7446 <__fp_round+0x20>
    743e:	6f 5f       	subi	r22, 0xFF	; 255
    7440:	7f 4f       	sbci	r23, 0xFF	; 255
    7442:	8f 4f       	sbci	r24, 0xFF	; 255
    7444:	9f 4f       	sbci	r25, 0xFF	; 255
    7446:	08 95       	ret

00007448 <__fp_split3>:
    7448:	57 fd       	sbrc	r21, 7
    744a:	90 58       	subi	r25, 0x80	; 128
    744c:	44 0f       	add	r20, r20
    744e:	55 1f       	adc	r21, r21
    7450:	59 f0       	breq	.+22     	; 0x7468 <__fp_splitA+0x10>
    7452:	5f 3f       	cpi	r21, 0xFF	; 255
    7454:	71 f0       	breq	.+28     	; 0x7472 <__fp_splitA+0x1a>
    7456:	47 95       	ror	r20

00007458 <__fp_splitA>:
    7458:	88 0f       	add	r24, r24
    745a:	97 fb       	bst	r25, 7
    745c:	99 1f       	adc	r25, r25
    745e:	61 f0       	breq	.+24     	; 0x7478 <__fp_splitA+0x20>
    7460:	9f 3f       	cpi	r25, 0xFF	; 255
    7462:	79 f0       	breq	.+30     	; 0x7482 <__fp_splitA+0x2a>
    7464:	87 95       	ror	r24
    7466:	08 95       	ret
    7468:	12 16       	cp	r1, r18
    746a:	13 06       	cpc	r1, r19
    746c:	14 06       	cpc	r1, r20
    746e:	55 1f       	adc	r21, r21
    7470:	f2 cf       	rjmp	.-28     	; 0x7456 <__fp_split3+0xe>
    7472:	46 95       	lsr	r20
    7474:	f1 df       	rcall	.-30     	; 0x7458 <__fp_splitA>
    7476:	08 c0       	rjmp	.+16     	; 0x7488 <__fp_splitA+0x30>
    7478:	16 16       	cp	r1, r22
    747a:	17 06       	cpc	r1, r23
    747c:	18 06       	cpc	r1, r24
    747e:	99 1f       	adc	r25, r25
    7480:	f1 cf       	rjmp	.-30     	; 0x7464 <__fp_splitA+0xc>
    7482:	86 95       	lsr	r24
    7484:	71 05       	cpc	r23, r1
    7486:	61 05       	cpc	r22, r1
    7488:	08 94       	sec
    748a:	08 95       	ret

0000748c <__fp_zero>:
    748c:	e8 94       	clt

0000748e <__fp_szero>:
    748e:	bb 27       	eor	r27, r27
    7490:	66 27       	eor	r22, r22
    7492:	77 27       	eor	r23, r23
    7494:	cb 01       	movw	r24, r22
    7496:	97 f9       	bld	r25, 7
    7498:	08 95       	ret

0000749a <__gesf2>:
    749a:	03 d0       	rcall	.+6      	; 0x74a2 <__fp_cmp>
    749c:	08 f4       	brcc	.+2      	; 0x74a0 <__gesf2+0x6>
    749e:	8f ef       	ldi	r24, 0xFF	; 255
    74a0:	08 95       	ret

000074a2 <__fp_cmp>:
    74a2:	99 0f       	add	r25, r25
    74a4:	00 08       	sbc	r0, r0
    74a6:	55 0f       	add	r21, r21
    74a8:	aa 0b       	sbc	r26, r26
    74aa:	e0 e8       	ldi	r30, 0x80	; 128
    74ac:	fe ef       	ldi	r31, 0xFE	; 254
    74ae:	16 16       	cp	r1, r22
    74b0:	17 06       	cpc	r1, r23
    74b2:	e8 07       	cpc	r30, r24
    74b4:	f9 07       	cpc	r31, r25
    74b6:	c0 f0       	brcs	.+48     	; 0x74e8 <__fp_cmp+0x46>
    74b8:	12 16       	cp	r1, r18
    74ba:	13 06       	cpc	r1, r19
    74bc:	e4 07       	cpc	r30, r20
    74be:	f5 07       	cpc	r31, r21
    74c0:	98 f0       	brcs	.+38     	; 0x74e8 <__fp_cmp+0x46>
    74c2:	62 1b       	sub	r22, r18
    74c4:	73 0b       	sbc	r23, r19
    74c6:	84 0b       	sbc	r24, r20
    74c8:	95 0b       	sbc	r25, r21
    74ca:	39 f4       	brne	.+14     	; 0x74da <__fp_cmp+0x38>
    74cc:	0a 26       	eor	r0, r26
    74ce:	61 f0       	breq	.+24     	; 0x74e8 <__fp_cmp+0x46>
    74d0:	23 2b       	or	r18, r19
    74d2:	24 2b       	or	r18, r20
    74d4:	25 2b       	or	r18, r21
    74d6:	21 f4       	brne	.+8      	; 0x74e0 <__fp_cmp+0x3e>
    74d8:	08 95       	ret
    74da:	0a 26       	eor	r0, r26
    74dc:	09 f4       	brne	.+2      	; 0x74e0 <__fp_cmp+0x3e>
    74de:	a1 40       	sbci	r26, 0x01	; 1
    74e0:	a6 95       	lsr	r26
    74e2:	8f ef       	ldi	r24, 0xFF	; 255
    74e4:	81 1d       	adc	r24, r1
    74e6:	81 1d       	adc	r24, r1
    74e8:	08 95       	ret

000074ea <__mulsi3>:
    74ea:	62 9f       	mul	r22, r18
    74ec:	d0 01       	movw	r26, r0
    74ee:	73 9f       	mul	r23, r19
    74f0:	f0 01       	movw	r30, r0
    74f2:	82 9f       	mul	r24, r18
    74f4:	e0 0d       	add	r30, r0
    74f6:	f1 1d       	adc	r31, r1
    74f8:	64 9f       	mul	r22, r20
    74fa:	e0 0d       	add	r30, r0
    74fc:	f1 1d       	adc	r31, r1
    74fe:	92 9f       	mul	r25, r18
    7500:	f0 0d       	add	r31, r0
    7502:	83 9f       	mul	r24, r19
    7504:	f0 0d       	add	r31, r0
    7506:	74 9f       	mul	r23, r20
    7508:	f0 0d       	add	r31, r0
    750a:	65 9f       	mul	r22, r21
    750c:	f0 0d       	add	r31, r0
    750e:	99 27       	eor	r25, r25
    7510:	72 9f       	mul	r23, r18
    7512:	b0 0d       	add	r27, r0
    7514:	e1 1d       	adc	r30, r1
    7516:	f9 1f       	adc	r31, r25
    7518:	63 9f       	mul	r22, r19
    751a:	b0 0d       	add	r27, r0
    751c:	e1 1d       	adc	r30, r1
    751e:	f9 1f       	adc	r31, r25
    7520:	bd 01       	movw	r22, r26
    7522:	cf 01       	movw	r24, r30
    7524:	11 24       	eor	r1, r1
    7526:	08 95       	ret

00007528 <__udivmodhi4>:
    7528:	aa 1b       	sub	r26, r26
    752a:	bb 1b       	sub	r27, r27
    752c:	51 e1       	ldi	r21, 0x11	; 17
    752e:	07 c0       	rjmp	.+14     	; 0x753e <__udivmodhi4_ep>

00007530 <__udivmodhi4_loop>:
    7530:	aa 1f       	adc	r26, r26
    7532:	bb 1f       	adc	r27, r27
    7534:	a6 17       	cp	r26, r22
    7536:	b7 07       	cpc	r27, r23
    7538:	10 f0       	brcs	.+4      	; 0x753e <__udivmodhi4_ep>
    753a:	a6 1b       	sub	r26, r22
    753c:	b7 0b       	sbc	r27, r23

0000753e <__udivmodhi4_ep>:
    753e:	88 1f       	adc	r24, r24
    7540:	99 1f       	adc	r25, r25
    7542:	5a 95       	dec	r21
    7544:	a9 f7       	brne	.-22     	; 0x7530 <__udivmodhi4_loop>
    7546:	80 95       	com	r24
    7548:	90 95       	com	r25
    754a:	bc 01       	movw	r22, r24
    754c:	cd 01       	movw	r24, r26
    754e:	08 95       	ret

00007550 <__divmodhi4>:
    7550:	97 fb       	bst	r25, 7
    7552:	09 2e       	mov	r0, r25
    7554:	07 26       	eor	r0, r23
    7556:	0a d0       	rcall	.+20     	; 0x756c <__divmodhi4_neg1>
    7558:	77 fd       	sbrc	r23, 7
    755a:	04 d0       	rcall	.+8      	; 0x7564 <__divmodhi4_neg2>
    755c:	e5 df       	rcall	.-54     	; 0x7528 <__udivmodhi4>
    755e:	06 d0       	rcall	.+12     	; 0x756c <__divmodhi4_neg1>
    7560:	00 20       	and	r0, r0
    7562:	1a f4       	brpl	.+6      	; 0x756a <__divmodhi4_exit>

00007564 <__divmodhi4_neg2>:
    7564:	70 95       	com	r23
    7566:	61 95       	neg	r22
    7568:	7f 4f       	sbci	r23, 0xFF	; 255

0000756a <__divmodhi4_exit>:
    756a:	08 95       	ret

0000756c <__divmodhi4_neg1>:
    756c:	f6 f7       	brtc	.-4      	; 0x756a <__divmodhi4_exit>
    756e:	90 95       	com	r25
    7570:	81 95       	neg	r24
    7572:	9f 4f       	sbci	r25, 0xFF	; 255
    7574:	08 95       	ret

00007576 <__udivmodsi4>:
    7576:	a1 e2       	ldi	r26, 0x21	; 33
    7578:	1a 2e       	mov	r1, r26
    757a:	aa 1b       	sub	r26, r26
    757c:	bb 1b       	sub	r27, r27
    757e:	fd 01       	movw	r30, r26
    7580:	0d c0       	rjmp	.+26     	; 0x759c <__udivmodsi4_ep>

00007582 <__udivmodsi4_loop>:
    7582:	aa 1f       	adc	r26, r26
    7584:	bb 1f       	adc	r27, r27
    7586:	ee 1f       	adc	r30, r30
    7588:	ff 1f       	adc	r31, r31
    758a:	a2 17       	cp	r26, r18
    758c:	b3 07       	cpc	r27, r19
    758e:	e4 07       	cpc	r30, r20
    7590:	f5 07       	cpc	r31, r21
    7592:	20 f0       	brcs	.+8      	; 0x759c <__udivmodsi4_ep>
    7594:	a2 1b       	sub	r26, r18
    7596:	b3 0b       	sbc	r27, r19
    7598:	e4 0b       	sbc	r30, r20
    759a:	f5 0b       	sbc	r31, r21

0000759c <__udivmodsi4_ep>:
    759c:	66 1f       	adc	r22, r22
    759e:	77 1f       	adc	r23, r23
    75a0:	88 1f       	adc	r24, r24
    75a2:	99 1f       	adc	r25, r25
    75a4:	1a 94       	dec	r1
    75a6:	69 f7       	brne	.-38     	; 0x7582 <__udivmodsi4_loop>
    75a8:	60 95       	com	r22
    75aa:	70 95       	com	r23
    75ac:	80 95       	com	r24
    75ae:	90 95       	com	r25
    75b0:	9b 01       	movw	r18, r22
    75b2:	ac 01       	movw	r20, r24
    75b4:	bd 01       	movw	r22, r26
    75b6:	cf 01       	movw	r24, r30
    75b8:	08 95       	ret

000075ba <__divmodsi4>:
    75ba:	97 fb       	bst	r25, 7
    75bc:	09 2e       	mov	r0, r25
    75be:	05 26       	eor	r0, r21
    75c0:	0e d0       	rcall	.+28     	; 0x75de <__divmodsi4_neg1>
    75c2:	57 fd       	sbrc	r21, 7
    75c4:	04 d0       	rcall	.+8      	; 0x75ce <__divmodsi4_neg2>
    75c6:	d7 df       	rcall	.-82     	; 0x7576 <__udivmodsi4>
    75c8:	0a d0       	rcall	.+20     	; 0x75de <__divmodsi4_neg1>
    75ca:	00 1c       	adc	r0, r0
    75cc:	38 f4       	brcc	.+14     	; 0x75dc <__divmodsi4_exit>

000075ce <__divmodsi4_neg2>:
    75ce:	50 95       	com	r21
    75d0:	40 95       	com	r20
    75d2:	30 95       	com	r19
    75d4:	21 95       	neg	r18
    75d6:	3f 4f       	sbci	r19, 0xFF	; 255
    75d8:	4f 4f       	sbci	r20, 0xFF	; 255
    75da:	5f 4f       	sbci	r21, 0xFF	; 255

000075dc <__divmodsi4_exit>:
    75dc:	08 95       	ret

000075de <__divmodsi4_neg1>:
    75de:	f6 f7       	brtc	.-4      	; 0x75dc <__divmodsi4_exit>
    75e0:	90 95       	com	r25
    75e2:	80 95       	com	r24
    75e4:	70 95       	com	r23
    75e6:	61 95       	neg	r22
    75e8:	7f 4f       	sbci	r23, 0xFF	; 255
    75ea:	8f 4f       	sbci	r24, 0xFF	; 255
    75ec:	9f 4f       	sbci	r25, 0xFF	; 255
    75ee:	08 95       	ret

000075f0 <__prologue_saves__>:
    75f0:	2f 92       	push	r2
    75f2:	3f 92       	push	r3
    75f4:	4f 92       	push	r4
    75f6:	5f 92       	push	r5
    75f8:	6f 92       	push	r6
    75fa:	7f 92       	push	r7
    75fc:	8f 92       	push	r8
    75fe:	9f 92       	push	r9
    7600:	af 92       	push	r10
    7602:	bf 92       	push	r11
    7604:	cf 92       	push	r12
    7606:	df 92       	push	r13
    7608:	ef 92       	push	r14
    760a:	ff 92       	push	r15
    760c:	0f 93       	push	r16
    760e:	1f 93       	push	r17
    7610:	cf 93       	push	r28
    7612:	df 93       	push	r29
    7614:	cd b7       	in	r28, 0x3d	; 61
    7616:	de b7       	in	r29, 0x3e	; 62
    7618:	ca 1b       	sub	r28, r26
    761a:	db 0b       	sbc	r29, r27
    761c:	cd bf       	out	0x3d, r28	; 61
    761e:	de bf       	out	0x3e, r29	; 62
    7620:	19 94       	eijmp

00007622 <__epilogue_restores__>:
    7622:	2a 88       	ldd	r2, Y+18	; 0x12
    7624:	39 88       	ldd	r3, Y+17	; 0x11
    7626:	48 88       	ldd	r4, Y+16	; 0x10
    7628:	5f 84       	ldd	r5, Y+15	; 0x0f
    762a:	6e 84       	ldd	r6, Y+14	; 0x0e
    762c:	7d 84       	ldd	r7, Y+13	; 0x0d
    762e:	8c 84       	ldd	r8, Y+12	; 0x0c
    7630:	9b 84       	ldd	r9, Y+11	; 0x0b
    7632:	aa 84       	ldd	r10, Y+10	; 0x0a
    7634:	b9 84       	ldd	r11, Y+9	; 0x09
    7636:	c8 84       	ldd	r12, Y+8	; 0x08
    7638:	df 80       	ldd	r13, Y+7	; 0x07
    763a:	ee 80       	ldd	r14, Y+6	; 0x06
    763c:	fd 80       	ldd	r15, Y+5	; 0x05
    763e:	0c 81       	ldd	r16, Y+4	; 0x04
    7640:	1b 81       	ldd	r17, Y+3	; 0x03
    7642:	aa 81       	ldd	r26, Y+2	; 0x02
    7644:	b9 81       	ldd	r27, Y+1	; 0x01
    7646:	ce 0f       	add	r28, r30
    7648:	d1 1d       	adc	r29, r1
    764a:	cd bf       	out	0x3d, r28	; 61
    764c:	de bf       	out	0x3e, r29	; 62
    764e:	ed 01       	movw	r28, r26
    7650:	08 95       	ret

00007652 <strcpy_P>:
    7652:	fb 01       	movw	r30, r22
    7654:	dc 01       	movw	r26, r24
    7656:	05 90       	lpm	r0, Z+
    7658:	0d 92       	st	X+, r0
    765a:	00 20       	and	r0, r0
    765c:	e1 f7       	brne	.-8      	; 0x7656 <strcpy_P+0x4>
    765e:	08 95       	ret

00007660 <memmove>:
    7660:	68 17       	cp	r22, r24
    7662:	79 07       	cpc	r23, r25
    7664:	68 f4       	brcc	.+26     	; 0x7680 <memmove+0x20>
    7666:	fb 01       	movw	r30, r22
    7668:	dc 01       	movw	r26, r24
    766a:	e4 0f       	add	r30, r20
    766c:	f5 1f       	adc	r31, r21
    766e:	a4 0f       	add	r26, r20
    7670:	b5 1f       	adc	r27, r21
    7672:	02 c0       	rjmp	.+4      	; 0x7678 <memmove+0x18>
    7674:	02 90       	ld	r0, -Z
    7676:	0e 92       	st	-X, r0
    7678:	41 50       	subi	r20, 0x01	; 1
    767a:	50 40       	sbci	r21, 0x00	; 0
    767c:	d8 f7       	brcc	.-10     	; 0x7674 <memmove+0x14>
    767e:	08 95       	ret
    7680:	0c 94 c3 3d 	jmp	0x7b86	; 0x7b86 <memcpy>

00007684 <strcat>:
    7684:	fb 01       	movw	r30, r22
    7686:	dc 01       	movw	r26, r24
    7688:	0d 90       	ld	r0, X+
    768a:	00 20       	and	r0, r0
    768c:	e9 f7       	brne	.-6      	; 0x7688 <strcat+0x4>
    768e:	11 97       	sbiw	r26, 0x01	; 1
    7690:	01 90       	ld	r0, Z+
    7692:	0d 92       	st	X+, r0
    7694:	00 20       	and	r0, r0
    7696:	e1 f7       	brne	.-8      	; 0x7690 <strcat+0xc>
    7698:	08 95       	ret

0000769a <strncmp>:
    769a:	fb 01       	movw	r30, r22
    769c:	dc 01       	movw	r26, r24
    769e:	41 50       	subi	r20, 0x01	; 1
    76a0:	50 40       	sbci	r21, 0x00	; 0
    76a2:	30 f0       	brcs	.+12     	; 0x76b0 <strncmp+0x16>
    76a4:	8d 91       	ld	r24, X+
    76a6:	01 90       	ld	r0, Z+
    76a8:	80 19       	sub	r24, r0
    76aa:	19 f4       	brne	.+6      	; 0x76b2 <strncmp+0x18>
    76ac:	00 20       	and	r0, r0
    76ae:	b9 f7       	brne	.-18     	; 0x769e <strncmp+0x4>
    76b0:	88 1b       	sub	r24, r24
    76b2:	99 0b       	sbc	r25, r25
    76b4:	08 95       	ret

000076b6 <itoa>:
    76b6:	fb 01       	movw	r30, r22
    76b8:	9f 01       	movw	r18, r30
    76ba:	e8 94       	clt
    76bc:	42 30       	cpi	r20, 0x02	; 2
    76be:	c4 f0       	brlt	.+48     	; 0x76f0 <itoa+0x3a>
    76c0:	45 32       	cpi	r20, 0x25	; 37
    76c2:	b4 f4       	brge	.+44     	; 0x76f0 <itoa+0x3a>
    76c4:	4a 30       	cpi	r20, 0x0A	; 10
    76c6:	29 f4       	brne	.+10     	; 0x76d2 <itoa+0x1c>
    76c8:	97 fb       	bst	r25, 7
    76ca:	1e f4       	brtc	.+6      	; 0x76d2 <itoa+0x1c>
    76cc:	90 95       	com	r25
    76ce:	81 95       	neg	r24
    76d0:	9f 4f       	sbci	r25, 0xFF	; 255
    76d2:	64 2f       	mov	r22, r20
    76d4:	77 27       	eor	r23, r23
    76d6:	0e 94 94 3a 	call	0x7528	; 0x7528 <__udivmodhi4>
    76da:	80 5d       	subi	r24, 0xD0	; 208
    76dc:	8a 33       	cpi	r24, 0x3A	; 58
    76de:	0c f0       	brlt	.+2      	; 0x76e2 <itoa+0x2c>
    76e0:	89 5d       	subi	r24, 0xD9	; 217
    76e2:	81 93       	st	Z+, r24
    76e4:	cb 01       	movw	r24, r22
    76e6:	00 97       	sbiw	r24, 0x00	; 0
    76e8:	a1 f7       	brne	.-24     	; 0x76d2 <itoa+0x1c>
    76ea:	16 f4       	brtc	.+4      	; 0x76f0 <itoa+0x3a>
    76ec:	5d e2       	ldi	r21, 0x2D	; 45
    76ee:	51 93       	st	Z+, r21
    76f0:	10 82       	st	Z, r1
    76f2:	c9 01       	movw	r24, r18
    76f4:	0c 94 d7 3d 	jmp	0x7bae	; 0x7bae <strrev>

000076f8 <printf>:
    76f8:	cf 93       	push	r28
    76fa:	df 93       	push	r29
    76fc:	cd b7       	in	r28, 0x3d	; 61
    76fe:	de b7       	in	r29, 0x3e	; 62
    7700:	fe 01       	movw	r30, r28
    7702:	36 96       	adiw	r30, 0x06	; 6
    7704:	61 91       	ld	r22, Z+
    7706:	71 91       	ld	r23, Z+
    7708:	80 91 d9 50 	lds	r24, 0x50D9
    770c:	90 91 da 50 	lds	r25, 0x50DA
    7710:	af 01       	movw	r20, r30
    7712:	0e 94 b7 3b 	call	0x776e	; 0x776e <vfprintf>
    7716:	df 91       	pop	r29
    7718:	cf 91       	pop	r28
    771a:	08 95       	ret

0000771c <sprintf>:
    771c:	0f 93       	push	r16
    771e:	1f 93       	push	r17
    7720:	cf 93       	push	r28
    7722:	df 93       	push	r29
    7724:	cd b7       	in	r28, 0x3d	; 61
    7726:	de b7       	in	r29, 0x3e	; 62
    7728:	2e 97       	sbiw	r28, 0x0e	; 14
    772a:	cd bf       	out	0x3d, r28	; 61
    772c:	de bf       	out	0x3e, r29	; 62
    772e:	0e 89       	ldd	r16, Y+22	; 0x16
    7730:	1f 89       	ldd	r17, Y+23	; 0x17
    7732:	86 e0       	ldi	r24, 0x06	; 6
    7734:	8c 83       	std	Y+4, r24	; 0x04
    7736:	09 83       	std	Y+1, r16	; 0x01
    7738:	1a 83       	std	Y+2, r17	; 0x02
    773a:	8f ef       	ldi	r24, 0xFF	; 255
    773c:	9f e7       	ldi	r25, 0x7F	; 127
    773e:	8d 83       	std	Y+5, r24	; 0x05
    7740:	9e 83       	std	Y+6, r25	; 0x06
    7742:	ae 01       	movw	r20, r28
    7744:	46 5e       	subi	r20, 0xE6	; 230
    7746:	5f 4f       	sbci	r21, 0xFF	; 255
    7748:	ce 01       	movw	r24, r28
    774a:	01 96       	adiw	r24, 0x01	; 1
    774c:	68 8d       	ldd	r22, Y+24	; 0x18
    774e:	79 8d       	ldd	r23, Y+25	; 0x19
    7750:	0e 94 b7 3b 	call	0x776e	; 0x776e <vfprintf>
    7754:	ef 81       	ldd	r30, Y+7	; 0x07
    7756:	f8 85       	ldd	r31, Y+8	; 0x08
    7758:	e0 0f       	add	r30, r16
    775a:	f1 1f       	adc	r31, r17
    775c:	10 82       	st	Z, r1
    775e:	2e 96       	adiw	r28, 0x0e	; 14
    7760:	cd bf       	out	0x3d, r28	; 61
    7762:	de bf       	out	0x3e, r29	; 62
    7764:	df 91       	pop	r29
    7766:	cf 91       	pop	r28
    7768:	1f 91       	pop	r17
    776a:	0f 91       	pop	r16
    776c:	08 95       	ret

0000776e <vfprintf>:
    776e:	2f 92       	push	r2
    7770:	3f 92       	push	r3
    7772:	4f 92       	push	r4
    7774:	5f 92       	push	r5
    7776:	6f 92       	push	r6
    7778:	7f 92       	push	r7
    777a:	8f 92       	push	r8
    777c:	9f 92       	push	r9
    777e:	af 92       	push	r10
    7780:	bf 92       	push	r11
    7782:	cf 92       	push	r12
    7784:	df 92       	push	r13
    7786:	ef 92       	push	r14
    7788:	ff 92       	push	r15
    778a:	0f 93       	push	r16
    778c:	1f 93       	push	r17
    778e:	cf 93       	push	r28
    7790:	df 93       	push	r29
    7792:	cd b7       	in	r28, 0x3d	; 61
    7794:	de b7       	in	r29, 0x3e	; 62
    7796:	2d 97       	sbiw	r28, 0x0d	; 13
    7798:	cd bf       	out	0x3d, r28	; 61
    779a:	de bf       	out	0x3e, r29	; 62
    779c:	3c 01       	movw	r6, r24
    779e:	6c 87       	std	Y+12, r22	; 0x0c
    77a0:	7d 87       	std	Y+13, r23	; 0x0d
    77a2:	5a 01       	movw	r10, r20
    77a4:	fc 01       	movw	r30, r24
    77a6:	16 82       	std	Z+6, r1	; 0x06
    77a8:	17 82       	std	Z+7, r1	; 0x07
    77aa:	83 81       	ldd	r24, Z+3	; 0x03
    77ac:	81 ff       	sbrs	r24, 1
    77ae:	c8 c1       	rjmp	.+912    	; 0x7b40 <vfprintf+0x3d2>
    77b0:	2e 01       	movw	r4, r28
    77b2:	08 94       	sec
    77b4:	41 1c       	adc	r4, r1
    77b6:	51 1c       	adc	r5, r1
    77b8:	f3 01       	movw	r30, r6
    77ba:	93 81       	ldd	r25, Z+3	; 0x03
    77bc:	ec 85       	ldd	r30, Y+12	; 0x0c
    77be:	fd 85       	ldd	r31, Y+13	; 0x0d
    77c0:	93 fd       	sbrc	r25, 3
    77c2:	85 91       	lpm	r24, Z+
    77c4:	93 ff       	sbrs	r25, 3
    77c6:	81 91       	ld	r24, Z+
    77c8:	ec 87       	std	Y+12, r30	; 0x0c
    77ca:	fd 87       	std	Y+13, r31	; 0x0d
    77cc:	88 23       	and	r24, r24
    77ce:	09 f4       	brne	.+2      	; 0x77d2 <vfprintf+0x64>
    77d0:	b3 c1       	rjmp	.+870    	; 0x7b38 <vfprintf+0x3ca>
    77d2:	85 32       	cpi	r24, 0x25	; 37
    77d4:	41 f4       	brne	.+16     	; 0x77e6 <vfprintf+0x78>
    77d6:	93 fd       	sbrc	r25, 3
    77d8:	85 91       	lpm	r24, Z+
    77da:	93 ff       	sbrs	r25, 3
    77dc:	81 91       	ld	r24, Z+
    77de:	ec 87       	std	Y+12, r30	; 0x0c
    77e0:	fd 87       	std	Y+13, r31	; 0x0d
    77e2:	85 32       	cpi	r24, 0x25	; 37
    77e4:	29 f4       	brne	.+10     	; 0x77f0 <vfprintf+0x82>
    77e6:	90 e0       	ldi	r25, 0x00	; 0
    77e8:	b3 01       	movw	r22, r6
    77ea:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    77ee:	e4 cf       	rjmp	.-56     	; 0x77b8 <vfprintf+0x4a>
    77f0:	ff 24       	eor	r15, r15
    77f2:	ee 24       	eor	r14, r14
    77f4:	10 e0       	ldi	r17, 0x00	; 0
    77f6:	10 32       	cpi	r17, 0x20	; 32
    77f8:	b0 f4       	brcc	.+44     	; 0x7826 <vfprintf+0xb8>
    77fa:	8b 32       	cpi	r24, 0x2B	; 43
    77fc:	69 f0       	breq	.+26     	; 0x7818 <vfprintf+0xaa>
    77fe:	8c 32       	cpi	r24, 0x2C	; 44
    7800:	28 f4       	brcc	.+10     	; 0x780c <vfprintf+0x9e>
    7802:	80 32       	cpi	r24, 0x20	; 32
    7804:	51 f0       	breq	.+20     	; 0x781a <vfprintf+0xac>
    7806:	83 32       	cpi	r24, 0x23	; 35
    7808:	71 f4       	brne	.+28     	; 0x7826 <vfprintf+0xb8>
    780a:	0b c0       	rjmp	.+22     	; 0x7822 <vfprintf+0xb4>
    780c:	8d 32       	cpi	r24, 0x2D	; 45
    780e:	39 f0       	breq	.+14     	; 0x781e <vfprintf+0xb0>
    7810:	80 33       	cpi	r24, 0x30	; 48
    7812:	49 f4       	brne	.+18     	; 0x7826 <vfprintf+0xb8>
    7814:	11 60       	ori	r17, 0x01	; 1
    7816:	2c c0       	rjmp	.+88     	; 0x7870 <vfprintf+0x102>
    7818:	12 60       	ori	r17, 0x02	; 2
    781a:	14 60       	ori	r17, 0x04	; 4
    781c:	29 c0       	rjmp	.+82     	; 0x7870 <vfprintf+0x102>
    781e:	18 60       	ori	r17, 0x08	; 8
    7820:	27 c0       	rjmp	.+78     	; 0x7870 <vfprintf+0x102>
    7822:	10 61       	ori	r17, 0x10	; 16
    7824:	25 c0       	rjmp	.+74     	; 0x7870 <vfprintf+0x102>
    7826:	17 fd       	sbrc	r17, 7
    7828:	2e c0       	rjmp	.+92     	; 0x7886 <vfprintf+0x118>
    782a:	28 2f       	mov	r18, r24
    782c:	20 53       	subi	r18, 0x30	; 48
    782e:	2a 30       	cpi	r18, 0x0A	; 10
    7830:	98 f4       	brcc	.+38     	; 0x7858 <vfprintf+0xea>
    7832:	16 ff       	sbrs	r17, 6
    7834:	08 c0       	rjmp	.+16     	; 0x7846 <vfprintf+0xd8>
    7836:	8f 2d       	mov	r24, r15
    7838:	88 0f       	add	r24, r24
    783a:	f8 2e       	mov	r15, r24
    783c:	ff 0c       	add	r15, r15
    783e:	ff 0c       	add	r15, r15
    7840:	f8 0e       	add	r15, r24
    7842:	f2 0e       	add	r15, r18
    7844:	15 c0       	rjmp	.+42     	; 0x7870 <vfprintf+0x102>
    7846:	8e 2d       	mov	r24, r14
    7848:	88 0f       	add	r24, r24
    784a:	e8 2e       	mov	r14, r24
    784c:	ee 0c       	add	r14, r14
    784e:	ee 0c       	add	r14, r14
    7850:	e8 0e       	add	r14, r24
    7852:	e2 0e       	add	r14, r18
    7854:	10 62       	ori	r17, 0x20	; 32
    7856:	0c c0       	rjmp	.+24     	; 0x7870 <vfprintf+0x102>
    7858:	8e 32       	cpi	r24, 0x2E	; 46
    785a:	21 f4       	brne	.+8      	; 0x7864 <vfprintf+0xf6>
    785c:	16 fd       	sbrc	r17, 6
    785e:	6c c1       	rjmp	.+728    	; 0x7b38 <vfprintf+0x3ca>
    7860:	10 64       	ori	r17, 0x40	; 64
    7862:	06 c0       	rjmp	.+12     	; 0x7870 <vfprintf+0x102>
    7864:	8c 36       	cpi	r24, 0x6C	; 108
    7866:	11 f4       	brne	.+4      	; 0x786c <vfprintf+0xfe>
    7868:	10 68       	ori	r17, 0x80	; 128
    786a:	02 c0       	rjmp	.+4      	; 0x7870 <vfprintf+0x102>
    786c:	88 36       	cpi	r24, 0x68	; 104
    786e:	59 f4       	brne	.+22     	; 0x7886 <vfprintf+0x118>
    7870:	ec 85       	ldd	r30, Y+12	; 0x0c
    7872:	fd 85       	ldd	r31, Y+13	; 0x0d
    7874:	93 fd       	sbrc	r25, 3
    7876:	85 91       	lpm	r24, Z+
    7878:	93 ff       	sbrs	r25, 3
    787a:	81 91       	ld	r24, Z+
    787c:	ec 87       	std	Y+12, r30	; 0x0c
    787e:	fd 87       	std	Y+13, r31	; 0x0d
    7880:	88 23       	and	r24, r24
    7882:	09 f0       	breq	.+2      	; 0x7886 <vfprintf+0x118>
    7884:	b8 cf       	rjmp	.-144    	; 0x77f6 <vfprintf+0x88>
    7886:	98 2f       	mov	r25, r24
    7888:	95 54       	subi	r25, 0x45	; 69
    788a:	93 30       	cpi	r25, 0x03	; 3
    788c:	18 f0       	brcs	.+6      	; 0x7894 <vfprintf+0x126>
    788e:	90 52       	subi	r25, 0x20	; 32
    7890:	93 30       	cpi	r25, 0x03	; 3
    7892:	38 f4       	brcc	.+14     	; 0x78a2 <vfprintf+0x134>
    7894:	24 e0       	ldi	r18, 0x04	; 4
    7896:	30 e0       	ldi	r19, 0x00	; 0
    7898:	a2 0e       	add	r10, r18
    789a:	b3 1e       	adc	r11, r19
    789c:	3f e3       	ldi	r19, 0x3F	; 63
    789e:	39 83       	std	Y+1, r19	; 0x01
    78a0:	0f c0       	rjmp	.+30     	; 0x78c0 <vfprintf+0x152>
    78a2:	83 36       	cpi	r24, 0x63	; 99
    78a4:	31 f0       	breq	.+12     	; 0x78b2 <vfprintf+0x144>
    78a6:	83 37       	cpi	r24, 0x73	; 115
    78a8:	81 f0       	breq	.+32     	; 0x78ca <vfprintf+0x15c>
    78aa:	83 35       	cpi	r24, 0x53	; 83
    78ac:	09 f0       	breq	.+2      	; 0x78b0 <vfprintf+0x142>
    78ae:	5a c0       	rjmp	.+180    	; 0x7964 <vfprintf+0x1f6>
    78b0:	22 c0       	rjmp	.+68     	; 0x78f6 <vfprintf+0x188>
    78b2:	f5 01       	movw	r30, r10
    78b4:	80 81       	ld	r24, Z
    78b6:	89 83       	std	Y+1, r24	; 0x01
    78b8:	22 e0       	ldi	r18, 0x02	; 2
    78ba:	30 e0       	ldi	r19, 0x00	; 0
    78bc:	a2 0e       	add	r10, r18
    78be:	b3 1e       	adc	r11, r19
    78c0:	21 e0       	ldi	r18, 0x01	; 1
    78c2:	c2 2e       	mov	r12, r18
    78c4:	d1 2c       	mov	r13, r1
    78c6:	42 01       	movw	r8, r4
    78c8:	14 c0       	rjmp	.+40     	; 0x78f2 <vfprintf+0x184>
    78ca:	92 e0       	ldi	r25, 0x02	; 2
    78cc:	29 2e       	mov	r2, r25
    78ce:	31 2c       	mov	r3, r1
    78d0:	2a 0c       	add	r2, r10
    78d2:	3b 1c       	adc	r3, r11
    78d4:	f5 01       	movw	r30, r10
    78d6:	80 80       	ld	r8, Z
    78d8:	91 80       	ldd	r9, Z+1	; 0x01
    78da:	16 ff       	sbrs	r17, 6
    78dc:	03 c0       	rjmp	.+6      	; 0x78e4 <vfprintf+0x176>
    78de:	6f 2d       	mov	r22, r15
    78e0:	70 e0       	ldi	r23, 0x00	; 0
    78e2:	02 c0       	rjmp	.+4      	; 0x78e8 <vfprintf+0x17a>
    78e4:	6f ef       	ldi	r22, 0xFF	; 255
    78e6:	7f ef       	ldi	r23, 0xFF	; 255
    78e8:	c4 01       	movw	r24, r8
    78ea:	0e 94 cc 3d 	call	0x7b98	; 0x7b98 <strnlen>
    78ee:	6c 01       	movw	r12, r24
    78f0:	51 01       	movw	r10, r2
    78f2:	1f 77       	andi	r17, 0x7F	; 127
    78f4:	15 c0       	rjmp	.+42     	; 0x7920 <vfprintf+0x1b2>
    78f6:	82 e0       	ldi	r24, 0x02	; 2
    78f8:	28 2e       	mov	r2, r24
    78fa:	31 2c       	mov	r3, r1
    78fc:	2a 0c       	add	r2, r10
    78fe:	3b 1c       	adc	r3, r11
    7900:	f5 01       	movw	r30, r10
    7902:	80 80       	ld	r8, Z
    7904:	91 80       	ldd	r9, Z+1	; 0x01
    7906:	16 ff       	sbrs	r17, 6
    7908:	03 c0       	rjmp	.+6      	; 0x7910 <vfprintf+0x1a2>
    790a:	6f 2d       	mov	r22, r15
    790c:	70 e0       	ldi	r23, 0x00	; 0
    790e:	02 c0       	rjmp	.+4      	; 0x7914 <vfprintf+0x1a6>
    7910:	6f ef       	ldi	r22, 0xFF	; 255
    7912:	7f ef       	ldi	r23, 0xFF	; 255
    7914:	c4 01       	movw	r24, r8
    7916:	0e 94 b8 3d 	call	0x7b70	; 0x7b70 <strnlen_P>
    791a:	6c 01       	movw	r12, r24
    791c:	10 68       	ori	r17, 0x80	; 128
    791e:	51 01       	movw	r10, r2
    7920:	13 fd       	sbrc	r17, 3
    7922:	1c c0       	rjmp	.+56     	; 0x795c <vfprintf+0x1ee>
    7924:	06 c0       	rjmp	.+12     	; 0x7932 <vfprintf+0x1c4>
    7926:	80 e2       	ldi	r24, 0x20	; 32
    7928:	90 e0       	ldi	r25, 0x00	; 0
    792a:	b3 01       	movw	r22, r6
    792c:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7930:	ea 94       	dec	r14
    7932:	8e 2d       	mov	r24, r14
    7934:	90 e0       	ldi	r25, 0x00	; 0
    7936:	c8 16       	cp	r12, r24
    7938:	d9 06       	cpc	r13, r25
    793a:	a8 f3       	brcs	.-22     	; 0x7926 <vfprintf+0x1b8>
    793c:	0f c0       	rjmp	.+30     	; 0x795c <vfprintf+0x1ee>
    793e:	f4 01       	movw	r30, r8
    7940:	17 fd       	sbrc	r17, 7
    7942:	85 91       	lpm	r24, Z+
    7944:	17 ff       	sbrs	r17, 7
    7946:	81 91       	ld	r24, Z+
    7948:	4f 01       	movw	r8, r30
    794a:	90 e0       	ldi	r25, 0x00	; 0
    794c:	b3 01       	movw	r22, r6
    794e:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7952:	e1 10       	cpse	r14, r1
    7954:	ea 94       	dec	r14
    7956:	08 94       	sec
    7958:	c1 08       	sbc	r12, r1
    795a:	d1 08       	sbc	r13, r1
    795c:	c1 14       	cp	r12, r1
    795e:	d1 04       	cpc	r13, r1
    7960:	71 f7       	brne	.-36     	; 0x793e <vfprintf+0x1d0>
    7962:	e7 c0       	rjmp	.+462    	; 0x7b32 <vfprintf+0x3c4>
    7964:	84 36       	cpi	r24, 0x64	; 100
    7966:	11 f0       	breq	.+4      	; 0x796c <vfprintf+0x1fe>
    7968:	89 36       	cpi	r24, 0x69	; 105
    796a:	51 f5       	brne	.+84     	; 0x79c0 <vfprintf+0x252>
    796c:	f5 01       	movw	r30, r10
    796e:	17 ff       	sbrs	r17, 7
    7970:	07 c0       	rjmp	.+14     	; 0x7980 <vfprintf+0x212>
    7972:	80 81       	ld	r24, Z
    7974:	91 81       	ldd	r25, Z+1	; 0x01
    7976:	a2 81       	ldd	r26, Z+2	; 0x02
    7978:	b3 81       	ldd	r27, Z+3	; 0x03
    797a:	24 e0       	ldi	r18, 0x04	; 4
    797c:	30 e0       	ldi	r19, 0x00	; 0
    797e:	08 c0       	rjmp	.+16     	; 0x7990 <vfprintf+0x222>
    7980:	80 81       	ld	r24, Z
    7982:	91 81       	ldd	r25, Z+1	; 0x01
    7984:	aa 27       	eor	r26, r26
    7986:	97 fd       	sbrc	r25, 7
    7988:	a0 95       	com	r26
    798a:	ba 2f       	mov	r27, r26
    798c:	22 e0       	ldi	r18, 0x02	; 2
    798e:	30 e0       	ldi	r19, 0x00	; 0
    7990:	a2 0e       	add	r10, r18
    7992:	b3 1e       	adc	r11, r19
    7994:	01 2f       	mov	r16, r17
    7996:	0f 76       	andi	r16, 0x6F	; 111
    7998:	b7 ff       	sbrs	r27, 7
    799a:	08 c0       	rjmp	.+16     	; 0x79ac <vfprintf+0x23e>
    799c:	b0 95       	com	r27
    799e:	a0 95       	com	r26
    79a0:	90 95       	com	r25
    79a2:	81 95       	neg	r24
    79a4:	9f 4f       	sbci	r25, 0xFF	; 255
    79a6:	af 4f       	sbci	r26, 0xFF	; 255
    79a8:	bf 4f       	sbci	r27, 0xFF	; 255
    79aa:	00 68       	ori	r16, 0x80	; 128
    79ac:	bc 01       	movw	r22, r24
    79ae:	cd 01       	movw	r24, r26
    79b0:	a2 01       	movw	r20, r4
    79b2:	2a e0       	ldi	r18, 0x0A	; 10
    79b4:	30 e0       	ldi	r19, 0x00	; 0
    79b6:	0e 94 13 3e 	call	0x7c26	; 0x7c26 <__ultoa_invert>
    79ba:	d8 2e       	mov	r13, r24
    79bc:	d4 18       	sub	r13, r4
    79be:	3f c0       	rjmp	.+126    	; 0x7a3e <vfprintf+0x2d0>
    79c0:	85 37       	cpi	r24, 0x75	; 117
    79c2:	21 f4       	brne	.+8      	; 0x79cc <vfprintf+0x25e>
    79c4:	1f 7e       	andi	r17, 0xEF	; 239
    79c6:	2a e0       	ldi	r18, 0x0A	; 10
    79c8:	30 e0       	ldi	r19, 0x00	; 0
    79ca:	20 c0       	rjmp	.+64     	; 0x7a0c <vfprintf+0x29e>
    79cc:	19 7f       	andi	r17, 0xF9	; 249
    79ce:	8f 36       	cpi	r24, 0x6F	; 111
    79d0:	a9 f0       	breq	.+42     	; 0x79fc <vfprintf+0x28e>
    79d2:	80 37       	cpi	r24, 0x70	; 112
    79d4:	20 f4       	brcc	.+8      	; 0x79de <vfprintf+0x270>
    79d6:	88 35       	cpi	r24, 0x58	; 88
    79d8:	09 f0       	breq	.+2      	; 0x79dc <vfprintf+0x26e>
    79da:	ae c0       	rjmp	.+348    	; 0x7b38 <vfprintf+0x3ca>
    79dc:	0b c0       	rjmp	.+22     	; 0x79f4 <vfprintf+0x286>
    79de:	80 37       	cpi	r24, 0x70	; 112
    79e0:	21 f0       	breq	.+8      	; 0x79ea <vfprintf+0x27c>
    79e2:	88 37       	cpi	r24, 0x78	; 120
    79e4:	09 f0       	breq	.+2      	; 0x79e8 <vfprintf+0x27a>
    79e6:	a8 c0       	rjmp	.+336    	; 0x7b38 <vfprintf+0x3ca>
    79e8:	01 c0       	rjmp	.+2      	; 0x79ec <vfprintf+0x27e>
    79ea:	10 61       	ori	r17, 0x10	; 16
    79ec:	14 ff       	sbrs	r17, 4
    79ee:	09 c0       	rjmp	.+18     	; 0x7a02 <vfprintf+0x294>
    79f0:	14 60       	ori	r17, 0x04	; 4
    79f2:	07 c0       	rjmp	.+14     	; 0x7a02 <vfprintf+0x294>
    79f4:	14 ff       	sbrs	r17, 4
    79f6:	08 c0       	rjmp	.+16     	; 0x7a08 <vfprintf+0x29a>
    79f8:	16 60       	ori	r17, 0x06	; 6
    79fa:	06 c0       	rjmp	.+12     	; 0x7a08 <vfprintf+0x29a>
    79fc:	28 e0       	ldi	r18, 0x08	; 8
    79fe:	30 e0       	ldi	r19, 0x00	; 0
    7a00:	05 c0       	rjmp	.+10     	; 0x7a0c <vfprintf+0x29e>
    7a02:	20 e1       	ldi	r18, 0x10	; 16
    7a04:	30 e0       	ldi	r19, 0x00	; 0
    7a06:	02 c0       	rjmp	.+4      	; 0x7a0c <vfprintf+0x29e>
    7a08:	20 e1       	ldi	r18, 0x10	; 16
    7a0a:	32 e0       	ldi	r19, 0x02	; 2
    7a0c:	f5 01       	movw	r30, r10
    7a0e:	17 ff       	sbrs	r17, 7
    7a10:	07 c0       	rjmp	.+14     	; 0x7a20 <vfprintf+0x2b2>
    7a12:	60 81       	ld	r22, Z
    7a14:	71 81       	ldd	r23, Z+1	; 0x01
    7a16:	82 81       	ldd	r24, Z+2	; 0x02
    7a18:	93 81       	ldd	r25, Z+3	; 0x03
    7a1a:	44 e0       	ldi	r20, 0x04	; 4
    7a1c:	50 e0       	ldi	r21, 0x00	; 0
    7a1e:	06 c0       	rjmp	.+12     	; 0x7a2c <vfprintf+0x2be>
    7a20:	60 81       	ld	r22, Z
    7a22:	71 81       	ldd	r23, Z+1	; 0x01
    7a24:	80 e0       	ldi	r24, 0x00	; 0
    7a26:	90 e0       	ldi	r25, 0x00	; 0
    7a28:	42 e0       	ldi	r20, 0x02	; 2
    7a2a:	50 e0       	ldi	r21, 0x00	; 0
    7a2c:	a4 0e       	add	r10, r20
    7a2e:	b5 1e       	adc	r11, r21
    7a30:	a2 01       	movw	r20, r4
    7a32:	0e 94 13 3e 	call	0x7c26	; 0x7c26 <__ultoa_invert>
    7a36:	d8 2e       	mov	r13, r24
    7a38:	d4 18       	sub	r13, r4
    7a3a:	01 2f       	mov	r16, r17
    7a3c:	0f 77       	andi	r16, 0x7F	; 127
    7a3e:	06 ff       	sbrs	r16, 6
    7a40:	09 c0       	rjmp	.+18     	; 0x7a54 <vfprintf+0x2e6>
    7a42:	0e 7f       	andi	r16, 0xFE	; 254
    7a44:	df 14       	cp	r13, r15
    7a46:	30 f4       	brcc	.+12     	; 0x7a54 <vfprintf+0x2e6>
    7a48:	04 ff       	sbrs	r16, 4
    7a4a:	06 c0       	rjmp	.+12     	; 0x7a58 <vfprintf+0x2ea>
    7a4c:	02 fd       	sbrc	r16, 2
    7a4e:	04 c0       	rjmp	.+8      	; 0x7a58 <vfprintf+0x2ea>
    7a50:	0f 7e       	andi	r16, 0xEF	; 239
    7a52:	02 c0       	rjmp	.+4      	; 0x7a58 <vfprintf+0x2ea>
    7a54:	1d 2d       	mov	r17, r13
    7a56:	01 c0       	rjmp	.+2      	; 0x7a5a <vfprintf+0x2ec>
    7a58:	1f 2d       	mov	r17, r15
    7a5a:	80 2f       	mov	r24, r16
    7a5c:	90 e0       	ldi	r25, 0x00	; 0
    7a5e:	04 ff       	sbrs	r16, 4
    7a60:	0c c0       	rjmp	.+24     	; 0x7a7a <vfprintf+0x30c>
    7a62:	fe 01       	movw	r30, r28
    7a64:	ed 0d       	add	r30, r13
    7a66:	f1 1d       	adc	r31, r1
    7a68:	20 81       	ld	r18, Z
    7a6a:	20 33       	cpi	r18, 0x30	; 48
    7a6c:	11 f4       	brne	.+4      	; 0x7a72 <vfprintf+0x304>
    7a6e:	09 7e       	andi	r16, 0xE9	; 233
    7a70:	09 c0       	rjmp	.+18     	; 0x7a84 <vfprintf+0x316>
    7a72:	02 ff       	sbrs	r16, 2
    7a74:	06 c0       	rjmp	.+12     	; 0x7a82 <vfprintf+0x314>
    7a76:	1e 5f       	subi	r17, 0xFE	; 254
    7a78:	05 c0       	rjmp	.+10     	; 0x7a84 <vfprintf+0x316>
    7a7a:	86 78       	andi	r24, 0x86	; 134
    7a7c:	90 70       	andi	r25, 0x00	; 0
    7a7e:	00 97       	sbiw	r24, 0x00	; 0
    7a80:	09 f0       	breq	.+2      	; 0x7a84 <vfprintf+0x316>
    7a82:	1f 5f       	subi	r17, 0xFF	; 255
    7a84:	80 2e       	mov	r8, r16
    7a86:	99 24       	eor	r9, r9
    7a88:	03 fd       	sbrc	r16, 3
    7a8a:	12 c0       	rjmp	.+36     	; 0x7ab0 <vfprintf+0x342>
    7a8c:	00 ff       	sbrs	r16, 0
    7a8e:	0d c0       	rjmp	.+26     	; 0x7aaa <vfprintf+0x33c>
    7a90:	fd 2c       	mov	r15, r13
    7a92:	1e 15       	cp	r17, r14
    7a94:	50 f4       	brcc	.+20     	; 0x7aaa <vfprintf+0x33c>
    7a96:	fe 0c       	add	r15, r14
    7a98:	f1 1a       	sub	r15, r17
    7a9a:	1e 2d       	mov	r17, r14
    7a9c:	06 c0       	rjmp	.+12     	; 0x7aaa <vfprintf+0x33c>
    7a9e:	80 e2       	ldi	r24, 0x20	; 32
    7aa0:	90 e0       	ldi	r25, 0x00	; 0
    7aa2:	b3 01       	movw	r22, r6
    7aa4:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7aa8:	1f 5f       	subi	r17, 0xFF	; 255
    7aaa:	1e 15       	cp	r17, r14
    7aac:	c0 f3       	brcs	.-16     	; 0x7a9e <vfprintf+0x330>
    7aae:	04 c0       	rjmp	.+8      	; 0x7ab8 <vfprintf+0x34a>
    7ab0:	1e 15       	cp	r17, r14
    7ab2:	10 f4       	brcc	.+4      	; 0x7ab8 <vfprintf+0x34a>
    7ab4:	e1 1a       	sub	r14, r17
    7ab6:	01 c0       	rjmp	.+2      	; 0x7aba <vfprintf+0x34c>
    7ab8:	ee 24       	eor	r14, r14
    7aba:	84 fe       	sbrs	r8, 4
    7abc:	0f c0       	rjmp	.+30     	; 0x7adc <vfprintf+0x36e>
    7abe:	80 e3       	ldi	r24, 0x30	; 48
    7ac0:	90 e0       	ldi	r25, 0x00	; 0
    7ac2:	b3 01       	movw	r22, r6
    7ac4:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7ac8:	82 fe       	sbrs	r8, 2
    7aca:	1f c0       	rjmp	.+62     	; 0x7b0a <vfprintf+0x39c>
    7acc:	81 fe       	sbrs	r8, 1
    7ace:	03 c0       	rjmp	.+6      	; 0x7ad6 <vfprintf+0x368>
    7ad0:	88 e5       	ldi	r24, 0x58	; 88
    7ad2:	90 e0       	ldi	r25, 0x00	; 0
    7ad4:	10 c0       	rjmp	.+32     	; 0x7af6 <vfprintf+0x388>
    7ad6:	88 e7       	ldi	r24, 0x78	; 120
    7ad8:	90 e0       	ldi	r25, 0x00	; 0
    7ada:	0d c0       	rjmp	.+26     	; 0x7af6 <vfprintf+0x388>
    7adc:	c4 01       	movw	r24, r8
    7ade:	86 78       	andi	r24, 0x86	; 134
    7ae0:	90 70       	andi	r25, 0x00	; 0
    7ae2:	00 97       	sbiw	r24, 0x00	; 0
    7ae4:	91 f0       	breq	.+36     	; 0x7b0a <vfprintf+0x39c>
    7ae6:	81 fc       	sbrc	r8, 1
    7ae8:	02 c0       	rjmp	.+4      	; 0x7aee <vfprintf+0x380>
    7aea:	80 e2       	ldi	r24, 0x20	; 32
    7aec:	01 c0       	rjmp	.+2      	; 0x7af0 <vfprintf+0x382>
    7aee:	8b e2       	ldi	r24, 0x2B	; 43
    7af0:	07 fd       	sbrc	r16, 7
    7af2:	8d e2       	ldi	r24, 0x2D	; 45
    7af4:	90 e0       	ldi	r25, 0x00	; 0
    7af6:	b3 01       	movw	r22, r6
    7af8:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7afc:	06 c0       	rjmp	.+12     	; 0x7b0a <vfprintf+0x39c>
    7afe:	80 e3       	ldi	r24, 0x30	; 48
    7b00:	90 e0       	ldi	r25, 0x00	; 0
    7b02:	b3 01       	movw	r22, r6
    7b04:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7b08:	fa 94       	dec	r15
    7b0a:	df 14       	cp	r13, r15
    7b0c:	c0 f3       	brcs	.-16     	; 0x7afe <vfprintf+0x390>
    7b0e:	da 94       	dec	r13
    7b10:	f2 01       	movw	r30, r4
    7b12:	ed 0d       	add	r30, r13
    7b14:	f1 1d       	adc	r31, r1
    7b16:	80 81       	ld	r24, Z
    7b18:	90 e0       	ldi	r25, 0x00	; 0
    7b1a:	b3 01       	movw	r22, r6
    7b1c:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7b20:	dd 20       	and	r13, r13
    7b22:	a9 f7       	brne	.-22     	; 0x7b0e <vfprintf+0x3a0>
    7b24:	06 c0       	rjmp	.+12     	; 0x7b32 <vfprintf+0x3c4>
    7b26:	80 e2       	ldi	r24, 0x20	; 32
    7b28:	90 e0       	ldi	r25, 0x00	; 0
    7b2a:	b3 01       	movw	r22, r6
    7b2c:	0e 94 e7 3d 	call	0x7bce	; 0x7bce <fputc>
    7b30:	ea 94       	dec	r14
    7b32:	ee 20       	and	r14, r14
    7b34:	c1 f7       	brne	.-16     	; 0x7b26 <vfprintf+0x3b8>
    7b36:	40 ce       	rjmp	.-896    	; 0x77b8 <vfprintf+0x4a>
    7b38:	f3 01       	movw	r30, r6
    7b3a:	86 81       	ldd	r24, Z+6	; 0x06
    7b3c:	97 81       	ldd	r25, Z+7	; 0x07
    7b3e:	02 c0       	rjmp	.+4      	; 0x7b44 <vfprintf+0x3d6>
    7b40:	8f ef       	ldi	r24, 0xFF	; 255
    7b42:	9f ef       	ldi	r25, 0xFF	; 255
    7b44:	2d 96       	adiw	r28, 0x0d	; 13
    7b46:	cd bf       	out	0x3d, r28	; 61
    7b48:	de bf       	out	0x3e, r29	; 62
    7b4a:	df 91       	pop	r29
    7b4c:	cf 91       	pop	r28
    7b4e:	1f 91       	pop	r17
    7b50:	0f 91       	pop	r16
    7b52:	ff 90       	pop	r15
    7b54:	ef 90       	pop	r14
    7b56:	df 90       	pop	r13
    7b58:	cf 90       	pop	r12
    7b5a:	bf 90       	pop	r11
    7b5c:	af 90       	pop	r10
    7b5e:	9f 90       	pop	r9
    7b60:	8f 90       	pop	r8
    7b62:	7f 90       	pop	r7
    7b64:	6f 90       	pop	r6
    7b66:	5f 90       	pop	r5
    7b68:	4f 90       	pop	r4
    7b6a:	3f 90       	pop	r3
    7b6c:	2f 90       	pop	r2
    7b6e:	08 95       	ret

00007b70 <strnlen_P>:
    7b70:	fc 01       	movw	r30, r24
    7b72:	05 90       	lpm	r0, Z+
    7b74:	61 50       	subi	r22, 0x01	; 1
    7b76:	70 40       	sbci	r23, 0x00	; 0
    7b78:	01 10       	cpse	r0, r1
    7b7a:	d8 f7       	brcc	.-10     	; 0x7b72 <strnlen_P+0x2>
    7b7c:	80 95       	com	r24
    7b7e:	90 95       	com	r25
    7b80:	8e 0f       	add	r24, r30
    7b82:	9f 1f       	adc	r25, r31
    7b84:	08 95       	ret

00007b86 <memcpy>:
    7b86:	fb 01       	movw	r30, r22
    7b88:	dc 01       	movw	r26, r24
    7b8a:	02 c0       	rjmp	.+4      	; 0x7b90 <memcpy+0xa>
    7b8c:	01 90       	ld	r0, Z+
    7b8e:	0d 92       	st	X+, r0
    7b90:	41 50       	subi	r20, 0x01	; 1
    7b92:	50 40       	sbci	r21, 0x00	; 0
    7b94:	d8 f7       	brcc	.-10     	; 0x7b8c <memcpy+0x6>
    7b96:	08 95       	ret

00007b98 <strnlen>:
    7b98:	fc 01       	movw	r30, r24
    7b9a:	61 50       	subi	r22, 0x01	; 1
    7b9c:	70 40       	sbci	r23, 0x00	; 0
    7b9e:	01 90       	ld	r0, Z+
    7ba0:	01 10       	cpse	r0, r1
    7ba2:	d8 f7       	brcc	.-10     	; 0x7b9a <strnlen+0x2>
    7ba4:	80 95       	com	r24
    7ba6:	90 95       	com	r25
    7ba8:	8e 0f       	add	r24, r30
    7baa:	9f 1f       	adc	r25, r31
    7bac:	08 95       	ret

00007bae <strrev>:
    7bae:	dc 01       	movw	r26, r24
    7bb0:	fc 01       	movw	r30, r24
    7bb2:	67 2f       	mov	r22, r23
    7bb4:	71 91       	ld	r23, Z+
    7bb6:	77 23       	and	r23, r23
    7bb8:	e1 f7       	brne	.-8      	; 0x7bb2 <strrev+0x4>
    7bba:	32 97       	sbiw	r30, 0x02	; 2
    7bbc:	04 c0       	rjmp	.+8      	; 0x7bc6 <strrev+0x18>
    7bbe:	7c 91       	ld	r23, X
    7bc0:	6d 93       	st	X+, r22
    7bc2:	70 83       	st	Z, r23
    7bc4:	62 91       	ld	r22, -Z
    7bc6:	ae 17       	cp	r26, r30
    7bc8:	bf 07       	cpc	r27, r31
    7bca:	c8 f3       	brcs	.-14     	; 0x7bbe <strrev+0x10>
    7bcc:	08 95       	ret

00007bce <fputc>:
    7bce:	0f 93       	push	r16
    7bd0:	1f 93       	push	r17
    7bd2:	cf 93       	push	r28
    7bd4:	df 93       	push	r29
    7bd6:	8c 01       	movw	r16, r24
    7bd8:	eb 01       	movw	r28, r22
    7bda:	8b 81       	ldd	r24, Y+3	; 0x03
    7bdc:	81 ff       	sbrs	r24, 1
    7bde:	1b c0       	rjmp	.+54     	; 0x7c16 <fputc+0x48>
    7be0:	82 ff       	sbrs	r24, 2
    7be2:	0d c0       	rjmp	.+26     	; 0x7bfe <fputc+0x30>
    7be4:	2e 81       	ldd	r18, Y+6	; 0x06
    7be6:	3f 81       	ldd	r19, Y+7	; 0x07
    7be8:	8c 81       	ldd	r24, Y+4	; 0x04
    7bea:	9d 81       	ldd	r25, Y+5	; 0x05
    7bec:	28 17       	cp	r18, r24
    7bee:	39 07       	cpc	r19, r25
    7bf0:	64 f4       	brge	.+24     	; 0x7c0a <fputc+0x3c>
    7bf2:	e8 81       	ld	r30, Y
    7bf4:	f9 81       	ldd	r31, Y+1	; 0x01
    7bf6:	01 93       	st	Z+, r16
    7bf8:	e8 83       	st	Y, r30
    7bfa:	f9 83       	std	Y+1, r31	; 0x01
    7bfc:	06 c0       	rjmp	.+12     	; 0x7c0a <fputc+0x3c>
    7bfe:	e8 85       	ldd	r30, Y+8	; 0x08
    7c00:	f9 85       	ldd	r31, Y+9	; 0x09
    7c02:	80 2f       	mov	r24, r16
    7c04:	19 95       	eicall
    7c06:	00 97       	sbiw	r24, 0x00	; 0
    7c08:	31 f4       	brne	.+12     	; 0x7c16 <fputc+0x48>
    7c0a:	8e 81       	ldd	r24, Y+6	; 0x06
    7c0c:	9f 81       	ldd	r25, Y+7	; 0x07
    7c0e:	01 96       	adiw	r24, 0x01	; 1
    7c10:	8e 83       	std	Y+6, r24	; 0x06
    7c12:	9f 83       	std	Y+7, r25	; 0x07
    7c14:	02 c0       	rjmp	.+4      	; 0x7c1a <fputc+0x4c>
    7c16:	0f ef       	ldi	r16, 0xFF	; 255
    7c18:	1f ef       	ldi	r17, 0xFF	; 255
    7c1a:	c8 01       	movw	r24, r16
    7c1c:	df 91       	pop	r29
    7c1e:	cf 91       	pop	r28
    7c20:	1f 91       	pop	r17
    7c22:	0f 91       	pop	r16
    7c24:	08 95       	ret

00007c26 <__ultoa_invert>:
    7c26:	fa 01       	movw	r30, r20
    7c28:	aa 27       	eor	r26, r26
    7c2a:	28 30       	cpi	r18, 0x08	; 8
    7c2c:	51 f1       	breq	.+84     	; 0x7c82 <__ultoa_invert+0x5c>
    7c2e:	20 31       	cpi	r18, 0x10	; 16
    7c30:	81 f1       	breq	.+96     	; 0x7c92 <__ultoa_invert+0x6c>
    7c32:	e8 94       	clt
    7c34:	6f 93       	push	r22
    7c36:	6e 7f       	andi	r22, 0xFE	; 254
    7c38:	6e 5f       	subi	r22, 0xFE	; 254
    7c3a:	7f 4f       	sbci	r23, 0xFF	; 255
    7c3c:	8f 4f       	sbci	r24, 0xFF	; 255
    7c3e:	9f 4f       	sbci	r25, 0xFF	; 255
    7c40:	af 4f       	sbci	r26, 0xFF	; 255
    7c42:	b1 e0       	ldi	r27, 0x01	; 1
    7c44:	3e d0       	rcall	.+124    	; 0x7cc2 <__ultoa_invert+0x9c>
    7c46:	b4 e0       	ldi	r27, 0x04	; 4
    7c48:	3c d0       	rcall	.+120    	; 0x7cc2 <__ultoa_invert+0x9c>
    7c4a:	67 0f       	add	r22, r23
    7c4c:	78 1f       	adc	r23, r24
    7c4e:	89 1f       	adc	r24, r25
    7c50:	9a 1f       	adc	r25, r26
    7c52:	a1 1d       	adc	r26, r1
    7c54:	68 0f       	add	r22, r24
    7c56:	79 1f       	adc	r23, r25
    7c58:	8a 1f       	adc	r24, r26
    7c5a:	91 1d       	adc	r25, r1
    7c5c:	a1 1d       	adc	r26, r1
    7c5e:	6a 0f       	add	r22, r26
    7c60:	71 1d       	adc	r23, r1
    7c62:	81 1d       	adc	r24, r1
    7c64:	91 1d       	adc	r25, r1
    7c66:	a1 1d       	adc	r26, r1
    7c68:	20 d0       	rcall	.+64     	; 0x7caa <__ultoa_invert+0x84>
    7c6a:	09 f4       	brne	.+2      	; 0x7c6e <__ultoa_invert+0x48>
    7c6c:	68 94       	set
    7c6e:	3f 91       	pop	r19
    7c70:	2a e0       	ldi	r18, 0x0A	; 10
    7c72:	26 9f       	mul	r18, r22
    7c74:	11 24       	eor	r1, r1
    7c76:	30 19       	sub	r19, r0
    7c78:	30 5d       	subi	r19, 0xD0	; 208
    7c7a:	31 93       	st	Z+, r19
    7c7c:	de f6       	brtc	.-74     	; 0x7c34 <__ultoa_invert+0xe>
    7c7e:	cf 01       	movw	r24, r30
    7c80:	08 95       	ret
    7c82:	46 2f       	mov	r20, r22
    7c84:	47 70       	andi	r20, 0x07	; 7
    7c86:	40 5d       	subi	r20, 0xD0	; 208
    7c88:	41 93       	st	Z+, r20
    7c8a:	b3 e0       	ldi	r27, 0x03	; 3
    7c8c:	0f d0       	rcall	.+30     	; 0x7cac <__ultoa_invert+0x86>
    7c8e:	c9 f7       	brne	.-14     	; 0x7c82 <__ultoa_invert+0x5c>
    7c90:	f6 cf       	rjmp	.-20     	; 0x7c7e <__ultoa_invert+0x58>
    7c92:	46 2f       	mov	r20, r22
    7c94:	4f 70       	andi	r20, 0x0F	; 15
    7c96:	40 5d       	subi	r20, 0xD0	; 208
    7c98:	4a 33       	cpi	r20, 0x3A	; 58
    7c9a:	18 f0       	brcs	.+6      	; 0x7ca2 <__ultoa_invert+0x7c>
    7c9c:	49 5d       	subi	r20, 0xD9	; 217
    7c9e:	31 fd       	sbrc	r19, 1
    7ca0:	40 52       	subi	r20, 0x20	; 32
    7ca2:	41 93       	st	Z+, r20
    7ca4:	02 d0       	rcall	.+4      	; 0x7caa <__ultoa_invert+0x84>
    7ca6:	a9 f7       	brne	.-22     	; 0x7c92 <__ultoa_invert+0x6c>
    7ca8:	ea cf       	rjmp	.-44     	; 0x7c7e <__ultoa_invert+0x58>
    7caa:	b4 e0       	ldi	r27, 0x04	; 4
    7cac:	a6 95       	lsr	r26
    7cae:	97 95       	ror	r25
    7cb0:	87 95       	ror	r24
    7cb2:	77 95       	ror	r23
    7cb4:	67 95       	ror	r22
    7cb6:	ba 95       	dec	r27
    7cb8:	c9 f7       	brne	.-14     	; 0x7cac <__ultoa_invert+0x86>
    7cba:	00 97       	sbiw	r24, 0x00	; 0
    7cbc:	61 05       	cpc	r22, r1
    7cbe:	71 05       	cpc	r23, r1
    7cc0:	08 95       	ret
    7cc2:	9b 01       	movw	r18, r22
    7cc4:	ac 01       	movw	r20, r24
    7cc6:	0a 2e       	mov	r0, r26
    7cc8:	06 94       	lsr	r0
    7cca:	57 95       	ror	r21
    7ccc:	47 95       	ror	r20
    7cce:	37 95       	ror	r19
    7cd0:	27 95       	ror	r18
    7cd2:	ba 95       	dec	r27
    7cd4:	c9 f7       	brne	.-14     	; 0x7cc8 <__ultoa_invert+0xa2>
    7cd6:	62 0f       	add	r22, r18
    7cd8:	73 1f       	adc	r23, r19
    7cda:	84 1f       	adc	r24, r20
    7cdc:	95 1f       	adc	r25, r21
    7cde:	a0 1d       	adc	r26, r0
    7ce0:	08 95       	ret

00007ce2 <_exit>:
    7ce2:	f8 94       	cli

00007ce4 <__stop_program>:
    7ce4:	ff cf       	rjmp	.-2      	; 0x7ce4 <__stop_program>
