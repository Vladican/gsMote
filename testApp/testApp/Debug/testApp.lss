
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007d70  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00802000  00007d70  00007e04  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa5  00802138  00802138  00007f3c  2**0
                  ALLOC
  3 .stab         000029b8  00000000  00000000  00007f3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2d  00000000  00000000  0000a8f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000400  00000000  00000000  0000b328  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cb89  00000000  00000000  0000b728  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000270a  00000000  00000000  000182b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005565  00000000  00000000  0001a9bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c9c  00000000  00000000  0001ff20  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004695  00000000  00000000  00021bbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008371  00000000  00000000  00026251  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b166  00000000  00000000  0002e5c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001a8  00000000  00000000  00189728  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 2d 09 	jmp	0x125a	; 0x125a <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 f2 0d 	jmp	0x1be4	; 0x1be4 <__vector_16>
      44:	0c 94 ca 0d 	jmp	0x1b94	; 0x1b94 <__vector_17>
      48:	0c 94 a2 0d 	jmp	0x1b44	; 0x1b44 <__vector_18>
      4c:	0c 94 5c 0d 	jmp	0x1ab8	; 0x1ab8 <__vector_19>
      50:	0c 94 7f 07 	jmp	0xefe	; 0xefe <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 e0 20 	jmp	0x41c0	; 0x41c0 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 c8 1a 	jmp	0x3590	; 0x3590 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 d5 0a 	jmp	0x15aa	; 0x15aa <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 34 0d 	jmp	0x1a68	; 0x1a68 <__vector_79>
     140:	0c 94 0c 0d 	jmp	0x1a18	; 0x1a18 <__vector_80>
     144:	0c 94 e4 0c 	jmp	0x19c8	; 0x19c8 <__vector_81>
     148:	0c 94 ba 0c 	jmp	0x1974	; 0x1974 <__vector_82>
     14c:	0c 94 9d 03 	jmp	0x73a	; 0x73a <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 11 08 	jmp	0x1022	; 0x1022 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e0 e7       	ldi	r30, 0x70	; 112
     244:	fd e7       	ldi	r31, 0x7D	; 125
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 33       	cpi	r26, 0x38	; 56
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e3       	ldi	r26, 0x38	; 56
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ad 3d       	cpi	r26, 0xDD	; 221
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 01 02 	call	0x402	; 0x402 <main>
     26a:	0c 94 b6 3e 	jmp	0x7d6c	; 0x7d6c <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	6b 01       	movw	r12, r22
     284:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     286:	dc 01       	movw	r26, r24
     288:	cb 01       	movw	r24, r22
     28a:	88 55       	subi	r24, 0x58	; 88
     28c:	92 40       	sbci	r25, 0x02	; 2
     28e:	a0 40       	sbci	r26, 0x00	; 0
     290:	b0 40       	sbci	r27, 0x00	; 0
     292:	89 3e       	cpi	r24, 0xE9	; 233
     294:	2f e3       	ldi	r18, 0x3F	; 63
     296:	92 07       	cpc	r25, r18
     298:	2f e0       	ldi	r18, 0x0F	; 15
     29a:	a2 07       	cpc	r26, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	b2 07       	cpc	r27, r18
     2a0:	08 f0       	brcs	.+2      	; 0x2a4 <StartSerial+0x32>
     2a2:	5c c0       	rjmp	.+184    	; 0x35c <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2a4:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2a8:	e0 e4       	ldi	r30, 0x40	; 64
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2b0:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2b2:	84 e0       	ldi	r24, 0x04	; 4
     2b4:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2b6:	cc 0c       	add	r12, r12
     2b8:	dd 1c       	adc	r13, r13
     2ba:	ee 1c       	adc	r14, r14
     2bc:	ff 1c       	adc	r15, r15
     2be:	cc 0c       	add	r12, r12
     2c0:	dd 1c       	adc	r13, r13
     2c2:	ee 1c       	adc	r14, r14
     2c4:	ff 1c       	adc	r15, r15
     2c6:	c7 01       	movw	r24, r14
     2c8:	b6 01       	movw	r22, r12
     2ca:	66 0f       	add	r22, r22
     2cc:	77 1f       	adc	r23, r23
     2ce:	88 1f       	adc	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	66 0f       	add	r22, r22
     2d4:	77 1f       	adc	r23, r23
     2d6:	88 1f       	adc	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	0e 94 04 3a 	call	0x7408	; 0x7408 <__floatunsisf>
     2de:	9b 01       	movw	r18, r22
     2e0:	ac 01       	movw	r20, r24
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	74 e2       	ldi	r23, 0x24	; 36
     2e6:	84 ef       	ldi	r24, 0xF4	; 244
     2e8:	9b e4       	ldi	r25, 0x4B	; 75
     2ea:	0e 94 70 39 	call	0x72e0	; 0x72e0 <__divsf3>
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	40 e8       	ldi	r20, 0x80	; 128
     2f4:	5f e3       	ldi	r21, 0x3F	; 63
     2f6:	0e 94 0b 39 	call	0x7216	; 0x7216 <__subsf3>
     2fa:	c6 2f       	mov	r28, r22
     2fc:	d7 2f       	mov	r29, r23
     2fe:	18 2f       	mov	r17, r24
     300:	09 2f       	mov	r16, r25
     302:	86 2f       	mov	r24, r22
     304:	9d 2f       	mov	r25, r29
     306:	a1 2f       	mov	r26, r17
     308:	b0 2f       	mov	r27, r16
     30a:	bc 01       	movw	r22, r24
     30c:	cd 01       	movw	r24, r26
     30e:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__fixunssfsi>
     312:	6b 01       	movw	r12, r22
     314:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 04 3a 	call	0x7408	; 0x7408 <__floatunsisf>
     31e:	9b 01       	movw	r18, r22
     320:	ac 01       	movw	r20, r24
     322:	8c 2f       	mov	r24, r28
     324:	9d 2f       	mov	r25, r29
     326:	a1 2f       	mov	r26, r17
     328:	b0 2f       	mov	r27, r16
     32a:	bc 01       	movw	r22, r24
     32c:	cd 01       	movw	r24, r26
     32e:	0e 94 0b 39 	call	0x7216	; 0x7216 <__subsf3>
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	40 e0       	ldi	r20, 0x00	; 0
     338:	5f e3       	ldi	r21, 0x3F	; 63
     33a:	0e 94 92 3a 	call	0x7524	; 0x7524 <__gesf2>
     33e:	88 23       	and	r24, r24
     340:	1c f0       	brlt	.+6      	; 0x348 <StartSerial+0xd6>
     342:	08 94       	sec
     344:	c1 1c       	adc	r12, r1
     346:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     348:	e0 ea       	ldi	r30, 0xA0	; 160
     34a:	f8 e0       	ldi	r31, 0x08	; 8
     34c:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     34e:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     354:	88 e1       	ldi	r24, 0x18	; 24
     356:	84 83       	std	Z+4, r24	; 0x04
	return true;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	01 c0       	rjmp	.+2      	; 0x35e <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     35c:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	1f 91       	pop	r17
     364:	0f 91       	pop	r16
     366:	ff 90       	pop	r15
     368:	ef 90       	pop	r14
     36a:	df 90       	pop	r13
     36c:	cf 90       	pop	r12
     36e:	08 95       	ret

00000370 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     370:	e0 ea       	ldi	r30, 0xA0	; 160
     372:	f8 e0       	ldi	r31, 0x08	; 8
     374:	91 81       	ldd	r25, Z+1	; 0x01
     376:	95 ff       	sbrs	r25, 5
     378:	fd cf       	rjmp	.-6      	; 0x374 <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     37a:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     37e:	08 95       	ret

00000380 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     380:	e0 ea       	ldi	r30, 0xA0	; 160
     382:	f8 e0       	ldi	r31, 0x08	; 8
     384:	81 81       	ldd	r24, Z+1	; 0x01
     386:	88 23       	and	r24, r24
     388:	ec f7       	brge	.-6      	; 0x384 <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     38a:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     38e:	08 95       	ret

00000390 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     390:	8f 92       	push	r8
     392:	9f 92       	push	r9
     394:	af 92       	push	r10
     396:	bf 92       	push	r11
     398:	cf 92       	push	r12
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	6a 01       	movw	r12, r20
     3a6:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     3a8:	41 15       	cp	r20, r1
     3aa:	51 05       	cpc	r21, r1
     3ac:	61 05       	cpc	r22, r1
     3ae:	71 05       	cpc	r23, r1
     3b0:	91 f0       	breq	.+36     	; 0x3d6 <SerialWriteBuffer+0x46>
     3b2:	c8 2f       	mov	r28, r24
     3b4:	d9 2f       	mov	r29, r25
     3b6:	88 24       	eor	r8, r8
     3b8:	99 24       	eor	r9, r9
     3ba:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     3bc:	89 91       	ld	r24, Y+
     3be:	0e 94 b8 01 	call	0x370	; 0x370 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     3c2:	08 94       	sec
     3c4:	81 1c       	adc	r8, r1
     3c6:	91 1c       	adc	r9, r1
     3c8:	a1 1c       	adc	r10, r1
     3ca:	b1 1c       	adc	r11, r1
     3cc:	8c 14       	cp	r8, r12
     3ce:	9d 04       	cpc	r9, r13
     3d0:	ae 04       	cpc	r10, r14
     3d2:	bf 04       	cpc	r11, r15
     3d4:	99 f7       	brne	.-26     	; 0x3bc <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	ff 90       	pop	r15
     3dc:	ef 90       	pop	r14
     3de:	df 90       	pop	r13
     3e0:	cf 90       	pop	r12
     3e2:	bf 90       	pop	r11
     3e4:	af 90       	pop	r10
     3e6:	9f 90       	pop	r9
     3e8:	8f 90       	pop	r8
     3ea:	08 95       	ret

000003ec <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     3ec:	e0 ea       	ldi	r30, 0xA0	; 160
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	84 81       	ldd	r24, Z+4	; 0x04
     3f2:	87 7e       	andi	r24, 0xE7	; 231
     3f4:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     3f6:	e0 e4       	ldi	r30, 0x40	; 64
     3f8:	f6 e0       	ldi	r31, 0x06	; 6
     3fa:	88 e0       	ldi	r24, 0x08	; 8
     3fc:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     3fe:	82 83       	std	Z+2, r24	; 0x02
     400:	08 95       	ret

00000402 <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
     40a:	6a 97       	sbiw	r28, 0x1a	; 26
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
	volatile uint32_t samples = 0;
     410:	19 82       	std	Y+1, r1	; 0x01
     412:	1a 82       	std	Y+2, r1	; 0x02
     414:	1b 82       	std	Y+3, r1	; 0x03
     416:	1c 82       	std	Y+4, r1	; 0x04
	DataAvailable = 0;
     418:	10 92 d5 21 	sts	0x21D5, r1
	ADC_Sampling_Finished = 1;
     41c:	81 e0       	ldi	r24, 0x01	; 1
     41e:	80 93 cd 50 	sts	0x50CD, r24
	uint8_t RadioMessageBuffer[20];
	set_32MHz();
     422:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <set_32MHz>
	chb_init();
     426:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <chb_init>
	chb_set_channel(1);
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <chb_set_channel>
	chb_set_short_addr(0x0002);
     430:	82 e0       	ldi	r24, 0x02	; 2
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 b6 18 	call	0x316c	; 0x316c <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     438:	0e 94 91 16 	call	0x2d22	; 0x2d22 <chb_get_pcb>
     43c:	7c 01       	movw	r14, r24

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
     43e:	0f 2e       	mov	r0, r31
     440:	f8 ee       	ldi	r31, 0xE8	; 232
     442:	cf 2e       	mov	r12, r31
     444:	f3 e0       	ldi	r31, 0x03	; 3
     446:	df 2e       	mov	r13, r31
     448:	f0 2d       	mov	r31, r0
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     44a:	1a 8e       	std	Y+26, r1	; 0x1a
								//if((samples*4-i) >= 100) chb_write(0x0000,(FRAMReadBuffer+i),100);
								//else chb_write(0x0000,(FRAMReadBuffer+i),(samples*4-i));
								//add 1 ms delay between messages
								//delay_us(10000);
							//}		
							uint8_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     44c:	0f 2e       	mov	r0, r31
     44e:	f4 e6       	ldi	r31, 0x64	; 100
     450:	8f 2e       	mov	r8, r31
     452:	f0 e0       	ldi	r31, 0x00	; 0
     454:	9f 2e       	mov	r9, r31
     456:	f0 e0       	ldi	r31, 0x00	; 0
     458:	af 2e       	mov	r10, r31
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	bf 2e       	mov	r11, r31
     45e:	f0 2d       	mov	r31, r0
     460:	02 c0       	rjmp	.+4      	; 0x466 <main+0x64>
					switch(RadioMessageBuffer[1]){
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     462:	81 e0       	ldi	r24, 0x01	; 1
     464:	8a 8f       	std	Y+26, r24	; 0x1a
	chb_init();
	chb_set_channel(1);
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
     466:	f7 01       	movw	r30, r14
     468:	83 81       	ldd	r24, Z+3	; 0x03
     46a:	88 23       	and	r24, r24
     46c:	e1 f3       	breq	.-8      	; 0x466 <main+0x64>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     46e:	ce 01       	movw	r24, r28
     470:	05 96       	adiw	r24, 0x05	; 5
     472:	0e 94 57 17 	call	0x2eae	; 0x2eae <chb_read>
			
			if(length == 1){
     476:	81 30       	cpi	r24, 0x01	; 1
     478:	b1 f7       	brne	.-20     	; 0x466 <main+0x64>
				switch ( RadioMessageBuffer[0])
     47a:	8d 81       	ldd	r24, Y+5	; 0x05
     47c:	82 35       	cpi	r24, 0x52	; 82
     47e:	71 f0       	breq	.+28     	; 0x49c <main+0x9a>
     480:	83 35       	cpi	r24, 0x53	; 83
     482:	30 f4       	brcc	.+12     	; 0x490 <main+0x8e>
     484:	86 34       	cpi	r24, 0x46	; 70
     486:	09 f4       	brne	.+2      	; 0x48a <main+0x88>
     488:	4e c0       	rjmp	.+156    	; 0x526 <main+0x124>
     48a:	87 34       	cpi	r24, 0x47	; 71
     48c:	61 f7       	brne	.-40     	; 0x466 <main+0x64>
     48e:	14 c0       	rjmp	.+40     	; 0x4b8 <main+0xb6>
     490:	83 35       	cpi	r24, 0x53	; 83
     492:	09 f4       	brne	.+2      	; 0x496 <main+0x94>
     494:	4b c0       	rjmp	.+150    	; 0x52c <main+0x12a>
     496:	84 35       	cpi	r24, 0x54	; 84
     498:	31 f7       	brne	.-52     	; 0x466 <main+0x64>
     49a:	50 c0       	rjmp	.+160    	; 0x53c <main+0x13a>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     49c:	80 91 cd 50 	lds	r24, 0x50CD
     4a0:	88 23       	and	r24, r24
     4a2:	09 f3       	breq	.-62     	; 0x466 <main+0x64>
						CO_collectADC(ADC_CH_1_gc, gain, freq, 1000,(int32_t*)FRAMReadBuffer);
     4a4:	80 e0       	ldi	r24, 0x00	; 0
     4a6:	6a 8d       	ldd	r22, Y+26	; 0x1a
     4a8:	a6 01       	movw	r20, r12
     4aa:	28 ee       	ldi	r18, 0xE8	; 232
     4ac:	33 e0       	ldi	r19, 0x03	; 3
     4ae:	0f ed       	ldi	r16, 0xDF	; 223
     4b0:	13 e2       	ldi	r17, 0x23	; 35
     4b2:	0e 94 99 15 	call	0x2b32	; 0x2b32 <CO_collectADC>
     4b6:	d7 cf       	rjmp	.-82     	; 0x466 <main+0x64>
						//CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
					}						
					break;
				case 'G':
					//set gain to what is specified
					switch(RadioMessageBuffer[1]){
     4b8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ba:	88 30       	cpi	r24, 0x08	; 8
     4bc:	d1 f0       	breq	.+52     	; 0x4f2 <main+0xf0>
     4be:	89 30       	cpi	r24, 0x09	; 9
     4c0:	38 f4       	brcc	.+14     	; 0x4d0 <main+0xce>
     4c2:	82 30       	cpi	r24, 0x02	; 2
     4c4:	71 f2       	breq	.-100    	; 0x462 <main+0x60>
     4c6:	84 30       	cpi	r24, 0x04	; 4
     4c8:	89 f0       	breq	.+34     	; 0x4ec <main+0xea>
     4ca:	81 30       	cpi	r24, 0x01	; 1
     4cc:	09 f5       	brne	.+66     	; 0x510 <main+0x10e>
     4ce:	0c c0       	rjmp	.+24     	; 0x4e8 <main+0xe6>
     4d0:	80 32       	cpi	r24, 0x20	; 32
     4d2:	a9 f0       	breq	.+42     	; 0x4fe <main+0xfc>
     4d4:	81 32       	cpi	r24, 0x21	; 33
     4d6:	18 f4       	brcc	.+6      	; 0x4de <main+0xdc>
     4d8:	80 31       	cpi	r24, 0x10	; 16
     4da:	d1 f4       	brne	.+52     	; 0x510 <main+0x10e>
     4dc:	0d c0       	rjmp	.+26     	; 0x4f8 <main+0xf6>
     4de:	80 34       	cpi	r24, 0x40	; 64
     4e0:	89 f0       	breq	.+34     	; 0x504 <main+0x102>
     4e2:	80 38       	cpi	r24, 0x80	; 128
     4e4:	a9 f4       	brne	.+42     	; 0x510 <main+0x10e>
     4e6:	11 c0       	rjmp	.+34     	; 0x50a <main+0x108>
						case 1:
							gain = GAIN_1_gc;
     4e8:	1a 8e       	std	Y+26, r1	; 0x1a
     4ea:	bd cf       	rjmp	.-134    	; 0x466 <main+0x64>
							break;
						case 2:
							gain = GAIN_2_gc;
							break;
						case 4:
							gain = GAIN_4_gc;
     4ec:	f2 e0       	ldi	r31, 0x02	; 2
     4ee:	fa 8f       	std	Y+26, r31	; 0x1a
							break;
     4f0:	ba cf       	rjmp	.-140    	; 0x466 <main+0x64>
						case 8:
							gain = GAIN_8_gc;
     4f2:	83 e0       	ldi	r24, 0x03	; 3
     4f4:	8a 8f       	std	Y+26, r24	; 0x1a
							break;
     4f6:	b7 cf       	rjmp	.-146    	; 0x466 <main+0x64>
						case 16:
							gain = GAIN_16_gc;
     4f8:	94 e0       	ldi	r25, 0x04	; 4
     4fa:	9a 8f       	std	Y+26, r25	; 0x1a
							break;
     4fc:	b4 cf       	rjmp	.-152    	; 0x466 <main+0x64>
						case 32:
							gain = GAIN_32_gc;
     4fe:	e5 e0       	ldi	r30, 0x05	; 5
     500:	ea 8f       	std	Y+26, r30	; 0x1a
							break;
     502:	b1 cf       	rjmp	.-158    	; 0x466 <main+0x64>
						case 64:
							gain = GAIN_64_gc;
     504:	f6 e0       	ldi	r31, 0x06	; 6
     506:	fa 8f       	std	Y+26, r31	; 0x1a
							break;
     508:	ae cf       	rjmp	.-164    	; 0x466 <main+0x64>
						case 128:
							gain = GAIN_128_gc;
     50a:	87 e0       	ldi	r24, 0x07	; 7
     50c:	8a 8f       	std	Y+26, r24	; 0x1a
							break;
     50e:	ab cf       	rjmp	.-170    	; 0x466 <main+0x64>
						default:
							chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
     510:	80 e0       	ldi	r24, 0x00	; 0
     512:	90 e0       	ldi	r25, 0x00	; 0
     514:	60 e0       	ldi	r22, 0x00	; 0
     516:	70 e2       	ldi	r23, 0x20	; 32
     518:	2c e0       	ldi	r18, 0x0C	; 12
     51a:	30 e0       	ldi	r19, 0x00	; 0
     51c:	40 e0       	ldi	r20, 0x00	; 0
     51e:	50 e0       	ldi	r21, 0x00	; 0
     520:	0e 94 94 16 	call	0x2d28	; 0x2d28 <chb_write>
							break;
     524:	a0 cf       	rjmp	.-192    	; 0x466 <main+0x64>
					}					
					break;
				case 'F':
					//set sampling frequency to what is specified
					freq = *(uint16_t*)(RadioMessageBuffer+1);
     526:	ce 80       	ldd	r12, Y+6	; 0x06
     528:	df 80       	ldd	r13, Y+7	; 0x07
					break;
     52a:	9d cf       	rjmp	.-198    	; 0x466 <main+0x64>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     52c:	80 91 cd 50 	lds	r24, 0x50CD
     530:	88 23       	and	r24, r24
     532:	09 f0       	breq	.+2      	; 0x536 <main+0x134>
     534:	98 cf       	rjmp	.-208    	; 0x466 <main+0x64>
						ADC_Stop_Sampling();
     536:	0e 94 c5 07 	call	0xf8a	; 0xf8a <ADC_Stop_Sampling>
     53a:	95 cf       	rjmp	.-214    	; 0x466 <main+0x64>
					}
					//otherwise, the ADC has finished sampling on its own and the data will be transmitted after this switch statement
					break;
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     53c:	80 91 cd 50 	lds	r24, 0x50CD
     540:	88 23       	and	r24, r24
     542:	09 f4       	brne	.+2      	; 0x546 <main+0x144>
     544:	90 cf       	rjmp	.-224    	; 0x466 <main+0x64>
     546:	80 91 d5 21 	lds	r24, 0x21D5
     54a:	88 23       	and	r24, r24
     54c:	09 f4       	brne	.+2      	; 0x550 <main+0x14e>
     54e:	8b cf       	rjmp	.-234    	; 0x466 <main+0x64>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     550:	0e 94 e6 07 	call	0xfcc	; 0xfcc <ADC_Get_Num_Samples>
     554:	a0 e0       	ldi	r26, 0x00	; 0
     556:	b0 e0       	ldi	r27, 0x00	; 0
     558:	89 83       	std	Y+1, r24	; 0x01
     55a:	9a 83       	std	Y+2, r25	; 0x02
     55c:	ab 83       	std	Y+3, r26	; 0x03
     55e:	bc 83       	std	Y+4, r27	; 0x04
						if(samples > 0){
     560:	89 81       	ldd	r24, Y+1	; 0x01
     562:	9a 81       	ldd	r25, Y+2	; 0x02
     564:	ab 81       	ldd	r26, Y+3	; 0x03
     566:	bc 81       	ldd	r27, Y+4	; 0x04
     568:	00 97       	sbiw	r24, 0x00	; 0
     56a:	a1 05       	cpc	r26, r1
     56c:	b1 05       	cpc	r27, r1
     56e:	09 f4       	brne	.+2      	; 0x572 <main+0x170>
     570:	a9 c0       	rjmp	.+338    	; 0x6c4 <main+0x2c2>
								//if((samples*4-i) >= 100) chb_write(0x0000,(FRAMReadBuffer+i),100);
								//else chb_write(0x0000,(FRAMReadBuffer+i),(samples*4-i));
								//add 1 ms delay between messages
								//delay_us(10000);
							//}		
							uint8_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     572:	89 81       	ldd	r24, Y+1	; 0x01
     574:	9a 81       	ldd	r25, Y+2	; 0x02
     576:	ab 81       	ldd	r26, Y+3	; 0x03
     578:	bc 81       	ldd	r27, Y+4	; 0x04
     57a:	bc 01       	movw	r22, r24
     57c:	cd 01       	movw	r24, r26
     57e:	66 0f       	add	r22, r22
     580:	77 1f       	adc	r23, r23
     582:	88 1f       	adc	r24, r24
     584:	99 1f       	adc	r25, r25
     586:	66 0f       	add	r22, r22
     588:	77 1f       	adc	r23, r23
     58a:	88 1f       	adc	r24, r24
     58c:	99 1f       	adc	r25, r25
     58e:	a5 01       	movw	r20, r10
     590:	94 01       	movw	r18, r8
     592:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     596:	02 2f       	mov	r16, r18
     598:	29 8f       	std	Y+25, r18	; 0x19
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
     59a:	89 81       	ldd	r24, Y+1	; 0x01
     59c:	9a 81       	ldd	r25, Y+2	; 0x02
     59e:	ab 81       	ldd	r26, Y+3	; 0x03
     5a0:	bc 81       	ldd	r27, Y+4	; 0x04
     5a2:	bc 01       	movw	r22, r24
     5a4:	cd 01       	movw	r24, r26
     5a6:	66 0f       	add	r22, r22
     5a8:	77 1f       	adc	r23, r23
     5aa:	88 1f       	adc	r24, r24
     5ac:	99 1f       	adc	r25, r25
     5ae:	66 0f       	add	r22, r22
     5b0:	77 1f       	adc	r23, r23
     5b2:	88 1f       	adc	r24, r24
     5b4:	99 1f       	adc	r25, r25
     5b6:	a5 01       	movw	r20, r10
     5b8:	94 01       	movw	r18, r8
     5ba:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     5be:	dc 01       	movw	r26, r24
     5c0:	cb 01       	movw	r24, r22
     5c2:	00 97       	sbiw	r24, 0x00	; 0
     5c4:	a1 05       	cpc	r26, r1
     5c6:	b1 05       	cpc	r27, r1
     5c8:	11 f0       	breq	.+4      	; 0x5ce <main+0x1cc>
     5ca:	0f 5f       	subi	r16, 0xFF	; 255
     5cc:	09 8f       	std	Y+25, r16	; 0x19
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,1);  
     5ce:	80 e0       	ldi	r24, 0x00	; 0
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	be 01       	movw	r22, r28
     5d4:	67 5e       	subi	r22, 0xE7	; 231
     5d6:	7f 4f       	sbci	r23, 0xFF	; 255
     5d8:	21 e0       	ldi	r18, 0x01	; 1
     5da:	30 e0       	ldi	r19, 0x00	; 0
     5dc:	40 e0       	ldi	r20, 0x00	; 0
     5de:	50 e0       	ldi	r21, 0x00	; 0
     5e0:	0e 94 94 16 	call	0x2d28	; 0x2d28 <chb_write>
							//send the data
							for(int i=0;i<(4*samples); i+=100){
     5e4:	89 81       	ldd	r24, Y+1	; 0x01
     5e6:	9a 81       	ldd	r25, Y+2	; 0x02
     5e8:	ab 81       	ldd	r26, Y+3	; 0x03
     5ea:	bc 81       	ldd	r27, Y+4	; 0x04
     5ec:	88 0f       	add	r24, r24
     5ee:	99 1f       	adc	r25, r25
     5f0:	aa 1f       	adc	r26, r26
     5f2:	bb 1f       	adc	r27, r27
     5f4:	88 0f       	add	r24, r24
     5f6:	99 1f       	adc	r25, r25
     5f8:	aa 1f       	adc	r26, r26
     5fa:	bb 1f       	adc	r27, r27
     5fc:	00 97       	sbiw	r24, 0x00	; 0
     5fe:	a1 05       	cpc	r26, r1
     600:	b1 05       	cpc	r27, r1
     602:	09 f4       	brne	.+2      	; 0x606 <main+0x204>
     604:	5f c0       	rjmp	.+190    	; 0x6c4 <main+0x2c2>
     606:	40 e0       	ldi	r20, 0x00	; 0
     608:	50 e0       	ldi	r21, 0x00	; 0
     60a:	ba 01       	movw	r22, r20
     60c:	00 e0       	ldi	r16, 0x00	; 0
     60e:	10 e0       	ldi	r17, 0x00	; 0
								if((samples*4-i) >= 100) chb_write(0x0000,(FRAMReadBuffer+i),100);
     610:	89 81       	ldd	r24, Y+1	; 0x01
     612:	9a 81       	ldd	r25, Y+2	; 0x02
     614:	ab 81       	ldd	r26, Y+3	; 0x03
     616:	bc 81       	ldd	r27, Y+4	; 0x04
     618:	88 0f       	add	r24, r24
     61a:	99 1f       	adc	r25, r25
     61c:	aa 1f       	adc	r26, r26
     61e:	bb 1f       	adc	r27, r27
     620:	88 0f       	add	r24, r24
     622:	99 1f       	adc	r25, r25
     624:	aa 1f       	adc	r26, r26
     626:	bb 1f       	adc	r27, r27
     628:	84 1b       	sub	r24, r20
     62a:	95 0b       	sbc	r25, r21
     62c:	a6 0b       	sbc	r26, r22
     62e:	b7 0b       	sbc	r27, r23
     630:	84 36       	cpi	r24, 0x64	; 100
     632:	91 05       	cpc	r25, r1
     634:	a1 05       	cpc	r26, r1
     636:	b1 05       	cpc	r27, r1
     638:	50 f0       	brcs	.+20     	; 0x64e <main+0x24c>
     63a:	b8 01       	movw	r22, r16
     63c:	61 52       	subi	r22, 0x21	; 33
     63e:	7c 4d       	sbci	r23, 0xDC	; 220
     640:	80 e0       	ldi	r24, 0x00	; 0
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	a5 01       	movw	r20, r10
     646:	94 01       	movw	r18, r8
     648:	0e 94 94 16 	call	0x2d28	; 0x2d28 <chb_write>
     64c:	1c c0       	rjmp	.+56     	; 0x686 <main+0x284>
								else chb_write(0x0000,(FRAMReadBuffer+i),(samples*4-i));
     64e:	89 81       	ldd	r24, Y+1	; 0x01
     650:	9a 81       	ldd	r25, Y+2	; 0x02
     652:	ab 81       	ldd	r26, Y+3	; 0x03
     654:	bc 81       	ldd	r27, Y+4	; 0x04
     656:	f8 01       	movw	r30, r16
     658:	e1 52       	subi	r30, 0x21	; 33
     65a:	fc 4d       	sbci	r31, 0xDC	; 220
     65c:	88 0f       	add	r24, r24
     65e:	99 1f       	adc	r25, r25
     660:	aa 1f       	adc	r26, r26
     662:	bb 1f       	adc	r27, r27
     664:	88 0f       	add	r24, r24
     666:	99 1f       	adc	r25, r25
     668:	aa 1f       	adc	r26, r26
     66a:	bb 1f       	adc	r27, r27
     66c:	2c 01       	movw	r4, r24
     66e:	3d 01       	movw	r6, r26
     670:	44 1a       	sub	r4, r20
     672:	55 0a       	sbc	r5, r21
     674:	66 0a       	sbc	r6, r22
     676:	77 0a       	sbc	r7, r23
     678:	a3 01       	movw	r20, r6
     67a:	92 01       	movw	r18, r4
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	bf 01       	movw	r22, r30
     682:	0e 94 94 16 	call	0x2d28	; 0x2d28 <chb_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     686:	8f e9       	ldi	r24, 0x9F	; 159
     688:	9f e0       	ldi	r25, 0x0F	; 15
     68a:	01 97       	sbiw	r24, 0x01	; 1
     68c:	f1 f7       	brne	.-4      	; 0x68a <main+0x288>
     68e:	00 c0       	rjmp	.+0      	; 0x690 <main+0x28e>
     690:	00 00       	nop
							uint8_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,1);  
							//send the data
							for(int i=0;i<(4*samples); i+=100){
     692:	0c 59       	subi	r16, 0x9C	; 156
     694:	1f 4f       	sbci	r17, 0xFF	; 255
     696:	a8 01       	movw	r20, r16
     698:	66 27       	eor	r22, r22
     69a:	57 fd       	sbrc	r21, 7
     69c:	60 95       	com	r22
     69e:	76 2f       	mov	r23, r22
     6a0:	89 81       	ldd	r24, Y+1	; 0x01
     6a2:	9a 81       	ldd	r25, Y+2	; 0x02
     6a4:	ab 81       	ldd	r26, Y+3	; 0x03
     6a6:	bc 81       	ldd	r27, Y+4	; 0x04
     6a8:	88 0f       	add	r24, r24
     6aa:	99 1f       	adc	r25, r25
     6ac:	aa 1f       	adc	r26, r26
     6ae:	bb 1f       	adc	r27, r27
     6b0:	88 0f       	add	r24, r24
     6b2:	99 1f       	adc	r25, r25
     6b4:	aa 1f       	adc	r26, r26
     6b6:	bb 1f       	adc	r27, r27
     6b8:	48 17       	cp	r20, r24
     6ba:	59 07       	cpc	r21, r25
     6bc:	6a 07       	cpc	r22, r26
     6be:	7b 07       	cpc	r23, r27
     6c0:	08 f4       	brcc	.+2      	; 0x6c4 <main+0x2c2>
     6c2:	a6 cf       	rjmp	.-180    	; 0x610 <main+0x20e>
								else chb_write(0x0000,(FRAMReadBuffer+i),(samples*4-i));
								_delay_us(500);
							}								
							//chb_write(0x0000,FRAMReadBuffer,samples*4);					
						}							
						DataAvailable = 0;
     6c4:	10 92 d5 21 	sts	0x21D5, r1
     6c8:	ce ce       	rjmp	.-612    	; 0x466 <main+0x64>

000006ca <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     6ca:	0f 93       	push	r16
     6cc:	1f 93       	push	r17
     6ce:	cf 93       	push	r28
     6d0:	8c 01       	movw	r16, r24
	moteID = 1;
     6d2:	c1 e0       	ldi	r28, 0x01	; 1
     6d4:	c0 93 c8 50 	sts	0x50C8, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     6d8:	83 e0       	ldi	r24, 0x03	; 3
     6da:	80 93 5e 40 	sts	0x405E, r24
	chb_init();
     6de:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <chb_init>
	chb_set_short_addr(moteID);
     6e2:	80 91 c8 50 	lds	r24, 0x50C8
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	0e 94 b6 18 	call	0x316c	; 0x316c <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     6ec:	88 ec       	ldi	r24, 0xC8	; 200
     6ee:	e0 e8       	ldi	r30, 0x80	; 128
     6f0:	f1 e0       	ldi	r31, 0x01	; 1
     6f2:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     6f4:	e0 e4       	ldi	r30, 0x40	; 64
     6f6:	f9 e0       	ldi	r31, 0x09	; 9
     6f8:	89 e0       	ldi	r24, 0x09	; 9
     6fa:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     6fc:	82 e0       	ldi	r24, 0x02	; 2
     6fe:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     700:	24 ef       	ldi	r18, 0xF4	; 244
     702:	31 e0       	ldi	r19, 0x01	; 1
     704:	02 9f       	mul	r16, r18
     706:	c0 01       	movw	r24, r0
     708:	03 9f       	mul	r16, r19
     70a:	90 0d       	add	r25, r0
     70c:	12 9f       	mul	r17, r18
     70e:	90 0d       	add	r25, r0
     710:	11 24       	eor	r1, r1
     712:	86 a3       	lds	r24, 0x56
     714:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     716:	e0 e4       	ldi	r30, 0x40	; 64
     718:	f8 e0       	ldi	r31, 0x08	; 8
     71a:	80 e0       	ldi	r24, 0x00	; 0
     71c:	9a ef       	ldi	r25, 0xFA	; 250
     71e:	86 a3       	lds	r24, 0x56
     720:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     722:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     724:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     726:	e0 ea       	ldi	r30, 0xA0	; 160
     728:	f0 e0       	ldi	r31, 0x00	; 0
     72a:	82 81       	ldd	r24, Z+2	; 0x02
     72c:	87 60       	ori	r24, 0x07	; 7
     72e:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     730:	78 94       	sei
}
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	08 95       	ret

0000073a <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     73a:	78 94       	sei
     73c:	1f 92       	push	r1
     73e:	0f 92       	push	r0
     740:	0f b6       	in	r0, 0x3f	; 63
     742:	0f 92       	push	r0
     744:	0b b6       	in	r0, 0x3b	; 59
     746:	0f 92       	push	r0
     748:	11 24       	eor	r1, r1
     74a:	ef 92       	push	r14
     74c:	ff 92       	push	r15
     74e:	0f 93       	push	r16
     750:	1f 93       	push	r17
     752:	2f 93       	push	r18
     754:	3f 93       	push	r19
     756:	4f 93       	push	r20
     758:	5f 93       	push	r21
     75a:	6f 93       	push	r22
     75c:	7f 93       	push	r23
     75e:	8f 93       	push	r24
     760:	9f 93       	push	r25
     762:	af 93       	push	r26
     764:	bf 93       	push	r27
     766:	ef 93       	push	r30
     768:	ff 93       	push	r31
     76a:	cf 93       	push	r28
     76c:	df 93       	push	r29
     76e:	cd b7       	in	r28, 0x3d	; 61
     770:	de b7       	in	r29, 0x3e	; 62
     772:	28 97       	sbiw	r28, 0x08	; 8
     774:	cd bf       	out	0x3d, r28	; 61
     776:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     778:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
     77c:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     780:	82 e0       	ldi	r24, 0x02	; 2
     782:	80 93 5e 40 	sts	0x405E, r24
	char message[8];
	strcpy(message,"reset");
     786:	de 01       	movw	r26, r28
     788:	11 96       	adiw	r26, 0x01	; 1
     78a:	ed e0       	ldi	r30, 0x0D	; 13
     78c:	f0 e2       	ldi	r31, 0x20	; 32
     78e:	86 e0       	ldi	r24, 0x06	; 6
     790:	01 90       	ld	r0, Z+
     792:	0d 92       	st	X+, r0
     794:	81 50       	subi	r24, 0x01	; 1
     796:	e1 f7       	brne	.-8      	; 0x790 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
     798:	0f ec       	ldi	r16, 0xCF	; 207
     79a:	10 e5       	ldi	r17, 0x50	; 80
     79c:	80 91 c8 50 	lds	r24, 0x50C8
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	b8 01       	movw	r22, r16
     7a4:	4a e0       	ldi	r20, 0x0A	; 10
     7a6:	50 e0       	ldi	r21, 0x00	; 0
     7a8:	0e 94 a0 3b 	call	0x7740	; 0x7740 <itoa>
	strcat(message,buff);
     7ac:	7e 01       	movw	r14, r28
     7ae:	08 94       	sec
     7b0:	e1 1c       	adc	r14, r1
     7b2:	f1 1c       	adc	r15, r1
     7b4:	c7 01       	movw	r24, r14
     7b6:	b8 01       	movw	r22, r16
     7b8:	0e 94 87 3b 	call	0x770e	; 0x770e <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     7bc:	0e 94 08 08 	call	0x1010	; 0x1010 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     7c0:	f7 01       	movw	r30, r14
     7c2:	01 90       	ld	r0, Z+
     7c4:	00 20       	and	r0, r0
     7c6:	e9 f7       	brne	.-6      	; 0x7c2 <__vector_83+0x88>
     7c8:	31 97       	sbiw	r30, 0x01	; 1
     7ca:	ee 19       	sub	r30, r14
     7cc:	ff 09       	sbc	r31, r15
     7ce:	9f 01       	movw	r18, r30
     7d0:	40 e0       	ldi	r20, 0x00	; 0
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	80 e0       	ldi	r24, 0x00	; 0
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	b7 01       	movw	r22, r14
     7da:	0e 94 94 16 	call	0x2d28	; 0x2d28 <chb_write>
}	
     7de:	28 96       	adiw	r28, 0x08	; 8
     7e0:	cd bf       	out	0x3d, r28	; 61
     7e2:	de bf       	out	0x3e, r29	; 62
     7e4:	df 91       	pop	r29
     7e6:	cf 91       	pop	r28
     7e8:	ff 91       	pop	r31
     7ea:	ef 91       	pop	r30
     7ec:	bf 91       	pop	r27
     7ee:	af 91       	pop	r26
     7f0:	9f 91       	pop	r25
     7f2:	8f 91       	pop	r24
     7f4:	7f 91       	pop	r23
     7f6:	6f 91       	pop	r22
     7f8:	5f 91       	pop	r21
     7fa:	4f 91       	pop	r20
     7fc:	3f 91       	pop	r19
     7fe:	2f 91       	pop	r18
     800:	1f 91       	pop	r17
     802:	0f 91       	pop	r16
     804:	ff 90       	pop	r15
     806:	ef 90       	pop	r14
     808:	0f 90       	pop	r0
     80a:	0b be       	out	0x3b, r0	; 59
     80c:	0f 90       	pop	r0
     80e:	0f be       	out	0x3f, r0	; 63
     810:	0f 90       	pop	r0
     812:	1f 90       	pop	r1
     814:	18 95       	reti

00000816 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     816:	cf 93       	push	r28
     818:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     81a:	21 e0       	ldi	r18, 0x01	; 1
     81c:	30 e0       	ldi	r19, 0x00	; 0
     81e:	a9 01       	movw	r20, r18
     820:	02 c0       	rjmp	.+4      	; 0x826 <set_ampGain+0x10>
     822:	44 0f       	add	r20, r20
     824:	55 1f       	adc	r21, r21
     826:	8a 95       	dec	r24
     828:	e2 f7       	brpl	.-8      	; 0x822 <set_ampGain+0xc>
     82a:	ca 01       	movw	r24, r20
     82c:	61 e0       	ldi	r22, 0x01	; 1
     82e:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     832:	c0 ff       	sbrs	r28, 0
     834:	05 c0       	rjmp	.+10     	; 0x840 <set_ampGain+0x2a>
     836:	80 e4       	ldi	r24, 0x40	; 64
     838:	e0 e0       	ldi	r30, 0x00	; 0
     83a:	f6 e0       	ldi	r31, 0x06	; 6
     83c:	85 83       	std	Z+5, r24	; 0x05
     83e:	04 c0       	rjmp	.+8      	; 0x848 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
     840:	80 e4       	ldi	r24, 0x40	; 64
     842:	e0 e0       	ldi	r30, 0x00	; 0
     844:	f6 e0       	ldi	r31, 0x06	; 6
     846:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     848:	c1 ff       	sbrs	r28, 1
     84a:	05 c0       	rjmp	.+10     	; 0x856 <set_ampGain+0x40>
     84c:	82 e0       	ldi	r24, 0x02	; 2
     84e:	e0 e2       	ldi	r30, 0x20	; 32
     850:	f6 e0       	ldi	r31, 0x06	; 6
     852:	85 83       	std	Z+5, r24	; 0x05
     854:	04 c0       	rjmp	.+8      	; 0x85e <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
     856:	82 e0       	ldi	r24, 0x02	; 2
     858:	e0 e2       	ldi	r30, 0x20	; 32
     85a:	f6 e0       	ldi	r31, 0x06	; 6
     85c:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     85e:	c2 ff       	sbrs	r28, 2
     860:	05 c0       	rjmp	.+10     	; 0x86c <set_ampGain+0x56>
     862:	84 e0       	ldi	r24, 0x04	; 4
     864:	e0 e2       	ldi	r30, 0x20	; 32
     866:	f6 e0       	ldi	r31, 0x06	; 6
     868:	85 83       	std	Z+5, r24	; 0x05
     86a:	04 c0       	rjmp	.+8      	; 0x874 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
     86c:	84 e0       	ldi	r24, 0x04	; 4
     86e:	e0 e2       	ldi	r30, 0x20	; 32
     870:	f6 e0       	ldi	r31, 0x06	; 6
     872:	86 83       	std	Z+6, r24	; 0x06
     874:	5a e0       	ldi	r21, 0x0A	; 10
     876:	5a 95       	dec	r21
     878:	f1 f7       	brne	.-4      	; 0x876 <set_ampGain+0x60>
     87a:	00 c0       	rjmp	.+0      	; 0x87c <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     87c:	8f ef       	ldi	r24, 0xFF	; 255
     87e:	61 e0       	ldi	r22, 0x01	; 1
     880:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     884:	cf 91       	pop	r28
     886:	08 95       	ret

00000888 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     88c:	c8 2f       	mov	r28, r24
     88e:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     890:	d8 2f       	mov	r29, r24
     892:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     894:	28 2f       	mov	r18, r24
     896:	30 e0       	ldi	r19, 0x00	; 0
     898:	a9 01       	movw	r20, r18
     89a:	45 70       	andi	r20, 0x05	; 5
     89c:	50 70       	andi	r21, 0x00	; 0
     89e:	41 15       	cp	r20, r1
     8a0:	51 05       	cpc	r21, r1
     8a2:	49 f0       	breq	.+18     	; 0x8b6 <set_filter+0x2e>
     8a4:	90 91 81 50 	lds	r25, 0x5081
     8a8:	48 2f       	mov	r20, r24
     8aa:	42 95       	swap	r20
     8ac:	4f 70       	andi	r20, 0x0F	; 15
     8ae:	90 7f       	andi	r25, 0xF0	; 240
     8b0:	94 2b       	or	r25, r20
     8b2:	90 93 81 50 	sts	0x5081, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     8b6:	2a 70       	andi	r18, 0x0A	; 10
     8b8:	30 70       	andi	r19, 0x00	; 0
     8ba:	21 15       	cp	r18, r1
     8bc:	31 05       	cpc	r19, r1
     8be:	39 f0       	breq	.+14     	; 0x8ce <set_filter+0x46>
     8c0:	90 91 81 50 	lds	r25, 0x5081
     8c4:	80 7f       	andi	r24, 0xF0	; 240
     8c6:	9f 70       	andi	r25, 0x0F	; 15
     8c8:	89 2b       	or	r24, r25
     8ca:	80 93 81 50 	sts	0x5081, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     8ce:	84 e0       	ldi	r24, 0x04	; 4
     8d0:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     8d4:	80 91 81 50 	lds	r24, 0x5081
     8d8:	80 93 65 50 	sts	0x5065, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     8dc:	cc 23       	and	r28, r28
     8de:	19 f0       	breq	.+6      	; 0x8e6 <set_filter+0x5e>
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     8e6:	dd 23       	and	r29, r29
     8e8:	19 f0       	breq	.+6      	; 0x8f0 <set_filter+0x68>
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <upperMuxCS>

	SPICS(TRUE);
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     8f6:	8f ef       	ldi	r24, 0xFF	; 255
     8f8:	e0 ec       	ldi	r30, 0xC0	; 192
     8fa:	f8 e0       	ldi	r31, 0x08	; 8
     8fc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     8fe:	82 81       	ldd	r24, Z+2	; 0x02
     900:	88 23       	and	r24, r24
     902:	ec f7       	brge	.-6      	; 0x8fe <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     904:	e0 ec       	ldi	r30, 0xC0	; 192
     906:	f8 e0       	ldi	r31, 0x08	; 8
     908:	83 81       	ldd	r24, Z+3	; 0x03
     90a:	80 93 71 50 	sts	0x5071, r24

	nop();
     90e:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     910:	a1 e7       	ldi	r26, 0x71	; 113
     912:	b0 e5       	ldi	r27, 0x50	; 80
     914:	1c 97       	sbiw	r26, 0x0c	; 12
     916:	8c 91       	ld	r24, X
     918:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     91a:	82 81       	ldd	r24, Z+2	; 0x02
     91c:	88 23       	and	r24, r24
     91e:	ec f7       	brge	.-6      	; 0x91a <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     920:	e0 ec       	ldi	r30, 0xC0	; 192
     922:	f8 e0       	ldi	r31, 0x08	; 8
     924:	83 81       	ldd	r24, Z+3	; 0x03
     926:	80 93 71 50 	sts	0x5071, r24
	SPICS(FALSE);
     92a:	80 e0       	ldi	r24, 0x00	; 0
     92c:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     930:	cc 23       	and	r28, r28
     932:	19 f0       	breq	.+6      	; 0x93a <set_filter+0xb2>
     934:	80 e0       	ldi	r24, 0x00	; 0
     936:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     93a:	dd 23       	and	r29, r29
     93c:	19 f0       	breq	.+6      	; 0x944 <set_filter+0xbc>
     93e:	80 e0       	ldi	r24, 0x00	; 0
     940:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <upperMuxCS>
	SPIDisable();
     944:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
}
     948:	df 91       	pop	r29
     94a:	cf 91       	pop	r28
     94c:	08 95       	ret

0000094e <ADCPower>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void ADCPower(uint8_t on) {
     94e:	0f 93       	push	r16
     950:	1f 93       	push	r17
     952:	cf 93       	push	r28
     954:	df 93       	push	r29
	
	if (on) {
     956:	88 23       	and	r24, r24
     958:	09 f4       	brne	.+2      	; 0x95c <ADCPower+0xe>
     95a:	46 c0       	rjmp	.+140    	; 0x9e8 <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     95c:	00 e0       	ldi	r16, 0x00	; 0
     95e:	16 e0       	ldi	r17, 0x06	; 6
     960:	8e ed       	ldi	r24, 0xDE	; 222
     962:	d8 01       	movw	r26, r16
     964:	11 96       	adiw	r26, 0x01	; 1
     966:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     968:	c0 e2       	ldi	r28, 0x20	; 32
     96a:	d6 e0       	ldi	r29, 0x06	; 6
     96c:	4e e0       	ldi	r20, 0x0E	; 14
     96e:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     970:	e0 e4       	ldi	r30, 0x40	; 64
     972:	f6 e0       	ldi	r31, 0x06	; 6
     974:	63 e0       	ldi	r22, 0x03	; 3
     976:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     978:	80 e8       	ldi	r24, 0x80	; 128
     97a:	96 e0       	ldi	r25, 0x06	; 6
     97c:	50 e1       	ldi	r21, 0x10	; 16
     97e:	dc 01       	movw	r26, r24
     980:	11 96       	adiw	r26, 0x01	; 1
     982:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     984:	20 ea       	ldi	r18, 0xA0	; 160
     986:	36 e0       	ldi	r19, 0x06	; 6
     988:	d9 01       	movw	r26, r18
     98a:	11 96       	adiw	r26, 0x01	; 1
     98c:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     98e:	7e e9       	ldi	r23, 0x9E	; 158
     990:	d8 01       	movw	r26, r16
     992:	15 96       	adiw	r26, 0x05	; 5
     994:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     996:	78 e0       	ldi	r23, 0x08	; 8
     998:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     99a:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     99c:	ec 01       	movw	r28, r24
     99e:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     9a0:	d9 01       	movw	r26, r18
     9a2:	15 96       	adiw	r26, 0x05	; 5
     9a4:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     9a6:	10 92 81 50 	sts	0x5081, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9aa:	8f ef       	ldi	r24, 0xFF	; 255
     9ac:	93 ec       	ldi	r25, 0xC3	; 195
     9ae:	a9 e0       	ldi	r26, 0x09	; 9
     9b0:	81 50       	subi	r24, 0x01	; 1
     9b2:	90 40       	sbci	r25, 0x00	; 0
     9b4:	a0 40       	sbci	r26, 0x00	; 0
     9b6:	e1 f7       	brne	.-8      	; 0x9b0 <ADCPower+0x62>
     9b8:	00 c0       	rjmp	.+0      	; 0x9ba <ADCPower+0x6c>
     9ba:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     9bc:	80 e4       	ldi	r24, 0x40	; 64
     9be:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     9c0:	10 92 82 50 	sts	0x5082, r1
     9c4:	10 92 ce 50 	sts	0x50CE, r1
     9c8:	10 92 d6 23 	sts	0x23D6, r1
     9cc:	10 92 7a 50 	sts	0x507A, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     9d0:	8f ef       	ldi	r24, 0xFF	; 255
     9d2:	61 e0       	ldi	r22, 0x01	; 1
     9d4:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     9d8:	8f ef       	ldi	r24, 0xFF	; 255
     9da:	61 e0       	ldi	r22, 0x01	; 1
     9dc:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     9e0:	8f ef       	ldi	r24, 0xFF	; 255
     9e2:	0e 94 44 04 	call	0x888	; 0x888 <set_filter>
     9e6:	32 c0       	rjmp	.+100    	; 0xa4c <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     9e8:	00 e0       	ldi	r16, 0x00	; 0
     9ea:	16 e0       	ldi	r17, 0x06	; 6
     9ec:	7e ed       	ldi	r23, 0xDE	; 222
     9ee:	d8 01       	movw	r26, r16
     9f0:	16 96       	adiw	r26, 0x06	; 6
     9f2:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     9f4:	a0 e2       	ldi	r26, 0x20	; 32
     9f6:	b6 e0       	ldi	r27, 0x06	; 6
     9f8:	4e e0       	ldi	r20, 0x0E	; 14
     9fa:	16 96       	adiw	r26, 0x06	; 6
     9fc:	4c 93       	st	X, r20
     9fe:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     a00:	20 e4       	ldi	r18, 0x40	; 64
     a02:	36 e0       	ldi	r19, 0x06	; 6
     a04:	63 e0       	ldi	r22, 0x03	; 3
     a06:	e9 01       	movw	r28, r18
     a08:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     a0a:	c0 e8       	ldi	r28, 0x80	; 128
     a0c:	d6 e0       	ldi	r29, 0x06	; 6
     a0e:	50 e1       	ldi	r21, 0x10	; 16
     a10:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     a12:	80 ea       	ldi	r24, 0xA0	; 160
     a14:	96 e0       	ldi	r25, 0x06	; 6
     a16:	fc 01       	movw	r30, r24
     a18:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     a1a:	f8 01       	movw	r30, r16
     a1c:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     a1e:	12 96       	adiw	r26, 0x02	; 2
     a20:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     a22:	d9 01       	movw	r26, r18
     a24:	12 96       	adiw	r26, 0x02	; 2
     a26:	6c 93       	st	X, r22
     a28:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     a2a:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     a2c:	ec 01       	movw	r28, r24
     a2e:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     a30:	80 e4       	ldi	r24, 0x40	; 64
     a32:	12 96       	adiw	r26, 0x02	; 2
     a34:	8c 93       	st	X, r24
     a36:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     a38:	10 92 82 50 	sts	0x5082, r1
     a3c:	10 92 ce 50 	sts	0x50CE, r1
     a40:	10 92 d6 23 	sts	0x23D6, r1
     a44:	10 92 7a 50 	sts	0x507A, r1
		channelStatus = 0x00;
     a48:	10 92 81 50 	sts	0x5081, r1
		
	}
}
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	08 95       	ret

00000a56 <CO_collectBatt>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     a56:	4f 92       	push	r4
     a58:	5f 92       	push	r5
     a5a:	6f 92       	push	r6
     a5c:	7f 92       	push	r7
     a5e:	8f 92       	push	r8
     a60:	9f 92       	push	r9
     a62:	af 92       	push	r10
     a64:	bf 92       	push	r11
     a66:	ef 92       	push	r14
     a68:	ff 92       	push	r15
     a6a:	0f 93       	push	r16
     a6c:	1f 93       	push	r17
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	cd b7       	in	r28, 0x3d	; 61
     a74:	de b7       	in	r29, 0x3e	; 62
     a76:	2b 97       	sbiw	r28, 0x0b	; 11
     a78:	cd bf       	out	0x3d, r28	; 61
     a7a:	de bf       	out	0x3e, r29	; 62
     a7c:	8e 83       	std	Y+6, r24	; 0x06
     a7e:	9f 83       	std	Y+7, r25	; 0x07
     a80:	68 87       	std	Y+8, r22	; 0x08
     a82:	79 87       	std	Y+9, r23	; 0x09
     a84:	4a 87       	std	Y+10, r20	; 0x0a
     a86:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     a88:	81 e0       	ldi	r24, 0x01	; 1
     a8a:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     a8e:	84 e0       	ldi	r24, 0x04	; 4
     a90:	60 e0       	ldi	r22, 0x00	; 0
     a92:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     a96:	84 e0       	ldi	r24, 0x04	; 4
     a98:	60 e0       	ldi	r22, 0x00	; 0
     a9a:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
     a9e:	2f ef       	ldi	r18, 0xFF	; 255
     aa0:	33 ec       	ldi	r19, 0xC3	; 195
     aa2:	49 e0       	ldi	r20, 0x09	; 9
     aa4:	21 50       	subi	r18, 0x01	; 1
     aa6:	30 40       	sbci	r19, 0x00	; 0
     aa8:	40 40       	sbci	r20, 0x00	; 0
     aaa:	e1 f7       	brne	.-8      	; 0xaa4 <CO_collectBatt+0x4e>
     aac:	00 c0       	rjmp	.+0      	; 0xaae <CO_collectBatt+0x58>
     aae:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     ab0:	80 e4       	ldi	r24, 0x40	; 64
     ab2:	92 e0       	ldi	r25, 0x02	; 2
     ab4:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     ab8:	00 e4       	ldi	r16, 0x40	; 64
     aba:	12 e0       	ldi	r17, 0x02	; 2
     abc:	d8 01       	movw	r26, r16
     abe:	11 96       	adiw	r26, 0x01	; 1
     ac0:	8c 91       	ld	r24, X
     ac2:	11 97       	sbiw	r26, 0x01	; 1
     ac4:	89 7e       	andi	r24, 0xE9	; 233
     ac6:	11 96       	adiw	r26, 0x01	; 1
     ac8:	8c 93       	st	X, r24
     aca:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     acc:	14 96       	adiw	r26, 0x04	; 4
     ace:	8c 91       	ld	r24, X
     ad0:	14 97       	sbiw	r26, 0x04	; 4
     ad2:	88 7f       	andi	r24, 0xF8	; 248
     ad4:	83 60       	ori	r24, 0x03	; 3
     ad6:	14 96       	adiw	r26, 0x04	; 4
     ad8:	8c 93       	st	X, r24
     ada:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     adc:	12 96       	adiw	r26, 0x02	; 2
     ade:	8c 91       	ld	r24, X
     ae0:	12 97       	sbiw	r26, 0x02	; 2
     ae2:	8f 7c       	andi	r24, 0xCF	; 207
     ae4:	12 96       	adiw	r26, 0x02	; 2
     ae6:	8c 93       	st	X, r24
     ae8:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     aea:	0f 2e       	mov	r0, r31
     aec:	f0 e6       	ldi	r31, 0x60	; 96
     aee:	ef 2e       	mov	r14, r31
     af0:	f2 e0       	ldi	r31, 0x02	; 2
     af2:	ff 2e       	mov	r15, r31
     af4:	f0 2d       	mov	r31, r0
     af6:	f7 01       	movw	r30, r14
     af8:	80 81       	ld	r24, Z
     afa:	80 7e       	andi	r24, 0xE0	; 224
     afc:	81 60       	ori	r24, 0x01	; 1
     afe:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     b00:	89 e0       	ldi	r24, 0x09	; 9
     b02:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
     b04:	8c 91       	ld	r24, X
     b06:	81 60       	ori	r24, 0x01	; 1
     b08:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     b0a:	80 e4       	ldi	r24, 0x40	; 64
     b0c:	92 e0       	ldi	r25, 0x02	; 2
     b0e:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     b12:	80 e4       	ldi	r24, 0x40	; 64
     b14:	92 e0       	ldi	r25, 0x02	; 2
     b16:	60 e6       	ldi	r22, 0x60	; 96
     b18:	72 e0       	ldi	r23, 0x02	; 2
     b1a:	40 e0       	ldi	r20, 0x00	; 0
     b1c:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <ADC_Offset_Get_Unsigned>
     b20:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
     b22:	d8 01       	movw	r26, r16
     b24:	8c 91       	ld	r24, X
     b26:	8e 7f       	andi	r24, 0xFE	; 254
     b28:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     b2a:	f7 01       	movw	r30, r14
     b2c:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     b2e:	13 96       	adiw	r26, 0x03	; 3
     b30:	8c 91       	ld	r24, X
     b32:	13 97       	sbiw	r26, 0x03	; 3
     b34:	8f 73       	andi	r24, 0x3F	; 63
     b36:	13 96       	adiw	r26, 0x03	; 3
     b38:	8c 93       	st	X, r24
     b3a:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     b3c:	8c 91       	ld	r24, X
     b3e:	81 60       	ori	r24, 0x01	; 1
     b40:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     b42:	80 e4       	ldi	r24, 0x40	; 64
     b44:	92 e0       	ldi	r25, 0x02	; 2
     b46:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     b4a:	d8 01       	movw	r26, r16
     b4c:	11 96       	adiw	r26, 0x01	; 1
     b4e:	8c 91       	ld	r24, X
     b50:	11 97       	sbiw	r26, 0x01	; 1
     b52:	88 60       	ori	r24, 0x08	; 8
     b54:	11 96       	adiw	r26, 0x01	; 1
     b56:	8c 93       	st	X, r24
     b58:	ee 24       	eor	r14, r14
     b5a:	ff 24       	eor	r15, r15
     b5c:	68 94       	set
     b5e:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     b60:	44 24       	eor	r4, r4
     b62:	55 24       	eor	r5, r5
     b64:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     b66:	20 e0       	ldi	r18, 0x00	; 0
     b68:	30 e1       	ldi	r19, 0x10	; 16
     b6a:	40 e0       	ldi	r20, 0x00	; 0
     b6c:	50 e0       	ldi	r21, 0x00	; 0
     b6e:	2a 83       	std	Y+2, r18	; 0x02
     b70:	3b 83       	std	Y+3, r19	; 0x03
     b72:	4c 83       	std	Y+4, r20	; 0x04
     b74:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     b76:	88 24       	eor	r8, r8
     b78:	99 24       	eor	r9, r9
     b7a:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     b7c:	00 e6       	ldi	r16, 0x60	; 96
     b7e:	12 e0       	ldi	r17, 0x02	; 2
     b80:	d8 01       	movw	r26, r16
     b82:	13 96       	adiw	r26, 0x03	; 3
     b84:	8c 91       	ld	r24, X
     b86:	13 97       	sbiw	r26, 0x03	; 3
     b88:	80 ff       	sbrs	r24, 0
     b8a:	fa cf       	rjmp	.-12     	; 0xb80 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     b8c:	69 81       	ldd	r22, Y+1	; 0x01
     b8e:	c8 01       	movw	r24, r16
     b90:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
     b94:	a0 e0       	ldi	r26, 0x00	; 0
     b96:	b0 e0       	ldi	r27, 0x00	; 0
     b98:	88 0e       	add	r8, r24
     b9a:	99 1e       	adc	r9, r25
     b9c:	aa 1e       	adc	r10, r26
     b9e:	bb 1e       	adc	r11, r27
     ba0:	48 16       	cp	r4, r24
     ba2:	59 06       	cpc	r5, r25
     ba4:	6a 06       	cpc	r6, r26
     ba6:	7b 06       	cpc	r7, r27
     ba8:	10 f4       	brcc	.+4      	; 0xbae <CO_collectBatt+0x158>
     baa:	2c 01       	movw	r4, r24
     bac:	3d 01       	movw	r6, r26
     bae:	2a 81       	ldd	r18, Y+2	; 0x02
     bb0:	3b 81       	ldd	r19, Y+3	; 0x03
     bb2:	4c 81       	ldd	r20, Y+4	; 0x04
     bb4:	5d 81       	ldd	r21, Y+5	; 0x05
     bb6:	82 17       	cp	r24, r18
     bb8:	93 07       	cpc	r25, r19
     bba:	a4 07       	cpc	r26, r20
     bbc:	b5 07       	cpc	r27, r21
     bbe:	20 f4       	brcc	.+8      	; 0xbc8 <CO_collectBatt+0x172>
     bc0:	8a 83       	std	Y+2, r24	; 0x02
     bc2:	9b 83       	std	Y+3, r25	; 0x03
     bc4:	ac 83       	std	Y+4, r26	; 0x04
     bc6:	bd 83       	std	Y+5, r27	; 0x05
     bc8:	08 94       	sec
     bca:	e1 08       	sbc	r14, r1
     bcc:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     bce:	e1 14       	cp	r14, r1
     bd0:	f1 04       	cpc	r15, r1
     bd2:	b1 f6       	brne	.-84     	; 0xb80 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     bd4:	e0 e4       	ldi	r30, 0x40	; 64
     bd6:	f2 e0       	ldi	r31, 0x02	; 2
     bd8:	81 81       	ldd	r24, Z+1	; 0x01
     bda:	87 7f       	andi	r24, 0xF7	; 247
     bdc:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
     bde:	80 81       	ld	r24, Z
     be0:	8e 7f       	andi	r24, 0xFE	; 254
     be2:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     be4:	84 e0       	ldi	r24, 0x04	; 4
     be6:	60 e0       	ldi	r22, 0x00	; 0
     be8:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     bec:	80 e0       	ldi	r24, 0x00	; 0
     bee:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
     bf2:	c5 01       	movw	r24, r10
     bf4:	b4 01       	movw	r22, r8
     bf6:	05 2e       	mov	r0, r21
     bf8:	5a e0       	ldi	r21, 0x0A	; 10
     bfa:	96 95       	lsr	r25
     bfc:	87 95       	ror	r24
     bfe:	77 95       	ror	r23
     c00:	67 95       	ror	r22
     c02:	5a 95       	dec	r21
     c04:	d1 f7       	brne	.-12     	; 0xbfa <CO_collectBatt+0x1a4>
     c06:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     c08:	28 ee       	ldi	r18, 0xE8	; 232
     c0a:	33 e0       	ldi	r19, 0x03	; 3
     c0c:	40 e0       	ldi	r20, 0x00	; 0
     c0e:	50 e0       	ldi	r21, 0x00	; 0
     c10:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
     c14:	0f 2e       	mov	r0, r31
     c16:	ff ef       	ldi	r31, 0xFF	; 255
     c18:	8f 2e       	mov	r8, r31
     c1a:	ff e0       	ldi	r31, 0x0F	; 15
     c1c:	9f 2e       	mov	r9, r31
     c1e:	f0 e0       	ldi	r31, 0x00	; 0
     c20:	af 2e       	mov	r10, r31
     c22:	f0 e0       	ldi	r31, 0x00	; 0
     c24:	bf 2e       	mov	r11, r31
     c26:	f0 2d       	mov	r31, r0
     c28:	a5 01       	movw	r20, r10
     c2a:	94 01       	movw	r18, r8
     c2c:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     c30:	c9 01       	movw	r24, r18
     c32:	c2 97       	sbiw	r24, 0x32	; 50
     c34:	ae 81       	ldd	r26, Y+6	; 0x06
     c36:	bf 81       	ldd	r27, Y+7	; 0x07
     c38:	8d 93       	st	X+, r24
     c3a:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     c3c:	c3 01       	movw	r24, r6
     c3e:	b2 01       	movw	r22, r4
     c40:	28 ee       	ldi	r18, 0xE8	; 232
     c42:	33 e0       	ldi	r19, 0x03	; 3
     c44:	40 e0       	ldi	r20, 0x00	; 0
     c46:	50 e0       	ldi	r21, 0x00	; 0
     c48:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
     c4c:	a5 01       	movw	r20, r10
     c4e:	94 01       	movw	r18, r8
     c50:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     c54:	c9 01       	movw	r24, r18
     c56:	c2 97       	sbiw	r24, 0x32	; 50
     c58:	ea 85       	ldd	r30, Y+10	; 0x0a
     c5a:	fb 85       	ldd	r31, Y+11	; 0x0b
     c5c:	80 83       	st	Z, r24
     c5e:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     c60:	6a 81       	ldd	r22, Y+2	; 0x02
     c62:	7b 81       	ldd	r23, Y+3	; 0x03
     c64:	8c 81       	ldd	r24, Y+4	; 0x04
     c66:	9d 81       	ldd	r25, Y+5	; 0x05
     c68:	28 ee       	ldi	r18, 0xE8	; 232
     c6a:	33 e0       	ldi	r19, 0x03	; 3
     c6c:	40 e0       	ldi	r20, 0x00	; 0
     c6e:	50 e0       	ldi	r21, 0x00	; 0
     c70:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
     c74:	a5 01       	movw	r20, r10
     c76:	94 01       	movw	r18, r8
     c78:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     c7c:	22 53       	subi	r18, 0x32	; 50
     c7e:	30 40       	sbci	r19, 0x00	; 0
     c80:	a8 85       	ldd	r26, Y+8	; 0x08
     c82:	b9 85       	ldd	r27, Y+9	; 0x09
     c84:	2d 93       	st	X+, r18
     c86:	3c 93       	st	X, r19
     c88:	11 97       	sbiw	r26, 0x01	; 1
}
     c8a:	2b 96       	adiw	r28, 0x0b	; 11
     c8c:	cd bf       	out	0x3d, r28	; 61
     c8e:	de bf       	out	0x3e, r29	; 62
     c90:	df 91       	pop	r29
     c92:	cf 91       	pop	r28
     c94:	1f 91       	pop	r17
     c96:	0f 91       	pop	r16
     c98:	ff 90       	pop	r15
     c9a:	ef 90       	pop	r14
     c9c:	bf 90       	pop	r11
     c9e:	af 90       	pop	r10
     ca0:	9f 90       	pop	r9
     ca2:	8f 90       	pop	r8
     ca4:	7f 90       	pop	r7
     ca6:	6f 90       	pop	r6
     ca8:	5f 90       	pop	r5
     caa:	4f 90       	pop	r4
     cac:	08 95       	ret

00000cae <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     cae:	4f 92       	push	r4
     cb0:	5f 92       	push	r5
     cb2:	6f 92       	push	r6
     cb4:	7f 92       	push	r7
     cb6:	8f 92       	push	r8
     cb8:	9f 92       	push	r9
     cba:	af 92       	push	r10
     cbc:	bf 92       	push	r11
     cbe:	ef 92       	push	r14
     cc0:	ff 92       	push	r15
     cc2:	0f 93       	push	r16
     cc4:	1f 93       	push	r17
     cc6:	cf 93       	push	r28
     cc8:	df 93       	push	r29
     cca:	cd b7       	in	r28, 0x3d	; 61
     ccc:	de b7       	in	r29, 0x3e	; 62
     cce:	2b 97       	sbiw	r28, 0x0b	; 11
     cd0:	cd bf       	out	0x3d, r28	; 61
     cd2:	de bf       	out	0x3e, r29	; 62
     cd4:	8e 83       	std	Y+6, r24	; 0x06
     cd6:	9f 83       	std	Y+7, r25	; 0x07
     cd8:	68 87       	std	Y+8, r22	; 0x08
     cda:	79 87       	std	Y+9, r23	; 0x09
     cdc:	4a 87       	std	Y+10, r20	; 0x0a
     cde:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     ce0:	81 e0       	ldi	r24, 0x01	; 1
     ce2:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     ce6:	80 e0       	ldi	r24, 0x00	; 0
     ce8:	92 e0       	ldi	r25, 0x02	; 2
     cea:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     cee:	00 e0       	ldi	r16, 0x00	; 0
     cf0:	12 e0       	ldi	r17, 0x02	; 2
     cf2:	d8 01       	movw	r26, r16
     cf4:	11 96       	adiw	r26, 0x01	; 1
     cf6:	8c 91       	ld	r24, X
     cf8:	11 97       	sbiw	r26, 0x01	; 1
     cfa:	89 7e       	andi	r24, 0xE9	; 233
     cfc:	11 96       	adiw	r26, 0x01	; 1
     cfe:	8c 93       	st	X, r24
     d00:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     d02:	14 96       	adiw	r26, 0x04	; 4
     d04:	8c 91       	ld	r24, X
     d06:	14 97       	sbiw	r26, 0x04	; 4
     d08:	88 7f       	andi	r24, 0xF8	; 248
     d0a:	83 60       	ori	r24, 0x03	; 3
     d0c:	14 96       	adiw	r26, 0x04	; 4
     d0e:	8c 93       	st	X, r24
     d10:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     d12:	12 96       	adiw	r26, 0x02	; 2
     d14:	8c 91       	ld	r24, X
     d16:	12 97       	sbiw	r26, 0x02	; 2
     d18:	8f 7c       	andi	r24, 0xCF	; 207
     d1a:	12 96       	adiw	r26, 0x02	; 2
     d1c:	8c 93       	st	X, r24
     d1e:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     d20:	0f 2e       	mov	r0, r31
     d22:	f0 e2       	ldi	r31, 0x20	; 32
     d24:	ef 2e       	mov	r14, r31
     d26:	f2 e0       	ldi	r31, 0x02	; 2
     d28:	ff 2e       	mov	r15, r31
     d2a:	f0 2d       	mov	r31, r0
     d2c:	f7 01       	movw	r30, r14
     d2e:	80 81       	ld	r24, Z
     d30:	80 7e       	andi	r24, 0xE0	; 224
     d32:	81 60       	ori	r24, 0x01	; 1
     d34:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     d36:	89 e0       	ldi	r24, 0x09	; 9
     d38:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     d3a:	8c 91       	ld	r24, X
     d3c:	81 60       	ori	r24, 0x01	; 1
     d3e:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     d40:	80 e0       	ldi	r24, 0x00	; 0
     d42:	92 e0       	ldi	r25, 0x02	; 2
     d44:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     d48:	80 e0       	ldi	r24, 0x00	; 0
     d4a:	92 e0       	ldi	r25, 0x02	; 2
     d4c:	60 e2       	ldi	r22, 0x20	; 32
     d4e:	72 e0       	ldi	r23, 0x02	; 2
     d50:	40 e0       	ldi	r20, 0x00	; 0
     d52:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <ADC_Offset_Get_Unsigned>
     d56:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     d58:	d8 01       	movw	r26, r16
     d5a:	8c 91       	ld	r24, X
     d5c:	8e 7f       	andi	r24, 0xFE	; 254
     d5e:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     d60:	f7 01       	movw	r30, r14
     d62:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     d64:	13 96       	adiw	r26, 0x03	; 3
     d66:	8c 91       	ld	r24, X
     d68:	13 97       	sbiw	r26, 0x03	; 3
     d6a:	8f 73       	andi	r24, 0x3F	; 63
     d6c:	13 96       	adiw	r26, 0x03	; 3
     d6e:	8c 93       	st	X, r24
     d70:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     d72:	8c 91       	ld	r24, X
     d74:	81 60       	ori	r24, 0x01	; 1
     d76:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	92 e0       	ldi	r25, 0x02	; 2
     d7c:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     d80:	d8 01       	movw	r26, r16
     d82:	11 96       	adiw	r26, 0x01	; 1
     d84:	8c 91       	ld	r24, X
     d86:	11 97       	sbiw	r26, 0x01	; 1
     d88:	88 60       	ori	r24, 0x08	; 8
     d8a:	11 96       	adiw	r26, 0x01	; 1
     d8c:	8c 93       	st	X, r24
     d8e:	ee 24       	eor	r14, r14
     d90:	ff 24       	eor	r15, r15
     d92:	68 94       	set
     d94:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     d96:	44 24       	eor	r4, r4
     d98:	55 24       	eor	r5, r5
     d9a:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	30 e1       	ldi	r19, 0x10	; 16
     da0:	40 e0       	ldi	r20, 0x00	; 0
     da2:	50 e0       	ldi	r21, 0x00	; 0
     da4:	2a 83       	std	Y+2, r18	; 0x02
     da6:	3b 83       	std	Y+3, r19	; 0x03
     da8:	4c 83       	std	Y+4, r20	; 0x04
     daa:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     dac:	88 24       	eor	r8, r8
     dae:	99 24       	eor	r9, r9
     db0:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     db2:	00 e2       	ldi	r16, 0x20	; 32
     db4:	12 e0       	ldi	r17, 0x02	; 2
     db6:	d8 01       	movw	r26, r16
     db8:	13 96       	adiw	r26, 0x03	; 3
     dba:	8c 91       	ld	r24, X
     dbc:	13 97       	sbiw	r26, 0x03	; 3
     dbe:	80 ff       	sbrs	r24, 0
     dc0:	fa cf       	rjmp	.-12     	; 0xdb6 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     dc2:	69 81       	ldd	r22, Y+1	; 0x01
     dc4:	c8 01       	movw	r24, r16
     dc6:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
     dca:	a0 e0       	ldi	r26, 0x00	; 0
     dcc:	b0 e0       	ldi	r27, 0x00	; 0
     dce:	88 0e       	add	r8, r24
     dd0:	99 1e       	adc	r9, r25
     dd2:	aa 1e       	adc	r10, r26
     dd4:	bb 1e       	adc	r11, r27
     dd6:	48 16       	cp	r4, r24
     dd8:	59 06       	cpc	r5, r25
     dda:	6a 06       	cpc	r6, r26
     ddc:	7b 06       	cpc	r7, r27
     dde:	10 f4       	brcc	.+4      	; 0xde4 <CO_collectTemp+0x136>
     de0:	2c 01       	movw	r4, r24
     de2:	3d 01       	movw	r6, r26
     de4:	2a 81       	ldd	r18, Y+2	; 0x02
     de6:	3b 81       	ldd	r19, Y+3	; 0x03
     de8:	4c 81       	ldd	r20, Y+4	; 0x04
     dea:	5d 81       	ldd	r21, Y+5	; 0x05
     dec:	82 17       	cp	r24, r18
     dee:	93 07       	cpc	r25, r19
     df0:	a4 07       	cpc	r26, r20
     df2:	b5 07       	cpc	r27, r21
     df4:	20 f4       	brcc	.+8      	; 0xdfe <CO_collectTemp+0x150>
     df6:	8a 83       	std	Y+2, r24	; 0x02
     df8:	9b 83       	std	Y+3, r25	; 0x03
     dfa:	ac 83       	std	Y+4, r26	; 0x04
     dfc:	bd 83       	std	Y+5, r27	; 0x05
     dfe:	08 94       	sec
     e00:	e1 08       	sbc	r14, r1
     e02:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     e04:	e1 14       	cp	r14, r1
     e06:	f1 04       	cpc	r15, r1
     e08:	b1 f6       	brne	.-84     	; 0xdb6 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     e0a:	e0 e0       	ldi	r30, 0x00	; 0
     e0c:	f2 e0       	ldi	r31, 0x02	; 2
     e0e:	81 81       	ldd	r24, Z+1	; 0x01
     e10:	87 7f       	andi	r24, 0xF7	; 247
     e12:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     e14:	80 81       	ld	r24, Z
     e16:	82 60       	ori	r24, 0x02	; 2
     e18:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
     e1a:	80 81       	ld	r24, Z
     e1c:	8e 7f       	andi	r24, 0xFE	; 254
     e1e:	80 83       	st	Z, r24

	ADCPower(FALSE);
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>

	average = sum / NUM_SAMPLES;
     e26:	c5 01       	movw	r24, r10
     e28:	b4 01       	movw	r22, r8
     e2a:	05 2e       	mov	r0, r21
     e2c:	5a e0       	ldi	r21, 0x0A	; 10
     e2e:	96 95       	lsr	r25
     e30:	87 95       	ror	r24
     e32:	77 95       	ror	r23
     e34:	67 95       	ror	r22
     e36:	5a 95       	dec	r21
     e38:	d1 f7       	brne	.-12     	; 0xe2e <CO_collectTemp+0x180>
     e3a:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     e3c:	28 ee       	ldi	r18, 0xE8	; 232
     e3e:	33 e0       	ldi	r19, 0x03	; 3
     e40:	40 e0       	ldi	r20, 0x00	; 0
     e42:	50 e0       	ldi	r21, 0x00	; 0
     e44:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
     e48:	0f 2e       	mov	r0, r31
     e4a:	ff ef       	ldi	r31, 0xFF	; 255
     e4c:	8f 2e       	mov	r8, r31
     e4e:	ff e0       	ldi	r31, 0x0F	; 15
     e50:	9f 2e       	mov	r9, r31
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	af 2e       	mov	r10, r31
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	bf 2e       	mov	r11, r31
     e5a:	f0 2d       	mov	r31, r0
     e5c:	a5 01       	movw	r20, r10
     e5e:	94 01       	movw	r18, r8
     e60:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     e64:	c9 01       	movw	r24, r18
     e66:	c2 97       	sbiw	r24, 0x32	; 50
     e68:	ae 81       	ldd	r26, Y+6	; 0x06
     e6a:	bf 81       	ldd	r27, Y+7	; 0x07
     e6c:	8d 93       	st	X+, r24
     e6e:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     e70:	c3 01       	movw	r24, r6
     e72:	b2 01       	movw	r22, r4
     e74:	28 ee       	ldi	r18, 0xE8	; 232
     e76:	33 e0       	ldi	r19, 0x03	; 3
     e78:	40 e0       	ldi	r20, 0x00	; 0
     e7a:	50 e0       	ldi	r21, 0x00	; 0
     e7c:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
     e80:	a5 01       	movw	r20, r10
     e82:	94 01       	movw	r18, r8
     e84:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     e88:	c9 01       	movw	r24, r18
     e8a:	c2 97       	sbiw	r24, 0x32	; 50
     e8c:	ea 85       	ldd	r30, Y+10	; 0x0a
     e8e:	fb 85       	ldd	r31, Y+11	; 0x0b
     e90:	80 83       	st	Z, r24
     e92:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     e94:	6a 81       	ldd	r22, Y+2	; 0x02
     e96:	7b 81       	ldd	r23, Y+3	; 0x03
     e98:	8c 81       	ldd	r24, Y+4	; 0x04
     e9a:	9d 81       	ldd	r25, Y+5	; 0x05
     e9c:	28 ee       	ldi	r18, 0xE8	; 232
     e9e:	33 e0       	ldi	r19, 0x03	; 3
     ea0:	40 e0       	ldi	r20, 0x00	; 0
     ea2:	50 e0       	ldi	r21, 0x00	; 0
     ea4:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
     ea8:	a5 01       	movw	r20, r10
     eaa:	94 01       	movw	r18, r8
     eac:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
     eb0:	22 53       	subi	r18, 0x32	; 50
     eb2:	30 40       	sbci	r19, 0x00	; 0
     eb4:	a8 85       	ldd	r26, Y+8	; 0x08
     eb6:	b9 85       	ldd	r27, Y+9	; 0x09
     eb8:	2d 93       	st	X+, r18
     eba:	3c 93       	st	X, r19
     ebc:	11 97       	sbiw	r26, 0x01	; 1
}
     ebe:	2b 96       	adiw	r28, 0x0b	; 11
     ec0:	cd bf       	out	0x3d, r28	; 61
     ec2:	de bf       	out	0x3e, r29	; 62
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	1f 91       	pop	r17
     eca:	0f 91       	pop	r16
     ecc:	ff 90       	pop	r15
     ece:	ef 90       	pop	r14
     ed0:	bf 90       	pop	r11
     ed2:	af 90       	pop	r10
     ed4:	9f 90       	pop	r9
     ed6:	8f 90       	pop	r8
     ed8:	7f 90       	pop	r7
     eda:	6f 90       	pop	r6
     edc:	5f 90       	pop	r5
     ede:	4f 90       	pop	r4
     ee0:	08 95       	ret

00000ee2 <enableADCMUX>:
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	
	if(on) {
     ee2:	88 23       	and	r24, r24
     ee4:	31 f0       	breq	.+12     	; 0xef2 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
     ee6:	e0 e0       	ldi	r30, 0x00	; 0
     ee8:	f6 e0       	ldi	r31, 0x06	; 6
     eea:	80 e2       	ldi	r24, 0x20	; 32
     eec:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
     eee:	85 83       	std	Z+5, r24	; 0x05
     ef0:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
     ef2:	e0 e0       	ldi	r30, 0x00	; 0
     ef4:	f6 e0       	ldi	r31, 0x06	; 6
     ef6:	80 e2       	ldi	r24, 0x20	; 32
     ef8:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     efa:	82 83       	std	Z+2, r24	; 0x02
     efc:	08 95       	ret

00000efe <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
     efe:	1f 92       	push	r1
     f00:	0f 92       	push	r0
     f02:	0f b6       	in	r0, 0x3f	; 63
     f04:	0f 92       	push	r0
     f06:	0b b6       	in	r0, 0x3b	; 59
     f08:	0f 92       	push	r0
     f0a:	11 24       	eor	r1, r1
     f0c:	2f 93       	push	r18
     f0e:	3f 93       	push	r19
     f10:	4f 93       	push	r20
     f12:	5f 93       	push	r21
     f14:	6f 93       	push	r22
     f16:	7f 93       	push	r23
     f18:	8f 93       	push	r24
     f1a:	9f 93       	push	r25
     f1c:	af 93       	push	r26
     f1e:	bf 93       	push	r27
     f20:	ef 93       	push	r30
     f22:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f24:	e0 e4       	ldi	r30, 0x40	; 64
     f26:	fa e0       	ldi	r31, 0x0A	; 10
     f28:	80 81       	ld	r24, Z
     f2a:	80 7f       	andi	r24, 0xF0	; 240
     f2c:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f2e:	a0 e0       	ldi	r26, 0x00	; 0
     f30:	b8 e0       	ldi	r27, 0x08	; 8
     f32:	8c 91       	ld	r24, X
     f34:	80 7f       	andi	r24, 0xF0	; 240
     f36:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f38:	a0 e0       	ldi	r26, 0x00	; 0
     f3a:	b9 e0       	ldi	r27, 0x09	; 9
     f3c:	8c 91       	ld	r24, X
     f3e:	80 7f       	andi	r24, 0xF0	; 240
     f40:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f42:	80 81       	ld	r24, Z
     f44:	80 7f       	andi	r24, 0xF0	; 240
     f46:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     f4a:	80 e0       	ldi	r24, 0x00	; 0
     f4c:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
     f50:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	enableADCMUX(FALSE);
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	0e 94 71 07 	call	0xee2	; 0xee2 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
     f5a:	81 e0       	ldi	r24, 0x01	; 1
     f5c:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     f60:	80 93 d5 21 	sts	0x21D5, r24
}
     f64:	ff 91       	pop	r31
     f66:	ef 91       	pop	r30
     f68:	bf 91       	pop	r27
     f6a:	af 91       	pop	r26
     f6c:	9f 91       	pop	r25
     f6e:	8f 91       	pop	r24
     f70:	7f 91       	pop	r23
     f72:	6f 91       	pop	r22
     f74:	5f 91       	pop	r21
     f76:	4f 91       	pop	r20
     f78:	3f 91       	pop	r19
     f7a:	2f 91       	pop	r18
     f7c:	0f 90       	pop	r0
     f7e:	0b be       	out	0x3b, r0	; 59
     f80:	0f 90       	pop	r0
     f82:	0f be       	out	0x3f, r0	; 63
     f84:	0f 90       	pop	r0
     f86:	1f 90       	pop	r1
     f88:	18 95       	reti

00000f8a <ADC_Stop_Sampling>:
//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f8a:	e0 e4       	ldi	r30, 0x40	; 64
     f8c:	fa e0       	ldi	r31, 0x0A	; 10
     f8e:	80 81       	ld	r24, Z
     f90:	80 7f       	andi	r24, 0xF0	; 240
     f92:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f94:	a0 e0       	ldi	r26, 0x00	; 0
     f96:	b8 e0       	ldi	r27, 0x08	; 8
     f98:	8c 91       	ld	r24, X
     f9a:	80 7f       	andi	r24, 0xF0	; 240
     f9c:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f9e:	a0 e0       	ldi	r26, 0x00	; 0
     fa0:	b9 e0       	ldi	r27, 0x09	; 9
     fa2:	8c 91       	ld	r24, X
     fa4:	80 7f       	andi	r24, 0xF0	; 240
     fa6:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     fa8:	80 81       	ld	r24, Z
     faa:	80 7f       	andi	r24, 0xF0	; 240
     fac:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     fb0:	80 e0       	ldi	r24, 0x00	; 0
     fb2:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
     fb6:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	enableADCMUX(FALSE);
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	0e 94 71 07 	call	0xee2	; 0xee2 <enableADCMUX>
	ADC_Sampling_Finished = 1;
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     fc6:	80 93 d5 21 	sts	0x21D5, r24
}
     fca:	08 95       	ret

00000fcc <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
     fcc:	cf 93       	push	r28
     fce:	df 93       	push	r29
     fd0:	0f 92       	push	r0
     fd2:	0f 92       	push	r0
     fd4:	cd b7       	in	r28, 0x3d	; 61
     fd6:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
     fd8:	80 91 cd 50 	lds	r24, 0x50CD
     fdc:	88 23       	and	r24, r24
     fde:	89 f0       	breq	.+34     	; 0x1002 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
     fe0:	e0 e4       	ldi	r30, 0x40	; 64
     fe2:	f8 e0       	ldi	r31, 0x08	; 8
     fe4:	80 a1       	lds	r24, 0x40
     fe6:	91 a1       	lds	r25, 0x41
     fe8:	89 83       	std	Y+1, r24	; 0x01
     fea:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
     fec:	89 81       	ldd	r24, Y+1	; 0x01
     fee:	9a 81       	ldd	r25, Y+2	; 0x02
     ff0:	00 97       	sbiw	r24, 0x00	; 0
     ff2:	21 f4       	brne	.+8      	; 0xffc <ADC_Get_Num_Samples+0x30>
     ff4:	86 a1       	lds	r24, 0x46
     ff6:	97 a1       	lds	r25, 0x47
     ff8:	89 83       	std	Y+1, r24	; 0x01
     ffa:	9a 83       	std	Y+2, r25	; 0x02
		return count;
     ffc:	89 81       	ldd	r24, Y+1	; 0x01
     ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    1000:	02 c0       	rjmp	.+4      	; 0x1006 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    1002:	80 e0       	ldi	r24, 0x00	; 0
    1004:	90 e0       	ldi	r25, 0x00	; 0
}
    1006:	0f 90       	pop	r0
    1008:	0f 90       	pop	r0
    100a:	df 91       	pop	r29
    100c:	cf 91       	pop	r28
    100e:	08 95       	ret

00001010 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1010:	e0 ea       	ldi	r30, 0xA0	; 160
    1012:	f6 e0       	ldi	r31, 0x06	; 6
    1014:	13 86       	std	Z+11, r1	; 0x0b
}
    1016:	08 95       	ret

00001018 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	e0 ea       	ldi	r30, 0xA0	; 160
    101c:	f6 e0       	ldi	r31, 0x06	; 6
    101e:	83 87       	std	Z+11, r24	; 0x0b
}	
    1020:	08 95       	ret

00001022 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    1022:	1f 92       	push	r1
    1024:	0f 92       	push	r0
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	0f 92       	push	r0
    102a:	0b b6       	in	r0, 0x3b	; 59
    102c:	0f 92       	push	r0
    102e:	11 24       	eor	r1, r1
    1030:	6f 92       	push	r6
    1032:	7f 92       	push	r7
    1034:	8f 92       	push	r8
    1036:	9f 92       	push	r9
    1038:	af 92       	push	r10
    103a:	bf 92       	push	r11
    103c:	cf 92       	push	r12
    103e:	df 92       	push	r13
    1040:	ef 92       	push	r14
    1042:	ff 92       	push	r15
    1044:	0f 93       	push	r16
    1046:	1f 93       	push	r17
    1048:	2f 93       	push	r18
    104a:	3f 93       	push	r19
    104c:	4f 93       	push	r20
    104e:	5f 93       	push	r21
    1050:	6f 93       	push	r22
    1052:	7f 93       	push	r23
    1054:	8f 93       	push	r24
    1056:	9f 93       	push	r25
    1058:	af 93       	push	r26
    105a:	bf 93       	push	r27
    105c:	ef 93       	push	r30
    105e:	ff 93       	push	r31
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	cd b7       	in	r28, 0x3d	; 61
    1066:	de b7       	in	r29, 0x3e	; 62
    1068:	2c 97       	sbiw	r28, 0x0c	; 12
    106a:	cd bf       	out	0x3d, r28	; 61
    106c:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    106e:	80 91 5d 40 	lds	r24, 0x405D
    1072:	88 23       	and	r24, r24
    1074:	8c f0       	brlt	.+34     	; 0x1098 <__vector_104+0x76>
		discardCount++;
    1076:	80 91 5d 40 	lds	r24, 0x405D
    107a:	8f 5f       	subi	r24, 0xFF	; 255
    107c:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
    1080:	80 91 5d 40 	lds	r24, 0x405D
    1084:	80 38       	cpi	r24, 0x80	; 128
    1086:	09 f0       	breq	.+2      	; 0x108a <__vector_104+0x68>
    1088:	b4 c0       	rjmp	.+360    	; 0x11f2 <__vector_104+0x1d0>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    108a:	e0 e4       	ldi	r30, 0x40	; 64
    108c:	f8 e0       	ldi	r31, 0x08	; 8
    108e:	80 81       	ld	r24, Z
    1090:	80 7f       	andi	r24, 0xF0	; 240
    1092:	89 60       	ori	r24, 0x09	; 9
    1094:	80 83       	st	Z, r24
    1096:	ad c0       	rjmp	.+346    	; 0x11f2 <__vector_104+0x1d0>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    109e:	82 e0       	ldi	r24, 0x02	; 2
    10a0:	e0 ea       	ldi	r30, 0xA0	; 160
    10a2:	f6 e0       	ldi	r31, 0x06	; 6
    10a4:	86 83       	std	Z+6, r24	; 0x06
    10a6:	80 e0       	ldi	r24, 0x00	; 0
    10a8:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    10aa:	e0 ec       	ldi	r30, 0xC0	; 192
    10ac:	f8 e0       	ldi	r31, 0x08	; 8
    10ae:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    10b0:	25 e6       	ldi	r18, 0x65	; 101
    10b2:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    10b4:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    10b6:	42 81       	ldd	r20, Z+2	; 0x02
    10b8:	44 23       	and	r20, r20
    10ba:	ec f7       	brge	.-6      	; 0x10b6 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    10bc:	43 81       	ldd	r20, Z+3	; 0x03
    10be:	d9 01       	movw	r26, r18
    10c0:	a8 0f       	add	r26, r24
    10c2:	b9 1f       	adc	r27, r25
    10c4:	4c 93       	st	X, r20
    10c6:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    10c8:	83 30       	cpi	r24, 0x03	; 3
    10ca:	91 05       	cpc	r25, r1
    10cc:	99 f7       	brne	.-26     	; 0x10b4 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    10ce:	82 e0       	ldi	r24, 0x02	; 2
    10d0:	e0 ea       	ldi	r30, 0xA0	; 160
    10d2:	f6 e0       	ldi	r31, 0x06	; 6
    10d4:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    10d6:	80 e0       	ldi	r24, 0x00	; 0
    10d8:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    10dc:	80 91 65 50 	lds	r24, 0x5065
    10e0:	88 23       	and	r24, r24
    10e2:	1c f4       	brge	.+6      	; 0x10ea <__vector_104+0xc8>
    10e4:	8f ef       	ldi	r24, 0xFF	; 255
    10e6:	8c 83       	std	Y+4, r24	; 0x04
    10e8:	01 c0       	rjmp	.+2      	; 0x10ec <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    10ea:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    10ec:	80 91 65 50 	lds	r24, 0x5065
    10f0:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    10f2:	80 91 66 50 	lds	r24, 0x5066
    10f6:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    10f8:	80 91 67 50 	lds	r24, 0x5067
    10fc:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    10fe:	89 81       	ldd	r24, Y+1	; 0x01
    1100:	9a 81       	ldd	r25, Y+2	; 0x02
    1102:	ab 81       	ldd	r26, Y+3	; 0x03
    1104:	bc 81       	ldd	r27, Y+4	; 0x04
    1106:	ac 01       	movw	r20, r24
    1108:	bd 01       	movw	r22, r26
    110a:	77 0f       	add	r23, r23
    110c:	44 0b       	sbc	r20, r20
    110e:	54 2f       	mov	r21, r20
    1110:	ba 01       	movw	r22, r20
    1112:	8d 83       	std	Y+5, r24	; 0x05
    1114:	9e 83       	std	Y+6, r25	; 0x06
    1116:	af 83       	std	Y+7, r26	; 0x07
    1118:	b8 87       	std	Y+8, r27	; 0x08
    111a:	49 87       	std	Y+9, r20	; 0x09
    111c:	4a 87       	std	Y+10, r20	; 0x0a
    111e:	4b 87       	std	Y+11, r20	; 0x0b
    1120:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1122:	80 90 74 50 	lds	r8, 0x5074
    1126:	90 90 75 50 	lds	r9, 0x5075
    112a:	a0 90 76 50 	lds	r10, 0x5076
    112e:	b0 90 77 50 	lds	r11, 0x5077
    1132:	2d 81       	ldd	r18, Y+5	; 0x05
    1134:	3e 81       	ldd	r19, Y+6	; 0x06
    1136:	4f 81       	ldd	r20, Y+7	; 0x07
    1138:	58 85       	ldd	r21, Y+8	; 0x08
    113a:	69 85       	ldd	r22, Y+9	; 0x09
    113c:	7a 85       	ldd	r23, Y+10	; 0x0a
    113e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1140:	9c 85       	ldd	r25, Y+12	; 0x0c
    1142:	f4 01       	movw	r30, r8
    1144:	ee 0f       	add	r30, r30
    1146:	ff 1f       	adc	r31, r31
    1148:	ee 0f       	add	r30, r30
    114a:	ff 1f       	adc	r31, r31
    114c:	60 90 72 50 	lds	r6, 0x5072
    1150:	70 90 73 50 	lds	r7, 0x5073
    1154:	6e 0e       	add	r6, r30
    1156:	7f 1e       	adc	r7, r31
    1158:	0f 2e       	mov	r0, r31
    115a:	f0 ea       	ldi	r31, 0xA0	; 160
    115c:	af 2e       	mov	r10, r31
    115e:	f0 2d       	mov	r31, r0
    1160:	0f 2e       	mov	r0, r31
    1162:	f5 e2       	ldi	r31, 0x25	; 37
    1164:	bf 2e       	mov	r11, r31
    1166:	f0 2d       	mov	r31, r0
    1168:	0f 2e       	mov	r0, r31
    116a:	f6 e2       	ldi	r31, 0x26	; 38
    116c:	cf 2e       	mov	r12, r31
    116e:	f0 2d       	mov	r31, r0
    1170:	dd 24       	eor	r13, r13
    1172:	ee 24       	eor	r14, r14
    1174:	ff 24       	eor	r15, r15
    1176:	00 e0       	ldi	r16, 0x00	; 0
    1178:	10 e0       	ldi	r17, 0x00	; 0
    117a:	0e 94 a0 2f 	call	0x5f40	; 0x5f40 <__muldi3>
    117e:	aa 24       	eor	r10, r10
    1180:	aa 94       	dec	r10
    1182:	bb 24       	eor	r11, r11
    1184:	ba 94       	dec	r11
    1186:	0f 2e       	mov	r0, r31
    1188:	ff e7       	ldi	r31, 0x7F	; 127
    118a:	cf 2e       	mov	r12, r31
    118c:	f0 2d       	mov	r31, r0
    118e:	0e 94 4f 31 	call	0x629e	; 0x629e <__divdi3>
    1192:	01 e0       	ldi	r16, 0x01	; 1
    1194:	0e 94 73 30 	call	0x60e6	; 0x60e6 <__ashldi3>
    1198:	0f 2e       	mov	r0, r31
    119a:	f3 e0       	ldi	r31, 0x03	; 3
    119c:	af 2e       	mov	r10, r31
    119e:	f0 2d       	mov	r31, r0
    11a0:	bb 24       	eor	r11, r11
    11a2:	cc 24       	eor	r12, r12
    11a4:	00 e0       	ldi	r16, 0x00	; 0
    11a6:	0e 94 4f 31 	call	0x629e	; 0x629e <__divdi3>
    11aa:	82 2e       	mov	r8, r18
    11ac:	93 2e       	mov	r9, r19
    11ae:	a4 2e       	mov	r10, r20
    11b0:	b5 2e       	mov	r11, r21
    11b2:	b0 94       	com	r11
    11b4:	a0 94       	com	r10
    11b6:	90 94       	com	r9
    11b8:	80 94       	com	r8
    11ba:	81 1c       	adc	r8, r1
    11bc:	91 1c       	adc	r9, r1
    11be:	a1 1c       	adc	r10, r1
    11c0:	b1 1c       	adc	r11, r1
    11c2:	f3 01       	movw	r30, r6
    11c4:	80 82       	st	Z, r8
    11c6:	91 82       	std	Z+1, r9	; 0x01
    11c8:	a2 82       	std	Z+2, r10	; 0x02
    11ca:	b3 82       	std	Z+3, r11	; 0x03
		sampleCount++;
    11cc:	80 91 74 50 	lds	r24, 0x5074
    11d0:	90 91 75 50 	lds	r25, 0x5075
    11d4:	a0 91 76 50 	lds	r26, 0x5076
    11d8:	b0 91 77 50 	lds	r27, 0x5077
    11dc:	01 96       	adiw	r24, 0x01	; 1
    11de:	a1 1d       	adc	r26, r1
    11e0:	b1 1d       	adc	r27, r1
    11e2:	80 93 74 50 	sts	0x5074, r24
    11e6:	90 93 75 50 	sts	0x5075, r25
    11ea:	a0 93 76 50 	sts	0x5076, r26
    11ee:	b0 93 77 50 	sts	0x5077, r27
	}
}
    11f2:	2c 96       	adiw	r28, 0x0c	; 12
    11f4:	cd bf       	out	0x3d, r28	; 61
    11f6:	de bf       	out	0x3e, r29	; 62
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	ff 91       	pop	r31
    11fe:	ef 91       	pop	r30
    1200:	bf 91       	pop	r27
    1202:	af 91       	pop	r26
    1204:	9f 91       	pop	r25
    1206:	8f 91       	pop	r24
    1208:	7f 91       	pop	r23
    120a:	6f 91       	pop	r22
    120c:	5f 91       	pop	r21
    120e:	4f 91       	pop	r20
    1210:	3f 91       	pop	r19
    1212:	2f 91       	pop	r18
    1214:	1f 91       	pop	r17
    1216:	0f 91       	pop	r16
    1218:	ff 90       	pop	r15
    121a:	ef 90       	pop	r14
    121c:	df 90       	pop	r13
    121e:	cf 90       	pop	r12
    1220:	bf 90       	pop	r11
    1222:	af 90       	pop	r10
    1224:	9f 90       	pop	r9
    1226:	8f 90       	pop	r8
    1228:	7f 90       	pop	r7
    122a:	6f 90       	pop	r6
    122c:	0f 90       	pop	r0
    122e:	0b be       	out	0x3b, r0	; 59
    1230:	0f 90       	pop	r0
    1232:	0f be       	out	0x3f, r0	; 63
    1234:	0f 90       	pop	r0
    1236:	1f 90       	pop	r1
    1238:	18 95       	reti

0000123a <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    123a:	88 23       	and	r24, r24
    123c:	49 f0       	breq	.+18     	; 0x1250 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    123e:	80 e2       	ldi	r24, 0x20	; 32
    1240:	60 e0       	ldi	r22, 0x00	; 0
    1242:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1246:	80 e2       	ldi	r24, 0x20	; 32
    1248:	60 e0       	ldi	r22, 0x00	; 0
    124a:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
    124e:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1250:	80 e2       	ldi	r24, 0x20	; 32
    1252:	60 e0       	ldi	r22, 0x00	; 0
    1254:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <PortEx_DIRCLR>
    1258:	08 95       	ret

0000125a <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    125a:	1f 92       	push	r1
    125c:	0f 92       	push	r0
    125e:	0f b6       	in	r0, 0x3f	; 63
    1260:	0f 92       	push	r0
    1262:	0b b6       	in	r0, 0x3b	; 59
    1264:	0f 92       	push	r0
    1266:	11 24       	eor	r1, r1
    1268:	6f 92       	push	r6
    126a:	7f 92       	push	r7
    126c:	8f 92       	push	r8
    126e:	9f 92       	push	r9
    1270:	af 92       	push	r10
    1272:	bf 92       	push	r11
    1274:	cf 92       	push	r12
    1276:	df 92       	push	r13
    1278:	ef 92       	push	r14
    127a:	ff 92       	push	r15
    127c:	0f 93       	push	r16
    127e:	1f 93       	push	r17
    1280:	2f 93       	push	r18
    1282:	3f 93       	push	r19
    1284:	4f 93       	push	r20
    1286:	5f 93       	push	r21
    1288:	6f 93       	push	r22
    128a:	7f 93       	push	r23
    128c:	8f 93       	push	r24
    128e:	9f 93       	push	r25
    1290:	af 93       	push	r26
    1292:	bf 93       	push	r27
    1294:	ef 93       	push	r30
    1296:	ff 93       	push	r31
    1298:	cf 93       	push	r28
    129a:	df 93       	push	r29
    129c:	cd b7       	in	r28, 0x3d	; 61
    129e:	de b7       	in	r29, 0x3e	; 62
    12a0:	2c 97       	sbiw	r28, 0x0c	; 12
    12a2:	cd bf       	out	0x3d, r28	; 61
    12a4:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    12a6:	19 82       	std	Y+1, r1	; 0x01
    12a8:	1a 82       	std	Y+2, r1	; 0x02
    12aa:	1b 82       	std	Y+3, r1	; 0x03
    12ac:	1c 82       	std	Y+4, r1	; 0x04
    12ae:	1d 82       	std	Y+5, r1	; 0x05
    12b0:	1e 82       	std	Y+6, r1	; 0x06
    12b2:	1f 82       	std	Y+7, r1	; 0x07
    12b4:	18 86       	std	Y+8, r1	; 0x08
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    12ba:	25 e6       	ldi	r18, 0x65	; 101
    12bc:	30 e5       	ldi	r19, 0x50	; 80
    12be:	aa 24       	eor	r10, r10
    12c0:	aa 94       	dec	r10
    12c2:	ac 01       	movw	r20, r24
    12c4:	f9 01       	movw	r30, r18
    12c6:	e8 0f       	add	r30, r24
    12c8:	f9 1f       	adc	r31, r25
    12ca:	60 81       	ld	r22, Z
    12cc:	66 23       	and	r22, r22
    12ce:	14 f4       	brge	.+4      	; 0x12d4 <__vector_14+0x7a>
    12d0:	ac 86       	std	Y+12, r10	; 0x0c
    12d2:	01 c0       	rjmp	.+2      	; 0x12d6 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    12d4:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    12d6:	42 0f       	add	r20, r18
    12d8:	53 1f       	adc	r21, r19
    12da:	fa 01       	movw	r30, r20
    12dc:	40 81       	ld	r20, Z
    12de:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    12e0:	fc 01       	movw	r30, r24
    12e2:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    12e4:	e2 0f       	add	r30, r18
    12e6:	f3 1f       	adc	r31, r19
    12e8:	40 81       	ld	r20, Z
    12ea:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    12ec:	fc 01       	movw	r30, r24
    12ee:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    12f0:	e2 0f       	add	r30, r18
    12f2:	f3 1f       	adc	r31, r19
    12f4:	40 81       	ld	r20, Z
    12f6:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    12f8:	49 85       	ldd	r20, Y+9	; 0x09
    12fa:	5a 85       	ldd	r21, Y+10	; 0x0a
    12fc:	6b 85       	ldd	r22, Y+11	; 0x0b
    12fe:	7c 85       	ldd	r23, Y+12	; 0x0c
    1300:	b9 80       	ldd	r11, Y+1	; 0x01
    1302:	ca 80       	ldd	r12, Y+2	; 0x02
    1304:	db 80       	ldd	r13, Y+3	; 0x03
    1306:	ec 80       	ldd	r14, Y+4	; 0x04
    1308:	fd 80       	ldd	r15, Y+5	; 0x05
    130a:	0e 81       	ldd	r16, Y+6	; 0x06
    130c:	1f 81       	ldd	r17, Y+7	; 0x07
    130e:	88 84       	ldd	r8, Y+8	; 0x08
    1310:	b4 2f       	mov	r27, r20
    1312:	a5 2f       	mov	r26, r21
    1314:	f6 2f       	mov	r31, r22
    1316:	e7 2f       	mov	r30, r23
    1318:	77 0f       	add	r23, r23
    131a:	44 0b       	sbc	r20, r20
    131c:	54 2f       	mov	r21, r20
    131e:	ba 01       	movw	r22, r20
    1320:	64 2e       	mov	r6, r20
    1322:	74 2e       	mov	r7, r20
    1324:	94 2e       	mov	r9, r20
    1326:	bb 0e       	add	r11, r27
    1328:	61 e0       	ldi	r22, 0x01	; 1
    132a:	bb 16       	cp	r11, r27
    132c:	08 f0       	brcs	.+2      	; 0x1330 <__vector_14+0xd6>
    132e:	60 e0       	ldi	r22, 0x00	; 0
    1330:	ca 0e       	add	r12, r26
    1332:	51 e0       	ldi	r21, 0x01	; 1
    1334:	ca 16       	cp	r12, r26
    1336:	08 f0       	brcs	.+2      	; 0x133a <__vector_14+0xe0>
    1338:	50 e0       	ldi	r21, 0x00	; 0
    133a:	a6 2f       	mov	r26, r22
    133c:	ac 0d       	add	r26, r12
    133e:	61 e0       	ldi	r22, 0x01	; 1
    1340:	ac 15       	cp	r26, r12
    1342:	08 f0       	brcs	.+2      	; 0x1346 <__vector_14+0xec>
    1344:	60 e0       	ldi	r22, 0x00	; 0
    1346:	56 2b       	or	r21, r22
    1348:	df 0e       	add	r13, r31
    134a:	61 e0       	ldi	r22, 0x01	; 1
    134c:	df 16       	cp	r13, r31
    134e:	08 f0       	brcs	.+2      	; 0x1352 <__vector_14+0xf8>
    1350:	60 e0       	ldi	r22, 0x00	; 0
    1352:	f5 2f       	mov	r31, r21
    1354:	fd 0d       	add	r31, r13
    1356:	51 e0       	ldi	r21, 0x01	; 1
    1358:	fd 15       	cp	r31, r13
    135a:	08 f0       	brcs	.+2      	; 0x135e <__vector_14+0x104>
    135c:	50 e0       	ldi	r21, 0x00	; 0
    135e:	65 2b       	or	r22, r21
    1360:	ee 0e       	add	r14, r30
    1362:	51 e0       	ldi	r21, 0x01	; 1
    1364:	ee 16       	cp	r14, r30
    1366:	08 f0       	brcs	.+2      	; 0x136a <__vector_14+0x110>
    1368:	50 e0       	ldi	r21, 0x00	; 0
    136a:	e6 2f       	mov	r30, r22
    136c:	ee 0d       	add	r30, r14
    136e:	61 e0       	ldi	r22, 0x01	; 1
    1370:	ee 15       	cp	r30, r14
    1372:	08 f0       	brcs	.+2      	; 0x1376 <__vector_14+0x11c>
    1374:	60 e0       	ldi	r22, 0x00	; 0
    1376:	56 2b       	or	r21, r22
    1378:	f6 0c       	add	r15, r6
    137a:	71 e0       	ldi	r23, 0x01	; 1
    137c:	f6 14       	cp	r15, r6
    137e:	08 f0       	brcs	.+2      	; 0x1382 <__vector_14+0x128>
    1380:	70 e0       	ldi	r23, 0x00	; 0
    1382:	b5 2f       	mov	r27, r21
    1384:	bf 0d       	add	r27, r15
    1386:	51 e0       	ldi	r21, 0x01	; 1
    1388:	bf 15       	cp	r27, r15
    138a:	08 f0       	brcs	.+2      	; 0x138e <__vector_14+0x134>
    138c:	50 e0       	ldi	r21, 0x00	; 0
    138e:	75 2b       	or	r23, r21
    1390:	07 0d       	add	r16, r7
    1392:	61 e0       	ldi	r22, 0x01	; 1
    1394:	07 15       	cp	r16, r7
    1396:	08 f0       	brcs	.+2      	; 0x139a <__vector_14+0x140>
    1398:	60 e0       	ldi	r22, 0x00	; 0
    139a:	70 0f       	add	r23, r16
    139c:	51 e0       	ldi	r21, 0x01	; 1
    139e:	70 17       	cp	r23, r16
    13a0:	08 f0       	brcs	.+2      	; 0x13a4 <__vector_14+0x14a>
    13a2:	50 e0       	ldi	r21, 0x00	; 0
    13a4:	65 2b       	or	r22, r21
    13a6:	19 0d       	add	r17, r9
    13a8:	51 e0       	ldi	r21, 0x01	; 1
    13aa:	19 15       	cp	r17, r9
    13ac:	08 f0       	brcs	.+2      	; 0x13b0 <__vector_14+0x156>
    13ae:	50 e0       	ldi	r21, 0x00	; 0
    13b0:	61 0f       	add	r22, r17
    13b2:	01 e0       	ldi	r16, 0x01	; 1
    13b4:	61 17       	cp	r22, r17
    13b6:	08 f0       	brcs	.+2      	; 0x13ba <__vector_14+0x160>
    13b8:	00 e0       	ldi	r16, 0x00	; 0
    13ba:	50 2b       	or	r21, r16
    13bc:	48 0d       	add	r20, r8
    13be:	54 0f       	add	r21, r20
    13c0:	b9 82       	std	Y+1, r11	; 0x01
    13c2:	aa 83       	std	Y+2, r26	; 0x02
    13c4:	fb 83       	std	Y+3, r31	; 0x03
    13c6:	ec 83       	std	Y+4, r30	; 0x04
    13c8:	bd 83       	std	Y+5, r27	; 0x05
    13ca:	7e 83       	std	Y+6, r23	; 0x06
    13cc:	6f 83       	std	Y+7, r22	; 0x07
    13ce:	58 87       	std	Y+8, r21	; 0x08
    13d0:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    13d2:	8c 30       	cpi	r24, 0x0C	; 12
    13d4:	91 05       	cpc	r25, r1
    13d6:	09 f0       	breq	.+2      	; 0x13da <__vector_14+0x180>
    13d8:	74 cf       	rjmp	.-280    	; 0x12c2 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    13da:	e9 80       	ldd	r14, Y+1	; 0x01
    13dc:	fa 80       	ldd	r15, Y+2	; 0x02
    13de:	0b 81       	ldd	r16, Y+3	; 0x03
    13e0:	1c 81       	ldd	r17, Y+4	; 0x04
    13e2:	bd 81       	ldd	r27, Y+5	; 0x05
    13e4:	ae 81       	ldd	r26, Y+6	; 0x06
    13e6:	ff 81       	ldd	r31, Y+7	; 0x07
    13e8:	e8 85       	ldd	r30, Y+8	; 0x08
    13ea:	2e 2d       	mov	r18, r14
    13ec:	3f 2d       	mov	r19, r15
    13ee:	40 2f       	mov	r20, r16
    13f0:	51 2f       	mov	r21, r17
    13f2:	6b 2f       	mov	r22, r27
    13f4:	7a 2f       	mov	r23, r26
    13f6:	8f 2f       	mov	r24, r31
    13f8:	9e 2f       	mov	r25, r30
    13fa:	ee 23       	and	r30, r30
    13fc:	0c f0       	brlt	.+2      	; 0x1400 <__vector_14+0x1a6>
    13fe:	4a c0       	rjmp	.+148    	; 0x1494 <__vector_14+0x23a>
    1400:	93 e0       	ldi	r25, 0x03	; 3
    1402:	e9 0e       	add	r14, r25
    1404:	91 e0       	ldi	r25, 0x01	; 1
    1406:	e2 16       	cp	r14, r18
    1408:	08 f0       	brcs	.+2      	; 0x140c <__vector_14+0x1b2>
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	21 e0       	ldi	r18, 0x01	; 1
    140e:	f3 16       	cp	r15, r19
    1410:	08 f0       	brcs	.+2      	; 0x1414 <__vector_14+0x1ba>
    1412:	20 e0       	ldi	r18, 0x00	; 0
    1414:	39 2f       	mov	r19, r25
    1416:	3f 0d       	add	r19, r15
    1418:	91 e0       	ldi	r25, 0x01	; 1
    141a:	3f 15       	cp	r19, r15
    141c:	08 f0       	brcs	.+2      	; 0x1420 <__vector_14+0x1c6>
    141e:	90 e0       	ldi	r25, 0x00	; 0
    1420:	29 2b       	or	r18, r25
    1422:	91 e0       	ldi	r25, 0x01	; 1
    1424:	04 17       	cp	r16, r20
    1426:	08 f0       	brcs	.+2      	; 0x142a <__vector_14+0x1d0>
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	42 2f       	mov	r20, r18
    142c:	40 0f       	add	r20, r16
    142e:	21 e0       	ldi	r18, 0x01	; 1
    1430:	40 17       	cp	r20, r16
    1432:	08 f0       	brcs	.+2      	; 0x1436 <__vector_14+0x1dc>
    1434:	20 e0       	ldi	r18, 0x00	; 0
    1436:	92 2b       	or	r25, r18
    1438:	21 e0       	ldi	r18, 0x01	; 1
    143a:	15 17       	cp	r17, r21
    143c:	08 f0       	brcs	.+2      	; 0x1440 <__vector_14+0x1e6>
    143e:	20 e0       	ldi	r18, 0x00	; 0
    1440:	59 2f       	mov	r21, r25
    1442:	51 0f       	add	r21, r17
    1444:	91 e0       	ldi	r25, 0x01	; 1
    1446:	51 17       	cp	r21, r17
    1448:	08 f0       	brcs	.+2      	; 0x144c <__vector_14+0x1f2>
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	29 2b       	or	r18, r25
    144e:	91 e0       	ldi	r25, 0x01	; 1
    1450:	b6 17       	cp	r27, r22
    1452:	08 f0       	brcs	.+2      	; 0x1456 <__vector_14+0x1fc>
    1454:	90 e0       	ldi	r25, 0x00	; 0
    1456:	62 2f       	mov	r22, r18
    1458:	6b 0f       	add	r22, r27
    145a:	21 e0       	ldi	r18, 0x01	; 1
    145c:	6b 17       	cp	r22, r27
    145e:	08 f0       	brcs	.+2      	; 0x1462 <__vector_14+0x208>
    1460:	20 e0       	ldi	r18, 0x00	; 0
    1462:	92 2b       	or	r25, r18
    1464:	21 e0       	ldi	r18, 0x01	; 1
    1466:	a7 17       	cp	r26, r23
    1468:	08 f0       	brcs	.+2      	; 0x146c <__vector_14+0x212>
    146a:	20 e0       	ldi	r18, 0x00	; 0
    146c:	79 2f       	mov	r23, r25
    146e:	7a 0f       	add	r23, r26
    1470:	91 e0       	ldi	r25, 0x01	; 1
    1472:	7a 17       	cp	r23, r26
    1474:	08 f0       	brcs	.+2      	; 0x1478 <__vector_14+0x21e>
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	29 2b       	or	r18, r25
    147a:	91 e0       	ldi	r25, 0x01	; 1
    147c:	f8 17       	cp	r31, r24
    147e:	08 f0       	brcs	.+2      	; 0x1482 <__vector_14+0x228>
    1480:	90 e0       	ldi	r25, 0x00	; 0
    1482:	82 2f       	mov	r24, r18
    1484:	8f 0f       	add	r24, r31
    1486:	21 e0       	ldi	r18, 0x01	; 1
    1488:	8f 17       	cp	r24, r31
    148a:	08 f0       	brcs	.+2      	; 0x148e <__vector_14+0x234>
    148c:	20 e0       	ldi	r18, 0x00	; 0
    148e:	92 2b       	or	r25, r18
    1490:	2e 2d       	mov	r18, r14
    1492:	9e 0f       	add	r25, r30
    1494:	02 e0       	ldi	r16, 0x02	; 2
    1496:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__ashrdi3>
    149a:	29 83       	std	Y+1, r18	; 0x01
    149c:	3a 83       	std	Y+2, r19	; 0x02
    149e:	4b 83       	std	Y+3, r20	; 0x03
    14a0:	5c 83       	std	Y+4, r21	; 0x04
    14a2:	6d 83       	std	Y+5, r22	; 0x05
    14a4:	7e 83       	std	Y+6, r23	; 0x06
    14a6:	8f 83       	std	Y+7, r24	; 0x07
    14a8:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    14aa:	80 90 74 50 	lds	r8, 0x5074
    14ae:	90 90 75 50 	lds	r9, 0x5075
    14b2:	a0 90 76 50 	lds	r10, 0x5076
    14b6:	b0 90 77 50 	lds	r11, 0x5077
    14ba:	29 81       	ldd	r18, Y+1	; 0x01
    14bc:	3a 81       	ldd	r19, Y+2	; 0x02
    14be:	4b 81       	ldd	r20, Y+3	; 0x03
    14c0:	5c 81       	ldd	r21, Y+4	; 0x04
    14c2:	6d 81       	ldd	r22, Y+5	; 0x05
    14c4:	7e 81       	ldd	r23, Y+6	; 0x06
    14c6:	8f 81       	ldd	r24, Y+7	; 0x07
    14c8:	98 85       	ldd	r25, Y+8	; 0x08
    14ca:	f4 01       	movw	r30, r8
    14cc:	ee 0f       	add	r30, r30
    14ce:	ff 1f       	adc	r31, r31
    14d0:	ee 0f       	add	r30, r30
    14d2:	ff 1f       	adc	r31, r31
    14d4:	80 90 72 50 	lds	r8, 0x5072
    14d8:	90 90 73 50 	lds	r9, 0x5073
    14dc:	8e 0e       	add	r8, r30
    14de:	9f 1e       	adc	r9, r31
    14e0:	0f 2e       	mov	r0, r31
    14e2:	f0 ea       	ldi	r31, 0xA0	; 160
    14e4:	af 2e       	mov	r10, r31
    14e6:	f0 2d       	mov	r31, r0
    14e8:	0f 2e       	mov	r0, r31
    14ea:	f5 e2       	ldi	r31, 0x25	; 37
    14ec:	bf 2e       	mov	r11, r31
    14ee:	f0 2d       	mov	r31, r0
    14f0:	0f 2e       	mov	r0, r31
    14f2:	f6 e2       	ldi	r31, 0x26	; 38
    14f4:	cf 2e       	mov	r12, r31
    14f6:	f0 2d       	mov	r31, r0
    14f8:	dd 24       	eor	r13, r13
    14fa:	ee 24       	eor	r14, r14
    14fc:	ff 24       	eor	r15, r15
    14fe:	00 e0       	ldi	r16, 0x00	; 0
    1500:	10 e0       	ldi	r17, 0x00	; 0
    1502:	0e 94 a0 2f 	call	0x5f40	; 0x5f40 <__muldi3>
    1506:	aa 24       	eor	r10, r10
    1508:	aa 94       	dec	r10
    150a:	bb 24       	eor	r11, r11
    150c:	ba 94       	dec	r11
    150e:	0f 2e       	mov	r0, r31
    1510:	ff e7       	ldi	r31, 0x7F	; 127
    1512:	cf 2e       	mov	r12, r31
    1514:	f0 2d       	mov	r31, r0
    1516:	0e 94 4f 31 	call	0x629e	; 0x629e <__divdi3>
    151a:	01 e0       	ldi	r16, 0x01	; 1
    151c:	0e 94 73 30 	call	0x60e6	; 0x60e6 <__ashldi3>
    1520:	0f 2e       	mov	r0, r31
    1522:	f3 e0       	ldi	r31, 0x03	; 3
    1524:	af 2e       	mov	r10, r31
    1526:	f0 2d       	mov	r31, r0
    1528:	bb 24       	eor	r11, r11
    152a:	cc 24       	eor	r12, r12
    152c:	00 e0       	ldi	r16, 0x00	; 0
    152e:	0e 94 4f 31 	call	0x629e	; 0x629e <__divdi3>
    1532:	f4 01       	movw	r30, r8
    1534:	20 83       	st	Z, r18
    1536:	31 83       	std	Z+1, r19	; 0x01
    1538:	42 83       	std	Z+2, r20	; 0x02
    153a:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    153c:	80 91 74 50 	lds	r24, 0x5074
    1540:	90 91 75 50 	lds	r25, 0x5075
    1544:	a0 91 76 50 	lds	r26, 0x5076
    1548:	b0 91 77 50 	lds	r27, 0x5077
    154c:	01 96       	adiw	r24, 0x01	; 1
    154e:	a1 1d       	adc	r26, r1
    1550:	b1 1d       	adc	r27, r1
    1552:	80 93 74 50 	sts	0x5074, r24
    1556:	90 93 75 50 	sts	0x5075, r25
    155a:	a0 93 76 50 	sts	0x5076, r26
    155e:	b0 93 77 50 	sts	0x5077, r27

}
    1562:	2c 96       	adiw	r28, 0x0c	; 12
    1564:	cd bf       	out	0x3d, r28	; 61
    1566:	de bf       	out	0x3e, r29	; 62
    1568:	df 91       	pop	r29
    156a:	cf 91       	pop	r28
    156c:	ff 91       	pop	r31
    156e:	ef 91       	pop	r30
    1570:	bf 91       	pop	r27
    1572:	af 91       	pop	r26
    1574:	9f 91       	pop	r25
    1576:	8f 91       	pop	r24
    1578:	7f 91       	pop	r23
    157a:	6f 91       	pop	r22
    157c:	5f 91       	pop	r21
    157e:	4f 91       	pop	r20
    1580:	3f 91       	pop	r19
    1582:	2f 91       	pop	r18
    1584:	1f 91       	pop	r17
    1586:	0f 91       	pop	r16
    1588:	ff 90       	pop	r15
    158a:	ef 90       	pop	r14
    158c:	df 90       	pop	r13
    158e:	cf 90       	pop	r12
    1590:	bf 90       	pop	r11
    1592:	af 90       	pop	r10
    1594:	9f 90       	pop	r9
    1596:	8f 90       	pop	r8
    1598:	7f 90       	pop	r7
    159a:	6f 90       	pop	r6
    159c:	0f 90       	pop	r0
    159e:	0b be       	out	0x3b, r0	; 59
    15a0:	0f 90       	pop	r0
    15a2:	0f be       	out	0x3f, r0	; 63
    15a4:	0f 90       	pop	r0
    15a6:	1f 90       	pop	r1
    15a8:	18 95       	reti

000015aa <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    15aa:	1f 92       	push	r1
    15ac:	0f 92       	push	r0
    15ae:	0f b6       	in	r0, 0x3f	; 63
    15b0:	0f 92       	push	r0
    15b2:	0b b6       	in	r0, 0x3b	; 59
    15b4:	0f 92       	push	r0
    15b6:	11 24       	eor	r1, r1
    15b8:	6f 92       	push	r6
    15ba:	7f 92       	push	r7
    15bc:	8f 92       	push	r8
    15be:	9f 92       	push	r9
    15c0:	af 92       	push	r10
    15c2:	bf 92       	push	r11
    15c4:	cf 92       	push	r12
    15c6:	df 92       	push	r13
    15c8:	ef 92       	push	r14
    15ca:	ff 92       	push	r15
    15cc:	0f 93       	push	r16
    15ce:	1f 93       	push	r17
    15d0:	2f 93       	push	r18
    15d2:	3f 93       	push	r19
    15d4:	4f 93       	push	r20
    15d6:	5f 93       	push	r21
    15d8:	6f 93       	push	r22
    15da:	7f 93       	push	r23
    15dc:	8f 93       	push	r24
    15de:	9f 93       	push	r25
    15e0:	af 93       	push	r26
    15e2:	bf 93       	push	r27
    15e4:	ef 93       	push	r30
    15e6:	ff 93       	push	r31
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
    15ec:	cd b7       	in	r28, 0x3d	; 61
    15ee:	de b7       	in	r29, 0x3e	; 62
    15f0:	2c 97       	sbiw	r28, 0x0c	; 12
    15f2:	cd bf       	out	0x3d, r28	; 61
    15f4:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    15f6:	19 82       	std	Y+1, r1	; 0x01
    15f8:	1a 82       	std	Y+2, r1	; 0x02
    15fa:	1b 82       	std	Y+3, r1	; 0x03
    15fc:	1c 82       	std	Y+4, r1	; 0x04
    15fe:	1d 82       	std	Y+5, r1	; 0x05
    1600:	1e 82       	std	Y+6, r1	; 0x06
    1602:	1f 82       	std	Y+7, r1	; 0x07
    1604:	18 86       	std	Y+8, r1	; 0x08
    1606:	80 e0       	ldi	r24, 0x00	; 0
    1608:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    160a:	25 e6       	ldi	r18, 0x65	; 101
    160c:	30 e5       	ldi	r19, 0x50	; 80
    160e:	aa 24       	eor	r10, r10
    1610:	aa 94       	dec	r10
    1612:	ac 01       	movw	r20, r24
    1614:	f9 01       	movw	r30, r18
    1616:	e8 0f       	add	r30, r24
    1618:	f9 1f       	adc	r31, r25
    161a:	60 81       	ld	r22, Z
    161c:	66 23       	and	r22, r22
    161e:	14 f4       	brge	.+4      	; 0x1624 <__vector_77+0x7a>
    1620:	ac 86       	std	Y+12, r10	; 0x0c
    1622:	01 c0       	rjmp	.+2      	; 0x1626 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1624:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1626:	42 0f       	add	r20, r18
    1628:	53 1f       	adc	r21, r19
    162a:	fa 01       	movw	r30, r20
    162c:	40 81       	ld	r20, Z
    162e:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1630:	fc 01       	movw	r30, r24
    1632:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1634:	e2 0f       	add	r30, r18
    1636:	f3 1f       	adc	r31, r19
    1638:	40 81       	ld	r20, Z
    163a:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    163c:	fc 01       	movw	r30, r24
    163e:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1640:	e2 0f       	add	r30, r18
    1642:	f3 1f       	adc	r31, r19
    1644:	40 81       	ld	r20, Z
    1646:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1648:	49 85       	ldd	r20, Y+9	; 0x09
    164a:	5a 85       	ldd	r21, Y+10	; 0x0a
    164c:	6b 85       	ldd	r22, Y+11	; 0x0b
    164e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1650:	b9 80       	ldd	r11, Y+1	; 0x01
    1652:	ca 80       	ldd	r12, Y+2	; 0x02
    1654:	db 80       	ldd	r13, Y+3	; 0x03
    1656:	ec 80       	ldd	r14, Y+4	; 0x04
    1658:	fd 80       	ldd	r15, Y+5	; 0x05
    165a:	0e 81       	ldd	r16, Y+6	; 0x06
    165c:	1f 81       	ldd	r17, Y+7	; 0x07
    165e:	88 84       	ldd	r8, Y+8	; 0x08
    1660:	b4 2f       	mov	r27, r20
    1662:	a5 2f       	mov	r26, r21
    1664:	f6 2f       	mov	r31, r22
    1666:	e7 2f       	mov	r30, r23
    1668:	77 0f       	add	r23, r23
    166a:	44 0b       	sbc	r20, r20
    166c:	54 2f       	mov	r21, r20
    166e:	ba 01       	movw	r22, r20
    1670:	64 2e       	mov	r6, r20
    1672:	74 2e       	mov	r7, r20
    1674:	94 2e       	mov	r9, r20
    1676:	bb 0e       	add	r11, r27
    1678:	61 e0       	ldi	r22, 0x01	; 1
    167a:	bb 16       	cp	r11, r27
    167c:	08 f0       	brcs	.+2      	; 0x1680 <__vector_77+0xd6>
    167e:	60 e0       	ldi	r22, 0x00	; 0
    1680:	ca 0e       	add	r12, r26
    1682:	51 e0       	ldi	r21, 0x01	; 1
    1684:	ca 16       	cp	r12, r26
    1686:	08 f0       	brcs	.+2      	; 0x168a <__vector_77+0xe0>
    1688:	50 e0       	ldi	r21, 0x00	; 0
    168a:	a6 2f       	mov	r26, r22
    168c:	ac 0d       	add	r26, r12
    168e:	61 e0       	ldi	r22, 0x01	; 1
    1690:	ac 15       	cp	r26, r12
    1692:	08 f0       	brcs	.+2      	; 0x1696 <__vector_77+0xec>
    1694:	60 e0       	ldi	r22, 0x00	; 0
    1696:	56 2b       	or	r21, r22
    1698:	df 0e       	add	r13, r31
    169a:	61 e0       	ldi	r22, 0x01	; 1
    169c:	df 16       	cp	r13, r31
    169e:	08 f0       	brcs	.+2      	; 0x16a2 <__vector_77+0xf8>
    16a0:	60 e0       	ldi	r22, 0x00	; 0
    16a2:	f5 2f       	mov	r31, r21
    16a4:	fd 0d       	add	r31, r13
    16a6:	51 e0       	ldi	r21, 0x01	; 1
    16a8:	fd 15       	cp	r31, r13
    16aa:	08 f0       	brcs	.+2      	; 0x16ae <__vector_77+0x104>
    16ac:	50 e0       	ldi	r21, 0x00	; 0
    16ae:	65 2b       	or	r22, r21
    16b0:	ee 0e       	add	r14, r30
    16b2:	51 e0       	ldi	r21, 0x01	; 1
    16b4:	ee 16       	cp	r14, r30
    16b6:	08 f0       	brcs	.+2      	; 0x16ba <__vector_77+0x110>
    16b8:	50 e0       	ldi	r21, 0x00	; 0
    16ba:	e6 2f       	mov	r30, r22
    16bc:	ee 0d       	add	r30, r14
    16be:	61 e0       	ldi	r22, 0x01	; 1
    16c0:	ee 15       	cp	r30, r14
    16c2:	08 f0       	brcs	.+2      	; 0x16c6 <__vector_77+0x11c>
    16c4:	60 e0       	ldi	r22, 0x00	; 0
    16c6:	56 2b       	or	r21, r22
    16c8:	f6 0c       	add	r15, r6
    16ca:	71 e0       	ldi	r23, 0x01	; 1
    16cc:	f6 14       	cp	r15, r6
    16ce:	08 f0       	brcs	.+2      	; 0x16d2 <__vector_77+0x128>
    16d0:	70 e0       	ldi	r23, 0x00	; 0
    16d2:	b5 2f       	mov	r27, r21
    16d4:	bf 0d       	add	r27, r15
    16d6:	51 e0       	ldi	r21, 0x01	; 1
    16d8:	bf 15       	cp	r27, r15
    16da:	08 f0       	brcs	.+2      	; 0x16de <__vector_77+0x134>
    16dc:	50 e0       	ldi	r21, 0x00	; 0
    16de:	75 2b       	or	r23, r21
    16e0:	07 0d       	add	r16, r7
    16e2:	61 e0       	ldi	r22, 0x01	; 1
    16e4:	07 15       	cp	r16, r7
    16e6:	08 f0       	brcs	.+2      	; 0x16ea <__vector_77+0x140>
    16e8:	60 e0       	ldi	r22, 0x00	; 0
    16ea:	70 0f       	add	r23, r16
    16ec:	51 e0       	ldi	r21, 0x01	; 1
    16ee:	70 17       	cp	r23, r16
    16f0:	08 f0       	brcs	.+2      	; 0x16f4 <__vector_77+0x14a>
    16f2:	50 e0       	ldi	r21, 0x00	; 0
    16f4:	65 2b       	or	r22, r21
    16f6:	19 0d       	add	r17, r9
    16f8:	51 e0       	ldi	r21, 0x01	; 1
    16fa:	19 15       	cp	r17, r9
    16fc:	08 f0       	brcs	.+2      	; 0x1700 <__vector_77+0x156>
    16fe:	50 e0       	ldi	r21, 0x00	; 0
    1700:	61 0f       	add	r22, r17
    1702:	01 e0       	ldi	r16, 0x01	; 1
    1704:	61 17       	cp	r22, r17
    1706:	08 f0       	brcs	.+2      	; 0x170a <__vector_77+0x160>
    1708:	00 e0       	ldi	r16, 0x00	; 0
    170a:	50 2b       	or	r21, r16
    170c:	48 0d       	add	r20, r8
    170e:	54 0f       	add	r21, r20
    1710:	b9 82       	std	Y+1, r11	; 0x01
    1712:	aa 83       	std	Y+2, r26	; 0x02
    1714:	fb 83       	std	Y+3, r31	; 0x03
    1716:	ec 83       	std	Y+4, r30	; 0x04
    1718:	bd 83       	std	Y+5, r27	; 0x05
    171a:	7e 83       	std	Y+6, r23	; 0x06
    171c:	6f 83       	std	Y+7, r22	; 0x07
    171e:	58 87       	std	Y+8, r21	; 0x08
    1720:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1722:	8c 30       	cpi	r24, 0x0C	; 12
    1724:	91 05       	cpc	r25, r1
    1726:	09 f0       	breq	.+2      	; 0x172a <__vector_77+0x180>
    1728:	74 cf       	rjmp	.-280    	; 0x1612 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    172a:	e9 80       	ldd	r14, Y+1	; 0x01
    172c:	fa 80       	ldd	r15, Y+2	; 0x02
    172e:	0b 81       	ldd	r16, Y+3	; 0x03
    1730:	1c 81       	ldd	r17, Y+4	; 0x04
    1732:	bd 81       	ldd	r27, Y+5	; 0x05
    1734:	ae 81       	ldd	r26, Y+6	; 0x06
    1736:	ff 81       	ldd	r31, Y+7	; 0x07
    1738:	e8 85       	ldd	r30, Y+8	; 0x08
    173a:	2e 2d       	mov	r18, r14
    173c:	3f 2d       	mov	r19, r15
    173e:	40 2f       	mov	r20, r16
    1740:	51 2f       	mov	r21, r17
    1742:	6b 2f       	mov	r22, r27
    1744:	7a 2f       	mov	r23, r26
    1746:	8f 2f       	mov	r24, r31
    1748:	9e 2f       	mov	r25, r30
    174a:	ee 23       	and	r30, r30
    174c:	0c f0       	brlt	.+2      	; 0x1750 <__vector_77+0x1a6>
    174e:	4a c0       	rjmp	.+148    	; 0x17e4 <__vector_77+0x23a>
    1750:	93 e0       	ldi	r25, 0x03	; 3
    1752:	e9 0e       	add	r14, r25
    1754:	91 e0       	ldi	r25, 0x01	; 1
    1756:	e2 16       	cp	r14, r18
    1758:	08 f0       	brcs	.+2      	; 0x175c <__vector_77+0x1b2>
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	21 e0       	ldi	r18, 0x01	; 1
    175e:	f3 16       	cp	r15, r19
    1760:	08 f0       	brcs	.+2      	; 0x1764 <__vector_77+0x1ba>
    1762:	20 e0       	ldi	r18, 0x00	; 0
    1764:	39 2f       	mov	r19, r25
    1766:	3f 0d       	add	r19, r15
    1768:	91 e0       	ldi	r25, 0x01	; 1
    176a:	3f 15       	cp	r19, r15
    176c:	08 f0       	brcs	.+2      	; 0x1770 <__vector_77+0x1c6>
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	29 2b       	or	r18, r25
    1772:	91 e0       	ldi	r25, 0x01	; 1
    1774:	04 17       	cp	r16, r20
    1776:	08 f0       	brcs	.+2      	; 0x177a <__vector_77+0x1d0>
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	42 2f       	mov	r20, r18
    177c:	40 0f       	add	r20, r16
    177e:	21 e0       	ldi	r18, 0x01	; 1
    1780:	40 17       	cp	r20, r16
    1782:	08 f0       	brcs	.+2      	; 0x1786 <__vector_77+0x1dc>
    1784:	20 e0       	ldi	r18, 0x00	; 0
    1786:	92 2b       	or	r25, r18
    1788:	21 e0       	ldi	r18, 0x01	; 1
    178a:	15 17       	cp	r17, r21
    178c:	08 f0       	brcs	.+2      	; 0x1790 <__vector_77+0x1e6>
    178e:	20 e0       	ldi	r18, 0x00	; 0
    1790:	59 2f       	mov	r21, r25
    1792:	51 0f       	add	r21, r17
    1794:	91 e0       	ldi	r25, 0x01	; 1
    1796:	51 17       	cp	r21, r17
    1798:	08 f0       	brcs	.+2      	; 0x179c <__vector_77+0x1f2>
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	29 2b       	or	r18, r25
    179e:	91 e0       	ldi	r25, 0x01	; 1
    17a0:	b6 17       	cp	r27, r22
    17a2:	08 f0       	brcs	.+2      	; 0x17a6 <__vector_77+0x1fc>
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	62 2f       	mov	r22, r18
    17a8:	6b 0f       	add	r22, r27
    17aa:	21 e0       	ldi	r18, 0x01	; 1
    17ac:	6b 17       	cp	r22, r27
    17ae:	08 f0       	brcs	.+2      	; 0x17b2 <__vector_77+0x208>
    17b0:	20 e0       	ldi	r18, 0x00	; 0
    17b2:	92 2b       	or	r25, r18
    17b4:	21 e0       	ldi	r18, 0x01	; 1
    17b6:	a7 17       	cp	r26, r23
    17b8:	08 f0       	brcs	.+2      	; 0x17bc <__vector_77+0x212>
    17ba:	20 e0       	ldi	r18, 0x00	; 0
    17bc:	79 2f       	mov	r23, r25
    17be:	7a 0f       	add	r23, r26
    17c0:	91 e0       	ldi	r25, 0x01	; 1
    17c2:	7a 17       	cp	r23, r26
    17c4:	08 f0       	brcs	.+2      	; 0x17c8 <__vector_77+0x21e>
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	29 2b       	or	r18, r25
    17ca:	91 e0       	ldi	r25, 0x01	; 1
    17cc:	f8 17       	cp	r31, r24
    17ce:	08 f0       	brcs	.+2      	; 0x17d2 <__vector_77+0x228>
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	82 2f       	mov	r24, r18
    17d4:	8f 0f       	add	r24, r31
    17d6:	21 e0       	ldi	r18, 0x01	; 1
    17d8:	8f 17       	cp	r24, r31
    17da:	08 f0       	brcs	.+2      	; 0x17de <__vector_77+0x234>
    17dc:	20 e0       	ldi	r18, 0x00	; 0
    17de:	92 2b       	or	r25, r18
    17e0:	2e 2d       	mov	r18, r14
    17e2:	9e 0f       	add	r25, r30
    17e4:	02 e0       	ldi	r16, 0x02	; 2
    17e6:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__ashrdi3>
    17ea:	29 83       	std	Y+1, r18	; 0x01
    17ec:	3a 83       	std	Y+2, r19	; 0x02
    17ee:	4b 83       	std	Y+3, r20	; 0x03
    17f0:	5c 83       	std	Y+4, r21	; 0x04
    17f2:	6d 83       	std	Y+5, r22	; 0x05
    17f4:	7e 83       	std	Y+6, r23	; 0x06
    17f6:	8f 83       	std	Y+7, r24	; 0x07
    17f8:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    17fa:	80 90 74 50 	lds	r8, 0x5074
    17fe:	90 90 75 50 	lds	r9, 0x5075
    1802:	a0 90 76 50 	lds	r10, 0x5076
    1806:	b0 90 77 50 	lds	r11, 0x5077
    180a:	29 81       	ldd	r18, Y+1	; 0x01
    180c:	3a 81       	ldd	r19, Y+2	; 0x02
    180e:	4b 81       	ldd	r20, Y+3	; 0x03
    1810:	5c 81       	ldd	r21, Y+4	; 0x04
    1812:	6d 81       	ldd	r22, Y+5	; 0x05
    1814:	7e 81       	ldd	r23, Y+6	; 0x06
    1816:	8f 81       	ldd	r24, Y+7	; 0x07
    1818:	98 85       	ldd	r25, Y+8	; 0x08
    181a:	f4 01       	movw	r30, r8
    181c:	ee 0f       	add	r30, r30
    181e:	ff 1f       	adc	r31, r31
    1820:	ee 0f       	add	r30, r30
    1822:	ff 1f       	adc	r31, r31
    1824:	80 90 72 50 	lds	r8, 0x5072
    1828:	90 90 73 50 	lds	r9, 0x5073
    182c:	8e 0e       	add	r8, r30
    182e:	9f 1e       	adc	r9, r31
    1830:	0f 2e       	mov	r0, r31
    1832:	f0 ea       	ldi	r31, 0xA0	; 160
    1834:	af 2e       	mov	r10, r31
    1836:	f0 2d       	mov	r31, r0
    1838:	0f 2e       	mov	r0, r31
    183a:	f5 e2       	ldi	r31, 0x25	; 37
    183c:	bf 2e       	mov	r11, r31
    183e:	f0 2d       	mov	r31, r0
    1840:	0f 2e       	mov	r0, r31
    1842:	f6 e2       	ldi	r31, 0x26	; 38
    1844:	cf 2e       	mov	r12, r31
    1846:	f0 2d       	mov	r31, r0
    1848:	dd 24       	eor	r13, r13
    184a:	ee 24       	eor	r14, r14
    184c:	ff 24       	eor	r15, r15
    184e:	00 e0       	ldi	r16, 0x00	; 0
    1850:	10 e0       	ldi	r17, 0x00	; 0
    1852:	0e 94 a0 2f 	call	0x5f40	; 0x5f40 <__muldi3>
    1856:	aa 24       	eor	r10, r10
    1858:	aa 94       	dec	r10
    185a:	bb 24       	eor	r11, r11
    185c:	ba 94       	dec	r11
    185e:	0f 2e       	mov	r0, r31
    1860:	ff e7       	ldi	r31, 0x7F	; 127
    1862:	cf 2e       	mov	r12, r31
    1864:	f0 2d       	mov	r31, r0
    1866:	0e 94 4f 31 	call	0x629e	; 0x629e <__divdi3>
    186a:	01 e0       	ldi	r16, 0x01	; 1
    186c:	0e 94 73 30 	call	0x60e6	; 0x60e6 <__ashldi3>
    1870:	0f 2e       	mov	r0, r31
    1872:	f3 e0       	ldi	r31, 0x03	; 3
    1874:	af 2e       	mov	r10, r31
    1876:	f0 2d       	mov	r31, r0
    1878:	bb 24       	eor	r11, r11
    187a:	cc 24       	eor	r12, r12
    187c:	00 e0       	ldi	r16, 0x00	; 0
    187e:	0e 94 4f 31 	call	0x629e	; 0x629e <__divdi3>
    1882:	f4 01       	movw	r30, r8
    1884:	20 83       	st	Z, r18
    1886:	31 83       	std	Z+1, r19	; 0x01
    1888:	42 83       	std	Z+2, r20	; 0x02
    188a:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    188c:	80 91 74 50 	lds	r24, 0x5074
    1890:	90 91 75 50 	lds	r25, 0x5075
    1894:	a0 91 76 50 	lds	r26, 0x5076
    1898:	b0 91 77 50 	lds	r27, 0x5077
    189c:	01 96       	adiw	r24, 0x01	; 1
    189e:	a1 1d       	adc	r26, r1
    18a0:	b1 1d       	adc	r27, r1
    18a2:	80 93 74 50 	sts	0x5074, r24
    18a6:	90 93 75 50 	sts	0x5075, r25
    18aa:	a0 93 76 50 	sts	0x5076, r26
    18ae:	b0 93 77 50 	sts	0x5077, r27
}
    18b2:	2c 96       	adiw	r28, 0x0c	; 12
    18b4:	cd bf       	out	0x3d, r28	; 61
    18b6:	de bf       	out	0x3e, r29	; 62
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	ff 91       	pop	r31
    18be:	ef 91       	pop	r30
    18c0:	bf 91       	pop	r27
    18c2:	af 91       	pop	r26
    18c4:	9f 91       	pop	r25
    18c6:	8f 91       	pop	r24
    18c8:	7f 91       	pop	r23
    18ca:	6f 91       	pop	r22
    18cc:	5f 91       	pop	r21
    18ce:	4f 91       	pop	r20
    18d0:	3f 91       	pop	r19
    18d2:	2f 91       	pop	r18
    18d4:	1f 91       	pop	r17
    18d6:	0f 91       	pop	r16
    18d8:	ff 90       	pop	r15
    18da:	ef 90       	pop	r14
    18dc:	df 90       	pop	r13
    18de:	cf 90       	pop	r12
    18e0:	bf 90       	pop	r11
    18e2:	af 90       	pop	r10
    18e4:	9f 90       	pop	r9
    18e6:	8f 90       	pop	r8
    18e8:	7f 90       	pop	r7
    18ea:	6f 90       	pop	r6
    18ec:	0f 90       	pop	r0
    18ee:	0b be       	out	0x3b, r0	; 59
    18f0:	0f 90       	pop	r0
    18f2:	0f be       	out	0x3f, r0	; 63
    18f4:	0f 90       	pop	r0
    18f6:	1f 90       	pop	r1
    18f8:	18 95       	reti

000018fa <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    18fa:	82 e0       	ldi	r24, 0x02	; 2
    18fc:	e0 ea       	ldi	r30, 0xA0	; 160
    18fe:	f6 e0       	ldi	r31, 0x06	; 6
    1900:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1902:	8a ea       	ldi	r24, 0xAA	; 170
    1904:	e0 ec       	ldi	r30, 0xC0	; 192
    1906:	f8 e0       	ldi	r31, 0x08	; 8
    1908:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    190a:	82 81       	ldd	r24, Z+2	; 0x02
    190c:	88 23       	and	r24, r24
    190e:	ec f7       	brge	.-6      	; 0x190a <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    1910:	90 91 c6 50 	lds	r25, 0x50C6
    1914:	e0 ec       	ldi	r30, 0xC0	; 192
    1916:	f8 e0       	ldi	r31, 0x08	; 8
    1918:	83 81       	ldd	r24, Z+3	; 0x03
    191a:	a5 e6       	ldi	r26, 0x65	; 101
    191c:	b0 e5       	ldi	r27, 0x50	; 80
    191e:	a9 0f       	add	r26, r25
    1920:	b1 1d       	adc	r27, r1
    1922:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1924:	8a ea       	ldi	r24, 0xAA	; 170
    1926:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1928:	82 81       	ldd	r24, Z+2	; 0x02
    192a:	88 23       	and	r24, r24
    192c:	ec f7       	brge	.-6      	; 0x1928 <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    192e:	a0 91 c6 50 	lds	r26, 0x50C6
    1932:	b0 e0       	ldi	r27, 0x00	; 0
    1934:	e0 ec       	ldi	r30, 0xC0	; 192
    1936:	f8 e0       	ldi	r31, 0x08	; 8
    1938:	83 81       	ldd	r24, Z+3	; 0x03
    193a:	aa 59       	subi	r26, 0x9A	; 154
    193c:	bf 4a       	sbci	r27, 0xAF	; 175
    193e:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1940:	8a ea       	ldi	r24, 0xAA	; 170
    1942:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1944:	82 81       	ldd	r24, Z+2	; 0x02
    1946:	88 23       	and	r24, r24
    1948:	ec f7       	brge	.-6      	; 0x1944 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    194a:	e0 91 c6 50 	lds	r30, 0x50C6
    194e:	f0 e0       	ldi	r31, 0x00	; 0
    1950:	a0 ec       	ldi	r26, 0xC0	; 192
    1952:	b8 e0       	ldi	r27, 0x08	; 8
    1954:	13 96       	adiw	r26, 0x03	; 3
    1956:	8c 91       	ld	r24, X
    1958:	13 97       	sbiw	r26, 0x03	; 3
    195a:	e9 59       	subi	r30, 0x99	; 153
    195c:	ff 4a       	sbci	r31, 0xAF	; 175
    195e:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1960:	82 e0       	ldi	r24, 0x02	; 2
    1962:	e0 ea       	ldi	r30, 0xA0	; 160
    1964:	f6 e0       	ldi	r31, 0x06	; 6
    1966:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    1968:	80 91 c6 50 	lds	r24, 0x50C6
    196c:	8d 5f       	subi	r24, 0xFD	; 253
    196e:	80 93 c6 50 	sts	0x50C6, r24
}
    1972:	08 95       	ret

00001974 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    1974:	1f 92       	push	r1
    1976:	0f 92       	push	r0
    1978:	0f b6       	in	r0, 0x3f	; 63
    197a:	0f 92       	push	r0
    197c:	0b b6       	in	r0, 0x3b	; 59
    197e:	0f 92       	push	r0
    1980:	11 24       	eor	r1, r1
    1982:	2f 93       	push	r18
    1984:	3f 93       	push	r19
    1986:	4f 93       	push	r20
    1988:	5f 93       	push	r21
    198a:	6f 93       	push	r22
    198c:	7f 93       	push	r23
    198e:	8f 93       	push	r24
    1990:	9f 93       	push	r25
    1992:	af 93       	push	r26
    1994:	bf 93       	push	r27
    1996:	ef 93       	push	r30
    1998:	ff 93       	push	r31
	sampleCurrentChannel();
    199a:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
	SPICount = 0;
    199e:	10 92 c6 50 	sts	0x50C6, r1
}
    19a2:	ff 91       	pop	r31
    19a4:	ef 91       	pop	r30
    19a6:	bf 91       	pop	r27
    19a8:	af 91       	pop	r26
    19aa:	9f 91       	pop	r25
    19ac:	8f 91       	pop	r24
    19ae:	7f 91       	pop	r23
    19b0:	6f 91       	pop	r22
    19b2:	5f 91       	pop	r21
    19b4:	4f 91       	pop	r20
    19b6:	3f 91       	pop	r19
    19b8:	2f 91       	pop	r18
    19ba:	0f 90       	pop	r0
    19bc:	0b be       	out	0x3b, r0	; 59
    19be:	0f 90       	pop	r0
    19c0:	0f be       	out	0x3f, r0	; 63
    19c2:	0f 90       	pop	r0
    19c4:	1f 90       	pop	r1
    19c6:	18 95       	reti

000019c8 <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    19c8:	1f 92       	push	r1
    19ca:	0f 92       	push	r0
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	0f 92       	push	r0
    19d0:	0b b6       	in	r0, 0x3b	; 59
    19d2:	0f 92       	push	r0
    19d4:	11 24       	eor	r1, r1
    19d6:	2f 93       	push	r18
    19d8:	3f 93       	push	r19
    19da:	4f 93       	push	r20
    19dc:	5f 93       	push	r21
    19de:	6f 93       	push	r22
    19e0:	7f 93       	push	r23
    19e2:	8f 93       	push	r24
    19e4:	9f 93       	push	r25
    19e6:	af 93       	push	r26
    19e8:	bf 93       	push	r27
    19ea:	ef 93       	push	r30
    19ec:	ff 93       	push	r31
	sampleCurrentChannel();
    19ee:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
}
    19f2:	ff 91       	pop	r31
    19f4:	ef 91       	pop	r30
    19f6:	bf 91       	pop	r27
    19f8:	af 91       	pop	r26
    19fa:	9f 91       	pop	r25
    19fc:	8f 91       	pop	r24
    19fe:	7f 91       	pop	r23
    1a00:	6f 91       	pop	r22
    1a02:	5f 91       	pop	r21
    1a04:	4f 91       	pop	r20
    1a06:	3f 91       	pop	r19
    1a08:	2f 91       	pop	r18
    1a0a:	0f 90       	pop	r0
    1a0c:	0b be       	out	0x3b, r0	; 59
    1a0e:	0f 90       	pop	r0
    1a10:	0f be       	out	0x3f, r0	; 63
    1a12:	0f 90       	pop	r0
    1a14:	1f 90       	pop	r1
    1a16:	18 95       	reti

00001a18 <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    1a18:	1f 92       	push	r1
    1a1a:	0f 92       	push	r0
    1a1c:	0f b6       	in	r0, 0x3f	; 63
    1a1e:	0f 92       	push	r0
    1a20:	0b b6       	in	r0, 0x3b	; 59
    1a22:	0f 92       	push	r0
    1a24:	11 24       	eor	r1, r1
    1a26:	2f 93       	push	r18
    1a28:	3f 93       	push	r19
    1a2a:	4f 93       	push	r20
    1a2c:	5f 93       	push	r21
    1a2e:	6f 93       	push	r22
    1a30:	7f 93       	push	r23
    1a32:	8f 93       	push	r24
    1a34:	9f 93       	push	r25
    1a36:	af 93       	push	r26
    1a38:	bf 93       	push	r27
    1a3a:	ef 93       	push	r30
    1a3c:	ff 93       	push	r31
	sampleCurrentChannel();
    1a3e:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
}
    1a42:	ff 91       	pop	r31
    1a44:	ef 91       	pop	r30
    1a46:	bf 91       	pop	r27
    1a48:	af 91       	pop	r26
    1a4a:	9f 91       	pop	r25
    1a4c:	8f 91       	pop	r24
    1a4e:	7f 91       	pop	r23
    1a50:	6f 91       	pop	r22
    1a52:	5f 91       	pop	r21
    1a54:	4f 91       	pop	r20
    1a56:	3f 91       	pop	r19
    1a58:	2f 91       	pop	r18
    1a5a:	0f 90       	pop	r0
    1a5c:	0b be       	out	0x3b, r0	; 59
    1a5e:	0f 90       	pop	r0
    1a60:	0f be       	out	0x3f, r0	; 63
    1a62:	0f 90       	pop	r0
    1a64:	1f 90       	pop	r1
    1a66:	18 95       	reti

00001a68 <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    1a68:	1f 92       	push	r1
    1a6a:	0f 92       	push	r0
    1a6c:	0f b6       	in	r0, 0x3f	; 63
    1a6e:	0f 92       	push	r0
    1a70:	0b b6       	in	r0, 0x3b	; 59
    1a72:	0f 92       	push	r0
    1a74:	11 24       	eor	r1, r1
    1a76:	2f 93       	push	r18
    1a78:	3f 93       	push	r19
    1a7a:	4f 93       	push	r20
    1a7c:	5f 93       	push	r21
    1a7e:	6f 93       	push	r22
    1a80:	7f 93       	push	r23
    1a82:	8f 93       	push	r24
    1a84:	9f 93       	push	r25
    1a86:	af 93       	push	r26
    1a88:	bf 93       	push	r27
    1a8a:	ef 93       	push	r30
    1a8c:	ff 93       	push	r31
	sampleCurrentChannel();
    1a8e:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
}
    1a92:	ff 91       	pop	r31
    1a94:	ef 91       	pop	r30
    1a96:	bf 91       	pop	r27
    1a98:	af 91       	pop	r26
    1a9a:	9f 91       	pop	r25
    1a9c:	8f 91       	pop	r24
    1a9e:	7f 91       	pop	r23
    1aa0:	6f 91       	pop	r22
    1aa2:	5f 91       	pop	r21
    1aa4:	4f 91       	pop	r20
    1aa6:	3f 91       	pop	r19
    1aa8:	2f 91       	pop	r18
    1aaa:	0f 90       	pop	r0
    1aac:	0b be       	out	0x3b, r0	; 59
    1aae:	0f 90       	pop	r0
    1ab0:	0f be       	out	0x3f, r0	; 63
    1ab2:	0f 90       	pop	r0
    1ab4:	1f 90       	pop	r1
    1ab6:	18 95       	reti

00001ab8 <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    1ab8:	1f 92       	push	r1
    1aba:	0f 92       	push	r0
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	0f 92       	push	r0
    1ac0:	0b b6       	in	r0, 0x3b	; 59
    1ac2:	0f 92       	push	r0
    1ac4:	11 24       	eor	r1, r1
    1ac6:	2f 93       	push	r18
    1ac8:	3f 93       	push	r19
    1aca:	4f 93       	push	r20
    1acc:	5f 93       	push	r21
    1ace:	6f 93       	push	r22
    1ad0:	7f 93       	push	r23
    1ad2:	8f 93       	push	r24
    1ad4:	9f 93       	push	r25
    1ad6:	af 93       	push	r26
    1ad8:	bf 93       	push	r27
    1ada:	ef 93       	push	r30
    1adc:	ff 93       	push	r31
	sampleCurrentChannel();
    1ade:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
	SPICount = 0;
    1ae2:	10 92 c6 50 	sts	0x50C6, r1
	if(PORTB.OUT & PIN1_bm) {
    1ae6:	e0 e2       	ldi	r30, 0x20	; 32
    1ae8:	f6 e0       	ldi	r31, 0x06	; 6
    1aea:	84 81       	ldd	r24, Z+4	; 0x04
    1aec:	81 ff       	sbrs	r24, 1
    1aee:	0f c0       	rjmp	.+30     	; 0x1b0e <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    1af0:	e0 e0       	ldi	r30, 0x00	; 0
    1af2:	f6 e0       	ldi	r31, 0x06	; 6
    1af4:	84 81       	ldd	r24, Z+4	; 0x04
    1af6:	86 ff       	sbrs	r24, 6
    1af8:	05 c0       	rjmp	.+10     	; 0x1b04 <__vector_19+0x4c>
    1afa:	82 e0       	ldi	r24, 0x02	; 2
    1afc:	e0 e2       	ldi	r30, 0x20	; 32
    1afe:	f6 e0       	ldi	r31, 0x06	; 6
    1b00:	87 83       	std	Z+7, r24	; 0x07
    1b02:	0d c0       	rjmp	.+26     	; 0x1b1e <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    1b04:	80 e4       	ldi	r24, 0x40	; 64
    1b06:	e0 e0       	ldi	r30, 0x00	; 0
    1b08:	f6 e0       	ldi	r31, 0x06	; 6
    1b0a:	87 83       	std	Z+7, r24	; 0x07
    1b0c:	08 c0       	rjmp	.+16     	; 0x1b1e <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    1b0e:	80 e4       	ldi	r24, 0x40	; 64
    1b10:	e0 e0       	ldi	r30, 0x00	; 0
    1b12:	f6 e0       	ldi	r31, 0x06	; 6
    1b14:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    1b16:	82 e0       	ldi	r24, 0x02	; 2
    1b18:	e0 e2       	ldi	r30, 0x20	; 32
    1b1a:	f6 e0       	ldi	r31, 0x06	; 6
    1b1c:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    1b1e:	ff 91       	pop	r31
    1b20:	ef 91       	pop	r30
    1b22:	bf 91       	pop	r27
    1b24:	af 91       	pop	r26
    1b26:	9f 91       	pop	r25
    1b28:	8f 91       	pop	r24
    1b2a:	7f 91       	pop	r23
    1b2c:	6f 91       	pop	r22
    1b2e:	5f 91       	pop	r21
    1b30:	4f 91       	pop	r20
    1b32:	3f 91       	pop	r19
    1b34:	2f 91       	pop	r18
    1b36:	0f 90       	pop	r0
    1b38:	0b be       	out	0x3b, r0	; 59
    1b3a:	0f 90       	pop	r0
    1b3c:	0f be       	out	0x3f, r0	; 63
    1b3e:	0f 90       	pop	r0
    1b40:	1f 90       	pop	r1
    1b42:	18 95       	reti

00001b44 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    1b44:	1f 92       	push	r1
    1b46:	0f 92       	push	r0
    1b48:	0f b6       	in	r0, 0x3f	; 63
    1b4a:	0f 92       	push	r0
    1b4c:	0b b6       	in	r0, 0x3b	; 59
    1b4e:	0f 92       	push	r0
    1b50:	11 24       	eor	r1, r1
    1b52:	2f 93       	push	r18
    1b54:	3f 93       	push	r19
    1b56:	4f 93       	push	r20
    1b58:	5f 93       	push	r21
    1b5a:	6f 93       	push	r22
    1b5c:	7f 93       	push	r23
    1b5e:	8f 93       	push	r24
    1b60:	9f 93       	push	r25
    1b62:	af 93       	push	r26
    1b64:	bf 93       	push	r27
    1b66:	ef 93       	push	r30
    1b68:	ff 93       	push	r31
	sampleCurrentChannel();
    1b6a:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
}
    1b6e:	ff 91       	pop	r31
    1b70:	ef 91       	pop	r30
    1b72:	bf 91       	pop	r27
    1b74:	af 91       	pop	r26
    1b76:	9f 91       	pop	r25
    1b78:	8f 91       	pop	r24
    1b7a:	7f 91       	pop	r23
    1b7c:	6f 91       	pop	r22
    1b7e:	5f 91       	pop	r21
    1b80:	4f 91       	pop	r20
    1b82:	3f 91       	pop	r19
    1b84:	2f 91       	pop	r18
    1b86:	0f 90       	pop	r0
    1b88:	0b be       	out	0x3b, r0	; 59
    1b8a:	0f 90       	pop	r0
    1b8c:	0f be       	out	0x3f, r0	; 63
    1b8e:	0f 90       	pop	r0
    1b90:	1f 90       	pop	r1
    1b92:	18 95       	reti

00001b94 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    1b94:	1f 92       	push	r1
    1b96:	0f 92       	push	r0
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	0f 92       	push	r0
    1b9c:	0b b6       	in	r0, 0x3b	; 59
    1b9e:	0f 92       	push	r0
    1ba0:	11 24       	eor	r1, r1
    1ba2:	2f 93       	push	r18
    1ba4:	3f 93       	push	r19
    1ba6:	4f 93       	push	r20
    1ba8:	5f 93       	push	r21
    1baa:	6f 93       	push	r22
    1bac:	7f 93       	push	r23
    1bae:	8f 93       	push	r24
    1bb0:	9f 93       	push	r25
    1bb2:	af 93       	push	r26
    1bb4:	bf 93       	push	r27
    1bb6:	ef 93       	push	r30
    1bb8:	ff 93       	push	r31
	sampleCurrentChannel();
    1bba:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
}
    1bbe:	ff 91       	pop	r31
    1bc0:	ef 91       	pop	r30
    1bc2:	bf 91       	pop	r27
    1bc4:	af 91       	pop	r26
    1bc6:	9f 91       	pop	r25
    1bc8:	8f 91       	pop	r24
    1bca:	7f 91       	pop	r23
    1bcc:	6f 91       	pop	r22
    1bce:	5f 91       	pop	r21
    1bd0:	4f 91       	pop	r20
    1bd2:	3f 91       	pop	r19
    1bd4:	2f 91       	pop	r18
    1bd6:	0f 90       	pop	r0
    1bd8:	0b be       	out	0x3b, r0	; 59
    1bda:	0f 90       	pop	r0
    1bdc:	0f be       	out	0x3f, r0	; 63
    1bde:	0f 90       	pop	r0
    1be0:	1f 90       	pop	r1
    1be2:	18 95       	reti

00001be4 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    1be4:	1f 92       	push	r1
    1be6:	0f 92       	push	r0
    1be8:	0f b6       	in	r0, 0x3f	; 63
    1bea:	0f 92       	push	r0
    1bec:	0b b6       	in	r0, 0x3b	; 59
    1bee:	0f 92       	push	r0
    1bf0:	11 24       	eor	r1, r1
    1bf2:	2f 93       	push	r18
    1bf4:	3f 93       	push	r19
    1bf6:	4f 93       	push	r20
    1bf8:	5f 93       	push	r21
    1bfa:	6f 93       	push	r22
    1bfc:	7f 93       	push	r23
    1bfe:	8f 93       	push	r24
    1c00:	9f 93       	push	r25
    1c02:	af 93       	push	r26
    1c04:	bf 93       	push	r27
    1c06:	ef 93       	push	r30
    1c08:	ff 93       	push	r31
	sampleCurrentChannel();
    1c0a:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <sampleCurrentChannel>
}
    1c0e:	ff 91       	pop	r31
    1c10:	ef 91       	pop	r30
    1c12:	bf 91       	pop	r27
    1c14:	af 91       	pop	r26
    1c16:	9f 91       	pop	r25
    1c18:	8f 91       	pop	r24
    1c1a:	7f 91       	pop	r23
    1c1c:	6f 91       	pop	r22
    1c1e:	5f 91       	pop	r21
    1c20:	4f 91       	pop	r20
    1c22:	3f 91       	pop	r19
    1c24:	2f 91       	pop	r18
    1c26:	0f 90       	pop	r0
    1c28:	0b be       	out	0x3b, r0	; 59
    1c2a:	0f 90       	pop	r0
    1c2c:	0f be       	out	0x3f, r0	; 63
    1c2e:	0f 90       	pop	r0
    1c30:	1f 90       	pop	r1
    1c32:	18 95       	reti

00001c34 <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1c34:	ff 92       	push	r15
    1c36:	0f 93       	push	r16
    1c38:	1f 93       	push	r17
    1c3a:	cf 93       	push	r28
    1c3c:	df 93       	push	r29
    1c3e:	cd b7       	in	r28, 0x3d	; 61
    1c40:	de b7       	in	r29, 0x3e	; 62
    1c42:	28 97       	sbiw	r28, 0x08	; 8
    1c44:	cd bf       	out	0x3d, r28	; 61
    1c46:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1c48:	19 82       	std	Y+1, r1	; 0x01
    1c4a:	1a 82       	std	Y+2, r1	; 0x02
    1c4c:	1b 82       	std	Y+3, r1	; 0x03
    1c4e:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    1c50:	80 91 74 50 	lds	r24, 0x5074
    1c54:	90 91 75 50 	lds	r25, 0x5075
    1c58:	a0 91 76 50 	lds	r26, 0x5076
    1c5c:	b0 91 77 50 	lds	r27, 0x5077
    1c60:	01 96       	adiw	r24, 0x01	; 1
    1c62:	a1 1d       	adc	r26, r1
    1c64:	b1 1d       	adc	r27, r1
    1c66:	80 93 74 50 	sts	0x5074, r24
    1c6a:	90 93 75 50 	sts	0x5075, r25
    1c6e:	a0 93 76 50 	sts	0x5076, r26
    1c72:	b0 93 77 50 	sts	0x5077, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1c76:	80 ed       	ldi	r24, 0xD0	; 208
    1c78:	80 93 c0 08 	sts	0x08C0, r24
    1c7c:	20 e0       	ldi	r18, 0x00	; 0
    1c7e:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1c80:	05 e6       	ldi	r16, 0x65	; 101
    1c82:	10 e5       	ldi	r17, 0x50	; 80
    1c84:	ff 24       	eor	r15, r15
    1c86:	fa 94       	dec	r15
    1c88:	c9 01       	movw	r24, r18
    1c8a:	f8 01       	movw	r30, r16
    1c8c:	e2 0f       	add	r30, r18
    1c8e:	f3 1f       	adc	r31, r19
    1c90:	40 81       	ld	r20, Z
    1c92:	44 23       	and	r20, r20
    1c94:	14 f4       	brge	.+4      	; 0x1c9a <writeSE2FRAM+0x66>
    1c96:	f8 86       	std	Y+8, r15	; 0x08
    1c98:	01 c0       	rjmp	.+2      	; 0x1c9c <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1c9a:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1c9c:	80 0f       	add	r24, r16
    1c9e:	91 1f       	adc	r25, r17
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	80 81       	ld	r24, Z
    1ca4:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1ca6:	f9 01       	movw	r30, r18
    1ca8:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1caa:	e0 0f       	add	r30, r16
    1cac:	f1 1f       	adc	r31, r17
    1cae:	80 81       	ld	r24, Z
    1cb0:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1cb2:	f9 01       	movw	r30, r18
    1cb4:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1cb6:	e0 0f       	add	r30, r16
    1cb8:	f1 1f       	adc	r31, r17
    1cba:	80 81       	ld	r24, Z
    1cbc:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    1cbe:	49 81       	ldd	r20, Y+1	; 0x01
    1cc0:	5a 81       	ldd	r21, Y+2	; 0x02
    1cc2:	6b 81       	ldd	r22, Y+3	; 0x03
    1cc4:	7c 81       	ldd	r23, Y+4	; 0x04
    1cc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cca:	af 81       	ldd	r26, Y+7	; 0x07
    1ccc:	b8 85       	ldd	r27, Y+8	; 0x08
    1cce:	84 0f       	add	r24, r20
    1cd0:	95 1f       	adc	r25, r21
    1cd2:	a6 1f       	adc	r26, r22
    1cd4:	b7 1f       	adc	r27, r23
    1cd6:	89 83       	std	Y+1, r24	; 0x01
    1cd8:	9a 83       	std	Y+2, r25	; 0x02
    1cda:	ab 83       	std	Y+3, r26	; 0x03
    1cdc:	bc 83       	std	Y+4, r27	; 0x04
    1cde:	2d 5f       	subi	r18, 0xFD	; 253
    1ce0:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    1ce2:	2c 30       	cpi	r18, 0x0C	; 12
    1ce4:	31 05       	cpc	r19, r1
    1ce6:	81 f6       	brne	.-96     	; 0x1c88 <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    1ce8:	69 81       	ldd	r22, Y+1	; 0x01
    1cea:	7a 81       	ldd	r23, Y+2	; 0x02
    1cec:	8b 81       	ldd	r24, Y+3	; 0x03
    1cee:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf0:	24 e0       	ldi	r18, 0x04	; 4
    1cf2:	30 e0       	ldi	r19, 0x00	; 0
    1cf4:	40 e0       	ldi	r20, 0x00	; 0
    1cf6:	50 e0       	ldi	r21, 0x00	; 0
    1cf8:	0e 94 22 3b 	call	0x7644	; 0x7644 <__divmodsi4>
    1cfc:	29 83       	std	Y+1, r18	; 0x01
    1cfe:	3a 83       	std	Y+2, r19	; 0x02
    1d00:	4b 83       	std	Y+3, r20	; 0x03
    1d02:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    1d04:	29 81       	ldd	r18, Y+1	; 0x01
    1d06:	87 e6       	ldi	r24, 0x67	; 103
    1d08:	90 e5       	ldi	r25, 0x50	; 80
    1d0a:	20 93 67 50 	sts	0x5067, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    1d0e:	2a 81       	ldd	r18, Y+2	; 0x02
    1d10:	fc 01       	movw	r30, r24
    1d12:	31 97       	sbiw	r30, 0x01	; 1
    1d14:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    1d16:	2b 81       	ldd	r18, Y+3	; 0x03
    1d18:	02 97       	sbiw	r24, 0x02	; 2
    1d1a:	fc 01       	movw	r30, r24
    1d1c:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1d1e:	80 e1       	ldi	r24, 0x10	; 16
    1d20:	e0 e4       	ldi	r30, 0x40	; 64
    1d22:	f6 e0       	ldi	r31, 0x06	; 6
    1d24:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1d26:	88 e0       	ldi	r24, 0x08	; 8
    1d28:	e0 e2       	ldi	r30, 0x20	; 32
    1d2a:	f6 e0       	ldi	r31, 0x06	; 6
    1d2c:	86 83       	std	Z+6, r24	; 0x06
	nop();
    1d2e:	00 00       	nop
	SPIC.DATA = FR_WREN;
    1d30:	86 e0       	ldi	r24, 0x06	; 6
    1d32:	e0 ec       	ldi	r30, 0xC0	; 192
    1d34:	f8 e0       	ldi	r31, 0x08	; 8
    1d36:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d38:	82 81       	ldd	r24, Z+2	; 0x02
    1d3a:	88 23       	and	r24, r24
    1d3c:	ec f7       	brge	.-6      	; 0x1d38 <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    1d3e:	e0 ec       	ldi	r30, 0xC0	; 192
    1d40:	f8 e0       	ldi	r31, 0x08	; 8
    1d42:	83 81       	ldd	r24, Z+3	; 0x03
    1d44:	80 93 71 50 	sts	0x5071, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    1d48:	a0 e2       	ldi	r26, 0x20	; 32
    1d4a:	b6 e0       	ldi	r27, 0x06	; 6
    1d4c:	88 e0       	ldi	r24, 0x08	; 8
    1d4e:	15 96       	adiw	r26, 0x05	; 5
    1d50:	8c 93       	st	X, r24
    1d52:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    1d54:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1d56:	16 96       	adiw	r26, 0x06	; 6
    1d58:	8c 93       	st	X, r24
    1d5a:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    1d5c:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    1d5e:	82 e0       	ldi	r24, 0x02	; 2
    1d60:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d62:	82 81       	ldd	r24, Z+2	; 0x02
    1d64:	88 23       	and	r24, r24
    1d66:	ec f7       	brge	.-6      	; 0x1d62 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    1d68:	e0 ec       	ldi	r30, 0xC0	; 192
    1d6a:	f8 e0       	ldi	r31, 0x08	; 8
    1d6c:	83 81       	ldd	r24, Z+3	; 0x03
    1d6e:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1d72:	80 91 58 40 	lds	r24, 0x4058
    1d76:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d78:	82 81       	ldd	r24, Z+2	; 0x02
    1d7a:	88 23       	and	r24, r24
    1d7c:	ec f7       	brge	.-6      	; 0x1d78 <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    1d7e:	e0 ec       	ldi	r30, 0xC0	; 192
    1d80:	f8 e0       	ldi	r31, 0x08	; 8
    1d82:	83 81       	ldd	r24, Z+3	; 0x03
    1d84:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1d88:	80 91 57 40 	lds	r24, 0x4057
    1d8c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d8e:	82 81       	ldd	r24, Z+2	; 0x02
    1d90:	88 23       	and	r24, r24
    1d92:	ec f7       	brge	.-6      	; 0x1d8e <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    1d94:	e0 ec       	ldi	r30, 0xC0	; 192
    1d96:	f8 e0       	ldi	r31, 0x08	; 8
    1d98:	83 81       	ldd	r24, Z+3	; 0x03
    1d9a:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[0];
    1d9e:	80 91 65 50 	lds	r24, 0x5065
    1da2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1da4:	82 81       	ldd	r24, Z+2	; 0x02
    1da6:	88 23       	and	r24, r24
    1da8:	ec f7       	brge	.-6      	; 0x1da4 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    1daa:	e0 ec       	ldi	r30, 0xC0	; 192
    1dac:	f8 e0       	ldi	r31, 0x08	; 8
    1dae:	83 81       	ldd	r24, Z+3	; 0x03
    1db0:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[1];
    1db4:	80 91 66 50 	lds	r24, 0x5066
    1db8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1dba:	82 81       	ldd	r24, Z+2	; 0x02
    1dbc:	88 23       	and	r24, r24
    1dbe:	ec f7       	brge	.-6      	; 0x1dba <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    1dc0:	e0 ec       	ldi	r30, 0xC0	; 192
    1dc2:	f8 e0       	ldi	r31, 0x08	; 8
    1dc4:	83 81       	ldd	r24, Z+3	; 0x03
    1dc6:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[2];
    1dca:	80 91 67 50 	lds	r24, 0x5067
    1dce:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1dd0:	82 81       	ldd	r24, Z+2	; 0x02
    1dd2:	88 23       	and	r24, r24
    1dd4:	ec f7       	brge	.-6      	; 0x1dd0 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    1dd6:	a0 ec       	ldi	r26, 0xC0	; 192
    1dd8:	b8 e0       	ldi	r27, 0x08	; 8
    1dda:	13 96       	adiw	r26, 0x03	; 3
    1ddc:	8c 91       	ld	r24, X
    1dde:	13 97       	sbiw	r26, 0x03	; 3
    1de0:	80 93 71 50 	sts	0x5071, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    1de4:	88 e0       	ldi	r24, 0x08	; 8
    1de6:	e0 e2       	ldi	r30, 0x20	; 32
    1de8:	f6 e0       	ldi	r31, 0x06	; 6
    1dea:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1dec:	e0 e4       	ldi	r30, 0x40	; 64
    1dee:	f6 e0       	ldi	r31, 0x06	; 6
    1df0:	80 e1       	ldi	r24, 0x10	; 16
    1df2:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1df4:	94 e5       	ldi	r25, 0x54	; 84
    1df6:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1df8:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    1dfa:	80 91 57 40 	lds	r24, 0x4057
    1dfe:	90 91 58 40 	lds	r25, 0x4058
    1e02:	03 96       	adiw	r24, 0x03	; 3
    1e04:	80 93 57 40 	sts	0x4057, r24
    1e08:	90 93 58 40 	sts	0x4058, r25
	checksumADC[0] += SPIBuffer[0];
    1e0c:	80 91 3b 21 	lds	r24, 0x213B
    1e10:	e5 e6       	ldi	r30, 0x65	; 101
    1e12:	f0 e5       	ldi	r31, 0x50	; 80
    1e14:	90 81       	ld	r25, Z
    1e16:	89 0f       	add	r24, r25
    1e18:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[1] += SPIBuffer[1];
    1e1c:	80 91 3c 21 	lds	r24, 0x213C
    1e20:	91 81       	ldd	r25, Z+1	; 0x01
    1e22:	89 0f       	add	r24, r25
    1e24:	80 93 3c 21 	sts	0x213C, r24
	checksumADC[2] += SPIBuffer[2];
    1e28:	80 91 3d 21 	lds	r24, 0x213D
    1e2c:	92 81       	ldd	r25, Z+2	; 0x02
    1e2e:	89 0f       	add	r24, r25
    1e30:	80 93 3d 21 	sts	0x213D, r24
}
    1e34:	28 96       	adiw	r28, 0x08	; 8
    1e36:	cd bf       	out	0x3d, r28	; 61
    1e38:	de bf       	out	0x3e, r29	; 62
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	1f 91       	pop	r17
    1e40:	0f 91       	pop	r16
    1e42:	ff 90       	pop	r15
    1e44:	08 95       	ret

00001e46 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1e46:	2f 92       	push	r2
    1e48:	3f 92       	push	r3
    1e4a:	4f 92       	push	r4
    1e4c:	5f 92       	push	r5
    1e4e:	6f 92       	push	r6
    1e50:	7f 92       	push	r7
    1e52:	8f 92       	push	r8
    1e54:	9f 92       	push	r9
    1e56:	af 92       	push	r10
    1e58:	bf 92       	push	r11
    1e5a:	cf 92       	push	r12
    1e5c:	df 92       	push	r13
    1e5e:	ef 92       	push	r14
    1e60:	ff 92       	push	r15
    1e62:	0f 93       	push	r16
    1e64:	1f 93       	push	r17
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
    1e6a:	00 d0       	rcall	.+0      	; 0x1e6c <calcChecksumFRAM+0x26>
    1e6c:	0f 92       	push	r0
    1e6e:	cd b7       	in	r28, 0x3d	; 61
    1e70:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    1e72:	eb e9       	ldi	r30, 0x9B	; 155
    1e74:	f0 e5       	ldi	r31, 0x50	; 80
    1e76:	10 92 9b 50 	sts	0x509B, r1
    1e7a:	10 92 9c 50 	sts	0x509C, r1
    1e7e:	10 92 9d 50 	sts	0x509D, r1
    1e82:	10 92 9e 50 	sts	0x509E, r1
    1e86:	10 92 9f 50 	sts	0x509F, r1
    1e8a:	10 92 a0 50 	sts	0x50A0, r1
    1e8e:	10 92 a1 50 	sts	0x50A1, r1
    1e92:	10 92 a2 50 	sts	0x50A2, r1
    1e96:	df 01       	movw	r26, r30
    1e98:	18 97       	sbiw	r26, 0x08	; 8
    1e9a:	1c 92       	st	X, r1
    1e9c:	11 96       	adiw	r26, 0x01	; 1
    1e9e:	1c 92       	st	X, r1
    1ea0:	11 97       	sbiw	r26, 0x01	; 1
    1ea2:	12 96       	adiw	r26, 0x02	; 2
    1ea4:	1c 92       	st	X, r1
    1ea6:	12 97       	sbiw	r26, 0x02	; 2
    1ea8:	13 96       	adiw	r26, 0x03	; 3
    1eaa:	1c 92       	st	X, r1
    1eac:	13 97       	sbiw	r26, 0x03	; 3
    1eae:	14 96       	adiw	r26, 0x04	; 4
    1eb0:	1c 92       	st	X, r1
    1eb2:	14 97       	sbiw	r26, 0x04	; 4
    1eb4:	15 96       	adiw	r26, 0x05	; 5
    1eb6:	1c 92       	st	X, r1
    1eb8:	15 97       	sbiw	r26, 0x05	; 5
    1eba:	16 96       	adiw	r26, 0x06	; 6
    1ebc:	1c 92       	st	X, r1
    1ebe:	16 97       	sbiw	r26, 0x06	; 6
    1ec0:	17 96       	adiw	r26, 0x07	; 7
    1ec2:	1c 92       	st	X, r1
    1ec4:	70 97       	sbiw	r30, 0x10	; 16
    1ec6:	10 82       	st	Z, r1
    1ec8:	11 82       	std	Z+1, r1	; 0x01
    1eca:	12 82       	std	Z+2, r1	; 0x02
    1ecc:	13 82       	std	Z+3, r1	; 0x03
    1ece:	14 82       	std	Z+4, r1	; 0x04
    1ed0:	15 82       	std	Z+5, r1	; 0x05
    1ed2:	16 82       	std	Z+6, r1	; 0x06
    1ed4:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    1ed6:	8a e3       	ldi	r24, 0x3A	; 58
    1ed8:	91 e2       	ldi	r25, 0x21	; 33
    1eda:	10 92 3a 21 	sts	0x213A, r1
    1ede:	fc 01       	movw	r30, r24
    1ee0:	31 97       	sbiw	r30, 0x01	; 1
    1ee2:	10 82       	st	Z, r1
    1ee4:	02 97       	sbiw	r24, 0x02	; 2
    1ee6:	dc 01       	movw	r26, r24
    1ee8:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    1eea:	10 92 57 40 	sts	0x4057, r1
    1eee:	10 92 58 40 	sts	0x4058, r1
    1ef2:	e9 e0       	ldi	r30, 0x09	; 9
    1ef4:	f0 e0       	ldi	r31, 0x00	; 0
    1ef6:	e9 83       	std	Y+1, r30	; 0x01
    1ef8:	fa 83       	std	Y+2, r31	; 0x02
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1efa:	99 24       	eor	r9, r9
    1efc:	9a 94       	dec	r9
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    1efe:	0f 2e       	mov	r0, r31
    1f00:	fb e9       	ldi	r31, 0x9B	; 155
    1f02:	ef 2e       	mov	r14, r31
    1f04:	f0 e5       	ldi	r31, 0x50	; 80
    1f06:	ff 2e       	mov	r15, r31
    1f08:	f0 2d       	mov	r31, r0
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    1f0a:	0f 2e       	mov	r0, r31
    1f0c:	f3 e9       	ldi	r31, 0x93	; 147
    1f0e:	cf 2e       	mov	r12, r31
    1f10:	f0 e5       	ldi	r31, 0x50	; 80
    1f12:	df 2e       	mov	r13, r31
    1f14:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1f16:	0f 2e       	mov	r0, r31
    1f18:	fb e8       	ldi	r31, 0x8B	; 139
    1f1a:	af 2e       	mov	r10, r31
    1f1c:	f0 e5       	ldi	r31, 0x50	; 80
    1f1e:	bf 2e       	mov	r11, r31
    1f20:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    1f22:	81 e7       	ldi	r24, 0x71	; 113
    1f24:	9c e1       	ldi	r25, 0x1C	; 28
    1f26:	0e 94 75 1f 	call	0x3eea	; 0x3eea <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    1f2a:	80 91 57 40 	lds	r24, 0x4057
    1f2e:	90 91 58 40 	lds	r25, 0x4058
    1f32:	8f 58       	subi	r24, 0x8F	; 143
    1f34:	93 4e       	sbci	r25, 0xE3	; 227
    1f36:	80 93 57 40 	sts	0x4057, r24
    1f3a:	90 93 58 40 	sts	0x4058, r25
    1f3e:	0f ed       	ldi	r16, 0xDF	; 223
    1f40:	13 e2       	ldi	r17, 0x23	; 35
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1f42:	80 e0       	ldi	r24, 0x00	; 0
    1f44:	90 e0       	ldi	r25, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1f46:	0f 2e       	mov	r0, r31
    1f48:	f9 e0       	ldi	r31, 0x09	; 9
    1f4a:	2f 2e       	mov	r2, r31
    1f4c:	33 24       	eor	r3, r3
    1f4e:	f0 2d       	mov	r31, r0
    1f50:	8b 83       	std	Y+3, r24	; 0x03
    1f52:	9c 83       	std	Y+4, r25	; 0x04
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1f54:	8b 81       	ldd	r24, Y+3	; 0x03
    1f56:	9c 81       	ldd	r25, Y+4	; 0x04
    1f58:	63 e0       	ldi	r22, 0x03	; 3
    1f5a:	70 e0       	ldi	r23, 0x00	; 0
    1f5c:	0e 94 d9 3a 	call	0x75b2	; 0x75b2 <__udivmodhi4>
    1f60:	9c 01       	movw	r18, r24
    1f62:	e8 e3       	ldi	r30, 0x38	; 56
    1f64:	f1 e2       	ldi	r31, 0x21	; 33
    1f66:	e8 0f       	add	r30, r24
    1f68:	f9 1f       	adc	r31, r25
    1f6a:	90 81       	ld	r25, Z
	checksumADC[1] += SPIBuffer[1];
	checksumADC[2] += SPIBuffer[2];
}

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1f6c:	a8 01       	movw	r20, r16
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1f6e:	d8 01       	movw	r26, r16
    1f70:	8c 91       	ld	r24, X
    1f72:	98 0f       	add	r25, r24
    1f74:	90 83       	st	Z, r25
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    1f76:	21 15       	cp	r18, r1
    1f78:	31 05       	cpc	r19, r1
    1f7a:	19 f5       	brne	.+70     	; 0x1fc2 <calcChecksumFRAM+0x17c>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1f7c:	88 23       	and	r24, r24
    1f7e:	6c f4       	brge	.+26     	; 0x1f9a <calcChecksumFRAM+0x154>
    1f80:	e0 91 63 50 	lds	r30, 0x5063
    1f84:	f0 91 64 50 	lds	r31, 0x5064
    1f88:	10 82       	st	Z, r1
    1f8a:	11 82       	std	Z+1, r1	; 0x01
    1f8c:	12 82       	std	Z+2, r1	; 0x02
    1f8e:	93 82       	std	Z+3, r9	; 0x03
    1f90:	94 82       	std	Z+4, r9	; 0x04
    1f92:	95 82       	std	Z+5, r9	; 0x05
    1f94:	96 82       	std	Z+6, r9	; 0x06
    1f96:	97 82       	std	Z+7, r9	; 0x07
    1f98:	0c c0       	rjmp	.+24     	; 0x1fb2 <calcChecksumFRAM+0x16c>
				else *temp64 = 0x0000000000000000;
    1f9a:	e0 91 63 50 	lds	r30, 0x5063
    1f9e:	f0 91 64 50 	lds	r31, 0x5064
    1fa2:	10 82       	st	Z, r1
    1fa4:	11 82       	std	Z+1, r1	; 0x01
    1fa6:	12 82       	std	Z+2, r1	; 0x02
    1fa8:	13 82       	std	Z+3, r1	; 0x03
    1faa:	14 82       	std	Z+4, r1	; 0x04
    1fac:	15 82       	std	Z+5, r1	; 0x05
    1fae:	16 82       	std	Z+6, r1	; 0x06
    1fb0:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    1fb2:	fa 01       	movw	r30, r20
    1fb4:	80 81       	ld	r24, Z
    1fb6:	e0 91 63 50 	lds	r30, 0x5063
    1fba:	f0 91 64 50 	lds	r31, 0x5064
    1fbe:	82 83       	std	Z+2, r24	; 0x02
    1fc0:	10 c0       	rjmp	.+32     	; 0x1fe2 <calcChecksumFRAM+0x19c>
			} else if(k%3 == 1) {
    1fc2:	21 30       	cpi	r18, 0x01	; 1
    1fc4:	31 05       	cpc	r19, r1
    1fc6:	31 f4       	brne	.+12     	; 0x1fd4 <calcChecksumFRAM+0x18e>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    1fc8:	e0 91 63 50 	lds	r30, 0x5063
    1fcc:	f0 91 64 50 	lds	r31, 0x5064
    1fd0:	81 83       	std	Z+1, r24	; 0x01
    1fd2:	07 c0       	rjmp	.+14     	; 0x1fe2 <calcChecksumFRAM+0x19c>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    1fd4:	e0 91 63 50 	lds	r30, 0x5063
    1fd8:	f0 91 64 50 	lds	r31, 0x5064
    1fdc:	d8 01       	movw	r26, r16
    1fde:	8c 91       	ld	r24, X
    1fe0:	80 83       	st	Z, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1fe2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe6:	b1 01       	movw	r22, r2
    1fe8:	0e 94 d9 3a 	call	0x75b2	; 0x75b2 <__udivmodhi4>
    1fec:	82 30       	cpi	r24, 0x02	; 2
    1fee:	91 05       	cpc	r25, r1
    1ff0:	09 f0       	breq	.+2      	; 0x1ff4 <calcChecksumFRAM+0x1ae>
    1ff2:	76 c0       	rjmp	.+236    	; 0x20e0 <calcChecksumFRAM+0x29a>
    1ff4:	f5 01       	movw	r30, r10
    1ff6:	60 81       	ld	r22, Z
    1ff8:	51 81       	ldd	r21, Z+1	; 0x01
    1ffa:	42 81       	ldd	r20, Z+2	; 0x02
    1ffc:	33 81       	ldd	r19, Z+3	; 0x03
    1ffe:	24 81       	ldd	r18, Z+4	; 0x04
    2000:	95 81       	ldd	r25, Z+5	; 0x05
    2002:	86 81       	ldd	r24, Z+6	; 0x06
    2004:	47 80       	ldd	r4, Z+7	; 0x07
    2006:	e0 91 63 50 	lds	r30, 0x5063
    200a:	f0 91 64 50 	lds	r31, 0x5064
    200e:	70 81       	ld	r23, Z
    2010:	a1 81       	ldd	r26, Z+1	; 0x01
    2012:	b2 81       	ldd	r27, Z+2	; 0x02
    2014:	83 80       	ldd	r8, Z+3	; 0x03
    2016:	74 80       	ldd	r7, Z+4	; 0x04
    2018:	65 80       	ldd	r6, Z+5	; 0x05
    201a:	56 80       	ldd	r5, Z+6	; 0x06
    201c:	e7 81       	ldd	r30, Z+7	; 0x07
    201e:	76 0f       	add	r23, r22
    2020:	f1 e0       	ldi	r31, 0x01	; 1
    2022:	76 17       	cp	r23, r22
    2024:	08 f0       	brcs	.+2      	; 0x2028 <calcChecksumFRAM+0x1e2>
    2026:	f0 e0       	ldi	r31, 0x00	; 0
    2028:	a5 0f       	add	r26, r21
    202a:	61 e0       	ldi	r22, 0x01	; 1
    202c:	a5 17       	cp	r26, r21
    202e:	08 f0       	brcs	.+2      	; 0x2032 <calcChecksumFRAM+0x1ec>
    2030:	60 e0       	ldi	r22, 0x00	; 0
    2032:	fa 0f       	add	r31, r26
    2034:	51 e0       	ldi	r21, 0x01	; 1
    2036:	fa 17       	cp	r31, r26
    2038:	08 f0       	brcs	.+2      	; 0x203c <calcChecksumFRAM+0x1f6>
    203a:	50 e0       	ldi	r21, 0x00	; 0
    203c:	65 2b       	or	r22, r21
    203e:	b4 0f       	add	r27, r20
    2040:	51 e0       	ldi	r21, 0x01	; 1
    2042:	b4 17       	cp	r27, r20
    2044:	08 f0       	brcs	.+2      	; 0x2048 <calcChecksumFRAM+0x202>
    2046:	50 e0       	ldi	r21, 0x00	; 0
    2048:	6b 0f       	add	r22, r27
    204a:	41 e0       	ldi	r20, 0x01	; 1
    204c:	6b 17       	cp	r22, r27
    204e:	08 f0       	brcs	.+2      	; 0x2052 <calcChecksumFRAM+0x20c>
    2050:	40 e0       	ldi	r20, 0x00	; 0
    2052:	54 2b       	or	r21, r20
    2054:	83 0e       	add	r8, r19
    2056:	41 e0       	ldi	r20, 0x01	; 1
    2058:	83 16       	cp	r8, r19
    205a:	08 f0       	brcs	.+2      	; 0x205e <calcChecksumFRAM+0x218>
    205c:	40 e0       	ldi	r20, 0x00	; 0
    205e:	58 0d       	add	r21, r8
    2060:	31 e0       	ldi	r19, 0x01	; 1
    2062:	58 15       	cp	r21, r8
    2064:	08 f0       	brcs	.+2      	; 0x2068 <calcChecksumFRAM+0x222>
    2066:	30 e0       	ldi	r19, 0x00	; 0
    2068:	43 2b       	or	r20, r19
    206a:	72 0e       	add	r7, r18
    206c:	31 e0       	ldi	r19, 0x01	; 1
    206e:	72 16       	cp	r7, r18
    2070:	08 f0       	brcs	.+2      	; 0x2074 <calcChecksumFRAM+0x22e>
    2072:	30 e0       	ldi	r19, 0x00	; 0
    2074:	47 0d       	add	r20, r7
    2076:	21 e0       	ldi	r18, 0x01	; 1
    2078:	47 15       	cp	r20, r7
    207a:	08 f0       	brcs	.+2      	; 0x207e <calcChecksumFRAM+0x238>
    207c:	20 e0       	ldi	r18, 0x00	; 0
    207e:	32 2b       	or	r19, r18
    2080:	69 0e       	add	r6, r25
    2082:	21 e0       	ldi	r18, 0x01	; 1
    2084:	69 16       	cp	r6, r25
    2086:	08 f0       	brcs	.+2      	; 0x208a <calcChecksumFRAM+0x244>
    2088:	20 e0       	ldi	r18, 0x00	; 0
    208a:	36 0d       	add	r19, r6
    208c:	91 e0       	ldi	r25, 0x01	; 1
    208e:	36 15       	cp	r19, r6
    2090:	08 f0       	brcs	.+2      	; 0x2094 <calcChecksumFRAM+0x24e>
    2092:	90 e0       	ldi	r25, 0x00	; 0
    2094:	29 2b       	or	r18, r25
    2096:	58 0e       	add	r5, r24
    2098:	91 e0       	ldi	r25, 0x01	; 1
    209a:	58 16       	cp	r5, r24
    209c:	08 f0       	brcs	.+2      	; 0x20a0 <calcChecksumFRAM+0x25a>
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	25 0d       	add	r18, r5
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	25 15       	cp	r18, r5
    20a6:	08 f0       	brcs	.+2      	; 0x20aa <calcChecksumFRAM+0x264>
    20a8:	80 e0       	ldi	r24, 0x00	; 0
    20aa:	98 2b       	or	r25, r24
    20ac:	e4 0d       	add	r30, r4
    20ae:	9e 0f       	add	r25, r30
    20b0:	d5 01       	movw	r26, r10
    20b2:	7c 93       	st	X, r23
    20b4:	11 96       	adiw	r26, 0x01	; 1
    20b6:	fc 93       	st	X, r31
    20b8:	11 97       	sbiw	r26, 0x01	; 1
    20ba:	12 96       	adiw	r26, 0x02	; 2
    20bc:	6c 93       	st	X, r22
    20be:	12 97       	sbiw	r26, 0x02	; 2
    20c0:	13 96       	adiw	r26, 0x03	; 3
    20c2:	5c 93       	st	X, r21
    20c4:	13 97       	sbiw	r26, 0x03	; 3
    20c6:	14 96       	adiw	r26, 0x04	; 4
    20c8:	4c 93       	st	X, r20
    20ca:	14 97       	sbiw	r26, 0x04	; 4
    20cc:	15 96       	adiw	r26, 0x05	; 5
    20ce:	3c 93       	st	X, r19
    20d0:	15 97       	sbiw	r26, 0x05	; 5
    20d2:	16 96       	adiw	r26, 0x06	; 6
    20d4:	2c 93       	st	X, r18
    20d6:	16 97       	sbiw	r26, 0x06	; 6
    20d8:	17 96       	adiw	r26, 0x07	; 7
    20da:	9c 93       	st	X, r25
    20dc:	17 97       	sbiw	r26, 0x07	; 7
    20de:	f3 c0       	rjmp	.+486    	; 0x22c6 <calcChecksumFRAM+0x480>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    20e0:	85 30       	cpi	r24, 0x05	; 5
    20e2:	91 05       	cpc	r25, r1
    20e4:	09 f0       	breq	.+2      	; 0x20e8 <calcChecksumFRAM+0x2a2>
    20e6:	76 c0       	rjmp	.+236    	; 0x21d4 <calcChecksumFRAM+0x38e>
    20e8:	f6 01       	movw	r30, r12
    20ea:	60 81       	ld	r22, Z
    20ec:	51 81       	ldd	r21, Z+1	; 0x01
    20ee:	42 81       	ldd	r20, Z+2	; 0x02
    20f0:	33 81       	ldd	r19, Z+3	; 0x03
    20f2:	24 81       	ldd	r18, Z+4	; 0x04
    20f4:	95 81       	ldd	r25, Z+5	; 0x05
    20f6:	86 81       	ldd	r24, Z+6	; 0x06
    20f8:	47 80       	ldd	r4, Z+7	; 0x07
    20fa:	e0 91 63 50 	lds	r30, 0x5063
    20fe:	f0 91 64 50 	lds	r31, 0x5064
    2102:	70 81       	ld	r23, Z
    2104:	a1 81       	ldd	r26, Z+1	; 0x01
    2106:	b2 81       	ldd	r27, Z+2	; 0x02
    2108:	83 80       	ldd	r8, Z+3	; 0x03
    210a:	74 80       	ldd	r7, Z+4	; 0x04
    210c:	65 80       	ldd	r6, Z+5	; 0x05
    210e:	56 80       	ldd	r5, Z+6	; 0x06
    2110:	e7 81       	ldd	r30, Z+7	; 0x07
    2112:	76 0f       	add	r23, r22
    2114:	f1 e0       	ldi	r31, 0x01	; 1
    2116:	76 17       	cp	r23, r22
    2118:	08 f0       	brcs	.+2      	; 0x211c <calcChecksumFRAM+0x2d6>
    211a:	f0 e0       	ldi	r31, 0x00	; 0
    211c:	a5 0f       	add	r26, r21
    211e:	61 e0       	ldi	r22, 0x01	; 1
    2120:	a5 17       	cp	r26, r21
    2122:	08 f0       	brcs	.+2      	; 0x2126 <calcChecksumFRAM+0x2e0>
    2124:	60 e0       	ldi	r22, 0x00	; 0
    2126:	fa 0f       	add	r31, r26
    2128:	51 e0       	ldi	r21, 0x01	; 1
    212a:	fa 17       	cp	r31, r26
    212c:	08 f0       	brcs	.+2      	; 0x2130 <calcChecksumFRAM+0x2ea>
    212e:	50 e0       	ldi	r21, 0x00	; 0
    2130:	65 2b       	or	r22, r21
    2132:	b4 0f       	add	r27, r20
    2134:	51 e0       	ldi	r21, 0x01	; 1
    2136:	b4 17       	cp	r27, r20
    2138:	08 f0       	brcs	.+2      	; 0x213c <calcChecksumFRAM+0x2f6>
    213a:	50 e0       	ldi	r21, 0x00	; 0
    213c:	6b 0f       	add	r22, r27
    213e:	41 e0       	ldi	r20, 0x01	; 1
    2140:	6b 17       	cp	r22, r27
    2142:	08 f0       	brcs	.+2      	; 0x2146 <calcChecksumFRAM+0x300>
    2144:	40 e0       	ldi	r20, 0x00	; 0
    2146:	54 2b       	or	r21, r20
    2148:	83 0e       	add	r8, r19
    214a:	41 e0       	ldi	r20, 0x01	; 1
    214c:	83 16       	cp	r8, r19
    214e:	08 f0       	brcs	.+2      	; 0x2152 <calcChecksumFRAM+0x30c>
    2150:	40 e0       	ldi	r20, 0x00	; 0
    2152:	58 0d       	add	r21, r8
    2154:	31 e0       	ldi	r19, 0x01	; 1
    2156:	58 15       	cp	r21, r8
    2158:	08 f0       	brcs	.+2      	; 0x215c <calcChecksumFRAM+0x316>
    215a:	30 e0       	ldi	r19, 0x00	; 0
    215c:	43 2b       	or	r20, r19
    215e:	72 0e       	add	r7, r18
    2160:	31 e0       	ldi	r19, 0x01	; 1
    2162:	72 16       	cp	r7, r18
    2164:	08 f0       	brcs	.+2      	; 0x2168 <calcChecksumFRAM+0x322>
    2166:	30 e0       	ldi	r19, 0x00	; 0
    2168:	47 0d       	add	r20, r7
    216a:	21 e0       	ldi	r18, 0x01	; 1
    216c:	47 15       	cp	r20, r7
    216e:	08 f0       	brcs	.+2      	; 0x2172 <calcChecksumFRAM+0x32c>
    2170:	20 e0       	ldi	r18, 0x00	; 0
    2172:	32 2b       	or	r19, r18
    2174:	69 0e       	add	r6, r25
    2176:	21 e0       	ldi	r18, 0x01	; 1
    2178:	69 16       	cp	r6, r25
    217a:	08 f0       	brcs	.+2      	; 0x217e <calcChecksumFRAM+0x338>
    217c:	20 e0       	ldi	r18, 0x00	; 0
    217e:	36 0d       	add	r19, r6
    2180:	91 e0       	ldi	r25, 0x01	; 1
    2182:	36 15       	cp	r19, r6
    2184:	08 f0       	brcs	.+2      	; 0x2188 <calcChecksumFRAM+0x342>
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	29 2b       	or	r18, r25
    218a:	58 0e       	add	r5, r24
    218c:	91 e0       	ldi	r25, 0x01	; 1
    218e:	58 16       	cp	r5, r24
    2190:	08 f0       	brcs	.+2      	; 0x2194 <calcChecksumFRAM+0x34e>
    2192:	90 e0       	ldi	r25, 0x00	; 0
    2194:	25 0d       	add	r18, r5
    2196:	81 e0       	ldi	r24, 0x01	; 1
    2198:	25 15       	cp	r18, r5
    219a:	08 f0       	brcs	.+2      	; 0x219e <calcChecksumFRAM+0x358>
    219c:	80 e0       	ldi	r24, 0x00	; 0
    219e:	98 2b       	or	r25, r24
    21a0:	e4 0d       	add	r30, r4
    21a2:	9e 0f       	add	r25, r30
    21a4:	d6 01       	movw	r26, r12
    21a6:	7c 93       	st	X, r23
    21a8:	11 96       	adiw	r26, 0x01	; 1
    21aa:	fc 93       	st	X, r31
    21ac:	11 97       	sbiw	r26, 0x01	; 1
    21ae:	12 96       	adiw	r26, 0x02	; 2
    21b0:	6c 93       	st	X, r22
    21b2:	12 97       	sbiw	r26, 0x02	; 2
    21b4:	13 96       	adiw	r26, 0x03	; 3
    21b6:	5c 93       	st	X, r21
    21b8:	13 97       	sbiw	r26, 0x03	; 3
    21ba:	14 96       	adiw	r26, 0x04	; 4
    21bc:	4c 93       	st	X, r20
    21be:	14 97       	sbiw	r26, 0x04	; 4
    21c0:	15 96       	adiw	r26, 0x05	; 5
    21c2:	3c 93       	st	X, r19
    21c4:	15 97       	sbiw	r26, 0x05	; 5
    21c6:	16 96       	adiw	r26, 0x06	; 6
    21c8:	2c 93       	st	X, r18
    21ca:	16 97       	sbiw	r26, 0x06	; 6
    21cc:	17 96       	adiw	r26, 0x07	; 7
    21ce:	9c 93       	st	X, r25
    21d0:	17 97       	sbiw	r26, 0x07	; 7
    21d2:	79 c0       	rjmp	.+242    	; 0x22c6 <calcChecksumFRAM+0x480>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    21d4:	88 30       	cpi	r24, 0x08	; 8
    21d6:	91 05       	cpc	r25, r1
    21d8:	09 f0       	breq	.+2      	; 0x21dc <calcChecksumFRAM+0x396>
    21da:	75 c0       	rjmp	.+234    	; 0x22c6 <calcChecksumFRAM+0x480>
    21dc:	f7 01       	movw	r30, r14
    21de:	60 81       	ld	r22, Z
    21e0:	51 81       	ldd	r21, Z+1	; 0x01
    21e2:	42 81       	ldd	r20, Z+2	; 0x02
    21e4:	33 81       	ldd	r19, Z+3	; 0x03
    21e6:	24 81       	ldd	r18, Z+4	; 0x04
    21e8:	95 81       	ldd	r25, Z+5	; 0x05
    21ea:	86 81       	ldd	r24, Z+6	; 0x06
    21ec:	47 80       	ldd	r4, Z+7	; 0x07
    21ee:	e0 91 63 50 	lds	r30, 0x5063
    21f2:	f0 91 64 50 	lds	r31, 0x5064
    21f6:	70 81       	ld	r23, Z
    21f8:	a1 81       	ldd	r26, Z+1	; 0x01
    21fa:	b2 81       	ldd	r27, Z+2	; 0x02
    21fc:	83 80       	ldd	r8, Z+3	; 0x03
    21fe:	74 80       	ldd	r7, Z+4	; 0x04
    2200:	65 80       	ldd	r6, Z+5	; 0x05
    2202:	56 80       	ldd	r5, Z+6	; 0x06
    2204:	e7 81       	ldd	r30, Z+7	; 0x07
    2206:	76 0f       	add	r23, r22
    2208:	f1 e0       	ldi	r31, 0x01	; 1
    220a:	76 17       	cp	r23, r22
    220c:	08 f0       	brcs	.+2      	; 0x2210 <calcChecksumFRAM+0x3ca>
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	a5 0f       	add	r26, r21
    2212:	61 e0       	ldi	r22, 0x01	; 1
    2214:	a5 17       	cp	r26, r21
    2216:	08 f0       	brcs	.+2      	; 0x221a <calcChecksumFRAM+0x3d4>
    2218:	60 e0       	ldi	r22, 0x00	; 0
    221a:	fa 0f       	add	r31, r26
    221c:	51 e0       	ldi	r21, 0x01	; 1
    221e:	fa 17       	cp	r31, r26
    2220:	08 f0       	brcs	.+2      	; 0x2224 <calcChecksumFRAM+0x3de>
    2222:	50 e0       	ldi	r21, 0x00	; 0
    2224:	65 2b       	or	r22, r21
    2226:	b4 0f       	add	r27, r20
    2228:	51 e0       	ldi	r21, 0x01	; 1
    222a:	b4 17       	cp	r27, r20
    222c:	08 f0       	brcs	.+2      	; 0x2230 <calcChecksumFRAM+0x3ea>
    222e:	50 e0       	ldi	r21, 0x00	; 0
    2230:	6b 0f       	add	r22, r27
    2232:	41 e0       	ldi	r20, 0x01	; 1
    2234:	6b 17       	cp	r22, r27
    2236:	08 f0       	brcs	.+2      	; 0x223a <calcChecksumFRAM+0x3f4>
    2238:	40 e0       	ldi	r20, 0x00	; 0
    223a:	54 2b       	or	r21, r20
    223c:	83 0e       	add	r8, r19
    223e:	41 e0       	ldi	r20, 0x01	; 1
    2240:	83 16       	cp	r8, r19
    2242:	08 f0       	brcs	.+2      	; 0x2246 <calcChecksumFRAM+0x400>
    2244:	40 e0       	ldi	r20, 0x00	; 0
    2246:	58 0d       	add	r21, r8
    2248:	31 e0       	ldi	r19, 0x01	; 1
    224a:	58 15       	cp	r21, r8
    224c:	08 f0       	brcs	.+2      	; 0x2250 <calcChecksumFRAM+0x40a>
    224e:	30 e0       	ldi	r19, 0x00	; 0
    2250:	43 2b       	or	r20, r19
    2252:	72 0e       	add	r7, r18
    2254:	31 e0       	ldi	r19, 0x01	; 1
    2256:	72 16       	cp	r7, r18
    2258:	08 f0       	brcs	.+2      	; 0x225c <calcChecksumFRAM+0x416>
    225a:	30 e0       	ldi	r19, 0x00	; 0
    225c:	47 0d       	add	r20, r7
    225e:	21 e0       	ldi	r18, 0x01	; 1
    2260:	47 15       	cp	r20, r7
    2262:	08 f0       	brcs	.+2      	; 0x2266 <calcChecksumFRAM+0x420>
    2264:	20 e0       	ldi	r18, 0x00	; 0
    2266:	32 2b       	or	r19, r18
    2268:	69 0e       	add	r6, r25
    226a:	21 e0       	ldi	r18, 0x01	; 1
    226c:	69 16       	cp	r6, r25
    226e:	08 f0       	brcs	.+2      	; 0x2272 <calcChecksumFRAM+0x42c>
    2270:	20 e0       	ldi	r18, 0x00	; 0
    2272:	36 0d       	add	r19, r6
    2274:	91 e0       	ldi	r25, 0x01	; 1
    2276:	36 15       	cp	r19, r6
    2278:	08 f0       	brcs	.+2      	; 0x227c <calcChecksumFRAM+0x436>
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	29 2b       	or	r18, r25
    227e:	58 0e       	add	r5, r24
    2280:	91 e0       	ldi	r25, 0x01	; 1
    2282:	58 16       	cp	r5, r24
    2284:	08 f0       	brcs	.+2      	; 0x2288 <calcChecksumFRAM+0x442>
    2286:	90 e0       	ldi	r25, 0x00	; 0
    2288:	25 0d       	add	r18, r5
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	25 15       	cp	r18, r5
    228e:	08 f0       	brcs	.+2      	; 0x2292 <calcChecksumFRAM+0x44c>
    2290:	80 e0       	ldi	r24, 0x00	; 0
    2292:	98 2b       	or	r25, r24
    2294:	e4 0d       	add	r30, r4
    2296:	9e 0f       	add	r25, r30
    2298:	d7 01       	movw	r26, r14
    229a:	7c 93       	st	X, r23
    229c:	11 96       	adiw	r26, 0x01	; 1
    229e:	fc 93       	st	X, r31
    22a0:	11 97       	sbiw	r26, 0x01	; 1
    22a2:	12 96       	adiw	r26, 0x02	; 2
    22a4:	6c 93       	st	X, r22
    22a6:	12 97       	sbiw	r26, 0x02	; 2
    22a8:	13 96       	adiw	r26, 0x03	; 3
    22aa:	5c 93       	st	X, r21
    22ac:	13 97       	sbiw	r26, 0x03	; 3
    22ae:	14 96       	adiw	r26, 0x04	; 4
    22b0:	4c 93       	st	X, r20
    22b2:	14 97       	sbiw	r26, 0x04	; 4
    22b4:	15 96       	adiw	r26, 0x05	; 5
    22b6:	3c 93       	st	X, r19
    22b8:	15 97       	sbiw	r26, 0x05	; 5
    22ba:	16 96       	adiw	r26, 0x06	; 6
    22bc:	2c 93       	st	X, r18
    22be:	16 97       	sbiw	r26, 0x06	; 6
    22c0:	17 96       	adiw	r26, 0x07	; 7
    22c2:	9c 93       	st	X, r25
    22c4:	17 97       	sbiw	r26, 0x07	; 7
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	31 96       	adiw	r30, 0x01	; 1
    22cc:	eb 83       	std	Y+3, r30	; 0x03
    22ce:	fc 83       	std	Y+4, r31	; 0x04
    22d0:	0f 5f       	subi	r16, 0xFF	; 255
    22d2:	1f 4f       	sbci	r17, 0xFF	; 255
    22d4:	2c e1       	ldi	r18, 0x1C	; 28
    22d6:	e1 37       	cpi	r30, 0x71	; 113
    22d8:	f2 07       	cpc	r31, r18
    22da:	09 f0       	breq	.+2      	; 0x22de <calcChecksumFRAM+0x498>
    22dc:	3b ce       	rjmp	.-906    	; 0x1f54 <calcChecksumFRAM+0x10e>
    22de:	89 81       	ldd	r24, Y+1	; 0x01
    22e0:	9a 81       	ldd	r25, Y+2	; 0x02
    22e2:	01 97       	sbiw	r24, 0x01	; 1
    22e4:	89 83       	std	Y+1, r24	; 0x01
    22e6:	9a 83       	std	Y+2, r25	; 0x02
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    22e8:	00 97       	sbiw	r24, 0x00	; 0
    22ea:	09 f0       	breq	.+2      	; 0x22ee <calcChecksumFRAM+0x4a8>
    22ec:	1a ce       	rjmp	.-972    	; 0x1f22 <calcChecksumFRAM+0xdc>
			
		}
		
	}
	
}
    22ee:	24 96       	adiw	r28, 0x04	; 4
    22f0:	cd bf       	out	0x3d, r28	; 61
    22f2:	de bf       	out	0x3e, r29	; 62
    22f4:	df 91       	pop	r29
    22f6:	cf 91       	pop	r28
    22f8:	1f 91       	pop	r17
    22fa:	0f 91       	pop	r16
    22fc:	ff 90       	pop	r15
    22fe:	ef 90       	pop	r14
    2300:	df 90       	pop	r13
    2302:	cf 90       	pop	r12
    2304:	bf 90       	pop	r11
    2306:	af 90       	pop	r10
    2308:	9f 90       	pop	r9
    230a:	8f 90       	pop	r8
    230c:	7f 90       	pop	r7
    230e:	6f 90       	pop	r6
    2310:	5f 90       	pop	r5
    2312:	4f 90       	pop	r4
    2314:	3f 90       	pop	r3
    2316:	2f 90       	pop	r2
    2318:	08 95       	ret

0000231a <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    231a:	2f 92       	push	r2
    231c:	3f 92       	push	r3
    231e:	4f 92       	push	r4
    2320:	5f 92       	push	r5
    2322:	6f 92       	push	r6
    2324:	7f 92       	push	r7
    2326:	8f 92       	push	r8
    2328:	9f 92       	push	r9
    232a:	af 92       	push	r10
    232c:	bf 92       	push	r11
    232e:	cf 92       	push	r12
    2330:	df 92       	push	r13
    2332:	ef 92       	push	r14
    2334:	ff 92       	push	r15
    2336:	0f 93       	push	r16
    2338:	1f 93       	push	r17
    233a:	cf 93       	push	r28
    233c:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    233e:	10 92 57 40 	sts	0x4057, r1
    2342:	10 92 58 40 	sts	0x4058, r1
	sampleCount = 0;
    2346:	10 92 74 50 	sts	0x5074, r1
    234a:	10 92 75 50 	sts	0x5075, r1
    234e:	10 92 76 50 	sts	0x5076, r1
    2352:	10 92 77 50 	sts	0x5077, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2356:	8d e3       	ldi	r24, 0x3D	; 61
    2358:	91 e2       	ldi	r25, 0x21	; 33
    235a:	10 92 3d 21 	sts	0x213D, r1
    235e:	fc 01       	movw	r30, r24
    2360:	31 97       	sbiw	r30, 0x01	; 1
    2362:	10 82       	st	Z, r1
    2364:	02 97       	sbiw	r24, 0x02	; 2
    2366:	dc 01       	movw	r26, r24
    2368:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    236a:	81 e0       	ldi	r24, 0x01	; 1
    236c:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    2370:	84 e0       	ldi	r24, 0x04	; 4
    2372:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2376:	80 ed       	ldi	r24, 0xD0	; 208
    2378:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    237c:	8d e0       	ldi	r24, 0x0D	; 13
    237e:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[1] = 0xF3;
    2382:	83 ef       	ldi	r24, 0xF3	; 243
    2384:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[2] = 0x57;
    2388:	87 e5       	ldi	r24, 0x57	; 87
    238a:	80 93 67 50 	sts	0x5067, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    238e:	80 91 74 50 	lds	r24, 0x5074
    2392:	90 91 75 50 	lds	r25, 0x5075
    2396:	a0 91 76 50 	lds	r26, 0x5076
    239a:	b0 91 77 50 	lds	r27, 0x5077
    239e:	83 35       	cpi	r24, 0x53	; 83
    23a0:	e5 e5       	ldi	r30, 0x55	; 85
    23a2:	9e 07       	cpc	r25, r30
    23a4:	e0 e0       	ldi	r30, 0x00	; 0
    23a6:	ae 07       	cpc	r26, r30
    23a8:	e0 e0       	ldi	r30, 0x00	; 0
    23aa:	be 07       	cpc	r27, r30
    23ac:	08 f0       	brcs	.+2      	; 0x23b0 <FRAMWriteKnowns+0x96>
    23ae:	cc c0       	rjmp	.+408    	; 0x2548 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    23b0:	0f 2e       	mov	r0, r31
    23b2:	f0 e4       	ldi	r31, 0x40	; 64
    23b4:	ef 2e       	mov	r14, r31
    23b6:	f6 e0       	ldi	r31, 0x06	; 6
    23b8:	ff 2e       	mov	r15, r31
    23ba:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    23bc:	40 e2       	ldi	r20, 0x20	; 32
    23be:	56 e0       	ldi	r21, 0x06	; 6
    23c0:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    23c2:	e0 ec       	ldi	r30, 0xC0	; 192
    23c4:	f8 e0       	ldi	r31, 0x08	; 8
    23c6:	0f 2e       	mov	r0, r31
    23c8:	f6 e0       	ldi	r31, 0x06	; 6
    23ca:	7f 2e       	mov	r7, r31
    23cc:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    23ce:	c1 e7       	ldi	r28, 0x71	; 113
    23d0:	d0 e5       	ldi	r29, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    23d2:	66 24       	eor	r6, r6
    23d4:	68 94       	set
    23d6:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    23d8:	0f 2e       	mov	r0, r31
    23da:	f7 e5       	ldi	r31, 0x57	; 87
    23dc:	cf 2e       	mov	r12, r31
    23de:	f0 e4       	ldi	r31, 0x40	; 64
    23e0:	df 2e       	mov	r13, r31
    23e2:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    23e4:	8e 01       	movw	r16, r28
    23e6:	0c 50       	subi	r16, 0x0C	; 12
    23e8:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    23ea:	0f 2e       	mov	r0, r31
    23ec:	f5 ef       	ldi	r31, 0xF5	; 245
    23ee:	4f 2e       	mov	r4, r31
    23f0:	ff ef       	ldi	r31, 0xFF	; 255
    23f2:	5f 2e       	mov	r5, r31
    23f4:	f0 2d       	mov	r31, r0
    23f6:	4c 0e       	add	r4, r28
    23f8:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    23fa:	0f 2e       	mov	r0, r31
    23fc:	f6 ef       	ldi	r31, 0xF6	; 246
    23fe:	2f 2e       	mov	r2, r31
    2400:	ff ef       	ldi	r31, 0xFF	; 255
    2402:	3f 2e       	mov	r3, r31
    2404:	f0 2d       	mov	r31, r0
    2406:	2c 0e       	add	r2, r28
    2408:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    240a:	6b e3       	ldi	r22, 0x3B	; 59
    240c:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    240e:	5b 01       	movw	r10, r22
    2410:	08 94       	sec
    2412:	a1 1c       	adc	r10, r1
    2414:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2416:	88 24       	eor	r8, r8
    2418:	99 24       	eor	r9, r9
    241a:	68 94       	set
    241c:	81 f8       	bld	r8, 1
    241e:	86 0e       	add	r8, r22
    2420:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2422:	30 e1       	ldi	r19, 0x10	; 16
    2424:	d7 01       	movw	r26, r14
    2426:	16 96       	adiw	r26, 0x06	; 6
    2428:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    242a:	da 01       	movw	r26, r20
    242c:	16 96       	adiw	r26, 0x06	; 6
    242e:	2c 93       	st	X, r18
    2430:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2432:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2434:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2436:	82 81       	ldd	r24, Z+2	; 0x02
    2438:	88 23       	and	r24, r24
    243a:	ec f7       	brge	.-6      	; 0x2436 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    243c:	83 81       	ldd	r24, Z+3	; 0x03
    243e:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    2440:	da 01       	movw	r26, r20
    2442:	15 96       	adiw	r26, 0x05	; 5
    2444:	2c 93       	st	X, r18
    2446:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2448:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    244a:	16 96       	adiw	r26, 0x06	; 6
    244c:	2c 93       	st	X, r18
    244e:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2450:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2452:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2454:	82 81       	ldd	r24, Z+2	; 0x02
    2456:	88 23       	and	r24, r24
    2458:	ec f7       	brge	.-6      	; 0x2454 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    245a:	83 81       	ldd	r24, Z+3	; 0x03
    245c:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    245e:	d6 01       	movw	r26, r12
    2460:	11 96       	adiw	r26, 0x01	; 1
    2462:	8c 91       	ld	r24, X
    2464:	11 97       	sbiw	r26, 0x01	; 1
    2466:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2468:	82 81       	ldd	r24, Z+2	; 0x02
    246a:	88 23       	and	r24, r24
    246c:	ec f7       	brge	.-6      	; 0x2468 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    246e:	83 81       	ldd	r24, Z+3	; 0x03
    2470:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2472:	d6 01       	movw	r26, r12
    2474:	8c 91       	ld	r24, X
    2476:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2478:	82 81       	ldd	r24, Z+2	; 0x02
    247a:	88 23       	and	r24, r24
    247c:	ec f7       	brge	.-6      	; 0x2478 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    247e:	83 81       	ldd	r24, Z+3	; 0x03
    2480:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2482:	d8 01       	movw	r26, r16
    2484:	8c 91       	ld	r24, X
    2486:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2488:	82 81       	ldd	r24, Z+2	; 0x02
    248a:	88 23       	and	r24, r24
    248c:	ec f7       	brge	.-6      	; 0x2488 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    248e:	83 81       	ldd	r24, Z+3	; 0x03
    2490:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2492:	d2 01       	movw	r26, r4
    2494:	8c 91       	ld	r24, X
    2496:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2498:	82 81       	ldd	r24, Z+2	; 0x02
    249a:	88 23       	and	r24, r24
    249c:	ec f7       	brge	.-6      	; 0x2498 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    249e:	83 81       	ldd	r24, Z+3	; 0x03
    24a0:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    24a2:	d1 01       	movw	r26, r2
    24a4:	8c 91       	ld	r24, X
    24a6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    24a8:	82 81       	ldd	r24, Z+2	; 0x02
    24aa:	88 23       	and	r24, r24
    24ac:	ec f7       	brge	.-6      	; 0x24a8 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    24ae:	83 81       	ldd	r24, Z+3	; 0x03
    24b0:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    24b2:	da 01       	movw	r26, r20
    24b4:	15 96       	adiw	r26, 0x05	; 5
    24b6:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    24b8:	30 e1       	ldi	r19, 0x10	; 16
    24ba:	d7 01       	movw	r26, r14
    24bc:	15 96       	adiw	r26, 0x05	; 5
    24be:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    24c0:	80 91 57 40 	lds	r24, 0x4057
    24c4:	90 91 58 40 	lds	r25, 0x4058
    24c8:	03 96       	adiw	r24, 0x03	; 3
    24ca:	80 93 57 40 	sts	0x4057, r24
    24ce:	90 93 58 40 	sts	0x4058, r25
		checksumADC[0] += SPIBuffer[0];
    24d2:	db 01       	movw	r26, r22
    24d4:	8c 91       	ld	r24, X
    24d6:	d8 01       	movw	r26, r16
    24d8:	9c 91       	ld	r25, X
    24da:	89 0f       	add	r24, r25
    24dc:	db 01       	movw	r26, r22
    24de:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    24e0:	d5 01       	movw	r26, r10
    24e2:	8c 91       	ld	r24, X
    24e4:	a6 e6       	ldi	r26, 0x66	; 102
    24e6:	b0 e5       	ldi	r27, 0x50	; 80
    24e8:	9c 91       	ld	r25, X
    24ea:	89 0f       	add	r24, r25
    24ec:	d5 01       	movw	r26, r10
    24ee:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    24f0:	d4 01       	movw	r26, r8
    24f2:	8c 91       	ld	r24, X
    24f4:	a7 e6       	ldi	r26, 0x67	; 103
    24f6:	b0 e5       	ldi	r27, 0x50	; 80
    24f8:	9c 91       	ld	r25, X
    24fa:	89 0f       	add	r24, r25
    24fc:	d4 01       	movw	r26, r8
    24fe:	8c 93       	st	X, r24
		
		sampleCount++;
    2500:	80 91 74 50 	lds	r24, 0x5074
    2504:	90 91 75 50 	lds	r25, 0x5075
    2508:	a0 91 76 50 	lds	r26, 0x5076
    250c:	b0 91 77 50 	lds	r27, 0x5077
    2510:	01 96       	adiw	r24, 0x01	; 1
    2512:	a1 1d       	adc	r26, r1
    2514:	b1 1d       	adc	r27, r1
    2516:	80 93 74 50 	sts	0x5074, r24
    251a:	90 93 75 50 	sts	0x5075, r25
    251e:	a0 93 76 50 	sts	0x5076, r26
    2522:	b0 93 77 50 	sts	0x5077, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2526:	80 91 74 50 	lds	r24, 0x5074
    252a:	90 91 75 50 	lds	r25, 0x5075
    252e:	a0 91 76 50 	lds	r26, 0x5076
    2532:	b0 91 77 50 	lds	r27, 0x5077
    2536:	83 35       	cpi	r24, 0x53	; 83
    2538:	35 e5       	ldi	r19, 0x55	; 85
    253a:	93 07       	cpc	r25, r19
    253c:	30 e0       	ldi	r19, 0x00	; 0
    253e:	a3 07       	cpc	r26, r19
    2540:	30 e0       	ldi	r19, 0x00	; 0
    2542:	b3 07       	cpc	r27, r19
    2544:	08 f4       	brcc	.+2      	; 0x2548 <FRAMWriteKnowns+0x22e>
    2546:	6d cf       	rjmp	.-294    	; 0x2422 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2548:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	ADCPower(FALSE);
    254c:	80 e0       	ldi	r24, 0x00	; 0
    254e:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
}
    2552:	df 91       	pop	r29
    2554:	cf 91       	pop	r28
    2556:	1f 91       	pop	r17
    2558:	0f 91       	pop	r16
    255a:	ff 90       	pop	r15
    255c:	ef 90       	pop	r14
    255e:	df 90       	pop	r13
    2560:	cf 90       	pop	r12
    2562:	bf 90       	pop	r11
    2564:	af 90       	pop	r10
    2566:	9f 90       	pop	r9
    2568:	8f 90       	pop	r8
    256a:	7f 90       	pop	r7
    256c:	6f 90       	pop	r6
    256e:	5f 90       	pop	r5
    2570:	4f 90       	pop	r4
    2572:	3f 90       	pop	r3
    2574:	2f 90       	pop	r2
    2576:	08 95       	ret

00002578 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2578:	80 ff       	sbrs	r24, 0
    257a:	05 c0       	rjmp	.+10     	; 0x2586 <setADCInput+0xe>
    257c:	20 e4       	ldi	r18, 0x40	; 64
    257e:	e0 e0       	ldi	r30, 0x00	; 0
    2580:	f6 e0       	ldi	r31, 0x06	; 6
    2582:	25 83       	std	Z+5, r18	; 0x05
    2584:	04 c0       	rjmp	.+8      	; 0x258e <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2586:	20 e4       	ldi	r18, 0x40	; 64
    2588:	e0 e0       	ldi	r30, 0x00	; 0
    258a:	f6 e0       	ldi	r31, 0x06	; 6
    258c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    258e:	81 ff       	sbrs	r24, 1
    2590:	05 c0       	rjmp	.+10     	; 0x259c <setADCInput+0x24>
    2592:	22 e0       	ldi	r18, 0x02	; 2
    2594:	e0 e2       	ldi	r30, 0x20	; 32
    2596:	f6 e0       	ldi	r31, 0x06	; 6
    2598:	25 83       	std	Z+5, r18	; 0x05
    259a:	04 c0       	rjmp	.+8      	; 0x25a4 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    259c:	22 e0       	ldi	r18, 0x02	; 2
    259e:	e0 e2       	ldi	r30, 0x20	; 32
    25a0:	f6 e0       	ldi	r31, 0x06	; 6
    25a2:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    25a4:	82 ff       	sbrs	r24, 2
    25a6:	05 c0       	rjmp	.+10     	; 0x25b2 <setADCInput+0x3a>
    25a8:	84 e0       	ldi	r24, 0x04	; 4
    25aa:	e0 e2       	ldi	r30, 0x20	; 32
    25ac:	f6 e0       	ldi	r31, 0x06	; 6
    25ae:	85 83       	std	Z+5, r24	; 0x05
    25b0:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    25b2:	84 e0       	ldi	r24, 0x04	; 4
    25b4:	e0 e2       	ldi	r30, 0x20	; 32
    25b6:	f6 e0       	ldi	r31, 0x06	; 6
    25b8:	86 83       	std	Z+6, r24	; 0x06
    25ba:	08 95       	ret

000025bc <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    25bc:	2f 92       	push	r2
    25be:	3f 92       	push	r3
    25c0:	4f 92       	push	r4
    25c2:	5f 92       	push	r5
    25c4:	7f 92       	push	r7
    25c6:	8f 92       	push	r8
    25c8:	9f 92       	push	r9
    25ca:	af 92       	push	r10
    25cc:	bf 92       	push	r11
    25ce:	cf 92       	push	r12
    25d0:	df 92       	push	r13
    25d2:	ef 92       	push	r14
    25d4:	ff 92       	push	r15
    25d6:	0f 93       	push	r16
    25d8:	1f 93       	push	r17
    25da:	cf 93       	push	r28
    25dc:	df 93       	push	r29
    25de:	cd b7       	in	r28, 0x3d	; 61
    25e0:	de b7       	in	r29, 0x3e	; 62
    25e2:	18 2f       	mov	r17, r24
    25e4:	76 2e       	mov	r7, r22
    25e6:	f4 2e       	mov	r15, r20
    25e8:	19 01       	movw	r2, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER=DataArray;
    25ea:	89 8d       	ldd	r24, Y+25	; 0x19
    25ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    25ee:	80 93 72 50 	sts	0x5072, r24
    25f2:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    25f6:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    25fa:	81 e0       	ldi	r24, 0x01	; 1
    25fc:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2600:	81 2f       	mov	r24, r17
    2602:	6f 2d       	mov	r22, r15
    2604:	0e 94 0b 04 	call	0x816	; 0x816 <set_ampGain>
	set_filter(filterConfig);
    2608:	87 2d       	mov	r24, r7
    260a:	0e 94 44 04 	call	0x888	; 0x888 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    260e:	8e 2d       	mov	r24, r14
    2610:	0e 94 1d 09 	call	0x123a	; 0x123a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2614:	84 e0       	ldi	r24, 0x04	; 4
    2616:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    261a:	84 e5       	ldi	r24, 0x54	; 84
    261c:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2620:	81 e0       	ldi	r24, 0x01	; 1
    2622:	0e 94 71 07 	call	0xee2	; 0xee2 <enableADCMUX>
	setADCInput(channel);
    2626:	81 2f       	mov	r24, r17
    2628:	0e 94 bc 12 	call	0x2578	; 0x2578 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    262c:	e0 ea       	ldi	r30, 0xA0	; 160
    262e:	f6 e0       	ldi	r31, 0x06	; 6
    2630:	22 e0       	ldi	r18, 0x02	; 2
    2632:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2634:	77 24       	eor	r7, r7
    2636:	73 94       	inc	r7
    2638:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    263a:	0f 2e       	mov	r0, r31
    263c:	f0 e8       	ldi	r31, 0x80	; 128
    263e:	4f 2e       	mov	r4, r31
    2640:	f1 e0       	ldi	r31, 0x01	; 1
    2642:	5f 2e       	mov	r5, r31
    2644:	f0 2d       	mov	r31, r0
    2646:	88 e7       	ldi	r24, 0x78	; 120
    2648:	d2 01       	movw	r26, r4
    264a:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    264c:	e0 e0       	ldi	r30, 0x00	; 0
    264e:	f9 e0       	ldi	r31, 0x09	; 9
    2650:	80 ef       	ldi	r24, 0xF0	; 240
    2652:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2654:	c0 a6       	lds	r28, 0xb0
    2656:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2658:	a2 a6       	lds	r26, 0xb2
    265a:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    265c:	84 a6       	lds	r24, 0xb4
    265e:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2660:	8d 89       	ldd	r24, Y+21	; 0x15
    2662:	9e 89       	ldd	r25, Y+22	; 0x16
    2664:	86 a7       	lds	r24, 0x76
    2666:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2668:	80 2f       	mov	r24, r16
    266a:	90 e0       	ldi	r25, 0x00	; 0
    266c:	01 97       	sbiw	r24, 0x01	; 1
    266e:	86 a3       	lds	r24, 0x56
    2670:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2672:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2674:	8f ef       	ldi	r24, 0xFF	; 255
    2676:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2678:	80 81       	ld	r24, Z
    267a:	80 7f       	andi	r24, 0xF0	; 240
    267c:	88 60       	ori	r24, 0x08	; 8
    267e:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2680:	10 92 74 50 	sts	0x5074, r1
    2684:	10 92 75 50 	sts	0x5075, r1
    2688:	10 92 76 50 	sts	0x5076, r1
    268c:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    2690:	10 92 c6 50 	sts	0x50C6, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2694:	e0 ea       	ldi	r30, 0xA0	; 160
    2696:	f0 e0       	ldi	r31, 0x00	; 0
    2698:	82 81       	ldd	r24, Z+2	; 0x02
    269a:	87 60       	ori	r24, 0x07	; 7
    269c:	82 83       	std	Z+2, r24	; 0x02
	sei();
    269e:	78 94       	sei

	SPICS(TRUE);
    26a0:	81 e0       	ldi	r24, 0x01	; 1
    26a2:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    26a6:	80 e2       	ldi	r24, 0x20	; 32
    26a8:	e0 e8       	ldi	r30, 0x80	; 128
    26aa:	f6 e0       	ldi	r31, 0x06	; 6
    26ac:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    26ae:	00 e4       	ldi	r16, 0x40	; 64
    26b0:	1a e0       	ldi	r17, 0x0A	; 10
    26b2:	83 e2       	ldi	r24, 0x23	; 35
    26b4:	f8 01       	movw	r30, r16
    26b6:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    26b8:	61 01       	movw	r12, r2
    26ba:	ee 24       	eor	r14, r14
    26bc:	ff 24       	eor	r15, r15
    26be:	60 e8       	ldi	r22, 0x80	; 128
    26c0:	74 e8       	ldi	r23, 0x84	; 132
    26c2:	8e e1       	ldi	r24, 0x1E	; 30
    26c4:	90 e0       	ldi	r25, 0x00	; 0
    26c6:	a7 01       	movw	r20, r14
    26c8:	96 01       	movw	r18, r12
    26ca:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    26ce:	d8 01       	movw	r26, r16
    26d0:	96 96       	adiw	r26, 0x26	; 38
    26d2:	2d 93       	st	X+, r18
    26d4:	3c 93       	st	X, r19
    26d6:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    26d8:	60 e4       	ldi	r22, 0x40	; 64
    26da:	72 e4       	ldi	r23, 0x42	; 66
    26dc:	8f e0       	ldi	r24, 0x0F	; 15
    26de:	90 e0       	ldi	r25, 0x00	; 0
    26e0:	a7 01       	movw	r20, r14
    26e2:	96 01       	movw	r18, r12
    26e4:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    26e8:	f8 01       	movw	r30, r16
    26ea:	22 af       	sts	0x72, r18
    26ec:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    26ee:	e0 e4       	ldi	r30, 0x40	; 64
    26f0:	f8 e0       	ldi	r31, 0x08	; 8
    26f2:	8f 89       	ldd	r24, Y+23	; 0x17
    26f4:	98 8d       	ldd	r25, Y+24	; 0x18
    26f6:	86 a3       	lds	r24, 0x56
    26f8:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    26fa:	80 ed       	ldi	r24, 0xD0	; 208
    26fc:	d2 01       	movw	r26, r4
    26fe:	11 96       	adiw	r26, 0x01	; 1
    2700:	8c 93       	st	X, r24
    2702:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2704:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2706:	80 81       	ld	r24, Z
    2708:	80 7f       	andi	r24, 0xF0	; 240
    270a:	89 60       	ori	r24, 0x09	; 9
    270c:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    270e:	f8 01       	movw	r30, r16
    2710:	80 81       	ld	r24, Z
    2712:	80 7f       	andi	r24, 0xF0	; 240
    2714:	81 60       	ori	r24, 0x01	; 1
    2716:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2718:	df 91       	pop	r29
    271a:	cf 91       	pop	r28
    271c:	1f 91       	pop	r17
    271e:	0f 91       	pop	r16
    2720:	ff 90       	pop	r15
    2722:	ef 90       	pop	r14
    2724:	df 90       	pop	r13
    2726:	cf 90       	pop	r12
    2728:	bf 90       	pop	r11
    272a:	af 90       	pop	r10
    272c:	9f 90       	pop	r9
    272e:	8f 90       	pop	r8
    2730:	7f 90       	pop	r7
    2732:	5f 90       	pop	r5
    2734:	4f 90       	pop	r4
    2736:	3f 90       	pop	r3
    2738:	2f 90       	pop	r2
    273a:	08 95       	ret

0000273c <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    273c:	2f 92       	push	r2
    273e:	3f 92       	push	r3
    2740:	4f 92       	push	r4
    2742:	5f 92       	push	r5
    2744:	6f 92       	push	r6
    2746:	7f 92       	push	r7
    2748:	8f 92       	push	r8
    274a:	9f 92       	push	r9
    274c:	af 92       	push	r10
    274e:	bf 92       	push	r11
    2750:	cf 92       	push	r12
    2752:	df 92       	push	r13
    2754:	ef 92       	push	r14
    2756:	ff 92       	push	r15
    2758:	0f 93       	push	r16
    275a:	cf 93       	push	r28
    275c:	df 93       	push	r29
    275e:	cd b7       	in	r28, 0x3d	; 61
    2760:	de b7       	in	r29, 0x3e	; 62
    2762:	96 2f       	mov	r25, r22
    2764:	1a 01       	movw	r2, r20
    2766:	52 2f       	mov	r21, r18
    2768:	70 2f       	mov	r23, r16
    276a:	d7 01       	movw	r26, r14
    276c:	36 01       	movw	r6, r12
    276e:	25 01       	movw	r4, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2770:	00 d0       	rcall	.+0      	; 0x2772 <CO_collectSeismic1Channel+0x36>
    2772:	00 d0       	rcall	.+0      	; 0x2774 <CO_collectSeismic1Channel+0x38>
    2774:	2d b7       	in	r18, 0x3d	; 61
    2776:	3e b7       	in	r19, 0x3e	; 62
    2778:	2f 5f       	subi	r18, 0xFF	; 255
    277a:	3f 4f       	sbci	r19, 0xFF	; 255
    277c:	ed b7       	in	r30, 0x3d	; 61
    277e:	fe b7       	in	r31, 0x3e	; 62
    2780:	81 82       	std	Z+1, r8	; 0x01
    2782:	92 82       	std	Z+2, r9	; 0x02
    2784:	8d 88       	ldd	r8, Y+21	; 0x15
    2786:	9e 88       	ldd	r9, Y+22	; 0x16
    2788:	f9 01       	movw	r30, r18
    278a:	82 82       	std	Z+2, r8	; 0x02
    278c:	93 82       	std	Z+3, r9	; 0x03
    278e:	8f 88       	ldd	r8, Y+23	; 0x17
    2790:	98 8c       	ldd	r9, Y+24	; 0x18
    2792:	84 82       	std	Z+4, r8	; 0x04
    2794:	95 82       	std	Z+5, r9	; 0x05
    2796:	64 ec       	ldi	r22, 0xC4	; 196
    2798:	49 2f       	mov	r20, r25
    279a:	91 01       	movw	r18, r2
    279c:	05 2f       	mov	r16, r21
    279e:	e7 2e       	mov	r14, r23
    27a0:	6d 01       	movw	r12, r26
    27a2:	53 01       	movw	r10, r6
    27a4:	42 01       	movw	r8, r4
    27a6:	0e 94 de 12 	call	0x25bc	; 0x25bc <CO_collectSeismic1Channel_ext>
    27aa:	8d b7       	in	r24, 0x3d	; 61
    27ac:	9e b7       	in	r25, 0x3e	; 62
    27ae:	06 96       	adiw	r24, 0x06	; 6
    27b0:	8d bf       	out	0x3d, r24	; 61
    27b2:	9e bf       	out	0x3e, r25	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    27b4:	df 91       	pop	r29
    27b6:	cf 91       	pop	r28
    27b8:	0f 91       	pop	r16
    27ba:	ff 90       	pop	r15
    27bc:	ef 90       	pop	r14
    27be:	df 90       	pop	r13
    27c0:	cf 90       	pop	r12
    27c2:	bf 90       	pop	r11
    27c4:	af 90       	pop	r10
    27c6:	9f 90       	pop	r9
    27c8:	8f 90       	pop	r8
    27ca:	7f 90       	pop	r7
    27cc:	6f 90       	pop	r6
    27ce:	5f 90       	pop	r5
    27d0:	4f 90       	pop	r4
    27d2:	3f 90       	pop	r3
    27d4:	2f 90       	pop	r2
    27d6:	08 95       	ret

000027d8 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    27d8:	2f 92       	push	r2
    27da:	3f 92       	push	r3
    27dc:	5f 92       	push	r5
    27de:	6f 92       	push	r6
    27e0:	7f 92       	push	r7
    27e2:	8f 92       	push	r8
    27e4:	9f 92       	push	r9
    27e6:	af 92       	push	r10
    27e8:	bf 92       	push	r11
    27ea:	cf 92       	push	r12
    27ec:	df 92       	push	r13
    27ee:	ef 92       	push	r14
    27f0:	ff 92       	push	r15
    27f2:	0f 93       	push	r16
    27f4:	1f 93       	push	r17
    27f6:	cf 93       	push	r28
    27f8:	df 93       	push	r29
    27fa:	0f 92       	push	r0
    27fc:	0f 92       	push	r0
    27fe:	cd b7       	in	r28, 0x3d	; 61
    2800:	de b7       	in	r29, 0x3e	; 62
    2802:	18 2f       	mov	r17, r24
    2804:	3b 01       	movw	r6, r22
    2806:	49 83       	std	Y+1, r20	; 0x01
    2808:	5a 83       	std	Y+2, r21	; 0x02
    280a:	52 2e       	mov	r5, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER = DataArray;
    280c:	89 8d       	ldd	r24, Y+25	; 0x19
    280e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2810:	80 93 72 50 	sts	0x5072, r24
    2814:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    2818:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    281c:	81 e0       	ldi	r24, 0x01	; 1
    281e:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2822:	85 e0       	ldi	r24, 0x05	; 5
    2824:	d3 01       	movw	r26, r6
    2826:	6c 91       	ld	r22, X
    2828:	0e 94 0b 04 	call	0x816	; 0x816 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    282c:	86 e0       	ldi	r24, 0x06	; 6
    282e:	f3 01       	movw	r30, r6
    2830:	61 81       	ldd	r22, Z+1	; 0x01
    2832:	0e 94 0b 04 	call	0x816	; 0x816 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2836:	87 e0       	ldi	r24, 0x07	; 7
    2838:	d3 01       	movw	r26, r6
    283a:	12 96       	adiw	r26, 0x02	; 2
    283c:	6c 91       	ld	r22, X
    283e:	0e 94 0b 04 	call	0x816	; 0x816 <set_ampGain>
	set_filter(filterConfig);
    2842:	81 2f       	mov	r24, r17
    2844:	0e 94 44 04 	call	0x888	; 0x888 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2848:	80 2f       	mov	r24, r16
    284a:	0e 94 1d 09 	call	0x123a	; 0x123a <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    284e:	84 e0       	ldi	r24, 0x04	; 4
    2850:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2854:	84 e5       	ldi	r24, 0x54	; 84
    2856:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	0e 94 71 07 	call	0xee2	; 0xee2 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2860:	85 e0       	ldi	r24, 0x05	; 5
    2862:	0e 94 bc 12 	call	0x2578	; 0x2578 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2866:	e0 ea       	ldi	r30, 0xA0	; 160
    2868:	f6 e0       	ldi	r31, 0x06	; 6
    286a:	22 e0       	ldi	r18, 0x02	; 2
    286c:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    286e:	66 24       	eor	r6, r6
    2870:	63 94       	inc	r6
    2872:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2874:	0f 2e       	mov	r0, r31
    2876:	f0 e8       	ldi	r31, 0x80	; 128
    2878:	2f 2e       	mov	r2, r31
    287a:	f1 e0       	ldi	r31, 0x01	; 1
    287c:	3f 2e       	mov	r3, r31
    287e:	f0 2d       	mov	r31, r0
    2880:	88 e7       	ldi	r24, 0x78	; 120
    2882:	f1 01       	movw	r30, r2
    2884:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2886:	e0 e0       	ldi	r30, 0x00	; 0
    2888:	f8 e0       	ldi	r31, 0x08	; 8
    288a:	80 ef       	ldi	r24, 0xF0	; 240
    288c:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    288e:	e0 a6       	lds	r30, 0xb0
    2890:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2892:	c2 a6       	lds	r28, 0xb2
    2894:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2896:	a4 a6       	lds	r26, 0xb4
    2898:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    289a:	86 a6       	lds	r24, 0xb6
    289c:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    289e:	85 2d       	mov	r24, r5
    28a0:	90 e0       	ldi	r25, 0x00	; 0
    28a2:	01 97       	sbiw	r24, 0x01	; 1
    28a4:	86 a3       	lds	r24, 0x56
    28a6:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    28a8:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    28aa:	8f ef       	ldi	r24, 0xFF	; 255
    28ac:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    28ae:	80 81       	ld	r24, Z
    28b0:	80 7f       	andi	r24, 0xF0	; 240
    28b2:	88 60       	ori	r24, 0x08	; 8
    28b4:	80 83       	st	Z, r24

	sampleCount = 0;
    28b6:	10 92 74 50 	sts	0x5074, r1
    28ba:	10 92 75 50 	sts	0x5075, r1
    28be:	10 92 76 50 	sts	0x5076, r1
    28c2:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    28c6:	10 92 c6 50 	sts	0x50C6, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    28ca:	8d e3       	ldi	r24, 0x3D	; 61
    28cc:	91 e2       	ldi	r25, 0x21	; 33
    28ce:	10 92 3d 21 	sts	0x213D, r1
    28d2:	fc 01       	movw	r30, r24
    28d4:	31 97       	sbiw	r30, 0x01	; 1
    28d6:	10 82       	st	Z, r1
    28d8:	02 97       	sbiw	r24, 0x02	; 2
    28da:	dc 01       	movw	r26, r24
    28dc:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    28de:	e0 ea       	ldi	r30, 0xA0	; 160
    28e0:	f0 e0       	ldi	r31, 0x00	; 0
    28e2:	82 81       	ldd	r24, Z+2	; 0x02
    28e4:	87 60       	ori	r24, 0x07	; 7
    28e6:	82 83       	std	Z+2, r24	; 0x02
	sei();
    28e8:	78 94       	sei

	SPICS(TRUE);
    28ea:	81 e0       	ldi	r24, 0x01	; 1
    28ec:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    28f0:	80 e2       	ldi	r24, 0x20	; 32
    28f2:	e0 e8       	ldi	r30, 0x80	; 128
    28f4:	f6 e0       	ldi	r31, 0x06	; 6
    28f6:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    28f8:	00 e4       	ldi	r16, 0x40	; 64
    28fa:	1a e0       	ldi	r17, 0x0A	; 10
    28fc:	83 e2       	ldi	r24, 0x23	; 35
    28fe:	f8 01       	movw	r30, r16
    2900:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2902:	89 81       	ldd	r24, Y+1	; 0x01
    2904:	9a 81       	ldd	r25, Y+2	; 0x02
    2906:	6c 01       	movw	r12, r24
    2908:	ee 24       	eor	r14, r14
    290a:	ff 24       	eor	r15, r15
    290c:	60 e8       	ldi	r22, 0x80	; 128
    290e:	74 e8       	ldi	r23, 0x84	; 132
    2910:	8e e1       	ldi	r24, 0x1E	; 30
    2912:	90 e0       	ldi	r25, 0x00	; 0
    2914:	a7 01       	movw	r20, r14
    2916:	96 01       	movw	r18, r12
    2918:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    291c:	d8 01       	movw	r26, r16
    291e:	96 96       	adiw	r26, 0x26	; 38
    2920:	2d 93       	st	X+, r18
    2922:	3c 93       	st	X, r19
    2924:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2926:	60 e4       	ldi	r22, 0x40	; 64
    2928:	72 e4       	ldi	r23, 0x42	; 66
    292a:	8f e0       	ldi	r24, 0x0F	; 15
    292c:	90 e0       	ldi	r25, 0x00	; 0
    292e:	a7 01       	movw	r20, r14
    2930:	96 01       	movw	r18, r12
    2932:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    2936:	f8 01       	movw	r30, r16
    2938:	22 af       	sts	0x72, r18
    293a:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    293c:	e0 e4       	ldi	r30, 0x40	; 64
    293e:	f8 e0       	ldi	r31, 0x08	; 8
    2940:	8f 89       	ldd	r24, Y+23	; 0x17
    2942:	98 8d       	ldd	r25, Y+24	; 0x18
    2944:	86 a3       	lds	r24, 0x56
    2946:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2948:	80 ec       	ldi	r24, 0xC0	; 192
    294a:	d1 01       	movw	r26, r2
    294c:	11 96       	adiw	r26, 0x01	; 1
    294e:	8c 93       	st	X, r24
    2950:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2952:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2954:	80 81       	ld	r24, Z
    2956:	80 7f       	andi	r24, 0xF0	; 240
    2958:	89 60       	ori	r24, 0x09	; 9
    295a:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    295c:	f8 01       	movw	r30, r16
    295e:	80 81       	ld	r24, Z
    2960:	80 7f       	andi	r24, 0xF0	; 240
    2962:	81 60       	ori	r24, 0x01	; 1
    2964:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2966:	0f 90       	pop	r0
    2968:	0f 90       	pop	r0
    296a:	df 91       	pop	r29
    296c:	cf 91       	pop	r28
    296e:	1f 91       	pop	r17
    2970:	0f 91       	pop	r16
    2972:	ff 90       	pop	r15
    2974:	ef 90       	pop	r14
    2976:	df 90       	pop	r13
    2978:	cf 90       	pop	r12
    297a:	bf 90       	pop	r11
    297c:	af 90       	pop	r10
    297e:	9f 90       	pop	r9
    2980:	8f 90       	pop	r8
    2982:	7f 90       	pop	r7
    2984:	6f 90       	pop	r6
    2986:	5f 90       	pop	r5
    2988:	3f 90       	pop	r3
    298a:	2f 90       	pop	r2
    298c:	08 95       	ret

0000298e <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    298e:	2f 92       	push	r2
    2990:	3f 92       	push	r3
    2992:	4f 92       	push	r4
    2994:	5f 92       	push	r5
    2996:	6f 92       	push	r6
    2998:	7f 92       	push	r7
    299a:	8f 92       	push	r8
    299c:	9f 92       	push	r9
    299e:	af 92       	push	r10
    29a0:	bf 92       	push	r11
    29a2:	cf 92       	push	r12
    29a4:	df 92       	push	r13
    29a6:	ef 92       	push	r14
    29a8:	ff 92       	push	r15
    29aa:	0f 93       	push	r16
    29ac:	1f 93       	push	r17
    29ae:	cf 93       	push	r28
    29b0:	df 93       	push	r29
    29b2:	00 d0       	rcall	.+0      	; 0x29b4 <CO_collectSeismic3Axises+0x26>
    29b4:	0f 92       	push	r0
    29b6:	cd b7       	in	r28, 0x3d	; 61
    29b8:	de b7       	in	r29, 0x3e	; 62
    29ba:	8b 83       	std	Y+3, r24	; 0x03
    29bc:	9c 83       	std	Y+4, r25	; 0x04
    29be:	db 01       	movw	r26, r22
    29c0:	94 2f       	mov	r25, r20
    29c2:	32 2f       	mov	r19, r18
    29c4:	38 01       	movw	r6, r16
    29c6:	27 01       	movw	r4, r14
    29c8:	16 01       	movw	r2, r12
    29ca:	a9 82       	std	Y+1, r10	; 0x01
    29cc:	ba 82       	std	Y+2, r11	; 0x02
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    29ce:	00 d0       	rcall	.+0      	; 0x29d0 <CO_collectSeismic3Axises+0x42>
    29d0:	0f 92       	push	r0
    29d2:	ed b7       	in	r30, 0x3d	; 61
    29d4:	fe b7       	in	r31, 0x3e	; 62
    29d6:	81 82       	std	Z+1, r8	; 0x01
    29d8:	92 82       	std	Z+2, r9	; 0x02
    29da:	4a 8d       	ldd	r20, Y+26	; 0x1a
    29dc:	5b 8d       	ldd	r21, Y+27	; 0x1b
    29de:	43 83       	std	Z+3, r20	; 0x03
    29e0:	54 83       	std	Z+4, r21	; 0x04
    29e2:	84 ec       	ldi	r24, 0xC4	; 196
    29e4:	6b 81       	ldd	r22, Y+3	; 0x03
    29e6:	7c 81       	ldd	r23, Y+4	; 0x04
    29e8:	ad 01       	movw	r20, r26
    29ea:	29 2f       	mov	r18, r25
    29ec:	03 2f       	mov	r16, r19
    29ee:	73 01       	movw	r14, r6
    29f0:	62 01       	movw	r12, r4
    29f2:	51 01       	movw	r10, r2
    29f4:	89 80       	ldd	r8, Y+1	; 0x01
    29f6:	9a 80       	ldd	r9, Y+2	; 0x02
    29f8:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <CO_collectSeismic3Axises_ext>
    29fc:	0f 90       	pop	r0
    29fe:	0f 90       	pop	r0
    2a00:	0f 90       	pop	r0
    2a02:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    2a04:	24 96       	adiw	r28, 0x04	; 4
    2a06:	cd bf       	out	0x3d, r28	; 61
    2a08:	de bf       	out	0x3e, r29	; 62
    2a0a:	df 91       	pop	r29
    2a0c:	cf 91       	pop	r28
    2a0e:	1f 91       	pop	r17
    2a10:	0f 91       	pop	r16
    2a12:	ff 90       	pop	r15
    2a14:	ef 90       	pop	r14
    2a16:	df 90       	pop	r13
    2a18:	cf 90       	pop	r12
    2a1a:	bf 90       	pop	r11
    2a1c:	af 90       	pop	r10
    2a1e:	9f 90       	pop	r9
    2a20:	8f 90       	pop	r8
    2a22:	7f 90       	pop	r7
    2a24:	6f 90       	pop	r6
    2a26:	5f 90       	pop	r5
    2a28:	4f 90       	pop	r4
    2a2a:	3f 90       	pop	r3
    2a2c:	2f 90       	pop	r2
    2a2e:	08 95       	ret

00002a30 <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2a30:	8f 92       	push	r8
    2a32:	9f 92       	push	r9
    2a34:	af 92       	push	r10
    2a36:	bf 92       	push	r11
    2a38:	df 92       	push	r13
    2a3a:	ef 92       	push	r14
    2a3c:	ff 92       	push	r15
    2a3e:	0f 93       	push	r16
    2a40:	1f 93       	push	r17
    2a42:	cf 93       	push	r28
    2a44:	df 93       	push	r29
    2a46:	c8 2f       	mov	r28, r24
    2a48:	d6 2e       	mov	r13, r22
    2a4a:	d4 2f       	mov	r29, r20
    2a4c:	59 01       	movw	r10, r18
    2a4e:	48 01       	movw	r8, r16
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif

	uint16_t period;
	ADC_BUFFER = DataArray;
    2a50:	e0 92 72 50 	sts	0x5072, r14
    2a54:	f0 92 73 50 	sts	0x5073, r15
	ADC_Sampling_Finished = 0;
    2a58:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2a5c:	81 e0       	ldi	r24, 0x01	; 1
    2a5e:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    2a62:	8c 2f       	mov	r24, r28
    2a64:	6d 2f       	mov	r22, r29
    2a66:	0e 94 0b 04 	call	0x816	; 0x816 <set_ampGain>
	set_filter(filterConfig);
    2a6a:	8d 2d       	mov	r24, r13
    2a6c:	0e 94 44 04 	call	0x888	; 0x888 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    2a70:	8c 2f       	mov	r24, r28
    2a72:	85 50       	subi	r24, 0x05	; 5
    2a74:	83 30       	cpi	r24, 0x03	; 3
    2a76:	18 f4       	brcc	.+6      	; 0x2a7e <CO_collectADC_ext+0x4e>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	0e 94 1d 09 	call	0x123a	; 0x123a <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2a7e:	81 e0       	ldi	r24, 0x01	; 1
    2a80:	0e 94 71 07 	call	0xee2	; 0xee2 <enableADCMUX>
	setADCInput(channel);
    2a84:	8c 2f       	mov	r24, r28
    2a86:	0e 94 bc 12 	call	0x2578	; 0x2578 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2a8a:	84 e0       	ldi	r24, 0x04	; 4
    2a8c:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2a90:	84 e5       	ldi	r24, 0x54	; 84
    2a92:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2a96:	e0 ea       	ldi	r30, 0xA0	; 160
    2a98:	f6 e0       	ldi	r31, 0x06	; 6
    2a9a:	dd 24       	eor	r13, r13
    2a9c:	d3 94       	inc	r13
    2a9e:	d2 82       	std	Z+2, r13	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2aa0:	82 e0       	ldi	r24, 0x02	; 2
    2aa2:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    2aa4:	d2 86       	std	Z+10, r13	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2aa6:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2aa8:	80 e2       	ldi	r24, 0x20	; 32
    2aaa:	e0 e8       	ldi	r30, 0x80	; 128
    2aac:	f6 e0       	ldi	r31, 0x06	; 6
    2aae:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2ab0:	c0 e4       	ldi	r28, 0x40	; 64
    2ab2:	da e0       	ldi	r29, 0x0A	; 10
    2ab4:	83 e2       	ldi	r24, 0x23	; 35
    2ab6:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2ab8:	95 01       	movw	r18, r10
    2aba:	40 e0       	ldi	r20, 0x00	; 0
    2abc:	50 e0       	ldi	r21, 0x00	; 0
    2abe:	60 e8       	ldi	r22, 0x80	; 128
    2ac0:	74 e8       	ldi	r23, 0x84	; 132
    2ac2:	8e e1       	ldi	r24, 0x1E	; 30
    2ac4:	90 e0       	ldi	r25, 0x00	; 0
    2ac6:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    2aca:	89 01       	movw	r16, r18
    2acc:	9a 01       	movw	r18, r20
    2ace:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    2ad0:	0e a3       	lds	r16, 0x5e
    2ad2:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    2ad4:	96 95       	lsr	r25
    2ad6:	87 95       	ror	r24
    2ad8:	8a af       	sts	0x7a, r24
    2ada:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    2adc:	e0 e4       	ldi	r30, 0x40	; 64
    2ade:	f8 e0       	ldi	r31, 0x08	; 8
    2ae0:	86 a2       	lds	r24, 0x96
    2ae2:	97 a2       	lds	r25, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2ae4:	88 e7       	ldi	r24, 0x78	; 120
    2ae6:	a0 e8       	ldi	r26, 0x80	; 128
    2ae8:	b1 e0       	ldi	r27, 0x01	; 1
    2aea:	11 96       	adiw	r26, 0x01	; 1
    2aec:	8c 93       	st	X, r24
    2aee:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2af0:	d6 82       	std	Z+6, r13	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2af2:	88 81       	ld	r24, Y
    2af4:	80 7f       	andi	r24, 0xF0	; 240
    2af6:	81 60       	ori	r24, 0x01	; 1
    2af8:	88 83       	st	Y, r24
	
	sampleCount = 0;
    2afa:	10 92 74 50 	sts	0x5074, r1
    2afe:	10 92 75 50 	sts	0x5075, r1
    2b02:	10 92 76 50 	sts	0x5076, r1
    2b06:	10 92 77 50 	sts	0x5077, r1
	discardCount = 0;
    2b0a:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2b0e:	e0 ea       	ldi	r30, 0xA0	; 160
    2b10:	f0 e0       	ldi	r31, 0x00	; 0
    2b12:	82 81       	ldd	r24, Z+2	; 0x02
    2b14:	83 60       	ori	r24, 0x03	; 3
    2b16:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2b18:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2b1a:	df 91       	pop	r29
    2b1c:	cf 91       	pop	r28
    2b1e:	1f 91       	pop	r17
    2b20:	0f 91       	pop	r16
    2b22:	ff 90       	pop	r15
    2b24:	ef 90       	pop	r14
    2b26:	df 90       	pop	r13
    2b28:	bf 90       	pop	r11
    2b2a:	af 90       	pop	r10
    2b2c:	9f 90       	pop	r9
    2b2e:	8f 90       	pop	r8
    2b30:	08 95       	ret

00002b32 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2b32:	ef 92       	push	r14
    2b34:	ff 92       	push	r15
    2b36:	0f 93       	push	r16
    2b38:	1f 93       	push	r17
    2b3a:	96 2f       	mov	r25, r22
    2b3c:	fa 01       	movw	r30, r20
    2b3e:	d9 01       	movw	r26, r18
    2b40:	78 01       	movw	r14, r16
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    2b42:	61 ec       	ldi	r22, 0xC1	; 193
    2b44:	49 2f       	mov	r20, r25
    2b46:	9f 01       	movw	r18, r30
    2b48:	8d 01       	movw	r16, r26
    2b4a:	0e 94 18 15 	call	0x2a30	; 0x2a30 <CO_collectADC_ext>
}
    2b4e:	1f 91       	pop	r17
    2b50:	0f 91       	pop	r16
    2b52:	ff 90       	pop	r15
    2b54:	ef 90       	pop	r14
    2b56:	08 95       	ret

00002b58 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2b58:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b5a:	81 e0       	ldi	r24, 0x01	; 1
    2b5c:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2b5e:	84 81       	ldd	r24, Z+4	; 0x04
    2b60:	95 81       	ldd	r25, Z+5	; 0x05
    2b62:	86 1b       	sub	r24, r22
    2b64:	91 09       	sbc	r25, r1

	return answer;
}
    2b66:	08 95       	ret

00002b68 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2b68:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b6a:	81 e0       	ldi	r24, 0x01	; 1
    2b6c:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2b6e:	84 81       	ldd	r24, Z+4	; 0x04
    2b70:	95 81       	ldd	r25, Z+5	; 0x05
    2b72:	77 27       	eor	r23, r23
    2b74:	67 fd       	sbrc	r22, 7
    2b76:	70 95       	com	r23
    2b78:	86 1b       	sub	r24, r22
    2b7a:	97 0b       	sbc	r25, r23

	return answer;
}
    2b7c:	08 95       	ret

00002b7e <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2b7e:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b80:	81 e0       	ldi	r24, 0x01	; 1
    2b82:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    2b84:	84 81       	ldd	r24, Z+4	; 0x04
    2b86:	95 81       	ldd	r25, Z+5	; 0x05
}
    2b88:	08 95       	ret

00002b8a <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2b8a:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b8c:	81 e0       	ldi	r24, 0x01	; 1
    2b8e:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2b90:	84 81       	ldd	r24, Z+4	; 0x04
}
    2b92:	08 95       	ret

00002b94 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    2b94:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b96:	81 e0       	ldi	r24, 0x01	; 1
    2b98:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2b9a:	85 81       	ldd	r24, Z+5	; 0x05
}
    2b9c:	08 95       	ret

00002b9e <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2b9e:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2ba0:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    2ba2:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2ba4:	9a e2       	ldi	r25, 0x2A	; 42
    2ba6:	9a 95       	dec	r25
    2ba8:	f1 f7       	brne	.-4      	; 0x2ba6 <ADC_Wait_8MHz+0x8>
    2baa:	00 c0       	rjmp	.+0      	; 0x2bac <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2bac:	84 83       	std	Z+4, r24	; 0x04
}
    2bae:	08 95       	ret

00002bb0 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2bb0:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2bb2:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    2bb4:	91 e0       	ldi	r25, 0x01	; 1
    2bb6:	94 83       	std	Z+4, r25	; 0x04
    2bb8:	95 e5       	ldi	r25, 0x55	; 85
    2bba:	9a 95       	dec	r25
    2bbc:	f1 f7       	brne	.-4      	; 0x2bba <ADC_Wait_32MHz+0xa>
    2bbe:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2bc0:	84 83       	std	Z+4, r24	; 0x04
}
    2bc2:	08 95       	ret

00002bc4 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2bc4:	ef 92       	push	r14
    2bc6:	ff 92       	push	r15
    2bc8:	0f 93       	push	r16
    2bca:	1f 93       	push	r17
    2bcc:	cf 93       	push	r28
    2bce:	df 93       	push	r29
    2bd0:	eb 01       	movw	r28, r22
    if (oversampling)
    2bd2:	44 23       	and	r20, r20
    2bd4:	c9 f0       	breq	.+50     	; 0x2c08 <ADC_Offset_Get_Unsigned+0x44>
    2bd6:	04 e0       	ldi	r16, 0x04	; 4
    2bd8:	10 e0       	ldi	r17, 0x00	; 0
    2bda:	ee 24       	eor	r14, r14
    2bdc:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2bde:	88 81       	ld	r24, Y
    2be0:	80 68       	ori	r24, 0x80	; 128
    2be2:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2be4:	8b 81       	ldd	r24, Y+3	; 0x03
    2be6:	80 ff       	sbrs	r24, 0
    2be8:	fd cf       	rjmp	.-6      	; 0x2be4 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    2bea:	ce 01       	movw	r24, r28
    2bec:	60 e0       	ldi	r22, 0x00	; 0
    2bee:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <ADC_ResultCh_GetWord_Unsigned>
    2bf2:	e8 0e       	add	r14, r24
    2bf4:	f9 1e       	adc	r15, r25
    2bf6:	01 50       	subi	r16, 0x01	; 1
    2bf8:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    2bfa:	89 f7       	brne	.-30     	; 0x2bde <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    2bfc:	c7 01       	movw	r24, r14
    2bfe:	96 95       	lsr	r25
    2c00:	87 95       	ror	r24
    2c02:	96 95       	lsr	r25
    2c04:	87 95       	ror	r24
    2c06:	09 c0       	rjmp	.+18     	; 0x2c1a <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2c08:	88 81       	ld	r24, Y
    2c0a:	80 68       	ori	r24, 0x80	; 128
    2c0c:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c10:	80 ff       	sbrs	r24, 0
    2c12:	fd cf       	rjmp	.-6      	; 0x2c0e <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    2c14:	ce 01       	movw	r24, r28
    2c16:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    2c1a:	df 91       	pop	r29
    2c1c:	cf 91       	pop	r28
    2c1e:	1f 91       	pop	r17
    2c20:	0f 91       	pop	r16
    2c22:	ff 90       	pop	r15
    2c24:	ef 90       	pop	r14
    2c26:	08 95       	ret

00002c28 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2c28:	ef 92       	push	r14
    2c2a:	ff 92       	push	r15
    2c2c:	0f 93       	push	r16
    2c2e:	1f 93       	push	r17
    2c30:	cf 93       	push	r28
    2c32:	df 93       	push	r29
    2c34:	eb 01       	movw	r28, r22
    if (oversampling)
    2c36:	44 23       	and	r20, r20
    2c38:	e1 f0       	breq	.+56     	; 0x2c72 <ADC_Offset_Get_Signed+0x4a>
    2c3a:	04 e0       	ldi	r16, 0x04	; 4
    2c3c:	10 e0       	ldi	r17, 0x00	; 0
    2c3e:	ee 24       	eor	r14, r14
    2c40:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2c42:	88 81       	ld	r24, Y
    2c44:	80 68       	ori	r24, 0x80	; 128
    2c46:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2c48:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4a:	80 ff       	sbrs	r24, 0
    2c4c:	fd cf       	rjmp	.-6      	; 0x2c48 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2c4e:	ce 01       	movw	r24, r28
    2c50:	60 e0       	ldi	r22, 0x00	; 0
    2c52:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <ADC_ResultCh_GetWord_Signed>
    2c56:	e8 0e       	add	r14, r24
    2c58:	f9 1e       	adc	r15, r25
    2c5a:	01 50       	subi	r16, 0x01	; 1
    2c5c:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2c5e:	89 f7       	brne	.-30     	; 0x2c42 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    2c60:	c7 01       	movw	r24, r14
    2c62:	99 23       	and	r25, r25
    2c64:	0c f4       	brge	.+2      	; 0x2c68 <ADC_Offset_Get_Signed+0x40>
    2c66:	03 96       	adiw	r24, 0x03	; 3
    2c68:	95 95       	asr	r25
    2c6a:	87 95       	ror	r24
    2c6c:	95 95       	asr	r25
    2c6e:	87 95       	ror	r24
    2c70:	0a c0       	rjmp	.+20     	; 0x2c86 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2c72:	88 81       	ld	r24, Y
    2c74:	80 68       	ori	r24, 0x80	; 128
    2c76:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2c78:	8b 81       	ldd	r24, Y+3	; 0x03
    2c7a:	80 ff       	sbrs	r24, 0
    2c7c:	fd cf       	rjmp	.-6      	; 0x2c78 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2c7e:	ce 01       	movw	r24, r28
    2c80:	60 e0       	ldi	r22, 0x00	; 0
    2c82:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    2c86:	df 91       	pop	r29
    2c88:	cf 91       	pop	r28
    2c8a:	1f 91       	pop	r17
    2c8c:	0f 91       	pop	r16
    2c8e:	ff 90       	pop	r15
    2c90:	ef 90       	pop	r14
    2c92:	08 95       	ret

00002c94 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    2c94:	aa ec       	ldi	r26, 0xCA	; 202
    2c96:	b1 e0       	ldi	r27, 0x01	; 1
    2c98:	92 e0       	ldi	r25, 0x02	; 2
    2c9a:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    2c9c:	e8 2f       	mov	r30, r24
    2c9e:	f0 e0       	ldi	r31, 0x00	; 0
    2ca0:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    2ca2:	1c 92       	st	X, r1

	return result;
}
    2ca4:	08 95       	ret

00002ca6 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    2ca6:	cf 93       	push	r28
    2ca8:	df 93       	push	r29
    2caa:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    2cac:	82 e0       	ldi	r24, 0x02	; 2
    2cae:	c0 30       	cpi	r28, 0x00	; 0
    2cb0:	d8 07       	cpc	r29, r24
    2cb2:	59 f4       	brne	.+22     	; 0x2cca <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    2cb4:	80 e2       	ldi	r24, 0x20	; 32
    2cb6:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <SP_ReadCalibrationByte>
    2cba:	c0 e0       	ldi	r28, 0x00	; 0
    2cbc:	d2 e0       	ldi	r29, 0x02	; 2
    2cbe:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    2cc0:	81 e2       	ldi	r24, 0x21	; 33
    2cc2:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <SP_ReadCalibrationByte>
    2cc6:	8d 87       	std	Y+13, r24	; 0x0d
    2cc8:	08 c0       	rjmp	.+16     	; 0x2cda <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    2cca:	84 e2       	ldi	r24, 0x24	; 36
    2ccc:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <SP_ReadCalibrationByte>
    2cd0:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    2cd2:	85 e2       	ldi	r24, 0x25	; 37
    2cd4:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <SP_ReadCalibrationByte>
    2cd8:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    2cda:	df 91       	pop	r29
    2cdc:	cf 91       	pop	r28
    2cde:	08 95       	ret

00002ce0 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    2ce0:	84 e1       	ldi	r24, 0x14	; 20
    2ce2:	ee e3       	ldi	r30, 0x3E	; 62
    2ce4:	f1 e2       	ldi	r31, 0x21	; 33
    2ce6:	df 01       	movw	r26, r30
    2ce8:	1d 92       	st	X+, r1
    2cea:	8a 95       	dec	r24
    2cec:	e9 f7       	brne	.-6      	; 0x2ce8 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    2cee:	0e 94 f4 17 	call	0x2fe8	; 0x2fe8 <chb_get_short_addr>
    2cf2:	80 93 3e 21 	sts	0x213E, r24
    2cf6:	90 93 3f 21 	sts	0x213F, r25
    chb_drvr_init();
    2cfa:	0e 94 46 1a 	call	0x348c	; 0x348c <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    2cfe:	08 95       	ret

00002d00 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    2d00:	e0 e8       	ldi	r30, 0x80	; 128
    2d02:	f6 e0       	ldi	r31, 0x06	; 6
    2d04:	84 e0       	ldi	r24, 0x04	; 4
    2d06:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    2d08:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2d0a:	92 e0       	ldi	r25, 0x02	; 2
    2d0c:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    2d0e:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    2d10:	83 e0       	ldi	r24, 0x03	; 3
    2d12:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    2d14:	e0 ea       	ldi	r30, 0xA0	; 160
    2d16:	f0 e0       	ldi	r31, 0x00	; 0
    2d18:	82 81       	ldd	r24, Z+2	; 0x02
    2d1a:	84 60       	ori	r24, 0x04	; 4
    2d1c:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2d1e:	78 94       	sei
}
    2d20:	08 95       	ret

00002d22 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    2d22:	8e e3       	ldi	r24, 0x3E	; 62
    2d24:	91 e2       	ldi	r25, 0x21	; 33
    2d26:	08 95       	ret

00002d28 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    2d28:	2f 92       	push	r2
    2d2a:	3f 92       	push	r3
    2d2c:	4f 92       	push	r4
    2d2e:	5f 92       	push	r5
    2d30:	6f 92       	push	r6
    2d32:	7f 92       	push	r7
    2d34:	8f 92       	push	r8
    2d36:	9f 92       	push	r9
    2d38:	af 92       	push	r10
    2d3a:	bf 92       	push	r11
    2d3c:	cf 92       	push	r12
    2d3e:	df 92       	push	r13
    2d40:	ef 92       	push	r14
    2d42:	ff 92       	push	r15
    2d44:	0f 93       	push	r16
    2d46:	1f 93       	push	r17
    2d48:	cf 93       	push	r28
    2d4a:	df 93       	push	r29
    2d4c:	cd b7       	in	r28, 0x3d	; 61
    2d4e:	de b7       	in	r29, 0x3e	; 62
    2d50:	2e 97       	sbiw	r28, 0x0e	; 14
    2d52:	cd bf       	out	0x3d, r28	; 61
    2d54:	de bf       	out	0x3e, r29	; 62
    2d56:	8b 87       	std	Y+11, r24	; 0x0b
    2d58:	9c 87       	std	Y+12, r25	; 0x0c
    2d5a:	6d 87       	std	Y+13, r22	; 0x0d
    2d5c:	7e 87       	std	Y+14, r23	; 0x0e
    2d5e:	49 01       	movw	r8, r18
    2d60:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2d62:	21 15       	cp	r18, r1
    2d64:	31 05       	cpc	r19, r1
    2d66:	41 05       	cpc	r20, r1
    2d68:	51 05       	cpc	r21, r1
    2d6a:	09 f4       	brne	.+2      	; 0x2d6e <chb_write+0x46>
    2d6c:	88 c0       	rjmp	.+272    	; 0x2e7e <chb_write+0x156>
{
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    2d6e:	ee 24       	eor	r14, r14
                 pcb.txd_noack++;
				 rtry++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2d70:	0f 2e       	mov	r0, r31
    2d72:	f9 e4       	ldi	r31, 0x49	; 73
    2d74:	6f 2e       	mov	r6, r31
    2d76:	f1 e2       	ldi	r31, 0x21	; 33
    2d78:	7f 2e       	mov	r7, r31
    2d7a:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2d7c:	0f 2e       	mov	r0, r31
    2d7e:	f5 e4       	ldi	r31, 0x45	; 69
    2d80:	4f 2e       	mov	r4, r31
    2d82:	f1 e2       	ldi	r31, 0x21	; 33
    2d84:	5f 2e       	mov	r5, r31
    2d86:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2d88:	0f 2e       	mov	r0, r31
    2d8a:	f7 e4       	ldi	r31, 0x47	; 71
    2d8c:	2f 2e       	mov	r2, r31
    2d8e:	f1 e2       	ldi	r31, 0x21	; 33
    2d90:	3f 2e       	mov	r3, r31
    2d92:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    2d94:	f8 2c       	mov	r15, r8
    2d96:	25 e6       	ldi	r18, 0x65	; 101
    2d98:	82 16       	cp	r8, r18
    2d9a:	91 04       	cpc	r9, r1
    2d9c:	a1 04       	cpc	r10, r1
    2d9e:	b1 04       	cpc	r11, r1
    2da0:	20 f0       	brcs	.+8      	; 0x2daa <chb_write+0x82>
    2da2:	0f 2e       	mov	r0, r31
    2da4:	f4 e6       	ldi	r31, 0x64	; 100
    2da6:	ff 2e       	mov	r15, r31
    2da8:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    2daa:	8f 2d       	mov	r24, r15
    2dac:	85 5f       	subi	r24, 0xF5	; 245
    2dae:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    2db0:	8b 85       	ldd	r24, Y+11	; 0x0b
    2db2:	9c 85       	ldd	r25, Y+12	; 0x0c
    2db4:	ef ef       	ldi	r30, 0xFF	; 255
    2db6:	8f 3f       	cpi	r24, 0xFF	; 255
    2db8:	9e 07       	cpc	r25, r30
    2dba:	11 f0       	breq	.+4      	; 0x2dc0 <chb_write+0x98>
    2dbc:	81 e6       	ldi	r24, 0x61	; 97
    2dbe:	01 c0       	rjmp	.+2      	; 0x2dc2 <chb_write+0x9a>
    2dc0:	81 e4       	ldi	r24, 0x41	; 65
    2dc2:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    2dc4:	88 e9       	ldi	r24, 0x98	; 152
    2dc6:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
    2dc8:	e0 e4       	ldi	r30, 0x40	; 64
    2dca:	f1 e2       	ldi	r31, 0x21	; 33
    2dcc:	80 81       	ld	r24, Z
    2dce:	8c 83       	std	Y+4, r24	; 0x04
    2dd0:	8f 5f       	subi	r24, 0xFF	; 255
    2dd2:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    2dd4:	84 e3       	ldi	r24, 0x34	; 52
    2dd6:	92 e1       	ldi	r25, 0x12	; 18
    2dd8:	8d 83       	std	Y+5, r24	; 0x05
    2dda:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    2ddc:	8b 85       	ldd	r24, Y+11	; 0x0b
    2dde:	9c 85       	ldd	r25, Y+12	; 0x0c
    2de0:	8f 83       	std	Y+7, r24	; 0x07
    2de2:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    2de4:	32 97       	sbiw	r30, 0x02	; 2
    2de6:	80 81       	ld	r24, Z
    2de8:	91 81       	ldd	r25, Z+1	; 0x01
    2dea:	89 87       	std	Y+9, r24	; 0x09
    2dec:	9a 87       	std	Y+10, r25	; 0x0a
        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
    2dee:	00 e0       	ldi	r16, 0x00	; 0
    2df0:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    2df2:	cd 84       	ldd	r12, Y+13	; 0x0d
    2df4:	de 84       	ldd	r13, Y+14	; 0x0e
    2df6:	ce 0c       	add	r12, r14
    2df8:	d1 1c       	adc	r13, r1
    2dfa:	ce 01       	movw	r24, r28
    2dfc:	01 96       	adiw	r24, 0x01	; 1
    2dfe:	b6 01       	movw	r22, r12
    2e00:	4f 2d       	mov	r20, r15
    2e02:	0e 94 82 19 	call	0x3304	; 0x3304 <chb_tx>
    2e06:	28 2f       	mov	r18, r24

             switch (status)
    2e08:	83 30       	cpi	r24, 0x03	; 3
    2e0a:	c9 f0       	breq	.+50     	; 0x2e3e <chb_write+0x116>
    2e0c:	84 30       	cpi	r24, 0x04	; 4
    2e0e:	18 f4       	brcc	.+6      	; 0x2e16 <chb_write+0xee>
    2e10:	81 30       	cpi	r24, 0x01	; 1
    2e12:	e9 f4       	brne	.+58     	; 0x2e4e <chb_write+0x126>
    2e14:	04 c0       	rjmp	.+8      	; 0x2e1e <chb_write+0xf6>
    2e16:	85 30       	cpi	r24, 0x05	; 5
    2e18:	49 f0       	breq	.+18     	; 0x2e2c <chb_write+0x104>
    2e1a:	80 34       	cpi	r24, 0x40	; 64
    2e1c:	c1 f4       	brne	.+48     	; 0x2e4e <chb_write+0x126>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2e1e:	f2 01       	movw	r30, r4
    2e20:	80 81       	ld	r24, Z
    2e22:	91 81       	ldd	r25, Z+1	; 0x01
    2e24:	01 96       	adiw	r24, 0x01	; 1
    2e26:	80 83       	st	Z, r24
    2e28:	91 83       	std	Z+1, r25	; 0x01
                 break;
    2e2a:	11 c0       	rjmp	.+34     	; 0x2e4e <chb_write+0x126>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2e2c:	f1 01       	movw	r30, r2
    2e2e:	80 81       	ld	r24, Z
    2e30:	91 81       	ldd	r25, Z+1	; 0x01
    2e32:	01 96       	adiw	r24, 0x01	; 1
    2e34:	80 83       	st	Z, r24
    2e36:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2e38:	0f 5f       	subi	r16, 0xFF	; 255
    2e3a:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
    2e3c:	08 c0       	rjmp	.+16     	; 0x2e4e <chb_write+0x126>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2e3e:	f3 01       	movw	r30, r6
    2e40:	80 81       	ld	r24, Z
    2e42:	91 81       	ldd	r25, Z+1	; 0x01
    2e44:	01 96       	adiw	r24, 0x01	; 1
    2e46:	80 83       	st	Z, r24
    2e48:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2e4a:	0f 5f       	subi	r16, 0xFF	; 255
    2e4c:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
 
             default:
                 break;
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    2e4e:	10 16       	cp	r1, r16
    2e50:	11 06       	cpc	r1, r17
    2e52:	24 f4       	brge	.+8      	; 0x2e5c <chb_write+0x134>
    2e54:	fa e6       	ldi	r31, 0x6A	; 106
    2e56:	fa 95       	dec	r31
    2e58:	f1 f7       	brne	.-4      	; 0x2e56 <chb_write+0x12e>
    2e5a:	00 c0       	rjmp	.+0      	; 0x2e5c <chb_write+0x134>
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    2e5c:	04 31       	cpi	r16, 0x14	; 20
    2e5e:	11 05       	cpc	r17, r1
    2e60:	79 f0       	breq	.+30     	; 0x2e80 <chb_write+0x158>
		} while(status != CHB_SUCCESS);			
    2e62:	22 23       	and	r18, r18
    2e64:	51 f6       	brne	.-108    	; 0x2dfa <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
    2e66:	ef 0c       	add	r14, r15
        len = len - frm_len;
    2e68:	8f 18       	sub	r8, r15
    2e6a:	91 08       	sbc	r9, r1
    2e6c:	a1 08       	sbc	r10, r1
    2e6e:	b1 08       	sbc	r11, r1
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2e70:	81 14       	cp	r8, r1
    2e72:	91 04       	cpc	r9, r1
    2e74:	a1 04       	cpc	r10, r1
    2e76:	b1 04       	cpc	r11, r1
    2e78:	09 f0       	breq	.+2      	; 0x2e7c <chb_write+0x154>
    2e7a:	8c cf       	rjmp	.-232    	; 0x2d94 <chb_write+0x6c>
    2e7c:	01 c0       	rjmp	.+2      	; 0x2e80 <chb_write+0x158>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_us(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    2e7e:	20 e0       	ldi	r18, 0x00	; 0
}
    2e80:	82 2f       	mov	r24, r18
    2e82:	2e 96       	adiw	r28, 0x0e	; 14
    2e84:	cd bf       	out	0x3d, r28	; 61
    2e86:	de bf       	out	0x3e, r29	; 62
    2e88:	df 91       	pop	r29
    2e8a:	cf 91       	pop	r28
    2e8c:	1f 91       	pop	r17
    2e8e:	0f 91       	pop	r16
    2e90:	ff 90       	pop	r15
    2e92:	ef 90       	pop	r14
    2e94:	df 90       	pop	r13
    2e96:	cf 90       	pop	r12
    2e98:	bf 90       	pop	r11
    2e9a:	af 90       	pop	r10
    2e9c:	9f 90       	pop	r9
    2e9e:	8f 90       	pop	r8
    2ea0:	7f 90       	pop	r7
    2ea2:	6f 90       	pop	r6
    2ea4:	5f 90       	pop	r5
    2ea6:	4f 90       	pop	r4
    2ea8:	3f 90       	pop	r3
    2eaa:	2f 90       	pop	r2
    2eac:	08 95       	ret

00002eae <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    2eae:	df 92       	push	r13
    2eb0:	ef 92       	push	r14
    2eb2:	ff 92       	push	r15
    2eb4:	0f 93       	push	r16
    2eb6:	1f 93       	push	r17
    2eb8:	cf 93       	push	r28
    2eba:	df 93       	push	r29
    2ebc:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    2ebe:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <chb_buf_read>
    2ec2:	d8 2e       	mov	r13, r24
    2ec4:	88 23       	and	r24, r24
    2ec6:	0c f4       	brge	.+2      	; 0x2eca <chb_read+0x1c>
    2ec8:	46 c0       	rjmp	.+140    	; 0x2f56 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    2eca:	f7 01       	movw	r30, r14
    2ecc:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2ece:	88 23       	and	r24, r24
    2ed0:	71 f0       	breq	.+28     	; 0x2eee <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    2ed2:	e7 01       	movw	r28, r14
    2ed4:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    2ed6:	87 01       	movw	r16, r14
    2ed8:	09 5f       	subi	r16, 0xF9	; 249
    2eda:	1f 4f       	sbci	r17, 0xFF	; 255
    2edc:	81 50       	subi	r24, 0x01	; 1
    2ede:	08 0f       	add	r16, r24
    2ee0:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    2ee2:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <chb_buf_read>
    2ee6:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2ee8:	c0 17       	cp	r28, r16
    2eea:	d1 07       	cpc	r29, r17
    2eec:	d1 f7       	brne	.-12     	; 0x2ee2 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    2eee:	f7 01       	movw	r30, r14
    2ef0:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    2ef2:	83 85       	ldd	r24, Z+11	; 0x0b
    2ef4:	94 85       	ldd	r25, Z+12	; 0x0c
    2ef6:	83 83       	std	Z+3, r24	; 0x03
    2ef8:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    2efa:	85 85       	ldd	r24, Z+13	; 0x0d
    2efc:	96 85       	ldd	r25, Z+14	; 0x0e
    2efe:	81 83       	std	Z+1, r24	; 0x01
    2f00:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    2f02:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <chb_buf_get_len>
    2f06:	88 23       	and	r24, r24
    2f08:	11 f4       	brne	.+4      	; 0x2f0e <chb_read+0x60>
    {
        pcb.data_rcv = false;
    2f0a:	10 92 41 21 	sts	0x2141, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    2f0e:	80 91 13 20 	lds	r24, 0x2013
    2f12:	c8 17       	cp	r28, r24
    2f14:	51 f4       	brne	.+20     	; 0x2f2a <chb_read+0x7c>
    2f16:	f7 01       	movw	r30, r14
    2f18:	21 81       	ldd	r18, Z+1	; 0x01
    2f1a:	32 81       	ldd	r19, Z+2	; 0x02
    2f1c:	80 91 14 20 	lds	r24, 0x2014
    2f20:	90 91 15 20 	lds	r25, 0x2015
    2f24:	28 17       	cp	r18, r24
    2f26:	39 07       	cpc	r19, r25
    2f28:	c1 f0       	breq	.+48     	; 0x2f5a <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    2f2a:	c0 93 13 20 	sts	0x2013, r28
        prev_src_addr = rx->src_addr;
    2f2e:	f7 01       	movw	r30, r14
    2f30:	81 81       	ldd	r24, Z+1	; 0x01
    2f32:	92 81       	ldd	r25, Z+2	; 0x02
    2f34:	80 93 14 20 	sts	0x2014, r24
    2f38:	90 93 15 20 	sts	0x2015, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    2f3c:	b7 01       	movw	r22, r14
    2f3e:	61 5f       	subi	r22, 0xF1	; 241
    2f40:	7f 4f       	sbci	r23, 0xFF	; 255
    2f42:	4d 2d       	mov	r20, r13
    2f44:	50 e0       	ldi	r21, 0x00	; 0
    2f46:	49 50       	subi	r20, 0x09	; 9
    2f48:	50 40       	sbci	r21, 0x00	; 0
    2f4a:	c7 01       	movw	r24, r14
    2f4c:	0e 94 75 3b 	call	0x76ea	; 0x76ea <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2f50:	8d 2d       	mov	r24, r13
    2f52:	8b 50       	subi	r24, 0x0B	; 11
    2f54:	03 c0       	rjmp	.+6      	; 0x2f5c <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2f56:	80 e0       	ldi	r24, 0x00	; 0
    2f58:	01 c0       	rjmp	.+2      	; 0x2f5c <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    2f5a:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    2f5c:	df 91       	pop	r29
    2f5e:	cf 91       	pop	r28
    2f60:	1f 91       	pop	r17
    2f62:	0f 91       	pop	r16
    2f64:	ff 90       	pop	r15
    2f66:	ef 90       	pop	r14
    2f68:	df 90       	pop	r13
    2f6a:	08 95       	ret

00002f6c <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    2f6c:	10 92 52 21 	sts	0x2152, r1
    wr_ptr = 0;
    2f70:	10 92 53 21 	sts	0x2153, r1
    len = 0;
    2f74:	10 92 54 21 	sts	0x2154, r1
}
    2f78:	08 95       	ret

00002f7a <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    2f7a:	20 91 53 21 	lds	r18, 0x2153
    2f7e:	30 e0       	ldi	r19, 0x00	; 0
    2f80:	f9 01       	movw	r30, r18
    2f82:	eb 5a       	subi	r30, 0xAB	; 171
    2f84:	fe 4d       	sbci	r31, 0xDE	; 222
    2f86:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2f88:	c9 01       	movw	r24, r18
    2f8a:	01 96       	adiw	r24, 0x01	; 1
    2f8c:	60 e8       	ldi	r22, 0x80	; 128
    2f8e:	70 e0       	ldi	r23, 0x00	; 0
    2f90:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    2f94:	80 93 53 21 	sts	0x2153, r24
    len++;
    2f98:	80 91 54 21 	lds	r24, 0x2154
    2f9c:	8f 5f       	subi	r24, 0xFF	; 255
    2f9e:	80 93 54 21 	sts	0x2154, r24
}
    2fa2:	08 95       	ret

00002fa4 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    2fa4:	20 91 52 21 	lds	r18, 0x2152
    2fa8:	30 e0       	ldi	r19, 0x00	; 0
    2faa:	f9 01       	movw	r30, r18
    2fac:	eb 5a       	subi	r30, 0xAB	; 171
    2fae:	fe 4d       	sbci	r31, 0xDE	; 222
    2fb0:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    2fb2:	2f 5f       	subi	r18, 0xFF	; 255
    2fb4:	3f 4f       	sbci	r19, 0xFF	; 255
    2fb6:	c9 01       	movw	r24, r18
    2fb8:	60 e8       	ldi	r22, 0x80	; 128
    2fba:	70 e0       	ldi	r23, 0x00	; 0
    2fbc:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    2fc0:	80 93 52 21 	sts	0x2152, r24
    len--;
    2fc4:	80 91 54 21 	lds	r24, 0x2154
    2fc8:	81 50       	subi	r24, 0x01	; 1
    2fca:	80 93 54 21 	sts	0x2154, r24
    return data;
}
    2fce:	84 2f       	mov	r24, r20
    2fd0:	08 95       	ret

00002fd2 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    2fd2:	80 91 54 21 	lds	r24, 0x2154
    2fd6:	08 95       	ret

00002fd8 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    2fd8:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    2fda:	80 e0       	ldi	r24, 0x00	; 0
    2fdc:	90 e0       	ldi	r25, 0x00	; 0
    2fde:	48 e0       	ldi	r20, 0x08	; 8
    2fe0:	50 e0       	ldi	r21, 0x00	; 0
    2fe2:	0e 94 55 1c 	call	0x38aa	; 0x38aa <chb_eeprom_read>
}
    2fe6:	08 95       	ret

00002fe8 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    2fe8:	cf 93       	push	r28
    2fea:	df 93       	push	r29
    2fec:	0f 92       	push	r0
    2fee:	0f 92       	push	r0
    2ff0:	cd b7       	in	r28, 0x3d	; 61
    2ff2:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    2ff4:	89 e0       	ldi	r24, 0x09	; 9
    2ff6:	90 e0       	ldi	r25, 0x00	; 0
    2ff8:	be 01       	movw	r22, r28
    2ffa:	6f 5f       	subi	r22, 0xFF	; 255
    2ffc:	7f 4f       	sbci	r23, 0xFF	; 255
    2ffe:	42 e0       	ldi	r20, 0x02	; 2
    3000:	50 e0       	ldi	r21, 0x00	; 0
    3002:	0e 94 55 1c 	call	0x38aa	; 0x38aa <chb_eeprom_read>
    return *(U16 *)addr;
}
    3006:	89 81       	ldd	r24, Y+1	; 0x01
    3008:	9a 81       	ldd	r25, Y+2	; 0x02
    300a:	0f 90       	pop	r0
    300c:	0f 90       	pop	r0
    300e:	df 91       	pop	r29
    3010:	cf 91       	pop	r28
    3012:	08 95       	ret

00003014 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    3014:	88 23       	and	r24, r24
    3016:	29 f0       	breq	.+10     	; 0x3022 <RadioCS+0xe>
    3018:	80 e1       	ldi	r24, 0x10	; 16
    301a:	e0 e6       	ldi	r30, 0x60	; 96
    301c:	f6 e0       	ldi	r31, 0x06	; 6
    301e:	86 83       	std	Z+6, r24	; 0x06
    3020:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    3022:	80 e1       	ldi	r24, 0x10	; 16
    3024:	e0 e6       	ldi	r30, 0x60	; 96
    3026:	f6 e0       	ldi	r31, 0x06	; 6
    3028:	85 83       	std	Z+5, r24	; 0x05
    302a:	08 95       	ret

0000302c <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    302c:	df 92       	push	r13
    302e:	ef 92       	push	r14
    3030:	ff 92       	push	r15
    3032:	0f 93       	push	r16
    3034:	1f 93       	push	r17
    3036:	cf 93       	push	r28
    3038:	df 93       	push	r29
    303a:	8c 01       	movw	r16, r24
    303c:	c6 2f       	mov	r28, r22
    303e:	7a 01       	movw	r14, r20
    3040:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    3042:	82 2f       	mov	r24, r18
    3044:	90 e0       	ldi	r25, 0x00	; 0
    3046:	86 0f       	add	r24, r22
    3048:	91 1d       	adc	r25, r1
    304a:	80 38       	cpi	r24, 0x80	; 128
    304c:	91 05       	cpc	r25, r1
    304e:	8c f5       	brge	.+98     	; 0x30b2 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3050:	8f b7       	in	r24, 0x3f	; 63
    3052:	80 93 56 40 	sts	0x4056, r24
    3056:	f8 94       	cli
    RadioCS(TRUE); 
    3058:	81 e0       	ldi	r24, 0x01	; 1
    305a:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    305e:	80 e6       	ldi	r24, 0x60	; 96
    3060:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3064:	cc 23       	and	r28, r28
    3066:	79 f0       	breq	.+30     	; 0x3086 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    3068:	c8 01       	movw	r24, r16
    306a:	01 96       	adiw	r24, 0x01	; 1
    306c:	c1 50       	subi	r28, 0x01	; 1
    306e:	9c 01       	movw	r18, r24
    3070:	2c 0f       	add	r18, r28
    3072:	31 1d       	adc	r19, r1
    3074:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    3076:	f8 01       	movw	r30, r16
    3078:	81 91       	ld	r24, Z+
    307a:	8f 01       	movw	r16, r30
    307c:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3080:	0c 17       	cp	r16, r28
    3082:	1d 07       	cpc	r17, r29
    3084:	c1 f7       	brne	.-16     	; 0x3076 <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3086:	dd 20       	and	r13, r13
    3088:	69 f0       	breq	.+26     	; 0x30a4 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    308a:	e7 01       	movw	r28, r14
    308c:	21 96       	adiw	r28, 0x01	; 1
    308e:	da 94       	dec	r13
    3090:	cd 0d       	add	r28, r13
    3092:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    3094:	f7 01       	movw	r30, r14
    3096:	81 91       	ld	r24, Z+
    3098:	7f 01       	movw	r14, r30
    309a:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    309e:	ec 16       	cp	r14, r28
    30a0:	fd 06       	cpc	r15, r29
    30a2:	c1 f7       	brne	.-16     	; 0x3094 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    30a4:	80 e0       	ldi	r24, 0x00	; 0
    30a6:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>
    CHB_LEAVE_CRIT();
    30aa:	80 91 56 40 	lds	r24, 0x4056
    30ae:	8f bf       	out	0x3f, r24	; 63
    30b0:	78 94       	sei
}
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	1f 91       	pop	r17
    30b8:	0f 91       	pop	r16
    30ba:	ff 90       	pop	r15
    30bc:	ef 90       	pop	r14
    30be:	df 90       	pop	r13
    30c0:	08 95       	ret

000030c2 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    30c2:	cf 93       	push	r28
    30c4:	df 93       	push	r29
    30c6:	d8 2f       	mov	r29, r24
    30c8:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    30ca:	8f b7       	in	r24, 0x3f	; 63
    30cc:	80 93 56 40 	sts	0x4056, r24
    30d0:	f8 94       	cli
    RadioCS(TRUE);
    30d2:	81 e0       	ldi	r24, 0x01	; 1
    30d4:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    30d8:	8d 2f       	mov	r24, r29
    30da:	80 6c       	ori	r24, 0xC0	; 192
    30dc:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    30e0:	8c 2f       	mov	r24, r28
    30e2:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>

    RadioCS(FALSE);
    30e6:	80 e0       	ldi	r24, 0x00	; 0
    30e8:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>
    CHB_LEAVE_CRIT();
    30ec:	80 91 56 40 	lds	r24, 0x4056
    30f0:	8f bf       	out	0x3f, r24	; 63
    30f2:	78 94       	sei
}
    30f4:	df 91       	pop	r29
    30f6:	cf 91       	pop	r28
    30f8:	08 95       	ret

000030fa <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    30fa:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    30fc:	85 e0       	ldi	r24, 0x05	; 5
    30fe:	0e 94 61 18 	call	0x30c2	; 0x30c2 <chb_reg_write>
}
    3102:	08 95       	ret

00003104 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    3104:	0f 93       	push	r16
    3106:	1f 93       	push	r17
    3108:	cf 93       	push	r28
    310a:	df 93       	push	r29
    310c:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    310e:	c6 2f       	mov	r28, r22
    3110:	d7 2f       	mov	r29, r23
    3112:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    3114:	69 91       	ld	r22, Y+
    3116:	81 2f       	mov	r24, r17
    3118:	80 0f       	add	r24, r16
    311a:	0e 94 61 18 	call	0x30c2	; 0x30c2 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    311e:	1f 5f       	subi	r17, 0xFF	; 255
    3120:	18 30       	cpi	r17, 0x08	; 8
    3122:	c1 f7       	brne	.-16     	; 0x3114 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    3124:	df 91       	pop	r29
    3126:	cf 91       	pop	r28
    3128:	1f 91       	pop	r17
    312a:	0f 91       	pop	r16
    312c:	08 95       	ret

0000312e <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    312e:	cf 93       	push	r28
    3130:	df 93       	push	r29
    3132:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    3134:	80 e0       	ldi	r24, 0x00	; 0
    3136:	90 e0       	ldi	r25, 0x00	; 0
    3138:	be 01       	movw	r22, r28
    313a:	48 e0       	ldi	r20, 0x08	; 8
    313c:	50 e0       	ldi	r21, 0x00	; 0
    313e:	0e 94 f2 1b 	call	0x37e4	; 0x37e4 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    3142:	84 e2       	ldi	r24, 0x24	; 36
    3144:	be 01       	movw	r22, r28
    3146:	0e 94 82 18 	call	0x3104	; 0x3104 <chb_reg_write64>
}
    314a:	df 91       	pop	r29
    314c:	cf 91       	pop	r28
    314e:	08 95       	ret

00003150 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3150:	cf 93       	push	r28
    3152:	df 93       	push	r29
    3154:	c8 2f       	mov	r28, r24
    3156:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    3158:	0e 94 61 18 	call	0x30c2	; 0x30c2 <chb_reg_write>
    315c:	8c 2f       	mov	r24, r28
    315e:	8f 5f       	subi	r24, 0xFF	; 255
    3160:	6d 2f       	mov	r22, r29
    3162:	0e 94 61 18 	call	0x30c2	; 0x30c2 <chb_reg_write>
    }
}
    3166:	df 91       	pop	r29
    3168:	cf 91       	pop	r28
    316a:	08 95       	ret

0000316c <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    316c:	0f 93       	push	r16
    316e:	1f 93       	push	r17
    3170:	cf 93       	push	r28
    3172:	df 93       	push	r29
    3174:	0f 92       	push	r0
    3176:	0f 92       	push	r0
    3178:	cd b7       	in	r28, 0x3d	; 61
    317a:	de b7       	in	r29, 0x3e	; 62
    317c:	89 83       	std	Y+1, r24	; 0x01
    317e:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3180:	0e 94 91 16 	call	0x2d22	; 0x2d22 <chb_get_pcb>
    3184:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    3186:	89 e0       	ldi	r24, 0x09	; 9
    3188:	90 e0       	ldi	r25, 0x00	; 0
    318a:	be 01       	movw	r22, r28
    318c:	6f 5f       	subi	r22, 0xFF	; 255
    318e:	7f 4f       	sbci	r23, 0xFF	; 255
    3190:	42 e0       	ldi	r20, 0x02	; 2
    3192:	50 e0       	ldi	r21, 0x00	; 0
    3194:	0e 94 f2 1b 	call	0x37e4	; 0x37e4 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    3198:	69 81       	ldd	r22, Y+1	; 0x01
    319a:	7a 81       	ldd	r23, Y+2	; 0x02
    319c:	80 e2       	ldi	r24, 0x20	; 32
    319e:	0e 94 a8 18 	call	0x3150	; 0x3150 <chb_reg_write16>
    pcb->src_addr = addr;
    31a2:	89 81       	ldd	r24, Y+1	; 0x01
    31a4:	9a 81       	ldd	r25, Y+2	; 0x02
    31a6:	f8 01       	movw	r30, r16
    31a8:	80 83       	st	Z, r24
    31aa:	91 83       	std	Z+1, r25	; 0x01
}
    31ac:	0f 90       	pop	r0
    31ae:	0f 90       	pop	r0
    31b0:	df 91       	pop	r29
    31b2:	cf 91       	pop	r28
    31b4:	1f 91       	pop	r17
    31b6:	0f 91       	pop	r16
    31b8:	08 95       	ret

000031ba <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    31ba:	cf 93       	push	r28
    31bc:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    31be:	8f b7       	in	r24, 0x3f	; 63
    31c0:	80 93 56 40 	sts	0x4056, r24
    31c4:	f8 94       	cli
    RadioCS(TRUE);
    31c6:	81 e0       	ldi	r24, 0x01	; 1
    31c8:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    31cc:	8c 2f       	mov	r24, r28
    31ce:	80 68       	ori	r24, 0x80	; 128
    31d0:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    val = SPID_write(val);
    31d4:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    31d8:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    31da:	80 e0       	ldi	r24, 0x00	; 0
    31dc:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>
    CHB_LEAVE_CRIT();
    31e0:	80 91 56 40 	lds	r24, 0x4056
    31e4:	8f bf       	out	0x3f, r24	; 63
    31e6:	78 94       	sei

    return val;
}
    31e8:	8c 2f       	mov	r24, r28
    31ea:	cf 91       	pop	r28
    31ec:	08 95       	ret

000031ee <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    31ee:	81 e0       	ldi	r24, 0x01	; 1
    31f0:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
}
    31f4:	8f 71       	andi	r24, 0x1F	; 31
    31f6:	08 95       	ret

000031f8 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    31f8:	1f 93       	push	r17
    31fa:	cf 93       	push	r28
    31fc:	df 93       	push	r29
    31fe:	c8 2f       	mov	r28, r24
    3200:	16 2f       	mov	r17, r22
    3202:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    3204:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    3208:	6d 2f       	mov	r22, r29
    320a:	60 95       	com	r22
    320c:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    320e:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3210:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    3212:	8c 2f       	mov	r24, r28
    3214:	0e 94 61 18 	call	0x30c2	; 0x30c2 <chb_reg_write>
}
    3218:	df 91       	pop	r29
    321a:	cf 91       	pop	r28
    321c:	1f 91       	pop	r17
    321e:	08 95       	ret

00003220 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3220:	cf 93       	push	r28
    3222:	df 93       	push	r29
    3224:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    3226:	80 91 64 06 	lds	r24, 0x0664
    322a:	81 fd       	sbrc	r24, 1
    322c:	4b c0       	rjmp	.+150    	; 0x32c4 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    322e:	0e 94 f7 18 	call	0x31ee	; 0x31ee <chb_get_state>
    3232:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    3234:	81 51       	subi	r24, 0x11	; 17
    3236:	82 30       	cpi	r24, 0x02	; 2
    3238:	20 f0       	brcs	.+8      	; 0x3242 <chb_set_state+0x22>
    323a:	c1 30       	cpi	r28, 0x01	; 1
    323c:	11 f0       	breq	.+4      	; 0x3242 <chb_set_state+0x22>
    323e:	c2 30       	cpi	r28, 0x02	; 2
    3240:	21 f4       	brne	.+8      	; 0x324a <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    3242:	0e 94 f7 18 	call	0x31ee	; 0x31ee <chb_get_state>
    3246:	8c 17       	cp	r24, r28
    3248:	e1 f3       	breq	.-8      	; 0x3242 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    324a:	d6 31       	cpi	r29, 0x16	; 22
    324c:	f9 f0       	breq	.+62     	; 0x328c <chb_set_state+0x6c>
    324e:	d9 31       	cpi	r29, 0x19	; 25
    3250:	89 f0       	breq	.+34     	; 0x3274 <chb_set_state+0x54>
    3252:	d8 30       	cpi	r29, 0x08	; 8
    3254:	31 f5       	brne	.+76     	; 0x32a2 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    3256:	e4 e6       	ldi	r30, 0x64	; 100
    3258:	f6 e0       	ldi	r31, 0x06	; 6
    325a:	80 81       	ld	r24, Z
    325c:	8d 7f       	andi	r24, 0xFD	; 253
    325e:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3260:	82 e0       	ldi	r24, 0x02	; 2
    3262:	63 e0       	ldi	r22, 0x03	; 3
    3264:	4f e1       	ldi	r20, 0x1F	; 31
    3266:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
    326a:	8a e0       	ldi	r24, 0x0A	; 10
    326c:	8a 95       	dec	r24
    326e:	f1 f7       	brne	.-4      	; 0x326c <chb_set_state+0x4c>
    3270:	00 c0       	rjmp	.+0      	; 0x3272 <chb_set_state+0x52>
    3272:	17 c0       	rjmp	.+46     	; 0x32a2 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3274:	c6 31       	cpi	r28, 0x16	; 22
    3276:	a9 f4       	brne	.+42     	; 0x32a2 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3278:	82 e0       	ldi	r24, 0x02	; 2
    327a:	69 e0       	ldi	r22, 0x09	; 9
    327c:	4f e1       	ldi	r20, 0x1F	; 31
    327e:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
    3282:	9a e0       	ldi	r25, 0x0A	; 10
    3284:	9a 95       	dec	r25
    3286:	f1 f7       	brne	.-4      	; 0x3284 <chb_set_state+0x64>
    3288:	00 c0       	rjmp	.+0      	; 0x328a <chb_set_state+0x6a>
    328a:	0b c0       	rjmp	.+22     	; 0x32a2 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    328c:	c9 31       	cpi	r28, 0x19	; 25
    328e:	49 f4       	brne	.+18     	; 0x32a2 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3290:	82 e0       	ldi	r24, 0x02	; 2
    3292:	69 e0       	ldi	r22, 0x09	; 9
    3294:	4f e1       	ldi	r20, 0x1F	; 31
    3296:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
    329a:	8a e0       	ldi	r24, 0x0A	; 10
    329c:	8a 95       	dec	r24
    329e:	f1 f7       	brne	.-4      	; 0x329c <chb_set_state+0x7c>
    32a0:	00 c0       	rjmp	.+0      	; 0x32a2 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    32a2:	82 e0       	ldi	r24, 0x02	; 2
    32a4:	6d 2f       	mov	r22, r29
    32a6:	4f e1       	ldi	r20, 0x1F	; 31
    32a8:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
    32ac:	8f e6       	ldi	r24, 0x6F	; 111
    32ae:	93 e0       	ldi	r25, 0x03	; 3
    32b0:	01 97       	sbiw	r24, 0x01	; 1
    32b2:	f1 f7       	brne	.-4      	; 0x32b0 <chb_set_state+0x90>
    32b4:	00 c0       	rjmp	.+0      	; 0x32b6 <chb_set_state+0x96>
    32b6:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    32b8:	0e 94 f7 18 	call	0x31ee	; 0x31ee <chb_get_state>
    32bc:	8d 17       	cp	r24, r29
    32be:	21 f4       	brne	.+8      	; 0x32c8 <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    32c0:	80 e4       	ldi	r24, 0x40	; 64
    32c2:	03 c0       	rjmp	.+6      	; 0x32ca <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    32c4:	84 e4       	ldi	r24, 0x44	; 68
    32c6:	01 c0       	rjmp	.+2      	; 0x32ca <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    32c8:	83 e4       	ldi	r24, 0x43	; 67
}
    32ca:	df 91       	pop	r29
    32cc:	cf 91       	pop	r28
    32ce:	08 95       	ret

000032d0 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    32d0:	88 23       	and	r24, r24
    32d2:	49 f0       	breq	.+18     	; 0x32e6 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    32d4:	88 e0       	ldi	r24, 0x08	; 8
    32d6:	0e 94 10 19 	call	0x3220	; 0x3220 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    32da:	e4 e6       	ldi	r30, 0x64	; 100
    32dc:	f6 e0       	ldi	r31, 0x06	; 6
    32de:	80 81       	ld	r24, Z
    32e0:	82 60       	ori	r24, 0x02	; 2
    32e2:	80 83       	st	Z, r24
    32e4:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    32e6:	e4 e6       	ldi	r30, 0x64	; 100
    32e8:	f6 e0       	ldi	r31, 0x06	; 6
    32ea:	80 81       	ld	r24, Z
    32ec:	8d 7f       	andi	r24, 0xFD	; 253
    32ee:	80 83       	st	Z, r24
    32f0:	8f e7       	ldi	r24, 0x7F	; 127
    32f2:	97 e0       	ldi	r25, 0x07	; 7
    32f4:	01 97       	sbiw	r24, 0x01	; 1
    32f6:	f1 f7       	brne	.-4      	; 0x32f4 <chb_sleep+0x24>
    32f8:	00 c0       	rjmp	.+0      	; 0x32fa <chb_sleep+0x2a>
    32fa:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    32fc:	86 e1       	ldi	r24, 0x16	; 22
    32fe:	0e 94 10 19 	call	0x3220	; 0x3220 <chb_set_state>
    3302:	08 95       	ret

00003304 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    3304:	cf 92       	push	r12
    3306:	df 92       	push	r13
    3308:	ef 92       	push	r14
    330a:	ff 92       	push	r15
    330c:	0f 93       	push	r16
    330e:	1f 93       	push	r17
    3310:	cf 93       	push	r28
    3312:	df 93       	push	r29
    3314:	7c 01       	movw	r14, r24
    3316:	6b 01       	movw	r12, r22
    3318:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    331a:	0e 94 f7 18 	call	0x31ee	; 0x31ee <chb_get_state>
    331e:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3320:	0e 94 91 16 	call	0x2d22	; 0x2d22 <chb_get_pcb>
    3324:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3326:	12 30       	cpi	r17, 0x02	; 2
    3328:	f1 f0       	breq	.+60     	; 0x3366 <chb_tx+0x62>
    332a:	12 31       	cpi	r17, 0x12	; 18
    332c:	f1 f0       	breq	.+60     	; 0x336a <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    332e:	88 e0       	ldi	r24, 0x08	; 8
    3330:	0e 94 10 19 	call	0x3220	; 0x3220 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    3334:	89 e1       	ldi	r24, 0x19	; 25
    3336:	0e 94 10 19 	call	0x3220	; 0x3220 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    333a:	c7 01       	movw	r24, r14
    333c:	6a e0       	ldi	r22, 0x0A	; 10
    333e:	a6 01       	movw	r20, r12
    3340:	20 2f       	mov	r18, r16
    3342:	0e 94 16 18 	call	0x302c	; 0x302c <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3346:	82 e0       	ldi	r24, 0x02	; 2
    3348:	62 e0       	ldi	r22, 0x02	; 2
    334a:	4f e1       	ldi	r20, 0x1F	; 31
    334c:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3350:	8c 81       	ldd	r24, Y+4	; 0x04
    3352:	88 23       	and	r24, r24
    3354:	e9 f3       	breq	.-6      	; 0x3350 <chb_tx+0x4c>
    pcb->tx_end = false;
    3356:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3358:	82 e0       	ldi	r24, 0x02	; 2
    335a:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    335e:	82 95       	swap	r24
    3360:	86 95       	lsr	r24
    3362:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3364:	03 c0       	rjmp	.+6      	; 0x336c <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3366:	84 e4       	ldi	r24, 0x44	; 68
    3368:	01 c0       	rjmp	.+2      	; 0x336c <chb_tx+0x68>
    336a:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    336c:	df 91       	pop	r29
    336e:	cf 91       	pop	r28
    3370:	1f 91       	pop	r17
    3372:	0f 91       	pop	r16
    3374:	ff 90       	pop	r15
    3376:	ef 90       	pop	r14
    3378:	df 90       	pop	r13
    337a:	cf 90       	pop	r12
    337c:	08 95       	ret

0000337e <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    337e:	81 30       	cpi	r24, 0x01	; 1
    3380:	91 f0       	breq	.+36     	; 0x33a6 <chb_set_mode+0x28>
    3382:	81 30       	cpi	r24, 0x01	; 1
    3384:	28 f0       	brcs	.+10     	; 0x3390 <chb_set_mode+0x12>
    3386:	82 30       	cpi	r24, 0x02	; 2
    3388:	c9 f0       	breq	.+50     	; 0x33bc <chb_set_mode+0x3e>
    338a:	83 30       	cpi	r24, 0x03	; 3
    338c:	61 f5       	brne	.+88     	; 0x33e6 <chb_set_mode+0x68>
    338e:	21 c0       	rjmp	.+66     	; 0x33d2 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3390:	8c e0       	ldi	r24, 0x0C	; 12
    3392:	68 e0       	ldi	r22, 0x08	; 8
    3394:	4f e3       	ldi	r20, 0x3F	; 63
    3396:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    339a:	86 e1       	ldi	r24, 0x16	; 22
    339c:	62 e0       	ldi	r22, 0x02	; 2
    339e:	43 e0       	ldi	r20, 0x03	; 3
    33a0:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
        break;
    33a4:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    33a6:	8c e0       	ldi	r24, 0x0C	; 12
    33a8:	6c e0       	ldi	r22, 0x0C	; 12
    33aa:	4f e3       	ldi	r20, 0x3F	; 63
    33ac:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    33b0:	86 e1       	ldi	r24, 0x16	; 22
    33b2:	62 e0       	ldi	r22, 0x02	; 2
    33b4:	43 e0       	ldi	r20, 0x03	; 3
    33b6:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
        break;
    33ba:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    33bc:	8c e0       	ldi	r24, 0x0C	; 12
    33be:	6c e1       	ldi	r22, 0x1C	; 28
    33c0:	4f e3       	ldi	r20, 0x3F	; 63
    33c2:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    33c6:	86 e1       	ldi	r24, 0x16	; 22
    33c8:	62 e0       	ldi	r22, 0x02	; 2
    33ca:	43 e0       	ldi	r20, 0x03	; 3
    33cc:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
        break;
    33d0:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    33d2:	8c e0       	ldi	r24, 0x0C	; 12
    33d4:	60 e0       	ldi	r22, 0x00	; 0
    33d6:	4f e3       	ldi	r20, 0x3F	; 63
    33d8:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    33dc:	86 e1       	ldi	r24, 0x16	; 22
    33de:	63 e0       	ldi	r22, 0x03	; 3
    33e0:	43 e0       	ldi	r20, 0x03	; 3
    33e2:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
    33e6:	08 95       	ret

000033e8 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    33e8:	cf 93       	push	r28
    33ea:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    33ec:	88 e0       	ldi	r24, 0x08	; 8
    33ee:	6c 2f       	mov	r22, r28
    33f0:	4f e1       	ldi	r20, 0x1F	; 31
    33f2:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    33f6:	0e 94 f7 18 	call	0x31ee	; 0x31ee <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    33fa:	86 30       	cpi	r24, 0x06	; 6
    33fc:	11 f0       	breq	.+4      	; 0x3402 <chb_set_channel+0x1a>
    33fe:	89 30       	cpi	r24, 0x09	; 9
    3400:	31 f4       	brne	.+12     	; 0x340e <chb_set_channel+0x26>
    3402:	8f e6       	ldi	r24, 0x6F	; 111
    3404:	93 e0       	ldi	r25, 0x03	; 3
    3406:	01 97       	sbiw	r24, 0x01	; 1
    3408:	f1 f7       	brne	.-4      	; 0x3406 <chb_set_channel+0x1e>
    340a:	00 c0       	rjmp	.+0      	; 0x340c <chb_set_channel+0x24>
    340c:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    340e:	88 e0       	ldi	r24, 0x08	; 8
    3410:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    3414:	90 e0       	ldi	r25, 0x00	; 0
    3416:	8f 71       	andi	r24, 0x1F	; 31
    3418:	90 70       	andi	r25, 0x00	; 0
    341a:	6c 2f       	mov	r22, r28
    341c:	70 e0       	ldi	r23, 0x00	; 0
    341e:	86 17       	cp	r24, r22
    3420:	97 07       	cpc	r25, r23
    3422:	11 f4       	brne	.+4      	; 0x3428 <chb_set_channel+0x40>
    3424:	80 e4       	ldi	r24, 0x40	; 64
    3426:	01 c0       	rjmp	.+2      	; 0x342a <chb_set_channel+0x42>
    3428:	83 e4       	ldi	r24, 0x43	; 67
}
    342a:	cf 91       	pop	r28
    342c:	08 95       	ret

0000342e <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    342e:	cf 93       	push	r28
    3430:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3432:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    3436:	8c 2b       	or	r24, r28
    3438:	8f 5f       	subi	r24, 0xFF	; 255
    343a:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    }
    return val;
}
    343e:	80 e0       	ldi	r24, 0x00	; 0
    3440:	90 e0       	ldi	r25, 0x00	; 0
    3442:	cf 91       	pop	r28
    3444:	08 95       	ret

00003446 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3446:	e4 e6       	ldi	r30, 0x64	; 100
    3448:	f6 e0       	ldi	r31, 0x06	; 6
    344a:	80 81       	ld	r24, Z
    344c:	81 60       	ori	r24, 0x01	; 1
    344e:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3450:	80 81       	ld	r24, Z
    3452:	8d 7f       	andi	r24, 0xFD	; 253
    3454:	80 83       	st	Z, r24
    3456:	8f ed       	ldi	r24, 0xDF	; 223
    3458:	9b e0       	ldi	r25, 0x0B	; 11
    345a:	01 97       	sbiw	r24, 0x01	; 1
    345c:	f1 f7       	brne	.-4      	; 0x345a <chb_reset+0x14>
    345e:	00 c0       	rjmp	.+0      	; 0x3460 <chb_reset+0x1a>
    3460:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3462:	80 81       	ld	r24, Z
    3464:	8e 7f       	andi	r24, 0xFE	; 254
    3466:	80 83       	st	Z, r24
    3468:	9a e0       	ldi	r25, 0x0A	; 10
    346a:	9a 95       	dec	r25
    346c:	f1 f7       	brne	.-4      	; 0x346a <chb_reset+0x24>
    346e:	00 c0       	rjmp	.+0      	; 0x3470 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3470:	80 81       	ld	r24, Z
    3472:	81 60       	ori	r24, 0x01	; 1
    3474:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3476:	8d e1       	ldi	r24, 0x1D	; 29
    3478:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    347c:	81 30       	cpi	r24, 0x01	; 1
    347e:	d9 f7       	brne	.-10     	; 0x3476 <chb_reset+0x30>
    3480:	8c e1       	ldi	r24, 0x1C	; 28
    3482:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    3486:	87 30       	cpi	r24, 0x07	; 7
    3488:	b1 f7       	brne	.-20     	; 0x3476 <chb_reset+0x30>
            break;
        }
    }
	

}
    348a:	08 95       	ret

0000348c <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    348c:	0f 93       	push	r16
    348e:	1f 93       	push	r17
    3490:	cf 93       	push	r28
    3492:	df 93       	push	r29
    3494:	cd b7       	in	r28, 0x3d	; 61
    3496:	de b7       	in	r29, 0x3e	; 62
    3498:	ea 97       	sbiw	r28, 0x3a	; 58
    349a:	cd bf       	out	0x3d, r28	; 61
    349c:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    349e:	0e 94 8d 1c 	call	0x391a	; 0x391a <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    34a2:	e0 e6       	ldi	r30, 0x60	; 96
    34a4:	f6 e0       	ldi	r31, 0x06	; 6
    34a6:	80 81       	ld	r24, Z
    34a8:	82 60       	ori	r24, 0x02	; 2
    34aa:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    34ac:	80 81       	ld	r24, Z
    34ae:	81 60       	ori	r24, 0x01	; 1
    34b0:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    34b2:	0e 94 23 1a 	call	0x3446	; 0x3446 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    34b6:	8e e0       	ldi	r24, 0x0E	; 14
    34b8:	60 e0       	ldi	r22, 0x00	; 0
    34ba:	0e 94 61 18 	call	0x30c2	; 0x30c2 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    34be:	82 e0       	ldi	r24, 0x02	; 2
    34c0:	63 e0       	ldi	r22, 0x03	; 3
    34c2:	4f e1       	ldi	r20, 0x1F	; 31
    34c4:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    34c8:	81 e0       	ldi	r24, 0x01	; 1
    34ca:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    34ce:	8f 71       	andi	r24, 0x1F	; 31
    34d0:	88 30       	cpi	r24, 0x08	; 8
    34d2:	d1 f7       	brne	.-12     	; 0x34c8 <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    34d4:	8e e2       	ldi	r24, 0x2E	; 46
    34d6:	60 e4       	ldi	r22, 0x40	; 64
    34d8:	40 ec       	ldi	r20, 0xC0	; 192
    34da:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    34de:	8e e0       	ldi	r24, 0x0E	; 14
    34e0:	6c e0       	ldi	r22, 0x0C	; 12
    34e2:	0e 94 61 18 	call	0x30c2	; 0x30c2 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    34e6:	84 e0       	ldi	r24, 0x04	; 4
    34e8:	60 e2       	ldi	r22, 0x20	; 32
    34ea:	40 e2       	ldi	r20, 0x20	; 32
    34ec:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    34f0:	81 e0       	ldi	r24, 0x01	; 1
    34f2:	0e 94 bf 19 	call	0x337e	; 0x337e <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    34f6:	81 e0       	ldi	r24, 0x01	; 1
    34f8:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    34fc:	86 e1       	ldi	r24, 0x16	; 22
    34fe:	0e 94 10 19 	call	0x3220	; 0x3220 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3502:	82 e2       	ldi	r24, 0x22	; 34
    3504:	64 e3       	ldi	r22, 0x34	; 52
    3506:	72 e1       	ldi	r23, 0x12	; 18
    3508:	0e 94 a8 18 	call	0x3150	; 0x3150 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    350c:	0e 94 f4 17 	call	0x2fe8	; 0x2fe8 <chb_get_short_addr>
    3510:	bc 01       	movw	r22, r24
    3512:	80 e2       	ldi	r24, 0x20	; 32
    3514:	0e 94 a8 18 	call	0x3150	; 0x3150 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3518:	ce 01       	movw	r24, r28
    351a:	01 96       	adiw	r24, 0x01	; 1
    351c:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3520:	84 e2       	ldi	r24, 0x24	; 36
    3522:	be 01       	movw	r22, r28
    3524:	6f 5f       	subi	r22, 0xFF	; 255
    3526:	7f 4f       	sbci	r23, 0xFF	; 255
    3528:	0e 94 82 18 	call	0x3104	; 0x3104 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    352c:	e2 e7       	ldi	r30, 0x72	; 114
    352e:	f6 e0       	ldi	r31, 0x06	; 6
    3530:	80 81       	ld	r24, Z
    3532:	81 60       	ori	r24, 0x01	; 1
    3534:	80 83       	st	Z, r24
    3536:	e9 e6       	ldi	r30, 0x69	; 105
    3538:	f6 e0       	ldi	r31, 0x06	; 6
    353a:	80 81       	ld	r24, Z
    353c:	83 60       	ori	r24, 0x03	; 3
    353e:	80 83       	st	Z, r24
    3540:	ea e6       	ldi	r30, 0x6A	; 106
    3542:	f6 e0       	ldi	r31, 0x06	; 6
    3544:	80 81       	ld	r24, Z
    3546:	84 60       	ori	r24, 0x04	; 4
    3548:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    354a:	e0 ea       	ldi	r30, 0xA0	; 160
    354c:	f0 e0       	ldi	r31, 0x00	; 0
    354e:	82 81       	ldd	r24, Z+2	; 0x02
    3550:	87 60       	ori	r24, 0x07	; 7
    3552:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3554:	0e 94 f7 18 	call	0x31ee	; 0x31ee <chb_get_state>
    3558:	86 31       	cpi	r24, 0x16	; 22
    355a:	91 f0       	breq	.+36     	; 0x3580 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    355c:	8e 01       	movw	r16, r28
    355e:	07 5f       	subi	r16, 0xF7	; 247
    3560:	1f 4f       	sbci	r17, 0xFF	; 255
    3562:	c8 01       	movw	r24, r16
    3564:	68 ee       	ldi	r22, 0xE8	; 232
    3566:	71 e0       	ldi	r23, 0x01	; 1
    3568:	0e 94 6e 3b 	call	0x76dc	; 0x76dc <strcpy_P>
        printf(buf);
    356c:	0f 92       	push	r0
    356e:	0f 92       	push	r0
    3570:	ed b7       	in	r30, 0x3d	; 61
    3572:	fe b7       	in	r31, 0x3e	; 62
    3574:	01 83       	std	Z+1, r16	; 0x01
    3576:	12 83       	std	Z+2, r17	; 0x02
    3578:	0e 94 c1 3b 	call	0x7782	; 0x7782 <printf>
    357c:	0f 90       	pop	r0
    357e:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3580:	ea 96       	adiw	r28, 0x3a	; 58
    3582:	cd bf       	out	0x3d, r28	; 61
    3584:	de bf       	out	0x3e, r29	; 62
    3586:	df 91       	pop	r29
    3588:	cf 91       	pop	r28
    358a:	1f 91       	pop	r17
    358c:	0f 91       	pop	r16
    358e:	08 95       	ret

00003590 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3590:	1f 92       	push	r1
    3592:	0f 92       	push	r0
    3594:	0f b6       	in	r0, 0x3f	; 63
    3596:	0f 92       	push	r0
    3598:	0b b6       	in	r0, 0x3b	; 59
    359a:	0f 92       	push	r0
    359c:	11 24       	eor	r1, r1
    359e:	4f 92       	push	r4
    35a0:	5f 92       	push	r5
    35a2:	6f 92       	push	r6
    35a4:	7f 92       	push	r7
    35a6:	8f 92       	push	r8
    35a8:	9f 92       	push	r9
    35aa:	af 92       	push	r10
    35ac:	bf 92       	push	r11
    35ae:	cf 92       	push	r12
    35b0:	df 92       	push	r13
    35b2:	ef 92       	push	r14
    35b4:	ff 92       	push	r15
    35b6:	0f 93       	push	r16
    35b8:	1f 93       	push	r17
    35ba:	2f 93       	push	r18
    35bc:	3f 93       	push	r19
    35be:	4f 93       	push	r20
    35c0:	5f 93       	push	r21
    35c2:	6f 93       	push	r22
    35c4:	7f 93       	push	r23
    35c6:	8f 93       	push	r24
    35c8:	9f 93       	push	r25
    35ca:	af 93       	push	r26
    35cc:	bf 93       	push	r27
    35ce:	ef 93       	push	r30
    35d0:	ff 93       	push	r31
    35d2:	cf 93       	push	r28
    35d4:	df 93       	push	r29
    35d6:	cd b7       	in	r28, 0x3d	; 61
    35d8:	de b7       	in	r29, 0x3e	; 62
    35da:	e2 97       	sbiw	r28, 0x32	; 50
    35dc:	cd bf       	out	0x3d, r28	; 61
    35de:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    35e0:	0e 94 91 16 	call	0x2d22	; 0x2d22 <chb_get_pcb>
    35e4:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    35e6:	8f b7       	in	r24, 0x3f	; 63
    35e8:	80 93 56 40 	sts	0x4056, r24
    35ec:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    35ee:	81 e0       	ldi	r24, 0x01	; 1
    35f0:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    35f4:	8f e8       	ldi	r24, 0x8F	; 143
    35f6:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    intp_src = SPID_write(0);
    35fa:	80 e0       	ldi	r24, 0x00	; 0
    35fc:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    3600:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3602:	80 e0       	ldi	r24, 0x00	; 0
    3604:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>

    while (intp_src)
    3608:	11 23       	and	r17, r17
    360a:	09 f4       	brne	.+2      	; 0x360e <__vector_64+0x7e>
    360c:	be c0       	rjmp	.+380    	; 0x378a <__vector_64+0x1fa>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    360e:	aa 24       	eor	r10, r10
    3610:	bb 24       	eor	r11, r11
    3612:	68 94       	set
    3614:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3616:	0f 2e       	mov	r0, r31
    3618:	f8 e0       	ldi	r31, 0x08	; 8
    361a:	6f 2e       	mov	r6, r31
    361c:	f2 e0       	ldi	r31, 0x02	; 2
    361e:	7f 2e       	mov	r7, r31
    3620:	f0 2d       	mov	r31, r0
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    3622:	0f 2e       	mov	r0, r31
    3624:	f0 e8       	ldi	r31, 0x80	; 128
    3626:	8f 2e       	mov	r8, r31
    3628:	f6 e0       	ldi	r31, 0x06	; 6
    362a:	9f 2e       	mov	r9, r31
    362c:	f0 2d       	mov	r31, r0
    362e:	cc 24       	eor	r12, r12
    3630:	68 94       	set
    3632:	c2 f8       	bld	r12, 2
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3634:	12 ff       	sbrs	r17, 2
    3636:	02 c0       	rjmp	.+4      	; 0x363c <__vector_64+0xac>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3638:	1b 7f       	andi	r17, 0xFB	; 251
    363a:	a4 c0       	rjmp	.+328    	; 0x3784 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    363c:	13 ff       	sbrs	r17, 3
    363e:	89 c0       	rjmp	.+274    	; 0x3752 <__vector_64+0x1c2>
        {
            state = chb_get_state();
    3640:	0e 94 f7 18 	call	0x31ee	; 0x31ee <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3644:	86 30       	cpi	r24, 0x06	; 6
    3646:	29 f0       	breq	.+10     	; 0x3652 <__vector_64+0xc2>
    3648:	86 31       	cpi	r24, 0x16	; 22
    364a:	19 f0       	breq	.+6      	; 0x3652 <__vector_64+0xc2>
    364c:	81 31       	cpi	r24, 0x11	; 17
    364e:	09 f0       	breq	.+2      	; 0x3652 <__vector_64+0xc2>
    3650:	76 c0       	rjmp	.+236    	; 0x373e <__vector_64+0x1ae>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    3652:	88 e0       	ldi	r24, 0x08	; 8
    3654:	0e 94 10 19 	call	0x3220	; 0x3220 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3658:	87 e0       	ldi	r24, 0x07	; 7
    365a:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    365e:	f7 01       	movw	r30, r14
    3660:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3662:	86 e0       	ldi	r24, 0x06	; 6
    3664:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
    3668:	88 1f       	adc	r24, r24
    366a:	88 27       	eor	r24, r24
    366c:	88 1f       	adc	r24, r24
    366e:	f7 01       	movw	r30, r14
    3670:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3672:	88 23       	and	r24, r24
    3674:	09 f4       	brne	.+2      	; 0x3678 <__vector_64+0xe8>
    3676:	66 c0       	rjmp	.+204    	; 0x3744 <__vector_64+0x1b4>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3678:	8f b7       	in	r24, 0x3f	; 63
    367a:	80 93 56 40 	sts	0x4056, r24
    367e:	f8 94       	cli
    RadioCS(TRUE);
    3680:	81 e0       	ldi	r24, 0x01	; 1
    3682:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3686:	80 e2       	ldi	r24, 0x20	; 32
    3688:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    len = SPID_write(0);
    368c:	80 e0       	ldi	r24, 0x00	; 0
    368e:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
    3692:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3694:	83 50       	subi	r24, 0x03	; 3
    3696:	8d 37       	cpi	r24, 0x7D	; 125
    3698:	08 f0       	brcs	.+2      	; 0x369c <__vector_64+0x10c>
    369a:	41 c0       	rjmp	.+130    	; 0x371e <__vector_64+0x18e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    369c:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <chb_buf_get_len>
    36a0:	2d 2d       	mov	r18, r13
    36a2:	30 e0       	ldi	r19, 0x00	; 0
    36a4:	a5 01       	movw	r20, r10
    36a6:	48 1b       	sub	r20, r24
    36a8:	51 09       	sbc	r21, r1
    36aa:	24 17       	cp	r18, r20
    36ac:	35 07       	cpc	r19, r21
    36ae:	94 f4       	brge	.+36     	; 0x36d4 <__vector_64+0x144>
        {
            chb_buf_write(len);
    36b0:	8d 2d       	mov	r24, r13
    36b2:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <chb_buf_write>
            
            for (i=0; i<len; i++)
    36b6:	dd 20       	and	r13, r13
    36b8:	49 f0       	breq	.+18     	; 0x36cc <__vector_64+0x13c>
    36ba:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    36bc:	80 e0       	ldi	r24, 0x00	; 0
    36be:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
                chb_buf_write(data);
    36c2:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    36c6:	0f 5f       	subi	r16, 0xFF	; 255
    36c8:	0d 15       	cp	r16, r13
    36ca:	c1 f7       	brne	.-16     	; 0x36bc <__vector_64+0x12c>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    36cc:	f4 01       	movw	r30, r8
    36ce:	c5 82       	std	Z+5, r12	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    36d0:	c6 82       	std	Z+6, r12	; 0x06
    36d2:	25 c0       	rjmp	.+74     	; 0x371e <__vector_64+0x18e>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    36d4:	0e 94 91 16 	call	0x2d22	; 0x2d22 <chb_get_pcb>
    36d8:	2c 01       	movw	r4, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    36da:	dd 20       	and	r13, r13
    36dc:	39 f0       	breq	.+14     	; 0x36ec <__vector_64+0x15c>
    36de:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    36e0:	80 e0       	ldi	r24, 0x00	; 0
    36e2:	0e 94 a0 1c 	call	0x3940	; 0x3940 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    36e6:	0f 5f       	subi	r16, 0xFF	; 255
    36e8:	0d 15       	cp	r16, r13
    36ea:	d1 f7       	brne	.-12     	; 0x36e0 <__vector_64+0x150>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    36ec:	f2 01       	movw	r30, r4
    36ee:	85 85       	ldd	r24, Z+13	; 0x0d
    36f0:	96 85       	ldd	r25, Z+14	; 0x0e
    36f2:	01 96       	adiw	r24, 0x01	; 1
    36f4:	85 87       	std	Z+13, r24	; 0x0d
    36f6:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    36f8:	ce 01       	movw	r24, r28
    36fa:	01 96       	adiw	r24, 0x01	; 1
    36fc:	b3 01       	movw	r22, r6
    36fe:	0e 94 6e 3b 	call	0x76dc	; 0x76dc <strcpy_P>
            printf(buf);
    3702:	0f 92       	push	r0
    3704:	0f 92       	push	r0
    3706:	41 e0       	ldi	r20, 0x01	; 1
    3708:	50 e0       	ldi	r21, 0x00	; 0
    370a:	4c 0f       	add	r20, r28
    370c:	5d 1f       	adc	r21, r29
    370e:	ed b7       	in	r30, 0x3d	; 61
    3710:	fe b7       	in	r31, 0x3e	; 62
    3712:	41 83       	std	Z+1, r20	; 0x01
    3714:	52 83       	std	Z+2, r21	; 0x02
    3716:	0e 94 c1 3b 	call	0x7782	; 0x7782 <printf>
    371a:	0f 90       	pop	r0
    371c:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    371e:	80 e0       	ldi	r24, 0x00	; 0
    3720:	0e 94 0a 18 	call	0x3014	; 0x3014 <RadioCS>
    CHB_LEAVE_CRIT();
    3724:	80 91 56 40 	lds	r24, 0x4056
    3728:	8f bf       	out	0x3f, r24	; 63
    372a:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    372c:	f7 01       	movw	r30, r14
    372e:	85 81       	ldd	r24, Z+5	; 0x05
    3730:	96 81       	ldd	r25, Z+6	; 0x06
    3732:	01 96       	adiw	r24, 0x01	; 1
    3734:	85 83       	std	Z+5, r24	; 0x05
    3736:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3738:	81 e0       	ldi	r24, 0x01	; 1
    373a:	83 83       	std	Z+3, r24	; 0x03
    373c:	03 c0       	rjmp	.+6      	; 0x3744 <__vector_64+0x1b4>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    373e:	81 e0       	ldi	r24, 0x01	; 1
    3740:	f7 01       	movw	r30, r14
    3742:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3744:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3746:	86 e1       	ldi	r24, 0x16	; 22
    3748:	0e 94 10 19 	call	0x3220	; 0x3220 <chb_set_state>
    374c:	80 34       	cpi	r24, 0x40	; 64
    374e:	d9 f7       	brne	.-10     	; 0x3746 <__vector_64+0x1b6>
    3750:	19 c0       	rjmp	.+50     	; 0x3784 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3752:	16 ff       	sbrs	r17, 6
    3754:	08 c0       	rjmp	.+16     	; 0x3766 <__vector_64+0x1d6>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3756:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3758:	f7 01       	movw	r30, r14
    375a:	87 85       	ldd	r24, Z+15	; 0x0f
    375c:	90 89       	ldd	r25, Z+16	; 0x10
    375e:	01 96       	adiw	r24, 0x01	; 1
    3760:	87 87       	std	Z+15, r24	; 0x0f
    3762:	90 8b       	std	Z+16, r25	; 0x10
    3764:	0f c0       	rjmp	.+30     	; 0x3784 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3766:	11 ff       	sbrs	r17, 1
    3768:	02 c0       	rjmp	.+4      	; 0x376e <__vector_64+0x1de>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    376a:	1d 7f       	andi	r17, 0xFD	; 253
    376c:	0b c0       	rjmp	.+22     	; 0x3784 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    376e:	10 ff       	sbrs	r17, 0
    3770:	02 c0       	rjmp	.+4      	; 0x3776 <__vector_64+0x1e6>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3772:	1e 7f       	andi	r17, 0xFE	; 254
    3774:	07 c0       	rjmp	.+14     	; 0x3784 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3776:	11 23       	and	r17, r17
    3778:	2c f4       	brge	.+10     	; 0x3784 <__vector_64+0x1f4>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    377a:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    377c:	f7 01       	movw	r30, r14
    377e:	81 89       	ldd	r24, Z+17	; 0x11
    3780:	8f 5f       	subi	r24, 0xFF	; 255
    3782:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3784:	11 23       	and	r17, r17
    3786:	09 f0       	breq	.+2      	; 0x378a <__vector_64+0x1fa>
    3788:	55 cf       	rjmp	.-342    	; 0x3634 <__vector_64+0xa4>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    378a:	80 91 56 40 	lds	r24, 0x4056
    378e:	8f bf       	out	0x3f, r24	; 63
    3790:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3792:	8f e0       	ldi	r24, 0x0F	; 15
    3794:	0e 94 dd 18 	call	0x31ba	; 0x31ba <chb_reg_read>
}
    3798:	e2 96       	adiw	r28, 0x32	; 50
    379a:	cd bf       	out	0x3d, r28	; 61
    379c:	de bf       	out	0x3e, r29	; 62
    379e:	df 91       	pop	r29
    37a0:	cf 91       	pop	r28
    37a2:	ff 91       	pop	r31
    37a4:	ef 91       	pop	r30
    37a6:	bf 91       	pop	r27
    37a8:	af 91       	pop	r26
    37aa:	9f 91       	pop	r25
    37ac:	8f 91       	pop	r24
    37ae:	7f 91       	pop	r23
    37b0:	6f 91       	pop	r22
    37b2:	5f 91       	pop	r21
    37b4:	4f 91       	pop	r20
    37b6:	3f 91       	pop	r19
    37b8:	2f 91       	pop	r18
    37ba:	1f 91       	pop	r17
    37bc:	0f 91       	pop	r16
    37be:	ff 90       	pop	r15
    37c0:	ef 90       	pop	r14
    37c2:	df 90       	pop	r13
    37c4:	cf 90       	pop	r12
    37c6:	bf 90       	pop	r11
    37c8:	af 90       	pop	r10
    37ca:	9f 90       	pop	r9
    37cc:	8f 90       	pop	r8
    37ce:	7f 90       	pop	r7
    37d0:	6f 90       	pop	r6
    37d2:	5f 90       	pop	r5
    37d4:	4f 90       	pop	r4
    37d6:	0f 90       	pop	r0
    37d8:	0b be       	out	0x3b, r0	; 59
    37da:	0f 90       	pop	r0
    37dc:	0f be       	out	0x3f, r0	; 63
    37de:	0f 90       	pop	r0
    37e0:	1f 90       	pop	r1
    37e2:	18 95       	reti

000037e4 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    37e4:	0f 93       	push	r16
    37e6:	1f 93       	push	r17
    37e8:	cf 93       	push	r28
    37ea:	df 93       	push	r29
    37ec:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    37ee:	e0 ec       	ldi	r30, 0xC0	; 192
    37f0:	f1 e0       	ldi	r31, 0x01	; 1
    37f2:	84 85       	ldd	r24, Z+12	; 0x0c
    37f4:	87 7f       	andi	r24, 0xF7	; 247
    37f6:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    37f8:	41 15       	cp	r20, r1
    37fa:	51 05       	cpc	r21, r1
    37fc:	09 f4       	brne	.+2      	; 0x3800 <chb_eeprom_write+0x1c>
    37fe:	50 c0       	rjmp	.+160    	; 0x38a0 <chb_eeprom_write+0xbc>
    3800:	e0 e0       	ldi	r30, 0x00	; 0
    3802:	f0 e0       	ldi	r31, 0x00	; 0
    3804:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3806:	a0 ec       	ldi	r26, 0xC0	; 192
    3808:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    380a:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    380c:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    380e:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3810:	cf 01       	movw	r24, r30
    3812:	80 0f       	add	r24, r16
    3814:	91 1f       	adc	r25, r17
    3816:	e6 0f       	add	r30, r22
    3818:	f7 1f       	adc	r31, r23
    381a:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    381c:	1f 96       	adiw	r26, 0x0f	; 15
    381e:	ec 91       	ld	r30, X
    3820:	1f 97       	sbiw	r26, 0x0f	; 15
    3822:	ee 23       	and	r30, r30
    3824:	dc f3       	brlt	.-10     	; 0x381c <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3826:	1f 96       	adiw	r26, 0x0f	; 15
    3828:	ec 91       	ld	r30, X
    382a:	1f 97       	sbiw	r26, 0x0f	; 15
    382c:	e1 ff       	sbrs	r30, 1
    382e:	11 c0       	rjmp	.+34     	; 0x3852 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3830:	1a 96       	adiw	r26, 0x0a	; 10
    3832:	dc 93       	st	X, r29
    3834:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3836:	ef 93       	push	r30
    3838:	ff 93       	push	r31
    383a:	0f 93       	push	r16
    383c:	2f 93       	push	r18
    383e:	eb ec       	ldi	r30, 0xCB	; 203
    3840:	f1 e0       	ldi	r31, 0x01	; 1
    3842:	08 ed       	ldi	r16, 0xD8	; 216
    3844:	21 e0       	ldi	r18, 0x01	; 1
    3846:	04 bf       	out	0x34, r16	; 52
    3848:	20 83       	st	Z, r18
    384a:	2f 91       	pop	r18
    384c:	0f 91       	pop	r16
    384e:	ff 91       	pop	r31
    3850:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3852:	1a 96       	adiw	r26, 0x0a	; 10
    3854:	cc 93       	st	X, r28
    3856:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3858:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    385a:	89 2f       	mov	r24, r25
    385c:	8f 71       	andi	r24, 0x1F	; 31
    385e:	11 96       	adiw	r26, 0x01	; 1
    3860:	8c 93       	st	X, r24
    3862:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3864:	12 96       	adiw	r26, 0x02	; 2
    3866:	1c 92       	st	X, r1
    3868:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    386a:	14 96       	adiw	r26, 0x04	; 4
    386c:	fc 93       	st	X, r31
    386e:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3870:	1a 96       	adiw	r26, 0x0a	; 10
    3872:	3c 93       	st	X, r19
    3874:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3876:	ef 93       	push	r30
    3878:	ff 93       	push	r31
    387a:	0f 93       	push	r16
    387c:	2f 93       	push	r18
    387e:	eb ec       	ldi	r30, 0xCB	; 203
    3880:	f1 e0       	ldi	r31, 0x01	; 1
    3882:	08 ed       	ldi	r16, 0xD8	; 216
    3884:	21 e0       	ldi	r18, 0x01	; 1
    3886:	04 bf       	out	0x34, r16	; 52
    3888:	20 83       	st	Z, r18
    388a:	2f 91       	pop	r18
    388c:	0f 91       	pop	r16
    388e:	ff 91       	pop	r31
    3890:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3892:	2f 5f       	subi	r18, 0xFF	; 255
    3894:	e2 2f       	mov	r30, r18
    3896:	f0 e0       	ldi	r31, 0x00	; 0
    3898:	e4 17       	cp	r30, r20
    389a:	f5 07       	cpc	r31, r21
    389c:	08 f4       	brcc	.+2      	; 0x38a0 <chb_eeprom_write+0xbc>
    389e:	b8 cf       	rjmp	.-144    	; 0x3810 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    38a0:	df 91       	pop	r29
    38a2:	cf 91       	pop	r28
    38a4:	1f 91       	pop	r17
    38a6:	0f 91       	pop	r16
    38a8:	08 95       	ret

000038aa <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    38aa:	1f 93       	push	r17
    38ac:	cf 93       	push	r28
    38ae:	df 93       	push	r29
    38b0:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    38b2:	e0 ec       	ldi	r30, 0xC0	; 192
    38b4:	f1 e0       	ldi	r31, 0x01	; 1
    38b6:	84 85       	ldd	r24, Z+12	; 0x0c
    38b8:	87 7f       	andi	r24, 0xF7	; 247
    38ba:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    38bc:	41 15       	cp	r20, r1
    38be:	51 05       	cpc	r21, r1
    38c0:	41 f1       	breq	.+80     	; 0x3912 <chb_eeprom_read+0x68>
    38c2:	80 e0       	ldi	r24, 0x00	; 0
    38c4:	90 e0       	ldi	r25, 0x00	; 0
    38c6:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    38c8:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    38ca:	db 01       	movw	r26, r22
    38cc:	a8 0f       	add	r26, r24
    38ce:	b9 1f       	adc	r27, r25
    38d0:	82 0f       	add	r24, r18
    38d2:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    38d4:	17 85       	ldd	r17, Z+15	; 0x0f
    38d6:	11 23       	and	r17, r17
    38d8:	ec f3       	brlt	.-6      	; 0x38d4 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    38da:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    38dc:	89 2f       	mov	r24, r25
    38de:	8f 71       	andi	r24, 0x1F	; 31
    38e0:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    38e2:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    38e4:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    38e6:	ef 93       	push	r30
    38e8:	ff 93       	push	r31
    38ea:	0f 93       	push	r16
    38ec:	2f 93       	push	r18
    38ee:	eb ec       	ldi	r30, 0xCB	; 203
    38f0:	f1 e0       	ldi	r31, 0x01	; 1
    38f2:	08 ed       	ldi	r16, 0xD8	; 216
    38f4:	21 e0       	ldi	r18, 0x01	; 1
    38f6:	04 bf       	out	0x34, r16	; 52
    38f8:	20 83       	st	Z, r18
    38fa:	2f 91       	pop	r18
    38fc:	0f 91       	pop	r16
    38fe:	ff 91       	pop	r31
    3900:	ef 91       	pop	r30

    return NVM.DATA0;
    3902:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3904:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3906:	cf 5f       	subi	r28, 0xFF	; 255
    3908:	8c 2f       	mov	r24, r28
    390a:	90 e0       	ldi	r25, 0x00	; 0
    390c:	84 17       	cp	r24, r20
    390e:	95 07       	cpc	r25, r21
    3910:	e0 f2       	brcs	.-72     	; 0x38ca <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3912:	df 91       	pop	r29
    3914:	cf 91       	pop	r28
    3916:	1f 91       	pop	r17
    3918:	08 95       	ret

0000391a <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    391a:	e0 e6       	ldi	r30, 0x60	; 96
    391c:	f6 e0       	ldi	r31, 0x06	; 6
    391e:	80 81       	ld	r24, Z
    3920:	80 6b       	ori	r24, 0xB0	; 176
    3922:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3924:	e4 e6       	ldi	r30, 0x64	; 100
    3926:	f6 e0       	ldi	r31, 0x06	; 6
    3928:	80 81       	ld	r24, Z
    392a:	80 61       	ori	r24, 0x10	; 16
    392c:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    392e:	a0 ec       	ldi	r26, 0xC0	; 192
    3930:	b9 e0       	ldi	r27, 0x09	; 9
    3932:	8c 91       	ld	r24, X
    3934:	81 65       	ori	r24, 0x51	; 81
    3936:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3938:	80 81       	ld	r24, Z
    393a:	80 61       	ori	r24, 0x10	; 16
    393c:	80 83       	st	Z, r24
}
    393e:	08 95       	ret

00003940 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3940:	e0 ec       	ldi	r30, 0xC0	; 192
    3942:	f9 e0       	ldi	r31, 0x09	; 9
    3944:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3946:	82 81       	ldd	r24, Z+2	; 0x02
    3948:	88 23       	and	r24, r24
    394a:	ec f7       	brge	.-6      	; 0x3946 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    394c:	e0 ec       	ldi	r30, 0xC0	; 192
    394e:	f9 e0       	ldi	r31, 0x09	; 9
    3950:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3952:	08 95       	ret

00003954 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3954:	0f 93       	push	r16
    3956:	cf 93       	push	r28
    3958:	df 93       	push	r29
    395a:	0f 92       	push	r0
    395c:	cd b7       	in	r28, 0x3d	; 61
    395e:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    3960:	2f b7       	in	r18, 0x3f	; 63
    3962:	29 83       	std	Y+1, r18	; 0x01
    3964:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3966:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3968:	fc 01       	movw	r30, r24
    396a:	08 ed       	ldi	r16, 0xD8	; 216
    396c:	04 bf       	out	0x34, r16	; 52
    396e:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3974:	0f 90       	pop	r0
    3976:	df 91       	pop	r29
    3978:	cf 91       	pop	r28
    397a:	0f 91       	pop	r16
    397c:	08 95       	ret

0000397e <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    397e:	66 23       	and	r22, r22
    3980:	11 f0       	breq	.+4      	; 0x3986 <CLKSYS_XOSC_Config+0x8>
    3982:	90 e2       	ldi	r25, 0x20	; 32
    3984:	01 c0       	rjmp	.+2      	; 0x3988 <CLKSYS_XOSC_Config+0xa>
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	84 2b       	or	r24, r20
    398a:	89 2b       	or	r24, r25
    398c:	e0 e5       	ldi	r30, 0x50	; 80
    398e:	f0 e0       	ldi	r31, 0x00	; 0
    3990:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3992:	08 95       	ret

00003994 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3994:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3996:	86 2b       	or	r24, r22
    3998:	e0 e5       	ldi	r30, 0x50	; 80
    399a:	f0 e0       	ldi	r31, 0x00	; 0
    399c:	85 83       	std	Z+5, r24	; 0x05
}
    399e:	08 95       	ret

000039a0 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    39a0:	e0 e5       	ldi	r30, 0x50	; 80
    39a2:	f0 e0       	ldi	r31, 0x00	; 0
    39a4:	90 81       	ld	r25, Z
    39a6:	28 2f       	mov	r18, r24
    39a8:	20 95       	com	r18
    39aa:	92 23       	and	r25, r18
    39ac:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    39ae:	90 81       	ld	r25, Z
	return clkEnabled;
}
    39b0:	89 23       	and	r24, r25
    39b2:	08 95       	ret

000039b4 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    39b4:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    39b6:	81 e4       	ldi	r24, 0x41	; 65
    39b8:	90 e0       	ldi	r25, 0x00	; 0
    39ba:	0e 94 aa 1c 	call	0x3954	; 0x3954 <CCPWrite>
}
    39be:	08 95       	ret

000039c0 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    39c0:	1f 93       	push	r17
    39c2:	cf 93       	push	r28
    39c4:	df 93       	push	r29
    39c6:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    39c8:	c0 e4       	ldi	r28, 0x40	; 64
    39ca:	d0 e0       	ldi	r29, 0x00	; 0
    39cc:	68 81       	ld	r22, Y
    39ce:	68 7f       	andi	r22, 0xF8	; 248
    39d0:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    39d2:	80 e4       	ldi	r24, 0x40	; 64
    39d4:	90 e0       	ldi	r25, 0x00	; 0
    39d6:	0e 94 aa 1c 	call	0x3954	; 0x3954 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    39da:	88 81       	ld	r24, Y
	return clkCtrl;
}
    39dc:	81 23       	and	r24, r17
    39de:	df 91       	pop	r29
    39e0:	cf 91       	pop	r28
    39e2:	1f 91       	pop	r17
    39e4:	08 95       	ret

000039e6 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    39e6:	e0 e4       	ldi	r30, 0x40	; 64
    39e8:	f0 e0       	ldi	r31, 0x00	; 0
    39ea:	93 81       	ldd	r25, Z+3	; 0x03
    39ec:	91 7f       	andi	r25, 0xF1	; 241
    39ee:	91 60       	ori	r25, 0x01	; 1
    39f0:	89 2b       	or	r24, r25
    39f2:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    39f4:	08 95       	ret

000039f6 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    39f6:	e0 e5       	ldi	r30, 0x50	; 80
    39f8:	f0 e0       	ldi	r31, 0x00	; 0
    39fa:	26 81       	ldd	r18, Z+6	; 0x06
    39fc:	98 2f       	mov	r25, r24
    39fe:	38 2f       	mov	r19, r24
    3a00:	30 95       	com	r19
    3a02:	23 23       	and	r18, r19
    3a04:	66 23       	and	r22, r22
    3a06:	09 f4       	brne	.+2      	; 0x3a0a <CLKSYS_AutoCalibration_Enable+0x14>
    3a08:	90 e0       	ldi	r25, 0x00	; 0
    3a0a:	92 2b       	or	r25, r18
    3a0c:	e0 e5       	ldi	r30, 0x50	; 80
    3a0e:	f0 e0       	ldi	r31, 0x00	; 0
    3a10:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3a12:	81 30       	cpi	r24, 0x01	; 1
    3a14:	31 f4       	brne	.+12     	; 0x3a22 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3a16:	e8 e6       	ldi	r30, 0x68	; 104
    3a18:	f0 e0       	ldi	r31, 0x00	; 0
    3a1a:	80 81       	ld	r24, Z
    3a1c:	81 60       	ori	r24, 0x01	; 1
    3a1e:	80 83       	st	Z, r24
    3a20:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3a22:	82 30       	cpi	r24, 0x02	; 2
    3a24:	29 f4       	brne	.+10     	; 0x3a30 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3a26:	e0 e6       	ldi	r30, 0x60	; 96
    3a28:	f0 e0       	ldi	r31, 0x00	; 0
    3a2a:	80 81       	ld	r24, Z
    3a2c:	81 60       	ori	r24, 0x01	; 1
    3a2e:	80 83       	st	Z, r24
    3a30:	08 95       	ret

00003a32 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3a32:	83 e5       	ldi	r24, 0x53	; 83
    3a34:	90 e0       	ldi	r25, 0x00	; 0
    3a36:	63 e0       	ldi	r22, 0x03	; 3
    3a38:	0e 94 aa 1c 	call	0x3954	; 0x3954 <CCPWrite>
}
    3a3c:	08 95       	ret

00003a3e <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    3a3e:	82 e4       	ldi	r24, 0x42	; 66
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	61 e0       	ldi	r22, 0x01	; 1
    3a44:	0e 94 aa 1c 	call	0x3954	; 0x3954 <CCPWrite>
}
    3a48:	08 95       	ret

00003a4a <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    3a4a:	80 ec       	ldi	r24, 0xC0	; 192
    3a4c:	60 e0       	ldi	r22, 0x00	; 0
    3a4e:	4b e0       	ldi	r20, 0x0B	; 11
    3a50:	0e 94 bf 1c 	call	0x397e	; 0x397e <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    3a54:	e0 e5       	ldi	r30, 0x50	; 80
    3a56:	f0 e0       	ldi	r31, 0x00	; 0
    3a58:	80 81       	ld	r24, Z
    3a5a:	88 60       	ori	r24, 0x08	; 8
    3a5c:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    3a5e:	81 81       	ldd	r24, Z+1	; 0x01
    3a60:	83 ff       	sbrs	r24, 3
    3a62:	fd cf       	rjmp	.-6      	; 0x3a5e <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    3a64:	80 ec       	ldi	r24, 0xC0	; 192
    3a66:	62 e0       	ldi	r22, 0x02	; 2
    3a68:	0e 94 ca 1c 	call	0x3994	; 0x3994 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    3a6c:	e0 e5       	ldi	r30, 0x50	; 80
    3a6e:	f0 e0       	ldi	r31, 0x00	; 0
    3a70:	80 81       	ld	r24, Z
    3a72:	80 61       	ori	r24, 0x10	; 16
    3a74:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    3a76:	81 81       	ldd	r24, Z+1	; 0x01
    3a78:	84 ff       	sbrs	r24, 4
    3a7a:	fd cf       	rjmp	.-6      	; 0x3a76 <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    3a7c:	84 e0       	ldi	r24, 0x04	; 4
    3a7e:	0e 94 e0 1c 	call	0x39c0	; 0x39c0 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3a82:	81 e0       	ldi	r24, 0x01	; 1
    3a84:	0e 94 d0 1c 	call	0x39a0	; 0x39a0 <CLKSYS_Disable>
}
    3a88:	08 95       	ret

00003a8a <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3a8a:	e0 e5       	ldi	r30, 0x50	; 80
    3a8c:	f0 e0       	ldi	r31, 0x00	; 0
    3a8e:	80 81       	ld	r24, Z
    3a90:	82 60       	ori	r24, 0x02	; 2
    3a92:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    3a94:	80 e0       	ldi	r24, 0x00	; 0
    3a96:	61 e0       	ldi	r22, 0x01	; 1
    3a98:	0e 94 da 1c 	call	0x39b4	; 0x39b4 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3a9c:	e0 e5       	ldi	r30, 0x50	; 80
    3a9e:	f0 e0       	ldi	r31, 0x00	; 0
    3aa0:	81 81       	ldd	r24, Z+1	; 0x01
    3aa2:	81 ff       	sbrs	r24, 1
    3aa4:	fd cf       	rjmp	.-6      	; 0x3aa0 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3aa6:	81 e0       	ldi	r24, 0x01	; 1
    3aa8:	0e 94 e0 1c 	call	0x39c0	; 0x39c0 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3aac:	81 e0       	ldi	r24, 0x01	; 1
    3aae:	0e 94 d0 1c 	call	0x39a0	; 0x39a0 <CLKSYS_Disable>
	
}
    3ab2:	08 95       	ret

00003ab4 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3ab4:	e0 e5       	ldi	r30, 0x50	; 80
    3ab6:	f0 e0       	ldi	r31, 0x00	; 0
    3ab8:	80 81       	ld	r24, Z
    3aba:	82 60       	ori	r24, 0x02	; 2
    3abc:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    3abe:	80 e0       	ldi	r24, 0x00	; 0
    3ac0:	60 e0       	ldi	r22, 0x00	; 0
    3ac2:	0e 94 da 1c 	call	0x39b4	; 0x39b4 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3ac6:	e0 e5       	ldi	r30, 0x50	; 80
    3ac8:	f0 e0       	ldi	r31, 0x00	; 0
    3aca:	81 81       	ldd	r24, Z+1	; 0x01
    3acc:	81 ff       	sbrs	r24, 1
    3ace:	fd cf       	rjmp	.-6      	; 0x3aca <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3ad0:	81 e0       	ldi	r24, 0x01	; 1
    3ad2:	0e 94 e0 1c 	call	0x39c0	; 0x39c0 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	0e 94 d0 1c 	call	0x39a0	; 0x39a0 <CLKSYS_Disable>
	
}
    3adc:	08 95       	ret

00003ade <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    3ade:	88 23       	and	r24, r24
    3ae0:	29 f0       	breq	.+10     	; 0x3aec <portExCS+0xe>
    3ae2:	88 e0       	ldi	r24, 0x08	; 8
    3ae4:	e0 e0       	ldi	r30, 0x00	; 0
    3ae6:	f6 e0       	ldi	r31, 0x06	; 6
    3ae8:	86 83       	std	Z+6, r24	; 0x06
    3aea:	04 c0       	rjmp	.+8      	; 0x3af4 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    3aec:	88 e0       	ldi	r24, 0x08	; 8
    3aee:	e0 e0       	ldi	r30, 0x00	; 0
    3af0:	f6 e0       	ldi	r31, 0x06	; 6
    3af2:	85 83       	std	Z+5, r24	; 0x05
    3af4:	8a e6       	ldi	r24, 0x6A	; 106
    3af6:	8a 95       	dec	r24
    3af8:	f1 f7       	brne	.-4      	; 0x3af6 <portExCS+0x18>
    3afa:	00 c0       	rjmp	.+0      	; 0x3afc <portExCS+0x1e>
	}
	_delay_us(10);
}
    3afc:	08 95       	ret

00003afe <Ext1Power>:
*/


void Ext1Power(uint8_t on) {
	
	if (on) {
    3afe:	88 23       	and	r24, r24
    3b00:	79 f0       	breq	.+30     	; 0x3b20 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    3b02:	e0 ea       	ldi	r30, 0xA0	; 160
    3b04:	f6 e0       	ldi	r31, 0x06	; 6
    3b06:	80 e2       	ldi	r24, 0x20	; 32
    3b08:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    3b0a:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3b0c:	8f ef       	ldi	r24, 0xFF	; 255
    3b0e:	93 ec       	ldi	r25, 0xC3	; 195
    3b10:	a9 e0       	ldi	r26, 0x09	; 9
    3b12:	81 50       	subi	r24, 0x01	; 1
    3b14:	90 40       	sbci	r25, 0x00	; 0
    3b16:	a0 40       	sbci	r26, 0x00	; 0
    3b18:	e1 f7       	brne	.-8      	; 0x3b12 <Ext1Power+0x14>
    3b1a:	00 c0       	rjmp	.+0      	; 0x3b1c <Ext1Power+0x1e>
    3b1c:	00 00       	nop
    3b1e:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    3b20:	e0 ea       	ldi	r30, 0xA0	; 160
    3b22:	f6 e0       	ldi	r31, 0x06	; 6
    3b24:	80 e2       	ldi	r24, 0x20	; 32
    3b26:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    3b28:	82 83       	std	Z+2, r24	; 0x02
    3b2a:	08 95       	ret

00003b2c <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
    3b2c:	88 23       	and	r24, r24
    3b2e:	79 f0       	breq	.+30     	; 0x3b4e <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    3b30:	e0 ea       	ldi	r30, 0xA0	; 160
    3b32:	f6 e0       	ldi	r31, 0x06	; 6
    3b34:	80 e4       	ldi	r24, 0x40	; 64
    3b36:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    3b38:	85 83       	std	Z+5, r24	; 0x05
    3b3a:	8f ef       	ldi	r24, 0xFF	; 255
    3b3c:	93 ec       	ldi	r25, 0xC3	; 195
    3b3e:	a9 e0       	ldi	r26, 0x09	; 9
    3b40:	81 50       	subi	r24, 0x01	; 1
    3b42:	90 40       	sbci	r25, 0x00	; 0
    3b44:	a0 40       	sbci	r26, 0x00	; 0
    3b46:	e1 f7       	brne	.-8      	; 0x3b40 <Ext2Power+0x14>
    3b48:	00 c0       	rjmp	.+0      	; 0x3b4a <Ext2Power+0x1e>
    3b4a:	00 00       	nop
    3b4c:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    3b4e:	e0 ea       	ldi	r30, 0xA0	; 160
    3b50:	f6 e0       	ldi	r31, 0x06	; 6
    3b52:	80 e4       	ldi	r24, 0x40	; 64
    3b54:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    3b56:	82 83       	std	Z+2, r24	; 0x02
    3b58:	08 95       	ret

00003b5a <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
    3b5a:	88 23       	and	r24, r24
    3b5c:	79 f0       	breq	.+30     	; 0x3b7c <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    3b5e:	e0 ea       	ldi	r30, 0xA0	; 160
    3b60:	f6 e0       	ldi	r31, 0x06	; 6
    3b62:	80 e8       	ldi	r24, 0x80	; 128
    3b64:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    3b66:	85 83       	std	Z+5, r24	; 0x05
    3b68:	8f ef       	ldi	r24, 0xFF	; 255
    3b6a:	93 ec       	ldi	r25, 0xC3	; 195
    3b6c:	a9 e0       	ldi	r26, 0x09	; 9
    3b6e:	81 50       	subi	r24, 0x01	; 1
    3b70:	90 40       	sbci	r25, 0x00	; 0
    3b72:	a0 40       	sbci	r26, 0x00	; 0
    3b74:	e1 f7       	brne	.-8      	; 0x3b6e <HVPower+0x14>
    3b76:	00 c0       	rjmp	.+0      	; 0x3b78 <HVPower+0x1e>
    3b78:	00 00       	nop
    3b7a:	05 c0       	rjmp	.+10     	; 0x3b86 <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    3b7c:	e0 ea       	ldi	r30, 0xA0	; 160
    3b7e:	f6 e0       	ldi	r31, 0x06	; 6
    3b80:	80 e8       	ldi	r24, 0x80	; 128
    3b82:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    3b84:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3b86:	af e3       	ldi	r26, 0x3F	; 63
    3b88:	bf e1       	ldi	r27, 0x1F	; 31
    3b8a:	11 97       	sbiw	r26, 0x01	; 1
    3b8c:	f1 f7       	brne	.-4      	; 0x3b8a <HVPower+0x30>
    3b8e:	00 c0       	rjmp	.+0      	; 0x3b90 <HVPower+0x36>
    3b90:	00 00       	nop
	}
	_delay_us(1000);
}
    3b92:	08 95       	ret

00003b94 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    3b94:	88 23       	and	r24, r24
    3b96:	29 f0       	breq	.+10     	; 0x3ba2 <lowerMuxCS+0xe>
    3b98:	80 e1       	ldi	r24, 0x10	; 16
    3b9a:	e0 e8       	ldi	r30, 0x80	; 128
    3b9c:	f6 e0       	ldi	r31, 0x06	; 6
    3b9e:	86 83       	std	Z+6, r24	; 0x06
    3ba0:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    3ba2:	80 e1       	ldi	r24, 0x10	; 16
    3ba4:	e0 e8       	ldi	r30, 0x80	; 128
    3ba6:	f6 e0       	ldi	r31, 0x06	; 6
    3ba8:	85 83       	std	Z+5, r24	; 0x05
    3baa:	08 95       	ret

00003bac <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    3bac:	88 23       	and	r24, r24
    3bae:	29 f0       	breq	.+10     	; 0x3bba <upperMuxCS+0xe>
    3bb0:	82 e0       	ldi	r24, 0x02	; 2
    3bb2:	e0 e4       	ldi	r30, 0x40	; 64
    3bb4:	f6 e0       	ldi	r31, 0x06	; 6
    3bb6:	86 83       	std	Z+6, r24	; 0x06
    3bb8:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    3bba:	82 e0       	ldi	r24, 0x02	; 2
    3bbc:	e0 e4       	ldi	r30, 0x40	; 64
    3bbe:	f6 e0       	ldi	r31, 0x06	; 6
    3bc0:	85 83       	std	Z+5, r24	; 0x05
    3bc2:	08 95       	ret

00003bc4 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3bc4:	e0 e4       	ldi	r30, 0x40	; 64
    3bc6:	f6 e0       	ldi	r31, 0x06	; 6
    3bc8:	90 e1       	ldi	r25, 0x10	; 16
    3bca:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3bcc:	28 e3       	ldi	r18, 0x38	; 56
    3bce:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3bd0:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    3bd2:	81 65       	ori	r24, 0x51	; 81
    3bd4:	a0 ec       	ldi	r26, 0xC0	; 192
    3bd6:	b8 e0       	ldi	r27, 0x08	; 8
    3bd8:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3bda:	11 96       	adiw	r26, 0x01	; 1
    3bdc:	1c 92       	st	X, r1
    3bde:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3be0:	80 ea       	ldi	r24, 0xA0	; 160
    3be2:	81 83       	std	Z+1, r24	; 0x01

	
}
    3be4:	08 95       	ret

00003be6 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3be6:	e0 e4       	ldi	r30, 0x40	; 64
    3be8:	f6 e0       	ldi	r31, 0x06	; 6
    3bea:	90 e1       	ldi	r25, 0x10	; 16
    3bec:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3bee:	28 e3       	ldi	r18, 0x38	; 56
    3bf0:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3bf2:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    3bf4:	80 65       	ori	r24, 0x50	; 80
    3bf6:	68 2b       	or	r22, r24
    3bf8:	a0 ec       	ldi	r26, 0xC0	; 192
    3bfa:	b8 e0       	ldi	r27, 0x08	; 8
    3bfc:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3bfe:	11 96       	adiw	r26, 0x01	; 1
    3c00:	1c 92       	st	X, r1
    3c02:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3c04:	80 ea       	ldi	r24, 0xA0	; 160
    3c06:	81 83       	std	Z+1, r24	; 0x01
}
    3c08:	08 95       	ret

00003c0a <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    3c0a:	88 23       	and	r24, r24
    3c0c:	29 f0       	breq	.+10     	; 0x3c18 <SPICS+0xe>
    3c0e:	80 e1       	ldi	r24, 0x10	; 16
    3c10:	e0 e4       	ldi	r30, 0x40	; 64
    3c12:	f6 e0       	ldi	r31, 0x06	; 6
    3c14:	86 83       	std	Z+6, r24	; 0x06
    3c16:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    3c18:	80 e1       	ldi	r24, 0x10	; 16
    3c1a:	e0 e4       	ldi	r30, 0x40	; 64
    3c1c:	f6 e0       	ldi	r31, 0x06	; 6
    3c1e:	85 83       	std	Z+5, r24	; 0x05
    3c20:	08 95       	ret

00003c22 <SPIDisable>:
	}	
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
    3c22:	e0 e4       	ldi	r30, 0x40	; 64
    3c24:	f6 e0       	ldi	r31, 0x06	; 6
    3c26:	80 e1       	ldi	r24, 0x10	; 16
    3c28:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    3c2a:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    3c2e:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    3c30:	80 eb       	ldi	r24, 0xB0	; 176
    3c32:	82 83       	std	Z+2, r24	; 0x02

}
    3c34:	08 95       	ret

00003c36 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3c36:	cf 93       	push	r28
    3c38:	df 93       	push	r29
    3c3a:	c8 2f       	mov	r28, r24
    3c3c:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3c3e:	80 e0       	ldi	r24, 0x00	; 0
    3c40:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    3c44:	81 e0       	ldi	r24, 0x01	; 1
    3c46:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	portExCS(TRUE);
    3c4a:	81 e0       	ldi	r24, 0x01	; 1
    3c4c:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    3c50:	dd 23       	and	r29, r29
    3c52:	89 f0       	breq	.+34     	; 0x3c76 <PortEx_OUTCLR+0x40>
    3c54:	80 91 d6 23 	lds	r24, 0x23D6
    3c58:	c0 95       	com	r28
    3c5a:	c8 23       	and	r28, r24
    3c5c:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    3c60:	80 e4       	ldi	r24, 0x40	; 64
    3c62:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3c66:	84 e1       	ldi	r24, 0x14	; 20
    3c68:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3c6c:	80 91 d6 23 	lds	r24, 0x23D6
    3c70:	80 93 67 50 	sts	0x5067, r24
    3c74:	10 c0       	rjmp	.+32     	; 0x3c96 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    3c76:	80 91 82 50 	lds	r24, 0x5082
    3c7a:	c0 95       	com	r28
    3c7c:	c8 23       	and	r28, r24
    3c7e:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3c82:	80 e4       	ldi	r24, 0x40	; 64
    3c84:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3c88:	85 e1       	ldi	r24, 0x15	; 21
    3c8a:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3c8e:	80 91 82 50 	lds	r24, 0x5082
    3c92:	80 93 67 50 	sts	0x5067, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3c96:	80 e0       	ldi	r24, 0x00	; 0
    3c98:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3c9a:	25 e6       	ldi	r18, 0x65	; 101
    3c9c:	30 e5       	ldi	r19, 0x50	; 80
    3c9e:	a0 ec       	ldi	r26, 0xC0	; 192
    3ca0:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3ca2:	c1 e7       	ldi	r28, 0x71	; 113
    3ca4:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3ca6:	f9 01       	movw	r30, r18
    3ca8:	e8 0f       	add	r30, r24
    3caa:	f9 1f       	adc	r31, r25
    3cac:	40 81       	ld	r20, Z
    3cae:	13 96       	adiw	r26, 0x03	; 3
    3cb0:	4c 93       	st	X, r20
    3cb2:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3cb4:	12 96       	adiw	r26, 0x02	; 2
    3cb6:	4c 91       	ld	r20, X
    3cb8:	12 97       	sbiw	r26, 0x02	; 2
    3cba:	44 23       	and	r20, r20
    3cbc:	dc f7       	brge	.-10     	; 0x3cb4 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    3cbe:	13 96       	adiw	r26, 0x03	; 3
    3cc0:	4c 91       	ld	r20, X
    3cc2:	13 97       	sbiw	r26, 0x03	; 3
    3cc4:	48 83       	st	Y, r20
    3cc6:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3cc8:	83 30       	cpi	r24, 0x03	; 3
    3cca:	91 05       	cpc	r25, r1
    3ccc:	61 f7       	brne	.-40     	; 0x3ca6 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3cce:	80 e0       	ldi	r24, 0x00	; 0
    3cd0:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	portExCS(FALSE);
    3cd4:	80 e0       	ldi	r24, 0x00	; 0
    3cd6:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>
	SPIDisable();
    3cda:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
}
    3cde:	df 91       	pop	r29
    3ce0:	cf 91       	pop	r28
    3ce2:	08 95       	ret

00003ce4 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3ce4:	cf 93       	push	r28
    3ce6:	df 93       	push	r29
    3ce8:	c8 2f       	mov	r28, r24
    3cea:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3cec:	80 e0       	ldi	r24, 0x00	; 0
    3cee:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    3cf2:	81 e0       	ldi	r24, 0x01	; 1
    3cf4:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	portExCS(TRUE);
    3cf8:	81 e0       	ldi	r24, 0x01	; 1
    3cfa:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    3cfe:	dd 23       	and	r29, r29
    3d00:	81 f0       	breq	.+32     	; 0x3d22 <PortEx_OUTSET+0x3e>
    3d02:	80 91 d6 23 	lds	r24, 0x23D6
    3d06:	c8 2b       	or	r28, r24
    3d08:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    3d0c:	80 e4       	ldi	r24, 0x40	; 64
    3d0e:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3d12:	84 e1       	ldi	r24, 0x14	; 20
    3d14:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3d18:	80 91 d6 23 	lds	r24, 0x23D6
    3d1c:	80 93 67 50 	sts	0x5067, r24
    3d20:	0f c0       	rjmp	.+30     	; 0x3d40 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    3d22:	80 91 82 50 	lds	r24, 0x5082
    3d26:	c8 2b       	or	r28, r24
    3d28:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3d2c:	80 e4       	ldi	r24, 0x40	; 64
    3d2e:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3d32:	85 e1       	ldi	r24, 0x15	; 21
    3d34:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3d38:	80 91 82 50 	lds	r24, 0x5082
    3d3c:	80 93 67 50 	sts	0x5067, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3d40:	80 e0       	ldi	r24, 0x00	; 0
    3d42:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3d44:	25 e6       	ldi	r18, 0x65	; 101
    3d46:	30 e5       	ldi	r19, 0x50	; 80
    3d48:	a0 ec       	ldi	r26, 0xC0	; 192
    3d4a:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3d4c:	c1 e7       	ldi	r28, 0x71	; 113
    3d4e:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3d50:	f9 01       	movw	r30, r18
    3d52:	e8 0f       	add	r30, r24
    3d54:	f9 1f       	adc	r31, r25
    3d56:	40 81       	ld	r20, Z
    3d58:	13 96       	adiw	r26, 0x03	; 3
    3d5a:	4c 93       	st	X, r20
    3d5c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3d5e:	12 96       	adiw	r26, 0x02	; 2
    3d60:	4c 91       	ld	r20, X
    3d62:	12 97       	sbiw	r26, 0x02	; 2
    3d64:	44 23       	and	r20, r20
    3d66:	dc f7       	brge	.-10     	; 0x3d5e <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3d68:	13 96       	adiw	r26, 0x03	; 3
    3d6a:	4c 91       	ld	r20, X
    3d6c:	13 97       	sbiw	r26, 0x03	; 3
    3d6e:	48 83       	st	Y, r20
    3d70:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3d72:	83 30       	cpi	r24, 0x03	; 3
    3d74:	91 05       	cpc	r25, r1
    3d76:	61 f7       	brne	.-40     	; 0x3d50 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3d78:	80 e0       	ldi	r24, 0x00	; 0
    3d7a:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	portExCS(FALSE);
    3d7e:	80 e0       	ldi	r24, 0x00	; 0
    3d80:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>
	SPIDisable();
    3d84:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
}
    3d88:	df 91       	pop	r29
    3d8a:	cf 91       	pop	r28
    3d8c:	08 95       	ret

00003d8e <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3d8e:	cf 93       	push	r28
    3d90:	df 93       	push	r29
    3d92:	c8 2f       	mov	r28, r24
    3d94:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3d96:	80 e0       	ldi	r24, 0x00	; 0
    3d98:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    3d9c:	81 e0       	ldi	r24, 0x01	; 1
    3d9e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	portExCS(TRUE);
    3da2:	81 e0       	ldi	r24, 0x01	; 1
    3da4:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    3da8:	dd 23       	and	r29, r29
    3daa:	89 f0       	breq	.+34     	; 0x3dce <PortEx_DIRCLR+0x40>
    3dac:	80 91 7a 50 	lds	r24, 0x507A
    3db0:	80 95       	com	r24
    3db2:	c8 23       	and	r28, r24
    3db4:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3db8:	80 e4       	ldi	r24, 0x40	; 64
    3dba:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3dbe:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3dc2:	80 91 7a 50 	lds	r24, 0x507A
    3dc6:	80 95       	com	r24
    3dc8:	80 93 67 50 	sts	0x5067, r24
    3dcc:	11 c0       	rjmp	.+34     	; 0x3df0 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    3dce:	80 91 ce 50 	lds	r24, 0x50CE
    3dd2:	80 95       	com	r24
    3dd4:	c8 23       	and	r28, r24
    3dd6:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3dda:	80 e4       	ldi	r24, 0x40	; 64
    3ddc:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3de0:	81 e0       	ldi	r24, 0x01	; 1
    3de2:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3de6:	80 91 ce 50 	lds	r24, 0x50CE
    3dea:	80 95       	com	r24
    3dec:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3df0:	80 e0       	ldi	r24, 0x00	; 0
    3df2:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3df4:	25 e6       	ldi	r18, 0x65	; 101
    3df6:	30 e5       	ldi	r19, 0x50	; 80
    3df8:	a0 ec       	ldi	r26, 0xC0	; 192
    3dfa:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3dfc:	c1 e7       	ldi	r28, 0x71	; 113
    3dfe:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3e00:	f9 01       	movw	r30, r18
    3e02:	e8 0f       	add	r30, r24
    3e04:	f9 1f       	adc	r31, r25
    3e06:	40 81       	ld	r20, Z
    3e08:	13 96       	adiw	r26, 0x03	; 3
    3e0a:	4c 93       	st	X, r20
    3e0c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3e0e:	12 96       	adiw	r26, 0x02	; 2
    3e10:	4c 91       	ld	r20, X
    3e12:	12 97       	sbiw	r26, 0x02	; 2
    3e14:	44 23       	and	r20, r20
    3e16:	dc f7       	brge	.-10     	; 0x3e0e <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    3e18:	13 96       	adiw	r26, 0x03	; 3
    3e1a:	4c 91       	ld	r20, X
    3e1c:	13 97       	sbiw	r26, 0x03	; 3
    3e1e:	48 83       	st	Y, r20
    3e20:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3e22:	83 30       	cpi	r24, 0x03	; 3
    3e24:	91 05       	cpc	r25, r1
    3e26:	61 f7       	brne	.-40     	; 0x3e00 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3e28:	80 e0       	ldi	r24, 0x00	; 0
    3e2a:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	portExCS(FALSE);
    3e2e:	80 e0       	ldi	r24, 0x00	; 0
    3e30:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>
	SPIDisable();
    3e34:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
}
    3e38:	df 91       	pop	r29
    3e3a:	cf 91       	pop	r28
    3e3c:	08 95       	ret

00003e3e <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3e3e:	cf 93       	push	r28
    3e40:	df 93       	push	r29
    3e42:	c8 2f       	mov	r28, r24
    3e44:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3e46:	80 e0       	ldi	r24, 0x00	; 0
    3e48:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    3e4c:	81 e0       	ldi	r24, 0x01	; 1
    3e4e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	portExCS(TRUE);
    3e52:	81 e0       	ldi	r24, 0x01	; 1
    3e54:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    3e58:	dd 23       	and	r29, r29
    3e5a:	81 f0       	breq	.+32     	; 0x3e7c <PortEx_DIRSET+0x3e>
    3e5c:	80 91 7a 50 	lds	r24, 0x507A
    3e60:	c8 2b       	or	r28, r24
    3e62:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3e66:	80 e4       	ldi	r24, 0x40	; 64
    3e68:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3e6c:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3e70:	80 91 7a 50 	lds	r24, 0x507A
    3e74:	80 95       	com	r24
    3e76:	80 93 67 50 	sts	0x5067, r24
    3e7a:	10 c0       	rjmp	.+32     	; 0x3e9c <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    3e7c:	80 91 ce 50 	lds	r24, 0x50CE
    3e80:	c8 2b       	or	r28, r24
    3e82:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3e86:	80 e4       	ldi	r24, 0x40	; 64
    3e88:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3e8c:	81 e0       	ldi	r24, 0x01	; 1
    3e8e:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3e92:	80 91 ce 50 	lds	r24, 0x50CE
    3e96:	80 95       	com	r24
    3e98:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3e9c:	80 e0       	ldi	r24, 0x00	; 0
    3e9e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3ea0:	25 e6       	ldi	r18, 0x65	; 101
    3ea2:	30 e5       	ldi	r19, 0x50	; 80
    3ea4:	a0 ec       	ldi	r26, 0xC0	; 192
    3ea6:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3ea8:	c1 e7       	ldi	r28, 0x71	; 113
    3eaa:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3eac:	f9 01       	movw	r30, r18
    3eae:	e8 0f       	add	r30, r24
    3eb0:	f9 1f       	adc	r31, r25
    3eb2:	40 81       	ld	r20, Z
    3eb4:	13 96       	adiw	r26, 0x03	; 3
    3eb6:	4c 93       	st	X, r20
    3eb8:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    3eba:	12 96       	adiw	r26, 0x02	; 2
    3ebc:	4c 91       	ld	r20, X
    3ebe:	12 97       	sbiw	r26, 0x02	; 2
    3ec0:	44 23       	and	r20, r20
    3ec2:	dc f7       	brge	.-10     	; 0x3eba <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3ec4:	13 96       	adiw	r26, 0x03	; 3
    3ec6:	4c 91       	ld	r20, X
    3ec8:	13 97       	sbiw	r26, 0x03	; 3
    3eca:	48 83       	st	Y, r20
    3ecc:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3ece:	83 30       	cpi	r24, 0x03	; 3
    3ed0:	91 05       	cpc	r25, r1
    3ed2:	61 f7       	brne	.-40     	; 0x3eac <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    3ed4:	80 e0       	ldi	r24, 0x00	; 0
    3ed6:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <portExCS>
	SPICS(FALSE);
    3eda:	80 e0       	ldi	r24, 0x00	; 0
    3edc:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    3ee0:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>


}
    3ee4:	df 91       	pop	r29
    3ee6:	cf 91       	pop	r28
    3ee8:	08 95       	ret

00003eea <readFRAM>:

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3eea:	0f 93       	push	r16
    3eec:	1f 93       	push	r17
    3eee:	cf 93       	push	r28
    3ef0:	df 93       	push	r29
    3ef2:	8c 01       	movw	r16, r24
	
	SPIInit(SPI_MODE_0_gc);
    3ef4:	80 e0       	ldi	r24, 0x00	; 0
    3ef6:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3efa:	c0 ec       	ldi	r28, 0xC0	; 192
    3efc:	d8 e0       	ldi	r29, 0x08	; 8
    3efe:	80 ed       	ldi	r24, 0xD0	; 208
    3f00:	88 83       	st	Y, r24
	SPICS(TRUE);
    3f02:	81 e0       	ldi	r24, 0x01	; 1
    3f04:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3f08:	88 e0       	ldi	r24, 0x08	; 8
    3f0a:	e0 e2       	ldi	r30, 0x20	; 32
    3f0c:	f6 e0       	ldi	r31, 0x06	; 6
    3f0e:	86 83       	std	Z+6, r24	; 0x06
	nop();
    3f10:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    3f12:	83 e0       	ldi	r24, 0x03	; 3
    3f14:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3f16:	e0 ec       	ldi	r30, 0xC0	; 192
    3f18:	f8 e0       	ldi	r31, 0x08	; 8
    3f1a:	82 81       	ldd	r24, Z+2	; 0x02
    3f1c:	88 23       	and	r24, r24
    3f1e:	ec f7       	brge	.-6      	; 0x3f1a <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    3f20:	e0 ec       	ldi	r30, 0xC0	; 192
    3f22:	f8 e0       	ldi	r31, 0x08	; 8
    3f24:	83 81       	ldd	r24, Z+3	; 0x03
    3f26:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    3f2a:	80 91 58 40 	lds	r24, 0x4058
    3f2e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3f30:	82 81       	ldd	r24, Z+2	; 0x02
    3f32:	88 23       	and	r24, r24
    3f34:	ec f7       	brge	.-6      	; 0x3f30 <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    3f36:	e0 ec       	ldi	r30, 0xC0	; 192
    3f38:	f8 e0       	ldi	r31, 0x08	; 8
    3f3a:	83 81       	ldd	r24, Z+3	; 0x03
    3f3c:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    3f40:	80 91 57 40 	lds	r24, 0x4057
    3f44:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3f46:	82 81       	ldd	r24, Z+2	; 0x02
    3f48:	88 23       	and	r24, r24
    3f4a:	ec f7       	brge	.-6      	; 0x3f46 <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3f4c:	e0 ec       	ldi	r30, 0xC0	; 192
    3f4e:	f8 e0       	ldi	r31, 0x08	; 8
    3f50:	83 81       	ldd	r24, Z+3	; 0x03
    3f52:	80 93 71 50 	sts	0x5071, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3f56:	01 15       	cp	r16, r1
    3f58:	11 05       	cpc	r17, r1
    3f5a:	b1 f0       	breq	.+44     	; 0x3f88 <readFRAM+0x9e>
    3f5c:	ef ed       	ldi	r30, 0xDF	; 223
    3f5e:	f3 e2       	ldi	r31, 0x23	; 35

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3f60:	0e 0f       	add	r16, r30
    3f62:	1f 1f       	adc	r17, r31
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    3f64:	a0 ec       	ldi	r26, 0xC0	; 192
    3f66:	b8 e0       	ldi	r27, 0x08	; 8
    3f68:	9a ea       	ldi	r25, 0xAA	; 170
    3f6a:	13 96       	adiw	r26, 0x03	; 3
    3f6c:	9c 93       	st	X, r25
    3f6e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3f70:	12 96       	adiw	r26, 0x02	; 2
    3f72:	8c 91       	ld	r24, X
    3f74:	12 97       	sbiw	r26, 0x02	; 2
    3f76:	88 23       	and	r24, r24
    3f78:	dc f7       	brge	.-10     	; 0x3f70 <readFRAM+0x86>
		FRAMReadBuffer[i] = SPIC.DATA;
    3f7a:	13 96       	adiw	r26, 0x03	; 3
    3f7c:	8c 91       	ld	r24, X
    3f7e:	13 97       	sbiw	r26, 0x03	; 3
    3f80:	81 93       	st	Z+, r24
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3f82:	e0 17       	cp	r30, r16
    3f84:	f1 07       	cpc	r31, r17
    3f86:	89 f7       	brne	.-30     	; 0x3f6a <readFRAM+0x80>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    3f88:	88 e0       	ldi	r24, 0x08	; 8
    3f8a:	e0 e2       	ldi	r30, 0x20	; 32
    3f8c:	f6 e0       	ldi	r31, 0x06	; 6
    3f8e:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    3f90:	80 e0       	ldi	r24, 0x00	; 0
    3f92:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    3f96:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>

}
    3f9a:	df 91       	pop	r29
    3f9c:	cf 91       	pop	r28
    3f9e:	1f 91       	pop	r17
    3fa0:	0f 91       	pop	r16
    3fa2:	08 95       	ret

00003fa4 <FRAMTest3Channel>:
//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3fa4:	81 e0       	ldi	r24, 0x01	; 1
    3fa6:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
    3faa:	8f ec       	ldi	r24, 0xCF	; 207
    3fac:	97 e0       	ldi	r25, 0x07	; 7
    3fae:	01 97       	sbiw	r24, 0x01	; 1
    3fb0:	f1 f7       	brne	.-4      	; 0x3fae <FRAMTest3Channel+0xa>
    3fb2:	00 c0       	rjmp	.+0      	; 0x3fb4 <FRAMTest3Channel+0x10>
    3fb4:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3fb6:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <calcChecksumFRAM>

	ADCPower(FALSE);
    3fba:	80 e0       	ldi	r24, 0x00	; 0
    3fbc:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	
}
    3fc0:	08 95       	ret

00003fc2 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3fc2:	81 e0       	ldi	r24, 0x01	; 1
    3fc4:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
    3fc8:	8f ec       	ldi	r24, 0xCF	; 207
    3fca:	97 e0       	ldi	r25, 0x07	; 7
    3fcc:	01 97       	sbiw	r24, 0x01	; 1
    3fce:	f1 f7       	brne	.-4      	; 0x3fcc <FRAMTest1Channel+0xa>
    3fd0:	00 c0       	rjmp	.+0      	; 0x3fd2 <FRAMTest1Channel+0x10>
    3fd2:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3fd4:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <calcChecksumFRAM>

	ADCPower(FALSE);
    3fd8:	80 e0       	ldi	r24, 0x00	; 0
    3fda:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>

}
    3fde:	08 95       	ret

00003fe0 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
	
	FRAMWriteKnowns();
    3fe0:	0e 94 8d 11 	call	0x231a	; 0x231a <FRAMWriteKnowns>
	ADCPower(TRUE);
    3fe4:	81 e0       	ldi	r24, 0x01	; 1
    3fe6:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
    3fea:	8f ec       	ldi	r24, 0xCF	; 207
    3fec:	97 e0       	ldi	r25, 0x07	; 7
    3fee:	01 97       	sbiw	r24, 0x01	; 1
    3ff0:	f1 f7       	brne	.-4      	; 0x3fee <FRAMWriteKnownsCheck+0xe>
    3ff2:	00 c0       	rjmp	.+0      	; 0x3ff4 <FRAMWriteKnownsCheck+0x14>
    3ff4:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    3ff6:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <calcChecksumFRAM>

	ADCPower(FALSE);
    3ffa:	80 e0       	ldi	r24, 0x00	; 0
    3ffc:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>

}
    4000:	08 95       	ret

00004002 <checkMote>:

//random function for testing stuff	
void checkMote(){
	
	ADCPower(TRUE);
    4002:	81 e0       	ldi	r24, 0x01	; 1
    4004:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	Ext1Power(TRUE);
    4008:	81 e0       	ldi	r24, 0x01	; 1
    400a:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    400e:	8f ef       	ldi	r24, 0xFF	; 255
    4010:	93 ec       	ldi	r25, 0xC3	; 195
    4012:	a9 e0       	ldi	r26, 0x09	; 9
    4014:	81 50       	subi	r24, 0x01	; 1
    4016:	90 40       	sbci	r25, 0x00	; 0
    4018:	a0 40       	sbci	r26, 0x00	; 0
    401a:	e1 f7       	brne	.-8      	; 0x4014 <checkMote+0x12>
    401c:	00 c0       	rjmp	.+0      	; 0x401e <checkMote+0x1c>
    401e:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    4020:	88 e0       	ldi	r24, 0x08	; 8
    4022:	60 e0       	ldi	r22, 0x00	; 0
    4024:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    4028:	88 e0       	ldi	r24, 0x08	; 8
    402a:	60 e0       	ldi	r22, 0x00	; 0
    402c:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
    4030:	8a ea       	ldi	r24, 0xAA	; 170
    4032:	96 ee       	ldi	r25, 0xE6	; 230
    4034:	a6 e9       	ldi	r26, 0x96	; 150
    4036:	b1 e0       	ldi	r27, 0x01	; 1
    4038:	81 50       	subi	r24, 0x01	; 1
    403a:	90 40       	sbci	r25, 0x00	; 0
    403c:	a0 40       	sbci	r26, 0x00	; 0
    403e:	b0 40       	sbci	r27, 0x00	; 0
    4040:	d9 f7       	brne	.-10     	; 0x4038 <checkMote+0x36>
    4042:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    4044:	88 e0       	ldi	r24, 0x08	; 8
    4046:	60 e0       	ldi	r22, 0x00	; 0
    4048:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <PortEx_OUTCLR>
    404c:	8a ea       	ldi	r24, 0xAA	; 170
    404e:	96 ee       	ldi	r25, 0xE6	; 230
    4050:	a6 e9       	ldi	r26, 0x96	; 150
    4052:	b1 e0       	ldi	r27, 0x01	; 1
    4054:	81 50       	subi	r24, 0x01	; 1
    4056:	90 40       	sbci	r25, 0x00	; 0
    4058:	a0 40       	sbci	r26, 0x00	; 0
    405a:	b0 40       	sbci	r27, 0x00	; 0
    405c:	d9 f7       	brne	.-10     	; 0x4054 <checkMote+0x52>
    405e:	00 00       	nop
    4060:	e3 cf       	rjmp	.-58     	; 0x4028 <checkMote+0x26>

00004062 <SD_write_and_read_knowns>:
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    4062:	0f 93       	push	r16
    4064:	1f 93       	push	r17
    4066:	cf 93       	push	r28
    4068:	df 93       	push	r29
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    406a:	0f ed       	ldi	r16, 0xDF	; 223
    406c:	13 e2       	ldi	r17, 0x23	; 35
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    406e:	f8 01       	movw	r30, r16
    4070:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    4072:	81 93       	st	Z+, r24
    4074:	8f 5f       	subi	r24, 0xFF	; 255
    4076:	88 31       	cpi	r24, 0x18	; 24
    4078:	e1 f7       	brne	.-8      	; 0x4072 <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    407a:	cf ed       	ldi	r28, 0xDF	; 223
    407c:	d3 e2       	ldi	r29, 0x23	; 35
    407e:	64 e1       	ldi	r22, 0x14	; 20
    4080:	70 e0       	ldi	r23, 0x00	; 0
    4082:	80 e0       	ldi	r24, 0x00	; 0
    4084:	90 e0       	ldi	r25, 0x00	; 0
    4086:	ae 01       	movw	r20, r28
    4088:	28 e1       	ldi	r18, 0x18	; 24
    408a:	30 e0       	ldi	r19, 0x00	; 0
    408c:	0e 94 5f 2c 	call	0x58be	; 0x58be <SD_write_block>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    4090:	68 96       	adiw	r28, 0x18	; 24
    4092:	f8 01       	movw	r30, r16
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    4094:	11 92       	st	Z+, r1
    4096:	ec 17       	cp	r30, r28
    4098:	fd 07       	cpc	r31, r29
    409a:	e1 f7       	brne	.-8      	; 0x4094 <SD_write_and_read_knowns+0x32>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    409c:	64 e1       	ldi	r22, 0x14	; 20
    409e:	70 e0       	ldi	r23, 0x00	; 0
    40a0:	80 e0       	ldi	r24, 0x00	; 0
    40a2:	90 e0       	ldi	r25, 0x00	; 0
    40a4:	4f ed       	ldi	r20, 0xDF	; 223
    40a6:	53 e2       	ldi	r21, 0x23	; 35
    40a8:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
    40ac:	f8 01       	movw	r30, r16
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    40ae:	20 e0       	ldi	r18, 0x00	; 0
    40b0:	30 e0       	ldi	r19, 0x00	; 0
    40b2:	c4 e6       	ldi	r28, 0x64	; 100
    40b4:	d0 e0       	ldi	r29, 0x00	; 0
    40b6:	c9 01       	movw	r24, r18
    40b8:	be 01       	movw	r22, r28
    40ba:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    40be:	81 93       	st	Z+, r24
    40c0:	2f 5f       	subi	r18, 0xFF	; 255
    40c2:	3f 4f       	sbci	r19, 0xFF	; 255
    40c4:	84 e0       	ldi	r24, 0x04	; 4
    40c6:	22 3e       	cpi	r18, 0xE2	; 226
    40c8:	38 07       	cpc	r19, r24
    40ca:	a9 f7       	brne	.-22     	; 0x40b6 <SD_write_and_read_knowns+0x54>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    40cc:	60 e5       	ldi	r22, 0x50	; 80
    40ce:	70 e0       	ldi	r23, 0x00	; 0
    40d0:	80 e0       	ldi	r24, 0x00	; 0
    40d2:	90 e0       	ldi	r25, 0x00	; 0
    40d4:	4f ed       	ldi	r20, 0xDF	; 223
    40d6:	53 e2       	ldi	r21, 0x23	; 35
    40d8:	22 ee       	ldi	r18, 0xE2	; 226
    40da:	34 e0       	ldi	r19, 0x04	; 4
    40dc:	0e 94 7b 2d 	call	0x5af6	; 0x5af6 <SD_write_multiple_blocks>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    40e0:	81 ec       	ldi	r24, 0xC1	; 193
    40e2:	98 e2       	ldi	r25, 0x28	; 40
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    40e4:	f8 01       	movw	r30, r16
    40e6:	11 92       	st	Z+, r1
    40e8:	8f 01       	movw	r16, r30
    40ea:	e8 17       	cp	r30, r24
    40ec:	f9 07       	cpc	r31, r25
    40ee:	d1 f7       	brne	.-12     	; 0x40e4 <SD_write_and_read_knowns+0x82>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    40f0:	60 e5       	ldi	r22, 0x50	; 80
    40f2:	70 e0       	ldi	r23, 0x00	; 0
    40f4:	80 e0       	ldi	r24, 0x00	; 0
    40f6:	90 e0       	ldi	r25, 0x00	; 0
    40f8:	4f ed       	ldi	r20, 0xDF	; 223
    40fa:	53 e2       	ldi	r21, 0x23	; 35
    40fc:	23 e0       	ldi	r18, 0x03	; 3
    40fe:	30 e0       	ldi	r19, 0x00	; 0
    4100:	0e 94 d5 2e 	call	0x5daa	; 0x5daa <SD_read_multiple_blocks>
}
    4104:	df 91       	pop	r29
    4106:	cf 91       	pop	r28
    4108:	1f 91       	pop	r17
    410a:	0f 91       	pop	r16
    410c:	08 95       	ret

0000410e <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    410e:	0f 93       	push	r16
    4110:	1f 93       	push	r17
    4112:	cf 93       	push	r28
    4114:	df 93       	push	r29
    4116:	0f ed       	ldi	r16, 0xDF	; 223
    4118:	13 e2       	ldi	r17, 0x23	; 35
    411a:	f8 01       	movw	r30, r16
    411c:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    411e:	81 93       	st	Z+, r24
    4120:	8f 5f       	subi	r24, 0xFF	; 255
    4122:	88 31       	cpi	r24, 0x18	; 24
    4124:	e1 f7       	brne	.-8      	; 0x411e <SD_write_and_read_knowns_FAT+0x10>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    4126:	cf ed       	ldi	r28, 0xDF	; 223
    4128:	d3 e2       	ldi	r29, 0x23	; 35
    412a:	86 e1       	ldi	r24, 0x16	; 22
    412c:	90 e2       	ldi	r25, 0x20	; 32
    412e:	be 01       	movw	r22, r28
    4130:	20 e0       	ldi	r18, 0x00	; 0
    4132:	32 e0       	ldi	r19, 0x02	; 2
    4134:	40 e0       	ldi	r20, 0x00	; 0
    4136:	50 e0       	ldi	r21, 0x00	; 0
    4138:	0e 94 4c 28 	call	0x5098	; 0x5098 <writeFile>
    413c:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
}

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    4140:	68 96       	adiw	r28, 0x18	; 24
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    4142:	f8 01       	movw	r30, r16
    4144:	11 92       	st	Z+, r1
    4146:	8f 01       	movw	r16, r30
    4148:	ec 17       	cp	r30, r28
    414a:	fd 07       	cpc	r31, r29
    414c:	d1 f7       	brne	.-12     	; 0x4142 <SD_write_and_read_knowns_FAT+0x34>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    414e:	80 e0       	ldi	r24, 0x00	; 0
    4150:	66 e1       	ldi	r22, 0x16	; 22
    4152:	70 e2       	ldi	r23, 0x20	; 32
    4154:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <readFile>
    4158:	80 93 a3 50 	sts	0x50A3, r24
}
    415c:	df 91       	pop	r29
    415e:	cf 91       	pop	r28
    4160:	1f 91       	pop	r17
    4162:	0f 91       	pop	r16
    4164:	08 95       	ret

00004166 <chibi_test_radio>:


//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    4166:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <chb_init>
	chb_set_short_addr(0x0002);
    416a:	82 e0       	ldi	r24, 0x02	; 2
    416c:	90 e0       	ldi	r25, 0x00	; 0
    416e:	0e 94 b6 18 	call	0x316c	; 0x316c <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    4172:	00 00       	nop
    4174:	fe cf       	rjmp	.-4      	; 0x4172 <chibi_test_radio+0xc>

00004176 <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    4176:	cf 93       	push	r28
    4178:	df 93       	push	r29
	
	SD_init();
    417a:	0e 94 85 2b 	call	0x570a	; 0x570a <SD_init>
	getBootSectorData();
    417e:	0e 94 65 23 	call	0x46ca	; 0x46ca <getBootSectorData>
    4182:	ef ed       	ldi	r30, 0xDF	; 223
    4184:	f3 e2       	ldi	r31, 0x23	; 35
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    4186:	20 e0       	ldi	r18, 0x00	; 0
    4188:	30 e0       	ldi	r19, 0x00	; 0
    418a:	c9 e7       	ldi	r28, 0x79	; 121
    418c:	d0 e0       	ldi	r29, 0x00	; 0
    418e:	c9 01       	movw	r24, r18
    4190:	be 01       	movw	r22, r28
    4192:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    4196:	81 93       	st	Z+, r24
    4198:	2f 5f       	subi	r18, 0xFF	; 255
    419a:	3f 4f       	sbci	r19, 0xFF	; 255
    419c:	82 e0       	ldi	r24, 0x02	; 2
    419e:	20 30       	cpi	r18, 0x00	; 0
    41a0:	38 07       	cpc	r19, r24
    41a2:	a9 f7       	brne	.-22     	; 0x418e <TestCard+0x18>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    41a4:	86 e1       	ldi	r24, 0x16	; 22
    41a6:	90 e2       	ldi	r25, 0x20	; 32
    41a8:	6f ed       	ldi	r22, 0xDF	; 223
    41aa:	73 e2       	ldi	r23, 0x23	; 35
    41ac:	20 e0       	ldi	r18, 0x00	; 0
    41ae:	32 e0       	ldi	r19, 0x02	; 2
    41b0:	40 e0       	ldi	r20, 0x00	; 0
    41b2:	50 e0       	ldi	r21, 0x00	; 0
    41b4:	0e 94 4c 28 	call	0x5098	; 0x5098 <writeFile>
	nop();
    41b8:	00 00       	nop
}
    41ba:	df 91       	pop	r29
    41bc:	cf 91       	pop	r28
    41be:	08 95       	ret

000041c0 <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    41c0:	1f 92       	push	r1
    41c2:	0f 92       	push	r0
    41c4:	0f b6       	in	r0, 0x3f	; 63
    41c6:	0f 92       	push	r0
    41c8:	0b b6       	in	r0, 0x3b	; 59
    41ca:	0f 92       	push	r0
    41cc:	11 24       	eor	r1, r1
    41ce:	2f 93       	push	r18
    41d0:	3f 93       	push	r19
    41d2:	4f 93       	push	r20
    41d4:	5f 93       	push	r21
    41d6:	6f 93       	push	r22
    41d8:	7f 93       	push	r23
    41da:	8f 93       	push	r24
    41dc:	9f 93       	push	r25
    41de:	af 93       	push	r26
    41e0:	bf 93       	push	r27
    41e2:	ef 93       	push	r30
    41e4:	ff 93       	push	r31
	
	chb_rx_data_t* msg = NULL;
	switch (RadioMonitorMode) {
    41e6:	80 91 5e 40 	lds	r24, 0x405E
    41ea:	81 30       	cpi	r24, 0x01	; 1
    41ec:	21 f0       	breq	.+8      	; 0x41f6 <__vector_43+0x36>
    41ee:	82 30       	cpi	r24, 0x02	; 2
    41f0:	09 f0       	breq	.+2      	; 0x41f4 <__vector_43+0x34>
    41f2:	72 c0       	rjmp	.+228    	; 0x42d8 <__vector_43+0x118>
    41f4:	55 c0       	rjmp	.+170    	; 0x42a0 <__vector_43+0xe0>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    41f6:	80 e0       	ldi	r24, 0x00	; 0
    41f8:	90 e0       	ldi	r25, 0x00	; 0
    41fa:	0e 94 57 17 	call	0x2eae	; 0x2eae <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    41fe:	85 e0       	ldi	r24, 0x05	; 5
    4200:	90 e0       	ldi	r25, 0x00	; 0
    4202:	6e e1       	ldi	r22, 0x1E	; 30
    4204:	70 e2       	ldi	r23, 0x20	; 32
    4206:	45 e0       	ldi	r20, 0x05	; 5
    4208:	50 e0       	ldi	r21, 0x00	; 0
    420a:	0e 94 92 3b 	call	0x7724	; 0x7724 <strncmp>
    420e:	28 2f       	mov	r18, r24
    4210:	39 2f       	mov	r19, r25
    4212:	21 15       	cp	r18, r1
    4214:	31 05       	cpc	r19, r1
    4216:	51 f4       	brne	.+20     	; 0x422c <__vector_43+0x6c>
				MotesReadyToSynch++;
    4218:	80 91 78 50 	lds	r24, 0x5078
    421c:	90 91 79 50 	lds	r25, 0x5079
    4220:	01 96       	adiw	r24, 0x01	; 1
    4222:	80 93 78 50 	sts	0x5078, r24
    4226:	90 93 79 50 	sts	0x5079, r25
    422a:	56 c0       	rjmp	.+172    	; 0x42d8 <__vector_43+0x118>
    422c:	e5 e0       	ldi	r30, 0x05	; 5
    422e:	f0 e0       	ldi	r31, 0x00	; 0
    4230:	af ed       	ldi	r26, 0xDF	; 223
    4232:	b3 e2       	ldi	r27, 0x23	; 35
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    4234:	81 91       	ld	r24, Z+
    4236:	8d 93       	st	X+, r24
    4238:	e5 38       	cpi	r30, 0x85	; 133
    423a:	f1 05       	cpc	r31, r1
    423c:	d9 f7       	brne	.-10     	; 0x4234 <__vector_43+0x74>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    423e:	80 91 c2 50 	lds	r24, 0x50C2
    4242:	90 91 c3 50 	lds	r25, 0x50C3
    4246:	a0 91 c4 50 	lds	r26, 0x50C4
    424a:	b0 91 c5 50 	lds	r27, 0x50C5
    424e:	80 58       	subi	r24, 0x80	; 128
    4250:	9f 4f       	sbci	r25, 0xFF	; 255
    4252:	af 4f       	sbci	r26, 0xFF	; 255
    4254:	bf 4f       	sbci	r27, 0xFF	; 255
    4256:	80 93 c2 50 	sts	0x50C2, r24
    425a:	90 93 c3 50 	sts	0x50C3, r25
    425e:	a0 93 c4 50 	sts	0x50C4, r26
    4262:	b0 93 c5 50 	sts	0x50C5, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    4266:	80 91 c2 50 	lds	r24, 0x50C2
    426a:	90 91 c3 50 	lds	r25, 0x50C3
    426e:	a0 91 c4 50 	lds	r26, 0x50C4
    4272:	b0 91 c5 50 	lds	r27, 0x50C5
    4276:	80 58       	subi	r24, 0x80	; 128
    4278:	9f 4f       	sbci	r25, 0xFF	; 255
    427a:	af 4f       	sbci	r26, 0xFF	; 255
    427c:	bf 4f       	sbci	r27, 0xFF	; 255
    427e:	81 37       	cpi	r24, 0x71	; 113
    4280:	2c e1       	ldi	r18, 0x1C	; 28
    4282:	92 07       	cpc	r25, r18
    4284:	20 e0       	ldi	r18, 0x00	; 0
    4286:	a2 07       	cpc	r26, r18
    4288:	20 e0       	ldi	r18, 0x00	; 0
    428a:	b2 07       	cpc	r27, r18
    428c:	28 f1       	brcs	.+74     	; 0x42d8 <__vector_43+0x118>
    428e:	10 92 c2 50 	sts	0x50C2, r1
    4292:	10 92 c3 50 	sts	0x50C3, r1
    4296:	10 92 c4 50 	sts	0x50C4, r1
    429a:	10 92 c5 50 	sts	0x50C5, r1
    429e:	1c c0       	rjmp	.+56     	; 0x42d8 <__vector_43+0x118>
			}			
			break;
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    42a0:	80 e0       	ldi	r24, 0x00	; 0
    42a2:	90 e0       	ldi	r25, 0x00	; 0
    42a4:	0e 94 57 17 	call	0x2eae	; 0x2eae <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    42a8:	85 e0       	ldi	r24, 0x05	; 5
    42aa:	90 e0       	ldi	r25, 0x00	; 0
    42ac:	64 e2       	ldi	r22, 0x24	; 36
    42ae:	70 e2       	ldi	r23, 0x20	; 32
    42b0:	4e e0       	ldi	r20, 0x0E	; 14
    42b2:	50 e0       	ldi	r21, 0x00	; 0
    42b4:	0e 94 92 3b 	call	0x7724	; 0x7724 <strncmp>
    42b8:	28 2f       	mov	r18, r24
    42ba:	39 2f       	mov	r19, r25
    42bc:	21 15       	cp	r18, r1
    42be:	31 05       	cpc	r19, r1
    42c0:	59 f4       	brne	.+22     	; 0x42d8 <__vector_43+0x118>
				RadioMonitorMode = SYNCHED;
    42c2:	83 e0       	ldi	r24, 0x03	; 3
    42c4:	80 93 5e 40 	sts	0x405E, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    42c8:	89 e0       	ldi	r24, 0x09	; 9
    42ca:	80 93 40 09 	sts	0x0940, r24
				TCC1.CTRLA = 0x01;  
    42ce:	81 e0       	ldi	r24, 0x01	; 1
    42d0:	80 93 40 08 	sts	0x0840, r24
				ADC_Resume_Sampling();	//resume sampling with the adc
    42d4:	0e 94 0c 08 	call	0x1018	; 0x1018 <ADC_Resume_Sampling>
			}
			break;
		default:
			break;
	}
}
    42d8:	ff 91       	pop	r31
    42da:	ef 91       	pop	r30
    42dc:	bf 91       	pop	r27
    42de:	af 91       	pop	r26
    42e0:	9f 91       	pop	r25
    42e2:	8f 91       	pop	r24
    42e4:	7f 91       	pop	r23
    42e6:	6f 91       	pop	r22
    42e8:	5f 91       	pop	r21
    42ea:	4f 91       	pop	r20
    42ec:	3f 91       	pop	r19
    42ee:	2f 91       	pop	r18
    42f0:	0f 90       	pop	r0
    42f2:	0b be       	out	0x3b, r0	; 59
    42f4:	0f 90       	pop	r0
    42f6:	0f be       	out	0x3f, r0	; 63
    42f8:	0f 90       	pop	r0
    42fa:	1f 90       	pop	r1
    42fc:	18 95       	reti

000042fe <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    42fe:	2f 92       	push	r2
    4300:	3f 92       	push	r3
    4302:	4f 92       	push	r4
    4304:	5f 92       	push	r5
    4306:	6f 92       	push	r6
    4308:	7f 92       	push	r7
    430a:	8f 92       	push	r8
    430c:	9f 92       	push	r9
    430e:	af 92       	push	r10
    4310:	bf 92       	push	r11
    4312:	cf 92       	push	r12
    4314:	df 92       	push	r13
    4316:	ef 92       	push	r14
    4318:	ff 92       	push	r15
    431a:	0f 93       	push	r16
    431c:	1f 93       	push	r17
    431e:	cf 93       	push	r28
    4320:	df 93       	push	r29
    4322:	cd b7       	in	r28, 0x3d	; 61
    4324:	de b7       	in	r29, 0x3e	; 62
    4326:	64 97       	sbiw	r28, 0x14	; 20
    4328:	cd bf       	out	0x3d, r28	; 61
    432a:	de bf       	out	0x3e, r29	; 62
    432c:	2a 01       	movw	r4, r20
    432e:	3b 01       	movw	r6, r22
    4330:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    4332:	f9 01       	movw	r30, r18
    4334:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    4336:	41 15       	cp	r20, r1
    4338:	51 05       	cpc	r21, r1
    433a:	61 05       	cpc	r22, r1
    433c:	71 05       	cpc	r23, r1
    433e:	09 f4       	brne	.+2      	; 0x4342 <DeciToString+0x44>
    4340:	4d c0       	rjmp	.+154    	; 0x43dc <DeciToString+0xde>
    4342:	88 2e       	mov	r8, r24
    4344:	99 2e       	mov	r9, r25
    4346:	cc 24       	eor	r12, r12
    4348:	dd 24       	eor	r13, r13
    434a:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    434c:	5e 01       	movw	r10, r28
    434e:	08 94       	sec
    4350:	a1 1c       	adc	r10, r1
    4352:	b1 1c       	adc	r11, r1
    4354:	0f 2e       	mov	r0, r31
    4356:	f3 e3       	ldi	r31, 0x33	; 51
    4358:	2f 2e       	mov	r2, r31
    435a:	f0 e2       	ldi	r31, 0x20	; 32
    435c:	3f 2e       	mov	r3, r31
    435e:	f0 2d       	mov	r31, r0
    4360:	f4 01       	movw	r30, r8
    4362:	81 91       	ld	r24, Z+
    4364:	91 91       	ld	r25, Z+
    4366:	a1 91       	ld	r26, Z+
    4368:	b1 91       	ld	r27, Z+
    436a:	4f 01       	movw	r8, r30
    436c:	2d b7       	in	r18, 0x3d	; 61
    436e:	3e b7       	in	r19, 0x3e	; 62
    4370:	28 50       	subi	r18, 0x08	; 8
    4372:	30 40       	sbci	r19, 0x00	; 0
    4374:	2d bf       	out	0x3d, r18	; 61
    4376:	3e bf       	out	0x3e, r19	; 62
    4378:	2f 5f       	subi	r18, 0xFF	; 255
    437a:	3f 4f       	sbci	r19, 0xFF	; 255
    437c:	ed b7       	in	r30, 0x3d	; 61
    437e:	fe b7       	in	r31, 0x3e	; 62
    4380:	a1 82       	std	Z+1, r10	; 0x01
    4382:	b2 82       	std	Z+2, r11	; 0x02
    4384:	f9 01       	movw	r30, r18
    4386:	22 82       	std	Z+2, r2	; 0x02
    4388:	33 82       	std	Z+3, r3	; 0x03
    438a:	84 83       	std	Z+4, r24	; 0x04
    438c:	95 83       	std	Z+5, r25	; 0x05
    438e:	a6 83       	std	Z+6, r26	; 0x06
    4390:	b7 83       	std	Z+7, r27	; 0x07
    4392:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <sprintf>
		strcat(ReturnString,b);
    4396:	2d b7       	in	r18, 0x3d	; 61
    4398:	3e b7       	in	r19, 0x3e	; 62
    439a:	28 5f       	subi	r18, 0xF8	; 248
    439c:	3f 4f       	sbci	r19, 0xFF	; 255
    439e:	2d bf       	out	0x3d, r18	; 61
    43a0:	3e bf       	out	0x3e, r19	; 62
    43a2:	c8 01       	movw	r24, r16
    43a4:	b5 01       	movw	r22, r10
    43a6:	0e 94 87 3b 	call	0x770e	; 0x770e <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    43aa:	a0 2f       	mov	r26, r16
    43ac:	b1 2f       	mov	r27, r17
    43ae:	fd 01       	movw	r30, r26
    43b0:	01 90       	ld	r0, Z+
    43b2:	00 20       	and	r0, r0
    43b4:	e9 f7       	brne	.-6      	; 0x43b0 <DeciToString+0xb2>
    43b6:	31 97       	sbiw	r30, 0x01	; 1
    43b8:	ea 1b       	sub	r30, r26
    43ba:	fb 0b       	sbc	r31, r27
    43bc:	e0 0f       	add	r30, r16
    43be:	f1 1f       	adc	r31, r17
    43c0:	8a e0       	ldi	r24, 0x0A	; 10
    43c2:	90 e0       	ldi	r25, 0x00	; 0
    43c4:	80 83       	st	Z, r24
    43c6:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    43c8:	08 94       	sec
    43ca:	c1 1c       	adc	r12, r1
    43cc:	d1 1c       	adc	r13, r1
    43ce:	e1 1c       	adc	r14, r1
    43d0:	f1 1c       	adc	r15, r1
    43d2:	c4 14       	cp	r12, r4
    43d4:	d5 04       	cpc	r13, r5
    43d6:	e6 04       	cpc	r14, r6
    43d8:	f7 04       	cpc	r15, r7
    43da:	11 f6       	brne	.-124    	; 0x4360 <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    43dc:	64 96       	adiw	r28, 0x14	; 20
    43de:	cd bf       	out	0x3d, r28	; 61
    43e0:	de bf       	out	0x3e, r29	; 62
    43e2:	df 91       	pop	r29
    43e4:	cf 91       	pop	r28
    43e6:	1f 91       	pop	r17
    43e8:	0f 91       	pop	r16
    43ea:	ff 90       	pop	r15
    43ec:	ef 90       	pop	r14
    43ee:	df 90       	pop	r13
    43f0:	cf 90       	pop	r12
    43f2:	bf 90       	pop	r11
    43f4:	af 90       	pop	r10
    43f6:	9f 90       	pop	r9
    43f8:	8f 90       	pop	r8
    43fa:	7f 90       	pop	r7
    43fc:	6f 90       	pop	r6
    43fe:	5f 90       	pop	r5
    4400:	4f 90       	pop	r4
    4402:	3f 90       	pop	r3
    4404:	2f 90       	pop	r2
    4406:	08 95       	ret

00004408 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    4408:	cf 92       	push	r12
    440a:	df 92       	push	r13
    440c:	ef 92       	push	r14
    440e:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    4410:	20 91 7b 50 	lds	r18, 0x507B
    4414:	30 91 7c 50 	lds	r19, 0x507C
    4418:	c0 90 db 23 	lds	r12, 0x23DB
    441c:	d0 90 dc 23 	lds	r13, 0x23DC
    4420:	e0 90 dd 23 	lds	r14, 0x23DD
    4424:	f0 90 de 23 	lds	r15, 0x23DE
    4428:	62 50       	subi	r22, 0x02	; 2
    442a:	70 40       	sbci	r23, 0x00	; 0
    442c:	80 40       	sbci	r24, 0x00	; 0
    442e:	90 40       	sbci	r25, 0x00	; 0
    4430:	40 e0       	ldi	r20, 0x00	; 0
    4432:	50 e0       	ldi	r21, 0x00	; 0
    4434:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    4438:	dc 01       	movw	r26, r24
    443a:	cb 01       	movw	r24, r22
    443c:	c8 0e       	add	r12, r24
    443e:	d9 1e       	adc	r13, r25
    4440:	ea 1e       	adc	r14, r26
    4442:	fb 1e       	adc	r15, r27
}
    4444:	6c 2d       	mov	r22, r12
    4446:	7d 2d       	mov	r23, r13
    4448:	8e 2d       	mov	r24, r14
    444a:	9f 2d       	mov	r25, r15
    444c:	ff 90       	pop	r15
    444e:	ef 90       	pop	r14
    4450:	df 90       	pop	r13
    4452:	cf 90       	pop	r12
    4454:	08 95       	ret

00004456 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    4456:	3f 92       	push	r3
    4458:	4f 92       	push	r4
    445a:	5f 92       	push	r5
    445c:	6f 92       	push	r6
    445e:	7f 92       	push	r7
    4460:	8f 92       	push	r8
    4462:	9f 92       	push	r9
    4464:	af 92       	push	r10
    4466:	bf 92       	push	r11
    4468:	cf 92       	push	r12
    446a:	df 92       	push	r13
    446c:	ef 92       	push	r14
    446e:	ff 92       	push	r15
    4470:	0f 93       	push	r16
    4472:	1f 93       	push	r17
    4474:	cf 93       	push	r28
    4476:	df 93       	push	r29
    4478:	00 d0       	rcall	.+0      	; 0x447a <getSetNextCluster+0x24>
    447a:	0f 92       	push	r0
    447c:	cd b7       	in	r28, 0x3d	; 61
    447e:	de b7       	in	r29, 0x3e	; 62
    4480:	dc 01       	movw	r26, r24
    4482:	cb 01       	movw	r24, r22
    4484:	34 2e       	mov	r3, r20
    4486:	09 83       	std	Y+1, r16	; 0x01
    4488:	1a 83       	std	Y+2, r17	; 0x02
    448a:	2b 83       	std	Y+3, r18	; 0x03
    448c:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    448e:	80 90 83 50 	lds	r8, 0x5083
    4492:	90 90 84 50 	lds	r9, 0x5084
    4496:	2c 01       	movw	r4, r24
    4498:	3d 01       	movw	r6, r26
    449a:	44 0c       	add	r4, r4
    449c:	55 1c       	adc	r5, r5
    449e:	66 1c       	adc	r6, r6
    44a0:	77 1c       	adc	r7, r7
    44a2:	44 0c       	add	r4, r4
    44a4:	55 1c       	adc	r5, r5
    44a6:	66 1c       	adc	r6, r6
    44a8:	77 1c       	adc	r7, r7
    44aa:	20 91 54 40 	lds	r18, 0x4054
    44ae:	30 91 55 40 	lds	r19, 0x4055
    44b2:	aa 24       	eor	r10, r10
    44b4:	bb 24       	eor	r11, r11
    44b6:	80 91 7d 50 	lds	r24, 0x507D
    44ba:	90 91 7e 50 	lds	r25, 0x507E
    44be:	a0 91 7f 50 	lds	r26, 0x507F
    44c2:	b0 91 80 50 	lds	r27, 0x5080
    44c6:	88 0e       	add	r8, r24
    44c8:	99 1e       	adc	r9, r25
    44ca:	aa 1e       	adc	r10, r26
    44cc:	bb 1e       	adc	r11, r27
    44ce:	40 e0       	ldi	r20, 0x00	; 0
    44d0:	50 e0       	ldi	r21, 0x00	; 0
    44d2:	c3 01       	movw	r24, r6
    44d4:	b2 01       	movw	r22, r4
    44d6:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    44da:	69 01       	movw	r12, r18
    44dc:	7a 01       	movw	r14, r20
    44de:	c8 0c       	add	r12, r8
    44e0:	d9 1c       	adc	r13, r9
    44e2:	ea 1c       	adc	r14, r10
    44e4:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    44e6:	00 91 54 40 	lds	r16, 0x4054
    44ea:	10 91 55 40 	lds	r17, 0x4055

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    44ee:	c7 01       	movw	r24, r14
    44f0:	b6 01       	movw	r22, r12
    44f2:	46 ed       	ldi	r20, 0xD6	; 214
    44f4:	51 e2       	ldi	r21, 0x21	; 33
    44f6:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    44fa:	98 01       	movw	r18, r16
    44fc:	40 e0       	ldi	r20, 0x00	; 0
    44fe:	50 e0       	ldi	r21, 0x00	; 0
    4500:	c3 01       	movw	r24, r6
    4502:	b2 01       	movw	r22, r4
    4504:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    4508:	6a 52       	subi	r22, 0x2A	; 42
    450a:	7e 4d       	sbci	r23, 0xDE	; 222

if(get_set == GET)
    450c:	33 20       	and	r3, r3
    450e:	41 f4       	brne	.+16     	; 0x4520 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    4510:	db 01       	movw	r26, r22
    4512:	0d 91       	ld	r16, X+
    4514:	1d 91       	ld	r17, X+
    4516:	2d 91       	ld	r18, X+
    4518:	3c 91       	ld	r19, X
    451a:	13 97       	sbiw	r26, 0x03	; 3
    451c:	3f 70       	andi	r19, 0x0F	; 15
    451e:	14 c0       	rjmp	.+40     	; 0x4548 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4520:	89 81       	ldd	r24, Y+1	; 0x01
    4522:	9a 81       	ldd	r25, Y+2	; 0x02
    4524:	ab 81       	ldd	r26, Y+3	; 0x03
    4526:	bc 81       	ldd	r27, Y+4	; 0x04
    4528:	fb 01       	movw	r30, r22
    452a:	80 83       	st	Z, r24
    452c:	91 83       	std	Z+1, r25	; 0x01
    452e:	a2 83       	std	Z+2, r26	; 0x02
    4530:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    4532:	c7 01       	movw	r24, r14
    4534:	b6 01       	movw	r22, r12
    4536:	46 ed       	ldi	r20, 0xD6	; 214
    4538:	51 e2       	ldi	r21, 0x21	; 33
    453a:	20 e0       	ldi	r18, 0x00	; 0
    453c:	32 e0       	ldi	r19, 0x02	; 2
    453e:	0e 94 5f 2c 	call	0x58be	; 0x58be <SD_write_block>

return (0);
    4542:	00 e0       	ldi	r16, 0x00	; 0
    4544:	10 e0       	ldi	r17, 0x00	; 0
    4546:	98 01       	movw	r18, r16
}
    4548:	60 2f       	mov	r22, r16
    454a:	71 2f       	mov	r23, r17
    454c:	82 2f       	mov	r24, r18
    454e:	93 2f       	mov	r25, r19
    4550:	24 96       	adiw	r28, 0x04	; 4
    4552:	cd bf       	out	0x3d, r28	; 61
    4554:	de bf       	out	0x3e, r29	; 62
    4556:	df 91       	pop	r29
    4558:	cf 91       	pop	r28
    455a:	1f 91       	pop	r17
    455c:	0f 91       	pop	r16
    455e:	ff 90       	pop	r15
    4560:	ef 90       	pop	r14
    4562:	df 90       	pop	r13
    4564:	cf 90       	pop	r12
    4566:	bf 90       	pop	r11
    4568:	af 90       	pop	r10
    456a:	9f 90       	pop	r9
    456c:	8f 90       	pop	r8
    456e:	7f 90       	pop	r7
    4570:	6f 90       	pop	r6
    4572:	5f 90       	pop	r5
    4574:	4f 90       	pop	r4
    4576:	3f 90       	pop	r3
    4578:	08 95       	ret

0000457a <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    457a:	cf 92       	push	r12
    457c:	df 92       	push	r13
    457e:	ef 92       	push	r14
    4580:	ff 92       	push	r15
    4582:	0f 93       	push	r16
    4584:	1f 93       	push	r17
    4586:	cf 93       	push	r28
    4588:	c8 2f       	mov	r28, r24
    458a:	06 2f       	mov	r16, r22
    458c:	69 01       	movw	r12, r18
    458e:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4590:	80 91 7d 50 	lds	r24, 0x507D
    4594:	90 91 7e 50 	lds	r25, 0x507E
    4598:	a0 91 7f 50 	lds	r26, 0x507F
    459c:	b0 91 80 50 	lds	r27, 0x5080
    45a0:	bc 01       	movw	r22, r24
    45a2:	cd 01       	movw	r24, r26
    45a4:	6f 5f       	subi	r22, 0xFF	; 255
    45a6:	7f 4f       	sbci	r23, 0xFF	; 255
    45a8:	8f 4f       	sbci	r24, 0xFF	; 255
    45aa:	9f 4f       	sbci	r25, 0xFF	; 255
    45ac:	46 ed       	ldi	r20, 0xD6	; 214
    45ae:	51 e2       	ldi	r21, 0x21	; 33
    45b0:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    45b4:	80 91 d6 21 	lds	r24, 0x21D6
    45b8:	90 91 d7 21 	lds	r25, 0x21D7
    45bc:	a0 91 d8 21 	lds	r26, 0x21D8
    45c0:	b0 91 d9 21 	lds	r27, 0x21D9
    45c4:	82 35       	cpi	r24, 0x52	; 82
    45c6:	22 e5       	ldi	r18, 0x52	; 82
    45c8:	92 07       	cpc	r25, r18
    45ca:	21 e6       	ldi	r18, 0x61	; 97
    45cc:	a2 07       	cpc	r26, r18
    45ce:	21 e4       	ldi	r18, 0x41	; 65
    45d0:	b2 07       	cpc	r27, r18
    45d2:	09 f0       	breq	.+2      	; 0x45d6 <getSetFreeCluster+0x5c>
    45d4:	63 c0       	rjmp	.+198    	; 0x469c <getSetFreeCluster+0x122>
    45d6:	80 91 ba 23 	lds	r24, 0x23BA
    45da:	90 91 bb 23 	lds	r25, 0x23BB
    45de:	a0 91 bc 23 	lds	r26, 0x23BC
    45e2:	b0 91 bd 23 	lds	r27, 0x23BD
    45e6:	82 37       	cpi	r24, 0x72	; 114
    45e8:	22 e7       	ldi	r18, 0x72	; 114
    45ea:	92 07       	cpc	r25, r18
    45ec:	21 e4       	ldi	r18, 0x41	; 65
    45ee:	a2 07       	cpc	r26, r18
    45f0:	21 e6       	ldi	r18, 0x61	; 97
    45f2:	b2 07       	cpc	r27, r18
    45f4:	09 f0       	breq	.+2      	; 0x45f8 <getSetFreeCluster+0x7e>
    45f6:	56 c0       	rjmp	.+172    	; 0x46a4 <getSetFreeCluster+0x12a>
    45f8:	80 91 d2 23 	lds	r24, 0x23D2
    45fc:	90 91 d3 23 	lds	r25, 0x23D3
    4600:	a0 91 d4 23 	lds	r26, 0x23D4
    4604:	b0 91 d5 23 	lds	r27, 0x23D5
    4608:	80 30       	cpi	r24, 0x00	; 0
    460a:	20 e0       	ldi	r18, 0x00	; 0
    460c:	92 07       	cpc	r25, r18
    460e:	25 e5       	ldi	r18, 0x55	; 85
    4610:	a2 07       	cpc	r26, r18
    4612:	2a ea       	ldi	r18, 0xAA	; 170
    4614:	b2 07       	cpc	r27, r18
    4616:	09 f0       	breq	.+2      	; 0x461a <getSetFreeCluster+0xa0>
    4618:	49 c0       	rjmp	.+146    	; 0x46ac <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    461a:	00 23       	and	r16, r16
    461c:	a1 f4       	brne	.+40     	; 0x4646 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    461e:	c1 30       	cpi	r28, 0x01	; 1
    4620:	49 f4       	brne	.+18     	; 0x4634 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    4622:	00 91 be 23 	lds	r16, 0x23BE
    4626:	10 91 bf 23 	lds	r17, 0x23BF
    462a:	20 91 c0 23 	lds	r18, 0x23C0
    462e:	30 91 c1 23 	lds	r19, 0x23C1
    4632:	3f c0       	rjmp	.+126    	; 0x46b2 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    4634:	00 91 c2 23 	lds	r16, 0x23C2
    4638:	10 91 c3 23 	lds	r17, 0x23C3
    463c:	20 91 c4 23 	lds	r18, 0x23C4
    4640:	30 91 c5 23 	lds	r19, 0x23C5
    4644:	36 c0       	rjmp	.+108    	; 0x46b2 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4646:	c1 30       	cpi	r28, 0x01	; 1
    4648:	49 f4       	brne	.+18     	; 0x465c <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    464a:	c0 92 be 23 	sts	0x23BE, r12
    464e:	d0 92 bf 23 	sts	0x23BF, r13
    4652:	e0 92 c0 23 	sts	0x23C0, r14
    4656:	f0 92 c1 23 	sts	0x23C1, r15
    465a:	08 c0       	rjmp	.+16     	; 0x466c <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    465c:	c0 92 c2 23 	sts	0x23C2, r12
    4660:	d0 92 c3 23 	sts	0x23C3, r13
    4664:	e0 92 c4 23 	sts	0x23C4, r14
    4668:	f0 92 c5 23 	sts	0x23C5, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    466c:	80 91 7d 50 	lds	r24, 0x507D
    4670:	90 91 7e 50 	lds	r25, 0x507E
    4674:	a0 91 7f 50 	lds	r26, 0x507F
    4678:	b0 91 80 50 	lds	r27, 0x5080
    467c:	bc 01       	movw	r22, r24
    467e:	cd 01       	movw	r24, r26
    4680:	6f 5f       	subi	r22, 0xFF	; 255
    4682:	7f 4f       	sbci	r23, 0xFF	; 255
    4684:	8f 4f       	sbci	r24, 0xFF	; 255
    4686:	9f 4f       	sbci	r25, 0xFF	; 255
    4688:	46 ed       	ldi	r20, 0xD6	; 214
    468a:	51 e2       	ldi	r21, 0x21	; 33
    468c:	20 e0       	ldi	r18, 0x00	; 0
    468e:	32 e0       	ldi	r19, 0x02	; 2
    4690:	0e 94 5f 2c 	call	0x58be	; 0x58be <SD_write_block>
 }
 return 0xffffffff;
    4694:	0f ef       	ldi	r16, 0xFF	; 255
    4696:	1f ef       	ldi	r17, 0xFF	; 255
    4698:	98 01       	movw	r18, r16
    469a:	0b c0       	rjmp	.+22     	; 0x46b2 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    469c:	0f ef       	ldi	r16, 0xFF	; 255
    469e:	1f ef       	ldi	r17, 0xFF	; 255
    46a0:	98 01       	movw	r18, r16
    46a2:	07 c0       	rjmp	.+14     	; 0x46b2 <getSetFreeCluster+0x138>
    46a4:	0f ef       	ldi	r16, 0xFF	; 255
    46a6:	1f ef       	ldi	r17, 0xFF	; 255
    46a8:	98 01       	movw	r18, r16
    46aa:	03 c0       	rjmp	.+6      	; 0x46b2 <getSetFreeCluster+0x138>
    46ac:	0f ef       	ldi	r16, 0xFF	; 255
    46ae:	1f ef       	ldi	r17, 0xFF	; 255
    46b0:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    46b2:	60 2f       	mov	r22, r16
    46b4:	71 2f       	mov	r23, r17
    46b6:	82 2f       	mov	r24, r18
    46b8:	93 2f       	mov	r25, r19
    46ba:	cf 91       	pop	r28
    46bc:	1f 91       	pop	r17
    46be:	0f 91       	pop	r16
    46c0:	ff 90       	pop	r15
    46c2:	ef 90       	pop	r14
    46c4:	df 90       	pop	r13
    46c6:	cf 90       	pop	r12
    46c8:	08 95       	ret

000046ca <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    46ca:	ef 92       	push	r14
    46cc:	ff 92       	push	r15
    46ce:	0f 93       	push	r16
    46d0:	1f 93       	push	r17
    46d2:	cf 93       	push	r28
    46d4:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    46d6:	10 92 7d 50 	sts	0x507D, r1
    46da:	10 92 7e 50 	sts	0x507E, r1
    46de:	10 92 7f 50 	sts	0x507F, r1
    46e2:	10 92 80 50 	sts	0x5080, r1

SD_read_block(0,SDBuffer);
    46e6:	60 e0       	ldi	r22, 0x00	; 0
    46e8:	70 e0       	ldi	r23, 0x00	; 0
    46ea:	cb 01       	movw	r24, r22
    46ec:	46 ed       	ldi	r20, 0xD6	; 214
    46ee:	51 e2       	ldi	r21, 0x21	; 33
    46f0:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    46f4:	80 91 d6 21 	lds	r24, 0x21D6
    46f8:	89 3e       	cpi	r24, 0xE9	; 233
    46fa:	31 f1       	breq	.+76     	; 0x4748 <getBootSectorData+0x7e>
    46fc:	8b 3e       	cpi	r24, 0xEB	; 235
    46fe:	21 f1       	breq	.+72     	; 0x4748 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4700:	80 91 d4 23 	lds	r24, 0x23D4
    4704:	90 91 d5 23 	lds	r25, 0x23D5
    4708:	2a ea       	ldi	r18, 0xAA	; 170
    470a:	85 35       	cpi	r24, 0x55	; 85
    470c:	92 07       	cpc	r25, r18
    470e:	09 f0       	breq	.+2      	; 0x4712 <getBootSectorData+0x48>
    4710:	b7 c0       	rjmp	.+366    	; 0x4880 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    4712:	60 91 9c 23 	lds	r22, 0x239C
    4716:	70 91 9d 23 	lds	r23, 0x239D
    471a:	80 91 9e 23 	lds	r24, 0x239E
    471e:	90 91 9f 23 	lds	r25, 0x239F
    4722:	60 93 7d 50 	sts	0x507D, r22
    4726:	70 93 7e 50 	sts	0x507E, r23
    472a:	80 93 7f 50 	sts	0x507F, r24
    472e:	90 93 80 50 	sts	0x5080, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    4732:	46 ed       	ldi	r20, 0xD6	; 214
    4734:	51 e2       	ldi	r21, 0x21	; 33
    4736:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    473a:	80 91 d6 21 	lds	r24, 0x21D6
    473e:	89 3e       	cpi	r24, 0xE9	; 233
    4740:	19 f0       	breq	.+6      	; 0x4748 <getBootSectorData+0x7e>
    4742:	8b 3e       	cpi	r24, 0xEB	; 235
    4744:	09 f0       	breq	.+2      	; 0x4748 <getBootSectorData+0x7e>
    4746:	9e c0       	rjmp	.+316    	; 0x4884 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4748:	80 91 e1 21 	lds	r24, 0x21E1
    474c:	90 91 e2 21 	lds	r25, 0x21E2
    4750:	80 93 54 40 	sts	0x4054, r24
    4754:	90 93 55 40 	sts	0x4055, r25
sectorPerCluster = bpb->sectorPerCluster;
    4758:	80 91 e3 21 	lds	r24, 0x21E3
    475c:	90 e0       	ldi	r25, 0x00	; 0
    475e:	80 93 7b 50 	sts	0x507B, r24
    4762:	90 93 7c 50 	sts	0x507C, r25
reservedSectorCount = bpb->reservedSectorCount;
    4766:	e0 90 e4 21 	lds	r14, 0x21E4
    476a:	f0 90 e5 21 	lds	r15, 0x21E5
    476e:	e0 92 83 50 	sts	0x5083, r14
    4772:	f0 92 84 50 	sts	0x5084, r15
rootCluster = bpb->rootCluster;
    4776:	80 91 02 22 	lds	r24, 0x2202
    477a:	90 91 03 22 	lds	r25, 0x2203
    477e:	a0 91 04 22 	lds	r26, 0x2204
    4782:	b0 91 05 22 	lds	r27, 0x2205
    4786:	80 93 5f 40 	sts	0x405F, r24
    478a:	90 93 60 40 	sts	0x4060, r25
    478e:	a0 93 61 40 	sts	0x4061, r26
    4792:	b0 93 62 40 	sts	0x4062, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    4796:	c0 91 83 50 	lds	r28, 0x5083
    479a:	d0 91 84 50 	lds	r29, 0x5084
    479e:	60 91 e6 21 	lds	r22, 0x21E6
    47a2:	70 e0       	ldi	r23, 0x00	; 0
    47a4:	80 e0       	ldi	r24, 0x00	; 0
    47a6:	90 e0       	ldi	r25, 0x00	; 0
    47a8:	20 91 fa 21 	lds	r18, 0x21FA
    47ac:	30 91 fb 21 	lds	r19, 0x21FB
    47b0:	40 91 fc 21 	lds	r20, 0x21FC
    47b4:	50 91 fd 21 	lds	r21, 0x21FD
    47b8:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    47bc:	8b 01       	movw	r16, r22
    47be:	9c 01       	movw	r18, r24
    47c0:	ae 01       	movw	r20, r28
    47c2:	60 e0       	ldi	r22, 0x00	; 0
    47c4:	70 e0       	ldi	r23, 0x00	; 0
    47c6:	80 91 f2 21 	lds	r24, 0x21F2
    47ca:	90 91 f3 21 	lds	r25, 0x21F3
    47ce:	a0 91 f4 21 	lds	r26, 0x21F4
    47d2:	b0 91 f5 21 	lds	r27, 0x21F5
    47d6:	84 0f       	add	r24, r20
    47d8:	95 1f       	adc	r25, r21
    47da:	a6 1f       	adc	r26, r22
    47dc:	b7 1f       	adc	r27, r23
    47de:	80 0f       	add	r24, r16
    47e0:	91 1f       	adc	r25, r17
    47e2:	a2 1f       	adc	r26, r18
    47e4:	b3 1f       	adc	r27, r19
    47e6:	80 93 db 23 	sts	0x23DB, r24
    47ea:	90 93 dc 23 	sts	0x23DC, r25
    47ee:	a0 93 dd 23 	sts	0x23DD, r26
    47f2:	b0 93 de 23 	sts	0x23DE, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    47f6:	e0 91 7b 50 	lds	r30, 0x507B
    47fa:	f0 91 7c 50 	lds	r31, 0x507C
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    47fe:	c7 01       	movw	r24, r14
    4800:	a0 e0       	ldi	r26, 0x00	; 0
    4802:	b0 e0       	ldi	r27, 0x00	; 0
    4804:	40 91 f6 21 	lds	r20, 0x21F6
    4808:	50 91 f7 21 	lds	r21, 0x21F7
    480c:	60 91 f8 21 	lds	r22, 0x21F8
    4810:	70 91 f9 21 	lds	r23, 0x21F9
    4814:	48 1b       	sub	r20, r24
    4816:	59 0b       	sbc	r21, r25
    4818:	6a 0b       	sbc	r22, r26
    481a:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    481c:	cb 01       	movw	r24, r22
    481e:	ba 01       	movw	r22, r20
    4820:	60 1b       	sub	r22, r16
    4822:	71 0b       	sbc	r23, r17
    4824:	82 0b       	sbc	r24, r18
    4826:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4828:	9f 01       	movw	r18, r30
    482a:	40 e0       	ldi	r20, 0x00	; 0
    482c:	50 e0       	ldi	r21, 0x00	; 0
    482e:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    4832:	20 93 59 40 	sts	0x4059, r18
    4836:	30 93 5a 40 	sts	0x405A, r19
    483a:	40 93 5b 40 	sts	0x405B, r20
    483e:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    4842:	81 e0       	ldi	r24, 0x01	; 1
    4844:	60 e0       	ldi	r22, 0x00	; 0
    4846:	20 e0       	ldi	r18, 0x00	; 0
    4848:	30 e0       	ldi	r19, 0x00	; 0
    484a:	a9 01       	movw	r20, r18
    484c:	0e 94 bd 22 	call	0x457a	; 0x457a <getSetFreeCluster>
    4850:	ab 01       	movw	r20, r22
    4852:	bc 01       	movw	r22, r24
    4854:	80 91 59 40 	lds	r24, 0x4059
    4858:	90 91 5a 40 	lds	r25, 0x405A
    485c:	a0 91 5b 40 	lds	r26, 0x405B
    4860:	b0 91 5c 40 	lds	r27, 0x405C
    4864:	84 17       	cp	r24, r20
    4866:	95 07       	cpc	r25, r21
    4868:	a6 07       	cpc	r26, r22
    486a:	b7 07       	cpc	r27, r23
    486c:	20 f4       	brcc	.+8      	; 0x4876 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    486e:	10 92 c7 50 	sts	0x50C7, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4872:	80 e0       	ldi	r24, 0x00	; 0
    4874:	08 c0       	rjmp	.+16     	; 0x4886 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4876:	81 e0       	ldi	r24, 0x01	; 1
    4878:	80 93 c7 50 	sts	0x50C7, r24
return 0;
    487c:	80 e0       	ldi	r24, 0x00	; 0
    487e:	03 c0       	rjmp	.+6      	; 0x4886 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4880:	81 e0       	ldi	r24, 0x01	; 1
    4882:	01 c0       	rjmp	.+2      	; 0x4886 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4884:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4886:	df 91       	pop	r29
    4888:	cf 91       	pop	r28
    488a:	1f 91       	pop	r17
    488c:	0f 91       	pop	r16
    488e:	ff 90       	pop	r15
    4890:	ef 90       	pop	r14
    4892:	08 95       	ret

00004894 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4894:	0f 93       	push	r16
    4896:	1f 93       	push	r17
    4898:	cf 93       	push	r28
    489a:	df 93       	push	r29
    489c:	cd b7       	in	r28, 0x3d	; 61
    489e:	de b7       	in	r29, 0x3e	; 62
    48a0:	2b 97       	sbiw	r28, 0x0b	; 11
    48a2:	cd bf       	out	0x3d, r28	; 61
    48a4:	de bf       	out	0x3e, r29	; 62
    48a6:	78 2f       	mov	r23, r24
    48a8:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    48aa:	e8 2f       	mov	r30, r24
    48ac:	f9 2f       	mov	r31, r25
    48ae:	df 01       	movw	r26, r30
    48b0:	0d 90       	ld	r0, X+
    48b2:	00 20       	and	r0, r0
    48b4:	e9 f7       	brne	.-6      	; 0x48b0 <convertFileName+0x1c>
    48b6:	11 97       	sbiw	r26, 0x01	; 1
    48b8:	ae 1b       	sub	r26, r30
    48ba:	bf 0b       	sbc	r27, r31
    48bc:	a0 31       	cpi	r26, 0x10	; 16
    48be:	b1 05       	cpc	r27, r1
    48c0:	08 f0       	brcs	.+2      	; 0x48c4 <convertFileName+0x30>
    48c2:	9c c0       	rjmp	.+312    	; 0x49fc <convertFileName+0x168>
    48c4:	28 2f       	mov	r18, r24
    48c6:	39 2f       	mov	r19, r25
    48c8:	03 eb       	ldi	r16, 0xB3	; 179
    48ca:	10 e5       	ldi	r17, 0x50	; 80
    48cc:	a8 01       	movw	r20, r16
    48ce:	80 e0       	ldi	r24, 0x00	; 0
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	07 c0       	rjmp	.+14     	; 0x48e2 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    48d4:	d9 01       	movw	r26, r18
    48d6:	ed 91       	ld	r30, X+
    48d8:	9d 01       	movw	r18, r26
    48da:	da 01       	movw	r26, r20
    48dc:	ed 93       	st	X+, r30
    48de:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    48e0:	01 96       	adiw	r24, 0x01	; 1
    48e2:	a7 2f       	mov	r26, r23
    48e4:	b6 2f       	mov	r27, r22
    48e6:	fd 01       	movw	r30, r26
    48e8:	01 90       	ld	r0, Z+
    48ea:	00 20       	and	r0, r0
    48ec:	e9 f7       	brne	.-6      	; 0x48e8 <convertFileName+0x54>
    48ee:	31 97       	sbiw	r30, 0x01	; 1
    48f0:	ea 1b       	sub	r30, r26
    48f2:	fb 0b       	sbc	r31, r27
    48f4:	8e 17       	cp	r24, r30
    48f6:	9f 07       	cpc	r25, r31
    48f8:	68 f3       	brcs	.-38     	; 0x48d4 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    48fa:	8f 30       	cpi	r24, 0x0F	; 15
    48fc:	91 05       	cpc	r25, r1
    48fe:	54 f4       	brge	.+20     	; 0x4914 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4900:	fc 01       	movw	r30, r24
    4902:	ed 54       	subi	r30, 0x4D	; 77
    4904:	ff 4a       	sbci	r31, 0xAF	; 175
    4906:	82 ec       	ldi	r24, 0xC2	; 194
    4908:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    490a:	20 e2       	ldi	r18, 0x20	; 32
    490c:	21 93       	st	Z+, r18
    490e:	e8 17       	cp	r30, r24
    4910:	f9 07       	cpc	r31, r25
    4912:	e1 f7       	brne	.-8      	; 0x490c <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4914:	80 91 b3 50 	lds	r24, 0x50B3
    4918:	8e 32       	cpi	r24, 0x2E	; 46
    491a:	91 f0       	breq	.+36     	; 0x4940 <convertFileName+0xac>
    491c:	e4 eb       	ldi	r30, 0xB4	; 180
    491e:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4920:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    4922:	81 91       	ld	r24, Z+
    4924:	8e 32       	cpi	r24, 0x2E	; 46
    4926:	21 f0       	breq	.+8      	; 0x4930 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4928:	2f 5f       	subi	r18, 0xFF	; 255
    492a:	2c 30       	cpi	r18, 0x0C	; 12
    492c:	d1 f7       	brne	.-12     	; 0x4922 <convertFileName+0x8e>
    492e:	05 c0       	rjmp	.+10     	; 0x493a <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    4930:	82 2f       	mov	r24, r18
    4932:	89 50       	subi	r24, 0x09	; 9
    4934:	83 30       	cpi	r24, 0x03	; 3
    4936:	08 f4       	brcc	.+2      	; 0x493a <convertFileName+0xa6>
    4938:	63 c0       	rjmp	.+198    	; 0x4a00 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    493a:	22 23       	and	r18, r18
    493c:	29 f4       	brne	.+10     	; 0x4948 <convertFileName+0xb4>
    493e:	01 c0       	rjmp	.+2      	; 0x4942 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4940:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4942:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    4944:	90 e2       	ldi	r25, 0x20	; 32
    4946:	10 c0       	rjmp	.+32     	; 0x4968 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4948:	de 01       	movw	r26, r28
    494a:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    494c:	82 2f       	mov	r24, r18
    494e:	81 50       	subi	r24, 0x01	; 1
    4950:	90 e0       	ldi	r25, 0x00	; 0
    4952:	8c 54       	subi	r24, 0x4C	; 76
    4954:	9f 4a       	sbci	r25, 0xAF	; 175
    4956:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    4958:	31 91       	ld	r19, Z+
    495a:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    495c:	e8 17       	cp	r30, r24
    495e:	f9 07       	cpc	r31, r25
    4960:	d9 f7       	brne	.-10     	; 0x4958 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4962:	28 30       	cpi	r18, 0x08	; 8
    4964:	70 f3       	brcs	.-36     	; 0x4942 <convertFileName+0xae>
    4966:	0a c0       	rjmp	.+20     	; 0x497c <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    4968:	e1 e0       	ldi	r30, 0x01	; 1
    496a:	f0 e0       	ldi	r31, 0x00	; 0
    496c:	ec 0f       	add	r30, r28
    496e:	fd 1f       	adc	r31, r29
    4970:	e8 0f       	add	r30, r24
    4972:	f1 1d       	adc	r31, r1
    4974:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4976:	8f 5f       	subi	r24, 0xFF	; 255
    4978:	88 30       	cpi	r24, 0x08	; 8
    497a:	b0 f3       	brcs	.-20     	; 0x4968 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    497c:	2c 30       	cpi	r18, 0x0C	; 12
    497e:	09 f0       	breq	.+2      	; 0x4982 <convertFileName+0xee>
    4980:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4982:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4984:	83 eb       	ldi	r24, 0xB3	; 179
    4986:	90 e5       	ldi	r25, 0x50	; 80
    4988:	fc 01       	movw	r30, r24
    498a:	e2 0f       	add	r30, r18
    498c:	f1 1d       	adc	r31, r1
    498e:	40 81       	ld	r20, Z
    4990:	44 23       	and	r20, r20
    4992:	19 f4       	brne	.+6      	; 0x499a <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4994:	3b 30       	cpi	r19, 0x0B	; 11
    4996:	50 f0       	brcs	.+20     	; 0x49ac <convertFileName+0x118>
    4998:	15 c0       	rjmp	.+42     	; 0x49c4 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    499a:	e1 e0       	ldi	r30, 0x01	; 1
    499c:	f0 e0       	ldi	r31, 0x00	; 0
    499e:	ec 0f       	add	r30, r28
    49a0:	fd 1f       	adc	r31, r29
    49a2:	e3 0f       	add	r30, r19
    49a4:	f1 1d       	adc	r31, r1
    49a6:	40 83       	st	Z, r20
    49a8:	2f 5f       	subi	r18, 0xFF	; 255
    49aa:	0c c0       	rjmp	.+24     	; 0x49c4 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    49ac:	80 e2       	ldi	r24, 0x20	; 32
    49ae:	e1 e0       	ldi	r30, 0x01	; 1
    49b0:	f0 e0       	ldi	r31, 0x00	; 0
    49b2:	ec 0f       	add	r30, r28
    49b4:	fd 1f       	adc	r31, r29
    49b6:	e3 0f       	add	r30, r19
    49b8:	f1 1d       	adc	r31, r1
    49ba:	80 83       	st	Z, r24
    49bc:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    49be:	3b 30       	cpi	r19, 0x0B	; 11
    49c0:	b1 f7       	brne	.-20     	; 0x49ae <convertFileName+0x11a>
    49c2:	03 c0       	rjmp	.+6      	; 0x49ca <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    49c4:	3f 5f       	subi	r19, 0xFF	; 255
    49c6:	3b 30       	cpi	r19, 0x0B	; 11
    49c8:	f8 f2       	brcs	.-66     	; 0x4988 <convertFileName+0xf4>
    49ca:	de 01       	movw	r26, r28
    49cc:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    49ce:	ce 01       	movw	r24, r28
    49d0:	0c 96       	adiw	r24, 0x0c	; 12
    49d2:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    49d4:	20 81       	ld	r18, Z
    49d6:	32 2f       	mov	r19, r18
    49d8:	31 56       	subi	r19, 0x61	; 97
    49da:	3a 31       	cpi	r19, 0x1A	; 26
    49dc:	10 f4       	brcc	.+4      	; 0x49e2 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    49de:	20 52       	subi	r18, 0x20	; 32
    49e0:	20 83       	st	Z, r18
    49e2:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    49e4:	e8 17       	cp	r30, r24
    49e6:	f9 07       	cpc	r31, r25
    49e8:	a9 f7       	brne	.-22     	; 0x49d4 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    49ea:	2d 91       	ld	r18, X+
    49ec:	f8 01       	movw	r30, r16
    49ee:	21 93       	st	Z+, r18
    49f0:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    49f2:	a8 17       	cp	r26, r24
    49f4:	b9 07       	cpc	r27, r25
    49f6:	c9 f7       	brne	.-14     	; 0x49ea <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    49f8:	80 e0       	ldi	r24, 0x00	; 0
    49fa:	03 c0       	rjmp	.+6      	; 0x4a02 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    49fc:	81 e0       	ldi	r24, 0x01	; 1
    49fe:	01 c0       	rjmp	.+2      	; 0x4a02 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4a00:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    4a02:	2b 96       	adiw	r28, 0x0b	; 11
    4a04:	cd bf       	out	0x3d, r28	; 61
    4a06:	de bf       	out	0x3e, r29	; 62
    4a08:	df 91       	pop	r29
    4a0a:	cf 91       	pop	r28
    4a0c:	1f 91       	pop	r17
    4a0e:	0f 91       	pop	r16
    4a10:	08 95       	ret

00004a12 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4a12:	4f 92       	push	r4
    4a14:	5f 92       	push	r5
    4a16:	6f 92       	push	r6
    4a18:	7f 92       	push	r7
    4a1a:	8f 92       	push	r8
    4a1c:	9f 92       	push	r9
    4a1e:	af 92       	push	r10
    4a20:	bf 92       	push	r11
    4a22:	cf 92       	push	r12
    4a24:	df 92       	push	r13
    4a26:	ef 92       	push	r14
    4a28:	ff 92       	push	r15
    4a2a:	cf 93       	push	r28
    4a2c:	df 93       	push	r29
    4a2e:	2b 01       	movw	r4, r22
    4a30:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4a32:	20 e8       	ldi	r18, 0x80	; 128
    4a34:	3f ef       	ldi	r19, 0xFF	; 255
    4a36:	4f ef       	ldi	r20, 0xFF	; 255
    4a38:	5f ef       	ldi	r21, 0xFF	; 255
    4a3a:	42 22       	and	r4, r18
    4a3c:	53 22       	and	r5, r19
    4a3e:	64 22       	and	r6, r20
    4a40:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4a42:	80 91 59 40 	lds	r24, 0x4059
    4a46:	90 91 5a 40 	lds	r25, 0x405A
    4a4a:	a0 91 5b 40 	lds	r26, 0x405B
    4a4e:	b0 91 5c 40 	lds	r27, 0x405C
    4a52:	48 16       	cp	r4, r24
    4a54:	59 06       	cpc	r5, r25
    4a56:	6a 06       	cpc	r6, r26
    4a58:	7b 06       	cpc	r7, r27
    4a5a:	08 f0       	brcs	.+2      	; 0x4a5e <searchNextFreeCluster+0x4c>
    4a5c:	77 c0       	rjmp	.+238    	; 0x4b4c <searchNextFreeCluster+0x13a>
    4a5e:	53 01       	movw	r10, r6
    4a60:	42 01       	movw	r8, r4
    4a62:	88 0c       	add	r8, r8
    4a64:	99 1c       	adc	r9, r9
    4a66:	aa 1c       	adc	r10, r10
    4a68:	bb 1c       	adc	r11, r11
    4a6a:	88 0c       	add	r8, r8
    4a6c:	99 1c       	adc	r9, r9
    4a6e:	aa 1c       	adc	r10, r10
    4a70:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4a72:	c6 ed       	ldi	r28, 0xD6	; 214
    4a74:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4a76:	c0 90 83 50 	lds	r12, 0x5083
    4a7a:	d0 90 84 50 	lds	r13, 0x5084
    4a7e:	20 91 54 40 	lds	r18, 0x4054
    4a82:	30 91 55 40 	lds	r19, 0x4055
    4a86:	ee 24       	eor	r14, r14
    4a88:	ff 24       	eor	r15, r15
    4a8a:	80 91 7d 50 	lds	r24, 0x507D
    4a8e:	90 91 7e 50 	lds	r25, 0x507E
    4a92:	a0 91 7f 50 	lds	r26, 0x507F
    4a96:	b0 91 80 50 	lds	r27, 0x5080
    4a9a:	c8 0e       	add	r12, r24
    4a9c:	d9 1e       	adc	r13, r25
    4a9e:	ea 1e       	adc	r14, r26
    4aa0:	fb 1e       	adc	r15, r27
    4aa2:	40 e0       	ldi	r20, 0x00	; 0
    4aa4:	50 e0       	ldi	r21, 0x00	; 0
    4aa6:	c5 01       	movw	r24, r10
    4aa8:	b4 01       	movw	r22, r8
    4aaa:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    4aae:	c7 01       	movw	r24, r14
    4ab0:	b6 01       	movw	r22, r12
    4ab2:	62 0f       	add	r22, r18
    4ab4:	73 1f       	adc	r23, r19
    4ab6:	84 1f       	adc	r24, r20
    4ab8:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    4aba:	ae 01       	movw	r20, r28
    4abc:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    4ac0:	88 81       	ld	r24, Y
    4ac2:	99 81       	ldd	r25, Y+1	; 0x01
    4ac4:	aa 81       	ldd	r26, Y+2	; 0x02
    4ac6:	bb 81       	ldd	r27, Y+3	; 0x03
    4ac8:	bf 70       	andi	r27, 0x0F	; 15
    4aca:	00 97       	sbiw	r24, 0x00	; 0
    4acc:	a1 05       	cpc	r26, r1
    4ace:	b1 05       	cpc	r27, r1
    4ad0:	99 f0       	breq	.+38     	; 0x4af8 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4ad2:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    4ad4:	e2 2f       	mov	r30, r18
    4ad6:	f0 e0       	ldi	r31, 0x00	; 0
    4ad8:	ee 0f       	add	r30, r30
    4ada:	ff 1f       	adc	r31, r31
    4adc:	ee 0f       	add	r30, r30
    4ade:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    4ae0:	ea 52       	subi	r30, 0x2A	; 42
    4ae2:	fe 4d       	sbci	r31, 0xDE	; 222
    4ae4:	80 81       	ld	r24, Z
    4ae6:	91 81       	ldd	r25, Z+1	; 0x01
    4ae8:	a2 81       	ldd	r26, Z+2	; 0x02
    4aea:	b3 81       	ldd	r27, Z+3	; 0x03
    4aec:	bf 70       	andi	r27, 0x0F	; 15
    4aee:	00 97       	sbiw	r24, 0x00	; 0
    4af0:	a1 05       	cpc	r26, r1
    4af2:	b1 05       	cpc	r27, r1
    4af4:	39 f4       	brne	.+14     	; 0x4b04 <searchNextFreeCluster+0xf2>
    4af6:	01 c0       	rjmp	.+2      	; 0x4afa <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4af8:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4afa:	42 0e       	add	r4, r18
    4afc:	51 1c       	adc	r5, r1
    4afe:	61 1c       	adc	r6, r1
    4b00:	71 1c       	adc	r7, r1
    4b02:	27 c0       	rjmp	.+78     	; 0x4b52 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4b04:	2f 5f       	subi	r18, 0xFF	; 255
    4b06:	32 f7       	brpl	.-52     	; 0x4ad4 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4b08:	80 e8       	ldi	r24, 0x80	; 128
    4b0a:	90 e0       	ldi	r25, 0x00	; 0
    4b0c:	a0 e0       	ldi	r26, 0x00	; 0
    4b0e:	b0 e0       	ldi	r27, 0x00	; 0
    4b10:	48 0e       	add	r4, r24
    4b12:	59 1e       	adc	r5, r25
    4b14:	6a 1e       	adc	r6, r26
    4b16:	7b 1e       	adc	r7, r27
    4b18:	80 91 59 40 	lds	r24, 0x4059
    4b1c:	90 91 5a 40 	lds	r25, 0x405A
    4b20:	a0 91 5b 40 	lds	r26, 0x405B
    4b24:	b0 91 5c 40 	lds	r27, 0x405C
    4b28:	20 e0       	ldi	r18, 0x00	; 0
    4b2a:	32 e0       	ldi	r19, 0x02	; 2
    4b2c:	40 e0       	ldi	r20, 0x00	; 0
    4b2e:	50 e0       	ldi	r21, 0x00	; 0
    4b30:	82 0e       	add	r8, r18
    4b32:	93 1e       	adc	r9, r19
    4b34:	a4 1e       	adc	r10, r20
    4b36:	b5 1e       	adc	r11, r21
    4b38:	48 16       	cp	r4, r24
    4b3a:	59 06       	cpc	r5, r25
    4b3c:	6a 06       	cpc	r6, r26
    4b3e:	7b 06       	cpc	r7, r27
    4b40:	08 f4       	brcc	.+2      	; 0x4b44 <searchNextFreeCluster+0x132>
    4b42:	99 cf       	rjmp	.-206    	; 0x4a76 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4b44:	44 24       	eor	r4, r4
    4b46:	55 24       	eor	r5, r5
    4b48:	32 01       	movw	r6, r4
    4b4a:	03 c0       	rjmp	.+6      	; 0x4b52 <searchNextFreeCluster+0x140>
    4b4c:	44 24       	eor	r4, r4
    4b4e:	55 24       	eor	r5, r5
    4b50:	32 01       	movw	r6, r4
}
    4b52:	64 2d       	mov	r22, r4
    4b54:	75 2d       	mov	r23, r5
    4b56:	86 2d       	mov	r24, r6
    4b58:	97 2d       	mov	r25, r7
    4b5a:	df 91       	pop	r29
    4b5c:	cf 91       	pop	r28
    4b5e:	ff 90       	pop	r15
    4b60:	ef 90       	pop	r14
    4b62:	df 90       	pop	r13
    4b64:	cf 90       	pop	r12
    4b66:	bf 90       	pop	r11
    4b68:	af 90       	pop	r10
    4b6a:	9f 90       	pop	r9
    4b6c:	8f 90       	pop	r8
    4b6e:	7f 90       	pop	r7
    4b70:	6f 90       	pop	r6
    4b72:	5f 90       	pop	r5
    4b74:	4f 90       	pop	r4
    4b76:	08 95       	ret

00004b78 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4b78:	cf 92       	push	r12
    4b7a:	df 92       	push	r13
    4b7c:	ef 92       	push	r14
    4b7e:	ff 92       	push	r15
    4b80:	cf 93       	push	r28
    4b82:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4b84:	db 01       	movw	r26, r22
    4b86:	ca 01       	movw	r24, r20
    4b88:	91 70       	andi	r25, 0x01	; 1
    4b8a:	a0 70       	andi	r26, 0x00	; 0
    4b8c:	b0 70       	andi	r27, 0x00	; 0
    4b8e:	00 97       	sbiw	r24, 0x00	; 0
    4b90:	a1 05       	cpc	r26, r1
    4b92:	b1 05       	cpc	r27, r1
    4b94:	51 f4       	brne	.+20     	; 0x4baa <freeMemoryUpdate+0x32>
    4b96:	03 2e       	mov	r0, r19
    4b98:	39 e0       	ldi	r19, 0x09	; 9
    4b9a:	76 95       	lsr	r23
    4b9c:	67 95       	ror	r22
    4b9e:	57 95       	ror	r21
    4ba0:	47 95       	ror	r20
    4ba2:	3a 95       	dec	r19
    4ba4:	d1 f7       	brne	.-12     	; 0x4b9a <freeMemoryUpdate+0x22>
    4ba6:	30 2d       	mov	r19, r0
    4ba8:	0d c0       	rjmp	.+26     	; 0x4bc4 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4baa:	03 2e       	mov	r0, r19
    4bac:	39 e0       	ldi	r19, 0x09	; 9
    4bae:	76 95       	lsr	r23
    4bb0:	67 95       	ror	r22
    4bb2:	57 95       	ror	r21
    4bb4:	47 95       	ror	r20
    4bb6:	3a 95       	dec	r19
    4bb8:	d1 f7       	brne	.-12     	; 0x4bae <freeMemoryUpdate+0x36>
    4bba:	30 2d       	mov	r19, r0
    4bbc:	4f 5f       	subi	r20, 0xFF	; 255
    4bbe:	5f 4f       	sbci	r21, 0xFF	; 255
    4bc0:	6f 4f       	sbci	r22, 0xFF	; 255
    4bc2:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4bc4:	db 01       	movw	r26, r22
    4bc6:	ca 01       	movw	r24, r20
    4bc8:	87 70       	andi	r24, 0x07	; 7
    4bca:	90 70       	andi	r25, 0x00	; 0
    4bcc:	a0 70       	andi	r26, 0x00	; 0
    4bce:	b0 70       	andi	r27, 0x00	; 0
    4bd0:	00 97       	sbiw	r24, 0x00	; 0
    4bd2:	a1 05       	cpc	r26, r1
    4bd4:	b1 05       	cpc	r27, r1
    4bd6:	59 f4       	brne	.+22     	; 0x4bee <freeMemoryUpdate+0x76>
    4bd8:	6a 01       	movw	r12, r20
    4bda:	7b 01       	movw	r14, r22
    4bdc:	68 94       	set
    4bde:	12 f8       	bld	r1, 2
    4be0:	f6 94       	lsr	r15
    4be2:	e7 94       	ror	r14
    4be4:	d7 94       	ror	r13
    4be6:	c7 94       	ror	r12
    4be8:	16 94       	lsr	r1
    4bea:	d1 f7       	brne	.-12     	; 0x4be0 <freeMemoryUpdate+0x68>
    4bec:	0f c0       	rjmp	.+30     	; 0x4c0c <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    4bee:	6a 01       	movw	r12, r20
    4bf0:	7b 01       	movw	r14, r22
    4bf2:	68 94       	set
    4bf4:	12 f8       	bld	r1, 2
    4bf6:	f6 94       	lsr	r15
    4bf8:	e7 94       	ror	r14
    4bfa:	d7 94       	ror	r13
    4bfc:	c7 94       	ror	r12
    4bfe:	16 94       	lsr	r1
    4c00:	d1 f7       	brne	.-12     	; 0x4bf6 <freeMemoryUpdate+0x7e>
    4c02:	08 94       	sec
    4c04:	c1 1c       	adc	r12, r1
    4c06:	d1 1c       	adc	r13, r1
    4c08:	e1 1c       	adc	r14, r1
    4c0a:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4c0c:	80 91 c7 50 	lds	r24, 0x50C7
    4c10:	88 23       	and	r24, r24
    4c12:	d1 f0       	breq	.+52     	; 0x4c48 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4c14:	81 e0       	ldi	r24, 0x01	; 1
    4c16:	60 e0       	ldi	r22, 0x00	; 0
    4c18:	20 e0       	ldi	r18, 0x00	; 0
    4c1a:	30 e0       	ldi	r19, 0x00	; 0
    4c1c:	a9 01       	movw	r20, r18
    4c1e:	0e 94 bd 22 	call	0x457a	; 0x457a <getSetFreeCluster>
	if(flag == ADD)
    4c22:	cc 23       	and	r28, r28
    4c24:	39 f4       	brne	.+14     	; 0x4c34 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4c26:	9b 01       	movw	r18, r22
    4c28:	ac 01       	movw	r20, r24
    4c2a:	2c 0d       	add	r18, r12
    4c2c:	3d 1d       	adc	r19, r13
    4c2e:	4e 1d       	adc	r20, r14
    4c30:	5f 1d       	adc	r21, r15
    4c32:	06 c0       	rjmp	.+12     	; 0x4c40 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4c34:	9b 01       	movw	r18, r22
    4c36:	ac 01       	movw	r20, r24
    4c38:	2c 19       	sub	r18, r12
    4c3a:	3d 09       	sbc	r19, r13
    4c3c:	4e 09       	sbc	r20, r14
    4c3e:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4c40:	81 e0       	ldi	r24, 0x01	; 1
    4c42:	61 e0       	ldi	r22, 0x01	; 1
    4c44:	0e 94 bd 22 	call	0x457a	; 0x457a <getSetFreeCluster>
  }
}
    4c48:	cf 91       	pop	r28
    4c4a:	ff 90       	pop	r15
    4c4c:	ef 90       	pop	r14
    4c4e:	df 90       	pop	r13
    4c50:	cf 90       	pop	r12
    4c52:	08 95       	ret

00004c54 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4c54:	2f 92       	push	r2
    4c56:	3f 92       	push	r3
    4c58:	4f 92       	push	r4
    4c5a:	5f 92       	push	r5
    4c5c:	6f 92       	push	r6
    4c5e:	7f 92       	push	r7
    4c60:	8f 92       	push	r8
    4c62:	9f 92       	push	r9
    4c64:	af 92       	push	r10
    4c66:	bf 92       	push	r11
    4c68:	cf 92       	push	r12
    4c6a:	df 92       	push	r13
    4c6c:	ef 92       	push	r14
    4c6e:	ff 92       	push	r15
    4c70:	0f 93       	push	r16
    4c72:	1f 93       	push	r17
    4c74:	cf 93       	push	r28
    4c76:	df 93       	push	r29
    4c78:	cd b7       	in	r28, 0x3d	; 61
    4c7a:	de b7       	in	r29, 0x3e	; 62
    4c7c:	2c 97       	sbiw	r28, 0x0c	; 12
    4c7e:	cd bf       	out	0x3d, r28	; 61
    4c80:	de bf       	out	0x3e, r29	; 62
    4c82:	88 2e       	mov	r8, r24
    4c84:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4c86:	80 91 5f 40 	lds	r24, 0x405F
    4c8a:	90 91 60 40 	lds	r25, 0x4060
    4c8e:	a0 91 61 40 	lds	r26, 0x4061
    4c92:	b0 91 62 40 	lds	r27, 0x4062
    4c96:	89 87       	std	Y+9, r24	; 0x09
    4c98:	9a 87       	std	Y+10, r25	; 0x0a
    4c9a:	ab 87       	std	Y+11, r26	; 0x0b
    4c9c:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c9e:	0f 2e       	mov	r0, r31
    4ca0:	f6 ed       	ldi	r31, 0xD6	; 214
    4ca2:	2f 2e       	mov	r2, r31
    4ca4:	f1 e2       	ldi	r31, 0x21	; 33
    4ca6:	3f 2e       	mov	r3, r31
    4ca8:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4caa:	c8 2c       	mov	r12, r8
    4cac:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4cae:	d2 2c       	mov	r13, r2
    4cb0:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4cb2:	5b 01       	movw	r10, r22
    4cb4:	08 94       	sec
    4cb6:	a1 1c       	adc	r10, r1
    4cb8:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4cba:	69 85       	ldd	r22, Y+9	; 0x09
    4cbc:	7a 85       	ldd	r23, Y+10	; 0x0a
    4cbe:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cc0:	9c 85       	ldd	r25, Y+12	; 0x0c
    4cc2:	0e 94 04 22 	call	0x4408	; 0x4408 <getFirstSector>
    4cc6:	6d 83       	std	Y+5, r22	; 0x05
    4cc8:	7e 83       	std	Y+6, r23	; 0x06
    4cca:	8f 83       	std	Y+7, r24	; 0x07
    4ccc:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4cce:	80 91 7b 50 	lds	r24, 0x507B
    4cd2:	90 91 7c 50 	lds	r25, 0x507C
    4cd6:	00 97       	sbiw	r24, 0x00	; 0
    4cd8:	09 f4       	brne	.+2      	; 0x4cdc <findFiles+0x88>
    4cda:	13 c1       	rjmp	.+550    	; 0x4f02 <findFiles+0x2ae>
    4cdc:	44 24       	eor	r4, r4
    4cde:	55 24       	eor	r5, r5
    4ce0:	32 01       	movw	r6, r4
    4ce2:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4ce4:	8d 81       	ldd	r24, Y+5	; 0x05
    4ce6:	9e 81       	ldd	r25, Y+6	; 0x06
    4ce8:	af 81       	ldd	r26, Y+7	; 0x07
    4cea:	b8 85       	ldd	r27, Y+8	; 0x08
    4cec:	84 0d       	add	r24, r4
    4cee:	95 1d       	adc	r25, r5
    4cf0:	a6 1d       	adc	r26, r6
    4cf2:	b7 1d       	adc	r27, r7
    4cf4:	89 83       	std	Y+1, r24	; 0x01
    4cf6:	9a 83       	std	Y+2, r25	; 0x02
    4cf8:	ab 83       	std	Y+3, r26	; 0x03
    4cfa:	bc 83       	std	Y+4, r27	; 0x04
    4cfc:	bc 01       	movw	r22, r24
    4cfe:	cd 01       	movw	r24, r26
    4d00:	4d 2d       	mov	r20, r13
    4d02:	59 2d       	mov	r21, r9
    4d04:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4d08:	80 91 54 40 	lds	r24, 0x4054
    4d0c:	90 91 55 40 	lds	r25, 0x4055
    4d10:	00 97       	sbiw	r24, 0x00	; 0
    4d12:	09 f4       	brne	.+2      	; 0x4d16 <findFiles+0xc2>
    4d14:	e4 c0       	rjmp	.+456    	; 0x4ede <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4d16:	d1 01       	movw	r26, r2
    4d18:	8c 91       	ld	r24, X
    4d1a:	88 23       	and	r24, r24
    4d1c:	09 f4       	brne	.+2      	; 0x4d20 <findFiles+0xcc>
    4d1e:	10 c1       	rjmp	.+544    	; 0x4f40 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4d20:	4d 2d       	mov	r20, r13
    4d22:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4d24:	20 e0       	ldi	r18, 0x00	; 0
    4d26:	30 e0       	ldi	r19, 0x00	; 0
    4d28:	08 c0       	rjmp	.+16     	; 0x4d3a <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4d2a:	a9 01       	movw	r20, r18
    4d2c:	4a 52       	subi	r20, 0x2A	; 42
    4d2e:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4d30:	fa 01       	movw	r30, r20
    4d32:	80 81       	ld	r24, Z
    4d34:	88 23       	and	r24, r24
    4d36:	09 f4       	brne	.+2      	; 0x4d3a <findFiles+0xe6>
    4d38:	06 c1       	rjmp	.+524    	; 0x4f46 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4d3a:	85 3e       	cpi	r24, 0xE5	; 229
    4d3c:	09 f4       	brne	.+2      	; 0x4d40 <findFiles+0xec>
    4d3e:	c5 c0       	rjmp	.+394    	; 0x4eca <findFiles+0x276>
    4d40:	da 01       	movw	r26, r20
    4d42:	1b 96       	adiw	r26, 0x0b	; 11
    4d44:	8c 91       	ld	r24, X
    4d46:	1b 97       	sbiw	r26, 0x0b	; 11
    4d48:	8f 30       	cpi	r24, 0x0F	; 15
    4d4a:	09 f4       	brne	.+2      	; 0x4d4e <findFiles+0xfa>
    4d4c:	be c0       	rjmp	.+380    	; 0x4eca <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4d4e:	12 30       	cpi	r17, 0x02	; 2
    4d50:	08 f0       	brcs	.+2      	; 0x4d54 <findFiles+0x100>
    4d52:	fc c0       	rjmp	.+504    	; 0x4f4c <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4d54:	9c 91       	ld	r25, X
    4d56:	f7 01       	movw	r30, r14
    4d58:	80 81       	ld	r24, Z
    4d5a:	98 17       	cp	r25, r24
    4d5c:	09 f0       	breq	.+2      	; 0x4d60 <findFiles+0x10c>
    4d5e:	b5 c0       	rjmp	.+362    	; 0x4eca <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4d60:	fa 01       	movw	r30, r20
    4d62:	31 96       	adiw	r30, 0x01	; 1
    4d64:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4d66:	81 e0       	ldi	r24, 0x01	; 1
    4d68:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4d6a:	41 91       	ld	r20, Z+
    4d6c:	9d 91       	ld	r25, X+
    4d6e:	49 17       	cp	r20, r25
    4d70:	31 f4       	brne	.+12     	; 0x4d7e <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4d72:	8f 5f       	subi	r24, 0xFF	; 255
    4d74:	8b 30       	cpi	r24, 0x0B	; 11
    4d76:	c9 f7       	brne	.-14     	; 0x4d6a <findFiles+0x116>
    4d78:	8b 01       	movw	r16, r22
    4d7a:	6b 01       	movw	r12, r22
    4d7c:	05 c0       	rjmp	.+10     	; 0x4d88 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4d7e:	8b 30       	cpi	r24, 0x0B	; 11
    4d80:	09 f0       	breq	.+2      	; 0x4d84 <findFiles+0x130>
    4d82:	a3 c0       	rjmp	.+326    	; 0x4eca <findFiles+0x276>
    4d84:	8b 01       	movw	r16, r22
    4d86:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4d88:	f1 e0       	ldi	r31, 0x01	; 1
    4d8a:	8f 16       	cp	r8, r31
    4d8c:	09 f0       	breq	.+2      	; 0x4d90 <findFiles+0x13c>
    4d8e:	41 c0       	rjmp	.+130    	; 0x4e12 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4d90:	89 81       	ldd	r24, Y+1	; 0x01
    4d92:	9a 81       	ldd	r25, Y+2	; 0x02
    4d94:	ab 81       	ldd	r26, Y+3	; 0x03
    4d96:	bc 81       	ldd	r27, Y+4	; 0x04
    4d98:	80 93 c9 50 	sts	0x50C9, r24
    4d9c:	90 93 ca 50 	sts	0x50CA, r25
    4da0:	a0 93 cb 50 	sts	0x50CB, r26
    4da4:	b0 93 cc 50 	sts	0x50CC, r27
				appendFileLocation = i;
    4da8:	c9 01       	movw	r24, r18
    4daa:	a0 e0       	ldi	r26, 0x00	; 0
    4dac:	b0 e0       	ldi	r27, 0x00	; 0
    4dae:	80 93 d7 23 	sts	0x23D7, r24
    4db2:	90 93 d8 23 	sts	0x23D8, r25
    4db6:	a0 93 d9 23 	sts	0x23D9, r26
    4dba:	b0 93 da 23 	sts	0x23DA, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4dbe:	d6 01       	movw	r26, r12
    4dc0:	54 96       	adiw	r26, 0x14	; 20
    4dc2:	4d 91       	ld	r20, X+
    4dc4:	5c 91       	ld	r21, X
    4dc6:	55 97       	sbiw	r26, 0x15	; 21
    4dc8:	60 e0       	ldi	r22, 0x00	; 0
    4dca:	70 e0       	ldi	r23, 0x00	; 0
    4dcc:	ba 01       	movw	r22, r20
    4dce:	55 27       	eor	r21, r21
    4dd0:	44 27       	eor	r20, r20
    4dd2:	5a 96       	adiw	r26, 0x1a	; 26
    4dd4:	8d 91       	ld	r24, X+
    4dd6:	9c 91       	ld	r25, X
    4dd8:	5b 97       	sbiw	r26, 0x1b	; 27
    4dda:	a0 e0       	ldi	r26, 0x00	; 0
    4ddc:	b0 e0       	ldi	r27, 0x00	; 0
    4dde:	84 2b       	or	r24, r20
    4de0:	95 2b       	or	r25, r21
    4de2:	a6 2b       	or	r26, r22
    4de4:	b7 2b       	or	r27, r23
    4de6:	80 93 87 50 	sts	0x5087, r24
    4dea:	90 93 88 50 	sts	0x5088, r25
    4dee:	a0 93 89 50 	sts	0x5089, r26
    4df2:	b0 93 8a 50 	sts	0x508A, r27
				fileSize = dir->fileSize;
    4df6:	f6 01       	movw	r30, r12
    4df8:	84 8d       	ldd	r24, Z+28	; 0x1c
    4dfa:	95 8d       	ldd	r25, Z+29	; 0x1d
    4dfc:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4dfe:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4e00:	80 93 50 40 	sts	0x4050, r24
    4e04:	90 93 51 40 	sts	0x4051, r25
    4e08:	a0 93 52 40 	sts	0x4052, r26
    4e0c:	b0 93 53 40 	sts	0x4053, r27
			    return (dir);
    4e10:	a5 c0       	rjmp	.+330    	; 0x4f5c <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4e12:	d6 01       	movw	r26, r12
    4e14:	54 96       	adiw	r26, 0x14	; 20
    4e16:	8d 91       	ld	r24, X+
    4e18:	9c 91       	ld	r25, X
    4e1a:	55 97       	sbiw	r26, 0x15	; 21
    4e1c:	a0 e0       	ldi	r26, 0x00	; 0
    4e1e:	b0 e0       	ldi	r27, 0x00	; 0
    4e20:	3c 01       	movw	r6, r24
    4e22:	55 24       	eor	r5, r5
    4e24:	44 24       	eor	r4, r4
    4e26:	f6 01       	movw	r30, r12
    4e28:	82 8d       	ldd	r24, Z+26	; 0x1a
    4e2a:	93 8d       	ldd	r25, Z+27	; 0x1b
    4e2c:	a0 e0       	ldi	r26, 0x00	; 0
    4e2e:	b0 e0       	ldi	r27, 0x00	; 0
    4e30:	48 2a       	or	r4, r24
    4e32:	59 2a       	or	r5, r25
    4e34:	6a 2a       	or	r6, r26
    4e36:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4e38:	85 ee       	ldi	r24, 0xE5	; 229
    4e3a:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4e3c:	69 81       	ldd	r22, Y+1	; 0x01
    4e3e:	7a 81       	ldd	r23, Y+2	; 0x02
    4e40:	8b 81       	ldd	r24, Y+3	; 0x03
    4e42:	9c 81       	ldd	r25, Y+4	; 0x04
    4e44:	46 ed       	ldi	r20, 0xD6	; 214
    4e46:	51 e2       	ldi	r21, 0x21	; 33
    4e48:	20 e0       	ldi	r18, 0x00	; 0
    4e4a:	32 e0       	ldi	r19, 0x02	; 2
    4e4c:	0e 94 5f 2c 	call	0x58be	; 0x58be <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4e50:	d6 01       	movw	r26, r12
    4e52:	5c 96       	adiw	r26, 0x1c	; 28
    4e54:	4d 91       	ld	r20, X+
    4e56:	5d 91       	ld	r21, X+
    4e58:	6d 91       	ld	r22, X+
    4e5a:	7c 91       	ld	r23, X
    4e5c:	5f 97       	sbiw	r26, 0x1f	; 31
    4e5e:	80 e0       	ldi	r24, 0x00	; 0
    4e60:	0e 94 bc 25 	call	0x4b78	; 0x4b78 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4e64:	82 e0       	ldi	r24, 0x02	; 2
    4e66:	60 e0       	ldi	r22, 0x00	; 0
    4e68:	20 e0       	ldi	r18, 0x00	; 0
    4e6a:	30 e0       	ldi	r19, 0x00	; 0
    4e6c:	a9 01       	movw	r20, r18
    4e6e:	0e 94 bd 22 	call	0x457a	; 0x457a <getSetFreeCluster>
    4e72:	dc 01       	movw	r26, r24
    4e74:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4e76:	48 16       	cp	r4, r24
    4e78:	59 06       	cpc	r5, r25
    4e7a:	6a 06       	cpc	r6, r26
    4e7c:	7b 06       	cpc	r7, r27
    4e7e:	30 f4       	brcc	.+12     	; 0x4e8c <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4e80:	82 e0       	ldi	r24, 0x02	; 2
    4e82:	61 e0       	ldi	r22, 0x01	; 1
    4e84:	a3 01       	movw	r20, r6
    4e86:	92 01       	movw	r18, r4
    4e88:	0e 94 bd 22 	call	0x457a	; 0x457a <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4e8c:	c3 01       	movw	r24, r6
    4e8e:	b2 01       	movw	r22, r4
    4e90:	40 e0       	ldi	r20, 0x00	; 0
    4e92:	00 e0       	ldi	r16, 0x00	; 0
    4e94:	10 e0       	ldi	r17, 0x00	; 0
    4e96:	98 01       	movw	r18, r16
    4e98:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
    4e9c:	6b 01       	movw	r12, r22
    4e9e:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4ea0:	c3 01       	movw	r24, r6
    4ea2:	b2 01       	movw	r22, r4
    4ea4:	41 e0       	ldi	r20, 0x01	; 1
    4ea6:	00 e0       	ldi	r16, 0x00	; 0
    4ea8:	10 e0       	ldi	r17, 0x00	; 0
    4eaa:	98 01       	movw	r18, r16
    4eac:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4eb0:	b7 ef       	ldi	r27, 0xF7	; 247
    4eb2:	cb 16       	cp	r12, r27
    4eb4:	bf ef       	ldi	r27, 0xFF	; 255
    4eb6:	db 06       	cpc	r13, r27
    4eb8:	bf ef       	ldi	r27, 0xFF	; 255
    4eba:	eb 06       	cpc	r14, r27
    4ebc:	bf e0       	ldi	r27, 0x0F	; 15
    4ebe:	fb 06       	cpc	r15, r27
    4ec0:	08 f0       	brcs	.+2      	; 0x4ec4 <findFiles+0x270>
    4ec2:	47 c0       	rjmp	.+142    	; 0x4f52 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4ec4:	26 01       	movw	r4, r12
    4ec6:	37 01       	movw	r6, r14
    4ec8:	e1 cf       	rjmp	.-62     	; 0x4e8c <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4eca:	20 5e       	subi	r18, 0xE0	; 224
    4ecc:	3f 4f       	sbci	r19, 0xFF	; 255
    4ece:	80 91 54 40 	lds	r24, 0x4054
    4ed2:	90 91 55 40 	lds	r25, 0x4055
    4ed6:	28 17       	cp	r18, r24
    4ed8:	39 07       	cpc	r19, r25
    4eda:	08 f4       	brcc	.+2      	; 0x4ede <findFiles+0x28a>
    4edc:	26 cf       	rjmp	.-436    	; 0x4d2a <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4ede:	08 94       	sec
    4ee0:	41 1c       	adc	r4, r1
    4ee2:	51 1c       	adc	r5, r1
    4ee4:	61 1c       	adc	r6, r1
    4ee6:	71 1c       	adc	r7, r1
    4ee8:	80 91 7b 50 	lds	r24, 0x507B
    4eec:	90 91 7c 50 	lds	r25, 0x507C
    4ef0:	a0 e0       	ldi	r26, 0x00	; 0
    4ef2:	b0 e0       	ldi	r27, 0x00	; 0
    4ef4:	48 16       	cp	r4, r24
    4ef6:	59 06       	cpc	r5, r25
    4ef8:	6a 06       	cpc	r6, r26
    4efa:	7b 06       	cpc	r7, r27
    4efc:	08 f4       	brcc	.+2      	; 0x4f00 <findFiles+0x2ac>
    4efe:	f2 ce       	rjmp	.-540    	; 0x4ce4 <findFiles+0x90>
    4f00:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4f02:	69 85       	ldd	r22, Y+9	; 0x09
    4f04:	7a 85       	ldd	r23, Y+10	; 0x0a
    4f06:	8b 85       	ldd	r24, Y+11	; 0x0b
    4f08:	9c 85       	ldd	r25, Y+12	; 0x0c
    4f0a:	40 e0       	ldi	r20, 0x00	; 0
    4f0c:	00 e0       	ldi	r16, 0x00	; 0
    4f0e:	10 e0       	ldi	r17, 0x00	; 0
    4f10:	98 01       	movw	r18, r16
    4f12:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
    4f16:	69 87       	std	Y+9, r22	; 0x09
    4f18:	7a 87       	std	Y+10, r23	; 0x0a
    4f1a:	8b 87       	std	Y+11, r24	; 0x0b
    4f1c:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4f1e:	67 3f       	cpi	r22, 0xF7	; 247
    4f20:	ef ef       	ldi	r30, 0xFF	; 255
    4f22:	7e 07       	cpc	r23, r30
    4f24:	ef ef       	ldi	r30, 0xFF	; 255
    4f26:	8e 07       	cpc	r24, r30
    4f28:	ef e0       	ldi	r30, 0x0F	; 15
    4f2a:	9e 07       	cpc	r25, r30
    4f2c:	a8 f4       	brcc	.+42     	; 0x4f58 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4f2e:	61 15       	cp	r22, r1
    4f30:	71 05       	cpc	r23, r1
    4f32:	81 05       	cpc	r24, r1
    4f34:	91 05       	cpc	r25, r1
    4f36:	09 f0       	breq	.+2      	; 0x4f3a <findFiles+0x2e6>
    4f38:	c0 ce       	rjmp	.-640    	; 0x4cba <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4f3a:	00 e0       	ldi	r16, 0x00	; 0
    4f3c:	10 e0       	ldi	r17, 0x00	; 0
    4f3e:	0e c0       	rjmp	.+28     	; 0x4f5c <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4f40:	00 e0       	ldi	r16, 0x00	; 0
    4f42:	10 e0       	ldi	r17, 0x00	; 0
    4f44:	0b c0       	rjmp	.+22     	; 0x4f5c <findFiles+0x308>
    4f46:	00 e0       	ldi	r16, 0x00	; 0
    4f48:	10 e0       	ldi	r17, 0x00	; 0
    4f4a:	08 c0       	rjmp	.+16     	; 0x4f5c <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4f4c:	00 e0       	ldi	r16, 0x00	; 0
    4f4e:	10 e0       	ldi	r17, 0x00	; 0
    4f50:	05 c0       	rjmp	.+10     	; 0x4f5c <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4f52:	00 e0       	ldi	r16, 0x00	; 0
    4f54:	10 e0       	ldi	r17, 0x00	; 0
    4f56:	02 c0       	rjmp	.+4      	; 0x4f5c <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4f58:	00 e0       	ldi	r16, 0x00	; 0
    4f5a:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4f5c:	80 2f       	mov	r24, r16
    4f5e:	91 2f       	mov	r25, r17
    4f60:	2c 96       	adiw	r28, 0x0c	; 12
    4f62:	cd bf       	out	0x3d, r28	; 61
    4f64:	de bf       	out	0x3e, r29	; 62
    4f66:	df 91       	pop	r29
    4f68:	cf 91       	pop	r28
    4f6a:	1f 91       	pop	r17
    4f6c:	0f 91       	pop	r16
    4f6e:	ff 90       	pop	r15
    4f70:	ef 90       	pop	r14
    4f72:	df 90       	pop	r13
    4f74:	cf 90       	pop	r12
    4f76:	bf 90       	pop	r11
    4f78:	af 90       	pop	r10
    4f7a:	9f 90       	pop	r9
    4f7c:	8f 90       	pop	r8
    4f7e:	7f 90       	pop	r7
    4f80:	6f 90       	pop	r6
    4f82:	5f 90       	pop	r5
    4f84:	4f 90       	pop	r4
    4f86:	3f 90       	pop	r3
    4f88:	2f 90       	pop	r2
    4f8a:	08 95       	ret

00004f8c <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4f8c:	0e 94 4a 24 	call	0x4894	; 0x4894 <convertFileName>
  if(error) return;
    4f90:	88 23       	and	r24, r24
    4f92:	29 f4       	brne	.+10     	; 0x4f9e <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4f94:	82 e0       	ldi	r24, 0x02	; 2
    4f96:	63 eb       	ldi	r22, 0xB3	; 179
    4f98:	70 e5       	ldi	r23, 0x50	; 80
    4f9a:	0e 94 2a 26 	call	0x4c54	; 0x4c54 <findFiles>
    4f9e:	08 95       	ret

00004fa0 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4fa0:	4f 92       	push	r4
    4fa2:	5f 92       	push	r5
    4fa4:	6f 92       	push	r6
    4fa6:	7f 92       	push	r7
    4fa8:	af 92       	push	r10
    4faa:	bf 92       	push	r11
    4fac:	cf 92       	push	r12
    4fae:	df 92       	push	r13
    4fb0:	ef 92       	push	r14
    4fb2:	ff 92       	push	r15
    4fb4:	0f 93       	push	r16
    4fb6:	1f 93       	push	r17
    4fb8:	cf 93       	push	r28
    4fba:	c8 2f       	mov	r28, r24
    4fbc:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4fbe:	0e 94 4a 24 	call	0x4894	; 0x4894 <convertFileName>
if(error) return 2;
    4fc2:	88 23       	and	r24, r24
    4fc4:	09 f0       	breq	.+2      	; 0x4fc8 <readFile+0x28>
    4fc6:	57 c0       	rjmp	.+174    	; 0x5076 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4fc8:	81 e0       	ldi	r24, 0x01	; 1
    4fca:	63 eb       	ldi	r22, 0xB3	; 179
    4fcc:	70 e5       	ldi	r23, 0x50	; 80
    4fce:	0e 94 2a 26 	call	0x4c54	; 0x4c54 <findFiles>
    4fd2:	fc 01       	movw	r30, r24
if(dir == 0) 
    4fd4:	00 97       	sbiw	r24, 0x00	; 0
    4fd6:	31 f4       	brne	.+12     	; 0x4fe4 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4fd8:	81 e0       	ldi	r24, 0x01	; 1
    4fda:	cc 23       	and	r28, r28
    4fdc:	09 f4       	brne	.+2      	; 0x4fe0 <readFile+0x40>
    4fde:	4e c0       	rjmp	.+156    	; 0x507c <readFile+0xdc>
    4fe0:	80 e0       	ldi	r24, 0x00	; 0
    4fe2:	4c c0       	rjmp	.+152    	; 0x507c <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4fe4:	c1 30       	cpi	r28, 0x01	; 1
    4fe6:	09 f4       	brne	.+2      	; 0x4fea <readFile+0x4a>
    4fe8:	48 c0       	rjmp	.+144    	; 0x507a <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4fea:	44 88       	ldd	r4, Z+20	; 0x14
    4fec:	55 88       	ldd	r5, Z+21	; 0x15
    4fee:	66 24       	eor	r6, r6
    4ff0:	77 24       	eor	r7, r7
    4ff2:	32 01       	movw	r6, r4
    4ff4:	55 24       	eor	r5, r5
    4ff6:	44 24       	eor	r4, r4
    4ff8:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ffa:	93 8d       	ldd	r25, Z+27	; 0x1b
    4ffc:	a0 e0       	ldi	r26, 0x00	; 0
    4ffe:	b0 e0       	ldi	r27, 0x00	; 0
    5000:	48 2a       	or	r4, r24
    5002:	59 2a       	or	r5, r25
    5004:	6a 2a       	or	r6, r26
    5006:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    5008:	0f 2e       	mov	r0, r31
    500a:	ff ed       	ldi	r31, 0xDF	; 223
    500c:	af 2e       	mov	r10, r31
    500e:	f3 e2       	ldi	r31, 0x23	; 35
    5010:	bf 2e       	mov	r11, r31
    5012:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    5014:	c3 01       	movw	r24, r6
    5016:	b2 01       	movw	r22, r4
    5018:	0e 94 04 22 	call	0x4408	; 0x4408 <getFirstSector>
    501c:	6b 01       	movw	r12, r22
    501e:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    5020:	80 91 7b 50 	lds	r24, 0x507B
    5024:	90 91 7c 50 	lds	r25, 0x507C
    5028:	00 97       	sbiw	r24, 0x00	; 0
    502a:	a1 f0       	breq	.+40     	; 0x5054 <readFile+0xb4>
    502c:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    502e:	c7 01       	movw	r24, r14
    5030:	b6 01       	movw	r22, r12
    5032:	6c 0f       	add	r22, r28
    5034:	71 1d       	adc	r23, r1
    5036:	81 1d       	adc	r24, r1
    5038:	91 1d       	adc	r25, r1
    503a:	a5 01       	movw	r20, r10
    503c:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    5040:	cf 5f       	subi	r28, 0xFF	; 255
    5042:	80 91 7b 50 	lds	r24, 0x507B
    5046:	90 91 7c 50 	lds	r25, 0x507C
    504a:	2c 2f       	mov	r18, r28
    504c:	30 e0       	ldi	r19, 0x00	; 0
    504e:	28 17       	cp	r18, r24
    5050:	39 07       	cpc	r19, r25
    5052:	68 f3       	brcs	.-38     	; 0x502e <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    5054:	c3 01       	movw	r24, r6
    5056:	b2 01       	movw	r22, r4
    5058:	40 e0       	ldi	r20, 0x00	; 0
    505a:	00 e0       	ldi	r16, 0x00	; 0
    505c:	10 e0       	ldi	r17, 0x00	; 0
    505e:	98 01       	movw	r18, r16
    5060:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
    5064:	2b 01       	movw	r4, r22
    5066:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    5068:	61 15       	cp	r22, r1
    506a:	71 05       	cpc	r23, r1
    506c:	81 05       	cpc	r24, r1
    506e:	91 05       	cpc	r25, r1
    5070:	89 f6       	brne	.-94     	; 0x5014 <readFile+0x74>
	  return 0;}
    5072:	80 e0       	ldi	r24, 0x00	; 0
    5074:	03 c0       	rjmp	.+6      	; 0x507c <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    5076:	82 e0       	ldi	r24, 0x02	; 2
    5078:	01 c0       	rjmp	.+2      	; 0x507c <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    507a:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    507c:	cf 91       	pop	r28
    507e:	1f 91       	pop	r17
    5080:	0f 91       	pop	r16
    5082:	ff 90       	pop	r15
    5084:	ef 90       	pop	r14
    5086:	df 90       	pop	r13
    5088:	cf 90       	pop	r12
    508a:	bf 90       	pop	r11
    508c:	af 90       	pop	r10
    508e:	7f 90       	pop	r7
    5090:	6f 90       	pop	r6
    5092:	5f 90       	pop	r5
    5094:	4f 90       	pop	r4
    5096:	08 95       	ret

00005098 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    5098:	2f 92       	push	r2
    509a:	3f 92       	push	r3
    509c:	4f 92       	push	r4
    509e:	5f 92       	push	r5
    50a0:	6f 92       	push	r6
    50a2:	7f 92       	push	r7
    50a4:	8f 92       	push	r8
    50a6:	9f 92       	push	r9
    50a8:	af 92       	push	r10
    50aa:	bf 92       	push	r11
    50ac:	cf 92       	push	r12
    50ae:	df 92       	push	r13
    50b0:	ef 92       	push	r14
    50b2:	ff 92       	push	r15
    50b4:	0f 93       	push	r16
    50b6:	1f 93       	push	r17
    50b8:	cf 93       	push	r28
    50ba:	df 93       	push	r29
    50bc:	cd b7       	in	r28, 0x3d	; 61
    50be:	de b7       	in	r29, 0x3e	; 62
    50c0:	60 97       	sbiw	r28, 0x10	; 16
    50c2:	cd bf       	out	0x3d, r28	; 61
    50c4:	de bf       	out	0x3e, r29	; 62
    50c6:	fc 01       	movw	r30, r24
    50c8:	6d 83       	std	Y+5, r22	; 0x05
    50ca:	7e 83       	std	Y+6, r23	; 0x06
    50cc:	49 01       	movw	r8, r18
    50ce:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    50d0:	81 e0       	ldi	r24, 0x01	; 1
    50d2:	bf 01       	movw	r22, r30
    50d4:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <readFile>

if(j == 1) 
    50d8:	81 30       	cpi	r24, 0x01	; 1
    50da:	09 f0       	breq	.+2      	; 0x50de <writeFile+0x46>
    50dc:	7b c0       	rjmp	.+246    	; 0x51d4 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    50de:	00 91 87 50 	lds	r16, 0x5087
    50e2:	10 91 88 50 	lds	r17, 0x5088
    50e6:	20 91 89 50 	lds	r18, 0x5089
    50ea:	30 91 8a 50 	lds	r19, 0x508A
    50ee:	09 83       	std	Y+1, r16	; 0x01
    50f0:	1a 83       	std	Y+2, r17	; 0x02
    50f2:	2b 83       	std	Y+3, r18	; 0x03
    50f4:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    50f6:	cc 24       	eor	r12, r12
    50f8:	dd 24       	eor	r13, r13
    50fa:	76 01       	movw	r14, r12
    50fc:	24 01       	movw	r4, r8
    50fe:	35 01       	movw	r6, r10
    5100:	48 01       	movw	r8, r16
    5102:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    5104:	c5 01       	movw	r24, r10
    5106:	b4 01       	movw	r22, r8
    5108:	40 e0       	ldi	r20, 0x00	; 0
    510a:	00 e0       	ldi	r16, 0x00	; 0
    510c:	10 e0       	ldi	r17, 0x00	; 0
    510e:	98 01       	movw	r18, r16
    5110:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
    5114:	dc 01       	movw	r26, r24
    5116:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    5118:	8f 3f       	cpi	r24, 0xFF	; 255
    511a:	1f ef       	ldi	r17, 0xFF	; 255
    511c:	91 07       	cpc	r25, r17
    511e:	1f ef       	ldi	r17, 0xFF	; 255
    5120:	a1 07       	cpc	r26, r17
    5122:	1f ef       	ldi	r17, 0xFF	; 255
    5124:	b1 07       	cpc	r27, r17
    5126:	41 f0       	breq	.+16     	; 0x5138 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    5128:	08 94       	sec
    512a:	c1 1c       	adc	r12, r1
    512c:	d1 1c       	adc	r13, r1
    512e:	e1 1c       	adc	r14, r1
    5130:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    5132:	4c 01       	movw	r8, r24
    5134:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    5136:	e6 cf       	rjmp	.-52     	; 0x5104 <writeFile+0x6c>
    5138:	89 82       	std	Y+1, r8	; 0x01
    513a:	9a 82       	std	Y+2, r9	; 0x02
    513c:	ab 82       	std	Y+3, r10	; 0x03
    513e:	bc 82       	std	Y+4, r11	; 0x04
    5140:	53 01       	movw	r10, r6
    5142:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    5144:	20 91 7b 50 	lds	r18, 0x507B
    5148:	30 91 7c 50 	lds	r19, 0x507C
    514c:	80 91 54 40 	lds	r24, 0x4054
    5150:	90 91 55 40 	lds	r25, 0x4055
    5154:	60 90 54 40 	lds	r6, 0x4054
    5158:	70 90 55 40 	lds	r7, 0x4055
    515c:	bc 01       	movw	r22, r24
    515e:	80 e0       	ldi	r24, 0x00	; 0
    5160:	90 e0       	ldi	r25, 0x00	; 0
    5162:	40 e0       	ldi	r20, 0x00	; 0
    5164:	50 e0       	ldi	r21, 0x00	; 0
    5166:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    516a:	a7 01       	movw	r20, r14
    516c:	96 01       	movw	r18, r12
    516e:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    5172:	dc 01       	movw	r26, r24
    5174:	cb 01       	movw	r24, r22
    5176:	40 91 50 40 	lds	r20, 0x4050
    517a:	50 91 51 40 	lds	r21, 0x4051
    517e:	60 91 52 40 	lds	r22, 0x4052
    5182:	70 91 53 40 	lds	r23, 0x4053
    5186:	8a 01       	movw	r16, r20
    5188:	9b 01       	movw	r18, r22
    518a:	08 1b       	sub	r16, r24
    518c:	19 0b       	sbc	r17, r25
    518e:	2a 0b       	sbc	r18, r26
    5190:	3b 0b       	sbc	r19, r27
    5192:	c9 01       	movw	r24, r18
    5194:	b8 01       	movw	r22, r16
    5196:	93 01       	movw	r18, r6
    5198:	40 e0       	ldi	r20, 0x00	; 0
    519a:	50 e0       	ldi	r21, 0x00	; 0
    519c:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    51a0:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    51a2:	69 81       	ldd	r22, Y+1	; 0x01
    51a4:	7a 81       	ldd	r23, Y+2	; 0x02
    51a6:	8b 81       	ldd	r24, Y+3	; 0x03
    51a8:	9c 81       	ldd	r25, Y+4	; 0x04
    51aa:	0e 94 04 22 	call	0x4408	; 0x4408 <getFirstSector>
    51ae:	dc 01       	movw	r26, r24
    51b0:	cb 01       	movw	r24, r22
    51b2:	20 2e       	mov	r2, r16
    51b4:	33 24       	eor	r3, r3
    51b6:	28 0e       	add	r2, r24
    51b8:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    51ba:	b1 01       	movw	r22, r2
    51bc:	80 e0       	ldi	r24, 0x00	; 0
    51be:	90 e0       	ldi	r25, 0x00	; 0
    51c0:	46 ed       	ldi	r20, 0xD6	; 214
    51c2:	51 e2       	ldi	r21, 0x21	; 33
    51c4:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    51c8:	1f 86       	std	Y+15, r1	; 0x0f
    51ca:	18 8a       	std	Y+16, r1	; 0x10
    51cc:	19 86       	std	Y+9, r1	; 0x09
    51ce:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    51d0:	11 e0       	ldi	r17, 0x01	; 1
    51d2:	4c c0       	rjmp	.+152    	; 0x526c <writeFile+0x1d4>
}
else if(j == 2) 
    51d4:	82 30       	cpi	r24, 0x02	; 2
    51d6:	09 f4       	brne	.+2      	; 0x51da <writeFile+0x142>
    51d8:	0c c2       	rjmp	.+1048   	; 0x55f2 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    51da:	82 e0       	ldi	r24, 0x02	; 2
    51dc:	60 e0       	ldi	r22, 0x00	; 0
    51de:	20 e0       	ldi	r18, 0x00	; 0
    51e0:	30 e0       	ldi	r19, 0x00	; 0
    51e2:	a9 01       	movw	r20, r18
    51e4:	0e 94 bd 22 	call	0x457a	; 0x457a <getSetFreeCluster>
  if(cluster > totalClusters)
    51e8:	00 91 59 40 	lds	r16, 0x4059
    51ec:	10 91 5a 40 	lds	r17, 0x405A
    51f0:	20 91 5b 40 	lds	r18, 0x405B
    51f4:	30 91 5c 40 	lds	r19, 0x405C
    51f8:	06 17       	cp	r16, r22
    51fa:	17 07       	cpc	r17, r23
    51fc:	28 07       	cpc	r18, r24
    51fe:	39 07       	cpc	r19, r25
    5200:	40 f4       	brcc	.+16     	; 0x5212 <writeFile+0x17a>
     cluster = rootCluster;
    5202:	60 91 5f 40 	lds	r22, 0x405F
    5206:	70 91 60 40 	lds	r23, 0x4060
    520a:	80 91 61 40 	lds	r24, 0x4061
    520e:	90 91 62 40 	lds	r25, 0x4062

  cluster = searchNextFreeCluster(cluster);
    5212:	0e 94 09 25 	call	0x4a12	; 0x4a12 <searchNextFreeCluster>
    5216:	69 83       	std	Y+1, r22	; 0x01
    5218:	7a 83       	std	Y+2, r23	; 0x02
    521a:	8b 83       	std	Y+3, r24	; 0x03
    521c:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    521e:	61 15       	cp	r22, r1
    5220:	71 05       	cpc	r23, r1
    5222:	81 05       	cpc	r24, r1
    5224:	91 05       	cpc	r25, r1
    5226:	09 f4       	brne	.+2      	; 0x522a <writeFile+0x192>
    5228:	e6 c1       	rjmp	.+972    	; 0x55f6 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    522a:	41 e0       	ldi	r20, 0x01	; 1
    522c:	0f ef       	ldi	r16, 0xFF	; 255
    522e:	1f ef       	ldi	r17, 0xFF	; 255
    5230:	98 01       	movw	r18, r16
    5232:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    5236:	2b 81       	ldd	r18, Y+3	; 0x03
    5238:	3c 81       	ldd	r19, Y+4	; 0x04
    523a:	29 87       	std	Y+9, r18	; 0x09
    523c:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    523e:	89 81       	ldd	r24, Y+1	; 0x01
    5240:	9a 81       	ldd	r25, Y+2	; 0x02
    5242:	8f 87       	std	Y+15, r24	; 0x0f
    5244:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    5246:	10 92 50 40 	sts	0x4050, r1
    524a:	10 92 51 40 	sts	0x4051, r1
    524e:	10 92 52 40 	sts	0x4052, r1
    5252:	10 92 53 40 	sts	0x4053, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    5256:	69 81       	ldd	r22, Y+1	; 0x01
    5258:	7a 81       	ldd	r23, Y+2	; 0x02
    525a:	8b 81       	ldd	r24, Y+3	; 0x03
    525c:	9c 81       	ldd	r25, Y+4	; 0x04
    525e:	0e 94 04 22 	call	0x4408	; 0x4408 <getFirstSector>
    5262:	dc 01       	movw	r26, r24
    5264:	cb 01       	movw	r24, r22
    5266:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    5268:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    526a:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    526c:	81 14       	cp	r8, r1
    526e:	91 04       	cpc	r9, r1
    5270:	a1 04       	cpc	r10, r1
    5272:	b1 04       	cpc	r11, r1
    5274:	09 f4       	brne	.+2      	; 0x5278 <writeFile+0x1e0>
    5276:	8d c0       	rjmp	.+282    	; 0x5392 <writeFile+0x2fa>
    5278:	44 24       	eor	r4, r4
    527a:	55 24       	eor	r5, r5
    527c:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    527e:	c0 2e       	mov	r12, r16
    5280:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    5282:	90 e0       	ldi	r25, 0x00	; 0
    5284:	89 16       	cp	r8, r25
    5286:	92 e0       	ldi	r25, 0x02	; 2
    5288:	99 06       	cpc	r9, r25
    528a:	90 e0       	ldi	r25, 0x00	; 0
    528c:	a9 06       	cpc	r10, r25
    528e:	90 e0       	ldi	r25, 0x00	; 0
    5290:	b9 06       	cpc	r11, r25
    5292:	88 f0       	brcs	.+34     	; 0x52b6 <writeFile+0x21e>
		 writtenData += 512;
    5294:	00 e0       	ldi	r16, 0x00	; 0
    5296:	12 e0       	ldi	r17, 0x02	; 2
    5298:	20 e0       	ldi	r18, 0x00	; 0
    529a:	30 e0       	ldi	r19, 0x00	; 0
    529c:	40 0e       	add	r4, r16
    529e:	51 1e       	adc	r5, r17
    52a0:	62 1e       	adc	r6, r18
    52a2:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    52a4:	80 e0       	ldi	r24, 0x00	; 0
    52a6:	9e ef       	ldi	r25, 0xFE	; 254
    52a8:	af ef       	ldi	r26, 0xFF	; 255
    52aa:	bf ef       	ldi	r27, 0xFF	; 255
    52ac:	88 0e       	add	r8, r24
    52ae:	99 1e       	adc	r9, r25
    52b0:	aa 1e       	adc	r10, r26
    52b2:	bb 1e       	adc	r11, r27
    52b4:	0c c0       	rjmp	.+24     	; 0x52ce <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    52b6:	48 0c       	add	r4, r8
    52b8:	59 1c       	adc	r5, r9
    52ba:	6a 1c       	adc	r6, r10
    52bc:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    52be:	95 01       	movw	r18, r10
    52c0:	84 01       	movw	r16, r8
    52c2:	11 70       	andi	r17, 0x01	; 1
    52c4:	20 70       	andi	r18, 0x00	; 0
    52c6:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    52c8:	88 24       	eor	r8, r8
    52ca:	99 24       	eor	r9, r9
    52cc:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    52ce:	80 91 50 40 	lds	r24, 0x4050
    52d2:	90 91 51 40 	lds	r25, 0x4051
    52d6:	a0 91 52 40 	lds	r26, 0x4052
    52da:	b0 91 53 40 	lds	r27, 0x4053
    52de:	80 50       	subi	r24, 0x00	; 0
    52e0:	9e 4f       	sbci	r25, 0xFE	; 254
    52e2:	af 4f       	sbci	r26, 0xFF	; 255
    52e4:	bf 4f       	sbci	r27, 0xFF	; 255
    52e6:	80 93 50 40 	sts	0x4050, r24
    52ea:	90 93 51 40 	sts	0x4051, r25
    52ee:	a0 93 52 40 	sts	0x4052, r26
    52f2:	b0 93 53 40 	sts	0x4053, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    52f6:	b1 01       	movw	r22, r2
    52f8:	80 e0       	ldi	r24, 0x00	; 0
    52fa:	90 e0       	ldi	r25, 0x00	; 0
    52fc:	a2 01       	movw	r20, r4
    52fe:	40 1b       	sub	r20, r16
    5300:	51 0b       	sbc	r21, r17
    5302:	ad 81       	ldd	r26, Y+5	; 0x05
    5304:	be 81       	ldd	r27, Y+6	; 0x06
    5306:	4a 0f       	add	r20, r26
    5308:	5b 1f       	adc	r21, r27
    530a:	98 01       	movw	r18, r16
    530c:	0e 94 5f 2c 	call	0x58be	; 0x58be <SD_write_block>
	j++;
    5310:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    5312:	20 91 7b 50 	lds	r18, 0x507B
    5316:	30 91 7c 50 	lds	r19, 0x507C
    531a:	8c 2d       	mov	r24, r12
    531c:	90 e0       	ldi	r25, 0x00	; 0
    531e:	82 17       	cp	r24, r18
    5320:	93 07       	cpc	r25, r19
    5322:	29 f5       	brne	.+74     	; 0x536e <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5324:	69 81       	ldd	r22, Y+1	; 0x01
    5326:	7a 81       	ldd	r23, Y+2	; 0x02
    5328:	8b 81       	ldd	r24, Y+3	; 0x03
    532a:	9c 81       	ldd	r25, Y+4	; 0x04
    532c:	0e 94 09 25 	call	0x4a12	; 0x4a12 <searchNextFreeCluster>
    5330:	6b 01       	movw	r12, r22
    5332:	7c 01       	movw	r14, r24
		if(cluster == 0){
    5334:	61 15       	cp	r22, r1
    5336:	71 05       	cpc	r23, r1
    5338:	81 05       	cpc	r24, r1
    533a:	91 05       	cpc	r25, r1
    533c:	09 f4       	brne	.+2      	; 0x5340 <writeFile+0x2a8>
    533e:	5d c1       	rjmp	.+698    	; 0x55fa <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    5340:	69 81       	ldd	r22, Y+1	; 0x01
    5342:	7a 81       	ldd	r23, Y+2	; 0x02
    5344:	8b 81       	ldd	r24, Y+3	; 0x03
    5346:	9c 81       	ldd	r25, Y+4	; 0x04
    5348:	41 e0       	ldi	r20, 0x01	; 1
    534a:	97 01       	movw	r18, r14
    534c:	86 01       	movw	r16, r12
    534e:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    5352:	c7 01       	movw	r24, r14
    5354:	b6 01       	movw	r22, r12
    5356:	41 e0       	ldi	r20, 0x01	; 1
    5358:	0f ef       	ldi	r16, 0xFF	; 255
    535a:	1f ef       	ldi	r17, 0xFF	; 255
    535c:	98 01       	movw	r18, r16
    535e:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5362:	c9 82       	std	Y+1, r12	; 0x01
    5364:	da 82       	std	Y+2, r13	; 0x02
    5366:	eb 82       	std	Y+3, r14	; 0x03
    5368:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    536a:	cc 24       	eor	r12, r12
    536c:	03 c0       	rjmp	.+6      	; 0x5374 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    536e:	08 94       	sec
    5370:	21 1c       	adc	r2, r1
    5372:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    5374:	82 e0       	ldi	r24, 0x02	; 2
    5376:	61 e0       	ldi	r22, 0x01	; 1
    5378:	29 81       	ldd	r18, Y+1	; 0x01
    537a:	3a 81       	ldd	r19, Y+2	; 0x02
    537c:	4b 81       	ldd	r20, Y+3	; 0x03
    537e:	5c 81       	ldd	r21, Y+4	; 0x04
    5380:	0e 94 bd 22 	call	0x457a	; 0x457a <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    5384:	81 14       	cp	r8, r1
    5386:	91 04       	cpc	r9, r1
    5388:	a1 04       	cpc	r10, r1
    538a:	b1 04       	cpc	r11, r1
    538c:	09 f0       	breq	.+2      	; 0x5390 <writeFile+0x2f8>
    538e:	79 cf       	rjmp	.-270    	; 0x5282 <writeFile+0x1ea>
    5390:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    5392:	11 23       	and	r17, r17
    5394:	09 f4       	brne	.+2      	; 0x5398 <writeFile+0x300>
    5396:	3f c0       	rjmp	.+126    	; 0x5416 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    5398:	60 91 c9 50 	lds	r22, 0x50C9
    539c:	70 91 ca 50 	lds	r23, 0x50CA
    53a0:	80 91 cb 50 	lds	r24, 0x50CB
    53a4:	90 91 cc 50 	lds	r25, 0x50CC
    53a8:	06 ed       	ldi	r16, 0xD6	; 214
    53aa:	11 e2       	ldi	r17, 0x21	; 33
    53ac:	a8 01       	movw	r20, r16
    53ae:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    53b2:	e0 91 d7 23 	lds	r30, 0x23D7
    53b6:	f0 91 d8 23 	lds	r31, 0x23D8
    53ba:	e0 0f       	add	r30, r16
    53bc:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    53be:	12 8a       	std	Z+18, r1	; 0x12
    53c0:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    53c2:	80 91 50 40 	lds	r24, 0x4050
    53c6:	90 91 51 40 	lds	r25, 0x4051
    53ca:	a0 91 52 40 	lds	r26, 0x4052
    53ce:	b0 91 53 40 	lds	r27, 0x4053
    53d2:	44 8d       	ldd	r20, Z+28	; 0x1c
    53d4:	55 8d       	ldd	r21, Z+29	; 0x1d
    53d6:	66 8d       	ldd	r22, Z+30	; 0x1e
    53d8:	77 8d       	ldd	r23, Z+31	; 0x1f
    53da:	6c 01       	movw	r12, r24
    53dc:	7d 01       	movw	r14, r26
    53de:	c4 1a       	sub	r12, r20
    53e0:	d5 0a       	sbc	r13, r21
    53e2:	e6 0a       	sbc	r14, r22
    53e4:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    53e6:	84 8f       	std	Z+28, r24	; 0x1c
    53e8:	95 8f       	std	Z+29, r25	; 0x1d
    53ea:	a6 8f       	std	Z+30, r26	; 0x1e
    53ec:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    53ee:	60 91 c9 50 	lds	r22, 0x50C9
    53f2:	70 91 ca 50 	lds	r23, 0x50CA
    53f6:	80 91 cb 50 	lds	r24, 0x50CB
    53fa:	90 91 cc 50 	lds	r25, 0x50CC
    53fe:	a8 01       	movw	r20, r16
    5400:	20 e0       	ldi	r18, 0x00	; 0
    5402:	32 e0       	ldi	r19, 0x02	; 2
    5404:	0e 94 5f 2c 	call	0x58be	; 0x58be <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    5408:	81 e0       	ldi	r24, 0x01	; 1
    540a:	b7 01       	movw	r22, r14
    540c:	a6 01       	movw	r20, r12
    540e:	0e 94 bc 25 	call	0x4b78	; 0x4b78 <freeMemoryUpdate>

 //File appended!
  return 0;
    5412:	80 e0       	ldi	r24, 0x00	; 0
    5414:	f9 c0       	rjmp	.+498    	; 0x5608 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    5416:	00 91 5f 40 	lds	r16, 0x405F
    541a:	10 91 60 40 	lds	r17, 0x4060
    541e:	20 91 61 40 	lds	r18, 0x4061
    5422:	30 91 62 40 	lds	r19, 0x4062
    5426:	0b 87       	std	Y+11, r16	; 0x0b
    5428:	1c 87       	std	Y+12, r17	; 0x0c
    542a:	2d 87       	std	Y+13, r18	; 0x0d
    542c:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    542e:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5430:	83 eb       	ldi	r24, 0xB3	; 179
    5432:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    5434:	0f 2e       	mov	r0, r31
    5436:	fb e0       	ldi	r31, 0x0B	; 11
    5438:	af 2e       	mov	r10, r31
    543a:	bb 24       	eor	r11, r11
    543c:	f0 2d       	mov	r31, r0
    543e:	a8 0e       	add	r10, r24
    5440:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    5442:	88 24       	eor	r8, r8
    5444:	68 94       	set
    5446:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5448:	0f 2e       	mov	r0, r31
    544a:	f6 ed       	ldi	r31, 0xD6	; 214
    544c:	4f 2e       	mov	r4, r31
    544e:	f1 e2       	ldi	r31, 0x21	; 33
    5450:	5f 2e       	mov	r5, r31
    5452:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5454:	28 2e       	mov	r2, r24
    5456:	99 2e       	mov	r9, r25
    5458:	37 2c       	mov	r3, r7
    545a:	6f 84       	ldd	r6, Y+15	; 0x0f
    545c:	78 88       	ldd	r7, Y+16	; 0x10
    545e:	04 c0       	rjmp	.+8      	; 0x5468 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    5460:	cb 86       	std	Y+11, r12	; 0x0b
    5462:	dc 86       	std	Y+12, r13	; 0x0c
    5464:	ed 86       	std	Y+13, r14	; 0x0d
    5466:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    5468:	6b 85       	ldd	r22, Y+11	; 0x0b
    546a:	7c 85       	ldd	r23, Y+12	; 0x0c
    546c:	8d 85       	ldd	r24, Y+13	; 0x0d
    546e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5470:	0e 94 04 22 	call	0x4408	; 0x4408 <getFirstSector>
    5474:	6d 83       	std	Y+5, r22	; 0x05
    5476:	7e 83       	std	Y+6, r23	; 0x06
    5478:	8f 83       	std	Y+7, r24	; 0x07
    547a:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    547c:	80 91 7b 50 	lds	r24, 0x507B
    5480:	90 91 7c 50 	lds	r25, 0x507C
    5484:	00 97       	sbiw	r24, 0x00	; 0
    5486:	09 f4       	brne	.+2      	; 0x548a <writeFile+0x3f2>
    5488:	77 c0       	rjmp	.+238    	; 0x5578 <writeFile+0x4e0>
    548a:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    548c:	cd 80       	ldd	r12, Y+5	; 0x05
    548e:	de 80       	ldd	r13, Y+6	; 0x06
    5490:	ef 80       	ldd	r14, Y+7	; 0x07
    5492:	f8 84       	ldd	r15, Y+8	; 0x08
    5494:	19 81       	ldd	r17, Y+1	; 0x01
    5496:	c1 0e       	add	r12, r17
    5498:	d1 1c       	adc	r13, r1
    549a:	e1 1c       	adc	r14, r1
    549c:	f1 1c       	adc	r15, r1
    549e:	c7 01       	movw	r24, r14
    54a0:	b6 01       	movw	r22, r12
    54a2:	a2 01       	movw	r20, r4
    54a4:	0e 94 14 2d 	call	0x5a28	; 0x5a28 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    54a8:	80 91 54 40 	lds	r24, 0x4054
    54ac:	90 91 55 40 	lds	r25, 0x4055
    54b0:	00 97       	sbiw	r24, 0x00	; 0
    54b2:	09 f4       	brne	.+2      	; 0x54b6 <writeFile+0x41e>
    54b4:	54 c0       	rjmp	.+168    	; 0x555e <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    54b6:	33 20       	and	r3, r3
    54b8:	09 f0       	breq	.+2      	; 0x54bc <writeFile+0x424>
    54ba:	a1 c0       	rjmp	.+322    	; 0x55fe <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    54bc:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    54be:	00 e0       	ldi	r16, 0x00	; 0
    54c0:	10 e0       	ldi	r17, 0x00	; 0
    54c2:	06 c0       	rjmp	.+12     	; 0x54d0 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    54c4:	a8 01       	movw	r20, r16
    54c6:	4a 52       	subi	r20, 0x2A	; 42
    54c8:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    54ca:	22 23       	and	r18, r18
    54cc:	09 f0       	breq	.+2      	; 0x54d0 <writeFile+0x438>
    54ce:	99 c0       	rjmp	.+306    	; 0x5602 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    54d0:	da 01       	movw	r26, r20
    54d2:	8c 91       	ld	r24, X
    54d4:	88 23       	and	r24, r24
    54d6:	21 f4       	brne	.+8      	; 0x54e0 <writeFile+0x448>
    54d8:	e2 2d       	mov	r30, r2
    54da:	f9 2d       	mov	r31, r9
    54dc:	da 01       	movw	r26, r20
    54de:	04 c0       	rjmp	.+8      	; 0x54e8 <writeFile+0x450>
    54e0:	85 3e       	cpi	r24, 0xE5	; 229
    54e2:	d1 f3       	breq	.-12     	; 0x54d8 <writeFile+0x440>
    54e4:	23 2d       	mov	r18, r3
    54e6:	30 c0       	rjmp	.+96     	; 0x5548 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    54e8:	81 91       	ld	r24, Z+
    54ea:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    54ec:	ea 15       	cp	r30, r10
    54ee:	fb 05       	cpc	r31, r11
    54f0:	d9 f7       	brne	.-10     	; 0x54e8 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    54f2:	fa 01       	movw	r30, r20
    54f4:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    54f6:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    54f8:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    54fa:	12 8a       	std	Z+18, r1	; 0x12
    54fc:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    54fe:	29 85       	ldd	r18, Y+9	; 0x09
    5500:	3a 85       	ldd	r19, Y+10	; 0x0a
    5502:	24 8b       	std	Z+20, r18	; 0x14
    5504:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    5506:	62 8e       	std	Z+26, r6	; 0x1a
    5508:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    550a:	80 91 50 40 	lds	r24, 0x4050
    550e:	90 91 51 40 	lds	r25, 0x4051
    5512:	a0 91 52 40 	lds	r26, 0x4052
    5516:	b0 91 53 40 	lds	r27, 0x4053
    551a:	84 8f       	std	Z+28, r24	; 0x1c
    551c:	95 8f       	std	Z+29, r25	; 0x1d
    551e:	a6 8f       	std	Z+30, r26	; 0x1e
    5520:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    5522:	c7 01       	movw	r24, r14
    5524:	b6 01       	movw	r22, r12
    5526:	a2 01       	movw	r20, r4
    5528:	20 e0       	ldi	r18, 0x00	; 0
    552a:	32 e0       	ldi	r19, 0x02	; 2
    552c:	0e 94 5f 2c 	call	0x58be	; 0x58be <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    5530:	40 91 50 40 	lds	r20, 0x4050
    5534:	50 91 51 40 	lds	r21, 0x4051
    5538:	60 91 52 40 	lds	r22, 0x4052
    553c:	70 91 53 40 	lds	r23, 0x4053
    5540:	81 e0       	ldi	r24, 0x01	; 1
    5542:	0e 94 bc 25 	call	0x4b78	; 0x4b78 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    5546:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5548:	00 5e       	subi	r16, 0xE0	; 224
    554a:	1f 4f       	sbci	r17, 0xFF	; 255
    554c:	80 91 54 40 	lds	r24, 0x4054
    5550:	90 91 55 40 	lds	r25, 0x4055
    5554:	08 17       	cp	r16, r24
    5556:	19 07       	cpc	r17, r25
    5558:	08 f4       	brcc	.+2      	; 0x555c <writeFile+0x4c4>
    555a:	b4 cf       	rjmp	.-152    	; 0x54c4 <writeFile+0x42c>
    555c:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    555e:	09 81       	ldd	r16, Y+1	; 0x01
    5560:	0f 5f       	subi	r16, 0xFF	; 255
    5562:	09 83       	std	Y+1, r16	; 0x01
    5564:	20 91 7b 50 	lds	r18, 0x507B
    5568:	30 91 7c 50 	lds	r19, 0x507C
    556c:	80 2f       	mov	r24, r16
    556e:	90 e0       	ldi	r25, 0x00	; 0
    5570:	82 17       	cp	r24, r18
    5572:	93 07       	cpc	r25, r19
    5574:	08 f4       	brcc	.+2      	; 0x5578 <writeFile+0x4e0>
    5576:	8a cf       	rjmp	.-236    	; 0x548c <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    5578:	6b 85       	ldd	r22, Y+11	; 0x0b
    557a:	7c 85       	ldd	r23, Y+12	; 0x0c
    557c:	8d 85       	ldd	r24, Y+13	; 0x0d
    557e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5580:	40 e0       	ldi	r20, 0x00	; 0
    5582:	00 e0       	ldi	r16, 0x00	; 0
    5584:	10 e0       	ldi	r17, 0x00	; 0
    5586:	98 01       	movw	r18, r16
    5588:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
    558c:	6b 01       	movw	r12, r22
    558e:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5590:	67 3f       	cpi	r22, 0xF7	; 247
    5592:	1f ef       	ldi	r17, 0xFF	; 255
    5594:	71 07       	cpc	r23, r17
    5596:	1f ef       	ldi	r17, 0xFF	; 255
    5598:	81 07       	cpc	r24, r17
    559a:	1f e0       	ldi	r17, 0x0F	; 15
    559c:	91 07       	cpc	r25, r17
    559e:	08 f1       	brcs	.+66     	; 0x55e2 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    55a0:	6f 3f       	cpi	r22, 0xFF	; 255
    55a2:	2f ef       	ldi	r18, 0xFF	; 255
    55a4:	72 07       	cpc	r23, r18
    55a6:	2f ef       	ldi	r18, 0xFF	; 255
    55a8:	82 07       	cpc	r24, r18
    55aa:	2f ef       	ldi	r18, 0xFF	; 255
    55ac:	92 07       	cpc	r25, r18
    55ae:	59 f5       	brne	.+86     	; 0x5606 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    55b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    55b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    55b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    55b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    55b8:	0e 94 09 25 	call	0x4a12	; 0x4a12 <searchNextFreeCluster>
    55bc:	6b 01       	movw	r12, r22
    55be:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    55c0:	6b 85       	ldd	r22, Y+11	; 0x0b
    55c2:	7c 85       	ldd	r23, Y+12	; 0x0c
    55c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    55c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    55c8:	41 e0       	ldi	r20, 0x01	; 1
    55ca:	97 01       	movw	r18, r14
    55cc:	86 01       	movw	r16, r12
    55ce:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    55d2:	c7 01       	movw	r24, r14
    55d4:	b6 01       	movw	r22, r12
    55d6:	41 e0       	ldi	r20, 0x01	; 1
    55d8:	0f ef       	ldi	r16, 0xFF	; 255
    55da:	1f ef       	ldi	r17, 0xFF	; 255
    55dc:	98 01       	movw	r18, r16
    55de:	0e 94 2b 22 	call	0x4456	; 0x4456 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    55e2:	c1 14       	cp	r12, r1
    55e4:	d1 04       	cpc	r13, r1
    55e6:	e1 04       	cpc	r14, r1
    55e8:	f1 04       	cpc	r15, r1
    55ea:	09 f0       	breq	.+2      	; 0x55ee <writeFile+0x556>
    55ec:	39 cf       	rjmp	.-398    	; 0x5460 <writeFile+0x3c8>
	   return 4;
    55ee:	84 e0       	ldi	r24, 0x04	; 4
    55f0:	0b c0       	rjmp	.+22     	; 0x5608 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    55f2:	81 e0       	ldi	r24, 0x01	; 1
    55f4:	09 c0       	rjmp	.+18     	; 0x5608 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    55f6:	82 e0       	ldi	r24, 0x02	; 2
    55f8:	07 c0       	rjmp	.+14     	; 0x5608 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    55fa:	82 e0       	ldi	r24, 0x02	; 2
    55fc:	05 c0       	rjmp	.+10     	; 0x5608 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    55fe:	80 e0       	ldi	r24, 0x00	; 0
    5600:	03 c0       	rjmp	.+6      	; 0x5608 <writeFile+0x570>
    5602:	80 e0       	ldi	r24, 0x00	; 0
    5604:	01 c0       	rjmp	.+2      	; 0x5608 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    5606:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    5608:	60 96       	adiw	r28, 0x10	; 16
    560a:	cd bf       	out	0x3d, r28	; 61
    560c:	de bf       	out	0x3e, r29	; 62
    560e:	df 91       	pop	r29
    5610:	cf 91       	pop	r28
    5612:	1f 91       	pop	r17
    5614:	0f 91       	pop	r16
    5616:	ff 90       	pop	r15
    5618:	ef 90       	pop	r14
    561a:	df 90       	pop	r13
    561c:	cf 90       	pop	r12
    561e:	bf 90       	pop	r11
    5620:	af 90       	pop	r10
    5622:	9f 90       	pop	r9
    5624:	8f 90       	pop	r8
    5626:	7f 90       	pop	r7
    5628:	6f 90       	pop	r6
    562a:	5f 90       	pop	r5
    562c:	4f 90       	pop	r4
    562e:	3f 90       	pop	r3
    5630:	2f 90       	pop	r2
    5632:	08 95       	ret

00005634 <SPI_write>:
}	

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    5634:	e0 ec       	ldi	r30, 0xC0	; 192
    5636:	f8 e0       	ldi	r31, 0x08	; 8
    5638:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    563a:	82 81       	ldd	r24, Z+2	; 0x02
    563c:	88 23       	and	r24, r24
    563e:	ec f7       	brge	.-6      	; 0x563a <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    5640:	e0 ec       	ldi	r30, 0xC0	; 192
    5642:	f8 e0       	ldi	r31, 0x08	; 8
    5644:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    5646:	08 95       	ret

00005648 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    5648:	8f 92       	push	r8
    564a:	9f 92       	push	r9
    564c:	af 92       	push	r10
    564e:	bf 92       	push	r11
    5650:	cf 92       	push	r12
    5652:	df 92       	push	r13
    5654:	ef 92       	push	r14
    5656:	ff 92       	push	r15
    5658:	0f 93       	push	r16
    565a:	1f 93       	push	r17
    565c:	cf 93       	push	r28
    565e:	df 93       	push	r29
    5660:	84 2e       	mov	r8, r20
    5662:	a5 2e       	mov	r10, r21
    5664:	c6 2e       	mov	r12, r22
    5666:	c7 2f       	mov	r28, r23
    5668:	d2 2f       	mov	r29, r18
    566a:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    566c:	80 64       	ori	r24, 0x40	; 64
    566e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5672:	8c 2f       	mov	r24, r28
    5674:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    5678:	8c 2d       	mov	r24, r12
    567a:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    567e:	8a 2d       	mov	r24, r10
    5680:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5684:	88 2d       	mov	r24, r8
    5686:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
	SPI_write(crc);
    568a:	8d 2f       	mov	r24, r29
    568c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
	
	for(int i=0; i<read; i++){
    5690:	10 16       	cp	r1, r16
    5692:	11 06       	cpc	r1, r17
    5694:	64 f5       	brge	.+88     	; 0x56ee <SD_command+0xa6>
    5696:	00 e0       	ldi	r16, 0x00	; 0
    5698:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    569a:	0f 2e       	mov	r0, r31
    569c:	fd e0       	ldi	r31, 0x0D	; 13
    569e:	cf 2e       	mov	r12, r31
    56a0:	dd 24       	eor	r13, r13
    56a2:	f0 2d       	mov	r31, r0
    56a4:	0f 2e       	mov	r0, r31
    56a6:	f6 ea       	ldi	r31, 0xA6	; 166
    56a8:	af 2e       	mov	r10, r31
    56aa:	f0 e5       	ldi	r31, 0x50	; 80
    56ac:	bf 2e       	mov	r11, r31
    56ae:	f0 2d       	mov	r31, r0
    56b0:	c8 01       	movw	r24, r16
    56b2:	b6 01       	movw	r22, r12
    56b4:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    56b8:	ec 01       	movw	r28, r24
    56ba:	8f ef       	ldi	r24, 0xFF	; 255
    56bc:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    56c0:	f5 01       	movw	r30, r10
    56c2:	ec 0f       	add	r30, r28
    56c4:	fd 1f       	adc	r31, r29
    56c6:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    56c8:	80 81       	ld	r24, Z
    56ca:	8f 3f       	cpi	r24, 0xFF	; 255
    56cc:	49 f0       	breq	.+18     	; 0x56e0 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    56ce:	fe 01       	movw	r30, r28
    56d0:	ea 55       	subi	r30, 0x5A	; 90
    56d2:	ff 4a       	sbci	r31, 0xAF	; 175
    56d4:	80 81       	ld	r24, Z
    56d6:	80 93 a7 50 	sts	0x50A7, r24
			return Buffer[1];
    56da:	80 91 a7 50 	lds	r24, 0x50A7
    56de:	08 c0       	rjmp	.+16     	; 0x56f0 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    56e0:	0f 5f       	subi	r16, 0xFF	; 255
    56e2:	1f 4f       	sbci	r17, 0xFF	; 255
    56e4:	0e 15       	cp	r16, r14
    56e6:	1f 05       	cpc	r17, r15
    56e8:	19 f7       	brne	.-58     	; 0x56b0 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    56ea:	8f ef       	ldi	r24, 0xFF	; 255
    56ec:	01 c0       	rjmp	.+2      	; 0x56f0 <SD_command+0xa8>
    56ee:	8f ef       	ldi	r24, 0xFF	; 255
}
    56f0:	df 91       	pop	r29
    56f2:	cf 91       	pop	r28
    56f4:	1f 91       	pop	r17
    56f6:	0f 91       	pop	r16
    56f8:	ff 90       	pop	r15
    56fa:	ef 90       	pop	r14
    56fc:	df 90       	pop	r13
    56fe:	cf 90       	pop	r12
    5700:	bf 90       	pop	r11
    5702:	af 90       	pop	r10
    5704:	9f 90       	pop	r9
    5706:	8f 90       	pop	r8
    5708:	08 95       	ret

0000570a <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    570a:	ff 92       	push	r15
    570c:	0f 93       	push	r16
    570e:	1f 93       	push	r17
    5710:	cf 93       	push	r28
    5712:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    5714:	81 e0       	ldi	r24, 0x01	; 1
    5716:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    571a:	81 e0       	ldi	r24, 0x01	; 1
    571c:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <Ext1Power>
    5720:	8f ef       	ldi	r24, 0xFF	; 255
    5722:	93 ec       	ldi	r25, 0xC3	; 195
    5724:	a9 e0       	ldi	r26, 0x09	; 9
    5726:	81 50       	subi	r24, 0x01	; 1
    5728:	90 40       	sbci	r25, 0x00	; 0
    572a:	a0 40       	sbci	r26, 0x00	; 0
    572c:	e1 f7       	brne	.-8      	; 0x5726 <SD_init+0x1c>
    572e:	00 c0       	rjmp	.+0      	; 0x5730 <SD_init+0x26>
    5730:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    5732:	88 e0       	ldi	r24, 0x08	; 8
    5734:	60 e0       	ldi	r22, 0x00	; 0
    5736:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    573a:	88 e0       	ldi	r24, 0x08	; 8
    573c:	60 e0       	ldi	r22, 0x00	; 0
    573e:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5742:	80 e0       	ldi	r24, 0x00	; 0
    5744:	63 e0       	ldi	r22, 0x03	; 3
    5746:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <SPIInit2>
	SPICS(TRUE);
    574a:	81 e0       	ldi	r24, 0x01	; 1
    574c:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
    5750:	8a e0       	ldi	r24, 0x0A	; 10
    5752:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    5754:	e0 ec       	ldi	r30, 0xC0	; 192
    5756:	f8 e0       	ldi	r31, 0x08	; 8
    5758:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    575a:	a2 eb       	ldi	r26, 0xB2	; 178
    575c:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    575e:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5760:	22 81       	ldd	r18, Z+2	; 0x02
    5762:	22 23       	and	r18, r18
    5764:	ec f7       	brge	.-6      	; 0x5760 <SD_init+0x56>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    5766:	23 81       	ldd	r18, Z+3	; 0x03
    5768:	2c 93       	st	X, r18
    576a:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    576c:	c1 f7       	brne	.-16     	; 0x575e <SD_init+0x54>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    576e:	80 e0       	ldi	r24, 0x00	; 0
    5770:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    5774:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5778:	88 e0       	ldi	r24, 0x08	; 8
    577a:	60 e0       	ldi	r22, 0x00	; 0
    577c:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5780:	80 e0       	ldi	r24, 0x00	; 0
    5782:	63 e0       	ldi	r22, 0x03	; 3
    5784:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <SPIInit2>
	SPICS(TRUE);
    5788:	81 e0       	ldi	r24, 0x01	; 1
    578a:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    578e:	cb e0       	ldi	r28, 0x0B	; 11
    5790:	d0 e0       	ldi	r29, 0x00	; 0
    5792:	02 c0       	rjmp	.+4      	; 0x5798 <SD_init+0x8e>
    5794:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    5796:	69 f0       	breq	.+26     	; 0x57b2 <SD_init+0xa8>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    5798:	80 e0       	ldi	r24, 0x00	; 0
    579a:	40 e0       	ldi	r20, 0x00	; 0
    579c:	50 e0       	ldi	r21, 0x00	; 0
    579e:	ba 01       	movw	r22, r20
    57a0:	25 e9       	ldi	r18, 0x95	; 149
    57a2:	08 e0       	ldi	r16, 0x08	; 8
    57a4:	10 e0       	ldi	r17, 0x00	; 0
    57a6:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
    57aa:	81 30       	cpi	r24, 0x01	; 1
    57ac:	99 f7       	brne	.-26     	; 0x5794 <SD_init+0x8a>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    57ae:	ff 24       	eor	r15, r15
    57b0:	02 c0       	rjmp	.+4      	; 0x57b6 <SD_init+0xac>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    57b2:	ff 24       	eor	r15, r15
    57b4:	f3 94       	inc	r15
    57b6:	8f ef       	ldi	r24, 0xFF	; 255
    57b8:	93 ec       	ldi	r25, 0xC3	; 195
    57ba:	a9 e0       	ldi	r26, 0x09	; 9
    57bc:	81 50       	subi	r24, 0x01	; 1
    57be:	90 40       	sbci	r25, 0x00	; 0
    57c0:	a0 40       	sbci	r26, 0x00	; 0
    57c2:	e1 f7       	brne	.-8      	; 0x57bc <SD_init+0xb2>
    57c4:	00 c0       	rjmp	.+0      	; 0x57c6 <SD_init+0xbc>
    57c6:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    57c8:	cb e0       	ldi	r28, 0x0B	; 11
    57ca:	d0 e0       	ldi	r29, 0x00	; 0
    57cc:	02 c0       	rjmp	.+4      	; 0x57d2 <SD_init+0xc8>
    57ce:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    57d0:	69 f0       	breq	.+26     	; 0x57ec <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    57d2:	88 e0       	ldi	r24, 0x08	; 8
    57d4:	4a ea       	ldi	r20, 0xAA	; 170
    57d6:	51 e0       	ldi	r21, 0x01	; 1
    57d8:	60 e0       	ldi	r22, 0x00	; 0
    57da:	70 e0       	ldi	r23, 0x00	; 0
    57dc:	27 e8       	ldi	r18, 0x87	; 135
    57de:	08 e0       	ldi	r16, 0x08	; 8
    57e0:	10 e0       	ldi	r17, 0x00	; 0
    57e2:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
    57e6:	81 30       	cpi	r24, 0x01	; 1
    57e8:	91 f7       	brne	.-28     	; 0x57ce <SD_init+0xc4>
    57ea:	02 c0       	rjmp	.+4      	; 0x57f0 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    57ec:	ff 24       	eor	r15, r15
    57ee:	f3 94       	inc	r15
    57f0:	c2 e0       	ldi	r28, 0x02	; 2
    57f2:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    57f4:	06 ea       	ldi	r16, 0xA6	; 166
    57f6:	10 e5       	ldi	r17, 0x50	; 80
    57f8:	8f ef       	ldi	r24, 0xFF	; 255
    57fa:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    57fe:	f8 01       	movw	r30, r16
    5800:	ec 0f       	add	r30, r28
    5802:	fd 1f       	adc	r31, r29
    5804:	80 83       	st	Z, r24
    5806:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    5808:	c6 30       	cpi	r28, 0x06	; 6
    580a:	d1 05       	cpc	r29, r1
    580c:	a9 f7       	brne	.-22     	; 0x57f8 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    580e:	80 91 aa 50 	lds	r24, 0x50AA
    5812:	81 30       	cpi	r24, 0x01	; 1
    5814:	29 f4       	brne	.+10     	; 0x5820 <SD_init+0x116>
    5816:	80 91 ab 50 	lds	r24, 0x50AB
    581a:	8a 3a       	cpi	r24, 0xAA	; 170
    581c:	21 f4       	brne	.+8      	; 0x5826 <SD_init+0x11c>
    581e:	05 c0       	rjmp	.+10     	; 0x582a <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    5820:	ff 24       	eor	r15, r15
    5822:	f3 94       	inc	r15
    5824:	02 c0       	rjmp	.+4      	; 0x582a <SD_init+0x120>
    5826:	ff 24       	eor	r15, r15
    5828:	f3 94       	inc	r15
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    582a:	c7 ea       	ldi	r28, 0xA7	; 167
    582c:	d0 e5       	ldi	r29, 0x50	; 80
		//broken card or voltage out of operating range bounds
		errorCode = 1;
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    582e:	87 e3       	ldi	r24, 0x37	; 55
    5830:	40 e0       	ldi	r20, 0x00	; 0
    5832:	50 e0       	ldi	r21, 0x00	; 0
    5834:	ba 01       	movw	r22, r20
    5836:	2f ef       	ldi	r18, 0xFF	; 255
    5838:	08 e0       	ldi	r16, 0x08	; 8
    583a:	10 e0       	ldi	r17, 0x00	; 0
    583c:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    5840:	81 e0       	ldi	r24, 0x01	; 1
    5842:	40 e0       	ldi	r20, 0x00	; 0
    5844:	50 e0       	ldi	r21, 0x00	; 0
    5846:	60 e0       	ldi	r22, 0x00	; 0
    5848:	70 e4       	ldi	r23, 0x40	; 64
    584a:	2f ef       	ldi	r18, 0xFF	; 255
    584c:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
	} while(Buffer[1]!= 0x00);
    5850:	88 81       	ld	r24, Y
    5852:	88 23       	and	r24, r24
    5854:	61 f7       	brne	.-40     	; 0x582e <SD_init+0x124>
    5856:	cb e0       	ldi	r28, 0x0B	; 11
    5858:	d0 e0       	ldi	r29, 0x00	; 0
    585a:	02 c0       	rjmp	.+4      	; 0x5860 <SD_init+0x156>
    585c:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    585e:	61 f0       	breq	.+24     	; 0x5878 <SD_init+0x16e>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    5860:	8a e3       	ldi	r24, 0x3A	; 58
    5862:	40 e0       	ldi	r20, 0x00	; 0
    5864:	50 e0       	ldi	r21, 0x00	; 0
    5866:	ba 01       	movw	r22, r20
    5868:	2f ef       	ldi	r18, 0xFF	; 255
    586a:	08 e0       	ldi	r16, 0x08	; 8
    586c:	10 e0       	ldi	r17, 0x00	; 0
    586e:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
    5872:	88 23       	and	r24, r24
    5874:	99 f7       	brne	.-26     	; 0x585c <SD_init+0x152>
    5876:	02 c0       	rjmp	.+4      	; 0x587c <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5878:	ff 24       	eor	r15, r15
    587a:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    587c:	c0 e0       	ldi	r28, 0x00	; 0
    587e:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5880:	06 ea       	ldi	r16, 0xA6	; 166
    5882:	10 e5       	ldi	r17, 0x50	; 80
    5884:	8f ef       	ldi	r24, 0xFF	; 255
    5886:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    588a:	f8 01       	movw	r30, r16
    588c:	ec 0f       	add	r30, r28
    588e:	fd 1f       	adc	r31, r29
    5890:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5892:	21 96       	adiw	r28, 0x01	; 1
    5894:	c4 30       	cpi	r28, 0x04	; 4
    5896:	d1 05       	cpc	r29, r1
    5898:	a9 f7       	brne	.-22     	; 0x5884 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    589a:	80 91 a6 50 	lds	r24, 0x50A6
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    589e:	80 e0       	ldi	r24, 0x00	; 0
    58a0:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    58a4:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    58a8:	88 e0       	ldi	r24, 0x08	; 8
    58aa:	60 e0       	ldi	r22, 0x00	; 0
    58ac:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
	return errorCode;	
}	
    58b0:	8f 2d       	mov	r24, r15
    58b2:	df 91       	pop	r29
    58b4:	cf 91       	pop	r28
    58b6:	1f 91       	pop	r17
    58b8:	0f 91       	pop	r16
    58ba:	ff 90       	pop	r15
    58bc:	08 95       	ret

000058be <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    58be:	6f 92       	push	r6
    58c0:	7f 92       	push	r7
    58c2:	8f 92       	push	r8
    58c4:	9f 92       	push	r9
    58c6:	af 92       	push	r10
    58c8:	bf 92       	push	r11
    58ca:	cf 92       	push	r12
    58cc:	df 92       	push	r13
    58ce:	ef 92       	push	r14
    58d0:	ff 92       	push	r15
    58d2:	0f 93       	push	r16
    58d4:	1f 93       	push	r17
    58d6:	cf 93       	push	r28
    58d8:	df 93       	push	r29
    58da:	4b 01       	movw	r8, r22
    58dc:	5c 01       	movw	r10, r24
    58de:	74 2e       	mov	r7, r20
    58e0:	65 2e       	mov	r6, r21
    58e2:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    58e4:	88 e0       	ldi	r24, 0x08	; 8
    58e6:	60 e0       	ldi	r22, 0x00	; 0
    58e8:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    58ec:	80 e0       	ldi	r24, 0x00	; 0
    58ee:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    58f2:	81 e0       	ldi	r24, 0x01	; 1
    58f4:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    58f8:	80 e0       	ldi	r24, 0x00	; 0
    58fa:	92 e0       	ldi	r25, 0x02	; 2
    58fc:	7c 01       	movw	r14, r24
    58fe:	ec 18       	sub	r14, r12
    5900:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5902:	80 e0       	ldi	r24, 0x00	; 0
    5904:	e8 16       	cp	r14, r24
    5906:	82 e0       	ldi	r24, 0x02	; 2
    5908:	f8 06       	cpc	r15, r24
    590a:	11 f4       	brne	.+4      	; 0x5910 <SD_write_block+0x52>
    590c:	ee 24       	eor	r14, r14
    590e:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5910:	cb e0       	ldi	r28, 0x0B	; 11
    5912:	d0 e0       	ldi	r29, 0x00	; 0
    5914:	03 c0       	rjmp	.+6      	; 0x591c <SD_write_block+0x5e>
    5916:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    5918:	09 f4       	brne	.+2      	; 0x591c <SD_write_block+0x5e>
    591a:	ff cf       	rjmp	.-2      	; 0x591a <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    591c:	88 e1       	ldi	r24, 0x18	; 24
    591e:	b5 01       	movw	r22, r10
    5920:	a4 01       	movw	r20, r8
    5922:	2f ef       	ldi	r18, 0xFF	; 255
    5924:	08 e0       	ldi	r16, 0x08	; 8
    5926:	10 e0       	ldi	r17, 0x00	; 0
    5928:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
    592c:	88 23       	and	r24, r24
    592e:	99 f7       	brne	.-26     	; 0x5916 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    5930:	8f ef       	ldi	r24, 0xFF	; 255
    5932:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5936:	80 93 a6 50 	sts	0x50A6, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    593a:	8e ef       	ldi	r24, 0xFE	; 254
    593c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5940:	1c 14       	cp	r1, r12
    5942:	1d 04       	cpc	r1, r13
    5944:	bc f4       	brge	.+46     	; 0x5974 <SD_write_block+0xb6>
    5946:	87 2c       	mov	r8, r7
    5948:	96 2c       	mov	r9, r6
    594a:	00 e0       	ldi	r16, 0x00	; 0
    594c:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    594e:	c8 01       	movw	r24, r16
    5950:	6d e0       	ldi	r22, 0x0D	; 13
    5952:	70 e0       	ldi	r23, 0x00	; 0
    5954:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    5958:	ec 01       	movw	r28, r24
    595a:	f4 01       	movw	r30, r8
    595c:	81 91       	ld	r24, Z+
    595e:	4f 01       	movw	r8, r30
    5960:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5964:	ca 55       	subi	r28, 0x5A	; 90
    5966:	df 4a       	sbci	r29, 0xAF	; 175
    5968:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    596a:	0f 5f       	subi	r16, 0xFF	; 255
    596c:	1f 4f       	sbci	r17, 0xFF	; 255
    596e:	0c 15       	cp	r16, r12
    5970:	1d 05       	cpc	r17, r13
    5972:	69 f7       	brne	.-38     	; 0x594e <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5974:	1e 14       	cp	r1, r14
    5976:	1f 04       	cpc	r1, r15
    5978:	ec f4       	brge	.+58     	; 0x59b4 <SD_write_block+0xf6>
    597a:	00 e0       	ldi	r16, 0x00	; 0
    597c:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    597e:	0f 2e       	mov	r0, r31
    5980:	fd e0       	ldi	r31, 0x0D	; 13
    5982:	cf 2e       	mov	r12, r31
    5984:	dd 24       	eor	r13, r13
    5986:	f0 2d       	mov	r31, r0
    5988:	0f 2e       	mov	r0, r31
    598a:	f6 ea       	ldi	r31, 0xA6	; 166
    598c:	8f 2e       	mov	r8, r31
    598e:	f0 e5       	ldi	r31, 0x50	; 80
    5990:	9f 2e       	mov	r9, r31
    5992:	f0 2d       	mov	r31, r0
    5994:	c8 01       	movw	r24, r16
    5996:	b6 01       	movw	r22, r12
    5998:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    599c:	ec 01       	movw	r28, r24
    599e:	80 e0       	ldi	r24, 0x00	; 0
    59a0:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    59a4:	c8 0d       	add	r28, r8
    59a6:	d9 1d       	adc	r29, r9
    59a8:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    59aa:	0f 5f       	subi	r16, 0xFF	; 255
    59ac:	1f 4f       	sbci	r17, 0xFF	; 255
    59ae:	0e 15       	cp	r16, r14
    59b0:	1f 05       	cpc	r17, r15
    59b2:	81 f7       	brne	.-32     	; 0x5994 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    59b4:	8f ef       	ldi	r24, 0xFF	; 255
    59b6:	80 93 a6 50 	sts	0x50A6, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    59ba:	c0 e0       	ldi	r28, 0x00	; 0
    59bc:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    59be:	06 ea       	ldi	r16, 0xA6	; 166
    59c0:	10 e5       	ldi	r17, 0x50	; 80
    59c2:	8f ef       	ldi	r24, 0xFF	; 255
    59c4:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    59c8:	f8 01       	movw	r30, r16
    59ca:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    59cc:	21 96       	adiw	r28, 0x01	; 1
    59ce:	c2 30       	cpi	r28, 0x02	; 2
    59d0:	d1 05       	cpc	r29, r1
    59d2:	bc f3       	brlt	.-18     	; 0x59c2 <SD_write_block+0x104>
    59d4:	80 81       	ld	r24, Z
    59d6:	8f 3f       	cpi	r24, 0xFF	; 255
    59d8:	a1 f3       	breq	.-24     	; 0x59c2 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    59da:	80 91 a6 50 	lds	r24, 0x50A6
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    59de:	80 91 a6 50 	lds	r24, 0x50A6
    59e2:	8f 3f       	cpi	r24, 0xFF	; 255
    59e4:	49 f0       	breq	.+18     	; 0x59f8 <SD_write_block+0x13a>
    59e6:	c6 ea       	ldi	r28, 0xA6	; 166
    59e8:	d0 e5       	ldi	r29, 0x50	; 80
    59ea:	8f ef       	ldi	r24, 0xFF	; 255
    59ec:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    59f0:	88 83       	st	Y, r24
    59f2:	88 81       	ld	r24, Y
    59f4:	8f 3f       	cpi	r24, 0xFF	; 255
    59f6:	c9 f7       	brne	.-14     	; 0x59ea <SD_write_block+0x12c>
	SPICS(FALSE);
    59f8:	80 e0       	ldi	r24, 0x00	; 0
    59fa:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    59fe:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    5a02:	88 e0       	ldi	r24, 0x08	; 8
    5a04:	60 e0       	ldi	r22, 0x00	; 0
    5a06:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
}
    5a0a:	df 91       	pop	r29
    5a0c:	cf 91       	pop	r28
    5a0e:	1f 91       	pop	r17
    5a10:	0f 91       	pop	r16
    5a12:	ff 90       	pop	r15
    5a14:	ef 90       	pop	r14
    5a16:	df 90       	pop	r13
    5a18:	cf 90       	pop	r12
    5a1a:	bf 90       	pop	r11
    5a1c:	af 90       	pop	r10
    5a1e:	9f 90       	pop	r9
    5a20:	8f 90       	pop	r8
    5a22:	7f 90       	pop	r7
    5a24:	6f 90       	pop	r6
    5a26:	08 95       	ret

00005a28 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    5a28:	af 92       	push	r10
    5a2a:	bf 92       	push	r11
    5a2c:	cf 92       	push	r12
    5a2e:	df 92       	push	r13
    5a30:	ef 92       	push	r14
    5a32:	ff 92       	push	r15
    5a34:	0f 93       	push	r16
    5a36:	1f 93       	push	r17
    5a38:	cf 93       	push	r28
    5a3a:	df 93       	push	r29
    5a3c:	6b 01       	movw	r12, r22
    5a3e:	7c 01       	movw	r14, r24
    5a40:	b4 2e       	mov	r11, r20
    5a42:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5a44:	88 e0       	ldi	r24, 0x08	; 8
    5a46:	60 e0       	ldi	r22, 0x00	; 0
    5a48:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5a4c:	80 e0       	ldi	r24, 0x00	; 0
    5a4e:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    5a52:	81 e0       	ldi	r24, 0x01	; 1
    5a54:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5a58:	cb e0       	ldi	r28, 0x0B	; 11
    5a5a:	d0 e0       	ldi	r29, 0x00	; 0
    5a5c:	03 c0       	rjmp	.+6      	; 0x5a64 <SD_read_block+0x3c>
    5a5e:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5a60:	09 f4       	brne	.+2      	; 0x5a64 <SD_read_block+0x3c>
    5a62:	ff cf       	rjmp	.-2      	; 0x5a62 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5a64:	81 e1       	ldi	r24, 0x11	; 17
    5a66:	b7 01       	movw	r22, r14
    5a68:	a6 01       	movw	r20, r12
    5a6a:	2f ef       	ldi	r18, 0xFF	; 255
    5a6c:	08 e0       	ldi	r16, 0x08	; 8
    5a6e:	10 e0       	ldi	r17, 0x00	; 0
    5a70:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
    5a74:	88 23       	and	r24, r24
    5a76:	99 f7       	brne	.-26     	; 0x5a5e <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5a78:	80 91 a6 50 	lds	r24, 0x50A6
    5a7c:	8e 3f       	cpi	r24, 0xFE	; 254
    5a7e:	49 f0       	breq	.+18     	; 0x5a92 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5a80:	c6 ea       	ldi	r28, 0xA6	; 166
    5a82:	d0 e5       	ldi	r29, 0x50	; 80
    5a84:	8f ef       	ldi	r24, 0xFF	; 255
    5a86:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5a8a:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5a8c:	88 81       	ld	r24, Y
    5a8e:	8e 3f       	cpi	r24, 0xFE	; 254
    5a90:	c9 f7       	brne	.-14     	; 0x5a84 <SD_read_block+0x5c>
    5a92:	0b 2d       	mov	r16, r11
    5a94:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5a96:	c0 e0       	ldi	r28, 0x00	; 0
    5a98:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5a9a:	8f ef       	ldi	r24, 0xFF	; 255
    5a9c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5aa0:	f8 01       	movw	r30, r16
    5aa2:	81 93       	st	Z+, r24
    5aa4:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5aa6:	21 96       	adiw	r28, 0x01	; 1
    5aa8:	f2 e0       	ldi	r31, 0x02	; 2
    5aaa:	c0 30       	cpi	r28, 0x00	; 0
    5aac:	df 07       	cpc	r29, r31
    5aae:	a9 f7       	brne	.-22     	; 0x5a9a <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    5ab0:	10 92 b2 50 	sts	0x50B2, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5ab4:	80 91 b2 50 	lds	r24, 0x50B2
    5ab8:	8f 3f       	cpi	r24, 0xFF	; 255
    5aba:	49 f0       	breq	.+18     	; 0x5ace <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5abc:	c2 eb       	ldi	r28, 0xB2	; 178
    5abe:	d0 e5       	ldi	r29, 0x50	; 80
    5ac0:	8f ef       	ldi	r24, 0xFF	; 255
    5ac2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5ac6:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5ac8:	88 81       	ld	r24, Y
    5aca:	8f 3f       	cpi	r24, 0xFF	; 255
    5acc:	c9 f7       	brne	.-14     	; 0x5ac0 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    5ace:	80 e0       	ldi	r24, 0x00	; 0
    5ad0:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    5ad4:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5ad8:	88 e0       	ldi	r24, 0x08	; 8
    5ada:	60 e0       	ldi	r22, 0x00	; 0
    5adc:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
}
    5ae0:	df 91       	pop	r29
    5ae2:	cf 91       	pop	r28
    5ae4:	1f 91       	pop	r17
    5ae6:	0f 91       	pop	r16
    5ae8:	ff 90       	pop	r15
    5aea:	ef 90       	pop	r14
    5aec:	df 90       	pop	r13
    5aee:	cf 90       	pop	r12
    5af0:	bf 90       	pop	r11
    5af2:	af 90       	pop	r10
    5af4:	08 95       	ret

00005af6 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5af6:	2f 92       	push	r2
    5af8:	3f 92       	push	r3
    5afa:	4f 92       	push	r4
    5afc:	5f 92       	push	r5
    5afe:	6f 92       	push	r6
    5b00:	7f 92       	push	r7
    5b02:	8f 92       	push	r8
    5b04:	9f 92       	push	r9
    5b06:	af 92       	push	r10
    5b08:	bf 92       	push	r11
    5b0a:	cf 92       	push	r12
    5b0c:	df 92       	push	r13
    5b0e:	ef 92       	push	r14
    5b10:	ff 92       	push	r15
    5b12:	0f 93       	push	r16
    5b14:	1f 93       	push	r17
    5b16:	cf 93       	push	r28
    5b18:	df 93       	push	r29
    5b1a:	cd b7       	in	r28, 0x3d	; 61
    5b1c:	de b7       	in	r29, 0x3e	; 62
    5b1e:	2a 97       	sbiw	r28, 0x0a	; 10
    5b20:	cd bf       	out	0x3d, r28	; 61
    5b22:	de bf       	out	0x3e, r29	; 62
    5b24:	6b 01       	movw	r12, r22
    5b26:	7c 01       	movw	r14, r24
    5b28:	4f 83       	std	Y+7, r20	; 0x07
    5b2a:	58 87       	std	Y+8, r21	; 0x08
    5b2c:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5b2e:	88 e0       	ldi	r24, 0x08	; 8
    5b30:	60 e0       	ldi	r22, 0x00	; 0
    5b32:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5b36:	80 e0       	ldi	r24, 0x00	; 0
    5b38:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    5b3c:	81 e0       	ldi	r24, 0x01	; 1
    5b3e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5b42:	c8 01       	movw	r24, r16
    5b44:	11 23       	and	r17, r17
    5b46:	14 f4       	brge	.+4      	; 0x5b4c <SD_write_multiple_blocks+0x56>
    5b48:	81 50       	subi	r24, 0x01	; 1
    5b4a:	9e 4f       	sbci	r25, 0xFE	; 254
    5b4c:	9c 01       	movw	r18, r24
    5b4e:	23 2f       	mov	r18, r19
    5b50:	33 0f       	add	r19, r19
    5b52:	33 0b       	sbc	r19, r19
    5b54:	25 95       	asr	r18
    5b56:	2b 83       	std	Y+3, r18	; 0x03
    5b58:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5b5a:	20 e0       	ldi	r18, 0x00	; 0
    5b5c:	32 e0       	ldi	r19, 0x02	; 2
    5b5e:	c8 01       	movw	r24, r16
    5b60:	b9 01       	movw	r22, r18
    5b62:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    5b66:	29 01       	movw	r4, r18
    5b68:	48 1a       	sub	r4, r24
    5b6a:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5b6c:	30 e0       	ldi	r19, 0x00	; 0
    5b6e:	43 16       	cp	r4, r19
    5b70:	32 e0       	ldi	r19, 0x02	; 2
    5b72:	53 06       	cpc	r5, r19
    5b74:	31 f0       	breq	.+12     	; 0x5b82 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5b76:	8b 81       	ldd	r24, Y+3	; 0x03
    5b78:	9c 81       	ldd	r25, Y+4	; 0x04
    5b7a:	01 96       	adiw	r24, 0x01	; 1
    5b7c:	8b 83       	std	Y+3, r24	; 0x03
    5b7e:	9c 83       	std	Y+4, r25	; 0x04
    5b80:	02 c0       	rjmp	.+4      	; 0x5b86 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5b82:	44 24       	eor	r4, r4
    5b84:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5b86:	89 e1       	ldi	r24, 0x19	; 25
    5b88:	b7 01       	movw	r22, r14
    5b8a:	a6 01       	movw	r20, r12
    5b8c:	2f ef       	ldi	r18, 0xFF	; 255
    5b8e:	08 e0       	ldi	r16, 0x08	; 8
    5b90:	10 e0       	ldi	r17, 0x00	; 0
    5b92:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
    5b96:	88 23       	and	r24, r24
    5b98:	b1 f7       	brne	.-20     	; 0x5b86 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    5b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    5b9e:	1e 16       	cp	r1, r30
    5ba0:	1f 06       	cpc	r1, r31
    5ba2:	0c f0       	brlt	.+2      	; 0x5ba6 <SD_write_multiple_blocks+0xb0>
    5ba4:	ac c0       	rjmp	.+344    	; 0x5cfe <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5ba6:	31 97       	sbiw	r30, 0x01	; 1
    5ba8:	ed 83       	std	Y+5, r30	; 0x05
    5baa:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5bac:	9f 01       	movw	r18, r30
    5bae:	32 2f       	mov	r19, r18
    5bb0:	22 27       	eor	r18, r18
    5bb2:	33 0f       	add	r19, r19
    5bb4:	8f 81       	ldd	r24, Y+7	; 0x07
    5bb6:	98 85       	ldd	r25, Y+8	; 0x08
    5bb8:	89 83       	std	Y+1, r24	; 0x01
    5bba:	9a 83       	std	Y+2, r25	; 0x02
    5bbc:	66 24       	eor	r6, r6
    5bbe:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5bc0:	0f 2e       	mov	r0, r31
    5bc2:	f7 ea       	ldi	r31, 0xA7	; 167
    5bc4:	8f 2e       	mov	r8, r31
    5bc6:	f0 e5       	ldi	r31, 0x50	; 80
    5bc8:	9f 2e       	mov	r9, r31
    5bca:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5bcc:	0f 2e       	mov	r0, r31
    5bce:	fc e0       	ldi	r31, 0x0C	; 12
    5bd0:	cf 2e       	mov	r12, r31
    5bd2:	dd 24       	eor	r13, r13
    5bd4:	f0 2d       	mov	r31, r0
    5bd6:	0f 2e       	mov	r0, r31
    5bd8:	f6 ea       	ldi	r31, 0xA6	; 166
    5bda:	af 2e       	mov	r10, r31
    5bdc:	f0 e5       	ldi	r31, 0x50	; 80
    5bde:	bf 2e       	mov	r11, r31
    5be0:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5be2:	80 e0       	ldi	r24, 0x00	; 0
    5be4:	92 e0       	ldi	r25, 0x02	; 2
    5be6:	1c 01       	movw	r2, r24
    5be8:	24 18       	sub	r2, r4
    5bea:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5bec:	ef 81       	ldd	r30, Y+7	; 0x07
    5bee:	f8 85       	ldd	r31, Y+8	; 0x08
    5bf0:	e2 0f       	add	r30, r18
    5bf2:	f3 1f       	adc	r31, r19
    5bf4:	ef 83       	std	Y+7, r30	; 0x07
    5bf6:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5bf8:	8f ef       	ldi	r24, 0xFF	; 255
    5bfa:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5bfe:	f4 01       	movw	r30, r8
    5c00:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    5c02:	8c ef       	ldi	r24, 0xFC	; 252
    5c04:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5c08:	f4 01       	movw	r30, r8
    5c0a:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    5c0c:	2d 81       	ldd	r18, Y+5	; 0x05
    5c0e:	3e 81       	ldd	r19, Y+6	; 0x06
    5c10:	26 15       	cp	r18, r6
    5c12:	37 05       	cpc	r19, r7
    5c14:	09 f0       	breq	.+2      	; 0x5c18 <SD_write_multiple_blocks+0x122>
    5c16:	41 c0       	rjmp	.+130    	; 0x5c9a <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5c18:	12 14       	cp	r1, r2
    5c1a:	13 04       	cpc	r1, r3
    5c1c:	cc f4       	brge	.+50     	; 0x5c50 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5c1e:	ef 80       	ldd	r14, Y+7	; 0x07
    5c20:	f8 84       	ldd	r15, Y+8	; 0x08
    5c22:	00 e0       	ldi	r16, 0x00	; 0
    5c24:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5c26:	c8 01       	movw	r24, r16
    5c28:	b6 01       	movw	r22, r12
    5c2a:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    5c2e:	89 87       	std	Y+9, r24	; 0x09
    5c30:	9a 87       	std	Y+10, r25	; 0x0a
    5c32:	f7 01       	movw	r30, r14
    5c34:	81 91       	ld	r24, Z+
    5c36:	7f 01       	movw	r14, r30
    5c38:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5c3c:	e9 85       	ldd	r30, Y+9	; 0x09
    5c3e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5c40:	ea 0d       	add	r30, r10
    5c42:	fb 1d       	adc	r31, r11
    5c44:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5c46:	0f 5f       	subi	r16, 0xFF	; 255
    5c48:	1f 4f       	sbci	r17, 0xFF	; 255
    5c4a:	02 15       	cp	r16, r2
    5c4c:	13 05       	cpc	r17, r3
    5c4e:	59 f7       	brne	.-42     	; 0x5c26 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5c50:	14 14       	cp	r1, r4
    5c52:	15 04       	cpc	r1, r5
    5c54:	9c f4       	brge	.+38     	; 0x5c7c <SD_write_multiple_blocks+0x186>
    5c56:	00 e0       	ldi	r16, 0x00	; 0
    5c58:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5c5a:	c8 01       	movw	r24, r16
    5c5c:	b6 01       	movw	r22, r12
    5c5e:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    5c62:	7c 01       	movw	r14, r24
    5c64:	80 e0       	ldi	r24, 0x00	; 0
    5c66:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5c6a:	f5 01       	movw	r30, r10
    5c6c:	ee 0d       	add	r30, r14
    5c6e:	ff 1d       	adc	r31, r15
    5c70:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5c72:	0f 5f       	subi	r16, 0xFF	; 255
    5c74:	1f 4f       	sbci	r17, 0xFF	; 255
    5c76:	04 15       	cp	r16, r4
    5c78:	15 05       	cpc	r17, r5
    5c7a:	79 f7       	brne	.-34     	; 0x5c5a <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5c7c:	8f ef       	ldi	r24, 0xFF	; 255
    5c7e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5c82:	f4 01       	movw	r30, r8
    5c84:	80 83       	st	Z, r24
    5c86:	8f ef       	ldi	r24, 0xFF	; 255
    5c88:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5c8c:	f4 01       	movw	r30, r8
    5c8e:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5c90:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5c92:	80 81       	ld	r24, Z
    5c94:	8f 3f       	cpi	r24, 0xFF	; 255
    5c96:	e1 f4       	brne	.+56     	; 0x5cd0 <SD_write_multiple_blocks+0x1da>
    5c98:	23 c0       	rjmp	.+70     	; 0x5ce0 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5c9a:	e9 80       	ldd	r14, Y+1	; 0x01
    5c9c:	fa 80       	ldd	r15, Y+2	; 0x02
    5c9e:	00 e0       	ldi	r16, 0x00	; 0
    5ca0:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5ca2:	c8 01       	movw	r24, r16
    5ca4:	b6 01       	movw	r22, r12
    5ca6:	0e 94 ed 3a 	call	0x75da	; 0x75da <__divmodhi4>
    5caa:	89 87       	std	Y+9, r24	; 0x09
    5cac:	9a 87       	std	Y+10, r25	; 0x0a
    5cae:	f7 01       	movw	r30, r14
    5cb0:	81 91       	ld	r24, Z+
    5cb2:	7f 01       	movw	r14, r30
    5cb4:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5cb8:	e9 85       	ldd	r30, Y+9	; 0x09
    5cba:	fa 85       	ldd	r31, Y+10	; 0x0a
    5cbc:	ea 0d       	add	r30, r10
    5cbe:	fb 1d       	adc	r31, r11
    5cc0:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5cc2:	0f 5f       	subi	r16, 0xFF	; 255
    5cc4:	1f 4f       	sbci	r17, 0xFF	; 255
    5cc6:	f2 e0       	ldi	r31, 0x02	; 2
    5cc8:	00 30       	cpi	r16, 0x00	; 0
    5cca:	1f 07       	cpc	r17, r31
    5ccc:	51 f7       	brne	.-44     	; 0x5ca2 <SD_write_multiple_blocks+0x1ac>
    5cce:	d6 cf       	rjmp	.-84     	; 0x5c7c <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5cd0:	8f ef       	ldi	r24, 0xFF	; 255
    5cd2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5cd6:	f4 01       	movw	r30, r8
    5cd8:	80 83       	st	Z, r24
    5cda:	80 81       	ld	r24, Z
    5cdc:	8f 3f       	cpi	r24, 0xFF	; 255
    5cde:	c1 f7       	brne	.-16     	; 0x5cd0 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    5ce0:	08 94       	sec
    5ce2:	61 1c       	adc	r6, r1
    5ce4:	71 1c       	adc	r7, r1
    5ce6:	29 81       	ldd	r18, Y+1	; 0x01
    5ce8:	3a 81       	ldd	r19, Y+2	; 0x02
    5cea:	20 50       	subi	r18, 0x00	; 0
    5cec:	3e 4f       	sbci	r19, 0xFE	; 254
    5cee:	29 83       	std	Y+1, r18	; 0x01
    5cf0:	3a 83       	std	Y+2, r19	; 0x02
    5cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    5cf4:	9c 81       	ldd	r25, Y+4	; 0x04
    5cf6:	68 16       	cp	r6, r24
    5cf8:	79 06       	cpc	r7, r25
    5cfa:	09 f0       	breq	.+2      	; 0x5cfe <SD_write_multiple_blocks+0x208>
    5cfc:	7d cf       	rjmp	.-262    	; 0x5bf8 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5cfe:	ee 24       	eor	r14, r14
    5d00:	ff 24       	eor	r15, r15
    5d02:	68 94       	set
    5d04:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5d06:	07 ea       	ldi	r16, 0xA7	; 167
    5d08:	10 e5       	ldi	r17, 0x50	; 80
    5d0a:	8f ef       	ldi	r24, 0xFF	; 255
    5d0c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5d10:	f8 01       	movw	r30, r16
    5d12:	80 83       	st	Z, r24
    5d14:	08 94       	sec
    5d16:	e1 08       	sbc	r14, r1
    5d18:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5d1a:	e1 14       	cp	r14, r1
    5d1c:	f1 04       	cpc	r15, r1
    5d1e:	a9 f7       	brne	.-22     	; 0x5d0a <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5d20:	8d ef       	ldi	r24, 0xFD	; 253
    5d22:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5d26:	80 93 a7 50 	sts	0x50A7, r24
    5d2a:	ee 24       	eor	r14, r14
    5d2c:	ff 24       	eor	r15, r15
    5d2e:	68 94       	set
    5d30:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5d32:	07 ea       	ldi	r16, 0xA7	; 167
    5d34:	10 e5       	ldi	r17, 0x50	; 80
    5d36:	8f ef       	ldi	r24, 0xFF	; 255
    5d38:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5d3c:	f8 01       	movw	r30, r16
    5d3e:	80 83       	st	Z, r24
    5d40:	08 94       	sec
    5d42:	e1 08       	sbc	r14, r1
    5d44:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5d46:	e1 14       	cp	r14, r1
    5d48:	f1 04       	cpc	r15, r1
    5d4a:	a9 f7       	brne	.-22     	; 0x5d36 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5d4c:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5d50:	80 91 a7 50 	lds	r24, 0x50A7
    5d54:	8f 3f       	cpi	r24, 0xFF	; 255
    5d56:	51 f0       	breq	.+20     	; 0x5d6c <SD_write_multiple_blocks+0x276>
    5d58:	07 ea       	ldi	r16, 0xA7	; 167
    5d5a:	10 e5       	ldi	r17, 0x50	; 80
    5d5c:	8f ef       	ldi	r24, 0xFF	; 255
    5d5e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5d62:	f8 01       	movw	r30, r16
    5d64:	80 83       	st	Z, r24
    5d66:	80 81       	ld	r24, Z
    5d68:	8f 3f       	cpi	r24, 0xFF	; 255
    5d6a:	c1 f7       	brne	.-16     	; 0x5d5c <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5d6c:	80 e0       	ldi	r24, 0x00	; 0
    5d6e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    5d72:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5d76:	88 e0       	ldi	r24, 0x08	; 8
    5d78:	60 e0       	ldi	r22, 0x00	; 0
    5d7a:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
}
    5d7e:	2a 96       	adiw	r28, 0x0a	; 10
    5d80:	cd bf       	out	0x3d, r28	; 61
    5d82:	de bf       	out	0x3e, r29	; 62
    5d84:	df 91       	pop	r29
    5d86:	cf 91       	pop	r28
    5d88:	1f 91       	pop	r17
    5d8a:	0f 91       	pop	r16
    5d8c:	ff 90       	pop	r15
    5d8e:	ef 90       	pop	r14
    5d90:	df 90       	pop	r13
    5d92:	cf 90       	pop	r12
    5d94:	bf 90       	pop	r11
    5d96:	af 90       	pop	r10
    5d98:	9f 90       	pop	r9
    5d9a:	8f 90       	pop	r8
    5d9c:	7f 90       	pop	r7
    5d9e:	6f 90       	pop	r6
    5da0:	5f 90       	pop	r5
    5da2:	4f 90       	pop	r4
    5da4:	3f 90       	pop	r3
    5da6:	2f 90       	pop	r2
    5da8:	08 95       	ret

00005daa <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5daa:	2f 92       	push	r2
    5dac:	3f 92       	push	r3
    5dae:	4f 92       	push	r4
    5db0:	5f 92       	push	r5
    5db2:	6f 92       	push	r6
    5db4:	7f 92       	push	r7
    5db6:	8f 92       	push	r8
    5db8:	9f 92       	push	r9
    5dba:	af 92       	push	r10
    5dbc:	bf 92       	push	r11
    5dbe:	cf 92       	push	r12
    5dc0:	df 92       	push	r13
    5dc2:	ef 92       	push	r14
    5dc4:	ff 92       	push	r15
    5dc6:	0f 93       	push	r16
    5dc8:	1f 93       	push	r17
    5dca:	cf 93       	push	r28
    5dcc:	df 93       	push	r29
    5dce:	6b 01       	movw	r12, r22
    5dd0:	7c 01       	movw	r14, r24
    5dd2:	c4 2f       	mov	r28, r20
    5dd4:	85 2e       	mov	r8, r21
    5dd6:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5dd8:	88 e0       	ldi	r24, 0x08	; 8
    5dda:	60 e0       	ldi	r22, 0x00	; 0
    5ddc:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5de0:	80 e0       	ldi	r24, 0x00	; 0
    5de2:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    5de6:	81 e0       	ldi	r24, 0x01	; 1
    5de8:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5dec:	82 e1       	ldi	r24, 0x12	; 18
    5dee:	b7 01       	movw	r22, r14
    5df0:	a6 01       	movw	r20, r12
    5df2:	2f ef       	ldi	r18, 0xFF	; 255
    5df4:	08 e0       	ldi	r16, 0x08	; 8
    5df6:	10 e0       	ldi	r17, 0x00	; 0
    5df8:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
    5dfc:	88 23       	and	r24, r24
    5dfe:	b1 f7       	brne	.-20     	; 0x5dec <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5e00:	16 14       	cp	r1, r6
    5e02:	17 04       	cpc	r1, r7
    5e04:	0c f0       	brlt	.+2      	; 0x5e08 <SD_read_multiple_blocks+0x5e>
    5e06:	46 c0       	rjmp	.+140    	; 0x5e94 <SD_read_multiple_blocks+0xea>
    5e08:	ac 2e       	mov	r10, r28
    5e0a:	b8 2c       	mov	r11, r8
    5e0c:	88 24       	eor	r8, r8
    5e0e:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5e10:	0f 2e       	mov	r0, r31
    5e12:	f7 ea       	ldi	r31, 0xA7	; 167
    5e14:	cf 2e       	mov	r12, r31
    5e16:	f0 e5       	ldi	r31, 0x50	; 80
    5e18:	df 2e       	mov	r13, r31
    5e1a:	f0 2d       	mov	r31, r0
    5e1c:	ff 24       	eor	r15, r15
    5e1e:	fa 94       	dec	r15
    5e20:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5e22:	0f 2e       	mov	r0, r31
    5e24:	f6 ea       	ldi	r31, 0xA6	; 166
    5e26:	4f 2e       	mov	r4, r31
    5e28:	f0 e5       	ldi	r31, 0x50	; 80
    5e2a:	5f 2e       	mov	r5, r31
    5e2c:	f0 2d       	mov	r31, r0
    5e2e:	12 01       	movw	r2, r4
    5e30:	08 94       	sec
    5e32:	21 1c       	adc	r2, r1
    5e34:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5e36:	f6 01       	movw	r30, r12
    5e38:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5e3a:	80 81       	ld	r24, Z
    5e3c:	8e 3f       	cpi	r24, 0xFE	; 254
    5e3e:	41 f0       	breq	.+16     	; 0x5e50 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5e40:	8f 2d       	mov	r24, r15
    5e42:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5e46:	f6 01       	movw	r30, r12
    5e48:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5e4a:	80 81       	ld	r24, Z
    5e4c:	8e 3f       	cpi	r24, 0xFE	; 254
    5e4e:	c1 f7       	brne	.-16     	; 0x5e40 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5e50:	85 01       	movw	r16, r10
    5e52:	c0 e0       	ldi	r28, 0x00	; 0
    5e54:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5e56:	8f 2d       	mov	r24, r15
    5e58:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5e5c:	f8 01       	movw	r30, r16
    5e5e:	81 93       	st	Z+, r24
    5e60:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5e62:	21 96       	adiw	r28, 0x01	; 1
    5e64:	f2 e0       	ldi	r31, 0x02	; 2
    5e66:	c0 30       	cpi	r28, 0x00	; 0
    5e68:	df 07       	cpc	r29, r31
    5e6a:	a9 f7       	brne	.-22     	; 0x5e56 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5e6c:	8f 2d       	mov	r24, r15
    5e6e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5e72:	f2 01       	movw	r30, r4
    5e74:	80 83       	st	Z, r24
    5e76:	8f 2d       	mov	r24, r15
    5e78:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5e7c:	f1 01       	movw	r30, r2
    5e7e:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5e80:	08 94       	sec
    5e82:	81 1c       	adc	r8, r1
    5e84:	91 1c       	adc	r9, r1
    5e86:	80 e0       	ldi	r24, 0x00	; 0
    5e88:	92 e0       	ldi	r25, 0x02	; 2
    5e8a:	a8 0e       	add	r10, r24
    5e8c:	b9 1e       	adc	r11, r25
    5e8e:	86 14       	cp	r8, r6
    5e90:	97 04       	cpc	r9, r7
    5e92:	89 f6       	brne	.-94     	; 0x5e36 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5e94:	8c e0       	ldi	r24, 0x0C	; 12
    5e96:	40 e0       	ldi	r20, 0x00	; 0
    5e98:	50 e0       	ldi	r21, 0x00	; 0
    5e9a:	ba 01       	movw	r22, r20
    5e9c:	2f ef       	ldi	r18, 0xFF	; 255
    5e9e:	08 e0       	ldi	r16, 0x08	; 8
    5ea0:	10 e0       	ldi	r17, 0x00	; 0
    5ea2:	0e 94 24 2b 	call	0x5648	; 0x5648 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5ea6:	8f ef       	ldi	r24, 0xFF	; 255
    5ea8:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5eac:	80 93 a6 50 	sts	0x50A6, r24
	Buffer[1] = FILLER_BYTE;
    5eb0:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5eb4:	80 91 a7 50 	lds	r24, 0x50A7
    5eb8:	8f 3f       	cpi	r24, 0xFF	; 255
    5eba:	49 f0       	breq	.+18     	; 0x5ece <SD_read_multiple_blocks+0x124>
    5ebc:	c7 ea       	ldi	r28, 0xA7	; 167
    5ebe:	d0 e5       	ldi	r29, 0x50	; 80
    5ec0:	8f ef       	ldi	r24, 0xFF	; 255
    5ec2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
    5ec6:	88 83       	st	Y, r24
    5ec8:	88 81       	ld	r24, Y
    5eca:	8f 3f       	cpi	r24, 0xFF	; 255
    5ecc:	c9 f7       	brne	.-14     	; 0x5ec0 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5ece:	80 e0       	ldi	r24, 0x00	; 0
    5ed0:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    5ed4:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5ed8:	88 e0       	ldi	r24, 0x08	; 8
    5eda:	60 e0       	ldi	r22, 0x00	; 0
    5edc:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
}
    5ee0:	df 91       	pop	r29
    5ee2:	cf 91       	pop	r28
    5ee4:	1f 91       	pop	r17
    5ee6:	0f 91       	pop	r16
    5ee8:	ff 90       	pop	r15
    5eea:	ef 90       	pop	r14
    5eec:	df 90       	pop	r13
    5eee:	cf 90       	pop	r12
    5ef0:	bf 90       	pop	r11
    5ef2:	af 90       	pop	r10
    5ef4:	9f 90       	pop	r9
    5ef6:	8f 90       	pop	r8
    5ef8:	7f 90       	pop	r7
    5efa:	6f 90       	pop	r6
    5efc:	5f 90       	pop	r5
    5efe:	4f 90       	pop	r4
    5f00:	3f 90       	pop	r3
    5f02:	2f 90       	pop	r2
    5f04:	08 95       	ret

00005f06 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5f06:	88 e0       	ldi	r24, 0x08	; 8
    5f08:	60 e0       	ldi	r22, 0x00	; 0
    5f0a:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5f0e:	88 e0       	ldi	r24, 0x08	; 8
    5f10:	60 e0       	ldi	r22, 0x00	; 0
    5f12:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5f16:	80 e0       	ldi	r24, 0x00	; 0
    5f18:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <SPIInit>
	SPICS(TRUE);
    5f1c:	81 e0       	ldi	r24, 0x01	; 1
    5f1e:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5f22:	8f ef       	ldi	r24, 0xFF	; 255
    5f24:	0e 94 1a 2b 	call	0x5634	; 0x5634 <SPI_write>
	SPICS(FALSE);	//stop spi
    5f28:	80 e0       	ldi	r24, 0x00	; 0
    5f2a:	0e 94 05 1e 	call	0x3c0a	; 0x3c0a <SPICS>
	SPIDisable();
    5f2e:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5f32:	80 e0       	ldi	r24, 0x00	; 0
    5f34:	0e 94 a7 04 	call	0x94e	; 0x94e <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5f38:	80 e0       	ldi	r24, 0x00	; 0
    5f3a:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <Ext1Power>
}
    5f3e:	08 95       	ret

00005f40 <__muldi3>:
    5f40:	a0 e3       	ldi	r26, 0x30	; 48
    5f42:	b0 e0       	ldi	r27, 0x00	; 0
    5f44:	e6 ea       	ldi	r30, 0xA6	; 166
    5f46:	ff e2       	ldi	r31, 0x2F	; 47
    5f48:	0c 94 3f 3b 	jmp	0x767e	; 0x767e <__prologue_saves__+0x4>
    5f4c:	29 8f       	std	Y+25, r18	; 0x19
    5f4e:	3a 8f       	std	Y+26, r19	; 0x1a
    5f50:	4b 8f       	std	Y+27, r20	; 0x1b
    5f52:	5c 8f       	std	Y+28, r21	; 0x1c
    5f54:	6d 8f       	std	Y+29, r22	; 0x1d
    5f56:	7e 8f       	std	Y+30, r23	; 0x1e
    5f58:	8f 8f       	std	Y+31, r24	; 0x1f
    5f5a:	98 a3       	lds	r25, 0x58
    5f5c:	a9 8a       	std	Y+17, r10	; 0x11
    5f5e:	ba 8a       	std	Y+18, r11	; 0x12
    5f60:	cb 8a       	std	Y+19, r12	; 0x13
    5f62:	dc 8a       	std	Y+20, r13	; 0x14
    5f64:	ed 8a       	std	Y+21, r14	; 0x15
    5f66:	fe 8a       	std	Y+22, r15	; 0x16
    5f68:	0f 8b       	std	Y+23, r16	; 0x17
    5f6a:	18 8f       	std	Y+24, r17	; 0x18
    5f6c:	09 8d       	ldd	r16, Y+25	; 0x19
    5f6e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5f70:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5f72:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5f74:	09 a3       	lds	r16, 0x59
    5f76:	1a a3       	lds	r17, 0x5a
    5f78:	2b a3       	lds	r18, 0x5b
    5f7a:	3c a3       	lds	r19, 0x5c
    5f7c:	68 01       	movw	r12, r16
    5f7e:	79 01       	movw	r14, r18
    5f80:	8f ef       	ldi	r24, 0xFF	; 255
    5f82:	9f ef       	ldi	r25, 0xFF	; 255
    5f84:	a0 e0       	ldi	r26, 0x00	; 0
    5f86:	b0 e0       	ldi	r27, 0x00	; 0
    5f88:	c8 22       	and	r12, r24
    5f8a:	d9 22       	and	r13, r25
    5f8c:	ea 22       	and	r14, r26
    5f8e:	fb 22       	and	r15, r27
    5f90:	89 01       	movw	r16, r18
    5f92:	22 27       	eor	r18, r18
    5f94:	33 27       	eor	r19, r19
    5f96:	09 a7       	lds	r16, 0x79
    5f98:	1a a7       	lds	r17, 0x7a
    5f9a:	2b a7       	lds	r18, 0x7b
    5f9c:	3c a7       	lds	r19, 0x7c
    5f9e:	09 89       	ldd	r16, Y+17	; 0x11
    5fa0:	1a 89       	ldd	r17, Y+18	; 0x12
    5fa2:	2b 89       	ldd	r18, Y+19	; 0x13
    5fa4:	3c 89       	ldd	r19, Y+20	; 0x14
    5fa6:	0d a3       	lds	r16, 0x5d
    5fa8:	1e a3       	lds	r17, 0x5e
    5faa:	2f a3       	lds	r18, 0x5f
    5fac:	38 a7       	lds	r19, 0x78
    5fae:	48 01       	movw	r8, r16
    5fb0:	59 01       	movw	r10, r18
    5fb2:	88 22       	and	r8, r24
    5fb4:	99 22       	and	r9, r25
    5fb6:	aa 22       	and	r10, r26
    5fb8:	bb 22       	and	r11, r27
    5fba:	29 01       	movw	r4, r18
    5fbc:	66 24       	eor	r6, r6
    5fbe:	77 24       	eor	r7, r7
    5fc0:	c5 01       	movw	r24, r10
    5fc2:	b4 01       	movw	r22, r8
    5fc4:	a7 01       	movw	r20, r14
    5fc6:	96 01       	movw	r18, r12
    5fc8:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    5fcc:	6d a7       	lds	r22, 0x7d
    5fce:	7e a7       	lds	r23, 0x7e
    5fd0:	8f a7       	lds	r24, 0x7f
    5fd2:	98 ab       	sts	0x58, r25
    5fd4:	c3 01       	movw	r24, r6
    5fd6:	b2 01       	movw	r22, r4
    5fd8:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    5fdc:	6b 01       	movw	r12, r22
    5fde:	7c 01       	movw	r14, r24
    5fe0:	c5 01       	movw	r24, r10
    5fe2:	b4 01       	movw	r22, r8
    5fe4:	29 a5       	lds	r18, 0x69
    5fe6:	3a a5       	lds	r19, 0x6a
    5fe8:	4b a5       	lds	r20, 0x6b
    5fea:	5c a5       	lds	r21, 0x6c
    5fec:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    5ff0:	4b 01       	movw	r8, r22
    5ff2:	5c 01       	movw	r10, r24
    5ff4:	c3 01       	movw	r24, r6
    5ff6:	b2 01       	movw	r22, r4
    5ff8:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    5ffc:	ab 01       	movw	r20, r22
    5ffe:	bc 01       	movw	r22, r24
    6000:	c8 0c       	add	r12, r8
    6002:	d9 1c       	adc	r13, r9
    6004:	ea 1c       	adc	r14, r10
    6006:	fb 1c       	adc	r15, r11
    6008:	0d a5       	lds	r16, 0x6d
    600a:	1e a5       	lds	r17, 0x6e
    600c:	2f a5       	lds	r18, 0x6f
    600e:	38 a9       	sts	0x48, r19
    6010:	c9 01       	movw	r24, r18
    6012:	aa 27       	eor	r26, r26
    6014:	bb 27       	eor	r27, r27
    6016:	c8 0e       	add	r12, r24
    6018:	d9 1e       	adc	r13, r25
    601a:	ea 1e       	adc	r14, r26
    601c:	fb 1e       	adc	r15, r27
    601e:	c8 14       	cp	r12, r8
    6020:	d9 04       	cpc	r13, r9
    6022:	ea 04       	cpc	r14, r10
    6024:	fb 04       	cpc	r15, r11
    6026:	20 f4       	brcc	.+8      	; 0x6030 <__stack+0x31>
    6028:	40 50       	subi	r20, 0x00	; 0
    602a:	50 40       	sbci	r21, 0x00	; 0
    602c:	6f 4f       	sbci	r22, 0xFF	; 255
    602e:	7f 4f       	sbci	r23, 0xFF	; 255
    6030:	c7 01       	movw	r24, r14
    6032:	aa 27       	eor	r26, r26
    6034:	bb 27       	eor	r27, r27
    6036:	84 0f       	add	r24, r20
    6038:	95 1f       	adc	r25, r21
    603a:	a6 1f       	adc	r26, r22
    603c:	b7 1f       	adc	r27, r23
    603e:	8d 83       	std	Y+5, r24	; 0x05
    6040:	9e 83       	std	Y+6, r25	; 0x06
    6042:	af 83       	std	Y+7, r26	; 0x07
    6044:	b8 87       	std	Y+8, r27	; 0x08
    6046:	76 01       	movw	r14, r12
    6048:	dd 24       	eor	r13, r13
    604a:	cc 24       	eor	r12, r12
    604c:	4d a5       	lds	r20, 0x6d
    604e:	5e a5       	lds	r21, 0x6e
    6050:	6f a5       	lds	r22, 0x6f
    6052:	78 a9       	sts	0x48, r23
    6054:	60 70       	andi	r22, 0x00	; 0
    6056:	70 70       	andi	r23, 0x00	; 0
    6058:	c4 0e       	add	r12, r20
    605a:	d5 1e       	adc	r13, r21
    605c:	e6 1e       	adc	r14, r22
    605e:	f7 1e       	adc	r15, r23
    6060:	c9 82       	std	Y+1, r12	; 0x01
    6062:	da 82       	std	Y+2, r13	; 0x02
    6064:	eb 82       	std	Y+3, r14	; 0x03
    6066:	fc 82       	std	Y+4, r15	; 0x04
    6068:	1c 2d       	mov	r17, r12
    606a:	0a 81       	ldd	r16, Y+2	; 0x02
    606c:	8b 80       	ldd	r8, Y+3	; 0x03
    606e:	4c 80       	ldd	r4, Y+4	; 0x04
    6070:	8d 87       	std	Y+13, r24	; 0x0d
    6072:	8e 81       	ldd	r24, Y+6	; 0x06
    6074:	8e 87       	std	Y+14, r24	; 0x0e
    6076:	8f 81       	ldd	r24, Y+7	; 0x07
    6078:	8f 87       	std	Y+15, r24	; 0x0f
    607a:	88 85       	ldd	r24, Y+8	; 0x08
    607c:	88 8b       	std	Y+16, r24	; 0x10
    607e:	2d 89       	ldd	r18, Y+21	; 0x15
    6080:	3e 89       	ldd	r19, Y+22	; 0x16
    6082:	4f 89       	ldd	r20, Y+23	; 0x17
    6084:	58 8d       	ldd	r21, Y+24	; 0x18
    6086:	69 a1       	lds	r22, 0x49
    6088:	7a a1       	lds	r23, 0x4a
    608a:	8b a1       	lds	r24, 0x4b
    608c:	9c a1       	lds	r25, 0x4c
    608e:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6092:	6b 01       	movw	r12, r22
    6094:	7c 01       	movw	r14, r24
    6096:	2d 8d       	ldd	r18, Y+29	; 0x1d
    6098:	3e 8d       	ldd	r19, Y+30	; 0x1e
    609a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    609c:	58 a1       	lds	r21, 0x48
    609e:	6d a1       	lds	r22, 0x4d
    60a0:	7e a1       	lds	r23, 0x4e
    60a2:	8f a1       	lds	r24, 0x4f
    60a4:	98 a5       	lds	r25, 0x68
    60a6:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    60aa:	dc 01       	movw	r26, r24
    60ac:	cb 01       	movw	r24, r22
    60ae:	c8 0e       	add	r12, r24
    60b0:	d9 1e       	adc	r13, r25
    60b2:	ea 1e       	adc	r14, r26
    60b4:	fb 1e       	adc	r15, r27
    60b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    60b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    60ba:	af 85       	ldd	r26, Y+15	; 0x0f
    60bc:	b8 89       	ldd	r27, Y+16	; 0x10
    60be:	8c 0d       	add	r24, r12
    60c0:	9d 1d       	adc	r25, r13
    60c2:	ae 1d       	adc	r26, r14
    60c4:	bf 1d       	adc	r27, r15
    60c6:	8d 87       	std	Y+13, r24	; 0x0d
    60c8:	9e 87       	std	Y+14, r25	; 0x0e
    60ca:	af 87       	std	Y+15, r26	; 0x0f
    60cc:	b8 8b       	std	Y+16, r27	; 0x10
    60ce:	68 2f       	mov	r22, r24
    60d0:	7e 85       	ldd	r23, Y+14	; 0x0e
    60d2:	21 2f       	mov	r18, r17
    60d4:	30 2f       	mov	r19, r16
    60d6:	48 2d       	mov	r20, r8
    60d8:	54 2d       	mov	r21, r4
    60da:	8f 85       	ldd	r24, Y+15	; 0x0f
    60dc:	98 89       	ldd	r25, Y+16	; 0x10
    60de:	e0 96       	adiw	r28, 0x30	; 48
    60e0:	e0 e1       	ldi	r30, 0x10	; 16
    60e2:	0c 94 58 3b 	jmp	0x76b0	; 0x76b0 <__epilogue_restores__+0x4>

000060e6 <__ashldi3>:
    60e6:	cf 92       	push	r12
    60e8:	df 92       	push	r13
    60ea:	ef 92       	push	r14
    60ec:	ff 92       	push	r15
    60ee:	0f 93       	push	r16
    60f0:	cf 93       	push	r28
    60f2:	df 93       	push	r29
    60f4:	cd b7       	in	r28, 0x3d	; 61
    60f6:	de b7       	in	r29, 0x3e	; 62
    60f8:	60 97       	sbiw	r28, 0x10	; 16
    60fa:	cd bf       	out	0x3d, r28	; 61
    60fc:	de bf       	out	0x3e, r29	; 62
    60fe:	00 23       	and	r16, r16
    6100:	09 f4       	brne	.+2      	; 0x6104 <__ashldi3+0x1e>
    6102:	5a c0       	rjmp	.+180    	; 0x61b8 <__ashldi3+0xd2>
    6104:	29 87       	std	Y+9, r18	; 0x09
    6106:	3a 87       	std	Y+10, r19	; 0x0a
    6108:	4b 87       	std	Y+11, r20	; 0x0b
    610a:	5c 87       	std	Y+12, r21	; 0x0c
    610c:	6d 87       	std	Y+13, r22	; 0x0d
    610e:	7e 87       	std	Y+14, r23	; 0x0e
    6110:	8f 87       	std	Y+15, r24	; 0x0f
    6112:	98 8b       	std	Y+16, r25	; 0x10
    6114:	80 e2       	ldi	r24, 0x20	; 32
    6116:	80 1b       	sub	r24, r16
    6118:	49 85       	ldd	r20, Y+9	; 0x09
    611a:	5a 85       	ldd	r21, Y+10	; 0x0a
    611c:	6b 85       	ldd	r22, Y+11	; 0x0b
    611e:	7c 85       	ldd	r23, Y+12	; 0x0c
    6120:	18 16       	cp	r1, r24
    6122:	b4 f0       	brlt	.+44     	; 0x6150 <__ashldi3+0x6a>
    6124:	19 82       	std	Y+1, r1	; 0x01
    6126:	1a 82       	std	Y+2, r1	; 0x02
    6128:	1b 82       	std	Y+3, r1	; 0x03
    612a:	1c 82       	std	Y+4, r1	; 0x04
    612c:	99 27       	eor	r25, r25
    612e:	87 fd       	sbrc	r24, 7
    6130:	90 95       	com	r25
    6132:	90 95       	com	r25
    6134:	81 95       	neg	r24
    6136:	9f 4f       	sbci	r25, 0xFF	; 255
    6138:	04 c0       	rjmp	.+8      	; 0x6142 <__ashldi3+0x5c>
    613a:	44 0f       	add	r20, r20
    613c:	55 1f       	adc	r21, r21
    613e:	66 1f       	adc	r22, r22
    6140:	77 1f       	adc	r23, r23
    6142:	8a 95       	dec	r24
    6144:	d2 f7       	brpl	.-12     	; 0x613a <__ashldi3+0x54>
    6146:	4d 83       	std	Y+5, r20	; 0x05
    6148:	5e 83       	std	Y+6, r21	; 0x06
    614a:	6f 83       	std	Y+7, r22	; 0x07
    614c:	78 87       	std	Y+8, r23	; 0x08
    614e:	2c c0       	rjmp	.+88     	; 0x61a8 <__ashldi3+0xc2>
    6150:	6a 01       	movw	r12, r20
    6152:	7b 01       	movw	r14, r22
    6154:	00 2e       	mov	r0, r16
    6156:	04 c0       	rjmp	.+8      	; 0x6160 <__ashldi3+0x7a>
    6158:	cc 0c       	add	r12, r12
    615a:	dd 1c       	adc	r13, r13
    615c:	ee 1c       	adc	r14, r14
    615e:	ff 1c       	adc	r15, r15
    6160:	0a 94       	dec	r0
    6162:	d2 f7       	brpl	.-12     	; 0x6158 <__ashldi3+0x72>
    6164:	c9 82       	std	Y+1, r12	; 0x01
    6166:	da 82       	std	Y+2, r13	; 0x02
    6168:	eb 82       	std	Y+3, r14	; 0x03
    616a:	fc 82       	std	Y+4, r15	; 0x04
    616c:	6a 01       	movw	r12, r20
    616e:	7b 01       	movw	r14, r22
    6170:	04 c0       	rjmp	.+8      	; 0x617a <__ashldi3+0x94>
    6172:	f6 94       	lsr	r15
    6174:	e7 94       	ror	r14
    6176:	d7 94       	ror	r13
    6178:	c7 94       	ror	r12
    617a:	8a 95       	dec	r24
    617c:	d2 f7       	brpl	.-12     	; 0x6172 <__ashldi3+0x8c>
    617e:	d7 01       	movw	r26, r14
    6180:	c6 01       	movw	r24, r12
    6182:	4d 85       	ldd	r20, Y+13	; 0x0d
    6184:	5e 85       	ldd	r21, Y+14	; 0x0e
    6186:	6f 85       	ldd	r22, Y+15	; 0x0f
    6188:	78 89       	ldd	r23, Y+16	; 0x10
    618a:	04 c0       	rjmp	.+8      	; 0x6194 <__ashldi3+0xae>
    618c:	44 0f       	add	r20, r20
    618e:	55 1f       	adc	r21, r21
    6190:	66 1f       	adc	r22, r22
    6192:	77 1f       	adc	r23, r23
    6194:	0a 95       	dec	r16
    6196:	d2 f7       	brpl	.-12     	; 0x618c <__ashldi3+0xa6>
    6198:	84 2b       	or	r24, r20
    619a:	95 2b       	or	r25, r21
    619c:	a6 2b       	or	r26, r22
    619e:	b7 2b       	or	r27, r23
    61a0:	8d 83       	std	Y+5, r24	; 0x05
    61a2:	9e 83       	std	Y+6, r25	; 0x06
    61a4:	af 83       	std	Y+7, r26	; 0x07
    61a6:	b8 87       	std	Y+8, r27	; 0x08
    61a8:	29 81       	ldd	r18, Y+1	; 0x01
    61aa:	3a 81       	ldd	r19, Y+2	; 0x02
    61ac:	4b 81       	ldd	r20, Y+3	; 0x03
    61ae:	5c 81       	ldd	r21, Y+4	; 0x04
    61b0:	6d 81       	ldd	r22, Y+5	; 0x05
    61b2:	7e 81       	ldd	r23, Y+6	; 0x06
    61b4:	8f 81       	ldd	r24, Y+7	; 0x07
    61b6:	98 85       	ldd	r25, Y+8	; 0x08
    61b8:	60 96       	adiw	r28, 0x10	; 16
    61ba:	cd bf       	out	0x3d, r28	; 61
    61bc:	de bf       	out	0x3e, r29	; 62
    61be:	df 91       	pop	r29
    61c0:	cf 91       	pop	r28
    61c2:	0f 91       	pop	r16
    61c4:	ff 90       	pop	r15
    61c6:	ef 90       	pop	r14
    61c8:	df 90       	pop	r13
    61ca:	cf 90       	pop	r12
    61cc:	08 95       	ret

000061ce <__ashrdi3>:
    61ce:	0f 93       	push	r16
    61d0:	cf 93       	push	r28
    61d2:	df 93       	push	r29
    61d4:	cd b7       	in	r28, 0x3d	; 61
    61d6:	de b7       	in	r29, 0x3e	; 62
    61d8:	60 97       	sbiw	r28, 0x10	; 16
    61da:	cd bf       	out	0x3d, r28	; 61
    61dc:	de bf       	out	0x3e, r29	; 62
    61de:	00 23       	and	r16, r16
    61e0:	09 f4       	brne	.+2      	; 0x61e4 <__ashrdi3+0x16>
    61e2:	56 c0       	rjmp	.+172    	; 0x6290 <__ashrdi3+0xc2>
    61e4:	29 87       	std	Y+9, r18	; 0x09
    61e6:	3a 87       	std	Y+10, r19	; 0x0a
    61e8:	4b 87       	std	Y+11, r20	; 0x0b
    61ea:	5c 87       	std	Y+12, r21	; 0x0c
    61ec:	6d 87       	std	Y+13, r22	; 0x0d
    61ee:	7e 87       	std	Y+14, r23	; 0x0e
    61f0:	8f 87       	std	Y+15, r24	; 0x0f
    61f2:	98 8b       	std	Y+16, r25	; 0x10
    61f4:	20 e2       	ldi	r18, 0x20	; 32
    61f6:	20 1b       	sub	r18, r16
    61f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    61fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    61fc:	af 85       	ldd	r26, Y+15	; 0x0f
    61fe:	b8 89       	ldd	r27, Y+16	; 0x10
    6200:	ac 01       	movw	r20, r24
    6202:	bd 01       	movw	r22, r26
    6204:	12 16       	cp	r1, r18
    6206:	b4 f0       	brlt	.+44     	; 0x6234 <__ashrdi3+0x66>
    6208:	77 0f       	add	r23, r23
    620a:	44 0b       	sbc	r20, r20
    620c:	54 2f       	mov	r21, r20
    620e:	ba 01       	movw	r22, r20
    6210:	4d 83       	std	Y+5, r20	; 0x05
    6212:	5e 83       	std	Y+6, r21	; 0x06
    6214:	6f 83       	std	Y+7, r22	; 0x07
    6216:	78 87       	std	Y+8, r23	; 0x08
    6218:	33 27       	eor	r19, r19
    621a:	27 fd       	sbrc	r18, 7
    621c:	30 95       	com	r19
    621e:	30 95       	com	r19
    6220:	21 95       	neg	r18
    6222:	3f 4f       	sbci	r19, 0xFF	; 255
    6224:	04 c0       	rjmp	.+8      	; 0x622e <__ashrdi3+0x60>
    6226:	b5 95       	asr	r27
    6228:	a7 95       	ror	r26
    622a:	97 95       	ror	r25
    622c:	87 95       	ror	r24
    622e:	2a 95       	dec	r18
    6230:	d2 f7       	brpl	.-12     	; 0x6226 <__ashrdi3+0x58>
    6232:	22 c0       	rjmp	.+68     	; 0x6278 <__ashrdi3+0xaa>
    6234:	00 2e       	mov	r0, r16
    6236:	04 c0       	rjmp	.+8      	; 0x6240 <__ashrdi3+0x72>
    6238:	75 95       	asr	r23
    623a:	67 95       	ror	r22
    623c:	57 95       	ror	r21
    623e:	47 95       	ror	r20
    6240:	0a 94       	dec	r0
    6242:	d2 f7       	brpl	.-12     	; 0x6238 <__ashrdi3+0x6a>
    6244:	4d 83       	std	Y+5, r20	; 0x05
    6246:	5e 83       	std	Y+6, r21	; 0x06
    6248:	6f 83       	std	Y+7, r22	; 0x07
    624a:	78 87       	std	Y+8, r23	; 0x08
    624c:	04 c0       	rjmp	.+8      	; 0x6256 <__ashrdi3+0x88>
    624e:	88 0f       	add	r24, r24
    6250:	99 1f       	adc	r25, r25
    6252:	aa 1f       	adc	r26, r26
    6254:	bb 1f       	adc	r27, r27
    6256:	2a 95       	dec	r18
    6258:	d2 f7       	brpl	.-12     	; 0x624e <__ashrdi3+0x80>
    625a:	49 85       	ldd	r20, Y+9	; 0x09
    625c:	5a 85       	ldd	r21, Y+10	; 0x0a
    625e:	6b 85       	ldd	r22, Y+11	; 0x0b
    6260:	7c 85       	ldd	r23, Y+12	; 0x0c
    6262:	04 c0       	rjmp	.+8      	; 0x626c <__ashrdi3+0x9e>
    6264:	76 95       	lsr	r23
    6266:	67 95       	ror	r22
    6268:	57 95       	ror	r21
    626a:	47 95       	ror	r20
    626c:	0a 95       	dec	r16
    626e:	d2 f7       	brpl	.-12     	; 0x6264 <__ashrdi3+0x96>
    6270:	84 2b       	or	r24, r20
    6272:	95 2b       	or	r25, r21
    6274:	a6 2b       	or	r26, r22
    6276:	b7 2b       	or	r27, r23
    6278:	89 83       	std	Y+1, r24	; 0x01
    627a:	9a 83       	std	Y+2, r25	; 0x02
    627c:	ab 83       	std	Y+3, r26	; 0x03
    627e:	bc 83       	std	Y+4, r27	; 0x04
    6280:	29 81       	ldd	r18, Y+1	; 0x01
    6282:	3a 81       	ldd	r19, Y+2	; 0x02
    6284:	4b 81       	ldd	r20, Y+3	; 0x03
    6286:	5c 81       	ldd	r21, Y+4	; 0x04
    6288:	6d 81       	ldd	r22, Y+5	; 0x05
    628a:	7e 81       	ldd	r23, Y+6	; 0x06
    628c:	8f 81       	ldd	r24, Y+7	; 0x07
    628e:	98 85       	ldd	r25, Y+8	; 0x08
    6290:	60 96       	adiw	r28, 0x10	; 16
    6292:	cd bf       	out	0x3d, r28	; 61
    6294:	de bf       	out	0x3e, r29	; 62
    6296:	df 91       	pop	r29
    6298:	cf 91       	pop	r28
    629a:	0f 91       	pop	r16
    629c:	08 95       	ret

0000629e <__divdi3>:
    629e:	a8 e4       	ldi	r26, 0x48	; 72
    62a0:	b0 e0       	ldi	r27, 0x00	; 0
    62a2:	e5 e5       	ldi	r30, 0x55	; 85
    62a4:	f1 e3       	ldi	r31, 0x31	; 49
    62a6:	0c 94 3e 3b 	jmp	0x767c	; 0x767c <__prologue_saves__+0x2>
    62aa:	f5 01       	movw	r30, r10
    62ac:	29 a3       	lds	r18, 0x59
    62ae:	3a a3       	lds	r19, 0x5a
    62b0:	4b a3       	lds	r20, 0x5b
    62b2:	5c a3       	lds	r21, 0x5c
    62b4:	6d a3       	lds	r22, 0x5d
    62b6:	7e a3       	lds	r23, 0x5e
    62b8:	8f a3       	lds	r24, 0x5f
    62ba:	98 a7       	lds	r25, 0x78
    62bc:	a9 8e       	std	Y+25, r10	; 0x19
    62be:	fa 8f       	std	Y+26, r31	; 0x1a
    62c0:	cb 8e       	std	Y+27, r12	; 0x1b
    62c2:	dc 8e       	std	Y+28, r13	; 0x1c
    62c4:	ed 8e       	std	Y+29, r14	; 0x1d
    62c6:	fe 8e       	std	Y+30, r15	; 0x1e
    62c8:	0f 8f       	std	Y+31, r16	; 0x1f
    62ca:	18 a3       	lds	r17, 0x58
    62cc:	8d a0       	lds	r24, 0x8d
    62ce:	9e a0       	lds	r25, 0x8e
    62d0:	af a0       	lds	r26, 0x8f
    62d2:	b8 a4       	lds	r27, 0xa8
    62d4:	b7 fe       	sbrs	r11, 7
    62d6:	67 c0       	rjmp	.+206    	; 0x63a6 <__divdi3+0x108>
    62d8:	21 95       	neg	r18
    62da:	b1 e0       	ldi	r27, 0x01	; 1
    62dc:	12 16       	cp	r1, r18
    62de:	08 f0       	brcs	.+2      	; 0x62e2 <__divdi3+0x44>
    62e0:	b0 e0       	ldi	r27, 0x00	; 0
    62e2:	31 95       	neg	r19
    62e4:	a1 e0       	ldi	r26, 0x01	; 1
    62e6:	13 16       	cp	r1, r19
    62e8:	08 f0       	brcs	.+2      	; 0x62ec <__divdi3+0x4e>
    62ea:	a0 e0       	ldi	r26, 0x00	; 0
    62ec:	b3 2e       	mov	r11, r19
    62ee:	bb 1a       	sub	r11, r27
    62f0:	bb 2d       	mov	r27, r11
    62f2:	88 24       	eor	r8, r8
    62f4:	83 94       	inc	r8
    62f6:	3b 15       	cp	r19, r11
    62f8:	08 f0       	brcs	.+2      	; 0x62fc <__divdi3+0x5e>
    62fa:	88 24       	eor	r8, r8
    62fc:	a8 29       	or	r26, r8
    62fe:	41 95       	neg	r20
    6300:	31 e0       	ldi	r19, 0x01	; 1
    6302:	14 16       	cp	r1, r20
    6304:	08 f0       	brcs	.+2      	; 0x6308 <__divdi3+0x6a>
    6306:	30 e0       	ldi	r19, 0x00	; 0
    6308:	b4 2e       	mov	r11, r20
    630a:	ba 1a       	sub	r11, r26
    630c:	ab 2d       	mov	r26, r11
    630e:	88 24       	eor	r8, r8
    6310:	83 94       	inc	r8
    6312:	4b 15       	cp	r20, r11
    6314:	08 f0       	brcs	.+2      	; 0x6318 <__divdi3+0x7a>
    6316:	88 24       	eor	r8, r8
    6318:	38 29       	or	r19, r8
    631a:	51 95       	neg	r21
    631c:	41 e0       	ldi	r20, 0x01	; 1
    631e:	15 16       	cp	r1, r21
    6320:	08 f0       	brcs	.+2      	; 0x6324 <__divdi3+0x86>
    6322:	40 e0       	ldi	r20, 0x00	; 0
    6324:	45 2e       	mov	r4, r21
    6326:	43 1a       	sub	r4, r19
    6328:	31 e0       	ldi	r19, 0x01	; 1
    632a:	54 15       	cp	r21, r4
    632c:	08 f0       	brcs	.+2      	; 0x6330 <__divdi3+0x92>
    632e:	30 e0       	ldi	r19, 0x00	; 0
    6330:	43 2b       	or	r20, r19
    6332:	61 95       	neg	r22
    6334:	31 e0       	ldi	r19, 0x01	; 1
    6336:	16 16       	cp	r1, r22
    6338:	08 f0       	brcs	.+2      	; 0x633c <__divdi3+0x9e>
    633a:	30 e0       	ldi	r19, 0x00	; 0
    633c:	86 2e       	mov	r8, r22
    633e:	84 1a       	sub	r8, r20
    6340:	41 e0       	ldi	r20, 0x01	; 1
    6342:	68 15       	cp	r22, r8
    6344:	08 f0       	brcs	.+2      	; 0x6348 <__divdi3+0xaa>
    6346:	40 e0       	ldi	r20, 0x00	; 0
    6348:	34 2b       	or	r19, r20
    634a:	71 95       	neg	r23
    634c:	41 e0       	ldi	r20, 0x01	; 1
    634e:	17 16       	cp	r1, r23
    6350:	08 f0       	brcs	.+2      	; 0x6354 <__divdi3+0xb6>
    6352:	40 e0       	ldi	r20, 0x00	; 0
    6354:	57 2f       	mov	r21, r23
    6356:	53 1b       	sub	r21, r19
    6358:	31 e0       	ldi	r19, 0x01	; 1
    635a:	75 17       	cp	r23, r21
    635c:	08 f0       	brcs	.+2      	; 0x6360 <__divdi3+0xc2>
    635e:	30 e0       	ldi	r19, 0x00	; 0
    6360:	43 2b       	or	r20, r19
    6362:	81 95       	neg	r24
    6364:	31 e0       	ldi	r19, 0x01	; 1
    6366:	18 16       	cp	r1, r24
    6368:	08 f0       	brcs	.+2      	; 0x636c <__divdi3+0xce>
    636a:	30 e0       	ldi	r19, 0x00	; 0
    636c:	68 2f       	mov	r22, r24
    636e:	64 1b       	sub	r22, r20
    6370:	46 2f       	mov	r20, r22
    6372:	61 e0       	ldi	r22, 0x01	; 1
    6374:	84 17       	cp	r24, r20
    6376:	08 f0       	brcs	.+2      	; 0x637a <__divdi3+0xdc>
    6378:	60 e0       	ldi	r22, 0x00	; 0
    637a:	36 2b       	or	r19, r22
    637c:	91 95       	neg	r25
    637e:	93 1b       	sub	r25, r19
    6380:	29 a3       	lds	r18, 0x59
    6382:	ba a3       	lds	r27, 0x5a
    6384:	ab a3       	lds	r26, 0x5b
    6386:	4c a2       	lds	r20, 0x9c
    6388:	8d a2       	lds	r24, 0x9d
    638a:	5e a3       	lds	r21, 0x5e
    638c:	4f a3       	lds	r20, 0x5f
    638e:	98 a7       	lds	r25, 0x78
    6390:	8f ef       	ldi	r24, 0xFF	; 255
    6392:	9f ef       	ldi	r25, 0xFF	; 255
    6394:	af ef       	ldi	r26, 0xFF	; 255
    6396:	bf ef       	ldi	r27, 0xFF	; 255
    6398:	25 96       	adiw	r28, 0x05	; 5
    639a:	8c af       	sts	0x7c, r24
    639c:	9d af       	sts	0x7d, r25
    639e:	ae af       	sts	0x7e, r26
    63a0:	bf af       	sts	0x7f, r27
    63a2:	25 97       	sbiw	r28, 0x05	; 5
    63a4:	06 c0       	rjmp	.+12     	; 0x63b2 <__divdi3+0x114>
    63a6:	25 96       	adiw	r28, 0x05	; 5
    63a8:	1c ae       	sts	0xbc, r17
    63aa:	1d ae       	sts	0xbd, r17
    63ac:	1e ae       	sts	0xbe, r17
    63ae:	1f ae       	sts	0xbf, r17
    63b0:	25 97       	sbiw	r28, 0x05	; 5
    63b2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    63b4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    63b6:	af 8d       	ldd	r26, Y+31	; 0x1f
    63b8:	b8 a1       	lds	r27, 0x48
    63ba:	b7 ff       	sbrs	r27, 7
    63bc:	68 c0       	rjmp	.+208    	; 0x648e <__divdi3+0x1f0>
    63be:	25 96       	adiw	r28, 0x05	; 5
    63c0:	2c ad       	sts	0x6c, r18
    63c2:	3d ad       	sts	0x6d, r19
    63c4:	4e ad       	sts	0x6e, r20
    63c6:	5f ad       	sts	0x6f, r21
    63c8:	25 97       	sbiw	r28, 0x05	; 5
    63ca:	20 95       	com	r18
    63cc:	30 95       	com	r19
    63ce:	40 95       	com	r20
    63d0:	50 95       	com	r21
    63d2:	25 96       	adiw	r28, 0x05	; 5
    63d4:	2c af       	sts	0x7c, r18
    63d6:	3d af       	sts	0x7d, r19
    63d8:	4e af       	sts	0x7e, r20
    63da:	5f af       	sts	0x7f, r21
    63dc:	25 97       	sbiw	r28, 0x05	; 5
    63de:	e1 95       	neg	r30
    63e0:	81 e0       	ldi	r24, 0x01	; 1
    63e2:	1e 16       	cp	r1, r30
    63e4:	08 f0       	brcs	.+2      	; 0x63e8 <__divdi3+0x14a>
    63e6:	80 e0       	ldi	r24, 0x00	; 0
    63e8:	f1 95       	neg	r31
    63ea:	91 e0       	ldi	r25, 0x01	; 1
    63ec:	1f 16       	cp	r1, r31
    63ee:	08 f0       	brcs	.+2      	; 0x63f2 <__divdi3+0x154>
    63f0:	90 e0       	ldi	r25, 0x00	; 0
    63f2:	4f 2f       	mov	r20, r31
    63f4:	48 1b       	sub	r20, r24
    63f6:	81 e0       	ldi	r24, 0x01	; 1
    63f8:	f4 17       	cp	r31, r20
    63fa:	08 f0       	brcs	.+2      	; 0x63fe <__divdi3+0x160>
    63fc:	80 e0       	ldi	r24, 0x00	; 0
    63fe:	98 2b       	or	r25, r24
    6400:	c1 94       	neg	r12
    6402:	81 e0       	ldi	r24, 0x01	; 1
    6404:	1c 14       	cp	r1, r12
    6406:	08 f0       	brcs	.+2      	; 0x640a <__divdi3+0x16c>
    6408:	80 e0       	ldi	r24, 0x00	; 0
    640a:	6c 2d       	mov	r22, r12
    640c:	69 1b       	sub	r22, r25
    640e:	91 e0       	ldi	r25, 0x01	; 1
    6410:	c6 16       	cp	r12, r22
    6412:	08 f0       	brcs	.+2      	; 0x6416 <__divdi3+0x178>
    6414:	90 e0       	ldi	r25, 0x00	; 0
    6416:	89 2b       	or	r24, r25
    6418:	d1 94       	neg	r13
    641a:	91 e0       	ldi	r25, 0x01	; 1
    641c:	1d 14       	cp	r1, r13
    641e:	08 f0       	brcs	.+2      	; 0x6422 <__divdi3+0x184>
    6420:	90 e0       	ldi	r25, 0x00	; 0
    6422:	5d 2d       	mov	r21, r13
    6424:	58 1b       	sub	r21, r24
    6426:	81 e0       	ldi	r24, 0x01	; 1
    6428:	d5 16       	cp	r13, r21
    642a:	08 f0       	brcs	.+2      	; 0x642e <__divdi3+0x190>
    642c:	80 e0       	ldi	r24, 0x00	; 0
    642e:	98 2b       	or	r25, r24
    6430:	e1 94       	neg	r14
    6432:	81 e0       	ldi	r24, 0x01	; 1
    6434:	1e 14       	cp	r1, r14
    6436:	08 f0       	brcs	.+2      	; 0x643a <__divdi3+0x19c>
    6438:	80 e0       	ldi	r24, 0x00	; 0
    643a:	3e 2d       	mov	r19, r14
    643c:	39 1b       	sub	r19, r25
    643e:	91 e0       	ldi	r25, 0x01	; 1
    6440:	e3 16       	cp	r14, r19
    6442:	08 f0       	brcs	.+2      	; 0x6446 <__divdi3+0x1a8>
    6444:	90 e0       	ldi	r25, 0x00	; 0
    6446:	89 2b       	or	r24, r25
    6448:	f1 94       	neg	r15
    644a:	91 e0       	ldi	r25, 0x01	; 1
    644c:	1f 14       	cp	r1, r15
    644e:	08 f0       	brcs	.+2      	; 0x6452 <__divdi3+0x1b4>
    6450:	90 e0       	ldi	r25, 0x00	; 0
    6452:	2f 2d       	mov	r18, r15
    6454:	28 1b       	sub	r18, r24
    6456:	81 e0       	ldi	r24, 0x01	; 1
    6458:	f2 16       	cp	r15, r18
    645a:	08 f0       	brcs	.+2      	; 0x645e <__divdi3+0x1c0>
    645c:	80 e0       	ldi	r24, 0x00	; 0
    645e:	98 2b       	or	r25, r24
    6460:	01 95       	neg	r16
    6462:	81 e0       	ldi	r24, 0x01	; 1
    6464:	10 16       	cp	r1, r16
    6466:	08 f0       	brcs	.+2      	; 0x646a <__divdi3+0x1cc>
    6468:	80 e0       	ldi	r24, 0x00	; 0
    646a:	70 2f       	mov	r23, r16
    646c:	79 1b       	sub	r23, r25
    646e:	97 2f       	mov	r25, r23
    6470:	71 e0       	ldi	r23, 0x01	; 1
    6472:	09 17       	cp	r16, r25
    6474:	08 f0       	brcs	.+2      	; 0x6478 <__divdi3+0x1da>
    6476:	70 e0       	ldi	r23, 0x00	; 0
    6478:	87 2b       	or	r24, r23
    647a:	11 95       	neg	r17
    647c:	18 1b       	sub	r17, r24
    647e:	e9 8f       	std	Y+25, r30	; 0x19
    6480:	4a 8f       	std	Y+26, r20	; 0x1a
    6482:	6b 8f       	std	Y+27, r22	; 0x1b
    6484:	5c 8f       	std	Y+28, r21	; 0x1c
    6486:	3d 8f       	std	Y+29, r19	; 0x1d
    6488:	2e 8f       	std	Y+30, r18	; 0x1e
    648a:	9f 8f       	std	Y+31, r25	; 0x1f
    648c:	18 a3       	lds	r17, 0x58
    648e:	79 8d       	ldd	r23, Y+25	; 0x19
    6490:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6492:	5b 8d       	ldd	r21, Y+27	; 0x1b
    6494:	4c 8d       	ldd	r20, Y+28	; 0x1c
    6496:	3d 8d       	ldd	r19, Y+29	; 0x1d
    6498:	2e 8d       	ldd	r18, Y+30	; 0x1e
    649a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    649c:	88 a1       	lds	r24, 0x48
    649e:	e9 a1       	lds	r30, 0x49
    64a0:	e9 8b       	std	Y+17, r30	; 0x11
    64a2:	ea a1       	lds	r30, 0x4a
    64a4:	ea 8b       	std	Y+18, r30	; 0x12
    64a6:	eb a1       	lds	r30, 0x4b
    64a8:	eb 8b       	std	Y+19, r30	; 0x13
    64aa:	ec a1       	lds	r30, 0x4c
    64ac:	ec 8b       	std	Y+20, r30	; 0x14
    64ae:	ed a1       	lds	r30, 0x4d
    64b0:	ed 8b       	std	Y+21, r30	; 0x15
    64b2:	ee a1       	lds	r30, 0x4e
    64b4:	ee 8b       	std	Y+22, r30	; 0x16
    64b6:	ef a1       	lds	r30, 0x4f
    64b8:	ef 8b       	std	Y+23, r30	; 0x17
    64ba:	e8 a5       	lds	r30, 0x68
    64bc:	e8 8f       	std	Y+24, r30	; 0x18
    64be:	79 87       	std	Y+9, r23	; 0x09
    64c0:	6a 87       	std	Y+10, r22	; 0x0a
    64c2:	5b 87       	std	Y+11, r21	; 0x0b
    64c4:	4c 87       	std	Y+12, r20	; 0x0c
    64c6:	3d 87       	std	Y+13, r19	; 0x0d
    64c8:	2e 87       	std	Y+14, r18	; 0x0e
    64ca:	9f 87       	std	Y+15, r25	; 0x0f
    64cc:	88 8b       	std	Y+16, r24	; 0x10
    64ce:	89 84       	ldd	r8, Y+9	; 0x09
    64d0:	9a 84       	ldd	r9, Y+10	; 0x0a
    64d2:	ab 84       	ldd	r10, Y+11	; 0x0b
    64d4:	bc 84       	ldd	r11, Y+12	; 0x0c
    64d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    64d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    64da:	af 85       	ldd	r26, Y+15	; 0x0f
    64dc:	b8 89       	ldd	r27, Y+16	; 0x10
    64de:	e9 88       	ldd	r14, Y+17	; 0x11
    64e0:	fa 88       	ldd	r15, Y+18	; 0x12
    64e2:	0b 89       	ldd	r16, Y+19	; 0x13
    64e4:	1c 89       	ldd	r17, Y+20	; 0x14
    64e6:	ed aa       	sts	0x9d, r30
    64e8:	fe aa       	sts	0x9e, r31
    64ea:	0f ab       	sts	0x5f, r16
    64ec:	18 af       	sts	0x78, r17
    64ee:	cd 88       	ldd	r12, Y+21	; 0x15
    64f0:	de 88       	ldd	r13, Y+22	; 0x16
    64f2:	ef 88       	ldd	r14, Y+23	; 0x17
    64f4:	f8 8c       	ldd	r15, Y+24	; 0x18
    64f6:	00 97       	sbiw	r24, 0x00	; 0
    64f8:	a1 05       	cpc	r26, r1
    64fa:	b1 05       	cpc	r27, r1
    64fc:	09 f0       	breq	.+2      	; 0x6500 <__divdi3+0x262>
    64fe:	bd c3       	rjmp	.+1914   	; 0x6c7a <__divdi3+0x9dc>
    6500:	c8 14       	cp	r12, r8
    6502:	d9 04       	cpc	r13, r9
    6504:	ea 04       	cpc	r14, r10
    6506:	fb 04       	cpc	r15, r11
    6508:	08 f0       	brcs	.+2      	; 0x650c <__divdi3+0x26e>
    650a:	4d c1       	rjmp	.+666    	; 0x67a6 <__divdi3+0x508>
    650c:	00 e0       	ldi	r16, 0x00	; 0
    650e:	80 16       	cp	r8, r16
    6510:	00 e0       	ldi	r16, 0x00	; 0
    6512:	90 06       	cpc	r9, r16
    6514:	01 e0       	ldi	r16, 0x01	; 1
    6516:	a0 06       	cpc	r10, r16
    6518:	00 e0       	ldi	r16, 0x00	; 0
    651a:	b0 06       	cpc	r11, r16
    651c:	58 f4       	brcc	.+22     	; 0x6534 <__divdi3+0x296>
    651e:	1f ef       	ldi	r17, 0xFF	; 255
    6520:	81 16       	cp	r8, r17
    6522:	91 04       	cpc	r9, r1
    6524:	a1 04       	cpc	r10, r1
    6526:	b1 04       	cpc	r11, r1
    6528:	09 f0       	breq	.+2      	; 0x652c <__divdi3+0x28e>
    652a:	90 f4       	brcc	.+36     	; 0x6550 <__divdi3+0x2b2>
    652c:	80 e0       	ldi	r24, 0x00	; 0
    652e:	90 e0       	ldi	r25, 0x00	; 0
    6530:	dc 01       	movw	r26, r24
    6532:	17 c0       	rjmp	.+46     	; 0x6562 <__divdi3+0x2c4>
    6534:	20 e0       	ldi	r18, 0x00	; 0
    6536:	82 16       	cp	r8, r18
    6538:	20 e0       	ldi	r18, 0x00	; 0
    653a:	92 06       	cpc	r9, r18
    653c:	20 e0       	ldi	r18, 0x00	; 0
    653e:	a2 06       	cpc	r10, r18
    6540:	21 e0       	ldi	r18, 0x01	; 1
    6542:	b2 06       	cpc	r11, r18
    6544:	50 f4       	brcc	.+20     	; 0x655a <__divdi3+0x2bc>
    6546:	80 e1       	ldi	r24, 0x10	; 16
    6548:	90 e0       	ldi	r25, 0x00	; 0
    654a:	a0 e0       	ldi	r26, 0x00	; 0
    654c:	b0 e0       	ldi	r27, 0x00	; 0
    654e:	09 c0       	rjmp	.+18     	; 0x6562 <__divdi3+0x2c4>
    6550:	88 e0       	ldi	r24, 0x08	; 8
    6552:	90 e0       	ldi	r25, 0x00	; 0
    6554:	a0 e0       	ldi	r26, 0x00	; 0
    6556:	b0 e0       	ldi	r27, 0x00	; 0
    6558:	04 c0       	rjmp	.+8      	; 0x6562 <__divdi3+0x2c4>
    655a:	88 e1       	ldi	r24, 0x18	; 24
    655c:	90 e0       	ldi	r25, 0x00	; 0
    655e:	a0 e0       	ldi	r26, 0x00	; 0
    6560:	b0 e0       	ldi	r27, 0x00	; 0
    6562:	b5 01       	movw	r22, r10
    6564:	a4 01       	movw	r20, r8
    6566:	08 2e       	mov	r0, r24
    6568:	04 c0       	rjmp	.+8      	; 0x6572 <__divdi3+0x2d4>
    656a:	76 95       	lsr	r23
    656c:	67 95       	ror	r22
    656e:	57 95       	ror	r21
    6570:	47 95       	ror	r20
    6572:	0a 94       	dec	r0
    6574:	d2 f7       	brpl	.-12     	; 0x656a <__divdi3+0x2cc>
    6576:	fa 01       	movw	r30, r20
    6578:	e9 5c       	subi	r30, 0xC9	; 201
    657a:	ff 4d       	sbci	r31, 0xDF	; 223
    657c:	20 81       	ld	r18, Z
    657e:	40 e2       	ldi	r20, 0x20	; 32
    6580:	50 e0       	ldi	r21, 0x00	; 0
    6582:	60 e0       	ldi	r22, 0x00	; 0
    6584:	70 e0       	ldi	r23, 0x00	; 0
    6586:	48 1b       	sub	r20, r24
    6588:	59 0b       	sbc	r21, r25
    658a:	6a 0b       	sbc	r22, r26
    658c:	7b 0b       	sbc	r23, r27
    658e:	42 1b       	sub	r20, r18
    6590:	51 09       	sbc	r21, r1
    6592:	61 09       	sbc	r22, r1
    6594:	71 09       	sbc	r23, r1
    6596:	41 15       	cp	r20, r1
    6598:	51 05       	cpc	r21, r1
    659a:	61 05       	cpc	r22, r1
    659c:	71 05       	cpc	r23, r1
    659e:	a1 f1       	breq	.+104    	; 0x6608 <__divdi3+0x36a>
    65a0:	04 2e       	mov	r0, r20
    65a2:	04 c0       	rjmp	.+8      	; 0x65ac <__divdi3+0x30e>
    65a4:	88 0c       	add	r8, r8
    65a6:	99 1c       	adc	r9, r9
    65a8:	aa 1c       	adc	r10, r10
    65aa:	bb 1c       	adc	r11, r11
    65ac:	0a 94       	dec	r0
    65ae:	d2 f7       	brpl	.-12     	; 0x65a4 <__divdi3+0x306>
    65b0:	97 01       	movw	r18, r14
    65b2:	86 01       	movw	r16, r12
    65b4:	04 2e       	mov	r0, r20
    65b6:	04 c0       	rjmp	.+8      	; 0x65c0 <__divdi3+0x322>
    65b8:	00 0f       	add	r16, r16
    65ba:	11 1f       	adc	r17, r17
    65bc:	22 1f       	adc	r18, r18
    65be:	33 1f       	adc	r19, r19
    65c0:	0a 94       	dec	r0
    65c2:	d2 f7       	brpl	.-12     	; 0x65b8 <__divdi3+0x31a>
    65c4:	80 e2       	ldi	r24, 0x20	; 32
    65c6:	90 e0       	ldi	r25, 0x00	; 0
    65c8:	84 1b       	sub	r24, r20
    65ca:	95 0b       	sbc	r25, r21
    65cc:	cd a8       	sts	0x8d, r28
    65ce:	de a8       	sts	0x8e, r29
    65d0:	ef a8       	sts	0x8f, r30
    65d2:	f8 ac       	sts	0xa8, r31
    65d4:	04 c0       	rjmp	.+8      	; 0x65de <__divdi3+0x340>
    65d6:	f6 94       	lsr	r15
    65d8:	e7 94       	ror	r14
    65da:	d7 94       	ror	r13
    65dc:	c7 94       	ror	r12
    65de:	8a 95       	dec	r24
    65e0:	d2 f7       	brpl	.-12     	; 0x65d6 <__divdi3+0x338>
    65e2:	c0 2a       	or	r12, r16
    65e4:	d1 2a       	or	r13, r17
    65e6:	e2 2a       	or	r14, r18
    65e8:	f3 2a       	or	r15, r19
    65ea:	0d a9       	sts	0x4d, r16
    65ec:	1e a9       	sts	0x4e, r17
    65ee:	2f a9       	sts	0x4f, r18
    65f0:	38 ad       	sts	0x68, r19
    65f2:	04 c0       	rjmp	.+8      	; 0x65fc <__divdi3+0x35e>
    65f4:	00 0f       	add	r16, r16
    65f6:	11 1f       	adc	r17, r17
    65f8:	22 1f       	adc	r18, r18
    65fa:	33 1f       	adc	r19, r19
    65fc:	4a 95       	dec	r20
    65fe:	d2 f7       	brpl	.-12     	; 0x65f4 <__divdi3+0x356>
    6600:	0d ab       	sts	0x5d, r16
    6602:	1e ab       	sts	0x5e, r17
    6604:	2f ab       	sts	0x5f, r18
    6606:	38 af       	sts	0x78, r19
    6608:	25 01       	movw	r4, r10
    660a:	66 24       	eor	r6, r6
    660c:	77 24       	eor	r7, r7
    660e:	95 01       	movw	r18, r10
    6610:	84 01       	movw	r16, r8
    6612:	20 70       	andi	r18, 0x00	; 0
    6614:	30 70       	andi	r19, 0x00	; 0
    6616:	09 ab       	sts	0x59, r16
    6618:	1a ab       	sts	0x5a, r17
    661a:	2b ab       	sts	0x5b, r18
    661c:	3c ab       	sts	0x5c, r19
    661e:	c7 01       	movw	r24, r14
    6620:	b6 01       	movw	r22, r12
    6622:	a3 01       	movw	r20, r6
    6624:	92 01       	movw	r18, r4
    6626:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    662a:	2d a7       	lds	r18, 0x7d
    662c:	3e a7       	lds	r19, 0x7e
    662e:	4f a7       	lds	r20, 0x7f
    6630:	58 ab       	sts	0x58, r21
    6632:	69 a7       	lds	r22, 0x79
    6634:	7a a7       	lds	r23, 0x7a
    6636:	8b a7       	lds	r24, 0x7b
    6638:	9c a7       	lds	r25, 0x7c
    663a:	c7 01       	movw	r24, r14
    663c:	b6 01       	movw	r22, r12
    663e:	a3 01       	movw	r20, r6
    6640:	92 01       	movw	r18, r4
    6642:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6646:	ca 01       	movw	r24, r20
    6648:	b9 01       	movw	r22, r18
    664a:	29 a9       	sts	0x49, r18
    664c:	3a a9       	sts	0x4a, r19
    664e:	4b a9       	sts	0x4b, r20
    6650:	5c a9       	sts	0x4c, r21
    6652:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6656:	ab 01       	movw	r20, r22
    6658:	bc 01       	movw	r22, r24
    665a:	09 a5       	lds	r16, 0x69
    665c:	1a a5       	lds	r17, 0x6a
    665e:	2b a5       	lds	r18, 0x6b
    6660:	3c a5       	lds	r19, 0x6c
    6662:	78 01       	movw	r14, r16
    6664:	dd 24       	eor	r13, r13
    6666:	cc 24       	eor	r12, r12
    6668:	0d a9       	sts	0x4d, r16
    666a:	1e a9       	sts	0x4e, r17
    666c:	2f a9       	sts	0x4f, r18
    666e:	38 ad       	sts	0x68, r19
    6670:	c9 01       	movw	r24, r18
    6672:	aa 27       	eor	r26, r26
    6674:	bb 27       	eor	r27, r27
    6676:	c8 2a       	or	r12, r24
    6678:	d9 2a       	or	r13, r25
    667a:	ea 2a       	or	r14, r26
    667c:	fb 2a       	or	r15, r27
    667e:	0d a5       	lds	r16, 0x6d
    6680:	1e a5       	lds	r17, 0x6e
    6682:	2f a5       	lds	r18, 0x6f
    6684:	38 a9       	sts	0x48, r19
    6686:	c4 16       	cp	r12, r20
    6688:	d5 06       	cpc	r13, r21
    668a:	e6 06       	cpc	r14, r22
    668c:	f7 06       	cpc	r15, r23
    668e:	38 f5       	brcc	.+78     	; 0x66de <__divdi3+0x440>
    6690:	01 50       	subi	r16, 0x01	; 1
    6692:	10 40       	sbci	r17, 0x00	; 0
    6694:	20 40       	sbci	r18, 0x00	; 0
    6696:	30 40       	sbci	r19, 0x00	; 0
    6698:	09 a7       	lds	r16, 0x79
    669a:	1a a7       	lds	r17, 0x7a
    669c:	2b a7       	lds	r18, 0x7b
    669e:	3c a7       	lds	r19, 0x7c
    66a0:	c8 0c       	add	r12, r8
    66a2:	d9 1c       	adc	r13, r9
    66a4:	ea 1c       	adc	r14, r10
    66a6:	fb 1c       	adc	r15, r11
    66a8:	c8 14       	cp	r12, r8
    66aa:	d9 04       	cpc	r13, r9
    66ac:	ea 04       	cpc	r14, r10
    66ae:	fb 04       	cpc	r15, r11
    66b0:	d0 f0       	brcs	.+52     	; 0x66e6 <__divdi3+0x448>
    66b2:	c4 16       	cp	r12, r20
    66b4:	d5 06       	cpc	r13, r21
    66b6:	e6 06       	cpc	r14, r22
    66b8:	f7 06       	cpc	r15, r23
    66ba:	a8 f4       	brcc	.+42     	; 0x66e6 <__divdi3+0x448>
    66bc:	0d a5       	lds	r16, 0x6d
    66be:	1e a5       	lds	r17, 0x6e
    66c0:	2f a5       	lds	r18, 0x6f
    66c2:	38 a9       	sts	0x48, r19
    66c4:	02 50       	subi	r16, 0x02	; 2
    66c6:	10 40       	sbci	r17, 0x00	; 0
    66c8:	20 40       	sbci	r18, 0x00	; 0
    66ca:	30 40       	sbci	r19, 0x00	; 0
    66cc:	09 a7       	lds	r16, 0x79
    66ce:	1a a7       	lds	r17, 0x7a
    66d0:	2b a7       	lds	r18, 0x7b
    66d2:	3c a7       	lds	r19, 0x7c
    66d4:	c8 0c       	add	r12, r8
    66d6:	d9 1c       	adc	r13, r9
    66d8:	ea 1c       	adc	r14, r10
    66da:	fb 1c       	adc	r15, r11
    66dc:	04 c0       	rjmp	.+8      	; 0x66e6 <__divdi3+0x448>
    66de:	09 a7       	lds	r16, 0x79
    66e0:	1a a7       	lds	r17, 0x7a
    66e2:	2b a7       	lds	r18, 0x7b
    66e4:	3c a7       	lds	r19, 0x7c
    66e6:	c4 1a       	sub	r12, r20
    66e8:	d5 0a       	sbc	r13, r21
    66ea:	e6 0a       	sbc	r14, r22
    66ec:	f7 0a       	sbc	r15, r23
    66ee:	c7 01       	movw	r24, r14
    66f0:	b6 01       	movw	r22, r12
    66f2:	a3 01       	movw	r20, r6
    66f4:	92 01       	movw	r18, r4
    66f6:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    66fa:	2d a7       	lds	r18, 0x7d
    66fc:	3e a7       	lds	r19, 0x7e
    66fe:	4f a7       	lds	r20, 0x7f
    6700:	58 ab       	sts	0x58, r21
    6702:	69 af       	sts	0x79, r22
    6704:	7a af       	sts	0x7a, r23
    6706:	8b af       	sts	0x7b, r24
    6708:	9c af       	sts	0x7c, r25
    670a:	c7 01       	movw	r24, r14
    670c:	b6 01       	movw	r22, r12
    670e:	a3 01       	movw	r20, r6
    6710:	92 01       	movw	r18, r4
    6712:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6716:	ca 01       	movw	r24, r20
    6718:	b9 01       	movw	r22, r18
    671a:	29 a9       	sts	0x49, r18
    671c:	3a a9       	sts	0x4a, r19
    671e:	4b a9       	sts	0x4b, r20
    6720:	5c a9       	sts	0x4c, r21
    6722:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6726:	6b 01       	movw	r12, r22
    6728:	7c 01       	movw	r14, r24
    672a:	49 ad       	sts	0x69, r20
    672c:	5a ad       	sts	0x6a, r21
    672e:	6b ad       	sts	0x6b, r22
    6730:	7c ad       	sts	0x6c, r23
    6732:	9a 01       	movw	r18, r20
    6734:	11 27       	eor	r17, r17
    6736:	00 27       	eor	r16, r16
    6738:	4d a9       	sts	0x4d, r20
    673a:	5e a9       	sts	0x4e, r21
    673c:	6f a9       	sts	0x4f, r22
    673e:	78 ad       	sts	0x68, r23
    6740:	60 70       	andi	r22, 0x00	; 0
    6742:	70 70       	andi	r23, 0x00	; 0
    6744:	04 2b       	or	r16, r20
    6746:	15 2b       	or	r17, r21
    6748:	26 2b       	or	r18, r22
    674a:	37 2b       	or	r19, r23
    674c:	8d a5       	lds	r24, 0x6d
    674e:	9e a5       	lds	r25, 0x6e
    6750:	af a5       	lds	r26, 0x6f
    6752:	b8 a9       	sts	0x48, r27
    6754:	0c 15       	cp	r16, r12
    6756:	1d 05       	cpc	r17, r13
    6758:	2e 05       	cpc	r18, r14
    675a:	3f 05       	cpc	r19, r15
    675c:	c0 f4       	brcc	.+48     	; 0x678e <__divdi3+0x4f0>
    675e:	01 97       	sbiw	r24, 0x01	; 1
    6760:	a1 09       	sbc	r26, r1
    6762:	b1 09       	sbc	r27, r1
    6764:	08 0d       	add	r16, r8
    6766:	19 1d       	adc	r17, r9
    6768:	2a 1d       	adc	r18, r10
    676a:	3b 1d       	adc	r19, r11
    676c:	08 15       	cp	r16, r8
    676e:	19 05       	cpc	r17, r9
    6770:	2a 05       	cpc	r18, r10
    6772:	3b 05       	cpc	r19, r11
    6774:	60 f0       	brcs	.+24     	; 0x678e <__divdi3+0x4f0>
    6776:	0c 15       	cp	r16, r12
    6778:	1d 05       	cpc	r17, r13
    677a:	2e 05       	cpc	r18, r14
    677c:	3f 05       	cpc	r19, r15
    677e:	38 f4       	brcc	.+14     	; 0x678e <__divdi3+0x4f0>
    6780:	8d a5       	lds	r24, 0x6d
    6782:	9e a5       	lds	r25, 0x6e
    6784:	af a5       	lds	r26, 0x6f
    6786:	b8 a9       	sts	0x48, r27
    6788:	02 97       	sbiw	r24, 0x02	; 2
    678a:	a1 09       	sbc	r26, r1
    678c:	b1 09       	sbc	r27, r1
    678e:	09 a5       	lds	r16, 0x69
    6790:	1a a5       	lds	r17, 0x6a
    6792:	2b a5       	lds	r18, 0x6b
    6794:	3c a5       	lds	r19, 0x6c
    6796:	78 01       	movw	r14, r16
    6798:	dd 24       	eor	r13, r13
    679a:	cc 24       	eor	r12, r12
    679c:	c8 2a       	or	r12, r24
    679e:	d9 2a       	or	r13, r25
    67a0:	ea 2a       	or	r14, r26
    67a2:	fb 2a       	or	r15, r27
    67a4:	b7 c4       	rjmp	.+2414   	; 0x7114 <__divdi3+0xe76>
    67a6:	81 14       	cp	r8, r1
    67a8:	91 04       	cpc	r9, r1
    67aa:	a1 04       	cpc	r10, r1
    67ac:	b1 04       	cpc	r11, r1
    67ae:	51 f4       	brne	.+20     	; 0x67c4 <__divdi3+0x526>
    67b0:	61 e0       	ldi	r22, 0x01	; 1
    67b2:	70 e0       	ldi	r23, 0x00	; 0
    67b4:	80 e0       	ldi	r24, 0x00	; 0
    67b6:	90 e0       	ldi	r25, 0x00	; 0
    67b8:	a5 01       	movw	r20, r10
    67ba:	94 01       	movw	r18, r8
    67bc:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    67c0:	49 01       	movw	r8, r18
    67c2:	5a 01       	movw	r10, r20
    67c4:	10 e0       	ldi	r17, 0x00	; 0
    67c6:	81 16       	cp	r8, r17
    67c8:	10 e0       	ldi	r17, 0x00	; 0
    67ca:	91 06       	cpc	r9, r17
    67cc:	11 e0       	ldi	r17, 0x01	; 1
    67ce:	a1 06       	cpc	r10, r17
    67d0:	10 e0       	ldi	r17, 0x00	; 0
    67d2:	b1 06       	cpc	r11, r17
    67d4:	58 f4       	brcc	.+22     	; 0x67ec <__divdi3+0x54e>
    67d6:	2f ef       	ldi	r18, 0xFF	; 255
    67d8:	82 16       	cp	r8, r18
    67da:	91 04       	cpc	r9, r1
    67dc:	a1 04       	cpc	r10, r1
    67de:	b1 04       	cpc	r11, r1
    67e0:	09 f0       	breq	.+2      	; 0x67e4 <__divdi3+0x546>
    67e2:	90 f4       	brcc	.+36     	; 0x6808 <__divdi3+0x56a>
    67e4:	80 e0       	ldi	r24, 0x00	; 0
    67e6:	90 e0       	ldi	r25, 0x00	; 0
    67e8:	dc 01       	movw	r26, r24
    67ea:	17 c0       	rjmp	.+46     	; 0x681a <__divdi3+0x57c>
    67ec:	30 e0       	ldi	r19, 0x00	; 0
    67ee:	83 16       	cp	r8, r19
    67f0:	30 e0       	ldi	r19, 0x00	; 0
    67f2:	93 06       	cpc	r9, r19
    67f4:	30 e0       	ldi	r19, 0x00	; 0
    67f6:	a3 06       	cpc	r10, r19
    67f8:	31 e0       	ldi	r19, 0x01	; 1
    67fa:	b3 06       	cpc	r11, r19
    67fc:	50 f4       	brcc	.+20     	; 0x6812 <__divdi3+0x574>
    67fe:	80 e1       	ldi	r24, 0x10	; 16
    6800:	90 e0       	ldi	r25, 0x00	; 0
    6802:	a0 e0       	ldi	r26, 0x00	; 0
    6804:	b0 e0       	ldi	r27, 0x00	; 0
    6806:	09 c0       	rjmp	.+18     	; 0x681a <__divdi3+0x57c>
    6808:	88 e0       	ldi	r24, 0x08	; 8
    680a:	90 e0       	ldi	r25, 0x00	; 0
    680c:	a0 e0       	ldi	r26, 0x00	; 0
    680e:	b0 e0       	ldi	r27, 0x00	; 0
    6810:	04 c0       	rjmp	.+8      	; 0x681a <__divdi3+0x57c>
    6812:	88 e1       	ldi	r24, 0x18	; 24
    6814:	90 e0       	ldi	r25, 0x00	; 0
    6816:	a0 e0       	ldi	r26, 0x00	; 0
    6818:	b0 e0       	ldi	r27, 0x00	; 0
    681a:	b5 01       	movw	r22, r10
    681c:	a4 01       	movw	r20, r8
    681e:	08 2e       	mov	r0, r24
    6820:	04 c0       	rjmp	.+8      	; 0x682a <__divdi3+0x58c>
    6822:	76 95       	lsr	r23
    6824:	67 95       	ror	r22
    6826:	57 95       	ror	r21
    6828:	47 95       	ror	r20
    682a:	0a 94       	dec	r0
    682c:	d2 f7       	brpl	.-12     	; 0x6822 <__divdi3+0x584>
    682e:	fa 01       	movw	r30, r20
    6830:	e9 5c       	subi	r30, 0xC9	; 201
    6832:	ff 4d       	sbci	r31, 0xDF	; 223
    6834:	20 81       	ld	r18, Z
    6836:	ac 01       	movw	r20, r24
    6838:	bd 01       	movw	r22, r26
    683a:	42 0f       	add	r20, r18
    683c:	51 1d       	adc	r21, r1
    683e:	61 1d       	adc	r22, r1
    6840:	71 1d       	adc	r23, r1
    6842:	80 e2       	ldi	r24, 0x20	; 32
    6844:	90 e0       	ldi	r25, 0x00	; 0
    6846:	a0 e0       	ldi	r26, 0x00	; 0
    6848:	b0 e0       	ldi	r27, 0x00	; 0
    684a:	84 1b       	sub	r24, r20
    684c:	95 0b       	sbc	r25, r21
    684e:	a6 0b       	sbc	r26, r22
    6850:	b7 0b       	sbc	r27, r23
    6852:	51 f4       	brne	.+20     	; 0x6868 <__divdi3+0x5ca>
    6854:	c8 18       	sub	r12, r8
    6856:	d9 08       	sbc	r13, r9
    6858:	ea 08       	sbc	r14, r10
    685a:	fb 08       	sbc	r15, r11
    685c:	f1 e0       	ldi	r31, 0x01	; 1
    685e:	4f 2e       	mov	r4, r31
    6860:	51 2c       	mov	r5, r1
    6862:	61 2c       	mov	r6, r1
    6864:	71 2c       	mov	r7, r1
    6866:	28 c1       	rjmp	.+592    	; 0x6ab8 <__divdi3+0x81a>
    6868:	08 2e       	mov	r0, r24
    686a:	04 c0       	rjmp	.+8      	; 0x6874 <__divdi3+0x5d6>
    686c:	88 0c       	add	r8, r8
    686e:	99 1c       	adc	r9, r9
    6870:	aa 1c       	adc	r10, r10
    6872:	bb 1c       	adc	r11, r11
    6874:	0a 94       	dec	r0
    6876:	d2 f7       	brpl	.-12     	; 0x686c <__divdi3+0x5ce>
    6878:	97 01       	movw	r18, r14
    687a:	86 01       	movw	r16, r12
    687c:	04 2e       	mov	r0, r20
    687e:	04 c0       	rjmp	.+8      	; 0x6888 <__divdi3+0x5ea>
    6880:	36 95       	lsr	r19
    6882:	27 95       	ror	r18
    6884:	17 95       	ror	r17
    6886:	07 95       	ror	r16
    6888:	0a 94       	dec	r0
    688a:	d2 f7       	brpl	.-12     	; 0x6880 <__divdi3+0x5e2>
    688c:	09 ab       	sts	0x59, r16
    688e:	1a ab       	sts	0x5a, r17
    6890:	2b ab       	sts	0x5b, r18
    6892:	3c ab       	sts	0x5c, r19
    6894:	97 01       	movw	r18, r14
    6896:	86 01       	movw	r16, r12
    6898:	08 2e       	mov	r0, r24
    689a:	04 c0       	rjmp	.+8      	; 0x68a4 <__divdi3+0x606>
    689c:	00 0f       	add	r16, r16
    689e:	11 1f       	adc	r17, r17
    68a0:	22 1f       	adc	r18, r18
    68a2:	33 1f       	adc	r19, r19
    68a4:	0a 94       	dec	r0
    68a6:	d2 f7       	brpl	.-12     	; 0x689c <__divdi3+0x5fe>
    68a8:	0d a7       	lds	r16, 0x7d
    68aa:	1e a7       	lds	r17, 0x7e
    68ac:	2f a7       	lds	r18, 0x7f
    68ae:	38 ab       	sts	0x58, r19
    68b0:	ed a8       	sts	0x8d, r30
    68b2:	fe a8       	sts	0x8e, r31
    68b4:	0f a9       	sts	0x4f, r16
    68b6:	18 ad       	sts	0x68, r17
    68b8:	04 c0       	rjmp	.+8      	; 0x68c2 <__divdi3+0x624>
    68ba:	16 95       	lsr	r17
    68bc:	07 95       	ror	r16
    68be:	f7 94       	ror	r15
    68c0:	e7 94       	ror	r14
    68c2:	4a 95       	dec	r20
    68c4:	d2 f7       	brpl	.-12     	; 0x68ba <__divdi3+0x61c>
    68c6:	b8 01       	movw	r22, r16
    68c8:	a7 01       	movw	r20, r14
    68ca:	0d a5       	lds	r16, 0x6d
    68cc:	1e a5       	lds	r17, 0x6e
    68ce:	2f a5       	lds	r18, 0x6f
    68d0:	38 a9       	sts	0x48, r19
    68d2:	04 2b       	or	r16, r20
    68d4:	15 2b       	or	r17, r21
    68d6:	26 2b       	or	r18, r22
    68d8:	37 2b       	or	r19, r23
    68da:	0d a7       	lds	r16, 0x7d
    68dc:	1e a7       	lds	r17, 0x7e
    68de:	2f a7       	lds	r18, 0x7f
    68e0:	38 ab       	sts	0x58, r19
    68e2:	ed a8       	sts	0x8d, r30
    68e4:	fe a8       	sts	0x8e, r31
    68e6:	0f a9       	sts	0x4f, r16
    68e8:	18 ad       	sts	0x68, r17
    68ea:	04 c0       	rjmp	.+8      	; 0x68f4 <__divdi3+0x656>
    68ec:	ee 0c       	add	r14, r14
    68ee:	ff 1c       	adc	r15, r15
    68f0:	00 1f       	adc	r16, r16
    68f2:	11 1f       	adc	r17, r17
    68f4:	8a 95       	dec	r24
    68f6:	d2 f7       	brpl	.-12     	; 0x68ec <__divdi3+0x64e>
    68f8:	ed aa       	sts	0x9d, r30
    68fa:	fe aa       	sts	0x9e, r31
    68fc:	0f ab       	sts	0x5f, r16
    68fe:	18 af       	sts	0x78, r17
    6900:	25 01       	movw	r4, r10
    6902:	66 24       	eor	r6, r6
    6904:	77 24       	eor	r7, r7
    6906:	95 01       	movw	r18, r10
    6908:	84 01       	movw	r16, r8
    690a:	20 70       	andi	r18, 0x00	; 0
    690c:	30 70       	andi	r19, 0x00	; 0
    690e:	09 af       	sts	0x79, r16
    6910:	1a af       	sts	0x7a, r17
    6912:	2b af       	sts	0x7b, r18
    6914:	3c af       	sts	0x7c, r19
    6916:	69 a9       	sts	0x49, r22
    6918:	7a a9       	sts	0x4a, r23
    691a:	8b a9       	sts	0x4b, r24
    691c:	9c a9       	sts	0x4c, r25
    691e:	a3 01       	movw	r20, r6
    6920:	92 01       	movw	r18, r4
    6922:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6926:	29 a7       	lds	r18, 0x79
    6928:	3a a7       	lds	r19, 0x7a
    692a:	4b a7       	lds	r20, 0x7b
    692c:	5c a7       	lds	r21, 0x7c
    692e:	6b 01       	movw	r12, r22
    6930:	7c 01       	movw	r14, r24
    6932:	69 a9       	sts	0x49, r22
    6934:	7a a9       	sts	0x4a, r23
    6936:	8b a9       	sts	0x4b, r24
    6938:	9c a9       	sts	0x4c, r25
    693a:	a3 01       	movw	r20, r6
    693c:	92 01       	movw	r18, r4
    693e:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6942:	ca 01       	movw	r24, r20
    6944:	b9 01       	movw	r22, r18
    6946:	29 ad       	sts	0x69, r18
    6948:	3a ad       	sts	0x6a, r19
    694a:	4b ad       	sts	0x6b, r20
    694c:	5c ad       	sts	0x6c, r21
    694e:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6952:	ab 01       	movw	r20, r22
    6954:	bc 01       	movw	r22, r24
    6956:	76 01       	movw	r14, r12
    6958:	dd 24       	eor	r13, r13
    695a:	cc 24       	eor	r12, r12
    695c:	0d a5       	lds	r16, 0x6d
    695e:	1e a5       	lds	r17, 0x6e
    6960:	2f a5       	lds	r18, 0x6f
    6962:	38 a9       	sts	0x48, r19
    6964:	c9 01       	movw	r24, r18
    6966:	aa 27       	eor	r26, r26
    6968:	bb 27       	eor	r27, r27
    696a:	c8 2a       	or	r12, r24
    696c:	d9 2a       	or	r13, r25
    696e:	ea 2a       	or	r14, r26
    6970:	fb 2a       	or	r15, r27
    6972:	09 a5       	lds	r16, 0x69
    6974:	1a a5       	lds	r17, 0x6a
    6976:	2b a5       	lds	r18, 0x6b
    6978:	3c a5       	lds	r19, 0x6c
    697a:	c4 16       	cp	r12, r20
    697c:	d5 06       	cpc	r13, r21
    697e:	e6 06       	cpc	r14, r22
    6980:	f7 06       	cpc	r15, r23
    6982:	38 f5       	brcc	.+78     	; 0x69d2 <__divdi3+0x734>
    6984:	01 50       	subi	r16, 0x01	; 1
    6986:	10 40       	sbci	r17, 0x00	; 0
    6988:	20 40       	sbci	r18, 0x00	; 0
    698a:	30 40       	sbci	r19, 0x00	; 0
    698c:	09 ab       	sts	0x59, r16
    698e:	1a ab       	sts	0x5a, r17
    6990:	2b ab       	sts	0x5b, r18
    6992:	3c ab       	sts	0x5c, r19
    6994:	c8 0c       	add	r12, r8
    6996:	d9 1c       	adc	r13, r9
    6998:	ea 1c       	adc	r14, r10
    699a:	fb 1c       	adc	r15, r11
    699c:	c8 14       	cp	r12, r8
    699e:	d9 04       	cpc	r13, r9
    69a0:	ea 04       	cpc	r14, r10
    69a2:	fb 04       	cpc	r15, r11
    69a4:	d0 f0       	brcs	.+52     	; 0x69da <__divdi3+0x73c>
    69a6:	c4 16       	cp	r12, r20
    69a8:	d5 06       	cpc	r13, r21
    69aa:	e6 06       	cpc	r14, r22
    69ac:	f7 06       	cpc	r15, r23
    69ae:	a8 f4       	brcc	.+42     	; 0x69da <__divdi3+0x73c>
    69b0:	09 a5       	lds	r16, 0x69
    69b2:	1a a5       	lds	r17, 0x6a
    69b4:	2b a5       	lds	r18, 0x6b
    69b6:	3c a5       	lds	r19, 0x6c
    69b8:	02 50       	subi	r16, 0x02	; 2
    69ba:	10 40       	sbci	r17, 0x00	; 0
    69bc:	20 40       	sbci	r18, 0x00	; 0
    69be:	30 40       	sbci	r19, 0x00	; 0
    69c0:	09 ab       	sts	0x59, r16
    69c2:	1a ab       	sts	0x5a, r17
    69c4:	2b ab       	sts	0x5b, r18
    69c6:	3c ab       	sts	0x5c, r19
    69c8:	c8 0c       	add	r12, r8
    69ca:	d9 1c       	adc	r13, r9
    69cc:	ea 1c       	adc	r14, r10
    69ce:	fb 1c       	adc	r15, r11
    69d0:	04 c0       	rjmp	.+8      	; 0x69da <__divdi3+0x73c>
    69d2:	09 ab       	sts	0x59, r16
    69d4:	1a ab       	sts	0x5a, r17
    69d6:	2b ab       	sts	0x5b, r18
    69d8:	3c ab       	sts	0x5c, r19
    69da:	c4 1a       	sub	r12, r20
    69dc:	d5 0a       	sbc	r13, r21
    69de:	e6 0a       	sbc	r14, r22
    69e0:	f7 0a       	sbc	r15, r23
    69e2:	c7 01       	movw	r24, r14
    69e4:	b6 01       	movw	r22, r12
    69e6:	a3 01       	movw	r20, r6
    69e8:	92 01       	movw	r18, r4
    69ea:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    69ee:	29 a7       	lds	r18, 0x79
    69f0:	3a a7       	lds	r19, 0x7a
    69f2:	4b a7       	lds	r20, 0x7b
    69f4:	5c a7       	lds	r21, 0x7c
    69f6:	21 96       	adiw	r28, 0x01	; 1
    69f8:	6c af       	sts	0x7c, r22
    69fa:	7d af       	sts	0x7d, r23
    69fc:	8e af       	sts	0x7e, r24
    69fe:	9f af       	sts	0x7f, r25
    6a00:	21 97       	sbiw	r28, 0x01	; 1
    6a02:	c7 01       	movw	r24, r14
    6a04:	b6 01       	movw	r22, r12
    6a06:	a3 01       	movw	r20, r6
    6a08:	92 01       	movw	r18, r4
    6a0a:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6a0e:	ca 01       	movw	r24, r20
    6a10:	b9 01       	movw	r22, r18
    6a12:	29 ad       	sts	0x69, r18
    6a14:	3a ad       	sts	0x6a, r19
    6a16:	4b ad       	sts	0x6b, r20
    6a18:	5c ad       	sts	0x6c, r21
    6a1a:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6a1e:	8b 01       	movw	r16, r22
    6a20:	9c 01       	movw	r18, r24
    6a22:	21 96       	adiw	r28, 0x01	; 1
    6a24:	4c ad       	sts	0x6c, r20
    6a26:	5d ad       	sts	0x6d, r21
    6a28:	6e ad       	sts	0x6e, r22
    6a2a:	7f ad       	sts	0x6f, r23
    6a2c:	21 97       	sbiw	r28, 0x01	; 1
    6a2e:	da 01       	movw	r26, r20
    6a30:	99 27       	eor	r25, r25
    6a32:	88 27       	eor	r24, r24
    6a34:	4d a5       	lds	r20, 0x6d
    6a36:	5e a5       	lds	r21, 0x6e
    6a38:	6f a5       	lds	r22, 0x6f
    6a3a:	78 a9       	sts	0x48, r23
    6a3c:	60 70       	andi	r22, 0x00	; 0
    6a3e:	70 70       	andi	r23, 0x00	; 0
    6a40:	84 2b       	or	r24, r20
    6a42:	95 2b       	or	r25, r21
    6a44:	a6 2b       	or	r26, r22
    6a46:	b7 2b       	or	r27, r23
    6a48:	49 a5       	lds	r20, 0x69
    6a4a:	5a a5       	lds	r21, 0x6a
    6a4c:	6b a5       	lds	r22, 0x6b
    6a4e:	7c a5       	lds	r23, 0x6c
    6a50:	80 17       	cp	r24, r16
    6a52:	91 07       	cpc	r25, r17
    6a54:	a2 07       	cpc	r26, r18
    6a56:	b3 07       	cpc	r27, r19
    6a58:	f0 f4       	brcc	.+60     	; 0x6a96 <__divdi3+0x7f8>
    6a5a:	41 50       	subi	r20, 0x01	; 1
    6a5c:	50 40       	sbci	r21, 0x00	; 0
    6a5e:	60 40       	sbci	r22, 0x00	; 0
    6a60:	70 40       	sbci	r23, 0x00	; 0
    6a62:	88 0d       	add	r24, r8
    6a64:	99 1d       	adc	r25, r9
    6a66:	aa 1d       	adc	r26, r10
    6a68:	bb 1d       	adc	r27, r11
    6a6a:	88 15       	cp	r24, r8
    6a6c:	99 05       	cpc	r25, r9
    6a6e:	aa 05       	cpc	r26, r10
    6a70:	bb 05       	cpc	r27, r11
    6a72:	88 f0       	brcs	.+34     	; 0x6a96 <__divdi3+0x7f8>
    6a74:	80 17       	cp	r24, r16
    6a76:	91 07       	cpc	r25, r17
    6a78:	a2 07       	cpc	r26, r18
    6a7a:	b3 07       	cpc	r27, r19
    6a7c:	60 f4       	brcc	.+24     	; 0x6a96 <__divdi3+0x7f8>
    6a7e:	49 a5       	lds	r20, 0x69
    6a80:	5a a5       	lds	r21, 0x6a
    6a82:	6b a5       	lds	r22, 0x6b
    6a84:	7c a5       	lds	r23, 0x6c
    6a86:	42 50       	subi	r20, 0x02	; 2
    6a88:	50 40       	sbci	r21, 0x00	; 0
    6a8a:	60 40       	sbci	r22, 0x00	; 0
    6a8c:	70 40       	sbci	r23, 0x00	; 0
    6a8e:	88 0d       	add	r24, r8
    6a90:	99 1d       	adc	r25, r9
    6a92:	aa 1d       	adc	r26, r10
    6a94:	bb 1d       	adc	r27, r11
    6a96:	6c 01       	movw	r12, r24
    6a98:	7d 01       	movw	r14, r26
    6a9a:	c0 1a       	sub	r12, r16
    6a9c:	d1 0a       	sbc	r13, r17
    6a9e:	e2 0a       	sbc	r14, r18
    6aa0:	f3 0a       	sbc	r15, r19
    6aa2:	09 a9       	sts	0x49, r16
    6aa4:	1a a9       	sts	0x4a, r17
    6aa6:	2b a9       	sts	0x4b, r18
    6aa8:	3c a9       	sts	0x4c, r19
    6aaa:	38 01       	movw	r6, r16
    6aac:	55 24       	eor	r5, r5
    6aae:	44 24       	eor	r4, r4
    6ab0:	44 2a       	or	r4, r20
    6ab2:	55 2a       	or	r5, r21
    6ab4:	66 2a       	or	r6, r22
    6ab6:	77 2a       	or	r7, r23
    6ab8:	85 01       	movw	r16, r10
    6aba:	22 27       	eor	r18, r18
    6abc:	33 27       	eor	r19, r19
    6abe:	0d a7       	lds	r16, 0x7d
    6ac0:	1e a7       	lds	r17, 0x7e
    6ac2:	2f a7       	lds	r18, 0x7f
    6ac4:	38 ab       	sts	0x58, r19
    6ac6:	95 01       	movw	r18, r10
    6ac8:	84 01       	movw	r16, r8
    6aca:	20 70       	andi	r18, 0x00	; 0
    6acc:	30 70       	andi	r19, 0x00	; 0
    6ace:	09 af       	sts	0x79, r16
    6ad0:	1a af       	sts	0x7a, r17
    6ad2:	2b af       	sts	0x7b, r18
    6ad4:	3c af       	sts	0x7c, r19
    6ad6:	c7 01       	movw	r24, r14
    6ad8:	b6 01       	movw	r22, r12
    6ada:	2d a5       	lds	r18, 0x6d
    6adc:	3e a5       	lds	r19, 0x6e
    6ade:	4f a5       	lds	r20, 0x6f
    6ae0:	58 a9       	sts	0x48, r21
    6ae2:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6ae6:	29 a7       	lds	r18, 0x79
    6ae8:	3a a7       	lds	r19, 0x7a
    6aea:	4b a7       	lds	r20, 0x7b
    6aec:	5c a7       	lds	r21, 0x7c
    6aee:	69 ab       	sts	0x59, r22
    6af0:	7a ab       	sts	0x5a, r23
    6af2:	8b ab       	sts	0x5b, r24
    6af4:	9c ab       	sts	0x5c, r25
    6af6:	c7 01       	movw	r24, r14
    6af8:	b6 01       	movw	r22, r12
    6afa:	2d a5       	lds	r18, 0x6d
    6afc:	3e a5       	lds	r19, 0x6e
    6afe:	4f a5       	lds	r20, 0x6f
    6b00:	58 a9       	sts	0x48, r21
    6b02:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6b06:	ca 01       	movw	r24, r20
    6b08:	b9 01       	movw	r22, r18
    6b0a:	29 ad       	sts	0x69, r18
    6b0c:	3a ad       	sts	0x6a, r19
    6b0e:	4b ad       	sts	0x6b, r20
    6b10:	5c ad       	sts	0x6c, r21
    6b12:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6b16:	ab 01       	movw	r20, r22
    6b18:	bc 01       	movw	r22, r24
    6b1a:	09 a9       	sts	0x49, r16
    6b1c:	1a a9       	sts	0x4a, r17
    6b1e:	2b a9       	sts	0x4b, r18
    6b20:	3c a9       	sts	0x4c, r19
    6b22:	78 01       	movw	r14, r16
    6b24:	dd 24       	eor	r13, r13
    6b26:	cc 24       	eor	r12, r12
    6b28:	0d a9       	sts	0x4d, r16
    6b2a:	1e a9       	sts	0x4e, r17
    6b2c:	2f a9       	sts	0x4f, r18
    6b2e:	38 ad       	sts	0x68, r19
    6b30:	c9 01       	movw	r24, r18
    6b32:	aa 27       	eor	r26, r26
    6b34:	bb 27       	eor	r27, r27
    6b36:	c8 2a       	or	r12, r24
    6b38:	d9 2a       	or	r13, r25
    6b3a:	ea 2a       	or	r14, r26
    6b3c:	fb 2a       	or	r15, r27
    6b3e:	09 a5       	lds	r16, 0x69
    6b40:	1a a5       	lds	r17, 0x6a
    6b42:	2b a5       	lds	r18, 0x6b
    6b44:	3c a5       	lds	r19, 0x6c
    6b46:	c4 16       	cp	r12, r20
    6b48:	d5 06       	cpc	r13, r21
    6b4a:	e6 06       	cpc	r14, r22
    6b4c:	f7 06       	cpc	r15, r23
    6b4e:	38 f5       	brcc	.+78     	; 0x6b9e <__divdi3+0x900>
    6b50:	01 50       	subi	r16, 0x01	; 1
    6b52:	10 40       	sbci	r17, 0x00	; 0
    6b54:	20 40       	sbci	r18, 0x00	; 0
    6b56:	30 40       	sbci	r19, 0x00	; 0
    6b58:	09 ab       	sts	0x59, r16
    6b5a:	1a ab       	sts	0x5a, r17
    6b5c:	2b ab       	sts	0x5b, r18
    6b5e:	3c ab       	sts	0x5c, r19
    6b60:	c8 0c       	add	r12, r8
    6b62:	d9 1c       	adc	r13, r9
    6b64:	ea 1c       	adc	r14, r10
    6b66:	fb 1c       	adc	r15, r11
    6b68:	c8 14       	cp	r12, r8
    6b6a:	d9 04       	cpc	r13, r9
    6b6c:	ea 04       	cpc	r14, r10
    6b6e:	fb 04       	cpc	r15, r11
    6b70:	d0 f0       	brcs	.+52     	; 0x6ba6 <__divdi3+0x908>
    6b72:	c4 16       	cp	r12, r20
    6b74:	d5 06       	cpc	r13, r21
    6b76:	e6 06       	cpc	r14, r22
    6b78:	f7 06       	cpc	r15, r23
    6b7a:	a8 f4       	brcc	.+42     	; 0x6ba6 <__divdi3+0x908>
    6b7c:	09 a5       	lds	r16, 0x69
    6b7e:	1a a5       	lds	r17, 0x6a
    6b80:	2b a5       	lds	r18, 0x6b
    6b82:	3c a5       	lds	r19, 0x6c
    6b84:	02 50       	subi	r16, 0x02	; 2
    6b86:	10 40       	sbci	r17, 0x00	; 0
    6b88:	20 40       	sbci	r18, 0x00	; 0
    6b8a:	30 40       	sbci	r19, 0x00	; 0
    6b8c:	09 ab       	sts	0x59, r16
    6b8e:	1a ab       	sts	0x5a, r17
    6b90:	2b ab       	sts	0x5b, r18
    6b92:	3c ab       	sts	0x5c, r19
    6b94:	c8 0c       	add	r12, r8
    6b96:	d9 1c       	adc	r13, r9
    6b98:	ea 1c       	adc	r14, r10
    6b9a:	fb 1c       	adc	r15, r11
    6b9c:	04 c0       	rjmp	.+8      	; 0x6ba6 <__divdi3+0x908>
    6b9e:	09 ab       	sts	0x59, r16
    6ba0:	1a ab       	sts	0x5a, r17
    6ba2:	2b ab       	sts	0x5b, r18
    6ba4:	3c ab       	sts	0x5c, r19
    6ba6:	c4 1a       	sub	r12, r20
    6ba8:	d5 0a       	sbc	r13, r21
    6baa:	e6 0a       	sbc	r14, r22
    6bac:	f7 0a       	sbc	r15, r23
    6bae:	c7 01       	movw	r24, r14
    6bb0:	b6 01       	movw	r22, r12
    6bb2:	2d a5       	lds	r18, 0x6d
    6bb4:	3e a5       	lds	r19, 0x6e
    6bb6:	4f a5       	lds	r20, 0x6f
    6bb8:	58 a9       	sts	0x48, r21
    6bba:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6bbe:	29 a7       	lds	r18, 0x79
    6bc0:	3a a7       	lds	r19, 0x7a
    6bc2:	4b a7       	lds	r20, 0x7b
    6bc4:	5c a7       	lds	r21, 0x7c
    6bc6:	21 96       	adiw	r28, 0x01	; 1
    6bc8:	6c af       	sts	0x7c, r22
    6bca:	7d af       	sts	0x7d, r23
    6bcc:	8e af       	sts	0x7e, r24
    6bce:	9f af       	sts	0x7f, r25
    6bd0:	21 97       	sbiw	r28, 0x01	; 1
    6bd2:	c7 01       	movw	r24, r14
    6bd4:	b6 01       	movw	r22, r12
    6bd6:	2d a5       	lds	r18, 0x6d
    6bd8:	3e a5       	lds	r19, 0x6e
    6bda:	4f a5       	lds	r20, 0x6f
    6bdc:	58 a9       	sts	0x48, r21
    6bde:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6be2:	ca 01       	movw	r24, r20
    6be4:	b9 01       	movw	r22, r18
    6be6:	29 ad       	sts	0x69, r18
    6be8:	3a ad       	sts	0x6a, r19
    6bea:	4b ad       	sts	0x6b, r20
    6bec:	5c ad       	sts	0x6c, r21
    6bee:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6bf2:	8b 01       	movw	r16, r22
    6bf4:	9c 01       	movw	r18, r24
    6bf6:	21 96       	adiw	r28, 0x01	; 1
    6bf8:	4c ad       	sts	0x6c, r20
    6bfa:	5d ad       	sts	0x6d, r21
    6bfc:	6e ad       	sts	0x6e, r22
    6bfe:	7f ad       	sts	0x6f, r23
    6c00:	21 97       	sbiw	r28, 0x01	; 1
    6c02:	da 01       	movw	r26, r20
    6c04:	99 27       	eor	r25, r25
    6c06:	88 27       	eor	r24, r24
    6c08:	4d a9       	sts	0x4d, r20
    6c0a:	5e a9       	sts	0x4e, r21
    6c0c:	6f a9       	sts	0x4f, r22
    6c0e:	78 ad       	sts	0x68, r23
    6c10:	60 70       	andi	r22, 0x00	; 0
    6c12:	70 70       	andi	r23, 0x00	; 0
    6c14:	84 2b       	or	r24, r20
    6c16:	95 2b       	or	r25, r21
    6c18:	a6 2b       	or	r26, r22
    6c1a:	b7 2b       	or	r27, r23
    6c1c:	49 a5       	lds	r20, 0x69
    6c1e:	5a a5       	lds	r21, 0x6a
    6c20:	6b a5       	lds	r22, 0x6b
    6c22:	7c a5       	lds	r23, 0x6c
    6c24:	80 17       	cp	r24, r16
    6c26:	91 07       	cpc	r25, r17
    6c28:	a2 07       	cpc	r26, r18
    6c2a:	b3 07       	cpc	r27, r19
    6c2c:	d0 f4       	brcc	.+52     	; 0x6c62 <__divdi3+0x9c4>
    6c2e:	41 50       	subi	r20, 0x01	; 1
    6c30:	50 40       	sbci	r21, 0x00	; 0
    6c32:	60 40       	sbci	r22, 0x00	; 0
    6c34:	70 40       	sbci	r23, 0x00	; 0
    6c36:	88 0d       	add	r24, r8
    6c38:	99 1d       	adc	r25, r9
    6c3a:	aa 1d       	adc	r26, r10
    6c3c:	bb 1d       	adc	r27, r11
    6c3e:	88 15       	cp	r24, r8
    6c40:	99 05       	cpc	r25, r9
    6c42:	aa 05       	cpc	r26, r10
    6c44:	bb 05       	cpc	r27, r11
    6c46:	68 f0       	brcs	.+26     	; 0x6c62 <__divdi3+0x9c4>
    6c48:	80 17       	cp	r24, r16
    6c4a:	91 07       	cpc	r25, r17
    6c4c:	a2 07       	cpc	r26, r18
    6c4e:	b3 07       	cpc	r27, r19
    6c50:	40 f4       	brcc	.+16     	; 0x6c62 <__divdi3+0x9c4>
    6c52:	49 a5       	lds	r20, 0x69
    6c54:	5a a5       	lds	r21, 0x6a
    6c56:	6b a5       	lds	r22, 0x6b
    6c58:	7c a5       	lds	r23, 0x6c
    6c5a:	42 50       	subi	r20, 0x02	; 2
    6c5c:	50 40       	sbci	r21, 0x00	; 0
    6c5e:	60 40       	sbci	r22, 0x00	; 0
    6c60:	70 40       	sbci	r23, 0x00	; 0
    6c62:	09 a9       	sts	0x49, r16
    6c64:	1a a9       	sts	0x4a, r17
    6c66:	2b a9       	sts	0x4b, r18
    6c68:	3c a9       	sts	0x4c, r19
    6c6a:	78 01       	movw	r14, r16
    6c6c:	dd 24       	eor	r13, r13
    6c6e:	cc 24       	eor	r12, r12
    6c70:	c4 2a       	or	r12, r20
    6c72:	d5 2a       	or	r13, r21
    6c74:	e6 2a       	or	r14, r22
    6c76:	f7 2a       	or	r15, r23
    6c78:	50 c2       	rjmp	.+1184   	; 0x711a <__divdi3+0xe7c>
    6c7a:	c8 16       	cp	r12, r24
    6c7c:	d9 06       	cpc	r13, r25
    6c7e:	ea 06       	cpc	r14, r26
    6c80:	fb 06       	cpc	r15, r27
    6c82:	08 f4       	brcc	.+2      	; 0x6c86 <__divdi3+0x9e8>
    6c84:	37 c2       	rjmp	.+1134   	; 0x70f4 <__divdi3+0xe56>
    6c86:	80 30       	cpi	r24, 0x00	; 0
    6c88:	10 e0       	ldi	r17, 0x00	; 0
    6c8a:	91 07       	cpc	r25, r17
    6c8c:	11 e0       	ldi	r17, 0x01	; 1
    6c8e:	a1 07       	cpc	r26, r17
    6c90:	10 e0       	ldi	r17, 0x00	; 0
    6c92:	b1 07       	cpc	r27, r17
    6c94:	50 f4       	brcc	.+20     	; 0x6caa <__divdi3+0xa0c>
    6c96:	8f 3f       	cpi	r24, 0xFF	; 255
    6c98:	91 05       	cpc	r25, r1
    6c9a:	a1 05       	cpc	r26, r1
    6c9c:	b1 05       	cpc	r27, r1
    6c9e:	09 f0       	breq	.+2      	; 0x6ca2 <__divdi3+0xa04>
    6ca0:	88 f4       	brcc	.+34     	; 0x6cc4 <__divdi3+0xa26>
    6ca2:	00 e0       	ldi	r16, 0x00	; 0
    6ca4:	10 e0       	ldi	r17, 0x00	; 0
    6ca6:	98 01       	movw	r18, r16
    6ca8:	16 c0       	rjmp	.+44     	; 0x6cd6 <__divdi3+0xa38>
    6caa:	80 30       	cpi	r24, 0x00	; 0
    6cac:	20 e0       	ldi	r18, 0x00	; 0
    6cae:	92 07       	cpc	r25, r18
    6cb0:	20 e0       	ldi	r18, 0x00	; 0
    6cb2:	a2 07       	cpc	r26, r18
    6cb4:	21 e0       	ldi	r18, 0x01	; 1
    6cb6:	b2 07       	cpc	r27, r18
    6cb8:	50 f4       	brcc	.+20     	; 0x6cce <__divdi3+0xa30>
    6cba:	00 e1       	ldi	r16, 0x10	; 16
    6cbc:	10 e0       	ldi	r17, 0x00	; 0
    6cbe:	20 e0       	ldi	r18, 0x00	; 0
    6cc0:	30 e0       	ldi	r19, 0x00	; 0
    6cc2:	09 c0       	rjmp	.+18     	; 0x6cd6 <__divdi3+0xa38>
    6cc4:	08 e0       	ldi	r16, 0x08	; 8
    6cc6:	10 e0       	ldi	r17, 0x00	; 0
    6cc8:	20 e0       	ldi	r18, 0x00	; 0
    6cca:	30 e0       	ldi	r19, 0x00	; 0
    6ccc:	04 c0       	rjmp	.+8      	; 0x6cd6 <__divdi3+0xa38>
    6cce:	08 e1       	ldi	r16, 0x18	; 24
    6cd0:	10 e0       	ldi	r17, 0x00	; 0
    6cd2:	20 e0       	ldi	r18, 0x00	; 0
    6cd4:	30 e0       	ldi	r19, 0x00	; 0
    6cd6:	ac 01       	movw	r20, r24
    6cd8:	bd 01       	movw	r22, r26
    6cda:	00 2e       	mov	r0, r16
    6cdc:	04 c0       	rjmp	.+8      	; 0x6ce6 <__divdi3+0xa48>
    6cde:	76 95       	lsr	r23
    6ce0:	67 95       	ror	r22
    6ce2:	57 95       	ror	r21
    6ce4:	47 95       	ror	r20
    6ce6:	0a 94       	dec	r0
    6ce8:	d2 f7       	brpl	.-12     	; 0x6cde <__divdi3+0xa40>
    6cea:	fa 01       	movw	r30, r20
    6cec:	e9 5c       	subi	r30, 0xC9	; 201
    6cee:	ff 4d       	sbci	r31, 0xDF	; 223
    6cf0:	40 81       	ld	r20, Z
    6cf2:	04 0f       	add	r16, r20
    6cf4:	11 1d       	adc	r17, r1
    6cf6:	21 1d       	adc	r18, r1
    6cf8:	31 1d       	adc	r19, r1
    6cfa:	40 e2       	ldi	r20, 0x20	; 32
    6cfc:	50 e0       	ldi	r21, 0x00	; 0
    6cfe:	60 e0       	ldi	r22, 0x00	; 0
    6d00:	70 e0       	ldi	r23, 0x00	; 0
    6d02:	40 1b       	sub	r20, r16
    6d04:	51 0b       	sbc	r21, r17
    6d06:	62 0b       	sbc	r22, r18
    6d08:	73 0b       	sbc	r23, r19
    6d0a:	a1 f4       	brne	.+40     	; 0x6d34 <__divdi3+0xa96>
    6d0c:	8c 15       	cp	r24, r12
    6d0e:	9d 05       	cpc	r25, r13
    6d10:	ae 05       	cpc	r26, r14
    6d12:	bf 05       	cpc	r27, r15
    6d14:	08 f4       	brcc	.+2      	; 0x6d18 <__divdi3+0xa7a>
    6d16:	f5 c1       	rjmp	.+1002   	; 0x7102 <__divdi3+0xe64>
    6d18:	ed a8       	sts	0x8d, r30
    6d1a:	fe a8       	sts	0x8e, r31
    6d1c:	0f a9       	sts	0x4f, r16
    6d1e:	18 ad       	sts	0x68, r17
    6d20:	44 24       	eor	r4, r4
    6d22:	55 24       	eor	r5, r5
    6d24:	32 01       	movw	r6, r4
    6d26:	e8 14       	cp	r14, r8
    6d28:	f9 04       	cpc	r15, r9
    6d2a:	0a 05       	cpc	r16, r10
    6d2c:	1b 05       	cpc	r17, r11
    6d2e:	08 f0       	brcs	.+2      	; 0x6d32 <__divdi3+0xa94>
    6d30:	eb c1       	rjmp	.+982    	; 0x7108 <__divdi3+0xe6a>
    6d32:	e3 c1       	rjmp	.+966    	; 0x70fa <__divdi3+0xe5c>
    6d34:	34 2e       	mov	r3, r20
    6d36:	2c 01       	movw	r4, r24
    6d38:	3d 01       	movw	r6, r26
    6d3a:	04 c0       	rjmp	.+8      	; 0x6d44 <__divdi3+0xaa6>
    6d3c:	44 0c       	add	r4, r4
    6d3e:	55 1c       	adc	r5, r5
    6d40:	66 1c       	adc	r6, r6
    6d42:	77 1c       	adc	r7, r7
    6d44:	4a 95       	dec	r20
    6d46:	d2 f7       	brpl	.-12     	; 0x6d3c <__divdi3+0xa9e>
    6d48:	d5 01       	movw	r26, r10
    6d4a:	c4 01       	movw	r24, r8
    6d4c:	00 2e       	mov	r0, r16
    6d4e:	04 c0       	rjmp	.+8      	; 0x6d58 <__divdi3+0xaba>
    6d50:	b6 95       	lsr	r27
    6d52:	a7 95       	ror	r26
    6d54:	97 95       	ror	r25
    6d56:	87 95       	ror	r24
    6d58:	0a 94       	dec	r0
    6d5a:	d2 f7       	brpl	.-12     	; 0x6d50 <__divdi3+0xab2>
    6d5c:	48 2a       	or	r4, r24
    6d5e:	59 2a       	or	r5, r25
    6d60:	6a 2a       	or	r6, r26
    6d62:	7b 2a       	or	r7, r27
    6d64:	a5 01       	movw	r20, r10
    6d66:	94 01       	movw	r18, r8
    6d68:	03 2c       	mov	r0, r3
    6d6a:	04 c0       	rjmp	.+8      	; 0x6d74 <__divdi3+0xad6>
    6d6c:	22 0f       	add	r18, r18
    6d6e:	33 1f       	adc	r19, r19
    6d70:	44 1f       	adc	r20, r20
    6d72:	55 1f       	adc	r21, r21
    6d74:	0a 94       	dec	r0
    6d76:	d2 f7       	brpl	.-12     	; 0x6d6c <__divdi3+0xace>
    6d78:	29 af       	sts	0x79, r18
    6d7a:	3a af       	sts	0x7a, r19
    6d7c:	4b af       	sts	0x7b, r20
    6d7e:	5c af       	sts	0x7c, r21
    6d80:	b7 01       	movw	r22, r14
    6d82:	a6 01       	movw	r20, r12
    6d84:	00 2e       	mov	r0, r16
    6d86:	04 c0       	rjmp	.+8      	; 0x6d90 <__divdi3+0xaf2>
    6d88:	76 95       	lsr	r23
    6d8a:	67 95       	ror	r22
    6d8c:	57 95       	ror	r21
    6d8e:	47 95       	ror	r20
    6d90:	0a 94       	dec	r0
    6d92:	d2 f7       	brpl	.-12     	; 0x6d88 <__divdi3+0xaea>
    6d94:	49 ab       	sts	0x59, r20
    6d96:	5a ab       	sts	0x5a, r21
    6d98:	6b ab       	sts	0x5b, r22
    6d9a:	7c ab       	sts	0x5c, r23
    6d9c:	c7 01       	movw	r24, r14
    6d9e:	b6 01       	movw	r22, r12
    6da0:	03 2c       	mov	r0, r3
    6da2:	04 c0       	rjmp	.+8      	; 0x6dac <__divdi3+0xb0e>
    6da4:	66 0f       	add	r22, r22
    6da6:	77 1f       	adc	r23, r23
    6da8:	88 1f       	adc	r24, r24
    6daa:	99 1f       	adc	r25, r25
    6dac:	0a 94       	dec	r0
    6dae:	d2 f7       	brpl	.-12     	; 0x6da4 <__divdi3+0xb06>
    6db0:	6d a7       	lds	r22, 0x7d
    6db2:	7e a7       	lds	r23, 0x7e
    6db4:	8f a7       	lds	r24, 0x7f
    6db6:	98 ab       	sts	0x58, r25
    6db8:	8d a9       	sts	0x4d, r24
    6dba:	9e a9       	sts	0x4e, r25
    6dbc:	af a9       	sts	0x4f, r26
    6dbe:	b8 ad       	sts	0x68, r27
    6dc0:	04 c0       	rjmp	.+8      	; 0x6dca <__divdi3+0xb2c>
    6dc2:	b6 95       	lsr	r27
    6dc4:	a7 95       	ror	r26
    6dc6:	97 95       	ror	r25
    6dc8:	87 95       	ror	r24
    6dca:	0a 95       	dec	r16
    6dcc:	d2 f7       	brpl	.-12     	; 0x6dc2 <__divdi3+0xb24>
    6dce:	4d a5       	lds	r20, 0x6d
    6dd0:	5e a5       	lds	r21, 0x6e
    6dd2:	6f a5       	lds	r22, 0x6f
    6dd4:	78 a9       	sts	0x48, r23
    6dd6:	48 2b       	or	r20, r24
    6dd8:	59 2b       	or	r21, r25
    6dda:	6a 2b       	or	r22, r26
    6ddc:	7b 2b       	or	r23, r27
    6dde:	4d a7       	lds	r20, 0x7d
    6de0:	5e a7       	lds	r21, 0x7e
    6de2:	6f a7       	lds	r22, 0x7f
    6de4:	78 ab       	sts	0x58, r23
    6de6:	43 01       	movw	r8, r6
    6de8:	aa 24       	eor	r10, r10
    6dea:	bb 24       	eor	r11, r11
    6dec:	93 01       	movw	r18, r6
    6dee:	82 01       	movw	r16, r4
    6df0:	20 70       	andi	r18, 0x00	; 0
    6df2:	30 70       	andi	r19, 0x00	; 0
    6df4:	21 96       	adiw	r28, 0x01	; 1
    6df6:	0c af       	sts	0x7c, r16
    6df8:	1d af       	sts	0x7d, r17
    6dfa:	2e af       	sts	0x7e, r18
    6dfc:	3f af       	sts	0x7f, r19
    6dfe:	21 97       	sbiw	r28, 0x01	; 1
    6e00:	69 a9       	sts	0x49, r22
    6e02:	7a a9       	sts	0x4a, r23
    6e04:	8b a9       	sts	0x4b, r24
    6e06:	9c a9       	sts	0x4c, r25
    6e08:	a5 01       	movw	r20, r10
    6e0a:	94 01       	movw	r18, r8
    6e0c:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6e10:	29 a7       	lds	r18, 0x79
    6e12:	3a a7       	lds	r19, 0x7a
    6e14:	4b a7       	lds	r20, 0x7b
    6e16:	5c a7       	lds	r21, 0x7c
    6e18:	6b 01       	movw	r12, r22
    6e1a:	7c 01       	movw	r14, r24
    6e1c:	69 a9       	sts	0x49, r22
    6e1e:	7a a9       	sts	0x4a, r23
    6e20:	8b a9       	sts	0x4b, r24
    6e22:	9c a9       	sts	0x4c, r25
    6e24:	a5 01       	movw	r20, r10
    6e26:	94 01       	movw	r18, r8
    6e28:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6e2c:	ca 01       	movw	r24, r20
    6e2e:	b9 01       	movw	r22, r18
    6e30:	21 96       	adiw	r28, 0x01	; 1
    6e32:	2c ad       	sts	0x6c, r18
    6e34:	3d ad       	sts	0x6d, r19
    6e36:	4e ad       	sts	0x6e, r20
    6e38:	5f ad       	sts	0x6f, r21
    6e3a:	21 97       	sbiw	r28, 0x01	; 1
    6e3c:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6e40:	dc 01       	movw	r26, r24
    6e42:	cb 01       	movw	r24, r22
    6e44:	76 01       	movw	r14, r12
    6e46:	dd 24       	eor	r13, r13
    6e48:	cc 24       	eor	r12, r12
    6e4a:	0d a5       	lds	r16, 0x6d
    6e4c:	1e a5       	lds	r17, 0x6e
    6e4e:	2f a5       	lds	r18, 0x6f
    6e50:	38 a9       	sts	0x48, r19
    6e52:	a9 01       	movw	r20, r18
    6e54:	66 27       	eor	r22, r22
    6e56:	77 27       	eor	r23, r23
    6e58:	c4 2a       	or	r12, r20
    6e5a:	d5 2a       	or	r13, r21
    6e5c:	e6 2a       	or	r14, r22
    6e5e:	f7 2a       	or	r15, r23
    6e60:	09 a5       	lds	r16, 0x69
    6e62:	1a a5       	lds	r17, 0x6a
    6e64:	2b a5       	lds	r18, 0x6b
    6e66:	3c a5       	lds	r19, 0x6c
    6e68:	c8 16       	cp	r12, r24
    6e6a:	d9 06       	cpc	r13, r25
    6e6c:	ea 06       	cpc	r14, r26
    6e6e:	fb 06       	cpc	r15, r27
    6e70:	38 f5       	brcc	.+78     	; 0x6ec0 <__divdi3+0xc22>
    6e72:	01 50       	subi	r16, 0x01	; 1
    6e74:	10 40       	sbci	r17, 0x00	; 0
    6e76:	20 40       	sbci	r18, 0x00	; 0
    6e78:	30 40       	sbci	r19, 0x00	; 0
    6e7a:	09 ab       	sts	0x59, r16
    6e7c:	1a ab       	sts	0x5a, r17
    6e7e:	2b ab       	sts	0x5b, r18
    6e80:	3c ab       	sts	0x5c, r19
    6e82:	c4 0c       	add	r12, r4
    6e84:	d5 1c       	adc	r13, r5
    6e86:	e6 1c       	adc	r14, r6
    6e88:	f7 1c       	adc	r15, r7
    6e8a:	c4 14       	cp	r12, r4
    6e8c:	d5 04       	cpc	r13, r5
    6e8e:	e6 04       	cpc	r14, r6
    6e90:	f7 04       	cpc	r15, r7
    6e92:	d0 f0       	brcs	.+52     	; 0x6ec8 <__divdi3+0xc2a>
    6e94:	c8 16       	cp	r12, r24
    6e96:	d9 06       	cpc	r13, r25
    6e98:	ea 06       	cpc	r14, r26
    6e9a:	fb 06       	cpc	r15, r27
    6e9c:	a8 f4       	brcc	.+42     	; 0x6ec8 <__divdi3+0xc2a>
    6e9e:	09 a5       	lds	r16, 0x69
    6ea0:	1a a5       	lds	r17, 0x6a
    6ea2:	2b a5       	lds	r18, 0x6b
    6ea4:	3c a5       	lds	r19, 0x6c
    6ea6:	02 50       	subi	r16, 0x02	; 2
    6ea8:	10 40       	sbci	r17, 0x00	; 0
    6eaa:	20 40       	sbci	r18, 0x00	; 0
    6eac:	30 40       	sbci	r19, 0x00	; 0
    6eae:	09 ab       	sts	0x59, r16
    6eb0:	1a ab       	sts	0x5a, r17
    6eb2:	2b ab       	sts	0x5b, r18
    6eb4:	3c ab       	sts	0x5c, r19
    6eb6:	c4 0c       	add	r12, r4
    6eb8:	d5 1c       	adc	r13, r5
    6eba:	e6 1c       	adc	r14, r6
    6ebc:	f7 1c       	adc	r15, r7
    6ebe:	04 c0       	rjmp	.+8      	; 0x6ec8 <__divdi3+0xc2a>
    6ec0:	09 ab       	sts	0x59, r16
    6ec2:	1a ab       	sts	0x5a, r17
    6ec4:	2b ab       	sts	0x5b, r18
    6ec6:	3c ab       	sts	0x5c, r19
    6ec8:	c8 1a       	sub	r12, r24
    6eca:	d9 0a       	sbc	r13, r25
    6ecc:	ea 0a       	sbc	r14, r26
    6ece:	fb 0a       	sbc	r15, r27
    6ed0:	c7 01       	movw	r24, r14
    6ed2:	b6 01       	movw	r22, r12
    6ed4:	a5 01       	movw	r20, r10
    6ed6:	94 01       	movw	r18, r8
    6ed8:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6edc:	29 a7       	lds	r18, 0x79
    6ede:	3a a7       	lds	r19, 0x7a
    6ee0:	4b a7       	lds	r20, 0x7b
    6ee2:	5c a7       	lds	r21, 0x7c
    6ee4:	29 96       	adiw	r28, 0x09	; 9
    6ee6:	6c af       	sts	0x7c, r22
    6ee8:	7d af       	sts	0x7d, r23
    6eea:	8e af       	sts	0x7e, r24
    6eec:	9f af       	sts	0x7f, r25
    6eee:	29 97       	sbiw	r28, 0x09	; 9
    6ef0:	c7 01       	movw	r24, r14
    6ef2:	b6 01       	movw	r22, r12
    6ef4:	a5 01       	movw	r20, r10
    6ef6:	94 01       	movw	r18, r8
    6ef8:	0e 94 00 3b 	call	0x7600	; 0x7600 <__udivmodsi4>
    6efc:	ca 01       	movw	r24, r20
    6efe:	b9 01       	movw	r22, r18
    6f00:	21 96       	adiw	r28, 0x01	; 1
    6f02:	2c ad       	sts	0x6c, r18
    6f04:	3d ad       	sts	0x6d, r19
    6f06:	4e ad       	sts	0x6e, r20
    6f08:	5f ad       	sts	0x6f, r21
    6f0a:	21 97       	sbiw	r28, 0x01	; 1
    6f0c:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    6f10:	4b 01       	movw	r8, r22
    6f12:	5c 01       	movw	r10, r24
    6f14:	29 96       	adiw	r28, 0x09	; 9
    6f16:	4c ad       	sts	0x6c, r20
    6f18:	5d ad       	sts	0x6d, r21
    6f1a:	6e ad       	sts	0x6e, r22
    6f1c:	7f ad       	sts	0x6f, r23
    6f1e:	29 97       	sbiw	r28, 0x09	; 9
    6f20:	9a 01       	movw	r18, r20
    6f22:	11 27       	eor	r17, r17
    6f24:	00 27       	eor	r16, r16
    6f26:	8d a5       	lds	r24, 0x6d
    6f28:	9e a5       	lds	r25, 0x6e
    6f2a:	af a5       	lds	r26, 0x6f
    6f2c:	b8 a9       	sts	0x48, r27
    6f2e:	a0 70       	andi	r26, 0x00	; 0
    6f30:	b0 70       	andi	r27, 0x00	; 0
    6f32:	08 2b       	or	r16, r24
    6f34:	19 2b       	or	r17, r25
    6f36:	2a 2b       	or	r18, r26
    6f38:	3b 2b       	or	r19, r27
    6f3a:	89 a5       	lds	r24, 0x69
    6f3c:	9a a5       	lds	r25, 0x6a
    6f3e:	ab a5       	lds	r26, 0x6b
    6f40:	bc a5       	lds	r27, 0x6c
    6f42:	08 15       	cp	r16, r8
    6f44:	19 05       	cpc	r17, r9
    6f46:	2a 05       	cpc	r18, r10
    6f48:	3b 05       	cpc	r19, r11
    6f4a:	e0 f4       	brcc	.+56     	; 0x6f84 <__divdi3+0xce6>
    6f4c:	01 97       	sbiw	r24, 0x01	; 1
    6f4e:	a1 09       	sbc	r26, r1
    6f50:	b1 09       	sbc	r27, r1
    6f52:	04 0d       	add	r16, r4
    6f54:	15 1d       	adc	r17, r5
    6f56:	26 1d       	adc	r18, r6
    6f58:	37 1d       	adc	r19, r7
    6f5a:	04 15       	cp	r16, r4
    6f5c:	15 05       	cpc	r17, r5
    6f5e:	26 05       	cpc	r18, r6
    6f60:	37 05       	cpc	r19, r7
    6f62:	80 f0       	brcs	.+32     	; 0x6f84 <__divdi3+0xce6>
    6f64:	08 15       	cp	r16, r8
    6f66:	19 05       	cpc	r17, r9
    6f68:	2a 05       	cpc	r18, r10
    6f6a:	3b 05       	cpc	r19, r11
    6f6c:	58 f4       	brcc	.+22     	; 0x6f84 <__divdi3+0xce6>
    6f6e:	89 a5       	lds	r24, 0x69
    6f70:	9a a5       	lds	r25, 0x6a
    6f72:	ab a5       	lds	r26, 0x6b
    6f74:	bc a5       	lds	r27, 0x6c
    6f76:	02 97       	sbiw	r24, 0x02	; 2
    6f78:	a1 09       	sbc	r26, r1
    6f7a:	b1 09       	sbc	r27, r1
    6f7c:	04 0d       	add	r16, r4
    6f7e:	15 1d       	adc	r17, r5
    6f80:	26 1d       	adc	r18, r6
    6f82:	37 1d       	adc	r19, r7
    6f84:	b9 01       	movw	r22, r18
    6f86:	a8 01       	movw	r20, r16
    6f88:	48 19       	sub	r20, r8
    6f8a:	59 09       	sbc	r21, r9
    6f8c:	6a 09       	sbc	r22, r10
    6f8e:	7b 09       	sbc	r23, r11
    6f90:	4d a7       	lds	r20, 0x7d
    6f92:	5e a7       	lds	r21, 0x7e
    6f94:	6f a7       	lds	r22, 0x7f
    6f96:	78 ab       	sts	0x58, r23
    6f98:	09 a9       	sts	0x49, r16
    6f9a:	1a a9       	sts	0x4a, r17
    6f9c:	2b a9       	sts	0x4b, r18
    6f9e:	3c a9       	sts	0x4c, r19
    6fa0:	78 01       	movw	r14, r16
    6fa2:	dd 24       	eor	r13, r13
    6fa4:	cc 24       	eor	r12, r12
    6fa6:	c8 2a       	or	r12, r24
    6fa8:	d9 2a       	or	r13, r25
    6faa:	ea 2a       	or	r14, r26
    6fac:	fb 2a       	or	r15, r27
    6fae:	ff ef       	ldi	r31, 0xFF	; 255
    6fb0:	8f 2e       	mov	r8, r31
    6fb2:	ff ef       	ldi	r31, 0xFF	; 255
    6fb4:	9f 2e       	mov	r9, r31
    6fb6:	a1 2c       	mov	r10, r1
    6fb8:	b1 2c       	mov	r11, r1
    6fba:	8c 20       	and	r8, r12
    6fbc:	9d 20       	and	r9, r13
    6fbe:	ae 20       	and	r10, r14
    6fc0:	bf 20       	and	r11, r15
    6fc2:	87 01       	movw	r16, r14
    6fc4:	22 27       	eor	r18, r18
    6fc6:	33 27       	eor	r19, r19
    6fc8:	09 a7       	lds	r16, 0x79
    6fca:	1a a7       	lds	r17, 0x7a
    6fcc:	2b a7       	lds	r18, 0x7b
    6fce:	3c a7       	lds	r19, 0x7c
    6fd0:	49 ac       	sts	0xa9, r20
    6fd2:	5a ac       	sts	0xaa, r21
    6fd4:	6b ac       	sts	0xab, r22
    6fd6:	7c ac       	sts	0xac, r23
    6fd8:	2f ef       	ldi	r18, 0xFF	; 255
    6fda:	3f ef       	ldi	r19, 0xFF	; 255
    6fdc:	40 e0       	ldi	r20, 0x00	; 0
    6fde:	50 e0       	ldi	r21, 0x00	; 0
    6fe0:	42 22       	and	r4, r18
    6fe2:	53 22       	and	r5, r19
    6fe4:	64 22       	and	r6, r20
    6fe6:	75 22       	and	r7, r21
    6fe8:	29 ad       	sts	0x69, r18
    6fea:	3a ad       	sts	0x6a, r19
    6fec:	4b ad       	sts	0x6b, r20
    6fee:	5c ad       	sts	0x6c, r21
    6ff0:	8a 01       	movw	r16, r20
    6ff2:	22 27       	eor	r18, r18
    6ff4:	33 27       	eor	r19, r19
    6ff6:	09 ab       	sts	0x59, r16
    6ff8:	1a ab       	sts	0x5a, r17
    6ffa:	2b ab       	sts	0x5b, r18
    6ffc:	3c ab       	sts	0x5c, r19
    6ffe:	c5 01       	movw	r24, r10
    7000:	b4 01       	movw	r22, r8
    7002:	a3 01       	movw	r20, r6
    7004:	92 01       	movw	r18, r4
    7006:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    700a:	69 af       	sts	0x79, r22
    700c:	7a af       	sts	0x7a, r23
    700e:	8b af       	sts	0x7b, r24
    7010:	9c af       	sts	0x7c, r25
    7012:	c5 01       	movw	r24, r10
    7014:	b4 01       	movw	r22, r8
    7016:	29 a9       	sts	0x49, r18
    7018:	3a a9       	sts	0x4a, r19
    701a:	4b a9       	sts	0x4b, r20
    701c:	5c a9       	sts	0x4c, r21
    701e:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    7022:	4b 01       	movw	r8, r22
    7024:	5c 01       	movw	r10, r24
    7026:	69 a5       	lds	r22, 0x69
    7028:	7a a5       	lds	r23, 0x6a
    702a:	8b a5       	lds	r24, 0x6b
    702c:	9c a5       	lds	r25, 0x6c
    702e:	a3 01       	movw	r20, r6
    7030:	92 01       	movw	r18, r4
    7032:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    7036:	2b 01       	movw	r4, r22
    7038:	3c 01       	movw	r6, r24
    703a:	69 a5       	lds	r22, 0x69
    703c:	7a a5       	lds	r23, 0x6a
    703e:	8b a5       	lds	r24, 0x6b
    7040:	9c a5       	lds	r25, 0x6c
    7042:	29 a9       	sts	0x49, r18
    7044:	3a a9       	sts	0x4a, r19
    7046:	4b a9       	sts	0x4b, r20
    7048:	5c a9       	sts	0x4c, r21
    704a:	0e 94 ba 3a 	call	0x7574	; 0x7574 <__mulsi3>
    704e:	ab 01       	movw	r20, r22
    7050:	bc 01       	movw	r22, r24
    7052:	84 0c       	add	r8, r4
    7054:	95 1c       	adc	r9, r5
    7056:	a6 1c       	adc	r10, r6
    7058:	b7 1c       	adc	r11, r7
    705a:	09 ad       	sts	0x69, r16
    705c:	1a ad       	sts	0x6a, r17
    705e:	2b ad       	sts	0x6b, r18
    7060:	3c ad       	sts	0x6c, r19
    7062:	c9 01       	movw	r24, r18
    7064:	aa 27       	eor	r26, r26
    7066:	bb 27       	eor	r27, r27
    7068:	88 0e       	add	r8, r24
    706a:	99 1e       	adc	r9, r25
    706c:	aa 1e       	adc	r10, r26
    706e:	bb 1e       	adc	r11, r27
    7070:	84 14       	cp	r8, r4
    7072:	95 04       	cpc	r9, r5
    7074:	a6 04       	cpc	r10, r6
    7076:	b7 04       	cpc	r11, r7
    7078:	20 f4       	brcc	.+8      	; 0x7082 <__divdi3+0xde4>
    707a:	40 50       	subi	r20, 0x00	; 0
    707c:	50 40       	sbci	r21, 0x00	; 0
    707e:	6f 4f       	sbci	r22, 0xFF	; 255
    7080:	7f 4f       	sbci	r23, 0xFF	; 255
    7082:	c5 01       	movw	r24, r10
    7084:	aa 27       	eor	r26, r26
    7086:	bb 27       	eor	r27, r27
    7088:	84 0f       	add	r24, r20
    708a:	95 1f       	adc	r25, r21
    708c:	a6 1f       	adc	r26, r22
    708e:	b7 1f       	adc	r27, r23
    7090:	0d a5       	lds	r16, 0x6d
    7092:	1e a5       	lds	r17, 0x6e
    7094:	2f a5       	lds	r18, 0x6f
    7096:	38 a9       	sts	0x48, r19
    7098:	08 17       	cp	r16, r24
    709a:	19 07       	cpc	r17, r25
    709c:	2a 07       	cpc	r18, r26
    709e:	3b 07       	cpc	r19, r27
    70a0:	18 f1       	brcs	.+70     	; 0x70e8 <__divdi3+0xe4a>
    70a2:	80 17       	cp	r24, r16
    70a4:	91 07       	cpc	r25, r17
    70a6:	a2 07       	cpc	r26, r18
    70a8:	b3 07       	cpc	r27, r19
    70aa:	a1 f5       	brne	.+104    	; 0x7114 <__divdi3+0xe76>
    70ac:	54 01       	movw	r10, r8
    70ae:	99 24       	eor	r9, r9
    70b0:	88 24       	eor	r8, r8
    70b2:	89 ad       	sts	0x69, r24
    70b4:	9a ad       	sts	0x6a, r25
    70b6:	ab ad       	sts	0x6b, r26
    70b8:	bc ad       	sts	0x6c, r27
    70ba:	a0 70       	andi	r26, 0x00	; 0
    70bc:	b0 70       	andi	r27, 0x00	; 0
    70be:	88 0e       	add	r8, r24
    70c0:	99 1e       	adc	r9, r25
    70c2:	aa 1e       	adc	r10, r26
    70c4:	bb 1e       	adc	r11, r27
    70c6:	4d a9       	sts	0x4d, r20
    70c8:	5e a9       	sts	0x4e, r21
    70ca:	6f a9       	sts	0x4f, r22
    70cc:	78 ad       	sts	0x68, r23
    70ce:	03 2c       	mov	r0, r3
    70d0:	04 c0       	rjmp	.+8      	; 0x70da <__divdi3+0xe3c>
    70d2:	44 0f       	add	r20, r20
    70d4:	55 1f       	adc	r21, r21
    70d6:	66 1f       	adc	r22, r22
    70d8:	77 1f       	adc	r23, r23
    70da:	0a 94       	dec	r0
    70dc:	d2 f7       	brpl	.-12     	; 0x70d2 <__divdi3+0xe34>
    70de:	48 15       	cp	r20, r8
    70e0:	59 05       	cpc	r21, r9
    70e2:	6a 05       	cpc	r22, r10
    70e4:	7b 05       	cpc	r23, r11
    70e6:	b0 f4       	brcc	.+44     	; 0x7114 <__divdi3+0xe76>
    70e8:	08 94       	sec
    70ea:	c1 08       	sbc	r12, r1
    70ec:	d1 08       	sbc	r13, r1
    70ee:	e1 08       	sbc	r14, r1
    70f0:	f1 08       	sbc	r15, r1
    70f2:	10 c0       	rjmp	.+32     	; 0x7114 <__divdi3+0xe76>
    70f4:	44 24       	eor	r4, r4
    70f6:	55 24       	eor	r5, r5
    70f8:	32 01       	movw	r6, r4
    70fa:	cc 24       	eor	r12, r12
    70fc:	dd 24       	eor	r13, r13
    70fe:	76 01       	movw	r14, r12
    7100:	0c c0       	rjmp	.+24     	; 0x711a <__divdi3+0xe7c>
    7102:	44 24       	eor	r4, r4
    7104:	55 24       	eor	r5, r5
    7106:	32 01       	movw	r6, r4
    7108:	81 e0       	ldi	r24, 0x01	; 1
    710a:	c8 2e       	mov	r12, r24
    710c:	d1 2c       	mov	r13, r1
    710e:	e1 2c       	mov	r14, r1
    7110:	f1 2c       	mov	r15, r1
    7112:	03 c0       	rjmp	.+6      	; 0x711a <__divdi3+0xe7c>
    7114:	44 24       	eor	r4, r4
    7116:	55 24       	eor	r5, r5
    7118:	32 01       	movw	r6, r4
    711a:	fe 01       	movw	r30, r28
    711c:	31 96       	adiw	r30, 0x01	; 1
    711e:	88 e0       	ldi	r24, 0x08	; 8
    7120:	df 01       	movw	r26, r30
    7122:	1d 92       	st	X+, r1
    7124:	8a 95       	dec	r24
    7126:	e9 f7       	brne	.-6      	; 0x7122 <__divdi3+0xe84>
    7128:	c9 82       	std	Y+1, r12	; 0x01
    712a:	da 82       	std	Y+2, r13	; 0x02
    712c:	eb 82       	std	Y+3, r14	; 0x03
    712e:	fc 82       	std	Y+4, r15	; 0x04
    7130:	4d 82       	std	Y+5, r4	; 0x05
    7132:	5e 82       	std	Y+6, r5	; 0x06
    7134:	6f 82       	std	Y+7, r6	; 0x07
    7136:	78 86       	std	Y+8, r7	; 0x08
    7138:	2c 2d       	mov	r18, r12
    713a:	3a 81       	ldd	r19, Y+2	; 0x02
    713c:	4b 81       	ldd	r20, Y+3	; 0x03
    713e:	5c 81       	ldd	r21, Y+4	; 0x04
    7140:	64 2d       	mov	r22, r4
    7142:	7e 81       	ldd	r23, Y+6	; 0x06
    7144:	8f 81       	ldd	r24, Y+7	; 0x07
    7146:	98 85       	ldd	r25, Y+8	; 0x08
    7148:	25 96       	adiw	r28, 0x05	; 5
    714a:	ec ac       	sts	0xac, r30
    714c:	fd ac       	sts	0xad, r31
    714e:	0e ad       	sts	0x6e, r16
    7150:	1f ad       	sts	0x6f, r17
    7152:	25 97       	sbiw	r28, 0x05	; 5
    7154:	e1 14       	cp	r14, r1
    7156:	f1 04       	cpc	r15, r1
    7158:	01 05       	cpc	r16, r1
    715a:	11 05       	cpc	r17, r1
    715c:	09 f4       	brne	.+2      	; 0x7160 <__divdi3+0xec2>
    715e:	56 c0       	rjmp	.+172    	; 0x720c <__divdi3+0xf6e>
    7160:	21 95       	neg	r18
    7162:	e1 e0       	ldi	r30, 0x01	; 1
    7164:	12 16       	cp	r1, r18
    7166:	08 f0       	brcs	.+2      	; 0x716a <__divdi3+0xecc>
    7168:	e0 e0       	ldi	r30, 0x00	; 0
    716a:	31 95       	neg	r19
    716c:	f1 e0       	ldi	r31, 0x01	; 1
    716e:	13 16       	cp	r1, r19
    7170:	08 f0       	brcs	.+2      	; 0x7174 <__divdi3+0xed6>
    7172:	f0 e0       	ldi	r31, 0x00	; 0
    7174:	03 2f       	mov	r16, r19
    7176:	0e 1b       	sub	r16, r30
    7178:	e1 e0       	ldi	r30, 0x01	; 1
    717a:	30 17       	cp	r19, r16
    717c:	08 f0       	brcs	.+2      	; 0x7180 <__divdi3+0xee2>
    717e:	e0 e0       	ldi	r30, 0x00	; 0
    7180:	fe 2b       	or	r31, r30
    7182:	41 95       	neg	r20
    7184:	e1 e0       	ldi	r30, 0x01	; 1
    7186:	14 16       	cp	r1, r20
    7188:	08 f0       	brcs	.+2      	; 0x718c <__divdi3+0xeee>
    718a:	e0 e0       	ldi	r30, 0x00	; 0
    718c:	14 2f       	mov	r17, r20
    718e:	1f 1b       	sub	r17, r31
    7190:	31 e0       	ldi	r19, 0x01	; 1
    7192:	41 17       	cp	r20, r17
    7194:	08 f0       	brcs	.+2      	; 0x7198 <__divdi3+0xefa>
    7196:	30 e0       	ldi	r19, 0x00	; 0
    7198:	e3 2b       	or	r30, r19
    719a:	51 95       	neg	r21
    719c:	f1 e0       	ldi	r31, 0x01	; 1
    719e:	15 16       	cp	r1, r21
    71a0:	08 f0       	brcs	.+2      	; 0x71a4 <__divdi3+0xf06>
    71a2:	f0 e0       	ldi	r31, 0x00	; 0
    71a4:	b5 2f       	mov	r27, r21
    71a6:	be 1b       	sub	r27, r30
    71a8:	31 e0       	ldi	r19, 0x01	; 1
    71aa:	5b 17       	cp	r21, r27
    71ac:	08 f0       	brcs	.+2      	; 0x71b0 <__divdi3+0xf12>
    71ae:	30 e0       	ldi	r19, 0x00	; 0
    71b0:	f3 2b       	or	r31, r19
    71b2:	61 95       	neg	r22
    71b4:	e1 e0       	ldi	r30, 0x01	; 1
    71b6:	16 16       	cp	r1, r22
    71b8:	08 f0       	brcs	.+2      	; 0x71bc <__divdi3+0xf1e>
    71ba:	e0 e0       	ldi	r30, 0x00	; 0
    71bc:	46 2e       	mov	r4, r22
    71be:	4f 1a       	sub	r4, r31
    71c0:	31 e0       	ldi	r19, 0x01	; 1
    71c2:	64 15       	cp	r22, r4
    71c4:	08 f0       	brcs	.+2      	; 0x71c8 <__divdi3+0xf2a>
    71c6:	30 e0       	ldi	r19, 0x00	; 0
    71c8:	e3 2b       	or	r30, r19
    71ca:	71 95       	neg	r23
    71cc:	f1 e0       	ldi	r31, 0x01	; 1
    71ce:	17 16       	cp	r1, r23
    71d0:	08 f0       	brcs	.+2      	; 0x71d4 <__divdi3+0xf36>
    71d2:	f0 e0       	ldi	r31, 0x00	; 0
    71d4:	a7 2f       	mov	r26, r23
    71d6:	ae 1b       	sub	r26, r30
    71d8:	31 e0       	ldi	r19, 0x01	; 1
    71da:	7a 17       	cp	r23, r26
    71dc:	08 f0       	brcs	.+2      	; 0x71e0 <__divdi3+0xf42>
    71de:	30 e0       	ldi	r19, 0x00	; 0
    71e0:	f3 2b       	or	r31, r19
    71e2:	81 95       	neg	r24
    71e4:	e1 e0       	ldi	r30, 0x01	; 1
    71e6:	18 16       	cp	r1, r24
    71e8:	08 f0       	brcs	.+2      	; 0x71ec <__divdi3+0xf4e>
    71ea:	e0 e0       	ldi	r30, 0x00	; 0
    71ec:	f8 2e       	mov	r15, r24
    71ee:	ff 1a       	sub	r15, r31
    71f0:	ff 2d       	mov	r31, r15
    71f2:	31 e0       	ldi	r19, 0x01	; 1
    71f4:	8f 15       	cp	r24, r15
    71f6:	08 f0       	brcs	.+2      	; 0x71fa <__divdi3+0xf5c>
    71f8:	30 e0       	ldi	r19, 0x00	; 0
    71fa:	e3 2b       	or	r30, r19
    71fc:	91 95       	neg	r25
    71fe:	30 2f       	mov	r19, r16
    7200:	41 2f       	mov	r20, r17
    7202:	5b 2f       	mov	r21, r27
    7204:	64 2d       	mov	r22, r4
    7206:	7a 2f       	mov	r23, r26
    7208:	8f 2f       	mov	r24, r31
    720a:	9e 1b       	sub	r25, r30
    720c:	c8 5b       	subi	r28, 0xB8	; 184
    720e:	df 4f       	sbci	r29, 0xFF	; 255
    7210:	e1 e1       	ldi	r30, 0x11	; 17
    7212:	0c 94 57 3b 	jmp	0x76ae	; 0x76ae <__epilogue_restores__+0x2>

00007216 <__subsf3>:
    7216:	50 58       	subi	r21, 0x80	; 128

00007218 <__addsf3>:
    7218:	bb 27       	eor	r27, r27
    721a:	aa 27       	eor	r26, r26
    721c:	0e d0       	rcall	.+28     	; 0x723a <__addsf3x>
    721e:	48 c1       	rjmp	.+656    	; 0x74b0 <__fp_round>
    7220:	39 d1       	rcall	.+626    	; 0x7494 <__fp_pscA>
    7222:	30 f0       	brcs	.+12     	; 0x7230 <__addsf3+0x18>
    7224:	3e d1       	rcall	.+636    	; 0x74a2 <__fp_pscB>
    7226:	20 f0       	brcs	.+8      	; 0x7230 <__addsf3+0x18>
    7228:	31 f4       	brne	.+12     	; 0x7236 <__addsf3+0x1e>
    722a:	9f 3f       	cpi	r25, 0xFF	; 255
    722c:	11 f4       	brne	.+4      	; 0x7232 <__addsf3+0x1a>
    722e:	1e f4       	brtc	.+6      	; 0x7236 <__addsf3+0x1e>
    7230:	2e c1       	rjmp	.+604    	; 0x748e <__fp_nan>
    7232:	0e f4       	brtc	.+2      	; 0x7236 <__addsf3+0x1e>
    7234:	e0 95       	com	r30
    7236:	e7 fb       	bst	r30, 7
    7238:	24 c1       	rjmp	.+584    	; 0x7482 <__fp_inf>

0000723a <__addsf3x>:
    723a:	e9 2f       	mov	r30, r25
    723c:	4a d1       	rcall	.+660    	; 0x74d2 <__fp_split3>
    723e:	80 f3       	brcs	.-32     	; 0x7220 <__addsf3+0x8>
    7240:	ba 17       	cp	r27, r26
    7242:	62 07       	cpc	r22, r18
    7244:	73 07       	cpc	r23, r19
    7246:	84 07       	cpc	r24, r20
    7248:	95 07       	cpc	r25, r21
    724a:	18 f0       	brcs	.+6      	; 0x7252 <__addsf3x+0x18>
    724c:	71 f4       	brne	.+28     	; 0x726a <__addsf3x+0x30>
    724e:	9e f5       	brtc	.+102    	; 0x72b6 <__addsf3x+0x7c>
    7250:	62 c1       	rjmp	.+708    	; 0x7516 <__fp_zero>
    7252:	0e f4       	brtc	.+2      	; 0x7256 <__addsf3x+0x1c>
    7254:	e0 95       	com	r30
    7256:	0b 2e       	mov	r0, r27
    7258:	ba 2f       	mov	r27, r26
    725a:	a0 2d       	mov	r26, r0
    725c:	0b 01       	movw	r0, r22
    725e:	b9 01       	movw	r22, r18
    7260:	90 01       	movw	r18, r0
    7262:	0c 01       	movw	r0, r24
    7264:	ca 01       	movw	r24, r20
    7266:	a0 01       	movw	r20, r0
    7268:	11 24       	eor	r1, r1
    726a:	ff 27       	eor	r31, r31
    726c:	59 1b       	sub	r21, r25
    726e:	99 f0       	breq	.+38     	; 0x7296 <__addsf3x+0x5c>
    7270:	59 3f       	cpi	r21, 0xF9	; 249
    7272:	50 f4       	brcc	.+20     	; 0x7288 <__addsf3x+0x4e>
    7274:	50 3e       	cpi	r21, 0xE0	; 224
    7276:	68 f1       	brcs	.+90     	; 0x72d2 <__addsf3x+0x98>
    7278:	1a 16       	cp	r1, r26
    727a:	f0 40       	sbci	r31, 0x00	; 0
    727c:	a2 2f       	mov	r26, r18
    727e:	23 2f       	mov	r18, r19
    7280:	34 2f       	mov	r19, r20
    7282:	44 27       	eor	r20, r20
    7284:	58 5f       	subi	r21, 0xF8	; 248
    7286:	f3 cf       	rjmp	.-26     	; 0x726e <__addsf3x+0x34>
    7288:	46 95       	lsr	r20
    728a:	37 95       	ror	r19
    728c:	27 95       	ror	r18
    728e:	a7 95       	ror	r26
    7290:	f0 40       	sbci	r31, 0x00	; 0
    7292:	53 95       	inc	r21
    7294:	c9 f7       	brne	.-14     	; 0x7288 <__addsf3x+0x4e>
    7296:	7e f4       	brtc	.+30     	; 0x72b6 <__addsf3x+0x7c>
    7298:	1f 16       	cp	r1, r31
    729a:	ba 0b       	sbc	r27, r26
    729c:	62 0b       	sbc	r22, r18
    729e:	73 0b       	sbc	r23, r19
    72a0:	84 0b       	sbc	r24, r20
    72a2:	ba f0       	brmi	.+46     	; 0x72d2 <__addsf3x+0x98>
    72a4:	91 50       	subi	r25, 0x01	; 1
    72a6:	a1 f0       	breq	.+40     	; 0x72d0 <__addsf3x+0x96>
    72a8:	ff 0f       	add	r31, r31
    72aa:	bb 1f       	adc	r27, r27
    72ac:	66 1f       	adc	r22, r22
    72ae:	77 1f       	adc	r23, r23
    72b0:	88 1f       	adc	r24, r24
    72b2:	c2 f7       	brpl	.-16     	; 0x72a4 <__addsf3x+0x6a>
    72b4:	0e c0       	rjmp	.+28     	; 0x72d2 <__addsf3x+0x98>
    72b6:	ba 0f       	add	r27, r26
    72b8:	62 1f       	adc	r22, r18
    72ba:	73 1f       	adc	r23, r19
    72bc:	84 1f       	adc	r24, r20
    72be:	48 f4       	brcc	.+18     	; 0x72d2 <__addsf3x+0x98>
    72c0:	87 95       	ror	r24
    72c2:	77 95       	ror	r23
    72c4:	67 95       	ror	r22
    72c6:	b7 95       	ror	r27
    72c8:	f7 95       	ror	r31
    72ca:	9e 3f       	cpi	r25, 0xFE	; 254
    72cc:	08 f0       	brcs	.+2      	; 0x72d0 <__addsf3x+0x96>
    72ce:	b3 cf       	rjmp	.-154    	; 0x7236 <__addsf3+0x1e>
    72d0:	93 95       	inc	r25
    72d2:	88 0f       	add	r24, r24
    72d4:	08 f0       	brcs	.+2      	; 0x72d8 <__addsf3x+0x9e>
    72d6:	99 27       	eor	r25, r25
    72d8:	ee 0f       	add	r30, r30
    72da:	97 95       	ror	r25
    72dc:	87 95       	ror	r24
    72de:	08 95       	ret

000072e0 <__divsf3>:
    72e0:	0c d0       	rcall	.+24     	; 0x72fa <__divsf3x>
    72e2:	e6 c0       	rjmp	.+460    	; 0x74b0 <__fp_round>
    72e4:	de d0       	rcall	.+444    	; 0x74a2 <__fp_pscB>
    72e6:	40 f0       	brcs	.+16     	; 0x72f8 <__divsf3+0x18>
    72e8:	d5 d0       	rcall	.+426    	; 0x7494 <__fp_pscA>
    72ea:	30 f0       	brcs	.+12     	; 0x72f8 <__divsf3+0x18>
    72ec:	21 f4       	brne	.+8      	; 0x72f6 <__divsf3+0x16>
    72ee:	5f 3f       	cpi	r21, 0xFF	; 255
    72f0:	19 f0       	breq	.+6      	; 0x72f8 <__divsf3+0x18>
    72f2:	c7 c0       	rjmp	.+398    	; 0x7482 <__fp_inf>
    72f4:	51 11       	cpse	r21, r1
    72f6:	10 c1       	rjmp	.+544    	; 0x7518 <__fp_szero>
    72f8:	ca c0       	rjmp	.+404    	; 0x748e <__fp_nan>

000072fa <__divsf3x>:
    72fa:	eb d0       	rcall	.+470    	; 0x74d2 <__fp_split3>
    72fc:	98 f3       	brcs	.-26     	; 0x72e4 <__divsf3+0x4>

000072fe <__divsf3_pse>:
    72fe:	99 23       	and	r25, r25
    7300:	c9 f3       	breq	.-14     	; 0x72f4 <__divsf3+0x14>
    7302:	55 23       	and	r21, r21
    7304:	b1 f3       	breq	.-20     	; 0x72f2 <__divsf3+0x12>
    7306:	95 1b       	sub	r25, r21
    7308:	55 0b       	sbc	r21, r21
    730a:	bb 27       	eor	r27, r27
    730c:	aa 27       	eor	r26, r26
    730e:	62 17       	cp	r22, r18
    7310:	73 07       	cpc	r23, r19
    7312:	84 07       	cpc	r24, r20
    7314:	38 f0       	brcs	.+14     	; 0x7324 <__divsf3_pse+0x26>
    7316:	9f 5f       	subi	r25, 0xFF	; 255
    7318:	5f 4f       	sbci	r21, 0xFF	; 255
    731a:	22 0f       	add	r18, r18
    731c:	33 1f       	adc	r19, r19
    731e:	44 1f       	adc	r20, r20
    7320:	aa 1f       	adc	r26, r26
    7322:	a9 f3       	breq	.-22     	; 0x730e <__divsf3_pse+0x10>
    7324:	33 d0       	rcall	.+102    	; 0x738c <__divsf3_pse+0x8e>
    7326:	0e 2e       	mov	r0, r30
    7328:	3a f0       	brmi	.+14     	; 0x7338 <__divsf3_pse+0x3a>
    732a:	e0 e8       	ldi	r30, 0x80	; 128
    732c:	30 d0       	rcall	.+96     	; 0x738e <__divsf3_pse+0x90>
    732e:	91 50       	subi	r25, 0x01	; 1
    7330:	50 40       	sbci	r21, 0x00	; 0
    7332:	e6 95       	lsr	r30
    7334:	00 1c       	adc	r0, r0
    7336:	ca f7       	brpl	.-14     	; 0x732a <__divsf3_pse+0x2c>
    7338:	29 d0       	rcall	.+82     	; 0x738c <__divsf3_pse+0x8e>
    733a:	fe 2f       	mov	r31, r30
    733c:	27 d0       	rcall	.+78     	; 0x738c <__divsf3_pse+0x8e>
    733e:	66 0f       	add	r22, r22
    7340:	77 1f       	adc	r23, r23
    7342:	88 1f       	adc	r24, r24
    7344:	bb 1f       	adc	r27, r27
    7346:	26 17       	cp	r18, r22
    7348:	37 07       	cpc	r19, r23
    734a:	48 07       	cpc	r20, r24
    734c:	ab 07       	cpc	r26, r27
    734e:	b0 e8       	ldi	r27, 0x80	; 128
    7350:	09 f0       	breq	.+2      	; 0x7354 <__divsf3_pse+0x56>
    7352:	bb 0b       	sbc	r27, r27
    7354:	80 2d       	mov	r24, r0
    7356:	bf 01       	movw	r22, r30
    7358:	ff 27       	eor	r31, r31
    735a:	93 58       	subi	r25, 0x83	; 131
    735c:	5f 4f       	sbci	r21, 0xFF	; 255
    735e:	2a f0       	brmi	.+10     	; 0x736a <__divsf3_pse+0x6c>
    7360:	9e 3f       	cpi	r25, 0xFE	; 254
    7362:	51 05       	cpc	r21, r1
    7364:	68 f0       	brcs	.+26     	; 0x7380 <__divsf3_pse+0x82>
    7366:	8d c0       	rjmp	.+282    	; 0x7482 <__fp_inf>
    7368:	d7 c0       	rjmp	.+430    	; 0x7518 <__fp_szero>
    736a:	5f 3f       	cpi	r21, 0xFF	; 255
    736c:	ec f3       	brlt	.-6      	; 0x7368 <__divsf3_pse+0x6a>
    736e:	98 3e       	cpi	r25, 0xE8	; 232
    7370:	dc f3       	brlt	.-10     	; 0x7368 <__divsf3_pse+0x6a>
    7372:	86 95       	lsr	r24
    7374:	77 95       	ror	r23
    7376:	67 95       	ror	r22
    7378:	b7 95       	ror	r27
    737a:	f7 95       	ror	r31
    737c:	9f 5f       	subi	r25, 0xFF	; 255
    737e:	c9 f7       	brne	.-14     	; 0x7372 <__divsf3_pse+0x74>
    7380:	88 0f       	add	r24, r24
    7382:	91 1d       	adc	r25, r1
    7384:	96 95       	lsr	r25
    7386:	87 95       	ror	r24
    7388:	97 f9       	bld	r25, 7
    738a:	08 95       	ret
    738c:	e1 e0       	ldi	r30, 0x01	; 1
    738e:	66 0f       	add	r22, r22
    7390:	77 1f       	adc	r23, r23
    7392:	88 1f       	adc	r24, r24
    7394:	bb 1f       	adc	r27, r27
    7396:	62 17       	cp	r22, r18
    7398:	73 07       	cpc	r23, r19
    739a:	84 07       	cpc	r24, r20
    739c:	ba 07       	cpc	r27, r26
    739e:	20 f0       	brcs	.+8      	; 0x73a8 <__divsf3_pse+0xaa>
    73a0:	62 1b       	sub	r22, r18
    73a2:	73 0b       	sbc	r23, r19
    73a4:	84 0b       	sbc	r24, r20
    73a6:	ba 0b       	sbc	r27, r26
    73a8:	ee 1f       	adc	r30, r30
    73aa:	88 f7       	brcc	.-30     	; 0x738e <__divsf3_pse+0x90>
    73ac:	e0 95       	com	r30
    73ae:	08 95       	ret

000073b0 <__fixunssfsi>:
    73b0:	98 d0       	rcall	.+304    	; 0x74e2 <__fp_splitA>
    73b2:	88 f0       	brcs	.+34     	; 0x73d6 <__fixunssfsi+0x26>
    73b4:	9f 57       	subi	r25, 0x7F	; 127
    73b6:	90 f0       	brcs	.+36     	; 0x73dc <__fixunssfsi+0x2c>
    73b8:	b9 2f       	mov	r27, r25
    73ba:	99 27       	eor	r25, r25
    73bc:	b7 51       	subi	r27, 0x17	; 23
    73be:	a0 f0       	brcs	.+40     	; 0x73e8 <__fixunssfsi+0x38>
    73c0:	d1 f0       	breq	.+52     	; 0x73f6 <__fixunssfsi+0x46>
    73c2:	66 0f       	add	r22, r22
    73c4:	77 1f       	adc	r23, r23
    73c6:	88 1f       	adc	r24, r24
    73c8:	99 1f       	adc	r25, r25
    73ca:	1a f0       	brmi	.+6      	; 0x73d2 <__fixunssfsi+0x22>
    73cc:	ba 95       	dec	r27
    73ce:	c9 f7       	brne	.-14     	; 0x73c2 <__fixunssfsi+0x12>
    73d0:	12 c0       	rjmp	.+36     	; 0x73f6 <__fixunssfsi+0x46>
    73d2:	b1 30       	cpi	r27, 0x01	; 1
    73d4:	81 f0       	breq	.+32     	; 0x73f6 <__fixunssfsi+0x46>
    73d6:	9f d0       	rcall	.+318    	; 0x7516 <__fp_zero>
    73d8:	b1 e0       	ldi	r27, 0x01	; 1
    73da:	08 95       	ret
    73dc:	9c c0       	rjmp	.+312    	; 0x7516 <__fp_zero>
    73de:	67 2f       	mov	r22, r23
    73e0:	78 2f       	mov	r23, r24
    73e2:	88 27       	eor	r24, r24
    73e4:	b8 5f       	subi	r27, 0xF8	; 248
    73e6:	39 f0       	breq	.+14     	; 0x73f6 <__fixunssfsi+0x46>
    73e8:	b9 3f       	cpi	r27, 0xF9	; 249
    73ea:	cc f3       	brlt	.-14     	; 0x73de <__fixunssfsi+0x2e>
    73ec:	86 95       	lsr	r24
    73ee:	77 95       	ror	r23
    73f0:	67 95       	ror	r22
    73f2:	b3 95       	inc	r27
    73f4:	d9 f7       	brne	.-10     	; 0x73ec <__fixunssfsi+0x3c>
    73f6:	3e f4       	brtc	.+14     	; 0x7406 <__fixunssfsi+0x56>
    73f8:	90 95       	com	r25
    73fa:	80 95       	com	r24
    73fc:	70 95       	com	r23
    73fe:	61 95       	neg	r22
    7400:	7f 4f       	sbci	r23, 0xFF	; 255
    7402:	8f 4f       	sbci	r24, 0xFF	; 255
    7404:	9f 4f       	sbci	r25, 0xFF	; 255
    7406:	08 95       	ret

00007408 <__floatunsisf>:
    7408:	e8 94       	clt
    740a:	09 c0       	rjmp	.+18     	; 0x741e <__floatsisf+0x12>

0000740c <__floatsisf>:
    740c:	97 fb       	bst	r25, 7
    740e:	3e f4       	brtc	.+14     	; 0x741e <__floatsisf+0x12>
    7410:	90 95       	com	r25
    7412:	80 95       	com	r24
    7414:	70 95       	com	r23
    7416:	61 95       	neg	r22
    7418:	7f 4f       	sbci	r23, 0xFF	; 255
    741a:	8f 4f       	sbci	r24, 0xFF	; 255
    741c:	9f 4f       	sbci	r25, 0xFF	; 255
    741e:	99 23       	and	r25, r25
    7420:	a9 f0       	breq	.+42     	; 0x744c <__floatsisf+0x40>
    7422:	f9 2f       	mov	r31, r25
    7424:	96 e9       	ldi	r25, 0x96	; 150
    7426:	bb 27       	eor	r27, r27
    7428:	93 95       	inc	r25
    742a:	f6 95       	lsr	r31
    742c:	87 95       	ror	r24
    742e:	77 95       	ror	r23
    7430:	67 95       	ror	r22
    7432:	b7 95       	ror	r27
    7434:	f1 11       	cpse	r31, r1
    7436:	f8 cf       	rjmp	.-16     	; 0x7428 <__floatsisf+0x1c>
    7438:	fa f4       	brpl	.+62     	; 0x7478 <__floatsisf+0x6c>
    743a:	bb 0f       	add	r27, r27
    743c:	11 f4       	brne	.+4      	; 0x7442 <__floatsisf+0x36>
    743e:	60 ff       	sbrs	r22, 0
    7440:	1b c0       	rjmp	.+54     	; 0x7478 <__floatsisf+0x6c>
    7442:	6f 5f       	subi	r22, 0xFF	; 255
    7444:	7f 4f       	sbci	r23, 0xFF	; 255
    7446:	8f 4f       	sbci	r24, 0xFF	; 255
    7448:	9f 4f       	sbci	r25, 0xFF	; 255
    744a:	16 c0       	rjmp	.+44     	; 0x7478 <__floatsisf+0x6c>
    744c:	88 23       	and	r24, r24
    744e:	11 f0       	breq	.+4      	; 0x7454 <__floatsisf+0x48>
    7450:	96 e9       	ldi	r25, 0x96	; 150
    7452:	11 c0       	rjmp	.+34     	; 0x7476 <__floatsisf+0x6a>
    7454:	77 23       	and	r23, r23
    7456:	21 f0       	breq	.+8      	; 0x7460 <__floatsisf+0x54>
    7458:	9e e8       	ldi	r25, 0x8E	; 142
    745a:	87 2f       	mov	r24, r23
    745c:	76 2f       	mov	r23, r22
    745e:	05 c0       	rjmp	.+10     	; 0x746a <__floatsisf+0x5e>
    7460:	66 23       	and	r22, r22
    7462:	71 f0       	breq	.+28     	; 0x7480 <__floatsisf+0x74>
    7464:	96 e8       	ldi	r25, 0x86	; 134
    7466:	86 2f       	mov	r24, r22
    7468:	70 e0       	ldi	r23, 0x00	; 0
    746a:	60 e0       	ldi	r22, 0x00	; 0
    746c:	2a f0       	brmi	.+10     	; 0x7478 <__floatsisf+0x6c>
    746e:	9a 95       	dec	r25
    7470:	66 0f       	add	r22, r22
    7472:	77 1f       	adc	r23, r23
    7474:	88 1f       	adc	r24, r24
    7476:	da f7       	brpl	.-10     	; 0x746e <__floatsisf+0x62>
    7478:	88 0f       	add	r24, r24
    747a:	96 95       	lsr	r25
    747c:	87 95       	ror	r24
    747e:	97 f9       	bld	r25, 7
    7480:	08 95       	ret

00007482 <__fp_inf>:
    7482:	97 f9       	bld	r25, 7
    7484:	9f 67       	ori	r25, 0x7F	; 127
    7486:	80 e8       	ldi	r24, 0x80	; 128
    7488:	70 e0       	ldi	r23, 0x00	; 0
    748a:	60 e0       	ldi	r22, 0x00	; 0
    748c:	08 95       	ret

0000748e <__fp_nan>:
    748e:	9f ef       	ldi	r25, 0xFF	; 255
    7490:	80 ec       	ldi	r24, 0xC0	; 192
    7492:	08 95       	ret

00007494 <__fp_pscA>:
    7494:	00 24       	eor	r0, r0
    7496:	0a 94       	dec	r0
    7498:	16 16       	cp	r1, r22
    749a:	17 06       	cpc	r1, r23
    749c:	18 06       	cpc	r1, r24
    749e:	09 06       	cpc	r0, r25
    74a0:	08 95       	ret

000074a2 <__fp_pscB>:
    74a2:	00 24       	eor	r0, r0
    74a4:	0a 94       	dec	r0
    74a6:	12 16       	cp	r1, r18
    74a8:	13 06       	cpc	r1, r19
    74aa:	14 06       	cpc	r1, r20
    74ac:	05 06       	cpc	r0, r21
    74ae:	08 95       	ret

000074b0 <__fp_round>:
    74b0:	09 2e       	mov	r0, r25
    74b2:	03 94       	inc	r0
    74b4:	00 0c       	add	r0, r0
    74b6:	11 f4       	brne	.+4      	; 0x74bc <__fp_round+0xc>
    74b8:	88 23       	and	r24, r24
    74ba:	52 f0       	brmi	.+20     	; 0x74d0 <__fp_round+0x20>
    74bc:	bb 0f       	add	r27, r27
    74be:	40 f4       	brcc	.+16     	; 0x74d0 <__fp_round+0x20>
    74c0:	bf 2b       	or	r27, r31
    74c2:	11 f4       	brne	.+4      	; 0x74c8 <__fp_round+0x18>
    74c4:	60 ff       	sbrs	r22, 0
    74c6:	04 c0       	rjmp	.+8      	; 0x74d0 <__fp_round+0x20>
    74c8:	6f 5f       	subi	r22, 0xFF	; 255
    74ca:	7f 4f       	sbci	r23, 0xFF	; 255
    74cc:	8f 4f       	sbci	r24, 0xFF	; 255
    74ce:	9f 4f       	sbci	r25, 0xFF	; 255
    74d0:	08 95       	ret

000074d2 <__fp_split3>:
    74d2:	57 fd       	sbrc	r21, 7
    74d4:	90 58       	subi	r25, 0x80	; 128
    74d6:	44 0f       	add	r20, r20
    74d8:	55 1f       	adc	r21, r21
    74da:	59 f0       	breq	.+22     	; 0x74f2 <__fp_splitA+0x10>
    74dc:	5f 3f       	cpi	r21, 0xFF	; 255
    74de:	71 f0       	breq	.+28     	; 0x74fc <__fp_splitA+0x1a>
    74e0:	47 95       	ror	r20

000074e2 <__fp_splitA>:
    74e2:	88 0f       	add	r24, r24
    74e4:	97 fb       	bst	r25, 7
    74e6:	99 1f       	adc	r25, r25
    74e8:	61 f0       	breq	.+24     	; 0x7502 <__fp_splitA+0x20>
    74ea:	9f 3f       	cpi	r25, 0xFF	; 255
    74ec:	79 f0       	breq	.+30     	; 0x750c <__fp_splitA+0x2a>
    74ee:	87 95       	ror	r24
    74f0:	08 95       	ret
    74f2:	12 16       	cp	r1, r18
    74f4:	13 06       	cpc	r1, r19
    74f6:	14 06       	cpc	r1, r20
    74f8:	55 1f       	adc	r21, r21
    74fa:	f2 cf       	rjmp	.-28     	; 0x74e0 <__fp_split3+0xe>
    74fc:	46 95       	lsr	r20
    74fe:	f1 df       	rcall	.-30     	; 0x74e2 <__fp_splitA>
    7500:	08 c0       	rjmp	.+16     	; 0x7512 <__fp_splitA+0x30>
    7502:	16 16       	cp	r1, r22
    7504:	17 06       	cpc	r1, r23
    7506:	18 06       	cpc	r1, r24
    7508:	99 1f       	adc	r25, r25
    750a:	f1 cf       	rjmp	.-30     	; 0x74ee <__fp_splitA+0xc>
    750c:	86 95       	lsr	r24
    750e:	71 05       	cpc	r23, r1
    7510:	61 05       	cpc	r22, r1
    7512:	08 94       	sec
    7514:	08 95       	ret

00007516 <__fp_zero>:
    7516:	e8 94       	clt

00007518 <__fp_szero>:
    7518:	bb 27       	eor	r27, r27
    751a:	66 27       	eor	r22, r22
    751c:	77 27       	eor	r23, r23
    751e:	cb 01       	movw	r24, r22
    7520:	97 f9       	bld	r25, 7
    7522:	08 95       	ret

00007524 <__gesf2>:
    7524:	03 d0       	rcall	.+6      	; 0x752c <__fp_cmp>
    7526:	08 f4       	brcc	.+2      	; 0x752a <__gesf2+0x6>
    7528:	8f ef       	ldi	r24, 0xFF	; 255
    752a:	08 95       	ret

0000752c <__fp_cmp>:
    752c:	99 0f       	add	r25, r25
    752e:	00 08       	sbc	r0, r0
    7530:	55 0f       	add	r21, r21
    7532:	aa 0b       	sbc	r26, r26
    7534:	e0 e8       	ldi	r30, 0x80	; 128
    7536:	fe ef       	ldi	r31, 0xFE	; 254
    7538:	16 16       	cp	r1, r22
    753a:	17 06       	cpc	r1, r23
    753c:	e8 07       	cpc	r30, r24
    753e:	f9 07       	cpc	r31, r25
    7540:	c0 f0       	brcs	.+48     	; 0x7572 <__fp_cmp+0x46>
    7542:	12 16       	cp	r1, r18
    7544:	13 06       	cpc	r1, r19
    7546:	e4 07       	cpc	r30, r20
    7548:	f5 07       	cpc	r31, r21
    754a:	98 f0       	brcs	.+38     	; 0x7572 <__fp_cmp+0x46>
    754c:	62 1b       	sub	r22, r18
    754e:	73 0b       	sbc	r23, r19
    7550:	84 0b       	sbc	r24, r20
    7552:	95 0b       	sbc	r25, r21
    7554:	39 f4       	brne	.+14     	; 0x7564 <__fp_cmp+0x38>
    7556:	0a 26       	eor	r0, r26
    7558:	61 f0       	breq	.+24     	; 0x7572 <__fp_cmp+0x46>
    755a:	23 2b       	or	r18, r19
    755c:	24 2b       	or	r18, r20
    755e:	25 2b       	or	r18, r21
    7560:	21 f4       	brne	.+8      	; 0x756a <__fp_cmp+0x3e>
    7562:	08 95       	ret
    7564:	0a 26       	eor	r0, r26
    7566:	09 f4       	brne	.+2      	; 0x756a <__fp_cmp+0x3e>
    7568:	a1 40       	sbci	r26, 0x01	; 1
    756a:	a6 95       	lsr	r26
    756c:	8f ef       	ldi	r24, 0xFF	; 255
    756e:	81 1d       	adc	r24, r1
    7570:	81 1d       	adc	r24, r1
    7572:	08 95       	ret

00007574 <__mulsi3>:
    7574:	62 9f       	mul	r22, r18
    7576:	d0 01       	movw	r26, r0
    7578:	73 9f       	mul	r23, r19
    757a:	f0 01       	movw	r30, r0
    757c:	82 9f       	mul	r24, r18
    757e:	e0 0d       	add	r30, r0
    7580:	f1 1d       	adc	r31, r1
    7582:	64 9f       	mul	r22, r20
    7584:	e0 0d       	add	r30, r0
    7586:	f1 1d       	adc	r31, r1
    7588:	92 9f       	mul	r25, r18
    758a:	f0 0d       	add	r31, r0
    758c:	83 9f       	mul	r24, r19
    758e:	f0 0d       	add	r31, r0
    7590:	74 9f       	mul	r23, r20
    7592:	f0 0d       	add	r31, r0
    7594:	65 9f       	mul	r22, r21
    7596:	f0 0d       	add	r31, r0
    7598:	99 27       	eor	r25, r25
    759a:	72 9f       	mul	r23, r18
    759c:	b0 0d       	add	r27, r0
    759e:	e1 1d       	adc	r30, r1
    75a0:	f9 1f       	adc	r31, r25
    75a2:	63 9f       	mul	r22, r19
    75a4:	b0 0d       	add	r27, r0
    75a6:	e1 1d       	adc	r30, r1
    75a8:	f9 1f       	adc	r31, r25
    75aa:	bd 01       	movw	r22, r26
    75ac:	cf 01       	movw	r24, r30
    75ae:	11 24       	eor	r1, r1
    75b0:	08 95       	ret

000075b2 <__udivmodhi4>:
    75b2:	aa 1b       	sub	r26, r26
    75b4:	bb 1b       	sub	r27, r27
    75b6:	51 e1       	ldi	r21, 0x11	; 17
    75b8:	07 c0       	rjmp	.+14     	; 0x75c8 <__udivmodhi4_ep>

000075ba <__udivmodhi4_loop>:
    75ba:	aa 1f       	adc	r26, r26
    75bc:	bb 1f       	adc	r27, r27
    75be:	a6 17       	cp	r26, r22
    75c0:	b7 07       	cpc	r27, r23
    75c2:	10 f0       	brcs	.+4      	; 0x75c8 <__udivmodhi4_ep>
    75c4:	a6 1b       	sub	r26, r22
    75c6:	b7 0b       	sbc	r27, r23

000075c8 <__udivmodhi4_ep>:
    75c8:	88 1f       	adc	r24, r24
    75ca:	99 1f       	adc	r25, r25
    75cc:	5a 95       	dec	r21
    75ce:	a9 f7       	brne	.-22     	; 0x75ba <__udivmodhi4_loop>
    75d0:	80 95       	com	r24
    75d2:	90 95       	com	r25
    75d4:	bc 01       	movw	r22, r24
    75d6:	cd 01       	movw	r24, r26
    75d8:	08 95       	ret

000075da <__divmodhi4>:
    75da:	97 fb       	bst	r25, 7
    75dc:	09 2e       	mov	r0, r25
    75de:	07 26       	eor	r0, r23
    75e0:	0a d0       	rcall	.+20     	; 0x75f6 <__divmodhi4_neg1>
    75e2:	77 fd       	sbrc	r23, 7
    75e4:	04 d0       	rcall	.+8      	; 0x75ee <__divmodhi4_neg2>
    75e6:	e5 df       	rcall	.-54     	; 0x75b2 <__udivmodhi4>
    75e8:	06 d0       	rcall	.+12     	; 0x75f6 <__divmodhi4_neg1>
    75ea:	00 20       	and	r0, r0
    75ec:	1a f4       	brpl	.+6      	; 0x75f4 <__divmodhi4_exit>

000075ee <__divmodhi4_neg2>:
    75ee:	70 95       	com	r23
    75f0:	61 95       	neg	r22
    75f2:	7f 4f       	sbci	r23, 0xFF	; 255

000075f4 <__divmodhi4_exit>:
    75f4:	08 95       	ret

000075f6 <__divmodhi4_neg1>:
    75f6:	f6 f7       	brtc	.-4      	; 0x75f4 <__divmodhi4_exit>
    75f8:	90 95       	com	r25
    75fa:	81 95       	neg	r24
    75fc:	9f 4f       	sbci	r25, 0xFF	; 255
    75fe:	08 95       	ret

00007600 <__udivmodsi4>:
    7600:	a1 e2       	ldi	r26, 0x21	; 33
    7602:	1a 2e       	mov	r1, r26
    7604:	aa 1b       	sub	r26, r26
    7606:	bb 1b       	sub	r27, r27
    7608:	fd 01       	movw	r30, r26
    760a:	0d c0       	rjmp	.+26     	; 0x7626 <__udivmodsi4_ep>

0000760c <__udivmodsi4_loop>:
    760c:	aa 1f       	adc	r26, r26
    760e:	bb 1f       	adc	r27, r27
    7610:	ee 1f       	adc	r30, r30
    7612:	ff 1f       	adc	r31, r31
    7614:	a2 17       	cp	r26, r18
    7616:	b3 07       	cpc	r27, r19
    7618:	e4 07       	cpc	r30, r20
    761a:	f5 07       	cpc	r31, r21
    761c:	20 f0       	brcs	.+8      	; 0x7626 <__udivmodsi4_ep>
    761e:	a2 1b       	sub	r26, r18
    7620:	b3 0b       	sbc	r27, r19
    7622:	e4 0b       	sbc	r30, r20
    7624:	f5 0b       	sbc	r31, r21

00007626 <__udivmodsi4_ep>:
    7626:	66 1f       	adc	r22, r22
    7628:	77 1f       	adc	r23, r23
    762a:	88 1f       	adc	r24, r24
    762c:	99 1f       	adc	r25, r25
    762e:	1a 94       	dec	r1
    7630:	69 f7       	brne	.-38     	; 0x760c <__udivmodsi4_loop>
    7632:	60 95       	com	r22
    7634:	70 95       	com	r23
    7636:	80 95       	com	r24
    7638:	90 95       	com	r25
    763a:	9b 01       	movw	r18, r22
    763c:	ac 01       	movw	r20, r24
    763e:	bd 01       	movw	r22, r26
    7640:	cf 01       	movw	r24, r30
    7642:	08 95       	ret

00007644 <__divmodsi4>:
    7644:	97 fb       	bst	r25, 7
    7646:	09 2e       	mov	r0, r25
    7648:	05 26       	eor	r0, r21
    764a:	0e d0       	rcall	.+28     	; 0x7668 <__divmodsi4_neg1>
    764c:	57 fd       	sbrc	r21, 7
    764e:	04 d0       	rcall	.+8      	; 0x7658 <__divmodsi4_neg2>
    7650:	d7 df       	rcall	.-82     	; 0x7600 <__udivmodsi4>
    7652:	0a d0       	rcall	.+20     	; 0x7668 <__divmodsi4_neg1>
    7654:	00 1c       	adc	r0, r0
    7656:	38 f4       	brcc	.+14     	; 0x7666 <__divmodsi4_exit>

00007658 <__divmodsi4_neg2>:
    7658:	50 95       	com	r21
    765a:	40 95       	com	r20
    765c:	30 95       	com	r19
    765e:	21 95       	neg	r18
    7660:	3f 4f       	sbci	r19, 0xFF	; 255
    7662:	4f 4f       	sbci	r20, 0xFF	; 255
    7664:	5f 4f       	sbci	r21, 0xFF	; 255

00007666 <__divmodsi4_exit>:
    7666:	08 95       	ret

00007668 <__divmodsi4_neg1>:
    7668:	f6 f7       	brtc	.-4      	; 0x7666 <__divmodsi4_exit>
    766a:	90 95       	com	r25
    766c:	80 95       	com	r24
    766e:	70 95       	com	r23
    7670:	61 95       	neg	r22
    7672:	7f 4f       	sbci	r23, 0xFF	; 255
    7674:	8f 4f       	sbci	r24, 0xFF	; 255
    7676:	9f 4f       	sbci	r25, 0xFF	; 255
    7678:	08 95       	ret

0000767a <__prologue_saves__>:
    767a:	2f 92       	push	r2
    767c:	3f 92       	push	r3
    767e:	4f 92       	push	r4
    7680:	5f 92       	push	r5
    7682:	6f 92       	push	r6
    7684:	7f 92       	push	r7
    7686:	8f 92       	push	r8
    7688:	9f 92       	push	r9
    768a:	af 92       	push	r10
    768c:	bf 92       	push	r11
    768e:	cf 92       	push	r12
    7690:	df 92       	push	r13
    7692:	ef 92       	push	r14
    7694:	ff 92       	push	r15
    7696:	0f 93       	push	r16
    7698:	1f 93       	push	r17
    769a:	cf 93       	push	r28
    769c:	df 93       	push	r29
    769e:	cd b7       	in	r28, 0x3d	; 61
    76a0:	de b7       	in	r29, 0x3e	; 62
    76a2:	ca 1b       	sub	r28, r26
    76a4:	db 0b       	sbc	r29, r27
    76a6:	cd bf       	out	0x3d, r28	; 61
    76a8:	de bf       	out	0x3e, r29	; 62
    76aa:	19 94       	eijmp

000076ac <__epilogue_restores__>:
    76ac:	2a 88       	ldd	r2, Y+18	; 0x12
    76ae:	39 88       	ldd	r3, Y+17	; 0x11
    76b0:	48 88       	ldd	r4, Y+16	; 0x10
    76b2:	5f 84       	ldd	r5, Y+15	; 0x0f
    76b4:	6e 84       	ldd	r6, Y+14	; 0x0e
    76b6:	7d 84       	ldd	r7, Y+13	; 0x0d
    76b8:	8c 84       	ldd	r8, Y+12	; 0x0c
    76ba:	9b 84       	ldd	r9, Y+11	; 0x0b
    76bc:	aa 84       	ldd	r10, Y+10	; 0x0a
    76be:	b9 84       	ldd	r11, Y+9	; 0x09
    76c0:	c8 84       	ldd	r12, Y+8	; 0x08
    76c2:	df 80       	ldd	r13, Y+7	; 0x07
    76c4:	ee 80       	ldd	r14, Y+6	; 0x06
    76c6:	fd 80       	ldd	r15, Y+5	; 0x05
    76c8:	0c 81       	ldd	r16, Y+4	; 0x04
    76ca:	1b 81       	ldd	r17, Y+3	; 0x03
    76cc:	aa 81       	ldd	r26, Y+2	; 0x02
    76ce:	b9 81       	ldd	r27, Y+1	; 0x01
    76d0:	ce 0f       	add	r28, r30
    76d2:	d1 1d       	adc	r29, r1
    76d4:	cd bf       	out	0x3d, r28	; 61
    76d6:	de bf       	out	0x3e, r29	; 62
    76d8:	ed 01       	movw	r28, r26
    76da:	08 95       	ret

000076dc <strcpy_P>:
    76dc:	fb 01       	movw	r30, r22
    76de:	dc 01       	movw	r26, r24
    76e0:	05 90       	lpm	r0, Z+
    76e2:	0d 92       	st	X+, r0
    76e4:	00 20       	and	r0, r0
    76e6:	e1 f7       	brne	.-8      	; 0x76e0 <strcpy_P+0x4>
    76e8:	08 95       	ret

000076ea <memmove>:
    76ea:	68 17       	cp	r22, r24
    76ec:	79 07       	cpc	r23, r25
    76ee:	68 f4       	brcc	.+26     	; 0x770a <memmove+0x20>
    76f0:	fb 01       	movw	r30, r22
    76f2:	dc 01       	movw	r26, r24
    76f4:	e4 0f       	add	r30, r20
    76f6:	f5 1f       	adc	r31, r21
    76f8:	a4 0f       	add	r26, r20
    76fa:	b5 1f       	adc	r27, r21
    76fc:	02 c0       	rjmp	.+4      	; 0x7702 <memmove+0x18>
    76fe:	02 90       	ld	r0, -Z
    7700:	0e 92       	st	-X, r0
    7702:	41 50       	subi	r20, 0x01	; 1
    7704:	50 40       	sbci	r21, 0x00	; 0
    7706:	d8 f7       	brcc	.-10     	; 0x76fe <memmove+0x14>
    7708:	08 95       	ret
    770a:	0c 94 08 3e 	jmp	0x7c10	; 0x7c10 <memcpy>

0000770e <strcat>:
    770e:	fb 01       	movw	r30, r22
    7710:	dc 01       	movw	r26, r24
    7712:	0d 90       	ld	r0, X+
    7714:	00 20       	and	r0, r0
    7716:	e9 f7       	brne	.-6      	; 0x7712 <strcat+0x4>
    7718:	11 97       	sbiw	r26, 0x01	; 1
    771a:	01 90       	ld	r0, Z+
    771c:	0d 92       	st	X+, r0
    771e:	00 20       	and	r0, r0
    7720:	e1 f7       	brne	.-8      	; 0x771a <strcat+0xc>
    7722:	08 95       	ret

00007724 <strncmp>:
    7724:	fb 01       	movw	r30, r22
    7726:	dc 01       	movw	r26, r24
    7728:	41 50       	subi	r20, 0x01	; 1
    772a:	50 40       	sbci	r21, 0x00	; 0
    772c:	30 f0       	brcs	.+12     	; 0x773a <strncmp+0x16>
    772e:	8d 91       	ld	r24, X+
    7730:	01 90       	ld	r0, Z+
    7732:	80 19       	sub	r24, r0
    7734:	19 f4       	brne	.+6      	; 0x773c <strncmp+0x18>
    7736:	00 20       	and	r0, r0
    7738:	b9 f7       	brne	.-18     	; 0x7728 <strncmp+0x4>
    773a:	88 1b       	sub	r24, r24
    773c:	99 0b       	sbc	r25, r25
    773e:	08 95       	ret

00007740 <itoa>:
    7740:	fb 01       	movw	r30, r22
    7742:	9f 01       	movw	r18, r30
    7744:	e8 94       	clt
    7746:	42 30       	cpi	r20, 0x02	; 2
    7748:	c4 f0       	brlt	.+48     	; 0x777a <itoa+0x3a>
    774a:	45 32       	cpi	r20, 0x25	; 37
    774c:	b4 f4       	brge	.+44     	; 0x777a <itoa+0x3a>
    774e:	4a 30       	cpi	r20, 0x0A	; 10
    7750:	29 f4       	brne	.+10     	; 0x775c <itoa+0x1c>
    7752:	97 fb       	bst	r25, 7
    7754:	1e f4       	brtc	.+6      	; 0x775c <itoa+0x1c>
    7756:	90 95       	com	r25
    7758:	81 95       	neg	r24
    775a:	9f 4f       	sbci	r25, 0xFF	; 255
    775c:	64 2f       	mov	r22, r20
    775e:	77 27       	eor	r23, r23
    7760:	0e 94 d9 3a 	call	0x75b2	; 0x75b2 <__udivmodhi4>
    7764:	80 5d       	subi	r24, 0xD0	; 208
    7766:	8a 33       	cpi	r24, 0x3A	; 58
    7768:	0c f0       	brlt	.+2      	; 0x776c <itoa+0x2c>
    776a:	89 5d       	subi	r24, 0xD9	; 217
    776c:	81 93       	st	Z+, r24
    776e:	cb 01       	movw	r24, r22
    7770:	00 97       	sbiw	r24, 0x00	; 0
    7772:	a1 f7       	brne	.-24     	; 0x775c <itoa+0x1c>
    7774:	16 f4       	brtc	.+4      	; 0x777a <itoa+0x3a>
    7776:	5d e2       	ldi	r21, 0x2D	; 45
    7778:	51 93       	st	Z+, r21
    777a:	10 82       	st	Z, r1
    777c:	c9 01       	movw	r24, r18
    777e:	0c 94 1c 3e 	jmp	0x7c38	; 0x7c38 <strrev>

00007782 <printf>:
    7782:	cf 93       	push	r28
    7784:	df 93       	push	r29
    7786:	cd b7       	in	r28, 0x3d	; 61
    7788:	de b7       	in	r29, 0x3e	; 62
    778a:	fe 01       	movw	r30, r28
    778c:	36 96       	adiw	r30, 0x06	; 6
    778e:	61 91       	ld	r22, Z+
    7790:	71 91       	ld	r23, Z+
    7792:	80 91 d9 50 	lds	r24, 0x50D9
    7796:	90 91 da 50 	lds	r25, 0x50DA
    779a:	af 01       	movw	r20, r30
    779c:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <vfprintf>
    77a0:	df 91       	pop	r29
    77a2:	cf 91       	pop	r28
    77a4:	08 95       	ret

000077a6 <sprintf>:
    77a6:	0f 93       	push	r16
    77a8:	1f 93       	push	r17
    77aa:	cf 93       	push	r28
    77ac:	df 93       	push	r29
    77ae:	cd b7       	in	r28, 0x3d	; 61
    77b0:	de b7       	in	r29, 0x3e	; 62
    77b2:	2e 97       	sbiw	r28, 0x0e	; 14
    77b4:	cd bf       	out	0x3d, r28	; 61
    77b6:	de bf       	out	0x3e, r29	; 62
    77b8:	0e 89       	ldd	r16, Y+22	; 0x16
    77ba:	1f 89       	ldd	r17, Y+23	; 0x17
    77bc:	86 e0       	ldi	r24, 0x06	; 6
    77be:	8c 83       	std	Y+4, r24	; 0x04
    77c0:	09 83       	std	Y+1, r16	; 0x01
    77c2:	1a 83       	std	Y+2, r17	; 0x02
    77c4:	8f ef       	ldi	r24, 0xFF	; 255
    77c6:	9f e7       	ldi	r25, 0x7F	; 127
    77c8:	8d 83       	std	Y+5, r24	; 0x05
    77ca:	9e 83       	std	Y+6, r25	; 0x06
    77cc:	ae 01       	movw	r20, r28
    77ce:	46 5e       	subi	r20, 0xE6	; 230
    77d0:	5f 4f       	sbci	r21, 0xFF	; 255
    77d2:	ce 01       	movw	r24, r28
    77d4:	01 96       	adiw	r24, 0x01	; 1
    77d6:	68 8d       	ldd	r22, Y+24	; 0x18
    77d8:	79 8d       	ldd	r23, Y+25	; 0x19
    77da:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <vfprintf>
    77de:	ef 81       	ldd	r30, Y+7	; 0x07
    77e0:	f8 85       	ldd	r31, Y+8	; 0x08
    77e2:	e0 0f       	add	r30, r16
    77e4:	f1 1f       	adc	r31, r17
    77e6:	10 82       	st	Z, r1
    77e8:	2e 96       	adiw	r28, 0x0e	; 14
    77ea:	cd bf       	out	0x3d, r28	; 61
    77ec:	de bf       	out	0x3e, r29	; 62
    77ee:	df 91       	pop	r29
    77f0:	cf 91       	pop	r28
    77f2:	1f 91       	pop	r17
    77f4:	0f 91       	pop	r16
    77f6:	08 95       	ret

000077f8 <vfprintf>:
    77f8:	2f 92       	push	r2
    77fa:	3f 92       	push	r3
    77fc:	4f 92       	push	r4
    77fe:	5f 92       	push	r5
    7800:	6f 92       	push	r6
    7802:	7f 92       	push	r7
    7804:	8f 92       	push	r8
    7806:	9f 92       	push	r9
    7808:	af 92       	push	r10
    780a:	bf 92       	push	r11
    780c:	cf 92       	push	r12
    780e:	df 92       	push	r13
    7810:	ef 92       	push	r14
    7812:	ff 92       	push	r15
    7814:	0f 93       	push	r16
    7816:	1f 93       	push	r17
    7818:	cf 93       	push	r28
    781a:	df 93       	push	r29
    781c:	cd b7       	in	r28, 0x3d	; 61
    781e:	de b7       	in	r29, 0x3e	; 62
    7820:	2d 97       	sbiw	r28, 0x0d	; 13
    7822:	cd bf       	out	0x3d, r28	; 61
    7824:	de bf       	out	0x3e, r29	; 62
    7826:	3c 01       	movw	r6, r24
    7828:	6c 87       	std	Y+12, r22	; 0x0c
    782a:	7d 87       	std	Y+13, r23	; 0x0d
    782c:	5a 01       	movw	r10, r20
    782e:	fc 01       	movw	r30, r24
    7830:	16 82       	std	Z+6, r1	; 0x06
    7832:	17 82       	std	Z+7, r1	; 0x07
    7834:	83 81       	ldd	r24, Z+3	; 0x03
    7836:	81 ff       	sbrs	r24, 1
    7838:	c8 c1       	rjmp	.+912    	; 0x7bca <vfprintf+0x3d2>
    783a:	2e 01       	movw	r4, r28
    783c:	08 94       	sec
    783e:	41 1c       	adc	r4, r1
    7840:	51 1c       	adc	r5, r1
    7842:	f3 01       	movw	r30, r6
    7844:	93 81       	ldd	r25, Z+3	; 0x03
    7846:	ec 85       	ldd	r30, Y+12	; 0x0c
    7848:	fd 85       	ldd	r31, Y+13	; 0x0d
    784a:	93 fd       	sbrc	r25, 3
    784c:	85 91       	lpm	r24, Z+
    784e:	93 ff       	sbrs	r25, 3
    7850:	81 91       	ld	r24, Z+
    7852:	ec 87       	std	Y+12, r30	; 0x0c
    7854:	fd 87       	std	Y+13, r31	; 0x0d
    7856:	88 23       	and	r24, r24
    7858:	09 f4       	brne	.+2      	; 0x785c <vfprintf+0x64>
    785a:	b3 c1       	rjmp	.+870    	; 0x7bc2 <vfprintf+0x3ca>
    785c:	85 32       	cpi	r24, 0x25	; 37
    785e:	41 f4       	brne	.+16     	; 0x7870 <vfprintf+0x78>
    7860:	93 fd       	sbrc	r25, 3
    7862:	85 91       	lpm	r24, Z+
    7864:	93 ff       	sbrs	r25, 3
    7866:	81 91       	ld	r24, Z+
    7868:	ec 87       	std	Y+12, r30	; 0x0c
    786a:	fd 87       	std	Y+13, r31	; 0x0d
    786c:	85 32       	cpi	r24, 0x25	; 37
    786e:	29 f4       	brne	.+10     	; 0x787a <vfprintf+0x82>
    7870:	90 e0       	ldi	r25, 0x00	; 0
    7872:	b3 01       	movw	r22, r6
    7874:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    7878:	e4 cf       	rjmp	.-56     	; 0x7842 <vfprintf+0x4a>
    787a:	ff 24       	eor	r15, r15
    787c:	ee 24       	eor	r14, r14
    787e:	10 e0       	ldi	r17, 0x00	; 0
    7880:	10 32       	cpi	r17, 0x20	; 32
    7882:	b0 f4       	brcc	.+44     	; 0x78b0 <vfprintf+0xb8>
    7884:	8b 32       	cpi	r24, 0x2B	; 43
    7886:	69 f0       	breq	.+26     	; 0x78a2 <vfprintf+0xaa>
    7888:	8c 32       	cpi	r24, 0x2C	; 44
    788a:	28 f4       	brcc	.+10     	; 0x7896 <vfprintf+0x9e>
    788c:	80 32       	cpi	r24, 0x20	; 32
    788e:	51 f0       	breq	.+20     	; 0x78a4 <vfprintf+0xac>
    7890:	83 32       	cpi	r24, 0x23	; 35
    7892:	71 f4       	brne	.+28     	; 0x78b0 <vfprintf+0xb8>
    7894:	0b c0       	rjmp	.+22     	; 0x78ac <vfprintf+0xb4>
    7896:	8d 32       	cpi	r24, 0x2D	; 45
    7898:	39 f0       	breq	.+14     	; 0x78a8 <vfprintf+0xb0>
    789a:	80 33       	cpi	r24, 0x30	; 48
    789c:	49 f4       	brne	.+18     	; 0x78b0 <vfprintf+0xb8>
    789e:	11 60       	ori	r17, 0x01	; 1
    78a0:	2c c0       	rjmp	.+88     	; 0x78fa <vfprintf+0x102>
    78a2:	12 60       	ori	r17, 0x02	; 2
    78a4:	14 60       	ori	r17, 0x04	; 4
    78a6:	29 c0       	rjmp	.+82     	; 0x78fa <vfprintf+0x102>
    78a8:	18 60       	ori	r17, 0x08	; 8
    78aa:	27 c0       	rjmp	.+78     	; 0x78fa <vfprintf+0x102>
    78ac:	10 61       	ori	r17, 0x10	; 16
    78ae:	25 c0       	rjmp	.+74     	; 0x78fa <vfprintf+0x102>
    78b0:	17 fd       	sbrc	r17, 7
    78b2:	2e c0       	rjmp	.+92     	; 0x7910 <vfprintf+0x118>
    78b4:	28 2f       	mov	r18, r24
    78b6:	20 53       	subi	r18, 0x30	; 48
    78b8:	2a 30       	cpi	r18, 0x0A	; 10
    78ba:	98 f4       	brcc	.+38     	; 0x78e2 <vfprintf+0xea>
    78bc:	16 ff       	sbrs	r17, 6
    78be:	08 c0       	rjmp	.+16     	; 0x78d0 <vfprintf+0xd8>
    78c0:	8f 2d       	mov	r24, r15
    78c2:	88 0f       	add	r24, r24
    78c4:	f8 2e       	mov	r15, r24
    78c6:	ff 0c       	add	r15, r15
    78c8:	ff 0c       	add	r15, r15
    78ca:	f8 0e       	add	r15, r24
    78cc:	f2 0e       	add	r15, r18
    78ce:	15 c0       	rjmp	.+42     	; 0x78fa <vfprintf+0x102>
    78d0:	8e 2d       	mov	r24, r14
    78d2:	88 0f       	add	r24, r24
    78d4:	e8 2e       	mov	r14, r24
    78d6:	ee 0c       	add	r14, r14
    78d8:	ee 0c       	add	r14, r14
    78da:	e8 0e       	add	r14, r24
    78dc:	e2 0e       	add	r14, r18
    78de:	10 62       	ori	r17, 0x20	; 32
    78e0:	0c c0       	rjmp	.+24     	; 0x78fa <vfprintf+0x102>
    78e2:	8e 32       	cpi	r24, 0x2E	; 46
    78e4:	21 f4       	brne	.+8      	; 0x78ee <vfprintf+0xf6>
    78e6:	16 fd       	sbrc	r17, 6
    78e8:	6c c1       	rjmp	.+728    	; 0x7bc2 <vfprintf+0x3ca>
    78ea:	10 64       	ori	r17, 0x40	; 64
    78ec:	06 c0       	rjmp	.+12     	; 0x78fa <vfprintf+0x102>
    78ee:	8c 36       	cpi	r24, 0x6C	; 108
    78f0:	11 f4       	brne	.+4      	; 0x78f6 <vfprintf+0xfe>
    78f2:	10 68       	ori	r17, 0x80	; 128
    78f4:	02 c0       	rjmp	.+4      	; 0x78fa <vfprintf+0x102>
    78f6:	88 36       	cpi	r24, 0x68	; 104
    78f8:	59 f4       	brne	.+22     	; 0x7910 <vfprintf+0x118>
    78fa:	ec 85       	ldd	r30, Y+12	; 0x0c
    78fc:	fd 85       	ldd	r31, Y+13	; 0x0d
    78fe:	93 fd       	sbrc	r25, 3
    7900:	85 91       	lpm	r24, Z+
    7902:	93 ff       	sbrs	r25, 3
    7904:	81 91       	ld	r24, Z+
    7906:	ec 87       	std	Y+12, r30	; 0x0c
    7908:	fd 87       	std	Y+13, r31	; 0x0d
    790a:	88 23       	and	r24, r24
    790c:	09 f0       	breq	.+2      	; 0x7910 <vfprintf+0x118>
    790e:	b8 cf       	rjmp	.-144    	; 0x7880 <vfprintf+0x88>
    7910:	98 2f       	mov	r25, r24
    7912:	95 54       	subi	r25, 0x45	; 69
    7914:	93 30       	cpi	r25, 0x03	; 3
    7916:	18 f0       	brcs	.+6      	; 0x791e <vfprintf+0x126>
    7918:	90 52       	subi	r25, 0x20	; 32
    791a:	93 30       	cpi	r25, 0x03	; 3
    791c:	38 f4       	brcc	.+14     	; 0x792c <vfprintf+0x134>
    791e:	24 e0       	ldi	r18, 0x04	; 4
    7920:	30 e0       	ldi	r19, 0x00	; 0
    7922:	a2 0e       	add	r10, r18
    7924:	b3 1e       	adc	r11, r19
    7926:	3f e3       	ldi	r19, 0x3F	; 63
    7928:	39 83       	std	Y+1, r19	; 0x01
    792a:	0f c0       	rjmp	.+30     	; 0x794a <vfprintf+0x152>
    792c:	83 36       	cpi	r24, 0x63	; 99
    792e:	31 f0       	breq	.+12     	; 0x793c <vfprintf+0x144>
    7930:	83 37       	cpi	r24, 0x73	; 115
    7932:	81 f0       	breq	.+32     	; 0x7954 <vfprintf+0x15c>
    7934:	83 35       	cpi	r24, 0x53	; 83
    7936:	09 f0       	breq	.+2      	; 0x793a <vfprintf+0x142>
    7938:	5a c0       	rjmp	.+180    	; 0x79ee <vfprintf+0x1f6>
    793a:	22 c0       	rjmp	.+68     	; 0x7980 <vfprintf+0x188>
    793c:	f5 01       	movw	r30, r10
    793e:	80 81       	ld	r24, Z
    7940:	89 83       	std	Y+1, r24	; 0x01
    7942:	22 e0       	ldi	r18, 0x02	; 2
    7944:	30 e0       	ldi	r19, 0x00	; 0
    7946:	a2 0e       	add	r10, r18
    7948:	b3 1e       	adc	r11, r19
    794a:	21 e0       	ldi	r18, 0x01	; 1
    794c:	c2 2e       	mov	r12, r18
    794e:	d1 2c       	mov	r13, r1
    7950:	42 01       	movw	r8, r4
    7952:	14 c0       	rjmp	.+40     	; 0x797c <vfprintf+0x184>
    7954:	92 e0       	ldi	r25, 0x02	; 2
    7956:	29 2e       	mov	r2, r25
    7958:	31 2c       	mov	r3, r1
    795a:	2a 0c       	add	r2, r10
    795c:	3b 1c       	adc	r3, r11
    795e:	f5 01       	movw	r30, r10
    7960:	80 80       	ld	r8, Z
    7962:	91 80       	ldd	r9, Z+1	; 0x01
    7964:	16 ff       	sbrs	r17, 6
    7966:	03 c0       	rjmp	.+6      	; 0x796e <vfprintf+0x176>
    7968:	6f 2d       	mov	r22, r15
    796a:	70 e0       	ldi	r23, 0x00	; 0
    796c:	02 c0       	rjmp	.+4      	; 0x7972 <vfprintf+0x17a>
    796e:	6f ef       	ldi	r22, 0xFF	; 255
    7970:	7f ef       	ldi	r23, 0xFF	; 255
    7972:	c4 01       	movw	r24, r8
    7974:	0e 94 11 3e 	call	0x7c22	; 0x7c22 <strnlen>
    7978:	6c 01       	movw	r12, r24
    797a:	51 01       	movw	r10, r2
    797c:	1f 77       	andi	r17, 0x7F	; 127
    797e:	15 c0       	rjmp	.+42     	; 0x79aa <vfprintf+0x1b2>
    7980:	82 e0       	ldi	r24, 0x02	; 2
    7982:	28 2e       	mov	r2, r24
    7984:	31 2c       	mov	r3, r1
    7986:	2a 0c       	add	r2, r10
    7988:	3b 1c       	adc	r3, r11
    798a:	f5 01       	movw	r30, r10
    798c:	80 80       	ld	r8, Z
    798e:	91 80       	ldd	r9, Z+1	; 0x01
    7990:	16 ff       	sbrs	r17, 6
    7992:	03 c0       	rjmp	.+6      	; 0x799a <vfprintf+0x1a2>
    7994:	6f 2d       	mov	r22, r15
    7996:	70 e0       	ldi	r23, 0x00	; 0
    7998:	02 c0       	rjmp	.+4      	; 0x799e <vfprintf+0x1a6>
    799a:	6f ef       	ldi	r22, 0xFF	; 255
    799c:	7f ef       	ldi	r23, 0xFF	; 255
    799e:	c4 01       	movw	r24, r8
    79a0:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <strnlen_P>
    79a4:	6c 01       	movw	r12, r24
    79a6:	10 68       	ori	r17, 0x80	; 128
    79a8:	51 01       	movw	r10, r2
    79aa:	13 fd       	sbrc	r17, 3
    79ac:	1c c0       	rjmp	.+56     	; 0x79e6 <vfprintf+0x1ee>
    79ae:	06 c0       	rjmp	.+12     	; 0x79bc <vfprintf+0x1c4>
    79b0:	80 e2       	ldi	r24, 0x20	; 32
    79b2:	90 e0       	ldi	r25, 0x00	; 0
    79b4:	b3 01       	movw	r22, r6
    79b6:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    79ba:	ea 94       	dec	r14
    79bc:	8e 2d       	mov	r24, r14
    79be:	90 e0       	ldi	r25, 0x00	; 0
    79c0:	c8 16       	cp	r12, r24
    79c2:	d9 06       	cpc	r13, r25
    79c4:	a8 f3       	brcs	.-22     	; 0x79b0 <vfprintf+0x1b8>
    79c6:	0f c0       	rjmp	.+30     	; 0x79e6 <vfprintf+0x1ee>
    79c8:	f4 01       	movw	r30, r8
    79ca:	17 fd       	sbrc	r17, 7
    79cc:	85 91       	lpm	r24, Z+
    79ce:	17 ff       	sbrs	r17, 7
    79d0:	81 91       	ld	r24, Z+
    79d2:	4f 01       	movw	r8, r30
    79d4:	90 e0       	ldi	r25, 0x00	; 0
    79d6:	b3 01       	movw	r22, r6
    79d8:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    79dc:	e1 10       	cpse	r14, r1
    79de:	ea 94       	dec	r14
    79e0:	08 94       	sec
    79e2:	c1 08       	sbc	r12, r1
    79e4:	d1 08       	sbc	r13, r1
    79e6:	c1 14       	cp	r12, r1
    79e8:	d1 04       	cpc	r13, r1
    79ea:	71 f7       	brne	.-36     	; 0x79c8 <vfprintf+0x1d0>
    79ec:	e7 c0       	rjmp	.+462    	; 0x7bbc <vfprintf+0x3c4>
    79ee:	84 36       	cpi	r24, 0x64	; 100
    79f0:	11 f0       	breq	.+4      	; 0x79f6 <vfprintf+0x1fe>
    79f2:	89 36       	cpi	r24, 0x69	; 105
    79f4:	51 f5       	brne	.+84     	; 0x7a4a <vfprintf+0x252>
    79f6:	f5 01       	movw	r30, r10
    79f8:	17 ff       	sbrs	r17, 7
    79fa:	07 c0       	rjmp	.+14     	; 0x7a0a <vfprintf+0x212>
    79fc:	80 81       	ld	r24, Z
    79fe:	91 81       	ldd	r25, Z+1	; 0x01
    7a00:	a2 81       	ldd	r26, Z+2	; 0x02
    7a02:	b3 81       	ldd	r27, Z+3	; 0x03
    7a04:	24 e0       	ldi	r18, 0x04	; 4
    7a06:	30 e0       	ldi	r19, 0x00	; 0
    7a08:	08 c0       	rjmp	.+16     	; 0x7a1a <vfprintf+0x222>
    7a0a:	80 81       	ld	r24, Z
    7a0c:	91 81       	ldd	r25, Z+1	; 0x01
    7a0e:	aa 27       	eor	r26, r26
    7a10:	97 fd       	sbrc	r25, 7
    7a12:	a0 95       	com	r26
    7a14:	ba 2f       	mov	r27, r26
    7a16:	22 e0       	ldi	r18, 0x02	; 2
    7a18:	30 e0       	ldi	r19, 0x00	; 0
    7a1a:	a2 0e       	add	r10, r18
    7a1c:	b3 1e       	adc	r11, r19
    7a1e:	01 2f       	mov	r16, r17
    7a20:	0f 76       	andi	r16, 0x6F	; 111
    7a22:	b7 ff       	sbrs	r27, 7
    7a24:	08 c0       	rjmp	.+16     	; 0x7a36 <vfprintf+0x23e>
    7a26:	b0 95       	com	r27
    7a28:	a0 95       	com	r26
    7a2a:	90 95       	com	r25
    7a2c:	81 95       	neg	r24
    7a2e:	9f 4f       	sbci	r25, 0xFF	; 255
    7a30:	af 4f       	sbci	r26, 0xFF	; 255
    7a32:	bf 4f       	sbci	r27, 0xFF	; 255
    7a34:	00 68       	ori	r16, 0x80	; 128
    7a36:	bc 01       	movw	r22, r24
    7a38:	cd 01       	movw	r24, r26
    7a3a:	a2 01       	movw	r20, r4
    7a3c:	2a e0       	ldi	r18, 0x0A	; 10
    7a3e:	30 e0       	ldi	r19, 0x00	; 0
    7a40:	0e 94 58 3e 	call	0x7cb0	; 0x7cb0 <__ultoa_invert>
    7a44:	d8 2e       	mov	r13, r24
    7a46:	d4 18       	sub	r13, r4
    7a48:	3f c0       	rjmp	.+126    	; 0x7ac8 <vfprintf+0x2d0>
    7a4a:	85 37       	cpi	r24, 0x75	; 117
    7a4c:	21 f4       	brne	.+8      	; 0x7a56 <vfprintf+0x25e>
    7a4e:	1f 7e       	andi	r17, 0xEF	; 239
    7a50:	2a e0       	ldi	r18, 0x0A	; 10
    7a52:	30 e0       	ldi	r19, 0x00	; 0
    7a54:	20 c0       	rjmp	.+64     	; 0x7a96 <vfprintf+0x29e>
    7a56:	19 7f       	andi	r17, 0xF9	; 249
    7a58:	8f 36       	cpi	r24, 0x6F	; 111
    7a5a:	a9 f0       	breq	.+42     	; 0x7a86 <vfprintf+0x28e>
    7a5c:	80 37       	cpi	r24, 0x70	; 112
    7a5e:	20 f4       	brcc	.+8      	; 0x7a68 <vfprintf+0x270>
    7a60:	88 35       	cpi	r24, 0x58	; 88
    7a62:	09 f0       	breq	.+2      	; 0x7a66 <vfprintf+0x26e>
    7a64:	ae c0       	rjmp	.+348    	; 0x7bc2 <vfprintf+0x3ca>
    7a66:	0b c0       	rjmp	.+22     	; 0x7a7e <vfprintf+0x286>
    7a68:	80 37       	cpi	r24, 0x70	; 112
    7a6a:	21 f0       	breq	.+8      	; 0x7a74 <vfprintf+0x27c>
    7a6c:	88 37       	cpi	r24, 0x78	; 120
    7a6e:	09 f0       	breq	.+2      	; 0x7a72 <vfprintf+0x27a>
    7a70:	a8 c0       	rjmp	.+336    	; 0x7bc2 <vfprintf+0x3ca>
    7a72:	01 c0       	rjmp	.+2      	; 0x7a76 <vfprintf+0x27e>
    7a74:	10 61       	ori	r17, 0x10	; 16
    7a76:	14 ff       	sbrs	r17, 4
    7a78:	09 c0       	rjmp	.+18     	; 0x7a8c <vfprintf+0x294>
    7a7a:	14 60       	ori	r17, 0x04	; 4
    7a7c:	07 c0       	rjmp	.+14     	; 0x7a8c <vfprintf+0x294>
    7a7e:	14 ff       	sbrs	r17, 4
    7a80:	08 c0       	rjmp	.+16     	; 0x7a92 <vfprintf+0x29a>
    7a82:	16 60       	ori	r17, 0x06	; 6
    7a84:	06 c0       	rjmp	.+12     	; 0x7a92 <vfprintf+0x29a>
    7a86:	28 e0       	ldi	r18, 0x08	; 8
    7a88:	30 e0       	ldi	r19, 0x00	; 0
    7a8a:	05 c0       	rjmp	.+10     	; 0x7a96 <vfprintf+0x29e>
    7a8c:	20 e1       	ldi	r18, 0x10	; 16
    7a8e:	30 e0       	ldi	r19, 0x00	; 0
    7a90:	02 c0       	rjmp	.+4      	; 0x7a96 <vfprintf+0x29e>
    7a92:	20 e1       	ldi	r18, 0x10	; 16
    7a94:	32 e0       	ldi	r19, 0x02	; 2
    7a96:	f5 01       	movw	r30, r10
    7a98:	17 ff       	sbrs	r17, 7
    7a9a:	07 c0       	rjmp	.+14     	; 0x7aaa <vfprintf+0x2b2>
    7a9c:	60 81       	ld	r22, Z
    7a9e:	71 81       	ldd	r23, Z+1	; 0x01
    7aa0:	82 81       	ldd	r24, Z+2	; 0x02
    7aa2:	93 81       	ldd	r25, Z+3	; 0x03
    7aa4:	44 e0       	ldi	r20, 0x04	; 4
    7aa6:	50 e0       	ldi	r21, 0x00	; 0
    7aa8:	06 c0       	rjmp	.+12     	; 0x7ab6 <vfprintf+0x2be>
    7aaa:	60 81       	ld	r22, Z
    7aac:	71 81       	ldd	r23, Z+1	; 0x01
    7aae:	80 e0       	ldi	r24, 0x00	; 0
    7ab0:	90 e0       	ldi	r25, 0x00	; 0
    7ab2:	42 e0       	ldi	r20, 0x02	; 2
    7ab4:	50 e0       	ldi	r21, 0x00	; 0
    7ab6:	a4 0e       	add	r10, r20
    7ab8:	b5 1e       	adc	r11, r21
    7aba:	a2 01       	movw	r20, r4
    7abc:	0e 94 58 3e 	call	0x7cb0	; 0x7cb0 <__ultoa_invert>
    7ac0:	d8 2e       	mov	r13, r24
    7ac2:	d4 18       	sub	r13, r4
    7ac4:	01 2f       	mov	r16, r17
    7ac6:	0f 77       	andi	r16, 0x7F	; 127
    7ac8:	06 ff       	sbrs	r16, 6
    7aca:	09 c0       	rjmp	.+18     	; 0x7ade <vfprintf+0x2e6>
    7acc:	0e 7f       	andi	r16, 0xFE	; 254
    7ace:	df 14       	cp	r13, r15
    7ad0:	30 f4       	brcc	.+12     	; 0x7ade <vfprintf+0x2e6>
    7ad2:	04 ff       	sbrs	r16, 4
    7ad4:	06 c0       	rjmp	.+12     	; 0x7ae2 <vfprintf+0x2ea>
    7ad6:	02 fd       	sbrc	r16, 2
    7ad8:	04 c0       	rjmp	.+8      	; 0x7ae2 <vfprintf+0x2ea>
    7ada:	0f 7e       	andi	r16, 0xEF	; 239
    7adc:	02 c0       	rjmp	.+4      	; 0x7ae2 <vfprintf+0x2ea>
    7ade:	1d 2d       	mov	r17, r13
    7ae0:	01 c0       	rjmp	.+2      	; 0x7ae4 <vfprintf+0x2ec>
    7ae2:	1f 2d       	mov	r17, r15
    7ae4:	80 2f       	mov	r24, r16
    7ae6:	90 e0       	ldi	r25, 0x00	; 0
    7ae8:	04 ff       	sbrs	r16, 4
    7aea:	0c c0       	rjmp	.+24     	; 0x7b04 <vfprintf+0x30c>
    7aec:	fe 01       	movw	r30, r28
    7aee:	ed 0d       	add	r30, r13
    7af0:	f1 1d       	adc	r31, r1
    7af2:	20 81       	ld	r18, Z
    7af4:	20 33       	cpi	r18, 0x30	; 48
    7af6:	11 f4       	brne	.+4      	; 0x7afc <vfprintf+0x304>
    7af8:	09 7e       	andi	r16, 0xE9	; 233
    7afa:	09 c0       	rjmp	.+18     	; 0x7b0e <vfprintf+0x316>
    7afc:	02 ff       	sbrs	r16, 2
    7afe:	06 c0       	rjmp	.+12     	; 0x7b0c <vfprintf+0x314>
    7b00:	1e 5f       	subi	r17, 0xFE	; 254
    7b02:	05 c0       	rjmp	.+10     	; 0x7b0e <vfprintf+0x316>
    7b04:	86 78       	andi	r24, 0x86	; 134
    7b06:	90 70       	andi	r25, 0x00	; 0
    7b08:	00 97       	sbiw	r24, 0x00	; 0
    7b0a:	09 f0       	breq	.+2      	; 0x7b0e <vfprintf+0x316>
    7b0c:	1f 5f       	subi	r17, 0xFF	; 255
    7b0e:	80 2e       	mov	r8, r16
    7b10:	99 24       	eor	r9, r9
    7b12:	03 fd       	sbrc	r16, 3
    7b14:	12 c0       	rjmp	.+36     	; 0x7b3a <vfprintf+0x342>
    7b16:	00 ff       	sbrs	r16, 0
    7b18:	0d c0       	rjmp	.+26     	; 0x7b34 <vfprintf+0x33c>
    7b1a:	fd 2c       	mov	r15, r13
    7b1c:	1e 15       	cp	r17, r14
    7b1e:	50 f4       	brcc	.+20     	; 0x7b34 <vfprintf+0x33c>
    7b20:	fe 0c       	add	r15, r14
    7b22:	f1 1a       	sub	r15, r17
    7b24:	1e 2d       	mov	r17, r14
    7b26:	06 c0       	rjmp	.+12     	; 0x7b34 <vfprintf+0x33c>
    7b28:	80 e2       	ldi	r24, 0x20	; 32
    7b2a:	90 e0       	ldi	r25, 0x00	; 0
    7b2c:	b3 01       	movw	r22, r6
    7b2e:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    7b32:	1f 5f       	subi	r17, 0xFF	; 255
    7b34:	1e 15       	cp	r17, r14
    7b36:	c0 f3       	brcs	.-16     	; 0x7b28 <vfprintf+0x330>
    7b38:	04 c0       	rjmp	.+8      	; 0x7b42 <vfprintf+0x34a>
    7b3a:	1e 15       	cp	r17, r14
    7b3c:	10 f4       	brcc	.+4      	; 0x7b42 <vfprintf+0x34a>
    7b3e:	e1 1a       	sub	r14, r17
    7b40:	01 c0       	rjmp	.+2      	; 0x7b44 <vfprintf+0x34c>
    7b42:	ee 24       	eor	r14, r14
    7b44:	84 fe       	sbrs	r8, 4
    7b46:	0f c0       	rjmp	.+30     	; 0x7b66 <vfprintf+0x36e>
    7b48:	80 e3       	ldi	r24, 0x30	; 48
    7b4a:	90 e0       	ldi	r25, 0x00	; 0
    7b4c:	b3 01       	movw	r22, r6
    7b4e:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    7b52:	82 fe       	sbrs	r8, 2
    7b54:	1f c0       	rjmp	.+62     	; 0x7b94 <vfprintf+0x39c>
    7b56:	81 fe       	sbrs	r8, 1
    7b58:	03 c0       	rjmp	.+6      	; 0x7b60 <vfprintf+0x368>
    7b5a:	88 e5       	ldi	r24, 0x58	; 88
    7b5c:	90 e0       	ldi	r25, 0x00	; 0
    7b5e:	10 c0       	rjmp	.+32     	; 0x7b80 <vfprintf+0x388>
    7b60:	88 e7       	ldi	r24, 0x78	; 120
    7b62:	90 e0       	ldi	r25, 0x00	; 0
    7b64:	0d c0       	rjmp	.+26     	; 0x7b80 <vfprintf+0x388>
    7b66:	c4 01       	movw	r24, r8
    7b68:	86 78       	andi	r24, 0x86	; 134
    7b6a:	90 70       	andi	r25, 0x00	; 0
    7b6c:	00 97       	sbiw	r24, 0x00	; 0
    7b6e:	91 f0       	breq	.+36     	; 0x7b94 <vfprintf+0x39c>
    7b70:	81 fc       	sbrc	r8, 1
    7b72:	02 c0       	rjmp	.+4      	; 0x7b78 <vfprintf+0x380>
    7b74:	80 e2       	ldi	r24, 0x20	; 32
    7b76:	01 c0       	rjmp	.+2      	; 0x7b7a <vfprintf+0x382>
    7b78:	8b e2       	ldi	r24, 0x2B	; 43
    7b7a:	07 fd       	sbrc	r16, 7
    7b7c:	8d e2       	ldi	r24, 0x2D	; 45
    7b7e:	90 e0       	ldi	r25, 0x00	; 0
    7b80:	b3 01       	movw	r22, r6
    7b82:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    7b86:	06 c0       	rjmp	.+12     	; 0x7b94 <vfprintf+0x39c>
    7b88:	80 e3       	ldi	r24, 0x30	; 48
    7b8a:	90 e0       	ldi	r25, 0x00	; 0
    7b8c:	b3 01       	movw	r22, r6
    7b8e:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    7b92:	fa 94       	dec	r15
    7b94:	df 14       	cp	r13, r15
    7b96:	c0 f3       	brcs	.-16     	; 0x7b88 <vfprintf+0x390>
    7b98:	da 94       	dec	r13
    7b9a:	f2 01       	movw	r30, r4
    7b9c:	ed 0d       	add	r30, r13
    7b9e:	f1 1d       	adc	r31, r1
    7ba0:	80 81       	ld	r24, Z
    7ba2:	90 e0       	ldi	r25, 0x00	; 0
    7ba4:	b3 01       	movw	r22, r6
    7ba6:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    7baa:	dd 20       	and	r13, r13
    7bac:	a9 f7       	brne	.-22     	; 0x7b98 <vfprintf+0x3a0>
    7bae:	06 c0       	rjmp	.+12     	; 0x7bbc <vfprintf+0x3c4>
    7bb0:	80 e2       	ldi	r24, 0x20	; 32
    7bb2:	90 e0       	ldi	r25, 0x00	; 0
    7bb4:	b3 01       	movw	r22, r6
    7bb6:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <fputc>
    7bba:	ea 94       	dec	r14
    7bbc:	ee 20       	and	r14, r14
    7bbe:	c1 f7       	brne	.-16     	; 0x7bb0 <vfprintf+0x3b8>
    7bc0:	40 ce       	rjmp	.-896    	; 0x7842 <vfprintf+0x4a>
    7bc2:	f3 01       	movw	r30, r6
    7bc4:	86 81       	ldd	r24, Z+6	; 0x06
    7bc6:	97 81       	ldd	r25, Z+7	; 0x07
    7bc8:	02 c0       	rjmp	.+4      	; 0x7bce <vfprintf+0x3d6>
    7bca:	8f ef       	ldi	r24, 0xFF	; 255
    7bcc:	9f ef       	ldi	r25, 0xFF	; 255
    7bce:	2d 96       	adiw	r28, 0x0d	; 13
    7bd0:	cd bf       	out	0x3d, r28	; 61
    7bd2:	de bf       	out	0x3e, r29	; 62
    7bd4:	df 91       	pop	r29
    7bd6:	cf 91       	pop	r28
    7bd8:	1f 91       	pop	r17
    7bda:	0f 91       	pop	r16
    7bdc:	ff 90       	pop	r15
    7bde:	ef 90       	pop	r14
    7be0:	df 90       	pop	r13
    7be2:	cf 90       	pop	r12
    7be4:	bf 90       	pop	r11
    7be6:	af 90       	pop	r10
    7be8:	9f 90       	pop	r9
    7bea:	8f 90       	pop	r8
    7bec:	7f 90       	pop	r7
    7bee:	6f 90       	pop	r6
    7bf0:	5f 90       	pop	r5
    7bf2:	4f 90       	pop	r4
    7bf4:	3f 90       	pop	r3
    7bf6:	2f 90       	pop	r2
    7bf8:	08 95       	ret

00007bfa <strnlen_P>:
    7bfa:	fc 01       	movw	r30, r24
    7bfc:	05 90       	lpm	r0, Z+
    7bfe:	61 50       	subi	r22, 0x01	; 1
    7c00:	70 40       	sbci	r23, 0x00	; 0
    7c02:	01 10       	cpse	r0, r1
    7c04:	d8 f7       	brcc	.-10     	; 0x7bfc <strnlen_P+0x2>
    7c06:	80 95       	com	r24
    7c08:	90 95       	com	r25
    7c0a:	8e 0f       	add	r24, r30
    7c0c:	9f 1f       	adc	r25, r31
    7c0e:	08 95       	ret

00007c10 <memcpy>:
    7c10:	fb 01       	movw	r30, r22
    7c12:	dc 01       	movw	r26, r24
    7c14:	02 c0       	rjmp	.+4      	; 0x7c1a <memcpy+0xa>
    7c16:	01 90       	ld	r0, Z+
    7c18:	0d 92       	st	X+, r0
    7c1a:	41 50       	subi	r20, 0x01	; 1
    7c1c:	50 40       	sbci	r21, 0x00	; 0
    7c1e:	d8 f7       	brcc	.-10     	; 0x7c16 <memcpy+0x6>
    7c20:	08 95       	ret

00007c22 <strnlen>:
    7c22:	fc 01       	movw	r30, r24
    7c24:	61 50       	subi	r22, 0x01	; 1
    7c26:	70 40       	sbci	r23, 0x00	; 0
    7c28:	01 90       	ld	r0, Z+
    7c2a:	01 10       	cpse	r0, r1
    7c2c:	d8 f7       	brcc	.-10     	; 0x7c24 <strnlen+0x2>
    7c2e:	80 95       	com	r24
    7c30:	90 95       	com	r25
    7c32:	8e 0f       	add	r24, r30
    7c34:	9f 1f       	adc	r25, r31
    7c36:	08 95       	ret

00007c38 <strrev>:
    7c38:	dc 01       	movw	r26, r24
    7c3a:	fc 01       	movw	r30, r24
    7c3c:	67 2f       	mov	r22, r23
    7c3e:	71 91       	ld	r23, Z+
    7c40:	77 23       	and	r23, r23
    7c42:	e1 f7       	brne	.-8      	; 0x7c3c <strrev+0x4>
    7c44:	32 97       	sbiw	r30, 0x02	; 2
    7c46:	04 c0       	rjmp	.+8      	; 0x7c50 <strrev+0x18>
    7c48:	7c 91       	ld	r23, X
    7c4a:	6d 93       	st	X+, r22
    7c4c:	70 83       	st	Z, r23
    7c4e:	62 91       	ld	r22, -Z
    7c50:	ae 17       	cp	r26, r30
    7c52:	bf 07       	cpc	r27, r31
    7c54:	c8 f3       	brcs	.-14     	; 0x7c48 <strrev+0x10>
    7c56:	08 95       	ret

00007c58 <fputc>:
    7c58:	0f 93       	push	r16
    7c5a:	1f 93       	push	r17
    7c5c:	cf 93       	push	r28
    7c5e:	df 93       	push	r29
    7c60:	8c 01       	movw	r16, r24
    7c62:	eb 01       	movw	r28, r22
    7c64:	8b 81       	ldd	r24, Y+3	; 0x03
    7c66:	81 ff       	sbrs	r24, 1
    7c68:	1b c0       	rjmp	.+54     	; 0x7ca0 <fputc+0x48>
    7c6a:	82 ff       	sbrs	r24, 2
    7c6c:	0d c0       	rjmp	.+26     	; 0x7c88 <fputc+0x30>
    7c6e:	2e 81       	ldd	r18, Y+6	; 0x06
    7c70:	3f 81       	ldd	r19, Y+7	; 0x07
    7c72:	8c 81       	ldd	r24, Y+4	; 0x04
    7c74:	9d 81       	ldd	r25, Y+5	; 0x05
    7c76:	28 17       	cp	r18, r24
    7c78:	39 07       	cpc	r19, r25
    7c7a:	64 f4       	brge	.+24     	; 0x7c94 <fputc+0x3c>
    7c7c:	e8 81       	ld	r30, Y
    7c7e:	f9 81       	ldd	r31, Y+1	; 0x01
    7c80:	01 93       	st	Z+, r16
    7c82:	e8 83       	st	Y, r30
    7c84:	f9 83       	std	Y+1, r31	; 0x01
    7c86:	06 c0       	rjmp	.+12     	; 0x7c94 <fputc+0x3c>
    7c88:	e8 85       	ldd	r30, Y+8	; 0x08
    7c8a:	f9 85       	ldd	r31, Y+9	; 0x09
    7c8c:	80 2f       	mov	r24, r16
    7c8e:	19 95       	eicall
    7c90:	00 97       	sbiw	r24, 0x00	; 0
    7c92:	31 f4       	brne	.+12     	; 0x7ca0 <fputc+0x48>
    7c94:	8e 81       	ldd	r24, Y+6	; 0x06
    7c96:	9f 81       	ldd	r25, Y+7	; 0x07
    7c98:	01 96       	adiw	r24, 0x01	; 1
    7c9a:	8e 83       	std	Y+6, r24	; 0x06
    7c9c:	9f 83       	std	Y+7, r25	; 0x07
    7c9e:	02 c0       	rjmp	.+4      	; 0x7ca4 <fputc+0x4c>
    7ca0:	0f ef       	ldi	r16, 0xFF	; 255
    7ca2:	1f ef       	ldi	r17, 0xFF	; 255
    7ca4:	c8 01       	movw	r24, r16
    7ca6:	df 91       	pop	r29
    7ca8:	cf 91       	pop	r28
    7caa:	1f 91       	pop	r17
    7cac:	0f 91       	pop	r16
    7cae:	08 95       	ret

00007cb0 <__ultoa_invert>:
    7cb0:	fa 01       	movw	r30, r20
    7cb2:	aa 27       	eor	r26, r26
    7cb4:	28 30       	cpi	r18, 0x08	; 8
    7cb6:	51 f1       	breq	.+84     	; 0x7d0c <__ultoa_invert+0x5c>
    7cb8:	20 31       	cpi	r18, 0x10	; 16
    7cba:	81 f1       	breq	.+96     	; 0x7d1c <__ultoa_invert+0x6c>
    7cbc:	e8 94       	clt
    7cbe:	6f 93       	push	r22
    7cc0:	6e 7f       	andi	r22, 0xFE	; 254
    7cc2:	6e 5f       	subi	r22, 0xFE	; 254
    7cc4:	7f 4f       	sbci	r23, 0xFF	; 255
    7cc6:	8f 4f       	sbci	r24, 0xFF	; 255
    7cc8:	9f 4f       	sbci	r25, 0xFF	; 255
    7cca:	af 4f       	sbci	r26, 0xFF	; 255
    7ccc:	b1 e0       	ldi	r27, 0x01	; 1
    7cce:	3e d0       	rcall	.+124    	; 0x7d4c <__ultoa_invert+0x9c>
    7cd0:	b4 e0       	ldi	r27, 0x04	; 4
    7cd2:	3c d0       	rcall	.+120    	; 0x7d4c <__ultoa_invert+0x9c>
    7cd4:	67 0f       	add	r22, r23
    7cd6:	78 1f       	adc	r23, r24
    7cd8:	89 1f       	adc	r24, r25
    7cda:	9a 1f       	adc	r25, r26
    7cdc:	a1 1d       	adc	r26, r1
    7cde:	68 0f       	add	r22, r24
    7ce0:	79 1f       	adc	r23, r25
    7ce2:	8a 1f       	adc	r24, r26
    7ce4:	91 1d       	adc	r25, r1
    7ce6:	a1 1d       	adc	r26, r1
    7ce8:	6a 0f       	add	r22, r26
    7cea:	71 1d       	adc	r23, r1
    7cec:	81 1d       	adc	r24, r1
    7cee:	91 1d       	adc	r25, r1
    7cf0:	a1 1d       	adc	r26, r1
    7cf2:	20 d0       	rcall	.+64     	; 0x7d34 <__ultoa_invert+0x84>
    7cf4:	09 f4       	brne	.+2      	; 0x7cf8 <__ultoa_invert+0x48>
    7cf6:	68 94       	set
    7cf8:	3f 91       	pop	r19
    7cfa:	2a e0       	ldi	r18, 0x0A	; 10
    7cfc:	26 9f       	mul	r18, r22
    7cfe:	11 24       	eor	r1, r1
    7d00:	30 19       	sub	r19, r0
    7d02:	30 5d       	subi	r19, 0xD0	; 208
    7d04:	31 93       	st	Z+, r19
    7d06:	de f6       	brtc	.-74     	; 0x7cbe <__ultoa_invert+0xe>
    7d08:	cf 01       	movw	r24, r30
    7d0a:	08 95       	ret
    7d0c:	46 2f       	mov	r20, r22
    7d0e:	47 70       	andi	r20, 0x07	; 7
    7d10:	40 5d       	subi	r20, 0xD0	; 208
    7d12:	41 93       	st	Z+, r20
    7d14:	b3 e0       	ldi	r27, 0x03	; 3
    7d16:	0f d0       	rcall	.+30     	; 0x7d36 <__ultoa_invert+0x86>
    7d18:	c9 f7       	brne	.-14     	; 0x7d0c <__ultoa_invert+0x5c>
    7d1a:	f6 cf       	rjmp	.-20     	; 0x7d08 <__ultoa_invert+0x58>
    7d1c:	46 2f       	mov	r20, r22
    7d1e:	4f 70       	andi	r20, 0x0F	; 15
    7d20:	40 5d       	subi	r20, 0xD0	; 208
    7d22:	4a 33       	cpi	r20, 0x3A	; 58
    7d24:	18 f0       	brcs	.+6      	; 0x7d2c <__ultoa_invert+0x7c>
    7d26:	49 5d       	subi	r20, 0xD9	; 217
    7d28:	31 fd       	sbrc	r19, 1
    7d2a:	40 52       	subi	r20, 0x20	; 32
    7d2c:	41 93       	st	Z+, r20
    7d2e:	02 d0       	rcall	.+4      	; 0x7d34 <__ultoa_invert+0x84>
    7d30:	a9 f7       	brne	.-22     	; 0x7d1c <__ultoa_invert+0x6c>
    7d32:	ea cf       	rjmp	.-44     	; 0x7d08 <__ultoa_invert+0x58>
    7d34:	b4 e0       	ldi	r27, 0x04	; 4
    7d36:	a6 95       	lsr	r26
    7d38:	97 95       	ror	r25
    7d3a:	87 95       	ror	r24
    7d3c:	77 95       	ror	r23
    7d3e:	67 95       	ror	r22
    7d40:	ba 95       	dec	r27
    7d42:	c9 f7       	brne	.-14     	; 0x7d36 <__ultoa_invert+0x86>
    7d44:	00 97       	sbiw	r24, 0x00	; 0
    7d46:	61 05       	cpc	r22, r1
    7d48:	71 05       	cpc	r23, r1
    7d4a:	08 95       	ret
    7d4c:	9b 01       	movw	r18, r22
    7d4e:	ac 01       	movw	r20, r24
    7d50:	0a 2e       	mov	r0, r26
    7d52:	06 94       	lsr	r0
    7d54:	57 95       	ror	r21
    7d56:	47 95       	ror	r20
    7d58:	37 95       	ror	r19
    7d5a:	27 95       	ror	r18
    7d5c:	ba 95       	dec	r27
    7d5e:	c9 f7       	brne	.-14     	; 0x7d52 <__ultoa_invert+0xa2>
    7d60:	62 0f       	add	r22, r18
    7d62:	73 1f       	adc	r23, r19
    7d64:	84 1f       	adc	r24, r20
    7d66:	95 1f       	adc	r25, r21
    7d68:	a0 1d       	adc	r26, r0
    7d6a:	08 95       	ret

00007d6c <_exit>:
    7d6c:	f8 94       	cli

00007d6e <__stop_program>:
    7d6e:	ff cf       	rjmp	.-2      	; 0x7d6e <__stop_program>
