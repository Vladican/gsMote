
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c54a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000128  00802000  0000c54a  0000c5de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fbc  00802128  00802128  0000c706  2**0
                  ALLOC
  3 .stab         00002784  00000000  00000000  0000c708  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a8c  00000000  00000000  0000ee8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  0000f918  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c6eb  00000000  00000000  0000fcd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002156  00000000  00000000  0001c3c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003de9  00000000  00000000  0001e519  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c38  00000000  00000000  00022304  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000458f  00000000  00000000  00023f3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000051b0  00000000  00000000  000284cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0002d67b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 56 14 	jmp	0x28ac	; 0x28ac <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 6a 13 	jmp	0x26d4	; 0x26d4 <__vector_16>
      44:	0c 94 9a 13 	jmp	0x2734	; 0x2734 <__vector_17>
      48:	0c 94 ca 13 	jmp	0x2794	; 0x2794 <__vector_18>
      4c:	0c 94 fa 13 	jmp	0x27f4	; 0x27f4 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 ae 40 	jmp	0x815c	; 0x815c <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 13 30 	jmp	0x6026	; 0x6026 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 5b 16 	jmp	0x2cb6	; 0x2cb6 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 99 15 	jmp	0x2b32	; 0x2b32 <__vector_79>
     140:	0c 94 c9 15 	jmp	0x2b92	; 0x2b92 <__vector_80>
     144:	0c 94 f9 15 	jmp	0x2bf2	; 0x2bf2 <__vector_81>
     148:	0c 94 29 16 	jmp	0x2c52	; 0x2c52 <__vector_82>
     14c:	0c 94 ce 01 	jmp	0x39c	; 0x39c <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 75 10 	jmp	0x20ea	; 0x20ea <__vector_104>
     1a4:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ea e4       	ldi	r30, 0x4A	; 74
     244:	f5 ec       	ldi	r31, 0xC5	; 197
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 32       	cpi	r26, 0x28	; 40
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e2       	ldi	r26, 0x28	; 40
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a4 3e       	cpi	r26, 0xE4	; 228
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 39 01 	call	0x272	; 0x272 <main>
     26a:	0c 94 a3 62 	jmp	0xc546	; 0xc546 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <main>:
 * Created: 1/29/2013 2:50:50 PM
 *  Author: Vlad
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	0f 92       	push	r0
     278:	0f 92       	push	r0
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
	chb_init();
     27e:	0e 94 42 20 	call	0x4084	; 0x4084 <chb_init>
	SD_init();
     282:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_init>
	getBootSectorData();
     286:	0e 94 86 41 	call	0x830c	; 0x830c <getBootSectorData>
	uint16_t MotesInSystem = 2;
     28a:	82 e0       	ldi	r24, 0x02	; 2
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	89 83       	std	Y+1, r24	; 0x01
     290:	9a 83       	std	Y+2, r25	; 0x02
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     292:	28 c0       	rjmp	.+80     	; 0x2e4 <main+0x72>
			//store samples in SD card as they come in
			if(StartOfFreeSpace >= 512){
     294:	80 91 ca 50 	lds	r24, 0x50CA
     298:	90 91 cb 50 	lds	r25, 0x50CB
     29c:	a0 91 cc 50 	lds	r26, 0x50CC
     2a0:	b0 91 cd 50 	lds	r27, 0x50CD
     2a4:	80 30       	cpi	r24, 0x00	; 0
     2a6:	22 e0       	ldi	r18, 0x02	; 2
     2a8:	92 07       	cpc	r25, r18
     2aa:	20 e0       	ldi	r18, 0x00	; 0
     2ac:	a2 07       	cpc	r26, r18
     2ae:	20 e0       	ldi	r18, 0x00	; 0
     2b0:	b2 07       	cpc	r27, r18
     2b2:	c0 f0       	brcs	.+48     	; 0x2e4 <main+0x72>
				cli();
     2b4:	f8 94       	cli
				//atomically write the data that accumulated in the FRAM buffer to the SD card
				writeFile("DATA",FRAMReadBuffer,StartOfFreeSpace);						
     2b6:	20 91 ca 50 	lds	r18, 0x50CA
     2ba:	30 91 cb 50 	lds	r19, 0x50CB
     2be:	40 91 cc 50 	lds	r20, 0x50CC
     2c2:	50 91 cd 50 	lds	r21, 0x50CD
     2c6:	80 e0       	ldi	r24, 0x00	; 0
     2c8:	90 e2       	ldi	r25, 0x20	; 32
     2ca:	6e ec       	ldi	r22, 0xCE	; 206
     2cc:	73 e2       	ldi	r23, 0x23	; 35
     2ce:	0e 94 1b 48 	call	0x9036	; 0x9036 <writeFile>
				StartOfFreeSpace = 0;					
     2d2:	10 92 ca 50 	sts	0x50CA, r1
     2d6:	10 92 cb 50 	sts	0x50CB, r1
     2da:	10 92 cc 50 	sts	0x50CC, r1
     2de:	10 92 cd 50 	sts	0x50CD, r1
				sei();
     2e2:	78 94       	sei
	chb_init();
	SD_init();
	getBootSectorData();
	uint16_t MotesInSystem = 2;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     2e4:	20 91 63 50 	lds	r18, 0x5063
     2e8:	30 91 64 50 	lds	r19, 0x5064
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	28 17       	cp	r18, r24
     2f2:	39 07       	cpc	r19, r25
     2f4:	78 f2       	brcs	.-98     	; 0x294 <main+0x22>
				StartOfFreeSpace = 0;					
				sei();
			}				
		}
		//send synch message
		MotesReadyToSynch = 0;	//reset unsynched motes number
     2f6:	10 92 63 50 	sts	0x5063, r1
     2fa:	10 92 64 50 	sts	0x5064, r1
	}	
     2fe:	00 00       	nop
	chb_init();
	SD_init();
	getBootSectorData();
	uint16_t MotesInSystem = 2;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     300:	f1 cf       	rjmp	.-30     	; 0x2e4 <main+0x72>

00000302 <synch>:

//const char ResetCommand[6] = {'r','e','s','e','t','\n'};
uint8_t messageSize = 8;
char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	0f 92       	push	r0
     308:	0f 92       	push	r0
     30a:	cd b7       	in	r28, 0x3d	; 61
     30c:	de b7       	in	r29, 0x3e	; 62
     30e:	89 83       	std	Y+1, r24	; 0x01
     310:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     312:	81 e0       	ldi	r24, 0x01	; 1
     314:	80 93 d0 50 	sts	0x50D0, r24
	*ResetCommand = "reset";
     318:	86 e0       	ldi	r24, 0x06	; 6
     31a:	90 e2       	ldi	r25, 0x20	; 32
     31c:	80 93 a6 50 	sts	0x50A6, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     320:	83 e0       	ldi	r24, 0x03	; 3
     322:	80 93 4d 40 	sts	0x404D, r24
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     326:	80 e8       	ldi	r24, 0x80	; 128
     328:	91 e0       	ldi	r25, 0x01	; 1
     32a:	28 ec       	ldi	r18, 0xC8	; 200
     32c:	fc 01       	movw	r30, r24
     32e:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     330:	80 e4       	ldi	r24, 0x40	; 64
     332:	99 e0       	ldi	r25, 0x09	; 9
     334:	29 e0       	ldi	r18, 0x09	; 9
     336:	fc 01       	movw	r30, r24
     338:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x03;	//enable timer overflow interrupt as high priority interrupt
     33a:	80 e4       	ldi	r24, 0x40	; 64
     33c:	99 e0       	ldi	r25, 0x09	; 9
     33e:	23 e0       	ldi	r18, 0x03	; 3
     340:	fc 01       	movw	r30, r24
     342:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     344:	80 e4       	ldi	r24, 0x40	; 64
     346:	99 e0       	ldi	r25, 0x09	; 9
     348:	69 81       	ldd	r22, Y+1	; 0x01
     34a:	7a 81       	ldd	r23, Y+2	; 0x02
     34c:	44 ef       	ldi	r20, 0xF4	; 244
     34e:	51 e0       	ldi	r21, 0x01	; 1
     350:	64 9f       	mul	r22, r20
     352:	90 01       	movw	r18, r0
     354:	65 9f       	mul	r22, r21
     356:	30 0d       	add	r19, r0
     358:	74 9f       	mul	r23, r20
     35a:	30 0d       	add	r19, r0
     35c:	11 24       	eor	r1, r1
     35e:	fc 01       	movw	r30, r24
     360:	26 a3       	lds	r18, 0x56
     362:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     364:	80 e4       	ldi	r24, 0x40	; 64
     366:	98 e0       	ldi	r25, 0x08	; 8
     368:	20 e0       	ldi	r18, 0x00	; 0
     36a:	3a ef       	ldi	r19, 0xFA	; 250
     36c:	fc 01       	movw	r30, r24
     36e:	26 a3       	lds	r18, 0x56
     370:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x02;  //enable timer overflow interrupt as medium priority interrupt
     372:	80 e4       	ldi	r24, 0x40	; 64
     374:	98 e0       	ldi	r25, 0x08	; 8
     376:	22 e0       	ldi	r18, 0x02	; 2
     378:	fc 01       	movw	r30, r24
     37a:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     37c:	80 e4       	ldi	r24, 0x40	; 64
     37e:	98 e0       	ldi	r25, 0x08	; 8
     380:	21 e0       	ldi	r18, 0x01	; 1
     382:	fc 01       	movw	r30, r24
     384:	20 83       	st	Z, r18
	PMIC.CTRL = ENABLE_ALL_INTERRUPT_LEVELS;
     386:	80 ea       	ldi	r24, 0xA0	; 160
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	27 e0       	ldi	r18, 0x07	; 7
     38c:	fc 01       	movw	r30, r24
     38e:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     390:	78 94       	sei
}
     392:	0f 90       	pop	r0
     394:	0f 90       	pop	r0
     396:	df 91       	pop	r29
     398:	cf 91       	pop	r28
     39a:	08 95       	ret

0000039c <__vector_83>:

ISR(TCD1_OVF_vect) {
     39c:	1f 92       	push	r1
     39e:	0f 92       	push	r0
     3a0:	0f b6       	in	r0, 0x3f	; 63
     3a2:	0f 92       	push	r0
     3a4:	00 90 3b 00 	lds	r0, 0x003B
     3a8:	0f 92       	push	r0
     3aa:	11 24       	eor	r1, r1
     3ac:	ef 92       	push	r14
     3ae:	ff 92       	push	r15
     3b0:	0f 93       	push	r16
     3b2:	1f 93       	push	r17
     3b4:	2f 93       	push	r18
     3b6:	3f 93       	push	r19
     3b8:	4f 93       	push	r20
     3ba:	5f 93       	push	r21
     3bc:	6f 93       	push	r22
     3be:	7f 93       	push	r23
     3c0:	8f 93       	push	r24
     3c2:	9f 93       	push	r25
     3c4:	af 93       	push	r26
     3c6:	bf 93       	push	r27
     3c8:	ef 93       	push	r30
     3ca:	ff 93       	push	r31
     3cc:	cf 93       	push	r28
     3ce:	df 93       	push	r29
     3d0:	00 d0       	rcall	.+0      	; 0x3d2 <__vector_83+0x36>
     3d2:	0f 92       	push	r0
     3d4:	cd b7       	in	r28, 0x3d	; 61
     3d6:	de b7       	in	r29, 0x3e	; 62
	//insert code here to send and wait for synch message
	//perhaps just disable ADC or ADC interrupts while waiting for reply instead of having the whole mote hang
	RadioMonitorMode = TIME_SYNCH;
	ADC_Pause_Sampling();	//pause the ADC while synching
	chb_write(0x0000,message,strlen(message));
}	
     3d8:	0d b7       	in	r16, 0x3d	; 61
     3da:	1e b7       	in	r17, 0x3e	; 62
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
	PMIC.CTRL = ENABLE_ALL_INTERRUPT_LEVELS;
	sei(); //  Enable global interrupts
}

ISR(TCD1_OVF_vect) {
     3dc:	8d b7       	in	r24, 0x3d	; 61
     3de:	9e b7       	in	r25, 0x3e	; 62
     3e0:	7c 01       	movw	r14, r24
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     3e2:	80 e4       	ldi	r24, 0x40	; 64
     3e4:	98 e0       	ldi	r25, 0x08	; 8
     3e6:	fc 01       	movw	r30, r24
     3e8:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     3ea:	80 e4       	ldi	r24, 0x40	; 64
     3ec:	99 e0       	ldi	r25, 0x09	; 9
     3ee:	fc 01       	movw	r30, r24
     3f0:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
     3f2:	80 e4       	ldi	r24, 0x40	; 64
     3f4:	98 e0       	ldi	r25, 0x08	; 8
     3f6:	2c e0       	ldi	r18, 0x0C	; 12
     3f8:	fc 01       	movw	r30, r24
     3fa:	21 87       	std	Z+9, r18	; 0x09
	TCD1.CTRLFSET = 0x0C;
     3fc:	80 e4       	ldi	r24, 0x40	; 64
     3fe:	99 e0       	ldi	r25, 0x09	; 9
     400:	2c e0       	ldi	r18, 0x0C	; 12
     402:	fc 01       	movw	r30, r24
     404:	21 87       	std	Z+9, r18	; 0x09
	chb_init();
     406:	0e 94 42 20 	call	0x4084	; 0x4084 <chb_init>
	chb_set_short_addr(moteID);
     40a:	80 91 d0 50 	lds	r24, 0x50D0
     40e:	88 2f       	mov	r24, r24
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	0e 94 d6 2d 	call	0x5bac	; 0x5bac <chb_set_short_addr>
	char message[messageSize];
     416:	20 91 05 20 	lds	r18, 0x2005
     41a:	82 2f       	mov	r24, r18
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	01 97       	sbiw	r24, 0x01	; 1
     420:	89 83       	std	Y+1, r24	; 0x01
     422:	9a 83       	std	Y+2, r25	; 0x02
     424:	82 2f       	mov	r24, r18
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	2d b7       	in	r18, 0x3d	; 61
     42a:	3e b7       	in	r19, 0x3e	; 62
     42c:	28 1b       	sub	r18, r24
     42e:	39 0b       	sbc	r19, r25
     430:	2d bf       	out	0x3d, r18	; 61
     432:	3e bf       	out	0x3e, r19	; 62
     434:	8d b7       	in	r24, 0x3d	; 61
     436:	9e b7       	in	r25, 0x3e	; 62
     438:	01 96       	adiw	r24, 0x01	; 1
     43a:	00 96       	adiw	r24, 0x00	; 0
     43c:	8b 83       	std	Y+3, r24	; 0x03
     43e:	9c 83       	std	Y+4, r25	; 0x04
	strcpy(message,ResetCommand);
     440:	8b 81       	ldd	r24, Y+3	; 0x03
     442:	9c 81       	ldd	r25, Y+4	; 0x04
     444:	26 ea       	ldi	r18, 0xA6	; 166
     446:	30 e5       	ldi	r19, 0x50	; 80
     448:	b9 01       	movw	r22, r18
     44a:	0e 94 aa 5f 	call	0xbf54	; 0xbf54 <strcpy>
	itoa((int)(moteID),buff,10);
     44e:	80 91 d0 50 	lds	r24, 0x50D0
     452:	88 2f       	mov	r24, r24
     454:	90 e0       	ldi	r25, 0x00	; 0
     456:	26 ed       	ldi	r18, 0xD6	; 214
     458:	30 e5       	ldi	r19, 0x50	; 80
     45a:	b9 01       	movw	r22, r18
     45c:	4a e0       	ldi	r20, 0x0A	; 10
     45e:	50 e0       	ldi	r21, 0x00	; 0
     460:	0e 94 bf 5f 	call	0xbf7e	; 0xbf7e <itoa>
	strcat(message,buff);
     464:	8b 81       	ldd	r24, Y+3	; 0x03
     466:	9c 81       	ldd	r25, Y+4	; 0x04
     468:	26 ed       	ldi	r18, 0xD6	; 214
     46a:	30 e5       	ldi	r19, 0x50	; 80
     46c:	b9 01       	movw	r22, r18
     46e:	0e 94 9f 5f 	call	0xbf3e	; 0xbf3e <strcat>
	//insert code here to send and wait for synch message
	//perhaps just disable ADC or ADC interrupts while waiting for reply instead of having the whole mote hang
	RadioMonitorMode = TIME_SYNCH;
     472:	82 e0       	ldi	r24, 0x02	; 2
     474:	80 93 4d 40 	sts	0x404D, r24
	ADC_Pause_Sampling();	//pause the ADC while synching
     478:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     47c:	6b 81       	ldd	r22, Y+3	; 0x03
     47e:	7c 81       	ldd	r23, Y+4	; 0x04
     480:	8b 81       	ldd	r24, Y+3	; 0x03
     482:	9c 81       	ldd	r25, Y+4	; 0x04
     484:	9c 01       	movw	r18, r24
     486:	f9 01       	movw	r30, r18
     488:	01 90       	ld	r0, Z+
     48a:	00 20       	and	r0, r0
     48c:	e9 f7       	brne	.-6      	; 0x488 <__vector_83+0xec>
     48e:	cf 01       	movw	r24, r30
     490:	01 97       	sbiw	r24, 0x01	; 1
     492:	82 1b       	sub	r24, r18
     494:	93 0b       	sbc	r25, r19
     496:	9c 01       	movw	r18, r24
     498:	40 e0       	ldi	r20, 0x00	; 0
     49a:	50 e0       	ldi	r21, 0x00	; 0
     49c:	80 e0       	ldi	r24, 0x00	; 0
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_write>
     4a4:	ed be       	out	0x3d, r14	; 61
     4a6:	fe be       	out	0x3e, r15	; 62
}	
     4a8:	0d bf       	out	0x3d, r16	; 61
     4aa:	1e bf       	out	0x3e, r17	; 62
     4ac:	24 96       	adiw	r28, 0x04	; 4
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	de bf       	out	0x3e, r29	; 62
     4b2:	df 91       	pop	r29
     4b4:	cf 91       	pop	r28
     4b6:	ff 91       	pop	r31
     4b8:	ef 91       	pop	r30
     4ba:	bf 91       	pop	r27
     4bc:	af 91       	pop	r26
     4be:	9f 91       	pop	r25
     4c0:	8f 91       	pop	r24
     4c2:	7f 91       	pop	r23
     4c4:	6f 91       	pop	r22
     4c6:	5f 91       	pop	r21
     4c8:	4f 91       	pop	r20
     4ca:	3f 91       	pop	r19
     4cc:	2f 91       	pop	r18
     4ce:	1f 91       	pop	r17
     4d0:	0f 91       	pop	r16
     4d2:	ff 90       	pop	r15
     4d4:	ef 90       	pop	r14
     4d6:	0f 90       	pop	r0
     4d8:	00 92 3b 00 	sts	0x003B, r0
     4dc:	0f 90       	pop	r0
     4de:	0f be       	out	0x3f, r0	; 63
     4e0:	0f 90       	pop	r0
     4e2:	1f 90       	pop	r1
     4e4:	18 95       	reti

000004e6 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     4e6:	cf 93       	push	r28
     4e8:	df 93       	push	r29
     4ea:	cd b7       	in	r28, 0x3d	; 61
     4ec:	de b7       	in	r29, 0x3e	; 62
     4ee:	6b 97       	sbiw	r28, 0x1b	; 27
     4f0:	cd bf       	out	0x3d, r28	; 61
     4f2:	de bf       	out	0x3e, r29	; 62
     4f4:	8e 8b       	std	Y+22, r24	; 0x16
     4f6:	9f 8b       	std	Y+23, r25	; 0x17
     4f8:	68 8f       	std	Y+24, r22	; 0x18
     4fa:	79 8f       	std	Y+25, r23	; 0x19
     4fc:	4a 8f       	std	Y+26, r20	; 0x1a
     4fe:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     500:	19 82       	std	Y+1, r1	; 0x01
     502:	1a 82       	std	Y+2, r1	; 0x02
     504:	1b 82       	std	Y+3, r1	; 0x03
     506:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	90 e1       	ldi	r25, 0x10	; 16
     50c:	a0 e0       	ldi	r26, 0x00	; 0
     50e:	b0 e0       	ldi	r27, 0x00	; 0
     510:	8d 83       	std	Y+5, r24	; 0x05
     512:	9e 83       	std	Y+6, r25	; 0x06
     514:	af 83       	std	Y+7, r26	; 0x07
     516:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     518:	19 86       	std	Y+9, r1	; 0x09
     51a:	1a 86       	std	Y+10, r1	; 0x0a
     51c:	1b 86       	std	Y+11, r1	; 0x0b
     51e:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     520:	81 e0       	ldi	r24, 0x01	; 1
     522:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	92 e0       	ldi	r25, 0x02	; 2
     52a:	0e 94 9f 1c 	call	0x393e	; 0x393e <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     52e:	80 e0       	ldi	r24, 0x00	; 0
     530:	92 e0       	ldi	r25, 0x02	; 2
     532:	20 e0       	ldi	r18, 0x00	; 0
     534:	32 e0       	ldi	r19, 0x02	; 2
     536:	f9 01       	movw	r30, r18
     538:	21 81       	ldd	r18, Z+1	; 0x01
     53a:	29 7e       	andi	r18, 0xE9	; 233
     53c:	fc 01       	movw	r30, r24
     53e:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     540:	80 e0       	ldi	r24, 0x00	; 0
     542:	92 e0       	ldi	r25, 0x02	; 2
     544:	20 e0       	ldi	r18, 0x00	; 0
     546:	32 e0       	ldi	r19, 0x02	; 2
     548:	f9 01       	movw	r30, r18
     54a:	24 81       	ldd	r18, Z+4	; 0x04
     54c:	28 7f       	andi	r18, 0xF8	; 248
     54e:	23 60       	ori	r18, 0x03	; 3
     550:	fc 01       	movw	r30, r24
     552:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     554:	80 e0       	ldi	r24, 0x00	; 0
     556:	92 e0       	ldi	r25, 0x02	; 2
     558:	20 e0       	ldi	r18, 0x00	; 0
     55a:	32 e0       	ldi	r19, 0x02	; 2
     55c:	f9 01       	movw	r30, r18
     55e:	22 81       	ldd	r18, Z+2	; 0x02
     560:	2f 7c       	andi	r18, 0xCF	; 207
     562:	fc 01       	movw	r30, r24
     564:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     566:	80 e2       	ldi	r24, 0x20	; 32
     568:	92 e0       	ldi	r25, 0x02	; 2
     56a:	20 e2       	ldi	r18, 0x20	; 32
     56c:	32 e0       	ldi	r19, 0x02	; 2
     56e:	f9 01       	movw	r30, r18
     570:	20 81       	ld	r18, Z
     572:	20 7e       	andi	r18, 0xE0	; 224
     574:	21 60       	ori	r18, 0x01	; 1
     576:	fc 01       	movw	r30, r24
     578:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     57a:	80 e2       	ldi	r24, 0x20	; 32
     57c:	92 e0       	ldi	r25, 0x02	; 2
     57e:	29 e0       	ldi	r18, 0x09	; 9
     580:	fc 01       	movw	r30, r24
     582:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	92 e0       	ldi	r25, 0x02	; 2
     588:	20 e0       	ldi	r18, 0x00	; 0
     58a:	32 e0       	ldi	r19, 0x02	; 2
     58c:	f9 01       	movw	r30, r18
     58e:	20 81       	ld	r18, Z
     590:	21 60       	ori	r18, 0x01	; 1
     592:	fc 01       	movw	r30, r24
     594:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     596:	80 e0       	ldi	r24, 0x00	; 0
     598:	92 e0       	ldi	r25, 0x02	; 2
     59a:	0e 94 57 1e 	call	0x3cae	; 0x3cae <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     59e:	80 e0       	ldi	r24, 0x00	; 0
     5a0:	92 e0       	ldi	r25, 0x02	; 2
     5a2:	60 e2       	ldi	r22, 0x20	; 32
     5a4:	72 e0       	ldi	r23, 0x02	; 2
     5a6:	40 e0       	ldi	r20, 0x00	; 0
     5a8:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <ADC_Offset_Get_Unsigned>
     5ac:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	92 e0       	ldi	r25, 0x02	; 2
     5b2:	20 e0       	ldi	r18, 0x00	; 0
     5b4:	32 e0       	ldi	r19, 0x02	; 2
     5b6:	f9 01       	movw	r30, r18
     5b8:	20 81       	ld	r18, Z
     5ba:	2e 7f       	andi	r18, 0xFE	; 254
     5bc:	fc 01       	movw	r30, r24
     5be:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     5c0:	80 e2       	ldi	r24, 0x20	; 32
     5c2:	92 e0       	ldi	r25, 0x02	; 2
     5c4:	fc 01       	movw	r30, r24
     5c6:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	92 e0       	ldi	r25, 0x02	; 2
     5cc:	20 e0       	ldi	r18, 0x00	; 0
     5ce:	32 e0       	ldi	r19, 0x02	; 2
     5d0:	f9 01       	movw	r30, r18
     5d2:	23 81       	ldd	r18, Z+3	; 0x03
     5d4:	2f 73       	andi	r18, 0x3F	; 63
     5d6:	fc 01       	movw	r30, r24
     5d8:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     5da:	80 e0       	ldi	r24, 0x00	; 0
     5dc:	92 e0       	ldi	r25, 0x02	; 2
     5de:	20 e0       	ldi	r18, 0x00	; 0
     5e0:	32 e0       	ldi	r19, 0x02	; 2
     5e2:	f9 01       	movw	r30, r18
     5e4:	20 81       	ld	r18, Z
     5e6:	21 60       	ori	r18, 0x01	; 1
     5e8:	fc 01       	movw	r30, r24
     5ea:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	92 e0       	ldi	r25, 0x02	; 2
     5f0:	0e 94 57 1e 	call	0x3cae	; 0x3cae <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	92 e0       	ldi	r25, 0x02	; 2
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	32 e0       	ldi	r19, 0x02	; 2
     5fc:	f9 01       	movw	r30, r18
     5fe:	21 81       	ldd	r18, Z+1	; 0x01
     600:	28 60       	ori	r18, 0x08	; 8
     602:	fc 01       	movw	r30, r24
     604:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     606:	1d 86       	std	Y+13, r1	; 0x0d
     608:	1e 86       	std	Y+14, r1	; 0x0e
     60a:	56 c0       	rjmp	.+172    	; 0x6b8 <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     60c:	80 e2       	ldi	r24, 0x20	; 32
     60e:	92 e0       	ldi	r25, 0x02	; 2
     610:	fc 01       	movw	r30, r24
     612:	83 81       	ldd	r24, Z+3	; 0x03
     614:	88 2f       	mov	r24, r24
     616:	90 e0       	ldi	r25, 0x00	; 0
     618:	81 70       	andi	r24, 0x01	; 1
     61a:	90 70       	andi	r25, 0x00	; 0
     61c:	00 97       	sbiw	r24, 0x00	; 0
     61e:	b1 f3       	breq	.-20     	; 0x60c <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     620:	2d 89       	ldd	r18, Y+21	; 0x15
     622:	80 e2       	ldi	r24, 0x20	; 32
     624:	92 e0       	ldi	r25, 0x02	; 2
     626:	62 2f       	mov	r22, r18
     628:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <ADC_ResultCh_GetWord_Signed>
     62c:	8f 87       	std	Y+15, r24	; 0x0f
     62e:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     630:	8f 85       	ldd	r24, Y+15	; 0x0f
     632:	98 89       	ldd	r25, Y+16	; 0x10
     634:	cc 01       	movw	r24, r24
     636:	a0 e0       	ldi	r26, 0x00	; 0
     638:	b0 e0       	ldi	r27, 0x00	; 0
     63a:	29 81       	ldd	r18, Y+1	; 0x01
     63c:	3a 81       	ldd	r19, Y+2	; 0x02
     63e:	4b 81       	ldd	r20, Y+3	; 0x03
     640:	5c 81       	ldd	r21, Y+4	; 0x04
     642:	82 0f       	add	r24, r18
     644:	93 1f       	adc	r25, r19
     646:	a4 1f       	adc	r26, r20
     648:	b5 1f       	adc	r27, r21
     64a:	89 83       	std	Y+1, r24	; 0x01
     64c:	9a 83       	std	Y+2, r25	; 0x02
     64e:	ab 83       	std	Y+3, r26	; 0x03
     650:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     652:	8f 85       	ldd	r24, Y+15	; 0x0f
     654:	98 89       	ldd	r25, Y+16	; 0x10
     656:	9c 01       	movw	r18, r24
     658:	40 e0       	ldi	r20, 0x00	; 0
     65a:	50 e0       	ldi	r21, 0x00	; 0
     65c:	89 85       	ldd	r24, Y+9	; 0x09
     65e:	9a 85       	ldd	r25, Y+10	; 0x0a
     660:	ab 85       	ldd	r26, Y+11	; 0x0b
     662:	bc 85       	ldd	r27, Y+12	; 0x0c
     664:	82 17       	cp	r24, r18
     666:	93 07       	cpc	r25, r19
     668:	a4 07       	cpc	r26, r20
     66a:	b5 07       	cpc	r27, r21
     66c:	48 f4       	brcc	.+18     	; 0x680 <CO_collectTemp+0x19a>
     66e:	8f 85       	ldd	r24, Y+15	; 0x0f
     670:	98 89       	ldd	r25, Y+16	; 0x10
     672:	cc 01       	movw	r24, r24
     674:	a0 e0       	ldi	r26, 0x00	; 0
     676:	b0 e0       	ldi	r27, 0x00	; 0
     678:	89 87       	std	Y+9, r24	; 0x09
     67a:	9a 87       	std	Y+10, r25	; 0x0a
     67c:	ab 87       	std	Y+11, r26	; 0x0b
     67e:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     680:	8f 85       	ldd	r24, Y+15	; 0x0f
     682:	98 89       	ldd	r25, Y+16	; 0x10
     684:	9c 01       	movw	r18, r24
     686:	40 e0       	ldi	r20, 0x00	; 0
     688:	50 e0       	ldi	r21, 0x00	; 0
     68a:	8d 81       	ldd	r24, Y+5	; 0x05
     68c:	9e 81       	ldd	r25, Y+6	; 0x06
     68e:	af 81       	ldd	r26, Y+7	; 0x07
     690:	b8 85       	ldd	r27, Y+8	; 0x08
     692:	28 17       	cp	r18, r24
     694:	39 07       	cpc	r19, r25
     696:	4a 07       	cpc	r20, r26
     698:	5b 07       	cpc	r21, r27
     69a:	48 f4       	brcc	.+18     	; 0x6ae <CO_collectTemp+0x1c8>
     69c:	8f 85       	ldd	r24, Y+15	; 0x0f
     69e:	98 89       	ldd	r25, Y+16	; 0x10
     6a0:	cc 01       	movw	r24, r24
     6a2:	a0 e0       	ldi	r26, 0x00	; 0
     6a4:	b0 e0       	ldi	r27, 0x00	; 0
     6a6:	8d 83       	std	Y+5, r24	; 0x05
     6a8:	9e 83       	std	Y+6, r25	; 0x06
     6aa:	af 83       	std	Y+7, r26	; 0x07
     6ac:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     6ae:	8d 85       	ldd	r24, Y+13	; 0x0d
     6b0:	9e 85       	ldd	r25, Y+14	; 0x0e
     6b2:	01 96       	adiw	r24, 0x01	; 1
     6b4:	8d 87       	std	Y+13, r24	; 0x0d
     6b6:	9e 87       	std	Y+14, r25	; 0x0e
     6b8:	8d 85       	ldd	r24, Y+13	; 0x0d
     6ba:	9e 85       	ldd	r25, Y+14	; 0x0e
     6bc:	f4 e0       	ldi	r31, 0x04	; 4
     6be:	80 30       	cpi	r24, 0x00	; 0
     6c0:	9f 07       	cpc	r25, r31
     6c2:	08 f4       	brcc	.+2      	; 0x6c6 <CO_collectTemp+0x1e0>
     6c4:	a3 cf       	rjmp	.-186    	; 0x60c <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     6c6:	80 e0       	ldi	r24, 0x00	; 0
     6c8:	92 e0       	ldi	r25, 0x02	; 2
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	32 e0       	ldi	r19, 0x02	; 2
     6ce:	f9 01       	movw	r30, r18
     6d0:	21 81       	ldd	r18, Z+1	; 0x01
     6d2:	27 7f       	andi	r18, 0xF7	; 247
     6d4:	fc 01       	movw	r30, r24
     6d6:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     6d8:	80 e0       	ldi	r24, 0x00	; 0
     6da:	92 e0       	ldi	r25, 0x02	; 2
     6dc:	20 e0       	ldi	r18, 0x00	; 0
     6de:	32 e0       	ldi	r19, 0x02	; 2
     6e0:	f9 01       	movw	r30, r18
     6e2:	20 81       	ld	r18, Z
     6e4:	22 60       	ori	r18, 0x02	; 2
     6e6:	fc 01       	movw	r30, r24
     6e8:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     6ea:	80 e0       	ldi	r24, 0x00	; 0
     6ec:	92 e0       	ldi	r25, 0x02	; 2
     6ee:	20 e0       	ldi	r18, 0x00	; 0
     6f0:	32 e0       	ldi	r19, 0x02	; 2
     6f2:	f9 01       	movw	r30, r18
     6f4:	20 81       	ld	r18, Z
     6f6:	2e 7f       	andi	r18, 0xFE	; 254
     6f8:	fc 01       	movw	r30, r24
     6fa:	20 83       	st	Z, r18

	ADCPower(FALSE);
     6fc:	80 e0       	ldi	r24, 0x00	; 0
     6fe:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>

	average = sum / NUM_SAMPLES;
     702:	89 81       	ldd	r24, Y+1	; 0x01
     704:	9a 81       	ldd	r25, Y+2	; 0x02
     706:	ab 81       	ldd	r26, Y+3	; 0x03
     708:	bc 81       	ldd	r27, Y+4	; 0x04
     70a:	07 2e       	mov	r0, r23
     70c:	7a e0       	ldi	r23, 0x0A	; 10
     70e:	b6 95       	lsr	r27
     710:	a7 95       	ror	r26
     712:	97 95       	ror	r25
     714:	87 95       	ror	r24
     716:	7a 95       	dec	r23
     718:	d1 f7       	brne	.-12     	; 0x70e <CO_collectTemp+0x228>
     71a:	70 2d       	mov	r23, r0
     71c:	89 8b       	std	Y+17, r24	; 0x11
     71e:	9a 8b       	std	Y+18, r25	; 0x12
     720:	ab 8b       	std	Y+19, r26	; 0x13
     722:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     724:	89 89       	ldd	r24, Y+17	; 0x11
     726:	9a 89       	ldd	r25, Y+18	; 0x12
     728:	ab 89       	ldd	r26, Y+19	; 0x13
     72a:	bc 89       	ldd	r27, Y+20	; 0x14
     72c:	28 ee       	ldi	r18, 0xE8	; 232
     72e:	33 e0       	ldi	r19, 0x03	; 3
     730:	40 e0       	ldi	r20, 0x00	; 0
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	bc 01       	movw	r22, r24
     736:	cd 01       	movw	r24, r26
     738:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
     73c:	dc 01       	movw	r26, r24
     73e:	cb 01       	movw	r24, r22
     740:	2f ef       	ldi	r18, 0xFF	; 255
     742:	3f e0       	ldi	r19, 0x0F	; 15
     744:	40 e0       	ldi	r20, 0x00	; 0
     746:	50 e0       	ldi	r21, 0x00	; 0
     748:	bc 01       	movw	r22, r24
     74a:	cd 01       	movw	r24, r26
     74c:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
     750:	da 01       	movw	r26, r20
     752:	c9 01       	movw	r24, r18
     754:	9c 01       	movw	r18, r24
     756:	22 53       	subi	r18, 0x32	; 50
     758:	30 40       	sbci	r19, 0x00	; 0
     75a:	8e 89       	ldd	r24, Y+22	; 0x16
     75c:	9f 89       	ldd	r25, Y+23	; 0x17
     75e:	fc 01       	movw	r30, r24
     760:	20 83       	st	Z, r18
     762:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     764:	89 85       	ldd	r24, Y+9	; 0x09
     766:	9a 85       	ldd	r25, Y+10	; 0x0a
     768:	ab 85       	ldd	r26, Y+11	; 0x0b
     76a:	bc 85       	ldd	r27, Y+12	; 0x0c
     76c:	28 ee       	ldi	r18, 0xE8	; 232
     76e:	33 e0       	ldi	r19, 0x03	; 3
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	bc 01       	movw	r22, r24
     776:	cd 01       	movw	r24, r26
     778:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
     77c:	dc 01       	movw	r26, r24
     77e:	cb 01       	movw	r24, r22
     780:	2f ef       	ldi	r18, 0xFF	; 255
     782:	3f e0       	ldi	r19, 0x0F	; 15
     784:	40 e0       	ldi	r20, 0x00	; 0
     786:	50 e0       	ldi	r21, 0x00	; 0
     788:	bc 01       	movw	r22, r24
     78a:	cd 01       	movw	r24, r26
     78c:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
     790:	da 01       	movw	r26, r20
     792:	c9 01       	movw	r24, r18
     794:	9c 01       	movw	r18, r24
     796:	22 53       	subi	r18, 0x32	; 50
     798:	30 40       	sbci	r19, 0x00	; 0
     79a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     79c:	9b 8d       	ldd	r25, Y+27	; 0x1b
     79e:	fc 01       	movw	r30, r24
     7a0:	20 83       	st	Z, r18
     7a2:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     7a4:	8d 81       	ldd	r24, Y+5	; 0x05
     7a6:	9e 81       	ldd	r25, Y+6	; 0x06
     7a8:	af 81       	ldd	r26, Y+7	; 0x07
     7aa:	b8 85       	ldd	r27, Y+8	; 0x08
     7ac:	28 ee       	ldi	r18, 0xE8	; 232
     7ae:	33 e0       	ldi	r19, 0x03	; 3
     7b0:	40 e0       	ldi	r20, 0x00	; 0
     7b2:	50 e0       	ldi	r21, 0x00	; 0
     7b4:	bc 01       	movw	r22, r24
     7b6:	cd 01       	movw	r24, r26
     7b8:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
     7bc:	dc 01       	movw	r26, r24
     7be:	cb 01       	movw	r24, r22
     7c0:	2f ef       	ldi	r18, 0xFF	; 255
     7c2:	3f e0       	ldi	r19, 0x0F	; 15
     7c4:	40 e0       	ldi	r20, 0x00	; 0
     7c6:	50 e0       	ldi	r21, 0x00	; 0
     7c8:	bc 01       	movw	r22, r24
     7ca:	cd 01       	movw	r24, r26
     7cc:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
     7d0:	da 01       	movw	r26, r20
     7d2:	c9 01       	movw	r24, r18
     7d4:	9c 01       	movw	r18, r24
     7d6:	22 53       	subi	r18, 0x32	; 50
     7d8:	30 40       	sbci	r19, 0x00	; 0
     7da:	88 8d       	ldd	r24, Y+24	; 0x18
     7dc:	99 8d       	ldd	r25, Y+25	; 0x19
     7de:	fc 01       	movw	r30, r24
     7e0:	20 83       	st	Z, r18
     7e2:	31 83       	std	Z+1, r19	; 0x01
}
     7e4:	6b 96       	adiw	r28, 0x1b	; 27
     7e6:	cd bf       	out	0x3d, r28	; 61
     7e8:	de bf       	out	0x3e, r29	; 62
     7ea:	df 91       	pop	r29
     7ec:	cf 91       	pop	r28
     7ee:	08 95       	ret

000007f0 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     7f0:	0f 93       	push	r16
     7f2:	1f 93       	push	r17
     7f4:	cf 93       	push	r28
     7f6:	df 93       	push	r29
     7f8:	cd b7       	in	r28, 0x3d	; 61
     7fa:	de b7       	in	r29, 0x3e	; 62
     7fc:	a9 97       	sbiw	r28, 0x29	; 41
     7fe:	cd bf       	out	0x3d, r28	; 61
     800:	de bf       	out	0x3e, r29	; 62
     802:	8c a3       	lds	r24, 0x5c
     804:	9d a3       	lds	r25, 0x5d
     806:	6e a3       	lds	r22, 0x5e
     808:	7f a3       	lds	r23, 0x5f
     80a:	48 a7       	lds	r20, 0x78
     80c:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     80e:	19 82       	std	Y+1, r1	; 0x01
     810:	1a 82       	std	Y+2, r1	; 0x02
     812:	1b 82       	std	Y+3, r1	; 0x03
     814:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e1       	ldi	r25, 0x10	; 16
     81a:	a0 e0       	ldi	r26, 0x00	; 0
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	8d 83       	std	Y+5, r24	; 0x05
     820:	9e 83       	std	Y+6, r25	; 0x06
     822:	af 83       	std	Y+7, r26	; 0x07
     824:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     826:	19 86       	std	Y+9, r1	; 0x09
     828:	1a 86       	std	Y+10, r1	; 0x0a
     82a:	1b 86       	std	Y+11, r1	; 0x0b
     82c:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     834:	84 e0       	ldi	r24, 0x04	; 4
     836:	60 e0       	ldi	r22, 0x00	; 0
     838:	0e 94 1f 35 	call	0x6a3e	; 0x6a3e <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     83c:	84 e0       	ldi	r24, 0x04	; 4
     83e:	60 e0       	ldi	r22, 0x00	; 0
     840:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	90 e0       	ldi	r25, 0x00	; 0
     848:	a8 ec       	ldi	r26, 0xC8	; 200
     84a:	b2 e4       	ldi	r27, 0x42	; 66
     84c:	8d 8b       	std	Y+21, r24	; 0x15
     84e:	9e 8b       	std	Y+22, r25	; 0x16
     850:	af 8b       	std	Y+23, r26	; 0x17
     852:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     854:	6d 89       	ldd	r22, Y+21	; 0x15
     856:	7e 89       	ldd	r23, Y+22	; 0x16
     858:	8f 89       	ldd	r24, Y+23	; 0x17
     85a:	98 8d       	ldd	r25, Y+24	; 0x18
     85c:	20 e0       	ldi	r18, 0x00	; 0
     85e:	30 e0       	ldi	r19, 0x00	; 0
     860:	4a ef       	ldi	r20, 0xFA	; 250
     862:	55 e4       	ldi	r21, 0x45	; 69
     864:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
     868:	dc 01       	movw	r26, r24
     86a:	cb 01       	movw	r24, r22
     86c:	89 8f       	std	Y+25, r24	; 0x19
     86e:	9a 8f       	std	Y+26, r25	; 0x1a
     870:	ab 8f       	std	Y+27, r26	; 0x1b
     872:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     874:	11 e0       	ldi	r17, 0x01	; 1
     876:	69 8d       	ldd	r22, Y+25	; 0x19
     878:	7a 8d       	ldd	r23, Y+26	; 0x1a
     87a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     87c:	9c 8d       	ldd	r25, Y+28	; 0x1c
     87e:	20 e0       	ldi	r18, 0x00	; 0
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	40 e8       	ldi	r20, 0x80	; 128
     884:	5f e3       	ldi	r21, 0x3F	; 63
     886:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
     88a:	88 23       	and	r24, r24
     88c:	0c f0       	brlt	.+2      	; 0x890 <CO_collectBatt+0xa0>
     88e:	10 e0       	ldi	r17, 0x00	; 0
     890:	11 23       	and	r17, r17
     892:	29 f0       	breq	.+10     	; 0x89e <CO_collectBatt+0xae>
		__ticks = 1;
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	90 e0       	ldi	r25, 0x00	; 0
     898:	8d 8f       	std	Y+29, r24	; 0x1d
     89a:	9e 8f       	std	Y+30, r25	; 0x1e
     89c:	46 c0       	rjmp	.+140    	; 0x92a <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     89e:	11 e0       	ldi	r17, 0x01	; 1
     8a0:	69 8d       	ldd	r22, Y+25	; 0x19
     8a2:	7a 8d       	ldd	r23, Y+26	; 0x1a
     8a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8a6:	9c 8d       	ldd	r25, Y+28	; 0x1c
     8a8:	20 e0       	ldi	r18, 0x00	; 0
     8aa:	3f ef       	ldi	r19, 0xFF	; 255
     8ac:	4f e7       	ldi	r20, 0x7F	; 127
     8ae:	57 e4       	ldi	r21, 0x47	; 71
     8b0:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
     8b4:	18 16       	cp	r1, r24
     8b6:	0c f0       	brlt	.+2      	; 0x8ba <CO_collectBatt+0xca>
     8b8:	10 e0       	ldi	r17, 0x00	; 0
     8ba:	11 23       	and	r17, r17
     8bc:	61 f1       	breq	.+88     	; 0x916 <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     8be:	6d 89       	ldd	r22, Y+21	; 0x15
     8c0:	7e 89       	ldd	r23, Y+22	; 0x16
     8c2:	8f 89       	ldd	r24, Y+23	; 0x17
     8c4:	98 8d       	ldd	r25, Y+24	; 0x18
     8c6:	20 e0       	ldi	r18, 0x00	; 0
     8c8:	30 e0       	ldi	r19, 0x00	; 0
     8ca:	40 e2       	ldi	r20, 0x20	; 32
     8cc:	51 e4       	ldi	r21, 0x41	; 65
     8ce:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
     8d2:	dc 01       	movw	r26, r24
     8d4:	cb 01       	movw	r24, r22
     8d6:	bc 01       	movw	r22, r24
     8d8:	cd 01       	movw	r24, r26
     8da:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
     8de:	dc 01       	movw	r26, r24
     8e0:	cb 01       	movw	r24, r22
     8e2:	8d 8f       	std	Y+29, r24	; 0x1d
     8e4:	9e 8f       	std	Y+30, r25	; 0x1e
     8e6:	12 c0       	rjmp	.+36     	; 0x90c <CO_collectBatt+0x11c>
     8e8:	80 e2       	ldi	r24, 0x20	; 32
     8ea:	93 e0       	ldi	r25, 0x03	; 3
     8ec:	8f 8f       	std	Y+31, r24	; 0x1f
     8ee:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8f0:	8f 8d       	ldd	r24, Y+31	; 0x1f
     8f2:	98 a1       	lds	r25, 0x48
     8f4:	8c 01       	movw	r16, r24
     8f6:	c8 01       	movw	r24, r16
     8f8:	01 97       	sbiw	r24, 0x01	; 1
     8fa:	f1 f7       	brne	.-4      	; 0x8f8 <CO_collectBatt+0x108>
     8fc:	8c 01       	movw	r16, r24
     8fe:	0f 8f       	std	Y+31, r16	; 0x1f
     900:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     902:	8d 8d       	ldd	r24, Y+29	; 0x1d
     904:	9e 8d       	ldd	r25, Y+30	; 0x1e
     906:	01 97       	sbiw	r24, 0x01	; 1
     908:	8d 8f       	std	Y+29, r24	; 0x1d
     90a:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     90c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     90e:	9e 8d       	ldd	r25, Y+30	; 0x1e
     910:	00 97       	sbiw	r24, 0x00	; 0
     912:	51 f7       	brne	.-44     	; 0x8e8 <CO_collectBatt+0xf8>
     914:	17 c0       	rjmp	.+46     	; 0x944 <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     916:	69 8d       	ldd	r22, Y+25	; 0x19
     918:	7a 8d       	ldd	r23, Y+26	; 0x1a
     91a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     91c:	9c 8d       	ldd	r25, Y+28	; 0x1c
     91e:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
     922:	dc 01       	movw	r26, r24
     924:	cb 01       	movw	r24, r22
     926:	8d 8f       	std	Y+29, r24	; 0x1d
     928:	9e 8f       	std	Y+30, r25	; 0x1e
     92a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     92c:	9e 8d       	ldd	r25, Y+30	; 0x1e
     92e:	89 a3       	lds	r24, 0x59
     930:	9a a3       	lds	r25, 0x5a
     932:	89 a1       	lds	r24, 0x49
     934:	9a a1       	lds	r25, 0x4a
     936:	8c 01       	movw	r16, r24
     938:	f8 01       	movw	r30, r16
     93a:	31 97       	sbiw	r30, 0x01	; 1
     93c:	f1 f7       	brne	.-4      	; 0x93a <CO_collectBatt+0x14a>
     93e:	8f 01       	movw	r16, r30
     940:	09 a3       	lds	r16, 0x59
     942:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     944:	80 e4       	ldi	r24, 0x40	; 64
     946:	92 e0       	ldi	r25, 0x02	; 2
     948:	0e 94 9f 1c 	call	0x393e	; 0x393e <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     94c:	80 e4       	ldi	r24, 0x40	; 64
     94e:	92 e0       	ldi	r25, 0x02	; 2
     950:	20 e4       	ldi	r18, 0x40	; 64
     952:	32 e0       	ldi	r19, 0x02	; 2
     954:	f9 01       	movw	r30, r18
     956:	21 81       	ldd	r18, Z+1	; 0x01
     958:	29 7e       	andi	r18, 0xE9	; 233
     95a:	fc 01       	movw	r30, r24
     95c:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     95e:	80 e4       	ldi	r24, 0x40	; 64
     960:	92 e0       	ldi	r25, 0x02	; 2
     962:	20 e4       	ldi	r18, 0x40	; 64
     964:	32 e0       	ldi	r19, 0x02	; 2
     966:	f9 01       	movw	r30, r18
     968:	24 81       	ldd	r18, Z+4	; 0x04
     96a:	28 7f       	andi	r18, 0xF8	; 248
     96c:	23 60       	ori	r18, 0x03	; 3
     96e:	fc 01       	movw	r30, r24
     970:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     972:	80 e4       	ldi	r24, 0x40	; 64
     974:	92 e0       	ldi	r25, 0x02	; 2
     976:	20 e4       	ldi	r18, 0x40	; 64
     978:	32 e0       	ldi	r19, 0x02	; 2
     97a:	f9 01       	movw	r30, r18
     97c:	22 81       	ldd	r18, Z+2	; 0x02
     97e:	2f 7c       	andi	r18, 0xCF	; 207
     980:	fc 01       	movw	r30, r24
     982:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     984:	80 e6       	ldi	r24, 0x60	; 96
     986:	92 e0       	ldi	r25, 0x02	; 2
     988:	20 e6       	ldi	r18, 0x60	; 96
     98a:	32 e0       	ldi	r19, 0x02	; 2
     98c:	f9 01       	movw	r30, r18
     98e:	20 81       	ld	r18, Z
     990:	20 7e       	andi	r18, 0xE0	; 224
     992:	21 60       	ori	r18, 0x01	; 1
     994:	fc 01       	movw	r30, r24
     996:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     998:	80 e6       	ldi	r24, 0x60	; 96
     99a:	92 e0       	ldi	r25, 0x02	; 2
     99c:	29 e0       	ldi	r18, 0x09	; 9
     99e:	fc 01       	movw	r30, r24
     9a0:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     9a2:	80 e4       	ldi	r24, 0x40	; 64
     9a4:	92 e0       	ldi	r25, 0x02	; 2
     9a6:	20 e4       	ldi	r18, 0x40	; 64
     9a8:	32 e0       	ldi	r19, 0x02	; 2
     9aa:	f9 01       	movw	r30, r18
     9ac:	20 81       	ld	r18, Z
     9ae:	21 60       	ori	r18, 0x01	; 1
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     9b4:	80 e4       	ldi	r24, 0x40	; 64
     9b6:	92 e0       	ldi	r25, 0x02	; 2
     9b8:	0e 94 57 1e 	call	0x3cae	; 0x3cae <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     9bc:	80 e4       	ldi	r24, 0x40	; 64
     9be:	92 e0       	ldi	r25, 0x02	; 2
     9c0:	60 e6       	ldi	r22, 0x60	; 96
     9c2:	72 e0       	ldi	r23, 0x02	; 2
     9c4:	40 e0       	ldi	r20, 0x00	; 0
     9c6:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <ADC_Offset_Get_Unsigned>
     9ca:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     9cc:	80 e4       	ldi	r24, 0x40	; 64
     9ce:	92 e0       	ldi	r25, 0x02	; 2
     9d0:	20 e4       	ldi	r18, 0x40	; 64
     9d2:	32 e0       	ldi	r19, 0x02	; 2
     9d4:	f9 01       	movw	r30, r18
     9d6:	20 81       	ld	r18, Z
     9d8:	2e 7f       	andi	r18, 0xFE	; 254
     9da:	fc 01       	movw	r30, r24
     9dc:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     9de:	80 e6       	ldi	r24, 0x60	; 96
     9e0:	92 e0       	ldi	r25, 0x02	; 2
     9e2:	fc 01       	movw	r30, r24
     9e4:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     9e6:	80 e4       	ldi	r24, 0x40	; 64
     9e8:	92 e0       	ldi	r25, 0x02	; 2
     9ea:	20 e4       	ldi	r18, 0x40	; 64
     9ec:	32 e0       	ldi	r19, 0x02	; 2
     9ee:	f9 01       	movw	r30, r18
     9f0:	23 81       	ldd	r18, Z+3	; 0x03
     9f2:	2f 73       	andi	r18, 0x3F	; 63
     9f4:	fc 01       	movw	r30, r24
     9f6:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     9f8:	80 e4       	ldi	r24, 0x40	; 64
     9fa:	92 e0       	ldi	r25, 0x02	; 2
     9fc:	20 e4       	ldi	r18, 0x40	; 64
     9fe:	32 e0       	ldi	r19, 0x02	; 2
     a00:	f9 01       	movw	r30, r18
     a02:	20 81       	ld	r18, Z
     a04:	21 60       	ori	r18, 0x01	; 1
     a06:	fc 01       	movw	r30, r24
     a08:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     a0a:	80 e4       	ldi	r24, 0x40	; 64
     a0c:	92 e0       	ldi	r25, 0x02	; 2
     a0e:	0e 94 57 1e 	call	0x3cae	; 0x3cae <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     a12:	80 e4       	ldi	r24, 0x40	; 64
     a14:	92 e0       	ldi	r25, 0x02	; 2
     a16:	20 e4       	ldi	r18, 0x40	; 64
     a18:	32 e0       	ldi	r19, 0x02	; 2
     a1a:	f9 01       	movw	r30, r18
     a1c:	21 81       	ldd	r18, Z+1	; 0x01
     a1e:	28 60       	ori	r18, 0x08	; 8
     a20:	fc 01       	movw	r30, r24
     a22:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a24:	1d 86       	std	Y+13, r1	; 0x0d
     a26:	1e 86       	std	Y+14, r1	; 0x0e
     a28:	56 c0       	rjmp	.+172    	; 0xad6 <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     a2a:	80 e6       	ldi	r24, 0x60	; 96
     a2c:	92 e0       	ldi	r25, 0x02	; 2
     a2e:	fc 01       	movw	r30, r24
     a30:	83 81       	ldd	r24, Z+3	; 0x03
     a32:	88 2f       	mov	r24, r24
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	81 70       	andi	r24, 0x01	; 1
     a38:	90 70       	andi	r25, 0x00	; 0
     a3a:	00 97       	sbiw	r24, 0x00	; 0
     a3c:	b1 f3       	breq	.-20     	; 0xa2a <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a3e:	2b a1       	lds	r18, 0x4b
     a40:	80 e6       	ldi	r24, 0x60	; 96
     a42:	92 e0       	ldi	r25, 0x02	; 2
     a44:	62 2f       	mov	r22, r18
     a46:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <ADC_ResultCh_GetWord_Signed>
     a4a:	8f 87       	std	Y+15, r24	; 0x0f
     a4c:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     a4e:	8f 85       	ldd	r24, Y+15	; 0x0f
     a50:	98 89       	ldd	r25, Y+16	; 0x10
     a52:	cc 01       	movw	r24, r24
     a54:	a0 e0       	ldi	r26, 0x00	; 0
     a56:	b0 e0       	ldi	r27, 0x00	; 0
     a58:	29 81       	ldd	r18, Y+1	; 0x01
     a5a:	3a 81       	ldd	r19, Y+2	; 0x02
     a5c:	4b 81       	ldd	r20, Y+3	; 0x03
     a5e:	5c 81       	ldd	r21, Y+4	; 0x04
     a60:	82 0f       	add	r24, r18
     a62:	93 1f       	adc	r25, r19
     a64:	a4 1f       	adc	r26, r20
     a66:	b5 1f       	adc	r27, r21
     a68:	89 83       	std	Y+1, r24	; 0x01
     a6a:	9a 83       	std	Y+2, r25	; 0x02
     a6c:	ab 83       	std	Y+3, r26	; 0x03
     a6e:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     a70:	8f 85       	ldd	r24, Y+15	; 0x0f
     a72:	98 89       	ldd	r25, Y+16	; 0x10
     a74:	9c 01       	movw	r18, r24
     a76:	40 e0       	ldi	r20, 0x00	; 0
     a78:	50 e0       	ldi	r21, 0x00	; 0
     a7a:	89 85       	ldd	r24, Y+9	; 0x09
     a7c:	9a 85       	ldd	r25, Y+10	; 0x0a
     a7e:	ab 85       	ldd	r26, Y+11	; 0x0b
     a80:	bc 85       	ldd	r27, Y+12	; 0x0c
     a82:	82 17       	cp	r24, r18
     a84:	93 07       	cpc	r25, r19
     a86:	a4 07       	cpc	r26, r20
     a88:	b5 07       	cpc	r27, r21
     a8a:	48 f4       	brcc	.+18     	; 0xa9e <CO_collectBatt+0x2ae>
     a8c:	8f 85       	ldd	r24, Y+15	; 0x0f
     a8e:	98 89       	ldd	r25, Y+16	; 0x10
     a90:	cc 01       	movw	r24, r24
     a92:	a0 e0       	ldi	r26, 0x00	; 0
     a94:	b0 e0       	ldi	r27, 0x00	; 0
     a96:	89 87       	std	Y+9, r24	; 0x09
     a98:	9a 87       	std	Y+10, r25	; 0x0a
     a9a:	ab 87       	std	Y+11, r26	; 0x0b
     a9c:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     a9e:	8f 85       	ldd	r24, Y+15	; 0x0f
     aa0:	98 89       	ldd	r25, Y+16	; 0x10
     aa2:	9c 01       	movw	r18, r24
     aa4:	40 e0       	ldi	r20, 0x00	; 0
     aa6:	50 e0       	ldi	r21, 0x00	; 0
     aa8:	8d 81       	ldd	r24, Y+5	; 0x05
     aaa:	9e 81       	ldd	r25, Y+6	; 0x06
     aac:	af 81       	ldd	r26, Y+7	; 0x07
     aae:	b8 85       	ldd	r27, Y+8	; 0x08
     ab0:	28 17       	cp	r18, r24
     ab2:	39 07       	cpc	r19, r25
     ab4:	4a 07       	cpc	r20, r26
     ab6:	5b 07       	cpc	r21, r27
     ab8:	48 f4       	brcc	.+18     	; 0xacc <CO_collectBatt+0x2dc>
     aba:	8f 85       	ldd	r24, Y+15	; 0x0f
     abc:	98 89       	ldd	r25, Y+16	; 0x10
     abe:	cc 01       	movw	r24, r24
     ac0:	a0 e0       	ldi	r26, 0x00	; 0
     ac2:	b0 e0       	ldi	r27, 0x00	; 0
     ac4:	8d 83       	std	Y+5, r24	; 0x05
     ac6:	9e 83       	std	Y+6, r25	; 0x06
     ac8:	af 83       	std	Y+7, r26	; 0x07
     aca:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     acc:	8d 85       	ldd	r24, Y+13	; 0x0d
     ace:	9e 85       	ldd	r25, Y+14	; 0x0e
     ad0:	01 96       	adiw	r24, 0x01	; 1
     ad2:	8d 87       	std	Y+13, r24	; 0x0d
     ad4:	9e 87       	std	Y+14, r25	; 0x0e
     ad6:	8d 85       	ldd	r24, Y+13	; 0x0d
     ad8:	9e 85       	ldd	r25, Y+14	; 0x0e
     ada:	f4 e0       	ldi	r31, 0x04	; 4
     adc:	80 30       	cpi	r24, 0x00	; 0
     ade:	9f 07       	cpc	r25, r31
     ae0:	08 f4       	brcc	.+2      	; 0xae4 <CO_collectBatt+0x2f4>
     ae2:	a3 cf       	rjmp	.-186    	; 0xa2a <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     ae4:	80 e4       	ldi	r24, 0x40	; 64
     ae6:	92 e0       	ldi	r25, 0x02	; 2
     ae8:	20 e4       	ldi	r18, 0x40	; 64
     aea:	32 e0       	ldi	r19, 0x02	; 2
     aec:	f9 01       	movw	r30, r18
     aee:	21 81       	ldd	r18, Z+1	; 0x01
     af0:	27 7f       	andi	r18, 0xF7	; 247
     af2:	fc 01       	movw	r30, r24
     af4:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     af6:	80 e4       	ldi	r24, 0x40	; 64
     af8:	92 e0       	ldi	r25, 0x02	; 2
     afa:	20 e4       	ldi	r18, 0x40	; 64
     afc:	32 e0       	ldi	r19, 0x02	; 2
     afe:	f9 01       	movw	r30, r18
     b00:	20 81       	ld	r18, Z
     b02:	2e 7f       	andi	r18, 0xFE	; 254
     b04:	fc 01       	movw	r30, r24
     b06:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     b08:	89 81       	ldd	r24, Y+1	; 0x01
     b0a:	9a 81       	ldd	r25, Y+2	; 0x02
     b0c:	ab 81       	ldd	r26, Y+3	; 0x03
     b0e:	bc 81       	ldd	r27, Y+4	; 0x04
     b10:	07 2e       	mov	r0, r23
     b12:	7a e0       	ldi	r23, 0x0A	; 10
     b14:	b6 95       	lsr	r27
     b16:	a7 95       	ror	r26
     b18:	97 95       	ror	r25
     b1a:	87 95       	ror	r24
     b1c:	7a 95       	dec	r23
     b1e:	d1 f7       	brne	.-12     	; 0xb14 <CO_collectBatt+0x324>
     b20:	70 2d       	mov	r23, r0
     b22:	89 8b       	std	Y+17, r24	; 0x11
     b24:	9a 8b       	std	Y+18, r25	; 0x12
     b26:	ab 8b       	std	Y+19, r26	; 0x13
     b28:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     b2a:	84 e0       	ldi	r24, 0x04	; 4
     b2c:	60 e0       	ldi	r22, 0x00	; 0
     b2e:	0e 94 83 35 	call	0x6b06	; 0x6b06 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b38:	89 89       	ldd	r24, Y+17	; 0x11
     b3a:	9a 89       	ldd	r25, Y+18	; 0x12
     b3c:	ab 89       	ldd	r26, Y+19	; 0x13
     b3e:	bc 89       	ldd	r27, Y+20	; 0x14
     b40:	28 ee       	ldi	r18, 0xE8	; 232
     b42:	33 e0       	ldi	r19, 0x03	; 3
     b44:	40 e0       	ldi	r20, 0x00	; 0
     b46:	50 e0       	ldi	r21, 0x00	; 0
     b48:	bc 01       	movw	r22, r24
     b4a:	cd 01       	movw	r24, r26
     b4c:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
     b50:	dc 01       	movw	r26, r24
     b52:	cb 01       	movw	r24, r22
     b54:	2f ef       	ldi	r18, 0xFF	; 255
     b56:	3f e0       	ldi	r19, 0x0F	; 15
     b58:	40 e0       	ldi	r20, 0x00	; 0
     b5a:	50 e0       	ldi	r21, 0x00	; 0
     b5c:	bc 01       	movw	r22, r24
     b5e:	cd 01       	movw	r24, r26
     b60:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
     b64:	da 01       	movw	r26, r20
     b66:	c9 01       	movw	r24, r18
     b68:	9c 01       	movw	r18, r24
     b6a:	22 53       	subi	r18, 0x32	; 50
     b6c:	30 40       	sbci	r19, 0x00	; 0
     b6e:	8c a1       	lds	r24, 0x4c
     b70:	9d a1       	lds	r25, 0x4d
     b72:	fc 01       	movw	r30, r24
     b74:	20 83       	st	Z, r18
     b76:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     b78:	89 85       	ldd	r24, Y+9	; 0x09
     b7a:	9a 85       	ldd	r25, Y+10	; 0x0a
     b7c:	ab 85       	ldd	r26, Y+11	; 0x0b
     b7e:	bc 85       	ldd	r27, Y+12	; 0x0c
     b80:	28 ee       	ldi	r18, 0xE8	; 232
     b82:	33 e0       	ldi	r19, 0x03	; 3
     b84:	40 e0       	ldi	r20, 0x00	; 0
     b86:	50 e0       	ldi	r21, 0x00	; 0
     b88:	bc 01       	movw	r22, r24
     b8a:	cd 01       	movw	r24, r26
     b8c:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
     b90:	dc 01       	movw	r26, r24
     b92:	cb 01       	movw	r24, r22
     b94:	2f ef       	ldi	r18, 0xFF	; 255
     b96:	3f e0       	ldi	r19, 0x0F	; 15
     b98:	40 e0       	ldi	r20, 0x00	; 0
     b9a:	50 e0       	ldi	r21, 0x00	; 0
     b9c:	bc 01       	movw	r22, r24
     b9e:	cd 01       	movw	r24, r26
     ba0:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
     ba4:	da 01       	movw	r26, r20
     ba6:	c9 01       	movw	r24, r18
     ba8:	9c 01       	movw	r18, r24
     baa:	22 53       	subi	r18, 0x32	; 50
     bac:	30 40       	sbci	r19, 0x00	; 0
     bae:	88 a5       	lds	r24, 0x68
     bb0:	99 a5       	lds	r25, 0x69
     bb2:	fc 01       	movw	r30, r24
     bb4:	20 83       	st	Z, r18
     bb6:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     bb8:	8d 81       	ldd	r24, Y+5	; 0x05
     bba:	9e 81       	ldd	r25, Y+6	; 0x06
     bbc:	af 81       	ldd	r26, Y+7	; 0x07
     bbe:	b8 85       	ldd	r27, Y+8	; 0x08
     bc0:	28 ee       	ldi	r18, 0xE8	; 232
     bc2:	33 e0       	ldi	r19, 0x03	; 3
     bc4:	40 e0       	ldi	r20, 0x00	; 0
     bc6:	50 e0       	ldi	r21, 0x00	; 0
     bc8:	bc 01       	movw	r22, r24
     bca:	cd 01       	movw	r24, r26
     bcc:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
     bd0:	dc 01       	movw	r26, r24
     bd2:	cb 01       	movw	r24, r22
     bd4:	2f ef       	ldi	r18, 0xFF	; 255
     bd6:	3f e0       	ldi	r19, 0x0F	; 15
     bd8:	40 e0       	ldi	r20, 0x00	; 0
     bda:	50 e0       	ldi	r21, 0x00	; 0
     bdc:	bc 01       	movw	r22, r24
     bde:	cd 01       	movw	r24, r26
     be0:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
     be4:	da 01       	movw	r26, r20
     be6:	c9 01       	movw	r24, r18
     be8:	9c 01       	movw	r18, r24
     bea:	22 53       	subi	r18, 0x32	; 50
     bec:	30 40       	sbci	r19, 0x00	; 0
     bee:	8e a1       	lds	r24, 0x4e
     bf0:	9f a1       	lds	r25, 0x4f
     bf2:	fc 01       	movw	r30, r24
     bf4:	20 83       	st	Z, r18
     bf6:	31 83       	std	Z+1, r19	; 0x01
}
     bf8:	a9 96       	adiw	r28, 0x29	; 41
     bfa:	cd bf       	out	0x3d, r28	; 61
     bfc:	de bf       	out	0x3e, r29	; 62
     bfe:	df 91       	pop	r29
     c00:	cf 91       	pop	r28
     c02:	1f 91       	pop	r17
     c04:	0f 91       	pop	r16
     c06:	08 95       	ret

00000c08 <ADCPower>:

void ADCPower(uint8_t on) {
     c08:	0f 93       	push	r16
     c0a:	1f 93       	push	r17
     c0c:	cf 93       	push	r28
     c0e:	df 93       	push	r29
     c10:	cd b7       	in	r28, 0x3d	; 61
     c12:	de b7       	in	r29, 0x3e	; 62
     c14:	2f 97       	sbiw	r28, 0x0f	; 15
     c16:	cd bf       	out	0x3d, r28	; 61
     c18:	de bf       	out	0x3e, r29	; 62
     c1a:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     c1c:	8f 85       	ldd	r24, Y+15	; 0x0f
     c1e:	88 23       	and	r24, r24
     c20:	09 f4       	brne	.+2      	; 0xc24 <ADCPower+0x1c>
     c22:	ce c0       	rjmp	.+412    	; 0xdc0 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     c24:	80 e0       	ldi	r24, 0x00	; 0
     c26:	96 e0       	ldi	r25, 0x06	; 6
     c28:	2e ed       	ldi	r18, 0xDE	; 222
     c2a:	fc 01       	movw	r30, r24
     c2c:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c2e:	80 e2       	ldi	r24, 0x20	; 32
     c30:	96 e0       	ldi	r25, 0x06	; 6
     c32:	2e e0       	ldi	r18, 0x0E	; 14
     c34:	fc 01       	movw	r30, r24
     c36:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     c38:	80 e4       	ldi	r24, 0x40	; 64
     c3a:	96 e0       	ldi	r25, 0x06	; 6
     c3c:	23 e0       	ldi	r18, 0x03	; 3
     c3e:	fc 01       	movw	r30, r24
     c40:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     c42:	80 e8       	ldi	r24, 0x80	; 128
     c44:	96 e0       	ldi	r25, 0x06	; 6
     c46:	20 e1       	ldi	r18, 0x10	; 16
     c48:	fc 01       	movw	r30, r24
     c4a:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     c4c:	80 ea       	ldi	r24, 0xA0	; 160
     c4e:	96 e0       	ldi	r25, 0x06	; 6
     c50:	2e e0       	ldi	r18, 0x0E	; 14
     c52:	fc 01       	movw	r30, r24
     c54:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     c56:	80 e0       	ldi	r24, 0x00	; 0
     c58:	96 e0       	ldi	r25, 0x06	; 6
     c5a:	2e e9       	ldi	r18, 0x9E	; 158
     c5c:	fc 01       	movw	r30, r24
     c5e:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     c60:	80 e2       	ldi	r24, 0x20	; 32
     c62:	96 e0       	ldi	r25, 0x06	; 6
     c64:	28 e0       	ldi	r18, 0x08	; 8
     c66:	fc 01       	movw	r30, r24
     c68:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c6a:	80 e4       	ldi	r24, 0x40	; 64
     c6c:	96 e0       	ldi	r25, 0x06	; 6
     c6e:	23 e0       	ldi	r18, 0x03	; 3
     c70:	fc 01       	movw	r30, r24
     c72:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     c74:	80 e8       	ldi	r24, 0x80	; 128
     c76:	96 e0       	ldi	r25, 0x06	; 6
     c78:	20 e1       	ldi	r18, 0x10	; 16
     c7a:	fc 01       	movw	r30, r24
     c7c:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c7e:	80 ea       	ldi	r24, 0xA0	; 160
     c80:	96 e0       	ldi	r25, 0x06	; 6
     c82:	2e e0       	ldi	r18, 0x0E	; 14
     c84:	fc 01       	movw	r30, r24
     c86:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     c88:	10 92 6c 50 	sts	0x506C, r1
     c8c:	80 e0       	ldi	r24, 0x00	; 0
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	a8 ec       	ldi	r26, 0xC8	; 200
     c92:	b2 e4       	ldi	r27, 0x42	; 66
     c94:	89 83       	std	Y+1, r24	; 0x01
     c96:	9a 83       	std	Y+2, r25	; 0x02
     c98:	ab 83       	std	Y+3, r26	; 0x03
     c9a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     c9c:	69 81       	ldd	r22, Y+1	; 0x01
     c9e:	7a 81       	ldd	r23, Y+2	; 0x02
     ca0:	8b 81       	ldd	r24, Y+3	; 0x03
     ca2:	9c 81       	ldd	r25, Y+4	; 0x04
     ca4:	20 e0       	ldi	r18, 0x00	; 0
     ca6:	30 e0       	ldi	r19, 0x00	; 0
     ca8:	4a ef       	ldi	r20, 0xFA	; 250
     caa:	55 e4       	ldi	r21, 0x45	; 69
     cac:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
     cb0:	dc 01       	movw	r26, r24
     cb2:	cb 01       	movw	r24, r22
     cb4:	8d 83       	std	Y+5, r24	; 0x05
     cb6:	9e 83       	std	Y+6, r25	; 0x06
     cb8:	af 83       	std	Y+7, r26	; 0x07
     cba:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     cbc:	11 e0       	ldi	r17, 0x01	; 1
     cbe:	6d 81       	ldd	r22, Y+5	; 0x05
     cc0:	7e 81       	ldd	r23, Y+6	; 0x06
     cc2:	8f 81       	ldd	r24, Y+7	; 0x07
     cc4:	98 85       	ldd	r25, Y+8	; 0x08
     cc6:	20 e0       	ldi	r18, 0x00	; 0
     cc8:	30 e0       	ldi	r19, 0x00	; 0
     cca:	40 e8       	ldi	r20, 0x80	; 128
     ccc:	5f e3       	ldi	r21, 0x3F	; 63
     cce:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
     cd2:	88 23       	and	r24, r24
     cd4:	0c f0       	brlt	.+2      	; 0xcd8 <ADCPower+0xd0>
     cd6:	10 e0       	ldi	r17, 0x00	; 0
     cd8:	11 23       	and	r17, r17
     cda:	29 f0       	breq	.+10     	; 0xce6 <ADCPower+0xde>
		__ticks = 1;
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	89 87       	std	Y+9, r24	; 0x09
     ce2:	9a 87       	std	Y+10, r25	; 0x0a
     ce4:	46 c0       	rjmp	.+140    	; 0xd72 <ADCPower+0x16a>
	else if (__tmp > 65535)
     ce6:	11 e0       	ldi	r17, 0x01	; 1
     ce8:	6d 81       	ldd	r22, Y+5	; 0x05
     cea:	7e 81       	ldd	r23, Y+6	; 0x06
     cec:	8f 81       	ldd	r24, Y+7	; 0x07
     cee:	98 85       	ldd	r25, Y+8	; 0x08
     cf0:	20 e0       	ldi	r18, 0x00	; 0
     cf2:	3f ef       	ldi	r19, 0xFF	; 255
     cf4:	4f e7       	ldi	r20, 0x7F	; 127
     cf6:	57 e4       	ldi	r21, 0x47	; 71
     cf8:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
     cfc:	18 16       	cp	r1, r24
     cfe:	0c f0       	brlt	.+2      	; 0xd02 <ADCPower+0xfa>
     d00:	10 e0       	ldi	r17, 0x00	; 0
     d02:	11 23       	and	r17, r17
     d04:	61 f1       	breq	.+88     	; 0xd5e <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d06:	69 81       	ldd	r22, Y+1	; 0x01
     d08:	7a 81       	ldd	r23, Y+2	; 0x02
     d0a:	8b 81       	ldd	r24, Y+3	; 0x03
     d0c:	9c 81       	ldd	r25, Y+4	; 0x04
     d0e:	20 e0       	ldi	r18, 0x00	; 0
     d10:	30 e0       	ldi	r19, 0x00	; 0
     d12:	40 e2       	ldi	r20, 0x20	; 32
     d14:	51 e4       	ldi	r21, 0x41	; 65
     d16:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
     d1a:	dc 01       	movw	r26, r24
     d1c:	cb 01       	movw	r24, r22
     d1e:	bc 01       	movw	r22, r24
     d20:	cd 01       	movw	r24, r26
     d22:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
     d26:	dc 01       	movw	r26, r24
     d28:	cb 01       	movw	r24, r22
     d2a:	89 87       	std	Y+9, r24	; 0x09
     d2c:	9a 87       	std	Y+10, r25	; 0x0a
     d2e:	12 c0       	rjmp	.+36     	; 0xd54 <ADCPower+0x14c>
     d30:	80 e2       	ldi	r24, 0x20	; 32
     d32:	93 e0       	ldi	r25, 0x03	; 3
     d34:	8b 87       	std	Y+11, r24	; 0x0b
     d36:	9c 87       	std	Y+12, r25	; 0x0c
     d38:	8b 85       	ldd	r24, Y+11	; 0x0b
     d3a:	9c 85       	ldd	r25, Y+12	; 0x0c
     d3c:	8c 01       	movw	r16, r24
     d3e:	c8 01       	movw	r24, r16
     d40:	01 97       	sbiw	r24, 0x01	; 1
     d42:	f1 f7       	brne	.-4      	; 0xd40 <ADCPower+0x138>
     d44:	8c 01       	movw	r16, r24
     d46:	0b 87       	std	Y+11, r16	; 0x0b
     d48:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d4a:	89 85       	ldd	r24, Y+9	; 0x09
     d4c:	9a 85       	ldd	r25, Y+10	; 0x0a
     d4e:	01 97       	sbiw	r24, 0x01	; 1
     d50:	89 87       	std	Y+9, r24	; 0x09
     d52:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d54:	89 85       	ldd	r24, Y+9	; 0x09
     d56:	9a 85       	ldd	r25, Y+10	; 0x0a
     d58:	00 97       	sbiw	r24, 0x00	; 0
     d5a:	51 f7       	brne	.-44     	; 0xd30 <ADCPower+0x128>
     d5c:	17 c0       	rjmp	.+46     	; 0xd8c <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d5e:	6d 81       	ldd	r22, Y+5	; 0x05
     d60:	7e 81       	ldd	r23, Y+6	; 0x06
     d62:	8f 81       	ldd	r24, Y+7	; 0x07
     d64:	98 85       	ldd	r25, Y+8	; 0x08
     d66:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
     d6a:	dc 01       	movw	r26, r24
     d6c:	cb 01       	movw	r24, r22
     d6e:	89 87       	std	Y+9, r24	; 0x09
     d70:	9a 87       	std	Y+10, r25	; 0x0a
     d72:	89 85       	ldd	r24, Y+9	; 0x09
     d74:	9a 85       	ldd	r25, Y+10	; 0x0a
     d76:	8d 87       	std	Y+13, r24	; 0x0d
     d78:	9e 87       	std	Y+14, r25	; 0x0e
     d7a:	8d 85       	ldd	r24, Y+13	; 0x0d
     d7c:	9e 85       	ldd	r25, Y+14	; 0x0e
     d7e:	8c 01       	movw	r16, r24
     d80:	f8 01       	movw	r30, r16
     d82:	31 97       	sbiw	r30, 0x01	; 1
     d84:	f1 f7       	brne	.-4      	; 0xd82 <ADCPower+0x17a>
     d86:	8f 01       	movw	r16, r30
     d88:	0d 87       	std	Y+13, r16	; 0x0d
     d8a:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     d8c:	80 e4       	ldi	r24, 0x40	; 64
     d8e:	96 e0       	ldi	r25, 0x06	; 6
     d90:	20 e4       	ldi	r18, 0x40	; 64
     d92:	fc 01       	movw	r30, r24
     d94:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     d96:	80 e0       	ldi	r24, 0x00	; 0
     d98:	80 93 6d 50 	sts	0x506D, r24
     d9c:	80 93 d5 50 	sts	0x50D5, r24
     da0:	80 93 c5 23 	sts	0x23C5, r24
     da4:	80 93 65 50 	sts	0x5065, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     da8:	8f ef       	ldi	r24, 0xFF	; 255
     daa:	61 e0       	ldi	r22, 0x01	; 1
     dac:	0e 94 1f 35 	call	0x6a3e	; 0x6a3e <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     db0:	8f ef       	ldi	r24, 0xFF	; 255
     db2:	61 e0       	ldi	r22, 0x01	; 1
     db4:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     db8:	8f ef       	ldi	r24, 0xFF	; 255
     dba:	0e 94 59 08 	call	0x10b2	; 0x10b2 <set_filter>
     dbe:	42 c0       	rjmp	.+132    	; 0xe44 <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	96 e0       	ldi	r25, 0x06	; 6
     dc4:	2e ed       	ldi	r18, 0xDE	; 222
     dc6:	fc 01       	movw	r30, r24
     dc8:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     dca:	80 e2       	ldi	r24, 0x20	; 32
     dcc:	96 e0       	ldi	r25, 0x06	; 6
     dce:	2e e0       	ldi	r18, 0x0E	; 14
     dd0:	fc 01       	movw	r30, r24
     dd2:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     dd4:	80 e4       	ldi	r24, 0x40	; 64
     dd6:	96 e0       	ldi	r25, 0x06	; 6
     dd8:	23 e0       	ldi	r18, 0x03	; 3
     dda:	fc 01       	movw	r30, r24
     ddc:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     dde:	80 e8       	ldi	r24, 0x80	; 128
     de0:	96 e0       	ldi	r25, 0x06	; 6
     de2:	20 e1       	ldi	r18, 0x10	; 16
     de4:	fc 01       	movw	r30, r24
     de6:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     de8:	80 ea       	ldi	r24, 0xA0	; 160
     dea:	96 e0       	ldi	r25, 0x06	; 6
     dec:	2e e0       	ldi	r18, 0x0E	; 14
     dee:	fc 01       	movw	r30, r24
     df0:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     df2:	80 e0       	ldi	r24, 0x00	; 0
     df4:	96 e0       	ldi	r25, 0x06	; 6
     df6:	2e ed       	ldi	r18, 0xDE	; 222
     df8:	fc 01       	movw	r30, r24
     dfa:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     dfc:	80 e2       	ldi	r24, 0x20	; 32
     dfe:	96 e0       	ldi	r25, 0x06	; 6
     e00:	2e e0       	ldi	r18, 0x0E	; 14
     e02:	fc 01       	movw	r30, r24
     e04:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     e06:	80 e4       	ldi	r24, 0x40	; 64
     e08:	96 e0       	ldi	r25, 0x06	; 6
     e0a:	23 e0       	ldi	r18, 0x03	; 3
     e0c:	fc 01       	movw	r30, r24
     e0e:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     e10:	80 e8       	ldi	r24, 0x80	; 128
     e12:	96 e0       	ldi	r25, 0x06	; 6
     e14:	20 e1       	ldi	r18, 0x10	; 16
     e16:	fc 01       	movw	r30, r24
     e18:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     e1a:	80 ea       	ldi	r24, 0xA0	; 160
     e1c:	96 e0       	ldi	r25, 0x06	; 6
     e1e:	2e e0       	ldi	r18, 0x0E	; 14
     e20:	fc 01       	movw	r30, r24
     e22:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     e24:	80 e4       	ldi	r24, 0x40	; 64
     e26:	96 e0       	ldi	r25, 0x06	; 6
     e28:	20 e4       	ldi	r18, 0x40	; 64
     e2a:	fc 01       	movw	r30, r24
     e2c:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	80 93 6d 50 	sts	0x506D, r24
     e34:	80 93 d5 50 	sts	0x50D5, r24
     e38:	80 93 c5 23 	sts	0x23C5, r24
     e3c:	80 93 65 50 	sts	0x5065, r24
		channelStatus = 0x00;
     e40:	10 92 6c 50 	sts	0x506C, r1
		
	}
}
     e44:	2f 96       	adiw	r28, 0x0f	; 15
     e46:	cd bf       	out	0x3d, r28	; 61
     e48:	de bf       	out	0x3e, r29	; 62
     e4a:	df 91       	pop	r29
     e4c:	cf 91       	pop	r28
     e4e:	1f 91       	pop	r17
     e50:	0f 91       	pop	r16
     e52:	08 95       	ret

00000e54 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     e54:	0f 93       	push	r16
     e56:	1f 93       	push	r17
     e58:	cf 93       	push	r28
     e5a:	df 93       	push	r29
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
     e60:	6a 97       	sbiw	r28, 0x1a	; 26
     e62:	cd bf       	out	0x3d, r28	; 61
     e64:	de bf       	out	0x3e, r29	; 62
     e66:	89 8f       	std	Y+25, r24	; 0x19
     e68:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     e6a:	89 8d       	ldd	r24, Y+25	; 0x19
     e6c:	28 2f       	mov	r18, r24
     e6e:	30 e0       	ldi	r19, 0x00	; 0
     e70:	81 e0       	ldi	r24, 0x01	; 1
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	02 c0       	rjmp	.+4      	; 0xe7a <set_ampGain+0x26>
     e76:	88 0f       	add	r24, r24
     e78:	99 1f       	adc	r25, r25
     e7a:	2a 95       	dec	r18
     e7c:	e2 f7       	brpl	.-8      	; 0xe76 <set_ampGain+0x22>
     e7e:	61 e0       	ldi	r22, 0x01	; 1
     e80:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     e84:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e86:	88 2f       	mov	r24, r24
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	81 70       	andi	r24, 0x01	; 1
     e8c:	90 70       	andi	r25, 0x00	; 0
     e8e:	88 23       	and	r24, r24
     e90:	31 f0       	breq	.+12     	; 0xe9e <set_ampGain+0x4a>
     e92:	80 e0       	ldi	r24, 0x00	; 0
     e94:	96 e0       	ldi	r25, 0x06	; 6
     e96:	20 e4       	ldi	r18, 0x40	; 64
     e98:	fc 01       	movw	r30, r24
     e9a:	25 83       	std	Z+5, r18	; 0x05
     e9c:	05 c0       	rjmp	.+10     	; 0xea8 <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	96 e0       	ldi	r25, 0x06	; 6
     ea2:	20 e4       	ldi	r18, 0x40	; 64
     ea4:	fc 01       	movw	r30, r24
     ea6:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     ea8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     eaa:	88 2f       	mov	r24, r24
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	82 70       	andi	r24, 0x02	; 2
     eb0:	90 70       	andi	r25, 0x00	; 0
     eb2:	00 97       	sbiw	r24, 0x00	; 0
     eb4:	31 f0       	breq	.+12     	; 0xec2 <set_ampGain+0x6e>
     eb6:	80 e2       	ldi	r24, 0x20	; 32
     eb8:	96 e0       	ldi	r25, 0x06	; 6
     eba:	22 e0       	ldi	r18, 0x02	; 2
     ebc:	fc 01       	movw	r30, r24
     ebe:	25 83       	std	Z+5, r18	; 0x05
     ec0:	05 c0       	rjmp	.+10     	; 0xecc <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     ec2:	80 e2       	ldi	r24, 0x20	; 32
     ec4:	96 e0       	ldi	r25, 0x06	; 6
     ec6:	22 e0       	ldi	r18, 0x02	; 2
     ec8:	fc 01       	movw	r30, r24
     eca:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     ecc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ece:	88 2f       	mov	r24, r24
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	84 70       	andi	r24, 0x04	; 4
     ed4:	90 70       	andi	r25, 0x00	; 0
     ed6:	00 97       	sbiw	r24, 0x00	; 0
     ed8:	31 f0       	breq	.+12     	; 0xee6 <set_ampGain+0x92>
     eda:	80 e2       	ldi	r24, 0x20	; 32
     edc:	96 e0       	ldi	r25, 0x06	; 6
     ede:	24 e0       	ldi	r18, 0x04	; 4
     ee0:	fc 01       	movw	r30, r24
     ee2:	25 83       	std	Z+5, r18	; 0x05
     ee4:	05 c0       	rjmp	.+10     	; 0xef0 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     ee6:	80 e2       	ldi	r24, 0x20	; 32
     ee8:	96 e0       	ldi	r25, 0x06	; 6
     eea:	24 e0       	ldi	r18, 0x04	; 4
     eec:	fc 01       	movw	r30, r24
     eee:	26 83       	std	Z+6, r18	; 0x06
     ef0:	80 e0       	ldi	r24, 0x00	; 0
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	a0 e8       	ldi	r26, 0x80	; 128
     ef6:	bf e3       	ldi	r27, 0x3F	; 63
     ef8:	89 83       	std	Y+1, r24	; 0x01
     efa:	9a 83       	std	Y+2, r25	; 0x02
     efc:	ab 83       	std	Y+3, r26	; 0x03
     efe:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     f00:	69 81       	ldd	r22, Y+1	; 0x01
     f02:	7a 81       	ldd	r23, Y+2	; 0x02
     f04:	8b 81       	ldd	r24, Y+3	; 0x03
     f06:	9c 81       	ldd	r25, Y+4	; 0x04
     f08:	2b ea       	ldi	r18, 0xAB	; 171
     f0a:	3a ea       	ldi	r19, 0xAA	; 170
     f0c:	4a e2       	ldi	r20, 0x2A	; 42
     f0e:	51 e4       	ldi	r21, 0x41	; 65
     f10:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
     f14:	dc 01       	movw	r26, r24
     f16:	cb 01       	movw	r24, r22
     f18:	8d 83       	std	Y+5, r24	; 0x05
     f1a:	9e 83       	std	Y+6, r25	; 0x06
     f1c:	af 83       	std	Y+7, r26	; 0x07
     f1e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     f20:	11 e0       	ldi	r17, 0x01	; 1
     f22:	6d 81       	ldd	r22, Y+5	; 0x05
     f24:	7e 81       	ldd	r23, Y+6	; 0x06
     f26:	8f 81       	ldd	r24, Y+7	; 0x07
     f28:	98 85       	ldd	r25, Y+8	; 0x08
     f2a:	20 e0       	ldi	r18, 0x00	; 0
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	40 e8       	ldi	r20, 0x80	; 128
     f30:	5f e3       	ldi	r21, 0x3F	; 63
     f32:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
     f36:	88 23       	and	r24, r24
     f38:	0c f0       	brlt	.+2      	; 0xf3c <set_ampGain+0xe8>
     f3a:	10 e0       	ldi	r17, 0x00	; 0
     f3c:	11 23       	and	r17, r17
     f3e:	19 f0       	breq	.+6      	; 0xf46 <set_ampGain+0xf2>
		__ticks = 1;
     f40:	81 e0       	ldi	r24, 0x01	; 1
     f42:	89 87       	std	Y+9, r24	; 0x09
     f44:	a3 c0       	rjmp	.+326    	; 0x108c <set_ampGain+0x238>
	else if (__tmp > 255)
     f46:	11 e0       	ldi	r17, 0x01	; 1
     f48:	6d 81       	ldd	r22, Y+5	; 0x05
     f4a:	7e 81       	ldd	r23, Y+6	; 0x06
     f4c:	8f 81       	ldd	r24, Y+7	; 0x07
     f4e:	98 85       	ldd	r25, Y+8	; 0x08
     f50:	20 e0       	ldi	r18, 0x00	; 0
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	4f e7       	ldi	r20, 0x7F	; 127
     f56:	53 e4       	ldi	r21, 0x43	; 67
     f58:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
     f5c:	18 16       	cp	r1, r24
     f5e:	0c f0       	brlt	.+2      	; 0xf62 <set_ampGain+0x10e>
     f60:	10 e0       	ldi	r17, 0x00	; 0
     f62:	11 23       	and	r17, r17
     f64:	09 f4       	brne	.+2      	; 0xf68 <set_ampGain+0x114>
     f66:	89 c0       	rjmp	.+274    	; 0x107a <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     f68:	69 81       	ldd	r22, Y+1	; 0x01
     f6a:	7a 81       	ldd	r23, Y+2	; 0x02
     f6c:	8b 81       	ldd	r24, Y+3	; 0x03
     f6e:	9c 81       	ldd	r25, Y+4	; 0x04
     f70:	20 e0       	ldi	r18, 0x00	; 0
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	4a e7       	ldi	r20, 0x7A	; 122
     f76:	54 e4       	ldi	r21, 0x44	; 68
     f78:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
     f7c:	dc 01       	movw	r26, r24
     f7e:	cb 01       	movw	r24, r22
     f80:	8a 87       	std	Y+10, r24	; 0x0a
     f82:	9b 87       	std	Y+11, r25	; 0x0b
     f84:	ac 87       	std	Y+12, r26	; 0x0c
     f86:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     f88:	6a 85       	ldd	r22, Y+10	; 0x0a
     f8a:	7b 85       	ldd	r23, Y+11	; 0x0b
     f8c:	8c 85       	ldd	r24, Y+12	; 0x0c
     f8e:	9d 85       	ldd	r25, Y+13	; 0x0d
     f90:	20 e0       	ldi	r18, 0x00	; 0
     f92:	30 e0       	ldi	r19, 0x00	; 0
     f94:	4a ef       	ldi	r20, 0xFA	; 250
     f96:	55 e4       	ldi	r21, 0x45	; 69
     f98:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
     f9c:	dc 01       	movw	r26, r24
     f9e:	cb 01       	movw	r24, r22
     fa0:	8e 87       	std	Y+14, r24	; 0x0e
     fa2:	9f 87       	std	Y+15, r25	; 0x0f
     fa4:	a8 8b       	std	Y+16, r26	; 0x10
     fa6:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     fa8:	11 e0       	ldi	r17, 0x01	; 1
     faa:	6e 85       	ldd	r22, Y+14	; 0x0e
     fac:	7f 85       	ldd	r23, Y+15	; 0x0f
     fae:	88 89       	ldd	r24, Y+16	; 0x10
     fb0:	99 89       	ldd	r25, Y+17	; 0x11
     fb2:	20 e0       	ldi	r18, 0x00	; 0
     fb4:	30 e0       	ldi	r19, 0x00	; 0
     fb6:	40 e8       	ldi	r20, 0x80	; 128
     fb8:	5f e3       	ldi	r21, 0x3F	; 63
     fba:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
     fbe:	88 23       	and	r24, r24
     fc0:	0c f0       	brlt	.+2      	; 0xfc4 <set_ampGain+0x170>
     fc2:	10 e0       	ldi	r17, 0x00	; 0
     fc4:	11 23       	and	r17, r17
     fc6:	29 f0       	breq	.+10     	; 0xfd2 <set_ampGain+0x17e>
		__ticks = 1;
     fc8:	81 e0       	ldi	r24, 0x01	; 1
     fca:	90 e0       	ldi	r25, 0x00	; 0
     fcc:	8a 8b       	std	Y+18, r24	; 0x12
     fce:	9b 8b       	std	Y+19, r25	; 0x13
     fd0:	46 c0       	rjmp	.+140    	; 0x105e <set_ampGain+0x20a>
	else if (__tmp > 65535)
     fd2:	11 e0       	ldi	r17, 0x01	; 1
     fd4:	6e 85       	ldd	r22, Y+14	; 0x0e
     fd6:	7f 85       	ldd	r23, Y+15	; 0x0f
     fd8:	88 89       	ldd	r24, Y+16	; 0x10
     fda:	99 89       	ldd	r25, Y+17	; 0x11
     fdc:	20 e0       	ldi	r18, 0x00	; 0
     fde:	3f ef       	ldi	r19, 0xFF	; 255
     fe0:	4f e7       	ldi	r20, 0x7F	; 127
     fe2:	57 e4       	ldi	r21, 0x47	; 71
     fe4:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
     fe8:	18 16       	cp	r1, r24
     fea:	0c f0       	brlt	.+2      	; 0xfee <set_ampGain+0x19a>
     fec:	10 e0       	ldi	r17, 0x00	; 0
     fee:	11 23       	and	r17, r17
     ff0:	61 f1       	breq	.+88     	; 0x104a <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ff2:	6a 85       	ldd	r22, Y+10	; 0x0a
     ff4:	7b 85       	ldd	r23, Y+11	; 0x0b
     ff6:	8c 85       	ldd	r24, Y+12	; 0x0c
     ff8:	9d 85       	ldd	r25, Y+13	; 0x0d
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	40 e2       	ldi	r20, 0x20	; 32
    1000:	51 e4       	ldi	r21, 0x41	; 65
    1002:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    1006:	dc 01       	movw	r26, r24
    1008:	cb 01       	movw	r24, r22
    100a:	bc 01       	movw	r22, r24
    100c:	cd 01       	movw	r24, r26
    100e:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    1012:	dc 01       	movw	r26, r24
    1014:	cb 01       	movw	r24, r22
    1016:	8a 8b       	std	Y+18, r24	; 0x12
    1018:	9b 8b       	std	Y+19, r25	; 0x13
    101a:	12 c0       	rjmp	.+36     	; 0x1040 <set_ampGain+0x1ec>
    101c:	80 e2       	ldi	r24, 0x20	; 32
    101e:	93 e0       	ldi	r25, 0x03	; 3
    1020:	8c 8b       	std	Y+20, r24	; 0x14
    1022:	9d 8b       	std	Y+21, r25	; 0x15
    1024:	8c 89       	ldd	r24, Y+20	; 0x14
    1026:	9d 89       	ldd	r25, Y+21	; 0x15
    1028:	8c 01       	movw	r16, r24
    102a:	c8 01       	movw	r24, r16
    102c:	01 97       	sbiw	r24, 0x01	; 1
    102e:	f1 f7       	brne	.-4      	; 0x102c <set_ampGain+0x1d8>
    1030:	8c 01       	movw	r16, r24
    1032:	0c 8b       	std	Y+20, r16	; 0x14
    1034:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1036:	8a 89       	ldd	r24, Y+18	; 0x12
    1038:	9b 89       	ldd	r25, Y+19	; 0x13
    103a:	01 97       	sbiw	r24, 0x01	; 1
    103c:	8a 8b       	std	Y+18, r24	; 0x12
    103e:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1040:	8a 89       	ldd	r24, Y+18	; 0x12
    1042:	9b 89       	ldd	r25, Y+19	; 0x13
    1044:	00 97       	sbiw	r24, 0x00	; 0
    1046:	51 f7       	brne	.-44     	; 0x101c <set_ampGain+0x1c8>
    1048:	28 c0       	rjmp	.+80     	; 0x109a <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    104a:	6e 85       	ldd	r22, Y+14	; 0x0e
    104c:	7f 85       	ldd	r23, Y+15	; 0x0f
    104e:	88 89       	ldd	r24, Y+16	; 0x10
    1050:	99 89       	ldd	r25, Y+17	; 0x11
    1052:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    1056:	dc 01       	movw	r26, r24
    1058:	cb 01       	movw	r24, r22
    105a:	8a 8b       	std	Y+18, r24	; 0x12
    105c:	9b 8b       	std	Y+19, r25	; 0x13
    105e:	8a 89       	ldd	r24, Y+18	; 0x12
    1060:	9b 89       	ldd	r25, Y+19	; 0x13
    1062:	8e 8b       	std	Y+22, r24	; 0x16
    1064:	9f 8b       	std	Y+23, r25	; 0x17
    1066:	8e 89       	ldd	r24, Y+22	; 0x16
    1068:	9f 89       	ldd	r25, Y+23	; 0x17
    106a:	8c 01       	movw	r16, r24
    106c:	f8 01       	movw	r30, r16
    106e:	31 97       	sbiw	r30, 0x01	; 1
    1070:	f1 f7       	brne	.-4      	; 0x106e <set_ampGain+0x21a>
    1072:	8f 01       	movw	r16, r30
    1074:	0e 8b       	std	Y+22, r16	; 0x16
    1076:	1f 8b       	std	Y+23, r17	; 0x17
    1078:	10 c0       	rjmp	.+32     	; 0x109a <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    107a:	6d 81       	ldd	r22, Y+5	; 0x05
    107c:	7e 81       	ldd	r23, Y+6	; 0x06
    107e:	8f 81       	ldd	r24, Y+7	; 0x07
    1080:	98 85       	ldd	r25, Y+8	; 0x08
    1082:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    1086:	dc 01       	movw	r26, r24
    1088:	cb 01       	movw	r24, r22
    108a:	89 87       	std	Y+9, r24	; 0x09
    108c:	89 85       	ldd	r24, Y+9	; 0x09
    108e:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1090:	88 8d       	ldd	r24, Y+24	; 0x18
    1092:	18 2f       	mov	r17, r24
    1094:	1a 95       	dec	r17
    1096:	f1 f7       	brne	.-4      	; 0x1094 <set_ampGain+0x240>
    1098:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    109a:	8f ef       	ldi	r24, 0xFF	; 255
    109c:	61 e0       	ldi	r22, 0x01	; 1
    109e:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    10a2:	6a 96       	adiw	r28, 0x1a	; 26
    10a4:	cd bf       	out	0x3d, r28	; 61
    10a6:	de bf       	out	0x3e, r29	; 62
    10a8:	df 91       	pop	r29
    10aa:	cf 91       	pop	r28
    10ac:	1f 91       	pop	r17
    10ae:	0f 91       	pop	r16
    10b0:	08 95       	ret

000010b2 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    10b2:	cf 93       	push	r28
    10b4:	df 93       	push	r29
    10b6:	00 d0       	rcall	.+0      	; 0x10b8 <set_filter+0x6>
    10b8:	cd b7       	in	r28, 0x3d	; 61
    10ba:	de b7       	in	r29, 0x3e	; 62
    10bc:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    10be:	8b 81       	ldd	r24, Y+3	; 0x03
    10c0:	83 70       	andi	r24, 0x03	; 3
    10c2:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    10c4:	8b 81       	ldd	r24, Y+3	; 0x03
    10c6:	8c 70       	andi	r24, 0x0C	; 12
    10c8:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    10ca:	8b 81       	ldd	r24, Y+3	; 0x03
    10cc:	88 2f       	mov	r24, r24
    10ce:	90 e0       	ldi	r25, 0x00	; 0
    10d0:	85 70       	andi	r24, 0x05	; 5
    10d2:	90 70       	andi	r25, 0x00	; 0
    10d4:	00 97       	sbiw	r24, 0x00	; 0
    10d6:	51 f0       	breq	.+20     	; 0x10ec <set_filter+0x3a>
    10d8:	80 91 6c 50 	lds	r24, 0x506C
    10dc:	98 2f       	mov	r25, r24
    10de:	90 7f       	andi	r25, 0xF0	; 240
    10e0:	8b 81       	ldd	r24, Y+3	; 0x03
    10e2:	82 95       	swap	r24
    10e4:	8f 70       	andi	r24, 0x0F	; 15
    10e6:	89 2b       	or	r24, r25
    10e8:	80 93 6c 50 	sts	0x506C, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    10ec:	8b 81       	ldd	r24, Y+3	; 0x03
    10ee:	88 2f       	mov	r24, r24
    10f0:	90 e0       	ldi	r25, 0x00	; 0
    10f2:	8a 70       	andi	r24, 0x0A	; 10
    10f4:	90 70       	andi	r25, 0x00	; 0
    10f6:	00 97       	sbiw	r24, 0x00	; 0
    10f8:	49 f0       	breq	.+18     	; 0x110c <set_filter+0x5a>
    10fa:	8b 81       	ldd	r24, Y+3	; 0x03
    10fc:	98 2f       	mov	r25, r24
    10fe:	90 7f       	andi	r25, 0xF0	; 240
    1100:	80 91 6c 50 	lds	r24, 0x506C
    1104:	8f 70       	andi	r24, 0x0F	; 15
    1106:	89 2b       	or	r24, r25
    1108:	80 93 6c 50 	sts	0x506C, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    110c:	84 e0       	ldi	r24, 0x04	; 4
    110e:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    1112:	80 91 6c 50 	lds	r24, 0x506C
    1116:	80 93 54 50 	sts	0x5054, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    111a:	89 81       	ldd	r24, Y+1	; 0x01
    111c:	88 23       	and	r24, r24
    111e:	19 f0       	breq	.+6      	; 0x1126 <set_filter+0x74>
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	0e 94 8b 39 	call	0x7316	; 0x7316 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    1126:	8a 81       	ldd	r24, Y+2	; 0x02
    1128:	88 23       	and	r24, r24
    112a:	19 f0       	breq	.+6      	; 0x1132 <set_filter+0x80>
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	0e 94 a3 39 	call	0x7346	; 0x7346 <upperMuxCS>

	SPICS(TRUE);
    1132:	81 e0       	ldi	r24, 0x01	; 1
    1134:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    1138:	80 ec       	ldi	r24, 0xC0	; 192
    113a:	98 e0       	ldi	r25, 0x08	; 8
    113c:	2f ef       	ldi	r18, 0xFF	; 255
    113e:	fc 01       	movw	r30, r24
    1140:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1142:	00 00       	nop
    1144:	80 ec       	ldi	r24, 0xC0	; 192
    1146:	98 e0       	ldi	r25, 0x08	; 8
    1148:	fc 01       	movw	r30, r24
    114a:	82 81       	ldd	r24, Z+2	; 0x02
    114c:	88 23       	and	r24, r24
    114e:	d4 f7       	brge	.-12     	; 0x1144 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    1150:	80 ec       	ldi	r24, 0xC0	; 192
    1152:	98 e0       	ldi	r25, 0x08	; 8
    1154:	fc 01       	movw	r30, r24
    1156:	83 81       	ldd	r24, Z+3	; 0x03
    1158:	80 93 60 50 	sts	0x5060, r24

	nop();
    115c:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    115e:	80 ec       	ldi	r24, 0xC0	; 192
    1160:	98 e0       	ldi	r25, 0x08	; 8
    1162:	20 91 54 50 	lds	r18, 0x5054
    1166:	fc 01       	movw	r30, r24
    1168:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    116a:	00 00       	nop
    116c:	80 ec       	ldi	r24, 0xC0	; 192
    116e:	98 e0       	ldi	r25, 0x08	; 8
    1170:	fc 01       	movw	r30, r24
    1172:	82 81       	ldd	r24, Z+2	; 0x02
    1174:	88 23       	and	r24, r24
    1176:	d4 f7       	brge	.-12     	; 0x116c <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    1178:	80 ec       	ldi	r24, 0xC0	; 192
    117a:	98 e0       	ldi	r25, 0x08	; 8
    117c:	fc 01       	movw	r30, r24
    117e:	83 81       	ldd	r24, Z+3	; 0x03
    1180:	80 93 60 50 	sts	0x5060, r24
	SPICS(FALSE);
    1184:	80 e0       	ldi	r24, 0x00	; 0
    1186:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    118a:	89 81       	ldd	r24, Y+1	; 0x01
    118c:	88 23       	and	r24, r24
    118e:	19 f0       	breq	.+6      	; 0x1196 <set_filter+0xe4>
    1190:	80 e0       	ldi	r24, 0x00	; 0
    1192:	0e 94 8b 39 	call	0x7316	; 0x7316 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    1196:	8a 81       	ldd	r24, Y+2	; 0x02
    1198:	88 23       	and	r24, r24
    119a:	19 f0       	breq	.+6      	; 0x11a2 <set_filter+0xf0>
    119c:	80 e0       	ldi	r24, 0x00	; 0
    119e:	0e 94 a3 39 	call	0x7346	; 0x7346 <upperMuxCS>
	SPIDisable();
    11a2:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
}
    11a6:	23 96       	adiw	r28, 0x03	; 3
    11a8:	cd bf       	out	0x3d, r28	; 61
    11aa:	de bf       	out	0x3e, r29	; 62
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	08 95       	ret

000011b2 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    11b2:	cf 93       	push	r28
    11b4:	df 93       	push	r29
    11b6:	0f 92       	push	r0
    11b8:	cd b7       	in	r28, 0x3d	; 61
    11ba:	de b7       	in	r29, 0x3e	; 62
    11bc:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    11be:	89 81       	ldd	r24, Y+1	; 0x01
    11c0:	88 23       	and	r24, r24
    11c2:	59 f0       	breq	.+22     	; 0x11da <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    11c4:	80 e0       	ldi	r24, 0x00	; 0
    11c6:	96 e0       	ldi	r25, 0x06	; 6
    11c8:	20 e2       	ldi	r18, 0x20	; 32
    11ca:	fc 01       	movw	r30, r24
    11cc:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    11ce:	80 e0       	ldi	r24, 0x00	; 0
    11d0:	96 e0       	ldi	r25, 0x06	; 6
    11d2:	20 e2       	ldi	r18, 0x20	; 32
    11d4:	fc 01       	movw	r30, r24
    11d6:	25 83       	std	Z+5, r18	; 0x05
    11d8:	0a c0       	rjmp	.+20     	; 0x11ee <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    11da:	80 e0       	ldi	r24, 0x00	; 0
    11dc:	96 e0       	ldi	r25, 0x06	; 6
    11de:	20 e2       	ldi	r18, 0x20	; 32
    11e0:	fc 01       	movw	r30, r24
    11e2:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    11e4:	80 e0       	ldi	r24, 0x00	; 0
    11e6:	96 e0       	ldi	r25, 0x06	; 6
    11e8:	20 e2       	ldi	r18, 0x20	; 32
    11ea:	fc 01       	movw	r30, r24
    11ec:	22 83       	std	Z+2, r18	; 0x02
	}
}
    11ee:	0f 90       	pop	r0
    11f0:	df 91       	pop	r29
    11f2:	cf 91       	pop	r28
    11f4:	08 95       	ret

000011f6 <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {
    11f6:	2f 92       	push	r2
    11f8:	3f 92       	push	r3
    11fa:	4f 92       	push	r4
    11fc:	5f 92       	push	r5
    11fe:	6f 92       	push	r6
    1200:	7f 92       	push	r7
    1202:	8f 92       	push	r8
    1204:	9f 92       	push	r9
    1206:	af 92       	push	r10
    1208:	bf 92       	push	r11
    120a:	cf 92       	push	r12
    120c:	df 92       	push	r13
    120e:	ef 92       	push	r14
    1210:	ff 92       	push	r15
    1212:	0f 93       	push	r16
    1214:	1f 93       	push	r17
    1216:	cf 93       	push	r28
    1218:	df 93       	push	r29
    121a:	cd b7       	in	r28, 0x3d	; 61
    121c:	de b7       	in	r29, 0x3e	; 62
    121e:	ec 97       	sbiw	r28, 0x3c	; 60
    1220:	cd bf       	out	0x3d, r28	; 61
    1222:	de bf       	out	0x3e, r29	; 62
    1224:	8b a3       	lds	r24, 0x5b
    1226:	6c a3       	lds	r22, 0x5c
    1228:	4d a3       	lds	r20, 0x5d
    122a:	5e a3       	lds	r21, 0x5e
    122c:	2f a3       	lds	r18, 0x5f
    122e:	38 a7       	lds	r19, 0x78
    1230:	09 a7       	lds	r16, 0x79
    1232:	1a a7       	lds	r17, 0x7a
    1234:	eb a6       	lds	r30, 0xbb
    1236:	cc a6       	lds	r28, 0xbc

	int64_t sum = 0;
    1238:	19 82       	std	Y+1, r1	; 0x01
    123a:	1a 82       	std	Y+2, r1	; 0x02
    123c:	1b 82       	std	Y+3, r1	; 0x03
    123e:	1c 82       	std	Y+4, r1	; 0x04
    1240:	1d 82       	std	Y+5, r1	; 0x05
    1242:	1e 82       	std	Y+6, r1	; 0x06
    1244:	1f 82       	std	Y+7, r1	; 0x07
    1246:	18 86       	std	Y+8, r1	; 0x08
	int64_t average;
	int64_t min = ADC_MAX;
    1248:	8f ef       	ldi	r24, 0xFF	; 255
    124a:	89 87       	std	Y+9, r24	; 0x09
    124c:	8f ef       	ldi	r24, 0xFF	; 255
    124e:	8a 87       	std	Y+10, r24	; 0x0a
    1250:	8f e7       	ldi	r24, 0x7F	; 127
    1252:	8b 87       	std	Y+11, r24	; 0x0b
    1254:	1c 86       	std	Y+12, r1	; 0x0c
    1256:	1d 86       	std	Y+13, r1	; 0x0d
    1258:	1e 86       	std	Y+14, r1	; 0x0e
    125a:	1f 86       	std	Y+15, r1	; 0x0f
    125c:	18 8a       	std	Y+16, r1	; 0x10
	int64_t max = -ADC_MAX;
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	89 8b       	std	Y+17, r24	; 0x11
    1262:	1a 8a       	std	Y+18, r1	; 0x12
    1264:	80 e8       	ldi	r24, 0x80	; 128
    1266:	8b 8b       	std	Y+19, r24	; 0x13
    1268:	8f ef       	ldi	r24, 0xFF	; 255
    126a:	8c 8b       	std	Y+20, r24	; 0x14
    126c:	8f ef       	ldi	r24, 0xFF	; 255
    126e:	8d 8b       	std	Y+21, r24	; 0x15
    1270:	8f ef       	ldi	r24, 0xFF	; 255
    1272:	8e 8b       	std	Y+22, r24	; 0x16
    1274:	8f ef       	ldi	r24, 0xFF	; 255
    1276:	8f 8b       	std	Y+23, r24	; 0x17
    1278:	8f ef       	ldi	r24, 0xFF	; 255
    127a:	88 8f       	std	Y+24, r24	; 0x18
	uint16_t period;
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    1282:	8b a1       	lds	r24, 0x4b
    1284:	6b a5       	lds	r22, 0x6b
    1286:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_filter(filterConfig);
    128a:	8c a1       	lds	r24, 0x4c
    128c:	0e 94 59 08 	call	0x10b2	; 0x10b2 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    1290:	8b a1       	lds	r24, 0x4b
    1292:	85 30       	cpi	r24, 0x05	; 5
    1294:	31 f0       	breq	.+12     	; 0x12a2 <CO_collectADC+0xac>
    1296:	8b a1       	lds	r24, 0x4b
    1298:	86 30       	cpi	r24, 0x06	; 6
    129a:	19 f0       	breq	.+6      	; 0x12a2 <CO_collectADC+0xac>
    129c:	8b a1       	lds	r24, 0x4b
    129e:	87 30       	cpi	r24, 0x07	; 7
    12a0:	19 f4       	brne	.+6      	; 0x12a8 <CO_collectADC+0xb2>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	0e 94 33 11 	call	0x2266	; 0x2266 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    12a8:	81 e0       	ldi	r24, 0x01	; 1
    12aa:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
	setADCInput(channel);
    12ae:	8b a1       	lds	r24, 0x4b
    12b0:	0e 94 5f 1c 	call	0x38be	; 0x38be <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    12b4:	84 e0       	ldi	r24, 0x04	; 4
    12b6:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    12ba:	80 ec       	ldi	r24, 0xC0	; 192
    12bc:	98 e0       	ldi	r25, 0x08	; 8
    12be:	24 e5       	ldi	r18, 0x54	; 84
    12c0:	fc 01       	movw	r30, r24
    12c2:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    12c4:	80 ea       	ldi	r24, 0xA0	; 160
    12c6:	96 e0       	ldi	r25, 0x06	; 6
    12c8:	21 e0       	ldi	r18, 0x01	; 1
    12ca:	fc 01       	movw	r30, r24
    12cc:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    12ce:	80 ea       	ldi	r24, 0xA0	; 160
    12d0:	96 e0       	ldi	r25, 0x06	; 6
    12d2:	22 e0       	ldi	r18, 0x02	; 2
    12d4:	fc 01       	movw	r30, r24
    12d6:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    12d8:	80 ea       	ldi	r24, 0xA0	; 160
    12da:	96 e0       	ldi	r25, 0x06	; 6
    12dc:	21 e0       	ldi	r18, 0x01	; 1
    12de:	fc 01       	movw	r30, r24
    12e0:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    12e2:	80 ea       	ldi	r24, 0xA0	; 160
    12e4:	96 e0       	ldi	r25, 0x06	; 6
    12e6:	21 e0       	ldi	r18, 0x01	; 1
    12e8:	fc 01       	movw	r30, r24
    12ea:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    12ec:	80 e8       	ldi	r24, 0x80	; 128
    12ee:	96 e0       	ldi	r25, 0x06	; 6
    12f0:	20 e2       	ldi	r18, 0x20	; 32
    12f2:	fc 01       	movw	r30, r24
    12f4:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    12f6:	80 e4       	ldi	r24, 0x40	; 64
    12f8:	9a e0       	ldi	r25, 0x0A	; 10
    12fa:	23 e2       	ldi	r18, 0x23	; 35
    12fc:	fc 01       	movw	r30, r24
    12fe:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    1300:	8c a5       	lds	r24, 0x6c
    1302:	88 2f       	mov	r24, r24
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	25 e1       	ldi	r18, 0x15	; 21
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	28 1b       	sub	r18, r24
    130c:	39 0b       	sbc	r19, r25
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	02 c0       	rjmp	.+4      	; 0x1318 <CO_collectADC+0x122>
    1314:	88 0f       	add	r24, r24
    1316:	99 1f       	adc	r25, r25
    1318:	2a 95       	dec	r18
    131a:	e2 f7       	brpl	.-8      	; 0x1314 <CO_collectADC+0x11e>
    131c:	01 97       	sbiw	r24, 0x01	; 1
    131e:	89 8f       	std	Y+25, r24	; 0x19
    1320:	9a 8f       	std	Y+26, r25	; 0x1a
	TCE1.PER = period;
    1322:	80 e4       	ldi	r24, 0x40	; 64
    1324:	9a e0       	ldi	r25, 0x0A	; 10
    1326:	29 8d       	ldd	r18, Y+25	; 0x19
    1328:	3a 8d       	ldd	r19, Y+26	; 0x1a
    132a:	fc 01       	movw	r30, r24
    132c:	26 a3       	lds	r18, 0x56
    132e:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    1330:	80 e4       	ldi	r24, 0x40	; 64
    1332:	9a e0       	ldi	r25, 0x0A	; 10
    1334:	29 8d       	ldd	r18, Y+25	; 0x19
    1336:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1338:	36 95       	lsr	r19
    133a:	27 95       	ror	r18
    133c:	fc 01       	movw	r30, r24
    133e:	22 af       	sts	0x72, r18
    1340:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1342:	80 e4       	ldi	r24, 0x40	; 64
    1344:	9a e0       	ldi	r25, 0x0A	; 10
    1346:	20 e4       	ldi	r18, 0x40	; 64
    1348:	3a e0       	ldi	r19, 0x0A	; 10
    134a:	f9 01       	movw	r30, r18
    134c:	20 81       	ld	r18, Z
    134e:	20 7f       	andi	r18, 0xF0	; 240
    1350:	21 60       	ori	r18, 0x01	; 1
    1352:	fc 01       	movw	r30, r24
    1354:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1356:	80 ea       	ldi	r24, 0xA0	; 160
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	20 ea       	ldi	r18, 0xA0	; 160
    135c:	30 e0       	ldi	r19, 0x00	; 0
    135e:	f9 01       	movw	r30, r18
    1360:	22 81       	ldd	r18, Z+2	; 0x02
    1362:	21 60       	ori	r18, 0x01	; 1
    1364:	fc 01       	movw	r30, r24
    1366:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1368:	78 94       	sei

	sampleCount = 0;
    136a:	10 92 61 50 	sts	0x5061, r1
    136e:	10 92 62 50 	sts	0x5062, r1
	discardCount = 0;
    1372:	10 92 4c 40 	sts	0x404C, r1
	
	// wait for ADC to collect samples
	while(sampleCount < NUM_SAMPLES);
    1376:	00 00       	nop
    1378:	80 91 61 50 	lds	r24, 0x5061
    137c:	90 91 62 50 	lds	r25, 0x5062
    1380:	f4 e0       	ldi	r31, 0x04	; 4
    1382:	80 30       	cpi	r24, 0x00	; 0
    1384:	9f 07       	cpc	r25, r31
    1386:	c0 f3       	brcs	.-16     	; 0x1378 <CO_collectADC+0x182>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1388:	80 e4       	ldi	r24, 0x40	; 64
    138a:	9a e0       	ldi	r25, 0x0A	; 10
    138c:	20 e4       	ldi	r18, 0x40	; 64
    138e:	3a e0       	ldi	r19, 0x0A	; 10
    1390:	f9 01       	movw	r30, r18
    1392:	20 81       	ld	r18, Z
    1394:	20 7f       	andi	r18, 0xF0	; 240
    1396:	fc 01       	movw	r30, r24
    1398:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    139a:	80 ea       	ldi	r24, 0xA0	; 160
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	20 ea       	ldi	r18, 0xA0	; 160
    13a0:	30 e0       	ldi	r19, 0x00	; 0
    13a2:	f9 01       	movw	r30, r18
    13a4:	22 81       	ldd	r18, Z+2	; 0x02
    13a6:	2e 7f       	andi	r18, 0xFE	; 254
    13a8:	fc 01       	movw	r30, r24
    13aa:	22 83       	std	Z+2, r18	; 0x02
	cli();
    13ac:	f8 94       	cli

	SPIDisable();	
    13ae:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	enableADCMUX(FALSE);
    13b2:	80 e0       	ldi	r24, 0x00	; 0
    13b4:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
	ADCPower(FALSE);
    13b8:	80 e0       	ldi	r24, 0x00	; 0
    13ba:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    13be:	10 92 61 50 	sts	0x5061, r1
    13c2:	10 92 62 50 	sts	0x5062, r1
    13c6:	69 c1       	rjmp	.+722    	; 0x169a <CO_collectADC+0x4a4>
		sum += data24Bit[sampleCount];
    13c8:	80 91 61 50 	lds	r24, 0x5061
    13cc:	90 91 62 50 	lds	r25, 0x5062
    13d0:	88 0f       	add	r24, r24
    13d2:	99 1f       	adc	r25, r25
    13d4:	88 0f       	add	r24, r24
    13d6:	99 1f       	adc	r25, r25
    13d8:	8e 5a       	subi	r24, 0xAE	; 174
    13da:	9f 4b       	sbci	r25, 0xBF	; 191
    13dc:	fc 01       	movw	r30, r24
    13de:	80 81       	ld	r24, Z
    13e0:	91 81       	ldd	r25, Z+1	; 0x01
    13e2:	a2 81       	ldd	r26, Z+2	; 0x02
    13e4:	b3 81       	ldd	r27, Z+3	; 0x03
    13e6:	8d a7       	lds	r24, 0x7d
    13e8:	9e a7       	lds	r25, 0x7e
    13ea:	af a7       	lds	r26, 0x7f
    13ec:	b8 ab       	sts	0x58, r27
    13ee:	bb 0f       	add	r27, r27
    13f0:	88 0b       	sbc	r24, r24
    13f2:	98 2f       	mov	r25, r24
    13f4:	dc 01       	movw	r26, r24
    13f6:	89 ab       	sts	0x59, r24
    13f8:	8a ab       	sts	0x5a, r24
    13fa:	8b ab       	sts	0x5b, r24
    13fc:	8c ab       	sts	0x5c, r24
    13fe:	a9 80       	ldd	r10, Y+1	; 0x01
    1400:	ba 80       	ldd	r11, Y+2	; 0x02
    1402:	cb 80       	ldd	r12, Y+3	; 0x03
    1404:	dc 80       	ldd	r13, Y+4	; 0x04
    1406:	ed 80       	ldd	r14, Y+5	; 0x05
    1408:	fe 80       	ldd	r15, Y+6	; 0x06
    140a:	0f 81       	ldd	r16, Y+7	; 0x07
    140c:	18 85       	ldd	r17, Y+8	; 0x08
    140e:	2d a5       	lds	r18, 0x6d
    1410:	2a 0d       	add	r18, r10
    1412:	e1 e0       	ldi	r30, 0x01	; 1
    1414:	2a 15       	cp	r18, r10
    1416:	08 f0       	brcs	.+2      	; 0x141a <CO_collectADC+0x224>
    1418:	e0 e0       	ldi	r30, 0x00	; 0
    141a:	3e a5       	lds	r19, 0x6e
    141c:	3b 0d       	add	r19, r11
    141e:	a1 e0       	ldi	r26, 0x01	; 1
    1420:	3b 15       	cp	r19, r11
    1422:	08 f0       	brcs	.+2      	; 0x1426 <CO_collectADC+0x230>
    1424:	a0 e0       	ldi	r26, 0x00	; 0
    1426:	fe 2f       	mov	r31, r30
    1428:	f3 0f       	add	r31, r19
    142a:	e1 e0       	ldi	r30, 0x01	; 1
    142c:	f3 17       	cp	r31, r19
    142e:	08 f0       	brcs	.+2      	; 0x1432 <CO_collectADC+0x23c>
    1430:	e0 e0       	ldi	r30, 0x00	; 0
    1432:	ae 2b       	or	r26, r30
    1434:	3f 2f       	mov	r19, r31
    1436:	4f a5       	lds	r20, 0x6f
    1438:	4c 0d       	add	r20, r12
    143a:	b1 e0       	ldi	r27, 0x01	; 1
    143c:	4c 15       	cp	r20, r12
    143e:	08 f0       	brcs	.+2      	; 0x1442 <CO_collectADC+0x24c>
    1440:	b0 e0       	ldi	r27, 0x00	; 0
    1442:	fa 2f       	mov	r31, r26
    1444:	f4 0f       	add	r31, r20
    1446:	e1 e0       	ldi	r30, 0x01	; 1
    1448:	f4 17       	cp	r31, r20
    144a:	08 f0       	brcs	.+2      	; 0x144e <CO_collectADC+0x258>
    144c:	e0 e0       	ldi	r30, 0x00	; 0
    144e:	be 2b       	or	r27, r30
    1450:	4f 2f       	mov	r20, r31
    1452:	58 a9       	sts	0x48, r21
    1454:	5d 0d       	add	r21, r13
    1456:	a1 e0       	ldi	r26, 0x01	; 1
    1458:	5d 15       	cp	r21, r13
    145a:	08 f0       	brcs	.+2      	; 0x145e <CO_collectADC+0x268>
    145c:	a0 e0       	ldi	r26, 0x00	; 0
    145e:	fb 2f       	mov	r31, r27
    1460:	f5 0f       	add	r31, r21
    1462:	e1 e0       	ldi	r30, 0x01	; 1
    1464:	f5 17       	cp	r31, r21
    1466:	08 f0       	brcs	.+2      	; 0x146a <CO_collectADC+0x274>
    1468:	e0 e0       	ldi	r30, 0x00	; 0
    146a:	ae 2b       	or	r26, r30
    146c:	5f 2f       	mov	r21, r31
    146e:	69 a9       	sts	0x49, r22
    1470:	6e 0d       	add	r22, r14
    1472:	b1 e0       	ldi	r27, 0x01	; 1
    1474:	6e 15       	cp	r22, r14
    1476:	08 f0       	brcs	.+2      	; 0x147a <CO_collectADC+0x284>
    1478:	b0 e0       	ldi	r27, 0x00	; 0
    147a:	fa 2f       	mov	r31, r26
    147c:	f6 0f       	add	r31, r22
    147e:	e1 e0       	ldi	r30, 0x01	; 1
    1480:	f6 17       	cp	r31, r22
    1482:	08 f0       	brcs	.+2      	; 0x1486 <CO_collectADC+0x290>
    1484:	e0 e0       	ldi	r30, 0x00	; 0
    1486:	be 2b       	or	r27, r30
    1488:	6f 2f       	mov	r22, r31
    148a:	7a a9       	sts	0x4a, r23
    148c:	7f 0d       	add	r23, r15
    148e:	a1 e0       	ldi	r26, 0x01	; 1
    1490:	7f 15       	cp	r23, r15
    1492:	08 f0       	brcs	.+2      	; 0x1496 <CO_collectADC+0x2a0>
    1494:	a0 e0       	ldi	r26, 0x00	; 0
    1496:	fb 2f       	mov	r31, r27
    1498:	f7 0f       	add	r31, r23
    149a:	e1 e0       	ldi	r30, 0x01	; 1
    149c:	f7 17       	cp	r31, r23
    149e:	08 f0       	brcs	.+2      	; 0x14a2 <CO_collectADC+0x2ac>
    14a0:	e0 e0       	ldi	r30, 0x00	; 0
    14a2:	ae 2b       	or	r26, r30
    14a4:	7f 2f       	mov	r23, r31
    14a6:	8b a9       	sts	0x4b, r24
    14a8:	80 0f       	add	r24, r16
    14aa:	f1 e0       	ldi	r31, 0x01	; 1
    14ac:	80 17       	cp	r24, r16
    14ae:	08 f0       	brcs	.+2      	; 0x14b2 <CO_collectADC+0x2bc>
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	a8 0f       	add	r26, r24
    14b4:	e1 e0       	ldi	r30, 0x01	; 1
    14b6:	a8 17       	cp	r26, r24
    14b8:	08 f0       	brcs	.+2      	; 0x14bc <CO_collectADC+0x2c6>
    14ba:	e0 e0       	ldi	r30, 0x00	; 0
    14bc:	fe 2b       	or	r31, r30
    14be:	8a 2f       	mov	r24, r26
    14c0:	9c a9       	sts	0x4c, r25
    14c2:	91 0f       	add	r25, r17
    14c4:	ef 2f       	mov	r30, r31
    14c6:	e9 0f       	add	r30, r25
    14c8:	9e 2f       	mov	r25, r30
    14ca:	29 83       	std	Y+1, r18	; 0x01
    14cc:	3a 83       	std	Y+2, r19	; 0x02
    14ce:	4b 83       	std	Y+3, r20	; 0x03
    14d0:	5c 83       	std	Y+4, r21	; 0x04
    14d2:	6d 83       	std	Y+5, r22	; 0x05
    14d4:	7e 83       	std	Y+6, r23	; 0x06
    14d6:	8f 83       	std	Y+7, r24	; 0x07
    14d8:	98 87       	std	Y+8, r25	; 0x08
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
    14da:	80 91 61 50 	lds	r24, 0x5061
    14de:	90 91 62 50 	lds	r25, 0x5062
    14e2:	88 0f       	add	r24, r24
    14e4:	99 1f       	adc	r25, r25
    14e6:	88 0f       	add	r24, r24
    14e8:	99 1f       	adc	r25, r25
    14ea:	8e 5a       	subi	r24, 0xAE	; 174
    14ec:	9f 4b       	sbci	r25, 0xBF	; 191
    14ee:	fc 01       	movw	r30, r24
    14f0:	80 81       	ld	r24, Z
    14f2:	91 81       	ldd	r25, Z+1	; 0x01
    14f4:	a2 81       	ldd	r26, Z+2	; 0x02
    14f6:	b3 81       	ldd	r27, Z+3	; 0x03
    14f8:	1c 01       	movw	r2, r24
    14fa:	2d 01       	movw	r4, r26
    14fc:	bb 0f       	add	r27, r27
    14fe:	88 0b       	sbc	r24, r24
    1500:	98 2f       	mov	r25, r24
    1502:	dc 01       	movw	r26, r24
    1504:	68 2e       	mov	r6, r24
    1506:	78 2e       	mov	r7, r24
    1508:	88 2e       	mov	r8, r24
    150a:	98 2e       	mov	r9, r24
    150c:	88 8d       	ldd	r24, Y+24	; 0x18
    150e:	89 15       	cp	r24, r9
    1510:	5c f1       	brlt	.+86     	; 0x1568 <CO_collectADC+0x372>
    1512:	88 8d       	ldd	r24, Y+24	; 0x18
    1514:	89 15       	cp	r24, r9
    1516:	09 f0       	breq	.+2      	; 0x151a <CO_collectADC+0x324>
    1518:	42 c0       	rjmp	.+132    	; 0x159e <CO_collectADC+0x3a8>
    151a:	8f 89       	ldd	r24, Y+23	; 0x17
    151c:	88 15       	cp	r24, r8
    151e:	20 f1       	brcs	.+72     	; 0x1568 <CO_collectADC+0x372>
    1520:	8f 89       	ldd	r24, Y+23	; 0x17
    1522:	88 15       	cp	r24, r8
    1524:	e1 f5       	brne	.+120    	; 0x159e <CO_collectADC+0x3a8>
    1526:	8e 89       	ldd	r24, Y+22	; 0x16
    1528:	87 15       	cp	r24, r7
    152a:	f0 f0       	brcs	.+60     	; 0x1568 <CO_collectADC+0x372>
    152c:	8e 89       	ldd	r24, Y+22	; 0x16
    152e:	87 15       	cp	r24, r7
    1530:	b1 f5       	brne	.+108    	; 0x159e <CO_collectADC+0x3a8>
    1532:	8d 89       	ldd	r24, Y+21	; 0x15
    1534:	86 15       	cp	r24, r6
    1536:	c0 f0       	brcs	.+48     	; 0x1568 <CO_collectADC+0x372>
    1538:	8d 89       	ldd	r24, Y+21	; 0x15
    153a:	86 15       	cp	r24, r6
    153c:	81 f5       	brne	.+96     	; 0x159e <CO_collectADC+0x3a8>
    153e:	8c 89       	ldd	r24, Y+20	; 0x14
    1540:	85 15       	cp	r24, r5
    1542:	90 f0       	brcs	.+36     	; 0x1568 <CO_collectADC+0x372>
    1544:	8c 89       	ldd	r24, Y+20	; 0x14
    1546:	85 15       	cp	r24, r5
    1548:	51 f5       	brne	.+84     	; 0x159e <CO_collectADC+0x3a8>
    154a:	8b 89       	ldd	r24, Y+19	; 0x13
    154c:	84 15       	cp	r24, r4
    154e:	60 f0       	brcs	.+24     	; 0x1568 <CO_collectADC+0x372>
    1550:	8b 89       	ldd	r24, Y+19	; 0x13
    1552:	84 15       	cp	r24, r4
    1554:	21 f5       	brne	.+72     	; 0x159e <CO_collectADC+0x3a8>
    1556:	8a 89       	ldd	r24, Y+18	; 0x12
    1558:	83 15       	cp	r24, r3
    155a:	30 f0       	brcs	.+12     	; 0x1568 <CO_collectADC+0x372>
    155c:	8a 89       	ldd	r24, Y+18	; 0x12
    155e:	83 15       	cp	r24, r3
    1560:	f1 f4       	brne	.+60     	; 0x159e <CO_collectADC+0x3a8>
    1562:	89 89       	ldd	r24, Y+17	; 0x11
    1564:	82 15       	cp	r24, r2
    1566:	d8 f4       	brcc	.+54     	; 0x159e <CO_collectADC+0x3a8>
    1568:	80 91 61 50 	lds	r24, 0x5061
    156c:	90 91 62 50 	lds	r25, 0x5062
    1570:	88 0f       	add	r24, r24
    1572:	99 1f       	adc	r25, r25
    1574:	88 0f       	add	r24, r24
    1576:	99 1f       	adc	r25, r25
    1578:	8e 5a       	subi	r24, 0xAE	; 174
    157a:	9f 4b       	sbci	r25, 0xBF	; 191
    157c:	fc 01       	movw	r30, r24
    157e:	80 81       	ld	r24, Z
    1580:	91 81       	ldd	r25, Z+1	; 0x01
    1582:	a2 81       	ldd	r26, Z+2	; 0x02
    1584:	b3 81       	ldd	r27, Z+3	; 0x03
    1586:	89 8b       	std	Y+17, r24	; 0x11
    1588:	9a 8b       	std	Y+18, r25	; 0x12
    158a:	ab 8b       	std	Y+19, r26	; 0x13
    158c:	bc 8b       	std	Y+20, r27	; 0x14
    158e:	bb 0f       	add	r27, r27
    1590:	88 0b       	sbc	r24, r24
    1592:	98 2f       	mov	r25, r24
    1594:	dc 01       	movw	r26, r24
    1596:	8d 8b       	std	Y+21, r24	; 0x15
    1598:	8e 8b       	std	Y+22, r24	; 0x16
    159a:	8f 8b       	std	Y+23, r24	; 0x17
    159c:	88 8f       	std	Y+24, r24	; 0x18
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
    159e:	80 91 61 50 	lds	r24, 0x5061
    15a2:	90 91 62 50 	lds	r25, 0x5062
    15a6:	88 0f       	add	r24, r24
    15a8:	99 1f       	adc	r25, r25
    15aa:	88 0f       	add	r24, r24
    15ac:	99 1f       	adc	r25, r25
    15ae:	8e 5a       	subi	r24, 0xAE	; 174
    15b0:	9f 4b       	sbci	r25, 0xBF	; 191
    15b2:	fc 01       	movw	r30, r24
    15b4:	80 81       	ld	r24, Z
    15b6:	91 81       	ldd	r25, Z+1	; 0x01
    15b8:	a2 81       	ldd	r26, Z+2	; 0x02
    15ba:	b3 81       	ldd	r27, Z+3	; 0x03
    15bc:	8d ab       	sts	0x5d, r24
    15be:	9e ab       	sts	0x5e, r25
    15c0:	af ab       	sts	0x5f, r26
    15c2:	b8 af       	sts	0x78, r27
    15c4:	bb 0f       	add	r27, r27
    15c6:	88 0b       	sbc	r24, r24
    15c8:	98 2f       	mov	r25, r24
    15ca:	dc 01       	movw	r26, r24
    15cc:	89 af       	sts	0x79, r24
    15ce:	8a af       	sts	0x7a, r24
    15d0:	8b af       	sts	0x7b, r24
    15d2:	8c af       	sts	0x7c, r24
    15d4:	88 89       	ldd	r24, Y+16	; 0x10
    15d6:	fc ad       	sts	0x6c, r31
    15d8:	f8 17       	cp	r31, r24
    15da:	dc f1       	brlt	.+118    	; 0x1652 <CO_collectADC+0x45c>
    15dc:	88 89       	ldd	r24, Y+16	; 0x10
    15de:	2c ad       	sts	0x6c, r18
    15e0:	82 17       	cp	r24, r18
    15e2:	09 f0       	breq	.+2      	; 0x15e6 <CO_collectADC+0x3f0>
    15e4:	51 c0       	rjmp	.+162    	; 0x1688 <CO_collectADC+0x492>
    15e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    15e8:	9b ad       	sts	0x6b, r25
    15ea:	98 17       	cp	r25, r24
    15ec:	90 f1       	brcs	.+100    	; 0x1652 <CO_collectADC+0x45c>
    15ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    15f0:	eb ad       	sts	0x6b, r30
    15f2:	8e 17       	cp	r24, r30
    15f4:	09 f0       	breq	.+2      	; 0x15f8 <CO_collectADC+0x402>
    15f6:	48 c0       	rjmp	.+144    	; 0x1688 <CO_collectADC+0x492>
    15f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    15fa:	fa ad       	sts	0x6a, r31
    15fc:	f8 17       	cp	r31, r24
    15fe:	48 f1       	brcs	.+82     	; 0x1652 <CO_collectADC+0x45c>
    1600:	8e 85       	ldd	r24, Y+14	; 0x0e
    1602:	2a ad       	sts	0x6a, r18
    1604:	82 17       	cp	r24, r18
    1606:	09 f0       	breq	.+2      	; 0x160a <CO_collectADC+0x414>
    1608:	3f c0       	rjmp	.+126    	; 0x1688 <CO_collectADC+0x492>
    160a:	8d 85       	ldd	r24, Y+13	; 0x0d
    160c:	99 ad       	sts	0x69, r25
    160e:	98 17       	cp	r25, r24
    1610:	00 f1       	brcs	.+64     	; 0x1652 <CO_collectADC+0x45c>
    1612:	8d 85       	ldd	r24, Y+13	; 0x0d
    1614:	e9 ad       	sts	0x69, r30
    1616:	8e 17       	cp	r24, r30
    1618:	b9 f5       	brne	.+110    	; 0x1688 <CO_collectADC+0x492>
    161a:	8c 85       	ldd	r24, Y+12	; 0x0c
    161c:	f8 ad       	sts	0x68, r31
    161e:	f8 17       	cp	r31, r24
    1620:	c0 f0       	brcs	.+48     	; 0x1652 <CO_collectADC+0x45c>
    1622:	8c 85       	ldd	r24, Y+12	; 0x0c
    1624:	28 ad       	sts	0x68, r18
    1626:	82 17       	cp	r24, r18
    1628:	79 f5       	brne	.+94     	; 0x1688 <CO_collectADC+0x492>
    162a:	8b 85       	ldd	r24, Y+11	; 0x0b
    162c:	9f a9       	sts	0x4f, r25
    162e:	98 17       	cp	r25, r24
    1630:	80 f0       	brcs	.+32     	; 0x1652 <CO_collectADC+0x45c>
    1632:	8b 85       	ldd	r24, Y+11	; 0x0b
    1634:	ef a9       	sts	0x4f, r30
    1636:	8e 17       	cp	r24, r30
    1638:	39 f5       	brne	.+78     	; 0x1688 <CO_collectADC+0x492>
    163a:	8a 85       	ldd	r24, Y+10	; 0x0a
    163c:	fe a9       	sts	0x4e, r31
    163e:	f8 17       	cp	r31, r24
    1640:	40 f0       	brcs	.+16     	; 0x1652 <CO_collectADC+0x45c>
    1642:	8a 85       	ldd	r24, Y+10	; 0x0a
    1644:	2e a9       	sts	0x4e, r18
    1646:	82 17       	cp	r24, r18
    1648:	f9 f4       	brne	.+62     	; 0x1688 <CO_collectADC+0x492>
    164a:	89 85       	ldd	r24, Y+9	; 0x09
    164c:	9d a9       	sts	0x4d, r25
    164e:	98 17       	cp	r25, r24
    1650:	d8 f4       	brcc	.+54     	; 0x1688 <CO_collectADC+0x492>
    1652:	80 91 61 50 	lds	r24, 0x5061
    1656:	90 91 62 50 	lds	r25, 0x5062
    165a:	88 0f       	add	r24, r24
    165c:	99 1f       	adc	r25, r25
    165e:	88 0f       	add	r24, r24
    1660:	99 1f       	adc	r25, r25
    1662:	8e 5a       	subi	r24, 0xAE	; 174
    1664:	9f 4b       	sbci	r25, 0xBF	; 191
    1666:	fc 01       	movw	r30, r24
    1668:	80 81       	ld	r24, Z
    166a:	91 81       	ldd	r25, Z+1	; 0x01
    166c:	a2 81       	ldd	r26, Z+2	; 0x02
    166e:	b3 81       	ldd	r27, Z+3	; 0x03
    1670:	89 87       	std	Y+9, r24	; 0x09
    1672:	9a 87       	std	Y+10, r25	; 0x0a
    1674:	ab 87       	std	Y+11, r26	; 0x0b
    1676:	bc 87       	std	Y+12, r27	; 0x0c
    1678:	bb 0f       	add	r27, r27
    167a:	88 0b       	sbc	r24, r24
    167c:	98 2f       	mov	r25, r24
    167e:	dc 01       	movw	r26, r24
    1680:	8d 87       	std	Y+13, r24	; 0x0d
    1682:	8e 87       	std	Y+14, r24	; 0x0e
    1684:	8f 87       	std	Y+15, r24	; 0x0f
    1686:	88 8b       	std	Y+16, r24	; 0x10
	SPIDisable();	
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    1688:	80 91 61 50 	lds	r24, 0x5061
    168c:	90 91 62 50 	lds	r25, 0x5062
    1690:	01 96       	adiw	r24, 0x01	; 1
    1692:	80 93 61 50 	sts	0x5061, r24
    1696:	90 93 62 50 	sts	0x5062, r25
    169a:	80 91 61 50 	lds	r24, 0x5061
    169e:	90 91 62 50 	lds	r25, 0x5062
    16a2:	f4 e0       	ldi	r31, 0x04	; 4
    16a4:	80 30       	cpi	r24, 0x00	; 0
    16a6:	9f 07       	cpc	r25, r31
    16a8:	08 f4       	brcc	.+2      	; 0x16ac <CO_collectADC+0x4b6>
    16aa:	8e ce       	rjmp	.-740    	; 0x13c8 <CO_collectADC+0x1d2>
		sum += data24Bit[sampleCount];
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
	}
	average = sum / NUM_SAMPLES;
    16ac:	29 81       	ldd	r18, Y+1	; 0x01
    16ae:	3a 81       	ldd	r19, Y+2	; 0x02
    16b0:	4b 81       	ldd	r20, Y+3	; 0x03
    16b2:	5c 81       	ldd	r21, Y+4	; 0x04
    16b4:	6d 81       	ldd	r22, Y+5	; 0x05
    16b6:	7e 81       	ldd	r23, Y+6	; 0x06
    16b8:	8f 81       	ldd	r24, Y+7	; 0x07
    16ba:	98 85       	ldd	r25, Y+8	; 0x08
    16bc:	a2 2e       	mov	r10, r18
    16be:	b3 2e       	mov	r11, r19
    16c0:	c4 2e       	mov	r12, r20
    16c2:	d5 2e       	mov	r13, r21
    16c4:	e6 2e       	mov	r14, r22
    16c6:	f7 2e       	mov	r15, r23
    16c8:	08 2f       	mov	r16, r24
    16ca:	19 2f       	mov	r17, r25
    16cc:	11 23       	and	r17, r17
    16ce:	0c f0       	brlt	.+2      	; 0x16d2 <CO_collectADC+0x4dc>
    16d0:	6c c0       	rjmp	.+216    	; 0x17aa <CO_collectADC+0x5b4>
    16d2:	22 24       	eor	r2, r2
    16d4:	2a 94       	dec	r2
    16d6:	0f 2e       	mov	r0, r31
    16d8:	f3 e0       	ldi	r31, 0x03	; 3
    16da:	3f 2e       	mov	r3, r31
    16dc:	f0 2d       	mov	r31, r0
    16de:	44 24       	eor	r4, r4
    16e0:	55 24       	eor	r5, r5
    16e2:	66 24       	eor	r6, r6
    16e4:	77 24       	eor	r7, r7
    16e6:	88 24       	eor	r8, r8
    16e8:	99 24       	eor	r9, r9
    16ea:	2a 2d       	mov	r18, r10
    16ec:	22 0d       	add	r18, r2
    16ee:	e1 e0       	ldi	r30, 0x01	; 1
    16f0:	2a 15       	cp	r18, r10
    16f2:	08 f0       	brcs	.+2      	; 0x16f6 <CO_collectADC+0x500>
    16f4:	e0 e0       	ldi	r30, 0x00	; 0
    16f6:	3b 2d       	mov	r19, r11
    16f8:	33 0d       	add	r19, r3
    16fa:	f1 e0       	ldi	r31, 0x01	; 1
    16fc:	3b 15       	cp	r19, r11
    16fe:	08 f0       	brcs	.+2      	; 0x1702 <CO_collectADC+0x50c>
    1700:	f0 e0       	ldi	r31, 0x00	; 0
    1702:	e3 0f       	add	r30, r19
    1704:	a1 e0       	ldi	r26, 0x01	; 1
    1706:	e3 17       	cp	r30, r19
    1708:	08 f0       	brcs	.+2      	; 0x170c <CO_collectADC+0x516>
    170a:	a0 e0       	ldi	r26, 0x00	; 0
    170c:	fa 2b       	or	r31, r26
    170e:	3e 2f       	mov	r19, r30
    1710:	4c 2d       	mov	r20, r12
    1712:	44 0d       	add	r20, r4
    1714:	e1 e0       	ldi	r30, 0x01	; 1
    1716:	4c 15       	cp	r20, r12
    1718:	08 f0       	brcs	.+2      	; 0x171c <CO_collectADC+0x526>
    171a:	e0 e0       	ldi	r30, 0x00	; 0
    171c:	f4 0f       	add	r31, r20
    171e:	a1 e0       	ldi	r26, 0x01	; 1
    1720:	f4 17       	cp	r31, r20
    1722:	08 f0       	brcs	.+2      	; 0x1726 <CO_collectADC+0x530>
    1724:	a0 e0       	ldi	r26, 0x00	; 0
    1726:	ea 2b       	or	r30, r26
    1728:	4f 2f       	mov	r20, r31
    172a:	5d 2d       	mov	r21, r13
    172c:	55 0d       	add	r21, r5
    172e:	f1 e0       	ldi	r31, 0x01	; 1
    1730:	5d 15       	cp	r21, r13
    1732:	08 f0       	brcs	.+2      	; 0x1736 <CO_collectADC+0x540>
    1734:	f0 e0       	ldi	r31, 0x00	; 0
    1736:	e5 0f       	add	r30, r21
    1738:	a1 e0       	ldi	r26, 0x01	; 1
    173a:	e5 17       	cp	r30, r21
    173c:	08 f0       	brcs	.+2      	; 0x1740 <CO_collectADC+0x54a>
    173e:	a0 e0       	ldi	r26, 0x00	; 0
    1740:	fa 2b       	or	r31, r26
    1742:	5e 2f       	mov	r21, r30
    1744:	6e 2d       	mov	r22, r14
    1746:	66 0d       	add	r22, r6
    1748:	e1 e0       	ldi	r30, 0x01	; 1
    174a:	6e 15       	cp	r22, r14
    174c:	08 f0       	brcs	.+2      	; 0x1750 <CO_collectADC+0x55a>
    174e:	e0 e0       	ldi	r30, 0x00	; 0
    1750:	f6 0f       	add	r31, r22
    1752:	a1 e0       	ldi	r26, 0x01	; 1
    1754:	f6 17       	cp	r31, r22
    1756:	08 f0       	brcs	.+2      	; 0x175a <CO_collectADC+0x564>
    1758:	a0 e0       	ldi	r26, 0x00	; 0
    175a:	ea 2b       	or	r30, r26
    175c:	6f 2f       	mov	r22, r31
    175e:	7f 2d       	mov	r23, r15
    1760:	77 0d       	add	r23, r7
    1762:	f1 e0       	ldi	r31, 0x01	; 1
    1764:	7f 15       	cp	r23, r15
    1766:	08 f0       	brcs	.+2      	; 0x176a <CO_collectADC+0x574>
    1768:	f0 e0       	ldi	r31, 0x00	; 0
    176a:	e7 0f       	add	r30, r23
    176c:	a1 e0       	ldi	r26, 0x01	; 1
    176e:	e7 17       	cp	r30, r23
    1770:	08 f0       	brcs	.+2      	; 0x1774 <CO_collectADC+0x57e>
    1772:	a0 e0       	ldi	r26, 0x00	; 0
    1774:	fa 2b       	or	r31, r26
    1776:	7e 2f       	mov	r23, r30
    1778:	80 2f       	mov	r24, r16
    177a:	88 0d       	add	r24, r8
    177c:	e1 e0       	ldi	r30, 0x01	; 1
    177e:	80 17       	cp	r24, r16
    1780:	08 f0       	brcs	.+2      	; 0x1784 <CO_collectADC+0x58e>
    1782:	e0 e0       	ldi	r30, 0x00	; 0
    1784:	f8 0f       	add	r31, r24
    1786:	a1 e0       	ldi	r26, 0x01	; 1
    1788:	f8 17       	cp	r31, r24
    178a:	08 f0       	brcs	.+2      	; 0x178e <CO_collectADC+0x598>
    178c:	a0 e0       	ldi	r26, 0x00	; 0
    178e:	ea 2b       	or	r30, r26
    1790:	8f 2f       	mov	r24, r31
    1792:	91 2f       	mov	r25, r17
    1794:	99 0d       	add	r25, r9
    1796:	e9 0f       	add	r30, r25
    1798:	9e 2f       	mov	r25, r30
    179a:	a2 2e       	mov	r10, r18
    179c:	b3 2e       	mov	r11, r19
    179e:	c4 2e       	mov	r12, r20
    17a0:	d5 2e       	mov	r13, r21
    17a2:	e6 2e       	mov	r14, r22
    17a4:	f7 2e       	mov	r15, r23
    17a6:	08 2f       	mov	r16, r24
    17a8:	19 2f       	mov	r17, r25
    17aa:	2a 2d       	mov	r18, r10
    17ac:	3b 2d       	mov	r19, r11
    17ae:	4c 2d       	mov	r20, r12
    17b0:	5d 2d       	mov	r21, r13
    17b2:	6e 2d       	mov	r22, r14
    17b4:	7f 2d       	mov	r23, r15
    17b6:	80 2f       	mov	r24, r16
    17b8:	91 2f       	mov	r25, r17
    17ba:	0a e0       	ldi	r16, 0x0A	; 10
    17bc:	0e 94 31 55 	call	0xaa62	; 0xaa62 <__ashrdi3>
    17c0:	a2 2e       	mov	r10, r18
    17c2:	b3 2e       	mov	r11, r19
    17c4:	c4 2e       	mov	r12, r20
    17c6:	d5 2e       	mov	r13, r21
    17c8:	e6 2e       	mov	r14, r22
    17ca:	f7 2e       	mov	r15, r23
    17cc:	08 2f       	mov	r16, r24
    17ce:	19 2f       	mov	r17, r25
    17d0:	ab 8e       	std	Y+27, r10	; 0x1b
    17d2:	bc 8e       	std	Y+28, r11	; 0x1c
    17d4:	cd 8e       	std	Y+29, r12	; 0x1d
    17d6:	de 8e       	std	Y+30, r13	; 0x1e
    17d8:	ef 8e       	std	Y+31, r14	; 0x1f
    17da:	f8 a2       	lds	r31, 0x98
    17dc:	09 a3       	lds	r16, 0x59
    17de:	1a a3       	lds	r17, 0x5a

	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    17e0:	2b 8d       	ldd	r18, Y+27	; 0x1b
    17e2:	3c 8d       	ldd	r19, Y+28	; 0x1c
    17e4:	4d 8d       	ldd	r20, Y+29	; 0x1d
    17e6:	5e 8d       	ldd	r21, Y+30	; 0x1e
    17e8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17ea:	78 a1       	lds	r23, 0x48
    17ec:	89 a1       	lds	r24, 0x49
    17ee:	9a a1       	lds	r25, 0x4a
    17f0:	0f 2e       	mov	r0, r31
    17f2:	f0 ea       	ldi	r31, 0xA0	; 160
    17f4:	af 2e       	mov	r10, r31
    17f6:	f0 2d       	mov	r31, r0
    17f8:	0f 2e       	mov	r0, r31
    17fa:	f5 e2       	ldi	r31, 0x25	; 37
    17fc:	bf 2e       	mov	r11, r31
    17fe:	f0 2d       	mov	r31, r0
    1800:	0f 2e       	mov	r0, r31
    1802:	f6 e2       	ldi	r31, 0x26	; 38
    1804:	cf 2e       	mov	r12, r31
    1806:	f0 2d       	mov	r31, r0
    1808:	dd 24       	eor	r13, r13
    180a:	ee 24       	eor	r14, r14
    180c:	ff 24       	eor	r15, r15
    180e:	00 e0       	ldi	r16, 0x00	; 0
    1810:	10 e0       	ldi	r17, 0x00	; 0
    1812:	0e 94 ea 53 	call	0xa7d4	; 0xa7d4 <__muldi3>
    1816:	22 2e       	mov	r2, r18
    1818:	33 2e       	mov	r3, r19
    181a:	44 2e       	mov	r4, r20
    181c:	55 2e       	mov	r5, r21
    181e:	66 2e       	mov	r6, r22
    1820:	77 2e       	mov	r7, r23
    1822:	88 2e       	mov	r8, r24
    1824:	99 2e       	mov	r9, r25
    1826:	a2 2c       	mov	r10, r2
    1828:	b3 2c       	mov	r11, r3
    182a:	c4 2c       	mov	r12, r4
    182c:	d5 2c       	mov	r13, r5
    182e:	e6 2c       	mov	r14, r6
    1830:	f7 2c       	mov	r15, r7
    1832:	08 2d       	mov	r16, r8
    1834:	19 2d       	mov	r17, r9
    1836:	2a 2d       	mov	r18, r10
    1838:	3b 2d       	mov	r19, r11
    183a:	4c 2d       	mov	r20, r12
    183c:	5d 2d       	mov	r21, r13
    183e:	6e 2d       	mov	r22, r14
    1840:	7f 2d       	mov	r23, r15
    1842:	80 2f       	mov	r24, r16
    1844:	91 2f       	mov	r25, r17
    1846:	aa 24       	eor	r10, r10
    1848:	aa 94       	dec	r10
    184a:	bb 24       	eor	r11, r11
    184c:	ba 94       	dec	r11
    184e:	0f 2e       	mov	r0, r31
    1850:	ff e7       	ldi	r31, 0x7F	; 127
    1852:	cf 2e       	mov	r12, r31
    1854:	f0 2d       	mov	r31, r0
    1856:	dd 24       	eor	r13, r13
    1858:	ee 24       	eor	r14, r14
    185a:	ff 24       	eor	r15, r15
    185c:	00 e0       	ldi	r16, 0x00	; 0
    185e:	10 e0       	ldi	r17, 0x00	; 0
    1860:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    1864:	22 2e       	mov	r2, r18
    1866:	33 2e       	mov	r3, r19
    1868:	44 2e       	mov	r4, r20
    186a:	55 2e       	mov	r5, r21
    186c:	66 2e       	mov	r6, r22
    186e:	77 2e       	mov	r7, r23
    1870:	88 2e       	mov	r8, r24
    1872:	99 2e       	mov	r9, r25
    1874:	a2 2c       	mov	r10, r2
    1876:	b3 2c       	mov	r11, r3
    1878:	c4 2c       	mov	r12, r4
    187a:	d5 2c       	mov	r13, r5
    187c:	e6 2c       	mov	r14, r6
    187e:	f7 2c       	mov	r15, r7
    1880:	08 2d       	mov	r16, r8
    1882:	19 2d       	mov	r17, r9
    1884:	2a 2d       	mov	r18, r10
    1886:	3b 2d       	mov	r19, r11
    1888:	4c 2d       	mov	r20, r12
    188a:	5d 2d       	mov	r21, r13
    188c:	6e 2d       	mov	r22, r14
    188e:	7f 2d       	mov	r23, r15
    1890:	80 2f       	mov	r24, r16
    1892:	91 2f       	mov	r25, r17
    1894:	01 e0       	ldi	r16, 0x01	; 1
    1896:	0e 94 bd 54 	call	0xa97a	; 0xa97a <__ashldi3>
    189a:	22 2e       	mov	r2, r18
    189c:	33 2e       	mov	r3, r19
    189e:	44 2e       	mov	r4, r20
    18a0:	55 2e       	mov	r5, r21
    18a2:	66 2e       	mov	r6, r22
    18a4:	77 2e       	mov	r7, r23
    18a6:	88 2e       	mov	r8, r24
    18a8:	99 2e       	mov	r9, r25
    18aa:	a2 2c       	mov	r10, r2
    18ac:	b3 2c       	mov	r11, r3
    18ae:	c4 2c       	mov	r12, r4
    18b0:	d5 2c       	mov	r13, r5
    18b2:	e6 2c       	mov	r14, r6
    18b4:	f7 2c       	mov	r15, r7
    18b6:	08 2d       	mov	r16, r8
    18b8:	19 2d       	mov	r17, r9
    18ba:	2a 2d       	mov	r18, r10
    18bc:	3b 2d       	mov	r19, r11
    18be:	4c 2d       	mov	r20, r12
    18c0:	5d 2d       	mov	r21, r13
    18c2:	6e 2d       	mov	r22, r14
    18c4:	7f 2d       	mov	r23, r15
    18c6:	80 2f       	mov	r24, r16
    18c8:	91 2f       	mov	r25, r17
    18ca:	0f 2e       	mov	r0, r31
    18cc:	f3 e0       	ldi	r31, 0x03	; 3
    18ce:	af 2e       	mov	r10, r31
    18d0:	f0 2d       	mov	r31, r0
    18d2:	bb 24       	eor	r11, r11
    18d4:	cc 24       	eor	r12, r12
    18d6:	dd 24       	eor	r13, r13
    18d8:	ee 24       	eor	r14, r14
    18da:	ff 24       	eor	r15, r15
    18dc:	00 e0       	ldi	r16, 0x00	; 0
    18de:	10 e0       	ldi	r17, 0x00	; 0
    18e0:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    18e4:	a2 2e       	mov	r10, r18
    18e6:	b3 2e       	mov	r11, r19
    18e8:	c4 2e       	mov	r12, r20
    18ea:	d5 2e       	mov	r13, r21
    18ec:	e6 2e       	mov	r14, r22
    18ee:	f7 2e       	mov	r15, r23
    18f0:	08 2f       	mov	r16, r24
    18f2:	19 2f       	mov	r17, r25
    18f4:	2a 2d       	mov	r18, r10
    18f6:	3b 2d       	mov	r19, r11
    18f8:	4c 2d       	mov	r20, r12
    18fa:	5d 2d       	mov	r21, r13
    18fc:	6e 2d       	mov	r22, r14
    18fe:	7f 2d       	mov	r23, r15
    1900:	80 2f       	mov	r24, r16
    1902:	91 2f       	mov	r25, r17
    1904:	da 01       	movw	r26, r20
    1906:	c9 01       	movw	r24, r18
    1908:	b0 95       	com	r27
    190a:	a0 95       	com	r26
    190c:	90 95       	com	r25
    190e:	81 95       	neg	r24
    1910:	9f 4f       	sbci	r25, 0xFF	; 255
    1912:	af 4f       	sbci	r26, 0xFF	; 255
    1914:	bf 4f       	sbci	r27, 0xFF	; 255
    1916:	2d a1       	lds	r18, 0x4d
    1918:	3e a1       	lds	r19, 0x4e
    191a:	f9 01       	movw	r30, r18
    191c:	80 83       	st	Z, r24
    191e:	91 83       	std	Z+1, r25	; 0x01
    1920:	a2 83       	std	Z+2, r26	; 0x02
    1922:	b3 83       	std	Z+3, r27	; 0x03
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1924:	29 89       	ldd	r18, Y+17	; 0x11
    1926:	3a 89       	ldd	r19, Y+18	; 0x12
    1928:	4b 89       	ldd	r20, Y+19	; 0x13
    192a:	5c 89       	ldd	r21, Y+20	; 0x14
    192c:	6d 89       	ldd	r22, Y+21	; 0x15
    192e:	7e 89       	ldd	r23, Y+22	; 0x16
    1930:	8f 89       	ldd	r24, Y+23	; 0x17
    1932:	98 8d       	ldd	r25, Y+24	; 0x18
    1934:	0f 2e       	mov	r0, r31
    1936:	f0 ea       	ldi	r31, 0xA0	; 160
    1938:	af 2e       	mov	r10, r31
    193a:	f0 2d       	mov	r31, r0
    193c:	0f 2e       	mov	r0, r31
    193e:	f5 e2       	ldi	r31, 0x25	; 37
    1940:	bf 2e       	mov	r11, r31
    1942:	f0 2d       	mov	r31, r0
    1944:	0f 2e       	mov	r0, r31
    1946:	f6 e2       	ldi	r31, 0x26	; 38
    1948:	cf 2e       	mov	r12, r31
    194a:	f0 2d       	mov	r31, r0
    194c:	dd 24       	eor	r13, r13
    194e:	ee 24       	eor	r14, r14
    1950:	ff 24       	eor	r15, r15
    1952:	00 e0       	ldi	r16, 0x00	; 0
    1954:	10 e0       	ldi	r17, 0x00	; 0
    1956:	0e 94 ea 53 	call	0xa7d4	; 0xa7d4 <__muldi3>
    195a:	22 2e       	mov	r2, r18
    195c:	33 2e       	mov	r3, r19
    195e:	44 2e       	mov	r4, r20
    1960:	55 2e       	mov	r5, r21
    1962:	66 2e       	mov	r6, r22
    1964:	77 2e       	mov	r7, r23
    1966:	88 2e       	mov	r8, r24
    1968:	99 2e       	mov	r9, r25
    196a:	a2 2c       	mov	r10, r2
    196c:	b3 2c       	mov	r11, r3
    196e:	c4 2c       	mov	r12, r4
    1970:	d5 2c       	mov	r13, r5
    1972:	e6 2c       	mov	r14, r6
    1974:	f7 2c       	mov	r15, r7
    1976:	08 2d       	mov	r16, r8
    1978:	19 2d       	mov	r17, r9
    197a:	2a 2d       	mov	r18, r10
    197c:	3b 2d       	mov	r19, r11
    197e:	4c 2d       	mov	r20, r12
    1980:	5d 2d       	mov	r21, r13
    1982:	6e 2d       	mov	r22, r14
    1984:	7f 2d       	mov	r23, r15
    1986:	80 2f       	mov	r24, r16
    1988:	91 2f       	mov	r25, r17
    198a:	aa 24       	eor	r10, r10
    198c:	aa 94       	dec	r10
    198e:	bb 24       	eor	r11, r11
    1990:	ba 94       	dec	r11
    1992:	0f 2e       	mov	r0, r31
    1994:	ff e7       	ldi	r31, 0x7F	; 127
    1996:	cf 2e       	mov	r12, r31
    1998:	f0 2d       	mov	r31, r0
    199a:	dd 24       	eor	r13, r13
    199c:	ee 24       	eor	r14, r14
    199e:	ff 24       	eor	r15, r15
    19a0:	00 e0       	ldi	r16, 0x00	; 0
    19a2:	10 e0       	ldi	r17, 0x00	; 0
    19a4:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    19a8:	22 2e       	mov	r2, r18
    19aa:	33 2e       	mov	r3, r19
    19ac:	44 2e       	mov	r4, r20
    19ae:	55 2e       	mov	r5, r21
    19b0:	66 2e       	mov	r6, r22
    19b2:	77 2e       	mov	r7, r23
    19b4:	88 2e       	mov	r8, r24
    19b6:	99 2e       	mov	r9, r25
    19b8:	a2 2c       	mov	r10, r2
    19ba:	b3 2c       	mov	r11, r3
    19bc:	c4 2c       	mov	r12, r4
    19be:	d5 2c       	mov	r13, r5
    19c0:	e6 2c       	mov	r14, r6
    19c2:	f7 2c       	mov	r15, r7
    19c4:	08 2d       	mov	r16, r8
    19c6:	19 2d       	mov	r17, r9
    19c8:	2a 2d       	mov	r18, r10
    19ca:	3b 2d       	mov	r19, r11
    19cc:	4c 2d       	mov	r20, r12
    19ce:	5d 2d       	mov	r21, r13
    19d0:	6e 2d       	mov	r22, r14
    19d2:	7f 2d       	mov	r23, r15
    19d4:	80 2f       	mov	r24, r16
    19d6:	91 2f       	mov	r25, r17
    19d8:	01 e0       	ldi	r16, 0x01	; 1
    19da:	0e 94 bd 54 	call	0xa97a	; 0xa97a <__ashldi3>
    19de:	22 2e       	mov	r2, r18
    19e0:	33 2e       	mov	r3, r19
    19e2:	44 2e       	mov	r4, r20
    19e4:	55 2e       	mov	r5, r21
    19e6:	66 2e       	mov	r6, r22
    19e8:	77 2e       	mov	r7, r23
    19ea:	88 2e       	mov	r8, r24
    19ec:	99 2e       	mov	r9, r25
    19ee:	a2 2c       	mov	r10, r2
    19f0:	b3 2c       	mov	r11, r3
    19f2:	c4 2c       	mov	r12, r4
    19f4:	d5 2c       	mov	r13, r5
    19f6:	e6 2c       	mov	r14, r6
    19f8:	f7 2c       	mov	r15, r7
    19fa:	08 2d       	mov	r16, r8
    19fc:	19 2d       	mov	r17, r9
    19fe:	2a 2d       	mov	r18, r10
    1a00:	3b 2d       	mov	r19, r11
    1a02:	4c 2d       	mov	r20, r12
    1a04:	5d 2d       	mov	r21, r13
    1a06:	6e 2d       	mov	r22, r14
    1a08:	7f 2d       	mov	r23, r15
    1a0a:	80 2f       	mov	r24, r16
    1a0c:	91 2f       	mov	r25, r17
    1a0e:	0f 2e       	mov	r0, r31
    1a10:	f3 e0       	ldi	r31, 0x03	; 3
    1a12:	af 2e       	mov	r10, r31
    1a14:	f0 2d       	mov	r31, r0
    1a16:	bb 24       	eor	r11, r11
    1a18:	cc 24       	eor	r12, r12
    1a1a:	dd 24       	eor	r13, r13
    1a1c:	ee 24       	eor	r14, r14
    1a1e:	ff 24       	eor	r15, r15
    1a20:	00 e0       	ldi	r16, 0x00	; 0
    1a22:	10 e0       	ldi	r17, 0x00	; 0
    1a24:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    1a28:	a2 2e       	mov	r10, r18
    1a2a:	b3 2e       	mov	r11, r19
    1a2c:	c4 2e       	mov	r12, r20
    1a2e:	d5 2e       	mov	r13, r21
    1a30:	e6 2e       	mov	r14, r22
    1a32:	f7 2e       	mov	r15, r23
    1a34:	08 2f       	mov	r16, r24
    1a36:	19 2f       	mov	r17, r25
    1a38:	2a 2d       	mov	r18, r10
    1a3a:	3b 2d       	mov	r19, r11
    1a3c:	4c 2d       	mov	r20, r12
    1a3e:	5d 2d       	mov	r21, r13
    1a40:	6e 2d       	mov	r22, r14
    1a42:	7f 2d       	mov	r23, r15
    1a44:	80 2f       	mov	r24, r16
    1a46:	91 2f       	mov	r25, r17
    1a48:	da 01       	movw	r26, r20
    1a4a:	c9 01       	movw	r24, r18
    1a4c:	b0 95       	com	r27
    1a4e:	a0 95       	com	r26
    1a50:	90 95       	com	r25
    1a52:	81 95       	neg	r24
    1a54:	9f 4f       	sbci	r25, 0xFF	; 255
    1a56:	af 4f       	sbci	r26, 0xFF	; 255
    1a58:	bf 4f       	sbci	r27, 0xFF	; 255
    1a5a:	29 a5       	lds	r18, 0x69
    1a5c:	3a a5       	lds	r19, 0x6a
    1a5e:	f9 01       	movw	r30, r18
    1a60:	80 83       	st	Z, r24
    1a62:	91 83       	std	Z+1, r25	; 0x01
    1a64:	a2 83       	std	Z+2, r26	; 0x02
    1a66:	b3 83       	std	Z+3, r27	; 0x03
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a68:	29 85       	ldd	r18, Y+9	; 0x09
    1a6a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a6c:	4b 85       	ldd	r20, Y+11	; 0x0b
    1a6e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1a70:	6d 85       	ldd	r22, Y+13	; 0x0d
    1a72:	7e 85       	ldd	r23, Y+14	; 0x0e
    1a74:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a76:	98 89       	ldd	r25, Y+16	; 0x10
    1a78:	0f 2e       	mov	r0, r31
    1a7a:	f0 ea       	ldi	r31, 0xA0	; 160
    1a7c:	af 2e       	mov	r10, r31
    1a7e:	f0 2d       	mov	r31, r0
    1a80:	0f 2e       	mov	r0, r31
    1a82:	f5 e2       	ldi	r31, 0x25	; 37
    1a84:	bf 2e       	mov	r11, r31
    1a86:	f0 2d       	mov	r31, r0
    1a88:	0f 2e       	mov	r0, r31
    1a8a:	f6 e2       	ldi	r31, 0x26	; 38
    1a8c:	cf 2e       	mov	r12, r31
    1a8e:	f0 2d       	mov	r31, r0
    1a90:	dd 24       	eor	r13, r13
    1a92:	ee 24       	eor	r14, r14
    1a94:	ff 24       	eor	r15, r15
    1a96:	00 e0       	ldi	r16, 0x00	; 0
    1a98:	10 e0       	ldi	r17, 0x00	; 0
    1a9a:	0e 94 ea 53 	call	0xa7d4	; 0xa7d4 <__muldi3>
    1a9e:	22 2e       	mov	r2, r18
    1aa0:	33 2e       	mov	r3, r19
    1aa2:	44 2e       	mov	r4, r20
    1aa4:	55 2e       	mov	r5, r21
    1aa6:	66 2e       	mov	r6, r22
    1aa8:	77 2e       	mov	r7, r23
    1aaa:	88 2e       	mov	r8, r24
    1aac:	99 2e       	mov	r9, r25
    1aae:	a2 2c       	mov	r10, r2
    1ab0:	b3 2c       	mov	r11, r3
    1ab2:	c4 2c       	mov	r12, r4
    1ab4:	d5 2c       	mov	r13, r5
    1ab6:	e6 2c       	mov	r14, r6
    1ab8:	f7 2c       	mov	r15, r7
    1aba:	08 2d       	mov	r16, r8
    1abc:	19 2d       	mov	r17, r9
    1abe:	2a 2d       	mov	r18, r10
    1ac0:	3b 2d       	mov	r19, r11
    1ac2:	4c 2d       	mov	r20, r12
    1ac4:	5d 2d       	mov	r21, r13
    1ac6:	6e 2d       	mov	r22, r14
    1ac8:	7f 2d       	mov	r23, r15
    1aca:	80 2f       	mov	r24, r16
    1acc:	91 2f       	mov	r25, r17
    1ace:	aa 24       	eor	r10, r10
    1ad0:	aa 94       	dec	r10
    1ad2:	bb 24       	eor	r11, r11
    1ad4:	ba 94       	dec	r11
    1ad6:	0f 2e       	mov	r0, r31
    1ad8:	ff e7       	ldi	r31, 0x7F	; 127
    1ada:	cf 2e       	mov	r12, r31
    1adc:	f0 2d       	mov	r31, r0
    1ade:	dd 24       	eor	r13, r13
    1ae0:	ee 24       	eor	r14, r14
    1ae2:	ff 24       	eor	r15, r15
    1ae4:	00 e0       	ldi	r16, 0x00	; 0
    1ae6:	10 e0       	ldi	r17, 0x00	; 0
    1ae8:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    1aec:	22 2e       	mov	r2, r18
    1aee:	33 2e       	mov	r3, r19
    1af0:	44 2e       	mov	r4, r20
    1af2:	55 2e       	mov	r5, r21
    1af4:	66 2e       	mov	r6, r22
    1af6:	77 2e       	mov	r7, r23
    1af8:	88 2e       	mov	r8, r24
    1afa:	99 2e       	mov	r9, r25
    1afc:	a2 2c       	mov	r10, r2
    1afe:	b3 2c       	mov	r11, r3
    1b00:	c4 2c       	mov	r12, r4
    1b02:	d5 2c       	mov	r13, r5
    1b04:	e6 2c       	mov	r14, r6
    1b06:	f7 2c       	mov	r15, r7
    1b08:	08 2d       	mov	r16, r8
    1b0a:	19 2d       	mov	r17, r9
    1b0c:	2a 2d       	mov	r18, r10
    1b0e:	3b 2d       	mov	r19, r11
    1b10:	4c 2d       	mov	r20, r12
    1b12:	5d 2d       	mov	r21, r13
    1b14:	6e 2d       	mov	r22, r14
    1b16:	7f 2d       	mov	r23, r15
    1b18:	80 2f       	mov	r24, r16
    1b1a:	91 2f       	mov	r25, r17
    1b1c:	01 e0       	ldi	r16, 0x01	; 1
    1b1e:	0e 94 bd 54 	call	0xa97a	; 0xa97a <__ashldi3>
    1b22:	22 2e       	mov	r2, r18
    1b24:	33 2e       	mov	r3, r19
    1b26:	44 2e       	mov	r4, r20
    1b28:	55 2e       	mov	r5, r21
    1b2a:	66 2e       	mov	r6, r22
    1b2c:	77 2e       	mov	r7, r23
    1b2e:	88 2e       	mov	r8, r24
    1b30:	99 2e       	mov	r9, r25
    1b32:	a2 2c       	mov	r10, r2
    1b34:	b3 2c       	mov	r11, r3
    1b36:	c4 2c       	mov	r12, r4
    1b38:	d5 2c       	mov	r13, r5
    1b3a:	e6 2c       	mov	r14, r6
    1b3c:	f7 2c       	mov	r15, r7
    1b3e:	08 2d       	mov	r16, r8
    1b40:	19 2d       	mov	r17, r9
    1b42:	2a 2d       	mov	r18, r10
    1b44:	3b 2d       	mov	r19, r11
    1b46:	4c 2d       	mov	r20, r12
    1b48:	5d 2d       	mov	r21, r13
    1b4a:	6e 2d       	mov	r22, r14
    1b4c:	7f 2d       	mov	r23, r15
    1b4e:	80 2f       	mov	r24, r16
    1b50:	91 2f       	mov	r25, r17
    1b52:	0f 2e       	mov	r0, r31
    1b54:	f3 e0       	ldi	r31, 0x03	; 3
    1b56:	af 2e       	mov	r10, r31
    1b58:	f0 2d       	mov	r31, r0
    1b5a:	bb 24       	eor	r11, r11
    1b5c:	cc 24       	eor	r12, r12
    1b5e:	dd 24       	eor	r13, r13
    1b60:	ee 24       	eor	r14, r14
    1b62:	ff 24       	eor	r15, r15
    1b64:	00 e0       	ldi	r16, 0x00	; 0
    1b66:	10 e0       	ldi	r17, 0x00	; 0
    1b68:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    1b6c:	a2 2e       	mov	r10, r18
    1b6e:	b3 2e       	mov	r11, r19
    1b70:	c4 2e       	mov	r12, r20
    1b72:	d5 2e       	mov	r13, r21
    1b74:	e6 2e       	mov	r14, r22
    1b76:	f7 2e       	mov	r15, r23
    1b78:	08 2f       	mov	r16, r24
    1b7a:	19 2f       	mov	r17, r25
    1b7c:	2a 2d       	mov	r18, r10
    1b7e:	3b 2d       	mov	r19, r11
    1b80:	4c 2d       	mov	r20, r12
    1b82:	5d 2d       	mov	r21, r13
    1b84:	6e 2d       	mov	r22, r14
    1b86:	7f 2d       	mov	r23, r15
    1b88:	80 2f       	mov	r24, r16
    1b8a:	91 2f       	mov	r25, r17
    1b8c:	da 01       	movw	r26, r20
    1b8e:	c9 01       	movw	r24, r18
    1b90:	b0 95       	com	r27
    1b92:	a0 95       	com	r26
    1b94:	90 95       	com	r25
    1b96:	81 95       	neg	r24
    1b98:	9f 4f       	sbci	r25, 0xFF	; 255
    1b9a:	af 4f       	sbci	r26, 0xFF	; 255
    1b9c:	bf 4f       	sbci	r27, 0xFF	; 255
    1b9e:	2f a1       	lds	r18, 0x4f
    1ba0:	38 a5       	lds	r19, 0x68
    1ba2:	f9 01       	movw	r30, r18
    1ba4:	80 83       	st	Z, r24
    1ba6:	91 83       	std	Z+1, r25	; 0x01
    1ba8:	a2 83       	std	Z+2, r26	; 0x02
    1baa:	b3 83       	std	Z+3, r27	; 0x03

}
    1bac:	ec 96       	adiw	r28, 0x3c	; 60
    1bae:	cd bf       	out	0x3d, r28	; 61
    1bb0:	de bf       	out	0x3e, r29	; 62
    1bb2:	df 91       	pop	r29
    1bb4:	cf 91       	pop	r28
    1bb6:	1f 91       	pop	r17
    1bb8:	0f 91       	pop	r16
    1bba:	ff 90       	pop	r15
    1bbc:	ef 90       	pop	r14
    1bbe:	df 90       	pop	r13
    1bc0:	cf 90       	pop	r12
    1bc2:	bf 90       	pop	r11
    1bc4:	af 90       	pop	r10
    1bc6:	9f 90       	pop	r9
    1bc8:	8f 90       	pop	r8
    1bca:	7f 90       	pop	r7
    1bcc:	6f 90       	pop	r6
    1bce:	5f 90       	pop	r5
    1bd0:	4f 90       	pop	r4
    1bd2:	3f 90       	pop	r3
    1bd4:	2f 90       	pop	r2
    1bd6:	08 95       	ret

00001bd8 <CO_collectADC_cont>:

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1bd8:	cf 93       	push	r28
    1bda:	df 93       	push	r29
    1bdc:	00 d0       	rcall	.+0      	; 0x1bde <CO_collectADC_cont+0x6>
    1bde:	00 d0       	rcall	.+0      	; 0x1be0 <CO_collectADC_cont+0x8>
    1be0:	cd b7       	in	r28, 0x3d	; 61
    1be2:	de b7       	in	r29, 0x3e	; 62
    1be4:	8b 83       	std	Y+3, r24	; 0x03
    1be6:	6c 83       	std	Y+4, r22	; 0x04
    1be8:	4d 83       	std	Y+5, r20	; 0x05
    1bea:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
//get data to write files to SD card
getBootSectorData();
    1bf2:	0e 94 86 41 	call	0x830c	; 0x830c <getBootSectorData>
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf8:	6d 81       	ldd	r22, Y+5	; 0x05
    1bfa:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
set_filter(filterConfig);
    1bfe:	8c 81       	ldd	r24, Y+4	; 0x04
    1c00:	0e 94 59 08 	call	0x10b2	; 0x10b2 <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1c04:	8b 81       	ldd	r24, Y+3	; 0x03
    1c06:	85 30       	cpi	r24, 0x05	; 5
    1c08:	31 f0       	breq	.+12     	; 0x1c16 <CO_collectADC_cont+0x3e>
    1c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0c:	86 30       	cpi	r24, 0x06	; 6
    1c0e:	19 f0       	breq	.+6      	; 0x1c16 <CO_collectADC_cont+0x3e>
    1c10:	8b 81       	ldd	r24, Y+3	; 0x03
    1c12:	87 30       	cpi	r24, 0x07	; 7
    1c14:	19 f4       	brne	.+6      	; 0x1c1c <CO_collectADC_cont+0x44>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1c16:	81 e0       	ldi	r24, 0x01	; 1
    1c18:	0e 94 33 11 	call	0x2266	; 0x2266 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1c1c:	81 e0       	ldi	r24, 0x01	; 1
    1c1e:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
setADCInput(channel);
    1c22:	8b 81       	ldd	r24, Y+3	; 0x03
    1c24:	0e 94 5f 1c 	call	0x38be	; 0x38be <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1c28:	84 e0       	ldi	r24, 0x04	; 4
    1c2a:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1c2e:	80 ec       	ldi	r24, 0xC0	; 192
    1c30:	98 e0       	ldi	r25, 0x08	; 8
    1c32:	24 e5       	ldi	r18, 0x54	; 84
    1c34:	fc 01       	movw	r30, r24
    1c36:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1c38:	80 ea       	ldi	r24, 0xA0	; 160
    1c3a:	96 e0       	ldi	r25, 0x06	; 6
    1c3c:	21 e0       	ldi	r18, 0x01	; 1
    1c3e:	fc 01       	movw	r30, r24
    1c40:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1c42:	80 ea       	ldi	r24, 0xA0	; 160
    1c44:	96 e0       	ldi	r25, 0x06	; 6
    1c46:	22 e0       	ldi	r18, 0x02	; 2
    1c48:	fc 01       	movw	r30, r24
    1c4a:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    1c4c:	80 ea       	ldi	r24, 0xA0	; 160
    1c4e:	96 e0       	ldi	r25, 0x06	; 6
    1c50:	21 e0       	ldi	r18, 0x01	; 1
    1c52:	fc 01       	movw	r30, r24
    1c54:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_LO_gc;
    1c56:	80 ea       	ldi	r24, 0xA0	; 160
    1c58:	96 e0       	ldi	r25, 0x06	; 6
    1c5a:	24 e0       	ldi	r18, 0x04	; 4
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    1c60:	80 e8       	ldi	r24, 0x80	; 128
    1c62:	96 e0       	ldi	r25, 0x06	; 6
    1c64:	20 e2       	ldi	r18, 0x20	; 32
    1c66:	fc 01       	movw	r30, r24
    1c68:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1c6a:	80 e4       	ldi	r24, 0x40	; 64
    1c6c:	9a e0       	ldi	r25, 0x0A	; 10
    1c6e:	23 e2       	ldi	r18, 0x23	; 35
    1c70:	fc 01       	movw	r30, r24
    1c72:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1c74:	8e 81       	ldd	r24, Y+6	; 0x06
    1c76:	88 2f       	mov	r24, r24
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	25 e1       	ldi	r18, 0x15	; 21
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	28 1b       	sub	r18, r24
    1c80:	39 0b       	sbc	r19, r25
    1c82:	81 e0       	ldi	r24, 0x01	; 1
    1c84:	90 e0       	ldi	r25, 0x00	; 0
    1c86:	02 c0       	rjmp	.+4      	; 0x1c8c <CO_collectADC_cont+0xb4>
    1c88:	88 0f       	add	r24, r24
    1c8a:	99 1f       	adc	r25, r25
    1c8c:	2a 95       	dec	r18
    1c8e:	e2 f7       	brpl	.-8      	; 0x1c88 <CO_collectADC_cont+0xb0>
    1c90:	01 97       	sbiw	r24, 0x01	; 1
    1c92:	89 83       	std	Y+1, r24	; 0x01
    1c94:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1c96:	80 e4       	ldi	r24, 0x40	; 64
    1c98:	9a e0       	ldi	r25, 0x0A	; 10
    1c9a:	29 81       	ldd	r18, Y+1	; 0x01
    1c9c:	3a 81       	ldd	r19, Y+2	; 0x02
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	26 a3       	lds	r18, 0x56
    1ca2:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1ca4:	80 e4       	ldi	r24, 0x40	; 64
    1ca6:	9a e0       	ldi	r25, 0x0A	; 10
    1ca8:	29 81       	ldd	r18, Y+1	; 0x01
    1caa:	3a 81       	ldd	r19, Y+2	; 0x02
    1cac:	36 95       	lsr	r19
    1cae:	27 95       	ror	r18
    1cb0:	fc 01       	movw	r30, r24
    1cb2:	22 af       	sts	0x72, r18
    1cb4:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1cb6:	80 e4       	ldi	r24, 0x40	; 64
    1cb8:	9a e0       	ldi	r25, 0x0A	; 10
    1cba:	20 e4       	ldi	r18, 0x40	; 64
    1cbc:	3a e0       	ldi	r19, 0x0A	; 10
    1cbe:	f9 01       	movw	r30, r18
    1cc0:	20 81       	ld	r18, Z
    1cc2:	20 7f       	andi	r18, 0xF0	; 240
    1cc4:	21 60       	ori	r18, 0x01	; 1
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1cca:	80 ea       	ldi	r24, 0xA0	; 160
    1ccc:	90 e0       	ldi	r25, 0x00	; 0
    1cce:	20 ea       	ldi	r18, 0xA0	; 160
    1cd0:	30 e0       	ldi	r19, 0x00	; 0
    1cd2:	f9 01       	movw	r30, r18
    1cd4:	22 81       	ldd	r18, Z+2	; 0x02
    1cd6:	21 60       	ori	r18, 0x01	; 1
    1cd8:	fc 01       	movw	r30, r24
    1cda:	22 83       	std	Z+2, r18	; 0x02
chb_init();
    1cdc:	0e 94 42 20 	call	0x4084	; 0x4084 <chb_init>
chb_set_short_addr(moteID);
    1ce0:	80 91 d0 50 	lds	r24, 0x50D0
    1ce4:	88 2f       	mov	r24, r24
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	0e 94 d6 2d 	call	0x5bac	; 0x5bac <chb_set_short_addr>
sei();
    1cec:	78 94       	sei

sampleCount = 0;
    1cee:	10 92 61 50 	sts	0x5061, r1
    1cf2:	10 92 62 50 	sts	0x5062, r1
TotalSampleCount = 0;
    1cf6:	10 92 8f 50 	sts	0x508F, r1
    1cfa:	10 92 90 50 	sts	0x5090, r1
discardCount = 0;
    1cfe:	10 92 4c 40 	sts	0x404C, r1
}
    1d02:	26 96       	adiw	r28, 0x06	; 6
    1d04:	cd bf       	out	0x3d, r28	; 61
    1d06:	de bf       	out	0x3e, r29	; 62
    1d08:	df 91       	pop	r29
    1d0a:	cf 91       	pop	r28
    1d0c:	08 95       	ret

00001d0e <ADC_Pause_Sampling>:


void ADC_Pause_Sampling(){
    1d0e:	cf 93       	push	r28
    1d10:	df 93       	push	r29
    1d12:	cd b7       	in	r28, 0x3d	; 61
    1d14:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1d16:	80 ea       	ldi	r24, 0xA0	; 160
    1d18:	96 e0       	ldi	r25, 0x06	; 6
    1d1a:	fc 01       	movw	r30, r24
    1d1c:	13 86       	std	Z+11, r1	; 0x0b
}
    1d1e:	df 91       	pop	r29
    1d20:	cf 91       	pop	r28
    1d22:	08 95       	ret

00001d24 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    1d24:	cf 93       	push	r28
    1d26:	df 93       	push	r29
    1d28:	cd b7       	in	r28, 0x3d	; 61
    1d2a:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1d2c:	80 ea       	ldi	r24, 0xA0	; 160
    1d2e:	96 e0       	ldi	r25, 0x06	; 6
    1d30:	21 e0       	ldi	r18, 0x01	; 1
    1d32:	fc 01       	movw	r30, r24
    1d34:	23 87       	std	Z+11, r18	; 0x0b
}	
    1d36:	df 91       	pop	r29
    1d38:	cf 91       	pop	r28
    1d3a:	08 95       	ret

00001d3c <__vector_105>:
ISR(PORTF_INT1_vect) {
    1d3c:	1f 92       	push	r1
    1d3e:	0f 92       	push	r0
    1d40:	0f b6       	in	r0, 0x3f	; 63
    1d42:	0f 92       	push	r0
    1d44:	00 90 3b 00 	lds	r0, 0x003B
    1d48:	0f 92       	push	r0
    1d4a:	11 24       	eor	r1, r1
    1d4c:	2f 92       	push	r2
    1d4e:	3f 92       	push	r3
    1d50:	4f 92       	push	r4
    1d52:	5f 92       	push	r5
    1d54:	6f 92       	push	r6
    1d56:	7f 92       	push	r7
    1d58:	8f 92       	push	r8
    1d5a:	9f 92       	push	r9
    1d5c:	af 92       	push	r10
    1d5e:	bf 92       	push	r11
    1d60:	cf 92       	push	r12
    1d62:	df 92       	push	r13
    1d64:	ef 92       	push	r14
    1d66:	ff 92       	push	r15
    1d68:	0f 93       	push	r16
    1d6a:	1f 93       	push	r17
    1d6c:	2f 93       	push	r18
    1d6e:	3f 93       	push	r19
    1d70:	4f 93       	push	r20
    1d72:	5f 93       	push	r21
    1d74:	6f 93       	push	r22
    1d76:	7f 93       	push	r23
    1d78:	8f 93       	push	r24
    1d7a:	9f 93       	push	r25
    1d7c:	af 93       	push	r26
    1d7e:	bf 93       	push	r27
    1d80:	ef 93       	push	r30
    1d82:	ff 93       	push	r31
    1d84:	cf 93       	push	r28
    1d86:	df 93       	push	r29
    1d88:	00 d0       	rcall	.+0      	; 0x1d8a <__vector_105+0x4e>
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1d8e:	80 91 4c 40 	lds	r24, 0x404C
    1d92:	88 23       	and	r24, r24
    1d94:	34 f0       	brlt	.+12     	; 0x1da2 <__vector_105+0x66>
		discardCount++;
    1d96:	80 91 4c 40 	lds	r24, 0x404C
    1d9a:	8f 5f       	subi	r24, 0xFF	; 255
    1d9c:	80 93 4c 40 	sts	0x404C, r24
    1da0:	7b c1       	rjmp	.+758    	; 0x2098 <__vector_105+0x35c>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1da2:	84 e0       	ldi	r24, 0x04	; 4
    1da4:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1da8:	80 ec       	ldi	r24, 0xC0	; 192
    1daa:	98 e0       	ldi	r25, 0x08	; 8
    1dac:	24 e5       	ldi	r18, 0x54	; 84
    1dae:	fc 01       	movw	r30, r24
    1db0:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1db8:	80 ea       	ldi	r24, 0xA0	; 160
    1dba:	96 e0       	ldi	r25, 0x06	; 6
    1dbc:	22 e0       	ldi	r18, 0x02	; 2
    1dbe:	fc 01       	movw	r30, r24
    1dc0:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1dc2:	19 82       	std	Y+1, r1	; 0x01
    1dc4:	1a c0       	rjmp	.+52     	; 0x1dfa <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1dc6:	80 ec       	ldi	r24, 0xC0	; 192
    1dc8:	98 e0       	ldi	r25, 0x08	; 8
    1dca:	2a ea       	ldi	r18, 0xAA	; 170
    1dcc:	fc 01       	movw	r30, r24
    1dce:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1dd0:	00 00       	nop
    1dd2:	80 ec       	ldi	r24, 0xC0	; 192
    1dd4:	98 e0       	ldi	r25, 0x08	; 8
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	82 81       	ldd	r24, Z+2	; 0x02
    1dda:	88 23       	and	r24, r24
    1ddc:	d4 f7       	brge	.-12     	; 0x1dd2 <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1dde:	89 81       	ldd	r24, Y+1	; 0x01
    1de0:	88 2f       	mov	r24, r24
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	20 ec       	ldi	r18, 0xC0	; 192
    1de6:	38 e0       	ldi	r19, 0x08	; 8
    1de8:	f9 01       	movw	r30, r18
    1dea:	23 81       	ldd	r18, Z+3	; 0x03
    1dec:	8c 5a       	subi	r24, 0xAC	; 172
    1dee:	9f 4a       	sbci	r25, 0xAF	; 175
    1df0:	fc 01       	movw	r30, r24
    1df2:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1df4:	89 81       	ldd	r24, Y+1	; 0x01
    1df6:	8f 5f       	subi	r24, 0xFF	; 255
    1df8:	89 83       	std	Y+1, r24	; 0x01
    1dfa:	89 81       	ldd	r24, Y+1	; 0x01
    1dfc:	83 30       	cpi	r24, 0x03	; 3
    1dfe:	18 f3       	brcs	.-58     	; 0x1dc6 <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1e00:	80 ea       	ldi	r24, 0xA0	; 160
    1e02:	96 e0       	ldi	r25, 0x06	; 6
    1e04:	22 e0       	ldi	r18, 0x02	; 2
    1e06:	fc 01       	movw	r30, r24
    1e08:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1e0a:	80 e0       	ldi	r24, 0x00	; 0
    1e0c:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1e10:	80 91 54 50 	lds	r24, 0x5054
    1e14:	88 23       	and	r24, r24
    1e16:	34 f4       	brge	.+12     	; 0x1e24 <__vector_105+0xe8>
    1e18:	85 e5       	ldi	r24, 0x55	; 85
    1e1a:	90 e4       	ldi	r25, 0x40	; 64
    1e1c:	2f ef       	ldi	r18, 0xFF	; 255
    1e1e:	fc 01       	movw	r30, r24
    1e20:	20 83       	st	Z, r18
    1e22:	04 c0       	rjmp	.+8      	; 0x1e2c <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    1e24:	85 e5       	ldi	r24, 0x55	; 85
    1e26:	90 e4       	ldi	r25, 0x40	; 64
    1e28:	fc 01       	movw	r30, r24
    1e2a:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1e2c:	84 e5       	ldi	r24, 0x54	; 84
    1e2e:	90 e4       	ldi	r25, 0x40	; 64
    1e30:	20 91 54 50 	lds	r18, 0x5054
    1e34:	fc 01       	movw	r30, r24
    1e36:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1e38:	83 e5       	ldi	r24, 0x53	; 83
    1e3a:	90 e4       	ldi	r25, 0x40	; 64
    1e3c:	20 91 55 50 	lds	r18, 0x5055
    1e40:	fc 01       	movw	r30, r24
    1e42:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    1e44:	82 e5       	ldi	r24, 0x52	; 82
    1e46:	90 e4       	ldi	r25, 0x40	; 64
    1e48:	20 91 56 50 	lds	r18, 0x5056
    1e4c:	fc 01       	movw	r30, r24
    1e4e:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    1e50:	80 91 52 40 	lds	r24, 0x4052
    1e54:	90 91 53 40 	lds	r25, 0x4053
    1e58:	a0 91 54 40 	lds	r26, 0x4054
    1e5c:	b0 91 55 40 	lds	r27, 0x4055
    1e60:	5c 01       	movw	r10, r24
    1e62:	6d 01       	movw	r12, r26
    1e64:	bb 0f       	add	r27, r27
    1e66:	88 0b       	sbc	r24, r24
    1e68:	98 2f       	mov	r25, r24
    1e6a:	dc 01       	movw	r26, r24
    1e6c:	e8 2e       	mov	r14, r24
    1e6e:	f8 2e       	mov	r15, r24
    1e70:	08 2f       	mov	r16, r24
    1e72:	18 2f       	mov	r17, r24
    1e74:	a0 92 91 50 	sts	0x5091, r10
    1e78:	b0 92 92 50 	sts	0x5092, r11
    1e7c:	c0 92 93 50 	sts	0x5093, r12
    1e80:	d0 92 94 50 	sts	0x5094, r13
    1e84:	e0 92 95 50 	sts	0x5095, r14
    1e88:	f0 92 96 50 	sts	0x5096, r15
    1e8c:	00 93 97 50 	sts	0x5097, r16
    1e90:	10 93 98 50 	sts	0x5098, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1e94:	80 91 61 50 	lds	r24, 0x5061
    1e98:	90 91 62 50 	lds	r25, 0x5062
    1e9c:	88 0f       	add	r24, r24
    1e9e:	99 1f       	adc	r25, r25
    1ea0:	88 0f       	add	r24, r24
    1ea2:	99 1f       	adc	r25, r25
    1ea4:	9c 01       	movw	r18, r24
    1ea6:	22 53       	subi	r18, 0x32	; 50
    1ea8:	3c 4d       	sbci	r19, 0xDC	; 220
    1eaa:	2a 83       	std	Y+2, r18	; 0x02
    1eac:	3b 83       	std	Y+3, r19	; 0x03
    1eae:	a0 90 91 50 	lds	r10, 0x5091
    1eb2:	b0 90 92 50 	lds	r11, 0x5092
    1eb6:	c0 90 93 50 	lds	r12, 0x5093
    1eba:	d0 90 94 50 	lds	r13, 0x5094
    1ebe:	e0 90 95 50 	lds	r14, 0x5095
    1ec2:	f0 90 96 50 	lds	r15, 0x5096
    1ec6:	00 91 97 50 	lds	r16, 0x5097
    1eca:	10 91 98 50 	lds	r17, 0x5098
    1ece:	2a 2d       	mov	r18, r10
    1ed0:	3b 2d       	mov	r19, r11
    1ed2:	4c 2d       	mov	r20, r12
    1ed4:	5d 2d       	mov	r21, r13
    1ed6:	6e 2d       	mov	r22, r14
    1ed8:	7f 2d       	mov	r23, r15
    1eda:	80 2f       	mov	r24, r16
    1edc:	91 2f       	mov	r25, r17
    1ede:	0f 2e       	mov	r0, r31
    1ee0:	f0 ea       	ldi	r31, 0xA0	; 160
    1ee2:	af 2e       	mov	r10, r31
    1ee4:	f0 2d       	mov	r31, r0
    1ee6:	0f 2e       	mov	r0, r31
    1ee8:	f5 e2       	ldi	r31, 0x25	; 37
    1eea:	bf 2e       	mov	r11, r31
    1eec:	f0 2d       	mov	r31, r0
    1eee:	0f 2e       	mov	r0, r31
    1ef0:	f6 e2       	ldi	r31, 0x26	; 38
    1ef2:	cf 2e       	mov	r12, r31
    1ef4:	f0 2d       	mov	r31, r0
    1ef6:	dd 24       	eor	r13, r13
    1ef8:	ee 24       	eor	r14, r14
    1efa:	ff 24       	eor	r15, r15
    1efc:	00 e0       	ldi	r16, 0x00	; 0
    1efe:	10 e0       	ldi	r17, 0x00	; 0
    1f00:	0e 94 ea 53 	call	0xa7d4	; 0xa7d4 <__muldi3>
    1f04:	22 2e       	mov	r2, r18
    1f06:	33 2e       	mov	r3, r19
    1f08:	44 2e       	mov	r4, r20
    1f0a:	55 2e       	mov	r5, r21
    1f0c:	66 2e       	mov	r6, r22
    1f0e:	77 2e       	mov	r7, r23
    1f10:	88 2e       	mov	r8, r24
    1f12:	99 2e       	mov	r9, r25
    1f14:	a2 2c       	mov	r10, r2
    1f16:	b3 2c       	mov	r11, r3
    1f18:	c4 2c       	mov	r12, r4
    1f1a:	d5 2c       	mov	r13, r5
    1f1c:	e6 2c       	mov	r14, r6
    1f1e:	f7 2c       	mov	r15, r7
    1f20:	08 2d       	mov	r16, r8
    1f22:	19 2d       	mov	r17, r9
    1f24:	2a 2d       	mov	r18, r10
    1f26:	3b 2d       	mov	r19, r11
    1f28:	4c 2d       	mov	r20, r12
    1f2a:	5d 2d       	mov	r21, r13
    1f2c:	6e 2d       	mov	r22, r14
    1f2e:	7f 2d       	mov	r23, r15
    1f30:	80 2f       	mov	r24, r16
    1f32:	91 2f       	mov	r25, r17
    1f34:	aa 24       	eor	r10, r10
    1f36:	aa 94       	dec	r10
    1f38:	bb 24       	eor	r11, r11
    1f3a:	ba 94       	dec	r11
    1f3c:	0f 2e       	mov	r0, r31
    1f3e:	ff e7       	ldi	r31, 0x7F	; 127
    1f40:	cf 2e       	mov	r12, r31
    1f42:	f0 2d       	mov	r31, r0
    1f44:	dd 24       	eor	r13, r13
    1f46:	ee 24       	eor	r14, r14
    1f48:	ff 24       	eor	r15, r15
    1f4a:	00 e0       	ldi	r16, 0x00	; 0
    1f4c:	10 e0       	ldi	r17, 0x00	; 0
    1f4e:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    1f52:	22 2e       	mov	r2, r18
    1f54:	33 2e       	mov	r3, r19
    1f56:	44 2e       	mov	r4, r20
    1f58:	55 2e       	mov	r5, r21
    1f5a:	66 2e       	mov	r6, r22
    1f5c:	77 2e       	mov	r7, r23
    1f5e:	88 2e       	mov	r8, r24
    1f60:	99 2e       	mov	r9, r25
    1f62:	a2 2c       	mov	r10, r2
    1f64:	b3 2c       	mov	r11, r3
    1f66:	c4 2c       	mov	r12, r4
    1f68:	d5 2c       	mov	r13, r5
    1f6a:	e6 2c       	mov	r14, r6
    1f6c:	f7 2c       	mov	r15, r7
    1f6e:	08 2d       	mov	r16, r8
    1f70:	19 2d       	mov	r17, r9
    1f72:	2a 2d       	mov	r18, r10
    1f74:	3b 2d       	mov	r19, r11
    1f76:	4c 2d       	mov	r20, r12
    1f78:	5d 2d       	mov	r21, r13
    1f7a:	6e 2d       	mov	r22, r14
    1f7c:	7f 2d       	mov	r23, r15
    1f7e:	80 2f       	mov	r24, r16
    1f80:	91 2f       	mov	r25, r17
    1f82:	01 e0       	ldi	r16, 0x01	; 1
    1f84:	0e 94 bd 54 	call	0xa97a	; 0xa97a <__ashldi3>
    1f88:	22 2e       	mov	r2, r18
    1f8a:	33 2e       	mov	r3, r19
    1f8c:	44 2e       	mov	r4, r20
    1f8e:	55 2e       	mov	r5, r21
    1f90:	66 2e       	mov	r6, r22
    1f92:	77 2e       	mov	r7, r23
    1f94:	88 2e       	mov	r8, r24
    1f96:	99 2e       	mov	r9, r25
    1f98:	a2 2c       	mov	r10, r2
    1f9a:	b3 2c       	mov	r11, r3
    1f9c:	c4 2c       	mov	r12, r4
    1f9e:	d5 2c       	mov	r13, r5
    1fa0:	e6 2c       	mov	r14, r6
    1fa2:	f7 2c       	mov	r15, r7
    1fa4:	08 2d       	mov	r16, r8
    1fa6:	19 2d       	mov	r17, r9
    1fa8:	2a 2d       	mov	r18, r10
    1faa:	3b 2d       	mov	r19, r11
    1fac:	4c 2d       	mov	r20, r12
    1fae:	5d 2d       	mov	r21, r13
    1fb0:	6e 2d       	mov	r22, r14
    1fb2:	7f 2d       	mov	r23, r15
    1fb4:	80 2f       	mov	r24, r16
    1fb6:	91 2f       	mov	r25, r17
    1fb8:	0f 2e       	mov	r0, r31
    1fba:	f3 e0       	ldi	r31, 0x03	; 3
    1fbc:	af 2e       	mov	r10, r31
    1fbe:	f0 2d       	mov	r31, r0
    1fc0:	bb 24       	eor	r11, r11
    1fc2:	cc 24       	eor	r12, r12
    1fc4:	dd 24       	eor	r13, r13
    1fc6:	ee 24       	eor	r14, r14
    1fc8:	ff 24       	eor	r15, r15
    1fca:	00 e0       	ldi	r16, 0x00	; 0
    1fcc:	10 e0       	ldi	r17, 0x00	; 0
    1fce:	0e 94 99 55 	call	0xab32	; 0xab32 <__divdi3>
    1fd2:	a2 2e       	mov	r10, r18
    1fd4:	b3 2e       	mov	r11, r19
    1fd6:	c4 2e       	mov	r12, r20
    1fd8:	d5 2e       	mov	r13, r21
    1fda:	e6 2e       	mov	r14, r22
    1fdc:	f7 2e       	mov	r15, r23
    1fde:	08 2f       	mov	r16, r24
    1fe0:	19 2f       	mov	r17, r25
    1fe2:	2a 2d       	mov	r18, r10
    1fe4:	3b 2d       	mov	r19, r11
    1fe6:	4c 2d       	mov	r20, r12
    1fe8:	5d 2d       	mov	r21, r13
    1fea:	6e 2d       	mov	r22, r14
    1fec:	7f 2d       	mov	r23, r15
    1fee:	80 2f       	mov	r24, r16
    1ff0:	91 2f       	mov	r25, r17
    1ff2:	da 01       	movw	r26, r20
    1ff4:	c9 01       	movw	r24, r18
    1ff6:	b0 95       	com	r27
    1ff8:	a0 95       	com	r26
    1ffa:	90 95       	com	r25
    1ffc:	81 95       	neg	r24
    1ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    2000:	af 4f       	sbci	r26, 0xFF	; 255
    2002:	bf 4f       	sbci	r27, 0xFF	; 255
    2004:	ea 81       	ldd	r30, Y+2	; 0x02
    2006:	fb 81       	ldd	r31, Y+3	; 0x03
    2008:	80 83       	st	Z, r24
    200a:	91 83       	std	Z+1, r25	; 0x01
    200c:	a2 83       	std	Z+2, r26	; 0x02
    200e:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    2010:	80 91 61 50 	lds	r24, 0x5061
    2014:	90 91 62 50 	lds	r25, 0x5062
    2018:	01 96       	adiw	r24, 0x01	; 1
    201a:	80 93 61 50 	sts	0x5061, r24
    201e:	90 93 62 50 	sts	0x5062, r25
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    2022:	80 91 61 50 	lds	r24, 0x5061
    2026:	90 91 62 50 	lds	r25, 0x5062
    202a:	8e 31       	cpi	r24, 0x1E	; 30
    202c:	91 05       	cpc	r25, r1
    202e:	a0 f1       	brcs	.+104    	; 0x2098 <__vector_105+0x35c>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    2030:	10 92 61 50 	sts	0x5061, r1
    2034:	10 92 62 50 	sts	0x5062, r1
		TotalSampleCount++;
    2038:	80 91 8f 50 	lds	r24, 0x508F
    203c:	90 91 90 50 	lds	r25, 0x5090
    2040:	01 96       	adiw	r24, 0x01	; 1
    2042:	80 93 8f 50 	sts	0x508F, r24
    2046:	90 93 90 50 	sts	0x5090, r25
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove(FRAMReadBuffer+1,FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    204a:	80 91 61 50 	lds	r24, 0x5061
    204e:	90 91 62 50 	lds	r25, 0x5062
    2052:	9c 01       	movw	r18, r24
    2054:	22 0f       	add	r18, r18
    2056:	33 1f       	adc	r19, r19
    2058:	22 0f       	add	r18, r18
    205a:	33 1f       	adc	r19, r19
    205c:	8f ec       	ldi	r24, 0xCF	; 207
    205e:	93 e2       	ldi	r25, 0x23	; 35
    2060:	4e ec       	ldi	r20, 0xCE	; 206
    2062:	53 e2       	ldi	r21, 0x23	; 35
    2064:	ba 01       	movw	r22, r20
    2066:	a9 01       	movw	r20, r18
    2068:	0e 94 84 5f 	call	0xbf08	; 0xbf08 <memcpy>
		FRAMReadBuffer[0] = moteID;
    206c:	80 91 d0 50 	lds	r24, 0x50D0
    2070:	80 93 ce 23 	sts	0x23CE, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+1);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    2074:	80 91 61 50 	lds	r24, 0x5061
    2078:	90 91 62 50 	lds	r25, 0x5062
    207c:	88 0f       	add	r24, r24
    207e:	99 1f       	adc	r25, r25
    2080:	88 0f       	add	r24, r24
    2082:	99 1f       	adc	r25, r25
    2084:	01 96       	adiw	r24, 0x01	; 1
    2086:	9c 01       	movw	r18, r24
    2088:	40 e0       	ldi	r20, 0x00	; 0
    208a:	50 e0       	ldi	r21, 0x00	; 0
    208c:	6e ec       	ldi	r22, 0xCE	; 206
    208e:	73 e2       	ldi	r23, 0x23	; 35
    2090:	80 e0       	ldi	r24, 0x00	; 0
    2092:	90 e0       	ldi	r25, 0x00	; 0
    2094:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_write>
	}	
	}	
}
    2098:	23 96       	adiw	r28, 0x03	; 3
    209a:	cd bf       	out	0x3d, r28	; 61
    209c:	de bf       	out	0x3e, r29	; 62
    209e:	df 91       	pop	r29
    20a0:	cf 91       	pop	r28
    20a2:	ff 91       	pop	r31
    20a4:	ef 91       	pop	r30
    20a6:	bf 91       	pop	r27
    20a8:	af 91       	pop	r26
    20aa:	9f 91       	pop	r25
    20ac:	8f 91       	pop	r24
    20ae:	7f 91       	pop	r23
    20b0:	6f 91       	pop	r22
    20b2:	5f 91       	pop	r21
    20b4:	4f 91       	pop	r20
    20b6:	3f 91       	pop	r19
    20b8:	2f 91       	pop	r18
    20ba:	1f 91       	pop	r17
    20bc:	0f 91       	pop	r16
    20be:	ff 90       	pop	r15
    20c0:	ef 90       	pop	r14
    20c2:	df 90       	pop	r13
    20c4:	cf 90       	pop	r12
    20c6:	bf 90       	pop	r11
    20c8:	af 90       	pop	r10
    20ca:	9f 90       	pop	r9
    20cc:	8f 90       	pop	r8
    20ce:	7f 90       	pop	r7
    20d0:	6f 90       	pop	r6
    20d2:	5f 90       	pop	r5
    20d4:	4f 90       	pop	r4
    20d6:	3f 90       	pop	r3
    20d8:	2f 90       	pop	r2
    20da:	0f 90       	pop	r0
    20dc:	00 92 3b 00 	sts	0x003B, r0
    20e0:	0f 90       	pop	r0
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	0f 90       	pop	r0
    20e6:	1f 90       	pop	r1
    20e8:	18 95       	reti

000020ea <__vector_104>:

ISR(PORTF_INT0_vect) {
    20ea:	1f 92       	push	r1
    20ec:	0f 92       	push	r0
    20ee:	0f b6       	in	r0, 0x3f	; 63
    20f0:	0f 92       	push	r0
    20f2:	00 90 3b 00 	lds	r0, 0x003B
    20f6:	0f 92       	push	r0
    20f8:	11 24       	eor	r1, r1
    20fa:	2f 93       	push	r18
    20fc:	3f 93       	push	r19
    20fe:	4f 93       	push	r20
    2100:	5f 93       	push	r21
    2102:	6f 93       	push	r22
    2104:	7f 93       	push	r23
    2106:	8f 93       	push	r24
    2108:	9f 93       	push	r25
    210a:	af 93       	push	r26
    210c:	bf 93       	push	r27
    210e:	ef 93       	push	r30
    2110:	ff 93       	push	r31
    2112:	cf 93       	push	r28
    2114:	df 93       	push	r29
    2116:	0f 92       	push	r0
    2118:	cd b7       	in	r28, 0x3d	; 61
    211a:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    211c:	80 91 4c 40 	lds	r24, 0x404C
    2120:	88 23       	and	r24, r24
    2122:	34 f0       	brlt	.+12     	; 0x2130 <__vector_104+0x46>
		discardCount++;
    2124:	80 91 4c 40 	lds	r24, 0x404C
    2128:	8f 5f       	subi	r24, 0xFF	; 255
    212a:	80 93 4c 40 	sts	0x404C, r24
    212e:	84 c0       	rjmp	.+264    	; 0x2238 <__vector_104+0x14e>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    2130:	81 e0       	ldi	r24, 0x01	; 1
    2132:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2136:	80 ea       	ldi	r24, 0xA0	; 160
    2138:	96 e0       	ldi	r25, 0x06	; 6
    213a:	22 e0       	ldi	r18, 0x02	; 2
    213c:	fc 01       	movw	r30, r24
    213e:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    2140:	19 82       	std	Y+1, r1	; 0x01
    2142:	1a c0       	rjmp	.+52     	; 0x2178 <__vector_104+0x8e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2144:	80 ec       	ldi	r24, 0xC0	; 192
    2146:	98 e0       	ldi	r25, 0x08	; 8
    2148:	2a ea       	ldi	r18, 0xAA	; 170
    214a:	fc 01       	movw	r30, r24
    214c:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    214e:	00 00       	nop
    2150:	80 ec       	ldi	r24, 0xC0	; 192
    2152:	98 e0       	ldi	r25, 0x08	; 8
    2154:	fc 01       	movw	r30, r24
    2156:	82 81       	ldd	r24, Z+2	; 0x02
    2158:	88 23       	and	r24, r24
    215a:	d4 f7       	brge	.-12     	; 0x2150 <__vector_104+0x66>
			SPIBuffer[bufIndex] = SPIC.DATA;
    215c:	89 81       	ldd	r24, Y+1	; 0x01
    215e:	88 2f       	mov	r24, r24
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	20 ec       	ldi	r18, 0xC0	; 192
    2164:	38 e0       	ldi	r19, 0x08	; 8
    2166:	f9 01       	movw	r30, r18
    2168:	23 81       	ldd	r18, Z+3	; 0x03
    216a:	8c 5a       	subi	r24, 0xAC	; 172
    216c:	9f 4a       	sbci	r25, 0xAF	; 175
    216e:	fc 01       	movw	r30, r24
    2170:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    2172:	89 81       	ldd	r24, Y+1	; 0x01
    2174:	8f 5f       	subi	r24, 0xFF	; 255
    2176:	89 83       	std	Y+1, r24	; 0x01
    2178:	89 81       	ldd	r24, Y+1	; 0x01
    217a:	83 30       	cpi	r24, 0x03	; 3
    217c:	18 f3       	brcs	.-58     	; 0x2144 <__vector_104+0x5a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    217e:	80 ea       	ldi	r24, 0xA0	; 160
    2180:	96 e0       	ldi	r25, 0x06	; 6
    2182:	22 e0       	ldi	r18, 0x02	; 2
    2184:	fc 01       	movw	r30, r24
    2186:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    2188:	80 e0       	ldi	r24, 0x00	; 0
    218a:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    218e:	80 91 54 50 	lds	r24, 0x5054
    2192:	88 23       	and	r24, r24
    2194:	7c f4       	brge	.+30     	; 0x21b4 <__vector_104+0xca>
    2196:	80 91 61 50 	lds	r24, 0x5061
    219a:	90 91 62 50 	lds	r25, 0x5062
    219e:	88 0f       	add	r24, r24
    21a0:	99 1f       	adc	r25, r25
    21a2:	88 0f       	add	r24, r24
    21a4:	99 1f       	adc	r25, r25
    21a6:	03 96       	adiw	r24, 0x03	; 3
    21a8:	8e 5a       	subi	r24, 0xAE	; 174
    21aa:	9f 4b       	sbci	r25, 0xBF	; 191
    21ac:	2f ef       	ldi	r18, 0xFF	; 255
    21ae:	fc 01       	movw	r30, r24
    21b0:	20 83       	st	Z, r18
    21b2:	0d c0       	rjmp	.+26     	; 0x21ce <__vector_104+0xe4>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    21b4:	80 91 61 50 	lds	r24, 0x5061
    21b8:	90 91 62 50 	lds	r25, 0x5062
    21bc:	88 0f       	add	r24, r24
    21be:	99 1f       	adc	r25, r25
    21c0:	88 0f       	add	r24, r24
    21c2:	99 1f       	adc	r25, r25
    21c4:	03 96       	adiw	r24, 0x03	; 3
    21c6:	8e 5a       	subi	r24, 0xAE	; 174
    21c8:	9f 4b       	sbci	r25, 0xBF	; 191
    21ca:	fc 01       	movw	r30, r24
    21cc:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    21ce:	80 91 61 50 	lds	r24, 0x5061
    21d2:	90 91 62 50 	lds	r25, 0x5062
    21d6:	88 0f       	add	r24, r24
    21d8:	99 1f       	adc	r25, r25
    21da:	88 0f       	add	r24, r24
    21dc:	99 1f       	adc	r25, r25
    21de:	02 96       	adiw	r24, 0x02	; 2
    21e0:	8e 5a       	subi	r24, 0xAE	; 174
    21e2:	9f 4b       	sbci	r25, 0xBF	; 191
    21e4:	20 91 54 50 	lds	r18, 0x5054
    21e8:	fc 01       	movw	r30, r24
    21ea:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    21ec:	80 91 61 50 	lds	r24, 0x5061
    21f0:	90 91 62 50 	lds	r25, 0x5062
    21f4:	88 0f       	add	r24, r24
    21f6:	99 1f       	adc	r25, r25
    21f8:	88 0f       	add	r24, r24
    21fa:	99 1f       	adc	r25, r25
    21fc:	01 96       	adiw	r24, 0x01	; 1
    21fe:	8e 5a       	subi	r24, 0xAE	; 174
    2200:	9f 4b       	sbci	r25, 0xBF	; 191
    2202:	20 91 55 50 	lds	r18, 0x5055
    2206:	fc 01       	movw	r30, r24
    2208:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    220a:	80 91 61 50 	lds	r24, 0x5061
    220e:	90 91 62 50 	lds	r25, 0x5062
    2212:	88 0f       	add	r24, r24
    2214:	99 1f       	adc	r25, r25
    2216:	88 0f       	add	r24, r24
    2218:	99 1f       	adc	r25, r25
    221a:	8e 5a       	subi	r24, 0xAE	; 174
    221c:	9f 4b       	sbci	r25, 0xBF	; 191
    221e:	20 91 56 50 	lds	r18, 0x5056
    2222:	fc 01       	movw	r30, r24
    2224:	20 83       	st	Z, r18

		sampleCount++;
    2226:	80 91 61 50 	lds	r24, 0x5061
    222a:	90 91 62 50 	lds	r25, 0x5062
    222e:	01 96       	adiw	r24, 0x01	; 1
    2230:	80 93 61 50 	sts	0x5061, r24
    2234:	90 93 62 50 	sts	0x5062, r25
	}
}
    2238:	0f 90       	pop	r0
    223a:	df 91       	pop	r29
    223c:	cf 91       	pop	r28
    223e:	ff 91       	pop	r31
    2240:	ef 91       	pop	r30
    2242:	bf 91       	pop	r27
    2244:	af 91       	pop	r26
    2246:	9f 91       	pop	r25
    2248:	8f 91       	pop	r24
    224a:	7f 91       	pop	r23
    224c:	6f 91       	pop	r22
    224e:	5f 91       	pop	r21
    2250:	4f 91       	pop	r20
    2252:	3f 91       	pop	r19
    2254:	2f 91       	pop	r18
    2256:	0f 90       	pop	r0
    2258:	00 92 3b 00 	sts	0x003B, r0
    225c:	0f 90       	pop	r0
    225e:	0f be       	out	0x3f, r0	; 63
    2260:	0f 90       	pop	r0
    2262:	1f 90       	pop	r1
    2264:	18 95       	reti

00002266 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    2266:	cf 93       	push	r28
    2268:	df 93       	push	r29
    226a:	0f 92       	push	r0
    226c:	cd b7       	in	r28, 0x3d	; 61
    226e:	de b7       	in	r29, 0x3e	; 62
    2270:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    2272:	89 81       	ldd	r24, Y+1	; 0x01
    2274:	88 23       	and	r24, r24
    2276:	49 f0       	breq	.+18     	; 0x228a <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    2278:	80 e2       	ldi	r24, 0x20	; 32
    227a:	60 e0       	ldi	r22, 0x00	; 0
    227c:	0e 94 1f 35 	call	0x6a3e	; 0x6a3e <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    2280:	80 e2       	ldi	r24, 0x20	; 32
    2282:	60 e0       	ldi	r22, 0x00	; 0
    2284:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
    2288:	04 c0       	rjmp	.+8      	; 0x2292 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    228a:	80 e2       	ldi	r24, 0x20	; 32
    228c:	60 e0       	ldi	r22, 0x00	; 0
    228e:	0e 94 83 35 	call	0x6b06	; 0x6b06 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    2292:	0f 90       	pop	r0
    2294:	df 91       	pop	r29
    2296:	cf 91       	pop	r28
    2298:	08 95       	ret

0000229a <CO_collectSeismic3Channel>:

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    229a:	8f 92       	push	r8
    229c:	9f 92       	push	r9
    229e:	af 92       	push	r10
    22a0:	bf 92       	push	r11
    22a2:	cf 92       	push	r12
    22a4:	df 92       	push	r13
    22a6:	ef 92       	push	r14
    22a8:	ff 92       	push	r15
    22aa:	0f 93       	push	r16
    22ac:	cf 93       	push	r28
    22ae:	df 93       	push	r29
    22b0:	cd b7       	in	r28, 0x3d	; 61
    22b2:	de b7       	in	r29, 0x3e	; 62
    22b4:	2e 97       	sbiw	r28, 0x0e	; 14
    22b6:	cd bf       	out	0x3d, r28	; 61
    22b8:	de bf       	out	0x3e, r29	; 62
    22ba:	89 83       	std	Y+1, r24	; 0x01
    22bc:	6a 83       	std	Y+2, r22	; 0x02
    22be:	7b 83       	std	Y+3, r23	; 0x03
    22c0:	4c 83       	std	Y+4, r20	; 0x04
    22c2:	2d 83       	std	Y+5, r18	; 0x05
    22c4:	0e 83       	std	Y+6, r16	; 0x06
    22c6:	ef 82       	std	Y+7, r14	; 0x07
    22c8:	f8 86       	std	Y+8, r15	; 0x08
    22ca:	c9 86       	std	Y+9, r12	; 0x09
    22cc:	da 86       	std	Y+10, r13	; 0x0a
    22ce:	ab 86       	std	Y+11, r10	; 0x0b
    22d0:	bc 86       	std	Y+12, r11	; 0x0c
    22d2:	8d 86       	std	Y+13, r8	; 0x0d
    22d4:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    22d6:	81 e0       	ldi	r24, 0x01	; 1
    22d8:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    22dc:	8a 81       	ldd	r24, Y+2	; 0x02
    22de:	9b 81       	ldd	r25, Y+3	; 0x03
    22e0:	fc 01       	movw	r30, r24
    22e2:	90 81       	ld	r25, Z
    22e4:	85 e0       	ldi	r24, 0x05	; 5
    22e6:	69 2f       	mov	r22, r25
    22e8:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    22ec:	8a 81       	ldd	r24, Y+2	; 0x02
    22ee:	9b 81       	ldd	r25, Y+3	; 0x03
    22f0:	01 96       	adiw	r24, 0x01	; 1
    22f2:	fc 01       	movw	r30, r24
    22f4:	90 81       	ld	r25, Z
    22f6:	86 e0       	ldi	r24, 0x06	; 6
    22f8:	69 2f       	mov	r22, r25
    22fa:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    22fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2300:	9b 81       	ldd	r25, Y+3	; 0x03
    2302:	02 96       	adiw	r24, 0x02	; 2
    2304:	fc 01       	movw	r30, r24
    2306:	90 81       	ld	r25, Z
    2308:	87 e0       	ldi	r24, 0x07	; 7
    230a:	69 2f       	mov	r22, r25
    230c:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_filter(filterConfig);
    2310:	89 81       	ldd	r24, Y+1	; 0x01
    2312:	0e 94 59 08 	call	0x10b2	; 0x10b2 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2316:	8e 81       	ldd	r24, Y+6	; 0x06
    2318:	0e 94 33 11 	call	0x2266	; 0x2266 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    231c:	84 e0       	ldi	r24, 0x04	; 4
    231e:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2322:	80 ec       	ldi	r24, 0xC0	; 192
    2324:	98 e0       	ldi	r25, 0x08	; 8
    2326:	24 e5       	ldi	r18, 0x54	; 84
    2328:	fc 01       	movw	r30, r24
    232a:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    232c:	81 e0       	ldi	r24, 0x01	; 1
    232e:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2332:	85 e0       	ldi	r24, 0x05	; 5
    2334:	0e 94 5f 1c 	call	0x38be	; 0x38be <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2338:	80 ea       	ldi	r24, 0xA0	; 160
    233a:	96 e0       	ldi	r25, 0x06	; 6
    233c:	22 e0       	ldi	r18, 0x02	; 2
    233e:	fc 01       	movw	r30, r24
    2340:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2342:	80 ea       	ldi	r24, 0xA0	; 160
    2344:	96 e0       	ldi	r25, 0x06	; 6
    2346:	21 e0       	ldi	r18, 0x01	; 1
    2348:	fc 01       	movw	r30, r24
    234a:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    234c:	80 e8       	ldi	r24, 0x80	; 128
    234e:	91 e0       	ldi	r25, 0x01	; 1
    2350:	28 e7       	ldi	r18, 0x78	; 120
    2352:	fc 01       	movw	r30, r24
    2354:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2356:	80 e0       	ldi	r24, 0x00	; 0
    2358:	98 e0       	ldi	r25, 0x08	; 8
    235a:	20 ef       	ldi	r18, 0xF0	; 240
    235c:	fc 01       	movw	r30, r24
    235e:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    2360:	80 e0       	ldi	r24, 0x00	; 0
    2362:	98 e0       	ldi	r25, 0x08	; 8
    2364:	2f 81       	ldd	r18, Y+7	; 0x07
    2366:	38 85       	ldd	r19, Y+8	; 0x08
    2368:	fc 01       	movw	r30, r24
    236a:	20 a7       	lds	r18, 0x70
    236c:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    236e:	80 e0       	ldi	r24, 0x00	; 0
    2370:	98 e0       	ldi	r25, 0x08	; 8
    2372:	29 85       	ldd	r18, Y+9	; 0x09
    2374:	3a 85       	ldd	r19, Y+10	; 0x0a
    2376:	fc 01       	movw	r30, r24
    2378:	22 a7       	lds	r18, 0x72
    237a:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    237c:	80 e0       	ldi	r24, 0x00	; 0
    237e:	98 e0       	ldi	r25, 0x08	; 8
    2380:	2b 85       	ldd	r18, Y+11	; 0x0b
    2382:	3c 85       	ldd	r19, Y+12	; 0x0c
    2384:	fc 01       	movw	r30, r24
    2386:	24 a7       	lds	r18, 0x74
    2388:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    238a:	80 e0       	ldi	r24, 0x00	; 0
    238c:	98 e0       	ldi	r25, 0x08	; 8
    238e:	2d 85       	ldd	r18, Y+13	; 0x0d
    2390:	3e 85       	ldd	r19, Y+14	; 0x0e
    2392:	fc 01       	movw	r30, r24
    2394:	26 a7       	lds	r18, 0x76
    2396:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	98 e0       	ldi	r25, 0x08	; 8
    239c:	2d 81       	ldd	r18, Y+5	; 0x05
    239e:	22 2f       	mov	r18, r18
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	21 50       	subi	r18, 0x01	; 1
    23a4:	30 40       	sbci	r19, 0x00	; 0
    23a6:	fc 01       	movw	r30, r24
    23a8:	26 a3       	lds	r18, 0x56
    23aa:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    23ac:	80 e0       	ldi	r24, 0x00	; 0
    23ae:	98 e0       	ldi	r25, 0x08	; 8
    23b0:	22 e0       	ldi	r18, 0x02	; 2
    23b2:	fc 01       	movw	r30, r24
    23b4:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    23b6:	80 e0       	ldi	r24, 0x00	; 0
    23b8:	98 e0       	ldi	r25, 0x08	; 8
    23ba:	2f ef       	ldi	r18, 0xFF	; 255
    23bc:	fc 01       	movw	r30, r24
    23be:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    23c0:	80 e0       	ldi	r24, 0x00	; 0
    23c2:	98 e0       	ldi	r25, 0x08	; 8
    23c4:	20 e0       	ldi	r18, 0x00	; 0
    23c6:	38 e0       	ldi	r19, 0x08	; 8
    23c8:	f9 01       	movw	r30, r18
    23ca:	20 81       	ld	r18, Z
    23cc:	20 7f       	andi	r18, 0xF0	; 240
    23ce:	28 60       	ori	r18, 0x08	; 8
    23d0:	fc 01       	movw	r30, r24
    23d2:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    23d4:	10 92 46 40 	sts	0x4046, r1
    23d8:	10 92 47 40 	sts	0x4047, r1
	sampleCount = 0;
    23dc:	10 92 61 50 	sts	0x5061, r1
    23e0:	10 92 62 50 	sts	0x5062, r1
	SPICount = 0;
    23e4:	10 92 ce 50 	sts	0x50CE, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    23e8:	80 e0       	ldi	r24, 0x00	; 0
    23ea:	80 93 2a 21 	sts	0x212A, r24
    23ee:	80 93 29 21 	sts	0x2129, r24
    23f2:	80 93 28 21 	sts	0x2128, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    23f6:	80 ea       	ldi	r24, 0xA0	; 160
    23f8:	90 e0       	ldi	r25, 0x00	; 0
    23fa:	20 ea       	ldi	r18, 0xA0	; 160
    23fc:	30 e0       	ldi	r19, 0x00	; 0
    23fe:	f9 01       	movw	r30, r18
    2400:	22 81       	ldd	r18, Z+2	; 0x02
    2402:	26 60       	ori	r18, 0x06	; 6
    2404:	fc 01       	movw	r30, r24
    2406:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2408:	78 94       	sei

	SPICS(TRUE);
    240a:	81 e0       	ldi	r24, 0x01	; 1
    240c:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2410:	80 e8       	ldi	r24, 0x80	; 128
    2412:	96 e0       	ldi	r25, 0x06	; 6
    2414:	20 e2       	ldi	r18, 0x20	; 32
    2416:	fc 01       	movw	r30, r24
    2418:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    241a:	80 e4       	ldi	r24, 0x40	; 64
    241c:	9a e0       	ldi	r25, 0x0A	; 10
    241e:	23 e2       	ldi	r18, 0x23	; 35
    2420:	fc 01       	movw	r30, r24
    2422:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2424:	80 e4       	ldi	r24, 0x40	; 64
    2426:	9a e0       	ldi	r25, 0x0A	; 10
    2428:	2c 81       	ldd	r18, Y+4	; 0x04
    242a:	42 2f       	mov	r20, r18
    242c:	50 e0       	ldi	r21, 0x00	; 0
    242e:	20 e2       	ldi	r18, 0x20	; 32
    2430:	30 e0       	ldi	r19, 0x00	; 0
    2432:	02 c0       	rjmp	.+4      	; 0x2438 <CO_collectSeismic3Channel+0x19e>
    2434:	22 0f       	add	r18, r18
    2436:	33 1f       	adc	r19, r19
    2438:	4a 95       	dec	r20
    243a:	e2 f7       	brpl	.-8      	; 0x2434 <CO_collectSeismic3Channel+0x19a>
    243c:	fc 01       	movw	r30, r24
    243e:	26 a3       	lds	r18, 0x56
    2440:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2442:	80 e4       	ldi	r24, 0x40	; 64
    2444:	9a e0       	ldi	r25, 0x0A	; 10
    2446:	2c 81       	ldd	r18, Y+4	; 0x04
    2448:	42 2f       	mov	r20, r18
    244a:	50 e0       	ldi	r21, 0x00	; 0
    244c:	20 e1       	ldi	r18, 0x10	; 16
    244e:	30 e0       	ldi	r19, 0x00	; 0
    2450:	04 2e       	mov	r0, r20
    2452:	02 c0       	rjmp	.+4      	; 0x2458 <CO_collectSeismic3Channel+0x1be>
    2454:	22 0f       	add	r18, r18
    2456:	33 1f       	adc	r19, r19
    2458:	0a 94       	dec	r0
    245a:	e2 f7       	brpl	.-8      	; 0x2454 <CO_collectSeismic3Channel+0x1ba>
    245c:	fc 01       	movw	r30, r24
    245e:	22 af       	sts	0x72, r18
    2460:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2462:	80 e4       	ldi	r24, 0x40	; 64
    2464:	9a e0       	ldi	r25, 0x0A	; 10
    2466:	20 e4       	ldi	r18, 0x40	; 64
    2468:	3a e0       	ldi	r19, 0x0A	; 10
    246a:	f9 01       	movw	r30, r18
    246c:	20 81       	ld	r18, Z
    246e:	20 7f       	andi	r18, 0xF0	; 240
    2470:	21 60       	ori	r18, 0x01	; 1
    2472:	fc 01       	movw	r30, r24
    2474:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2476:	00 00       	nop
    2478:	80 91 61 50 	lds	r24, 0x5061
    247c:	90 91 62 50 	lds	r25, 0x5062
    2480:	f5 e5       	ldi	r31, 0x55	; 85
    2482:	83 35       	cpi	r24, 0x53	; 83
    2484:	9f 07       	cpc	r25, r31
    2486:	c0 f3       	brcs	.-16     	; 0x2478 <CO_collectSeismic3Channel+0x1de>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2488:	80 e0       	ldi	r24, 0x00	; 0
    248a:	98 e0       	ldi	r25, 0x08	; 8
    248c:	20 e0       	ldi	r18, 0x00	; 0
    248e:	38 e0       	ldi	r19, 0x08	; 8
    2490:	f9 01       	movw	r30, r18
    2492:	20 81       	ld	r18, Z
    2494:	20 7f       	andi	r18, 0xF0	; 240
    2496:	fc 01       	movw	r30, r24
    2498:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    249a:	80 e4       	ldi	r24, 0x40	; 64
    249c:	9a e0       	ldi	r25, 0x0A	; 10
    249e:	20 e4       	ldi	r18, 0x40	; 64
    24a0:	3a e0       	ldi	r19, 0x0A	; 10
    24a2:	f9 01       	movw	r30, r18
    24a4:	20 81       	ld	r18, Z
    24a6:	20 7f       	andi	r18, 0xF0	; 240
    24a8:	fc 01       	movw	r30, r24
    24aa:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    24ac:	80 ea       	ldi	r24, 0xA0	; 160
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	20 ea       	ldi	r18, 0xA0	; 160
    24b2:	30 e0       	ldi	r19, 0x00	; 0
    24b4:	f9 01       	movw	r30, r18
    24b6:	22 81       	ldd	r18, Z+2	; 0x02
    24b8:	29 7f       	andi	r18, 0xF9	; 249
    24ba:	fc 01       	movw	r30, r24
    24bc:	22 83       	std	Z+2, r18	; 0x02
	cli();
    24be:	f8 94       	cli

	SPICS(FALSE);
    24c0:	80 e0       	ldi	r24, 0x00	; 0
    24c2:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    24c6:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	enableADCMUX(FALSE);
    24ca:	80 e0       	ldi	r24, 0x00	; 0
    24cc:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
	ADCPower(FALSE);
    24d0:	80 e0       	ldi	r24, 0x00	; 0
    24d2:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	
}
    24d6:	2e 96       	adiw	r28, 0x0e	; 14
    24d8:	cd bf       	out	0x3d, r28	; 61
    24da:	de bf       	out	0x3e, r29	; 62
    24dc:	df 91       	pop	r29
    24de:	cf 91       	pop	r28
    24e0:	0f 91       	pop	r16
    24e2:	ff 90       	pop	r15
    24e4:	ef 90       	pop	r14
    24e6:	df 90       	pop	r13
    24e8:	cf 90       	pop	r12
    24ea:	bf 90       	pop	r11
    24ec:	af 90       	pop	r10
    24ee:	9f 90       	pop	r9
    24f0:	8f 90       	pop	r8
    24f2:	08 95       	ret

000024f4 <CO_collectSeismic3Channel_continuous>:

void CO_collectSeismic3Channel_continuous(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    24f4:	8f 92       	push	r8
    24f6:	9f 92       	push	r9
    24f8:	af 92       	push	r10
    24fa:	bf 92       	push	r11
    24fc:	cf 92       	push	r12
    24fe:	df 92       	push	r13
    2500:	ef 92       	push	r14
    2502:	ff 92       	push	r15
    2504:	0f 93       	push	r16
    2506:	cf 93       	push	r28
    2508:	df 93       	push	r29
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	2e 97       	sbiw	r28, 0x0e	; 14
    2510:	cd bf       	out	0x3d, r28	; 61
    2512:	de bf       	out	0x3e, r29	; 62
    2514:	89 83       	std	Y+1, r24	; 0x01
    2516:	6a 83       	std	Y+2, r22	; 0x02
    2518:	7b 83       	std	Y+3, r23	; 0x03
    251a:	4c 83       	std	Y+4, r20	; 0x04
    251c:	2d 83       	std	Y+5, r18	; 0x05
    251e:	0e 83       	std	Y+6, r16	; 0x06
    2520:	ef 82       	std	Y+7, r14	; 0x07
    2522:	f8 86       	std	Y+8, r15	; 0x08
    2524:	c9 86       	std	Y+9, r12	; 0x09
    2526:	da 86       	std	Y+10, r13	; 0x0a
    2528:	ab 86       	std	Y+11, r10	; 0x0b
    252a:	bc 86       	std	Y+12, r11	; 0x0c
    252c:	8d 86       	std	Y+13, r8	; 0x0d
    252e:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2530:	81 e0       	ldi	r24, 0x01	; 1
    2532:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2536:	8a 81       	ldd	r24, Y+2	; 0x02
    2538:	9b 81       	ldd	r25, Y+3	; 0x03
    253a:	fc 01       	movw	r30, r24
    253c:	90 81       	ld	r25, Z
    253e:	85 e0       	ldi	r24, 0x05	; 5
    2540:	69 2f       	mov	r22, r25
    2542:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2546:	8a 81       	ldd	r24, Y+2	; 0x02
    2548:	9b 81       	ldd	r25, Y+3	; 0x03
    254a:	01 96       	adiw	r24, 0x01	; 1
    254c:	fc 01       	movw	r30, r24
    254e:	90 81       	ld	r25, Z
    2550:	86 e0       	ldi	r24, 0x06	; 6
    2552:	69 2f       	mov	r22, r25
    2554:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2558:	8a 81       	ldd	r24, Y+2	; 0x02
    255a:	9b 81       	ldd	r25, Y+3	; 0x03
    255c:	02 96       	adiw	r24, 0x02	; 2
    255e:	fc 01       	movw	r30, r24
    2560:	90 81       	ld	r25, Z
    2562:	87 e0       	ldi	r24, 0x07	; 7
    2564:	69 2f       	mov	r22, r25
    2566:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_filter(filterConfig);
    256a:	89 81       	ldd	r24, Y+1	; 0x01
    256c:	0e 94 59 08 	call	0x10b2	; 0x10b2 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2570:	8e 81       	ldd	r24, Y+6	; 0x06
    2572:	0e 94 33 11 	call	0x2266	; 0x2266 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2576:	84 e0       	ldi	r24, 0x04	; 4
    2578:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    257c:	80 ec       	ldi	r24, 0xC0	; 192
    257e:	98 e0       	ldi	r25, 0x08	; 8
    2580:	24 e5       	ldi	r18, 0x54	; 84
    2582:	fc 01       	movw	r30, r24
    2584:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2586:	81 e0       	ldi	r24, 0x01	; 1
    2588:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    258c:	85 e0       	ldi	r24, 0x05	; 5
    258e:	0e 94 5f 1c 	call	0x38be	; 0x38be <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2592:	80 ea       	ldi	r24, 0xA0	; 160
    2594:	96 e0       	ldi	r25, 0x06	; 6
    2596:	22 e0       	ldi	r18, 0x02	; 2
    2598:	fc 01       	movw	r30, r24
    259a:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    259c:	80 ea       	ldi	r24, 0xA0	; 160
    259e:	96 e0       	ldi	r25, 0x06	; 6
    25a0:	21 e0       	ldi	r18, 0x01	; 1
    25a2:	fc 01       	movw	r30, r24
    25a4:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    25a6:	80 e8       	ldi	r24, 0x80	; 128
    25a8:	91 e0       	ldi	r25, 0x01	; 1
    25aa:	28 e7       	ldi	r18, 0x78	; 120
    25ac:	fc 01       	movw	r30, r24
    25ae:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    25b0:	80 e0       	ldi	r24, 0x00	; 0
    25b2:	98 e0       	ldi	r25, 0x08	; 8
    25b4:	20 ef       	ldi	r18, 0xF0	; 240
    25b6:	fc 01       	movw	r30, r24
    25b8:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    25ba:	80 e0       	ldi	r24, 0x00	; 0
    25bc:	98 e0       	ldi	r25, 0x08	; 8
    25be:	2f 81       	ldd	r18, Y+7	; 0x07
    25c0:	38 85       	ldd	r19, Y+8	; 0x08
    25c2:	fc 01       	movw	r30, r24
    25c4:	20 a7       	lds	r18, 0x70
    25c6:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    25c8:	80 e0       	ldi	r24, 0x00	; 0
    25ca:	98 e0       	ldi	r25, 0x08	; 8
    25cc:	29 85       	ldd	r18, Y+9	; 0x09
    25ce:	3a 85       	ldd	r19, Y+10	; 0x0a
    25d0:	fc 01       	movw	r30, r24
    25d2:	22 a7       	lds	r18, 0x72
    25d4:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    25d6:	80 e0       	ldi	r24, 0x00	; 0
    25d8:	98 e0       	ldi	r25, 0x08	; 8
    25da:	2b 85       	ldd	r18, Y+11	; 0x0b
    25dc:	3c 85       	ldd	r19, Y+12	; 0x0c
    25de:	fc 01       	movw	r30, r24
    25e0:	24 a7       	lds	r18, 0x74
    25e2:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    25e4:	80 e0       	ldi	r24, 0x00	; 0
    25e6:	98 e0       	ldi	r25, 0x08	; 8
    25e8:	2d 85       	ldd	r18, Y+13	; 0x0d
    25ea:	3e 85       	ldd	r19, Y+14	; 0x0e
    25ec:	fc 01       	movw	r30, r24
    25ee:	26 a7       	lds	r18, 0x76
    25f0:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    25f2:	80 e0       	ldi	r24, 0x00	; 0
    25f4:	98 e0       	ldi	r25, 0x08	; 8
    25f6:	2d 81       	ldd	r18, Y+5	; 0x05
    25f8:	22 2f       	mov	r18, r18
    25fa:	30 e0       	ldi	r19, 0x00	; 0
    25fc:	21 50       	subi	r18, 0x01	; 1
    25fe:	30 40       	sbci	r19, 0x00	; 0
    2600:	fc 01       	movw	r30, r24
    2602:	26 a3       	lds	r18, 0x56
    2604:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2606:	80 e0       	ldi	r24, 0x00	; 0
    2608:	98 e0       	ldi	r25, 0x08	; 8
    260a:	22 e0       	ldi	r18, 0x02	; 2
    260c:	fc 01       	movw	r30, r24
    260e:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2610:	80 e0       	ldi	r24, 0x00	; 0
    2612:	98 e0       	ldi	r25, 0x08	; 8
    2614:	2f ef       	ldi	r18, 0xFF	; 255
    2616:	fc 01       	movw	r30, r24
    2618:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    261a:	80 e0       	ldi	r24, 0x00	; 0
    261c:	98 e0       	ldi	r25, 0x08	; 8
    261e:	20 e0       	ldi	r18, 0x00	; 0
    2620:	38 e0       	ldi	r19, 0x08	; 8
    2622:	f9 01       	movw	r30, r18
    2624:	20 81       	ld	r18, Z
    2626:	20 7f       	andi	r18, 0xF0	; 240
    2628:	28 60       	ori	r18, 0x08	; 8
    262a:	fc 01       	movw	r30, r24
    262c:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    262e:	10 92 46 40 	sts	0x4046, r1
    2632:	10 92 47 40 	sts	0x4047, r1
	sampleCount = 0;
    2636:	10 92 61 50 	sts	0x5061, r1
    263a:	10 92 62 50 	sts	0x5062, r1
	SPICount = 0;
    263e:	10 92 ce 50 	sts	0x50CE, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2642:	80 e0       	ldi	r24, 0x00	; 0
    2644:	80 93 2a 21 	sts	0x212A, r24
    2648:	80 93 29 21 	sts	0x2129, r24
    264c:	80 93 28 21 	sts	0x2128, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2650:	80 ea       	ldi	r24, 0xA0	; 160
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	20 ea       	ldi	r18, 0xA0	; 160
    2656:	30 e0       	ldi	r19, 0x00	; 0
    2658:	f9 01       	movw	r30, r18
    265a:	22 81       	ldd	r18, Z+2	; 0x02
    265c:	26 60       	ori	r18, 0x06	; 6
    265e:	fc 01       	movw	r30, r24
    2660:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2662:	78 94       	sei

	SPICS(TRUE);
    2664:	81 e0       	ldi	r24, 0x01	; 1
    2666:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    266a:	80 e8       	ldi	r24, 0x80	; 128
    266c:	96 e0       	ldi	r25, 0x06	; 6
    266e:	20 e2       	ldi	r18, 0x20	; 32
    2670:	fc 01       	movw	r30, r24
    2672:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2674:	80 e4       	ldi	r24, 0x40	; 64
    2676:	9a e0       	ldi	r25, 0x0A	; 10
    2678:	23 e2       	ldi	r18, 0x23	; 35
    267a:	fc 01       	movw	r30, r24
    267c:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    267e:	80 e4       	ldi	r24, 0x40	; 64
    2680:	9a e0       	ldi	r25, 0x0A	; 10
    2682:	2c 81       	ldd	r18, Y+4	; 0x04
    2684:	42 2f       	mov	r20, r18
    2686:	50 e0       	ldi	r21, 0x00	; 0
    2688:	20 e2       	ldi	r18, 0x20	; 32
    268a:	30 e0       	ldi	r19, 0x00	; 0
    268c:	02 c0       	rjmp	.+4      	; 0x2692 <CO_collectSeismic3Channel_continuous+0x19e>
    268e:	22 0f       	add	r18, r18
    2690:	33 1f       	adc	r19, r19
    2692:	4a 95       	dec	r20
    2694:	e2 f7       	brpl	.-8      	; 0x268e <CO_collectSeismic3Channel_continuous+0x19a>
    2696:	fc 01       	movw	r30, r24
    2698:	26 a3       	lds	r18, 0x56
    269a:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    269c:	80 e4       	ldi	r24, 0x40	; 64
    269e:	9a e0       	ldi	r25, 0x0A	; 10
    26a0:	2c 81       	ldd	r18, Y+4	; 0x04
    26a2:	42 2f       	mov	r20, r18
    26a4:	50 e0       	ldi	r21, 0x00	; 0
    26a6:	20 e1       	ldi	r18, 0x10	; 16
    26a8:	30 e0       	ldi	r19, 0x00	; 0
    26aa:	04 2e       	mov	r0, r20
    26ac:	02 c0       	rjmp	.+4      	; 0x26b2 <CO_collectSeismic3Channel_continuous+0x1be>
    26ae:	22 0f       	add	r18, r18
    26b0:	33 1f       	adc	r19, r19
    26b2:	0a 94       	dec	r0
    26b4:	e2 f7       	brpl	.-8      	; 0x26ae <CO_collectSeismic3Channel_continuous+0x1ba>
    26b6:	fc 01       	movw	r30, r24
    26b8:	22 af       	sts	0x72, r18
    26ba:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    26bc:	80 e4       	ldi	r24, 0x40	; 64
    26be:	9a e0       	ldi	r25, 0x0A	; 10
    26c0:	20 e4       	ldi	r18, 0x40	; 64
    26c2:	3a e0       	ldi	r19, 0x0A	; 10
    26c4:	f9 01       	movw	r30, r18
    26c6:	20 81       	ld	r18, Z
    26c8:	20 7f       	andi	r18, 0xF0	; 240
    26ca:	21 60       	ori	r18, 0x01	; 1
    26cc:	fc 01       	movw	r30, r24
    26ce:	20 83       	st	Z, r18
	
	// collect samples from ADC continuously
	while(1){
		nop();
    26d0:	00 00       	nop
	}
    26d2:	fe cf       	rjmp	.-4      	; 0x26d0 <CO_collectSeismic3Channel_continuous+0x1dc>

000026d4 <__vector_16>:
}


ISR(TCC0_CCA_vect) {
    26d4:	1f 92       	push	r1
    26d6:	0f 92       	push	r0
    26d8:	0f b6       	in	r0, 0x3f	; 63
    26da:	0f 92       	push	r0
    26dc:	00 90 3b 00 	lds	r0, 0x003B
    26e0:	0f 92       	push	r0
    26e2:	11 24       	eor	r1, r1
    26e4:	2f 93       	push	r18
    26e6:	3f 93       	push	r19
    26e8:	4f 93       	push	r20
    26ea:	5f 93       	push	r21
    26ec:	6f 93       	push	r22
    26ee:	7f 93       	push	r23
    26f0:	8f 93       	push	r24
    26f2:	9f 93       	push	r25
    26f4:	af 93       	push	r26
    26f6:	bf 93       	push	r27
    26f8:	ef 93       	push	r30
    26fa:	ff 93       	push	r31
    26fc:	cf 93       	push	r28
    26fe:	df 93       	push	r29
    2700:	cd b7       	in	r28, 0x3d	; 61
    2702:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2704:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
}
    2708:	df 91       	pop	r29
    270a:	cf 91       	pop	r28
    270c:	ff 91       	pop	r31
    270e:	ef 91       	pop	r30
    2710:	bf 91       	pop	r27
    2712:	af 91       	pop	r26
    2714:	9f 91       	pop	r25
    2716:	8f 91       	pop	r24
    2718:	7f 91       	pop	r23
    271a:	6f 91       	pop	r22
    271c:	5f 91       	pop	r21
    271e:	4f 91       	pop	r20
    2720:	3f 91       	pop	r19
    2722:	2f 91       	pop	r18
    2724:	0f 90       	pop	r0
    2726:	00 92 3b 00 	sts	0x003B, r0
    272a:	0f 90       	pop	r0
    272c:	0f be       	out	0x3f, r0	; 63
    272e:	0f 90       	pop	r0
    2730:	1f 90       	pop	r1
    2732:	18 95       	reti

00002734 <__vector_17>:

ISR(TCC0_CCB_vect) {
    2734:	1f 92       	push	r1
    2736:	0f 92       	push	r0
    2738:	0f b6       	in	r0, 0x3f	; 63
    273a:	0f 92       	push	r0
    273c:	00 90 3b 00 	lds	r0, 0x003B
    2740:	0f 92       	push	r0
    2742:	11 24       	eor	r1, r1
    2744:	2f 93       	push	r18
    2746:	3f 93       	push	r19
    2748:	4f 93       	push	r20
    274a:	5f 93       	push	r21
    274c:	6f 93       	push	r22
    274e:	7f 93       	push	r23
    2750:	8f 93       	push	r24
    2752:	9f 93       	push	r25
    2754:	af 93       	push	r26
    2756:	bf 93       	push	r27
    2758:	ef 93       	push	r30
    275a:	ff 93       	push	r31
    275c:	cf 93       	push	r28
    275e:	df 93       	push	r29
    2760:	cd b7       	in	r28, 0x3d	; 61
    2762:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2764:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
}
    2768:	df 91       	pop	r29
    276a:	cf 91       	pop	r28
    276c:	ff 91       	pop	r31
    276e:	ef 91       	pop	r30
    2770:	bf 91       	pop	r27
    2772:	af 91       	pop	r26
    2774:	9f 91       	pop	r25
    2776:	8f 91       	pop	r24
    2778:	7f 91       	pop	r23
    277a:	6f 91       	pop	r22
    277c:	5f 91       	pop	r21
    277e:	4f 91       	pop	r20
    2780:	3f 91       	pop	r19
    2782:	2f 91       	pop	r18
    2784:	0f 90       	pop	r0
    2786:	00 92 3b 00 	sts	0x003B, r0
    278a:	0f 90       	pop	r0
    278c:	0f be       	out	0x3f, r0	; 63
    278e:	0f 90       	pop	r0
    2790:	1f 90       	pop	r1
    2792:	18 95       	reti

00002794 <__vector_18>:

ISR(TCC0_CCC_vect) {
    2794:	1f 92       	push	r1
    2796:	0f 92       	push	r0
    2798:	0f b6       	in	r0, 0x3f	; 63
    279a:	0f 92       	push	r0
    279c:	00 90 3b 00 	lds	r0, 0x003B
    27a0:	0f 92       	push	r0
    27a2:	11 24       	eor	r1, r1
    27a4:	2f 93       	push	r18
    27a6:	3f 93       	push	r19
    27a8:	4f 93       	push	r20
    27aa:	5f 93       	push	r21
    27ac:	6f 93       	push	r22
    27ae:	7f 93       	push	r23
    27b0:	8f 93       	push	r24
    27b2:	9f 93       	push	r25
    27b4:	af 93       	push	r26
    27b6:	bf 93       	push	r27
    27b8:	ef 93       	push	r30
    27ba:	ff 93       	push	r31
    27bc:	cf 93       	push	r28
    27be:	df 93       	push	r29
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    27c4:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
}
    27c8:	df 91       	pop	r29
    27ca:	cf 91       	pop	r28
    27cc:	ff 91       	pop	r31
    27ce:	ef 91       	pop	r30
    27d0:	bf 91       	pop	r27
    27d2:	af 91       	pop	r26
    27d4:	9f 91       	pop	r25
    27d6:	8f 91       	pop	r24
    27d8:	7f 91       	pop	r23
    27da:	6f 91       	pop	r22
    27dc:	5f 91       	pop	r21
    27de:	4f 91       	pop	r20
    27e0:	3f 91       	pop	r19
    27e2:	2f 91       	pop	r18
    27e4:	0f 90       	pop	r0
    27e6:	00 92 3b 00 	sts	0x003B, r0
    27ea:	0f 90       	pop	r0
    27ec:	0f be       	out	0x3f, r0	; 63
    27ee:	0f 90       	pop	r0
    27f0:	1f 90       	pop	r1
    27f2:	18 95       	reti

000027f4 <__vector_19>:

ISR(TCC0_CCD_vect) {
    27f4:	1f 92       	push	r1
    27f6:	0f 92       	push	r0
    27f8:	0f b6       	in	r0, 0x3f	; 63
    27fa:	0f 92       	push	r0
    27fc:	00 90 3b 00 	lds	r0, 0x003B
    2800:	0f 92       	push	r0
    2802:	11 24       	eor	r1, r1
    2804:	2f 93       	push	r18
    2806:	3f 93       	push	r19
    2808:	4f 93       	push	r20
    280a:	5f 93       	push	r21
    280c:	6f 93       	push	r22
    280e:	7f 93       	push	r23
    2810:	8f 93       	push	r24
    2812:	9f 93       	push	r25
    2814:	af 93       	push	r26
    2816:	bf 93       	push	r27
    2818:	ef 93       	push	r30
    281a:	ff 93       	push	r31
    281c:	cf 93       	push	r28
    281e:	df 93       	push	r29
    2820:	cd b7       	in	r28, 0x3d	; 61
    2822:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2824:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
	SPICount = 0;
    2828:	10 92 ce 50 	sts	0x50CE, r1
	if(PORTB.OUT & PIN1_bm) {
    282c:	80 e2       	ldi	r24, 0x20	; 32
    282e:	96 e0       	ldi	r25, 0x06	; 6
    2830:	fc 01       	movw	r30, r24
    2832:	84 81       	ldd	r24, Z+4	; 0x04
    2834:	88 2f       	mov	r24, r24
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	82 70       	andi	r24, 0x02	; 2
    283a:	90 70       	andi	r25, 0x00	; 0
    283c:	00 97       	sbiw	r24, 0x00	; 0
    283e:	b1 f0       	breq	.+44     	; 0x286c <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2840:	80 e0       	ldi	r24, 0x00	; 0
    2842:	96 e0       	ldi	r25, 0x06	; 6
    2844:	fc 01       	movw	r30, r24
    2846:	84 81       	ldd	r24, Z+4	; 0x04
    2848:	88 2f       	mov	r24, r24
    284a:	90 e0       	ldi	r25, 0x00	; 0
    284c:	80 74       	andi	r24, 0x40	; 64
    284e:	90 70       	andi	r25, 0x00	; 0
    2850:	00 97       	sbiw	r24, 0x00	; 0
    2852:	31 f0       	breq	.+12     	; 0x2860 <__vector_19+0x6c>
    2854:	80 e2       	ldi	r24, 0x20	; 32
    2856:	96 e0       	ldi	r25, 0x06	; 6
    2858:	22 e0       	ldi	r18, 0x02	; 2
    285a:	fc 01       	movw	r30, r24
    285c:	27 83       	std	Z+7, r18	; 0x07
    285e:	10 c0       	rjmp	.+32     	; 0x2880 <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    2860:	80 e0       	ldi	r24, 0x00	; 0
    2862:	96 e0       	ldi	r25, 0x06	; 6
    2864:	20 e4       	ldi	r18, 0x40	; 64
    2866:	fc 01       	movw	r30, r24
    2868:	27 83       	std	Z+7, r18	; 0x07
    286a:	0a c0       	rjmp	.+20     	; 0x2880 <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    286c:	80 e0       	ldi	r24, 0x00	; 0
    286e:	96 e0       	ldi	r25, 0x06	; 6
    2870:	20 e4       	ldi	r18, 0x40	; 64
    2872:	fc 01       	movw	r30, r24
    2874:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2876:	80 e2       	ldi	r24, 0x20	; 32
    2878:	96 e0       	ldi	r25, 0x06	; 6
    287a:	22 e0       	ldi	r18, 0x02	; 2
    287c:	fc 01       	movw	r30, r24
    287e:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    2880:	df 91       	pop	r29
    2882:	cf 91       	pop	r28
    2884:	ff 91       	pop	r31
    2886:	ef 91       	pop	r30
    2888:	bf 91       	pop	r27
    288a:	af 91       	pop	r26
    288c:	9f 91       	pop	r25
    288e:	8f 91       	pop	r24
    2890:	7f 91       	pop	r23
    2892:	6f 91       	pop	r22
    2894:	5f 91       	pop	r21
    2896:	4f 91       	pop	r20
    2898:	3f 91       	pop	r19
    289a:	2f 91       	pop	r18
    289c:	0f 90       	pop	r0
    289e:	00 92 3b 00 	sts	0x003B, r0
    28a2:	0f 90       	pop	r0
    28a4:	0f be       	out	0x3f, r0	; 63
    28a6:	0f 90       	pop	r0
    28a8:	1f 90       	pop	r1
    28aa:	18 95       	reti

000028ac <__vector_14>:

ISR(TCC0_OVF_vect) {
    28ac:	1f 92       	push	r1
    28ae:	0f 92       	push	r0
    28b0:	0f b6       	in	r0, 0x3f	; 63
    28b2:	0f 92       	push	r0
    28b4:	00 90 3b 00 	lds	r0, 0x003B
    28b8:	0f 92       	push	r0
    28ba:	11 24       	eor	r1, r1
    28bc:	2f 93       	push	r18
    28be:	3f 93       	push	r19
    28c0:	4f 93       	push	r20
    28c2:	5f 93       	push	r21
    28c4:	6f 93       	push	r22
    28c6:	7f 93       	push	r23
    28c8:	8f 93       	push	r24
    28ca:	9f 93       	push	r25
    28cc:	af 93       	push	r26
    28ce:	bf 93       	push	r27
    28d0:	ef 93       	push	r30
    28d2:	ff 93       	push	r31
    28d4:	cf 93       	push	r28
    28d6:	df 93       	push	r29
    28d8:	cd b7       	in	r28, 0x3d	; 61
    28da:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    28dc:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <writeSE2FRAM>
}
    28e0:	df 91       	pop	r29
    28e2:	cf 91       	pop	r28
    28e4:	ff 91       	pop	r31
    28e6:	ef 91       	pop	r30
    28e8:	bf 91       	pop	r27
    28ea:	af 91       	pop	r26
    28ec:	9f 91       	pop	r25
    28ee:	8f 91       	pop	r24
    28f0:	7f 91       	pop	r23
    28f2:	6f 91       	pop	r22
    28f4:	5f 91       	pop	r21
    28f6:	4f 91       	pop	r20
    28f8:	3f 91       	pop	r19
    28fa:	2f 91       	pop	r18
    28fc:	0f 90       	pop	r0
    28fe:	00 92 3b 00 	sts	0x003B, r0
    2902:	0f 90       	pop	r0
    2904:	0f be       	out	0x3f, r0	; 63
    2906:	0f 90       	pop	r0
    2908:	1f 90       	pop	r1
    290a:	18 95       	reti

0000290c <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD) {
    290c:	8f 92       	push	r8
    290e:	9f 92       	push	r9
    2910:	af 92       	push	r10
    2912:	bf 92       	push	r11
    2914:	cf 92       	push	r12
    2916:	df 92       	push	r13
    2918:	ef 92       	push	r14
    291a:	0f 93       	push	r16
    291c:	cf 93       	push	r28
    291e:	df 93       	push	r29
    2920:	cd b7       	in	r28, 0x3d	; 61
    2922:	de b7       	in	r29, 0x3e	; 62
    2924:	2c 97       	sbiw	r28, 0x0c	; 12
    2926:	cd bf       	out	0x3d, r28	; 61
    2928:	de bf       	out	0x3e, r29	; 62
    292a:	89 83       	std	Y+1, r24	; 0x01
    292c:	6a 83       	std	Y+2, r22	; 0x02
    292e:	4b 83       	std	Y+3, r20	; 0x03
    2930:	2c 83       	std	Y+4, r18	; 0x04
    2932:	0d 83       	std	Y+5, r16	; 0x05
    2934:	ee 82       	std	Y+6, r14	; 0x06
    2936:	cf 82       	std	Y+7, r12	; 0x07
    2938:	d8 86       	std	Y+8, r13	; 0x08
    293a:	a9 86       	std	Y+9, r10	; 0x09
    293c:	ba 86       	std	Y+10, r11	; 0x0a
    293e:	8b 86       	std	Y+11, r8	; 0x0b
    2940:	9c 86       	std	Y+12, r9	; 0x0c
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2942:	81 e0       	ldi	r24, 0x01	; 1
    2944:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2948:	89 81       	ldd	r24, Y+1	; 0x01
    294a:	6b 81       	ldd	r22, Y+3	; 0x03
    294c:	0e 94 2a 07 	call	0xe54	; 0xe54 <set_ampGain>
	set_filter(filterConfig);
    2950:	8a 81       	ldd	r24, Y+2	; 0x02
    2952:	0e 94 59 08 	call	0x10b2	; 0x10b2 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2956:	8e 81       	ldd	r24, Y+6	; 0x06
    2958:	0e 94 33 11 	call	0x2266	; 0x2266 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    295c:	84 e0       	ldi	r24, 0x04	; 4
    295e:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2962:	80 ec       	ldi	r24, 0xC0	; 192
    2964:	98 e0       	ldi	r25, 0x08	; 8
    2966:	24 e5       	ldi	r18, 0x54	; 84
    2968:	fc 01       	movw	r30, r24
    296a:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    296c:	81 e0       	ldi	r24, 0x01	; 1
    296e:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
	setADCInput(channel);
    2972:	89 81       	ldd	r24, Y+1	; 0x01
    2974:	0e 94 5f 1c 	call	0x38be	; 0x38be <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2978:	80 ea       	ldi	r24, 0xA0	; 160
    297a:	96 e0       	ldi	r25, 0x06	; 6
    297c:	22 e0       	ldi	r18, 0x02	; 2
    297e:	fc 01       	movw	r30, r24
    2980:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2982:	80 ea       	ldi	r24, 0xA0	; 160
    2984:	96 e0       	ldi	r25, 0x06	; 6
    2986:	21 e0       	ldi	r18, 0x01	; 1
    2988:	fc 01       	movw	r30, r24
    298a:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    298c:	80 e8       	ldi	r24, 0x80	; 128
    298e:	91 e0       	ldi	r25, 0x01	; 1
    2990:	28 e7       	ldi	r18, 0x78	; 120
    2992:	fc 01       	movw	r30, r24
    2994:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2996:	80 e0       	ldi	r24, 0x00	; 0
    2998:	99 e0       	ldi	r25, 0x09	; 9
    299a:	20 ef       	ldi	r18, 0xF0	; 240
    299c:	fc 01       	movw	r30, r24
    299e:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    29a0:	80 e0       	ldi	r24, 0x00	; 0
    29a2:	99 e0       	ldi	r25, 0x09	; 9
    29a4:	2f 81       	ldd	r18, Y+7	; 0x07
    29a6:	38 85       	ldd	r19, Y+8	; 0x08
    29a8:	fc 01       	movw	r30, r24
    29aa:	20 a7       	lds	r18, 0x70
    29ac:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    29ae:	80 e0       	ldi	r24, 0x00	; 0
    29b0:	99 e0       	ldi	r25, 0x09	; 9
    29b2:	29 85       	ldd	r18, Y+9	; 0x09
    29b4:	3a 85       	ldd	r19, Y+10	; 0x0a
    29b6:	fc 01       	movw	r30, r24
    29b8:	22 a7       	lds	r18, 0x72
    29ba:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    29bc:	80 e0       	ldi	r24, 0x00	; 0
    29be:	99 e0       	ldi	r25, 0x09	; 9
    29c0:	2b 85       	ldd	r18, Y+11	; 0x0b
    29c2:	3c 85       	ldd	r19, Y+12	; 0x0c
    29c4:	fc 01       	movw	r30, r24
    29c6:	24 a7       	lds	r18, 0x74
    29c8:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    29ca:	80 e0       	ldi	r24, 0x00	; 0
    29cc:	99 e0       	ldi	r25, 0x09	; 9
    29ce:	2a 8d       	ldd	r18, Y+26	; 0x1a
    29d0:	3b 8d       	ldd	r19, Y+27	; 0x1b
    29d2:	fc 01       	movw	r30, r24
    29d4:	26 a7       	lds	r18, 0x76
    29d6:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    29d8:	80 e0       	ldi	r24, 0x00	; 0
    29da:	99 e0       	ldi	r25, 0x09	; 9
    29dc:	2d 81       	ldd	r18, Y+5	; 0x05
    29de:	22 2f       	mov	r18, r18
    29e0:	30 e0       	ldi	r19, 0x00	; 0
    29e2:	21 50       	subi	r18, 0x01	; 1
    29e4:	30 40       	sbci	r19, 0x00	; 0
    29e6:	fc 01       	movw	r30, r24
    29e8:	26 a3       	lds	r18, 0x56
    29ea:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    29ec:	80 e0       	ldi	r24, 0x00	; 0
    29ee:	99 e0       	ldi	r25, 0x09	; 9
    29f0:	22 e0       	ldi	r18, 0x02	; 2
    29f2:	fc 01       	movw	r30, r24
    29f4:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    29f6:	80 e0       	ldi	r24, 0x00	; 0
    29f8:	99 e0       	ldi	r25, 0x09	; 9
    29fa:	2f ef       	ldi	r18, 0xFF	; 255
    29fc:	fc 01       	movw	r30, r24
    29fe:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2a00:	80 e0       	ldi	r24, 0x00	; 0
    2a02:	99 e0       	ldi	r25, 0x09	; 9
    2a04:	20 e0       	ldi	r18, 0x00	; 0
    2a06:	39 e0       	ldi	r19, 0x09	; 9
    2a08:	f9 01       	movw	r30, r18
    2a0a:	20 81       	ld	r18, Z
    2a0c:	20 7f       	andi	r18, 0xF0	; 240
    2a0e:	28 60       	ori	r18, 0x08	; 8
    2a10:	fc 01       	movw	r30, r24
    2a12:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    2a14:	10 92 46 40 	sts	0x4046, r1
    2a18:	10 92 47 40 	sts	0x4047, r1
	sampleCount = 0;
    2a1c:	10 92 61 50 	sts	0x5061, r1
    2a20:	10 92 62 50 	sts	0x5062, r1
	SPICount = 0;
    2a24:	10 92 ce 50 	sts	0x50CE, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2a28:	80 e0       	ldi	r24, 0x00	; 0
    2a2a:	80 93 2a 21 	sts	0x212A, r24
    2a2e:	80 93 29 21 	sts	0x2129, r24
    2a32:	80 93 28 21 	sts	0x2128, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2a36:	80 ea       	ldi	r24, 0xA0	; 160
    2a38:	90 e0       	ldi	r25, 0x00	; 0
    2a3a:	20 ea       	ldi	r18, 0xA0	; 160
    2a3c:	30 e0       	ldi	r19, 0x00	; 0
    2a3e:	f9 01       	movw	r30, r18
    2a40:	22 81       	ldd	r18, Z+2	; 0x02
    2a42:	26 60       	ori	r18, 0x06	; 6
    2a44:	fc 01       	movw	r30, r24
    2a46:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2a48:	78 94       	sei

	SPICS(TRUE);
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
    2a4c:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2a50:	80 e8       	ldi	r24, 0x80	; 128
    2a52:	96 e0       	ldi	r25, 0x06	; 6
    2a54:	20 e2       	ldi	r18, 0x20	; 32
    2a56:	fc 01       	movw	r30, r24
    2a58:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a5a:	80 e4       	ldi	r24, 0x40	; 64
    2a5c:	9a e0       	ldi	r25, 0x0A	; 10
    2a5e:	23 e2       	ldi	r18, 0x23	; 35
    2a60:	fc 01       	movw	r30, r24
    2a62:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2a64:	80 e4       	ldi	r24, 0x40	; 64
    2a66:	9a e0       	ldi	r25, 0x0A	; 10
    2a68:	2c 81       	ldd	r18, Y+4	; 0x04
    2a6a:	42 2f       	mov	r20, r18
    2a6c:	50 e0       	ldi	r21, 0x00	; 0
    2a6e:	20 e2       	ldi	r18, 0x20	; 32
    2a70:	30 e0       	ldi	r19, 0x00	; 0
    2a72:	02 c0       	rjmp	.+4      	; 0x2a78 <CO_collectSeismic1Channel+0x16c>
    2a74:	22 0f       	add	r18, r18
    2a76:	33 1f       	adc	r19, r19
    2a78:	4a 95       	dec	r20
    2a7a:	e2 f7       	brpl	.-8      	; 0x2a74 <CO_collectSeismic1Channel+0x168>
    2a7c:	fc 01       	movw	r30, r24
    2a7e:	26 a3       	lds	r18, 0x56
    2a80:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2a82:	80 e4       	ldi	r24, 0x40	; 64
    2a84:	9a e0       	ldi	r25, 0x0A	; 10
    2a86:	2c 81       	ldd	r18, Y+4	; 0x04
    2a88:	42 2f       	mov	r20, r18
    2a8a:	50 e0       	ldi	r21, 0x00	; 0
    2a8c:	20 e1       	ldi	r18, 0x10	; 16
    2a8e:	30 e0       	ldi	r19, 0x00	; 0
    2a90:	04 2e       	mov	r0, r20
    2a92:	02 c0       	rjmp	.+4      	; 0x2a98 <CO_collectSeismic1Channel+0x18c>
    2a94:	22 0f       	add	r18, r18
    2a96:	33 1f       	adc	r19, r19
    2a98:	0a 94       	dec	r0
    2a9a:	e2 f7       	brpl	.-8      	; 0x2a94 <CO_collectSeismic1Channel+0x188>
    2a9c:	fc 01       	movw	r30, r24
    2a9e:	22 af       	sts	0x72, r18
    2aa0:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2aa2:	80 e4       	ldi	r24, 0x40	; 64
    2aa4:	9a e0       	ldi	r25, 0x0A	; 10
    2aa6:	20 e4       	ldi	r18, 0x40	; 64
    2aa8:	3a e0       	ldi	r19, 0x0A	; 10
    2aaa:	f9 01       	movw	r30, r18
    2aac:	20 81       	ld	r18, Z
    2aae:	20 7f       	andi	r18, 0xF0	; 240
    2ab0:	21 60       	ori	r18, 0x01	; 1
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2ab6:	00 00       	nop
    2ab8:	80 91 61 50 	lds	r24, 0x5061
    2abc:	90 91 62 50 	lds	r25, 0x5062
    2ac0:	f5 e5       	ldi	r31, 0x55	; 85
    2ac2:	83 35       	cpi	r24, 0x53	; 83
    2ac4:	9f 07       	cpc	r25, r31
    2ac6:	c0 f3       	brcs	.-16     	; 0x2ab8 <CO_collectSeismic1Channel+0x1ac>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2ac8:	80 e0       	ldi	r24, 0x00	; 0
    2aca:	99 e0       	ldi	r25, 0x09	; 9
    2acc:	20 e0       	ldi	r18, 0x00	; 0
    2ace:	39 e0       	ldi	r19, 0x09	; 9
    2ad0:	f9 01       	movw	r30, r18
    2ad2:	20 81       	ld	r18, Z
    2ad4:	20 7f       	andi	r18, 0xF0	; 240
    2ad6:	fc 01       	movw	r30, r24
    2ad8:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2ada:	80 e4       	ldi	r24, 0x40	; 64
    2adc:	9a e0       	ldi	r25, 0x0A	; 10
    2ade:	20 e4       	ldi	r18, 0x40	; 64
    2ae0:	3a e0       	ldi	r19, 0x0A	; 10
    2ae2:	f9 01       	movw	r30, r18
    2ae4:	20 81       	ld	r18, Z
    2ae6:	20 7f       	andi	r18, 0xF0	; 240
    2ae8:	fc 01       	movw	r30, r24
    2aea:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2aec:	80 ea       	ldi	r24, 0xA0	; 160
    2aee:	90 e0       	ldi	r25, 0x00	; 0
    2af0:	20 ea       	ldi	r18, 0xA0	; 160
    2af2:	30 e0       	ldi	r19, 0x00	; 0
    2af4:	f9 01       	movw	r30, r18
    2af6:	22 81       	ldd	r18, Z+2	; 0x02
    2af8:	29 7f       	andi	r18, 0xF9	; 249
    2afa:	fc 01       	movw	r30, r24
    2afc:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2afe:	f8 94       	cli

	SPICS(FALSE);
    2b00:	80 e0       	ldi	r24, 0x00	; 0
    2b02:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    2b06:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	enableADCMUX(FALSE);
    2b0a:	80 e0       	ldi	r24, 0x00	; 0
    2b0c:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <enableADCMUX>
	ADCPower(FALSE);
    2b10:	80 e0       	ldi	r24, 0x00	; 0
    2b12:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	
}
    2b16:	2c 96       	adiw	r28, 0x0c	; 12
    2b18:	cd bf       	out	0x3d, r28	; 61
    2b1a:	de bf       	out	0x3e, r29	; 62
    2b1c:	df 91       	pop	r29
    2b1e:	cf 91       	pop	r28
    2b20:	0f 91       	pop	r16
    2b22:	ef 90       	pop	r14
    2b24:	df 90       	pop	r13
    2b26:	cf 90       	pop	r12
    2b28:	bf 90       	pop	r11
    2b2a:	af 90       	pop	r10
    2b2c:	9f 90       	pop	r9
    2b2e:	8f 90       	pop	r8
    2b30:	08 95       	ret

00002b32 <__vector_79>:

ISR(TCD0_CCA_vect) {
    2b32:	1f 92       	push	r1
    2b34:	0f 92       	push	r0
    2b36:	0f b6       	in	r0, 0x3f	; 63
    2b38:	0f 92       	push	r0
    2b3a:	00 90 3b 00 	lds	r0, 0x003B
    2b3e:	0f 92       	push	r0
    2b40:	11 24       	eor	r1, r1
    2b42:	2f 93       	push	r18
    2b44:	3f 93       	push	r19
    2b46:	4f 93       	push	r20
    2b48:	5f 93       	push	r21
    2b4a:	6f 93       	push	r22
    2b4c:	7f 93       	push	r23
    2b4e:	8f 93       	push	r24
    2b50:	9f 93       	push	r25
    2b52:	af 93       	push	r26
    2b54:	bf 93       	push	r27
    2b56:	ef 93       	push	r30
    2b58:	ff 93       	push	r31
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	cd b7       	in	r28, 0x3d	; 61
    2b60:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2b62:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
}
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	ff 91       	pop	r31
    2b6c:	ef 91       	pop	r30
    2b6e:	bf 91       	pop	r27
    2b70:	af 91       	pop	r26
    2b72:	9f 91       	pop	r25
    2b74:	8f 91       	pop	r24
    2b76:	7f 91       	pop	r23
    2b78:	6f 91       	pop	r22
    2b7a:	5f 91       	pop	r21
    2b7c:	4f 91       	pop	r20
    2b7e:	3f 91       	pop	r19
    2b80:	2f 91       	pop	r18
    2b82:	0f 90       	pop	r0
    2b84:	00 92 3b 00 	sts	0x003B, r0
    2b88:	0f 90       	pop	r0
    2b8a:	0f be       	out	0x3f, r0	; 63
    2b8c:	0f 90       	pop	r0
    2b8e:	1f 90       	pop	r1
    2b90:	18 95       	reti

00002b92 <__vector_80>:

ISR(TCD0_CCB_vect) {
    2b92:	1f 92       	push	r1
    2b94:	0f 92       	push	r0
    2b96:	0f b6       	in	r0, 0x3f	; 63
    2b98:	0f 92       	push	r0
    2b9a:	00 90 3b 00 	lds	r0, 0x003B
    2b9e:	0f 92       	push	r0
    2ba0:	11 24       	eor	r1, r1
    2ba2:	2f 93       	push	r18
    2ba4:	3f 93       	push	r19
    2ba6:	4f 93       	push	r20
    2ba8:	5f 93       	push	r21
    2baa:	6f 93       	push	r22
    2bac:	7f 93       	push	r23
    2bae:	8f 93       	push	r24
    2bb0:	9f 93       	push	r25
    2bb2:	af 93       	push	r26
    2bb4:	bf 93       	push	r27
    2bb6:	ef 93       	push	r30
    2bb8:	ff 93       	push	r31
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	cd b7       	in	r28, 0x3d	; 61
    2bc0:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2bc2:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
}
    2bc6:	df 91       	pop	r29
    2bc8:	cf 91       	pop	r28
    2bca:	ff 91       	pop	r31
    2bcc:	ef 91       	pop	r30
    2bce:	bf 91       	pop	r27
    2bd0:	af 91       	pop	r26
    2bd2:	9f 91       	pop	r25
    2bd4:	8f 91       	pop	r24
    2bd6:	7f 91       	pop	r23
    2bd8:	6f 91       	pop	r22
    2bda:	5f 91       	pop	r21
    2bdc:	4f 91       	pop	r20
    2bde:	3f 91       	pop	r19
    2be0:	2f 91       	pop	r18
    2be2:	0f 90       	pop	r0
    2be4:	00 92 3b 00 	sts	0x003B, r0
    2be8:	0f 90       	pop	r0
    2bea:	0f be       	out	0x3f, r0	; 63
    2bec:	0f 90       	pop	r0
    2bee:	1f 90       	pop	r1
    2bf0:	18 95       	reti

00002bf2 <__vector_81>:

ISR(TCD0_CCC_vect) {
    2bf2:	1f 92       	push	r1
    2bf4:	0f 92       	push	r0
    2bf6:	0f b6       	in	r0, 0x3f	; 63
    2bf8:	0f 92       	push	r0
    2bfa:	00 90 3b 00 	lds	r0, 0x003B
    2bfe:	0f 92       	push	r0
    2c00:	11 24       	eor	r1, r1
    2c02:	2f 93       	push	r18
    2c04:	3f 93       	push	r19
    2c06:	4f 93       	push	r20
    2c08:	5f 93       	push	r21
    2c0a:	6f 93       	push	r22
    2c0c:	7f 93       	push	r23
    2c0e:	8f 93       	push	r24
    2c10:	9f 93       	push	r25
    2c12:	af 93       	push	r26
    2c14:	bf 93       	push	r27
    2c16:	ef 93       	push	r30
    2c18:	ff 93       	push	r31
    2c1a:	cf 93       	push	r28
    2c1c:	df 93       	push	r29
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2c22:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
}
    2c26:	df 91       	pop	r29
    2c28:	cf 91       	pop	r28
    2c2a:	ff 91       	pop	r31
    2c2c:	ef 91       	pop	r30
    2c2e:	bf 91       	pop	r27
    2c30:	af 91       	pop	r26
    2c32:	9f 91       	pop	r25
    2c34:	8f 91       	pop	r24
    2c36:	7f 91       	pop	r23
    2c38:	6f 91       	pop	r22
    2c3a:	5f 91       	pop	r21
    2c3c:	4f 91       	pop	r20
    2c3e:	3f 91       	pop	r19
    2c40:	2f 91       	pop	r18
    2c42:	0f 90       	pop	r0
    2c44:	00 92 3b 00 	sts	0x003B, r0
    2c48:	0f 90       	pop	r0
    2c4a:	0f be       	out	0x3f, r0	; 63
    2c4c:	0f 90       	pop	r0
    2c4e:	1f 90       	pop	r1
    2c50:	18 95       	reti

00002c52 <__vector_82>:

ISR(TCD0_CCD_vect) {
    2c52:	1f 92       	push	r1
    2c54:	0f 92       	push	r0
    2c56:	0f b6       	in	r0, 0x3f	; 63
    2c58:	0f 92       	push	r0
    2c5a:	00 90 3b 00 	lds	r0, 0x003B
    2c5e:	0f 92       	push	r0
    2c60:	11 24       	eor	r1, r1
    2c62:	2f 93       	push	r18
    2c64:	3f 93       	push	r19
    2c66:	4f 93       	push	r20
    2c68:	5f 93       	push	r21
    2c6a:	6f 93       	push	r22
    2c6c:	7f 93       	push	r23
    2c6e:	8f 93       	push	r24
    2c70:	9f 93       	push	r25
    2c72:	af 93       	push	r26
    2c74:	bf 93       	push	r27
    2c76:	ef 93       	push	r30
    2c78:	ff 93       	push	r31
    2c7a:	cf 93       	push	r28
    2c7c:	df 93       	push	r29
    2c7e:	cd b7       	in	r28, 0x3d	; 61
    2c80:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2c82:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <sampleCurrentChannel>
	SPICount = 0;
    2c86:	10 92 ce 50 	sts	0x50CE, r1
}
    2c8a:	df 91       	pop	r29
    2c8c:	cf 91       	pop	r28
    2c8e:	ff 91       	pop	r31
    2c90:	ef 91       	pop	r30
    2c92:	bf 91       	pop	r27
    2c94:	af 91       	pop	r26
    2c96:	9f 91       	pop	r25
    2c98:	8f 91       	pop	r24
    2c9a:	7f 91       	pop	r23
    2c9c:	6f 91       	pop	r22
    2c9e:	5f 91       	pop	r21
    2ca0:	4f 91       	pop	r20
    2ca2:	3f 91       	pop	r19
    2ca4:	2f 91       	pop	r18
    2ca6:	0f 90       	pop	r0
    2ca8:	00 92 3b 00 	sts	0x003B, r0
    2cac:	0f 90       	pop	r0
    2cae:	0f be       	out	0x3f, r0	; 63
    2cb0:	0f 90       	pop	r0
    2cb2:	1f 90       	pop	r1
    2cb4:	18 95       	reti

00002cb6 <__vector_77>:

ISR(TCD0_OVF_vect) {
    2cb6:	1f 92       	push	r1
    2cb8:	0f 92       	push	r0
    2cba:	0f b6       	in	r0, 0x3f	; 63
    2cbc:	0f 92       	push	r0
    2cbe:	00 90 3b 00 	lds	r0, 0x003B
    2cc2:	0f 92       	push	r0
    2cc4:	11 24       	eor	r1, r1
    2cc6:	2f 93       	push	r18
    2cc8:	3f 93       	push	r19
    2cca:	4f 93       	push	r20
    2ccc:	5f 93       	push	r21
    2cce:	6f 93       	push	r22
    2cd0:	7f 93       	push	r23
    2cd2:	8f 93       	push	r24
    2cd4:	9f 93       	push	r25
    2cd6:	af 93       	push	r26
    2cd8:	bf 93       	push	r27
    2cda:	ef 93       	push	r30
    2cdc:	ff 93       	push	r31
    2cde:	cf 93       	push	r28
    2ce0:	df 93       	push	r29
    2ce2:	cd b7       	in	r28, 0x3d	; 61
    2ce4:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    2ce6:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <writeSE2FRAM>
}
    2cea:	df 91       	pop	r29
    2cec:	cf 91       	pop	r28
    2cee:	ff 91       	pop	r31
    2cf0:	ef 91       	pop	r30
    2cf2:	bf 91       	pop	r27
    2cf4:	af 91       	pop	r26
    2cf6:	9f 91       	pop	r25
    2cf8:	8f 91       	pop	r24
    2cfa:	7f 91       	pop	r23
    2cfc:	6f 91       	pop	r22
    2cfe:	5f 91       	pop	r21
    2d00:	4f 91       	pop	r20
    2d02:	3f 91       	pop	r19
    2d04:	2f 91       	pop	r18
    2d06:	0f 90       	pop	r0
    2d08:	00 92 3b 00 	sts	0x003B, r0
    2d0c:	0f 90       	pop	r0
    2d0e:	0f be       	out	0x3f, r0	; 63
    2d10:	0f 90       	pop	r0
    2d12:	1f 90       	pop	r1
    2d14:	18 95       	reti

00002d16 <sampleCurrentChannel>:

void sampleCurrentChannel() {
    2d16:	cf 93       	push	r28
    2d18:	df 93       	push	r29
    2d1a:	cd b7       	in	r28, 0x3d	; 61
    2d1c:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2d1e:	80 ea       	ldi	r24, 0xA0	; 160
    2d20:	96 e0       	ldi	r25, 0x06	; 6
    2d22:	22 e0       	ldi	r18, 0x02	; 2
    2d24:	fc 01       	movw	r30, r24
    2d26:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d28:	80 ec       	ldi	r24, 0xC0	; 192
    2d2a:	98 e0       	ldi	r25, 0x08	; 8
    2d2c:	2a ea       	ldi	r18, 0xAA	; 170
    2d2e:	fc 01       	movw	r30, r24
    2d30:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d32:	00 00       	nop
    2d34:	80 ec       	ldi	r24, 0xC0	; 192
    2d36:	98 e0       	ldi	r25, 0x08	; 8
    2d38:	fc 01       	movw	r30, r24
    2d3a:	82 81       	ldd	r24, Z+2	; 0x02
    2d3c:	88 23       	and	r24, r24
    2d3e:	d4 f7       	brge	.-12     	; 0x2d34 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    2d40:	80 91 ce 50 	lds	r24, 0x50CE
    2d44:	88 2f       	mov	r24, r24
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	20 ec       	ldi	r18, 0xC0	; 192
    2d4a:	38 e0       	ldi	r19, 0x08	; 8
    2d4c:	f9 01       	movw	r30, r18
    2d4e:	23 81       	ldd	r18, Z+3	; 0x03
    2d50:	8c 5a       	subi	r24, 0xAC	; 172
    2d52:	9f 4a       	sbci	r25, 0xAF	; 175
    2d54:	fc 01       	movw	r30, r24
    2d56:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d58:	80 ec       	ldi	r24, 0xC0	; 192
    2d5a:	98 e0       	ldi	r25, 0x08	; 8
    2d5c:	2a ea       	ldi	r18, 0xAA	; 170
    2d5e:	fc 01       	movw	r30, r24
    2d60:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d62:	00 00       	nop
    2d64:	80 ec       	ldi	r24, 0xC0	; 192
    2d66:	98 e0       	ldi	r25, 0x08	; 8
    2d68:	fc 01       	movw	r30, r24
    2d6a:	82 81       	ldd	r24, Z+2	; 0x02
    2d6c:	88 23       	and	r24, r24
    2d6e:	d4 f7       	brge	.-12     	; 0x2d64 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2d70:	80 91 ce 50 	lds	r24, 0x50CE
    2d74:	88 2f       	mov	r24, r24
    2d76:	90 e0       	ldi	r25, 0x00	; 0
    2d78:	01 96       	adiw	r24, 0x01	; 1
    2d7a:	20 ec       	ldi	r18, 0xC0	; 192
    2d7c:	38 e0       	ldi	r19, 0x08	; 8
    2d7e:	f9 01       	movw	r30, r18
    2d80:	23 81       	ldd	r18, Z+3	; 0x03
    2d82:	8c 5a       	subi	r24, 0xAC	; 172
    2d84:	9f 4a       	sbci	r25, 0xAF	; 175
    2d86:	fc 01       	movw	r30, r24
    2d88:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d8a:	80 ec       	ldi	r24, 0xC0	; 192
    2d8c:	98 e0       	ldi	r25, 0x08	; 8
    2d8e:	2a ea       	ldi	r18, 0xAA	; 170
    2d90:	fc 01       	movw	r30, r24
    2d92:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d94:	00 00       	nop
    2d96:	80 ec       	ldi	r24, 0xC0	; 192
    2d98:	98 e0       	ldi	r25, 0x08	; 8
    2d9a:	fc 01       	movw	r30, r24
    2d9c:	82 81       	ldd	r24, Z+2	; 0x02
    2d9e:	88 23       	and	r24, r24
    2da0:	d4 f7       	brge	.-12     	; 0x2d96 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2da2:	80 91 ce 50 	lds	r24, 0x50CE
    2da6:	88 2f       	mov	r24, r24
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	02 96       	adiw	r24, 0x02	; 2
    2dac:	20 ec       	ldi	r18, 0xC0	; 192
    2dae:	38 e0       	ldi	r19, 0x08	; 8
    2db0:	f9 01       	movw	r30, r18
    2db2:	23 81       	ldd	r18, Z+3	; 0x03
    2db4:	8c 5a       	subi	r24, 0xAC	; 172
    2db6:	9f 4a       	sbci	r25, 0xAF	; 175
    2db8:	fc 01       	movw	r30, r24
    2dba:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2dbc:	80 ea       	ldi	r24, 0xA0	; 160
    2dbe:	96 e0       	ldi	r25, 0x06	; 6
    2dc0:	22 e0       	ldi	r18, 0x02	; 2
    2dc2:	fc 01       	movw	r30, r24
    2dc4:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2dc6:	80 91 ce 50 	lds	r24, 0x50CE
    2dca:	8d 5f       	subi	r24, 0xFD	; 253
    2dcc:	80 93 ce 50 	sts	0x50CE, r24
}
    2dd0:	df 91       	pop	r29
    2dd2:	cf 91       	pop	r28
    2dd4:	08 95       	ret

00002dd6 <writeSE2FRAM>:

void writeSE2FRAM() {
    2dd6:	cf 93       	push	r28
    2dd8:	df 93       	push	r29
    2dda:	cd b7       	in	r28, 0x3d	; 61
    2ddc:	de b7       	in	r29, 0x3e	; 62
    2dde:	29 97       	sbiw	r28, 0x09	; 9
    2de0:	cd bf       	out	0x3d, r28	; 61
    2de2:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2de4:	1a 82       	std	Y+2, r1	; 0x02
    2de6:	1b 82       	std	Y+3, r1	; 0x03
    2de8:	1c 82       	std	Y+4, r1	; 0x04
    2dea:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2dec:	80 91 61 50 	lds	r24, 0x5061
    2df0:	90 91 62 50 	lds	r25, 0x5062
    2df4:	01 96       	adiw	r24, 0x01	; 1
    2df6:	80 93 61 50 	sts	0x5061, r24
    2dfa:	90 93 62 50 	sts	0x5062, r25
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2dfe:	80 ec       	ldi	r24, 0xC0	; 192
    2e00:	98 e0       	ldi	r25, 0x08	; 8
    2e02:	20 ed       	ldi	r18, 0xD0	; 208
    2e04:	fc 01       	movw	r30, r24
    2e06:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2e08:	19 82       	std	Y+1, r1	; 0x01
    2e0a:	4f c0       	rjmp	.+158    	; 0x2eaa <writeSE2FRAM+0xd4>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2e0c:	89 81       	ldd	r24, Y+1	; 0x01
    2e0e:	88 2f       	mov	r24, r24
    2e10:	90 e0       	ldi	r25, 0x00	; 0
    2e12:	8c 5a       	subi	r24, 0xAC	; 172
    2e14:	9f 4a       	sbci	r25, 0xAF	; 175
    2e16:	fc 01       	movw	r30, r24
    2e18:	80 81       	ld	r24, Z
    2e1a:	88 23       	and	r24, r24
    2e1c:	3c f4       	brge	.+14     	; 0x2e2c <writeSE2FRAM+0x56>
    2e1e:	ce 01       	movw	r24, r28
    2e20:	06 96       	adiw	r24, 0x06	; 6
    2e22:	03 96       	adiw	r24, 0x03	; 3
    2e24:	2f ef       	ldi	r18, 0xFF	; 255
    2e26:	fc 01       	movw	r30, r24
    2e28:	20 83       	st	Z, r18
    2e2a:	05 c0       	rjmp	.+10     	; 0x2e36 <writeSE2FRAM+0x60>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2e2c:	ce 01       	movw	r24, r28
    2e2e:	06 96       	adiw	r24, 0x06	; 6
    2e30:	03 96       	adiw	r24, 0x03	; 3
    2e32:	fc 01       	movw	r30, r24
    2e34:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2e36:	ce 01       	movw	r24, r28
    2e38:	06 96       	adiw	r24, 0x06	; 6
    2e3a:	02 96       	adiw	r24, 0x02	; 2
    2e3c:	29 81       	ldd	r18, Y+1	; 0x01
    2e3e:	22 2f       	mov	r18, r18
    2e40:	30 e0       	ldi	r19, 0x00	; 0
    2e42:	2c 5a       	subi	r18, 0xAC	; 172
    2e44:	3f 4a       	sbci	r19, 0xAF	; 175
    2e46:	f9 01       	movw	r30, r18
    2e48:	20 81       	ld	r18, Z
    2e4a:	fc 01       	movw	r30, r24
    2e4c:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2e4e:	ce 01       	movw	r24, r28
    2e50:	06 96       	adiw	r24, 0x06	; 6
    2e52:	01 96       	adiw	r24, 0x01	; 1
    2e54:	29 81       	ldd	r18, Y+1	; 0x01
    2e56:	22 2f       	mov	r18, r18
    2e58:	30 e0       	ldi	r19, 0x00	; 0
    2e5a:	2f 5f       	subi	r18, 0xFF	; 255
    2e5c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e5e:	2c 5a       	subi	r18, 0xAC	; 172
    2e60:	3f 4a       	sbci	r19, 0xAF	; 175
    2e62:	f9 01       	movw	r30, r18
    2e64:	20 81       	ld	r18, Z
    2e66:	fc 01       	movw	r30, r24
    2e68:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2e6a:	ce 01       	movw	r24, r28
    2e6c:	06 96       	adiw	r24, 0x06	; 6
    2e6e:	29 81       	ldd	r18, Y+1	; 0x01
    2e70:	22 2f       	mov	r18, r18
    2e72:	30 e0       	ldi	r19, 0x00	; 0
    2e74:	2e 5f       	subi	r18, 0xFE	; 254
    2e76:	3f 4f       	sbci	r19, 0xFF	; 255
    2e78:	2c 5a       	subi	r18, 0xAC	; 172
    2e7a:	3f 4a       	sbci	r19, 0xAF	; 175
    2e7c:	f9 01       	movw	r30, r18
    2e7e:	20 81       	ld	r18, Z
    2e80:	fc 01       	movw	r30, r24
    2e82:	20 83       	st	Z, r18
		sum += currentSample;
    2e84:	2a 81       	ldd	r18, Y+2	; 0x02
    2e86:	3b 81       	ldd	r19, Y+3	; 0x03
    2e88:	4c 81       	ldd	r20, Y+4	; 0x04
    2e8a:	5d 81       	ldd	r21, Y+5	; 0x05
    2e8c:	8e 81       	ldd	r24, Y+6	; 0x06
    2e8e:	9f 81       	ldd	r25, Y+7	; 0x07
    2e90:	a8 85       	ldd	r26, Y+8	; 0x08
    2e92:	b9 85       	ldd	r27, Y+9	; 0x09
    2e94:	82 0f       	add	r24, r18
    2e96:	93 1f       	adc	r25, r19
    2e98:	a4 1f       	adc	r26, r20
    2e9a:	b5 1f       	adc	r27, r21
    2e9c:	8a 83       	std	Y+2, r24	; 0x02
    2e9e:	9b 83       	std	Y+3, r25	; 0x03
    2ea0:	ac 83       	std	Y+4, r26	; 0x04
    2ea2:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2ea4:	89 81       	ldd	r24, Y+1	; 0x01
    2ea6:	8d 5f       	subi	r24, 0xFD	; 253
    2ea8:	89 83       	std	Y+1, r24	; 0x01
    2eaa:	89 81       	ldd	r24, Y+1	; 0x01
    2eac:	8c 30       	cpi	r24, 0x0C	; 12
    2eae:	08 f4       	brcc	.+2      	; 0x2eb2 <writeSE2FRAM+0xdc>
    2eb0:	ad cf       	rjmp	.-166    	; 0x2e0c <writeSE2FRAM+0x36>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb4:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb6:	ac 81       	ldd	r26, Y+4	; 0x04
    2eb8:	bd 81       	ldd	r27, Y+5	; 0x05
    2eba:	24 e0       	ldi	r18, 0x04	; 4
    2ebc:	30 e0       	ldi	r19, 0x00	; 0
    2ebe:	40 e0       	ldi	r20, 0x00	; 0
    2ec0:	50 e0       	ldi	r21, 0x00	; 0
    2ec2:	bc 01       	movw	r22, r24
    2ec4:	cd 01       	movw	r24, r26
    2ec6:	0e 94 31 5f 	call	0xbe62	; 0xbe62 <__divmodsi4>
    2eca:	da 01       	movw	r26, r20
    2ecc:	c9 01       	movw	r24, r18
    2ece:	8a 83       	std	Y+2, r24	; 0x02
    2ed0:	9b 83       	std	Y+3, r25	; 0x03
    2ed2:	ac 83       	std	Y+4, r26	; 0x04
    2ed4:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2ed6:	ce 01       	movw	r24, r28
    2ed8:	02 96       	adiw	r24, 0x02	; 2
    2eda:	fc 01       	movw	r30, r24
    2edc:	80 81       	ld	r24, Z
    2ede:	80 93 56 50 	sts	0x5056, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2ee2:	ce 01       	movw	r24, r28
    2ee4:	02 96       	adiw	r24, 0x02	; 2
    2ee6:	fc 01       	movw	r30, r24
    2ee8:	81 81       	ldd	r24, Z+1	; 0x01
    2eea:	80 93 55 50 	sts	0x5055, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2eee:	ce 01       	movw	r24, r28
    2ef0:	02 96       	adiw	r24, 0x02	; 2
    2ef2:	fc 01       	movw	r30, r24
    2ef4:	82 81       	ldd	r24, Z+2	; 0x02
    2ef6:	80 93 54 50 	sts	0x5054, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2efa:	80 e4       	ldi	r24, 0x40	; 64
    2efc:	96 e0       	ldi	r25, 0x06	; 6
    2efe:	20 e1       	ldi	r18, 0x10	; 16
    2f00:	fc 01       	movw	r30, r24
    2f02:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2f04:	80 e2       	ldi	r24, 0x20	; 32
    2f06:	96 e0       	ldi	r25, 0x06	; 6
    2f08:	28 e0       	ldi	r18, 0x08	; 8
    2f0a:	fc 01       	movw	r30, r24
    2f0c:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2f0e:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2f10:	80 ec       	ldi	r24, 0xC0	; 192
    2f12:	98 e0       	ldi	r25, 0x08	; 8
    2f14:	26 e0       	ldi	r18, 0x06	; 6
    2f16:	fc 01       	movw	r30, r24
    2f18:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f1a:	00 00       	nop
    2f1c:	80 ec       	ldi	r24, 0xC0	; 192
    2f1e:	98 e0       	ldi	r25, 0x08	; 8
    2f20:	fc 01       	movw	r30, r24
    2f22:	82 81       	ldd	r24, Z+2	; 0x02
    2f24:	88 23       	and	r24, r24
    2f26:	d4 f7       	brge	.-12     	; 0x2f1c <writeSE2FRAM+0x146>
	SPIBuffer[12] = SPIC.DATA;
    2f28:	80 ec       	ldi	r24, 0xC0	; 192
    2f2a:	98 e0       	ldi	r25, 0x08	; 8
    2f2c:	fc 01       	movw	r30, r24
    2f2e:	83 81       	ldd	r24, Z+3	; 0x03
    2f30:	80 93 60 50 	sts	0x5060, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2f34:	80 e2       	ldi	r24, 0x20	; 32
    2f36:	96 e0       	ldi	r25, 0x06	; 6
    2f38:	28 e0       	ldi	r18, 0x08	; 8
    2f3a:	fc 01       	movw	r30, r24
    2f3c:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2f3e:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2f40:	80 e2       	ldi	r24, 0x20	; 32
    2f42:	96 e0       	ldi	r25, 0x06	; 6
    2f44:	28 e0       	ldi	r18, 0x08	; 8
    2f46:	fc 01       	movw	r30, r24
    2f48:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2f4a:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2f4c:	80 ec       	ldi	r24, 0xC0	; 192
    2f4e:	98 e0       	ldi	r25, 0x08	; 8
    2f50:	22 e0       	ldi	r18, 0x02	; 2
    2f52:	fc 01       	movw	r30, r24
    2f54:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f56:	00 00       	nop
    2f58:	80 ec       	ldi	r24, 0xC0	; 192
    2f5a:	98 e0       	ldi	r25, 0x08	; 8
    2f5c:	fc 01       	movw	r30, r24
    2f5e:	82 81       	ldd	r24, Z+2	; 0x02
    2f60:	88 23       	and	r24, r24
    2f62:	d4 f7       	brge	.-12     	; 0x2f58 <writeSE2FRAM+0x182>
	SPIBuffer[12] = SPIC.DATA;
    2f64:	80 ec       	ldi	r24, 0xC0	; 192
    2f66:	98 e0       	ldi	r25, 0x08	; 8
    2f68:	fc 01       	movw	r30, r24
    2f6a:	83 81       	ldd	r24, Z+3	; 0x03
    2f6c:	80 93 60 50 	sts	0x5060, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2f70:	80 ec       	ldi	r24, 0xC0	; 192
    2f72:	98 e0       	ldi	r25, 0x08	; 8
    2f74:	20 91 47 40 	lds	r18, 0x4047
    2f78:	fc 01       	movw	r30, r24
    2f7a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f7c:	00 00       	nop
    2f7e:	80 ec       	ldi	r24, 0xC0	; 192
    2f80:	98 e0       	ldi	r25, 0x08	; 8
    2f82:	fc 01       	movw	r30, r24
    2f84:	82 81       	ldd	r24, Z+2	; 0x02
    2f86:	88 23       	and	r24, r24
    2f88:	d4 f7       	brge	.-12     	; 0x2f7e <writeSE2FRAM+0x1a8>
	SPIBuffer[12] = SPIC.DATA;
    2f8a:	80 ec       	ldi	r24, 0xC0	; 192
    2f8c:	98 e0       	ldi	r25, 0x08	; 8
    2f8e:	fc 01       	movw	r30, r24
    2f90:	83 81       	ldd	r24, Z+3	; 0x03
    2f92:	80 93 60 50 	sts	0x5060, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2f96:	80 ec       	ldi	r24, 0xC0	; 192
    2f98:	98 e0       	ldi	r25, 0x08	; 8
    2f9a:	26 e4       	ldi	r18, 0x46	; 70
    2f9c:	30 e4       	ldi	r19, 0x40	; 64
    2f9e:	f9 01       	movw	r30, r18
    2fa0:	20 81       	ld	r18, Z
    2fa2:	fc 01       	movw	r30, r24
    2fa4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fa6:	00 00       	nop
    2fa8:	80 ec       	ldi	r24, 0xC0	; 192
    2faa:	98 e0       	ldi	r25, 0x08	; 8
    2fac:	fc 01       	movw	r30, r24
    2fae:	82 81       	ldd	r24, Z+2	; 0x02
    2fb0:	88 23       	and	r24, r24
    2fb2:	d4 f7       	brge	.-12     	; 0x2fa8 <writeSE2FRAM+0x1d2>
	SPIBuffer[12] = SPIC.DATA;
    2fb4:	80 ec       	ldi	r24, 0xC0	; 192
    2fb6:	98 e0       	ldi	r25, 0x08	; 8
    2fb8:	fc 01       	movw	r30, r24
    2fba:	83 81       	ldd	r24, Z+3	; 0x03
    2fbc:	80 93 60 50 	sts	0x5060, r24
	SPIC.DATA = SPIBuffer[0];
    2fc0:	80 ec       	ldi	r24, 0xC0	; 192
    2fc2:	98 e0       	ldi	r25, 0x08	; 8
    2fc4:	20 91 54 50 	lds	r18, 0x5054
    2fc8:	fc 01       	movw	r30, r24
    2fca:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fcc:	00 00       	nop
    2fce:	80 ec       	ldi	r24, 0xC0	; 192
    2fd0:	98 e0       	ldi	r25, 0x08	; 8
    2fd2:	fc 01       	movw	r30, r24
    2fd4:	82 81       	ldd	r24, Z+2	; 0x02
    2fd6:	88 23       	and	r24, r24
    2fd8:	d4 f7       	brge	.-12     	; 0x2fce <writeSE2FRAM+0x1f8>
	SPIBuffer[12] = SPIC.DATA;
    2fda:	80 ec       	ldi	r24, 0xC0	; 192
    2fdc:	98 e0       	ldi	r25, 0x08	; 8
    2fde:	fc 01       	movw	r30, r24
    2fe0:	83 81       	ldd	r24, Z+3	; 0x03
    2fe2:	80 93 60 50 	sts	0x5060, r24
	SPIC.DATA = SPIBuffer[1];
    2fe6:	80 ec       	ldi	r24, 0xC0	; 192
    2fe8:	98 e0       	ldi	r25, 0x08	; 8
    2fea:	20 91 55 50 	lds	r18, 0x5055
    2fee:	fc 01       	movw	r30, r24
    2ff0:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ff2:	00 00       	nop
    2ff4:	80 ec       	ldi	r24, 0xC0	; 192
    2ff6:	98 e0       	ldi	r25, 0x08	; 8
    2ff8:	fc 01       	movw	r30, r24
    2ffa:	82 81       	ldd	r24, Z+2	; 0x02
    2ffc:	88 23       	and	r24, r24
    2ffe:	d4 f7       	brge	.-12     	; 0x2ff4 <writeSE2FRAM+0x21e>
	SPIBuffer[12] = SPIC.DATA;
    3000:	80 ec       	ldi	r24, 0xC0	; 192
    3002:	98 e0       	ldi	r25, 0x08	; 8
    3004:	fc 01       	movw	r30, r24
    3006:	83 81       	ldd	r24, Z+3	; 0x03
    3008:	80 93 60 50 	sts	0x5060, r24
	SPIC.DATA = SPIBuffer[2];
    300c:	80 ec       	ldi	r24, 0xC0	; 192
    300e:	98 e0       	ldi	r25, 0x08	; 8
    3010:	20 91 56 50 	lds	r18, 0x5056
    3014:	fc 01       	movw	r30, r24
    3016:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3018:	00 00       	nop
    301a:	80 ec       	ldi	r24, 0xC0	; 192
    301c:	98 e0       	ldi	r25, 0x08	; 8
    301e:	fc 01       	movw	r30, r24
    3020:	82 81       	ldd	r24, Z+2	; 0x02
    3022:	88 23       	and	r24, r24
    3024:	d4 f7       	brge	.-12     	; 0x301a <writeSE2FRAM+0x244>
	SPIBuffer[12] = SPIC.DATA;
    3026:	80 ec       	ldi	r24, 0xC0	; 192
    3028:	98 e0       	ldi	r25, 0x08	; 8
    302a:	fc 01       	movw	r30, r24
    302c:	83 81       	ldd	r24, Z+3	; 0x03
    302e:	80 93 60 50 	sts	0x5060, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3032:	80 e2       	ldi	r24, 0x20	; 32
    3034:	96 e0       	ldi	r25, 0x06	; 6
    3036:	28 e0       	ldi	r18, 0x08	; 8
    3038:	fc 01       	movw	r30, r24
    303a:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    303c:	80 e4       	ldi	r24, 0x40	; 64
    303e:	96 e0       	ldi	r25, 0x06	; 6
    3040:	20 e1       	ldi	r18, 0x10	; 16
    3042:	fc 01       	movw	r30, r24
    3044:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    3046:	80 ec       	ldi	r24, 0xC0	; 192
    3048:	98 e0       	ldi	r25, 0x08	; 8
    304a:	24 e5       	ldi	r18, 0x54	; 84
    304c:	fc 01       	movw	r30, r24
    304e:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    3050:	80 e4       	ldi	r24, 0x40	; 64
    3052:	96 e0       	ldi	r25, 0x06	; 6
    3054:	20 e1       	ldi	r18, 0x10	; 16
    3056:	fc 01       	movw	r30, r24
    3058:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    305a:	80 91 46 40 	lds	r24, 0x4046
    305e:	90 91 47 40 	lds	r25, 0x4047
    3062:	03 96       	adiw	r24, 0x03	; 3
    3064:	80 93 46 40 	sts	0x4046, r24
    3068:	90 93 47 40 	sts	0x4047, r25
	checksumADC[0] += SPIBuffer[0];
    306c:	90 91 28 21 	lds	r25, 0x2128
    3070:	80 91 54 50 	lds	r24, 0x5054
    3074:	89 0f       	add	r24, r25
    3076:	80 93 28 21 	sts	0x2128, r24
	checksumADC[1] += SPIBuffer[1];
    307a:	90 91 29 21 	lds	r25, 0x2129
    307e:	80 91 55 50 	lds	r24, 0x5055
    3082:	89 0f       	add	r24, r25
    3084:	80 93 29 21 	sts	0x2129, r24
	checksumADC[2] += SPIBuffer[2];
    3088:	90 91 2a 21 	lds	r25, 0x212A
    308c:	80 91 56 50 	lds	r24, 0x5056
    3090:	89 0f       	add	r24, r25
    3092:	80 93 2a 21 	sts	0x212A, r24
}
    3096:	29 96       	adiw	r28, 0x09	; 9
    3098:	cd bf       	out	0x3d, r28	; 61
    309a:	de bf       	out	0x3e, r29	; 62
    309c:	df 91       	pop	r29
    309e:	cf 91       	pop	r28
    30a0:	08 95       	ret

000030a2 <calcChecksumFRAM>:


void calcChecksumFRAM() {
    30a2:	2f 92       	push	r2
    30a4:	3f 92       	push	r3
    30a6:	4f 92       	push	r4
    30a8:	5f 92       	push	r5
    30aa:	6f 92       	push	r6
    30ac:	7f 92       	push	r7
    30ae:	8f 92       	push	r8
    30b0:	9f 92       	push	r9
    30b2:	af 92       	push	r10
    30b4:	bf 92       	push	r11
    30b6:	cf 92       	push	r12
    30b8:	df 92       	push	r13
    30ba:	ef 92       	push	r14
    30bc:	ff 92       	push	r15
    30be:	0f 93       	push	r16
    30c0:	1f 93       	push	r17
    30c2:	cf 93       	push	r28
    30c4:	df 93       	push	r29
    30c6:	00 d0       	rcall	.+0      	; 0x30c8 <calcChecksumFRAM+0x26>
    30c8:	0f 92       	push	r0
    30ca:	cd b7       	in	r28, 0x3d	; 61
    30cc:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    30ce:	aa 24       	eor	r10, r10
    30d0:	bb 24       	eor	r11, r11
    30d2:	cc 24       	eor	r12, r12
    30d4:	dd 24       	eor	r13, r13
    30d6:	ee 24       	eor	r14, r14
    30d8:	ff 24       	eor	r15, r15
    30da:	00 e0       	ldi	r16, 0x00	; 0
    30dc:	10 e0       	ldi	r17, 0x00	; 0
    30de:	a0 92 86 50 	sts	0x5086, r10
    30e2:	b0 92 87 50 	sts	0x5087, r11
    30e6:	c0 92 88 50 	sts	0x5088, r12
    30ea:	d0 92 89 50 	sts	0x5089, r13
    30ee:	e0 92 8a 50 	sts	0x508A, r14
    30f2:	f0 92 8b 50 	sts	0x508B, r15
    30f6:	00 93 8c 50 	sts	0x508C, r16
    30fa:	10 93 8d 50 	sts	0x508D, r17
    30fe:	2a 2d       	mov	r18, r10
    3100:	3b 2d       	mov	r19, r11
    3102:	4c 2d       	mov	r20, r12
    3104:	5d 2d       	mov	r21, r13
    3106:	6e 2d       	mov	r22, r14
    3108:	7f 2d       	mov	r23, r15
    310a:	80 2f       	mov	r24, r16
    310c:	91 2f       	mov	r25, r17
    310e:	20 93 7e 50 	sts	0x507E, r18
    3112:	30 93 7f 50 	sts	0x507F, r19
    3116:	40 93 80 50 	sts	0x5080, r20
    311a:	50 93 81 50 	sts	0x5081, r21
    311e:	60 93 82 50 	sts	0x5082, r22
    3122:	70 93 83 50 	sts	0x5083, r23
    3126:	80 93 84 50 	sts	0x5084, r24
    312a:	90 93 85 50 	sts	0x5085, r25
    312e:	20 93 76 50 	sts	0x5076, r18
    3132:	30 93 77 50 	sts	0x5077, r19
    3136:	40 93 78 50 	sts	0x5078, r20
    313a:	50 93 79 50 	sts	0x5079, r21
    313e:	60 93 7a 50 	sts	0x507A, r22
    3142:	70 93 7b 50 	sts	0x507B, r23
    3146:	80 93 7c 50 	sts	0x507C, r24
    314a:	90 93 7d 50 	sts	0x507D, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    314e:	80 e0       	ldi	r24, 0x00	; 0
    3150:	80 93 2d 21 	sts	0x212D, r24
    3154:	80 93 2c 21 	sts	0x212C, r24
    3158:	80 93 2b 21 	sts	0x212B, r24
	FRAMAddress = FR_BASEADD;
    315c:	10 92 46 40 	sts	0x4046, r1
    3160:	10 92 47 40 	sts	0x4047, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3164:	19 82       	std	Y+1, r1	; 0x01
    3166:	1a 82       	std	Y+2, r1	; 0x02
    3168:	88 c2       	rjmp	.+1296   	; 0x367a <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    316a:	81 e7       	ldi	r24, 0x71	; 113
    316c:	9c e1       	ldi	r25, 0x1C	; 28
    316e:	0e 94 42 3a 	call	0x7484	; 0x7484 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    3172:	80 91 46 40 	lds	r24, 0x4046
    3176:	90 91 47 40 	lds	r25, 0x4047
    317a:	8f 58       	subi	r24, 0x8F	; 143
    317c:	93 4e       	sbci	r25, 0xE3	; 227
    317e:	80 93 46 40 	sts	0x4046, r24
    3182:	90 93 47 40 	sts	0x4047, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3186:	1b 82       	std	Y+3, r1	; 0x03
    3188:	1c 82       	std	Y+4, r1	; 0x04
    318a:	6b c2       	rjmp	.+1238   	; 0x3662 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    318c:	8b 81       	ldd	r24, Y+3	; 0x03
    318e:	9c 81       	ldd	r25, Y+4	; 0x04
    3190:	23 e0       	ldi	r18, 0x03	; 3
    3192:	30 e0       	ldi	r19, 0x00	; 0
    3194:	b9 01       	movw	r22, r18
    3196:	0e 94 e8 5e 	call	0xbdd0	; 0xbdd0 <__udivmodhi4>
    319a:	9c 01       	movw	r18, r24
    319c:	25 5d       	subi	r18, 0xD5	; 213
    319e:	3e 4d       	sbci	r19, 0xDE	; 222
    31a0:	f9 01       	movw	r30, r18
    31a2:	40 81       	ld	r20, Z
    31a4:	2b 81       	ldd	r18, Y+3	; 0x03
    31a6:	3c 81       	ldd	r19, Y+4	; 0x04
    31a8:	22 53       	subi	r18, 0x32	; 50
    31aa:	3c 4d       	sbci	r19, 0xDC	; 220
    31ac:	f9 01       	movw	r30, r18
    31ae:	20 81       	ld	r18, Z
    31b0:	24 0f       	add	r18, r20
    31b2:	85 5d       	subi	r24, 0xD5	; 213
    31b4:	9e 4d       	sbci	r25, 0xDE	; 222
    31b6:	fc 01       	movw	r30, r24
    31b8:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    31ba:	8b 81       	ldd	r24, Y+3	; 0x03
    31bc:	9c 81       	ldd	r25, Y+4	; 0x04
    31be:	23 e0       	ldi	r18, 0x03	; 3
    31c0:	30 e0       	ldi	r19, 0x00	; 0
    31c2:	b9 01       	movw	r22, r18
    31c4:	0e 94 e8 5e 	call	0xbdd0	; 0xbdd0 <__udivmodhi4>
    31c8:	00 97       	sbiw	r24, 0x00	; 0
    31ca:	09 f0       	breq	.+2      	; 0x31ce <calcChecksumFRAM+0x12c>
    31cc:	44 c0       	rjmp	.+136    	; 0x3256 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    31ce:	8b 81       	ldd	r24, Y+3	; 0x03
    31d0:	9c 81       	ldd	r25, Y+4	; 0x04
    31d2:	82 53       	subi	r24, 0x32	; 50
    31d4:	9c 4d       	sbci	r25, 0xDC	; 220
    31d6:	fc 01       	movw	r30, r24
    31d8:	80 81       	ld	r24, Z
    31da:	88 23       	and	r24, r24
    31dc:	d4 f4       	brge	.+52     	; 0x3212 <calcChecksumFRAM+0x170>
    31de:	80 91 52 50 	lds	r24, 0x5052
    31e2:	90 91 53 50 	lds	r25, 0x5053
    31e6:	fc 01       	movw	r30, r24
    31e8:	10 82       	st	Z, r1
    31ea:	fc 01       	movw	r30, r24
    31ec:	11 82       	std	Z+1, r1	; 0x01
    31ee:	fc 01       	movw	r30, r24
    31f0:	12 82       	std	Z+2, r1	; 0x02
    31f2:	2f ef       	ldi	r18, 0xFF	; 255
    31f4:	fc 01       	movw	r30, r24
    31f6:	23 83       	std	Z+3, r18	; 0x03
    31f8:	2f ef       	ldi	r18, 0xFF	; 255
    31fa:	fc 01       	movw	r30, r24
    31fc:	24 83       	std	Z+4, r18	; 0x04
    31fe:	2f ef       	ldi	r18, 0xFF	; 255
    3200:	fc 01       	movw	r30, r24
    3202:	25 83       	std	Z+5, r18	; 0x05
    3204:	2f ef       	ldi	r18, 0xFF	; 255
    3206:	fc 01       	movw	r30, r24
    3208:	26 83       	std	Z+6, r18	; 0x06
    320a:	2f ef       	ldi	r18, 0xFF	; 255
    320c:	fc 01       	movw	r30, r24
    320e:	27 83       	std	Z+7, r18	; 0x07
    3210:	14 c0       	rjmp	.+40     	; 0x323a <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    3212:	80 91 52 50 	lds	r24, 0x5052
    3216:	90 91 53 50 	lds	r25, 0x5053
    321a:	fc 01       	movw	r30, r24
    321c:	10 82       	st	Z, r1
    321e:	fc 01       	movw	r30, r24
    3220:	11 82       	std	Z+1, r1	; 0x01
    3222:	fc 01       	movw	r30, r24
    3224:	12 82       	std	Z+2, r1	; 0x02
    3226:	fc 01       	movw	r30, r24
    3228:	13 82       	std	Z+3, r1	; 0x03
    322a:	fc 01       	movw	r30, r24
    322c:	14 82       	std	Z+4, r1	; 0x04
    322e:	fc 01       	movw	r30, r24
    3230:	15 82       	std	Z+5, r1	; 0x05
    3232:	fc 01       	movw	r30, r24
    3234:	16 82       	std	Z+6, r1	; 0x06
    3236:	fc 01       	movw	r30, r24
    3238:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    323a:	80 91 52 50 	lds	r24, 0x5052
    323e:	90 91 53 50 	lds	r25, 0x5053
    3242:	02 96       	adiw	r24, 0x02	; 2
    3244:	2b 81       	ldd	r18, Y+3	; 0x03
    3246:	3c 81       	ldd	r19, Y+4	; 0x04
    3248:	22 53       	subi	r18, 0x32	; 50
    324a:	3c 4d       	sbci	r19, 0xDC	; 220
    324c:	f9 01       	movw	r30, r18
    324e:	20 81       	ld	r18, Z
    3250:	fc 01       	movw	r30, r24
    3252:	20 83       	st	Z, r18
    3254:	24 c0       	rjmp	.+72     	; 0x329e <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    3256:	8b 81       	ldd	r24, Y+3	; 0x03
    3258:	9c 81       	ldd	r25, Y+4	; 0x04
    325a:	23 e0       	ldi	r18, 0x03	; 3
    325c:	30 e0       	ldi	r19, 0x00	; 0
    325e:	b9 01       	movw	r22, r18
    3260:	0e 94 e8 5e 	call	0xbdd0	; 0xbdd0 <__udivmodhi4>
    3264:	81 30       	cpi	r24, 0x01	; 1
    3266:	91 05       	cpc	r25, r1
    3268:	71 f4       	brne	.+28     	; 0x3286 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    326a:	80 91 52 50 	lds	r24, 0x5052
    326e:	90 91 53 50 	lds	r25, 0x5053
    3272:	01 96       	adiw	r24, 0x01	; 1
    3274:	2b 81       	ldd	r18, Y+3	; 0x03
    3276:	3c 81       	ldd	r19, Y+4	; 0x04
    3278:	22 53       	subi	r18, 0x32	; 50
    327a:	3c 4d       	sbci	r19, 0xDC	; 220
    327c:	f9 01       	movw	r30, r18
    327e:	20 81       	ld	r18, Z
    3280:	fc 01       	movw	r30, r24
    3282:	20 83       	st	Z, r18
    3284:	0c c0       	rjmp	.+24     	; 0x329e <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    3286:	80 91 52 50 	lds	r24, 0x5052
    328a:	90 91 53 50 	lds	r25, 0x5053
    328e:	2b 81       	ldd	r18, Y+3	; 0x03
    3290:	3c 81       	ldd	r19, Y+4	; 0x04
    3292:	22 53       	subi	r18, 0x32	; 50
    3294:	3c 4d       	sbci	r19, 0xDC	; 220
    3296:	f9 01       	movw	r30, r18
    3298:	20 81       	ld	r18, Z
    329a:	fc 01       	movw	r30, r24
    329c:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    329e:	8b 81       	ldd	r24, Y+3	; 0x03
    32a0:	9c 81       	ldd	r25, Y+4	; 0x04
    32a2:	29 e0       	ldi	r18, 0x09	; 9
    32a4:	30 e0       	ldi	r19, 0x00	; 0
    32a6:	b9 01       	movw	r22, r18
    32a8:	0e 94 e8 5e 	call	0xbdd0	; 0xbdd0 <__udivmodhi4>
    32ac:	82 30       	cpi	r24, 0x02	; 2
    32ae:	91 05       	cpc	r25, r1
    32b0:	09 f0       	breq	.+2      	; 0x32b4 <calcChecksumFRAM+0x212>
    32b2:	94 c0       	rjmp	.+296    	; 0x33dc <calcChecksumFRAM+0x33a>
    32b4:	a0 90 76 50 	lds	r10, 0x5076
    32b8:	b0 90 77 50 	lds	r11, 0x5077
    32bc:	c0 90 78 50 	lds	r12, 0x5078
    32c0:	d0 90 79 50 	lds	r13, 0x5079
    32c4:	e0 90 7a 50 	lds	r14, 0x507A
    32c8:	f0 90 7b 50 	lds	r15, 0x507B
    32cc:	00 91 7c 50 	lds	r16, 0x507C
    32d0:	10 91 7d 50 	lds	r17, 0x507D
    32d4:	80 91 52 50 	lds	r24, 0x5052
    32d8:	90 91 53 50 	lds	r25, 0x5053
    32dc:	fc 01       	movw	r30, r24
    32de:	20 80       	ld	r2, Z
    32e0:	fc 01       	movw	r30, r24
    32e2:	31 80       	ldd	r3, Z+1	; 0x01
    32e4:	fc 01       	movw	r30, r24
    32e6:	42 80       	ldd	r4, Z+2	; 0x02
    32e8:	fc 01       	movw	r30, r24
    32ea:	53 80       	ldd	r5, Z+3	; 0x03
    32ec:	fc 01       	movw	r30, r24
    32ee:	64 80       	ldd	r6, Z+4	; 0x04
    32f0:	fc 01       	movw	r30, r24
    32f2:	75 80       	ldd	r7, Z+5	; 0x05
    32f4:	fc 01       	movw	r30, r24
    32f6:	86 80       	ldd	r8, Z+6	; 0x06
    32f8:	fc 01       	movw	r30, r24
    32fa:	97 80       	ldd	r9, Z+7	; 0x07
    32fc:	2a 2d       	mov	r18, r10
    32fe:	22 0d       	add	r18, r2
    3300:	e1 e0       	ldi	r30, 0x01	; 1
    3302:	2a 15       	cp	r18, r10
    3304:	08 f0       	brcs	.+2      	; 0x3308 <calcChecksumFRAM+0x266>
    3306:	e0 e0       	ldi	r30, 0x00	; 0
    3308:	3b 2d       	mov	r19, r11
    330a:	33 0d       	add	r19, r3
    330c:	f1 e0       	ldi	r31, 0x01	; 1
    330e:	3b 15       	cp	r19, r11
    3310:	08 f0       	brcs	.+2      	; 0x3314 <calcChecksumFRAM+0x272>
    3312:	f0 e0       	ldi	r31, 0x00	; 0
    3314:	e3 0f       	add	r30, r19
    3316:	a1 e0       	ldi	r26, 0x01	; 1
    3318:	e3 17       	cp	r30, r19
    331a:	08 f0       	brcs	.+2      	; 0x331e <calcChecksumFRAM+0x27c>
    331c:	a0 e0       	ldi	r26, 0x00	; 0
    331e:	fa 2b       	or	r31, r26
    3320:	3e 2f       	mov	r19, r30
    3322:	4c 2d       	mov	r20, r12
    3324:	44 0d       	add	r20, r4
    3326:	e1 e0       	ldi	r30, 0x01	; 1
    3328:	4c 15       	cp	r20, r12
    332a:	08 f0       	brcs	.+2      	; 0x332e <calcChecksumFRAM+0x28c>
    332c:	e0 e0       	ldi	r30, 0x00	; 0
    332e:	f4 0f       	add	r31, r20
    3330:	a1 e0       	ldi	r26, 0x01	; 1
    3332:	f4 17       	cp	r31, r20
    3334:	08 f0       	brcs	.+2      	; 0x3338 <calcChecksumFRAM+0x296>
    3336:	a0 e0       	ldi	r26, 0x00	; 0
    3338:	ea 2b       	or	r30, r26
    333a:	4f 2f       	mov	r20, r31
    333c:	5d 2d       	mov	r21, r13
    333e:	55 0d       	add	r21, r5
    3340:	f1 e0       	ldi	r31, 0x01	; 1
    3342:	5d 15       	cp	r21, r13
    3344:	08 f0       	brcs	.+2      	; 0x3348 <calcChecksumFRAM+0x2a6>
    3346:	f0 e0       	ldi	r31, 0x00	; 0
    3348:	e5 0f       	add	r30, r21
    334a:	a1 e0       	ldi	r26, 0x01	; 1
    334c:	e5 17       	cp	r30, r21
    334e:	08 f0       	brcs	.+2      	; 0x3352 <calcChecksumFRAM+0x2b0>
    3350:	a0 e0       	ldi	r26, 0x00	; 0
    3352:	fa 2b       	or	r31, r26
    3354:	5e 2f       	mov	r21, r30
    3356:	6e 2d       	mov	r22, r14
    3358:	66 0d       	add	r22, r6
    335a:	e1 e0       	ldi	r30, 0x01	; 1
    335c:	6e 15       	cp	r22, r14
    335e:	08 f0       	brcs	.+2      	; 0x3362 <calcChecksumFRAM+0x2c0>
    3360:	e0 e0       	ldi	r30, 0x00	; 0
    3362:	f6 0f       	add	r31, r22
    3364:	a1 e0       	ldi	r26, 0x01	; 1
    3366:	f6 17       	cp	r31, r22
    3368:	08 f0       	brcs	.+2      	; 0x336c <calcChecksumFRAM+0x2ca>
    336a:	a0 e0       	ldi	r26, 0x00	; 0
    336c:	ea 2b       	or	r30, r26
    336e:	6f 2f       	mov	r22, r31
    3370:	7f 2d       	mov	r23, r15
    3372:	77 0d       	add	r23, r7
    3374:	f1 e0       	ldi	r31, 0x01	; 1
    3376:	7f 15       	cp	r23, r15
    3378:	08 f0       	brcs	.+2      	; 0x337c <calcChecksumFRAM+0x2da>
    337a:	f0 e0       	ldi	r31, 0x00	; 0
    337c:	e7 0f       	add	r30, r23
    337e:	a1 e0       	ldi	r26, 0x01	; 1
    3380:	e7 17       	cp	r30, r23
    3382:	08 f0       	brcs	.+2      	; 0x3386 <calcChecksumFRAM+0x2e4>
    3384:	a0 e0       	ldi	r26, 0x00	; 0
    3386:	fa 2b       	or	r31, r26
    3388:	7e 2f       	mov	r23, r30
    338a:	80 2f       	mov	r24, r16
    338c:	88 0d       	add	r24, r8
    338e:	e1 e0       	ldi	r30, 0x01	; 1
    3390:	80 17       	cp	r24, r16
    3392:	08 f0       	brcs	.+2      	; 0x3396 <calcChecksumFRAM+0x2f4>
    3394:	e0 e0       	ldi	r30, 0x00	; 0
    3396:	f8 0f       	add	r31, r24
    3398:	a1 e0       	ldi	r26, 0x01	; 1
    339a:	f8 17       	cp	r31, r24
    339c:	08 f0       	brcs	.+2      	; 0x33a0 <calcChecksumFRAM+0x2fe>
    339e:	a0 e0       	ldi	r26, 0x00	; 0
    33a0:	ea 2b       	or	r30, r26
    33a2:	8f 2f       	mov	r24, r31
    33a4:	91 2f       	mov	r25, r17
    33a6:	99 0d       	add	r25, r9
    33a8:	e9 0f       	add	r30, r25
    33aa:	9e 2f       	mov	r25, r30
    33ac:	a2 2e       	mov	r10, r18
    33ae:	b3 2e       	mov	r11, r19
    33b0:	c4 2e       	mov	r12, r20
    33b2:	d5 2e       	mov	r13, r21
    33b4:	e6 2e       	mov	r14, r22
    33b6:	f7 2e       	mov	r15, r23
    33b8:	08 2f       	mov	r16, r24
    33ba:	19 2f       	mov	r17, r25
    33bc:	a0 92 76 50 	sts	0x5076, r10
    33c0:	b0 92 77 50 	sts	0x5077, r11
    33c4:	c0 92 78 50 	sts	0x5078, r12
    33c8:	d0 92 79 50 	sts	0x5079, r13
    33cc:	e0 92 7a 50 	sts	0x507A, r14
    33d0:	f0 92 7b 50 	sts	0x507B, r15
    33d4:	00 93 7c 50 	sts	0x507C, r16
    33d8:	10 93 7d 50 	sts	0x507D, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    33dc:	8b 81       	ldd	r24, Y+3	; 0x03
    33de:	9c 81       	ldd	r25, Y+4	; 0x04
    33e0:	29 e0       	ldi	r18, 0x09	; 9
    33e2:	30 e0       	ldi	r19, 0x00	; 0
    33e4:	b9 01       	movw	r22, r18
    33e6:	0e 94 e8 5e 	call	0xbdd0	; 0xbdd0 <__udivmodhi4>
    33ea:	85 30       	cpi	r24, 0x05	; 5
    33ec:	91 05       	cpc	r25, r1
    33ee:	09 f0       	breq	.+2      	; 0x33f2 <calcChecksumFRAM+0x350>
    33f0:	94 c0       	rjmp	.+296    	; 0x351a <calcChecksumFRAM+0x478>
    33f2:	a0 90 7e 50 	lds	r10, 0x507E
    33f6:	b0 90 7f 50 	lds	r11, 0x507F
    33fa:	c0 90 80 50 	lds	r12, 0x5080
    33fe:	d0 90 81 50 	lds	r13, 0x5081
    3402:	e0 90 82 50 	lds	r14, 0x5082
    3406:	f0 90 83 50 	lds	r15, 0x5083
    340a:	00 91 84 50 	lds	r16, 0x5084
    340e:	10 91 85 50 	lds	r17, 0x5085
    3412:	80 91 52 50 	lds	r24, 0x5052
    3416:	90 91 53 50 	lds	r25, 0x5053
    341a:	fc 01       	movw	r30, r24
    341c:	20 80       	ld	r2, Z
    341e:	fc 01       	movw	r30, r24
    3420:	31 80       	ldd	r3, Z+1	; 0x01
    3422:	fc 01       	movw	r30, r24
    3424:	42 80       	ldd	r4, Z+2	; 0x02
    3426:	fc 01       	movw	r30, r24
    3428:	53 80       	ldd	r5, Z+3	; 0x03
    342a:	fc 01       	movw	r30, r24
    342c:	64 80       	ldd	r6, Z+4	; 0x04
    342e:	fc 01       	movw	r30, r24
    3430:	75 80       	ldd	r7, Z+5	; 0x05
    3432:	fc 01       	movw	r30, r24
    3434:	86 80       	ldd	r8, Z+6	; 0x06
    3436:	fc 01       	movw	r30, r24
    3438:	97 80       	ldd	r9, Z+7	; 0x07
    343a:	2a 2d       	mov	r18, r10
    343c:	22 0d       	add	r18, r2
    343e:	e1 e0       	ldi	r30, 0x01	; 1
    3440:	2a 15       	cp	r18, r10
    3442:	08 f0       	brcs	.+2      	; 0x3446 <calcChecksumFRAM+0x3a4>
    3444:	e0 e0       	ldi	r30, 0x00	; 0
    3446:	3b 2d       	mov	r19, r11
    3448:	33 0d       	add	r19, r3
    344a:	f1 e0       	ldi	r31, 0x01	; 1
    344c:	3b 15       	cp	r19, r11
    344e:	08 f0       	brcs	.+2      	; 0x3452 <calcChecksumFRAM+0x3b0>
    3450:	f0 e0       	ldi	r31, 0x00	; 0
    3452:	e3 0f       	add	r30, r19
    3454:	a1 e0       	ldi	r26, 0x01	; 1
    3456:	e3 17       	cp	r30, r19
    3458:	08 f0       	brcs	.+2      	; 0x345c <calcChecksumFRAM+0x3ba>
    345a:	a0 e0       	ldi	r26, 0x00	; 0
    345c:	fa 2b       	or	r31, r26
    345e:	3e 2f       	mov	r19, r30
    3460:	4c 2d       	mov	r20, r12
    3462:	44 0d       	add	r20, r4
    3464:	e1 e0       	ldi	r30, 0x01	; 1
    3466:	4c 15       	cp	r20, r12
    3468:	08 f0       	brcs	.+2      	; 0x346c <calcChecksumFRAM+0x3ca>
    346a:	e0 e0       	ldi	r30, 0x00	; 0
    346c:	f4 0f       	add	r31, r20
    346e:	a1 e0       	ldi	r26, 0x01	; 1
    3470:	f4 17       	cp	r31, r20
    3472:	08 f0       	brcs	.+2      	; 0x3476 <calcChecksumFRAM+0x3d4>
    3474:	a0 e0       	ldi	r26, 0x00	; 0
    3476:	ea 2b       	or	r30, r26
    3478:	4f 2f       	mov	r20, r31
    347a:	5d 2d       	mov	r21, r13
    347c:	55 0d       	add	r21, r5
    347e:	f1 e0       	ldi	r31, 0x01	; 1
    3480:	5d 15       	cp	r21, r13
    3482:	08 f0       	brcs	.+2      	; 0x3486 <calcChecksumFRAM+0x3e4>
    3484:	f0 e0       	ldi	r31, 0x00	; 0
    3486:	e5 0f       	add	r30, r21
    3488:	a1 e0       	ldi	r26, 0x01	; 1
    348a:	e5 17       	cp	r30, r21
    348c:	08 f0       	brcs	.+2      	; 0x3490 <calcChecksumFRAM+0x3ee>
    348e:	a0 e0       	ldi	r26, 0x00	; 0
    3490:	fa 2b       	or	r31, r26
    3492:	5e 2f       	mov	r21, r30
    3494:	6e 2d       	mov	r22, r14
    3496:	66 0d       	add	r22, r6
    3498:	e1 e0       	ldi	r30, 0x01	; 1
    349a:	6e 15       	cp	r22, r14
    349c:	08 f0       	brcs	.+2      	; 0x34a0 <calcChecksumFRAM+0x3fe>
    349e:	e0 e0       	ldi	r30, 0x00	; 0
    34a0:	f6 0f       	add	r31, r22
    34a2:	a1 e0       	ldi	r26, 0x01	; 1
    34a4:	f6 17       	cp	r31, r22
    34a6:	08 f0       	brcs	.+2      	; 0x34aa <calcChecksumFRAM+0x408>
    34a8:	a0 e0       	ldi	r26, 0x00	; 0
    34aa:	ea 2b       	or	r30, r26
    34ac:	6f 2f       	mov	r22, r31
    34ae:	7f 2d       	mov	r23, r15
    34b0:	77 0d       	add	r23, r7
    34b2:	f1 e0       	ldi	r31, 0x01	; 1
    34b4:	7f 15       	cp	r23, r15
    34b6:	08 f0       	brcs	.+2      	; 0x34ba <calcChecksumFRAM+0x418>
    34b8:	f0 e0       	ldi	r31, 0x00	; 0
    34ba:	e7 0f       	add	r30, r23
    34bc:	a1 e0       	ldi	r26, 0x01	; 1
    34be:	e7 17       	cp	r30, r23
    34c0:	08 f0       	brcs	.+2      	; 0x34c4 <calcChecksumFRAM+0x422>
    34c2:	a0 e0       	ldi	r26, 0x00	; 0
    34c4:	fa 2b       	or	r31, r26
    34c6:	7e 2f       	mov	r23, r30
    34c8:	80 2f       	mov	r24, r16
    34ca:	88 0d       	add	r24, r8
    34cc:	e1 e0       	ldi	r30, 0x01	; 1
    34ce:	80 17       	cp	r24, r16
    34d0:	08 f0       	brcs	.+2      	; 0x34d4 <calcChecksumFRAM+0x432>
    34d2:	e0 e0       	ldi	r30, 0x00	; 0
    34d4:	f8 0f       	add	r31, r24
    34d6:	a1 e0       	ldi	r26, 0x01	; 1
    34d8:	f8 17       	cp	r31, r24
    34da:	08 f0       	brcs	.+2      	; 0x34de <calcChecksumFRAM+0x43c>
    34dc:	a0 e0       	ldi	r26, 0x00	; 0
    34de:	ea 2b       	or	r30, r26
    34e0:	8f 2f       	mov	r24, r31
    34e2:	91 2f       	mov	r25, r17
    34e4:	99 0d       	add	r25, r9
    34e6:	e9 0f       	add	r30, r25
    34e8:	9e 2f       	mov	r25, r30
    34ea:	a2 2e       	mov	r10, r18
    34ec:	b3 2e       	mov	r11, r19
    34ee:	c4 2e       	mov	r12, r20
    34f0:	d5 2e       	mov	r13, r21
    34f2:	e6 2e       	mov	r14, r22
    34f4:	f7 2e       	mov	r15, r23
    34f6:	08 2f       	mov	r16, r24
    34f8:	19 2f       	mov	r17, r25
    34fa:	a0 92 7e 50 	sts	0x507E, r10
    34fe:	b0 92 7f 50 	sts	0x507F, r11
    3502:	c0 92 80 50 	sts	0x5080, r12
    3506:	d0 92 81 50 	sts	0x5081, r13
    350a:	e0 92 82 50 	sts	0x5082, r14
    350e:	f0 92 83 50 	sts	0x5083, r15
    3512:	00 93 84 50 	sts	0x5084, r16
    3516:	10 93 85 50 	sts	0x5085, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    351a:	8b 81       	ldd	r24, Y+3	; 0x03
    351c:	9c 81       	ldd	r25, Y+4	; 0x04
    351e:	29 e0       	ldi	r18, 0x09	; 9
    3520:	30 e0       	ldi	r19, 0x00	; 0
    3522:	b9 01       	movw	r22, r18
    3524:	0e 94 e8 5e 	call	0xbdd0	; 0xbdd0 <__udivmodhi4>
    3528:	88 30       	cpi	r24, 0x08	; 8
    352a:	91 05       	cpc	r25, r1
    352c:	09 f0       	breq	.+2      	; 0x3530 <calcChecksumFRAM+0x48e>
    352e:	94 c0       	rjmp	.+296    	; 0x3658 <calcChecksumFRAM+0x5b6>
    3530:	a0 90 86 50 	lds	r10, 0x5086
    3534:	b0 90 87 50 	lds	r11, 0x5087
    3538:	c0 90 88 50 	lds	r12, 0x5088
    353c:	d0 90 89 50 	lds	r13, 0x5089
    3540:	e0 90 8a 50 	lds	r14, 0x508A
    3544:	f0 90 8b 50 	lds	r15, 0x508B
    3548:	00 91 8c 50 	lds	r16, 0x508C
    354c:	10 91 8d 50 	lds	r17, 0x508D
    3550:	80 91 52 50 	lds	r24, 0x5052
    3554:	90 91 53 50 	lds	r25, 0x5053
    3558:	fc 01       	movw	r30, r24
    355a:	20 80       	ld	r2, Z
    355c:	fc 01       	movw	r30, r24
    355e:	31 80       	ldd	r3, Z+1	; 0x01
    3560:	fc 01       	movw	r30, r24
    3562:	42 80       	ldd	r4, Z+2	; 0x02
    3564:	fc 01       	movw	r30, r24
    3566:	53 80       	ldd	r5, Z+3	; 0x03
    3568:	fc 01       	movw	r30, r24
    356a:	64 80       	ldd	r6, Z+4	; 0x04
    356c:	fc 01       	movw	r30, r24
    356e:	75 80       	ldd	r7, Z+5	; 0x05
    3570:	fc 01       	movw	r30, r24
    3572:	86 80       	ldd	r8, Z+6	; 0x06
    3574:	fc 01       	movw	r30, r24
    3576:	97 80       	ldd	r9, Z+7	; 0x07
    3578:	2a 2d       	mov	r18, r10
    357a:	22 0d       	add	r18, r2
    357c:	e1 e0       	ldi	r30, 0x01	; 1
    357e:	2a 15       	cp	r18, r10
    3580:	08 f0       	brcs	.+2      	; 0x3584 <calcChecksumFRAM+0x4e2>
    3582:	e0 e0       	ldi	r30, 0x00	; 0
    3584:	3b 2d       	mov	r19, r11
    3586:	33 0d       	add	r19, r3
    3588:	f1 e0       	ldi	r31, 0x01	; 1
    358a:	3b 15       	cp	r19, r11
    358c:	08 f0       	brcs	.+2      	; 0x3590 <calcChecksumFRAM+0x4ee>
    358e:	f0 e0       	ldi	r31, 0x00	; 0
    3590:	e3 0f       	add	r30, r19
    3592:	a1 e0       	ldi	r26, 0x01	; 1
    3594:	e3 17       	cp	r30, r19
    3596:	08 f0       	brcs	.+2      	; 0x359a <calcChecksumFRAM+0x4f8>
    3598:	a0 e0       	ldi	r26, 0x00	; 0
    359a:	fa 2b       	or	r31, r26
    359c:	3e 2f       	mov	r19, r30
    359e:	4c 2d       	mov	r20, r12
    35a0:	44 0d       	add	r20, r4
    35a2:	e1 e0       	ldi	r30, 0x01	; 1
    35a4:	4c 15       	cp	r20, r12
    35a6:	08 f0       	brcs	.+2      	; 0x35aa <calcChecksumFRAM+0x508>
    35a8:	e0 e0       	ldi	r30, 0x00	; 0
    35aa:	f4 0f       	add	r31, r20
    35ac:	a1 e0       	ldi	r26, 0x01	; 1
    35ae:	f4 17       	cp	r31, r20
    35b0:	08 f0       	brcs	.+2      	; 0x35b4 <calcChecksumFRAM+0x512>
    35b2:	a0 e0       	ldi	r26, 0x00	; 0
    35b4:	ea 2b       	or	r30, r26
    35b6:	4f 2f       	mov	r20, r31
    35b8:	5d 2d       	mov	r21, r13
    35ba:	55 0d       	add	r21, r5
    35bc:	f1 e0       	ldi	r31, 0x01	; 1
    35be:	5d 15       	cp	r21, r13
    35c0:	08 f0       	brcs	.+2      	; 0x35c4 <calcChecksumFRAM+0x522>
    35c2:	f0 e0       	ldi	r31, 0x00	; 0
    35c4:	e5 0f       	add	r30, r21
    35c6:	a1 e0       	ldi	r26, 0x01	; 1
    35c8:	e5 17       	cp	r30, r21
    35ca:	08 f0       	brcs	.+2      	; 0x35ce <calcChecksumFRAM+0x52c>
    35cc:	a0 e0       	ldi	r26, 0x00	; 0
    35ce:	fa 2b       	or	r31, r26
    35d0:	5e 2f       	mov	r21, r30
    35d2:	6e 2d       	mov	r22, r14
    35d4:	66 0d       	add	r22, r6
    35d6:	e1 e0       	ldi	r30, 0x01	; 1
    35d8:	6e 15       	cp	r22, r14
    35da:	08 f0       	brcs	.+2      	; 0x35de <calcChecksumFRAM+0x53c>
    35dc:	e0 e0       	ldi	r30, 0x00	; 0
    35de:	f6 0f       	add	r31, r22
    35e0:	a1 e0       	ldi	r26, 0x01	; 1
    35e2:	f6 17       	cp	r31, r22
    35e4:	08 f0       	brcs	.+2      	; 0x35e8 <calcChecksumFRAM+0x546>
    35e6:	a0 e0       	ldi	r26, 0x00	; 0
    35e8:	ea 2b       	or	r30, r26
    35ea:	6f 2f       	mov	r22, r31
    35ec:	7f 2d       	mov	r23, r15
    35ee:	77 0d       	add	r23, r7
    35f0:	f1 e0       	ldi	r31, 0x01	; 1
    35f2:	7f 15       	cp	r23, r15
    35f4:	08 f0       	brcs	.+2      	; 0x35f8 <calcChecksumFRAM+0x556>
    35f6:	f0 e0       	ldi	r31, 0x00	; 0
    35f8:	e7 0f       	add	r30, r23
    35fa:	a1 e0       	ldi	r26, 0x01	; 1
    35fc:	e7 17       	cp	r30, r23
    35fe:	08 f0       	brcs	.+2      	; 0x3602 <calcChecksumFRAM+0x560>
    3600:	a0 e0       	ldi	r26, 0x00	; 0
    3602:	fa 2b       	or	r31, r26
    3604:	7e 2f       	mov	r23, r30
    3606:	80 2f       	mov	r24, r16
    3608:	88 0d       	add	r24, r8
    360a:	e1 e0       	ldi	r30, 0x01	; 1
    360c:	80 17       	cp	r24, r16
    360e:	08 f0       	brcs	.+2      	; 0x3612 <calcChecksumFRAM+0x570>
    3610:	e0 e0       	ldi	r30, 0x00	; 0
    3612:	f8 0f       	add	r31, r24
    3614:	a1 e0       	ldi	r26, 0x01	; 1
    3616:	f8 17       	cp	r31, r24
    3618:	08 f0       	brcs	.+2      	; 0x361c <calcChecksumFRAM+0x57a>
    361a:	a0 e0       	ldi	r26, 0x00	; 0
    361c:	ea 2b       	or	r30, r26
    361e:	8f 2f       	mov	r24, r31
    3620:	91 2f       	mov	r25, r17
    3622:	99 0d       	add	r25, r9
    3624:	e9 0f       	add	r30, r25
    3626:	9e 2f       	mov	r25, r30
    3628:	a2 2e       	mov	r10, r18
    362a:	b3 2e       	mov	r11, r19
    362c:	c4 2e       	mov	r12, r20
    362e:	d5 2e       	mov	r13, r21
    3630:	e6 2e       	mov	r14, r22
    3632:	f7 2e       	mov	r15, r23
    3634:	08 2f       	mov	r16, r24
    3636:	19 2f       	mov	r17, r25
    3638:	a0 92 86 50 	sts	0x5086, r10
    363c:	b0 92 87 50 	sts	0x5087, r11
    3640:	c0 92 88 50 	sts	0x5088, r12
    3644:	d0 92 89 50 	sts	0x5089, r13
    3648:	e0 92 8a 50 	sts	0x508A, r14
    364c:	f0 92 8b 50 	sts	0x508B, r15
    3650:	00 93 8c 50 	sts	0x508C, r16
    3654:	10 93 8d 50 	sts	0x508D, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3658:	8b 81       	ldd	r24, Y+3	; 0x03
    365a:	9c 81       	ldd	r25, Y+4	; 0x04
    365c:	01 96       	adiw	r24, 0x01	; 1
    365e:	8b 83       	std	Y+3, r24	; 0x03
    3660:	9c 83       	std	Y+4, r25	; 0x04
    3662:	8b 81       	ldd	r24, Y+3	; 0x03
    3664:	9c 81       	ldd	r25, Y+4	; 0x04
    3666:	fc e1       	ldi	r31, 0x1C	; 28
    3668:	81 37       	cpi	r24, 0x71	; 113
    366a:	9f 07       	cpc	r25, r31
    366c:	08 f4       	brcc	.+2      	; 0x3670 <calcChecksumFRAM+0x5ce>
    366e:	8e cd       	rjmp	.-1252   	; 0x318c <calcChecksumFRAM+0xea>

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3670:	89 81       	ldd	r24, Y+1	; 0x01
    3672:	9a 81       	ldd	r25, Y+2	; 0x02
    3674:	01 96       	adiw	r24, 0x01	; 1
    3676:	89 83       	std	Y+1, r24	; 0x01
    3678:	9a 83       	std	Y+2, r25	; 0x02
    367a:	89 81       	ldd	r24, Y+1	; 0x01
    367c:	9a 81       	ldd	r25, Y+2	; 0x02
    367e:	89 30       	cpi	r24, 0x09	; 9
    3680:	91 05       	cpc	r25, r1
    3682:	08 f4       	brcc	.+2      	; 0x3686 <calcChecksumFRAM+0x5e4>
    3684:	72 cd       	rjmp	.-1308   	; 0x316a <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3686:	24 96       	adiw	r28, 0x04	; 4
    3688:	cd bf       	out	0x3d, r28	; 61
    368a:	de bf       	out	0x3e, r29	; 62
    368c:	df 91       	pop	r29
    368e:	cf 91       	pop	r28
    3690:	1f 91       	pop	r17
    3692:	0f 91       	pop	r16
    3694:	ff 90       	pop	r15
    3696:	ef 90       	pop	r14
    3698:	df 90       	pop	r13
    369a:	cf 90       	pop	r12
    369c:	bf 90       	pop	r11
    369e:	af 90       	pop	r10
    36a0:	9f 90       	pop	r9
    36a2:	8f 90       	pop	r8
    36a4:	7f 90       	pop	r7
    36a6:	6f 90       	pop	r6
    36a8:	5f 90       	pop	r5
    36aa:	4f 90       	pop	r4
    36ac:	3f 90       	pop	r3
    36ae:	2f 90       	pop	r2
    36b0:	08 95       	ret

000036b2 <FRAMWriteKnowns>:


void FRAMWriteKnowns() {
    36b2:	cf 93       	push	r28
    36b4:	df 93       	push	r29
    36b6:	cd b7       	in	r28, 0x3d	; 61
    36b8:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    36ba:	10 92 46 40 	sts	0x4046, r1
    36be:	10 92 47 40 	sts	0x4047, r1
	sampleCount = 0;
    36c2:	10 92 61 50 	sts	0x5061, r1
    36c6:	10 92 62 50 	sts	0x5062, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    36ca:	80 e0       	ldi	r24, 0x00	; 0
    36cc:	80 93 2a 21 	sts	0x212A, r24
    36d0:	80 93 29 21 	sts	0x2129, r24
    36d4:	80 93 28 21 	sts	0x2128, r24
	
	ADCPower(TRUE);
    36d8:	81 e0       	ldi	r24, 0x01	; 1
    36da:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    36de:	84 e0       	ldi	r24, 0x04	; 4
    36e0:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    36e4:	80 ec       	ldi	r24, 0xC0	; 192
    36e6:	98 e0       	ldi	r25, 0x08	; 8
    36e8:	20 ed       	ldi	r18, 0xD0	; 208
    36ea:	fc 01       	movw	r30, r24
    36ec:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    36ee:	8d e0       	ldi	r24, 0x0D	; 13
    36f0:	80 93 54 50 	sts	0x5054, r24
	SPIBuffer[1] = 0xF3;
    36f4:	83 ef       	ldi	r24, 0xF3	; 243
    36f6:	80 93 55 50 	sts	0x5055, r24
	SPIBuffer[2] = 0x57;
    36fa:	87 e5       	ldi	r24, 0x57	; 87
    36fc:	80 93 56 50 	sts	0x5056, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3700:	cd c0       	rjmp	.+410    	; 0x389c <FRAMWriteKnowns+0x1ea>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    3702:	80 e4       	ldi	r24, 0x40	; 64
    3704:	96 e0       	ldi	r25, 0x06	; 6
    3706:	20 e1       	ldi	r18, 0x10	; 16
    3708:	fc 01       	movw	r30, r24
    370a:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    370c:	80 e2       	ldi	r24, 0x20	; 32
    370e:	96 e0       	ldi	r25, 0x06	; 6
    3710:	28 e0       	ldi	r18, 0x08	; 8
    3712:	fc 01       	movw	r30, r24
    3714:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3716:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3718:	80 ec       	ldi	r24, 0xC0	; 192
    371a:	98 e0       	ldi	r25, 0x08	; 8
    371c:	26 e0       	ldi	r18, 0x06	; 6
    371e:	fc 01       	movw	r30, r24
    3720:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3722:	00 00       	nop
    3724:	80 ec       	ldi	r24, 0xC0	; 192
    3726:	98 e0       	ldi	r25, 0x08	; 8
    3728:	fc 01       	movw	r30, r24
    372a:	82 81       	ldd	r24, Z+2	; 0x02
    372c:	88 23       	and	r24, r24
    372e:	d4 f7       	brge	.-12     	; 0x3724 <FRAMWriteKnowns+0x72>
		SPIBuffer[12] = SPIC.DATA;
    3730:	80 ec       	ldi	r24, 0xC0	; 192
    3732:	98 e0       	ldi	r25, 0x08	; 8
    3734:	fc 01       	movw	r30, r24
    3736:	83 81       	ldd	r24, Z+3	; 0x03
    3738:	80 93 60 50 	sts	0x5060, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    373c:	80 e2       	ldi	r24, 0x20	; 32
    373e:	96 e0       	ldi	r25, 0x06	; 6
    3740:	28 e0       	ldi	r18, 0x08	; 8
    3742:	fc 01       	movw	r30, r24
    3744:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    3746:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3748:	80 e2       	ldi	r24, 0x20	; 32
    374a:	96 e0       	ldi	r25, 0x06	; 6
    374c:	28 e0       	ldi	r18, 0x08	; 8
    374e:	fc 01       	movw	r30, r24
    3750:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3752:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    3754:	80 ec       	ldi	r24, 0xC0	; 192
    3756:	98 e0       	ldi	r25, 0x08	; 8
    3758:	22 e0       	ldi	r18, 0x02	; 2
    375a:	fc 01       	movw	r30, r24
    375c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    375e:	00 00       	nop
    3760:	80 ec       	ldi	r24, 0xC0	; 192
    3762:	98 e0       	ldi	r25, 0x08	; 8
    3764:	fc 01       	movw	r30, r24
    3766:	82 81       	ldd	r24, Z+2	; 0x02
    3768:	88 23       	and	r24, r24
    376a:	d4 f7       	brge	.-12     	; 0x3760 <FRAMWriteKnowns+0xae>
		SPIBuffer[12] = SPIC.DATA;
    376c:	80 ec       	ldi	r24, 0xC0	; 192
    376e:	98 e0       	ldi	r25, 0x08	; 8
    3770:	fc 01       	movw	r30, r24
    3772:	83 81       	ldd	r24, Z+3	; 0x03
    3774:	80 93 60 50 	sts	0x5060, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    3778:	80 ec       	ldi	r24, 0xC0	; 192
    377a:	98 e0       	ldi	r25, 0x08	; 8
    377c:	20 91 47 40 	lds	r18, 0x4047
    3780:	fc 01       	movw	r30, r24
    3782:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3784:	00 00       	nop
    3786:	80 ec       	ldi	r24, 0xC0	; 192
    3788:	98 e0       	ldi	r25, 0x08	; 8
    378a:	fc 01       	movw	r30, r24
    378c:	82 81       	ldd	r24, Z+2	; 0x02
    378e:	88 23       	and	r24, r24
    3790:	d4 f7       	brge	.-12     	; 0x3786 <FRAMWriteKnowns+0xd4>
		SPIBuffer[12] = SPIC.DATA;
    3792:	80 ec       	ldi	r24, 0xC0	; 192
    3794:	98 e0       	ldi	r25, 0x08	; 8
    3796:	fc 01       	movw	r30, r24
    3798:	83 81       	ldd	r24, Z+3	; 0x03
    379a:	80 93 60 50 	sts	0x5060, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    379e:	80 ec       	ldi	r24, 0xC0	; 192
    37a0:	98 e0       	ldi	r25, 0x08	; 8
    37a2:	26 e4       	ldi	r18, 0x46	; 70
    37a4:	30 e4       	ldi	r19, 0x40	; 64
    37a6:	f9 01       	movw	r30, r18
    37a8:	20 81       	ld	r18, Z
    37aa:	fc 01       	movw	r30, r24
    37ac:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37ae:	00 00       	nop
    37b0:	80 ec       	ldi	r24, 0xC0	; 192
    37b2:	98 e0       	ldi	r25, 0x08	; 8
    37b4:	fc 01       	movw	r30, r24
    37b6:	82 81       	ldd	r24, Z+2	; 0x02
    37b8:	88 23       	and	r24, r24
    37ba:	d4 f7       	brge	.-12     	; 0x37b0 <FRAMWriteKnowns+0xfe>
		SPIBuffer[12] = SPIC.DATA;
    37bc:	80 ec       	ldi	r24, 0xC0	; 192
    37be:	98 e0       	ldi	r25, 0x08	; 8
    37c0:	fc 01       	movw	r30, r24
    37c2:	83 81       	ldd	r24, Z+3	; 0x03
    37c4:	80 93 60 50 	sts	0x5060, r24
		SPIC.DATA = SPIBuffer[0];
    37c8:	80 ec       	ldi	r24, 0xC0	; 192
    37ca:	98 e0       	ldi	r25, 0x08	; 8
    37cc:	20 91 54 50 	lds	r18, 0x5054
    37d0:	fc 01       	movw	r30, r24
    37d2:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37d4:	00 00       	nop
    37d6:	80 ec       	ldi	r24, 0xC0	; 192
    37d8:	98 e0       	ldi	r25, 0x08	; 8
    37da:	fc 01       	movw	r30, r24
    37dc:	82 81       	ldd	r24, Z+2	; 0x02
    37de:	88 23       	and	r24, r24
    37e0:	d4 f7       	brge	.-12     	; 0x37d6 <FRAMWriteKnowns+0x124>
		SPIBuffer[12] = SPIC.DATA;
    37e2:	80 ec       	ldi	r24, 0xC0	; 192
    37e4:	98 e0       	ldi	r25, 0x08	; 8
    37e6:	fc 01       	movw	r30, r24
    37e8:	83 81       	ldd	r24, Z+3	; 0x03
    37ea:	80 93 60 50 	sts	0x5060, r24
		SPIC.DATA = SPIBuffer[1];
    37ee:	80 ec       	ldi	r24, 0xC0	; 192
    37f0:	98 e0       	ldi	r25, 0x08	; 8
    37f2:	20 91 55 50 	lds	r18, 0x5055
    37f6:	fc 01       	movw	r30, r24
    37f8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37fa:	00 00       	nop
    37fc:	80 ec       	ldi	r24, 0xC0	; 192
    37fe:	98 e0       	ldi	r25, 0x08	; 8
    3800:	fc 01       	movw	r30, r24
    3802:	82 81       	ldd	r24, Z+2	; 0x02
    3804:	88 23       	and	r24, r24
    3806:	d4 f7       	brge	.-12     	; 0x37fc <FRAMWriteKnowns+0x14a>
		SPIBuffer[12] = SPIC.DATA;
    3808:	80 ec       	ldi	r24, 0xC0	; 192
    380a:	98 e0       	ldi	r25, 0x08	; 8
    380c:	fc 01       	movw	r30, r24
    380e:	83 81       	ldd	r24, Z+3	; 0x03
    3810:	80 93 60 50 	sts	0x5060, r24
		SPIC.DATA = SPIBuffer[2];
    3814:	80 ec       	ldi	r24, 0xC0	; 192
    3816:	98 e0       	ldi	r25, 0x08	; 8
    3818:	20 91 56 50 	lds	r18, 0x5056
    381c:	fc 01       	movw	r30, r24
    381e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3820:	00 00       	nop
    3822:	80 ec       	ldi	r24, 0xC0	; 192
    3824:	98 e0       	ldi	r25, 0x08	; 8
    3826:	fc 01       	movw	r30, r24
    3828:	82 81       	ldd	r24, Z+2	; 0x02
    382a:	88 23       	and	r24, r24
    382c:	d4 f7       	brge	.-12     	; 0x3822 <FRAMWriteKnowns+0x170>
		SPIBuffer[12] = SPIC.DATA;
    382e:	80 ec       	ldi	r24, 0xC0	; 192
    3830:	98 e0       	ldi	r25, 0x08	; 8
    3832:	fc 01       	movw	r30, r24
    3834:	83 81       	ldd	r24, Z+3	; 0x03
    3836:	80 93 60 50 	sts	0x5060, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    383a:	80 e2       	ldi	r24, 0x20	; 32
    383c:	96 e0       	ldi	r25, 0x06	; 6
    383e:	28 e0       	ldi	r18, 0x08	; 8
    3840:	fc 01       	movw	r30, r24
    3842:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3844:	80 e4       	ldi	r24, 0x40	; 64
    3846:	96 e0       	ldi	r25, 0x06	; 6
    3848:	20 e1       	ldi	r18, 0x10	; 16
    384a:	fc 01       	movw	r30, r24
    384c:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    384e:	80 91 46 40 	lds	r24, 0x4046
    3852:	90 91 47 40 	lds	r25, 0x4047
    3856:	03 96       	adiw	r24, 0x03	; 3
    3858:	80 93 46 40 	sts	0x4046, r24
    385c:	90 93 47 40 	sts	0x4047, r25
		checksumADC[0] += SPIBuffer[0];
    3860:	90 91 28 21 	lds	r25, 0x2128
    3864:	80 91 54 50 	lds	r24, 0x5054
    3868:	89 0f       	add	r24, r25
    386a:	80 93 28 21 	sts	0x2128, r24
		checksumADC[1] += SPIBuffer[1];
    386e:	90 91 29 21 	lds	r25, 0x2129
    3872:	80 91 55 50 	lds	r24, 0x5055
    3876:	89 0f       	add	r24, r25
    3878:	80 93 29 21 	sts	0x2129, r24
		checksumADC[2] += SPIBuffer[2];
    387c:	90 91 2a 21 	lds	r25, 0x212A
    3880:	80 91 56 50 	lds	r24, 0x5056
    3884:	89 0f       	add	r24, r25
    3886:	80 93 2a 21 	sts	0x212A, r24
		
		sampleCount++;
    388a:	80 91 61 50 	lds	r24, 0x5061
    388e:	90 91 62 50 	lds	r25, 0x5062
    3892:	01 96       	adiw	r24, 0x01	; 1
    3894:	80 93 61 50 	sts	0x5061, r24
    3898:	90 93 62 50 	sts	0x5062, r25
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    389c:	80 91 61 50 	lds	r24, 0x5061
    38a0:	90 91 62 50 	lds	r25, 0x5062
    38a4:	f5 e5       	ldi	r31, 0x55	; 85
    38a6:	83 35       	cpi	r24, 0x53	; 83
    38a8:	9f 07       	cpc	r25, r31
    38aa:	08 f4       	brcc	.+2      	; 0x38ae <FRAMWriteKnowns+0x1fc>
    38ac:	2a cf       	rjmp	.-428    	; 0x3702 <FRAMWriteKnowns+0x50>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    38ae:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	ADCPower(FALSE);
    38b2:	80 e0       	ldi	r24, 0x00	; 0
    38b4:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
}
    38b8:	df 91       	pop	r29
    38ba:	cf 91       	pop	r28
    38bc:	08 95       	ret

000038be <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    38be:	cf 93       	push	r28
    38c0:	df 93       	push	r29
    38c2:	0f 92       	push	r0
    38c4:	cd b7       	in	r28, 0x3d	; 61
    38c6:	de b7       	in	r29, 0x3e	; 62
    38c8:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    38ca:	89 81       	ldd	r24, Y+1	; 0x01
    38cc:	88 2f       	mov	r24, r24
    38ce:	90 e0       	ldi	r25, 0x00	; 0
    38d0:	81 70       	andi	r24, 0x01	; 1
    38d2:	90 70       	andi	r25, 0x00	; 0
    38d4:	88 23       	and	r24, r24
    38d6:	31 f0       	breq	.+12     	; 0x38e4 <setADCInput+0x26>
    38d8:	80 e0       	ldi	r24, 0x00	; 0
    38da:	96 e0       	ldi	r25, 0x06	; 6
    38dc:	20 e4       	ldi	r18, 0x40	; 64
    38de:	fc 01       	movw	r30, r24
    38e0:	25 83       	std	Z+5, r18	; 0x05
    38e2:	05 c0       	rjmp	.+10     	; 0x38ee <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    38e4:	80 e0       	ldi	r24, 0x00	; 0
    38e6:	96 e0       	ldi	r25, 0x06	; 6
    38e8:	20 e4       	ldi	r18, 0x40	; 64
    38ea:	fc 01       	movw	r30, r24
    38ec:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    38ee:	89 81       	ldd	r24, Y+1	; 0x01
    38f0:	88 2f       	mov	r24, r24
    38f2:	90 e0       	ldi	r25, 0x00	; 0
    38f4:	82 70       	andi	r24, 0x02	; 2
    38f6:	90 70       	andi	r25, 0x00	; 0
    38f8:	00 97       	sbiw	r24, 0x00	; 0
    38fa:	31 f0       	breq	.+12     	; 0x3908 <setADCInput+0x4a>
    38fc:	80 e2       	ldi	r24, 0x20	; 32
    38fe:	96 e0       	ldi	r25, 0x06	; 6
    3900:	22 e0       	ldi	r18, 0x02	; 2
    3902:	fc 01       	movw	r30, r24
    3904:	25 83       	std	Z+5, r18	; 0x05
    3906:	05 c0       	rjmp	.+10     	; 0x3912 <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3908:	80 e2       	ldi	r24, 0x20	; 32
    390a:	96 e0       	ldi	r25, 0x06	; 6
    390c:	22 e0       	ldi	r18, 0x02	; 2
    390e:	fc 01       	movw	r30, r24
    3910:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    3912:	89 81       	ldd	r24, Y+1	; 0x01
    3914:	88 2f       	mov	r24, r24
    3916:	90 e0       	ldi	r25, 0x00	; 0
    3918:	84 70       	andi	r24, 0x04	; 4
    391a:	90 70       	andi	r25, 0x00	; 0
    391c:	00 97       	sbiw	r24, 0x00	; 0
    391e:	31 f0       	breq	.+12     	; 0x392c <setADCInput+0x6e>
    3920:	80 e2       	ldi	r24, 0x20	; 32
    3922:	96 e0       	ldi	r25, 0x06	; 6
    3924:	24 e0       	ldi	r18, 0x04	; 4
    3926:	fc 01       	movw	r30, r24
    3928:	25 83       	std	Z+5, r18	; 0x05
    392a:	05 c0       	rjmp	.+10     	; 0x3936 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    392c:	80 e2       	ldi	r24, 0x20	; 32
    392e:	96 e0       	ldi	r25, 0x06	; 6
    3930:	24 e0       	ldi	r18, 0x04	; 4
    3932:	fc 01       	movw	r30, r24
    3934:	26 83       	std	Z+6, r18	; 0x06

}
    3936:	0f 90       	pop	r0
    3938:	df 91       	pop	r29
    393a:	cf 91       	pop	r28
    393c:	08 95       	ret

0000393e <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    393e:	cf 93       	push	r28
    3940:	df 93       	push	r29
    3942:	0f 92       	push	r0
    3944:	0f 92       	push	r0
    3946:	cd b7       	in	r28, 0x3d	; 61
    3948:	de b7       	in	r29, 0x3e	; 62
    394a:	89 83       	std	Y+1, r24	; 0x01
    394c:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    394e:	89 81       	ldd	r24, Y+1	; 0x01
    3950:	9a 81       	ldd	r25, Y+2	; 0x02
    3952:	22 e0       	ldi	r18, 0x02	; 2
    3954:	80 30       	cpi	r24, 0x00	; 0
    3956:	92 07       	cpc	r25, r18
    3958:	89 f4       	brne	.+34     	; 0x397c <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    395a:	80 e2       	ldi	r24, 0x20	; 32
    395c:	0e 94 1c 20 	call	0x4038	; 0x4038 <SP_ReadCalibrationByte>
    3960:	28 2f       	mov	r18, r24
    3962:	89 81       	ldd	r24, Y+1	; 0x01
    3964:	9a 81       	ldd	r25, Y+2	; 0x02
    3966:	fc 01       	movw	r30, r24
    3968:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    396a:	81 e2       	ldi	r24, 0x21	; 33
    396c:	0e 94 1c 20 	call	0x4038	; 0x4038 <SP_ReadCalibrationByte>
    3970:	28 2f       	mov	r18, r24
    3972:	89 81       	ldd	r24, Y+1	; 0x01
    3974:	9a 81       	ldd	r25, Y+2	; 0x02
    3976:	fc 01       	movw	r30, r24
    3978:	25 87       	std	Z+13, r18	; 0x0d
    397a:	10 c0       	rjmp	.+32     	; 0x399c <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    397c:	84 e2       	ldi	r24, 0x24	; 36
    397e:	0e 94 1c 20 	call	0x4038	; 0x4038 <SP_ReadCalibrationByte>
    3982:	28 2f       	mov	r18, r24
    3984:	89 81       	ldd	r24, Y+1	; 0x01
    3986:	9a 81       	ldd	r25, Y+2	; 0x02
    3988:	fc 01       	movw	r30, r24
    398a:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    398c:	85 e2       	ldi	r24, 0x25	; 37
    398e:	0e 94 1c 20 	call	0x4038	; 0x4038 <SP_ReadCalibrationByte>
    3992:	28 2f       	mov	r18, r24
    3994:	89 81       	ldd	r24, Y+1	; 0x01
    3996:	9a 81       	ldd	r25, Y+2	; 0x02
    3998:	fc 01       	movw	r30, r24
    399a:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    399c:	0f 90       	pop	r0
    399e:	0f 90       	pop	r0
    39a0:	df 91       	pop	r29
    39a2:	cf 91       	pop	r28
    39a4:	08 95       	ret

000039a6 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    39a6:	cf 93       	push	r28
    39a8:	df 93       	push	r29
    39aa:	cd b7       	in	r28, 0x3d	; 61
    39ac:	de b7       	in	r29, 0x3e	; 62
    39ae:	25 97       	sbiw	r28, 0x05	; 5
    39b0:	cd bf       	out	0x3d, r28	; 61
    39b2:	de bf       	out	0x3e, r29	; 62
    39b4:	8b 83       	std	Y+3, r24	; 0x03
    39b6:	9c 83       	std	Y+4, r25	; 0x04
    39b8:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    39ba:	8b 81       	ldd	r24, Y+3	; 0x03
    39bc:	9c 81       	ldd	r25, Y+4	; 0x04
    39be:	21 e0       	ldi	r18, 0x01	; 1
    39c0:	fc 01       	movw	r30, r24
    39c2:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    39c4:	8b 81       	ldd	r24, Y+3	; 0x03
    39c6:	9c 81       	ldd	r25, Y+4	; 0x04
    39c8:	fc 01       	movw	r30, r24
    39ca:	24 81       	ldd	r18, Z+4	; 0x04
    39cc:	35 81       	ldd	r19, Z+5	; 0x05
    39ce:	8d 81       	ldd	r24, Y+5	; 0x05
    39d0:	88 2f       	mov	r24, r24
    39d2:	90 e0       	ldi	r25, 0x00	; 0
    39d4:	a9 01       	movw	r20, r18
    39d6:	48 1b       	sub	r20, r24
    39d8:	59 0b       	sbc	r21, r25
    39da:	ca 01       	movw	r24, r20
    39dc:	89 83       	std	Y+1, r24	; 0x01
    39de:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    39e0:	89 81       	ldd	r24, Y+1	; 0x01
    39e2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39e4:	25 96       	adiw	r28, 0x05	; 5
    39e6:	cd bf       	out	0x3d, r28	; 61
    39e8:	de bf       	out	0x3e, r29	; 62
    39ea:	df 91       	pop	r29
    39ec:	cf 91       	pop	r28
    39ee:	08 95       	ret

000039f0 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    39f0:	cf 93       	push	r28
    39f2:	df 93       	push	r29
    39f4:	cd b7       	in	r28, 0x3d	; 61
    39f6:	de b7       	in	r29, 0x3e	; 62
    39f8:	25 97       	sbiw	r28, 0x05	; 5
    39fa:	cd bf       	out	0x3d, r28	; 61
    39fc:	de bf       	out	0x3e, r29	; 62
    39fe:	8b 83       	std	Y+3, r24	; 0x03
    3a00:	9c 83       	std	Y+4, r25	; 0x04
    3a02:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a04:	8b 81       	ldd	r24, Y+3	; 0x03
    3a06:	9c 81       	ldd	r25, Y+4	; 0x04
    3a08:	21 e0       	ldi	r18, 0x01	; 1
    3a0a:	fc 01       	movw	r30, r24
    3a0c:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a10:	9c 81       	ldd	r25, Y+4	; 0x04
    3a12:	fc 01       	movw	r30, r24
    3a14:	24 81       	ldd	r18, Z+4	; 0x04
    3a16:	35 81       	ldd	r19, Z+5	; 0x05
    3a18:	8d 81       	ldd	r24, Y+5	; 0x05
    3a1a:	99 27       	eor	r25, r25
    3a1c:	87 fd       	sbrc	r24, 7
    3a1e:	90 95       	com	r25
    3a20:	a9 01       	movw	r20, r18
    3a22:	48 1b       	sub	r20, r24
    3a24:	59 0b       	sbc	r21, r25
    3a26:	ca 01       	movw	r24, r20
    3a28:	89 83       	std	Y+1, r24	; 0x01
    3a2a:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3a2c:	89 81       	ldd	r24, Y+1	; 0x01
    3a2e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a30:	25 96       	adiw	r28, 0x05	; 5
    3a32:	cd bf       	out	0x3d, r28	; 61
    3a34:	de bf       	out	0x3e, r29	; 62
    3a36:	df 91       	pop	r29
    3a38:	cf 91       	pop	r28
    3a3a:	08 95       	ret

00003a3c <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3a3c:	cf 93       	push	r28
    3a3e:	df 93       	push	r29
    3a40:	0f 92       	push	r0
    3a42:	0f 92       	push	r0
    3a44:	cd b7       	in	r28, 0x3d	; 61
    3a46:	de b7       	in	r29, 0x3e	; 62
    3a48:	89 83       	std	Y+1, r24	; 0x01
    3a4a:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a4c:	89 81       	ldd	r24, Y+1	; 0x01
    3a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a50:	21 e0       	ldi	r18, 0x01	; 1
    3a52:	fc 01       	movw	r30, r24
    3a54:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3a56:	89 81       	ldd	r24, Y+1	; 0x01
    3a58:	9a 81       	ldd	r25, Y+2	; 0x02
    3a5a:	fc 01       	movw	r30, r24
    3a5c:	84 81       	ldd	r24, Z+4	; 0x04
    3a5e:	95 81       	ldd	r25, Z+5	; 0x05
}
    3a60:	0f 90       	pop	r0
    3a62:	0f 90       	pop	r0
    3a64:	df 91       	pop	r29
    3a66:	cf 91       	pop	r28
    3a68:	08 95       	ret

00003a6a <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3a6a:	cf 93       	push	r28
    3a6c:	df 93       	push	r29
    3a6e:	0f 92       	push	r0
    3a70:	0f 92       	push	r0
    3a72:	cd b7       	in	r28, 0x3d	; 61
    3a74:	de b7       	in	r29, 0x3e	; 62
    3a76:	89 83       	std	Y+1, r24	; 0x01
    3a78:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a7a:	89 81       	ldd	r24, Y+1	; 0x01
    3a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a7e:	21 e0       	ldi	r18, 0x01	; 1
    3a80:	fc 01       	movw	r30, r24
    3a82:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3a84:	89 81       	ldd	r24, Y+1	; 0x01
    3a86:	9a 81       	ldd	r25, Y+2	; 0x02
    3a88:	fc 01       	movw	r30, r24
    3a8a:	84 81       	ldd	r24, Z+4	; 0x04
}
    3a8c:	0f 90       	pop	r0
    3a8e:	0f 90       	pop	r0
    3a90:	df 91       	pop	r29
    3a92:	cf 91       	pop	r28
    3a94:	08 95       	ret

00003a96 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3a96:	cf 93       	push	r28
    3a98:	df 93       	push	r29
    3a9a:	0f 92       	push	r0
    3a9c:	0f 92       	push	r0
    3a9e:	cd b7       	in	r28, 0x3d	; 61
    3aa0:	de b7       	in	r29, 0x3e	; 62
    3aa2:	89 83       	std	Y+1, r24	; 0x01
    3aa4:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3aa6:	89 81       	ldd	r24, Y+1	; 0x01
    3aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    3aaa:	21 e0       	ldi	r18, 0x01	; 1
    3aac:	fc 01       	movw	r30, r24
    3aae:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    3ab0:	89 81       	ldd	r24, Y+1	; 0x01
    3ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ab4:	fc 01       	movw	r30, r24
    3ab6:	85 81       	ldd	r24, Z+5	; 0x05
}
    3ab8:	0f 90       	pop	r0
    3aba:	0f 90       	pop	r0
    3abc:	df 91       	pop	r29
    3abe:	cf 91       	pop	r28
    3ac0:	08 95       	ret

00003ac2 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    3ac2:	0f 93       	push	r16
    3ac4:	1f 93       	push	r17
    3ac6:	cf 93       	push	r28
    3ac8:	df 93       	push	r29
    3aca:	cd b7       	in	r28, 0x3d	; 61
    3acc:	de b7       	in	r29, 0x3e	; 62
    3ace:	6b 97       	sbiw	r28, 0x1b	; 27
    3ad0:	cd bf       	out	0x3d, r28	; 61
    3ad2:	de bf       	out	0x3e, r29	; 62
    3ad4:	8a 8f       	std	Y+26, r24	; 0x1a
    3ad6:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3ad8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ada:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3adc:	fc 01       	movw	r30, r24
    3ade:	84 81       	ldd	r24, Z+4	; 0x04
    3ae0:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    3ae2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ae4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ae6:	fc 01       	movw	r30, r24
    3ae8:	14 82       	std	Z+4, r1	; 0x04
    3aea:	80 e0       	ldi	r24, 0x00	; 0
    3aec:	90 e0       	ldi	r25, 0x00	; 0
    3aee:	a0 e8       	ldi	r26, 0x80	; 128
    3af0:	b2 e4       	ldi	r27, 0x42	; 66
    3af2:	8a 83       	std	Y+2, r24	; 0x02
    3af4:	9b 83       	std	Y+3, r25	; 0x03
    3af6:	ac 83       	std	Y+4, r26	; 0x04
    3af8:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3afa:	6a 81       	ldd	r22, Y+2	; 0x02
    3afc:	7b 81       	ldd	r23, Y+3	; 0x03
    3afe:	8c 81       	ldd	r24, Y+4	; 0x04
    3b00:	9d 81       	ldd	r25, Y+5	; 0x05
    3b02:	2b ea       	ldi	r18, 0xAB	; 171
    3b04:	3a ea       	ldi	r19, 0xAA	; 170
    3b06:	4a e2       	ldi	r20, 0x2A	; 42
    3b08:	5f e3       	ldi	r21, 0x3F	; 63
    3b0a:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    3b0e:	dc 01       	movw	r26, r24
    3b10:	cb 01       	movw	r24, r22
    3b12:	8e 83       	std	Y+6, r24	; 0x06
    3b14:	9f 83       	std	Y+7, r25	; 0x07
    3b16:	a8 87       	std	Y+8, r26	; 0x08
    3b18:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3b1a:	11 e0       	ldi	r17, 0x01	; 1
    3b1c:	6e 81       	ldd	r22, Y+6	; 0x06
    3b1e:	7f 81       	ldd	r23, Y+7	; 0x07
    3b20:	88 85       	ldd	r24, Y+8	; 0x08
    3b22:	99 85       	ldd	r25, Y+9	; 0x09
    3b24:	20 e0       	ldi	r18, 0x00	; 0
    3b26:	30 e0       	ldi	r19, 0x00	; 0
    3b28:	40 e8       	ldi	r20, 0x80	; 128
    3b2a:	5f e3       	ldi	r21, 0x3F	; 63
    3b2c:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    3b30:	88 23       	and	r24, r24
    3b32:	0c f0       	brlt	.+2      	; 0x3b36 <ADC_Wait_8MHz+0x74>
    3b34:	10 e0       	ldi	r17, 0x00	; 0
    3b36:	11 23       	and	r17, r17
    3b38:	19 f0       	breq	.+6      	; 0x3b40 <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3b3a:	81 e0       	ldi	r24, 0x01	; 1
    3b3c:	8a 87       	std	Y+10, r24	; 0x0a
    3b3e:	a3 c0       	rjmp	.+326    	; 0x3c86 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    3b40:	11 e0       	ldi	r17, 0x01	; 1
    3b42:	6e 81       	ldd	r22, Y+6	; 0x06
    3b44:	7f 81       	ldd	r23, Y+7	; 0x07
    3b46:	88 85       	ldd	r24, Y+8	; 0x08
    3b48:	99 85       	ldd	r25, Y+9	; 0x09
    3b4a:	20 e0       	ldi	r18, 0x00	; 0
    3b4c:	30 e0       	ldi	r19, 0x00	; 0
    3b4e:	4f e7       	ldi	r20, 0x7F	; 127
    3b50:	53 e4       	ldi	r21, 0x43	; 67
    3b52:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    3b56:	18 16       	cp	r1, r24
    3b58:	0c f0       	brlt	.+2      	; 0x3b5c <ADC_Wait_8MHz+0x9a>
    3b5a:	10 e0       	ldi	r17, 0x00	; 0
    3b5c:	11 23       	and	r17, r17
    3b5e:	09 f4       	brne	.+2      	; 0x3b62 <ADC_Wait_8MHz+0xa0>
    3b60:	89 c0       	rjmp	.+274    	; 0x3c74 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    3b62:	6a 81       	ldd	r22, Y+2	; 0x02
    3b64:	7b 81       	ldd	r23, Y+3	; 0x03
    3b66:	8c 81       	ldd	r24, Y+4	; 0x04
    3b68:	9d 81       	ldd	r25, Y+5	; 0x05
    3b6a:	20 e0       	ldi	r18, 0x00	; 0
    3b6c:	30 e0       	ldi	r19, 0x00	; 0
    3b6e:	4a e7       	ldi	r20, 0x7A	; 122
    3b70:	54 e4       	ldi	r21, 0x44	; 68
    3b72:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    3b76:	dc 01       	movw	r26, r24
    3b78:	cb 01       	movw	r24, r22
    3b7a:	8b 87       	std	Y+11, r24	; 0x0b
    3b7c:	9c 87       	std	Y+12, r25	; 0x0c
    3b7e:	ad 87       	std	Y+13, r26	; 0x0d
    3b80:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3b82:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b84:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b86:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b88:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b8a:	20 e0       	ldi	r18, 0x00	; 0
    3b8c:	30 e0       	ldi	r19, 0x00	; 0
    3b8e:	4a ef       	ldi	r20, 0xFA	; 250
    3b90:	53 e4       	ldi	r21, 0x43	; 67
    3b92:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    3b96:	dc 01       	movw	r26, r24
    3b98:	cb 01       	movw	r24, r22
    3b9a:	8f 87       	std	Y+15, r24	; 0x0f
    3b9c:	98 8b       	std	Y+16, r25	; 0x10
    3b9e:	a9 8b       	std	Y+17, r26	; 0x11
    3ba0:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3ba2:	11 e0       	ldi	r17, 0x01	; 1
    3ba4:	6f 85       	ldd	r22, Y+15	; 0x0f
    3ba6:	78 89       	ldd	r23, Y+16	; 0x10
    3ba8:	89 89       	ldd	r24, Y+17	; 0x11
    3baa:	9a 89       	ldd	r25, Y+18	; 0x12
    3bac:	20 e0       	ldi	r18, 0x00	; 0
    3bae:	30 e0       	ldi	r19, 0x00	; 0
    3bb0:	40 e8       	ldi	r20, 0x80	; 128
    3bb2:	5f e3       	ldi	r21, 0x3F	; 63
    3bb4:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    3bb8:	88 23       	and	r24, r24
    3bba:	0c f0       	brlt	.+2      	; 0x3bbe <ADC_Wait_8MHz+0xfc>
    3bbc:	10 e0       	ldi	r17, 0x00	; 0
    3bbe:	11 23       	and	r17, r17
    3bc0:	29 f0       	breq	.+10     	; 0x3bcc <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    3bc2:	81 e0       	ldi	r24, 0x01	; 1
    3bc4:	90 e0       	ldi	r25, 0x00	; 0
    3bc6:	8b 8b       	std	Y+19, r24	; 0x13
    3bc8:	9c 8b       	std	Y+20, r25	; 0x14
    3bca:	46 c0       	rjmp	.+140    	; 0x3c58 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3bcc:	11 e0       	ldi	r17, 0x01	; 1
    3bce:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bd0:	78 89       	ldd	r23, Y+16	; 0x10
    3bd2:	89 89       	ldd	r24, Y+17	; 0x11
    3bd4:	9a 89       	ldd	r25, Y+18	; 0x12
    3bd6:	20 e0       	ldi	r18, 0x00	; 0
    3bd8:	3f ef       	ldi	r19, 0xFF	; 255
    3bda:	4f e7       	ldi	r20, 0x7F	; 127
    3bdc:	57 e4       	ldi	r21, 0x47	; 71
    3bde:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    3be2:	18 16       	cp	r1, r24
    3be4:	0c f0       	brlt	.+2      	; 0x3be8 <ADC_Wait_8MHz+0x126>
    3be6:	10 e0       	ldi	r17, 0x00	; 0
    3be8:	11 23       	and	r17, r17
    3bea:	61 f1       	breq	.+88     	; 0x3c44 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3bec:	6b 85       	ldd	r22, Y+11	; 0x0b
    3bee:	7c 85       	ldd	r23, Y+12	; 0x0c
    3bf0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bf2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3bf4:	20 e0       	ldi	r18, 0x00	; 0
    3bf6:	30 e0       	ldi	r19, 0x00	; 0
    3bf8:	40 e2       	ldi	r20, 0x20	; 32
    3bfa:	51 e4       	ldi	r21, 0x41	; 65
    3bfc:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    3c00:	dc 01       	movw	r26, r24
    3c02:	cb 01       	movw	r24, r22
    3c04:	bc 01       	movw	r22, r24
    3c06:	cd 01       	movw	r24, r26
    3c08:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    3c0c:	dc 01       	movw	r26, r24
    3c0e:	cb 01       	movw	r24, r22
    3c10:	8b 8b       	std	Y+19, r24	; 0x13
    3c12:	9c 8b       	std	Y+20, r25	; 0x14
    3c14:	12 c0       	rjmp	.+36     	; 0x3c3a <ADC_Wait_8MHz+0x178>
    3c16:	82 e3       	ldi	r24, 0x32	; 50
    3c18:	90 e0       	ldi	r25, 0x00	; 0
    3c1a:	8d 8b       	std	Y+21, r24	; 0x15
    3c1c:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3c1e:	8d 89       	ldd	r24, Y+21	; 0x15
    3c20:	9e 89       	ldd	r25, Y+22	; 0x16
    3c22:	8c 01       	movw	r16, r24
    3c24:	c8 01       	movw	r24, r16
    3c26:	01 97       	sbiw	r24, 0x01	; 1
    3c28:	f1 f7       	brne	.-4      	; 0x3c26 <ADC_Wait_8MHz+0x164>
    3c2a:	8c 01       	movw	r16, r24
    3c2c:	0d 8b       	std	Y+21, r16	; 0x15
    3c2e:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3c30:	8b 89       	ldd	r24, Y+19	; 0x13
    3c32:	9c 89       	ldd	r25, Y+20	; 0x14
    3c34:	01 97       	sbiw	r24, 0x01	; 1
    3c36:	8b 8b       	std	Y+19, r24	; 0x13
    3c38:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c3a:	8b 89       	ldd	r24, Y+19	; 0x13
    3c3c:	9c 89       	ldd	r25, Y+20	; 0x14
    3c3e:	00 97       	sbiw	r24, 0x00	; 0
    3c40:	51 f7       	brne	.-44     	; 0x3c16 <ADC_Wait_8MHz+0x154>
    3c42:	28 c0       	rjmp	.+80     	; 0x3c94 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c44:	6f 85       	ldd	r22, Y+15	; 0x0f
    3c46:	78 89       	ldd	r23, Y+16	; 0x10
    3c48:	89 89       	ldd	r24, Y+17	; 0x11
    3c4a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c4c:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    3c50:	dc 01       	movw	r26, r24
    3c52:	cb 01       	movw	r24, r22
    3c54:	8b 8b       	std	Y+19, r24	; 0x13
    3c56:	9c 8b       	std	Y+20, r25	; 0x14
    3c58:	8b 89       	ldd	r24, Y+19	; 0x13
    3c5a:	9c 89       	ldd	r25, Y+20	; 0x14
    3c5c:	8f 8b       	std	Y+23, r24	; 0x17
    3c5e:	98 8f       	std	Y+24, r25	; 0x18
    3c60:	8f 89       	ldd	r24, Y+23	; 0x17
    3c62:	98 8d       	ldd	r25, Y+24	; 0x18
    3c64:	8c 01       	movw	r16, r24
    3c66:	f8 01       	movw	r30, r16
    3c68:	31 97       	sbiw	r30, 0x01	; 1
    3c6a:	f1 f7       	brne	.-4      	; 0x3c68 <ADC_Wait_8MHz+0x1a6>
    3c6c:	8f 01       	movw	r16, r30
    3c6e:	0f 8b       	std	Y+23, r16	; 0x17
    3c70:	18 8f       	std	Y+24, r17	; 0x18
    3c72:	10 c0       	rjmp	.+32     	; 0x3c94 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3c74:	6e 81       	ldd	r22, Y+6	; 0x06
    3c76:	7f 81       	ldd	r23, Y+7	; 0x07
    3c78:	88 85       	ldd	r24, Y+8	; 0x08
    3c7a:	99 85       	ldd	r25, Y+9	; 0x09
    3c7c:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    3c80:	dc 01       	movw	r26, r24
    3c82:	cb 01       	movw	r24, r22
    3c84:	8a 87       	std	Y+10, r24	; 0x0a
    3c86:	8a 85       	ldd	r24, Y+10	; 0x0a
    3c88:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3c8a:	89 8d       	ldd	r24, Y+25	; 0x19
    3c8c:	18 2f       	mov	r17, r24
    3c8e:	1a 95       	dec	r17
    3c90:	f1 f7       	brne	.-4      	; 0x3c8e <ADC_Wait_8MHz+0x1cc>
    3c92:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3c94:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3c96:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3c98:	29 81       	ldd	r18, Y+1	; 0x01
    3c9a:	fc 01       	movw	r30, r24
    3c9c:	24 83       	std	Z+4, r18	; 0x04
}
    3c9e:	6b 96       	adiw	r28, 0x1b	; 27
    3ca0:	cd bf       	out	0x3d, r28	; 61
    3ca2:	de bf       	out	0x3e, r29	; 62
    3ca4:	df 91       	pop	r29
    3ca6:	cf 91       	pop	r28
    3ca8:	1f 91       	pop	r17
    3caa:	0f 91       	pop	r16
    3cac:	08 95       	ret

00003cae <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    3cae:	0f 93       	push	r16
    3cb0:	1f 93       	push	r17
    3cb2:	cf 93       	push	r28
    3cb4:	df 93       	push	r29
    3cb6:	cd b7       	in	r28, 0x3d	; 61
    3cb8:	de b7       	in	r29, 0x3e	; 62
    3cba:	6b 97       	sbiw	r28, 0x1b	; 27
    3cbc:	cd bf       	out	0x3d, r28	; 61
    3cbe:	de bf       	out	0x3e, r29	; 62
    3cc0:	8a 8f       	std	Y+26, r24	; 0x1a
    3cc2:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3cc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cc6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cc8:	fc 01       	movw	r30, r24
    3cca:	84 81       	ldd	r24, Z+4	; 0x04
    3ccc:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3cce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cd0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cd2:	21 e0       	ldi	r18, 0x01	; 1
    3cd4:	fc 01       	movw	r30, r24
    3cd6:	24 83       	std	Z+4, r18	; 0x04
    3cd8:	80 e0       	ldi	r24, 0x00	; 0
    3cda:	90 e0       	ldi	r25, 0x00	; 0
    3cdc:	a0 e0       	ldi	r26, 0x00	; 0
    3cde:	b3 e4       	ldi	r27, 0x43	; 67
    3ce0:	8a 83       	std	Y+2, r24	; 0x02
    3ce2:	9b 83       	std	Y+3, r25	; 0x03
    3ce4:	ac 83       	std	Y+4, r26	; 0x04
    3ce6:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3ce8:	6a 81       	ldd	r22, Y+2	; 0x02
    3cea:	7b 81       	ldd	r23, Y+3	; 0x03
    3cec:	8c 81       	ldd	r24, Y+4	; 0x04
    3cee:	9d 81       	ldd	r25, Y+5	; 0x05
    3cf0:	2b ea       	ldi	r18, 0xAB	; 171
    3cf2:	3a ea       	ldi	r19, 0xAA	; 170
    3cf4:	4a e2       	ldi	r20, 0x2A	; 42
    3cf6:	5f e3       	ldi	r21, 0x3F	; 63
    3cf8:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    3cfc:	dc 01       	movw	r26, r24
    3cfe:	cb 01       	movw	r24, r22
    3d00:	8e 83       	std	Y+6, r24	; 0x06
    3d02:	9f 83       	std	Y+7, r25	; 0x07
    3d04:	a8 87       	std	Y+8, r26	; 0x08
    3d06:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3d08:	11 e0       	ldi	r17, 0x01	; 1
    3d0a:	6e 81       	ldd	r22, Y+6	; 0x06
    3d0c:	7f 81       	ldd	r23, Y+7	; 0x07
    3d0e:	88 85       	ldd	r24, Y+8	; 0x08
    3d10:	99 85       	ldd	r25, Y+9	; 0x09
    3d12:	20 e0       	ldi	r18, 0x00	; 0
    3d14:	30 e0       	ldi	r19, 0x00	; 0
    3d16:	40 e8       	ldi	r20, 0x80	; 128
    3d18:	5f e3       	ldi	r21, 0x3F	; 63
    3d1a:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    3d1e:	88 23       	and	r24, r24
    3d20:	0c f0       	brlt	.+2      	; 0x3d24 <ADC_Wait_32MHz+0x76>
    3d22:	10 e0       	ldi	r17, 0x00	; 0
    3d24:	11 23       	and	r17, r17
    3d26:	19 f0       	breq	.+6      	; 0x3d2e <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3d28:	81 e0       	ldi	r24, 0x01	; 1
    3d2a:	8a 87       	std	Y+10, r24	; 0x0a
    3d2c:	a3 c0       	rjmp	.+326    	; 0x3e74 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3d2e:	11 e0       	ldi	r17, 0x01	; 1
    3d30:	6e 81       	ldd	r22, Y+6	; 0x06
    3d32:	7f 81       	ldd	r23, Y+7	; 0x07
    3d34:	88 85       	ldd	r24, Y+8	; 0x08
    3d36:	99 85       	ldd	r25, Y+9	; 0x09
    3d38:	20 e0       	ldi	r18, 0x00	; 0
    3d3a:	30 e0       	ldi	r19, 0x00	; 0
    3d3c:	4f e7       	ldi	r20, 0x7F	; 127
    3d3e:	53 e4       	ldi	r21, 0x43	; 67
    3d40:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    3d44:	18 16       	cp	r1, r24
    3d46:	0c f0       	brlt	.+2      	; 0x3d4a <ADC_Wait_32MHz+0x9c>
    3d48:	10 e0       	ldi	r17, 0x00	; 0
    3d4a:	11 23       	and	r17, r17
    3d4c:	09 f4       	brne	.+2      	; 0x3d50 <ADC_Wait_32MHz+0xa2>
    3d4e:	89 c0       	rjmp	.+274    	; 0x3e62 <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3d50:	6a 81       	ldd	r22, Y+2	; 0x02
    3d52:	7b 81       	ldd	r23, Y+3	; 0x03
    3d54:	8c 81       	ldd	r24, Y+4	; 0x04
    3d56:	9d 81       	ldd	r25, Y+5	; 0x05
    3d58:	20 e0       	ldi	r18, 0x00	; 0
    3d5a:	30 e0       	ldi	r19, 0x00	; 0
    3d5c:	4a e7       	ldi	r20, 0x7A	; 122
    3d5e:	54 e4       	ldi	r21, 0x44	; 68
    3d60:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    3d64:	dc 01       	movw	r26, r24
    3d66:	cb 01       	movw	r24, r22
    3d68:	8b 87       	std	Y+11, r24	; 0x0b
    3d6a:	9c 87       	std	Y+12, r25	; 0x0c
    3d6c:	ad 87       	std	Y+13, r26	; 0x0d
    3d6e:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3d70:	6b 85       	ldd	r22, Y+11	; 0x0b
    3d72:	7c 85       	ldd	r23, Y+12	; 0x0c
    3d74:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d76:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d78:	20 e0       	ldi	r18, 0x00	; 0
    3d7a:	30 e0       	ldi	r19, 0x00	; 0
    3d7c:	4a ef       	ldi	r20, 0xFA	; 250
    3d7e:	53 e4       	ldi	r21, 0x43	; 67
    3d80:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    3d84:	dc 01       	movw	r26, r24
    3d86:	cb 01       	movw	r24, r22
    3d88:	8f 87       	std	Y+15, r24	; 0x0f
    3d8a:	98 8b       	std	Y+16, r25	; 0x10
    3d8c:	a9 8b       	std	Y+17, r26	; 0x11
    3d8e:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3d90:	11 e0       	ldi	r17, 0x01	; 1
    3d92:	6f 85       	ldd	r22, Y+15	; 0x0f
    3d94:	78 89       	ldd	r23, Y+16	; 0x10
    3d96:	89 89       	ldd	r24, Y+17	; 0x11
    3d98:	9a 89       	ldd	r25, Y+18	; 0x12
    3d9a:	20 e0       	ldi	r18, 0x00	; 0
    3d9c:	30 e0       	ldi	r19, 0x00	; 0
    3d9e:	40 e8       	ldi	r20, 0x80	; 128
    3da0:	5f e3       	ldi	r21, 0x3F	; 63
    3da2:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    3da6:	88 23       	and	r24, r24
    3da8:	0c f0       	brlt	.+2      	; 0x3dac <ADC_Wait_32MHz+0xfe>
    3daa:	10 e0       	ldi	r17, 0x00	; 0
    3dac:	11 23       	and	r17, r17
    3dae:	29 f0       	breq	.+10     	; 0x3dba <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    3db0:	81 e0       	ldi	r24, 0x01	; 1
    3db2:	90 e0       	ldi	r25, 0x00	; 0
    3db4:	8b 8b       	std	Y+19, r24	; 0x13
    3db6:	9c 8b       	std	Y+20, r25	; 0x14
    3db8:	46 c0       	rjmp	.+140    	; 0x3e46 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3dba:	11 e0       	ldi	r17, 0x01	; 1
    3dbc:	6f 85       	ldd	r22, Y+15	; 0x0f
    3dbe:	78 89       	ldd	r23, Y+16	; 0x10
    3dc0:	89 89       	ldd	r24, Y+17	; 0x11
    3dc2:	9a 89       	ldd	r25, Y+18	; 0x12
    3dc4:	20 e0       	ldi	r18, 0x00	; 0
    3dc6:	3f ef       	ldi	r19, 0xFF	; 255
    3dc8:	4f e7       	ldi	r20, 0x7F	; 127
    3dca:	57 e4       	ldi	r21, 0x47	; 71
    3dcc:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    3dd0:	18 16       	cp	r1, r24
    3dd2:	0c f0       	brlt	.+2      	; 0x3dd6 <ADC_Wait_32MHz+0x128>
    3dd4:	10 e0       	ldi	r17, 0x00	; 0
    3dd6:	11 23       	and	r17, r17
    3dd8:	61 f1       	breq	.+88     	; 0x3e32 <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3dda:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ddc:	7c 85       	ldd	r23, Y+12	; 0x0c
    3dde:	8d 85       	ldd	r24, Y+13	; 0x0d
    3de0:	9e 85       	ldd	r25, Y+14	; 0x0e
    3de2:	20 e0       	ldi	r18, 0x00	; 0
    3de4:	30 e0       	ldi	r19, 0x00	; 0
    3de6:	40 e2       	ldi	r20, 0x20	; 32
    3de8:	51 e4       	ldi	r21, 0x41	; 65
    3dea:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    3dee:	dc 01       	movw	r26, r24
    3df0:	cb 01       	movw	r24, r22
    3df2:	bc 01       	movw	r22, r24
    3df4:	cd 01       	movw	r24, r26
    3df6:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    3dfa:	dc 01       	movw	r26, r24
    3dfc:	cb 01       	movw	r24, r22
    3dfe:	8b 8b       	std	Y+19, r24	; 0x13
    3e00:	9c 8b       	std	Y+20, r25	; 0x14
    3e02:	12 c0       	rjmp	.+36     	; 0x3e28 <ADC_Wait_32MHz+0x17a>
    3e04:	82 e3       	ldi	r24, 0x32	; 50
    3e06:	90 e0       	ldi	r25, 0x00	; 0
    3e08:	8d 8b       	std	Y+21, r24	; 0x15
    3e0a:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3e0c:	8d 89       	ldd	r24, Y+21	; 0x15
    3e0e:	9e 89       	ldd	r25, Y+22	; 0x16
    3e10:	8c 01       	movw	r16, r24
    3e12:	c8 01       	movw	r24, r16
    3e14:	01 97       	sbiw	r24, 0x01	; 1
    3e16:	f1 f7       	brne	.-4      	; 0x3e14 <ADC_Wait_32MHz+0x166>
    3e18:	8c 01       	movw	r16, r24
    3e1a:	0d 8b       	std	Y+21, r16	; 0x15
    3e1c:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e1e:	8b 89       	ldd	r24, Y+19	; 0x13
    3e20:	9c 89       	ldd	r25, Y+20	; 0x14
    3e22:	01 97       	sbiw	r24, 0x01	; 1
    3e24:	8b 8b       	std	Y+19, r24	; 0x13
    3e26:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e28:	8b 89       	ldd	r24, Y+19	; 0x13
    3e2a:	9c 89       	ldd	r25, Y+20	; 0x14
    3e2c:	00 97       	sbiw	r24, 0x00	; 0
    3e2e:	51 f7       	brne	.-44     	; 0x3e04 <ADC_Wait_32MHz+0x156>
    3e30:	28 c0       	rjmp	.+80     	; 0x3e82 <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e32:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e34:	78 89       	ldd	r23, Y+16	; 0x10
    3e36:	89 89       	ldd	r24, Y+17	; 0x11
    3e38:	9a 89       	ldd	r25, Y+18	; 0x12
    3e3a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    3e3e:	dc 01       	movw	r26, r24
    3e40:	cb 01       	movw	r24, r22
    3e42:	8b 8b       	std	Y+19, r24	; 0x13
    3e44:	9c 8b       	std	Y+20, r25	; 0x14
    3e46:	8b 89       	ldd	r24, Y+19	; 0x13
    3e48:	9c 89       	ldd	r25, Y+20	; 0x14
    3e4a:	8f 8b       	std	Y+23, r24	; 0x17
    3e4c:	98 8f       	std	Y+24, r25	; 0x18
    3e4e:	8f 89       	ldd	r24, Y+23	; 0x17
    3e50:	98 8d       	ldd	r25, Y+24	; 0x18
    3e52:	8c 01       	movw	r16, r24
    3e54:	f8 01       	movw	r30, r16
    3e56:	31 97       	sbiw	r30, 0x01	; 1
    3e58:	f1 f7       	brne	.-4      	; 0x3e56 <ADC_Wait_32MHz+0x1a8>
    3e5a:	8f 01       	movw	r16, r30
    3e5c:	0f 8b       	std	Y+23, r16	; 0x17
    3e5e:	18 8f       	std	Y+24, r17	; 0x18
    3e60:	10 c0       	rjmp	.+32     	; 0x3e82 <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3e62:	6e 81       	ldd	r22, Y+6	; 0x06
    3e64:	7f 81       	ldd	r23, Y+7	; 0x07
    3e66:	88 85       	ldd	r24, Y+8	; 0x08
    3e68:	99 85       	ldd	r25, Y+9	; 0x09
    3e6a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    3e6e:	dc 01       	movw	r26, r24
    3e70:	cb 01       	movw	r24, r22
    3e72:	8a 87       	std	Y+10, r24	; 0x0a
    3e74:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e76:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3e78:	89 8d       	ldd	r24, Y+25	; 0x19
    3e7a:	18 2f       	mov	r17, r24
    3e7c:	1a 95       	dec	r17
    3e7e:	f1 f7       	brne	.-4      	; 0x3e7c <ADC_Wait_32MHz+0x1ce>
    3e80:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3e82:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3e84:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3e86:	29 81       	ldd	r18, Y+1	; 0x01
    3e88:	fc 01       	movw	r30, r24
    3e8a:	24 83       	std	Z+4, r18	; 0x04
}
    3e8c:	6b 96       	adiw	r28, 0x1b	; 27
    3e8e:	cd bf       	out	0x3d, r28	; 61
    3e90:	de bf       	out	0x3e, r29	; 62
    3e92:	df 91       	pop	r29
    3e94:	cf 91       	pop	r28
    3e96:	1f 91       	pop	r17
    3e98:	0f 91       	pop	r16
    3e9a:	08 95       	ret

00003e9c <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3e9c:	cf 93       	push	r28
    3e9e:	df 93       	push	r29
    3ea0:	cd b7       	in	r28, 0x3d	; 61
    3ea2:	de b7       	in	r29, 0x3e	; 62
    3ea4:	2a 97       	sbiw	r28, 0x0a	; 10
    3ea6:	cd bf       	out	0x3d, r28	; 61
    3ea8:	de bf       	out	0x3e, r29	; 62
    3eaa:	8e 83       	std	Y+6, r24	; 0x06
    3eac:	9f 83       	std	Y+7, r25	; 0x07
    3eae:	68 87       	std	Y+8, r22	; 0x08
    3eb0:	79 87       	std	Y+9, r23	; 0x09
    3eb2:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3eb4:	8a 85       	ldd	r24, Y+10	; 0x0a
    3eb6:	88 23       	and	r24, r24
    3eb8:	a9 f1       	breq	.+106    	; 0x3f24 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3eba:	19 82       	std	Y+1, r1	; 0x01
    3ebc:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3ebe:	1b 82       	std	Y+3, r1	; 0x03
    3ec0:	1c 82       	std	Y+4, r1	; 0x04
    3ec2:	24 c0       	rjmp	.+72     	; 0x3f0c <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3ec4:	88 85       	ldd	r24, Y+8	; 0x08
    3ec6:	99 85       	ldd	r25, Y+9	; 0x09
    3ec8:	fc 01       	movw	r30, r24
    3eca:	80 81       	ld	r24, Z
    3ecc:	28 2f       	mov	r18, r24
    3ece:	20 68       	ori	r18, 0x80	; 128
    3ed0:	88 85       	ldd	r24, Y+8	; 0x08
    3ed2:	99 85       	ldd	r25, Y+9	; 0x09
    3ed4:	fc 01       	movw	r30, r24
    3ed6:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3ed8:	88 85       	ldd	r24, Y+8	; 0x08
    3eda:	99 85       	ldd	r25, Y+9	; 0x09
    3edc:	fc 01       	movw	r30, r24
    3ede:	83 81       	ldd	r24, Z+3	; 0x03
    3ee0:	88 2f       	mov	r24, r24
    3ee2:	90 e0       	ldi	r25, 0x00	; 0
    3ee4:	81 70       	andi	r24, 0x01	; 1
    3ee6:	90 70       	andi	r25, 0x00	; 0
    3ee8:	00 97       	sbiw	r24, 0x00	; 0
    3eea:	b1 f3       	breq	.-20     	; 0x3ed8 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3eec:	88 85       	ldd	r24, Y+8	; 0x08
    3eee:	99 85       	ldd	r25, Y+9	; 0x09
    3ef0:	60 e0       	ldi	r22, 0x00	; 0
    3ef2:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <ADC_ResultCh_GetWord_Unsigned>
    3ef6:	29 81       	ldd	r18, Y+1	; 0x01
    3ef8:	3a 81       	ldd	r19, Y+2	; 0x02
    3efa:	82 0f       	add	r24, r18
    3efc:	93 1f       	adc	r25, r19
    3efe:	89 83       	std	Y+1, r24	; 0x01
    3f00:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3f02:	8b 81       	ldd	r24, Y+3	; 0x03
    3f04:	9c 81       	ldd	r25, Y+4	; 0x04
    3f06:	01 96       	adiw	r24, 0x01	; 1
    3f08:	8b 83       	std	Y+3, r24	; 0x03
    3f0a:	9c 83       	std	Y+4, r25	; 0x04
    3f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f10:	84 30       	cpi	r24, 0x04	; 4
    3f12:	91 05       	cpc	r25, r1
    3f14:	bc f2       	brlt	.-82     	; 0x3ec4 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3f16:	89 81       	ldd	r24, Y+1	; 0x01
    3f18:	9a 81       	ldd	r25, Y+2	; 0x02
    3f1a:	96 95       	lsr	r25
    3f1c:	87 95       	ror	r24
    3f1e:	96 95       	lsr	r25
    3f20:	87 95       	ror	r24
    3f22:	1b c0       	rjmp	.+54     	; 0x3f5a <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3f24:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3f26:	88 85       	ldd	r24, Y+8	; 0x08
    3f28:	99 85       	ldd	r25, Y+9	; 0x09
    3f2a:	fc 01       	movw	r30, r24
    3f2c:	80 81       	ld	r24, Z
    3f2e:	28 2f       	mov	r18, r24
    3f30:	20 68       	ori	r18, 0x80	; 128
    3f32:	88 85       	ldd	r24, Y+8	; 0x08
    3f34:	99 85       	ldd	r25, Y+9	; 0x09
    3f36:	fc 01       	movw	r30, r24
    3f38:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3f3a:	88 85       	ldd	r24, Y+8	; 0x08
    3f3c:	99 85       	ldd	r25, Y+9	; 0x09
    3f3e:	fc 01       	movw	r30, r24
    3f40:	83 81       	ldd	r24, Z+3	; 0x03
    3f42:	88 2f       	mov	r24, r24
    3f44:	90 e0       	ldi	r25, 0x00	; 0
    3f46:	81 70       	andi	r24, 0x01	; 1
    3f48:	90 70       	andi	r25, 0x00	; 0
    3f4a:	00 97       	sbiw	r24, 0x00	; 0
    3f4c:	b1 f3       	breq	.-20     	; 0x3f3a <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3f4e:	88 85       	ldd	r24, Y+8	; 0x08
    3f50:	99 85       	ldd	r25, Y+9	; 0x09
    3f52:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <ADC_ResultCh_GetWord>
    3f56:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3f58:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3f5a:	2a 96       	adiw	r28, 0x0a	; 10
    3f5c:	cd bf       	out	0x3d, r28	; 61
    3f5e:	de bf       	out	0x3e, r29	; 62
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	08 95       	ret

00003f66 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3f66:	cf 93       	push	r28
    3f68:	df 93       	push	r29
    3f6a:	cd b7       	in	r28, 0x3d	; 61
    3f6c:	de b7       	in	r29, 0x3e	; 62
    3f6e:	2a 97       	sbiw	r28, 0x0a	; 10
    3f70:	cd bf       	out	0x3d, r28	; 61
    3f72:	de bf       	out	0x3e, r29	; 62
    3f74:	8e 83       	std	Y+6, r24	; 0x06
    3f76:	9f 83       	std	Y+7, r25	; 0x07
    3f78:	68 87       	std	Y+8, r22	; 0x08
    3f7a:	79 87       	std	Y+9, r23	; 0x09
    3f7c:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3f7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f80:	88 23       	and	r24, r24
    3f82:	c1 f1       	breq	.+112    	; 0x3ff4 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3f84:	19 82       	std	Y+1, r1	; 0x01
    3f86:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3f88:	1b 82       	std	Y+3, r1	; 0x03
    3f8a:	1c 82       	std	Y+4, r1	; 0x04
    3f8c:	24 c0       	rjmp	.+72     	; 0x3fd6 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3f8e:	88 85       	ldd	r24, Y+8	; 0x08
    3f90:	99 85       	ldd	r25, Y+9	; 0x09
    3f92:	fc 01       	movw	r30, r24
    3f94:	80 81       	ld	r24, Z
    3f96:	28 2f       	mov	r18, r24
    3f98:	20 68       	ori	r18, 0x80	; 128
    3f9a:	88 85       	ldd	r24, Y+8	; 0x08
    3f9c:	99 85       	ldd	r25, Y+9	; 0x09
    3f9e:	fc 01       	movw	r30, r24
    3fa0:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3fa2:	88 85       	ldd	r24, Y+8	; 0x08
    3fa4:	99 85       	ldd	r25, Y+9	; 0x09
    3fa6:	fc 01       	movw	r30, r24
    3fa8:	83 81       	ldd	r24, Z+3	; 0x03
    3faa:	88 2f       	mov	r24, r24
    3fac:	90 e0       	ldi	r25, 0x00	; 0
    3fae:	81 70       	andi	r24, 0x01	; 1
    3fb0:	90 70       	andi	r25, 0x00	; 0
    3fb2:	00 97       	sbiw	r24, 0x00	; 0
    3fb4:	b1 f3       	breq	.-20     	; 0x3fa2 <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3fb6:	88 85       	ldd	r24, Y+8	; 0x08
    3fb8:	99 85       	ldd	r25, Y+9	; 0x09
    3fba:	60 e0       	ldi	r22, 0x00	; 0
    3fbc:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <ADC_ResultCh_GetWord_Signed>
    3fc0:	29 81       	ldd	r18, Y+1	; 0x01
    3fc2:	3a 81       	ldd	r19, Y+2	; 0x02
    3fc4:	82 0f       	add	r24, r18
    3fc6:	93 1f       	adc	r25, r19
    3fc8:	89 83       	std	Y+1, r24	; 0x01
    3fca:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    3fce:	9c 81       	ldd	r25, Y+4	; 0x04
    3fd0:	01 96       	adiw	r24, 0x01	; 1
    3fd2:	8b 83       	std	Y+3, r24	; 0x03
    3fd4:	9c 83       	std	Y+4, r25	; 0x04
    3fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fda:	84 30       	cpi	r24, 0x04	; 4
    3fdc:	91 05       	cpc	r25, r1
    3fde:	bc f2       	brlt	.-82     	; 0x3f8e <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3fe0:	89 81       	ldd	r24, Y+1	; 0x01
    3fe2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe4:	99 23       	and	r25, r25
    3fe6:	0c f4       	brge	.+2      	; 0x3fea <ADC_Offset_Get_Signed+0x84>
    3fe8:	03 96       	adiw	r24, 0x03	; 3
    3fea:	95 95       	asr	r25
    3fec:	87 95       	ror	r24
    3fee:	95 95       	asr	r25
    3ff0:	87 95       	ror	r24
    3ff2:	1c c0       	rjmp	.+56     	; 0x402c <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3ff4:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3ff6:	88 85       	ldd	r24, Y+8	; 0x08
    3ff8:	99 85       	ldd	r25, Y+9	; 0x09
    3ffa:	fc 01       	movw	r30, r24
    3ffc:	80 81       	ld	r24, Z
    3ffe:	28 2f       	mov	r18, r24
    4000:	20 68       	ori	r18, 0x80	; 128
    4002:	88 85       	ldd	r24, Y+8	; 0x08
    4004:	99 85       	ldd	r25, Y+9	; 0x09
    4006:	fc 01       	movw	r30, r24
    4008:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    400a:	88 85       	ldd	r24, Y+8	; 0x08
    400c:	99 85       	ldd	r25, Y+9	; 0x09
    400e:	fc 01       	movw	r30, r24
    4010:	83 81       	ldd	r24, Z+3	; 0x03
    4012:	88 2f       	mov	r24, r24
    4014:	90 e0       	ldi	r25, 0x00	; 0
    4016:	81 70       	andi	r24, 0x01	; 1
    4018:	90 70       	andi	r25, 0x00	; 0
    401a:	00 97       	sbiw	r24, 0x00	; 0
    401c:	b1 f3       	breq	.-20     	; 0x400a <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    401e:	88 85       	ldd	r24, Y+8	; 0x08
    4020:	99 85       	ldd	r25, Y+9	; 0x09
    4022:	60 e0       	ldi	r22, 0x00	; 0
    4024:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <ADC_ResultCh_GetWord_Signed>
    4028:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    402a:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    402c:	2a 96       	adiw	r28, 0x0a	; 10
    402e:	cd bf       	out	0x3d, r28	; 61
    4030:	de bf       	out	0x3e, r29	; 62
    4032:	df 91       	pop	r29
    4034:	cf 91       	pop	r28
    4036:	08 95       	ret

00004038 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    4038:	1f 93       	push	r17
    403a:	cf 93       	push	r28
    403c:	df 93       	push	r29
    403e:	cd b7       	in	r28, 0x3d	; 61
    4040:	de b7       	in	r29, 0x3e	; 62
    4042:	25 97       	sbiw	r28, 0x05	; 5
    4044:	cd bf       	out	0x3d, r28	; 61
    4046:	de bf       	out	0x3e, r29	; 62
    4048:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    404a:	8a ec       	ldi	r24, 0xCA	; 202
    404c:	91 e0       	ldi	r25, 0x01	; 1
    404e:	22 e0       	ldi	r18, 0x02	; 2
    4050:	fc 01       	movw	r30, r24
    4052:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    4054:	8d 81       	ldd	r24, Y+5	; 0x05
    4056:	88 2f       	mov	r24, r24
    4058:	90 e0       	ldi	r25, 0x00	; 0
    405a:	89 83       	std	Y+1, r24	; 0x01
    405c:	9a 83       	std	Y+2, r25	; 0x02
    405e:	89 81       	ldd	r24, Y+1	; 0x01
    4060:	9a 81       	ldd	r25, Y+2	; 0x02
    4062:	fc 01       	movw	r30, r24
    4064:	14 91       	lpm	r17, Z
    4066:	1b 83       	std	Y+3, r17	; 0x03
    4068:	8b 81       	ldd	r24, Y+3	; 0x03
    406a:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    406c:	8a ec       	ldi	r24, 0xCA	; 202
    406e:	91 e0       	ldi	r25, 0x01	; 1
    4070:	fc 01       	movw	r30, r24
    4072:	10 82       	st	Z, r1

	return result;
    4074:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4076:	25 96       	adiw	r28, 0x05	; 5
    4078:	cd bf       	out	0x3d, r28	; 61
    407a:	de bf       	out	0x3e, r29	; 62
    407c:	df 91       	pop	r29
    407e:	cf 91       	pop	r28
    4080:	1f 91       	pop	r17
    4082:	08 95       	ret

00004084 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    4084:	cf 93       	push	r28
    4086:	df 93       	push	r29
    4088:	cd b7       	in	r28, 0x3d	; 61
    408a:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    408c:	24 e1       	ldi	r18, 0x14	; 20
    408e:	8e e2       	ldi	r24, 0x2E	; 46
    4090:	91 e2       	ldi	r25, 0x21	; 33
    4092:	fc 01       	movw	r30, r24
    4094:	32 2f       	mov	r19, r18
    4096:	11 92       	st	Z+, r1
    4098:	3a 95       	dec	r19
    409a:	e9 f7       	brne	.-6      	; 0x4096 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    409c:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <chb_get_short_addr>
    40a0:	80 93 2e 21 	sts	0x212E, r24
    40a4:	90 93 2f 21 	sts	0x212F, r25
    chb_drvr_init();
    40a8:	0e 94 f6 2f 	call	0x5fec	; 0x5fec <chb_drvr_init>
	radio_msg_received_int_enable();
    40ac:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <radio_msg_received_int_enable>
}
    40b0:	df 91       	pop	r29
    40b2:	cf 91       	pop	r28
    40b4:	08 95       	ret

000040b6 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    40b6:	cf 93       	push	r28
    40b8:	df 93       	push	r29
    40ba:	cd b7       	in	r28, 0x3d	; 61
    40bc:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    40be:	80 e8       	ldi	r24, 0x80	; 128
    40c0:	96 e0       	ldi	r25, 0x06	; 6
    40c2:	24 e0       	ldi	r18, 0x04	; 4
    40c4:	fc 01       	movw	r30, r24
    40c6:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    40c8:	80 e8       	ldi	r24, 0x80	; 128
    40ca:	96 e0       	ldi	r25, 0x06	; 6
    40cc:	24 e0       	ldi	r18, 0x04	; 4
    40ce:	fc 01       	movw	r30, r24
    40d0:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    40d2:	80 e8       	ldi	r24, 0x80	; 128
    40d4:	96 e0       	ldi	r25, 0x06	; 6
    40d6:	22 e0       	ldi	r18, 0x02	; 2
    40d8:	fc 01       	movw	r30, r24
    40da:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    40dc:	80 e8       	ldi	r24, 0x80	; 128
    40de:	96 e0       	ldi	r25, 0x06	; 6
    40e0:	24 e0       	ldi	r18, 0x04	; 4
    40e2:	fc 01       	movw	r30, r24
    40e4:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_LO_gc;
    40e6:	80 e8       	ldi	r24, 0x80	; 128
    40e8:	96 e0       	ldi	r25, 0x06	; 6
    40ea:	21 e0       	ldi	r18, 0x01	; 1
    40ec:	fc 01       	movw	r30, r24
    40ee:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    40f0:	80 ea       	ldi	r24, 0xA0	; 160
    40f2:	90 e0       	ldi	r25, 0x00	; 0
    40f4:	20 ea       	ldi	r18, 0xA0	; 160
    40f6:	30 e0       	ldi	r19, 0x00	; 0
    40f8:	f9 01       	movw	r30, r18
    40fa:	22 81       	ldd	r18, Z+2	; 0x02
    40fc:	21 60       	ori	r18, 0x01	; 1
    40fe:	fc 01       	movw	r30, r24
    4100:	22 83       	std	Z+2, r18	; 0x02
	sei();
    4102:	78 94       	sei
}
    4104:	df 91       	pop	r29
    4106:	cf 91       	pop	r28
    4108:	08 95       	ret

0000410a <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    410a:	cf 93       	push	r28
    410c:	df 93       	push	r29
    410e:	cd b7       	in	r28, 0x3d	; 61
    4110:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    4112:	8e e2       	ldi	r24, 0x2E	; 46
    4114:	91 e2       	ldi	r25, 0x21	; 33
}
    4116:	df 91       	pop	r29
    4118:	cf 91       	pop	r28
    411a:	08 95       	ret

0000411c <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    411c:	cf 93       	push	r28
    411e:	df 93       	push	r29
    4120:	cd b7       	in	r28, 0x3d	; 61
    4122:	de b7       	in	r29, 0x3e	; 62
    4124:	27 97       	sbiw	r28, 0x07	; 7
    4126:	cd bf       	out	0x3d, r28	; 61
    4128:	de bf       	out	0x3e, r29	; 62
    412a:	8b 83       	std	Y+3, r24	; 0x03
    412c:	9c 83       	std	Y+4, r25	; 0x04
    412e:	6d 83       	std	Y+5, r22	; 0x05
    4130:	7e 83       	std	Y+6, r23	; 0x06
    4132:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    4134:	8b 81       	ldd	r24, Y+3	; 0x03
    4136:	9c 81       	ldd	r25, Y+4	; 0x04
    4138:	89 83       	std	Y+1, r24	; 0x01
    413a:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    413c:	8f 81       	ldd	r24, Y+7	; 0x07
    413e:	28 2f       	mov	r18, r24
    4140:	25 5f       	subi	r18, 0xF5	; 245
    4142:	89 81       	ldd	r24, Y+1	; 0x01
    4144:	9a 81       	ldd	r25, Y+2	; 0x02
    4146:	fc 01       	movw	r30, r24
    4148:	20 83       	st	Z, r18
    414a:	89 81       	ldd	r24, Y+1	; 0x01
    414c:	9a 81       	ldd	r25, Y+2	; 0x02
    414e:	01 96       	adiw	r24, 0x01	; 1
    4150:	89 83       	std	Y+1, r24	; 0x01
    4152:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    4154:	8d 81       	ldd	r24, Y+5	; 0x05
    4156:	9e 81       	ldd	r25, Y+6	; 0x06
    4158:	ff ef       	ldi	r31, 0xFF	; 255
    415a:	8f 3f       	cpi	r24, 0xFF	; 255
    415c:	9f 07       	cpc	r25, r31
    415e:	11 f0       	breq	.+4      	; 0x4164 <chb_gen_hdr+0x48>
    4160:	21 e6       	ldi	r18, 0x61	; 97
    4162:	01 c0       	rjmp	.+2      	; 0x4166 <chb_gen_hdr+0x4a>
    4164:	21 e4       	ldi	r18, 0x41	; 65
    4166:	89 81       	ldd	r24, Y+1	; 0x01
    4168:	9a 81       	ldd	r25, Y+2	; 0x02
    416a:	fc 01       	movw	r30, r24
    416c:	20 83       	st	Z, r18
    416e:	89 81       	ldd	r24, Y+1	; 0x01
    4170:	9a 81       	ldd	r25, Y+2	; 0x02
    4172:	01 96       	adiw	r24, 0x01	; 1
    4174:	89 83       	std	Y+1, r24	; 0x01
    4176:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    4178:	89 81       	ldd	r24, Y+1	; 0x01
    417a:	9a 81       	ldd	r25, Y+2	; 0x02
    417c:	28 e9       	ldi	r18, 0x98	; 152
    417e:	fc 01       	movw	r30, r24
    4180:	20 83       	st	Z, r18
    4182:	89 81       	ldd	r24, Y+1	; 0x01
    4184:	9a 81       	ldd	r25, Y+2	; 0x02
    4186:	01 96       	adiw	r24, 0x01	; 1
    4188:	89 83       	std	Y+1, r24	; 0x01
    418a:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    418c:	20 91 30 21 	lds	r18, 0x2130
    4190:	89 81       	ldd	r24, Y+1	; 0x01
    4192:	9a 81       	ldd	r25, Y+2	; 0x02
    4194:	fc 01       	movw	r30, r24
    4196:	20 83       	st	Z, r18
    4198:	89 81       	ldd	r24, Y+1	; 0x01
    419a:	9a 81       	ldd	r25, Y+2	; 0x02
    419c:	01 96       	adiw	r24, 0x01	; 1
    419e:	89 83       	std	Y+1, r24	; 0x01
    41a0:	9a 83       	std	Y+2, r25	; 0x02
    41a2:	82 2f       	mov	r24, r18
    41a4:	8f 5f       	subi	r24, 0xFF	; 255
    41a6:	80 93 30 21 	sts	0x2130, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    41aa:	89 81       	ldd	r24, Y+1	; 0x01
    41ac:	9a 81       	ldd	r25, Y+2	; 0x02
    41ae:	24 e3       	ldi	r18, 0x34	; 52
    41b0:	32 e1       	ldi	r19, 0x12	; 18
    41b2:	fc 01       	movw	r30, r24
    41b4:	20 83       	st	Z, r18
    41b6:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41b8:	89 81       	ldd	r24, Y+1	; 0x01
    41ba:	9a 81       	ldd	r25, Y+2	; 0x02
    41bc:	02 96       	adiw	r24, 0x02	; 2
    41be:	89 83       	std	Y+1, r24	; 0x01
    41c0:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    41c2:	89 81       	ldd	r24, Y+1	; 0x01
    41c4:	9a 81       	ldd	r25, Y+2	; 0x02
    41c6:	2d 81       	ldd	r18, Y+5	; 0x05
    41c8:	3e 81       	ldd	r19, Y+6	; 0x06
    41ca:	fc 01       	movw	r30, r24
    41cc:	20 83       	st	Z, r18
    41ce:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41d0:	89 81       	ldd	r24, Y+1	; 0x01
    41d2:	9a 81       	ldd	r25, Y+2	; 0x02
    41d4:	02 96       	adiw	r24, 0x02	; 2
    41d6:	89 83       	std	Y+1, r24	; 0x01
    41d8:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    41da:	20 91 2e 21 	lds	r18, 0x212E
    41de:	30 91 2f 21 	lds	r19, 0x212F
    41e2:	89 81       	ldd	r24, Y+1	; 0x01
    41e4:	9a 81       	ldd	r25, Y+2	; 0x02
    41e6:	fc 01       	movw	r30, r24
    41e8:	20 83       	st	Z, r18
    41ea:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41ec:	89 81       	ldd	r24, Y+1	; 0x01
    41ee:	9a 81       	ldd	r25, Y+2	; 0x02
    41f0:	02 96       	adiw	r24, 0x02	; 2
    41f2:	89 83       	std	Y+1, r24	; 0x01
    41f4:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    41f6:	29 81       	ldd	r18, Y+1	; 0x01
    41f8:	3a 81       	ldd	r19, Y+2	; 0x02
    41fa:	8b 81       	ldd	r24, Y+3	; 0x03
    41fc:	9c 81       	ldd	r25, Y+4	; 0x04
    41fe:	a9 01       	movw	r20, r18
    4200:	48 1b       	sub	r20, r24
    4202:	59 0b       	sbc	r21, r25
    4204:	ca 01       	movw	r24, r20
}
    4206:	27 96       	adiw	r28, 0x07	; 7
    4208:	cd bf       	out	0x3d, r28	; 61
    420a:	de bf       	out	0x3e, r29	; 62
    420c:	df 91       	pop	r29
    420e:	cf 91       	pop	r28
    4210:	08 95       	ret

00004212 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    4212:	ef 92       	push	r14
    4214:	ff 92       	push	r15
    4216:	0f 93       	push	r16
    4218:	1f 93       	push	r17
    421a:	cf 93       	push	r28
    421c:	df 93       	push	r29
    421e:	cd b7       	in	r28, 0x3d	; 61
    4220:	de b7       	in	r29, 0x3e	; 62
    4222:	e0 97       	sbiw	r28, 0x30	; 48
    4224:	cd bf       	out	0x3d, r28	; 61
    4226:	de bf       	out	0x3e, r29	; 62
    4228:	89 a7       	lds	r24, 0x79
    422a:	9a a7       	lds	r25, 0x7a
    422c:	6b a7       	lds	r22, 0x7b
    422e:	7c a7       	lds	r23, 0x7c
    4230:	2d a7       	lds	r18, 0x7d
    4232:	3e a7       	lds	r19, 0x7e
    4234:	4f a7       	lds	r20, 0x7f
    4236:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    4238:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    423a:	5c c1       	rjmp	.+696    	; 0x44f4 <chb_write+0x2e2>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    423c:	8d a5       	lds	r24, 0x6d
    423e:	9e a5       	lds	r25, 0x6e
    4240:	af a5       	lds	r26, 0x6f
    4242:	b8 a9       	sts	0x48, r27
    4244:	85 36       	cpi	r24, 0x65	; 101
    4246:	91 05       	cpc	r25, r1
    4248:	a1 05       	cpc	r26, r1
    424a:	b1 05       	cpc	r27, r1
    424c:	20 f0       	brcs	.+8      	; 0x4256 <chb_write+0x44>
    424e:	84 e6       	ldi	r24, 0x64	; 100
    4250:	90 e0       	ldi	r25, 0x00	; 0
    4252:	a0 e0       	ldi	r26, 0x00	; 0
    4254:	b0 e0       	ldi	r27, 0x00	; 0
    4256:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    4258:	ce 01       	movw	r24, r28
    425a:	4f 96       	adiw	r24, 0x1f	; 31
    425c:	29 a5       	lds	r18, 0x69
    425e:	3a a5       	lds	r19, 0x6a
    4260:	b9 01       	movw	r22, r18
    4262:	4c 81       	ldd	r20, Y+4	; 0x04
    4264:	0e 94 8e 20 	call	0x411c	; 0x411c <chb_gen_hdr>
    4268:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    426a:	1a 82       	std	Y+2, r1	; 0x02
    426c:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    426e:	89 81       	ldd	r24, Y+1	; 0x01
    4270:	88 2f       	mov	r24, r24
    4272:	90 e0       	ldi	r25, 0x00	; 0
    4274:	2b a5       	lds	r18, 0x6b
    4276:	3c a5       	lds	r19, 0x6c
    4278:	28 0f       	add	r18, r24
    427a:	39 1f       	adc	r19, r25
    427c:	ce 01       	movw	r24, r28
    427e:	4f 96       	adiw	r24, 0x1f	; 31
    4280:	b9 01       	movw	r22, r18
    4282:	4c 81       	ldd	r20, Y+4	; 0x04
    4284:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <chb_tx>
    4288:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    428a:	8e 81       	ldd	r24, Y+6	; 0x06
    428c:	88 2f       	mov	r24, r24
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	83 30       	cpi	r24, 0x03	; 3
    4292:	91 05       	cpc	r25, r1
    4294:	09 f1       	breq	.+66     	; 0x42d8 <chb_write+0xc6>
    4296:	84 30       	cpi	r24, 0x04	; 4
    4298:	91 05       	cpc	r25, r1
    429a:	24 f4       	brge	.+8      	; 0x42a4 <chb_write+0x92>
    429c:	81 30       	cpi	r24, 0x01	; 1
    429e:	91 05       	cpc	r25, r1
    42a0:	39 f0       	breq	.+14     	; 0x42b0 <chb_write+0x9e>
    42a2:	24 c0       	rjmp	.+72     	; 0x42ec <chb_write+0xda>
    42a4:	85 30       	cpi	r24, 0x05	; 5
    42a6:	91 05       	cpc	r25, r1
    42a8:	69 f0       	breq	.+26     	; 0x42c4 <chb_write+0xb2>
    42aa:	80 34       	cpi	r24, 0x40	; 64
    42ac:	91 05       	cpc	r25, r1
    42ae:	f1 f4       	brne	.+60     	; 0x42ec <chb_write+0xda>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    42b0:	80 91 35 21 	lds	r24, 0x2135
    42b4:	90 91 36 21 	lds	r25, 0x2136
    42b8:	01 96       	adiw	r24, 0x01	; 1
    42ba:	80 93 35 21 	sts	0x2135, r24
    42be:	90 93 36 21 	sts	0x2136, r25
                 break;
    42c2:	15 c0       	rjmp	.+42     	; 0x42ee <chb_write+0xdc>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    42c4:	80 91 37 21 	lds	r24, 0x2137
    42c8:	90 91 38 21 	lds	r25, 0x2138
    42cc:	01 96       	adiw	r24, 0x01	; 1
    42ce:	80 93 37 21 	sts	0x2137, r24
    42d2:	90 93 38 21 	sts	0x2138, r25
                 break;
    42d6:	0b c0       	rjmp	.+22     	; 0x42ee <chb_write+0xdc>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    42d8:	80 91 39 21 	lds	r24, 0x2139
    42dc:	90 91 3a 21 	lds	r25, 0x213A
    42e0:	01 96       	adiw	r24, 0x01	; 1
    42e2:	80 93 39 21 	sts	0x2139, r24
    42e6:	90 93 3a 21 	sts	0x213A, r25
                 break;
    42ea:	01 c0       	rjmp	.+2      	; 0x42ee <chb_write+0xdc>
 
             default:
                 break;
    42ec:	00 00       	nop
             }
			if(rtry>=0) _delay_us(100);		//if not successfully sent the first time, wait some time and try again
    42ee:	8a 81       	ldd	r24, Y+2	; 0x02
    42f0:	9b 81       	ldd	r25, Y+3	; 0x03
    42f2:	99 23       	and	r25, r25
    42f4:	0c f4       	brge	.+2      	; 0x42f8 <chb_write+0xe6>
    42f6:	d5 c0       	rjmp	.+426    	; 0x44a2 <chb_write+0x290>
    42f8:	80 e0       	ldi	r24, 0x00	; 0
    42fa:	90 e0       	ldi	r25, 0x00	; 0
    42fc:	a8 ec       	ldi	r26, 0xC8	; 200
    42fe:	b2 e4       	ldi	r27, 0x42	; 66
    4300:	8f 83       	std	Y+7, r24	; 0x07
    4302:	98 87       	std	Y+8, r25	; 0x08
    4304:	a9 87       	std	Y+9, r26	; 0x09
    4306:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4308:	6f 81       	ldd	r22, Y+7	; 0x07
    430a:	78 85       	ldd	r23, Y+8	; 0x08
    430c:	89 85       	ldd	r24, Y+9	; 0x09
    430e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4310:	2b ea       	ldi	r18, 0xAB	; 171
    4312:	3a ea       	ldi	r19, 0xAA	; 170
    4314:	4a ea       	ldi	r20, 0xAA	; 170
    4316:	5e e3       	ldi	r21, 0x3E	; 62
    4318:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    431c:	dc 01       	movw	r26, r24
    431e:	cb 01       	movw	r24, r22
    4320:	8b 87       	std	Y+11, r24	; 0x0b
    4322:	9c 87       	std	Y+12, r25	; 0x0c
    4324:	ad 87       	std	Y+13, r26	; 0x0d
    4326:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    4328:	11 e0       	ldi	r17, 0x01	; 1
    432a:	6b 85       	ldd	r22, Y+11	; 0x0b
    432c:	7c 85       	ldd	r23, Y+12	; 0x0c
    432e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4330:	9e 85       	ldd	r25, Y+14	; 0x0e
    4332:	20 e0       	ldi	r18, 0x00	; 0
    4334:	30 e0       	ldi	r19, 0x00	; 0
    4336:	40 e8       	ldi	r20, 0x80	; 128
    4338:	5f e3       	ldi	r21, 0x3F	; 63
    433a:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    433e:	88 23       	and	r24, r24
    4340:	0c f0       	brlt	.+2      	; 0x4344 <chb_write+0x132>
    4342:	10 e0       	ldi	r17, 0x00	; 0
    4344:	11 23       	and	r17, r17
    4346:	19 f0       	breq	.+6      	; 0x434e <chb_write+0x13c>
		__ticks = 1;
    4348:	81 e0       	ldi	r24, 0x01	; 1
    434a:	8f 87       	std	Y+15, r24	; 0x0f
    434c:	a3 c0       	rjmp	.+326    	; 0x4494 <chb_write+0x282>
	else if (__tmp > 255)
    434e:	11 e0       	ldi	r17, 0x01	; 1
    4350:	6b 85       	ldd	r22, Y+11	; 0x0b
    4352:	7c 85       	ldd	r23, Y+12	; 0x0c
    4354:	8d 85       	ldd	r24, Y+13	; 0x0d
    4356:	9e 85       	ldd	r25, Y+14	; 0x0e
    4358:	20 e0       	ldi	r18, 0x00	; 0
    435a:	30 e0       	ldi	r19, 0x00	; 0
    435c:	4f e7       	ldi	r20, 0x7F	; 127
    435e:	53 e4       	ldi	r21, 0x43	; 67
    4360:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    4364:	18 16       	cp	r1, r24
    4366:	0c f0       	brlt	.+2      	; 0x436a <chb_write+0x158>
    4368:	10 e0       	ldi	r17, 0x00	; 0
    436a:	11 23       	and	r17, r17
    436c:	09 f4       	brne	.+2      	; 0x4370 <chb_write+0x15e>
    436e:	89 c0       	rjmp	.+274    	; 0x4482 <chb_write+0x270>
	{
		_delay_ms(__us / 1000.0);
    4370:	6f 81       	ldd	r22, Y+7	; 0x07
    4372:	78 85       	ldd	r23, Y+8	; 0x08
    4374:	89 85       	ldd	r24, Y+9	; 0x09
    4376:	9a 85       	ldd	r25, Y+10	; 0x0a
    4378:	20 e0       	ldi	r18, 0x00	; 0
    437a:	30 e0       	ldi	r19, 0x00	; 0
    437c:	4a e7       	ldi	r20, 0x7A	; 122
    437e:	54 e4       	ldi	r21, 0x44	; 68
    4380:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    4384:	dc 01       	movw	r26, r24
    4386:	cb 01       	movw	r24, r22
    4388:	88 8b       	std	Y+16, r24	; 0x10
    438a:	99 8b       	std	Y+17, r25	; 0x11
    438c:	aa 8b       	std	Y+18, r26	; 0x12
    438e:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4390:	68 89       	ldd	r22, Y+16	; 0x10
    4392:	79 89       	ldd	r23, Y+17	; 0x11
    4394:	8a 89       	ldd	r24, Y+18	; 0x12
    4396:	9b 89       	ldd	r25, Y+19	; 0x13
    4398:	20 e0       	ldi	r18, 0x00	; 0
    439a:	30 e0       	ldi	r19, 0x00	; 0
    439c:	4a e7       	ldi	r20, 0x7A	; 122
    439e:	53 e4       	ldi	r21, 0x43	; 67
    43a0:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    43a4:	dc 01       	movw	r26, r24
    43a6:	cb 01       	movw	r24, r22
    43a8:	8c 8b       	std	Y+20, r24	; 0x14
    43aa:	9d 8b       	std	Y+21, r25	; 0x15
    43ac:	ae 8b       	std	Y+22, r26	; 0x16
    43ae:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    43b0:	11 e0       	ldi	r17, 0x01	; 1
    43b2:	6c 89       	ldd	r22, Y+20	; 0x14
    43b4:	7d 89       	ldd	r23, Y+21	; 0x15
    43b6:	8e 89       	ldd	r24, Y+22	; 0x16
    43b8:	9f 89       	ldd	r25, Y+23	; 0x17
    43ba:	20 e0       	ldi	r18, 0x00	; 0
    43bc:	30 e0       	ldi	r19, 0x00	; 0
    43be:	40 e8       	ldi	r20, 0x80	; 128
    43c0:	5f e3       	ldi	r21, 0x3F	; 63
    43c2:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    43c6:	88 23       	and	r24, r24
    43c8:	0c f0       	brlt	.+2      	; 0x43cc <chb_write+0x1ba>
    43ca:	10 e0       	ldi	r17, 0x00	; 0
    43cc:	11 23       	and	r17, r17
    43ce:	29 f0       	breq	.+10     	; 0x43da <chb_write+0x1c8>
		__ticks = 1;
    43d0:	81 e0       	ldi	r24, 0x01	; 1
    43d2:	90 e0       	ldi	r25, 0x00	; 0
    43d4:	88 8f       	std	Y+24, r24	; 0x18
    43d6:	99 8f       	std	Y+25, r25	; 0x19
    43d8:	46 c0       	rjmp	.+140    	; 0x4466 <chb_write+0x254>
	else if (__tmp > 65535)
    43da:	11 e0       	ldi	r17, 0x01	; 1
    43dc:	6c 89       	ldd	r22, Y+20	; 0x14
    43de:	7d 89       	ldd	r23, Y+21	; 0x15
    43e0:	8e 89       	ldd	r24, Y+22	; 0x16
    43e2:	9f 89       	ldd	r25, Y+23	; 0x17
    43e4:	20 e0       	ldi	r18, 0x00	; 0
    43e6:	3f ef       	ldi	r19, 0xFF	; 255
    43e8:	4f e7       	ldi	r20, 0x7F	; 127
    43ea:	57 e4       	ldi	r21, 0x47	; 71
    43ec:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    43f0:	18 16       	cp	r1, r24
    43f2:	0c f0       	brlt	.+2      	; 0x43f6 <chb_write+0x1e4>
    43f4:	10 e0       	ldi	r17, 0x00	; 0
    43f6:	11 23       	and	r17, r17
    43f8:	61 f1       	breq	.+88     	; 0x4452 <chb_write+0x240>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    43fa:	68 89       	ldd	r22, Y+16	; 0x10
    43fc:	79 89       	ldd	r23, Y+17	; 0x11
    43fe:	8a 89       	ldd	r24, Y+18	; 0x12
    4400:	9b 89       	ldd	r25, Y+19	; 0x13
    4402:	20 e0       	ldi	r18, 0x00	; 0
    4404:	30 e0       	ldi	r19, 0x00	; 0
    4406:	40 e2       	ldi	r20, 0x20	; 32
    4408:	51 e4       	ldi	r21, 0x41	; 65
    440a:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    440e:	dc 01       	movw	r26, r24
    4410:	cb 01       	movw	r24, r22
    4412:	bc 01       	movw	r22, r24
    4414:	cd 01       	movw	r24, r26
    4416:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    441a:	dc 01       	movw	r26, r24
    441c:	cb 01       	movw	r24, r22
    441e:	88 8f       	std	Y+24, r24	; 0x18
    4420:	99 8f       	std	Y+25, r25	; 0x19
    4422:	12 c0       	rjmp	.+36     	; 0x4448 <chb_write+0x236>
    4424:	89 e1       	ldi	r24, 0x19	; 25
    4426:	90 e0       	ldi	r25, 0x00	; 0
    4428:	8a 8f       	std	Y+26, r24	; 0x1a
    442a:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    442c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    442e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4430:	8c 01       	movw	r16, r24
    4432:	c8 01       	movw	r24, r16
    4434:	01 97       	sbiw	r24, 0x01	; 1
    4436:	f1 f7       	brne	.-4      	; 0x4434 <chb_write+0x222>
    4438:	8c 01       	movw	r16, r24
    443a:	0a 8f       	std	Y+26, r16	; 0x1a
    443c:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    443e:	88 8d       	ldd	r24, Y+24	; 0x18
    4440:	99 8d       	ldd	r25, Y+25	; 0x19
    4442:	01 97       	sbiw	r24, 0x01	; 1
    4444:	88 8f       	std	Y+24, r24	; 0x18
    4446:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4448:	88 8d       	ldd	r24, Y+24	; 0x18
    444a:	99 8d       	ldd	r25, Y+25	; 0x19
    444c:	00 97       	sbiw	r24, 0x00	; 0
    444e:	51 f7       	brne	.-44     	; 0x4424 <chb_write+0x212>
    4450:	28 c0       	rjmp	.+80     	; 0x44a2 <chb_write+0x290>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4452:	6c 89       	ldd	r22, Y+20	; 0x14
    4454:	7d 89       	ldd	r23, Y+21	; 0x15
    4456:	8e 89       	ldd	r24, Y+22	; 0x16
    4458:	9f 89       	ldd	r25, Y+23	; 0x17
    445a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    445e:	dc 01       	movw	r26, r24
    4460:	cb 01       	movw	r24, r22
    4462:	88 8f       	std	Y+24, r24	; 0x18
    4464:	99 8f       	std	Y+25, r25	; 0x19
    4466:	88 8d       	ldd	r24, Y+24	; 0x18
    4468:	99 8d       	ldd	r25, Y+25	; 0x19
    446a:	8c 8f       	std	Y+28, r24	; 0x1c
    446c:	9d 8f       	std	Y+29, r25	; 0x1d
    446e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4470:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4472:	8c 01       	movw	r16, r24
    4474:	c8 01       	movw	r24, r16
    4476:	01 97       	sbiw	r24, 0x01	; 1
    4478:	f1 f7       	brne	.-4      	; 0x4476 <chb_write+0x264>
    447a:	8c 01       	movw	r16, r24
    447c:	0c 8f       	std	Y+28, r16	; 0x1c
    447e:	1d 8f       	std	Y+29, r17	; 0x1d
    4480:	10 c0       	rjmp	.+32     	; 0x44a2 <chb_write+0x290>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4482:	6b 85       	ldd	r22, Y+11	; 0x0b
    4484:	7c 85       	ldd	r23, Y+12	; 0x0c
    4486:	8d 85       	ldd	r24, Y+13	; 0x0d
    4488:	9e 85       	ldd	r25, Y+14	; 0x0e
    448a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    448e:	dc 01       	movw	r26, r24
    4490:	cb 01       	movw	r24, r22
    4492:	8f 87       	std	Y+15, r24	; 0x0f
    4494:	8f 85       	ldd	r24, Y+15	; 0x0f
    4496:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4498:	8e 8d       	ldd	r24, Y+30	; 0x1e
    449a:	18 2f       	mov	r17, r24
    449c:	1a 95       	dec	r17
    449e:	f1 f7       	brne	.-4      	; 0x449c <chb_write+0x28a>
    44a0:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message
    44a2:	8a 81       	ldd	r24, Y+2	; 0x02
    44a4:	9b 81       	ldd	r25, Y+3	; 0x03
    44a6:	84 31       	cpi	r24, 0x14	; 20
    44a8:	91 05       	cpc	r25, r1
    44aa:	11 f4       	brne	.+4      	; 0x44b0 <chb_write+0x29e>
    44ac:	8e 81       	ldd	r24, Y+6	; 0x06
    44ae:	2c c0       	rjmp	.+88     	; 0x4508 <chb_write+0x2f6>
			rtry++;	
    44b0:	8a 81       	ldd	r24, Y+2	; 0x02
    44b2:	9b 81       	ldd	r25, Y+3	; 0x03
    44b4:	01 96       	adiw	r24, 0x01	; 1
    44b6:	8a 83       	std	Y+2, r24	; 0x02
    44b8:	9b 83       	std	Y+3, r25	; 0x03
		} while(status != CHB_SUCCESS);			
    44ba:	8e 81       	ldd	r24, Y+6	; 0x06
    44bc:	88 23       	and	r24, r24
    44be:	09 f0       	breq	.+2      	; 0x44c2 <chb_write+0x2b0>
    44c0:	d6 ce       	rjmp	.-596    	; 0x426e <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    44c2:	99 81       	ldd	r25, Y+1	; 0x01
    44c4:	8c 81       	ldd	r24, Y+4	; 0x04
    44c6:	89 0f       	add	r24, r25
    44c8:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    44ca:	8c 81       	ldd	r24, Y+4	; 0x04
    44cc:	88 2f       	mov	r24, r24
    44ce:	90 e0       	ldi	r25, 0x00	; 0
    44d0:	a0 e0       	ldi	r26, 0x00	; 0
    44d2:	b0 e0       	ldi	r27, 0x00	; 0
    44d4:	2d a5       	lds	r18, 0x6d
    44d6:	3e a5       	lds	r19, 0x6e
    44d8:	4f a5       	lds	r20, 0x6f
    44da:	58 a9       	sts	0x48, r21
    44dc:	79 01       	movw	r14, r18
    44de:	8a 01       	movw	r16, r20
    44e0:	e8 1a       	sub	r14, r24
    44e2:	f9 0a       	sbc	r15, r25
    44e4:	0a 0b       	sbc	r16, r26
    44e6:	1b 0b       	sbc	r17, r27
    44e8:	d8 01       	movw	r26, r16
    44ea:	c7 01       	movw	r24, r14
    44ec:	8d a7       	lds	r24, 0x7d
    44ee:	9e a7       	lds	r25, 0x7e
    44f0:	af a7       	lds	r26, 0x7f
    44f2:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    44f4:	8d a5       	lds	r24, 0x6d
    44f6:	9e a5       	lds	r25, 0x6e
    44f8:	af a5       	lds	r26, 0x6f
    44fa:	b8 a9       	sts	0x48, r27
    44fc:	00 97       	sbiw	r24, 0x00	; 0
    44fe:	a1 05       	cpc	r26, r1
    4500:	b1 05       	cpc	r27, r1
    4502:	09 f0       	breq	.+2      	; 0x4506 <chb_write+0x2f4>
    4504:	9b ce       	rjmp	.-714    	; 0x423c <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    4506:	80 e0       	ldi	r24, 0x00	; 0
}
    4508:	e0 96       	adiw	r28, 0x30	; 48
    450a:	cd bf       	out	0x3d, r28	; 61
    450c:	de bf       	out	0x3e, r29	; 62
    450e:	df 91       	pop	r29
    4510:	cf 91       	pop	r28
    4512:	1f 91       	pop	r17
    4514:	0f 91       	pop	r16
    4516:	ff 90       	pop	r15
    4518:	ef 90       	pop	r14
    451a:	08 95       	ret

0000451c <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    451c:	cf 93       	push	r28
    451e:	df 93       	push	r29
    4520:	cd b7       	in	r28, 0x3d	; 61
    4522:	de b7       	in	r29, 0x3e	; 62
    4524:	27 97       	sbiw	r28, 0x07	; 7
    4526:	cd bf       	out	0x3d, r28	; 61
    4528:	de bf       	out	0x3e, r29	; 62
    452a:	8e 83       	std	Y+6, r24	; 0x06
    452c:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    452e:	8e 81       	ldd	r24, Y+6	; 0x06
    4530:	9f 81       	ldd	r25, Y+7	; 0x07
    4532:	05 96       	adiw	r24, 0x05	; 5
    4534:	8a 83       	std	Y+2, r24	; 0x02
    4536:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    4538:	0e 94 5b 23 	call	0x46b6	; 0x46b6 <chb_buf_read>
    453c:	8c 83       	std	Y+4, r24	; 0x04
    453e:	8c 81       	ldd	r24, Y+4	; 0x04
    4540:	88 23       	and	r24, r24
    4542:	14 f4       	brge	.+4      	; 0x4548 <chb_read+0x2c>
    {
        return 0;
    4544:	80 e0       	ldi	r24, 0x00	; 0
    4546:	80 c0       	rjmp	.+256    	; 0x4648 <chb_read+0x12c>
    }
    *data_ptr++ = len;
    4548:	8a 81       	ldd	r24, Y+2	; 0x02
    454a:	9b 81       	ldd	r25, Y+3	; 0x03
    454c:	2c 81       	ldd	r18, Y+4	; 0x04
    454e:	fc 01       	movw	r30, r24
    4550:	20 83       	st	Z, r18
    4552:	8a 81       	ldd	r24, Y+2	; 0x02
    4554:	9b 81       	ldd	r25, Y+3	; 0x03
    4556:	01 96       	adiw	r24, 0x01	; 1
    4558:	8a 83       	std	Y+2, r24	; 0x02
    455a:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    455c:	19 82       	std	Y+1, r1	; 0x01
    455e:	0f c0       	rjmp	.+30     	; 0x457e <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    4560:	0e 94 5b 23 	call	0x46b6	; 0x46b6 <chb_buf_read>
    4564:	28 2f       	mov	r18, r24
    4566:	8a 81       	ldd	r24, Y+2	; 0x02
    4568:	9b 81       	ldd	r25, Y+3	; 0x03
    456a:	fc 01       	movw	r30, r24
    456c:	20 83       	st	Z, r18
    456e:	8a 81       	ldd	r24, Y+2	; 0x02
    4570:	9b 81       	ldd	r25, Y+3	; 0x03
    4572:	01 96       	adiw	r24, 0x01	; 1
    4574:	8a 83       	std	Y+2, r24	; 0x02
    4576:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4578:	89 81       	ldd	r24, Y+1	; 0x01
    457a:	8f 5f       	subi	r24, 0xFF	; 255
    457c:	89 83       	std	Y+1, r24	; 0x01
    457e:	99 81       	ldd	r25, Y+1	; 0x01
    4580:	8c 81       	ldd	r24, Y+4	; 0x04
    4582:	98 17       	cp	r25, r24
    4584:	68 f3       	brcs	.-38     	; 0x4560 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    4586:	8e 81       	ldd	r24, Y+6	; 0x06
    4588:	9f 81       	ldd	r25, Y+7	; 0x07
    458a:	08 96       	adiw	r24, 0x08	; 8
    458c:	8a 83       	std	Y+2, r24	; 0x02
    458e:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4590:	8a 81       	ldd	r24, Y+2	; 0x02
    4592:	9b 81       	ldd	r25, Y+3	; 0x03
    4594:	fc 01       	movw	r30, r24
    4596:	80 81       	ld	r24, Z
    4598:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    459a:	8e 81       	ldd	r24, Y+6	; 0x06
    459c:	9f 81       	ldd	r25, Y+7	; 0x07
    459e:	0b 96       	adiw	r24, 0x0b	; 11
    45a0:	8a 83       	std	Y+2, r24	; 0x02
    45a2:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    45a4:	8a 81       	ldd	r24, Y+2	; 0x02
    45a6:	9b 81       	ldd	r25, Y+3	; 0x03
    45a8:	fc 01       	movw	r30, r24
    45aa:	20 81       	ld	r18, Z
    45ac:	31 81       	ldd	r19, Z+1	; 0x01
    45ae:	8e 81       	ldd	r24, Y+6	; 0x06
    45b0:	9f 81       	ldd	r25, Y+7	; 0x07
    45b2:	fc 01       	movw	r30, r24
    45b4:	23 83       	std	Z+3, r18	; 0x03
    45b6:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    45b8:	8a 81       	ldd	r24, Y+2	; 0x02
    45ba:	9b 81       	ldd	r25, Y+3	; 0x03
    45bc:	02 96       	adiw	r24, 0x02	; 2
    45be:	8a 83       	std	Y+2, r24	; 0x02
    45c0:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    45c2:	8a 81       	ldd	r24, Y+2	; 0x02
    45c4:	9b 81       	ldd	r25, Y+3	; 0x03
    45c6:	fc 01       	movw	r30, r24
    45c8:	20 81       	ld	r18, Z
    45ca:	31 81       	ldd	r19, Z+1	; 0x01
    45cc:	8e 81       	ldd	r24, Y+6	; 0x06
    45ce:	9f 81       	ldd	r25, Y+7	; 0x07
    45d0:	fc 01       	movw	r30, r24
    45d2:	21 83       	std	Z+1, r18	; 0x01
    45d4:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    45d6:	8a 81       	ldd	r24, Y+2	; 0x02
    45d8:	9b 81       	ldd	r25, Y+3	; 0x03
    45da:	02 96       	adiw	r24, 0x02	; 2
    45dc:	8a 83       	std	Y+2, r24	; 0x02
    45de:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    45e0:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_buf_get_len>
    45e4:	88 23       	and	r24, r24
    45e6:	11 f4       	brne	.+4      	; 0x45ec <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    45e8:	10 92 31 21 	sts	0x2131, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    45ec:	80 91 0c 20 	lds	r24, 0x200C
    45f0:	9d 81       	ldd	r25, Y+5	; 0x05
    45f2:	98 17       	cp	r25, r24
    45f4:	71 f4       	brne	.+28     	; 0x4612 <chb_read+0xf6>
    45f6:	8e 81       	ldd	r24, Y+6	; 0x06
    45f8:	9f 81       	ldd	r25, Y+7	; 0x07
    45fa:	fc 01       	movw	r30, r24
    45fc:	21 81       	ldd	r18, Z+1	; 0x01
    45fe:	32 81       	ldd	r19, Z+2	; 0x02
    4600:	80 91 0d 20 	lds	r24, 0x200D
    4604:	90 91 0e 20 	lds	r25, 0x200E
    4608:	28 17       	cp	r18, r24
    460a:	39 07       	cpc	r19, r25
    460c:	11 f4       	brne	.+4      	; 0x4612 <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    460e:	80 e0       	ldi	r24, 0x00	; 0
    4610:	1b c0       	rjmp	.+54     	; 0x4648 <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    4612:	8d 81       	ldd	r24, Y+5	; 0x05
    4614:	80 93 0c 20 	sts	0x200C, r24
        prev_src_addr = rx->src_addr;
    4618:	8e 81       	ldd	r24, Y+6	; 0x06
    461a:	9f 81       	ldd	r25, Y+7	; 0x07
    461c:	fc 01       	movw	r30, r24
    461e:	81 81       	ldd	r24, Z+1	; 0x01
    4620:	92 81       	ldd	r25, Z+2	; 0x02
    4622:	80 93 0d 20 	sts	0x200D, r24
    4626:	90 93 0e 20 	sts	0x200E, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    462a:	8c 81       	ldd	r24, Y+4	; 0x04
    462c:	88 2f       	mov	r24, r24
    462e:	90 e0       	ldi	r25, 0x00	; 0
    4630:	09 97       	sbiw	r24, 0x09	; 9
    4632:	9c 01       	movw	r18, r24
    4634:	8e 81       	ldd	r24, Y+6	; 0x06
    4636:	9f 81       	ldd	r25, Y+7	; 0x07
    4638:	4a 81       	ldd	r20, Y+2	; 0x02
    463a:	5b 81       	ldd	r21, Y+3	; 0x03
    463c:	ba 01       	movw	r22, r20
    463e:	a9 01       	movw	r20, r18
    4640:	0e 94 8d 5f 	call	0xbf1a	; 0xbf1a <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    4644:	8c 81       	ldd	r24, Y+4	; 0x04
    4646:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    4648:	27 96       	adiw	r28, 0x07	; 7
    464a:	cd bf       	out	0x3d, r28	; 61
    464c:	de bf       	out	0x3e, r29	; 62
    464e:	df 91       	pop	r29
    4650:	cf 91       	pop	r28
    4652:	08 95       	ret

00004654 <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    4654:	cf 93       	push	r28
    4656:	df 93       	push	r29
    4658:	cd b7       	in	r28, 0x3d	; 61
    465a:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    465c:	10 92 c2 21 	sts	0x21C2, r1
    wr_ptr = 0;
    4660:	10 92 c3 21 	sts	0x21C3, r1
    len = 0;
    4664:	10 92 c4 21 	sts	0x21C4, r1
}
    4668:	df 91       	pop	r29
    466a:	cf 91       	pop	r28
    466c:	08 95       	ret

0000466e <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    466e:	cf 93       	push	r28
    4670:	df 93       	push	r29
    4672:	0f 92       	push	r0
    4674:	cd b7       	in	r28, 0x3d	; 61
    4676:	de b7       	in	r29, 0x3e	; 62
    4678:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    467a:	80 91 c3 21 	lds	r24, 0x21C3
    467e:	88 2f       	mov	r24, r24
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	8e 5b       	subi	r24, 0xBE	; 190
    4684:	9e 4d       	sbci	r25, 0xDE	; 222
    4686:	29 81       	ldd	r18, Y+1	; 0x01
    4688:	fc 01       	movw	r30, r24
    468a:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    468c:	80 91 c3 21 	lds	r24, 0x21C3
    4690:	88 2f       	mov	r24, r24
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	01 96       	adiw	r24, 0x01	; 1
    4696:	20 e8       	ldi	r18, 0x80	; 128
    4698:	30 e0       	ldi	r19, 0x00	; 0
    469a:	b9 01       	movw	r22, r18
    469c:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    46a0:	80 93 c3 21 	sts	0x21C3, r24
    len++;
    46a4:	80 91 c4 21 	lds	r24, 0x21C4
    46a8:	8f 5f       	subi	r24, 0xFF	; 255
    46aa:	80 93 c4 21 	sts	0x21C4, r24
}
    46ae:	0f 90       	pop	r0
    46b0:	df 91       	pop	r29
    46b2:	cf 91       	pop	r28
    46b4:	08 95       	ret

000046b6 <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    46b6:	cf 93       	push	r28
    46b8:	df 93       	push	r29
    46ba:	0f 92       	push	r0
    46bc:	cd b7       	in	r28, 0x3d	; 61
    46be:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    46c0:	80 91 c2 21 	lds	r24, 0x21C2
    46c4:	88 2f       	mov	r24, r24
    46c6:	90 e0       	ldi	r25, 0x00	; 0
    46c8:	8e 5b       	subi	r24, 0xBE	; 190
    46ca:	9e 4d       	sbci	r25, 0xDE	; 222
    46cc:	fc 01       	movw	r30, r24
    46ce:	80 81       	ld	r24, Z
    46d0:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    46d2:	80 91 c2 21 	lds	r24, 0x21C2
    46d6:	88 2f       	mov	r24, r24
    46d8:	90 e0       	ldi	r25, 0x00	; 0
    46da:	01 96       	adiw	r24, 0x01	; 1
    46dc:	20 e8       	ldi	r18, 0x80	; 128
    46de:	30 e0       	ldi	r19, 0x00	; 0
    46e0:	b9 01       	movw	r22, r18
    46e2:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    46e6:	80 93 c2 21 	sts	0x21C2, r24
    len--;
    46ea:	80 91 c4 21 	lds	r24, 0x21C4
    46ee:	81 50       	subi	r24, 0x01	; 1
    46f0:	80 93 c4 21 	sts	0x21C4, r24
    return data;
    46f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    46f6:	0f 90       	pop	r0
    46f8:	df 91       	pop	r29
    46fa:	cf 91       	pop	r28
    46fc:	08 95       	ret

000046fe <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    46fe:	cf 93       	push	r28
    4700:	df 93       	push	r29
    4702:	cd b7       	in	r28, 0x3d	; 61
    4704:	de b7       	in	r29, 0x3e	; 62
    return len;
    4706:	80 91 c4 21 	lds	r24, 0x21C4
}
    470a:	df 91       	pop	r29
    470c:	cf 91       	pop	r28
    470e:	08 95       	ret

00004710 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    4710:	cf 93       	push	r28
    4712:	df 93       	push	r29
    4714:	cd b7       	in	r28, 0x3d	; 61
    4716:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    4718:	81 e0       	ldi	r24, 0x01	; 1
    471a:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    471e:	8f 71       	andi	r24, 0x1F	; 31
}
    4720:	df 91       	pop	r29
    4722:	cf 91       	pop	r28
    4724:	08 95       	ret

00004726 <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    4726:	cf 93       	push	r28
    4728:	df 93       	push	r29
    472a:	cd b7       	in	r28, 0x3d	; 61
    472c:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    472e:	82 e0       	ldi	r24, 0x02	; 2
    4730:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    4734:	82 95       	swap	r24
    4736:	86 95       	lsr	r24
    4738:	87 70       	andi	r24, 0x07	; 7
}
    473a:	df 91       	pop	r29
    473c:	cf 91       	pop	r28
    473e:	08 95       	ret

00004740 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    4740:	0f 93       	push	r16
    4742:	1f 93       	push	r17
    4744:	cf 93       	push	r28
    4746:	df 93       	push	r29
    4748:	cd b7       	in	r28, 0x3d	; 61
    474a:	de b7       	in	r29, 0x3e	; 62
    474c:	e0 97       	sbiw	r28, 0x30	; 48
    474e:	cd bf       	out	0x3d, r28	; 61
    4750:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    4752:	84 e6       	ldi	r24, 0x64	; 100
    4754:	96 e0       	ldi	r25, 0x06	; 6
    4756:	24 e6       	ldi	r18, 0x64	; 100
    4758:	36 e0       	ldi	r19, 0x06	; 6
    475a:	f9 01       	movw	r30, r18
    475c:	20 81       	ld	r18, Z
    475e:	21 60       	ori	r18, 0x01	; 1
    4760:	fc 01       	movw	r30, r24
    4762:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    4764:	84 e6       	ldi	r24, 0x64	; 100
    4766:	96 e0       	ldi	r25, 0x06	; 6
    4768:	24 e6       	ldi	r18, 0x64	; 100
    476a:	36 e0       	ldi	r19, 0x06	; 6
    476c:	f9 01       	movw	r30, r18
    476e:	20 81       	ld	r18, Z
    4770:	2d 7f       	andi	r18, 0xFD	; 253
    4772:	fc 01       	movw	r30, r24
    4774:	20 83       	st	Z, r18
    4776:	80 e0       	ldi	r24, 0x00	; 0
    4778:	90 e0       	ldi	r25, 0x00	; 0
    477a:	ae eb       	ldi	r26, 0xBE	; 190
    477c:	b3 e4       	ldi	r27, 0x43	; 67
    477e:	89 83       	std	Y+1, r24	; 0x01
    4780:	9a 83       	std	Y+2, r25	; 0x02
    4782:	ab 83       	std	Y+3, r26	; 0x03
    4784:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4786:	69 81       	ldd	r22, Y+1	; 0x01
    4788:	7a 81       	ldd	r23, Y+2	; 0x02
    478a:	8b 81       	ldd	r24, Y+3	; 0x03
    478c:	9c 81       	ldd	r25, Y+4	; 0x04
    478e:	2b ea       	ldi	r18, 0xAB	; 171
    4790:	3a ea       	ldi	r19, 0xAA	; 170
    4792:	4a ea       	ldi	r20, 0xAA	; 170
    4794:	5e e3       	ldi	r21, 0x3E	; 62
    4796:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    479a:	dc 01       	movw	r26, r24
    479c:	cb 01       	movw	r24, r22
    479e:	8d 83       	std	Y+5, r24	; 0x05
    47a0:	9e 83       	std	Y+6, r25	; 0x06
    47a2:	af 83       	std	Y+7, r26	; 0x07
    47a4:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    47a6:	11 e0       	ldi	r17, 0x01	; 1
    47a8:	6d 81       	ldd	r22, Y+5	; 0x05
    47aa:	7e 81       	ldd	r23, Y+6	; 0x06
    47ac:	8f 81       	ldd	r24, Y+7	; 0x07
    47ae:	98 85       	ldd	r25, Y+8	; 0x08
    47b0:	20 e0       	ldi	r18, 0x00	; 0
    47b2:	30 e0       	ldi	r19, 0x00	; 0
    47b4:	40 e8       	ldi	r20, 0x80	; 128
    47b6:	5f e3       	ldi	r21, 0x3F	; 63
    47b8:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    47bc:	88 23       	and	r24, r24
    47be:	0c f0       	brlt	.+2      	; 0x47c2 <chb_reset+0x82>
    47c0:	10 e0       	ldi	r17, 0x00	; 0
    47c2:	11 23       	and	r17, r17
    47c4:	19 f0       	breq	.+6      	; 0x47cc <chb_reset+0x8c>
		__ticks = 1;
    47c6:	81 e0       	ldi	r24, 0x01	; 1
    47c8:	89 87       	std	Y+9, r24	; 0x09
    47ca:	a3 c0       	rjmp	.+326    	; 0x4912 <chb_reset+0x1d2>
	else if (__tmp > 255)
    47cc:	11 e0       	ldi	r17, 0x01	; 1
    47ce:	6d 81       	ldd	r22, Y+5	; 0x05
    47d0:	7e 81       	ldd	r23, Y+6	; 0x06
    47d2:	8f 81       	ldd	r24, Y+7	; 0x07
    47d4:	98 85       	ldd	r25, Y+8	; 0x08
    47d6:	20 e0       	ldi	r18, 0x00	; 0
    47d8:	30 e0       	ldi	r19, 0x00	; 0
    47da:	4f e7       	ldi	r20, 0x7F	; 127
    47dc:	53 e4       	ldi	r21, 0x43	; 67
    47de:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    47e2:	18 16       	cp	r1, r24
    47e4:	0c f0       	brlt	.+2      	; 0x47e8 <chb_reset+0xa8>
    47e6:	10 e0       	ldi	r17, 0x00	; 0
    47e8:	11 23       	and	r17, r17
    47ea:	09 f4       	brne	.+2      	; 0x47ee <chb_reset+0xae>
    47ec:	89 c0       	rjmp	.+274    	; 0x4900 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    47ee:	69 81       	ldd	r22, Y+1	; 0x01
    47f0:	7a 81       	ldd	r23, Y+2	; 0x02
    47f2:	8b 81       	ldd	r24, Y+3	; 0x03
    47f4:	9c 81       	ldd	r25, Y+4	; 0x04
    47f6:	20 e0       	ldi	r18, 0x00	; 0
    47f8:	30 e0       	ldi	r19, 0x00	; 0
    47fa:	4a e7       	ldi	r20, 0x7A	; 122
    47fc:	54 e4       	ldi	r21, 0x44	; 68
    47fe:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    4802:	dc 01       	movw	r26, r24
    4804:	cb 01       	movw	r24, r22
    4806:	8a 87       	std	Y+10, r24	; 0x0a
    4808:	9b 87       	std	Y+11, r25	; 0x0b
    480a:	ac 87       	std	Y+12, r26	; 0x0c
    480c:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    480e:	6a 85       	ldd	r22, Y+10	; 0x0a
    4810:	7b 85       	ldd	r23, Y+11	; 0x0b
    4812:	8c 85       	ldd	r24, Y+12	; 0x0c
    4814:	9d 85       	ldd	r25, Y+13	; 0x0d
    4816:	20 e0       	ldi	r18, 0x00	; 0
    4818:	30 e0       	ldi	r19, 0x00	; 0
    481a:	4a e7       	ldi	r20, 0x7A	; 122
    481c:	53 e4       	ldi	r21, 0x43	; 67
    481e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    4822:	dc 01       	movw	r26, r24
    4824:	cb 01       	movw	r24, r22
    4826:	8e 87       	std	Y+14, r24	; 0x0e
    4828:	9f 87       	std	Y+15, r25	; 0x0f
    482a:	a8 8b       	std	Y+16, r26	; 0x10
    482c:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    482e:	11 e0       	ldi	r17, 0x01	; 1
    4830:	6e 85       	ldd	r22, Y+14	; 0x0e
    4832:	7f 85       	ldd	r23, Y+15	; 0x0f
    4834:	88 89       	ldd	r24, Y+16	; 0x10
    4836:	99 89       	ldd	r25, Y+17	; 0x11
    4838:	20 e0       	ldi	r18, 0x00	; 0
    483a:	30 e0       	ldi	r19, 0x00	; 0
    483c:	40 e8       	ldi	r20, 0x80	; 128
    483e:	5f e3       	ldi	r21, 0x3F	; 63
    4840:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    4844:	88 23       	and	r24, r24
    4846:	0c f0       	brlt	.+2      	; 0x484a <chb_reset+0x10a>
    4848:	10 e0       	ldi	r17, 0x00	; 0
    484a:	11 23       	and	r17, r17
    484c:	29 f0       	breq	.+10     	; 0x4858 <chb_reset+0x118>
		__ticks = 1;
    484e:	81 e0       	ldi	r24, 0x01	; 1
    4850:	90 e0       	ldi	r25, 0x00	; 0
    4852:	8a 8b       	std	Y+18, r24	; 0x12
    4854:	9b 8b       	std	Y+19, r25	; 0x13
    4856:	46 c0       	rjmp	.+140    	; 0x48e4 <chb_reset+0x1a4>
	else if (__tmp > 65535)
    4858:	11 e0       	ldi	r17, 0x01	; 1
    485a:	6e 85       	ldd	r22, Y+14	; 0x0e
    485c:	7f 85       	ldd	r23, Y+15	; 0x0f
    485e:	88 89       	ldd	r24, Y+16	; 0x10
    4860:	99 89       	ldd	r25, Y+17	; 0x11
    4862:	20 e0       	ldi	r18, 0x00	; 0
    4864:	3f ef       	ldi	r19, 0xFF	; 255
    4866:	4f e7       	ldi	r20, 0x7F	; 127
    4868:	57 e4       	ldi	r21, 0x47	; 71
    486a:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    486e:	18 16       	cp	r1, r24
    4870:	0c f0       	brlt	.+2      	; 0x4874 <chb_reset+0x134>
    4872:	10 e0       	ldi	r17, 0x00	; 0
    4874:	11 23       	and	r17, r17
    4876:	61 f1       	breq	.+88     	; 0x48d0 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4878:	6a 85       	ldd	r22, Y+10	; 0x0a
    487a:	7b 85       	ldd	r23, Y+11	; 0x0b
    487c:	8c 85       	ldd	r24, Y+12	; 0x0c
    487e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4880:	20 e0       	ldi	r18, 0x00	; 0
    4882:	30 e0       	ldi	r19, 0x00	; 0
    4884:	40 e2       	ldi	r20, 0x20	; 32
    4886:	51 e4       	ldi	r21, 0x41	; 65
    4888:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    488c:	dc 01       	movw	r26, r24
    488e:	cb 01       	movw	r24, r22
    4890:	bc 01       	movw	r22, r24
    4892:	cd 01       	movw	r24, r26
    4894:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    4898:	dc 01       	movw	r26, r24
    489a:	cb 01       	movw	r24, r22
    489c:	8a 8b       	std	Y+18, r24	; 0x12
    489e:	9b 8b       	std	Y+19, r25	; 0x13
    48a0:	12 c0       	rjmp	.+36     	; 0x48c6 <chb_reset+0x186>
    48a2:	89 e1       	ldi	r24, 0x19	; 25
    48a4:	90 e0       	ldi	r25, 0x00	; 0
    48a6:	8c 8b       	std	Y+20, r24	; 0x14
    48a8:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    48aa:	8c 89       	ldd	r24, Y+20	; 0x14
    48ac:	9d 89       	ldd	r25, Y+21	; 0x15
    48ae:	8c 01       	movw	r16, r24
    48b0:	c8 01       	movw	r24, r16
    48b2:	01 97       	sbiw	r24, 0x01	; 1
    48b4:	f1 f7       	brne	.-4      	; 0x48b2 <chb_reset+0x172>
    48b6:	8c 01       	movw	r16, r24
    48b8:	0c 8b       	std	Y+20, r16	; 0x14
    48ba:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    48bc:	8a 89       	ldd	r24, Y+18	; 0x12
    48be:	9b 89       	ldd	r25, Y+19	; 0x13
    48c0:	01 97       	sbiw	r24, 0x01	; 1
    48c2:	8a 8b       	std	Y+18, r24	; 0x12
    48c4:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    48c6:	8a 89       	ldd	r24, Y+18	; 0x12
    48c8:	9b 89       	ldd	r25, Y+19	; 0x13
    48ca:	00 97       	sbiw	r24, 0x00	; 0
    48cc:	51 f7       	brne	.-44     	; 0x48a2 <chb_reset+0x162>
    48ce:	28 c0       	rjmp	.+80     	; 0x4920 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    48d0:	6e 85       	ldd	r22, Y+14	; 0x0e
    48d2:	7f 85       	ldd	r23, Y+15	; 0x0f
    48d4:	88 89       	ldd	r24, Y+16	; 0x10
    48d6:	99 89       	ldd	r25, Y+17	; 0x11
    48d8:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    48dc:	dc 01       	movw	r26, r24
    48de:	cb 01       	movw	r24, r22
    48e0:	8a 8b       	std	Y+18, r24	; 0x12
    48e2:	9b 8b       	std	Y+19, r25	; 0x13
    48e4:	8a 89       	ldd	r24, Y+18	; 0x12
    48e6:	9b 89       	ldd	r25, Y+19	; 0x13
    48e8:	8e 8b       	std	Y+22, r24	; 0x16
    48ea:	9f 8b       	std	Y+23, r25	; 0x17
    48ec:	8e 89       	ldd	r24, Y+22	; 0x16
    48ee:	9f 89       	ldd	r25, Y+23	; 0x17
    48f0:	8c 01       	movw	r16, r24
    48f2:	f8 01       	movw	r30, r16
    48f4:	31 97       	sbiw	r30, 0x01	; 1
    48f6:	f1 f7       	brne	.-4      	; 0x48f4 <chb_reset+0x1b4>
    48f8:	8f 01       	movw	r16, r30
    48fa:	0e 8b       	std	Y+22, r16	; 0x16
    48fc:	1f 8b       	std	Y+23, r17	; 0x17
    48fe:	10 c0       	rjmp	.+32     	; 0x4920 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4900:	6d 81       	ldd	r22, Y+5	; 0x05
    4902:	7e 81       	ldd	r23, Y+6	; 0x06
    4904:	8f 81       	ldd	r24, Y+7	; 0x07
    4906:	98 85       	ldd	r25, Y+8	; 0x08
    4908:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    490c:	dc 01       	movw	r26, r24
    490e:	cb 01       	movw	r24, r22
    4910:	89 87       	std	Y+9, r24	; 0x09
    4912:	89 85       	ldd	r24, Y+9	; 0x09
    4914:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4916:	88 8d       	ldd	r24, Y+24	; 0x18
    4918:	18 2f       	mov	r17, r24
    491a:	1a 95       	dec	r17
    491c:	f1 f7       	brne	.-4      	; 0x491a <chb_reset+0x1da>
    491e:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    4920:	84 e6       	ldi	r24, 0x64	; 100
    4922:	96 e0       	ldi	r25, 0x06	; 6
    4924:	24 e6       	ldi	r18, 0x64	; 100
    4926:	36 e0       	ldi	r19, 0x06	; 6
    4928:	f9 01       	movw	r30, r18
    492a:	20 81       	ld	r18, Z
    492c:	2e 7f       	andi	r18, 0xFE	; 254
    492e:	fc 01       	movw	r30, r24
    4930:	20 83       	st	Z, r18
    4932:	80 e0       	ldi	r24, 0x00	; 0
    4934:	90 e0       	ldi	r25, 0x00	; 0
    4936:	a0 e8       	ldi	r26, 0x80	; 128
    4938:	bf e3       	ldi	r27, 0x3F	; 63
    493a:	89 8f       	std	Y+25, r24	; 0x19
    493c:	9a 8f       	std	Y+26, r25	; 0x1a
    493e:	ab 8f       	std	Y+27, r26	; 0x1b
    4940:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4942:	69 8d       	ldd	r22, Y+25	; 0x19
    4944:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4946:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4948:	9c 8d       	ldd	r25, Y+28	; 0x1c
    494a:	2b ea       	ldi	r18, 0xAB	; 171
    494c:	3a ea       	ldi	r19, 0xAA	; 170
    494e:	4a ea       	ldi	r20, 0xAA	; 170
    4950:	5e e3       	ldi	r21, 0x3E	; 62
    4952:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    4956:	dc 01       	movw	r26, r24
    4958:	cb 01       	movw	r24, r22
    495a:	8d 8f       	std	Y+29, r24	; 0x1d
    495c:	9e 8f       	std	Y+30, r25	; 0x1e
    495e:	af 8f       	std	Y+31, r26	; 0x1f
    4960:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    4962:	11 e0       	ldi	r17, 0x01	; 1
    4964:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4966:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4968:	8f 8d       	ldd	r24, Y+31	; 0x1f
    496a:	98 a1       	lds	r25, 0x48
    496c:	20 e0       	ldi	r18, 0x00	; 0
    496e:	30 e0       	ldi	r19, 0x00	; 0
    4970:	40 e8       	ldi	r20, 0x80	; 128
    4972:	5f e3       	ldi	r21, 0x3F	; 63
    4974:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    4978:	88 23       	and	r24, r24
    497a:	0c f0       	brlt	.+2      	; 0x497e <chb_reset+0x23e>
    497c:	10 e0       	ldi	r17, 0x00	; 0
    497e:	11 23       	and	r17, r17
    4980:	19 f0       	breq	.+6      	; 0x4988 <chb_reset+0x248>
		__ticks = 1;
    4982:	81 e0       	ldi	r24, 0x01	; 1
    4984:	89 a3       	lds	r24, 0x59
    4986:	a3 c0       	rjmp	.+326    	; 0x4ace <chb_reset+0x38e>
	else if (__tmp > 255)
    4988:	11 e0       	ldi	r17, 0x01	; 1
    498a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    498c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    498e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4990:	98 a1       	lds	r25, 0x48
    4992:	20 e0       	ldi	r18, 0x00	; 0
    4994:	30 e0       	ldi	r19, 0x00	; 0
    4996:	4f e7       	ldi	r20, 0x7F	; 127
    4998:	53 e4       	ldi	r21, 0x43	; 67
    499a:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    499e:	18 16       	cp	r1, r24
    49a0:	0c f0       	brlt	.+2      	; 0x49a4 <chb_reset+0x264>
    49a2:	10 e0       	ldi	r17, 0x00	; 0
    49a4:	11 23       	and	r17, r17
    49a6:	09 f4       	brne	.+2      	; 0x49aa <chb_reset+0x26a>
    49a8:	89 c0       	rjmp	.+274    	; 0x4abc <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    49aa:	69 8d       	ldd	r22, Y+25	; 0x19
    49ac:	7a 8d       	ldd	r23, Y+26	; 0x1a
    49ae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    49b0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    49b2:	20 e0       	ldi	r18, 0x00	; 0
    49b4:	30 e0       	ldi	r19, 0x00	; 0
    49b6:	4a e7       	ldi	r20, 0x7A	; 122
    49b8:	54 e4       	ldi	r21, 0x44	; 68
    49ba:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    49be:	dc 01       	movw	r26, r24
    49c0:	cb 01       	movw	r24, r22
    49c2:	8a a3       	lds	r24, 0x5a
    49c4:	9b a3       	lds	r25, 0x5b
    49c6:	ac a3       	lds	r26, 0x5c
    49c8:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    49ca:	6a a1       	lds	r22, 0x4a
    49cc:	7b a1       	lds	r23, 0x4b
    49ce:	8c a1       	lds	r24, 0x4c
    49d0:	9d a1       	lds	r25, 0x4d
    49d2:	20 e0       	ldi	r18, 0x00	; 0
    49d4:	30 e0       	ldi	r19, 0x00	; 0
    49d6:	4a e7       	ldi	r20, 0x7A	; 122
    49d8:	53 e4       	ldi	r21, 0x43	; 67
    49da:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    49de:	dc 01       	movw	r26, r24
    49e0:	cb 01       	movw	r24, r22
    49e2:	8e a3       	lds	r24, 0x5e
    49e4:	9f a3       	lds	r25, 0x5f
    49e6:	a8 a7       	lds	r26, 0x78
    49e8:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    49ea:	11 e0       	ldi	r17, 0x01	; 1
    49ec:	6e a1       	lds	r22, 0x4e
    49ee:	7f a1       	lds	r23, 0x4f
    49f0:	88 a5       	lds	r24, 0x68
    49f2:	99 a5       	lds	r25, 0x69
    49f4:	20 e0       	ldi	r18, 0x00	; 0
    49f6:	30 e0       	ldi	r19, 0x00	; 0
    49f8:	40 e8       	ldi	r20, 0x80	; 128
    49fa:	5f e3       	ldi	r21, 0x3F	; 63
    49fc:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    4a00:	88 23       	and	r24, r24
    4a02:	0c f0       	brlt	.+2      	; 0x4a06 <chb_reset+0x2c6>
    4a04:	10 e0       	ldi	r17, 0x00	; 0
    4a06:	11 23       	and	r17, r17
    4a08:	29 f0       	breq	.+10     	; 0x4a14 <chb_reset+0x2d4>
		__ticks = 1;
    4a0a:	81 e0       	ldi	r24, 0x01	; 1
    4a0c:	90 e0       	ldi	r25, 0x00	; 0
    4a0e:	8a a7       	lds	r24, 0x7a
    4a10:	9b a7       	lds	r25, 0x7b
    4a12:	46 c0       	rjmp	.+140    	; 0x4aa0 <chb_reset+0x360>
	else if (__tmp > 65535)
    4a14:	11 e0       	ldi	r17, 0x01	; 1
    4a16:	6e a1       	lds	r22, 0x4e
    4a18:	7f a1       	lds	r23, 0x4f
    4a1a:	88 a5       	lds	r24, 0x68
    4a1c:	99 a5       	lds	r25, 0x69
    4a1e:	20 e0       	ldi	r18, 0x00	; 0
    4a20:	3f ef       	ldi	r19, 0xFF	; 255
    4a22:	4f e7       	ldi	r20, 0x7F	; 127
    4a24:	57 e4       	ldi	r21, 0x47	; 71
    4a26:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    4a2a:	18 16       	cp	r1, r24
    4a2c:	0c f0       	brlt	.+2      	; 0x4a30 <chb_reset+0x2f0>
    4a2e:	10 e0       	ldi	r17, 0x00	; 0
    4a30:	11 23       	and	r17, r17
    4a32:	61 f1       	breq	.+88     	; 0x4a8c <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a34:	6a a1       	lds	r22, 0x4a
    4a36:	7b a1       	lds	r23, 0x4b
    4a38:	8c a1       	lds	r24, 0x4c
    4a3a:	9d a1       	lds	r25, 0x4d
    4a3c:	20 e0       	ldi	r18, 0x00	; 0
    4a3e:	30 e0       	ldi	r19, 0x00	; 0
    4a40:	40 e2       	ldi	r20, 0x20	; 32
    4a42:	51 e4       	ldi	r21, 0x41	; 65
    4a44:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    4a48:	dc 01       	movw	r26, r24
    4a4a:	cb 01       	movw	r24, r22
    4a4c:	bc 01       	movw	r22, r24
    4a4e:	cd 01       	movw	r24, r26
    4a50:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    4a54:	dc 01       	movw	r26, r24
    4a56:	cb 01       	movw	r24, r22
    4a58:	8a a7       	lds	r24, 0x7a
    4a5a:	9b a7       	lds	r25, 0x7b
    4a5c:	12 c0       	rjmp	.+36     	; 0x4a82 <chb_reset+0x342>
    4a5e:	89 e1       	ldi	r24, 0x19	; 25
    4a60:	90 e0       	ldi	r25, 0x00	; 0
    4a62:	8c a7       	lds	r24, 0x7c
    4a64:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4a66:	8c a5       	lds	r24, 0x6c
    4a68:	9d a5       	lds	r25, 0x6d
    4a6a:	8c 01       	movw	r16, r24
    4a6c:	c8 01       	movw	r24, r16
    4a6e:	01 97       	sbiw	r24, 0x01	; 1
    4a70:	f1 f7       	brne	.-4      	; 0x4a6e <chb_reset+0x32e>
    4a72:	8c 01       	movw	r16, r24
    4a74:	0c a7       	lds	r16, 0x7c
    4a76:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a78:	8a a5       	lds	r24, 0x6a
    4a7a:	9b a5       	lds	r25, 0x6b
    4a7c:	01 97       	sbiw	r24, 0x01	; 1
    4a7e:	8a a7       	lds	r24, 0x7a
    4a80:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a82:	8a a5       	lds	r24, 0x6a
    4a84:	9b a5       	lds	r25, 0x6b
    4a86:	00 97       	sbiw	r24, 0x00	; 0
    4a88:	51 f7       	brne	.-44     	; 0x4a5e <chb_reset+0x31e>
    4a8a:	28 c0       	rjmp	.+80     	; 0x4adc <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a8c:	6e a1       	lds	r22, 0x4e
    4a8e:	7f a1       	lds	r23, 0x4f
    4a90:	88 a5       	lds	r24, 0x68
    4a92:	99 a5       	lds	r25, 0x69
    4a94:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    4a98:	dc 01       	movw	r26, r24
    4a9a:	cb 01       	movw	r24, r22
    4a9c:	8a a7       	lds	r24, 0x7a
    4a9e:	9b a7       	lds	r25, 0x7b
    4aa0:	8a a5       	lds	r24, 0x6a
    4aa2:	9b a5       	lds	r25, 0x6b
    4aa4:	8e a7       	lds	r24, 0x7e
    4aa6:	9f a7       	lds	r25, 0x7f
    4aa8:	8e a5       	lds	r24, 0x6e
    4aaa:	9f a5       	lds	r25, 0x6f
    4aac:	8c 01       	movw	r16, r24
    4aae:	f8 01       	movw	r30, r16
    4ab0:	31 97       	sbiw	r30, 0x01	; 1
    4ab2:	f1 f7       	brne	.-4      	; 0x4ab0 <chb_reset+0x370>
    4ab4:	8f 01       	movw	r16, r30
    4ab6:	0e a7       	lds	r16, 0x7e
    4ab8:	1f a7       	lds	r17, 0x7f
    4aba:	10 c0       	rjmp	.+32     	; 0x4adc <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4abc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4abe:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4ac0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4ac2:	98 a1       	lds	r25, 0x48
    4ac4:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    4ac8:	dc 01       	movw	r26, r24
    4aca:	cb 01       	movw	r24, r22
    4acc:	89 a3       	lds	r24, 0x59
    4ace:	89 a1       	lds	r24, 0x49
    4ad0:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4ad2:	88 a9       	sts	0x48, r24
    4ad4:	18 2f       	mov	r17, r24
    4ad6:	1a 95       	dec	r17
    4ad8:	f1 f7       	brne	.-4      	; 0x4ad6 <chb_reset+0x396>
    4ada:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4adc:	84 e6       	ldi	r24, 0x64	; 100
    4ade:	96 e0       	ldi	r25, 0x06	; 6
    4ae0:	24 e6       	ldi	r18, 0x64	; 100
    4ae2:	36 e0       	ldi	r19, 0x06	; 6
    4ae4:	f9 01       	movw	r30, r18
    4ae6:	20 81       	ld	r18, Z
    4ae8:	21 60       	ori	r18, 0x01	; 1
    4aea:	fc 01       	movw	r30, r24
    4aec:	20 83       	st	Z, r18
    4aee:	01 c0       	rjmp	.+2      	; 0x4af2 <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4af0:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    4af2:	8d e1       	ldi	r24, 0x1D	; 29
    4af4:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    4af8:	81 30       	cpi	r24, 0x01	; 1
    4afa:	d1 f7       	brne	.-12     	; 0x4af0 <chb_reset+0x3b0>
    4afc:	8c e1       	ldi	r24, 0x1C	; 28
    4afe:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    4b02:	87 30       	cpi	r24, 0x07	; 7
    4b04:	a9 f7       	brne	.-22     	; 0x4af0 <chb_reset+0x3b0>
        {
            break;
    4b06:	00 00       	nop
        }
    }
	

}
    4b08:	e0 96       	adiw	r28, 0x30	; 48
    4b0a:	cd bf       	out	0x3d, r28	; 61
    4b0c:	de bf       	out	0x3e, r29	; 62
    4b0e:	df 91       	pop	r29
    4b10:	cf 91       	pop	r28
    4b12:	1f 91       	pop	r17
    4b14:	0f 91       	pop	r16
    4b16:	08 95       	ret

00004b18 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    4b18:	cf 93       	push	r28
    4b1a:	df 93       	push	r29
    4b1c:	0f 92       	push	r0
    4b1e:	0f 92       	push	r0
    4b20:	cd b7       	in	r28, 0x3d	; 61
    4b22:	de b7       	in	r29, 0x3e	; 62
    4b24:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    4b26:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    4b28:	8a 81       	ldd	r24, Y+2	; 0x02
    4b2a:	80 68       	ori	r24, 0x80	; 128
    4b2c:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4b2e:	8f e3       	ldi	r24, 0x3F	; 63
    4b30:	90 e0       	ldi	r25, 0x00	; 0
    4b32:	fc 01       	movw	r30, r24
    4b34:	80 81       	ld	r24, Z
    4b36:	80 93 45 40 	sts	0x4045, r24
    4b3a:	f8 94       	cli
    RadioCS(TRUE);
    4b3c:	81 e0       	ldi	r24, 0x01	; 1
    4b3e:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4b42:	8a 81       	ldd	r24, Y+2	; 0x02
    4b44:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4b48:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4b4a:	89 81       	ldd	r24, Y+1	; 0x01
    4b4c:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4b50:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4b52:	80 e0       	ldi	r24, 0x00	; 0
    4b54:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>
    CHB_LEAVE_CRIT();
    4b58:	8f e3       	ldi	r24, 0x3F	; 63
    4b5a:	90 e0       	ldi	r25, 0x00	; 0
    4b5c:	20 91 45 40 	lds	r18, 0x4045
    4b60:	fc 01       	movw	r30, r24
    4b62:	20 83       	st	Z, r18
    4b64:	78 94       	sei

    return val;
    4b66:	89 81       	ldd	r24, Y+1	; 0x01
}
    4b68:	0f 90       	pop	r0
    4b6a:	0f 90       	pop	r0
    4b6c:	df 91       	pop	r29
    4b6e:	cf 91       	pop	r28
    4b70:	08 95       	ret

00004b72 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4b72:	cf 93       	push	r28
    4b74:	df 93       	push	r29
    4b76:	00 d0       	rcall	.+0      	; 0x4b78 <chb_reg_read16+0x6>
    4b78:	0f 92       	push	r0
    4b7a:	cd b7       	in	r28, 0x3d	; 61
    4b7c:	de b7       	in	r29, 0x3e	; 62
    4b7e:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4b80:	1a 82       	std	Y+2, r1	; 0x02
    4b82:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    4b84:	19 82       	std	Y+1, r1	; 0x01
    4b86:	1d c0       	rjmp	.+58     	; 0x4bc2 <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4b88:	9c 81       	ldd	r25, Y+4	; 0x04
    4b8a:	89 81       	ldd	r24, Y+1	; 0x01
    4b8c:	89 0f       	add	r24, r25
    4b8e:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    4b92:	88 2f       	mov	r24, r24
    4b94:	90 e0       	ldi	r25, 0x00	; 0
    4b96:	29 81       	ldd	r18, Y+1	; 0x01
    4b98:	22 2f       	mov	r18, r18
    4b9a:	30 e0       	ldi	r19, 0x00	; 0
    4b9c:	22 0f       	add	r18, r18
    4b9e:	33 1f       	adc	r19, r19
    4ba0:	22 0f       	add	r18, r18
    4ba2:	33 1f       	adc	r19, r19
    4ba4:	22 0f       	add	r18, r18
    4ba6:	33 1f       	adc	r19, r19
    4ba8:	02 2e       	mov	r0, r18
    4baa:	02 c0       	rjmp	.+4      	; 0x4bb0 <chb_reg_read16+0x3e>
    4bac:	88 0f       	add	r24, r24
    4bae:	99 1f       	adc	r25, r25
    4bb0:	0a 94       	dec	r0
    4bb2:	e2 f7       	brpl	.-8      	; 0x4bac <chb_reg_read16+0x3a>
    4bb4:	98 2f       	mov	r25, r24
    4bb6:	8c 81       	ldd	r24, Y+4	; 0x04
    4bb8:	89 2b       	or	r24, r25
    4bba:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4bbc:	89 81       	ldd	r24, Y+1	; 0x01
    4bbe:	8f 5f       	subi	r24, 0xFF	; 255
    4bc0:	89 83       	std	Y+1, r24	; 0x01
    4bc2:	89 81       	ldd	r24, Y+1	; 0x01
    4bc4:	82 30       	cpi	r24, 0x02	; 2
    4bc6:	00 f3       	brcs	.-64     	; 0x4b88 <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    4bc8:	8a 81       	ldd	r24, Y+2	; 0x02
    4bca:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4bcc:	24 96       	adiw	r28, 0x04	; 4
    4bce:	cd bf       	out	0x3d, r28	; 61
    4bd0:	de bf       	out	0x3e, r29	; 62
    4bd2:	df 91       	pop	r29
    4bd4:	cf 91       	pop	r28
    4bd6:	08 95       	ret

00004bd8 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    4bd8:	cf 93       	push	r28
    4bda:	df 93       	push	r29
    4bdc:	00 d0       	rcall	.+0      	; 0x4bde <chb_reg_write+0x6>
    4bde:	cd b7       	in	r28, 0x3d	; 61
    4be0:	de b7       	in	r29, 0x3e	; 62
    4be2:	8a 83       	std	Y+2, r24	; 0x02
    4be4:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    4be6:	8a 81       	ldd	r24, Y+2	; 0x02
    4be8:	80 6c       	ori	r24, 0xC0	; 192
    4bea:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4bec:	8f e3       	ldi	r24, 0x3F	; 63
    4bee:	90 e0       	ldi	r25, 0x00	; 0
    4bf0:	fc 01       	movw	r30, r24
    4bf2:	80 81       	ld	r24, Z
    4bf4:	80 93 45 40 	sts	0x4045, r24
    4bf8:	f8 94       	cli
    RadioCS(TRUE);
    4bfa:	81 e0       	ldi	r24, 0x01	; 1
    4bfc:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    4c00:	8a 81       	ldd	r24, Y+2	; 0x02
    4c02:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4c06:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    4c08:	8b 81       	ldd	r24, Y+3	; 0x03
    4c0a:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4c0e:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4c10:	80 e0       	ldi	r24, 0x00	; 0
    4c12:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>
    CHB_LEAVE_CRIT();
    4c16:	8f e3       	ldi	r24, 0x3F	; 63
    4c18:	90 e0       	ldi	r25, 0x00	; 0
    4c1a:	20 91 45 40 	lds	r18, 0x4045
    4c1e:	fc 01       	movw	r30, r24
    4c20:	20 83       	st	Z, r18
    4c22:	78 94       	sei
}
    4c24:	23 96       	adiw	r28, 0x03	; 3
    4c26:	cd bf       	out	0x3d, r28	; 61
    4c28:	de bf       	out	0x3e, r29	; 62
    4c2a:	df 91       	pop	r29
    4c2c:	cf 91       	pop	r28
    4c2e:	08 95       	ret

00004c30 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4c30:	cf 93       	push	r28
    4c32:	df 93       	push	r29
    4c34:	00 d0       	rcall	.+0      	; 0x4c36 <chb_reg_write16+0x6>
    4c36:	0f 92       	push	r0
    4c38:	cd b7       	in	r28, 0x3d	; 61
    4c3a:	de b7       	in	r29, 0x3e	; 62
    4c3c:	8a 83       	std	Y+2, r24	; 0x02
    4c3e:	6b 83       	std	Y+3, r22	; 0x03
    4c40:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4c42:	19 82       	std	Y+1, r1	; 0x01
    4c44:	1d c0       	rjmp	.+58     	; 0x4c80 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4c46:	9a 81       	ldd	r25, Y+2	; 0x02
    4c48:	89 81       	ldd	r24, Y+1	; 0x01
    4c4a:	49 2f       	mov	r20, r25
    4c4c:	48 0f       	add	r20, r24
    4c4e:	89 81       	ldd	r24, Y+1	; 0x01
    4c50:	88 2f       	mov	r24, r24
    4c52:	90 e0       	ldi	r25, 0x00	; 0
    4c54:	9c 01       	movw	r18, r24
    4c56:	22 0f       	add	r18, r18
    4c58:	33 1f       	adc	r19, r19
    4c5a:	22 0f       	add	r18, r18
    4c5c:	33 1f       	adc	r19, r19
    4c5e:	22 0f       	add	r18, r18
    4c60:	33 1f       	adc	r19, r19
    4c62:	8b 81       	ldd	r24, Y+3	; 0x03
    4c64:	9c 81       	ldd	r25, Y+4	; 0x04
    4c66:	02 c0       	rjmp	.+4      	; 0x4c6c <chb_reg_write16+0x3c>
    4c68:	96 95       	lsr	r25
    4c6a:	87 95       	ror	r24
    4c6c:	2a 95       	dec	r18
    4c6e:	e2 f7       	brpl	.-8      	; 0x4c68 <chb_reg_write16+0x38>
    4c70:	98 2f       	mov	r25, r24
    4c72:	84 2f       	mov	r24, r20
    4c74:	69 2f       	mov	r22, r25
    4c76:	0e 94 ec 25 	call	0x4bd8	; 0x4bd8 <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4c7a:	89 81       	ldd	r24, Y+1	; 0x01
    4c7c:	8f 5f       	subi	r24, 0xFF	; 255
    4c7e:	89 83       	std	Y+1, r24	; 0x01
    4c80:	89 81       	ldd	r24, Y+1	; 0x01
    4c82:	82 30       	cpi	r24, 0x02	; 2
    4c84:	00 f3       	brcs	.-64     	; 0x4c46 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4c86:	24 96       	adiw	r28, 0x04	; 4
    4c88:	cd bf       	out	0x3d, r28	; 61
    4c8a:	de bf       	out	0x3e, r29	; 62
    4c8c:	df 91       	pop	r29
    4c8e:	cf 91       	pop	r28
    4c90:	08 95       	ret

00004c92 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4c92:	cf 93       	push	r28
    4c94:	df 93       	push	r29
    4c96:	00 d0       	rcall	.+0      	; 0x4c98 <chb_reg_write64+0x6>
    4c98:	0f 92       	push	r0
    4c9a:	cd b7       	in	r28, 0x3d	; 61
    4c9c:	de b7       	in	r29, 0x3e	; 62
    4c9e:	8a 83       	std	Y+2, r24	; 0x02
    4ca0:	6b 83       	std	Y+3, r22	; 0x03
    4ca2:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4ca4:	19 82       	std	Y+1, r1	; 0x01
    4ca6:	14 c0       	rjmp	.+40     	; 0x4cd0 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    4caa:	89 81       	ldd	r24, Y+1	; 0x01
    4cac:	49 2f       	mov	r20, r25
    4cae:	48 0f       	add	r20, r24
    4cb0:	89 81       	ldd	r24, Y+1	; 0x01
    4cb2:	88 2f       	mov	r24, r24
    4cb4:	90 e0       	ldi	r25, 0x00	; 0
    4cb6:	2b 81       	ldd	r18, Y+3	; 0x03
    4cb8:	3c 81       	ldd	r19, Y+4	; 0x04
    4cba:	82 0f       	add	r24, r18
    4cbc:	93 1f       	adc	r25, r19
    4cbe:	fc 01       	movw	r30, r24
    4cc0:	90 81       	ld	r25, Z
    4cc2:	84 2f       	mov	r24, r20
    4cc4:	69 2f       	mov	r22, r25
    4cc6:	0e 94 ec 25 	call	0x4bd8	; 0x4bd8 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4cca:	89 81       	ldd	r24, Y+1	; 0x01
    4ccc:	8f 5f       	subi	r24, 0xFF	; 255
    4cce:	89 83       	std	Y+1, r24	; 0x01
    4cd0:	89 81       	ldd	r24, Y+1	; 0x01
    4cd2:	88 30       	cpi	r24, 0x08	; 8
    4cd4:	48 f3       	brcs	.-46     	; 0x4ca8 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    4cd6:	24 96       	adiw	r28, 0x04	; 4
    4cd8:	cd bf       	out	0x3d, r28	; 61
    4cda:	de bf       	out	0x3e, r29	; 62
    4cdc:	df 91       	pop	r29
    4cde:	cf 91       	pop	r28
    4ce0:	08 95       	ret

00004ce2 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    4ce2:	cf 93       	push	r28
    4ce4:	df 93       	push	r29
    4ce6:	00 d0       	rcall	.+0      	; 0x4ce8 <chb_reg_read_mod_write+0x6>
    4ce8:	0f 92       	push	r0
    4cea:	cd b7       	in	r28, 0x3d	; 61
    4cec:	de b7       	in	r29, 0x3e	; 62
    4cee:	8a 83       	std	Y+2, r24	; 0x02
    4cf0:	6b 83       	std	Y+3, r22	; 0x03
    4cf2:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    4cf4:	8a 81       	ldd	r24, Y+2	; 0x02
    4cf6:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    4cfa:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4cfc:	9b 81       	ldd	r25, Y+3	; 0x03
    4cfe:	8c 81       	ldd	r24, Y+4	; 0x04
    4d00:	89 23       	and	r24, r25
    4d02:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4d04:	8c 81       	ldd	r24, Y+4	; 0x04
    4d06:	98 2f       	mov	r25, r24
    4d08:	90 95       	com	r25
    4d0a:	89 81       	ldd	r24, Y+1	; 0x01
    4d0c:	89 23       	and	r24, r25
    4d0e:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4d10:	99 81       	ldd	r25, Y+1	; 0x01
    4d12:	8b 81       	ldd	r24, Y+3	; 0x03
    4d14:	89 2b       	or	r24, r25
    4d16:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4d18:	8a 81       	ldd	r24, Y+2	; 0x02
    4d1a:	69 81       	ldd	r22, Y+1	; 0x01
    4d1c:	0e 94 ec 25 	call	0x4bd8	; 0x4bd8 <chb_reg_write>
}
    4d20:	24 96       	adiw	r28, 0x04	; 4
    4d22:	cd bf       	out	0x3d, r28	; 61
    4d24:	de bf       	out	0x3e, r29	; 62
    4d26:	df 91       	pop	r29
    4d28:	cf 91       	pop	r28
    4d2a:	08 95       	ret

00004d2c <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4d2c:	cf 93       	push	r28
    4d2e:	df 93       	push	r29
    4d30:	cd b7       	in	r28, 0x3d	; 61
    4d32:	de b7       	in	r29, 0x3e	; 62
    4d34:	28 97       	sbiw	r28, 0x08	; 8
    4d36:	cd bf       	out	0x3d, r28	; 61
    4d38:	de bf       	out	0x3e, r29	; 62
    4d3a:	8b 83       	std	Y+3, r24	; 0x03
    4d3c:	9c 83       	std	Y+4, r25	; 0x04
    4d3e:	6d 83       	std	Y+5, r22	; 0x05
    4d40:	4e 83       	std	Y+6, r20	; 0x06
    4d42:	5f 83       	std	Y+7, r21	; 0x07
    4d44:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4d46:	8d 81       	ldd	r24, Y+5	; 0x05
    4d48:	28 2f       	mov	r18, r24
    4d4a:	30 e0       	ldi	r19, 0x00	; 0
    4d4c:	88 85       	ldd	r24, Y+8	; 0x08
    4d4e:	88 2f       	mov	r24, r24
    4d50:	90 e0       	ldi	r25, 0x00	; 0
    4d52:	82 0f       	add	r24, r18
    4d54:	93 1f       	adc	r25, r19
    4d56:	80 38       	cpi	r24, 0x80	; 128
    4d58:	91 05       	cpc	r25, r1
    4d5a:	0c f0       	brlt	.+2      	; 0x4d5e <chb_frame_write+0x32>
    4d5c:	45 c0       	rjmp	.+138    	; 0x4de8 <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4d5e:	8f e3       	ldi	r24, 0x3F	; 63
    4d60:	90 e0       	ldi	r25, 0x00	; 0
    4d62:	fc 01       	movw	r30, r24
    4d64:	80 81       	ld	r24, Z
    4d66:	80 93 45 40 	sts	0x4045, r24
    4d6a:	f8 94       	cli
    RadioCS(TRUE); 
    4d6c:	81 e0       	ldi	r24, 0x01	; 1
    4d6e:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    4d72:	80 e6       	ldi	r24, 0x60	; 96
    4d74:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4d78:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4d7a:	19 82       	std	Y+1, r1	; 0x01
    4d7c:	10 c0       	rjmp	.+32     	; 0x4d9e <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    4d80:	9c 81       	ldd	r25, Y+4	; 0x04
    4d82:	fc 01       	movw	r30, r24
    4d84:	20 81       	ld	r18, Z
    4d86:	8b 81       	ldd	r24, Y+3	; 0x03
    4d88:	9c 81       	ldd	r25, Y+4	; 0x04
    4d8a:	01 96       	adiw	r24, 0x01	; 1
    4d8c:	8b 83       	std	Y+3, r24	; 0x03
    4d8e:	9c 83       	std	Y+4, r25	; 0x04
    4d90:	82 2f       	mov	r24, r18
    4d92:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4d96:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4d98:	89 81       	ldd	r24, Y+1	; 0x01
    4d9a:	8f 5f       	subi	r24, 0xFF	; 255
    4d9c:	89 83       	std	Y+1, r24	; 0x01
    4d9e:	99 81       	ldd	r25, Y+1	; 0x01
    4da0:	8d 81       	ldd	r24, Y+5	; 0x05
    4da2:	98 17       	cp	r25, r24
    4da4:	60 f3       	brcs	.-40     	; 0x4d7e <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4da6:	19 82       	std	Y+1, r1	; 0x01
    4da8:	10 c0       	rjmp	.+32     	; 0x4dca <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4daa:	8e 81       	ldd	r24, Y+6	; 0x06
    4dac:	9f 81       	ldd	r25, Y+7	; 0x07
    4dae:	fc 01       	movw	r30, r24
    4db0:	20 81       	ld	r18, Z
    4db2:	8e 81       	ldd	r24, Y+6	; 0x06
    4db4:	9f 81       	ldd	r25, Y+7	; 0x07
    4db6:	01 96       	adiw	r24, 0x01	; 1
    4db8:	8e 83       	std	Y+6, r24	; 0x06
    4dba:	9f 83       	std	Y+7, r25	; 0x07
    4dbc:	82 2f       	mov	r24, r18
    4dbe:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4dc2:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4dc4:	89 81       	ldd	r24, Y+1	; 0x01
    4dc6:	8f 5f       	subi	r24, 0xFF	; 255
    4dc8:	89 83       	std	Y+1, r24	; 0x01
    4dca:	99 81       	ldd	r25, Y+1	; 0x01
    4dcc:	88 85       	ldd	r24, Y+8	; 0x08
    4dce:	98 17       	cp	r25, r24
    4dd0:	60 f3       	brcs	.-40     	; 0x4daa <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    4dd2:	80 e0       	ldi	r24, 0x00	; 0
    4dd4:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>
    CHB_LEAVE_CRIT();
    4dd8:	8f e3       	ldi	r24, 0x3F	; 63
    4dda:	90 e0       	ldi	r25, 0x00	; 0
    4ddc:	20 91 45 40 	lds	r18, 0x4045
    4de0:	fc 01       	movw	r30, r24
    4de2:	20 83       	st	Z, r18
    4de4:	78 94       	sei
    4de6:	01 c0       	rjmp	.+2      	; 0x4dea <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4de8:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4dea:	28 96       	adiw	r28, 0x08	; 8
    4dec:	cd bf       	out	0x3d, r28	; 61
    4dee:	de bf       	out	0x3e, r29	; 62
    4df0:	df 91       	pop	r29
    4df2:	cf 91       	pop	r28
    4df4:	08 95       	ret

00004df6 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    4df6:	0f 93       	push	r16
    4df8:	1f 93       	push	r17
    4dfa:	cf 93       	push	r28
    4dfc:	df 93       	push	r29
    4dfe:	cd b7       	in	r28, 0x3d	; 61
    4e00:	de b7       	in	r29, 0x3e	; 62
    4e02:	e7 97       	sbiw	r28, 0x37	; 55
    4e04:	cd bf       	out	0x3d, r28	; 61
    4e06:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4e08:	8f e3       	ldi	r24, 0x3F	; 63
    4e0a:	90 e0       	ldi	r25, 0x00	; 0
    4e0c:	fc 01       	movw	r30, r24
    4e0e:	80 81       	ld	r24, Z
    4e10:	80 93 45 40 	sts	0x4045, r24
    4e14:	f8 94       	cli
    RadioCS(TRUE);
    4e16:	81 e0       	ldi	r24, 0x01	; 1
    4e18:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4e1c:	80 e2       	ldi	r24, 0x20	; 32
    4e1e:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    len = SPID_write(0);
    4e22:	80 e0       	ldi	r24, 0x00	; 0
    4e24:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4e28:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e2c:	83 30       	cpi	r24, 0x03	; 3
    4e2e:	08 f4       	brcc	.+2      	; 0x4e32 <chb_frame_read+0x3c>
    4e30:	66 c0       	rjmp	.+204    	; 0x4efe <chb_frame_read+0x108>
    4e32:	8a 81       	ldd	r24, Y+2	; 0x02
    4e34:	88 23       	and	r24, r24
    4e36:	0c f4       	brge	.+2      	; 0x4e3a <chb_frame_read+0x44>
    4e38:	62 c0       	rjmp	.+196    	; 0x4efe <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4e3a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e3c:	08 2f       	mov	r16, r24
    4e3e:	10 e0       	ldi	r17, 0x00	; 0
    4e40:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_buf_get_len>
    4e44:	88 2f       	mov	r24, r24
    4e46:	90 e0       	ldi	r25, 0x00	; 0
    4e48:	20 e8       	ldi	r18, 0x80	; 128
    4e4a:	30 e0       	ldi	r19, 0x00	; 0
    4e4c:	a9 01       	movw	r20, r18
    4e4e:	48 1b       	sub	r20, r24
    4e50:	59 0b       	sbc	r21, r25
    4e52:	ca 01       	movw	r24, r20
    4e54:	08 17       	cp	r16, r24
    4e56:	19 07       	cpc	r17, r25
    4e58:	f4 f4       	brge	.+60     	; 0x4e96 <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4e5a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e5c:	0e 94 37 23 	call	0x466e	; 0x466e <chb_buf_write>
            
            for (i=0; i<len; i++)
    4e60:	19 82       	std	Y+1, r1	; 0x01
    4e62:	0a c0       	rjmp	.+20     	; 0x4e78 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4e64:	80 e0       	ldi	r24, 0x00	; 0
    4e66:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4e6a:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4e6e:	0e 94 37 23 	call	0x466e	; 0x466e <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4e72:	89 81       	ldd	r24, Y+1	; 0x01
    4e74:	8f 5f       	subi	r24, 0xFF	; 255
    4e76:	89 83       	std	Y+1, r24	; 0x01
    4e78:	99 81       	ldd	r25, Y+1	; 0x01
    4e7a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e7c:	98 17       	cp	r25, r24
    4e7e:	90 f3       	brcs	.-28     	; 0x4e64 <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4e80:	80 e8       	ldi	r24, 0x80	; 128
    4e82:	96 e0       	ldi	r25, 0x06	; 6
    4e84:	24 e0       	ldi	r18, 0x04	; 4
    4e86:	fc 01       	movw	r30, r24
    4e88:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4e8a:	80 e8       	ldi	r24, 0x80	; 128
    4e8c:	96 e0       	ldi	r25, 0x06	; 6
    4e8e:	24 e0       	ldi	r18, 0x04	; 4
    4e90:	fc 01       	movw	r30, r24
    4e92:	26 83       	std	Z+6, r18	; 0x06
    4e94:	34 c0       	rjmp	.+104    	; 0x4efe <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4e96:	0e 94 85 20 	call	0x410a	; 0x410a <chb_get_pcb>
    4e9a:	8c 83       	std	Y+4, r24	; 0x04
    4e9c:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4e9e:	19 82       	std	Y+1, r1	; 0x01
    4ea0:	07 c0       	rjmp	.+14     	; 0x4eb0 <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    4ea2:	80 e0       	ldi	r24, 0x00	; 0
    4ea4:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    4ea8:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4eaa:	89 81       	ldd	r24, Y+1	; 0x01
    4eac:	8f 5f       	subi	r24, 0xFF	; 255
    4eae:	89 83       	std	Y+1, r24	; 0x01
    4eb0:	99 81       	ldd	r25, Y+1	; 0x01
    4eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    4eb4:	98 17       	cp	r25, r24
    4eb6:	a8 f3       	brcs	.-22     	; 0x4ea2 <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4eb8:	8c 81       	ldd	r24, Y+4	; 0x04
    4eba:	9d 81       	ldd	r25, Y+5	; 0x05
    4ebc:	fc 01       	movw	r30, r24
    4ebe:	85 85       	ldd	r24, Z+13	; 0x0d
    4ec0:	96 85       	ldd	r25, Z+14	; 0x0e
    4ec2:	9c 01       	movw	r18, r24
    4ec4:	2f 5f       	subi	r18, 0xFF	; 255
    4ec6:	3f 4f       	sbci	r19, 0xFF	; 255
    4ec8:	8c 81       	ldd	r24, Y+4	; 0x04
    4eca:	9d 81       	ldd	r25, Y+5	; 0x05
    4ecc:	fc 01       	movw	r30, r24
    4ece:	25 87       	std	Z+13, r18	; 0x0d
    4ed0:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4ed2:	ce 01       	movw	r24, r28
    4ed4:	06 96       	adiw	r24, 0x06	; 6
    4ed6:	28 ee       	ldi	r18, 0xE8	; 232
    4ed8:	31 e0       	ldi	r19, 0x01	; 1
    4eda:	b9 01       	movw	r22, r18
    4edc:	0e 94 7d 5f 	call	0xbefa	; 0xbefa <strcpy_P>
            printf(buf);
    4ee0:	0f 92       	push	r0
    4ee2:	0f 92       	push	r0
    4ee4:	8d b7       	in	r24, 0x3d	; 61
    4ee6:	9e b7       	in	r25, 0x3e	; 62
    4ee8:	01 96       	adiw	r24, 0x01	; 1
    4eea:	9e 01       	movw	r18, r28
    4eec:	2a 5f       	subi	r18, 0xFA	; 250
    4eee:	3f 4f       	sbci	r19, 0xFF	; 255
    4ef0:	fc 01       	movw	r30, r24
    4ef2:	20 83       	st	Z, r18
    4ef4:	31 83       	std	Z+1, r19	; 0x01
    4ef6:	0e 94 e0 5f 	call	0xbfc0	; 0xbfc0 <printf>
    4efa:	0f 90       	pop	r0
    4efc:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4efe:	80 e0       	ldi	r24, 0x00	; 0
    4f00:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>
    CHB_LEAVE_CRIT();
    4f04:	8f e3       	ldi	r24, 0x3F	; 63
    4f06:	90 e0       	ldi	r25, 0x00	; 0
    4f08:	20 91 45 40 	lds	r18, 0x4045
    4f0c:	fc 01       	movw	r30, r24
    4f0e:	20 83       	st	Z, r18
    4f10:	78 94       	sei
}
    4f12:	e7 96       	adiw	r28, 0x37	; 55
    4f14:	cd bf       	out	0x3d, r28	; 61
    4f16:	de bf       	out	0x3e, r29	; 62
    4f18:	df 91       	pop	r29
    4f1a:	cf 91       	pop	r28
    4f1c:	1f 91       	pop	r17
    4f1e:	0f 91       	pop	r16
    4f20:	08 95       	ret

00004f22 <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4f22:	cf 93       	push	r28
    4f24:	df 93       	push	r29
    4f26:	0f 92       	push	r0
    4f28:	cd b7       	in	r28, 0x3d	; 61
    4f2a:	de b7       	in	r29, 0x3e	; 62
    4f2c:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4f2e:	89 81       	ldd	r24, Y+1	; 0x01
    4f30:	88 2f       	mov	r24, r24
    4f32:	90 e0       	ldi	r25, 0x00	; 0
    4f34:	81 30       	cpi	r24, 0x01	; 1
    4f36:	91 05       	cpc	r25, r1
    4f38:	c1 f0       	breq	.+48     	; 0x4f6a <chb_set_mode+0x48>
    4f3a:	82 30       	cpi	r24, 0x02	; 2
    4f3c:	91 05       	cpc	r25, r1
    4f3e:	1c f4       	brge	.+6      	; 0x4f46 <chb_set_mode+0x24>
    4f40:	00 97       	sbiw	r24, 0x00	; 0
    4f42:	41 f0       	breq	.+16     	; 0x4f54 <chb_set_mode+0x32>
    4f44:	33 c0       	rjmp	.+102    	; 0x4fac <chb_set_mode+0x8a>
    4f46:	82 30       	cpi	r24, 0x02	; 2
    4f48:	91 05       	cpc	r25, r1
    4f4a:	d1 f0       	breq	.+52     	; 0x4f80 <chb_set_mode+0x5e>
    4f4c:	83 30       	cpi	r24, 0x03	; 3
    4f4e:	91 05       	cpc	r25, r1
    4f50:	11 f1       	breq	.+68     	; 0x4f96 <chb_set_mode+0x74>
    4f52:	2c c0       	rjmp	.+88     	; 0x4fac <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4f54:	8c e0       	ldi	r24, 0x0C	; 12
    4f56:	68 e0       	ldi	r22, 0x08	; 8
    4f58:	4f e3       	ldi	r20, 0x3F	; 63
    4f5a:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f5e:	86 e1       	ldi	r24, 0x16	; 22
    4f60:	62 e0       	ldi	r22, 0x02	; 2
    4f62:	43 e0       	ldi	r20, 0x03	; 3
    4f64:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        break;
    4f68:	21 c0       	rjmp	.+66     	; 0x4fac <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4f6a:	8c e0       	ldi	r24, 0x0C	; 12
    4f6c:	6c e0       	ldi	r22, 0x0C	; 12
    4f6e:	4f e3       	ldi	r20, 0x3F	; 63
    4f70:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f74:	86 e1       	ldi	r24, 0x16	; 22
    4f76:	62 e0       	ldi	r22, 0x02	; 2
    4f78:	43 e0       	ldi	r20, 0x03	; 3
    4f7a:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        break;
    4f7e:	16 c0       	rjmp	.+44     	; 0x4fac <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4f80:	8c e0       	ldi	r24, 0x0C	; 12
    4f82:	6c e1       	ldi	r22, 0x1C	; 28
    4f84:	4f e3       	ldi	r20, 0x3F	; 63
    4f86:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f8a:	86 e1       	ldi	r24, 0x16	; 22
    4f8c:	62 e0       	ldi	r22, 0x02	; 2
    4f8e:	43 e0       	ldi	r20, 0x03	; 3
    4f90:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        break;
    4f94:	0b c0       	rjmp	.+22     	; 0x4fac <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4f96:	8c e0       	ldi	r24, 0x0C	; 12
    4f98:	60 e0       	ldi	r22, 0x00	; 0
    4f9a:	4f e3       	ldi	r20, 0x3F	; 63
    4f9c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4fa0:	86 e1       	ldi	r24, 0x16	; 22
    4fa2:	63 e0       	ldi	r22, 0x03	; 3
    4fa4:	43 e0       	ldi	r20, 0x03	; 3
    4fa6:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
        break;
    4faa:	00 00       	nop
    }
}
    4fac:	0f 90       	pop	r0
    4fae:	df 91       	pop	r29
    4fb0:	cf 91       	pop	r28
    4fb2:	08 95       	ret

00004fb4 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4fb4:	0f 93       	push	r16
    4fb6:	1f 93       	push	r17
    4fb8:	cf 93       	push	r28
    4fba:	df 93       	push	r29
    4fbc:	cd b7       	in	r28, 0x3d	; 61
    4fbe:	de b7       	in	r29, 0x3e	; 62
    4fc0:	6a 97       	sbiw	r28, 0x1a	; 26
    4fc2:	cd bf       	out	0x3d, r28	; 61
    4fc4:	de bf       	out	0x3e, r29	; 62
    4fc6:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4fc8:	88 e0       	ldi	r24, 0x08	; 8
    4fca:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4fcc:	4f e1       	ldi	r20, 0x1F	; 31
    4fce:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4fd2:	0e 94 88 23 	call	0x4710	; 0x4710 <chb_get_state>
    4fd6:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4fd8:	89 81       	ldd	r24, Y+1	; 0x01
    4fda:	86 30       	cpi	r24, 0x06	; 6
    4fdc:	21 f0       	breq	.+8      	; 0x4fe6 <chb_set_channel+0x32>
    4fde:	89 81       	ldd	r24, Y+1	; 0x01
    4fe0:	89 30       	cpi	r24, 0x09	; 9
    4fe2:	09 f0       	breq	.+2      	; 0x4fe6 <chb_set_channel+0x32>
    4fe4:	d5 c0       	rjmp	.+426    	; 0x5190 <chb_set_channel+0x1dc>
    4fe6:	80 e0       	ldi	r24, 0x00	; 0
    4fe8:	90 e0       	ldi	r25, 0x00	; 0
    4fea:	ac ed       	ldi	r26, 0xDC	; 220
    4fec:	b2 e4       	ldi	r27, 0x42	; 66
    4fee:	8a 83       	std	Y+2, r24	; 0x02
    4ff0:	9b 83       	std	Y+3, r25	; 0x03
    4ff2:	ac 83       	std	Y+4, r26	; 0x04
    4ff4:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4ff6:	6a 81       	ldd	r22, Y+2	; 0x02
    4ff8:	7b 81       	ldd	r23, Y+3	; 0x03
    4ffa:	8c 81       	ldd	r24, Y+4	; 0x04
    4ffc:	9d 81       	ldd	r25, Y+5	; 0x05
    4ffe:	2b ea       	ldi	r18, 0xAB	; 171
    5000:	3a ea       	ldi	r19, 0xAA	; 170
    5002:	4a ea       	ldi	r20, 0xAA	; 170
    5004:	5e e3       	ldi	r21, 0x3E	; 62
    5006:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    500a:	dc 01       	movw	r26, r24
    500c:	cb 01       	movw	r24, r22
    500e:	8e 83       	std	Y+6, r24	; 0x06
    5010:	9f 83       	std	Y+7, r25	; 0x07
    5012:	a8 87       	std	Y+8, r26	; 0x08
    5014:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    5016:	11 e0       	ldi	r17, 0x01	; 1
    5018:	6e 81       	ldd	r22, Y+6	; 0x06
    501a:	7f 81       	ldd	r23, Y+7	; 0x07
    501c:	88 85       	ldd	r24, Y+8	; 0x08
    501e:	99 85       	ldd	r25, Y+9	; 0x09
    5020:	20 e0       	ldi	r18, 0x00	; 0
    5022:	30 e0       	ldi	r19, 0x00	; 0
    5024:	40 e8       	ldi	r20, 0x80	; 128
    5026:	5f e3       	ldi	r21, 0x3F	; 63
    5028:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    502c:	88 23       	and	r24, r24
    502e:	0c f0       	brlt	.+2      	; 0x5032 <chb_set_channel+0x7e>
    5030:	10 e0       	ldi	r17, 0x00	; 0
    5032:	11 23       	and	r17, r17
    5034:	19 f0       	breq	.+6      	; 0x503c <chb_set_channel+0x88>
		__ticks = 1;
    5036:	81 e0       	ldi	r24, 0x01	; 1
    5038:	8a 87       	std	Y+10, r24	; 0x0a
    503a:	a3 c0       	rjmp	.+326    	; 0x5182 <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    503c:	11 e0       	ldi	r17, 0x01	; 1
    503e:	6e 81       	ldd	r22, Y+6	; 0x06
    5040:	7f 81       	ldd	r23, Y+7	; 0x07
    5042:	88 85       	ldd	r24, Y+8	; 0x08
    5044:	99 85       	ldd	r25, Y+9	; 0x09
    5046:	20 e0       	ldi	r18, 0x00	; 0
    5048:	30 e0       	ldi	r19, 0x00	; 0
    504a:	4f e7       	ldi	r20, 0x7F	; 127
    504c:	53 e4       	ldi	r21, 0x43	; 67
    504e:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    5052:	18 16       	cp	r1, r24
    5054:	0c f0       	brlt	.+2      	; 0x5058 <chb_set_channel+0xa4>
    5056:	10 e0       	ldi	r17, 0x00	; 0
    5058:	11 23       	and	r17, r17
    505a:	09 f4       	brne	.+2      	; 0x505e <chb_set_channel+0xaa>
    505c:	89 c0       	rjmp	.+274    	; 0x5170 <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    505e:	6a 81       	ldd	r22, Y+2	; 0x02
    5060:	7b 81       	ldd	r23, Y+3	; 0x03
    5062:	8c 81       	ldd	r24, Y+4	; 0x04
    5064:	9d 81       	ldd	r25, Y+5	; 0x05
    5066:	20 e0       	ldi	r18, 0x00	; 0
    5068:	30 e0       	ldi	r19, 0x00	; 0
    506a:	4a e7       	ldi	r20, 0x7A	; 122
    506c:	54 e4       	ldi	r21, 0x44	; 68
    506e:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    5072:	dc 01       	movw	r26, r24
    5074:	cb 01       	movw	r24, r22
    5076:	8b 87       	std	Y+11, r24	; 0x0b
    5078:	9c 87       	std	Y+12, r25	; 0x0c
    507a:	ad 87       	std	Y+13, r26	; 0x0d
    507c:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    507e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5080:	7c 85       	ldd	r23, Y+12	; 0x0c
    5082:	8d 85       	ldd	r24, Y+13	; 0x0d
    5084:	9e 85       	ldd	r25, Y+14	; 0x0e
    5086:	20 e0       	ldi	r18, 0x00	; 0
    5088:	30 e0       	ldi	r19, 0x00	; 0
    508a:	4a e7       	ldi	r20, 0x7A	; 122
    508c:	53 e4       	ldi	r21, 0x43	; 67
    508e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5092:	dc 01       	movw	r26, r24
    5094:	cb 01       	movw	r24, r22
    5096:	8f 87       	std	Y+15, r24	; 0x0f
    5098:	98 8b       	std	Y+16, r25	; 0x10
    509a:	a9 8b       	std	Y+17, r26	; 0x11
    509c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    509e:	11 e0       	ldi	r17, 0x01	; 1
    50a0:	6f 85       	ldd	r22, Y+15	; 0x0f
    50a2:	78 89       	ldd	r23, Y+16	; 0x10
    50a4:	89 89       	ldd	r24, Y+17	; 0x11
    50a6:	9a 89       	ldd	r25, Y+18	; 0x12
    50a8:	20 e0       	ldi	r18, 0x00	; 0
    50aa:	30 e0       	ldi	r19, 0x00	; 0
    50ac:	40 e8       	ldi	r20, 0x80	; 128
    50ae:	5f e3       	ldi	r21, 0x3F	; 63
    50b0:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    50b4:	88 23       	and	r24, r24
    50b6:	0c f0       	brlt	.+2      	; 0x50ba <chb_set_channel+0x106>
    50b8:	10 e0       	ldi	r17, 0x00	; 0
    50ba:	11 23       	and	r17, r17
    50bc:	29 f0       	breq	.+10     	; 0x50c8 <chb_set_channel+0x114>
		__ticks = 1;
    50be:	81 e0       	ldi	r24, 0x01	; 1
    50c0:	90 e0       	ldi	r25, 0x00	; 0
    50c2:	8b 8b       	std	Y+19, r24	; 0x13
    50c4:	9c 8b       	std	Y+20, r25	; 0x14
    50c6:	46 c0       	rjmp	.+140    	; 0x5154 <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    50c8:	11 e0       	ldi	r17, 0x01	; 1
    50ca:	6f 85       	ldd	r22, Y+15	; 0x0f
    50cc:	78 89       	ldd	r23, Y+16	; 0x10
    50ce:	89 89       	ldd	r24, Y+17	; 0x11
    50d0:	9a 89       	ldd	r25, Y+18	; 0x12
    50d2:	20 e0       	ldi	r18, 0x00	; 0
    50d4:	3f ef       	ldi	r19, 0xFF	; 255
    50d6:	4f e7       	ldi	r20, 0x7F	; 127
    50d8:	57 e4       	ldi	r21, 0x47	; 71
    50da:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    50de:	18 16       	cp	r1, r24
    50e0:	0c f0       	brlt	.+2      	; 0x50e4 <chb_set_channel+0x130>
    50e2:	10 e0       	ldi	r17, 0x00	; 0
    50e4:	11 23       	and	r17, r17
    50e6:	61 f1       	breq	.+88     	; 0x5140 <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    50e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    50ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    50ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    50ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    50f0:	20 e0       	ldi	r18, 0x00	; 0
    50f2:	30 e0       	ldi	r19, 0x00	; 0
    50f4:	40 e2       	ldi	r20, 0x20	; 32
    50f6:	51 e4       	ldi	r21, 0x41	; 65
    50f8:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    50fc:	dc 01       	movw	r26, r24
    50fe:	cb 01       	movw	r24, r22
    5100:	bc 01       	movw	r22, r24
    5102:	cd 01       	movw	r24, r26
    5104:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5108:	dc 01       	movw	r26, r24
    510a:	cb 01       	movw	r24, r22
    510c:	8b 8b       	std	Y+19, r24	; 0x13
    510e:	9c 8b       	std	Y+20, r25	; 0x14
    5110:	12 c0       	rjmp	.+36     	; 0x5136 <chb_set_channel+0x182>
    5112:	89 e1       	ldi	r24, 0x19	; 25
    5114:	90 e0       	ldi	r25, 0x00	; 0
    5116:	8d 8b       	std	Y+21, r24	; 0x15
    5118:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    511a:	8d 89       	ldd	r24, Y+21	; 0x15
    511c:	9e 89       	ldd	r25, Y+22	; 0x16
    511e:	8c 01       	movw	r16, r24
    5120:	c8 01       	movw	r24, r16
    5122:	01 97       	sbiw	r24, 0x01	; 1
    5124:	f1 f7       	brne	.-4      	; 0x5122 <chb_set_channel+0x16e>
    5126:	8c 01       	movw	r16, r24
    5128:	0d 8b       	std	Y+21, r16	; 0x15
    512a:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    512c:	8b 89       	ldd	r24, Y+19	; 0x13
    512e:	9c 89       	ldd	r25, Y+20	; 0x14
    5130:	01 97       	sbiw	r24, 0x01	; 1
    5132:	8b 8b       	std	Y+19, r24	; 0x13
    5134:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5136:	8b 89       	ldd	r24, Y+19	; 0x13
    5138:	9c 89       	ldd	r25, Y+20	; 0x14
    513a:	00 97       	sbiw	r24, 0x00	; 0
    513c:	51 f7       	brne	.-44     	; 0x5112 <chb_set_channel+0x15e>
    513e:	28 c0       	rjmp	.+80     	; 0x5190 <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5140:	6f 85       	ldd	r22, Y+15	; 0x0f
    5142:	78 89       	ldd	r23, Y+16	; 0x10
    5144:	89 89       	ldd	r24, Y+17	; 0x11
    5146:	9a 89       	ldd	r25, Y+18	; 0x12
    5148:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    514c:	dc 01       	movw	r26, r24
    514e:	cb 01       	movw	r24, r22
    5150:	8b 8b       	std	Y+19, r24	; 0x13
    5152:	9c 8b       	std	Y+20, r25	; 0x14
    5154:	8b 89       	ldd	r24, Y+19	; 0x13
    5156:	9c 89       	ldd	r25, Y+20	; 0x14
    5158:	8f 8b       	std	Y+23, r24	; 0x17
    515a:	98 8f       	std	Y+24, r25	; 0x18
    515c:	8f 89       	ldd	r24, Y+23	; 0x17
    515e:	98 8d       	ldd	r25, Y+24	; 0x18
    5160:	8c 01       	movw	r16, r24
    5162:	c8 01       	movw	r24, r16
    5164:	01 97       	sbiw	r24, 0x01	; 1
    5166:	f1 f7       	brne	.-4      	; 0x5164 <chb_set_channel+0x1b0>
    5168:	8c 01       	movw	r16, r24
    516a:	0f 8b       	std	Y+23, r16	; 0x17
    516c:	18 8f       	std	Y+24, r17	; 0x18
    516e:	10 c0       	rjmp	.+32     	; 0x5190 <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5170:	6e 81       	ldd	r22, Y+6	; 0x06
    5172:	7f 81       	ldd	r23, Y+7	; 0x07
    5174:	88 85       	ldd	r24, Y+8	; 0x08
    5176:	99 85       	ldd	r25, Y+9	; 0x09
    5178:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    517c:	dc 01       	movw	r26, r24
    517e:	cb 01       	movw	r24, r22
    5180:	8a 87       	std	Y+10, r24	; 0x0a
    5182:	8a 85       	ldd	r24, Y+10	; 0x0a
    5184:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5186:	89 8d       	ldd	r24, Y+25	; 0x19
    5188:	18 2f       	mov	r17, r24
    518a:	1a 95       	dec	r17
    518c:	f1 f7       	brne	.-4      	; 0x518a <chb_set_channel+0x1d6>
    518e:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    5190:	88 e0       	ldi	r24, 0x08	; 8
    5192:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    5196:	88 2f       	mov	r24, r24
    5198:	90 e0       	ldi	r25, 0x00	; 0
    519a:	9c 01       	movw	r18, r24
    519c:	2f 71       	andi	r18, 0x1F	; 31
    519e:	30 70       	andi	r19, 0x00	; 0
    51a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    51a2:	88 2f       	mov	r24, r24
    51a4:	90 e0       	ldi	r25, 0x00	; 0
    51a6:	28 17       	cp	r18, r24
    51a8:	39 07       	cpc	r19, r25
    51aa:	11 f4       	brne	.+4      	; 0x51b0 <chb_set_channel+0x1fc>
    51ac:	80 e4       	ldi	r24, 0x40	; 64
    51ae:	01 c0       	rjmp	.+2      	; 0x51b2 <chb_set_channel+0x1fe>
    51b0:	83 e4       	ldi	r24, 0x43	; 67
}
    51b2:	6a 96       	adiw	r28, 0x1a	; 26
    51b4:	cd bf       	out	0x3d, r28	; 61
    51b6:	de bf       	out	0x3e, r29	; 62
    51b8:	df 91       	pop	r29
    51ba:	cf 91       	pop	r28
    51bc:	1f 91       	pop	r17
    51be:	0f 91       	pop	r16
    51c0:	08 95       	ret

000051c2 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    51c2:	cf 93       	push	r28
    51c4:	df 93       	push	r29
    51c6:	0f 92       	push	r0
    51c8:	cd b7       	in	r28, 0x3d	; 61
    51ca:	de b7       	in	r29, 0x3e	; 62
    51cc:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    51ce:	85 e0       	ldi	r24, 0x05	; 5
    51d0:	69 81       	ldd	r22, Y+1	; 0x01
    51d2:	0e 94 ec 25 	call	0x4bd8	; 0x4bd8 <chb_reg_write>
}
    51d6:	0f 90       	pop	r0
    51d8:	df 91       	pop	r29
    51da:	cf 91       	pop	r28
    51dc:	08 95       	ret

000051de <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    51de:	0f 93       	push	r16
    51e0:	1f 93       	push	r17
    51e2:	cf 93       	push	r28
    51e4:	df 93       	push	r29
    51e6:	cd b7       	in	r28, 0x3d	; 61
    51e8:	de b7       	in	r29, 0x3e	; 62
    51ea:	c2 56       	subi	r28, 0x62	; 98
    51ec:	d0 40       	sbci	r29, 0x00	; 0
    51ee:	cd bf       	out	0x3d, r28	; 61
    51f0:	de bf       	out	0x3e, r29	; 62
    51f2:	9e 01       	movw	r18, r28
    51f4:	2e 59       	subi	r18, 0x9E	; 158
    51f6:	3f 4f       	sbci	r19, 0xFF	; 255
    51f8:	f9 01       	movw	r30, r18
    51fa:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    51fc:	84 e6       	ldi	r24, 0x64	; 100
    51fe:	96 e0       	ldi	r25, 0x06	; 6
    5200:	fc 01       	movw	r30, r24
    5202:	80 81       	ld	r24, Z
    5204:	88 2f       	mov	r24, r24
    5206:	90 e0       	ldi	r25, 0x00	; 0
    5208:	82 70       	andi	r24, 0x02	; 2
    520a:	90 70       	andi	r25, 0x00	; 0
    520c:	00 97       	sbiw	r24, 0x00	; 0
    520e:	11 f0       	breq	.+4      	; 0x5214 <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    5210:	84 e4       	ldi	r24, 0x44	; 68
    5212:	91 c4       	rjmp	.+2338   	; 0x5b36 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    5214:	0e 94 88 23 	call	0x4710	; 0x4710 <chb_get_state>
    5218:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    521a:	89 81       	ldd	r24, Y+1	; 0x01
    521c:	82 31       	cpi	r24, 0x12	; 18
    521e:	49 f0       	breq	.+18     	; 0x5232 <chb_set_state+0x54>
    5220:	89 81       	ldd	r24, Y+1	; 0x01
    5222:	81 31       	cpi	r24, 0x11	; 17
    5224:	31 f0       	breq	.+12     	; 0x5232 <chb_set_state+0x54>
    5226:	89 81       	ldd	r24, Y+1	; 0x01
    5228:	81 30       	cpi	r24, 0x01	; 1
    522a:	19 f0       	breq	.+6      	; 0x5232 <chb_set_state+0x54>
    522c:	89 81       	ldd	r24, Y+1	; 0x01
    522e:	82 30       	cpi	r24, 0x02	; 2
    5230:	39 f4       	brne	.+14     	; 0x5240 <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    5232:	00 00       	nop
    5234:	0e 94 88 23 	call	0x4710	; 0x4710 <chb_get_state>
    5238:	98 2f       	mov	r25, r24
    523a:	89 81       	ldd	r24, Y+1	; 0x01
    523c:	98 17       	cp	r25, r24
    523e:	d1 f3       	breq	.-12     	; 0x5234 <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    5240:	ce 01       	movw	r24, r28
    5242:	8e 59       	subi	r24, 0x9E	; 158
    5244:	9f 4f       	sbci	r25, 0xFF	; 255
    5246:	fc 01       	movw	r30, r24
    5248:	80 81       	ld	r24, Z
    524a:	88 2f       	mov	r24, r24
    524c:	90 e0       	ldi	r25, 0x00	; 0
    524e:	86 31       	cpi	r24, 0x16	; 22
    5250:	91 05       	cpc	r25, r1
    5252:	09 f4       	brne	.+2      	; 0x5256 <chb_set_state+0x78>
    5254:	cd c1       	rjmp	.+922    	; 0x55f0 <chb_set_state+0x412>
    5256:	89 31       	cpi	r24, 0x19	; 25
    5258:	91 05       	cpc	r25, r1
    525a:	09 f4       	brne	.+2      	; 0x525e <chb_set_state+0x80>
    525c:	e9 c0       	rjmp	.+466    	; 0x5430 <chb_set_state+0x252>
    525e:	88 30       	cpi	r24, 0x08	; 8
    5260:	91 05       	cpc	r25, r1
    5262:	09 f0       	breq	.+2      	; 0x5266 <chb_set_state+0x88>
    5264:	f7 c2       	rjmp	.+1518   	; 0x5854 <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    5266:	84 e6       	ldi	r24, 0x64	; 100
    5268:	96 e0       	ldi	r25, 0x06	; 6
    526a:	24 e6       	ldi	r18, 0x64	; 100
    526c:	36 e0       	ldi	r19, 0x06	; 6
    526e:	f9 01       	movw	r30, r18
    5270:	20 81       	ld	r18, Z
    5272:	2d 7f       	andi	r18, 0xFD	; 253
    5274:	fc 01       	movw	r30, r24
    5276:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    5278:	82 e0       	ldi	r24, 0x02	; 2
    527a:	63 e0       	ldi	r22, 0x03	; 3
    527c:	4f e1       	ldi	r20, 0x1F	; 31
    527e:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
    5282:	80 e0       	ldi	r24, 0x00	; 0
    5284:	90 e0       	ldi	r25, 0x00	; 0
    5286:	a0 e8       	ldi	r26, 0x80	; 128
    5288:	bf e3       	ldi	r27, 0x3F	; 63
    528a:	8a 83       	std	Y+2, r24	; 0x02
    528c:	9b 83       	std	Y+3, r25	; 0x03
    528e:	ac 83       	std	Y+4, r26	; 0x04
    5290:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5292:	6a 81       	ldd	r22, Y+2	; 0x02
    5294:	7b 81       	ldd	r23, Y+3	; 0x03
    5296:	8c 81       	ldd	r24, Y+4	; 0x04
    5298:	9d 81       	ldd	r25, Y+5	; 0x05
    529a:	2b ea       	ldi	r18, 0xAB	; 171
    529c:	3a ea       	ldi	r19, 0xAA	; 170
    529e:	4a ea       	ldi	r20, 0xAA	; 170
    52a0:	5e e3       	ldi	r21, 0x3E	; 62
    52a2:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    52a6:	dc 01       	movw	r26, r24
    52a8:	cb 01       	movw	r24, r22
    52aa:	8e 83       	std	Y+6, r24	; 0x06
    52ac:	9f 83       	std	Y+7, r25	; 0x07
    52ae:	a8 87       	std	Y+8, r26	; 0x08
    52b0:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    52b2:	11 e0       	ldi	r17, 0x01	; 1
    52b4:	6e 81       	ldd	r22, Y+6	; 0x06
    52b6:	7f 81       	ldd	r23, Y+7	; 0x07
    52b8:	88 85       	ldd	r24, Y+8	; 0x08
    52ba:	99 85       	ldd	r25, Y+9	; 0x09
    52bc:	20 e0       	ldi	r18, 0x00	; 0
    52be:	30 e0       	ldi	r19, 0x00	; 0
    52c0:	40 e8       	ldi	r20, 0x80	; 128
    52c2:	5f e3       	ldi	r21, 0x3F	; 63
    52c4:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    52c8:	88 23       	and	r24, r24
    52ca:	0c f0       	brlt	.+2      	; 0x52ce <chb_set_state+0xf0>
    52cc:	10 e0       	ldi	r17, 0x00	; 0
    52ce:	11 23       	and	r17, r17
    52d0:	19 f0       	breq	.+6      	; 0x52d8 <chb_set_state+0xfa>
		__ticks = 1;
    52d2:	81 e0       	ldi	r24, 0x01	; 1
    52d4:	8a 87       	std	Y+10, r24	; 0x0a
    52d6:	a3 c0       	rjmp	.+326    	; 0x541e <chb_set_state+0x240>
	else if (__tmp > 255)
    52d8:	11 e0       	ldi	r17, 0x01	; 1
    52da:	6e 81       	ldd	r22, Y+6	; 0x06
    52dc:	7f 81       	ldd	r23, Y+7	; 0x07
    52de:	88 85       	ldd	r24, Y+8	; 0x08
    52e0:	99 85       	ldd	r25, Y+9	; 0x09
    52e2:	20 e0       	ldi	r18, 0x00	; 0
    52e4:	30 e0       	ldi	r19, 0x00	; 0
    52e6:	4f e7       	ldi	r20, 0x7F	; 127
    52e8:	53 e4       	ldi	r21, 0x43	; 67
    52ea:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    52ee:	18 16       	cp	r1, r24
    52f0:	0c f0       	brlt	.+2      	; 0x52f4 <chb_set_state+0x116>
    52f2:	10 e0       	ldi	r17, 0x00	; 0
    52f4:	11 23       	and	r17, r17
    52f6:	09 f4       	brne	.+2      	; 0x52fa <chb_set_state+0x11c>
    52f8:	89 c0       	rjmp	.+274    	; 0x540c <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    52fa:	6a 81       	ldd	r22, Y+2	; 0x02
    52fc:	7b 81       	ldd	r23, Y+3	; 0x03
    52fe:	8c 81       	ldd	r24, Y+4	; 0x04
    5300:	9d 81       	ldd	r25, Y+5	; 0x05
    5302:	20 e0       	ldi	r18, 0x00	; 0
    5304:	30 e0       	ldi	r19, 0x00	; 0
    5306:	4a e7       	ldi	r20, 0x7A	; 122
    5308:	54 e4       	ldi	r21, 0x44	; 68
    530a:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    530e:	dc 01       	movw	r26, r24
    5310:	cb 01       	movw	r24, r22
    5312:	8b 87       	std	Y+11, r24	; 0x0b
    5314:	9c 87       	std	Y+12, r25	; 0x0c
    5316:	ad 87       	std	Y+13, r26	; 0x0d
    5318:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    531a:	6b 85       	ldd	r22, Y+11	; 0x0b
    531c:	7c 85       	ldd	r23, Y+12	; 0x0c
    531e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5320:	9e 85       	ldd	r25, Y+14	; 0x0e
    5322:	20 e0       	ldi	r18, 0x00	; 0
    5324:	30 e0       	ldi	r19, 0x00	; 0
    5326:	4a e7       	ldi	r20, 0x7A	; 122
    5328:	53 e4       	ldi	r21, 0x43	; 67
    532a:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    532e:	dc 01       	movw	r26, r24
    5330:	cb 01       	movw	r24, r22
    5332:	8f 87       	std	Y+15, r24	; 0x0f
    5334:	98 8b       	std	Y+16, r25	; 0x10
    5336:	a9 8b       	std	Y+17, r26	; 0x11
    5338:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    533a:	11 e0       	ldi	r17, 0x01	; 1
    533c:	6f 85       	ldd	r22, Y+15	; 0x0f
    533e:	78 89       	ldd	r23, Y+16	; 0x10
    5340:	89 89       	ldd	r24, Y+17	; 0x11
    5342:	9a 89       	ldd	r25, Y+18	; 0x12
    5344:	20 e0       	ldi	r18, 0x00	; 0
    5346:	30 e0       	ldi	r19, 0x00	; 0
    5348:	40 e8       	ldi	r20, 0x80	; 128
    534a:	5f e3       	ldi	r21, 0x3F	; 63
    534c:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    5350:	88 23       	and	r24, r24
    5352:	0c f0       	brlt	.+2      	; 0x5356 <chb_set_state+0x178>
    5354:	10 e0       	ldi	r17, 0x00	; 0
    5356:	11 23       	and	r17, r17
    5358:	29 f0       	breq	.+10     	; 0x5364 <chb_set_state+0x186>
		__ticks = 1;
    535a:	81 e0       	ldi	r24, 0x01	; 1
    535c:	90 e0       	ldi	r25, 0x00	; 0
    535e:	8b 8b       	std	Y+19, r24	; 0x13
    5360:	9c 8b       	std	Y+20, r25	; 0x14
    5362:	46 c0       	rjmp	.+140    	; 0x53f0 <chb_set_state+0x212>
	else if (__tmp > 65535)
    5364:	11 e0       	ldi	r17, 0x01	; 1
    5366:	6f 85       	ldd	r22, Y+15	; 0x0f
    5368:	78 89       	ldd	r23, Y+16	; 0x10
    536a:	89 89       	ldd	r24, Y+17	; 0x11
    536c:	9a 89       	ldd	r25, Y+18	; 0x12
    536e:	20 e0       	ldi	r18, 0x00	; 0
    5370:	3f ef       	ldi	r19, 0xFF	; 255
    5372:	4f e7       	ldi	r20, 0x7F	; 127
    5374:	57 e4       	ldi	r21, 0x47	; 71
    5376:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    537a:	18 16       	cp	r1, r24
    537c:	0c f0       	brlt	.+2      	; 0x5380 <chb_set_state+0x1a2>
    537e:	10 e0       	ldi	r17, 0x00	; 0
    5380:	11 23       	and	r17, r17
    5382:	61 f1       	breq	.+88     	; 0x53dc <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5384:	6b 85       	ldd	r22, Y+11	; 0x0b
    5386:	7c 85       	ldd	r23, Y+12	; 0x0c
    5388:	8d 85       	ldd	r24, Y+13	; 0x0d
    538a:	9e 85       	ldd	r25, Y+14	; 0x0e
    538c:	20 e0       	ldi	r18, 0x00	; 0
    538e:	30 e0       	ldi	r19, 0x00	; 0
    5390:	40 e2       	ldi	r20, 0x20	; 32
    5392:	51 e4       	ldi	r21, 0x41	; 65
    5394:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5398:	dc 01       	movw	r26, r24
    539a:	cb 01       	movw	r24, r22
    539c:	bc 01       	movw	r22, r24
    539e:	cd 01       	movw	r24, r26
    53a0:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    53a4:	dc 01       	movw	r26, r24
    53a6:	cb 01       	movw	r24, r22
    53a8:	8b 8b       	std	Y+19, r24	; 0x13
    53aa:	9c 8b       	std	Y+20, r25	; 0x14
    53ac:	12 c0       	rjmp	.+36     	; 0x53d2 <chb_set_state+0x1f4>
    53ae:	89 e1       	ldi	r24, 0x19	; 25
    53b0:	90 e0       	ldi	r25, 0x00	; 0
    53b2:	8d 8b       	std	Y+21, r24	; 0x15
    53b4:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    53b6:	8d 89       	ldd	r24, Y+21	; 0x15
    53b8:	9e 89       	ldd	r25, Y+22	; 0x16
    53ba:	8c 01       	movw	r16, r24
    53bc:	c8 01       	movw	r24, r16
    53be:	01 97       	sbiw	r24, 0x01	; 1
    53c0:	f1 f7       	brne	.-4      	; 0x53be <chb_set_state+0x1e0>
    53c2:	8c 01       	movw	r16, r24
    53c4:	0d 8b       	std	Y+21, r16	; 0x15
    53c6:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53c8:	8b 89       	ldd	r24, Y+19	; 0x13
    53ca:	9c 89       	ldd	r25, Y+20	; 0x14
    53cc:	01 97       	sbiw	r24, 0x01	; 1
    53ce:	8b 8b       	std	Y+19, r24	; 0x13
    53d0:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53d2:	8b 89       	ldd	r24, Y+19	; 0x13
    53d4:	9c 89       	ldd	r25, Y+20	; 0x14
    53d6:	00 97       	sbiw	r24, 0x00	; 0
    53d8:	51 f7       	brne	.-44     	; 0x53ae <chb_set_state+0x1d0>
    53da:	29 c0       	rjmp	.+82     	; 0x542e <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53dc:	6f 85       	ldd	r22, Y+15	; 0x0f
    53de:	78 89       	ldd	r23, Y+16	; 0x10
    53e0:	89 89       	ldd	r24, Y+17	; 0x11
    53e2:	9a 89       	ldd	r25, Y+18	; 0x12
    53e4:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    53e8:	dc 01       	movw	r26, r24
    53ea:	cb 01       	movw	r24, r22
    53ec:	8b 8b       	std	Y+19, r24	; 0x13
    53ee:	9c 8b       	std	Y+20, r25	; 0x14
    53f0:	8b 89       	ldd	r24, Y+19	; 0x13
    53f2:	9c 89       	ldd	r25, Y+20	; 0x14
    53f4:	8f 8b       	std	Y+23, r24	; 0x17
    53f6:	98 8f       	std	Y+24, r25	; 0x18
    53f8:	8f 89       	ldd	r24, Y+23	; 0x17
    53fa:	98 8d       	ldd	r25, Y+24	; 0x18
    53fc:	8c 01       	movw	r16, r24
    53fe:	f8 01       	movw	r30, r16
    5400:	31 97       	sbiw	r30, 0x01	; 1
    5402:	f1 f7       	brne	.-4      	; 0x5400 <chb_set_state+0x222>
    5404:	8f 01       	movw	r16, r30
    5406:	0f 8b       	std	Y+23, r16	; 0x17
    5408:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    540a:	24 c2       	rjmp	.+1096   	; 0x5854 <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    540c:	6e 81       	ldd	r22, Y+6	; 0x06
    540e:	7f 81       	ldd	r23, Y+7	; 0x07
    5410:	88 85       	ldd	r24, Y+8	; 0x08
    5412:	99 85       	ldd	r25, Y+9	; 0x09
    5414:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5418:	dc 01       	movw	r26, r24
    541a:	cb 01       	movw	r24, r22
    541c:	8a 87       	std	Y+10, r24	; 0x0a
    541e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5420:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5422:	89 8d       	ldd	r24, Y+25	; 0x19
    5424:	18 2f       	mov	r17, r24
    5426:	1a 95       	dec	r17
    5428:	f1 f7       	brne	.-4      	; 0x5426 <chb_set_state+0x248>
    542a:	19 8f       	std	Y+25, r17	; 0x19
    542c:	13 c2       	rjmp	.+1062   	; 0x5854 <chb_set_state+0x676>
    542e:	12 c2       	rjmp	.+1060   	; 0x5854 <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    5430:	89 81       	ldd	r24, Y+1	; 0x01
    5432:	86 31       	cpi	r24, 0x16	; 22
    5434:	09 f0       	breq	.+2      	; 0x5438 <chb_set_state+0x25a>
    5436:	0b c2       	rjmp	.+1046   	; 0x584e <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5438:	82 e0       	ldi	r24, 0x02	; 2
    543a:	69 e0       	ldi	r22, 0x09	; 9
    543c:	4f e1       	ldi	r20, 0x1F	; 31
    543e:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
    5442:	80 e0       	ldi	r24, 0x00	; 0
    5444:	90 e0       	ldi	r25, 0x00	; 0
    5446:	a0 e8       	ldi	r26, 0x80	; 128
    5448:	bf e3       	ldi	r27, 0x3F	; 63
    544a:	8a 8f       	std	Y+26, r24	; 0x1a
    544c:	9b 8f       	std	Y+27, r25	; 0x1b
    544e:	ac 8f       	std	Y+28, r26	; 0x1c
    5450:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5452:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5454:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5456:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5458:	9d 8d       	ldd	r25, Y+29	; 0x1d
    545a:	2b ea       	ldi	r18, 0xAB	; 171
    545c:	3a ea       	ldi	r19, 0xAA	; 170
    545e:	4a ea       	ldi	r20, 0xAA	; 170
    5460:	5e e3       	ldi	r21, 0x3E	; 62
    5462:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5466:	dc 01       	movw	r26, r24
    5468:	cb 01       	movw	r24, r22
    546a:	8e 8f       	std	Y+30, r24	; 0x1e
    546c:	9f 8f       	std	Y+31, r25	; 0x1f
    546e:	a8 a3       	lds	r26, 0x58
    5470:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    5472:	11 e0       	ldi	r17, 0x01	; 1
    5474:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5476:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5478:	88 a1       	lds	r24, 0x48
    547a:	99 a1       	lds	r25, 0x49
    547c:	20 e0       	ldi	r18, 0x00	; 0
    547e:	30 e0       	ldi	r19, 0x00	; 0
    5480:	40 e8       	ldi	r20, 0x80	; 128
    5482:	5f e3       	ldi	r21, 0x3F	; 63
    5484:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    5488:	88 23       	and	r24, r24
    548a:	0c f0       	brlt	.+2      	; 0x548e <chb_set_state+0x2b0>
    548c:	10 e0       	ldi	r17, 0x00	; 0
    548e:	11 23       	and	r17, r17
    5490:	19 f0       	breq	.+6      	; 0x5498 <chb_set_state+0x2ba>
		__ticks = 1;
    5492:	81 e0       	ldi	r24, 0x01	; 1
    5494:	8a a3       	lds	r24, 0x5a
    5496:	a3 c0       	rjmp	.+326    	; 0x55de <chb_set_state+0x400>
	else if (__tmp > 255)
    5498:	11 e0       	ldi	r17, 0x01	; 1
    549a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    549c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    549e:	88 a1       	lds	r24, 0x48
    54a0:	99 a1       	lds	r25, 0x49
    54a2:	20 e0       	ldi	r18, 0x00	; 0
    54a4:	30 e0       	ldi	r19, 0x00	; 0
    54a6:	4f e7       	ldi	r20, 0x7F	; 127
    54a8:	53 e4       	ldi	r21, 0x43	; 67
    54aa:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    54ae:	18 16       	cp	r1, r24
    54b0:	0c f0       	brlt	.+2      	; 0x54b4 <chb_set_state+0x2d6>
    54b2:	10 e0       	ldi	r17, 0x00	; 0
    54b4:	11 23       	and	r17, r17
    54b6:	09 f4       	brne	.+2      	; 0x54ba <chb_set_state+0x2dc>
    54b8:	89 c0       	rjmp	.+274    	; 0x55cc <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    54ba:	6a 8d       	ldd	r22, Y+26	; 0x1a
    54bc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    54be:	8c 8d       	ldd	r24, Y+28	; 0x1c
    54c0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    54c2:	20 e0       	ldi	r18, 0x00	; 0
    54c4:	30 e0       	ldi	r19, 0x00	; 0
    54c6:	4a e7       	ldi	r20, 0x7A	; 122
    54c8:	54 e4       	ldi	r21, 0x44	; 68
    54ca:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    54ce:	dc 01       	movw	r26, r24
    54d0:	cb 01       	movw	r24, r22
    54d2:	8b a3       	lds	r24, 0x5b
    54d4:	9c a3       	lds	r25, 0x5c
    54d6:	ad a3       	lds	r26, 0x5d
    54d8:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    54da:	6b a1       	lds	r22, 0x4b
    54dc:	7c a1       	lds	r23, 0x4c
    54de:	8d a1       	lds	r24, 0x4d
    54e0:	9e a1       	lds	r25, 0x4e
    54e2:	20 e0       	ldi	r18, 0x00	; 0
    54e4:	30 e0       	ldi	r19, 0x00	; 0
    54e6:	4a e7       	ldi	r20, 0x7A	; 122
    54e8:	53 e4       	ldi	r21, 0x43	; 67
    54ea:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    54ee:	dc 01       	movw	r26, r24
    54f0:	cb 01       	movw	r24, r22
    54f2:	8f a3       	lds	r24, 0x5f
    54f4:	98 a7       	lds	r25, 0x78
    54f6:	a9 a7       	lds	r26, 0x79
    54f8:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    54fa:	11 e0       	ldi	r17, 0x01	; 1
    54fc:	6f a1       	lds	r22, 0x4f
    54fe:	78 a5       	lds	r23, 0x68
    5500:	89 a5       	lds	r24, 0x69
    5502:	9a a5       	lds	r25, 0x6a
    5504:	20 e0       	ldi	r18, 0x00	; 0
    5506:	30 e0       	ldi	r19, 0x00	; 0
    5508:	40 e8       	ldi	r20, 0x80	; 128
    550a:	5f e3       	ldi	r21, 0x3F	; 63
    550c:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    5510:	88 23       	and	r24, r24
    5512:	0c f0       	brlt	.+2      	; 0x5516 <chb_set_state+0x338>
    5514:	10 e0       	ldi	r17, 0x00	; 0
    5516:	11 23       	and	r17, r17
    5518:	29 f0       	breq	.+10     	; 0x5524 <chb_set_state+0x346>
		__ticks = 1;
    551a:	81 e0       	ldi	r24, 0x01	; 1
    551c:	90 e0       	ldi	r25, 0x00	; 0
    551e:	8b a7       	lds	r24, 0x7b
    5520:	9c a7       	lds	r25, 0x7c
    5522:	46 c0       	rjmp	.+140    	; 0x55b0 <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    5524:	11 e0       	ldi	r17, 0x01	; 1
    5526:	6f a1       	lds	r22, 0x4f
    5528:	78 a5       	lds	r23, 0x68
    552a:	89 a5       	lds	r24, 0x69
    552c:	9a a5       	lds	r25, 0x6a
    552e:	20 e0       	ldi	r18, 0x00	; 0
    5530:	3f ef       	ldi	r19, 0xFF	; 255
    5532:	4f e7       	ldi	r20, 0x7F	; 127
    5534:	57 e4       	ldi	r21, 0x47	; 71
    5536:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    553a:	18 16       	cp	r1, r24
    553c:	0c f0       	brlt	.+2      	; 0x5540 <chb_set_state+0x362>
    553e:	10 e0       	ldi	r17, 0x00	; 0
    5540:	11 23       	and	r17, r17
    5542:	61 f1       	breq	.+88     	; 0x559c <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5544:	6b a1       	lds	r22, 0x4b
    5546:	7c a1       	lds	r23, 0x4c
    5548:	8d a1       	lds	r24, 0x4d
    554a:	9e a1       	lds	r25, 0x4e
    554c:	20 e0       	ldi	r18, 0x00	; 0
    554e:	30 e0       	ldi	r19, 0x00	; 0
    5550:	40 e2       	ldi	r20, 0x20	; 32
    5552:	51 e4       	ldi	r21, 0x41	; 65
    5554:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5558:	dc 01       	movw	r26, r24
    555a:	cb 01       	movw	r24, r22
    555c:	bc 01       	movw	r22, r24
    555e:	cd 01       	movw	r24, r26
    5560:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5564:	dc 01       	movw	r26, r24
    5566:	cb 01       	movw	r24, r22
    5568:	8b a7       	lds	r24, 0x7b
    556a:	9c a7       	lds	r25, 0x7c
    556c:	12 c0       	rjmp	.+36     	; 0x5592 <chb_set_state+0x3b4>
    556e:	89 e1       	ldi	r24, 0x19	; 25
    5570:	90 e0       	ldi	r25, 0x00	; 0
    5572:	8d a7       	lds	r24, 0x7d
    5574:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5576:	8d a5       	lds	r24, 0x6d
    5578:	9e a5       	lds	r25, 0x6e
    557a:	8c 01       	movw	r16, r24
    557c:	c8 01       	movw	r24, r16
    557e:	01 97       	sbiw	r24, 0x01	; 1
    5580:	f1 f7       	brne	.-4      	; 0x557e <chb_set_state+0x3a0>
    5582:	8c 01       	movw	r16, r24
    5584:	0d a7       	lds	r16, 0x7d
    5586:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5588:	8b a5       	lds	r24, 0x6b
    558a:	9c a5       	lds	r25, 0x6c
    558c:	01 97       	sbiw	r24, 0x01	; 1
    558e:	8b a7       	lds	r24, 0x7b
    5590:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5592:	8b a5       	lds	r24, 0x6b
    5594:	9c a5       	lds	r25, 0x6c
    5596:	00 97       	sbiw	r24, 0x00	; 0
    5598:	51 f7       	brne	.-44     	; 0x556e <chb_set_state+0x390>
    559a:	29 c0       	rjmp	.+82     	; 0x55ee <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    559c:	6f a1       	lds	r22, 0x4f
    559e:	78 a5       	lds	r23, 0x68
    55a0:	89 a5       	lds	r24, 0x69
    55a2:	9a a5       	lds	r25, 0x6a
    55a4:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    55a8:	dc 01       	movw	r26, r24
    55aa:	cb 01       	movw	r24, r22
    55ac:	8b a7       	lds	r24, 0x7b
    55ae:	9c a7       	lds	r25, 0x7c
    55b0:	8b a5       	lds	r24, 0x6b
    55b2:	9c a5       	lds	r25, 0x6c
    55b4:	8f a7       	lds	r24, 0x7f
    55b6:	98 ab       	sts	0x58, r25
    55b8:	8f a5       	lds	r24, 0x6f
    55ba:	98 a9       	sts	0x48, r25
    55bc:	8c 01       	movw	r16, r24
    55be:	f8 01       	movw	r30, r16
    55c0:	31 97       	sbiw	r30, 0x01	; 1
    55c2:	f1 f7       	brne	.-4      	; 0x55c0 <chb_set_state+0x3e2>
    55c4:	8f 01       	movw	r16, r30
    55c6:	0f a7       	lds	r16, 0x7f
    55c8:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    55ca:	41 c1       	rjmp	.+642    	; 0x584e <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    55cc:	6e 8d       	ldd	r22, Y+30	; 0x1e
    55ce:	7f 8d       	ldd	r23, Y+31	; 0x1f
    55d0:	88 a1       	lds	r24, 0x48
    55d2:	99 a1       	lds	r25, 0x49
    55d4:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    55d8:	dc 01       	movw	r26, r24
    55da:	cb 01       	movw	r24, r22
    55dc:	8a a3       	lds	r24, 0x5a
    55de:	8a a1       	lds	r24, 0x4a
    55e0:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55e2:	89 a9       	sts	0x49, r24
    55e4:	18 2f       	mov	r17, r24
    55e6:	1a 95       	dec	r17
    55e8:	f1 f7       	brne	.-4      	; 0x55e6 <chb_set_state+0x408>
    55ea:	19 ab       	sts	0x59, r17
    55ec:	30 c1       	rjmp	.+608    	; 0x584e <chb_set_state+0x670>
    55ee:	2f c1       	rjmp	.+606    	; 0x584e <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    55f0:	89 81       	ldd	r24, Y+1	; 0x01
    55f2:	89 31       	cpi	r24, 0x19	; 25
    55f4:	09 f0       	breq	.+2      	; 0x55f8 <chb_set_state+0x41a>
    55f6:	2d c1       	rjmp	.+602    	; 0x5852 <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    55f8:	82 e0       	ldi	r24, 0x02	; 2
    55fa:	69 e0       	ldi	r22, 0x09	; 9
    55fc:	4f e1       	ldi	r20, 0x1F	; 31
    55fe:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
    5602:	80 e0       	ldi	r24, 0x00	; 0
    5604:	90 e0       	ldi	r25, 0x00	; 0
    5606:	a0 e8       	ldi	r26, 0x80	; 128
    5608:	bf e3       	ldi	r27, 0x3F	; 63
    560a:	8a ab       	sts	0x5a, r24
    560c:	9b ab       	sts	0x5b, r25
    560e:	ac ab       	sts	0x5c, r26
    5610:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5612:	6a a9       	sts	0x4a, r22
    5614:	7b a9       	sts	0x4b, r23
    5616:	8c a9       	sts	0x4c, r24
    5618:	9d a9       	sts	0x4d, r25
    561a:	2b ea       	ldi	r18, 0xAB	; 171
    561c:	3a ea       	ldi	r19, 0xAA	; 170
    561e:	4a ea       	ldi	r20, 0xAA	; 170
    5620:	5e e3       	ldi	r21, 0x3E	; 62
    5622:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5626:	dc 01       	movw	r26, r24
    5628:	cb 01       	movw	r24, r22
    562a:	8e ab       	sts	0x5e, r24
    562c:	9f ab       	sts	0x5f, r25
    562e:	a8 af       	sts	0x78, r26
    5630:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    5632:	11 e0       	ldi	r17, 0x01	; 1
    5634:	6e a9       	sts	0x4e, r22
    5636:	7f a9       	sts	0x4f, r23
    5638:	88 ad       	sts	0x68, r24
    563a:	99 ad       	sts	0x69, r25
    563c:	20 e0       	ldi	r18, 0x00	; 0
    563e:	30 e0       	ldi	r19, 0x00	; 0
    5640:	40 e8       	ldi	r20, 0x80	; 128
    5642:	5f e3       	ldi	r21, 0x3F	; 63
    5644:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    5648:	88 23       	and	r24, r24
    564a:	0c f0       	brlt	.+2      	; 0x564e <chb_set_state+0x470>
    564c:	10 e0       	ldi	r17, 0x00	; 0
    564e:	11 23       	and	r17, r17
    5650:	19 f0       	breq	.+6      	; 0x5658 <chb_set_state+0x47a>
		__ticks = 1;
    5652:	81 e0       	ldi	r24, 0x01	; 1
    5654:	8a af       	sts	0x7a, r24
    5656:	e6 c0       	rjmp	.+460    	; 0x5824 <chb_set_state+0x646>
	else if (__tmp > 255)
    5658:	11 e0       	ldi	r17, 0x01	; 1
    565a:	6e a9       	sts	0x4e, r22
    565c:	7f a9       	sts	0x4f, r23
    565e:	88 ad       	sts	0x68, r24
    5660:	99 ad       	sts	0x69, r25
    5662:	20 e0       	ldi	r18, 0x00	; 0
    5664:	30 e0       	ldi	r19, 0x00	; 0
    5666:	4f e7       	ldi	r20, 0x7F	; 127
    5668:	53 e4       	ldi	r21, 0x43	; 67
    566a:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    566e:	18 16       	cp	r1, r24
    5670:	0c f0       	brlt	.+2      	; 0x5674 <chb_set_state+0x496>
    5672:	10 e0       	ldi	r17, 0x00	; 0
    5674:	11 23       	and	r17, r17
    5676:	09 f4       	brne	.+2      	; 0x567a <chb_set_state+0x49c>
    5678:	cc c0       	rjmp	.+408    	; 0x5812 <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    567a:	6a a9       	sts	0x4a, r22
    567c:	7b a9       	sts	0x4b, r23
    567e:	8c a9       	sts	0x4c, r24
    5680:	9d a9       	sts	0x4d, r25
    5682:	20 e0       	ldi	r18, 0x00	; 0
    5684:	30 e0       	ldi	r19, 0x00	; 0
    5686:	4a e7       	ldi	r20, 0x7A	; 122
    5688:	54 e4       	ldi	r21, 0x44	; 68
    568a:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    568e:	dc 01       	movw	r26, r24
    5690:	cb 01       	movw	r24, r22
    5692:	8b af       	sts	0x7b, r24
    5694:	9c af       	sts	0x7c, r25
    5696:	ad af       	sts	0x7d, r26
    5698:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    569a:	8e 01       	movw	r16, r28
    569c:	01 5c       	subi	r16, 0xC1	; 193
    569e:	1f 4f       	sbci	r17, 0xFF	; 255
    56a0:	6b ad       	sts	0x6b, r22
    56a2:	7c ad       	sts	0x6c, r23
    56a4:	8d ad       	sts	0x6d, r24
    56a6:	9e ad       	sts	0x6e, r25
    56a8:	20 e0       	ldi	r18, 0x00	; 0
    56aa:	30 e0       	ldi	r19, 0x00	; 0
    56ac:	4a e7       	ldi	r20, 0x7A	; 122
    56ae:	53 e4       	ldi	r21, 0x43	; 67
    56b0:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    56b4:	dc 01       	movw	r26, r24
    56b6:	cb 01       	movw	r24, r22
    56b8:	f8 01       	movw	r30, r16
    56ba:	80 83       	st	Z, r24
    56bc:	91 83       	std	Z+1, r25	; 0x01
    56be:	a2 83       	std	Z+2, r26	; 0x02
    56c0:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    56c2:	ce 01       	movw	r24, r28
    56c4:	cf 96       	adiw	r24, 0x3f	; 63
    56c6:	11 e0       	ldi	r17, 0x01	; 1
    56c8:	fc 01       	movw	r30, r24
    56ca:	60 81       	ld	r22, Z
    56cc:	71 81       	ldd	r23, Z+1	; 0x01
    56ce:	82 81       	ldd	r24, Z+2	; 0x02
    56d0:	93 81       	ldd	r25, Z+3	; 0x03
    56d2:	20 e0       	ldi	r18, 0x00	; 0
    56d4:	30 e0       	ldi	r19, 0x00	; 0
    56d6:	40 e8       	ldi	r20, 0x80	; 128
    56d8:	5f e3       	ldi	r21, 0x3F	; 63
    56da:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    56de:	88 23       	and	r24, r24
    56e0:	0c f0       	brlt	.+2      	; 0x56e4 <chb_set_state+0x506>
    56e2:	10 e0       	ldi	r17, 0x00	; 0
    56e4:	11 23       	and	r17, r17
    56e6:	49 f0       	breq	.+18     	; 0x56fa <chb_set_state+0x51c>
		__ticks = 1;
    56e8:	ce 01       	movw	r24, r28
    56ea:	8d 5b       	subi	r24, 0xBD	; 189
    56ec:	9f 4f       	sbci	r25, 0xFF	; 255
    56ee:	21 e0       	ldi	r18, 0x01	; 1
    56f0:	30 e0       	ldi	r19, 0x00	; 0
    56f2:	fc 01       	movw	r30, r24
    56f4:	20 83       	st	Z, r18
    56f6:	31 83       	std	Z+1, r19	; 0x01
    56f8:	6e c0       	rjmp	.+220    	; 0x57d6 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    56fa:	ce 01       	movw	r24, r28
    56fc:	cf 96       	adiw	r24, 0x3f	; 63
    56fe:	11 e0       	ldi	r17, 0x01	; 1
    5700:	fc 01       	movw	r30, r24
    5702:	60 81       	ld	r22, Z
    5704:	71 81       	ldd	r23, Z+1	; 0x01
    5706:	82 81       	ldd	r24, Z+2	; 0x02
    5708:	93 81       	ldd	r25, Z+3	; 0x03
    570a:	20 e0       	ldi	r18, 0x00	; 0
    570c:	3f ef       	ldi	r19, 0xFF	; 255
    570e:	4f e7       	ldi	r20, 0x7F	; 127
    5710:	57 e4       	ldi	r21, 0x47	; 71
    5712:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    5716:	18 16       	cp	r1, r24
    5718:	0c f0       	brlt	.+2      	; 0x571c <chb_set_state+0x53e>
    571a:	10 e0       	ldi	r17, 0x00	; 0
    571c:	11 23       	and	r17, r17
    571e:	09 f4       	brne	.+2      	; 0x5722 <chb_set_state+0x544>
    5720:	49 c0       	rjmp	.+146    	; 0x57b4 <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5722:	6b ad       	sts	0x6b, r22
    5724:	7c ad       	sts	0x6c, r23
    5726:	8d ad       	sts	0x6d, r24
    5728:	9e ad       	sts	0x6e, r25
    572a:	20 e0       	ldi	r18, 0x00	; 0
    572c:	30 e0       	ldi	r19, 0x00	; 0
    572e:	40 e2       	ldi	r20, 0x20	; 32
    5730:	51 e4       	ldi	r21, 0x41	; 65
    5732:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5736:	dc 01       	movw	r26, r24
    5738:	cb 01       	movw	r24, r22
    573a:	8e 01       	movw	r16, r28
    573c:	0d 5b       	subi	r16, 0xBD	; 189
    573e:	1f 4f       	sbci	r17, 0xFF	; 255
    5740:	bc 01       	movw	r22, r24
    5742:	cd 01       	movw	r24, r26
    5744:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5748:	dc 01       	movw	r26, r24
    574a:	cb 01       	movw	r24, r22
    574c:	f8 01       	movw	r30, r16
    574e:	80 83       	st	Z, r24
    5750:	91 83       	std	Z+1, r25	; 0x01
    5752:	27 c0       	rjmp	.+78     	; 0x57a2 <chb_set_state+0x5c4>
    5754:	ce 01       	movw	r24, r28
    5756:	8b 5b       	subi	r24, 0xBB	; 187
    5758:	9f 4f       	sbci	r25, 0xFF	; 255
    575a:	29 e1       	ldi	r18, 0x19	; 25
    575c:	30 e0       	ldi	r19, 0x00	; 0
    575e:	fc 01       	movw	r30, r24
    5760:	20 83       	st	Z, r18
    5762:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5764:	ce 01       	movw	r24, r28
    5766:	8b 5b       	subi	r24, 0xBB	; 187
    5768:	9f 4f       	sbci	r25, 0xFF	; 255
    576a:	fc 01       	movw	r30, r24
    576c:	80 81       	ld	r24, Z
    576e:	91 81       	ldd	r25, Z+1	; 0x01
    5770:	8c 01       	movw	r16, r24
    5772:	c8 01       	movw	r24, r16
    5774:	01 97       	sbiw	r24, 0x01	; 1
    5776:	f1 f7       	brne	.-4      	; 0x5774 <chb_set_state+0x596>
    5778:	8c 01       	movw	r16, r24
    577a:	ce 01       	movw	r24, r28
    577c:	8b 5b       	subi	r24, 0xBB	; 187
    577e:	9f 4f       	sbci	r25, 0xFF	; 255
    5780:	fc 01       	movw	r30, r24
    5782:	00 83       	st	Z, r16
    5784:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5786:	ce 01       	movw	r24, r28
    5788:	8d 5b       	subi	r24, 0xBD	; 189
    578a:	9f 4f       	sbci	r25, 0xFF	; 255
    578c:	9e 01       	movw	r18, r28
    578e:	2d 5b       	subi	r18, 0xBD	; 189
    5790:	3f 4f       	sbci	r19, 0xFF	; 255
    5792:	f9 01       	movw	r30, r18
    5794:	20 81       	ld	r18, Z
    5796:	31 81       	ldd	r19, Z+1	; 0x01
    5798:	21 50       	subi	r18, 0x01	; 1
    579a:	30 40       	sbci	r19, 0x00	; 0
    579c:	fc 01       	movw	r30, r24
    579e:	20 83       	st	Z, r18
    57a0:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57a2:	ce 01       	movw	r24, r28
    57a4:	8d 5b       	subi	r24, 0xBD	; 189
    57a6:	9f 4f       	sbci	r25, 0xFF	; 255
    57a8:	fc 01       	movw	r30, r24
    57aa:	80 81       	ld	r24, Z
    57ac:	91 81       	ldd	r25, Z+1	; 0x01
    57ae:	00 97       	sbiw	r24, 0x00	; 0
    57b0:	89 f6       	brne	.-94     	; 0x5754 <chb_set_state+0x576>
    57b2:	4c c0       	rjmp	.+152    	; 0x584c <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57b4:	8e 01       	movw	r16, r28
    57b6:	0d 5b       	subi	r16, 0xBD	; 189
    57b8:	1f 4f       	sbci	r17, 0xFF	; 255
    57ba:	ce 01       	movw	r24, r28
    57bc:	cf 96       	adiw	r24, 0x3f	; 63
    57be:	fc 01       	movw	r30, r24
    57c0:	60 81       	ld	r22, Z
    57c2:	71 81       	ldd	r23, Z+1	; 0x01
    57c4:	82 81       	ldd	r24, Z+2	; 0x02
    57c6:	93 81       	ldd	r25, Z+3	; 0x03
    57c8:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    57cc:	dc 01       	movw	r26, r24
    57ce:	cb 01       	movw	r24, r22
    57d0:	f8 01       	movw	r30, r16
    57d2:	80 83       	st	Z, r24
    57d4:	91 83       	std	Z+1, r25	; 0x01
    57d6:	ce 01       	movw	r24, r28
    57d8:	89 5b       	subi	r24, 0xB9	; 185
    57da:	9f 4f       	sbci	r25, 0xFF	; 255
    57dc:	9e 01       	movw	r18, r28
    57de:	2d 5b       	subi	r18, 0xBD	; 189
    57e0:	3f 4f       	sbci	r19, 0xFF	; 255
    57e2:	f9 01       	movw	r30, r18
    57e4:	20 81       	ld	r18, Z
    57e6:	31 81       	ldd	r19, Z+1	; 0x01
    57e8:	fc 01       	movw	r30, r24
    57ea:	20 83       	st	Z, r18
    57ec:	31 83       	std	Z+1, r19	; 0x01
    57ee:	ce 01       	movw	r24, r28
    57f0:	89 5b       	subi	r24, 0xB9	; 185
    57f2:	9f 4f       	sbci	r25, 0xFF	; 255
    57f4:	fc 01       	movw	r30, r24
    57f6:	80 81       	ld	r24, Z
    57f8:	91 81       	ldd	r25, Z+1	; 0x01
    57fa:	8c 01       	movw	r16, r24
    57fc:	c8 01       	movw	r24, r16
    57fe:	01 97       	sbiw	r24, 0x01	; 1
    5800:	f1 f7       	brne	.-4      	; 0x57fe <chb_set_state+0x620>
    5802:	8c 01       	movw	r16, r24
    5804:	ce 01       	movw	r24, r28
    5806:	89 5b       	subi	r24, 0xB9	; 185
    5808:	9f 4f       	sbci	r25, 0xFF	; 255
    580a:	fc 01       	movw	r30, r24
    580c:	00 83       	st	Z, r16
    580e:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5810:	20 c0       	rjmp	.+64     	; 0x5852 <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5812:	6e a9       	sts	0x4e, r22
    5814:	7f a9       	sts	0x4f, r23
    5816:	88 ad       	sts	0x68, r24
    5818:	99 ad       	sts	0x69, r25
    581a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    581e:	dc 01       	movw	r26, r24
    5820:	cb 01       	movw	r24, r22
    5822:	8a af       	sts	0x7a, r24
    5824:	ce 01       	movw	r24, r28
    5826:	87 5b       	subi	r24, 0xB7	; 183
    5828:	9f 4f       	sbci	r25, 0xFF	; 255
    582a:	2a ad       	sts	0x6a, r18
    582c:	fc 01       	movw	r30, r24
    582e:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5830:	ce 01       	movw	r24, r28
    5832:	87 5b       	subi	r24, 0xB7	; 183
    5834:	9f 4f       	sbci	r25, 0xFF	; 255
    5836:	fc 01       	movw	r30, r24
    5838:	80 81       	ld	r24, Z
    583a:	18 2f       	mov	r17, r24
    583c:	1a 95       	dec	r17
    583e:	f1 f7       	brne	.-4      	; 0x583c <chb_set_state+0x65e>
    5840:	ce 01       	movw	r24, r28
    5842:	87 5b       	subi	r24, 0xB7	; 183
    5844:	9f 4f       	sbci	r25, 0xFF	; 255
    5846:	fc 01       	movw	r30, r24
    5848:	10 83       	st	Z, r17
    584a:	03 c0       	rjmp	.+6      	; 0x5852 <chb_set_state+0x674>
    584c:	02 c0       	rjmp	.+4      	; 0x5852 <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    584e:	00 00       	nop
    5850:	01 c0       	rjmp	.+2      	; 0x5854 <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5852:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    5854:	9e 01       	movw	r18, r28
    5856:	2e 59       	subi	r18, 0x9E	; 158
    5858:	3f 4f       	sbci	r19, 0xFF	; 255
    585a:	82 e0       	ldi	r24, 0x02	; 2
    585c:	f9 01       	movw	r30, r18
    585e:	60 81       	ld	r22, Z
    5860:	4f e1       	ldi	r20, 0x1F	; 31
    5862:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
    5866:	9e 01       	movw	r18, r28
    5868:	26 5b       	subi	r18, 0xB6	; 182
    586a:	3f 4f       	sbci	r19, 0xFF	; 255
    586c:	80 e0       	ldi	r24, 0x00	; 0
    586e:	90 e0       	ldi	r25, 0x00	; 0
    5870:	ac ed       	ldi	r26, 0xDC	; 220
    5872:	b2 e4       	ldi	r27, 0x42	; 66
    5874:	f9 01       	movw	r30, r18
    5876:	80 83       	st	Z, r24
    5878:	91 83       	std	Z+1, r25	; 0x01
    587a:	a2 83       	std	Z+2, r26	; 0x02
    587c:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    587e:	8e 01       	movw	r16, r28
    5880:	02 5b       	subi	r16, 0xB2	; 178
    5882:	1f 4f       	sbci	r17, 0xFF	; 255
    5884:	ce 01       	movw	r24, r28
    5886:	86 5b       	subi	r24, 0xB6	; 182
    5888:	9f 4f       	sbci	r25, 0xFF	; 255
    588a:	fc 01       	movw	r30, r24
    588c:	60 81       	ld	r22, Z
    588e:	71 81       	ldd	r23, Z+1	; 0x01
    5890:	82 81       	ldd	r24, Z+2	; 0x02
    5892:	93 81       	ldd	r25, Z+3	; 0x03
    5894:	2b ea       	ldi	r18, 0xAB	; 171
    5896:	3a ea       	ldi	r19, 0xAA	; 170
    5898:	4a ea       	ldi	r20, 0xAA	; 170
    589a:	5e e3       	ldi	r21, 0x3E	; 62
    589c:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    58a0:	dc 01       	movw	r26, r24
    58a2:	cb 01       	movw	r24, r22
    58a4:	f8 01       	movw	r30, r16
    58a6:	80 83       	st	Z, r24
    58a8:	91 83       	std	Z+1, r25	; 0x01
    58aa:	a2 83       	std	Z+2, r26	; 0x02
    58ac:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    58ae:	ce 01       	movw	r24, r28
    58b0:	82 5b       	subi	r24, 0xB2	; 178
    58b2:	9f 4f       	sbci	r25, 0xFF	; 255
    58b4:	11 e0       	ldi	r17, 0x01	; 1
    58b6:	fc 01       	movw	r30, r24
    58b8:	60 81       	ld	r22, Z
    58ba:	71 81       	ldd	r23, Z+1	; 0x01
    58bc:	82 81       	ldd	r24, Z+2	; 0x02
    58be:	93 81       	ldd	r25, Z+3	; 0x03
    58c0:	20 e0       	ldi	r18, 0x00	; 0
    58c2:	30 e0       	ldi	r19, 0x00	; 0
    58c4:	40 e8       	ldi	r20, 0x80	; 128
    58c6:	5f e3       	ldi	r21, 0x3F	; 63
    58c8:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    58cc:	88 23       	and	r24, r24
    58ce:	0c f0       	brlt	.+2      	; 0x58d2 <chb_set_state+0x6f4>
    58d0:	10 e0       	ldi	r17, 0x00	; 0
    58d2:	11 23       	and	r17, r17
    58d4:	39 f0       	breq	.+14     	; 0x58e4 <chb_set_state+0x706>
		__ticks = 1;
    58d6:	ce 01       	movw	r24, r28
    58d8:	8e 5a       	subi	r24, 0xAE	; 174
    58da:	9f 4f       	sbci	r25, 0xFF	; 255
    58dc:	21 e0       	ldi	r18, 0x01	; 1
    58de:	fc 01       	movw	r30, r24
    58e0:	20 83       	st	Z, r18
    58e2:	05 c1       	rjmp	.+522    	; 0x5aee <chb_set_state+0x910>
	else if (__tmp > 255)
    58e4:	ce 01       	movw	r24, r28
    58e6:	82 5b       	subi	r24, 0xB2	; 178
    58e8:	9f 4f       	sbci	r25, 0xFF	; 255
    58ea:	11 e0       	ldi	r17, 0x01	; 1
    58ec:	fc 01       	movw	r30, r24
    58ee:	60 81       	ld	r22, Z
    58f0:	71 81       	ldd	r23, Z+1	; 0x01
    58f2:	82 81       	ldd	r24, Z+2	; 0x02
    58f4:	93 81       	ldd	r25, Z+3	; 0x03
    58f6:	20 e0       	ldi	r18, 0x00	; 0
    58f8:	30 e0       	ldi	r19, 0x00	; 0
    58fa:	4f e7       	ldi	r20, 0x7F	; 127
    58fc:	53 e4       	ldi	r21, 0x43	; 67
    58fe:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    5902:	18 16       	cp	r1, r24
    5904:	0c f0       	brlt	.+2      	; 0x5908 <chb_set_state+0x72a>
    5906:	10 e0       	ldi	r17, 0x00	; 0
    5908:	11 23       	and	r17, r17
    590a:	09 f4       	brne	.+2      	; 0x590e <chb_set_state+0x730>
    590c:	df c0       	rjmp	.+446    	; 0x5acc <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    590e:	ce 01       	movw	r24, r28
    5910:	86 5b       	subi	r24, 0xB6	; 182
    5912:	9f 4f       	sbci	r25, 0xFF	; 255
    5914:	fc 01       	movw	r30, r24
    5916:	60 81       	ld	r22, Z
    5918:	71 81       	ldd	r23, Z+1	; 0x01
    591a:	82 81       	ldd	r24, Z+2	; 0x02
    591c:	93 81       	ldd	r25, Z+3	; 0x03
    591e:	20 e0       	ldi	r18, 0x00	; 0
    5920:	30 e0       	ldi	r19, 0x00	; 0
    5922:	4a e7       	ldi	r20, 0x7A	; 122
    5924:	54 e4       	ldi	r21, 0x44	; 68
    5926:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    592a:	dc 01       	movw	r26, r24
    592c:	cb 01       	movw	r24, r22
    592e:	9e 01       	movw	r18, r28
    5930:	2d 5a       	subi	r18, 0xAD	; 173
    5932:	3f 4f       	sbci	r19, 0xFF	; 255
    5934:	f9 01       	movw	r30, r18
    5936:	80 83       	st	Z, r24
    5938:	91 83       	std	Z+1, r25	; 0x01
    593a:	a2 83       	std	Z+2, r26	; 0x02
    593c:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    593e:	8e 01       	movw	r16, r28
    5940:	09 5a       	subi	r16, 0xA9	; 169
    5942:	1f 4f       	sbci	r17, 0xFF	; 255
    5944:	ce 01       	movw	r24, r28
    5946:	8d 5a       	subi	r24, 0xAD	; 173
    5948:	9f 4f       	sbci	r25, 0xFF	; 255
    594a:	fc 01       	movw	r30, r24
    594c:	60 81       	ld	r22, Z
    594e:	71 81       	ldd	r23, Z+1	; 0x01
    5950:	82 81       	ldd	r24, Z+2	; 0x02
    5952:	93 81       	ldd	r25, Z+3	; 0x03
    5954:	20 e0       	ldi	r18, 0x00	; 0
    5956:	30 e0       	ldi	r19, 0x00	; 0
    5958:	4a e7       	ldi	r20, 0x7A	; 122
    595a:	53 e4       	ldi	r21, 0x43	; 67
    595c:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5960:	dc 01       	movw	r26, r24
    5962:	cb 01       	movw	r24, r22
    5964:	f8 01       	movw	r30, r16
    5966:	80 83       	st	Z, r24
    5968:	91 83       	std	Z+1, r25	; 0x01
    596a:	a2 83       	std	Z+2, r26	; 0x02
    596c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    596e:	ce 01       	movw	r24, r28
    5970:	89 5a       	subi	r24, 0xA9	; 169
    5972:	9f 4f       	sbci	r25, 0xFF	; 255
    5974:	11 e0       	ldi	r17, 0x01	; 1
    5976:	fc 01       	movw	r30, r24
    5978:	60 81       	ld	r22, Z
    597a:	71 81       	ldd	r23, Z+1	; 0x01
    597c:	82 81       	ldd	r24, Z+2	; 0x02
    597e:	93 81       	ldd	r25, Z+3	; 0x03
    5980:	20 e0       	ldi	r18, 0x00	; 0
    5982:	30 e0       	ldi	r19, 0x00	; 0
    5984:	40 e8       	ldi	r20, 0x80	; 128
    5986:	5f e3       	ldi	r21, 0x3F	; 63
    5988:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    598c:	88 23       	and	r24, r24
    598e:	0c f0       	brlt	.+2      	; 0x5992 <chb_set_state+0x7b4>
    5990:	10 e0       	ldi	r17, 0x00	; 0
    5992:	11 23       	and	r17, r17
    5994:	49 f0       	breq	.+18     	; 0x59a8 <chb_set_state+0x7ca>
		__ticks = 1;
    5996:	ce 01       	movw	r24, r28
    5998:	85 5a       	subi	r24, 0xA5	; 165
    599a:	9f 4f       	sbci	r25, 0xFF	; 255
    599c:	21 e0       	ldi	r18, 0x01	; 1
    599e:	30 e0       	ldi	r19, 0x00	; 0
    59a0:	fc 01       	movw	r30, r24
    59a2:	20 83       	st	Z, r18
    59a4:	31 83       	std	Z+1, r19	; 0x01
    59a6:	74 c0       	rjmp	.+232    	; 0x5a90 <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    59a8:	ce 01       	movw	r24, r28
    59aa:	89 5a       	subi	r24, 0xA9	; 169
    59ac:	9f 4f       	sbci	r25, 0xFF	; 255
    59ae:	11 e0       	ldi	r17, 0x01	; 1
    59b0:	fc 01       	movw	r30, r24
    59b2:	60 81       	ld	r22, Z
    59b4:	71 81       	ldd	r23, Z+1	; 0x01
    59b6:	82 81       	ldd	r24, Z+2	; 0x02
    59b8:	93 81       	ldd	r25, Z+3	; 0x03
    59ba:	20 e0       	ldi	r18, 0x00	; 0
    59bc:	3f ef       	ldi	r19, 0xFF	; 255
    59be:	4f e7       	ldi	r20, 0x7F	; 127
    59c0:	57 e4       	ldi	r21, 0x47	; 71
    59c2:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    59c6:	18 16       	cp	r1, r24
    59c8:	0c f0       	brlt	.+2      	; 0x59cc <chb_set_state+0x7ee>
    59ca:	10 e0       	ldi	r17, 0x00	; 0
    59cc:	11 23       	and	r17, r17
    59ce:	09 f4       	brne	.+2      	; 0x59d2 <chb_set_state+0x7f4>
    59d0:	4d c0       	rjmp	.+154    	; 0x5a6c <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    59d2:	ce 01       	movw	r24, r28
    59d4:	8d 5a       	subi	r24, 0xAD	; 173
    59d6:	9f 4f       	sbci	r25, 0xFF	; 255
    59d8:	fc 01       	movw	r30, r24
    59da:	60 81       	ld	r22, Z
    59dc:	71 81       	ldd	r23, Z+1	; 0x01
    59de:	82 81       	ldd	r24, Z+2	; 0x02
    59e0:	93 81       	ldd	r25, Z+3	; 0x03
    59e2:	20 e0       	ldi	r18, 0x00	; 0
    59e4:	30 e0       	ldi	r19, 0x00	; 0
    59e6:	40 e2       	ldi	r20, 0x20	; 32
    59e8:	51 e4       	ldi	r21, 0x41	; 65
    59ea:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    59ee:	dc 01       	movw	r26, r24
    59f0:	cb 01       	movw	r24, r22
    59f2:	8e 01       	movw	r16, r28
    59f4:	05 5a       	subi	r16, 0xA5	; 165
    59f6:	1f 4f       	sbci	r17, 0xFF	; 255
    59f8:	bc 01       	movw	r22, r24
    59fa:	cd 01       	movw	r24, r26
    59fc:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5a00:	dc 01       	movw	r26, r24
    5a02:	cb 01       	movw	r24, r22
    5a04:	f8 01       	movw	r30, r16
    5a06:	80 83       	st	Z, r24
    5a08:	91 83       	std	Z+1, r25	; 0x01
    5a0a:	27 c0       	rjmp	.+78     	; 0x5a5a <chb_set_state+0x87c>
    5a0c:	ce 01       	movw	r24, r28
    5a0e:	83 5a       	subi	r24, 0xA3	; 163
    5a10:	9f 4f       	sbci	r25, 0xFF	; 255
    5a12:	29 e1       	ldi	r18, 0x19	; 25
    5a14:	30 e0       	ldi	r19, 0x00	; 0
    5a16:	fc 01       	movw	r30, r24
    5a18:	20 83       	st	Z, r18
    5a1a:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5a1c:	ce 01       	movw	r24, r28
    5a1e:	83 5a       	subi	r24, 0xA3	; 163
    5a20:	9f 4f       	sbci	r25, 0xFF	; 255
    5a22:	fc 01       	movw	r30, r24
    5a24:	80 81       	ld	r24, Z
    5a26:	91 81       	ldd	r25, Z+1	; 0x01
    5a28:	8c 01       	movw	r16, r24
    5a2a:	c8 01       	movw	r24, r16
    5a2c:	01 97       	sbiw	r24, 0x01	; 1
    5a2e:	f1 f7       	brne	.-4      	; 0x5a2c <chb_set_state+0x84e>
    5a30:	8c 01       	movw	r16, r24
    5a32:	ce 01       	movw	r24, r28
    5a34:	83 5a       	subi	r24, 0xA3	; 163
    5a36:	9f 4f       	sbci	r25, 0xFF	; 255
    5a38:	fc 01       	movw	r30, r24
    5a3a:	00 83       	st	Z, r16
    5a3c:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a3e:	ce 01       	movw	r24, r28
    5a40:	85 5a       	subi	r24, 0xA5	; 165
    5a42:	9f 4f       	sbci	r25, 0xFF	; 255
    5a44:	9e 01       	movw	r18, r28
    5a46:	25 5a       	subi	r18, 0xA5	; 165
    5a48:	3f 4f       	sbci	r19, 0xFF	; 255
    5a4a:	f9 01       	movw	r30, r18
    5a4c:	20 81       	ld	r18, Z
    5a4e:	31 81       	ldd	r19, Z+1	; 0x01
    5a50:	21 50       	subi	r18, 0x01	; 1
    5a52:	30 40       	sbci	r19, 0x00	; 0
    5a54:	fc 01       	movw	r30, r24
    5a56:	20 83       	st	Z, r18
    5a58:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a5a:	ce 01       	movw	r24, r28
    5a5c:	85 5a       	subi	r24, 0xA5	; 165
    5a5e:	9f 4f       	sbci	r25, 0xFF	; 255
    5a60:	fc 01       	movw	r30, r24
    5a62:	80 81       	ld	r24, Z
    5a64:	91 81       	ldd	r25, Z+1	; 0x01
    5a66:	00 97       	sbiw	r24, 0x00	; 0
    5a68:	89 f6       	brne	.-94     	; 0x5a0c <chb_set_state+0x82e>
    5a6a:	58 c0       	rjmp	.+176    	; 0x5b1c <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a6c:	8e 01       	movw	r16, r28
    5a6e:	05 5a       	subi	r16, 0xA5	; 165
    5a70:	1f 4f       	sbci	r17, 0xFF	; 255
    5a72:	ce 01       	movw	r24, r28
    5a74:	89 5a       	subi	r24, 0xA9	; 169
    5a76:	9f 4f       	sbci	r25, 0xFF	; 255
    5a78:	fc 01       	movw	r30, r24
    5a7a:	60 81       	ld	r22, Z
    5a7c:	71 81       	ldd	r23, Z+1	; 0x01
    5a7e:	82 81       	ldd	r24, Z+2	; 0x02
    5a80:	93 81       	ldd	r25, Z+3	; 0x03
    5a82:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5a86:	dc 01       	movw	r26, r24
    5a88:	cb 01       	movw	r24, r22
    5a8a:	f8 01       	movw	r30, r16
    5a8c:	80 83       	st	Z, r24
    5a8e:	91 83       	std	Z+1, r25	; 0x01
    5a90:	ce 01       	movw	r24, r28
    5a92:	81 5a       	subi	r24, 0xA1	; 161
    5a94:	9f 4f       	sbci	r25, 0xFF	; 255
    5a96:	9e 01       	movw	r18, r28
    5a98:	25 5a       	subi	r18, 0xA5	; 165
    5a9a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a9c:	f9 01       	movw	r30, r18
    5a9e:	20 81       	ld	r18, Z
    5aa0:	31 81       	ldd	r19, Z+1	; 0x01
    5aa2:	fc 01       	movw	r30, r24
    5aa4:	20 83       	st	Z, r18
    5aa6:	31 83       	std	Z+1, r19	; 0x01
    5aa8:	ce 01       	movw	r24, r28
    5aaa:	81 5a       	subi	r24, 0xA1	; 161
    5aac:	9f 4f       	sbci	r25, 0xFF	; 255
    5aae:	fc 01       	movw	r30, r24
    5ab0:	80 81       	ld	r24, Z
    5ab2:	91 81       	ldd	r25, Z+1	; 0x01
    5ab4:	8c 01       	movw	r16, r24
    5ab6:	c8 01       	movw	r24, r16
    5ab8:	01 97       	sbiw	r24, 0x01	; 1
    5aba:	f1 f7       	brne	.-4      	; 0x5ab8 <chb_set_state+0x8da>
    5abc:	8c 01       	movw	r16, r24
    5abe:	ce 01       	movw	r24, r28
    5ac0:	81 5a       	subi	r24, 0xA1	; 161
    5ac2:	9f 4f       	sbci	r25, 0xFF	; 255
    5ac4:	fc 01       	movw	r30, r24
    5ac6:	00 83       	st	Z, r16
    5ac8:	11 83       	std	Z+1, r17	; 0x01
    5aca:	28 c0       	rjmp	.+80     	; 0x5b1c <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5acc:	8e 01       	movw	r16, r28
    5ace:	0e 5a       	subi	r16, 0xAE	; 174
    5ad0:	1f 4f       	sbci	r17, 0xFF	; 255
    5ad2:	ce 01       	movw	r24, r28
    5ad4:	82 5b       	subi	r24, 0xB2	; 178
    5ad6:	9f 4f       	sbci	r25, 0xFF	; 255
    5ad8:	fc 01       	movw	r30, r24
    5ada:	60 81       	ld	r22, Z
    5adc:	71 81       	ldd	r23, Z+1	; 0x01
    5ade:	82 81       	ldd	r24, Z+2	; 0x02
    5ae0:	93 81       	ldd	r25, Z+3	; 0x03
    5ae2:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5ae6:	dc 01       	movw	r26, r24
    5ae8:	cb 01       	movw	r24, r22
    5aea:	f8 01       	movw	r30, r16
    5aec:	80 83       	st	Z, r24
    5aee:	ce 01       	movw	r24, r28
    5af0:	8f 59       	subi	r24, 0x9F	; 159
    5af2:	9f 4f       	sbci	r25, 0xFF	; 255
    5af4:	9e 01       	movw	r18, r28
    5af6:	2e 5a       	subi	r18, 0xAE	; 174
    5af8:	3f 4f       	sbci	r19, 0xFF	; 255
    5afa:	f9 01       	movw	r30, r18
    5afc:	20 81       	ld	r18, Z
    5afe:	fc 01       	movw	r30, r24
    5b00:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5b02:	ce 01       	movw	r24, r28
    5b04:	8f 59       	subi	r24, 0x9F	; 159
    5b06:	9f 4f       	sbci	r25, 0xFF	; 255
    5b08:	fc 01       	movw	r30, r24
    5b0a:	80 81       	ld	r24, Z
    5b0c:	18 2f       	mov	r17, r24
    5b0e:	1a 95       	dec	r17
    5b10:	f1 f7       	brne	.-4      	; 0x5b0e <chb_set_state+0x930>
    5b12:	ce 01       	movw	r24, r28
    5b14:	8f 59       	subi	r24, 0x9F	; 159
    5b16:	9f 4f       	sbci	r25, 0xFF	; 255
    5b18:	fc 01       	movw	r30, r24
    5b1a:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5b1c:	0e 94 88 23 	call	0x4710	; 0x4710 <chb_get_state>
    5b20:	28 2f       	mov	r18, r24
    5b22:	ce 01       	movw	r24, r28
    5b24:	8e 59       	subi	r24, 0x9E	; 158
    5b26:	9f 4f       	sbci	r25, 0xFF	; 255
    5b28:	fc 01       	movw	r30, r24
    5b2a:	80 81       	ld	r24, Z
    5b2c:	28 17       	cp	r18, r24
    5b2e:	11 f4       	brne	.+4      	; 0x5b34 <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5b30:	80 e4       	ldi	r24, 0x40	; 64
    5b32:	01 c0       	rjmp	.+2      	; 0x5b36 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    5b34:	83 e4       	ldi	r24, 0x43	; 67
}
    5b36:	ce 59       	subi	r28, 0x9E	; 158
    5b38:	df 4f       	sbci	r29, 0xFF	; 255
    5b3a:	cd bf       	out	0x3d, r28	; 61
    5b3c:	de bf       	out	0x3e, r29	; 62
    5b3e:	df 91       	pop	r29
    5b40:	cf 91       	pop	r28
    5b42:	1f 91       	pop	r17
    5b44:	0f 91       	pop	r16
    5b46:	08 95       	ret

00005b48 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5b48:	cf 93       	push	r28
    5b4a:	df 93       	push	r29
    5b4c:	0f 92       	push	r0
    5b4e:	0f 92       	push	r0
    5b50:	cd b7       	in	r28, 0x3d	; 61
    5b52:	de b7       	in	r29, 0x3e	; 62
    5b54:	89 83       	std	Y+1, r24	; 0x01
    5b56:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5b58:	29 81       	ldd	r18, Y+1	; 0x01
    5b5a:	3a 81       	ldd	r19, Y+2	; 0x02
    5b5c:	80 e0       	ldi	r24, 0x00	; 0
    5b5e:	90 e0       	ldi	r25, 0x00	; 0
    5b60:	b9 01       	movw	r22, r18
    5b62:	48 e0       	ldi	r20, 0x08	; 8
    5b64:	50 e0       	ldi	r21, 0x00	; 0
    5b66:	0e 94 c3 31 	call	0x6386	; 0x6386 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5b6a:	29 81       	ldd	r18, Y+1	; 0x01
    5b6c:	3a 81       	ldd	r19, Y+2	; 0x02
    5b6e:	84 e2       	ldi	r24, 0x24	; 36
    5b70:	b9 01       	movw	r22, r18
    5b72:	0e 94 49 26 	call	0x4c92	; 0x4c92 <chb_reg_write64>
}
    5b76:	0f 90       	pop	r0
    5b78:	0f 90       	pop	r0
    5b7a:	df 91       	pop	r29
    5b7c:	cf 91       	pop	r28
    5b7e:	08 95       	ret

00005b80 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5b80:	cf 93       	push	r28
    5b82:	df 93       	push	r29
    5b84:	0f 92       	push	r0
    5b86:	0f 92       	push	r0
    5b88:	cd b7       	in	r28, 0x3d	; 61
    5b8a:	de b7       	in	r29, 0x3e	; 62
    5b8c:	89 83       	std	Y+1, r24	; 0x01
    5b8e:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5b90:	29 81       	ldd	r18, Y+1	; 0x01
    5b92:	3a 81       	ldd	r19, Y+2	; 0x02
    5b94:	80 e0       	ldi	r24, 0x00	; 0
    5b96:	90 e0       	ldi	r25, 0x00	; 0
    5b98:	b9 01       	movw	r22, r18
    5b9a:	48 e0       	ldi	r20, 0x08	; 8
    5b9c:	50 e0       	ldi	r21, 0x00	; 0
    5b9e:	0e 94 ff 31 	call	0x63fe	; 0x63fe <chb_eeprom_read>
}
    5ba2:	0f 90       	pop	r0
    5ba4:	0f 90       	pop	r0
    5ba6:	df 91       	pop	r29
    5ba8:	cf 91       	pop	r28
    5baa:	08 95       	ret

00005bac <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5bac:	cf 93       	push	r28
    5bae:	df 93       	push	r29
    5bb0:	00 d0       	rcall	.+0      	; 0x5bb2 <chb_set_short_addr+0x6>
    5bb2:	00 d0       	rcall	.+0      	; 0x5bb4 <chb_set_short_addr+0x8>
    5bb4:	cd b7       	in	r28, 0x3d	; 61
    5bb6:	de b7       	in	r29, 0x3e	; 62
    5bb8:	8d 83       	std	Y+5, r24	; 0x05
    5bba:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5bbc:	ce 01       	movw	r24, r28
    5bbe:	05 96       	adiw	r24, 0x05	; 5
    5bc0:	89 83       	std	Y+1, r24	; 0x01
    5bc2:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    5bc4:	0e 94 85 20 	call	0x410a	; 0x410a <chb_get_pcb>
    5bc8:	8b 83       	std	Y+3, r24	; 0x03
    5bca:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5bcc:	29 81       	ldd	r18, Y+1	; 0x01
    5bce:	3a 81       	ldd	r19, Y+2	; 0x02
    5bd0:	89 e0       	ldi	r24, 0x09	; 9
    5bd2:	90 e0       	ldi	r25, 0x00	; 0
    5bd4:	b9 01       	movw	r22, r18
    5bd6:	42 e0       	ldi	r20, 0x02	; 2
    5bd8:	50 e0       	ldi	r21, 0x00	; 0
    5bda:	0e 94 c3 31 	call	0x6386	; 0x6386 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    5bde:	2d 81       	ldd	r18, Y+5	; 0x05
    5be0:	3e 81       	ldd	r19, Y+6	; 0x06
    5be2:	80 e2       	ldi	r24, 0x20	; 32
    5be4:	b9 01       	movw	r22, r18
    5be6:	0e 94 18 26 	call	0x4c30	; 0x4c30 <chb_reg_write16>
    pcb->src_addr = addr;
    5bea:	2d 81       	ldd	r18, Y+5	; 0x05
    5bec:	3e 81       	ldd	r19, Y+6	; 0x06
    5bee:	8b 81       	ldd	r24, Y+3	; 0x03
    5bf0:	9c 81       	ldd	r25, Y+4	; 0x04
    5bf2:	fc 01       	movw	r30, r24
    5bf4:	20 83       	st	Z, r18
    5bf6:	31 83       	std	Z+1, r19	; 0x01
}
    5bf8:	26 96       	adiw	r28, 0x06	; 6
    5bfa:	cd bf       	out	0x3d, r28	; 61
    5bfc:	de bf       	out	0x3e, r29	; 62
    5bfe:	df 91       	pop	r29
    5c00:	cf 91       	pop	r28
    5c02:	08 95       	ret

00005c04 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    5c04:	cf 93       	push	r28
    5c06:	df 93       	push	r29
    5c08:	0f 92       	push	r0
    5c0a:	0f 92       	push	r0
    5c0c:	cd b7       	in	r28, 0x3d	; 61
    5c0e:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    5c10:	89 e0       	ldi	r24, 0x09	; 9
    5c12:	90 e0       	ldi	r25, 0x00	; 0
    5c14:	9e 01       	movw	r18, r28
    5c16:	2f 5f       	subi	r18, 0xFF	; 255
    5c18:	3f 4f       	sbci	r19, 0xFF	; 255
    5c1a:	b9 01       	movw	r22, r18
    5c1c:	42 e0       	ldi	r20, 0x02	; 2
    5c1e:	50 e0       	ldi	r21, 0x00	; 0
    5c20:	0e 94 ff 31 	call	0x63fe	; 0x63fe <chb_eeprom_read>
    return *(U16 *)addr;
    5c24:	ce 01       	movw	r24, r28
    5c26:	01 96       	adiw	r24, 0x01	; 1
    5c28:	fc 01       	movw	r30, r24
    5c2a:	80 81       	ld	r24, Z
    5c2c:	91 81       	ldd	r25, Z+1	; 0x01
}
    5c2e:	0f 90       	pop	r0
    5c30:	0f 90       	pop	r0
    5c32:	df 91       	pop	r29
    5c34:	cf 91       	pop	r28
    5c36:	08 95       	ret

00005c38 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5c38:	cf 93       	push	r28
    5c3a:	df 93       	push	r29
    5c3c:	cd b7       	in	r28, 0x3d	; 61
    5c3e:	de b7       	in	r29, 0x3e	; 62
    5c40:	28 97       	sbiw	r28, 0x08	; 8
    5c42:	cd bf       	out	0x3d, r28	; 61
    5c44:	de bf       	out	0x3e, r29	; 62
    5c46:	8c 83       	std	Y+4, r24	; 0x04
    5c48:	9d 83       	std	Y+5, r25	; 0x05
    5c4a:	6e 83       	std	Y+6, r22	; 0x06
    5c4c:	7f 83       	std	Y+7, r23	; 0x07
    5c4e:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5c50:	0e 94 88 23 	call	0x4710	; 0x4710 <chb_get_state>
    5c54:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5c56:	0e 94 85 20 	call	0x410a	; 0x410a <chb_get_pcb>
    5c5a:	8a 83       	std	Y+2, r24	; 0x02
    5c5c:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5c5e:	89 81       	ldd	r24, Y+1	; 0x01
    5c60:	82 30       	cpi	r24, 0x02	; 2
    5c62:	19 f0       	breq	.+6      	; 0x5c6a <chb_tx+0x32>
    5c64:	89 81       	ldd	r24, Y+1	; 0x01
    5c66:	82 31       	cpi	r24, 0x12	; 18
    5c68:	11 f4       	brne	.+4      	; 0x5c6e <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5c6a:	84 e4       	ldi	r24, 0x44	; 68
    5c6c:	23 c0       	rjmp	.+70     	; 0x5cb4 <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5c6e:	88 e0       	ldi	r24, 0x08	; 8
    5c70:	0e 94 ef 28 	call	0x51de	; 0x51de <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    5c74:	89 e1       	ldi	r24, 0x19	; 25
    5c76:	0e 94 ef 28 	call	0x51de	; 0x51de <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5c7a:	8c 81       	ldd	r24, Y+4	; 0x04
    5c7c:	9d 81       	ldd	r25, Y+5	; 0x05
    5c7e:	2e 81       	ldd	r18, Y+6	; 0x06
    5c80:	3f 81       	ldd	r19, Y+7	; 0x07
    5c82:	6a e0       	ldi	r22, 0x0A	; 10
    5c84:	a9 01       	movw	r20, r18
    5c86:	28 85       	ldd	r18, Y+8	; 0x08
    5c88:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5c8c:	82 e0       	ldi	r24, 0x02	; 2
    5c8e:	62 e0       	ldi	r22, 0x02	; 2
    5c90:	4f e1       	ldi	r20, 0x1F	; 31
    5c92:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>

    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
    5c96:	00 00       	nop
    5c98:	8a 81       	ldd	r24, Y+2	; 0x02
    5c9a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c9c:	fc 01       	movw	r30, r24
    5c9e:	94 81       	ldd	r25, Z+4	; 0x04
    5ca0:	81 e0       	ldi	r24, 0x01	; 1
    5ca2:	89 27       	eor	r24, r25
    5ca4:	88 23       	and	r24, r24
    5ca6:	c1 f7       	brne	.-16     	; 0x5c98 <chb_tx+0x60>
    pcb->tx_end = false;
    5ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    5caa:	9b 81       	ldd	r25, Y+3	; 0x03
    5cac:	fc 01       	movw	r30, r24
    5cae:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5cb0:	0e 94 93 23 	call	0x4726	; 0x4726 <chb_get_status>
}
    5cb4:	28 96       	adiw	r28, 0x08	; 8
    5cb6:	cd bf       	out	0x3d, r28	; 61
    5cb8:	de bf       	out	0x3e, r29	; 62
    5cba:	df 91       	pop	r29
    5cbc:	cf 91       	pop	r28
    5cbe:	08 95       	ret

00005cc0 <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5cc0:	0f 93       	push	r16
    5cc2:	1f 93       	push	r17
    5cc4:	cf 93       	push	r28
    5cc6:	df 93       	push	r29
    5cc8:	cd b7       	in	r28, 0x3d	; 61
    5cca:	de b7       	in	r29, 0x3e	; 62
    5ccc:	69 97       	sbiw	r28, 0x19	; 25
    5cce:	cd bf       	out	0x3d, r28	; 61
    5cd0:	de bf       	out	0x3e, r29	; 62
    5cd2:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    5cd4:	89 8d       	ldd	r24, Y+25	; 0x19
    5cd6:	88 23       	and	r24, r24
    5cd8:	69 f0       	breq	.+26     	; 0x5cf4 <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5cda:	88 e0       	ldi	r24, 0x08	; 8
    5cdc:	0e 94 ef 28 	call	0x51de	; 0x51de <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5ce0:	84 e6       	ldi	r24, 0x64	; 100
    5ce2:	96 e0       	ldi	r25, 0x06	; 6
    5ce4:	24 e6       	ldi	r18, 0x64	; 100
    5ce6:	36 e0       	ldi	r19, 0x06	; 6
    5ce8:	f9 01       	movw	r30, r18
    5cea:	20 81       	ld	r18, Z
    5cec:	22 60       	ori	r18, 0x02	; 2
    5cee:	fc 01       	movw	r30, r24
    5cf0:	20 83       	st	Z, r18
    5cf2:	e1 c0       	rjmp	.+450    	; 0x5eb6 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    5cf4:	84 e6       	ldi	r24, 0x64	; 100
    5cf6:	96 e0       	ldi	r25, 0x06	; 6
    5cf8:	24 e6       	ldi	r18, 0x64	; 100
    5cfa:	36 e0       	ldi	r19, 0x06	; 6
    5cfc:	f9 01       	movw	r30, r18
    5cfe:	20 81       	ld	r18, Z
    5d00:	2d 7f       	andi	r18, 0xFD	; 253
    5d02:	fc 01       	movw	r30, r24
    5d04:	20 83       	st	Z, r18
    5d06:	80 e0       	ldi	r24, 0x00	; 0
    5d08:	90 e0       	ldi	r25, 0x00	; 0
    5d0a:	a0 e7       	ldi	r26, 0x70	; 112
    5d0c:	b3 e4       	ldi	r27, 0x43	; 67
    5d0e:	89 83       	std	Y+1, r24	; 0x01
    5d10:	9a 83       	std	Y+2, r25	; 0x02
    5d12:	ab 83       	std	Y+3, r26	; 0x03
    5d14:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5d16:	69 81       	ldd	r22, Y+1	; 0x01
    5d18:	7a 81       	ldd	r23, Y+2	; 0x02
    5d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    5d1e:	2b ea       	ldi	r18, 0xAB	; 171
    5d20:	3a ea       	ldi	r19, 0xAA	; 170
    5d22:	4a ea       	ldi	r20, 0xAA	; 170
    5d24:	5e e3       	ldi	r21, 0x3E	; 62
    5d26:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5d2a:	dc 01       	movw	r26, r24
    5d2c:	cb 01       	movw	r24, r22
    5d2e:	8d 83       	std	Y+5, r24	; 0x05
    5d30:	9e 83       	std	Y+6, r25	; 0x06
    5d32:	af 83       	std	Y+7, r26	; 0x07
    5d34:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5d36:	11 e0       	ldi	r17, 0x01	; 1
    5d38:	6d 81       	ldd	r22, Y+5	; 0x05
    5d3a:	7e 81       	ldd	r23, Y+6	; 0x06
    5d3c:	8f 81       	ldd	r24, Y+7	; 0x07
    5d3e:	98 85       	ldd	r25, Y+8	; 0x08
    5d40:	20 e0       	ldi	r18, 0x00	; 0
    5d42:	30 e0       	ldi	r19, 0x00	; 0
    5d44:	40 e8       	ldi	r20, 0x80	; 128
    5d46:	5f e3       	ldi	r21, 0x3F	; 63
    5d48:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    5d4c:	88 23       	and	r24, r24
    5d4e:	0c f0       	brlt	.+2      	; 0x5d52 <chb_sleep+0x92>
    5d50:	10 e0       	ldi	r17, 0x00	; 0
    5d52:	11 23       	and	r17, r17
    5d54:	19 f0       	breq	.+6      	; 0x5d5c <chb_sleep+0x9c>
		__ticks = 1;
    5d56:	81 e0       	ldi	r24, 0x01	; 1
    5d58:	89 87       	std	Y+9, r24	; 0x09
    5d5a:	a3 c0       	rjmp	.+326    	; 0x5ea2 <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5d5c:	11 e0       	ldi	r17, 0x01	; 1
    5d5e:	6d 81       	ldd	r22, Y+5	; 0x05
    5d60:	7e 81       	ldd	r23, Y+6	; 0x06
    5d62:	8f 81       	ldd	r24, Y+7	; 0x07
    5d64:	98 85       	ldd	r25, Y+8	; 0x08
    5d66:	20 e0       	ldi	r18, 0x00	; 0
    5d68:	30 e0       	ldi	r19, 0x00	; 0
    5d6a:	4f e7       	ldi	r20, 0x7F	; 127
    5d6c:	53 e4       	ldi	r21, 0x43	; 67
    5d6e:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    5d72:	18 16       	cp	r1, r24
    5d74:	0c f0       	brlt	.+2      	; 0x5d78 <chb_sleep+0xb8>
    5d76:	10 e0       	ldi	r17, 0x00	; 0
    5d78:	11 23       	and	r17, r17
    5d7a:	09 f4       	brne	.+2      	; 0x5d7e <chb_sleep+0xbe>
    5d7c:	89 c0       	rjmp	.+274    	; 0x5e90 <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5d7e:	69 81       	ldd	r22, Y+1	; 0x01
    5d80:	7a 81       	ldd	r23, Y+2	; 0x02
    5d82:	8b 81       	ldd	r24, Y+3	; 0x03
    5d84:	9c 81       	ldd	r25, Y+4	; 0x04
    5d86:	20 e0       	ldi	r18, 0x00	; 0
    5d88:	30 e0       	ldi	r19, 0x00	; 0
    5d8a:	4a e7       	ldi	r20, 0x7A	; 122
    5d8c:	54 e4       	ldi	r21, 0x44	; 68
    5d8e:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    5d92:	dc 01       	movw	r26, r24
    5d94:	cb 01       	movw	r24, r22
    5d96:	8a 87       	std	Y+10, r24	; 0x0a
    5d98:	9b 87       	std	Y+11, r25	; 0x0b
    5d9a:	ac 87       	std	Y+12, r26	; 0x0c
    5d9c:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5d9e:	6a 85       	ldd	r22, Y+10	; 0x0a
    5da0:	7b 85       	ldd	r23, Y+11	; 0x0b
    5da2:	8c 85       	ldd	r24, Y+12	; 0x0c
    5da4:	9d 85       	ldd	r25, Y+13	; 0x0d
    5da6:	20 e0       	ldi	r18, 0x00	; 0
    5da8:	30 e0       	ldi	r19, 0x00	; 0
    5daa:	4a e7       	ldi	r20, 0x7A	; 122
    5dac:	53 e4       	ldi	r21, 0x43	; 67
    5dae:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5db2:	dc 01       	movw	r26, r24
    5db4:	cb 01       	movw	r24, r22
    5db6:	8e 87       	std	Y+14, r24	; 0x0e
    5db8:	9f 87       	std	Y+15, r25	; 0x0f
    5dba:	a8 8b       	std	Y+16, r26	; 0x10
    5dbc:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5dbe:	11 e0       	ldi	r17, 0x01	; 1
    5dc0:	6e 85       	ldd	r22, Y+14	; 0x0e
    5dc2:	7f 85       	ldd	r23, Y+15	; 0x0f
    5dc4:	88 89       	ldd	r24, Y+16	; 0x10
    5dc6:	99 89       	ldd	r25, Y+17	; 0x11
    5dc8:	20 e0       	ldi	r18, 0x00	; 0
    5dca:	30 e0       	ldi	r19, 0x00	; 0
    5dcc:	40 e8       	ldi	r20, 0x80	; 128
    5dce:	5f e3       	ldi	r21, 0x3F	; 63
    5dd0:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    5dd4:	88 23       	and	r24, r24
    5dd6:	0c f0       	brlt	.+2      	; 0x5dda <chb_sleep+0x11a>
    5dd8:	10 e0       	ldi	r17, 0x00	; 0
    5dda:	11 23       	and	r17, r17
    5ddc:	29 f0       	breq	.+10     	; 0x5de8 <chb_sleep+0x128>
		__ticks = 1;
    5dde:	81 e0       	ldi	r24, 0x01	; 1
    5de0:	90 e0       	ldi	r25, 0x00	; 0
    5de2:	8a 8b       	std	Y+18, r24	; 0x12
    5de4:	9b 8b       	std	Y+19, r25	; 0x13
    5de6:	46 c0       	rjmp	.+140    	; 0x5e74 <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5de8:	11 e0       	ldi	r17, 0x01	; 1
    5dea:	6e 85       	ldd	r22, Y+14	; 0x0e
    5dec:	7f 85       	ldd	r23, Y+15	; 0x0f
    5dee:	88 89       	ldd	r24, Y+16	; 0x10
    5df0:	99 89       	ldd	r25, Y+17	; 0x11
    5df2:	20 e0       	ldi	r18, 0x00	; 0
    5df4:	3f ef       	ldi	r19, 0xFF	; 255
    5df6:	4f e7       	ldi	r20, 0x7F	; 127
    5df8:	57 e4       	ldi	r21, 0x47	; 71
    5dfa:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    5dfe:	18 16       	cp	r1, r24
    5e00:	0c f0       	brlt	.+2      	; 0x5e04 <chb_sleep+0x144>
    5e02:	10 e0       	ldi	r17, 0x00	; 0
    5e04:	11 23       	and	r17, r17
    5e06:	61 f1       	breq	.+88     	; 0x5e60 <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5e08:	6a 85       	ldd	r22, Y+10	; 0x0a
    5e0a:	7b 85       	ldd	r23, Y+11	; 0x0b
    5e0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    5e0e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5e10:	20 e0       	ldi	r18, 0x00	; 0
    5e12:	30 e0       	ldi	r19, 0x00	; 0
    5e14:	40 e2       	ldi	r20, 0x20	; 32
    5e16:	51 e4       	ldi	r21, 0x41	; 65
    5e18:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    5e1c:	dc 01       	movw	r26, r24
    5e1e:	cb 01       	movw	r24, r22
    5e20:	bc 01       	movw	r22, r24
    5e22:	cd 01       	movw	r24, r26
    5e24:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5e28:	dc 01       	movw	r26, r24
    5e2a:	cb 01       	movw	r24, r22
    5e2c:	8a 8b       	std	Y+18, r24	; 0x12
    5e2e:	9b 8b       	std	Y+19, r25	; 0x13
    5e30:	12 c0       	rjmp	.+36     	; 0x5e56 <chb_sleep+0x196>
    5e32:	89 e1       	ldi	r24, 0x19	; 25
    5e34:	90 e0       	ldi	r25, 0x00	; 0
    5e36:	8c 8b       	std	Y+20, r24	; 0x14
    5e38:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5e3a:	8c 89       	ldd	r24, Y+20	; 0x14
    5e3c:	9d 89       	ldd	r25, Y+21	; 0x15
    5e3e:	8c 01       	movw	r16, r24
    5e40:	c8 01       	movw	r24, r16
    5e42:	01 97       	sbiw	r24, 0x01	; 1
    5e44:	f1 f7       	brne	.-4      	; 0x5e42 <chb_sleep+0x182>
    5e46:	8c 01       	movw	r16, r24
    5e48:	0c 8b       	std	Y+20, r16	; 0x14
    5e4a:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5e4c:	8a 89       	ldd	r24, Y+18	; 0x12
    5e4e:	9b 89       	ldd	r25, Y+19	; 0x13
    5e50:	01 97       	sbiw	r24, 0x01	; 1
    5e52:	8a 8b       	std	Y+18, r24	; 0x12
    5e54:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5e56:	8a 89       	ldd	r24, Y+18	; 0x12
    5e58:	9b 89       	ldd	r25, Y+19	; 0x13
    5e5a:	00 97       	sbiw	r24, 0x00	; 0
    5e5c:	51 f7       	brne	.-44     	; 0x5e32 <chb_sleep+0x172>
    5e5e:	28 c0       	rjmp	.+80     	; 0x5eb0 <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5e60:	6e 85       	ldd	r22, Y+14	; 0x0e
    5e62:	7f 85       	ldd	r23, Y+15	; 0x0f
    5e64:	88 89       	ldd	r24, Y+16	; 0x10
    5e66:	99 89       	ldd	r25, Y+17	; 0x11
    5e68:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5e6c:	dc 01       	movw	r26, r24
    5e6e:	cb 01       	movw	r24, r22
    5e70:	8a 8b       	std	Y+18, r24	; 0x12
    5e72:	9b 8b       	std	Y+19, r25	; 0x13
    5e74:	8a 89       	ldd	r24, Y+18	; 0x12
    5e76:	9b 89       	ldd	r25, Y+19	; 0x13
    5e78:	8e 8b       	std	Y+22, r24	; 0x16
    5e7a:	9f 8b       	std	Y+23, r25	; 0x17
    5e7c:	8e 89       	ldd	r24, Y+22	; 0x16
    5e7e:	9f 89       	ldd	r25, Y+23	; 0x17
    5e80:	8c 01       	movw	r16, r24
    5e82:	f8 01       	movw	r30, r16
    5e84:	31 97       	sbiw	r30, 0x01	; 1
    5e86:	f1 f7       	brne	.-4      	; 0x5e84 <chb_sleep+0x1c4>
    5e88:	8f 01       	movw	r16, r30
    5e8a:	0e 8b       	std	Y+22, r16	; 0x16
    5e8c:	1f 8b       	std	Y+23, r17	; 0x17
    5e8e:	10 c0       	rjmp	.+32     	; 0x5eb0 <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5e90:	6d 81       	ldd	r22, Y+5	; 0x05
    5e92:	7e 81       	ldd	r23, Y+6	; 0x06
    5e94:	8f 81       	ldd	r24, Y+7	; 0x07
    5e96:	98 85       	ldd	r25, Y+8	; 0x08
    5e98:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    5e9c:	dc 01       	movw	r26, r24
    5e9e:	cb 01       	movw	r24, r22
    5ea0:	89 87       	std	Y+9, r24	; 0x09
    5ea2:	89 85       	ldd	r24, Y+9	; 0x09
    5ea4:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5ea6:	88 8d       	ldd	r24, Y+24	; 0x18
    5ea8:	18 2f       	mov	r17, r24
    5eaa:	1a 95       	dec	r17
    5eac:	f1 f7       	brne	.-4      	; 0x5eaa <chb_sleep+0x1ea>
    5eae:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5eb0:	86 e1       	ldi	r24, 0x16	; 22
    5eb2:	0e 94 ef 28 	call	0x51de	; 0x51de <chb_set_state>
    }
}
    5eb6:	69 96       	adiw	r28, 0x19	; 25
    5eb8:	cd bf       	out	0x3d, r28	; 61
    5eba:	de bf       	out	0x3e, r29	; 62
    5ebc:	df 91       	pop	r29
    5ebe:	cf 91       	pop	r28
    5ec0:	1f 91       	pop	r17
    5ec2:	0f 91       	pop	r16
    5ec4:	08 95       	ret

00005ec6 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5ec6:	cf 93       	push	r28
    5ec8:	df 93       	push	r29
    5eca:	cd b7       	in	r28, 0x3d	; 61
    5ecc:	de b7       	in	r29, 0x3e	; 62
    5ece:	ea 97       	sbiw	r28, 0x3a	; 58
    5ed0:	cd bf       	out	0x3d, r28	; 61
    5ed2:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5ed4:	0e 94 a0 23 	call	0x4740	; 0x4740 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5ed8:	8e e0       	ldi	r24, 0x0E	; 14
    5eda:	60 e0       	ldi	r22, 0x00	; 0
    5edc:	0e 94 ec 25 	call	0x4bd8	; 0x4bd8 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5ee0:	82 e0       	ldi	r24, 0x02	; 2
    5ee2:	63 e0       	ldi	r22, 0x03	; 3
    5ee4:	4f e1       	ldi	r20, 0x1F	; 31
    5ee6:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5eea:	00 00       	nop
    5eec:	81 e0       	ldi	r24, 0x01	; 1
    5eee:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    5ef2:	88 2f       	mov	r24, r24
    5ef4:	90 e0       	ldi	r25, 0x00	; 0
    5ef6:	8f 71       	andi	r24, 0x1F	; 31
    5ef8:	90 70       	andi	r25, 0x00	; 0
    5efa:	88 30       	cpi	r24, 0x08	; 8
    5efc:	91 05       	cpc	r25, r1
    5efe:	b1 f7       	brne	.-20     	; 0x5eec <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5f00:	8e e2       	ldi	r24, 0x2E	; 46
    5f02:	60 e4       	ldi	r22, 0x40	; 64
    5f04:	40 ec       	ldi	r20, 0xC0	; 192
    5f06:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5f0a:	8e e0       	ldi	r24, 0x0E	; 14
    5f0c:	6c e0       	ldi	r22, 0x0C	; 12
    5f0e:	0e 94 ec 25 	call	0x4bd8	; 0x4bd8 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5f12:	84 e0       	ldi	r24, 0x04	; 4
    5f14:	60 e2       	ldi	r22, 0x20	; 32
    5f16:	40 e2       	ldi	r20, 0x20	; 32
    5f18:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5f1c:	81 e0       	ldi	r24, 0x01	; 1
    5f1e:	0e 94 91 27 	call	0x4f22	; 0x4f22 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5f22:	81 e0       	ldi	r24, 0x01	; 1
    5f24:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5f28:	86 e1       	ldi	r24, 0x16	; 22
    5f2a:	0e 94 ef 28 	call	0x51de	; 0x51de <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5f2e:	82 e2       	ldi	r24, 0x22	; 34
    5f30:	64 e3       	ldi	r22, 0x34	; 52
    5f32:	72 e1       	ldi	r23, 0x12	; 18
    5f34:	0e 94 18 26 	call	0x4c30	; 0x4c30 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5f38:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <chb_get_short_addr>
    5f3c:	9c 01       	movw	r18, r24
    5f3e:	80 e2       	ldi	r24, 0x20	; 32
    5f40:	b9 01       	movw	r22, r18
    5f42:	0e 94 18 26 	call	0x4c30	; 0x4c30 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5f46:	ce 01       	movw	r24, r28
    5f48:	01 96       	adiw	r24, 0x01	; 1
    5f4a:	0e 94 c0 2d 	call	0x5b80	; 0x5b80 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5f4e:	84 e2       	ldi	r24, 0x24	; 36
    5f50:	9e 01       	movw	r18, r28
    5f52:	2f 5f       	subi	r18, 0xFF	; 255
    5f54:	3f 4f       	sbci	r19, 0xFF	; 255
    5f56:	b9 01       	movw	r22, r18
    5f58:	0e 94 49 26 	call	0x4c92	; 0x4c92 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5f5c:	82 e7       	ldi	r24, 0x72	; 114
    5f5e:	96 e0       	ldi	r25, 0x06	; 6
    5f60:	22 e7       	ldi	r18, 0x72	; 114
    5f62:	36 e0       	ldi	r19, 0x06	; 6
    5f64:	f9 01       	movw	r30, r18
    5f66:	20 81       	ld	r18, Z
    5f68:	21 60       	ori	r18, 0x01	; 1
    5f6a:	fc 01       	movw	r30, r24
    5f6c:	20 83       	st	Z, r18
    5f6e:	89 e6       	ldi	r24, 0x69	; 105
    5f70:	96 e0       	ldi	r25, 0x06	; 6
    5f72:	29 e6       	ldi	r18, 0x69	; 105
    5f74:	36 e0       	ldi	r19, 0x06	; 6
    5f76:	f9 01       	movw	r30, r18
    5f78:	20 81       	ld	r18, Z
    5f7a:	22 60       	ori	r18, 0x02	; 2
    5f7c:	fc 01       	movw	r30, r24
    5f7e:	20 83       	st	Z, r18
    5f80:	8a e6       	ldi	r24, 0x6A	; 106
    5f82:	96 e0       	ldi	r25, 0x06	; 6
    5f84:	2a e6       	ldi	r18, 0x6A	; 106
    5f86:	36 e0       	ldi	r19, 0x06	; 6
    5f88:	f9 01       	movw	r30, r18
    5f8a:	20 81       	ld	r18, Z
    5f8c:	24 60       	ori	r18, 0x04	; 4
    5f8e:	fc 01       	movw	r30, r24
    5f90:	20 83       	st	Z, r18
	PMIC.CTRL = 0x07;	//enable interrupts on MCU
    5f92:	80 ea       	ldi	r24, 0xA0	; 160
    5f94:	90 e0       	ldi	r25, 0x00	; 0
    5f96:	27 e0       	ldi	r18, 0x07	; 7
    5f98:	fc 01       	movw	r30, r24
    5f9a:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5f9c:	0e 94 88 23 	call	0x4710	; 0x4710 <chb_get_state>
    5fa0:	86 31       	cpi	r24, 0x16	; 22
    5fa2:	b1 f0       	breq	.+44     	; 0x5fd0 <chb_radio_init+0x10a>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5fa4:	ce 01       	movw	r24, r28
    5fa6:	09 96       	adiw	r24, 0x09	; 9
    5fa8:	2c e0       	ldi	r18, 0x0C	; 12
    5faa:	32 e0       	ldi	r19, 0x02	; 2
    5fac:	b9 01       	movw	r22, r18
    5fae:	0e 94 7d 5f 	call	0xbefa	; 0xbefa <strcpy_P>
        printf(buf);
    5fb2:	0f 92       	push	r0
    5fb4:	0f 92       	push	r0
    5fb6:	8d b7       	in	r24, 0x3d	; 61
    5fb8:	9e b7       	in	r25, 0x3e	; 62
    5fba:	01 96       	adiw	r24, 0x01	; 1
    5fbc:	9e 01       	movw	r18, r28
    5fbe:	27 5f       	subi	r18, 0xF7	; 247
    5fc0:	3f 4f       	sbci	r19, 0xFF	; 255
    5fc2:	fc 01       	movw	r30, r24
    5fc4:	20 83       	st	Z, r18
    5fc6:	31 83       	std	Z+1, r19	; 0x01
    5fc8:	0e 94 e0 5f 	call	0xbfc0	; 0xbfc0 <printf>
    5fcc:	0f 90       	pop	r0
    5fce:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5fd0:	10 92 ca 50 	sts	0x50CA, r1
    5fd4:	10 92 cb 50 	sts	0x50CB, r1
    5fd8:	10 92 cc 50 	sts	0x50CC, r1
    5fdc:	10 92 cd 50 	sts	0x50CD, r1
}
    5fe0:	ea 96       	adiw	r28, 0x3a	; 58
    5fe2:	cd bf       	out	0x3d, r28	; 61
    5fe4:	de bf       	out	0x3e, r29	; 62
    5fe6:	df 91       	pop	r29
    5fe8:	cf 91       	pop	r28
    5fea:	08 95       	ret

00005fec <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5fec:	cf 93       	push	r28
    5fee:	df 93       	push	r29
    5ff0:	cd b7       	in	r28, 0x3d	; 61
    5ff2:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5ff4:	0e 94 3f 32 	call	0x647e	; 0x647e <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5ff8:	80 e6       	ldi	r24, 0x60	; 96
    5ffa:	96 e0       	ldi	r25, 0x06	; 6
    5ffc:	20 e6       	ldi	r18, 0x60	; 96
    5ffe:	36 e0       	ldi	r19, 0x06	; 6
    6000:	f9 01       	movw	r30, r18
    6002:	20 81       	ld	r18, Z
    6004:	22 60       	ori	r18, 0x02	; 2
    6006:	fc 01       	movw	r30, r24
    6008:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    600a:	80 e6       	ldi	r24, 0x60	; 96
    600c:	96 e0       	ldi	r25, 0x06	; 6
    600e:	20 e6       	ldi	r18, 0x60	; 96
    6010:	36 e0       	ldi	r19, 0x06	; 6
    6012:	f9 01       	movw	r30, r18
    6014:	20 81       	ld	r18, Z
    6016:	21 60       	ori	r18, 0x01	; 1
    6018:	fc 01       	movw	r30, r24
    601a:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    601c:	0e 94 63 2f 	call	0x5ec6	; 0x5ec6 <chb_radio_init>
}
    6020:	df 91       	pop	r29
    6022:	cf 91       	pop	r28
    6024:	08 95       	ret

00006026 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    6026:	1f 92       	push	r1
    6028:	0f 92       	push	r0
    602a:	0f b6       	in	r0, 0x3f	; 63
    602c:	0f 92       	push	r0
    602e:	00 90 3b 00 	lds	r0, 0x003B
    6032:	0f 92       	push	r0
    6034:	11 24       	eor	r1, r1
    6036:	2f 93       	push	r18
    6038:	3f 93       	push	r19
    603a:	4f 93       	push	r20
    603c:	5f 93       	push	r21
    603e:	6f 93       	push	r22
    6040:	7f 93       	push	r23
    6042:	8f 93       	push	r24
    6044:	9f 93       	push	r25
    6046:	af 93       	push	r26
    6048:	bf 93       	push	r27
    604a:	ef 93       	push	r30
    604c:	ff 93       	push	r31
    604e:	cf 93       	push	r28
    6050:	df 93       	push	r29
    6052:	cd b7       	in	r28, 0x3d	; 61
    6054:	de b7       	in	r29, 0x3e	; 62
    6056:	25 97       	sbiw	r28, 0x05	; 5
    6058:	cd bf       	out	0x3d, r28	; 61
    605a:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    605c:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    605e:	0e 94 85 20 	call	0x410a	; 0x410a <chb_get_pcb>
    6062:	8a 83       	std	Y+2, r24	; 0x02
    6064:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    6066:	8f e3       	ldi	r24, 0x3F	; 63
    6068:	90 e0       	ldi	r25, 0x00	; 0
    606a:	fc 01       	movw	r30, r24
    606c:	80 81       	ld	r24, Z
    606e:	80 93 45 40 	sts	0x4045, r24
    6072:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    6074:	81 e0       	ldi	r24, 0x01	; 1
    6076:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    607a:	8f e8       	ldi	r24, 0x8F	; 143
    607c:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    6080:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    6082:	80 e0       	ldi	r24, 0x00	; 0
    6084:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <SPID_write>
    6088:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    608a:	80 e0       	ldi	r24, 0x00	; 0
    608c:	0e 94 0d 31 	call	0x621a	; 0x621a <RadioCS>

    while (intp_src)
    6090:	9d c0       	rjmp	.+314    	; 0x61cc <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    6092:	89 81       	ldd	r24, Y+1	; 0x01
    6094:	88 2f       	mov	r24, r24
    6096:	90 e0       	ldi	r25, 0x00	; 0
    6098:	84 70       	andi	r24, 0x04	; 4
    609a:	90 70       	andi	r25, 0x00	; 0
    609c:	00 97       	sbiw	r24, 0x00	; 0
    609e:	21 f0       	breq	.+8      	; 0x60a8 <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    60a0:	89 81       	ldd	r24, Y+1	; 0x01
    60a2:	8b 7f       	andi	r24, 0xFB	; 251
    60a4:	89 83       	std	Y+1, r24	; 0x01
    60a6:	92 c0       	rjmp	.+292    	; 0x61cc <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    60a8:	89 81       	ldd	r24, Y+1	; 0x01
    60aa:	88 2f       	mov	r24, r24
    60ac:	90 e0       	ldi	r25, 0x00	; 0
    60ae:	88 70       	andi	r24, 0x08	; 8
    60b0:	90 70       	andi	r25, 0x00	; 0
    60b2:	00 97       	sbiw	r24, 0x00	; 0
    60b4:	09 f4       	brne	.+2      	; 0x60b8 <__vector_64+0x92>
    60b6:	4c c0       	rjmp	.+152    	; 0x6150 <__vector_64+0x12a>
        {
            state = chb_get_state();
    60b8:	0e 94 88 23 	call	0x4710	; 0x4710 <chb_get_state>
    60bc:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    60be:	8d 81       	ldd	r24, Y+5	; 0x05
    60c0:	86 30       	cpi	r24, 0x06	; 6
    60c2:	31 f0       	breq	.+12     	; 0x60d0 <__vector_64+0xaa>
    60c4:	8d 81       	ldd	r24, Y+5	; 0x05
    60c6:	86 31       	cpi	r24, 0x16	; 22
    60c8:	19 f0       	breq	.+6      	; 0x60d0 <__vector_64+0xaa>
    60ca:	8d 81       	ldd	r24, Y+5	; 0x05
    60cc:	81 31       	cpi	r24, 0x11	; 17
    60ce:	89 f5       	brne	.+98     	; 0x6132 <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    60d0:	88 e0       	ldi	r24, 0x08	; 8
    60d2:	0e 94 ef 28 	call	0x51de	; 0x51de <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    60d6:	87 e0       	ldi	r24, 0x07	; 7
    60d8:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    60dc:	28 2f       	mov	r18, r24
    60de:	8a 81       	ldd	r24, Y+2	; 0x02
    60e0:	9b 81       	ldd	r25, Y+3	; 0x03
    60e2:	fc 01       	movw	r30, r24
    60e4:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    60e6:	86 e0       	ldi	r24, 0x06	; 6
    60e8:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
    60ec:	28 2f       	mov	r18, r24
    60ee:	22 1f       	adc	r18, r18
    60f0:	22 27       	eor	r18, r18
    60f2:	22 1f       	adc	r18, r18
    60f4:	8a 81       	ldd	r24, Y+2	; 0x02
    60f6:	9b 81       	ldd	r25, Y+3	; 0x03
    60f8:	fc 01       	movw	r30, r24
    60fa:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    60fc:	8a 81       	ldd	r24, Y+2	; 0x02
    60fe:	9b 81       	ldd	r25, Y+3	; 0x03
    6100:	fc 01       	movw	r30, r24
    6102:	83 89       	ldd	r24, Z+19	; 0x13
    6104:	88 23       	and	r24, r24
    6106:	d1 f0       	breq	.+52     	; 0x613c <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    6108:	0e 94 fb 26 	call	0x4df6	; 0x4df6 <chb_frame_read>
                    pcb->rcvd_xfers++;
    610c:	8a 81       	ldd	r24, Y+2	; 0x02
    610e:	9b 81       	ldd	r25, Y+3	; 0x03
    6110:	fc 01       	movw	r30, r24
    6112:	85 81       	ldd	r24, Z+5	; 0x05
    6114:	96 81       	ldd	r25, Z+6	; 0x06
    6116:	9c 01       	movw	r18, r24
    6118:	2f 5f       	subi	r18, 0xFF	; 255
    611a:	3f 4f       	sbci	r19, 0xFF	; 255
    611c:	8a 81       	ldd	r24, Y+2	; 0x02
    611e:	9b 81       	ldd	r25, Y+3	; 0x03
    6120:	fc 01       	movw	r30, r24
    6122:	25 83       	std	Z+5, r18	; 0x05
    6124:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    6126:	8a 81       	ldd	r24, Y+2	; 0x02
    6128:	9b 81       	ldd	r25, Y+3	; 0x03
    612a:	21 e0       	ldi	r18, 0x01	; 1
    612c:	fc 01       	movw	r30, r24
    612e:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    6130:	05 c0       	rjmp	.+10     	; 0x613c <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    6132:	8a 81       	ldd	r24, Y+2	; 0x02
    6134:	9b 81       	ldd	r25, Y+3	; 0x03
    6136:	21 e0       	ldi	r18, 0x01	; 1
    6138:	fc 01       	movw	r30, r24
    613a:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    613c:	89 81       	ldd	r24, Y+1	; 0x01
    613e:	87 7f       	andi	r24, 0xF7	; 247
    6140:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    6142:	00 00       	nop
    6144:	86 e1       	ldi	r24, 0x16	; 22
    6146:	0e 94 ef 28 	call	0x51de	; 0x51de <chb_set_state>
    614a:	80 34       	cpi	r24, 0x40	; 64
    614c:	d9 f7       	brne	.-10     	; 0x6144 <__vector_64+0x11e>
    614e:	3e c0       	rjmp	.+124    	; 0x61cc <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    6150:	89 81       	ldd	r24, Y+1	; 0x01
    6152:	88 2f       	mov	r24, r24
    6154:	90 e0       	ldi	r25, 0x00	; 0
    6156:	80 74       	andi	r24, 0x40	; 64
    6158:	90 70       	andi	r25, 0x00	; 0
    615a:	00 97       	sbiw	r24, 0x00	; 0
    615c:	89 f0       	breq	.+34     	; 0x6180 <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    615e:	89 81       	ldd	r24, Y+1	; 0x01
    6160:	8f 7b       	andi	r24, 0xBF	; 191
    6162:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    6164:	8a 81       	ldd	r24, Y+2	; 0x02
    6166:	9b 81       	ldd	r25, Y+3	; 0x03
    6168:	fc 01       	movw	r30, r24
    616a:	87 85       	ldd	r24, Z+15	; 0x0f
    616c:	90 89       	ldd	r25, Z+16	; 0x10
    616e:	9c 01       	movw	r18, r24
    6170:	2f 5f       	subi	r18, 0xFF	; 255
    6172:	3f 4f       	sbci	r19, 0xFF	; 255
    6174:	8a 81       	ldd	r24, Y+2	; 0x02
    6176:	9b 81       	ldd	r25, Y+3	; 0x03
    6178:	fc 01       	movw	r30, r24
    617a:	27 87       	std	Z+15, r18	; 0x0f
    617c:	30 8b       	std	Z+16, r19	; 0x10
    617e:	26 c0       	rjmp	.+76     	; 0x61cc <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    6180:	89 81       	ldd	r24, Y+1	; 0x01
    6182:	88 2f       	mov	r24, r24
    6184:	90 e0       	ldi	r25, 0x00	; 0
    6186:	82 70       	andi	r24, 0x02	; 2
    6188:	90 70       	andi	r25, 0x00	; 0
    618a:	00 97       	sbiw	r24, 0x00	; 0
    618c:	21 f0       	breq	.+8      	; 0x6196 <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    618e:	89 81       	ldd	r24, Y+1	; 0x01
    6190:	8d 7f       	andi	r24, 0xFD	; 253
    6192:	89 83       	std	Y+1, r24	; 0x01
    6194:	1b c0       	rjmp	.+54     	; 0x61cc <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    6196:	89 81       	ldd	r24, Y+1	; 0x01
    6198:	88 2f       	mov	r24, r24
    619a:	90 e0       	ldi	r25, 0x00	; 0
    619c:	81 70       	andi	r24, 0x01	; 1
    619e:	90 70       	andi	r25, 0x00	; 0
    61a0:	88 23       	and	r24, r24
    61a2:	21 f0       	breq	.+8      	; 0x61ac <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    61a4:	89 81       	ldd	r24, Y+1	; 0x01
    61a6:	8e 7f       	andi	r24, 0xFE	; 254
    61a8:	89 83       	std	Y+1, r24	; 0x01
    61aa:	10 c0       	rjmp	.+32     	; 0x61cc <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    61ac:	89 81       	ldd	r24, Y+1	; 0x01
    61ae:	88 23       	and	r24, r24
    61b0:	6c f4       	brge	.+26     	; 0x61cc <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    61b2:	89 81       	ldd	r24, Y+1	; 0x01
    61b4:	8f 77       	andi	r24, 0x7F	; 127
    61b6:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    61b8:	8a 81       	ldd	r24, Y+2	; 0x02
    61ba:	9b 81       	ldd	r25, Y+3	; 0x03
    61bc:	fc 01       	movw	r30, r24
    61be:	81 89       	ldd	r24, Z+17	; 0x11
    61c0:	28 2f       	mov	r18, r24
    61c2:	2f 5f       	subi	r18, 0xFF	; 255
    61c4:	8a 81       	ldd	r24, Y+2	; 0x02
    61c6:	9b 81       	ldd	r25, Y+3	; 0x03
    61c8:	fc 01       	movw	r30, r24
    61ca:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    61cc:	89 81       	ldd	r24, Y+1	; 0x01
    61ce:	88 23       	and	r24, r24
    61d0:	09 f0       	breq	.+2      	; 0x61d4 <__vector_64+0x1ae>
    61d2:	5f cf       	rjmp	.-322    	; 0x6092 <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    61d4:	8f e3       	ldi	r24, 0x3F	; 63
    61d6:	90 e0       	ldi	r25, 0x00	; 0
    61d8:	20 91 45 40 	lds	r18, 0x4045
    61dc:	fc 01       	movw	r30, r24
    61de:	20 83       	st	Z, r18
    61e0:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    61e2:	8f e0       	ldi	r24, 0x0F	; 15
    61e4:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <chb_reg_read>
}
    61e8:	25 96       	adiw	r28, 0x05	; 5
    61ea:	cd bf       	out	0x3d, r28	; 61
    61ec:	de bf       	out	0x3e, r29	; 62
    61ee:	df 91       	pop	r29
    61f0:	cf 91       	pop	r28
    61f2:	ff 91       	pop	r31
    61f4:	ef 91       	pop	r30
    61f6:	bf 91       	pop	r27
    61f8:	af 91       	pop	r26
    61fa:	9f 91       	pop	r25
    61fc:	8f 91       	pop	r24
    61fe:	7f 91       	pop	r23
    6200:	6f 91       	pop	r22
    6202:	5f 91       	pop	r21
    6204:	4f 91       	pop	r20
    6206:	3f 91       	pop	r19
    6208:	2f 91       	pop	r18
    620a:	0f 90       	pop	r0
    620c:	00 92 3b 00 	sts	0x003B, r0
    6210:	0f 90       	pop	r0
    6212:	0f be       	out	0x3f, r0	; 63
    6214:	0f 90       	pop	r0
    6216:	1f 90       	pop	r1
    6218:	18 95       	reti

0000621a <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    621a:	cf 93       	push	r28
    621c:	df 93       	push	r29
    621e:	0f 92       	push	r0
    6220:	cd b7       	in	r28, 0x3d	; 61
    6222:	de b7       	in	r29, 0x3e	; 62
    6224:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    6226:	89 81       	ldd	r24, Y+1	; 0x01
    6228:	88 23       	and	r24, r24
    622a:	31 f0       	breq	.+12     	; 0x6238 <RadioCS+0x1e>
    622c:	80 e6       	ldi	r24, 0x60	; 96
    622e:	96 e0       	ldi	r25, 0x06	; 6
    6230:	20 e1       	ldi	r18, 0x10	; 16
    6232:	fc 01       	movw	r30, r24
    6234:	26 83       	std	Z+6, r18	; 0x06
    6236:	05 c0       	rjmp	.+10     	; 0x6242 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    6238:	80 e6       	ldi	r24, 0x60	; 96
    623a:	96 e0       	ldi	r25, 0x06	; 6
    623c:	20 e1       	ldi	r18, 0x10	; 16
    623e:	fc 01       	movw	r30, r24
    6240:	25 83       	std	Z+5, r18	; 0x05
	}
    6242:	0f 90       	pop	r0
    6244:	df 91       	pop	r29
    6246:	cf 91       	pop	r28
    6248:	08 95       	ret

0000624a <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    624a:	cf 93       	push	r28
    624c:	df 93       	push	r29
    624e:	00 d0       	rcall	.+0      	; 0x6250 <chb_eep_write_byte+0x6>
    6250:	cd b7       	in	r28, 0x3d	; 61
    6252:	de b7       	in	r29, 0x3e	; 62
    6254:	89 83       	std	Y+1, r24	; 0x01
    6256:	9a 83       	std	Y+2, r25	; 0x02
    6258:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    625a:	00 00       	nop
    625c:	80 ec       	ldi	r24, 0xC0	; 192
    625e:	91 e0       	ldi	r25, 0x01	; 1
    6260:	fc 01       	movw	r30, r24
    6262:	87 85       	ldd	r24, Z+15	; 0x0f
    6264:	88 23       	and	r24, r24
    6266:	d4 f3       	brlt	.-12     	; 0x625c <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    6268:	80 ec       	ldi	r24, 0xC0	; 192
    626a:	91 e0       	ldi	r25, 0x01	; 1
    626c:	fc 01       	movw	r30, r24
    626e:	87 85       	ldd	r24, Z+15	; 0x0f
    6270:	88 2f       	mov	r24, r24
    6272:	90 e0       	ldi	r25, 0x00	; 0
    6274:	82 70       	andi	r24, 0x02	; 2
    6276:	90 70       	andi	r25, 0x00	; 0
    6278:	00 97       	sbiw	r24, 0x00	; 0
    627a:	99 f0       	breq	.+38     	; 0x62a2 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    627c:	80 ec       	ldi	r24, 0xC0	; 192
    627e:	91 e0       	ldi	r25, 0x01	; 1
    6280:	26 e3       	ldi	r18, 0x36	; 54
    6282:	fc 01       	movw	r30, r24
    6284:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    6286:	ef 93       	push	r30
    6288:	ff 93       	push	r31
    628a:	0f 93       	push	r16
    628c:	2f 93       	push	r18
    628e:	eb ec       	ldi	r30, 0xCB	; 203
    6290:	f1 e0       	ldi	r31, 0x01	; 1
    6292:	08 ed       	ldi	r16, 0xD8	; 216
    6294:	21 e0       	ldi	r18, 0x01	; 1
    6296:	04 bf       	out	0x34, r16	; 52
    6298:	20 83       	st	Z, r18
    629a:	2f 91       	pop	r18
    629c:	0f 91       	pop	r16
    629e:	ff 91       	pop	r31
    62a0:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    62a2:	80 ec       	ldi	r24, 0xC0	; 192
    62a4:	91 e0       	ldi	r25, 0x01	; 1
    62a6:	23 e3       	ldi	r18, 0x33	; 51
    62a8:	fc 01       	movw	r30, r24
    62aa:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    62ac:	80 ec       	ldi	r24, 0xC0	; 192
    62ae:	91 e0       	ldi	r25, 0x01	; 1
    62b0:	29 81       	ldd	r18, Y+1	; 0x01
    62b2:	fc 01       	movw	r30, r24
    62b4:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    62b6:	80 ec       	ldi	r24, 0xC0	; 192
    62b8:	91 e0       	ldi	r25, 0x01	; 1
    62ba:	29 81       	ldd	r18, Y+1	; 0x01
    62bc:	3a 81       	ldd	r19, Y+2	; 0x02
    62be:	23 2f       	mov	r18, r19
    62c0:	33 27       	eor	r19, r19
    62c2:	2f 71       	andi	r18, 0x1F	; 31
    62c4:	fc 01       	movw	r30, r24
    62c6:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    62c8:	80 ec       	ldi	r24, 0xC0	; 192
    62ca:	91 e0       	ldi	r25, 0x01	; 1
    62cc:	fc 01       	movw	r30, r24
    62ce:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    62d0:	80 ec       	ldi	r24, 0xC0	; 192
    62d2:	91 e0       	ldi	r25, 0x01	; 1
    62d4:	2b 81       	ldd	r18, Y+3	; 0x03
    62d6:	fc 01       	movw	r30, r24
    62d8:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    62da:	80 ec       	ldi	r24, 0xC0	; 192
    62dc:	91 e0       	ldi	r25, 0x01	; 1
    62de:	25 e3       	ldi	r18, 0x35	; 53
    62e0:	fc 01       	movw	r30, r24
    62e2:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    62e4:	ef 93       	push	r30
    62e6:	ff 93       	push	r31
    62e8:	0f 93       	push	r16
    62ea:	2f 93       	push	r18
    62ec:	eb ec       	ldi	r30, 0xCB	; 203
    62ee:	f1 e0       	ldi	r31, 0x01	; 1
    62f0:	08 ed       	ldi	r16, 0xD8	; 216
    62f2:	21 e0       	ldi	r18, 0x01	; 1
    62f4:	04 bf       	out	0x34, r16	; 52
    62f6:	20 83       	st	Z, r18
    62f8:	2f 91       	pop	r18
    62fa:	0f 91       	pop	r16
    62fc:	ff 91       	pop	r31
    62fe:	ef 91       	pop	r30
}
    6300:	23 96       	adiw	r28, 0x03	; 3
    6302:	cd bf       	out	0x3d, r28	; 61
    6304:	de bf       	out	0x3e, r29	; 62
    6306:	df 91       	pop	r29
    6308:	cf 91       	pop	r28
    630a:	08 95       	ret

0000630c <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    630c:	cf 93       	push	r28
    630e:	df 93       	push	r29
    6310:	0f 92       	push	r0
    6312:	0f 92       	push	r0
    6314:	cd b7       	in	r28, 0x3d	; 61
    6316:	de b7       	in	r29, 0x3e	; 62
    6318:	89 83       	std	Y+1, r24	; 0x01
    631a:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    631c:	00 00       	nop
    631e:	80 ec       	ldi	r24, 0xC0	; 192
    6320:	91 e0       	ldi	r25, 0x01	; 1
    6322:	fc 01       	movw	r30, r24
    6324:	87 85       	ldd	r24, Z+15	; 0x0f
    6326:	88 23       	and	r24, r24
    6328:	d4 f3       	brlt	.-12     	; 0x631e <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    632a:	80 ec       	ldi	r24, 0xC0	; 192
    632c:	91 e0       	ldi	r25, 0x01	; 1
    632e:	29 81       	ldd	r18, Y+1	; 0x01
    6330:	fc 01       	movw	r30, r24
    6332:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    6334:	80 ec       	ldi	r24, 0xC0	; 192
    6336:	91 e0       	ldi	r25, 0x01	; 1
    6338:	29 81       	ldd	r18, Y+1	; 0x01
    633a:	3a 81       	ldd	r19, Y+2	; 0x02
    633c:	23 2f       	mov	r18, r19
    633e:	33 27       	eor	r19, r19
    6340:	2f 71       	andi	r18, 0x1F	; 31
    6342:	fc 01       	movw	r30, r24
    6344:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    6346:	80 ec       	ldi	r24, 0xC0	; 192
    6348:	91 e0       	ldi	r25, 0x01	; 1
    634a:	fc 01       	movw	r30, r24
    634c:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    634e:	80 ec       	ldi	r24, 0xC0	; 192
    6350:	91 e0       	ldi	r25, 0x01	; 1
    6352:	26 e0       	ldi	r18, 0x06	; 6
    6354:	fc 01       	movw	r30, r24
    6356:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    6358:	ef 93       	push	r30
    635a:	ff 93       	push	r31
    635c:	0f 93       	push	r16
    635e:	2f 93       	push	r18
    6360:	eb ec       	ldi	r30, 0xCB	; 203
    6362:	f1 e0       	ldi	r31, 0x01	; 1
    6364:	08 ed       	ldi	r16, 0xD8	; 216
    6366:	21 e0       	ldi	r18, 0x01	; 1
    6368:	04 bf       	out	0x34, r16	; 52
    636a:	20 83       	st	Z, r18
    636c:	2f 91       	pop	r18
    636e:	0f 91       	pop	r16
    6370:	ff 91       	pop	r31
    6372:	ef 91       	pop	r30

    return NVM.DATA0;
    6374:	80 ec       	ldi	r24, 0xC0	; 192
    6376:	91 e0       	ldi	r25, 0x01	; 1
    6378:	fc 01       	movw	r30, r24
    637a:	84 81       	ldd	r24, Z+4	; 0x04
}
    637c:	0f 90       	pop	r0
    637e:	0f 90       	pop	r0
    6380:	df 91       	pop	r29
    6382:	cf 91       	pop	r28
    6384:	08 95       	ret

00006386 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    6386:	cf 93       	push	r28
    6388:	df 93       	push	r29
    638a:	cd b7       	in	r28, 0x3d	; 61
    638c:	de b7       	in	r29, 0x3e	; 62
    638e:	27 97       	sbiw	r28, 0x07	; 7
    6390:	cd bf       	out	0x3d, r28	; 61
    6392:	de bf       	out	0x3e, r29	; 62
    6394:	8a 83       	std	Y+2, r24	; 0x02
    6396:	9b 83       	std	Y+3, r25	; 0x03
    6398:	6c 83       	std	Y+4, r22	; 0x04
    639a:	7d 83       	std	Y+5, r23	; 0x05
    639c:	4e 83       	std	Y+6, r20	; 0x06
    639e:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    63a0:	80 ec       	ldi	r24, 0xC0	; 192
    63a2:	91 e0       	ldi	r25, 0x01	; 1
    63a4:	20 ec       	ldi	r18, 0xC0	; 192
    63a6:	31 e0       	ldi	r19, 0x01	; 1
    63a8:	f9 01       	movw	r30, r18
    63aa:	24 85       	ldd	r18, Z+12	; 0x0c
    63ac:	27 7f       	andi	r18, 0xF7	; 247
    63ae:	fc 01       	movw	r30, r24
    63b0:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    63b2:	19 82       	std	Y+1, r1	; 0x01
    63b4:	16 c0       	rjmp	.+44     	; 0x63e2 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    63b6:	89 81       	ldd	r24, Y+1	; 0x01
    63b8:	28 2f       	mov	r18, r24
    63ba:	30 e0       	ldi	r19, 0x00	; 0
    63bc:	8a 81       	ldd	r24, Y+2	; 0x02
    63be:	9b 81       	ldd	r25, Y+3	; 0x03
    63c0:	82 0f       	add	r24, r18
    63c2:	93 1f       	adc	r25, r19
    63c4:	29 81       	ldd	r18, Y+1	; 0x01
    63c6:	22 2f       	mov	r18, r18
    63c8:	30 e0       	ldi	r19, 0x00	; 0
    63ca:	4c 81       	ldd	r20, Y+4	; 0x04
    63cc:	5d 81       	ldd	r21, Y+5	; 0x05
    63ce:	24 0f       	add	r18, r20
    63d0:	35 1f       	adc	r19, r21
    63d2:	f9 01       	movw	r30, r18
    63d4:	20 81       	ld	r18, Z
    63d6:	62 2f       	mov	r22, r18
    63d8:	0e 94 25 31 	call	0x624a	; 0x624a <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    63dc:	89 81       	ldd	r24, Y+1	; 0x01
    63de:	8f 5f       	subi	r24, 0xFF	; 255
    63e0:	89 83       	std	Y+1, r24	; 0x01
    63e2:	89 81       	ldd	r24, Y+1	; 0x01
    63e4:	28 2f       	mov	r18, r24
    63e6:	30 e0       	ldi	r19, 0x00	; 0
    63e8:	8e 81       	ldd	r24, Y+6	; 0x06
    63ea:	9f 81       	ldd	r25, Y+7	; 0x07
    63ec:	28 17       	cp	r18, r24
    63ee:	39 07       	cpc	r19, r25
    63f0:	10 f3       	brcs	.-60     	; 0x63b6 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    63f2:	27 96       	adiw	r28, 0x07	; 7
    63f4:	cd bf       	out	0x3d, r28	; 61
    63f6:	de bf       	out	0x3e, r29	; 62
    63f8:	df 91       	pop	r29
    63fa:	cf 91       	pop	r28
    63fc:	08 95       	ret

000063fe <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    63fe:	0f 93       	push	r16
    6400:	1f 93       	push	r17
    6402:	cf 93       	push	r28
    6404:	df 93       	push	r29
    6406:	cd b7       	in	r28, 0x3d	; 61
    6408:	de b7       	in	r29, 0x3e	; 62
    640a:	27 97       	sbiw	r28, 0x07	; 7
    640c:	cd bf       	out	0x3d, r28	; 61
    640e:	de bf       	out	0x3e, r29	; 62
    6410:	8a 83       	std	Y+2, r24	; 0x02
    6412:	9b 83       	std	Y+3, r25	; 0x03
    6414:	6c 83       	std	Y+4, r22	; 0x04
    6416:	7d 83       	std	Y+5, r23	; 0x05
    6418:	4e 83       	std	Y+6, r20	; 0x06
    641a:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    641c:	80 ec       	ldi	r24, 0xC0	; 192
    641e:	91 e0       	ldi	r25, 0x01	; 1
    6420:	20 ec       	ldi	r18, 0xC0	; 192
    6422:	31 e0       	ldi	r19, 0x01	; 1
    6424:	f9 01       	movw	r30, r18
    6426:	24 85       	ldd	r18, Z+12	; 0x0c
    6428:	27 7f       	andi	r18, 0xF7	; 247
    642a:	fc 01       	movw	r30, r24
    642c:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    642e:	19 82       	std	Y+1, r1	; 0x01
    6430:	16 c0       	rjmp	.+44     	; 0x645e <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    6432:	89 81       	ldd	r24, Y+1	; 0x01
    6434:	88 2f       	mov	r24, r24
    6436:	90 e0       	ldi	r25, 0x00	; 0
    6438:	2c 81       	ldd	r18, Y+4	; 0x04
    643a:	3d 81       	ldd	r19, Y+5	; 0x05
    643c:	89 01       	movw	r16, r18
    643e:	08 0f       	add	r16, r24
    6440:	19 1f       	adc	r17, r25
    6442:	89 81       	ldd	r24, Y+1	; 0x01
    6444:	28 2f       	mov	r18, r24
    6446:	30 e0       	ldi	r19, 0x00	; 0
    6448:	8a 81       	ldd	r24, Y+2	; 0x02
    644a:	9b 81       	ldd	r25, Y+3	; 0x03
    644c:	82 0f       	add	r24, r18
    644e:	93 1f       	adc	r25, r19
    6450:	0e 94 86 31 	call	0x630c	; 0x630c <chb_eep_read_byte>
    6454:	f8 01       	movw	r30, r16
    6456:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6458:	89 81       	ldd	r24, Y+1	; 0x01
    645a:	8f 5f       	subi	r24, 0xFF	; 255
    645c:	89 83       	std	Y+1, r24	; 0x01
    645e:	89 81       	ldd	r24, Y+1	; 0x01
    6460:	28 2f       	mov	r18, r24
    6462:	30 e0       	ldi	r19, 0x00	; 0
    6464:	8e 81       	ldd	r24, Y+6	; 0x06
    6466:	9f 81       	ldd	r25, Y+7	; 0x07
    6468:	28 17       	cp	r18, r24
    646a:	39 07       	cpc	r19, r25
    646c:	10 f3       	brcs	.-60     	; 0x6432 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    646e:	27 96       	adiw	r28, 0x07	; 7
    6470:	cd bf       	out	0x3d, r28	; 61
    6472:	de bf       	out	0x3e, r29	; 62
    6474:	df 91       	pop	r29
    6476:	cf 91       	pop	r28
    6478:	1f 91       	pop	r17
    647a:	0f 91       	pop	r16
    647c:	08 95       	ret

0000647e <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    647e:	cf 93       	push	r28
    6480:	df 93       	push	r29
    6482:	cd b7       	in	r28, 0x3d	; 61
    6484:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    6486:	80 e6       	ldi	r24, 0x60	; 96
    6488:	96 e0       	ldi	r25, 0x06	; 6
    648a:	20 e6       	ldi	r18, 0x60	; 96
    648c:	36 e0       	ldi	r19, 0x06	; 6
    648e:	f9 01       	movw	r30, r18
    6490:	20 81       	ld	r18, Z
    6492:	20 6b       	ori	r18, 0xB0	; 176
    6494:	fc 01       	movw	r30, r24
    6496:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    6498:	84 e6       	ldi	r24, 0x64	; 100
    649a:	96 e0       	ldi	r25, 0x06	; 6
    649c:	24 e6       	ldi	r18, 0x64	; 100
    649e:	36 e0       	ldi	r19, 0x06	; 6
    64a0:	f9 01       	movw	r30, r18
    64a2:	20 81       	ld	r18, Z
    64a4:	20 61       	ori	r18, 0x10	; 16
    64a6:	fc 01       	movw	r30, r24
    64a8:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    64aa:	80 ec       	ldi	r24, 0xC0	; 192
    64ac:	99 e0       	ldi	r25, 0x09	; 9
    64ae:	20 ec       	ldi	r18, 0xC0	; 192
    64b0:	39 e0       	ldi	r19, 0x09	; 9
    64b2:	f9 01       	movw	r30, r18
    64b4:	20 81       	ld	r18, Z
    64b6:	21 65       	ori	r18, 0x51	; 81
    64b8:	fc 01       	movw	r30, r24
    64ba:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    64bc:	84 e6       	ldi	r24, 0x64	; 100
    64be:	96 e0       	ldi	r25, 0x06	; 6
    64c0:	24 e6       	ldi	r18, 0x64	; 100
    64c2:	36 e0       	ldi	r19, 0x06	; 6
    64c4:	f9 01       	movw	r30, r18
    64c6:	20 81       	ld	r18, Z
    64c8:	20 61       	ori	r18, 0x10	; 16
    64ca:	fc 01       	movw	r30, r24
    64cc:	20 83       	st	Z, r18
}
    64ce:	df 91       	pop	r29
    64d0:	cf 91       	pop	r28
    64d2:	08 95       	ret

000064d4 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    64d4:	cf 93       	push	r28
    64d6:	df 93       	push	r29
    64d8:	0f 92       	push	r0
    64da:	0f 92       	push	r0
    64dc:	cd b7       	in	r28, 0x3d	; 61
    64de:	de b7       	in	r29, 0x3e	; 62
    64e0:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    64e2:	80 ec       	ldi	r24, 0xC0	; 192
    64e4:	99 e0       	ldi	r25, 0x09	; 9
    64e6:	2a 81       	ldd	r18, Y+2	; 0x02
    64e8:	fc 01       	movw	r30, r24
    64ea:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    64ec:	00 00       	nop
    64ee:	80 ec       	ldi	r24, 0xC0	; 192
    64f0:	99 e0       	ldi	r25, 0x09	; 9
    64f2:	fc 01       	movw	r30, r24
    64f4:	82 81       	ldd	r24, Z+2	; 0x02
    64f6:	88 23       	and	r24, r24
    64f8:	d4 f7       	brge	.-12     	; 0x64ee <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    64fa:	80 ec       	ldi	r24, 0xC0	; 192
    64fc:	99 e0       	ldi	r25, 0x09	; 9
    64fe:	fc 01       	movw	r30, r24
    6500:	83 81       	ldd	r24, Z+3	; 0x03
    6502:	89 83       	std	Y+1, r24	; 0x01
	return data;
    6504:	89 81       	ldd	r24, Y+1	; 0x01
    6506:	0f 90       	pop	r0
    6508:	0f 90       	pop	r0
    650a:	df 91       	pop	r29
    650c:	cf 91       	pop	r28
    650e:	08 95       	ret

00006510 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    6510:	0f 93       	push	r16
    6512:	cf 93       	push	r28
    6514:	df 93       	push	r29
    6516:	00 d0       	rcall	.+0      	; 0x6518 <CCPWrite+0x8>
    6518:	00 d0       	rcall	.+0      	; 0x651a <CCPWrite+0xa>
    651a:	cd b7       	in	r28, 0x3d	; 61
    651c:	de b7       	in	r29, 0x3e	; 62
    651e:	8c 83       	std	Y+4, r24	; 0x04
    6520:	9d 83       	std	Y+5, r25	; 0x05
    6522:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    6524:	8f e3       	ldi	r24, 0x3F	; 63
    6526:	90 e0       	ldi	r25, 0x00	; 0
    6528:	fc 01       	movw	r30, r24
    652a:	80 81       	ld	r24, Z
    652c:	8b 83       	std	Y+3, r24	; 0x03
    652e:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    6530:	8c 81       	ldd	r24, Y+4	; 0x04
    6532:	9d 81       	ldd	r25, Y+5	; 0x05
    6534:	89 83       	std	Y+1, r24	; 0x01
    6536:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    6538:	8b e3       	ldi	r24, 0x3B	; 59
    653a:	90 e0       	ldi	r25, 0x00	; 0
    653c:	fc 01       	movw	r30, r24
    653e:	10 82       	st	Z, r1
#endif
	asm volatile(
    6540:	89 81       	ldd	r24, Y+1	; 0x01
    6542:	9a 81       	ldd	r25, Y+2	; 0x02
    6544:	2e 81       	ldd	r18, Y+6	; 0x06
    6546:	fc 01       	movw	r30, r24
    6548:	08 ed       	ldi	r16, 0xD8	; 216
    654a:	04 bf       	out	0x34, r16	; 52
    654c:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    654e:	8f e3       	ldi	r24, 0x3F	; 63
    6550:	90 e0       	ldi	r25, 0x00	; 0
    6552:	2b 81       	ldd	r18, Y+3	; 0x03
    6554:	fc 01       	movw	r30, r24
    6556:	20 83       	st	Z, r18
#endif
}
    6558:	26 96       	adiw	r28, 0x06	; 6
    655a:	cd bf       	out	0x3d, r28	; 61
    655c:	de bf       	out	0x3e, r29	; 62
    655e:	df 91       	pop	r29
    6560:	cf 91       	pop	r28
    6562:	0f 91       	pop	r16
    6564:	08 95       	ret

00006566 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6566:	cf 93       	push	r28
    6568:	df 93       	push	r29
    656a:	00 d0       	rcall	.+0      	; 0x656c <CLKSYS_XOSC_Config+0x6>
    656c:	cd b7       	in	r28, 0x3d	; 61
    656e:	de b7       	in	r29, 0x3e	; 62
    6570:	89 83       	std	Y+1, r24	; 0x01
    6572:	6a 83       	std	Y+2, r22	; 0x02
    6574:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6576:	80 e5       	ldi	r24, 0x50	; 80
    6578:	90 e0       	ldi	r25, 0x00	; 0
    657a:	2a 81       	ldd	r18, Y+2	; 0x02
    657c:	22 23       	and	r18, r18
    657e:	11 f0       	breq	.+4      	; 0x6584 <CLKSYS_XOSC_Config+0x1e>
    6580:	20 e2       	ldi	r18, 0x20	; 32
    6582:	01 c0       	rjmp	.+2      	; 0x6586 <CLKSYS_XOSC_Config+0x20>
    6584:	20 e0       	ldi	r18, 0x00	; 0
    6586:	39 81       	ldd	r19, Y+1	; 0x01
    6588:	32 2b       	or	r19, r18
    658a:	2b 81       	ldd	r18, Y+3	; 0x03
    658c:	23 2b       	or	r18, r19
    658e:	fc 01       	movw	r30, r24
    6590:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    6592:	23 96       	adiw	r28, 0x03	; 3
    6594:	cd bf       	out	0x3d, r28	; 61
    6596:	de bf       	out	0x3e, r29	; 62
    6598:	df 91       	pop	r29
    659a:	cf 91       	pop	r28
    659c:	08 95       	ret

0000659e <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    659e:	cf 93       	push	r28
    65a0:	df 93       	push	r29
    65a2:	0f 92       	push	r0
    65a4:	0f 92       	push	r0
    65a6:	cd b7       	in	r28, 0x3d	; 61
    65a8:	de b7       	in	r29, 0x3e	; 62
    65aa:	89 83       	std	Y+1, r24	; 0x01
    65ac:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    65ae:	8a 81       	ldd	r24, Y+2	; 0x02
    65b0:	8f 71       	andi	r24, 0x1F	; 31
    65b2:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    65b4:	80 e5       	ldi	r24, 0x50	; 80
    65b6:	90 e0       	ldi	r25, 0x00	; 0
    65b8:	39 81       	ldd	r19, Y+1	; 0x01
    65ba:	2a 81       	ldd	r18, Y+2	; 0x02
    65bc:	23 2b       	or	r18, r19
    65be:	fc 01       	movw	r30, r24
    65c0:	25 83       	std	Z+5, r18	; 0x05
}
    65c2:	0f 90       	pop	r0
    65c4:	0f 90       	pop	r0
    65c6:	df 91       	pop	r29
    65c8:	cf 91       	pop	r28
    65ca:	08 95       	ret

000065cc <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    65cc:	cf 93       	push	r28
    65ce:	df 93       	push	r29
    65d0:	0f 92       	push	r0
    65d2:	0f 92       	push	r0
    65d4:	cd b7       	in	r28, 0x3d	; 61
    65d6:	de b7       	in	r29, 0x3e	; 62
    65d8:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    65da:	80 e5       	ldi	r24, 0x50	; 80
    65dc:	90 e0       	ldi	r25, 0x00	; 0
    65de:	20 e5       	ldi	r18, 0x50	; 80
    65e0:	30 e0       	ldi	r19, 0x00	; 0
    65e2:	f9 01       	movw	r30, r18
    65e4:	20 81       	ld	r18, Z
    65e6:	32 2f       	mov	r19, r18
    65e8:	2a 81       	ldd	r18, Y+2	; 0x02
    65ea:	20 95       	com	r18
    65ec:	23 23       	and	r18, r19
    65ee:	fc 01       	movw	r30, r24
    65f0:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    65f2:	80 e5       	ldi	r24, 0x50	; 80
    65f4:	90 e0       	ldi	r25, 0x00	; 0
    65f6:	fc 01       	movw	r30, r24
    65f8:	90 81       	ld	r25, Z
    65fa:	8a 81       	ldd	r24, Y+2	; 0x02
    65fc:	89 23       	and	r24, r25
    65fe:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    6600:	89 81       	ldd	r24, Y+1	; 0x01
}
    6602:	0f 90       	pop	r0
    6604:	0f 90       	pop	r0
    6606:	df 91       	pop	r29
    6608:	cf 91       	pop	r28
    660a:	08 95       	ret

0000660c <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    660c:	cf 93       	push	r28
    660e:	df 93       	push	r29
    6610:	00 d0       	rcall	.+0      	; 0x6612 <CLKSYS_Prescalers_Config+0x6>
    6612:	cd b7       	in	r28, 0x3d	; 61
    6614:	de b7       	in	r29, 0x3e	; 62
    6616:	8a 83       	std	Y+2, r24	; 0x02
    6618:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    661a:	9a 81       	ldd	r25, Y+2	; 0x02
    661c:	8b 81       	ldd	r24, Y+3	; 0x03
    661e:	89 2b       	or	r24, r25
    6620:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    6622:	81 e4       	ldi	r24, 0x41	; 65
    6624:	90 e0       	ldi	r25, 0x00	; 0
    6626:	69 81       	ldd	r22, Y+1	; 0x01
    6628:	0e 94 88 32 	call	0x6510	; 0x6510 <CCPWrite>
}
    662c:	23 96       	adiw	r28, 0x03	; 3
    662e:	cd bf       	out	0x3d, r28	; 61
    6630:	de bf       	out	0x3e, r29	; 62
    6632:	df 91       	pop	r29
    6634:	cf 91       	pop	r28
    6636:	08 95       	ret

00006638 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6638:	cf 93       	push	r28
    663a:	df 93       	push	r29
    663c:	0f 92       	push	r0
    663e:	0f 92       	push	r0
    6640:	cd b7       	in	r28, 0x3d	; 61
    6642:	de b7       	in	r29, 0x3e	; 62
    6644:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    6646:	80 e4       	ldi	r24, 0x40	; 64
    6648:	90 e0       	ldi	r25, 0x00	; 0
    664a:	fc 01       	movw	r30, r24
    664c:	80 81       	ld	r24, Z
    664e:	98 2f       	mov	r25, r24
    6650:	98 7f       	andi	r25, 0xF8	; 248
    6652:	8a 81       	ldd	r24, Y+2	; 0x02
    6654:	89 2b       	or	r24, r25
    6656:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    6658:	80 e4       	ldi	r24, 0x40	; 64
    665a:	90 e0       	ldi	r25, 0x00	; 0
    665c:	69 81       	ldd	r22, Y+1	; 0x01
    665e:	0e 94 88 32 	call	0x6510	; 0x6510 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    6662:	80 e4       	ldi	r24, 0x40	; 64
    6664:	90 e0       	ldi	r25, 0x00	; 0
    6666:	fc 01       	movw	r30, r24
    6668:	90 81       	ld	r25, Z
    666a:	8a 81       	ldd	r24, Y+2	; 0x02
    666c:	89 23       	and	r24, r25
    666e:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    6670:	89 81       	ldd	r24, Y+1	; 0x01
}
    6672:	0f 90       	pop	r0
    6674:	0f 90       	pop	r0
    6676:	df 91       	pop	r29
    6678:	cf 91       	pop	r28
    667a:	08 95       	ret

0000667c <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    667c:	cf 93       	push	r28
    667e:	df 93       	push	r29
    6680:	0f 92       	push	r0
    6682:	cd b7       	in	r28, 0x3d	; 61
    6684:	de b7       	in	r29, 0x3e	; 62
    6686:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6688:	80 e4       	ldi	r24, 0x40	; 64
    668a:	90 e0       	ldi	r25, 0x00	; 0
    668c:	20 e4       	ldi	r18, 0x40	; 64
    668e:	30 e0       	ldi	r19, 0x00	; 0
    6690:	f9 01       	movw	r30, r18
    6692:	23 81       	ldd	r18, Z+3	; 0x03
    6694:	32 2f       	mov	r19, r18
    6696:	31 7f       	andi	r19, 0xF1	; 241
    6698:	29 81       	ldd	r18, Y+1	; 0x01
    669a:	23 2b       	or	r18, r19
    669c:	21 60       	ori	r18, 0x01	; 1
    669e:	fc 01       	movw	r30, r24
    66a0:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    66a2:	0f 90       	pop	r0
    66a4:	df 91       	pop	r29
    66a6:	cf 91       	pop	r28
    66a8:	08 95       	ret

000066aa <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    66aa:	cf 93       	push	r28
    66ac:	df 93       	push	r29
    66ae:	0f 92       	push	r0
    66b0:	0f 92       	push	r0
    66b2:	cd b7       	in	r28, 0x3d	; 61
    66b4:	de b7       	in	r29, 0x3e	; 62
    66b6:	89 83       	std	Y+1, r24	; 0x01
    66b8:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    66ba:	80 e5       	ldi	r24, 0x50	; 80
    66bc:	90 e0       	ldi	r25, 0x00	; 0
    66be:	20 e5       	ldi	r18, 0x50	; 80
    66c0:	30 e0       	ldi	r19, 0x00	; 0
    66c2:	f9 01       	movw	r30, r18
    66c4:	26 81       	ldd	r18, Z+6	; 0x06
    66c6:	32 2f       	mov	r19, r18
    66c8:	29 81       	ldd	r18, Y+1	; 0x01
    66ca:	20 95       	com	r18
    66cc:	32 23       	and	r19, r18
    66ce:	2a 81       	ldd	r18, Y+2	; 0x02
    66d0:	22 23       	and	r18, r18
    66d2:	11 f0       	breq	.+4      	; 0x66d8 <CLKSYS_AutoCalibration_Enable+0x2e>
    66d4:	29 81       	ldd	r18, Y+1	; 0x01
    66d6:	01 c0       	rjmp	.+2      	; 0x66da <CLKSYS_AutoCalibration_Enable+0x30>
    66d8:	20 e0       	ldi	r18, 0x00	; 0
    66da:	23 2b       	or	r18, r19
    66dc:	fc 01       	movw	r30, r24
    66de:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    66e0:	89 81       	ldd	r24, Y+1	; 0x01
    66e2:	81 30       	cpi	r24, 0x01	; 1
    66e4:	51 f4       	brne	.+20     	; 0x66fa <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    66e6:	88 e6       	ldi	r24, 0x68	; 104
    66e8:	90 e0       	ldi	r25, 0x00	; 0
    66ea:	28 e6       	ldi	r18, 0x68	; 104
    66ec:	30 e0       	ldi	r19, 0x00	; 0
    66ee:	f9 01       	movw	r30, r18
    66f0:	20 81       	ld	r18, Z
    66f2:	21 60       	ori	r18, 0x01	; 1
    66f4:	fc 01       	movw	r30, r24
    66f6:	20 83       	st	Z, r18
    66f8:	0c c0       	rjmp	.+24     	; 0x6712 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    66fa:	89 81       	ldd	r24, Y+1	; 0x01
    66fc:	82 30       	cpi	r24, 0x02	; 2
    66fe:	49 f4       	brne	.+18     	; 0x6712 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    6700:	80 e6       	ldi	r24, 0x60	; 96
    6702:	90 e0       	ldi	r25, 0x00	; 0
    6704:	20 e6       	ldi	r18, 0x60	; 96
    6706:	30 e0       	ldi	r19, 0x00	; 0
    6708:	f9 01       	movw	r30, r18
    670a:	20 81       	ld	r18, Z
    670c:	21 60       	ori	r18, 0x01	; 1
    670e:	fc 01       	movw	r30, r24
    6710:	20 83       	st	Z, r18
	}
}
    6712:	0f 90       	pop	r0
    6714:	0f 90       	pop	r0
    6716:	df 91       	pop	r29
    6718:	cf 91       	pop	r28
    671a:	08 95       	ret

0000671c <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    671c:	cf 93       	push	r28
    671e:	df 93       	push	r29
    6720:	cd b7       	in	r28, 0x3d	; 61
    6722:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    6724:	83 e5       	ldi	r24, 0x53	; 83
    6726:	90 e0       	ldi	r25, 0x00	; 0
    6728:	63 e0       	ldi	r22, 0x03	; 3
    672a:	0e 94 88 32 	call	0x6510	; 0x6510 <CCPWrite>
}
    672e:	df 91       	pop	r29
    6730:	cf 91       	pop	r28
    6732:	08 95       	ret

00006734 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    6734:	cf 93       	push	r28
    6736:	df 93       	push	r29
    6738:	cd b7       	in	r28, 0x3d	; 61
    673a:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    673c:	82 e4       	ldi	r24, 0x42	; 66
    673e:	90 e0       	ldi	r25, 0x00	; 0
    6740:	61 e0       	ldi	r22, 0x01	; 1
    6742:	0e 94 88 32 	call	0x6510	; 0x6510 <CCPWrite>
}
    6746:	df 91       	pop	r29
    6748:	cf 91       	pop	r28
    674a:	08 95       	ret

0000674c <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    674c:	cf 93       	push	r28
    674e:	df 93       	push	r29
    6750:	cd b7       	in	r28, 0x3d	; 61
    6752:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6754:	80 ec       	ldi	r24, 0xC0	; 192
    6756:	60 e0       	ldi	r22, 0x00	; 0
    6758:	4b e0       	ldi	r20, 0x0B	; 11
    675a:	0e 94 b3 32 	call	0x6566	; 0x6566 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    675e:	80 e5       	ldi	r24, 0x50	; 80
    6760:	90 e0       	ldi	r25, 0x00	; 0
    6762:	20 e5       	ldi	r18, 0x50	; 80
    6764:	30 e0       	ldi	r19, 0x00	; 0
    6766:	f9 01       	movw	r30, r18
    6768:	20 81       	ld	r18, Z
    676a:	28 60       	ori	r18, 0x08	; 8
    676c:	fc 01       	movw	r30, r24
    676e:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    6770:	80 e5       	ldi	r24, 0x50	; 80
    6772:	90 e0       	ldi	r25, 0x00	; 0
    6774:	fc 01       	movw	r30, r24
    6776:	81 81       	ldd	r24, Z+1	; 0x01
    6778:	88 2f       	mov	r24, r24
    677a:	90 e0       	ldi	r25, 0x00	; 0
    677c:	88 70       	andi	r24, 0x08	; 8
    677e:	90 70       	andi	r25, 0x00	; 0
    6780:	00 97       	sbiw	r24, 0x00	; 0
    6782:	b1 f3       	breq	.-20     	; 0x6770 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6784:	80 ec       	ldi	r24, 0xC0	; 192
    6786:	62 e0       	ldi	r22, 0x02	; 2
    6788:	0e 94 cf 32 	call	0x659e	; 0x659e <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    678c:	80 e5       	ldi	r24, 0x50	; 80
    678e:	90 e0       	ldi	r25, 0x00	; 0
    6790:	20 e5       	ldi	r18, 0x50	; 80
    6792:	30 e0       	ldi	r19, 0x00	; 0
    6794:	f9 01       	movw	r30, r18
    6796:	20 81       	ld	r18, Z
    6798:	20 61       	ori	r18, 0x10	; 16
    679a:	fc 01       	movw	r30, r24
    679c:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    679e:	80 e5       	ldi	r24, 0x50	; 80
    67a0:	90 e0       	ldi	r25, 0x00	; 0
    67a2:	fc 01       	movw	r30, r24
    67a4:	81 81       	ldd	r24, Z+1	; 0x01
    67a6:	88 2f       	mov	r24, r24
    67a8:	90 e0       	ldi	r25, 0x00	; 0
    67aa:	80 71       	andi	r24, 0x10	; 16
    67ac:	90 70       	andi	r25, 0x00	; 0
    67ae:	00 97       	sbiw	r24, 0x00	; 0
    67b0:	b1 f3       	breq	.-20     	; 0x679e <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    67b2:	84 e0       	ldi	r24, 0x04	; 4
    67b4:	0e 94 1c 33 	call	0x6638	; 0x6638 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    67b8:	81 e0       	ldi	r24, 0x01	; 1
    67ba:	0e 94 e6 32 	call	0x65cc	; 0x65cc <CLKSYS_Disable>
}
    67be:	df 91       	pop	r29
    67c0:	cf 91       	pop	r28
    67c2:	08 95       	ret

000067c4 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    67c4:	cf 93       	push	r28
    67c6:	df 93       	push	r29
    67c8:	cd b7       	in	r28, 0x3d	; 61
    67ca:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    67cc:	80 e5       	ldi	r24, 0x50	; 80
    67ce:	90 e0       	ldi	r25, 0x00	; 0
    67d0:	20 e5       	ldi	r18, 0x50	; 80
    67d2:	30 e0       	ldi	r19, 0x00	; 0
    67d4:	f9 01       	movw	r30, r18
    67d6:	20 81       	ld	r18, Z
    67d8:	22 60       	ori	r18, 0x02	; 2
    67da:	fc 01       	movw	r30, r24
    67dc:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    67de:	80 e0       	ldi	r24, 0x00	; 0
    67e0:	61 e0       	ldi	r22, 0x01	; 1
    67e2:	0e 94 06 33 	call	0x660c	; 0x660c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    67e6:	80 e5       	ldi	r24, 0x50	; 80
    67e8:	90 e0       	ldi	r25, 0x00	; 0
    67ea:	fc 01       	movw	r30, r24
    67ec:	81 81       	ldd	r24, Z+1	; 0x01
    67ee:	88 2f       	mov	r24, r24
    67f0:	90 e0       	ldi	r25, 0x00	; 0
    67f2:	82 70       	andi	r24, 0x02	; 2
    67f4:	90 70       	andi	r25, 0x00	; 0
    67f6:	00 97       	sbiw	r24, 0x00	; 0
    67f8:	b1 f3       	breq	.-20     	; 0x67e6 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    67fa:	81 e0       	ldi	r24, 0x01	; 1
    67fc:	0e 94 1c 33 	call	0x6638	; 0x6638 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6800:	81 e0       	ldi	r24, 0x01	; 1
    6802:	0e 94 e6 32 	call	0x65cc	; 0x65cc <CLKSYS_Disable>
	
}
    6806:	df 91       	pop	r29
    6808:	cf 91       	pop	r28
    680a:	08 95       	ret

0000680c <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    680c:	cf 93       	push	r28
    680e:	df 93       	push	r29
    6810:	cd b7       	in	r28, 0x3d	; 61
    6812:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6814:	80 e5       	ldi	r24, 0x50	; 80
    6816:	90 e0       	ldi	r25, 0x00	; 0
    6818:	20 e5       	ldi	r18, 0x50	; 80
    681a:	30 e0       	ldi	r19, 0x00	; 0
    681c:	f9 01       	movw	r30, r18
    681e:	20 81       	ld	r18, Z
    6820:	22 60       	ori	r18, 0x02	; 2
    6822:	fc 01       	movw	r30, r24
    6824:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6826:	80 e0       	ldi	r24, 0x00	; 0
    6828:	60 e0       	ldi	r22, 0x00	; 0
    682a:	0e 94 06 33 	call	0x660c	; 0x660c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    682e:	80 e5       	ldi	r24, 0x50	; 80
    6830:	90 e0       	ldi	r25, 0x00	; 0
    6832:	fc 01       	movw	r30, r24
    6834:	81 81       	ldd	r24, Z+1	; 0x01
    6836:	88 2f       	mov	r24, r24
    6838:	90 e0       	ldi	r25, 0x00	; 0
    683a:	82 70       	andi	r24, 0x02	; 2
    683c:	90 70       	andi	r25, 0x00	; 0
    683e:	00 97       	sbiw	r24, 0x00	; 0
    6840:	b1 f3       	breq	.-20     	; 0x682e <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6842:	81 e0       	ldi	r24, 0x01	; 1
    6844:	0e 94 1c 33 	call	0x6638	; 0x6638 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6848:	81 e0       	ldi	r24, 0x01	; 1
    684a:	0e 94 e6 32 	call	0x65cc	; 0x65cc <CLKSYS_Disable>
	
}
    684e:	df 91       	pop	r29
    6850:	cf 91       	pop	r28
    6852:	08 95       	ret

00006854 <portExCS>:


void portExCS(uint8_t write) {
    6854:	0f 93       	push	r16
    6856:	1f 93       	push	r17
    6858:	cf 93       	push	r28
    685a:	df 93       	push	r29
    685c:	cd b7       	in	r28, 0x3d	; 61
    685e:	de b7       	in	r29, 0x3e	; 62
    6860:	69 97       	sbiw	r28, 0x19	; 25
    6862:	cd bf       	out	0x3d, r28	; 61
    6864:	de bf       	out	0x3e, r29	; 62
    6866:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6868:	89 8d       	ldd	r24, Y+25	; 0x19
    686a:	88 23       	and	r24, r24
    686c:	31 f0       	breq	.+12     	; 0x687a <portExCS+0x26>
    686e:	80 e0       	ldi	r24, 0x00	; 0
    6870:	96 e0       	ldi	r25, 0x06	; 6
    6872:	28 e0       	ldi	r18, 0x08	; 8
    6874:	fc 01       	movw	r30, r24
    6876:	26 83       	std	Z+6, r18	; 0x06
    6878:	05 c0       	rjmp	.+10     	; 0x6884 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    687a:	80 e0       	ldi	r24, 0x00	; 0
    687c:	96 e0       	ldi	r25, 0x06	; 6
    687e:	28 e0       	ldi	r18, 0x08	; 8
    6880:	fc 01       	movw	r30, r24
    6882:	25 83       	std	Z+5, r18	; 0x05
    6884:	80 e0       	ldi	r24, 0x00	; 0
    6886:	90 e0       	ldi	r25, 0x00	; 0
    6888:	a0 e2       	ldi	r26, 0x20	; 32
    688a:	b1 e4       	ldi	r27, 0x41	; 65
    688c:	89 83       	std	Y+1, r24	; 0x01
    688e:	9a 83       	std	Y+2, r25	; 0x02
    6890:	ab 83       	std	Y+3, r26	; 0x03
    6892:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6894:	69 81       	ldd	r22, Y+1	; 0x01
    6896:	7a 81       	ldd	r23, Y+2	; 0x02
    6898:	8b 81       	ldd	r24, Y+3	; 0x03
    689a:	9c 81       	ldd	r25, Y+4	; 0x04
    689c:	2b ea       	ldi	r18, 0xAB	; 171
    689e:	3a ea       	ldi	r19, 0xAA	; 170
    68a0:	4a e2       	ldi	r20, 0x2A	; 42
    68a2:	51 e4       	ldi	r21, 0x41	; 65
    68a4:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    68a8:	dc 01       	movw	r26, r24
    68aa:	cb 01       	movw	r24, r22
    68ac:	8d 83       	std	Y+5, r24	; 0x05
    68ae:	9e 83       	std	Y+6, r25	; 0x06
    68b0:	af 83       	std	Y+7, r26	; 0x07
    68b2:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    68b4:	11 e0       	ldi	r17, 0x01	; 1
    68b6:	6d 81       	ldd	r22, Y+5	; 0x05
    68b8:	7e 81       	ldd	r23, Y+6	; 0x06
    68ba:	8f 81       	ldd	r24, Y+7	; 0x07
    68bc:	98 85       	ldd	r25, Y+8	; 0x08
    68be:	20 e0       	ldi	r18, 0x00	; 0
    68c0:	30 e0       	ldi	r19, 0x00	; 0
    68c2:	40 e8       	ldi	r20, 0x80	; 128
    68c4:	5f e3       	ldi	r21, 0x3F	; 63
    68c6:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    68ca:	88 23       	and	r24, r24
    68cc:	0c f0       	brlt	.+2      	; 0x68d0 <portExCS+0x7c>
    68ce:	10 e0       	ldi	r17, 0x00	; 0
    68d0:	11 23       	and	r17, r17
    68d2:	19 f0       	breq	.+6      	; 0x68da <portExCS+0x86>
		__ticks = 1;
    68d4:	81 e0       	ldi	r24, 0x01	; 1
    68d6:	89 87       	std	Y+9, r24	; 0x09
    68d8:	a3 c0       	rjmp	.+326    	; 0x6a20 <portExCS+0x1cc>
	else if (__tmp > 255)
    68da:	11 e0       	ldi	r17, 0x01	; 1
    68dc:	6d 81       	ldd	r22, Y+5	; 0x05
    68de:	7e 81       	ldd	r23, Y+6	; 0x06
    68e0:	8f 81       	ldd	r24, Y+7	; 0x07
    68e2:	98 85       	ldd	r25, Y+8	; 0x08
    68e4:	20 e0       	ldi	r18, 0x00	; 0
    68e6:	30 e0       	ldi	r19, 0x00	; 0
    68e8:	4f e7       	ldi	r20, 0x7F	; 127
    68ea:	53 e4       	ldi	r21, 0x43	; 67
    68ec:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    68f0:	18 16       	cp	r1, r24
    68f2:	0c f0       	brlt	.+2      	; 0x68f6 <portExCS+0xa2>
    68f4:	10 e0       	ldi	r17, 0x00	; 0
    68f6:	11 23       	and	r17, r17
    68f8:	09 f4       	brne	.+2      	; 0x68fc <portExCS+0xa8>
    68fa:	89 c0       	rjmp	.+274    	; 0x6a0e <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    68fc:	69 81       	ldd	r22, Y+1	; 0x01
    68fe:	7a 81       	ldd	r23, Y+2	; 0x02
    6900:	8b 81       	ldd	r24, Y+3	; 0x03
    6902:	9c 81       	ldd	r25, Y+4	; 0x04
    6904:	20 e0       	ldi	r18, 0x00	; 0
    6906:	30 e0       	ldi	r19, 0x00	; 0
    6908:	4a e7       	ldi	r20, 0x7A	; 122
    690a:	54 e4       	ldi	r21, 0x44	; 68
    690c:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    6910:	dc 01       	movw	r26, r24
    6912:	cb 01       	movw	r24, r22
    6914:	8a 87       	std	Y+10, r24	; 0x0a
    6916:	9b 87       	std	Y+11, r25	; 0x0b
    6918:	ac 87       	std	Y+12, r26	; 0x0c
    691a:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    691c:	6a 85       	ldd	r22, Y+10	; 0x0a
    691e:	7b 85       	ldd	r23, Y+11	; 0x0b
    6920:	8c 85       	ldd	r24, Y+12	; 0x0c
    6922:	9d 85       	ldd	r25, Y+13	; 0x0d
    6924:	20 e0       	ldi	r18, 0x00	; 0
    6926:	30 e0       	ldi	r19, 0x00	; 0
    6928:	4a ef       	ldi	r20, 0xFA	; 250
    692a:	55 e4       	ldi	r21, 0x45	; 69
    692c:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    6930:	dc 01       	movw	r26, r24
    6932:	cb 01       	movw	r24, r22
    6934:	8e 87       	std	Y+14, r24	; 0x0e
    6936:	9f 87       	std	Y+15, r25	; 0x0f
    6938:	a8 8b       	std	Y+16, r26	; 0x10
    693a:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    693c:	11 e0       	ldi	r17, 0x01	; 1
    693e:	6e 85       	ldd	r22, Y+14	; 0x0e
    6940:	7f 85       	ldd	r23, Y+15	; 0x0f
    6942:	88 89       	ldd	r24, Y+16	; 0x10
    6944:	99 89       	ldd	r25, Y+17	; 0x11
    6946:	20 e0       	ldi	r18, 0x00	; 0
    6948:	30 e0       	ldi	r19, 0x00	; 0
    694a:	40 e8       	ldi	r20, 0x80	; 128
    694c:	5f e3       	ldi	r21, 0x3F	; 63
    694e:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    6952:	88 23       	and	r24, r24
    6954:	0c f0       	brlt	.+2      	; 0x6958 <portExCS+0x104>
    6956:	10 e0       	ldi	r17, 0x00	; 0
    6958:	11 23       	and	r17, r17
    695a:	29 f0       	breq	.+10     	; 0x6966 <portExCS+0x112>
		__ticks = 1;
    695c:	81 e0       	ldi	r24, 0x01	; 1
    695e:	90 e0       	ldi	r25, 0x00	; 0
    6960:	8a 8b       	std	Y+18, r24	; 0x12
    6962:	9b 8b       	std	Y+19, r25	; 0x13
    6964:	46 c0       	rjmp	.+140    	; 0x69f2 <portExCS+0x19e>
	else if (__tmp > 65535)
    6966:	11 e0       	ldi	r17, 0x01	; 1
    6968:	6e 85       	ldd	r22, Y+14	; 0x0e
    696a:	7f 85       	ldd	r23, Y+15	; 0x0f
    696c:	88 89       	ldd	r24, Y+16	; 0x10
    696e:	99 89       	ldd	r25, Y+17	; 0x11
    6970:	20 e0       	ldi	r18, 0x00	; 0
    6972:	3f ef       	ldi	r19, 0xFF	; 255
    6974:	4f e7       	ldi	r20, 0x7F	; 127
    6976:	57 e4       	ldi	r21, 0x47	; 71
    6978:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    697c:	18 16       	cp	r1, r24
    697e:	0c f0       	brlt	.+2      	; 0x6982 <portExCS+0x12e>
    6980:	10 e0       	ldi	r17, 0x00	; 0
    6982:	11 23       	and	r17, r17
    6984:	61 f1       	breq	.+88     	; 0x69de <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6986:	6a 85       	ldd	r22, Y+10	; 0x0a
    6988:	7b 85       	ldd	r23, Y+11	; 0x0b
    698a:	8c 85       	ldd	r24, Y+12	; 0x0c
    698c:	9d 85       	ldd	r25, Y+13	; 0x0d
    698e:	20 e0       	ldi	r18, 0x00	; 0
    6990:	30 e0       	ldi	r19, 0x00	; 0
    6992:	40 e2       	ldi	r20, 0x20	; 32
    6994:	51 e4       	ldi	r21, 0x41	; 65
    6996:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    699a:	dc 01       	movw	r26, r24
    699c:	cb 01       	movw	r24, r22
    699e:	bc 01       	movw	r22, r24
    69a0:	cd 01       	movw	r24, r26
    69a2:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    69a6:	dc 01       	movw	r26, r24
    69a8:	cb 01       	movw	r24, r22
    69aa:	8a 8b       	std	Y+18, r24	; 0x12
    69ac:	9b 8b       	std	Y+19, r25	; 0x13
    69ae:	12 c0       	rjmp	.+36     	; 0x69d4 <portExCS+0x180>
    69b0:	80 e2       	ldi	r24, 0x20	; 32
    69b2:	93 e0       	ldi	r25, 0x03	; 3
    69b4:	8c 8b       	std	Y+20, r24	; 0x14
    69b6:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    69b8:	8c 89       	ldd	r24, Y+20	; 0x14
    69ba:	9d 89       	ldd	r25, Y+21	; 0x15
    69bc:	8c 01       	movw	r16, r24
    69be:	c8 01       	movw	r24, r16
    69c0:	01 97       	sbiw	r24, 0x01	; 1
    69c2:	f1 f7       	brne	.-4      	; 0x69c0 <portExCS+0x16c>
    69c4:	8c 01       	movw	r16, r24
    69c6:	0c 8b       	std	Y+20, r16	; 0x14
    69c8:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    69ca:	8a 89       	ldd	r24, Y+18	; 0x12
    69cc:	9b 89       	ldd	r25, Y+19	; 0x13
    69ce:	01 97       	sbiw	r24, 0x01	; 1
    69d0:	8a 8b       	std	Y+18, r24	; 0x12
    69d2:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    69d4:	8a 89       	ldd	r24, Y+18	; 0x12
    69d6:	9b 89       	ldd	r25, Y+19	; 0x13
    69d8:	00 97       	sbiw	r24, 0x00	; 0
    69da:	51 f7       	brne	.-44     	; 0x69b0 <portExCS+0x15c>
    69dc:	28 c0       	rjmp	.+80     	; 0x6a2e <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    69de:	6e 85       	ldd	r22, Y+14	; 0x0e
    69e0:	7f 85       	ldd	r23, Y+15	; 0x0f
    69e2:	88 89       	ldd	r24, Y+16	; 0x10
    69e4:	99 89       	ldd	r25, Y+17	; 0x11
    69e6:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    69ea:	dc 01       	movw	r26, r24
    69ec:	cb 01       	movw	r24, r22
    69ee:	8a 8b       	std	Y+18, r24	; 0x12
    69f0:	9b 8b       	std	Y+19, r25	; 0x13
    69f2:	8a 89       	ldd	r24, Y+18	; 0x12
    69f4:	9b 89       	ldd	r25, Y+19	; 0x13
    69f6:	8e 8b       	std	Y+22, r24	; 0x16
    69f8:	9f 8b       	std	Y+23, r25	; 0x17
    69fa:	8e 89       	ldd	r24, Y+22	; 0x16
    69fc:	9f 89       	ldd	r25, Y+23	; 0x17
    69fe:	8c 01       	movw	r16, r24
    6a00:	f8 01       	movw	r30, r16
    6a02:	31 97       	sbiw	r30, 0x01	; 1
    6a04:	f1 f7       	brne	.-4      	; 0x6a02 <portExCS+0x1ae>
    6a06:	8f 01       	movw	r16, r30
    6a08:	0e 8b       	std	Y+22, r16	; 0x16
    6a0a:	1f 8b       	std	Y+23, r17	; 0x17
    6a0c:	10 c0       	rjmp	.+32     	; 0x6a2e <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6a0e:	6d 81       	ldd	r22, Y+5	; 0x05
    6a10:	7e 81       	ldd	r23, Y+6	; 0x06
    6a12:	8f 81       	ldd	r24, Y+7	; 0x07
    6a14:	98 85       	ldd	r25, Y+8	; 0x08
    6a16:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    6a1a:	dc 01       	movw	r26, r24
    6a1c:	cb 01       	movw	r24, r22
    6a1e:	89 87       	std	Y+9, r24	; 0x09
    6a20:	89 85       	ldd	r24, Y+9	; 0x09
    6a22:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6a24:	88 8d       	ldd	r24, Y+24	; 0x18
    6a26:	18 2f       	mov	r17, r24
    6a28:	1a 95       	dec	r17
    6a2a:	f1 f7       	brne	.-4      	; 0x6a28 <portExCS+0x1d4>
    6a2c:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    6a2e:	69 96       	adiw	r28, 0x19	; 25
    6a30:	cd bf       	out	0x3d, r28	; 61
    6a32:	de bf       	out	0x3e, r29	; 62
    6a34:	df 91       	pop	r29
    6a36:	cf 91       	pop	r28
    6a38:	1f 91       	pop	r17
    6a3a:	0f 91       	pop	r16
    6a3c:	08 95       	ret

00006a3e <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    6a3e:	cf 93       	push	r28
    6a40:	df 93       	push	r29
    6a42:	00 d0       	rcall	.+0      	; 0x6a44 <PortEx_DIRSET+0x6>
    6a44:	cd b7       	in	r28, 0x3d	; 61
    6a46:	de b7       	in	r29, 0x3e	; 62
    6a48:	8a 83       	std	Y+2, r24	; 0x02
    6a4a:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6a4c:	80 e0       	ldi	r24, 0x00	; 0
    6a4e:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    6a52:	81 e0       	ldi	r24, 0x01	; 1
    6a54:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	portExCS(TRUE);
    6a58:	81 e0       	ldi	r24, 0x01	; 1
    6a5a:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    6a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a60:	88 23       	and	r24, r24
    6a62:	39 f0       	breq	.+14     	; 0x6a72 <PortEx_DIRSET+0x34>
    6a64:	90 91 65 50 	lds	r25, 0x5065
    6a68:	8a 81       	ldd	r24, Y+2	; 0x02
    6a6a:	89 2b       	or	r24, r25
    6a6c:	80 93 65 50 	sts	0x5065, r24
    6a70:	06 c0       	rjmp	.+12     	; 0x6a7e <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6a72:	90 91 d5 50 	lds	r25, 0x50D5
    6a76:	8a 81       	ldd	r24, Y+2	; 0x02
    6a78:	89 2b       	or	r24, r25
    6a7a:	80 93 d5 50 	sts	0x50D5, r24
	
	SPIBuffer[0] = PS_WRITE;
    6a7e:	80 e4       	ldi	r24, 0x40	; 64
    6a80:	80 93 54 50 	sts	0x5054, r24
	if(bank) {
    6a84:	8b 81       	ldd	r24, Y+3	; 0x03
    6a86:	88 23       	and	r24, r24
    6a88:	41 f0       	breq	.+16     	; 0x6a9a <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    6a8a:	10 92 55 50 	sts	0x5055, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6a8e:	80 91 65 50 	lds	r24, 0x5065
    6a92:	80 95       	com	r24
    6a94:	80 93 56 50 	sts	0x5056, r24
    6a98:	08 c0       	rjmp	.+16     	; 0x6aaa <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6a9a:	81 e0       	ldi	r24, 0x01	; 1
    6a9c:	80 93 55 50 	sts	0x5055, r24
		SPIBuffer[2] = ~bankB_DIR;
    6aa0:	80 91 d5 50 	lds	r24, 0x50D5
    6aa4:	80 95       	com	r24
    6aa6:	80 93 56 50 	sts	0x5056, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6aaa:	19 82       	std	Y+1, r1	; 0x01
    6aac:	1b c0       	rjmp	.+54     	; 0x6ae4 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    6aae:	80 ec       	ldi	r24, 0xC0	; 192
    6ab0:	98 e0       	ldi	r25, 0x08	; 8
    6ab2:	29 81       	ldd	r18, Y+1	; 0x01
    6ab4:	22 2f       	mov	r18, r18
    6ab6:	30 e0       	ldi	r19, 0x00	; 0
    6ab8:	2c 5a       	subi	r18, 0xAC	; 172
    6aba:	3f 4a       	sbci	r19, 0xAF	; 175
    6abc:	f9 01       	movw	r30, r18
    6abe:	20 81       	ld	r18, Z
    6ac0:	fc 01       	movw	r30, r24
    6ac2:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6ac4:	00 00       	nop
    6ac6:	80 ec       	ldi	r24, 0xC0	; 192
    6ac8:	98 e0       	ldi	r25, 0x08	; 8
    6aca:	fc 01       	movw	r30, r24
    6acc:	82 81       	ldd	r24, Z+2	; 0x02
    6ace:	88 23       	and	r24, r24
    6ad0:	d4 f7       	brge	.-12     	; 0x6ac6 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6ad2:	80 ec       	ldi	r24, 0xC0	; 192
    6ad4:	98 e0       	ldi	r25, 0x08	; 8
    6ad6:	fc 01       	movw	r30, r24
    6ad8:	83 81       	ldd	r24, Z+3	; 0x03
    6ada:	80 93 60 50 	sts	0x5060, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6ade:	89 81       	ldd	r24, Y+1	; 0x01
    6ae0:	8f 5f       	subi	r24, 0xFF	; 255
    6ae2:	89 83       	std	Y+1, r24	; 0x01
    6ae4:	89 81       	ldd	r24, Y+1	; 0x01
    6ae6:	83 30       	cpi	r24, 0x03	; 3
    6ae8:	10 f3       	brcs	.-60     	; 0x6aae <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    6aea:	80 e0       	ldi	r24, 0x00	; 0
    6aec:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>
	SPICS(FALSE);
    6af0:	80 e0       	ldi	r24, 0x00	; 0
    6af2:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    6af6:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>


}
    6afa:	23 96       	adiw	r28, 0x03	; 3
    6afc:	cd bf       	out	0x3d, r28	; 61
    6afe:	de bf       	out	0x3e, r29	; 62
    6b00:	df 91       	pop	r29
    6b02:	cf 91       	pop	r28
    6b04:	08 95       	ret

00006b06 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6b06:	cf 93       	push	r28
    6b08:	df 93       	push	r29
    6b0a:	00 d0       	rcall	.+0      	; 0x6b0c <PortEx_DIRCLR+0x6>
    6b0c:	cd b7       	in	r28, 0x3d	; 61
    6b0e:	de b7       	in	r29, 0x3e	; 62
    6b10:	8a 83       	std	Y+2, r24	; 0x02
    6b12:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6b14:	80 e0       	ldi	r24, 0x00	; 0
    6b16:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    6b1a:	81 e0       	ldi	r24, 0x01	; 1
    6b1c:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	portExCS(TRUE);
    6b20:	81 e0       	ldi	r24, 0x01	; 1
    6b22:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6b26:	8b 81       	ldd	r24, Y+3	; 0x03
    6b28:	88 23       	and	r24, r24
    6b2a:	49 f0       	breq	.+18     	; 0x6b3e <PortEx_DIRCLR+0x38>
    6b2c:	80 91 65 50 	lds	r24, 0x5065
    6b30:	98 2f       	mov	r25, r24
    6b32:	90 95       	com	r25
    6b34:	8a 81       	ldd	r24, Y+2	; 0x02
    6b36:	89 23       	and	r24, r25
    6b38:	80 93 65 50 	sts	0x5065, r24
    6b3c:	08 c0       	rjmp	.+16     	; 0x6b4e <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    6b3e:	80 91 d5 50 	lds	r24, 0x50D5
    6b42:	98 2f       	mov	r25, r24
    6b44:	90 95       	com	r25
    6b46:	8a 81       	ldd	r24, Y+2	; 0x02
    6b48:	89 23       	and	r24, r25
    6b4a:	80 93 d5 50 	sts	0x50D5, r24
	
	SPIBuffer[0] = PS_WRITE;
    6b4e:	80 e4       	ldi	r24, 0x40	; 64
    6b50:	80 93 54 50 	sts	0x5054, r24
	if(bank) {
    6b54:	8b 81       	ldd	r24, Y+3	; 0x03
    6b56:	88 23       	and	r24, r24
    6b58:	41 f0       	breq	.+16     	; 0x6b6a <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    6b5a:	10 92 55 50 	sts	0x5055, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6b5e:	80 91 65 50 	lds	r24, 0x5065
    6b62:	80 95       	com	r24
    6b64:	80 93 56 50 	sts	0x5056, r24
    6b68:	08 c0       	rjmp	.+16     	; 0x6b7a <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6b6a:	81 e0       	ldi	r24, 0x01	; 1
    6b6c:	80 93 55 50 	sts	0x5055, r24
		SPIBuffer[2] = ~bankB_DIR;
    6b70:	80 91 d5 50 	lds	r24, 0x50D5
    6b74:	80 95       	com	r24
    6b76:	80 93 56 50 	sts	0x5056, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6b7a:	19 82       	std	Y+1, r1	; 0x01
    6b7c:	1b c0       	rjmp	.+54     	; 0x6bb4 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    6b7e:	80 ec       	ldi	r24, 0xC0	; 192
    6b80:	98 e0       	ldi	r25, 0x08	; 8
    6b82:	29 81       	ldd	r18, Y+1	; 0x01
    6b84:	22 2f       	mov	r18, r18
    6b86:	30 e0       	ldi	r19, 0x00	; 0
    6b88:	2c 5a       	subi	r18, 0xAC	; 172
    6b8a:	3f 4a       	sbci	r19, 0xAF	; 175
    6b8c:	f9 01       	movw	r30, r18
    6b8e:	20 81       	ld	r18, Z
    6b90:	fc 01       	movw	r30, r24
    6b92:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6b94:	00 00       	nop
    6b96:	80 ec       	ldi	r24, 0xC0	; 192
    6b98:	98 e0       	ldi	r25, 0x08	; 8
    6b9a:	fc 01       	movw	r30, r24
    6b9c:	82 81       	ldd	r24, Z+2	; 0x02
    6b9e:	88 23       	and	r24, r24
    6ba0:	d4 f7       	brge	.-12     	; 0x6b96 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6ba2:	80 ec       	ldi	r24, 0xC0	; 192
    6ba4:	98 e0       	ldi	r25, 0x08	; 8
    6ba6:	fc 01       	movw	r30, r24
    6ba8:	83 81       	ldd	r24, Z+3	; 0x03
    6baa:	80 93 60 50 	sts	0x5060, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6bae:	89 81       	ldd	r24, Y+1	; 0x01
    6bb0:	8f 5f       	subi	r24, 0xFF	; 255
    6bb2:	89 83       	std	Y+1, r24	; 0x01
    6bb4:	89 81       	ldd	r24, Y+1	; 0x01
    6bb6:	83 30       	cpi	r24, 0x03	; 3
    6bb8:	10 f3       	brcs	.-60     	; 0x6b7e <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6bba:	80 e0       	ldi	r24, 0x00	; 0
    6bbc:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	portExCS(FALSE);
    6bc0:	80 e0       	ldi	r24, 0x00	; 0
    6bc2:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>
	SPIDisable();
    6bc6:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
}
    6bca:	23 96       	adiw	r28, 0x03	; 3
    6bcc:	cd bf       	out	0x3d, r28	; 61
    6bce:	de bf       	out	0x3e, r29	; 62
    6bd0:	df 91       	pop	r29
    6bd2:	cf 91       	pop	r28
    6bd4:	08 95       	ret

00006bd6 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6bd6:	cf 93       	push	r28
    6bd8:	df 93       	push	r29
    6bda:	00 d0       	rcall	.+0      	; 0x6bdc <PortEx_OUTSET+0x6>
    6bdc:	cd b7       	in	r28, 0x3d	; 61
    6bde:	de b7       	in	r29, 0x3e	; 62
    6be0:	8a 83       	std	Y+2, r24	; 0x02
    6be2:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6be4:	80 e0       	ldi	r24, 0x00	; 0
    6be6:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    6bea:	81 e0       	ldi	r24, 0x01	; 1
    6bec:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	portExCS(TRUE);
    6bf0:	81 e0       	ldi	r24, 0x01	; 1
    6bf2:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    6bf8:	88 23       	and	r24, r24
    6bfa:	39 f0       	breq	.+14     	; 0x6c0a <PortEx_OUTSET+0x34>
    6bfc:	90 91 c5 23 	lds	r25, 0x23C5
    6c00:	8a 81       	ldd	r24, Y+2	; 0x02
    6c02:	89 2b       	or	r24, r25
    6c04:	80 93 c5 23 	sts	0x23C5, r24
    6c08:	06 c0       	rjmp	.+12     	; 0x6c16 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6c0a:	90 91 6d 50 	lds	r25, 0x506D
    6c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    6c10:	89 2b       	or	r24, r25
    6c12:	80 93 6d 50 	sts	0x506D, r24
	
	SPIBuffer[0] = PS_WRITE;
    6c16:	80 e4       	ldi	r24, 0x40	; 64
    6c18:	80 93 54 50 	sts	0x5054, r24
	if(bank) {
    6c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    6c1e:	88 23       	and	r24, r24
    6c20:	41 f0       	breq	.+16     	; 0x6c32 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6c22:	84 e1       	ldi	r24, 0x14	; 20
    6c24:	80 93 55 50 	sts	0x5055, r24
		SPIBuffer[2] = bankA_OUT;
    6c28:	80 91 c5 23 	lds	r24, 0x23C5
    6c2c:	80 93 56 50 	sts	0x5056, r24
    6c30:	07 c0       	rjmp	.+14     	; 0x6c40 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6c32:	85 e1       	ldi	r24, 0x15	; 21
    6c34:	80 93 55 50 	sts	0x5055, r24
		SPIBuffer[2] = bankB_OUT; 
    6c38:	80 91 6d 50 	lds	r24, 0x506D
    6c3c:	80 93 56 50 	sts	0x5056, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6c40:	19 82       	std	Y+1, r1	; 0x01
    6c42:	1b c0       	rjmp	.+54     	; 0x6c7a <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6c44:	80 ec       	ldi	r24, 0xC0	; 192
    6c46:	98 e0       	ldi	r25, 0x08	; 8
    6c48:	29 81       	ldd	r18, Y+1	; 0x01
    6c4a:	22 2f       	mov	r18, r18
    6c4c:	30 e0       	ldi	r19, 0x00	; 0
    6c4e:	2c 5a       	subi	r18, 0xAC	; 172
    6c50:	3f 4a       	sbci	r19, 0xAF	; 175
    6c52:	f9 01       	movw	r30, r18
    6c54:	20 81       	ld	r18, Z
    6c56:	fc 01       	movw	r30, r24
    6c58:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6c5a:	00 00       	nop
    6c5c:	80 ec       	ldi	r24, 0xC0	; 192
    6c5e:	98 e0       	ldi	r25, 0x08	; 8
    6c60:	fc 01       	movw	r30, r24
    6c62:	82 81       	ldd	r24, Z+2	; 0x02
    6c64:	88 23       	and	r24, r24
    6c66:	d4 f7       	brge	.-12     	; 0x6c5c <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6c68:	80 ec       	ldi	r24, 0xC0	; 192
    6c6a:	98 e0       	ldi	r25, 0x08	; 8
    6c6c:	fc 01       	movw	r30, r24
    6c6e:	83 81       	ldd	r24, Z+3	; 0x03
    6c70:	80 93 60 50 	sts	0x5060, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6c74:	89 81       	ldd	r24, Y+1	; 0x01
    6c76:	8f 5f       	subi	r24, 0xFF	; 255
    6c78:	89 83       	std	Y+1, r24	; 0x01
    6c7a:	89 81       	ldd	r24, Y+1	; 0x01
    6c7c:	83 30       	cpi	r24, 0x03	; 3
    6c7e:	10 f3       	brcs	.-60     	; 0x6c44 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6c80:	80 e0       	ldi	r24, 0x00	; 0
    6c82:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	portExCS(FALSE);
    6c86:	80 e0       	ldi	r24, 0x00	; 0
    6c88:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>
	SPIDisable();
    6c8c:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
}
    6c90:	23 96       	adiw	r28, 0x03	; 3
    6c92:	cd bf       	out	0x3d, r28	; 61
    6c94:	de bf       	out	0x3e, r29	; 62
    6c96:	df 91       	pop	r29
    6c98:	cf 91       	pop	r28
    6c9a:	08 95       	ret

00006c9c <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    6c9c:	cf 93       	push	r28
    6c9e:	df 93       	push	r29
    6ca0:	00 d0       	rcall	.+0      	; 0x6ca2 <PortEx_OUTCLR+0x6>
    6ca2:	cd b7       	in	r28, 0x3d	; 61
    6ca4:	de b7       	in	r29, 0x3e	; 62
    6ca6:	8a 83       	std	Y+2, r24	; 0x02
    6ca8:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6caa:	80 e0       	ldi	r24, 0x00	; 0
    6cac:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    6cb0:	81 e0       	ldi	r24, 0x01	; 1
    6cb2:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	portExCS(TRUE);
    6cb6:	81 e0       	ldi	r24, 0x01	; 1
    6cb8:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    6cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    6cbe:	88 23       	and	r24, r24
    6cc0:	49 f0       	breq	.+18     	; 0x6cd4 <PortEx_OUTCLR+0x38>
    6cc2:	8a 81       	ldd	r24, Y+2	; 0x02
    6cc4:	98 2f       	mov	r25, r24
    6cc6:	90 95       	com	r25
    6cc8:	80 91 c5 23 	lds	r24, 0x23C5
    6ccc:	89 23       	and	r24, r25
    6cce:	80 93 c5 23 	sts	0x23C5, r24
    6cd2:	08 c0       	rjmp	.+16     	; 0x6ce4 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6cd4:	8a 81       	ldd	r24, Y+2	; 0x02
    6cd6:	98 2f       	mov	r25, r24
    6cd8:	90 95       	com	r25
    6cda:	80 91 6d 50 	lds	r24, 0x506D
    6cde:	89 23       	and	r24, r25
    6ce0:	80 93 6d 50 	sts	0x506D, r24
	
	SPIBuffer[0] = PS_WRITE;
    6ce4:	80 e4       	ldi	r24, 0x40	; 64
    6ce6:	80 93 54 50 	sts	0x5054, r24
	if(bank) {
    6cea:	8b 81       	ldd	r24, Y+3	; 0x03
    6cec:	88 23       	and	r24, r24
    6cee:	41 f0       	breq	.+16     	; 0x6d00 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6cf0:	84 e1       	ldi	r24, 0x14	; 20
    6cf2:	80 93 55 50 	sts	0x5055, r24
		SPIBuffer[2] = bankA_OUT;
    6cf6:	80 91 c5 23 	lds	r24, 0x23C5
    6cfa:	80 93 56 50 	sts	0x5056, r24
    6cfe:	07 c0       	rjmp	.+14     	; 0x6d0e <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6d00:	85 e1       	ldi	r24, 0x15	; 21
    6d02:	80 93 55 50 	sts	0x5055, r24
		SPIBuffer[2] = bankB_OUT; 
    6d06:	80 91 6d 50 	lds	r24, 0x506D
    6d0a:	80 93 56 50 	sts	0x5056, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d0e:	19 82       	std	Y+1, r1	; 0x01
    6d10:	1b c0       	rjmp	.+54     	; 0x6d48 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6d12:	80 ec       	ldi	r24, 0xC0	; 192
    6d14:	98 e0       	ldi	r25, 0x08	; 8
    6d16:	29 81       	ldd	r18, Y+1	; 0x01
    6d18:	22 2f       	mov	r18, r18
    6d1a:	30 e0       	ldi	r19, 0x00	; 0
    6d1c:	2c 5a       	subi	r18, 0xAC	; 172
    6d1e:	3f 4a       	sbci	r19, 0xAF	; 175
    6d20:	f9 01       	movw	r30, r18
    6d22:	20 81       	ld	r18, Z
    6d24:	fc 01       	movw	r30, r24
    6d26:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6d28:	00 00       	nop
    6d2a:	80 ec       	ldi	r24, 0xC0	; 192
    6d2c:	98 e0       	ldi	r25, 0x08	; 8
    6d2e:	fc 01       	movw	r30, r24
    6d30:	82 81       	ldd	r24, Z+2	; 0x02
    6d32:	88 23       	and	r24, r24
    6d34:	d4 f7       	brge	.-12     	; 0x6d2a <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6d36:	80 ec       	ldi	r24, 0xC0	; 192
    6d38:	98 e0       	ldi	r25, 0x08	; 8
    6d3a:	fc 01       	movw	r30, r24
    6d3c:	83 81       	ldd	r24, Z+3	; 0x03
    6d3e:	80 93 60 50 	sts	0x5060, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d42:	89 81       	ldd	r24, Y+1	; 0x01
    6d44:	8f 5f       	subi	r24, 0xFF	; 255
    6d46:	89 83       	std	Y+1, r24	; 0x01
    6d48:	89 81       	ldd	r24, Y+1	; 0x01
    6d4a:	83 30       	cpi	r24, 0x03	; 3
    6d4c:	10 f3       	brcs	.-60     	; 0x6d12 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6d4e:	80 e0       	ldi	r24, 0x00	; 0
    6d50:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	portExCS(FALSE);
    6d54:	80 e0       	ldi	r24, 0x00	; 0
    6d56:	0e 94 2a 34 	call	0x6854	; 0x6854 <portExCS>
	SPIDisable();
    6d5a:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
}
    6d5e:	23 96       	adiw	r28, 0x03	; 3
    6d60:	cd bf       	out	0x3d, r28	; 61
    6d62:	de bf       	out	0x3e, r29	; 62
    6d64:	df 91       	pop	r29
    6d66:	cf 91       	pop	r28
    6d68:	08 95       	ret

00006d6a <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6d6a:	0f 93       	push	r16
    6d6c:	1f 93       	push	r17
    6d6e:	cf 93       	push	r28
    6d70:	df 93       	push	r29
    6d72:	cd b7       	in	r28, 0x3d	; 61
    6d74:	de b7       	in	r29, 0x3e	; 62
    6d76:	2f 97       	sbiw	r28, 0x0f	; 15
    6d78:	cd bf       	out	0x3d, r28	; 61
    6d7a:	de bf       	out	0x3e, r29	; 62
    6d7c:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6d7e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6d80:	88 23       	and	r24, r24
    6d82:	09 f4       	brne	.+2      	; 0x6d86 <Ext1Power+0x1c>
    6d84:	8b c0       	rjmp	.+278    	; 0x6e9c <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6d86:	80 ea       	ldi	r24, 0xA0	; 160
    6d88:	96 e0       	ldi	r25, 0x06	; 6
    6d8a:	20 e2       	ldi	r18, 0x20	; 32
    6d8c:	fc 01       	movw	r30, r24
    6d8e:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6d90:	80 ea       	ldi	r24, 0xA0	; 160
    6d92:	96 e0       	ldi	r25, 0x06	; 6
    6d94:	20 e2       	ldi	r18, 0x20	; 32
    6d96:	fc 01       	movw	r30, r24
    6d98:	25 83       	std	Z+5, r18	; 0x05
    6d9a:	80 e0       	ldi	r24, 0x00	; 0
    6d9c:	90 e0       	ldi	r25, 0x00	; 0
    6d9e:	a8 ec       	ldi	r26, 0xC8	; 200
    6da0:	b2 e4       	ldi	r27, 0x42	; 66
    6da2:	89 83       	std	Y+1, r24	; 0x01
    6da4:	9a 83       	std	Y+2, r25	; 0x02
    6da6:	ab 83       	std	Y+3, r26	; 0x03
    6da8:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6daa:	69 81       	ldd	r22, Y+1	; 0x01
    6dac:	7a 81       	ldd	r23, Y+2	; 0x02
    6dae:	8b 81       	ldd	r24, Y+3	; 0x03
    6db0:	9c 81       	ldd	r25, Y+4	; 0x04
    6db2:	20 e0       	ldi	r18, 0x00	; 0
    6db4:	30 e0       	ldi	r19, 0x00	; 0
    6db6:	4a ef       	ldi	r20, 0xFA	; 250
    6db8:	55 e4       	ldi	r21, 0x45	; 69
    6dba:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    6dbe:	dc 01       	movw	r26, r24
    6dc0:	cb 01       	movw	r24, r22
    6dc2:	8d 83       	std	Y+5, r24	; 0x05
    6dc4:	9e 83       	std	Y+6, r25	; 0x06
    6dc6:	af 83       	std	Y+7, r26	; 0x07
    6dc8:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6dca:	11 e0       	ldi	r17, 0x01	; 1
    6dcc:	6d 81       	ldd	r22, Y+5	; 0x05
    6dce:	7e 81       	ldd	r23, Y+6	; 0x06
    6dd0:	8f 81       	ldd	r24, Y+7	; 0x07
    6dd2:	98 85       	ldd	r25, Y+8	; 0x08
    6dd4:	20 e0       	ldi	r18, 0x00	; 0
    6dd6:	30 e0       	ldi	r19, 0x00	; 0
    6dd8:	40 e8       	ldi	r20, 0x80	; 128
    6dda:	5f e3       	ldi	r21, 0x3F	; 63
    6ddc:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    6de0:	88 23       	and	r24, r24
    6de2:	0c f0       	brlt	.+2      	; 0x6de6 <Ext1Power+0x7c>
    6de4:	10 e0       	ldi	r17, 0x00	; 0
    6de6:	11 23       	and	r17, r17
    6de8:	29 f0       	breq	.+10     	; 0x6df4 <Ext1Power+0x8a>
		__ticks = 1;
    6dea:	81 e0       	ldi	r24, 0x01	; 1
    6dec:	90 e0       	ldi	r25, 0x00	; 0
    6dee:	89 87       	std	Y+9, r24	; 0x09
    6df0:	9a 87       	std	Y+10, r25	; 0x0a
    6df2:	46 c0       	rjmp	.+140    	; 0x6e80 <Ext1Power+0x116>
	else if (__tmp > 65535)
    6df4:	11 e0       	ldi	r17, 0x01	; 1
    6df6:	6d 81       	ldd	r22, Y+5	; 0x05
    6df8:	7e 81       	ldd	r23, Y+6	; 0x06
    6dfa:	8f 81       	ldd	r24, Y+7	; 0x07
    6dfc:	98 85       	ldd	r25, Y+8	; 0x08
    6dfe:	20 e0       	ldi	r18, 0x00	; 0
    6e00:	3f ef       	ldi	r19, 0xFF	; 255
    6e02:	4f e7       	ldi	r20, 0x7F	; 127
    6e04:	57 e4       	ldi	r21, 0x47	; 71
    6e06:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    6e0a:	18 16       	cp	r1, r24
    6e0c:	0c f0       	brlt	.+2      	; 0x6e10 <Ext1Power+0xa6>
    6e0e:	10 e0       	ldi	r17, 0x00	; 0
    6e10:	11 23       	and	r17, r17
    6e12:	61 f1       	breq	.+88     	; 0x6e6c <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e14:	69 81       	ldd	r22, Y+1	; 0x01
    6e16:	7a 81       	ldd	r23, Y+2	; 0x02
    6e18:	8b 81       	ldd	r24, Y+3	; 0x03
    6e1a:	9c 81       	ldd	r25, Y+4	; 0x04
    6e1c:	20 e0       	ldi	r18, 0x00	; 0
    6e1e:	30 e0       	ldi	r19, 0x00	; 0
    6e20:	40 e2       	ldi	r20, 0x20	; 32
    6e22:	51 e4       	ldi	r21, 0x41	; 65
    6e24:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    6e28:	dc 01       	movw	r26, r24
    6e2a:	cb 01       	movw	r24, r22
    6e2c:	bc 01       	movw	r22, r24
    6e2e:	cd 01       	movw	r24, r26
    6e30:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    6e34:	dc 01       	movw	r26, r24
    6e36:	cb 01       	movw	r24, r22
    6e38:	89 87       	std	Y+9, r24	; 0x09
    6e3a:	9a 87       	std	Y+10, r25	; 0x0a
    6e3c:	12 c0       	rjmp	.+36     	; 0x6e62 <Ext1Power+0xf8>
    6e3e:	80 e2       	ldi	r24, 0x20	; 32
    6e40:	93 e0       	ldi	r25, 0x03	; 3
    6e42:	8b 87       	std	Y+11, r24	; 0x0b
    6e44:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6e46:	8b 85       	ldd	r24, Y+11	; 0x0b
    6e48:	9c 85       	ldd	r25, Y+12	; 0x0c
    6e4a:	8c 01       	movw	r16, r24
    6e4c:	c8 01       	movw	r24, r16
    6e4e:	01 97       	sbiw	r24, 0x01	; 1
    6e50:	f1 f7       	brne	.-4      	; 0x6e4e <Ext1Power+0xe4>
    6e52:	8c 01       	movw	r16, r24
    6e54:	0b 87       	std	Y+11, r16	; 0x0b
    6e56:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e58:	89 85       	ldd	r24, Y+9	; 0x09
    6e5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e5c:	01 97       	sbiw	r24, 0x01	; 1
    6e5e:	89 87       	std	Y+9, r24	; 0x09
    6e60:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e62:	89 85       	ldd	r24, Y+9	; 0x09
    6e64:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e66:	00 97       	sbiw	r24, 0x00	; 0
    6e68:	51 f7       	brne	.-44     	; 0x6e3e <Ext1Power+0xd4>
    6e6a:	22 c0       	rjmp	.+68     	; 0x6eb0 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e6c:	6d 81       	ldd	r22, Y+5	; 0x05
    6e6e:	7e 81       	ldd	r23, Y+6	; 0x06
    6e70:	8f 81       	ldd	r24, Y+7	; 0x07
    6e72:	98 85       	ldd	r25, Y+8	; 0x08
    6e74:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    6e78:	dc 01       	movw	r26, r24
    6e7a:	cb 01       	movw	r24, r22
    6e7c:	89 87       	std	Y+9, r24	; 0x09
    6e7e:	9a 87       	std	Y+10, r25	; 0x0a
    6e80:	89 85       	ldd	r24, Y+9	; 0x09
    6e82:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e84:	8d 87       	std	Y+13, r24	; 0x0d
    6e86:	9e 87       	std	Y+14, r25	; 0x0e
    6e88:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e8c:	8c 01       	movw	r16, r24
    6e8e:	f8 01       	movw	r30, r16
    6e90:	31 97       	sbiw	r30, 0x01	; 1
    6e92:	f1 f7       	brne	.-4      	; 0x6e90 <Ext1Power+0x126>
    6e94:	8f 01       	movw	r16, r30
    6e96:	0d 87       	std	Y+13, r16	; 0x0d
    6e98:	1e 87       	std	Y+14, r17	; 0x0e
    6e9a:	0a c0       	rjmp	.+20     	; 0x6eb0 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6e9c:	80 ea       	ldi	r24, 0xA0	; 160
    6e9e:	96 e0       	ldi	r25, 0x06	; 6
    6ea0:	20 e2       	ldi	r18, 0x20	; 32
    6ea2:	fc 01       	movw	r30, r24
    6ea4:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6ea6:	80 ea       	ldi	r24, 0xA0	; 160
    6ea8:	96 e0       	ldi	r25, 0x06	; 6
    6eaa:	20 e2       	ldi	r18, 0x20	; 32
    6eac:	fc 01       	movw	r30, r24
    6eae:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6eb0:	2f 96       	adiw	r28, 0x0f	; 15
    6eb2:	cd bf       	out	0x3d, r28	; 61
    6eb4:	de bf       	out	0x3e, r29	; 62
    6eb6:	df 91       	pop	r29
    6eb8:	cf 91       	pop	r28
    6eba:	1f 91       	pop	r17
    6ebc:	0f 91       	pop	r16
    6ebe:	08 95       	ret

00006ec0 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6ec0:	0f 93       	push	r16
    6ec2:	1f 93       	push	r17
    6ec4:	cf 93       	push	r28
    6ec6:	df 93       	push	r29
    6ec8:	cd b7       	in	r28, 0x3d	; 61
    6eca:	de b7       	in	r29, 0x3e	; 62
    6ecc:	2f 97       	sbiw	r28, 0x0f	; 15
    6ece:	cd bf       	out	0x3d, r28	; 61
    6ed0:	de bf       	out	0x3e, r29	; 62
    6ed2:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6ed4:	8f 85       	ldd	r24, Y+15	; 0x0f
    6ed6:	88 23       	and	r24, r24
    6ed8:	09 f4       	brne	.+2      	; 0x6edc <Ext2Power+0x1c>
    6eda:	8b c0       	rjmp	.+278    	; 0x6ff2 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6edc:	80 ea       	ldi	r24, 0xA0	; 160
    6ede:	96 e0       	ldi	r25, 0x06	; 6
    6ee0:	20 e4       	ldi	r18, 0x40	; 64
    6ee2:	fc 01       	movw	r30, r24
    6ee4:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6ee6:	80 ea       	ldi	r24, 0xA0	; 160
    6ee8:	96 e0       	ldi	r25, 0x06	; 6
    6eea:	20 e4       	ldi	r18, 0x40	; 64
    6eec:	fc 01       	movw	r30, r24
    6eee:	25 83       	std	Z+5, r18	; 0x05
    6ef0:	80 e0       	ldi	r24, 0x00	; 0
    6ef2:	90 e0       	ldi	r25, 0x00	; 0
    6ef4:	a8 ec       	ldi	r26, 0xC8	; 200
    6ef6:	b2 e4       	ldi	r27, 0x42	; 66
    6ef8:	89 83       	std	Y+1, r24	; 0x01
    6efa:	9a 83       	std	Y+2, r25	; 0x02
    6efc:	ab 83       	std	Y+3, r26	; 0x03
    6efe:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6f00:	69 81       	ldd	r22, Y+1	; 0x01
    6f02:	7a 81       	ldd	r23, Y+2	; 0x02
    6f04:	8b 81       	ldd	r24, Y+3	; 0x03
    6f06:	9c 81       	ldd	r25, Y+4	; 0x04
    6f08:	20 e0       	ldi	r18, 0x00	; 0
    6f0a:	30 e0       	ldi	r19, 0x00	; 0
    6f0c:	4a ef       	ldi	r20, 0xFA	; 250
    6f0e:	55 e4       	ldi	r21, 0x45	; 69
    6f10:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    6f14:	dc 01       	movw	r26, r24
    6f16:	cb 01       	movw	r24, r22
    6f18:	8d 83       	std	Y+5, r24	; 0x05
    6f1a:	9e 83       	std	Y+6, r25	; 0x06
    6f1c:	af 83       	std	Y+7, r26	; 0x07
    6f1e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6f20:	11 e0       	ldi	r17, 0x01	; 1
    6f22:	6d 81       	ldd	r22, Y+5	; 0x05
    6f24:	7e 81       	ldd	r23, Y+6	; 0x06
    6f26:	8f 81       	ldd	r24, Y+7	; 0x07
    6f28:	98 85       	ldd	r25, Y+8	; 0x08
    6f2a:	20 e0       	ldi	r18, 0x00	; 0
    6f2c:	30 e0       	ldi	r19, 0x00	; 0
    6f2e:	40 e8       	ldi	r20, 0x80	; 128
    6f30:	5f e3       	ldi	r21, 0x3F	; 63
    6f32:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    6f36:	88 23       	and	r24, r24
    6f38:	0c f0       	brlt	.+2      	; 0x6f3c <Ext2Power+0x7c>
    6f3a:	10 e0       	ldi	r17, 0x00	; 0
    6f3c:	11 23       	and	r17, r17
    6f3e:	29 f0       	breq	.+10     	; 0x6f4a <Ext2Power+0x8a>
		__ticks = 1;
    6f40:	81 e0       	ldi	r24, 0x01	; 1
    6f42:	90 e0       	ldi	r25, 0x00	; 0
    6f44:	89 87       	std	Y+9, r24	; 0x09
    6f46:	9a 87       	std	Y+10, r25	; 0x0a
    6f48:	46 c0       	rjmp	.+140    	; 0x6fd6 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6f4a:	11 e0       	ldi	r17, 0x01	; 1
    6f4c:	6d 81       	ldd	r22, Y+5	; 0x05
    6f4e:	7e 81       	ldd	r23, Y+6	; 0x06
    6f50:	8f 81       	ldd	r24, Y+7	; 0x07
    6f52:	98 85       	ldd	r25, Y+8	; 0x08
    6f54:	20 e0       	ldi	r18, 0x00	; 0
    6f56:	3f ef       	ldi	r19, 0xFF	; 255
    6f58:	4f e7       	ldi	r20, 0x7F	; 127
    6f5a:	57 e4       	ldi	r21, 0x47	; 71
    6f5c:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    6f60:	18 16       	cp	r1, r24
    6f62:	0c f0       	brlt	.+2      	; 0x6f66 <Ext2Power+0xa6>
    6f64:	10 e0       	ldi	r17, 0x00	; 0
    6f66:	11 23       	and	r17, r17
    6f68:	61 f1       	breq	.+88     	; 0x6fc2 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6f6a:	69 81       	ldd	r22, Y+1	; 0x01
    6f6c:	7a 81       	ldd	r23, Y+2	; 0x02
    6f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    6f70:	9c 81       	ldd	r25, Y+4	; 0x04
    6f72:	20 e0       	ldi	r18, 0x00	; 0
    6f74:	30 e0       	ldi	r19, 0x00	; 0
    6f76:	40 e2       	ldi	r20, 0x20	; 32
    6f78:	51 e4       	ldi	r21, 0x41	; 65
    6f7a:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    6f7e:	dc 01       	movw	r26, r24
    6f80:	cb 01       	movw	r24, r22
    6f82:	bc 01       	movw	r22, r24
    6f84:	cd 01       	movw	r24, r26
    6f86:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    6f8a:	dc 01       	movw	r26, r24
    6f8c:	cb 01       	movw	r24, r22
    6f8e:	89 87       	std	Y+9, r24	; 0x09
    6f90:	9a 87       	std	Y+10, r25	; 0x0a
    6f92:	12 c0       	rjmp	.+36     	; 0x6fb8 <Ext2Power+0xf8>
    6f94:	80 e2       	ldi	r24, 0x20	; 32
    6f96:	93 e0       	ldi	r25, 0x03	; 3
    6f98:	8b 87       	std	Y+11, r24	; 0x0b
    6f9a:	9c 87       	std	Y+12, r25	; 0x0c
    6f9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6f9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6fa0:	8c 01       	movw	r16, r24
    6fa2:	c8 01       	movw	r24, r16
    6fa4:	01 97       	sbiw	r24, 0x01	; 1
    6fa6:	f1 f7       	brne	.-4      	; 0x6fa4 <Ext2Power+0xe4>
    6fa8:	8c 01       	movw	r16, r24
    6faa:	0b 87       	std	Y+11, r16	; 0x0b
    6fac:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6fae:	89 85       	ldd	r24, Y+9	; 0x09
    6fb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fb2:	01 97       	sbiw	r24, 0x01	; 1
    6fb4:	89 87       	std	Y+9, r24	; 0x09
    6fb6:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6fb8:	89 85       	ldd	r24, Y+9	; 0x09
    6fba:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fbc:	00 97       	sbiw	r24, 0x00	; 0
    6fbe:	51 f7       	brne	.-44     	; 0x6f94 <Ext2Power+0xd4>
    6fc0:	22 c0       	rjmp	.+68     	; 0x7006 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6fc2:	6d 81       	ldd	r22, Y+5	; 0x05
    6fc4:	7e 81       	ldd	r23, Y+6	; 0x06
    6fc6:	8f 81       	ldd	r24, Y+7	; 0x07
    6fc8:	98 85       	ldd	r25, Y+8	; 0x08
    6fca:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    6fce:	dc 01       	movw	r26, r24
    6fd0:	cb 01       	movw	r24, r22
    6fd2:	89 87       	std	Y+9, r24	; 0x09
    6fd4:	9a 87       	std	Y+10, r25	; 0x0a
    6fd6:	89 85       	ldd	r24, Y+9	; 0x09
    6fd8:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fda:	8d 87       	std	Y+13, r24	; 0x0d
    6fdc:	9e 87       	std	Y+14, r25	; 0x0e
    6fde:	8d 85       	ldd	r24, Y+13	; 0x0d
    6fe0:	9e 85       	ldd	r25, Y+14	; 0x0e
    6fe2:	8c 01       	movw	r16, r24
    6fe4:	f8 01       	movw	r30, r16
    6fe6:	31 97       	sbiw	r30, 0x01	; 1
    6fe8:	f1 f7       	brne	.-4      	; 0x6fe6 <Ext2Power+0x126>
    6fea:	8f 01       	movw	r16, r30
    6fec:	0d 87       	std	Y+13, r16	; 0x0d
    6fee:	1e 87       	std	Y+14, r17	; 0x0e
    6ff0:	0a c0       	rjmp	.+20     	; 0x7006 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6ff2:	80 ea       	ldi	r24, 0xA0	; 160
    6ff4:	96 e0       	ldi	r25, 0x06	; 6
    6ff6:	20 e4       	ldi	r18, 0x40	; 64
    6ff8:	fc 01       	movw	r30, r24
    6ffa:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6ffc:	80 ea       	ldi	r24, 0xA0	; 160
    6ffe:	96 e0       	ldi	r25, 0x06	; 6
    7000:	20 e4       	ldi	r18, 0x40	; 64
    7002:	fc 01       	movw	r30, r24
    7004:	22 83       	std	Z+2, r18	; 0x02
	}
}
    7006:	2f 96       	adiw	r28, 0x0f	; 15
    7008:	cd bf       	out	0x3d, r28	; 61
    700a:	de bf       	out	0x3e, r29	; 62
    700c:	df 91       	pop	r29
    700e:	cf 91       	pop	r28
    7010:	1f 91       	pop	r17
    7012:	0f 91       	pop	r16
    7014:	08 95       	ret

00007016 <HVPower>:

void HVPower(uint8_t on) {
    7016:	0f 93       	push	r16
    7018:	1f 93       	push	r17
    701a:	cf 93       	push	r28
    701c:	df 93       	push	r29
    701e:	cd b7       	in	r28, 0x3d	; 61
    7020:	de b7       	in	r29, 0x3e	; 62
    7022:	a7 97       	sbiw	r28, 0x27	; 39
    7024:	cd bf       	out	0x3d, r28	; 61
    7026:	de bf       	out	0x3e, r29	; 62
    7028:	8f a3       	lds	r24, 0x5f
	if (on) {
    702a:	8f a1       	lds	r24, 0x4f
    702c:	88 23       	and	r24, r24
    702e:	09 f4       	brne	.+2      	; 0x7032 <HVPower+0x1c>
    7030:	8b c0       	rjmp	.+278    	; 0x7148 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    7032:	80 ea       	ldi	r24, 0xA0	; 160
    7034:	96 e0       	ldi	r25, 0x06	; 6
    7036:	20 e8       	ldi	r18, 0x80	; 128
    7038:	fc 01       	movw	r30, r24
    703a:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    703c:	80 ea       	ldi	r24, 0xA0	; 160
    703e:	96 e0       	ldi	r25, 0x06	; 6
    7040:	20 e8       	ldi	r18, 0x80	; 128
    7042:	fc 01       	movw	r30, r24
    7044:	25 83       	std	Z+5, r18	; 0x05
    7046:	80 e0       	ldi	r24, 0x00	; 0
    7048:	90 e0       	ldi	r25, 0x00	; 0
    704a:	a8 ec       	ldi	r26, 0xC8	; 200
    704c:	b2 e4       	ldi	r27, 0x42	; 66
    704e:	89 83       	std	Y+1, r24	; 0x01
    7050:	9a 83       	std	Y+2, r25	; 0x02
    7052:	ab 83       	std	Y+3, r26	; 0x03
    7054:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7056:	69 81       	ldd	r22, Y+1	; 0x01
    7058:	7a 81       	ldd	r23, Y+2	; 0x02
    705a:	8b 81       	ldd	r24, Y+3	; 0x03
    705c:	9c 81       	ldd	r25, Y+4	; 0x04
    705e:	20 e0       	ldi	r18, 0x00	; 0
    7060:	30 e0       	ldi	r19, 0x00	; 0
    7062:	4a ef       	ldi	r20, 0xFA	; 250
    7064:	55 e4       	ldi	r21, 0x45	; 69
    7066:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    706a:	dc 01       	movw	r26, r24
    706c:	cb 01       	movw	r24, r22
    706e:	8d 83       	std	Y+5, r24	; 0x05
    7070:	9e 83       	std	Y+6, r25	; 0x06
    7072:	af 83       	std	Y+7, r26	; 0x07
    7074:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7076:	11 e0       	ldi	r17, 0x01	; 1
    7078:	6d 81       	ldd	r22, Y+5	; 0x05
    707a:	7e 81       	ldd	r23, Y+6	; 0x06
    707c:	8f 81       	ldd	r24, Y+7	; 0x07
    707e:	98 85       	ldd	r25, Y+8	; 0x08
    7080:	20 e0       	ldi	r18, 0x00	; 0
    7082:	30 e0       	ldi	r19, 0x00	; 0
    7084:	40 e8       	ldi	r20, 0x80	; 128
    7086:	5f e3       	ldi	r21, 0x3F	; 63
    7088:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    708c:	88 23       	and	r24, r24
    708e:	0c f0       	brlt	.+2      	; 0x7092 <HVPower+0x7c>
    7090:	10 e0       	ldi	r17, 0x00	; 0
    7092:	11 23       	and	r17, r17
    7094:	29 f0       	breq	.+10     	; 0x70a0 <HVPower+0x8a>
		__ticks = 1;
    7096:	81 e0       	ldi	r24, 0x01	; 1
    7098:	90 e0       	ldi	r25, 0x00	; 0
    709a:	89 87       	std	Y+9, r24	; 0x09
    709c:	9a 87       	std	Y+10, r25	; 0x0a
    709e:	46 c0       	rjmp	.+140    	; 0x712c <HVPower+0x116>
	else if (__tmp > 65535)
    70a0:	11 e0       	ldi	r17, 0x01	; 1
    70a2:	6d 81       	ldd	r22, Y+5	; 0x05
    70a4:	7e 81       	ldd	r23, Y+6	; 0x06
    70a6:	8f 81       	ldd	r24, Y+7	; 0x07
    70a8:	98 85       	ldd	r25, Y+8	; 0x08
    70aa:	20 e0       	ldi	r18, 0x00	; 0
    70ac:	3f ef       	ldi	r19, 0xFF	; 255
    70ae:	4f e7       	ldi	r20, 0x7F	; 127
    70b0:	57 e4       	ldi	r21, 0x47	; 71
    70b2:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    70b6:	18 16       	cp	r1, r24
    70b8:	0c f0       	brlt	.+2      	; 0x70bc <HVPower+0xa6>
    70ba:	10 e0       	ldi	r17, 0x00	; 0
    70bc:	11 23       	and	r17, r17
    70be:	61 f1       	breq	.+88     	; 0x7118 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    70c0:	69 81       	ldd	r22, Y+1	; 0x01
    70c2:	7a 81       	ldd	r23, Y+2	; 0x02
    70c4:	8b 81       	ldd	r24, Y+3	; 0x03
    70c6:	9c 81       	ldd	r25, Y+4	; 0x04
    70c8:	20 e0       	ldi	r18, 0x00	; 0
    70ca:	30 e0       	ldi	r19, 0x00	; 0
    70cc:	40 e2       	ldi	r20, 0x20	; 32
    70ce:	51 e4       	ldi	r21, 0x41	; 65
    70d0:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    70d4:	dc 01       	movw	r26, r24
    70d6:	cb 01       	movw	r24, r22
    70d8:	bc 01       	movw	r22, r24
    70da:	cd 01       	movw	r24, r26
    70dc:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    70e0:	dc 01       	movw	r26, r24
    70e2:	cb 01       	movw	r24, r22
    70e4:	89 87       	std	Y+9, r24	; 0x09
    70e6:	9a 87       	std	Y+10, r25	; 0x0a
    70e8:	12 c0       	rjmp	.+36     	; 0x710e <HVPower+0xf8>
    70ea:	80 e2       	ldi	r24, 0x20	; 32
    70ec:	93 e0       	ldi	r25, 0x03	; 3
    70ee:	8b 87       	std	Y+11, r24	; 0x0b
    70f0:	9c 87       	std	Y+12, r25	; 0x0c
    70f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    70f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    70f6:	8c 01       	movw	r16, r24
    70f8:	c8 01       	movw	r24, r16
    70fa:	01 97       	sbiw	r24, 0x01	; 1
    70fc:	f1 f7       	brne	.-4      	; 0x70fa <HVPower+0xe4>
    70fe:	8c 01       	movw	r16, r24
    7100:	0b 87       	std	Y+11, r16	; 0x0b
    7102:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7104:	89 85       	ldd	r24, Y+9	; 0x09
    7106:	9a 85       	ldd	r25, Y+10	; 0x0a
    7108:	01 97       	sbiw	r24, 0x01	; 1
    710a:	89 87       	std	Y+9, r24	; 0x09
    710c:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    710e:	89 85       	ldd	r24, Y+9	; 0x09
    7110:	9a 85       	ldd	r25, Y+10	; 0x0a
    7112:	00 97       	sbiw	r24, 0x00	; 0
    7114:	51 f7       	brne	.-44     	; 0x70ea <HVPower+0xd4>
    7116:	22 c0       	rjmp	.+68     	; 0x715c <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7118:	6d 81       	ldd	r22, Y+5	; 0x05
    711a:	7e 81       	ldd	r23, Y+6	; 0x06
    711c:	8f 81       	ldd	r24, Y+7	; 0x07
    711e:	98 85       	ldd	r25, Y+8	; 0x08
    7120:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7124:	dc 01       	movw	r26, r24
    7126:	cb 01       	movw	r24, r22
    7128:	89 87       	std	Y+9, r24	; 0x09
    712a:	9a 87       	std	Y+10, r25	; 0x0a
    712c:	89 85       	ldd	r24, Y+9	; 0x09
    712e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7130:	8d 87       	std	Y+13, r24	; 0x0d
    7132:	9e 87       	std	Y+14, r25	; 0x0e
    7134:	8d 85       	ldd	r24, Y+13	; 0x0d
    7136:	9e 85       	ldd	r25, Y+14	; 0x0e
    7138:	8c 01       	movw	r16, r24
    713a:	f8 01       	movw	r30, r16
    713c:	31 97       	sbiw	r30, 0x01	; 1
    713e:	f1 f7       	brne	.-4      	; 0x713c <HVPower+0x126>
    7140:	8f 01       	movw	r16, r30
    7142:	0d 87       	std	Y+13, r16	; 0x0d
    7144:	1e 87       	std	Y+14, r17	; 0x0e
    7146:	0a c0       	rjmp	.+20     	; 0x715c <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    7148:	80 ea       	ldi	r24, 0xA0	; 160
    714a:	96 e0       	ldi	r25, 0x06	; 6
    714c:	20 e8       	ldi	r18, 0x80	; 128
    714e:	fc 01       	movw	r30, r24
    7150:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    7152:	80 ea       	ldi	r24, 0xA0	; 160
    7154:	96 e0       	ldi	r25, 0x06	; 6
    7156:	20 e8       	ldi	r18, 0x80	; 128
    7158:	fc 01       	movw	r30, r24
    715a:	22 83       	std	Z+2, r18	; 0x02
    715c:	80 e0       	ldi	r24, 0x00	; 0
    715e:	90 e0       	ldi	r25, 0x00	; 0
    7160:	aa e7       	ldi	r26, 0x7A	; 122
    7162:	b4 e4       	ldi	r27, 0x44	; 68
    7164:	8f 87       	std	Y+15, r24	; 0x0f
    7166:	98 8b       	std	Y+16, r25	; 0x10
    7168:	a9 8b       	std	Y+17, r26	; 0x11
    716a:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    716c:	6f 85       	ldd	r22, Y+15	; 0x0f
    716e:	78 89       	ldd	r23, Y+16	; 0x10
    7170:	89 89       	ldd	r24, Y+17	; 0x11
    7172:	9a 89       	ldd	r25, Y+18	; 0x12
    7174:	2b ea       	ldi	r18, 0xAB	; 171
    7176:	3a ea       	ldi	r19, 0xAA	; 170
    7178:	4a e2       	ldi	r20, 0x2A	; 42
    717a:	51 e4       	ldi	r21, 0x41	; 65
    717c:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7180:	dc 01       	movw	r26, r24
    7182:	cb 01       	movw	r24, r22
    7184:	8b 8b       	std	Y+19, r24	; 0x13
    7186:	9c 8b       	std	Y+20, r25	; 0x14
    7188:	ad 8b       	std	Y+21, r26	; 0x15
    718a:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    718c:	11 e0       	ldi	r17, 0x01	; 1
    718e:	6b 89       	ldd	r22, Y+19	; 0x13
    7190:	7c 89       	ldd	r23, Y+20	; 0x14
    7192:	8d 89       	ldd	r24, Y+21	; 0x15
    7194:	9e 89       	ldd	r25, Y+22	; 0x16
    7196:	20 e0       	ldi	r18, 0x00	; 0
    7198:	30 e0       	ldi	r19, 0x00	; 0
    719a:	40 e8       	ldi	r20, 0x80	; 128
    719c:	5f e3       	ldi	r21, 0x3F	; 63
    719e:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    71a2:	88 23       	and	r24, r24
    71a4:	0c f0       	brlt	.+2      	; 0x71a8 <HVPower+0x192>
    71a6:	10 e0       	ldi	r17, 0x00	; 0
    71a8:	11 23       	and	r17, r17
    71aa:	19 f0       	breq	.+6      	; 0x71b2 <HVPower+0x19c>
		__ticks = 1;
    71ac:	81 e0       	ldi	r24, 0x01	; 1
    71ae:	8f 8b       	std	Y+23, r24	; 0x17
    71b0:	a3 c0       	rjmp	.+326    	; 0x72f8 <HVPower+0x2e2>
	else if (__tmp > 255)
    71b2:	11 e0       	ldi	r17, 0x01	; 1
    71b4:	6b 89       	ldd	r22, Y+19	; 0x13
    71b6:	7c 89       	ldd	r23, Y+20	; 0x14
    71b8:	8d 89       	ldd	r24, Y+21	; 0x15
    71ba:	9e 89       	ldd	r25, Y+22	; 0x16
    71bc:	20 e0       	ldi	r18, 0x00	; 0
    71be:	30 e0       	ldi	r19, 0x00	; 0
    71c0:	4f e7       	ldi	r20, 0x7F	; 127
    71c2:	53 e4       	ldi	r21, 0x43	; 67
    71c4:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    71c8:	18 16       	cp	r1, r24
    71ca:	0c f0       	brlt	.+2      	; 0x71ce <HVPower+0x1b8>
    71cc:	10 e0       	ldi	r17, 0x00	; 0
    71ce:	11 23       	and	r17, r17
    71d0:	09 f4       	brne	.+2      	; 0x71d4 <HVPower+0x1be>
    71d2:	89 c0       	rjmp	.+274    	; 0x72e6 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    71d4:	6f 85       	ldd	r22, Y+15	; 0x0f
    71d6:	78 89       	ldd	r23, Y+16	; 0x10
    71d8:	89 89       	ldd	r24, Y+17	; 0x11
    71da:	9a 89       	ldd	r25, Y+18	; 0x12
    71dc:	20 e0       	ldi	r18, 0x00	; 0
    71de:	30 e0       	ldi	r19, 0x00	; 0
    71e0:	4a e7       	ldi	r20, 0x7A	; 122
    71e2:	54 e4       	ldi	r21, 0x44	; 68
    71e4:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    71e8:	dc 01       	movw	r26, r24
    71ea:	cb 01       	movw	r24, r22
    71ec:	88 8f       	std	Y+24, r24	; 0x18
    71ee:	99 8f       	std	Y+25, r25	; 0x19
    71f0:	aa 8f       	std	Y+26, r26	; 0x1a
    71f2:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    71f4:	68 8d       	ldd	r22, Y+24	; 0x18
    71f6:	79 8d       	ldd	r23, Y+25	; 0x19
    71f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    71fa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    71fc:	20 e0       	ldi	r18, 0x00	; 0
    71fe:	30 e0       	ldi	r19, 0x00	; 0
    7200:	4a ef       	ldi	r20, 0xFA	; 250
    7202:	55 e4       	ldi	r21, 0x45	; 69
    7204:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7208:	dc 01       	movw	r26, r24
    720a:	cb 01       	movw	r24, r22
    720c:	8c 8f       	std	Y+28, r24	; 0x1c
    720e:	9d 8f       	std	Y+29, r25	; 0x1d
    7210:	ae 8f       	std	Y+30, r26	; 0x1e
    7212:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    7214:	11 e0       	ldi	r17, 0x01	; 1
    7216:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7218:	7d 8d       	ldd	r23, Y+29	; 0x1d
    721a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    721c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    721e:	20 e0       	ldi	r18, 0x00	; 0
    7220:	30 e0       	ldi	r19, 0x00	; 0
    7222:	40 e8       	ldi	r20, 0x80	; 128
    7224:	5f e3       	ldi	r21, 0x3F	; 63
    7226:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    722a:	88 23       	and	r24, r24
    722c:	0c f0       	brlt	.+2      	; 0x7230 <HVPower+0x21a>
    722e:	10 e0       	ldi	r17, 0x00	; 0
    7230:	11 23       	and	r17, r17
    7232:	29 f0       	breq	.+10     	; 0x723e <HVPower+0x228>
		__ticks = 1;
    7234:	81 e0       	ldi	r24, 0x01	; 1
    7236:	90 e0       	ldi	r25, 0x00	; 0
    7238:	88 a3       	lds	r24, 0x58
    723a:	99 a3       	lds	r25, 0x59
    723c:	46 c0       	rjmp	.+140    	; 0x72ca <HVPower+0x2b4>
	else if (__tmp > 65535)
    723e:	11 e0       	ldi	r17, 0x01	; 1
    7240:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7242:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7244:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7246:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7248:	20 e0       	ldi	r18, 0x00	; 0
    724a:	3f ef       	ldi	r19, 0xFF	; 255
    724c:	4f e7       	ldi	r20, 0x7F	; 127
    724e:	57 e4       	ldi	r21, 0x47	; 71
    7250:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7254:	18 16       	cp	r1, r24
    7256:	0c f0       	brlt	.+2      	; 0x725a <HVPower+0x244>
    7258:	10 e0       	ldi	r17, 0x00	; 0
    725a:	11 23       	and	r17, r17
    725c:	61 f1       	breq	.+88     	; 0x72b6 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    725e:	68 8d       	ldd	r22, Y+24	; 0x18
    7260:	79 8d       	ldd	r23, Y+25	; 0x19
    7262:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7264:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7266:	20 e0       	ldi	r18, 0x00	; 0
    7268:	30 e0       	ldi	r19, 0x00	; 0
    726a:	40 e2       	ldi	r20, 0x20	; 32
    726c:	51 e4       	ldi	r21, 0x41	; 65
    726e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7272:	dc 01       	movw	r26, r24
    7274:	cb 01       	movw	r24, r22
    7276:	bc 01       	movw	r22, r24
    7278:	cd 01       	movw	r24, r26
    727a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    727e:	dc 01       	movw	r26, r24
    7280:	cb 01       	movw	r24, r22
    7282:	88 a3       	lds	r24, 0x58
    7284:	99 a3       	lds	r25, 0x59
    7286:	12 c0       	rjmp	.+36     	; 0x72ac <HVPower+0x296>
    7288:	80 e2       	ldi	r24, 0x20	; 32
    728a:	93 e0       	ldi	r25, 0x03	; 3
    728c:	8a a3       	lds	r24, 0x5a
    728e:	9b a3       	lds	r25, 0x5b
    7290:	8a a1       	lds	r24, 0x4a
    7292:	9b a1       	lds	r25, 0x4b
    7294:	8c 01       	movw	r16, r24
    7296:	c8 01       	movw	r24, r16
    7298:	01 97       	sbiw	r24, 0x01	; 1
    729a:	f1 f7       	brne	.-4      	; 0x7298 <HVPower+0x282>
    729c:	8c 01       	movw	r16, r24
    729e:	0a a3       	lds	r16, 0x5a
    72a0:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    72a2:	88 a1       	lds	r24, 0x48
    72a4:	99 a1       	lds	r25, 0x49
    72a6:	01 97       	sbiw	r24, 0x01	; 1
    72a8:	88 a3       	lds	r24, 0x58
    72aa:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    72ac:	88 a1       	lds	r24, 0x48
    72ae:	99 a1       	lds	r25, 0x49
    72b0:	00 97       	sbiw	r24, 0x00	; 0
    72b2:	51 f7       	brne	.-44     	; 0x7288 <HVPower+0x272>
    72b4:	28 c0       	rjmp	.+80     	; 0x7306 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    72b6:	6c 8d       	ldd	r22, Y+28	; 0x1c
    72b8:	7d 8d       	ldd	r23, Y+29	; 0x1d
    72ba:	8e 8d       	ldd	r24, Y+30	; 0x1e
    72bc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    72be:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    72c2:	dc 01       	movw	r26, r24
    72c4:	cb 01       	movw	r24, r22
    72c6:	88 a3       	lds	r24, 0x58
    72c8:	99 a3       	lds	r25, 0x59
    72ca:	88 a1       	lds	r24, 0x48
    72cc:	99 a1       	lds	r25, 0x49
    72ce:	8c a3       	lds	r24, 0x5c
    72d0:	9d a3       	lds	r25, 0x5d
    72d2:	8c a1       	lds	r24, 0x4c
    72d4:	9d a1       	lds	r25, 0x4d
    72d6:	8c 01       	movw	r16, r24
    72d8:	f8 01       	movw	r30, r16
    72da:	31 97       	sbiw	r30, 0x01	; 1
    72dc:	f1 f7       	brne	.-4      	; 0x72da <HVPower+0x2c4>
    72de:	8f 01       	movw	r16, r30
    72e0:	0c a3       	lds	r16, 0x5c
    72e2:	1d a3       	lds	r17, 0x5d
    72e4:	10 c0       	rjmp	.+32     	; 0x7306 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    72e6:	6b 89       	ldd	r22, Y+19	; 0x13
    72e8:	7c 89       	ldd	r23, Y+20	; 0x14
    72ea:	8d 89       	ldd	r24, Y+21	; 0x15
    72ec:	9e 89       	ldd	r25, Y+22	; 0x16
    72ee:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    72f2:	dc 01       	movw	r26, r24
    72f4:	cb 01       	movw	r24, r22
    72f6:	8f 8b       	std	Y+23, r24	; 0x17
    72f8:	8f 89       	ldd	r24, Y+23	; 0x17
    72fa:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    72fc:	8e a1       	lds	r24, 0x4e
    72fe:	18 2f       	mov	r17, r24
    7300:	1a 95       	dec	r17
    7302:	f1 f7       	brne	.-4      	; 0x7300 <HVPower+0x2ea>
    7304:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    7306:	a7 96       	adiw	r28, 0x27	; 39
    7308:	cd bf       	out	0x3d, r28	; 61
    730a:	de bf       	out	0x3e, r29	; 62
    730c:	df 91       	pop	r29
    730e:	cf 91       	pop	r28
    7310:	1f 91       	pop	r17
    7312:	0f 91       	pop	r16
    7314:	08 95       	ret

00007316 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    7316:	cf 93       	push	r28
    7318:	df 93       	push	r29
    731a:	0f 92       	push	r0
    731c:	cd b7       	in	r28, 0x3d	; 61
    731e:	de b7       	in	r29, 0x3e	; 62
    7320:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    7322:	89 81       	ldd	r24, Y+1	; 0x01
    7324:	88 23       	and	r24, r24
    7326:	31 f0       	breq	.+12     	; 0x7334 <lowerMuxCS+0x1e>
    7328:	80 e8       	ldi	r24, 0x80	; 128
    732a:	96 e0       	ldi	r25, 0x06	; 6
    732c:	20 e1       	ldi	r18, 0x10	; 16
    732e:	fc 01       	movw	r30, r24
    7330:	26 83       	std	Z+6, r18	; 0x06
    7332:	05 c0       	rjmp	.+10     	; 0x733e <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    7334:	80 e8       	ldi	r24, 0x80	; 128
    7336:	96 e0       	ldi	r25, 0x06	; 6
    7338:	20 e1       	ldi	r18, 0x10	; 16
    733a:	fc 01       	movw	r30, r24
    733c:	25 83       	std	Z+5, r18	; 0x05
}
    733e:	0f 90       	pop	r0
    7340:	df 91       	pop	r29
    7342:	cf 91       	pop	r28
    7344:	08 95       	ret

00007346 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    7346:	cf 93       	push	r28
    7348:	df 93       	push	r29
    734a:	0f 92       	push	r0
    734c:	cd b7       	in	r28, 0x3d	; 61
    734e:	de b7       	in	r29, 0x3e	; 62
    7350:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    7352:	89 81       	ldd	r24, Y+1	; 0x01
    7354:	88 23       	and	r24, r24
    7356:	31 f0       	breq	.+12     	; 0x7364 <upperMuxCS+0x1e>
    7358:	80 e4       	ldi	r24, 0x40	; 64
    735a:	96 e0       	ldi	r25, 0x06	; 6
    735c:	22 e0       	ldi	r18, 0x02	; 2
    735e:	fc 01       	movw	r30, r24
    7360:	26 83       	std	Z+6, r18	; 0x06
    7362:	05 c0       	rjmp	.+10     	; 0x736e <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    7364:	80 e4       	ldi	r24, 0x40	; 64
    7366:	96 e0       	ldi	r25, 0x06	; 6
    7368:	22 e0       	ldi	r18, 0x02	; 2
    736a:	fc 01       	movw	r30, r24
    736c:	25 83       	std	Z+5, r18	; 0x05
}
    736e:	0f 90       	pop	r0
    7370:	df 91       	pop	r29
    7372:	cf 91       	pop	r28
    7374:	08 95       	ret

00007376 <SPIInit>:

void SPIInit(uint8_t mode) {
    7376:	cf 93       	push	r28
    7378:	df 93       	push	r29
    737a:	0f 92       	push	r0
    737c:	cd b7       	in	r28, 0x3d	; 61
    737e:	de b7       	in	r29, 0x3e	; 62
    7380:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    7382:	80 e4       	ldi	r24, 0x40	; 64
    7384:	96 e0       	ldi	r25, 0x06	; 6
    7386:	20 e1       	ldi	r18, 0x10	; 16
    7388:	fc 01       	movw	r30, r24
    738a:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    738c:	80 e4       	ldi	r24, 0x40	; 64
    738e:	96 e0       	ldi	r25, 0x06	; 6
    7390:	28 e3       	ldi	r18, 0x38	; 56
    7392:	fc 01       	movw	r30, r24
    7394:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    7396:	80 e4       	ldi	r24, 0x40	; 64
    7398:	96 e0       	ldi	r25, 0x06	; 6
    739a:	20 e1       	ldi	r18, 0x10	; 16
    739c:	fc 01       	movw	r30, r24
    739e:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    73a0:	80 ec       	ldi	r24, 0xC0	; 192
    73a2:	98 e0       	ldi	r25, 0x08	; 8
    73a4:	29 81       	ldd	r18, Y+1	; 0x01
    73a6:	21 65       	ori	r18, 0x51	; 81
    73a8:	fc 01       	movw	r30, r24
    73aa:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    73ac:	80 ec       	ldi	r24, 0xC0	; 192
    73ae:	98 e0       	ldi	r25, 0x08	; 8
    73b0:	fc 01       	movw	r30, r24
    73b2:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    73b4:	80 e4       	ldi	r24, 0x40	; 64
    73b6:	96 e0       	ldi	r25, 0x06	; 6
    73b8:	20 ea       	ldi	r18, 0xA0	; 160
    73ba:	fc 01       	movw	r30, r24
    73bc:	21 83       	std	Z+1, r18	; 0x01

	
}
    73be:	0f 90       	pop	r0
    73c0:	df 91       	pop	r29
    73c2:	cf 91       	pop	r28
    73c4:	08 95       	ret

000073c6 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    73c6:	cf 93       	push	r28
    73c8:	df 93       	push	r29
    73ca:	0f 92       	push	r0
    73cc:	0f 92       	push	r0
    73ce:	cd b7       	in	r28, 0x3d	; 61
    73d0:	de b7       	in	r29, 0x3e	; 62
    73d2:	89 83       	std	Y+1, r24	; 0x01
    73d4:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    73d6:	80 e4       	ldi	r24, 0x40	; 64
    73d8:	96 e0       	ldi	r25, 0x06	; 6
    73da:	20 e1       	ldi	r18, 0x10	; 16
    73dc:	fc 01       	movw	r30, r24
    73de:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    73e0:	80 e4       	ldi	r24, 0x40	; 64
    73e2:	96 e0       	ldi	r25, 0x06	; 6
    73e4:	28 e3       	ldi	r18, 0x38	; 56
    73e6:	fc 01       	movw	r30, r24
    73e8:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    73ea:	80 e4       	ldi	r24, 0x40	; 64
    73ec:	96 e0       	ldi	r25, 0x06	; 6
    73ee:	20 e1       	ldi	r18, 0x10	; 16
    73f0:	fc 01       	movw	r30, r24
    73f2:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    73f4:	80 ec       	ldi	r24, 0xC0	; 192
    73f6:	98 e0       	ldi	r25, 0x08	; 8
    73f8:	3a 81       	ldd	r19, Y+2	; 0x02
    73fa:	29 81       	ldd	r18, Y+1	; 0x01
    73fc:	23 2b       	or	r18, r19
    73fe:	20 65       	ori	r18, 0x50	; 80
    7400:	fc 01       	movw	r30, r24
    7402:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    7404:	80 ec       	ldi	r24, 0xC0	; 192
    7406:	98 e0       	ldi	r25, 0x08	; 8
    7408:	fc 01       	movw	r30, r24
    740a:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    740c:	80 e4       	ldi	r24, 0x40	; 64
    740e:	96 e0       	ldi	r25, 0x06	; 6
    7410:	20 ea       	ldi	r18, 0xA0	; 160
    7412:	fc 01       	movw	r30, r24
    7414:	21 83       	std	Z+1, r18	; 0x01
}
    7416:	0f 90       	pop	r0
    7418:	0f 90       	pop	r0
    741a:	df 91       	pop	r29
    741c:	cf 91       	pop	r28
    741e:	08 95       	ret

00007420 <SPICS>:

void SPICS(uint8_t enable) {
    7420:	cf 93       	push	r28
    7422:	df 93       	push	r29
    7424:	0f 92       	push	r0
    7426:	cd b7       	in	r28, 0x3d	; 61
    7428:	de b7       	in	r29, 0x3e	; 62
    742a:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    742c:	89 81       	ldd	r24, Y+1	; 0x01
    742e:	88 23       	and	r24, r24
    7430:	31 f0       	breq	.+12     	; 0x743e <SPICS+0x1e>
    7432:	80 e4       	ldi	r24, 0x40	; 64
    7434:	96 e0       	ldi	r25, 0x06	; 6
    7436:	20 e1       	ldi	r18, 0x10	; 16
    7438:	fc 01       	movw	r30, r24
    743a:	26 83       	std	Z+6, r18	; 0x06
    743c:	05 c0       	rjmp	.+10     	; 0x7448 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    743e:	80 e4       	ldi	r24, 0x40	; 64
    7440:	96 e0       	ldi	r25, 0x06	; 6
    7442:	20 e1       	ldi	r18, 0x10	; 16
    7444:	fc 01       	movw	r30, r24
    7446:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    7448:	0f 90       	pop	r0
    744a:	df 91       	pop	r29
    744c:	cf 91       	pop	r28
    744e:	08 95       	ret

00007450 <SPIDisable>:

void SPIDisable() {
    7450:	cf 93       	push	r28
    7452:	df 93       	push	r29
    7454:	cd b7       	in	r28, 0x3d	; 61
    7456:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    7458:	80 e4       	ldi	r24, 0x40	; 64
    745a:	96 e0       	ldi	r25, 0x06	; 6
    745c:	20 e1       	ldi	r18, 0x10	; 16
    745e:	fc 01       	movw	r30, r24
    7460:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    7462:	80 ec       	ldi	r24, 0xC0	; 192
    7464:	98 e0       	ldi	r25, 0x08	; 8
    7466:	fc 01       	movw	r30, r24
    7468:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    746a:	80 e4       	ldi	r24, 0x40	; 64
    746c:	96 e0       	ldi	r25, 0x06	; 6
    746e:	20 e1       	ldi	r18, 0x10	; 16
    7470:	fc 01       	movw	r30, r24
    7472:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    7474:	80 e4       	ldi	r24, 0x40	; 64
    7476:	96 e0       	ldi	r25, 0x06	; 6
    7478:	20 eb       	ldi	r18, 0xB0	; 176
    747a:	fc 01       	movw	r30, r24
    747c:	22 83       	std	Z+2, r18	; 0x02

}
    747e:	df 91       	pop	r29
    7480:	cf 91       	pop	r28
    7482:	08 95       	ret

00007484 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    7484:	cf 93       	push	r28
    7486:	df 93       	push	r29
    7488:	00 d0       	rcall	.+0      	; 0x748a <readFRAM+0x6>
    748a:	0f 92       	push	r0
    748c:	cd b7       	in	r28, 0x3d	; 61
    748e:	de b7       	in	r29, 0x3e	; 62
    7490:	8b 83       	std	Y+3, r24	; 0x03
    7492:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    7494:	80 e0       	ldi	r24, 0x00	; 0
    7496:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    749a:	80 ec       	ldi	r24, 0xC0	; 192
    749c:	98 e0       	ldi	r25, 0x08	; 8
    749e:	20 ed       	ldi	r18, 0xD0	; 208
    74a0:	fc 01       	movw	r30, r24
    74a2:	20 83       	st	Z, r18
	SPICS(TRUE);
    74a4:	81 e0       	ldi	r24, 0x01	; 1
    74a6:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    74aa:	80 e2       	ldi	r24, 0x20	; 32
    74ac:	96 e0       	ldi	r25, 0x06	; 6
    74ae:	28 e0       	ldi	r18, 0x08	; 8
    74b0:	fc 01       	movw	r30, r24
    74b2:	26 83       	std	Z+6, r18	; 0x06
	nop();
    74b4:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    74b6:	80 ec       	ldi	r24, 0xC0	; 192
    74b8:	98 e0       	ldi	r25, 0x08	; 8
    74ba:	23 e0       	ldi	r18, 0x03	; 3
    74bc:	fc 01       	movw	r30, r24
    74be:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74c0:	00 00       	nop
    74c2:	80 ec       	ldi	r24, 0xC0	; 192
    74c4:	98 e0       	ldi	r25, 0x08	; 8
    74c6:	fc 01       	movw	r30, r24
    74c8:	82 81       	ldd	r24, Z+2	; 0x02
    74ca:	88 23       	and	r24, r24
    74cc:	d4 f7       	brge	.-12     	; 0x74c2 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    74ce:	80 ec       	ldi	r24, 0xC0	; 192
    74d0:	98 e0       	ldi	r25, 0x08	; 8
    74d2:	fc 01       	movw	r30, r24
    74d4:	83 81       	ldd	r24, Z+3	; 0x03
    74d6:	80 93 60 50 	sts	0x5060, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    74da:	80 ec       	ldi	r24, 0xC0	; 192
    74dc:	98 e0       	ldi	r25, 0x08	; 8
    74de:	20 91 47 40 	lds	r18, 0x4047
    74e2:	fc 01       	movw	r30, r24
    74e4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74e6:	00 00       	nop
    74e8:	80 ec       	ldi	r24, 0xC0	; 192
    74ea:	98 e0       	ldi	r25, 0x08	; 8
    74ec:	fc 01       	movw	r30, r24
    74ee:	82 81       	ldd	r24, Z+2	; 0x02
    74f0:	88 23       	and	r24, r24
    74f2:	d4 f7       	brge	.-12     	; 0x74e8 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    74f4:	80 ec       	ldi	r24, 0xC0	; 192
    74f6:	98 e0       	ldi	r25, 0x08	; 8
    74f8:	fc 01       	movw	r30, r24
    74fa:	83 81       	ldd	r24, Z+3	; 0x03
    74fc:	80 93 60 50 	sts	0x5060, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    7500:	80 ec       	ldi	r24, 0xC0	; 192
    7502:	98 e0       	ldi	r25, 0x08	; 8
    7504:	26 e4       	ldi	r18, 0x46	; 70
    7506:	30 e4       	ldi	r19, 0x40	; 64
    7508:	f9 01       	movw	r30, r18
    750a:	20 81       	ld	r18, Z
    750c:	fc 01       	movw	r30, r24
    750e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7510:	00 00       	nop
    7512:	80 ec       	ldi	r24, 0xC0	; 192
    7514:	98 e0       	ldi	r25, 0x08	; 8
    7516:	fc 01       	movw	r30, r24
    7518:	82 81       	ldd	r24, Z+2	; 0x02
    751a:	88 23       	and	r24, r24
    751c:	d4 f7       	brge	.-12     	; 0x7512 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    751e:	80 ec       	ldi	r24, 0xC0	; 192
    7520:	98 e0       	ldi	r25, 0x08	; 8
    7522:	fc 01       	movw	r30, r24
    7524:	83 81       	ldd	r24, Z+3	; 0x03
    7526:	80 93 60 50 	sts	0x5060, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    752a:	19 82       	std	Y+1, r1	; 0x01
    752c:	1a 82       	std	Y+2, r1	; 0x02
    752e:	1b c0       	rjmp	.+54     	; 0x7566 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    7530:	80 ec       	ldi	r24, 0xC0	; 192
    7532:	98 e0       	ldi	r25, 0x08	; 8
    7534:	2a ea       	ldi	r18, 0xAA	; 170
    7536:	fc 01       	movw	r30, r24
    7538:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    753a:	00 00       	nop
    753c:	80 ec       	ldi	r24, 0xC0	; 192
    753e:	98 e0       	ldi	r25, 0x08	; 8
    7540:	fc 01       	movw	r30, r24
    7542:	82 81       	ldd	r24, Z+2	; 0x02
    7544:	88 23       	and	r24, r24
    7546:	d4 f7       	brge	.-12     	; 0x753c <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    7548:	80 ec       	ldi	r24, 0xC0	; 192
    754a:	98 e0       	ldi	r25, 0x08	; 8
    754c:	fc 01       	movw	r30, r24
    754e:	23 81       	ldd	r18, Z+3	; 0x03
    7550:	89 81       	ldd	r24, Y+1	; 0x01
    7552:	9a 81       	ldd	r25, Y+2	; 0x02
    7554:	82 53       	subi	r24, 0x32	; 50
    7556:	9c 4d       	sbci	r25, 0xDC	; 220
    7558:	fc 01       	movw	r30, r24
    755a:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    755c:	89 81       	ldd	r24, Y+1	; 0x01
    755e:	9a 81       	ldd	r25, Y+2	; 0x02
    7560:	01 96       	adiw	r24, 0x01	; 1
    7562:	89 83       	std	Y+1, r24	; 0x01
    7564:	9a 83       	std	Y+2, r25	; 0x02
    7566:	29 81       	ldd	r18, Y+1	; 0x01
    7568:	3a 81       	ldd	r19, Y+2	; 0x02
    756a:	8b 81       	ldd	r24, Y+3	; 0x03
    756c:	9c 81       	ldd	r25, Y+4	; 0x04
    756e:	28 17       	cp	r18, r24
    7570:	39 07       	cpc	r19, r25
    7572:	f0 f2       	brcs	.-68     	; 0x7530 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7574:	80 e2       	ldi	r24, 0x20	; 32
    7576:	96 e0       	ldi	r25, 0x06	; 6
    7578:	28 e0       	ldi	r18, 0x08	; 8
    757a:	fc 01       	movw	r30, r24
    757c:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    757e:	80 e0       	ldi	r24, 0x00	; 0
    7580:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    7584:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>

}
    7588:	24 96       	adiw	r28, 0x04	; 4
    758a:	cd bf       	out	0x3d, r28	; 61
    758c:	de bf       	out	0x3e, r29	; 62
    758e:	df 91       	pop	r29
    7590:	cf 91       	pop	r28
    7592:	08 95       	ret

00007594 <FRAMTest3Channel>:

void FRAMTest3Channel(void) {
    7594:	8f 92       	push	r8
    7596:	9f 92       	push	r9
    7598:	af 92       	push	r10
    759a:	bf 92       	push	r11
    759c:	cf 92       	push	r12
    759e:	df 92       	push	r13
    75a0:	ef 92       	push	r14
    75a2:	ff 92       	push	r15
    75a4:	0f 93       	push	r16
    75a6:	1f 93       	push	r17
    75a8:	cf 93       	push	r28
    75aa:	df 93       	push	r29
    75ac:	cd b7       	in	r28, 0x3d	; 61
    75ae:	de b7       	in	r29, 0x3e	; 62
    75b0:	6b 97       	sbiw	r28, 0x1b	; 27
    75b2:	cd bf       	out	0x3d, r28	; 61
    75b4:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    75b6:	19 8e       	std	Y+25, r1	; 0x19
    75b8:	1a 8e       	std	Y+26, r1	; 0x1a
    75ba:	1b 8e       	std	Y+27, r1	; 0x1b
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
    75bc:	9e 01       	movw	r18, r28
    75be:	27 5e       	subi	r18, 0xE7	; 231
    75c0:	3f 4f       	sbci	r19, 0xFF	; 255
}

void FRAMTest3Channel(void) {
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    75c2:	8e ec       	ldi	r24, 0xCE	; 206
    75c4:	b9 01       	movw	r22, r18
    75c6:	40 e0       	ldi	r20, 0x00	; 0
    75c8:	25 e1       	ldi	r18, 0x15	; 21
    75ca:	01 e0       	ldi	r16, 0x01	; 1
    75cc:	0f 2e       	mov	r0, r31
    75ce:	fd e0       	ldi	r31, 0x0D	; 13
    75d0:	ef 2e       	mov	r14, r31
    75d2:	ff 24       	eor	r15, r15
    75d4:	f0 2d       	mov	r31, r0
    75d6:	0f 2e       	mov	r0, r31
    75d8:	fe e0       	ldi	r31, 0x0E	; 14
    75da:	cf 2e       	mov	r12, r31
    75dc:	dd 24       	eor	r13, r13
    75de:	f0 2d       	mov	r31, r0
    75e0:	0f 2e       	mov	r0, r31
    75e2:	ff e0       	ldi	r31, 0x0F	; 15
    75e4:	af 2e       	mov	r10, r31
    75e6:	bb 24       	eor	r11, r11
    75e8:	f0 2d       	mov	r31, r0
    75ea:	88 24       	eor	r8, r8
    75ec:	99 24       	eor	r9, r9
    75ee:	68 94       	set
    75f0:	84 f8       	bld	r8, 4
    75f2:	0e 94 4d 11 	call	0x229a	; 0x229a <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    75f6:	81 e0       	ldi	r24, 0x01	; 1
    75f8:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
    75fc:	80 e0       	ldi	r24, 0x00	; 0
    75fe:	90 e0       	ldi	r25, 0x00	; 0
    7600:	aa e7       	ldi	r26, 0x7A	; 122
    7602:	b3 e4       	ldi	r27, 0x43	; 67
    7604:	89 83       	std	Y+1, r24	; 0x01
    7606:	9a 83       	std	Y+2, r25	; 0x02
    7608:	ab 83       	std	Y+3, r26	; 0x03
    760a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    760c:	69 81       	ldd	r22, Y+1	; 0x01
    760e:	7a 81       	ldd	r23, Y+2	; 0x02
    7610:	8b 81       	ldd	r24, Y+3	; 0x03
    7612:	9c 81       	ldd	r25, Y+4	; 0x04
    7614:	2b ea       	ldi	r18, 0xAB	; 171
    7616:	3a ea       	ldi	r19, 0xAA	; 170
    7618:	4a e2       	ldi	r20, 0x2A	; 42
    761a:	51 e4       	ldi	r21, 0x41	; 65
    761c:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7620:	dc 01       	movw	r26, r24
    7622:	cb 01       	movw	r24, r22
    7624:	8d 83       	std	Y+5, r24	; 0x05
    7626:	9e 83       	std	Y+6, r25	; 0x06
    7628:	af 83       	std	Y+7, r26	; 0x07
    762a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    762c:	11 e0       	ldi	r17, 0x01	; 1
    762e:	6d 81       	ldd	r22, Y+5	; 0x05
    7630:	7e 81       	ldd	r23, Y+6	; 0x06
    7632:	8f 81       	ldd	r24, Y+7	; 0x07
    7634:	98 85       	ldd	r25, Y+8	; 0x08
    7636:	20 e0       	ldi	r18, 0x00	; 0
    7638:	30 e0       	ldi	r19, 0x00	; 0
    763a:	40 e8       	ldi	r20, 0x80	; 128
    763c:	5f e3       	ldi	r21, 0x3F	; 63
    763e:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    7642:	88 23       	and	r24, r24
    7644:	0c f0       	brlt	.+2      	; 0x7648 <FRAMTest3Channel+0xb4>
    7646:	10 e0       	ldi	r17, 0x00	; 0
    7648:	11 23       	and	r17, r17
    764a:	19 f0       	breq	.+6      	; 0x7652 <FRAMTest3Channel+0xbe>
		__ticks = 1;
    764c:	81 e0       	ldi	r24, 0x01	; 1
    764e:	89 87       	std	Y+9, r24	; 0x09
    7650:	a3 c0       	rjmp	.+326    	; 0x7798 <FRAMTest3Channel+0x204>
	else if (__tmp > 255)
    7652:	11 e0       	ldi	r17, 0x01	; 1
    7654:	6d 81       	ldd	r22, Y+5	; 0x05
    7656:	7e 81       	ldd	r23, Y+6	; 0x06
    7658:	8f 81       	ldd	r24, Y+7	; 0x07
    765a:	98 85       	ldd	r25, Y+8	; 0x08
    765c:	20 e0       	ldi	r18, 0x00	; 0
    765e:	30 e0       	ldi	r19, 0x00	; 0
    7660:	4f e7       	ldi	r20, 0x7F	; 127
    7662:	53 e4       	ldi	r21, 0x43	; 67
    7664:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7668:	18 16       	cp	r1, r24
    766a:	0c f0       	brlt	.+2      	; 0x766e <FRAMTest3Channel+0xda>
    766c:	10 e0       	ldi	r17, 0x00	; 0
    766e:	11 23       	and	r17, r17
    7670:	09 f4       	brne	.+2      	; 0x7674 <FRAMTest3Channel+0xe0>
    7672:	89 c0       	rjmp	.+274    	; 0x7786 <FRAMTest3Channel+0x1f2>
	{
		_delay_ms(__us / 1000.0);
    7674:	69 81       	ldd	r22, Y+1	; 0x01
    7676:	7a 81       	ldd	r23, Y+2	; 0x02
    7678:	8b 81       	ldd	r24, Y+3	; 0x03
    767a:	9c 81       	ldd	r25, Y+4	; 0x04
    767c:	20 e0       	ldi	r18, 0x00	; 0
    767e:	30 e0       	ldi	r19, 0x00	; 0
    7680:	4a e7       	ldi	r20, 0x7A	; 122
    7682:	54 e4       	ldi	r21, 0x44	; 68
    7684:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    7688:	dc 01       	movw	r26, r24
    768a:	cb 01       	movw	r24, r22
    768c:	8a 87       	std	Y+10, r24	; 0x0a
    768e:	9b 87       	std	Y+11, r25	; 0x0b
    7690:	ac 87       	std	Y+12, r26	; 0x0c
    7692:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7694:	6a 85       	ldd	r22, Y+10	; 0x0a
    7696:	7b 85       	ldd	r23, Y+11	; 0x0b
    7698:	8c 85       	ldd	r24, Y+12	; 0x0c
    769a:	9d 85       	ldd	r25, Y+13	; 0x0d
    769c:	20 e0       	ldi	r18, 0x00	; 0
    769e:	30 e0       	ldi	r19, 0x00	; 0
    76a0:	4a ef       	ldi	r20, 0xFA	; 250
    76a2:	55 e4       	ldi	r21, 0x45	; 69
    76a4:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    76a8:	dc 01       	movw	r26, r24
    76aa:	cb 01       	movw	r24, r22
    76ac:	8e 87       	std	Y+14, r24	; 0x0e
    76ae:	9f 87       	std	Y+15, r25	; 0x0f
    76b0:	a8 8b       	std	Y+16, r26	; 0x10
    76b2:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    76b4:	11 e0       	ldi	r17, 0x01	; 1
    76b6:	6e 85       	ldd	r22, Y+14	; 0x0e
    76b8:	7f 85       	ldd	r23, Y+15	; 0x0f
    76ba:	88 89       	ldd	r24, Y+16	; 0x10
    76bc:	99 89       	ldd	r25, Y+17	; 0x11
    76be:	20 e0       	ldi	r18, 0x00	; 0
    76c0:	30 e0       	ldi	r19, 0x00	; 0
    76c2:	40 e8       	ldi	r20, 0x80	; 128
    76c4:	5f e3       	ldi	r21, 0x3F	; 63
    76c6:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    76ca:	88 23       	and	r24, r24
    76cc:	0c f0       	brlt	.+2      	; 0x76d0 <FRAMTest3Channel+0x13c>
    76ce:	10 e0       	ldi	r17, 0x00	; 0
    76d0:	11 23       	and	r17, r17
    76d2:	29 f0       	breq	.+10     	; 0x76de <FRAMTest3Channel+0x14a>
		__ticks = 1;
    76d4:	81 e0       	ldi	r24, 0x01	; 1
    76d6:	90 e0       	ldi	r25, 0x00	; 0
    76d8:	8a 8b       	std	Y+18, r24	; 0x12
    76da:	9b 8b       	std	Y+19, r25	; 0x13
    76dc:	46 c0       	rjmp	.+140    	; 0x776a <FRAMTest3Channel+0x1d6>
	else if (__tmp > 65535)
    76de:	11 e0       	ldi	r17, 0x01	; 1
    76e0:	6e 85       	ldd	r22, Y+14	; 0x0e
    76e2:	7f 85       	ldd	r23, Y+15	; 0x0f
    76e4:	88 89       	ldd	r24, Y+16	; 0x10
    76e6:	99 89       	ldd	r25, Y+17	; 0x11
    76e8:	20 e0       	ldi	r18, 0x00	; 0
    76ea:	3f ef       	ldi	r19, 0xFF	; 255
    76ec:	4f e7       	ldi	r20, 0x7F	; 127
    76ee:	57 e4       	ldi	r21, 0x47	; 71
    76f0:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    76f4:	18 16       	cp	r1, r24
    76f6:	0c f0       	brlt	.+2      	; 0x76fa <FRAMTest3Channel+0x166>
    76f8:	10 e0       	ldi	r17, 0x00	; 0
    76fa:	11 23       	and	r17, r17
    76fc:	61 f1       	breq	.+88     	; 0x7756 <FRAMTest3Channel+0x1c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    76fe:	6a 85       	ldd	r22, Y+10	; 0x0a
    7700:	7b 85       	ldd	r23, Y+11	; 0x0b
    7702:	8c 85       	ldd	r24, Y+12	; 0x0c
    7704:	9d 85       	ldd	r25, Y+13	; 0x0d
    7706:	20 e0       	ldi	r18, 0x00	; 0
    7708:	30 e0       	ldi	r19, 0x00	; 0
    770a:	40 e2       	ldi	r20, 0x20	; 32
    770c:	51 e4       	ldi	r21, 0x41	; 65
    770e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7712:	dc 01       	movw	r26, r24
    7714:	cb 01       	movw	r24, r22
    7716:	bc 01       	movw	r22, r24
    7718:	cd 01       	movw	r24, r26
    771a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    771e:	dc 01       	movw	r26, r24
    7720:	cb 01       	movw	r24, r22
    7722:	8a 8b       	std	Y+18, r24	; 0x12
    7724:	9b 8b       	std	Y+19, r25	; 0x13
    7726:	12 c0       	rjmp	.+36     	; 0x774c <FRAMTest3Channel+0x1b8>
    7728:	80 e2       	ldi	r24, 0x20	; 32
    772a:	93 e0       	ldi	r25, 0x03	; 3
    772c:	8c 8b       	std	Y+20, r24	; 0x14
    772e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7730:	8c 89       	ldd	r24, Y+20	; 0x14
    7732:	9d 89       	ldd	r25, Y+21	; 0x15
    7734:	8c 01       	movw	r16, r24
    7736:	c8 01       	movw	r24, r16
    7738:	01 97       	sbiw	r24, 0x01	; 1
    773a:	f1 f7       	brne	.-4      	; 0x7738 <FRAMTest3Channel+0x1a4>
    773c:	8c 01       	movw	r16, r24
    773e:	0c 8b       	std	Y+20, r16	; 0x14
    7740:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7742:	8a 89       	ldd	r24, Y+18	; 0x12
    7744:	9b 89       	ldd	r25, Y+19	; 0x13
    7746:	01 97       	sbiw	r24, 0x01	; 1
    7748:	8a 8b       	std	Y+18, r24	; 0x12
    774a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    774c:	8a 89       	ldd	r24, Y+18	; 0x12
    774e:	9b 89       	ldd	r25, Y+19	; 0x13
    7750:	00 97       	sbiw	r24, 0x00	; 0
    7752:	51 f7       	brne	.-44     	; 0x7728 <FRAMTest3Channel+0x194>
    7754:	28 c0       	rjmp	.+80     	; 0x77a6 <FRAMTest3Channel+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7756:	6e 85       	ldd	r22, Y+14	; 0x0e
    7758:	7f 85       	ldd	r23, Y+15	; 0x0f
    775a:	88 89       	ldd	r24, Y+16	; 0x10
    775c:	99 89       	ldd	r25, Y+17	; 0x11
    775e:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7762:	dc 01       	movw	r26, r24
    7764:	cb 01       	movw	r24, r22
    7766:	8a 8b       	std	Y+18, r24	; 0x12
    7768:	9b 8b       	std	Y+19, r25	; 0x13
    776a:	8a 89       	ldd	r24, Y+18	; 0x12
    776c:	9b 89       	ldd	r25, Y+19	; 0x13
    776e:	8e 8b       	std	Y+22, r24	; 0x16
    7770:	9f 8b       	std	Y+23, r25	; 0x17
    7772:	8e 89       	ldd	r24, Y+22	; 0x16
    7774:	9f 89       	ldd	r25, Y+23	; 0x17
    7776:	8c 01       	movw	r16, r24
    7778:	c8 01       	movw	r24, r16
    777a:	01 97       	sbiw	r24, 0x01	; 1
    777c:	f1 f7       	brne	.-4      	; 0x777a <FRAMTest3Channel+0x1e6>
    777e:	8c 01       	movw	r16, r24
    7780:	0e 8b       	std	Y+22, r16	; 0x16
    7782:	1f 8b       	std	Y+23, r17	; 0x17
    7784:	10 c0       	rjmp	.+32     	; 0x77a6 <FRAMTest3Channel+0x212>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7786:	6d 81       	ldd	r22, Y+5	; 0x05
    7788:	7e 81       	ldd	r23, Y+6	; 0x06
    778a:	8f 81       	ldd	r24, Y+7	; 0x07
    778c:	98 85       	ldd	r25, Y+8	; 0x08
    778e:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7792:	dc 01       	movw	r26, r24
    7794:	cb 01       	movw	r24, r22
    7796:	89 87       	std	Y+9, r24	; 0x09
    7798:	89 85       	ldd	r24, Y+9	; 0x09
    779a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    779c:	88 8d       	ldd	r24, Y+24	; 0x18
    779e:	18 2f       	mov	r17, r24
    77a0:	1a 95       	dec	r17
    77a2:	f1 f7       	brne	.-4      	; 0x77a0 <FRAMTest3Channel+0x20c>
    77a4:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    77a6:	0e 94 51 18 	call	0x30a2	; 0x30a2 <calcChecksumFRAM>

	ADCPower(FALSE);
    77aa:	80 e0       	ldi	r24, 0x00	; 0
    77ac:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	
}
    77b0:	6b 96       	adiw	r28, 0x1b	; 27
    77b2:	cd bf       	out	0x3d, r28	; 61
    77b4:	de bf       	out	0x3e, r29	; 62
    77b6:	df 91       	pop	r29
    77b8:	cf 91       	pop	r28
    77ba:	1f 91       	pop	r17
    77bc:	0f 91       	pop	r16
    77be:	ff 90       	pop	r15
    77c0:	ef 90       	pop	r14
    77c2:	df 90       	pop	r13
    77c4:	cf 90       	pop	r12
    77c6:	bf 90       	pop	r11
    77c8:	af 90       	pop	r10
    77ca:	9f 90       	pop	r9
    77cc:	8f 90       	pop	r8
    77ce:	08 95       	ret

000077d0 <FRAMTest1Channel>:

void FRAMTest1Channel(void) {
    77d0:	8f 92       	push	r8
    77d2:	9f 92       	push	r9
    77d4:	af 92       	push	r10
    77d6:	bf 92       	push	r11
    77d8:	cf 92       	push	r12
    77da:	df 92       	push	r13
    77dc:	ef 92       	push	r14
    77de:	0f 93       	push	r16
    77e0:	1f 93       	push	r17
    77e2:	cf 93       	push	r28
    77e4:	df 93       	push	r29
    77e6:	cd b7       	in	r28, 0x3d	; 61
    77e8:	de b7       	in	r29, 0x3e	; 62
    77ea:	68 97       	sbiw	r28, 0x18	; 24
    77ec:	cd bf       	out	0x3d, r28	; 61
    77ee:	de bf       	out	0x3e, r29	; 62

	CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
    77f0:	0f 92       	push	r0
    77f2:	0f 92       	push	r0
    77f4:	8d b7       	in	r24, 0x3d	; 61
    77f6:	9e b7       	in	r25, 0x3e	; 62
    77f8:	01 96       	adiw	r24, 0x01	; 1
    77fa:	20 e1       	ldi	r18, 0x10	; 16
    77fc:	30 e0       	ldi	r19, 0x00	; 0
    77fe:	fc 01       	movw	r30, r24
    7800:	20 83       	st	Z, r18
    7802:	31 83       	std	Z+1, r19	; 0x01
    7804:	87 e0       	ldi	r24, 0x07	; 7
    7806:	68 ec       	ldi	r22, 0xC8	; 200
    7808:	40 e0       	ldi	r20, 0x00	; 0
    780a:	20 e0       	ldi	r18, 0x00	; 0
    780c:	05 e1       	ldi	r16, 0x15	; 21
    780e:	ee 24       	eor	r14, r14
    7810:	e3 94       	inc	r14
    7812:	0f 2e       	mov	r0, r31
    7814:	fd e0       	ldi	r31, 0x0D	; 13
    7816:	cf 2e       	mov	r12, r31
    7818:	dd 24       	eor	r13, r13
    781a:	f0 2d       	mov	r31, r0
    781c:	0f 2e       	mov	r0, r31
    781e:	fe e0       	ldi	r31, 0x0E	; 14
    7820:	af 2e       	mov	r10, r31
    7822:	bb 24       	eor	r11, r11
    7824:	f0 2d       	mov	r31, r0
    7826:	0f 2e       	mov	r0, r31
    7828:	ff e0       	ldi	r31, 0x0F	; 15
    782a:	8f 2e       	mov	r8, r31
    782c:	99 24       	eor	r9, r9
    782e:	f0 2d       	mov	r31, r0
    7830:	0e 94 86 14 	call	0x290c	; 0x290c <CO_collectSeismic1Channel>
    7834:	0f 90       	pop	r0
    7836:	0f 90       	pop	r0
	GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7838:	81 e0       	ldi	r24, 0x01	; 1
    783a:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
    783e:	80 e0       	ldi	r24, 0x00	; 0
    7840:	90 e0       	ldi	r25, 0x00	; 0
    7842:	aa e7       	ldi	r26, 0x7A	; 122
    7844:	b3 e4       	ldi	r27, 0x43	; 67
    7846:	89 83       	std	Y+1, r24	; 0x01
    7848:	9a 83       	std	Y+2, r25	; 0x02
    784a:	ab 83       	std	Y+3, r26	; 0x03
    784c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    784e:	69 81       	ldd	r22, Y+1	; 0x01
    7850:	7a 81       	ldd	r23, Y+2	; 0x02
    7852:	8b 81       	ldd	r24, Y+3	; 0x03
    7854:	9c 81       	ldd	r25, Y+4	; 0x04
    7856:	2b ea       	ldi	r18, 0xAB	; 171
    7858:	3a ea       	ldi	r19, 0xAA	; 170
    785a:	4a e2       	ldi	r20, 0x2A	; 42
    785c:	51 e4       	ldi	r21, 0x41	; 65
    785e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7862:	dc 01       	movw	r26, r24
    7864:	cb 01       	movw	r24, r22
    7866:	8d 83       	std	Y+5, r24	; 0x05
    7868:	9e 83       	std	Y+6, r25	; 0x06
    786a:	af 83       	std	Y+7, r26	; 0x07
    786c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    786e:	11 e0       	ldi	r17, 0x01	; 1
    7870:	6d 81       	ldd	r22, Y+5	; 0x05
    7872:	7e 81       	ldd	r23, Y+6	; 0x06
    7874:	8f 81       	ldd	r24, Y+7	; 0x07
    7876:	98 85       	ldd	r25, Y+8	; 0x08
    7878:	20 e0       	ldi	r18, 0x00	; 0
    787a:	30 e0       	ldi	r19, 0x00	; 0
    787c:	40 e8       	ldi	r20, 0x80	; 128
    787e:	5f e3       	ldi	r21, 0x3F	; 63
    7880:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    7884:	88 23       	and	r24, r24
    7886:	0c f0       	brlt	.+2      	; 0x788a <FRAMTest1Channel+0xba>
    7888:	10 e0       	ldi	r17, 0x00	; 0
    788a:	11 23       	and	r17, r17
    788c:	19 f0       	breq	.+6      	; 0x7894 <FRAMTest1Channel+0xc4>
		__ticks = 1;
    788e:	81 e0       	ldi	r24, 0x01	; 1
    7890:	89 87       	std	Y+9, r24	; 0x09
    7892:	a3 c0       	rjmp	.+326    	; 0x79da <FRAMTest1Channel+0x20a>
	else if (__tmp > 255)
    7894:	11 e0       	ldi	r17, 0x01	; 1
    7896:	6d 81       	ldd	r22, Y+5	; 0x05
    7898:	7e 81       	ldd	r23, Y+6	; 0x06
    789a:	8f 81       	ldd	r24, Y+7	; 0x07
    789c:	98 85       	ldd	r25, Y+8	; 0x08
    789e:	20 e0       	ldi	r18, 0x00	; 0
    78a0:	30 e0       	ldi	r19, 0x00	; 0
    78a2:	4f e7       	ldi	r20, 0x7F	; 127
    78a4:	53 e4       	ldi	r21, 0x43	; 67
    78a6:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    78aa:	18 16       	cp	r1, r24
    78ac:	0c f0       	brlt	.+2      	; 0x78b0 <FRAMTest1Channel+0xe0>
    78ae:	10 e0       	ldi	r17, 0x00	; 0
    78b0:	11 23       	and	r17, r17
    78b2:	09 f4       	brne	.+2      	; 0x78b6 <FRAMTest1Channel+0xe6>
    78b4:	89 c0       	rjmp	.+274    	; 0x79c8 <FRAMTest1Channel+0x1f8>
	{
		_delay_ms(__us / 1000.0);
    78b6:	69 81       	ldd	r22, Y+1	; 0x01
    78b8:	7a 81       	ldd	r23, Y+2	; 0x02
    78ba:	8b 81       	ldd	r24, Y+3	; 0x03
    78bc:	9c 81       	ldd	r25, Y+4	; 0x04
    78be:	20 e0       	ldi	r18, 0x00	; 0
    78c0:	30 e0       	ldi	r19, 0x00	; 0
    78c2:	4a e7       	ldi	r20, 0x7A	; 122
    78c4:	54 e4       	ldi	r21, 0x44	; 68
    78c6:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    78ca:	dc 01       	movw	r26, r24
    78cc:	cb 01       	movw	r24, r22
    78ce:	8a 87       	std	Y+10, r24	; 0x0a
    78d0:	9b 87       	std	Y+11, r25	; 0x0b
    78d2:	ac 87       	std	Y+12, r26	; 0x0c
    78d4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    78d6:	6a 85       	ldd	r22, Y+10	; 0x0a
    78d8:	7b 85       	ldd	r23, Y+11	; 0x0b
    78da:	8c 85       	ldd	r24, Y+12	; 0x0c
    78dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    78de:	20 e0       	ldi	r18, 0x00	; 0
    78e0:	30 e0       	ldi	r19, 0x00	; 0
    78e2:	4a ef       	ldi	r20, 0xFA	; 250
    78e4:	55 e4       	ldi	r21, 0x45	; 69
    78e6:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    78ea:	dc 01       	movw	r26, r24
    78ec:	cb 01       	movw	r24, r22
    78ee:	8e 87       	std	Y+14, r24	; 0x0e
    78f0:	9f 87       	std	Y+15, r25	; 0x0f
    78f2:	a8 8b       	std	Y+16, r26	; 0x10
    78f4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    78f6:	11 e0       	ldi	r17, 0x01	; 1
    78f8:	6e 85       	ldd	r22, Y+14	; 0x0e
    78fa:	7f 85       	ldd	r23, Y+15	; 0x0f
    78fc:	88 89       	ldd	r24, Y+16	; 0x10
    78fe:	99 89       	ldd	r25, Y+17	; 0x11
    7900:	20 e0       	ldi	r18, 0x00	; 0
    7902:	30 e0       	ldi	r19, 0x00	; 0
    7904:	40 e8       	ldi	r20, 0x80	; 128
    7906:	5f e3       	ldi	r21, 0x3F	; 63
    7908:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    790c:	88 23       	and	r24, r24
    790e:	0c f0       	brlt	.+2      	; 0x7912 <FRAMTest1Channel+0x142>
    7910:	10 e0       	ldi	r17, 0x00	; 0
    7912:	11 23       	and	r17, r17
    7914:	29 f0       	breq	.+10     	; 0x7920 <FRAMTest1Channel+0x150>
		__ticks = 1;
    7916:	81 e0       	ldi	r24, 0x01	; 1
    7918:	90 e0       	ldi	r25, 0x00	; 0
    791a:	8a 8b       	std	Y+18, r24	; 0x12
    791c:	9b 8b       	std	Y+19, r25	; 0x13
    791e:	46 c0       	rjmp	.+140    	; 0x79ac <FRAMTest1Channel+0x1dc>
	else if (__tmp > 65535)
    7920:	11 e0       	ldi	r17, 0x01	; 1
    7922:	6e 85       	ldd	r22, Y+14	; 0x0e
    7924:	7f 85       	ldd	r23, Y+15	; 0x0f
    7926:	88 89       	ldd	r24, Y+16	; 0x10
    7928:	99 89       	ldd	r25, Y+17	; 0x11
    792a:	20 e0       	ldi	r18, 0x00	; 0
    792c:	3f ef       	ldi	r19, 0xFF	; 255
    792e:	4f e7       	ldi	r20, 0x7F	; 127
    7930:	57 e4       	ldi	r21, 0x47	; 71
    7932:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7936:	18 16       	cp	r1, r24
    7938:	0c f0       	brlt	.+2      	; 0x793c <FRAMTest1Channel+0x16c>
    793a:	10 e0       	ldi	r17, 0x00	; 0
    793c:	11 23       	and	r17, r17
    793e:	61 f1       	breq	.+88     	; 0x7998 <FRAMTest1Channel+0x1c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7940:	6a 85       	ldd	r22, Y+10	; 0x0a
    7942:	7b 85       	ldd	r23, Y+11	; 0x0b
    7944:	8c 85       	ldd	r24, Y+12	; 0x0c
    7946:	9d 85       	ldd	r25, Y+13	; 0x0d
    7948:	20 e0       	ldi	r18, 0x00	; 0
    794a:	30 e0       	ldi	r19, 0x00	; 0
    794c:	40 e2       	ldi	r20, 0x20	; 32
    794e:	51 e4       	ldi	r21, 0x41	; 65
    7950:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7954:	dc 01       	movw	r26, r24
    7956:	cb 01       	movw	r24, r22
    7958:	bc 01       	movw	r22, r24
    795a:	cd 01       	movw	r24, r26
    795c:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7960:	dc 01       	movw	r26, r24
    7962:	cb 01       	movw	r24, r22
    7964:	8a 8b       	std	Y+18, r24	; 0x12
    7966:	9b 8b       	std	Y+19, r25	; 0x13
    7968:	12 c0       	rjmp	.+36     	; 0x798e <FRAMTest1Channel+0x1be>
    796a:	80 e2       	ldi	r24, 0x20	; 32
    796c:	93 e0       	ldi	r25, 0x03	; 3
    796e:	8c 8b       	std	Y+20, r24	; 0x14
    7970:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7972:	8c 89       	ldd	r24, Y+20	; 0x14
    7974:	9d 89       	ldd	r25, Y+21	; 0x15
    7976:	8c 01       	movw	r16, r24
    7978:	c8 01       	movw	r24, r16
    797a:	01 97       	sbiw	r24, 0x01	; 1
    797c:	f1 f7       	brne	.-4      	; 0x797a <FRAMTest1Channel+0x1aa>
    797e:	8c 01       	movw	r16, r24
    7980:	0c 8b       	std	Y+20, r16	; 0x14
    7982:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7984:	8a 89       	ldd	r24, Y+18	; 0x12
    7986:	9b 89       	ldd	r25, Y+19	; 0x13
    7988:	01 97       	sbiw	r24, 0x01	; 1
    798a:	8a 8b       	std	Y+18, r24	; 0x12
    798c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    798e:	8a 89       	ldd	r24, Y+18	; 0x12
    7990:	9b 89       	ldd	r25, Y+19	; 0x13
    7992:	00 97       	sbiw	r24, 0x00	; 0
    7994:	51 f7       	brne	.-44     	; 0x796a <FRAMTest1Channel+0x19a>
    7996:	28 c0       	rjmp	.+80     	; 0x79e8 <FRAMTest1Channel+0x218>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7998:	6e 85       	ldd	r22, Y+14	; 0x0e
    799a:	7f 85       	ldd	r23, Y+15	; 0x0f
    799c:	88 89       	ldd	r24, Y+16	; 0x10
    799e:	99 89       	ldd	r25, Y+17	; 0x11
    79a0:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    79a4:	dc 01       	movw	r26, r24
    79a6:	cb 01       	movw	r24, r22
    79a8:	8a 8b       	std	Y+18, r24	; 0x12
    79aa:	9b 8b       	std	Y+19, r25	; 0x13
    79ac:	8a 89       	ldd	r24, Y+18	; 0x12
    79ae:	9b 89       	ldd	r25, Y+19	; 0x13
    79b0:	8e 8b       	std	Y+22, r24	; 0x16
    79b2:	9f 8b       	std	Y+23, r25	; 0x17
    79b4:	8e 89       	ldd	r24, Y+22	; 0x16
    79b6:	9f 89       	ldd	r25, Y+23	; 0x17
    79b8:	8c 01       	movw	r16, r24
    79ba:	f8 01       	movw	r30, r16
    79bc:	31 97       	sbiw	r30, 0x01	; 1
    79be:	f1 f7       	brne	.-4      	; 0x79bc <FRAMTest1Channel+0x1ec>
    79c0:	8f 01       	movw	r16, r30
    79c2:	0e 8b       	std	Y+22, r16	; 0x16
    79c4:	1f 8b       	std	Y+23, r17	; 0x17
    79c6:	10 c0       	rjmp	.+32     	; 0x79e8 <FRAMTest1Channel+0x218>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    79c8:	6d 81       	ldd	r22, Y+5	; 0x05
    79ca:	7e 81       	ldd	r23, Y+6	; 0x06
    79cc:	8f 81       	ldd	r24, Y+7	; 0x07
    79ce:	98 85       	ldd	r25, Y+8	; 0x08
    79d0:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    79d4:	dc 01       	movw	r26, r24
    79d6:	cb 01       	movw	r24, r22
    79d8:	89 87       	std	Y+9, r24	; 0x09
    79da:	89 85       	ldd	r24, Y+9	; 0x09
    79dc:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    79de:	88 8d       	ldd	r24, Y+24	; 0x18
    79e0:	18 2f       	mov	r17, r24
    79e2:	1a 95       	dec	r17
    79e4:	f1 f7       	brne	.-4      	; 0x79e2 <FRAMTest1Channel+0x212>
    79e6:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    79e8:	0e 94 51 18 	call	0x30a2	; 0x30a2 <calcChecksumFRAM>

	ADCPower(FALSE);
    79ec:	80 e0       	ldi	r24, 0x00	; 0
    79ee:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>

}
    79f2:	68 96       	adiw	r28, 0x18	; 24
    79f4:	cd bf       	out	0x3d, r28	; 61
    79f6:	de bf       	out	0x3e, r29	; 62
    79f8:	df 91       	pop	r29
    79fa:	cf 91       	pop	r28
    79fc:	1f 91       	pop	r17
    79fe:	0f 91       	pop	r16
    7a00:	ef 90       	pop	r14
    7a02:	df 90       	pop	r13
    7a04:	cf 90       	pop	r12
    7a06:	bf 90       	pop	r11
    7a08:	af 90       	pop	r10
    7a0a:	9f 90       	pop	r9
    7a0c:	8f 90       	pop	r8
    7a0e:	08 95       	ret

00007a10 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7a10:	0f 93       	push	r16
    7a12:	1f 93       	push	r17
    7a14:	cf 93       	push	r28
    7a16:	df 93       	push	r29
    7a18:	cd b7       	in	r28, 0x3d	; 61
    7a1a:	de b7       	in	r29, 0x3e	; 62
    7a1c:	68 97       	sbiw	r28, 0x18	; 24
    7a1e:	cd bf       	out	0x3d, r28	; 61
    7a20:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    7a22:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <FRAMWriteKnowns>
	ADCPower(TRUE);
    7a26:	81 e0       	ldi	r24, 0x01	; 1
    7a28:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
    7a2c:	80 e0       	ldi	r24, 0x00	; 0
    7a2e:	90 e0       	ldi	r25, 0x00	; 0
    7a30:	aa e7       	ldi	r26, 0x7A	; 122
    7a32:	b3 e4       	ldi	r27, 0x43	; 67
    7a34:	89 83       	std	Y+1, r24	; 0x01
    7a36:	9a 83       	std	Y+2, r25	; 0x02
    7a38:	ab 83       	std	Y+3, r26	; 0x03
    7a3a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7a3c:	69 81       	ldd	r22, Y+1	; 0x01
    7a3e:	7a 81       	ldd	r23, Y+2	; 0x02
    7a40:	8b 81       	ldd	r24, Y+3	; 0x03
    7a42:	9c 81       	ldd	r25, Y+4	; 0x04
    7a44:	2b ea       	ldi	r18, 0xAB	; 171
    7a46:	3a ea       	ldi	r19, 0xAA	; 170
    7a48:	4a e2       	ldi	r20, 0x2A	; 42
    7a4a:	51 e4       	ldi	r21, 0x41	; 65
    7a4c:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7a50:	dc 01       	movw	r26, r24
    7a52:	cb 01       	movw	r24, r22
    7a54:	8d 83       	std	Y+5, r24	; 0x05
    7a56:	9e 83       	std	Y+6, r25	; 0x06
    7a58:	af 83       	std	Y+7, r26	; 0x07
    7a5a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7a5c:	11 e0       	ldi	r17, 0x01	; 1
    7a5e:	6d 81       	ldd	r22, Y+5	; 0x05
    7a60:	7e 81       	ldd	r23, Y+6	; 0x06
    7a62:	8f 81       	ldd	r24, Y+7	; 0x07
    7a64:	98 85       	ldd	r25, Y+8	; 0x08
    7a66:	20 e0       	ldi	r18, 0x00	; 0
    7a68:	30 e0       	ldi	r19, 0x00	; 0
    7a6a:	40 e8       	ldi	r20, 0x80	; 128
    7a6c:	5f e3       	ldi	r21, 0x3F	; 63
    7a6e:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    7a72:	88 23       	and	r24, r24
    7a74:	0c f0       	brlt	.+2      	; 0x7a78 <FRAMWriteKnownsCheck+0x68>
    7a76:	10 e0       	ldi	r17, 0x00	; 0
    7a78:	11 23       	and	r17, r17
    7a7a:	19 f0       	breq	.+6      	; 0x7a82 <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    7a7c:	81 e0       	ldi	r24, 0x01	; 1
    7a7e:	89 87       	std	Y+9, r24	; 0x09
    7a80:	a3 c0       	rjmp	.+326    	; 0x7bc8 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7a82:	11 e0       	ldi	r17, 0x01	; 1
    7a84:	6d 81       	ldd	r22, Y+5	; 0x05
    7a86:	7e 81       	ldd	r23, Y+6	; 0x06
    7a88:	8f 81       	ldd	r24, Y+7	; 0x07
    7a8a:	98 85       	ldd	r25, Y+8	; 0x08
    7a8c:	20 e0       	ldi	r18, 0x00	; 0
    7a8e:	30 e0       	ldi	r19, 0x00	; 0
    7a90:	4f e7       	ldi	r20, 0x7F	; 127
    7a92:	53 e4       	ldi	r21, 0x43	; 67
    7a94:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7a98:	18 16       	cp	r1, r24
    7a9a:	0c f0       	brlt	.+2      	; 0x7a9e <FRAMWriteKnownsCheck+0x8e>
    7a9c:	10 e0       	ldi	r17, 0x00	; 0
    7a9e:	11 23       	and	r17, r17
    7aa0:	09 f4       	brne	.+2      	; 0x7aa4 <FRAMWriteKnownsCheck+0x94>
    7aa2:	89 c0       	rjmp	.+274    	; 0x7bb6 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7aa4:	69 81       	ldd	r22, Y+1	; 0x01
    7aa6:	7a 81       	ldd	r23, Y+2	; 0x02
    7aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    7aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    7aac:	20 e0       	ldi	r18, 0x00	; 0
    7aae:	30 e0       	ldi	r19, 0x00	; 0
    7ab0:	4a e7       	ldi	r20, 0x7A	; 122
    7ab2:	54 e4       	ldi	r21, 0x44	; 68
    7ab4:	0e 94 59 5d 	call	0xbab2	; 0xbab2 <__divsf3>
    7ab8:	dc 01       	movw	r26, r24
    7aba:	cb 01       	movw	r24, r22
    7abc:	8a 87       	std	Y+10, r24	; 0x0a
    7abe:	9b 87       	std	Y+11, r25	; 0x0b
    7ac0:	ac 87       	std	Y+12, r26	; 0x0c
    7ac2:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7ac4:	6a 85       	ldd	r22, Y+10	; 0x0a
    7ac6:	7b 85       	ldd	r23, Y+11	; 0x0b
    7ac8:	8c 85       	ldd	r24, Y+12	; 0x0c
    7aca:	9d 85       	ldd	r25, Y+13	; 0x0d
    7acc:	20 e0       	ldi	r18, 0x00	; 0
    7ace:	30 e0       	ldi	r19, 0x00	; 0
    7ad0:	4a ef       	ldi	r20, 0xFA	; 250
    7ad2:	55 e4       	ldi	r21, 0x45	; 69
    7ad4:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7ad8:	dc 01       	movw	r26, r24
    7ada:	cb 01       	movw	r24, r22
    7adc:	8e 87       	std	Y+14, r24	; 0x0e
    7ade:	9f 87       	std	Y+15, r25	; 0x0f
    7ae0:	a8 8b       	std	Y+16, r26	; 0x10
    7ae2:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7ae4:	11 e0       	ldi	r17, 0x01	; 1
    7ae6:	6e 85       	ldd	r22, Y+14	; 0x0e
    7ae8:	7f 85       	ldd	r23, Y+15	; 0x0f
    7aea:	88 89       	ldd	r24, Y+16	; 0x10
    7aec:	99 89       	ldd	r25, Y+17	; 0x11
    7aee:	20 e0       	ldi	r18, 0x00	; 0
    7af0:	30 e0       	ldi	r19, 0x00	; 0
    7af2:	40 e8       	ldi	r20, 0x80	; 128
    7af4:	5f e3       	ldi	r21, 0x3F	; 63
    7af6:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    7afa:	88 23       	and	r24, r24
    7afc:	0c f0       	brlt	.+2      	; 0x7b00 <FRAMWriteKnownsCheck+0xf0>
    7afe:	10 e0       	ldi	r17, 0x00	; 0
    7b00:	11 23       	and	r17, r17
    7b02:	29 f0       	breq	.+10     	; 0x7b0e <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    7b04:	81 e0       	ldi	r24, 0x01	; 1
    7b06:	90 e0       	ldi	r25, 0x00	; 0
    7b08:	8a 8b       	std	Y+18, r24	; 0x12
    7b0a:	9b 8b       	std	Y+19, r25	; 0x13
    7b0c:	46 c0       	rjmp	.+140    	; 0x7b9a <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7b0e:	11 e0       	ldi	r17, 0x01	; 1
    7b10:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b12:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b14:	88 89       	ldd	r24, Y+16	; 0x10
    7b16:	99 89       	ldd	r25, Y+17	; 0x11
    7b18:	20 e0       	ldi	r18, 0x00	; 0
    7b1a:	3f ef       	ldi	r19, 0xFF	; 255
    7b1c:	4f e7       	ldi	r20, 0x7F	; 127
    7b1e:	57 e4       	ldi	r21, 0x47	; 71
    7b20:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7b24:	18 16       	cp	r1, r24
    7b26:	0c f0       	brlt	.+2      	; 0x7b2a <FRAMWriteKnownsCheck+0x11a>
    7b28:	10 e0       	ldi	r17, 0x00	; 0
    7b2a:	11 23       	and	r17, r17
    7b2c:	61 f1       	breq	.+88     	; 0x7b86 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7b2e:	6a 85       	ldd	r22, Y+10	; 0x0a
    7b30:	7b 85       	ldd	r23, Y+11	; 0x0b
    7b32:	8c 85       	ldd	r24, Y+12	; 0x0c
    7b34:	9d 85       	ldd	r25, Y+13	; 0x0d
    7b36:	20 e0       	ldi	r18, 0x00	; 0
    7b38:	30 e0       	ldi	r19, 0x00	; 0
    7b3a:	40 e2       	ldi	r20, 0x20	; 32
    7b3c:	51 e4       	ldi	r21, 0x41	; 65
    7b3e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7b42:	dc 01       	movw	r26, r24
    7b44:	cb 01       	movw	r24, r22
    7b46:	bc 01       	movw	r22, r24
    7b48:	cd 01       	movw	r24, r26
    7b4a:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7b4e:	dc 01       	movw	r26, r24
    7b50:	cb 01       	movw	r24, r22
    7b52:	8a 8b       	std	Y+18, r24	; 0x12
    7b54:	9b 8b       	std	Y+19, r25	; 0x13
    7b56:	12 c0       	rjmp	.+36     	; 0x7b7c <FRAMWriteKnownsCheck+0x16c>
    7b58:	80 e2       	ldi	r24, 0x20	; 32
    7b5a:	93 e0       	ldi	r25, 0x03	; 3
    7b5c:	8c 8b       	std	Y+20, r24	; 0x14
    7b5e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b60:	8c 89       	ldd	r24, Y+20	; 0x14
    7b62:	9d 89       	ldd	r25, Y+21	; 0x15
    7b64:	8c 01       	movw	r16, r24
    7b66:	c8 01       	movw	r24, r16
    7b68:	01 97       	sbiw	r24, 0x01	; 1
    7b6a:	f1 f7       	brne	.-4      	; 0x7b68 <FRAMWriteKnownsCheck+0x158>
    7b6c:	8c 01       	movw	r16, r24
    7b6e:	0c 8b       	std	Y+20, r16	; 0x14
    7b70:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b72:	8a 89       	ldd	r24, Y+18	; 0x12
    7b74:	9b 89       	ldd	r25, Y+19	; 0x13
    7b76:	01 97       	sbiw	r24, 0x01	; 1
    7b78:	8a 8b       	std	Y+18, r24	; 0x12
    7b7a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b7c:	8a 89       	ldd	r24, Y+18	; 0x12
    7b7e:	9b 89       	ldd	r25, Y+19	; 0x13
    7b80:	00 97       	sbiw	r24, 0x00	; 0
    7b82:	51 f7       	brne	.-44     	; 0x7b58 <FRAMWriteKnownsCheck+0x148>
    7b84:	28 c0       	rjmp	.+80     	; 0x7bd6 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b86:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b88:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b8a:	88 89       	ldd	r24, Y+16	; 0x10
    7b8c:	99 89       	ldd	r25, Y+17	; 0x11
    7b8e:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7b92:	dc 01       	movw	r26, r24
    7b94:	cb 01       	movw	r24, r22
    7b96:	8a 8b       	std	Y+18, r24	; 0x12
    7b98:	9b 8b       	std	Y+19, r25	; 0x13
    7b9a:	8a 89       	ldd	r24, Y+18	; 0x12
    7b9c:	9b 89       	ldd	r25, Y+19	; 0x13
    7b9e:	8e 8b       	std	Y+22, r24	; 0x16
    7ba0:	9f 8b       	std	Y+23, r25	; 0x17
    7ba2:	8e 89       	ldd	r24, Y+22	; 0x16
    7ba4:	9f 89       	ldd	r25, Y+23	; 0x17
    7ba6:	8c 01       	movw	r16, r24
    7ba8:	c8 01       	movw	r24, r16
    7baa:	01 97       	sbiw	r24, 0x01	; 1
    7bac:	f1 f7       	brne	.-4      	; 0x7baa <FRAMWriteKnownsCheck+0x19a>
    7bae:	8c 01       	movw	r16, r24
    7bb0:	0e 8b       	std	Y+22, r16	; 0x16
    7bb2:	1f 8b       	std	Y+23, r17	; 0x17
    7bb4:	10 c0       	rjmp	.+32     	; 0x7bd6 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7bb6:	6d 81       	ldd	r22, Y+5	; 0x05
    7bb8:	7e 81       	ldd	r23, Y+6	; 0x06
    7bba:	8f 81       	ldd	r24, Y+7	; 0x07
    7bbc:	98 85       	ldd	r25, Y+8	; 0x08
    7bbe:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7bc2:	dc 01       	movw	r26, r24
    7bc4:	cb 01       	movw	r24, r22
    7bc6:	89 87       	std	Y+9, r24	; 0x09
    7bc8:	89 85       	ldd	r24, Y+9	; 0x09
    7bca:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7bcc:	88 8d       	ldd	r24, Y+24	; 0x18
    7bce:	18 2f       	mov	r17, r24
    7bd0:	1a 95       	dec	r17
    7bd2:	f1 f7       	brne	.-4      	; 0x7bd0 <FRAMWriteKnownsCheck+0x1c0>
    7bd4:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7bd6:	0e 94 51 18 	call	0x30a2	; 0x30a2 <calcChecksumFRAM>

	ADCPower(FALSE);
    7bda:	80 e0       	ldi	r24, 0x00	; 0
    7bdc:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>

}
    7be0:	68 96       	adiw	r28, 0x18	; 24
    7be2:	cd bf       	out	0x3d, r28	; 61
    7be4:	de bf       	out	0x3e, r29	; 62
    7be6:	df 91       	pop	r29
    7be8:	cf 91       	pop	r28
    7bea:	1f 91       	pop	r17
    7bec:	0f 91       	pop	r16
    7bee:	08 95       	ret

00007bf0 <checkMote>:

//random function for testing stuff	
void checkMote(){
    7bf0:	0f 93       	push	r16
    7bf2:	1f 93       	push	r17
    7bf4:	cf 93       	push	r28
    7bf6:	df 93       	push	r29
    7bf8:	cd b7       	in	r28, 0x3d	; 61
    7bfa:	de b7       	in	r29, 0x3e	; 62
    7bfc:	aa 97       	sbiw	r28, 0x2a	; 42
    7bfe:	cd bf       	out	0x3d, r28	; 61
    7c00:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    7c02:	81 e0       	ldi	r24, 0x01	; 1
    7c04:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	Ext1Power(TRUE);
    7c08:	81 e0       	ldi	r24, 0x01	; 1
    7c0a:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <Ext1Power>
    7c0e:	80 e0       	ldi	r24, 0x00	; 0
    7c10:	90 e0       	ldi	r25, 0x00	; 0
    7c12:	a8 ec       	ldi	r26, 0xC8	; 200
    7c14:	b2 e4       	ldi	r27, 0x42	; 66
    7c16:	89 83       	std	Y+1, r24	; 0x01
    7c18:	9a 83       	std	Y+2, r25	; 0x02
    7c1a:	ab 83       	std	Y+3, r26	; 0x03
    7c1c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7c1e:	69 81       	ldd	r22, Y+1	; 0x01
    7c20:	7a 81       	ldd	r23, Y+2	; 0x02
    7c22:	8b 81       	ldd	r24, Y+3	; 0x03
    7c24:	9c 81       	ldd	r25, Y+4	; 0x04
    7c26:	20 e0       	ldi	r18, 0x00	; 0
    7c28:	30 e0       	ldi	r19, 0x00	; 0
    7c2a:	4a ef       	ldi	r20, 0xFA	; 250
    7c2c:	55 e4       	ldi	r21, 0x45	; 69
    7c2e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7c32:	dc 01       	movw	r26, r24
    7c34:	cb 01       	movw	r24, r22
    7c36:	8d 83       	std	Y+5, r24	; 0x05
    7c38:	9e 83       	std	Y+6, r25	; 0x06
    7c3a:	af 83       	std	Y+7, r26	; 0x07
    7c3c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7c3e:	11 e0       	ldi	r17, 0x01	; 1
    7c40:	6d 81       	ldd	r22, Y+5	; 0x05
    7c42:	7e 81       	ldd	r23, Y+6	; 0x06
    7c44:	8f 81       	ldd	r24, Y+7	; 0x07
    7c46:	98 85       	ldd	r25, Y+8	; 0x08
    7c48:	20 e0       	ldi	r18, 0x00	; 0
    7c4a:	30 e0       	ldi	r19, 0x00	; 0
    7c4c:	40 e8       	ldi	r20, 0x80	; 128
    7c4e:	5f e3       	ldi	r21, 0x3F	; 63
    7c50:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    7c54:	88 23       	and	r24, r24
    7c56:	0c f0       	brlt	.+2      	; 0x7c5a <checkMote+0x6a>
    7c58:	10 e0       	ldi	r17, 0x00	; 0
    7c5a:	11 23       	and	r17, r17
    7c5c:	29 f0       	breq	.+10     	; 0x7c68 <checkMote+0x78>
		__ticks = 1;
    7c5e:	81 e0       	ldi	r24, 0x01	; 1
    7c60:	90 e0       	ldi	r25, 0x00	; 0
    7c62:	89 87       	std	Y+9, r24	; 0x09
    7c64:	9a 87       	std	Y+10, r25	; 0x0a
    7c66:	46 c0       	rjmp	.+140    	; 0x7cf4 <checkMote+0x104>
	else if (__tmp > 65535)
    7c68:	11 e0       	ldi	r17, 0x01	; 1
    7c6a:	6d 81       	ldd	r22, Y+5	; 0x05
    7c6c:	7e 81       	ldd	r23, Y+6	; 0x06
    7c6e:	8f 81       	ldd	r24, Y+7	; 0x07
    7c70:	98 85       	ldd	r25, Y+8	; 0x08
    7c72:	20 e0       	ldi	r18, 0x00	; 0
    7c74:	3f ef       	ldi	r19, 0xFF	; 255
    7c76:	4f e7       	ldi	r20, 0x7F	; 127
    7c78:	57 e4       	ldi	r21, 0x47	; 71
    7c7a:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7c7e:	18 16       	cp	r1, r24
    7c80:	0c f0       	brlt	.+2      	; 0x7c84 <checkMote+0x94>
    7c82:	10 e0       	ldi	r17, 0x00	; 0
    7c84:	11 23       	and	r17, r17
    7c86:	61 f1       	breq	.+88     	; 0x7ce0 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7c88:	69 81       	ldd	r22, Y+1	; 0x01
    7c8a:	7a 81       	ldd	r23, Y+2	; 0x02
    7c8c:	8b 81       	ldd	r24, Y+3	; 0x03
    7c8e:	9c 81       	ldd	r25, Y+4	; 0x04
    7c90:	20 e0       	ldi	r18, 0x00	; 0
    7c92:	30 e0       	ldi	r19, 0x00	; 0
    7c94:	40 e2       	ldi	r20, 0x20	; 32
    7c96:	51 e4       	ldi	r21, 0x41	; 65
    7c98:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7c9c:	dc 01       	movw	r26, r24
    7c9e:	cb 01       	movw	r24, r22
    7ca0:	bc 01       	movw	r22, r24
    7ca2:	cd 01       	movw	r24, r26
    7ca4:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7ca8:	dc 01       	movw	r26, r24
    7caa:	cb 01       	movw	r24, r22
    7cac:	89 87       	std	Y+9, r24	; 0x09
    7cae:	9a 87       	std	Y+10, r25	; 0x0a
    7cb0:	12 c0       	rjmp	.+36     	; 0x7cd6 <checkMote+0xe6>
    7cb2:	80 e2       	ldi	r24, 0x20	; 32
    7cb4:	93 e0       	ldi	r25, 0x03	; 3
    7cb6:	8b 87       	std	Y+11, r24	; 0x0b
    7cb8:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7cba:	8b 85       	ldd	r24, Y+11	; 0x0b
    7cbc:	9c 85       	ldd	r25, Y+12	; 0x0c
    7cbe:	8c 01       	movw	r16, r24
    7cc0:	c8 01       	movw	r24, r16
    7cc2:	01 97       	sbiw	r24, 0x01	; 1
    7cc4:	f1 f7       	brne	.-4      	; 0x7cc2 <checkMote+0xd2>
    7cc6:	8c 01       	movw	r16, r24
    7cc8:	0b 87       	std	Y+11, r16	; 0x0b
    7cca:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ccc:	89 85       	ldd	r24, Y+9	; 0x09
    7cce:	9a 85       	ldd	r25, Y+10	; 0x0a
    7cd0:	01 97       	sbiw	r24, 0x01	; 1
    7cd2:	89 87       	std	Y+9, r24	; 0x09
    7cd4:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7cd6:	89 85       	ldd	r24, Y+9	; 0x09
    7cd8:	9a 85       	ldd	r25, Y+10	; 0x0a
    7cda:	00 97       	sbiw	r24, 0x00	; 0
    7cdc:	51 f7       	brne	.-44     	; 0x7cb2 <checkMote+0xc2>
    7cde:	17 c0       	rjmp	.+46     	; 0x7d0e <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ce0:	6d 81       	ldd	r22, Y+5	; 0x05
    7ce2:	7e 81       	ldd	r23, Y+6	; 0x06
    7ce4:	8f 81       	ldd	r24, Y+7	; 0x07
    7ce6:	98 85       	ldd	r25, Y+8	; 0x08
    7ce8:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7cec:	dc 01       	movw	r26, r24
    7cee:	cb 01       	movw	r24, r22
    7cf0:	89 87       	std	Y+9, r24	; 0x09
    7cf2:	9a 87       	std	Y+10, r25	; 0x0a
    7cf4:	89 85       	ldd	r24, Y+9	; 0x09
    7cf6:	9a 85       	ldd	r25, Y+10	; 0x0a
    7cf8:	8d 87       	std	Y+13, r24	; 0x0d
    7cfa:	9e 87       	std	Y+14, r25	; 0x0e
    7cfc:	8d 85       	ldd	r24, Y+13	; 0x0d
    7cfe:	9e 85       	ldd	r25, Y+14	; 0x0e
    7d00:	8c 01       	movw	r16, r24
    7d02:	c8 01       	movw	r24, r16
    7d04:	01 97       	sbiw	r24, 0x01	; 1
    7d06:	f1 f7       	brne	.-4      	; 0x7d04 <checkMote+0x114>
    7d08:	8c 01       	movw	r16, r24
    7d0a:	0d 87       	std	Y+13, r16	; 0x0d
    7d0c:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7d0e:	88 e0       	ldi	r24, 0x08	; 8
    7d10:	60 e0       	ldi	r22, 0x00	; 0
    7d12:	0e 94 1f 35 	call	0x6a3e	; 0x6a3e <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7d16:	88 e0       	ldi	r24, 0x08	; 8
    7d18:	60 e0       	ldi	r22, 0x00	; 0
    7d1a:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
    7d1e:	80 e0       	ldi	r24, 0x00	; 0
    7d20:	90 e4       	ldi	r25, 0x40	; 64
    7d22:	ac e9       	ldi	r26, 0x9C	; 156
    7d24:	b5 e4       	ldi	r27, 0x45	; 69
    7d26:	8f 87       	std	Y+15, r24	; 0x0f
    7d28:	98 8b       	std	Y+16, r25	; 0x10
    7d2a:	a9 8b       	std	Y+17, r26	; 0x11
    7d2c:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7d2e:	6f 85       	ldd	r22, Y+15	; 0x0f
    7d30:	78 89       	ldd	r23, Y+16	; 0x10
    7d32:	89 89       	ldd	r24, Y+17	; 0x11
    7d34:	9a 89       	ldd	r25, Y+18	; 0x12
    7d36:	20 e0       	ldi	r18, 0x00	; 0
    7d38:	30 e0       	ldi	r19, 0x00	; 0
    7d3a:	4a ef       	ldi	r20, 0xFA	; 250
    7d3c:	55 e4       	ldi	r21, 0x45	; 69
    7d3e:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7d42:	dc 01       	movw	r26, r24
    7d44:	cb 01       	movw	r24, r22
    7d46:	8b 8b       	std	Y+19, r24	; 0x13
    7d48:	9c 8b       	std	Y+20, r25	; 0x14
    7d4a:	ad 8b       	std	Y+21, r26	; 0x15
    7d4c:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7d4e:	11 e0       	ldi	r17, 0x01	; 1
    7d50:	6b 89       	ldd	r22, Y+19	; 0x13
    7d52:	7c 89       	ldd	r23, Y+20	; 0x14
    7d54:	8d 89       	ldd	r24, Y+21	; 0x15
    7d56:	9e 89       	ldd	r25, Y+22	; 0x16
    7d58:	20 e0       	ldi	r18, 0x00	; 0
    7d5a:	30 e0       	ldi	r19, 0x00	; 0
    7d5c:	40 e8       	ldi	r20, 0x80	; 128
    7d5e:	5f e3       	ldi	r21, 0x3F	; 63
    7d60:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    7d64:	88 23       	and	r24, r24
    7d66:	0c f0       	brlt	.+2      	; 0x7d6a <checkMote+0x17a>
    7d68:	10 e0       	ldi	r17, 0x00	; 0
    7d6a:	11 23       	and	r17, r17
    7d6c:	29 f0       	breq	.+10     	; 0x7d78 <checkMote+0x188>
		__ticks = 1;
    7d6e:	81 e0       	ldi	r24, 0x01	; 1
    7d70:	90 e0       	ldi	r25, 0x00	; 0
    7d72:	8f 8b       	std	Y+23, r24	; 0x17
    7d74:	98 8f       	std	Y+24, r25	; 0x18
    7d76:	46 c0       	rjmp	.+140    	; 0x7e04 <checkMote+0x214>
	else if (__tmp > 65535)
    7d78:	11 e0       	ldi	r17, 0x01	; 1
    7d7a:	6b 89       	ldd	r22, Y+19	; 0x13
    7d7c:	7c 89       	ldd	r23, Y+20	; 0x14
    7d7e:	8d 89       	ldd	r24, Y+21	; 0x15
    7d80:	9e 89       	ldd	r25, Y+22	; 0x16
    7d82:	20 e0       	ldi	r18, 0x00	; 0
    7d84:	3f ef       	ldi	r19, 0xFF	; 255
    7d86:	4f e7       	ldi	r20, 0x7F	; 127
    7d88:	57 e4       	ldi	r21, 0x47	; 71
    7d8a:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7d8e:	18 16       	cp	r1, r24
    7d90:	0c f0       	brlt	.+2      	; 0x7d94 <checkMote+0x1a4>
    7d92:	10 e0       	ldi	r17, 0x00	; 0
    7d94:	11 23       	and	r17, r17
    7d96:	61 f1       	breq	.+88     	; 0x7df0 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7d98:	6f 85       	ldd	r22, Y+15	; 0x0f
    7d9a:	78 89       	ldd	r23, Y+16	; 0x10
    7d9c:	89 89       	ldd	r24, Y+17	; 0x11
    7d9e:	9a 89       	ldd	r25, Y+18	; 0x12
    7da0:	20 e0       	ldi	r18, 0x00	; 0
    7da2:	30 e0       	ldi	r19, 0x00	; 0
    7da4:	40 e2       	ldi	r20, 0x20	; 32
    7da6:	51 e4       	ldi	r21, 0x41	; 65
    7da8:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7dac:	dc 01       	movw	r26, r24
    7dae:	cb 01       	movw	r24, r22
    7db0:	bc 01       	movw	r22, r24
    7db2:	cd 01       	movw	r24, r26
    7db4:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7db8:	dc 01       	movw	r26, r24
    7dba:	cb 01       	movw	r24, r22
    7dbc:	8f 8b       	std	Y+23, r24	; 0x17
    7dbe:	98 8f       	std	Y+24, r25	; 0x18
    7dc0:	12 c0       	rjmp	.+36     	; 0x7de6 <checkMote+0x1f6>
    7dc2:	80 e2       	ldi	r24, 0x20	; 32
    7dc4:	93 e0       	ldi	r25, 0x03	; 3
    7dc6:	89 8f       	std	Y+25, r24	; 0x19
    7dc8:	9a 8f       	std	Y+26, r25	; 0x1a
    7dca:	89 8d       	ldd	r24, Y+25	; 0x19
    7dcc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7dce:	8c 01       	movw	r16, r24
    7dd0:	c8 01       	movw	r24, r16
    7dd2:	01 97       	sbiw	r24, 0x01	; 1
    7dd4:	f1 f7       	brne	.-4      	; 0x7dd2 <checkMote+0x1e2>
    7dd6:	8c 01       	movw	r16, r24
    7dd8:	09 8f       	std	Y+25, r16	; 0x19
    7dda:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ddc:	8f 89       	ldd	r24, Y+23	; 0x17
    7dde:	98 8d       	ldd	r25, Y+24	; 0x18
    7de0:	01 97       	sbiw	r24, 0x01	; 1
    7de2:	8f 8b       	std	Y+23, r24	; 0x17
    7de4:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7de6:	8f 89       	ldd	r24, Y+23	; 0x17
    7de8:	98 8d       	ldd	r25, Y+24	; 0x18
    7dea:	00 97       	sbiw	r24, 0x00	; 0
    7dec:	51 f7       	brne	.-44     	; 0x7dc2 <checkMote+0x1d2>
    7dee:	17 c0       	rjmp	.+46     	; 0x7e1e <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7df0:	6b 89       	ldd	r22, Y+19	; 0x13
    7df2:	7c 89       	ldd	r23, Y+20	; 0x14
    7df4:	8d 89       	ldd	r24, Y+21	; 0x15
    7df6:	9e 89       	ldd	r25, Y+22	; 0x16
    7df8:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7dfc:	dc 01       	movw	r26, r24
    7dfe:	cb 01       	movw	r24, r22
    7e00:	8f 8b       	std	Y+23, r24	; 0x17
    7e02:	98 8f       	std	Y+24, r25	; 0x18
    7e04:	8f 89       	ldd	r24, Y+23	; 0x17
    7e06:	98 8d       	ldd	r25, Y+24	; 0x18
    7e08:	8b 8f       	std	Y+27, r24	; 0x1b
    7e0a:	9c 8f       	std	Y+28, r25	; 0x1c
    7e0c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7e0e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7e10:	8c 01       	movw	r16, r24
    7e12:	c8 01       	movw	r24, r16
    7e14:	01 97       	sbiw	r24, 0x01	; 1
    7e16:	f1 f7       	brne	.-4      	; 0x7e14 <checkMote+0x224>
    7e18:	8c 01       	movw	r16, r24
    7e1a:	0b 8f       	std	Y+27, r16	; 0x1b
    7e1c:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7e1e:	88 e0       	ldi	r24, 0x08	; 8
    7e20:	60 e0       	ldi	r22, 0x00	; 0
    7e22:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <PortEx_OUTCLR>
    7e26:	80 e0       	ldi	r24, 0x00	; 0
    7e28:	90 e4       	ldi	r25, 0x40	; 64
    7e2a:	ac e9       	ldi	r26, 0x9C	; 156
    7e2c:	b5 e4       	ldi	r27, 0x45	; 69
    7e2e:	8d 8f       	std	Y+29, r24	; 0x1d
    7e30:	9e 8f       	std	Y+30, r25	; 0x1e
    7e32:	af 8f       	std	Y+31, r26	; 0x1f
    7e34:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7e36:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7e38:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7e3a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7e3c:	98 a1       	lds	r25, 0x48
    7e3e:	20 e0       	ldi	r18, 0x00	; 0
    7e40:	30 e0       	ldi	r19, 0x00	; 0
    7e42:	4a ef       	ldi	r20, 0xFA	; 250
    7e44:	55 e4       	ldi	r21, 0x45	; 69
    7e46:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7e4a:	dc 01       	movw	r26, r24
    7e4c:	cb 01       	movw	r24, r22
    7e4e:	89 a3       	lds	r24, 0x59
    7e50:	9a a3       	lds	r25, 0x5a
    7e52:	ab a3       	lds	r26, 0x5b
    7e54:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7e56:	11 e0       	ldi	r17, 0x01	; 1
    7e58:	69 a1       	lds	r22, 0x49
    7e5a:	7a a1       	lds	r23, 0x4a
    7e5c:	8b a1       	lds	r24, 0x4b
    7e5e:	9c a1       	lds	r25, 0x4c
    7e60:	20 e0       	ldi	r18, 0x00	; 0
    7e62:	30 e0       	ldi	r19, 0x00	; 0
    7e64:	40 e8       	ldi	r20, 0x80	; 128
    7e66:	5f e3       	ldi	r21, 0x3F	; 63
    7e68:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    7e6c:	88 23       	and	r24, r24
    7e6e:	0c f0       	brlt	.+2      	; 0x7e72 <checkMote+0x282>
    7e70:	10 e0       	ldi	r17, 0x00	; 0
    7e72:	11 23       	and	r17, r17
    7e74:	29 f0       	breq	.+10     	; 0x7e80 <checkMote+0x290>
		__ticks = 1;
    7e76:	81 e0       	ldi	r24, 0x01	; 1
    7e78:	90 e0       	ldi	r25, 0x00	; 0
    7e7a:	8d a3       	lds	r24, 0x5d
    7e7c:	9e a3       	lds	r25, 0x5e
    7e7e:	46 c0       	rjmp	.+140    	; 0x7f0c <checkMote+0x31c>
	else if (__tmp > 65535)
    7e80:	11 e0       	ldi	r17, 0x01	; 1
    7e82:	69 a1       	lds	r22, 0x49
    7e84:	7a a1       	lds	r23, 0x4a
    7e86:	8b a1       	lds	r24, 0x4b
    7e88:	9c a1       	lds	r25, 0x4c
    7e8a:	20 e0       	ldi	r18, 0x00	; 0
    7e8c:	3f ef       	ldi	r19, 0xFF	; 255
    7e8e:	4f e7       	ldi	r20, 0x7F	; 127
    7e90:	57 e4       	ldi	r21, 0x47	; 71
    7e92:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    7e96:	18 16       	cp	r1, r24
    7e98:	0c f0       	brlt	.+2      	; 0x7e9c <checkMote+0x2ac>
    7e9a:	10 e0       	ldi	r17, 0x00	; 0
    7e9c:	11 23       	and	r17, r17
    7e9e:	61 f1       	breq	.+88     	; 0x7ef8 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7ea0:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7ea2:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7ea4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7ea6:	98 a1       	lds	r25, 0x48
    7ea8:	20 e0       	ldi	r18, 0x00	; 0
    7eaa:	30 e0       	ldi	r19, 0x00	; 0
    7eac:	40 e2       	ldi	r20, 0x20	; 32
    7eae:	51 e4       	ldi	r21, 0x41	; 65
    7eb0:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    7eb4:	dc 01       	movw	r26, r24
    7eb6:	cb 01       	movw	r24, r22
    7eb8:	bc 01       	movw	r22, r24
    7eba:	cd 01       	movw	r24, r26
    7ebc:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7ec0:	dc 01       	movw	r26, r24
    7ec2:	cb 01       	movw	r24, r22
    7ec4:	8d a3       	lds	r24, 0x5d
    7ec6:	9e a3       	lds	r25, 0x5e
    7ec8:	12 c0       	rjmp	.+36     	; 0x7eee <checkMote+0x2fe>
    7eca:	80 e2       	ldi	r24, 0x20	; 32
    7ecc:	93 e0       	ldi	r25, 0x03	; 3
    7ece:	8f a3       	lds	r24, 0x5f
    7ed0:	98 a7       	lds	r25, 0x78
    7ed2:	8f a1       	lds	r24, 0x4f
    7ed4:	98 a5       	lds	r25, 0x68
    7ed6:	8c 01       	movw	r16, r24
    7ed8:	c8 01       	movw	r24, r16
    7eda:	01 97       	sbiw	r24, 0x01	; 1
    7edc:	f1 f7       	brne	.-4      	; 0x7eda <checkMote+0x2ea>
    7ede:	8c 01       	movw	r16, r24
    7ee0:	0f a3       	lds	r16, 0x5f
    7ee2:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ee4:	8d a1       	lds	r24, 0x4d
    7ee6:	9e a1       	lds	r25, 0x4e
    7ee8:	01 97       	sbiw	r24, 0x01	; 1
    7eea:	8d a3       	lds	r24, 0x5d
    7eec:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7eee:	8d a1       	lds	r24, 0x4d
    7ef0:	9e a1       	lds	r25, 0x4e
    7ef2:	00 97       	sbiw	r24, 0x00	; 0
    7ef4:	51 f7       	brne	.-44     	; 0x7eca <checkMote+0x2da>
    7ef6:	18 c0       	rjmp	.+48     	; 0x7f28 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ef8:	69 a1       	lds	r22, 0x49
    7efa:	7a a1       	lds	r23, 0x4a
    7efc:	8b a1       	lds	r24, 0x4b
    7efe:	9c a1       	lds	r25, 0x4c
    7f00:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    7f04:	dc 01       	movw	r26, r24
    7f06:	cb 01       	movw	r24, r22
    7f08:	8d a3       	lds	r24, 0x5d
    7f0a:	9e a3       	lds	r25, 0x5e
    7f0c:	8d a1       	lds	r24, 0x4d
    7f0e:	9e a1       	lds	r25, 0x4e
    7f10:	89 a7       	lds	r24, 0x79
    7f12:	9a a7       	lds	r25, 0x7a
    7f14:	89 a5       	lds	r24, 0x69
    7f16:	9a a5       	lds	r25, 0x6a
    7f18:	8c 01       	movw	r16, r24
    7f1a:	c8 01       	movw	r24, r16
    7f1c:	01 97       	sbiw	r24, 0x01	; 1
    7f1e:	f1 f7       	brne	.-4      	; 0x7f1c <checkMote+0x32c>
    7f20:	8c 01       	movw	r16, r24
    7f22:	09 a7       	lds	r16, 0x79
    7f24:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7f26:	f7 ce       	rjmp	.-530    	; 0x7d16 <checkMote+0x126>
    7f28:	f6 ce       	rjmp	.-532    	; 0x7d16 <checkMote+0x126>

00007f2a <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7f2a:	cf 93       	push	r28
    7f2c:	df 93       	push	r29
    7f2e:	cd b7       	in	r28, 0x3d	; 61
    7f30:	de b7       	in	r29, 0x3e	; 62
    7f32:	28 97       	sbiw	r28, 0x08	; 8
    7f34:	cd bf       	out	0x3d, r28	; 61
    7f36:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7f38:	19 82       	std	Y+1, r1	; 0x01
    7f3a:	1a 82       	std	Y+2, r1	; 0x02
    7f3c:	0c c0       	rjmp	.+24     	; 0x7f56 <SD_write_and_read_knowns+0x2c>
    7f3e:	29 81       	ldd	r18, Y+1	; 0x01
    7f40:	89 81       	ldd	r24, Y+1	; 0x01
    7f42:	9a 81       	ldd	r25, Y+2	; 0x02
    7f44:	82 53       	subi	r24, 0x32	; 50
    7f46:	9c 4d       	sbci	r25, 0xDC	; 220
    7f48:	fc 01       	movw	r30, r24
    7f4a:	20 83       	st	Z, r18
    7f4c:	89 81       	ldd	r24, Y+1	; 0x01
    7f4e:	9a 81       	ldd	r25, Y+2	; 0x02
    7f50:	01 96       	adiw	r24, 0x01	; 1
    7f52:	89 83       	std	Y+1, r24	; 0x01
    7f54:	9a 83       	std	Y+2, r25	; 0x02
    7f56:	89 81       	ldd	r24, Y+1	; 0x01
    7f58:	9a 81       	ldd	r25, Y+2	; 0x02
    7f5a:	88 31       	cpi	r24, 0x18	; 24
    7f5c:	91 05       	cpc	r25, r1
    7f5e:	7c f3       	brlt	.-34     	; 0x7f3e <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7f60:	2e ec       	ldi	r18, 0xCE	; 206
    7f62:	33 e2       	ldi	r19, 0x23	; 35
    7f64:	64 e1       	ldi	r22, 0x14	; 20
    7f66:	70 e0       	ldi	r23, 0x00	; 0
    7f68:	80 e0       	ldi	r24, 0x00	; 0
    7f6a:	90 e0       	ldi	r25, 0x00	; 0
    7f6c:	a9 01       	movw	r20, r18
    7f6e:	28 e1       	ldi	r18, 0x18	; 24
    7f70:	30 e0       	ldi	r19, 0x00	; 0
    7f72:	0e 94 2d 50 	call	0xa05a	; 0xa05a <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7f76:	1b 82       	std	Y+3, r1	; 0x03
    7f78:	1c 82       	std	Y+4, r1	; 0x04
    7f7a:	0b c0       	rjmp	.+22     	; 0x7f92 <SD_write_and_read_knowns+0x68>
    7f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    7f7e:	9c 81       	ldd	r25, Y+4	; 0x04
    7f80:	82 53       	subi	r24, 0x32	; 50
    7f82:	9c 4d       	sbci	r25, 0xDC	; 220
    7f84:	fc 01       	movw	r30, r24
    7f86:	10 82       	st	Z, r1
    7f88:	8b 81       	ldd	r24, Y+3	; 0x03
    7f8a:	9c 81       	ldd	r25, Y+4	; 0x04
    7f8c:	01 96       	adiw	r24, 0x01	; 1
    7f8e:	8b 83       	std	Y+3, r24	; 0x03
    7f90:	9c 83       	std	Y+4, r25	; 0x04
    7f92:	8b 81       	ldd	r24, Y+3	; 0x03
    7f94:	9c 81       	ldd	r25, Y+4	; 0x04
    7f96:	88 31       	cpi	r24, 0x18	; 24
    7f98:	91 05       	cpc	r25, r1
    7f9a:	84 f3       	brlt	.-32     	; 0x7f7c <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7f9c:	2e ec       	ldi	r18, 0xCE	; 206
    7f9e:	33 e2       	ldi	r19, 0x23	; 35
    7fa0:	64 e1       	ldi	r22, 0x14	; 20
    7fa2:	70 e0       	ldi	r23, 0x00	; 0
    7fa4:	80 e0       	ldi	r24, 0x00	; 0
    7fa6:	90 e0       	ldi	r25, 0x00	; 0
    7fa8:	a9 01       	movw	r20, r18
    7faa:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7fae:	1d 82       	std	Y+5, r1	; 0x05
    7fb0:	1e 82       	std	Y+6, r1	; 0x06
    7fb2:	13 c0       	rjmp	.+38     	; 0x7fda <SD_write_and_read_knowns+0xb0>
    7fb4:	8d 81       	ldd	r24, Y+5	; 0x05
    7fb6:	9e 81       	ldd	r25, Y+6	; 0x06
    7fb8:	24 e6       	ldi	r18, 0x64	; 100
    7fba:	30 e0       	ldi	r19, 0x00	; 0
    7fbc:	b9 01       	movw	r22, r18
    7fbe:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    7fc2:	28 2f       	mov	r18, r24
    7fc4:	8d 81       	ldd	r24, Y+5	; 0x05
    7fc6:	9e 81       	ldd	r25, Y+6	; 0x06
    7fc8:	82 53       	subi	r24, 0x32	; 50
    7fca:	9c 4d       	sbci	r25, 0xDC	; 220
    7fcc:	fc 01       	movw	r30, r24
    7fce:	20 83       	st	Z, r18
    7fd0:	8d 81       	ldd	r24, Y+5	; 0x05
    7fd2:	9e 81       	ldd	r25, Y+6	; 0x06
    7fd4:	01 96       	adiw	r24, 0x01	; 1
    7fd6:	8d 83       	std	Y+5, r24	; 0x05
    7fd8:	9e 83       	std	Y+6, r25	; 0x06
    7fda:	8d 81       	ldd	r24, Y+5	; 0x05
    7fdc:	9e 81       	ldd	r25, Y+6	; 0x06
    7fde:	f4 e0       	ldi	r31, 0x04	; 4
    7fe0:	82 3e       	cpi	r24, 0xE2	; 226
    7fe2:	9f 07       	cpc	r25, r31
    7fe4:	3c f3       	brlt	.-50     	; 0x7fb4 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7fe6:	2e ec       	ldi	r18, 0xCE	; 206
    7fe8:	33 e2       	ldi	r19, 0x23	; 35
    7fea:	60 e5       	ldi	r22, 0x50	; 80
    7fec:	70 e0       	ldi	r23, 0x00	; 0
    7fee:	80 e0       	ldi	r24, 0x00	; 0
    7ff0:	90 e0       	ldi	r25, 0x00	; 0
    7ff2:	a9 01       	movw	r20, r18
    7ff4:	22 ee       	ldi	r18, 0xE2	; 226
    7ff6:	34 e0       	ldi	r19, 0x04	; 4
    7ff8:	0e 94 71 51 	call	0xa2e2	; 0xa2e2 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7ffc:	1f 82       	std	Y+7, r1	; 0x07
    7ffe:	18 86       	std	Y+8, r1	; 0x08
    8000:	0b c0       	rjmp	.+22     	; 0x8018 <SD_write_and_read_knowns+0xee>
    8002:	8f 81       	ldd	r24, Y+7	; 0x07
    8004:	98 85       	ldd	r25, Y+8	; 0x08
    8006:	82 53       	subi	r24, 0x32	; 50
    8008:	9c 4d       	sbci	r25, 0xDC	; 220
    800a:	fc 01       	movw	r30, r24
    800c:	10 82       	st	Z, r1
    800e:	8f 81       	ldd	r24, Y+7	; 0x07
    8010:	98 85       	ldd	r25, Y+8	; 0x08
    8012:	01 96       	adiw	r24, 0x01	; 1
    8014:	8f 83       	std	Y+7, r24	; 0x07
    8016:	98 87       	std	Y+8, r25	; 0x08
    8018:	8f 81       	ldd	r24, Y+7	; 0x07
    801a:	98 85       	ldd	r25, Y+8	; 0x08
    801c:	f4 e0       	ldi	r31, 0x04	; 4
    801e:	82 3e       	cpi	r24, 0xE2	; 226
    8020:	9f 07       	cpc	r25, r31
    8022:	7c f3       	brlt	.-34     	; 0x8002 <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    8024:	2e ec       	ldi	r18, 0xCE	; 206
    8026:	33 e2       	ldi	r19, 0x23	; 35
    8028:	60 e5       	ldi	r22, 0x50	; 80
    802a:	70 e0       	ldi	r23, 0x00	; 0
    802c:	80 e0       	ldi	r24, 0x00	; 0
    802e:	90 e0       	ldi	r25, 0x00	; 0
    8030:	a9 01       	movw	r20, r18
    8032:	23 e0       	ldi	r18, 0x03	; 3
    8034:	30 e0       	ldi	r19, 0x00	; 0
    8036:	0e 94 cf 52 	call	0xa59e	; 0xa59e <SD_read_multiple_blocks>
}
    803a:	28 96       	adiw	r28, 0x08	; 8
    803c:	cd bf       	out	0x3d, r28	; 61
    803e:	de bf       	out	0x3e, r29	; 62
    8040:	df 91       	pop	r29
    8042:	cf 91       	pop	r28
    8044:	08 95       	ret

00008046 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    8046:	cf 93       	push	r28
    8048:	df 93       	push	r29
    804a:	00 d0       	rcall	.+0      	; 0x804c <SD_write_and_read_knowns_FAT+0x6>
    804c:	0f 92       	push	r0
    804e:	cd b7       	in	r28, 0x3d	; 61
    8050:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    8052:	19 82       	std	Y+1, r1	; 0x01
    8054:	1a 82       	std	Y+2, r1	; 0x02
    8056:	0c c0       	rjmp	.+24     	; 0x8070 <SD_write_and_read_knowns_FAT+0x2a>
    8058:	29 81       	ldd	r18, Y+1	; 0x01
    805a:	89 81       	ldd	r24, Y+1	; 0x01
    805c:	9a 81       	ldd	r25, Y+2	; 0x02
    805e:	82 53       	subi	r24, 0x32	; 50
    8060:	9c 4d       	sbci	r25, 0xDC	; 220
    8062:	fc 01       	movw	r30, r24
    8064:	20 83       	st	Z, r18
    8066:	89 81       	ldd	r24, Y+1	; 0x01
    8068:	9a 81       	ldd	r25, Y+2	; 0x02
    806a:	01 96       	adiw	r24, 0x01	; 1
    806c:	89 83       	std	Y+1, r24	; 0x01
    806e:	9a 83       	std	Y+2, r25	; 0x02
    8070:	89 81       	ldd	r24, Y+1	; 0x01
    8072:	9a 81       	ldd	r25, Y+2	; 0x02
    8074:	88 31       	cpi	r24, 0x18	; 24
    8076:	91 05       	cpc	r25, r1
    8078:	7c f3       	brlt	.-34     	; 0x8058 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",FRAMReadBuffer,512);
    807a:	8e e1       	ldi	r24, 0x1E	; 30
    807c:	90 e2       	ldi	r25, 0x20	; 32
    807e:	2e ec       	ldi	r18, 0xCE	; 206
    8080:	33 e2       	ldi	r19, 0x23	; 35
    8082:	b9 01       	movw	r22, r18
    8084:	20 e0       	ldi	r18, 0x00	; 0
    8086:	32 e0       	ldi	r19, 0x02	; 2
    8088:	40 e0       	ldi	r20, 0x00	; 0
    808a:	50 e0       	ldi	r21, 0x00	; 0
    808c:	0e 94 1b 48 	call	0x9036	; 0x9036 <writeFile>
    8090:	80 93 8e 50 	sts	0x508E, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    8094:	1b 82       	std	Y+3, r1	; 0x03
    8096:	1c 82       	std	Y+4, r1	; 0x04
    8098:	0b c0       	rjmp	.+22     	; 0x80b0 <SD_write_and_read_knowns_FAT+0x6a>
    809a:	8b 81       	ldd	r24, Y+3	; 0x03
    809c:	9c 81       	ldd	r25, Y+4	; 0x04
    809e:	82 53       	subi	r24, 0x32	; 50
    80a0:	9c 4d       	sbci	r25, 0xDC	; 220
    80a2:	fc 01       	movw	r30, r24
    80a4:	10 82       	st	Z, r1
    80a6:	8b 81       	ldd	r24, Y+3	; 0x03
    80a8:	9c 81       	ldd	r25, Y+4	; 0x04
    80aa:	01 96       	adiw	r24, 0x01	; 1
    80ac:	8b 83       	std	Y+3, r24	; 0x03
    80ae:	9c 83       	std	Y+4, r25	; 0x04
    80b0:	8b 81       	ldd	r24, Y+3	; 0x03
    80b2:	9c 81       	ldd	r25, Y+4	; 0x04
    80b4:	88 31       	cpi	r24, 0x18	; 24
    80b6:	91 05       	cpc	r25, r1
    80b8:	84 f3       	brlt	.-32     	; 0x809a <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    80ba:	2e e1       	ldi	r18, 0x1E	; 30
    80bc:	30 e2       	ldi	r19, 0x20	; 32
    80be:	80 e0       	ldi	r24, 0x00	; 0
    80c0:	b9 01       	movw	r22, r18
    80c2:	0e 94 36 46 	call	0x8c6c	; 0x8c6c <readFile>
    80c6:	80 93 8e 50 	sts	0x508E, r24
}
    80ca:	24 96       	adiw	r28, 0x04	; 4
    80cc:	cd bf       	out	0x3d, r28	; 61
    80ce:	de bf       	out	0x3e, r29	; 62
    80d0:	df 91       	pop	r29
    80d2:	cf 91       	pop	r28
    80d4:	08 95       	ret

000080d6 <chibi_test_radio>:
	//WriteRadioRegister(RADIOCTRLRGSTR, RX_ON);
	//sei();
}
*/
//function for testing radio transmission
void chibi_test_radio(){
    80d6:	cf 93       	push	r28
    80d8:	df 93       	push	r29
    80da:	cd b7       	in	r28, 0x3d	; 61
    80dc:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    80de:	0e 94 42 20 	call	0x4084	; 0x4084 <chb_init>
	chb_set_short_addr(0x0002);
    80e2:	82 e0       	ldi	r24, 0x02	; 2
    80e4:	90 e0       	ldi	r25, 0x00	; 0
    80e6:	0e 94 d6 2d 	call	0x5bac	; 0x5bac <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    80ea:	00 00       	nop
    80ec:	fe cf       	rjmp	.-4      	; 0x80ea <chibi_test_radio+0x14>

000080ee <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    80ee:	cf 93       	push	r28
    80f0:	df 93       	push	r29
    80f2:	0f 92       	push	r0
    80f4:	0f 92       	push	r0
    80f6:	cd b7       	in	r28, 0x3d	; 61
    80f8:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    80fa:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <SD_init>
	getBootSectorData();
    80fe:	0e 94 86 41 	call	0x830c	; 0x830c <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    8102:	19 82       	std	Y+1, r1	; 0x01
    8104:	1a 82       	std	Y+2, r1	; 0x02
    8106:	13 c0       	rjmp	.+38     	; 0x812e <TestCard+0x40>
    8108:	89 81       	ldd	r24, Y+1	; 0x01
    810a:	9a 81       	ldd	r25, Y+2	; 0x02
    810c:	29 e7       	ldi	r18, 0x79	; 121
    810e:	30 e0       	ldi	r19, 0x00	; 0
    8110:	b9 01       	movw	r22, r18
    8112:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    8116:	28 2f       	mov	r18, r24
    8118:	89 81       	ldd	r24, Y+1	; 0x01
    811a:	9a 81       	ldd	r25, Y+2	; 0x02
    811c:	82 53       	subi	r24, 0x32	; 50
    811e:	9c 4d       	sbci	r25, 0xDC	; 220
    8120:	fc 01       	movw	r30, r24
    8122:	20 83       	st	Z, r18
    8124:	89 81       	ldd	r24, Y+1	; 0x01
    8126:	9a 81       	ldd	r25, Y+2	; 0x02
    8128:	01 96       	adiw	r24, 0x01	; 1
    812a:	89 83       	std	Y+1, r24	; 0x01
    812c:	9a 83       	std	Y+2, r25	; 0x02
    812e:	89 81       	ldd	r24, Y+1	; 0x01
    8130:	9a 81       	ldd	r25, Y+2	; 0x02
    8132:	f2 e0       	ldi	r31, 0x02	; 2
    8134:	80 30       	cpi	r24, 0x00	; 0
    8136:	9f 07       	cpc	r25, r31
    8138:	3c f3       	brlt	.-50     	; 0x8108 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",FRAMReadBuffer,512);//}
    813a:	8e e1       	ldi	r24, 0x1E	; 30
    813c:	90 e2       	ldi	r25, 0x20	; 32
    813e:	2e ec       	ldi	r18, 0xCE	; 206
    8140:	33 e2       	ldi	r19, 0x23	; 35
    8142:	b9 01       	movw	r22, r18
    8144:	20 e0       	ldi	r18, 0x00	; 0
    8146:	32 e0       	ldi	r19, 0x02	; 2
    8148:	40 e0       	ldi	r20, 0x00	; 0
    814a:	50 e0       	ldi	r21, 0x00	; 0
    814c:	0e 94 1b 48 	call	0x9036	; 0x9036 <writeFile>
	nop();
    8150:	00 00       	nop
}
    8152:	0f 90       	pop	r0
    8154:	0f 90       	pop	r0
    8156:	df 91       	pop	r29
    8158:	cf 91       	pop	r28
    815a:	08 95       	ret

0000815c <__vector_43>:

//interrupt service routine for handling received data over radio
ISR(PORTE_INT0_vect){
    815c:	1f 92       	push	r1
    815e:	0f 92       	push	r0
    8160:	0f b6       	in	r0, 0x3f	; 63
    8162:	0f 92       	push	r0
    8164:	00 90 3b 00 	lds	r0, 0x003B
    8168:	0f 92       	push	r0
    816a:	11 24       	eor	r1, r1
    816c:	2f 93       	push	r18
    816e:	3f 93       	push	r19
    8170:	4f 93       	push	r20
    8172:	5f 93       	push	r21
    8174:	6f 93       	push	r22
    8176:	7f 93       	push	r23
    8178:	8f 93       	push	r24
    817a:	9f 93       	push	r25
    817c:	af 93       	push	r26
    817e:	bf 93       	push	r27
    8180:	ef 93       	push	r30
    8182:	ff 93       	push	r31
    8184:	cf 93       	push	r28
    8186:	df 93       	push	r29
    8188:	cd b7       	in	r28, 0x3d	; 61
    818a:	de b7       	in	r29, 0x3e	; 62
    818c:	c4 58       	subi	r28, 0x84	; 132
    818e:	d0 40       	sbci	r29, 0x00	; 0
    8190:	cd bf       	out	0x3d, r28	; 61
    8192:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    8194:	80 91 4d 40 	lds	r24, 0x404D
    8198:	88 2f       	mov	r24, r24
    819a:	90 e0       	ldi	r25, 0x00	; 0
    819c:	81 30       	cpi	r24, 0x01	; 1
    819e:	91 05       	cpc	r25, r1
    81a0:	29 f0       	breq	.+10     	; 0x81ac <__vector_43+0x50>
    81a2:	82 30       	cpi	r24, 0x02	; 2
    81a4:	91 05       	cpc	r25, r1
    81a6:	09 f4       	brne	.+2      	; 0x81aa <__vector_43+0x4e>
    81a8:	73 c0       	rjmp	.+230    	; 0x8290 <__vector_43+0x134>
    81aa:	91 c0       	rjmp	.+290    	; 0x82ce <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    81ac:	ce 01       	movw	r24, r28
    81ae:	05 96       	adiw	r24, 0x05	; 5
    81b0:	0e 94 8e 22 	call	0x451c	; 0x451c <chb_read>
			if(!strncmp(msg,ResetCommand,5)){
    81b4:	ce 01       	movw	r24, r28
    81b6:	05 96       	adiw	r24, 0x05	; 5
    81b8:	26 ea       	ldi	r18, 0xA6	; 166
    81ba:	30 e5       	ldi	r19, 0x50	; 80
    81bc:	b9 01       	movw	r22, r18
    81be:	45 e0       	ldi	r20, 0x05	; 5
    81c0:	50 e0       	ldi	r21, 0x00	; 0
    81c2:	0e 94 b1 5f 	call	0xbf62	; 0xbf62 <strncmp>
    81c6:	00 97       	sbiw	r24, 0x00	; 0
    81c8:	51 f4       	brne	.+20     	; 0x81de <__vector_43+0x82>
				MotesReadyToSynch++;
    81ca:	80 91 63 50 	lds	r24, 0x5063
    81ce:	90 91 64 50 	lds	r25, 0x5064
    81d2:	01 96       	adiw	r24, 0x01	; 1
    81d4:	80 93 63 50 	sts	0x5063, r24
    81d8:	90 93 64 50 	sts	0x5064, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    81dc:	7a c0       	rjmp	.+244    	; 0x82d2 <__vector_43+0x176>
			if(!strncmp(msg,ResetCommand,5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    81de:	19 82       	std	Y+1, r1	; 0x01
    81e0:	1a 82       	std	Y+2, r1	; 0x02
    81e2:	1b 82       	std	Y+3, r1	; 0x03
    81e4:	1c 82       	std	Y+4, r1	; 0x04
    81e6:	1a c0       	rjmp	.+52     	; 0x821c <__vector_43+0xc0>
    81e8:	9e 01       	movw	r18, r28
    81ea:	2b 5f       	subi	r18, 0xFB	; 251
    81ec:	3f 4f       	sbci	r19, 0xFF	; 255
    81ee:	89 81       	ldd	r24, Y+1	; 0x01
    81f0:	9a 81       	ldd	r25, Y+2	; 0x02
    81f2:	82 0f       	add	r24, r18
    81f4:	93 1f       	adc	r25, r19
    81f6:	fc 01       	movw	r30, r24
    81f8:	20 81       	ld	r18, Z
    81fa:	89 81       	ldd	r24, Y+1	; 0x01
    81fc:	9a 81       	ldd	r25, Y+2	; 0x02
    81fe:	82 53       	subi	r24, 0x32	; 50
    8200:	9c 4d       	sbci	r25, 0xDC	; 220
    8202:	fc 01       	movw	r30, r24
    8204:	20 83       	st	Z, r18
    8206:	89 81       	ldd	r24, Y+1	; 0x01
    8208:	9a 81       	ldd	r25, Y+2	; 0x02
    820a:	ab 81       	ldd	r26, Y+3	; 0x03
    820c:	bc 81       	ldd	r27, Y+4	; 0x04
    820e:	01 96       	adiw	r24, 0x01	; 1
    8210:	a1 1d       	adc	r26, r1
    8212:	b1 1d       	adc	r27, r1
    8214:	89 83       	std	Y+1, r24	; 0x01
    8216:	9a 83       	std	Y+2, r25	; 0x02
    8218:	ab 83       	std	Y+3, r26	; 0x03
    821a:	bc 83       	std	Y+4, r27	; 0x04
    821c:	89 81       	ldd	r24, Y+1	; 0x01
    821e:	9a 81       	ldd	r25, Y+2	; 0x02
    8220:	ab 81       	ldd	r26, Y+3	; 0x03
    8222:	bc 81       	ldd	r27, Y+4	; 0x04
    8224:	80 38       	cpi	r24, 0x80	; 128
    8226:	91 05       	cpc	r25, r1
    8228:	a1 05       	cpc	r26, r1
    822a:	b1 05       	cpc	r27, r1
    822c:	e8 f2       	brcs	.-70     	; 0x81e8 <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    822e:	80 91 ca 50 	lds	r24, 0x50CA
    8232:	90 91 cb 50 	lds	r25, 0x50CB
    8236:	a0 91 cc 50 	lds	r26, 0x50CC
    823a:	b0 91 cd 50 	lds	r27, 0x50CD
    823e:	80 58       	subi	r24, 0x80	; 128
    8240:	9f 4f       	sbci	r25, 0xFF	; 255
    8242:	af 4f       	sbci	r26, 0xFF	; 255
    8244:	bf 4f       	sbci	r27, 0xFF	; 255
    8246:	80 93 ca 50 	sts	0x50CA, r24
    824a:	90 93 cb 50 	sts	0x50CB, r25
    824e:	a0 93 cc 50 	sts	0x50CC, r26
    8252:	b0 93 cd 50 	sts	0x50CD, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    8256:	80 91 ca 50 	lds	r24, 0x50CA
    825a:	90 91 cb 50 	lds	r25, 0x50CB
    825e:	a0 91 cc 50 	lds	r26, 0x50CC
    8262:	b0 91 cd 50 	lds	r27, 0x50CD
    8266:	80 58       	subi	r24, 0x80	; 128
    8268:	9f 4f       	sbci	r25, 0xFF	; 255
    826a:	af 4f       	sbci	r26, 0xFF	; 255
    826c:	bf 4f       	sbci	r27, 0xFF	; 255
    826e:	81 37       	cpi	r24, 0x71	; 113
    8270:	fc e1       	ldi	r31, 0x1C	; 28
    8272:	9f 07       	cpc	r25, r31
    8274:	f0 e0       	ldi	r31, 0x00	; 0
    8276:	af 07       	cpc	r26, r31
    8278:	f0 e0       	ldi	r31, 0x00	; 0
    827a:	bf 07       	cpc	r27, r31
    827c:	50 f1       	brcs	.+84     	; 0x82d2 <__vector_43+0x176>
    827e:	10 92 ca 50 	sts	0x50CA, r1
    8282:	10 92 cb 50 	sts	0x50CB, r1
    8286:	10 92 cc 50 	sts	0x50CC, r1
    828a:	10 92 cd 50 	sts	0x50CD, r1
			}			
			break;
    828e:	21 c0       	rjmp	.+66     	; 0x82d2 <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    8290:	ce 01       	movw	r24, r28
    8292:	05 96       	adiw	r24, 0x05	; 5
    8294:	0e 94 8e 22 	call	0x451c	; 0x451c <chb_read>
			if(!strncmp(msg,BasestationSynchResponse,15)){	//if basestation synch response message received, do the following
    8298:	ce 01       	movw	r24, r28
    829a:	05 96       	adiw	r24, 0x05	; 5
    829c:	2f e0       	ldi	r18, 0x0F	; 15
    829e:	30 e2       	ldi	r19, 0x20	; 32
    82a0:	b9 01       	movw	r22, r18
    82a2:	4f e0       	ldi	r20, 0x0F	; 15
    82a4:	50 e0       	ldi	r21, 0x00	; 0
    82a6:	0e 94 b1 5f 	call	0xbf62	; 0xbf62 <strncmp>
    82aa:	00 97       	sbiw	r24, 0x00	; 0
    82ac:	a1 f4       	brne	.+40     	; 0x82d6 <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    82ae:	83 e0       	ldi	r24, 0x03	; 3
    82b0:	80 93 4d 40 	sts	0x404D, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    82b4:	80 e4       	ldi	r24, 0x40	; 64
    82b6:	99 e0       	ldi	r25, 0x09	; 9
    82b8:	29 e0       	ldi	r18, 0x09	; 9
    82ba:	fc 01       	movw	r30, r24
    82bc:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    82be:	80 e4       	ldi	r24, 0x40	; 64
    82c0:	98 e0       	ldi	r25, 0x08	; 8
    82c2:	21 e0       	ldi	r18, 0x01	; 1
    82c4:	fc 01       	movw	r30, r24
    82c6:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    82c8:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <ADC_Resume_Sampling>
			}
			break;
    82cc:	04 c0       	rjmp	.+8      	; 0x82d6 <__vector_43+0x17a>
		default:
			break;
    82ce:	00 00       	nop
    82d0:	03 c0       	rjmp	.+6      	; 0x82d8 <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    82d2:	00 00       	nop
    82d4:	01 c0       	rjmp	.+2      	; 0x82d8 <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    82d6:	00 00       	nop
		default:
			break;
	}
    82d8:	cc 57       	subi	r28, 0x7C	; 124
    82da:	df 4f       	sbci	r29, 0xFF	; 255
    82dc:	cd bf       	out	0x3d, r28	; 61
    82de:	de bf       	out	0x3e, r29	; 62
    82e0:	df 91       	pop	r29
    82e2:	cf 91       	pop	r28
    82e4:	ff 91       	pop	r31
    82e6:	ef 91       	pop	r30
    82e8:	bf 91       	pop	r27
    82ea:	af 91       	pop	r26
    82ec:	9f 91       	pop	r25
    82ee:	8f 91       	pop	r24
    82f0:	7f 91       	pop	r23
    82f2:	6f 91       	pop	r22
    82f4:	5f 91       	pop	r21
    82f6:	4f 91       	pop	r20
    82f8:	3f 91       	pop	r19
    82fa:	2f 91       	pop	r18
    82fc:	0f 90       	pop	r0
    82fe:	00 92 3b 00 	sts	0x003B, r0
    8302:	0f 90       	pop	r0
    8304:	0f be       	out	0x3f, r0	; 63
    8306:	0f 90       	pop	r0
    8308:	1f 90       	pop	r1
    830a:	18 95       	reti

0000830c <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    830c:	ef 92       	push	r14
    830e:	ff 92       	push	r15
    8310:	0f 93       	push	r16
    8312:	1f 93       	push	r17
    8314:	cf 93       	push	r28
    8316:	df 93       	push	r29
    8318:	cd b7       	in	r28, 0x3d	; 61
    831a:	de b7       	in	r29, 0x3e	; 62
    831c:	2a 97       	sbiw	r28, 0x0a	; 10
    831e:	cd bf       	out	0x3d, r28	; 61
    8320:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    8322:	10 92 68 50 	sts	0x5068, r1
    8326:	10 92 69 50 	sts	0x5069, r1
    832a:	10 92 6a 50 	sts	0x506A, r1
    832e:	10 92 6b 50 	sts	0x506B, r1

SD_read_block(0,SDBuffer);
    8332:	25 ec       	ldi	r18, 0xC5	; 197
    8334:	31 e2       	ldi	r19, 0x21	; 33
    8336:	60 e0       	ldi	r22, 0x00	; 0
    8338:	70 e0       	ldi	r23, 0x00	; 0
    833a:	cb 01       	movw	r24, r22
    833c:	a9 01       	movw	r20, r18
    833e:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    8342:	85 ec       	ldi	r24, 0xC5	; 197
    8344:	91 e2       	ldi	r25, 0x21	; 33
    8346:	89 83       	std	Y+1, r24	; 0x01
    8348:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    834a:	89 81       	ldd	r24, Y+1	; 0x01
    834c:	9a 81       	ldd	r25, Y+2	; 0x02
    834e:	fc 01       	movw	r30, r24
    8350:	80 81       	ld	r24, Z
    8352:	89 3e       	cpi	r24, 0xE9	; 233
    8354:	09 f4       	brne	.+2      	; 0x8358 <getBootSectorData+0x4c>
    8356:	4d c0       	rjmp	.+154    	; 0x83f2 <getBootSectorData+0xe6>
    8358:	89 81       	ldd	r24, Y+1	; 0x01
    835a:	9a 81       	ldd	r25, Y+2	; 0x02
    835c:	fc 01       	movw	r30, r24
    835e:	80 81       	ld	r24, Z
    8360:	8b 3e       	cpi	r24, 0xEB	; 235
    8362:	09 f4       	brne	.+2      	; 0x8366 <getBootSectorData+0x5a>
    8364:	46 c0       	rjmp	.+140    	; 0x83f2 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    8366:	85 ec       	ldi	r24, 0xC5	; 197
    8368:	91 e2       	ldi	r25, 0x21	; 33
    836a:	8b 83       	std	Y+3, r24	; 0x03
    836c:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    836e:	8b 81       	ldd	r24, Y+3	; 0x03
    8370:	9c 81       	ldd	r25, Y+4	; 0x04
    8372:	82 50       	subi	r24, 0x02	; 2
    8374:	9e 4f       	sbci	r25, 0xFE	; 254
    8376:	fc 01       	movw	r30, r24
    8378:	80 81       	ld	r24, Z
    837a:	91 81       	ldd	r25, Z+1	; 0x01
    837c:	fa ea       	ldi	r31, 0xAA	; 170
    837e:	85 35       	cpi	r24, 0x55	; 85
    8380:	9f 07       	cpc	r25, r31
    8382:	11 f0       	breq	.+4      	; 0x8388 <getBootSectorData+0x7c>
    8384:	81 e0       	ldi	r24, 0x01	; 1
    8386:	01 c1       	rjmp	.+514    	; 0x858a <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    8388:	8b 81       	ldd	r24, Y+3	; 0x03
    838a:	9c 81       	ldd	r25, Y+4	; 0x04
    838c:	82 54       	subi	r24, 0x42	; 66
    838e:	9e 4f       	sbci	r25, 0xFE	; 254
    8390:	8d 83       	std	Y+5, r24	; 0x05
    8392:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    8394:	8d 81       	ldd	r24, Y+5	; 0x05
    8396:	9e 81       	ldd	r25, Y+6	; 0x06
    8398:	fc 01       	movw	r30, r24
    839a:	80 85       	ldd	r24, Z+8	; 0x08
    839c:	91 85       	ldd	r25, Z+9	; 0x09
    839e:	a2 85       	ldd	r26, Z+10	; 0x0a
    83a0:	b3 85       	ldd	r27, Z+11	; 0x0b
    83a2:	80 93 68 50 	sts	0x5068, r24
    83a6:	90 93 69 50 	sts	0x5069, r25
    83aa:	a0 93 6a 50 	sts	0x506A, r26
    83ae:	b0 93 6b 50 	sts	0x506B, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    83b2:	8d 81       	ldd	r24, Y+5	; 0x05
    83b4:	9e 81       	ldd	r25, Y+6	; 0x06
    83b6:	fc 01       	movw	r30, r24
    83b8:	80 85       	ldd	r24, Z+8	; 0x08
    83ba:	91 85       	ldd	r25, Z+9	; 0x09
    83bc:	a2 85       	ldd	r26, Z+10	; 0x0a
    83be:	b3 85       	ldd	r27, Z+11	; 0x0b
    83c0:	25 ec       	ldi	r18, 0xC5	; 197
    83c2:	31 e2       	ldi	r19, 0x21	; 33
    83c4:	bc 01       	movw	r22, r24
    83c6:	cd 01       	movw	r24, r26
    83c8:	a9 01       	movw	r20, r18
    83ca:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    83ce:	85 ec       	ldi	r24, 0xC5	; 197
    83d0:	91 e2       	ldi	r25, 0x21	; 33
    83d2:	89 83       	std	Y+1, r24	; 0x01
    83d4:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    83d6:	89 81       	ldd	r24, Y+1	; 0x01
    83d8:	9a 81       	ldd	r25, Y+2	; 0x02
    83da:	fc 01       	movw	r30, r24
    83dc:	80 81       	ld	r24, Z
    83de:	89 3e       	cpi	r24, 0xE9	; 233
    83e0:	41 f0       	breq	.+16     	; 0x83f2 <getBootSectorData+0xe6>
    83e2:	89 81       	ldd	r24, Y+1	; 0x01
    83e4:	9a 81       	ldd	r25, Y+2	; 0x02
    83e6:	fc 01       	movw	r30, r24
    83e8:	80 81       	ld	r24, Z
    83ea:	8b 3e       	cpi	r24, 0xEB	; 235
    83ec:	11 f0       	breq	.+4      	; 0x83f2 <getBootSectorData+0xe6>
    83ee:	81 e0       	ldi	r24, 0x01	; 1
    83f0:	cc c0       	rjmp	.+408    	; 0x858a <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    83f2:	89 81       	ldd	r24, Y+1	; 0x01
    83f4:	9a 81       	ldd	r25, Y+2	; 0x02
    83f6:	fc 01       	movw	r30, r24
    83f8:	83 85       	ldd	r24, Z+11	; 0x0b
    83fa:	94 85       	ldd	r25, Z+12	; 0x0c
    83fc:	80 93 43 40 	sts	0x4043, r24
    8400:	90 93 44 40 	sts	0x4044, r25
sectorPerCluster = bpb->sectorPerCluster;
    8404:	89 81       	ldd	r24, Y+1	; 0x01
    8406:	9a 81       	ldd	r25, Y+2	; 0x02
    8408:	fc 01       	movw	r30, r24
    840a:	85 85       	ldd	r24, Z+13	; 0x0d
    840c:	88 2f       	mov	r24, r24
    840e:	90 e0       	ldi	r25, 0x00	; 0
    8410:	80 93 66 50 	sts	0x5066, r24
    8414:	90 93 67 50 	sts	0x5067, r25
reservedSectorCount = bpb->reservedSectorCount;
    8418:	89 81       	ldd	r24, Y+1	; 0x01
    841a:	9a 81       	ldd	r25, Y+2	; 0x02
    841c:	fc 01       	movw	r30, r24
    841e:	86 85       	ldd	r24, Z+14	; 0x0e
    8420:	97 85       	ldd	r25, Z+15	; 0x0f
    8422:	80 93 6e 50 	sts	0x506E, r24
    8426:	90 93 6f 50 	sts	0x506F, r25
rootCluster = bpb->rootCluster;
    842a:	89 81       	ldd	r24, Y+1	; 0x01
    842c:	9a 81       	ldd	r25, Y+2	; 0x02
    842e:	fc 01       	movw	r30, r24
    8430:	84 a5       	lds	r24, 0x64
    8432:	95 a5       	lds	r25, 0x65
    8434:	a6 a5       	lds	r26, 0x66
    8436:	b7 a5       	lds	r27, 0x67
    8438:	80 93 4e 40 	sts	0x404E, r24
    843c:	90 93 4f 40 	sts	0x404F, r25
    8440:	a0 93 50 40 	sts	0x4050, r26
    8444:	b0 93 51 40 	sts	0x4051, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    8448:	89 81       	ldd	r24, Y+1	; 0x01
    844a:	9a 81       	ldd	r25, Y+2	; 0x02
    844c:	fc 01       	movw	r30, r24
    844e:	24 8d       	ldd	r18, Z+28	; 0x1c
    8450:	35 8d       	ldd	r19, Z+29	; 0x1d
    8452:	46 8d       	ldd	r20, Z+30	; 0x1e
    8454:	57 8d       	ldd	r21, Z+31	; 0x1f
    8456:	80 91 6e 50 	lds	r24, 0x506E
    845a:	90 91 6f 50 	lds	r25, 0x506F
    845e:	cc 01       	movw	r24, r24
    8460:	a0 e0       	ldi	r26, 0x00	; 0
    8462:	b0 e0       	ldi	r27, 0x00	; 0
    8464:	79 01       	movw	r14, r18
    8466:	8a 01       	movw	r16, r20
    8468:	e8 0e       	add	r14, r24
    846a:	f9 1e       	adc	r15, r25
    846c:	0a 1f       	adc	r16, r26
    846e:	1b 1f       	adc	r17, r27
    8470:	89 81       	ldd	r24, Y+1	; 0x01
    8472:	9a 81       	ldd	r25, Y+2	; 0x02
    8474:	fc 01       	movw	r30, r24
    8476:	80 89       	ldd	r24, Z+16	; 0x10
    8478:	88 2f       	mov	r24, r24
    847a:	90 e0       	ldi	r25, 0x00	; 0
    847c:	a0 e0       	ldi	r26, 0x00	; 0
    847e:	b0 e0       	ldi	r27, 0x00	; 0
    8480:	29 81       	ldd	r18, Y+1	; 0x01
    8482:	3a 81       	ldd	r19, Y+2	; 0x02
    8484:	f9 01       	movw	r30, r18
    8486:	24 a1       	lds	r18, 0x44
    8488:	35 a1       	lds	r19, 0x45
    848a:	46 a1       	lds	r20, 0x46
    848c:	57 a1       	lds	r21, 0x47
    848e:	bc 01       	movw	r22, r24
    8490:	cd 01       	movw	r24, r26
    8492:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    8496:	dc 01       	movw	r26, r24
    8498:	cb 01       	movw	r24, r22
    849a:	8e 0d       	add	r24, r14
    849c:	9f 1d       	adc	r25, r15
    849e:	a0 1f       	adc	r26, r16
    84a0:	b1 1f       	adc	r27, r17
    84a2:	80 93 ca 23 	sts	0x23CA, r24
    84a6:	90 93 cb 23 	sts	0x23CB, r25
    84aa:	a0 93 cc 23 	sts	0x23CC, r26
    84ae:	b0 93 cd 23 	sts	0x23CD, r27

dataSectors = bpb->totalSectors_F32
    84b2:	89 81       	ldd	r24, Y+1	; 0x01
    84b4:	9a 81       	ldd	r25, Y+2	; 0x02
    84b6:	fc 01       	movw	r30, r24
    84b8:	20 a1       	lds	r18, 0x40
    84ba:	31 a1       	lds	r19, 0x41
    84bc:	42 a1       	lds	r20, 0x42
    84be:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    84c0:	89 81       	ldd	r24, Y+1	; 0x01
    84c2:	9a 81       	ldd	r25, Y+2	; 0x02
    84c4:	fc 01       	movw	r30, r24
    84c6:	86 85       	ldd	r24, Z+14	; 0x0e
    84c8:	97 85       	ldd	r25, Z+15	; 0x0f
    84ca:	cc 01       	movw	r24, r24
    84cc:	a0 e0       	ldi	r26, 0x00	; 0
    84ce:	b0 e0       	ldi	r27, 0x00	; 0
    84d0:	79 01       	movw	r14, r18
    84d2:	8a 01       	movw	r16, r20
    84d4:	e8 1a       	sub	r14, r24
    84d6:	f9 0a       	sbc	r15, r25
    84d8:	0a 0b       	sbc	r16, r26
    84da:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    84dc:	89 81       	ldd	r24, Y+1	; 0x01
    84de:	9a 81       	ldd	r25, Y+2	; 0x02
    84e0:	fc 01       	movw	r30, r24
    84e2:	80 89       	ldd	r24, Z+16	; 0x10
    84e4:	88 2f       	mov	r24, r24
    84e6:	90 e0       	ldi	r25, 0x00	; 0
    84e8:	a0 e0       	ldi	r26, 0x00	; 0
    84ea:	b0 e0       	ldi	r27, 0x00	; 0
    84ec:	29 81       	ldd	r18, Y+1	; 0x01
    84ee:	3a 81       	ldd	r19, Y+2	; 0x02
    84f0:	f9 01       	movw	r30, r18
    84f2:	24 a1       	lds	r18, 0x44
    84f4:	35 a1       	lds	r19, 0x45
    84f6:	46 a1       	lds	r20, 0x46
    84f8:	57 a1       	lds	r21, 0x47
    84fa:	bc 01       	movw	r22, r24
    84fc:	cd 01       	movw	r24, r26
    84fe:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    8502:	dc 01       	movw	r26, r24
    8504:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    8506:	a8 01       	movw	r20, r16
    8508:	97 01       	movw	r18, r14
    850a:	28 1b       	sub	r18, r24
    850c:	39 0b       	sbc	r19, r25
    850e:	4a 0b       	sbc	r20, r26
    8510:	5b 0b       	sbc	r21, r27
    8512:	da 01       	movw	r26, r20
    8514:	c9 01       	movw	r24, r18
    8516:	8f 83       	std	Y+7, r24	; 0x07
    8518:	98 87       	std	Y+8, r25	; 0x08
    851a:	a9 87       	std	Y+9, r26	; 0x09
    851c:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    851e:	80 91 66 50 	lds	r24, 0x5066
    8522:	90 91 67 50 	lds	r25, 0x5067
    8526:	9c 01       	movw	r18, r24
    8528:	40 e0       	ldi	r20, 0x00	; 0
    852a:	50 e0       	ldi	r21, 0x00	; 0
    852c:	8f 81       	ldd	r24, Y+7	; 0x07
    852e:	98 85       	ldd	r25, Y+8	; 0x08
    8530:	a9 85       	ldd	r26, Y+9	; 0x09
    8532:	ba 85       	ldd	r27, Y+10	; 0x0a
    8534:	bc 01       	movw	r22, r24
    8536:	cd 01       	movw	r24, r26
    8538:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    853c:	da 01       	movw	r26, r20
    853e:	c9 01       	movw	r24, r18
    8540:	80 93 48 40 	sts	0x4048, r24
    8544:	90 93 49 40 	sts	0x4049, r25
    8548:	a0 93 4a 40 	sts	0x404A, r26
    854c:	b0 93 4b 40 	sts	0x404B, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    8550:	81 e0       	ldi	r24, 0x01	; 1
    8552:	60 e0       	ldi	r22, 0x00	; 0
    8554:	20 e0       	ldi	r18, 0x00	; 0
    8556:	30 e0       	ldi	r19, 0x00	; 0
    8558:	a9 01       	movw	r20, r18
    855a:	0e 94 ab 43 	call	0x8756	; 0x8756 <getSetFreeCluster>
    855e:	9b 01       	movw	r18, r22
    8560:	ac 01       	movw	r20, r24
    8562:	80 91 48 40 	lds	r24, 0x4048
    8566:	90 91 49 40 	lds	r25, 0x4049
    856a:	a0 91 4a 40 	lds	r26, 0x404A
    856e:	b0 91 4b 40 	lds	r27, 0x404B
    8572:	82 17       	cp	r24, r18
    8574:	93 07       	cpc	r25, r19
    8576:	a4 07       	cpc	r26, r20
    8578:	b5 07       	cpc	r27, r21
    857a:	18 f4       	brcc	.+6      	; 0x8582 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    857c:	10 92 cf 50 	sts	0x50CF, r1
    8580:	03 c0       	rjmp	.+6      	; 0x8588 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    8582:	81 e0       	ldi	r24, 0x01	; 1
    8584:	80 93 cf 50 	sts	0x50CF, r24
return 0;
    8588:	80 e0       	ldi	r24, 0x00	; 0
}
    858a:	2a 96       	adiw	r28, 0x0a	; 10
    858c:	cd bf       	out	0x3d, r28	; 61
    858e:	de bf       	out	0x3e, r29	; 62
    8590:	df 91       	pop	r29
    8592:	cf 91       	pop	r28
    8594:	1f 91       	pop	r17
    8596:	0f 91       	pop	r16
    8598:	ff 90       	pop	r15
    859a:	ef 90       	pop	r14
    859c:	08 95       	ret

0000859e <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    859e:	cf 93       	push	r28
    85a0:	df 93       	push	r29
    85a2:	00 d0       	rcall	.+0      	; 0x85a4 <getFirstSector+0x6>
    85a4:	0f 92       	push	r0
    85a6:	cd b7       	in	r28, 0x3d	; 61
    85a8:	de b7       	in	r29, 0x3e	; 62
    85aa:	69 83       	std	Y+1, r22	; 0x01
    85ac:	7a 83       	std	Y+2, r23	; 0x02
    85ae:	8b 83       	std	Y+3, r24	; 0x03
    85b0:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    85b2:	89 81       	ldd	r24, Y+1	; 0x01
    85b4:	9a 81       	ldd	r25, Y+2	; 0x02
    85b6:	ab 81       	ldd	r26, Y+3	; 0x03
    85b8:	bc 81       	ldd	r27, Y+4	; 0x04
    85ba:	02 97       	sbiw	r24, 0x02	; 2
    85bc:	a1 09       	sbc	r26, r1
    85be:	b1 09       	sbc	r27, r1
    85c0:	20 91 66 50 	lds	r18, 0x5066
    85c4:	30 91 67 50 	lds	r19, 0x5067
    85c8:	99 01       	movw	r18, r18
    85ca:	40 e0       	ldi	r20, 0x00	; 0
    85cc:	50 e0       	ldi	r21, 0x00	; 0
    85ce:	bc 01       	movw	r22, r24
    85d0:	cd 01       	movw	r24, r26
    85d2:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    85d6:	9b 01       	movw	r18, r22
    85d8:	ac 01       	movw	r20, r24
    85da:	80 91 ca 23 	lds	r24, 0x23CA
    85de:	90 91 cb 23 	lds	r25, 0x23CB
    85e2:	a0 91 cc 23 	lds	r26, 0x23CC
    85e6:	b0 91 cd 23 	lds	r27, 0x23CD
    85ea:	82 0f       	add	r24, r18
    85ec:	93 1f       	adc	r25, r19
    85ee:	a4 1f       	adc	r26, r20
    85f0:	b5 1f       	adc	r27, r21
}
    85f2:	bc 01       	movw	r22, r24
    85f4:	cd 01       	movw	r24, r26
    85f6:	24 96       	adiw	r28, 0x04	; 4
    85f8:	cd bf       	out	0x3d, r28	; 61
    85fa:	de bf       	out	0x3e, r29	; 62
    85fc:	df 91       	pop	r29
    85fe:	cf 91       	pop	r28
    8600:	08 95       	ret

00008602 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    8602:	ef 92       	push	r14
    8604:	ff 92       	push	r15
    8606:	0f 93       	push	r16
    8608:	1f 93       	push	r17
    860a:	cf 93       	push	r28
    860c:	df 93       	push	r29
    860e:	cd b7       	in	r28, 0x3d	; 61
    8610:	de b7       	in	r29, 0x3e	; 62
    8612:	62 97       	sbiw	r28, 0x12	; 18
    8614:	cd bf       	out	0x3d, r28	; 61
    8616:	de bf       	out	0x3e, r29	; 62
    8618:	6a 87       	std	Y+10, r22	; 0x0a
    861a:	7b 87       	std	Y+11, r23	; 0x0b
    861c:	8c 87       	std	Y+12, r24	; 0x0c
    861e:	9d 87       	std	Y+13, r25	; 0x0d
    8620:	4e 87       	std	Y+14, r20	; 0x0e
    8622:	0f 87       	std	Y+15, r16	; 0x0f
    8624:	18 8b       	std	Y+16, r17	; 0x10
    8626:	29 8b       	std	Y+17, r18	; 0x11
    8628:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    862a:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    862c:	80 91 6e 50 	lds	r24, 0x506E
    8630:	90 91 6f 50 	lds	r25, 0x506F
    8634:	9c 01       	movw	r18, r24
    8636:	40 e0       	ldi	r20, 0x00	; 0
    8638:	50 e0       	ldi	r21, 0x00	; 0
    863a:	80 91 68 50 	lds	r24, 0x5068
    863e:	90 91 69 50 	lds	r25, 0x5069
    8642:	a0 91 6a 50 	lds	r26, 0x506A
    8646:	b0 91 6b 50 	lds	r27, 0x506B
    864a:	79 01       	movw	r14, r18
    864c:	8a 01       	movw	r16, r20
    864e:	e8 0e       	add	r14, r24
    8650:	f9 1e       	adc	r15, r25
    8652:	0a 1f       	adc	r16, r26
    8654:	1b 1f       	adc	r17, r27
    8656:	8a 85       	ldd	r24, Y+10	; 0x0a
    8658:	9b 85       	ldd	r25, Y+11	; 0x0b
    865a:	ac 85       	ldd	r26, Y+12	; 0x0c
    865c:	bd 85       	ldd	r27, Y+13	; 0x0d
    865e:	88 0f       	add	r24, r24
    8660:	99 1f       	adc	r25, r25
    8662:	aa 1f       	adc	r26, r26
    8664:	bb 1f       	adc	r27, r27
    8666:	88 0f       	add	r24, r24
    8668:	99 1f       	adc	r25, r25
    866a:	aa 1f       	adc	r26, r26
    866c:	bb 1f       	adc	r27, r27
    866e:	20 91 43 40 	lds	r18, 0x4043
    8672:	30 91 44 40 	lds	r19, 0x4044
    8676:	99 01       	movw	r18, r18
    8678:	40 e0       	ldi	r20, 0x00	; 0
    867a:	50 e0       	ldi	r21, 0x00	; 0
    867c:	bc 01       	movw	r22, r24
    867e:	cd 01       	movw	r24, r26
    8680:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    8684:	da 01       	movw	r26, r20
    8686:	c9 01       	movw	r24, r18
    8688:	8e 0d       	add	r24, r14
    868a:	9f 1d       	adc	r25, r15
    868c:	a0 1f       	adc	r26, r16
    868e:	b1 1f       	adc	r27, r17
    8690:	8a 83       	std	Y+2, r24	; 0x02
    8692:	9b 83       	std	Y+3, r25	; 0x03
    8694:	ac 83       	std	Y+4, r26	; 0x04
    8696:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    8698:	8a 85       	ldd	r24, Y+10	; 0x0a
    869a:	9b 85       	ldd	r25, Y+11	; 0x0b
    869c:	ac 85       	ldd	r26, Y+12	; 0x0c
    869e:	bd 85       	ldd	r27, Y+13	; 0x0d
    86a0:	88 0f       	add	r24, r24
    86a2:	99 1f       	adc	r25, r25
    86a4:	aa 1f       	adc	r26, r26
    86a6:	bb 1f       	adc	r27, r27
    86a8:	88 0f       	add	r24, r24
    86aa:	99 1f       	adc	r25, r25
    86ac:	aa 1f       	adc	r26, r26
    86ae:	bb 1f       	adc	r27, r27
    86b0:	20 91 43 40 	lds	r18, 0x4043
    86b4:	30 91 44 40 	lds	r19, 0x4044
    86b8:	99 01       	movw	r18, r18
    86ba:	40 e0       	ldi	r20, 0x00	; 0
    86bc:	50 e0       	ldi	r21, 0x00	; 0
    86be:	bc 01       	movw	r22, r24
    86c0:	cd 01       	movw	r24, r26
    86c2:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    86c6:	dc 01       	movw	r26, r24
    86c8:	cb 01       	movw	r24, r22
    86ca:	8e 83       	std	Y+6, r24	; 0x06
    86cc:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    86ce:	8a 81       	ldd	r24, Y+2	; 0x02
    86d0:	9b 81       	ldd	r25, Y+3	; 0x03
    86d2:	ac 81       	ldd	r26, Y+4	; 0x04
    86d4:	bd 81       	ldd	r27, Y+5	; 0x05
    86d6:	25 ec       	ldi	r18, 0xC5	; 197
    86d8:	31 e2       	ldi	r19, 0x21	; 33
    86da:	bc 01       	movw	r22, r24
    86dc:	cd 01       	movw	r24, r26
    86de:	a9 01       	movw	r20, r18
    86e0:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    86e4:	8e 81       	ldd	r24, Y+6	; 0x06
    86e6:	9f 81       	ldd	r25, Y+7	; 0x07
    86e8:	8b 53       	subi	r24, 0x3B	; 59
    86ea:	9e 4d       	sbci	r25, 0xDE	; 222
    86ec:	88 87       	std	Y+8, r24	; 0x08
    86ee:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    86f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    86f2:	88 23       	and	r24, r24
    86f4:	49 f4       	brne	.+18     	; 0x8708 <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    86f6:	88 85       	ldd	r24, Y+8	; 0x08
    86f8:	99 85       	ldd	r25, Y+9	; 0x09
    86fa:	fc 01       	movw	r30, r24
    86fc:	80 81       	ld	r24, Z
    86fe:	91 81       	ldd	r25, Z+1	; 0x01
    8700:	a2 81       	ldd	r26, Z+2	; 0x02
    8702:	b3 81       	ldd	r27, Z+3	; 0x03
    8704:	bf 70       	andi	r27, 0x0F	; 15
    8706:	1b c0       	rjmp	.+54     	; 0x873e <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    8708:	28 85       	ldd	r18, Y+8	; 0x08
    870a:	39 85       	ldd	r19, Y+9	; 0x09
    870c:	8f 85       	ldd	r24, Y+15	; 0x0f
    870e:	98 89       	ldd	r25, Y+16	; 0x10
    8710:	a9 89       	ldd	r26, Y+17	; 0x11
    8712:	ba 89       	ldd	r27, Y+18	; 0x12
    8714:	f9 01       	movw	r30, r18
    8716:	80 83       	st	Z, r24
    8718:	91 83       	std	Z+1, r25	; 0x01
    871a:	a2 83       	std	Z+2, r26	; 0x02
    871c:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    871e:	8a 81       	ldd	r24, Y+2	; 0x02
    8720:	9b 81       	ldd	r25, Y+3	; 0x03
    8722:	ac 81       	ldd	r26, Y+4	; 0x04
    8724:	bd 81       	ldd	r27, Y+5	; 0x05
    8726:	25 ec       	ldi	r18, 0xC5	; 197
    8728:	31 e2       	ldi	r19, 0x21	; 33
    872a:	bc 01       	movw	r22, r24
    872c:	cd 01       	movw	r24, r26
    872e:	a9 01       	movw	r20, r18
    8730:	20 e0       	ldi	r18, 0x00	; 0
    8732:	32 e0       	ldi	r19, 0x02	; 2
    8734:	0e 94 2d 50 	call	0xa05a	; 0xa05a <SD_write_block>

return (0);
    8738:	80 e0       	ldi	r24, 0x00	; 0
    873a:	90 e0       	ldi	r25, 0x00	; 0
    873c:	dc 01       	movw	r26, r24
}
    873e:	bc 01       	movw	r22, r24
    8740:	cd 01       	movw	r24, r26
    8742:	62 96       	adiw	r28, 0x12	; 18
    8744:	cd bf       	out	0x3d, r28	; 61
    8746:	de bf       	out	0x3e, r29	; 62
    8748:	df 91       	pop	r29
    874a:	cf 91       	pop	r28
    874c:	1f 91       	pop	r17
    874e:	0f 91       	pop	r16
    8750:	ff 90       	pop	r15
    8752:	ef 90       	pop	r14
    8754:	08 95       	ret

00008756 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    8756:	cf 93       	push	r28
    8758:	df 93       	push	r29
    875a:	cd b7       	in	r28, 0x3d	; 61
    875c:	de b7       	in	r29, 0x3e	; 62
    875e:	28 97       	sbiw	r28, 0x08	; 8
    8760:	cd bf       	out	0x3d, r28	; 61
    8762:	de bf       	out	0x3e, r29	; 62
    8764:	8b 83       	std	Y+3, r24	; 0x03
    8766:	6c 83       	std	Y+4, r22	; 0x04
    8768:	2d 83       	std	Y+5, r18	; 0x05
    876a:	3e 83       	std	Y+6, r19	; 0x06
    876c:	4f 83       	std	Y+7, r20	; 0x07
    876e:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    8770:	85 ec       	ldi	r24, 0xC5	; 197
    8772:	91 e2       	ldi	r25, 0x21	; 33
    8774:	89 83       	std	Y+1, r24	; 0x01
    8776:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    8778:	80 91 68 50 	lds	r24, 0x5068
    877c:	90 91 69 50 	lds	r25, 0x5069
    8780:	a0 91 6a 50 	lds	r26, 0x506A
    8784:	b0 91 6b 50 	lds	r27, 0x506B
    8788:	01 96       	adiw	r24, 0x01	; 1
    878a:	a1 1d       	adc	r26, r1
    878c:	b1 1d       	adc	r27, r1
    878e:	25 ec       	ldi	r18, 0xC5	; 197
    8790:	31 e2       	ldi	r19, 0x21	; 33
    8792:	bc 01       	movw	r22, r24
    8794:	cd 01       	movw	r24, r26
    8796:	a9 01       	movw	r20, r18
    8798:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    879c:	89 81       	ldd	r24, Y+1	; 0x01
    879e:	9a 81       	ldd	r25, Y+2	; 0x02
    87a0:	fc 01       	movw	r30, r24
    87a2:	80 81       	ld	r24, Z
    87a4:	91 81       	ldd	r25, Z+1	; 0x01
    87a6:	a2 81       	ldd	r26, Z+2	; 0x02
    87a8:	b3 81       	ldd	r27, Z+3	; 0x03
    87aa:	82 35       	cpi	r24, 0x52	; 82
    87ac:	f2 e5       	ldi	r31, 0x52	; 82
    87ae:	9f 07       	cpc	r25, r31
    87b0:	f1 e6       	ldi	r31, 0x61	; 97
    87b2:	af 07       	cpc	r26, r31
    87b4:	f1 e4       	ldi	r31, 0x41	; 65
    87b6:	bf 07       	cpc	r27, r31
    87b8:	11 f5       	brne	.+68     	; 0x87fe <getSetFreeCluster+0xa8>
    87ba:	89 81       	ldd	r24, Y+1	; 0x01
    87bc:	9a 81       	ldd	r25, Y+2	; 0x02
    87be:	8c 51       	subi	r24, 0x1C	; 28
    87c0:	9e 4f       	sbci	r25, 0xFE	; 254
    87c2:	fc 01       	movw	r30, r24
    87c4:	80 81       	ld	r24, Z
    87c6:	91 81       	ldd	r25, Z+1	; 0x01
    87c8:	a2 81       	ldd	r26, Z+2	; 0x02
    87ca:	b3 81       	ldd	r27, Z+3	; 0x03
    87cc:	82 37       	cpi	r24, 0x72	; 114
    87ce:	f2 e7       	ldi	r31, 0x72	; 114
    87d0:	9f 07       	cpc	r25, r31
    87d2:	f1 e4       	ldi	r31, 0x41	; 65
    87d4:	af 07       	cpc	r26, r31
    87d6:	f1 e6       	ldi	r31, 0x61	; 97
    87d8:	bf 07       	cpc	r27, r31
    87da:	89 f4       	brne	.+34     	; 0x87fe <getSetFreeCluster+0xa8>
    87dc:	89 81       	ldd	r24, Y+1	; 0x01
    87de:	9a 81       	ldd	r25, Y+2	; 0x02
    87e0:	84 50       	subi	r24, 0x04	; 4
    87e2:	9e 4f       	sbci	r25, 0xFE	; 254
    87e4:	fc 01       	movw	r30, r24
    87e6:	80 81       	ld	r24, Z
    87e8:	91 81       	ldd	r25, Z+1	; 0x01
    87ea:	a2 81       	ldd	r26, Z+2	; 0x02
    87ec:	b3 81       	ldd	r27, Z+3	; 0x03
    87ee:	80 30       	cpi	r24, 0x00	; 0
    87f0:	f0 e0       	ldi	r31, 0x00	; 0
    87f2:	9f 07       	cpc	r25, r31
    87f4:	f5 e5       	ldi	r31, 0x55	; 85
    87f6:	af 07       	cpc	r26, r31
    87f8:	fa ea       	ldi	r31, 0xAA	; 170
    87fa:	bf 07       	cpc	r27, r31
    87fc:	21 f0       	breq	.+8      	; 0x8806 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    87fe:	8f ef       	ldi	r24, 0xFF	; 255
    8800:	9f ef       	ldi	r25, 0xFF	; 255
    8802:	dc 01       	movw	r26, r24
    8804:	51 c0       	rjmp	.+162    	; 0x88a8 <getSetFreeCluster+0x152>

 if(get_set == GET)
    8806:	8c 81       	ldd	r24, Y+4	; 0x04
    8808:	88 23       	and	r24, r24
    880a:	b9 f4       	brne	.+46     	; 0x883a <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    880c:	8b 81       	ldd	r24, Y+3	; 0x03
    880e:	81 30       	cpi	r24, 0x01	; 1
    8810:	51 f4       	brne	.+20     	; 0x8826 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    8812:	89 81       	ldd	r24, Y+1	; 0x01
    8814:	9a 81       	ldd	r25, Y+2	; 0x02
    8816:	88 51       	subi	r24, 0x18	; 24
    8818:	9e 4f       	sbci	r25, 0xFE	; 254
    881a:	fc 01       	movw	r30, r24
    881c:	80 81       	ld	r24, Z
    881e:	91 81       	ldd	r25, Z+1	; 0x01
    8820:	a2 81       	ldd	r26, Z+2	; 0x02
    8822:	b3 81       	ldd	r27, Z+3	; 0x03
    8824:	41 c0       	rjmp	.+130    	; 0x88a8 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    8826:	89 81       	ldd	r24, Y+1	; 0x01
    8828:	9a 81       	ldd	r25, Y+2	; 0x02
    882a:	84 51       	subi	r24, 0x14	; 20
    882c:	9e 4f       	sbci	r25, 0xFE	; 254
    882e:	fc 01       	movw	r30, r24
    8830:	80 81       	ld	r24, Z
    8832:	91 81       	ldd	r25, Z+1	; 0x01
    8834:	a2 81       	ldd	r26, Z+2	; 0x02
    8836:	b3 81       	ldd	r27, Z+3	; 0x03
    8838:	37 c0       	rjmp	.+110    	; 0x88a8 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    883a:	8b 81       	ldd	r24, Y+3	; 0x03
    883c:	81 30       	cpi	r24, 0x01	; 1
    883e:	79 f4       	brne	.+30     	; 0x885e <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    8840:	89 81       	ldd	r24, Y+1	; 0x01
    8842:	9a 81       	ldd	r25, Y+2	; 0x02
    8844:	9c 01       	movw	r18, r24
    8846:	28 51       	subi	r18, 0x18	; 24
    8848:	3e 4f       	sbci	r19, 0xFE	; 254
    884a:	8d 81       	ldd	r24, Y+5	; 0x05
    884c:	9e 81       	ldd	r25, Y+6	; 0x06
    884e:	af 81       	ldd	r26, Y+7	; 0x07
    8850:	b8 85       	ldd	r27, Y+8	; 0x08
    8852:	f9 01       	movw	r30, r18
    8854:	80 83       	st	Z, r24
    8856:	91 83       	std	Z+1, r25	; 0x01
    8858:	a2 83       	std	Z+2, r26	; 0x02
    885a:	b3 83       	std	Z+3, r27	; 0x03
    885c:	0e c0       	rjmp	.+28     	; 0x887a <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    885e:	89 81       	ldd	r24, Y+1	; 0x01
    8860:	9a 81       	ldd	r25, Y+2	; 0x02
    8862:	9c 01       	movw	r18, r24
    8864:	24 51       	subi	r18, 0x14	; 20
    8866:	3e 4f       	sbci	r19, 0xFE	; 254
    8868:	8d 81       	ldd	r24, Y+5	; 0x05
    886a:	9e 81       	ldd	r25, Y+6	; 0x06
    886c:	af 81       	ldd	r26, Y+7	; 0x07
    886e:	b8 85       	ldd	r27, Y+8	; 0x08
    8870:	f9 01       	movw	r30, r18
    8872:	80 83       	st	Z, r24
    8874:	91 83       	std	Z+1, r25	; 0x01
    8876:	a2 83       	std	Z+2, r26	; 0x02
    8878:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    887a:	80 91 68 50 	lds	r24, 0x5068
    887e:	90 91 69 50 	lds	r25, 0x5069
    8882:	a0 91 6a 50 	lds	r26, 0x506A
    8886:	b0 91 6b 50 	lds	r27, 0x506B
    888a:	01 96       	adiw	r24, 0x01	; 1
    888c:	a1 1d       	adc	r26, r1
    888e:	b1 1d       	adc	r27, r1
    8890:	25 ec       	ldi	r18, 0xC5	; 197
    8892:	31 e2       	ldi	r19, 0x21	; 33
    8894:	bc 01       	movw	r22, r24
    8896:	cd 01       	movw	r24, r26
    8898:	a9 01       	movw	r20, r18
    889a:	20 e0       	ldi	r18, 0x00	; 0
    889c:	32 e0       	ldi	r19, 0x02	; 2
    889e:	0e 94 2d 50 	call	0xa05a	; 0xa05a <SD_write_block>
 }
 return 0xffffffff;
    88a2:	8f ef       	ldi	r24, 0xFF	; 255
    88a4:	9f ef       	ldi	r25, 0xFF	; 255
    88a6:	dc 01       	movw	r26, r24
}
    88a8:	bc 01       	movw	r22, r24
    88aa:	cd 01       	movw	r24, r26
    88ac:	28 96       	adiw	r28, 0x08	; 8
    88ae:	cd bf       	out	0x3d, r28	; 61
    88b0:	de bf       	out	0x3e, r29	; 62
    88b2:	df 91       	pop	r29
    88b4:	cf 91       	pop	r28
    88b6:	08 95       	ret

000088b8 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    88b8:	0f 93       	push	r16
    88ba:	1f 93       	push	r17
    88bc:	cf 93       	push	r28
    88be:	df 93       	push	r29
    88c0:	cd b7       	in	r28, 0x3d	; 61
    88c2:	de b7       	in	r29, 0x3e	; 62
    88c4:	6c 97       	sbiw	r28, 0x1c	; 28
    88c6:	cd bf       	out	0x3d, r28	; 61
    88c8:	de bf       	out	0x3e, r29	; 62
    88ca:	8a 8f       	std	Y+26, r24	; 0x1a
    88cc:	6b 8f       	std	Y+27, r22	; 0x1b
    88ce:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    88d0:	80 91 4e 40 	lds	r24, 0x404E
    88d4:	90 91 4f 40 	lds	r25, 0x404F
    88d8:	a0 91 50 40 	lds	r26, 0x4050
    88dc:	b0 91 51 40 	lds	r27, 0x4051
    88e0:	89 83       	std	Y+1, r24	; 0x01
    88e2:	9a 83       	std	Y+2, r25	; 0x02
    88e4:	ab 83       	std	Y+3, r26	; 0x03
    88e6:	bc 83       	std	Y+4, r27	; 0x04
    88e8:	01 c0       	rjmp	.+2      	; 0x88ec <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    88ea:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    88ec:	89 81       	ldd	r24, Y+1	; 0x01
    88ee:	9a 81       	ldd	r25, Y+2	; 0x02
    88f0:	ab 81       	ldd	r26, Y+3	; 0x03
    88f2:	bc 81       	ldd	r27, Y+4	; 0x04
    88f4:	bc 01       	movw	r22, r24
    88f6:	cd 01       	movw	r24, r26
    88f8:	0e 94 cf 42 	call	0x859e	; 0x859e <getFirstSector>
    88fc:	dc 01       	movw	r26, r24
    88fe:	cb 01       	movw	r24, r22
    8900:	88 8b       	std	Y+16, r24	; 0x10
    8902:	99 8b       	std	Y+17, r25	; 0x11
    8904:	aa 8b       	std	Y+18, r26	; 0x12
    8906:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    8908:	1d 82       	std	Y+5, r1	; 0x05
    890a:	1e 82       	std	Y+6, r1	; 0x06
    890c:	1f 82       	std	Y+7, r1	; 0x07
    890e:	18 86       	std	Y+8, r1	; 0x08
    8910:	68 c1       	rjmp	.+720    	; 0x8be2 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    8912:	28 89       	ldd	r18, Y+16	; 0x10
    8914:	39 89       	ldd	r19, Y+17	; 0x11
    8916:	4a 89       	ldd	r20, Y+18	; 0x12
    8918:	5b 89       	ldd	r21, Y+19	; 0x13
    891a:	8d 81       	ldd	r24, Y+5	; 0x05
    891c:	9e 81       	ldd	r25, Y+6	; 0x06
    891e:	af 81       	ldd	r26, Y+7	; 0x07
    8920:	b8 85       	ldd	r27, Y+8	; 0x08
    8922:	82 0f       	add	r24, r18
    8924:	93 1f       	adc	r25, r19
    8926:	a4 1f       	adc	r26, r20
    8928:	b5 1f       	adc	r27, r21
    892a:	25 ec       	ldi	r18, 0xC5	; 197
    892c:	31 e2       	ldi	r19, 0x21	; 33
    892e:	bc 01       	movw	r22, r24
    8930:	cd 01       	movw	r24, r26
    8932:	a9 01       	movw	r20, r18
    8934:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    8938:	1d 86       	std	Y+13, r1	; 0x0d
    893a:	1e 86       	std	Y+14, r1	; 0x0e
    893c:	3d c1       	rjmp	.+634    	; 0x8bb8 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    893e:	8d 85       	ldd	r24, Y+13	; 0x0d
    8940:	9e 85       	ldd	r25, Y+14	; 0x0e
    8942:	8b 53       	subi	r24, 0x3B	; 59
    8944:	9e 4d       	sbci	r25, 0xDE	; 222
    8946:	8c 8b       	std	Y+20, r24	; 0x14
    8948:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    894a:	8c 89       	ldd	r24, Y+20	; 0x14
    894c:	9d 89       	ldd	r25, Y+21	; 0x15
    894e:	fc 01       	movw	r30, r24
    8950:	80 81       	ld	r24, Z
    8952:	88 23       	and	r24, r24
    8954:	19 f4       	brne	.+6      	; 0x895c <findFiles+0xa4>
		{
		  return 0;   
    8956:	80 e0       	ldi	r24, 0x00	; 0
    8958:	90 e0       	ldi	r25, 0x00	; 0
    895a:	80 c1       	rjmp	.+768    	; 0x8c5c <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    895c:	8c 89       	ldd	r24, Y+20	; 0x14
    895e:	9d 89       	ldd	r25, Y+21	; 0x15
    8960:	fc 01       	movw	r30, r24
    8962:	80 81       	ld	r24, Z
    8964:	85 3e       	cpi	r24, 0xE5	; 229
    8966:	09 f4       	brne	.+2      	; 0x896a <findFiles+0xb2>
    8968:	22 c1       	rjmp	.+580    	; 0x8bae <findFiles+0x2f6>
    896a:	8c 89       	ldd	r24, Y+20	; 0x14
    896c:	9d 89       	ldd	r25, Y+21	; 0x15
    896e:	fc 01       	movw	r30, r24
    8970:	83 85       	ldd	r24, Z+11	; 0x0b
    8972:	8f 30       	cpi	r24, 0x0F	; 15
    8974:	09 f4       	brne	.+2      	; 0x8978 <findFiles+0xc0>
    8976:	1b c1       	rjmp	.+566    	; 0x8bae <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    8978:	8a 8d       	ldd	r24, Y+26	; 0x1a
    897a:	81 30       	cpi	r24, 0x01	; 1
    897c:	21 f0       	breq	.+8      	; 0x8986 <findFiles+0xce>
    897e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8980:	82 30       	cpi	r24, 0x02	; 2
    8982:	09 f0       	breq	.+2      	; 0x8986 <findFiles+0xce>
    8984:	11 c1       	rjmp	.+546    	; 0x8ba8 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8986:	1f 86       	std	Y+15, r1	; 0x0f
    8988:	17 c0       	rjmp	.+46     	; 0x89b8 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    898a:	8f 85       	ldd	r24, Y+15	; 0x0f
    898c:	88 2f       	mov	r24, r24
    898e:	90 e0       	ldi	r25, 0x00	; 0
    8990:	2c 89       	ldd	r18, Y+20	; 0x14
    8992:	3d 89       	ldd	r19, Y+21	; 0x15
    8994:	82 0f       	add	r24, r18
    8996:	93 1f       	adc	r25, r19
    8998:	fc 01       	movw	r30, r24
    899a:	40 81       	ld	r20, Z
    899c:	8f 85       	ldd	r24, Y+15	; 0x0f
    899e:	88 2f       	mov	r24, r24
    89a0:	90 e0       	ldi	r25, 0x00	; 0
    89a2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    89a4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    89a6:	82 0f       	add	r24, r18
    89a8:	93 1f       	adc	r25, r19
    89aa:	fc 01       	movw	r30, r24
    89ac:	80 81       	ld	r24, Z
    89ae:	48 17       	cp	r20, r24
    89b0:	39 f4       	brne	.+14     	; 0x89c0 <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    89b2:	8f 85       	ldd	r24, Y+15	; 0x0f
    89b4:	8f 5f       	subi	r24, 0xFF	; 255
    89b6:	8f 87       	std	Y+15, r24	; 0x0f
    89b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    89ba:	8b 30       	cpi	r24, 0x0B	; 11
    89bc:	30 f3       	brcs	.-52     	; 0x898a <findFiles+0xd2>
    89be:	01 c0       	rjmp	.+2      	; 0x89c2 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    89c0:	00 00       	nop
            if(j == 11)
    89c2:	8f 85       	ldd	r24, Y+15	; 0x0f
    89c4:	8b 30       	cpi	r24, 0x0B	; 11
    89c6:	09 f0       	breq	.+2      	; 0x89ca <findFiles+0x112>
    89c8:	f2 c0       	rjmp	.+484    	; 0x8bae <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    89ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    89cc:	81 30       	cpi	r24, 0x01	; 1
    89ce:	09 f0       	breq	.+2      	; 0x89d2 <findFiles+0x11a>
    89d0:	52 c0       	rjmp	.+164    	; 0x8a76 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    89d2:	28 89       	ldd	r18, Y+16	; 0x10
    89d4:	39 89       	ldd	r19, Y+17	; 0x11
    89d6:	4a 89       	ldd	r20, Y+18	; 0x12
    89d8:	5b 89       	ldd	r21, Y+19	; 0x13
    89da:	8d 81       	ldd	r24, Y+5	; 0x05
    89dc:	9e 81       	ldd	r25, Y+6	; 0x06
    89de:	af 81       	ldd	r26, Y+7	; 0x07
    89e0:	b8 85       	ldd	r27, Y+8	; 0x08
    89e2:	82 0f       	add	r24, r18
    89e4:	93 1f       	adc	r25, r19
    89e6:	a4 1f       	adc	r26, r20
    89e8:	b5 1f       	adc	r27, r21
    89ea:	80 93 d1 50 	sts	0x50D1, r24
    89ee:	90 93 d2 50 	sts	0x50D2, r25
    89f2:	a0 93 d3 50 	sts	0x50D3, r26
    89f6:	b0 93 d4 50 	sts	0x50D4, r27
				appendFileLocation = i;
    89fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    89fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    89fe:	cc 01       	movw	r24, r24
    8a00:	a0 e0       	ldi	r26, 0x00	; 0
    8a02:	b0 e0       	ldi	r27, 0x00	; 0
    8a04:	80 93 c6 23 	sts	0x23C6, r24
    8a08:	90 93 c7 23 	sts	0x23C7, r25
    8a0c:	a0 93 c8 23 	sts	0x23C8, r26
    8a10:	b0 93 c9 23 	sts	0x23C9, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a14:	8c 89       	ldd	r24, Y+20	; 0x14
    8a16:	9d 89       	ldd	r25, Y+21	; 0x15
    8a18:	fc 01       	movw	r30, r24
    8a1a:	84 89       	ldd	r24, Z+20	; 0x14
    8a1c:	95 89       	ldd	r25, Z+21	; 0x15
    8a1e:	cc 01       	movw	r24, r24
    8a20:	a0 e0       	ldi	r26, 0x00	; 0
    8a22:	b0 e0       	ldi	r27, 0x00	; 0
    8a24:	ac 01       	movw	r20, r24
    8a26:	33 27       	eor	r19, r19
    8a28:	22 27       	eor	r18, r18
    8a2a:	8c 89       	ldd	r24, Y+20	; 0x14
    8a2c:	9d 89       	ldd	r25, Y+21	; 0x15
    8a2e:	fc 01       	movw	r30, r24
    8a30:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a32:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a34:	cc 01       	movw	r24, r24
    8a36:	a0 e0       	ldi	r26, 0x00	; 0
    8a38:	b0 e0       	ldi	r27, 0x00	; 0
    8a3a:	82 2b       	or	r24, r18
    8a3c:	93 2b       	or	r25, r19
    8a3e:	a4 2b       	or	r26, r20
    8a40:	b5 2b       	or	r27, r21
    8a42:	80 93 72 50 	sts	0x5072, r24
    8a46:	90 93 73 50 	sts	0x5073, r25
    8a4a:	a0 93 74 50 	sts	0x5074, r26
    8a4e:	b0 93 75 50 	sts	0x5075, r27
				fileSize = dir->fileSize;
    8a52:	8c 89       	ldd	r24, Y+20	; 0x14
    8a54:	9d 89       	ldd	r25, Y+21	; 0x15
    8a56:	fc 01       	movw	r30, r24
    8a58:	84 8d       	ldd	r24, Z+28	; 0x1c
    8a5a:	95 8d       	ldd	r25, Z+29	; 0x1d
    8a5c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8a5e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8a60:	80 93 3f 40 	sts	0x403F, r24
    8a64:	90 93 40 40 	sts	0x4040, r25
    8a68:	a0 93 41 40 	sts	0x4041, r26
    8a6c:	b0 93 42 40 	sts	0x4042, r27
			    return (dir);
    8a70:	8c 89       	ldd	r24, Y+20	; 0x14
    8a72:	9d 89       	ldd	r25, Y+21	; 0x15
    8a74:	f3 c0       	rjmp	.+486    	; 0x8c5c <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a76:	8c 89       	ldd	r24, Y+20	; 0x14
    8a78:	9d 89       	ldd	r25, Y+21	; 0x15
    8a7a:	fc 01       	movw	r30, r24
    8a7c:	84 89       	ldd	r24, Z+20	; 0x14
    8a7e:	95 89       	ldd	r25, Z+21	; 0x15
    8a80:	cc 01       	movw	r24, r24
    8a82:	a0 e0       	ldi	r26, 0x00	; 0
    8a84:	b0 e0       	ldi	r27, 0x00	; 0
    8a86:	ac 01       	movw	r20, r24
    8a88:	33 27       	eor	r19, r19
    8a8a:	22 27       	eor	r18, r18
    8a8c:	8c 89       	ldd	r24, Y+20	; 0x14
    8a8e:	9d 89       	ldd	r25, Y+21	; 0x15
    8a90:	fc 01       	movw	r30, r24
    8a92:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a94:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a96:	cc 01       	movw	r24, r24
    8a98:	a0 e0       	ldi	r26, 0x00	; 0
    8a9a:	b0 e0       	ldi	r27, 0x00	; 0
    8a9c:	82 2b       	or	r24, r18
    8a9e:	93 2b       	or	r25, r19
    8aa0:	a4 2b       	or	r26, r20
    8aa2:	b5 2b       	or	r27, r21
    8aa4:	89 87       	std	Y+9, r24	; 0x09
    8aa6:	9a 87       	std	Y+10, r25	; 0x0a
    8aa8:	ab 87       	std	Y+11, r26	; 0x0b
    8aaa:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8aac:	8c 89       	ldd	r24, Y+20	; 0x14
    8aae:	9d 89       	ldd	r25, Y+21	; 0x15
    8ab0:	25 ee       	ldi	r18, 0xE5	; 229
    8ab2:	fc 01       	movw	r30, r24
    8ab4:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8ab6:	28 89       	ldd	r18, Y+16	; 0x10
    8ab8:	39 89       	ldd	r19, Y+17	; 0x11
    8aba:	4a 89       	ldd	r20, Y+18	; 0x12
    8abc:	5b 89       	ldd	r21, Y+19	; 0x13
    8abe:	8d 81       	ldd	r24, Y+5	; 0x05
    8ac0:	9e 81       	ldd	r25, Y+6	; 0x06
    8ac2:	af 81       	ldd	r26, Y+7	; 0x07
    8ac4:	b8 85       	ldd	r27, Y+8	; 0x08
    8ac6:	82 0f       	add	r24, r18
    8ac8:	93 1f       	adc	r25, r19
    8aca:	a4 1f       	adc	r26, r20
    8acc:	b5 1f       	adc	r27, r21
    8ace:	25 ec       	ldi	r18, 0xC5	; 197
    8ad0:	31 e2       	ldi	r19, 0x21	; 33
    8ad2:	bc 01       	movw	r22, r24
    8ad4:	cd 01       	movw	r24, r26
    8ad6:	a9 01       	movw	r20, r18
    8ad8:	20 e0       	ldi	r18, 0x00	; 0
    8ada:	32 e0       	ldi	r19, 0x02	; 2
    8adc:	0e 94 2d 50 	call	0xa05a	; 0xa05a <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8ae0:	8c 89       	ldd	r24, Y+20	; 0x14
    8ae2:	9d 89       	ldd	r25, Y+21	; 0x15
    8ae4:	fc 01       	movw	r30, r24
    8ae6:	24 8d       	ldd	r18, Z+28	; 0x1c
    8ae8:	35 8d       	ldd	r19, Z+29	; 0x1d
    8aea:	46 8d       	ldd	r20, Z+30	; 0x1e
    8aec:	57 8d       	ldd	r21, Z+31	; 0x1f
    8aee:	80 e0       	ldi	r24, 0x00	; 0
    8af0:	ba 01       	movw	r22, r20
    8af2:	a9 01       	movw	r20, r18
    8af4:	0e 94 ca 4c 	call	0x9994	; 0x9994 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8af8:	82 e0       	ldi	r24, 0x02	; 2
    8afa:	60 e0       	ldi	r22, 0x00	; 0
    8afc:	20 e0       	ldi	r18, 0x00	; 0
    8afe:	30 e0       	ldi	r19, 0x00	; 0
    8b00:	a9 01       	movw	r20, r18
    8b02:	0e 94 ab 43 	call	0x8756	; 0x8756 <getSetFreeCluster>
    8b06:	dc 01       	movw	r26, r24
    8b08:	cb 01       	movw	r24, r22
    8b0a:	89 83       	std	Y+1, r24	; 0x01
    8b0c:	9a 83       	std	Y+2, r25	; 0x02
    8b0e:	ab 83       	std	Y+3, r26	; 0x03
    8b10:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8b12:	29 85       	ldd	r18, Y+9	; 0x09
    8b14:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b16:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b18:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b1a:	89 81       	ldd	r24, Y+1	; 0x01
    8b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    8b1e:	ab 81       	ldd	r26, Y+3	; 0x03
    8b20:	bc 81       	ldd	r27, Y+4	; 0x04
    8b22:	28 17       	cp	r18, r24
    8b24:	39 07       	cpc	r19, r25
    8b26:	4a 07       	cpc	r20, r26
    8b28:	5b 07       	cpc	r21, r27
    8b2a:	40 f4       	brcc	.+16     	; 0x8b3c <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    8b2c:	29 85       	ldd	r18, Y+9	; 0x09
    8b2e:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b30:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b32:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b34:	82 e0       	ldi	r24, 0x02	; 2
    8b36:	61 e0       	ldi	r22, 0x01	; 1
    8b38:	0e 94 ab 43 	call	0x8756	; 0x8756 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    8b3c:	89 85       	ldd	r24, Y+9	; 0x09
    8b3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b40:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b42:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b44:	bc 01       	movw	r22, r24
    8b46:	cd 01       	movw	r24, r26
    8b48:	40 e0       	ldi	r20, 0x00	; 0
    8b4a:	00 e0       	ldi	r16, 0x00	; 0
    8b4c:	10 e0       	ldi	r17, 0x00	; 0
    8b4e:	98 01       	movw	r18, r16
    8b50:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
    8b54:	dc 01       	movw	r26, r24
    8b56:	cb 01       	movw	r24, r22
    8b58:	8e 8b       	std	Y+22, r24	; 0x16
    8b5a:	9f 8b       	std	Y+23, r25	; 0x17
    8b5c:	a8 8f       	std	Y+24, r26	; 0x18
    8b5e:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8b60:	89 85       	ldd	r24, Y+9	; 0x09
    8b62:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b64:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b66:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b68:	bc 01       	movw	r22, r24
    8b6a:	cd 01       	movw	r24, r26
    8b6c:	41 e0       	ldi	r20, 0x01	; 1
    8b6e:	00 e0       	ldi	r16, 0x00	; 0
    8b70:	10 e0       	ldi	r17, 0x00	; 0
    8b72:	98 01       	movw	r18, r16
    8b74:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8b78:	8e 89       	ldd	r24, Y+22	; 0x16
    8b7a:	9f 89       	ldd	r25, Y+23	; 0x17
    8b7c:	a8 8d       	ldd	r26, Y+24	; 0x18
    8b7e:	b9 8d       	ldd	r27, Y+25	; 0x19
    8b80:	87 3f       	cpi	r24, 0xF7	; 247
    8b82:	ff ef       	ldi	r31, 0xFF	; 255
    8b84:	9f 07       	cpc	r25, r31
    8b86:	ff ef       	ldi	r31, 0xFF	; 255
    8b88:	af 07       	cpc	r26, r31
    8b8a:	ff e0       	ldi	r31, 0x0F	; 15
    8b8c:	bf 07       	cpc	r27, r31
    8b8e:	18 f0       	brcs	.+6      	; 0x8b96 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    8b90:	80 e0       	ldi	r24, 0x00	; 0
    8b92:	90 e0       	ldi	r25, 0x00	; 0
    8b94:	63 c0       	rjmp	.+198    	; 0x8c5c <findFiles+0x3a4>
					firstCluster = nextCluster;
    8b96:	8e 89       	ldd	r24, Y+22	; 0x16
    8b98:	9f 89       	ldd	r25, Y+23	; 0x17
    8b9a:	a8 8d       	ldd	r26, Y+24	; 0x18
    8b9c:	b9 8d       	ldd	r27, Y+25	; 0x19
    8b9e:	89 87       	std	Y+9, r24	; 0x09
    8ba0:	9a 87       	std	Y+10, r25	; 0x0a
    8ba2:	ab 87       	std	Y+11, r26	; 0x0b
    8ba4:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8ba6:	ca cf       	rjmp	.-108    	; 0x8b3c <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8ba8:	80 e0       	ldi	r24, 0x00	; 0
    8baa:	90 e0       	ldi	r25, 0x00	; 0
    8bac:	57 c0       	rjmp	.+174    	; 0x8c5c <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8bae:	8d 85       	ldd	r24, Y+13	; 0x0d
    8bb0:	9e 85       	ldd	r25, Y+14	; 0x0e
    8bb2:	80 96       	adiw	r24, 0x20	; 32
    8bb4:	8d 87       	std	Y+13, r24	; 0x0d
    8bb6:	9e 87       	std	Y+14, r25	; 0x0e
    8bb8:	80 91 43 40 	lds	r24, 0x4043
    8bbc:	90 91 44 40 	lds	r25, 0x4044
    8bc0:	2d 85       	ldd	r18, Y+13	; 0x0d
    8bc2:	3e 85       	ldd	r19, Y+14	; 0x0e
    8bc4:	28 17       	cp	r18, r24
    8bc6:	39 07       	cpc	r19, r25
    8bc8:	08 f4       	brcc	.+2      	; 0x8bcc <findFiles+0x314>
    8bca:	b9 ce       	rjmp	.-654    	; 0x893e <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    8bce:	9e 81       	ldd	r25, Y+6	; 0x06
    8bd0:	af 81       	ldd	r26, Y+7	; 0x07
    8bd2:	b8 85       	ldd	r27, Y+8	; 0x08
    8bd4:	01 96       	adiw	r24, 0x01	; 1
    8bd6:	a1 1d       	adc	r26, r1
    8bd8:	b1 1d       	adc	r27, r1
    8bda:	8d 83       	std	Y+5, r24	; 0x05
    8bdc:	9e 83       	std	Y+6, r25	; 0x06
    8bde:	af 83       	std	Y+7, r26	; 0x07
    8be0:	b8 87       	std	Y+8, r27	; 0x08
    8be2:	80 91 66 50 	lds	r24, 0x5066
    8be6:	90 91 67 50 	lds	r25, 0x5067
    8bea:	9c 01       	movw	r18, r24
    8bec:	40 e0       	ldi	r20, 0x00	; 0
    8bee:	50 e0       	ldi	r21, 0x00	; 0
    8bf0:	8d 81       	ldd	r24, Y+5	; 0x05
    8bf2:	9e 81       	ldd	r25, Y+6	; 0x06
    8bf4:	af 81       	ldd	r26, Y+7	; 0x07
    8bf6:	b8 85       	ldd	r27, Y+8	; 0x08
    8bf8:	82 17       	cp	r24, r18
    8bfa:	93 07       	cpc	r25, r19
    8bfc:	a4 07       	cpc	r26, r20
    8bfe:	b5 07       	cpc	r27, r21
    8c00:	08 f4       	brcc	.+2      	; 0x8c04 <findFiles+0x34c>
    8c02:	87 ce       	rjmp	.-754    	; 0x8912 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8c04:	89 81       	ldd	r24, Y+1	; 0x01
    8c06:	9a 81       	ldd	r25, Y+2	; 0x02
    8c08:	ab 81       	ldd	r26, Y+3	; 0x03
    8c0a:	bc 81       	ldd	r27, Y+4	; 0x04
    8c0c:	bc 01       	movw	r22, r24
    8c0e:	cd 01       	movw	r24, r26
    8c10:	40 e0       	ldi	r20, 0x00	; 0
    8c12:	00 e0       	ldi	r16, 0x00	; 0
    8c14:	10 e0       	ldi	r17, 0x00	; 0
    8c16:	98 01       	movw	r18, r16
    8c18:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
    8c1c:	dc 01       	movw	r26, r24
    8c1e:	cb 01       	movw	r24, r22
    8c20:	89 83       	std	Y+1, r24	; 0x01
    8c22:	9a 83       	std	Y+2, r25	; 0x02
    8c24:	ab 83       	std	Y+3, r26	; 0x03
    8c26:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8c28:	89 81       	ldd	r24, Y+1	; 0x01
    8c2a:	9a 81       	ldd	r25, Y+2	; 0x02
    8c2c:	ab 81       	ldd	r26, Y+3	; 0x03
    8c2e:	bc 81       	ldd	r27, Y+4	; 0x04
    8c30:	87 3f       	cpi	r24, 0xF7	; 247
    8c32:	2f ef       	ldi	r18, 0xFF	; 255
    8c34:	92 07       	cpc	r25, r18
    8c36:	2f ef       	ldi	r18, 0xFF	; 255
    8c38:	a2 07       	cpc	r26, r18
    8c3a:	2f e0       	ldi	r18, 0x0F	; 15
    8c3c:	b2 07       	cpc	r27, r18
    8c3e:	18 f0       	brcs	.+6      	; 0x8c46 <findFiles+0x38e>
   	 return 0;
    8c40:	80 e0       	ldi	r24, 0x00	; 0
    8c42:	90 e0       	ldi	r25, 0x00	; 0
    8c44:	0b c0       	rjmp	.+22     	; 0x8c5c <findFiles+0x3a4>
   if(cluster == 0) 
    8c46:	89 81       	ldd	r24, Y+1	; 0x01
    8c48:	9a 81       	ldd	r25, Y+2	; 0x02
    8c4a:	ab 81       	ldd	r26, Y+3	; 0x03
    8c4c:	bc 81       	ldd	r27, Y+4	; 0x04
    8c4e:	00 97       	sbiw	r24, 0x00	; 0
    8c50:	a1 05       	cpc	r26, r1
    8c52:	b1 05       	cpc	r27, r1
    8c54:	09 f0       	breq	.+2      	; 0x8c58 <findFiles+0x3a0>
    8c56:	49 ce       	rjmp	.-878    	; 0x88ea <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8c58:	80 e0       	ldi	r24, 0x00	; 0
    8c5a:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    8c5c:	6c 96       	adiw	r28, 0x1c	; 28
    8c5e:	cd bf       	out	0x3d, r28	; 61
    8c60:	de bf       	out	0x3e, r29	; 62
    8c62:	df 91       	pop	r29
    8c64:	cf 91       	pop	r28
    8c66:	1f 91       	pop	r17
    8c68:	0f 91       	pop	r16
    8c6a:	08 95       	ret

00008c6c <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    8c6c:	0f 93       	push	r16
    8c6e:	1f 93       	push	r17
    8c70:	cf 93       	push	r28
    8c72:	df 93       	push	r29
    8c74:	cd b7       	in	r28, 0x3d	; 61
    8c76:	de b7       	in	r29, 0x3e	; 62
    8c78:	67 97       	sbiw	r28, 0x17	; 23
    8c7a:	cd bf       	out	0x3d, r28	; 61
    8c7c:	de bf       	out	0x3e, r29	; 62
    8c7e:	8d 8b       	std	Y+21, r24	; 0x15
    8c80:	6e 8b       	std	Y+22, r22	; 0x16
    8c82:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8c84:	1e 82       	std	Y+6, r1	; 0x06
    8c86:	1f 82       	std	Y+7, r1	; 0x07
    8c88:	18 86       	std	Y+8, r1	; 0x08
    8c8a:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8c8c:	8e 89       	ldd	r24, Y+22	; 0x16
    8c8e:	9f 89       	ldd	r25, Y+23	; 0x17
    8c90:	0e 94 e5 46 	call	0x8dca	; 0x8dca <convertFileName>
    8c94:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8c96:	8a 85       	ldd	r24, Y+10	; 0x0a
    8c98:	88 23       	and	r24, r24
    8c9a:	11 f0       	breq	.+4      	; 0x8ca0 <readFile+0x34>
    8c9c:	82 e0       	ldi	r24, 0x02	; 2
    8c9e:	8d c0       	rjmp	.+282    	; 0x8dba <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    8ca0:	2c ea       	ldi	r18, 0xAC	; 172
    8ca2:	30 e5       	ldi	r19, 0x50	; 80
    8ca4:	81 e0       	ldi	r24, 0x01	; 1
    8ca6:	b9 01       	movw	r22, r18
    8ca8:	0e 94 5c 44 	call	0x88b8	; 0x88b8 <findFiles>
    8cac:	8b 87       	std	Y+11, r24	; 0x0b
    8cae:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    8cb0:	8b 85       	ldd	r24, Y+11	; 0x0b
    8cb2:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cb4:	00 97       	sbiw	r24, 0x00	; 0
    8cb6:	39 f4       	brne	.+14     	; 0x8cc6 <readFile+0x5a>
{
  if(flag == READ) return (1);
    8cb8:	8d 89       	ldd	r24, Y+21	; 0x15
    8cba:	88 23       	and	r24, r24
    8cbc:	11 f4       	brne	.+4      	; 0x8cc2 <readFile+0x56>
    8cbe:	81 e0       	ldi	r24, 0x01	; 1
    8cc0:	7c c0       	rjmp	.+248    	; 0x8dba <readFile+0x14e>
  else return (0);
    8cc2:	80 e0       	ldi	r24, 0x00	; 0
    8cc4:	7a c0       	rjmp	.+244    	; 0x8dba <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8cc6:	8d 89       	ldd	r24, Y+21	; 0x15
    8cc8:	81 30       	cpi	r24, 0x01	; 1
    8cca:	11 f4       	brne	.+4      	; 0x8cd0 <readFile+0x64>
    8ccc:	81 e0       	ldi	r24, 0x01	; 1
    8cce:	75 c0       	rjmp	.+234    	; 0x8dba <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8cd0:	8b 85       	ldd	r24, Y+11	; 0x0b
    8cd2:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cd4:	fc 01       	movw	r30, r24
    8cd6:	84 89       	ldd	r24, Z+20	; 0x14
    8cd8:	95 89       	ldd	r25, Z+21	; 0x15
    8cda:	cc 01       	movw	r24, r24
    8cdc:	a0 e0       	ldi	r26, 0x00	; 0
    8cde:	b0 e0       	ldi	r27, 0x00	; 0
    8ce0:	ac 01       	movw	r20, r24
    8ce2:	33 27       	eor	r19, r19
    8ce4:	22 27       	eor	r18, r18
    8ce6:	8b 85       	ldd	r24, Y+11	; 0x0b
    8ce8:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cea:	fc 01       	movw	r30, r24
    8cec:	82 8d       	ldd	r24, Z+26	; 0x1a
    8cee:	93 8d       	ldd	r25, Z+27	; 0x1b
    8cf0:	cc 01       	movw	r24, r24
    8cf2:	a0 e0       	ldi	r26, 0x00	; 0
    8cf4:	b0 e0       	ldi	r27, 0x00	; 0
    8cf6:	82 2b       	or	r24, r18
    8cf8:	93 2b       	or	r25, r19
    8cfa:	a4 2b       	or	r26, r20
    8cfc:	b5 2b       	or	r27, r21
    8cfe:	89 83       	std	Y+1, r24	; 0x01
    8d00:	9a 83       	std	Y+2, r25	; 0x02
    8d02:	ab 83       	std	Y+3, r26	; 0x03
    8d04:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    8d06:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d08:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d0a:	fc 01       	movw	r30, r24
    8d0c:	84 8d       	ldd	r24, Z+28	; 0x1c
    8d0e:	95 8d       	ldd	r25, Z+29	; 0x1d
    8d10:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8d12:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8d14:	8d 87       	std	Y+13, r24	; 0x0d
    8d16:	9e 87       	std	Y+14, r25	; 0x0e
    8d18:	af 87       	std	Y+15, r26	; 0x0f
    8d1a:	b8 8b       	std	Y+16, r27	; 0x10
    8d1c:	01 c0       	rjmp	.+2      	; 0x8d20 <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8d1e:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8d20:	89 81       	ldd	r24, Y+1	; 0x01
    8d22:	9a 81       	ldd	r25, Y+2	; 0x02
    8d24:	ab 81       	ldd	r26, Y+3	; 0x03
    8d26:	bc 81       	ldd	r27, Y+4	; 0x04
    8d28:	bc 01       	movw	r22, r24
    8d2a:	cd 01       	movw	r24, r26
    8d2c:	0e 94 cf 42 	call	0x859e	; 0x859e <getFirstSector>
    8d30:	dc 01       	movw	r26, r24
    8d32:	cb 01       	movw	r24, r22
    8d34:	89 8b       	std	Y+17, r24	; 0x11
    8d36:	9a 8b       	std	Y+18, r25	; 0x12
    8d38:	ab 8b       	std	Y+19, r26	; 0x13
    8d3a:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    8d3c:	1d 82       	std	Y+5, r1	; 0x05
    8d3e:	17 c0       	rjmp	.+46     	; 0x8d6e <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8d40:	8d 81       	ldd	r24, Y+5	; 0x05
    8d42:	28 2f       	mov	r18, r24
    8d44:	30 e0       	ldi	r19, 0x00	; 0
    8d46:	40 e0       	ldi	r20, 0x00	; 0
    8d48:	50 e0       	ldi	r21, 0x00	; 0
    8d4a:	89 89       	ldd	r24, Y+17	; 0x11
    8d4c:	9a 89       	ldd	r25, Y+18	; 0x12
    8d4e:	ab 89       	ldd	r26, Y+19	; 0x13
    8d50:	bc 89       	ldd	r27, Y+20	; 0x14
    8d52:	82 0f       	add	r24, r18
    8d54:	93 1f       	adc	r25, r19
    8d56:	a4 1f       	adc	r26, r20
    8d58:	b5 1f       	adc	r27, r21
    8d5a:	2e ec       	ldi	r18, 0xCE	; 206
    8d5c:	33 e2       	ldi	r19, 0x23	; 35
    8d5e:	bc 01       	movw	r22, r24
    8d60:	cd 01       	movw	r24, r26
    8d62:	a9 01       	movw	r20, r18
    8d64:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8d68:	8d 81       	ldd	r24, Y+5	; 0x05
    8d6a:	8f 5f       	subi	r24, 0xFF	; 255
    8d6c:	8d 83       	std	Y+5, r24	; 0x05
    8d6e:	8d 81       	ldd	r24, Y+5	; 0x05
    8d70:	28 2f       	mov	r18, r24
    8d72:	30 e0       	ldi	r19, 0x00	; 0
    8d74:	80 91 66 50 	lds	r24, 0x5066
    8d78:	90 91 67 50 	lds	r25, 0x5067
    8d7c:	28 17       	cp	r18, r24
    8d7e:	39 07       	cpc	r19, r25
    8d80:	f8 f2       	brcs	.-66     	; 0x8d40 <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8d82:	89 81       	ldd	r24, Y+1	; 0x01
    8d84:	9a 81       	ldd	r25, Y+2	; 0x02
    8d86:	ab 81       	ldd	r26, Y+3	; 0x03
    8d88:	bc 81       	ldd	r27, Y+4	; 0x04
    8d8a:	bc 01       	movw	r22, r24
    8d8c:	cd 01       	movw	r24, r26
    8d8e:	40 e0       	ldi	r20, 0x00	; 0
    8d90:	00 e0       	ldi	r16, 0x00	; 0
    8d92:	10 e0       	ldi	r17, 0x00	; 0
    8d94:	98 01       	movw	r18, r16
    8d96:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
    8d9a:	dc 01       	movw	r26, r24
    8d9c:	cb 01       	movw	r24, r22
    8d9e:	89 83       	std	Y+1, r24	; 0x01
    8da0:	9a 83       	std	Y+2, r25	; 0x02
    8da2:	ab 83       	std	Y+3, r26	; 0x03
    8da4:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8da6:	89 81       	ldd	r24, Y+1	; 0x01
    8da8:	9a 81       	ldd	r25, Y+2	; 0x02
    8daa:	ab 81       	ldd	r26, Y+3	; 0x03
    8dac:	bc 81       	ldd	r27, Y+4	; 0x04
    8dae:	00 97       	sbiw	r24, 0x00	; 0
    8db0:	a1 05       	cpc	r26, r1
    8db2:	b1 05       	cpc	r27, r1
    8db4:	09 f0       	breq	.+2      	; 0x8db8 <readFile+0x14c>
    8db6:	b3 cf       	rjmp	.-154    	; 0x8d1e <readFile+0xb2>
	  return 0;}
    8db8:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8dba:	67 96       	adiw	r28, 0x17	; 23
    8dbc:	cd bf       	out	0x3d, r28	; 61
    8dbe:	de bf       	out	0x3e, r29	; 62
    8dc0:	df 91       	pop	r29
    8dc2:	cf 91       	pop	r28
    8dc4:	1f 91       	pop	r17
    8dc6:	0f 91       	pop	r16
    8dc8:	08 95       	ret

00008dca <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8dca:	cf 93       	push	r28
    8dcc:	df 93       	push	r29
    8dce:	cd b7       	in	r28, 0x3d	; 61
    8dd0:	de b7       	in	r29, 0x3e	; 62
    8dd2:	62 97       	sbiw	r28, 0x12	; 18
    8dd4:	cd bf       	out	0x3d, r28	; 61
    8dd6:	de bf       	out	0x3e, r29	; 62
    8dd8:	89 8b       	std	Y+17, r24	; 0x11
    8dda:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8ddc:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    8dde:	89 89       	ldd	r24, Y+17	; 0x11
    8de0:	9a 89       	ldd	r25, Y+18	; 0x12
    8de2:	9c 01       	movw	r18, r24
    8de4:	f9 01       	movw	r30, r18
    8de6:	01 90       	ld	r0, Z+
    8de8:	00 20       	and	r0, r0
    8dea:	e9 f7       	brne	.-6      	; 0x8de6 <convertFileName+0x1c>
    8dec:	cf 01       	movw	r24, r30
    8dee:	01 97       	sbiw	r24, 0x01	; 1
    8df0:	82 1b       	sub	r24, r18
    8df2:	93 0b       	sbc	r25, r19
    8df4:	80 31       	cpi	r24, 0x10	; 16
    8df6:	91 05       	cpc	r25, r1
    8df8:	10 f0       	brcs	.+4      	; 0x8dfe <convertFileName+0x34>
    8dfa:	81 e0       	ldi	r24, 0x01	; 1
    8dfc:	16 c1       	rjmp	.+556    	; 0x902a <convertFileName+0x260>
int i=0;
    8dfe:	1c 82       	std	Y+4, r1	; 0x04
    8e00:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    8e02:	13 c0       	rjmp	.+38     	; 0x8e2a <convertFileName+0x60>
	Filename[i] = fileName[i];
    8e04:	8c 81       	ldd	r24, Y+4	; 0x04
    8e06:	9d 81       	ldd	r25, Y+5	; 0x05
    8e08:	29 89       	ldd	r18, Y+17	; 0x11
    8e0a:	3a 89       	ldd	r19, Y+18	; 0x12
    8e0c:	82 0f       	add	r24, r18
    8e0e:	93 1f       	adc	r25, r19
    8e10:	fc 01       	movw	r30, r24
    8e12:	20 81       	ld	r18, Z
    8e14:	8c 81       	ldd	r24, Y+4	; 0x04
    8e16:	9d 81       	ldd	r25, Y+5	; 0x05
    8e18:	84 55       	subi	r24, 0x54	; 84
    8e1a:	9f 4a       	sbci	r25, 0xAF	; 175
    8e1c:	fc 01       	movw	r30, r24
    8e1e:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    8e20:	8c 81       	ldd	r24, Y+4	; 0x04
    8e22:	9d 81       	ldd	r25, Y+5	; 0x05
    8e24:	01 96       	adiw	r24, 0x01	; 1
    8e26:	8c 83       	std	Y+4, r24	; 0x04
    8e28:	9d 83       	std	Y+5, r25	; 0x05
    8e2a:	4c 81       	ldd	r20, Y+4	; 0x04
    8e2c:	5d 81       	ldd	r21, Y+5	; 0x05
    8e2e:	89 89       	ldd	r24, Y+17	; 0x11
    8e30:	9a 89       	ldd	r25, Y+18	; 0x12
    8e32:	9c 01       	movw	r18, r24
    8e34:	f9 01       	movw	r30, r18
    8e36:	01 90       	ld	r0, Z+
    8e38:	00 20       	and	r0, r0
    8e3a:	e9 f7       	brne	.-6      	; 0x8e36 <convertFileName+0x6c>
    8e3c:	cf 01       	movw	r24, r30
    8e3e:	01 97       	sbiw	r24, 0x01	; 1
    8e40:	82 1b       	sub	r24, r18
    8e42:	93 0b       	sbc	r25, r19
    8e44:	48 17       	cp	r20, r24
    8e46:	59 07       	cpc	r21, r25
    8e48:	e8 f2       	brcs	.-70     	; 0x8e04 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8e4a:	0c c0       	rjmp	.+24     	; 0x8e64 <convertFileName+0x9a>
    8e4c:	8c 81       	ldd	r24, Y+4	; 0x04
    8e4e:	9d 81       	ldd	r25, Y+5	; 0x05
    8e50:	84 55       	subi	r24, 0x54	; 84
    8e52:	9f 4a       	sbci	r25, 0xAF	; 175
    8e54:	20 e2       	ldi	r18, 0x20	; 32
    8e56:	fc 01       	movw	r30, r24
    8e58:	20 83       	st	Z, r18
    8e5a:	8c 81       	ldd	r24, Y+4	; 0x04
    8e5c:	9d 81       	ldd	r25, Y+5	; 0x05
    8e5e:	01 96       	adiw	r24, 0x01	; 1
    8e60:	8c 83       	std	Y+4, r24	; 0x04
    8e62:	9d 83       	std	Y+5, r25	; 0x05
    8e64:	8c 81       	ldd	r24, Y+4	; 0x04
    8e66:	9d 81       	ldd	r25, Y+5	; 0x05
    8e68:	8f 30       	cpi	r24, 0x0F	; 15
    8e6a:	91 05       	cpc	r25, r1
    8e6c:	7c f3       	brlt	.-34     	; 0x8e4c <convertFileName+0x82>


for(j=0; j<12; j++)
    8e6e:	1a 82       	std	Y+2, r1	; 0x02
    8e70:	0c c0       	rjmp	.+24     	; 0x8e8a <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8e72:	8a 81       	ldd	r24, Y+2	; 0x02
    8e74:	88 2f       	mov	r24, r24
    8e76:	90 e0       	ldi	r25, 0x00	; 0
    8e78:	84 55       	subi	r24, 0x54	; 84
    8e7a:	9f 4a       	sbci	r25, 0xAF	; 175
    8e7c:	fc 01       	movw	r30, r24
    8e7e:	80 81       	ld	r24, Z
    8e80:	8e 32       	cpi	r24, 0x2E	; 46
    8e82:	39 f0       	breq	.+14     	; 0x8e92 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8e84:	8a 81       	ldd	r24, Y+2	; 0x02
    8e86:	8f 5f       	subi	r24, 0xFF	; 255
    8e88:	8a 83       	std	Y+2, r24	; 0x02
    8e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    8e8c:	8c 30       	cpi	r24, 0x0C	; 12
    8e8e:	88 f3       	brcs	.-30     	; 0x8e72 <convertFileName+0xa8>
    8e90:	01 c0       	rjmp	.+2      	; 0x8e94 <convertFileName+0xca>
if(Filename[j] == '.') break;
    8e92:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8e94:	8a 81       	ldd	r24, Y+2	; 0x02
    8e96:	89 30       	cpi	r24, 0x09	; 9
    8e98:	28 f0       	brcs	.+10     	; 0x8ea4 <convertFileName+0xda>
    8e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    8e9c:	8c 30       	cpi	r24, 0x0C	; 12
    8e9e:	10 f4       	brcc	.+4      	; 0x8ea4 <convertFileName+0xda>
	return 1;}
    8ea0:	81 e0       	ldi	r24, 0x01	; 1
    8ea2:	c3 c0       	rjmp	.+390    	; 0x902a <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    8ea6:	8c 30       	cpi	r24, 0x0C	; 12
    8ea8:	11 f4       	brne	.+4      	; 0x8eae <convertFileName+0xe4>
    8eaa:	81 e0       	ldi	r24, 0x01	; 1
    8eac:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8eae:	1b 82       	std	Y+3, r1	; 0x03
    8eb0:	14 c0       	rjmp	.+40     	; 0x8eda <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8eb2:	8b 81       	ldd	r24, Y+3	; 0x03
    8eb4:	88 2f       	mov	r24, r24
    8eb6:	90 e0       	ldi	r25, 0x00	; 0
    8eb8:	2b 81       	ldd	r18, Y+3	; 0x03
    8eba:	22 2f       	mov	r18, r18
    8ebc:	30 e0       	ldi	r19, 0x00	; 0
    8ebe:	24 55       	subi	r18, 0x54	; 84
    8ec0:	3f 4a       	sbci	r19, 0xAF	; 175
    8ec2:	f9 01       	movw	r30, r18
    8ec4:	40 81       	ld	r20, Z
    8ec6:	9e 01       	movw	r18, r28
    8ec8:	2a 5f       	subi	r18, 0xFA	; 250
    8eca:	3f 4f       	sbci	r19, 0xFF	; 255
    8ecc:	82 0f       	add	r24, r18
    8ece:	93 1f       	adc	r25, r19
    8ed0:	fc 01       	movw	r30, r24
    8ed2:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    8ed6:	8f 5f       	subi	r24, 0xFF	; 255
    8ed8:	8b 83       	std	Y+3, r24	; 0x03
    8eda:	9b 81       	ldd	r25, Y+3	; 0x03
    8edc:	8a 81       	ldd	r24, Y+2	; 0x02
    8ede:	98 17       	cp	r25, r24
    8ee0:	40 f3       	brcs	.-48     	; 0x8eb2 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    8ee4:	8b 83       	std	Y+3, r24	; 0x03
    8ee6:	0e c0       	rjmp	.+28     	; 0x8f04 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    8eea:	88 2f       	mov	r24, r24
    8eec:	90 e0       	ldi	r25, 0x00	; 0
    8eee:	9e 01       	movw	r18, r28
    8ef0:	2a 5f       	subi	r18, 0xFA	; 250
    8ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    8ef4:	82 0f       	add	r24, r18
    8ef6:	93 1f       	adc	r25, r19
    8ef8:	20 e2       	ldi	r18, 0x20	; 32
    8efa:	fc 01       	movw	r30, r24
    8efc:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8efe:	8b 81       	ldd	r24, Y+3	; 0x03
    8f00:	8f 5f       	subi	r24, 0xFF	; 255
    8f02:	8b 83       	std	Y+3, r24	; 0x03
    8f04:	8b 81       	ldd	r24, Y+3	; 0x03
    8f06:	88 30       	cpi	r24, 0x08	; 8
    8f08:	78 f3       	brcs	.-34     	; 0x8ee8 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8f0a:	99 81       	ldd	r25, Y+1	; 0x01
    8f0c:	81 e0       	ldi	r24, 0x01	; 1
    8f0e:	89 27       	eor	r24, r25
    8f10:	88 23       	and	r24, r24
    8f12:	19 f0       	breq	.+6      	; 0x8f1a <convertFileName+0x150>
    8f14:	8a 81       	ldd	r24, Y+2	; 0x02
    8f16:	8f 5f       	subi	r24, 0xFF	; 255
    8f18:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8f1a:	88 e0       	ldi	r24, 0x08	; 8
    8f1c:	8b 83       	std	Y+3, r24	; 0x03
    8f1e:	32 c0       	rjmp	.+100    	; 0x8f84 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8f20:	8a 81       	ldd	r24, Y+2	; 0x02
    8f22:	88 2f       	mov	r24, r24
    8f24:	90 e0       	ldi	r25, 0x00	; 0
    8f26:	84 55       	subi	r24, 0x54	; 84
    8f28:	9f 4a       	sbci	r25, 0xAF	; 175
    8f2a:	fc 01       	movw	r30, r24
    8f2c:	80 81       	ld	r24, Z
    8f2e:	88 23       	and	r24, r24
    8f30:	19 f1       	breq	.+70     	; 0x8f78 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8f32:	8b 81       	ldd	r24, Y+3	; 0x03
    8f34:	88 2f       	mov	r24, r24
    8f36:	90 e0       	ldi	r25, 0x00	; 0
    8f38:	2a 81       	ldd	r18, Y+2	; 0x02
    8f3a:	22 2f       	mov	r18, r18
    8f3c:	30 e0       	ldi	r19, 0x00	; 0
    8f3e:	24 55       	subi	r18, 0x54	; 84
    8f40:	3f 4a       	sbci	r19, 0xAF	; 175
    8f42:	f9 01       	movw	r30, r18
    8f44:	40 81       	ld	r20, Z
    8f46:	9e 01       	movw	r18, r28
    8f48:	2a 5f       	subi	r18, 0xFA	; 250
    8f4a:	3f 4f       	sbci	r19, 0xFF	; 255
    8f4c:	82 0f       	add	r24, r18
    8f4e:	93 1f       	adc	r25, r19
    8f50:	fc 01       	movw	r30, r24
    8f52:	40 83       	st	Z, r20
    8f54:	8a 81       	ldd	r24, Y+2	; 0x02
    8f56:	8f 5f       	subi	r24, 0xFF	; 255
    8f58:	8a 83       	std	Y+2, r24	; 0x02
    8f5a:	11 c0       	rjmp	.+34     	; 0x8f7e <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    8f5e:	88 2f       	mov	r24, r24
    8f60:	90 e0       	ldi	r25, 0x00	; 0
    8f62:	9e 01       	movw	r18, r28
    8f64:	2a 5f       	subi	r18, 0xFA	; 250
    8f66:	3f 4f       	sbci	r19, 0xFF	; 255
    8f68:	82 0f       	add	r24, r18
    8f6a:	93 1f       	adc	r25, r19
    8f6c:	20 e2       	ldi	r18, 0x20	; 32
    8f6e:	fc 01       	movw	r30, r24
    8f70:	20 83       	st	Z, r18
    8f72:	8b 81       	ldd	r24, Y+3	; 0x03
    8f74:	8f 5f       	subi	r24, 0xFF	; 255
    8f76:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8f78:	8b 81       	ldd	r24, Y+3	; 0x03
    8f7a:	8b 30       	cpi	r24, 0x0B	; 11
    8f7c:	78 f3       	brcs	.-34     	; 0x8f5c <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    8f80:	8f 5f       	subi	r24, 0xFF	; 255
    8f82:	8b 83       	std	Y+3, r24	; 0x03
    8f84:	8b 81       	ldd	r24, Y+3	; 0x03
    8f86:	8b 30       	cpi	r24, 0x0B	; 11
    8f88:	58 f2       	brcs	.-106    	; 0x8f20 <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8f8a:	1a 82       	std	Y+2, r1	; 0x02
    8f8c:	31 c0       	rjmp	.+98     	; 0x8ff0 <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8f8e:	8a 81       	ldd	r24, Y+2	; 0x02
    8f90:	88 2f       	mov	r24, r24
    8f92:	90 e0       	ldi	r25, 0x00	; 0
    8f94:	9e 01       	movw	r18, r28
    8f96:	2a 5f       	subi	r18, 0xFA	; 250
    8f98:	3f 4f       	sbci	r19, 0xFF	; 255
    8f9a:	82 0f       	add	r24, r18
    8f9c:	93 1f       	adc	r25, r19
    8f9e:	fc 01       	movw	r30, r24
    8fa0:	80 81       	ld	r24, Z
    8fa2:	81 36       	cpi	r24, 0x61	; 97
    8fa4:	10 f1       	brcs	.+68     	; 0x8fea <convertFileName+0x220>
    8fa6:	8a 81       	ldd	r24, Y+2	; 0x02
    8fa8:	88 2f       	mov	r24, r24
    8faa:	90 e0       	ldi	r25, 0x00	; 0
    8fac:	9e 01       	movw	r18, r28
    8fae:	2a 5f       	subi	r18, 0xFA	; 250
    8fb0:	3f 4f       	sbci	r19, 0xFF	; 255
    8fb2:	82 0f       	add	r24, r18
    8fb4:	93 1f       	adc	r25, r19
    8fb6:	fc 01       	movw	r30, r24
    8fb8:	80 81       	ld	r24, Z
    8fba:	8b 37       	cpi	r24, 0x7B	; 123
    8fbc:	b0 f4       	brcc	.+44     	; 0x8fea <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    8fc0:	88 2f       	mov	r24, r24
    8fc2:	90 e0       	ldi	r25, 0x00	; 0
    8fc4:	2a 81       	ldd	r18, Y+2	; 0x02
    8fc6:	22 2f       	mov	r18, r18
    8fc8:	30 e0       	ldi	r19, 0x00	; 0
    8fca:	ae 01       	movw	r20, r28
    8fcc:	4a 5f       	subi	r20, 0xFA	; 250
    8fce:	5f 4f       	sbci	r21, 0xFF	; 255
    8fd0:	24 0f       	add	r18, r20
    8fd2:	35 1f       	adc	r19, r21
    8fd4:	f9 01       	movw	r30, r18
    8fd6:	20 81       	ld	r18, Z
    8fd8:	42 2f       	mov	r20, r18
    8fda:	40 52       	subi	r20, 0x20	; 32
    8fdc:	9e 01       	movw	r18, r28
    8fde:	2a 5f       	subi	r18, 0xFA	; 250
    8fe0:	3f 4f       	sbci	r19, 0xFF	; 255
    8fe2:	82 0f       	add	r24, r18
    8fe4:	93 1f       	adc	r25, r19
    8fe6:	fc 01       	movw	r30, r24
    8fe8:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8fea:	8a 81       	ldd	r24, Y+2	; 0x02
    8fec:	8f 5f       	subi	r24, 0xFF	; 255
    8fee:	8a 83       	std	Y+2, r24	; 0x02
    8ff0:	8a 81       	ldd	r24, Y+2	; 0x02
    8ff2:	8b 30       	cpi	r24, 0x0B	; 11
    8ff4:	60 f2       	brcs	.-104    	; 0x8f8e <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8ff6:	1a 82       	std	Y+2, r1	; 0x02
    8ff8:	14 c0       	rjmp	.+40     	; 0x9022 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8ffa:	8a 81       	ldd	r24, Y+2	; 0x02
    8ffc:	88 2f       	mov	r24, r24
    8ffe:	90 e0       	ldi	r25, 0x00	; 0
    9000:	2a 81       	ldd	r18, Y+2	; 0x02
    9002:	22 2f       	mov	r18, r18
    9004:	30 e0       	ldi	r19, 0x00	; 0
    9006:	ae 01       	movw	r20, r28
    9008:	4a 5f       	subi	r20, 0xFA	; 250
    900a:	5f 4f       	sbci	r21, 0xFF	; 255
    900c:	24 0f       	add	r18, r20
    900e:	35 1f       	adc	r19, r21
    9010:	f9 01       	movw	r30, r18
    9012:	20 81       	ld	r18, Z
    9014:	84 55       	subi	r24, 0x54	; 84
    9016:	9f 4a       	sbci	r25, 0xAF	; 175
    9018:	fc 01       	movw	r30, r24
    901a:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    901c:	8a 81       	ldd	r24, Y+2	; 0x02
    901e:	8f 5f       	subi	r24, 0xFF	; 255
    9020:	8a 83       	std	Y+2, r24	; 0x02
    9022:	8a 81       	ldd	r24, Y+2	; 0x02
    9024:	8b 30       	cpi	r24, 0x0B	; 11
    9026:	48 f3       	brcs	.-46     	; 0x8ffa <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    9028:	80 e0       	ldi	r24, 0x00	; 0
}
    902a:	62 96       	adiw	r28, 0x12	; 18
    902c:	cd bf       	out	0x3d, r28	; 61
    902e:	de bf       	out	0x3e, r29	; 62
    9030:	df 91       	pop	r29
    9032:	cf 91       	pop	r28
    9034:	08 95       	ret

00009036 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    9036:	ef 92       	push	r14
    9038:	ff 92       	push	r15
    903a:	0f 93       	push	r16
    903c:	1f 93       	push	r17
    903e:	cf 93       	push	r28
    9040:	df 93       	push	r29
    9042:	cd b7       	in	r28, 0x3d	; 61
    9044:	de b7       	in	r29, 0x3e	; 62
    9046:	e7 97       	sbiw	r28, 0x37	; 55
    9048:	cd bf       	out	0x3d, r28	; 61
    904a:	de bf       	out	0x3e, r29	; 62
    904c:	88 ab       	sts	0x58, r24
    904e:	99 ab       	sts	0x59, r25
    9050:	6a ab       	sts	0x5a, r22
    9052:	7b ab       	sts	0x5b, r23
    9054:	2c ab       	sts	0x5c, r18
    9056:	3d ab       	sts	0x5d, r19
    9058:	4e ab       	sts	0x5e, r20
    905a:	5f ab       	sts	0x5f, r21
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    905c:	1a 82       	std	Y+2, r1	; 0x02
    905e:	1b 82       	std	Y+3, r1	; 0x03
    9060:	1c 82       	std	Y+4, r1	; 0x04
    9062:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    9064:	1e 82       	std	Y+6, r1	; 0x06
    9066:	1f 82       	std	Y+7, r1	; 0x07
    9068:	18 86       	std	Y+8, r1	; 0x08
    906a:	19 86       	std	Y+9, r1	; 0x09
    906c:	1a 86       	std	Y+10, r1	; 0x0a
    906e:	1b 86       	std	Y+11, r1	; 0x0b
if(strlen(fileName) > 15) return 1;
for(int i=0; i < strlen(fileName); i++){
	Filename[i] = fileName[i];
}
*/
j = readFile (VERIFY, fileName);
    9070:	28 a9       	sts	0x48, r18
    9072:	39 a9       	sts	0x49, r19
    9074:	81 e0       	ldi	r24, 0x01	; 1
    9076:	b9 01       	movw	r22, r18
    9078:	0e 94 36 46 	call	0x8c6c	; 0x8c6c <readFile>
    907c:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    907e:	89 81       	ldd	r24, Y+1	; 0x01
    9080:	81 30       	cpi	r24, 0x01	; 1
    9082:	09 f0       	breq	.+2      	; 0x9086 <writeFile+0x50>
    9084:	84 c0       	rjmp	.+264    	; 0x918e <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    9086:	81 e0       	ldi	r24, 0x01	; 1
    9088:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    908a:	80 91 72 50 	lds	r24, 0x5072
    908e:	90 91 73 50 	lds	r25, 0x5073
    9092:	a0 91 74 50 	lds	r26, 0x5074
    9096:	b0 91 75 50 	lds	r27, 0x5075
    909a:	8c 87       	std	Y+12, r24	; 0x0c
    909c:	9d 87       	std	Y+13, r25	; 0x0d
    909e:	ae 87       	std	Y+14, r26	; 0x0e
    90a0:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    90a2:	1c 8a       	std	Y+20, r1	; 0x14
    90a4:	1d 8a       	std	Y+21, r1	; 0x15
    90a6:	1e 8a       	std	Y+22, r1	; 0x16
    90a8:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    90aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    90ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    90ae:	ae 85       	ldd	r26, Y+14	; 0x0e
    90b0:	bf 85       	ldd	r27, Y+15	; 0x0f
    90b2:	bc 01       	movw	r22, r24
    90b4:	cd 01       	movw	r24, r26
    90b6:	40 e0       	ldi	r20, 0x00	; 0
    90b8:	00 e0       	ldi	r16, 0x00	; 0
    90ba:	10 e0       	ldi	r17, 0x00	; 0
    90bc:	98 01       	movw	r18, r16
    90be:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
    90c2:	dc 01       	movw	r26, r24
    90c4:	cb 01       	movw	r24, r22
    90c6:	8a a3       	lds	r24, 0x5a
    90c8:	9b a3       	lds	r25, 0x5b
    90ca:	ac a3       	lds	r26, 0x5c
    90cc:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    90ce:	8a a1       	lds	r24, 0x4a
    90d0:	9b a1       	lds	r25, 0x4b
    90d2:	ac a1       	lds	r26, 0x4c
    90d4:	bd a1       	lds	r27, 0x4d
    90d6:	8f 3f       	cpi	r24, 0xFF	; 255
    90d8:	0f ef       	ldi	r16, 0xFF	; 255
    90da:	90 07       	cpc	r25, r16
    90dc:	0f ef       	ldi	r16, 0xFF	; 255
    90de:	a0 07       	cpc	r26, r16
    90e0:	0f e0       	ldi	r16, 0x0F	; 15
    90e2:	b0 07       	cpc	r27, r16
    90e4:	a1 f0       	breq	.+40     	; 0x910e <writeFile+0xd8>
	cluster = nextCluster;
    90e6:	8a a1       	lds	r24, 0x4a
    90e8:	9b a1       	lds	r25, 0x4b
    90ea:	ac a1       	lds	r26, 0x4c
    90ec:	bd a1       	lds	r27, 0x4d
    90ee:	8c 87       	std	Y+12, r24	; 0x0c
    90f0:	9d 87       	std	Y+13, r25	; 0x0d
    90f2:	ae 87       	std	Y+14, r26	; 0x0e
    90f4:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    90f6:	8c 89       	ldd	r24, Y+20	; 0x14
    90f8:	9d 89       	ldd	r25, Y+21	; 0x15
    90fa:	ae 89       	ldd	r26, Y+22	; 0x16
    90fc:	bf 89       	ldd	r27, Y+23	; 0x17
    90fe:	01 96       	adiw	r24, 0x01	; 1
    9100:	a1 1d       	adc	r26, r1
    9102:	b1 1d       	adc	r27, r1
    9104:	8c 8b       	std	Y+20, r24	; 0x14
    9106:	9d 8b       	std	Y+21, r25	; 0x15
    9108:	ae 8b       	std	Y+22, r26	; 0x16
    910a:	bf 8b       	std	Y+23, r27	; 0x17
  }
    910c:	ce cf       	rjmp	.-100    	; 0x90aa <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    910e:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    9110:	e0 90 3f 40 	lds	r14, 0x403F
    9114:	f0 90 40 40 	lds	r15, 0x4040
    9118:	00 91 41 40 	lds	r16, 0x4041
    911c:	10 91 42 40 	lds	r17, 0x4042
    9120:	80 91 66 50 	lds	r24, 0x5066
    9124:	90 91 67 50 	lds	r25, 0x5067
    9128:	cc 01       	movw	r24, r24
    912a:	a0 e0       	ldi	r26, 0x00	; 0
    912c:	b0 e0       	ldi	r27, 0x00	; 0
    912e:	2c 89       	ldd	r18, Y+20	; 0x14
    9130:	3d 89       	ldd	r19, Y+21	; 0x15
    9132:	4e 89       	ldd	r20, Y+22	; 0x16
    9134:	5f 89       	ldd	r21, Y+23	; 0x17
    9136:	bc 01       	movw	r22, r24
    9138:	cd 01       	movw	r24, r26
    913a:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    913e:	dc 01       	movw	r26, r24
    9140:	cb 01       	movw	r24, r22
    9142:	20 91 43 40 	lds	r18, 0x4043
    9146:	30 91 44 40 	lds	r19, 0x4044
    914a:	99 01       	movw	r18, r18
    914c:	40 e0       	ldi	r20, 0x00	; 0
    914e:	50 e0       	ldi	r21, 0x00	; 0
    9150:	bc 01       	movw	r22, r24
    9152:	cd 01       	movw	r24, r26
    9154:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    9158:	dc 01       	movw	r26, r24
    915a:	cb 01       	movw	r24, r22
    915c:	a8 01       	movw	r20, r16
    915e:	97 01       	movw	r18, r14
    9160:	28 1b       	sub	r18, r24
    9162:	39 0b       	sbc	r19, r25
    9164:	4a 0b       	sbc	r20, r26
    9166:	5b 0b       	sbc	r21, r27
    9168:	da 01       	movw	r26, r20
    916a:	c9 01       	movw	r24, r18
    916c:	20 91 43 40 	lds	r18, 0x4043
    9170:	30 91 44 40 	lds	r19, 0x4044
    9174:	99 01       	movw	r18, r18
    9176:	40 e0       	ldi	r20, 0x00	; 0
    9178:	50 e0       	ldi	r21, 0x00	; 0
    917a:	bc 01       	movw	r22, r24
    917c:	cd 01       	movw	r24, r26
    917e:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    9182:	da 01       	movw	r26, r20
    9184:	c9 01       	movw	r24, r18
    9186:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    9188:	81 e0       	ldi	r24, 0x01	; 1
    918a:	8b 83       	std	Y+3, r24	; 0x03
    918c:	69 c0       	rjmp	.+210    	; 0x9260 <writeFile+0x22a>
}
else if(j == 2) 
    918e:	89 81       	ldd	r24, Y+1	; 0x01
    9190:	82 30       	cpi	r24, 0x02	; 2
    9192:	11 f4       	brne	.+4      	; 0x9198 <writeFile+0x162>
   return 1; //invalid file name
    9194:	81 e0       	ldi	r24, 0x01	; 1
    9196:	1b c3       	rjmp	.+1590   	; 0x97ce <writeFile+0x798>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    9198:	82 e0       	ldi	r24, 0x02	; 2
    919a:	60 e0       	ldi	r22, 0x00	; 0
    919c:	20 e0       	ldi	r18, 0x00	; 0
    919e:	30 e0       	ldi	r19, 0x00	; 0
    91a0:	a9 01       	movw	r20, r18
    91a2:	0e 94 ab 43 	call	0x8756	; 0x8756 <getSetFreeCluster>
    91a6:	dc 01       	movw	r26, r24
    91a8:	cb 01       	movw	r24, r22
    91aa:	8c 87       	std	Y+12, r24	; 0x0c
    91ac:	9d 87       	std	Y+13, r25	; 0x0d
    91ae:	ae 87       	std	Y+14, r26	; 0x0e
    91b0:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    91b2:	80 91 48 40 	lds	r24, 0x4048
    91b6:	90 91 49 40 	lds	r25, 0x4049
    91ba:	a0 91 4a 40 	lds	r26, 0x404A
    91be:	b0 91 4b 40 	lds	r27, 0x404B
    91c2:	2c 85       	ldd	r18, Y+12	; 0x0c
    91c4:	3d 85       	ldd	r19, Y+13	; 0x0d
    91c6:	4e 85       	ldd	r20, Y+14	; 0x0e
    91c8:	5f 85       	ldd	r21, Y+15	; 0x0f
    91ca:	82 17       	cp	r24, r18
    91cc:	93 07       	cpc	r25, r19
    91ce:	a4 07       	cpc	r26, r20
    91d0:	b5 07       	cpc	r27, r21
    91d2:	60 f4       	brcc	.+24     	; 0x91ec <writeFile+0x1b6>
     cluster = rootCluster;
    91d4:	80 91 4e 40 	lds	r24, 0x404E
    91d8:	90 91 4f 40 	lds	r25, 0x404F
    91dc:	a0 91 50 40 	lds	r26, 0x4050
    91e0:	b0 91 51 40 	lds	r27, 0x4051
    91e4:	8c 87       	std	Y+12, r24	; 0x0c
    91e6:	9d 87       	std	Y+13, r25	; 0x0d
    91e8:	ae 87       	std	Y+14, r26	; 0x0e
    91ea:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    91ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    91ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    91f0:	ae 85       	ldd	r26, Y+14	; 0x0e
    91f2:	bf 85       	ldd	r27, Y+15	; 0x0f
    91f4:	bc 01       	movw	r22, r24
    91f6:	cd 01       	movw	r24, r26
    91f8:	0e 94 f1 4b 	call	0x97e2	; 0x97e2 <searchNextFreeCluster>
    91fc:	dc 01       	movw	r26, r24
    91fe:	cb 01       	movw	r24, r22
    9200:	8c 87       	std	Y+12, r24	; 0x0c
    9202:	9d 87       	std	Y+13, r25	; 0x0d
    9204:	ae 87       	std	Y+14, r26	; 0x0e
    9206:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    9208:	8c 85       	ldd	r24, Y+12	; 0x0c
    920a:	9d 85       	ldd	r25, Y+13	; 0x0d
    920c:	ae 85       	ldd	r26, Y+14	; 0x0e
    920e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9210:	00 97       	sbiw	r24, 0x00	; 0
    9212:	a1 05       	cpc	r26, r1
    9214:	b1 05       	cpc	r27, r1
    9216:	11 f4       	brne	.+4      	; 0x921c <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    9218:	82 e0       	ldi	r24, 0x02	; 2
    921a:	d9 c2       	rjmp	.+1458   	; 0x97ce <writeFile+0x798>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    921c:	8c 85       	ldd	r24, Y+12	; 0x0c
    921e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9220:	ae 85       	ldd	r26, Y+14	; 0x0e
    9222:	bf 85       	ldd	r27, Y+15	; 0x0f
    9224:	bc 01       	movw	r22, r24
    9226:	cd 01       	movw	r24, r26
    9228:	41 e0       	ldi	r20, 0x01	; 1
    922a:	0f ef       	ldi	r16, 0xFF	; 255
    922c:	1f ef       	ldi	r17, 0xFF	; 255
    922e:	2f ef       	ldi	r18, 0xFF	; 255
    9230:	3f e0       	ldi	r19, 0x0F	; 15
    9232:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    9236:	8c 85       	ldd	r24, Y+12	; 0x0c
    9238:	9d 85       	ldd	r25, Y+13	; 0x0d
    923a:	ae 85       	ldd	r26, Y+14	; 0x0e
    923c:	bf 85       	ldd	r27, Y+15	; 0x0f
    923e:	cd 01       	movw	r24, r26
    9240:	aa 27       	eor	r26, r26
    9242:	bb 27       	eor	r27, r27
    9244:	8e 83       	std	Y+6, r24	; 0x06
    9246:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    9248:	8c 85       	ldd	r24, Y+12	; 0x0c
    924a:	9d 85       	ldd	r25, Y+13	; 0x0d
    924c:	88 87       	std	Y+8, r24	; 0x08
    924e:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    9250:	10 92 3f 40 	sts	0x403F, r1
    9254:	10 92 40 40 	sts	0x4040, r1
    9258:	10 92 41 40 	sts	0x4041, r1
    925c:	10 92 42 40 	sts	0x4042, r1
}

//start writing data here

if(start){
    9260:	8b 81       	ldd	r24, Y+3	; 0x03
    9262:	88 23       	and	r24, r24
    9264:	11 f1       	breq	.+68     	; 0x92aa <writeFile+0x274>
  start = 0;
    9266:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    9268:	8c 85       	ldd	r24, Y+12	; 0x0c
    926a:	9d 85       	ldd	r25, Y+13	; 0x0d
    926c:	ae 85       	ldd	r26, Y+14	; 0x0e
    926e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9270:	bc 01       	movw	r22, r24
    9272:	cd 01       	movw	r24, r26
    9274:	0e 94 cf 42 	call	0x859e	; 0x859e <getFirstSector>
    9278:	dc 01       	movw	r26, r24
    927a:	cb 01       	movw	r24, r22
    927c:	9c 01       	movw	r18, r24
    927e:	8d 81       	ldd	r24, Y+5	; 0x05
    9280:	88 2f       	mov	r24, r24
    9282:	90 e0       	ldi	r25, 0x00	; 0
    9284:	82 0f       	add	r24, r18
    9286:	93 1f       	adc	r25, r19
    9288:	8a 87       	std	Y+10, r24	; 0x0a
    928a:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    928c:	8a 85       	ldd	r24, Y+10	; 0x0a
    928e:	9b 85       	ldd	r25, Y+11	; 0x0b
    9290:	cc 01       	movw	r24, r24
    9292:	a0 e0       	ldi	r26, 0x00	; 0
    9294:	b0 e0       	ldi	r27, 0x00	; 0
    9296:	25 ec       	ldi	r18, 0xC5	; 197
    9298:	31 e2       	ldi	r19, 0x21	; 33
    929a:	bc 01       	movw	r22, r24
    929c:	cd 01       	movw	r24, r26
    929e:	a9 01       	movw	r20, r18
    92a0:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
  j = sector;
    92a4:	8d 81       	ldd	r24, Y+5	; 0x05
    92a6:	89 83       	std	Y+1, r24	; 0x01
    92a8:	0d c0       	rjmp	.+26     	; 0x92c4 <writeFile+0x28e>
}
else{
  startBlock = getFirstSector (cluster);
    92aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    92ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    92ae:	ae 85       	ldd	r26, Y+14	; 0x0e
    92b0:	bf 85       	ldd	r27, Y+15	; 0x0f
    92b2:	bc 01       	movw	r22, r24
    92b4:	cd 01       	movw	r24, r26
    92b6:	0e 94 cf 42 	call	0x859e	; 0x859e <getFirstSector>
    92ba:	dc 01       	movw	r26, r24
    92bc:	cb 01       	movw	r24, r22
    92be:	8a 87       	std	Y+10, r24	; 0x0a
    92c0:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    92c2:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    92c4:	18 8e       	std	Y+24, r1	; 0x18
    92c6:	19 8e       	std	Y+25, r1	; 0x19
    92c8:	1a 8e       	std	Y+26, r1	; 0x1a
    92ca:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    92cc:	1c 8e       	std	Y+28, r1	; 0x1c
    92ce:	1d 8e       	std	Y+29, r1	; 0x1d
    92d0:	1e 8e       	std	Y+30, r1	; 0x1e
    92d2:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    92d4:	cd c0       	rjmp	.+410    	; 0x9470 <writeFile+0x43a>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    92d6:	8c a9       	sts	0x4c, r24
    92d8:	9d a9       	sts	0x4d, r25
    92da:	ae a9       	sts	0x4e, r26
    92dc:	bf a9       	sts	0x4f, r27
    92de:	80 30       	cpi	r24, 0x00	; 0
    92e0:	32 e0       	ldi	r19, 0x02	; 2
    92e2:	93 07       	cpc	r25, r19
    92e4:	30 e0       	ldi	r19, 0x00	; 0
    92e6:	a3 07       	cpc	r26, r19
    92e8:	30 e0       	ldi	r19, 0x00	; 0
    92ea:	b3 07       	cpc	r27, r19
    92ec:	08 f1       	brcs	.+66     	; 0x9330 <writeFile+0x2fa>
		 writtenData += 512;
    92ee:	88 8d       	ldd	r24, Y+24	; 0x18
    92f0:	99 8d       	ldd	r25, Y+25	; 0x19
    92f2:	aa 8d       	ldd	r26, Y+26	; 0x1a
    92f4:	bb 8d       	ldd	r27, Y+27	; 0x1b
    92f6:	80 50       	subi	r24, 0x00	; 0
    92f8:	9e 4f       	sbci	r25, 0xFE	; 254
    92fa:	af 4f       	sbci	r26, 0xFF	; 255
    92fc:	bf 4f       	sbci	r27, 0xFF	; 255
    92fe:	88 8f       	std	Y+24, r24	; 0x18
    9300:	99 8f       	std	Y+25, r25	; 0x19
    9302:	aa 8f       	std	Y+26, r26	; 0x1a
    9304:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    9306:	80 e0       	ldi	r24, 0x00	; 0
    9308:	92 e0       	ldi	r25, 0x02	; 2
    930a:	a0 e0       	ldi	r26, 0x00	; 0
    930c:	b0 e0       	ldi	r27, 0x00	; 0
    930e:	8c 8f       	std	Y+28, r24	; 0x1c
    9310:	9d 8f       	std	Y+29, r25	; 0x1d
    9312:	ae 8f       	std	Y+30, r26	; 0x1e
    9314:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    9316:	8c a9       	sts	0x4c, r24
    9318:	9d a9       	sts	0x4d, r25
    931a:	ae a9       	sts	0x4e, r26
    931c:	bf a9       	sts	0x4f, r27
    931e:	80 50       	subi	r24, 0x00	; 0
    9320:	92 40       	sbci	r25, 0x02	; 2
    9322:	a0 40       	sbci	r26, 0x00	; 0
    9324:	b0 40       	sbci	r27, 0x00	; 0
    9326:	8c ab       	sts	0x5c, r24
    9328:	9d ab       	sts	0x5d, r25
    932a:	ae ab       	sts	0x5e, r26
    932c:	bf ab       	sts	0x5f, r27
    932e:	1f c0       	rjmp	.+62     	; 0x936e <writeFile+0x338>
	}
	else{
		writtenData += lengthOfData;
    9330:	28 8d       	ldd	r18, Y+24	; 0x18
    9332:	39 8d       	ldd	r19, Y+25	; 0x19
    9334:	4a 8d       	ldd	r20, Y+26	; 0x1a
    9336:	5b 8d       	ldd	r21, Y+27	; 0x1b
    9338:	8c a9       	sts	0x4c, r24
    933a:	9d a9       	sts	0x4d, r25
    933c:	ae a9       	sts	0x4e, r26
    933e:	bf a9       	sts	0x4f, r27
    9340:	82 0f       	add	r24, r18
    9342:	93 1f       	adc	r25, r19
    9344:	a4 1f       	adc	r26, r20
    9346:	b5 1f       	adc	r27, r21
    9348:	88 8f       	std	Y+24, r24	; 0x18
    934a:	99 8f       	std	Y+25, r25	; 0x19
    934c:	aa 8f       	std	Y+26, r26	; 0x1a
    934e:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    9350:	8c a9       	sts	0x4c, r24
    9352:	9d a9       	sts	0x4d, r25
    9354:	ae a9       	sts	0x4e, r26
    9356:	bf a9       	sts	0x4f, r27
    9358:	91 70       	andi	r25, 0x01	; 1
    935a:	a0 70       	andi	r26, 0x00	; 0
    935c:	b0 70       	andi	r27, 0x00	; 0
    935e:	8c 8f       	std	Y+28, r24	; 0x1c
    9360:	9d 8f       	std	Y+29, r25	; 0x1d
    9362:	ae 8f       	std	Y+30, r26	; 0x1e
    9364:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    9366:	1c aa       	sts	0x9c, r17
    9368:	1d aa       	sts	0x9d, r17
    936a:	1e aa       	sts	0x9e, r17
    936c:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    936e:	80 91 3f 40 	lds	r24, 0x403F
    9372:	90 91 40 40 	lds	r25, 0x4040
    9376:	a0 91 41 40 	lds	r26, 0x4041
    937a:	b0 91 42 40 	lds	r27, 0x4042
    937e:	80 50       	subi	r24, 0x00	; 0
    9380:	9e 4f       	sbci	r25, 0xFE	; 254
    9382:	af 4f       	sbci	r26, 0xFF	; 255
    9384:	bf 4f       	sbci	r27, 0xFF	; 255
    9386:	80 93 3f 40 	sts	0x403F, r24
    938a:	90 93 40 40 	sts	0x4040, r25
    938e:	a0 93 41 40 	sts	0x4041, r26
    9392:	b0 93 42 40 	sts	0x4042, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    9396:	8a 85       	ldd	r24, Y+10	; 0x0a
    9398:	9b 85       	ldd	r25, Y+11	; 0x0b
    939a:	cc 01       	movw	r24, r24
    939c:	a0 e0       	ldi	r26, 0x00	; 0
    939e:	b0 e0       	ldi	r27, 0x00	; 0
    93a0:	48 8d       	ldd	r20, Y+24	; 0x18
    93a2:	59 8d       	ldd	r21, Y+25	; 0x19
    93a4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    93a6:	3d 8d       	ldd	r19, Y+29	; 0x1d
    93a8:	ba 01       	movw	r22, r20
    93aa:	62 1b       	sub	r22, r18
    93ac:	73 0b       	sbc	r23, r19
    93ae:	9b 01       	movw	r18, r22
    93b0:	4a a9       	sts	0x4a, r20
    93b2:	5b a9       	sts	0x4b, r21
    93b4:	42 0f       	add	r20, r18
    93b6:	53 1f       	adc	r21, r19
    93b8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    93ba:	3d 8d       	ldd	r19, Y+29	; 0x1d
    93bc:	bc 01       	movw	r22, r24
    93be:	cd 01       	movw	r24, r26
    93c0:	0e 94 2d 50 	call	0xa05a	; 0xa05a <SD_write_block>
	j++;
    93c4:	89 81       	ldd	r24, Y+1	; 0x01
    93c6:	8f 5f       	subi	r24, 0xFF	; 255
    93c8:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    93ca:	89 81       	ldd	r24, Y+1	; 0x01
    93cc:	28 2f       	mov	r18, r24
    93ce:	30 e0       	ldi	r19, 0x00	; 0
    93d0:	80 91 66 50 	lds	r24, 0x5066
    93d4:	90 91 67 50 	lds	r25, 0x5067
    93d8:	28 17       	cp	r18, r24
    93da:	39 07       	cpc	r19, r25
    93dc:	e1 f5       	brne	.+120    	; 0x9456 <writeFile+0x420>
		j = 0; 
    93de:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    93e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    93e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    93e4:	ae 85       	ldd	r26, Y+14	; 0x0e
    93e6:	bf 85       	ldd	r27, Y+15	; 0x0f
    93e8:	88 8b       	std	Y+16, r24	; 0x10
    93ea:	99 8b       	std	Y+17, r25	; 0x11
    93ec:	aa 8b       	std	Y+18, r26	; 0x12
    93ee:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    93f0:	88 89       	ldd	r24, Y+16	; 0x10
    93f2:	99 89       	ldd	r25, Y+17	; 0x11
    93f4:	aa 89       	ldd	r26, Y+18	; 0x12
    93f6:	bb 89       	ldd	r27, Y+19	; 0x13
    93f8:	bc 01       	movw	r22, r24
    93fa:	cd 01       	movw	r24, r26
    93fc:	0e 94 f1 4b 	call	0x97e2	; 0x97e2 <searchNextFreeCluster>
    9400:	dc 01       	movw	r26, r24
    9402:	cb 01       	movw	r24, r22
    9404:	8c 87       	std	Y+12, r24	; 0x0c
    9406:	9d 87       	std	Y+13, r25	; 0x0d
    9408:	ae 87       	std	Y+14, r26	; 0x0e
    940a:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    940c:	8c 85       	ldd	r24, Y+12	; 0x0c
    940e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9410:	ae 85       	ldd	r26, Y+14	; 0x0e
    9412:	bf 85       	ldd	r27, Y+15	; 0x0f
    9414:	00 97       	sbiw	r24, 0x00	; 0
    9416:	a1 05       	cpc	r26, r1
    9418:	b1 05       	cpc	r27, r1
    941a:	11 f4       	brne	.+4      	; 0x9420 <writeFile+0x3ea>
		  //No free cluster!
		  return 2;
    941c:	82 e0       	ldi	r24, 0x02	; 2
    941e:	d7 c1       	rjmp	.+942    	; 0x97ce <writeFile+0x798>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    9420:	88 89       	ldd	r24, Y+16	; 0x10
    9422:	99 89       	ldd	r25, Y+17	; 0x11
    9424:	aa 89       	ldd	r26, Y+18	; 0x12
    9426:	bb 89       	ldd	r27, Y+19	; 0x13
    9428:	0c 85       	ldd	r16, Y+12	; 0x0c
    942a:	1d 85       	ldd	r17, Y+13	; 0x0d
    942c:	2e 85       	ldd	r18, Y+14	; 0x0e
    942e:	3f 85       	ldd	r19, Y+15	; 0x0f
    9430:	bc 01       	movw	r22, r24
    9432:	cd 01       	movw	r24, r26
    9434:	41 e0       	ldi	r20, 0x01	; 1
    9436:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    943a:	8c 85       	ldd	r24, Y+12	; 0x0c
    943c:	9d 85       	ldd	r25, Y+13	; 0x0d
    943e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9440:	bf 85       	ldd	r27, Y+15	; 0x0f
    9442:	bc 01       	movw	r22, r24
    9444:	cd 01       	movw	r24, r26
    9446:	41 e0       	ldi	r20, 0x01	; 1
    9448:	0f ef       	ldi	r16, 0xFF	; 255
    944a:	1f ef       	ldi	r17, 0xFF	; 255
    944c:	2f ef       	ldi	r18, 0xFF	; 255
    944e:	3f e0       	ldi	r19, 0x0F	; 15
    9450:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
    9454:	05 c0       	rjmp	.+10     	; 0x9460 <writeFile+0x42a>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    9456:	8a 85       	ldd	r24, Y+10	; 0x0a
    9458:	9b 85       	ldd	r25, Y+11	; 0x0b
    945a:	01 96       	adiw	r24, 0x01	; 1
    945c:	8a 87       	std	Y+10, r24	; 0x0a
    945e:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    9460:	2c 85       	ldd	r18, Y+12	; 0x0c
    9462:	3d 85       	ldd	r19, Y+13	; 0x0d
    9464:	4e 85       	ldd	r20, Y+14	; 0x0e
    9466:	5f 85       	ldd	r21, Y+15	; 0x0f
    9468:	82 e0       	ldi	r24, 0x02	; 2
    946a:	61 e0       	ldi	r22, 0x01	; 1
    946c:	0e 94 ab 43 	call	0x8756	; 0x8756 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    9470:	8c a9       	sts	0x4c, r24
    9472:	9d a9       	sts	0x4d, r25
    9474:	ae a9       	sts	0x4e, r26
    9476:	bf a9       	sts	0x4f, r27
    9478:	00 97       	sbiw	r24, 0x00	; 0
    947a:	a1 05       	cpc	r26, r1
    947c:	b1 05       	cpc	r27, r1
    947e:	09 f0       	breq	.+2      	; 0x9482 <writeFile+0x44c>
    9480:	2a cf       	rjmp	.-428    	; 0x92d6 <writeFile+0x2a0>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    9482:	8c 81       	ldd	r24, Y+4	; 0x04
    9484:	88 23       	and	r24, r24
    9486:	09 f4       	brne	.+2      	; 0x948a <writeFile+0x454>
    9488:	66 c0       	rjmp	.+204    	; 0x9556 <writeFile+0x520>
{
  SD_read_block (appendFileSector,SDBuffer);    
    948a:	80 91 d1 50 	lds	r24, 0x50D1
    948e:	90 91 d2 50 	lds	r25, 0x50D2
    9492:	a0 91 d3 50 	lds	r26, 0x50D3
    9496:	b0 91 d4 50 	lds	r27, 0x50D4
    949a:	25 ec       	ldi	r18, 0xC5	; 197
    949c:	31 e2       	ldi	r19, 0x21	; 33
    949e:	bc 01       	movw	r22, r24
    94a0:	cd 01       	movw	r24, r26
    94a2:	a9 01       	movw	r20, r18
    94a4:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    94a8:	80 91 c6 23 	lds	r24, 0x23C6
    94ac:	90 91 c7 23 	lds	r25, 0x23C7
    94b0:	a0 91 c8 23 	lds	r26, 0x23C8
    94b4:	b0 91 c9 23 	lds	r27, 0x23C9
    94b8:	8b 53       	subi	r24, 0x3B	; 59
    94ba:	9e 4d       	sbci	r25, 0xDE	; 222
    94bc:	8e a3       	lds	r24, 0x5e
    94be:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    94c0:	8e a1       	lds	r24, 0x4e
    94c2:	9f a1       	lds	r25, 0x4f
    94c4:	fc 01       	movw	r30, r24
    94c6:	12 8a       	std	Z+18, r1	; 0x12
    94c8:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    94ca:	20 91 3f 40 	lds	r18, 0x403F
    94ce:	30 91 40 40 	lds	r19, 0x4040
    94d2:	40 91 41 40 	lds	r20, 0x4041
    94d6:	50 91 42 40 	lds	r21, 0x4042
    94da:	8e a1       	lds	r24, 0x4e
    94dc:	9f a1       	lds	r25, 0x4f
    94de:	fc 01       	movw	r30, r24
    94e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    94e2:	95 8d       	ldd	r25, Z+29	; 0x1d
    94e4:	a6 8d       	ldd	r26, Z+30	; 0x1e
    94e6:	b7 8d       	ldd	r27, Z+31	; 0x1f
    94e8:	79 01       	movw	r14, r18
    94ea:	8a 01       	movw	r16, r20
    94ec:	e8 1a       	sub	r14, r24
    94ee:	f9 0a       	sbc	r15, r25
    94f0:	0a 0b       	sbc	r16, r26
    94f2:	1b 0b       	sbc	r17, r27
    94f4:	d8 01       	movw	r26, r16
    94f6:	c7 01       	movw	r24, r14
    94f8:	88 a7       	lds	r24, 0x78
    94fa:	99 a7       	lds	r25, 0x79
    94fc:	aa a7       	lds	r26, 0x7a
    94fe:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    9500:	80 91 3f 40 	lds	r24, 0x403F
    9504:	90 91 40 40 	lds	r25, 0x4040
    9508:	a0 91 41 40 	lds	r26, 0x4041
    950c:	b0 91 42 40 	lds	r27, 0x4042
    9510:	2e a1       	lds	r18, 0x4e
    9512:	3f a1       	lds	r19, 0x4f
    9514:	f9 01       	movw	r30, r18
    9516:	84 8f       	std	Z+28, r24	; 0x1c
    9518:	95 8f       	std	Z+29, r25	; 0x1d
    951a:	a6 8f       	std	Z+30, r26	; 0x1e
    951c:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    951e:	80 91 d1 50 	lds	r24, 0x50D1
    9522:	90 91 d2 50 	lds	r25, 0x50D2
    9526:	a0 91 d3 50 	lds	r26, 0x50D3
    952a:	b0 91 d4 50 	lds	r27, 0x50D4
    952e:	25 ec       	ldi	r18, 0xC5	; 197
    9530:	31 e2       	ldi	r19, 0x21	; 33
    9532:	bc 01       	movw	r22, r24
    9534:	cd 01       	movw	r24, r26
    9536:	a9 01       	movw	r20, r18
    9538:	20 e0       	ldi	r18, 0x00	; 0
    953a:	32 e0       	ldi	r19, 0x02	; 2
    953c:	0e 94 2d 50 	call	0xa05a	; 0xa05a <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    9540:	28 a5       	lds	r18, 0x68
    9542:	39 a5       	lds	r19, 0x69
    9544:	4a a5       	lds	r20, 0x6a
    9546:	5b a5       	lds	r21, 0x6b
    9548:	81 e0       	ldi	r24, 0x01	; 1
    954a:	ba 01       	movw	r22, r20
    954c:	a9 01       	movw	r20, r18
    954e:	0e 94 ca 4c 	call	0x9994	; 0x9994 <freeMemoryUpdate>

 //File appended!
  return 0;
    9552:	80 e0       	ldi	r24, 0x00	; 0
    9554:	3c c1       	rjmp	.+632    	; 0x97ce <writeFile+0x798>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9556:	80 91 4e 40 	lds	r24, 0x404E
    955a:	90 91 4f 40 	lds	r25, 0x404F
    955e:	a0 91 50 40 	lds	r26, 0x4050
    9562:	b0 91 51 40 	lds	r27, 0x4051
    9566:	88 8b       	std	Y+16, r24	; 0x10
    9568:	99 8b       	std	Y+17, r25	; 0x11
    956a:	aa 8b       	std	Y+18, r26	; 0x12
    956c:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    956e:	88 89       	ldd	r24, Y+16	; 0x10
    9570:	99 89       	ldd	r25, Y+17	; 0x11
    9572:	aa 89       	ldd	r26, Y+18	; 0x12
    9574:	bb 89       	ldd	r27, Y+19	; 0x13
    9576:	bc 01       	movw	r22, r24
    9578:	cd 01       	movw	r24, r26
    957a:	0e 94 cf 42 	call	0x859e	; 0x859e <getFirstSector>
    957e:	dc 01       	movw	r26, r24
    9580:	cb 01       	movw	r24, r22
    9582:	8c a7       	lds	r24, 0x7c
    9584:	9d a7       	lds	r25, 0x7d
    9586:	ae a7       	lds	r26, 0x7e
    9588:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    958a:	1d 82       	std	Y+5, r1	; 0x05
    958c:	ad c0       	rjmp	.+346    	; 0x96e8 <writeFile+0x6b2>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    958e:	8d 81       	ldd	r24, Y+5	; 0x05
    9590:	28 2f       	mov	r18, r24
    9592:	30 e0       	ldi	r19, 0x00	; 0
    9594:	40 e0       	ldi	r20, 0x00	; 0
    9596:	50 e0       	ldi	r21, 0x00	; 0
    9598:	8c a5       	lds	r24, 0x6c
    959a:	9d a5       	lds	r25, 0x6d
    959c:	ae a5       	lds	r26, 0x6e
    959e:	bf a5       	lds	r27, 0x6f
    95a0:	82 0f       	add	r24, r18
    95a2:	93 1f       	adc	r25, r19
    95a4:	a4 1f       	adc	r26, r20
    95a6:	b5 1f       	adc	r27, r21
    95a8:	25 ec       	ldi	r18, 0xC5	; 197
    95aa:	31 e2       	ldi	r19, 0x21	; 33
    95ac:	bc 01       	movw	r22, r24
    95ae:	cd 01       	movw	r24, r26
    95b0:	a9 01       	movw	r20, r18
    95b2:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    95b6:	18 a2       	lds	r17, 0x98
    95b8:	19 a2       	lds	r17, 0x99
    95ba:	89 c0       	rjmp	.+274    	; 0x96ce <writeFile+0x698>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    95bc:	88 a1       	lds	r24, 0x48
    95be:	99 a1       	lds	r25, 0x49
    95c0:	8b 53       	subi	r24, 0x3B	; 59
    95c2:	9e 4d       	sbci	r25, 0xDE	; 222
    95c4:	8e a3       	lds	r24, 0x5e
    95c6:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    95c8:	8a 81       	ldd	r24, Y+2	; 0x02
    95ca:	88 23       	and	r24, r24
    95cc:	11 f0       	breq	.+4      	; 0x95d2 <writeFile+0x59c>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    95ce:	80 e0       	ldi	r24, 0x00	; 0
    95d0:	fe c0       	rjmp	.+508    	; 0x97ce <writeFile+0x798>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    95d2:	8e a1       	lds	r24, 0x4e
    95d4:	9f a1       	lds	r25, 0x4f
    95d6:	fc 01       	movw	r30, r24
    95d8:	80 81       	ld	r24, Z
    95da:	88 23       	and	r24, r24
    95dc:	39 f0       	breq	.+14     	; 0x95ec <writeFile+0x5b6>
    95de:	8e a1       	lds	r24, 0x4e
    95e0:	9f a1       	lds	r25, 0x4f
    95e2:	fc 01       	movw	r30, r24
    95e4:	80 81       	ld	r24, Z
    95e6:	85 3e       	cpi	r24, 0xE5	; 229
    95e8:	09 f0       	breq	.+2      	; 0x95ec <writeFile+0x5b6>
    95ea:	6c c0       	rjmp	.+216    	; 0x96c4 <writeFile+0x68e>
		{
		  for(j=0; j<11; j++)
    95ec:	19 82       	std	Y+1, r1	; 0x01
    95ee:	13 c0       	rjmp	.+38     	; 0x9616 <writeFile+0x5e0>
  			dir->name[j] = Filename[j];
    95f0:	89 81       	ldd	r24, Y+1	; 0x01
    95f2:	88 2f       	mov	r24, r24
    95f4:	90 e0       	ldi	r25, 0x00	; 0
    95f6:	29 81       	ldd	r18, Y+1	; 0x01
    95f8:	22 2f       	mov	r18, r18
    95fa:	30 e0       	ldi	r19, 0x00	; 0
    95fc:	24 55       	subi	r18, 0x54	; 84
    95fe:	3f 4a       	sbci	r19, 0xAF	; 175
    9600:	f9 01       	movw	r30, r18
    9602:	40 81       	ld	r20, Z
    9604:	2e a1       	lds	r18, 0x4e
    9606:	3f a1       	lds	r19, 0x4f
    9608:	82 0f       	add	r24, r18
    960a:	93 1f       	adc	r25, r19
    960c:	fc 01       	movw	r30, r24
    960e:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    9610:	89 81       	ldd	r24, Y+1	; 0x01
    9612:	8f 5f       	subi	r24, 0xFF	; 255
    9614:	89 83       	std	Y+1, r24	; 0x01
    9616:	89 81       	ldd	r24, Y+1	; 0x01
    9618:	8b 30       	cpi	r24, 0x0B	; 11
    961a:	50 f3       	brcs	.-44     	; 0x95f0 <writeFile+0x5ba>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    961c:	8e a1       	lds	r24, 0x4e
    961e:	9f a1       	lds	r25, 0x4f
    9620:	20 e2       	ldi	r18, 0x20	; 32
    9622:	fc 01       	movw	r30, r24
    9624:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    9626:	8e a1       	lds	r24, 0x4e
    9628:	9f a1       	lds	r25, 0x4f
    962a:	fc 01       	movw	r30, r24
    962c:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    962e:	8e a1       	lds	r24, 0x4e
    9630:	9f a1       	lds	r25, 0x4f
    9632:	fc 01       	movw	r30, r24
    9634:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    9636:	8e a1       	lds	r24, 0x4e
    9638:	9f a1       	lds	r25, 0x4f
    963a:	fc 01       	movw	r30, r24
    963c:	12 8a       	std	Z+18, r1	; 0x12
    963e:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    9640:	8e a1       	lds	r24, 0x4e
    9642:	9f a1       	lds	r25, 0x4f
    9644:	2e 81       	ldd	r18, Y+6	; 0x06
    9646:	3f 81       	ldd	r19, Y+7	; 0x07
    9648:	fc 01       	movw	r30, r24
    964a:	24 8b       	std	Z+20, r18	; 0x14
    964c:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    964e:	8e a1       	lds	r24, 0x4e
    9650:	9f a1       	lds	r25, 0x4f
    9652:	28 85       	ldd	r18, Y+8	; 0x08
    9654:	39 85       	ldd	r19, Y+9	; 0x09
    9656:	fc 01       	movw	r30, r24
    9658:	22 8f       	std	Z+26, r18	; 0x1a
    965a:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    965c:	80 91 3f 40 	lds	r24, 0x403F
    9660:	90 91 40 40 	lds	r25, 0x4040
    9664:	a0 91 41 40 	lds	r26, 0x4041
    9668:	b0 91 42 40 	lds	r27, 0x4042
    966c:	2e a1       	lds	r18, 0x4e
    966e:	3f a1       	lds	r19, 0x4f
    9670:	f9 01       	movw	r30, r18
    9672:	84 8f       	std	Z+28, r24	; 0x1c
    9674:	95 8f       	std	Z+29, r25	; 0x1d
    9676:	a6 8f       	std	Z+30, r26	; 0x1e
    9678:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    967a:	8d 81       	ldd	r24, Y+5	; 0x05
    967c:	28 2f       	mov	r18, r24
    967e:	30 e0       	ldi	r19, 0x00	; 0
    9680:	40 e0       	ldi	r20, 0x00	; 0
    9682:	50 e0       	ldi	r21, 0x00	; 0
    9684:	8c a5       	lds	r24, 0x6c
    9686:	9d a5       	lds	r25, 0x6d
    9688:	ae a5       	lds	r26, 0x6e
    968a:	bf a5       	lds	r27, 0x6f
    968c:	82 0f       	add	r24, r18
    968e:	93 1f       	adc	r25, r19
    9690:	a4 1f       	adc	r26, r20
    9692:	b5 1f       	adc	r27, r21
    9694:	25 ec       	ldi	r18, 0xC5	; 197
    9696:	31 e2       	ldi	r19, 0x21	; 33
    9698:	bc 01       	movw	r22, r24
    969a:	cd 01       	movw	r24, r26
    969c:	a9 01       	movw	r20, r18
    969e:	20 e0       	ldi	r18, 0x00	; 0
    96a0:	32 e0       	ldi	r19, 0x02	; 2
    96a2:	0e 94 2d 50 	call	0xa05a	; 0xa05a <SD_write_block>
		  fileCreatedFlag = 1;
    96a6:	81 e0       	ldi	r24, 0x01	; 1
    96a8:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    96aa:	20 91 3f 40 	lds	r18, 0x403F
    96ae:	30 91 40 40 	lds	r19, 0x4040
    96b2:	40 91 41 40 	lds	r20, 0x4041
    96b6:	50 91 42 40 	lds	r21, 0x4042
    96ba:	81 e0       	ldi	r24, 0x01	; 1
    96bc:	ba 01       	movw	r22, r20
    96be:	a9 01       	movw	r20, r18
    96c0:	0e 94 ca 4c 	call	0x9994	; 0x9994 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    96c4:	88 a1       	lds	r24, 0x48
    96c6:	99 a1       	lds	r25, 0x49
    96c8:	80 96       	adiw	r24, 0x20	; 32
    96ca:	88 a3       	lds	r24, 0x58
    96cc:	99 a3       	lds	r25, 0x59
    96ce:	28 a1       	lds	r18, 0x48
    96d0:	39 a1       	lds	r19, 0x49
    96d2:	80 91 43 40 	lds	r24, 0x4043
    96d6:	90 91 44 40 	lds	r25, 0x4044
    96da:	28 17       	cp	r18, r24
    96dc:	39 07       	cpc	r19, r25
    96de:	08 f4       	brcc	.+2      	; 0x96e2 <writeFile+0x6ac>
    96e0:	6d cf       	rjmp	.-294    	; 0x95bc <writeFile+0x586>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    96e2:	8d 81       	ldd	r24, Y+5	; 0x05
    96e4:	8f 5f       	subi	r24, 0xFF	; 255
    96e6:	8d 83       	std	Y+5, r24	; 0x05
    96e8:	8d 81       	ldd	r24, Y+5	; 0x05
    96ea:	28 2f       	mov	r18, r24
    96ec:	30 e0       	ldi	r19, 0x00	; 0
    96ee:	80 91 66 50 	lds	r24, 0x5066
    96f2:	90 91 67 50 	lds	r25, 0x5067
    96f6:	28 17       	cp	r18, r24
    96f8:	39 07       	cpc	r19, r25
    96fa:	08 f4       	brcc	.+2      	; 0x96fe <writeFile+0x6c8>
    96fc:	48 cf       	rjmp	.-368    	; 0x958e <writeFile+0x558>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    96fe:	88 89       	ldd	r24, Y+16	; 0x10
    9700:	99 89       	ldd	r25, Y+17	; 0x11
    9702:	aa 89       	ldd	r26, Y+18	; 0x12
    9704:	bb 89       	ldd	r27, Y+19	; 0x13
    9706:	bc 01       	movw	r22, r24
    9708:	cd 01       	movw	r24, r26
    970a:	40 e0       	ldi	r20, 0x00	; 0
    970c:	00 e0       	ldi	r16, 0x00	; 0
    970e:	10 e0       	ldi	r17, 0x00	; 0
    9710:	98 01       	movw	r18, r16
    9712:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
    9716:	dc 01       	movw	r26, r24
    9718:	cb 01       	movw	r24, r22
    971a:	8c 87       	std	Y+12, r24	; 0x0c
    971c:	9d 87       	std	Y+13, r25	; 0x0d
    971e:	ae 87       	std	Y+14, r26	; 0x0e
    9720:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    9722:	8c 85       	ldd	r24, Y+12	; 0x0c
    9724:	9d 85       	ldd	r25, Y+13	; 0x0d
    9726:	ae 85       	ldd	r26, Y+14	; 0x0e
    9728:	bf 85       	ldd	r27, Y+15	; 0x0f
    972a:	87 3f       	cpi	r24, 0xF7	; 247
    972c:	ff ef       	ldi	r31, 0xFF	; 255
    972e:	9f 07       	cpc	r25, r31
    9730:	ff ef       	ldi	r31, 0xFF	; 255
    9732:	af 07       	cpc	r26, r31
    9734:	ff e0       	ldi	r31, 0x0F	; 15
    9736:	bf 07       	cpc	r27, r31
    9738:	b8 f1       	brcs	.+110    	; 0x97a8 <writeFile+0x772>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    973a:	8c 85       	ldd	r24, Y+12	; 0x0c
    973c:	9d 85       	ldd	r25, Y+13	; 0x0d
    973e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9740:	bf 85       	ldd	r27, Y+15	; 0x0f
    9742:	8f 3f       	cpi	r24, 0xFF	; 255
    9744:	0f ef       	ldi	r16, 0xFF	; 255
    9746:	90 07       	cpc	r25, r16
    9748:	0f ef       	ldi	r16, 0xFF	; 255
    974a:	a0 07       	cpc	r26, r16
    974c:	0f e0       	ldi	r16, 0x0F	; 15
    974e:	b0 07       	cpc	r27, r16
    9750:	49 f5       	brne	.+82     	; 0x97a4 <writeFile+0x76e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9752:	88 89       	ldd	r24, Y+16	; 0x10
    9754:	99 89       	ldd	r25, Y+17	; 0x11
    9756:	aa 89       	ldd	r26, Y+18	; 0x12
    9758:	bb 89       	ldd	r27, Y+19	; 0x13
    975a:	bc 01       	movw	r22, r24
    975c:	cd 01       	movw	r24, r26
    975e:	0e 94 f1 4b 	call	0x97e2	; 0x97e2 <searchNextFreeCluster>
    9762:	dc 01       	movw	r26, r24
    9764:	cb 01       	movw	r24, r22
    9766:	8c 87       	std	Y+12, r24	; 0x0c
    9768:	9d 87       	std	Y+13, r25	; 0x0d
    976a:	ae 87       	std	Y+14, r26	; 0x0e
    976c:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    976e:	88 89       	ldd	r24, Y+16	; 0x10
    9770:	99 89       	ldd	r25, Y+17	; 0x11
    9772:	aa 89       	ldd	r26, Y+18	; 0x12
    9774:	bb 89       	ldd	r27, Y+19	; 0x13
    9776:	0c 85       	ldd	r16, Y+12	; 0x0c
    9778:	1d 85       	ldd	r17, Y+13	; 0x0d
    977a:	2e 85       	ldd	r18, Y+14	; 0x0e
    977c:	3f 85       	ldd	r19, Y+15	; 0x0f
    977e:	bc 01       	movw	r22, r24
    9780:	cd 01       	movw	r24, r26
    9782:	41 e0       	ldi	r20, 0x01	; 1
    9784:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    9788:	8c 85       	ldd	r24, Y+12	; 0x0c
    978a:	9d 85       	ldd	r25, Y+13	; 0x0d
    978c:	ae 85       	ldd	r26, Y+14	; 0x0e
    978e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9790:	bc 01       	movw	r22, r24
    9792:	cd 01       	movw	r24, r26
    9794:	41 e0       	ldi	r20, 0x01	; 1
    9796:	0f ef       	ldi	r16, 0xFF	; 255
    9798:	1f ef       	ldi	r17, 0xFF	; 255
    979a:	2f ef       	ldi	r18, 0xFF	; 255
    979c:	3f e0       	ldi	r19, 0x0F	; 15
    979e:	0e 94 01 43 	call	0x8602	; 0x8602 <getSetNextCluster>
    97a2:	02 c0       	rjmp	.+4      	; 0x97a8 <writeFile+0x772>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    97a4:	83 e0       	ldi	r24, 0x03	; 3
    97a6:	13 c0       	rjmp	.+38     	; 0x97ce <writeFile+0x798>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    97a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    97aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    97ac:	ae 85       	ldd	r26, Y+14	; 0x0e
    97ae:	bf 85       	ldd	r27, Y+15	; 0x0f
    97b0:	00 97       	sbiw	r24, 0x00	; 0
    97b2:	a1 05       	cpc	r26, r1
    97b4:	b1 05       	cpc	r27, r1
    97b6:	11 f4       	brne	.+4      	; 0x97bc <writeFile+0x786>
	   return 4;
    97b8:	84 e0       	ldi	r24, 0x04	; 4
    97ba:	09 c0       	rjmp	.+18     	; 0x97ce <writeFile+0x798>
	}
   
   prevCluster = cluster;
    97bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    97be:	9d 85       	ldd	r25, Y+13	; 0x0d
    97c0:	ae 85       	ldd	r26, Y+14	; 0x0e
    97c2:	bf 85       	ldd	r27, Y+15	; 0x0f
    97c4:	88 8b       	std	Y+16, r24	; 0x10
    97c6:	99 8b       	std	Y+17, r25	; 0x11
    97c8:	aa 8b       	std	Y+18, r26	; 0x12
    97ca:	bb 8b       	std	Y+19, r27	; 0x13
 }
    97cc:	d0 ce       	rjmp	.-608    	; 0x956e <writeFile+0x538>
 
 return 0;
}
    97ce:	e7 96       	adiw	r28, 0x37	; 55
    97d0:	cd bf       	out	0x3d, r28	; 61
    97d2:	de bf       	out	0x3e, r29	; 62
    97d4:	df 91       	pop	r29
    97d6:	cf 91       	pop	r28
    97d8:	1f 91       	pop	r17
    97da:	0f 91       	pop	r16
    97dc:	ff 90       	pop	r15
    97de:	ef 90       	pop	r14
    97e0:	08 95       	ret

000097e2 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    97e2:	ef 92       	push	r14
    97e4:	ff 92       	push	r15
    97e6:	0f 93       	push	r16
    97e8:	1f 93       	push	r17
    97ea:	cf 93       	push	r28
    97ec:	df 93       	push	r29
    97ee:	cd b7       	in	r28, 0x3d	; 61
    97f0:	de b7       	in	r29, 0x3e	; 62
    97f2:	2f 97       	sbiw	r28, 0x0f	; 15
    97f4:	cd bf       	out	0x3d, r28	; 61
    97f6:	de bf       	out	0x3e, r29	; 62
    97f8:	6c 87       	std	Y+12, r22	; 0x0c
    97fa:	7d 87       	std	Y+13, r23	; 0x0d
    97fc:	8e 87       	std	Y+14, r24	; 0x0e
    97fe:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    9800:	8c 85       	ldd	r24, Y+12	; 0x0c
    9802:	9d 85       	ldd	r25, Y+13	; 0x0d
    9804:	ae 85       	ldd	r26, Y+14	; 0x0e
    9806:	bf 85       	ldd	r27, Y+15	; 0x0f
    9808:	80 78       	andi	r24, 0x80	; 128
    980a:	8c 87       	std	Y+12, r24	; 0x0c
    980c:	9d 87       	std	Y+13, r25	; 0x0d
    980e:	ae 87       	std	Y+14, r26	; 0x0e
    9810:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9812:	8c 85       	ldd	r24, Y+12	; 0x0c
    9814:	9d 85       	ldd	r25, Y+13	; 0x0d
    9816:	ae 85       	ldd	r26, Y+14	; 0x0e
    9818:	bf 85       	ldd	r27, Y+15	; 0x0f
    981a:	89 83       	std	Y+1, r24	; 0x01
    981c:	9a 83       	std	Y+2, r25	; 0x02
    981e:	ab 83       	std	Y+3, r26	; 0x03
    9820:	bc 83       	std	Y+4, r27	; 0x04
    9822:	7a c0       	rjmp	.+244    	; 0x9918 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9824:	80 91 6e 50 	lds	r24, 0x506E
    9828:	90 91 6f 50 	lds	r25, 0x506F
    982c:	9c 01       	movw	r18, r24
    982e:	40 e0       	ldi	r20, 0x00	; 0
    9830:	50 e0       	ldi	r21, 0x00	; 0
    9832:	80 91 68 50 	lds	r24, 0x5068
    9836:	90 91 69 50 	lds	r25, 0x5069
    983a:	a0 91 6a 50 	lds	r26, 0x506A
    983e:	b0 91 6b 50 	lds	r27, 0x506B
    9842:	79 01       	movw	r14, r18
    9844:	8a 01       	movw	r16, r20
    9846:	e8 0e       	add	r14, r24
    9848:	f9 1e       	adc	r15, r25
    984a:	0a 1f       	adc	r16, r26
    984c:	1b 1f       	adc	r17, r27
    984e:	89 81       	ldd	r24, Y+1	; 0x01
    9850:	9a 81       	ldd	r25, Y+2	; 0x02
    9852:	ab 81       	ldd	r26, Y+3	; 0x03
    9854:	bc 81       	ldd	r27, Y+4	; 0x04
    9856:	88 0f       	add	r24, r24
    9858:	99 1f       	adc	r25, r25
    985a:	aa 1f       	adc	r26, r26
    985c:	bb 1f       	adc	r27, r27
    985e:	88 0f       	add	r24, r24
    9860:	99 1f       	adc	r25, r25
    9862:	aa 1f       	adc	r26, r26
    9864:	bb 1f       	adc	r27, r27
    9866:	20 91 43 40 	lds	r18, 0x4043
    986a:	30 91 44 40 	lds	r19, 0x4044
    986e:	99 01       	movw	r18, r18
    9870:	40 e0       	ldi	r20, 0x00	; 0
    9872:	50 e0       	ldi	r21, 0x00	; 0
    9874:	bc 01       	movw	r22, r24
    9876:	cd 01       	movw	r24, r26
    9878:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    987c:	da 01       	movw	r26, r20
    987e:	c9 01       	movw	r24, r18
    9880:	8e 0d       	add	r24, r14
    9882:	9f 1d       	adc	r25, r15
    9884:	a0 1f       	adc	r26, r16
    9886:	b1 1f       	adc	r27, r17
    9888:	8e 83       	std	Y+6, r24	; 0x06
    988a:	9f 83       	std	Y+7, r25	; 0x07
    988c:	a8 87       	std	Y+8, r26	; 0x08
    988e:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    9890:	8e 81       	ldd	r24, Y+6	; 0x06
    9892:	9f 81       	ldd	r25, Y+7	; 0x07
    9894:	a8 85       	ldd	r26, Y+8	; 0x08
    9896:	b9 85       	ldd	r27, Y+9	; 0x09
    9898:	25 ec       	ldi	r18, 0xC5	; 197
    989a:	31 e2       	ldi	r19, 0x21	; 33
    989c:	bc 01       	movw	r22, r24
    989e:	cd 01       	movw	r24, r26
    98a0:	a9 01       	movw	r20, r18
    98a2:	0e 94 fb 50 	call	0xa1f6	; 0xa1f6 <SD_read_block>
      for(i=0; i<128; i++)
    98a6:	1d 82       	std	Y+5, r1	; 0x05
    98a8:	28 c0       	rjmp	.+80     	; 0x98fa <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    98aa:	8d 81       	ldd	r24, Y+5	; 0x05
    98ac:	88 2f       	mov	r24, r24
    98ae:	90 e0       	ldi	r25, 0x00	; 0
    98b0:	88 0f       	add	r24, r24
    98b2:	99 1f       	adc	r25, r25
    98b4:	88 0f       	add	r24, r24
    98b6:	99 1f       	adc	r25, r25
    98b8:	8b 53       	subi	r24, 0x3B	; 59
    98ba:	9e 4d       	sbci	r25, 0xDE	; 222
    98bc:	8a 87       	std	Y+10, r24	; 0x0a
    98be:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    98c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    98c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    98c4:	fc 01       	movw	r30, r24
    98c6:	80 81       	ld	r24, Z
    98c8:	91 81       	ldd	r25, Z+1	; 0x01
    98ca:	a2 81       	ldd	r26, Z+2	; 0x02
    98cc:	b3 81       	ldd	r27, Z+3	; 0x03
    98ce:	bf 70       	andi	r27, 0x0F	; 15
    98d0:	00 97       	sbiw	r24, 0x00	; 0
    98d2:	a1 05       	cpc	r26, r1
    98d4:	b1 05       	cpc	r27, r1
    98d6:	71 f4       	brne	.+28     	; 0x98f4 <searchNextFreeCluster+0x112>
            return(cluster+i);
    98d8:	8d 81       	ldd	r24, Y+5	; 0x05
    98da:	28 2f       	mov	r18, r24
    98dc:	30 e0       	ldi	r19, 0x00	; 0
    98de:	40 e0       	ldi	r20, 0x00	; 0
    98e0:	50 e0       	ldi	r21, 0x00	; 0
    98e2:	89 81       	ldd	r24, Y+1	; 0x01
    98e4:	9a 81       	ldd	r25, Y+2	; 0x02
    98e6:	ab 81       	ldd	r26, Y+3	; 0x03
    98e8:	bc 81       	ldd	r27, Y+4	; 0x04
    98ea:	82 0f       	add	r24, r18
    98ec:	93 1f       	adc	r25, r19
    98ee:	a4 1f       	adc	r26, r20
    98f0:	b5 1f       	adc	r27, r21
    98f2:	27 c0       	rjmp	.+78     	; 0x9942 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    98f4:	8d 81       	ldd	r24, Y+5	; 0x05
    98f6:	8f 5f       	subi	r24, 0xFF	; 255
    98f8:	8d 83       	std	Y+5, r24	; 0x05
    98fa:	8d 81       	ldd	r24, Y+5	; 0x05
    98fc:	88 23       	and	r24, r24
    98fe:	ac f6       	brge	.-86     	; 0x98aa <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9900:	89 81       	ldd	r24, Y+1	; 0x01
    9902:	9a 81       	ldd	r25, Y+2	; 0x02
    9904:	ab 81       	ldd	r26, Y+3	; 0x03
    9906:	bc 81       	ldd	r27, Y+4	; 0x04
    9908:	80 58       	subi	r24, 0x80	; 128
    990a:	9f 4f       	sbci	r25, 0xFF	; 255
    990c:	af 4f       	sbci	r26, 0xFF	; 255
    990e:	bf 4f       	sbci	r27, 0xFF	; 255
    9910:	89 83       	std	Y+1, r24	; 0x01
    9912:	9a 83       	std	Y+2, r25	; 0x02
    9914:	ab 83       	std	Y+3, r26	; 0x03
    9916:	bc 83       	std	Y+4, r27	; 0x04
    9918:	80 91 48 40 	lds	r24, 0x4048
    991c:	90 91 49 40 	lds	r25, 0x4049
    9920:	a0 91 4a 40 	lds	r26, 0x404A
    9924:	b0 91 4b 40 	lds	r27, 0x404B
    9928:	29 81       	ldd	r18, Y+1	; 0x01
    992a:	3a 81       	ldd	r19, Y+2	; 0x02
    992c:	4b 81       	ldd	r20, Y+3	; 0x03
    992e:	5c 81       	ldd	r21, Y+4	; 0x04
    9930:	28 17       	cp	r18, r24
    9932:	39 07       	cpc	r19, r25
    9934:	4a 07       	cpc	r20, r26
    9936:	5b 07       	cpc	r21, r27
    9938:	08 f4       	brcc	.+2      	; 0x993c <searchNextFreeCluster+0x15a>
    993a:	74 cf       	rjmp	.-280    	; 0x9824 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    993c:	80 e0       	ldi	r24, 0x00	; 0
    993e:	90 e0       	ldi	r25, 0x00	; 0
    9940:	dc 01       	movw	r26, r24
}
    9942:	bc 01       	movw	r22, r24
    9944:	cd 01       	movw	r24, r26
    9946:	2f 96       	adiw	r28, 0x0f	; 15
    9948:	cd bf       	out	0x3d, r28	; 61
    994a:	de bf       	out	0x3e, r29	; 62
    994c:	df 91       	pop	r29
    994e:	cf 91       	pop	r28
    9950:	1f 91       	pop	r17
    9952:	0f 91       	pop	r16
    9954:	ff 90       	pop	r15
    9956:	ef 90       	pop	r14
    9958:	08 95       	ret

0000995a <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    995a:	cf 93       	push	r28
    995c:	df 93       	push	r29
    995e:	00 d0       	rcall	.+0      	; 0x9960 <deleteFile+0x6>
    9960:	cd b7       	in	r28, 0x3d	; 61
    9962:	de b7       	in	r29, 0x3e	; 62
    9964:	8a 83       	std	Y+2, r24	; 0x02
    9966:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9968:	8a 81       	ldd	r24, Y+2	; 0x02
    996a:	9b 81       	ldd	r25, Y+3	; 0x03
    996c:	0e 94 e5 46 	call	0x8dca	; 0x8dca <convertFileName>
    9970:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9972:	89 81       	ldd	r24, Y+1	; 0x01
    9974:	88 23       	and	r24, r24
    9976:	39 f4       	brne	.+14     	; 0x9986 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9978:	2c ea       	ldi	r18, 0xAC	; 172
    997a:	30 e5       	ldi	r19, 0x50	; 80
    997c:	82 e0       	ldi	r24, 0x02	; 2
    997e:	b9 01       	movw	r22, r18
    9980:	0e 94 5c 44 	call	0x88b8	; 0x88b8 <findFiles>
    9984:	01 c0       	rjmp	.+2      	; 0x9988 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9986:	00 00       	nop

  findFiles (DELETE, Filename);
}
    9988:	23 96       	adiw	r28, 0x03	; 3
    998a:	cd bf       	out	0x3d, r28	; 61
    998c:	de bf       	out	0x3e, r29	; 62
    998e:	df 91       	pop	r29
    9990:	cf 91       	pop	r28
    9992:	08 95       	ret

00009994 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9994:	ef 92       	push	r14
    9996:	ff 92       	push	r15
    9998:	0f 93       	push	r16
    999a:	1f 93       	push	r17
    999c:	cf 93       	push	r28
    999e:	df 93       	push	r29
    99a0:	cd b7       	in	r28, 0x3d	; 61
    99a2:	de b7       	in	r29, 0x3e	; 62
    99a4:	29 97       	sbiw	r28, 0x09	; 9
    99a6:	cd bf       	out	0x3d, r28	; 61
    99a8:	de bf       	out	0x3e, r29	; 62
    99aa:	8d 83       	std	Y+5, r24	; 0x05
    99ac:	4e 83       	std	Y+6, r20	; 0x06
    99ae:	5f 83       	std	Y+7, r21	; 0x07
    99b0:	68 87       	std	Y+8, r22	; 0x08
    99b2:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    99b4:	8e 81       	ldd	r24, Y+6	; 0x06
    99b6:	9f 81       	ldd	r25, Y+7	; 0x07
    99b8:	a8 85       	ldd	r26, Y+8	; 0x08
    99ba:	b9 85       	ldd	r27, Y+9	; 0x09
    99bc:	91 70       	andi	r25, 0x01	; 1
    99be:	a0 70       	andi	r26, 0x00	; 0
    99c0:	b0 70       	andi	r27, 0x00	; 0
    99c2:	00 97       	sbiw	r24, 0x00	; 0
    99c4:	a1 05       	cpc	r26, r1
    99c6:	b1 05       	cpc	r27, r1
    99c8:	91 f4       	brne	.+36     	; 0x99ee <freeMemoryUpdate+0x5a>
    99ca:	8e 81       	ldd	r24, Y+6	; 0x06
    99cc:	9f 81       	ldd	r25, Y+7	; 0x07
    99ce:	a8 85       	ldd	r26, Y+8	; 0x08
    99d0:	b9 85       	ldd	r27, Y+9	; 0x09
    99d2:	07 2e       	mov	r0, r23
    99d4:	79 e0       	ldi	r23, 0x09	; 9
    99d6:	b6 95       	lsr	r27
    99d8:	a7 95       	ror	r26
    99da:	97 95       	ror	r25
    99dc:	87 95       	ror	r24
    99de:	7a 95       	dec	r23
    99e0:	d1 f7       	brne	.-12     	; 0x99d6 <freeMemoryUpdate+0x42>
    99e2:	70 2d       	mov	r23, r0
    99e4:	8e 83       	std	Y+6, r24	; 0x06
    99e6:	9f 83       	std	Y+7, r25	; 0x07
    99e8:	a8 87       	std	Y+8, r26	; 0x08
    99ea:	b9 87       	std	Y+9, r27	; 0x09
    99ec:	14 c0       	rjmp	.+40     	; 0x9a16 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    99ee:	8e 81       	ldd	r24, Y+6	; 0x06
    99f0:	9f 81       	ldd	r25, Y+7	; 0x07
    99f2:	a8 85       	ldd	r26, Y+8	; 0x08
    99f4:	b9 85       	ldd	r27, Y+9	; 0x09
    99f6:	07 2e       	mov	r0, r23
    99f8:	79 e0       	ldi	r23, 0x09	; 9
    99fa:	b6 95       	lsr	r27
    99fc:	a7 95       	ror	r26
    99fe:	97 95       	ror	r25
    9a00:	87 95       	ror	r24
    9a02:	7a 95       	dec	r23
    9a04:	d1 f7       	brne	.-12     	; 0x99fa <freeMemoryUpdate+0x66>
    9a06:	70 2d       	mov	r23, r0
    9a08:	01 96       	adiw	r24, 0x01	; 1
    9a0a:	a1 1d       	adc	r26, r1
    9a0c:	b1 1d       	adc	r27, r1
    9a0e:	8e 83       	std	Y+6, r24	; 0x06
    9a10:	9f 83       	std	Y+7, r25	; 0x07
    9a12:	a8 87       	std	Y+8, r26	; 0x08
    9a14:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9a16:	8e 81       	ldd	r24, Y+6	; 0x06
    9a18:	9f 81       	ldd	r25, Y+7	; 0x07
    9a1a:	a8 85       	ldd	r26, Y+8	; 0x08
    9a1c:	b9 85       	ldd	r27, Y+9	; 0x09
    9a1e:	87 70       	andi	r24, 0x07	; 7
    9a20:	90 70       	andi	r25, 0x00	; 0
    9a22:	a0 70       	andi	r26, 0x00	; 0
    9a24:	b0 70       	andi	r27, 0x00	; 0
    9a26:	00 97       	sbiw	r24, 0x00	; 0
    9a28:	a1 05       	cpc	r26, r1
    9a2a:	b1 05       	cpc	r27, r1
    9a2c:	89 f4       	brne	.+34     	; 0x9a50 <freeMemoryUpdate+0xbc>
    9a2e:	8e 81       	ldd	r24, Y+6	; 0x06
    9a30:	9f 81       	ldd	r25, Y+7	; 0x07
    9a32:	a8 85       	ldd	r26, Y+8	; 0x08
    9a34:	b9 85       	ldd	r27, Y+9	; 0x09
    9a36:	68 94       	set
    9a38:	12 f8       	bld	r1, 2
    9a3a:	b6 95       	lsr	r27
    9a3c:	a7 95       	ror	r26
    9a3e:	97 95       	ror	r25
    9a40:	87 95       	ror	r24
    9a42:	16 94       	lsr	r1
    9a44:	d1 f7       	brne	.-12     	; 0x9a3a <freeMemoryUpdate+0xa6>
    9a46:	8e 83       	std	Y+6, r24	; 0x06
    9a48:	9f 83       	std	Y+7, r25	; 0x07
    9a4a:	a8 87       	std	Y+8, r26	; 0x08
    9a4c:	b9 87       	std	Y+9, r27	; 0x09
    9a4e:	13 c0       	rjmp	.+38     	; 0x9a76 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    9a50:	8e 81       	ldd	r24, Y+6	; 0x06
    9a52:	9f 81       	ldd	r25, Y+7	; 0x07
    9a54:	a8 85       	ldd	r26, Y+8	; 0x08
    9a56:	b9 85       	ldd	r27, Y+9	; 0x09
    9a58:	68 94       	set
    9a5a:	12 f8       	bld	r1, 2
    9a5c:	b6 95       	lsr	r27
    9a5e:	a7 95       	ror	r26
    9a60:	97 95       	ror	r25
    9a62:	87 95       	ror	r24
    9a64:	16 94       	lsr	r1
    9a66:	d1 f7       	brne	.-12     	; 0x9a5c <freeMemoryUpdate+0xc8>
    9a68:	01 96       	adiw	r24, 0x01	; 1
    9a6a:	a1 1d       	adc	r26, r1
    9a6c:	b1 1d       	adc	r27, r1
    9a6e:	8e 83       	std	Y+6, r24	; 0x06
    9a70:	9f 83       	std	Y+7, r25	; 0x07
    9a72:	a8 87       	std	Y+8, r26	; 0x08
    9a74:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9a76:	80 91 cf 50 	lds	r24, 0x50CF
    9a7a:	88 23       	and	r24, r24
    9a7c:	e9 f1       	breq	.+122    	; 0x9af8 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    9a7e:	81 e0       	ldi	r24, 0x01	; 1
    9a80:	60 e0       	ldi	r22, 0x00	; 0
    9a82:	20 e0       	ldi	r18, 0x00	; 0
    9a84:	30 e0       	ldi	r19, 0x00	; 0
    9a86:	a9 01       	movw	r20, r18
    9a88:	0e 94 ab 43 	call	0x8756	; 0x8756 <getSetFreeCluster>
    9a8c:	dc 01       	movw	r26, r24
    9a8e:	cb 01       	movw	r24, r22
    9a90:	89 83       	std	Y+1, r24	; 0x01
    9a92:	9a 83       	std	Y+2, r25	; 0x02
    9a94:	ab 83       	std	Y+3, r26	; 0x03
    9a96:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9a98:	8d 81       	ldd	r24, Y+5	; 0x05
    9a9a:	88 23       	and	r24, r24
    9a9c:	89 f4       	brne	.+34     	; 0x9ac0 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    9a9e:	29 81       	ldd	r18, Y+1	; 0x01
    9aa0:	3a 81       	ldd	r19, Y+2	; 0x02
    9aa2:	4b 81       	ldd	r20, Y+3	; 0x03
    9aa4:	5c 81       	ldd	r21, Y+4	; 0x04
    9aa6:	8e 81       	ldd	r24, Y+6	; 0x06
    9aa8:	9f 81       	ldd	r25, Y+7	; 0x07
    9aaa:	a8 85       	ldd	r26, Y+8	; 0x08
    9aac:	b9 85       	ldd	r27, Y+9	; 0x09
    9aae:	82 0f       	add	r24, r18
    9ab0:	93 1f       	adc	r25, r19
    9ab2:	a4 1f       	adc	r26, r20
    9ab4:	b5 1f       	adc	r27, r21
    9ab6:	89 83       	std	Y+1, r24	; 0x01
    9ab8:	9a 83       	std	Y+2, r25	; 0x02
    9aba:	ab 83       	std	Y+3, r26	; 0x03
    9abc:	bc 83       	std	Y+4, r27	; 0x04
    9abe:	14 c0       	rjmp	.+40     	; 0x9ae8 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    9ac0:	29 81       	ldd	r18, Y+1	; 0x01
    9ac2:	3a 81       	ldd	r19, Y+2	; 0x02
    9ac4:	4b 81       	ldd	r20, Y+3	; 0x03
    9ac6:	5c 81       	ldd	r21, Y+4	; 0x04
    9ac8:	8e 81       	ldd	r24, Y+6	; 0x06
    9aca:	9f 81       	ldd	r25, Y+7	; 0x07
    9acc:	a8 85       	ldd	r26, Y+8	; 0x08
    9ace:	b9 85       	ldd	r27, Y+9	; 0x09
    9ad0:	79 01       	movw	r14, r18
    9ad2:	8a 01       	movw	r16, r20
    9ad4:	e8 1a       	sub	r14, r24
    9ad6:	f9 0a       	sbc	r15, r25
    9ad8:	0a 0b       	sbc	r16, r26
    9ada:	1b 0b       	sbc	r17, r27
    9adc:	d8 01       	movw	r26, r16
    9ade:	c7 01       	movw	r24, r14
    9ae0:	89 83       	std	Y+1, r24	; 0x01
    9ae2:	9a 83       	std	Y+2, r25	; 0x02
    9ae4:	ab 83       	std	Y+3, r26	; 0x03
    9ae6:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9ae8:	29 81       	ldd	r18, Y+1	; 0x01
    9aea:	3a 81       	ldd	r19, Y+2	; 0x02
    9aec:	4b 81       	ldd	r20, Y+3	; 0x03
    9aee:	5c 81       	ldd	r21, Y+4	; 0x04
    9af0:	81 e0       	ldi	r24, 0x01	; 1
    9af2:	61 e0       	ldi	r22, 0x01	; 1
    9af4:	0e 94 ab 43 	call	0x8756	; 0x8756 <getSetFreeCluster>
  }
}
    9af8:	29 96       	adiw	r28, 0x09	; 9
    9afa:	cd bf       	out	0x3d, r28	; 61
    9afc:	de bf       	out	0x3e, r29	; 62
    9afe:	df 91       	pop	r29
    9b00:	cf 91       	pop	r28
    9b02:	1f 91       	pop	r17
    9b04:	0f 91       	pop	r16
    9b06:	ff 90       	pop	r15
    9b08:	ef 90       	pop	r14
    9b0a:	08 95       	ret

00009b0c <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    9b0c:	0f 93       	push	r16
    9b0e:	1f 93       	push	r17
    9b10:	cf 93       	push	r28
    9b12:	df 93       	push	r29
    9b14:	cd b7       	in	r28, 0x3d	; 61
    9b16:	de b7       	in	r29, 0x3e	; 62
    9b18:	a9 97       	sbiw	r28, 0x29	; 41
    9b1a:	cd bf       	out	0x3d, r28	; 61
    9b1c:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    9b1e:	81 e0       	ldi	r24, 0x01	; 1
    9b20:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9b24:	81 e0       	ldi	r24, 0x01	; 1
    9b26:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <Ext1Power>
    9b2a:	80 e0       	ldi	r24, 0x00	; 0
    9b2c:	90 e0       	ldi	r25, 0x00	; 0
    9b2e:	a8 ec       	ldi	r26, 0xC8	; 200
    9b30:	b2 e4       	ldi	r27, 0x42	; 66
    9b32:	8e 87       	std	Y+14, r24	; 0x0e
    9b34:	9f 87       	std	Y+15, r25	; 0x0f
    9b36:	a8 8b       	std	Y+16, r26	; 0x10
    9b38:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9b3a:	6e 85       	ldd	r22, Y+14	; 0x0e
    9b3c:	7f 85       	ldd	r23, Y+15	; 0x0f
    9b3e:	88 89       	ldd	r24, Y+16	; 0x10
    9b40:	99 89       	ldd	r25, Y+17	; 0x11
    9b42:	20 e0       	ldi	r18, 0x00	; 0
    9b44:	30 e0       	ldi	r19, 0x00	; 0
    9b46:	4a ef       	ldi	r20, 0xFA	; 250
    9b48:	55 e4       	ldi	r21, 0x45	; 69
    9b4a:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    9b4e:	dc 01       	movw	r26, r24
    9b50:	cb 01       	movw	r24, r22
    9b52:	8a 8b       	std	Y+18, r24	; 0x12
    9b54:	9b 8b       	std	Y+19, r25	; 0x13
    9b56:	ac 8b       	std	Y+20, r26	; 0x14
    9b58:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9b5a:	11 e0       	ldi	r17, 0x01	; 1
    9b5c:	6a 89       	ldd	r22, Y+18	; 0x12
    9b5e:	7b 89       	ldd	r23, Y+19	; 0x13
    9b60:	8c 89       	ldd	r24, Y+20	; 0x14
    9b62:	9d 89       	ldd	r25, Y+21	; 0x15
    9b64:	20 e0       	ldi	r18, 0x00	; 0
    9b66:	30 e0       	ldi	r19, 0x00	; 0
    9b68:	40 e8       	ldi	r20, 0x80	; 128
    9b6a:	5f e3       	ldi	r21, 0x3F	; 63
    9b6c:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    9b70:	88 23       	and	r24, r24
    9b72:	0c f0       	brlt	.+2      	; 0x9b76 <SD_init+0x6a>
    9b74:	10 e0       	ldi	r17, 0x00	; 0
    9b76:	11 23       	and	r17, r17
    9b78:	29 f0       	breq	.+10     	; 0x9b84 <SD_init+0x78>
		__ticks = 1;
    9b7a:	81 e0       	ldi	r24, 0x01	; 1
    9b7c:	90 e0       	ldi	r25, 0x00	; 0
    9b7e:	8e 8b       	std	Y+22, r24	; 0x16
    9b80:	9f 8b       	std	Y+23, r25	; 0x17
    9b82:	46 c0       	rjmp	.+140    	; 0x9c10 <SD_init+0x104>
	else if (__tmp > 65535)
    9b84:	11 e0       	ldi	r17, 0x01	; 1
    9b86:	6a 89       	ldd	r22, Y+18	; 0x12
    9b88:	7b 89       	ldd	r23, Y+19	; 0x13
    9b8a:	8c 89       	ldd	r24, Y+20	; 0x14
    9b8c:	9d 89       	ldd	r25, Y+21	; 0x15
    9b8e:	20 e0       	ldi	r18, 0x00	; 0
    9b90:	3f ef       	ldi	r19, 0xFF	; 255
    9b92:	4f e7       	ldi	r20, 0x7F	; 127
    9b94:	57 e4       	ldi	r21, 0x47	; 71
    9b96:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    9b9a:	18 16       	cp	r1, r24
    9b9c:	0c f0       	brlt	.+2      	; 0x9ba0 <SD_init+0x94>
    9b9e:	10 e0       	ldi	r17, 0x00	; 0
    9ba0:	11 23       	and	r17, r17
    9ba2:	61 f1       	breq	.+88     	; 0x9bfc <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9ba4:	6e 85       	ldd	r22, Y+14	; 0x0e
    9ba6:	7f 85       	ldd	r23, Y+15	; 0x0f
    9ba8:	88 89       	ldd	r24, Y+16	; 0x10
    9baa:	99 89       	ldd	r25, Y+17	; 0x11
    9bac:	20 e0       	ldi	r18, 0x00	; 0
    9bae:	30 e0       	ldi	r19, 0x00	; 0
    9bb0:	40 e2       	ldi	r20, 0x20	; 32
    9bb2:	51 e4       	ldi	r21, 0x41	; 65
    9bb4:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    9bb8:	dc 01       	movw	r26, r24
    9bba:	cb 01       	movw	r24, r22
    9bbc:	bc 01       	movw	r22, r24
    9bbe:	cd 01       	movw	r24, r26
    9bc0:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    9bc4:	dc 01       	movw	r26, r24
    9bc6:	cb 01       	movw	r24, r22
    9bc8:	8e 8b       	std	Y+22, r24	; 0x16
    9bca:	9f 8b       	std	Y+23, r25	; 0x17
    9bcc:	12 c0       	rjmp	.+36     	; 0x9bf2 <SD_init+0xe6>
    9bce:	80 e2       	ldi	r24, 0x20	; 32
    9bd0:	93 e0       	ldi	r25, 0x03	; 3
    9bd2:	88 8f       	std	Y+24, r24	; 0x18
    9bd4:	99 8f       	std	Y+25, r25	; 0x19
    9bd6:	88 8d       	ldd	r24, Y+24	; 0x18
    9bd8:	99 8d       	ldd	r25, Y+25	; 0x19
    9bda:	8c 01       	movw	r16, r24
    9bdc:	c8 01       	movw	r24, r16
    9bde:	01 97       	sbiw	r24, 0x01	; 1
    9be0:	f1 f7       	brne	.-4      	; 0x9bde <SD_init+0xd2>
    9be2:	8c 01       	movw	r16, r24
    9be4:	08 8f       	std	Y+24, r16	; 0x18
    9be6:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9be8:	8e 89       	ldd	r24, Y+22	; 0x16
    9bea:	9f 89       	ldd	r25, Y+23	; 0x17
    9bec:	01 97       	sbiw	r24, 0x01	; 1
    9bee:	8e 8b       	std	Y+22, r24	; 0x16
    9bf0:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9bf2:	8e 89       	ldd	r24, Y+22	; 0x16
    9bf4:	9f 89       	ldd	r25, Y+23	; 0x17
    9bf6:	00 97       	sbiw	r24, 0x00	; 0
    9bf8:	51 f7       	brne	.-44     	; 0x9bce <SD_init+0xc2>
    9bfa:	17 c0       	rjmp	.+46     	; 0x9c2a <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9bfc:	6a 89       	ldd	r22, Y+18	; 0x12
    9bfe:	7b 89       	ldd	r23, Y+19	; 0x13
    9c00:	8c 89       	ldd	r24, Y+20	; 0x14
    9c02:	9d 89       	ldd	r25, Y+21	; 0x15
    9c04:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    9c08:	dc 01       	movw	r26, r24
    9c0a:	cb 01       	movw	r24, r22
    9c0c:	8e 8b       	std	Y+22, r24	; 0x16
    9c0e:	9f 8b       	std	Y+23, r25	; 0x17
    9c10:	8e 89       	ldd	r24, Y+22	; 0x16
    9c12:	9f 89       	ldd	r25, Y+23	; 0x17
    9c14:	8a 8f       	std	Y+26, r24	; 0x1a
    9c16:	9b 8f       	std	Y+27, r25	; 0x1b
    9c18:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9c1a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    9c1c:	8c 01       	movw	r16, r24
    9c1e:	f8 01       	movw	r30, r16
    9c20:	31 97       	sbiw	r30, 0x01	; 1
    9c22:	f1 f7       	brne	.-4      	; 0x9c20 <SD_init+0x114>
    9c24:	8f 01       	movw	r16, r30
    9c26:	0a 8f       	std	Y+26, r16	; 0x1a
    9c28:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9c2a:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    9c2c:	88 e0       	ldi	r24, 0x08	; 8
    9c2e:	60 e0       	ldi	r22, 0x00	; 0
    9c30:	0e 94 1f 35 	call	0x6a3e	; 0x6a3e <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9c34:	88 e0       	ldi	r24, 0x08	; 8
    9c36:	60 e0       	ldi	r22, 0x00	; 0
    9c38:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9c3c:	80 e0       	ldi	r24, 0x00	; 0
    9c3e:	90 e0       	ldi	r25, 0x00	; 0
    9c40:	63 e0       	ldi	r22, 0x03	; 3
    9c42:	70 e0       	ldi	r23, 0x00	; 0
    9c44:	0e 94 e3 39 	call	0x73c6	; 0x73c6 <SPIInit2>
	SPICS(TRUE);
    9c48:	81 e0       	ldi	r24, 0x01	; 1
    9c4a:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9c4e:	1a 82       	std	Y+2, r1	; 0x02
    9c50:	1b 82       	std	Y+3, r1	; 0x03
    9c52:	17 c0       	rjmp	.+46     	; 0x9c82 <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9c54:	80 ec       	ldi	r24, 0xC0	; 192
    9c56:	98 e0       	ldi	r25, 0x08	; 8
    9c58:	2f ef       	ldi	r18, 0xFF	; 255
    9c5a:	fc 01       	movw	r30, r24
    9c5c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9c5e:	00 00       	nop
    9c60:	80 ec       	ldi	r24, 0xC0	; 192
    9c62:	98 e0       	ldi	r25, 0x08	; 8
    9c64:	fc 01       	movw	r30, r24
    9c66:	82 81       	ldd	r24, Z+2	; 0x02
    9c68:	88 23       	and	r24, r24
    9c6a:	d4 f7       	brge	.-12     	; 0x9c60 <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    9c6c:	80 ec       	ldi	r24, 0xC0	; 192
    9c6e:	98 e0       	ldi	r25, 0x08	; 8
    9c70:	fc 01       	movw	r30, r24
    9c72:	83 81       	ldd	r24, Z+3	; 0x03
    9c74:	80 93 a5 50 	sts	0x50A5, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9c78:	8a 81       	ldd	r24, Y+2	; 0x02
    9c7a:	9b 81       	ldd	r25, Y+3	; 0x03
    9c7c:	01 96       	adiw	r24, 0x01	; 1
    9c7e:	8a 83       	std	Y+2, r24	; 0x02
    9c80:	9b 83       	std	Y+3, r25	; 0x03
    9c82:	8a 81       	ldd	r24, Y+2	; 0x02
    9c84:	9b 81       	ldd	r25, Y+3	; 0x03
    9c86:	8a 30       	cpi	r24, 0x0A	; 10
    9c88:	91 05       	cpc	r25, r1
    9c8a:	24 f3       	brlt	.-56     	; 0x9c54 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    9c8c:	80 e0       	ldi	r24, 0x00	; 0
    9c8e:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    9c92:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9c96:	88 e0       	ldi	r24, 0x08	; 8
    9c98:	60 e0       	ldi	r22, 0x00	; 0
    9c9a:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9c9e:	80 e0       	ldi	r24, 0x00	; 0
    9ca0:	90 e0       	ldi	r25, 0x00	; 0
    9ca2:	63 e0       	ldi	r22, 0x03	; 3
    9ca4:	70 e0       	ldi	r23, 0x00	; 0
    9ca6:	0e 94 e3 39 	call	0x73c6	; 0x73c6 <SPIInit2>
	SPICS(TRUE);
    9caa:	81 e0       	ldi	r24, 0x01	; 1
    9cac:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9cb0:	1c 82       	std	Y+4, r1	; 0x04
    9cb2:	1d 82       	std	Y+5, r1	; 0x05
    9cb4:	0d c0       	rjmp	.+26     	; 0x9cd0 <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    9cb6:	8c 81       	ldd	r24, Y+4	; 0x04
    9cb8:	9d 81       	ldd	r25, Y+5	; 0x05
    9cba:	8a 30       	cpi	r24, 0x0A	; 10
    9cbc:	91 05       	cpc	r25, r1
    9cbe:	1c f0       	brlt	.+6      	; 0x9cc6 <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    9cc0:	81 e0       	ldi	r24, 0x01	; 1
    9cc2:	89 83       	std	Y+1, r24	; 0x01
			break;
    9cc4:	10 c0       	rjmp	.+32     	; 0x9ce6 <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9cc6:	8c 81       	ldd	r24, Y+4	; 0x04
    9cc8:	9d 81       	ldd	r25, Y+5	; 0x05
    9cca:	01 96       	adiw	r24, 0x01	; 1
    9ccc:	8c 83       	std	Y+4, r24	; 0x04
    9cce:	9d 83       	std	Y+5, r25	; 0x05
    9cd0:	80 e0       	ldi	r24, 0x00	; 0
    9cd2:	40 e0       	ldi	r20, 0x00	; 0
    9cd4:	50 e0       	ldi	r21, 0x00	; 0
    9cd6:	ba 01       	movw	r22, r20
    9cd8:	25 e9       	ldi	r18, 0x95	; 149
    9cda:	08 e0       	ldi	r16, 0x08	; 8
    9cdc:	10 e0       	ldi	r17, 0x00	; 0
    9cde:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
    9ce2:	81 30       	cpi	r24, 0x01	; 1
    9ce4:	41 f7       	brne	.-48     	; 0x9cb6 <SD_init+0x1aa>
    9ce6:	80 e0       	ldi	r24, 0x00	; 0
    9ce8:	90 e0       	ldi	r25, 0x00	; 0
    9cea:	a8 ec       	ldi	r26, 0xC8	; 200
    9cec:	b2 e4       	ldi	r27, 0x42	; 66
    9cee:	8c 8f       	std	Y+28, r24	; 0x1c
    9cf0:	9d 8f       	std	Y+29, r25	; 0x1d
    9cf2:	ae 8f       	std	Y+30, r26	; 0x1e
    9cf4:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9cf6:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9cf8:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9cfa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9cfc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9cfe:	20 e0       	ldi	r18, 0x00	; 0
    9d00:	30 e0       	ldi	r19, 0x00	; 0
    9d02:	4a ef       	ldi	r20, 0xFA	; 250
    9d04:	55 e4       	ldi	r21, 0x45	; 69
    9d06:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    9d0a:	dc 01       	movw	r26, r24
    9d0c:	cb 01       	movw	r24, r22
    9d0e:	88 a3       	lds	r24, 0x58
    9d10:	99 a3       	lds	r25, 0x59
    9d12:	aa a3       	lds	r26, 0x5a
    9d14:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    9d16:	11 e0       	ldi	r17, 0x01	; 1
    9d18:	68 a1       	lds	r22, 0x48
    9d1a:	79 a1       	lds	r23, 0x49
    9d1c:	8a a1       	lds	r24, 0x4a
    9d1e:	9b a1       	lds	r25, 0x4b
    9d20:	20 e0       	ldi	r18, 0x00	; 0
    9d22:	30 e0       	ldi	r19, 0x00	; 0
    9d24:	40 e8       	ldi	r20, 0x80	; 128
    9d26:	5f e3       	ldi	r21, 0x3F	; 63
    9d28:	0e 94 55 5d 	call	0xbaaa	; 0xbaaa <__cmpsf2>
    9d2c:	88 23       	and	r24, r24
    9d2e:	0c f0       	brlt	.+2      	; 0x9d32 <SD_init+0x226>
    9d30:	10 e0       	ldi	r17, 0x00	; 0
    9d32:	11 23       	and	r17, r17
    9d34:	29 f0       	breq	.+10     	; 0x9d40 <SD_init+0x234>
		__ticks = 1;
    9d36:	81 e0       	ldi	r24, 0x01	; 1
    9d38:	90 e0       	ldi	r25, 0x00	; 0
    9d3a:	8c a3       	lds	r24, 0x5c
    9d3c:	9d a3       	lds	r25, 0x5d
    9d3e:	46 c0       	rjmp	.+140    	; 0x9dcc <SD_init+0x2c0>
	else if (__tmp > 65535)
    9d40:	11 e0       	ldi	r17, 0x01	; 1
    9d42:	68 a1       	lds	r22, 0x48
    9d44:	79 a1       	lds	r23, 0x49
    9d46:	8a a1       	lds	r24, 0x4a
    9d48:	9b a1       	lds	r25, 0x4b
    9d4a:	20 e0       	ldi	r18, 0x00	; 0
    9d4c:	3f ef       	ldi	r19, 0xFF	; 255
    9d4e:	4f e7       	ldi	r20, 0x7F	; 127
    9d50:	57 e4       	ldi	r21, 0x47	; 71
    9d52:	0e 94 62 5e 	call	0xbcc4	; 0xbcc4 <__gesf2>
    9d56:	18 16       	cp	r1, r24
    9d58:	0c f0       	brlt	.+2      	; 0x9d5c <SD_init+0x250>
    9d5a:	10 e0       	ldi	r17, 0x00	; 0
    9d5c:	11 23       	and	r17, r17
    9d5e:	61 f1       	breq	.+88     	; 0x9db8 <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9d60:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9d62:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9d64:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9d66:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9d68:	20 e0       	ldi	r18, 0x00	; 0
    9d6a:	30 e0       	ldi	r19, 0x00	; 0
    9d6c:	40 e2       	ldi	r20, 0x20	; 32
    9d6e:	51 e4       	ldi	r21, 0x41	; 65
    9d70:	0e 94 66 5e 	call	0xbccc	; 0xbccc <__mulsf3>
    9d74:	dc 01       	movw	r26, r24
    9d76:	cb 01       	movw	r24, r22
    9d78:	bc 01       	movw	r22, r24
    9d7a:	cd 01       	movw	r24, r26
    9d7c:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    9d80:	dc 01       	movw	r26, r24
    9d82:	cb 01       	movw	r24, r22
    9d84:	8c a3       	lds	r24, 0x5c
    9d86:	9d a3       	lds	r25, 0x5d
    9d88:	12 c0       	rjmp	.+36     	; 0x9dae <SD_init+0x2a2>
    9d8a:	80 e2       	ldi	r24, 0x20	; 32
    9d8c:	93 e0       	ldi	r25, 0x03	; 3
    9d8e:	8e a3       	lds	r24, 0x5e
    9d90:	9f a3       	lds	r25, 0x5f
    9d92:	8e a1       	lds	r24, 0x4e
    9d94:	9f a1       	lds	r25, 0x4f
    9d96:	8c 01       	movw	r16, r24
    9d98:	c8 01       	movw	r24, r16
    9d9a:	01 97       	sbiw	r24, 0x01	; 1
    9d9c:	f1 f7       	brne	.-4      	; 0x9d9a <SD_init+0x28e>
    9d9e:	8c 01       	movw	r16, r24
    9da0:	0e a3       	lds	r16, 0x5e
    9da2:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9da4:	8c a1       	lds	r24, 0x4c
    9da6:	9d a1       	lds	r25, 0x4d
    9da8:	01 97       	sbiw	r24, 0x01	; 1
    9daa:	8c a3       	lds	r24, 0x5c
    9dac:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9dae:	8c a1       	lds	r24, 0x4c
    9db0:	9d a1       	lds	r25, 0x4d
    9db2:	00 97       	sbiw	r24, 0x00	; 0
    9db4:	51 f7       	brne	.-44     	; 0x9d8a <SD_init+0x27e>
    9db6:	17 c0       	rjmp	.+46     	; 0x9de6 <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9db8:	68 a1       	lds	r22, 0x48
    9dba:	79 a1       	lds	r23, 0x49
    9dbc:	8a a1       	lds	r24, 0x4a
    9dbe:	9b a1       	lds	r25, 0x4b
    9dc0:	0e 94 c1 5d 	call	0xbb82	; 0xbb82 <__fixunssfsi>
    9dc4:	dc 01       	movw	r26, r24
    9dc6:	cb 01       	movw	r24, r22
    9dc8:	8c a3       	lds	r24, 0x5c
    9dca:	9d a3       	lds	r25, 0x5d
    9dcc:	8c a1       	lds	r24, 0x4c
    9dce:	9d a1       	lds	r25, 0x4d
    9dd0:	88 a7       	lds	r24, 0x78
    9dd2:	99 a7       	lds	r25, 0x79
    9dd4:	88 a5       	lds	r24, 0x68
    9dd6:	99 a5       	lds	r25, 0x69
    9dd8:	8c 01       	movw	r16, r24
    9dda:	f8 01       	movw	r30, r16
    9ddc:	31 97       	sbiw	r30, 0x01	; 1
    9dde:	f1 f7       	brne	.-4      	; 0x9ddc <SD_init+0x2d0>
    9de0:	8f 01       	movw	r16, r30
    9de2:	08 a7       	lds	r16, 0x78
    9de4:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9de6:	1e 82       	std	Y+6, r1	; 0x06
    9de8:	1f 82       	std	Y+7, r1	; 0x07
    9dea:	0d c0       	rjmp	.+26     	; 0x9e06 <SD_init+0x2fa>
		if (i >= 10) {
    9dec:	8e 81       	ldd	r24, Y+6	; 0x06
    9dee:	9f 81       	ldd	r25, Y+7	; 0x07
    9df0:	8a 30       	cpi	r24, 0x0A	; 10
    9df2:	91 05       	cpc	r25, r1
    9df4:	1c f0       	brlt	.+6      	; 0x9dfc <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    9df6:	81 e0       	ldi	r24, 0x01	; 1
    9df8:	89 83       	std	Y+1, r24	; 0x01
			break;
    9dfa:	11 c0       	rjmp	.+34     	; 0x9e1e <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9dfc:	8e 81       	ldd	r24, Y+6	; 0x06
    9dfe:	9f 81       	ldd	r25, Y+7	; 0x07
    9e00:	01 96       	adiw	r24, 0x01	; 1
    9e02:	8e 83       	std	Y+6, r24	; 0x06
    9e04:	9f 83       	std	Y+7, r25	; 0x07
    9e06:	88 e0       	ldi	r24, 0x08	; 8
    9e08:	4a ea       	ldi	r20, 0xAA	; 170
    9e0a:	51 e0       	ldi	r21, 0x01	; 1
    9e0c:	60 e0       	ldi	r22, 0x00	; 0
    9e0e:	70 e0       	ldi	r23, 0x00	; 0
    9e10:	27 e8       	ldi	r18, 0x87	; 135
    9e12:	08 e0       	ldi	r16, 0x08	; 8
    9e14:	10 e0       	ldi	r17, 0x00	; 0
    9e16:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
    9e1a:	81 30       	cpi	r24, 0x01	; 1
    9e1c:	39 f7       	brne	.-50     	; 0x9dec <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9e1e:	18 86       	std	Y+8, r1	; 0x08
    9e20:	19 86       	std	Y+9, r1	; 0x09
    9e22:	13 c0       	rjmp	.+38     	; 0x9e4a <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9e24:	88 85       	ldd	r24, Y+8	; 0x08
    9e26:	99 85       	ldd	r25, Y+9	; 0x09
    9e28:	8c 01       	movw	r16, r24
    9e2a:	0e 5f       	subi	r16, 0xFE	; 254
    9e2c:	1f 4f       	sbci	r17, 0xFF	; 255
    9e2e:	8f ef       	ldi	r24, 0xFF	; 255
    9e30:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    9e34:	28 2f       	mov	r18, r24
    9e36:	c8 01       	movw	r24, r16
    9e38:	87 56       	subi	r24, 0x67	; 103
    9e3a:	9f 4a       	sbci	r25, 0xAF	; 175
    9e3c:	fc 01       	movw	r30, r24
    9e3e:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9e40:	88 85       	ldd	r24, Y+8	; 0x08
    9e42:	99 85       	ldd	r25, Y+9	; 0x09
    9e44:	01 96       	adiw	r24, 0x01	; 1
    9e46:	88 87       	std	Y+8, r24	; 0x08
    9e48:	99 87       	std	Y+9, r25	; 0x09
    9e4a:	88 85       	ldd	r24, Y+8	; 0x08
    9e4c:	99 85       	ldd	r25, Y+9	; 0x09
    9e4e:	84 30       	cpi	r24, 0x04	; 4
    9e50:	91 05       	cpc	r25, r1
    9e52:	44 f3       	brlt	.-48     	; 0x9e24 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9e54:	80 91 9d 50 	lds	r24, 0x509D
    9e58:	81 30       	cpi	r24, 0x01	; 1
    9e5a:	21 f4       	brne	.+8      	; 0x9e64 <SD_init+0x358>
    9e5c:	80 91 9e 50 	lds	r24, 0x509E
    9e60:	8a 3a       	cpi	r24, 0xAA	; 170
    9e62:	11 f0       	breq	.+4      	; 0x9e68 <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9e64:	81 e0       	ldi	r24, 0x01	; 1
    9e66:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9e68:	87 e3       	ldi	r24, 0x37	; 55
    9e6a:	40 e0       	ldi	r20, 0x00	; 0
    9e6c:	50 e0       	ldi	r21, 0x00	; 0
    9e6e:	ba 01       	movw	r22, r20
    9e70:	2f ef       	ldi	r18, 0xFF	; 255
    9e72:	08 e0       	ldi	r16, 0x08	; 8
    9e74:	10 e0       	ldi	r17, 0x00	; 0
    9e76:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9e7a:	81 e0       	ldi	r24, 0x01	; 1
    9e7c:	40 e0       	ldi	r20, 0x00	; 0
    9e7e:	50 e0       	ldi	r21, 0x00	; 0
    9e80:	60 e0       	ldi	r22, 0x00	; 0
    9e82:	70 e4       	ldi	r23, 0x40	; 64
    9e84:	2f ef       	ldi	r18, 0xFF	; 255
    9e86:	08 e0       	ldi	r16, 0x08	; 8
    9e88:	10 e0       	ldi	r17, 0x00	; 0
    9e8a:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
	} while(Buffer[1]!= 0x00);
    9e8e:	80 91 9a 50 	lds	r24, 0x509A
    9e92:	88 23       	and	r24, r24
    9e94:	49 f7       	brne	.-46     	; 0x9e68 <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9e96:	1a 86       	std	Y+10, r1	; 0x0a
    9e98:	1b 86       	std	Y+11, r1	; 0x0b
    9e9a:	0d c0       	rjmp	.+26     	; 0x9eb6 <SD_init+0x3aa>
		if (i >= 10) {
    9e9c:	8a 85       	ldd	r24, Y+10	; 0x0a
    9e9e:	9b 85       	ldd	r25, Y+11	; 0x0b
    9ea0:	8a 30       	cpi	r24, 0x0A	; 10
    9ea2:	91 05       	cpc	r25, r1
    9ea4:	1c f0       	brlt	.+6      	; 0x9eac <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    9ea6:	81 e0       	ldi	r24, 0x01	; 1
    9ea8:	89 83       	std	Y+1, r24	; 0x01
			break;
    9eaa:	10 c0       	rjmp	.+32     	; 0x9ecc <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9eac:	8a 85       	ldd	r24, Y+10	; 0x0a
    9eae:	9b 85       	ldd	r25, Y+11	; 0x0b
    9eb0:	01 96       	adiw	r24, 0x01	; 1
    9eb2:	8a 87       	std	Y+10, r24	; 0x0a
    9eb4:	9b 87       	std	Y+11, r25	; 0x0b
    9eb6:	8a e3       	ldi	r24, 0x3A	; 58
    9eb8:	40 e0       	ldi	r20, 0x00	; 0
    9eba:	50 e0       	ldi	r21, 0x00	; 0
    9ebc:	ba 01       	movw	r22, r20
    9ebe:	2f ef       	ldi	r18, 0xFF	; 255
    9ec0:	08 e0       	ldi	r16, 0x08	; 8
    9ec2:	10 e0       	ldi	r17, 0x00	; 0
    9ec4:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
    9ec8:	88 23       	and	r24, r24
    9eca:	41 f7       	brne	.-48     	; 0x9e9c <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9ecc:	1c 86       	std	Y+12, r1	; 0x0c
    9ece:	1d 86       	std	Y+13, r1	; 0x0d
    9ed0:	0f c0       	rjmp	.+30     	; 0x9ef0 <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9ed2:	8f ef       	ldi	r24, 0xFF	; 255
    9ed4:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    9ed8:	28 2f       	mov	r18, r24
    9eda:	8c 85       	ldd	r24, Y+12	; 0x0c
    9edc:	9d 85       	ldd	r25, Y+13	; 0x0d
    9ede:	87 56       	subi	r24, 0x67	; 103
    9ee0:	9f 4a       	sbci	r25, 0xAF	; 175
    9ee2:	fc 01       	movw	r30, r24
    9ee4:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9ee6:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ee8:	9d 85       	ldd	r25, Y+13	; 0x0d
    9eea:	01 96       	adiw	r24, 0x01	; 1
    9eec:	8c 87       	std	Y+12, r24	; 0x0c
    9eee:	9d 87       	std	Y+13, r25	; 0x0d
    9ef0:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ef2:	9d 85       	ldd	r25, Y+13	; 0x0d
    9ef4:	84 30       	cpi	r24, 0x04	; 4
    9ef6:	91 05       	cpc	r25, r1
    9ef8:	64 f3       	brlt	.-40     	; 0x9ed2 <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9efa:	80 91 99 50 	lds	r24, 0x5099
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9efe:	80 e0       	ldi	r24, 0x00	; 0
    9f00:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    9f04:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9f08:	88 e0       	ldi	r24, 0x08	; 8
    9f0a:	60 e0       	ldi	r22, 0x00	; 0
    9f0c:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
	return errorCode;	
    9f10:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9f12:	a9 96       	adiw	r28, 0x29	; 41
    9f14:	cd bf       	out	0x3d, r28	; 61
    9f16:	de bf       	out	0x3e, r29	; 62
    9f18:	df 91       	pop	r29
    9f1a:	cf 91       	pop	r28
    9f1c:	1f 91       	pop	r17
    9f1e:	0f 91       	pop	r16
    9f20:	08 95       	ret

00009f22 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9f22:	cf 93       	push	r28
    9f24:	df 93       	push	r29
    9f26:	0f 92       	push	r0
    9f28:	0f 92       	push	r0
    9f2a:	cd b7       	in	r28, 0x3d	; 61
    9f2c:	de b7       	in	r29, 0x3e	; 62
    9f2e:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9f30:	80 ec       	ldi	r24, 0xC0	; 192
    9f32:	98 e0       	ldi	r25, 0x08	; 8
    9f34:	2a 81       	ldd	r18, Y+2	; 0x02
    9f36:	fc 01       	movw	r30, r24
    9f38:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9f3a:	00 00       	nop
    9f3c:	80 ec       	ldi	r24, 0xC0	; 192
    9f3e:	98 e0       	ldi	r25, 0x08	; 8
    9f40:	fc 01       	movw	r30, r24
    9f42:	82 81       	ldd	r24, Z+2	; 0x02
    9f44:	88 23       	and	r24, r24
    9f46:	d4 f7       	brge	.-12     	; 0x9f3c <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9f48:	80 ec       	ldi	r24, 0xC0	; 192
    9f4a:	98 e0       	ldi	r25, 0x08	; 8
    9f4c:	fc 01       	movw	r30, r24
    9f4e:	83 81       	ldd	r24, Z+3	; 0x03
    9f50:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9f52:	89 81       	ldd	r24, Y+1	; 0x01
}
    9f54:	0f 90       	pop	r0
    9f56:	0f 90       	pop	r0
    9f58:	df 91       	pop	r29
    9f5a:	cf 91       	pop	r28
    9f5c:	08 95       	ret

00009f5e <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9f5e:	0f 93       	push	r16
    9f60:	1f 93       	push	r17
    9f62:	cf 93       	push	r28
    9f64:	df 93       	push	r29
    9f66:	cd b7       	in	r28, 0x3d	; 61
    9f68:	de b7       	in	r29, 0x3e	; 62
    9f6a:	2a 97       	sbiw	r28, 0x0a	; 10
    9f6c:	cd bf       	out	0x3d, r28	; 61
    9f6e:	de bf       	out	0x3e, r29	; 62
    9f70:	8b 83       	std	Y+3, r24	; 0x03
    9f72:	4c 83       	std	Y+4, r20	; 0x04
    9f74:	5d 83       	std	Y+5, r21	; 0x05
    9f76:	6e 83       	std	Y+6, r22	; 0x06
    9f78:	7f 83       	std	Y+7, r23	; 0x07
    9f7a:	28 87       	std	Y+8, r18	; 0x08
    9f7c:	09 87       	std	Y+9, r16	; 0x09
    9f7e:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9f80:	8b 81       	ldd	r24, Y+3	; 0x03
    9f82:	80 64       	ori	r24, 0x40	; 64
    9f84:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9f88:	8c 81       	ldd	r24, Y+4	; 0x04
    9f8a:	9d 81       	ldd	r25, Y+5	; 0x05
    9f8c:	ae 81       	ldd	r26, Y+6	; 0x06
    9f8e:	bf 81       	ldd	r27, Y+7	; 0x07
    9f90:	8b 2f       	mov	r24, r27
    9f92:	99 27       	eor	r25, r25
    9f94:	aa 27       	eor	r26, r26
    9f96:	bb 27       	eor	r27, r27
    9f98:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9f9c:	8c 81       	ldd	r24, Y+4	; 0x04
    9f9e:	9d 81       	ldd	r25, Y+5	; 0x05
    9fa0:	ae 81       	ldd	r26, Y+6	; 0x06
    9fa2:	bf 81       	ldd	r27, Y+7	; 0x07
    9fa4:	cd 01       	movw	r24, r26
    9fa6:	aa 27       	eor	r26, r26
    9fa8:	bb 27       	eor	r27, r27
    9faa:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9fae:	8c 81       	ldd	r24, Y+4	; 0x04
    9fb0:	9d 81       	ldd	r25, Y+5	; 0x05
    9fb2:	ae 81       	ldd	r26, Y+6	; 0x06
    9fb4:	bf 81       	ldd	r27, Y+7	; 0x07
    9fb6:	89 2f       	mov	r24, r25
    9fb8:	9a 2f       	mov	r25, r26
    9fba:	ab 2f       	mov	r26, r27
    9fbc:	bb 27       	eor	r27, r27
    9fbe:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9fc2:	8c 81       	ldd	r24, Y+4	; 0x04
    9fc4:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
	SPI_write(crc);
    9fc8:	88 85       	ldd	r24, Y+8	; 0x08
    9fca:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
	
	for(int i=0; i<read; i++){
    9fce:	19 82       	std	Y+1, r1	; 0x01
    9fd0:	1a 82       	std	Y+2, r1	; 0x02
    9fd2:	33 c0       	rjmp	.+102    	; 0xa03a <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9fd4:	89 81       	ldd	r24, Y+1	; 0x01
    9fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    9fd8:	2d e0       	ldi	r18, 0x0D	; 13
    9fda:	30 e0       	ldi	r19, 0x00	; 0
    9fdc:	b9 01       	movw	r22, r18
    9fde:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    9fe2:	8c 01       	movw	r16, r24
    9fe4:	8f ef       	ldi	r24, 0xFF	; 255
    9fe6:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    9fea:	28 2f       	mov	r18, r24
    9fec:	c8 01       	movw	r24, r16
    9fee:	87 56       	subi	r24, 0x67	; 103
    9ff0:	9f 4a       	sbci	r25, 0xAF	; 175
    9ff2:	fc 01       	movw	r30, r24
    9ff4:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9ff6:	89 81       	ldd	r24, Y+1	; 0x01
    9ff8:	9a 81       	ldd	r25, Y+2	; 0x02
    9ffa:	2d e0       	ldi	r18, 0x0D	; 13
    9ffc:	30 e0       	ldi	r19, 0x00	; 0
    9ffe:	b9 01       	movw	r22, r18
    a000:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a004:	87 56       	subi	r24, 0x67	; 103
    a006:	9f 4a       	sbci	r25, 0xAF	; 175
    a008:	fc 01       	movw	r30, r24
    a00a:	80 81       	ld	r24, Z
    a00c:	8f 3f       	cpi	r24, 0xFF	; 255
    a00e:	81 f0       	breq	.+32     	; 0xa030 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    a010:	89 81       	ldd	r24, Y+1	; 0x01
    a012:	9a 81       	ldd	r25, Y+2	; 0x02
    a014:	2d e0       	ldi	r18, 0x0D	; 13
    a016:	30 e0       	ldi	r19, 0x00	; 0
    a018:	b9 01       	movw	r22, r18
    a01a:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a01e:	87 56       	subi	r24, 0x67	; 103
    a020:	9f 4a       	sbci	r25, 0xAF	; 175
    a022:	fc 01       	movw	r30, r24
    a024:	80 81       	ld	r24, Z
    a026:	80 93 9a 50 	sts	0x509A, r24
			return Buffer[1];
    a02a:	80 91 9a 50 	lds	r24, 0x509A
    a02e:	0d c0       	rjmp	.+26     	; 0xa04a <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    a030:	89 81       	ldd	r24, Y+1	; 0x01
    a032:	9a 81       	ldd	r25, Y+2	; 0x02
    a034:	01 96       	adiw	r24, 0x01	; 1
    a036:	89 83       	std	Y+1, r24	; 0x01
    a038:	9a 83       	std	Y+2, r25	; 0x02
    a03a:	29 81       	ldd	r18, Y+1	; 0x01
    a03c:	3a 81       	ldd	r19, Y+2	; 0x02
    a03e:	89 85       	ldd	r24, Y+9	; 0x09
    a040:	9a 85       	ldd	r25, Y+10	; 0x0a
    a042:	28 17       	cp	r18, r24
    a044:	39 07       	cpc	r19, r25
    a046:	34 f2       	brlt	.-116    	; 0x9fd4 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    a048:	8f ef       	ldi	r24, 0xFF	; 255
}
    a04a:	2a 96       	adiw	r28, 0x0a	; 10
    a04c:	cd bf       	out	0x3d, r28	; 61
    a04e:	de bf       	out	0x3e, r29	; 62
    a050:	df 91       	pop	r29
    a052:	cf 91       	pop	r28
    a054:	1f 91       	pop	r17
    a056:	0f 91       	pop	r16
    a058:	08 95       	ret

0000a05a <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    a05a:	0f 93       	push	r16
    a05c:	1f 93       	push	r17
    a05e:	cf 93       	push	r28
    a060:	df 93       	push	r29
    a062:	cd b7       	in	r28, 0x3d	; 61
    a064:	de b7       	in	r29, 0x3e	; 62
    a066:	62 97       	sbiw	r28, 0x12	; 18
    a068:	cd bf       	out	0x3d, r28	; 61
    a06a:	de bf       	out	0x3e, r29	; 62
    a06c:	6b 87       	std	Y+11, r22	; 0x0b
    a06e:	7c 87       	std	Y+12, r23	; 0x0c
    a070:	8d 87       	std	Y+13, r24	; 0x0d
    a072:	9e 87       	std	Y+14, r25	; 0x0e
    a074:	4f 87       	std	Y+15, r20	; 0x0f
    a076:	58 8b       	std	Y+16, r21	; 0x10
    a078:	29 8b       	std	Y+17, r18	; 0x11
    a07a:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a07c:	88 e0       	ldi	r24, 0x08	; 8
    a07e:	60 e0       	ldi	r22, 0x00	; 0
    a080:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a084:	80 e0       	ldi	r24, 0x00	; 0
    a086:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    a08a:	81 e0       	ldi	r24, 0x01	; 1
    a08c:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    a090:	20 e0       	ldi	r18, 0x00	; 0
    a092:	32 e0       	ldi	r19, 0x02	; 2
    a094:	89 89       	ldd	r24, Y+17	; 0x11
    a096:	9a 89       	ldd	r25, Y+18	; 0x12
    a098:	a9 01       	movw	r20, r18
    a09a:	48 1b       	sub	r20, r24
    a09c:	59 0b       	sbc	r21, r25
    a09e:	ca 01       	movw	r24, r20
    a0a0:	89 83       	std	Y+1, r24	; 0x01
    a0a2:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a0a4:	89 81       	ldd	r24, Y+1	; 0x01
    a0a6:	9a 81       	ldd	r25, Y+2	; 0x02
    a0a8:	52 e0       	ldi	r21, 0x02	; 2
    a0aa:	80 30       	cpi	r24, 0x00	; 0
    a0ac:	95 07       	cpc	r25, r21
    a0ae:	11 f4       	brne	.+4      	; 0xa0b4 <SD_write_block+0x5a>
    a0b0:	19 82       	std	Y+1, r1	; 0x01
    a0b2:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a0b4:	1b 82       	std	Y+3, r1	; 0x03
    a0b6:	1c 82       	std	Y+4, r1	; 0x04
    a0b8:	0b c0       	rjmp	.+22     	; 0xa0d0 <SD_write_block+0x76>
	if (i >= 10) {
    a0ba:	8b 81       	ldd	r24, Y+3	; 0x03
    a0bc:	9c 81       	ldd	r25, Y+4	; 0x04
    a0be:	8a 30       	cpi	r24, 0x0A	; 10
    a0c0:	91 05       	cpc	r25, r1
    a0c2:	0c f0       	brlt	.+2      	; 0xa0c6 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    a0c4:	ff cf       	rjmp	.-2      	; 0xa0c4 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a0c6:	8b 81       	ldd	r24, Y+3	; 0x03
    a0c8:	9c 81       	ldd	r25, Y+4	; 0x04
    a0ca:	01 96       	adiw	r24, 0x01	; 1
    a0cc:	8b 83       	std	Y+3, r24	; 0x03
    a0ce:	9c 83       	std	Y+4, r25	; 0x04
    a0d0:	2b 85       	ldd	r18, Y+11	; 0x0b
    a0d2:	3c 85       	ldd	r19, Y+12	; 0x0c
    a0d4:	4d 85       	ldd	r20, Y+13	; 0x0d
    a0d6:	5e 85       	ldd	r21, Y+14	; 0x0e
    a0d8:	88 e1       	ldi	r24, 0x18	; 24
    a0da:	ba 01       	movw	r22, r20
    a0dc:	a9 01       	movw	r20, r18
    a0de:	2f ef       	ldi	r18, 0xFF	; 255
    a0e0:	08 e0       	ldi	r16, 0x08	; 8
    a0e2:	10 e0       	ldi	r17, 0x00	; 0
    a0e4:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
    a0e8:	88 23       	and	r24, r24
    a0ea:	39 f7       	brne	.-50     	; 0xa0ba <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    a0ec:	8f ef       	ldi	r24, 0xFF	; 255
    a0ee:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a0f2:	80 93 99 50 	sts	0x5099, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    a0f6:	8e ef       	ldi	r24, 0xFE	; 254
    a0f8:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a0fc:	1d 82       	std	Y+5, r1	; 0x05
    a0fe:	1e 82       	std	Y+6, r1	; 0x06
    a100:	1d c0       	rjmp	.+58     	; 0xa13c <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    a102:	8d 81       	ldd	r24, Y+5	; 0x05
    a104:	9e 81       	ldd	r25, Y+6	; 0x06
    a106:	2d e0       	ldi	r18, 0x0D	; 13
    a108:	30 e0       	ldi	r19, 0x00	; 0
    a10a:	b9 01       	movw	r22, r18
    a10c:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a110:	8c 01       	movw	r16, r24
    a112:	8d 81       	ldd	r24, Y+5	; 0x05
    a114:	9e 81       	ldd	r25, Y+6	; 0x06
    a116:	2f 85       	ldd	r18, Y+15	; 0x0f
    a118:	38 89       	ldd	r19, Y+16	; 0x10
    a11a:	82 0f       	add	r24, r18
    a11c:	93 1f       	adc	r25, r19
    a11e:	fc 01       	movw	r30, r24
    a120:	80 81       	ld	r24, Z
    a122:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a126:	28 2f       	mov	r18, r24
    a128:	c8 01       	movw	r24, r16
    a12a:	87 56       	subi	r24, 0x67	; 103
    a12c:	9f 4a       	sbci	r25, 0xAF	; 175
    a12e:	fc 01       	movw	r30, r24
    a130:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a132:	8d 81       	ldd	r24, Y+5	; 0x05
    a134:	9e 81       	ldd	r25, Y+6	; 0x06
    a136:	01 96       	adiw	r24, 0x01	; 1
    a138:	8d 83       	std	Y+5, r24	; 0x05
    a13a:	9e 83       	std	Y+6, r25	; 0x06
    a13c:	2d 81       	ldd	r18, Y+5	; 0x05
    a13e:	3e 81       	ldd	r19, Y+6	; 0x06
    a140:	89 89       	ldd	r24, Y+17	; 0x11
    a142:	9a 89       	ldd	r25, Y+18	; 0x12
    a144:	28 17       	cp	r18, r24
    a146:	39 07       	cpc	r19, r25
    a148:	e4 f2       	brlt	.-72     	; 0xa102 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a14a:	1f 82       	std	Y+7, r1	; 0x07
    a14c:	18 86       	std	Y+8, r1	; 0x08
    a14e:	16 c0       	rjmp	.+44     	; 0xa17c <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    a150:	8f 81       	ldd	r24, Y+7	; 0x07
    a152:	98 85       	ldd	r25, Y+8	; 0x08
    a154:	2d e0       	ldi	r18, 0x0D	; 13
    a156:	30 e0       	ldi	r19, 0x00	; 0
    a158:	b9 01       	movw	r22, r18
    a15a:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a15e:	8c 01       	movw	r16, r24
    a160:	80 e0       	ldi	r24, 0x00	; 0
    a162:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a166:	28 2f       	mov	r18, r24
    a168:	c8 01       	movw	r24, r16
    a16a:	87 56       	subi	r24, 0x67	; 103
    a16c:	9f 4a       	sbci	r25, 0xAF	; 175
    a16e:	fc 01       	movw	r30, r24
    a170:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a172:	8f 81       	ldd	r24, Y+7	; 0x07
    a174:	98 85       	ldd	r25, Y+8	; 0x08
    a176:	01 96       	adiw	r24, 0x01	; 1
    a178:	8f 83       	std	Y+7, r24	; 0x07
    a17a:	98 87       	std	Y+8, r25	; 0x08
    a17c:	2f 81       	ldd	r18, Y+7	; 0x07
    a17e:	38 85       	ldd	r19, Y+8	; 0x08
    a180:	89 81       	ldd	r24, Y+1	; 0x01
    a182:	9a 81       	ldd	r25, Y+2	; 0x02
    a184:	28 17       	cp	r18, r24
    a186:	39 07       	cpc	r19, r25
    a188:	1c f3       	brlt	.-58     	; 0xa150 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    a18a:	8f ef       	ldi	r24, 0xFF	; 255
    a18c:	80 93 99 50 	sts	0x5099, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a190:	19 86       	std	Y+9, r1	; 0x09
    a192:	1a 86       	std	Y+10, r1	; 0x0a
    a194:	0a c0       	rjmp	.+20     	; 0xa1aa <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    a196:	8f ef       	ldi	r24, 0xFF	; 255
    a198:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a19c:	80 93 99 50 	sts	0x5099, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a1a0:	89 85       	ldd	r24, Y+9	; 0x09
    a1a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    a1a4:	01 96       	adiw	r24, 0x01	; 1
    a1a6:	89 87       	std	Y+9, r24	; 0x09
    a1a8:	9a 87       	std	Y+10, r25	; 0x0a
    a1aa:	89 85       	ldd	r24, Y+9	; 0x09
    a1ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    a1ae:	82 30       	cpi	r24, 0x02	; 2
    a1b0:	91 05       	cpc	r25, r1
    a1b2:	8c f3       	brlt	.-30     	; 0xa196 <SD_write_block+0x13c>
    a1b4:	80 91 99 50 	lds	r24, 0x5099
    a1b8:	8f 3f       	cpi	r24, 0xFF	; 255
    a1ba:	69 f3       	breq	.-38     	; 0xa196 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    a1bc:	80 91 99 50 	lds	r24, 0x5099
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    a1c0:	05 c0       	rjmp	.+10     	; 0xa1cc <SD_write_block+0x172>
    a1c2:	8f ef       	ldi	r24, 0xFF	; 255
    a1c4:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a1c8:	80 93 99 50 	sts	0x5099, r24
    a1cc:	80 91 99 50 	lds	r24, 0x5099
    a1d0:	8f 3f       	cpi	r24, 0xFF	; 255
    a1d2:	b9 f7       	brne	.-18     	; 0xa1c2 <SD_write_block+0x168>
	SPICS(FALSE);
    a1d4:	80 e0       	ldi	r24, 0x00	; 0
    a1d6:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    a1da:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    a1de:	88 e0       	ldi	r24, 0x08	; 8
    a1e0:	60 e0       	ldi	r22, 0x00	; 0
    a1e2:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
}
    a1e6:	62 96       	adiw	r28, 0x12	; 18
    a1e8:	cd bf       	out	0x3d, r28	; 61
    a1ea:	de bf       	out	0x3e, r29	; 62
    a1ec:	df 91       	pop	r29
    a1ee:	cf 91       	pop	r28
    a1f0:	1f 91       	pop	r17
    a1f2:	0f 91       	pop	r16
    a1f4:	08 95       	ret

0000a1f6 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    a1f6:	0f 93       	push	r16
    a1f8:	1f 93       	push	r17
    a1fa:	cf 93       	push	r28
    a1fc:	df 93       	push	r29
    a1fe:	cd b7       	in	r28, 0x3d	; 61
    a200:	de b7       	in	r29, 0x3e	; 62
    a202:	2a 97       	sbiw	r28, 0x0a	; 10
    a204:	cd bf       	out	0x3d, r28	; 61
    a206:	de bf       	out	0x3e, r29	; 62
    a208:	6d 83       	std	Y+5, r22	; 0x05
    a20a:	7e 83       	std	Y+6, r23	; 0x06
    a20c:	8f 83       	std	Y+7, r24	; 0x07
    a20e:	98 87       	std	Y+8, r25	; 0x08
    a210:	49 87       	std	Y+9, r20	; 0x09
    a212:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a214:	88 e0       	ldi	r24, 0x08	; 8
    a216:	60 e0       	ldi	r22, 0x00	; 0
    a218:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a21c:	80 e0       	ldi	r24, 0x00	; 0
    a21e:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    a222:	81 e0       	ldi	r24, 0x01	; 1
    a224:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a228:	19 82       	std	Y+1, r1	; 0x01
    a22a:	1a 82       	std	Y+2, r1	; 0x02
    a22c:	0b c0       	rjmp	.+22     	; 0xa244 <SD_read_block+0x4e>
		if (i >= 10) {
    a22e:	89 81       	ldd	r24, Y+1	; 0x01
    a230:	9a 81       	ldd	r25, Y+2	; 0x02
    a232:	8a 30       	cpi	r24, 0x0A	; 10
    a234:	91 05       	cpc	r25, r1
    a236:	0c f0       	brlt	.+2      	; 0xa23a <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    a238:	ff cf       	rjmp	.-2      	; 0xa238 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a23a:	89 81       	ldd	r24, Y+1	; 0x01
    a23c:	9a 81       	ldd	r25, Y+2	; 0x02
    a23e:	01 96       	adiw	r24, 0x01	; 1
    a240:	89 83       	std	Y+1, r24	; 0x01
    a242:	9a 83       	std	Y+2, r25	; 0x02
    a244:	2d 81       	ldd	r18, Y+5	; 0x05
    a246:	3e 81       	ldd	r19, Y+6	; 0x06
    a248:	4f 81       	ldd	r20, Y+7	; 0x07
    a24a:	58 85       	ldd	r21, Y+8	; 0x08
    a24c:	81 e1       	ldi	r24, 0x11	; 17
    a24e:	ba 01       	movw	r22, r20
    a250:	a9 01       	movw	r20, r18
    a252:	2f ef       	ldi	r18, 0xFF	; 255
    a254:	08 e0       	ldi	r16, 0x08	; 8
    a256:	10 e0       	ldi	r17, 0x00	; 0
    a258:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
    a25c:	88 23       	and	r24, r24
    a25e:	39 f7       	brne	.-50     	; 0xa22e <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a260:	05 c0       	rjmp	.+10     	; 0xa26c <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    a262:	8f ef       	ldi	r24, 0xFF	; 255
    a264:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a268:	80 93 99 50 	sts	0x5099, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a26c:	80 91 99 50 	lds	r24, 0x5099
    a270:	8e 3f       	cpi	r24, 0xFE	; 254
    a272:	b9 f7       	brne	.-18     	; 0xa262 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a274:	1b 82       	std	Y+3, r1	; 0x03
    a276:	1c 82       	std	Y+4, r1	; 0x04
    a278:	11 c0       	rjmp	.+34     	; 0xa29c <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a27a:	8b 81       	ldd	r24, Y+3	; 0x03
    a27c:	9c 81       	ldd	r25, Y+4	; 0x04
    a27e:	29 85       	ldd	r18, Y+9	; 0x09
    a280:	3a 85       	ldd	r19, Y+10	; 0x0a
    a282:	89 01       	movw	r16, r18
    a284:	08 0f       	add	r16, r24
    a286:	19 1f       	adc	r17, r25
    a288:	8f ef       	ldi	r24, 0xFF	; 255
    a28a:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a28e:	f8 01       	movw	r30, r16
    a290:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a292:	8b 81       	ldd	r24, Y+3	; 0x03
    a294:	9c 81       	ldd	r25, Y+4	; 0x04
    a296:	01 96       	adiw	r24, 0x01	; 1
    a298:	8b 83       	std	Y+3, r24	; 0x03
    a29a:	9c 83       	std	Y+4, r25	; 0x04
    a29c:	8b 81       	ldd	r24, Y+3	; 0x03
    a29e:	9c 81       	ldd	r25, Y+4	; 0x04
    a2a0:	f2 e0       	ldi	r31, 0x02	; 2
    a2a2:	80 30       	cpi	r24, 0x00	; 0
    a2a4:	9f 07       	cpc	r25, r31
    a2a6:	4c f3       	brlt	.-46     	; 0xa27a <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    a2a8:	10 92 a5 50 	sts	0x50A5, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a2ac:	05 c0       	rjmp	.+10     	; 0xa2b8 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    a2ae:	8f ef       	ldi	r24, 0xFF	; 255
    a2b0:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a2b4:	80 93 a5 50 	sts	0x50A5, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a2b8:	80 91 a5 50 	lds	r24, 0x50A5
    a2bc:	8f 3f       	cpi	r24, 0xFF	; 255
    a2be:	b9 f7       	brne	.-18     	; 0xa2ae <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    a2c0:	80 e0       	ldi	r24, 0x00	; 0
    a2c2:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    a2c6:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a2ca:	88 e0       	ldi	r24, 0x08	; 8
    a2cc:	60 e0       	ldi	r22, 0x00	; 0
    a2ce:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
}
    a2d2:	2a 96       	adiw	r28, 0x0a	; 10
    a2d4:	cd bf       	out	0x3d, r28	; 61
    a2d6:	de bf       	out	0x3e, r29	; 62
    a2d8:	df 91       	pop	r29
    a2da:	cf 91       	pop	r28
    a2dc:	1f 91       	pop	r17
    a2de:	0f 91       	pop	r16
    a2e0:	08 95       	ret

0000a2e2 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    a2e2:	0f 93       	push	r16
    a2e4:	1f 93       	push	r17
    a2e6:	cf 93       	push	r28
    a2e8:	df 93       	push	r29
    a2ea:	cd b7       	in	r28, 0x3d	; 61
    a2ec:	de b7       	in	r29, 0x3e	; 62
    a2ee:	6a 97       	sbiw	r28, 0x1a	; 26
    a2f0:	cd bf       	out	0x3d, r28	; 61
    a2f2:	de bf       	out	0x3e, r29	; 62
    a2f4:	6b 8b       	std	Y+19, r22	; 0x13
    a2f6:	7c 8b       	std	Y+20, r23	; 0x14
    a2f8:	8d 8b       	std	Y+21, r24	; 0x15
    a2fa:	9e 8b       	std	Y+22, r25	; 0x16
    a2fc:	4f 8b       	std	Y+23, r20	; 0x17
    a2fe:	58 8f       	std	Y+24, r21	; 0x18
    a300:	29 8f       	std	Y+25, r18	; 0x19
    a302:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a304:	88 e0       	ldi	r24, 0x08	; 8
    a306:	60 e0       	ldi	r22, 0x00	; 0
    a308:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a30c:	80 e0       	ldi	r24, 0x00	; 0
    a30e:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    a312:	81 e0       	ldi	r24, 0x01	; 1
    a314:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    a318:	89 8d       	ldd	r24, Y+25	; 0x19
    a31a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a31c:	99 23       	and	r25, r25
    a31e:	14 f4       	brge	.+4      	; 0xa324 <SD_write_multiple_blocks+0x42>
    a320:	81 50       	subi	r24, 0x01	; 1
    a322:	9e 4f       	sbci	r25, 0xFE	; 254
    a324:	89 2f       	mov	r24, r25
    a326:	99 0f       	add	r25, r25
    a328:	99 0b       	sbc	r25, r25
    a32a:	85 95       	asr	r24
    a32c:	89 83       	std	Y+1, r24	; 0x01
    a32e:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    a330:	89 8d       	ldd	r24, Y+25	; 0x19
    a332:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a334:	20 e0       	ldi	r18, 0x00	; 0
    a336:	32 e0       	ldi	r19, 0x02	; 2
    a338:	b9 01       	movw	r22, r18
    a33a:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a33e:	20 e0       	ldi	r18, 0x00	; 0
    a340:	32 e0       	ldi	r19, 0x02	; 2
    a342:	a9 01       	movw	r20, r18
    a344:	48 1b       	sub	r20, r24
    a346:	59 0b       	sbc	r21, r25
    a348:	ca 01       	movw	r24, r20
    a34a:	8b 83       	std	Y+3, r24	; 0x03
    a34c:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a34e:	8b 81       	ldd	r24, Y+3	; 0x03
    a350:	9c 81       	ldd	r25, Y+4	; 0x04
    a352:	52 e0       	ldi	r21, 0x02	; 2
    a354:	80 30       	cpi	r24, 0x00	; 0
    a356:	95 07       	cpc	r25, r21
    a358:	19 f4       	brne	.+6      	; 0xa360 <SD_write_multiple_blocks+0x7e>
    a35a:	1b 82       	std	Y+3, r1	; 0x03
    a35c:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a35e:	05 c0       	rjmp	.+10     	; 0xa36a <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    a360:	89 81       	ldd	r24, Y+1	; 0x01
    a362:	9a 81       	ldd	r25, Y+2	; 0x02
    a364:	01 96       	adiw	r24, 0x01	; 1
    a366:	89 83       	std	Y+1, r24	; 0x01
    a368:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a36a:	00 00       	nop
    a36c:	2b 89       	ldd	r18, Y+19	; 0x13
    a36e:	3c 89       	ldd	r19, Y+20	; 0x14
    a370:	4d 89       	ldd	r20, Y+21	; 0x15
    a372:	5e 89       	ldd	r21, Y+22	; 0x16
    a374:	89 e1       	ldi	r24, 0x19	; 25
    a376:	ba 01       	movw	r22, r20
    a378:	a9 01       	movw	r20, r18
    a37a:	2f ef       	ldi	r18, 0xFF	; 255
    a37c:	08 e0       	ldi	r16, 0x08	; 8
    a37e:	10 e0       	ldi	r17, 0x00	; 0
    a380:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
    a384:	88 23       	and	r24, r24
    a386:	91 f7       	brne	.-28     	; 0xa36c <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    a388:	1d 82       	std	Y+5, r1	; 0x05
    a38a:	1e 82       	std	Y+6, r1	; 0x06
    a38c:	ba c0       	rjmp	.+372    	; 0xa502 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    a38e:	8f ef       	ldi	r24, 0xFF	; 255
    a390:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a394:	80 93 9a 50 	sts	0x509A, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    a398:	8c ef       	ldi	r24, 0xFC	; 252
    a39a:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a39e:	80 93 9a 50 	sts	0x509A, r24
		if(j == (numSectors-1)){
    a3a2:	89 81       	ldd	r24, Y+1	; 0x01
    a3a4:	9a 81       	ldd	r25, Y+2	; 0x02
    a3a6:	9c 01       	movw	r18, r24
    a3a8:	21 50       	subi	r18, 0x01	; 1
    a3aa:	30 40       	sbci	r19, 0x00	; 0
    a3ac:	8d 81       	ldd	r24, Y+5	; 0x05
    a3ae:	9e 81       	ldd	r25, Y+6	; 0x06
    a3b0:	28 17       	cp	r18, r24
    a3b2:	39 07       	cpc	r19, r25
    a3b4:	09 f0       	breq	.+2      	; 0xa3b8 <SD_write_multiple_blocks+0xd6>
    a3b6:	54 c0       	rjmp	.+168    	; 0xa460 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a3b8:	1f 82       	std	Y+7, r1	; 0x07
    a3ba:	18 86       	std	Y+8, r1	; 0x08
    a3bc:	25 c0       	rjmp	.+74     	; 0xa408 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a3be:	8f 81       	ldd	r24, Y+7	; 0x07
    a3c0:	98 85       	ldd	r25, Y+8	; 0x08
    a3c2:	2c e0       	ldi	r18, 0x0C	; 12
    a3c4:	30 e0       	ldi	r19, 0x00	; 0
    a3c6:	b9 01       	movw	r22, r18
    a3c8:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a3cc:	8c 01       	movw	r16, r24
    a3ce:	8d 81       	ldd	r24, Y+5	; 0x05
    a3d0:	9e 81       	ldd	r25, Y+6	; 0x06
    a3d2:	9c 01       	movw	r18, r24
    a3d4:	32 2f       	mov	r19, r18
    a3d6:	22 27       	eor	r18, r18
    a3d8:	33 0f       	add	r19, r19
    a3da:	8f 81       	ldd	r24, Y+7	; 0x07
    a3dc:	98 85       	ldd	r25, Y+8	; 0x08
    a3de:	82 0f       	add	r24, r18
    a3e0:	93 1f       	adc	r25, r19
    a3e2:	2f 89       	ldd	r18, Y+23	; 0x17
    a3e4:	38 8d       	ldd	r19, Y+24	; 0x18
    a3e6:	82 0f       	add	r24, r18
    a3e8:	93 1f       	adc	r25, r19
    a3ea:	fc 01       	movw	r30, r24
    a3ec:	80 81       	ld	r24, Z
    a3ee:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a3f2:	28 2f       	mov	r18, r24
    a3f4:	c8 01       	movw	r24, r16
    a3f6:	87 56       	subi	r24, 0x67	; 103
    a3f8:	9f 4a       	sbci	r25, 0xAF	; 175
    a3fa:	fc 01       	movw	r30, r24
    a3fc:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a3fe:	8f 81       	ldd	r24, Y+7	; 0x07
    a400:	98 85       	ldd	r25, Y+8	; 0x08
    a402:	01 96       	adiw	r24, 0x01	; 1
    a404:	8f 83       	std	Y+7, r24	; 0x07
    a406:	98 87       	std	Y+8, r25	; 0x08
    a408:	20 e0       	ldi	r18, 0x00	; 0
    a40a:	32 e0       	ldi	r19, 0x02	; 2
    a40c:	8b 81       	ldd	r24, Y+3	; 0x03
    a40e:	9c 81       	ldd	r25, Y+4	; 0x04
    a410:	28 1b       	sub	r18, r24
    a412:	39 0b       	sbc	r19, r25
    a414:	8f 81       	ldd	r24, Y+7	; 0x07
    a416:	98 85       	ldd	r25, Y+8	; 0x08
    a418:	82 17       	cp	r24, r18
    a41a:	93 07       	cpc	r25, r19
    a41c:	84 f2       	brlt	.-96     	; 0xa3be <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a41e:	19 86       	std	Y+9, r1	; 0x09
    a420:	1a 86       	std	Y+10, r1	; 0x0a
    a422:	16 c0       	rjmp	.+44     	; 0xa450 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a424:	89 85       	ldd	r24, Y+9	; 0x09
    a426:	9a 85       	ldd	r25, Y+10	; 0x0a
    a428:	2c e0       	ldi	r18, 0x0C	; 12
    a42a:	30 e0       	ldi	r19, 0x00	; 0
    a42c:	b9 01       	movw	r22, r18
    a42e:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a432:	8c 01       	movw	r16, r24
    a434:	80 e0       	ldi	r24, 0x00	; 0
    a436:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a43a:	28 2f       	mov	r18, r24
    a43c:	c8 01       	movw	r24, r16
    a43e:	87 56       	subi	r24, 0x67	; 103
    a440:	9f 4a       	sbci	r25, 0xAF	; 175
    a442:	fc 01       	movw	r30, r24
    a444:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a446:	89 85       	ldd	r24, Y+9	; 0x09
    a448:	9a 85       	ldd	r25, Y+10	; 0x0a
    a44a:	01 96       	adiw	r24, 0x01	; 1
    a44c:	89 87       	std	Y+9, r24	; 0x09
    a44e:	9a 87       	std	Y+10, r25	; 0x0a
    a450:	29 85       	ldd	r18, Y+9	; 0x09
    a452:	3a 85       	ldd	r19, Y+10	; 0x0a
    a454:	8b 81       	ldd	r24, Y+3	; 0x03
    a456:	9c 81       	ldd	r25, Y+4	; 0x04
    a458:	28 17       	cp	r18, r24
    a45a:	39 07       	cpc	r19, r25
    a45c:	1c f3       	brlt	.-58     	; 0xa424 <SD_write_multiple_blocks+0x142>
    a45e:	2e c0       	rjmp	.+92     	; 0xa4bc <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a460:	1b 86       	std	Y+11, r1	; 0x0b
    a462:	1c 86       	std	Y+12, r1	; 0x0c
    a464:	25 c0       	rjmp	.+74     	; 0xa4b0 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a466:	8b 85       	ldd	r24, Y+11	; 0x0b
    a468:	9c 85       	ldd	r25, Y+12	; 0x0c
    a46a:	2c e0       	ldi	r18, 0x0C	; 12
    a46c:	30 e0       	ldi	r19, 0x00	; 0
    a46e:	b9 01       	movw	r22, r18
    a470:	0e 94 fc 5e 	call	0xbdf8	; 0xbdf8 <__divmodhi4>
    a474:	8c 01       	movw	r16, r24
    a476:	8d 81       	ldd	r24, Y+5	; 0x05
    a478:	9e 81       	ldd	r25, Y+6	; 0x06
    a47a:	9c 01       	movw	r18, r24
    a47c:	32 2f       	mov	r19, r18
    a47e:	22 27       	eor	r18, r18
    a480:	33 0f       	add	r19, r19
    a482:	8b 85       	ldd	r24, Y+11	; 0x0b
    a484:	9c 85       	ldd	r25, Y+12	; 0x0c
    a486:	82 0f       	add	r24, r18
    a488:	93 1f       	adc	r25, r19
    a48a:	2f 89       	ldd	r18, Y+23	; 0x17
    a48c:	38 8d       	ldd	r19, Y+24	; 0x18
    a48e:	82 0f       	add	r24, r18
    a490:	93 1f       	adc	r25, r19
    a492:	fc 01       	movw	r30, r24
    a494:	80 81       	ld	r24, Z
    a496:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a49a:	28 2f       	mov	r18, r24
    a49c:	c8 01       	movw	r24, r16
    a49e:	87 56       	subi	r24, 0x67	; 103
    a4a0:	9f 4a       	sbci	r25, 0xAF	; 175
    a4a2:	fc 01       	movw	r30, r24
    a4a4:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a4a6:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4a8:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4aa:	01 96       	adiw	r24, 0x01	; 1
    a4ac:	8b 87       	std	Y+11, r24	; 0x0b
    a4ae:	9c 87       	std	Y+12, r25	; 0x0c
    a4b0:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4b2:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4b4:	f2 e0       	ldi	r31, 0x02	; 2
    a4b6:	80 30       	cpi	r24, 0x00	; 0
    a4b8:	9f 07       	cpc	r25, r31
    a4ba:	ac f2       	brlt	.-86     	; 0xa466 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a4bc:	1d 86       	std	Y+13, r1	; 0x0d
    a4be:	1e 86       	std	Y+14, r1	; 0x0e
    a4c0:	0a c0       	rjmp	.+20     	; 0xa4d6 <SD_write_multiple_blocks+0x1f4>
    a4c2:	8f ef       	ldi	r24, 0xFF	; 255
    a4c4:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a4c8:	80 93 9a 50 	sts	0x509A, r24
    a4cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    a4ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    a4d0:	01 96       	adiw	r24, 0x01	; 1
    a4d2:	8d 87       	std	Y+13, r24	; 0x0d
    a4d4:	9e 87       	std	Y+14, r25	; 0x0e
    a4d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    a4d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    a4da:	82 30       	cpi	r24, 0x02	; 2
    a4dc:	91 05       	cpc	r25, r1
    a4de:	8c f3       	brlt	.-30     	; 0xa4c2 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a4e0:	10 92 9a 50 	sts	0x509A, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a4e4:	05 c0       	rjmp	.+10     	; 0xa4f0 <SD_write_multiple_blocks+0x20e>
    a4e6:	8f ef       	ldi	r24, 0xFF	; 255
    a4e8:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a4ec:	80 93 9a 50 	sts	0x509A, r24
    a4f0:	80 91 9a 50 	lds	r24, 0x509A
    a4f4:	8f 3f       	cpi	r24, 0xFF	; 255
    a4f6:	b9 f7       	brne	.-18     	; 0xa4e6 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a4f8:	8d 81       	ldd	r24, Y+5	; 0x05
    a4fa:	9e 81       	ldd	r25, Y+6	; 0x06
    a4fc:	01 96       	adiw	r24, 0x01	; 1
    a4fe:	8d 83       	std	Y+5, r24	; 0x05
    a500:	9e 83       	std	Y+6, r25	; 0x06
    a502:	2d 81       	ldd	r18, Y+5	; 0x05
    a504:	3e 81       	ldd	r19, Y+6	; 0x06
    a506:	89 81       	ldd	r24, Y+1	; 0x01
    a508:	9a 81       	ldd	r25, Y+2	; 0x02
    a50a:	28 17       	cp	r18, r24
    a50c:	39 07       	cpc	r19, r25
    a50e:	0c f4       	brge	.+2      	; 0xa512 <SD_write_multiple_blocks+0x230>
    a510:	3e cf       	rjmp	.-388    	; 0xa38e <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a512:	1f 86       	std	Y+15, r1	; 0x0f
    a514:	18 8a       	std	Y+16, r1	; 0x10
    a516:	0a c0       	rjmp	.+20     	; 0xa52c <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a518:	8f ef       	ldi	r24, 0xFF	; 255
    a51a:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a51e:	80 93 9a 50 	sts	0x509A, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a522:	8f 85       	ldd	r24, Y+15	; 0x0f
    a524:	98 89       	ldd	r25, Y+16	; 0x10
    a526:	01 96       	adiw	r24, 0x01	; 1
    a528:	8f 87       	std	Y+15, r24	; 0x0f
    a52a:	98 8b       	std	Y+16, r25	; 0x10
    a52c:	8f 85       	ldd	r24, Y+15	; 0x0f
    a52e:	98 89       	ldd	r25, Y+16	; 0x10
    a530:	84 30       	cpi	r24, 0x04	; 4
    a532:	91 05       	cpc	r25, r1
    a534:	8c f3       	brlt	.-30     	; 0xa518 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a536:	8d ef       	ldi	r24, 0xFD	; 253
    a538:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a53c:	80 93 9a 50 	sts	0x509A, r24
	for(int i=0;i<4;i++){
    a540:	19 8a       	std	Y+17, r1	; 0x11
    a542:	1a 8a       	std	Y+18, r1	; 0x12
    a544:	0a c0       	rjmp	.+20     	; 0xa55a <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a546:	8f ef       	ldi	r24, 0xFF	; 255
    a548:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a54c:	80 93 9a 50 	sts	0x509A, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a550:	89 89       	ldd	r24, Y+17	; 0x11
    a552:	9a 89       	ldd	r25, Y+18	; 0x12
    a554:	01 96       	adiw	r24, 0x01	; 1
    a556:	89 8b       	std	Y+17, r24	; 0x11
    a558:	9a 8b       	std	Y+18, r25	; 0x12
    a55a:	89 89       	ldd	r24, Y+17	; 0x11
    a55c:	9a 89       	ldd	r25, Y+18	; 0x12
    a55e:	84 30       	cpi	r24, 0x04	; 4
    a560:	91 05       	cpc	r25, r1
    a562:	8c f3       	brlt	.-30     	; 0xa546 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a564:	10 92 9a 50 	sts	0x509A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a568:	05 c0       	rjmp	.+10     	; 0xa574 <SD_write_multiple_blocks+0x292>
    a56a:	8f ef       	ldi	r24, 0xFF	; 255
    a56c:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a570:	80 93 9a 50 	sts	0x509A, r24
    a574:	80 91 9a 50 	lds	r24, 0x509A
    a578:	8f 3f       	cpi	r24, 0xFF	; 255
    a57a:	b9 f7       	brne	.-18     	; 0xa56a <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a57c:	80 e0       	ldi	r24, 0x00	; 0
    a57e:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    a582:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a586:	88 e0       	ldi	r24, 0x08	; 8
    a588:	60 e0       	ldi	r22, 0x00	; 0
    a58a:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
}
    a58e:	6a 96       	adiw	r28, 0x1a	; 26
    a590:	cd bf       	out	0x3d, r28	; 61
    a592:	de bf       	out	0x3e, r29	; 62
    a594:	df 91       	pop	r29
    a596:	cf 91       	pop	r28
    a598:	1f 91       	pop	r17
    a59a:	0f 91       	pop	r16
    a59c:	08 95       	ret

0000a59e <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a59e:	0f 93       	push	r16
    a5a0:	1f 93       	push	r17
    a5a2:	cf 93       	push	r28
    a5a4:	df 93       	push	r29
    a5a6:	cd b7       	in	r28, 0x3d	; 61
    a5a8:	de b7       	in	r29, 0x3e	; 62
    a5aa:	2e 97       	sbiw	r28, 0x0e	; 14
    a5ac:	cd bf       	out	0x3d, r28	; 61
    a5ae:	de bf       	out	0x3e, r29	; 62
    a5b0:	6f 83       	std	Y+7, r22	; 0x07
    a5b2:	78 87       	std	Y+8, r23	; 0x08
    a5b4:	89 87       	std	Y+9, r24	; 0x09
    a5b6:	9a 87       	std	Y+10, r25	; 0x0a
    a5b8:	4b 87       	std	Y+11, r20	; 0x0b
    a5ba:	5c 87       	std	Y+12, r21	; 0x0c
    a5bc:	2d 87       	std	Y+13, r18	; 0x0d
    a5be:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a5c0:	88 e0       	ldi	r24, 0x08	; 8
    a5c2:	60 e0       	ldi	r22, 0x00	; 0
    a5c4:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a5c8:	80 e0       	ldi	r24, 0x00	; 0
    a5ca:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    a5ce:	81 e0       	ldi	r24, 0x01	; 1
    a5d0:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a5d4:	00 00       	nop
    a5d6:	2f 81       	ldd	r18, Y+7	; 0x07
    a5d8:	38 85       	ldd	r19, Y+8	; 0x08
    a5da:	49 85       	ldd	r20, Y+9	; 0x09
    a5dc:	5a 85       	ldd	r21, Y+10	; 0x0a
    a5de:	82 e1       	ldi	r24, 0x12	; 18
    a5e0:	ba 01       	movw	r22, r20
    a5e2:	a9 01       	movw	r20, r18
    a5e4:	2f ef       	ldi	r18, 0xFF	; 255
    a5e6:	08 e0       	ldi	r16, 0x08	; 8
    a5e8:	10 e0       	ldi	r17, 0x00	; 0
    a5ea:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
    a5ee:	88 23       	and	r24, r24
    a5f0:	91 f7       	brne	.-28     	; 0xa5d6 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a5f2:	19 82       	std	Y+1, r1	; 0x01
    a5f4:	1a 82       	std	Y+2, r1	; 0x02
    a5f6:	4b c0       	rjmp	.+150    	; 0xa68e <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a5f8:	8f ef       	ldi	r24, 0xFF	; 255
    a5fa:	80 93 9a 50 	sts	0x509A, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a5fe:	05 c0       	rjmp	.+10     	; 0xa60a <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a600:	8f ef       	ldi	r24, 0xFF	; 255
    a602:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a606:	80 93 9a 50 	sts	0x509A, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a60a:	80 91 9a 50 	lds	r24, 0x509A
    a60e:	8e 3f       	cpi	r24, 0xFE	; 254
    a610:	b9 f7       	brne	.-18     	; 0xa600 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a612:	1b 82       	std	Y+3, r1	; 0x03
    a614:	1c 82       	std	Y+4, r1	; 0x04
    a616:	19 c0       	rjmp	.+50     	; 0xa64a <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a618:	89 81       	ldd	r24, Y+1	; 0x01
    a61a:	9a 81       	ldd	r25, Y+2	; 0x02
    a61c:	9c 01       	movw	r18, r24
    a61e:	32 2f       	mov	r19, r18
    a620:	22 27       	eor	r18, r18
    a622:	33 0f       	add	r19, r19
    a624:	8b 81       	ldd	r24, Y+3	; 0x03
    a626:	9c 81       	ldd	r25, Y+4	; 0x04
    a628:	82 0f       	add	r24, r18
    a62a:	93 1f       	adc	r25, r19
    a62c:	2b 85       	ldd	r18, Y+11	; 0x0b
    a62e:	3c 85       	ldd	r19, Y+12	; 0x0c
    a630:	89 01       	movw	r16, r18
    a632:	08 0f       	add	r16, r24
    a634:	19 1f       	adc	r17, r25
    a636:	8f ef       	ldi	r24, 0xFF	; 255
    a638:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a63c:	f8 01       	movw	r30, r16
    a63e:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a640:	8b 81       	ldd	r24, Y+3	; 0x03
    a642:	9c 81       	ldd	r25, Y+4	; 0x04
    a644:	01 96       	adiw	r24, 0x01	; 1
    a646:	8b 83       	std	Y+3, r24	; 0x03
    a648:	9c 83       	std	Y+4, r25	; 0x04
    a64a:	8b 81       	ldd	r24, Y+3	; 0x03
    a64c:	9c 81       	ldd	r25, Y+4	; 0x04
    a64e:	f2 e0       	ldi	r31, 0x02	; 2
    a650:	80 30       	cpi	r24, 0x00	; 0
    a652:	9f 07       	cpc	r25, r31
    a654:	0c f3       	brlt	.-62     	; 0xa618 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a656:	1d 82       	std	Y+5, r1	; 0x05
    a658:	1e 82       	std	Y+6, r1	; 0x06
    a65a:	0f c0       	rjmp	.+30     	; 0xa67a <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a65c:	8f ef       	ldi	r24, 0xFF	; 255
    a65e:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a662:	28 2f       	mov	r18, r24
    a664:	8d 81       	ldd	r24, Y+5	; 0x05
    a666:	9e 81       	ldd	r25, Y+6	; 0x06
    a668:	87 56       	subi	r24, 0x67	; 103
    a66a:	9f 4a       	sbci	r25, 0xAF	; 175
    a66c:	fc 01       	movw	r30, r24
    a66e:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a670:	8d 81       	ldd	r24, Y+5	; 0x05
    a672:	9e 81       	ldd	r25, Y+6	; 0x06
    a674:	01 96       	adiw	r24, 0x01	; 1
    a676:	8d 83       	std	Y+5, r24	; 0x05
    a678:	9e 83       	std	Y+6, r25	; 0x06
    a67a:	8d 81       	ldd	r24, Y+5	; 0x05
    a67c:	9e 81       	ldd	r25, Y+6	; 0x06
    a67e:	82 30       	cpi	r24, 0x02	; 2
    a680:	91 05       	cpc	r25, r1
    a682:	64 f3       	brlt	.-40     	; 0xa65c <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a684:	89 81       	ldd	r24, Y+1	; 0x01
    a686:	9a 81       	ldd	r25, Y+2	; 0x02
    a688:	01 96       	adiw	r24, 0x01	; 1
    a68a:	89 83       	std	Y+1, r24	; 0x01
    a68c:	9a 83       	std	Y+2, r25	; 0x02
    a68e:	29 81       	ldd	r18, Y+1	; 0x01
    a690:	3a 81       	ldd	r19, Y+2	; 0x02
    a692:	8d 85       	ldd	r24, Y+13	; 0x0d
    a694:	9e 85       	ldd	r25, Y+14	; 0x0e
    a696:	28 17       	cp	r18, r24
    a698:	39 07       	cpc	r19, r25
    a69a:	0c f4       	brge	.+2      	; 0xa69e <SD_read_multiple_blocks+0x100>
    a69c:	ad cf       	rjmp	.-166    	; 0xa5f8 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a69e:	8c e0       	ldi	r24, 0x0C	; 12
    a6a0:	40 e0       	ldi	r20, 0x00	; 0
    a6a2:	50 e0       	ldi	r21, 0x00	; 0
    a6a4:	ba 01       	movw	r22, r20
    a6a6:	2f ef       	ldi	r18, 0xFF	; 255
    a6a8:	08 e0       	ldi	r16, 0x08	; 8
    a6aa:	10 e0       	ldi	r17, 0x00	; 0
    a6ac:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a6b0:	8f ef       	ldi	r24, 0xFF	; 255
    a6b2:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a6b6:	80 93 99 50 	sts	0x5099, r24
	Buffer[1] = FILLER_BYTE;
    a6ba:	10 92 9a 50 	sts	0x509A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a6be:	05 c0       	rjmp	.+10     	; 0xa6ca <SD_read_multiple_blocks+0x12c>
    a6c0:	8f ef       	ldi	r24, 0xFF	; 255
    a6c2:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
    a6c6:	80 93 9a 50 	sts	0x509A, r24
    a6ca:	80 91 9a 50 	lds	r24, 0x509A
    a6ce:	8f 3f       	cpi	r24, 0xFF	; 255
    a6d0:	b9 f7       	brne	.-18     	; 0xa6c0 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a6d2:	80 e0       	ldi	r24, 0x00	; 0
    a6d4:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    a6d8:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a6dc:	88 e0       	ldi	r24, 0x08	; 8
    a6de:	60 e0       	ldi	r22, 0x00	; 0
    a6e0:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
}
    a6e4:	2e 96       	adiw	r28, 0x0e	; 14
    a6e6:	cd bf       	out	0x3d, r28	; 61
    a6e8:	de bf       	out	0x3e, r29	; 62
    a6ea:	df 91       	pop	r29
    a6ec:	cf 91       	pop	r28
    a6ee:	1f 91       	pop	r17
    a6f0:	0f 91       	pop	r16
    a6f2:	08 95       	ret

0000a6f4 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a6f4:	cf 93       	push	r28
    a6f6:	df 93       	push	r29
    a6f8:	cd b7       	in	r28, 0x3d	; 61
    a6fa:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a6fc:	88 e0       	ldi	r24, 0x08	; 8
    a6fe:	60 e0       	ldi	r22, 0x00	; 0
    a700:	0e 94 1f 35 	call	0x6a3e	; 0x6a3e <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a704:	88 e0       	ldi	r24, 0x08	; 8
    a706:	60 e0       	ldi	r22, 0x00	; 0
    a708:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a70c:	80 e0       	ldi	r24, 0x00	; 0
    a70e:	0e 94 bb 39 	call	0x7376	; 0x7376 <SPIInit>
	SPICS(TRUE);
    a712:	81 e0       	ldi	r24, 0x01	; 1
    a714:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a718:	8f ef       	ldi	r24, 0xFF	; 255
    a71a:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <SPI_write>
	SPICS(FALSE);	//stop spi
    a71e:	80 e0       	ldi	r24, 0x00	; 0
    a720:	0e 94 10 3a 	call	0x7420	; 0x7420 <SPICS>
	SPIDisable();
    a724:	0e 94 28 3a 	call	0x7450	; 0x7450 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a728:	80 e0       	ldi	r24, 0x00	; 0
    a72a:	0e 94 04 06 	call	0xc08	; 0xc08 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a72e:	80 e0       	ldi	r24, 0x00	; 0
    a730:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <Ext1Power>
}
    a734:	df 91       	pop	r29
    a736:	cf 91       	pop	r28
    a738:	08 95       	ret

0000a73a <storeFilename>:

void storeFilename(char* str){
    a73a:	cf 93       	push	r28
    a73c:	df 93       	push	r29
    a73e:	00 d0       	rcall	.+0      	; 0xa740 <storeFilename+0x6>
    a740:	0f 92       	push	r0
    a742:	cd b7       	in	r28, 0x3d	; 61
    a744:	de b7       	in	r29, 0x3e	; 62
    a746:	8b 83       	std	Y+3, r24	; 0x03
    a748:	9c 83       	std	Y+4, r25	; 0x04
	int i=0;
    a74a:	19 82       	std	Y+1, r1	; 0x01
    a74c:	1a 82       	std	Y+2, r1	; 0x02
	for (;i<strlen(str) && i<15 ;i++) FileName[i] = str[i];
    a74e:	13 c0       	rjmp	.+38     	; 0xa776 <storeFilename+0x3c>
    a750:	89 81       	ldd	r24, Y+1	; 0x01
    a752:	9a 81       	ldd	r25, Y+2	; 0x02
    a754:	2b 81       	ldd	r18, Y+3	; 0x03
    a756:	3c 81       	ldd	r19, Y+4	; 0x04
    a758:	82 0f       	add	r24, r18
    a75a:	93 1f       	adc	r25, r19
    a75c:	fc 01       	movw	r30, r24
    a75e:	20 81       	ld	r18, Z
    a760:	89 81       	ldd	r24, Y+1	; 0x01
    a762:	9a 81       	ldd	r25, Y+2	; 0x02
    a764:	85 54       	subi	r24, 0x45	; 69
    a766:	9f 4a       	sbci	r25, 0xAF	; 175
    a768:	fc 01       	movw	r30, r24
    a76a:	20 83       	st	Z, r18
    a76c:	89 81       	ldd	r24, Y+1	; 0x01
    a76e:	9a 81       	ldd	r25, Y+2	; 0x02
    a770:	01 96       	adiw	r24, 0x01	; 1
    a772:	89 83       	std	Y+1, r24	; 0x01
    a774:	9a 83       	std	Y+2, r25	; 0x02
    a776:	49 81       	ldd	r20, Y+1	; 0x01
    a778:	5a 81       	ldd	r21, Y+2	; 0x02
    a77a:	8b 81       	ldd	r24, Y+3	; 0x03
    a77c:	9c 81       	ldd	r25, Y+4	; 0x04
    a77e:	9c 01       	movw	r18, r24
    a780:	f9 01       	movw	r30, r18
    a782:	01 90       	ld	r0, Z+
    a784:	00 20       	and	r0, r0
    a786:	e9 f7       	brne	.-6      	; 0xa782 <storeFilename+0x48>
    a788:	cf 01       	movw	r24, r30
    a78a:	01 97       	sbiw	r24, 0x01	; 1
    a78c:	82 1b       	sub	r24, r18
    a78e:	93 0b       	sbc	r25, r19
    a790:	48 17       	cp	r20, r24
    a792:	59 07       	cpc	r21, r25
    a794:	a0 f4       	brcc	.+40     	; 0xa7be <storeFilename+0x84>
    a796:	89 81       	ldd	r24, Y+1	; 0x01
    a798:	9a 81       	ldd	r25, Y+2	; 0x02
    a79a:	8f 30       	cpi	r24, 0x0F	; 15
    a79c:	91 05       	cpc	r25, r1
    a79e:	c4 f2       	brlt	.-80     	; 0xa750 <storeFilename+0x16>
	for (;i<15;i++)	FileName[i] = " ";
    a7a0:	0e c0       	rjmp	.+28     	; 0xa7be <storeFilename+0x84>
    a7a2:	86 e2       	ldi	r24, 0x26	; 38
    a7a4:	90 e2       	ldi	r25, 0x20	; 32
    a7a6:	28 2f       	mov	r18, r24
    a7a8:	89 81       	ldd	r24, Y+1	; 0x01
    a7aa:	9a 81       	ldd	r25, Y+2	; 0x02
    a7ac:	85 54       	subi	r24, 0x45	; 69
    a7ae:	9f 4a       	sbci	r25, 0xAF	; 175
    a7b0:	fc 01       	movw	r30, r24
    a7b2:	20 83       	st	Z, r18
    a7b4:	89 81       	ldd	r24, Y+1	; 0x01
    a7b6:	9a 81       	ldd	r25, Y+2	; 0x02
    a7b8:	01 96       	adiw	r24, 0x01	; 1
    a7ba:	89 83       	std	Y+1, r24	; 0x01
    a7bc:	9a 83       	std	Y+2, r25	; 0x02
    a7be:	89 81       	ldd	r24, Y+1	; 0x01
    a7c0:	9a 81       	ldd	r25, Y+2	; 0x02
    a7c2:	8f 30       	cpi	r24, 0x0F	; 15
    a7c4:	91 05       	cpc	r25, r1
    a7c6:	6c f3       	brlt	.-38     	; 0xa7a2 <storeFilename+0x68>
    a7c8:	24 96       	adiw	r28, 0x04	; 4
    a7ca:	cd bf       	out	0x3d, r28	; 61
    a7cc:	de bf       	out	0x3e, r29	; 62
    a7ce:	df 91       	pop	r29
    a7d0:	cf 91       	pop	r28
    a7d2:	08 95       	ret

0000a7d4 <__muldi3>:
    a7d4:	a0 e3       	ldi	r26, 0x30	; 48
    a7d6:	b0 e0       	ldi	r27, 0x00	; 0
    a7d8:	e0 ef       	ldi	r30, 0xF0	; 240
    a7da:	f3 e5       	ldi	r31, 0x53	; 83
    a7dc:	0c 94 4e 5f 	jmp	0xbe9c	; 0xbe9c <__prologue_saves__+0x4>
    a7e0:	29 8f       	std	Y+25, r18	; 0x19
    a7e2:	3a 8f       	std	Y+26, r19	; 0x1a
    a7e4:	4b 8f       	std	Y+27, r20	; 0x1b
    a7e6:	5c 8f       	std	Y+28, r21	; 0x1c
    a7e8:	6d 8f       	std	Y+29, r22	; 0x1d
    a7ea:	7e 8f       	std	Y+30, r23	; 0x1e
    a7ec:	8f 8f       	std	Y+31, r24	; 0x1f
    a7ee:	98 a3       	lds	r25, 0x58
    a7f0:	a9 8a       	std	Y+17, r10	; 0x11
    a7f2:	ba 8a       	std	Y+18, r11	; 0x12
    a7f4:	cb 8a       	std	Y+19, r12	; 0x13
    a7f6:	dc 8a       	std	Y+20, r13	; 0x14
    a7f8:	ed 8a       	std	Y+21, r14	; 0x15
    a7fa:	fe 8a       	std	Y+22, r15	; 0x16
    a7fc:	0f 8b       	std	Y+23, r16	; 0x17
    a7fe:	18 8f       	std	Y+24, r17	; 0x18
    a800:	09 8d       	ldd	r16, Y+25	; 0x19
    a802:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a804:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a806:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a808:	09 a3       	lds	r16, 0x59
    a80a:	1a a3       	lds	r17, 0x5a
    a80c:	2b a3       	lds	r18, 0x5b
    a80e:	3c a3       	lds	r19, 0x5c
    a810:	68 01       	movw	r12, r16
    a812:	79 01       	movw	r14, r18
    a814:	8f ef       	ldi	r24, 0xFF	; 255
    a816:	9f ef       	ldi	r25, 0xFF	; 255
    a818:	a0 e0       	ldi	r26, 0x00	; 0
    a81a:	b0 e0       	ldi	r27, 0x00	; 0
    a81c:	c8 22       	and	r12, r24
    a81e:	d9 22       	and	r13, r25
    a820:	ea 22       	and	r14, r26
    a822:	fb 22       	and	r15, r27
    a824:	89 01       	movw	r16, r18
    a826:	22 27       	eor	r18, r18
    a828:	33 27       	eor	r19, r19
    a82a:	09 a7       	lds	r16, 0x79
    a82c:	1a a7       	lds	r17, 0x7a
    a82e:	2b a7       	lds	r18, 0x7b
    a830:	3c a7       	lds	r19, 0x7c
    a832:	09 89       	ldd	r16, Y+17	; 0x11
    a834:	1a 89       	ldd	r17, Y+18	; 0x12
    a836:	2b 89       	ldd	r18, Y+19	; 0x13
    a838:	3c 89       	ldd	r19, Y+20	; 0x14
    a83a:	0d a3       	lds	r16, 0x5d
    a83c:	1e a3       	lds	r17, 0x5e
    a83e:	2f a3       	lds	r18, 0x5f
    a840:	38 a7       	lds	r19, 0x78
    a842:	48 01       	movw	r8, r16
    a844:	59 01       	movw	r10, r18
    a846:	88 22       	and	r8, r24
    a848:	99 22       	and	r9, r25
    a84a:	aa 22       	and	r10, r26
    a84c:	bb 22       	and	r11, r27
    a84e:	29 01       	movw	r4, r18
    a850:	66 24       	eor	r6, r6
    a852:	77 24       	eor	r7, r7
    a854:	c5 01       	movw	r24, r10
    a856:	b4 01       	movw	r22, r8
    a858:	a7 01       	movw	r20, r14
    a85a:	96 01       	movw	r18, r12
    a85c:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    a860:	6d a7       	lds	r22, 0x7d
    a862:	7e a7       	lds	r23, 0x7e
    a864:	8f a7       	lds	r24, 0x7f
    a866:	98 ab       	sts	0x58, r25
    a868:	c3 01       	movw	r24, r6
    a86a:	b2 01       	movw	r22, r4
    a86c:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    a870:	6b 01       	movw	r12, r22
    a872:	7c 01       	movw	r14, r24
    a874:	c5 01       	movw	r24, r10
    a876:	b4 01       	movw	r22, r8
    a878:	29 a5       	lds	r18, 0x69
    a87a:	3a a5       	lds	r19, 0x6a
    a87c:	4b a5       	lds	r20, 0x6b
    a87e:	5c a5       	lds	r21, 0x6c
    a880:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    a884:	4b 01       	movw	r8, r22
    a886:	5c 01       	movw	r10, r24
    a888:	c3 01       	movw	r24, r6
    a88a:	b2 01       	movw	r22, r4
    a88c:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    a890:	ab 01       	movw	r20, r22
    a892:	bc 01       	movw	r22, r24
    a894:	c8 0c       	add	r12, r8
    a896:	d9 1c       	adc	r13, r9
    a898:	ea 1c       	adc	r14, r10
    a89a:	fb 1c       	adc	r15, r11
    a89c:	0d a5       	lds	r16, 0x6d
    a89e:	1e a5       	lds	r17, 0x6e
    a8a0:	2f a5       	lds	r18, 0x6f
    a8a2:	38 a9       	sts	0x48, r19
    a8a4:	c9 01       	movw	r24, r18
    a8a6:	aa 27       	eor	r26, r26
    a8a8:	bb 27       	eor	r27, r27
    a8aa:	c8 0e       	add	r12, r24
    a8ac:	d9 1e       	adc	r13, r25
    a8ae:	ea 1e       	adc	r14, r26
    a8b0:	fb 1e       	adc	r15, r27
    a8b2:	c8 14       	cp	r12, r8
    a8b4:	d9 04       	cpc	r13, r9
    a8b6:	ea 04       	cpc	r14, r10
    a8b8:	fb 04       	cpc	r15, r11
    a8ba:	20 f4       	brcc	.+8      	; 0xa8c4 <__muldi3+0xf0>
    a8bc:	40 50       	subi	r20, 0x00	; 0
    a8be:	50 40       	sbci	r21, 0x00	; 0
    a8c0:	6f 4f       	sbci	r22, 0xFF	; 255
    a8c2:	7f 4f       	sbci	r23, 0xFF	; 255
    a8c4:	c7 01       	movw	r24, r14
    a8c6:	aa 27       	eor	r26, r26
    a8c8:	bb 27       	eor	r27, r27
    a8ca:	84 0f       	add	r24, r20
    a8cc:	95 1f       	adc	r25, r21
    a8ce:	a6 1f       	adc	r26, r22
    a8d0:	b7 1f       	adc	r27, r23
    a8d2:	8d 83       	std	Y+5, r24	; 0x05
    a8d4:	9e 83       	std	Y+6, r25	; 0x06
    a8d6:	af 83       	std	Y+7, r26	; 0x07
    a8d8:	b8 87       	std	Y+8, r27	; 0x08
    a8da:	76 01       	movw	r14, r12
    a8dc:	dd 24       	eor	r13, r13
    a8de:	cc 24       	eor	r12, r12
    a8e0:	4d a5       	lds	r20, 0x6d
    a8e2:	5e a5       	lds	r21, 0x6e
    a8e4:	6f a5       	lds	r22, 0x6f
    a8e6:	78 a9       	sts	0x48, r23
    a8e8:	60 70       	andi	r22, 0x00	; 0
    a8ea:	70 70       	andi	r23, 0x00	; 0
    a8ec:	c4 0e       	add	r12, r20
    a8ee:	d5 1e       	adc	r13, r21
    a8f0:	e6 1e       	adc	r14, r22
    a8f2:	f7 1e       	adc	r15, r23
    a8f4:	c9 82       	std	Y+1, r12	; 0x01
    a8f6:	da 82       	std	Y+2, r13	; 0x02
    a8f8:	eb 82       	std	Y+3, r14	; 0x03
    a8fa:	fc 82       	std	Y+4, r15	; 0x04
    a8fc:	1c 2d       	mov	r17, r12
    a8fe:	0a 81       	ldd	r16, Y+2	; 0x02
    a900:	8b 80       	ldd	r8, Y+3	; 0x03
    a902:	4c 80       	ldd	r4, Y+4	; 0x04
    a904:	8d 87       	std	Y+13, r24	; 0x0d
    a906:	8e 81       	ldd	r24, Y+6	; 0x06
    a908:	8e 87       	std	Y+14, r24	; 0x0e
    a90a:	8f 81       	ldd	r24, Y+7	; 0x07
    a90c:	8f 87       	std	Y+15, r24	; 0x0f
    a90e:	88 85       	ldd	r24, Y+8	; 0x08
    a910:	88 8b       	std	Y+16, r24	; 0x10
    a912:	2d 89       	ldd	r18, Y+21	; 0x15
    a914:	3e 89       	ldd	r19, Y+22	; 0x16
    a916:	4f 89       	ldd	r20, Y+23	; 0x17
    a918:	58 8d       	ldd	r21, Y+24	; 0x18
    a91a:	69 a1       	lds	r22, 0x49
    a91c:	7a a1       	lds	r23, 0x4a
    a91e:	8b a1       	lds	r24, 0x4b
    a920:	9c a1       	lds	r25, 0x4c
    a922:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    a926:	6b 01       	movw	r12, r22
    a928:	7c 01       	movw	r14, r24
    a92a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a92c:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a92e:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a930:	58 a1       	lds	r21, 0x48
    a932:	6d a1       	lds	r22, 0x4d
    a934:	7e a1       	lds	r23, 0x4e
    a936:	8f a1       	lds	r24, 0x4f
    a938:	98 a5       	lds	r25, 0x68
    a93a:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    a93e:	dc 01       	movw	r26, r24
    a940:	cb 01       	movw	r24, r22
    a942:	c8 0e       	add	r12, r24
    a944:	d9 1e       	adc	r13, r25
    a946:	ea 1e       	adc	r14, r26
    a948:	fb 1e       	adc	r15, r27
    a94a:	8d 85       	ldd	r24, Y+13	; 0x0d
    a94c:	9e 85       	ldd	r25, Y+14	; 0x0e
    a94e:	af 85       	ldd	r26, Y+15	; 0x0f
    a950:	b8 89       	ldd	r27, Y+16	; 0x10
    a952:	8c 0d       	add	r24, r12
    a954:	9d 1d       	adc	r25, r13
    a956:	ae 1d       	adc	r26, r14
    a958:	bf 1d       	adc	r27, r15
    a95a:	8d 87       	std	Y+13, r24	; 0x0d
    a95c:	9e 87       	std	Y+14, r25	; 0x0e
    a95e:	af 87       	std	Y+15, r26	; 0x0f
    a960:	b8 8b       	std	Y+16, r27	; 0x10
    a962:	68 2f       	mov	r22, r24
    a964:	7e 85       	ldd	r23, Y+14	; 0x0e
    a966:	21 2f       	mov	r18, r17
    a968:	30 2f       	mov	r19, r16
    a96a:	48 2d       	mov	r20, r8
    a96c:	54 2d       	mov	r21, r4
    a96e:	8f 85       	ldd	r24, Y+15	; 0x0f
    a970:	98 89       	ldd	r25, Y+16	; 0x10
    a972:	e0 96       	adiw	r28, 0x30	; 48
    a974:	e0 e1       	ldi	r30, 0x10	; 16
    a976:	0c 94 67 5f 	jmp	0xbece	; 0xbece <__epilogue_restores__+0x4>

0000a97a <__ashldi3>:
    a97a:	cf 92       	push	r12
    a97c:	df 92       	push	r13
    a97e:	ef 92       	push	r14
    a980:	ff 92       	push	r15
    a982:	0f 93       	push	r16
    a984:	cf 93       	push	r28
    a986:	df 93       	push	r29
    a988:	cd b7       	in	r28, 0x3d	; 61
    a98a:	de b7       	in	r29, 0x3e	; 62
    a98c:	60 97       	sbiw	r28, 0x10	; 16
    a98e:	cd bf       	out	0x3d, r28	; 61
    a990:	de bf       	out	0x3e, r29	; 62
    a992:	00 23       	and	r16, r16
    a994:	09 f4       	brne	.+2      	; 0xa998 <__ashldi3+0x1e>
    a996:	5a c0       	rjmp	.+180    	; 0xaa4c <__ashldi3+0xd2>
    a998:	29 87       	std	Y+9, r18	; 0x09
    a99a:	3a 87       	std	Y+10, r19	; 0x0a
    a99c:	4b 87       	std	Y+11, r20	; 0x0b
    a99e:	5c 87       	std	Y+12, r21	; 0x0c
    a9a0:	6d 87       	std	Y+13, r22	; 0x0d
    a9a2:	7e 87       	std	Y+14, r23	; 0x0e
    a9a4:	8f 87       	std	Y+15, r24	; 0x0f
    a9a6:	98 8b       	std	Y+16, r25	; 0x10
    a9a8:	80 e2       	ldi	r24, 0x20	; 32
    a9aa:	80 1b       	sub	r24, r16
    a9ac:	49 85       	ldd	r20, Y+9	; 0x09
    a9ae:	5a 85       	ldd	r21, Y+10	; 0x0a
    a9b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    a9b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    a9b4:	18 16       	cp	r1, r24
    a9b6:	b4 f0       	brlt	.+44     	; 0xa9e4 <__ashldi3+0x6a>
    a9b8:	19 82       	std	Y+1, r1	; 0x01
    a9ba:	1a 82       	std	Y+2, r1	; 0x02
    a9bc:	1b 82       	std	Y+3, r1	; 0x03
    a9be:	1c 82       	std	Y+4, r1	; 0x04
    a9c0:	99 27       	eor	r25, r25
    a9c2:	87 fd       	sbrc	r24, 7
    a9c4:	90 95       	com	r25
    a9c6:	90 95       	com	r25
    a9c8:	81 95       	neg	r24
    a9ca:	9f 4f       	sbci	r25, 0xFF	; 255
    a9cc:	04 c0       	rjmp	.+8      	; 0xa9d6 <__ashldi3+0x5c>
    a9ce:	44 0f       	add	r20, r20
    a9d0:	55 1f       	adc	r21, r21
    a9d2:	66 1f       	adc	r22, r22
    a9d4:	77 1f       	adc	r23, r23
    a9d6:	8a 95       	dec	r24
    a9d8:	d2 f7       	brpl	.-12     	; 0xa9ce <__ashldi3+0x54>
    a9da:	4d 83       	std	Y+5, r20	; 0x05
    a9dc:	5e 83       	std	Y+6, r21	; 0x06
    a9de:	6f 83       	std	Y+7, r22	; 0x07
    a9e0:	78 87       	std	Y+8, r23	; 0x08
    a9e2:	2c c0       	rjmp	.+88     	; 0xaa3c <__ashldi3+0xc2>
    a9e4:	6a 01       	movw	r12, r20
    a9e6:	7b 01       	movw	r14, r22
    a9e8:	00 2e       	mov	r0, r16
    a9ea:	04 c0       	rjmp	.+8      	; 0xa9f4 <__ashldi3+0x7a>
    a9ec:	cc 0c       	add	r12, r12
    a9ee:	dd 1c       	adc	r13, r13
    a9f0:	ee 1c       	adc	r14, r14
    a9f2:	ff 1c       	adc	r15, r15
    a9f4:	0a 94       	dec	r0
    a9f6:	d2 f7       	brpl	.-12     	; 0xa9ec <__ashldi3+0x72>
    a9f8:	c9 82       	std	Y+1, r12	; 0x01
    a9fa:	da 82       	std	Y+2, r13	; 0x02
    a9fc:	eb 82       	std	Y+3, r14	; 0x03
    a9fe:	fc 82       	std	Y+4, r15	; 0x04
    aa00:	6a 01       	movw	r12, r20
    aa02:	7b 01       	movw	r14, r22
    aa04:	04 c0       	rjmp	.+8      	; 0xaa0e <__ashldi3+0x94>
    aa06:	f6 94       	lsr	r15
    aa08:	e7 94       	ror	r14
    aa0a:	d7 94       	ror	r13
    aa0c:	c7 94       	ror	r12
    aa0e:	8a 95       	dec	r24
    aa10:	d2 f7       	brpl	.-12     	; 0xaa06 <__ashldi3+0x8c>
    aa12:	d7 01       	movw	r26, r14
    aa14:	c6 01       	movw	r24, r12
    aa16:	4d 85       	ldd	r20, Y+13	; 0x0d
    aa18:	5e 85       	ldd	r21, Y+14	; 0x0e
    aa1a:	6f 85       	ldd	r22, Y+15	; 0x0f
    aa1c:	78 89       	ldd	r23, Y+16	; 0x10
    aa1e:	04 c0       	rjmp	.+8      	; 0xaa28 <__ashldi3+0xae>
    aa20:	44 0f       	add	r20, r20
    aa22:	55 1f       	adc	r21, r21
    aa24:	66 1f       	adc	r22, r22
    aa26:	77 1f       	adc	r23, r23
    aa28:	0a 95       	dec	r16
    aa2a:	d2 f7       	brpl	.-12     	; 0xaa20 <__ashldi3+0xa6>
    aa2c:	84 2b       	or	r24, r20
    aa2e:	95 2b       	or	r25, r21
    aa30:	a6 2b       	or	r26, r22
    aa32:	b7 2b       	or	r27, r23
    aa34:	8d 83       	std	Y+5, r24	; 0x05
    aa36:	9e 83       	std	Y+6, r25	; 0x06
    aa38:	af 83       	std	Y+7, r26	; 0x07
    aa3a:	b8 87       	std	Y+8, r27	; 0x08
    aa3c:	29 81       	ldd	r18, Y+1	; 0x01
    aa3e:	3a 81       	ldd	r19, Y+2	; 0x02
    aa40:	4b 81       	ldd	r20, Y+3	; 0x03
    aa42:	5c 81       	ldd	r21, Y+4	; 0x04
    aa44:	6d 81       	ldd	r22, Y+5	; 0x05
    aa46:	7e 81       	ldd	r23, Y+6	; 0x06
    aa48:	8f 81       	ldd	r24, Y+7	; 0x07
    aa4a:	98 85       	ldd	r25, Y+8	; 0x08
    aa4c:	60 96       	adiw	r28, 0x10	; 16
    aa4e:	cd bf       	out	0x3d, r28	; 61
    aa50:	de bf       	out	0x3e, r29	; 62
    aa52:	df 91       	pop	r29
    aa54:	cf 91       	pop	r28
    aa56:	0f 91       	pop	r16
    aa58:	ff 90       	pop	r15
    aa5a:	ef 90       	pop	r14
    aa5c:	df 90       	pop	r13
    aa5e:	cf 90       	pop	r12
    aa60:	08 95       	ret

0000aa62 <__ashrdi3>:
    aa62:	0f 93       	push	r16
    aa64:	cf 93       	push	r28
    aa66:	df 93       	push	r29
    aa68:	cd b7       	in	r28, 0x3d	; 61
    aa6a:	de b7       	in	r29, 0x3e	; 62
    aa6c:	60 97       	sbiw	r28, 0x10	; 16
    aa6e:	cd bf       	out	0x3d, r28	; 61
    aa70:	de bf       	out	0x3e, r29	; 62
    aa72:	00 23       	and	r16, r16
    aa74:	09 f4       	brne	.+2      	; 0xaa78 <__ashrdi3+0x16>
    aa76:	56 c0       	rjmp	.+172    	; 0xab24 <__ashrdi3+0xc2>
    aa78:	29 87       	std	Y+9, r18	; 0x09
    aa7a:	3a 87       	std	Y+10, r19	; 0x0a
    aa7c:	4b 87       	std	Y+11, r20	; 0x0b
    aa7e:	5c 87       	std	Y+12, r21	; 0x0c
    aa80:	6d 87       	std	Y+13, r22	; 0x0d
    aa82:	7e 87       	std	Y+14, r23	; 0x0e
    aa84:	8f 87       	std	Y+15, r24	; 0x0f
    aa86:	98 8b       	std	Y+16, r25	; 0x10
    aa88:	20 e2       	ldi	r18, 0x20	; 32
    aa8a:	20 1b       	sub	r18, r16
    aa8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    aa8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    aa90:	af 85       	ldd	r26, Y+15	; 0x0f
    aa92:	b8 89       	ldd	r27, Y+16	; 0x10
    aa94:	ac 01       	movw	r20, r24
    aa96:	bd 01       	movw	r22, r26
    aa98:	12 16       	cp	r1, r18
    aa9a:	b4 f0       	brlt	.+44     	; 0xaac8 <__ashrdi3+0x66>
    aa9c:	77 0f       	add	r23, r23
    aa9e:	44 0b       	sbc	r20, r20
    aaa0:	54 2f       	mov	r21, r20
    aaa2:	ba 01       	movw	r22, r20
    aaa4:	4d 83       	std	Y+5, r20	; 0x05
    aaa6:	5e 83       	std	Y+6, r21	; 0x06
    aaa8:	6f 83       	std	Y+7, r22	; 0x07
    aaaa:	78 87       	std	Y+8, r23	; 0x08
    aaac:	33 27       	eor	r19, r19
    aaae:	27 fd       	sbrc	r18, 7
    aab0:	30 95       	com	r19
    aab2:	30 95       	com	r19
    aab4:	21 95       	neg	r18
    aab6:	3f 4f       	sbci	r19, 0xFF	; 255
    aab8:	04 c0       	rjmp	.+8      	; 0xaac2 <__ashrdi3+0x60>
    aaba:	b5 95       	asr	r27
    aabc:	a7 95       	ror	r26
    aabe:	97 95       	ror	r25
    aac0:	87 95       	ror	r24
    aac2:	2a 95       	dec	r18
    aac4:	d2 f7       	brpl	.-12     	; 0xaaba <__ashrdi3+0x58>
    aac6:	22 c0       	rjmp	.+68     	; 0xab0c <__ashrdi3+0xaa>
    aac8:	00 2e       	mov	r0, r16
    aaca:	04 c0       	rjmp	.+8      	; 0xaad4 <__ashrdi3+0x72>
    aacc:	75 95       	asr	r23
    aace:	67 95       	ror	r22
    aad0:	57 95       	ror	r21
    aad2:	47 95       	ror	r20
    aad4:	0a 94       	dec	r0
    aad6:	d2 f7       	brpl	.-12     	; 0xaacc <__ashrdi3+0x6a>
    aad8:	4d 83       	std	Y+5, r20	; 0x05
    aada:	5e 83       	std	Y+6, r21	; 0x06
    aadc:	6f 83       	std	Y+7, r22	; 0x07
    aade:	78 87       	std	Y+8, r23	; 0x08
    aae0:	04 c0       	rjmp	.+8      	; 0xaaea <__ashrdi3+0x88>
    aae2:	88 0f       	add	r24, r24
    aae4:	99 1f       	adc	r25, r25
    aae6:	aa 1f       	adc	r26, r26
    aae8:	bb 1f       	adc	r27, r27
    aaea:	2a 95       	dec	r18
    aaec:	d2 f7       	brpl	.-12     	; 0xaae2 <__ashrdi3+0x80>
    aaee:	49 85       	ldd	r20, Y+9	; 0x09
    aaf0:	5a 85       	ldd	r21, Y+10	; 0x0a
    aaf2:	6b 85       	ldd	r22, Y+11	; 0x0b
    aaf4:	7c 85       	ldd	r23, Y+12	; 0x0c
    aaf6:	04 c0       	rjmp	.+8      	; 0xab00 <__ashrdi3+0x9e>
    aaf8:	76 95       	lsr	r23
    aafa:	67 95       	ror	r22
    aafc:	57 95       	ror	r21
    aafe:	47 95       	ror	r20
    ab00:	0a 95       	dec	r16
    ab02:	d2 f7       	brpl	.-12     	; 0xaaf8 <__ashrdi3+0x96>
    ab04:	84 2b       	or	r24, r20
    ab06:	95 2b       	or	r25, r21
    ab08:	a6 2b       	or	r26, r22
    ab0a:	b7 2b       	or	r27, r23
    ab0c:	89 83       	std	Y+1, r24	; 0x01
    ab0e:	9a 83       	std	Y+2, r25	; 0x02
    ab10:	ab 83       	std	Y+3, r26	; 0x03
    ab12:	bc 83       	std	Y+4, r27	; 0x04
    ab14:	29 81       	ldd	r18, Y+1	; 0x01
    ab16:	3a 81       	ldd	r19, Y+2	; 0x02
    ab18:	4b 81       	ldd	r20, Y+3	; 0x03
    ab1a:	5c 81       	ldd	r21, Y+4	; 0x04
    ab1c:	6d 81       	ldd	r22, Y+5	; 0x05
    ab1e:	7e 81       	ldd	r23, Y+6	; 0x06
    ab20:	8f 81       	ldd	r24, Y+7	; 0x07
    ab22:	98 85       	ldd	r25, Y+8	; 0x08
    ab24:	60 96       	adiw	r28, 0x10	; 16
    ab26:	cd bf       	out	0x3d, r28	; 61
    ab28:	de bf       	out	0x3e, r29	; 62
    ab2a:	df 91       	pop	r29
    ab2c:	cf 91       	pop	r28
    ab2e:	0f 91       	pop	r16
    ab30:	08 95       	ret

0000ab32 <__divdi3>:
    ab32:	a8 e4       	ldi	r26, 0x48	; 72
    ab34:	b0 e0       	ldi	r27, 0x00	; 0
    ab36:	ef e9       	ldi	r30, 0x9F	; 159
    ab38:	f5 e5       	ldi	r31, 0x55	; 85
    ab3a:	0c 94 4d 5f 	jmp	0xbe9a	; 0xbe9a <__prologue_saves__+0x2>
    ab3e:	f5 01       	movw	r30, r10
    ab40:	29 a3       	lds	r18, 0x59
    ab42:	3a a3       	lds	r19, 0x5a
    ab44:	4b a3       	lds	r20, 0x5b
    ab46:	5c a3       	lds	r21, 0x5c
    ab48:	6d a3       	lds	r22, 0x5d
    ab4a:	7e a3       	lds	r23, 0x5e
    ab4c:	8f a3       	lds	r24, 0x5f
    ab4e:	98 a7       	lds	r25, 0x78
    ab50:	a9 8e       	std	Y+25, r10	; 0x19
    ab52:	fa 8f       	std	Y+26, r31	; 0x1a
    ab54:	cb 8e       	std	Y+27, r12	; 0x1b
    ab56:	dc 8e       	std	Y+28, r13	; 0x1c
    ab58:	ed 8e       	std	Y+29, r14	; 0x1d
    ab5a:	fe 8e       	std	Y+30, r15	; 0x1e
    ab5c:	0f 8f       	std	Y+31, r16	; 0x1f
    ab5e:	18 a3       	lds	r17, 0x58
    ab60:	8d a0       	lds	r24, 0x8d
    ab62:	9e a0       	lds	r25, 0x8e
    ab64:	af a0       	lds	r26, 0x8f
    ab66:	b8 a4       	lds	r27, 0xa8
    ab68:	b7 fe       	sbrs	r11, 7
    ab6a:	67 c0       	rjmp	.+206    	; 0xac3a <__divdi3+0x108>
    ab6c:	21 95       	neg	r18
    ab6e:	b1 e0       	ldi	r27, 0x01	; 1
    ab70:	12 16       	cp	r1, r18
    ab72:	08 f0       	brcs	.+2      	; 0xab76 <__divdi3+0x44>
    ab74:	b0 e0       	ldi	r27, 0x00	; 0
    ab76:	31 95       	neg	r19
    ab78:	a1 e0       	ldi	r26, 0x01	; 1
    ab7a:	13 16       	cp	r1, r19
    ab7c:	08 f0       	brcs	.+2      	; 0xab80 <__divdi3+0x4e>
    ab7e:	a0 e0       	ldi	r26, 0x00	; 0
    ab80:	b3 2e       	mov	r11, r19
    ab82:	bb 1a       	sub	r11, r27
    ab84:	bb 2d       	mov	r27, r11
    ab86:	88 24       	eor	r8, r8
    ab88:	83 94       	inc	r8
    ab8a:	3b 15       	cp	r19, r11
    ab8c:	08 f0       	brcs	.+2      	; 0xab90 <__divdi3+0x5e>
    ab8e:	88 24       	eor	r8, r8
    ab90:	a8 29       	or	r26, r8
    ab92:	41 95       	neg	r20
    ab94:	31 e0       	ldi	r19, 0x01	; 1
    ab96:	14 16       	cp	r1, r20
    ab98:	08 f0       	brcs	.+2      	; 0xab9c <__divdi3+0x6a>
    ab9a:	30 e0       	ldi	r19, 0x00	; 0
    ab9c:	b4 2e       	mov	r11, r20
    ab9e:	ba 1a       	sub	r11, r26
    aba0:	ab 2d       	mov	r26, r11
    aba2:	88 24       	eor	r8, r8
    aba4:	83 94       	inc	r8
    aba6:	4b 15       	cp	r20, r11
    aba8:	08 f0       	brcs	.+2      	; 0xabac <__divdi3+0x7a>
    abaa:	88 24       	eor	r8, r8
    abac:	38 29       	or	r19, r8
    abae:	51 95       	neg	r21
    abb0:	41 e0       	ldi	r20, 0x01	; 1
    abb2:	15 16       	cp	r1, r21
    abb4:	08 f0       	brcs	.+2      	; 0xabb8 <__divdi3+0x86>
    abb6:	40 e0       	ldi	r20, 0x00	; 0
    abb8:	45 2e       	mov	r4, r21
    abba:	43 1a       	sub	r4, r19
    abbc:	31 e0       	ldi	r19, 0x01	; 1
    abbe:	54 15       	cp	r21, r4
    abc0:	08 f0       	brcs	.+2      	; 0xabc4 <__divdi3+0x92>
    abc2:	30 e0       	ldi	r19, 0x00	; 0
    abc4:	43 2b       	or	r20, r19
    abc6:	61 95       	neg	r22
    abc8:	31 e0       	ldi	r19, 0x01	; 1
    abca:	16 16       	cp	r1, r22
    abcc:	08 f0       	brcs	.+2      	; 0xabd0 <__divdi3+0x9e>
    abce:	30 e0       	ldi	r19, 0x00	; 0
    abd0:	86 2e       	mov	r8, r22
    abd2:	84 1a       	sub	r8, r20
    abd4:	41 e0       	ldi	r20, 0x01	; 1
    abd6:	68 15       	cp	r22, r8
    abd8:	08 f0       	brcs	.+2      	; 0xabdc <__divdi3+0xaa>
    abda:	40 e0       	ldi	r20, 0x00	; 0
    abdc:	34 2b       	or	r19, r20
    abde:	71 95       	neg	r23
    abe0:	41 e0       	ldi	r20, 0x01	; 1
    abe2:	17 16       	cp	r1, r23
    abe4:	08 f0       	brcs	.+2      	; 0xabe8 <__divdi3+0xb6>
    abe6:	40 e0       	ldi	r20, 0x00	; 0
    abe8:	57 2f       	mov	r21, r23
    abea:	53 1b       	sub	r21, r19
    abec:	31 e0       	ldi	r19, 0x01	; 1
    abee:	75 17       	cp	r23, r21
    abf0:	08 f0       	brcs	.+2      	; 0xabf4 <__divdi3+0xc2>
    abf2:	30 e0       	ldi	r19, 0x00	; 0
    abf4:	43 2b       	or	r20, r19
    abf6:	81 95       	neg	r24
    abf8:	31 e0       	ldi	r19, 0x01	; 1
    abfa:	18 16       	cp	r1, r24
    abfc:	08 f0       	brcs	.+2      	; 0xac00 <__divdi3+0xce>
    abfe:	30 e0       	ldi	r19, 0x00	; 0
    ac00:	68 2f       	mov	r22, r24
    ac02:	64 1b       	sub	r22, r20
    ac04:	46 2f       	mov	r20, r22
    ac06:	61 e0       	ldi	r22, 0x01	; 1
    ac08:	84 17       	cp	r24, r20
    ac0a:	08 f0       	brcs	.+2      	; 0xac0e <__divdi3+0xdc>
    ac0c:	60 e0       	ldi	r22, 0x00	; 0
    ac0e:	36 2b       	or	r19, r22
    ac10:	91 95       	neg	r25
    ac12:	93 1b       	sub	r25, r19
    ac14:	29 a3       	lds	r18, 0x59
    ac16:	ba a3       	lds	r27, 0x5a
    ac18:	ab a3       	lds	r26, 0x5b
    ac1a:	4c a2       	lds	r20, 0x9c
    ac1c:	8d a2       	lds	r24, 0x9d
    ac1e:	5e a3       	lds	r21, 0x5e
    ac20:	4f a3       	lds	r20, 0x5f
    ac22:	98 a7       	lds	r25, 0x78
    ac24:	8f ef       	ldi	r24, 0xFF	; 255
    ac26:	9f ef       	ldi	r25, 0xFF	; 255
    ac28:	af ef       	ldi	r26, 0xFF	; 255
    ac2a:	bf ef       	ldi	r27, 0xFF	; 255
    ac2c:	25 96       	adiw	r28, 0x05	; 5
    ac2e:	8c af       	sts	0x7c, r24
    ac30:	9d af       	sts	0x7d, r25
    ac32:	ae af       	sts	0x7e, r26
    ac34:	bf af       	sts	0x7f, r27
    ac36:	25 97       	sbiw	r28, 0x05	; 5
    ac38:	06 c0       	rjmp	.+12     	; 0xac46 <__divdi3+0x114>
    ac3a:	25 96       	adiw	r28, 0x05	; 5
    ac3c:	1c ae       	sts	0xbc, r17
    ac3e:	1d ae       	sts	0xbd, r17
    ac40:	1e ae       	sts	0xbe, r17
    ac42:	1f ae       	sts	0xbf, r17
    ac44:	25 97       	sbiw	r28, 0x05	; 5
    ac46:	8d 8d       	ldd	r24, Y+29	; 0x1d
    ac48:	9e 8d       	ldd	r25, Y+30	; 0x1e
    ac4a:	af 8d       	ldd	r26, Y+31	; 0x1f
    ac4c:	b8 a1       	lds	r27, 0x48
    ac4e:	b7 ff       	sbrs	r27, 7
    ac50:	68 c0       	rjmp	.+208    	; 0xad22 <__divdi3+0x1f0>
    ac52:	25 96       	adiw	r28, 0x05	; 5
    ac54:	2c ad       	sts	0x6c, r18
    ac56:	3d ad       	sts	0x6d, r19
    ac58:	4e ad       	sts	0x6e, r20
    ac5a:	5f ad       	sts	0x6f, r21
    ac5c:	25 97       	sbiw	r28, 0x05	; 5
    ac5e:	20 95       	com	r18
    ac60:	30 95       	com	r19
    ac62:	40 95       	com	r20
    ac64:	50 95       	com	r21
    ac66:	25 96       	adiw	r28, 0x05	; 5
    ac68:	2c af       	sts	0x7c, r18
    ac6a:	3d af       	sts	0x7d, r19
    ac6c:	4e af       	sts	0x7e, r20
    ac6e:	5f af       	sts	0x7f, r21
    ac70:	25 97       	sbiw	r28, 0x05	; 5
    ac72:	e1 95       	neg	r30
    ac74:	81 e0       	ldi	r24, 0x01	; 1
    ac76:	1e 16       	cp	r1, r30
    ac78:	08 f0       	brcs	.+2      	; 0xac7c <__divdi3+0x14a>
    ac7a:	80 e0       	ldi	r24, 0x00	; 0
    ac7c:	f1 95       	neg	r31
    ac7e:	91 e0       	ldi	r25, 0x01	; 1
    ac80:	1f 16       	cp	r1, r31
    ac82:	08 f0       	brcs	.+2      	; 0xac86 <__divdi3+0x154>
    ac84:	90 e0       	ldi	r25, 0x00	; 0
    ac86:	4f 2f       	mov	r20, r31
    ac88:	48 1b       	sub	r20, r24
    ac8a:	81 e0       	ldi	r24, 0x01	; 1
    ac8c:	f4 17       	cp	r31, r20
    ac8e:	08 f0       	brcs	.+2      	; 0xac92 <__divdi3+0x160>
    ac90:	80 e0       	ldi	r24, 0x00	; 0
    ac92:	98 2b       	or	r25, r24
    ac94:	c1 94       	neg	r12
    ac96:	81 e0       	ldi	r24, 0x01	; 1
    ac98:	1c 14       	cp	r1, r12
    ac9a:	08 f0       	brcs	.+2      	; 0xac9e <__divdi3+0x16c>
    ac9c:	80 e0       	ldi	r24, 0x00	; 0
    ac9e:	6c 2d       	mov	r22, r12
    aca0:	69 1b       	sub	r22, r25
    aca2:	91 e0       	ldi	r25, 0x01	; 1
    aca4:	c6 16       	cp	r12, r22
    aca6:	08 f0       	brcs	.+2      	; 0xacaa <__divdi3+0x178>
    aca8:	90 e0       	ldi	r25, 0x00	; 0
    acaa:	89 2b       	or	r24, r25
    acac:	d1 94       	neg	r13
    acae:	91 e0       	ldi	r25, 0x01	; 1
    acb0:	1d 14       	cp	r1, r13
    acb2:	08 f0       	brcs	.+2      	; 0xacb6 <__divdi3+0x184>
    acb4:	90 e0       	ldi	r25, 0x00	; 0
    acb6:	5d 2d       	mov	r21, r13
    acb8:	58 1b       	sub	r21, r24
    acba:	81 e0       	ldi	r24, 0x01	; 1
    acbc:	d5 16       	cp	r13, r21
    acbe:	08 f0       	brcs	.+2      	; 0xacc2 <__divdi3+0x190>
    acc0:	80 e0       	ldi	r24, 0x00	; 0
    acc2:	98 2b       	or	r25, r24
    acc4:	e1 94       	neg	r14
    acc6:	81 e0       	ldi	r24, 0x01	; 1
    acc8:	1e 14       	cp	r1, r14
    acca:	08 f0       	brcs	.+2      	; 0xacce <__divdi3+0x19c>
    accc:	80 e0       	ldi	r24, 0x00	; 0
    acce:	3e 2d       	mov	r19, r14
    acd0:	39 1b       	sub	r19, r25
    acd2:	91 e0       	ldi	r25, 0x01	; 1
    acd4:	e3 16       	cp	r14, r19
    acd6:	08 f0       	brcs	.+2      	; 0xacda <__divdi3+0x1a8>
    acd8:	90 e0       	ldi	r25, 0x00	; 0
    acda:	89 2b       	or	r24, r25
    acdc:	f1 94       	neg	r15
    acde:	91 e0       	ldi	r25, 0x01	; 1
    ace0:	1f 14       	cp	r1, r15
    ace2:	08 f0       	brcs	.+2      	; 0xace6 <__divdi3+0x1b4>
    ace4:	90 e0       	ldi	r25, 0x00	; 0
    ace6:	2f 2d       	mov	r18, r15
    ace8:	28 1b       	sub	r18, r24
    acea:	81 e0       	ldi	r24, 0x01	; 1
    acec:	f2 16       	cp	r15, r18
    acee:	08 f0       	brcs	.+2      	; 0xacf2 <__divdi3+0x1c0>
    acf0:	80 e0       	ldi	r24, 0x00	; 0
    acf2:	98 2b       	or	r25, r24
    acf4:	01 95       	neg	r16
    acf6:	81 e0       	ldi	r24, 0x01	; 1
    acf8:	10 16       	cp	r1, r16
    acfa:	08 f0       	brcs	.+2      	; 0xacfe <__divdi3+0x1cc>
    acfc:	80 e0       	ldi	r24, 0x00	; 0
    acfe:	70 2f       	mov	r23, r16
    ad00:	79 1b       	sub	r23, r25
    ad02:	97 2f       	mov	r25, r23
    ad04:	71 e0       	ldi	r23, 0x01	; 1
    ad06:	09 17       	cp	r16, r25
    ad08:	08 f0       	brcs	.+2      	; 0xad0c <__divdi3+0x1da>
    ad0a:	70 e0       	ldi	r23, 0x00	; 0
    ad0c:	87 2b       	or	r24, r23
    ad0e:	11 95       	neg	r17
    ad10:	18 1b       	sub	r17, r24
    ad12:	e9 8f       	std	Y+25, r30	; 0x19
    ad14:	4a 8f       	std	Y+26, r20	; 0x1a
    ad16:	6b 8f       	std	Y+27, r22	; 0x1b
    ad18:	5c 8f       	std	Y+28, r21	; 0x1c
    ad1a:	3d 8f       	std	Y+29, r19	; 0x1d
    ad1c:	2e 8f       	std	Y+30, r18	; 0x1e
    ad1e:	9f 8f       	std	Y+31, r25	; 0x1f
    ad20:	18 a3       	lds	r17, 0x58
    ad22:	79 8d       	ldd	r23, Y+25	; 0x19
    ad24:	6a 8d       	ldd	r22, Y+26	; 0x1a
    ad26:	5b 8d       	ldd	r21, Y+27	; 0x1b
    ad28:	4c 8d       	ldd	r20, Y+28	; 0x1c
    ad2a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    ad2c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    ad2e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    ad30:	88 a1       	lds	r24, 0x48
    ad32:	e9 a1       	lds	r30, 0x49
    ad34:	e9 8b       	std	Y+17, r30	; 0x11
    ad36:	ea a1       	lds	r30, 0x4a
    ad38:	ea 8b       	std	Y+18, r30	; 0x12
    ad3a:	eb a1       	lds	r30, 0x4b
    ad3c:	eb 8b       	std	Y+19, r30	; 0x13
    ad3e:	ec a1       	lds	r30, 0x4c
    ad40:	ec 8b       	std	Y+20, r30	; 0x14
    ad42:	ed a1       	lds	r30, 0x4d
    ad44:	ed 8b       	std	Y+21, r30	; 0x15
    ad46:	ee a1       	lds	r30, 0x4e
    ad48:	ee 8b       	std	Y+22, r30	; 0x16
    ad4a:	ef a1       	lds	r30, 0x4f
    ad4c:	ef 8b       	std	Y+23, r30	; 0x17
    ad4e:	e8 a5       	lds	r30, 0x68
    ad50:	e8 8f       	std	Y+24, r30	; 0x18
    ad52:	79 87       	std	Y+9, r23	; 0x09
    ad54:	6a 87       	std	Y+10, r22	; 0x0a
    ad56:	5b 87       	std	Y+11, r21	; 0x0b
    ad58:	4c 87       	std	Y+12, r20	; 0x0c
    ad5a:	3d 87       	std	Y+13, r19	; 0x0d
    ad5c:	2e 87       	std	Y+14, r18	; 0x0e
    ad5e:	9f 87       	std	Y+15, r25	; 0x0f
    ad60:	88 8b       	std	Y+16, r24	; 0x10
    ad62:	89 84       	ldd	r8, Y+9	; 0x09
    ad64:	9a 84       	ldd	r9, Y+10	; 0x0a
    ad66:	ab 84       	ldd	r10, Y+11	; 0x0b
    ad68:	bc 84       	ldd	r11, Y+12	; 0x0c
    ad6a:	8d 85       	ldd	r24, Y+13	; 0x0d
    ad6c:	9e 85       	ldd	r25, Y+14	; 0x0e
    ad6e:	af 85       	ldd	r26, Y+15	; 0x0f
    ad70:	b8 89       	ldd	r27, Y+16	; 0x10
    ad72:	e9 88       	ldd	r14, Y+17	; 0x11
    ad74:	fa 88       	ldd	r15, Y+18	; 0x12
    ad76:	0b 89       	ldd	r16, Y+19	; 0x13
    ad78:	1c 89       	ldd	r17, Y+20	; 0x14
    ad7a:	ed aa       	sts	0x9d, r30
    ad7c:	fe aa       	sts	0x9e, r31
    ad7e:	0f ab       	sts	0x5f, r16
    ad80:	18 af       	sts	0x78, r17
    ad82:	cd 88       	ldd	r12, Y+21	; 0x15
    ad84:	de 88       	ldd	r13, Y+22	; 0x16
    ad86:	ef 88       	ldd	r14, Y+23	; 0x17
    ad88:	f8 8c       	ldd	r15, Y+24	; 0x18
    ad8a:	00 97       	sbiw	r24, 0x00	; 0
    ad8c:	a1 05       	cpc	r26, r1
    ad8e:	b1 05       	cpc	r27, r1
    ad90:	09 f0       	breq	.+2      	; 0xad94 <__divdi3+0x262>
    ad92:	bd c3       	rjmp	.+1914   	; 0xb50e <__divdi3+0x9dc>
    ad94:	c8 14       	cp	r12, r8
    ad96:	d9 04       	cpc	r13, r9
    ad98:	ea 04       	cpc	r14, r10
    ad9a:	fb 04       	cpc	r15, r11
    ad9c:	08 f0       	brcs	.+2      	; 0xada0 <__divdi3+0x26e>
    ad9e:	4d c1       	rjmp	.+666    	; 0xb03a <__divdi3+0x508>
    ada0:	00 e0       	ldi	r16, 0x00	; 0
    ada2:	80 16       	cp	r8, r16
    ada4:	00 e0       	ldi	r16, 0x00	; 0
    ada6:	90 06       	cpc	r9, r16
    ada8:	01 e0       	ldi	r16, 0x01	; 1
    adaa:	a0 06       	cpc	r10, r16
    adac:	00 e0       	ldi	r16, 0x00	; 0
    adae:	b0 06       	cpc	r11, r16
    adb0:	58 f4       	brcc	.+22     	; 0xadc8 <__divdi3+0x296>
    adb2:	1f ef       	ldi	r17, 0xFF	; 255
    adb4:	81 16       	cp	r8, r17
    adb6:	91 04       	cpc	r9, r1
    adb8:	a1 04       	cpc	r10, r1
    adba:	b1 04       	cpc	r11, r1
    adbc:	09 f0       	breq	.+2      	; 0xadc0 <__divdi3+0x28e>
    adbe:	90 f4       	brcc	.+36     	; 0xade4 <__divdi3+0x2b2>
    adc0:	80 e0       	ldi	r24, 0x00	; 0
    adc2:	90 e0       	ldi	r25, 0x00	; 0
    adc4:	dc 01       	movw	r26, r24
    adc6:	17 c0       	rjmp	.+46     	; 0xadf6 <__divdi3+0x2c4>
    adc8:	20 e0       	ldi	r18, 0x00	; 0
    adca:	82 16       	cp	r8, r18
    adcc:	20 e0       	ldi	r18, 0x00	; 0
    adce:	92 06       	cpc	r9, r18
    add0:	20 e0       	ldi	r18, 0x00	; 0
    add2:	a2 06       	cpc	r10, r18
    add4:	21 e0       	ldi	r18, 0x01	; 1
    add6:	b2 06       	cpc	r11, r18
    add8:	50 f4       	brcc	.+20     	; 0xadee <__divdi3+0x2bc>
    adda:	80 e1       	ldi	r24, 0x10	; 16
    addc:	90 e0       	ldi	r25, 0x00	; 0
    adde:	a0 e0       	ldi	r26, 0x00	; 0
    ade0:	b0 e0       	ldi	r27, 0x00	; 0
    ade2:	09 c0       	rjmp	.+18     	; 0xadf6 <__divdi3+0x2c4>
    ade4:	88 e0       	ldi	r24, 0x08	; 8
    ade6:	90 e0       	ldi	r25, 0x00	; 0
    ade8:	a0 e0       	ldi	r26, 0x00	; 0
    adea:	b0 e0       	ldi	r27, 0x00	; 0
    adec:	04 c0       	rjmp	.+8      	; 0xadf6 <__divdi3+0x2c4>
    adee:	88 e1       	ldi	r24, 0x18	; 24
    adf0:	90 e0       	ldi	r25, 0x00	; 0
    adf2:	a0 e0       	ldi	r26, 0x00	; 0
    adf4:	b0 e0       	ldi	r27, 0x00	; 0
    adf6:	b5 01       	movw	r22, r10
    adf8:	a4 01       	movw	r20, r8
    adfa:	08 2e       	mov	r0, r24
    adfc:	04 c0       	rjmp	.+8      	; 0xae06 <__divdi3+0x2d4>
    adfe:	76 95       	lsr	r23
    ae00:	67 95       	ror	r22
    ae02:	57 95       	ror	r21
    ae04:	47 95       	ror	r20
    ae06:	0a 94       	dec	r0
    ae08:	d2 f7       	brpl	.-12     	; 0xadfe <__divdi3+0x2cc>
    ae0a:	fa 01       	movw	r30, r20
    ae0c:	e8 5d       	subi	r30, 0xD8	; 216
    ae0e:	ff 4d       	sbci	r31, 0xDF	; 223
    ae10:	20 81       	ld	r18, Z
    ae12:	40 e2       	ldi	r20, 0x20	; 32
    ae14:	50 e0       	ldi	r21, 0x00	; 0
    ae16:	60 e0       	ldi	r22, 0x00	; 0
    ae18:	70 e0       	ldi	r23, 0x00	; 0
    ae1a:	48 1b       	sub	r20, r24
    ae1c:	59 0b       	sbc	r21, r25
    ae1e:	6a 0b       	sbc	r22, r26
    ae20:	7b 0b       	sbc	r23, r27
    ae22:	42 1b       	sub	r20, r18
    ae24:	51 09       	sbc	r21, r1
    ae26:	61 09       	sbc	r22, r1
    ae28:	71 09       	sbc	r23, r1
    ae2a:	41 15       	cp	r20, r1
    ae2c:	51 05       	cpc	r21, r1
    ae2e:	61 05       	cpc	r22, r1
    ae30:	71 05       	cpc	r23, r1
    ae32:	a1 f1       	breq	.+104    	; 0xae9c <__divdi3+0x36a>
    ae34:	04 2e       	mov	r0, r20
    ae36:	04 c0       	rjmp	.+8      	; 0xae40 <__divdi3+0x30e>
    ae38:	88 0c       	add	r8, r8
    ae3a:	99 1c       	adc	r9, r9
    ae3c:	aa 1c       	adc	r10, r10
    ae3e:	bb 1c       	adc	r11, r11
    ae40:	0a 94       	dec	r0
    ae42:	d2 f7       	brpl	.-12     	; 0xae38 <__divdi3+0x306>
    ae44:	97 01       	movw	r18, r14
    ae46:	86 01       	movw	r16, r12
    ae48:	04 2e       	mov	r0, r20
    ae4a:	04 c0       	rjmp	.+8      	; 0xae54 <__divdi3+0x322>
    ae4c:	00 0f       	add	r16, r16
    ae4e:	11 1f       	adc	r17, r17
    ae50:	22 1f       	adc	r18, r18
    ae52:	33 1f       	adc	r19, r19
    ae54:	0a 94       	dec	r0
    ae56:	d2 f7       	brpl	.-12     	; 0xae4c <__divdi3+0x31a>
    ae58:	80 e2       	ldi	r24, 0x20	; 32
    ae5a:	90 e0       	ldi	r25, 0x00	; 0
    ae5c:	84 1b       	sub	r24, r20
    ae5e:	95 0b       	sbc	r25, r21
    ae60:	cd a8       	sts	0x8d, r28
    ae62:	de a8       	sts	0x8e, r29
    ae64:	ef a8       	sts	0x8f, r30
    ae66:	f8 ac       	sts	0xa8, r31
    ae68:	04 c0       	rjmp	.+8      	; 0xae72 <__divdi3+0x340>
    ae6a:	f6 94       	lsr	r15
    ae6c:	e7 94       	ror	r14
    ae6e:	d7 94       	ror	r13
    ae70:	c7 94       	ror	r12
    ae72:	8a 95       	dec	r24
    ae74:	d2 f7       	brpl	.-12     	; 0xae6a <__divdi3+0x338>
    ae76:	c0 2a       	or	r12, r16
    ae78:	d1 2a       	or	r13, r17
    ae7a:	e2 2a       	or	r14, r18
    ae7c:	f3 2a       	or	r15, r19
    ae7e:	0d a9       	sts	0x4d, r16
    ae80:	1e a9       	sts	0x4e, r17
    ae82:	2f a9       	sts	0x4f, r18
    ae84:	38 ad       	sts	0x68, r19
    ae86:	04 c0       	rjmp	.+8      	; 0xae90 <__divdi3+0x35e>
    ae88:	00 0f       	add	r16, r16
    ae8a:	11 1f       	adc	r17, r17
    ae8c:	22 1f       	adc	r18, r18
    ae8e:	33 1f       	adc	r19, r19
    ae90:	4a 95       	dec	r20
    ae92:	d2 f7       	brpl	.-12     	; 0xae88 <__divdi3+0x356>
    ae94:	0d ab       	sts	0x5d, r16
    ae96:	1e ab       	sts	0x5e, r17
    ae98:	2f ab       	sts	0x5f, r18
    ae9a:	38 af       	sts	0x78, r19
    ae9c:	25 01       	movw	r4, r10
    ae9e:	66 24       	eor	r6, r6
    aea0:	77 24       	eor	r7, r7
    aea2:	95 01       	movw	r18, r10
    aea4:	84 01       	movw	r16, r8
    aea6:	20 70       	andi	r18, 0x00	; 0
    aea8:	30 70       	andi	r19, 0x00	; 0
    aeaa:	09 ab       	sts	0x59, r16
    aeac:	1a ab       	sts	0x5a, r17
    aeae:	2b ab       	sts	0x5b, r18
    aeb0:	3c ab       	sts	0x5c, r19
    aeb2:	c7 01       	movw	r24, r14
    aeb4:	b6 01       	movw	r22, r12
    aeb6:	a3 01       	movw	r20, r6
    aeb8:	92 01       	movw	r18, r4
    aeba:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    aebe:	2d a7       	lds	r18, 0x7d
    aec0:	3e a7       	lds	r19, 0x7e
    aec2:	4f a7       	lds	r20, 0x7f
    aec4:	58 ab       	sts	0x58, r21
    aec6:	69 a7       	lds	r22, 0x79
    aec8:	7a a7       	lds	r23, 0x7a
    aeca:	8b a7       	lds	r24, 0x7b
    aecc:	9c a7       	lds	r25, 0x7c
    aece:	c7 01       	movw	r24, r14
    aed0:	b6 01       	movw	r22, r12
    aed2:	a3 01       	movw	r20, r6
    aed4:	92 01       	movw	r18, r4
    aed6:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    aeda:	ca 01       	movw	r24, r20
    aedc:	b9 01       	movw	r22, r18
    aede:	29 a9       	sts	0x49, r18
    aee0:	3a a9       	sts	0x4a, r19
    aee2:	4b a9       	sts	0x4b, r20
    aee4:	5c a9       	sts	0x4c, r21
    aee6:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    aeea:	ab 01       	movw	r20, r22
    aeec:	bc 01       	movw	r22, r24
    aeee:	09 a5       	lds	r16, 0x69
    aef0:	1a a5       	lds	r17, 0x6a
    aef2:	2b a5       	lds	r18, 0x6b
    aef4:	3c a5       	lds	r19, 0x6c
    aef6:	78 01       	movw	r14, r16
    aef8:	dd 24       	eor	r13, r13
    aefa:	cc 24       	eor	r12, r12
    aefc:	0d a9       	sts	0x4d, r16
    aefe:	1e a9       	sts	0x4e, r17
    af00:	2f a9       	sts	0x4f, r18
    af02:	38 ad       	sts	0x68, r19
    af04:	c9 01       	movw	r24, r18
    af06:	aa 27       	eor	r26, r26
    af08:	bb 27       	eor	r27, r27
    af0a:	c8 2a       	or	r12, r24
    af0c:	d9 2a       	or	r13, r25
    af0e:	ea 2a       	or	r14, r26
    af10:	fb 2a       	or	r15, r27
    af12:	0d a5       	lds	r16, 0x6d
    af14:	1e a5       	lds	r17, 0x6e
    af16:	2f a5       	lds	r18, 0x6f
    af18:	38 a9       	sts	0x48, r19
    af1a:	c4 16       	cp	r12, r20
    af1c:	d5 06       	cpc	r13, r21
    af1e:	e6 06       	cpc	r14, r22
    af20:	f7 06       	cpc	r15, r23
    af22:	38 f5       	brcc	.+78     	; 0xaf72 <__divdi3+0x440>
    af24:	01 50       	subi	r16, 0x01	; 1
    af26:	10 40       	sbci	r17, 0x00	; 0
    af28:	20 40       	sbci	r18, 0x00	; 0
    af2a:	30 40       	sbci	r19, 0x00	; 0
    af2c:	09 a7       	lds	r16, 0x79
    af2e:	1a a7       	lds	r17, 0x7a
    af30:	2b a7       	lds	r18, 0x7b
    af32:	3c a7       	lds	r19, 0x7c
    af34:	c8 0c       	add	r12, r8
    af36:	d9 1c       	adc	r13, r9
    af38:	ea 1c       	adc	r14, r10
    af3a:	fb 1c       	adc	r15, r11
    af3c:	c8 14       	cp	r12, r8
    af3e:	d9 04       	cpc	r13, r9
    af40:	ea 04       	cpc	r14, r10
    af42:	fb 04       	cpc	r15, r11
    af44:	d0 f0       	brcs	.+52     	; 0xaf7a <__divdi3+0x448>
    af46:	c4 16       	cp	r12, r20
    af48:	d5 06       	cpc	r13, r21
    af4a:	e6 06       	cpc	r14, r22
    af4c:	f7 06       	cpc	r15, r23
    af4e:	a8 f4       	brcc	.+42     	; 0xaf7a <__divdi3+0x448>
    af50:	0d a5       	lds	r16, 0x6d
    af52:	1e a5       	lds	r17, 0x6e
    af54:	2f a5       	lds	r18, 0x6f
    af56:	38 a9       	sts	0x48, r19
    af58:	02 50       	subi	r16, 0x02	; 2
    af5a:	10 40       	sbci	r17, 0x00	; 0
    af5c:	20 40       	sbci	r18, 0x00	; 0
    af5e:	30 40       	sbci	r19, 0x00	; 0
    af60:	09 a7       	lds	r16, 0x79
    af62:	1a a7       	lds	r17, 0x7a
    af64:	2b a7       	lds	r18, 0x7b
    af66:	3c a7       	lds	r19, 0x7c
    af68:	c8 0c       	add	r12, r8
    af6a:	d9 1c       	adc	r13, r9
    af6c:	ea 1c       	adc	r14, r10
    af6e:	fb 1c       	adc	r15, r11
    af70:	04 c0       	rjmp	.+8      	; 0xaf7a <__divdi3+0x448>
    af72:	09 a7       	lds	r16, 0x79
    af74:	1a a7       	lds	r17, 0x7a
    af76:	2b a7       	lds	r18, 0x7b
    af78:	3c a7       	lds	r19, 0x7c
    af7a:	c4 1a       	sub	r12, r20
    af7c:	d5 0a       	sbc	r13, r21
    af7e:	e6 0a       	sbc	r14, r22
    af80:	f7 0a       	sbc	r15, r23
    af82:	c7 01       	movw	r24, r14
    af84:	b6 01       	movw	r22, r12
    af86:	a3 01       	movw	r20, r6
    af88:	92 01       	movw	r18, r4
    af8a:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    af8e:	2d a7       	lds	r18, 0x7d
    af90:	3e a7       	lds	r19, 0x7e
    af92:	4f a7       	lds	r20, 0x7f
    af94:	58 ab       	sts	0x58, r21
    af96:	69 af       	sts	0x79, r22
    af98:	7a af       	sts	0x7a, r23
    af9a:	8b af       	sts	0x7b, r24
    af9c:	9c af       	sts	0x7c, r25
    af9e:	c7 01       	movw	r24, r14
    afa0:	b6 01       	movw	r22, r12
    afa2:	a3 01       	movw	r20, r6
    afa4:	92 01       	movw	r18, r4
    afa6:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    afaa:	ca 01       	movw	r24, r20
    afac:	b9 01       	movw	r22, r18
    afae:	29 a9       	sts	0x49, r18
    afb0:	3a a9       	sts	0x4a, r19
    afb2:	4b a9       	sts	0x4b, r20
    afb4:	5c a9       	sts	0x4c, r21
    afb6:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    afba:	6b 01       	movw	r12, r22
    afbc:	7c 01       	movw	r14, r24
    afbe:	49 ad       	sts	0x69, r20
    afc0:	5a ad       	sts	0x6a, r21
    afc2:	6b ad       	sts	0x6b, r22
    afc4:	7c ad       	sts	0x6c, r23
    afc6:	9a 01       	movw	r18, r20
    afc8:	11 27       	eor	r17, r17
    afca:	00 27       	eor	r16, r16
    afcc:	4d a9       	sts	0x4d, r20
    afce:	5e a9       	sts	0x4e, r21
    afd0:	6f a9       	sts	0x4f, r22
    afd2:	78 ad       	sts	0x68, r23
    afd4:	60 70       	andi	r22, 0x00	; 0
    afd6:	70 70       	andi	r23, 0x00	; 0
    afd8:	04 2b       	or	r16, r20
    afda:	15 2b       	or	r17, r21
    afdc:	26 2b       	or	r18, r22
    afde:	37 2b       	or	r19, r23
    afe0:	8d a5       	lds	r24, 0x6d
    afe2:	9e a5       	lds	r25, 0x6e
    afe4:	af a5       	lds	r26, 0x6f
    afe6:	b8 a9       	sts	0x48, r27
    afe8:	0c 15       	cp	r16, r12
    afea:	1d 05       	cpc	r17, r13
    afec:	2e 05       	cpc	r18, r14
    afee:	3f 05       	cpc	r19, r15
    aff0:	c0 f4       	brcc	.+48     	; 0xb022 <__divdi3+0x4f0>
    aff2:	01 97       	sbiw	r24, 0x01	; 1
    aff4:	a1 09       	sbc	r26, r1
    aff6:	b1 09       	sbc	r27, r1
    aff8:	08 0d       	add	r16, r8
    affa:	19 1d       	adc	r17, r9
    affc:	2a 1d       	adc	r18, r10
    affe:	3b 1d       	adc	r19, r11
    b000:	08 15       	cp	r16, r8
    b002:	19 05       	cpc	r17, r9
    b004:	2a 05       	cpc	r18, r10
    b006:	3b 05       	cpc	r19, r11
    b008:	60 f0       	brcs	.+24     	; 0xb022 <__divdi3+0x4f0>
    b00a:	0c 15       	cp	r16, r12
    b00c:	1d 05       	cpc	r17, r13
    b00e:	2e 05       	cpc	r18, r14
    b010:	3f 05       	cpc	r19, r15
    b012:	38 f4       	brcc	.+14     	; 0xb022 <__divdi3+0x4f0>
    b014:	8d a5       	lds	r24, 0x6d
    b016:	9e a5       	lds	r25, 0x6e
    b018:	af a5       	lds	r26, 0x6f
    b01a:	b8 a9       	sts	0x48, r27
    b01c:	02 97       	sbiw	r24, 0x02	; 2
    b01e:	a1 09       	sbc	r26, r1
    b020:	b1 09       	sbc	r27, r1
    b022:	09 a5       	lds	r16, 0x69
    b024:	1a a5       	lds	r17, 0x6a
    b026:	2b a5       	lds	r18, 0x6b
    b028:	3c a5       	lds	r19, 0x6c
    b02a:	78 01       	movw	r14, r16
    b02c:	dd 24       	eor	r13, r13
    b02e:	cc 24       	eor	r12, r12
    b030:	c8 2a       	or	r12, r24
    b032:	d9 2a       	or	r13, r25
    b034:	ea 2a       	or	r14, r26
    b036:	fb 2a       	or	r15, r27
    b038:	b7 c4       	rjmp	.+2414   	; 0xb9a8 <__divdi3+0xe76>
    b03a:	81 14       	cp	r8, r1
    b03c:	91 04       	cpc	r9, r1
    b03e:	a1 04       	cpc	r10, r1
    b040:	b1 04       	cpc	r11, r1
    b042:	51 f4       	brne	.+20     	; 0xb058 <__divdi3+0x526>
    b044:	61 e0       	ldi	r22, 0x01	; 1
    b046:	70 e0       	ldi	r23, 0x00	; 0
    b048:	80 e0       	ldi	r24, 0x00	; 0
    b04a:	90 e0       	ldi	r25, 0x00	; 0
    b04c:	a5 01       	movw	r20, r10
    b04e:	94 01       	movw	r18, r8
    b050:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b054:	49 01       	movw	r8, r18
    b056:	5a 01       	movw	r10, r20
    b058:	10 e0       	ldi	r17, 0x00	; 0
    b05a:	81 16       	cp	r8, r17
    b05c:	10 e0       	ldi	r17, 0x00	; 0
    b05e:	91 06       	cpc	r9, r17
    b060:	11 e0       	ldi	r17, 0x01	; 1
    b062:	a1 06       	cpc	r10, r17
    b064:	10 e0       	ldi	r17, 0x00	; 0
    b066:	b1 06       	cpc	r11, r17
    b068:	58 f4       	brcc	.+22     	; 0xb080 <__divdi3+0x54e>
    b06a:	2f ef       	ldi	r18, 0xFF	; 255
    b06c:	82 16       	cp	r8, r18
    b06e:	91 04       	cpc	r9, r1
    b070:	a1 04       	cpc	r10, r1
    b072:	b1 04       	cpc	r11, r1
    b074:	09 f0       	breq	.+2      	; 0xb078 <__divdi3+0x546>
    b076:	90 f4       	brcc	.+36     	; 0xb09c <__divdi3+0x56a>
    b078:	80 e0       	ldi	r24, 0x00	; 0
    b07a:	90 e0       	ldi	r25, 0x00	; 0
    b07c:	dc 01       	movw	r26, r24
    b07e:	17 c0       	rjmp	.+46     	; 0xb0ae <__divdi3+0x57c>
    b080:	30 e0       	ldi	r19, 0x00	; 0
    b082:	83 16       	cp	r8, r19
    b084:	30 e0       	ldi	r19, 0x00	; 0
    b086:	93 06       	cpc	r9, r19
    b088:	30 e0       	ldi	r19, 0x00	; 0
    b08a:	a3 06       	cpc	r10, r19
    b08c:	31 e0       	ldi	r19, 0x01	; 1
    b08e:	b3 06       	cpc	r11, r19
    b090:	50 f4       	brcc	.+20     	; 0xb0a6 <__divdi3+0x574>
    b092:	80 e1       	ldi	r24, 0x10	; 16
    b094:	90 e0       	ldi	r25, 0x00	; 0
    b096:	a0 e0       	ldi	r26, 0x00	; 0
    b098:	b0 e0       	ldi	r27, 0x00	; 0
    b09a:	09 c0       	rjmp	.+18     	; 0xb0ae <__divdi3+0x57c>
    b09c:	88 e0       	ldi	r24, 0x08	; 8
    b09e:	90 e0       	ldi	r25, 0x00	; 0
    b0a0:	a0 e0       	ldi	r26, 0x00	; 0
    b0a2:	b0 e0       	ldi	r27, 0x00	; 0
    b0a4:	04 c0       	rjmp	.+8      	; 0xb0ae <__divdi3+0x57c>
    b0a6:	88 e1       	ldi	r24, 0x18	; 24
    b0a8:	90 e0       	ldi	r25, 0x00	; 0
    b0aa:	a0 e0       	ldi	r26, 0x00	; 0
    b0ac:	b0 e0       	ldi	r27, 0x00	; 0
    b0ae:	b5 01       	movw	r22, r10
    b0b0:	a4 01       	movw	r20, r8
    b0b2:	08 2e       	mov	r0, r24
    b0b4:	04 c0       	rjmp	.+8      	; 0xb0be <__divdi3+0x58c>
    b0b6:	76 95       	lsr	r23
    b0b8:	67 95       	ror	r22
    b0ba:	57 95       	ror	r21
    b0bc:	47 95       	ror	r20
    b0be:	0a 94       	dec	r0
    b0c0:	d2 f7       	brpl	.-12     	; 0xb0b6 <__divdi3+0x584>
    b0c2:	fa 01       	movw	r30, r20
    b0c4:	e8 5d       	subi	r30, 0xD8	; 216
    b0c6:	ff 4d       	sbci	r31, 0xDF	; 223
    b0c8:	20 81       	ld	r18, Z
    b0ca:	ac 01       	movw	r20, r24
    b0cc:	bd 01       	movw	r22, r26
    b0ce:	42 0f       	add	r20, r18
    b0d0:	51 1d       	adc	r21, r1
    b0d2:	61 1d       	adc	r22, r1
    b0d4:	71 1d       	adc	r23, r1
    b0d6:	80 e2       	ldi	r24, 0x20	; 32
    b0d8:	90 e0       	ldi	r25, 0x00	; 0
    b0da:	a0 e0       	ldi	r26, 0x00	; 0
    b0dc:	b0 e0       	ldi	r27, 0x00	; 0
    b0de:	84 1b       	sub	r24, r20
    b0e0:	95 0b       	sbc	r25, r21
    b0e2:	a6 0b       	sbc	r26, r22
    b0e4:	b7 0b       	sbc	r27, r23
    b0e6:	51 f4       	brne	.+20     	; 0xb0fc <__divdi3+0x5ca>
    b0e8:	c8 18       	sub	r12, r8
    b0ea:	d9 08       	sbc	r13, r9
    b0ec:	ea 08       	sbc	r14, r10
    b0ee:	fb 08       	sbc	r15, r11
    b0f0:	f1 e0       	ldi	r31, 0x01	; 1
    b0f2:	4f 2e       	mov	r4, r31
    b0f4:	51 2c       	mov	r5, r1
    b0f6:	61 2c       	mov	r6, r1
    b0f8:	71 2c       	mov	r7, r1
    b0fa:	28 c1       	rjmp	.+592    	; 0xb34c <__divdi3+0x81a>
    b0fc:	08 2e       	mov	r0, r24
    b0fe:	04 c0       	rjmp	.+8      	; 0xb108 <__divdi3+0x5d6>
    b100:	88 0c       	add	r8, r8
    b102:	99 1c       	adc	r9, r9
    b104:	aa 1c       	adc	r10, r10
    b106:	bb 1c       	adc	r11, r11
    b108:	0a 94       	dec	r0
    b10a:	d2 f7       	brpl	.-12     	; 0xb100 <__divdi3+0x5ce>
    b10c:	97 01       	movw	r18, r14
    b10e:	86 01       	movw	r16, r12
    b110:	04 2e       	mov	r0, r20
    b112:	04 c0       	rjmp	.+8      	; 0xb11c <__divdi3+0x5ea>
    b114:	36 95       	lsr	r19
    b116:	27 95       	ror	r18
    b118:	17 95       	ror	r17
    b11a:	07 95       	ror	r16
    b11c:	0a 94       	dec	r0
    b11e:	d2 f7       	brpl	.-12     	; 0xb114 <__divdi3+0x5e2>
    b120:	09 ab       	sts	0x59, r16
    b122:	1a ab       	sts	0x5a, r17
    b124:	2b ab       	sts	0x5b, r18
    b126:	3c ab       	sts	0x5c, r19
    b128:	97 01       	movw	r18, r14
    b12a:	86 01       	movw	r16, r12
    b12c:	08 2e       	mov	r0, r24
    b12e:	04 c0       	rjmp	.+8      	; 0xb138 <__divdi3+0x606>
    b130:	00 0f       	add	r16, r16
    b132:	11 1f       	adc	r17, r17
    b134:	22 1f       	adc	r18, r18
    b136:	33 1f       	adc	r19, r19
    b138:	0a 94       	dec	r0
    b13a:	d2 f7       	brpl	.-12     	; 0xb130 <__divdi3+0x5fe>
    b13c:	0d a7       	lds	r16, 0x7d
    b13e:	1e a7       	lds	r17, 0x7e
    b140:	2f a7       	lds	r18, 0x7f
    b142:	38 ab       	sts	0x58, r19
    b144:	ed a8       	sts	0x8d, r30
    b146:	fe a8       	sts	0x8e, r31
    b148:	0f a9       	sts	0x4f, r16
    b14a:	18 ad       	sts	0x68, r17
    b14c:	04 c0       	rjmp	.+8      	; 0xb156 <__divdi3+0x624>
    b14e:	16 95       	lsr	r17
    b150:	07 95       	ror	r16
    b152:	f7 94       	ror	r15
    b154:	e7 94       	ror	r14
    b156:	4a 95       	dec	r20
    b158:	d2 f7       	brpl	.-12     	; 0xb14e <__divdi3+0x61c>
    b15a:	b8 01       	movw	r22, r16
    b15c:	a7 01       	movw	r20, r14
    b15e:	0d a5       	lds	r16, 0x6d
    b160:	1e a5       	lds	r17, 0x6e
    b162:	2f a5       	lds	r18, 0x6f
    b164:	38 a9       	sts	0x48, r19
    b166:	04 2b       	or	r16, r20
    b168:	15 2b       	or	r17, r21
    b16a:	26 2b       	or	r18, r22
    b16c:	37 2b       	or	r19, r23
    b16e:	0d a7       	lds	r16, 0x7d
    b170:	1e a7       	lds	r17, 0x7e
    b172:	2f a7       	lds	r18, 0x7f
    b174:	38 ab       	sts	0x58, r19
    b176:	ed a8       	sts	0x8d, r30
    b178:	fe a8       	sts	0x8e, r31
    b17a:	0f a9       	sts	0x4f, r16
    b17c:	18 ad       	sts	0x68, r17
    b17e:	04 c0       	rjmp	.+8      	; 0xb188 <__divdi3+0x656>
    b180:	ee 0c       	add	r14, r14
    b182:	ff 1c       	adc	r15, r15
    b184:	00 1f       	adc	r16, r16
    b186:	11 1f       	adc	r17, r17
    b188:	8a 95       	dec	r24
    b18a:	d2 f7       	brpl	.-12     	; 0xb180 <__divdi3+0x64e>
    b18c:	ed aa       	sts	0x9d, r30
    b18e:	fe aa       	sts	0x9e, r31
    b190:	0f ab       	sts	0x5f, r16
    b192:	18 af       	sts	0x78, r17
    b194:	25 01       	movw	r4, r10
    b196:	66 24       	eor	r6, r6
    b198:	77 24       	eor	r7, r7
    b19a:	95 01       	movw	r18, r10
    b19c:	84 01       	movw	r16, r8
    b19e:	20 70       	andi	r18, 0x00	; 0
    b1a0:	30 70       	andi	r19, 0x00	; 0
    b1a2:	09 af       	sts	0x79, r16
    b1a4:	1a af       	sts	0x7a, r17
    b1a6:	2b af       	sts	0x7b, r18
    b1a8:	3c af       	sts	0x7c, r19
    b1aa:	69 a9       	sts	0x49, r22
    b1ac:	7a a9       	sts	0x4a, r23
    b1ae:	8b a9       	sts	0x4b, r24
    b1b0:	9c a9       	sts	0x4c, r25
    b1b2:	a3 01       	movw	r20, r6
    b1b4:	92 01       	movw	r18, r4
    b1b6:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b1ba:	29 a7       	lds	r18, 0x79
    b1bc:	3a a7       	lds	r19, 0x7a
    b1be:	4b a7       	lds	r20, 0x7b
    b1c0:	5c a7       	lds	r21, 0x7c
    b1c2:	6b 01       	movw	r12, r22
    b1c4:	7c 01       	movw	r14, r24
    b1c6:	69 a9       	sts	0x49, r22
    b1c8:	7a a9       	sts	0x4a, r23
    b1ca:	8b a9       	sts	0x4b, r24
    b1cc:	9c a9       	sts	0x4c, r25
    b1ce:	a3 01       	movw	r20, r6
    b1d0:	92 01       	movw	r18, r4
    b1d2:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b1d6:	ca 01       	movw	r24, r20
    b1d8:	b9 01       	movw	r22, r18
    b1da:	29 ad       	sts	0x69, r18
    b1dc:	3a ad       	sts	0x6a, r19
    b1de:	4b ad       	sts	0x6b, r20
    b1e0:	5c ad       	sts	0x6c, r21
    b1e2:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b1e6:	ab 01       	movw	r20, r22
    b1e8:	bc 01       	movw	r22, r24
    b1ea:	76 01       	movw	r14, r12
    b1ec:	dd 24       	eor	r13, r13
    b1ee:	cc 24       	eor	r12, r12
    b1f0:	0d a5       	lds	r16, 0x6d
    b1f2:	1e a5       	lds	r17, 0x6e
    b1f4:	2f a5       	lds	r18, 0x6f
    b1f6:	38 a9       	sts	0x48, r19
    b1f8:	c9 01       	movw	r24, r18
    b1fa:	aa 27       	eor	r26, r26
    b1fc:	bb 27       	eor	r27, r27
    b1fe:	c8 2a       	or	r12, r24
    b200:	d9 2a       	or	r13, r25
    b202:	ea 2a       	or	r14, r26
    b204:	fb 2a       	or	r15, r27
    b206:	09 a5       	lds	r16, 0x69
    b208:	1a a5       	lds	r17, 0x6a
    b20a:	2b a5       	lds	r18, 0x6b
    b20c:	3c a5       	lds	r19, 0x6c
    b20e:	c4 16       	cp	r12, r20
    b210:	d5 06       	cpc	r13, r21
    b212:	e6 06       	cpc	r14, r22
    b214:	f7 06       	cpc	r15, r23
    b216:	38 f5       	brcc	.+78     	; 0xb266 <__divdi3+0x734>
    b218:	01 50       	subi	r16, 0x01	; 1
    b21a:	10 40       	sbci	r17, 0x00	; 0
    b21c:	20 40       	sbci	r18, 0x00	; 0
    b21e:	30 40       	sbci	r19, 0x00	; 0
    b220:	09 ab       	sts	0x59, r16
    b222:	1a ab       	sts	0x5a, r17
    b224:	2b ab       	sts	0x5b, r18
    b226:	3c ab       	sts	0x5c, r19
    b228:	c8 0c       	add	r12, r8
    b22a:	d9 1c       	adc	r13, r9
    b22c:	ea 1c       	adc	r14, r10
    b22e:	fb 1c       	adc	r15, r11
    b230:	c8 14       	cp	r12, r8
    b232:	d9 04       	cpc	r13, r9
    b234:	ea 04       	cpc	r14, r10
    b236:	fb 04       	cpc	r15, r11
    b238:	d0 f0       	brcs	.+52     	; 0xb26e <__divdi3+0x73c>
    b23a:	c4 16       	cp	r12, r20
    b23c:	d5 06       	cpc	r13, r21
    b23e:	e6 06       	cpc	r14, r22
    b240:	f7 06       	cpc	r15, r23
    b242:	a8 f4       	brcc	.+42     	; 0xb26e <__divdi3+0x73c>
    b244:	09 a5       	lds	r16, 0x69
    b246:	1a a5       	lds	r17, 0x6a
    b248:	2b a5       	lds	r18, 0x6b
    b24a:	3c a5       	lds	r19, 0x6c
    b24c:	02 50       	subi	r16, 0x02	; 2
    b24e:	10 40       	sbci	r17, 0x00	; 0
    b250:	20 40       	sbci	r18, 0x00	; 0
    b252:	30 40       	sbci	r19, 0x00	; 0
    b254:	09 ab       	sts	0x59, r16
    b256:	1a ab       	sts	0x5a, r17
    b258:	2b ab       	sts	0x5b, r18
    b25a:	3c ab       	sts	0x5c, r19
    b25c:	c8 0c       	add	r12, r8
    b25e:	d9 1c       	adc	r13, r9
    b260:	ea 1c       	adc	r14, r10
    b262:	fb 1c       	adc	r15, r11
    b264:	04 c0       	rjmp	.+8      	; 0xb26e <__divdi3+0x73c>
    b266:	09 ab       	sts	0x59, r16
    b268:	1a ab       	sts	0x5a, r17
    b26a:	2b ab       	sts	0x5b, r18
    b26c:	3c ab       	sts	0x5c, r19
    b26e:	c4 1a       	sub	r12, r20
    b270:	d5 0a       	sbc	r13, r21
    b272:	e6 0a       	sbc	r14, r22
    b274:	f7 0a       	sbc	r15, r23
    b276:	c7 01       	movw	r24, r14
    b278:	b6 01       	movw	r22, r12
    b27a:	a3 01       	movw	r20, r6
    b27c:	92 01       	movw	r18, r4
    b27e:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b282:	29 a7       	lds	r18, 0x79
    b284:	3a a7       	lds	r19, 0x7a
    b286:	4b a7       	lds	r20, 0x7b
    b288:	5c a7       	lds	r21, 0x7c
    b28a:	21 96       	adiw	r28, 0x01	; 1
    b28c:	6c af       	sts	0x7c, r22
    b28e:	7d af       	sts	0x7d, r23
    b290:	8e af       	sts	0x7e, r24
    b292:	9f af       	sts	0x7f, r25
    b294:	21 97       	sbiw	r28, 0x01	; 1
    b296:	c7 01       	movw	r24, r14
    b298:	b6 01       	movw	r22, r12
    b29a:	a3 01       	movw	r20, r6
    b29c:	92 01       	movw	r18, r4
    b29e:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b2a2:	ca 01       	movw	r24, r20
    b2a4:	b9 01       	movw	r22, r18
    b2a6:	29 ad       	sts	0x69, r18
    b2a8:	3a ad       	sts	0x6a, r19
    b2aa:	4b ad       	sts	0x6b, r20
    b2ac:	5c ad       	sts	0x6c, r21
    b2ae:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b2b2:	8b 01       	movw	r16, r22
    b2b4:	9c 01       	movw	r18, r24
    b2b6:	21 96       	adiw	r28, 0x01	; 1
    b2b8:	4c ad       	sts	0x6c, r20
    b2ba:	5d ad       	sts	0x6d, r21
    b2bc:	6e ad       	sts	0x6e, r22
    b2be:	7f ad       	sts	0x6f, r23
    b2c0:	21 97       	sbiw	r28, 0x01	; 1
    b2c2:	da 01       	movw	r26, r20
    b2c4:	99 27       	eor	r25, r25
    b2c6:	88 27       	eor	r24, r24
    b2c8:	4d a5       	lds	r20, 0x6d
    b2ca:	5e a5       	lds	r21, 0x6e
    b2cc:	6f a5       	lds	r22, 0x6f
    b2ce:	78 a9       	sts	0x48, r23
    b2d0:	60 70       	andi	r22, 0x00	; 0
    b2d2:	70 70       	andi	r23, 0x00	; 0
    b2d4:	84 2b       	or	r24, r20
    b2d6:	95 2b       	or	r25, r21
    b2d8:	a6 2b       	or	r26, r22
    b2da:	b7 2b       	or	r27, r23
    b2dc:	49 a5       	lds	r20, 0x69
    b2de:	5a a5       	lds	r21, 0x6a
    b2e0:	6b a5       	lds	r22, 0x6b
    b2e2:	7c a5       	lds	r23, 0x6c
    b2e4:	80 17       	cp	r24, r16
    b2e6:	91 07       	cpc	r25, r17
    b2e8:	a2 07       	cpc	r26, r18
    b2ea:	b3 07       	cpc	r27, r19
    b2ec:	f0 f4       	brcc	.+60     	; 0xb32a <__divdi3+0x7f8>
    b2ee:	41 50       	subi	r20, 0x01	; 1
    b2f0:	50 40       	sbci	r21, 0x00	; 0
    b2f2:	60 40       	sbci	r22, 0x00	; 0
    b2f4:	70 40       	sbci	r23, 0x00	; 0
    b2f6:	88 0d       	add	r24, r8
    b2f8:	99 1d       	adc	r25, r9
    b2fa:	aa 1d       	adc	r26, r10
    b2fc:	bb 1d       	adc	r27, r11
    b2fe:	88 15       	cp	r24, r8
    b300:	99 05       	cpc	r25, r9
    b302:	aa 05       	cpc	r26, r10
    b304:	bb 05       	cpc	r27, r11
    b306:	88 f0       	brcs	.+34     	; 0xb32a <__divdi3+0x7f8>
    b308:	80 17       	cp	r24, r16
    b30a:	91 07       	cpc	r25, r17
    b30c:	a2 07       	cpc	r26, r18
    b30e:	b3 07       	cpc	r27, r19
    b310:	60 f4       	brcc	.+24     	; 0xb32a <__divdi3+0x7f8>
    b312:	49 a5       	lds	r20, 0x69
    b314:	5a a5       	lds	r21, 0x6a
    b316:	6b a5       	lds	r22, 0x6b
    b318:	7c a5       	lds	r23, 0x6c
    b31a:	42 50       	subi	r20, 0x02	; 2
    b31c:	50 40       	sbci	r21, 0x00	; 0
    b31e:	60 40       	sbci	r22, 0x00	; 0
    b320:	70 40       	sbci	r23, 0x00	; 0
    b322:	88 0d       	add	r24, r8
    b324:	99 1d       	adc	r25, r9
    b326:	aa 1d       	adc	r26, r10
    b328:	bb 1d       	adc	r27, r11
    b32a:	6c 01       	movw	r12, r24
    b32c:	7d 01       	movw	r14, r26
    b32e:	c0 1a       	sub	r12, r16
    b330:	d1 0a       	sbc	r13, r17
    b332:	e2 0a       	sbc	r14, r18
    b334:	f3 0a       	sbc	r15, r19
    b336:	09 a9       	sts	0x49, r16
    b338:	1a a9       	sts	0x4a, r17
    b33a:	2b a9       	sts	0x4b, r18
    b33c:	3c a9       	sts	0x4c, r19
    b33e:	38 01       	movw	r6, r16
    b340:	55 24       	eor	r5, r5
    b342:	44 24       	eor	r4, r4
    b344:	44 2a       	or	r4, r20
    b346:	55 2a       	or	r5, r21
    b348:	66 2a       	or	r6, r22
    b34a:	77 2a       	or	r7, r23
    b34c:	85 01       	movw	r16, r10
    b34e:	22 27       	eor	r18, r18
    b350:	33 27       	eor	r19, r19
    b352:	0d a7       	lds	r16, 0x7d
    b354:	1e a7       	lds	r17, 0x7e
    b356:	2f a7       	lds	r18, 0x7f
    b358:	38 ab       	sts	0x58, r19
    b35a:	95 01       	movw	r18, r10
    b35c:	84 01       	movw	r16, r8
    b35e:	20 70       	andi	r18, 0x00	; 0
    b360:	30 70       	andi	r19, 0x00	; 0
    b362:	09 af       	sts	0x79, r16
    b364:	1a af       	sts	0x7a, r17
    b366:	2b af       	sts	0x7b, r18
    b368:	3c af       	sts	0x7c, r19
    b36a:	c7 01       	movw	r24, r14
    b36c:	b6 01       	movw	r22, r12
    b36e:	2d a5       	lds	r18, 0x6d
    b370:	3e a5       	lds	r19, 0x6e
    b372:	4f a5       	lds	r20, 0x6f
    b374:	58 a9       	sts	0x48, r21
    b376:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b37a:	29 a7       	lds	r18, 0x79
    b37c:	3a a7       	lds	r19, 0x7a
    b37e:	4b a7       	lds	r20, 0x7b
    b380:	5c a7       	lds	r21, 0x7c
    b382:	69 ab       	sts	0x59, r22
    b384:	7a ab       	sts	0x5a, r23
    b386:	8b ab       	sts	0x5b, r24
    b388:	9c ab       	sts	0x5c, r25
    b38a:	c7 01       	movw	r24, r14
    b38c:	b6 01       	movw	r22, r12
    b38e:	2d a5       	lds	r18, 0x6d
    b390:	3e a5       	lds	r19, 0x6e
    b392:	4f a5       	lds	r20, 0x6f
    b394:	58 a9       	sts	0x48, r21
    b396:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b39a:	ca 01       	movw	r24, r20
    b39c:	b9 01       	movw	r22, r18
    b39e:	29 ad       	sts	0x69, r18
    b3a0:	3a ad       	sts	0x6a, r19
    b3a2:	4b ad       	sts	0x6b, r20
    b3a4:	5c ad       	sts	0x6c, r21
    b3a6:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b3aa:	ab 01       	movw	r20, r22
    b3ac:	bc 01       	movw	r22, r24
    b3ae:	09 a9       	sts	0x49, r16
    b3b0:	1a a9       	sts	0x4a, r17
    b3b2:	2b a9       	sts	0x4b, r18
    b3b4:	3c a9       	sts	0x4c, r19
    b3b6:	78 01       	movw	r14, r16
    b3b8:	dd 24       	eor	r13, r13
    b3ba:	cc 24       	eor	r12, r12
    b3bc:	0d a9       	sts	0x4d, r16
    b3be:	1e a9       	sts	0x4e, r17
    b3c0:	2f a9       	sts	0x4f, r18
    b3c2:	38 ad       	sts	0x68, r19
    b3c4:	c9 01       	movw	r24, r18
    b3c6:	aa 27       	eor	r26, r26
    b3c8:	bb 27       	eor	r27, r27
    b3ca:	c8 2a       	or	r12, r24
    b3cc:	d9 2a       	or	r13, r25
    b3ce:	ea 2a       	or	r14, r26
    b3d0:	fb 2a       	or	r15, r27
    b3d2:	09 a5       	lds	r16, 0x69
    b3d4:	1a a5       	lds	r17, 0x6a
    b3d6:	2b a5       	lds	r18, 0x6b
    b3d8:	3c a5       	lds	r19, 0x6c
    b3da:	c4 16       	cp	r12, r20
    b3dc:	d5 06       	cpc	r13, r21
    b3de:	e6 06       	cpc	r14, r22
    b3e0:	f7 06       	cpc	r15, r23
    b3e2:	38 f5       	brcc	.+78     	; 0xb432 <__divdi3+0x900>
    b3e4:	01 50       	subi	r16, 0x01	; 1
    b3e6:	10 40       	sbci	r17, 0x00	; 0
    b3e8:	20 40       	sbci	r18, 0x00	; 0
    b3ea:	30 40       	sbci	r19, 0x00	; 0
    b3ec:	09 ab       	sts	0x59, r16
    b3ee:	1a ab       	sts	0x5a, r17
    b3f0:	2b ab       	sts	0x5b, r18
    b3f2:	3c ab       	sts	0x5c, r19
    b3f4:	c8 0c       	add	r12, r8
    b3f6:	d9 1c       	adc	r13, r9
    b3f8:	ea 1c       	adc	r14, r10
    b3fa:	fb 1c       	adc	r15, r11
    b3fc:	c8 14       	cp	r12, r8
    b3fe:	d9 04       	cpc	r13, r9
    b400:	ea 04       	cpc	r14, r10
    b402:	fb 04       	cpc	r15, r11
    b404:	d0 f0       	brcs	.+52     	; 0xb43a <__divdi3+0x908>
    b406:	c4 16       	cp	r12, r20
    b408:	d5 06       	cpc	r13, r21
    b40a:	e6 06       	cpc	r14, r22
    b40c:	f7 06       	cpc	r15, r23
    b40e:	a8 f4       	brcc	.+42     	; 0xb43a <__divdi3+0x908>
    b410:	09 a5       	lds	r16, 0x69
    b412:	1a a5       	lds	r17, 0x6a
    b414:	2b a5       	lds	r18, 0x6b
    b416:	3c a5       	lds	r19, 0x6c
    b418:	02 50       	subi	r16, 0x02	; 2
    b41a:	10 40       	sbci	r17, 0x00	; 0
    b41c:	20 40       	sbci	r18, 0x00	; 0
    b41e:	30 40       	sbci	r19, 0x00	; 0
    b420:	09 ab       	sts	0x59, r16
    b422:	1a ab       	sts	0x5a, r17
    b424:	2b ab       	sts	0x5b, r18
    b426:	3c ab       	sts	0x5c, r19
    b428:	c8 0c       	add	r12, r8
    b42a:	d9 1c       	adc	r13, r9
    b42c:	ea 1c       	adc	r14, r10
    b42e:	fb 1c       	adc	r15, r11
    b430:	04 c0       	rjmp	.+8      	; 0xb43a <__divdi3+0x908>
    b432:	09 ab       	sts	0x59, r16
    b434:	1a ab       	sts	0x5a, r17
    b436:	2b ab       	sts	0x5b, r18
    b438:	3c ab       	sts	0x5c, r19
    b43a:	c4 1a       	sub	r12, r20
    b43c:	d5 0a       	sbc	r13, r21
    b43e:	e6 0a       	sbc	r14, r22
    b440:	f7 0a       	sbc	r15, r23
    b442:	c7 01       	movw	r24, r14
    b444:	b6 01       	movw	r22, r12
    b446:	2d a5       	lds	r18, 0x6d
    b448:	3e a5       	lds	r19, 0x6e
    b44a:	4f a5       	lds	r20, 0x6f
    b44c:	58 a9       	sts	0x48, r21
    b44e:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b452:	29 a7       	lds	r18, 0x79
    b454:	3a a7       	lds	r19, 0x7a
    b456:	4b a7       	lds	r20, 0x7b
    b458:	5c a7       	lds	r21, 0x7c
    b45a:	21 96       	adiw	r28, 0x01	; 1
    b45c:	6c af       	sts	0x7c, r22
    b45e:	7d af       	sts	0x7d, r23
    b460:	8e af       	sts	0x7e, r24
    b462:	9f af       	sts	0x7f, r25
    b464:	21 97       	sbiw	r28, 0x01	; 1
    b466:	c7 01       	movw	r24, r14
    b468:	b6 01       	movw	r22, r12
    b46a:	2d a5       	lds	r18, 0x6d
    b46c:	3e a5       	lds	r19, 0x6e
    b46e:	4f a5       	lds	r20, 0x6f
    b470:	58 a9       	sts	0x48, r21
    b472:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b476:	ca 01       	movw	r24, r20
    b478:	b9 01       	movw	r22, r18
    b47a:	29 ad       	sts	0x69, r18
    b47c:	3a ad       	sts	0x6a, r19
    b47e:	4b ad       	sts	0x6b, r20
    b480:	5c ad       	sts	0x6c, r21
    b482:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b486:	8b 01       	movw	r16, r22
    b488:	9c 01       	movw	r18, r24
    b48a:	21 96       	adiw	r28, 0x01	; 1
    b48c:	4c ad       	sts	0x6c, r20
    b48e:	5d ad       	sts	0x6d, r21
    b490:	6e ad       	sts	0x6e, r22
    b492:	7f ad       	sts	0x6f, r23
    b494:	21 97       	sbiw	r28, 0x01	; 1
    b496:	da 01       	movw	r26, r20
    b498:	99 27       	eor	r25, r25
    b49a:	88 27       	eor	r24, r24
    b49c:	4d a9       	sts	0x4d, r20
    b49e:	5e a9       	sts	0x4e, r21
    b4a0:	6f a9       	sts	0x4f, r22
    b4a2:	78 ad       	sts	0x68, r23
    b4a4:	60 70       	andi	r22, 0x00	; 0
    b4a6:	70 70       	andi	r23, 0x00	; 0
    b4a8:	84 2b       	or	r24, r20
    b4aa:	95 2b       	or	r25, r21
    b4ac:	a6 2b       	or	r26, r22
    b4ae:	b7 2b       	or	r27, r23
    b4b0:	49 a5       	lds	r20, 0x69
    b4b2:	5a a5       	lds	r21, 0x6a
    b4b4:	6b a5       	lds	r22, 0x6b
    b4b6:	7c a5       	lds	r23, 0x6c
    b4b8:	80 17       	cp	r24, r16
    b4ba:	91 07       	cpc	r25, r17
    b4bc:	a2 07       	cpc	r26, r18
    b4be:	b3 07       	cpc	r27, r19
    b4c0:	d0 f4       	brcc	.+52     	; 0xb4f6 <__divdi3+0x9c4>
    b4c2:	41 50       	subi	r20, 0x01	; 1
    b4c4:	50 40       	sbci	r21, 0x00	; 0
    b4c6:	60 40       	sbci	r22, 0x00	; 0
    b4c8:	70 40       	sbci	r23, 0x00	; 0
    b4ca:	88 0d       	add	r24, r8
    b4cc:	99 1d       	adc	r25, r9
    b4ce:	aa 1d       	adc	r26, r10
    b4d0:	bb 1d       	adc	r27, r11
    b4d2:	88 15       	cp	r24, r8
    b4d4:	99 05       	cpc	r25, r9
    b4d6:	aa 05       	cpc	r26, r10
    b4d8:	bb 05       	cpc	r27, r11
    b4da:	68 f0       	brcs	.+26     	; 0xb4f6 <__divdi3+0x9c4>
    b4dc:	80 17       	cp	r24, r16
    b4de:	91 07       	cpc	r25, r17
    b4e0:	a2 07       	cpc	r26, r18
    b4e2:	b3 07       	cpc	r27, r19
    b4e4:	40 f4       	brcc	.+16     	; 0xb4f6 <__divdi3+0x9c4>
    b4e6:	49 a5       	lds	r20, 0x69
    b4e8:	5a a5       	lds	r21, 0x6a
    b4ea:	6b a5       	lds	r22, 0x6b
    b4ec:	7c a5       	lds	r23, 0x6c
    b4ee:	42 50       	subi	r20, 0x02	; 2
    b4f0:	50 40       	sbci	r21, 0x00	; 0
    b4f2:	60 40       	sbci	r22, 0x00	; 0
    b4f4:	70 40       	sbci	r23, 0x00	; 0
    b4f6:	09 a9       	sts	0x49, r16
    b4f8:	1a a9       	sts	0x4a, r17
    b4fa:	2b a9       	sts	0x4b, r18
    b4fc:	3c a9       	sts	0x4c, r19
    b4fe:	78 01       	movw	r14, r16
    b500:	dd 24       	eor	r13, r13
    b502:	cc 24       	eor	r12, r12
    b504:	c4 2a       	or	r12, r20
    b506:	d5 2a       	or	r13, r21
    b508:	e6 2a       	or	r14, r22
    b50a:	f7 2a       	or	r15, r23
    b50c:	50 c2       	rjmp	.+1184   	; 0xb9ae <__divdi3+0xe7c>
    b50e:	c8 16       	cp	r12, r24
    b510:	d9 06       	cpc	r13, r25
    b512:	ea 06       	cpc	r14, r26
    b514:	fb 06       	cpc	r15, r27
    b516:	08 f4       	brcc	.+2      	; 0xb51a <__divdi3+0x9e8>
    b518:	37 c2       	rjmp	.+1134   	; 0xb988 <__divdi3+0xe56>
    b51a:	80 30       	cpi	r24, 0x00	; 0
    b51c:	10 e0       	ldi	r17, 0x00	; 0
    b51e:	91 07       	cpc	r25, r17
    b520:	11 e0       	ldi	r17, 0x01	; 1
    b522:	a1 07       	cpc	r26, r17
    b524:	10 e0       	ldi	r17, 0x00	; 0
    b526:	b1 07       	cpc	r27, r17
    b528:	50 f4       	brcc	.+20     	; 0xb53e <__divdi3+0xa0c>
    b52a:	8f 3f       	cpi	r24, 0xFF	; 255
    b52c:	91 05       	cpc	r25, r1
    b52e:	a1 05       	cpc	r26, r1
    b530:	b1 05       	cpc	r27, r1
    b532:	09 f0       	breq	.+2      	; 0xb536 <__divdi3+0xa04>
    b534:	88 f4       	brcc	.+34     	; 0xb558 <__divdi3+0xa26>
    b536:	00 e0       	ldi	r16, 0x00	; 0
    b538:	10 e0       	ldi	r17, 0x00	; 0
    b53a:	98 01       	movw	r18, r16
    b53c:	16 c0       	rjmp	.+44     	; 0xb56a <__divdi3+0xa38>
    b53e:	80 30       	cpi	r24, 0x00	; 0
    b540:	20 e0       	ldi	r18, 0x00	; 0
    b542:	92 07       	cpc	r25, r18
    b544:	20 e0       	ldi	r18, 0x00	; 0
    b546:	a2 07       	cpc	r26, r18
    b548:	21 e0       	ldi	r18, 0x01	; 1
    b54a:	b2 07       	cpc	r27, r18
    b54c:	50 f4       	brcc	.+20     	; 0xb562 <__divdi3+0xa30>
    b54e:	00 e1       	ldi	r16, 0x10	; 16
    b550:	10 e0       	ldi	r17, 0x00	; 0
    b552:	20 e0       	ldi	r18, 0x00	; 0
    b554:	30 e0       	ldi	r19, 0x00	; 0
    b556:	09 c0       	rjmp	.+18     	; 0xb56a <__divdi3+0xa38>
    b558:	08 e0       	ldi	r16, 0x08	; 8
    b55a:	10 e0       	ldi	r17, 0x00	; 0
    b55c:	20 e0       	ldi	r18, 0x00	; 0
    b55e:	30 e0       	ldi	r19, 0x00	; 0
    b560:	04 c0       	rjmp	.+8      	; 0xb56a <__divdi3+0xa38>
    b562:	08 e1       	ldi	r16, 0x18	; 24
    b564:	10 e0       	ldi	r17, 0x00	; 0
    b566:	20 e0       	ldi	r18, 0x00	; 0
    b568:	30 e0       	ldi	r19, 0x00	; 0
    b56a:	ac 01       	movw	r20, r24
    b56c:	bd 01       	movw	r22, r26
    b56e:	00 2e       	mov	r0, r16
    b570:	04 c0       	rjmp	.+8      	; 0xb57a <__divdi3+0xa48>
    b572:	76 95       	lsr	r23
    b574:	67 95       	ror	r22
    b576:	57 95       	ror	r21
    b578:	47 95       	ror	r20
    b57a:	0a 94       	dec	r0
    b57c:	d2 f7       	brpl	.-12     	; 0xb572 <__divdi3+0xa40>
    b57e:	fa 01       	movw	r30, r20
    b580:	e8 5d       	subi	r30, 0xD8	; 216
    b582:	ff 4d       	sbci	r31, 0xDF	; 223
    b584:	40 81       	ld	r20, Z
    b586:	04 0f       	add	r16, r20
    b588:	11 1d       	adc	r17, r1
    b58a:	21 1d       	adc	r18, r1
    b58c:	31 1d       	adc	r19, r1
    b58e:	40 e2       	ldi	r20, 0x20	; 32
    b590:	50 e0       	ldi	r21, 0x00	; 0
    b592:	60 e0       	ldi	r22, 0x00	; 0
    b594:	70 e0       	ldi	r23, 0x00	; 0
    b596:	40 1b       	sub	r20, r16
    b598:	51 0b       	sbc	r21, r17
    b59a:	62 0b       	sbc	r22, r18
    b59c:	73 0b       	sbc	r23, r19
    b59e:	a1 f4       	brne	.+40     	; 0xb5c8 <__divdi3+0xa96>
    b5a0:	8c 15       	cp	r24, r12
    b5a2:	9d 05       	cpc	r25, r13
    b5a4:	ae 05       	cpc	r26, r14
    b5a6:	bf 05       	cpc	r27, r15
    b5a8:	08 f4       	brcc	.+2      	; 0xb5ac <__divdi3+0xa7a>
    b5aa:	f5 c1       	rjmp	.+1002   	; 0xb996 <__divdi3+0xe64>
    b5ac:	ed a8       	sts	0x8d, r30
    b5ae:	fe a8       	sts	0x8e, r31
    b5b0:	0f a9       	sts	0x4f, r16
    b5b2:	18 ad       	sts	0x68, r17
    b5b4:	44 24       	eor	r4, r4
    b5b6:	55 24       	eor	r5, r5
    b5b8:	32 01       	movw	r6, r4
    b5ba:	e8 14       	cp	r14, r8
    b5bc:	f9 04       	cpc	r15, r9
    b5be:	0a 05       	cpc	r16, r10
    b5c0:	1b 05       	cpc	r17, r11
    b5c2:	08 f0       	brcs	.+2      	; 0xb5c6 <__divdi3+0xa94>
    b5c4:	eb c1       	rjmp	.+982    	; 0xb99c <__divdi3+0xe6a>
    b5c6:	e3 c1       	rjmp	.+966    	; 0xb98e <__divdi3+0xe5c>
    b5c8:	34 2e       	mov	r3, r20
    b5ca:	2c 01       	movw	r4, r24
    b5cc:	3d 01       	movw	r6, r26
    b5ce:	04 c0       	rjmp	.+8      	; 0xb5d8 <__divdi3+0xaa6>
    b5d0:	44 0c       	add	r4, r4
    b5d2:	55 1c       	adc	r5, r5
    b5d4:	66 1c       	adc	r6, r6
    b5d6:	77 1c       	adc	r7, r7
    b5d8:	4a 95       	dec	r20
    b5da:	d2 f7       	brpl	.-12     	; 0xb5d0 <__divdi3+0xa9e>
    b5dc:	d5 01       	movw	r26, r10
    b5de:	c4 01       	movw	r24, r8
    b5e0:	00 2e       	mov	r0, r16
    b5e2:	04 c0       	rjmp	.+8      	; 0xb5ec <__divdi3+0xaba>
    b5e4:	b6 95       	lsr	r27
    b5e6:	a7 95       	ror	r26
    b5e8:	97 95       	ror	r25
    b5ea:	87 95       	ror	r24
    b5ec:	0a 94       	dec	r0
    b5ee:	d2 f7       	brpl	.-12     	; 0xb5e4 <__divdi3+0xab2>
    b5f0:	48 2a       	or	r4, r24
    b5f2:	59 2a       	or	r5, r25
    b5f4:	6a 2a       	or	r6, r26
    b5f6:	7b 2a       	or	r7, r27
    b5f8:	a5 01       	movw	r20, r10
    b5fa:	94 01       	movw	r18, r8
    b5fc:	03 2c       	mov	r0, r3
    b5fe:	04 c0       	rjmp	.+8      	; 0xb608 <__divdi3+0xad6>
    b600:	22 0f       	add	r18, r18
    b602:	33 1f       	adc	r19, r19
    b604:	44 1f       	adc	r20, r20
    b606:	55 1f       	adc	r21, r21
    b608:	0a 94       	dec	r0
    b60a:	d2 f7       	brpl	.-12     	; 0xb600 <__divdi3+0xace>
    b60c:	29 af       	sts	0x79, r18
    b60e:	3a af       	sts	0x7a, r19
    b610:	4b af       	sts	0x7b, r20
    b612:	5c af       	sts	0x7c, r21
    b614:	b7 01       	movw	r22, r14
    b616:	a6 01       	movw	r20, r12
    b618:	00 2e       	mov	r0, r16
    b61a:	04 c0       	rjmp	.+8      	; 0xb624 <__divdi3+0xaf2>
    b61c:	76 95       	lsr	r23
    b61e:	67 95       	ror	r22
    b620:	57 95       	ror	r21
    b622:	47 95       	ror	r20
    b624:	0a 94       	dec	r0
    b626:	d2 f7       	brpl	.-12     	; 0xb61c <__divdi3+0xaea>
    b628:	49 ab       	sts	0x59, r20
    b62a:	5a ab       	sts	0x5a, r21
    b62c:	6b ab       	sts	0x5b, r22
    b62e:	7c ab       	sts	0x5c, r23
    b630:	c7 01       	movw	r24, r14
    b632:	b6 01       	movw	r22, r12
    b634:	03 2c       	mov	r0, r3
    b636:	04 c0       	rjmp	.+8      	; 0xb640 <__divdi3+0xb0e>
    b638:	66 0f       	add	r22, r22
    b63a:	77 1f       	adc	r23, r23
    b63c:	88 1f       	adc	r24, r24
    b63e:	99 1f       	adc	r25, r25
    b640:	0a 94       	dec	r0
    b642:	d2 f7       	brpl	.-12     	; 0xb638 <__divdi3+0xb06>
    b644:	6d a7       	lds	r22, 0x7d
    b646:	7e a7       	lds	r23, 0x7e
    b648:	8f a7       	lds	r24, 0x7f
    b64a:	98 ab       	sts	0x58, r25
    b64c:	8d a9       	sts	0x4d, r24
    b64e:	9e a9       	sts	0x4e, r25
    b650:	af a9       	sts	0x4f, r26
    b652:	b8 ad       	sts	0x68, r27
    b654:	04 c0       	rjmp	.+8      	; 0xb65e <__divdi3+0xb2c>
    b656:	b6 95       	lsr	r27
    b658:	a7 95       	ror	r26
    b65a:	97 95       	ror	r25
    b65c:	87 95       	ror	r24
    b65e:	0a 95       	dec	r16
    b660:	d2 f7       	brpl	.-12     	; 0xb656 <__divdi3+0xb24>
    b662:	4d a5       	lds	r20, 0x6d
    b664:	5e a5       	lds	r21, 0x6e
    b666:	6f a5       	lds	r22, 0x6f
    b668:	78 a9       	sts	0x48, r23
    b66a:	48 2b       	or	r20, r24
    b66c:	59 2b       	or	r21, r25
    b66e:	6a 2b       	or	r22, r26
    b670:	7b 2b       	or	r23, r27
    b672:	4d a7       	lds	r20, 0x7d
    b674:	5e a7       	lds	r21, 0x7e
    b676:	6f a7       	lds	r22, 0x7f
    b678:	78 ab       	sts	0x58, r23
    b67a:	43 01       	movw	r8, r6
    b67c:	aa 24       	eor	r10, r10
    b67e:	bb 24       	eor	r11, r11
    b680:	93 01       	movw	r18, r6
    b682:	82 01       	movw	r16, r4
    b684:	20 70       	andi	r18, 0x00	; 0
    b686:	30 70       	andi	r19, 0x00	; 0
    b688:	21 96       	adiw	r28, 0x01	; 1
    b68a:	0c af       	sts	0x7c, r16
    b68c:	1d af       	sts	0x7d, r17
    b68e:	2e af       	sts	0x7e, r18
    b690:	3f af       	sts	0x7f, r19
    b692:	21 97       	sbiw	r28, 0x01	; 1
    b694:	69 a9       	sts	0x49, r22
    b696:	7a a9       	sts	0x4a, r23
    b698:	8b a9       	sts	0x4b, r24
    b69a:	9c a9       	sts	0x4c, r25
    b69c:	a5 01       	movw	r20, r10
    b69e:	94 01       	movw	r18, r8
    b6a0:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b6a4:	29 a7       	lds	r18, 0x79
    b6a6:	3a a7       	lds	r19, 0x7a
    b6a8:	4b a7       	lds	r20, 0x7b
    b6aa:	5c a7       	lds	r21, 0x7c
    b6ac:	6b 01       	movw	r12, r22
    b6ae:	7c 01       	movw	r14, r24
    b6b0:	69 a9       	sts	0x49, r22
    b6b2:	7a a9       	sts	0x4a, r23
    b6b4:	8b a9       	sts	0x4b, r24
    b6b6:	9c a9       	sts	0x4c, r25
    b6b8:	a5 01       	movw	r20, r10
    b6ba:	94 01       	movw	r18, r8
    b6bc:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b6c0:	ca 01       	movw	r24, r20
    b6c2:	b9 01       	movw	r22, r18
    b6c4:	21 96       	adiw	r28, 0x01	; 1
    b6c6:	2c ad       	sts	0x6c, r18
    b6c8:	3d ad       	sts	0x6d, r19
    b6ca:	4e ad       	sts	0x6e, r20
    b6cc:	5f ad       	sts	0x6f, r21
    b6ce:	21 97       	sbiw	r28, 0x01	; 1
    b6d0:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b6d4:	dc 01       	movw	r26, r24
    b6d6:	cb 01       	movw	r24, r22
    b6d8:	76 01       	movw	r14, r12
    b6da:	dd 24       	eor	r13, r13
    b6dc:	cc 24       	eor	r12, r12
    b6de:	0d a5       	lds	r16, 0x6d
    b6e0:	1e a5       	lds	r17, 0x6e
    b6e2:	2f a5       	lds	r18, 0x6f
    b6e4:	38 a9       	sts	0x48, r19
    b6e6:	a9 01       	movw	r20, r18
    b6e8:	66 27       	eor	r22, r22
    b6ea:	77 27       	eor	r23, r23
    b6ec:	c4 2a       	or	r12, r20
    b6ee:	d5 2a       	or	r13, r21
    b6f0:	e6 2a       	or	r14, r22
    b6f2:	f7 2a       	or	r15, r23
    b6f4:	09 a5       	lds	r16, 0x69
    b6f6:	1a a5       	lds	r17, 0x6a
    b6f8:	2b a5       	lds	r18, 0x6b
    b6fa:	3c a5       	lds	r19, 0x6c
    b6fc:	c8 16       	cp	r12, r24
    b6fe:	d9 06       	cpc	r13, r25
    b700:	ea 06       	cpc	r14, r26
    b702:	fb 06       	cpc	r15, r27
    b704:	38 f5       	brcc	.+78     	; 0xb754 <__divdi3+0xc22>
    b706:	01 50       	subi	r16, 0x01	; 1
    b708:	10 40       	sbci	r17, 0x00	; 0
    b70a:	20 40       	sbci	r18, 0x00	; 0
    b70c:	30 40       	sbci	r19, 0x00	; 0
    b70e:	09 ab       	sts	0x59, r16
    b710:	1a ab       	sts	0x5a, r17
    b712:	2b ab       	sts	0x5b, r18
    b714:	3c ab       	sts	0x5c, r19
    b716:	c4 0c       	add	r12, r4
    b718:	d5 1c       	adc	r13, r5
    b71a:	e6 1c       	adc	r14, r6
    b71c:	f7 1c       	adc	r15, r7
    b71e:	c4 14       	cp	r12, r4
    b720:	d5 04       	cpc	r13, r5
    b722:	e6 04       	cpc	r14, r6
    b724:	f7 04       	cpc	r15, r7
    b726:	d0 f0       	brcs	.+52     	; 0xb75c <__divdi3+0xc2a>
    b728:	c8 16       	cp	r12, r24
    b72a:	d9 06       	cpc	r13, r25
    b72c:	ea 06       	cpc	r14, r26
    b72e:	fb 06       	cpc	r15, r27
    b730:	a8 f4       	brcc	.+42     	; 0xb75c <__divdi3+0xc2a>
    b732:	09 a5       	lds	r16, 0x69
    b734:	1a a5       	lds	r17, 0x6a
    b736:	2b a5       	lds	r18, 0x6b
    b738:	3c a5       	lds	r19, 0x6c
    b73a:	02 50       	subi	r16, 0x02	; 2
    b73c:	10 40       	sbci	r17, 0x00	; 0
    b73e:	20 40       	sbci	r18, 0x00	; 0
    b740:	30 40       	sbci	r19, 0x00	; 0
    b742:	09 ab       	sts	0x59, r16
    b744:	1a ab       	sts	0x5a, r17
    b746:	2b ab       	sts	0x5b, r18
    b748:	3c ab       	sts	0x5c, r19
    b74a:	c4 0c       	add	r12, r4
    b74c:	d5 1c       	adc	r13, r5
    b74e:	e6 1c       	adc	r14, r6
    b750:	f7 1c       	adc	r15, r7
    b752:	04 c0       	rjmp	.+8      	; 0xb75c <__divdi3+0xc2a>
    b754:	09 ab       	sts	0x59, r16
    b756:	1a ab       	sts	0x5a, r17
    b758:	2b ab       	sts	0x5b, r18
    b75a:	3c ab       	sts	0x5c, r19
    b75c:	c8 1a       	sub	r12, r24
    b75e:	d9 0a       	sbc	r13, r25
    b760:	ea 0a       	sbc	r14, r26
    b762:	fb 0a       	sbc	r15, r27
    b764:	c7 01       	movw	r24, r14
    b766:	b6 01       	movw	r22, r12
    b768:	a5 01       	movw	r20, r10
    b76a:	94 01       	movw	r18, r8
    b76c:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b770:	29 a7       	lds	r18, 0x79
    b772:	3a a7       	lds	r19, 0x7a
    b774:	4b a7       	lds	r20, 0x7b
    b776:	5c a7       	lds	r21, 0x7c
    b778:	29 96       	adiw	r28, 0x09	; 9
    b77a:	6c af       	sts	0x7c, r22
    b77c:	7d af       	sts	0x7d, r23
    b77e:	8e af       	sts	0x7e, r24
    b780:	9f af       	sts	0x7f, r25
    b782:	29 97       	sbiw	r28, 0x09	; 9
    b784:	c7 01       	movw	r24, r14
    b786:	b6 01       	movw	r22, r12
    b788:	a5 01       	movw	r20, r10
    b78a:	94 01       	movw	r18, r8
    b78c:	0e 94 0f 5f 	call	0xbe1e	; 0xbe1e <__udivmodsi4>
    b790:	ca 01       	movw	r24, r20
    b792:	b9 01       	movw	r22, r18
    b794:	21 96       	adiw	r28, 0x01	; 1
    b796:	2c ad       	sts	0x6c, r18
    b798:	3d ad       	sts	0x6d, r19
    b79a:	4e ad       	sts	0x6e, r20
    b79c:	5f ad       	sts	0x6f, r21
    b79e:	21 97       	sbiw	r28, 0x01	; 1
    b7a0:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b7a4:	4b 01       	movw	r8, r22
    b7a6:	5c 01       	movw	r10, r24
    b7a8:	29 96       	adiw	r28, 0x09	; 9
    b7aa:	4c ad       	sts	0x6c, r20
    b7ac:	5d ad       	sts	0x6d, r21
    b7ae:	6e ad       	sts	0x6e, r22
    b7b0:	7f ad       	sts	0x6f, r23
    b7b2:	29 97       	sbiw	r28, 0x09	; 9
    b7b4:	9a 01       	movw	r18, r20
    b7b6:	11 27       	eor	r17, r17
    b7b8:	00 27       	eor	r16, r16
    b7ba:	8d a5       	lds	r24, 0x6d
    b7bc:	9e a5       	lds	r25, 0x6e
    b7be:	af a5       	lds	r26, 0x6f
    b7c0:	b8 a9       	sts	0x48, r27
    b7c2:	a0 70       	andi	r26, 0x00	; 0
    b7c4:	b0 70       	andi	r27, 0x00	; 0
    b7c6:	08 2b       	or	r16, r24
    b7c8:	19 2b       	or	r17, r25
    b7ca:	2a 2b       	or	r18, r26
    b7cc:	3b 2b       	or	r19, r27
    b7ce:	89 a5       	lds	r24, 0x69
    b7d0:	9a a5       	lds	r25, 0x6a
    b7d2:	ab a5       	lds	r26, 0x6b
    b7d4:	bc a5       	lds	r27, 0x6c
    b7d6:	08 15       	cp	r16, r8
    b7d8:	19 05       	cpc	r17, r9
    b7da:	2a 05       	cpc	r18, r10
    b7dc:	3b 05       	cpc	r19, r11
    b7de:	e0 f4       	brcc	.+56     	; 0xb818 <__divdi3+0xce6>
    b7e0:	01 97       	sbiw	r24, 0x01	; 1
    b7e2:	a1 09       	sbc	r26, r1
    b7e4:	b1 09       	sbc	r27, r1
    b7e6:	04 0d       	add	r16, r4
    b7e8:	15 1d       	adc	r17, r5
    b7ea:	26 1d       	adc	r18, r6
    b7ec:	37 1d       	adc	r19, r7
    b7ee:	04 15       	cp	r16, r4
    b7f0:	15 05       	cpc	r17, r5
    b7f2:	26 05       	cpc	r18, r6
    b7f4:	37 05       	cpc	r19, r7
    b7f6:	80 f0       	brcs	.+32     	; 0xb818 <__divdi3+0xce6>
    b7f8:	08 15       	cp	r16, r8
    b7fa:	19 05       	cpc	r17, r9
    b7fc:	2a 05       	cpc	r18, r10
    b7fe:	3b 05       	cpc	r19, r11
    b800:	58 f4       	brcc	.+22     	; 0xb818 <__divdi3+0xce6>
    b802:	89 a5       	lds	r24, 0x69
    b804:	9a a5       	lds	r25, 0x6a
    b806:	ab a5       	lds	r26, 0x6b
    b808:	bc a5       	lds	r27, 0x6c
    b80a:	02 97       	sbiw	r24, 0x02	; 2
    b80c:	a1 09       	sbc	r26, r1
    b80e:	b1 09       	sbc	r27, r1
    b810:	04 0d       	add	r16, r4
    b812:	15 1d       	adc	r17, r5
    b814:	26 1d       	adc	r18, r6
    b816:	37 1d       	adc	r19, r7
    b818:	b9 01       	movw	r22, r18
    b81a:	a8 01       	movw	r20, r16
    b81c:	48 19       	sub	r20, r8
    b81e:	59 09       	sbc	r21, r9
    b820:	6a 09       	sbc	r22, r10
    b822:	7b 09       	sbc	r23, r11
    b824:	4d a7       	lds	r20, 0x7d
    b826:	5e a7       	lds	r21, 0x7e
    b828:	6f a7       	lds	r22, 0x7f
    b82a:	78 ab       	sts	0x58, r23
    b82c:	09 a9       	sts	0x49, r16
    b82e:	1a a9       	sts	0x4a, r17
    b830:	2b a9       	sts	0x4b, r18
    b832:	3c a9       	sts	0x4c, r19
    b834:	78 01       	movw	r14, r16
    b836:	dd 24       	eor	r13, r13
    b838:	cc 24       	eor	r12, r12
    b83a:	c8 2a       	or	r12, r24
    b83c:	d9 2a       	or	r13, r25
    b83e:	ea 2a       	or	r14, r26
    b840:	fb 2a       	or	r15, r27
    b842:	ff ef       	ldi	r31, 0xFF	; 255
    b844:	8f 2e       	mov	r8, r31
    b846:	ff ef       	ldi	r31, 0xFF	; 255
    b848:	9f 2e       	mov	r9, r31
    b84a:	a1 2c       	mov	r10, r1
    b84c:	b1 2c       	mov	r11, r1
    b84e:	8c 20       	and	r8, r12
    b850:	9d 20       	and	r9, r13
    b852:	ae 20       	and	r10, r14
    b854:	bf 20       	and	r11, r15
    b856:	87 01       	movw	r16, r14
    b858:	22 27       	eor	r18, r18
    b85a:	33 27       	eor	r19, r19
    b85c:	09 a7       	lds	r16, 0x79
    b85e:	1a a7       	lds	r17, 0x7a
    b860:	2b a7       	lds	r18, 0x7b
    b862:	3c a7       	lds	r19, 0x7c
    b864:	49 ac       	sts	0xa9, r20
    b866:	5a ac       	sts	0xaa, r21
    b868:	6b ac       	sts	0xab, r22
    b86a:	7c ac       	sts	0xac, r23
    b86c:	2f ef       	ldi	r18, 0xFF	; 255
    b86e:	3f ef       	ldi	r19, 0xFF	; 255
    b870:	40 e0       	ldi	r20, 0x00	; 0
    b872:	50 e0       	ldi	r21, 0x00	; 0
    b874:	42 22       	and	r4, r18
    b876:	53 22       	and	r5, r19
    b878:	64 22       	and	r6, r20
    b87a:	75 22       	and	r7, r21
    b87c:	29 ad       	sts	0x69, r18
    b87e:	3a ad       	sts	0x6a, r19
    b880:	4b ad       	sts	0x6b, r20
    b882:	5c ad       	sts	0x6c, r21
    b884:	8a 01       	movw	r16, r20
    b886:	22 27       	eor	r18, r18
    b888:	33 27       	eor	r19, r19
    b88a:	09 ab       	sts	0x59, r16
    b88c:	1a ab       	sts	0x5a, r17
    b88e:	2b ab       	sts	0x5b, r18
    b890:	3c ab       	sts	0x5c, r19
    b892:	c5 01       	movw	r24, r10
    b894:	b4 01       	movw	r22, r8
    b896:	a3 01       	movw	r20, r6
    b898:	92 01       	movw	r18, r4
    b89a:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b89e:	69 af       	sts	0x79, r22
    b8a0:	7a af       	sts	0x7a, r23
    b8a2:	8b af       	sts	0x7b, r24
    b8a4:	9c af       	sts	0x7c, r25
    b8a6:	c5 01       	movw	r24, r10
    b8a8:	b4 01       	movw	r22, r8
    b8aa:	29 a9       	sts	0x49, r18
    b8ac:	3a a9       	sts	0x4a, r19
    b8ae:	4b a9       	sts	0x4b, r20
    b8b0:	5c a9       	sts	0x4c, r21
    b8b2:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b8b6:	4b 01       	movw	r8, r22
    b8b8:	5c 01       	movw	r10, r24
    b8ba:	69 a5       	lds	r22, 0x69
    b8bc:	7a a5       	lds	r23, 0x6a
    b8be:	8b a5       	lds	r24, 0x6b
    b8c0:	9c a5       	lds	r25, 0x6c
    b8c2:	a3 01       	movw	r20, r6
    b8c4:	92 01       	movw	r18, r4
    b8c6:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b8ca:	2b 01       	movw	r4, r22
    b8cc:	3c 01       	movw	r6, r24
    b8ce:	69 a5       	lds	r22, 0x69
    b8d0:	7a a5       	lds	r23, 0x6a
    b8d2:	8b a5       	lds	r24, 0x6b
    b8d4:	9c a5       	lds	r25, 0x6c
    b8d6:	29 a9       	sts	0x49, r18
    b8d8:	3a a9       	sts	0x4a, r19
    b8da:	4b a9       	sts	0x4b, r20
    b8dc:	5c a9       	sts	0x4c, r21
    b8de:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__mulsi3>
    b8e2:	ab 01       	movw	r20, r22
    b8e4:	bc 01       	movw	r22, r24
    b8e6:	84 0c       	add	r8, r4
    b8e8:	95 1c       	adc	r9, r5
    b8ea:	a6 1c       	adc	r10, r6
    b8ec:	b7 1c       	adc	r11, r7
    b8ee:	09 ad       	sts	0x69, r16
    b8f0:	1a ad       	sts	0x6a, r17
    b8f2:	2b ad       	sts	0x6b, r18
    b8f4:	3c ad       	sts	0x6c, r19
    b8f6:	c9 01       	movw	r24, r18
    b8f8:	aa 27       	eor	r26, r26
    b8fa:	bb 27       	eor	r27, r27
    b8fc:	88 0e       	add	r8, r24
    b8fe:	99 1e       	adc	r9, r25
    b900:	aa 1e       	adc	r10, r26
    b902:	bb 1e       	adc	r11, r27
    b904:	84 14       	cp	r8, r4
    b906:	95 04       	cpc	r9, r5
    b908:	a6 04       	cpc	r10, r6
    b90a:	b7 04       	cpc	r11, r7
    b90c:	20 f4       	brcc	.+8      	; 0xb916 <__divdi3+0xde4>
    b90e:	40 50       	subi	r20, 0x00	; 0
    b910:	50 40       	sbci	r21, 0x00	; 0
    b912:	6f 4f       	sbci	r22, 0xFF	; 255
    b914:	7f 4f       	sbci	r23, 0xFF	; 255
    b916:	c5 01       	movw	r24, r10
    b918:	aa 27       	eor	r26, r26
    b91a:	bb 27       	eor	r27, r27
    b91c:	84 0f       	add	r24, r20
    b91e:	95 1f       	adc	r25, r21
    b920:	a6 1f       	adc	r26, r22
    b922:	b7 1f       	adc	r27, r23
    b924:	0d a5       	lds	r16, 0x6d
    b926:	1e a5       	lds	r17, 0x6e
    b928:	2f a5       	lds	r18, 0x6f
    b92a:	38 a9       	sts	0x48, r19
    b92c:	08 17       	cp	r16, r24
    b92e:	19 07       	cpc	r17, r25
    b930:	2a 07       	cpc	r18, r26
    b932:	3b 07       	cpc	r19, r27
    b934:	18 f1       	brcs	.+70     	; 0xb97c <__divdi3+0xe4a>
    b936:	80 17       	cp	r24, r16
    b938:	91 07       	cpc	r25, r17
    b93a:	a2 07       	cpc	r26, r18
    b93c:	b3 07       	cpc	r27, r19
    b93e:	a1 f5       	brne	.+104    	; 0xb9a8 <__divdi3+0xe76>
    b940:	54 01       	movw	r10, r8
    b942:	99 24       	eor	r9, r9
    b944:	88 24       	eor	r8, r8
    b946:	89 ad       	sts	0x69, r24
    b948:	9a ad       	sts	0x6a, r25
    b94a:	ab ad       	sts	0x6b, r26
    b94c:	bc ad       	sts	0x6c, r27
    b94e:	a0 70       	andi	r26, 0x00	; 0
    b950:	b0 70       	andi	r27, 0x00	; 0
    b952:	88 0e       	add	r8, r24
    b954:	99 1e       	adc	r9, r25
    b956:	aa 1e       	adc	r10, r26
    b958:	bb 1e       	adc	r11, r27
    b95a:	4d a9       	sts	0x4d, r20
    b95c:	5e a9       	sts	0x4e, r21
    b95e:	6f a9       	sts	0x4f, r22
    b960:	78 ad       	sts	0x68, r23
    b962:	03 2c       	mov	r0, r3
    b964:	04 c0       	rjmp	.+8      	; 0xb96e <__divdi3+0xe3c>
    b966:	44 0f       	add	r20, r20
    b968:	55 1f       	adc	r21, r21
    b96a:	66 1f       	adc	r22, r22
    b96c:	77 1f       	adc	r23, r23
    b96e:	0a 94       	dec	r0
    b970:	d2 f7       	brpl	.-12     	; 0xb966 <__divdi3+0xe34>
    b972:	48 15       	cp	r20, r8
    b974:	59 05       	cpc	r21, r9
    b976:	6a 05       	cpc	r22, r10
    b978:	7b 05       	cpc	r23, r11
    b97a:	b0 f4       	brcc	.+44     	; 0xb9a8 <__divdi3+0xe76>
    b97c:	08 94       	sec
    b97e:	c1 08       	sbc	r12, r1
    b980:	d1 08       	sbc	r13, r1
    b982:	e1 08       	sbc	r14, r1
    b984:	f1 08       	sbc	r15, r1
    b986:	10 c0       	rjmp	.+32     	; 0xb9a8 <__divdi3+0xe76>
    b988:	44 24       	eor	r4, r4
    b98a:	55 24       	eor	r5, r5
    b98c:	32 01       	movw	r6, r4
    b98e:	cc 24       	eor	r12, r12
    b990:	dd 24       	eor	r13, r13
    b992:	76 01       	movw	r14, r12
    b994:	0c c0       	rjmp	.+24     	; 0xb9ae <__divdi3+0xe7c>
    b996:	44 24       	eor	r4, r4
    b998:	55 24       	eor	r5, r5
    b99a:	32 01       	movw	r6, r4
    b99c:	81 e0       	ldi	r24, 0x01	; 1
    b99e:	c8 2e       	mov	r12, r24
    b9a0:	d1 2c       	mov	r13, r1
    b9a2:	e1 2c       	mov	r14, r1
    b9a4:	f1 2c       	mov	r15, r1
    b9a6:	03 c0       	rjmp	.+6      	; 0xb9ae <__divdi3+0xe7c>
    b9a8:	44 24       	eor	r4, r4
    b9aa:	55 24       	eor	r5, r5
    b9ac:	32 01       	movw	r6, r4
    b9ae:	fe 01       	movw	r30, r28
    b9b0:	31 96       	adiw	r30, 0x01	; 1
    b9b2:	88 e0       	ldi	r24, 0x08	; 8
    b9b4:	df 01       	movw	r26, r30
    b9b6:	1d 92       	st	X+, r1
    b9b8:	8a 95       	dec	r24
    b9ba:	e9 f7       	brne	.-6      	; 0xb9b6 <__divdi3+0xe84>
    b9bc:	c9 82       	std	Y+1, r12	; 0x01
    b9be:	da 82       	std	Y+2, r13	; 0x02
    b9c0:	eb 82       	std	Y+3, r14	; 0x03
    b9c2:	fc 82       	std	Y+4, r15	; 0x04
    b9c4:	4d 82       	std	Y+5, r4	; 0x05
    b9c6:	5e 82       	std	Y+6, r5	; 0x06
    b9c8:	6f 82       	std	Y+7, r6	; 0x07
    b9ca:	78 86       	std	Y+8, r7	; 0x08
    b9cc:	2c 2d       	mov	r18, r12
    b9ce:	3a 81       	ldd	r19, Y+2	; 0x02
    b9d0:	4b 81       	ldd	r20, Y+3	; 0x03
    b9d2:	5c 81       	ldd	r21, Y+4	; 0x04
    b9d4:	64 2d       	mov	r22, r4
    b9d6:	7e 81       	ldd	r23, Y+6	; 0x06
    b9d8:	8f 81       	ldd	r24, Y+7	; 0x07
    b9da:	98 85       	ldd	r25, Y+8	; 0x08
    b9dc:	25 96       	adiw	r28, 0x05	; 5
    b9de:	ec ac       	sts	0xac, r30
    b9e0:	fd ac       	sts	0xad, r31
    b9e2:	0e ad       	sts	0x6e, r16
    b9e4:	1f ad       	sts	0x6f, r17
    b9e6:	25 97       	sbiw	r28, 0x05	; 5
    b9e8:	e1 14       	cp	r14, r1
    b9ea:	f1 04       	cpc	r15, r1
    b9ec:	01 05       	cpc	r16, r1
    b9ee:	11 05       	cpc	r17, r1
    b9f0:	09 f4       	brne	.+2      	; 0xb9f4 <__divdi3+0xec2>
    b9f2:	56 c0       	rjmp	.+172    	; 0xbaa0 <__divdi3+0xf6e>
    b9f4:	21 95       	neg	r18
    b9f6:	e1 e0       	ldi	r30, 0x01	; 1
    b9f8:	12 16       	cp	r1, r18
    b9fa:	08 f0       	brcs	.+2      	; 0xb9fe <__divdi3+0xecc>
    b9fc:	e0 e0       	ldi	r30, 0x00	; 0
    b9fe:	31 95       	neg	r19
    ba00:	f1 e0       	ldi	r31, 0x01	; 1
    ba02:	13 16       	cp	r1, r19
    ba04:	08 f0       	brcs	.+2      	; 0xba08 <__divdi3+0xed6>
    ba06:	f0 e0       	ldi	r31, 0x00	; 0
    ba08:	03 2f       	mov	r16, r19
    ba0a:	0e 1b       	sub	r16, r30
    ba0c:	e1 e0       	ldi	r30, 0x01	; 1
    ba0e:	30 17       	cp	r19, r16
    ba10:	08 f0       	brcs	.+2      	; 0xba14 <__divdi3+0xee2>
    ba12:	e0 e0       	ldi	r30, 0x00	; 0
    ba14:	fe 2b       	or	r31, r30
    ba16:	41 95       	neg	r20
    ba18:	e1 e0       	ldi	r30, 0x01	; 1
    ba1a:	14 16       	cp	r1, r20
    ba1c:	08 f0       	brcs	.+2      	; 0xba20 <__divdi3+0xeee>
    ba1e:	e0 e0       	ldi	r30, 0x00	; 0
    ba20:	14 2f       	mov	r17, r20
    ba22:	1f 1b       	sub	r17, r31
    ba24:	31 e0       	ldi	r19, 0x01	; 1
    ba26:	41 17       	cp	r20, r17
    ba28:	08 f0       	brcs	.+2      	; 0xba2c <__divdi3+0xefa>
    ba2a:	30 e0       	ldi	r19, 0x00	; 0
    ba2c:	e3 2b       	or	r30, r19
    ba2e:	51 95       	neg	r21
    ba30:	f1 e0       	ldi	r31, 0x01	; 1
    ba32:	15 16       	cp	r1, r21
    ba34:	08 f0       	brcs	.+2      	; 0xba38 <__divdi3+0xf06>
    ba36:	f0 e0       	ldi	r31, 0x00	; 0
    ba38:	b5 2f       	mov	r27, r21
    ba3a:	be 1b       	sub	r27, r30
    ba3c:	31 e0       	ldi	r19, 0x01	; 1
    ba3e:	5b 17       	cp	r21, r27
    ba40:	08 f0       	brcs	.+2      	; 0xba44 <__divdi3+0xf12>
    ba42:	30 e0       	ldi	r19, 0x00	; 0
    ba44:	f3 2b       	or	r31, r19
    ba46:	61 95       	neg	r22
    ba48:	e1 e0       	ldi	r30, 0x01	; 1
    ba4a:	16 16       	cp	r1, r22
    ba4c:	08 f0       	brcs	.+2      	; 0xba50 <__divdi3+0xf1e>
    ba4e:	e0 e0       	ldi	r30, 0x00	; 0
    ba50:	46 2e       	mov	r4, r22
    ba52:	4f 1a       	sub	r4, r31
    ba54:	31 e0       	ldi	r19, 0x01	; 1
    ba56:	64 15       	cp	r22, r4
    ba58:	08 f0       	brcs	.+2      	; 0xba5c <__divdi3+0xf2a>
    ba5a:	30 e0       	ldi	r19, 0x00	; 0
    ba5c:	e3 2b       	or	r30, r19
    ba5e:	71 95       	neg	r23
    ba60:	f1 e0       	ldi	r31, 0x01	; 1
    ba62:	17 16       	cp	r1, r23
    ba64:	08 f0       	brcs	.+2      	; 0xba68 <__divdi3+0xf36>
    ba66:	f0 e0       	ldi	r31, 0x00	; 0
    ba68:	a7 2f       	mov	r26, r23
    ba6a:	ae 1b       	sub	r26, r30
    ba6c:	31 e0       	ldi	r19, 0x01	; 1
    ba6e:	7a 17       	cp	r23, r26
    ba70:	08 f0       	brcs	.+2      	; 0xba74 <__divdi3+0xf42>
    ba72:	30 e0       	ldi	r19, 0x00	; 0
    ba74:	f3 2b       	or	r31, r19
    ba76:	81 95       	neg	r24
    ba78:	e1 e0       	ldi	r30, 0x01	; 1
    ba7a:	18 16       	cp	r1, r24
    ba7c:	08 f0       	brcs	.+2      	; 0xba80 <__divdi3+0xf4e>
    ba7e:	e0 e0       	ldi	r30, 0x00	; 0
    ba80:	f8 2e       	mov	r15, r24
    ba82:	ff 1a       	sub	r15, r31
    ba84:	ff 2d       	mov	r31, r15
    ba86:	31 e0       	ldi	r19, 0x01	; 1
    ba88:	8f 15       	cp	r24, r15
    ba8a:	08 f0       	brcs	.+2      	; 0xba8e <__divdi3+0xf5c>
    ba8c:	30 e0       	ldi	r19, 0x00	; 0
    ba8e:	e3 2b       	or	r30, r19
    ba90:	91 95       	neg	r25
    ba92:	30 2f       	mov	r19, r16
    ba94:	41 2f       	mov	r20, r17
    ba96:	5b 2f       	mov	r21, r27
    ba98:	64 2d       	mov	r22, r4
    ba9a:	7a 2f       	mov	r23, r26
    ba9c:	8f 2f       	mov	r24, r31
    ba9e:	9e 1b       	sub	r25, r30
    baa0:	c8 5b       	subi	r28, 0xB8	; 184
    baa2:	df 4f       	sbci	r29, 0xFF	; 255
    baa4:	e1 e1       	ldi	r30, 0x11	; 17
    baa6:	0c 94 66 5f 	jmp	0xbecc	; 0xbecc <__epilogue_restores__+0x2>

0000baaa <__cmpsf2>:
    baaa:	97 d0       	rcall	.+302    	; 0xbbda <__fp_cmp>
    baac:	08 f4       	brcc	.+2      	; 0xbab0 <__cmpsf2+0x6>
    baae:	81 e0       	ldi	r24, 0x01	; 1
    bab0:	08 95       	ret

0000bab2 <__divsf3>:
    bab2:	0c d0       	rcall	.+24     	; 0xbacc <__divsf3x>
    bab4:	cd c0       	rjmp	.+410    	; 0xbc50 <__fp_round>
    bab6:	c5 d0       	rcall	.+394    	; 0xbc42 <__fp_pscB>
    bab8:	40 f0       	brcs	.+16     	; 0xbaca <__divsf3+0x18>
    baba:	bc d0       	rcall	.+376    	; 0xbc34 <__fp_pscA>
    babc:	30 f0       	brcs	.+12     	; 0xbaca <__divsf3+0x18>
    babe:	21 f4       	brne	.+8      	; 0xbac8 <__divsf3+0x16>
    bac0:	5f 3f       	cpi	r21, 0xFF	; 255
    bac2:	19 f0       	breq	.+6      	; 0xbaca <__divsf3+0x18>
    bac4:	ae c0       	rjmp	.+348    	; 0xbc22 <__fp_inf>
    bac6:	51 11       	cpse	r21, r1
    bac8:	f7 c0       	rjmp	.+494    	; 0xbcb8 <__fp_szero>
    baca:	b1 c0       	rjmp	.+354    	; 0xbc2e <__fp_nan>

0000bacc <__divsf3x>:
    bacc:	d2 d0       	rcall	.+420    	; 0xbc72 <__fp_split3>
    bace:	98 f3       	brcs	.-26     	; 0xbab6 <__divsf3+0x4>

0000bad0 <__divsf3_pse>:
    bad0:	99 23       	and	r25, r25
    bad2:	c9 f3       	breq	.-14     	; 0xbac6 <__divsf3+0x14>
    bad4:	55 23       	and	r21, r21
    bad6:	b1 f3       	breq	.-20     	; 0xbac4 <__divsf3+0x12>
    bad8:	95 1b       	sub	r25, r21
    bada:	55 0b       	sbc	r21, r21
    badc:	bb 27       	eor	r27, r27
    bade:	aa 27       	eor	r26, r26
    bae0:	62 17       	cp	r22, r18
    bae2:	73 07       	cpc	r23, r19
    bae4:	84 07       	cpc	r24, r20
    bae6:	38 f0       	brcs	.+14     	; 0xbaf6 <__divsf3_pse+0x26>
    bae8:	9f 5f       	subi	r25, 0xFF	; 255
    baea:	5f 4f       	sbci	r21, 0xFF	; 255
    baec:	22 0f       	add	r18, r18
    baee:	33 1f       	adc	r19, r19
    baf0:	44 1f       	adc	r20, r20
    baf2:	aa 1f       	adc	r26, r26
    baf4:	a9 f3       	breq	.-22     	; 0xbae0 <__divsf3_pse+0x10>
    baf6:	33 d0       	rcall	.+102    	; 0xbb5e <__divsf3_pse+0x8e>
    baf8:	0e 2e       	mov	r0, r30
    bafa:	3a f0       	brmi	.+14     	; 0xbb0a <__divsf3_pse+0x3a>
    bafc:	e0 e8       	ldi	r30, 0x80	; 128
    bafe:	30 d0       	rcall	.+96     	; 0xbb60 <__divsf3_pse+0x90>
    bb00:	91 50       	subi	r25, 0x01	; 1
    bb02:	50 40       	sbci	r21, 0x00	; 0
    bb04:	e6 95       	lsr	r30
    bb06:	00 1c       	adc	r0, r0
    bb08:	ca f7       	brpl	.-14     	; 0xbafc <__divsf3_pse+0x2c>
    bb0a:	29 d0       	rcall	.+82     	; 0xbb5e <__divsf3_pse+0x8e>
    bb0c:	fe 2f       	mov	r31, r30
    bb0e:	27 d0       	rcall	.+78     	; 0xbb5e <__divsf3_pse+0x8e>
    bb10:	66 0f       	add	r22, r22
    bb12:	77 1f       	adc	r23, r23
    bb14:	88 1f       	adc	r24, r24
    bb16:	bb 1f       	adc	r27, r27
    bb18:	26 17       	cp	r18, r22
    bb1a:	37 07       	cpc	r19, r23
    bb1c:	48 07       	cpc	r20, r24
    bb1e:	ab 07       	cpc	r26, r27
    bb20:	b0 e8       	ldi	r27, 0x80	; 128
    bb22:	09 f0       	breq	.+2      	; 0xbb26 <__divsf3_pse+0x56>
    bb24:	bb 0b       	sbc	r27, r27
    bb26:	80 2d       	mov	r24, r0
    bb28:	bf 01       	movw	r22, r30
    bb2a:	ff 27       	eor	r31, r31
    bb2c:	93 58       	subi	r25, 0x83	; 131
    bb2e:	5f 4f       	sbci	r21, 0xFF	; 255
    bb30:	2a f0       	brmi	.+10     	; 0xbb3c <__divsf3_pse+0x6c>
    bb32:	9e 3f       	cpi	r25, 0xFE	; 254
    bb34:	51 05       	cpc	r21, r1
    bb36:	68 f0       	brcs	.+26     	; 0xbb52 <__divsf3_pse+0x82>
    bb38:	74 c0       	rjmp	.+232    	; 0xbc22 <__fp_inf>
    bb3a:	be c0       	rjmp	.+380    	; 0xbcb8 <__fp_szero>
    bb3c:	5f 3f       	cpi	r21, 0xFF	; 255
    bb3e:	ec f3       	brlt	.-6      	; 0xbb3a <__divsf3_pse+0x6a>
    bb40:	98 3e       	cpi	r25, 0xE8	; 232
    bb42:	dc f3       	brlt	.-10     	; 0xbb3a <__divsf3_pse+0x6a>
    bb44:	86 95       	lsr	r24
    bb46:	77 95       	ror	r23
    bb48:	67 95       	ror	r22
    bb4a:	b7 95       	ror	r27
    bb4c:	f7 95       	ror	r31
    bb4e:	9f 5f       	subi	r25, 0xFF	; 255
    bb50:	c9 f7       	brne	.-14     	; 0xbb44 <__divsf3_pse+0x74>
    bb52:	88 0f       	add	r24, r24
    bb54:	91 1d       	adc	r25, r1
    bb56:	96 95       	lsr	r25
    bb58:	87 95       	ror	r24
    bb5a:	97 f9       	bld	r25, 7
    bb5c:	08 95       	ret
    bb5e:	e1 e0       	ldi	r30, 0x01	; 1
    bb60:	66 0f       	add	r22, r22
    bb62:	77 1f       	adc	r23, r23
    bb64:	88 1f       	adc	r24, r24
    bb66:	bb 1f       	adc	r27, r27
    bb68:	62 17       	cp	r22, r18
    bb6a:	73 07       	cpc	r23, r19
    bb6c:	84 07       	cpc	r24, r20
    bb6e:	ba 07       	cpc	r27, r26
    bb70:	20 f0       	brcs	.+8      	; 0xbb7a <__divsf3_pse+0xaa>
    bb72:	62 1b       	sub	r22, r18
    bb74:	73 0b       	sbc	r23, r19
    bb76:	84 0b       	sbc	r24, r20
    bb78:	ba 0b       	sbc	r27, r26
    bb7a:	ee 1f       	adc	r30, r30
    bb7c:	88 f7       	brcc	.-30     	; 0xbb60 <__divsf3_pse+0x90>
    bb7e:	e0 95       	com	r30
    bb80:	08 95       	ret

0000bb82 <__fixunssfsi>:
    bb82:	7f d0       	rcall	.+254    	; 0xbc82 <__fp_splitA>
    bb84:	88 f0       	brcs	.+34     	; 0xbba8 <__fixunssfsi+0x26>
    bb86:	9f 57       	subi	r25, 0x7F	; 127
    bb88:	90 f0       	brcs	.+36     	; 0xbbae <__fixunssfsi+0x2c>
    bb8a:	b9 2f       	mov	r27, r25
    bb8c:	99 27       	eor	r25, r25
    bb8e:	b7 51       	subi	r27, 0x17	; 23
    bb90:	a0 f0       	brcs	.+40     	; 0xbbba <__fixunssfsi+0x38>
    bb92:	d1 f0       	breq	.+52     	; 0xbbc8 <__fixunssfsi+0x46>
    bb94:	66 0f       	add	r22, r22
    bb96:	77 1f       	adc	r23, r23
    bb98:	88 1f       	adc	r24, r24
    bb9a:	99 1f       	adc	r25, r25
    bb9c:	1a f0       	brmi	.+6      	; 0xbba4 <__fixunssfsi+0x22>
    bb9e:	ba 95       	dec	r27
    bba0:	c9 f7       	brne	.-14     	; 0xbb94 <__fixunssfsi+0x12>
    bba2:	12 c0       	rjmp	.+36     	; 0xbbc8 <__fixunssfsi+0x46>
    bba4:	b1 30       	cpi	r27, 0x01	; 1
    bba6:	81 f0       	breq	.+32     	; 0xbbc8 <__fixunssfsi+0x46>
    bba8:	86 d0       	rcall	.+268    	; 0xbcb6 <__fp_zero>
    bbaa:	b1 e0       	ldi	r27, 0x01	; 1
    bbac:	08 95       	ret
    bbae:	83 c0       	rjmp	.+262    	; 0xbcb6 <__fp_zero>
    bbb0:	67 2f       	mov	r22, r23
    bbb2:	78 2f       	mov	r23, r24
    bbb4:	88 27       	eor	r24, r24
    bbb6:	b8 5f       	subi	r27, 0xF8	; 248
    bbb8:	39 f0       	breq	.+14     	; 0xbbc8 <__fixunssfsi+0x46>
    bbba:	b9 3f       	cpi	r27, 0xF9	; 249
    bbbc:	cc f3       	brlt	.-14     	; 0xbbb0 <__fixunssfsi+0x2e>
    bbbe:	86 95       	lsr	r24
    bbc0:	77 95       	ror	r23
    bbc2:	67 95       	ror	r22
    bbc4:	b3 95       	inc	r27
    bbc6:	d9 f7       	brne	.-10     	; 0xbbbe <__fixunssfsi+0x3c>
    bbc8:	3e f4       	brtc	.+14     	; 0xbbd8 <__fixunssfsi+0x56>
    bbca:	90 95       	com	r25
    bbcc:	80 95       	com	r24
    bbce:	70 95       	com	r23
    bbd0:	61 95       	neg	r22
    bbd2:	7f 4f       	sbci	r23, 0xFF	; 255
    bbd4:	8f 4f       	sbci	r24, 0xFF	; 255
    bbd6:	9f 4f       	sbci	r25, 0xFF	; 255
    bbd8:	08 95       	ret

0000bbda <__fp_cmp>:
    bbda:	99 0f       	add	r25, r25
    bbdc:	00 08       	sbc	r0, r0
    bbde:	55 0f       	add	r21, r21
    bbe0:	aa 0b       	sbc	r26, r26
    bbe2:	e0 e8       	ldi	r30, 0x80	; 128
    bbe4:	fe ef       	ldi	r31, 0xFE	; 254
    bbe6:	16 16       	cp	r1, r22
    bbe8:	17 06       	cpc	r1, r23
    bbea:	e8 07       	cpc	r30, r24
    bbec:	f9 07       	cpc	r31, r25
    bbee:	c0 f0       	brcs	.+48     	; 0xbc20 <__fp_cmp+0x46>
    bbf0:	12 16       	cp	r1, r18
    bbf2:	13 06       	cpc	r1, r19
    bbf4:	e4 07       	cpc	r30, r20
    bbf6:	f5 07       	cpc	r31, r21
    bbf8:	98 f0       	brcs	.+38     	; 0xbc20 <__fp_cmp+0x46>
    bbfa:	62 1b       	sub	r22, r18
    bbfc:	73 0b       	sbc	r23, r19
    bbfe:	84 0b       	sbc	r24, r20
    bc00:	95 0b       	sbc	r25, r21
    bc02:	39 f4       	brne	.+14     	; 0xbc12 <__fp_cmp+0x38>
    bc04:	0a 26       	eor	r0, r26
    bc06:	61 f0       	breq	.+24     	; 0xbc20 <__fp_cmp+0x46>
    bc08:	23 2b       	or	r18, r19
    bc0a:	24 2b       	or	r18, r20
    bc0c:	25 2b       	or	r18, r21
    bc0e:	21 f4       	brne	.+8      	; 0xbc18 <__fp_cmp+0x3e>
    bc10:	08 95       	ret
    bc12:	0a 26       	eor	r0, r26
    bc14:	09 f4       	brne	.+2      	; 0xbc18 <__fp_cmp+0x3e>
    bc16:	a1 40       	sbci	r26, 0x01	; 1
    bc18:	a6 95       	lsr	r26
    bc1a:	8f ef       	ldi	r24, 0xFF	; 255
    bc1c:	81 1d       	adc	r24, r1
    bc1e:	81 1d       	adc	r24, r1
    bc20:	08 95       	ret

0000bc22 <__fp_inf>:
    bc22:	97 f9       	bld	r25, 7
    bc24:	9f 67       	ori	r25, 0x7F	; 127
    bc26:	80 e8       	ldi	r24, 0x80	; 128
    bc28:	70 e0       	ldi	r23, 0x00	; 0
    bc2a:	60 e0       	ldi	r22, 0x00	; 0
    bc2c:	08 95       	ret

0000bc2e <__fp_nan>:
    bc2e:	9f ef       	ldi	r25, 0xFF	; 255
    bc30:	80 ec       	ldi	r24, 0xC0	; 192
    bc32:	08 95       	ret

0000bc34 <__fp_pscA>:
    bc34:	00 24       	eor	r0, r0
    bc36:	0a 94       	dec	r0
    bc38:	16 16       	cp	r1, r22
    bc3a:	17 06       	cpc	r1, r23
    bc3c:	18 06       	cpc	r1, r24
    bc3e:	09 06       	cpc	r0, r25
    bc40:	08 95       	ret

0000bc42 <__fp_pscB>:
    bc42:	00 24       	eor	r0, r0
    bc44:	0a 94       	dec	r0
    bc46:	12 16       	cp	r1, r18
    bc48:	13 06       	cpc	r1, r19
    bc4a:	14 06       	cpc	r1, r20
    bc4c:	05 06       	cpc	r0, r21
    bc4e:	08 95       	ret

0000bc50 <__fp_round>:
    bc50:	09 2e       	mov	r0, r25
    bc52:	03 94       	inc	r0
    bc54:	00 0c       	add	r0, r0
    bc56:	11 f4       	brne	.+4      	; 0xbc5c <__fp_round+0xc>
    bc58:	88 23       	and	r24, r24
    bc5a:	52 f0       	brmi	.+20     	; 0xbc70 <__fp_round+0x20>
    bc5c:	bb 0f       	add	r27, r27
    bc5e:	40 f4       	brcc	.+16     	; 0xbc70 <__fp_round+0x20>
    bc60:	bf 2b       	or	r27, r31
    bc62:	11 f4       	brne	.+4      	; 0xbc68 <__fp_round+0x18>
    bc64:	60 ff       	sbrs	r22, 0
    bc66:	04 c0       	rjmp	.+8      	; 0xbc70 <__fp_round+0x20>
    bc68:	6f 5f       	subi	r22, 0xFF	; 255
    bc6a:	7f 4f       	sbci	r23, 0xFF	; 255
    bc6c:	8f 4f       	sbci	r24, 0xFF	; 255
    bc6e:	9f 4f       	sbci	r25, 0xFF	; 255
    bc70:	08 95       	ret

0000bc72 <__fp_split3>:
    bc72:	57 fd       	sbrc	r21, 7
    bc74:	90 58       	subi	r25, 0x80	; 128
    bc76:	44 0f       	add	r20, r20
    bc78:	55 1f       	adc	r21, r21
    bc7a:	59 f0       	breq	.+22     	; 0xbc92 <__fp_splitA+0x10>
    bc7c:	5f 3f       	cpi	r21, 0xFF	; 255
    bc7e:	71 f0       	breq	.+28     	; 0xbc9c <__fp_splitA+0x1a>
    bc80:	47 95       	ror	r20

0000bc82 <__fp_splitA>:
    bc82:	88 0f       	add	r24, r24
    bc84:	97 fb       	bst	r25, 7
    bc86:	99 1f       	adc	r25, r25
    bc88:	61 f0       	breq	.+24     	; 0xbca2 <__fp_splitA+0x20>
    bc8a:	9f 3f       	cpi	r25, 0xFF	; 255
    bc8c:	79 f0       	breq	.+30     	; 0xbcac <__fp_splitA+0x2a>
    bc8e:	87 95       	ror	r24
    bc90:	08 95       	ret
    bc92:	12 16       	cp	r1, r18
    bc94:	13 06       	cpc	r1, r19
    bc96:	14 06       	cpc	r1, r20
    bc98:	55 1f       	adc	r21, r21
    bc9a:	f2 cf       	rjmp	.-28     	; 0xbc80 <__fp_split3+0xe>
    bc9c:	46 95       	lsr	r20
    bc9e:	f1 df       	rcall	.-30     	; 0xbc82 <__fp_splitA>
    bca0:	08 c0       	rjmp	.+16     	; 0xbcb2 <__fp_splitA+0x30>
    bca2:	16 16       	cp	r1, r22
    bca4:	17 06       	cpc	r1, r23
    bca6:	18 06       	cpc	r1, r24
    bca8:	99 1f       	adc	r25, r25
    bcaa:	f1 cf       	rjmp	.-30     	; 0xbc8e <__fp_splitA+0xc>
    bcac:	86 95       	lsr	r24
    bcae:	71 05       	cpc	r23, r1
    bcb0:	61 05       	cpc	r22, r1
    bcb2:	08 94       	sec
    bcb4:	08 95       	ret

0000bcb6 <__fp_zero>:
    bcb6:	e8 94       	clt

0000bcb8 <__fp_szero>:
    bcb8:	bb 27       	eor	r27, r27
    bcba:	66 27       	eor	r22, r22
    bcbc:	77 27       	eor	r23, r23
    bcbe:	cb 01       	movw	r24, r22
    bcc0:	97 f9       	bld	r25, 7
    bcc2:	08 95       	ret

0000bcc4 <__gesf2>:
    bcc4:	8a df       	rcall	.-236    	; 0xbbda <__fp_cmp>
    bcc6:	08 f4       	brcc	.+2      	; 0xbcca <__gesf2+0x6>
    bcc8:	8f ef       	ldi	r24, 0xFF	; 255
    bcca:	08 95       	ret

0000bccc <__mulsf3>:
    bccc:	0b d0       	rcall	.+22     	; 0xbce4 <__mulsf3x>
    bcce:	c0 cf       	rjmp	.-128    	; 0xbc50 <__fp_round>
    bcd0:	b1 df       	rcall	.-158    	; 0xbc34 <__fp_pscA>
    bcd2:	28 f0       	brcs	.+10     	; 0xbcde <__mulsf3+0x12>
    bcd4:	b6 df       	rcall	.-148    	; 0xbc42 <__fp_pscB>
    bcd6:	18 f0       	brcs	.+6      	; 0xbcde <__mulsf3+0x12>
    bcd8:	95 23       	and	r25, r21
    bcda:	09 f0       	breq	.+2      	; 0xbcde <__mulsf3+0x12>
    bcdc:	a2 cf       	rjmp	.-188    	; 0xbc22 <__fp_inf>
    bcde:	a7 cf       	rjmp	.-178    	; 0xbc2e <__fp_nan>
    bce0:	11 24       	eor	r1, r1
    bce2:	ea cf       	rjmp	.-44     	; 0xbcb8 <__fp_szero>

0000bce4 <__mulsf3x>:
    bce4:	c6 df       	rcall	.-116    	; 0xbc72 <__fp_split3>
    bce6:	a0 f3       	brcs	.-24     	; 0xbcd0 <__mulsf3+0x4>

0000bce8 <__mulsf3_pse>:
    bce8:	95 9f       	mul	r25, r21
    bcea:	d1 f3       	breq	.-12     	; 0xbce0 <__mulsf3+0x14>
    bcec:	95 0f       	add	r25, r21
    bcee:	50 e0       	ldi	r21, 0x00	; 0
    bcf0:	55 1f       	adc	r21, r21
    bcf2:	62 9f       	mul	r22, r18
    bcf4:	f0 01       	movw	r30, r0
    bcf6:	72 9f       	mul	r23, r18
    bcf8:	bb 27       	eor	r27, r27
    bcfa:	f0 0d       	add	r31, r0
    bcfc:	b1 1d       	adc	r27, r1
    bcfe:	63 9f       	mul	r22, r19
    bd00:	aa 27       	eor	r26, r26
    bd02:	f0 0d       	add	r31, r0
    bd04:	b1 1d       	adc	r27, r1
    bd06:	aa 1f       	adc	r26, r26
    bd08:	64 9f       	mul	r22, r20
    bd0a:	66 27       	eor	r22, r22
    bd0c:	b0 0d       	add	r27, r0
    bd0e:	a1 1d       	adc	r26, r1
    bd10:	66 1f       	adc	r22, r22
    bd12:	82 9f       	mul	r24, r18
    bd14:	22 27       	eor	r18, r18
    bd16:	b0 0d       	add	r27, r0
    bd18:	a1 1d       	adc	r26, r1
    bd1a:	62 1f       	adc	r22, r18
    bd1c:	73 9f       	mul	r23, r19
    bd1e:	b0 0d       	add	r27, r0
    bd20:	a1 1d       	adc	r26, r1
    bd22:	62 1f       	adc	r22, r18
    bd24:	83 9f       	mul	r24, r19
    bd26:	a0 0d       	add	r26, r0
    bd28:	61 1d       	adc	r22, r1
    bd2a:	22 1f       	adc	r18, r18
    bd2c:	74 9f       	mul	r23, r20
    bd2e:	33 27       	eor	r19, r19
    bd30:	a0 0d       	add	r26, r0
    bd32:	61 1d       	adc	r22, r1
    bd34:	23 1f       	adc	r18, r19
    bd36:	84 9f       	mul	r24, r20
    bd38:	60 0d       	add	r22, r0
    bd3a:	21 1d       	adc	r18, r1
    bd3c:	82 2f       	mov	r24, r18
    bd3e:	76 2f       	mov	r23, r22
    bd40:	6a 2f       	mov	r22, r26
    bd42:	11 24       	eor	r1, r1
    bd44:	9f 57       	subi	r25, 0x7F	; 127
    bd46:	50 40       	sbci	r21, 0x00	; 0
    bd48:	8a f0       	brmi	.+34     	; 0xbd6c <__mulsf3_pse+0x84>
    bd4a:	e1 f0       	breq	.+56     	; 0xbd84 <__mulsf3_pse+0x9c>
    bd4c:	88 23       	and	r24, r24
    bd4e:	4a f0       	brmi	.+18     	; 0xbd62 <__mulsf3_pse+0x7a>
    bd50:	ee 0f       	add	r30, r30
    bd52:	ff 1f       	adc	r31, r31
    bd54:	bb 1f       	adc	r27, r27
    bd56:	66 1f       	adc	r22, r22
    bd58:	77 1f       	adc	r23, r23
    bd5a:	88 1f       	adc	r24, r24
    bd5c:	91 50       	subi	r25, 0x01	; 1
    bd5e:	50 40       	sbci	r21, 0x00	; 0
    bd60:	a9 f7       	brne	.-22     	; 0xbd4c <__mulsf3_pse+0x64>
    bd62:	9e 3f       	cpi	r25, 0xFE	; 254
    bd64:	51 05       	cpc	r21, r1
    bd66:	70 f0       	brcs	.+28     	; 0xbd84 <__mulsf3_pse+0x9c>
    bd68:	5c cf       	rjmp	.-328    	; 0xbc22 <__fp_inf>
    bd6a:	a6 cf       	rjmp	.-180    	; 0xbcb8 <__fp_szero>
    bd6c:	5f 3f       	cpi	r21, 0xFF	; 255
    bd6e:	ec f3       	brlt	.-6      	; 0xbd6a <__mulsf3_pse+0x82>
    bd70:	98 3e       	cpi	r25, 0xE8	; 232
    bd72:	dc f3       	brlt	.-10     	; 0xbd6a <__mulsf3_pse+0x82>
    bd74:	86 95       	lsr	r24
    bd76:	77 95       	ror	r23
    bd78:	67 95       	ror	r22
    bd7a:	b7 95       	ror	r27
    bd7c:	f7 95       	ror	r31
    bd7e:	e7 95       	ror	r30
    bd80:	9f 5f       	subi	r25, 0xFF	; 255
    bd82:	c1 f7       	brne	.-16     	; 0xbd74 <__mulsf3_pse+0x8c>
    bd84:	fe 2b       	or	r31, r30
    bd86:	88 0f       	add	r24, r24
    bd88:	91 1d       	adc	r25, r1
    bd8a:	96 95       	lsr	r25
    bd8c:	87 95       	ror	r24
    bd8e:	97 f9       	bld	r25, 7
    bd90:	08 95       	ret

0000bd92 <__mulsi3>:
    bd92:	62 9f       	mul	r22, r18
    bd94:	d0 01       	movw	r26, r0
    bd96:	73 9f       	mul	r23, r19
    bd98:	f0 01       	movw	r30, r0
    bd9a:	82 9f       	mul	r24, r18
    bd9c:	e0 0d       	add	r30, r0
    bd9e:	f1 1d       	adc	r31, r1
    bda0:	64 9f       	mul	r22, r20
    bda2:	e0 0d       	add	r30, r0
    bda4:	f1 1d       	adc	r31, r1
    bda6:	92 9f       	mul	r25, r18
    bda8:	f0 0d       	add	r31, r0
    bdaa:	83 9f       	mul	r24, r19
    bdac:	f0 0d       	add	r31, r0
    bdae:	74 9f       	mul	r23, r20
    bdb0:	f0 0d       	add	r31, r0
    bdb2:	65 9f       	mul	r22, r21
    bdb4:	f0 0d       	add	r31, r0
    bdb6:	99 27       	eor	r25, r25
    bdb8:	72 9f       	mul	r23, r18
    bdba:	b0 0d       	add	r27, r0
    bdbc:	e1 1d       	adc	r30, r1
    bdbe:	f9 1f       	adc	r31, r25
    bdc0:	63 9f       	mul	r22, r19
    bdc2:	b0 0d       	add	r27, r0
    bdc4:	e1 1d       	adc	r30, r1
    bdc6:	f9 1f       	adc	r31, r25
    bdc8:	bd 01       	movw	r22, r26
    bdca:	cf 01       	movw	r24, r30
    bdcc:	11 24       	eor	r1, r1
    bdce:	08 95       	ret

0000bdd0 <__udivmodhi4>:
    bdd0:	aa 1b       	sub	r26, r26
    bdd2:	bb 1b       	sub	r27, r27
    bdd4:	51 e1       	ldi	r21, 0x11	; 17
    bdd6:	07 c0       	rjmp	.+14     	; 0xbde6 <__udivmodhi4_ep>

0000bdd8 <__udivmodhi4_loop>:
    bdd8:	aa 1f       	adc	r26, r26
    bdda:	bb 1f       	adc	r27, r27
    bddc:	a6 17       	cp	r26, r22
    bdde:	b7 07       	cpc	r27, r23
    bde0:	10 f0       	brcs	.+4      	; 0xbde6 <__udivmodhi4_ep>
    bde2:	a6 1b       	sub	r26, r22
    bde4:	b7 0b       	sbc	r27, r23

0000bde6 <__udivmodhi4_ep>:
    bde6:	88 1f       	adc	r24, r24
    bde8:	99 1f       	adc	r25, r25
    bdea:	5a 95       	dec	r21
    bdec:	a9 f7       	brne	.-22     	; 0xbdd8 <__udivmodhi4_loop>
    bdee:	80 95       	com	r24
    bdf0:	90 95       	com	r25
    bdf2:	bc 01       	movw	r22, r24
    bdf4:	cd 01       	movw	r24, r26
    bdf6:	08 95       	ret

0000bdf8 <__divmodhi4>:
    bdf8:	97 fb       	bst	r25, 7
    bdfa:	09 2e       	mov	r0, r25
    bdfc:	07 26       	eor	r0, r23
    bdfe:	0a d0       	rcall	.+20     	; 0xbe14 <__divmodhi4_neg1>
    be00:	77 fd       	sbrc	r23, 7
    be02:	04 d0       	rcall	.+8      	; 0xbe0c <__divmodhi4_neg2>
    be04:	e5 df       	rcall	.-54     	; 0xbdd0 <__udivmodhi4>
    be06:	06 d0       	rcall	.+12     	; 0xbe14 <__divmodhi4_neg1>
    be08:	00 20       	and	r0, r0
    be0a:	1a f4       	brpl	.+6      	; 0xbe12 <__divmodhi4_exit>

0000be0c <__divmodhi4_neg2>:
    be0c:	70 95       	com	r23
    be0e:	61 95       	neg	r22
    be10:	7f 4f       	sbci	r23, 0xFF	; 255

0000be12 <__divmodhi4_exit>:
    be12:	08 95       	ret

0000be14 <__divmodhi4_neg1>:
    be14:	f6 f7       	brtc	.-4      	; 0xbe12 <__divmodhi4_exit>
    be16:	90 95       	com	r25
    be18:	81 95       	neg	r24
    be1a:	9f 4f       	sbci	r25, 0xFF	; 255
    be1c:	08 95       	ret

0000be1e <__udivmodsi4>:
    be1e:	a1 e2       	ldi	r26, 0x21	; 33
    be20:	1a 2e       	mov	r1, r26
    be22:	aa 1b       	sub	r26, r26
    be24:	bb 1b       	sub	r27, r27
    be26:	fd 01       	movw	r30, r26
    be28:	0d c0       	rjmp	.+26     	; 0xbe44 <__udivmodsi4_ep>

0000be2a <__udivmodsi4_loop>:
    be2a:	aa 1f       	adc	r26, r26
    be2c:	bb 1f       	adc	r27, r27
    be2e:	ee 1f       	adc	r30, r30
    be30:	ff 1f       	adc	r31, r31
    be32:	a2 17       	cp	r26, r18
    be34:	b3 07       	cpc	r27, r19
    be36:	e4 07       	cpc	r30, r20
    be38:	f5 07       	cpc	r31, r21
    be3a:	20 f0       	brcs	.+8      	; 0xbe44 <__udivmodsi4_ep>
    be3c:	a2 1b       	sub	r26, r18
    be3e:	b3 0b       	sbc	r27, r19
    be40:	e4 0b       	sbc	r30, r20
    be42:	f5 0b       	sbc	r31, r21

0000be44 <__udivmodsi4_ep>:
    be44:	66 1f       	adc	r22, r22
    be46:	77 1f       	adc	r23, r23
    be48:	88 1f       	adc	r24, r24
    be4a:	99 1f       	adc	r25, r25
    be4c:	1a 94       	dec	r1
    be4e:	69 f7       	brne	.-38     	; 0xbe2a <__udivmodsi4_loop>
    be50:	60 95       	com	r22
    be52:	70 95       	com	r23
    be54:	80 95       	com	r24
    be56:	90 95       	com	r25
    be58:	9b 01       	movw	r18, r22
    be5a:	ac 01       	movw	r20, r24
    be5c:	bd 01       	movw	r22, r26
    be5e:	cf 01       	movw	r24, r30
    be60:	08 95       	ret

0000be62 <__divmodsi4>:
    be62:	97 fb       	bst	r25, 7
    be64:	09 2e       	mov	r0, r25
    be66:	05 26       	eor	r0, r21
    be68:	0e d0       	rcall	.+28     	; 0xbe86 <__divmodsi4_neg1>
    be6a:	57 fd       	sbrc	r21, 7
    be6c:	04 d0       	rcall	.+8      	; 0xbe76 <__divmodsi4_neg2>
    be6e:	d7 df       	rcall	.-82     	; 0xbe1e <__udivmodsi4>
    be70:	0a d0       	rcall	.+20     	; 0xbe86 <__divmodsi4_neg1>
    be72:	00 1c       	adc	r0, r0
    be74:	38 f4       	brcc	.+14     	; 0xbe84 <__divmodsi4_exit>

0000be76 <__divmodsi4_neg2>:
    be76:	50 95       	com	r21
    be78:	40 95       	com	r20
    be7a:	30 95       	com	r19
    be7c:	21 95       	neg	r18
    be7e:	3f 4f       	sbci	r19, 0xFF	; 255
    be80:	4f 4f       	sbci	r20, 0xFF	; 255
    be82:	5f 4f       	sbci	r21, 0xFF	; 255

0000be84 <__divmodsi4_exit>:
    be84:	08 95       	ret

0000be86 <__divmodsi4_neg1>:
    be86:	f6 f7       	brtc	.-4      	; 0xbe84 <__divmodsi4_exit>
    be88:	90 95       	com	r25
    be8a:	80 95       	com	r24
    be8c:	70 95       	com	r23
    be8e:	61 95       	neg	r22
    be90:	7f 4f       	sbci	r23, 0xFF	; 255
    be92:	8f 4f       	sbci	r24, 0xFF	; 255
    be94:	9f 4f       	sbci	r25, 0xFF	; 255
    be96:	08 95       	ret

0000be98 <__prologue_saves__>:
    be98:	2f 92       	push	r2
    be9a:	3f 92       	push	r3
    be9c:	4f 92       	push	r4
    be9e:	5f 92       	push	r5
    bea0:	6f 92       	push	r6
    bea2:	7f 92       	push	r7
    bea4:	8f 92       	push	r8
    bea6:	9f 92       	push	r9
    bea8:	af 92       	push	r10
    beaa:	bf 92       	push	r11
    beac:	cf 92       	push	r12
    beae:	df 92       	push	r13
    beb0:	ef 92       	push	r14
    beb2:	ff 92       	push	r15
    beb4:	0f 93       	push	r16
    beb6:	1f 93       	push	r17
    beb8:	cf 93       	push	r28
    beba:	df 93       	push	r29
    bebc:	cd b7       	in	r28, 0x3d	; 61
    bebe:	de b7       	in	r29, 0x3e	; 62
    bec0:	ca 1b       	sub	r28, r26
    bec2:	db 0b       	sbc	r29, r27
    bec4:	cd bf       	out	0x3d, r28	; 61
    bec6:	de bf       	out	0x3e, r29	; 62
    bec8:	19 94       	eijmp

0000beca <__epilogue_restores__>:
    beca:	2a 88       	ldd	r2, Y+18	; 0x12
    becc:	39 88       	ldd	r3, Y+17	; 0x11
    bece:	48 88       	ldd	r4, Y+16	; 0x10
    bed0:	5f 84       	ldd	r5, Y+15	; 0x0f
    bed2:	6e 84       	ldd	r6, Y+14	; 0x0e
    bed4:	7d 84       	ldd	r7, Y+13	; 0x0d
    bed6:	8c 84       	ldd	r8, Y+12	; 0x0c
    bed8:	9b 84       	ldd	r9, Y+11	; 0x0b
    beda:	aa 84       	ldd	r10, Y+10	; 0x0a
    bedc:	b9 84       	ldd	r11, Y+9	; 0x09
    bede:	c8 84       	ldd	r12, Y+8	; 0x08
    bee0:	df 80       	ldd	r13, Y+7	; 0x07
    bee2:	ee 80       	ldd	r14, Y+6	; 0x06
    bee4:	fd 80       	ldd	r15, Y+5	; 0x05
    bee6:	0c 81       	ldd	r16, Y+4	; 0x04
    bee8:	1b 81       	ldd	r17, Y+3	; 0x03
    beea:	aa 81       	ldd	r26, Y+2	; 0x02
    beec:	b9 81       	ldd	r27, Y+1	; 0x01
    beee:	ce 0f       	add	r28, r30
    bef0:	d1 1d       	adc	r29, r1
    bef2:	cd bf       	out	0x3d, r28	; 61
    bef4:	de bf       	out	0x3e, r29	; 62
    bef6:	ed 01       	movw	r28, r26
    bef8:	08 95       	ret

0000befa <strcpy_P>:
    befa:	fb 01       	movw	r30, r22
    befc:	dc 01       	movw	r26, r24
    befe:	05 90       	lpm	r0, Z+
    bf00:	0d 92       	st	X+, r0
    bf02:	00 20       	and	r0, r0
    bf04:	e1 f7       	brne	.-8      	; 0xbefe <strcpy_P+0x4>
    bf06:	08 95       	ret

0000bf08 <memcpy>:
    bf08:	fb 01       	movw	r30, r22
    bf0a:	dc 01       	movw	r26, r24
    bf0c:	02 c0       	rjmp	.+4      	; 0xbf12 <memcpy+0xa>
    bf0e:	01 90       	ld	r0, Z+
    bf10:	0d 92       	st	X+, r0
    bf12:	41 50       	subi	r20, 0x01	; 1
    bf14:	50 40       	sbci	r21, 0x00	; 0
    bf16:	d8 f7       	brcc	.-10     	; 0xbf0e <memcpy+0x6>
    bf18:	08 95       	ret

0000bf1a <memmove>:
    bf1a:	68 17       	cp	r22, r24
    bf1c:	79 07       	cpc	r23, r25
    bf1e:	68 f4       	brcc	.+26     	; 0xbf3a <memmove+0x20>
    bf20:	fb 01       	movw	r30, r22
    bf22:	dc 01       	movw	r26, r24
    bf24:	e4 0f       	add	r30, r20
    bf26:	f5 1f       	adc	r31, r21
    bf28:	a4 0f       	add	r26, r20
    bf2a:	b5 1f       	adc	r27, r21
    bf2c:	02 c0       	rjmp	.+4      	; 0xbf32 <memmove+0x18>
    bf2e:	02 90       	ld	r0, -Z
    bf30:	0e 92       	st	-X, r0
    bf32:	41 50       	subi	r20, 0x01	; 1
    bf34:	50 40       	sbci	r21, 0x00	; 0
    bf36:	d8 f7       	brcc	.-10     	; 0xbf2e <memmove+0x14>
    bf38:	08 95       	ret
    bf3a:	0c 94 84 5f 	jmp	0xbf08	; 0xbf08 <memcpy>

0000bf3e <strcat>:
    bf3e:	fb 01       	movw	r30, r22
    bf40:	dc 01       	movw	r26, r24
    bf42:	0d 90       	ld	r0, X+
    bf44:	00 20       	and	r0, r0
    bf46:	e9 f7       	brne	.-6      	; 0xbf42 <strcat+0x4>
    bf48:	11 97       	sbiw	r26, 0x01	; 1
    bf4a:	01 90       	ld	r0, Z+
    bf4c:	0d 92       	st	X+, r0
    bf4e:	00 20       	and	r0, r0
    bf50:	e1 f7       	brne	.-8      	; 0xbf4a <strcat+0xc>
    bf52:	08 95       	ret

0000bf54 <strcpy>:
    bf54:	fb 01       	movw	r30, r22
    bf56:	dc 01       	movw	r26, r24
    bf58:	01 90       	ld	r0, Z+
    bf5a:	0d 92       	st	X+, r0
    bf5c:	00 20       	and	r0, r0
    bf5e:	e1 f7       	brne	.-8      	; 0xbf58 <strcpy+0x4>
    bf60:	08 95       	ret

0000bf62 <strncmp>:
    bf62:	fb 01       	movw	r30, r22
    bf64:	dc 01       	movw	r26, r24
    bf66:	41 50       	subi	r20, 0x01	; 1
    bf68:	50 40       	sbci	r21, 0x00	; 0
    bf6a:	30 f0       	brcs	.+12     	; 0xbf78 <strncmp+0x16>
    bf6c:	8d 91       	ld	r24, X+
    bf6e:	01 90       	ld	r0, Z+
    bf70:	80 19       	sub	r24, r0
    bf72:	19 f4       	brne	.+6      	; 0xbf7a <strncmp+0x18>
    bf74:	00 20       	and	r0, r0
    bf76:	b9 f7       	brne	.-18     	; 0xbf66 <strncmp+0x4>
    bf78:	88 1b       	sub	r24, r24
    bf7a:	99 0b       	sbc	r25, r25
    bf7c:	08 95       	ret

0000bf7e <itoa>:
    bf7e:	fb 01       	movw	r30, r22
    bf80:	9f 01       	movw	r18, r30
    bf82:	e8 94       	clt
    bf84:	42 30       	cpi	r20, 0x02	; 2
    bf86:	c4 f0       	brlt	.+48     	; 0xbfb8 <itoa+0x3a>
    bf88:	45 32       	cpi	r20, 0x25	; 37
    bf8a:	b4 f4       	brge	.+44     	; 0xbfb8 <itoa+0x3a>
    bf8c:	4a 30       	cpi	r20, 0x0A	; 10
    bf8e:	29 f4       	brne	.+10     	; 0xbf9a <itoa+0x1c>
    bf90:	97 fb       	bst	r25, 7
    bf92:	1e f4       	brtc	.+6      	; 0xbf9a <itoa+0x1c>
    bf94:	90 95       	com	r25
    bf96:	81 95       	neg	r24
    bf98:	9f 4f       	sbci	r25, 0xFF	; 255
    bf9a:	64 2f       	mov	r22, r20
    bf9c:	77 27       	eor	r23, r23
    bf9e:	0e 94 e8 5e 	call	0xbdd0	; 0xbdd0 <__udivmodhi4>
    bfa2:	80 5d       	subi	r24, 0xD0	; 208
    bfa4:	8a 33       	cpi	r24, 0x3A	; 58
    bfa6:	0c f0       	brlt	.+2      	; 0xbfaa <itoa+0x2c>
    bfa8:	89 5d       	subi	r24, 0xD9	; 217
    bfaa:	81 93       	st	Z+, r24
    bfac:	cb 01       	movw	r24, r22
    bfae:	00 97       	sbiw	r24, 0x00	; 0
    bfb0:	a1 f7       	brne	.-24     	; 0xbf9a <itoa+0x1c>
    bfb2:	16 f4       	brtc	.+4      	; 0xbfb8 <itoa+0x3a>
    bfb4:	5d e2       	ldi	r21, 0x2D	; 45
    bfb6:	51 93       	st	Z+, r21
    bfb8:	10 82       	st	Z, r1
    bfba:	c9 01       	movw	r24, r18
    bfbc:	0c 94 09 62 	jmp	0xc412	; 0xc412 <strrev>

0000bfc0 <printf>:
    bfc0:	cf 93       	push	r28
    bfc2:	df 93       	push	r29
    bfc4:	cd b7       	in	r28, 0x3d	; 61
    bfc6:	de b7       	in	r29, 0x3e	; 62
    bfc8:	fe 01       	movw	r30, r28
    bfca:	36 96       	adiw	r30, 0x06	; 6
    bfcc:	61 91       	ld	r22, Z+
    bfce:	71 91       	ld	r23, Z+
    bfd0:	80 91 e0 50 	lds	r24, 0x50E0
    bfd4:	90 91 e1 50 	lds	r25, 0x50E1
    bfd8:	af 01       	movw	r20, r30
    bfda:	0e 94 f2 5f 	call	0xbfe4	; 0xbfe4 <vfprintf>
    bfde:	df 91       	pop	r29
    bfe0:	cf 91       	pop	r28
    bfe2:	08 95       	ret

0000bfe4 <vfprintf>:
    bfe4:	2f 92       	push	r2
    bfe6:	3f 92       	push	r3
    bfe8:	4f 92       	push	r4
    bfea:	5f 92       	push	r5
    bfec:	6f 92       	push	r6
    bfee:	7f 92       	push	r7
    bff0:	8f 92       	push	r8
    bff2:	9f 92       	push	r9
    bff4:	af 92       	push	r10
    bff6:	bf 92       	push	r11
    bff8:	cf 92       	push	r12
    bffa:	df 92       	push	r13
    bffc:	ef 92       	push	r14
    bffe:	ff 92       	push	r15
    c000:	0f 93       	push	r16
    c002:	1f 93       	push	r17
    c004:	cf 93       	push	r28
    c006:	df 93       	push	r29
    c008:	cd b7       	in	r28, 0x3d	; 61
    c00a:	de b7       	in	r29, 0x3e	; 62
    c00c:	2d 97       	sbiw	r28, 0x0d	; 13
    c00e:	cd bf       	out	0x3d, r28	; 61
    c010:	de bf       	out	0x3e, r29	; 62
    c012:	3c 01       	movw	r6, r24
    c014:	6c 87       	std	Y+12, r22	; 0x0c
    c016:	7d 87       	std	Y+13, r23	; 0x0d
    c018:	5a 01       	movw	r10, r20
    c01a:	fc 01       	movw	r30, r24
    c01c:	16 82       	std	Z+6, r1	; 0x06
    c01e:	17 82       	std	Z+7, r1	; 0x07
    c020:	83 81       	ldd	r24, Z+3	; 0x03
    c022:	81 ff       	sbrs	r24, 1
    c024:	c8 c1       	rjmp	.+912    	; 0xc3b6 <vfprintf+0x3d2>
    c026:	2e 01       	movw	r4, r28
    c028:	08 94       	sec
    c02a:	41 1c       	adc	r4, r1
    c02c:	51 1c       	adc	r5, r1
    c02e:	f3 01       	movw	r30, r6
    c030:	93 81       	ldd	r25, Z+3	; 0x03
    c032:	ec 85       	ldd	r30, Y+12	; 0x0c
    c034:	fd 85       	ldd	r31, Y+13	; 0x0d
    c036:	93 fd       	sbrc	r25, 3
    c038:	85 91       	lpm	r24, Z+
    c03a:	93 ff       	sbrs	r25, 3
    c03c:	81 91       	ld	r24, Z+
    c03e:	ec 87       	std	Y+12, r30	; 0x0c
    c040:	fd 87       	std	Y+13, r31	; 0x0d
    c042:	88 23       	and	r24, r24
    c044:	09 f4       	brne	.+2      	; 0xc048 <vfprintf+0x64>
    c046:	b3 c1       	rjmp	.+870    	; 0xc3ae <vfprintf+0x3ca>
    c048:	85 32       	cpi	r24, 0x25	; 37
    c04a:	41 f4       	brne	.+16     	; 0xc05c <vfprintf+0x78>
    c04c:	93 fd       	sbrc	r25, 3
    c04e:	85 91       	lpm	r24, Z+
    c050:	93 ff       	sbrs	r25, 3
    c052:	81 91       	ld	r24, Z+
    c054:	ec 87       	std	Y+12, r30	; 0x0c
    c056:	fd 87       	std	Y+13, r31	; 0x0d
    c058:	85 32       	cpi	r24, 0x25	; 37
    c05a:	29 f4       	brne	.+10     	; 0xc066 <vfprintf+0x82>
    c05c:	90 e0       	ldi	r25, 0x00	; 0
    c05e:	b3 01       	movw	r22, r6
    c060:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c064:	e4 cf       	rjmp	.-56     	; 0xc02e <vfprintf+0x4a>
    c066:	ff 24       	eor	r15, r15
    c068:	ee 24       	eor	r14, r14
    c06a:	10 e0       	ldi	r17, 0x00	; 0
    c06c:	10 32       	cpi	r17, 0x20	; 32
    c06e:	b0 f4       	brcc	.+44     	; 0xc09c <vfprintf+0xb8>
    c070:	8b 32       	cpi	r24, 0x2B	; 43
    c072:	69 f0       	breq	.+26     	; 0xc08e <vfprintf+0xaa>
    c074:	8c 32       	cpi	r24, 0x2C	; 44
    c076:	28 f4       	brcc	.+10     	; 0xc082 <vfprintf+0x9e>
    c078:	80 32       	cpi	r24, 0x20	; 32
    c07a:	51 f0       	breq	.+20     	; 0xc090 <vfprintf+0xac>
    c07c:	83 32       	cpi	r24, 0x23	; 35
    c07e:	71 f4       	brne	.+28     	; 0xc09c <vfprintf+0xb8>
    c080:	0b c0       	rjmp	.+22     	; 0xc098 <vfprintf+0xb4>
    c082:	8d 32       	cpi	r24, 0x2D	; 45
    c084:	39 f0       	breq	.+14     	; 0xc094 <vfprintf+0xb0>
    c086:	80 33       	cpi	r24, 0x30	; 48
    c088:	49 f4       	brne	.+18     	; 0xc09c <vfprintf+0xb8>
    c08a:	11 60       	ori	r17, 0x01	; 1
    c08c:	2c c0       	rjmp	.+88     	; 0xc0e6 <vfprintf+0x102>
    c08e:	12 60       	ori	r17, 0x02	; 2
    c090:	14 60       	ori	r17, 0x04	; 4
    c092:	29 c0       	rjmp	.+82     	; 0xc0e6 <vfprintf+0x102>
    c094:	18 60       	ori	r17, 0x08	; 8
    c096:	27 c0       	rjmp	.+78     	; 0xc0e6 <vfprintf+0x102>
    c098:	10 61       	ori	r17, 0x10	; 16
    c09a:	25 c0       	rjmp	.+74     	; 0xc0e6 <vfprintf+0x102>
    c09c:	17 fd       	sbrc	r17, 7
    c09e:	2e c0       	rjmp	.+92     	; 0xc0fc <vfprintf+0x118>
    c0a0:	28 2f       	mov	r18, r24
    c0a2:	20 53       	subi	r18, 0x30	; 48
    c0a4:	2a 30       	cpi	r18, 0x0A	; 10
    c0a6:	98 f4       	brcc	.+38     	; 0xc0ce <vfprintf+0xea>
    c0a8:	16 ff       	sbrs	r17, 6
    c0aa:	08 c0       	rjmp	.+16     	; 0xc0bc <vfprintf+0xd8>
    c0ac:	8f 2d       	mov	r24, r15
    c0ae:	88 0f       	add	r24, r24
    c0b0:	f8 2e       	mov	r15, r24
    c0b2:	ff 0c       	add	r15, r15
    c0b4:	ff 0c       	add	r15, r15
    c0b6:	f8 0e       	add	r15, r24
    c0b8:	f2 0e       	add	r15, r18
    c0ba:	15 c0       	rjmp	.+42     	; 0xc0e6 <vfprintf+0x102>
    c0bc:	8e 2d       	mov	r24, r14
    c0be:	88 0f       	add	r24, r24
    c0c0:	e8 2e       	mov	r14, r24
    c0c2:	ee 0c       	add	r14, r14
    c0c4:	ee 0c       	add	r14, r14
    c0c6:	e8 0e       	add	r14, r24
    c0c8:	e2 0e       	add	r14, r18
    c0ca:	10 62       	ori	r17, 0x20	; 32
    c0cc:	0c c0       	rjmp	.+24     	; 0xc0e6 <vfprintf+0x102>
    c0ce:	8e 32       	cpi	r24, 0x2E	; 46
    c0d0:	21 f4       	brne	.+8      	; 0xc0da <vfprintf+0xf6>
    c0d2:	16 fd       	sbrc	r17, 6
    c0d4:	6c c1       	rjmp	.+728    	; 0xc3ae <vfprintf+0x3ca>
    c0d6:	10 64       	ori	r17, 0x40	; 64
    c0d8:	06 c0       	rjmp	.+12     	; 0xc0e6 <vfprintf+0x102>
    c0da:	8c 36       	cpi	r24, 0x6C	; 108
    c0dc:	11 f4       	brne	.+4      	; 0xc0e2 <vfprintf+0xfe>
    c0de:	10 68       	ori	r17, 0x80	; 128
    c0e0:	02 c0       	rjmp	.+4      	; 0xc0e6 <vfprintf+0x102>
    c0e2:	88 36       	cpi	r24, 0x68	; 104
    c0e4:	59 f4       	brne	.+22     	; 0xc0fc <vfprintf+0x118>
    c0e6:	ec 85       	ldd	r30, Y+12	; 0x0c
    c0e8:	fd 85       	ldd	r31, Y+13	; 0x0d
    c0ea:	93 fd       	sbrc	r25, 3
    c0ec:	85 91       	lpm	r24, Z+
    c0ee:	93 ff       	sbrs	r25, 3
    c0f0:	81 91       	ld	r24, Z+
    c0f2:	ec 87       	std	Y+12, r30	; 0x0c
    c0f4:	fd 87       	std	Y+13, r31	; 0x0d
    c0f6:	88 23       	and	r24, r24
    c0f8:	09 f0       	breq	.+2      	; 0xc0fc <vfprintf+0x118>
    c0fa:	b8 cf       	rjmp	.-144    	; 0xc06c <vfprintf+0x88>
    c0fc:	98 2f       	mov	r25, r24
    c0fe:	95 54       	subi	r25, 0x45	; 69
    c100:	93 30       	cpi	r25, 0x03	; 3
    c102:	18 f0       	brcs	.+6      	; 0xc10a <vfprintf+0x126>
    c104:	90 52       	subi	r25, 0x20	; 32
    c106:	93 30       	cpi	r25, 0x03	; 3
    c108:	38 f4       	brcc	.+14     	; 0xc118 <vfprintf+0x134>
    c10a:	24 e0       	ldi	r18, 0x04	; 4
    c10c:	30 e0       	ldi	r19, 0x00	; 0
    c10e:	a2 0e       	add	r10, r18
    c110:	b3 1e       	adc	r11, r19
    c112:	3f e3       	ldi	r19, 0x3F	; 63
    c114:	39 83       	std	Y+1, r19	; 0x01
    c116:	0f c0       	rjmp	.+30     	; 0xc136 <vfprintf+0x152>
    c118:	83 36       	cpi	r24, 0x63	; 99
    c11a:	31 f0       	breq	.+12     	; 0xc128 <vfprintf+0x144>
    c11c:	83 37       	cpi	r24, 0x73	; 115
    c11e:	81 f0       	breq	.+32     	; 0xc140 <vfprintf+0x15c>
    c120:	83 35       	cpi	r24, 0x53	; 83
    c122:	09 f0       	breq	.+2      	; 0xc126 <vfprintf+0x142>
    c124:	5a c0       	rjmp	.+180    	; 0xc1da <vfprintf+0x1f6>
    c126:	22 c0       	rjmp	.+68     	; 0xc16c <vfprintf+0x188>
    c128:	f5 01       	movw	r30, r10
    c12a:	80 81       	ld	r24, Z
    c12c:	89 83       	std	Y+1, r24	; 0x01
    c12e:	22 e0       	ldi	r18, 0x02	; 2
    c130:	30 e0       	ldi	r19, 0x00	; 0
    c132:	a2 0e       	add	r10, r18
    c134:	b3 1e       	adc	r11, r19
    c136:	21 e0       	ldi	r18, 0x01	; 1
    c138:	c2 2e       	mov	r12, r18
    c13a:	d1 2c       	mov	r13, r1
    c13c:	42 01       	movw	r8, r4
    c13e:	14 c0       	rjmp	.+40     	; 0xc168 <vfprintf+0x184>
    c140:	92 e0       	ldi	r25, 0x02	; 2
    c142:	29 2e       	mov	r2, r25
    c144:	31 2c       	mov	r3, r1
    c146:	2a 0c       	add	r2, r10
    c148:	3b 1c       	adc	r3, r11
    c14a:	f5 01       	movw	r30, r10
    c14c:	80 80       	ld	r8, Z
    c14e:	91 80       	ldd	r9, Z+1	; 0x01
    c150:	16 ff       	sbrs	r17, 6
    c152:	03 c0       	rjmp	.+6      	; 0xc15a <vfprintf+0x176>
    c154:	6f 2d       	mov	r22, r15
    c156:	70 e0       	ldi	r23, 0x00	; 0
    c158:	02 c0       	rjmp	.+4      	; 0xc15e <vfprintf+0x17a>
    c15a:	6f ef       	ldi	r22, 0xFF	; 255
    c15c:	7f ef       	ldi	r23, 0xFF	; 255
    c15e:	c4 01       	movw	r24, r8
    c160:	0e 94 fe 61 	call	0xc3fc	; 0xc3fc <strnlen>
    c164:	6c 01       	movw	r12, r24
    c166:	51 01       	movw	r10, r2
    c168:	1f 77       	andi	r17, 0x7F	; 127
    c16a:	15 c0       	rjmp	.+42     	; 0xc196 <vfprintf+0x1b2>
    c16c:	82 e0       	ldi	r24, 0x02	; 2
    c16e:	28 2e       	mov	r2, r24
    c170:	31 2c       	mov	r3, r1
    c172:	2a 0c       	add	r2, r10
    c174:	3b 1c       	adc	r3, r11
    c176:	f5 01       	movw	r30, r10
    c178:	80 80       	ld	r8, Z
    c17a:	91 80       	ldd	r9, Z+1	; 0x01
    c17c:	16 ff       	sbrs	r17, 6
    c17e:	03 c0       	rjmp	.+6      	; 0xc186 <vfprintf+0x1a2>
    c180:	6f 2d       	mov	r22, r15
    c182:	70 e0       	ldi	r23, 0x00	; 0
    c184:	02 c0       	rjmp	.+4      	; 0xc18a <vfprintf+0x1a6>
    c186:	6f ef       	ldi	r22, 0xFF	; 255
    c188:	7f ef       	ldi	r23, 0xFF	; 255
    c18a:	c4 01       	movw	r24, r8
    c18c:	0e 94 f3 61 	call	0xc3e6	; 0xc3e6 <strnlen_P>
    c190:	6c 01       	movw	r12, r24
    c192:	10 68       	ori	r17, 0x80	; 128
    c194:	51 01       	movw	r10, r2
    c196:	13 fd       	sbrc	r17, 3
    c198:	1c c0       	rjmp	.+56     	; 0xc1d2 <vfprintf+0x1ee>
    c19a:	06 c0       	rjmp	.+12     	; 0xc1a8 <vfprintf+0x1c4>
    c19c:	80 e2       	ldi	r24, 0x20	; 32
    c19e:	90 e0       	ldi	r25, 0x00	; 0
    c1a0:	b3 01       	movw	r22, r6
    c1a2:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c1a6:	ea 94       	dec	r14
    c1a8:	8e 2d       	mov	r24, r14
    c1aa:	90 e0       	ldi	r25, 0x00	; 0
    c1ac:	c8 16       	cp	r12, r24
    c1ae:	d9 06       	cpc	r13, r25
    c1b0:	a8 f3       	brcs	.-22     	; 0xc19c <vfprintf+0x1b8>
    c1b2:	0f c0       	rjmp	.+30     	; 0xc1d2 <vfprintf+0x1ee>
    c1b4:	f4 01       	movw	r30, r8
    c1b6:	17 fd       	sbrc	r17, 7
    c1b8:	85 91       	lpm	r24, Z+
    c1ba:	17 ff       	sbrs	r17, 7
    c1bc:	81 91       	ld	r24, Z+
    c1be:	4f 01       	movw	r8, r30
    c1c0:	90 e0       	ldi	r25, 0x00	; 0
    c1c2:	b3 01       	movw	r22, r6
    c1c4:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c1c8:	e1 10       	cpse	r14, r1
    c1ca:	ea 94       	dec	r14
    c1cc:	08 94       	sec
    c1ce:	c1 08       	sbc	r12, r1
    c1d0:	d1 08       	sbc	r13, r1
    c1d2:	c1 14       	cp	r12, r1
    c1d4:	d1 04       	cpc	r13, r1
    c1d6:	71 f7       	brne	.-36     	; 0xc1b4 <vfprintf+0x1d0>
    c1d8:	e7 c0       	rjmp	.+462    	; 0xc3a8 <vfprintf+0x3c4>
    c1da:	84 36       	cpi	r24, 0x64	; 100
    c1dc:	11 f0       	breq	.+4      	; 0xc1e2 <vfprintf+0x1fe>
    c1de:	89 36       	cpi	r24, 0x69	; 105
    c1e0:	51 f5       	brne	.+84     	; 0xc236 <vfprintf+0x252>
    c1e2:	f5 01       	movw	r30, r10
    c1e4:	17 ff       	sbrs	r17, 7
    c1e6:	07 c0       	rjmp	.+14     	; 0xc1f6 <vfprintf+0x212>
    c1e8:	80 81       	ld	r24, Z
    c1ea:	91 81       	ldd	r25, Z+1	; 0x01
    c1ec:	a2 81       	ldd	r26, Z+2	; 0x02
    c1ee:	b3 81       	ldd	r27, Z+3	; 0x03
    c1f0:	24 e0       	ldi	r18, 0x04	; 4
    c1f2:	30 e0       	ldi	r19, 0x00	; 0
    c1f4:	08 c0       	rjmp	.+16     	; 0xc206 <vfprintf+0x222>
    c1f6:	80 81       	ld	r24, Z
    c1f8:	91 81       	ldd	r25, Z+1	; 0x01
    c1fa:	aa 27       	eor	r26, r26
    c1fc:	97 fd       	sbrc	r25, 7
    c1fe:	a0 95       	com	r26
    c200:	ba 2f       	mov	r27, r26
    c202:	22 e0       	ldi	r18, 0x02	; 2
    c204:	30 e0       	ldi	r19, 0x00	; 0
    c206:	a2 0e       	add	r10, r18
    c208:	b3 1e       	adc	r11, r19
    c20a:	01 2f       	mov	r16, r17
    c20c:	0f 76       	andi	r16, 0x6F	; 111
    c20e:	b7 ff       	sbrs	r27, 7
    c210:	08 c0       	rjmp	.+16     	; 0xc222 <vfprintf+0x23e>
    c212:	b0 95       	com	r27
    c214:	a0 95       	com	r26
    c216:	90 95       	com	r25
    c218:	81 95       	neg	r24
    c21a:	9f 4f       	sbci	r25, 0xFF	; 255
    c21c:	af 4f       	sbci	r26, 0xFF	; 255
    c21e:	bf 4f       	sbci	r27, 0xFF	; 255
    c220:	00 68       	ori	r16, 0x80	; 128
    c222:	bc 01       	movw	r22, r24
    c224:	cd 01       	movw	r24, r26
    c226:	a2 01       	movw	r20, r4
    c228:	2a e0       	ldi	r18, 0x0A	; 10
    c22a:	30 e0       	ldi	r19, 0x00	; 0
    c22c:	0e 94 45 62 	call	0xc48a	; 0xc48a <__ultoa_invert>
    c230:	d8 2e       	mov	r13, r24
    c232:	d4 18       	sub	r13, r4
    c234:	3f c0       	rjmp	.+126    	; 0xc2b4 <vfprintf+0x2d0>
    c236:	85 37       	cpi	r24, 0x75	; 117
    c238:	21 f4       	brne	.+8      	; 0xc242 <vfprintf+0x25e>
    c23a:	1f 7e       	andi	r17, 0xEF	; 239
    c23c:	2a e0       	ldi	r18, 0x0A	; 10
    c23e:	30 e0       	ldi	r19, 0x00	; 0
    c240:	20 c0       	rjmp	.+64     	; 0xc282 <vfprintf+0x29e>
    c242:	19 7f       	andi	r17, 0xF9	; 249
    c244:	8f 36       	cpi	r24, 0x6F	; 111
    c246:	a9 f0       	breq	.+42     	; 0xc272 <vfprintf+0x28e>
    c248:	80 37       	cpi	r24, 0x70	; 112
    c24a:	20 f4       	brcc	.+8      	; 0xc254 <vfprintf+0x270>
    c24c:	88 35       	cpi	r24, 0x58	; 88
    c24e:	09 f0       	breq	.+2      	; 0xc252 <vfprintf+0x26e>
    c250:	ae c0       	rjmp	.+348    	; 0xc3ae <vfprintf+0x3ca>
    c252:	0b c0       	rjmp	.+22     	; 0xc26a <vfprintf+0x286>
    c254:	80 37       	cpi	r24, 0x70	; 112
    c256:	21 f0       	breq	.+8      	; 0xc260 <vfprintf+0x27c>
    c258:	88 37       	cpi	r24, 0x78	; 120
    c25a:	09 f0       	breq	.+2      	; 0xc25e <vfprintf+0x27a>
    c25c:	a8 c0       	rjmp	.+336    	; 0xc3ae <vfprintf+0x3ca>
    c25e:	01 c0       	rjmp	.+2      	; 0xc262 <vfprintf+0x27e>
    c260:	10 61       	ori	r17, 0x10	; 16
    c262:	14 ff       	sbrs	r17, 4
    c264:	09 c0       	rjmp	.+18     	; 0xc278 <vfprintf+0x294>
    c266:	14 60       	ori	r17, 0x04	; 4
    c268:	07 c0       	rjmp	.+14     	; 0xc278 <vfprintf+0x294>
    c26a:	14 ff       	sbrs	r17, 4
    c26c:	08 c0       	rjmp	.+16     	; 0xc27e <vfprintf+0x29a>
    c26e:	16 60       	ori	r17, 0x06	; 6
    c270:	06 c0       	rjmp	.+12     	; 0xc27e <vfprintf+0x29a>
    c272:	28 e0       	ldi	r18, 0x08	; 8
    c274:	30 e0       	ldi	r19, 0x00	; 0
    c276:	05 c0       	rjmp	.+10     	; 0xc282 <vfprintf+0x29e>
    c278:	20 e1       	ldi	r18, 0x10	; 16
    c27a:	30 e0       	ldi	r19, 0x00	; 0
    c27c:	02 c0       	rjmp	.+4      	; 0xc282 <vfprintf+0x29e>
    c27e:	20 e1       	ldi	r18, 0x10	; 16
    c280:	32 e0       	ldi	r19, 0x02	; 2
    c282:	f5 01       	movw	r30, r10
    c284:	17 ff       	sbrs	r17, 7
    c286:	07 c0       	rjmp	.+14     	; 0xc296 <vfprintf+0x2b2>
    c288:	60 81       	ld	r22, Z
    c28a:	71 81       	ldd	r23, Z+1	; 0x01
    c28c:	82 81       	ldd	r24, Z+2	; 0x02
    c28e:	93 81       	ldd	r25, Z+3	; 0x03
    c290:	44 e0       	ldi	r20, 0x04	; 4
    c292:	50 e0       	ldi	r21, 0x00	; 0
    c294:	06 c0       	rjmp	.+12     	; 0xc2a2 <vfprintf+0x2be>
    c296:	60 81       	ld	r22, Z
    c298:	71 81       	ldd	r23, Z+1	; 0x01
    c29a:	80 e0       	ldi	r24, 0x00	; 0
    c29c:	90 e0       	ldi	r25, 0x00	; 0
    c29e:	42 e0       	ldi	r20, 0x02	; 2
    c2a0:	50 e0       	ldi	r21, 0x00	; 0
    c2a2:	a4 0e       	add	r10, r20
    c2a4:	b5 1e       	adc	r11, r21
    c2a6:	a2 01       	movw	r20, r4
    c2a8:	0e 94 45 62 	call	0xc48a	; 0xc48a <__ultoa_invert>
    c2ac:	d8 2e       	mov	r13, r24
    c2ae:	d4 18       	sub	r13, r4
    c2b0:	01 2f       	mov	r16, r17
    c2b2:	0f 77       	andi	r16, 0x7F	; 127
    c2b4:	06 ff       	sbrs	r16, 6
    c2b6:	09 c0       	rjmp	.+18     	; 0xc2ca <vfprintf+0x2e6>
    c2b8:	0e 7f       	andi	r16, 0xFE	; 254
    c2ba:	df 14       	cp	r13, r15
    c2bc:	30 f4       	brcc	.+12     	; 0xc2ca <vfprintf+0x2e6>
    c2be:	04 ff       	sbrs	r16, 4
    c2c0:	06 c0       	rjmp	.+12     	; 0xc2ce <vfprintf+0x2ea>
    c2c2:	02 fd       	sbrc	r16, 2
    c2c4:	04 c0       	rjmp	.+8      	; 0xc2ce <vfprintf+0x2ea>
    c2c6:	0f 7e       	andi	r16, 0xEF	; 239
    c2c8:	02 c0       	rjmp	.+4      	; 0xc2ce <vfprintf+0x2ea>
    c2ca:	1d 2d       	mov	r17, r13
    c2cc:	01 c0       	rjmp	.+2      	; 0xc2d0 <vfprintf+0x2ec>
    c2ce:	1f 2d       	mov	r17, r15
    c2d0:	80 2f       	mov	r24, r16
    c2d2:	90 e0       	ldi	r25, 0x00	; 0
    c2d4:	04 ff       	sbrs	r16, 4
    c2d6:	0c c0       	rjmp	.+24     	; 0xc2f0 <vfprintf+0x30c>
    c2d8:	fe 01       	movw	r30, r28
    c2da:	ed 0d       	add	r30, r13
    c2dc:	f1 1d       	adc	r31, r1
    c2de:	20 81       	ld	r18, Z
    c2e0:	20 33       	cpi	r18, 0x30	; 48
    c2e2:	11 f4       	brne	.+4      	; 0xc2e8 <vfprintf+0x304>
    c2e4:	09 7e       	andi	r16, 0xE9	; 233
    c2e6:	09 c0       	rjmp	.+18     	; 0xc2fa <vfprintf+0x316>
    c2e8:	02 ff       	sbrs	r16, 2
    c2ea:	06 c0       	rjmp	.+12     	; 0xc2f8 <vfprintf+0x314>
    c2ec:	1e 5f       	subi	r17, 0xFE	; 254
    c2ee:	05 c0       	rjmp	.+10     	; 0xc2fa <vfprintf+0x316>
    c2f0:	86 78       	andi	r24, 0x86	; 134
    c2f2:	90 70       	andi	r25, 0x00	; 0
    c2f4:	00 97       	sbiw	r24, 0x00	; 0
    c2f6:	09 f0       	breq	.+2      	; 0xc2fa <vfprintf+0x316>
    c2f8:	1f 5f       	subi	r17, 0xFF	; 255
    c2fa:	80 2e       	mov	r8, r16
    c2fc:	99 24       	eor	r9, r9
    c2fe:	03 fd       	sbrc	r16, 3
    c300:	12 c0       	rjmp	.+36     	; 0xc326 <vfprintf+0x342>
    c302:	00 ff       	sbrs	r16, 0
    c304:	0d c0       	rjmp	.+26     	; 0xc320 <vfprintf+0x33c>
    c306:	fd 2c       	mov	r15, r13
    c308:	1e 15       	cp	r17, r14
    c30a:	50 f4       	brcc	.+20     	; 0xc320 <vfprintf+0x33c>
    c30c:	fe 0c       	add	r15, r14
    c30e:	f1 1a       	sub	r15, r17
    c310:	1e 2d       	mov	r17, r14
    c312:	06 c0       	rjmp	.+12     	; 0xc320 <vfprintf+0x33c>
    c314:	80 e2       	ldi	r24, 0x20	; 32
    c316:	90 e0       	ldi	r25, 0x00	; 0
    c318:	b3 01       	movw	r22, r6
    c31a:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c31e:	1f 5f       	subi	r17, 0xFF	; 255
    c320:	1e 15       	cp	r17, r14
    c322:	c0 f3       	brcs	.-16     	; 0xc314 <vfprintf+0x330>
    c324:	04 c0       	rjmp	.+8      	; 0xc32e <vfprintf+0x34a>
    c326:	1e 15       	cp	r17, r14
    c328:	10 f4       	brcc	.+4      	; 0xc32e <vfprintf+0x34a>
    c32a:	e1 1a       	sub	r14, r17
    c32c:	01 c0       	rjmp	.+2      	; 0xc330 <vfprintf+0x34c>
    c32e:	ee 24       	eor	r14, r14
    c330:	84 fe       	sbrs	r8, 4
    c332:	0f c0       	rjmp	.+30     	; 0xc352 <vfprintf+0x36e>
    c334:	80 e3       	ldi	r24, 0x30	; 48
    c336:	90 e0       	ldi	r25, 0x00	; 0
    c338:	b3 01       	movw	r22, r6
    c33a:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c33e:	82 fe       	sbrs	r8, 2
    c340:	1f c0       	rjmp	.+62     	; 0xc380 <vfprintf+0x39c>
    c342:	81 fe       	sbrs	r8, 1
    c344:	03 c0       	rjmp	.+6      	; 0xc34c <vfprintf+0x368>
    c346:	88 e5       	ldi	r24, 0x58	; 88
    c348:	90 e0       	ldi	r25, 0x00	; 0
    c34a:	10 c0       	rjmp	.+32     	; 0xc36c <vfprintf+0x388>
    c34c:	88 e7       	ldi	r24, 0x78	; 120
    c34e:	90 e0       	ldi	r25, 0x00	; 0
    c350:	0d c0       	rjmp	.+26     	; 0xc36c <vfprintf+0x388>
    c352:	c4 01       	movw	r24, r8
    c354:	86 78       	andi	r24, 0x86	; 134
    c356:	90 70       	andi	r25, 0x00	; 0
    c358:	00 97       	sbiw	r24, 0x00	; 0
    c35a:	91 f0       	breq	.+36     	; 0xc380 <vfprintf+0x39c>
    c35c:	81 fc       	sbrc	r8, 1
    c35e:	02 c0       	rjmp	.+4      	; 0xc364 <vfprintf+0x380>
    c360:	80 e2       	ldi	r24, 0x20	; 32
    c362:	01 c0       	rjmp	.+2      	; 0xc366 <vfprintf+0x382>
    c364:	8b e2       	ldi	r24, 0x2B	; 43
    c366:	07 fd       	sbrc	r16, 7
    c368:	8d e2       	ldi	r24, 0x2D	; 45
    c36a:	90 e0       	ldi	r25, 0x00	; 0
    c36c:	b3 01       	movw	r22, r6
    c36e:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c372:	06 c0       	rjmp	.+12     	; 0xc380 <vfprintf+0x39c>
    c374:	80 e3       	ldi	r24, 0x30	; 48
    c376:	90 e0       	ldi	r25, 0x00	; 0
    c378:	b3 01       	movw	r22, r6
    c37a:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c37e:	fa 94       	dec	r15
    c380:	df 14       	cp	r13, r15
    c382:	c0 f3       	brcs	.-16     	; 0xc374 <vfprintf+0x390>
    c384:	da 94       	dec	r13
    c386:	f2 01       	movw	r30, r4
    c388:	ed 0d       	add	r30, r13
    c38a:	f1 1d       	adc	r31, r1
    c38c:	80 81       	ld	r24, Z
    c38e:	90 e0       	ldi	r25, 0x00	; 0
    c390:	b3 01       	movw	r22, r6
    c392:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c396:	dd 20       	and	r13, r13
    c398:	a9 f7       	brne	.-22     	; 0xc384 <vfprintf+0x3a0>
    c39a:	06 c0       	rjmp	.+12     	; 0xc3a8 <vfprintf+0x3c4>
    c39c:	80 e2       	ldi	r24, 0x20	; 32
    c39e:	90 e0       	ldi	r25, 0x00	; 0
    c3a0:	b3 01       	movw	r22, r6
    c3a2:	0e 94 19 62 	call	0xc432	; 0xc432 <fputc>
    c3a6:	ea 94       	dec	r14
    c3a8:	ee 20       	and	r14, r14
    c3aa:	c1 f7       	brne	.-16     	; 0xc39c <vfprintf+0x3b8>
    c3ac:	40 ce       	rjmp	.-896    	; 0xc02e <vfprintf+0x4a>
    c3ae:	f3 01       	movw	r30, r6
    c3b0:	86 81       	ldd	r24, Z+6	; 0x06
    c3b2:	97 81       	ldd	r25, Z+7	; 0x07
    c3b4:	02 c0       	rjmp	.+4      	; 0xc3ba <vfprintf+0x3d6>
    c3b6:	8f ef       	ldi	r24, 0xFF	; 255
    c3b8:	9f ef       	ldi	r25, 0xFF	; 255
    c3ba:	2d 96       	adiw	r28, 0x0d	; 13
    c3bc:	cd bf       	out	0x3d, r28	; 61
    c3be:	de bf       	out	0x3e, r29	; 62
    c3c0:	df 91       	pop	r29
    c3c2:	cf 91       	pop	r28
    c3c4:	1f 91       	pop	r17
    c3c6:	0f 91       	pop	r16
    c3c8:	ff 90       	pop	r15
    c3ca:	ef 90       	pop	r14
    c3cc:	df 90       	pop	r13
    c3ce:	cf 90       	pop	r12
    c3d0:	bf 90       	pop	r11
    c3d2:	af 90       	pop	r10
    c3d4:	9f 90       	pop	r9
    c3d6:	8f 90       	pop	r8
    c3d8:	7f 90       	pop	r7
    c3da:	6f 90       	pop	r6
    c3dc:	5f 90       	pop	r5
    c3de:	4f 90       	pop	r4
    c3e0:	3f 90       	pop	r3
    c3e2:	2f 90       	pop	r2
    c3e4:	08 95       	ret

0000c3e6 <strnlen_P>:
    c3e6:	fc 01       	movw	r30, r24
    c3e8:	05 90       	lpm	r0, Z+
    c3ea:	61 50       	subi	r22, 0x01	; 1
    c3ec:	70 40       	sbci	r23, 0x00	; 0
    c3ee:	01 10       	cpse	r0, r1
    c3f0:	d8 f7       	brcc	.-10     	; 0xc3e8 <strnlen_P+0x2>
    c3f2:	80 95       	com	r24
    c3f4:	90 95       	com	r25
    c3f6:	8e 0f       	add	r24, r30
    c3f8:	9f 1f       	adc	r25, r31
    c3fa:	08 95       	ret

0000c3fc <strnlen>:
    c3fc:	fc 01       	movw	r30, r24
    c3fe:	61 50       	subi	r22, 0x01	; 1
    c400:	70 40       	sbci	r23, 0x00	; 0
    c402:	01 90       	ld	r0, Z+
    c404:	01 10       	cpse	r0, r1
    c406:	d8 f7       	brcc	.-10     	; 0xc3fe <strnlen+0x2>
    c408:	80 95       	com	r24
    c40a:	90 95       	com	r25
    c40c:	8e 0f       	add	r24, r30
    c40e:	9f 1f       	adc	r25, r31
    c410:	08 95       	ret

0000c412 <strrev>:
    c412:	dc 01       	movw	r26, r24
    c414:	fc 01       	movw	r30, r24
    c416:	67 2f       	mov	r22, r23
    c418:	71 91       	ld	r23, Z+
    c41a:	77 23       	and	r23, r23
    c41c:	e1 f7       	brne	.-8      	; 0xc416 <strrev+0x4>
    c41e:	32 97       	sbiw	r30, 0x02	; 2
    c420:	04 c0       	rjmp	.+8      	; 0xc42a <strrev+0x18>
    c422:	7c 91       	ld	r23, X
    c424:	6d 93       	st	X+, r22
    c426:	70 83       	st	Z, r23
    c428:	62 91       	ld	r22, -Z
    c42a:	ae 17       	cp	r26, r30
    c42c:	bf 07       	cpc	r27, r31
    c42e:	c8 f3       	brcs	.-14     	; 0xc422 <strrev+0x10>
    c430:	08 95       	ret

0000c432 <fputc>:
    c432:	0f 93       	push	r16
    c434:	1f 93       	push	r17
    c436:	cf 93       	push	r28
    c438:	df 93       	push	r29
    c43a:	8c 01       	movw	r16, r24
    c43c:	eb 01       	movw	r28, r22
    c43e:	8b 81       	ldd	r24, Y+3	; 0x03
    c440:	81 ff       	sbrs	r24, 1
    c442:	1b c0       	rjmp	.+54     	; 0xc47a <fputc+0x48>
    c444:	82 ff       	sbrs	r24, 2
    c446:	0d c0       	rjmp	.+26     	; 0xc462 <fputc+0x30>
    c448:	2e 81       	ldd	r18, Y+6	; 0x06
    c44a:	3f 81       	ldd	r19, Y+7	; 0x07
    c44c:	8c 81       	ldd	r24, Y+4	; 0x04
    c44e:	9d 81       	ldd	r25, Y+5	; 0x05
    c450:	28 17       	cp	r18, r24
    c452:	39 07       	cpc	r19, r25
    c454:	64 f4       	brge	.+24     	; 0xc46e <fputc+0x3c>
    c456:	e8 81       	ld	r30, Y
    c458:	f9 81       	ldd	r31, Y+1	; 0x01
    c45a:	01 93       	st	Z+, r16
    c45c:	e8 83       	st	Y, r30
    c45e:	f9 83       	std	Y+1, r31	; 0x01
    c460:	06 c0       	rjmp	.+12     	; 0xc46e <fputc+0x3c>
    c462:	e8 85       	ldd	r30, Y+8	; 0x08
    c464:	f9 85       	ldd	r31, Y+9	; 0x09
    c466:	80 2f       	mov	r24, r16
    c468:	19 95       	eicall
    c46a:	00 97       	sbiw	r24, 0x00	; 0
    c46c:	31 f4       	brne	.+12     	; 0xc47a <fputc+0x48>
    c46e:	8e 81       	ldd	r24, Y+6	; 0x06
    c470:	9f 81       	ldd	r25, Y+7	; 0x07
    c472:	01 96       	adiw	r24, 0x01	; 1
    c474:	8e 83       	std	Y+6, r24	; 0x06
    c476:	9f 83       	std	Y+7, r25	; 0x07
    c478:	02 c0       	rjmp	.+4      	; 0xc47e <fputc+0x4c>
    c47a:	0f ef       	ldi	r16, 0xFF	; 255
    c47c:	1f ef       	ldi	r17, 0xFF	; 255
    c47e:	c8 01       	movw	r24, r16
    c480:	df 91       	pop	r29
    c482:	cf 91       	pop	r28
    c484:	1f 91       	pop	r17
    c486:	0f 91       	pop	r16
    c488:	08 95       	ret

0000c48a <__ultoa_invert>:
    c48a:	fa 01       	movw	r30, r20
    c48c:	aa 27       	eor	r26, r26
    c48e:	28 30       	cpi	r18, 0x08	; 8
    c490:	51 f1       	breq	.+84     	; 0xc4e6 <__ultoa_invert+0x5c>
    c492:	20 31       	cpi	r18, 0x10	; 16
    c494:	81 f1       	breq	.+96     	; 0xc4f6 <__ultoa_invert+0x6c>
    c496:	e8 94       	clt
    c498:	6f 93       	push	r22
    c49a:	6e 7f       	andi	r22, 0xFE	; 254
    c49c:	6e 5f       	subi	r22, 0xFE	; 254
    c49e:	7f 4f       	sbci	r23, 0xFF	; 255
    c4a0:	8f 4f       	sbci	r24, 0xFF	; 255
    c4a2:	9f 4f       	sbci	r25, 0xFF	; 255
    c4a4:	af 4f       	sbci	r26, 0xFF	; 255
    c4a6:	b1 e0       	ldi	r27, 0x01	; 1
    c4a8:	3e d0       	rcall	.+124    	; 0xc526 <__ultoa_invert+0x9c>
    c4aa:	b4 e0       	ldi	r27, 0x04	; 4
    c4ac:	3c d0       	rcall	.+120    	; 0xc526 <__ultoa_invert+0x9c>
    c4ae:	67 0f       	add	r22, r23
    c4b0:	78 1f       	adc	r23, r24
    c4b2:	89 1f       	adc	r24, r25
    c4b4:	9a 1f       	adc	r25, r26
    c4b6:	a1 1d       	adc	r26, r1
    c4b8:	68 0f       	add	r22, r24
    c4ba:	79 1f       	adc	r23, r25
    c4bc:	8a 1f       	adc	r24, r26
    c4be:	91 1d       	adc	r25, r1
    c4c0:	a1 1d       	adc	r26, r1
    c4c2:	6a 0f       	add	r22, r26
    c4c4:	71 1d       	adc	r23, r1
    c4c6:	81 1d       	adc	r24, r1
    c4c8:	91 1d       	adc	r25, r1
    c4ca:	a1 1d       	adc	r26, r1
    c4cc:	20 d0       	rcall	.+64     	; 0xc50e <__ultoa_invert+0x84>
    c4ce:	09 f4       	brne	.+2      	; 0xc4d2 <__ultoa_invert+0x48>
    c4d0:	68 94       	set
    c4d2:	3f 91       	pop	r19
    c4d4:	2a e0       	ldi	r18, 0x0A	; 10
    c4d6:	26 9f       	mul	r18, r22
    c4d8:	11 24       	eor	r1, r1
    c4da:	30 19       	sub	r19, r0
    c4dc:	30 5d       	subi	r19, 0xD0	; 208
    c4de:	31 93       	st	Z+, r19
    c4e0:	de f6       	brtc	.-74     	; 0xc498 <__ultoa_invert+0xe>
    c4e2:	cf 01       	movw	r24, r30
    c4e4:	08 95       	ret
    c4e6:	46 2f       	mov	r20, r22
    c4e8:	47 70       	andi	r20, 0x07	; 7
    c4ea:	40 5d       	subi	r20, 0xD0	; 208
    c4ec:	41 93       	st	Z+, r20
    c4ee:	b3 e0       	ldi	r27, 0x03	; 3
    c4f0:	0f d0       	rcall	.+30     	; 0xc510 <__ultoa_invert+0x86>
    c4f2:	c9 f7       	brne	.-14     	; 0xc4e6 <__ultoa_invert+0x5c>
    c4f4:	f6 cf       	rjmp	.-20     	; 0xc4e2 <__ultoa_invert+0x58>
    c4f6:	46 2f       	mov	r20, r22
    c4f8:	4f 70       	andi	r20, 0x0F	; 15
    c4fa:	40 5d       	subi	r20, 0xD0	; 208
    c4fc:	4a 33       	cpi	r20, 0x3A	; 58
    c4fe:	18 f0       	brcs	.+6      	; 0xc506 <__ultoa_invert+0x7c>
    c500:	49 5d       	subi	r20, 0xD9	; 217
    c502:	31 fd       	sbrc	r19, 1
    c504:	40 52       	subi	r20, 0x20	; 32
    c506:	41 93       	st	Z+, r20
    c508:	02 d0       	rcall	.+4      	; 0xc50e <__ultoa_invert+0x84>
    c50a:	a9 f7       	brne	.-22     	; 0xc4f6 <__ultoa_invert+0x6c>
    c50c:	ea cf       	rjmp	.-44     	; 0xc4e2 <__ultoa_invert+0x58>
    c50e:	b4 e0       	ldi	r27, 0x04	; 4
    c510:	a6 95       	lsr	r26
    c512:	97 95       	ror	r25
    c514:	87 95       	ror	r24
    c516:	77 95       	ror	r23
    c518:	67 95       	ror	r22
    c51a:	ba 95       	dec	r27
    c51c:	c9 f7       	brne	.-14     	; 0xc510 <__ultoa_invert+0x86>
    c51e:	00 97       	sbiw	r24, 0x00	; 0
    c520:	61 05       	cpc	r22, r1
    c522:	71 05       	cpc	r23, r1
    c524:	08 95       	ret
    c526:	9b 01       	movw	r18, r22
    c528:	ac 01       	movw	r20, r24
    c52a:	0a 2e       	mov	r0, r26
    c52c:	06 94       	lsr	r0
    c52e:	57 95       	ror	r21
    c530:	47 95       	ror	r20
    c532:	37 95       	ror	r19
    c534:	27 95       	ror	r18
    c536:	ba 95       	dec	r27
    c538:	c9 f7       	brne	.-14     	; 0xc52c <__ultoa_invert+0xa2>
    c53a:	62 0f       	add	r22, r18
    c53c:	73 1f       	adc	r23, r19
    c53e:	84 1f       	adc	r24, r20
    c540:	95 1f       	adc	r25, r21
    c542:	a0 1d       	adc	r26, r0
    c544:	08 95       	ret

0000c546 <_exit>:
    c546:	f8 94       	cli

0000c548 <__stop_program>:
    c548:	ff cf       	rjmp	.-2      	; 0xc548 <__stop_program>
