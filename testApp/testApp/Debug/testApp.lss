
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c150  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00802000  0000c150  0000c1e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fac  00802138  00802138  0000c31c  2**0
                  ALLOC
  3 .stab         00002f64  00000000  00000000  0000c31c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b51  00000000  00000000  0000f280  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003e0  00000000  00000000  0000fdd8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d1e4  00000000  00000000  000101b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000223c  00000000  00000000  0001d39c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005a62  00000000  00000000  0001f5d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001d18  00000000  00000000  0002503c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004656  00000000  00000000  00026d54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000528b  00000000  00000000  0002b3aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b168  00000000  00000000  00030635  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000100  00000000  00000000  0018b79d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 9c 10 	jmp	0x2138	; 0x2138 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 b0 0f 	jmp	0x1f60	; 0x1f60 <__vector_16>
      44:	0c 94 e0 0f 	jmp	0x1fc0	; 0x1fc0 <__vector_17>
      48:	0c 94 10 10 	jmp	0x2020	; 0x2020 <__vector_18>
      4c:	0c 94 40 10 	jmp	0x2080	; 0x2080 <__vector_19>
      50:	0c 94 b5 0b 	jmp	0x176a	; 0x176a <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 34 3e 	jmp	0x7c68	; 0x7c68 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 fd 2d 	jmp	0x5bfa	; 0x5bfa <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 8c 13 	jmp	0x2718	; 0x2718 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 ca 12 	jmp	0x2594	; 0x2594 <__vector_79>
     140:	0c 94 fa 12 	jmp	0x25f4	; 0x25f4 <__vector_80>
     144:	0c 94 2a 13 	jmp	0x2654	; 0x2654 <__vector_81>
     148:	0c 94 5a 13 	jmp	0x26b4	; 0x26b4 <__vector_82>
     14c:	0c 94 cc 03 	jmp	0x798	; 0x798 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 6b 0c 	jmp	0x18d6	; 0x18d6 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e0 e5       	ldi	r30, 0x50	; 80
     244:	f1 ec       	ldi	r31, 0xC1	; 193
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 33       	cpi	r26, 0x38	; 56
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e3       	ldi	r26, 0x38	; 56
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a4 3e       	cpi	r26, 0xE4	; 228
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 9e 02 	call	0x53c	; 0x53c <main>
     26a:	0c 94 a6 60 	jmp	0xc14c	; 0xc14c <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	ef 92       	push	r14
     274:	ff 92       	push	r15
     276:	0f 93       	push	r16
     278:	1f 93       	push	r17
     27a:	cf 93       	push	r28
     27c:	df 93       	push	r29
     27e:	00 d0       	rcall	.+0      	; 0x280 <StartSerial+0xe>
     280:	00 d0       	rcall	.+0      	; 0x282 <StartSerial+0x10>
     282:	cd b7       	in	r28, 0x3d	; 61
     284:	de b7       	in	r29, 0x3e	; 62
     286:	6b 83       	std	Y+3, r22	; 0x03
     288:	7c 83       	std	Y+4, r23	; 0x04
     28a:	8d 83       	std	Y+5, r24	; 0x05
     28c:	9e 83       	std	Y+6, r25	; 0x06
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     28e:	8b 81       	ldd	r24, Y+3	; 0x03
     290:	9c 81       	ldd	r25, Y+4	; 0x04
     292:	ad 81       	ldd	r26, Y+5	; 0x05
     294:	be 81       	ldd	r27, Y+6	; 0x06
     296:	88 35       	cpi	r24, 0x58	; 88
     298:	22 e0       	ldi	r18, 0x02	; 2
     29a:	92 07       	cpc	r25, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	a2 07       	cpc	r26, r18
     2a0:	20 e0       	ldi	r18, 0x00	; 0
     2a2:	b2 07       	cpc	r27, r18
     2a4:	60 f0       	brcs	.+24     	; 0x2be <StartSerial+0x4c>
     2a6:	8b 81       	ldd	r24, Y+3	; 0x03
     2a8:	9c 81       	ldd	r25, Y+4	; 0x04
     2aa:	ad 81       	ldd	r26, Y+5	; 0x05
     2ac:	be 81       	ldd	r27, Y+6	; 0x06
     2ae:	81 34       	cpi	r24, 0x41	; 65
     2b0:	e2 e4       	ldi	r30, 0x42	; 66
     2b2:	9e 07       	cpc	r25, r30
     2b4:	ef e0       	ldi	r30, 0x0F	; 15
     2b6:	ae 07       	cpc	r26, r30
     2b8:	e0 e0       	ldi	r30, 0x00	; 0
     2ba:	be 07       	cpc	r27, r30
     2bc:	10 f0       	brcs	.+4      	; 0x2c2 <StartSerial+0x50>
		//baud rate too fast or too slow
		return false;
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	af c0       	rjmp	.+350    	; 0x420 <StartSerial+0x1ae>
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2c2:	0e 94 ee 31 	call	0x63dc	; 0x63dc <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2c6:	80 e4       	ldi	r24, 0x40	; 64
     2c8:	96 e0       	ldi	r25, 0x06	; 6
     2ca:	28 e0       	ldi	r18, 0x08	; 8
     2cc:	fc 01       	movw	r30, r24
     2ce:	21 83       	std	Z+1, r18	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2d0:	80 e4       	ldi	r24, 0x40	; 64
     2d2:	96 e0       	ldi	r25, 0x06	; 6
     2d4:	28 e0       	ldi	r18, 0x08	; 8
     2d6:	fc 01       	movw	r30, r24
     2d8:	25 83       	std	Z+5, r18	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2da:	80 e4       	ldi	r24, 0x40	; 64
     2dc:	96 e0       	ldi	r25, 0x06	; 6
     2de:	24 e0       	ldi	r18, 0x04	; 4
     2e0:	fc 01       	movw	r30, r24
     2e2:	22 83       	std	Z+2, r18	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2e4:	8b 81       	ldd	r24, Y+3	; 0x03
     2e6:	9c 81       	ldd	r25, Y+4	; 0x04
     2e8:	ad 81       	ldd	r26, Y+5	; 0x05
     2ea:	be 81       	ldd	r27, Y+6	; 0x06
     2ec:	88 0f       	add	r24, r24
     2ee:	99 1f       	adc	r25, r25
     2f0:	aa 1f       	adc	r26, r26
     2f2:	bb 1f       	adc	r27, r27
     2f4:	88 0f       	add	r24, r24
     2f6:	99 1f       	adc	r25, r25
     2f8:	aa 1f       	adc	r26, r26
     2fa:	bb 1f       	adc	r27, r27
     2fc:	88 0f       	add	r24, r24
     2fe:	99 1f       	adc	r25, r25
     300:	aa 1f       	adc	r26, r26
     302:	bb 1f       	adc	r27, r27
     304:	88 0f       	add	r24, r24
     306:	99 1f       	adc	r25, r25
     308:	aa 1f       	adc	r26, r26
     30a:	bb 1f       	adc	r27, r27
     30c:	bc 01       	movw	r22, r24
     30e:	cd 01       	movw	r24, r26
     310:	0e 94 91 5b 	call	0xb722	; 0xb722 <__floatunsisf>
     314:	9b 01       	movw	r18, r22
     316:	ac 01       	movw	r20, r24
     318:	60 e0       	ldi	r22, 0x00	; 0
     31a:	74 e2       	ldi	r23, 0x24	; 36
     31c:	84 ef       	ldi	r24, 0xF4	; 244
     31e:	9b e4       	ldi	r25, 0x4B	; 75
     320:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
     324:	dc 01       	movw	r26, r24
     326:	cb 01       	movw	r24, r22
     328:	bc 01       	movw	r22, r24
     32a:	cd 01       	movw	r24, r26
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	40 e8       	ldi	r20, 0x80	; 128
     332:	5f e3       	ldi	r21, 0x3F	; 63
     334:	0e 94 94 5a 	call	0xb528	; 0xb528 <__subsf3>
     338:	dc 01       	movw	r26, r24
     33a:	cb 01       	movw	r24, r22
     33c:	bc 01       	movw	r22, r24
     33e:	cd 01       	movw	r24, r26
     340:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
     344:	dc 01       	movw	r26, r24
     346:	cb 01       	movw	r24, r22
     348:	89 83       	std	Y+1, r24	; 0x01
     34a:	9a 83       	std	Y+2, r25	; 0x02
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     34c:	8b 81       	ldd	r24, Y+3	; 0x03
     34e:	9c 81       	ldd	r25, Y+4	; 0x04
     350:	ad 81       	ldd	r26, Y+5	; 0x05
     352:	be 81       	ldd	r27, Y+6	; 0x06
     354:	88 0f       	add	r24, r24
     356:	99 1f       	adc	r25, r25
     358:	aa 1f       	adc	r26, r26
     35a:	bb 1f       	adc	r27, r27
     35c:	88 0f       	add	r24, r24
     35e:	99 1f       	adc	r25, r25
     360:	aa 1f       	adc	r26, r26
     362:	bb 1f       	adc	r27, r27
     364:	88 0f       	add	r24, r24
     366:	99 1f       	adc	r25, r25
     368:	aa 1f       	adc	r26, r26
     36a:	bb 1f       	adc	r27, r27
     36c:	88 0f       	add	r24, r24
     36e:	99 1f       	adc	r25, r25
     370:	aa 1f       	adc	r26, r26
     372:	bb 1f       	adc	r27, r27
     374:	bc 01       	movw	r22, r24
     376:	cd 01       	movw	r24, r26
     378:	0e 94 91 5b 	call	0xb722	; 0xb722 <__floatunsisf>
     37c:	9b 01       	movw	r18, r22
     37e:	ac 01       	movw	r20, r24
     380:	60 e0       	ldi	r22, 0x00	; 0
     382:	74 e2       	ldi	r23, 0x24	; 36
     384:	84 ef       	ldi	r24, 0xF4	; 244
     386:	9b e4       	ldi	r25, 0x4B	; 75
     388:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
     38c:	dc 01       	movw	r26, r24
     38e:	cb 01       	movw	r24, r22
     390:	bc 01       	movw	r22, r24
     392:	cd 01       	movw	r24, r26
     394:	20 e0       	ldi	r18, 0x00	; 0
     396:	30 e0       	ldi	r19, 0x00	; 0
     398:	40 e8       	ldi	r20, 0x80	; 128
     39a:	5f e3       	ldi	r21, 0x3F	; 63
     39c:	0e 94 94 5a 	call	0xb528	; 0xb528 <__subsf3>
     3a0:	dc 01       	movw	r26, r24
     3a2:	cb 01       	movw	r24, r22
     3a4:	7c 01       	movw	r14, r24
     3a6:	8d 01       	movw	r16, r26
     3a8:	89 81       	ldd	r24, Y+1	; 0x01
     3aa:	9a 81       	ldd	r25, Y+2	; 0x02
     3ac:	cc 01       	movw	r24, r24
     3ae:	a0 e0       	ldi	r26, 0x00	; 0
     3b0:	b0 e0       	ldi	r27, 0x00	; 0
     3b2:	bc 01       	movw	r22, r24
     3b4:	cd 01       	movw	r24, r26
     3b6:	0e 94 91 5b 	call	0xb722	; 0xb722 <__floatunsisf>
     3ba:	9b 01       	movw	r18, r22
     3bc:	ac 01       	movw	r20, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	b7 01       	movw	r22, r14
     3c2:	0e 94 94 5a 	call	0xb528	; 0xb528 <__subsf3>
     3c6:	dc 01       	movw	r26, r24
     3c8:	cb 01       	movw	r24, r22
     3ca:	11 e0       	ldi	r17, 0x01	; 1
     3cc:	bc 01       	movw	r22, r24
     3ce:	cd 01       	movw	r24, r26
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	40 e0       	ldi	r20, 0x00	; 0
     3d6:	5f e3       	ldi	r21, 0x3F	; 63
     3d8:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
     3dc:	88 23       	and	r24, r24
     3de:	0c f4       	brge	.+2      	; 0x3e2 <StartSerial+0x170>
     3e0:	10 e0       	ldi	r17, 0x00	; 0
     3e2:	11 23       	and	r17, r17
     3e4:	29 f0       	breq	.+10     	; 0x3f0 <StartSerial+0x17e>
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	9a 81       	ldd	r25, Y+2	; 0x02
     3ea:	01 96       	adiw	r24, 0x01	; 1
     3ec:	89 83       	std	Y+1, r24	; 0x01
     3ee:	9a 83       	std	Y+2, r25	; 0x02
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     3f0:	80 ea       	ldi	r24, 0xA0	; 160
     3f2:	98 e0       	ldi	r25, 0x08	; 8
     3f4:	29 81       	ldd	r18, Y+1	; 0x01
     3f6:	fc 01       	movw	r30, r24
     3f8:	26 83       	std	Z+6, r18	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     3fa:	80 ea       	ldi	r24, 0xA0	; 160
     3fc:	98 e0       	ldi	r25, 0x08	; 8
     3fe:	29 81       	ldd	r18, Y+1	; 0x01
     400:	3a 81       	ldd	r19, Y+2	; 0x02
     402:	23 2f       	mov	r18, r19
     404:	33 27       	eor	r19, r19
     406:	fc 01       	movw	r30, r24
     408:	27 83       	std	Z+7, r18	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     40a:	80 ea       	ldi	r24, 0xA0	; 160
     40c:	98 e0       	ldi	r25, 0x08	; 8
     40e:	23 e0       	ldi	r18, 0x03	; 3
     410:	fc 01       	movw	r30, r24
     412:	25 83       	std	Z+5, r18	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     414:	80 ea       	ldi	r24, 0xA0	; 160
     416:	98 e0       	ldi	r25, 0x08	; 8
     418:	28 e1       	ldi	r18, 0x18	; 24
     41a:	fc 01       	movw	r30, r24
     41c:	24 83       	std	Z+4, r18	; 0x04
	return true;
     41e:	81 e0       	ldi	r24, 0x01	; 1
}
     420:	26 96       	adiw	r28, 0x06	; 6
     422:	cd bf       	out	0x3d, r28	; 61
     424:	de bf       	out	0x3e, r29	; 62
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	0f 91       	pop	r16
     42e:	ff 90       	pop	r15
     430:	ef 90       	pop	r14
     432:	08 95       	ret

00000434 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	0f 92       	push	r0
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
     43e:	89 83       	std	Y+1, r24	; 0x01
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     440:	00 00       	nop
     442:	80 ea       	ldi	r24, 0xA0	; 160
     444:	98 e0       	ldi	r25, 0x08	; 8
     446:	fc 01       	movw	r30, r24
     448:	81 81       	ldd	r24, Z+1	; 0x01
     44a:	88 2f       	mov	r24, r24
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	80 72       	andi	r24, 0x20	; 32
     450:	90 70       	andi	r25, 0x00	; 0
     452:	00 97       	sbiw	r24, 0x00	; 0
     454:	b1 f3       	breq	.-20     	; 0x442 <SerialWriteByte+0xe>
		//wait
	}
	//incremented byte
	USARTC0.DATA = byte;
     456:	80 ea       	ldi	r24, 0xA0	; 160
     458:	98 e0       	ldi	r25, 0x08	; 8
     45a:	29 81       	ldd	r18, Y+1	; 0x01
     45c:	fc 01       	movw	r30, r24
     45e:	20 83       	st	Z, r18
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     460:	0f 90       	pop	r0
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	08 95       	ret

00000468 <SerialReadByte>:

uint8_t SerialReadByte(){
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	0f 92       	push	r0
     46e:	cd b7       	in	r28, 0x3d	; 61
     470:	de b7       	in	r29, 0x3e	; 62
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     472:	00 00       	nop
     474:	80 ea       	ldi	r24, 0xA0	; 160
     476:	98 e0       	ldi	r25, 0x08	; 8
     478:	fc 01       	movw	r30, r24
     47a:	81 81       	ldd	r24, Z+1	; 0x01
     47c:	88 23       	and	r24, r24
     47e:	d4 f7       	brge	.-12     	; 0x474 <SerialReadByte+0xc>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     480:	80 ea       	ldi	r24, 0xA0	; 160
     482:	98 e0       	ldi	r25, 0x08	; 8
     484:	fc 01       	movw	r30, r24
     486:	80 81       	ld	r24, Z
     488:	89 83       	std	Y+1, r24	; 0x01
	return byte;	
     48a:	89 81       	ldd	r24, Y+1	; 0x01
}
     48c:	0f 90       	pop	r0
     48e:	df 91       	pop	r29
     490:	cf 91       	pop	r28
     492:	08 95       	ret

00000494 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     494:	cf 93       	push	r28
     496:	df 93       	push	r29
     498:	cd b7       	in	r28, 0x3d	; 61
     49a:	de b7       	in	r29, 0x3e	; 62
     49c:	2a 97       	sbiw	r28, 0x0a	; 10
     49e:	cd bf       	out	0x3d, r28	; 61
     4a0:	de bf       	out	0x3e, r29	; 62
     4a2:	8d 83       	std	Y+5, r24	; 0x05
     4a4:	9e 83       	std	Y+6, r25	; 0x06
     4a6:	4f 83       	std	Y+7, r20	; 0x07
     4a8:	58 87       	std	Y+8, r21	; 0x08
     4aa:	69 87       	std	Y+9, r22	; 0x09
     4ac:	7a 87       	std	Y+10, r23	; 0x0a
	uint32_t i;
	for(i=0;i<length;i++){
     4ae:	19 82       	std	Y+1, r1	; 0x01
     4b0:	1a 82       	std	Y+2, r1	; 0x02
     4b2:	1b 82       	std	Y+3, r1	; 0x03
     4b4:	1c 82       	std	Y+4, r1	; 0x04
     4b6:	15 c0       	rjmp	.+42     	; 0x4e2 <SerialWriteBuffer+0x4e>
		SerialWriteByte(buffer[i]);
     4b8:	89 81       	ldd	r24, Y+1	; 0x01
     4ba:	9a 81       	ldd	r25, Y+2	; 0x02
     4bc:	2d 81       	ldd	r18, Y+5	; 0x05
     4be:	3e 81       	ldd	r19, Y+6	; 0x06
     4c0:	82 0f       	add	r24, r18
     4c2:	93 1f       	adc	r25, r19
     4c4:	fc 01       	movw	r30, r24
     4c6:	80 81       	ld	r24, Z
     4c8:	0e 94 1a 02 	call	0x434	; 0x434 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     4cc:	89 81       	ldd	r24, Y+1	; 0x01
     4ce:	9a 81       	ldd	r25, Y+2	; 0x02
     4d0:	ab 81       	ldd	r26, Y+3	; 0x03
     4d2:	bc 81       	ldd	r27, Y+4	; 0x04
     4d4:	01 96       	adiw	r24, 0x01	; 1
     4d6:	a1 1d       	adc	r26, r1
     4d8:	b1 1d       	adc	r27, r1
     4da:	89 83       	std	Y+1, r24	; 0x01
     4dc:	9a 83       	std	Y+2, r25	; 0x02
     4de:	ab 83       	std	Y+3, r26	; 0x03
     4e0:	bc 83       	std	Y+4, r27	; 0x04
     4e2:	29 81       	ldd	r18, Y+1	; 0x01
     4e4:	3a 81       	ldd	r19, Y+2	; 0x02
     4e6:	4b 81       	ldd	r20, Y+3	; 0x03
     4e8:	5c 81       	ldd	r21, Y+4	; 0x04
     4ea:	8f 81       	ldd	r24, Y+7	; 0x07
     4ec:	98 85       	ldd	r25, Y+8	; 0x08
     4ee:	a9 85       	ldd	r26, Y+9	; 0x09
     4f0:	ba 85       	ldd	r27, Y+10	; 0x0a
     4f2:	28 17       	cp	r18, r24
     4f4:	39 07       	cpc	r19, r25
     4f6:	4a 07       	cpc	r20, r26
     4f8:	5b 07       	cpc	r21, r27
     4fa:	f0 f2       	brcs	.-68     	; 0x4b8 <SerialWriteBuffer+0x24>
		SerialWriteByte(buffer[i]);
	}
}
     4fc:	2a 96       	adiw	r28, 0x0a	; 10
     4fe:	cd bf       	out	0x3d, r28	; 61
     500:	de bf       	out	0x3e, r29	; 62
     502:	df 91       	pop	r29
     504:	cf 91       	pop	r28
     506:	08 95       	ret

00000508 <StopSerial>:

void StopSerial(){
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	cd b7       	in	r28, 0x3d	; 61
     50e:	de b7       	in	r29, 0x3e	; 62
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     510:	80 ea       	ldi	r24, 0xA0	; 160
     512:	98 e0       	ldi	r25, 0x08	; 8
     514:	20 ea       	ldi	r18, 0xA0	; 160
     516:	38 e0       	ldi	r19, 0x08	; 8
     518:	f9 01       	movw	r30, r18
     51a:	24 81       	ldd	r18, Z+4	; 0x04
     51c:	27 7e       	andi	r18, 0xE7	; 231
     51e:	fc 01       	movw	r30, r24
     520:	24 83       	std	Z+4, r18	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     522:	80 e4       	ldi	r24, 0x40	; 64
     524:	96 e0       	ldi	r25, 0x06	; 6
     526:	28 e0       	ldi	r18, 0x08	; 8
     528:	fc 01       	movw	r30, r24
     52a:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     52c:	80 e4       	ldi	r24, 0x40	; 64
     52e:	96 e0       	ldi	r25, 0x06	; 6
     530:	28 e0       	ldi	r18, 0x08	; 8
     532:	fc 01       	movw	r30, r24
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	df 91       	pop	r29
     538:	cf 91       	pop	r28
     53a:	08 95       	ret

0000053c <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     53c:	0f 93       	push	r16
     53e:	1f 93       	push	r17
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	cd b7       	in	r28, 0x3d	; 61
     546:	de b7       	in	r29, 0x3e	; 62
     548:	2a 97       	sbiw	r28, 0x0a	; 10
     54a:	cd bf       	out	0x3d, r28	; 61
     54c:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     54e:	19 82       	std	Y+1, r1	; 0x01
	uint16_t freq = 1000;
     550:	88 ee       	ldi	r24, 0xE8	; 232
     552:	93 e0       	ldi	r25, 0x03	; 3
     554:	8a 83       	std	Y+2, r24	; 0x02
     556:	9b 83       	std	Y+3, r25	; 0x03
	chb_init();
     558:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <chb_init>
	chb_set_channel(1);
     55c:	81 e0       	ldi	r24, 0x01	; 1
     55e:	0e 94 c8 25 	call	0x4b90	; 0x4b90 <chb_set_channel>
	chb_set_short_addr(0x0002);
     562:	82 e0       	ldi	r24, 0x02	; 2
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	0e 94 c4 2b 	call	0x5788	; 0x5788 <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     56a:	0e 94 73 1e 	call	0x3ce6	; 0x3ce6 <chb_get_pcb>
     56e:	8c 83       	std	Y+4, r24	; 0x04
     570:	9d 83       	std	Y+5, r25	; 0x05
     572:	01 c0       	rjmp	.+2      	; 0x576 <main+0x3a>
		//if all data collected or ADC was stopped while sampling, send collected data to base station
		if(ADC_Sampling_Finished){
			uint32_t samples = ADC_Get_Num_Samples();
			if(samples > 0) chb_write(0x0000,FRAMReadBuffer,samples*4);
		}	
	}	
     574:	00 00       	nop
	chb_init();
	chb_set_channel(1);
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
     576:	8c 81       	ldd	r24, Y+4	; 0x04
     578:	9d 81       	ldd	r25, Y+5	; 0x05
     57a:	fc 01       	movw	r30, r24
     57c:	83 81       	ldd	r24, Z+3	; 0x03
     57e:	88 23       	and	r24, r24
     580:	09 f4       	brne	.+2      	; 0x584 <main+0x48>
     582:	89 c0       	rjmp	.+274    	; 0x696 <main+0x15a>
			//read the data
			length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
     584:	8e ed       	ldi	r24, 0xDE	; 222
     586:	93 e2       	ldi	r25, 0x23	; 35
     588:	0e 94 81 20 	call	0x4102	; 0x4102 <chb_read>
     58c:	8e 83       	std	Y+6, r24	; 0x06
			
			if(length == 1){
     58e:	8e 81       	ldd	r24, Y+6	; 0x06
     590:	81 30       	cpi	r24, 0x01	; 1
     592:	09 f0       	breq	.+2      	; 0x596 <main+0x5a>
     594:	80 c0       	rjmp	.+256    	; 0x696 <main+0x15a>
				switch ( FRAMReadBuffer[0])
     596:	80 91 de 23 	lds	r24, 0x23DE
     59a:	88 2f       	mov	r24, r24
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	87 36       	cpi	r24, 0x67	; 103
     5a0:	91 05       	cpc	r25, r1
     5a2:	11 f1       	breq	.+68     	; 0x5e8 <main+0xac>
     5a4:	88 36       	cpi	r24, 0x68	; 104
     5a6:	91 05       	cpc	r25, r1
     5a8:	2c f4       	brge	.+10     	; 0x5b4 <main+0x78>
     5aa:	86 36       	cpi	r24, 0x66	; 102
     5ac:	91 05       	cpc	r25, r1
     5ae:	09 f4       	brne	.+2      	; 0x5b2 <main+0x76>
     5b0:	64 c0       	rjmp	.+200    	; 0x67a <main+0x13e>
     5b2:	71 c0       	rjmp	.+226    	; 0x696 <main+0x15a>
     5b4:	83 37       	cpi	r24, 0x73	; 115
     5b6:	91 05       	cpc	r25, r1
     5b8:	31 f0       	breq	.+12     	; 0x5c6 <main+0x8a>
     5ba:	84 37       	cpi	r24, 0x74	; 116
     5bc:	91 05       	cpc	r25, r1
     5be:	09 f4       	brne	.+2      	; 0x5c2 <main+0x86>
     5c0:	63 c0       	rjmp	.+198    	; 0x688 <main+0x14c>
     5c2:	69 c0       	rjmp	.+210    	; 0x696 <main+0x15a>
					while(1){
						//collect data if the ADC is not collecting any data right now
						if(ADC_Sampling_Finished){
							CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
						}						
					}
     5c4:	00 00       	nop
				switch ( FRAMReadBuffer[0])
				{
				case 's':
					while(1){
						//collect data if the ADC is not collecting any data right now
						if(ADC_Sampling_Finished){
     5c6:	80 91 d4 50 	lds	r24, 0x50D4
     5ca:	88 23       	and	r24, r24
     5cc:	d9 f3       	breq	.-10     	; 0x5c4 <main+0x88>
							CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     5ce:	2a 81       	ldd	r18, Y+2	; 0x02
     5d0:	3b 81       	ldd	r19, Y+3	; 0x03
     5d2:	ee ed       	ldi	r30, 0xDE	; 222
     5d4:	f3 e2       	ldi	r31, 0x23	; 35
     5d6:	80 e0       	ldi	r24, 0x00	; 0
     5d8:	69 81       	ldd	r22, Y+1	; 0x01
     5da:	a9 01       	movw	r20, r18
     5dc:	2c e1       	ldi	r18, 0x1C	; 28
     5de:	37 e0       	ldi	r19, 0x07	; 7
     5e0:	8f 01       	movw	r16, r30
     5e2:	0e 94 cc 0a 	call	0x1598	; 0x1598 <CO_collectADC>
						}						
					}
     5e6:	ee cf       	rjmp	.-36     	; 0x5c4 <main+0x88>
					break;
				case 'g':
					//set gain to what is specified
					switch(FRAMReadBuffer[1]){
     5e8:	80 91 df 23 	lds	r24, 0x23DF
     5ec:	88 2f       	mov	r24, r24
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	88 30       	cpi	r24, 0x08	; 8
     5f2:	91 05       	cpc	r25, r1
     5f4:	31 f1       	breq	.+76     	; 0x642 <main+0x106>
     5f6:	89 30       	cpi	r24, 0x09	; 9
     5f8:	91 05       	cpc	r25, r1
     5fa:	54 f4       	brge	.+20     	; 0x610 <main+0xd4>
     5fc:	82 30       	cpi	r24, 0x02	; 2
     5fe:	91 05       	cpc	r25, r1
     600:	d1 f0       	breq	.+52     	; 0x636 <main+0xfa>
     602:	84 30       	cpi	r24, 0x04	; 4
     604:	91 05       	cpc	r25, r1
     606:	d1 f0       	breq	.+52     	; 0x63c <main+0x100>
     608:	81 30       	cpi	r24, 0x01	; 1
     60a:	91 05       	cpc	r25, r1
     60c:	91 f0       	breq	.+36     	; 0x632 <main+0xf6>
     60e:	28 c0       	rjmp	.+80     	; 0x660 <main+0x124>
     610:	80 32       	cpi	r24, 0x20	; 32
     612:	91 05       	cpc	r25, r1
     614:	e1 f0       	breq	.+56     	; 0x64e <main+0x112>
     616:	81 32       	cpi	r24, 0x21	; 33
     618:	91 05       	cpc	r25, r1
     61a:	24 f4       	brge	.+8      	; 0x624 <main+0xe8>
     61c:	80 31       	cpi	r24, 0x10	; 16
     61e:	91 05       	cpc	r25, r1
     620:	99 f0       	breq	.+38     	; 0x648 <main+0x10c>
     622:	1e c0       	rjmp	.+60     	; 0x660 <main+0x124>
     624:	80 34       	cpi	r24, 0x40	; 64
     626:	91 05       	cpc	r25, r1
     628:	a9 f0       	breq	.+42     	; 0x654 <main+0x118>
     62a:	80 38       	cpi	r24, 0x80	; 128
     62c:	91 05       	cpc	r25, r1
     62e:	a9 f0       	breq	.+42     	; 0x65a <main+0x11e>
     630:	17 c0       	rjmp	.+46     	; 0x660 <main+0x124>
						case 1:
							gain = GAIN_1_gc;
     632:	19 82       	std	Y+1, r1	; 0x01
							break;
     634:	21 c0       	rjmp	.+66     	; 0x678 <main+0x13c>
						case 2:
							gain = GAIN_2_gc;
     636:	81 e0       	ldi	r24, 0x01	; 1
     638:	89 83       	std	Y+1, r24	; 0x01
							break;
     63a:	1e c0       	rjmp	.+60     	; 0x678 <main+0x13c>
						case 4:
							gain = GAIN_4_gc;
     63c:	82 e0       	ldi	r24, 0x02	; 2
     63e:	89 83       	std	Y+1, r24	; 0x01
							break;
     640:	1b c0       	rjmp	.+54     	; 0x678 <main+0x13c>
						case 8:
							gain = GAIN_8_gc;
     642:	83 e0       	ldi	r24, 0x03	; 3
     644:	89 83       	std	Y+1, r24	; 0x01
							break;
     646:	18 c0       	rjmp	.+48     	; 0x678 <main+0x13c>
						case 16:
							gain = GAIN_16_gc;
     648:	84 e0       	ldi	r24, 0x04	; 4
     64a:	89 83       	std	Y+1, r24	; 0x01
							break;
     64c:	15 c0       	rjmp	.+42     	; 0x678 <main+0x13c>
						case 32:
							gain = GAIN_32_gc;
     64e:	85 e0       	ldi	r24, 0x05	; 5
     650:	89 83       	std	Y+1, r24	; 0x01
							break;
     652:	12 c0       	rjmp	.+36     	; 0x678 <main+0x13c>
						case 64:
							gain = GAIN_64_gc;
     654:	86 e0       	ldi	r24, 0x06	; 6
     656:	89 83       	std	Y+1, r24	; 0x01
							break;
     658:	0f c0       	rjmp	.+30     	; 0x678 <main+0x13c>
						case 128:
							gain = GAIN_128_gc;
     65a:	87 e0       	ldi	r24, 0x07	; 7
     65c:	89 83       	std	Y+1, r24	; 0x01
							break;
     65e:	0c c0       	rjmp	.+24     	; 0x678 <main+0x13c>
						default:
							chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
     660:	20 e0       	ldi	r18, 0x00	; 0
     662:	30 e2       	ldi	r19, 0x20	; 32
     664:	80 e0       	ldi	r24, 0x00	; 0
     666:	90 e0       	ldi	r25, 0x00	; 0
     668:	b9 01       	movw	r22, r18
     66a:	2c e0       	ldi	r18, 0x0C	; 12
     66c:	30 e0       	ldi	r19, 0x00	; 0
     66e:	40 e0       	ldi	r20, 0x00	; 0
     670:	50 e0       	ldi	r21, 0x00	; 0
     672:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <chb_write>
							break;
     676:	00 00       	nop
					}					
					break;
     678:	0e c0       	rjmp	.+28     	; 0x696 <main+0x15a>
				case 'f':
					//set sampling frequency to what is specified
					freq = *(uint16_t*)(FRAMReadBuffer+1);
     67a:	80 91 df 23 	lds	r24, 0x23DF
     67e:	90 91 e0 23 	lds	r25, 0x23E0
     682:	8a 83       	std	Y+2, r24	; 0x02
     684:	9b 83       	std	Y+3, r25	; 0x03
					break;
     686:	07 c0       	rjmp	.+14     	; 0x696 <main+0x15a>
				case 't':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     688:	80 91 d4 50 	lds	r24, 0x50D4
     68c:	88 23       	and	r24, r24
     68e:	11 f4       	brne	.+4      	; 0x694 <main+0x158>
						ADC_Stop_Sampling();
     690:	0e 94 12 0c 	call	0x1824	; 0x1824 <ADC_Stop_Sampling>
					}
					//otherwise, the ADC has finished sampling on its own and the data will be transmitted after this case statement
					break;
     694:	00 00       	nop
				}	
			}			
		}		
		//if all data collected or ADC was stopped while sampling, send collected data to base station
		if(ADC_Sampling_Finished){
     696:	80 91 d4 50 	lds	r24, 0x50D4
     69a:	88 23       	and	r24, r24
     69c:	09 f4       	brne	.+2      	; 0x6a0 <main+0x164>
     69e:	6a cf       	rjmp	.-300    	; 0x574 <main+0x38>
			uint32_t samples = ADC_Get_Num_Samples();
     6a0:	0e 94 48 0c 	call	0x1890	; 0x1890 <ADC_Get_Num_Samples>
     6a4:	cc 01       	movw	r24, r24
     6a6:	a0 e0       	ldi	r26, 0x00	; 0
     6a8:	b0 e0       	ldi	r27, 0x00	; 0
     6aa:	8f 83       	std	Y+7, r24	; 0x07
     6ac:	98 87       	std	Y+8, r25	; 0x08
     6ae:	a9 87       	std	Y+9, r26	; 0x09
     6b0:	ba 87       	std	Y+10, r27	; 0x0a
			if(samples > 0) chb_write(0x0000,FRAMReadBuffer,samples*4);
     6b2:	8f 81       	ldd	r24, Y+7	; 0x07
     6b4:	98 85       	ldd	r25, Y+8	; 0x08
     6b6:	a9 85       	ldd	r26, Y+9	; 0x09
     6b8:	ba 85       	ldd	r27, Y+10	; 0x0a
     6ba:	00 97       	sbiw	r24, 0x00	; 0
     6bc:	a1 05       	cpc	r26, r1
     6be:	b1 05       	cpc	r27, r1
     6c0:	09 f4       	brne	.+2      	; 0x6c4 <main+0x188>
     6c2:	58 cf       	rjmp	.-336    	; 0x574 <main+0x38>
     6c4:	8f 81       	ldd	r24, Y+7	; 0x07
     6c6:	98 85       	ldd	r25, Y+8	; 0x08
     6c8:	a9 85       	ldd	r26, Y+9	; 0x09
     6ca:	ba 85       	ldd	r27, Y+10	; 0x0a
     6cc:	9c 01       	movw	r18, r24
     6ce:	ad 01       	movw	r20, r26
     6d0:	22 0f       	add	r18, r18
     6d2:	33 1f       	adc	r19, r19
     6d4:	44 1f       	adc	r20, r20
     6d6:	55 1f       	adc	r21, r21
     6d8:	22 0f       	add	r18, r18
     6da:	33 1f       	adc	r19, r19
     6dc:	44 1f       	adc	r20, r20
     6de:	55 1f       	adc	r21, r21
     6e0:	6e ed       	ldi	r22, 0xDE	; 222
     6e2:	73 e2       	ldi	r23, 0x23	; 35
     6e4:	80 e0       	ldi	r24, 0x00	; 0
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <chb_write>
		}	
	}	
     6ec:	43 cf       	rjmp	.-378    	; 0x574 <main+0x38>

000006ee <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
     6f2:	0f 92       	push	r0
     6f4:	0f 92       	push	r0
     6f6:	cd b7       	in	r28, 0x3d	; 61
     6f8:	de b7       	in	r29, 0x3e	; 62
     6fa:	89 83       	std	Y+1, r24	; 0x01
     6fc:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	80 93 cf 50 	sts	0x50CF, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     704:	83 e0       	ldi	r24, 0x03	; 3
     706:	80 93 5d 40 	sts	0x405D, r24
	chb_init();
     70a:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <chb_init>
	chb_set_short_addr(moteID);
     70e:	80 91 cf 50 	lds	r24, 0x50CF
     712:	88 2f       	mov	r24, r24
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	0e 94 c4 2b 	call	0x5788	; 0x5788 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     71a:	80 e8       	ldi	r24, 0x80	; 128
     71c:	91 e0       	ldi	r25, 0x01	; 1
     71e:	28 ec       	ldi	r18, 0xC8	; 200
     720:	fc 01       	movw	r30, r24
     722:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     724:	80 e4       	ldi	r24, 0x40	; 64
     726:	99 e0       	ldi	r25, 0x09	; 9
     728:	29 e0       	ldi	r18, 0x09	; 9
     72a:	fc 01       	movw	r30, r24
     72c:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     72e:	80 e4       	ldi	r24, 0x40	; 64
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	22 e0       	ldi	r18, 0x02	; 2
     734:	fc 01       	movw	r30, r24
     736:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     738:	80 e4       	ldi	r24, 0x40	; 64
     73a:	99 e0       	ldi	r25, 0x09	; 9
     73c:	69 81       	ldd	r22, Y+1	; 0x01
     73e:	7a 81       	ldd	r23, Y+2	; 0x02
     740:	44 ef       	ldi	r20, 0xF4	; 244
     742:	51 e0       	ldi	r21, 0x01	; 1
     744:	64 9f       	mul	r22, r20
     746:	90 01       	movw	r18, r0
     748:	65 9f       	mul	r22, r21
     74a:	30 0d       	add	r19, r0
     74c:	74 9f       	mul	r23, r20
     74e:	30 0d       	add	r19, r0
     750:	11 24       	eor	r1, r1
     752:	fc 01       	movw	r30, r24
     754:	26 a3       	lds	r18, 0x56
     756:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     758:	80 e4       	ldi	r24, 0x40	; 64
     75a:	98 e0       	ldi	r25, 0x08	; 8
     75c:	20 e0       	ldi	r18, 0x00	; 0
     75e:	3a ef       	ldi	r19, 0xFA	; 250
     760:	fc 01       	movw	r30, r24
     762:	26 a3       	lds	r18, 0x56
     764:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     766:	80 e4       	ldi	r24, 0x40	; 64
     768:	98 e0       	ldi	r25, 0x08	; 8
     76a:	21 e0       	ldi	r18, 0x01	; 1
     76c:	fc 01       	movw	r30, r24
     76e:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     770:	80 e4       	ldi	r24, 0x40	; 64
     772:	98 e0       	ldi	r25, 0x08	; 8
     774:	21 e0       	ldi	r18, 0x01	; 1
     776:	fc 01       	movw	r30, r24
     778:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     77a:	80 ea       	ldi	r24, 0xA0	; 160
     77c:	90 e0       	ldi	r25, 0x00	; 0
     77e:	20 ea       	ldi	r18, 0xA0	; 160
     780:	30 e0       	ldi	r19, 0x00	; 0
     782:	f9 01       	movw	r30, r18
     784:	22 81       	ldd	r18, Z+2	; 0x02
     786:	27 60       	ori	r18, 0x07	; 7
     788:	fc 01       	movw	r30, r24
     78a:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     78c:	78 94       	sei
}
     78e:	0f 90       	pop	r0
     790:	0f 90       	pop	r0
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	08 95       	ret

00000798 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     798:	78 94       	sei
     79a:	1f 92       	push	r1
     79c:	0f 92       	push	r0
     79e:	0f b6       	in	r0, 0x3f	; 63
     7a0:	0f 92       	push	r0
     7a2:	00 90 3b 00 	lds	r0, 0x003B
     7a6:	0f 92       	push	r0
     7a8:	11 24       	eor	r1, r1
     7aa:	2f 93       	push	r18
     7ac:	3f 93       	push	r19
     7ae:	4f 93       	push	r20
     7b0:	5f 93       	push	r21
     7b2:	6f 93       	push	r22
     7b4:	7f 93       	push	r23
     7b6:	8f 93       	push	r24
     7b8:	9f 93       	push	r25
     7ba:	af 93       	push	r26
     7bc:	bf 93       	push	r27
     7be:	ef 93       	push	r30
     7c0:	ff 93       	push	r31
     7c2:	cf 93       	push	r28
     7c4:	df 93       	push	r29
     7c6:	cd b7       	in	r28, 0x3d	; 61
     7c8:	de b7       	in	r29, 0x3e	; 62
     7ca:	28 97       	sbiw	r28, 0x08	; 8
     7cc:	cd bf       	out	0x3d, r28	; 61
     7ce:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     7d0:	80 e4       	ldi	r24, 0x40	; 64
     7d2:	98 e0       	ldi	r25, 0x08	; 8
     7d4:	fc 01       	movw	r30, r24
     7d6:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     7d8:	80 e4       	ldi	r24, 0x40	; 64
     7da:	99 e0       	ldi	r25, 0x09	; 9
     7dc:	fc 01       	movw	r30, r24
     7de:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     7e0:	82 e0       	ldi	r24, 0x02	; 2
     7e2:	80 93 5d 40 	sts	0x405D, r24
	char message[8];
	strcpy(message,"reset");
     7e6:	ce 01       	movw	r24, r28
     7e8:	01 96       	adiw	r24, 0x01	; 1
     7ea:	2d e0       	ldi	r18, 0x0D	; 13
     7ec:	30 e2       	ldi	r19, 0x20	; 32
     7ee:	46 e0       	ldi	r20, 0x06	; 6
     7f0:	f9 01       	movw	r30, r18
     7f2:	00 80       	ld	r0, Z
     7f4:	2f 5f       	subi	r18, 0xFF	; 255
     7f6:	3f 4f       	sbci	r19, 0xFF	; 255
     7f8:	fc 01       	movw	r30, r24
     7fa:	00 82       	st	Z, r0
     7fc:	01 96       	adiw	r24, 0x01	; 1
     7fe:	41 50       	subi	r20, 0x01	; 1
     800:	44 23       	and	r20, r20
     802:	b1 f7       	brne	.-20     	; 0x7f0 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     804:	80 91 cf 50 	lds	r24, 0x50CF
     808:	88 2f       	mov	r24, r24
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	26 ed       	ldi	r18, 0xD6	; 214
     80e:	30 e5       	ldi	r19, 0x50	; 80
     810:	b9 01       	movw	r22, r18
     812:	4a e0       	ldi	r20, 0x0A	; 10
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	0e 94 90 5d 	call	0xbb20	; 0xbb20 <itoa>
	strcat(message,buff);
     81a:	26 ed       	ldi	r18, 0xD6	; 214
     81c:	30 e5       	ldi	r19, 0x50	; 80
     81e:	ce 01       	movw	r24, r28
     820:	01 96       	adiw	r24, 0x01	; 1
     822:	b9 01       	movw	r22, r18
     824:	0e 94 77 5d 	call	0xbaee	; 0xbaee <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     828:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     82c:	ce 01       	movw	r24, r28
     82e:	01 96       	adiw	r24, 0x01	; 1
     830:	9c 01       	movw	r18, r24
     832:	f9 01       	movw	r30, r18
     834:	01 90       	ld	r0, Z+
     836:	00 20       	and	r0, r0
     838:	e9 f7       	brne	.-6      	; 0x834 <__vector_83+0x9c>
     83a:	cf 01       	movw	r24, r30
     83c:	01 97       	sbiw	r24, 0x01	; 1
     83e:	82 1b       	sub	r24, r18
     840:	93 0b       	sbc	r25, r19
     842:	9c 01       	movw	r18, r24
     844:	40 e0       	ldi	r20, 0x00	; 0
     846:	50 e0       	ldi	r21, 0x00	; 0
     848:	80 e0       	ldi	r24, 0x00	; 0
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	be 01       	movw	r22, r28
     84e:	6f 5f       	subi	r22, 0xFF	; 255
     850:	7f 4f       	sbci	r23, 0xFF	; 255
     852:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <chb_write>
}	
     856:	28 96       	adiw	r28, 0x08	; 8
     858:	cd bf       	out	0x3d, r28	; 61
     85a:	de bf       	out	0x3e, r29	; 62
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	ff 91       	pop	r31
     862:	ef 91       	pop	r30
     864:	bf 91       	pop	r27
     866:	af 91       	pop	r26
     868:	9f 91       	pop	r25
     86a:	8f 91       	pop	r24
     86c:	7f 91       	pop	r23
     86e:	6f 91       	pop	r22
     870:	5f 91       	pop	r21
     872:	4f 91       	pop	r20
     874:	3f 91       	pop	r19
     876:	2f 91       	pop	r18
     878:	0f 90       	pop	r0
     87a:	00 92 3b 00 	sts	0x003B, r0
     87e:	0f 90       	pop	r0
     880:	0f be       	out	0x3f, r0	; 63
     882:	0f 90       	pop	r0
     884:	1f 90       	pop	r1
     886:	18 95       	reti

00000888 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	6b 97       	sbiw	r28, 0x1b	; 27
     892:	cd bf       	out	0x3d, r28	; 61
     894:	de bf       	out	0x3e, r29	; 62
     896:	8e 8b       	std	Y+22, r24	; 0x16
     898:	9f 8b       	std	Y+23, r25	; 0x17
     89a:	68 8f       	std	Y+24, r22	; 0x18
     89c:	79 8f       	std	Y+25, r23	; 0x19
     89e:	4a 8f       	std	Y+26, r20	; 0x1a
     8a0:	5b 8f       	std	Y+27, r21	; 0x1b
	
	uint32_t sum = 0;
     8a2:	19 82       	std	Y+1, r1	; 0x01
     8a4:	1a 82       	std	Y+2, r1	; 0x02
     8a6:	1b 82       	std	Y+3, r1	; 0x03
     8a8:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     8aa:	80 e0       	ldi	r24, 0x00	; 0
     8ac:	90 e1       	ldi	r25, 0x10	; 16
     8ae:	a0 e0       	ldi	r26, 0x00	; 0
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	8d 83       	std	Y+5, r24	; 0x05
     8b4:	9e 83       	std	Y+6, r25	; 0x06
     8b6:	af 83       	std	Y+7, r26	; 0x07
     8b8:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     8ba:	19 86       	std	Y+9, r1	; 0x09
     8bc:	1a 86       	std	Y+10, r1	; 0x0a
     8be:	1b 86       	std	Y+11, r1	; 0x0b
     8c0:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     8c2:	81 e0       	ldi	r24, 0x01	; 1
     8c4:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	92 e0       	ldi	r25, 0x02	; 2
     8cc:	0e 94 8d 1a 	call	0x351a	; 0x351a <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     8d0:	80 e0       	ldi	r24, 0x00	; 0
     8d2:	92 e0       	ldi	r25, 0x02	; 2
     8d4:	20 e0       	ldi	r18, 0x00	; 0
     8d6:	32 e0       	ldi	r19, 0x02	; 2
     8d8:	f9 01       	movw	r30, r18
     8da:	21 81       	ldd	r18, Z+1	; 0x01
     8dc:	29 7e       	andi	r18, 0xE9	; 233
     8de:	fc 01       	movw	r30, r24
     8e0:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     8e2:	80 e0       	ldi	r24, 0x00	; 0
     8e4:	92 e0       	ldi	r25, 0x02	; 2
     8e6:	20 e0       	ldi	r18, 0x00	; 0
     8e8:	32 e0       	ldi	r19, 0x02	; 2
     8ea:	f9 01       	movw	r30, r18
     8ec:	24 81       	ldd	r18, Z+4	; 0x04
     8ee:	28 7f       	andi	r18, 0xF8	; 248
     8f0:	23 60       	ori	r18, 0x03	; 3
     8f2:	fc 01       	movw	r30, r24
     8f4:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     8f6:	80 e0       	ldi	r24, 0x00	; 0
     8f8:	92 e0       	ldi	r25, 0x02	; 2
     8fa:	20 e0       	ldi	r18, 0x00	; 0
     8fc:	32 e0       	ldi	r19, 0x02	; 2
     8fe:	f9 01       	movw	r30, r18
     900:	22 81       	ldd	r18, Z+2	; 0x02
     902:	2f 7c       	andi	r18, 0xCF	; 207
     904:	fc 01       	movw	r30, r24
     906:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     908:	80 e2       	ldi	r24, 0x20	; 32
     90a:	92 e0       	ldi	r25, 0x02	; 2
     90c:	20 e2       	ldi	r18, 0x20	; 32
     90e:	32 e0       	ldi	r19, 0x02	; 2
     910:	f9 01       	movw	r30, r18
     912:	20 81       	ld	r18, Z
     914:	20 7e       	andi	r18, 0xE0	; 224
     916:	21 60       	ori	r18, 0x01	; 1
     918:	fc 01       	movw	r30, r24
     91a:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     91c:	80 e2       	ldi	r24, 0x20	; 32
     91e:	92 e0       	ldi	r25, 0x02	; 2
     920:	29 e0       	ldi	r18, 0x09	; 9
     922:	fc 01       	movw	r30, r24
     924:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     926:	80 e0       	ldi	r24, 0x00	; 0
     928:	92 e0       	ldi	r25, 0x02	; 2
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	32 e0       	ldi	r19, 0x02	; 2
     92e:	f9 01       	movw	r30, r18
     930:	20 81       	ld	r18, Z
     932:	21 60       	ori	r18, 0x01	; 1
     934:	fc 01       	movw	r30, r24
     936:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     938:	80 e0       	ldi	r24, 0x00	; 0
     93a:	92 e0       	ldi	r25, 0x02	; 2
     93c:	0e 94 45 1c 	call	0x388a	; 0x388a <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     940:	80 e0       	ldi	r24, 0x00	; 0
     942:	92 e0       	ldi	r25, 0x02	; 2
     944:	60 e2       	ldi	r22, 0x20	; 32
     946:	72 e0       	ldi	r23, 0x02	; 2
     948:	40 e0       	ldi	r20, 0x00	; 0
     94a:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <ADC_Offset_Get_Unsigned>
     94e:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	92 e0       	ldi	r25, 0x02	; 2
     954:	20 e0       	ldi	r18, 0x00	; 0
     956:	32 e0       	ldi	r19, 0x02	; 2
     958:	f9 01       	movw	r30, r18
     95a:	20 81       	ld	r18, Z
     95c:	2e 7f       	andi	r18, 0xFE	; 254
     95e:	fc 01       	movw	r30, r24
     960:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     962:	80 e2       	ldi	r24, 0x20	; 32
     964:	92 e0       	ldi	r25, 0x02	; 2
     966:	fc 01       	movw	r30, r24
     968:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	92 e0       	ldi	r25, 0x02	; 2
     96e:	20 e0       	ldi	r18, 0x00	; 0
     970:	32 e0       	ldi	r19, 0x02	; 2
     972:	f9 01       	movw	r30, r18
     974:	23 81       	ldd	r18, Z+3	; 0x03
     976:	2f 73       	andi	r18, 0x3F	; 63
     978:	fc 01       	movw	r30, r24
     97a:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	92 e0       	ldi	r25, 0x02	; 2
     980:	20 e0       	ldi	r18, 0x00	; 0
     982:	32 e0       	ldi	r19, 0x02	; 2
     984:	f9 01       	movw	r30, r18
     986:	20 81       	ld	r18, Z
     988:	21 60       	ori	r18, 0x01	; 1
     98a:	fc 01       	movw	r30, r24
     98c:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     98e:	80 e0       	ldi	r24, 0x00	; 0
     990:	92 e0       	ldi	r25, 0x02	; 2
     992:	0e 94 45 1c 	call	0x388a	; 0x388a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     996:	80 e0       	ldi	r24, 0x00	; 0
     998:	92 e0       	ldi	r25, 0x02	; 2
     99a:	20 e0       	ldi	r18, 0x00	; 0
     99c:	32 e0       	ldi	r19, 0x02	; 2
     99e:	f9 01       	movw	r30, r18
     9a0:	21 81       	ldd	r18, Z+1	; 0x01
     9a2:	28 60       	ori	r18, 0x08	; 8
     9a4:	fc 01       	movw	r30, r24
     9a6:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     9a8:	1d 86       	std	Y+13, r1	; 0x0d
     9aa:	1e 86       	std	Y+14, r1	; 0x0e
     9ac:	56 c0       	rjmp	.+172    	; 0xa5a <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     9ae:	80 e2       	ldi	r24, 0x20	; 32
     9b0:	92 e0       	ldi	r25, 0x02	; 2
     9b2:	fc 01       	movw	r30, r24
     9b4:	83 81       	ldd	r24, Z+3	; 0x03
     9b6:	88 2f       	mov	r24, r24
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	81 70       	andi	r24, 0x01	; 1
     9bc:	90 70       	andi	r25, 0x00	; 0
     9be:	00 97       	sbiw	r24, 0x00	; 0
     9c0:	b1 f3       	breq	.-20     	; 0x9ae <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     9c2:	2d 89       	ldd	r18, Y+21	; 0x15
     9c4:	80 e2       	ldi	r24, 0x20	; 32
     9c6:	92 e0       	ldi	r25, 0x02	; 2
     9c8:	62 2f       	mov	r22, r18
     9ca:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <ADC_ResultCh_GetWord_Signed>
     9ce:	8f 87       	std	Y+15, r24	; 0x0f
     9d0:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     9d2:	8f 85       	ldd	r24, Y+15	; 0x0f
     9d4:	98 89       	ldd	r25, Y+16	; 0x10
     9d6:	cc 01       	movw	r24, r24
     9d8:	a0 e0       	ldi	r26, 0x00	; 0
     9da:	b0 e0       	ldi	r27, 0x00	; 0
     9dc:	29 81       	ldd	r18, Y+1	; 0x01
     9de:	3a 81       	ldd	r19, Y+2	; 0x02
     9e0:	4b 81       	ldd	r20, Y+3	; 0x03
     9e2:	5c 81       	ldd	r21, Y+4	; 0x04
     9e4:	82 0f       	add	r24, r18
     9e6:	93 1f       	adc	r25, r19
     9e8:	a4 1f       	adc	r26, r20
     9ea:	b5 1f       	adc	r27, r21
     9ec:	89 83       	std	Y+1, r24	; 0x01
     9ee:	9a 83       	std	Y+2, r25	; 0x02
     9f0:	ab 83       	std	Y+3, r26	; 0x03
     9f2:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     9f4:	8f 85       	ldd	r24, Y+15	; 0x0f
     9f6:	98 89       	ldd	r25, Y+16	; 0x10
     9f8:	9c 01       	movw	r18, r24
     9fa:	40 e0       	ldi	r20, 0x00	; 0
     9fc:	50 e0       	ldi	r21, 0x00	; 0
     9fe:	89 85       	ldd	r24, Y+9	; 0x09
     a00:	9a 85       	ldd	r25, Y+10	; 0x0a
     a02:	ab 85       	ldd	r26, Y+11	; 0x0b
     a04:	bc 85       	ldd	r27, Y+12	; 0x0c
     a06:	82 17       	cp	r24, r18
     a08:	93 07       	cpc	r25, r19
     a0a:	a4 07       	cpc	r26, r20
     a0c:	b5 07       	cpc	r27, r21
     a0e:	48 f4       	brcc	.+18     	; 0xa22 <CO_collectTemp+0x19a>
     a10:	8f 85       	ldd	r24, Y+15	; 0x0f
     a12:	98 89       	ldd	r25, Y+16	; 0x10
     a14:	cc 01       	movw	r24, r24
     a16:	a0 e0       	ldi	r26, 0x00	; 0
     a18:	b0 e0       	ldi	r27, 0x00	; 0
     a1a:	89 87       	std	Y+9, r24	; 0x09
     a1c:	9a 87       	std	Y+10, r25	; 0x0a
     a1e:	ab 87       	std	Y+11, r26	; 0x0b
     a20:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     a22:	8f 85       	ldd	r24, Y+15	; 0x0f
     a24:	98 89       	ldd	r25, Y+16	; 0x10
     a26:	9c 01       	movw	r18, r24
     a28:	40 e0       	ldi	r20, 0x00	; 0
     a2a:	50 e0       	ldi	r21, 0x00	; 0
     a2c:	8d 81       	ldd	r24, Y+5	; 0x05
     a2e:	9e 81       	ldd	r25, Y+6	; 0x06
     a30:	af 81       	ldd	r26, Y+7	; 0x07
     a32:	b8 85       	ldd	r27, Y+8	; 0x08
     a34:	28 17       	cp	r18, r24
     a36:	39 07       	cpc	r19, r25
     a38:	4a 07       	cpc	r20, r26
     a3a:	5b 07       	cpc	r21, r27
     a3c:	48 f4       	brcc	.+18     	; 0xa50 <CO_collectTemp+0x1c8>
     a3e:	8f 85       	ldd	r24, Y+15	; 0x0f
     a40:	98 89       	ldd	r25, Y+16	; 0x10
     a42:	cc 01       	movw	r24, r24
     a44:	a0 e0       	ldi	r26, 0x00	; 0
     a46:	b0 e0       	ldi	r27, 0x00	; 0
     a48:	8d 83       	std	Y+5, r24	; 0x05
     a4a:	9e 83       	std	Y+6, r25	; 0x06
     a4c:	af 83       	std	Y+7, r26	; 0x07
     a4e:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a50:	8d 85       	ldd	r24, Y+13	; 0x0d
     a52:	9e 85       	ldd	r25, Y+14	; 0x0e
     a54:	01 96       	adiw	r24, 0x01	; 1
     a56:	8d 87       	std	Y+13, r24	; 0x0d
     a58:	9e 87       	std	Y+14, r25	; 0x0e
     a5a:	8d 85       	ldd	r24, Y+13	; 0x0d
     a5c:	9e 85       	ldd	r25, Y+14	; 0x0e
     a5e:	f4 e0       	ldi	r31, 0x04	; 4
     a60:	80 30       	cpi	r24, 0x00	; 0
     a62:	9f 07       	cpc	r25, r31
     a64:	08 f4       	brcc	.+2      	; 0xa68 <CO_collectTemp+0x1e0>
     a66:	a3 cf       	rjmp	.-186    	; 0x9ae <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     a68:	80 e0       	ldi	r24, 0x00	; 0
     a6a:	92 e0       	ldi	r25, 0x02	; 2
     a6c:	20 e0       	ldi	r18, 0x00	; 0
     a6e:	32 e0       	ldi	r19, 0x02	; 2
     a70:	f9 01       	movw	r30, r18
     a72:	21 81       	ldd	r18, Z+1	; 0x01
     a74:	27 7f       	andi	r18, 0xF7	; 247
     a76:	fc 01       	movw	r30, r24
     a78:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	92 e0       	ldi	r25, 0x02	; 2
     a7e:	20 e0       	ldi	r18, 0x00	; 0
     a80:	32 e0       	ldi	r19, 0x02	; 2
     a82:	f9 01       	movw	r30, r18
     a84:	20 81       	ld	r18, Z
     a86:	22 60       	ori	r18, 0x02	; 2
     a88:	fc 01       	movw	r30, r24
     a8a:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	20 e0       	ldi	r18, 0x00	; 0
     a92:	32 e0       	ldi	r19, 0x02	; 2
     a94:	f9 01       	movw	r30, r18
     a96:	20 81       	ld	r18, Z
     a98:	2e 7f       	andi	r18, 0xFE	; 254
     a9a:	fc 01       	movw	r30, r24
     a9c:	20 83       	st	Z, r18

	ADCPower(FALSE);
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>

	average = sum / NUM_SAMPLES;
     aa4:	89 81       	ldd	r24, Y+1	; 0x01
     aa6:	9a 81       	ldd	r25, Y+2	; 0x02
     aa8:	ab 81       	ldd	r26, Y+3	; 0x03
     aaa:	bc 81       	ldd	r27, Y+4	; 0x04
     aac:	07 2e       	mov	r0, r23
     aae:	7a e0       	ldi	r23, 0x0A	; 10
     ab0:	b6 95       	lsr	r27
     ab2:	a7 95       	ror	r26
     ab4:	97 95       	ror	r25
     ab6:	87 95       	ror	r24
     ab8:	7a 95       	dec	r23
     aba:	d1 f7       	brne	.-12     	; 0xab0 <CO_collectTemp+0x228>
     abc:	70 2d       	mov	r23, r0
     abe:	89 8b       	std	Y+17, r24	; 0x11
     ac0:	9a 8b       	std	Y+18, r25	; 0x12
     ac2:	ab 8b       	std	Y+19, r26	; 0x13
     ac4:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     ac6:	89 89       	ldd	r24, Y+17	; 0x11
     ac8:	9a 89       	ldd	r25, Y+18	; 0x12
     aca:	ab 89       	ldd	r26, Y+19	; 0x13
     acc:	bc 89       	ldd	r27, Y+20	; 0x14
     ace:	28 ee       	ldi	r18, 0xE8	; 232
     ad0:	33 e0       	ldi	r19, 0x03	; 3
     ad2:	40 e0       	ldi	r20, 0x00	; 0
     ad4:	50 e0       	ldi	r21, 0x00	; 0
     ad6:	bc 01       	movw	r22, r24
     ad8:	cd 01       	movw	r24, r26
     ada:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
     ade:	dc 01       	movw	r26, r24
     ae0:	cb 01       	movw	r24, r22
     ae2:	2f ef       	ldi	r18, 0xFF	; 255
     ae4:	3f e0       	ldi	r19, 0x0F	; 15
     ae6:	40 e0       	ldi	r20, 0x00	; 0
     ae8:	50 e0       	ldi	r21, 0x00	; 0
     aea:	bc 01       	movw	r22, r24
     aec:	cd 01       	movw	r24, r26
     aee:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
     af2:	da 01       	movw	r26, r20
     af4:	c9 01       	movw	r24, r18
     af6:	9c 01       	movw	r18, r24
     af8:	22 53       	subi	r18, 0x32	; 50
     afa:	30 40       	sbci	r19, 0x00	; 0
     afc:	8e 89       	ldd	r24, Y+22	; 0x16
     afe:	9f 89       	ldd	r25, Y+23	; 0x17
     b00:	fc 01       	movw	r30, r24
     b02:	20 83       	st	Z, r18
     b04:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     b06:	89 85       	ldd	r24, Y+9	; 0x09
     b08:	9a 85       	ldd	r25, Y+10	; 0x0a
     b0a:	ab 85       	ldd	r26, Y+11	; 0x0b
     b0c:	bc 85       	ldd	r27, Y+12	; 0x0c
     b0e:	28 ee       	ldi	r18, 0xE8	; 232
     b10:	33 e0       	ldi	r19, 0x03	; 3
     b12:	40 e0       	ldi	r20, 0x00	; 0
     b14:	50 e0       	ldi	r21, 0x00	; 0
     b16:	bc 01       	movw	r22, r24
     b18:	cd 01       	movw	r24, r26
     b1a:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
     b1e:	dc 01       	movw	r26, r24
     b20:	cb 01       	movw	r24, r22
     b22:	2f ef       	ldi	r18, 0xFF	; 255
     b24:	3f e0       	ldi	r19, 0x0F	; 15
     b26:	40 e0       	ldi	r20, 0x00	; 0
     b28:	50 e0       	ldi	r21, 0x00	; 0
     b2a:	bc 01       	movw	r22, r24
     b2c:	cd 01       	movw	r24, r26
     b2e:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
     b32:	da 01       	movw	r26, r20
     b34:	c9 01       	movw	r24, r18
     b36:	9c 01       	movw	r18, r24
     b38:	22 53       	subi	r18, 0x32	; 50
     b3a:	30 40       	sbci	r19, 0x00	; 0
     b3c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b3e:	9b 8d       	ldd	r25, Y+27	; 0x1b
     b40:	fc 01       	movw	r30, r24
     b42:	20 83       	st	Z, r18
     b44:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     b46:	8d 81       	ldd	r24, Y+5	; 0x05
     b48:	9e 81       	ldd	r25, Y+6	; 0x06
     b4a:	af 81       	ldd	r26, Y+7	; 0x07
     b4c:	b8 85       	ldd	r27, Y+8	; 0x08
     b4e:	28 ee       	ldi	r18, 0xE8	; 232
     b50:	33 e0       	ldi	r19, 0x03	; 3
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	bc 01       	movw	r22, r24
     b58:	cd 01       	movw	r24, r26
     b5a:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
     b5e:	dc 01       	movw	r26, r24
     b60:	cb 01       	movw	r24, r22
     b62:	2f ef       	ldi	r18, 0xFF	; 255
     b64:	3f e0       	ldi	r19, 0x0F	; 15
     b66:	40 e0       	ldi	r20, 0x00	; 0
     b68:	50 e0       	ldi	r21, 0x00	; 0
     b6a:	bc 01       	movw	r22, r24
     b6c:	cd 01       	movw	r24, r26
     b6e:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
     b72:	da 01       	movw	r26, r20
     b74:	c9 01       	movw	r24, r18
     b76:	9c 01       	movw	r18, r24
     b78:	22 53       	subi	r18, 0x32	; 50
     b7a:	30 40       	sbci	r19, 0x00	; 0
     b7c:	88 8d       	ldd	r24, Y+24	; 0x18
     b7e:	99 8d       	ldd	r25, Y+25	; 0x19
     b80:	fc 01       	movw	r30, r24
     b82:	20 83       	st	Z, r18
     b84:	31 83       	std	Z+1, r19	; 0x01
}
     b86:	6b 96       	adiw	r28, 0x1b	; 27
     b88:	cd bf       	out	0x3d, r28	; 61
     b8a:	de bf       	out	0x3e, r29	; 62
     b8c:	df 91       	pop	r29
     b8e:	cf 91       	pop	r28
     b90:	08 95       	ret

00000b92 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     b92:	0f 93       	push	r16
     b94:	1f 93       	push	r17
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	cd b7       	in	r28, 0x3d	; 61
     b9c:	de b7       	in	r29, 0x3e	; 62
     b9e:	a9 97       	sbiw	r28, 0x29	; 41
     ba0:	cd bf       	out	0x3d, r28	; 61
     ba2:	de bf       	out	0x3e, r29	; 62
     ba4:	8c a3       	lds	r24, 0x5c
     ba6:	9d a3       	lds	r25, 0x5d
     ba8:	6e a3       	lds	r22, 0x5e
     baa:	7f a3       	lds	r23, 0x5f
     bac:	48 a7       	lds	r20, 0x78
     bae:	59 a7       	lds	r21, 0x79
	
	uint32_t sum = 0;
     bb0:	19 82       	std	Y+1, r1	; 0x01
     bb2:	1a 82       	std	Y+2, r1	; 0x02
     bb4:	1b 82       	std	Y+3, r1	; 0x03
     bb6:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     bb8:	80 e0       	ldi	r24, 0x00	; 0
     bba:	90 e1       	ldi	r25, 0x10	; 16
     bbc:	a0 e0       	ldi	r26, 0x00	; 0
     bbe:	b0 e0       	ldi	r27, 0x00	; 0
     bc0:	8d 83       	std	Y+5, r24	; 0x05
     bc2:	9e 83       	std	Y+6, r25	; 0x06
     bc4:	af 83       	std	Y+7, r26	; 0x07
     bc6:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     bc8:	19 86       	std	Y+9, r1	; 0x09
     bca:	1a 86       	std	Y+10, r1	; 0x0a
     bcc:	1b 86       	std	Y+11, r1	; 0x0b
     bce:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     bd6:	84 e0       	ldi	r24, 0x04	; 4
     bd8:	60 e0       	ldi	r22, 0x00	; 0
     bda:	0e 94 07 33 	call	0x660e	; 0x660e <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     bde:	84 e0       	ldi	r24, 0x04	; 4
     be0:	60 e0       	ldi	r22, 0x00	; 0
     be2:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
     be6:	80 e0       	ldi	r24, 0x00	; 0
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	a8 ec       	ldi	r26, 0xC8	; 200
     bec:	b2 e4       	ldi	r27, 0x42	; 66
     bee:	8d 8b       	std	Y+21, r24	; 0x15
     bf0:	9e 8b       	std	Y+22, r25	; 0x16
     bf2:	af 8b       	std	Y+23, r26	; 0x17
     bf4:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     bf6:	6d 89       	ldd	r22, Y+21	; 0x15
     bf8:	7e 89       	ldd	r23, Y+22	; 0x16
     bfa:	8f 89       	ldd	r24, Y+23	; 0x17
     bfc:	98 8d       	ldd	r25, Y+24	; 0x18
     bfe:	20 e0       	ldi	r18, 0x00	; 0
     c00:	30 e0       	ldi	r19, 0x00	; 0
     c02:	4a ef       	ldi	r20, 0xFA	; 250
     c04:	55 e4       	ldi	r21, 0x45	; 69
     c06:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
     c0a:	dc 01       	movw	r26, r24
     c0c:	cb 01       	movw	r24, r22
     c0e:	89 8f       	std	Y+25, r24	; 0x19
     c10:	9a 8f       	std	Y+26, r25	; 0x1a
     c12:	ab 8f       	std	Y+27, r26	; 0x1b
     c14:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     c16:	11 e0       	ldi	r17, 0x01	; 1
     c18:	69 8d       	ldd	r22, Y+25	; 0x19
     c1a:	7a 8d       	ldd	r23, Y+26	; 0x1a
     c1c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     c1e:	9c 8d       	ldd	r25, Y+28	; 0x1c
     c20:	20 e0       	ldi	r18, 0x00	; 0
     c22:	30 e0       	ldi	r19, 0x00	; 0
     c24:	40 e8       	ldi	r20, 0x80	; 128
     c26:	5f e3       	ldi	r21, 0x3F	; 63
     c28:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
     c2c:	88 23       	and	r24, r24
     c2e:	0c f0       	brlt	.+2      	; 0xc32 <CO_collectBatt+0xa0>
     c30:	10 e0       	ldi	r17, 0x00	; 0
     c32:	11 23       	and	r17, r17
     c34:	29 f0       	breq	.+10     	; 0xc40 <CO_collectBatt+0xae>
		__ticks = 1;
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	8d 8f       	std	Y+29, r24	; 0x1d
     c3c:	9e 8f       	std	Y+30, r25	; 0x1e
     c3e:	46 c0       	rjmp	.+140    	; 0xccc <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     c40:	11 e0       	ldi	r17, 0x01	; 1
     c42:	69 8d       	ldd	r22, Y+25	; 0x19
     c44:	7a 8d       	ldd	r23, Y+26	; 0x1a
     c46:	8b 8d       	ldd	r24, Y+27	; 0x1b
     c48:	9c 8d       	ldd	r25, Y+28	; 0x1c
     c4a:	20 e0       	ldi	r18, 0x00	; 0
     c4c:	3f ef       	ldi	r19, 0xFF	; 255
     c4e:	4f e7       	ldi	r20, 0x7F	; 127
     c50:	57 e4       	ldi	r21, 0x47	; 71
     c52:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
     c56:	18 16       	cp	r1, r24
     c58:	0c f0       	brlt	.+2      	; 0xc5c <CO_collectBatt+0xca>
     c5a:	10 e0       	ldi	r17, 0x00	; 0
     c5c:	11 23       	and	r17, r17
     c5e:	61 f1       	breq	.+88     	; 0xcb8 <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c60:	6d 89       	ldd	r22, Y+21	; 0x15
     c62:	7e 89       	ldd	r23, Y+22	; 0x16
     c64:	8f 89       	ldd	r24, Y+23	; 0x17
     c66:	98 8d       	ldd	r25, Y+24	; 0x18
     c68:	20 e0       	ldi	r18, 0x00	; 0
     c6a:	30 e0       	ldi	r19, 0x00	; 0
     c6c:	40 e2       	ldi	r20, 0x20	; 32
     c6e:	51 e4       	ldi	r21, 0x41	; 65
     c70:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
     c74:	dc 01       	movw	r26, r24
     c76:	cb 01       	movw	r24, r22
     c78:	bc 01       	movw	r22, r24
     c7a:	cd 01       	movw	r24, r26
     c7c:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
     c80:	dc 01       	movw	r26, r24
     c82:	cb 01       	movw	r24, r22
     c84:	8d 8f       	std	Y+29, r24	; 0x1d
     c86:	9e 8f       	std	Y+30, r25	; 0x1e
     c88:	12 c0       	rjmp	.+36     	; 0xcae <CO_collectBatt+0x11c>
     c8a:	80 e2       	ldi	r24, 0x20	; 32
     c8c:	93 e0       	ldi	r25, 0x03	; 3
     c8e:	8f 8f       	std	Y+31, r24	; 0x1f
     c90:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c92:	8f 8d       	ldd	r24, Y+31	; 0x1f
     c94:	98 a1       	lds	r25, 0x48
     c96:	8c 01       	movw	r16, r24
     c98:	c8 01       	movw	r24, r16
     c9a:	01 97       	sbiw	r24, 0x01	; 1
     c9c:	f1 f7       	brne	.-4      	; 0xc9a <CO_collectBatt+0x108>
     c9e:	8c 01       	movw	r16, r24
     ca0:	0f 8f       	std	Y+31, r16	; 0x1f
     ca2:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ca4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ca6:	9e 8d       	ldd	r25, Y+30	; 0x1e
     ca8:	01 97       	sbiw	r24, 0x01	; 1
     caa:	8d 8f       	std	Y+29, r24	; 0x1d
     cac:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     cae:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cb0:	9e 8d       	ldd	r25, Y+30	; 0x1e
     cb2:	00 97       	sbiw	r24, 0x00	; 0
     cb4:	51 f7       	brne	.-44     	; 0xc8a <CO_collectBatt+0xf8>
     cb6:	17 c0       	rjmp	.+46     	; 0xce6 <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     cb8:	69 8d       	ldd	r22, Y+25	; 0x19
     cba:	7a 8d       	ldd	r23, Y+26	; 0x1a
     cbc:	8b 8d       	ldd	r24, Y+27	; 0x1b
     cbe:	9c 8d       	ldd	r25, Y+28	; 0x1c
     cc0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
     cc4:	dc 01       	movw	r26, r24
     cc6:	cb 01       	movw	r24, r22
     cc8:	8d 8f       	std	Y+29, r24	; 0x1d
     cca:	9e 8f       	std	Y+30, r25	; 0x1e
     ccc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cce:	9e 8d       	ldd	r25, Y+30	; 0x1e
     cd0:	89 a3       	lds	r24, 0x59
     cd2:	9a a3       	lds	r25, 0x5a
     cd4:	89 a1       	lds	r24, 0x49
     cd6:	9a a1       	lds	r25, 0x4a
     cd8:	8c 01       	movw	r16, r24
     cda:	f8 01       	movw	r30, r16
     cdc:	31 97       	sbiw	r30, 0x01	; 1
     cde:	f1 f7       	brne	.-4      	; 0xcdc <CO_collectBatt+0x14a>
     ce0:	8f 01       	movw	r16, r30
     ce2:	09 a3       	lds	r16, 0x59
     ce4:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     ce6:	80 e4       	ldi	r24, 0x40	; 64
     ce8:	92 e0       	ldi	r25, 0x02	; 2
     cea:	0e 94 8d 1a 	call	0x351a	; 0x351a <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     cee:	80 e4       	ldi	r24, 0x40	; 64
     cf0:	92 e0       	ldi	r25, 0x02	; 2
     cf2:	20 e4       	ldi	r18, 0x40	; 64
     cf4:	32 e0       	ldi	r19, 0x02	; 2
     cf6:	f9 01       	movw	r30, r18
     cf8:	21 81       	ldd	r18, Z+1	; 0x01
     cfa:	29 7e       	andi	r18, 0xE9	; 233
     cfc:	fc 01       	movw	r30, r24
     cfe:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     d00:	80 e4       	ldi	r24, 0x40	; 64
     d02:	92 e0       	ldi	r25, 0x02	; 2
     d04:	20 e4       	ldi	r18, 0x40	; 64
     d06:	32 e0       	ldi	r19, 0x02	; 2
     d08:	f9 01       	movw	r30, r18
     d0a:	24 81       	ldd	r18, Z+4	; 0x04
     d0c:	28 7f       	andi	r18, 0xF8	; 248
     d0e:	23 60       	ori	r18, 0x03	; 3
     d10:	fc 01       	movw	r30, r24
     d12:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     d14:	80 e4       	ldi	r24, 0x40	; 64
     d16:	92 e0       	ldi	r25, 0x02	; 2
     d18:	20 e4       	ldi	r18, 0x40	; 64
     d1a:	32 e0       	ldi	r19, 0x02	; 2
     d1c:	f9 01       	movw	r30, r18
     d1e:	22 81       	ldd	r18, Z+2	; 0x02
     d20:	2f 7c       	andi	r18, 0xCF	; 207
     d22:	fc 01       	movw	r30, r24
     d24:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     d26:	80 e6       	ldi	r24, 0x60	; 96
     d28:	92 e0       	ldi	r25, 0x02	; 2
     d2a:	20 e6       	ldi	r18, 0x60	; 96
     d2c:	32 e0       	ldi	r19, 0x02	; 2
     d2e:	f9 01       	movw	r30, r18
     d30:	20 81       	ld	r18, Z
     d32:	20 7e       	andi	r18, 0xE0	; 224
     d34:	21 60       	ori	r18, 0x01	; 1
     d36:	fc 01       	movw	r30, r24
     d38:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     d3a:	80 e6       	ldi	r24, 0x60	; 96
     d3c:	92 e0       	ldi	r25, 0x02	; 2
     d3e:	29 e0       	ldi	r18, 0x09	; 9
     d40:	fc 01       	movw	r30, r24
     d42:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     d44:	80 e4       	ldi	r24, 0x40	; 64
     d46:	92 e0       	ldi	r25, 0x02	; 2
     d48:	20 e4       	ldi	r18, 0x40	; 64
     d4a:	32 e0       	ldi	r19, 0x02	; 2
     d4c:	f9 01       	movw	r30, r18
     d4e:	20 81       	ld	r18, Z
     d50:	21 60       	ori	r18, 0x01	; 1
     d52:	fc 01       	movw	r30, r24
     d54:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     d56:	80 e4       	ldi	r24, 0x40	; 64
     d58:	92 e0       	ldi	r25, 0x02	; 2
     d5a:	0e 94 45 1c 	call	0x388a	; 0x388a <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     d5e:	80 e4       	ldi	r24, 0x40	; 64
     d60:	92 e0       	ldi	r25, 0x02	; 2
     d62:	60 e6       	ldi	r22, 0x60	; 96
     d64:	72 e0       	ldi	r23, 0x02	; 2
     d66:	40 e0       	ldi	r20, 0x00	; 0
     d68:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <ADC_Offset_Get_Unsigned>
     d6c:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     d6e:	80 e4       	ldi	r24, 0x40	; 64
     d70:	92 e0       	ldi	r25, 0x02	; 2
     d72:	20 e4       	ldi	r18, 0x40	; 64
     d74:	32 e0       	ldi	r19, 0x02	; 2
     d76:	f9 01       	movw	r30, r18
     d78:	20 81       	ld	r18, Z
     d7a:	2e 7f       	andi	r18, 0xFE	; 254
     d7c:	fc 01       	movw	r30, r24
     d7e:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     d80:	80 e6       	ldi	r24, 0x60	; 96
     d82:	92 e0       	ldi	r25, 0x02	; 2
     d84:	fc 01       	movw	r30, r24
     d86:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     d88:	80 e4       	ldi	r24, 0x40	; 64
     d8a:	92 e0       	ldi	r25, 0x02	; 2
     d8c:	20 e4       	ldi	r18, 0x40	; 64
     d8e:	32 e0       	ldi	r19, 0x02	; 2
     d90:	f9 01       	movw	r30, r18
     d92:	23 81       	ldd	r18, Z+3	; 0x03
     d94:	2f 73       	andi	r18, 0x3F	; 63
     d96:	fc 01       	movw	r30, r24
     d98:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     d9a:	80 e4       	ldi	r24, 0x40	; 64
     d9c:	92 e0       	ldi	r25, 0x02	; 2
     d9e:	20 e4       	ldi	r18, 0x40	; 64
     da0:	32 e0       	ldi	r19, 0x02	; 2
     da2:	f9 01       	movw	r30, r18
     da4:	20 81       	ld	r18, Z
     da6:	21 60       	ori	r18, 0x01	; 1
     da8:	fc 01       	movw	r30, r24
     daa:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     dac:	80 e4       	ldi	r24, 0x40	; 64
     dae:	92 e0       	ldi	r25, 0x02	; 2
     db0:	0e 94 45 1c 	call	0x388a	; 0x388a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     db4:	80 e4       	ldi	r24, 0x40	; 64
     db6:	92 e0       	ldi	r25, 0x02	; 2
     db8:	20 e4       	ldi	r18, 0x40	; 64
     dba:	32 e0       	ldi	r19, 0x02	; 2
     dbc:	f9 01       	movw	r30, r18
     dbe:	21 81       	ldd	r18, Z+1	; 0x01
     dc0:	28 60       	ori	r18, 0x08	; 8
     dc2:	fc 01       	movw	r30, r24
     dc4:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     dc6:	1d 86       	std	Y+13, r1	; 0x0d
     dc8:	1e 86       	std	Y+14, r1	; 0x0e
     dca:	56 c0       	rjmp	.+172    	; 0xe78 <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     dcc:	80 e6       	ldi	r24, 0x60	; 96
     dce:	92 e0       	ldi	r25, 0x02	; 2
     dd0:	fc 01       	movw	r30, r24
     dd2:	83 81       	ldd	r24, Z+3	; 0x03
     dd4:	88 2f       	mov	r24, r24
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	81 70       	andi	r24, 0x01	; 1
     dda:	90 70       	andi	r25, 0x00	; 0
     ddc:	00 97       	sbiw	r24, 0x00	; 0
     dde:	b1 f3       	breq	.-20     	; 0xdcc <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     de0:	2b a1       	lds	r18, 0x4b
     de2:	80 e6       	ldi	r24, 0x60	; 96
     de4:	92 e0       	ldi	r25, 0x02	; 2
     de6:	62 2f       	mov	r22, r18
     de8:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <ADC_ResultCh_GetWord_Signed>
     dec:	8f 87       	std	Y+15, r24	; 0x0f
     dee:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     df0:	8f 85       	ldd	r24, Y+15	; 0x0f
     df2:	98 89       	ldd	r25, Y+16	; 0x10
     df4:	cc 01       	movw	r24, r24
     df6:	a0 e0       	ldi	r26, 0x00	; 0
     df8:	b0 e0       	ldi	r27, 0x00	; 0
     dfa:	29 81       	ldd	r18, Y+1	; 0x01
     dfc:	3a 81       	ldd	r19, Y+2	; 0x02
     dfe:	4b 81       	ldd	r20, Y+3	; 0x03
     e00:	5c 81       	ldd	r21, Y+4	; 0x04
     e02:	82 0f       	add	r24, r18
     e04:	93 1f       	adc	r25, r19
     e06:	a4 1f       	adc	r26, r20
     e08:	b5 1f       	adc	r27, r21
     e0a:	89 83       	std	Y+1, r24	; 0x01
     e0c:	9a 83       	std	Y+2, r25	; 0x02
     e0e:	ab 83       	std	Y+3, r26	; 0x03
     e10:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     e12:	8f 85       	ldd	r24, Y+15	; 0x0f
     e14:	98 89       	ldd	r25, Y+16	; 0x10
     e16:	9c 01       	movw	r18, r24
     e18:	40 e0       	ldi	r20, 0x00	; 0
     e1a:	50 e0       	ldi	r21, 0x00	; 0
     e1c:	89 85       	ldd	r24, Y+9	; 0x09
     e1e:	9a 85       	ldd	r25, Y+10	; 0x0a
     e20:	ab 85       	ldd	r26, Y+11	; 0x0b
     e22:	bc 85       	ldd	r27, Y+12	; 0x0c
     e24:	82 17       	cp	r24, r18
     e26:	93 07       	cpc	r25, r19
     e28:	a4 07       	cpc	r26, r20
     e2a:	b5 07       	cpc	r27, r21
     e2c:	48 f4       	brcc	.+18     	; 0xe40 <CO_collectBatt+0x2ae>
     e2e:	8f 85       	ldd	r24, Y+15	; 0x0f
     e30:	98 89       	ldd	r25, Y+16	; 0x10
     e32:	cc 01       	movw	r24, r24
     e34:	a0 e0       	ldi	r26, 0x00	; 0
     e36:	b0 e0       	ldi	r27, 0x00	; 0
     e38:	89 87       	std	Y+9, r24	; 0x09
     e3a:	9a 87       	std	Y+10, r25	; 0x0a
     e3c:	ab 87       	std	Y+11, r26	; 0x0b
     e3e:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     e40:	8f 85       	ldd	r24, Y+15	; 0x0f
     e42:	98 89       	ldd	r25, Y+16	; 0x10
     e44:	9c 01       	movw	r18, r24
     e46:	40 e0       	ldi	r20, 0x00	; 0
     e48:	50 e0       	ldi	r21, 0x00	; 0
     e4a:	8d 81       	ldd	r24, Y+5	; 0x05
     e4c:	9e 81       	ldd	r25, Y+6	; 0x06
     e4e:	af 81       	ldd	r26, Y+7	; 0x07
     e50:	b8 85       	ldd	r27, Y+8	; 0x08
     e52:	28 17       	cp	r18, r24
     e54:	39 07       	cpc	r19, r25
     e56:	4a 07       	cpc	r20, r26
     e58:	5b 07       	cpc	r21, r27
     e5a:	48 f4       	brcc	.+18     	; 0xe6e <CO_collectBatt+0x2dc>
     e5c:	8f 85       	ldd	r24, Y+15	; 0x0f
     e5e:	98 89       	ldd	r25, Y+16	; 0x10
     e60:	cc 01       	movw	r24, r24
     e62:	a0 e0       	ldi	r26, 0x00	; 0
     e64:	b0 e0       	ldi	r27, 0x00	; 0
     e66:	8d 83       	std	Y+5, r24	; 0x05
     e68:	9e 83       	std	Y+6, r25	; 0x06
     e6a:	af 83       	std	Y+7, r26	; 0x07
     e6c:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     e6e:	8d 85       	ldd	r24, Y+13	; 0x0d
     e70:	9e 85       	ldd	r25, Y+14	; 0x0e
     e72:	01 96       	adiw	r24, 0x01	; 1
     e74:	8d 87       	std	Y+13, r24	; 0x0d
     e76:	9e 87       	std	Y+14, r25	; 0x0e
     e78:	8d 85       	ldd	r24, Y+13	; 0x0d
     e7a:	9e 85       	ldd	r25, Y+14	; 0x0e
     e7c:	f4 e0       	ldi	r31, 0x04	; 4
     e7e:	80 30       	cpi	r24, 0x00	; 0
     e80:	9f 07       	cpc	r25, r31
     e82:	08 f4       	brcc	.+2      	; 0xe86 <CO_collectBatt+0x2f4>
     e84:	a3 cf       	rjmp	.-186    	; 0xdcc <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     e86:	80 e4       	ldi	r24, 0x40	; 64
     e88:	92 e0       	ldi	r25, 0x02	; 2
     e8a:	20 e4       	ldi	r18, 0x40	; 64
     e8c:	32 e0       	ldi	r19, 0x02	; 2
     e8e:	f9 01       	movw	r30, r18
     e90:	21 81       	ldd	r18, Z+1	; 0x01
     e92:	27 7f       	andi	r18, 0xF7	; 247
     e94:	fc 01       	movw	r30, r24
     e96:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     e98:	80 e4       	ldi	r24, 0x40	; 64
     e9a:	92 e0       	ldi	r25, 0x02	; 2
     e9c:	20 e4       	ldi	r18, 0x40	; 64
     e9e:	32 e0       	ldi	r19, 0x02	; 2
     ea0:	f9 01       	movw	r30, r18
     ea2:	20 81       	ld	r18, Z
     ea4:	2e 7f       	andi	r18, 0xFE	; 254
     ea6:	fc 01       	movw	r30, r24
     ea8:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     eaa:	89 81       	ldd	r24, Y+1	; 0x01
     eac:	9a 81       	ldd	r25, Y+2	; 0x02
     eae:	ab 81       	ldd	r26, Y+3	; 0x03
     eb0:	bc 81       	ldd	r27, Y+4	; 0x04
     eb2:	07 2e       	mov	r0, r23
     eb4:	7a e0       	ldi	r23, 0x0A	; 10
     eb6:	b6 95       	lsr	r27
     eb8:	a7 95       	ror	r26
     eba:	97 95       	ror	r25
     ebc:	87 95       	ror	r24
     ebe:	7a 95       	dec	r23
     ec0:	d1 f7       	brne	.-12     	; 0xeb6 <CO_collectBatt+0x324>
     ec2:	70 2d       	mov	r23, r0
     ec4:	89 8b       	std	Y+17, r24	; 0x11
     ec6:	9a 8b       	std	Y+18, r25	; 0x12
     ec8:	ab 8b       	std	Y+19, r26	; 0x13
     eca:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     ecc:	84 e0       	ldi	r24, 0x04	; 4
     ece:	60 e0       	ldi	r22, 0x00	; 0
     ed0:	0e 94 6b 33 	call	0x66d6	; 0x66d6 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     ed4:	80 e0       	ldi	r24, 0x00	; 0
     ed6:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     eda:	89 89       	ldd	r24, Y+17	; 0x11
     edc:	9a 89       	ldd	r25, Y+18	; 0x12
     ede:	ab 89       	ldd	r26, Y+19	; 0x13
     ee0:	bc 89       	ldd	r27, Y+20	; 0x14
     ee2:	28 ee       	ldi	r18, 0xE8	; 232
     ee4:	33 e0       	ldi	r19, 0x03	; 3
     ee6:	40 e0       	ldi	r20, 0x00	; 0
     ee8:	50 e0       	ldi	r21, 0x00	; 0
     eea:	bc 01       	movw	r22, r24
     eec:	cd 01       	movw	r24, r26
     eee:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
     ef2:	dc 01       	movw	r26, r24
     ef4:	cb 01       	movw	r24, r22
     ef6:	2f ef       	ldi	r18, 0xFF	; 255
     ef8:	3f e0       	ldi	r19, 0x0F	; 15
     efa:	40 e0       	ldi	r20, 0x00	; 0
     efc:	50 e0       	ldi	r21, 0x00	; 0
     efe:	bc 01       	movw	r22, r24
     f00:	cd 01       	movw	r24, r26
     f02:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
     f06:	da 01       	movw	r26, r20
     f08:	c9 01       	movw	r24, r18
     f0a:	9c 01       	movw	r18, r24
     f0c:	22 53       	subi	r18, 0x32	; 50
     f0e:	30 40       	sbci	r19, 0x00	; 0
     f10:	8c a1       	lds	r24, 0x4c
     f12:	9d a1       	lds	r25, 0x4d
     f14:	fc 01       	movw	r30, r24
     f16:	20 83       	st	Z, r18
     f18:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     f1a:	89 85       	ldd	r24, Y+9	; 0x09
     f1c:	9a 85       	ldd	r25, Y+10	; 0x0a
     f1e:	ab 85       	ldd	r26, Y+11	; 0x0b
     f20:	bc 85       	ldd	r27, Y+12	; 0x0c
     f22:	28 ee       	ldi	r18, 0xE8	; 232
     f24:	33 e0       	ldi	r19, 0x03	; 3
     f26:	40 e0       	ldi	r20, 0x00	; 0
     f28:	50 e0       	ldi	r21, 0x00	; 0
     f2a:	bc 01       	movw	r22, r24
     f2c:	cd 01       	movw	r24, r26
     f2e:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
     f32:	dc 01       	movw	r26, r24
     f34:	cb 01       	movw	r24, r22
     f36:	2f ef       	ldi	r18, 0xFF	; 255
     f38:	3f e0       	ldi	r19, 0x0F	; 15
     f3a:	40 e0       	ldi	r20, 0x00	; 0
     f3c:	50 e0       	ldi	r21, 0x00	; 0
     f3e:	bc 01       	movw	r22, r24
     f40:	cd 01       	movw	r24, r26
     f42:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
     f46:	da 01       	movw	r26, r20
     f48:	c9 01       	movw	r24, r18
     f4a:	9c 01       	movw	r18, r24
     f4c:	22 53       	subi	r18, 0x32	; 50
     f4e:	30 40       	sbci	r19, 0x00	; 0
     f50:	88 a5       	lds	r24, 0x68
     f52:	99 a5       	lds	r25, 0x69
     f54:	fc 01       	movw	r30, r24
     f56:	20 83       	st	Z, r18
     f58:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     f5a:	8d 81       	ldd	r24, Y+5	; 0x05
     f5c:	9e 81       	ldd	r25, Y+6	; 0x06
     f5e:	af 81       	ldd	r26, Y+7	; 0x07
     f60:	b8 85       	ldd	r27, Y+8	; 0x08
     f62:	28 ee       	ldi	r18, 0xE8	; 232
     f64:	33 e0       	ldi	r19, 0x03	; 3
     f66:	40 e0       	ldi	r20, 0x00	; 0
     f68:	50 e0       	ldi	r21, 0x00	; 0
     f6a:	bc 01       	movw	r22, r24
     f6c:	cd 01       	movw	r24, r26
     f6e:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
     f72:	dc 01       	movw	r26, r24
     f74:	cb 01       	movw	r24, r22
     f76:	2f ef       	ldi	r18, 0xFF	; 255
     f78:	3f e0       	ldi	r19, 0x0F	; 15
     f7a:	40 e0       	ldi	r20, 0x00	; 0
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	bc 01       	movw	r22, r24
     f80:	cd 01       	movw	r24, r26
     f82:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
     f86:	da 01       	movw	r26, r20
     f88:	c9 01       	movw	r24, r18
     f8a:	9c 01       	movw	r18, r24
     f8c:	22 53       	subi	r18, 0x32	; 50
     f8e:	30 40       	sbci	r19, 0x00	; 0
     f90:	8e a1       	lds	r24, 0x4e
     f92:	9f a1       	lds	r25, 0x4f
     f94:	fc 01       	movw	r30, r24
     f96:	20 83       	st	Z, r18
     f98:	31 83       	std	Z+1, r19	; 0x01
}
     f9a:	a9 96       	adiw	r28, 0x29	; 41
     f9c:	cd bf       	out	0x3d, r28	; 61
     f9e:	de bf       	out	0x3e, r29	; 62
     fa0:	df 91       	pop	r29
     fa2:	cf 91       	pop	r28
     fa4:	1f 91       	pop	r17
     fa6:	0f 91       	pop	r16
     fa8:	08 95       	ret

00000faa <ADCPower>:

void ADCPower(uint8_t on) {
     faa:	0f 93       	push	r16
     fac:	1f 93       	push	r17
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	cd b7       	in	r28, 0x3d	; 61
     fb4:	de b7       	in	r29, 0x3e	; 62
     fb6:	2f 97       	sbiw	r28, 0x0f	; 15
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	de bf       	out	0x3e, r29	; 62
     fbc:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
     fbe:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc0:	88 23       	and	r24, r24
     fc2:	09 f4       	brne	.+2      	; 0xfc6 <ADCPower+0x1c>
     fc4:	ce c0       	rjmp	.+412    	; 0x1162 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     fc6:	80 e0       	ldi	r24, 0x00	; 0
     fc8:	96 e0       	ldi	r25, 0x06	; 6
     fca:	2e ed       	ldi	r18, 0xDE	; 222
     fcc:	fc 01       	movw	r30, r24
     fce:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     fd0:	80 e2       	ldi	r24, 0x20	; 32
     fd2:	96 e0       	ldi	r25, 0x06	; 6
     fd4:	2e e0       	ldi	r18, 0x0E	; 14
     fd6:	fc 01       	movw	r30, r24
     fd8:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     fda:	80 e4       	ldi	r24, 0x40	; 64
     fdc:	96 e0       	ldi	r25, 0x06	; 6
     fde:	23 e0       	ldi	r18, 0x03	; 3
     fe0:	fc 01       	movw	r30, r24
     fe2:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     fe4:	80 e8       	ldi	r24, 0x80	; 128
     fe6:	96 e0       	ldi	r25, 0x06	; 6
     fe8:	20 e1       	ldi	r18, 0x10	; 16
     fea:	fc 01       	movw	r30, r24
     fec:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     fee:	80 ea       	ldi	r24, 0xA0	; 160
     ff0:	96 e0       	ldi	r25, 0x06	; 6
     ff2:	2e e0       	ldi	r18, 0x0E	; 14
     ff4:	fc 01       	movw	r30, r24
     ff6:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     ff8:	80 e0       	ldi	r24, 0x00	; 0
     ffa:	96 e0       	ldi	r25, 0x06	; 6
     ffc:	2e e9       	ldi	r18, 0x9E	; 158
     ffe:	fc 01       	movw	r30, r24
    1000:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
    1002:	80 e2       	ldi	r24, 0x20	; 32
    1004:	96 e0       	ldi	r25, 0x06	; 6
    1006:	28 e0       	ldi	r18, 0x08	; 8
    1008:	fc 01       	movw	r30, r24
    100a:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
    100c:	80 e4       	ldi	r24, 0x40	; 64
    100e:	96 e0       	ldi	r25, 0x06	; 6
    1010:	23 e0       	ldi	r18, 0x03	; 3
    1012:	fc 01       	movw	r30, r24
    1014:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
    1016:	80 e8       	ldi	r24, 0x80	; 128
    1018:	96 e0       	ldi	r25, 0x06	; 6
    101a:	20 e1       	ldi	r18, 0x10	; 16
    101c:	fc 01       	movw	r30, r24
    101e:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
    1020:	80 ea       	ldi	r24, 0xA0	; 160
    1022:	96 e0       	ldi	r25, 0x06	; 6
    1024:	2e e0       	ldi	r18, 0x0E	; 14
    1026:	fc 01       	movw	r30, r24
    1028:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
    102a:	10 92 80 50 	sts	0x5080, r1
    102e:	80 e0       	ldi	r24, 0x00	; 0
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	a8 ec       	ldi	r26, 0xC8	; 200
    1034:	b2 e4       	ldi	r27, 0x42	; 66
    1036:	89 83       	std	Y+1, r24	; 0x01
    1038:	9a 83       	std	Y+2, r25	; 0x02
    103a:	ab 83       	std	Y+3, r26	; 0x03
    103c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    103e:	69 81       	ldd	r22, Y+1	; 0x01
    1040:	7a 81       	ldd	r23, Y+2	; 0x02
    1042:	8b 81       	ldd	r24, Y+3	; 0x03
    1044:	9c 81       	ldd	r25, Y+4	; 0x04
    1046:	20 e0       	ldi	r18, 0x00	; 0
    1048:	30 e0       	ldi	r19, 0x00	; 0
    104a:	4a ef       	ldi	r20, 0xFA	; 250
    104c:	55 e4       	ldi	r21, 0x45	; 69
    104e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    1052:	dc 01       	movw	r26, r24
    1054:	cb 01       	movw	r24, r22
    1056:	8d 83       	std	Y+5, r24	; 0x05
    1058:	9e 83       	std	Y+6, r25	; 0x06
    105a:	af 83       	std	Y+7, r26	; 0x07
    105c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    105e:	11 e0       	ldi	r17, 0x01	; 1
    1060:	6d 81       	ldd	r22, Y+5	; 0x05
    1062:	7e 81       	ldd	r23, Y+6	; 0x06
    1064:	8f 81       	ldd	r24, Y+7	; 0x07
    1066:	98 85       	ldd	r25, Y+8	; 0x08
    1068:	20 e0       	ldi	r18, 0x00	; 0
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	40 e8       	ldi	r20, 0x80	; 128
    106e:	5f e3       	ldi	r21, 0x3F	; 63
    1070:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    1074:	88 23       	and	r24, r24
    1076:	0c f0       	brlt	.+2      	; 0x107a <ADCPower+0xd0>
    1078:	10 e0       	ldi	r17, 0x00	; 0
    107a:	11 23       	and	r17, r17
    107c:	29 f0       	breq	.+10     	; 0x1088 <ADCPower+0xde>
		__ticks = 1;
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	89 87       	std	Y+9, r24	; 0x09
    1084:	9a 87       	std	Y+10, r25	; 0x0a
    1086:	46 c0       	rjmp	.+140    	; 0x1114 <ADCPower+0x16a>
	else if (__tmp > 65535)
    1088:	11 e0       	ldi	r17, 0x01	; 1
    108a:	6d 81       	ldd	r22, Y+5	; 0x05
    108c:	7e 81       	ldd	r23, Y+6	; 0x06
    108e:	8f 81       	ldd	r24, Y+7	; 0x07
    1090:	98 85       	ldd	r25, Y+8	; 0x08
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	3f ef       	ldi	r19, 0xFF	; 255
    1096:	4f e7       	ldi	r20, 0x7F	; 127
    1098:	57 e4       	ldi	r21, 0x47	; 71
    109a:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    109e:	18 16       	cp	r1, r24
    10a0:	0c f0       	brlt	.+2      	; 0x10a4 <ADCPower+0xfa>
    10a2:	10 e0       	ldi	r17, 0x00	; 0
    10a4:	11 23       	and	r17, r17
    10a6:	61 f1       	breq	.+88     	; 0x1100 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10a8:	69 81       	ldd	r22, Y+1	; 0x01
    10aa:	7a 81       	ldd	r23, Y+2	; 0x02
    10ac:	8b 81       	ldd	r24, Y+3	; 0x03
    10ae:	9c 81       	ldd	r25, Y+4	; 0x04
    10b0:	20 e0       	ldi	r18, 0x00	; 0
    10b2:	30 e0       	ldi	r19, 0x00	; 0
    10b4:	40 e2       	ldi	r20, 0x20	; 32
    10b6:	51 e4       	ldi	r21, 0x41	; 65
    10b8:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    10bc:	dc 01       	movw	r26, r24
    10be:	cb 01       	movw	r24, r22
    10c0:	bc 01       	movw	r22, r24
    10c2:	cd 01       	movw	r24, r26
    10c4:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    10c8:	dc 01       	movw	r26, r24
    10ca:	cb 01       	movw	r24, r22
    10cc:	89 87       	std	Y+9, r24	; 0x09
    10ce:	9a 87       	std	Y+10, r25	; 0x0a
    10d0:	12 c0       	rjmp	.+36     	; 0x10f6 <ADCPower+0x14c>
    10d2:	80 e2       	ldi	r24, 0x20	; 32
    10d4:	93 e0       	ldi	r25, 0x03	; 3
    10d6:	8b 87       	std	Y+11, r24	; 0x0b
    10d8:	9c 87       	std	Y+12, r25	; 0x0c
    10da:	8b 85       	ldd	r24, Y+11	; 0x0b
    10dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    10de:	8c 01       	movw	r16, r24
    10e0:	c8 01       	movw	r24, r16
    10e2:	01 97       	sbiw	r24, 0x01	; 1
    10e4:	f1 f7       	brne	.-4      	; 0x10e2 <ADCPower+0x138>
    10e6:	8c 01       	movw	r16, r24
    10e8:	0b 87       	std	Y+11, r16	; 0x0b
    10ea:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    10ec:	89 85       	ldd	r24, Y+9	; 0x09
    10ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    10f0:	01 97       	sbiw	r24, 0x01	; 1
    10f2:	89 87       	std	Y+9, r24	; 0x09
    10f4:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    10f6:	89 85       	ldd	r24, Y+9	; 0x09
    10f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    10fa:	00 97       	sbiw	r24, 0x00	; 0
    10fc:	51 f7       	brne	.-44     	; 0x10d2 <ADCPower+0x128>
    10fe:	17 c0       	rjmp	.+46     	; 0x112e <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1100:	6d 81       	ldd	r22, Y+5	; 0x05
    1102:	7e 81       	ldd	r23, Y+6	; 0x06
    1104:	8f 81       	ldd	r24, Y+7	; 0x07
    1106:	98 85       	ldd	r25, Y+8	; 0x08
    1108:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    110c:	dc 01       	movw	r26, r24
    110e:	cb 01       	movw	r24, r22
    1110:	89 87       	std	Y+9, r24	; 0x09
    1112:	9a 87       	std	Y+10, r25	; 0x0a
    1114:	89 85       	ldd	r24, Y+9	; 0x09
    1116:	9a 85       	ldd	r25, Y+10	; 0x0a
    1118:	8d 87       	std	Y+13, r24	; 0x0d
    111a:	9e 87       	std	Y+14, r25	; 0x0e
    111c:	8d 85       	ldd	r24, Y+13	; 0x0d
    111e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1120:	8c 01       	movw	r16, r24
    1122:	f8 01       	movw	r30, r16
    1124:	31 97       	sbiw	r30, 0x01	; 1
    1126:	f1 f7       	brne	.-4      	; 0x1124 <ADCPower+0x17a>
    1128:	8f 01       	movw	r16, r30
    112a:	0d 87       	std	Y+13, r16	; 0x0d
    112c:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
    112e:	80 e4       	ldi	r24, 0x40	; 64
    1130:	96 e0       	ldi	r25, 0x06	; 6
    1132:	20 e4       	ldi	r18, 0x40	; 64
    1134:	fc 01       	movw	r30, r24
    1136:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
    1138:	80 e0       	ldi	r24, 0x00	; 0
    113a:	80 93 81 50 	sts	0x5081, r24
    113e:	80 93 d5 50 	sts	0x50D5, r24
    1142:	80 93 d5 23 	sts	0x23D5, r24
    1146:	80 93 79 50 	sts	0x5079, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
    114a:	8f ef       	ldi	r24, 0xFF	; 255
    114c:	61 e0       	ldi	r22, 0x01	; 1
    114e:	0e 94 07 33 	call	0x660e	; 0x660e <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
    1152:	8f ef       	ldi	r24, 0xFF	; 255
    1154:	61 e0       	ldi	r22, 0x01	; 1
    1156:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
    115a:	8f ef       	ldi	r24, 0xFF	; 255
    115c:	0e 94 2a 0a 	call	0x1454	; 0x1454 <set_filter>
    1160:	42 c0       	rjmp	.+132    	; 0x11e6 <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
    1162:	80 e0       	ldi	r24, 0x00	; 0
    1164:	96 e0       	ldi	r25, 0x06	; 6
    1166:	2e ed       	ldi	r18, 0xDE	; 222
    1168:	fc 01       	movw	r30, r24
    116a:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
    116c:	80 e2       	ldi	r24, 0x20	; 32
    116e:	96 e0       	ldi	r25, 0x06	; 6
    1170:	2e e0       	ldi	r18, 0x0E	; 14
    1172:	fc 01       	movw	r30, r24
    1174:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
    1176:	80 e4       	ldi	r24, 0x40	; 64
    1178:	96 e0       	ldi	r25, 0x06	; 6
    117a:	23 e0       	ldi	r18, 0x03	; 3
    117c:	fc 01       	movw	r30, r24
    117e:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
    1180:	80 e8       	ldi	r24, 0x80	; 128
    1182:	96 e0       	ldi	r25, 0x06	; 6
    1184:	20 e1       	ldi	r18, 0x10	; 16
    1186:	fc 01       	movw	r30, r24
    1188:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
    118a:	80 ea       	ldi	r24, 0xA0	; 160
    118c:	96 e0       	ldi	r25, 0x06	; 6
    118e:	2e e0       	ldi	r18, 0x0E	; 14
    1190:	fc 01       	movw	r30, r24
    1192:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
    1194:	80 e0       	ldi	r24, 0x00	; 0
    1196:	96 e0       	ldi	r25, 0x06	; 6
    1198:	2e ed       	ldi	r18, 0xDE	; 222
    119a:	fc 01       	movw	r30, r24
    119c:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
    119e:	80 e2       	ldi	r24, 0x20	; 32
    11a0:	96 e0       	ldi	r25, 0x06	; 6
    11a2:	2e e0       	ldi	r18, 0x0E	; 14
    11a4:	fc 01       	movw	r30, r24
    11a6:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
    11a8:	80 e4       	ldi	r24, 0x40	; 64
    11aa:	96 e0       	ldi	r25, 0x06	; 6
    11ac:	23 e0       	ldi	r18, 0x03	; 3
    11ae:	fc 01       	movw	r30, r24
    11b0:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
    11b2:	80 e8       	ldi	r24, 0x80	; 128
    11b4:	96 e0       	ldi	r25, 0x06	; 6
    11b6:	20 e1       	ldi	r18, 0x10	; 16
    11b8:	fc 01       	movw	r30, r24
    11ba:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
    11bc:	80 ea       	ldi	r24, 0xA0	; 160
    11be:	96 e0       	ldi	r25, 0x06	; 6
    11c0:	2e e0       	ldi	r18, 0x0E	; 14
    11c2:	fc 01       	movw	r30, r24
    11c4:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
    11c6:	80 e4       	ldi	r24, 0x40	; 64
    11c8:	96 e0       	ldi	r25, 0x06	; 6
    11ca:	20 e4       	ldi	r18, 0x40	; 64
    11cc:	fc 01       	movw	r30, r24
    11ce:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
    11d0:	80 e0       	ldi	r24, 0x00	; 0
    11d2:	80 93 81 50 	sts	0x5081, r24
    11d6:	80 93 d5 50 	sts	0x50D5, r24
    11da:	80 93 d5 23 	sts	0x23D5, r24
    11de:	80 93 79 50 	sts	0x5079, r24
		channelStatus = 0x00;
    11e2:	10 92 80 50 	sts	0x5080, r1
		
	}
}
    11e6:	2f 96       	adiw	r28, 0x0f	; 15
    11e8:	cd bf       	out	0x3d, r28	; 61
    11ea:	de bf       	out	0x3e, r29	; 62
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	1f 91       	pop	r17
    11f2:	0f 91       	pop	r16
    11f4:	08 95       	ret

000011f6 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    11f6:	0f 93       	push	r16
    11f8:	1f 93       	push	r17
    11fa:	cf 93       	push	r28
    11fc:	df 93       	push	r29
    11fe:	cd b7       	in	r28, 0x3d	; 61
    1200:	de b7       	in	r29, 0x3e	; 62
    1202:	6a 97       	sbiw	r28, 0x1a	; 26
    1204:	cd bf       	out	0x3d, r28	; 61
    1206:	de bf       	out	0x3e, r29	; 62
    1208:	89 8f       	std	Y+25, r24	; 0x19
    120a:	6a 8f       	std	Y+26, r22	; 0x1a
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    120c:	89 8d       	ldd	r24, Y+25	; 0x19
    120e:	28 2f       	mov	r18, r24
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	81 e0       	ldi	r24, 0x01	; 1
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	02 c0       	rjmp	.+4      	; 0x121c <set_ampGain+0x26>
    1218:	88 0f       	add	r24, r24
    121a:	99 1f       	adc	r25, r25
    121c:	2a 95       	dec	r18
    121e:	e2 f7       	brpl	.-8      	; 0x1218 <set_ampGain+0x22>
    1220:	61 e0       	ldi	r22, 0x01	; 1
    1222:	0e 94 36 34 	call	0x686c	; 0x686c <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    1226:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1228:	88 2f       	mov	r24, r24
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	81 70       	andi	r24, 0x01	; 1
    122e:	90 70       	andi	r25, 0x00	; 0
    1230:	88 23       	and	r24, r24
    1232:	31 f0       	breq	.+12     	; 0x1240 <set_ampGain+0x4a>
    1234:	80 e0       	ldi	r24, 0x00	; 0
    1236:	96 e0       	ldi	r25, 0x06	; 6
    1238:	20 e4       	ldi	r18, 0x40	; 64
    123a:	fc 01       	movw	r30, r24
    123c:	25 83       	std	Z+5, r18	; 0x05
    123e:	05 c0       	rjmp	.+10     	; 0x124a <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
    1240:	80 e0       	ldi	r24, 0x00	; 0
    1242:	96 e0       	ldi	r25, 0x06	; 6
    1244:	20 e4       	ldi	r18, 0x40	; 64
    1246:	fc 01       	movw	r30, r24
    1248:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    124a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    124c:	88 2f       	mov	r24, r24
    124e:	90 e0       	ldi	r25, 0x00	; 0
    1250:	82 70       	andi	r24, 0x02	; 2
    1252:	90 70       	andi	r25, 0x00	; 0
    1254:	00 97       	sbiw	r24, 0x00	; 0
    1256:	31 f0       	breq	.+12     	; 0x1264 <set_ampGain+0x6e>
    1258:	80 e2       	ldi	r24, 0x20	; 32
    125a:	96 e0       	ldi	r25, 0x06	; 6
    125c:	22 e0       	ldi	r18, 0x02	; 2
    125e:	fc 01       	movw	r30, r24
    1260:	25 83       	std	Z+5, r18	; 0x05
    1262:	05 c0       	rjmp	.+10     	; 0x126e <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
    1264:	80 e2       	ldi	r24, 0x20	; 32
    1266:	96 e0       	ldi	r25, 0x06	; 6
    1268:	22 e0       	ldi	r18, 0x02	; 2
    126a:	fc 01       	movw	r30, r24
    126c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    126e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1270:	88 2f       	mov	r24, r24
    1272:	90 e0       	ldi	r25, 0x00	; 0
    1274:	84 70       	andi	r24, 0x04	; 4
    1276:	90 70       	andi	r25, 0x00	; 0
    1278:	00 97       	sbiw	r24, 0x00	; 0
    127a:	31 f0       	breq	.+12     	; 0x1288 <set_ampGain+0x92>
    127c:	80 e2       	ldi	r24, 0x20	; 32
    127e:	96 e0       	ldi	r25, 0x06	; 6
    1280:	24 e0       	ldi	r18, 0x04	; 4
    1282:	fc 01       	movw	r30, r24
    1284:	25 83       	std	Z+5, r18	; 0x05
    1286:	05 c0       	rjmp	.+10     	; 0x1292 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
    1288:	80 e2       	ldi	r24, 0x20	; 32
    128a:	96 e0       	ldi	r25, 0x06	; 6
    128c:	24 e0       	ldi	r18, 0x04	; 4
    128e:	fc 01       	movw	r30, r24
    1290:	26 83       	std	Z+6, r18	; 0x06
    1292:	80 e0       	ldi	r24, 0x00	; 0
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	a0 e8       	ldi	r26, 0x80	; 128
    1298:	bf e3       	ldi	r27, 0x3F	; 63
    129a:	89 83       	std	Y+1, r24	; 0x01
    129c:	9a 83       	std	Y+2, r25	; 0x02
    129e:	ab 83       	std	Y+3, r26	; 0x03
    12a0:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    12a2:	69 81       	ldd	r22, Y+1	; 0x01
    12a4:	7a 81       	ldd	r23, Y+2	; 0x02
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	9c 81       	ldd	r25, Y+4	; 0x04
    12aa:	2b ea       	ldi	r18, 0xAB	; 171
    12ac:	3a ea       	ldi	r19, 0xAA	; 170
    12ae:	4a e2       	ldi	r20, 0x2A	; 42
    12b0:	51 e4       	ldi	r21, 0x41	; 65
    12b2:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    12b6:	dc 01       	movw	r26, r24
    12b8:	cb 01       	movw	r24, r22
    12ba:	8d 83       	std	Y+5, r24	; 0x05
    12bc:	9e 83       	std	Y+6, r25	; 0x06
    12be:	af 83       	std	Y+7, r26	; 0x07
    12c0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    12c2:	11 e0       	ldi	r17, 0x01	; 1
    12c4:	6d 81       	ldd	r22, Y+5	; 0x05
    12c6:	7e 81       	ldd	r23, Y+6	; 0x06
    12c8:	8f 81       	ldd	r24, Y+7	; 0x07
    12ca:	98 85       	ldd	r25, Y+8	; 0x08
    12cc:	20 e0       	ldi	r18, 0x00	; 0
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	40 e8       	ldi	r20, 0x80	; 128
    12d2:	5f e3       	ldi	r21, 0x3F	; 63
    12d4:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    12d8:	88 23       	and	r24, r24
    12da:	0c f0       	brlt	.+2      	; 0x12de <set_ampGain+0xe8>
    12dc:	10 e0       	ldi	r17, 0x00	; 0
    12de:	11 23       	and	r17, r17
    12e0:	19 f0       	breq	.+6      	; 0x12e8 <set_ampGain+0xf2>
		__ticks = 1;
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	89 87       	std	Y+9, r24	; 0x09
    12e6:	a3 c0       	rjmp	.+326    	; 0x142e <set_ampGain+0x238>
	else if (__tmp > 255)
    12e8:	11 e0       	ldi	r17, 0x01	; 1
    12ea:	6d 81       	ldd	r22, Y+5	; 0x05
    12ec:	7e 81       	ldd	r23, Y+6	; 0x06
    12ee:	8f 81       	ldd	r24, Y+7	; 0x07
    12f0:	98 85       	ldd	r25, Y+8	; 0x08
    12f2:	20 e0       	ldi	r18, 0x00	; 0
    12f4:	30 e0       	ldi	r19, 0x00	; 0
    12f6:	4f e7       	ldi	r20, 0x7F	; 127
    12f8:	53 e4       	ldi	r21, 0x43	; 67
    12fa:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    12fe:	18 16       	cp	r1, r24
    1300:	0c f0       	brlt	.+2      	; 0x1304 <set_ampGain+0x10e>
    1302:	10 e0       	ldi	r17, 0x00	; 0
    1304:	11 23       	and	r17, r17
    1306:	09 f4       	brne	.+2      	; 0x130a <set_ampGain+0x114>
    1308:	89 c0       	rjmp	.+274    	; 0x141c <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
    130a:	69 81       	ldd	r22, Y+1	; 0x01
    130c:	7a 81       	ldd	r23, Y+2	; 0x02
    130e:	8b 81       	ldd	r24, Y+3	; 0x03
    1310:	9c 81       	ldd	r25, Y+4	; 0x04
    1312:	20 e0       	ldi	r18, 0x00	; 0
    1314:	30 e0       	ldi	r19, 0x00	; 0
    1316:	4a e7       	ldi	r20, 0x7A	; 122
    1318:	54 e4       	ldi	r21, 0x44	; 68
    131a:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    131e:	dc 01       	movw	r26, r24
    1320:	cb 01       	movw	r24, r22
    1322:	8a 87       	std	Y+10, r24	; 0x0a
    1324:	9b 87       	std	Y+11, r25	; 0x0b
    1326:	ac 87       	std	Y+12, r26	; 0x0c
    1328:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    132a:	6a 85       	ldd	r22, Y+10	; 0x0a
    132c:	7b 85       	ldd	r23, Y+11	; 0x0b
    132e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1330:	9d 85       	ldd	r25, Y+13	; 0x0d
    1332:	20 e0       	ldi	r18, 0x00	; 0
    1334:	30 e0       	ldi	r19, 0x00	; 0
    1336:	4a ef       	ldi	r20, 0xFA	; 250
    1338:	55 e4       	ldi	r21, 0x45	; 69
    133a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    133e:	dc 01       	movw	r26, r24
    1340:	cb 01       	movw	r24, r22
    1342:	8e 87       	std	Y+14, r24	; 0x0e
    1344:	9f 87       	std	Y+15, r25	; 0x0f
    1346:	a8 8b       	std	Y+16, r26	; 0x10
    1348:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    134a:	11 e0       	ldi	r17, 0x01	; 1
    134c:	6e 85       	ldd	r22, Y+14	; 0x0e
    134e:	7f 85       	ldd	r23, Y+15	; 0x0f
    1350:	88 89       	ldd	r24, Y+16	; 0x10
    1352:	99 89       	ldd	r25, Y+17	; 0x11
    1354:	20 e0       	ldi	r18, 0x00	; 0
    1356:	30 e0       	ldi	r19, 0x00	; 0
    1358:	40 e8       	ldi	r20, 0x80	; 128
    135a:	5f e3       	ldi	r21, 0x3F	; 63
    135c:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    1360:	88 23       	and	r24, r24
    1362:	0c f0       	brlt	.+2      	; 0x1366 <set_ampGain+0x170>
    1364:	10 e0       	ldi	r17, 0x00	; 0
    1366:	11 23       	and	r17, r17
    1368:	29 f0       	breq	.+10     	; 0x1374 <set_ampGain+0x17e>
		__ticks = 1;
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	8a 8b       	std	Y+18, r24	; 0x12
    1370:	9b 8b       	std	Y+19, r25	; 0x13
    1372:	46 c0       	rjmp	.+140    	; 0x1400 <set_ampGain+0x20a>
	else if (__tmp > 65535)
    1374:	11 e0       	ldi	r17, 0x01	; 1
    1376:	6e 85       	ldd	r22, Y+14	; 0x0e
    1378:	7f 85       	ldd	r23, Y+15	; 0x0f
    137a:	88 89       	ldd	r24, Y+16	; 0x10
    137c:	99 89       	ldd	r25, Y+17	; 0x11
    137e:	20 e0       	ldi	r18, 0x00	; 0
    1380:	3f ef       	ldi	r19, 0xFF	; 255
    1382:	4f e7       	ldi	r20, 0x7F	; 127
    1384:	57 e4       	ldi	r21, 0x47	; 71
    1386:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    138a:	18 16       	cp	r1, r24
    138c:	0c f0       	brlt	.+2      	; 0x1390 <set_ampGain+0x19a>
    138e:	10 e0       	ldi	r17, 0x00	; 0
    1390:	11 23       	and	r17, r17
    1392:	61 f1       	breq	.+88     	; 0x13ec <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1394:	6a 85       	ldd	r22, Y+10	; 0x0a
    1396:	7b 85       	ldd	r23, Y+11	; 0x0b
    1398:	8c 85       	ldd	r24, Y+12	; 0x0c
    139a:	9d 85       	ldd	r25, Y+13	; 0x0d
    139c:	20 e0       	ldi	r18, 0x00	; 0
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	40 e2       	ldi	r20, 0x20	; 32
    13a2:	51 e4       	ldi	r21, 0x41	; 65
    13a4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    13a8:	dc 01       	movw	r26, r24
    13aa:	cb 01       	movw	r24, r22
    13ac:	bc 01       	movw	r22, r24
    13ae:	cd 01       	movw	r24, r26
    13b0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    13b4:	dc 01       	movw	r26, r24
    13b6:	cb 01       	movw	r24, r22
    13b8:	8a 8b       	std	Y+18, r24	; 0x12
    13ba:	9b 8b       	std	Y+19, r25	; 0x13
    13bc:	12 c0       	rjmp	.+36     	; 0x13e2 <set_ampGain+0x1ec>
    13be:	80 e2       	ldi	r24, 0x20	; 32
    13c0:	93 e0       	ldi	r25, 0x03	; 3
    13c2:	8c 8b       	std	Y+20, r24	; 0x14
    13c4:	9d 8b       	std	Y+21, r25	; 0x15
    13c6:	8c 89       	ldd	r24, Y+20	; 0x14
    13c8:	9d 89       	ldd	r25, Y+21	; 0x15
    13ca:	8c 01       	movw	r16, r24
    13cc:	c8 01       	movw	r24, r16
    13ce:	01 97       	sbiw	r24, 0x01	; 1
    13d0:	f1 f7       	brne	.-4      	; 0x13ce <set_ampGain+0x1d8>
    13d2:	8c 01       	movw	r16, r24
    13d4:	0c 8b       	std	Y+20, r16	; 0x14
    13d6:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    13d8:	8a 89       	ldd	r24, Y+18	; 0x12
    13da:	9b 89       	ldd	r25, Y+19	; 0x13
    13dc:	01 97       	sbiw	r24, 0x01	; 1
    13de:	8a 8b       	std	Y+18, r24	; 0x12
    13e0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13e2:	8a 89       	ldd	r24, Y+18	; 0x12
    13e4:	9b 89       	ldd	r25, Y+19	; 0x13
    13e6:	00 97       	sbiw	r24, 0x00	; 0
    13e8:	51 f7       	brne	.-44     	; 0x13be <set_ampGain+0x1c8>
    13ea:	28 c0       	rjmp	.+80     	; 0x143c <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    13ec:	6e 85       	ldd	r22, Y+14	; 0x0e
    13ee:	7f 85       	ldd	r23, Y+15	; 0x0f
    13f0:	88 89       	ldd	r24, Y+16	; 0x10
    13f2:	99 89       	ldd	r25, Y+17	; 0x11
    13f4:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    13f8:	dc 01       	movw	r26, r24
    13fa:	cb 01       	movw	r24, r22
    13fc:	8a 8b       	std	Y+18, r24	; 0x12
    13fe:	9b 8b       	std	Y+19, r25	; 0x13
    1400:	8a 89       	ldd	r24, Y+18	; 0x12
    1402:	9b 89       	ldd	r25, Y+19	; 0x13
    1404:	8e 8b       	std	Y+22, r24	; 0x16
    1406:	9f 8b       	std	Y+23, r25	; 0x17
    1408:	8e 89       	ldd	r24, Y+22	; 0x16
    140a:	9f 89       	ldd	r25, Y+23	; 0x17
    140c:	8c 01       	movw	r16, r24
    140e:	f8 01       	movw	r30, r16
    1410:	31 97       	sbiw	r30, 0x01	; 1
    1412:	f1 f7       	brne	.-4      	; 0x1410 <set_ampGain+0x21a>
    1414:	8f 01       	movw	r16, r30
    1416:	0e 8b       	std	Y+22, r16	; 0x16
    1418:	1f 8b       	std	Y+23, r17	; 0x17
    141a:	10 c0       	rjmp	.+32     	; 0x143c <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    141c:	6d 81       	ldd	r22, Y+5	; 0x05
    141e:	7e 81       	ldd	r23, Y+6	; 0x06
    1420:	8f 81       	ldd	r24, Y+7	; 0x07
    1422:	98 85       	ldd	r25, Y+8	; 0x08
    1424:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    1428:	dc 01       	movw	r26, r24
    142a:	cb 01       	movw	r24, r22
    142c:	89 87       	std	Y+9, r24	; 0x09
    142e:	89 85       	ldd	r24, Y+9	; 0x09
    1430:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1432:	88 8d       	ldd	r24, Y+24	; 0x18
    1434:	18 2f       	mov	r17, r24
    1436:	1a 95       	dec	r17
    1438:	f1 f7       	brne	.-4      	; 0x1436 <set_ampGain+0x240>
    143a:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    143c:	8f ef       	ldi	r24, 0xFF	; 255
    143e:	61 e0       	ldi	r22, 0x01	; 1
    1440:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    1444:	6a 96       	adiw	r28, 0x1a	; 26
    1446:	cd bf       	out	0x3d, r28	; 61
    1448:	de bf       	out	0x3e, r29	; 62
    144a:	df 91       	pop	r29
    144c:	cf 91       	pop	r28
    144e:	1f 91       	pop	r17
    1450:	0f 91       	pop	r16
    1452:	08 95       	ret

00001454 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    1454:	cf 93       	push	r28
    1456:	df 93       	push	r29
    1458:	00 d0       	rcall	.+0      	; 0x145a <set_filter+0x6>
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
    145e:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    1460:	8b 81       	ldd	r24, Y+3	; 0x03
    1462:	83 70       	andi	r24, 0x03	; 3
    1464:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    1466:	8b 81       	ldd	r24, Y+3	; 0x03
    1468:	8c 70       	andi	r24, 0x0C	; 12
    146a:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    146c:	8b 81       	ldd	r24, Y+3	; 0x03
    146e:	88 2f       	mov	r24, r24
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	85 70       	andi	r24, 0x05	; 5
    1474:	90 70       	andi	r25, 0x00	; 0
    1476:	00 97       	sbiw	r24, 0x00	; 0
    1478:	51 f0       	breq	.+20     	; 0x148e <set_filter+0x3a>
    147a:	80 91 80 50 	lds	r24, 0x5080
    147e:	98 2f       	mov	r25, r24
    1480:	90 7f       	andi	r25, 0xF0	; 240
    1482:	8b 81       	ldd	r24, Y+3	; 0x03
    1484:	82 95       	swap	r24
    1486:	8f 70       	andi	r24, 0x0F	; 15
    1488:	89 2b       	or	r24, r25
    148a:	80 93 80 50 	sts	0x5080, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    148e:	8b 81       	ldd	r24, Y+3	; 0x03
    1490:	88 2f       	mov	r24, r24
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	8a 70       	andi	r24, 0x0A	; 10
    1496:	90 70       	andi	r25, 0x00	; 0
    1498:	00 97       	sbiw	r24, 0x00	; 0
    149a:	49 f0       	breq	.+18     	; 0x14ae <set_filter+0x5a>
    149c:	8b 81       	ldd	r24, Y+3	; 0x03
    149e:	98 2f       	mov	r25, r24
    14a0:	90 7f       	andi	r25, 0xF0	; 240
    14a2:	80 91 80 50 	lds	r24, 0x5080
    14a6:	8f 70       	andi	r24, 0x0F	; 15
    14a8:	89 2b       	or	r24, r25
    14aa:	80 93 80 50 	sts	0x5080, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    14ae:	84 e0       	ldi	r24, 0x04	; 4
    14b0:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    14b4:	80 91 80 50 	lds	r24, 0x5080
    14b8:	80 93 64 50 	sts	0x5064, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    14bc:	89 81       	ldd	r24, Y+1	; 0x01
    14be:	88 23       	and	r24, r24
    14c0:	19 f0       	breq	.+6      	; 0x14c8 <set_filter+0x74>
    14c2:	81 e0       	ldi	r24, 0x01	; 1
    14c4:	0e 94 73 37 	call	0x6ee6	; 0x6ee6 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	88 23       	and	r24, r24
    14cc:	19 f0       	breq	.+6      	; 0x14d4 <set_filter+0x80>
    14ce:	81 e0       	ldi	r24, 0x01	; 1
    14d0:	0e 94 8b 37 	call	0x6f16	; 0x6f16 <upperMuxCS>

	SPICS(TRUE);
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    14da:	80 ec       	ldi	r24, 0xC0	; 192
    14dc:	98 e0       	ldi	r25, 0x08	; 8
    14de:	2f ef       	ldi	r18, 0xFF	; 255
    14e0:	fc 01       	movw	r30, r24
    14e2:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    14e4:	00 00       	nop
    14e6:	80 ec       	ldi	r24, 0xC0	; 192
    14e8:	98 e0       	ldi	r25, 0x08	; 8
    14ea:	fc 01       	movw	r30, r24
    14ec:	82 81       	ldd	r24, Z+2	; 0x02
    14ee:	88 23       	and	r24, r24
    14f0:	d4 f7       	brge	.-12     	; 0x14e6 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    14f2:	80 ec       	ldi	r24, 0xC0	; 192
    14f4:	98 e0       	ldi	r25, 0x08	; 8
    14f6:	fc 01       	movw	r30, r24
    14f8:	83 81       	ldd	r24, Z+3	; 0x03
    14fa:	80 93 70 50 	sts	0x5070, r24

	nop();
    14fe:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    1500:	80 ec       	ldi	r24, 0xC0	; 192
    1502:	98 e0       	ldi	r25, 0x08	; 8
    1504:	20 91 64 50 	lds	r18, 0x5064
    1508:	fc 01       	movw	r30, r24
    150a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    150c:	00 00       	nop
    150e:	80 ec       	ldi	r24, 0xC0	; 192
    1510:	98 e0       	ldi	r25, 0x08	; 8
    1512:	fc 01       	movw	r30, r24
    1514:	82 81       	ldd	r24, Z+2	; 0x02
    1516:	88 23       	and	r24, r24
    1518:	d4 f7       	brge	.-12     	; 0x150e <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    151a:	80 ec       	ldi	r24, 0xC0	; 192
    151c:	98 e0       	ldi	r25, 0x08	; 8
    151e:	fc 01       	movw	r30, r24
    1520:	83 81       	ldd	r24, Z+3	; 0x03
    1522:	80 93 70 50 	sts	0x5070, r24
	SPICS(FALSE);
    1526:	80 e0       	ldi	r24, 0x00	; 0
    1528:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    152c:	89 81       	ldd	r24, Y+1	; 0x01
    152e:	88 23       	and	r24, r24
    1530:	19 f0       	breq	.+6      	; 0x1538 <set_filter+0xe4>
    1532:	80 e0       	ldi	r24, 0x00	; 0
    1534:	0e 94 73 37 	call	0x6ee6	; 0x6ee6 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    1538:	8a 81       	ldd	r24, Y+2	; 0x02
    153a:	88 23       	and	r24, r24
    153c:	19 f0       	breq	.+6      	; 0x1544 <set_filter+0xf0>
    153e:	80 e0       	ldi	r24, 0x00	; 0
    1540:	0e 94 8b 37 	call	0x6f16	; 0x6f16 <upperMuxCS>
	SPIDisable();
    1544:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
}
    1548:	23 96       	adiw	r28, 0x03	; 3
    154a:	cd bf       	out	0x3d, r28	; 61
    154c:	de bf       	out	0x3e, r29	; 62
    154e:	df 91       	pop	r29
    1550:	cf 91       	pop	r28
    1552:	08 95       	ret

00001554 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	0f 92       	push	r0
    155a:	cd b7       	in	r28, 0x3d	; 61
    155c:	de b7       	in	r29, 0x3e	; 62
    155e:	89 83       	std	Y+1, r24	; 0x01
	
	if(on) {
    1560:	89 81       	ldd	r24, Y+1	; 0x01
    1562:	88 23       	and	r24, r24
    1564:	59 f0       	breq	.+22     	; 0x157c <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    1566:	80 e0       	ldi	r24, 0x00	; 0
    1568:	96 e0       	ldi	r25, 0x06	; 6
    156a:	20 e2       	ldi	r18, 0x20	; 32
    156c:	fc 01       	movw	r30, r24
    156e:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1570:	80 e0       	ldi	r24, 0x00	; 0
    1572:	96 e0       	ldi	r25, 0x06	; 6
    1574:	20 e2       	ldi	r18, 0x20	; 32
    1576:	fc 01       	movw	r30, r24
    1578:	25 83       	std	Z+5, r18	; 0x05
    157a:	0a c0       	rjmp	.+20     	; 0x1590 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    157c:	80 e0       	ldi	r24, 0x00	; 0
    157e:	96 e0       	ldi	r25, 0x06	; 6
    1580:	20 e2       	ldi	r18, 0x20	; 32
    1582:	fc 01       	movw	r30, r24
    1584:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    1586:	80 e0       	ldi	r24, 0x00	; 0
    1588:	96 e0       	ldi	r25, 0x06	; 6
    158a:	20 e2       	ldi	r18, 0x20	; 32
    158c:	fc 01       	movw	r30, r24
    158e:	22 83       	std	Z+2, r18	; 0x02
	}
}
    1590:	0f 90       	pop	r0
    1592:	df 91       	pop	r29
    1594:	cf 91       	pop	r28
    1596:	08 95       	ret

00001598 <CO_collectADC>:

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    1598:	ef 92       	push	r14
    159a:	ff 92       	push	r15
    159c:	0f 93       	push	r16
    159e:	1f 93       	push	r17
    15a0:	cf 93       	push	r28
    15a2:	df 93       	push	r29
    15a4:	cd b7       	in	r28, 0x3d	; 61
    15a6:	de b7       	in	r29, 0x3e	; 62
    15a8:	28 97       	sbiw	r28, 0x08	; 8
    15aa:	cd bf       	out	0x3d, r28	; 61
    15ac:	de bf       	out	0x3e, r29	; 62
    15ae:	89 83       	std	Y+1, r24	; 0x01
    15b0:	6a 83       	std	Y+2, r22	; 0x02
    15b2:	4b 83       	std	Y+3, r20	; 0x03
    15b4:	5c 83       	std	Y+4, r21	; 0x04
    15b6:	2d 83       	std	Y+5, r18	; 0x05
    15b8:	3e 83       	std	Y+6, r19	; 0x06
    15ba:	0f 83       	std	Y+7, r16	; 0x07
    15bc:	18 87       	std	Y+8, r17	; 0x08
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    15be:	2b 81       	ldd	r18, Y+3	; 0x03
    15c0:	3c 81       	ldd	r19, Y+4	; 0x04
    15c2:	ad 81       	ldd	r26, Y+5	; 0x05
    15c4:	be 81       	ldd	r27, Y+6	; 0x06
    15c6:	ef 81       	ldd	r30, Y+7	; 0x07
    15c8:	f8 85       	ldd	r31, Y+8	; 0x08
    15ca:	89 81       	ldd	r24, Y+1	; 0x01
    15cc:	64 ec       	ldi	r22, 0xC4	; 196
    15ce:	4a 81       	ldd	r20, Y+2	; 0x02
    15d0:	8d 01       	movw	r16, r26
    15d2:	7f 01       	movw	r14, r30
    15d4:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <CO_collectADC_ext>
}
    15d8:	28 96       	adiw	r28, 0x08	; 8
    15da:	cd bf       	out	0x3d, r28	; 61
    15dc:	de bf       	out	0x3e, r29	; 62
    15de:	df 91       	pop	r29
    15e0:	cf 91       	pop	r28
    15e2:	1f 91       	pop	r17
    15e4:	0f 91       	pop	r16
    15e6:	ff 90       	pop	r15
    15e8:	ef 90       	pop	r14
    15ea:	08 95       	ret

000015ec <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    15ec:	ef 92       	push	r14
    15ee:	ff 92       	push	r15
    15f0:	0f 93       	push	r16
    15f2:	1f 93       	push	r17
    15f4:	cf 93       	push	r28
    15f6:	df 93       	push	r29
    15f8:	cd b7       	in	r28, 0x3d	; 61
    15fa:	de b7       	in	r29, 0x3e	; 62
    15fc:	2b 97       	sbiw	r28, 0x0b	; 11
    15fe:	cd bf       	out	0x3d, r28	; 61
    1600:	de bf       	out	0x3e, r29	; 62
    1602:	8b 83       	std	Y+3, r24	; 0x03
    1604:	6c 83       	std	Y+4, r22	; 0x04
    1606:	4d 83       	std	Y+5, r20	; 0x05
    1608:	2e 83       	std	Y+6, r18	; 0x06
    160a:	3f 83       	std	Y+7, r19	; 0x07
    160c:	08 87       	std	Y+8, r16	; 0x08
    160e:	19 87       	std	Y+9, r17	; 0x09
    1610:	ea 86       	std	Y+10, r14	; 0x0a
    1612:	fb 86       	std	Y+11, r15	; 0x0b


	uint16_t period;
	ADC_BUFFER = DataArray;
    1614:	8a 85       	ldd	r24, Y+10	; 0x0a
    1616:	9b 85       	ldd	r25, Y+11	; 0x0b
    1618:	80 93 71 50 	sts	0x5071, r24
    161c:	90 93 72 50 	sts	0x5072, r25
	ADC_Sampling_Finished = 0;
    1620:	10 92 d4 50 	sts	0x50D4, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    162a:	8b 81       	ldd	r24, Y+3	; 0x03
    162c:	6d 81       	ldd	r22, Y+5	; 0x05
    162e:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <set_ampGain>
	set_filter(filterConfig);
    1632:	8c 81       	ldd	r24, Y+4	; 0x04
    1634:	0e 94 2a 0a 	call	0x1454	; 0x1454 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    1638:	8b 81       	ldd	r24, Y+3	; 0x03
    163a:	85 30       	cpi	r24, 0x05	; 5
    163c:	31 f0       	breq	.+12     	; 0x164a <CO_collectADC_ext+0x5e>
    163e:	8b 81       	ldd	r24, Y+3	; 0x03
    1640:	86 30       	cpi	r24, 0x06	; 6
    1642:	19 f0       	breq	.+6      	; 0x164a <CO_collectADC_ext+0x5e>
    1644:	8b 81       	ldd	r24, Y+3	; 0x03
    1646:	87 30       	cpi	r24, 0x07	; 7
    1648:	19 f4       	brne	.+6      	; 0x1650 <CO_collectADC_ext+0x64>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    164a:	81 e0       	ldi	r24, 0x01	; 1
    164c:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1650:	81 e0       	ldi	r24, 0x01	; 1
    1652:	0e 94 aa 0a 	call	0x1554	; 0x1554 <enableADCMUX>
	setADCInput(channel);
    1656:	8b 81       	ldd	r24, Y+3	; 0x03
    1658:	0e 94 4d 1a 	call	0x349a	; 0x349a <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    165c:	84 e0       	ldi	r24, 0x04	; 4
    165e:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1662:	80 ec       	ldi	r24, 0xC0	; 192
    1664:	98 e0       	ldi	r25, 0x08	; 8
    1666:	24 e5       	ldi	r18, 0x54	; 84
    1668:	fc 01       	movw	r30, r24
    166a:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    166c:	80 ea       	ldi	r24, 0xA0	; 160
    166e:	96 e0       	ldi	r25, 0x06	; 6
    1670:	21 e0       	ldi	r18, 0x01	; 1
    1672:	fc 01       	movw	r30, r24
    1674:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1676:	80 ea       	ldi	r24, 0xA0	; 160
    1678:	96 e0       	ldi	r25, 0x06	; 6
    167a:	22 e0       	ldi	r18, 0x02	; 2
    167c:	fc 01       	movw	r30, r24
    167e:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    1680:	80 ea       	ldi	r24, 0xA0	; 160
    1682:	96 e0       	ldi	r25, 0x06	; 6
    1684:	21 e0       	ldi	r18, 0x01	; 1
    1686:	fc 01       	movw	r30, r24
    1688:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    168a:	80 ea       	ldi	r24, 0xA0	; 160
    168c:	96 e0       	ldi	r25, 0x06	; 6
    168e:	21 e0       	ldi	r18, 0x01	; 1
    1690:	fc 01       	movw	r30, r24
    1692:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    1694:	80 e8       	ldi	r24, 0x80	; 128
    1696:	96 e0       	ldi	r25, 0x06	; 6
    1698:	20 e2       	ldi	r18, 0x20	; 32
    169a:	fc 01       	movw	r30, r24
    169c:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    169e:	80 e4       	ldi	r24, 0x40	; 64
    16a0:	9a e0       	ldi	r25, 0x0A	; 10
    16a2:	23 e2       	ldi	r18, 0x23	; 35
    16a4:	fc 01       	movw	r30, r24
    16a6:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    16a8:	8e 81       	ldd	r24, Y+6	; 0x06
    16aa:	9f 81       	ldd	r25, Y+7	; 0x07
    16ac:	9c 01       	movw	r18, r24
    16ae:	40 e0       	ldi	r20, 0x00	; 0
    16b0:	50 e0       	ldi	r21, 0x00	; 0
    16b2:	80 e8       	ldi	r24, 0x80	; 128
    16b4:	94 e8       	ldi	r25, 0x84	; 132
    16b6:	ae e1       	ldi	r26, 0x1E	; 30
    16b8:	b0 e0       	ldi	r27, 0x00	; 0
    16ba:	bc 01       	movw	r22, r24
    16bc:	cd 01       	movw	r24, r26
    16be:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    16c2:	da 01       	movw	r26, r20
    16c4:	c9 01       	movw	r24, r18
    16c6:	89 83       	std	Y+1, r24	; 0x01
    16c8:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    16ca:	80 e4       	ldi	r24, 0x40	; 64
    16cc:	9a e0       	ldi	r25, 0x0A	; 10
    16ce:	29 81       	ldd	r18, Y+1	; 0x01
    16d0:	3a 81       	ldd	r19, Y+2	; 0x02
    16d2:	fc 01       	movw	r30, r24
    16d4:	26 a3       	lds	r18, 0x56
    16d6:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    16d8:	80 e4       	ldi	r24, 0x40	; 64
    16da:	9a e0       	ldi	r25, 0x0A	; 10
    16dc:	29 81       	ldd	r18, Y+1	; 0x01
    16de:	3a 81       	ldd	r19, Y+2	; 0x02
    16e0:	36 95       	lsr	r19
    16e2:	27 95       	ror	r18
    16e4:	fc 01       	movw	r30, r24
    16e6:	22 af       	sts	0x72, r18
    16e8:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples + ADC_DISCARD;
    16ea:	80 e4       	ldi	r24, 0x40	; 64
    16ec:	98 e0       	ldi	r25, 0x08	; 8
    16ee:	28 85       	ldd	r18, Y+8	; 0x08
    16f0:	39 85       	ldd	r19, Y+9	; 0x09
    16f2:	20 58       	subi	r18, 0x80	; 128
    16f4:	3f 4f       	sbci	r19, 0xFF	; 255
    16f6:	fc 01       	movw	r30, r24
    16f8:	26 a3       	lds	r18, 0x56
    16fa:	37 a3       	lds	r19, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    16fc:	80 e8       	ldi	r24, 0x80	; 128
    16fe:	91 e0       	ldi	r25, 0x01	; 1
    1700:	28 e7       	ldi	r18, 0x78	; 120
    1702:	fc 01       	movw	r30, r24
    1704:	21 83       	std	Z+1, r18	; 0x01
	
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1706:	80 e4       	ldi	r24, 0x40	; 64
    1708:	98 e0       	ldi	r25, 0x08	; 8
    170a:	20 e4       	ldi	r18, 0x40	; 64
    170c:	38 e0       	ldi	r19, 0x08	; 8
    170e:	f9 01       	movw	r30, r18
    1710:	20 81       	ld	r18, Z
    1712:	20 7f       	andi	r18, 0xF0	; 240
    1714:	29 60       	ori	r18, 0x09	; 9
    1716:	fc 01       	movw	r30, r24
    1718:	20 83       	st	Z, r18
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    171a:	80 e4       	ldi	r24, 0x40	; 64
    171c:	9a e0       	ldi	r25, 0x0A	; 10
    171e:	20 e4       	ldi	r18, 0x40	; 64
    1720:	3a e0       	ldi	r19, 0x0A	; 10
    1722:	f9 01       	movw	r30, r18
    1724:	20 81       	ld	r18, Z
    1726:	20 7f       	andi	r18, 0xF0	; 240
    1728:	21 60       	ori	r18, 0x01	; 1
    172a:	fc 01       	movw	r30, r24
    172c:	20 83       	st	Z, r18
	
	sampleCount = 0;
    172e:	10 92 73 50 	sts	0x5073, r1
    1732:	10 92 74 50 	sts	0x5074, r1
    1736:	10 92 75 50 	sts	0x5075, r1
    173a:	10 92 76 50 	sts	0x5076, r1
	discardCount = 0;
    173e:	10 92 5c 40 	sts	0x405C, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1742:	80 ea       	ldi	r24, 0xA0	; 160
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	20 ea       	ldi	r18, 0xA0	; 160
    1748:	30 e0       	ldi	r19, 0x00	; 0
    174a:	f9 01       	movw	r30, r18
    174c:	22 81       	ldd	r18, Z+2	; 0x02
    174e:	21 60       	ori	r18, 0x01	; 1
    1750:	fc 01       	movw	r30, r24
    1752:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1754:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    1756:	2b 96       	adiw	r28, 0x0b	; 11
    1758:	cd bf       	out	0x3d, r28	; 61
    175a:	de bf       	out	0x3e, r29	; 62
    175c:	df 91       	pop	r29
    175e:	cf 91       	pop	r28
    1760:	1f 91       	pop	r17
    1762:	0f 91       	pop	r16
    1764:	ff 90       	pop	r15
    1766:	ef 90       	pop	r14
    1768:	08 95       	ret

0000176a <__vector_20>:

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    176a:	1f 92       	push	r1
    176c:	0f 92       	push	r0
    176e:	0f b6       	in	r0, 0x3f	; 63
    1770:	0f 92       	push	r0
    1772:	00 90 3b 00 	lds	r0, 0x003B
    1776:	0f 92       	push	r0
    1778:	11 24       	eor	r1, r1
    177a:	2f 93       	push	r18
    177c:	3f 93       	push	r19
    177e:	4f 93       	push	r20
    1780:	5f 93       	push	r21
    1782:	6f 93       	push	r22
    1784:	7f 93       	push	r23
    1786:	8f 93       	push	r24
    1788:	9f 93       	push	r25
    178a:	af 93       	push	r26
    178c:	bf 93       	push	r27
    178e:	ef 93       	push	r30
    1790:	ff 93       	push	r31
    1792:	cf 93       	push	r28
    1794:	df 93       	push	r29
    1796:	cd b7       	in	r28, 0x3d	; 61
    1798:	de b7       	in	r29, 0x3e	; 62

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    179a:	80 e4       	ldi	r24, 0x40	; 64
    179c:	9a e0       	ldi	r25, 0x0A	; 10
    179e:	20 e4       	ldi	r18, 0x40	; 64
    17a0:	3a e0       	ldi	r19, 0x0A	; 10
    17a2:	f9 01       	movw	r30, r18
    17a4:	20 81       	ld	r18, Z
    17a6:	20 7f       	andi	r18, 0xF0	; 240
    17a8:	fc 01       	movw	r30, r24
    17aa:	20 83       	st	Z, r18
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	98 e0       	ldi	r25, 0x08	; 8
    17b0:	20 e0       	ldi	r18, 0x00	; 0
    17b2:	38 e0       	ldi	r19, 0x08	; 8
    17b4:	f9 01       	movw	r30, r18
    17b6:	20 81       	ld	r18, Z
    17b8:	20 7f       	andi	r18, 0xF0	; 240
    17ba:	fc 01       	movw	r30, r24
    17bc:	20 83       	st	Z, r18
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    17be:	80 e0       	ldi	r24, 0x00	; 0
    17c0:	99 e0       	ldi	r25, 0x09	; 9
    17c2:	20 e0       	ldi	r18, 0x00	; 0
    17c4:	39 e0       	ldi	r19, 0x09	; 9
    17c6:	f9 01       	movw	r30, r18
    17c8:	20 81       	ld	r18, Z
    17ca:	20 7f       	andi	r18, 0xF0	; 240
    17cc:	fc 01       	movw	r30, r24
    17ce:	20 83       	st	Z, r18
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    17d0:	80 e4       	ldi	r24, 0x40	; 64
    17d2:	98 e0       	ldi	r25, 0x08	; 8
    17d4:	20 e4       	ldi	r18, 0x40	; 64
    17d6:	3a e0       	ldi	r19, 0x0A	; 10
    17d8:	f9 01       	movw	r30, r18
    17da:	20 81       	ld	r18, Z
    17dc:	20 7f       	andi	r18, 0xF0	; 240
    17de:	fc 01       	movw	r30, r24
    17e0:	20 83       	st	Z, r18

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    17e8:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	enableADCMUX(FALSE);
    17ec:	80 e0       	ldi	r24, 0x00	; 0
    17ee:	0e 94 aa 0a 	call	0x1554	; 0x1554 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	80 93 d4 50 	sts	0x50D4, r24
}
    17f8:	df 91       	pop	r29
    17fa:	cf 91       	pop	r28
    17fc:	ff 91       	pop	r31
    17fe:	ef 91       	pop	r30
    1800:	bf 91       	pop	r27
    1802:	af 91       	pop	r26
    1804:	9f 91       	pop	r25
    1806:	8f 91       	pop	r24
    1808:	7f 91       	pop	r23
    180a:	6f 91       	pop	r22
    180c:	5f 91       	pop	r21
    180e:	4f 91       	pop	r20
    1810:	3f 91       	pop	r19
    1812:	2f 91       	pop	r18
    1814:	0f 90       	pop	r0
    1816:	00 92 3b 00 	sts	0x003B, r0
    181a:	0f 90       	pop	r0
    181c:	0f be       	out	0x3f, r0	; 63
    181e:	0f 90       	pop	r0
    1820:	1f 90       	pop	r1
    1822:	18 95       	reti

00001824 <ADC_Stop_Sampling>:
// sei();
// }

//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
    1824:	cf 93       	push	r28
    1826:	df 93       	push	r29
    1828:	cd b7       	in	r28, 0x3d	; 61
    182a:	de b7       	in	r29, 0x3e	; 62
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    182c:	80 e4       	ldi	r24, 0x40	; 64
    182e:	9a e0       	ldi	r25, 0x0A	; 10
    1830:	20 e4       	ldi	r18, 0x40	; 64
    1832:	3a e0       	ldi	r19, 0x0A	; 10
    1834:	f9 01       	movw	r30, r18
    1836:	20 81       	ld	r18, Z
    1838:	20 7f       	andi	r18, 0xF0	; 240
    183a:	fc 01       	movw	r30, r24
    183c:	20 83       	st	Z, r18
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    183e:	80 e0       	ldi	r24, 0x00	; 0
    1840:	98 e0       	ldi	r25, 0x08	; 8
    1842:	20 e0       	ldi	r18, 0x00	; 0
    1844:	38 e0       	ldi	r19, 0x08	; 8
    1846:	f9 01       	movw	r30, r18
    1848:	20 81       	ld	r18, Z
    184a:	20 7f       	andi	r18, 0xF0	; 240
    184c:	fc 01       	movw	r30, r24
    184e:	20 83       	st	Z, r18
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1850:	80 e0       	ldi	r24, 0x00	; 0
    1852:	99 e0       	ldi	r25, 0x09	; 9
    1854:	20 e0       	ldi	r18, 0x00	; 0
    1856:	39 e0       	ldi	r19, 0x09	; 9
    1858:	f9 01       	movw	r30, r18
    185a:	20 81       	ld	r18, Z
    185c:	20 7f       	andi	r18, 0xF0	; 240
    185e:	fc 01       	movw	r30, r24
    1860:	20 83       	st	Z, r18
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1862:	80 e4       	ldi	r24, 0x40	; 64
    1864:	98 e0       	ldi	r25, 0x08	; 8
    1866:	20 e4       	ldi	r18, 0x40	; 64
    1868:	3a e0       	ldi	r19, 0x0A	; 10
    186a:	f9 01       	movw	r30, r18
    186c:	20 81       	ld	r18, Z
    186e:	20 7f       	andi	r18, 0xF0	; 240
    1870:	fc 01       	movw	r30, r24
    1872:	20 83       	st	Z, r18

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1874:	80 e0       	ldi	r24, 0x00	; 0
    1876:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    187a:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	enableADCMUX(FALSE);
    187e:	80 e0       	ldi	r24, 0x00	; 0
    1880:	0e 94 aa 0a 	call	0x1554	; 0x1554 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    1884:	81 e0       	ldi	r24, 0x01	; 1
    1886:	80 93 d4 50 	sts	0x50D4, r24
}
    188a:	df 91       	pop	r29
    188c:	cf 91       	pop	r28
    188e:	08 95       	ret

00001890 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    1890:	cf 93       	push	r28
    1892:	df 93       	push	r29
    1894:	cd b7       	in	r28, 0x3d	; 61
    1896:	de b7       	in	r29, 0x3e	; 62
	
	return TCC1.CNT;
    1898:	80 e4       	ldi	r24, 0x40	; 64
    189a:	98 e0       	ldi	r25, 0x08	; 8
    189c:	fc 01       	movw	r30, r24
    189e:	80 a1       	lds	r24, 0x40
    18a0:	91 a1       	lds	r25, 0x41
}
    18a2:	df 91       	pop	r29
    18a4:	cf 91       	pop	r28
    18a6:	08 95       	ret

000018a8 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
    18a8:	cf 93       	push	r28
    18aa:	df 93       	push	r29
    18ac:	cd b7       	in	r28, 0x3d	; 61
    18ae:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    18b0:	80 ea       	ldi	r24, 0xA0	; 160
    18b2:	96 e0       	ldi	r25, 0x06	; 6
    18b4:	fc 01       	movw	r30, r24
    18b6:	13 86       	std	Z+11, r1	; 0x0b
}
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	08 95       	ret

000018be <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29
    18c2:	cd b7       	in	r28, 0x3d	; 61
    18c4:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    18c6:	80 ea       	ldi	r24, 0xA0	; 160
    18c8:	96 e0       	ldi	r25, 0x06	; 6
    18ca:	21 e0       	ldi	r18, 0x01	; 1
    18cc:	fc 01       	movw	r30, r24
    18ce:	23 87       	std	Z+11, r18	; 0x0b
}	
    18d0:	df 91       	pop	r29
    18d2:	cf 91       	pop	r28
    18d4:	08 95       	ret

000018d6 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    18d6:	1f 92       	push	r1
    18d8:	0f 92       	push	r0
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	0f 92       	push	r0
    18de:	00 90 3b 00 	lds	r0, 0x003B
    18e2:	0f 92       	push	r0
    18e4:	11 24       	eor	r1, r1
    18e6:	2f 92       	push	r2
    18e8:	3f 92       	push	r3
    18ea:	4f 92       	push	r4
    18ec:	5f 92       	push	r5
    18ee:	6f 92       	push	r6
    18f0:	7f 92       	push	r7
    18f2:	8f 92       	push	r8
    18f4:	9f 92       	push	r9
    18f6:	af 92       	push	r10
    18f8:	bf 92       	push	r11
    18fa:	cf 92       	push	r12
    18fc:	df 92       	push	r13
    18fe:	ef 92       	push	r14
    1900:	ff 92       	push	r15
    1902:	0f 93       	push	r16
    1904:	1f 93       	push	r17
    1906:	2f 93       	push	r18
    1908:	3f 93       	push	r19
    190a:	4f 93       	push	r20
    190c:	5f 93       	push	r21
    190e:	6f 93       	push	r22
    1910:	7f 93       	push	r23
    1912:	8f 93       	push	r24
    1914:	9f 93       	push	r25
    1916:	af 93       	push	r26
    1918:	bf 93       	push	r27
    191a:	ef 93       	push	r30
    191c:	ff 93       	push	r31
    191e:	cf 93       	push	r28
    1920:	df 93       	push	r29
    1922:	cd b7       	in	r28, 0x3d	; 61
    1924:	de b7       	in	r29, 0x3e	; 62
    1926:	27 97       	sbiw	r28, 0x07	; 7
    1928:	cd bf       	out	0x3d, r28	; 61
    192a:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	if (discardCount < ADC_DISCARD) {
    192c:	80 91 5c 40 	lds	r24, 0x405C
    1930:	88 23       	and	r24, r24
    1932:	34 f0       	brlt	.+12     	; 0x1940 <__vector_104+0x6a>
		discardCount++;
    1934:	80 91 5c 40 	lds	r24, 0x405C
    1938:	8f 5f       	subi	r24, 0xFF	; 255
    193a:	80 93 5c 40 	sts	0x405C, r24
    193e:	4a c1       	rjmp	.+660    	; 0x1bd4 <__vector_104+0x2fe>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1940:	81 e0       	ldi	r24, 0x01	; 1
    1942:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1946:	80 ea       	ldi	r24, 0xA0	; 160
    1948:	96 e0       	ldi	r25, 0x06	; 6
    194a:	22 e0       	ldi	r18, 0x02	; 2
    194c:	fc 01       	movw	r30, r24
    194e:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1950:	19 82       	std	Y+1, r1	; 0x01
    1952:	1a c0       	rjmp	.+52     	; 0x1988 <__vector_104+0xb2>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1954:	80 ec       	ldi	r24, 0xC0	; 192
    1956:	98 e0       	ldi	r25, 0x08	; 8
    1958:	2a ea       	ldi	r18, 0xAA	; 170
    195a:	fc 01       	movw	r30, r24
    195c:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    195e:	00 00       	nop
    1960:	80 ec       	ldi	r24, 0xC0	; 192
    1962:	98 e0       	ldi	r25, 0x08	; 8
    1964:	fc 01       	movw	r30, r24
    1966:	82 81       	ldd	r24, Z+2	; 0x02
    1968:	88 23       	and	r24, r24
    196a:	d4 f7       	brge	.-12     	; 0x1960 <__vector_104+0x8a>
			SPIBuffer[bufIndex] = SPIC.DATA;
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	88 2f       	mov	r24, r24
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	20 ec       	ldi	r18, 0xC0	; 192
    1974:	38 e0       	ldi	r19, 0x08	; 8
    1976:	f9 01       	movw	r30, r18
    1978:	23 81       	ldd	r18, Z+3	; 0x03
    197a:	8c 59       	subi	r24, 0x9C	; 156
    197c:	9f 4a       	sbci	r25, 0xAF	; 175
    197e:	fc 01       	movw	r30, r24
    1980:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1982:	89 81       	ldd	r24, Y+1	; 0x01
    1984:	8f 5f       	subi	r24, 0xFF	; 255
    1986:	89 83       	std	Y+1, r24	; 0x01
    1988:	89 81       	ldd	r24, Y+1	; 0x01
    198a:	83 30       	cpi	r24, 0x03	; 3
    198c:	18 f3       	brcs	.-58     	; 0x1954 <__vector_104+0x7e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    198e:	80 ea       	ldi	r24, 0xA0	; 160
    1990:	96 e0       	ldi	r25, 0x06	; 6
    1992:	22 e0       	ldi	r18, 0x02	; 2
    1994:	fc 01       	movw	r30, r24
    1996:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1998:	80 e0       	ldi	r24, 0x00	; 0
    199a:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    199e:	80 91 64 50 	lds	r24, 0x5064
    19a2:	88 23       	and	r24, r24
    19a4:	3c f4       	brge	.+14     	; 0x19b4 <__vector_104+0xde>
    19a6:	ce 01       	movw	r24, r28
    19a8:	02 96       	adiw	r24, 0x02	; 2
    19aa:	03 96       	adiw	r24, 0x03	; 3
    19ac:	2f ef       	ldi	r18, 0xFF	; 255
    19ae:	fc 01       	movw	r30, r24
    19b0:	20 83       	st	Z, r18
    19b2:	05 c0       	rjmp	.+10     	; 0x19be <__vector_104+0xe8>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    19b4:	ce 01       	movw	r24, r28
    19b6:	02 96       	adiw	r24, 0x02	; 2
    19b8:	03 96       	adiw	r24, 0x03	; 3
    19ba:	fc 01       	movw	r30, r24
    19bc:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    19be:	ce 01       	movw	r24, r28
    19c0:	02 96       	adiw	r24, 0x02	; 2
    19c2:	02 96       	adiw	r24, 0x02	; 2
    19c4:	20 91 64 50 	lds	r18, 0x5064
    19c8:	fc 01       	movw	r30, r24
    19ca:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    19cc:	ce 01       	movw	r24, r28
    19ce:	02 96       	adiw	r24, 0x02	; 2
    19d0:	01 96       	adiw	r24, 0x01	; 1
    19d2:	20 91 65 50 	lds	r18, 0x5065
    19d6:	fc 01       	movw	r30, r24
    19d8:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    19da:	ce 01       	movw	r24, r28
    19dc:	02 96       	adiw	r24, 0x02	; 2
    19de:	20 91 66 50 	lds	r18, 0x5066
    19e2:	fc 01       	movw	r30, r24
    19e4:	20 83       	st	Z, r18
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    19e6:	8a 81       	ldd	r24, Y+2	; 0x02
    19e8:	9b 81       	ldd	r25, Y+3	; 0x03
    19ea:	ac 81       	ldd	r26, Y+4	; 0x04
    19ec:	bd 81       	ldd	r27, Y+5	; 0x05
    19ee:	5c 01       	movw	r10, r24
    19f0:	6d 01       	movw	r12, r26
    19f2:	bb 0f       	add	r27, r27
    19f4:	88 0b       	sbc	r24, r24
    19f6:	98 2f       	mov	r25, r24
    19f8:	dc 01       	movw	r26, r24
    19fa:	e8 2e       	mov	r14, r24
    19fc:	f8 2e       	mov	r15, r24
    19fe:	08 2f       	mov	r16, r24
    1a00:	18 2f       	mov	r17, r24
    1a02:	a0 92 a5 50 	sts	0x50A5, r10
    1a06:	b0 92 a6 50 	sts	0x50A6, r11
    1a0a:	c0 92 a7 50 	sts	0x50A7, r12
    1a0e:	d0 92 a8 50 	sts	0x50A8, r13
    1a12:	e0 92 a9 50 	sts	0x50A9, r14
    1a16:	f0 92 aa 50 	sts	0x50AA, r15
    1a1a:	00 93 ab 50 	sts	0x50AB, r16
    1a1e:	10 93 ac 50 	sts	0x50AC, r17
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a22:	20 91 71 50 	lds	r18, 0x5071
    1a26:	30 91 72 50 	lds	r19, 0x5072
    1a2a:	80 91 73 50 	lds	r24, 0x5073
    1a2e:	90 91 74 50 	lds	r25, 0x5074
    1a32:	a0 91 75 50 	lds	r26, 0x5075
    1a36:	b0 91 76 50 	lds	r27, 0x5076
    1a3a:	88 0f       	add	r24, r24
    1a3c:	99 1f       	adc	r25, r25
    1a3e:	88 0f       	add	r24, r24
    1a40:	99 1f       	adc	r25, r25
    1a42:	a9 01       	movw	r20, r18
    1a44:	48 0f       	add	r20, r24
    1a46:	59 1f       	adc	r21, r25
    1a48:	4e 83       	std	Y+6, r20	; 0x06
    1a4a:	5f 83       	std	Y+7, r21	; 0x07
    1a4c:	a0 90 a5 50 	lds	r10, 0x50A5
    1a50:	b0 90 a6 50 	lds	r11, 0x50A6
    1a54:	c0 90 a7 50 	lds	r12, 0x50A7
    1a58:	d0 90 a8 50 	lds	r13, 0x50A8
    1a5c:	e0 90 a9 50 	lds	r14, 0x50A9
    1a60:	f0 90 aa 50 	lds	r15, 0x50AA
    1a64:	00 91 ab 50 	lds	r16, 0x50AB
    1a68:	10 91 ac 50 	lds	r17, 0x50AC
    1a6c:	2a 2d       	mov	r18, r10
    1a6e:	3b 2d       	mov	r19, r11
    1a70:	4c 2d       	mov	r20, r12
    1a72:	5d 2d       	mov	r21, r13
    1a74:	6e 2d       	mov	r22, r14
    1a76:	7f 2d       	mov	r23, r15
    1a78:	80 2f       	mov	r24, r16
    1a7a:	91 2f       	mov	r25, r17
    1a7c:	0f 2e       	mov	r0, r31
    1a7e:	f0 ea       	ldi	r31, 0xA0	; 160
    1a80:	af 2e       	mov	r10, r31
    1a82:	f0 2d       	mov	r31, r0
    1a84:	0f 2e       	mov	r0, r31
    1a86:	f5 e2       	ldi	r31, 0x25	; 37
    1a88:	bf 2e       	mov	r11, r31
    1a8a:	f0 2d       	mov	r31, r0
    1a8c:	0f 2e       	mov	r0, r31
    1a8e:	f6 e2       	ldi	r31, 0x26	; 38
    1a90:	cf 2e       	mov	r12, r31
    1a92:	f0 2d       	mov	r31, r0
    1a94:	dd 24       	eor	r13, r13
    1a96:	ee 24       	eor	r14, r14
    1a98:	ff 24       	eor	r15, r15
    1a9a:	00 e0       	ldi	r16, 0x00	; 0
    1a9c:	10 e0       	ldi	r17, 0x00	; 0
    1a9e:	0e 94 91 51 	call	0xa322	; 0xa322 <__muldi3>
    1aa2:	22 2e       	mov	r2, r18
    1aa4:	33 2e       	mov	r3, r19
    1aa6:	44 2e       	mov	r4, r20
    1aa8:	55 2e       	mov	r5, r21
    1aaa:	66 2e       	mov	r6, r22
    1aac:	77 2e       	mov	r7, r23
    1aae:	88 2e       	mov	r8, r24
    1ab0:	99 2e       	mov	r9, r25
    1ab2:	a2 2c       	mov	r10, r2
    1ab4:	b3 2c       	mov	r11, r3
    1ab6:	c4 2c       	mov	r12, r4
    1ab8:	d5 2c       	mov	r13, r5
    1aba:	e6 2c       	mov	r14, r6
    1abc:	f7 2c       	mov	r15, r7
    1abe:	08 2d       	mov	r16, r8
    1ac0:	19 2d       	mov	r17, r9
    1ac2:	2a 2d       	mov	r18, r10
    1ac4:	3b 2d       	mov	r19, r11
    1ac6:	4c 2d       	mov	r20, r12
    1ac8:	5d 2d       	mov	r21, r13
    1aca:	6e 2d       	mov	r22, r14
    1acc:	7f 2d       	mov	r23, r15
    1ace:	80 2f       	mov	r24, r16
    1ad0:	91 2f       	mov	r25, r17
    1ad2:	aa 24       	eor	r10, r10
    1ad4:	aa 94       	dec	r10
    1ad6:	bb 24       	eor	r11, r11
    1ad8:	ba 94       	dec	r11
    1ada:	0f 2e       	mov	r0, r31
    1adc:	ff e7       	ldi	r31, 0x7F	; 127
    1ade:	cf 2e       	mov	r12, r31
    1ae0:	f0 2d       	mov	r31, r0
    1ae2:	dd 24       	eor	r13, r13
    1ae4:	ee 24       	eor	r14, r14
    1ae6:	ff 24       	eor	r15, r15
    1ae8:	00 e0       	ldi	r16, 0x00	; 0
    1aea:	10 e0       	ldi	r17, 0x00	; 0
    1aec:	0e 94 d8 52 	call	0xa5b0	; 0xa5b0 <__divdi3>
    1af0:	22 2e       	mov	r2, r18
    1af2:	33 2e       	mov	r3, r19
    1af4:	44 2e       	mov	r4, r20
    1af6:	55 2e       	mov	r5, r21
    1af8:	66 2e       	mov	r6, r22
    1afa:	77 2e       	mov	r7, r23
    1afc:	88 2e       	mov	r8, r24
    1afe:	99 2e       	mov	r9, r25
    1b00:	a2 2c       	mov	r10, r2
    1b02:	b3 2c       	mov	r11, r3
    1b04:	c4 2c       	mov	r12, r4
    1b06:	d5 2c       	mov	r13, r5
    1b08:	e6 2c       	mov	r14, r6
    1b0a:	f7 2c       	mov	r15, r7
    1b0c:	08 2d       	mov	r16, r8
    1b0e:	19 2d       	mov	r17, r9
    1b10:	2a 2d       	mov	r18, r10
    1b12:	3b 2d       	mov	r19, r11
    1b14:	4c 2d       	mov	r20, r12
    1b16:	5d 2d       	mov	r21, r13
    1b18:	6e 2d       	mov	r22, r14
    1b1a:	7f 2d       	mov	r23, r15
    1b1c:	80 2f       	mov	r24, r16
    1b1e:	91 2f       	mov	r25, r17
    1b20:	01 e0       	ldi	r16, 0x01	; 1
    1b22:	0e 94 64 52 	call	0xa4c8	; 0xa4c8 <__ashldi3>
    1b26:	22 2e       	mov	r2, r18
    1b28:	33 2e       	mov	r3, r19
    1b2a:	44 2e       	mov	r4, r20
    1b2c:	55 2e       	mov	r5, r21
    1b2e:	66 2e       	mov	r6, r22
    1b30:	77 2e       	mov	r7, r23
    1b32:	88 2e       	mov	r8, r24
    1b34:	99 2e       	mov	r9, r25
    1b36:	a2 2c       	mov	r10, r2
    1b38:	b3 2c       	mov	r11, r3
    1b3a:	c4 2c       	mov	r12, r4
    1b3c:	d5 2c       	mov	r13, r5
    1b3e:	e6 2c       	mov	r14, r6
    1b40:	f7 2c       	mov	r15, r7
    1b42:	08 2d       	mov	r16, r8
    1b44:	19 2d       	mov	r17, r9
    1b46:	2a 2d       	mov	r18, r10
    1b48:	3b 2d       	mov	r19, r11
    1b4a:	4c 2d       	mov	r20, r12
    1b4c:	5d 2d       	mov	r21, r13
    1b4e:	6e 2d       	mov	r22, r14
    1b50:	7f 2d       	mov	r23, r15
    1b52:	80 2f       	mov	r24, r16
    1b54:	91 2f       	mov	r25, r17
    1b56:	0f 2e       	mov	r0, r31
    1b58:	f3 e0       	ldi	r31, 0x03	; 3
    1b5a:	af 2e       	mov	r10, r31
    1b5c:	f0 2d       	mov	r31, r0
    1b5e:	bb 24       	eor	r11, r11
    1b60:	cc 24       	eor	r12, r12
    1b62:	dd 24       	eor	r13, r13
    1b64:	ee 24       	eor	r14, r14
    1b66:	ff 24       	eor	r15, r15
    1b68:	00 e0       	ldi	r16, 0x00	; 0
    1b6a:	10 e0       	ldi	r17, 0x00	; 0
    1b6c:	0e 94 d8 52 	call	0xa5b0	; 0xa5b0 <__divdi3>
    1b70:	a2 2e       	mov	r10, r18
    1b72:	b3 2e       	mov	r11, r19
    1b74:	c4 2e       	mov	r12, r20
    1b76:	d5 2e       	mov	r13, r21
    1b78:	e6 2e       	mov	r14, r22
    1b7a:	f7 2e       	mov	r15, r23
    1b7c:	08 2f       	mov	r16, r24
    1b7e:	19 2f       	mov	r17, r25
    1b80:	2a 2d       	mov	r18, r10
    1b82:	3b 2d       	mov	r19, r11
    1b84:	4c 2d       	mov	r20, r12
    1b86:	5d 2d       	mov	r21, r13
    1b88:	6e 2d       	mov	r22, r14
    1b8a:	7f 2d       	mov	r23, r15
    1b8c:	80 2f       	mov	r24, r16
    1b8e:	91 2f       	mov	r25, r17
    1b90:	da 01       	movw	r26, r20
    1b92:	c9 01       	movw	r24, r18
    1b94:	b0 95       	com	r27
    1b96:	a0 95       	com	r26
    1b98:	90 95       	com	r25
    1b9a:	81 95       	neg	r24
    1b9c:	9f 4f       	sbci	r25, 0xFF	; 255
    1b9e:	af 4f       	sbci	r26, 0xFF	; 255
    1ba0:	bf 4f       	sbci	r27, 0xFF	; 255
    1ba2:	ee 81       	ldd	r30, Y+6	; 0x06
    1ba4:	ff 81       	ldd	r31, Y+7	; 0x07
    1ba6:	80 83       	st	Z, r24
    1ba8:	91 83       	std	Z+1, r25	; 0x01
    1baa:	a2 83       	std	Z+2, r26	; 0x02
    1bac:	b3 83       	std	Z+3, r27	; 0x03
		sampleCount++;
    1bae:	80 91 73 50 	lds	r24, 0x5073
    1bb2:	90 91 74 50 	lds	r25, 0x5074
    1bb6:	a0 91 75 50 	lds	r26, 0x5075
    1bba:	b0 91 76 50 	lds	r27, 0x5076
    1bbe:	01 96       	adiw	r24, 0x01	; 1
    1bc0:	a1 1d       	adc	r26, r1
    1bc2:	b1 1d       	adc	r27, r1
    1bc4:	80 93 73 50 	sts	0x5073, r24
    1bc8:	90 93 74 50 	sts	0x5074, r25
    1bcc:	a0 93 75 50 	sts	0x5075, r26
    1bd0:	b0 93 76 50 	sts	0x5076, r27
	}
}
    1bd4:	27 96       	adiw	r28, 0x07	; 7
    1bd6:	cd bf       	out	0x3d, r28	; 61
    1bd8:	de bf       	out	0x3e, r29	; 62
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	ff 91       	pop	r31
    1be0:	ef 91       	pop	r30
    1be2:	bf 91       	pop	r27
    1be4:	af 91       	pop	r26
    1be6:	9f 91       	pop	r25
    1be8:	8f 91       	pop	r24
    1bea:	7f 91       	pop	r23
    1bec:	6f 91       	pop	r22
    1bee:	5f 91       	pop	r21
    1bf0:	4f 91       	pop	r20
    1bf2:	3f 91       	pop	r19
    1bf4:	2f 91       	pop	r18
    1bf6:	1f 91       	pop	r17
    1bf8:	0f 91       	pop	r16
    1bfa:	ff 90       	pop	r15
    1bfc:	ef 90       	pop	r14
    1bfe:	df 90       	pop	r13
    1c00:	cf 90       	pop	r12
    1c02:	bf 90       	pop	r11
    1c04:	af 90       	pop	r10
    1c06:	9f 90       	pop	r9
    1c08:	8f 90       	pop	r8
    1c0a:	7f 90       	pop	r7
    1c0c:	6f 90       	pop	r6
    1c0e:	5f 90       	pop	r5
    1c10:	4f 90       	pop	r4
    1c12:	3f 90       	pop	r3
    1c14:	2f 90       	pop	r2
    1c16:	0f 90       	pop	r0
    1c18:	00 92 3b 00 	sts	0x003B, r0
    1c1c:	0f 90       	pop	r0
    1c1e:	0f be       	out	0x3f, r0	; 63
    1c20:	0f 90       	pop	r0
    1c22:	1f 90       	pop	r1
    1c24:	18 95       	reti

00001c26 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1c26:	cf 93       	push	r28
    1c28:	df 93       	push	r29
    1c2a:	0f 92       	push	r0
    1c2c:	cd b7       	in	r28, 0x3d	; 61
    1c2e:	de b7       	in	r29, 0x3e	; 62
    1c30:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1c32:	89 81       	ldd	r24, Y+1	; 0x01
    1c34:	88 23       	and	r24, r24
    1c36:	49 f0       	breq	.+18     	; 0x1c4a <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1c38:	80 e2       	ldi	r24, 0x20	; 32
    1c3a:	60 e0       	ldi	r22, 0x00	; 0
    1c3c:	0e 94 07 33 	call	0x660e	; 0x660e <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c40:	80 e2       	ldi	r24, 0x20	; 32
    1c42:	60 e0       	ldi	r22, 0x00	; 0
    1c44:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
    1c48:	04 c0       	rjmp	.+8      	; 0x1c52 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c4a:	80 e2       	ldi	r24, 0x20	; 32
    1c4c:	60 e0       	ldi	r22, 0x00	; 0
    1c4e:	0e 94 6b 33 	call	0x66d6	; 0x66d6 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1c52:	0f 90       	pop	r0
    1c54:	df 91       	pop	r29
    1c56:	cf 91       	pop	r28
    1c58:	08 95       	ret

00001c5a <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    1c5a:	8f 92       	push	r8
    1c5c:	9f 92       	push	r9
    1c5e:	af 92       	push	r10
    1c60:	bf 92       	push	r11
    1c62:	cf 92       	push	r12
    1c64:	df 92       	push	r13
    1c66:	ef 92       	push	r14
    1c68:	ff 92       	push	r15
    1c6a:	0f 93       	push	r16
    1c6c:	1f 93       	push	r17
    1c6e:	cf 93       	push	r28
    1c70:	df 93       	push	r29
    1c72:	cd b7       	in	r28, 0x3d	; 61
    1c74:	de b7       	in	r29, 0x3e	; 62
    1c76:	62 97       	sbiw	r28, 0x12	; 18
    1c78:	cd bf       	out	0x3d, r28	; 61
    1c7a:	de bf       	out	0x3e, r29	; 62
    1c7c:	89 83       	std	Y+1, r24	; 0x01
    1c7e:	9a 83       	std	Y+2, r25	; 0x02
    1c80:	6b 83       	std	Y+3, r22	; 0x03
    1c82:	7c 83       	std	Y+4, r23	; 0x04
    1c84:	4d 83       	std	Y+5, r20	; 0x05
    1c86:	2e 83       	std	Y+6, r18	; 0x06
    1c88:	0f 83       	std	Y+7, r16	; 0x07
    1c8a:	18 87       	std	Y+8, r17	; 0x08
    1c8c:	e9 86       	std	Y+9, r14	; 0x09
    1c8e:	fa 86       	std	Y+10, r15	; 0x0a
    1c90:	cb 86       	std	Y+11, r12	; 0x0b
    1c92:	dc 86       	std	Y+12, r13	; 0x0c
    1c94:	ad 86       	std	Y+13, r10	; 0x0d
    1c96:	be 86       	std	Y+14, r11	; 0x0e
    1c98:	8f 86       	std	Y+15, r8	; 0x0f
    1c9a:	98 8a       	std	Y+16, r9	; 0x10
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    1c9c:	00 d0       	rcall	.+0      	; 0x1c9e <CO_collectSeismic3Axises+0x44>
    1c9e:	0f 92       	push	r0
    1ca0:	8d b7       	in	r24, 0x3d	; 61
    1ca2:	9e b7       	in	r25, 0x3e	; 62
    1ca4:	01 96       	adiw	r24, 0x01	; 1
    1ca6:	49 81       	ldd	r20, Y+1	; 0x01
    1ca8:	5a 81       	ldd	r21, Y+2	; 0x02
    1caa:	2b 81       	ldd	r18, Y+3	; 0x03
    1cac:	3c 81       	ldd	r19, Y+4	; 0x04
    1cae:	ef 80       	ldd	r14, Y+7	; 0x07
    1cb0:	f8 84       	ldd	r15, Y+8	; 0x08
    1cb2:	c9 84       	ldd	r12, Y+9	; 0x09
    1cb4:	da 84       	ldd	r13, Y+10	; 0x0a
    1cb6:	ab 85       	ldd	r26, Y+11	; 0x0b
    1cb8:	bc 85       	ldd	r27, Y+12	; 0x0c
    1cba:	ed 85       	ldd	r30, Y+13	; 0x0d
    1cbc:	fe 85       	ldd	r31, Y+14	; 0x0e
    1cbe:	e9 8b       	std	Y+17, r30	; 0x11
    1cc0:	fa 8b       	std	Y+18, r31	; 0x12
    1cc2:	6f 85       	ldd	r22, Y+15	; 0x0f
    1cc4:	78 89       	ldd	r23, Y+16	; 0x10
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	60 83       	st	Z, r22
    1cca:	71 83       	std	Z+1, r23	; 0x01
    1ccc:	6a a1       	lds	r22, 0x4a
    1cce:	7b a1       	lds	r23, 0x4b
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	62 83       	std	Z+2, r22	; 0x02
    1cd4:	73 83       	std	Z+3, r23	; 0x03
    1cd6:	84 ec       	ldi	r24, 0xC4	; 196
    1cd8:	ba 01       	movw	r22, r20
    1cda:	a9 01       	movw	r20, r18
    1cdc:	2d 81       	ldd	r18, Y+5	; 0x05
    1cde:	0e 81       	ldd	r16, Y+6	; 0x06
    1ce0:	5d 01       	movw	r10, r26
    1ce2:	89 88       	ldd	r8, Y+17	; 0x11
    1ce4:	9a 88       	ldd	r9, Y+18	; 0x12
    1ce6:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <CO_collectSeismic3Axises_ext>
    1cea:	0f 90       	pop	r0
    1cec:	0f 90       	pop	r0
    1cee:	0f 90       	pop	r0
    1cf0:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    1cf2:	62 96       	adiw	r28, 0x12	; 18
    1cf4:	cd bf       	out	0x3d, r28	; 61
    1cf6:	de bf       	out	0x3e, r29	; 62
    1cf8:	df 91       	pop	r29
    1cfa:	cf 91       	pop	r28
    1cfc:	1f 91       	pop	r17
    1cfe:	0f 91       	pop	r16
    1d00:	ff 90       	pop	r15
    1d02:	ef 90       	pop	r14
    1d04:	df 90       	pop	r13
    1d06:	cf 90       	pop	r12
    1d08:	bf 90       	pop	r11
    1d0a:	af 90       	pop	r10
    1d0c:	9f 90       	pop	r9
    1d0e:	8f 90       	pop	r8
    1d10:	08 95       	ret

00001d12 <CO_collectSeismic3Axises_ext>:
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    1d12:	8f 92       	push	r8
    1d14:	9f 92       	push	r9
    1d16:	af 92       	push	r10
    1d18:	bf 92       	push	r11
    1d1a:	cf 92       	push	r12
    1d1c:	df 92       	push	r13
    1d1e:	ef 92       	push	r14
    1d20:	ff 92       	push	r15
    1d22:	0f 93       	push	r16
    1d24:	1f 93       	push	r17
    1d26:	cf 93       	push	r28
    1d28:	df 93       	push	r29
    1d2a:	cd b7       	in	r28, 0x3d	; 61
    1d2c:	de b7       	in	r29, 0x3e	; 62
    1d2e:	2f 97       	sbiw	r28, 0x0f	; 15
    1d30:	cd bf       	out	0x3d, r28	; 61
    1d32:	de bf       	out	0x3e, r29	; 62
    1d34:	89 83       	std	Y+1, r24	; 0x01
    1d36:	6a 83       	std	Y+2, r22	; 0x02
    1d38:	7b 83       	std	Y+3, r23	; 0x03
    1d3a:	4c 83       	std	Y+4, r20	; 0x04
    1d3c:	5d 83       	std	Y+5, r21	; 0x05
    1d3e:	2e 83       	std	Y+6, r18	; 0x06
    1d40:	0f 83       	std	Y+7, r16	; 0x07
    1d42:	e8 86       	std	Y+8, r14	; 0x08
    1d44:	f9 86       	std	Y+9, r15	; 0x09
    1d46:	ca 86       	std	Y+10, r12	; 0x0a
    1d48:	db 86       	std	Y+11, r13	; 0x0b
    1d4a:	ac 86       	std	Y+12, r10	; 0x0c
    1d4c:	bd 86       	std	Y+13, r11	; 0x0d
    1d4e:	8e 86       	std	Y+14, r8	; 0x0e
    1d50:	9f 86       	std	Y+15, r9	; 0x0f
	
	ADC_BUFFER = DataArray;
    1d52:	89 a1       	lds	r24, 0x49
    1d54:	9a a1       	lds	r25, 0x4a
    1d56:	80 93 71 50 	sts	0x5071, r24
    1d5a:	90 93 72 50 	sts	0x5072, r25
	ADC_Sampling_Finished = 0;
    1d5e:	10 92 d4 50 	sts	0x50D4, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1d68:	8a 81       	ldd	r24, Y+2	; 0x02
    1d6a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	90 81       	ld	r25, Z
    1d70:	85 e0       	ldi	r24, 0x05	; 5
    1d72:	69 2f       	mov	r22, r25
    1d74:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1d78:	8a 81       	ldd	r24, Y+2	; 0x02
    1d7a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d7c:	01 96       	adiw	r24, 0x01	; 1
    1d7e:	fc 01       	movw	r30, r24
    1d80:	90 81       	ld	r25, Z
    1d82:	86 e0       	ldi	r24, 0x06	; 6
    1d84:	69 2f       	mov	r22, r25
    1d86:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d8e:	02 96       	adiw	r24, 0x02	; 2
    1d90:	fc 01       	movw	r30, r24
    1d92:	90 81       	ld	r25, Z
    1d94:	87 e0       	ldi	r24, 0x07	; 7
    1d96:	69 2f       	mov	r22, r25
    1d98:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <set_ampGain>
	set_filter(filterConfig);
    1d9c:	89 81       	ldd	r24, Y+1	; 0x01
    1d9e:	0e 94 2a 0a 	call	0x1454	; 0x1454 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1da2:	8f 81       	ldd	r24, Y+7	; 0x07
    1da4:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1da8:	84 e0       	ldi	r24, 0x04	; 4
    1daa:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1dae:	80 ec       	ldi	r24, 0xC0	; 192
    1db0:	98 e0       	ldi	r25, 0x08	; 8
    1db2:	24 e5       	ldi	r18, 0x54	; 84
    1db4:	fc 01       	movw	r30, r24
    1db6:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1db8:	81 e0       	ldi	r24, 0x01	; 1
    1dba:	0e 94 aa 0a 	call	0x1554	; 0x1554 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1dbe:	85 e0       	ldi	r24, 0x05	; 5
    1dc0:	0e 94 4d 1a 	call	0x349a	; 0x349a <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1dc4:	80 ea       	ldi	r24, 0xA0	; 160
    1dc6:	96 e0       	ldi	r25, 0x06	; 6
    1dc8:	22 e0       	ldi	r18, 0x02	; 2
    1dca:	fc 01       	movw	r30, r24
    1dcc:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1dce:	80 ea       	ldi	r24, 0xA0	; 160
    1dd0:	96 e0       	ldi	r25, 0x06	; 6
    1dd2:	21 e0       	ldi	r18, 0x01	; 1
    1dd4:	fc 01       	movw	r30, r24
    1dd6:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1dd8:	80 e8       	ldi	r24, 0x80	; 128
    1dda:	91 e0       	ldi	r25, 0x01	; 1
    1ddc:	28 e7       	ldi	r18, 0x78	; 120
    1dde:	fc 01       	movw	r30, r24
    1de0:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1de2:	80 e0       	ldi	r24, 0x00	; 0
    1de4:	98 e0       	ldi	r25, 0x08	; 8
    1de6:	20 ef       	ldi	r18, 0xF0	; 240
    1de8:	fc 01       	movw	r30, r24
    1dea:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1dec:	80 e0       	ldi	r24, 0x00	; 0
    1dee:	98 e0       	ldi	r25, 0x08	; 8
    1df0:	28 85       	ldd	r18, Y+8	; 0x08
    1df2:	39 85       	ldd	r19, Y+9	; 0x09
    1df4:	fc 01       	movw	r30, r24
    1df6:	20 a7       	lds	r18, 0x70
    1df8:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1dfa:	80 e0       	ldi	r24, 0x00	; 0
    1dfc:	98 e0       	ldi	r25, 0x08	; 8
    1dfe:	2a 85       	ldd	r18, Y+10	; 0x0a
    1e00:	3b 85       	ldd	r19, Y+11	; 0x0b
    1e02:	fc 01       	movw	r30, r24
    1e04:	22 a7       	lds	r18, 0x72
    1e06:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	98 e0       	ldi	r25, 0x08	; 8
    1e0c:	2c 85       	ldd	r18, Y+12	; 0x0c
    1e0e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1e10:	fc 01       	movw	r30, r24
    1e12:	24 a7       	lds	r18, 0x74
    1e14:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1e16:	80 e0       	ldi	r24, 0x00	; 0
    1e18:	98 e0       	ldi	r25, 0x08	; 8
    1e1a:	2e 85       	ldd	r18, Y+14	; 0x0e
    1e1c:	3f 85       	ldd	r19, Y+15	; 0x0f
    1e1e:	fc 01       	movw	r30, r24
    1e20:	26 a7       	lds	r18, 0x76
    1e22:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1e24:	80 e0       	ldi	r24, 0x00	; 0
    1e26:	98 e0       	ldi	r25, 0x08	; 8
    1e28:	2e 81       	ldd	r18, Y+6	; 0x06
    1e2a:	22 2f       	mov	r18, r18
    1e2c:	30 e0       	ldi	r19, 0x00	; 0
    1e2e:	21 50       	subi	r18, 0x01	; 1
    1e30:	30 40       	sbci	r19, 0x00	; 0
    1e32:	fc 01       	movw	r30, r24
    1e34:	26 a3       	lds	r18, 0x56
    1e36:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1e38:	80 e0       	ldi	r24, 0x00	; 0
    1e3a:	98 e0       	ldi	r25, 0x08	; 8
    1e3c:	22 e0       	ldi	r18, 0x02	; 2
    1e3e:	fc 01       	movw	r30, r24
    1e40:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1e42:	80 e0       	ldi	r24, 0x00	; 0
    1e44:	98 e0       	ldi	r25, 0x08	; 8
    1e46:	2f ef       	ldi	r18, 0xFF	; 255
    1e48:	fc 01       	movw	r30, r24
    1e4a:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1e4c:	80 e0       	ldi	r24, 0x00	; 0
    1e4e:	98 e0       	ldi	r25, 0x08	; 8
    1e50:	20 e0       	ldi	r18, 0x00	; 0
    1e52:	38 e0       	ldi	r19, 0x08	; 8
    1e54:	f9 01       	movw	r30, r18
    1e56:	20 81       	ld	r18, Z
    1e58:	20 7f       	andi	r18, 0xF0	; 240
    1e5a:	28 60       	ori	r18, 0x08	; 8
    1e5c:	fc 01       	movw	r30, r24
    1e5e:	20 83       	st	Z, r18

	sampleCount = 0;
    1e60:	10 92 73 50 	sts	0x5073, r1
    1e64:	10 92 74 50 	sts	0x5074, r1
    1e68:	10 92 75 50 	sts	0x5075, r1
    1e6c:	10 92 76 50 	sts	0x5076, r1
	SPICount = 0;
    1e70:	10 92 cd 50 	sts	0x50CD, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1e74:	80 e0       	ldi	r24, 0x00	; 0
    1e76:	80 93 3a 21 	sts	0x213A, r24
    1e7a:	80 93 39 21 	sts	0x2139, r24
    1e7e:	80 93 38 21 	sts	0x2138, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1e82:	80 ea       	ldi	r24, 0xA0	; 160
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	20 ea       	ldi	r18, 0xA0	; 160
    1e88:	30 e0       	ldi	r19, 0x00	; 0
    1e8a:	f9 01       	movw	r30, r18
    1e8c:	22 81       	ldd	r18, Z+2	; 0x02
    1e8e:	26 60       	ori	r18, 0x06	; 6
    1e90:	fc 01       	movw	r30, r24
    1e92:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1e94:	78 94       	sei

	SPICS(TRUE);
    1e96:	81 e0       	ldi	r24, 0x01	; 1
    1e98:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1e9c:	80 e8       	ldi	r24, 0x80	; 128
    1e9e:	96 e0       	ldi	r25, 0x06	; 6
    1ea0:	20 e2       	ldi	r18, 0x20	; 32
    1ea2:	fc 01       	movw	r30, r24
    1ea4:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1ea6:	80 e4       	ldi	r24, 0x40	; 64
    1ea8:	9a e0       	ldi	r25, 0x0A	; 10
    1eaa:	23 e2       	ldi	r18, 0x23	; 35
    1eac:	fc 01       	movw	r30, r24
    1eae:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    1eb0:	00 e4       	ldi	r16, 0x40	; 64
    1eb2:	1a e0       	ldi	r17, 0x0A	; 10
    1eb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1eb6:	9d 81       	ldd	r25, Y+5	; 0x05
    1eb8:	9c 01       	movw	r18, r24
    1eba:	40 e0       	ldi	r20, 0x00	; 0
    1ebc:	50 e0       	ldi	r21, 0x00	; 0
    1ebe:	80 e8       	ldi	r24, 0x80	; 128
    1ec0:	94 e8       	ldi	r25, 0x84	; 132
    1ec2:	ae e1       	ldi	r26, 0x1E	; 30
    1ec4:	b0 e0       	ldi	r27, 0x00	; 0
    1ec6:	bc 01       	movw	r22, r24
    1ec8:	cd 01       	movw	r24, r26
    1eca:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    1ece:	da 01       	movw	r26, r20
    1ed0:	c9 01       	movw	r24, r18
    1ed2:	f8 01       	movw	r30, r16
    1ed4:	86 a3       	lds	r24, 0x56
    1ed6:	97 a3       	lds	r25, 0x57
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    1ed8:	00 e4       	ldi	r16, 0x40	; 64
    1eda:	1a e0       	ldi	r17, 0x0A	; 10
    1edc:	8c 81       	ldd	r24, Y+4	; 0x04
    1ede:	9d 81       	ldd	r25, Y+5	; 0x05
    1ee0:	9c 01       	movw	r18, r24
    1ee2:	40 e0       	ldi	r20, 0x00	; 0
    1ee4:	50 e0       	ldi	r21, 0x00	; 0
    1ee6:	80 e4       	ldi	r24, 0x40	; 64
    1ee8:	92 e4       	ldi	r25, 0x42	; 66
    1eea:	af e0       	ldi	r26, 0x0F	; 15
    1eec:	b0 e0       	ldi	r27, 0x00	; 0
    1eee:	bc 01       	movw	r22, r24
    1ef0:	cd 01       	movw	r24, r26
    1ef2:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    1ef6:	da 01       	movw	r26, r20
    1ef8:	c9 01       	movw	r24, r18
    1efa:	f8 01       	movw	r30, r16
    1efc:	82 af       	sts	0x72, r24
    1efe:	93 af       	sts	0x73, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    1f00:	80 e4       	ldi	r24, 0x40	; 64
    1f02:	98 e0       	ldi	r25, 0x08	; 8
    1f04:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1f06:	38 a1       	lds	r19, 0x48
    1f08:	fc 01       	movw	r30, r24
    1f0a:	26 a3       	lds	r18, 0x56
    1f0c:	37 a3       	lds	r19, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    1f0e:	80 e8       	ldi	r24, 0x80	; 128
    1f10:	91 e0       	ldi	r25, 0x01	; 1
    1f12:	20 ed       	ldi	r18, 0xD0	; 208
    1f14:	fc 01       	movw	r30, r24
    1f16:	21 83       	std	Z+1, r18	; 0x01
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1f18:	80 e4       	ldi	r24, 0x40	; 64
    1f1a:	98 e0       	ldi	r25, 0x08	; 8
    1f1c:	20 e4       	ldi	r18, 0x40	; 64
    1f1e:	38 e0       	ldi	r19, 0x08	; 8
    1f20:	f9 01       	movw	r30, r18
    1f22:	20 81       	ld	r18, Z
    1f24:	20 7f       	andi	r18, 0xF0	; 240
    1f26:	29 60       	ori	r18, 0x09	; 9
    1f28:	fc 01       	movw	r30, r24
    1f2a:	20 83       	st	Z, r18
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1f2c:	80 e4       	ldi	r24, 0x40	; 64
    1f2e:	9a e0       	ldi	r25, 0x0A	; 10
    1f30:	20 e4       	ldi	r18, 0x40	; 64
    1f32:	3a e0       	ldi	r19, 0x0A	; 10
    1f34:	f9 01       	movw	r30, r18
    1f36:	20 81       	ld	r18, Z
    1f38:	20 7f       	andi	r18, 0xF0	; 240
    1f3a:	21 60       	ori	r18, 0x01	; 1
    1f3c:	fc 01       	movw	r30, r24
    1f3e:	20 83       	st	Z, r18
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    1f40:	2f 96       	adiw	r28, 0x0f	; 15
    1f42:	cd bf       	out	0x3d, r28	; 61
    1f44:	de bf       	out	0x3e, r29	; 62
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	ff 90       	pop	r15
    1f50:	ef 90       	pop	r14
    1f52:	df 90       	pop	r13
    1f54:	cf 90       	pop	r12
    1f56:	bf 90       	pop	r11
    1f58:	af 90       	pop	r10
    1f5a:	9f 90       	pop	r9
    1f5c:	8f 90       	pop	r8
    1f5e:	08 95       	ret

00001f60 <__vector_16>:

//first averaging point
ISR(TCC0_CCA_vect) {
    1f60:	1f 92       	push	r1
    1f62:	0f 92       	push	r0
    1f64:	0f b6       	in	r0, 0x3f	; 63
    1f66:	0f 92       	push	r0
    1f68:	00 90 3b 00 	lds	r0, 0x003B
    1f6c:	0f 92       	push	r0
    1f6e:	11 24       	eor	r1, r1
    1f70:	2f 93       	push	r18
    1f72:	3f 93       	push	r19
    1f74:	4f 93       	push	r20
    1f76:	5f 93       	push	r21
    1f78:	6f 93       	push	r22
    1f7a:	7f 93       	push	r23
    1f7c:	8f 93       	push	r24
    1f7e:	9f 93       	push	r25
    1f80:	af 93       	push	r26
    1f82:	bf 93       	push	r27
    1f84:	ef 93       	push	r30
    1f86:	ff 93       	push	r31
    1f88:	cf 93       	push	r28
    1f8a:	df 93       	push	r29
    1f8c:	cd b7       	in	r28, 0x3d	; 61
    1f8e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f90:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
}
    1f94:	df 91       	pop	r29
    1f96:	cf 91       	pop	r28
    1f98:	ff 91       	pop	r31
    1f9a:	ef 91       	pop	r30
    1f9c:	bf 91       	pop	r27
    1f9e:	af 91       	pop	r26
    1fa0:	9f 91       	pop	r25
    1fa2:	8f 91       	pop	r24
    1fa4:	7f 91       	pop	r23
    1fa6:	6f 91       	pop	r22
    1fa8:	5f 91       	pop	r21
    1faa:	4f 91       	pop	r20
    1fac:	3f 91       	pop	r19
    1fae:	2f 91       	pop	r18
    1fb0:	0f 90       	pop	r0
    1fb2:	00 92 3b 00 	sts	0x003B, r0
    1fb6:	0f 90       	pop	r0
    1fb8:	0f be       	out	0x3f, r0	; 63
    1fba:	0f 90       	pop	r0
    1fbc:	1f 90       	pop	r1
    1fbe:	18 95       	reti

00001fc0 <__vector_17>:

//second averaging point
ISR(TCC0_CCB_vect) {
    1fc0:	1f 92       	push	r1
    1fc2:	0f 92       	push	r0
    1fc4:	0f b6       	in	r0, 0x3f	; 63
    1fc6:	0f 92       	push	r0
    1fc8:	00 90 3b 00 	lds	r0, 0x003B
    1fcc:	0f 92       	push	r0
    1fce:	11 24       	eor	r1, r1
    1fd0:	2f 93       	push	r18
    1fd2:	3f 93       	push	r19
    1fd4:	4f 93       	push	r20
    1fd6:	5f 93       	push	r21
    1fd8:	6f 93       	push	r22
    1fda:	7f 93       	push	r23
    1fdc:	8f 93       	push	r24
    1fde:	9f 93       	push	r25
    1fe0:	af 93       	push	r26
    1fe2:	bf 93       	push	r27
    1fe4:	ef 93       	push	r30
    1fe6:	ff 93       	push	r31
    1fe8:	cf 93       	push	r28
    1fea:	df 93       	push	r29
    1fec:	cd b7       	in	r28, 0x3d	; 61
    1fee:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1ff0:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
}
    1ff4:	df 91       	pop	r29
    1ff6:	cf 91       	pop	r28
    1ff8:	ff 91       	pop	r31
    1ffa:	ef 91       	pop	r30
    1ffc:	bf 91       	pop	r27
    1ffe:	af 91       	pop	r26
    2000:	9f 91       	pop	r25
    2002:	8f 91       	pop	r24
    2004:	7f 91       	pop	r23
    2006:	6f 91       	pop	r22
    2008:	5f 91       	pop	r21
    200a:	4f 91       	pop	r20
    200c:	3f 91       	pop	r19
    200e:	2f 91       	pop	r18
    2010:	0f 90       	pop	r0
    2012:	00 92 3b 00 	sts	0x003B, r0
    2016:	0f 90       	pop	r0
    2018:	0f be       	out	0x3f, r0	; 63
    201a:	0f 90       	pop	r0
    201c:	1f 90       	pop	r1
    201e:	18 95       	reti

00002020 <__vector_18>:

//third averaging point
ISR(TCC0_CCC_vect) {
    2020:	1f 92       	push	r1
    2022:	0f 92       	push	r0
    2024:	0f b6       	in	r0, 0x3f	; 63
    2026:	0f 92       	push	r0
    2028:	00 90 3b 00 	lds	r0, 0x003B
    202c:	0f 92       	push	r0
    202e:	11 24       	eor	r1, r1
    2030:	2f 93       	push	r18
    2032:	3f 93       	push	r19
    2034:	4f 93       	push	r20
    2036:	5f 93       	push	r21
    2038:	6f 93       	push	r22
    203a:	7f 93       	push	r23
    203c:	8f 93       	push	r24
    203e:	9f 93       	push	r25
    2040:	af 93       	push	r26
    2042:	bf 93       	push	r27
    2044:	ef 93       	push	r30
    2046:	ff 93       	push	r31
    2048:	cf 93       	push	r28
    204a:	df 93       	push	r29
    204c:	cd b7       	in	r28, 0x3d	; 61
    204e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2050:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
}
    2054:	df 91       	pop	r29
    2056:	cf 91       	pop	r28
    2058:	ff 91       	pop	r31
    205a:	ef 91       	pop	r30
    205c:	bf 91       	pop	r27
    205e:	af 91       	pop	r26
    2060:	9f 91       	pop	r25
    2062:	8f 91       	pop	r24
    2064:	7f 91       	pop	r23
    2066:	6f 91       	pop	r22
    2068:	5f 91       	pop	r21
    206a:	4f 91       	pop	r20
    206c:	3f 91       	pop	r19
    206e:	2f 91       	pop	r18
    2070:	0f 90       	pop	r0
    2072:	00 92 3b 00 	sts	0x003B, r0
    2076:	0f 90       	pop	r0
    2078:	0f be       	out	0x3f, r0	; 63
    207a:	0f 90       	pop	r0
    207c:	1f 90       	pop	r1
    207e:	18 95       	reti

00002080 <__vector_19>:

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    2080:	1f 92       	push	r1
    2082:	0f 92       	push	r0
    2084:	0f b6       	in	r0, 0x3f	; 63
    2086:	0f 92       	push	r0
    2088:	00 90 3b 00 	lds	r0, 0x003B
    208c:	0f 92       	push	r0
    208e:	11 24       	eor	r1, r1
    2090:	2f 93       	push	r18
    2092:	3f 93       	push	r19
    2094:	4f 93       	push	r20
    2096:	5f 93       	push	r21
    2098:	6f 93       	push	r22
    209a:	7f 93       	push	r23
    209c:	8f 93       	push	r24
    209e:	9f 93       	push	r25
    20a0:	af 93       	push	r26
    20a2:	bf 93       	push	r27
    20a4:	ef 93       	push	r30
    20a6:	ff 93       	push	r31
    20a8:	cf 93       	push	r28
    20aa:	df 93       	push	r29
    20ac:	cd b7       	in	r28, 0x3d	; 61
    20ae:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    20b0:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
	SPICount = 0;
    20b4:	10 92 cd 50 	sts	0x50CD, r1
	if(PORTB.OUT & PIN1_bm) {
    20b8:	80 e2       	ldi	r24, 0x20	; 32
    20ba:	96 e0       	ldi	r25, 0x06	; 6
    20bc:	fc 01       	movw	r30, r24
    20be:	84 81       	ldd	r24, Z+4	; 0x04
    20c0:	88 2f       	mov	r24, r24
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	82 70       	andi	r24, 0x02	; 2
    20c6:	90 70       	andi	r25, 0x00	; 0
    20c8:	00 97       	sbiw	r24, 0x00	; 0
    20ca:	b1 f0       	breq	.+44     	; 0x20f8 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    20cc:	80 e0       	ldi	r24, 0x00	; 0
    20ce:	96 e0       	ldi	r25, 0x06	; 6
    20d0:	fc 01       	movw	r30, r24
    20d2:	84 81       	ldd	r24, Z+4	; 0x04
    20d4:	88 2f       	mov	r24, r24
    20d6:	90 e0       	ldi	r25, 0x00	; 0
    20d8:	80 74       	andi	r24, 0x40	; 64
    20da:	90 70       	andi	r25, 0x00	; 0
    20dc:	00 97       	sbiw	r24, 0x00	; 0
    20de:	31 f0       	breq	.+12     	; 0x20ec <__vector_19+0x6c>
    20e0:	80 e2       	ldi	r24, 0x20	; 32
    20e2:	96 e0       	ldi	r25, 0x06	; 6
    20e4:	22 e0       	ldi	r18, 0x02	; 2
    20e6:	fc 01       	movw	r30, r24
    20e8:	27 83       	std	Z+7, r18	; 0x07
    20ea:	10 c0       	rjmp	.+32     	; 0x210c <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	96 e0       	ldi	r25, 0x06	; 6
    20f0:	20 e4       	ldi	r18, 0x40	; 64
    20f2:	fc 01       	movw	r30, r24
    20f4:	27 83       	std	Z+7, r18	; 0x07
    20f6:	0a c0       	rjmp	.+20     	; 0x210c <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    20f8:	80 e0       	ldi	r24, 0x00	; 0
    20fa:	96 e0       	ldi	r25, 0x06	; 6
    20fc:	20 e4       	ldi	r18, 0x40	; 64
    20fe:	fc 01       	movw	r30, r24
    2100:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2102:	80 e2       	ldi	r24, 0x20	; 32
    2104:	96 e0       	ldi	r25, 0x06	; 6
    2106:	22 e0       	ldi	r18, 0x02	; 2
    2108:	fc 01       	movw	r30, r24
    210a:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    210c:	df 91       	pop	r29
    210e:	cf 91       	pop	r28
    2110:	ff 91       	pop	r31
    2112:	ef 91       	pop	r30
    2114:	bf 91       	pop	r27
    2116:	af 91       	pop	r26
    2118:	9f 91       	pop	r25
    211a:	8f 91       	pop	r24
    211c:	7f 91       	pop	r23
    211e:	6f 91       	pop	r22
    2120:	5f 91       	pop	r21
    2122:	4f 91       	pop	r20
    2124:	3f 91       	pop	r19
    2126:	2f 91       	pop	r18
    2128:	0f 90       	pop	r0
    212a:	00 92 3b 00 	sts	0x003B, r0
    212e:	0f 90       	pop	r0
    2130:	0f be       	out	0x3f, r0	; 63
    2132:	0f 90       	pop	r0
    2134:	1f 90       	pop	r1
    2136:	18 95       	reti

00002138 <__vector_14>:

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    2138:	1f 92       	push	r1
    213a:	0f 92       	push	r0
    213c:	0f b6       	in	r0, 0x3f	; 63
    213e:	0f 92       	push	r0
    2140:	00 90 3b 00 	lds	r0, 0x003B
    2144:	0f 92       	push	r0
    2146:	11 24       	eor	r1, r1
    2148:	2f 93       	push	r18
    214a:	3f 93       	push	r19
    214c:	4f 93       	push	r20
    214e:	5f 93       	push	r21
    2150:	6f 93       	push	r22
    2152:	7f 93       	push	r23
    2154:	8f 93       	push	r24
    2156:	9f 93       	push	r25
    2158:	af 93       	push	r26
    215a:	bf 93       	push	r27
    215c:	ef 93       	push	r30
    215e:	ff 93       	push	r31
    2160:	cf 93       	push	r28
    2162:	df 93       	push	r29
    2164:	cd b7       	in	r28, 0x3d	; 61
    2166:	de b7       	in	r29, 0x3e	; 62
    2168:	29 97       	sbiw	r28, 0x09	; 9
    216a:	cd bf       	out	0x3d, r28	; 61
    216c:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    216e:	1a 82       	std	Y+2, r1	; 0x02
    2170:	1b 82       	std	Y+3, r1	; 0x03
    2172:	1c 82       	std	Y+4, r1	; 0x04
    2174:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2176:	19 82       	std	Y+1, r1	; 0x01
    2178:	4f c0       	rjmp	.+158    	; 0x2218 <__vector_14+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    217a:	89 81       	ldd	r24, Y+1	; 0x01
    217c:	88 2f       	mov	r24, r24
    217e:	90 e0       	ldi	r25, 0x00	; 0
    2180:	8c 59       	subi	r24, 0x9C	; 156
    2182:	9f 4a       	sbci	r25, 0xAF	; 175
    2184:	fc 01       	movw	r30, r24
    2186:	80 81       	ld	r24, Z
    2188:	88 23       	and	r24, r24
    218a:	3c f4       	brge	.+14     	; 0x219a <__vector_14+0x62>
    218c:	ce 01       	movw	r24, r28
    218e:	06 96       	adiw	r24, 0x06	; 6
    2190:	03 96       	adiw	r24, 0x03	; 3
    2192:	2f ef       	ldi	r18, 0xFF	; 255
    2194:	fc 01       	movw	r30, r24
    2196:	20 83       	st	Z, r18
    2198:	05 c0       	rjmp	.+10     	; 0x21a4 <__vector_14+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    219a:	ce 01       	movw	r24, r28
    219c:	06 96       	adiw	r24, 0x06	; 6
    219e:	03 96       	adiw	r24, 0x03	; 3
    21a0:	fc 01       	movw	r30, r24
    21a2:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    21a4:	ce 01       	movw	r24, r28
    21a6:	06 96       	adiw	r24, 0x06	; 6
    21a8:	02 96       	adiw	r24, 0x02	; 2
    21aa:	29 81       	ldd	r18, Y+1	; 0x01
    21ac:	22 2f       	mov	r18, r18
    21ae:	30 e0       	ldi	r19, 0x00	; 0
    21b0:	2c 59       	subi	r18, 0x9C	; 156
    21b2:	3f 4a       	sbci	r19, 0xAF	; 175
    21b4:	f9 01       	movw	r30, r18
    21b6:	20 81       	ld	r18, Z
    21b8:	fc 01       	movw	r30, r24
    21ba:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    21bc:	ce 01       	movw	r24, r28
    21be:	06 96       	adiw	r24, 0x06	; 6
    21c0:	01 96       	adiw	r24, 0x01	; 1
    21c2:	29 81       	ldd	r18, Y+1	; 0x01
    21c4:	22 2f       	mov	r18, r18
    21c6:	30 e0       	ldi	r19, 0x00	; 0
    21c8:	2f 5f       	subi	r18, 0xFF	; 255
    21ca:	3f 4f       	sbci	r19, 0xFF	; 255
    21cc:	2c 59       	subi	r18, 0x9C	; 156
    21ce:	3f 4a       	sbci	r19, 0xAF	; 175
    21d0:	f9 01       	movw	r30, r18
    21d2:	20 81       	ld	r18, Z
    21d4:	fc 01       	movw	r30, r24
    21d6:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    21d8:	ce 01       	movw	r24, r28
    21da:	06 96       	adiw	r24, 0x06	; 6
    21dc:	29 81       	ldd	r18, Y+1	; 0x01
    21de:	22 2f       	mov	r18, r18
    21e0:	30 e0       	ldi	r19, 0x00	; 0
    21e2:	2e 5f       	subi	r18, 0xFE	; 254
    21e4:	3f 4f       	sbci	r19, 0xFF	; 255
    21e6:	2c 59       	subi	r18, 0x9C	; 156
    21e8:	3f 4a       	sbci	r19, 0xAF	; 175
    21ea:	f9 01       	movw	r30, r18
    21ec:	20 81       	ld	r18, Z
    21ee:	fc 01       	movw	r30, r24
    21f0:	20 83       	st	Z, r18
		sum += currentSample;
    21f2:	2a 81       	ldd	r18, Y+2	; 0x02
    21f4:	3b 81       	ldd	r19, Y+3	; 0x03
    21f6:	4c 81       	ldd	r20, Y+4	; 0x04
    21f8:	5d 81       	ldd	r21, Y+5	; 0x05
    21fa:	8e 81       	ldd	r24, Y+6	; 0x06
    21fc:	9f 81       	ldd	r25, Y+7	; 0x07
    21fe:	a8 85       	ldd	r26, Y+8	; 0x08
    2200:	b9 85       	ldd	r27, Y+9	; 0x09
    2202:	82 0f       	add	r24, r18
    2204:	93 1f       	adc	r25, r19
    2206:	a4 1f       	adc	r26, r20
    2208:	b5 1f       	adc	r27, r21
    220a:	8a 83       	std	Y+2, r24	; 0x02
    220c:	9b 83       	std	Y+3, r25	; 0x03
    220e:	ac 83       	std	Y+4, r26	; 0x04
    2210:	bd 83       	std	Y+5, r27	; 0x05
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2212:	89 81       	ldd	r24, Y+1	; 0x01
    2214:	8d 5f       	subi	r24, 0xFD	; 253
    2216:	89 83       	std	Y+1, r24	; 0x01
    2218:	89 81       	ldd	r24, Y+1	; 0x01
    221a:	8c 30       	cpi	r24, 0x0C	; 12
    221c:	08 f4       	brcc	.+2      	; 0x2220 <__vector_14+0xe8>
    221e:	ad cf       	rjmp	.-166    	; 0x217a <__vector_14+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    2220:	8a 81       	ldd	r24, Y+2	; 0x02
    2222:	9b 81       	ldd	r25, Y+3	; 0x03
    2224:	ac 81       	ldd	r26, Y+4	; 0x04
    2226:	bd 81       	ldd	r27, Y+5	; 0x05
    2228:	24 e0       	ldi	r18, 0x04	; 4
    222a:	30 e0       	ldi	r19, 0x00	; 0
    222c:	40 e0       	ldi	r20, 0x00	; 0
    222e:	50 e0       	ldi	r21, 0x00	; 0
    2230:	bc 01       	movw	r22, r24
    2232:	cd 01       	movw	r24, r26
    2234:	0e 94 12 5d 	call	0xba24	; 0xba24 <__divmodsi4>
    2238:	da 01       	movw	r26, r20
    223a:	c9 01       	movw	r24, r18
    223c:	8a 83       	std	Y+2, r24	; 0x02
    223e:	9b 83       	std	Y+3, r25	; 0x03
    2240:	ac 83       	std	Y+4, r26	; 0x04
    2242:	bd 83       	std	Y+5, r27	; 0x05
	ADC_BUFFER[sampleCount] = currentSample;
    2244:	20 91 71 50 	lds	r18, 0x5071
    2248:	30 91 72 50 	lds	r19, 0x5072
    224c:	80 91 73 50 	lds	r24, 0x5073
    2250:	90 91 74 50 	lds	r25, 0x5074
    2254:	a0 91 75 50 	lds	r26, 0x5075
    2258:	b0 91 76 50 	lds	r27, 0x5076
    225c:	88 0f       	add	r24, r24
    225e:	99 1f       	adc	r25, r25
    2260:	88 0f       	add	r24, r24
    2262:	99 1f       	adc	r25, r25
    2264:	28 0f       	add	r18, r24
    2266:	39 1f       	adc	r19, r25
    2268:	8e 81       	ldd	r24, Y+6	; 0x06
    226a:	9f 81       	ldd	r25, Y+7	; 0x07
    226c:	a8 85       	ldd	r26, Y+8	; 0x08
    226e:	b9 85       	ldd	r27, Y+9	; 0x09
    2270:	f9 01       	movw	r30, r18
    2272:	80 83       	st	Z, r24
    2274:	91 83       	std	Z+1, r25	; 0x01
    2276:	a2 83       	std	Z+2, r26	; 0x02
    2278:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    227a:	80 91 73 50 	lds	r24, 0x5073
    227e:	90 91 74 50 	lds	r25, 0x5074
    2282:	a0 91 75 50 	lds	r26, 0x5075
    2286:	b0 91 76 50 	lds	r27, 0x5076
    228a:	01 96       	adiw	r24, 0x01	; 1
    228c:	a1 1d       	adc	r26, r1
    228e:	b1 1d       	adc	r27, r1
    2290:	80 93 73 50 	sts	0x5073, r24
    2294:	90 93 74 50 	sts	0x5074, r25
    2298:	a0 93 75 50 	sts	0x5075, r26
    229c:	b0 93 76 50 	sts	0x5076, r27

}
    22a0:	29 96       	adiw	r28, 0x09	; 9
    22a2:	cd bf       	out	0x3d, r28	; 61
    22a4:	de bf       	out	0x3e, r29	; 62
    22a6:	df 91       	pop	r29
    22a8:	cf 91       	pop	r28
    22aa:	ff 91       	pop	r31
    22ac:	ef 91       	pop	r30
    22ae:	bf 91       	pop	r27
    22b0:	af 91       	pop	r26
    22b2:	9f 91       	pop	r25
    22b4:	8f 91       	pop	r24
    22b6:	7f 91       	pop	r23
    22b8:	6f 91       	pop	r22
    22ba:	5f 91       	pop	r21
    22bc:	4f 91       	pop	r20
    22be:	3f 91       	pop	r19
    22c0:	2f 91       	pop	r18
    22c2:	0f 90       	pop	r0
    22c4:	00 92 3b 00 	sts	0x003B, r0
    22c8:	0f 90       	pop	r0
    22ca:	0f be       	out	0x3f, r0	; 63
    22cc:	0f 90       	pop	r0
    22ce:	1f 90       	pop	r1
    22d0:	18 95       	reti

000022d2 <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    22d2:	8f 92       	push	r8
    22d4:	9f 92       	push	r9
    22d6:	af 92       	push	r10
    22d8:	bf 92       	push	r11
    22da:	cf 92       	push	r12
    22dc:	df 92       	push	r13
    22de:	ef 92       	push	r14
    22e0:	ff 92       	push	r15
    22e2:	0f 93       	push	r16
    22e4:	cf 93       	push	r28
    22e6:	df 93       	push	r29
    22e8:	cd b7       	in	r28, 0x3d	; 61
    22ea:	de b7       	in	r29, 0x3e	; 62
    22ec:	60 97       	sbiw	r28, 0x10	; 16
    22ee:	cd bf       	out	0x3d, r28	; 61
    22f0:	de bf       	out	0x3e, r29	; 62
    22f2:	89 83       	std	Y+1, r24	; 0x01
    22f4:	6a 83       	std	Y+2, r22	; 0x02
    22f6:	4b 83       	std	Y+3, r20	; 0x03
    22f8:	5c 83       	std	Y+4, r21	; 0x04
    22fa:	2d 83       	std	Y+5, r18	; 0x05
    22fc:	0e 83       	std	Y+6, r16	; 0x06
    22fe:	ef 82       	std	Y+7, r14	; 0x07
    2300:	f8 86       	std	Y+8, r15	; 0x08
    2302:	c9 86       	std	Y+9, r12	; 0x09
    2304:	da 86       	std	Y+10, r13	; 0x0a
    2306:	ab 86       	std	Y+11, r10	; 0x0b
    2308:	bc 86       	std	Y+12, r11	; 0x0c
    230a:	8d 86       	std	Y+13, r8	; 0x0d
    230c:	9e 86       	std	Y+14, r9	; 0x0e
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    230e:	00 d0       	rcall	.+0      	; 0x2310 <CO_collectSeismic1Channel+0x3e>
    2310:	00 d0       	rcall	.+0      	; 0x2312 <CO_collectSeismic1Channel+0x40>
    2312:	8d b7       	in	r24, 0x3d	; 61
    2314:	9e b7       	in	r25, 0x3e	; 62
    2316:	01 96       	adiw	r24, 0x01	; 1
    2318:	2b 81       	ldd	r18, Y+3	; 0x03
    231a:	3c 81       	ldd	r19, Y+4	; 0x04
    231c:	cf 80       	ldd	r12, Y+7	; 0x07
    231e:	d8 84       	ldd	r13, Y+8	; 0x08
    2320:	a9 85       	ldd	r26, Y+9	; 0x09
    2322:	ba 85       	ldd	r27, Y+10	; 0x0a
    2324:	eb 85       	ldd	r30, Y+11	; 0x0b
    2326:	fc 85       	ldd	r31, Y+12	; 0x0c
    2328:	ef 87       	std	Y+15, r30	; 0x0f
    232a:	f8 8b       	std	Y+16, r31	; 0x10
    232c:	4d 85       	ldd	r20, Y+13	; 0x0d
    232e:	5e 85       	ldd	r21, Y+14	; 0x0e
    2330:	fc 01       	movw	r30, r24
    2332:	40 83       	st	Z, r20
    2334:	51 83       	std	Z+1, r21	; 0x01
    2336:	4f 8d       	ldd	r20, Y+31	; 0x1f
    2338:	58 a1       	lds	r21, 0x48
    233a:	fc 01       	movw	r30, r24
    233c:	42 83       	std	Z+2, r20	; 0x02
    233e:	53 83       	std	Z+3, r21	; 0x03
    2340:	49 a1       	lds	r20, 0x49
    2342:	5a a1       	lds	r21, 0x4a
    2344:	fc 01       	movw	r30, r24
    2346:	44 83       	std	Z+4, r20	; 0x04
    2348:	55 83       	std	Z+5, r21	; 0x05
    234a:	89 81       	ldd	r24, Y+1	; 0x01
    234c:	64 ec       	ldi	r22, 0xC4	; 196
    234e:	4a 81       	ldd	r20, Y+2	; 0x02
    2350:	0d 81       	ldd	r16, Y+5	; 0x05
    2352:	ee 80       	ldd	r14, Y+6	; 0x06
    2354:	5d 01       	movw	r10, r26
    2356:	8f 84       	ldd	r8, Y+15	; 0x0f
    2358:	98 88       	ldd	r9, Y+16	; 0x10
    235a:	0e 94 c4 11 	call	0x2388	; 0x2388 <CO_collectSeismic1Channel_ext>
    235e:	4d b7       	in	r20, 0x3d	; 61
    2360:	5e b7       	in	r21, 0x3e	; 62
    2362:	4a 5f       	subi	r20, 0xFA	; 250
    2364:	5f 4f       	sbci	r21, 0xFF	; 255
    2366:	4d bf       	out	0x3d, r20	; 61
    2368:	5e bf       	out	0x3e, r21	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    236a:	60 96       	adiw	r28, 0x10	; 16
    236c:	cd bf       	out	0x3d, r28	; 61
    236e:	de bf       	out	0x3e, r29	; 62
    2370:	df 91       	pop	r29
    2372:	cf 91       	pop	r28
    2374:	0f 91       	pop	r16
    2376:	ff 90       	pop	r15
    2378:	ef 90       	pop	r14
    237a:	df 90       	pop	r13
    237c:	cf 90       	pop	r12
    237e:	bf 90       	pop	r11
    2380:	af 90       	pop	r10
    2382:	9f 90       	pop	r9
    2384:	8f 90       	pop	r8
    2386:	08 95       	ret

00002388 <CO_collectSeismic1Channel_ext>:

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2388:	8f 92       	push	r8
    238a:	9f 92       	push	r9
    238c:	af 92       	push	r10
    238e:	bf 92       	push	r11
    2390:	cf 92       	push	r12
    2392:	df 92       	push	r13
    2394:	ef 92       	push	r14
    2396:	0f 93       	push	r16
    2398:	1f 93       	push	r17
    239a:	cf 93       	push	r28
    239c:	df 93       	push	r29
    239e:	cd b7       	in	r28, 0x3d	; 61
    23a0:	de b7       	in	r29, 0x3e	; 62
    23a2:	2d 97       	sbiw	r28, 0x0d	; 13
    23a4:	cd bf       	out	0x3d, r28	; 61
    23a6:	de bf       	out	0x3e, r29	; 62
    23a8:	89 83       	std	Y+1, r24	; 0x01
    23aa:	6a 83       	std	Y+2, r22	; 0x02
    23ac:	4b 83       	std	Y+3, r20	; 0x03
    23ae:	2c 83       	std	Y+4, r18	; 0x04
    23b0:	3d 83       	std	Y+5, r19	; 0x05
    23b2:	0e 83       	std	Y+6, r16	; 0x06
    23b4:	ef 82       	std	Y+7, r14	; 0x07
    23b6:	c8 86       	std	Y+8, r12	; 0x08
    23b8:	d9 86       	std	Y+9, r13	; 0x09
    23ba:	aa 86       	std	Y+10, r10	; 0x0a
    23bc:	bb 86       	std	Y+11, r11	; 0x0b
    23be:	8c 86       	std	Y+12, r8	; 0x0c
    23c0:	9d 86       	std	Y+13, r9	; 0x0d
	
	ADC_BUFFER=DataArray;
    23c2:	88 a1       	lds	r24, 0x48
    23c4:	99 a1       	lds	r25, 0x49
    23c6:	80 93 71 50 	sts	0x5071, r24
    23ca:	90 93 72 50 	sts	0x5072, r25
	ADC_Sampling_Finished = 0;
    23ce:	10 92 d4 50 	sts	0x50D4, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    23d2:	81 e0       	ldi	r24, 0x01	; 1
    23d4:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    23d8:	89 81       	ldd	r24, Y+1	; 0x01
    23da:	6b 81       	ldd	r22, Y+3	; 0x03
    23dc:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <set_ampGain>
	set_filter(filterConfig);
    23e0:	8a 81       	ldd	r24, Y+2	; 0x02
    23e2:	0e 94 2a 0a 	call	0x1454	; 0x1454 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    23e6:	8f 81       	ldd	r24, Y+7	; 0x07
    23e8:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    23ec:	84 e0       	ldi	r24, 0x04	; 4
    23ee:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    23f2:	80 ec       	ldi	r24, 0xC0	; 192
    23f4:	98 e0       	ldi	r25, 0x08	; 8
    23f6:	24 e5       	ldi	r18, 0x54	; 84
    23f8:	fc 01       	movw	r30, r24
    23fa:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	0e 94 aa 0a 	call	0x1554	; 0x1554 <enableADCMUX>
	setADCInput(channel);
    2402:	89 81       	ldd	r24, Y+1	; 0x01
    2404:	0e 94 4d 1a 	call	0x349a	; 0x349a <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2408:	80 ea       	ldi	r24, 0xA0	; 160
    240a:	96 e0       	ldi	r25, 0x06	; 6
    240c:	22 e0       	ldi	r18, 0x02	; 2
    240e:	fc 01       	movw	r30, r24
    2410:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2412:	80 ea       	ldi	r24, 0xA0	; 160
    2414:	96 e0       	ldi	r25, 0x06	; 6
    2416:	21 e0       	ldi	r18, 0x01	; 1
    2418:	fc 01       	movw	r30, r24
    241a:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    241c:	80 e8       	ldi	r24, 0x80	; 128
    241e:	91 e0       	ldi	r25, 0x01	; 1
    2420:	28 e7       	ldi	r18, 0x78	; 120
    2422:	fc 01       	movw	r30, r24
    2424:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2426:	80 e0       	ldi	r24, 0x00	; 0
    2428:	99 e0       	ldi	r25, 0x09	; 9
    242a:	20 ef       	ldi	r18, 0xF0	; 240
    242c:	fc 01       	movw	r30, r24
    242e:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    2430:	80 e0       	ldi	r24, 0x00	; 0
    2432:	99 e0       	ldi	r25, 0x09	; 9
    2434:	28 85       	ldd	r18, Y+8	; 0x08
    2436:	39 85       	ldd	r19, Y+9	; 0x09
    2438:	fc 01       	movw	r30, r24
    243a:	20 a7       	lds	r18, 0x70
    243c:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    243e:	80 e0       	ldi	r24, 0x00	; 0
    2440:	99 e0       	ldi	r25, 0x09	; 9
    2442:	2a 85       	ldd	r18, Y+10	; 0x0a
    2444:	3b 85       	ldd	r19, Y+11	; 0x0b
    2446:	fc 01       	movw	r30, r24
    2448:	22 a7       	lds	r18, 0x72
    244a:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    244c:	80 e0       	ldi	r24, 0x00	; 0
    244e:	99 e0       	ldi	r25, 0x09	; 9
    2450:	2c 85       	ldd	r18, Y+12	; 0x0c
    2452:	3d 85       	ldd	r19, Y+13	; 0x0d
    2454:	fc 01       	movw	r30, r24
    2456:	24 a7       	lds	r18, 0x74
    2458:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    245a:	80 e0       	ldi	r24, 0x00	; 0
    245c:	99 e0       	ldi	r25, 0x09	; 9
    245e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2460:	3d 8d       	ldd	r19, Y+29	; 0x1d
    2462:	fc 01       	movw	r30, r24
    2464:	26 a7       	lds	r18, 0x76
    2466:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2468:	80 e0       	ldi	r24, 0x00	; 0
    246a:	99 e0       	ldi	r25, 0x09	; 9
    246c:	2e 81       	ldd	r18, Y+6	; 0x06
    246e:	22 2f       	mov	r18, r18
    2470:	30 e0       	ldi	r19, 0x00	; 0
    2472:	21 50       	subi	r18, 0x01	; 1
    2474:	30 40       	sbci	r19, 0x00	; 0
    2476:	fc 01       	movw	r30, r24
    2478:	26 a3       	lds	r18, 0x56
    247a:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    247c:	80 e0       	ldi	r24, 0x00	; 0
    247e:	99 e0       	ldi	r25, 0x09	; 9
    2480:	22 e0       	ldi	r18, 0x02	; 2
    2482:	fc 01       	movw	r30, r24
    2484:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2486:	80 e0       	ldi	r24, 0x00	; 0
    2488:	99 e0       	ldi	r25, 0x09	; 9
    248a:	2f ef       	ldi	r18, 0xFF	; 255
    248c:	fc 01       	movw	r30, r24
    248e:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2490:	80 e0       	ldi	r24, 0x00	; 0
    2492:	99 e0       	ldi	r25, 0x09	; 9
    2494:	20 e0       	ldi	r18, 0x00	; 0
    2496:	39 e0       	ldi	r19, 0x09	; 9
    2498:	f9 01       	movw	r30, r18
    249a:	20 81       	ld	r18, Z
    249c:	20 7f       	andi	r18, 0xF0	; 240
    249e:	28 60       	ori	r18, 0x08	; 8
    24a0:	fc 01       	movw	r30, r24
    24a2:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    24a4:	10 92 73 50 	sts	0x5073, r1
    24a8:	10 92 74 50 	sts	0x5074, r1
    24ac:	10 92 75 50 	sts	0x5075, r1
    24b0:	10 92 76 50 	sts	0x5076, r1
	SPICount = 0;
    24b4:	10 92 cd 50 	sts	0x50CD, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    24b8:	80 ea       	ldi	r24, 0xA0	; 160
    24ba:	90 e0       	ldi	r25, 0x00	; 0
    24bc:	20 ea       	ldi	r18, 0xA0	; 160
    24be:	30 e0       	ldi	r19, 0x00	; 0
    24c0:	f9 01       	movw	r30, r18
    24c2:	22 81       	ldd	r18, Z+2	; 0x02
    24c4:	26 60       	ori	r18, 0x06	; 6
    24c6:	fc 01       	movw	r30, r24
    24c8:	22 83       	std	Z+2, r18	; 0x02
	sei();
    24ca:	78 94       	sei

	SPICS(TRUE);
    24cc:	81 e0       	ldi	r24, 0x01	; 1
    24ce:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    24d2:	80 e8       	ldi	r24, 0x80	; 128
    24d4:	96 e0       	ldi	r25, 0x06	; 6
    24d6:	20 e2       	ldi	r18, 0x20	; 32
    24d8:	fc 01       	movw	r30, r24
    24da:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    24dc:	80 e4       	ldi	r24, 0x40	; 64
    24de:	9a e0       	ldi	r25, 0x0A	; 10
    24e0:	23 e2       	ldi	r18, 0x23	; 35
    24e2:	fc 01       	movw	r30, r24
    24e4:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    24e6:	00 e4       	ldi	r16, 0x40	; 64
    24e8:	1a e0       	ldi	r17, 0x0A	; 10
    24ea:	8c 81       	ldd	r24, Y+4	; 0x04
    24ec:	9d 81       	ldd	r25, Y+5	; 0x05
    24ee:	9c 01       	movw	r18, r24
    24f0:	40 e0       	ldi	r20, 0x00	; 0
    24f2:	50 e0       	ldi	r21, 0x00	; 0
    24f4:	80 e8       	ldi	r24, 0x80	; 128
    24f6:	94 e8       	ldi	r25, 0x84	; 132
    24f8:	ae e1       	ldi	r26, 0x1E	; 30
    24fa:	b0 e0       	ldi	r27, 0x00	; 0
    24fc:	bc 01       	movw	r22, r24
    24fe:	cd 01       	movw	r24, r26
    2500:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    2504:	da 01       	movw	r26, r20
    2506:	c9 01       	movw	r24, r18
    2508:	f8 01       	movw	r30, r16
    250a:	86 a3       	lds	r24, 0x56
    250c:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    250e:	00 e4       	ldi	r16, 0x40	; 64
    2510:	1a e0       	ldi	r17, 0x0A	; 10
    2512:	8c 81       	ldd	r24, Y+4	; 0x04
    2514:	9d 81       	ldd	r25, Y+5	; 0x05
    2516:	9c 01       	movw	r18, r24
    2518:	40 e0       	ldi	r20, 0x00	; 0
    251a:	50 e0       	ldi	r21, 0x00	; 0
    251c:	80 e4       	ldi	r24, 0x40	; 64
    251e:	92 e4       	ldi	r25, 0x42	; 66
    2520:	af e0       	ldi	r26, 0x0F	; 15
    2522:	b0 e0       	ldi	r27, 0x00	; 0
    2524:	bc 01       	movw	r22, r24
    2526:	cd 01       	movw	r24, r26
    2528:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    252c:	da 01       	movw	r26, r20
    252e:	c9 01       	movw	r24, r18
    2530:	f8 01       	movw	r30, r16
    2532:	82 af       	sts	0x72, r24
    2534:	93 af       	sts	0x73, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2536:	80 e4       	ldi	r24, 0x40	; 64
    2538:	98 e0       	ldi	r25, 0x08	; 8
    253a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    253c:	3f 8d       	ldd	r19, Y+31	; 0x1f
    253e:	fc 01       	movw	r30, r24
    2540:	26 a3       	lds	r18, 0x56
    2542:	37 a3       	lds	r19, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2544:	80 e8       	ldi	r24, 0x80	; 128
    2546:	91 e0       	ldi	r25, 0x01	; 1
    2548:	20 ed       	ldi	r18, 0xD0	; 208
    254a:	fc 01       	movw	r30, r24
    254c:	21 83       	std	Z+1, r18	; 0x01
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    254e:	80 e4       	ldi	r24, 0x40	; 64
    2550:	98 e0       	ldi	r25, 0x08	; 8
    2552:	20 e4       	ldi	r18, 0x40	; 64
    2554:	38 e0       	ldi	r19, 0x08	; 8
    2556:	f9 01       	movw	r30, r18
    2558:	20 81       	ld	r18, Z
    255a:	20 7f       	andi	r18, 0xF0	; 240
    255c:	29 60       	ori	r18, 0x09	; 9
    255e:	fc 01       	movw	r30, r24
    2560:	20 83       	st	Z, r18
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2562:	80 e4       	ldi	r24, 0x40	; 64
    2564:	9a e0       	ldi	r25, 0x0A	; 10
    2566:	20 e4       	ldi	r18, 0x40	; 64
    2568:	3a e0       	ldi	r19, 0x0A	; 10
    256a:	f9 01       	movw	r30, r18
    256c:	20 81       	ld	r18, Z
    256e:	20 7f       	andi	r18, 0xF0	; 240
    2570:	21 60       	ori	r18, 0x01	; 1
    2572:	fc 01       	movw	r30, r24
    2574:	20 83       	st	Z, r18
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2576:	2d 96       	adiw	r28, 0x0d	; 13
    2578:	cd bf       	out	0x3d, r28	; 61
    257a:	de bf       	out	0x3e, r29	; 62
    257c:	df 91       	pop	r29
    257e:	cf 91       	pop	r28
    2580:	1f 91       	pop	r17
    2582:	0f 91       	pop	r16
    2584:	ef 90       	pop	r14
    2586:	df 90       	pop	r13
    2588:	cf 90       	pop	r12
    258a:	bf 90       	pop	r11
    258c:	af 90       	pop	r10
    258e:	9f 90       	pop	r9
    2590:	8f 90       	pop	r8
    2592:	08 95       	ret

00002594 <__vector_79>:

//first averaging point
ISR(TCD0_CCA_vect) {
    2594:	1f 92       	push	r1
    2596:	0f 92       	push	r0
    2598:	0f b6       	in	r0, 0x3f	; 63
    259a:	0f 92       	push	r0
    259c:	00 90 3b 00 	lds	r0, 0x003B
    25a0:	0f 92       	push	r0
    25a2:	11 24       	eor	r1, r1
    25a4:	2f 93       	push	r18
    25a6:	3f 93       	push	r19
    25a8:	4f 93       	push	r20
    25aa:	5f 93       	push	r21
    25ac:	6f 93       	push	r22
    25ae:	7f 93       	push	r23
    25b0:	8f 93       	push	r24
    25b2:	9f 93       	push	r25
    25b4:	af 93       	push	r26
    25b6:	bf 93       	push	r27
    25b8:	ef 93       	push	r30
    25ba:	ff 93       	push	r31
    25bc:	cf 93       	push	r28
    25be:	df 93       	push	r29
    25c0:	cd b7       	in	r28, 0x3d	; 61
    25c2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    25c4:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
}
    25c8:	df 91       	pop	r29
    25ca:	cf 91       	pop	r28
    25cc:	ff 91       	pop	r31
    25ce:	ef 91       	pop	r30
    25d0:	bf 91       	pop	r27
    25d2:	af 91       	pop	r26
    25d4:	9f 91       	pop	r25
    25d6:	8f 91       	pop	r24
    25d8:	7f 91       	pop	r23
    25da:	6f 91       	pop	r22
    25dc:	5f 91       	pop	r21
    25de:	4f 91       	pop	r20
    25e0:	3f 91       	pop	r19
    25e2:	2f 91       	pop	r18
    25e4:	0f 90       	pop	r0
    25e6:	00 92 3b 00 	sts	0x003B, r0
    25ea:	0f 90       	pop	r0
    25ec:	0f be       	out	0x3f, r0	; 63
    25ee:	0f 90       	pop	r0
    25f0:	1f 90       	pop	r1
    25f2:	18 95       	reti

000025f4 <__vector_80>:
//second averaging point
ISR(TCD0_CCB_vect) {
    25f4:	1f 92       	push	r1
    25f6:	0f 92       	push	r0
    25f8:	0f b6       	in	r0, 0x3f	; 63
    25fa:	0f 92       	push	r0
    25fc:	00 90 3b 00 	lds	r0, 0x003B
    2600:	0f 92       	push	r0
    2602:	11 24       	eor	r1, r1
    2604:	2f 93       	push	r18
    2606:	3f 93       	push	r19
    2608:	4f 93       	push	r20
    260a:	5f 93       	push	r21
    260c:	6f 93       	push	r22
    260e:	7f 93       	push	r23
    2610:	8f 93       	push	r24
    2612:	9f 93       	push	r25
    2614:	af 93       	push	r26
    2616:	bf 93       	push	r27
    2618:	ef 93       	push	r30
    261a:	ff 93       	push	r31
    261c:	cf 93       	push	r28
    261e:	df 93       	push	r29
    2620:	cd b7       	in	r28, 0x3d	; 61
    2622:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2624:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
}
    2628:	df 91       	pop	r29
    262a:	cf 91       	pop	r28
    262c:	ff 91       	pop	r31
    262e:	ef 91       	pop	r30
    2630:	bf 91       	pop	r27
    2632:	af 91       	pop	r26
    2634:	9f 91       	pop	r25
    2636:	8f 91       	pop	r24
    2638:	7f 91       	pop	r23
    263a:	6f 91       	pop	r22
    263c:	5f 91       	pop	r21
    263e:	4f 91       	pop	r20
    2640:	3f 91       	pop	r19
    2642:	2f 91       	pop	r18
    2644:	0f 90       	pop	r0
    2646:	00 92 3b 00 	sts	0x003B, r0
    264a:	0f 90       	pop	r0
    264c:	0f be       	out	0x3f, r0	; 63
    264e:	0f 90       	pop	r0
    2650:	1f 90       	pop	r1
    2652:	18 95       	reti

00002654 <__vector_81>:

//third averaging point
ISR(TCD0_CCC_vect) {
    2654:	1f 92       	push	r1
    2656:	0f 92       	push	r0
    2658:	0f b6       	in	r0, 0x3f	; 63
    265a:	0f 92       	push	r0
    265c:	00 90 3b 00 	lds	r0, 0x003B
    2660:	0f 92       	push	r0
    2662:	11 24       	eor	r1, r1
    2664:	2f 93       	push	r18
    2666:	3f 93       	push	r19
    2668:	4f 93       	push	r20
    266a:	5f 93       	push	r21
    266c:	6f 93       	push	r22
    266e:	7f 93       	push	r23
    2670:	8f 93       	push	r24
    2672:	9f 93       	push	r25
    2674:	af 93       	push	r26
    2676:	bf 93       	push	r27
    2678:	ef 93       	push	r30
    267a:	ff 93       	push	r31
    267c:	cf 93       	push	r28
    267e:	df 93       	push	r29
    2680:	cd b7       	in	r28, 0x3d	; 61
    2682:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2684:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
}
    2688:	df 91       	pop	r29
    268a:	cf 91       	pop	r28
    268c:	ff 91       	pop	r31
    268e:	ef 91       	pop	r30
    2690:	bf 91       	pop	r27
    2692:	af 91       	pop	r26
    2694:	9f 91       	pop	r25
    2696:	8f 91       	pop	r24
    2698:	7f 91       	pop	r23
    269a:	6f 91       	pop	r22
    269c:	5f 91       	pop	r21
    269e:	4f 91       	pop	r20
    26a0:	3f 91       	pop	r19
    26a2:	2f 91       	pop	r18
    26a4:	0f 90       	pop	r0
    26a6:	00 92 3b 00 	sts	0x003B, r0
    26aa:	0f 90       	pop	r0
    26ac:	0f be       	out	0x3f, r0	; 63
    26ae:	0f 90       	pop	r0
    26b0:	1f 90       	pop	r1
    26b2:	18 95       	reti

000026b4 <__vector_82>:

//final averaging point
ISR(TCD0_CCD_vect) {
    26b4:	1f 92       	push	r1
    26b6:	0f 92       	push	r0
    26b8:	0f b6       	in	r0, 0x3f	; 63
    26ba:	0f 92       	push	r0
    26bc:	00 90 3b 00 	lds	r0, 0x003B
    26c0:	0f 92       	push	r0
    26c2:	11 24       	eor	r1, r1
    26c4:	2f 93       	push	r18
    26c6:	3f 93       	push	r19
    26c8:	4f 93       	push	r20
    26ca:	5f 93       	push	r21
    26cc:	6f 93       	push	r22
    26ce:	7f 93       	push	r23
    26d0:	8f 93       	push	r24
    26d2:	9f 93       	push	r25
    26d4:	af 93       	push	r26
    26d6:	bf 93       	push	r27
    26d8:	ef 93       	push	r30
    26da:	ff 93       	push	r31
    26dc:	cf 93       	push	r28
    26de:	df 93       	push	r29
    26e0:	cd b7       	in	r28, 0x3d	; 61
    26e2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    26e4:	0e 94 59 14 	call	0x28b2	; 0x28b2 <sampleCurrentChannel>
	SPICount = 0;
    26e8:	10 92 cd 50 	sts	0x50CD, r1
}
    26ec:	df 91       	pop	r29
    26ee:	cf 91       	pop	r28
    26f0:	ff 91       	pop	r31
    26f2:	ef 91       	pop	r30
    26f4:	bf 91       	pop	r27
    26f6:	af 91       	pop	r26
    26f8:	9f 91       	pop	r25
    26fa:	8f 91       	pop	r24
    26fc:	7f 91       	pop	r23
    26fe:	6f 91       	pop	r22
    2700:	5f 91       	pop	r21
    2702:	4f 91       	pop	r20
    2704:	3f 91       	pop	r19
    2706:	2f 91       	pop	r18
    2708:	0f 90       	pop	r0
    270a:	00 92 3b 00 	sts	0x003B, r0
    270e:	0f 90       	pop	r0
    2710:	0f be       	out	0x3f, r0	; 63
    2712:	0f 90       	pop	r0
    2714:	1f 90       	pop	r1
    2716:	18 95       	reti

00002718 <__vector_77>:

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2718:	1f 92       	push	r1
    271a:	0f 92       	push	r0
    271c:	0f b6       	in	r0, 0x3f	; 63
    271e:	0f 92       	push	r0
    2720:	00 90 3b 00 	lds	r0, 0x003B
    2724:	0f 92       	push	r0
    2726:	11 24       	eor	r1, r1
    2728:	2f 93       	push	r18
    272a:	3f 93       	push	r19
    272c:	4f 93       	push	r20
    272e:	5f 93       	push	r21
    2730:	6f 93       	push	r22
    2732:	7f 93       	push	r23
    2734:	8f 93       	push	r24
    2736:	9f 93       	push	r25
    2738:	af 93       	push	r26
    273a:	bf 93       	push	r27
    273c:	ef 93       	push	r30
    273e:	ff 93       	push	r31
    2740:	cf 93       	push	r28
    2742:	df 93       	push	r29
    2744:	cd b7       	in	r28, 0x3d	; 61
    2746:	de b7       	in	r29, 0x3e	; 62
    2748:	29 97       	sbiw	r28, 0x09	; 9
    274a:	cd bf       	out	0x3d, r28	; 61
    274c:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    274e:	1a 82       	std	Y+2, r1	; 0x02
    2750:	1b 82       	std	Y+3, r1	; 0x03
    2752:	1c 82       	std	Y+4, r1	; 0x04
    2754:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2756:	19 82       	std	Y+1, r1	; 0x01
    2758:	4f c0       	rjmp	.+158    	; 0x27f8 <__vector_77+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    275a:	89 81       	ldd	r24, Y+1	; 0x01
    275c:	88 2f       	mov	r24, r24
    275e:	90 e0       	ldi	r25, 0x00	; 0
    2760:	8c 59       	subi	r24, 0x9C	; 156
    2762:	9f 4a       	sbci	r25, 0xAF	; 175
    2764:	fc 01       	movw	r30, r24
    2766:	80 81       	ld	r24, Z
    2768:	88 23       	and	r24, r24
    276a:	3c f4       	brge	.+14     	; 0x277a <__vector_77+0x62>
    276c:	ce 01       	movw	r24, r28
    276e:	06 96       	adiw	r24, 0x06	; 6
    2770:	03 96       	adiw	r24, 0x03	; 3
    2772:	2f ef       	ldi	r18, 0xFF	; 255
    2774:	fc 01       	movw	r30, r24
    2776:	20 83       	st	Z, r18
    2778:	05 c0       	rjmp	.+10     	; 0x2784 <__vector_77+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    277a:	ce 01       	movw	r24, r28
    277c:	06 96       	adiw	r24, 0x06	; 6
    277e:	03 96       	adiw	r24, 0x03	; 3
    2780:	fc 01       	movw	r30, r24
    2782:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2784:	ce 01       	movw	r24, r28
    2786:	06 96       	adiw	r24, 0x06	; 6
    2788:	02 96       	adiw	r24, 0x02	; 2
    278a:	29 81       	ldd	r18, Y+1	; 0x01
    278c:	22 2f       	mov	r18, r18
    278e:	30 e0       	ldi	r19, 0x00	; 0
    2790:	2c 59       	subi	r18, 0x9C	; 156
    2792:	3f 4a       	sbci	r19, 0xAF	; 175
    2794:	f9 01       	movw	r30, r18
    2796:	20 81       	ld	r18, Z
    2798:	fc 01       	movw	r30, r24
    279a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    279c:	ce 01       	movw	r24, r28
    279e:	06 96       	adiw	r24, 0x06	; 6
    27a0:	01 96       	adiw	r24, 0x01	; 1
    27a2:	29 81       	ldd	r18, Y+1	; 0x01
    27a4:	22 2f       	mov	r18, r18
    27a6:	30 e0       	ldi	r19, 0x00	; 0
    27a8:	2f 5f       	subi	r18, 0xFF	; 255
    27aa:	3f 4f       	sbci	r19, 0xFF	; 255
    27ac:	2c 59       	subi	r18, 0x9C	; 156
    27ae:	3f 4a       	sbci	r19, 0xAF	; 175
    27b0:	f9 01       	movw	r30, r18
    27b2:	20 81       	ld	r18, Z
    27b4:	fc 01       	movw	r30, r24
    27b6:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    27b8:	ce 01       	movw	r24, r28
    27ba:	06 96       	adiw	r24, 0x06	; 6
    27bc:	29 81       	ldd	r18, Y+1	; 0x01
    27be:	22 2f       	mov	r18, r18
    27c0:	30 e0       	ldi	r19, 0x00	; 0
    27c2:	2e 5f       	subi	r18, 0xFE	; 254
    27c4:	3f 4f       	sbci	r19, 0xFF	; 255
    27c6:	2c 59       	subi	r18, 0x9C	; 156
    27c8:	3f 4a       	sbci	r19, 0xAF	; 175
    27ca:	f9 01       	movw	r30, r18
    27cc:	20 81       	ld	r18, Z
    27ce:	fc 01       	movw	r30, r24
    27d0:	20 83       	st	Z, r18
		sum += currentSample;
    27d2:	2a 81       	ldd	r18, Y+2	; 0x02
    27d4:	3b 81       	ldd	r19, Y+3	; 0x03
    27d6:	4c 81       	ldd	r20, Y+4	; 0x04
    27d8:	5d 81       	ldd	r21, Y+5	; 0x05
    27da:	8e 81       	ldd	r24, Y+6	; 0x06
    27dc:	9f 81       	ldd	r25, Y+7	; 0x07
    27de:	a8 85       	ldd	r26, Y+8	; 0x08
    27e0:	b9 85       	ldd	r27, Y+9	; 0x09
    27e2:	82 0f       	add	r24, r18
    27e4:	93 1f       	adc	r25, r19
    27e6:	a4 1f       	adc	r26, r20
    27e8:	b5 1f       	adc	r27, r21
    27ea:	8a 83       	std	Y+2, r24	; 0x02
    27ec:	9b 83       	std	Y+3, r25	; 0x03
    27ee:	ac 83       	std	Y+4, r26	; 0x04
    27f0:	bd 83       	std	Y+5, r27	; 0x05
ISR(TCD0_OVF_vect) {

	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    27f2:	89 81       	ldd	r24, Y+1	; 0x01
    27f4:	8d 5f       	subi	r24, 0xFD	; 253
    27f6:	89 83       	std	Y+1, r24	; 0x01
    27f8:	89 81       	ldd	r24, Y+1	; 0x01
    27fa:	8c 30       	cpi	r24, 0x0C	; 12
    27fc:	08 f4       	brcc	.+2      	; 0x2800 <__vector_77+0xe8>
    27fe:	ad cf       	rjmp	.-166    	; 0x275a <__vector_77+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    2800:	8a 81       	ldd	r24, Y+2	; 0x02
    2802:	9b 81       	ldd	r25, Y+3	; 0x03
    2804:	ac 81       	ldd	r26, Y+4	; 0x04
    2806:	bd 81       	ldd	r27, Y+5	; 0x05
    2808:	24 e0       	ldi	r18, 0x04	; 4
    280a:	30 e0       	ldi	r19, 0x00	; 0
    280c:	40 e0       	ldi	r20, 0x00	; 0
    280e:	50 e0       	ldi	r21, 0x00	; 0
    2810:	bc 01       	movw	r22, r24
    2812:	cd 01       	movw	r24, r26
    2814:	0e 94 12 5d 	call	0xba24	; 0xba24 <__divmodsi4>
    2818:	da 01       	movw	r26, r20
    281a:	c9 01       	movw	r24, r18
    281c:	8a 83       	std	Y+2, r24	; 0x02
    281e:	9b 83       	std	Y+3, r25	; 0x03
    2820:	ac 83       	std	Y+4, r26	; 0x04
    2822:	bd 83       	std	Y+5, r27	; 0x05
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    2824:	20 91 71 50 	lds	r18, 0x5071
    2828:	30 91 72 50 	lds	r19, 0x5072
    282c:	80 91 73 50 	lds	r24, 0x5073
    2830:	90 91 74 50 	lds	r25, 0x5074
    2834:	a0 91 75 50 	lds	r26, 0x5075
    2838:	b0 91 76 50 	lds	r27, 0x5076
    283c:	88 0f       	add	r24, r24
    283e:	99 1f       	adc	r25, r25
    2840:	88 0f       	add	r24, r24
    2842:	99 1f       	adc	r25, r25
    2844:	28 0f       	add	r18, r24
    2846:	39 1f       	adc	r19, r25
    2848:	8a 81       	ldd	r24, Y+2	; 0x02
    284a:	9b 81       	ldd	r25, Y+3	; 0x03
    284c:	ac 81       	ldd	r26, Y+4	; 0x04
    284e:	bd 81       	ldd	r27, Y+5	; 0x05
    2850:	f9 01       	movw	r30, r18
    2852:	80 83       	st	Z, r24
    2854:	91 83       	std	Z+1, r25	; 0x01
    2856:	a2 83       	std	Z+2, r26	; 0x02
    2858:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    285a:	80 91 73 50 	lds	r24, 0x5073
    285e:	90 91 74 50 	lds	r25, 0x5074
    2862:	a0 91 75 50 	lds	r26, 0x5075
    2866:	b0 91 76 50 	lds	r27, 0x5076
    286a:	01 96       	adiw	r24, 0x01	; 1
    286c:	a1 1d       	adc	r26, r1
    286e:	b1 1d       	adc	r27, r1
    2870:	80 93 73 50 	sts	0x5073, r24
    2874:	90 93 74 50 	sts	0x5074, r25
    2878:	a0 93 75 50 	sts	0x5075, r26
    287c:	b0 93 76 50 	sts	0x5076, r27
}
    2880:	29 96       	adiw	r28, 0x09	; 9
    2882:	cd bf       	out	0x3d, r28	; 61
    2884:	de bf       	out	0x3e, r29	; 62
    2886:	df 91       	pop	r29
    2888:	cf 91       	pop	r28
    288a:	ff 91       	pop	r31
    288c:	ef 91       	pop	r30
    288e:	bf 91       	pop	r27
    2890:	af 91       	pop	r26
    2892:	9f 91       	pop	r25
    2894:	8f 91       	pop	r24
    2896:	7f 91       	pop	r23
    2898:	6f 91       	pop	r22
    289a:	5f 91       	pop	r21
    289c:	4f 91       	pop	r20
    289e:	3f 91       	pop	r19
    28a0:	2f 91       	pop	r18
    28a2:	0f 90       	pop	r0
    28a4:	00 92 3b 00 	sts	0x003B, r0
    28a8:	0f 90       	pop	r0
    28aa:	0f be       	out	0x3f, r0	; 63
    28ac:	0f 90       	pop	r0
    28ae:	1f 90       	pop	r1
    28b0:	18 95       	reti

000028b2 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
    28b2:	cf 93       	push	r28
    28b4:	df 93       	push	r29
    28b6:	cd b7       	in	r28, 0x3d	; 61
    28b8:	de b7       	in	r29, 0x3e	; 62
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    28ba:	80 ea       	ldi	r24, 0xA0	; 160
    28bc:	96 e0       	ldi	r25, 0x06	; 6
    28be:	22 e0       	ldi	r18, 0x02	; 2
    28c0:	fc 01       	movw	r30, r24
    28c2:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    28c4:	80 ec       	ldi	r24, 0xC0	; 192
    28c6:	98 e0       	ldi	r25, 0x08	; 8
    28c8:	2a ea       	ldi	r18, 0xAA	; 170
    28ca:	fc 01       	movw	r30, r24
    28cc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28ce:	00 00       	nop
    28d0:	80 ec       	ldi	r24, 0xC0	; 192
    28d2:	98 e0       	ldi	r25, 0x08	; 8
    28d4:	fc 01       	movw	r30, r24
    28d6:	82 81       	ldd	r24, Z+2	; 0x02
    28d8:	88 23       	and	r24, r24
    28da:	d4 f7       	brge	.-12     	; 0x28d0 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    28dc:	80 91 cd 50 	lds	r24, 0x50CD
    28e0:	88 2f       	mov	r24, r24
    28e2:	90 e0       	ldi	r25, 0x00	; 0
    28e4:	20 ec       	ldi	r18, 0xC0	; 192
    28e6:	38 e0       	ldi	r19, 0x08	; 8
    28e8:	f9 01       	movw	r30, r18
    28ea:	23 81       	ldd	r18, Z+3	; 0x03
    28ec:	8c 59       	subi	r24, 0x9C	; 156
    28ee:	9f 4a       	sbci	r25, 0xAF	; 175
    28f0:	fc 01       	movw	r30, r24
    28f2:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    28f4:	80 ec       	ldi	r24, 0xC0	; 192
    28f6:	98 e0       	ldi	r25, 0x08	; 8
    28f8:	2a ea       	ldi	r18, 0xAA	; 170
    28fa:	fc 01       	movw	r30, r24
    28fc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28fe:	00 00       	nop
    2900:	80 ec       	ldi	r24, 0xC0	; 192
    2902:	98 e0       	ldi	r25, 0x08	; 8
    2904:	fc 01       	movw	r30, r24
    2906:	82 81       	ldd	r24, Z+2	; 0x02
    2908:	88 23       	and	r24, r24
    290a:	d4 f7       	brge	.-12     	; 0x2900 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    290c:	80 91 cd 50 	lds	r24, 0x50CD
    2910:	88 2f       	mov	r24, r24
    2912:	90 e0       	ldi	r25, 0x00	; 0
    2914:	01 96       	adiw	r24, 0x01	; 1
    2916:	20 ec       	ldi	r18, 0xC0	; 192
    2918:	38 e0       	ldi	r19, 0x08	; 8
    291a:	f9 01       	movw	r30, r18
    291c:	23 81       	ldd	r18, Z+3	; 0x03
    291e:	8c 59       	subi	r24, 0x9C	; 156
    2920:	9f 4a       	sbci	r25, 0xAF	; 175
    2922:	fc 01       	movw	r30, r24
    2924:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2926:	80 ec       	ldi	r24, 0xC0	; 192
    2928:	98 e0       	ldi	r25, 0x08	; 8
    292a:	2a ea       	ldi	r18, 0xAA	; 170
    292c:	fc 01       	movw	r30, r24
    292e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2930:	00 00       	nop
    2932:	80 ec       	ldi	r24, 0xC0	; 192
    2934:	98 e0       	ldi	r25, 0x08	; 8
    2936:	fc 01       	movw	r30, r24
    2938:	82 81       	ldd	r24, Z+2	; 0x02
    293a:	88 23       	and	r24, r24
    293c:	d4 f7       	brge	.-12     	; 0x2932 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    293e:	80 91 cd 50 	lds	r24, 0x50CD
    2942:	88 2f       	mov	r24, r24
    2944:	90 e0       	ldi	r25, 0x00	; 0
    2946:	02 96       	adiw	r24, 0x02	; 2
    2948:	20 ec       	ldi	r18, 0xC0	; 192
    294a:	38 e0       	ldi	r19, 0x08	; 8
    294c:	f9 01       	movw	r30, r18
    294e:	23 81       	ldd	r18, Z+3	; 0x03
    2950:	8c 59       	subi	r24, 0x9C	; 156
    2952:	9f 4a       	sbci	r25, 0xAF	; 175
    2954:	fc 01       	movw	r30, r24
    2956:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2958:	80 ea       	ldi	r24, 0xA0	; 160
    295a:	96 e0       	ldi	r25, 0x06	; 6
    295c:	22 e0       	ldi	r18, 0x02	; 2
    295e:	fc 01       	movw	r30, r24
    2960:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2962:	80 91 cd 50 	lds	r24, 0x50CD
    2966:	8d 5f       	subi	r24, 0xFD	; 253
    2968:	80 93 cd 50 	sts	0x50CD, r24
}
    296c:	df 91       	pop	r29
    296e:	cf 91       	pop	r28
    2970:	08 95       	ret

00002972 <writeSE2FRAM>:

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2972:	cf 93       	push	r28
    2974:	df 93       	push	r29
    2976:	cd b7       	in	r28, 0x3d	; 61
    2978:	de b7       	in	r29, 0x3e	; 62
    297a:	29 97       	sbiw	r28, 0x09	; 9
    297c:	cd bf       	out	0x3d, r28	; 61
    297e:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2980:	1a 82       	std	Y+2, r1	; 0x02
    2982:	1b 82       	std	Y+3, r1	; 0x03
    2984:	1c 82       	std	Y+4, r1	; 0x04
    2986:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2988:	80 91 73 50 	lds	r24, 0x5073
    298c:	90 91 74 50 	lds	r25, 0x5074
    2990:	a0 91 75 50 	lds	r26, 0x5075
    2994:	b0 91 76 50 	lds	r27, 0x5076
    2998:	01 96       	adiw	r24, 0x01	; 1
    299a:	a1 1d       	adc	r26, r1
    299c:	b1 1d       	adc	r27, r1
    299e:	80 93 73 50 	sts	0x5073, r24
    29a2:	90 93 74 50 	sts	0x5074, r25
    29a6:	a0 93 75 50 	sts	0x5075, r26
    29aa:	b0 93 76 50 	sts	0x5076, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    29ae:	80 ec       	ldi	r24, 0xC0	; 192
    29b0:	98 e0       	ldi	r25, 0x08	; 8
    29b2:	20 ed       	ldi	r18, 0xD0	; 208
    29b4:	fc 01       	movw	r30, r24
    29b6:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    29b8:	19 82       	std	Y+1, r1	; 0x01
    29ba:	4f c0       	rjmp	.+158    	; 0x2a5a <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    29bc:	89 81       	ldd	r24, Y+1	; 0x01
    29be:	88 2f       	mov	r24, r24
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	8c 59       	subi	r24, 0x9C	; 156
    29c4:	9f 4a       	sbci	r25, 0xAF	; 175
    29c6:	fc 01       	movw	r30, r24
    29c8:	80 81       	ld	r24, Z
    29ca:	88 23       	and	r24, r24
    29cc:	3c f4       	brge	.+14     	; 0x29dc <writeSE2FRAM+0x6a>
    29ce:	ce 01       	movw	r24, r28
    29d0:	06 96       	adiw	r24, 0x06	; 6
    29d2:	03 96       	adiw	r24, 0x03	; 3
    29d4:	2f ef       	ldi	r18, 0xFF	; 255
    29d6:	fc 01       	movw	r30, r24
    29d8:	20 83       	st	Z, r18
    29da:	05 c0       	rjmp	.+10     	; 0x29e6 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    29dc:	ce 01       	movw	r24, r28
    29de:	06 96       	adiw	r24, 0x06	; 6
    29e0:	03 96       	adiw	r24, 0x03	; 3
    29e2:	fc 01       	movw	r30, r24
    29e4:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    29e6:	ce 01       	movw	r24, r28
    29e8:	06 96       	adiw	r24, 0x06	; 6
    29ea:	02 96       	adiw	r24, 0x02	; 2
    29ec:	29 81       	ldd	r18, Y+1	; 0x01
    29ee:	22 2f       	mov	r18, r18
    29f0:	30 e0       	ldi	r19, 0x00	; 0
    29f2:	2c 59       	subi	r18, 0x9C	; 156
    29f4:	3f 4a       	sbci	r19, 0xAF	; 175
    29f6:	f9 01       	movw	r30, r18
    29f8:	20 81       	ld	r18, Z
    29fa:	fc 01       	movw	r30, r24
    29fc:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    29fe:	ce 01       	movw	r24, r28
    2a00:	06 96       	adiw	r24, 0x06	; 6
    2a02:	01 96       	adiw	r24, 0x01	; 1
    2a04:	29 81       	ldd	r18, Y+1	; 0x01
    2a06:	22 2f       	mov	r18, r18
    2a08:	30 e0       	ldi	r19, 0x00	; 0
    2a0a:	2f 5f       	subi	r18, 0xFF	; 255
    2a0c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a0e:	2c 59       	subi	r18, 0x9C	; 156
    2a10:	3f 4a       	sbci	r19, 0xAF	; 175
    2a12:	f9 01       	movw	r30, r18
    2a14:	20 81       	ld	r18, Z
    2a16:	fc 01       	movw	r30, r24
    2a18:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2a1a:	ce 01       	movw	r24, r28
    2a1c:	06 96       	adiw	r24, 0x06	; 6
    2a1e:	29 81       	ldd	r18, Y+1	; 0x01
    2a20:	22 2f       	mov	r18, r18
    2a22:	30 e0       	ldi	r19, 0x00	; 0
    2a24:	2e 5f       	subi	r18, 0xFE	; 254
    2a26:	3f 4f       	sbci	r19, 0xFF	; 255
    2a28:	2c 59       	subi	r18, 0x9C	; 156
    2a2a:	3f 4a       	sbci	r19, 0xAF	; 175
    2a2c:	f9 01       	movw	r30, r18
    2a2e:	20 81       	ld	r18, Z
    2a30:	fc 01       	movw	r30, r24
    2a32:	20 83       	st	Z, r18
		sum += currentSample;
    2a34:	2a 81       	ldd	r18, Y+2	; 0x02
    2a36:	3b 81       	ldd	r19, Y+3	; 0x03
    2a38:	4c 81       	ldd	r20, Y+4	; 0x04
    2a3a:	5d 81       	ldd	r21, Y+5	; 0x05
    2a3c:	8e 81       	ldd	r24, Y+6	; 0x06
    2a3e:	9f 81       	ldd	r25, Y+7	; 0x07
    2a40:	a8 85       	ldd	r26, Y+8	; 0x08
    2a42:	b9 85       	ldd	r27, Y+9	; 0x09
    2a44:	82 0f       	add	r24, r18
    2a46:	93 1f       	adc	r25, r19
    2a48:	a4 1f       	adc	r26, r20
    2a4a:	b5 1f       	adc	r27, r21
    2a4c:	8a 83       	std	Y+2, r24	; 0x02
    2a4e:	9b 83       	std	Y+3, r25	; 0x03
    2a50:	ac 83       	std	Y+4, r26	; 0x04
    2a52:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2a54:	89 81       	ldd	r24, Y+1	; 0x01
    2a56:	8d 5f       	subi	r24, 0xFD	; 253
    2a58:	89 83       	std	Y+1, r24	; 0x01
    2a5a:	89 81       	ldd	r24, Y+1	; 0x01
    2a5c:	8c 30       	cpi	r24, 0x0C	; 12
    2a5e:	08 f4       	brcc	.+2      	; 0x2a62 <writeSE2FRAM+0xf0>
    2a60:	ad cf       	rjmp	.-166    	; 0x29bc <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2a62:	8a 81       	ldd	r24, Y+2	; 0x02
    2a64:	9b 81       	ldd	r25, Y+3	; 0x03
    2a66:	ac 81       	ldd	r26, Y+4	; 0x04
    2a68:	bd 81       	ldd	r27, Y+5	; 0x05
    2a6a:	24 e0       	ldi	r18, 0x04	; 4
    2a6c:	30 e0       	ldi	r19, 0x00	; 0
    2a6e:	40 e0       	ldi	r20, 0x00	; 0
    2a70:	50 e0       	ldi	r21, 0x00	; 0
    2a72:	bc 01       	movw	r22, r24
    2a74:	cd 01       	movw	r24, r26
    2a76:	0e 94 12 5d 	call	0xba24	; 0xba24 <__divmodsi4>
    2a7a:	da 01       	movw	r26, r20
    2a7c:	c9 01       	movw	r24, r18
    2a7e:	8a 83       	std	Y+2, r24	; 0x02
    2a80:	9b 83       	std	Y+3, r25	; 0x03
    2a82:	ac 83       	std	Y+4, r26	; 0x04
    2a84:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2a86:	ce 01       	movw	r24, r28
    2a88:	02 96       	adiw	r24, 0x02	; 2
    2a8a:	fc 01       	movw	r30, r24
    2a8c:	80 81       	ld	r24, Z
    2a8e:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2a92:	ce 01       	movw	r24, r28
    2a94:	02 96       	adiw	r24, 0x02	; 2
    2a96:	fc 01       	movw	r30, r24
    2a98:	81 81       	ldd	r24, Z+1	; 0x01
    2a9a:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2a9e:	ce 01       	movw	r24, r28
    2aa0:	02 96       	adiw	r24, 0x02	; 2
    2aa2:	fc 01       	movw	r30, r24
    2aa4:	82 81       	ldd	r24, Z+2	; 0x02
    2aa6:	80 93 64 50 	sts	0x5064, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2aaa:	80 e4       	ldi	r24, 0x40	; 64
    2aac:	96 e0       	ldi	r25, 0x06	; 6
    2aae:	20 e1       	ldi	r18, 0x10	; 16
    2ab0:	fc 01       	movw	r30, r24
    2ab2:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2ab4:	80 e2       	ldi	r24, 0x20	; 32
    2ab6:	96 e0       	ldi	r25, 0x06	; 6
    2ab8:	28 e0       	ldi	r18, 0x08	; 8
    2aba:	fc 01       	movw	r30, r24
    2abc:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2abe:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2ac0:	80 ec       	ldi	r24, 0xC0	; 192
    2ac2:	98 e0       	ldi	r25, 0x08	; 8
    2ac4:	26 e0       	ldi	r18, 0x06	; 6
    2ac6:	fc 01       	movw	r30, r24
    2ac8:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2aca:	00 00       	nop
    2acc:	80 ec       	ldi	r24, 0xC0	; 192
    2ace:	98 e0       	ldi	r25, 0x08	; 8
    2ad0:	fc 01       	movw	r30, r24
    2ad2:	82 81       	ldd	r24, Z+2	; 0x02
    2ad4:	88 23       	and	r24, r24
    2ad6:	d4 f7       	brge	.-12     	; 0x2acc <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    2ad8:	80 ec       	ldi	r24, 0xC0	; 192
    2ada:	98 e0       	ldi	r25, 0x08	; 8
    2adc:	fc 01       	movw	r30, r24
    2ade:	83 81       	ldd	r24, Z+3	; 0x03
    2ae0:	80 93 70 50 	sts	0x5070, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2ae4:	80 e2       	ldi	r24, 0x20	; 32
    2ae6:	96 e0       	ldi	r25, 0x06	; 6
    2ae8:	28 e0       	ldi	r18, 0x08	; 8
    2aea:	fc 01       	movw	r30, r24
    2aec:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2aee:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2af0:	80 e2       	ldi	r24, 0x20	; 32
    2af2:	96 e0       	ldi	r25, 0x06	; 6
    2af4:	28 e0       	ldi	r18, 0x08	; 8
    2af6:	fc 01       	movw	r30, r24
    2af8:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2afa:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2afc:	80 ec       	ldi	r24, 0xC0	; 192
    2afe:	98 e0       	ldi	r25, 0x08	; 8
    2b00:	22 e0       	ldi	r18, 0x02	; 2
    2b02:	fc 01       	movw	r30, r24
    2b04:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2b06:	00 00       	nop
    2b08:	80 ec       	ldi	r24, 0xC0	; 192
    2b0a:	98 e0       	ldi	r25, 0x08	; 8
    2b0c:	fc 01       	movw	r30, r24
    2b0e:	82 81       	ldd	r24, Z+2	; 0x02
    2b10:	88 23       	and	r24, r24
    2b12:	d4 f7       	brge	.-12     	; 0x2b08 <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    2b14:	80 ec       	ldi	r24, 0xC0	; 192
    2b16:	98 e0       	ldi	r25, 0x08	; 8
    2b18:	fc 01       	movw	r30, r24
    2b1a:	83 81       	ldd	r24, Z+3	; 0x03
    2b1c:	80 93 70 50 	sts	0x5070, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2b20:	80 ec       	ldi	r24, 0xC0	; 192
    2b22:	98 e0       	ldi	r25, 0x08	; 8
    2b24:	20 91 57 40 	lds	r18, 0x4057
    2b28:	fc 01       	movw	r30, r24
    2b2a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2b2c:	00 00       	nop
    2b2e:	80 ec       	ldi	r24, 0xC0	; 192
    2b30:	98 e0       	ldi	r25, 0x08	; 8
    2b32:	fc 01       	movw	r30, r24
    2b34:	82 81       	ldd	r24, Z+2	; 0x02
    2b36:	88 23       	and	r24, r24
    2b38:	d4 f7       	brge	.-12     	; 0x2b2e <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    2b3a:	80 ec       	ldi	r24, 0xC0	; 192
    2b3c:	98 e0       	ldi	r25, 0x08	; 8
    2b3e:	fc 01       	movw	r30, r24
    2b40:	83 81       	ldd	r24, Z+3	; 0x03
    2b42:	80 93 70 50 	sts	0x5070, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2b46:	80 ec       	ldi	r24, 0xC0	; 192
    2b48:	98 e0       	ldi	r25, 0x08	; 8
    2b4a:	26 e5       	ldi	r18, 0x56	; 86
    2b4c:	30 e4       	ldi	r19, 0x40	; 64
    2b4e:	f9 01       	movw	r30, r18
    2b50:	20 81       	ld	r18, Z
    2b52:	fc 01       	movw	r30, r24
    2b54:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2b56:	00 00       	nop
    2b58:	80 ec       	ldi	r24, 0xC0	; 192
    2b5a:	98 e0       	ldi	r25, 0x08	; 8
    2b5c:	fc 01       	movw	r30, r24
    2b5e:	82 81       	ldd	r24, Z+2	; 0x02
    2b60:	88 23       	and	r24, r24
    2b62:	d4 f7       	brge	.-12     	; 0x2b58 <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    2b64:	80 ec       	ldi	r24, 0xC0	; 192
    2b66:	98 e0       	ldi	r25, 0x08	; 8
    2b68:	fc 01       	movw	r30, r24
    2b6a:	83 81       	ldd	r24, Z+3	; 0x03
    2b6c:	80 93 70 50 	sts	0x5070, r24
	SPIC.DATA = SPIBuffer[0];
    2b70:	80 ec       	ldi	r24, 0xC0	; 192
    2b72:	98 e0       	ldi	r25, 0x08	; 8
    2b74:	20 91 64 50 	lds	r18, 0x5064
    2b78:	fc 01       	movw	r30, r24
    2b7a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2b7c:	00 00       	nop
    2b7e:	80 ec       	ldi	r24, 0xC0	; 192
    2b80:	98 e0       	ldi	r25, 0x08	; 8
    2b82:	fc 01       	movw	r30, r24
    2b84:	82 81       	ldd	r24, Z+2	; 0x02
    2b86:	88 23       	and	r24, r24
    2b88:	d4 f7       	brge	.-12     	; 0x2b7e <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    2b8a:	80 ec       	ldi	r24, 0xC0	; 192
    2b8c:	98 e0       	ldi	r25, 0x08	; 8
    2b8e:	fc 01       	movw	r30, r24
    2b90:	83 81       	ldd	r24, Z+3	; 0x03
    2b92:	80 93 70 50 	sts	0x5070, r24
	SPIC.DATA = SPIBuffer[1];
    2b96:	80 ec       	ldi	r24, 0xC0	; 192
    2b98:	98 e0       	ldi	r25, 0x08	; 8
    2b9a:	20 91 65 50 	lds	r18, 0x5065
    2b9e:	fc 01       	movw	r30, r24
    2ba0:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ba2:	00 00       	nop
    2ba4:	80 ec       	ldi	r24, 0xC0	; 192
    2ba6:	98 e0       	ldi	r25, 0x08	; 8
    2ba8:	fc 01       	movw	r30, r24
    2baa:	82 81       	ldd	r24, Z+2	; 0x02
    2bac:	88 23       	and	r24, r24
    2bae:	d4 f7       	brge	.-12     	; 0x2ba4 <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    2bb0:	80 ec       	ldi	r24, 0xC0	; 192
    2bb2:	98 e0       	ldi	r25, 0x08	; 8
    2bb4:	fc 01       	movw	r30, r24
    2bb6:	83 81       	ldd	r24, Z+3	; 0x03
    2bb8:	80 93 70 50 	sts	0x5070, r24
	SPIC.DATA = SPIBuffer[2];
    2bbc:	80 ec       	ldi	r24, 0xC0	; 192
    2bbe:	98 e0       	ldi	r25, 0x08	; 8
    2bc0:	20 91 66 50 	lds	r18, 0x5066
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2bc8:	00 00       	nop
    2bca:	80 ec       	ldi	r24, 0xC0	; 192
    2bcc:	98 e0       	ldi	r25, 0x08	; 8
    2bce:	fc 01       	movw	r30, r24
    2bd0:	82 81       	ldd	r24, Z+2	; 0x02
    2bd2:	88 23       	and	r24, r24
    2bd4:	d4 f7       	brge	.-12     	; 0x2bca <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    2bd6:	80 ec       	ldi	r24, 0xC0	; 192
    2bd8:	98 e0       	ldi	r25, 0x08	; 8
    2bda:	fc 01       	movw	r30, r24
    2bdc:	83 81       	ldd	r24, Z+3	; 0x03
    2bde:	80 93 70 50 	sts	0x5070, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2be2:	80 e2       	ldi	r24, 0x20	; 32
    2be4:	96 e0       	ldi	r25, 0x06	; 6
    2be6:	28 e0       	ldi	r18, 0x08	; 8
    2be8:	fc 01       	movw	r30, r24
    2bea:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2bec:	80 e4       	ldi	r24, 0x40	; 64
    2bee:	96 e0       	ldi	r25, 0x06	; 6
    2bf0:	20 e1       	ldi	r18, 0x10	; 16
    2bf2:	fc 01       	movw	r30, r24
    2bf4:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2bf6:	80 ec       	ldi	r24, 0xC0	; 192
    2bf8:	98 e0       	ldi	r25, 0x08	; 8
    2bfa:	24 e5       	ldi	r18, 0x54	; 84
    2bfc:	fc 01       	movw	r30, r24
    2bfe:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2c00:	80 e4       	ldi	r24, 0x40	; 64
    2c02:	96 e0       	ldi	r25, 0x06	; 6
    2c04:	20 e1       	ldi	r18, 0x10	; 16
    2c06:	fc 01       	movw	r30, r24
    2c08:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2c0a:	80 91 56 40 	lds	r24, 0x4056
    2c0e:	90 91 57 40 	lds	r25, 0x4057
    2c12:	03 96       	adiw	r24, 0x03	; 3
    2c14:	80 93 56 40 	sts	0x4056, r24
    2c18:	90 93 57 40 	sts	0x4057, r25
	checksumADC[0] += SPIBuffer[0];
    2c1c:	90 91 38 21 	lds	r25, 0x2138
    2c20:	80 91 64 50 	lds	r24, 0x5064
    2c24:	89 0f       	add	r24, r25
    2c26:	80 93 38 21 	sts	0x2138, r24
	checksumADC[1] += SPIBuffer[1];
    2c2a:	90 91 39 21 	lds	r25, 0x2139
    2c2e:	80 91 65 50 	lds	r24, 0x5065
    2c32:	89 0f       	add	r24, r25
    2c34:	80 93 39 21 	sts	0x2139, r24
	checksumADC[2] += SPIBuffer[2];
    2c38:	90 91 3a 21 	lds	r25, 0x213A
    2c3c:	80 91 66 50 	lds	r24, 0x5066
    2c40:	89 0f       	add	r24, r25
    2c42:	80 93 3a 21 	sts	0x213A, r24
}
    2c46:	29 96       	adiw	r28, 0x09	; 9
    2c48:	cd bf       	out	0x3d, r28	; 61
    2c4a:	de bf       	out	0x3e, r29	; 62
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	08 95       	ret

00002c52 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    2c52:	2f 92       	push	r2
    2c54:	3f 92       	push	r3
    2c56:	4f 92       	push	r4
    2c58:	5f 92       	push	r5
    2c5a:	6f 92       	push	r6
    2c5c:	7f 92       	push	r7
    2c5e:	8f 92       	push	r8
    2c60:	9f 92       	push	r9
    2c62:	af 92       	push	r10
    2c64:	bf 92       	push	r11
    2c66:	cf 92       	push	r12
    2c68:	df 92       	push	r13
    2c6a:	ef 92       	push	r14
    2c6c:	ff 92       	push	r15
    2c6e:	0f 93       	push	r16
    2c70:	1f 93       	push	r17
    2c72:	cf 93       	push	r28
    2c74:	df 93       	push	r29
    2c76:	00 d0       	rcall	.+0      	; 0x2c78 <calcChecksumFRAM+0x26>
    2c78:	0f 92       	push	r0
    2c7a:	cd b7       	in	r28, 0x3d	; 61
    2c7c:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2c7e:	aa 24       	eor	r10, r10
    2c80:	bb 24       	eor	r11, r11
    2c82:	cc 24       	eor	r12, r12
    2c84:	dd 24       	eor	r13, r13
    2c86:	ee 24       	eor	r14, r14
    2c88:	ff 24       	eor	r15, r15
    2c8a:	00 e0       	ldi	r16, 0x00	; 0
    2c8c:	10 e0       	ldi	r17, 0x00	; 0
    2c8e:	a0 92 9a 50 	sts	0x509A, r10
    2c92:	b0 92 9b 50 	sts	0x509B, r11
    2c96:	c0 92 9c 50 	sts	0x509C, r12
    2c9a:	d0 92 9d 50 	sts	0x509D, r13
    2c9e:	e0 92 9e 50 	sts	0x509E, r14
    2ca2:	f0 92 9f 50 	sts	0x509F, r15
    2ca6:	00 93 a0 50 	sts	0x50A0, r16
    2caa:	10 93 a1 50 	sts	0x50A1, r17
    2cae:	2a 2d       	mov	r18, r10
    2cb0:	3b 2d       	mov	r19, r11
    2cb2:	4c 2d       	mov	r20, r12
    2cb4:	5d 2d       	mov	r21, r13
    2cb6:	6e 2d       	mov	r22, r14
    2cb8:	7f 2d       	mov	r23, r15
    2cba:	80 2f       	mov	r24, r16
    2cbc:	91 2f       	mov	r25, r17
    2cbe:	20 93 92 50 	sts	0x5092, r18
    2cc2:	30 93 93 50 	sts	0x5093, r19
    2cc6:	40 93 94 50 	sts	0x5094, r20
    2cca:	50 93 95 50 	sts	0x5095, r21
    2cce:	60 93 96 50 	sts	0x5096, r22
    2cd2:	70 93 97 50 	sts	0x5097, r23
    2cd6:	80 93 98 50 	sts	0x5098, r24
    2cda:	90 93 99 50 	sts	0x5099, r25
    2cde:	20 93 8a 50 	sts	0x508A, r18
    2ce2:	30 93 8b 50 	sts	0x508B, r19
    2ce6:	40 93 8c 50 	sts	0x508C, r20
    2cea:	50 93 8d 50 	sts	0x508D, r21
    2cee:	60 93 8e 50 	sts	0x508E, r22
    2cf2:	70 93 8f 50 	sts	0x508F, r23
    2cf6:	80 93 90 50 	sts	0x5090, r24
    2cfa:	90 93 91 50 	sts	0x5091, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2cfe:	80 e0       	ldi	r24, 0x00	; 0
    2d00:	80 93 3d 21 	sts	0x213D, r24
    2d04:	80 93 3c 21 	sts	0x213C, r24
    2d08:	80 93 3b 21 	sts	0x213B, r24
	FRAMAddress = FR_BASEADD;
    2d0c:	10 92 56 40 	sts	0x4056, r1
    2d10:	10 92 57 40 	sts	0x4057, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2d14:	19 82       	std	Y+1, r1	; 0x01
    2d16:	1a 82       	std	Y+2, r1	; 0x02
    2d18:	88 c2       	rjmp	.+1296   	; 0x322a <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2d1a:	81 e7       	ldi	r24, 0x71	; 113
    2d1c:	9c e1       	ldi	r25, 0x1C	; 28
    2d1e:	0e 94 2a 38 	call	0x7054	; 0x7054 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2d22:	80 91 56 40 	lds	r24, 0x4056
    2d26:	90 91 57 40 	lds	r25, 0x4057
    2d2a:	8f 58       	subi	r24, 0x8F	; 143
    2d2c:	93 4e       	sbci	r25, 0xE3	; 227
    2d2e:	80 93 56 40 	sts	0x4056, r24
    2d32:	90 93 57 40 	sts	0x4057, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2d36:	1b 82       	std	Y+3, r1	; 0x03
    2d38:	1c 82       	std	Y+4, r1	; 0x04
    2d3a:	6b c2       	rjmp	.+1238   	; 0x3212 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d40:	23 e0       	ldi	r18, 0x03	; 3
    2d42:	30 e0       	ldi	r19, 0x00	; 0
    2d44:	b9 01       	movw	r22, r18
    2d46:	0e 94 c9 5c 	call	0xb992	; 0xb992 <__udivmodhi4>
    2d4a:	9c 01       	movw	r18, r24
    2d4c:	25 5c       	subi	r18, 0xC5	; 197
    2d4e:	3e 4d       	sbci	r19, 0xDE	; 222
    2d50:	f9 01       	movw	r30, r18
    2d52:	40 81       	ld	r20, Z
    2d54:	2b 81       	ldd	r18, Y+3	; 0x03
    2d56:	3c 81       	ldd	r19, Y+4	; 0x04
    2d58:	22 52       	subi	r18, 0x22	; 34
    2d5a:	3c 4d       	sbci	r19, 0xDC	; 220
    2d5c:	f9 01       	movw	r30, r18
    2d5e:	20 81       	ld	r18, Z
    2d60:	24 0f       	add	r18, r20
    2d62:	85 5c       	subi	r24, 0xC5	; 197
    2d64:	9e 4d       	sbci	r25, 0xDE	; 222
    2d66:	fc 01       	movw	r30, r24
    2d68:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6e:	23 e0       	ldi	r18, 0x03	; 3
    2d70:	30 e0       	ldi	r19, 0x00	; 0
    2d72:	b9 01       	movw	r22, r18
    2d74:	0e 94 c9 5c 	call	0xb992	; 0xb992 <__udivmodhi4>
    2d78:	00 97       	sbiw	r24, 0x00	; 0
    2d7a:	09 f0       	breq	.+2      	; 0x2d7e <calcChecksumFRAM+0x12c>
    2d7c:	44 c0       	rjmp	.+136    	; 0x2e06 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d80:	9c 81       	ldd	r25, Y+4	; 0x04
    2d82:	82 52       	subi	r24, 0x22	; 34
    2d84:	9c 4d       	sbci	r25, 0xDC	; 220
    2d86:	fc 01       	movw	r30, r24
    2d88:	80 81       	ld	r24, Z
    2d8a:	88 23       	and	r24, r24
    2d8c:	d4 f4       	brge	.+52     	; 0x2dc2 <calcChecksumFRAM+0x170>
    2d8e:	80 91 62 50 	lds	r24, 0x5062
    2d92:	90 91 63 50 	lds	r25, 0x5063
    2d96:	fc 01       	movw	r30, r24
    2d98:	10 82       	st	Z, r1
    2d9a:	fc 01       	movw	r30, r24
    2d9c:	11 82       	std	Z+1, r1	; 0x01
    2d9e:	fc 01       	movw	r30, r24
    2da0:	12 82       	std	Z+2, r1	; 0x02
    2da2:	2f ef       	ldi	r18, 0xFF	; 255
    2da4:	fc 01       	movw	r30, r24
    2da6:	23 83       	std	Z+3, r18	; 0x03
    2da8:	2f ef       	ldi	r18, 0xFF	; 255
    2daa:	fc 01       	movw	r30, r24
    2dac:	24 83       	std	Z+4, r18	; 0x04
    2dae:	2f ef       	ldi	r18, 0xFF	; 255
    2db0:	fc 01       	movw	r30, r24
    2db2:	25 83       	std	Z+5, r18	; 0x05
    2db4:	2f ef       	ldi	r18, 0xFF	; 255
    2db6:	fc 01       	movw	r30, r24
    2db8:	26 83       	std	Z+6, r18	; 0x06
    2dba:	2f ef       	ldi	r18, 0xFF	; 255
    2dbc:	fc 01       	movw	r30, r24
    2dbe:	27 83       	std	Z+7, r18	; 0x07
    2dc0:	14 c0       	rjmp	.+40     	; 0x2dea <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2dc2:	80 91 62 50 	lds	r24, 0x5062
    2dc6:	90 91 63 50 	lds	r25, 0x5063
    2dca:	fc 01       	movw	r30, r24
    2dcc:	10 82       	st	Z, r1
    2dce:	fc 01       	movw	r30, r24
    2dd0:	11 82       	std	Z+1, r1	; 0x01
    2dd2:	fc 01       	movw	r30, r24
    2dd4:	12 82       	std	Z+2, r1	; 0x02
    2dd6:	fc 01       	movw	r30, r24
    2dd8:	13 82       	std	Z+3, r1	; 0x03
    2dda:	fc 01       	movw	r30, r24
    2ddc:	14 82       	std	Z+4, r1	; 0x04
    2dde:	fc 01       	movw	r30, r24
    2de0:	15 82       	std	Z+5, r1	; 0x05
    2de2:	fc 01       	movw	r30, r24
    2de4:	16 82       	std	Z+6, r1	; 0x06
    2de6:	fc 01       	movw	r30, r24
    2de8:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2dea:	80 91 62 50 	lds	r24, 0x5062
    2dee:	90 91 63 50 	lds	r25, 0x5063
    2df2:	02 96       	adiw	r24, 0x02	; 2
    2df4:	2b 81       	ldd	r18, Y+3	; 0x03
    2df6:	3c 81       	ldd	r19, Y+4	; 0x04
    2df8:	22 52       	subi	r18, 0x22	; 34
    2dfa:	3c 4d       	sbci	r19, 0xDC	; 220
    2dfc:	f9 01       	movw	r30, r18
    2dfe:	20 81       	ld	r18, Z
    2e00:	fc 01       	movw	r30, r24
    2e02:	20 83       	st	Z, r18
    2e04:	24 c0       	rjmp	.+72     	; 0x2e4e <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2e06:	8b 81       	ldd	r24, Y+3	; 0x03
    2e08:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0a:	23 e0       	ldi	r18, 0x03	; 3
    2e0c:	30 e0       	ldi	r19, 0x00	; 0
    2e0e:	b9 01       	movw	r22, r18
    2e10:	0e 94 c9 5c 	call	0xb992	; 0xb992 <__udivmodhi4>
    2e14:	81 30       	cpi	r24, 0x01	; 1
    2e16:	91 05       	cpc	r25, r1
    2e18:	71 f4       	brne	.+28     	; 0x2e36 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2e1a:	80 91 62 50 	lds	r24, 0x5062
    2e1e:	90 91 63 50 	lds	r25, 0x5063
    2e22:	01 96       	adiw	r24, 0x01	; 1
    2e24:	2b 81       	ldd	r18, Y+3	; 0x03
    2e26:	3c 81       	ldd	r19, Y+4	; 0x04
    2e28:	22 52       	subi	r18, 0x22	; 34
    2e2a:	3c 4d       	sbci	r19, 0xDC	; 220
    2e2c:	f9 01       	movw	r30, r18
    2e2e:	20 81       	ld	r18, Z
    2e30:	fc 01       	movw	r30, r24
    2e32:	20 83       	st	Z, r18
    2e34:	0c c0       	rjmp	.+24     	; 0x2e4e <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2e36:	80 91 62 50 	lds	r24, 0x5062
    2e3a:	90 91 63 50 	lds	r25, 0x5063
    2e3e:	2b 81       	ldd	r18, Y+3	; 0x03
    2e40:	3c 81       	ldd	r19, Y+4	; 0x04
    2e42:	22 52       	subi	r18, 0x22	; 34
    2e44:	3c 4d       	sbci	r19, 0xDC	; 220
    2e46:	f9 01       	movw	r30, r18
    2e48:	20 81       	ld	r18, Z
    2e4a:	fc 01       	movw	r30, r24
    2e4c:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e50:	9c 81       	ldd	r25, Y+4	; 0x04
    2e52:	29 e0       	ldi	r18, 0x09	; 9
    2e54:	30 e0       	ldi	r19, 0x00	; 0
    2e56:	b9 01       	movw	r22, r18
    2e58:	0e 94 c9 5c 	call	0xb992	; 0xb992 <__udivmodhi4>
    2e5c:	82 30       	cpi	r24, 0x02	; 2
    2e5e:	91 05       	cpc	r25, r1
    2e60:	09 f0       	breq	.+2      	; 0x2e64 <calcChecksumFRAM+0x212>
    2e62:	94 c0       	rjmp	.+296    	; 0x2f8c <calcChecksumFRAM+0x33a>
    2e64:	a0 90 8a 50 	lds	r10, 0x508A
    2e68:	b0 90 8b 50 	lds	r11, 0x508B
    2e6c:	c0 90 8c 50 	lds	r12, 0x508C
    2e70:	d0 90 8d 50 	lds	r13, 0x508D
    2e74:	e0 90 8e 50 	lds	r14, 0x508E
    2e78:	f0 90 8f 50 	lds	r15, 0x508F
    2e7c:	00 91 90 50 	lds	r16, 0x5090
    2e80:	10 91 91 50 	lds	r17, 0x5091
    2e84:	80 91 62 50 	lds	r24, 0x5062
    2e88:	90 91 63 50 	lds	r25, 0x5063
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	20 80       	ld	r2, Z
    2e90:	fc 01       	movw	r30, r24
    2e92:	31 80       	ldd	r3, Z+1	; 0x01
    2e94:	fc 01       	movw	r30, r24
    2e96:	42 80       	ldd	r4, Z+2	; 0x02
    2e98:	fc 01       	movw	r30, r24
    2e9a:	53 80       	ldd	r5, Z+3	; 0x03
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	64 80       	ldd	r6, Z+4	; 0x04
    2ea0:	fc 01       	movw	r30, r24
    2ea2:	75 80       	ldd	r7, Z+5	; 0x05
    2ea4:	fc 01       	movw	r30, r24
    2ea6:	86 80       	ldd	r8, Z+6	; 0x06
    2ea8:	fc 01       	movw	r30, r24
    2eaa:	97 80       	ldd	r9, Z+7	; 0x07
    2eac:	2a 2d       	mov	r18, r10
    2eae:	22 0d       	add	r18, r2
    2eb0:	e1 e0       	ldi	r30, 0x01	; 1
    2eb2:	2a 15       	cp	r18, r10
    2eb4:	08 f0       	brcs	.+2      	; 0x2eb8 <calcChecksumFRAM+0x266>
    2eb6:	e0 e0       	ldi	r30, 0x00	; 0
    2eb8:	3b 2d       	mov	r19, r11
    2eba:	33 0d       	add	r19, r3
    2ebc:	f1 e0       	ldi	r31, 0x01	; 1
    2ebe:	3b 15       	cp	r19, r11
    2ec0:	08 f0       	brcs	.+2      	; 0x2ec4 <calcChecksumFRAM+0x272>
    2ec2:	f0 e0       	ldi	r31, 0x00	; 0
    2ec4:	e3 0f       	add	r30, r19
    2ec6:	a1 e0       	ldi	r26, 0x01	; 1
    2ec8:	e3 17       	cp	r30, r19
    2eca:	08 f0       	brcs	.+2      	; 0x2ece <calcChecksumFRAM+0x27c>
    2ecc:	a0 e0       	ldi	r26, 0x00	; 0
    2ece:	fa 2b       	or	r31, r26
    2ed0:	3e 2f       	mov	r19, r30
    2ed2:	4c 2d       	mov	r20, r12
    2ed4:	44 0d       	add	r20, r4
    2ed6:	e1 e0       	ldi	r30, 0x01	; 1
    2ed8:	4c 15       	cp	r20, r12
    2eda:	08 f0       	brcs	.+2      	; 0x2ede <calcChecksumFRAM+0x28c>
    2edc:	e0 e0       	ldi	r30, 0x00	; 0
    2ede:	f4 0f       	add	r31, r20
    2ee0:	a1 e0       	ldi	r26, 0x01	; 1
    2ee2:	f4 17       	cp	r31, r20
    2ee4:	08 f0       	brcs	.+2      	; 0x2ee8 <calcChecksumFRAM+0x296>
    2ee6:	a0 e0       	ldi	r26, 0x00	; 0
    2ee8:	ea 2b       	or	r30, r26
    2eea:	4f 2f       	mov	r20, r31
    2eec:	5d 2d       	mov	r21, r13
    2eee:	55 0d       	add	r21, r5
    2ef0:	f1 e0       	ldi	r31, 0x01	; 1
    2ef2:	5d 15       	cp	r21, r13
    2ef4:	08 f0       	brcs	.+2      	; 0x2ef8 <calcChecksumFRAM+0x2a6>
    2ef6:	f0 e0       	ldi	r31, 0x00	; 0
    2ef8:	e5 0f       	add	r30, r21
    2efa:	a1 e0       	ldi	r26, 0x01	; 1
    2efc:	e5 17       	cp	r30, r21
    2efe:	08 f0       	brcs	.+2      	; 0x2f02 <calcChecksumFRAM+0x2b0>
    2f00:	a0 e0       	ldi	r26, 0x00	; 0
    2f02:	fa 2b       	or	r31, r26
    2f04:	5e 2f       	mov	r21, r30
    2f06:	6e 2d       	mov	r22, r14
    2f08:	66 0d       	add	r22, r6
    2f0a:	e1 e0       	ldi	r30, 0x01	; 1
    2f0c:	6e 15       	cp	r22, r14
    2f0e:	08 f0       	brcs	.+2      	; 0x2f12 <calcChecksumFRAM+0x2c0>
    2f10:	e0 e0       	ldi	r30, 0x00	; 0
    2f12:	f6 0f       	add	r31, r22
    2f14:	a1 e0       	ldi	r26, 0x01	; 1
    2f16:	f6 17       	cp	r31, r22
    2f18:	08 f0       	brcs	.+2      	; 0x2f1c <calcChecksumFRAM+0x2ca>
    2f1a:	a0 e0       	ldi	r26, 0x00	; 0
    2f1c:	ea 2b       	or	r30, r26
    2f1e:	6f 2f       	mov	r22, r31
    2f20:	7f 2d       	mov	r23, r15
    2f22:	77 0d       	add	r23, r7
    2f24:	f1 e0       	ldi	r31, 0x01	; 1
    2f26:	7f 15       	cp	r23, r15
    2f28:	08 f0       	brcs	.+2      	; 0x2f2c <calcChecksumFRAM+0x2da>
    2f2a:	f0 e0       	ldi	r31, 0x00	; 0
    2f2c:	e7 0f       	add	r30, r23
    2f2e:	a1 e0       	ldi	r26, 0x01	; 1
    2f30:	e7 17       	cp	r30, r23
    2f32:	08 f0       	brcs	.+2      	; 0x2f36 <calcChecksumFRAM+0x2e4>
    2f34:	a0 e0       	ldi	r26, 0x00	; 0
    2f36:	fa 2b       	or	r31, r26
    2f38:	7e 2f       	mov	r23, r30
    2f3a:	80 2f       	mov	r24, r16
    2f3c:	88 0d       	add	r24, r8
    2f3e:	e1 e0       	ldi	r30, 0x01	; 1
    2f40:	80 17       	cp	r24, r16
    2f42:	08 f0       	brcs	.+2      	; 0x2f46 <calcChecksumFRAM+0x2f4>
    2f44:	e0 e0       	ldi	r30, 0x00	; 0
    2f46:	f8 0f       	add	r31, r24
    2f48:	a1 e0       	ldi	r26, 0x01	; 1
    2f4a:	f8 17       	cp	r31, r24
    2f4c:	08 f0       	brcs	.+2      	; 0x2f50 <calcChecksumFRAM+0x2fe>
    2f4e:	a0 e0       	ldi	r26, 0x00	; 0
    2f50:	ea 2b       	or	r30, r26
    2f52:	8f 2f       	mov	r24, r31
    2f54:	91 2f       	mov	r25, r17
    2f56:	99 0d       	add	r25, r9
    2f58:	e9 0f       	add	r30, r25
    2f5a:	9e 2f       	mov	r25, r30
    2f5c:	a2 2e       	mov	r10, r18
    2f5e:	b3 2e       	mov	r11, r19
    2f60:	c4 2e       	mov	r12, r20
    2f62:	d5 2e       	mov	r13, r21
    2f64:	e6 2e       	mov	r14, r22
    2f66:	f7 2e       	mov	r15, r23
    2f68:	08 2f       	mov	r16, r24
    2f6a:	19 2f       	mov	r17, r25
    2f6c:	a0 92 8a 50 	sts	0x508A, r10
    2f70:	b0 92 8b 50 	sts	0x508B, r11
    2f74:	c0 92 8c 50 	sts	0x508C, r12
    2f78:	d0 92 8d 50 	sts	0x508D, r13
    2f7c:	e0 92 8e 50 	sts	0x508E, r14
    2f80:	f0 92 8f 50 	sts	0x508F, r15
    2f84:	00 93 90 50 	sts	0x5090, r16
    2f88:	10 93 91 50 	sts	0x5091, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    2f8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f90:	29 e0       	ldi	r18, 0x09	; 9
    2f92:	30 e0       	ldi	r19, 0x00	; 0
    2f94:	b9 01       	movw	r22, r18
    2f96:	0e 94 c9 5c 	call	0xb992	; 0xb992 <__udivmodhi4>
    2f9a:	85 30       	cpi	r24, 0x05	; 5
    2f9c:	91 05       	cpc	r25, r1
    2f9e:	09 f0       	breq	.+2      	; 0x2fa2 <calcChecksumFRAM+0x350>
    2fa0:	94 c0       	rjmp	.+296    	; 0x30ca <calcChecksumFRAM+0x478>
    2fa2:	a0 90 92 50 	lds	r10, 0x5092
    2fa6:	b0 90 93 50 	lds	r11, 0x5093
    2faa:	c0 90 94 50 	lds	r12, 0x5094
    2fae:	d0 90 95 50 	lds	r13, 0x5095
    2fb2:	e0 90 96 50 	lds	r14, 0x5096
    2fb6:	f0 90 97 50 	lds	r15, 0x5097
    2fba:	00 91 98 50 	lds	r16, 0x5098
    2fbe:	10 91 99 50 	lds	r17, 0x5099
    2fc2:	80 91 62 50 	lds	r24, 0x5062
    2fc6:	90 91 63 50 	lds	r25, 0x5063
    2fca:	fc 01       	movw	r30, r24
    2fcc:	20 80       	ld	r2, Z
    2fce:	fc 01       	movw	r30, r24
    2fd0:	31 80       	ldd	r3, Z+1	; 0x01
    2fd2:	fc 01       	movw	r30, r24
    2fd4:	42 80       	ldd	r4, Z+2	; 0x02
    2fd6:	fc 01       	movw	r30, r24
    2fd8:	53 80       	ldd	r5, Z+3	; 0x03
    2fda:	fc 01       	movw	r30, r24
    2fdc:	64 80       	ldd	r6, Z+4	; 0x04
    2fde:	fc 01       	movw	r30, r24
    2fe0:	75 80       	ldd	r7, Z+5	; 0x05
    2fe2:	fc 01       	movw	r30, r24
    2fe4:	86 80       	ldd	r8, Z+6	; 0x06
    2fe6:	fc 01       	movw	r30, r24
    2fe8:	97 80       	ldd	r9, Z+7	; 0x07
    2fea:	2a 2d       	mov	r18, r10
    2fec:	22 0d       	add	r18, r2
    2fee:	e1 e0       	ldi	r30, 0x01	; 1
    2ff0:	2a 15       	cp	r18, r10
    2ff2:	08 f0       	brcs	.+2      	; 0x2ff6 <calcChecksumFRAM+0x3a4>
    2ff4:	e0 e0       	ldi	r30, 0x00	; 0
    2ff6:	3b 2d       	mov	r19, r11
    2ff8:	33 0d       	add	r19, r3
    2ffa:	f1 e0       	ldi	r31, 0x01	; 1
    2ffc:	3b 15       	cp	r19, r11
    2ffe:	08 f0       	brcs	.+2      	; 0x3002 <calcChecksumFRAM+0x3b0>
    3000:	f0 e0       	ldi	r31, 0x00	; 0
    3002:	e3 0f       	add	r30, r19
    3004:	a1 e0       	ldi	r26, 0x01	; 1
    3006:	e3 17       	cp	r30, r19
    3008:	08 f0       	brcs	.+2      	; 0x300c <calcChecksumFRAM+0x3ba>
    300a:	a0 e0       	ldi	r26, 0x00	; 0
    300c:	fa 2b       	or	r31, r26
    300e:	3e 2f       	mov	r19, r30
    3010:	4c 2d       	mov	r20, r12
    3012:	44 0d       	add	r20, r4
    3014:	e1 e0       	ldi	r30, 0x01	; 1
    3016:	4c 15       	cp	r20, r12
    3018:	08 f0       	brcs	.+2      	; 0x301c <calcChecksumFRAM+0x3ca>
    301a:	e0 e0       	ldi	r30, 0x00	; 0
    301c:	f4 0f       	add	r31, r20
    301e:	a1 e0       	ldi	r26, 0x01	; 1
    3020:	f4 17       	cp	r31, r20
    3022:	08 f0       	brcs	.+2      	; 0x3026 <calcChecksumFRAM+0x3d4>
    3024:	a0 e0       	ldi	r26, 0x00	; 0
    3026:	ea 2b       	or	r30, r26
    3028:	4f 2f       	mov	r20, r31
    302a:	5d 2d       	mov	r21, r13
    302c:	55 0d       	add	r21, r5
    302e:	f1 e0       	ldi	r31, 0x01	; 1
    3030:	5d 15       	cp	r21, r13
    3032:	08 f0       	brcs	.+2      	; 0x3036 <calcChecksumFRAM+0x3e4>
    3034:	f0 e0       	ldi	r31, 0x00	; 0
    3036:	e5 0f       	add	r30, r21
    3038:	a1 e0       	ldi	r26, 0x01	; 1
    303a:	e5 17       	cp	r30, r21
    303c:	08 f0       	brcs	.+2      	; 0x3040 <calcChecksumFRAM+0x3ee>
    303e:	a0 e0       	ldi	r26, 0x00	; 0
    3040:	fa 2b       	or	r31, r26
    3042:	5e 2f       	mov	r21, r30
    3044:	6e 2d       	mov	r22, r14
    3046:	66 0d       	add	r22, r6
    3048:	e1 e0       	ldi	r30, 0x01	; 1
    304a:	6e 15       	cp	r22, r14
    304c:	08 f0       	brcs	.+2      	; 0x3050 <calcChecksumFRAM+0x3fe>
    304e:	e0 e0       	ldi	r30, 0x00	; 0
    3050:	f6 0f       	add	r31, r22
    3052:	a1 e0       	ldi	r26, 0x01	; 1
    3054:	f6 17       	cp	r31, r22
    3056:	08 f0       	brcs	.+2      	; 0x305a <calcChecksumFRAM+0x408>
    3058:	a0 e0       	ldi	r26, 0x00	; 0
    305a:	ea 2b       	or	r30, r26
    305c:	6f 2f       	mov	r22, r31
    305e:	7f 2d       	mov	r23, r15
    3060:	77 0d       	add	r23, r7
    3062:	f1 e0       	ldi	r31, 0x01	; 1
    3064:	7f 15       	cp	r23, r15
    3066:	08 f0       	brcs	.+2      	; 0x306a <calcChecksumFRAM+0x418>
    3068:	f0 e0       	ldi	r31, 0x00	; 0
    306a:	e7 0f       	add	r30, r23
    306c:	a1 e0       	ldi	r26, 0x01	; 1
    306e:	e7 17       	cp	r30, r23
    3070:	08 f0       	brcs	.+2      	; 0x3074 <calcChecksumFRAM+0x422>
    3072:	a0 e0       	ldi	r26, 0x00	; 0
    3074:	fa 2b       	or	r31, r26
    3076:	7e 2f       	mov	r23, r30
    3078:	80 2f       	mov	r24, r16
    307a:	88 0d       	add	r24, r8
    307c:	e1 e0       	ldi	r30, 0x01	; 1
    307e:	80 17       	cp	r24, r16
    3080:	08 f0       	brcs	.+2      	; 0x3084 <calcChecksumFRAM+0x432>
    3082:	e0 e0       	ldi	r30, 0x00	; 0
    3084:	f8 0f       	add	r31, r24
    3086:	a1 e0       	ldi	r26, 0x01	; 1
    3088:	f8 17       	cp	r31, r24
    308a:	08 f0       	brcs	.+2      	; 0x308e <calcChecksumFRAM+0x43c>
    308c:	a0 e0       	ldi	r26, 0x00	; 0
    308e:	ea 2b       	or	r30, r26
    3090:	8f 2f       	mov	r24, r31
    3092:	91 2f       	mov	r25, r17
    3094:	99 0d       	add	r25, r9
    3096:	e9 0f       	add	r30, r25
    3098:	9e 2f       	mov	r25, r30
    309a:	a2 2e       	mov	r10, r18
    309c:	b3 2e       	mov	r11, r19
    309e:	c4 2e       	mov	r12, r20
    30a0:	d5 2e       	mov	r13, r21
    30a2:	e6 2e       	mov	r14, r22
    30a4:	f7 2e       	mov	r15, r23
    30a6:	08 2f       	mov	r16, r24
    30a8:	19 2f       	mov	r17, r25
    30aa:	a0 92 92 50 	sts	0x5092, r10
    30ae:	b0 92 93 50 	sts	0x5093, r11
    30b2:	c0 92 94 50 	sts	0x5094, r12
    30b6:	d0 92 95 50 	sts	0x5095, r13
    30ba:	e0 92 96 50 	sts	0x5096, r14
    30be:	f0 92 97 50 	sts	0x5097, r15
    30c2:	00 93 98 50 	sts	0x5098, r16
    30c6:	10 93 99 50 	sts	0x5099, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    30ca:	8b 81       	ldd	r24, Y+3	; 0x03
    30cc:	9c 81       	ldd	r25, Y+4	; 0x04
    30ce:	29 e0       	ldi	r18, 0x09	; 9
    30d0:	30 e0       	ldi	r19, 0x00	; 0
    30d2:	b9 01       	movw	r22, r18
    30d4:	0e 94 c9 5c 	call	0xb992	; 0xb992 <__udivmodhi4>
    30d8:	88 30       	cpi	r24, 0x08	; 8
    30da:	91 05       	cpc	r25, r1
    30dc:	09 f0       	breq	.+2      	; 0x30e0 <calcChecksumFRAM+0x48e>
    30de:	94 c0       	rjmp	.+296    	; 0x3208 <calcChecksumFRAM+0x5b6>
    30e0:	a0 90 9a 50 	lds	r10, 0x509A
    30e4:	b0 90 9b 50 	lds	r11, 0x509B
    30e8:	c0 90 9c 50 	lds	r12, 0x509C
    30ec:	d0 90 9d 50 	lds	r13, 0x509D
    30f0:	e0 90 9e 50 	lds	r14, 0x509E
    30f4:	f0 90 9f 50 	lds	r15, 0x509F
    30f8:	00 91 a0 50 	lds	r16, 0x50A0
    30fc:	10 91 a1 50 	lds	r17, 0x50A1
    3100:	80 91 62 50 	lds	r24, 0x5062
    3104:	90 91 63 50 	lds	r25, 0x5063
    3108:	fc 01       	movw	r30, r24
    310a:	20 80       	ld	r2, Z
    310c:	fc 01       	movw	r30, r24
    310e:	31 80       	ldd	r3, Z+1	; 0x01
    3110:	fc 01       	movw	r30, r24
    3112:	42 80       	ldd	r4, Z+2	; 0x02
    3114:	fc 01       	movw	r30, r24
    3116:	53 80       	ldd	r5, Z+3	; 0x03
    3118:	fc 01       	movw	r30, r24
    311a:	64 80       	ldd	r6, Z+4	; 0x04
    311c:	fc 01       	movw	r30, r24
    311e:	75 80       	ldd	r7, Z+5	; 0x05
    3120:	fc 01       	movw	r30, r24
    3122:	86 80       	ldd	r8, Z+6	; 0x06
    3124:	fc 01       	movw	r30, r24
    3126:	97 80       	ldd	r9, Z+7	; 0x07
    3128:	2a 2d       	mov	r18, r10
    312a:	22 0d       	add	r18, r2
    312c:	e1 e0       	ldi	r30, 0x01	; 1
    312e:	2a 15       	cp	r18, r10
    3130:	08 f0       	brcs	.+2      	; 0x3134 <calcChecksumFRAM+0x4e2>
    3132:	e0 e0       	ldi	r30, 0x00	; 0
    3134:	3b 2d       	mov	r19, r11
    3136:	33 0d       	add	r19, r3
    3138:	f1 e0       	ldi	r31, 0x01	; 1
    313a:	3b 15       	cp	r19, r11
    313c:	08 f0       	brcs	.+2      	; 0x3140 <calcChecksumFRAM+0x4ee>
    313e:	f0 e0       	ldi	r31, 0x00	; 0
    3140:	e3 0f       	add	r30, r19
    3142:	a1 e0       	ldi	r26, 0x01	; 1
    3144:	e3 17       	cp	r30, r19
    3146:	08 f0       	brcs	.+2      	; 0x314a <calcChecksumFRAM+0x4f8>
    3148:	a0 e0       	ldi	r26, 0x00	; 0
    314a:	fa 2b       	or	r31, r26
    314c:	3e 2f       	mov	r19, r30
    314e:	4c 2d       	mov	r20, r12
    3150:	44 0d       	add	r20, r4
    3152:	e1 e0       	ldi	r30, 0x01	; 1
    3154:	4c 15       	cp	r20, r12
    3156:	08 f0       	brcs	.+2      	; 0x315a <calcChecksumFRAM+0x508>
    3158:	e0 e0       	ldi	r30, 0x00	; 0
    315a:	f4 0f       	add	r31, r20
    315c:	a1 e0       	ldi	r26, 0x01	; 1
    315e:	f4 17       	cp	r31, r20
    3160:	08 f0       	brcs	.+2      	; 0x3164 <calcChecksumFRAM+0x512>
    3162:	a0 e0       	ldi	r26, 0x00	; 0
    3164:	ea 2b       	or	r30, r26
    3166:	4f 2f       	mov	r20, r31
    3168:	5d 2d       	mov	r21, r13
    316a:	55 0d       	add	r21, r5
    316c:	f1 e0       	ldi	r31, 0x01	; 1
    316e:	5d 15       	cp	r21, r13
    3170:	08 f0       	brcs	.+2      	; 0x3174 <calcChecksumFRAM+0x522>
    3172:	f0 e0       	ldi	r31, 0x00	; 0
    3174:	e5 0f       	add	r30, r21
    3176:	a1 e0       	ldi	r26, 0x01	; 1
    3178:	e5 17       	cp	r30, r21
    317a:	08 f0       	brcs	.+2      	; 0x317e <calcChecksumFRAM+0x52c>
    317c:	a0 e0       	ldi	r26, 0x00	; 0
    317e:	fa 2b       	or	r31, r26
    3180:	5e 2f       	mov	r21, r30
    3182:	6e 2d       	mov	r22, r14
    3184:	66 0d       	add	r22, r6
    3186:	e1 e0       	ldi	r30, 0x01	; 1
    3188:	6e 15       	cp	r22, r14
    318a:	08 f0       	brcs	.+2      	; 0x318e <calcChecksumFRAM+0x53c>
    318c:	e0 e0       	ldi	r30, 0x00	; 0
    318e:	f6 0f       	add	r31, r22
    3190:	a1 e0       	ldi	r26, 0x01	; 1
    3192:	f6 17       	cp	r31, r22
    3194:	08 f0       	brcs	.+2      	; 0x3198 <calcChecksumFRAM+0x546>
    3196:	a0 e0       	ldi	r26, 0x00	; 0
    3198:	ea 2b       	or	r30, r26
    319a:	6f 2f       	mov	r22, r31
    319c:	7f 2d       	mov	r23, r15
    319e:	77 0d       	add	r23, r7
    31a0:	f1 e0       	ldi	r31, 0x01	; 1
    31a2:	7f 15       	cp	r23, r15
    31a4:	08 f0       	brcs	.+2      	; 0x31a8 <calcChecksumFRAM+0x556>
    31a6:	f0 e0       	ldi	r31, 0x00	; 0
    31a8:	e7 0f       	add	r30, r23
    31aa:	a1 e0       	ldi	r26, 0x01	; 1
    31ac:	e7 17       	cp	r30, r23
    31ae:	08 f0       	brcs	.+2      	; 0x31b2 <calcChecksumFRAM+0x560>
    31b0:	a0 e0       	ldi	r26, 0x00	; 0
    31b2:	fa 2b       	or	r31, r26
    31b4:	7e 2f       	mov	r23, r30
    31b6:	80 2f       	mov	r24, r16
    31b8:	88 0d       	add	r24, r8
    31ba:	e1 e0       	ldi	r30, 0x01	; 1
    31bc:	80 17       	cp	r24, r16
    31be:	08 f0       	brcs	.+2      	; 0x31c2 <calcChecksumFRAM+0x570>
    31c0:	e0 e0       	ldi	r30, 0x00	; 0
    31c2:	f8 0f       	add	r31, r24
    31c4:	a1 e0       	ldi	r26, 0x01	; 1
    31c6:	f8 17       	cp	r31, r24
    31c8:	08 f0       	brcs	.+2      	; 0x31cc <calcChecksumFRAM+0x57a>
    31ca:	a0 e0       	ldi	r26, 0x00	; 0
    31cc:	ea 2b       	or	r30, r26
    31ce:	8f 2f       	mov	r24, r31
    31d0:	91 2f       	mov	r25, r17
    31d2:	99 0d       	add	r25, r9
    31d4:	e9 0f       	add	r30, r25
    31d6:	9e 2f       	mov	r25, r30
    31d8:	a2 2e       	mov	r10, r18
    31da:	b3 2e       	mov	r11, r19
    31dc:	c4 2e       	mov	r12, r20
    31de:	d5 2e       	mov	r13, r21
    31e0:	e6 2e       	mov	r14, r22
    31e2:	f7 2e       	mov	r15, r23
    31e4:	08 2f       	mov	r16, r24
    31e6:	19 2f       	mov	r17, r25
    31e8:	a0 92 9a 50 	sts	0x509A, r10
    31ec:	b0 92 9b 50 	sts	0x509B, r11
    31f0:	c0 92 9c 50 	sts	0x509C, r12
    31f4:	d0 92 9d 50 	sts	0x509D, r13
    31f8:	e0 92 9e 50 	sts	0x509E, r14
    31fc:	f0 92 9f 50 	sts	0x509F, r15
    3200:	00 93 a0 50 	sts	0x50A0, r16
    3204:	10 93 a1 50 	sts	0x50A1, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3208:	8b 81       	ldd	r24, Y+3	; 0x03
    320a:	9c 81       	ldd	r25, Y+4	; 0x04
    320c:	01 96       	adiw	r24, 0x01	; 1
    320e:	8b 83       	std	Y+3, r24	; 0x03
    3210:	9c 83       	std	Y+4, r25	; 0x04
    3212:	8b 81       	ldd	r24, Y+3	; 0x03
    3214:	9c 81       	ldd	r25, Y+4	; 0x04
    3216:	fc e1       	ldi	r31, 0x1C	; 28
    3218:	81 37       	cpi	r24, 0x71	; 113
    321a:	9f 07       	cpc	r25, r31
    321c:	08 f4       	brcc	.+2      	; 0x3220 <calcChecksumFRAM+0x5ce>
    321e:	8e cd       	rjmp	.-1252   	; 0x2d3c <calcChecksumFRAM+0xea>
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3220:	89 81       	ldd	r24, Y+1	; 0x01
    3222:	9a 81       	ldd	r25, Y+2	; 0x02
    3224:	01 96       	adiw	r24, 0x01	; 1
    3226:	89 83       	std	Y+1, r24	; 0x01
    3228:	9a 83       	std	Y+2, r25	; 0x02
    322a:	89 81       	ldd	r24, Y+1	; 0x01
    322c:	9a 81       	ldd	r25, Y+2	; 0x02
    322e:	89 30       	cpi	r24, 0x09	; 9
    3230:	91 05       	cpc	r25, r1
    3232:	08 f4       	brcc	.+2      	; 0x3236 <calcChecksumFRAM+0x5e4>
    3234:	72 cd       	rjmp	.-1308   	; 0x2d1a <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3236:	24 96       	adiw	r28, 0x04	; 4
    3238:	cd bf       	out	0x3d, r28	; 61
    323a:	de bf       	out	0x3e, r29	; 62
    323c:	df 91       	pop	r29
    323e:	cf 91       	pop	r28
    3240:	1f 91       	pop	r17
    3242:	0f 91       	pop	r16
    3244:	ff 90       	pop	r15
    3246:	ef 90       	pop	r14
    3248:	df 90       	pop	r13
    324a:	cf 90       	pop	r12
    324c:	bf 90       	pop	r11
    324e:	af 90       	pop	r10
    3250:	9f 90       	pop	r9
    3252:	8f 90       	pop	r8
    3254:	7f 90       	pop	r7
    3256:	6f 90       	pop	r6
    3258:	5f 90       	pop	r5
    325a:	4f 90       	pop	r4
    325c:	3f 90       	pop	r3
    325e:	2f 90       	pop	r2
    3260:	08 95       	ret

00003262 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    3262:	cf 93       	push	r28
    3264:	df 93       	push	r29
    3266:	cd b7       	in	r28, 0x3d	; 61
    3268:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    326a:	10 92 56 40 	sts	0x4056, r1
    326e:	10 92 57 40 	sts	0x4057, r1
	sampleCount = 0;
    3272:	10 92 73 50 	sts	0x5073, r1
    3276:	10 92 74 50 	sts	0x5074, r1
    327a:	10 92 75 50 	sts	0x5075, r1
    327e:	10 92 76 50 	sts	0x5076, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3282:	80 e0       	ldi	r24, 0x00	; 0
    3284:	80 93 3a 21 	sts	0x213A, r24
    3288:	80 93 39 21 	sts	0x2139, r24
    328c:	80 93 38 21 	sts	0x2138, r24
	
	ADCPower(TRUE);
    3290:	81 e0       	ldi	r24, 0x01	; 1
    3292:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    3296:	84 e0       	ldi	r24, 0x04	; 4
    3298:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    329c:	80 ec       	ldi	r24, 0xC0	; 192
    329e:	98 e0       	ldi	r25, 0x08	; 8
    32a0:	20 ed       	ldi	r18, 0xD0	; 208
    32a2:	fc 01       	movw	r30, r24
    32a4:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    32a6:	8d e0       	ldi	r24, 0x0D	; 13
    32a8:	80 93 64 50 	sts	0x5064, r24
	SPIBuffer[1] = 0xF3;
    32ac:	83 ef       	ldi	r24, 0xF3	; 243
    32ae:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[2] = 0x57;
    32b2:	87 e5       	ldi	r24, 0x57	; 87
    32b4:	80 93 66 50 	sts	0x5066, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    32b8:	d7 c0       	rjmp	.+430    	; 0x3468 <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    32ba:	80 e4       	ldi	r24, 0x40	; 64
    32bc:	96 e0       	ldi	r25, 0x06	; 6
    32be:	20 e1       	ldi	r18, 0x10	; 16
    32c0:	fc 01       	movw	r30, r24
    32c2:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    32c4:	80 e2       	ldi	r24, 0x20	; 32
    32c6:	96 e0       	ldi	r25, 0x06	; 6
    32c8:	28 e0       	ldi	r18, 0x08	; 8
    32ca:	fc 01       	movw	r30, r24
    32cc:	26 83       	std	Z+6, r18	; 0x06
		nop();
    32ce:	00 00       	nop
		SPIC.DATA = FR_WREN;
    32d0:	80 ec       	ldi	r24, 0xC0	; 192
    32d2:	98 e0       	ldi	r25, 0x08	; 8
    32d4:	26 e0       	ldi	r18, 0x06	; 6
    32d6:	fc 01       	movw	r30, r24
    32d8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    32da:	00 00       	nop
    32dc:	80 ec       	ldi	r24, 0xC0	; 192
    32de:	98 e0       	ldi	r25, 0x08	; 8
    32e0:	fc 01       	movw	r30, r24
    32e2:	82 81       	ldd	r24, Z+2	; 0x02
    32e4:	88 23       	and	r24, r24
    32e6:	d4 f7       	brge	.-12     	; 0x32dc <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    32e8:	80 ec       	ldi	r24, 0xC0	; 192
    32ea:	98 e0       	ldi	r25, 0x08	; 8
    32ec:	fc 01       	movw	r30, r24
    32ee:	83 81       	ldd	r24, Z+3	; 0x03
    32f0:	80 93 70 50 	sts	0x5070, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    32f4:	80 e2       	ldi	r24, 0x20	; 32
    32f6:	96 e0       	ldi	r25, 0x06	; 6
    32f8:	28 e0       	ldi	r18, 0x08	; 8
    32fa:	fc 01       	movw	r30, r24
    32fc:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    32fe:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3300:	80 e2       	ldi	r24, 0x20	; 32
    3302:	96 e0       	ldi	r25, 0x06	; 6
    3304:	28 e0       	ldi	r18, 0x08	; 8
    3306:	fc 01       	movw	r30, r24
    3308:	26 83       	std	Z+6, r18	; 0x06
		nop();
    330a:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    330c:	80 ec       	ldi	r24, 0xC0	; 192
    330e:	98 e0       	ldi	r25, 0x08	; 8
    3310:	22 e0       	ldi	r18, 0x02	; 2
    3312:	fc 01       	movw	r30, r24
    3314:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3316:	00 00       	nop
    3318:	80 ec       	ldi	r24, 0xC0	; 192
    331a:	98 e0       	ldi	r25, 0x08	; 8
    331c:	fc 01       	movw	r30, r24
    331e:	82 81       	ldd	r24, Z+2	; 0x02
    3320:	88 23       	and	r24, r24
    3322:	d4 f7       	brge	.-12     	; 0x3318 <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    3324:	80 ec       	ldi	r24, 0xC0	; 192
    3326:	98 e0       	ldi	r25, 0x08	; 8
    3328:	fc 01       	movw	r30, r24
    332a:	83 81       	ldd	r24, Z+3	; 0x03
    332c:	80 93 70 50 	sts	0x5070, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    3330:	80 ec       	ldi	r24, 0xC0	; 192
    3332:	98 e0       	ldi	r25, 0x08	; 8
    3334:	20 91 57 40 	lds	r18, 0x4057
    3338:	fc 01       	movw	r30, r24
    333a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    333c:	00 00       	nop
    333e:	80 ec       	ldi	r24, 0xC0	; 192
    3340:	98 e0       	ldi	r25, 0x08	; 8
    3342:	fc 01       	movw	r30, r24
    3344:	82 81       	ldd	r24, Z+2	; 0x02
    3346:	88 23       	and	r24, r24
    3348:	d4 f7       	brge	.-12     	; 0x333e <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    334a:	80 ec       	ldi	r24, 0xC0	; 192
    334c:	98 e0       	ldi	r25, 0x08	; 8
    334e:	fc 01       	movw	r30, r24
    3350:	83 81       	ldd	r24, Z+3	; 0x03
    3352:	80 93 70 50 	sts	0x5070, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    3356:	80 ec       	ldi	r24, 0xC0	; 192
    3358:	98 e0       	ldi	r25, 0x08	; 8
    335a:	26 e5       	ldi	r18, 0x56	; 86
    335c:	30 e4       	ldi	r19, 0x40	; 64
    335e:	f9 01       	movw	r30, r18
    3360:	20 81       	ld	r18, Z
    3362:	fc 01       	movw	r30, r24
    3364:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3366:	00 00       	nop
    3368:	80 ec       	ldi	r24, 0xC0	; 192
    336a:	98 e0       	ldi	r25, 0x08	; 8
    336c:	fc 01       	movw	r30, r24
    336e:	82 81       	ldd	r24, Z+2	; 0x02
    3370:	88 23       	and	r24, r24
    3372:	d4 f7       	brge	.-12     	; 0x3368 <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3374:	80 ec       	ldi	r24, 0xC0	; 192
    3376:	98 e0       	ldi	r25, 0x08	; 8
    3378:	fc 01       	movw	r30, r24
    337a:	83 81       	ldd	r24, Z+3	; 0x03
    337c:	80 93 70 50 	sts	0x5070, r24
		SPIC.DATA = SPIBuffer[0];
    3380:	80 ec       	ldi	r24, 0xC0	; 192
    3382:	98 e0       	ldi	r25, 0x08	; 8
    3384:	20 91 64 50 	lds	r18, 0x5064
    3388:	fc 01       	movw	r30, r24
    338a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    338c:	00 00       	nop
    338e:	80 ec       	ldi	r24, 0xC0	; 192
    3390:	98 e0       	ldi	r25, 0x08	; 8
    3392:	fc 01       	movw	r30, r24
    3394:	82 81       	ldd	r24, Z+2	; 0x02
    3396:	88 23       	and	r24, r24
    3398:	d4 f7       	brge	.-12     	; 0x338e <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    339a:	80 ec       	ldi	r24, 0xC0	; 192
    339c:	98 e0       	ldi	r25, 0x08	; 8
    339e:	fc 01       	movw	r30, r24
    33a0:	83 81       	ldd	r24, Z+3	; 0x03
    33a2:	80 93 70 50 	sts	0x5070, r24
		SPIC.DATA = SPIBuffer[1];
    33a6:	80 ec       	ldi	r24, 0xC0	; 192
    33a8:	98 e0       	ldi	r25, 0x08	; 8
    33aa:	20 91 65 50 	lds	r18, 0x5065
    33ae:	fc 01       	movw	r30, r24
    33b0:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    33b2:	00 00       	nop
    33b4:	80 ec       	ldi	r24, 0xC0	; 192
    33b6:	98 e0       	ldi	r25, 0x08	; 8
    33b8:	fc 01       	movw	r30, r24
    33ba:	82 81       	ldd	r24, Z+2	; 0x02
    33bc:	88 23       	and	r24, r24
    33be:	d4 f7       	brge	.-12     	; 0x33b4 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    33c0:	80 ec       	ldi	r24, 0xC0	; 192
    33c2:	98 e0       	ldi	r25, 0x08	; 8
    33c4:	fc 01       	movw	r30, r24
    33c6:	83 81       	ldd	r24, Z+3	; 0x03
    33c8:	80 93 70 50 	sts	0x5070, r24
		SPIC.DATA = SPIBuffer[2];
    33cc:	80 ec       	ldi	r24, 0xC0	; 192
    33ce:	98 e0       	ldi	r25, 0x08	; 8
    33d0:	20 91 66 50 	lds	r18, 0x5066
    33d4:	fc 01       	movw	r30, r24
    33d6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    33d8:	00 00       	nop
    33da:	80 ec       	ldi	r24, 0xC0	; 192
    33dc:	98 e0       	ldi	r25, 0x08	; 8
    33de:	fc 01       	movw	r30, r24
    33e0:	82 81       	ldd	r24, Z+2	; 0x02
    33e2:	88 23       	and	r24, r24
    33e4:	d4 f7       	brge	.-12     	; 0x33da <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    33e6:	80 ec       	ldi	r24, 0xC0	; 192
    33e8:	98 e0       	ldi	r25, 0x08	; 8
    33ea:	fc 01       	movw	r30, r24
    33ec:	83 81       	ldd	r24, Z+3	; 0x03
    33ee:	80 93 70 50 	sts	0x5070, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    33f2:	80 e2       	ldi	r24, 0x20	; 32
    33f4:	96 e0       	ldi	r25, 0x06	; 6
    33f6:	28 e0       	ldi	r18, 0x08	; 8
    33f8:	fc 01       	movw	r30, r24
    33fa:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    33fc:	80 e4       	ldi	r24, 0x40	; 64
    33fe:	96 e0       	ldi	r25, 0x06	; 6
    3400:	20 e1       	ldi	r18, 0x10	; 16
    3402:	fc 01       	movw	r30, r24
    3404:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    3406:	80 91 56 40 	lds	r24, 0x4056
    340a:	90 91 57 40 	lds	r25, 0x4057
    340e:	03 96       	adiw	r24, 0x03	; 3
    3410:	80 93 56 40 	sts	0x4056, r24
    3414:	90 93 57 40 	sts	0x4057, r25
		checksumADC[0] += SPIBuffer[0];
    3418:	90 91 38 21 	lds	r25, 0x2138
    341c:	80 91 64 50 	lds	r24, 0x5064
    3420:	89 0f       	add	r24, r25
    3422:	80 93 38 21 	sts	0x2138, r24
		checksumADC[1] += SPIBuffer[1];
    3426:	90 91 39 21 	lds	r25, 0x2139
    342a:	80 91 65 50 	lds	r24, 0x5065
    342e:	89 0f       	add	r24, r25
    3430:	80 93 39 21 	sts	0x2139, r24
		checksumADC[2] += SPIBuffer[2];
    3434:	90 91 3a 21 	lds	r25, 0x213A
    3438:	80 91 66 50 	lds	r24, 0x5066
    343c:	89 0f       	add	r24, r25
    343e:	80 93 3a 21 	sts	0x213A, r24
		
		sampleCount++;
    3442:	80 91 73 50 	lds	r24, 0x5073
    3446:	90 91 74 50 	lds	r25, 0x5074
    344a:	a0 91 75 50 	lds	r26, 0x5075
    344e:	b0 91 76 50 	lds	r27, 0x5076
    3452:	01 96       	adiw	r24, 0x01	; 1
    3454:	a1 1d       	adc	r26, r1
    3456:	b1 1d       	adc	r27, r1
    3458:	80 93 73 50 	sts	0x5073, r24
    345c:	90 93 74 50 	sts	0x5074, r25
    3460:	a0 93 75 50 	sts	0x5075, r26
    3464:	b0 93 76 50 	sts	0x5076, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3468:	80 91 73 50 	lds	r24, 0x5073
    346c:	90 91 74 50 	lds	r25, 0x5074
    3470:	a0 91 75 50 	lds	r26, 0x5075
    3474:	b0 91 76 50 	lds	r27, 0x5076
    3478:	83 35       	cpi	r24, 0x53	; 83
    347a:	f5 e5       	ldi	r31, 0x55	; 85
    347c:	9f 07       	cpc	r25, r31
    347e:	f0 e0       	ldi	r31, 0x00	; 0
    3480:	af 07       	cpc	r26, r31
    3482:	f0 e0       	ldi	r31, 0x00	; 0
    3484:	bf 07       	cpc	r27, r31
    3486:	08 f4       	brcc	.+2      	; 0x348a <FRAMWriteKnowns+0x228>
    3488:	18 cf       	rjmp	.-464    	; 0x32ba <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    348a:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	ADCPower(FALSE);
    348e:	80 e0       	ldi	r24, 0x00	; 0
    3490:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
}
    3494:	df 91       	pop	r29
    3496:	cf 91       	pop	r28
    3498:	08 95       	ret

0000349a <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    349a:	cf 93       	push	r28
    349c:	df 93       	push	r29
    349e:	0f 92       	push	r0
    34a0:	cd b7       	in	r28, 0x3d	; 61
    34a2:	de b7       	in	r29, 0x3e	; 62
    34a4:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    34a6:	89 81       	ldd	r24, Y+1	; 0x01
    34a8:	88 2f       	mov	r24, r24
    34aa:	90 e0       	ldi	r25, 0x00	; 0
    34ac:	81 70       	andi	r24, 0x01	; 1
    34ae:	90 70       	andi	r25, 0x00	; 0
    34b0:	88 23       	and	r24, r24
    34b2:	31 f0       	breq	.+12     	; 0x34c0 <setADCInput+0x26>
    34b4:	80 e0       	ldi	r24, 0x00	; 0
    34b6:	96 e0       	ldi	r25, 0x06	; 6
    34b8:	20 e4       	ldi	r18, 0x40	; 64
    34ba:	fc 01       	movw	r30, r24
    34bc:	25 83       	std	Z+5, r18	; 0x05
    34be:	05 c0       	rjmp	.+10     	; 0x34ca <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    34c0:	80 e0       	ldi	r24, 0x00	; 0
    34c2:	96 e0       	ldi	r25, 0x06	; 6
    34c4:	20 e4       	ldi	r18, 0x40	; 64
    34c6:	fc 01       	movw	r30, r24
    34c8:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    34ca:	89 81       	ldd	r24, Y+1	; 0x01
    34cc:	88 2f       	mov	r24, r24
    34ce:	90 e0       	ldi	r25, 0x00	; 0
    34d0:	82 70       	andi	r24, 0x02	; 2
    34d2:	90 70       	andi	r25, 0x00	; 0
    34d4:	00 97       	sbiw	r24, 0x00	; 0
    34d6:	31 f0       	breq	.+12     	; 0x34e4 <setADCInput+0x4a>
    34d8:	80 e2       	ldi	r24, 0x20	; 32
    34da:	96 e0       	ldi	r25, 0x06	; 6
    34dc:	22 e0       	ldi	r18, 0x02	; 2
    34de:	fc 01       	movw	r30, r24
    34e0:	25 83       	std	Z+5, r18	; 0x05
    34e2:	05 c0       	rjmp	.+10     	; 0x34ee <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    34e4:	80 e2       	ldi	r24, 0x20	; 32
    34e6:	96 e0       	ldi	r25, 0x06	; 6
    34e8:	22 e0       	ldi	r18, 0x02	; 2
    34ea:	fc 01       	movw	r30, r24
    34ec:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    34ee:	89 81       	ldd	r24, Y+1	; 0x01
    34f0:	88 2f       	mov	r24, r24
    34f2:	90 e0       	ldi	r25, 0x00	; 0
    34f4:	84 70       	andi	r24, 0x04	; 4
    34f6:	90 70       	andi	r25, 0x00	; 0
    34f8:	00 97       	sbiw	r24, 0x00	; 0
    34fa:	31 f0       	breq	.+12     	; 0x3508 <setADCInput+0x6e>
    34fc:	80 e2       	ldi	r24, 0x20	; 32
    34fe:	96 e0       	ldi	r25, 0x06	; 6
    3500:	24 e0       	ldi	r18, 0x04	; 4
    3502:	fc 01       	movw	r30, r24
    3504:	25 83       	std	Z+5, r18	; 0x05
    3506:	05 c0       	rjmp	.+10     	; 0x3512 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    3508:	80 e2       	ldi	r24, 0x20	; 32
    350a:	96 e0       	ldi	r25, 0x06	; 6
    350c:	24 e0       	ldi	r18, 0x04	; 4
    350e:	fc 01       	movw	r30, r24
    3510:	26 83       	std	Z+6, r18	; 0x06

}
    3512:	0f 90       	pop	r0
    3514:	df 91       	pop	r29
    3516:	cf 91       	pop	r28
    3518:	08 95       	ret

0000351a <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    351a:	cf 93       	push	r28
    351c:	df 93       	push	r29
    351e:	0f 92       	push	r0
    3520:	0f 92       	push	r0
    3522:	cd b7       	in	r28, 0x3d	; 61
    3524:	de b7       	in	r29, 0x3e	; 62
    3526:	89 83       	std	Y+1, r24	; 0x01
    3528:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    352a:	89 81       	ldd	r24, Y+1	; 0x01
    352c:	9a 81       	ldd	r25, Y+2	; 0x02
    352e:	22 e0       	ldi	r18, 0x02	; 2
    3530:	80 30       	cpi	r24, 0x00	; 0
    3532:	92 07       	cpc	r25, r18
    3534:	89 f4       	brne	.+34     	; 0x3558 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3536:	80 e2       	ldi	r24, 0x20	; 32
    3538:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <SP_ReadCalibrationByte>
    353c:	28 2f       	mov	r18, r24
    353e:	89 81       	ldd	r24, Y+1	; 0x01
    3540:	9a 81       	ldd	r25, Y+2	; 0x02
    3542:	fc 01       	movw	r30, r24
    3544:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3546:	81 e2       	ldi	r24, 0x21	; 33
    3548:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <SP_ReadCalibrationByte>
    354c:	28 2f       	mov	r18, r24
    354e:	89 81       	ldd	r24, Y+1	; 0x01
    3550:	9a 81       	ldd	r25, Y+2	; 0x02
    3552:	fc 01       	movw	r30, r24
    3554:	25 87       	std	Z+13, r18	; 0x0d
    3556:	10 c0       	rjmp	.+32     	; 0x3578 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3558:	84 e2       	ldi	r24, 0x24	; 36
    355a:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <SP_ReadCalibrationByte>
    355e:	28 2f       	mov	r18, r24
    3560:	89 81       	ldd	r24, Y+1	; 0x01
    3562:	9a 81       	ldd	r25, Y+2	; 0x02
    3564:	fc 01       	movw	r30, r24
    3566:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3568:	85 e2       	ldi	r24, 0x25	; 37
    356a:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <SP_ReadCalibrationByte>
    356e:	28 2f       	mov	r18, r24
    3570:	89 81       	ldd	r24, Y+1	; 0x01
    3572:	9a 81       	ldd	r25, Y+2	; 0x02
    3574:	fc 01       	movw	r30, r24
    3576:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3578:	0f 90       	pop	r0
    357a:	0f 90       	pop	r0
    357c:	df 91       	pop	r29
    357e:	cf 91       	pop	r28
    3580:	08 95       	ret

00003582 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3582:	cf 93       	push	r28
    3584:	df 93       	push	r29
    3586:	cd b7       	in	r28, 0x3d	; 61
    3588:	de b7       	in	r29, 0x3e	; 62
    358a:	25 97       	sbiw	r28, 0x05	; 5
    358c:	cd bf       	out	0x3d, r28	; 61
    358e:	de bf       	out	0x3e, r29	; 62
    3590:	8b 83       	std	Y+3, r24	; 0x03
    3592:	9c 83       	std	Y+4, r25	; 0x04
    3594:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3596:	8b 81       	ldd	r24, Y+3	; 0x03
    3598:	9c 81       	ldd	r25, Y+4	; 0x04
    359a:	21 e0       	ldi	r18, 0x01	; 1
    359c:	fc 01       	movw	r30, r24
    359e:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    35a0:	8b 81       	ldd	r24, Y+3	; 0x03
    35a2:	9c 81       	ldd	r25, Y+4	; 0x04
    35a4:	fc 01       	movw	r30, r24
    35a6:	24 81       	ldd	r18, Z+4	; 0x04
    35a8:	35 81       	ldd	r19, Z+5	; 0x05
    35aa:	8d 81       	ldd	r24, Y+5	; 0x05
    35ac:	88 2f       	mov	r24, r24
    35ae:	90 e0       	ldi	r25, 0x00	; 0
    35b0:	a9 01       	movw	r20, r18
    35b2:	48 1b       	sub	r20, r24
    35b4:	59 0b       	sbc	r21, r25
    35b6:	ca 01       	movw	r24, r20
    35b8:	89 83       	std	Y+1, r24	; 0x01
    35ba:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    35bc:	89 81       	ldd	r24, Y+1	; 0x01
    35be:	9a 81       	ldd	r25, Y+2	; 0x02
}
    35c0:	25 96       	adiw	r28, 0x05	; 5
    35c2:	cd bf       	out	0x3d, r28	; 61
    35c4:	de bf       	out	0x3e, r29	; 62
    35c6:	df 91       	pop	r29
    35c8:	cf 91       	pop	r28
    35ca:	08 95       	ret

000035cc <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    35cc:	cf 93       	push	r28
    35ce:	df 93       	push	r29
    35d0:	cd b7       	in	r28, 0x3d	; 61
    35d2:	de b7       	in	r29, 0x3e	; 62
    35d4:	25 97       	sbiw	r28, 0x05	; 5
    35d6:	cd bf       	out	0x3d, r28	; 61
    35d8:	de bf       	out	0x3e, r29	; 62
    35da:	8b 83       	std	Y+3, r24	; 0x03
    35dc:	9c 83       	std	Y+4, r25	; 0x04
    35de:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    35e0:	8b 81       	ldd	r24, Y+3	; 0x03
    35e2:	9c 81       	ldd	r25, Y+4	; 0x04
    35e4:	21 e0       	ldi	r18, 0x01	; 1
    35e6:	fc 01       	movw	r30, r24
    35e8:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    35ea:	8b 81       	ldd	r24, Y+3	; 0x03
    35ec:	9c 81       	ldd	r25, Y+4	; 0x04
    35ee:	fc 01       	movw	r30, r24
    35f0:	24 81       	ldd	r18, Z+4	; 0x04
    35f2:	35 81       	ldd	r19, Z+5	; 0x05
    35f4:	8d 81       	ldd	r24, Y+5	; 0x05
    35f6:	99 27       	eor	r25, r25
    35f8:	87 fd       	sbrc	r24, 7
    35fa:	90 95       	com	r25
    35fc:	a9 01       	movw	r20, r18
    35fe:	48 1b       	sub	r20, r24
    3600:	59 0b       	sbc	r21, r25
    3602:	ca 01       	movw	r24, r20
    3604:	89 83       	std	Y+1, r24	; 0x01
    3606:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3608:	89 81       	ldd	r24, Y+1	; 0x01
    360a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    360c:	25 96       	adiw	r28, 0x05	; 5
    360e:	cd bf       	out	0x3d, r28	; 61
    3610:	de bf       	out	0x3e, r29	; 62
    3612:	df 91       	pop	r29
    3614:	cf 91       	pop	r28
    3616:	08 95       	ret

00003618 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3618:	cf 93       	push	r28
    361a:	df 93       	push	r29
    361c:	0f 92       	push	r0
    361e:	0f 92       	push	r0
    3620:	cd b7       	in	r28, 0x3d	; 61
    3622:	de b7       	in	r29, 0x3e	; 62
    3624:	89 83       	std	Y+1, r24	; 0x01
    3626:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3628:	89 81       	ldd	r24, Y+1	; 0x01
    362a:	9a 81       	ldd	r25, Y+2	; 0x02
    362c:	21 e0       	ldi	r18, 0x01	; 1
    362e:	fc 01       	movw	r30, r24
    3630:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3632:	89 81       	ldd	r24, Y+1	; 0x01
    3634:	9a 81       	ldd	r25, Y+2	; 0x02
    3636:	fc 01       	movw	r30, r24
    3638:	84 81       	ldd	r24, Z+4	; 0x04
    363a:	95 81       	ldd	r25, Z+5	; 0x05
}
    363c:	0f 90       	pop	r0
    363e:	0f 90       	pop	r0
    3640:	df 91       	pop	r29
    3642:	cf 91       	pop	r28
    3644:	08 95       	ret

00003646 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3646:	cf 93       	push	r28
    3648:	df 93       	push	r29
    364a:	0f 92       	push	r0
    364c:	0f 92       	push	r0
    364e:	cd b7       	in	r28, 0x3d	; 61
    3650:	de b7       	in	r29, 0x3e	; 62
    3652:	89 83       	std	Y+1, r24	; 0x01
    3654:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3656:	89 81       	ldd	r24, Y+1	; 0x01
    3658:	9a 81       	ldd	r25, Y+2	; 0x02
    365a:	21 e0       	ldi	r18, 0x01	; 1
    365c:	fc 01       	movw	r30, r24
    365e:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3660:	89 81       	ldd	r24, Y+1	; 0x01
    3662:	9a 81       	ldd	r25, Y+2	; 0x02
    3664:	fc 01       	movw	r30, r24
    3666:	84 81       	ldd	r24, Z+4	; 0x04
}
    3668:	0f 90       	pop	r0
    366a:	0f 90       	pop	r0
    366c:	df 91       	pop	r29
    366e:	cf 91       	pop	r28
    3670:	08 95       	ret

00003672 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3672:	cf 93       	push	r28
    3674:	df 93       	push	r29
    3676:	0f 92       	push	r0
    3678:	0f 92       	push	r0
    367a:	cd b7       	in	r28, 0x3d	; 61
    367c:	de b7       	in	r29, 0x3e	; 62
    367e:	89 83       	std	Y+1, r24	; 0x01
    3680:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3682:	89 81       	ldd	r24, Y+1	; 0x01
    3684:	9a 81       	ldd	r25, Y+2	; 0x02
    3686:	21 e0       	ldi	r18, 0x01	; 1
    3688:	fc 01       	movw	r30, r24
    368a:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    368c:	89 81       	ldd	r24, Y+1	; 0x01
    368e:	9a 81       	ldd	r25, Y+2	; 0x02
    3690:	fc 01       	movw	r30, r24
    3692:	85 81       	ldd	r24, Z+5	; 0x05
}
    3694:	0f 90       	pop	r0
    3696:	0f 90       	pop	r0
    3698:	df 91       	pop	r29
    369a:	cf 91       	pop	r28
    369c:	08 95       	ret

0000369e <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    369e:	0f 93       	push	r16
    36a0:	1f 93       	push	r17
    36a2:	cf 93       	push	r28
    36a4:	df 93       	push	r29
    36a6:	cd b7       	in	r28, 0x3d	; 61
    36a8:	de b7       	in	r29, 0x3e	; 62
    36aa:	6b 97       	sbiw	r28, 0x1b	; 27
    36ac:	cd bf       	out	0x3d, r28	; 61
    36ae:	de bf       	out	0x3e, r29	; 62
    36b0:	8a 8f       	std	Y+26, r24	; 0x1a
    36b2:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    36b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    36b6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    36b8:	fc 01       	movw	r30, r24
    36ba:	84 81       	ldd	r24, Z+4	; 0x04
    36bc:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    36be:	8a 8d       	ldd	r24, Y+26	; 0x1a
    36c0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    36c2:	fc 01       	movw	r30, r24
    36c4:	14 82       	std	Z+4, r1	; 0x04
    36c6:	80 e0       	ldi	r24, 0x00	; 0
    36c8:	90 e0       	ldi	r25, 0x00	; 0
    36ca:	a0 e8       	ldi	r26, 0x80	; 128
    36cc:	b2 e4       	ldi	r27, 0x42	; 66
    36ce:	8a 83       	std	Y+2, r24	; 0x02
    36d0:	9b 83       	std	Y+3, r25	; 0x03
    36d2:	ac 83       	std	Y+4, r26	; 0x04
    36d4:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    36d6:	6a 81       	ldd	r22, Y+2	; 0x02
    36d8:	7b 81       	ldd	r23, Y+3	; 0x03
    36da:	8c 81       	ldd	r24, Y+4	; 0x04
    36dc:	9d 81       	ldd	r25, Y+5	; 0x05
    36de:	2b ea       	ldi	r18, 0xAB	; 171
    36e0:	3a ea       	ldi	r19, 0xAA	; 170
    36e2:	4a e2       	ldi	r20, 0x2A	; 42
    36e4:	5f e3       	ldi	r21, 0x3F	; 63
    36e6:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    36ea:	dc 01       	movw	r26, r24
    36ec:	cb 01       	movw	r24, r22
    36ee:	8e 83       	std	Y+6, r24	; 0x06
    36f0:	9f 83       	std	Y+7, r25	; 0x07
    36f2:	a8 87       	std	Y+8, r26	; 0x08
    36f4:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    36f6:	11 e0       	ldi	r17, 0x01	; 1
    36f8:	6e 81       	ldd	r22, Y+6	; 0x06
    36fa:	7f 81       	ldd	r23, Y+7	; 0x07
    36fc:	88 85       	ldd	r24, Y+8	; 0x08
    36fe:	99 85       	ldd	r25, Y+9	; 0x09
    3700:	20 e0       	ldi	r18, 0x00	; 0
    3702:	30 e0       	ldi	r19, 0x00	; 0
    3704:	40 e8       	ldi	r20, 0x80	; 128
    3706:	5f e3       	ldi	r21, 0x3F	; 63
    3708:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    370c:	88 23       	and	r24, r24
    370e:	0c f0       	brlt	.+2      	; 0x3712 <ADC_Wait_8MHz+0x74>
    3710:	10 e0       	ldi	r17, 0x00	; 0
    3712:	11 23       	and	r17, r17
    3714:	19 f0       	breq	.+6      	; 0x371c <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3716:	81 e0       	ldi	r24, 0x01	; 1
    3718:	8a 87       	std	Y+10, r24	; 0x0a
    371a:	a3 c0       	rjmp	.+326    	; 0x3862 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    371c:	11 e0       	ldi	r17, 0x01	; 1
    371e:	6e 81       	ldd	r22, Y+6	; 0x06
    3720:	7f 81       	ldd	r23, Y+7	; 0x07
    3722:	88 85       	ldd	r24, Y+8	; 0x08
    3724:	99 85       	ldd	r25, Y+9	; 0x09
    3726:	20 e0       	ldi	r18, 0x00	; 0
    3728:	30 e0       	ldi	r19, 0x00	; 0
    372a:	4f e7       	ldi	r20, 0x7F	; 127
    372c:	53 e4       	ldi	r21, 0x43	; 67
    372e:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    3732:	18 16       	cp	r1, r24
    3734:	0c f0       	brlt	.+2      	; 0x3738 <ADC_Wait_8MHz+0x9a>
    3736:	10 e0       	ldi	r17, 0x00	; 0
    3738:	11 23       	and	r17, r17
    373a:	09 f4       	brne	.+2      	; 0x373e <ADC_Wait_8MHz+0xa0>
    373c:	89 c0       	rjmp	.+274    	; 0x3850 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    373e:	6a 81       	ldd	r22, Y+2	; 0x02
    3740:	7b 81       	ldd	r23, Y+3	; 0x03
    3742:	8c 81       	ldd	r24, Y+4	; 0x04
    3744:	9d 81       	ldd	r25, Y+5	; 0x05
    3746:	20 e0       	ldi	r18, 0x00	; 0
    3748:	30 e0       	ldi	r19, 0x00	; 0
    374a:	4a e7       	ldi	r20, 0x7A	; 122
    374c:	54 e4       	ldi	r21, 0x44	; 68
    374e:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    3752:	dc 01       	movw	r26, r24
    3754:	cb 01       	movw	r24, r22
    3756:	8b 87       	std	Y+11, r24	; 0x0b
    3758:	9c 87       	std	Y+12, r25	; 0x0c
    375a:	ad 87       	std	Y+13, r26	; 0x0d
    375c:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    375e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3760:	7c 85       	ldd	r23, Y+12	; 0x0c
    3762:	8d 85       	ldd	r24, Y+13	; 0x0d
    3764:	9e 85       	ldd	r25, Y+14	; 0x0e
    3766:	20 e0       	ldi	r18, 0x00	; 0
    3768:	30 e0       	ldi	r19, 0x00	; 0
    376a:	4a ef       	ldi	r20, 0xFA	; 250
    376c:	53 e4       	ldi	r21, 0x43	; 67
    376e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    3772:	dc 01       	movw	r26, r24
    3774:	cb 01       	movw	r24, r22
    3776:	8f 87       	std	Y+15, r24	; 0x0f
    3778:	98 8b       	std	Y+16, r25	; 0x10
    377a:	a9 8b       	std	Y+17, r26	; 0x11
    377c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    377e:	11 e0       	ldi	r17, 0x01	; 1
    3780:	6f 85       	ldd	r22, Y+15	; 0x0f
    3782:	78 89       	ldd	r23, Y+16	; 0x10
    3784:	89 89       	ldd	r24, Y+17	; 0x11
    3786:	9a 89       	ldd	r25, Y+18	; 0x12
    3788:	20 e0       	ldi	r18, 0x00	; 0
    378a:	30 e0       	ldi	r19, 0x00	; 0
    378c:	40 e8       	ldi	r20, 0x80	; 128
    378e:	5f e3       	ldi	r21, 0x3F	; 63
    3790:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    3794:	88 23       	and	r24, r24
    3796:	0c f0       	brlt	.+2      	; 0x379a <ADC_Wait_8MHz+0xfc>
    3798:	10 e0       	ldi	r17, 0x00	; 0
    379a:	11 23       	and	r17, r17
    379c:	29 f0       	breq	.+10     	; 0x37a8 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    379e:	81 e0       	ldi	r24, 0x01	; 1
    37a0:	90 e0       	ldi	r25, 0x00	; 0
    37a2:	8b 8b       	std	Y+19, r24	; 0x13
    37a4:	9c 8b       	std	Y+20, r25	; 0x14
    37a6:	46 c0       	rjmp	.+140    	; 0x3834 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    37a8:	11 e0       	ldi	r17, 0x01	; 1
    37aa:	6f 85       	ldd	r22, Y+15	; 0x0f
    37ac:	78 89       	ldd	r23, Y+16	; 0x10
    37ae:	89 89       	ldd	r24, Y+17	; 0x11
    37b0:	9a 89       	ldd	r25, Y+18	; 0x12
    37b2:	20 e0       	ldi	r18, 0x00	; 0
    37b4:	3f ef       	ldi	r19, 0xFF	; 255
    37b6:	4f e7       	ldi	r20, 0x7F	; 127
    37b8:	57 e4       	ldi	r21, 0x47	; 71
    37ba:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    37be:	18 16       	cp	r1, r24
    37c0:	0c f0       	brlt	.+2      	; 0x37c4 <ADC_Wait_8MHz+0x126>
    37c2:	10 e0       	ldi	r17, 0x00	; 0
    37c4:	11 23       	and	r17, r17
    37c6:	61 f1       	breq	.+88     	; 0x3820 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    37c8:	6b 85       	ldd	r22, Y+11	; 0x0b
    37ca:	7c 85       	ldd	r23, Y+12	; 0x0c
    37cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    37ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    37d0:	20 e0       	ldi	r18, 0x00	; 0
    37d2:	30 e0       	ldi	r19, 0x00	; 0
    37d4:	40 e2       	ldi	r20, 0x20	; 32
    37d6:	51 e4       	ldi	r21, 0x41	; 65
    37d8:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    37dc:	dc 01       	movw	r26, r24
    37de:	cb 01       	movw	r24, r22
    37e0:	bc 01       	movw	r22, r24
    37e2:	cd 01       	movw	r24, r26
    37e4:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    37e8:	dc 01       	movw	r26, r24
    37ea:	cb 01       	movw	r24, r22
    37ec:	8b 8b       	std	Y+19, r24	; 0x13
    37ee:	9c 8b       	std	Y+20, r25	; 0x14
    37f0:	12 c0       	rjmp	.+36     	; 0x3816 <ADC_Wait_8MHz+0x178>
    37f2:	82 e3       	ldi	r24, 0x32	; 50
    37f4:	90 e0       	ldi	r25, 0x00	; 0
    37f6:	8d 8b       	std	Y+21, r24	; 0x15
    37f8:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    37fa:	8d 89       	ldd	r24, Y+21	; 0x15
    37fc:	9e 89       	ldd	r25, Y+22	; 0x16
    37fe:	8c 01       	movw	r16, r24
    3800:	c8 01       	movw	r24, r16
    3802:	01 97       	sbiw	r24, 0x01	; 1
    3804:	f1 f7       	brne	.-4      	; 0x3802 <ADC_Wait_8MHz+0x164>
    3806:	8c 01       	movw	r16, r24
    3808:	0d 8b       	std	Y+21, r16	; 0x15
    380a:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    380c:	8b 89       	ldd	r24, Y+19	; 0x13
    380e:	9c 89       	ldd	r25, Y+20	; 0x14
    3810:	01 97       	sbiw	r24, 0x01	; 1
    3812:	8b 8b       	std	Y+19, r24	; 0x13
    3814:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3816:	8b 89       	ldd	r24, Y+19	; 0x13
    3818:	9c 89       	ldd	r25, Y+20	; 0x14
    381a:	00 97       	sbiw	r24, 0x00	; 0
    381c:	51 f7       	brne	.-44     	; 0x37f2 <ADC_Wait_8MHz+0x154>
    381e:	28 c0       	rjmp	.+80     	; 0x3870 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3820:	6f 85       	ldd	r22, Y+15	; 0x0f
    3822:	78 89       	ldd	r23, Y+16	; 0x10
    3824:	89 89       	ldd	r24, Y+17	; 0x11
    3826:	9a 89       	ldd	r25, Y+18	; 0x12
    3828:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    382c:	dc 01       	movw	r26, r24
    382e:	cb 01       	movw	r24, r22
    3830:	8b 8b       	std	Y+19, r24	; 0x13
    3832:	9c 8b       	std	Y+20, r25	; 0x14
    3834:	8b 89       	ldd	r24, Y+19	; 0x13
    3836:	9c 89       	ldd	r25, Y+20	; 0x14
    3838:	8f 8b       	std	Y+23, r24	; 0x17
    383a:	98 8f       	std	Y+24, r25	; 0x18
    383c:	8f 89       	ldd	r24, Y+23	; 0x17
    383e:	98 8d       	ldd	r25, Y+24	; 0x18
    3840:	8c 01       	movw	r16, r24
    3842:	f8 01       	movw	r30, r16
    3844:	31 97       	sbiw	r30, 0x01	; 1
    3846:	f1 f7       	brne	.-4      	; 0x3844 <ADC_Wait_8MHz+0x1a6>
    3848:	8f 01       	movw	r16, r30
    384a:	0f 8b       	std	Y+23, r16	; 0x17
    384c:	18 8f       	std	Y+24, r17	; 0x18
    384e:	10 c0       	rjmp	.+32     	; 0x3870 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3850:	6e 81       	ldd	r22, Y+6	; 0x06
    3852:	7f 81       	ldd	r23, Y+7	; 0x07
    3854:	88 85       	ldd	r24, Y+8	; 0x08
    3856:	99 85       	ldd	r25, Y+9	; 0x09
    3858:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    385c:	dc 01       	movw	r26, r24
    385e:	cb 01       	movw	r24, r22
    3860:	8a 87       	std	Y+10, r24	; 0x0a
    3862:	8a 85       	ldd	r24, Y+10	; 0x0a
    3864:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3866:	89 8d       	ldd	r24, Y+25	; 0x19
    3868:	18 2f       	mov	r17, r24
    386a:	1a 95       	dec	r17
    386c:	f1 f7       	brne	.-4      	; 0x386a <ADC_Wait_8MHz+0x1cc>
    386e:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3870:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3872:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3874:	29 81       	ldd	r18, Y+1	; 0x01
    3876:	fc 01       	movw	r30, r24
    3878:	24 83       	std	Z+4, r18	; 0x04
}
    387a:	6b 96       	adiw	r28, 0x1b	; 27
    387c:	cd bf       	out	0x3d, r28	; 61
    387e:	de bf       	out	0x3e, r29	; 62
    3880:	df 91       	pop	r29
    3882:	cf 91       	pop	r28
    3884:	1f 91       	pop	r17
    3886:	0f 91       	pop	r16
    3888:	08 95       	ret

0000388a <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    388a:	0f 93       	push	r16
    388c:	1f 93       	push	r17
    388e:	cf 93       	push	r28
    3890:	df 93       	push	r29
    3892:	cd b7       	in	r28, 0x3d	; 61
    3894:	de b7       	in	r29, 0x3e	; 62
    3896:	6b 97       	sbiw	r28, 0x1b	; 27
    3898:	cd bf       	out	0x3d, r28	; 61
    389a:	de bf       	out	0x3e, r29	; 62
    389c:	8a 8f       	std	Y+26, r24	; 0x1a
    389e:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    38a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    38a2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    38a4:	fc 01       	movw	r30, r24
    38a6:	84 81       	ldd	r24, Z+4	; 0x04
    38a8:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    38aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    38ac:	9b 8d       	ldd	r25, Y+27	; 0x1b
    38ae:	21 e0       	ldi	r18, 0x01	; 1
    38b0:	fc 01       	movw	r30, r24
    38b2:	24 83       	std	Z+4, r18	; 0x04
    38b4:	80 e0       	ldi	r24, 0x00	; 0
    38b6:	90 e0       	ldi	r25, 0x00	; 0
    38b8:	a0 e0       	ldi	r26, 0x00	; 0
    38ba:	b3 e4       	ldi	r27, 0x43	; 67
    38bc:	8a 83       	std	Y+2, r24	; 0x02
    38be:	9b 83       	std	Y+3, r25	; 0x03
    38c0:	ac 83       	std	Y+4, r26	; 0x04
    38c2:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    38c4:	6a 81       	ldd	r22, Y+2	; 0x02
    38c6:	7b 81       	ldd	r23, Y+3	; 0x03
    38c8:	8c 81       	ldd	r24, Y+4	; 0x04
    38ca:	9d 81       	ldd	r25, Y+5	; 0x05
    38cc:	2b ea       	ldi	r18, 0xAB	; 171
    38ce:	3a ea       	ldi	r19, 0xAA	; 170
    38d0:	4a e2       	ldi	r20, 0x2A	; 42
    38d2:	5f e3       	ldi	r21, 0x3F	; 63
    38d4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    38d8:	dc 01       	movw	r26, r24
    38da:	cb 01       	movw	r24, r22
    38dc:	8e 83       	std	Y+6, r24	; 0x06
    38de:	9f 83       	std	Y+7, r25	; 0x07
    38e0:	a8 87       	std	Y+8, r26	; 0x08
    38e2:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    38e4:	11 e0       	ldi	r17, 0x01	; 1
    38e6:	6e 81       	ldd	r22, Y+6	; 0x06
    38e8:	7f 81       	ldd	r23, Y+7	; 0x07
    38ea:	88 85       	ldd	r24, Y+8	; 0x08
    38ec:	99 85       	ldd	r25, Y+9	; 0x09
    38ee:	20 e0       	ldi	r18, 0x00	; 0
    38f0:	30 e0       	ldi	r19, 0x00	; 0
    38f2:	40 e8       	ldi	r20, 0x80	; 128
    38f4:	5f e3       	ldi	r21, 0x3F	; 63
    38f6:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    38fa:	88 23       	and	r24, r24
    38fc:	0c f0       	brlt	.+2      	; 0x3900 <ADC_Wait_32MHz+0x76>
    38fe:	10 e0       	ldi	r17, 0x00	; 0
    3900:	11 23       	and	r17, r17
    3902:	19 f0       	breq	.+6      	; 0x390a <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3904:	81 e0       	ldi	r24, 0x01	; 1
    3906:	8a 87       	std	Y+10, r24	; 0x0a
    3908:	a3 c0       	rjmp	.+326    	; 0x3a50 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    390a:	11 e0       	ldi	r17, 0x01	; 1
    390c:	6e 81       	ldd	r22, Y+6	; 0x06
    390e:	7f 81       	ldd	r23, Y+7	; 0x07
    3910:	88 85       	ldd	r24, Y+8	; 0x08
    3912:	99 85       	ldd	r25, Y+9	; 0x09
    3914:	20 e0       	ldi	r18, 0x00	; 0
    3916:	30 e0       	ldi	r19, 0x00	; 0
    3918:	4f e7       	ldi	r20, 0x7F	; 127
    391a:	53 e4       	ldi	r21, 0x43	; 67
    391c:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    3920:	18 16       	cp	r1, r24
    3922:	0c f0       	brlt	.+2      	; 0x3926 <ADC_Wait_32MHz+0x9c>
    3924:	10 e0       	ldi	r17, 0x00	; 0
    3926:	11 23       	and	r17, r17
    3928:	09 f4       	brne	.+2      	; 0x392c <ADC_Wait_32MHz+0xa2>
    392a:	89 c0       	rjmp	.+274    	; 0x3a3e <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    392c:	6a 81       	ldd	r22, Y+2	; 0x02
    392e:	7b 81       	ldd	r23, Y+3	; 0x03
    3930:	8c 81       	ldd	r24, Y+4	; 0x04
    3932:	9d 81       	ldd	r25, Y+5	; 0x05
    3934:	20 e0       	ldi	r18, 0x00	; 0
    3936:	30 e0       	ldi	r19, 0x00	; 0
    3938:	4a e7       	ldi	r20, 0x7A	; 122
    393a:	54 e4       	ldi	r21, 0x44	; 68
    393c:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    3940:	dc 01       	movw	r26, r24
    3942:	cb 01       	movw	r24, r22
    3944:	8b 87       	std	Y+11, r24	; 0x0b
    3946:	9c 87       	std	Y+12, r25	; 0x0c
    3948:	ad 87       	std	Y+13, r26	; 0x0d
    394a:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    394c:	6b 85       	ldd	r22, Y+11	; 0x0b
    394e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3950:	8d 85       	ldd	r24, Y+13	; 0x0d
    3952:	9e 85       	ldd	r25, Y+14	; 0x0e
    3954:	20 e0       	ldi	r18, 0x00	; 0
    3956:	30 e0       	ldi	r19, 0x00	; 0
    3958:	4a ef       	ldi	r20, 0xFA	; 250
    395a:	53 e4       	ldi	r21, 0x43	; 67
    395c:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    3960:	dc 01       	movw	r26, r24
    3962:	cb 01       	movw	r24, r22
    3964:	8f 87       	std	Y+15, r24	; 0x0f
    3966:	98 8b       	std	Y+16, r25	; 0x10
    3968:	a9 8b       	std	Y+17, r26	; 0x11
    396a:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    396c:	11 e0       	ldi	r17, 0x01	; 1
    396e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3970:	78 89       	ldd	r23, Y+16	; 0x10
    3972:	89 89       	ldd	r24, Y+17	; 0x11
    3974:	9a 89       	ldd	r25, Y+18	; 0x12
    3976:	20 e0       	ldi	r18, 0x00	; 0
    3978:	30 e0       	ldi	r19, 0x00	; 0
    397a:	40 e8       	ldi	r20, 0x80	; 128
    397c:	5f e3       	ldi	r21, 0x3F	; 63
    397e:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    3982:	88 23       	and	r24, r24
    3984:	0c f0       	brlt	.+2      	; 0x3988 <ADC_Wait_32MHz+0xfe>
    3986:	10 e0       	ldi	r17, 0x00	; 0
    3988:	11 23       	and	r17, r17
    398a:	29 f0       	breq	.+10     	; 0x3996 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    398c:	81 e0       	ldi	r24, 0x01	; 1
    398e:	90 e0       	ldi	r25, 0x00	; 0
    3990:	8b 8b       	std	Y+19, r24	; 0x13
    3992:	9c 8b       	std	Y+20, r25	; 0x14
    3994:	46 c0       	rjmp	.+140    	; 0x3a22 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3996:	11 e0       	ldi	r17, 0x01	; 1
    3998:	6f 85       	ldd	r22, Y+15	; 0x0f
    399a:	78 89       	ldd	r23, Y+16	; 0x10
    399c:	89 89       	ldd	r24, Y+17	; 0x11
    399e:	9a 89       	ldd	r25, Y+18	; 0x12
    39a0:	20 e0       	ldi	r18, 0x00	; 0
    39a2:	3f ef       	ldi	r19, 0xFF	; 255
    39a4:	4f e7       	ldi	r20, 0x7F	; 127
    39a6:	57 e4       	ldi	r21, 0x47	; 71
    39a8:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    39ac:	18 16       	cp	r1, r24
    39ae:	0c f0       	brlt	.+2      	; 0x39b2 <ADC_Wait_32MHz+0x128>
    39b0:	10 e0       	ldi	r17, 0x00	; 0
    39b2:	11 23       	and	r17, r17
    39b4:	61 f1       	breq	.+88     	; 0x3a0e <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    39b6:	6b 85       	ldd	r22, Y+11	; 0x0b
    39b8:	7c 85       	ldd	r23, Y+12	; 0x0c
    39ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    39bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    39be:	20 e0       	ldi	r18, 0x00	; 0
    39c0:	30 e0       	ldi	r19, 0x00	; 0
    39c2:	40 e2       	ldi	r20, 0x20	; 32
    39c4:	51 e4       	ldi	r21, 0x41	; 65
    39c6:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    39ca:	dc 01       	movw	r26, r24
    39cc:	cb 01       	movw	r24, r22
    39ce:	bc 01       	movw	r22, r24
    39d0:	cd 01       	movw	r24, r26
    39d2:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    39d6:	dc 01       	movw	r26, r24
    39d8:	cb 01       	movw	r24, r22
    39da:	8b 8b       	std	Y+19, r24	; 0x13
    39dc:	9c 8b       	std	Y+20, r25	; 0x14
    39de:	12 c0       	rjmp	.+36     	; 0x3a04 <ADC_Wait_32MHz+0x17a>
    39e0:	82 e3       	ldi	r24, 0x32	; 50
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	8d 8b       	std	Y+21, r24	; 0x15
    39e6:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    39e8:	8d 89       	ldd	r24, Y+21	; 0x15
    39ea:	9e 89       	ldd	r25, Y+22	; 0x16
    39ec:	8c 01       	movw	r16, r24
    39ee:	c8 01       	movw	r24, r16
    39f0:	01 97       	sbiw	r24, 0x01	; 1
    39f2:	f1 f7       	brne	.-4      	; 0x39f0 <ADC_Wait_32MHz+0x166>
    39f4:	8c 01       	movw	r16, r24
    39f6:	0d 8b       	std	Y+21, r16	; 0x15
    39f8:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39fa:	8b 89       	ldd	r24, Y+19	; 0x13
    39fc:	9c 89       	ldd	r25, Y+20	; 0x14
    39fe:	01 97       	sbiw	r24, 0x01	; 1
    3a00:	8b 8b       	std	Y+19, r24	; 0x13
    3a02:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3a04:	8b 89       	ldd	r24, Y+19	; 0x13
    3a06:	9c 89       	ldd	r25, Y+20	; 0x14
    3a08:	00 97       	sbiw	r24, 0x00	; 0
    3a0a:	51 f7       	brne	.-44     	; 0x39e0 <ADC_Wait_32MHz+0x156>
    3a0c:	28 c0       	rjmp	.+80     	; 0x3a5e <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3a0e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3a10:	78 89       	ldd	r23, Y+16	; 0x10
    3a12:	89 89       	ldd	r24, Y+17	; 0x11
    3a14:	9a 89       	ldd	r25, Y+18	; 0x12
    3a16:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    3a1a:	dc 01       	movw	r26, r24
    3a1c:	cb 01       	movw	r24, r22
    3a1e:	8b 8b       	std	Y+19, r24	; 0x13
    3a20:	9c 8b       	std	Y+20, r25	; 0x14
    3a22:	8b 89       	ldd	r24, Y+19	; 0x13
    3a24:	9c 89       	ldd	r25, Y+20	; 0x14
    3a26:	8f 8b       	std	Y+23, r24	; 0x17
    3a28:	98 8f       	std	Y+24, r25	; 0x18
    3a2a:	8f 89       	ldd	r24, Y+23	; 0x17
    3a2c:	98 8d       	ldd	r25, Y+24	; 0x18
    3a2e:	8c 01       	movw	r16, r24
    3a30:	f8 01       	movw	r30, r16
    3a32:	31 97       	sbiw	r30, 0x01	; 1
    3a34:	f1 f7       	brne	.-4      	; 0x3a32 <ADC_Wait_32MHz+0x1a8>
    3a36:	8f 01       	movw	r16, r30
    3a38:	0f 8b       	std	Y+23, r16	; 0x17
    3a3a:	18 8f       	std	Y+24, r17	; 0x18
    3a3c:	10 c0       	rjmp	.+32     	; 0x3a5e <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3a3e:	6e 81       	ldd	r22, Y+6	; 0x06
    3a40:	7f 81       	ldd	r23, Y+7	; 0x07
    3a42:	88 85       	ldd	r24, Y+8	; 0x08
    3a44:	99 85       	ldd	r25, Y+9	; 0x09
    3a46:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    3a4a:	dc 01       	movw	r26, r24
    3a4c:	cb 01       	movw	r24, r22
    3a4e:	8a 87       	std	Y+10, r24	; 0x0a
    3a50:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a52:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a54:	89 8d       	ldd	r24, Y+25	; 0x19
    3a56:	18 2f       	mov	r17, r24
    3a58:	1a 95       	dec	r17
    3a5a:	f1 f7       	brne	.-4      	; 0x3a58 <ADC_Wait_32MHz+0x1ce>
    3a5c:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3a5e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a60:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a62:	29 81       	ldd	r18, Y+1	; 0x01
    3a64:	fc 01       	movw	r30, r24
    3a66:	24 83       	std	Z+4, r18	; 0x04
}
    3a68:	6b 96       	adiw	r28, 0x1b	; 27
    3a6a:	cd bf       	out	0x3d, r28	; 61
    3a6c:	de bf       	out	0x3e, r29	; 62
    3a6e:	df 91       	pop	r29
    3a70:	cf 91       	pop	r28
    3a72:	1f 91       	pop	r17
    3a74:	0f 91       	pop	r16
    3a76:	08 95       	ret

00003a78 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3a78:	cf 93       	push	r28
    3a7a:	df 93       	push	r29
    3a7c:	cd b7       	in	r28, 0x3d	; 61
    3a7e:	de b7       	in	r29, 0x3e	; 62
    3a80:	2a 97       	sbiw	r28, 0x0a	; 10
    3a82:	cd bf       	out	0x3d, r28	; 61
    3a84:	de bf       	out	0x3e, r29	; 62
    3a86:	8e 83       	std	Y+6, r24	; 0x06
    3a88:	9f 83       	std	Y+7, r25	; 0x07
    3a8a:	68 87       	std	Y+8, r22	; 0x08
    3a8c:	79 87       	std	Y+9, r23	; 0x09
    3a8e:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3a90:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a92:	88 23       	and	r24, r24
    3a94:	a9 f1       	breq	.+106    	; 0x3b00 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3a96:	19 82       	std	Y+1, r1	; 0x01
    3a98:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3a9a:	1b 82       	std	Y+3, r1	; 0x03
    3a9c:	1c 82       	std	Y+4, r1	; 0x04
    3a9e:	24 c0       	rjmp	.+72     	; 0x3ae8 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3aa0:	88 85       	ldd	r24, Y+8	; 0x08
    3aa2:	99 85       	ldd	r25, Y+9	; 0x09
    3aa4:	fc 01       	movw	r30, r24
    3aa6:	80 81       	ld	r24, Z
    3aa8:	28 2f       	mov	r18, r24
    3aaa:	20 68       	ori	r18, 0x80	; 128
    3aac:	88 85       	ldd	r24, Y+8	; 0x08
    3aae:	99 85       	ldd	r25, Y+9	; 0x09
    3ab0:	fc 01       	movw	r30, r24
    3ab2:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3ab4:	88 85       	ldd	r24, Y+8	; 0x08
    3ab6:	99 85       	ldd	r25, Y+9	; 0x09
    3ab8:	fc 01       	movw	r30, r24
    3aba:	83 81       	ldd	r24, Z+3	; 0x03
    3abc:	88 2f       	mov	r24, r24
    3abe:	90 e0       	ldi	r25, 0x00	; 0
    3ac0:	81 70       	andi	r24, 0x01	; 1
    3ac2:	90 70       	andi	r25, 0x00	; 0
    3ac4:	00 97       	sbiw	r24, 0x00	; 0
    3ac6:	b1 f3       	breq	.-20     	; 0x3ab4 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3ac8:	88 85       	ldd	r24, Y+8	; 0x08
    3aca:	99 85       	ldd	r25, Y+9	; 0x09
    3acc:	60 e0       	ldi	r22, 0x00	; 0
    3ace:	0e 94 c1 1a 	call	0x3582	; 0x3582 <ADC_ResultCh_GetWord_Unsigned>
    3ad2:	29 81       	ldd	r18, Y+1	; 0x01
    3ad4:	3a 81       	ldd	r19, Y+2	; 0x02
    3ad6:	82 0f       	add	r24, r18
    3ad8:	93 1f       	adc	r25, r19
    3ada:	89 83       	std	Y+1, r24	; 0x01
    3adc:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3ade:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ae2:	01 96       	adiw	r24, 0x01	; 1
    3ae4:	8b 83       	std	Y+3, r24	; 0x03
    3ae6:	9c 83       	std	Y+4, r25	; 0x04
    3ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aea:	9c 81       	ldd	r25, Y+4	; 0x04
    3aec:	84 30       	cpi	r24, 0x04	; 4
    3aee:	91 05       	cpc	r25, r1
    3af0:	bc f2       	brlt	.-82     	; 0x3aa0 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3af2:	89 81       	ldd	r24, Y+1	; 0x01
    3af4:	9a 81       	ldd	r25, Y+2	; 0x02
    3af6:	96 95       	lsr	r25
    3af8:	87 95       	ror	r24
    3afa:	96 95       	lsr	r25
    3afc:	87 95       	ror	r24
    3afe:	1b c0       	rjmp	.+54     	; 0x3b36 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3b00:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3b02:	88 85       	ldd	r24, Y+8	; 0x08
    3b04:	99 85       	ldd	r25, Y+9	; 0x09
    3b06:	fc 01       	movw	r30, r24
    3b08:	80 81       	ld	r24, Z
    3b0a:	28 2f       	mov	r18, r24
    3b0c:	20 68       	ori	r18, 0x80	; 128
    3b0e:	88 85       	ldd	r24, Y+8	; 0x08
    3b10:	99 85       	ldd	r25, Y+9	; 0x09
    3b12:	fc 01       	movw	r30, r24
    3b14:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3b16:	88 85       	ldd	r24, Y+8	; 0x08
    3b18:	99 85       	ldd	r25, Y+9	; 0x09
    3b1a:	fc 01       	movw	r30, r24
    3b1c:	83 81       	ldd	r24, Z+3	; 0x03
    3b1e:	88 2f       	mov	r24, r24
    3b20:	90 e0       	ldi	r25, 0x00	; 0
    3b22:	81 70       	andi	r24, 0x01	; 1
    3b24:	90 70       	andi	r25, 0x00	; 0
    3b26:	00 97       	sbiw	r24, 0x00	; 0
    3b28:	b1 f3       	breq	.-20     	; 0x3b16 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3b2a:	88 85       	ldd	r24, Y+8	; 0x08
    3b2c:	99 85       	ldd	r25, Y+9	; 0x09
    3b2e:	0e 94 0c 1b 	call	0x3618	; 0x3618 <ADC_ResultCh_GetWord>
    3b32:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3b34:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3b36:	2a 96       	adiw	r28, 0x0a	; 10
    3b38:	cd bf       	out	0x3d, r28	; 61
    3b3a:	de bf       	out	0x3e, r29	; 62
    3b3c:	df 91       	pop	r29
    3b3e:	cf 91       	pop	r28
    3b40:	08 95       	ret

00003b42 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3b42:	cf 93       	push	r28
    3b44:	df 93       	push	r29
    3b46:	cd b7       	in	r28, 0x3d	; 61
    3b48:	de b7       	in	r29, 0x3e	; 62
    3b4a:	2a 97       	sbiw	r28, 0x0a	; 10
    3b4c:	cd bf       	out	0x3d, r28	; 61
    3b4e:	de bf       	out	0x3e, r29	; 62
    3b50:	8e 83       	std	Y+6, r24	; 0x06
    3b52:	9f 83       	std	Y+7, r25	; 0x07
    3b54:	68 87       	std	Y+8, r22	; 0x08
    3b56:	79 87       	std	Y+9, r23	; 0x09
    3b58:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3b5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b5c:	88 23       	and	r24, r24
    3b5e:	c1 f1       	breq	.+112    	; 0x3bd0 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3b60:	19 82       	std	Y+1, r1	; 0x01
    3b62:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3b64:	1b 82       	std	Y+3, r1	; 0x03
    3b66:	1c 82       	std	Y+4, r1	; 0x04
    3b68:	24 c0       	rjmp	.+72     	; 0x3bb2 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3b6a:	88 85       	ldd	r24, Y+8	; 0x08
    3b6c:	99 85       	ldd	r25, Y+9	; 0x09
    3b6e:	fc 01       	movw	r30, r24
    3b70:	80 81       	ld	r24, Z
    3b72:	28 2f       	mov	r18, r24
    3b74:	20 68       	ori	r18, 0x80	; 128
    3b76:	88 85       	ldd	r24, Y+8	; 0x08
    3b78:	99 85       	ldd	r25, Y+9	; 0x09
    3b7a:	fc 01       	movw	r30, r24
    3b7c:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3b7e:	88 85       	ldd	r24, Y+8	; 0x08
    3b80:	99 85       	ldd	r25, Y+9	; 0x09
    3b82:	fc 01       	movw	r30, r24
    3b84:	83 81       	ldd	r24, Z+3	; 0x03
    3b86:	88 2f       	mov	r24, r24
    3b88:	90 e0       	ldi	r25, 0x00	; 0
    3b8a:	81 70       	andi	r24, 0x01	; 1
    3b8c:	90 70       	andi	r25, 0x00	; 0
    3b8e:	00 97       	sbiw	r24, 0x00	; 0
    3b90:	b1 f3       	breq	.-20     	; 0x3b7e <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3b92:	88 85       	ldd	r24, Y+8	; 0x08
    3b94:	99 85       	ldd	r25, Y+9	; 0x09
    3b96:	60 e0       	ldi	r22, 0x00	; 0
    3b98:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <ADC_ResultCh_GetWord_Signed>
    3b9c:	29 81       	ldd	r18, Y+1	; 0x01
    3b9e:	3a 81       	ldd	r19, Y+2	; 0x02
    3ba0:	82 0f       	add	r24, r18
    3ba2:	93 1f       	adc	r25, r19
    3ba4:	89 83       	std	Y+1, r24	; 0x01
    3ba6:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3ba8:	8b 81       	ldd	r24, Y+3	; 0x03
    3baa:	9c 81       	ldd	r25, Y+4	; 0x04
    3bac:	01 96       	adiw	r24, 0x01	; 1
    3bae:	8b 83       	std	Y+3, r24	; 0x03
    3bb0:	9c 83       	std	Y+4, r25	; 0x04
    3bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    3bb6:	84 30       	cpi	r24, 0x04	; 4
    3bb8:	91 05       	cpc	r25, r1
    3bba:	bc f2       	brlt	.-82     	; 0x3b6a <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3bbc:	89 81       	ldd	r24, Y+1	; 0x01
    3bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc0:	99 23       	and	r25, r25
    3bc2:	0c f4       	brge	.+2      	; 0x3bc6 <ADC_Offset_Get_Signed+0x84>
    3bc4:	03 96       	adiw	r24, 0x03	; 3
    3bc6:	95 95       	asr	r25
    3bc8:	87 95       	ror	r24
    3bca:	95 95       	asr	r25
    3bcc:	87 95       	ror	r24
    3bce:	1c c0       	rjmp	.+56     	; 0x3c08 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3bd0:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3bd2:	88 85       	ldd	r24, Y+8	; 0x08
    3bd4:	99 85       	ldd	r25, Y+9	; 0x09
    3bd6:	fc 01       	movw	r30, r24
    3bd8:	80 81       	ld	r24, Z
    3bda:	28 2f       	mov	r18, r24
    3bdc:	20 68       	ori	r18, 0x80	; 128
    3bde:	88 85       	ldd	r24, Y+8	; 0x08
    3be0:	99 85       	ldd	r25, Y+9	; 0x09
    3be2:	fc 01       	movw	r30, r24
    3be4:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3be6:	88 85       	ldd	r24, Y+8	; 0x08
    3be8:	99 85       	ldd	r25, Y+9	; 0x09
    3bea:	fc 01       	movw	r30, r24
    3bec:	83 81       	ldd	r24, Z+3	; 0x03
    3bee:	88 2f       	mov	r24, r24
    3bf0:	90 e0       	ldi	r25, 0x00	; 0
    3bf2:	81 70       	andi	r24, 0x01	; 1
    3bf4:	90 70       	andi	r25, 0x00	; 0
    3bf6:	00 97       	sbiw	r24, 0x00	; 0
    3bf8:	b1 f3       	breq	.-20     	; 0x3be6 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3bfa:	88 85       	ldd	r24, Y+8	; 0x08
    3bfc:	99 85       	ldd	r25, Y+9	; 0x09
    3bfe:	60 e0       	ldi	r22, 0x00	; 0
    3c00:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <ADC_ResultCh_GetWord_Signed>
    3c04:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3c06:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3c08:	2a 96       	adiw	r28, 0x0a	; 10
    3c0a:	cd bf       	out	0x3d, r28	; 61
    3c0c:	de bf       	out	0x3e, r29	; 62
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	08 95       	ret

00003c14 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3c14:	1f 93       	push	r17
    3c16:	cf 93       	push	r28
    3c18:	df 93       	push	r29
    3c1a:	cd b7       	in	r28, 0x3d	; 61
    3c1c:	de b7       	in	r29, 0x3e	; 62
    3c1e:	25 97       	sbiw	r28, 0x05	; 5
    3c20:	cd bf       	out	0x3d, r28	; 61
    3c22:	de bf       	out	0x3e, r29	; 62
    3c24:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3c26:	8a ec       	ldi	r24, 0xCA	; 202
    3c28:	91 e0       	ldi	r25, 0x01	; 1
    3c2a:	22 e0       	ldi	r18, 0x02	; 2
    3c2c:	fc 01       	movw	r30, r24
    3c2e:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3c30:	8d 81       	ldd	r24, Y+5	; 0x05
    3c32:	88 2f       	mov	r24, r24
    3c34:	90 e0       	ldi	r25, 0x00	; 0
    3c36:	89 83       	std	Y+1, r24	; 0x01
    3c38:	9a 83       	std	Y+2, r25	; 0x02
    3c3a:	89 81       	ldd	r24, Y+1	; 0x01
    3c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3e:	fc 01       	movw	r30, r24
    3c40:	14 91       	lpm	r17, Z
    3c42:	1b 83       	std	Y+3, r17	; 0x03
    3c44:	8b 81       	ldd	r24, Y+3	; 0x03
    3c46:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3c48:	8a ec       	ldi	r24, 0xCA	; 202
    3c4a:	91 e0       	ldi	r25, 0x01	; 1
    3c4c:	fc 01       	movw	r30, r24
    3c4e:	10 82       	st	Z, r1

	return result;
    3c50:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3c52:	25 96       	adiw	r28, 0x05	; 5
    3c54:	cd bf       	out	0x3d, r28	; 61
    3c56:	de bf       	out	0x3e, r29	; 62
    3c58:	df 91       	pop	r29
    3c5a:	cf 91       	pop	r28
    3c5c:	1f 91       	pop	r17
    3c5e:	08 95       	ret

00003c60 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3c60:	cf 93       	push	r28
    3c62:	df 93       	push	r29
    3c64:	cd b7       	in	r28, 0x3d	; 61
    3c66:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3c68:	24 e1       	ldi	r18, 0x14	; 20
    3c6a:	8e e3       	ldi	r24, 0x3E	; 62
    3c6c:	91 e2       	ldi	r25, 0x21	; 33
    3c6e:	fc 01       	movw	r30, r24
    3c70:	32 2f       	mov	r19, r18
    3c72:	11 92       	st	Z+, r1
    3c74:	3a 95       	dec	r19
    3c76:	e9 f7       	brne	.-6      	; 0x3c72 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3c78:	0e 94 f0 2b 	call	0x57e0	; 0x57e0 <chb_get_short_addr>
    3c7c:	80 93 3e 21 	sts	0x213E, r24
    3c80:	90 93 3f 21 	sts	0x213F, r25
    chb_drvr_init();
    3c84:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <chb_drvr_init>
	radio_msg_received_int_enable();
    3c88:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <radio_msg_received_int_enable>
}
    3c8c:	df 91       	pop	r29
    3c8e:	cf 91       	pop	r28
    3c90:	08 95       	ret

00003c92 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    3c92:	cf 93       	push	r28
    3c94:	df 93       	push	r29
    3c96:	cd b7       	in	r28, 0x3d	; 61
    3c98:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    3c9a:	80 e8       	ldi	r24, 0x80	; 128
    3c9c:	96 e0       	ldi	r25, 0x06	; 6
    3c9e:	24 e0       	ldi	r18, 0x04	; 4
    3ca0:	fc 01       	movw	r30, r24
    3ca2:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3ca4:	80 e8       	ldi	r24, 0x80	; 128
    3ca6:	96 e0       	ldi	r25, 0x06	; 6
    3ca8:	24 e0       	ldi	r18, 0x04	; 4
    3caa:	fc 01       	movw	r30, r24
    3cac:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3cae:	80 e8       	ldi	r24, 0x80	; 128
    3cb0:	96 e0       	ldi	r25, 0x06	; 6
    3cb2:	22 e0       	ldi	r18, 0x02	; 2
    3cb4:	fc 01       	movw	r30, r24
    3cb6:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3cb8:	80 e8       	ldi	r24, 0x80	; 128
    3cba:	96 e0       	ldi	r25, 0x06	; 6
    3cbc:	24 e0       	ldi	r18, 0x04	; 4
    3cbe:	fc 01       	movw	r30, r24
    3cc0:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3cc2:	80 e8       	ldi	r24, 0x80	; 128
    3cc4:	96 e0       	ldi	r25, 0x06	; 6
    3cc6:	23 e0       	ldi	r18, 0x03	; 3
    3cc8:	fc 01       	movw	r30, r24
    3cca:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3ccc:	80 ea       	ldi	r24, 0xA0	; 160
    3cce:	90 e0       	ldi	r25, 0x00	; 0
    3cd0:	20 ea       	ldi	r18, 0xA0	; 160
    3cd2:	30 e0       	ldi	r19, 0x00	; 0
    3cd4:	f9 01       	movw	r30, r18
    3cd6:	22 81       	ldd	r18, Z+2	; 0x02
    3cd8:	24 60       	ori	r18, 0x04	; 4
    3cda:	fc 01       	movw	r30, r24
    3cdc:	22 83       	std	Z+2, r18	; 0x02
	sei();
    3cde:	78 94       	sei
}
    3ce0:	df 91       	pop	r29
    3ce2:	cf 91       	pop	r28
    3ce4:	08 95       	ret

00003ce6 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3ce6:	cf 93       	push	r28
    3ce8:	df 93       	push	r29
    3cea:	cd b7       	in	r28, 0x3d	; 61
    3cec:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3cee:	8e e3       	ldi	r24, 0x3E	; 62
    3cf0:	91 e2       	ldi	r25, 0x21	; 33
}
    3cf2:	df 91       	pop	r29
    3cf4:	cf 91       	pop	r28
    3cf6:	08 95       	ret

00003cf8 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3cf8:	cf 93       	push	r28
    3cfa:	df 93       	push	r29
    3cfc:	cd b7       	in	r28, 0x3d	; 61
    3cfe:	de b7       	in	r29, 0x3e	; 62
    3d00:	27 97       	sbiw	r28, 0x07	; 7
    3d02:	cd bf       	out	0x3d, r28	; 61
    3d04:	de bf       	out	0x3e, r29	; 62
    3d06:	8b 83       	std	Y+3, r24	; 0x03
    3d08:	9c 83       	std	Y+4, r25	; 0x04
    3d0a:	6d 83       	std	Y+5, r22	; 0x05
    3d0c:	7e 83       	std	Y+6, r23	; 0x06
    3d0e:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3d10:	8b 81       	ldd	r24, Y+3	; 0x03
    3d12:	9c 81       	ldd	r25, Y+4	; 0x04
    3d14:	89 83       	std	Y+1, r24	; 0x01
    3d16:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3d18:	8f 81       	ldd	r24, Y+7	; 0x07
    3d1a:	28 2f       	mov	r18, r24
    3d1c:	25 5f       	subi	r18, 0xF5	; 245
    3d1e:	89 81       	ldd	r24, Y+1	; 0x01
    3d20:	9a 81       	ldd	r25, Y+2	; 0x02
    3d22:	fc 01       	movw	r30, r24
    3d24:	20 83       	st	Z, r18
    3d26:	89 81       	ldd	r24, Y+1	; 0x01
    3d28:	9a 81       	ldd	r25, Y+2	; 0x02
    3d2a:	01 96       	adiw	r24, 0x01	; 1
    3d2c:	89 83       	std	Y+1, r24	; 0x01
    3d2e:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3d30:	8d 81       	ldd	r24, Y+5	; 0x05
    3d32:	9e 81       	ldd	r25, Y+6	; 0x06
    3d34:	ff ef       	ldi	r31, 0xFF	; 255
    3d36:	8f 3f       	cpi	r24, 0xFF	; 255
    3d38:	9f 07       	cpc	r25, r31
    3d3a:	11 f0       	breq	.+4      	; 0x3d40 <chb_gen_hdr+0x48>
    3d3c:	21 e6       	ldi	r18, 0x61	; 97
    3d3e:	01 c0       	rjmp	.+2      	; 0x3d42 <chb_gen_hdr+0x4a>
    3d40:	21 e4       	ldi	r18, 0x41	; 65
    3d42:	89 81       	ldd	r24, Y+1	; 0x01
    3d44:	9a 81       	ldd	r25, Y+2	; 0x02
    3d46:	fc 01       	movw	r30, r24
    3d48:	20 83       	st	Z, r18
    3d4a:	89 81       	ldd	r24, Y+1	; 0x01
    3d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4e:	01 96       	adiw	r24, 0x01	; 1
    3d50:	89 83       	std	Y+1, r24	; 0x01
    3d52:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3d54:	89 81       	ldd	r24, Y+1	; 0x01
    3d56:	9a 81       	ldd	r25, Y+2	; 0x02
    3d58:	28 e9       	ldi	r18, 0x98	; 152
    3d5a:	fc 01       	movw	r30, r24
    3d5c:	20 83       	st	Z, r18
    3d5e:	89 81       	ldd	r24, Y+1	; 0x01
    3d60:	9a 81       	ldd	r25, Y+2	; 0x02
    3d62:	01 96       	adiw	r24, 0x01	; 1
    3d64:	89 83       	std	Y+1, r24	; 0x01
    3d66:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3d68:	20 91 40 21 	lds	r18, 0x2140
    3d6c:	89 81       	ldd	r24, Y+1	; 0x01
    3d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d70:	fc 01       	movw	r30, r24
    3d72:	20 83       	st	Z, r18
    3d74:	89 81       	ldd	r24, Y+1	; 0x01
    3d76:	9a 81       	ldd	r25, Y+2	; 0x02
    3d78:	01 96       	adiw	r24, 0x01	; 1
    3d7a:	89 83       	std	Y+1, r24	; 0x01
    3d7c:	9a 83       	std	Y+2, r25	; 0x02
    3d7e:	82 2f       	mov	r24, r18
    3d80:	8f 5f       	subi	r24, 0xFF	; 255
    3d82:	80 93 40 21 	sts	0x2140, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3d86:	89 81       	ldd	r24, Y+1	; 0x01
    3d88:	9a 81       	ldd	r25, Y+2	; 0x02
    3d8a:	24 e3       	ldi	r18, 0x34	; 52
    3d8c:	32 e1       	ldi	r19, 0x12	; 18
    3d8e:	fc 01       	movw	r30, r24
    3d90:	20 83       	st	Z, r18
    3d92:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3d94:	89 81       	ldd	r24, Y+1	; 0x01
    3d96:	9a 81       	ldd	r25, Y+2	; 0x02
    3d98:	02 96       	adiw	r24, 0x02	; 2
    3d9a:	89 83       	std	Y+1, r24	; 0x01
    3d9c:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3d9e:	89 81       	ldd	r24, Y+1	; 0x01
    3da0:	9a 81       	ldd	r25, Y+2	; 0x02
    3da2:	2d 81       	ldd	r18, Y+5	; 0x05
    3da4:	3e 81       	ldd	r19, Y+6	; 0x06
    3da6:	fc 01       	movw	r30, r24
    3da8:	20 83       	st	Z, r18
    3daa:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3dac:	89 81       	ldd	r24, Y+1	; 0x01
    3dae:	9a 81       	ldd	r25, Y+2	; 0x02
    3db0:	02 96       	adiw	r24, 0x02	; 2
    3db2:	89 83       	std	Y+1, r24	; 0x01
    3db4:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3db6:	20 91 3e 21 	lds	r18, 0x213E
    3dba:	30 91 3f 21 	lds	r19, 0x213F
    3dbe:	89 81       	ldd	r24, Y+1	; 0x01
    3dc0:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc2:	fc 01       	movw	r30, r24
    3dc4:	20 83       	st	Z, r18
    3dc6:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3dc8:	89 81       	ldd	r24, Y+1	; 0x01
    3dca:	9a 81       	ldd	r25, Y+2	; 0x02
    3dcc:	02 96       	adiw	r24, 0x02	; 2
    3dce:	89 83       	std	Y+1, r24	; 0x01
    3dd0:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3dd2:	29 81       	ldd	r18, Y+1	; 0x01
    3dd4:	3a 81       	ldd	r19, Y+2	; 0x02
    3dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3dd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3dda:	a9 01       	movw	r20, r18
    3ddc:	48 1b       	sub	r20, r24
    3dde:	59 0b       	sbc	r21, r25
    3de0:	ca 01       	movw	r24, r20
}
    3de2:	27 96       	adiw	r28, 0x07	; 7
    3de4:	cd bf       	out	0x3d, r28	; 61
    3de6:	de bf       	out	0x3e, r29	; 62
    3de8:	df 91       	pop	r29
    3dea:	cf 91       	pop	r28
    3dec:	08 95       	ret

00003dee <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3dee:	ef 92       	push	r14
    3df0:	ff 92       	push	r15
    3df2:	0f 93       	push	r16
    3df4:	1f 93       	push	r17
    3df6:	cf 93       	push	r28
    3df8:	df 93       	push	r29
    3dfa:	cd b7       	in	r28, 0x3d	; 61
    3dfc:	de b7       	in	r29, 0x3e	; 62
    3dfe:	af 97       	sbiw	r28, 0x2f	; 47
    3e00:	cd bf       	out	0x3d, r28	; 61
    3e02:	de bf       	out	0x3e, r29	; 62
    3e04:	88 a7       	lds	r24, 0x78
    3e06:	99 a7       	lds	r25, 0x79
    3e08:	6a a7       	lds	r22, 0x7a
    3e0a:	7b a7       	lds	r23, 0x7b
    3e0c:	2c a7       	lds	r18, 0x7c
    3e0e:	3d a7       	lds	r19, 0x7d
    3e10:	4e a7       	lds	r20, 0x7e
    3e12:	5f a7       	lds	r21, 0x7f
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    3e14:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3e16:	61 c1       	rjmp	.+706    	; 0x40da <chb_write+0x2ec>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3e18:	8c a5       	lds	r24, 0x6c
    3e1a:	9d a5       	lds	r25, 0x6d
    3e1c:	ae a5       	lds	r26, 0x6e
    3e1e:	bf a5       	lds	r27, 0x6f
    3e20:	85 36       	cpi	r24, 0x65	; 101
    3e22:	91 05       	cpc	r25, r1
    3e24:	a1 05       	cpc	r26, r1
    3e26:	b1 05       	cpc	r27, r1
    3e28:	20 f0       	brcs	.+8      	; 0x3e32 <chb_write+0x44>
    3e2a:	84 e6       	ldi	r24, 0x64	; 100
    3e2c:	90 e0       	ldi	r25, 0x00	; 0
    3e2e:	a0 e0       	ldi	r26, 0x00	; 0
    3e30:	b0 e0       	ldi	r27, 0x00	; 0
    3e32:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);
    3e34:	ce 01       	movw	r24, r28
    3e36:	4e 96       	adiw	r24, 0x1e	; 30
    3e38:	28 a5       	lds	r18, 0x68
    3e3a:	39 a5       	lds	r19, 0x69
    3e3c:	b9 01       	movw	r22, r18
    3e3e:	4c 81       	ldd	r20, Y+4	; 0x04
    3e40:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <chb_gen_hdr>

        // send data to chip
		rtry = 0;
    3e44:	1a 82       	std	Y+2, r1	; 0x02
    3e46:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3e48:	89 81       	ldd	r24, Y+1	; 0x01
    3e4a:	88 2f       	mov	r24, r24
    3e4c:	90 e0       	ldi	r25, 0x00	; 0
    3e4e:	2a a5       	lds	r18, 0x6a
    3e50:	3b a5       	lds	r19, 0x6b
    3e52:	28 0f       	add	r18, r24
    3e54:	39 1f       	adc	r19, r25
    3e56:	ce 01       	movw	r24, r28
    3e58:	4e 96       	adiw	r24, 0x1e	; 30
    3e5a:	b9 01       	movw	r22, r18
    3e5c:	4c 81       	ldd	r20, Y+4	; 0x04
    3e5e:	0e 94 0a 2c 	call	0x5814	; 0x5814 <chb_tx>
    3e62:	8d 83       	std	Y+5, r24	; 0x05

             switch (status)
    3e64:	8d 81       	ldd	r24, Y+5	; 0x05
    3e66:	88 2f       	mov	r24, r24
    3e68:	90 e0       	ldi	r25, 0x00	; 0
    3e6a:	83 30       	cpi	r24, 0x03	; 3
    3e6c:	91 05       	cpc	r25, r1
    3e6e:	31 f1       	breq	.+76     	; 0x3ebc <chb_write+0xce>
    3e70:	84 30       	cpi	r24, 0x04	; 4
    3e72:	91 05       	cpc	r25, r1
    3e74:	24 f4       	brge	.+8      	; 0x3e7e <chb_write+0x90>
    3e76:	81 30       	cpi	r24, 0x01	; 1
    3e78:	91 05       	cpc	r25, r1
    3e7a:	39 f0       	breq	.+14     	; 0x3e8a <chb_write+0x9c>
    3e7c:	2e c0       	rjmp	.+92     	; 0x3eda <chb_write+0xec>
    3e7e:	85 30       	cpi	r24, 0x05	; 5
    3e80:	91 05       	cpc	r25, r1
    3e82:	69 f0       	breq	.+26     	; 0x3e9e <chb_write+0xb0>
    3e84:	80 34       	cpi	r24, 0x40	; 64
    3e86:	91 05       	cpc	r25, r1
    3e88:	41 f5       	brne	.+80     	; 0x3eda <chb_write+0xec>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3e8a:	80 91 45 21 	lds	r24, 0x2145
    3e8e:	90 91 46 21 	lds	r25, 0x2146
    3e92:	01 96       	adiw	r24, 0x01	; 1
    3e94:	80 93 45 21 	sts	0x2145, r24
    3e98:	90 93 46 21 	sts	0x2146, r25
                 break;
    3e9c:	1f c0       	rjmp	.+62     	; 0x3edc <chb_write+0xee>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3e9e:	80 91 47 21 	lds	r24, 0x2147
    3ea2:	90 91 48 21 	lds	r25, 0x2148
    3ea6:	01 96       	adiw	r24, 0x01	; 1
    3ea8:	80 93 47 21 	sts	0x2147, r24
    3eac:	90 93 48 21 	sts	0x2148, r25
				 rtry++;
    3eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    3eb2:	9b 81       	ldd	r25, Y+3	; 0x03
    3eb4:	01 96       	adiw	r24, 0x01	; 1
    3eb6:	8a 83       	std	Y+2, r24	; 0x02
    3eb8:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3eba:	10 c0       	rjmp	.+32     	; 0x3edc <chb_write+0xee>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3ebc:	80 91 49 21 	lds	r24, 0x2149
    3ec0:	90 91 4a 21 	lds	r25, 0x214A
    3ec4:	01 96       	adiw	r24, 0x01	; 1
    3ec6:	80 93 49 21 	sts	0x2149, r24
    3eca:	90 93 4a 21 	sts	0x214A, r25
				 rtry++;
    3ece:	8a 81       	ldd	r24, Y+2	; 0x02
    3ed0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ed2:	01 96       	adiw	r24, 0x01	; 1
    3ed4:	8a 83       	std	Y+2, r24	; 0x02
    3ed6:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3ed8:	01 c0       	rjmp	.+2      	; 0x3edc <chb_write+0xee>
 
             default:
                 break;
    3eda:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    3edc:	8a 81       	ldd	r24, Y+2	; 0x02
    3ede:	9b 81       	ldd	r25, Y+3	; 0x03
    3ee0:	18 16       	cp	r1, r24
    3ee2:	19 06       	cpc	r1, r25
    3ee4:	0c f0       	brlt	.+2      	; 0x3ee8 <chb_write+0xfa>
    3ee6:	d5 c0       	rjmp	.+426    	; 0x4092 <chb_write+0x2a4>
    3ee8:	80 e0       	ldi	r24, 0x00	; 0
    3eea:	90 e0       	ldi	r25, 0x00	; 0
    3eec:	a0 e2       	ldi	r26, 0x20	; 32
    3eee:	b1 e4       	ldi	r27, 0x41	; 65
    3ef0:	8e 83       	std	Y+6, r24	; 0x06
    3ef2:	9f 83       	std	Y+7, r25	; 0x07
    3ef4:	a8 87       	std	Y+8, r26	; 0x08
    3ef6:	b9 87       	std	Y+9, r27	; 0x09
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3ef8:	6e 81       	ldd	r22, Y+6	; 0x06
    3efa:	7f 81       	ldd	r23, Y+7	; 0x07
    3efc:	88 85       	ldd	r24, Y+8	; 0x08
    3efe:	99 85       	ldd	r25, Y+9	; 0x09
    3f00:	2b ea       	ldi	r18, 0xAB	; 171
    3f02:	3a ea       	ldi	r19, 0xAA	; 170
    3f04:	4a e2       	ldi	r20, 0x2A	; 42
    3f06:	51 e4       	ldi	r21, 0x41	; 65
    3f08:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    3f0c:	dc 01       	movw	r26, r24
    3f0e:	cb 01       	movw	r24, r22
    3f10:	8a 87       	std	Y+10, r24	; 0x0a
    3f12:	9b 87       	std	Y+11, r25	; 0x0b
    3f14:	ac 87       	std	Y+12, r26	; 0x0c
    3f16:	bd 87       	std	Y+13, r27	; 0x0d
	if (__tmp < 1.0)
    3f18:	11 e0       	ldi	r17, 0x01	; 1
    3f1a:	6a 85       	ldd	r22, Y+10	; 0x0a
    3f1c:	7b 85       	ldd	r23, Y+11	; 0x0b
    3f1e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f20:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f22:	20 e0       	ldi	r18, 0x00	; 0
    3f24:	30 e0       	ldi	r19, 0x00	; 0
    3f26:	40 e8       	ldi	r20, 0x80	; 128
    3f28:	5f e3       	ldi	r21, 0x3F	; 63
    3f2a:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    3f2e:	88 23       	and	r24, r24
    3f30:	0c f0       	brlt	.+2      	; 0x3f34 <chb_write+0x146>
    3f32:	10 e0       	ldi	r17, 0x00	; 0
    3f34:	11 23       	and	r17, r17
    3f36:	19 f0       	breq	.+6      	; 0x3f3e <chb_write+0x150>
		__ticks = 1;
    3f38:	81 e0       	ldi	r24, 0x01	; 1
    3f3a:	8e 87       	std	Y+14, r24	; 0x0e
    3f3c:	a3 c0       	rjmp	.+326    	; 0x4084 <chb_write+0x296>
	else if (__tmp > 255)
    3f3e:	11 e0       	ldi	r17, 0x01	; 1
    3f40:	6a 85       	ldd	r22, Y+10	; 0x0a
    3f42:	7b 85       	ldd	r23, Y+11	; 0x0b
    3f44:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f46:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f48:	20 e0       	ldi	r18, 0x00	; 0
    3f4a:	30 e0       	ldi	r19, 0x00	; 0
    3f4c:	4f e7       	ldi	r20, 0x7F	; 127
    3f4e:	53 e4       	ldi	r21, 0x43	; 67
    3f50:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    3f54:	18 16       	cp	r1, r24
    3f56:	0c f0       	brlt	.+2      	; 0x3f5a <chb_write+0x16c>
    3f58:	10 e0       	ldi	r17, 0x00	; 0
    3f5a:	11 23       	and	r17, r17
    3f5c:	09 f4       	brne	.+2      	; 0x3f60 <chb_write+0x172>
    3f5e:	89 c0       	rjmp	.+274    	; 0x4072 <chb_write+0x284>
	{
		_delay_ms(__us / 1000.0);
    3f60:	6e 81       	ldd	r22, Y+6	; 0x06
    3f62:	7f 81       	ldd	r23, Y+7	; 0x07
    3f64:	88 85       	ldd	r24, Y+8	; 0x08
    3f66:	99 85       	ldd	r25, Y+9	; 0x09
    3f68:	20 e0       	ldi	r18, 0x00	; 0
    3f6a:	30 e0       	ldi	r19, 0x00	; 0
    3f6c:	4a e7       	ldi	r20, 0x7A	; 122
    3f6e:	54 e4       	ldi	r21, 0x44	; 68
    3f70:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    3f74:	dc 01       	movw	r26, r24
    3f76:	cb 01       	movw	r24, r22
    3f78:	8f 87       	std	Y+15, r24	; 0x0f
    3f7a:	98 8b       	std	Y+16, r25	; 0x10
    3f7c:	a9 8b       	std	Y+17, r26	; 0x11
    3f7e:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3f80:	6f 85       	ldd	r22, Y+15	; 0x0f
    3f82:	78 89       	ldd	r23, Y+16	; 0x10
    3f84:	89 89       	ldd	r24, Y+17	; 0x11
    3f86:	9a 89       	ldd	r25, Y+18	; 0x12
    3f88:	20 e0       	ldi	r18, 0x00	; 0
    3f8a:	30 e0       	ldi	r19, 0x00	; 0
    3f8c:	4a ef       	ldi	r20, 0xFA	; 250
    3f8e:	55 e4       	ldi	r21, 0x45	; 69
    3f90:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    3f94:	dc 01       	movw	r26, r24
    3f96:	cb 01       	movw	r24, r22
    3f98:	8b 8b       	std	Y+19, r24	; 0x13
    3f9a:	9c 8b       	std	Y+20, r25	; 0x14
    3f9c:	ad 8b       	std	Y+21, r26	; 0x15
    3f9e:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    3fa0:	11 e0       	ldi	r17, 0x01	; 1
    3fa2:	6b 89       	ldd	r22, Y+19	; 0x13
    3fa4:	7c 89       	ldd	r23, Y+20	; 0x14
    3fa6:	8d 89       	ldd	r24, Y+21	; 0x15
    3fa8:	9e 89       	ldd	r25, Y+22	; 0x16
    3faa:	20 e0       	ldi	r18, 0x00	; 0
    3fac:	30 e0       	ldi	r19, 0x00	; 0
    3fae:	40 e8       	ldi	r20, 0x80	; 128
    3fb0:	5f e3       	ldi	r21, 0x3F	; 63
    3fb2:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    3fb6:	88 23       	and	r24, r24
    3fb8:	0c f0       	brlt	.+2      	; 0x3fbc <chb_write+0x1ce>
    3fba:	10 e0       	ldi	r17, 0x00	; 0
    3fbc:	11 23       	and	r17, r17
    3fbe:	29 f0       	breq	.+10     	; 0x3fca <chb_write+0x1dc>
		__ticks = 1;
    3fc0:	81 e0       	ldi	r24, 0x01	; 1
    3fc2:	90 e0       	ldi	r25, 0x00	; 0
    3fc4:	8f 8b       	std	Y+23, r24	; 0x17
    3fc6:	98 8f       	std	Y+24, r25	; 0x18
    3fc8:	46 c0       	rjmp	.+140    	; 0x4056 <chb_write+0x268>
	else if (__tmp > 65535)
    3fca:	11 e0       	ldi	r17, 0x01	; 1
    3fcc:	6b 89       	ldd	r22, Y+19	; 0x13
    3fce:	7c 89       	ldd	r23, Y+20	; 0x14
    3fd0:	8d 89       	ldd	r24, Y+21	; 0x15
    3fd2:	9e 89       	ldd	r25, Y+22	; 0x16
    3fd4:	20 e0       	ldi	r18, 0x00	; 0
    3fd6:	3f ef       	ldi	r19, 0xFF	; 255
    3fd8:	4f e7       	ldi	r20, 0x7F	; 127
    3fda:	57 e4       	ldi	r21, 0x47	; 71
    3fdc:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    3fe0:	18 16       	cp	r1, r24
    3fe2:	0c f0       	brlt	.+2      	; 0x3fe6 <chb_write+0x1f8>
    3fe4:	10 e0       	ldi	r17, 0x00	; 0
    3fe6:	11 23       	and	r17, r17
    3fe8:	61 f1       	breq	.+88     	; 0x4042 <chb_write+0x254>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3fea:	6f 85       	ldd	r22, Y+15	; 0x0f
    3fec:	78 89       	ldd	r23, Y+16	; 0x10
    3fee:	89 89       	ldd	r24, Y+17	; 0x11
    3ff0:	9a 89       	ldd	r25, Y+18	; 0x12
    3ff2:	20 e0       	ldi	r18, 0x00	; 0
    3ff4:	30 e0       	ldi	r19, 0x00	; 0
    3ff6:	40 e2       	ldi	r20, 0x20	; 32
    3ff8:	51 e4       	ldi	r21, 0x41	; 65
    3ffa:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    3ffe:	dc 01       	movw	r26, r24
    4000:	cb 01       	movw	r24, r22
    4002:	bc 01       	movw	r22, r24
    4004:	cd 01       	movw	r24, r26
    4006:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    400a:	dc 01       	movw	r26, r24
    400c:	cb 01       	movw	r24, r22
    400e:	8f 8b       	std	Y+23, r24	; 0x17
    4010:	98 8f       	std	Y+24, r25	; 0x18
    4012:	12 c0       	rjmp	.+36     	; 0x4038 <chb_write+0x24a>
    4014:	80 e2       	ldi	r24, 0x20	; 32
    4016:	93 e0       	ldi	r25, 0x03	; 3
    4018:	89 8f       	std	Y+25, r24	; 0x19
    401a:	9a 8f       	std	Y+26, r25	; 0x1a
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    401c:	89 8d       	ldd	r24, Y+25	; 0x19
    401e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4020:	8c 01       	movw	r16, r24
    4022:	c8 01       	movw	r24, r16
    4024:	01 97       	sbiw	r24, 0x01	; 1
    4026:	f1 f7       	brne	.-4      	; 0x4024 <chb_write+0x236>
    4028:	8c 01       	movw	r16, r24
    402a:	09 8f       	std	Y+25, r16	; 0x19
    402c:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    402e:	8f 89       	ldd	r24, Y+23	; 0x17
    4030:	98 8d       	ldd	r25, Y+24	; 0x18
    4032:	01 97       	sbiw	r24, 0x01	; 1
    4034:	8f 8b       	std	Y+23, r24	; 0x17
    4036:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4038:	8f 89       	ldd	r24, Y+23	; 0x17
    403a:	98 8d       	ldd	r25, Y+24	; 0x18
    403c:	00 97       	sbiw	r24, 0x00	; 0
    403e:	51 f7       	brne	.-44     	; 0x4014 <chb_write+0x226>
    4040:	28 c0       	rjmp	.+80     	; 0x4092 <chb_write+0x2a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4042:	6b 89       	ldd	r22, Y+19	; 0x13
    4044:	7c 89       	ldd	r23, Y+20	; 0x14
    4046:	8d 89       	ldd	r24, Y+21	; 0x15
    4048:	9e 89       	ldd	r25, Y+22	; 0x16
    404a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    404e:	dc 01       	movw	r26, r24
    4050:	cb 01       	movw	r24, r22
    4052:	8f 8b       	std	Y+23, r24	; 0x17
    4054:	98 8f       	std	Y+24, r25	; 0x18
    4056:	8f 89       	ldd	r24, Y+23	; 0x17
    4058:	98 8d       	ldd	r25, Y+24	; 0x18
    405a:	8b 8f       	std	Y+27, r24	; 0x1b
    405c:	9c 8f       	std	Y+28, r25	; 0x1c
    405e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4060:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4062:	8c 01       	movw	r16, r24
    4064:	c8 01       	movw	r24, r16
    4066:	01 97       	sbiw	r24, 0x01	; 1
    4068:	f1 f7       	brne	.-4      	; 0x4066 <chb_write+0x278>
    406a:	8c 01       	movw	r16, r24
    406c:	0b 8f       	std	Y+27, r16	; 0x1b
    406e:	1c 8f       	std	Y+28, r17	; 0x1c
    4070:	10 c0       	rjmp	.+32     	; 0x4092 <chb_write+0x2a4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4072:	6a 85       	ldd	r22, Y+10	; 0x0a
    4074:	7b 85       	ldd	r23, Y+11	; 0x0b
    4076:	8c 85       	ldd	r24, Y+12	; 0x0c
    4078:	9d 85       	ldd	r25, Y+13	; 0x0d
    407a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    407e:	dc 01       	movw	r26, r24
    4080:	cb 01       	movw	r24, r22
    4082:	8e 87       	std	Y+14, r24	; 0x0e
    4084:	8e 85       	ldd	r24, Y+14	; 0x0e
    4086:	8d 8f       	std	Y+29, r24	; 0x1d
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4088:	8d 8d       	ldd	r24, Y+29	; 0x1d
    408a:	18 2f       	mov	r17, r24
    408c:	1a 95       	dec	r17
    408e:	f1 f7       	brne	.-4      	; 0x408c <chb_write+0x29e>
    4090:	1d 8f       	std	Y+29, r17	; 0x1d
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    4092:	8a 81       	ldd	r24, Y+2	; 0x02
    4094:	9b 81       	ldd	r25, Y+3	; 0x03
    4096:	84 31       	cpi	r24, 0x14	; 20
    4098:	91 05       	cpc	r25, r1
    409a:	11 f4       	brne	.+4      	; 0x40a0 <chb_write+0x2b2>
    409c:	8d 81       	ldd	r24, Y+5	; 0x05
    409e:	27 c0       	rjmp	.+78     	; 0x40ee <chb_write+0x300>
		} while(status != CHB_SUCCESS);			
    40a0:	8d 81       	ldd	r24, Y+5	; 0x05
    40a2:	88 23       	and	r24, r24
    40a4:	09 f0       	breq	.+2      	; 0x40a8 <chb_write+0x2ba>
    40a6:	d0 ce       	rjmp	.-608    	; 0x3e48 <chb_write+0x5a>
        // adjust len and restart
		frm_offset += frm_len;
    40a8:	99 81       	ldd	r25, Y+1	; 0x01
    40aa:	8c 81       	ldd	r24, Y+4	; 0x04
    40ac:	89 0f       	add	r24, r25
    40ae:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    40b0:	8c 81       	ldd	r24, Y+4	; 0x04
    40b2:	88 2f       	mov	r24, r24
    40b4:	90 e0       	ldi	r25, 0x00	; 0
    40b6:	a0 e0       	ldi	r26, 0x00	; 0
    40b8:	b0 e0       	ldi	r27, 0x00	; 0
    40ba:	2c a5       	lds	r18, 0x6c
    40bc:	3d a5       	lds	r19, 0x6d
    40be:	4e a5       	lds	r20, 0x6e
    40c0:	5f a5       	lds	r21, 0x6f
    40c2:	79 01       	movw	r14, r18
    40c4:	8a 01       	movw	r16, r20
    40c6:	e8 1a       	sub	r14, r24
    40c8:	f9 0a       	sbc	r15, r25
    40ca:	0a 0b       	sbc	r16, r26
    40cc:	1b 0b       	sbc	r17, r27
    40ce:	d8 01       	movw	r26, r16
    40d0:	c7 01       	movw	r24, r14
    40d2:	8c a7       	lds	r24, 0x7c
    40d4:	9d a7       	lds	r25, 0x7d
    40d6:	ae a7       	lds	r26, 0x7e
    40d8:	bf a7       	lds	r27, 0x7f
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    40da:	8c a5       	lds	r24, 0x6c
    40dc:	9d a5       	lds	r25, 0x6d
    40de:	ae a5       	lds	r26, 0x6e
    40e0:	bf a5       	lds	r27, 0x6f
    40e2:	00 97       	sbiw	r24, 0x00	; 0
    40e4:	a1 05       	cpc	r26, r1
    40e6:	b1 05       	cpc	r27, r1
    40e8:	09 f0       	breq	.+2      	; 0x40ec <chb_write+0x2fe>
    40ea:	96 ce       	rjmp	.-724    	; 0x3e18 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    40ec:	80 e0       	ldi	r24, 0x00	; 0
}
    40ee:	af 96       	adiw	r28, 0x2f	; 47
    40f0:	cd bf       	out	0x3d, r28	; 61
    40f2:	de bf       	out	0x3e, r29	; 62
    40f4:	df 91       	pop	r29
    40f6:	cf 91       	pop	r28
    40f8:	1f 91       	pop	r17
    40fa:	0f 91       	pop	r16
    40fc:	ff 90       	pop	r15
    40fe:	ef 90       	pop	r14
    4100:	08 95       	ret

00004102 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4102:	cf 93       	push	r28
    4104:	df 93       	push	r29
    4106:	cd b7       	in	r28, 0x3d	; 61
    4108:	de b7       	in	r29, 0x3e	; 62
    410a:	27 97       	sbiw	r28, 0x07	; 7
    410c:	cd bf       	out	0x3d, r28	; 61
    410e:	de bf       	out	0x3e, r29	; 62
    4110:	8e 83       	std	Y+6, r24	; 0x06
    4112:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    4114:	8e 81       	ldd	r24, Y+6	; 0x06
    4116:	9f 81       	ldd	r25, Y+7	; 0x07
    4118:	05 96       	adiw	r24, 0x05	; 5
    411a:	8a 83       	std	Y+2, r24	; 0x02
    411c:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    411e:	0e 94 4e 21 	call	0x429c	; 0x429c <chb_buf_read>
    4122:	8c 83       	std	Y+4, r24	; 0x04
    4124:	8c 81       	ldd	r24, Y+4	; 0x04
    4126:	88 23       	and	r24, r24
    4128:	14 f4       	brge	.+4      	; 0x412e <chb_read+0x2c>
    {
        return 0;
    412a:	80 e0       	ldi	r24, 0x00	; 0
    412c:	80 c0       	rjmp	.+256    	; 0x422e <chb_read+0x12c>
    }
    *data_ptr++ = len;
    412e:	8a 81       	ldd	r24, Y+2	; 0x02
    4130:	9b 81       	ldd	r25, Y+3	; 0x03
    4132:	2c 81       	ldd	r18, Y+4	; 0x04
    4134:	fc 01       	movw	r30, r24
    4136:	20 83       	st	Z, r18
    4138:	8a 81       	ldd	r24, Y+2	; 0x02
    413a:	9b 81       	ldd	r25, Y+3	; 0x03
    413c:	01 96       	adiw	r24, 0x01	; 1
    413e:	8a 83       	std	Y+2, r24	; 0x02
    4140:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4142:	19 82       	std	Y+1, r1	; 0x01
    4144:	0f c0       	rjmp	.+30     	; 0x4164 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    4146:	0e 94 4e 21 	call	0x429c	; 0x429c <chb_buf_read>
    414a:	28 2f       	mov	r18, r24
    414c:	8a 81       	ldd	r24, Y+2	; 0x02
    414e:	9b 81       	ldd	r25, Y+3	; 0x03
    4150:	fc 01       	movw	r30, r24
    4152:	20 83       	st	Z, r18
    4154:	8a 81       	ldd	r24, Y+2	; 0x02
    4156:	9b 81       	ldd	r25, Y+3	; 0x03
    4158:	01 96       	adiw	r24, 0x01	; 1
    415a:	8a 83       	std	Y+2, r24	; 0x02
    415c:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    415e:	89 81       	ldd	r24, Y+1	; 0x01
    4160:	8f 5f       	subi	r24, 0xFF	; 255
    4162:	89 83       	std	Y+1, r24	; 0x01
    4164:	99 81       	ldd	r25, Y+1	; 0x01
    4166:	8c 81       	ldd	r24, Y+4	; 0x04
    4168:	98 17       	cp	r25, r24
    416a:	68 f3       	brcs	.-38     	; 0x4146 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    416c:	8e 81       	ldd	r24, Y+6	; 0x06
    416e:	9f 81       	ldd	r25, Y+7	; 0x07
    4170:	08 96       	adiw	r24, 0x08	; 8
    4172:	8a 83       	std	Y+2, r24	; 0x02
    4174:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4176:	8a 81       	ldd	r24, Y+2	; 0x02
    4178:	9b 81       	ldd	r25, Y+3	; 0x03
    417a:	fc 01       	movw	r30, r24
    417c:	80 81       	ld	r24, Z
    417e:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    4180:	8e 81       	ldd	r24, Y+6	; 0x06
    4182:	9f 81       	ldd	r25, Y+7	; 0x07
    4184:	0b 96       	adiw	r24, 0x0b	; 11
    4186:	8a 83       	std	Y+2, r24	; 0x02
    4188:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    418a:	8a 81       	ldd	r24, Y+2	; 0x02
    418c:	9b 81       	ldd	r25, Y+3	; 0x03
    418e:	fc 01       	movw	r30, r24
    4190:	20 81       	ld	r18, Z
    4192:	31 81       	ldd	r19, Z+1	; 0x01
    4194:	8e 81       	ldd	r24, Y+6	; 0x06
    4196:	9f 81       	ldd	r25, Y+7	; 0x07
    4198:	fc 01       	movw	r30, r24
    419a:	23 83       	std	Z+3, r18	; 0x03
    419c:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    419e:	8a 81       	ldd	r24, Y+2	; 0x02
    41a0:	9b 81       	ldd	r25, Y+3	; 0x03
    41a2:	02 96       	adiw	r24, 0x02	; 2
    41a4:	8a 83       	std	Y+2, r24	; 0x02
    41a6:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    41a8:	8a 81       	ldd	r24, Y+2	; 0x02
    41aa:	9b 81       	ldd	r25, Y+3	; 0x03
    41ac:	fc 01       	movw	r30, r24
    41ae:	20 81       	ld	r18, Z
    41b0:	31 81       	ldd	r19, Z+1	; 0x01
    41b2:	8e 81       	ldd	r24, Y+6	; 0x06
    41b4:	9f 81       	ldd	r25, Y+7	; 0x07
    41b6:	fc 01       	movw	r30, r24
    41b8:	21 83       	std	Z+1, r18	; 0x01
    41ba:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    41bc:	8a 81       	ldd	r24, Y+2	; 0x02
    41be:	9b 81       	ldd	r25, Y+3	; 0x03
    41c0:	02 96       	adiw	r24, 0x02	; 2
    41c2:	8a 83       	std	Y+2, r24	; 0x02
    41c4:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    41c6:	0e 94 72 21 	call	0x42e4	; 0x42e4 <chb_buf_get_len>
    41ca:	88 23       	and	r24, r24
    41cc:	11 f4       	brne	.+4      	; 0x41d2 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    41ce:	10 92 41 21 	sts	0x2141, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    41d2:	80 91 13 20 	lds	r24, 0x2013
    41d6:	9d 81       	ldd	r25, Y+5	; 0x05
    41d8:	98 17       	cp	r25, r24
    41da:	71 f4       	brne	.+28     	; 0x41f8 <chb_read+0xf6>
    41dc:	8e 81       	ldd	r24, Y+6	; 0x06
    41de:	9f 81       	ldd	r25, Y+7	; 0x07
    41e0:	fc 01       	movw	r30, r24
    41e2:	21 81       	ldd	r18, Z+1	; 0x01
    41e4:	32 81       	ldd	r19, Z+2	; 0x02
    41e6:	80 91 14 20 	lds	r24, 0x2014
    41ea:	90 91 15 20 	lds	r25, 0x2015
    41ee:	28 17       	cp	r18, r24
    41f0:	39 07       	cpc	r19, r25
    41f2:	11 f4       	brne	.+4      	; 0x41f8 <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    41f4:	80 e0       	ldi	r24, 0x00	; 0
    41f6:	1b c0       	rjmp	.+54     	; 0x422e <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    41f8:	8d 81       	ldd	r24, Y+5	; 0x05
    41fa:	80 93 13 20 	sts	0x2013, r24
        prev_src_addr = rx->src_addr;
    41fe:	8e 81       	ldd	r24, Y+6	; 0x06
    4200:	9f 81       	ldd	r25, Y+7	; 0x07
    4202:	fc 01       	movw	r30, r24
    4204:	81 81       	ldd	r24, Z+1	; 0x01
    4206:	92 81       	ldd	r25, Z+2	; 0x02
    4208:	80 93 14 20 	sts	0x2014, r24
    420c:	90 93 15 20 	sts	0x2015, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    4210:	8c 81       	ldd	r24, Y+4	; 0x04
    4212:	88 2f       	mov	r24, r24
    4214:	90 e0       	ldi	r25, 0x00	; 0
    4216:	09 97       	sbiw	r24, 0x09	; 9
    4218:	9c 01       	movw	r18, r24
    421a:	8e 81       	ldd	r24, Y+6	; 0x06
    421c:	9f 81       	ldd	r25, Y+7	; 0x07
    421e:	4a 81       	ldd	r20, Y+2	; 0x02
    4220:	5b 81       	ldd	r21, Y+3	; 0x03
    4222:	ba 01       	movw	r22, r20
    4224:	a9 01       	movw	r20, r18
    4226:	0e 94 65 5d 	call	0xbaca	; 0xbaca <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    422a:	8c 81       	ldd	r24, Y+4	; 0x04
    422c:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    422e:	27 96       	adiw	r28, 0x07	; 7
    4230:	cd bf       	out	0x3d, r28	; 61
    4232:	de bf       	out	0x3e, r29	; 62
    4234:	df 91       	pop	r29
    4236:	cf 91       	pop	r28
    4238:	08 95       	ret

0000423a <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    423a:	cf 93       	push	r28
    423c:	df 93       	push	r29
    423e:	cd b7       	in	r28, 0x3d	; 61
    4240:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4242:	10 92 d2 21 	sts	0x21D2, r1
    wr_ptr = 0;
    4246:	10 92 d3 21 	sts	0x21D3, r1
    len = 0;
    424a:	10 92 d4 21 	sts	0x21D4, r1
}
    424e:	df 91       	pop	r29
    4250:	cf 91       	pop	r28
    4252:	08 95       	ret

00004254 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4254:	cf 93       	push	r28
    4256:	df 93       	push	r29
    4258:	0f 92       	push	r0
    425a:	cd b7       	in	r28, 0x3d	; 61
    425c:	de b7       	in	r29, 0x3e	; 62
    425e:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4260:	80 91 d3 21 	lds	r24, 0x21D3
    4264:	88 2f       	mov	r24, r24
    4266:	90 e0       	ldi	r25, 0x00	; 0
    4268:	8e 5a       	subi	r24, 0xAE	; 174
    426a:	9e 4d       	sbci	r25, 0xDE	; 222
    426c:	29 81       	ldd	r18, Y+1	; 0x01
    426e:	fc 01       	movw	r30, r24
    4270:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4272:	80 91 d3 21 	lds	r24, 0x21D3
    4276:	88 2f       	mov	r24, r24
    4278:	90 e0       	ldi	r25, 0x00	; 0
    427a:	01 96       	adiw	r24, 0x01	; 1
    427c:	20 e8       	ldi	r18, 0x80	; 128
    427e:	30 e0       	ldi	r19, 0x00	; 0
    4280:	b9 01       	movw	r22, r18
    4282:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    4286:	80 93 d3 21 	sts	0x21D3, r24
    len++;
    428a:	80 91 d4 21 	lds	r24, 0x21D4
    428e:	8f 5f       	subi	r24, 0xFF	; 255
    4290:	80 93 d4 21 	sts	0x21D4, r24
}
    4294:	0f 90       	pop	r0
    4296:	df 91       	pop	r29
    4298:	cf 91       	pop	r28
    429a:	08 95       	ret

0000429c <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    429c:	cf 93       	push	r28
    429e:	df 93       	push	r29
    42a0:	0f 92       	push	r0
    42a2:	cd b7       	in	r28, 0x3d	; 61
    42a4:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    42a6:	80 91 d2 21 	lds	r24, 0x21D2
    42aa:	88 2f       	mov	r24, r24
    42ac:	90 e0       	ldi	r25, 0x00	; 0
    42ae:	8e 5a       	subi	r24, 0xAE	; 174
    42b0:	9e 4d       	sbci	r25, 0xDE	; 222
    42b2:	fc 01       	movw	r30, r24
    42b4:	80 81       	ld	r24, Z
    42b6:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    42b8:	80 91 d2 21 	lds	r24, 0x21D2
    42bc:	88 2f       	mov	r24, r24
    42be:	90 e0       	ldi	r25, 0x00	; 0
    42c0:	01 96       	adiw	r24, 0x01	; 1
    42c2:	20 e8       	ldi	r18, 0x80	; 128
    42c4:	30 e0       	ldi	r19, 0x00	; 0
    42c6:	b9 01       	movw	r22, r18
    42c8:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    42cc:	80 93 d2 21 	sts	0x21D2, r24
    len--;
    42d0:	80 91 d4 21 	lds	r24, 0x21D4
    42d4:	81 50       	subi	r24, 0x01	; 1
    42d6:	80 93 d4 21 	sts	0x21D4, r24
    return data;
    42da:	89 81       	ldd	r24, Y+1	; 0x01
}
    42dc:	0f 90       	pop	r0
    42de:	df 91       	pop	r29
    42e0:	cf 91       	pop	r28
    42e2:	08 95       	ret

000042e4 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    42e4:	cf 93       	push	r28
    42e6:	df 93       	push	r29
    42e8:	cd b7       	in	r28, 0x3d	; 61
    42ea:	de b7       	in	r29, 0x3e	; 62
    return len;
    42ec:	80 91 d4 21 	lds	r24, 0x21D4
}
    42f0:	df 91       	pop	r29
    42f2:	cf 91       	pop	r28
    42f4:	08 95       	ret

000042f6 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    42f6:	cf 93       	push	r28
    42f8:	df 93       	push	r29
    42fa:	cd b7       	in	r28, 0x3d	; 61
    42fc:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    42fe:	81 e0       	ldi	r24, 0x01	; 1
    4300:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    4304:	8f 71       	andi	r24, 0x1F	; 31
}
    4306:	df 91       	pop	r29
    4308:	cf 91       	pop	r28
    430a:	08 95       	ret

0000430c <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    430c:	cf 93       	push	r28
    430e:	df 93       	push	r29
    4310:	cd b7       	in	r28, 0x3d	; 61
    4312:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    4314:	82 e0       	ldi	r24, 0x02	; 2
    4316:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    431a:	82 95       	swap	r24
    431c:	86 95       	lsr	r24
    431e:	87 70       	andi	r24, 0x07	; 7
}
    4320:	df 91       	pop	r29
    4322:	cf 91       	pop	r28
    4324:	08 95       	ret

00004326 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    4326:	0f 93       	push	r16
    4328:	1f 93       	push	r17
    432a:	cf 93       	push	r28
    432c:	df 93       	push	r29
    432e:	cd b7       	in	r28, 0x3d	; 61
    4330:	de b7       	in	r29, 0x3e	; 62
    4332:	e0 97       	sbiw	r28, 0x30	; 48
    4334:	cd bf       	out	0x3d, r28	; 61
    4336:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    4338:	84 e6       	ldi	r24, 0x64	; 100
    433a:	96 e0       	ldi	r25, 0x06	; 6
    433c:	24 e6       	ldi	r18, 0x64	; 100
    433e:	36 e0       	ldi	r19, 0x06	; 6
    4340:	f9 01       	movw	r30, r18
    4342:	20 81       	ld	r18, Z
    4344:	21 60       	ori	r18, 0x01	; 1
    4346:	fc 01       	movw	r30, r24
    4348:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    434a:	84 e6       	ldi	r24, 0x64	; 100
    434c:	96 e0       	ldi	r25, 0x06	; 6
    434e:	24 e6       	ldi	r18, 0x64	; 100
    4350:	36 e0       	ldi	r19, 0x06	; 6
    4352:	f9 01       	movw	r30, r18
    4354:	20 81       	ld	r18, Z
    4356:	2d 7f       	andi	r18, 0xFD	; 253
    4358:	fc 01       	movw	r30, r24
    435a:	20 83       	st	Z, r18
    435c:	80 e0       	ldi	r24, 0x00	; 0
    435e:	90 e0       	ldi	r25, 0x00	; 0
    4360:	ae eb       	ldi	r26, 0xBE	; 190
    4362:	b3 e4       	ldi	r27, 0x43	; 67
    4364:	89 83       	std	Y+1, r24	; 0x01
    4366:	9a 83       	std	Y+2, r25	; 0x02
    4368:	ab 83       	std	Y+3, r26	; 0x03
    436a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    436c:	69 81       	ldd	r22, Y+1	; 0x01
    436e:	7a 81       	ldd	r23, Y+2	; 0x02
    4370:	8b 81       	ldd	r24, Y+3	; 0x03
    4372:	9c 81       	ldd	r25, Y+4	; 0x04
    4374:	2b ea       	ldi	r18, 0xAB	; 171
    4376:	3a ea       	ldi	r19, 0xAA	; 170
    4378:	4a e2       	ldi	r20, 0x2A	; 42
    437a:	51 e4       	ldi	r21, 0x41	; 65
    437c:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4380:	dc 01       	movw	r26, r24
    4382:	cb 01       	movw	r24, r22
    4384:	8d 83       	std	Y+5, r24	; 0x05
    4386:	9e 83       	std	Y+6, r25	; 0x06
    4388:	af 83       	std	Y+7, r26	; 0x07
    438a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    438c:	11 e0       	ldi	r17, 0x01	; 1
    438e:	6d 81       	ldd	r22, Y+5	; 0x05
    4390:	7e 81       	ldd	r23, Y+6	; 0x06
    4392:	8f 81       	ldd	r24, Y+7	; 0x07
    4394:	98 85       	ldd	r25, Y+8	; 0x08
    4396:	20 e0       	ldi	r18, 0x00	; 0
    4398:	30 e0       	ldi	r19, 0x00	; 0
    439a:	40 e8       	ldi	r20, 0x80	; 128
    439c:	5f e3       	ldi	r21, 0x3F	; 63
    439e:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    43a2:	88 23       	and	r24, r24
    43a4:	0c f0       	brlt	.+2      	; 0x43a8 <chb_reset+0x82>
    43a6:	10 e0       	ldi	r17, 0x00	; 0
    43a8:	11 23       	and	r17, r17
    43aa:	19 f0       	breq	.+6      	; 0x43b2 <chb_reset+0x8c>
		__ticks = 1;
    43ac:	81 e0       	ldi	r24, 0x01	; 1
    43ae:	89 87       	std	Y+9, r24	; 0x09
    43b0:	a3 c0       	rjmp	.+326    	; 0x44f8 <chb_reset+0x1d2>
	else if (__tmp > 255)
    43b2:	11 e0       	ldi	r17, 0x01	; 1
    43b4:	6d 81       	ldd	r22, Y+5	; 0x05
    43b6:	7e 81       	ldd	r23, Y+6	; 0x06
    43b8:	8f 81       	ldd	r24, Y+7	; 0x07
    43ba:	98 85       	ldd	r25, Y+8	; 0x08
    43bc:	20 e0       	ldi	r18, 0x00	; 0
    43be:	30 e0       	ldi	r19, 0x00	; 0
    43c0:	4f e7       	ldi	r20, 0x7F	; 127
    43c2:	53 e4       	ldi	r21, 0x43	; 67
    43c4:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    43c8:	18 16       	cp	r1, r24
    43ca:	0c f0       	brlt	.+2      	; 0x43ce <chb_reset+0xa8>
    43cc:	10 e0       	ldi	r17, 0x00	; 0
    43ce:	11 23       	and	r17, r17
    43d0:	09 f4       	brne	.+2      	; 0x43d4 <chb_reset+0xae>
    43d2:	89 c0       	rjmp	.+274    	; 0x44e6 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    43d4:	69 81       	ldd	r22, Y+1	; 0x01
    43d6:	7a 81       	ldd	r23, Y+2	; 0x02
    43d8:	8b 81       	ldd	r24, Y+3	; 0x03
    43da:	9c 81       	ldd	r25, Y+4	; 0x04
    43dc:	20 e0       	ldi	r18, 0x00	; 0
    43de:	30 e0       	ldi	r19, 0x00	; 0
    43e0:	4a e7       	ldi	r20, 0x7A	; 122
    43e2:	54 e4       	ldi	r21, 0x44	; 68
    43e4:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    43e8:	dc 01       	movw	r26, r24
    43ea:	cb 01       	movw	r24, r22
    43ec:	8a 87       	std	Y+10, r24	; 0x0a
    43ee:	9b 87       	std	Y+11, r25	; 0x0b
    43f0:	ac 87       	std	Y+12, r26	; 0x0c
    43f2:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    43f4:	6a 85       	ldd	r22, Y+10	; 0x0a
    43f6:	7b 85       	ldd	r23, Y+11	; 0x0b
    43f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    43fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    43fc:	20 e0       	ldi	r18, 0x00	; 0
    43fe:	30 e0       	ldi	r19, 0x00	; 0
    4400:	4a ef       	ldi	r20, 0xFA	; 250
    4402:	55 e4       	ldi	r21, 0x45	; 69
    4404:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4408:	dc 01       	movw	r26, r24
    440a:	cb 01       	movw	r24, r22
    440c:	8e 87       	std	Y+14, r24	; 0x0e
    440e:	9f 87       	std	Y+15, r25	; 0x0f
    4410:	a8 8b       	std	Y+16, r26	; 0x10
    4412:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    4414:	11 e0       	ldi	r17, 0x01	; 1
    4416:	6e 85       	ldd	r22, Y+14	; 0x0e
    4418:	7f 85       	ldd	r23, Y+15	; 0x0f
    441a:	88 89       	ldd	r24, Y+16	; 0x10
    441c:	99 89       	ldd	r25, Y+17	; 0x11
    441e:	20 e0       	ldi	r18, 0x00	; 0
    4420:	30 e0       	ldi	r19, 0x00	; 0
    4422:	40 e8       	ldi	r20, 0x80	; 128
    4424:	5f e3       	ldi	r21, 0x3F	; 63
    4426:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    442a:	88 23       	and	r24, r24
    442c:	0c f0       	brlt	.+2      	; 0x4430 <chb_reset+0x10a>
    442e:	10 e0       	ldi	r17, 0x00	; 0
    4430:	11 23       	and	r17, r17
    4432:	29 f0       	breq	.+10     	; 0x443e <chb_reset+0x118>
		__ticks = 1;
    4434:	81 e0       	ldi	r24, 0x01	; 1
    4436:	90 e0       	ldi	r25, 0x00	; 0
    4438:	8a 8b       	std	Y+18, r24	; 0x12
    443a:	9b 8b       	std	Y+19, r25	; 0x13
    443c:	46 c0       	rjmp	.+140    	; 0x44ca <chb_reset+0x1a4>
	else if (__tmp > 65535)
    443e:	11 e0       	ldi	r17, 0x01	; 1
    4440:	6e 85       	ldd	r22, Y+14	; 0x0e
    4442:	7f 85       	ldd	r23, Y+15	; 0x0f
    4444:	88 89       	ldd	r24, Y+16	; 0x10
    4446:	99 89       	ldd	r25, Y+17	; 0x11
    4448:	20 e0       	ldi	r18, 0x00	; 0
    444a:	3f ef       	ldi	r19, 0xFF	; 255
    444c:	4f e7       	ldi	r20, 0x7F	; 127
    444e:	57 e4       	ldi	r21, 0x47	; 71
    4450:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    4454:	18 16       	cp	r1, r24
    4456:	0c f0       	brlt	.+2      	; 0x445a <chb_reset+0x134>
    4458:	10 e0       	ldi	r17, 0x00	; 0
    445a:	11 23       	and	r17, r17
    445c:	61 f1       	breq	.+88     	; 0x44b6 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    445e:	6a 85       	ldd	r22, Y+10	; 0x0a
    4460:	7b 85       	ldd	r23, Y+11	; 0x0b
    4462:	8c 85       	ldd	r24, Y+12	; 0x0c
    4464:	9d 85       	ldd	r25, Y+13	; 0x0d
    4466:	20 e0       	ldi	r18, 0x00	; 0
    4468:	30 e0       	ldi	r19, 0x00	; 0
    446a:	40 e2       	ldi	r20, 0x20	; 32
    446c:	51 e4       	ldi	r21, 0x41	; 65
    446e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4472:	dc 01       	movw	r26, r24
    4474:	cb 01       	movw	r24, r22
    4476:	bc 01       	movw	r22, r24
    4478:	cd 01       	movw	r24, r26
    447a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    447e:	dc 01       	movw	r26, r24
    4480:	cb 01       	movw	r24, r22
    4482:	8a 8b       	std	Y+18, r24	; 0x12
    4484:	9b 8b       	std	Y+19, r25	; 0x13
    4486:	12 c0       	rjmp	.+36     	; 0x44ac <chb_reset+0x186>
    4488:	80 e2       	ldi	r24, 0x20	; 32
    448a:	93 e0       	ldi	r25, 0x03	; 3
    448c:	8c 8b       	std	Y+20, r24	; 0x14
    448e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4490:	8c 89       	ldd	r24, Y+20	; 0x14
    4492:	9d 89       	ldd	r25, Y+21	; 0x15
    4494:	8c 01       	movw	r16, r24
    4496:	c8 01       	movw	r24, r16
    4498:	01 97       	sbiw	r24, 0x01	; 1
    449a:	f1 f7       	brne	.-4      	; 0x4498 <chb_reset+0x172>
    449c:	8c 01       	movw	r16, r24
    449e:	0c 8b       	std	Y+20, r16	; 0x14
    44a0:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    44a2:	8a 89       	ldd	r24, Y+18	; 0x12
    44a4:	9b 89       	ldd	r25, Y+19	; 0x13
    44a6:	01 97       	sbiw	r24, 0x01	; 1
    44a8:	8a 8b       	std	Y+18, r24	; 0x12
    44aa:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    44ac:	8a 89       	ldd	r24, Y+18	; 0x12
    44ae:	9b 89       	ldd	r25, Y+19	; 0x13
    44b0:	00 97       	sbiw	r24, 0x00	; 0
    44b2:	51 f7       	brne	.-44     	; 0x4488 <chb_reset+0x162>
    44b4:	28 c0       	rjmp	.+80     	; 0x4506 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    44b6:	6e 85       	ldd	r22, Y+14	; 0x0e
    44b8:	7f 85       	ldd	r23, Y+15	; 0x0f
    44ba:	88 89       	ldd	r24, Y+16	; 0x10
    44bc:	99 89       	ldd	r25, Y+17	; 0x11
    44be:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    44c2:	dc 01       	movw	r26, r24
    44c4:	cb 01       	movw	r24, r22
    44c6:	8a 8b       	std	Y+18, r24	; 0x12
    44c8:	9b 8b       	std	Y+19, r25	; 0x13
    44ca:	8a 89       	ldd	r24, Y+18	; 0x12
    44cc:	9b 89       	ldd	r25, Y+19	; 0x13
    44ce:	8e 8b       	std	Y+22, r24	; 0x16
    44d0:	9f 8b       	std	Y+23, r25	; 0x17
    44d2:	8e 89       	ldd	r24, Y+22	; 0x16
    44d4:	9f 89       	ldd	r25, Y+23	; 0x17
    44d6:	8c 01       	movw	r16, r24
    44d8:	f8 01       	movw	r30, r16
    44da:	31 97       	sbiw	r30, 0x01	; 1
    44dc:	f1 f7       	brne	.-4      	; 0x44da <chb_reset+0x1b4>
    44de:	8f 01       	movw	r16, r30
    44e0:	0e 8b       	std	Y+22, r16	; 0x16
    44e2:	1f 8b       	std	Y+23, r17	; 0x17
    44e4:	10 c0       	rjmp	.+32     	; 0x4506 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    44e6:	6d 81       	ldd	r22, Y+5	; 0x05
    44e8:	7e 81       	ldd	r23, Y+6	; 0x06
    44ea:	8f 81       	ldd	r24, Y+7	; 0x07
    44ec:	98 85       	ldd	r25, Y+8	; 0x08
    44ee:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    44f2:	dc 01       	movw	r26, r24
    44f4:	cb 01       	movw	r24, r22
    44f6:	89 87       	std	Y+9, r24	; 0x09
    44f8:	89 85       	ldd	r24, Y+9	; 0x09
    44fa:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    44fc:	88 8d       	ldd	r24, Y+24	; 0x18
    44fe:	18 2f       	mov	r17, r24
    4500:	1a 95       	dec	r17
    4502:	f1 f7       	brne	.-4      	; 0x4500 <chb_reset+0x1da>
    4504:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    4506:	84 e6       	ldi	r24, 0x64	; 100
    4508:	96 e0       	ldi	r25, 0x06	; 6
    450a:	24 e6       	ldi	r18, 0x64	; 100
    450c:	36 e0       	ldi	r19, 0x06	; 6
    450e:	f9 01       	movw	r30, r18
    4510:	20 81       	ld	r18, Z
    4512:	2e 7f       	andi	r18, 0xFE	; 254
    4514:	fc 01       	movw	r30, r24
    4516:	20 83       	st	Z, r18
    4518:	80 e0       	ldi	r24, 0x00	; 0
    451a:	90 e0       	ldi	r25, 0x00	; 0
    451c:	a0 e8       	ldi	r26, 0x80	; 128
    451e:	bf e3       	ldi	r27, 0x3F	; 63
    4520:	89 8f       	std	Y+25, r24	; 0x19
    4522:	9a 8f       	std	Y+26, r25	; 0x1a
    4524:	ab 8f       	std	Y+27, r26	; 0x1b
    4526:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4528:	69 8d       	ldd	r22, Y+25	; 0x19
    452a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    452c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    452e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4530:	2b ea       	ldi	r18, 0xAB	; 171
    4532:	3a ea       	ldi	r19, 0xAA	; 170
    4534:	4a e2       	ldi	r20, 0x2A	; 42
    4536:	51 e4       	ldi	r21, 0x41	; 65
    4538:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    453c:	dc 01       	movw	r26, r24
    453e:	cb 01       	movw	r24, r22
    4540:	8d 8f       	std	Y+29, r24	; 0x1d
    4542:	9e 8f       	std	Y+30, r25	; 0x1e
    4544:	af 8f       	std	Y+31, r26	; 0x1f
    4546:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    4548:	11 e0       	ldi	r17, 0x01	; 1
    454a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    454c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    454e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4550:	98 a1       	lds	r25, 0x48
    4552:	20 e0       	ldi	r18, 0x00	; 0
    4554:	30 e0       	ldi	r19, 0x00	; 0
    4556:	40 e8       	ldi	r20, 0x80	; 128
    4558:	5f e3       	ldi	r21, 0x3F	; 63
    455a:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    455e:	88 23       	and	r24, r24
    4560:	0c f0       	brlt	.+2      	; 0x4564 <chb_reset+0x23e>
    4562:	10 e0       	ldi	r17, 0x00	; 0
    4564:	11 23       	and	r17, r17
    4566:	19 f0       	breq	.+6      	; 0x456e <chb_reset+0x248>
		__ticks = 1;
    4568:	81 e0       	ldi	r24, 0x01	; 1
    456a:	89 a3       	lds	r24, 0x59
    456c:	a3 c0       	rjmp	.+326    	; 0x46b4 <chb_reset+0x38e>
	else if (__tmp > 255)
    456e:	11 e0       	ldi	r17, 0x01	; 1
    4570:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4572:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4574:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4576:	98 a1       	lds	r25, 0x48
    4578:	20 e0       	ldi	r18, 0x00	; 0
    457a:	30 e0       	ldi	r19, 0x00	; 0
    457c:	4f e7       	ldi	r20, 0x7F	; 127
    457e:	53 e4       	ldi	r21, 0x43	; 67
    4580:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    4584:	18 16       	cp	r1, r24
    4586:	0c f0       	brlt	.+2      	; 0x458a <chb_reset+0x264>
    4588:	10 e0       	ldi	r17, 0x00	; 0
    458a:	11 23       	and	r17, r17
    458c:	09 f4       	brne	.+2      	; 0x4590 <chb_reset+0x26a>
    458e:	89 c0       	rjmp	.+274    	; 0x46a2 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    4590:	69 8d       	ldd	r22, Y+25	; 0x19
    4592:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4594:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4596:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4598:	20 e0       	ldi	r18, 0x00	; 0
    459a:	30 e0       	ldi	r19, 0x00	; 0
    459c:	4a e7       	ldi	r20, 0x7A	; 122
    459e:	54 e4       	ldi	r21, 0x44	; 68
    45a0:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    45a4:	dc 01       	movw	r26, r24
    45a6:	cb 01       	movw	r24, r22
    45a8:	8a a3       	lds	r24, 0x5a
    45aa:	9b a3       	lds	r25, 0x5b
    45ac:	ac a3       	lds	r26, 0x5c
    45ae:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    45b0:	6a a1       	lds	r22, 0x4a
    45b2:	7b a1       	lds	r23, 0x4b
    45b4:	8c a1       	lds	r24, 0x4c
    45b6:	9d a1       	lds	r25, 0x4d
    45b8:	20 e0       	ldi	r18, 0x00	; 0
    45ba:	30 e0       	ldi	r19, 0x00	; 0
    45bc:	4a ef       	ldi	r20, 0xFA	; 250
    45be:	55 e4       	ldi	r21, 0x45	; 69
    45c0:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    45c4:	dc 01       	movw	r26, r24
    45c6:	cb 01       	movw	r24, r22
    45c8:	8e a3       	lds	r24, 0x5e
    45ca:	9f a3       	lds	r25, 0x5f
    45cc:	a8 a7       	lds	r26, 0x78
    45ce:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    45d0:	11 e0       	ldi	r17, 0x01	; 1
    45d2:	6e a1       	lds	r22, 0x4e
    45d4:	7f a1       	lds	r23, 0x4f
    45d6:	88 a5       	lds	r24, 0x68
    45d8:	99 a5       	lds	r25, 0x69
    45da:	20 e0       	ldi	r18, 0x00	; 0
    45dc:	30 e0       	ldi	r19, 0x00	; 0
    45de:	40 e8       	ldi	r20, 0x80	; 128
    45e0:	5f e3       	ldi	r21, 0x3F	; 63
    45e2:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    45e6:	88 23       	and	r24, r24
    45e8:	0c f0       	brlt	.+2      	; 0x45ec <chb_reset+0x2c6>
    45ea:	10 e0       	ldi	r17, 0x00	; 0
    45ec:	11 23       	and	r17, r17
    45ee:	29 f0       	breq	.+10     	; 0x45fa <chb_reset+0x2d4>
		__ticks = 1;
    45f0:	81 e0       	ldi	r24, 0x01	; 1
    45f2:	90 e0       	ldi	r25, 0x00	; 0
    45f4:	8a a7       	lds	r24, 0x7a
    45f6:	9b a7       	lds	r25, 0x7b
    45f8:	46 c0       	rjmp	.+140    	; 0x4686 <chb_reset+0x360>
	else if (__tmp > 65535)
    45fa:	11 e0       	ldi	r17, 0x01	; 1
    45fc:	6e a1       	lds	r22, 0x4e
    45fe:	7f a1       	lds	r23, 0x4f
    4600:	88 a5       	lds	r24, 0x68
    4602:	99 a5       	lds	r25, 0x69
    4604:	20 e0       	ldi	r18, 0x00	; 0
    4606:	3f ef       	ldi	r19, 0xFF	; 255
    4608:	4f e7       	ldi	r20, 0x7F	; 127
    460a:	57 e4       	ldi	r21, 0x47	; 71
    460c:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    4610:	18 16       	cp	r1, r24
    4612:	0c f0       	brlt	.+2      	; 0x4616 <chb_reset+0x2f0>
    4614:	10 e0       	ldi	r17, 0x00	; 0
    4616:	11 23       	and	r17, r17
    4618:	61 f1       	breq	.+88     	; 0x4672 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    461a:	6a a1       	lds	r22, 0x4a
    461c:	7b a1       	lds	r23, 0x4b
    461e:	8c a1       	lds	r24, 0x4c
    4620:	9d a1       	lds	r25, 0x4d
    4622:	20 e0       	ldi	r18, 0x00	; 0
    4624:	30 e0       	ldi	r19, 0x00	; 0
    4626:	40 e2       	ldi	r20, 0x20	; 32
    4628:	51 e4       	ldi	r21, 0x41	; 65
    462a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    462e:	dc 01       	movw	r26, r24
    4630:	cb 01       	movw	r24, r22
    4632:	bc 01       	movw	r22, r24
    4634:	cd 01       	movw	r24, r26
    4636:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    463a:	dc 01       	movw	r26, r24
    463c:	cb 01       	movw	r24, r22
    463e:	8a a7       	lds	r24, 0x7a
    4640:	9b a7       	lds	r25, 0x7b
    4642:	12 c0       	rjmp	.+36     	; 0x4668 <chb_reset+0x342>
    4644:	80 e2       	ldi	r24, 0x20	; 32
    4646:	93 e0       	ldi	r25, 0x03	; 3
    4648:	8c a7       	lds	r24, 0x7c
    464a:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    464c:	8c a5       	lds	r24, 0x6c
    464e:	9d a5       	lds	r25, 0x6d
    4650:	8c 01       	movw	r16, r24
    4652:	c8 01       	movw	r24, r16
    4654:	01 97       	sbiw	r24, 0x01	; 1
    4656:	f1 f7       	brne	.-4      	; 0x4654 <chb_reset+0x32e>
    4658:	8c 01       	movw	r16, r24
    465a:	0c a7       	lds	r16, 0x7c
    465c:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    465e:	8a a5       	lds	r24, 0x6a
    4660:	9b a5       	lds	r25, 0x6b
    4662:	01 97       	sbiw	r24, 0x01	; 1
    4664:	8a a7       	lds	r24, 0x7a
    4666:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4668:	8a a5       	lds	r24, 0x6a
    466a:	9b a5       	lds	r25, 0x6b
    466c:	00 97       	sbiw	r24, 0x00	; 0
    466e:	51 f7       	brne	.-44     	; 0x4644 <chb_reset+0x31e>
    4670:	28 c0       	rjmp	.+80     	; 0x46c2 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4672:	6e a1       	lds	r22, 0x4e
    4674:	7f a1       	lds	r23, 0x4f
    4676:	88 a5       	lds	r24, 0x68
    4678:	99 a5       	lds	r25, 0x69
    467a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    467e:	dc 01       	movw	r26, r24
    4680:	cb 01       	movw	r24, r22
    4682:	8a a7       	lds	r24, 0x7a
    4684:	9b a7       	lds	r25, 0x7b
    4686:	8a a5       	lds	r24, 0x6a
    4688:	9b a5       	lds	r25, 0x6b
    468a:	8e a7       	lds	r24, 0x7e
    468c:	9f a7       	lds	r25, 0x7f
    468e:	8e a5       	lds	r24, 0x6e
    4690:	9f a5       	lds	r25, 0x6f
    4692:	8c 01       	movw	r16, r24
    4694:	f8 01       	movw	r30, r16
    4696:	31 97       	sbiw	r30, 0x01	; 1
    4698:	f1 f7       	brne	.-4      	; 0x4696 <chb_reset+0x370>
    469a:	8f 01       	movw	r16, r30
    469c:	0e a7       	lds	r16, 0x7e
    469e:	1f a7       	lds	r17, 0x7f
    46a0:	10 c0       	rjmp	.+32     	; 0x46c2 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    46a2:	6d 8d       	ldd	r22, Y+29	; 0x1d
    46a4:	7e 8d       	ldd	r23, Y+30	; 0x1e
    46a6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    46a8:	98 a1       	lds	r25, 0x48
    46aa:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    46ae:	dc 01       	movw	r26, r24
    46b0:	cb 01       	movw	r24, r22
    46b2:	89 a3       	lds	r24, 0x59
    46b4:	89 a1       	lds	r24, 0x49
    46b6:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    46b8:	88 a9       	sts	0x48, r24
    46ba:	18 2f       	mov	r17, r24
    46bc:	1a 95       	dec	r17
    46be:	f1 f7       	brne	.-4      	; 0x46bc <chb_reset+0x396>
    46c0:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    46c2:	84 e6       	ldi	r24, 0x64	; 100
    46c4:	96 e0       	ldi	r25, 0x06	; 6
    46c6:	24 e6       	ldi	r18, 0x64	; 100
    46c8:	36 e0       	ldi	r19, 0x06	; 6
    46ca:	f9 01       	movw	r30, r18
    46cc:	20 81       	ld	r18, Z
    46ce:	21 60       	ori	r18, 0x01	; 1
    46d0:	fc 01       	movw	r30, r24
    46d2:	20 83       	st	Z, r18
    46d4:	01 c0       	rjmp	.+2      	; 0x46d8 <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    46d6:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    46d8:	8d e1       	ldi	r24, 0x1D	; 29
    46da:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    46de:	81 30       	cpi	r24, 0x01	; 1
    46e0:	d1 f7       	brne	.-12     	; 0x46d6 <chb_reset+0x3b0>
    46e2:	8c e1       	ldi	r24, 0x1C	; 28
    46e4:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    46e8:	87 30       	cpi	r24, 0x07	; 7
    46ea:	a9 f7       	brne	.-22     	; 0x46d6 <chb_reset+0x3b0>
        {
            break;
    46ec:	00 00       	nop
        }
    }
	

}
    46ee:	e0 96       	adiw	r28, 0x30	; 48
    46f0:	cd bf       	out	0x3d, r28	; 61
    46f2:	de bf       	out	0x3e, r29	; 62
    46f4:	df 91       	pop	r29
    46f6:	cf 91       	pop	r28
    46f8:	1f 91       	pop	r17
    46fa:	0f 91       	pop	r16
    46fc:	08 95       	ret

000046fe <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    46fe:	cf 93       	push	r28
    4700:	df 93       	push	r29
    4702:	0f 92       	push	r0
    4704:	0f 92       	push	r0
    4706:	cd b7       	in	r28, 0x3d	; 61
    4708:	de b7       	in	r29, 0x3e	; 62
    470a:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    470c:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    470e:	8a 81       	ldd	r24, Y+2	; 0x02
    4710:	80 68       	ori	r24, 0x80	; 128
    4712:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4714:	8f e3       	ldi	r24, 0x3F	; 63
    4716:	90 e0       	ldi	r25, 0x00	; 0
    4718:	fc 01       	movw	r30, r24
    471a:	80 81       	ld	r24, Z
    471c:	80 93 55 40 	sts	0x4055, r24
    4720:	f8 94       	cli
    RadioCS(TRUE);
    4722:	81 e0       	ldi	r24, 0x01	; 1
    4724:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4728:	8a 81       	ldd	r24, Y+2	; 0x02
    472a:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    472e:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4730:	89 81       	ldd	r24, Y+1	; 0x01
    4732:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    4736:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4738:	80 e0       	ldi	r24, 0x00	; 0
    473a:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>
    CHB_LEAVE_CRIT();
    473e:	8f e3       	ldi	r24, 0x3F	; 63
    4740:	90 e0       	ldi	r25, 0x00	; 0
    4742:	20 91 55 40 	lds	r18, 0x4055
    4746:	fc 01       	movw	r30, r24
    4748:	20 83       	st	Z, r18
    474a:	78 94       	sei

    return val;
    474c:	89 81       	ldd	r24, Y+1	; 0x01
}
    474e:	0f 90       	pop	r0
    4750:	0f 90       	pop	r0
    4752:	df 91       	pop	r29
    4754:	cf 91       	pop	r28
    4756:	08 95       	ret

00004758 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4758:	cf 93       	push	r28
    475a:	df 93       	push	r29
    475c:	00 d0       	rcall	.+0      	; 0x475e <chb_reg_read16+0x6>
    475e:	0f 92       	push	r0
    4760:	cd b7       	in	r28, 0x3d	; 61
    4762:	de b7       	in	r29, 0x3e	; 62
    4764:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4766:	1a 82       	std	Y+2, r1	; 0x02
    4768:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    476a:	19 82       	std	Y+1, r1	; 0x01
    476c:	1d c0       	rjmp	.+58     	; 0x47a8 <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    476e:	9c 81       	ldd	r25, Y+4	; 0x04
    4770:	89 81       	ldd	r24, Y+1	; 0x01
    4772:	89 0f       	add	r24, r25
    4774:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    4778:	88 2f       	mov	r24, r24
    477a:	90 e0       	ldi	r25, 0x00	; 0
    477c:	29 81       	ldd	r18, Y+1	; 0x01
    477e:	22 2f       	mov	r18, r18
    4780:	30 e0       	ldi	r19, 0x00	; 0
    4782:	22 0f       	add	r18, r18
    4784:	33 1f       	adc	r19, r19
    4786:	22 0f       	add	r18, r18
    4788:	33 1f       	adc	r19, r19
    478a:	22 0f       	add	r18, r18
    478c:	33 1f       	adc	r19, r19
    478e:	02 2e       	mov	r0, r18
    4790:	02 c0       	rjmp	.+4      	; 0x4796 <chb_reg_read16+0x3e>
    4792:	88 0f       	add	r24, r24
    4794:	99 1f       	adc	r25, r25
    4796:	0a 94       	dec	r0
    4798:	e2 f7       	brpl	.-8      	; 0x4792 <chb_reg_read16+0x3a>
    479a:	98 2f       	mov	r25, r24
    479c:	8c 81       	ldd	r24, Y+4	; 0x04
    479e:	89 2b       	or	r24, r25
    47a0:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    47a2:	89 81       	ldd	r24, Y+1	; 0x01
    47a4:	8f 5f       	subi	r24, 0xFF	; 255
    47a6:	89 83       	std	Y+1, r24	; 0x01
    47a8:	89 81       	ldd	r24, Y+1	; 0x01
    47aa:	82 30       	cpi	r24, 0x02	; 2
    47ac:	00 f3       	brcs	.-64     	; 0x476e <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    47ae:	8a 81       	ldd	r24, Y+2	; 0x02
    47b0:	9b 81       	ldd	r25, Y+3	; 0x03
}
    47b2:	24 96       	adiw	r28, 0x04	; 4
    47b4:	cd bf       	out	0x3d, r28	; 61
    47b6:	de bf       	out	0x3e, r29	; 62
    47b8:	df 91       	pop	r29
    47ba:	cf 91       	pop	r28
    47bc:	08 95       	ret

000047be <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    47be:	cf 93       	push	r28
    47c0:	df 93       	push	r29
    47c2:	0f 92       	push	r0
    47c4:	0f 92       	push	r0
    47c6:	cd b7       	in	r28, 0x3d	; 61
    47c8:	de b7       	in	r29, 0x3e	; 62
    47ca:	89 83       	std	Y+1, r24	; 0x01
    47cc:	6a 83       	std	Y+2, r22	; 0x02
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    47ce:	89 81       	ldd	r24, Y+1	; 0x01
    47d0:	80 6c       	ori	r24, 0xC0	; 192
    47d2:	89 83       	std	Y+1, r24	; 0x01

    CHB_ENTER_CRIT();
    47d4:	8f e3       	ldi	r24, 0x3F	; 63
    47d6:	90 e0       	ldi	r25, 0x00	; 0
    47d8:	fc 01       	movw	r30, r24
    47da:	80 81       	ld	r24, Z
    47dc:	80 93 55 40 	sts	0x4055, r24
    47e0:	f8 94       	cli
    RadioCS(TRUE);
    47e2:	81 e0       	ldi	r24, 0x01	; 1
    47e4:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    47e8:	89 81       	ldd	r24, Y+1	; 0x01
    47ea:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    47ee:	8a 81       	ldd	r24, Y+2	; 0x02
    47f0:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>

    RadioCS(FALSE);
    47f4:	80 e0       	ldi	r24, 0x00	; 0
    47f6:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>
    CHB_LEAVE_CRIT();
    47fa:	8f e3       	ldi	r24, 0x3F	; 63
    47fc:	90 e0       	ldi	r25, 0x00	; 0
    47fe:	20 91 55 40 	lds	r18, 0x4055
    4802:	fc 01       	movw	r30, r24
    4804:	20 83       	st	Z, r18
    4806:	78 94       	sei
}
    4808:	0f 90       	pop	r0
    480a:	0f 90       	pop	r0
    480c:	df 91       	pop	r29
    480e:	cf 91       	pop	r28
    4810:	08 95       	ret

00004812 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4812:	cf 93       	push	r28
    4814:	df 93       	push	r29
    4816:	00 d0       	rcall	.+0      	; 0x4818 <chb_reg_write16+0x6>
    4818:	0f 92       	push	r0
    481a:	cd b7       	in	r28, 0x3d	; 61
    481c:	de b7       	in	r29, 0x3e	; 62
    481e:	8a 83       	std	Y+2, r24	; 0x02
    4820:	6b 83       	std	Y+3, r22	; 0x03
    4822:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4824:	19 82       	std	Y+1, r1	; 0x01
    4826:	1d c0       	rjmp	.+58     	; 0x4862 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4828:	9a 81       	ldd	r25, Y+2	; 0x02
    482a:	89 81       	ldd	r24, Y+1	; 0x01
    482c:	49 2f       	mov	r20, r25
    482e:	48 0f       	add	r20, r24
    4830:	89 81       	ldd	r24, Y+1	; 0x01
    4832:	88 2f       	mov	r24, r24
    4834:	90 e0       	ldi	r25, 0x00	; 0
    4836:	9c 01       	movw	r18, r24
    4838:	22 0f       	add	r18, r18
    483a:	33 1f       	adc	r19, r19
    483c:	22 0f       	add	r18, r18
    483e:	33 1f       	adc	r19, r19
    4840:	22 0f       	add	r18, r18
    4842:	33 1f       	adc	r19, r19
    4844:	8b 81       	ldd	r24, Y+3	; 0x03
    4846:	9c 81       	ldd	r25, Y+4	; 0x04
    4848:	02 c0       	rjmp	.+4      	; 0x484e <chb_reg_write16+0x3c>
    484a:	96 95       	lsr	r25
    484c:	87 95       	ror	r24
    484e:	2a 95       	dec	r18
    4850:	e2 f7       	brpl	.-8      	; 0x484a <chb_reg_write16+0x38>
    4852:	98 2f       	mov	r25, r24
    4854:	84 2f       	mov	r24, r20
    4856:	69 2f       	mov	r22, r25
    4858:	0e 94 df 23 	call	0x47be	; 0x47be <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    485c:	89 81       	ldd	r24, Y+1	; 0x01
    485e:	8f 5f       	subi	r24, 0xFF	; 255
    4860:	89 83       	std	Y+1, r24	; 0x01
    4862:	89 81       	ldd	r24, Y+1	; 0x01
    4864:	82 30       	cpi	r24, 0x02	; 2
    4866:	00 f3       	brcs	.-64     	; 0x4828 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4868:	24 96       	adiw	r28, 0x04	; 4
    486a:	cd bf       	out	0x3d, r28	; 61
    486c:	de bf       	out	0x3e, r29	; 62
    486e:	df 91       	pop	r29
    4870:	cf 91       	pop	r28
    4872:	08 95       	ret

00004874 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4874:	cf 93       	push	r28
    4876:	df 93       	push	r29
    4878:	00 d0       	rcall	.+0      	; 0x487a <chb_reg_write64+0x6>
    487a:	0f 92       	push	r0
    487c:	cd b7       	in	r28, 0x3d	; 61
    487e:	de b7       	in	r29, 0x3e	; 62
    4880:	8a 83       	std	Y+2, r24	; 0x02
    4882:	6b 83       	std	Y+3, r22	; 0x03
    4884:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4886:	19 82       	std	Y+1, r1	; 0x01
    4888:	14 c0       	rjmp	.+40     	; 0x48b2 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    488a:	9a 81       	ldd	r25, Y+2	; 0x02
    488c:	89 81       	ldd	r24, Y+1	; 0x01
    488e:	49 2f       	mov	r20, r25
    4890:	48 0f       	add	r20, r24
    4892:	89 81       	ldd	r24, Y+1	; 0x01
    4894:	88 2f       	mov	r24, r24
    4896:	90 e0       	ldi	r25, 0x00	; 0
    4898:	2b 81       	ldd	r18, Y+3	; 0x03
    489a:	3c 81       	ldd	r19, Y+4	; 0x04
    489c:	82 0f       	add	r24, r18
    489e:	93 1f       	adc	r25, r19
    48a0:	fc 01       	movw	r30, r24
    48a2:	90 81       	ld	r25, Z
    48a4:	84 2f       	mov	r24, r20
    48a6:	69 2f       	mov	r22, r25
    48a8:	0e 94 df 23 	call	0x47be	; 0x47be <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    48ac:	89 81       	ldd	r24, Y+1	; 0x01
    48ae:	8f 5f       	subi	r24, 0xFF	; 255
    48b0:	89 83       	std	Y+1, r24	; 0x01
    48b2:	89 81       	ldd	r24, Y+1	; 0x01
    48b4:	88 30       	cpi	r24, 0x08	; 8
    48b6:	48 f3       	brcs	.-46     	; 0x488a <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    48b8:	24 96       	adiw	r28, 0x04	; 4
    48ba:	cd bf       	out	0x3d, r28	; 61
    48bc:	de bf       	out	0x3e, r29	; 62
    48be:	df 91       	pop	r29
    48c0:	cf 91       	pop	r28
    48c2:	08 95       	ret

000048c4 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    48c4:	cf 93       	push	r28
    48c6:	df 93       	push	r29
    48c8:	00 d0       	rcall	.+0      	; 0x48ca <chb_reg_read_mod_write+0x6>
    48ca:	0f 92       	push	r0
    48cc:	cd b7       	in	r28, 0x3d	; 61
    48ce:	de b7       	in	r29, 0x3e	; 62
    48d0:	8a 83       	std	Y+2, r24	; 0x02
    48d2:	6b 83       	std	Y+3, r22	; 0x03
    48d4:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    48d6:	8a 81       	ldd	r24, Y+2	; 0x02
    48d8:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    48dc:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    48de:	9b 81       	ldd	r25, Y+3	; 0x03
    48e0:	8c 81       	ldd	r24, Y+4	; 0x04
    48e2:	89 23       	and	r24, r25
    48e4:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    48e6:	8c 81       	ldd	r24, Y+4	; 0x04
    48e8:	98 2f       	mov	r25, r24
    48ea:	90 95       	com	r25
    48ec:	89 81       	ldd	r24, Y+1	; 0x01
    48ee:	89 23       	and	r24, r25
    48f0:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    48f2:	99 81       	ldd	r25, Y+1	; 0x01
    48f4:	8b 81       	ldd	r24, Y+3	; 0x03
    48f6:	89 2b       	or	r24, r25
    48f8:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    48fa:	8a 81       	ldd	r24, Y+2	; 0x02
    48fc:	69 81       	ldd	r22, Y+1	; 0x01
    48fe:	0e 94 df 23 	call	0x47be	; 0x47be <chb_reg_write>
}
    4902:	24 96       	adiw	r28, 0x04	; 4
    4904:	cd bf       	out	0x3d, r28	; 61
    4906:	de bf       	out	0x3e, r29	; 62
    4908:	df 91       	pop	r29
    490a:	cf 91       	pop	r28
    490c:	08 95       	ret

0000490e <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    490e:	cf 93       	push	r28
    4910:	df 93       	push	r29
    4912:	cd b7       	in	r28, 0x3d	; 61
    4914:	de b7       	in	r29, 0x3e	; 62
    4916:	27 97       	sbiw	r28, 0x07	; 7
    4918:	cd bf       	out	0x3d, r28	; 61
    491a:	de bf       	out	0x3e, r29	; 62
    491c:	8a 83       	std	Y+2, r24	; 0x02
    491e:	9b 83       	std	Y+3, r25	; 0x03
    4920:	6c 83       	std	Y+4, r22	; 0x04
    4922:	4d 83       	std	Y+5, r20	; 0x05
    4924:	5e 83       	std	Y+6, r21	; 0x06
    4926:	2f 83       	std	Y+7, r18	; 0x07
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4928:	8c 81       	ldd	r24, Y+4	; 0x04
    492a:	28 2f       	mov	r18, r24
    492c:	30 e0       	ldi	r19, 0x00	; 0
    492e:	8f 81       	ldd	r24, Y+7	; 0x07
    4930:	88 2f       	mov	r24, r24
    4932:	90 e0       	ldi	r25, 0x00	; 0
    4934:	82 0f       	add	r24, r18
    4936:	93 1f       	adc	r25, r19
    4938:	80 38       	cpi	r24, 0x80	; 128
    493a:	91 05       	cpc	r25, r1
    493c:	0c f0       	brlt	.+2      	; 0x4940 <chb_frame_write+0x32>
    493e:	42 c0       	rjmp	.+132    	; 0x49c4 <chb_frame_write+0xb6>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4940:	8f e3       	ldi	r24, 0x3F	; 63
    4942:	90 e0       	ldi	r25, 0x00	; 0
    4944:	fc 01       	movw	r30, r24
    4946:	80 81       	ld	r24, Z
    4948:	80 93 55 40 	sts	0x4055, r24
    494c:	f8 94       	cli
    RadioCS(TRUE); 
    494e:	81 e0       	ldi	r24, 0x01	; 1
    4950:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    4954:	80 e6       	ldi	r24, 0x60	; 96
    4956:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    495a:	19 82       	std	Y+1, r1	; 0x01
    495c:	0f c0       	rjmp	.+30     	; 0x497c <chb_frame_write+0x6e>
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    495e:	8a 81       	ldd	r24, Y+2	; 0x02
    4960:	9b 81       	ldd	r25, Y+3	; 0x03
    4962:	fc 01       	movw	r30, r24
    4964:	20 81       	ld	r18, Z
    4966:	8a 81       	ldd	r24, Y+2	; 0x02
    4968:	9b 81       	ldd	r25, Y+3	; 0x03
    496a:	01 96       	adiw	r24, 0x01	; 1
    496c:	8a 83       	std	Y+2, r24	; 0x02
    496e:	9b 83       	std	Y+3, r25	; 0x03
    4970:	82 2f       	mov	r24, r18
    4972:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4976:	89 81       	ldd	r24, Y+1	; 0x01
    4978:	8f 5f       	subi	r24, 0xFF	; 255
    497a:	89 83       	std	Y+1, r24	; 0x01
    497c:	99 81       	ldd	r25, Y+1	; 0x01
    497e:	8c 81       	ldd	r24, Y+4	; 0x04
    4980:	98 17       	cp	r25, r24
    4982:	68 f3       	brcs	.-38     	; 0x495e <chb_frame_write+0x50>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4984:	19 82       	std	Y+1, r1	; 0x01
    4986:	0f c0       	rjmp	.+30     	; 0x49a6 <chb_frame_write+0x98>
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    4988:	8d 81       	ldd	r24, Y+5	; 0x05
    498a:	9e 81       	ldd	r25, Y+6	; 0x06
    498c:	fc 01       	movw	r30, r24
    498e:	20 81       	ld	r18, Z
    4990:	8d 81       	ldd	r24, Y+5	; 0x05
    4992:	9e 81       	ldd	r25, Y+6	; 0x06
    4994:	01 96       	adiw	r24, 0x01	; 1
    4996:	8d 83       	std	Y+5, r24	; 0x05
    4998:	9e 83       	std	Y+6, r25	; 0x06
    499a:	82 2f       	mov	r24, r18
    499c:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    49a0:	89 81       	ldd	r24, Y+1	; 0x01
    49a2:	8f 5f       	subi	r24, 0xFF	; 255
    49a4:	89 83       	std	Y+1, r24	; 0x01
    49a6:	99 81       	ldd	r25, Y+1	; 0x01
    49a8:	8f 81       	ldd	r24, Y+7	; 0x07
    49aa:	98 17       	cp	r25, r24
    49ac:	68 f3       	brcs	.-38     	; 0x4988 <chb_frame_write+0x7a>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    49ae:	80 e0       	ldi	r24, 0x00	; 0
    49b0:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>
    CHB_LEAVE_CRIT();
    49b4:	8f e3       	ldi	r24, 0x3F	; 63
    49b6:	90 e0       	ldi	r25, 0x00	; 0
    49b8:	20 91 55 40 	lds	r18, 0x4055
    49bc:	fc 01       	movw	r30, r24
    49be:	20 83       	st	Z, r18
    49c0:	78 94       	sei
    49c2:	01 c0       	rjmp	.+2      	; 0x49c6 <chb_frame_write+0xb8>
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    49c4:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    49c6:	27 96       	adiw	r28, 0x07	; 7
    49c8:	cd bf       	out	0x3d, r28	; 61
    49ca:	de bf       	out	0x3e, r29	; 62
    49cc:	df 91       	pop	r29
    49ce:	cf 91       	pop	r28
    49d0:	08 95       	ret

000049d2 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    49d2:	0f 93       	push	r16
    49d4:	1f 93       	push	r17
    49d6:	cf 93       	push	r28
    49d8:	df 93       	push	r29
    49da:	cd b7       	in	r28, 0x3d	; 61
    49dc:	de b7       	in	r29, 0x3e	; 62
    49de:	e7 97       	sbiw	r28, 0x37	; 55
    49e0:	cd bf       	out	0x3d, r28	; 61
    49e2:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    49e4:	8f e3       	ldi	r24, 0x3F	; 63
    49e6:	90 e0       	ldi	r25, 0x00	; 0
    49e8:	fc 01       	movw	r30, r24
    49ea:	80 81       	ld	r24, Z
    49ec:	80 93 55 40 	sts	0x4055, r24
    49f0:	f8 94       	cli
    RadioCS(TRUE);
    49f2:	81 e0       	ldi	r24, 0x01	; 1
    49f4:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    49f8:	80 e2       	ldi	r24, 0x20	; 32
    49fa:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    len = SPID_write(0);
    49fe:	80 e0       	ldi	r24, 0x00	; 0
    4a00:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    4a04:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4a06:	8a 81       	ldd	r24, Y+2	; 0x02
    4a08:	83 30       	cpi	r24, 0x03	; 3
    4a0a:	08 f4       	brcc	.+2      	; 0x4a0e <chb_frame_read+0x3c>
    4a0c:	66 c0       	rjmp	.+204    	; 0x4ada <chb_frame_read+0x108>
    4a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a10:	88 23       	and	r24, r24
    4a12:	0c f4       	brge	.+2      	; 0x4a16 <chb_frame_read+0x44>
    4a14:	62 c0       	rjmp	.+196    	; 0x4ada <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4a16:	8a 81       	ldd	r24, Y+2	; 0x02
    4a18:	08 2f       	mov	r16, r24
    4a1a:	10 e0       	ldi	r17, 0x00	; 0
    4a1c:	0e 94 72 21 	call	0x42e4	; 0x42e4 <chb_buf_get_len>
    4a20:	88 2f       	mov	r24, r24
    4a22:	90 e0       	ldi	r25, 0x00	; 0
    4a24:	20 e8       	ldi	r18, 0x80	; 128
    4a26:	30 e0       	ldi	r19, 0x00	; 0
    4a28:	a9 01       	movw	r20, r18
    4a2a:	48 1b       	sub	r20, r24
    4a2c:	59 0b       	sbc	r21, r25
    4a2e:	ca 01       	movw	r24, r20
    4a30:	08 17       	cp	r16, r24
    4a32:	19 07       	cpc	r17, r25
    4a34:	f4 f4       	brge	.+60     	; 0x4a72 <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4a36:	8a 81       	ldd	r24, Y+2	; 0x02
    4a38:	0e 94 2a 21 	call	0x4254	; 0x4254 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4a3c:	19 82       	std	Y+1, r1	; 0x01
    4a3e:	0a c0       	rjmp	.+20     	; 0x4a54 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4a40:	80 e0       	ldi	r24, 0x00	; 0
    4a42:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    4a46:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4a48:	8b 81       	ldd	r24, Y+3	; 0x03
    4a4a:	0e 94 2a 21 	call	0x4254	; 0x4254 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4a4e:	89 81       	ldd	r24, Y+1	; 0x01
    4a50:	8f 5f       	subi	r24, 0xFF	; 255
    4a52:	89 83       	std	Y+1, r24	; 0x01
    4a54:	99 81       	ldd	r25, Y+1	; 0x01
    4a56:	8a 81       	ldd	r24, Y+2	; 0x02
    4a58:	98 17       	cp	r25, r24
    4a5a:	90 f3       	brcs	.-28     	; 0x4a40 <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4a5c:	80 e8       	ldi	r24, 0x80	; 128
    4a5e:	96 e0       	ldi	r25, 0x06	; 6
    4a60:	24 e0       	ldi	r18, 0x04	; 4
    4a62:	fc 01       	movw	r30, r24
    4a64:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4a66:	80 e8       	ldi	r24, 0x80	; 128
    4a68:	96 e0       	ldi	r25, 0x06	; 6
    4a6a:	24 e0       	ldi	r18, 0x04	; 4
    4a6c:	fc 01       	movw	r30, r24
    4a6e:	26 83       	std	Z+6, r18	; 0x06
    4a70:	34 c0       	rjmp	.+104    	; 0x4ada <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4a72:	0e 94 73 1e 	call	0x3ce6	; 0x3ce6 <chb_get_pcb>
    4a76:	8c 83       	std	Y+4, r24	; 0x04
    4a78:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4a7a:	19 82       	std	Y+1, r1	; 0x01
    4a7c:	07 c0       	rjmp	.+14     	; 0x4a8c <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    4a7e:	80 e0       	ldi	r24, 0x00	; 0
    4a80:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    4a84:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4a86:	89 81       	ldd	r24, Y+1	; 0x01
    4a88:	8f 5f       	subi	r24, 0xFF	; 255
    4a8a:	89 83       	std	Y+1, r24	; 0x01
    4a8c:	99 81       	ldd	r25, Y+1	; 0x01
    4a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a90:	98 17       	cp	r25, r24
    4a92:	a8 f3       	brcs	.-22     	; 0x4a7e <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4a94:	8c 81       	ldd	r24, Y+4	; 0x04
    4a96:	9d 81       	ldd	r25, Y+5	; 0x05
    4a98:	fc 01       	movw	r30, r24
    4a9a:	85 85       	ldd	r24, Z+13	; 0x0d
    4a9c:	96 85       	ldd	r25, Z+14	; 0x0e
    4a9e:	9c 01       	movw	r18, r24
    4aa0:	2f 5f       	subi	r18, 0xFF	; 255
    4aa2:	3f 4f       	sbci	r19, 0xFF	; 255
    4aa4:	8c 81       	ldd	r24, Y+4	; 0x04
    4aa6:	9d 81       	ldd	r25, Y+5	; 0x05
    4aa8:	fc 01       	movw	r30, r24
    4aaa:	25 87       	std	Z+13, r18	; 0x0d
    4aac:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4aae:	ce 01       	movw	r24, r28
    4ab0:	06 96       	adiw	r24, 0x06	; 6
    4ab2:	28 ee       	ldi	r18, 0xE8	; 232
    4ab4:	31 e0       	ldi	r19, 0x01	; 1
    4ab6:	b9 01       	movw	r22, r18
    4ab8:	0e 94 5e 5d 	call	0xbabc	; 0xbabc <strcpy_P>
            printf(buf);
    4abc:	0f 92       	push	r0
    4abe:	0f 92       	push	r0
    4ac0:	8d b7       	in	r24, 0x3d	; 61
    4ac2:	9e b7       	in	r25, 0x3e	; 62
    4ac4:	01 96       	adiw	r24, 0x01	; 1
    4ac6:	9e 01       	movw	r18, r28
    4ac8:	2a 5f       	subi	r18, 0xFA	; 250
    4aca:	3f 4f       	sbci	r19, 0xFF	; 255
    4acc:	fc 01       	movw	r30, r24
    4ace:	20 83       	st	Z, r18
    4ad0:	31 83       	std	Z+1, r19	; 0x01
    4ad2:	0e 94 b1 5d 	call	0xbb62	; 0xbb62 <printf>
    4ad6:	0f 90       	pop	r0
    4ad8:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4ada:	80 e0       	ldi	r24, 0x00	; 0
    4adc:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>
    CHB_LEAVE_CRIT();
    4ae0:	8f e3       	ldi	r24, 0x3F	; 63
    4ae2:	90 e0       	ldi	r25, 0x00	; 0
    4ae4:	20 91 55 40 	lds	r18, 0x4055
    4ae8:	fc 01       	movw	r30, r24
    4aea:	20 83       	st	Z, r18
    4aec:	78 94       	sei
}
    4aee:	e7 96       	adiw	r28, 0x37	; 55
    4af0:	cd bf       	out	0x3d, r28	; 61
    4af2:	de bf       	out	0x3e, r29	; 62
    4af4:	df 91       	pop	r29
    4af6:	cf 91       	pop	r28
    4af8:	1f 91       	pop	r17
    4afa:	0f 91       	pop	r16
    4afc:	08 95       	ret

00004afe <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4afe:	cf 93       	push	r28
    4b00:	df 93       	push	r29
    4b02:	0f 92       	push	r0
    4b04:	cd b7       	in	r28, 0x3d	; 61
    4b06:	de b7       	in	r29, 0x3e	; 62
    4b08:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4b0a:	89 81       	ldd	r24, Y+1	; 0x01
    4b0c:	88 2f       	mov	r24, r24
    4b0e:	90 e0       	ldi	r25, 0x00	; 0
    4b10:	81 30       	cpi	r24, 0x01	; 1
    4b12:	91 05       	cpc	r25, r1
    4b14:	c1 f0       	breq	.+48     	; 0x4b46 <chb_set_mode+0x48>
    4b16:	82 30       	cpi	r24, 0x02	; 2
    4b18:	91 05       	cpc	r25, r1
    4b1a:	1c f4       	brge	.+6      	; 0x4b22 <chb_set_mode+0x24>
    4b1c:	00 97       	sbiw	r24, 0x00	; 0
    4b1e:	41 f0       	breq	.+16     	; 0x4b30 <chb_set_mode+0x32>
    4b20:	33 c0       	rjmp	.+102    	; 0x4b88 <chb_set_mode+0x8a>
    4b22:	82 30       	cpi	r24, 0x02	; 2
    4b24:	91 05       	cpc	r25, r1
    4b26:	d1 f0       	breq	.+52     	; 0x4b5c <chb_set_mode+0x5e>
    4b28:	83 30       	cpi	r24, 0x03	; 3
    4b2a:	91 05       	cpc	r25, r1
    4b2c:	11 f1       	breq	.+68     	; 0x4b72 <chb_set_mode+0x74>
    4b2e:	2c c0       	rjmp	.+88     	; 0x4b88 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4b30:	8c e0       	ldi	r24, 0x0C	; 12
    4b32:	68 e0       	ldi	r22, 0x08	; 8
    4b34:	4f e3       	ldi	r20, 0x3F	; 63
    4b36:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4b3a:	86 e1       	ldi	r24, 0x16	; 22
    4b3c:	62 e0       	ldi	r22, 0x02	; 2
    4b3e:	43 e0       	ldi	r20, 0x03	; 3
    4b40:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        break;
    4b44:	21 c0       	rjmp	.+66     	; 0x4b88 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4b46:	8c e0       	ldi	r24, 0x0C	; 12
    4b48:	6c e0       	ldi	r22, 0x0C	; 12
    4b4a:	4f e3       	ldi	r20, 0x3F	; 63
    4b4c:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4b50:	86 e1       	ldi	r24, 0x16	; 22
    4b52:	62 e0       	ldi	r22, 0x02	; 2
    4b54:	43 e0       	ldi	r20, 0x03	; 3
    4b56:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        break;
    4b5a:	16 c0       	rjmp	.+44     	; 0x4b88 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4b5c:	8c e0       	ldi	r24, 0x0C	; 12
    4b5e:	6c e1       	ldi	r22, 0x1C	; 28
    4b60:	4f e3       	ldi	r20, 0x3F	; 63
    4b62:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4b66:	86 e1       	ldi	r24, 0x16	; 22
    4b68:	62 e0       	ldi	r22, 0x02	; 2
    4b6a:	43 e0       	ldi	r20, 0x03	; 3
    4b6c:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        break;
    4b70:	0b c0       	rjmp	.+22     	; 0x4b88 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4b72:	8c e0       	ldi	r24, 0x0C	; 12
    4b74:	60 e0       	ldi	r22, 0x00	; 0
    4b76:	4f e3       	ldi	r20, 0x3F	; 63
    4b78:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4b7c:	86 e1       	ldi	r24, 0x16	; 22
    4b7e:	63 e0       	ldi	r22, 0x03	; 3
    4b80:	43 e0       	ldi	r20, 0x03	; 3
    4b82:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
        break;
    4b86:	00 00       	nop
    }
}
    4b88:	0f 90       	pop	r0
    4b8a:	df 91       	pop	r29
    4b8c:	cf 91       	pop	r28
    4b8e:	08 95       	ret

00004b90 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4b90:	0f 93       	push	r16
    4b92:	1f 93       	push	r17
    4b94:	cf 93       	push	r28
    4b96:	df 93       	push	r29
    4b98:	cd b7       	in	r28, 0x3d	; 61
    4b9a:	de b7       	in	r29, 0x3e	; 62
    4b9c:	6a 97       	sbiw	r28, 0x1a	; 26
    4b9e:	cd bf       	out	0x3d, r28	; 61
    4ba0:	de bf       	out	0x3e, r29	; 62
    4ba2:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4ba4:	88 e0       	ldi	r24, 0x08	; 8
    4ba6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4ba8:	4f e1       	ldi	r20, 0x1F	; 31
    4baa:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4bae:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <chb_get_state>
    4bb2:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4bb4:	89 81       	ldd	r24, Y+1	; 0x01
    4bb6:	86 30       	cpi	r24, 0x06	; 6
    4bb8:	21 f0       	breq	.+8      	; 0x4bc2 <chb_set_channel+0x32>
    4bba:	89 81       	ldd	r24, Y+1	; 0x01
    4bbc:	89 30       	cpi	r24, 0x09	; 9
    4bbe:	09 f0       	breq	.+2      	; 0x4bc2 <chb_set_channel+0x32>
    4bc0:	d5 c0       	rjmp	.+426    	; 0x4d6c <chb_set_channel+0x1dc>
    4bc2:	80 e0       	ldi	r24, 0x00	; 0
    4bc4:	90 e0       	ldi	r25, 0x00	; 0
    4bc6:	ac ed       	ldi	r26, 0xDC	; 220
    4bc8:	b2 e4       	ldi	r27, 0x42	; 66
    4bca:	8a 83       	std	Y+2, r24	; 0x02
    4bcc:	9b 83       	std	Y+3, r25	; 0x03
    4bce:	ac 83       	std	Y+4, r26	; 0x04
    4bd0:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4bd2:	6a 81       	ldd	r22, Y+2	; 0x02
    4bd4:	7b 81       	ldd	r23, Y+3	; 0x03
    4bd6:	8c 81       	ldd	r24, Y+4	; 0x04
    4bd8:	9d 81       	ldd	r25, Y+5	; 0x05
    4bda:	2b ea       	ldi	r18, 0xAB	; 171
    4bdc:	3a ea       	ldi	r19, 0xAA	; 170
    4bde:	4a e2       	ldi	r20, 0x2A	; 42
    4be0:	51 e4       	ldi	r21, 0x41	; 65
    4be2:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4be6:	dc 01       	movw	r26, r24
    4be8:	cb 01       	movw	r24, r22
    4bea:	8e 83       	std	Y+6, r24	; 0x06
    4bec:	9f 83       	std	Y+7, r25	; 0x07
    4bee:	a8 87       	std	Y+8, r26	; 0x08
    4bf0:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4bf2:	11 e0       	ldi	r17, 0x01	; 1
    4bf4:	6e 81       	ldd	r22, Y+6	; 0x06
    4bf6:	7f 81       	ldd	r23, Y+7	; 0x07
    4bf8:	88 85       	ldd	r24, Y+8	; 0x08
    4bfa:	99 85       	ldd	r25, Y+9	; 0x09
    4bfc:	20 e0       	ldi	r18, 0x00	; 0
    4bfe:	30 e0       	ldi	r19, 0x00	; 0
    4c00:	40 e8       	ldi	r20, 0x80	; 128
    4c02:	5f e3       	ldi	r21, 0x3F	; 63
    4c04:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    4c08:	88 23       	and	r24, r24
    4c0a:	0c f0       	brlt	.+2      	; 0x4c0e <chb_set_channel+0x7e>
    4c0c:	10 e0       	ldi	r17, 0x00	; 0
    4c0e:	11 23       	and	r17, r17
    4c10:	19 f0       	breq	.+6      	; 0x4c18 <chb_set_channel+0x88>
		__ticks = 1;
    4c12:	81 e0       	ldi	r24, 0x01	; 1
    4c14:	8a 87       	std	Y+10, r24	; 0x0a
    4c16:	a3 c0       	rjmp	.+326    	; 0x4d5e <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4c18:	11 e0       	ldi	r17, 0x01	; 1
    4c1a:	6e 81       	ldd	r22, Y+6	; 0x06
    4c1c:	7f 81       	ldd	r23, Y+7	; 0x07
    4c1e:	88 85       	ldd	r24, Y+8	; 0x08
    4c20:	99 85       	ldd	r25, Y+9	; 0x09
    4c22:	20 e0       	ldi	r18, 0x00	; 0
    4c24:	30 e0       	ldi	r19, 0x00	; 0
    4c26:	4f e7       	ldi	r20, 0x7F	; 127
    4c28:	53 e4       	ldi	r21, 0x43	; 67
    4c2a:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    4c2e:	18 16       	cp	r1, r24
    4c30:	0c f0       	brlt	.+2      	; 0x4c34 <chb_set_channel+0xa4>
    4c32:	10 e0       	ldi	r17, 0x00	; 0
    4c34:	11 23       	and	r17, r17
    4c36:	09 f4       	brne	.+2      	; 0x4c3a <chb_set_channel+0xaa>
    4c38:	89 c0       	rjmp	.+274    	; 0x4d4c <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4c3a:	6a 81       	ldd	r22, Y+2	; 0x02
    4c3c:	7b 81       	ldd	r23, Y+3	; 0x03
    4c3e:	8c 81       	ldd	r24, Y+4	; 0x04
    4c40:	9d 81       	ldd	r25, Y+5	; 0x05
    4c42:	20 e0       	ldi	r18, 0x00	; 0
    4c44:	30 e0       	ldi	r19, 0x00	; 0
    4c46:	4a e7       	ldi	r20, 0x7A	; 122
    4c48:	54 e4       	ldi	r21, 0x44	; 68
    4c4a:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    4c4e:	dc 01       	movw	r26, r24
    4c50:	cb 01       	movw	r24, r22
    4c52:	8b 87       	std	Y+11, r24	; 0x0b
    4c54:	9c 87       	std	Y+12, r25	; 0x0c
    4c56:	ad 87       	std	Y+13, r26	; 0x0d
    4c58:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4c5a:	6b 85       	ldd	r22, Y+11	; 0x0b
    4c5c:	7c 85       	ldd	r23, Y+12	; 0x0c
    4c5e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c60:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c62:	20 e0       	ldi	r18, 0x00	; 0
    4c64:	30 e0       	ldi	r19, 0x00	; 0
    4c66:	4a ef       	ldi	r20, 0xFA	; 250
    4c68:	55 e4       	ldi	r21, 0x45	; 69
    4c6a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4c6e:	dc 01       	movw	r26, r24
    4c70:	cb 01       	movw	r24, r22
    4c72:	8f 87       	std	Y+15, r24	; 0x0f
    4c74:	98 8b       	std	Y+16, r25	; 0x10
    4c76:	a9 8b       	std	Y+17, r26	; 0x11
    4c78:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4c7a:	11 e0       	ldi	r17, 0x01	; 1
    4c7c:	6f 85       	ldd	r22, Y+15	; 0x0f
    4c7e:	78 89       	ldd	r23, Y+16	; 0x10
    4c80:	89 89       	ldd	r24, Y+17	; 0x11
    4c82:	9a 89       	ldd	r25, Y+18	; 0x12
    4c84:	20 e0       	ldi	r18, 0x00	; 0
    4c86:	30 e0       	ldi	r19, 0x00	; 0
    4c88:	40 e8       	ldi	r20, 0x80	; 128
    4c8a:	5f e3       	ldi	r21, 0x3F	; 63
    4c8c:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    4c90:	88 23       	and	r24, r24
    4c92:	0c f0       	brlt	.+2      	; 0x4c96 <chb_set_channel+0x106>
    4c94:	10 e0       	ldi	r17, 0x00	; 0
    4c96:	11 23       	and	r17, r17
    4c98:	29 f0       	breq	.+10     	; 0x4ca4 <chb_set_channel+0x114>
		__ticks = 1;
    4c9a:	81 e0       	ldi	r24, 0x01	; 1
    4c9c:	90 e0       	ldi	r25, 0x00	; 0
    4c9e:	8b 8b       	std	Y+19, r24	; 0x13
    4ca0:	9c 8b       	std	Y+20, r25	; 0x14
    4ca2:	46 c0       	rjmp	.+140    	; 0x4d30 <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4ca4:	11 e0       	ldi	r17, 0x01	; 1
    4ca6:	6f 85       	ldd	r22, Y+15	; 0x0f
    4ca8:	78 89       	ldd	r23, Y+16	; 0x10
    4caa:	89 89       	ldd	r24, Y+17	; 0x11
    4cac:	9a 89       	ldd	r25, Y+18	; 0x12
    4cae:	20 e0       	ldi	r18, 0x00	; 0
    4cb0:	3f ef       	ldi	r19, 0xFF	; 255
    4cb2:	4f e7       	ldi	r20, 0x7F	; 127
    4cb4:	57 e4       	ldi	r21, 0x47	; 71
    4cb6:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    4cba:	18 16       	cp	r1, r24
    4cbc:	0c f0       	brlt	.+2      	; 0x4cc0 <chb_set_channel+0x130>
    4cbe:	10 e0       	ldi	r17, 0x00	; 0
    4cc0:	11 23       	and	r17, r17
    4cc2:	61 f1       	breq	.+88     	; 0x4d1c <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4cc4:	6b 85       	ldd	r22, Y+11	; 0x0b
    4cc6:	7c 85       	ldd	r23, Y+12	; 0x0c
    4cc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    4cca:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ccc:	20 e0       	ldi	r18, 0x00	; 0
    4cce:	30 e0       	ldi	r19, 0x00	; 0
    4cd0:	40 e2       	ldi	r20, 0x20	; 32
    4cd2:	51 e4       	ldi	r21, 0x41	; 65
    4cd4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4cd8:	dc 01       	movw	r26, r24
    4cda:	cb 01       	movw	r24, r22
    4cdc:	bc 01       	movw	r22, r24
    4cde:	cd 01       	movw	r24, r26
    4ce0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    4ce4:	dc 01       	movw	r26, r24
    4ce6:	cb 01       	movw	r24, r22
    4ce8:	8b 8b       	std	Y+19, r24	; 0x13
    4cea:	9c 8b       	std	Y+20, r25	; 0x14
    4cec:	12 c0       	rjmp	.+36     	; 0x4d12 <chb_set_channel+0x182>
    4cee:	80 e2       	ldi	r24, 0x20	; 32
    4cf0:	93 e0       	ldi	r25, 0x03	; 3
    4cf2:	8d 8b       	std	Y+21, r24	; 0x15
    4cf4:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4cf6:	8d 89       	ldd	r24, Y+21	; 0x15
    4cf8:	9e 89       	ldd	r25, Y+22	; 0x16
    4cfa:	8c 01       	movw	r16, r24
    4cfc:	c8 01       	movw	r24, r16
    4cfe:	01 97       	sbiw	r24, 0x01	; 1
    4d00:	f1 f7       	brne	.-4      	; 0x4cfe <chb_set_channel+0x16e>
    4d02:	8c 01       	movw	r16, r24
    4d04:	0d 8b       	std	Y+21, r16	; 0x15
    4d06:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4d08:	8b 89       	ldd	r24, Y+19	; 0x13
    4d0a:	9c 89       	ldd	r25, Y+20	; 0x14
    4d0c:	01 97       	sbiw	r24, 0x01	; 1
    4d0e:	8b 8b       	std	Y+19, r24	; 0x13
    4d10:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4d12:	8b 89       	ldd	r24, Y+19	; 0x13
    4d14:	9c 89       	ldd	r25, Y+20	; 0x14
    4d16:	00 97       	sbiw	r24, 0x00	; 0
    4d18:	51 f7       	brne	.-44     	; 0x4cee <chb_set_channel+0x15e>
    4d1a:	28 c0       	rjmp	.+80     	; 0x4d6c <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4d1c:	6f 85       	ldd	r22, Y+15	; 0x0f
    4d1e:	78 89       	ldd	r23, Y+16	; 0x10
    4d20:	89 89       	ldd	r24, Y+17	; 0x11
    4d22:	9a 89       	ldd	r25, Y+18	; 0x12
    4d24:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    4d28:	dc 01       	movw	r26, r24
    4d2a:	cb 01       	movw	r24, r22
    4d2c:	8b 8b       	std	Y+19, r24	; 0x13
    4d2e:	9c 8b       	std	Y+20, r25	; 0x14
    4d30:	8b 89       	ldd	r24, Y+19	; 0x13
    4d32:	9c 89       	ldd	r25, Y+20	; 0x14
    4d34:	8f 8b       	std	Y+23, r24	; 0x17
    4d36:	98 8f       	std	Y+24, r25	; 0x18
    4d38:	8f 89       	ldd	r24, Y+23	; 0x17
    4d3a:	98 8d       	ldd	r25, Y+24	; 0x18
    4d3c:	8c 01       	movw	r16, r24
    4d3e:	c8 01       	movw	r24, r16
    4d40:	01 97       	sbiw	r24, 0x01	; 1
    4d42:	f1 f7       	brne	.-4      	; 0x4d40 <chb_set_channel+0x1b0>
    4d44:	8c 01       	movw	r16, r24
    4d46:	0f 8b       	std	Y+23, r16	; 0x17
    4d48:	18 8f       	std	Y+24, r17	; 0x18
    4d4a:	10 c0       	rjmp	.+32     	; 0x4d6c <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4d4c:	6e 81       	ldd	r22, Y+6	; 0x06
    4d4e:	7f 81       	ldd	r23, Y+7	; 0x07
    4d50:	88 85       	ldd	r24, Y+8	; 0x08
    4d52:	99 85       	ldd	r25, Y+9	; 0x09
    4d54:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    4d58:	dc 01       	movw	r26, r24
    4d5a:	cb 01       	movw	r24, r22
    4d5c:	8a 87       	std	Y+10, r24	; 0x0a
    4d5e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d60:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4d62:	89 8d       	ldd	r24, Y+25	; 0x19
    4d64:	18 2f       	mov	r17, r24
    4d66:	1a 95       	dec	r17
    4d68:	f1 f7       	brne	.-4      	; 0x4d66 <chb_set_channel+0x1d6>
    4d6a:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4d6c:	88 e0       	ldi	r24, 0x08	; 8
    4d6e:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    4d72:	88 2f       	mov	r24, r24
    4d74:	90 e0       	ldi	r25, 0x00	; 0
    4d76:	9c 01       	movw	r18, r24
    4d78:	2f 71       	andi	r18, 0x1F	; 31
    4d7a:	30 70       	andi	r19, 0x00	; 0
    4d7c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4d7e:	88 2f       	mov	r24, r24
    4d80:	90 e0       	ldi	r25, 0x00	; 0
    4d82:	28 17       	cp	r18, r24
    4d84:	39 07       	cpc	r19, r25
    4d86:	11 f4       	brne	.+4      	; 0x4d8c <chb_set_channel+0x1fc>
    4d88:	80 e4       	ldi	r24, 0x40	; 64
    4d8a:	01 c0       	rjmp	.+2      	; 0x4d8e <chb_set_channel+0x1fe>
    4d8c:	83 e4       	ldi	r24, 0x43	; 67
}
    4d8e:	6a 96       	adiw	r28, 0x1a	; 26
    4d90:	cd bf       	out	0x3d, r28	; 61
    4d92:	de bf       	out	0x3e, r29	; 62
    4d94:	df 91       	pop	r29
    4d96:	cf 91       	pop	r28
    4d98:	1f 91       	pop	r17
    4d9a:	0f 91       	pop	r16
    4d9c:	08 95       	ret

00004d9e <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4d9e:	cf 93       	push	r28
    4da0:	df 93       	push	r29
    4da2:	0f 92       	push	r0
    4da4:	cd b7       	in	r28, 0x3d	; 61
    4da6:	de b7       	in	r29, 0x3e	; 62
    4da8:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4daa:	85 e0       	ldi	r24, 0x05	; 5
    4dac:	69 81       	ldd	r22, Y+1	; 0x01
    4dae:	0e 94 df 23 	call	0x47be	; 0x47be <chb_reg_write>
}
    4db2:	0f 90       	pop	r0
    4db4:	df 91       	pop	r29
    4db6:	cf 91       	pop	r28
    4db8:	08 95       	ret

00004dba <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4dba:	0f 93       	push	r16
    4dbc:	1f 93       	push	r17
    4dbe:	cf 93       	push	r28
    4dc0:	df 93       	push	r29
    4dc2:	cd b7       	in	r28, 0x3d	; 61
    4dc4:	de b7       	in	r29, 0x3e	; 62
    4dc6:	c2 56       	subi	r28, 0x62	; 98
    4dc8:	d0 40       	sbci	r29, 0x00	; 0
    4dca:	cd bf       	out	0x3d, r28	; 61
    4dcc:	de bf       	out	0x3e, r29	; 62
    4dce:	9e 01       	movw	r18, r28
    4dd0:	2e 59       	subi	r18, 0x9E	; 158
    4dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    4dd4:	f9 01       	movw	r30, r18
    4dd6:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4dd8:	84 e6       	ldi	r24, 0x64	; 100
    4dda:	96 e0       	ldi	r25, 0x06	; 6
    4ddc:	fc 01       	movw	r30, r24
    4dde:	80 81       	ld	r24, Z
    4de0:	88 2f       	mov	r24, r24
    4de2:	90 e0       	ldi	r25, 0x00	; 0
    4de4:	82 70       	andi	r24, 0x02	; 2
    4de6:	90 70       	andi	r25, 0x00	; 0
    4de8:	00 97       	sbiw	r24, 0x00	; 0
    4dea:	11 f0       	breq	.+4      	; 0x4df0 <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4dec:	84 e4       	ldi	r24, 0x44	; 68
    4dee:	91 c4       	rjmp	.+2338   	; 0x5712 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4df0:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <chb_get_state>
    4df4:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4df6:	89 81       	ldd	r24, Y+1	; 0x01
    4df8:	82 31       	cpi	r24, 0x12	; 18
    4dfa:	49 f0       	breq	.+18     	; 0x4e0e <chb_set_state+0x54>
    4dfc:	89 81       	ldd	r24, Y+1	; 0x01
    4dfe:	81 31       	cpi	r24, 0x11	; 17
    4e00:	31 f0       	breq	.+12     	; 0x4e0e <chb_set_state+0x54>
    4e02:	89 81       	ldd	r24, Y+1	; 0x01
    4e04:	81 30       	cpi	r24, 0x01	; 1
    4e06:	19 f0       	breq	.+6      	; 0x4e0e <chb_set_state+0x54>
    4e08:	89 81       	ldd	r24, Y+1	; 0x01
    4e0a:	82 30       	cpi	r24, 0x02	; 2
    4e0c:	39 f4       	brne	.+14     	; 0x4e1c <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4e0e:	00 00       	nop
    4e10:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <chb_get_state>
    4e14:	98 2f       	mov	r25, r24
    4e16:	89 81       	ldd	r24, Y+1	; 0x01
    4e18:	98 17       	cp	r25, r24
    4e1a:	d1 f3       	breq	.-12     	; 0x4e10 <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4e1c:	ce 01       	movw	r24, r28
    4e1e:	8e 59       	subi	r24, 0x9E	; 158
    4e20:	9f 4f       	sbci	r25, 0xFF	; 255
    4e22:	fc 01       	movw	r30, r24
    4e24:	80 81       	ld	r24, Z
    4e26:	88 2f       	mov	r24, r24
    4e28:	90 e0       	ldi	r25, 0x00	; 0
    4e2a:	86 31       	cpi	r24, 0x16	; 22
    4e2c:	91 05       	cpc	r25, r1
    4e2e:	09 f4       	brne	.+2      	; 0x4e32 <chb_set_state+0x78>
    4e30:	cd c1       	rjmp	.+922    	; 0x51cc <chb_set_state+0x412>
    4e32:	89 31       	cpi	r24, 0x19	; 25
    4e34:	91 05       	cpc	r25, r1
    4e36:	09 f4       	brne	.+2      	; 0x4e3a <chb_set_state+0x80>
    4e38:	e9 c0       	rjmp	.+466    	; 0x500c <chb_set_state+0x252>
    4e3a:	88 30       	cpi	r24, 0x08	; 8
    4e3c:	91 05       	cpc	r25, r1
    4e3e:	09 f0       	breq	.+2      	; 0x4e42 <chb_set_state+0x88>
    4e40:	f7 c2       	rjmp	.+1518   	; 0x5430 <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4e42:	84 e6       	ldi	r24, 0x64	; 100
    4e44:	96 e0       	ldi	r25, 0x06	; 6
    4e46:	24 e6       	ldi	r18, 0x64	; 100
    4e48:	36 e0       	ldi	r19, 0x06	; 6
    4e4a:	f9 01       	movw	r30, r18
    4e4c:	20 81       	ld	r18, Z
    4e4e:	2d 7f       	andi	r18, 0xFD	; 253
    4e50:	fc 01       	movw	r30, r24
    4e52:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4e54:	82 e0       	ldi	r24, 0x02	; 2
    4e56:	63 e0       	ldi	r22, 0x03	; 3
    4e58:	4f e1       	ldi	r20, 0x1F	; 31
    4e5a:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
    4e5e:	80 e0       	ldi	r24, 0x00	; 0
    4e60:	90 e0       	ldi	r25, 0x00	; 0
    4e62:	a0 e8       	ldi	r26, 0x80	; 128
    4e64:	bf e3       	ldi	r27, 0x3F	; 63
    4e66:	8a 83       	std	Y+2, r24	; 0x02
    4e68:	9b 83       	std	Y+3, r25	; 0x03
    4e6a:	ac 83       	std	Y+4, r26	; 0x04
    4e6c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4e6e:	6a 81       	ldd	r22, Y+2	; 0x02
    4e70:	7b 81       	ldd	r23, Y+3	; 0x03
    4e72:	8c 81       	ldd	r24, Y+4	; 0x04
    4e74:	9d 81       	ldd	r25, Y+5	; 0x05
    4e76:	2b ea       	ldi	r18, 0xAB	; 171
    4e78:	3a ea       	ldi	r19, 0xAA	; 170
    4e7a:	4a e2       	ldi	r20, 0x2A	; 42
    4e7c:	51 e4       	ldi	r21, 0x41	; 65
    4e7e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4e82:	dc 01       	movw	r26, r24
    4e84:	cb 01       	movw	r24, r22
    4e86:	8e 83       	std	Y+6, r24	; 0x06
    4e88:	9f 83       	std	Y+7, r25	; 0x07
    4e8a:	a8 87       	std	Y+8, r26	; 0x08
    4e8c:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4e8e:	11 e0       	ldi	r17, 0x01	; 1
    4e90:	6e 81       	ldd	r22, Y+6	; 0x06
    4e92:	7f 81       	ldd	r23, Y+7	; 0x07
    4e94:	88 85       	ldd	r24, Y+8	; 0x08
    4e96:	99 85       	ldd	r25, Y+9	; 0x09
    4e98:	20 e0       	ldi	r18, 0x00	; 0
    4e9a:	30 e0       	ldi	r19, 0x00	; 0
    4e9c:	40 e8       	ldi	r20, 0x80	; 128
    4e9e:	5f e3       	ldi	r21, 0x3F	; 63
    4ea0:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    4ea4:	88 23       	and	r24, r24
    4ea6:	0c f0       	brlt	.+2      	; 0x4eaa <chb_set_state+0xf0>
    4ea8:	10 e0       	ldi	r17, 0x00	; 0
    4eaa:	11 23       	and	r17, r17
    4eac:	19 f0       	breq	.+6      	; 0x4eb4 <chb_set_state+0xfa>
		__ticks = 1;
    4eae:	81 e0       	ldi	r24, 0x01	; 1
    4eb0:	8a 87       	std	Y+10, r24	; 0x0a
    4eb2:	a3 c0       	rjmp	.+326    	; 0x4ffa <chb_set_state+0x240>
	else if (__tmp > 255)
    4eb4:	11 e0       	ldi	r17, 0x01	; 1
    4eb6:	6e 81       	ldd	r22, Y+6	; 0x06
    4eb8:	7f 81       	ldd	r23, Y+7	; 0x07
    4eba:	88 85       	ldd	r24, Y+8	; 0x08
    4ebc:	99 85       	ldd	r25, Y+9	; 0x09
    4ebe:	20 e0       	ldi	r18, 0x00	; 0
    4ec0:	30 e0       	ldi	r19, 0x00	; 0
    4ec2:	4f e7       	ldi	r20, 0x7F	; 127
    4ec4:	53 e4       	ldi	r21, 0x43	; 67
    4ec6:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    4eca:	18 16       	cp	r1, r24
    4ecc:	0c f0       	brlt	.+2      	; 0x4ed0 <chb_set_state+0x116>
    4ece:	10 e0       	ldi	r17, 0x00	; 0
    4ed0:	11 23       	and	r17, r17
    4ed2:	09 f4       	brne	.+2      	; 0x4ed6 <chb_set_state+0x11c>
    4ed4:	89 c0       	rjmp	.+274    	; 0x4fe8 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    4ed6:	6a 81       	ldd	r22, Y+2	; 0x02
    4ed8:	7b 81       	ldd	r23, Y+3	; 0x03
    4eda:	8c 81       	ldd	r24, Y+4	; 0x04
    4edc:	9d 81       	ldd	r25, Y+5	; 0x05
    4ede:	20 e0       	ldi	r18, 0x00	; 0
    4ee0:	30 e0       	ldi	r19, 0x00	; 0
    4ee2:	4a e7       	ldi	r20, 0x7A	; 122
    4ee4:	54 e4       	ldi	r21, 0x44	; 68
    4ee6:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    4eea:	dc 01       	movw	r26, r24
    4eec:	cb 01       	movw	r24, r22
    4eee:	8b 87       	std	Y+11, r24	; 0x0b
    4ef0:	9c 87       	std	Y+12, r25	; 0x0c
    4ef2:	ad 87       	std	Y+13, r26	; 0x0d
    4ef4:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4ef6:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ef8:	7c 85       	ldd	r23, Y+12	; 0x0c
    4efa:	8d 85       	ldd	r24, Y+13	; 0x0d
    4efc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4efe:	20 e0       	ldi	r18, 0x00	; 0
    4f00:	30 e0       	ldi	r19, 0x00	; 0
    4f02:	4a ef       	ldi	r20, 0xFA	; 250
    4f04:	55 e4       	ldi	r21, 0x45	; 69
    4f06:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4f0a:	dc 01       	movw	r26, r24
    4f0c:	cb 01       	movw	r24, r22
    4f0e:	8f 87       	std	Y+15, r24	; 0x0f
    4f10:	98 8b       	std	Y+16, r25	; 0x10
    4f12:	a9 8b       	std	Y+17, r26	; 0x11
    4f14:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4f16:	11 e0       	ldi	r17, 0x01	; 1
    4f18:	6f 85       	ldd	r22, Y+15	; 0x0f
    4f1a:	78 89       	ldd	r23, Y+16	; 0x10
    4f1c:	89 89       	ldd	r24, Y+17	; 0x11
    4f1e:	9a 89       	ldd	r25, Y+18	; 0x12
    4f20:	20 e0       	ldi	r18, 0x00	; 0
    4f22:	30 e0       	ldi	r19, 0x00	; 0
    4f24:	40 e8       	ldi	r20, 0x80	; 128
    4f26:	5f e3       	ldi	r21, 0x3F	; 63
    4f28:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    4f2c:	88 23       	and	r24, r24
    4f2e:	0c f0       	brlt	.+2      	; 0x4f32 <chb_set_state+0x178>
    4f30:	10 e0       	ldi	r17, 0x00	; 0
    4f32:	11 23       	and	r17, r17
    4f34:	29 f0       	breq	.+10     	; 0x4f40 <chb_set_state+0x186>
		__ticks = 1;
    4f36:	81 e0       	ldi	r24, 0x01	; 1
    4f38:	90 e0       	ldi	r25, 0x00	; 0
    4f3a:	8b 8b       	std	Y+19, r24	; 0x13
    4f3c:	9c 8b       	std	Y+20, r25	; 0x14
    4f3e:	46 c0       	rjmp	.+140    	; 0x4fcc <chb_set_state+0x212>
	else if (__tmp > 65535)
    4f40:	11 e0       	ldi	r17, 0x01	; 1
    4f42:	6f 85       	ldd	r22, Y+15	; 0x0f
    4f44:	78 89       	ldd	r23, Y+16	; 0x10
    4f46:	89 89       	ldd	r24, Y+17	; 0x11
    4f48:	9a 89       	ldd	r25, Y+18	; 0x12
    4f4a:	20 e0       	ldi	r18, 0x00	; 0
    4f4c:	3f ef       	ldi	r19, 0xFF	; 255
    4f4e:	4f e7       	ldi	r20, 0x7F	; 127
    4f50:	57 e4       	ldi	r21, 0x47	; 71
    4f52:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    4f56:	18 16       	cp	r1, r24
    4f58:	0c f0       	brlt	.+2      	; 0x4f5c <chb_set_state+0x1a2>
    4f5a:	10 e0       	ldi	r17, 0x00	; 0
    4f5c:	11 23       	and	r17, r17
    4f5e:	61 f1       	breq	.+88     	; 0x4fb8 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4f60:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f62:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f64:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f66:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f68:	20 e0       	ldi	r18, 0x00	; 0
    4f6a:	30 e0       	ldi	r19, 0x00	; 0
    4f6c:	40 e2       	ldi	r20, 0x20	; 32
    4f6e:	51 e4       	ldi	r21, 0x41	; 65
    4f70:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    4f74:	dc 01       	movw	r26, r24
    4f76:	cb 01       	movw	r24, r22
    4f78:	bc 01       	movw	r22, r24
    4f7a:	cd 01       	movw	r24, r26
    4f7c:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    4f80:	dc 01       	movw	r26, r24
    4f82:	cb 01       	movw	r24, r22
    4f84:	8b 8b       	std	Y+19, r24	; 0x13
    4f86:	9c 8b       	std	Y+20, r25	; 0x14
    4f88:	12 c0       	rjmp	.+36     	; 0x4fae <chb_set_state+0x1f4>
    4f8a:	80 e2       	ldi	r24, 0x20	; 32
    4f8c:	93 e0       	ldi	r25, 0x03	; 3
    4f8e:	8d 8b       	std	Y+21, r24	; 0x15
    4f90:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4f92:	8d 89       	ldd	r24, Y+21	; 0x15
    4f94:	9e 89       	ldd	r25, Y+22	; 0x16
    4f96:	8c 01       	movw	r16, r24
    4f98:	c8 01       	movw	r24, r16
    4f9a:	01 97       	sbiw	r24, 0x01	; 1
    4f9c:	f1 f7       	brne	.-4      	; 0x4f9a <chb_set_state+0x1e0>
    4f9e:	8c 01       	movw	r16, r24
    4fa0:	0d 8b       	std	Y+21, r16	; 0x15
    4fa2:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4fa4:	8b 89       	ldd	r24, Y+19	; 0x13
    4fa6:	9c 89       	ldd	r25, Y+20	; 0x14
    4fa8:	01 97       	sbiw	r24, 0x01	; 1
    4faa:	8b 8b       	std	Y+19, r24	; 0x13
    4fac:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4fae:	8b 89       	ldd	r24, Y+19	; 0x13
    4fb0:	9c 89       	ldd	r25, Y+20	; 0x14
    4fb2:	00 97       	sbiw	r24, 0x00	; 0
    4fb4:	51 f7       	brne	.-44     	; 0x4f8a <chb_set_state+0x1d0>
    4fb6:	29 c0       	rjmp	.+82     	; 0x500a <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4fb8:	6f 85       	ldd	r22, Y+15	; 0x0f
    4fba:	78 89       	ldd	r23, Y+16	; 0x10
    4fbc:	89 89       	ldd	r24, Y+17	; 0x11
    4fbe:	9a 89       	ldd	r25, Y+18	; 0x12
    4fc0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    4fc4:	dc 01       	movw	r26, r24
    4fc6:	cb 01       	movw	r24, r22
    4fc8:	8b 8b       	std	Y+19, r24	; 0x13
    4fca:	9c 8b       	std	Y+20, r25	; 0x14
    4fcc:	8b 89       	ldd	r24, Y+19	; 0x13
    4fce:	9c 89       	ldd	r25, Y+20	; 0x14
    4fd0:	8f 8b       	std	Y+23, r24	; 0x17
    4fd2:	98 8f       	std	Y+24, r25	; 0x18
    4fd4:	8f 89       	ldd	r24, Y+23	; 0x17
    4fd6:	98 8d       	ldd	r25, Y+24	; 0x18
    4fd8:	8c 01       	movw	r16, r24
    4fda:	f8 01       	movw	r30, r16
    4fdc:	31 97       	sbiw	r30, 0x01	; 1
    4fde:	f1 f7       	brne	.-4      	; 0x4fdc <chb_set_state+0x222>
    4fe0:	8f 01       	movw	r16, r30
    4fe2:	0f 8b       	std	Y+23, r16	; 0x17
    4fe4:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    4fe6:	24 c2       	rjmp	.+1096   	; 0x5430 <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4fe8:	6e 81       	ldd	r22, Y+6	; 0x06
    4fea:	7f 81       	ldd	r23, Y+7	; 0x07
    4fec:	88 85       	ldd	r24, Y+8	; 0x08
    4fee:	99 85       	ldd	r25, Y+9	; 0x09
    4ff0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    4ff4:	dc 01       	movw	r26, r24
    4ff6:	cb 01       	movw	r24, r22
    4ff8:	8a 87       	std	Y+10, r24	; 0x0a
    4ffa:	8a 85       	ldd	r24, Y+10	; 0x0a
    4ffc:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4ffe:	89 8d       	ldd	r24, Y+25	; 0x19
    5000:	18 2f       	mov	r17, r24
    5002:	1a 95       	dec	r17
    5004:	f1 f7       	brne	.-4      	; 0x5002 <chb_set_state+0x248>
    5006:	19 8f       	std	Y+25, r17	; 0x19
    5008:	13 c2       	rjmp	.+1062   	; 0x5430 <chb_set_state+0x676>
    500a:	12 c2       	rjmp	.+1060   	; 0x5430 <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    500c:	89 81       	ldd	r24, Y+1	; 0x01
    500e:	86 31       	cpi	r24, 0x16	; 22
    5010:	09 f0       	breq	.+2      	; 0x5014 <chb_set_state+0x25a>
    5012:	0b c2       	rjmp	.+1046   	; 0x542a <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5014:	82 e0       	ldi	r24, 0x02	; 2
    5016:	69 e0       	ldi	r22, 0x09	; 9
    5018:	4f e1       	ldi	r20, 0x1F	; 31
    501a:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
    501e:	80 e0       	ldi	r24, 0x00	; 0
    5020:	90 e0       	ldi	r25, 0x00	; 0
    5022:	a0 e8       	ldi	r26, 0x80	; 128
    5024:	bf e3       	ldi	r27, 0x3F	; 63
    5026:	8a 8f       	std	Y+26, r24	; 0x1a
    5028:	9b 8f       	std	Y+27, r25	; 0x1b
    502a:	ac 8f       	std	Y+28, r26	; 0x1c
    502c:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    502e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5030:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5032:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5034:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5036:	2b ea       	ldi	r18, 0xAB	; 171
    5038:	3a ea       	ldi	r19, 0xAA	; 170
    503a:	4a e2       	ldi	r20, 0x2A	; 42
    503c:	51 e4       	ldi	r21, 0x41	; 65
    503e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    5042:	dc 01       	movw	r26, r24
    5044:	cb 01       	movw	r24, r22
    5046:	8e 8f       	std	Y+30, r24	; 0x1e
    5048:	9f 8f       	std	Y+31, r25	; 0x1f
    504a:	a8 a3       	lds	r26, 0x58
    504c:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    504e:	11 e0       	ldi	r17, 0x01	; 1
    5050:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5052:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5054:	88 a1       	lds	r24, 0x48
    5056:	99 a1       	lds	r25, 0x49
    5058:	20 e0       	ldi	r18, 0x00	; 0
    505a:	30 e0       	ldi	r19, 0x00	; 0
    505c:	40 e8       	ldi	r20, 0x80	; 128
    505e:	5f e3       	ldi	r21, 0x3F	; 63
    5060:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    5064:	88 23       	and	r24, r24
    5066:	0c f0       	brlt	.+2      	; 0x506a <chb_set_state+0x2b0>
    5068:	10 e0       	ldi	r17, 0x00	; 0
    506a:	11 23       	and	r17, r17
    506c:	19 f0       	breq	.+6      	; 0x5074 <chb_set_state+0x2ba>
		__ticks = 1;
    506e:	81 e0       	ldi	r24, 0x01	; 1
    5070:	8a a3       	lds	r24, 0x5a
    5072:	a3 c0       	rjmp	.+326    	; 0x51ba <chb_set_state+0x400>
	else if (__tmp > 255)
    5074:	11 e0       	ldi	r17, 0x01	; 1
    5076:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5078:	7f 8d       	ldd	r23, Y+31	; 0x1f
    507a:	88 a1       	lds	r24, 0x48
    507c:	99 a1       	lds	r25, 0x49
    507e:	20 e0       	ldi	r18, 0x00	; 0
    5080:	30 e0       	ldi	r19, 0x00	; 0
    5082:	4f e7       	ldi	r20, 0x7F	; 127
    5084:	53 e4       	ldi	r21, 0x43	; 67
    5086:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    508a:	18 16       	cp	r1, r24
    508c:	0c f0       	brlt	.+2      	; 0x5090 <chb_set_state+0x2d6>
    508e:	10 e0       	ldi	r17, 0x00	; 0
    5090:	11 23       	and	r17, r17
    5092:	09 f4       	brne	.+2      	; 0x5096 <chb_set_state+0x2dc>
    5094:	89 c0       	rjmp	.+274    	; 0x51a8 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    5096:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5098:	7b 8d       	ldd	r23, Y+27	; 0x1b
    509a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    509c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    509e:	20 e0       	ldi	r18, 0x00	; 0
    50a0:	30 e0       	ldi	r19, 0x00	; 0
    50a2:	4a e7       	ldi	r20, 0x7A	; 122
    50a4:	54 e4       	ldi	r21, 0x44	; 68
    50a6:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    50aa:	dc 01       	movw	r26, r24
    50ac:	cb 01       	movw	r24, r22
    50ae:	8b a3       	lds	r24, 0x5b
    50b0:	9c a3       	lds	r25, 0x5c
    50b2:	ad a3       	lds	r26, 0x5d
    50b4:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    50b6:	6b a1       	lds	r22, 0x4b
    50b8:	7c a1       	lds	r23, 0x4c
    50ba:	8d a1       	lds	r24, 0x4d
    50bc:	9e a1       	lds	r25, 0x4e
    50be:	20 e0       	ldi	r18, 0x00	; 0
    50c0:	30 e0       	ldi	r19, 0x00	; 0
    50c2:	4a ef       	ldi	r20, 0xFA	; 250
    50c4:	55 e4       	ldi	r21, 0x45	; 69
    50c6:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    50ca:	dc 01       	movw	r26, r24
    50cc:	cb 01       	movw	r24, r22
    50ce:	8f a3       	lds	r24, 0x5f
    50d0:	98 a7       	lds	r25, 0x78
    50d2:	a9 a7       	lds	r26, 0x79
    50d4:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    50d6:	11 e0       	ldi	r17, 0x01	; 1
    50d8:	6f a1       	lds	r22, 0x4f
    50da:	78 a5       	lds	r23, 0x68
    50dc:	89 a5       	lds	r24, 0x69
    50de:	9a a5       	lds	r25, 0x6a
    50e0:	20 e0       	ldi	r18, 0x00	; 0
    50e2:	30 e0       	ldi	r19, 0x00	; 0
    50e4:	40 e8       	ldi	r20, 0x80	; 128
    50e6:	5f e3       	ldi	r21, 0x3F	; 63
    50e8:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    50ec:	88 23       	and	r24, r24
    50ee:	0c f0       	brlt	.+2      	; 0x50f2 <chb_set_state+0x338>
    50f0:	10 e0       	ldi	r17, 0x00	; 0
    50f2:	11 23       	and	r17, r17
    50f4:	29 f0       	breq	.+10     	; 0x5100 <chb_set_state+0x346>
		__ticks = 1;
    50f6:	81 e0       	ldi	r24, 0x01	; 1
    50f8:	90 e0       	ldi	r25, 0x00	; 0
    50fa:	8b a7       	lds	r24, 0x7b
    50fc:	9c a7       	lds	r25, 0x7c
    50fe:	46 c0       	rjmp	.+140    	; 0x518c <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    5100:	11 e0       	ldi	r17, 0x01	; 1
    5102:	6f a1       	lds	r22, 0x4f
    5104:	78 a5       	lds	r23, 0x68
    5106:	89 a5       	lds	r24, 0x69
    5108:	9a a5       	lds	r25, 0x6a
    510a:	20 e0       	ldi	r18, 0x00	; 0
    510c:	3f ef       	ldi	r19, 0xFF	; 255
    510e:	4f e7       	ldi	r20, 0x7F	; 127
    5110:	57 e4       	ldi	r21, 0x47	; 71
    5112:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    5116:	18 16       	cp	r1, r24
    5118:	0c f0       	brlt	.+2      	; 0x511c <chb_set_state+0x362>
    511a:	10 e0       	ldi	r17, 0x00	; 0
    511c:	11 23       	and	r17, r17
    511e:	61 f1       	breq	.+88     	; 0x5178 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5120:	6b a1       	lds	r22, 0x4b
    5122:	7c a1       	lds	r23, 0x4c
    5124:	8d a1       	lds	r24, 0x4d
    5126:	9e a1       	lds	r25, 0x4e
    5128:	20 e0       	ldi	r18, 0x00	; 0
    512a:	30 e0       	ldi	r19, 0x00	; 0
    512c:	40 e2       	ldi	r20, 0x20	; 32
    512e:	51 e4       	ldi	r21, 0x41	; 65
    5130:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    5134:	dc 01       	movw	r26, r24
    5136:	cb 01       	movw	r24, r22
    5138:	bc 01       	movw	r22, r24
    513a:	cd 01       	movw	r24, r26
    513c:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    5140:	dc 01       	movw	r26, r24
    5142:	cb 01       	movw	r24, r22
    5144:	8b a7       	lds	r24, 0x7b
    5146:	9c a7       	lds	r25, 0x7c
    5148:	12 c0       	rjmp	.+36     	; 0x516e <chb_set_state+0x3b4>
    514a:	80 e2       	ldi	r24, 0x20	; 32
    514c:	93 e0       	ldi	r25, 0x03	; 3
    514e:	8d a7       	lds	r24, 0x7d
    5150:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5152:	8d a5       	lds	r24, 0x6d
    5154:	9e a5       	lds	r25, 0x6e
    5156:	8c 01       	movw	r16, r24
    5158:	c8 01       	movw	r24, r16
    515a:	01 97       	sbiw	r24, 0x01	; 1
    515c:	f1 f7       	brne	.-4      	; 0x515a <chb_set_state+0x3a0>
    515e:	8c 01       	movw	r16, r24
    5160:	0d a7       	lds	r16, 0x7d
    5162:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5164:	8b a5       	lds	r24, 0x6b
    5166:	9c a5       	lds	r25, 0x6c
    5168:	01 97       	sbiw	r24, 0x01	; 1
    516a:	8b a7       	lds	r24, 0x7b
    516c:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    516e:	8b a5       	lds	r24, 0x6b
    5170:	9c a5       	lds	r25, 0x6c
    5172:	00 97       	sbiw	r24, 0x00	; 0
    5174:	51 f7       	brne	.-44     	; 0x514a <chb_set_state+0x390>
    5176:	29 c0       	rjmp	.+82     	; 0x51ca <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5178:	6f a1       	lds	r22, 0x4f
    517a:	78 a5       	lds	r23, 0x68
    517c:	89 a5       	lds	r24, 0x69
    517e:	9a a5       	lds	r25, 0x6a
    5180:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    5184:	dc 01       	movw	r26, r24
    5186:	cb 01       	movw	r24, r22
    5188:	8b a7       	lds	r24, 0x7b
    518a:	9c a7       	lds	r25, 0x7c
    518c:	8b a5       	lds	r24, 0x6b
    518e:	9c a5       	lds	r25, 0x6c
    5190:	8f a7       	lds	r24, 0x7f
    5192:	98 ab       	sts	0x58, r25
    5194:	8f a5       	lds	r24, 0x6f
    5196:	98 a9       	sts	0x48, r25
    5198:	8c 01       	movw	r16, r24
    519a:	f8 01       	movw	r30, r16
    519c:	31 97       	sbiw	r30, 0x01	; 1
    519e:	f1 f7       	brne	.-4      	; 0x519c <chb_set_state+0x3e2>
    51a0:	8f 01       	movw	r16, r30
    51a2:	0f a7       	lds	r16, 0x7f
    51a4:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    51a6:	41 c1       	rjmp	.+642    	; 0x542a <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    51a8:	6e 8d       	ldd	r22, Y+30	; 0x1e
    51aa:	7f 8d       	ldd	r23, Y+31	; 0x1f
    51ac:	88 a1       	lds	r24, 0x48
    51ae:	99 a1       	lds	r25, 0x49
    51b0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    51b4:	dc 01       	movw	r26, r24
    51b6:	cb 01       	movw	r24, r22
    51b8:	8a a3       	lds	r24, 0x5a
    51ba:	8a a1       	lds	r24, 0x4a
    51bc:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    51be:	89 a9       	sts	0x49, r24
    51c0:	18 2f       	mov	r17, r24
    51c2:	1a 95       	dec	r17
    51c4:	f1 f7       	brne	.-4      	; 0x51c2 <chb_set_state+0x408>
    51c6:	19 ab       	sts	0x59, r17
    51c8:	30 c1       	rjmp	.+608    	; 0x542a <chb_set_state+0x670>
    51ca:	2f c1       	rjmp	.+606    	; 0x542a <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    51cc:	89 81       	ldd	r24, Y+1	; 0x01
    51ce:	89 31       	cpi	r24, 0x19	; 25
    51d0:	09 f0       	breq	.+2      	; 0x51d4 <chb_set_state+0x41a>
    51d2:	2d c1       	rjmp	.+602    	; 0x542e <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    51d4:	82 e0       	ldi	r24, 0x02	; 2
    51d6:	69 e0       	ldi	r22, 0x09	; 9
    51d8:	4f e1       	ldi	r20, 0x1F	; 31
    51da:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
    51de:	80 e0       	ldi	r24, 0x00	; 0
    51e0:	90 e0       	ldi	r25, 0x00	; 0
    51e2:	a0 e8       	ldi	r26, 0x80	; 128
    51e4:	bf e3       	ldi	r27, 0x3F	; 63
    51e6:	8a ab       	sts	0x5a, r24
    51e8:	9b ab       	sts	0x5b, r25
    51ea:	ac ab       	sts	0x5c, r26
    51ec:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    51ee:	6a a9       	sts	0x4a, r22
    51f0:	7b a9       	sts	0x4b, r23
    51f2:	8c a9       	sts	0x4c, r24
    51f4:	9d a9       	sts	0x4d, r25
    51f6:	2b ea       	ldi	r18, 0xAB	; 171
    51f8:	3a ea       	ldi	r19, 0xAA	; 170
    51fa:	4a e2       	ldi	r20, 0x2A	; 42
    51fc:	51 e4       	ldi	r21, 0x41	; 65
    51fe:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    5202:	dc 01       	movw	r26, r24
    5204:	cb 01       	movw	r24, r22
    5206:	8e ab       	sts	0x5e, r24
    5208:	9f ab       	sts	0x5f, r25
    520a:	a8 af       	sts	0x78, r26
    520c:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    520e:	11 e0       	ldi	r17, 0x01	; 1
    5210:	6e a9       	sts	0x4e, r22
    5212:	7f a9       	sts	0x4f, r23
    5214:	88 ad       	sts	0x68, r24
    5216:	99 ad       	sts	0x69, r25
    5218:	20 e0       	ldi	r18, 0x00	; 0
    521a:	30 e0       	ldi	r19, 0x00	; 0
    521c:	40 e8       	ldi	r20, 0x80	; 128
    521e:	5f e3       	ldi	r21, 0x3F	; 63
    5220:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    5224:	88 23       	and	r24, r24
    5226:	0c f0       	brlt	.+2      	; 0x522a <chb_set_state+0x470>
    5228:	10 e0       	ldi	r17, 0x00	; 0
    522a:	11 23       	and	r17, r17
    522c:	19 f0       	breq	.+6      	; 0x5234 <chb_set_state+0x47a>
		__ticks = 1;
    522e:	81 e0       	ldi	r24, 0x01	; 1
    5230:	8a af       	sts	0x7a, r24
    5232:	e6 c0       	rjmp	.+460    	; 0x5400 <chb_set_state+0x646>
	else if (__tmp > 255)
    5234:	11 e0       	ldi	r17, 0x01	; 1
    5236:	6e a9       	sts	0x4e, r22
    5238:	7f a9       	sts	0x4f, r23
    523a:	88 ad       	sts	0x68, r24
    523c:	99 ad       	sts	0x69, r25
    523e:	20 e0       	ldi	r18, 0x00	; 0
    5240:	30 e0       	ldi	r19, 0x00	; 0
    5242:	4f e7       	ldi	r20, 0x7F	; 127
    5244:	53 e4       	ldi	r21, 0x43	; 67
    5246:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    524a:	18 16       	cp	r1, r24
    524c:	0c f0       	brlt	.+2      	; 0x5250 <chb_set_state+0x496>
    524e:	10 e0       	ldi	r17, 0x00	; 0
    5250:	11 23       	and	r17, r17
    5252:	09 f4       	brne	.+2      	; 0x5256 <chb_set_state+0x49c>
    5254:	cc c0       	rjmp	.+408    	; 0x53ee <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5256:	6a a9       	sts	0x4a, r22
    5258:	7b a9       	sts	0x4b, r23
    525a:	8c a9       	sts	0x4c, r24
    525c:	9d a9       	sts	0x4d, r25
    525e:	20 e0       	ldi	r18, 0x00	; 0
    5260:	30 e0       	ldi	r19, 0x00	; 0
    5262:	4a e7       	ldi	r20, 0x7A	; 122
    5264:	54 e4       	ldi	r21, 0x44	; 68
    5266:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    526a:	dc 01       	movw	r26, r24
    526c:	cb 01       	movw	r24, r22
    526e:	8b af       	sts	0x7b, r24
    5270:	9c af       	sts	0x7c, r25
    5272:	ad af       	sts	0x7d, r26
    5274:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5276:	8e 01       	movw	r16, r28
    5278:	01 5c       	subi	r16, 0xC1	; 193
    527a:	1f 4f       	sbci	r17, 0xFF	; 255
    527c:	6b ad       	sts	0x6b, r22
    527e:	7c ad       	sts	0x6c, r23
    5280:	8d ad       	sts	0x6d, r24
    5282:	9e ad       	sts	0x6e, r25
    5284:	20 e0       	ldi	r18, 0x00	; 0
    5286:	30 e0       	ldi	r19, 0x00	; 0
    5288:	4a ef       	ldi	r20, 0xFA	; 250
    528a:	55 e4       	ldi	r21, 0x45	; 69
    528c:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    5290:	dc 01       	movw	r26, r24
    5292:	cb 01       	movw	r24, r22
    5294:	f8 01       	movw	r30, r16
    5296:	80 83       	st	Z, r24
    5298:	91 83       	std	Z+1, r25	; 0x01
    529a:	a2 83       	std	Z+2, r26	; 0x02
    529c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    529e:	ce 01       	movw	r24, r28
    52a0:	cf 96       	adiw	r24, 0x3f	; 63
    52a2:	11 e0       	ldi	r17, 0x01	; 1
    52a4:	fc 01       	movw	r30, r24
    52a6:	60 81       	ld	r22, Z
    52a8:	71 81       	ldd	r23, Z+1	; 0x01
    52aa:	82 81       	ldd	r24, Z+2	; 0x02
    52ac:	93 81       	ldd	r25, Z+3	; 0x03
    52ae:	20 e0       	ldi	r18, 0x00	; 0
    52b0:	30 e0       	ldi	r19, 0x00	; 0
    52b2:	40 e8       	ldi	r20, 0x80	; 128
    52b4:	5f e3       	ldi	r21, 0x3F	; 63
    52b6:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    52ba:	88 23       	and	r24, r24
    52bc:	0c f0       	brlt	.+2      	; 0x52c0 <chb_set_state+0x506>
    52be:	10 e0       	ldi	r17, 0x00	; 0
    52c0:	11 23       	and	r17, r17
    52c2:	49 f0       	breq	.+18     	; 0x52d6 <chb_set_state+0x51c>
		__ticks = 1;
    52c4:	ce 01       	movw	r24, r28
    52c6:	8d 5b       	subi	r24, 0xBD	; 189
    52c8:	9f 4f       	sbci	r25, 0xFF	; 255
    52ca:	21 e0       	ldi	r18, 0x01	; 1
    52cc:	30 e0       	ldi	r19, 0x00	; 0
    52ce:	fc 01       	movw	r30, r24
    52d0:	20 83       	st	Z, r18
    52d2:	31 83       	std	Z+1, r19	; 0x01
    52d4:	6e c0       	rjmp	.+220    	; 0x53b2 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    52d6:	ce 01       	movw	r24, r28
    52d8:	cf 96       	adiw	r24, 0x3f	; 63
    52da:	11 e0       	ldi	r17, 0x01	; 1
    52dc:	fc 01       	movw	r30, r24
    52de:	60 81       	ld	r22, Z
    52e0:	71 81       	ldd	r23, Z+1	; 0x01
    52e2:	82 81       	ldd	r24, Z+2	; 0x02
    52e4:	93 81       	ldd	r25, Z+3	; 0x03
    52e6:	20 e0       	ldi	r18, 0x00	; 0
    52e8:	3f ef       	ldi	r19, 0xFF	; 255
    52ea:	4f e7       	ldi	r20, 0x7F	; 127
    52ec:	57 e4       	ldi	r21, 0x47	; 71
    52ee:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    52f2:	18 16       	cp	r1, r24
    52f4:	0c f0       	brlt	.+2      	; 0x52f8 <chb_set_state+0x53e>
    52f6:	10 e0       	ldi	r17, 0x00	; 0
    52f8:	11 23       	and	r17, r17
    52fa:	09 f4       	brne	.+2      	; 0x52fe <chb_set_state+0x544>
    52fc:	49 c0       	rjmp	.+146    	; 0x5390 <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    52fe:	6b ad       	sts	0x6b, r22
    5300:	7c ad       	sts	0x6c, r23
    5302:	8d ad       	sts	0x6d, r24
    5304:	9e ad       	sts	0x6e, r25
    5306:	20 e0       	ldi	r18, 0x00	; 0
    5308:	30 e0       	ldi	r19, 0x00	; 0
    530a:	40 e2       	ldi	r20, 0x20	; 32
    530c:	51 e4       	ldi	r21, 0x41	; 65
    530e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    5312:	dc 01       	movw	r26, r24
    5314:	cb 01       	movw	r24, r22
    5316:	8e 01       	movw	r16, r28
    5318:	0d 5b       	subi	r16, 0xBD	; 189
    531a:	1f 4f       	sbci	r17, 0xFF	; 255
    531c:	bc 01       	movw	r22, r24
    531e:	cd 01       	movw	r24, r26
    5320:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    5324:	dc 01       	movw	r26, r24
    5326:	cb 01       	movw	r24, r22
    5328:	f8 01       	movw	r30, r16
    532a:	80 83       	st	Z, r24
    532c:	91 83       	std	Z+1, r25	; 0x01
    532e:	27 c0       	rjmp	.+78     	; 0x537e <chb_set_state+0x5c4>
    5330:	ce 01       	movw	r24, r28
    5332:	8b 5b       	subi	r24, 0xBB	; 187
    5334:	9f 4f       	sbci	r25, 0xFF	; 255
    5336:	20 e2       	ldi	r18, 0x20	; 32
    5338:	33 e0       	ldi	r19, 0x03	; 3
    533a:	fc 01       	movw	r30, r24
    533c:	20 83       	st	Z, r18
    533e:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5340:	ce 01       	movw	r24, r28
    5342:	8b 5b       	subi	r24, 0xBB	; 187
    5344:	9f 4f       	sbci	r25, 0xFF	; 255
    5346:	fc 01       	movw	r30, r24
    5348:	80 81       	ld	r24, Z
    534a:	91 81       	ldd	r25, Z+1	; 0x01
    534c:	8c 01       	movw	r16, r24
    534e:	c8 01       	movw	r24, r16
    5350:	01 97       	sbiw	r24, 0x01	; 1
    5352:	f1 f7       	brne	.-4      	; 0x5350 <chb_set_state+0x596>
    5354:	8c 01       	movw	r16, r24
    5356:	ce 01       	movw	r24, r28
    5358:	8b 5b       	subi	r24, 0xBB	; 187
    535a:	9f 4f       	sbci	r25, 0xFF	; 255
    535c:	fc 01       	movw	r30, r24
    535e:	00 83       	st	Z, r16
    5360:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5362:	ce 01       	movw	r24, r28
    5364:	8d 5b       	subi	r24, 0xBD	; 189
    5366:	9f 4f       	sbci	r25, 0xFF	; 255
    5368:	9e 01       	movw	r18, r28
    536a:	2d 5b       	subi	r18, 0xBD	; 189
    536c:	3f 4f       	sbci	r19, 0xFF	; 255
    536e:	f9 01       	movw	r30, r18
    5370:	20 81       	ld	r18, Z
    5372:	31 81       	ldd	r19, Z+1	; 0x01
    5374:	21 50       	subi	r18, 0x01	; 1
    5376:	30 40       	sbci	r19, 0x00	; 0
    5378:	fc 01       	movw	r30, r24
    537a:	20 83       	st	Z, r18
    537c:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    537e:	ce 01       	movw	r24, r28
    5380:	8d 5b       	subi	r24, 0xBD	; 189
    5382:	9f 4f       	sbci	r25, 0xFF	; 255
    5384:	fc 01       	movw	r30, r24
    5386:	80 81       	ld	r24, Z
    5388:	91 81       	ldd	r25, Z+1	; 0x01
    538a:	00 97       	sbiw	r24, 0x00	; 0
    538c:	89 f6       	brne	.-94     	; 0x5330 <chb_set_state+0x576>
    538e:	4c c0       	rjmp	.+152    	; 0x5428 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5390:	8e 01       	movw	r16, r28
    5392:	0d 5b       	subi	r16, 0xBD	; 189
    5394:	1f 4f       	sbci	r17, 0xFF	; 255
    5396:	ce 01       	movw	r24, r28
    5398:	cf 96       	adiw	r24, 0x3f	; 63
    539a:	fc 01       	movw	r30, r24
    539c:	60 81       	ld	r22, Z
    539e:	71 81       	ldd	r23, Z+1	; 0x01
    53a0:	82 81       	ldd	r24, Z+2	; 0x02
    53a2:	93 81       	ldd	r25, Z+3	; 0x03
    53a4:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    53a8:	dc 01       	movw	r26, r24
    53aa:	cb 01       	movw	r24, r22
    53ac:	f8 01       	movw	r30, r16
    53ae:	80 83       	st	Z, r24
    53b0:	91 83       	std	Z+1, r25	; 0x01
    53b2:	ce 01       	movw	r24, r28
    53b4:	89 5b       	subi	r24, 0xB9	; 185
    53b6:	9f 4f       	sbci	r25, 0xFF	; 255
    53b8:	9e 01       	movw	r18, r28
    53ba:	2d 5b       	subi	r18, 0xBD	; 189
    53bc:	3f 4f       	sbci	r19, 0xFF	; 255
    53be:	f9 01       	movw	r30, r18
    53c0:	20 81       	ld	r18, Z
    53c2:	31 81       	ldd	r19, Z+1	; 0x01
    53c4:	fc 01       	movw	r30, r24
    53c6:	20 83       	st	Z, r18
    53c8:	31 83       	std	Z+1, r19	; 0x01
    53ca:	ce 01       	movw	r24, r28
    53cc:	89 5b       	subi	r24, 0xB9	; 185
    53ce:	9f 4f       	sbci	r25, 0xFF	; 255
    53d0:	fc 01       	movw	r30, r24
    53d2:	80 81       	ld	r24, Z
    53d4:	91 81       	ldd	r25, Z+1	; 0x01
    53d6:	8c 01       	movw	r16, r24
    53d8:	c8 01       	movw	r24, r16
    53da:	01 97       	sbiw	r24, 0x01	; 1
    53dc:	f1 f7       	brne	.-4      	; 0x53da <chb_set_state+0x620>
    53de:	8c 01       	movw	r16, r24
    53e0:	ce 01       	movw	r24, r28
    53e2:	89 5b       	subi	r24, 0xB9	; 185
    53e4:	9f 4f       	sbci	r25, 0xFF	; 255
    53e6:	fc 01       	movw	r30, r24
    53e8:	00 83       	st	Z, r16
    53ea:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    53ec:	20 c0       	rjmp	.+64     	; 0x542e <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    53ee:	6e a9       	sts	0x4e, r22
    53f0:	7f a9       	sts	0x4f, r23
    53f2:	88 ad       	sts	0x68, r24
    53f4:	99 ad       	sts	0x69, r25
    53f6:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    53fa:	dc 01       	movw	r26, r24
    53fc:	cb 01       	movw	r24, r22
    53fe:	8a af       	sts	0x7a, r24
    5400:	ce 01       	movw	r24, r28
    5402:	87 5b       	subi	r24, 0xB7	; 183
    5404:	9f 4f       	sbci	r25, 0xFF	; 255
    5406:	2a ad       	sts	0x6a, r18
    5408:	fc 01       	movw	r30, r24
    540a:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    540c:	ce 01       	movw	r24, r28
    540e:	87 5b       	subi	r24, 0xB7	; 183
    5410:	9f 4f       	sbci	r25, 0xFF	; 255
    5412:	fc 01       	movw	r30, r24
    5414:	80 81       	ld	r24, Z
    5416:	18 2f       	mov	r17, r24
    5418:	1a 95       	dec	r17
    541a:	f1 f7       	brne	.-4      	; 0x5418 <chb_set_state+0x65e>
    541c:	ce 01       	movw	r24, r28
    541e:	87 5b       	subi	r24, 0xB7	; 183
    5420:	9f 4f       	sbci	r25, 0xFF	; 255
    5422:	fc 01       	movw	r30, r24
    5424:	10 83       	st	Z, r17
    5426:	03 c0       	rjmp	.+6      	; 0x542e <chb_set_state+0x674>
    5428:	02 c0       	rjmp	.+4      	; 0x542e <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    542a:	00 00       	nop
    542c:	01 c0       	rjmp	.+2      	; 0x5430 <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    542e:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    5430:	9e 01       	movw	r18, r28
    5432:	2e 59       	subi	r18, 0x9E	; 158
    5434:	3f 4f       	sbci	r19, 0xFF	; 255
    5436:	82 e0       	ldi	r24, 0x02	; 2
    5438:	f9 01       	movw	r30, r18
    543a:	60 81       	ld	r22, Z
    543c:	4f e1       	ldi	r20, 0x1F	; 31
    543e:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
    5442:	9e 01       	movw	r18, r28
    5444:	26 5b       	subi	r18, 0xB6	; 182
    5446:	3f 4f       	sbci	r19, 0xFF	; 255
    5448:	80 e0       	ldi	r24, 0x00	; 0
    544a:	90 e0       	ldi	r25, 0x00	; 0
    544c:	ac ed       	ldi	r26, 0xDC	; 220
    544e:	b2 e4       	ldi	r27, 0x42	; 66
    5450:	f9 01       	movw	r30, r18
    5452:	80 83       	st	Z, r24
    5454:	91 83       	std	Z+1, r25	; 0x01
    5456:	a2 83       	std	Z+2, r26	; 0x02
    5458:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    545a:	8e 01       	movw	r16, r28
    545c:	02 5b       	subi	r16, 0xB2	; 178
    545e:	1f 4f       	sbci	r17, 0xFF	; 255
    5460:	ce 01       	movw	r24, r28
    5462:	86 5b       	subi	r24, 0xB6	; 182
    5464:	9f 4f       	sbci	r25, 0xFF	; 255
    5466:	fc 01       	movw	r30, r24
    5468:	60 81       	ld	r22, Z
    546a:	71 81       	ldd	r23, Z+1	; 0x01
    546c:	82 81       	ldd	r24, Z+2	; 0x02
    546e:	93 81       	ldd	r25, Z+3	; 0x03
    5470:	2b ea       	ldi	r18, 0xAB	; 171
    5472:	3a ea       	ldi	r19, 0xAA	; 170
    5474:	4a e2       	ldi	r20, 0x2A	; 42
    5476:	51 e4       	ldi	r21, 0x41	; 65
    5478:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    547c:	dc 01       	movw	r26, r24
    547e:	cb 01       	movw	r24, r22
    5480:	f8 01       	movw	r30, r16
    5482:	80 83       	st	Z, r24
    5484:	91 83       	std	Z+1, r25	; 0x01
    5486:	a2 83       	std	Z+2, r26	; 0x02
    5488:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    548a:	ce 01       	movw	r24, r28
    548c:	82 5b       	subi	r24, 0xB2	; 178
    548e:	9f 4f       	sbci	r25, 0xFF	; 255
    5490:	11 e0       	ldi	r17, 0x01	; 1
    5492:	fc 01       	movw	r30, r24
    5494:	60 81       	ld	r22, Z
    5496:	71 81       	ldd	r23, Z+1	; 0x01
    5498:	82 81       	ldd	r24, Z+2	; 0x02
    549a:	93 81       	ldd	r25, Z+3	; 0x03
    549c:	20 e0       	ldi	r18, 0x00	; 0
    549e:	30 e0       	ldi	r19, 0x00	; 0
    54a0:	40 e8       	ldi	r20, 0x80	; 128
    54a2:	5f e3       	ldi	r21, 0x3F	; 63
    54a4:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    54a8:	88 23       	and	r24, r24
    54aa:	0c f0       	brlt	.+2      	; 0x54ae <chb_set_state+0x6f4>
    54ac:	10 e0       	ldi	r17, 0x00	; 0
    54ae:	11 23       	and	r17, r17
    54b0:	39 f0       	breq	.+14     	; 0x54c0 <chb_set_state+0x706>
		__ticks = 1;
    54b2:	ce 01       	movw	r24, r28
    54b4:	8e 5a       	subi	r24, 0xAE	; 174
    54b6:	9f 4f       	sbci	r25, 0xFF	; 255
    54b8:	21 e0       	ldi	r18, 0x01	; 1
    54ba:	fc 01       	movw	r30, r24
    54bc:	20 83       	st	Z, r18
    54be:	05 c1       	rjmp	.+522    	; 0x56ca <chb_set_state+0x910>
	else if (__tmp > 255)
    54c0:	ce 01       	movw	r24, r28
    54c2:	82 5b       	subi	r24, 0xB2	; 178
    54c4:	9f 4f       	sbci	r25, 0xFF	; 255
    54c6:	11 e0       	ldi	r17, 0x01	; 1
    54c8:	fc 01       	movw	r30, r24
    54ca:	60 81       	ld	r22, Z
    54cc:	71 81       	ldd	r23, Z+1	; 0x01
    54ce:	82 81       	ldd	r24, Z+2	; 0x02
    54d0:	93 81       	ldd	r25, Z+3	; 0x03
    54d2:	20 e0       	ldi	r18, 0x00	; 0
    54d4:	30 e0       	ldi	r19, 0x00	; 0
    54d6:	4f e7       	ldi	r20, 0x7F	; 127
    54d8:	53 e4       	ldi	r21, 0x43	; 67
    54da:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    54de:	18 16       	cp	r1, r24
    54e0:	0c f0       	brlt	.+2      	; 0x54e4 <chb_set_state+0x72a>
    54e2:	10 e0       	ldi	r17, 0x00	; 0
    54e4:	11 23       	and	r17, r17
    54e6:	09 f4       	brne	.+2      	; 0x54ea <chb_set_state+0x730>
    54e8:	df c0       	rjmp	.+446    	; 0x56a8 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    54ea:	ce 01       	movw	r24, r28
    54ec:	86 5b       	subi	r24, 0xB6	; 182
    54ee:	9f 4f       	sbci	r25, 0xFF	; 255
    54f0:	fc 01       	movw	r30, r24
    54f2:	60 81       	ld	r22, Z
    54f4:	71 81       	ldd	r23, Z+1	; 0x01
    54f6:	82 81       	ldd	r24, Z+2	; 0x02
    54f8:	93 81       	ldd	r25, Z+3	; 0x03
    54fa:	20 e0       	ldi	r18, 0x00	; 0
    54fc:	30 e0       	ldi	r19, 0x00	; 0
    54fe:	4a e7       	ldi	r20, 0x7A	; 122
    5500:	54 e4       	ldi	r21, 0x44	; 68
    5502:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    5506:	dc 01       	movw	r26, r24
    5508:	cb 01       	movw	r24, r22
    550a:	9e 01       	movw	r18, r28
    550c:	2d 5a       	subi	r18, 0xAD	; 173
    550e:	3f 4f       	sbci	r19, 0xFF	; 255
    5510:	f9 01       	movw	r30, r18
    5512:	80 83       	st	Z, r24
    5514:	91 83       	std	Z+1, r25	; 0x01
    5516:	a2 83       	std	Z+2, r26	; 0x02
    5518:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    551a:	8e 01       	movw	r16, r28
    551c:	09 5a       	subi	r16, 0xA9	; 169
    551e:	1f 4f       	sbci	r17, 0xFF	; 255
    5520:	ce 01       	movw	r24, r28
    5522:	8d 5a       	subi	r24, 0xAD	; 173
    5524:	9f 4f       	sbci	r25, 0xFF	; 255
    5526:	fc 01       	movw	r30, r24
    5528:	60 81       	ld	r22, Z
    552a:	71 81       	ldd	r23, Z+1	; 0x01
    552c:	82 81       	ldd	r24, Z+2	; 0x02
    552e:	93 81       	ldd	r25, Z+3	; 0x03
    5530:	20 e0       	ldi	r18, 0x00	; 0
    5532:	30 e0       	ldi	r19, 0x00	; 0
    5534:	4a ef       	ldi	r20, 0xFA	; 250
    5536:	55 e4       	ldi	r21, 0x45	; 69
    5538:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    553c:	dc 01       	movw	r26, r24
    553e:	cb 01       	movw	r24, r22
    5540:	f8 01       	movw	r30, r16
    5542:	80 83       	st	Z, r24
    5544:	91 83       	std	Z+1, r25	; 0x01
    5546:	a2 83       	std	Z+2, r26	; 0x02
    5548:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    554a:	ce 01       	movw	r24, r28
    554c:	89 5a       	subi	r24, 0xA9	; 169
    554e:	9f 4f       	sbci	r25, 0xFF	; 255
    5550:	11 e0       	ldi	r17, 0x01	; 1
    5552:	fc 01       	movw	r30, r24
    5554:	60 81       	ld	r22, Z
    5556:	71 81       	ldd	r23, Z+1	; 0x01
    5558:	82 81       	ldd	r24, Z+2	; 0x02
    555a:	93 81       	ldd	r25, Z+3	; 0x03
    555c:	20 e0       	ldi	r18, 0x00	; 0
    555e:	30 e0       	ldi	r19, 0x00	; 0
    5560:	40 e8       	ldi	r20, 0x80	; 128
    5562:	5f e3       	ldi	r21, 0x3F	; 63
    5564:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    5568:	88 23       	and	r24, r24
    556a:	0c f0       	brlt	.+2      	; 0x556e <chb_set_state+0x7b4>
    556c:	10 e0       	ldi	r17, 0x00	; 0
    556e:	11 23       	and	r17, r17
    5570:	49 f0       	breq	.+18     	; 0x5584 <chb_set_state+0x7ca>
		__ticks = 1;
    5572:	ce 01       	movw	r24, r28
    5574:	85 5a       	subi	r24, 0xA5	; 165
    5576:	9f 4f       	sbci	r25, 0xFF	; 255
    5578:	21 e0       	ldi	r18, 0x01	; 1
    557a:	30 e0       	ldi	r19, 0x00	; 0
    557c:	fc 01       	movw	r30, r24
    557e:	20 83       	st	Z, r18
    5580:	31 83       	std	Z+1, r19	; 0x01
    5582:	74 c0       	rjmp	.+232    	; 0x566c <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    5584:	ce 01       	movw	r24, r28
    5586:	89 5a       	subi	r24, 0xA9	; 169
    5588:	9f 4f       	sbci	r25, 0xFF	; 255
    558a:	11 e0       	ldi	r17, 0x01	; 1
    558c:	fc 01       	movw	r30, r24
    558e:	60 81       	ld	r22, Z
    5590:	71 81       	ldd	r23, Z+1	; 0x01
    5592:	82 81       	ldd	r24, Z+2	; 0x02
    5594:	93 81       	ldd	r25, Z+3	; 0x03
    5596:	20 e0       	ldi	r18, 0x00	; 0
    5598:	3f ef       	ldi	r19, 0xFF	; 255
    559a:	4f e7       	ldi	r20, 0x7F	; 127
    559c:	57 e4       	ldi	r21, 0x47	; 71
    559e:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    55a2:	18 16       	cp	r1, r24
    55a4:	0c f0       	brlt	.+2      	; 0x55a8 <chb_set_state+0x7ee>
    55a6:	10 e0       	ldi	r17, 0x00	; 0
    55a8:	11 23       	and	r17, r17
    55aa:	09 f4       	brne	.+2      	; 0x55ae <chb_set_state+0x7f4>
    55ac:	4d c0       	rjmp	.+154    	; 0x5648 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    55ae:	ce 01       	movw	r24, r28
    55b0:	8d 5a       	subi	r24, 0xAD	; 173
    55b2:	9f 4f       	sbci	r25, 0xFF	; 255
    55b4:	fc 01       	movw	r30, r24
    55b6:	60 81       	ld	r22, Z
    55b8:	71 81       	ldd	r23, Z+1	; 0x01
    55ba:	82 81       	ldd	r24, Z+2	; 0x02
    55bc:	93 81       	ldd	r25, Z+3	; 0x03
    55be:	20 e0       	ldi	r18, 0x00	; 0
    55c0:	30 e0       	ldi	r19, 0x00	; 0
    55c2:	40 e2       	ldi	r20, 0x20	; 32
    55c4:	51 e4       	ldi	r21, 0x41	; 65
    55c6:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    55ca:	dc 01       	movw	r26, r24
    55cc:	cb 01       	movw	r24, r22
    55ce:	8e 01       	movw	r16, r28
    55d0:	05 5a       	subi	r16, 0xA5	; 165
    55d2:	1f 4f       	sbci	r17, 0xFF	; 255
    55d4:	bc 01       	movw	r22, r24
    55d6:	cd 01       	movw	r24, r26
    55d8:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    55dc:	dc 01       	movw	r26, r24
    55de:	cb 01       	movw	r24, r22
    55e0:	f8 01       	movw	r30, r16
    55e2:	80 83       	st	Z, r24
    55e4:	91 83       	std	Z+1, r25	; 0x01
    55e6:	27 c0       	rjmp	.+78     	; 0x5636 <chb_set_state+0x87c>
    55e8:	ce 01       	movw	r24, r28
    55ea:	83 5a       	subi	r24, 0xA3	; 163
    55ec:	9f 4f       	sbci	r25, 0xFF	; 255
    55ee:	20 e2       	ldi	r18, 0x20	; 32
    55f0:	33 e0       	ldi	r19, 0x03	; 3
    55f2:	fc 01       	movw	r30, r24
    55f4:	20 83       	st	Z, r18
    55f6:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    55f8:	ce 01       	movw	r24, r28
    55fa:	83 5a       	subi	r24, 0xA3	; 163
    55fc:	9f 4f       	sbci	r25, 0xFF	; 255
    55fe:	fc 01       	movw	r30, r24
    5600:	80 81       	ld	r24, Z
    5602:	91 81       	ldd	r25, Z+1	; 0x01
    5604:	8c 01       	movw	r16, r24
    5606:	c8 01       	movw	r24, r16
    5608:	01 97       	sbiw	r24, 0x01	; 1
    560a:	f1 f7       	brne	.-4      	; 0x5608 <chb_set_state+0x84e>
    560c:	8c 01       	movw	r16, r24
    560e:	ce 01       	movw	r24, r28
    5610:	83 5a       	subi	r24, 0xA3	; 163
    5612:	9f 4f       	sbci	r25, 0xFF	; 255
    5614:	fc 01       	movw	r30, r24
    5616:	00 83       	st	Z, r16
    5618:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    561a:	ce 01       	movw	r24, r28
    561c:	85 5a       	subi	r24, 0xA5	; 165
    561e:	9f 4f       	sbci	r25, 0xFF	; 255
    5620:	9e 01       	movw	r18, r28
    5622:	25 5a       	subi	r18, 0xA5	; 165
    5624:	3f 4f       	sbci	r19, 0xFF	; 255
    5626:	f9 01       	movw	r30, r18
    5628:	20 81       	ld	r18, Z
    562a:	31 81       	ldd	r19, Z+1	; 0x01
    562c:	21 50       	subi	r18, 0x01	; 1
    562e:	30 40       	sbci	r19, 0x00	; 0
    5630:	fc 01       	movw	r30, r24
    5632:	20 83       	st	Z, r18
    5634:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5636:	ce 01       	movw	r24, r28
    5638:	85 5a       	subi	r24, 0xA5	; 165
    563a:	9f 4f       	sbci	r25, 0xFF	; 255
    563c:	fc 01       	movw	r30, r24
    563e:	80 81       	ld	r24, Z
    5640:	91 81       	ldd	r25, Z+1	; 0x01
    5642:	00 97       	sbiw	r24, 0x00	; 0
    5644:	89 f6       	brne	.-94     	; 0x55e8 <chb_set_state+0x82e>
    5646:	58 c0       	rjmp	.+176    	; 0x56f8 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5648:	8e 01       	movw	r16, r28
    564a:	05 5a       	subi	r16, 0xA5	; 165
    564c:	1f 4f       	sbci	r17, 0xFF	; 255
    564e:	ce 01       	movw	r24, r28
    5650:	89 5a       	subi	r24, 0xA9	; 169
    5652:	9f 4f       	sbci	r25, 0xFF	; 255
    5654:	fc 01       	movw	r30, r24
    5656:	60 81       	ld	r22, Z
    5658:	71 81       	ldd	r23, Z+1	; 0x01
    565a:	82 81       	ldd	r24, Z+2	; 0x02
    565c:	93 81       	ldd	r25, Z+3	; 0x03
    565e:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    5662:	dc 01       	movw	r26, r24
    5664:	cb 01       	movw	r24, r22
    5666:	f8 01       	movw	r30, r16
    5668:	80 83       	st	Z, r24
    566a:	91 83       	std	Z+1, r25	; 0x01
    566c:	ce 01       	movw	r24, r28
    566e:	81 5a       	subi	r24, 0xA1	; 161
    5670:	9f 4f       	sbci	r25, 0xFF	; 255
    5672:	9e 01       	movw	r18, r28
    5674:	25 5a       	subi	r18, 0xA5	; 165
    5676:	3f 4f       	sbci	r19, 0xFF	; 255
    5678:	f9 01       	movw	r30, r18
    567a:	20 81       	ld	r18, Z
    567c:	31 81       	ldd	r19, Z+1	; 0x01
    567e:	fc 01       	movw	r30, r24
    5680:	20 83       	st	Z, r18
    5682:	31 83       	std	Z+1, r19	; 0x01
    5684:	ce 01       	movw	r24, r28
    5686:	81 5a       	subi	r24, 0xA1	; 161
    5688:	9f 4f       	sbci	r25, 0xFF	; 255
    568a:	fc 01       	movw	r30, r24
    568c:	80 81       	ld	r24, Z
    568e:	91 81       	ldd	r25, Z+1	; 0x01
    5690:	8c 01       	movw	r16, r24
    5692:	c8 01       	movw	r24, r16
    5694:	01 97       	sbiw	r24, 0x01	; 1
    5696:	f1 f7       	brne	.-4      	; 0x5694 <chb_set_state+0x8da>
    5698:	8c 01       	movw	r16, r24
    569a:	ce 01       	movw	r24, r28
    569c:	81 5a       	subi	r24, 0xA1	; 161
    569e:	9f 4f       	sbci	r25, 0xFF	; 255
    56a0:	fc 01       	movw	r30, r24
    56a2:	00 83       	st	Z, r16
    56a4:	11 83       	std	Z+1, r17	; 0x01
    56a6:	28 c0       	rjmp	.+80     	; 0x56f8 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    56a8:	8e 01       	movw	r16, r28
    56aa:	0e 5a       	subi	r16, 0xAE	; 174
    56ac:	1f 4f       	sbci	r17, 0xFF	; 255
    56ae:	ce 01       	movw	r24, r28
    56b0:	82 5b       	subi	r24, 0xB2	; 178
    56b2:	9f 4f       	sbci	r25, 0xFF	; 255
    56b4:	fc 01       	movw	r30, r24
    56b6:	60 81       	ld	r22, Z
    56b8:	71 81       	ldd	r23, Z+1	; 0x01
    56ba:	82 81       	ldd	r24, Z+2	; 0x02
    56bc:	93 81       	ldd	r25, Z+3	; 0x03
    56be:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    56c2:	dc 01       	movw	r26, r24
    56c4:	cb 01       	movw	r24, r22
    56c6:	f8 01       	movw	r30, r16
    56c8:	80 83       	st	Z, r24
    56ca:	ce 01       	movw	r24, r28
    56cc:	8f 59       	subi	r24, 0x9F	; 159
    56ce:	9f 4f       	sbci	r25, 0xFF	; 255
    56d0:	9e 01       	movw	r18, r28
    56d2:	2e 5a       	subi	r18, 0xAE	; 174
    56d4:	3f 4f       	sbci	r19, 0xFF	; 255
    56d6:	f9 01       	movw	r30, r18
    56d8:	20 81       	ld	r18, Z
    56da:	fc 01       	movw	r30, r24
    56dc:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    56de:	ce 01       	movw	r24, r28
    56e0:	8f 59       	subi	r24, 0x9F	; 159
    56e2:	9f 4f       	sbci	r25, 0xFF	; 255
    56e4:	fc 01       	movw	r30, r24
    56e6:	80 81       	ld	r24, Z
    56e8:	18 2f       	mov	r17, r24
    56ea:	1a 95       	dec	r17
    56ec:	f1 f7       	brne	.-4      	; 0x56ea <chb_set_state+0x930>
    56ee:	ce 01       	movw	r24, r28
    56f0:	8f 59       	subi	r24, 0x9F	; 159
    56f2:	9f 4f       	sbci	r25, 0xFF	; 255
    56f4:	fc 01       	movw	r30, r24
    56f6:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    56f8:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <chb_get_state>
    56fc:	28 2f       	mov	r18, r24
    56fe:	ce 01       	movw	r24, r28
    5700:	8e 59       	subi	r24, 0x9E	; 158
    5702:	9f 4f       	sbci	r25, 0xFF	; 255
    5704:	fc 01       	movw	r30, r24
    5706:	80 81       	ld	r24, Z
    5708:	28 17       	cp	r18, r24
    570a:	11 f4       	brne	.+4      	; 0x5710 <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    570c:	80 e4       	ldi	r24, 0x40	; 64
    570e:	01 c0       	rjmp	.+2      	; 0x5712 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    5710:	83 e4       	ldi	r24, 0x43	; 67
}
    5712:	ce 59       	subi	r28, 0x9E	; 158
    5714:	df 4f       	sbci	r29, 0xFF	; 255
    5716:	cd bf       	out	0x3d, r28	; 61
    5718:	de bf       	out	0x3e, r29	; 62
    571a:	df 91       	pop	r29
    571c:	cf 91       	pop	r28
    571e:	1f 91       	pop	r17
    5720:	0f 91       	pop	r16
    5722:	08 95       	ret

00005724 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5724:	cf 93       	push	r28
    5726:	df 93       	push	r29
    5728:	0f 92       	push	r0
    572a:	0f 92       	push	r0
    572c:	cd b7       	in	r28, 0x3d	; 61
    572e:	de b7       	in	r29, 0x3e	; 62
    5730:	89 83       	std	Y+1, r24	; 0x01
    5732:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5734:	29 81       	ldd	r18, Y+1	; 0x01
    5736:	3a 81       	ldd	r19, Y+2	; 0x02
    5738:	80 e0       	ldi	r24, 0x00	; 0
    573a:	90 e0       	ldi	r25, 0x00	; 0
    573c:	b9 01       	movw	r22, r18
    573e:	48 e0       	ldi	r20, 0x08	; 8
    5740:	50 e0       	ldi	r21, 0x00	; 0
    5742:	0e 94 ab 2f 	call	0x5f56	; 0x5f56 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5746:	29 81       	ldd	r18, Y+1	; 0x01
    5748:	3a 81       	ldd	r19, Y+2	; 0x02
    574a:	84 e2       	ldi	r24, 0x24	; 36
    574c:	b9 01       	movw	r22, r18
    574e:	0e 94 3a 24 	call	0x4874	; 0x4874 <chb_reg_write64>
}
    5752:	0f 90       	pop	r0
    5754:	0f 90       	pop	r0
    5756:	df 91       	pop	r29
    5758:	cf 91       	pop	r28
    575a:	08 95       	ret

0000575c <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    575c:	cf 93       	push	r28
    575e:	df 93       	push	r29
    5760:	0f 92       	push	r0
    5762:	0f 92       	push	r0
    5764:	cd b7       	in	r28, 0x3d	; 61
    5766:	de b7       	in	r29, 0x3e	; 62
    5768:	89 83       	std	Y+1, r24	; 0x01
    576a:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    576c:	29 81       	ldd	r18, Y+1	; 0x01
    576e:	3a 81       	ldd	r19, Y+2	; 0x02
    5770:	80 e0       	ldi	r24, 0x00	; 0
    5772:	90 e0       	ldi	r25, 0x00	; 0
    5774:	b9 01       	movw	r22, r18
    5776:	48 e0       	ldi	r20, 0x08	; 8
    5778:	50 e0       	ldi	r21, 0x00	; 0
    577a:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <chb_eeprom_read>
}
    577e:	0f 90       	pop	r0
    5780:	0f 90       	pop	r0
    5782:	df 91       	pop	r29
    5784:	cf 91       	pop	r28
    5786:	08 95       	ret

00005788 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5788:	cf 93       	push	r28
    578a:	df 93       	push	r29
    578c:	00 d0       	rcall	.+0      	; 0x578e <chb_set_short_addr+0x6>
    578e:	00 d0       	rcall	.+0      	; 0x5790 <chb_set_short_addr+0x8>
    5790:	cd b7       	in	r28, 0x3d	; 61
    5792:	de b7       	in	r29, 0x3e	; 62
    5794:	8d 83       	std	Y+5, r24	; 0x05
    5796:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5798:	ce 01       	movw	r24, r28
    579a:	05 96       	adiw	r24, 0x05	; 5
    579c:	89 83       	std	Y+1, r24	; 0x01
    579e:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    57a0:	0e 94 73 1e 	call	0x3ce6	; 0x3ce6 <chb_get_pcb>
    57a4:	8b 83       	std	Y+3, r24	; 0x03
    57a6:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    57a8:	29 81       	ldd	r18, Y+1	; 0x01
    57aa:	3a 81       	ldd	r19, Y+2	; 0x02
    57ac:	89 e0       	ldi	r24, 0x09	; 9
    57ae:	90 e0       	ldi	r25, 0x00	; 0
    57b0:	b9 01       	movw	r22, r18
    57b2:	42 e0       	ldi	r20, 0x02	; 2
    57b4:	50 e0       	ldi	r21, 0x00	; 0
    57b6:	0e 94 ab 2f 	call	0x5f56	; 0x5f56 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    57ba:	2d 81       	ldd	r18, Y+5	; 0x05
    57bc:	3e 81       	ldd	r19, Y+6	; 0x06
    57be:	80 e2       	ldi	r24, 0x20	; 32
    57c0:	b9 01       	movw	r22, r18
    57c2:	0e 94 09 24 	call	0x4812	; 0x4812 <chb_reg_write16>
    pcb->src_addr = addr;
    57c6:	2d 81       	ldd	r18, Y+5	; 0x05
    57c8:	3e 81       	ldd	r19, Y+6	; 0x06
    57ca:	8b 81       	ldd	r24, Y+3	; 0x03
    57cc:	9c 81       	ldd	r25, Y+4	; 0x04
    57ce:	fc 01       	movw	r30, r24
    57d0:	20 83       	st	Z, r18
    57d2:	31 83       	std	Z+1, r19	; 0x01
}
    57d4:	26 96       	adiw	r28, 0x06	; 6
    57d6:	cd bf       	out	0x3d, r28	; 61
    57d8:	de bf       	out	0x3e, r29	; 62
    57da:	df 91       	pop	r29
    57dc:	cf 91       	pop	r28
    57de:	08 95       	ret

000057e0 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    57e0:	cf 93       	push	r28
    57e2:	df 93       	push	r29
    57e4:	0f 92       	push	r0
    57e6:	0f 92       	push	r0
    57e8:	cd b7       	in	r28, 0x3d	; 61
    57ea:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    57ec:	89 e0       	ldi	r24, 0x09	; 9
    57ee:	90 e0       	ldi	r25, 0x00	; 0
    57f0:	9e 01       	movw	r18, r28
    57f2:	2f 5f       	subi	r18, 0xFF	; 255
    57f4:	3f 4f       	sbci	r19, 0xFF	; 255
    57f6:	b9 01       	movw	r22, r18
    57f8:	42 e0       	ldi	r20, 0x02	; 2
    57fa:	50 e0       	ldi	r21, 0x00	; 0
    57fc:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <chb_eeprom_read>
    return *(U16 *)addr;
    5800:	ce 01       	movw	r24, r28
    5802:	01 96       	adiw	r24, 0x01	; 1
    5804:	fc 01       	movw	r30, r24
    5806:	80 81       	ld	r24, Z
    5808:	91 81       	ldd	r25, Z+1	; 0x01
}
    580a:	0f 90       	pop	r0
    580c:	0f 90       	pop	r0
    580e:	df 91       	pop	r29
    5810:	cf 91       	pop	r28
    5812:	08 95       	ret

00005814 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5814:	cf 93       	push	r28
    5816:	df 93       	push	r29
    5818:	cd b7       	in	r28, 0x3d	; 61
    581a:	de b7       	in	r29, 0x3e	; 62
    581c:	28 97       	sbiw	r28, 0x08	; 8
    581e:	cd bf       	out	0x3d, r28	; 61
    5820:	de bf       	out	0x3e, r29	; 62
    5822:	8c 83       	std	Y+4, r24	; 0x04
    5824:	9d 83       	std	Y+5, r25	; 0x05
    5826:	6e 83       	std	Y+6, r22	; 0x06
    5828:	7f 83       	std	Y+7, r23	; 0x07
    582a:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    582c:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <chb_get_state>
    5830:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5832:	0e 94 73 1e 	call	0x3ce6	; 0x3ce6 <chb_get_pcb>
    5836:	8a 83       	std	Y+2, r24	; 0x02
    5838:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    583a:	89 81       	ldd	r24, Y+1	; 0x01
    583c:	82 30       	cpi	r24, 0x02	; 2
    583e:	19 f0       	breq	.+6      	; 0x5846 <chb_tx+0x32>
    5840:	89 81       	ldd	r24, Y+1	; 0x01
    5842:	82 31       	cpi	r24, 0x12	; 18
    5844:	11 f4       	brne	.+4      	; 0x584a <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5846:	84 e4       	ldi	r24, 0x44	; 68
    5848:	23 c0       	rjmp	.+70     	; 0x5890 <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    584a:	88 e0       	ldi	r24, 0x08	; 8
    584c:	0e 94 dd 26 	call	0x4dba	; 0x4dba <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    5850:	89 e1       	ldi	r24, 0x19	; 25
    5852:	0e 94 dd 26 	call	0x4dba	; 0x4dba <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5856:	8c 81       	ldd	r24, Y+4	; 0x04
    5858:	9d 81       	ldd	r25, Y+5	; 0x05
    585a:	2e 81       	ldd	r18, Y+6	; 0x06
    585c:	3f 81       	ldd	r19, Y+7	; 0x07
    585e:	6a e0       	ldi	r22, 0x0A	; 10
    5860:	a9 01       	movw	r20, r18
    5862:	28 85       	ldd	r18, Y+8	; 0x08
    5864:	0e 94 87 24 	call	0x490e	; 0x490e <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5868:	82 e0       	ldi	r24, 0x02	; 2
    586a:	62 e0       	ldi	r22, 0x02	; 2
    586c:	4f e1       	ldi	r20, 0x1F	; 31
    586e:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    5872:	00 00       	nop
    5874:	8a 81       	ldd	r24, Y+2	; 0x02
    5876:	9b 81       	ldd	r25, Y+3	; 0x03
    5878:	fc 01       	movw	r30, r24
    587a:	94 81       	ldd	r25, Z+4	; 0x04
    587c:	81 e0       	ldi	r24, 0x01	; 1
    587e:	89 27       	eor	r24, r25
    5880:	88 23       	and	r24, r24
    5882:	c1 f7       	brne	.-16     	; 0x5874 <chb_tx+0x60>
    pcb->tx_end = false;
    5884:	8a 81       	ldd	r24, Y+2	; 0x02
    5886:	9b 81       	ldd	r25, Y+3	; 0x03
    5888:	fc 01       	movw	r30, r24
    588a:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    588c:	0e 94 86 21 	call	0x430c	; 0x430c <chb_get_status>
}
    5890:	28 96       	adiw	r28, 0x08	; 8
    5892:	cd bf       	out	0x3d, r28	; 61
    5894:	de bf       	out	0x3e, r29	; 62
    5896:	df 91       	pop	r29
    5898:	cf 91       	pop	r28
    589a:	08 95       	ret

0000589c <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    589c:	0f 93       	push	r16
    589e:	1f 93       	push	r17
    58a0:	cf 93       	push	r28
    58a2:	df 93       	push	r29
    58a4:	cd b7       	in	r28, 0x3d	; 61
    58a6:	de b7       	in	r29, 0x3e	; 62
    58a8:	69 97       	sbiw	r28, 0x19	; 25
    58aa:	cd bf       	out	0x3d, r28	; 61
    58ac:	de bf       	out	0x3e, r29	; 62
    58ae:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    58b0:	89 8d       	ldd	r24, Y+25	; 0x19
    58b2:	88 23       	and	r24, r24
    58b4:	69 f0       	breq	.+26     	; 0x58d0 <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    58b6:	88 e0       	ldi	r24, 0x08	; 8
    58b8:	0e 94 dd 26 	call	0x4dba	; 0x4dba <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    58bc:	84 e6       	ldi	r24, 0x64	; 100
    58be:	96 e0       	ldi	r25, 0x06	; 6
    58c0:	24 e6       	ldi	r18, 0x64	; 100
    58c2:	36 e0       	ldi	r19, 0x06	; 6
    58c4:	f9 01       	movw	r30, r18
    58c6:	20 81       	ld	r18, Z
    58c8:	22 60       	ori	r18, 0x02	; 2
    58ca:	fc 01       	movw	r30, r24
    58cc:	20 83       	st	Z, r18
    58ce:	e1 c0       	rjmp	.+450    	; 0x5a92 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    58d0:	84 e6       	ldi	r24, 0x64	; 100
    58d2:	96 e0       	ldi	r25, 0x06	; 6
    58d4:	24 e6       	ldi	r18, 0x64	; 100
    58d6:	36 e0       	ldi	r19, 0x06	; 6
    58d8:	f9 01       	movw	r30, r18
    58da:	20 81       	ld	r18, Z
    58dc:	2d 7f       	andi	r18, 0xFD	; 253
    58de:	fc 01       	movw	r30, r24
    58e0:	20 83       	st	Z, r18
    58e2:	80 e0       	ldi	r24, 0x00	; 0
    58e4:	90 e0       	ldi	r25, 0x00	; 0
    58e6:	a0 e7       	ldi	r26, 0x70	; 112
    58e8:	b3 e4       	ldi	r27, 0x43	; 67
    58ea:	89 83       	std	Y+1, r24	; 0x01
    58ec:	9a 83       	std	Y+2, r25	; 0x02
    58ee:	ab 83       	std	Y+3, r26	; 0x03
    58f0:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    58f2:	69 81       	ldd	r22, Y+1	; 0x01
    58f4:	7a 81       	ldd	r23, Y+2	; 0x02
    58f6:	8b 81       	ldd	r24, Y+3	; 0x03
    58f8:	9c 81       	ldd	r25, Y+4	; 0x04
    58fa:	2b ea       	ldi	r18, 0xAB	; 171
    58fc:	3a ea       	ldi	r19, 0xAA	; 170
    58fe:	4a e2       	ldi	r20, 0x2A	; 42
    5900:	51 e4       	ldi	r21, 0x41	; 65
    5902:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    5906:	dc 01       	movw	r26, r24
    5908:	cb 01       	movw	r24, r22
    590a:	8d 83       	std	Y+5, r24	; 0x05
    590c:	9e 83       	std	Y+6, r25	; 0x06
    590e:	af 83       	std	Y+7, r26	; 0x07
    5910:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5912:	11 e0       	ldi	r17, 0x01	; 1
    5914:	6d 81       	ldd	r22, Y+5	; 0x05
    5916:	7e 81       	ldd	r23, Y+6	; 0x06
    5918:	8f 81       	ldd	r24, Y+7	; 0x07
    591a:	98 85       	ldd	r25, Y+8	; 0x08
    591c:	20 e0       	ldi	r18, 0x00	; 0
    591e:	30 e0       	ldi	r19, 0x00	; 0
    5920:	40 e8       	ldi	r20, 0x80	; 128
    5922:	5f e3       	ldi	r21, 0x3F	; 63
    5924:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    5928:	88 23       	and	r24, r24
    592a:	0c f0       	brlt	.+2      	; 0x592e <chb_sleep+0x92>
    592c:	10 e0       	ldi	r17, 0x00	; 0
    592e:	11 23       	and	r17, r17
    5930:	19 f0       	breq	.+6      	; 0x5938 <chb_sleep+0x9c>
		__ticks = 1;
    5932:	81 e0       	ldi	r24, 0x01	; 1
    5934:	89 87       	std	Y+9, r24	; 0x09
    5936:	a3 c0       	rjmp	.+326    	; 0x5a7e <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5938:	11 e0       	ldi	r17, 0x01	; 1
    593a:	6d 81       	ldd	r22, Y+5	; 0x05
    593c:	7e 81       	ldd	r23, Y+6	; 0x06
    593e:	8f 81       	ldd	r24, Y+7	; 0x07
    5940:	98 85       	ldd	r25, Y+8	; 0x08
    5942:	20 e0       	ldi	r18, 0x00	; 0
    5944:	30 e0       	ldi	r19, 0x00	; 0
    5946:	4f e7       	ldi	r20, 0x7F	; 127
    5948:	53 e4       	ldi	r21, 0x43	; 67
    594a:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    594e:	18 16       	cp	r1, r24
    5950:	0c f0       	brlt	.+2      	; 0x5954 <chb_sleep+0xb8>
    5952:	10 e0       	ldi	r17, 0x00	; 0
    5954:	11 23       	and	r17, r17
    5956:	09 f4       	brne	.+2      	; 0x595a <chb_sleep+0xbe>
    5958:	89 c0       	rjmp	.+274    	; 0x5a6c <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    595a:	69 81       	ldd	r22, Y+1	; 0x01
    595c:	7a 81       	ldd	r23, Y+2	; 0x02
    595e:	8b 81       	ldd	r24, Y+3	; 0x03
    5960:	9c 81       	ldd	r25, Y+4	; 0x04
    5962:	20 e0       	ldi	r18, 0x00	; 0
    5964:	30 e0       	ldi	r19, 0x00	; 0
    5966:	4a e7       	ldi	r20, 0x7A	; 122
    5968:	54 e4       	ldi	r21, 0x44	; 68
    596a:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    596e:	dc 01       	movw	r26, r24
    5970:	cb 01       	movw	r24, r22
    5972:	8a 87       	std	Y+10, r24	; 0x0a
    5974:	9b 87       	std	Y+11, r25	; 0x0b
    5976:	ac 87       	std	Y+12, r26	; 0x0c
    5978:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    597a:	6a 85       	ldd	r22, Y+10	; 0x0a
    597c:	7b 85       	ldd	r23, Y+11	; 0x0b
    597e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5980:	9d 85       	ldd	r25, Y+13	; 0x0d
    5982:	20 e0       	ldi	r18, 0x00	; 0
    5984:	30 e0       	ldi	r19, 0x00	; 0
    5986:	4a ef       	ldi	r20, 0xFA	; 250
    5988:	55 e4       	ldi	r21, 0x45	; 69
    598a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    598e:	dc 01       	movw	r26, r24
    5990:	cb 01       	movw	r24, r22
    5992:	8e 87       	std	Y+14, r24	; 0x0e
    5994:	9f 87       	std	Y+15, r25	; 0x0f
    5996:	a8 8b       	std	Y+16, r26	; 0x10
    5998:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    599a:	11 e0       	ldi	r17, 0x01	; 1
    599c:	6e 85       	ldd	r22, Y+14	; 0x0e
    599e:	7f 85       	ldd	r23, Y+15	; 0x0f
    59a0:	88 89       	ldd	r24, Y+16	; 0x10
    59a2:	99 89       	ldd	r25, Y+17	; 0x11
    59a4:	20 e0       	ldi	r18, 0x00	; 0
    59a6:	30 e0       	ldi	r19, 0x00	; 0
    59a8:	40 e8       	ldi	r20, 0x80	; 128
    59aa:	5f e3       	ldi	r21, 0x3F	; 63
    59ac:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    59b0:	88 23       	and	r24, r24
    59b2:	0c f0       	brlt	.+2      	; 0x59b6 <chb_sleep+0x11a>
    59b4:	10 e0       	ldi	r17, 0x00	; 0
    59b6:	11 23       	and	r17, r17
    59b8:	29 f0       	breq	.+10     	; 0x59c4 <chb_sleep+0x128>
		__ticks = 1;
    59ba:	81 e0       	ldi	r24, 0x01	; 1
    59bc:	90 e0       	ldi	r25, 0x00	; 0
    59be:	8a 8b       	std	Y+18, r24	; 0x12
    59c0:	9b 8b       	std	Y+19, r25	; 0x13
    59c2:	46 c0       	rjmp	.+140    	; 0x5a50 <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    59c4:	11 e0       	ldi	r17, 0x01	; 1
    59c6:	6e 85       	ldd	r22, Y+14	; 0x0e
    59c8:	7f 85       	ldd	r23, Y+15	; 0x0f
    59ca:	88 89       	ldd	r24, Y+16	; 0x10
    59cc:	99 89       	ldd	r25, Y+17	; 0x11
    59ce:	20 e0       	ldi	r18, 0x00	; 0
    59d0:	3f ef       	ldi	r19, 0xFF	; 255
    59d2:	4f e7       	ldi	r20, 0x7F	; 127
    59d4:	57 e4       	ldi	r21, 0x47	; 71
    59d6:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    59da:	18 16       	cp	r1, r24
    59dc:	0c f0       	brlt	.+2      	; 0x59e0 <chb_sleep+0x144>
    59de:	10 e0       	ldi	r17, 0x00	; 0
    59e0:	11 23       	and	r17, r17
    59e2:	61 f1       	breq	.+88     	; 0x5a3c <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    59e4:	6a 85       	ldd	r22, Y+10	; 0x0a
    59e6:	7b 85       	ldd	r23, Y+11	; 0x0b
    59e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    59ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    59ec:	20 e0       	ldi	r18, 0x00	; 0
    59ee:	30 e0       	ldi	r19, 0x00	; 0
    59f0:	40 e2       	ldi	r20, 0x20	; 32
    59f2:	51 e4       	ldi	r21, 0x41	; 65
    59f4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    59f8:	dc 01       	movw	r26, r24
    59fa:	cb 01       	movw	r24, r22
    59fc:	bc 01       	movw	r22, r24
    59fe:	cd 01       	movw	r24, r26
    5a00:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    5a04:	dc 01       	movw	r26, r24
    5a06:	cb 01       	movw	r24, r22
    5a08:	8a 8b       	std	Y+18, r24	; 0x12
    5a0a:	9b 8b       	std	Y+19, r25	; 0x13
    5a0c:	12 c0       	rjmp	.+36     	; 0x5a32 <chb_sleep+0x196>
    5a0e:	80 e2       	ldi	r24, 0x20	; 32
    5a10:	93 e0       	ldi	r25, 0x03	; 3
    5a12:	8c 8b       	std	Y+20, r24	; 0x14
    5a14:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5a16:	8c 89       	ldd	r24, Y+20	; 0x14
    5a18:	9d 89       	ldd	r25, Y+21	; 0x15
    5a1a:	8c 01       	movw	r16, r24
    5a1c:	c8 01       	movw	r24, r16
    5a1e:	01 97       	sbiw	r24, 0x01	; 1
    5a20:	f1 f7       	brne	.-4      	; 0x5a1e <chb_sleep+0x182>
    5a22:	8c 01       	movw	r16, r24
    5a24:	0c 8b       	std	Y+20, r16	; 0x14
    5a26:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a28:	8a 89       	ldd	r24, Y+18	; 0x12
    5a2a:	9b 89       	ldd	r25, Y+19	; 0x13
    5a2c:	01 97       	sbiw	r24, 0x01	; 1
    5a2e:	8a 8b       	std	Y+18, r24	; 0x12
    5a30:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a32:	8a 89       	ldd	r24, Y+18	; 0x12
    5a34:	9b 89       	ldd	r25, Y+19	; 0x13
    5a36:	00 97       	sbiw	r24, 0x00	; 0
    5a38:	51 f7       	brne	.-44     	; 0x5a0e <chb_sleep+0x172>
    5a3a:	28 c0       	rjmp	.+80     	; 0x5a8c <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a3c:	6e 85       	ldd	r22, Y+14	; 0x0e
    5a3e:	7f 85       	ldd	r23, Y+15	; 0x0f
    5a40:	88 89       	ldd	r24, Y+16	; 0x10
    5a42:	99 89       	ldd	r25, Y+17	; 0x11
    5a44:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    5a48:	dc 01       	movw	r26, r24
    5a4a:	cb 01       	movw	r24, r22
    5a4c:	8a 8b       	std	Y+18, r24	; 0x12
    5a4e:	9b 8b       	std	Y+19, r25	; 0x13
    5a50:	8a 89       	ldd	r24, Y+18	; 0x12
    5a52:	9b 89       	ldd	r25, Y+19	; 0x13
    5a54:	8e 8b       	std	Y+22, r24	; 0x16
    5a56:	9f 8b       	std	Y+23, r25	; 0x17
    5a58:	8e 89       	ldd	r24, Y+22	; 0x16
    5a5a:	9f 89       	ldd	r25, Y+23	; 0x17
    5a5c:	8c 01       	movw	r16, r24
    5a5e:	f8 01       	movw	r30, r16
    5a60:	31 97       	sbiw	r30, 0x01	; 1
    5a62:	f1 f7       	brne	.-4      	; 0x5a60 <chb_sleep+0x1c4>
    5a64:	8f 01       	movw	r16, r30
    5a66:	0e 8b       	std	Y+22, r16	; 0x16
    5a68:	1f 8b       	std	Y+23, r17	; 0x17
    5a6a:	10 c0       	rjmp	.+32     	; 0x5a8c <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5a6c:	6d 81       	ldd	r22, Y+5	; 0x05
    5a6e:	7e 81       	ldd	r23, Y+6	; 0x06
    5a70:	8f 81       	ldd	r24, Y+7	; 0x07
    5a72:	98 85       	ldd	r25, Y+8	; 0x08
    5a74:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    5a78:	dc 01       	movw	r26, r24
    5a7a:	cb 01       	movw	r24, r22
    5a7c:	89 87       	std	Y+9, r24	; 0x09
    5a7e:	89 85       	ldd	r24, Y+9	; 0x09
    5a80:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5a82:	88 8d       	ldd	r24, Y+24	; 0x18
    5a84:	18 2f       	mov	r17, r24
    5a86:	1a 95       	dec	r17
    5a88:	f1 f7       	brne	.-4      	; 0x5a86 <chb_sleep+0x1ea>
    5a8a:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5a8c:	86 e1       	ldi	r24, 0x16	; 22
    5a8e:	0e 94 dd 26 	call	0x4dba	; 0x4dba <chb_set_state>
    }
}
    5a92:	69 96       	adiw	r28, 0x19	; 25
    5a94:	cd bf       	out	0x3d, r28	; 61
    5a96:	de bf       	out	0x3e, r29	; 62
    5a98:	df 91       	pop	r29
    5a9a:	cf 91       	pop	r28
    5a9c:	1f 91       	pop	r17
    5a9e:	0f 91       	pop	r16
    5aa0:	08 95       	ret

00005aa2 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5aa2:	cf 93       	push	r28
    5aa4:	df 93       	push	r29
    5aa6:	cd b7       	in	r28, 0x3d	; 61
    5aa8:	de b7       	in	r29, 0x3e	; 62
    5aaa:	ea 97       	sbiw	r28, 0x3a	; 58
    5aac:	cd bf       	out	0x3d, r28	; 61
    5aae:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5ab0:	0e 94 93 21 	call	0x4326	; 0x4326 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5ab4:	8e e0       	ldi	r24, 0x0E	; 14
    5ab6:	60 e0       	ldi	r22, 0x00	; 0
    5ab8:	0e 94 df 23 	call	0x47be	; 0x47be <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5abc:	82 e0       	ldi	r24, 0x02	; 2
    5abe:	63 e0       	ldi	r22, 0x03	; 3
    5ac0:	4f e1       	ldi	r20, 0x1F	; 31
    5ac2:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5ac6:	00 00       	nop
    5ac8:	81 e0       	ldi	r24, 0x01	; 1
    5aca:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    5ace:	88 2f       	mov	r24, r24
    5ad0:	90 e0       	ldi	r25, 0x00	; 0
    5ad2:	8f 71       	andi	r24, 0x1F	; 31
    5ad4:	90 70       	andi	r25, 0x00	; 0
    5ad6:	88 30       	cpi	r24, 0x08	; 8
    5ad8:	91 05       	cpc	r25, r1
    5ada:	b1 f7       	brne	.-20     	; 0x5ac8 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5adc:	8e e2       	ldi	r24, 0x2E	; 46
    5ade:	60 e4       	ldi	r22, 0x40	; 64
    5ae0:	40 ec       	ldi	r20, 0xC0	; 192
    5ae2:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5ae6:	8e e0       	ldi	r24, 0x0E	; 14
    5ae8:	6c e0       	ldi	r22, 0x0C	; 12
    5aea:	0e 94 df 23 	call	0x47be	; 0x47be <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5aee:	84 e0       	ldi	r24, 0x04	; 4
    5af0:	60 e2       	ldi	r22, 0x20	; 32
    5af2:	40 e2       	ldi	r20, 0x20	; 32
    5af4:	0e 94 62 24 	call	0x48c4	; 0x48c4 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5af8:	81 e0       	ldi	r24, 0x01	; 1
    5afa:	0e 94 7f 25 	call	0x4afe	; 0x4afe <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5afe:	81 e0       	ldi	r24, 0x01	; 1
    5b00:	0e 94 c8 25 	call	0x4b90	; 0x4b90 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5b04:	86 e1       	ldi	r24, 0x16	; 22
    5b06:	0e 94 dd 26 	call	0x4dba	; 0x4dba <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5b0a:	82 e2       	ldi	r24, 0x22	; 34
    5b0c:	64 e3       	ldi	r22, 0x34	; 52
    5b0e:	72 e1       	ldi	r23, 0x12	; 18
    5b10:	0e 94 09 24 	call	0x4812	; 0x4812 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5b14:	0e 94 f0 2b 	call	0x57e0	; 0x57e0 <chb_get_short_addr>
    5b18:	9c 01       	movw	r18, r24
    5b1a:	80 e2       	ldi	r24, 0x20	; 32
    5b1c:	b9 01       	movw	r22, r18
    5b1e:	0e 94 09 24 	call	0x4812	; 0x4812 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5b22:	ce 01       	movw	r24, r28
    5b24:	01 96       	adiw	r24, 0x01	; 1
    5b26:	0e 94 ae 2b 	call	0x575c	; 0x575c <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5b2a:	84 e2       	ldi	r24, 0x24	; 36
    5b2c:	9e 01       	movw	r18, r28
    5b2e:	2f 5f       	subi	r18, 0xFF	; 255
    5b30:	3f 4f       	sbci	r19, 0xFF	; 255
    5b32:	b9 01       	movw	r22, r18
    5b34:	0e 94 3a 24 	call	0x4874	; 0x4874 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5b38:	82 e7       	ldi	r24, 0x72	; 114
    5b3a:	96 e0       	ldi	r25, 0x06	; 6
    5b3c:	22 e7       	ldi	r18, 0x72	; 114
    5b3e:	36 e0       	ldi	r19, 0x06	; 6
    5b40:	f9 01       	movw	r30, r18
    5b42:	20 81       	ld	r18, Z
    5b44:	21 60       	ori	r18, 0x01	; 1
    5b46:	fc 01       	movw	r30, r24
    5b48:	20 83       	st	Z, r18
    5b4a:	89 e6       	ldi	r24, 0x69	; 105
    5b4c:	96 e0       	ldi	r25, 0x06	; 6
    5b4e:	29 e6       	ldi	r18, 0x69	; 105
    5b50:	36 e0       	ldi	r19, 0x06	; 6
    5b52:	f9 01       	movw	r30, r18
    5b54:	20 81       	ld	r18, Z
    5b56:	23 60       	ori	r18, 0x03	; 3
    5b58:	fc 01       	movw	r30, r24
    5b5a:	20 83       	st	Z, r18
    5b5c:	8a e6       	ldi	r24, 0x6A	; 106
    5b5e:	96 e0       	ldi	r25, 0x06	; 6
    5b60:	2a e6       	ldi	r18, 0x6A	; 106
    5b62:	36 e0       	ldi	r19, 0x06	; 6
    5b64:	f9 01       	movw	r30, r18
    5b66:	20 81       	ld	r18, Z
    5b68:	24 60       	ori	r18, 0x04	; 4
    5b6a:	fc 01       	movw	r30, r24
    5b6c:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5b6e:	80 ea       	ldi	r24, 0xA0	; 160
    5b70:	90 e0       	ldi	r25, 0x00	; 0
    5b72:	20 ea       	ldi	r18, 0xA0	; 160
    5b74:	30 e0       	ldi	r19, 0x00	; 0
    5b76:	f9 01       	movw	r30, r18
    5b78:	22 81       	ldd	r18, Z+2	; 0x02
    5b7a:	27 60       	ori	r18, 0x07	; 7
    5b7c:	fc 01       	movw	r30, r24
    5b7e:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5b80:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <chb_get_state>
    5b84:	86 31       	cpi	r24, 0x16	; 22
    5b86:	b1 f0       	breq	.+44     	; 0x5bb4 <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5b88:	ce 01       	movw	r24, r28
    5b8a:	09 96       	adiw	r24, 0x09	; 9
    5b8c:	2c e0       	ldi	r18, 0x0C	; 12
    5b8e:	32 e0       	ldi	r19, 0x02	; 2
    5b90:	b9 01       	movw	r22, r18
    5b92:	0e 94 5e 5d 	call	0xbabc	; 0xbabc <strcpy_P>
        printf(buf);
    5b96:	0f 92       	push	r0
    5b98:	0f 92       	push	r0
    5b9a:	8d b7       	in	r24, 0x3d	; 61
    5b9c:	9e b7       	in	r25, 0x3e	; 62
    5b9e:	01 96       	adiw	r24, 0x01	; 1
    5ba0:	9e 01       	movw	r18, r28
    5ba2:	27 5f       	subi	r18, 0xF7	; 247
    5ba4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ba6:	fc 01       	movw	r30, r24
    5ba8:	20 83       	st	Z, r18
    5baa:	31 83       	std	Z+1, r19	; 0x01
    5bac:	0e 94 b1 5d 	call	0xbb62	; 0xbb62 <printf>
    5bb0:	0f 90       	pop	r0
    5bb2:	0f 90       	pop	r0
    }
	//StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
}
    5bb4:	ea 96       	adiw	r28, 0x3a	; 58
    5bb6:	cd bf       	out	0x3d, r28	; 61
    5bb8:	de bf       	out	0x3e, r29	; 62
    5bba:	df 91       	pop	r29
    5bbc:	cf 91       	pop	r28
    5bbe:	08 95       	ret

00005bc0 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5bc0:	cf 93       	push	r28
    5bc2:	df 93       	push	r29
    5bc4:	cd b7       	in	r28, 0x3d	; 61
    5bc6:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5bc8:	0e 94 27 30 	call	0x604e	; 0x604e <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5bcc:	80 e6       	ldi	r24, 0x60	; 96
    5bce:	96 e0       	ldi	r25, 0x06	; 6
    5bd0:	20 e6       	ldi	r18, 0x60	; 96
    5bd2:	36 e0       	ldi	r19, 0x06	; 6
    5bd4:	f9 01       	movw	r30, r18
    5bd6:	20 81       	ld	r18, Z
    5bd8:	22 60       	ori	r18, 0x02	; 2
    5bda:	fc 01       	movw	r30, r24
    5bdc:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5bde:	80 e6       	ldi	r24, 0x60	; 96
    5be0:	96 e0       	ldi	r25, 0x06	; 6
    5be2:	20 e6       	ldi	r18, 0x60	; 96
    5be4:	36 e0       	ldi	r19, 0x06	; 6
    5be6:	f9 01       	movw	r30, r18
    5be8:	20 81       	ld	r18, Z
    5bea:	21 60       	ori	r18, 0x01	; 1
    5bec:	fc 01       	movw	r30, r24
    5bee:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5bf0:	0e 94 51 2d 	call	0x5aa2	; 0x5aa2 <chb_radio_init>
}
    5bf4:	df 91       	pop	r29
    5bf6:	cf 91       	pop	r28
    5bf8:	08 95       	ret

00005bfa <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5bfa:	1f 92       	push	r1
    5bfc:	0f 92       	push	r0
    5bfe:	0f b6       	in	r0, 0x3f	; 63
    5c00:	0f 92       	push	r0
    5c02:	00 90 3b 00 	lds	r0, 0x003B
    5c06:	0f 92       	push	r0
    5c08:	11 24       	eor	r1, r1
    5c0a:	2f 93       	push	r18
    5c0c:	3f 93       	push	r19
    5c0e:	4f 93       	push	r20
    5c10:	5f 93       	push	r21
    5c12:	6f 93       	push	r22
    5c14:	7f 93       	push	r23
    5c16:	8f 93       	push	r24
    5c18:	9f 93       	push	r25
    5c1a:	af 93       	push	r26
    5c1c:	bf 93       	push	r27
    5c1e:	ef 93       	push	r30
    5c20:	ff 93       	push	r31
    5c22:	cf 93       	push	r28
    5c24:	df 93       	push	r29
    5c26:	00 d0       	rcall	.+0      	; 0x5c28 <__vector_64+0x2e>
    5c28:	0f 92       	push	r0
    5c2a:	cd b7       	in	r28, 0x3d	; 61
    5c2c:	de b7       	in	r29, 0x3e	; 62
    U8 state, intp_src = 0;
    5c2e:	19 82       	std	Y+1, r1	; 0x01
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    5c30:	0e 94 73 1e 	call	0x3ce6	; 0x3ce6 <chb_get_pcb>
    5c34:	8a 83       	std	Y+2, r24	; 0x02
    5c36:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5c38:	8f e3       	ldi	r24, 0x3F	; 63
    5c3a:	90 e0       	ldi	r25, 0x00	; 0
    5c3c:	fc 01       	movw	r30, r24
    5c3e:	80 81       	ld	r24, Z
    5c40:	80 93 55 40 	sts	0x4055, r24
    5c44:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5c46:	81 e0       	ldi	r24, 0x01	; 1
    5c48:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5c4c:	8f e8       	ldi	r24, 0x8F	; 143
    5c4e:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    intp_src = SPID_write(0);
    5c52:	80 e0       	ldi	r24, 0x00	; 0
    5c54:	0e 94 52 30 	call	0x60a4	; 0x60a4 <SPID_write>
    5c58:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5c5a:	80 e0       	ldi	r24, 0x00	; 0
    5c5c:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <RadioCS>

    while (intp_src)
    5c60:	9d c0       	rjmp	.+314    	; 0x5d9c <__vector_64+0x1a2>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5c62:	89 81       	ldd	r24, Y+1	; 0x01
    5c64:	88 2f       	mov	r24, r24
    5c66:	90 e0       	ldi	r25, 0x00	; 0
    5c68:	84 70       	andi	r24, 0x04	; 4
    5c6a:	90 70       	andi	r25, 0x00	; 0
    5c6c:	00 97       	sbiw	r24, 0x00	; 0
    5c6e:	21 f0       	breq	.+8      	; 0x5c78 <__vector_64+0x7e>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5c70:	89 81       	ldd	r24, Y+1	; 0x01
    5c72:	8b 7f       	andi	r24, 0xFB	; 251
    5c74:	89 83       	std	Y+1, r24	; 0x01
    5c76:	92 c0       	rjmp	.+292    	; 0x5d9c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5c78:	89 81       	ldd	r24, Y+1	; 0x01
    5c7a:	88 2f       	mov	r24, r24
    5c7c:	90 e0       	ldi	r25, 0x00	; 0
    5c7e:	88 70       	andi	r24, 0x08	; 8
    5c80:	90 70       	andi	r25, 0x00	; 0
    5c82:	00 97       	sbiw	r24, 0x00	; 0
    5c84:	09 f4       	brne	.+2      	; 0x5c88 <__vector_64+0x8e>
    5c86:	4c c0       	rjmp	.+152    	; 0x5d20 <__vector_64+0x126>
        {
            state = chb_get_state();
    5c88:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <chb_get_state>
    5c8c:	8c 83       	std	Y+4, r24	; 0x04

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5c8e:	8c 81       	ldd	r24, Y+4	; 0x04
    5c90:	86 30       	cpi	r24, 0x06	; 6
    5c92:	31 f0       	breq	.+12     	; 0x5ca0 <__vector_64+0xa6>
    5c94:	8c 81       	ldd	r24, Y+4	; 0x04
    5c96:	86 31       	cpi	r24, 0x16	; 22
    5c98:	19 f0       	breq	.+6      	; 0x5ca0 <__vector_64+0xa6>
    5c9a:	8c 81       	ldd	r24, Y+4	; 0x04
    5c9c:	81 31       	cpi	r24, 0x11	; 17
    5c9e:	89 f5       	brne	.+98     	; 0x5d02 <__vector_64+0x108>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5ca0:	88 e0       	ldi	r24, 0x08	; 8
    5ca2:	0e 94 dd 26 	call	0x4dba	; 0x4dba <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5ca6:	87 e0       	ldi	r24, 0x07	; 7
    5ca8:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    5cac:	28 2f       	mov	r18, r24
    5cae:	8a 81       	ldd	r24, Y+2	; 0x02
    5cb0:	9b 81       	ldd	r25, Y+3	; 0x03
    5cb2:	fc 01       	movw	r30, r24
    5cb4:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5cb6:	86 e0       	ldi	r24, 0x06	; 6
    5cb8:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
    5cbc:	28 2f       	mov	r18, r24
    5cbe:	22 1f       	adc	r18, r18
    5cc0:	22 27       	eor	r18, r18
    5cc2:	22 1f       	adc	r18, r18
    5cc4:	8a 81       	ldd	r24, Y+2	; 0x02
    5cc6:	9b 81       	ldd	r25, Y+3	; 0x03
    5cc8:	fc 01       	movw	r30, r24
    5cca:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cce:	9b 81       	ldd	r25, Y+3	; 0x03
    5cd0:	fc 01       	movw	r30, r24
    5cd2:	83 89       	ldd	r24, Z+19	; 0x13
    5cd4:	88 23       	and	r24, r24
    5cd6:	d1 f0       	breq	.+52     	; 0x5d0c <__vector_64+0x112>
                    // get the data
                    chb_frame_read();
    5cd8:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <chb_frame_read>
                    pcb->rcvd_xfers++;
    5cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cde:	9b 81       	ldd	r25, Y+3	; 0x03
    5ce0:	fc 01       	movw	r30, r24
    5ce2:	85 81       	ldd	r24, Z+5	; 0x05
    5ce4:	96 81       	ldd	r25, Z+6	; 0x06
    5ce6:	9c 01       	movw	r18, r24
    5ce8:	2f 5f       	subi	r18, 0xFF	; 255
    5cea:	3f 4f       	sbci	r19, 0xFF	; 255
    5cec:	8a 81       	ldd	r24, Y+2	; 0x02
    5cee:	9b 81       	ldd	r25, Y+3	; 0x03
    5cf0:	fc 01       	movw	r30, r24
    5cf2:	25 83       	std	Z+5, r18	; 0x05
    5cf4:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    5cf8:	9b 81       	ldd	r25, Y+3	; 0x03
    5cfa:	21 e0       	ldi	r18, 0x01	; 1
    5cfc:	fc 01       	movw	r30, r24
    5cfe:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5d00:	05 c0       	rjmp	.+10     	; 0x5d0c <__vector_64+0x112>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    5d02:	8a 81       	ldd	r24, Y+2	; 0x02
    5d04:	9b 81       	ldd	r25, Y+3	; 0x03
    5d06:	21 e0       	ldi	r18, 0x01	; 1
    5d08:	fc 01       	movw	r30, r24
    5d0a:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5d0c:	89 81       	ldd	r24, Y+1	; 0x01
    5d0e:	87 7f       	andi	r24, 0xF7	; 247
    5d10:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5d12:	00 00       	nop
    5d14:	86 e1       	ldi	r24, 0x16	; 22
    5d16:	0e 94 dd 26 	call	0x4dba	; 0x4dba <chb_set_state>
    5d1a:	80 34       	cpi	r24, 0x40	; 64
    5d1c:	d9 f7       	brne	.-10     	; 0x5d14 <__vector_64+0x11a>
    5d1e:	3e c0       	rjmp	.+124    	; 0x5d9c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5d20:	89 81       	ldd	r24, Y+1	; 0x01
    5d22:	88 2f       	mov	r24, r24
    5d24:	90 e0       	ldi	r25, 0x00	; 0
    5d26:	80 74       	andi	r24, 0x40	; 64
    5d28:	90 70       	andi	r25, 0x00	; 0
    5d2a:	00 97       	sbiw	r24, 0x00	; 0
    5d2c:	89 f0       	breq	.+34     	; 0x5d50 <__vector_64+0x156>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5d2e:	89 81       	ldd	r24, Y+1	; 0x01
    5d30:	8f 7b       	andi	r24, 0xBF	; 191
    5d32:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5d34:	8a 81       	ldd	r24, Y+2	; 0x02
    5d36:	9b 81       	ldd	r25, Y+3	; 0x03
    5d38:	fc 01       	movw	r30, r24
    5d3a:	87 85       	ldd	r24, Z+15	; 0x0f
    5d3c:	90 89       	ldd	r25, Z+16	; 0x10
    5d3e:	9c 01       	movw	r18, r24
    5d40:	2f 5f       	subi	r18, 0xFF	; 255
    5d42:	3f 4f       	sbci	r19, 0xFF	; 255
    5d44:	8a 81       	ldd	r24, Y+2	; 0x02
    5d46:	9b 81       	ldd	r25, Y+3	; 0x03
    5d48:	fc 01       	movw	r30, r24
    5d4a:	27 87       	std	Z+15, r18	; 0x0f
    5d4c:	30 8b       	std	Z+16, r19	; 0x10
    5d4e:	26 c0       	rjmp	.+76     	; 0x5d9c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5d50:	89 81       	ldd	r24, Y+1	; 0x01
    5d52:	88 2f       	mov	r24, r24
    5d54:	90 e0       	ldi	r25, 0x00	; 0
    5d56:	82 70       	andi	r24, 0x02	; 2
    5d58:	90 70       	andi	r25, 0x00	; 0
    5d5a:	00 97       	sbiw	r24, 0x00	; 0
    5d5c:	21 f0       	breq	.+8      	; 0x5d66 <__vector_64+0x16c>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5d5e:	89 81       	ldd	r24, Y+1	; 0x01
    5d60:	8d 7f       	andi	r24, 0xFD	; 253
    5d62:	89 83       	std	Y+1, r24	; 0x01
    5d64:	1b c0       	rjmp	.+54     	; 0x5d9c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5d66:	89 81       	ldd	r24, Y+1	; 0x01
    5d68:	88 2f       	mov	r24, r24
    5d6a:	90 e0       	ldi	r25, 0x00	; 0
    5d6c:	81 70       	andi	r24, 0x01	; 1
    5d6e:	90 70       	andi	r25, 0x00	; 0
    5d70:	88 23       	and	r24, r24
    5d72:	21 f0       	breq	.+8      	; 0x5d7c <__vector_64+0x182>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5d74:	89 81       	ldd	r24, Y+1	; 0x01
    5d76:	8e 7f       	andi	r24, 0xFE	; 254
    5d78:	89 83       	std	Y+1, r24	; 0x01
    5d7a:	10 c0       	rjmp	.+32     	; 0x5d9c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5d7c:	89 81       	ldd	r24, Y+1	; 0x01
    5d7e:	88 23       	and	r24, r24
    5d80:	6c f4       	brge	.+26     	; 0x5d9c <__vector_64+0x1a2>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5d82:	89 81       	ldd	r24, Y+1	; 0x01
    5d84:	8f 77       	andi	r24, 0x7F	; 127
    5d86:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5d88:	8a 81       	ldd	r24, Y+2	; 0x02
    5d8a:	9b 81       	ldd	r25, Y+3	; 0x03
    5d8c:	fc 01       	movw	r30, r24
    5d8e:	81 89       	ldd	r24, Z+17	; 0x11
    5d90:	28 2f       	mov	r18, r24
    5d92:	2f 5f       	subi	r18, 0xFF	; 255
    5d94:	8a 81       	ldd	r24, Y+2	; 0x02
    5d96:	9b 81       	ldd	r25, Y+3	; 0x03
    5d98:	fc 01       	movw	r30, r24
    5d9a:	21 8b       	std	Z+17, r18	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5d9c:	89 81       	ldd	r24, Y+1	; 0x01
    5d9e:	88 23       	and	r24, r24
    5da0:	09 f0       	breq	.+2      	; 0x5da4 <__vector_64+0x1aa>
    5da2:	5f cf       	rjmp	.-322    	; 0x5c62 <__vector_64+0x68>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5da4:	8f e3       	ldi	r24, 0x3F	; 63
    5da6:	90 e0       	ldi	r25, 0x00	; 0
    5da8:	20 91 55 40 	lds	r18, 0x4055
    5dac:	fc 01       	movw	r30, r24
    5dae:	20 83       	st	Z, r18
    5db0:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5db2:	8f e0       	ldi	r24, 0x0F	; 15
    5db4:	0e 94 7f 23 	call	0x46fe	; 0x46fe <chb_reg_read>
}
    5db8:	24 96       	adiw	r28, 0x04	; 4
    5dba:	cd bf       	out	0x3d, r28	; 61
    5dbc:	de bf       	out	0x3e, r29	; 62
    5dbe:	df 91       	pop	r29
    5dc0:	cf 91       	pop	r28
    5dc2:	ff 91       	pop	r31
    5dc4:	ef 91       	pop	r30
    5dc6:	bf 91       	pop	r27
    5dc8:	af 91       	pop	r26
    5dca:	9f 91       	pop	r25
    5dcc:	8f 91       	pop	r24
    5dce:	7f 91       	pop	r23
    5dd0:	6f 91       	pop	r22
    5dd2:	5f 91       	pop	r21
    5dd4:	4f 91       	pop	r20
    5dd6:	3f 91       	pop	r19
    5dd8:	2f 91       	pop	r18
    5dda:	0f 90       	pop	r0
    5ddc:	00 92 3b 00 	sts	0x003B, r0
    5de0:	0f 90       	pop	r0
    5de2:	0f be       	out	0x3f, r0	; 63
    5de4:	0f 90       	pop	r0
    5de6:	1f 90       	pop	r1
    5de8:	18 95       	reti

00005dea <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5dea:	cf 93       	push	r28
    5dec:	df 93       	push	r29
    5dee:	0f 92       	push	r0
    5df0:	cd b7       	in	r28, 0x3d	; 61
    5df2:	de b7       	in	r29, 0x3e	; 62
    5df4:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5df6:	89 81       	ldd	r24, Y+1	; 0x01
    5df8:	88 23       	and	r24, r24
    5dfa:	31 f0       	breq	.+12     	; 0x5e08 <RadioCS+0x1e>
    5dfc:	80 e6       	ldi	r24, 0x60	; 96
    5dfe:	96 e0       	ldi	r25, 0x06	; 6
    5e00:	20 e1       	ldi	r18, 0x10	; 16
    5e02:	fc 01       	movw	r30, r24
    5e04:	26 83       	std	Z+6, r18	; 0x06
    5e06:	05 c0       	rjmp	.+10     	; 0x5e12 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5e08:	80 e6       	ldi	r24, 0x60	; 96
    5e0a:	96 e0       	ldi	r25, 0x06	; 6
    5e0c:	20 e1       	ldi	r18, 0x10	; 16
    5e0e:	fc 01       	movw	r30, r24
    5e10:	25 83       	std	Z+5, r18	; 0x05
	}
    5e12:	0f 90       	pop	r0
    5e14:	df 91       	pop	r29
    5e16:	cf 91       	pop	r28
    5e18:	08 95       	ret

00005e1a <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5e1a:	cf 93       	push	r28
    5e1c:	df 93       	push	r29
    5e1e:	00 d0       	rcall	.+0      	; 0x5e20 <chb_eep_write_byte+0x6>
    5e20:	cd b7       	in	r28, 0x3d	; 61
    5e22:	de b7       	in	r29, 0x3e	; 62
    5e24:	89 83       	std	Y+1, r24	; 0x01
    5e26:	9a 83       	std	Y+2, r25	; 0x02
    5e28:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5e2a:	00 00       	nop
    5e2c:	80 ec       	ldi	r24, 0xC0	; 192
    5e2e:	91 e0       	ldi	r25, 0x01	; 1
    5e30:	fc 01       	movw	r30, r24
    5e32:	87 85       	ldd	r24, Z+15	; 0x0f
    5e34:	88 23       	and	r24, r24
    5e36:	d4 f3       	brlt	.-12     	; 0x5e2c <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5e38:	80 ec       	ldi	r24, 0xC0	; 192
    5e3a:	91 e0       	ldi	r25, 0x01	; 1
    5e3c:	fc 01       	movw	r30, r24
    5e3e:	87 85       	ldd	r24, Z+15	; 0x0f
    5e40:	88 2f       	mov	r24, r24
    5e42:	90 e0       	ldi	r25, 0x00	; 0
    5e44:	82 70       	andi	r24, 0x02	; 2
    5e46:	90 70       	andi	r25, 0x00	; 0
    5e48:	00 97       	sbiw	r24, 0x00	; 0
    5e4a:	99 f0       	breq	.+38     	; 0x5e72 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5e4c:	80 ec       	ldi	r24, 0xC0	; 192
    5e4e:	91 e0       	ldi	r25, 0x01	; 1
    5e50:	26 e3       	ldi	r18, 0x36	; 54
    5e52:	fc 01       	movw	r30, r24
    5e54:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5e56:	ef 93       	push	r30
    5e58:	ff 93       	push	r31
    5e5a:	0f 93       	push	r16
    5e5c:	2f 93       	push	r18
    5e5e:	eb ec       	ldi	r30, 0xCB	; 203
    5e60:	f1 e0       	ldi	r31, 0x01	; 1
    5e62:	08 ed       	ldi	r16, 0xD8	; 216
    5e64:	21 e0       	ldi	r18, 0x01	; 1
    5e66:	04 bf       	out	0x34, r16	; 52
    5e68:	20 83       	st	Z, r18
    5e6a:	2f 91       	pop	r18
    5e6c:	0f 91       	pop	r16
    5e6e:	ff 91       	pop	r31
    5e70:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    5e72:	80 ec       	ldi	r24, 0xC0	; 192
    5e74:	91 e0       	ldi	r25, 0x01	; 1
    5e76:	23 e3       	ldi	r18, 0x33	; 51
    5e78:	fc 01       	movw	r30, r24
    5e7a:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    5e7c:	80 ec       	ldi	r24, 0xC0	; 192
    5e7e:	91 e0       	ldi	r25, 0x01	; 1
    5e80:	29 81       	ldd	r18, Y+1	; 0x01
    5e82:	fc 01       	movw	r30, r24
    5e84:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5e86:	80 ec       	ldi	r24, 0xC0	; 192
    5e88:	91 e0       	ldi	r25, 0x01	; 1
    5e8a:	29 81       	ldd	r18, Y+1	; 0x01
    5e8c:	3a 81       	ldd	r19, Y+2	; 0x02
    5e8e:	23 2f       	mov	r18, r19
    5e90:	33 27       	eor	r19, r19
    5e92:	2f 71       	andi	r18, 0x1F	; 31
    5e94:	fc 01       	movw	r30, r24
    5e96:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5e98:	80 ec       	ldi	r24, 0xC0	; 192
    5e9a:	91 e0       	ldi	r25, 0x01	; 1
    5e9c:	fc 01       	movw	r30, r24
    5e9e:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    5ea0:	80 ec       	ldi	r24, 0xC0	; 192
    5ea2:	91 e0       	ldi	r25, 0x01	; 1
    5ea4:	2b 81       	ldd	r18, Y+3	; 0x03
    5ea6:	fc 01       	movw	r30, r24
    5ea8:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    5eaa:	80 ec       	ldi	r24, 0xC0	; 192
    5eac:	91 e0       	ldi	r25, 0x01	; 1
    5eae:	25 e3       	ldi	r18, 0x35	; 53
    5eb0:	fc 01       	movw	r30, r24
    5eb2:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5eb4:	ef 93       	push	r30
    5eb6:	ff 93       	push	r31
    5eb8:	0f 93       	push	r16
    5eba:	2f 93       	push	r18
    5ebc:	eb ec       	ldi	r30, 0xCB	; 203
    5ebe:	f1 e0       	ldi	r31, 0x01	; 1
    5ec0:	08 ed       	ldi	r16, 0xD8	; 216
    5ec2:	21 e0       	ldi	r18, 0x01	; 1
    5ec4:	04 bf       	out	0x34, r16	; 52
    5ec6:	20 83       	st	Z, r18
    5ec8:	2f 91       	pop	r18
    5eca:	0f 91       	pop	r16
    5ecc:	ff 91       	pop	r31
    5ece:	ef 91       	pop	r30
}
    5ed0:	23 96       	adiw	r28, 0x03	; 3
    5ed2:	cd bf       	out	0x3d, r28	; 61
    5ed4:	de bf       	out	0x3e, r29	; 62
    5ed6:	df 91       	pop	r29
    5ed8:	cf 91       	pop	r28
    5eda:	08 95       	ret

00005edc <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    5edc:	cf 93       	push	r28
    5ede:	df 93       	push	r29
    5ee0:	0f 92       	push	r0
    5ee2:	0f 92       	push	r0
    5ee4:	cd b7       	in	r28, 0x3d	; 61
    5ee6:	de b7       	in	r29, 0x3e	; 62
    5ee8:	89 83       	std	Y+1, r24	; 0x01
    5eea:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5eec:	00 00       	nop
    5eee:	80 ec       	ldi	r24, 0xC0	; 192
    5ef0:	91 e0       	ldi	r25, 0x01	; 1
    5ef2:	fc 01       	movw	r30, r24
    5ef4:	87 85       	ldd	r24, Z+15	; 0x0f
    5ef6:	88 23       	and	r24, r24
    5ef8:	d4 f3       	brlt	.-12     	; 0x5eee <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    5efa:	80 ec       	ldi	r24, 0xC0	; 192
    5efc:	91 e0       	ldi	r25, 0x01	; 1
    5efe:	29 81       	ldd	r18, Y+1	; 0x01
    5f00:	fc 01       	movw	r30, r24
    5f02:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5f04:	80 ec       	ldi	r24, 0xC0	; 192
    5f06:	91 e0       	ldi	r25, 0x01	; 1
    5f08:	29 81       	ldd	r18, Y+1	; 0x01
    5f0a:	3a 81       	ldd	r19, Y+2	; 0x02
    5f0c:	23 2f       	mov	r18, r19
    5f0e:	33 27       	eor	r19, r19
    5f10:	2f 71       	andi	r18, 0x1F	; 31
    5f12:	fc 01       	movw	r30, r24
    5f14:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5f16:	80 ec       	ldi	r24, 0xC0	; 192
    5f18:	91 e0       	ldi	r25, 0x01	; 1
    5f1a:	fc 01       	movw	r30, r24
    5f1c:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    5f1e:	80 ec       	ldi	r24, 0xC0	; 192
    5f20:	91 e0       	ldi	r25, 0x01	; 1
    5f22:	26 e0       	ldi	r18, 0x06	; 6
    5f24:	fc 01       	movw	r30, r24
    5f26:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5f28:	ef 93       	push	r30
    5f2a:	ff 93       	push	r31
    5f2c:	0f 93       	push	r16
    5f2e:	2f 93       	push	r18
    5f30:	eb ec       	ldi	r30, 0xCB	; 203
    5f32:	f1 e0       	ldi	r31, 0x01	; 1
    5f34:	08 ed       	ldi	r16, 0xD8	; 216
    5f36:	21 e0       	ldi	r18, 0x01	; 1
    5f38:	04 bf       	out	0x34, r16	; 52
    5f3a:	20 83       	st	Z, r18
    5f3c:	2f 91       	pop	r18
    5f3e:	0f 91       	pop	r16
    5f40:	ff 91       	pop	r31
    5f42:	ef 91       	pop	r30

    return NVM.DATA0;
    5f44:	80 ec       	ldi	r24, 0xC0	; 192
    5f46:	91 e0       	ldi	r25, 0x01	; 1
    5f48:	fc 01       	movw	r30, r24
    5f4a:	84 81       	ldd	r24, Z+4	; 0x04
}
    5f4c:	0f 90       	pop	r0
    5f4e:	0f 90       	pop	r0
    5f50:	df 91       	pop	r29
    5f52:	cf 91       	pop	r28
    5f54:	08 95       	ret

00005f56 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    5f56:	cf 93       	push	r28
    5f58:	df 93       	push	r29
    5f5a:	cd b7       	in	r28, 0x3d	; 61
    5f5c:	de b7       	in	r29, 0x3e	; 62
    5f5e:	27 97       	sbiw	r28, 0x07	; 7
    5f60:	cd bf       	out	0x3d, r28	; 61
    5f62:	de bf       	out	0x3e, r29	; 62
    5f64:	8a 83       	std	Y+2, r24	; 0x02
    5f66:	9b 83       	std	Y+3, r25	; 0x03
    5f68:	6c 83       	std	Y+4, r22	; 0x04
    5f6a:	7d 83       	std	Y+5, r23	; 0x05
    5f6c:	4e 83       	std	Y+6, r20	; 0x06
    5f6e:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5f70:	80 ec       	ldi	r24, 0xC0	; 192
    5f72:	91 e0       	ldi	r25, 0x01	; 1
    5f74:	20 ec       	ldi	r18, 0xC0	; 192
    5f76:	31 e0       	ldi	r19, 0x01	; 1
    5f78:	f9 01       	movw	r30, r18
    5f7a:	24 85       	ldd	r18, Z+12	; 0x0c
    5f7c:	27 7f       	andi	r18, 0xF7	; 247
    5f7e:	fc 01       	movw	r30, r24
    5f80:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    5f82:	19 82       	std	Y+1, r1	; 0x01
    5f84:	16 c0       	rjmp	.+44     	; 0x5fb2 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    5f86:	89 81       	ldd	r24, Y+1	; 0x01
    5f88:	28 2f       	mov	r18, r24
    5f8a:	30 e0       	ldi	r19, 0x00	; 0
    5f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f8e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f90:	82 0f       	add	r24, r18
    5f92:	93 1f       	adc	r25, r19
    5f94:	29 81       	ldd	r18, Y+1	; 0x01
    5f96:	22 2f       	mov	r18, r18
    5f98:	30 e0       	ldi	r19, 0x00	; 0
    5f9a:	4c 81       	ldd	r20, Y+4	; 0x04
    5f9c:	5d 81       	ldd	r21, Y+5	; 0x05
    5f9e:	24 0f       	add	r18, r20
    5fa0:	35 1f       	adc	r19, r21
    5fa2:	f9 01       	movw	r30, r18
    5fa4:	20 81       	ld	r18, Z
    5fa6:	62 2f       	mov	r22, r18
    5fa8:	0e 94 0d 2f 	call	0x5e1a	; 0x5e1a <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    5fac:	89 81       	ldd	r24, Y+1	; 0x01
    5fae:	8f 5f       	subi	r24, 0xFF	; 255
    5fb0:	89 83       	std	Y+1, r24	; 0x01
    5fb2:	89 81       	ldd	r24, Y+1	; 0x01
    5fb4:	28 2f       	mov	r18, r24
    5fb6:	30 e0       	ldi	r19, 0x00	; 0
    5fb8:	8e 81       	ldd	r24, Y+6	; 0x06
    5fba:	9f 81       	ldd	r25, Y+7	; 0x07
    5fbc:	28 17       	cp	r18, r24
    5fbe:	39 07       	cpc	r19, r25
    5fc0:	10 f3       	brcs	.-60     	; 0x5f86 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    5fc2:	27 96       	adiw	r28, 0x07	; 7
    5fc4:	cd bf       	out	0x3d, r28	; 61
    5fc6:	de bf       	out	0x3e, r29	; 62
    5fc8:	df 91       	pop	r29
    5fca:	cf 91       	pop	r28
    5fcc:	08 95       	ret

00005fce <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    5fce:	0f 93       	push	r16
    5fd0:	1f 93       	push	r17
    5fd2:	cf 93       	push	r28
    5fd4:	df 93       	push	r29
    5fd6:	cd b7       	in	r28, 0x3d	; 61
    5fd8:	de b7       	in	r29, 0x3e	; 62
    5fda:	27 97       	sbiw	r28, 0x07	; 7
    5fdc:	cd bf       	out	0x3d, r28	; 61
    5fde:	de bf       	out	0x3e, r29	; 62
    5fe0:	8a 83       	std	Y+2, r24	; 0x02
    5fe2:	9b 83       	std	Y+3, r25	; 0x03
    5fe4:	6c 83       	std	Y+4, r22	; 0x04
    5fe6:	7d 83       	std	Y+5, r23	; 0x05
    5fe8:	4e 83       	std	Y+6, r20	; 0x06
    5fea:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5fec:	80 ec       	ldi	r24, 0xC0	; 192
    5fee:	91 e0       	ldi	r25, 0x01	; 1
    5ff0:	20 ec       	ldi	r18, 0xC0	; 192
    5ff2:	31 e0       	ldi	r19, 0x01	; 1
    5ff4:	f9 01       	movw	r30, r18
    5ff6:	24 85       	ldd	r18, Z+12	; 0x0c
    5ff8:	27 7f       	andi	r18, 0xF7	; 247
    5ffa:	fc 01       	movw	r30, r24
    5ffc:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5ffe:	19 82       	std	Y+1, r1	; 0x01
    6000:	16 c0       	rjmp	.+44     	; 0x602e <__stack+0x2f>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    6002:	89 81       	ldd	r24, Y+1	; 0x01
    6004:	88 2f       	mov	r24, r24
    6006:	90 e0       	ldi	r25, 0x00	; 0
    6008:	2c 81       	ldd	r18, Y+4	; 0x04
    600a:	3d 81       	ldd	r19, Y+5	; 0x05
    600c:	89 01       	movw	r16, r18
    600e:	08 0f       	add	r16, r24
    6010:	19 1f       	adc	r17, r25
    6012:	89 81       	ldd	r24, Y+1	; 0x01
    6014:	28 2f       	mov	r18, r24
    6016:	30 e0       	ldi	r19, 0x00	; 0
    6018:	8a 81       	ldd	r24, Y+2	; 0x02
    601a:	9b 81       	ldd	r25, Y+3	; 0x03
    601c:	82 0f       	add	r24, r18
    601e:	93 1f       	adc	r25, r19
    6020:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <chb_eep_read_byte>
    6024:	f8 01       	movw	r30, r16
    6026:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6028:	89 81       	ldd	r24, Y+1	; 0x01
    602a:	8f 5f       	subi	r24, 0xFF	; 255
    602c:	89 83       	std	Y+1, r24	; 0x01
    602e:	89 81       	ldd	r24, Y+1	; 0x01
    6030:	28 2f       	mov	r18, r24
    6032:	30 e0       	ldi	r19, 0x00	; 0
    6034:	8e 81       	ldd	r24, Y+6	; 0x06
    6036:	9f 81       	ldd	r25, Y+7	; 0x07
    6038:	28 17       	cp	r18, r24
    603a:	39 07       	cpc	r19, r25
    603c:	10 f3       	brcs	.-60     	; 0x6002 <__stack+0x3>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    603e:	27 96       	adiw	r28, 0x07	; 7
    6040:	cd bf       	out	0x3d, r28	; 61
    6042:	de bf       	out	0x3e, r29	; 62
    6044:	df 91       	pop	r29
    6046:	cf 91       	pop	r28
    6048:	1f 91       	pop	r17
    604a:	0f 91       	pop	r16
    604c:	08 95       	ret

0000604e <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    604e:	cf 93       	push	r28
    6050:	df 93       	push	r29
    6052:	cd b7       	in	r28, 0x3d	; 61
    6054:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    6056:	80 e6       	ldi	r24, 0x60	; 96
    6058:	96 e0       	ldi	r25, 0x06	; 6
    605a:	20 e6       	ldi	r18, 0x60	; 96
    605c:	36 e0       	ldi	r19, 0x06	; 6
    605e:	f9 01       	movw	r30, r18
    6060:	20 81       	ld	r18, Z
    6062:	20 6b       	ori	r18, 0xB0	; 176
    6064:	fc 01       	movw	r30, r24
    6066:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    6068:	84 e6       	ldi	r24, 0x64	; 100
    606a:	96 e0       	ldi	r25, 0x06	; 6
    606c:	24 e6       	ldi	r18, 0x64	; 100
    606e:	36 e0       	ldi	r19, 0x06	; 6
    6070:	f9 01       	movw	r30, r18
    6072:	20 81       	ld	r18, Z
    6074:	20 61       	ori	r18, 0x10	; 16
    6076:	fc 01       	movw	r30, r24
    6078:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    607a:	80 ec       	ldi	r24, 0xC0	; 192
    607c:	99 e0       	ldi	r25, 0x09	; 9
    607e:	20 ec       	ldi	r18, 0xC0	; 192
    6080:	39 e0       	ldi	r19, 0x09	; 9
    6082:	f9 01       	movw	r30, r18
    6084:	20 81       	ld	r18, Z
    6086:	21 65       	ori	r18, 0x51	; 81
    6088:	fc 01       	movw	r30, r24
    608a:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    608c:	84 e6       	ldi	r24, 0x64	; 100
    608e:	96 e0       	ldi	r25, 0x06	; 6
    6090:	24 e6       	ldi	r18, 0x64	; 100
    6092:	36 e0       	ldi	r19, 0x06	; 6
    6094:	f9 01       	movw	r30, r18
    6096:	20 81       	ld	r18, Z
    6098:	20 61       	ori	r18, 0x10	; 16
    609a:	fc 01       	movw	r30, r24
    609c:	20 83       	st	Z, r18
}
    609e:	df 91       	pop	r29
    60a0:	cf 91       	pop	r28
    60a2:	08 95       	ret

000060a4 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    60a4:	cf 93       	push	r28
    60a6:	df 93       	push	r29
    60a8:	0f 92       	push	r0
    60aa:	0f 92       	push	r0
    60ac:	cd b7       	in	r28, 0x3d	; 61
    60ae:	de b7       	in	r29, 0x3e	; 62
    60b0:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    60b2:	80 ec       	ldi	r24, 0xC0	; 192
    60b4:	99 e0       	ldi	r25, 0x09	; 9
    60b6:	2a 81       	ldd	r18, Y+2	; 0x02
    60b8:	fc 01       	movw	r30, r24
    60ba:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    60bc:	00 00       	nop
    60be:	80 ec       	ldi	r24, 0xC0	; 192
    60c0:	99 e0       	ldi	r25, 0x09	; 9
    60c2:	fc 01       	movw	r30, r24
    60c4:	82 81       	ldd	r24, Z+2	; 0x02
    60c6:	88 23       	and	r24, r24
    60c8:	d4 f7       	brge	.-12     	; 0x60be <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    60ca:	80 ec       	ldi	r24, 0xC0	; 192
    60cc:	99 e0       	ldi	r25, 0x09	; 9
    60ce:	fc 01       	movw	r30, r24
    60d0:	83 81       	ldd	r24, Z+3	; 0x03
    60d2:	89 83       	std	Y+1, r24	; 0x01
	return data;
    60d4:	89 81       	ldd	r24, Y+1	; 0x01
    60d6:	0f 90       	pop	r0
    60d8:	0f 90       	pop	r0
    60da:	df 91       	pop	r29
    60dc:	cf 91       	pop	r28
    60de:	08 95       	ret

000060e0 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    60e0:	0f 93       	push	r16
    60e2:	cf 93       	push	r28
    60e4:	df 93       	push	r29
    60e6:	00 d0       	rcall	.+0      	; 0x60e8 <CCPWrite+0x8>
    60e8:	00 d0       	rcall	.+0      	; 0x60ea <CCPWrite+0xa>
    60ea:	cd b7       	in	r28, 0x3d	; 61
    60ec:	de b7       	in	r29, 0x3e	; 62
    60ee:	8c 83       	std	Y+4, r24	; 0x04
    60f0:	9d 83       	std	Y+5, r25	; 0x05
    60f2:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    60f4:	8f e3       	ldi	r24, 0x3F	; 63
    60f6:	90 e0       	ldi	r25, 0x00	; 0
    60f8:	fc 01       	movw	r30, r24
    60fa:	80 81       	ld	r24, Z
    60fc:	8b 83       	std	Y+3, r24	; 0x03
    60fe:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    6100:	8c 81       	ldd	r24, Y+4	; 0x04
    6102:	9d 81       	ldd	r25, Y+5	; 0x05
    6104:	89 83       	std	Y+1, r24	; 0x01
    6106:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    6108:	8b e3       	ldi	r24, 0x3B	; 59
    610a:	90 e0       	ldi	r25, 0x00	; 0
    610c:	fc 01       	movw	r30, r24
    610e:	10 82       	st	Z, r1
#endif
	asm volatile(
    6110:	89 81       	ldd	r24, Y+1	; 0x01
    6112:	9a 81       	ldd	r25, Y+2	; 0x02
    6114:	2e 81       	ldd	r18, Y+6	; 0x06
    6116:	fc 01       	movw	r30, r24
    6118:	08 ed       	ldi	r16, 0xD8	; 216
    611a:	04 bf       	out	0x34, r16	; 52
    611c:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    611e:	8f e3       	ldi	r24, 0x3F	; 63
    6120:	90 e0       	ldi	r25, 0x00	; 0
    6122:	2b 81       	ldd	r18, Y+3	; 0x03
    6124:	fc 01       	movw	r30, r24
    6126:	20 83       	st	Z, r18
#endif
}
    6128:	26 96       	adiw	r28, 0x06	; 6
    612a:	cd bf       	out	0x3d, r28	; 61
    612c:	de bf       	out	0x3e, r29	; 62
    612e:	df 91       	pop	r29
    6130:	cf 91       	pop	r28
    6132:	0f 91       	pop	r16
    6134:	08 95       	ret

00006136 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6136:	cf 93       	push	r28
    6138:	df 93       	push	r29
    613a:	00 d0       	rcall	.+0      	; 0x613c <CLKSYS_XOSC_Config+0x6>
    613c:	cd b7       	in	r28, 0x3d	; 61
    613e:	de b7       	in	r29, 0x3e	; 62
    6140:	89 83       	std	Y+1, r24	; 0x01
    6142:	6a 83       	std	Y+2, r22	; 0x02
    6144:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6146:	80 e5       	ldi	r24, 0x50	; 80
    6148:	90 e0       	ldi	r25, 0x00	; 0
    614a:	2a 81       	ldd	r18, Y+2	; 0x02
    614c:	22 23       	and	r18, r18
    614e:	11 f0       	breq	.+4      	; 0x6154 <CLKSYS_XOSC_Config+0x1e>
    6150:	20 e2       	ldi	r18, 0x20	; 32
    6152:	01 c0       	rjmp	.+2      	; 0x6156 <CLKSYS_XOSC_Config+0x20>
    6154:	20 e0       	ldi	r18, 0x00	; 0
    6156:	39 81       	ldd	r19, Y+1	; 0x01
    6158:	32 2b       	or	r19, r18
    615a:	2b 81       	ldd	r18, Y+3	; 0x03
    615c:	23 2b       	or	r18, r19
    615e:	fc 01       	movw	r30, r24
    6160:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    6162:	23 96       	adiw	r28, 0x03	; 3
    6164:	cd bf       	out	0x3d, r28	; 61
    6166:	de bf       	out	0x3e, r29	; 62
    6168:	df 91       	pop	r29
    616a:	cf 91       	pop	r28
    616c:	08 95       	ret

0000616e <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    616e:	cf 93       	push	r28
    6170:	df 93       	push	r29
    6172:	0f 92       	push	r0
    6174:	0f 92       	push	r0
    6176:	cd b7       	in	r28, 0x3d	; 61
    6178:	de b7       	in	r29, 0x3e	; 62
    617a:	89 83       	std	Y+1, r24	; 0x01
    617c:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    617e:	8a 81       	ldd	r24, Y+2	; 0x02
    6180:	8f 71       	andi	r24, 0x1F	; 31
    6182:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    6184:	80 e5       	ldi	r24, 0x50	; 80
    6186:	90 e0       	ldi	r25, 0x00	; 0
    6188:	39 81       	ldd	r19, Y+1	; 0x01
    618a:	2a 81       	ldd	r18, Y+2	; 0x02
    618c:	23 2b       	or	r18, r19
    618e:	fc 01       	movw	r30, r24
    6190:	25 83       	std	Z+5, r18	; 0x05
}
    6192:	0f 90       	pop	r0
    6194:	0f 90       	pop	r0
    6196:	df 91       	pop	r29
    6198:	cf 91       	pop	r28
    619a:	08 95       	ret

0000619c <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    619c:	cf 93       	push	r28
    619e:	df 93       	push	r29
    61a0:	0f 92       	push	r0
    61a2:	0f 92       	push	r0
    61a4:	cd b7       	in	r28, 0x3d	; 61
    61a6:	de b7       	in	r29, 0x3e	; 62
    61a8:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    61aa:	80 e5       	ldi	r24, 0x50	; 80
    61ac:	90 e0       	ldi	r25, 0x00	; 0
    61ae:	20 e5       	ldi	r18, 0x50	; 80
    61b0:	30 e0       	ldi	r19, 0x00	; 0
    61b2:	f9 01       	movw	r30, r18
    61b4:	20 81       	ld	r18, Z
    61b6:	32 2f       	mov	r19, r18
    61b8:	2a 81       	ldd	r18, Y+2	; 0x02
    61ba:	20 95       	com	r18
    61bc:	23 23       	and	r18, r19
    61be:	fc 01       	movw	r30, r24
    61c0:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    61c2:	80 e5       	ldi	r24, 0x50	; 80
    61c4:	90 e0       	ldi	r25, 0x00	; 0
    61c6:	fc 01       	movw	r30, r24
    61c8:	90 81       	ld	r25, Z
    61ca:	8a 81       	ldd	r24, Y+2	; 0x02
    61cc:	89 23       	and	r24, r25
    61ce:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    61d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    61d2:	0f 90       	pop	r0
    61d4:	0f 90       	pop	r0
    61d6:	df 91       	pop	r29
    61d8:	cf 91       	pop	r28
    61da:	08 95       	ret

000061dc <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    61dc:	cf 93       	push	r28
    61de:	df 93       	push	r29
    61e0:	00 d0       	rcall	.+0      	; 0x61e2 <CLKSYS_Prescalers_Config+0x6>
    61e2:	cd b7       	in	r28, 0x3d	; 61
    61e4:	de b7       	in	r29, 0x3e	; 62
    61e6:	8a 83       	std	Y+2, r24	; 0x02
    61e8:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    61ea:	9a 81       	ldd	r25, Y+2	; 0x02
    61ec:	8b 81       	ldd	r24, Y+3	; 0x03
    61ee:	89 2b       	or	r24, r25
    61f0:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    61f2:	81 e4       	ldi	r24, 0x41	; 65
    61f4:	90 e0       	ldi	r25, 0x00	; 0
    61f6:	69 81       	ldd	r22, Y+1	; 0x01
    61f8:	0e 94 70 30 	call	0x60e0	; 0x60e0 <CCPWrite>
}
    61fc:	23 96       	adiw	r28, 0x03	; 3
    61fe:	cd bf       	out	0x3d, r28	; 61
    6200:	de bf       	out	0x3e, r29	; 62
    6202:	df 91       	pop	r29
    6204:	cf 91       	pop	r28
    6206:	08 95       	ret

00006208 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6208:	cf 93       	push	r28
    620a:	df 93       	push	r29
    620c:	0f 92       	push	r0
    620e:	0f 92       	push	r0
    6210:	cd b7       	in	r28, 0x3d	; 61
    6212:	de b7       	in	r29, 0x3e	; 62
    6214:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    6216:	80 e4       	ldi	r24, 0x40	; 64
    6218:	90 e0       	ldi	r25, 0x00	; 0
    621a:	fc 01       	movw	r30, r24
    621c:	80 81       	ld	r24, Z
    621e:	98 2f       	mov	r25, r24
    6220:	98 7f       	andi	r25, 0xF8	; 248
    6222:	8a 81       	ldd	r24, Y+2	; 0x02
    6224:	89 2b       	or	r24, r25
    6226:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    6228:	80 e4       	ldi	r24, 0x40	; 64
    622a:	90 e0       	ldi	r25, 0x00	; 0
    622c:	69 81       	ldd	r22, Y+1	; 0x01
    622e:	0e 94 70 30 	call	0x60e0	; 0x60e0 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    6232:	80 e4       	ldi	r24, 0x40	; 64
    6234:	90 e0       	ldi	r25, 0x00	; 0
    6236:	fc 01       	movw	r30, r24
    6238:	90 81       	ld	r25, Z
    623a:	8a 81       	ldd	r24, Y+2	; 0x02
    623c:	89 23       	and	r24, r25
    623e:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    6240:	89 81       	ldd	r24, Y+1	; 0x01
}
    6242:	0f 90       	pop	r0
    6244:	0f 90       	pop	r0
    6246:	df 91       	pop	r29
    6248:	cf 91       	pop	r28
    624a:	08 95       	ret

0000624c <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    624c:	cf 93       	push	r28
    624e:	df 93       	push	r29
    6250:	0f 92       	push	r0
    6252:	cd b7       	in	r28, 0x3d	; 61
    6254:	de b7       	in	r29, 0x3e	; 62
    6256:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6258:	80 e4       	ldi	r24, 0x40	; 64
    625a:	90 e0       	ldi	r25, 0x00	; 0
    625c:	20 e4       	ldi	r18, 0x40	; 64
    625e:	30 e0       	ldi	r19, 0x00	; 0
    6260:	f9 01       	movw	r30, r18
    6262:	23 81       	ldd	r18, Z+3	; 0x03
    6264:	32 2f       	mov	r19, r18
    6266:	31 7f       	andi	r19, 0xF1	; 241
    6268:	29 81       	ldd	r18, Y+1	; 0x01
    626a:	23 2b       	or	r18, r19
    626c:	21 60       	ori	r18, 0x01	; 1
    626e:	fc 01       	movw	r30, r24
    6270:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    6272:	0f 90       	pop	r0
    6274:	df 91       	pop	r29
    6276:	cf 91       	pop	r28
    6278:	08 95       	ret

0000627a <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    627a:	cf 93       	push	r28
    627c:	df 93       	push	r29
    627e:	0f 92       	push	r0
    6280:	0f 92       	push	r0
    6282:	cd b7       	in	r28, 0x3d	; 61
    6284:	de b7       	in	r29, 0x3e	; 62
    6286:	89 83       	std	Y+1, r24	; 0x01
    6288:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    628a:	80 e5       	ldi	r24, 0x50	; 80
    628c:	90 e0       	ldi	r25, 0x00	; 0
    628e:	20 e5       	ldi	r18, 0x50	; 80
    6290:	30 e0       	ldi	r19, 0x00	; 0
    6292:	f9 01       	movw	r30, r18
    6294:	26 81       	ldd	r18, Z+6	; 0x06
    6296:	32 2f       	mov	r19, r18
    6298:	29 81       	ldd	r18, Y+1	; 0x01
    629a:	20 95       	com	r18
    629c:	32 23       	and	r19, r18
    629e:	2a 81       	ldd	r18, Y+2	; 0x02
    62a0:	22 23       	and	r18, r18
    62a2:	11 f0       	breq	.+4      	; 0x62a8 <CLKSYS_AutoCalibration_Enable+0x2e>
    62a4:	29 81       	ldd	r18, Y+1	; 0x01
    62a6:	01 c0       	rjmp	.+2      	; 0x62aa <CLKSYS_AutoCalibration_Enable+0x30>
    62a8:	20 e0       	ldi	r18, 0x00	; 0
    62aa:	23 2b       	or	r18, r19
    62ac:	fc 01       	movw	r30, r24
    62ae:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    62b0:	89 81       	ldd	r24, Y+1	; 0x01
    62b2:	81 30       	cpi	r24, 0x01	; 1
    62b4:	51 f4       	brne	.+20     	; 0x62ca <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    62b6:	88 e6       	ldi	r24, 0x68	; 104
    62b8:	90 e0       	ldi	r25, 0x00	; 0
    62ba:	28 e6       	ldi	r18, 0x68	; 104
    62bc:	30 e0       	ldi	r19, 0x00	; 0
    62be:	f9 01       	movw	r30, r18
    62c0:	20 81       	ld	r18, Z
    62c2:	21 60       	ori	r18, 0x01	; 1
    62c4:	fc 01       	movw	r30, r24
    62c6:	20 83       	st	Z, r18
    62c8:	0c c0       	rjmp	.+24     	; 0x62e2 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    62ca:	89 81       	ldd	r24, Y+1	; 0x01
    62cc:	82 30       	cpi	r24, 0x02	; 2
    62ce:	49 f4       	brne	.+18     	; 0x62e2 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    62d0:	80 e6       	ldi	r24, 0x60	; 96
    62d2:	90 e0       	ldi	r25, 0x00	; 0
    62d4:	20 e6       	ldi	r18, 0x60	; 96
    62d6:	30 e0       	ldi	r19, 0x00	; 0
    62d8:	f9 01       	movw	r30, r18
    62da:	20 81       	ld	r18, Z
    62dc:	21 60       	ori	r18, 0x01	; 1
    62de:	fc 01       	movw	r30, r24
    62e0:	20 83       	st	Z, r18
	}
}
    62e2:	0f 90       	pop	r0
    62e4:	0f 90       	pop	r0
    62e6:	df 91       	pop	r29
    62e8:	cf 91       	pop	r28
    62ea:	08 95       	ret

000062ec <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    62ec:	cf 93       	push	r28
    62ee:	df 93       	push	r29
    62f0:	cd b7       	in	r28, 0x3d	; 61
    62f2:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    62f4:	83 e5       	ldi	r24, 0x53	; 83
    62f6:	90 e0       	ldi	r25, 0x00	; 0
    62f8:	63 e0       	ldi	r22, 0x03	; 3
    62fa:	0e 94 70 30 	call	0x60e0	; 0x60e0 <CCPWrite>
}
    62fe:	df 91       	pop	r29
    6300:	cf 91       	pop	r28
    6302:	08 95       	ret

00006304 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    6304:	cf 93       	push	r28
    6306:	df 93       	push	r29
    6308:	cd b7       	in	r28, 0x3d	; 61
    630a:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    630c:	82 e4       	ldi	r24, 0x42	; 66
    630e:	90 e0       	ldi	r25, 0x00	; 0
    6310:	61 e0       	ldi	r22, 0x01	; 1
    6312:	0e 94 70 30 	call	0x60e0	; 0x60e0 <CCPWrite>
}
    6316:	df 91       	pop	r29
    6318:	cf 91       	pop	r28
    631a:	08 95       	ret

0000631c <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    631c:	cf 93       	push	r28
    631e:	df 93       	push	r29
    6320:	cd b7       	in	r28, 0x3d	; 61
    6322:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6324:	80 ec       	ldi	r24, 0xC0	; 192
    6326:	60 e0       	ldi	r22, 0x00	; 0
    6328:	4b e0       	ldi	r20, 0x0B	; 11
    632a:	0e 94 9b 30 	call	0x6136	; 0x6136 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    632e:	80 e5       	ldi	r24, 0x50	; 80
    6330:	90 e0       	ldi	r25, 0x00	; 0
    6332:	20 e5       	ldi	r18, 0x50	; 80
    6334:	30 e0       	ldi	r19, 0x00	; 0
    6336:	f9 01       	movw	r30, r18
    6338:	20 81       	ld	r18, Z
    633a:	28 60       	ori	r18, 0x08	; 8
    633c:	fc 01       	movw	r30, r24
    633e:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    6340:	80 e5       	ldi	r24, 0x50	; 80
    6342:	90 e0       	ldi	r25, 0x00	; 0
    6344:	fc 01       	movw	r30, r24
    6346:	81 81       	ldd	r24, Z+1	; 0x01
    6348:	88 2f       	mov	r24, r24
    634a:	90 e0       	ldi	r25, 0x00	; 0
    634c:	88 70       	andi	r24, 0x08	; 8
    634e:	90 70       	andi	r25, 0x00	; 0
    6350:	00 97       	sbiw	r24, 0x00	; 0
    6352:	b1 f3       	breq	.-20     	; 0x6340 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6354:	80 ec       	ldi	r24, 0xC0	; 192
    6356:	62 e0       	ldi	r22, 0x02	; 2
    6358:	0e 94 b7 30 	call	0x616e	; 0x616e <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    635c:	80 e5       	ldi	r24, 0x50	; 80
    635e:	90 e0       	ldi	r25, 0x00	; 0
    6360:	20 e5       	ldi	r18, 0x50	; 80
    6362:	30 e0       	ldi	r19, 0x00	; 0
    6364:	f9 01       	movw	r30, r18
    6366:	20 81       	ld	r18, Z
    6368:	20 61       	ori	r18, 0x10	; 16
    636a:	fc 01       	movw	r30, r24
    636c:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    636e:	80 e5       	ldi	r24, 0x50	; 80
    6370:	90 e0       	ldi	r25, 0x00	; 0
    6372:	fc 01       	movw	r30, r24
    6374:	81 81       	ldd	r24, Z+1	; 0x01
    6376:	88 2f       	mov	r24, r24
    6378:	90 e0       	ldi	r25, 0x00	; 0
    637a:	80 71       	andi	r24, 0x10	; 16
    637c:	90 70       	andi	r25, 0x00	; 0
    637e:	00 97       	sbiw	r24, 0x00	; 0
    6380:	b1 f3       	breq	.-20     	; 0x636e <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    6382:	84 e0       	ldi	r24, 0x04	; 4
    6384:	0e 94 04 31 	call	0x6208	; 0x6208 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6388:	81 e0       	ldi	r24, 0x01	; 1
    638a:	0e 94 ce 30 	call	0x619c	; 0x619c <CLKSYS_Disable>
}
    638e:	df 91       	pop	r29
    6390:	cf 91       	pop	r28
    6392:	08 95       	ret

00006394 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    6394:	cf 93       	push	r28
    6396:	df 93       	push	r29
    6398:	cd b7       	in	r28, 0x3d	; 61
    639a:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    639c:	80 e5       	ldi	r24, 0x50	; 80
    639e:	90 e0       	ldi	r25, 0x00	; 0
    63a0:	20 e5       	ldi	r18, 0x50	; 80
    63a2:	30 e0       	ldi	r19, 0x00	; 0
    63a4:	f9 01       	movw	r30, r18
    63a6:	20 81       	ld	r18, Z
    63a8:	22 60       	ori	r18, 0x02	; 2
    63aa:	fc 01       	movw	r30, r24
    63ac:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    63ae:	80 e0       	ldi	r24, 0x00	; 0
    63b0:	61 e0       	ldi	r22, 0x01	; 1
    63b2:	0e 94 ee 30 	call	0x61dc	; 0x61dc <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    63b6:	80 e5       	ldi	r24, 0x50	; 80
    63b8:	90 e0       	ldi	r25, 0x00	; 0
    63ba:	fc 01       	movw	r30, r24
    63bc:	81 81       	ldd	r24, Z+1	; 0x01
    63be:	88 2f       	mov	r24, r24
    63c0:	90 e0       	ldi	r25, 0x00	; 0
    63c2:	82 70       	andi	r24, 0x02	; 2
    63c4:	90 70       	andi	r25, 0x00	; 0
    63c6:	00 97       	sbiw	r24, 0x00	; 0
    63c8:	b1 f3       	breq	.-20     	; 0x63b6 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    63ca:	81 e0       	ldi	r24, 0x01	; 1
    63cc:	0e 94 04 31 	call	0x6208	; 0x6208 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    63d0:	81 e0       	ldi	r24, 0x01	; 1
    63d2:	0e 94 ce 30 	call	0x619c	; 0x619c <CLKSYS_Disable>
	
}
    63d6:	df 91       	pop	r29
    63d8:	cf 91       	pop	r28
    63da:	08 95       	ret

000063dc <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    63dc:	cf 93       	push	r28
    63de:	df 93       	push	r29
    63e0:	cd b7       	in	r28, 0x3d	; 61
    63e2:	de b7       	in	r29, 0x3e	; 62
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    63e4:	80 e5       	ldi	r24, 0x50	; 80
    63e6:	90 e0       	ldi	r25, 0x00	; 0
    63e8:	20 e5       	ldi	r18, 0x50	; 80
    63ea:	30 e0       	ldi	r19, 0x00	; 0
    63ec:	f9 01       	movw	r30, r18
    63ee:	20 81       	ld	r18, Z
    63f0:	22 60       	ori	r18, 0x02	; 2
    63f2:	fc 01       	movw	r30, r24
    63f4:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    63f6:	80 e0       	ldi	r24, 0x00	; 0
    63f8:	60 e0       	ldi	r22, 0x00	; 0
    63fa:	0e 94 ee 30 	call	0x61dc	; 0x61dc <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    63fe:	80 e5       	ldi	r24, 0x50	; 80
    6400:	90 e0       	ldi	r25, 0x00	; 0
    6402:	fc 01       	movw	r30, r24
    6404:	81 81       	ldd	r24, Z+1	; 0x01
    6406:	88 2f       	mov	r24, r24
    6408:	90 e0       	ldi	r25, 0x00	; 0
    640a:	82 70       	andi	r24, 0x02	; 2
    640c:	90 70       	andi	r25, 0x00	; 0
    640e:	00 97       	sbiw	r24, 0x00	; 0
    6410:	b1 f3       	breq	.-20     	; 0x63fe <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6412:	81 e0       	ldi	r24, 0x01	; 1
    6414:	0e 94 04 31 	call	0x6208	; 0x6208 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6418:	81 e0       	ldi	r24, 0x01	; 1
    641a:	0e 94 ce 30 	call	0x619c	; 0x619c <CLKSYS_Disable>
	
}
    641e:	df 91       	pop	r29
    6420:	cf 91       	pop	r28
    6422:	08 95       	ret

00006424 <portExCS>:


void portExCS(uint8_t write) {
    6424:	0f 93       	push	r16
    6426:	1f 93       	push	r17
    6428:	cf 93       	push	r28
    642a:	df 93       	push	r29
    642c:	cd b7       	in	r28, 0x3d	; 61
    642e:	de b7       	in	r29, 0x3e	; 62
    6430:	69 97       	sbiw	r28, 0x19	; 25
    6432:	cd bf       	out	0x3d, r28	; 61
    6434:	de bf       	out	0x3e, r29	; 62
    6436:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6438:	89 8d       	ldd	r24, Y+25	; 0x19
    643a:	88 23       	and	r24, r24
    643c:	31 f0       	breq	.+12     	; 0x644a <portExCS+0x26>
    643e:	80 e0       	ldi	r24, 0x00	; 0
    6440:	96 e0       	ldi	r25, 0x06	; 6
    6442:	28 e0       	ldi	r18, 0x08	; 8
    6444:	fc 01       	movw	r30, r24
    6446:	26 83       	std	Z+6, r18	; 0x06
    6448:	05 c0       	rjmp	.+10     	; 0x6454 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    644a:	80 e0       	ldi	r24, 0x00	; 0
    644c:	96 e0       	ldi	r25, 0x06	; 6
    644e:	28 e0       	ldi	r18, 0x08	; 8
    6450:	fc 01       	movw	r30, r24
    6452:	25 83       	std	Z+5, r18	; 0x05
    6454:	80 e0       	ldi	r24, 0x00	; 0
    6456:	90 e0       	ldi	r25, 0x00	; 0
    6458:	a0 e2       	ldi	r26, 0x20	; 32
    645a:	b1 e4       	ldi	r27, 0x41	; 65
    645c:	89 83       	std	Y+1, r24	; 0x01
    645e:	9a 83       	std	Y+2, r25	; 0x02
    6460:	ab 83       	std	Y+3, r26	; 0x03
    6462:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6464:	69 81       	ldd	r22, Y+1	; 0x01
    6466:	7a 81       	ldd	r23, Y+2	; 0x02
    6468:	8b 81       	ldd	r24, Y+3	; 0x03
    646a:	9c 81       	ldd	r25, Y+4	; 0x04
    646c:	2b ea       	ldi	r18, 0xAB	; 171
    646e:	3a ea       	ldi	r19, 0xAA	; 170
    6470:	4a e2       	ldi	r20, 0x2A	; 42
    6472:	51 e4       	ldi	r21, 0x41	; 65
    6474:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6478:	dc 01       	movw	r26, r24
    647a:	cb 01       	movw	r24, r22
    647c:	8d 83       	std	Y+5, r24	; 0x05
    647e:	9e 83       	std	Y+6, r25	; 0x06
    6480:	af 83       	std	Y+7, r26	; 0x07
    6482:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6484:	11 e0       	ldi	r17, 0x01	; 1
    6486:	6d 81       	ldd	r22, Y+5	; 0x05
    6488:	7e 81       	ldd	r23, Y+6	; 0x06
    648a:	8f 81       	ldd	r24, Y+7	; 0x07
    648c:	98 85       	ldd	r25, Y+8	; 0x08
    648e:	20 e0       	ldi	r18, 0x00	; 0
    6490:	30 e0       	ldi	r19, 0x00	; 0
    6492:	40 e8       	ldi	r20, 0x80	; 128
    6494:	5f e3       	ldi	r21, 0x3F	; 63
    6496:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    649a:	88 23       	and	r24, r24
    649c:	0c f0       	brlt	.+2      	; 0x64a0 <portExCS+0x7c>
    649e:	10 e0       	ldi	r17, 0x00	; 0
    64a0:	11 23       	and	r17, r17
    64a2:	19 f0       	breq	.+6      	; 0x64aa <portExCS+0x86>
		__ticks = 1;
    64a4:	81 e0       	ldi	r24, 0x01	; 1
    64a6:	89 87       	std	Y+9, r24	; 0x09
    64a8:	a3 c0       	rjmp	.+326    	; 0x65f0 <portExCS+0x1cc>
	else if (__tmp > 255)
    64aa:	11 e0       	ldi	r17, 0x01	; 1
    64ac:	6d 81       	ldd	r22, Y+5	; 0x05
    64ae:	7e 81       	ldd	r23, Y+6	; 0x06
    64b0:	8f 81       	ldd	r24, Y+7	; 0x07
    64b2:	98 85       	ldd	r25, Y+8	; 0x08
    64b4:	20 e0       	ldi	r18, 0x00	; 0
    64b6:	30 e0       	ldi	r19, 0x00	; 0
    64b8:	4f e7       	ldi	r20, 0x7F	; 127
    64ba:	53 e4       	ldi	r21, 0x43	; 67
    64bc:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    64c0:	18 16       	cp	r1, r24
    64c2:	0c f0       	brlt	.+2      	; 0x64c6 <portExCS+0xa2>
    64c4:	10 e0       	ldi	r17, 0x00	; 0
    64c6:	11 23       	and	r17, r17
    64c8:	09 f4       	brne	.+2      	; 0x64cc <portExCS+0xa8>
    64ca:	89 c0       	rjmp	.+274    	; 0x65de <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    64cc:	69 81       	ldd	r22, Y+1	; 0x01
    64ce:	7a 81       	ldd	r23, Y+2	; 0x02
    64d0:	8b 81       	ldd	r24, Y+3	; 0x03
    64d2:	9c 81       	ldd	r25, Y+4	; 0x04
    64d4:	20 e0       	ldi	r18, 0x00	; 0
    64d6:	30 e0       	ldi	r19, 0x00	; 0
    64d8:	4a e7       	ldi	r20, 0x7A	; 122
    64da:	54 e4       	ldi	r21, 0x44	; 68
    64dc:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    64e0:	dc 01       	movw	r26, r24
    64e2:	cb 01       	movw	r24, r22
    64e4:	8a 87       	std	Y+10, r24	; 0x0a
    64e6:	9b 87       	std	Y+11, r25	; 0x0b
    64e8:	ac 87       	std	Y+12, r26	; 0x0c
    64ea:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    64ec:	6a 85       	ldd	r22, Y+10	; 0x0a
    64ee:	7b 85       	ldd	r23, Y+11	; 0x0b
    64f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    64f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    64f4:	20 e0       	ldi	r18, 0x00	; 0
    64f6:	30 e0       	ldi	r19, 0x00	; 0
    64f8:	4a ef       	ldi	r20, 0xFA	; 250
    64fa:	55 e4       	ldi	r21, 0x45	; 69
    64fc:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6500:	dc 01       	movw	r26, r24
    6502:	cb 01       	movw	r24, r22
    6504:	8e 87       	std	Y+14, r24	; 0x0e
    6506:	9f 87       	std	Y+15, r25	; 0x0f
    6508:	a8 8b       	std	Y+16, r26	; 0x10
    650a:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    650c:	11 e0       	ldi	r17, 0x01	; 1
    650e:	6e 85       	ldd	r22, Y+14	; 0x0e
    6510:	7f 85       	ldd	r23, Y+15	; 0x0f
    6512:	88 89       	ldd	r24, Y+16	; 0x10
    6514:	99 89       	ldd	r25, Y+17	; 0x11
    6516:	20 e0       	ldi	r18, 0x00	; 0
    6518:	30 e0       	ldi	r19, 0x00	; 0
    651a:	40 e8       	ldi	r20, 0x80	; 128
    651c:	5f e3       	ldi	r21, 0x3F	; 63
    651e:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    6522:	88 23       	and	r24, r24
    6524:	0c f0       	brlt	.+2      	; 0x6528 <portExCS+0x104>
    6526:	10 e0       	ldi	r17, 0x00	; 0
    6528:	11 23       	and	r17, r17
    652a:	29 f0       	breq	.+10     	; 0x6536 <portExCS+0x112>
		__ticks = 1;
    652c:	81 e0       	ldi	r24, 0x01	; 1
    652e:	90 e0       	ldi	r25, 0x00	; 0
    6530:	8a 8b       	std	Y+18, r24	; 0x12
    6532:	9b 8b       	std	Y+19, r25	; 0x13
    6534:	46 c0       	rjmp	.+140    	; 0x65c2 <portExCS+0x19e>
	else if (__tmp > 65535)
    6536:	11 e0       	ldi	r17, 0x01	; 1
    6538:	6e 85       	ldd	r22, Y+14	; 0x0e
    653a:	7f 85       	ldd	r23, Y+15	; 0x0f
    653c:	88 89       	ldd	r24, Y+16	; 0x10
    653e:	99 89       	ldd	r25, Y+17	; 0x11
    6540:	20 e0       	ldi	r18, 0x00	; 0
    6542:	3f ef       	ldi	r19, 0xFF	; 255
    6544:	4f e7       	ldi	r20, 0x7F	; 127
    6546:	57 e4       	ldi	r21, 0x47	; 71
    6548:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    654c:	18 16       	cp	r1, r24
    654e:	0c f0       	brlt	.+2      	; 0x6552 <portExCS+0x12e>
    6550:	10 e0       	ldi	r17, 0x00	; 0
    6552:	11 23       	and	r17, r17
    6554:	61 f1       	breq	.+88     	; 0x65ae <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6556:	6a 85       	ldd	r22, Y+10	; 0x0a
    6558:	7b 85       	ldd	r23, Y+11	; 0x0b
    655a:	8c 85       	ldd	r24, Y+12	; 0x0c
    655c:	9d 85       	ldd	r25, Y+13	; 0x0d
    655e:	20 e0       	ldi	r18, 0x00	; 0
    6560:	30 e0       	ldi	r19, 0x00	; 0
    6562:	40 e2       	ldi	r20, 0x20	; 32
    6564:	51 e4       	ldi	r21, 0x41	; 65
    6566:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    656a:	dc 01       	movw	r26, r24
    656c:	cb 01       	movw	r24, r22
    656e:	bc 01       	movw	r22, r24
    6570:	cd 01       	movw	r24, r26
    6572:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6576:	dc 01       	movw	r26, r24
    6578:	cb 01       	movw	r24, r22
    657a:	8a 8b       	std	Y+18, r24	; 0x12
    657c:	9b 8b       	std	Y+19, r25	; 0x13
    657e:	12 c0       	rjmp	.+36     	; 0x65a4 <portExCS+0x180>
    6580:	80 e2       	ldi	r24, 0x20	; 32
    6582:	93 e0       	ldi	r25, 0x03	; 3
    6584:	8c 8b       	std	Y+20, r24	; 0x14
    6586:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6588:	8c 89       	ldd	r24, Y+20	; 0x14
    658a:	9d 89       	ldd	r25, Y+21	; 0x15
    658c:	8c 01       	movw	r16, r24
    658e:	c8 01       	movw	r24, r16
    6590:	01 97       	sbiw	r24, 0x01	; 1
    6592:	f1 f7       	brne	.-4      	; 0x6590 <portExCS+0x16c>
    6594:	8c 01       	movw	r16, r24
    6596:	0c 8b       	std	Y+20, r16	; 0x14
    6598:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    659a:	8a 89       	ldd	r24, Y+18	; 0x12
    659c:	9b 89       	ldd	r25, Y+19	; 0x13
    659e:	01 97       	sbiw	r24, 0x01	; 1
    65a0:	8a 8b       	std	Y+18, r24	; 0x12
    65a2:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    65a4:	8a 89       	ldd	r24, Y+18	; 0x12
    65a6:	9b 89       	ldd	r25, Y+19	; 0x13
    65a8:	00 97       	sbiw	r24, 0x00	; 0
    65aa:	51 f7       	brne	.-44     	; 0x6580 <portExCS+0x15c>
    65ac:	28 c0       	rjmp	.+80     	; 0x65fe <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    65ae:	6e 85       	ldd	r22, Y+14	; 0x0e
    65b0:	7f 85       	ldd	r23, Y+15	; 0x0f
    65b2:	88 89       	ldd	r24, Y+16	; 0x10
    65b4:	99 89       	ldd	r25, Y+17	; 0x11
    65b6:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    65ba:	dc 01       	movw	r26, r24
    65bc:	cb 01       	movw	r24, r22
    65be:	8a 8b       	std	Y+18, r24	; 0x12
    65c0:	9b 8b       	std	Y+19, r25	; 0x13
    65c2:	8a 89       	ldd	r24, Y+18	; 0x12
    65c4:	9b 89       	ldd	r25, Y+19	; 0x13
    65c6:	8e 8b       	std	Y+22, r24	; 0x16
    65c8:	9f 8b       	std	Y+23, r25	; 0x17
    65ca:	8e 89       	ldd	r24, Y+22	; 0x16
    65cc:	9f 89       	ldd	r25, Y+23	; 0x17
    65ce:	8c 01       	movw	r16, r24
    65d0:	f8 01       	movw	r30, r16
    65d2:	31 97       	sbiw	r30, 0x01	; 1
    65d4:	f1 f7       	brne	.-4      	; 0x65d2 <portExCS+0x1ae>
    65d6:	8f 01       	movw	r16, r30
    65d8:	0e 8b       	std	Y+22, r16	; 0x16
    65da:	1f 8b       	std	Y+23, r17	; 0x17
    65dc:	10 c0       	rjmp	.+32     	; 0x65fe <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    65de:	6d 81       	ldd	r22, Y+5	; 0x05
    65e0:	7e 81       	ldd	r23, Y+6	; 0x06
    65e2:	8f 81       	ldd	r24, Y+7	; 0x07
    65e4:	98 85       	ldd	r25, Y+8	; 0x08
    65e6:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    65ea:	dc 01       	movw	r26, r24
    65ec:	cb 01       	movw	r24, r22
    65ee:	89 87       	std	Y+9, r24	; 0x09
    65f0:	89 85       	ldd	r24, Y+9	; 0x09
    65f2:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    65f4:	88 8d       	ldd	r24, Y+24	; 0x18
    65f6:	18 2f       	mov	r17, r24
    65f8:	1a 95       	dec	r17
    65fa:	f1 f7       	brne	.-4      	; 0x65f8 <portExCS+0x1d4>
    65fc:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    65fe:	69 96       	adiw	r28, 0x19	; 25
    6600:	cd bf       	out	0x3d, r28	; 61
    6602:	de bf       	out	0x3e, r29	; 62
    6604:	df 91       	pop	r29
    6606:	cf 91       	pop	r28
    6608:	1f 91       	pop	r17
    660a:	0f 91       	pop	r16
    660c:	08 95       	ret

0000660e <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    660e:	cf 93       	push	r28
    6610:	df 93       	push	r29
    6612:	00 d0       	rcall	.+0      	; 0x6614 <PortEx_DIRSET+0x6>
    6614:	cd b7       	in	r28, 0x3d	; 61
    6616:	de b7       	in	r29, 0x3e	; 62
    6618:	8a 83       	std	Y+2, r24	; 0x02
    661a:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    661c:	80 e0       	ldi	r24, 0x00	; 0
    661e:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    6622:	81 e0       	ldi	r24, 0x01	; 1
    6624:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	portExCS(TRUE);
    6628:	81 e0       	ldi	r24, 0x01	; 1
    662a:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    662e:	8b 81       	ldd	r24, Y+3	; 0x03
    6630:	88 23       	and	r24, r24
    6632:	39 f0       	breq	.+14     	; 0x6642 <PortEx_DIRSET+0x34>
    6634:	90 91 79 50 	lds	r25, 0x5079
    6638:	8a 81       	ldd	r24, Y+2	; 0x02
    663a:	89 2b       	or	r24, r25
    663c:	80 93 79 50 	sts	0x5079, r24
    6640:	06 c0       	rjmp	.+12     	; 0x664e <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6642:	90 91 d5 50 	lds	r25, 0x50D5
    6646:	8a 81       	ldd	r24, Y+2	; 0x02
    6648:	89 2b       	or	r24, r25
    664a:	80 93 d5 50 	sts	0x50D5, r24
	
	SPIBuffer[0] = PS_WRITE;
    664e:	80 e4       	ldi	r24, 0x40	; 64
    6650:	80 93 64 50 	sts	0x5064, r24
	if(bank) {
    6654:	8b 81       	ldd	r24, Y+3	; 0x03
    6656:	88 23       	and	r24, r24
    6658:	41 f0       	breq	.+16     	; 0x666a <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    665a:	10 92 65 50 	sts	0x5065, r1
		SPIBuffer[2] = ~bankA_DIR; 
    665e:	80 91 79 50 	lds	r24, 0x5079
    6662:	80 95       	com	r24
    6664:	80 93 66 50 	sts	0x5066, r24
    6668:	08 c0       	rjmp	.+16     	; 0x667a <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    666a:	81 e0       	ldi	r24, 0x01	; 1
    666c:	80 93 65 50 	sts	0x5065, r24
		SPIBuffer[2] = ~bankB_DIR;
    6670:	80 91 d5 50 	lds	r24, 0x50D5
    6674:	80 95       	com	r24
    6676:	80 93 66 50 	sts	0x5066, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    667a:	19 82       	std	Y+1, r1	; 0x01
    667c:	1b c0       	rjmp	.+54     	; 0x66b4 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    667e:	80 ec       	ldi	r24, 0xC0	; 192
    6680:	98 e0       	ldi	r25, 0x08	; 8
    6682:	29 81       	ldd	r18, Y+1	; 0x01
    6684:	22 2f       	mov	r18, r18
    6686:	30 e0       	ldi	r19, 0x00	; 0
    6688:	2c 59       	subi	r18, 0x9C	; 156
    668a:	3f 4a       	sbci	r19, 0xAF	; 175
    668c:	f9 01       	movw	r30, r18
    668e:	20 81       	ld	r18, Z
    6690:	fc 01       	movw	r30, r24
    6692:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6694:	00 00       	nop
    6696:	80 ec       	ldi	r24, 0xC0	; 192
    6698:	98 e0       	ldi	r25, 0x08	; 8
    669a:	fc 01       	movw	r30, r24
    669c:	82 81       	ldd	r24, Z+2	; 0x02
    669e:	88 23       	and	r24, r24
    66a0:	d4 f7       	brge	.-12     	; 0x6696 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    66a2:	80 ec       	ldi	r24, 0xC0	; 192
    66a4:	98 e0       	ldi	r25, 0x08	; 8
    66a6:	fc 01       	movw	r30, r24
    66a8:	83 81       	ldd	r24, Z+3	; 0x03
    66aa:	80 93 70 50 	sts	0x5070, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    66ae:	89 81       	ldd	r24, Y+1	; 0x01
    66b0:	8f 5f       	subi	r24, 0xFF	; 255
    66b2:	89 83       	std	Y+1, r24	; 0x01
    66b4:	89 81       	ldd	r24, Y+1	; 0x01
    66b6:	83 30       	cpi	r24, 0x03	; 3
    66b8:	10 f3       	brcs	.-60     	; 0x667e <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    66ba:	80 e0       	ldi	r24, 0x00	; 0
    66bc:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>
	SPICS(FALSE);
    66c0:	80 e0       	ldi	r24, 0x00	; 0
    66c2:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    66c6:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>


}
    66ca:	23 96       	adiw	r28, 0x03	; 3
    66cc:	cd bf       	out	0x3d, r28	; 61
    66ce:	de bf       	out	0x3e, r29	; 62
    66d0:	df 91       	pop	r29
    66d2:	cf 91       	pop	r28
    66d4:	08 95       	ret

000066d6 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    66d6:	cf 93       	push	r28
    66d8:	df 93       	push	r29
    66da:	00 d0       	rcall	.+0      	; 0x66dc <PortEx_DIRCLR+0x6>
    66dc:	cd b7       	in	r28, 0x3d	; 61
    66de:	de b7       	in	r29, 0x3e	; 62
    66e0:	8a 83       	std	Y+2, r24	; 0x02
    66e2:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    66e4:	80 e0       	ldi	r24, 0x00	; 0
    66e6:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    66ea:	81 e0       	ldi	r24, 0x01	; 1
    66ec:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	portExCS(TRUE);
    66f0:	81 e0       	ldi	r24, 0x01	; 1
    66f2:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    66f6:	8b 81       	ldd	r24, Y+3	; 0x03
    66f8:	88 23       	and	r24, r24
    66fa:	49 f0       	breq	.+18     	; 0x670e <PortEx_DIRCLR+0x38>
    66fc:	80 91 79 50 	lds	r24, 0x5079
    6700:	98 2f       	mov	r25, r24
    6702:	90 95       	com	r25
    6704:	8a 81       	ldd	r24, Y+2	; 0x02
    6706:	89 23       	and	r24, r25
    6708:	80 93 79 50 	sts	0x5079, r24
    670c:	08 c0       	rjmp	.+16     	; 0x671e <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    670e:	80 91 d5 50 	lds	r24, 0x50D5
    6712:	98 2f       	mov	r25, r24
    6714:	90 95       	com	r25
    6716:	8a 81       	ldd	r24, Y+2	; 0x02
    6718:	89 23       	and	r24, r25
    671a:	80 93 d5 50 	sts	0x50D5, r24
	
	SPIBuffer[0] = PS_WRITE;
    671e:	80 e4       	ldi	r24, 0x40	; 64
    6720:	80 93 64 50 	sts	0x5064, r24
	if(bank) {
    6724:	8b 81       	ldd	r24, Y+3	; 0x03
    6726:	88 23       	and	r24, r24
    6728:	41 f0       	breq	.+16     	; 0x673a <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    672a:	10 92 65 50 	sts	0x5065, r1
		SPIBuffer[2] = ~bankA_DIR; 
    672e:	80 91 79 50 	lds	r24, 0x5079
    6732:	80 95       	com	r24
    6734:	80 93 66 50 	sts	0x5066, r24
    6738:	08 c0       	rjmp	.+16     	; 0x674a <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    673a:	81 e0       	ldi	r24, 0x01	; 1
    673c:	80 93 65 50 	sts	0x5065, r24
		SPIBuffer[2] = ~bankB_DIR;
    6740:	80 91 d5 50 	lds	r24, 0x50D5
    6744:	80 95       	com	r24
    6746:	80 93 66 50 	sts	0x5066, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    674a:	19 82       	std	Y+1, r1	; 0x01
    674c:	1b c0       	rjmp	.+54     	; 0x6784 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    674e:	80 ec       	ldi	r24, 0xC0	; 192
    6750:	98 e0       	ldi	r25, 0x08	; 8
    6752:	29 81       	ldd	r18, Y+1	; 0x01
    6754:	22 2f       	mov	r18, r18
    6756:	30 e0       	ldi	r19, 0x00	; 0
    6758:	2c 59       	subi	r18, 0x9C	; 156
    675a:	3f 4a       	sbci	r19, 0xAF	; 175
    675c:	f9 01       	movw	r30, r18
    675e:	20 81       	ld	r18, Z
    6760:	fc 01       	movw	r30, r24
    6762:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6764:	00 00       	nop
    6766:	80 ec       	ldi	r24, 0xC0	; 192
    6768:	98 e0       	ldi	r25, 0x08	; 8
    676a:	fc 01       	movw	r30, r24
    676c:	82 81       	ldd	r24, Z+2	; 0x02
    676e:	88 23       	and	r24, r24
    6770:	d4 f7       	brge	.-12     	; 0x6766 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6772:	80 ec       	ldi	r24, 0xC0	; 192
    6774:	98 e0       	ldi	r25, 0x08	; 8
    6776:	fc 01       	movw	r30, r24
    6778:	83 81       	ldd	r24, Z+3	; 0x03
    677a:	80 93 70 50 	sts	0x5070, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    677e:	89 81       	ldd	r24, Y+1	; 0x01
    6780:	8f 5f       	subi	r24, 0xFF	; 255
    6782:	89 83       	std	Y+1, r24	; 0x01
    6784:	89 81       	ldd	r24, Y+1	; 0x01
    6786:	83 30       	cpi	r24, 0x03	; 3
    6788:	10 f3       	brcs	.-60     	; 0x674e <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    678a:	80 e0       	ldi	r24, 0x00	; 0
    678c:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	portExCS(FALSE);
    6790:	80 e0       	ldi	r24, 0x00	; 0
    6792:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>
	SPIDisable();
    6796:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
}
    679a:	23 96       	adiw	r28, 0x03	; 3
    679c:	cd bf       	out	0x3d, r28	; 61
    679e:	de bf       	out	0x3e, r29	; 62
    67a0:	df 91       	pop	r29
    67a2:	cf 91       	pop	r28
    67a4:	08 95       	ret

000067a6 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    67a6:	cf 93       	push	r28
    67a8:	df 93       	push	r29
    67aa:	00 d0       	rcall	.+0      	; 0x67ac <PortEx_OUTSET+0x6>
    67ac:	cd b7       	in	r28, 0x3d	; 61
    67ae:	de b7       	in	r29, 0x3e	; 62
    67b0:	8a 83       	std	Y+2, r24	; 0x02
    67b2:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    67b4:	80 e0       	ldi	r24, 0x00	; 0
    67b6:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    67ba:	81 e0       	ldi	r24, 0x01	; 1
    67bc:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	portExCS(TRUE);
    67c0:	81 e0       	ldi	r24, 0x01	; 1
    67c2:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    67c6:	8b 81       	ldd	r24, Y+3	; 0x03
    67c8:	88 23       	and	r24, r24
    67ca:	39 f0       	breq	.+14     	; 0x67da <PortEx_OUTSET+0x34>
    67cc:	90 91 d5 23 	lds	r25, 0x23D5
    67d0:	8a 81       	ldd	r24, Y+2	; 0x02
    67d2:	89 2b       	or	r24, r25
    67d4:	80 93 d5 23 	sts	0x23D5, r24
    67d8:	06 c0       	rjmp	.+12     	; 0x67e6 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    67da:	90 91 81 50 	lds	r25, 0x5081
    67de:	8a 81       	ldd	r24, Y+2	; 0x02
    67e0:	89 2b       	or	r24, r25
    67e2:	80 93 81 50 	sts	0x5081, r24
	
	SPIBuffer[0] = PS_WRITE;
    67e6:	80 e4       	ldi	r24, 0x40	; 64
    67e8:	80 93 64 50 	sts	0x5064, r24
	if(bank) {
    67ec:	8b 81       	ldd	r24, Y+3	; 0x03
    67ee:	88 23       	and	r24, r24
    67f0:	41 f0       	breq	.+16     	; 0x6802 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    67f2:	84 e1       	ldi	r24, 0x14	; 20
    67f4:	80 93 65 50 	sts	0x5065, r24
		SPIBuffer[2] = bankA_OUT;
    67f8:	80 91 d5 23 	lds	r24, 0x23D5
    67fc:	80 93 66 50 	sts	0x5066, r24
    6800:	07 c0       	rjmp	.+14     	; 0x6810 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6802:	85 e1       	ldi	r24, 0x15	; 21
    6804:	80 93 65 50 	sts	0x5065, r24
		SPIBuffer[2] = bankB_OUT; 
    6808:	80 91 81 50 	lds	r24, 0x5081
    680c:	80 93 66 50 	sts	0x5066, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6810:	19 82       	std	Y+1, r1	; 0x01
    6812:	1b c0       	rjmp	.+54     	; 0x684a <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6814:	80 ec       	ldi	r24, 0xC0	; 192
    6816:	98 e0       	ldi	r25, 0x08	; 8
    6818:	29 81       	ldd	r18, Y+1	; 0x01
    681a:	22 2f       	mov	r18, r18
    681c:	30 e0       	ldi	r19, 0x00	; 0
    681e:	2c 59       	subi	r18, 0x9C	; 156
    6820:	3f 4a       	sbci	r19, 0xAF	; 175
    6822:	f9 01       	movw	r30, r18
    6824:	20 81       	ld	r18, Z
    6826:	fc 01       	movw	r30, r24
    6828:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    682a:	00 00       	nop
    682c:	80 ec       	ldi	r24, 0xC0	; 192
    682e:	98 e0       	ldi	r25, 0x08	; 8
    6830:	fc 01       	movw	r30, r24
    6832:	82 81       	ldd	r24, Z+2	; 0x02
    6834:	88 23       	and	r24, r24
    6836:	d4 f7       	brge	.-12     	; 0x682c <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6838:	80 ec       	ldi	r24, 0xC0	; 192
    683a:	98 e0       	ldi	r25, 0x08	; 8
    683c:	fc 01       	movw	r30, r24
    683e:	83 81       	ldd	r24, Z+3	; 0x03
    6840:	80 93 70 50 	sts	0x5070, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6844:	89 81       	ldd	r24, Y+1	; 0x01
    6846:	8f 5f       	subi	r24, 0xFF	; 255
    6848:	89 83       	std	Y+1, r24	; 0x01
    684a:	89 81       	ldd	r24, Y+1	; 0x01
    684c:	83 30       	cpi	r24, 0x03	; 3
    684e:	10 f3       	brcs	.-60     	; 0x6814 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6850:	80 e0       	ldi	r24, 0x00	; 0
    6852:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	portExCS(FALSE);
    6856:	80 e0       	ldi	r24, 0x00	; 0
    6858:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>
	SPIDisable();
    685c:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
}
    6860:	23 96       	adiw	r28, 0x03	; 3
    6862:	cd bf       	out	0x3d, r28	; 61
    6864:	de bf       	out	0x3e, r29	; 62
    6866:	df 91       	pop	r29
    6868:	cf 91       	pop	r28
    686a:	08 95       	ret

0000686c <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    686c:	cf 93       	push	r28
    686e:	df 93       	push	r29
    6870:	00 d0       	rcall	.+0      	; 0x6872 <PortEx_OUTCLR+0x6>
    6872:	cd b7       	in	r28, 0x3d	; 61
    6874:	de b7       	in	r29, 0x3e	; 62
    6876:	8a 83       	std	Y+2, r24	; 0x02
    6878:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    687a:	80 e0       	ldi	r24, 0x00	; 0
    687c:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    6880:	81 e0       	ldi	r24, 0x01	; 1
    6882:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	portExCS(TRUE);
    6886:	81 e0       	ldi	r24, 0x01	; 1
    6888:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    688c:	8b 81       	ldd	r24, Y+3	; 0x03
    688e:	88 23       	and	r24, r24
    6890:	49 f0       	breq	.+18     	; 0x68a4 <PortEx_OUTCLR+0x38>
    6892:	8a 81       	ldd	r24, Y+2	; 0x02
    6894:	98 2f       	mov	r25, r24
    6896:	90 95       	com	r25
    6898:	80 91 d5 23 	lds	r24, 0x23D5
    689c:	89 23       	and	r24, r25
    689e:	80 93 d5 23 	sts	0x23D5, r24
    68a2:	08 c0       	rjmp	.+16     	; 0x68b4 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    68a4:	8a 81       	ldd	r24, Y+2	; 0x02
    68a6:	98 2f       	mov	r25, r24
    68a8:	90 95       	com	r25
    68aa:	80 91 81 50 	lds	r24, 0x5081
    68ae:	89 23       	and	r24, r25
    68b0:	80 93 81 50 	sts	0x5081, r24
	
	SPIBuffer[0] = PS_WRITE;
    68b4:	80 e4       	ldi	r24, 0x40	; 64
    68b6:	80 93 64 50 	sts	0x5064, r24
	if(bank) {
    68ba:	8b 81       	ldd	r24, Y+3	; 0x03
    68bc:	88 23       	and	r24, r24
    68be:	41 f0       	breq	.+16     	; 0x68d0 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    68c0:	84 e1       	ldi	r24, 0x14	; 20
    68c2:	80 93 65 50 	sts	0x5065, r24
		SPIBuffer[2] = bankA_OUT;
    68c6:	80 91 d5 23 	lds	r24, 0x23D5
    68ca:	80 93 66 50 	sts	0x5066, r24
    68ce:	07 c0       	rjmp	.+14     	; 0x68de <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    68d0:	85 e1       	ldi	r24, 0x15	; 21
    68d2:	80 93 65 50 	sts	0x5065, r24
		SPIBuffer[2] = bankB_OUT; 
    68d6:	80 91 81 50 	lds	r24, 0x5081
    68da:	80 93 66 50 	sts	0x5066, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    68de:	19 82       	std	Y+1, r1	; 0x01
    68e0:	1b c0       	rjmp	.+54     	; 0x6918 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    68e2:	80 ec       	ldi	r24, 0xC0	; 192
    68e4:	98 e0       	ldi	r25, 0x08	; 8
    68e6:	29 81       	ldd	r18, Y+1	; 0x01
    68e8:	22 2f       	mov	r18, r18
    68ea:	30 e0       	ldi	r19, 0x00	; 0
    68ec:	2c 59       	subi	r18, 0x9C	; 156
    68ee:	3f 4a       	sbci	r19, 0xAF	; 175
    68f0:	f9 01       	movw	r30, r18
    68f2:	20 81       	ld	r18, Z
    68f4:	fc 01       	movw	r30, r24
    68f6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    68f8:	00 00       	nop
    68fa:	80 ec       	ldi	r24, 0xC0	; 192
    68fc:	98 e0       	ldi	r25, 0x08	; 8
    68fe:	fc 01       	movw	r30, r24
    6900:	82 81       	ldd	r24, Z+2	; 0x02
    6902:	88 23       	and	r24, r24
    6904:	d4 f7       	brge	.-12     	; 0x68fa <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6906:	80 ec       	ldi	r24, 0xC0	; 192
    6908:	98 e0       	ldi	r25, 0x08	; 8
    690a:	fc 01       	movw	r30, r24
    690c:	83 81       	ldd	r24, Z+3	; 0x03
    690e:	80 93 70 50 	sts	0x5070, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6912:	89 81       	ldd	r24, Y+1	; 0x01
    6914:	8f 5f       	subi	r24, 0xFF	; 255
    6916:	89 83       	std	Y+1, r24	; 0x01
    6918:	89 81       	ldd	r24, Y+1	; 0x01
    691a:	83 30       	cpi	r24, 0x03	; 3
    691c:	10 f3       	brcs	.-60     	; 0x68e2 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    691e:	80 e0       	ldi	r24, 0x00	; 0
    6920:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	portExCS(FALSE);
    6924:	80 e0       	ldi	r24, 0x00	; 0
    6926:	0e 94 12 32 	call	0x6424	; 0x6424 <portExCS>
	SPIDisable();
    692a:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
}
    692e:	23 96       	adiw	r28, 0x03	; 3
    6930:	cd bf       	out	0x3d, r28	; 61
    6932:	de bf       	out	0x3e, r29	; 62
    6934:	df 91       	pop	r29
    6936:	cf 91       	pop	r28
    6938:	08 95       	ret

0000693a <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    693a:	0f 93       	push	r16
    693c:	1f 93       	push	r17
    693e:	cf 93       	push	r28
    6940:	df 93       	push	r29
    6942:	cd b7       	in	r28, 0x3d	; 61
    6944:	de b7       	in	r29, 0x3e	; 62
    6946:	2f 97       	sbiw	r28, 0x0f	; 15
    6948:	cd bf       	out	0x3d, r28	; 61
    694a:	de bf       	out	0x3e, r29	; 62
    694c:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
    694e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6950:	88 23       	and	r24, r24
    6952:	09 f4       	brne	.+2      	; 0x6956 <Ext1Power+0x1c>
    6954:	8b c0       	rjmp	.+278    	; 0x6a6c <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6956:	80 ea       	ldi	r24, 0xA0	; 160
    6958:	96 e0       	ldi	r25, 0x06	; 6
    695a:	20 e2       	ldi	r18, 0x20	; 32
    695c:	fc 01       	movw	r30, r24
    695e:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6960:	80 ea       	ldi	r24, 0xA0	; 160
    6962:	96 e0       	ldi	r25, 0x06	; 6
    6964:	20 e2       	ldi	r18, 0x20	; 32
    6966:	fc 01       	movw	r30, r24
    6968:	25 83       	std	Z+5, r18	; 0x05
    696a:	80 e0       	ldi	r24, 0x00	; 0
    696c:	90 e0       	ldi	r25, 0x00	; 0
    696e:	a8 ec       	ldi	r26, 0xC8	; 200
    6970:	b2 e4       	ldi	r27, 0x42	; 66
    6972:	89 83       	std	Y+1, r24	; 0x01
    6974:	9a 83       	std	Y+2, r25	; 0x02
    6976:	ab 83       	std	Y+3, r26	; 0x03
    6978:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    697a:	69 81       	ldd	r22, Y+1	; 0x01
    697c:	7a 81       	ldd	r23, Y+2	; 0x02
    697e:	8b 81       	ldd	r24, Y+3	; 0x03
    6980:	9c 81       	ldd	r25, Y+4	; 0x04
    6982:	20 e0       	ldi	r18, 0x00	; 0
    6984:	30 e0       	ldi	r19, 0x00	; 0
    6986:	4a ef       	ldi	r20, 0xFA	; 250
    6988:	55 e4       	ldi	r21, 0x45	; 69
    698a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    698e:	dc 01       	movw	r26, r24
    6990:	cb 01       	movw	r24, r22
    6992:	8d 83       	std	Y+5, r24	; 0x05
    6994:	9e 83       	std	Y+6, r25	; 0x06
    6996:	af 83       	std	Y+7, r26	; 0x07
    6998:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    699a:	11 e0       	ldi	r17, 0x01	; 1
    699c:	6d 81       	ldd	r22, Y+5	; 0x05
    699e:	7e 81       	ldd	r23, Y+6	; 0x06
    69a0:	8f 81       	ldd	r24, Y+7	; 0x07
    69a2:	98 85       	ldd	r25, Y+8	; 0x08
    69a4:	20 e0       	ldi	r18, 0x00	; 0
    69a6:	30 e0       	ldi	r19, 0x00	; 0
    69a8:	40 e8       	ldi	r20, 0x80	; 128
    69aa:	5f e3       	ldi	r21, 0x3F	; 63
    69ac:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    69b0:	88 23       	and	r24, r24
    69b2:	0c f0       	brlt	.+2      	; 0x69b6 <Ext1Power+0x7c>
    69b4:	10 e0       	ldi	r17, 0x00	; 0
    69b6:	11 23       	and	r17, r17
    69b8:	29 f0       	breq	.+10     	; 0x69c4 <Ext1Power+0x8a>
		__ticks = 1;
    69ba:	81 e0       	ldi	r24, 0x01	; 1
    69bc:	90 e0       	ldi	r25, 0x00	; 0
    69be:	89 87       	std	Y+9, r24	; 0x09
    69c0:	9a 87       	std	Y+10, r25	; 0x0a
    69c2:	46 c0       	rjmp	.+140    	; 0x6a50 <Ext1Power+0x116>
	else if (__tmp > 65535)
    69c4:	11 e0       	ldi	r17, 0x01	; 1
    69c6:	6d 81       	ldd	r22, Y+5	; 0x05
    69c8:	7e 81       	ldd	r23, Y+6	; 0x06
    69ca:	8f 81       	ldd	r24, Y+7	; 0x07
    69cc:	98 85       	ldd	r25, Y+8	; 0x08
    69ce:	20 e0       	ldi	r18, 0x00	; 0
    69d0:	3f ef       	ldi	r19, 0xFF	; 255
    69d2:	4f e7       	ldi	r20, 0x7F	; 127
    69d4:	57 e4       	ldi	r21, 0x47	; 71
    69d6:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    69da:	18 16       	cp	r1, r24
    69dc:	0c f0       	brlt	.+2      	; 0x69e0 <Ext1Power+0xa6>
    69de:	10 e0       	ldi	r17, 0x00	; 0
    69e0:	11 23       	and	r17, r17
    69e2:	61 f1       	breq	.+88     	; 0x6a3c <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    69e4:	69 81       	ldd	r22, Y+1	; 0x01
    69e6:	7a 81       	ldd	r23, Y+2	; 0x02
    69e8:	8b 81       	ldd	r24, Y+3	; 0x03
    69ea:	9c 81       	ldd	r25, Y+4	; 0x04
    69ec:	20 e0       	ldi	r18, 0x00	; 0
    69ee:	30 e0       	ldi	r19, 0x00	; 0
    69f0:	40 e2       	ldi	r20, 0x20	; 32
    69f2:	51 e4       	ldi	r21, 0x41	; 65
    69f4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    69f8:	dc 01       	movw	r26, r24
    69fa:	cb 01       	movw	r24, r22
    69fc:	bc 01       	movw	r22, r24
    69fe:	cd 01       	movw	r24, r26
    6a00:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6a04:	dc 01       	movw	r26, r24
    6a06:	cb 01       	movw	r24, r22
    6a08:	89 87       	std	Y+9, r24	; 0x09
    6a0a:	9a 87       	std	Y+10, r25	; 0x0a
    6a0c:	12 c0       	rjmp	.+36     	; 0x6a32 <Ext1Power+0xf8>
    6a0e:	80 e2       	ldi	r24, 0x20	; 32
    6a10:	93 e0       	ldi	r25, 0x03	; 3
    6a12:	8b 87       	std	Y+11, r24	; 0x0b
    6a14:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6a16:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a18:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a1a:	8c 01       	movw	r16, r24
    6a1c:	c8 01       	movw	r24, r16
    6a1e:	01 97       	sbiw	r24, 0x01	; 1
    6a20:	f1 f7       	brne	.-4      	; 0x6a1e <Ext1Power+0xe4>
    6a22:	8c 01       	movw	r16, r24
    6a24:	0b 87       	std	Y+11, r16	; 0x0b
    6a26:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6a28:	89 85       	ldd	r24, Y+9	; 0x09
    6a2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a2c:	01 97       	sbiw	r24, 0x01	; 1
    6a2e:	89 87       	std	Y+9, r24	; 0x09
    6a30:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6a32:	89 85       	ldd	r24, Y+9	; 0x09
    6a34:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a36:	00 97       	sbiw	r24, 0x00	; 0
    6a38:	51 f7       	brne	.-44     	; 0x6a0e <Ext1Power+0xd4>
    6a3a:	22 c0       	rjmp	.+68     	; 0x6a80 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6a3c:	6d 81       	ldd	r22, Y+5	; 0x05
    6a3e:	7e 81       	ldd	r23, Y+6	; 0x06
    6a40:	8f 81       	ldd	r24, Y+7	; 0x07
    6a42:	98 85       	ldd	r25, Y+8	; 0x08
    6a44:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6a48:	dc 01       	movw	r26, r24
    6a4a:	cb 01       	movw	r24, r22
    6a4c:	89 87       	std	Y+9, r24	; 0x09
    6a4e:	9a 87       	std	Y+10, r25	; 0x0a
    6a50:	89 85       	ldd	r24, Y+9	; 0x09
    6a52:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a54:	8d 87       	std	Y+13, r24	; 0x0d
    6a56:	9e 87       	std	Y+14, r25	; 0x0e
    6a58:	8d 85       	ldd	r24, Y+13	; 0x0d
    6a5a:	9e 85       	ldd	r25, Y+14	; 0x0e
    6a5c:	8c 01       	movw	r16, r24
    6a5e:	f8 01       	movw	r30, r16
    6a60:	31 97       	sbiw	r30, 0x01	; 1
    6a62:	f1 f7       	brne	.-4      	; 0x6a60 <Ext1Power+0x126>
    6a64:	8f 01       	movw	r16, r30
    6a66:	0d 87       	std	Y+13, r16	; 0x0d
    6a68:	1e 87       	std	Y+14, r17	; 0x0e
    6a6a:	0a c0       	rjmp	.+20     	; 0x6a80 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6a6c:	80 ea       	ldi	r24, 0xA0	; 160
    6a6e:	96 e0       	ldi	r25, 0x06	; 6
    6a70:	20 e2       	ldi	r18, 0x20	; 32
    6a72:	fc 01       	movw	r30, r24
    6a74:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6a76:	80 ea       	ldi	r24, 0xA0	; 160
    6a78:	96 e0       	ldi	r25, 0x06	; 6
    6a7a:	20 e2       	ldi	r18, 0x20	; 32
    6a7c:	fc 01       	movw	r30, r24
    6a7e:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6a80:	2f 96       	adiw	r28, 0x0f	; 15
    6a82:	cd bf       	out	0x3d, r28	; 61
    6a84:	de bf       	out	0x3e, r29	; 62
    6a86:	df 91       	pop	r29
    6a88:	cf 91       	pop	r28
    6a8a:	1f 91       	pop	r17
    6a8c:	0f 91       	pop	r16
    6a8e:	08 95       	ret

00006a90 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6a90:	0f 93       	push	r16
    6a92:	1f 93       	push	r17
    6a94:	cf 93       	push	r28
    6a96:	df 93       	push	r29
    6a98:	cd b7       	in	r28, 0x3d	; 61
    6a9a:	de b7       	in	r29, 0x3e	; 62
    6a9c:	2f 97       	sbiw	r28, 0x0f	; 15
    6a9e:	cd bf       	out	0x3d, r28	; 61
    6aa0:	de bf       	out	0x3e, r29	; 62
    6aa2:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
    6aa4:	8f 85       	ldd	r24, Y+15	; 0x0f
    6aa6:	88 23       	and	r24, r24
    6aa8:	09 f4       	brne	.+2      	; 0x6aac <Ext2Power+0x1c>
    6aaa:	8b c0       	rjmp	.+278    	; 0x6bc2 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6aac:	80 ea       	ldi	r24, 0xA0	; 160
    6aae:	96 e0       	ldi	r25, 0x06	; 6
    6ab0:	20 e4       	ldi	r18, 0x40	; 64
    6ab2:	fc 01       	movw	r30, r24
    6ab4:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6ab6:	80 ea       	ldi	r24, 0xA0	; 160
    6ab8:	96 e0       	ldi	r25, 0x06	; 6
    6aba:	20 e4       	ldi	r18, 0x40	; 64
    6abc:	fc 01       	movw	r30, r24
    6abe:	25 83       	std	Z+5, r18	; 0x05
    6ac0:	80 e0       	ldi	r24, 0x00	; 0
    6ac2:	90 e0       	ldi	r25, 0x00	; 0
    6ac4:	a8 ec       	ldi	r26, 0xC8	; 200
    6ac6:	b2 e4       	ldi	r27, 0x42	; 66
    6ac8:	89 83       	std	Y+1, r24	; 0x01
    6aca:	9a 83       	std	Y+2, r25	; 0x02
    6acc:	ab 83       	std	Y+3, r26	; 0x03
    6ace:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6ad0:	69 81       	ldd	r22, Y+1	; 0x01
    6ad2:	7a 81       	ldd	r23, Y+2	; 0x02
    6ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    6ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    6ad8:	20 e0       	ldi	r18, 0x00	; 0
    6ada:	30 e0       	ldi	r19, 0x00	; 0
    6adc:	4a ef       	ldi	r20, 0xFA	; 250
    6ade:	55 e4       	ldi	r21, 0x45	; 69
    6ae0:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6ae4:	dc 01       	movw	r26, r24
    6ae6:	cb 01       	movw	r24, r22
    6ae8:	8d 83       	std	Y+5, r24	; 0x05
    6aea:	9e 83       	std	Y+6, r25	; 0x06
    6aec:	af 83       	std	Y+7, r26	; 0x07
    6aee:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6af0:	11 e0       	ldi	r17, 0x01	; 1
    6af2:	6d 81       	ldd	r22, Y+5	; 0x05
    6af4:	7e 81       	ldd	r23, Y+6	; 0x06
    6af6:	8f 81       	ldd	r24, Y+7	; 0x07
    6af8:	98 85       	ldd	r25, Y+8	; 0x08
    6afa:	20 e0       	ldi	r18, 0x00	; 0
    6afc:	30 e0       	ldi	r19, 0x00	; 0
    6afe:	40 e8       	ldi	r20, 0x80	; 128
    6b00:	5f e3       	ldi	r21, 0x3F	; 63
    6b02:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    6b06:	88 23       	and	r24, r24
    6b08:	0c f0       	brlt	.+2      	; 0x6b0c <Ext2Power+0x7c>
    6b0a:	10 e0       	ldi	r17, 0x00	; 0
    6b0c:	11 23       	and	r17, r17
    6b0e:	29 f0       	breq	.+10     	; 0x6b1a <Ext2Power+0x8a>
		__ticks = 1;
    6b10:	81 e0       	ldi	r24, 0x01	; 1
    6b12:	90 e0       	ldi	r25, 0x00	; 0
    6b14:	89 87       	std	Y+9, r24	; 0x09
    6b16:	9a 87       	std	Y+10, r25	; 0x0a
    6b18:	46 c0       	rjmp	.+140    	; 0x6ba6 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6b1a:	11 e0       	ldi	r17, 0x01	; 1
    6b1c:	6d 81       	ldd	r22, Y+5	; 0x05
    6b1e:	7e 81       	ldd	r23, Y+6	; 0x06
    6b20:	8f 81       	ldd	r24, Y+7	; 0x07
    6b22:	98 85       	ldd	r25, Y+8	; 0x08
    6b24:	20 e0       	ldi	r18, 0x00	; 0
    6b26:	3f ef       	ldi	r19, 0xFF	; 255
    6b28:	4f e7       	ldi	r20, 0x7F	; 127
    6b2a:	57 e4       	ldi	r21, 0x47	; 71
    6b2c:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    6b30:	18 16       	cp	r1, r24
    6b32:	0c f0       	brlt	.+2      	; 0x6b36 <Ext2Power+0xa6>
    6b34:	10 e0       	ldi	r17, 0x00	; 0
    6b36:	11 23       	and	r17, r17
    6b38:	61 f1       	breq	.+88     	; 0x6b92 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6b3a:	69 81       	ldd	r22, Y+1	; 0x01
    6b3c:	7a 81       	ldd	r23, Y+2	; 0x02
    6b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    6b40:	9c 81       	ldd	r25, Y+4	; 0x04
    6b42:	20 e0       	ldi	r18, 0x00	; 0
    6b44:	30 e0       	ldi	r19, 0x00	; 0
    6b46:	40 e2       	ldi	r20, 0x20	; 32
    6b48:	51 e4       	ldi	r21, 0x41	; 65
    6b4a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6b4e:	dc 01       	movw	r26, r24
    6b50:	cb 01       	movw	r24, r22
    6b52:	bc 01       	movw	r22, r24
    6b54:	cd 01       	movw	r24, r26
    6b56:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6b5a:	dc 01       	movw	r26, r24
    6b5c:	cb 01       	movw	r24, r22
    6b5e:	89 87       	std	Y+9, r24	; 0x09
    6b60:	9a 87       	std	Y+10, r25	; 0x0a
    6b62:	12 c0       	rjmp	.+36     	; 0x6b88 <Ext2Power+0xf8>
    6b64:	80 e2       	ldi	r24, 0x20	; 32
    6b66:	93 e0       	ldi	r25, 0x03	; 3
    6b68:	8b 87       	std	Y+11, r24	; 0x0b
    6b6a:	9c 87       	std	Y+12, r25	; 0x0c
    6b6c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b6e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b70:	8c 01       	movw	r16, r24
    6b72:	c8 01       	movw	r24, r16
    6b74:	01 97       	sbiw	r24, 0x01	; 1
    6b76:	f1 f7       	brne	.-4      	; 0x6b74 <Ext2Power+0xe4>
    6b78:	8c 01       	movw	r16, r24
    6b7a:	0b 87       	std	Y+11, r16	; 0x0b
    6b7c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6b7e:	89 85       	ldd	r24, Y+9	; 0x09
    6b80:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b82:	01 97       	sbiw	r24, 0x01	; 1
    6b84:	89 87       	std	Y+9, r24	; 0x09
    6b86:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6b88:	89 85       	ldd	r24, Y+9	; 0x09
    6b8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b8c:	00 97       	sbiw	r24, 0x00	; 0
    6b8e:	51 f7       	brne	.-44     	; 0x6b64 <Ext2Power+0xd4>
    6b90:	22 c0       	rjmp	.+68     	; 0x6bd6 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6b92:	6d 81       	ldd	r22, Y+5	; 0x05
    6b94:	7e 81       	ldd	r23, Y+6	; 0x06
    6b96:	8f 81       	ldd	r24, Y+7	; 0x07
    6b98:	98 85       	ldd	r25, Y+8	; 0x08
    6b9a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6b9e:	dc 01       	movw	r26, r24
    6ba0:	cb 01       	movw	r24, r22
    6ba2:	89 87       	std	Y+9, r24	; 0x09
    6ba4:	9a 87       	std	Y+10, r25	; 0x0a
    6ba6:	89 85       	ldd	r24, Y+9	; 0x09
    6ba8:	9a 85       	ldd	r25, Y+10	; 0x0a
    6baa:	8d 87       	std	Y+13, r24	; 0x0d
    6bac:	9e 87       	std	Y+14, r25	; 0x0e
    6bae:	8d 85       	ldd	r24, Y+13	; 0x0d
    6bb0:	9e 85       	ldd	r25, Y+14	; 0x0e
    6bb2:	8c 01       	movw	r16, r24
    6bb4:	f8 01       	movw	r30, r16
    6bb6:	31 97       	sbiw	r30, 0x01	; 1
    6bb8:	f1 f7       	brne	.-4      	; 0x6bb6 <Ext2Power+0x126>
    6bba:	8f 01       	movw	r16, r30
    6bbc:	0d 87       	std	Y+13, r16	; 0x0d
    6bbe:	1e 87       	std	Y+14, r17	; 0x0e
    6bc0:	0a c0       	rjmp	.+20     	; 0x6bd6 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6bc2:	80 ea       	ldi	r24, 0xA0	; 160
    6bc4:	96 e0       	ldi	r25, 0x06	; 6
    6bc6:	20 e4       	ldi	r18, 0x40	; 64
    6bc8:	fc 01       	movw	r30, r24
    6bca:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6bcc:	80 ea       	ldi	r24, 0xA0	; 160
    6bce:	96 e0       	ldi	r25, 0x06	; 6
    6bd0:	20 e4       	ldi	r18, 0x40	; 64
    6bd2:	fc 01       	movw	r30, r24
    6bd4:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6bd6:	2f 96       	adiw	r28, 0x0f	; 15
    6bd8:	cd bf       	out	0x3d, r28	; 61
    6bda:	de bf       	out	0x3e, r29	; 62
    6bdc:	df 91       	pop	r29
    6bde:	cf 91       	pop	r28
    6be0:	1f 91       	pop	r17
    6be2:	0f 91       	pop	r16
    6be4:	08 95       	ret

00006be6 <HVPower>:

void HVPower(uint8_t on) {
    6be6:	0f 93       	push	r16
    6be8:	1f 93       	push	r17
    6bea:	cf 93       	push	r28
    6bec:	df 93       	push	r29
    6bee:	cd b7       	in	r28, 0x3d	; 61
    6bf0:	de b7       	in	r29, 0x3e	; 62
    6bf2:	a7 97       	sbiw	r28, 0x27	; 39
    6bf4:	cd bf       	out	0x3d, r28	; 61
    6bf6:	de bf       	out	0x3e, r29	; 62
    6bf8:	8f a3       	lds	r24, 0x5f
	
	if (on) {
    6bfa:	8f a1       	lds	r24, 0x4f
    6bfc:	88 23       	and	r24, r24
    6bfe:	09 f4       	brne	.+2      	; 0x6c02 <HVPower+0x1c>
    6c00:	8b c0       	rjmp	.+278    	; 0x6d18 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6c02:	80 ea       	ldi	r24, 0xA0	; 160
    6c04:	96 e0       	ldi	r25, 0x06	; 6
    6c06:	20 e8       	ldi	r18, 0x80	; 128
    6c08:	fc 01       	movw	r30, r24
    6c0a:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6c0c:	80 ea       	ldi	r24, 0xA0	; 160
    6c0e:	96 e0       	ldi	r25, 0x06	; 6
    6c10:	20 e8       	ldi	r18, 0x80	; 128
    6c12:	fc 01       	movw	r30, r24
    6c14:	25 83       	std	Z+5, r18	; 0x05
    6c16:	80 e0       	ldi	r24, 0x00	; 0
    6c18:	90 e0       	ldi	r25, 0x00	; 0
    6c1a:	a8 ec       	ldi	r26, 0xC8	; 200
    6c1c:	b2 e4       	ldi	r27, 0x42	; 66
    6c1e:	89 83       	std	Y+1, r24	; 0x01
    6c20:	9a 83       	std	Y+2, r25	; 0x02
    6c22:	ab 83       	std	Y+3, r26	; 0x03
    6c24:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6c26:	69 81       	ldd	r22, Y+1	; 0x01
    6c28:	7a 81       	ldd	r23, Y+2	; 0x02
    6c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    6c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    6c2e:	20 e0       	ldi	r18, 0x00	; 0
    6c30:	30 e0       	ldi	r19, 0x00	; 0
    6c32:	4a ef       	ldi	r20, 0xFA	; 250
    6c34:	55 e4       	ldi	r21, 0x45	; 69
    6c36:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6c3a:	dc 01       	movw	r26, r24
    6c3c:	cb 01       	movw	r24, r22
    6c3e:	8d 83       	std	Y+5, r24	; 0x05
    6c40:	9e 83       	std	Y+6, r25	; 0x06
    6c42:	af 83       	std	Y+7, r26	; 0x07
    6c44:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6c46:	11 e0       	ldi	r17, 0x01	; 1
    6c48:	6d 81       	ldd	r22, Y+5	; 0x05
    6c4a:	7e 81       	ldd	r23, Y+6	; 0x06
    6c4c:	8f 81       	ldd	r24, Y+7	; 0x07
    6c4e:	98 85       	ldd	r25, Y+8	; 0x08
    6c50:	20 e0       	ldi	r18, 0x00	; 0
    6c52:	30 e0       	ldi	r19, 0x00	; 0
    6c54:	40 e8       	ldi	r20, 0x80	; 128
    6c56:	5f e3       	ldi	r21, 0x3F	; 63
    6c58:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    6c5c:	88 23       	and	r24, r24
    6c5e:	0c f0       	brlt	.+2      	; 0x6c62 <HVPower+0x7c>
    6c60:	10 e0       	ldi	r17, 0x00	; 0
    6c62:	11 23       	and	r17, r17
    6c64:	29 f0       	breq	.+10     	; 0x6c70 <HVPower+0x8a>
		__ticks = 1;
    6c66:	81 e0       	ldi	r24, 0x01	; 1
    6c68:	90 e0       	ldi	r25, 0x00	; 0
    6c6a:	89 87       	std	Y+9, r24	; 0x09
    6c6c:	9a 87       	std	Y+10, r25	; 0x0a
    6c6e:	46 c0       	rjmp	.+140    	; 0x6cfc <HVPower+0x116>
	else if (__tmp > 65535)
    6c70:	11 e0       	ldi	r17, 0x01	; 1
    6c72:	6d 81       	ldd	r22, Y+5	; 0x05
    6c74:	7e 81       	ldd	r23, Y+6	; 0x06
    6c76:	8f 81       	ldd	r24, Y+7	; 0x07
    6c78:	98 85       	ldd	r25, Y+8	; 0x08
    6c7a:	20 e0       	ldi	r18, 0x00	; 0
    6c7c:	3f ef       	ldi	r19, 0xFF	; 255
    6c7e:	4f e7       	ldi	r20, 0x7F	; 127
    6c80:	57 e4       	ldi	r21, 0x47	; 71
    6c82:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    6c86:	18 16       	cp	r1, r24
    6c88:	0c f0       	brlt	.+2      	; 0x6c8c <HVPower+0xa6>
    6c8a:	10 e0       	ldi	r17, 0x00	; 0
    6c8c:	11 23       	and	r17, r17
    6c8e:	61 f1       	breq	.+88     	; 0x6ce8 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6c90:	69 81       	ldd	r22, Y+1	; 0x01
    6c92:	7a 81       	ldd	r23, Y+2	; 0x02
    6c94:	8b 81       	ldd	r24, Y+3	; 0x03
    6c96:	9c 81       	ldd	r25, Y+4	; 0x04
    6c98:	20 e0       	ldi	r18, 0x00	; 0
    6c9a:	30 e0       	ldi	r19, 0x00	; 0
    6c9c:	40 e2       	ldi	r20, 0x20	; 32
    6c9e:	51 e4       	ldi	r21, 0x41	; 65
    6ca0:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6ca4:	dc 01       	movw	r26, r24
    6ca6:	cb 01       	movw	r24, r22
    6ca8:	bc 01       	movw	r22, r24
    6caa:	cd 01       	movw	r24, r26
    6cac:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6cb0:	dc 01       	movw	r26, r24
    6cb2:	cb 01       	movw	r24, r22
    6cb4:	89 87       	std	Y+9, r24	; 0x09
    6cb6:	9a 87       	std	Y+10, r25	; 0x0a
    6cb8:	12 c0       	rjmp	.+36     	; 0x6cde <HVPower+0xf8>
    6cba:	80 e2       	ldi	r24, 0x20	; 32
    6cbc:	93 e0       	ldi	r25, 0x03	; 3
    6cbe:	8b 87       	std	Y+11, r24	; 0x0b
    6cc0:	9c 87       	std	Y+12, r25	; 0x0c
    6cc2:	8b 85       	ldd	r24, Y+11	; 0x0b
    6cc4:	9c 85       	ldd	r25, Y+12	; 0x0c
    6cc6:	8c 01       	movw	r16, r24
    6cc8:	c8 01       	movw	r24, r16
    6cca:	01 97       	sbiw	r24, 0x01	; 1
    6ccc:	f1 f7       	brne	.-4      	; 0x6cca <HVPower+0xe4>
    6cce:	8c 01       	movw	r16, r24
    6cd0:	0b 87       	std	Y+11, r16	; 0x0b
    6cd2:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6cd4:	89 85       	ldd	r24, Y+9	; 0x09
    6cd6:	9a 85       	ldd	r25, Y+10	; 0x0a
    6cd8:	01 97       	sbiw	r24, 0x01	; 1
    6cda:	89 87       	std	Y+9, r24	; 0x09
    6cdc:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6cde:	89 85       	ldd	r24, Y+9	; 0x09
    6ce0:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ce2:	00 97       	sbiw	r24, 0x00	; 0
    6ce4:	51 f7       	brne	.-44     	; 0x6cba <HVPower+0xd4>
    6ce6:	22 c0       	rjmp	.+68     	; 0x6d2c <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6ce8:	6d 81       	ldd	r22, Y+5	; 0x05
    6cea:	7e 81       	ldd	r23, Y+6	; 0x06
    6cec:	8f 81       	ldd	r24, Y+7	; 0x07
    6cee:	98 85       	ldd	r25, Y+8	; 0x08
    6cf0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6cf4:	dc 01       	movw	r26, r24
    6cf6:	cb 01       	movw	r24, r22
    6cf8:	89 87       	std	Y+9, r24	; 0x09
    6cfa:	9a 87       	std	Y+10, r25	; 0x0a
    6cfc:	89 85       	ldd	r24, Y+9	; 0x09
    6cfe:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d00:	8d 87       	std	Y+13, r24	; 0x0d
    6d02:	9e 87       	std	Y+14, r25	; 0x0e
    6d04:	8d 85       	ldd	r24, Y+13	; 0x0d
    6d06:	9e 85       	ldd	r25, Y+14	; 0x0e
    6d08:	8c 01       	movw	r16, r24
    6d0a:	f8 01       	movw	r30, r16
    6d0c:	31 97       	sbiw	r30, 0x01	; 1
    6d0e:	f1 f7       	brne	.-4      	; 0x6d0c <HVPower+0x126>
    6d10:	8f 01       	movw	r16, r30
    6d12:	0d 87       	std	Y+13, r16	; 0x0d
    6d14:	1e 87       	std	Y+14, r17	; 0x0e
    6d16:	0a c0       	rjmp	.+20     	; 0x6d2c <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6d18:	80 ea       	ldi	r24, 0xA0	; 160
    6d1a:	96 e0       	ldi	r25, 0x06	; 6
    6d1c:	20 e8       	ldi	r18, 0x80	; 128
    6d1e:	fc 01       	movw	r30, r24
    6d20:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6d22:	80 ea       	ldi	r24, 0xA0	; 160
    6d24:	96 e0       	ldi	r25, 0x06	; 6
    6d26:	20 e8       	ldi	r18, 0x80	; 128
    6d28:	fc 01       	movw	r30, r24
    6d2a:	22 83       	std	Z+2, r18	; 0x02
    6d2c:	80 e0       	ldi	r24, 0x00	; 0
    6d2e:	90 e0       	ldi	r25, 0x00	; 0
    6d30:	aa e7       	ldi	r26, 0x7A	; 122
    6d32:	b4 e4       	ldi	r27, 0x44	; 68
    6d34:	8f 87       	std	Y+15, r24	; 0x0f
    6d36:	98 8b       	std	Y+16, r25	; 0x10
    6d38:	a9 8b       	std	Y+17, r26	; 0x11
    6d3a:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6d3c:	6f 85       	ldd	r22, Y+15	; 0x0f
    6d3e:	78 89       	ldd	r23, Y+16	; 0x10
    6d40:	89 89       	ldd	r24, Y+17	; 0x11
    6d42:	9a 89       	ldd	r25, Y+18	; 0x12
    6d44:	2b ea       	ldi	r18, 0xAB	; 171
    6d46:	3a ea       	ldi	r19, 0xAA	; 170
    6d48:	4a e2       	ldi	r20, 0x2A	; 42
    6d4a:	51 e4       	ldi	r21, 0x41	; 65
    6d4c:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6d50:	dc 01       	movw	r26, r24
    6d52:	cb 01       	movw	r24, r22
    6d54:	8b 8b       	std	Y+19, r24	; 0x13
    6d56:	9c 8b       	std	Y+20, r25	; 0x14
    6d58:	ad 8b       	std	Y+21, r26	; 0x15
    6d5a:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6d5c:	11 e0       	ldi	r17, 0x01	; 1
    6d5e:	6b 89       	ldd	r22, Y+19	; 0x13
    6d60:	7c 89       	ldd	r23, Y+20	; 0x14
    6d62:	8d 89       	ldd	r24, Y+21	; 0x15
    6d64:	9e 89       	ldd	r25, Y+22	; 0x16
    6d66:	20 e0       	ldi	r18, 0x00	; 0
    6d68:	30 e0       	ldi	r19, 0x00	; 0
    6d6a:	40 e8       	ldi	r20, 0x80	; 128
    6d6c:	5f e3       	ldi	r21, 0x3F	; 63
    6d6e:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    6d72:	88 23       	and	r24, r24
    6d74:	0c f0       	brlt	.+2      	; 0x6d78 <HVPower+0x192>
    6d76:	10 e0       	ldi	r17, 0x00	; 0
    6d78:	11 23       	and	r17, r17
    6d7a:	19 f0       	breq	.+6      	; 0x6d82 <HVPower+0x19c>
		__ticks = 1;
    6d7c:	81 e0       	ldi	r24, 0x01	; 1
    6d7e:	8f 8b       	std	Y+23, r24	; 0x17
    6d80:	a3 c0       	rjmp	.+326    	; 0x6ec8 <HVPower+0x2e2>
	else if (__tmp > 255)
    6d82:	11 e0       	ldi	r17, 0x01	; 1
    6d84:	6b 89       	ldd	r22, Y+19	; 0x13
    6d86:	7c 89       	ldd	r23, Y+20	; 0x14
    6d88:	8d 89       	ldd	r24, Y+21	; 0x15
    6d8a:	9e 89       	ldd	r25, Y+22	; 0x16
    6d8c:	20 e0       	ldi	r18, 0x00	; 0
    6d8e:	30 e0       	ldi	r19, 0x00	; 0
    6d90:	4f e7       	ldi	r20, 0x7F	; 127
    6d92:	53 e4       	ldi	r21, 0x43	; 67
    6d94:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    6d98:	18 16       	cp	r1, r24
    6d9a:	0c f0       	brlt	.+2      	; 0x6d9e <HVPower+0x1b8>
    6d9c:	10 e0       	ldi	r17, 0x00	; 0
    6d9e:	11 23       	and	r17, r17
    6da0:	09 f4       	brne	.+2      	; 0x6da4 <HVPower+0x1be>
    6da2:	89 c0       	rjmp	.+274    	; 0x6eb6 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6da4:	6f 85       	ldd	r22, Y+15	; 0x0f
    6da6:	78 89       	ldd	r23, Y+16	; 0x10
    6da8:	89 89       	ldd	r24, Y+17	; 0x11
    6daa:	9a 89       	ldd	r25, Y+18	; 0x12
    6dac:	20 e0       	ldi	r18, 0x00	; 0
    6dae:	30 e0       	ldi	r19, 0x00	; 0
    6db0:	4a e7       	ldi	r20, 0x7A	; 122
    6db2:	54 e4       	ldi	r21, 0x44	; 68
    6db4:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    6db8:	dc 01       	movw	r26, r24
    6dba:	cb 01       	movw	r24, r22
    6dbc:	88 8f       	std	Y+24, r24	; 0x18
    6dbe:	99 8f       	std	Y+25, r25	; 0x19
    6dc0:	aa 8f       	std	Y+26, r26	; 0x1a
    6dc2:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6dc4:	68 8d       	ldd	r22, Y+24	; 0x18
    6dc6:	79 8d       	ldd	r23, Y+25	; 0x19
    6dc8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6dca:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6dcc:	20 e0       	ldi	r18, 0x00	; 0
    6dce:	30 e0       	ldi	r19, 0x00	; 0
    6dd0:	4a ef       	ldi	r20, 0xFA	; 250
    6dd2:	55 e4       	ldi	r21, 0x45	; 69
    6dd4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6dd8:	dc 01       	movw	r26, r24
    6dda:	cb 01       	movw	r24, r22
    6ddc:	8c 8f       	std	Y+28, r24	; 0x1c
    6dde:	9d 8f       	std	Y+29, r25	; 0x1d
    6de0:	ae 8f       	std	Y+30, r26	; 0x1e
    6de2:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6de4:	11 e0       	ldi	r17, 0x01	; 1
    6de6:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6de8:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6dea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6dec:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6dee:	20 e0       	ldi	r18, 0x00	; 0
    6df0:	30 e0       	ldi	r19, 0x00	; 0
    6df2:	40 e8       	ldi	r20, 0x80	; 128
    6df4:	5f e3       	ldi	r21, 0x3F	; 63
    6df6:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    6dfa:	88 23       	and	r24, r24
    6dfc:	0c f0       	brlt	.+2      	; 0x6e00 <HVPower+0x21a>
    6dfe:	10 e0       	ldi	r17, 0x00	; 0
    6e00:	11 23       	and	r17, r17
    6e02:	29 f0       	breq	.+10     	; 0x6e0e <HVPower+0x228>
		__ticks = 1;
    6e04:	81 e0       	ldi	r24, 0x01	; 1
    6e06:	90 e0       	ldi	r25, 0x00	; 0
    6e08:	88 a3       	lds	r24, 0x58
    6e0a:	99 a3       	lds	r25, 0x59
    6e0c:	46 c0       	rjmp	.+140    	; 0x6e9a <HVPower+0x2b4>
	else if (__tmp > 65535)
    6e0e:	11 e0       	ldi	r17, 0x01	; 1
    6e10:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6e12:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6e14:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6e16:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6e18:	20 e0       	ldi	r18, 0x00	; 0
    6e1a:	3f ef       	ldi	r19, 0xFF	; 255
    6e1c:	4f e7       	ldi	r20, 0x7F	; 127
    6e1e:	57 e4       	ldi	r21, 0x47	; 71
    6e20:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    6e24:	18 16       	cp	r1, r24
    6e26:	0c f0       	brlt	.+2      	; 0x6e2a <HVPower+0x244>
    6e28:	10 e0       	ldi	r17, 0x00	; 0
    6e2a:	11 23       	and	r17, r17
    6e2c:	61 f1       	breq	.+88     	; 0x6e86 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e2e:	68 8d       	ldd	r22, Y+24	; 0x18
    6e30:	79 8d       	ldd	r23, Y+25	; 0x19
    6e32:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6e34:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6e36:	20 e0       	ldi	r18, 0x00	; 0
    6e38:	30 e0       	ldi	r19, 0x00	; 0
    6e3a:	40 e2       	ldi	r20, 0x20	; 32
    6e3c:	51 e4       	ldi	r21, 0x41	; 65
    6e3e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    6e42:	dc 01       	movw	r26, r24
    6e44:	cb 01       	movw	r24, r22
    6e46:	bc 01       	movw	r22, r24
    6e48:	cd 01       	movw	r24, r26
    6e4a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6e4e:	dc 01       	movw	r26, r24
    6e50:	cb 01       	movw	r24, r22
    6e52:	88 a3       	lds	r24, 0x58
    6e54:	99 a3       	lds	r25, 0x59
    6e56:	12 c0       	rjmp	.+36     	; 0x6e7c <HVPower+0x296>
    6e58:	80 e2       	ldi	r24, 0x20	; 32
    6e5a:	93 e0       	ldi	r25, 0x03	; 3
    6e5c:	8a a3       	lds	r24, 0x5a
    6e5e:	9b a3       	lds	r25, 0x5b
    6e60:	8a a1       	lds	r24, 0x4a
    6e62:	9b a1       	lds	r25, 0x4b
    6e64:	8c 01       	movw	r16, r24
    6e66:	c8 01       	movw	r24, r16
    6e68:	01 97       	sbiw	r24, 0x01	; 1
    6e6a:	f1 f7       	brne	.-4      	; 0x6e68 <HVPower+0x282>
    6e6c:	8c 01       	movw	r16, r24
    6e6e:	0a a3       	lds	r16, 0x5a
    6e70:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e72:	88 a1       	lds	r24, 0x48
    6e74:	99 a1       	lds	r25, 0x49
    6e76:	01 97       	sbiw	r24, 0x01	; 1
    6e78:	88 a3       	lds	r24, 0x58
    6e7a:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e7c:	88 a1       	lds	r24, 0x48
    6e7e:	99 a1       	lds	r25, 0x49
    6e80:	00 97       	sbiw	r24, 0x00	; 0
    6e82:	51 f7       	brne	.-44     	; 0x6e58 <HVPower+0x272>
    6e84:	28 c0       	rjmp	.+80     	; 0x6ed6 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e86:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6e88:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6e8a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6e8c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6e8e:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6e92:	dc 01       	movw	r26, r24
    6e94:	cb 01       	movw	r24, r22
    6e96:	88 a3       	lds	r24, 0x58
    6e98:	99 a3       	lds	r25, 0x59
    6e9a:	88 a1       	lds	r24, 0x48
    6e9c:	99 a1       	lds	r25, 0x49
    6e9e:	8c a3       	lds	r24, 0x5c
    6ea0:	9d a3       	lds	r25, 0x5d
    6ea2:	8c a1       	lds	r24, 0x4c
    6ea4:	9d a1       	lds	r25, 0x4d
    6ea6:	8c 01       	movw	r16, r24
    6ea8:	f8 01       	movw	r30, r16
    6eaa:	31 97       	sbiw	r30, 0x01	; 1
    6eac:	f1 f7       	brne	.-4      	; 0x6eaa <HVPower+0x2c4>
    6eae:	8f 01       	movw	r16, r30
    6eb0:	0c a3       	lds	r16, 0x5c
    6eb2:	1d a3       	lds	r17, 0x5d
    6eb4:	10 c0       	rjmp	.+32     	; 0x6ed6 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6eb6:	6b 89       	ldd	r22, Y+19	; 0x13
    6eb8:	7c 89       	ldd	r23, Y+20	; 0x14
    6eba:	8d 89       	ldd	r24, Y+21	; 0x15
    6ebc:	9e 89       	ldd	r25, Y+22	; 0x16
    6ebe:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    6ec2:	dc 01       	movw	r26, r24
    6ec4:	cb 01       	movw	r24, r22
    6ec6:	8f 8b       	std	Y+23, r24	; 0x17
    6ec8:	8f 89       	ldd	r24, Y+23	; 0x17
    6eca:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6ecc:	8e a1       	lds	r24, 0x4e
    6ece:	18 2f       	mov	r17, r24
    6ed0:	1a 95       	dec	r17
    6ed2:	f1 f7       	brne	.-4      	; 0x6ed0 <HVPower+0x2ea>
    6ed4:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    6ed6:	a7 96       	adiw	r28, 0x27	; 39
    6ed8:	cd bf       	out	0x3d, r28	; 61
    6eda:	de bf       	out	0x3e, r29	; 62
    6edc:	df 91       	pop	r29
    6ede:	cf 91       	pop	r28
    6ee0:	1f 91       	pop	r17
    6ee2:	0f 91       	pop	r16
    6ee4:	08 95       	ret

00006ee6 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    6ee6:	cf 93       	push	r28
    6ee8:	df 93       	push	r29
    6eea:	0f 92       	push	r0
    6eec:	cd b7       	in	r28, 0x3d	; 61
    6eee:	de b7       	in	r29, 0x3e	; 62
    6ef0:	89 83       	std	Y+1, r24	; 0x01
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    6ef2:	89 81       	ldd	r24, Y+1	; 0x01
    6ef4:	88 23       	and	r24, r24
    6ef6:	31 f0       	breq	.+12     	; 0x6f04 <lowerMuxCS+0x1e>
    6ef8:	80 e8       	ldi	r24, 0x80	; 128
    6efa:	96 e0       	ldi	r25, 0x06	; 6
    6efc:	20 e1       	ldi	r18, 0x10	; 16
    6efe:	fc 01       	movw	r30, r24
    6f00:	26 83       	std	Z+6, r18	; 0x06
    6f02:	05 c0       	rjmp	.+10     	; 0x6f0e <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    6f04:	80 e8       	ldi	r24, 0x80	; 128
    6f06:	96 e0       	ldi	r25, 0x06	; 6
    6f08:	20 e1       	ldi	r18, 0x10	; 16
    6f0a:	fc 01       	movw	r30, r24
    6f0c:	25 83       	std	Z+5, r18	; 0x05
}
    6f0e:	0f 90       	pop	r0
    6f10:	df 91       	pop	r29
    6f12:	cf 91       	pop	r28
    6f14:	08 95       	ret

00006f16 <upperMuxCS>:

void upperMuxCS(uint8_t write) {
    6f16:	cf 93       	push	r28
    6f18:	df 93       	push	r29
    6f1a:	0f 92       	push	r0
    6f1c:	cd b7       	in	r28, 0x3d	; 61
    6f1e:	de b7       	in	r29, 0x3e	; 62
    6f20:	89 83       	std	Y+1, r24	; 0x01
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    6f22:	89 81       	ldd	r24, Y+1	; 0x01
    6f24:	88 23       	and	r24, r24
    6f26:	31 f0       	breq	.+12     	; 0x6f34 <upperMuxCS+0x1e>
    6f28:	80 e4       	ldi	r24, 0x40	; 64
    6f2a:	96 e0       	ldi	r25, 0x06	; 6
    6f2c:	22 e0       	ldi	r18, 0x02	; 2
    6f2e:	fc 01       	movw	r30, r24
    6f30:	26 83       	std	Z+6, r18	; 0x06
    6f32:	05 c0       	rjmp	.+10     	; 0x6f3e <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    6f34:	80 e4       	ldi	r24, 0x40	; 64
    6f36:	96 e0       	ldi	r25, 0x06	; 6
    6f38:	22 e0       	ldi	r18, 0x02	; 2
    6f3a:	fc 01       	movw	r30, r24
    6f3c:	25 83       	std	Z+5, r18	; 0x05
}
    6f3e:	0f 90       	pop	r0
    6f40:	df 91       	pop	r29
    6f42:	cf 91       	pop	r28
    6f44:	08 95       	ret

00006f46 <SPIInit>:

void SPIInit(uint8_t mode) {
    6f46:	cf 93       	push	r28
    6f48:	df 93       	push	r29
    6f4a:	0f 92       	push	r0
    6f4c:	cd b7       	in	r28, 0x3d	; 61
    6f4e:	de b7       	in	r29, 0x3e	; 62
    6f50:	89 83       	std	Y+1, r24	; 0x01
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6f52:	80 e4       	ldi	r24, 0x40	; 64
    6f54:	96 e0       	ldi	r25, 0x06	; 6
    6f56:	20 e1       	ldi	r18, 0x10	; 16
    6f58:	fc 01       	movw	r30, r24
    6f5a:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6f5c:	80 e4       	ldi	r24, 0x40	; 64
    6f5e:	96 e0       	ldi	r25, 0x06	; 6
    6f60:	28 e3       	ldi	r18, 0x38	; 56
    6f62:	fc 01       	movw	r30, r24
    6f64:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6f66:	80 e4       	ldi	r24, 0x40	; 64
    6f68:	96 e0       	ldi	r25, 0x06	; 6
    6f6a:	20 e1       	ldi	r18, 0x10	; 16
    6f6c:	fc 01       	movw	r30, r24
    6f6e:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    6f70:	80 ec       	ldi	r24, 0xC0	; 192
    6f72:	98 e0       	ldi	r25, 0x08	; 8
    6f74:	29 81       	ldd	r18, Y+1	; 0x01
    6f76:	21 65       	ori	r18, 0x51	; 81
    6f78:	fc 01       	movw	r30, r24
    6f7a:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6f7c:	80 ec       	ldi	r24, 0xC0	; 192
    6f7e:	98 e0       	ldi	r25, 0x08	; 8
    6f80:	fc 01       	movw	r30, r24
    6f82:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6f84:	80 e4       	ldi	r24, 0x40	; 64
    6f86:	96 e0       	ldi	r25, 0x06	; 6
    6f88:	20 ea       	ldi	r18, 0xA0	; 160
    6f8a:	fc 01       	movw	r30, r24
    6f8c:	21 83       	std	Z+1, r18	; 0x01

	
}
    6f8e:	0f 90       	pop	r0
    6f90:	df 91       	pop	r29
    6f92:	cf 91       	pop	r28
    6f94:	08 95       	ret

00006f96 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    6f96:	cf 93       	push	r28
    6f98:	df 93       	push	r29
    6f9a:	0f 92       	push	r0
    6f9c:	0f 92       	push	r0
    6f9e:	cd b7       	in	r28, 0x3d	; 61
    6fa0:	de b7       	in	r29, 0x3e	; 62
    6fa2:	89 83       	std	Y+1, r24	; 0x01
    6fa4:	6a 83       	std	Y+2, r22	; 0x02
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6fa6:	80 e4       	ldi	r24, 0x40	; 64
    6fa8:	96 e0       	ldi	r25, 0x06	; 6
    6faa:	20 e1       	ldi	r18, 0x10	; 16
    6fac:	fc 01       	movw	r30, r24
    6fae:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6fb0:	80 e4       	ldi	r24, 0x40	; 64
    6fb2:	96 e0       	ldi	r25, 0x06	; 6
    6fb4:	28 e3       	ldi	r18, 0x38	; 56
    6fb6:	fc 01       	movw	r30, r24
    6fb8:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6fba:	80 e4       	ldi	r24, 0x40	; 64
    6fbc:	96 e0       	ldi	r25, 0x06	; 6
    6fbe:	20 e1       	ldi	r18, 0x10	; 16
    6fc0:	fc 01       	movw	r30, r24
    6fc2:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    6fc4:	80 ec       	ldi	r24, 0xC0	; 192
    6fc6:	98 e0       	ldi	r25, 0x08	; 8
    6fc8:	3a 81       	ldd	r19, Y+2	; 0x02
    6fca:	29 81       	ldd	r18, Y+1	; 0x01
    6fcc:	23 2b       	or	r18, r19
    6fce:	20 65       	ori	r18, 0x50	; 80
    6fd0:	fc 01       	movw	r30, r24
    6fd2:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6fd4:	80 ec       	ldi	r24, 0xC0	; 192
    6fd6:	98 e0       	ldi	r25, 0x08	; 8
    6fd8:	fc 01       	movw	r30, r24
    6fda:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6fdc:	80 e4       	ldi	r24, 0x40	; 64
    6fde:	96 e0       	ldi	r25, 0x06	; 6
    6fe0:	20 ea       	ldi	r18, 0xA0	; 160
    6fe2:	fc 01       	movw	r30, r24
    6fe4:	21 83       	std	Z+1, r18	; 0x01
}
    6fe6:	0f 90       	pop	r0
    6fe8:	0f 90       	pop	r0
    6fea:	df 91       	pop	r29
    6fec:	cf 91       	pop	r28
    6fee:	08 95       	ret

00006ff0 <SPICS>:

void SPICS(uint8_t enable) {
    6ff0:	cf 93       	push	r28
    6ff2:	df 93       	push	r29
    6ff4:	0f 92       	push	r0
    6ff6:	cd b7       	in	r28, 0x3d	; 61
    6ff8:	de b7       	in	r29, 0x3e	; 62
    6ffa:	89 83       	std	Y+1, r24	; 0x01
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    6ffc:	89 81       	ldd	r24, Y+1	; 0x01
    6ffe:	88 23       	and	r24, r24
    7000:	31 f0       	breq	.+12     	; 0x700e <SPICS+0x1e>
    7002:	80 e4       	ldi	r24, 0x40	; 64
    7004:	96 e0       	ldi	r25, 0x06	; 6
    7006:	20 e1       	ldi	r18, 0x10	; 16
    7008:	fc 01       	movw	r30, r24
    700a:	26 83       	std	Z+6, r18	; 0x06
    700c:	05 c0       	rjmp	.+10     	; 0x7018 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    700e:	80 e4       	ldi	r24, 0x40	; 64
    7010:	96 e0       	ldi	r25, 0x06	; 6
    7012:	20 e1       	ldi	r18, 0x10	; 16
    7014:	fc 01       	movw	r30, r24
    7016:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    7018:	0f 90       	pop	r0
    701a:	df 91       	pop	r29
    701c:	cf 91       	pop	r28
    701e:	08 95       	ret

00007020 <SPIDisable>:

void SPIDisable() {
    7020:	cf 93       	push	r28
    7022:	df 93       	push	r29
    7024:	cd b7       	in	r28, 0x3d	; 61
    7026:	de b7       	in	r29, 0x3e	; 62
	
	PORTC.OUTSET = PIN4_bm;
    7028:	80 e4       	ldi	r24, 0x40	; 64
    702a:	96 e0       	ldi	r25, 0x06	; 6
    702c:	20 e1       	ldi	r18, 0x10	; 16
    702e:	fc 01       	movw	r30, r24
    7030:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    7032:	80 ec       	ldi	r24, 0xC0	; 192
    7034:	98 e0       	ldi	r25, 0x08	; 8
    7036:	fc 01       	movw	r30, r24
    7038:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    703a:	80 e4       	ldi	r24, 0x40	; 64
    703c:	96 e0       	ldi	r25, 0x06	; 6
    703e:	20 e1       	ldi	r18, 0x10	; 16
    7040:	fc 01       	movw	r30, r24
    7042:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    7044:	80 e4       	ldi	r24, 0x40	; 64
    7046:	96 e0       	ldi	r25, 0x06	; 6
    7048:	20 eb       	ldi	r18, 0xB0	; 176
    704a:	fc 01       	movw	r30, r24
    704c:	22 83       	std	Z+2, r18	; 0x02

}
    704e:	df 91       	pop	r29
    7050:	cf 91       	pop	r28
    7052:	08 95       	ret

00007054 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    7054:	cf 93       	push	r28
    7056:	df 93       	push	r29
    7058:	00 d0       	rcall	.+0      	; 0x705a <readFRAM+0x6>
    705a:	0f 92       	push	r0
    705c:	cd b7       	in	r28, 0x3d	; 61
    705e:	de b7       	in	r29, 0x3e	; 62
    7060:	8b 83       	std	Y+3, r24	; 0x03
    7062:	9c 83       	std	Y+4, r25	; 0x04
	
	SPIInit(SPI_MODE_0_gc);
    7064:	80 e0       	ldi	r24, 0x00	; 0
    7066:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    706a:	80 ec       	ldi	r24, 0xC0	; 192
    706c:	98 e0       	ldi	r25, 0x08	; 8
    706e:	20 ed       	ldi	r18, 0xD0	; 208
    7070:	fc 01       	movw	r30, r24
    7072:	20 83       	st	Z, r18
	SPICS(TRUE);
    7074:	81 e0       	ldi	r24, 0x01	; 1
    7076:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    707a:	80 e2       	ldi	r24, 0x20	; 32
    707c:	96 e0       	ldi	r25, 0x06	; 6
    707e:	28 e0       	ldi	r18, 0x08	; 8
    7080:	fc 01       	movw	r30, r24
    7082:	26 83       	std	Z+6, r18	; 0x06
	nop();
    7084:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    7086:	80 ec       	ldi	r24, 0xC0	; 192
    7088:	98 e0       	ldi	r25, 0x08	; 8
    708a:	23 e0       	ldi	r18, 0x03	; 3
    708c:	fc 01       	movw	r30, r24
    708e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7090:	00 00       	nop
    7092:	80 ec       	ldi	r24, 0xC0	; 192
    7094:	98 e0       	ldi	r25, 0x08	; 8
    7096:	fc 01       	movw	r30, r24
    7098:	82 81       	ldd	r24, Z+2	; 0x02
    709a:	88 23       	and	r24, r24
    709c:	d4 f7       	brge	.-12     	; 0x7092 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    709e:	80 ec       	ldi	r24, 0xC0	; 192
    70a0:	98 e0       	ldi	r25, 0x08	; 8
    70a2:	fc 01       	movw	r30, r24
    70a4:	83 81       	ldd	r24, Z+3	; 0x03
    70a6:	80 93 70 50 	sts	0x5070, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    70aa:	80 ec       	ldi	r24, 0xC0	; 192
    70ac:	98 e0       	ldi	r25, 0x08	; 8
    70ae:	20 91 57 40 	lds	r18, 0x4057
    70b2:	fc 01       	movw	r30, r24
    70b4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    70b6:	00 00       	nop
    70b8:	80 ec       	ldi	r24, 0xC0	; 192
    70ba:	98 e0       	ldi	r25, 0x08	; 8
    70bc:	fc 01       	movw	r30, r24
    70be:	82 81       	ldd	r24, Z+2	; 0x02
    70c0:	88 23       	and	r24, r24
    70c2:	d4 f7       	brge	.-12     	; 0x70b8 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    70c4:	80 ec       	ldi	r24, 0xC0	; 192
    70c6:	98 e0       	ldi	r25, 0x08	; 8
    70c8:	fc 01       	movw	r30, r24
    70ca:	83 81       	ldd	r24, Z+3	; 0x03
    70cc:	80 93 70 50 	sts	0x5070, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    70d0:	80 ec       	ldi	r24, 0xC0	; 192
    70d2:	98 e0       	ldi	r25, 0x08	; 8
    70d4:	26 e5       	ldi	r18, 0x56	; 86
    70d6:	30 e4       	ldi	r19, 0x40	; 64
    70d8:	f9 01       	movw	r30, r18
    70da:	20 81       	ld	r18, Z
    70dc:	fc 01       	movw	r30, r24
    70de:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    70e0:	00 00       	nop
    70e2:	80 ec       	ldi	r24, 0xC0	; 192
    70e4:	98 e0       	ldi	r25, 0x08	; 8
    70e6:	fc 01       	movw	r30, r24
    70e8:	82 81       	ldd	r24, Z+2	; 0x02
    70ea:	88 23       	and	r24, r24
    70ec:	d4 f7       	brge	.-12     	; 0x70e2 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    70ee:	80 ec       	ldi	r24, 0xC0	; 192
    70f0:	98 e0       	ldi	r25, 0x08	; 8
    70f2:	fc 01       	movw	r30, r24
    70f4:	83 81       	ldd	r24, Z+3	; 0x03
    70f6:	80 93 70 50 	sts	0x5070, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    70fa:	19 82       	std	Y+1, r1	; 0x01
    70fc:	1a 82       	std	Y+2, r1	; 0x02
    70fe:	1b c0       	rjmp	.+54     	; 0x7136 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    7100:	80 ec       	ldi	r24, 0xC0	; 192
    7102:	98 e0       	ldi	r25, 0x08	; 8
    7104:	2a ea       	ldi	r18, 0xAA	; 170
    7106:	fc 01       	movw	r30, r24
    7108:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    710a:	00 00       	nop
    710c:	80 ec       	ldi	r24, 0xC0	; 192
    710e:	98 e0       	ldi	r25, 0x08	; 8
    7110:	fc 01       	movw	r30, r24
    7112:	82 81       	ldd	r24, Z+2	; 0x02
    7114:	88 23       	and	r24, r24
    7116:	d4 f7       	brge	.-12     	; 0x710c <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    7118:	80 ec       	ldi	r24, 0xC0	; 192
    711a:	98 e0       	ldi	r25, 0x08	; 8
    711c:	fc 01       	movw	r30, r24
    711e:	23 81       	ldd	r18, Z+3	; 0x03
    7120:	89 81       	ldd	r24, Y+1	; 0x01
    7122:	9a 81       	ldd	r25, Y+2	; 0x02
    7124:	82 52       	subi	r24, 0x22	; 34
    7126:	9c 4d       	sbci	r25, 0xDC	; 220
    7128:	fc 01       	movw	r30, r24
    712a:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    712c:	89 81       	ldd	r24, Y+1	; 0x01
    712e:	9a 81       	ldd	r25, Y+2	; 0x02
    7130:	01 96       	adiw	r24, 0x01	; 1
    7132:	89 83       	std	Y+1, r24	; 0x01
    7134:	9a 83       	std	Y+2, r25	; 0x02
    7136:	29 81       	ldd	r18, Y+1	; 0x01
    7138:	3a 81       	ldd	r19, Y+2	; 0x02
    713a:	8b 81       	ldd	r24, Y+3	; 0x03
    713c:	9c 81       	ldd	r25, Y+4	; 0x04
    713e:	28 17       	cp	r18, r24
    7140:	39 07       	cpc	r19, r25
    7142:	f0 f2       	brcs	.-68     	; 0x7100 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7144:	80 e2       	ldi	r24, 0x20	; 32
    7146:	96 e0       	ldi	r25, 0x06	; 6
    7148:	28 e0       	ldi	r18, 0x08	; 8
    714a:	fc 01       	movw	r30, r24
    714c:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    714e:	80 e0       	ldi	r24, 0x00	; 0
    7150:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    7154:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>

}
    7158:	24 96       	adiw	r28, 0x04	; 4
    715a:	cd bf       	out	0x3d, r28	; 61
    715c:	de bf       	out	0x3e, r29	; 62
    715e:	df 91       	pop	r29
    7160:	cf 91       	pop	r28
    7162:	08 95       	ret

00007164 <FRAMTest3Channel>:

//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
    7164:	0f 93       	push	r16
    7166:	1f 93       	push	r17
    7168:	cf 93       	push	r28
    716a:	df 93       	push	r29
    716c:	cd b7       	in	r28, 0x3d	; 61
    716e:	de b7       	in	r29, 0x3e	; 62
    7170:	68 97       	sbiw	r28, 0x18	; 24
    7172:	cd bf       	out	0x3d, r28	; 61
    7174:	de bf       	out	0x3e, r29	; 62
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7176:	81 e0       	ldi	r24, 0x01	; 1
    7178:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
    717c:	80 e0       	ldi	r24, 0x00	; 0
    717e:	90 e0       	ldi	r25, 0x00	; 0
    7180:	aa e7       	ldi	r26, 0x7A	; 122
    7182:	b3 e4       	ldi	r27, 0x43	; 67
    7184:	89 83       	std	Y+1, r24	; 0x01
    7186:	9a 83       	std	Y+2, r25	; 0x02
    7188:	ab 83       	std	Y+3, r26	; 0x03
    718a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    718c:	69 81       	ldd	r22, Y+1	; 0x01
    718e:	7a 81       	ldd	r23, Y+2	; 0x02
    7190:	8b 81       	ldd	r24, Y+3	; 0x03
    7192:	9c 81       	ldd	r25, Y+4	; 0x04
    7194:	2b ea       	ldi	r18, 0xAB	; 171
    7196:	3a ea       	ldi	r19, 0xAA	; 170
    7198:	4a e2       	ldi	r20, 0x2A	; 42
    719a:	51 e4       	ldi	r21, 0x41	; 65
    719c:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    71a0:	dc 01       	movw	r26, r24
    71a2:	cb 01       	movw	r24, r22
    71a4:	8d 83       	std	Y+5, r24	; 0x05
    71a6:	9e 83       	std	Y+6, r25	; 0x06
    71a8:	af 83       	std	Y+7, r26	; 0x07
    71aa:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    71ac:	11 e0       	ldi	r17, 0x01	; 1
    71ae:	6d 81       	ldd	r22, Y+5	; 0x05
    71b0:	7e 81       	ldd	r23, Y+6	; 0x06
    71b2:	8f 81       	ldd	r24, Y+7	; 0x07
    71b4:	98 85       	ldd	r25, Y+8	; 0x08
    71b6:	20 e0       	ldi	r18, 0x00	; 0
    71b8:	30 e0       	ldi	r19, 0x00	; 0
    71ba:	40 e8       	ldi	r20, 0x80	; 128
    71bc:	5f e3       	ldi	r21, 0x3F	; 63
    71be:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    71c2:	88 23       	and	r24, r24
    71c4:	0c f0       	brlt	.+2      	; 0x71c8 <FRAMTest3Channel+0x64>
    71c6:	10 e0       	ldi	r17, 0x00	; 0
    71c8:	11 23       	and	r17, r17
    71ca:	19 f0       	breq	.+6      	; 0x71d2 <FRAMTest3Channel+0x6e>
		__ticks = 1;
    71cc:	81 e0       	ldi	r24, 0x01	; 1
    71ce:	89 87       	std	Y+9, r24	; 0x09
    71d0:	a3 c0       	rjmp	.+326    	; 0x7318 <FRAMTest3Channel+0x1b4>
	else if (__tmp > 255)
    71d2:	11 e0       	ldi	r17, 0x01	; 1
    71d4:	6d 81       	ldd	r22, Y+5	; 0x05
    71d6:	7e 81       	ldd	r23, Y+6	; 0x06
    71d8:	8f 81       	ldd	r24, Y+7	; 0x07
    71da:	98 85       	ldd	r25, Y+8	; 0x08
    71dc:	20 e0       	ldi	r18, 0x00	; 0
    71de:	30 e0       	ldi	r19, 0x00	; 0
    71e0:	4f e7       	ldi	r20, 0x7F	; 127
    71e2:	53 e4       	ldi	r21, 0x43	; 67
    71e4:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    71e8:	18 16       	cp	r1, r24
    71ea:	0c f0       	brlt	.+2      	; 0x71ee <FRAMTest3Channel+0x8a>
    71ec:	10 e0       	ldi	r17, 0x00	; 0
    71ee:	11 23       	and	r17, r17
    71f0:	09 f4       	brne	.+2      	; 0x71f4 <FRAMTest3Channel+0x90>
    71f2:	89 c0       	rjmp	.+274    	; 0x7306 <FRAMTest3Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    71f4:	69 81       	ldd	r22, Y+1	; 0x01
    71f6:	7a 81       	ldd	r23, Y+2	; 0x02
    71f8:	8b 81       	ldd	r24, Y+3	; 0x03
    71fa:	9c 81       	ldd	r25, Y+4	; 0x04
    71fc:	20 e0       	ldi	r18, 0x00	; 0
    71fe:	30 e0       	ldi	r19, 0x00	; 0
    7200:	4a e7       	ldi	r20, 0x7A	; 122
    7202:	54 e4       	ldi	r21, 0x44	; 68
    7204:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    7208:	dc 01       	movw	r26, r24
    720a:	cb 01       	movw	r24, r22
    720c:	8a 87       	std	Y+10, r24	; 0x0a
    720e:	9b 87       	std	Y+11, r25	; 0x0b
    7210:	ac 87       	std	Y+12, r26	; 0x0c
    7212:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7214:	6a 85       	ldd	r22, Y+10	; 0x0a
    7216:	7b 85       	ldd	r23, Y+11	; 0x0b
    7218:	8c 85       	ldd	r24, Y+12	; 0x0c
    721a:	9d 85       	ldd	r25, Y+13	; 0x0d
    721c:	20 e0       	ldi	r18, 0x00	; 0
    721e:	30 e0       	ldi	r19, 0x00	; 0
    7220:	4a ef       	ldi	r20, 0xFA	; 250
    7222:	55 e4       	ldi	r21, 0x45	; 69
    7224:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    7228:	dc 01       	movw	r26, r24
    722a:	cb 01       	movw	r24, r22
    722c:	8e 87       	std	Y+14, r24	; 0x0e
    722e:	9f 87       	std	Y+15, r25	; 0x0f
    7230:	a8 8b       	std	Y+16, r26	; 0x10
    7232:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7234:	11 e0       	ldi	r17, 0x01	; 1
    7236:	6e 85       	ldd	r22, Y+14	; 0x0e
    7238:	7f 85       	ldd	r23, Y+15	; 0x0f
    723a:	88 89       	ldd	r24, Y+16	; 0x10
    723c:	99 89       	ldd	r25, Y+17	; 0x11
    723e:	20 e0       	ldi	r18, 0x00	; 0
    7240:	30 e0       	ldi	r19, 0x00	; 0
    7242:	40 e8       	ldi	r20, 0x80	; 128
    7244:	5f e3       	ldi	r21, 0x3F	; 63
    7246:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    724a:	88 23       	and	r24, r24
    724c:	0c f0       	brlt	.+2      	; 0x7250 <FRAMTest3Channel+0xec>
    724e:	10 e0       	ldi	r17, 0x00	; 0
    7250:	11 23       	and	r17, r17
    7252:	29 f0       	breq	.+10     	; 0x725e <FRAMTest3Channel+0xfa>
		__ticks = 1;
    7254:	81 e0       	ldi	r24, 0x01	; 1
    7256:	90 e0       	ldi	r25, 0x00	; 0
    7258:	8a 8b       	std	Y+18, r24	; 0x12
    725a:	9b 8b       	std	Y+19, r25	; 0x13
    725c:	46 c0       	rjmp	.+140    	; 0x72ea <FRAMTest3Channel+0x186>
	else if (__tmp > 65535)
    725e:	11 e0       	ldi	r17, 0x01	; 1
    7260:	6e 85       	ldd	r22, Y+14	; 0x0e
    7262:	7f 85       	ldd	r23, Y+15	; 0x0f
    7264:	88 89       	ldd	r24, Y+16	; 0x10
    7266:	99 89       	ldd	r25, Y+17	; 0x11
    7268:	20 e0       	ldi	r18, 0x00	; 0
    726a:	3f ef       	ldi	r19, 0xFF	; 255
    726c:	4f e7       	ldi	r20, 0x7F	; 127
    726e:	57 e4       	ldi	r21, 0x47	; 71
    7270:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    7274:	18 16       	cp	r1, r24
    7276:	0c f0       	brlt	.+2      	; 0x727a <FRAMTest3Channel+0x116>
    7278:	10 e0       	ldi	r17, 0x00	; 0
    727a:	11 23       	and	r17, r17
    727c:	61 f1       	breq	.+88     	; 0x72d6 <FRAMTest3Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    727e:	6a 85       	ldd	r22, Y+10	; 0x0a
    7280:	7b 85       	ldd	r23, Y+11	; 0x0b
    7282:	8c 85       	ldd	r24, Y+12	; 0x0c
    7284:	9d 85       	ldd	r25, Y+13	; 0x0d
    7286:	20 e0       	ldi	r18, 0x00	; 0
    7288:	30 e0       	ldi	r19, 0x00	; 0
    728a:	40 e2       	ldi	r20, 0x20	; 32
    728c:	51 e4       	ldi	r21, 0x41	; 65
    728e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    7292:	dc 01       	movw	r26, r24
    7294:	cb 01       	movw	r24, r22
    7296:	bc 01       	movw	r22, r24
    7298:	cd 01       	movw	r24, r26
    729a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    729e:	dc 01       	movw	r26, r24
    72a0:	cb 01       	movw	r24, r22
    72a2:	8a 8b       	std	Y+18, r24	; 0x12
    72a4:	9b 8b       	std	Y+19, r25	; 0x13
    72a6:	12 c0       	rjmp	.+36     	; 0x72cc <FRAMTest3Channel+0x168>
    72a8:	80 e2       	ldi	r24, 0x20	; 32
    72aa:	93 e0       	ldi	r25, 0x03	; 3
    72ac:	8c 8b       	std	Y+20, r24	; 0x14
    72ae:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    72b0:	8c 89       	ldd	r24, Y+20	; 0x14
    72b2:	9d 89       	ldd	r25, Y+21	; 0x15
    72b4:	8c 01       	movw	r16, r24
    72b6:	c8 01       	movw	r24, r16
    72b8:	01 97       	sbiw	r24, 0x01	; 1
    72ba:	f1 f7       	brne	.-4      	; 0x72b8 <FRAMTest3Channel+0x154>
    72bc:	8c 01       	movw	r16, r24
    72be:	0c 8b       	std	Y+20, r16	; 0x14
    72c0:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    72c2:	8a 89       	ldd	r24, Y+18	; 0x12
    72c4:	9b 89       	ldd	r25, Y+19	; 0x13
    72c6:	01 97       	sbiw	r24, 0x01	; 1
    72c8:	8a 8b       	std	Y+18, r24	; 0x12
    72ca:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    72cc:	8a 89       	ldd	r24, Y+18	; 0x12
    72ce:	9b 89       	ldd	r25, Y+19	; 0x13
    72d0:	00 97       	sbiw	r24, 0x00	; 0
    72d2:	51 f7       	brne	.-44     	; 0x72a8 <FRAMTest3Channel+0x144>
    72d4:	28 c0       	rjmp	.+80     	; 0x7326 <FRAMTest3Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    72d6:	6e 85       	ldd	r22, Y+14	; 0x0e
    72d8:	7f 85       	ldd	r23, Y+15	; 0x0f
    72da:	88 89       	ldd	r24, Y+16	; 0x10
    72dc:	99 89       	ldd	r25, Y+17	; 0x11
    72de:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    72e2:	dc 01       	movw	r26, r24
    72e4:	cb 01       	movw	r24, r22
    72e6:	8a 8b       	std	Y+18, r24	; 0x12
    72e8:	9b 8b       	std	Y+19, r25	; 0x13
    72ea:	8a 89       	ldd	r24, Y+18	; 0x12
    72ec:	9b 89       	ldd	r25, Y+19	; 0x13
    72ee:	8e 8b       	std	Y+22, r24	; 0x16
    72f0:	9f 8b       	std	Y+23, r25	; 0x17
    72f2:	8e 89       	ldd	r24, Y+22	; 0x16
    72f4:	9f 89       	ldd	r25, Y+23	; 0x17
    72f6:	8c 01       	movw	r16, r24
    72f8:	c8 01       	movw	r24, r16
    72fa:	01 97       	sbiw	r24, 0x01	; 1
    72fc:	f1 f7       	brne	.-4      	; 0x72fa <FRAMTest3Channel+0x196>
    72fe:	8c 01       	movw	r16, r24
    7300:	0e 8b       	std	Y+22, r16	; 0x16
    7302:	1f 8b       	std	Y+23, r17	; 0x17
    7304:	10 c0       	rjmp	.+32     	; 0x7326 <FRAMTest3Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7306:	6d 81       	ldd	r22, Y+5	; 0x05
    7308:	7e 81       	ldd	r23, Y+6	; 0x06
    730a:	8f 81       	ldd	r24, Y+7	; 0x07
    730c:	98 85       	ldd	r25, Y+8	; 0x08
    730e:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    7312:	dc 01       	movw	r26, r24
    7314:	cb 01       	movw	r24, r22
    7316:	89 87       	std	Y+9, r24	; 0x09
    7318:	89 85       	ldd	r24, Y+9	; 0x09
    731a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    731c:	88 8d       	ldd	r24, Y+24	; 0x18
    731e:	18 2f       	mov	r17, r24
    7320:	1a 95       	dec	r17
    7322:	f1 f7       	brne	.-4      	; 0x7320 <FRAMTest3Channel+0x1bc>
    7324:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7326:	0e 94 29 16 	call	0x2c52	; 0x2c52 <calcChecksumFRAM>

	ADCPower(FALSE);
    732a:	80 e0       	ldi	r24, 0x00	; 0
    732c:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	
}
    7330:	68 96       	adiw	r28, 0x18	; 24
    7332:	cd bf       	out	0x3d, r28	; 61
    7334:	de bf       	out	0x3e, r29	; 62
    7336:	df 91       	pop	r29
    7338:	cf 91       	pop	r28
    733a:	1f 91       	pop	r17
    733c:	0f 91       	pop	r16
    733e:	08 95       	ret

00007340 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {
    7340:	0f 93       	push	r16
    7342:	1f 93       	push	r17
    7344:	cf 93       	push	r28
    7346:	df 93       	push	r29
    7348:	cd b7       	in	r28, 0x3d	; 61
    734a:	de b7       	in	r29, 0x3e	; 62
    734c:	68 97       	sbiw	r28, 0x18	; 24
    734e:	cd bf       	out	0x3d, r28	; 61
    7350:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7352:	81 e0       	ldi	r24, 0x01	; 1
    7354:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
    7358:	80 e0       	ldi	r24, 0x00	; 0
    735a:	90 e0       	ldi	r25, 0x00	; 0
    735c:	aa e7       	ldi	r26, 0x7A	; 122
    735e:	b3 e4       	ldi	r27, 0x43	; 67
    7360:	89 83       	std	Y+1, r24	; 0x01
    7362:	9a 83       	std	Y+2, r25	; 0x02
    7364:	ab 83       	std	Y+3, r26	; 0x03
    7366:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7368:	69 81       	ldd	r22, Y+1	; 0x01
    736a:	7a 81       	ldd	r23, Y+2	; 0x02
    736c:	8b 81       	ldd	r24, Y+3	; 0x03
    736e:	9c 81       	ldd	r25, Y+4	; 0x04
    7370:	2b ea       	ldi	r18, 0xAB	; 171
    7372:	3a ea       	ldi	r19, 0xAA	; 170
    7374:	4a e2       	ldi	r20, 0x2A	; 42
    7376:	51 e4       	ldi	r21, 0x41	; 65
    7378:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    737c:	dc 01       	movw	r26, r24
    737e:	cb 01       	movw	r24, r22
    7380:	8d 83       	std	Y+5, r24	; 0x05
    7382:	9e 83       	std	Y+6, r25	; 0x06
    7384:	af 83       	std	Y+7, r26	; 0x07
    7386:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7388:	11 e0       	ldi	r17, 0x01	; 1
    738a:	6d 81       	ldd	r22, Y+5	; 0x05
    738c:	7e 81       	ldd	r23, Y+6	; 0x06
    738e:	8f 81       	ldd	r24, Y+7	; 0x07
    7390:	98 85       	ldd	r25, Y+8	; 0x08
    7392:	20 e0       	ldi	r18, 0x00	; 0
    7394:	30 e0       	ldi	r19, 0x00	; 0
    7396:	40 e8       	ldi	r20, 0x80	; 128
    7398:	5f e3       	ldi	r21, 0x3F	; 63
    739a:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    739e:	88 23       	and	r24, r24
    73a0:	0c f0       	brlt	.+2      	; 0x73a4 <FRAMTest1Channel+0x64>
    73a2:	10 e0       	ldi	r17, 0x00	; 0
    73a4:	11 23       	and	r17, r17
    73a6:	19 f0       	breq	.+6      	; 0x73ae <FRAMTest1Channel+0x6e>
		__ticks = 1;
    73a8:	81 e0       	ldi	r24, 0x01	; 1
    73aa:	89 87       	std	Y+9, r24	; 0x09
    73ac:	a3 c0       	rjmp	.+326    	; 0x74f4 <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    73ae:	11 e0       	ldi	r17, 0x01	; 1
    73b0:	6d 81       	ldd	r22, Y+5	; 0x05
    73b2:	7e 81       	ldd	r23, Y+6	; 0x06
    73b4:	8f 81       	ldd	r24, Y+7	; 0x07
    73b6:	98 85       	ldd	r25, Y+8	; 0x08
    73b8:	20 e0       	ldi	r18, 0x00	; 0
    73ba:	30 e0       	ldi	r19, 0x00	; 0
    73bc:	4f e7       	ldi	r20, 0x7F	; 127
    73be:	53 e4       	ldi	r21, 0x43	; 67
    73c0:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    73c4:	18 16       	cp	r1, r24
    73c6:	0c f0       	brlt	.+2      	; 0x73ca <FRAMTest1Channel+0x8a>
    73c8:	10 e0       	ldi	r17, 0x00	; 0
    73ca:	11 23       	and	r17, r17
    73cc:	09 f4       	brne	.+2      	; 0x73d0 <FRAMTest1Channel+0x90>
    73ce:	89 c0       	rjmp	.+274    	; 0x74e2 <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    73d0:	69 81       	ldd	r22, Y+1	; 0x01
    73d2:	7a 81       	ldd	r23, Y+2	; 0x02
    73d4:	8b 81       	ldd	r24, Y+3	; 0x03
    73d6:	9c 81       	ldd	r25, Y+4	; 0x04
    73d8:	20 e0       	ldi	r18, 0x00	; 0
    73da:	30 e0       	ldi	r19, 0x00	; 0
    73dc:	4a e7       	ldi	r20, 0x7A	; 122
    73de:	54 e4       	ldi	r21, 0x44	; 68
    73e0:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    73e4:	dc 01       	movw	r26, r24
    73e6:	cb 01       	movw	r24, r22
    73e8:	8a 87       	std	Y+10, r24	; 0x0a
    73ea:	9b 87       	std	Y+11, r25	; 0x0b
    73ec:	ac 87       	std	Y+12, r26	; 0x0c
    73ee:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    73f0:	6a 85       	ldd	r22, Y+10	; 0x0a
    73f2:	7b 85       	ldd	r23, Y+11	; 0x0b
    73f4:	8c 85       	ldd	r24, Y+12	; 0x0c
    73f6:	9d 85       	ldd	r25, Y+13	; 0x0d
    73f8:	20 e0       	ldi	r18, 0x00	; 0
    73fa:	30 e0       	ldi	r19, 0x00	; 0
    73fc:	4a ef       	ldi	r20, 0xFA	; 250
    73fe:	55 e4       	ldi	r21, 0x45	; 69
    7400:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    7404:	dc 01       	movw	r26, r24
    7406:	cb 01       	movw	r24, r22
    7408:	8e 87       	std	Y+14, r24	; 0x0e
    740a:	9f 87       	std	Y+15, r25	; 0x0f
    740c:	a8 8b       	std	Y+16, r26	; 0x10
    740e:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7410:	11 e0       	ldi	r17, 0x01	; 1
    7412:	6e 85       	ldd	r22, Y+14	; 0x0e
    7414:	7f 85       	ldd	r23, Y+15	; 0x0f
    7416:	88 89       	ldd	r24, Y+16	; 0x10
    7418:	99 89       	ldd	r25, Y+17	; 0x11
    741a:	20 e0       	ldi	r18, 0x00	; 0
    741c:	30 e0       	ldi	r19, 0x00	; 0
    741e:	40 e8       	ldi	r20, 0x80	; 128
    7420:	5f e3       	ldi	r21, 0x3F	; 63
    7422:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    7426:	88 23       	and	r24, r24
    7428:	0c f0       	brlt	.+2      	; 0x742c <FRAMTest1Channel+0xec>
    742a:	10 e0       	ldi	r17, 0x00	; 0
    742c:	11 23       	and	r17, r17
    742e:	29 f0       	breq	.+10     	; 0x743a <FRAMTest1Channel+0xfa>
		__ticks = 1;
    7430:	81 e0       	ldi	r24, 0x01	; 1
    7432:	90 e0       	ldi	r25, 0x00	; 0
    7434:	8a 8b       	std	Y+18, r24	; 0x12
    7436:	9b 8b       	std	Y+19, r25	; 0x13
    7438:	46 c0       	rjmp	.+140    	; 0x74c6 <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    743a:	11 e0       	ldi	r17, 0x01	; 1
    743c:	6e 85       	ldd	r22, Y+14	; 0x0e
    743e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7440:	88 89       	ldd	r24, Y+16	; 0x10
    7442:	99 89       	ldd	r25, Y+17	; 0x11
    7444:	20 e0       	ldi	r18, 0x00	; 0
    7446:	3f ef       	ldi	r19, 0xFF	; 255
    7448:	4f e7       	ldi	r20, 0x7F	; 127
    744a:	57 e4       	ldi	r21, 0x47	; 71
    744c:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    7450:	18 16       	cp	r1, r24
    7452:	0c f0       	brlt	.+2      	; 0x7456 <FRAMTest1Channel+0x116>
    7454:	10 e0       	ldi	r17, 0x00	; 0
    7456:	11 23       	and	r17, r17
    7458:	61 f1       	breq	.+88     	; 0x74b2 <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    745a:	6a 85       	ldd	r22, Y+10	; 0x0a
    745c:	7b 85       	ldd	r23, Y+11	; 0x0b
    745e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7460:	9d 85       	ldd	r25, Y+13	; 0x0d
    7462:	20 e0       	ldi	r18, 0x00	; 0
    7464:	30 e0       	ldi	r19, 0x00	; 0
    7466:	40 e2       	ldi	r20, 0x20	; 32
    7468:	51 e4       	ldi	r21, 0x41	; 65
    746a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    746e:	dc 01       	movw	r26, r24
    7470:	cb 01       	movw	r24, r22
    7472:	bc 01       	movw	r22, r24
    7474:	cd 01       	movw	r24, r26
    7476:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    747a:	dc 01       	movw	r26, r24
    747c:	cb 01       	movw	r24, r22
    747e:	8a 8b       	std	Y+18, r24	; 0x12
    7480:	9b 8b       	std	Y+19, r25	; 0x13
    7482:	12 c0       	rjmp	.+36     	; 0x74a8 <FRAMTest1Channel+0x168>
    7484:	80 e2       	ldi	r24, 0x20	; 32
    7486:	93 e0       	ldi	r25, 0x03	; 3
    7488:	8c 8b       	std	Y+20, r24	; 0x14
    748a:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    748c:	8c 89       	ldd	r24, Y+20	; 0x14
    748e:	9d 89       	ldd	r25, Y+21	; 0x15
    7490:	8c 01       	movw	r16, r24
    7492:	c8 01       	movw	r24, r16
    7494:	01 97       	sbiw	r24, 0x01	; 1
    7496:	f1 f7       	brne	.-4      	; 0x7494 <FRAMTest1Channel+0x154>
    7498:	8c 01       	movw	r16, r24
    749a:	0c 8b       	std	Y+20, r16	; 0x14
    749c:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    749e:	8a 89       	ldd	r24, Y+18	; 0x12
    74a0:	9b 89       	ldd	r25, Y+19	; 0x13
    74a2:	01 97       	sbiw	r24, 0x01	; 1
    74a4:	8a 8b       	std	Y+18, r24	; 0x12
    74a6:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    74a8:	8a 89       	ldd	r24, Y+18	; 0x12
    74aa:	9b 89       	ldd	r25, Y+19	; 0x13
    74ac:	00 97       	sbiw	r24, 0x00	; 0
    74ae:	51 f7       	brne	.-44     	; 0x7484 <FRAMTest1Channel+0x144>
    74b0:	28 c0       	rjmp	.+80     	; 0x7502 <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    74b2:	6e 85       	ldd	r22, Y+14	; 0x0e
    74b4:	7f 85       	ldd	r23, Y+15	; 0x0f
    74b6:	88 89       	ldd	r24, Y+16	; 0x10
    74b8:	99 89       	ldd	r25, Y+17	; 0x11
    74ba:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    74be:	dc 01       	movw	r26, r24
    74c0:	cb 01       	movw	r24, r22
    74c2:	8a 8b       	std	Y+18, r24	; 0x12
    74c4:	9b 8b       	std	Y+19, r25	; 0x13
    74c6:	8a 89       	ldd	r24, Y+18	; 0x12
    74c8:	9b 89       	ldd	r25, Y+19	; 0x13
    74ca:	8e 8b       	std	Y+22, r24	; 0x16
    74cc:	9f 8b       	std	Y+23, r25	; 0x17
    74ce:	8e 89       	ldd	r24, Y+22	; 0x16
    74d0:	9f 89       	ldd	r25, Y+23	; 0x17
    74d2:	8c 01       	movw	r16, r24
    74d4:	c8 01       	movw	r24, r16
    74d6:	01 97       	sbiw	r24, 0x01	; 1
    74d8:	f1 f7       	brne	.-4      	; 0x74d6 <FRAMTest1Channel+0x196>
    74da:	8c 01       	movw	r16, r24
    74dc:	0e 8b       	std	Y+22, r16	; 0x16
    74de:	1f 8b       	std	Y+23, r17	; 0x17
    74e0:	10 c0       	rjmp	.+32     	; 0x7502 <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    74e2:	6d 81       	ldd	r22, Y+5	; 0x05
    74e4:	7e 81       	ldd	r23, Y+6	; 0x06
    74e6:	8f 81       	ldd	r24, Y+7	; 0x07
    74e8:	98 85       	ldd	r25, Y+8	; 0x08
    74ea:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    74ee:	dc 01       	movw	r26, r24
    74f0:	cb 01       	movw	r24, r22
    74f2:	89 87       	std	Y+9, r24	; 0x09
    74f4:	89 85       	ldd	r24, Y+9	; 0x09
    74f6:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    74f8:	88 8d       	ldd	r24, Y+24	; 0x18
    74fa:	18 2f       	mov	r17, r24
    74fc:	1a 95       	dec	r17
    74fe:	f1 f7       	brne	.-4      	; 0x74fc <FRAMTest1Channel+0x1bc>
    7500:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7502:	0e 94 29 16 	call	0x2c52	; 0x2c52 <calcChecksumFRAM>

	ADCPower(FALSE);
    7506:	80 e0       	ldi	r24, 0x00	; 0
    7508:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>

}
    750c:	68 96       	adiw	r28, 0x18	; 24
    750e:	cd bf       	out	0x3d, r28	; 61
    7510:	de bf       	out	0x3e, r29	; 62
    7512:	df 91       	pop	r29
    7514:	cf 91       	pop	r28
    7516:	1f 91       	pop	r17
    7518:	0f 91       	pop	r16
    751a:	08 95       	ret

0000751c <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    751c:	0f 93       	push	r16
    751e:	1f 93       	push	r17
    7520:	cf 93       	push	r28
    7522:	df 93       	push	r29
    7524:	cd b7       	in	r28, 0x3d	; 61
    7526:	de b7       	in	r29, 0x3e	; 62
    7528:	68 97       	sbiw	r28, 0x18	; 24
    752a:	cd bf       	out	0x3d, r28	; 61
    752c:	de bf       	out	0x3e, r29	; 62
	
	FRAMWriteKnowns();
    752e:	0e 94 31 19 	call	0x3262	; 0x3262 <FRAMWriteKnowns>
	ADCPower(TRUE);
    7532:	81 e0       	ldi	r24, 0x01	; 1
    7534:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
    7538:	80 e0       	ldi	r24, 0x00	; 0
    753a:	90 e0       	ldi	r25, 0x00	; 0
    753c:	aa e7       	ldi	r26, 0x7A	; 122
    753e:	b3 e4       	ldi	r27, 0x43	; 67
    7540:	89 83       	std	Y+1, r24	; 0x01
    7542:	9a 83       	std	Y+2, r25	; 0x02
    7544:	ab 83       	std	Y+3, r26	; 0x03
    7546:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7548:	69 81       	ldd	r22, Y+1	; 0x01
    754a:	7a 81       	ldd	r23, Y+2	; 0x02
    754c:	8b 81       	ldd	r24, Y+3	; 0x03
    754e:	9c 81       	ldd	r25, Y+4	; 0x04
    7550:	2b ea       	ldi	r18, 0xAB	; 171
    7552:	3a ea       	ldi	r19, 0xAA	; 170
    7554:	4a e2       	ldi	r20, 0x2A	; 42
    7556:	51 e4       	ldi	r21, 0x41	; 65
    7558:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    755c:	dc 01       	movw	r26, r24
    755e:	cb 01       	movw	r24, r22
    7560:	8d 83       	std	Y+5, r24	; 0x05
    7562:	9e 83       	std	Y+6, r25	; 0x06
    7564:	af 83       	std	Y+7, r26	; 0x07
    7566:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7568:	11 e0       	ldi	r17, 0x01	; 1
    756a:	6d 81       	ldd	r22, Y+5	; 0x05
    756c:	7e 81       	ldd	r23, Y+6	; 0x06
    756e:	8f 81       	ldd	r24, Y+7	; 0x07
    7570:	98 85       	ldd	r25, Y+8	; 0x08
    7572:	20 e0       	ldi	r18, 0x00	; 0
    7574:	30 e0       	ldi	r19, 0x00	; 0
    7576:	40 e8       	ldi	r20, 0x80	; 128
    7578:	5f e3       	ldi	r21, 0x3F	; 63
    757a:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    757e:	88 23       	and	r24, r24
    7580:	0c f0       	brlt	.+2      	; 0x7584 <FRAMWriteKnownsCheck+0x68>
    7582:	10 e0       	ldi	r17, 0x00	; 0
    7584:	11 23       	and	r17, r17
    7586:	19 f0       	breq	.+6      	; 0x758e <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    7588:	81 e0       	ldi	r24, 0x01	; 1
    758a:	89 87       	std	Y+9, r24	; 0x09
    758c:	a3 c0       	rjmp	.+326    	; 0x76d4 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    758e:	11 e0       	ldi	r17, 0x01	; 1
    7590:	6d 81       	ldd	r22, Y+5	; 0x05
    7592:	7e 81       	ldd	r23, Y+6	; 0x06
    7594:	8f 81       	ldd	r24, Y+7	; 0x07
    7596:	98 85       	ldd	r25, Y+8	; 0x08
    7598:	20 e0       	ldi	r18, 0x00	; 0
    759a:	30 e0       	ldi	r19, 0x00	; 0
    759c:	4f e7       	ldi	r20, 0x7F	; 127
    759e:	53 e4       	ldi	r21, 0x43	; 67
    75a0:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    75a4:	18 16       	cp	r1, r24
    75a6:	0c f0       	brlt	.+2      	; 0x75aa <FRAMWriteKnownsCheck+0x8e>
    75a8:	10 e0       	ldi	r17, 0x00	; 0
    75aa:	11 23       	and	r17, r17
    75ac:	09 f4       	brne	.+2      	; 0x75b0 <FRAMWriteKnownsCheck+0x94>
    75ae:	89 c0       	rjmp	.+274    	; 0x76c2 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    75b0:	69 81       	ldd	r22, Y+1	; 0x01
    75b2:	7a 81       	ldd	r23, Y+2	; 0x02
    75b4:	8b 81       	ldd	r24, Y+3	; 0x03
    75b6:	9c 81       	ldd	r25, Y+4	; 0x04
    75b8:	20 e0       	ldi	r18, 0x00	; 0
    75ba:	30 e0       	ldi	r19, 0x00	; 0
    75bc:	4a e7       	ldi	r20, 0x7A	; 122
    75be:	54 e4       	ldi	r21, 0x44	; 68
    75c0:	0e 94 fd 5a 	call	0xb5fa	; 0xb5fa <__divsf3>
    75c4:	dc 01       	movw	r26, r24
    75c6:	cb 01       	movw	r24, r22
    75c8:	8a 87       	std	Y+10, r24	; 0x0a
    75ca:	9b 87       	std	Y+11, r25	; 0x0b
    75cc:	ac 87       	std	Y+12, r26	; 0x0c
    75ce:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    75d0:	6a 85       	ldd	r22, Y+10	; 0x0a
    75d2:	7b 85       	ldd	r23, Y+11	; 0x0b
    75d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    75d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    75d8:	20 e0       	ldi	r18, 0x00	; 0
    75da:	30 e0       	ldi	r19, 0x00	; 0
    75dc:	4a ef       	ldi	r20, 0xFA	; 250
    75de:	55 e4       	ldi	r21, 0x45	; 69
    75e0:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    75e4:	dc 01       	movw	r26, r24
    75e6:	cb 01       	movw	r24, r22
    75e8:	8e 87       	std	Y+14, r24	; 0x0e
    75ea:	9f 87       	std	Y+15, r25	; 0x0f
    75ec:	a8 8b       	std	Y+16, r26	; 0x10
    75ee:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    75f0:	11 e0       	ldi	r17, 0x01	; 1
    75f2:	6e 85       	ldd	r22, Y+14	; 0x0e
    75f4:	7f 85       	ldd	r23, Y+15	; 0x0f
    75f6:	88 89       	ldd	r24, Y+16	; 0x10
    75f8:	99 89       	ldd	r25, Y+17	; 0x11
    75fa:	20 e0       	ldi	r18, 0x00	; 0
    75fc:	30 e0       	ldi	r19, 0x00	; 0
    75fe:	40 e8       	ldi	r20, 0x80	; 128
    7600:	5f e3       	ldi	r21, 0x3F	; 63
    7602:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    7606:	88 23       	and	r24, r24
    7608:	0c f0       	brlt	.+2      	; 0x760c <FRAMWriteKnownsCheck+0xf0>
    760a:	10 e0       	ldi	r17, 0x00	; 0
    760c:	11 23       	and	r17, r17
    760e:	29 f0       	breq	.+10     	; 0x761a <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    7610:	81 e0       	ldi	r24, 0x01	; 1
    7612:	90 e0       	ldi	r25, 0x00	; 0
    7614:	8a 8b       	std	Y+18, r24	; 0x12
    7616:	9b 8b       	std	Y+19, r25	; 0x13
    7618:	46 c0       	rjmp	.+140    	; 0x76a6 <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    761a:	11 e0       	ldi	r17, 0x01	; 1
    761c:	6e 85       	ldd	r22, Y+14	; 0x0e
    761e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7620:	88 89       	ldd	r24, Y+16	; 0x10
    7622:	99 89       	ldd	r25, Y+17	; 0x11
    7624:	20 e0       	ldi	r18, 0x00	; 0
    7626:	3f ef       	ldi	r19, 0xFF	; 255
    7628:	4f e7       	ldi	r20, 0x7F	; 127
    762a:	57 e4       	ldi	r21, 0x47	; 71
    762c:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    7630:	18 16       	cp	r1, r24
    7632:	0c f0       	brlt	.+2      	; 0x7636 <FRAMWriteKnownsCheck+0x11a>
    7634:	10 e0       	ldi	r17, 0x00	; 0
    7636:	11 23       	and	r17, r17
    7638:	61 f1       	breq	.+88     	; 0x7692 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    763a:	6a 85       	ldd	r22, Y+10	; 0x0a
    763c:	7b 85       	ldd	r23, Y+11	; 0x0b
    763e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7640:	9d 85       	ldd	r25, Y+13	; 0x0d
    7642:	20 e0       	ldi	r18, 0x00	; 0
    7644:	30 e0       	ldi	r19, 0x00	; 0
    7646:	40 e2       	ldi	r20, 0x20	; 32
    7648:	51 e4       	ldi	r21, 0x41	; 65
    764a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    764e:	dc 01       	movw	r26, r24
    7650:	cb 01       	movw	r24, r22
    7652:	bc 01       	movw	r22, r24
    7654:	cd 01       	movw	r24, r26
    7656:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    765a:	dc 01       	movw	r26, r24
    765c:	cb 01       	movw	r24, r22
    765e:	8a 8b       	std	Y+18, r24	; 0x12
    7660:	9b 8b       	std	Y+19, r25	; 0x13
    7662:	12 c0       	rjmp	.+36     	; 0x7688 <FRAMWriteKnownsCheck+0x16c>
    7664:	80 e2       	ldi	r24, 0x20	; 32
    7666:	93 e0       	ldi	r25, 0x03	; 3
    7668:	8c 8b       	std	Y+20, r24	; 0x14
    766a:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    766c:	8c 89       	ldd	r24, Y+20	; 0x14
    766e:	9d 89       	ldd	r25, Y+21	; 0x15
    7670:	8c 01       	movw	r16, r24
    7672:	c8 01       	movw	r24, r16
    7674:	01 97       	sbiw	r24, 0x01	; 1
    7676:	f1 f7       	brne	.-4      	; 0x7674 <FRAMWriteKnownsCheck+0x158>
    7678:	8c 01       	movw	r16, r24
    767a:	0c 8b       	std	Y+20, r16	; 0x14
    767c:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    767e:	8a 89       	ldd	r24, Y+18	; 0x12
    7680:	9b 89       	ldd	r25, Y+19	; 0x13
    7682:	01 97       	sbiw	r24, 0x01	; 1
    7684:	8a 8b       	std	Y+18, r24	; 0x12
    7686:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7688:	8a 89       	ldd	r24, Y+18	; 0x12
    768a:	9b 89       	ldd	r25, Y+19	; 0x13
    768c:	00 97       	sbiw	r24, 0x00	; 0
    768e:	51 f7       	brne	.-44     	; 0x7664 <FRAMWriteKnownsCheck+0x148>
    7690:	28 c0       	rjmp	.+80     	; 0x76e2 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7692:	6e 85       	ldd	r22, Y+14	; 0x0e
    7694:	7f 85       	ldd	r23, Y+15	; 0x0f
    7696:	88 89       	ldd	r24, Y+16	; 0x10
    7698:	99 89       	ldd	r25, Y+17	; 0x11
    769a:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    769e:	dc 01       	movw	r26, r24
    76a0:	cb 01       	movw	r24, r22
    76a2:	8a 8b       	std	Y+18, r24	; 0x12
    76a4:	9b 8b       	std	Y+19, r25	; 0x13
    76a6:	8a 89       	ldd	r24, Y+18	; 0x12
    76a8:	9b 89       	ldd	r25, Y+19	; 0x13
    76aa:	8e 8b       	std	Y+22, r24	; 0x16
    76ac:	9f 8b       	std	Y+23, r25	; 0x17
    76ae:	8e 89       	ldd	r24, Y+22	; 0x16
    76b0:	9f 89       	ldd	r25, Y+23	; 0x17
    76b2:	8c 01       	movw	r16, r24
    76b4:	c8 01       	movw	r24, r16
    76b6:	01 97       	sbiw	r24, 0x01	; 1
    76b8:	f1 f7       	brne	.-4      	; 0x76b6 <FRAMWriteKnownsCheck+0x19a>
    76ba:	8c 01       	movw	r16, r24
    76bc:	0e 8b       	std	Y+22, r16	; 0x16
    76be:	1f 8b       	std	Y+23, r17	; 0x17
    76c0:	10 c0       	rjmp	.+32     	; 0x76e2 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    76c2:	6d 81       	ldd	r22, Y+5	; 0x05
    76c4:	7e 81       	ldd	r23, Y+6	; 0x06
    76c6:	8f 81       	ldd	r24, Y+7	; 0x07
    76c8:	98 85       	ldd	r25, Y+8	; 0x08
    76ca:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    76ce:	dc 01       	movw	r26, r24
    76d0:	cb 01       	movw	r24, r22
    76d2:	89 87       	std	Y+9, r24	; 0x09
    76d4:	89 85       	ldd	r24, Y+9	; 0x09
    76d6:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    76d8:	88 8d       	ldd	r24, Y+24	; 0x18
    76da:	18 2f       	mov	r17, r24
    76dc:	1a 95       	dec	r17
    76de:	f1 f7       	brne	.-4      	; 0x76dc <FRAMWriteKnownsCheck+0x1c0>
    76e0:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    76e2:	0e 94 29 16 	call	0x2c52	; 0x2c52 <calcChecksumFRAM>

	ADCPower(FALSE);
    76e6:	80 e0       	ldi	r24, 0x00	; 0
    76e8:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>

}
    76ec:	68 96       	adiw	r28, 0x18	; 24
    76ee:	cd bf       	out	0x3d, r28	; 61
    76f0:	de bf       	out	0x3e, r29	; 62
    76f2:	df 91       	pop	r29
    76f4:	cf 91       	pop	r28
    76f6:	1f 91       	pop	r17
    76f8:	0f 91       	pop	r16
    76fa:	08 95       	ret

000076fc <checkMote>:

//random function for testing stuff	
void checkMote(){
    76fc:	0f 93       	push	r16
    76fe:	1f 93       	push	r17
    7700:	cf 93       	push	r28
    7702:	df 93       	push	r29
    7704:	cd b7       	in	r28, 0x3d	; 61
    7706:	de b7       	in	r29, 0x3e	; 62
    7708:	aa 97       	sbiw	r28, 0x2a	; 42
    770a:	cd bf       	out	0x3d, r28	; 61
    770c:	de bf       	out	0x3e, r29	; 62
	
	ADCPower(TRUE);
    770e:	81 e0       	ldi	r24, 0x01	; 1
    7710:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	Ext1Power(TRUE);
    7714:	81 e0       	ldi	r24, 0x01	; 1
    7716:	0e 94 9d 34 	call	0x693a	; 0x693a <Ext1Power>
    771a:	80 e0       	ldi	r24, 0x00	; 0
    771c:	90 e0       	ldi	r25, 0x00	; 0
    771e:	a8 ec       	ldi	r26, 0xC8	; 200
    7720:	b2 e4       	ldi	r27, 0x42	; 66
    7722:	89 83       	std	Y+1, r24	; 0x01
    7724:	9a 83       	std	Y+2, r25	; 0x02
    7726:	ab 83       	std	Y+3, r26	; 0x03
    7728:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    772a:	69 81       	ldd	r22, Y+1	; 0x01
    772c:	7a 81       	ldd	r23, Y+2	; 0x02
    772e:	8b 81       	ldd	r24, Y+3	; 0x03
    7730:	9c 81       	ldd	r25, Y+4	; 0x04
    7732:	20 e0       	ldi	r18, 0x00	; 0
    7734:	30 e0       	ldi	r19, 0x00	; 0
    7736:	4a ef       	ldi	r20, 0xFA	; 250
    7738:	55 e4       	ldi	r21, 0x45	; 69
    773a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    773e:	dc 01       	movw	r26, r24
    7740:	cb 01       	movw	r24, r22
    7742:	8d 83       	std	Y+5, r24	; 0x05
    7744:	9e 83       	std	Y+6, r25	; 0x06
    7746:	af 83       	std	Y+7, r26	; 0x07
    7748:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    774a:	11 e0       	ldi	r17, 0x01	; 1
    774c:	6d 81       	ldd	r22, Y+5	; 0x05
    774e:	7e 81       	ldd	r23, Y+6	; 0x06
    7750:	8f 81       	ldd	r24, Y+7	; 0x07
    7752:	98 85       	ldd	r25, Y+8	; 0x08
    7754:	20 e0       	ldi	r18, 0x00	; 0
    7756:	30 e0       	ldi	r19, 0x00	; 0
    7758:	40 e8       	ldi	r20, 0x80	; 128
    775a:	5f e3       	ldi	r21, 0x3F	; 63
    775c:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    7760:	88 23       	and	r24, r24
    7762:	0c f0       	brlt	.+2      	; 0x7766 <checkMote+0x6a>
    7764:	10 e0       	ldi	r17, 0x00	; 0
    7766:	11 23       	and	r17, r17
    7768:	29 f0       	breq	.+10     	; 0x7774 <checkMote+0x78>
		__ticks = 1;
    776a:	81 e0       	ldi	r24, 0x01	; 1
    776c:	90 e0       	ldi	r25, 0x00	; 0
    776e:	89 87       	std	Y+9, r24	; 0x09
    7770:	9a 87       	std	Y+10, r25	; 0x0a
    7772:	46 c0       	rjmp	.+140    	; 0x7800 <checkMote+0x104>
	else if (__tmp > 65535)
    7774:	11 e0       	ldi	r17, 0x01	; 1
    7776:	6d 81       	ldd	r22, Y+5	; 0x05
    7778:	7e 81       	ldd	r23, Y+6	; 0x06
    777a:	8f 81       	ldd	r24, Y+7	; 0x07
    777c:	98 85       	ldd	r25, Y+8	; 0x08
    777e:	20 e0       	ldi	r18, 0x00	; 0
    7780:	3f ef       	ldi	r19, 0xFF	; 255
    7782:	4f e7       	ldi	r20, 0x7F	; 127
    7784:	57 e4       	ldi	r21, 0x47	; 71
    7786:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    778a:	18 16       	cp	r1, r24
    778c:	0c f0       	brlt	.+2      	; 0x7790 <checkMote+0x94>
    778e:	10 e0       	ldi	r17, 0x00	; 0
    7790:	11 23       	and	r17, r17
    7792:	61 f1       	breq	.+88     	; 0x77ec <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7794:	69 81       	ldd	r22, Y+1	; 0x01
    7796:	7a 81       	ldd	r23, Y+2	; 0x02
    7798:	8b 81       	ldd	r24, Y+3	; 0x03
    779a:	9c 81       	ldd	r25, Y+4	; 0x04
    779c:	20 e0       	ldi	r18, 0x00	; 0
    779e:	30 e0       	ldi	r19, 0x00	; 0
    77a0:	40 e2       	ldi	r20, 0x20	; 32
    77a2:	51 e4       	ldi	r21, 0x41	; 65
    77a4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    77a8:	dc 01       	movw	r26, r24
    77aa:	cb 01       	movw	r24, r22
    77ac:	bc 01       	movw	r22, r24
    77ae:	cd 01       	movw	r24, r26
    77b0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    77b4:	dc 01       	movw	r26, r24
    77b6:	cb 01       	movw	r24, r22
    77b8:	89 87       	std	Y+9, r24	; 0x09
    77ba:	9a 87       	std	Y+10, r25	; 0x0a
    77bc:	12 c0       	rjmp	.+36     	; 0x77e2 <checkMote+0xe6>
    77be:	80 e2       	ldi	r24, 0x20	; 32
    77c0:	93 e0       	ldi	r25, 0x03	; 3
    77c2:	8b 87       	std	Y+11, r24	; 0x0b
    77c4:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    77c6:	8b 85       	ldd	r24, Y+11	; 0x0b
    77c8:	9c 85       	ldd	r25, Y+12	; 0x0c
    77ca:	8c 01       	movw	r16, r24
    77cc:	c8 01       	movw	r24, r16
    77ce:	01 97       	sbiw	r24, 0x01	; 1
    77d0:	f1 f7       	brne	.-4      	; 0x77ce <checkMote+0xd2>
    77d2:	8c 01       	movw	r16, r24
    77d4:	0b 87       	std	Y+11, r16	; 0x0b
    77d6:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    77d8:	89 85       	ldd	r24, Y+9	; 0x09
    77da:	9a 85       	ldd	r25, Y+10	; 0x0a
    77dc:	01 97       	sbiw	r24, 0x01	; 1
    77de:	89 87       	std	Y+9, r24	; 0x09
    77e0:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    77e2:	89 85       	ldd	r24, Y+9	; 0x09
    77e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    77e6:	00 97       	sbiw	r24, 0x00	; 0
    77e8:	51 f7       	brne	.-44     	; 0x77be <checkMote+0xc2>
    77ea:	17 c0       	rjmp	.+46     	; 0x781a <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    77ec:	6d 81       	ldd	r22, Y+5	; 0x05
    77ee:	7e 81       	ldd	r23, Y+6	; 0x06
    77f0:	8f 81       	ldd	r24, Y+7	; 0x07
    77f2:	98 85       	ldd	r25, Y+8	; 0x08
    77f4:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    77f8:	dc 01       	movw	r26, r24
    77fa:	cb 01       	movw	r24, r22
    77fc:	89 87       	std	Y+9, r24	; 0x09
    77fe:	9a 87       	std	Y+10, r25	; 0x0a
    7800:	89 85       	ldd	r24, Y+9	; 0x09
    7802:	9a 85       	ldd	r25, Y+10	; 0x0a
    7804:	8d 87       	std	Y+13, r24	; 0x0d
    7806:	9e 87       	std	Y+14, r25	; 0x0e
    7808:	8d 85       	ldd	r24, Y+13	; 0x0d
    780a:	9e 85       	ldd	r25, Y+14	; 0x0e
    780c:	8c 01       	movw	r16, r24
    780e:	c8 01       	movw	r24, r16
    7810:	01 97       	sbiw	r24, 0x01	; 1
    7812:	f1 f7       	brne	.-4      	; 0x7810 <checkMote+0x114>
    7814:	8c 01       	movw	r16, r24
    7816:	0d 87       	std	Y+13, r16	; 0x0d
    7818:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    781a:	88 e0       	ldi	r24, 0x08	; 8
    781c:	60 e0       	ldi	r22, 0x00	; 0
    781e:	0e 94 07 33 	call	0x660e	; 0x660e <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7822:	88 e0       	ldi	r24, 0x08	; 8
    7824:	60 e0       	ldi	r22, 0x00	; 0
    7826:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
    782a:	80 e0       	ldi	r24, 0x00	; 0
    782c:	90 e4       	ldi	r25, 0x40	; 64
    782e:	ac e9       	ldi	r26, 0x9C	; 156
    7830:	b5 e4       	ldi	r27, 0x45	; 69
    7832:	8f 87       	std	Y+15, r24	; 0x0f
    7834:	98 8b       	std	Y+16, r25	; 0x10
    7836:	a9 8b       	std	Y+17, r26	; 0x11
    7838:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    783a:	6f 85       	ldd	r22, Y+15	; 0x0f
    783c:	78 89       	ldd	r23, Y+16	; 0x10
    783e:	89 89       	ldd	r24, Y+17	; 0x11
    7840:	9a 89       	ldd	r25, Y+18	; 0x12
    7842:	20 e0       	ldi	r18, 0x00	; 0
    7844:	30 e0       	ldi	r19, 0x00	; 0
    7846:	4a ef       	ldi	r20, 0xFA	; 250
    7848:	55 e4       	ldi	r21, 0x45	; 69
    784a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    784e:	dc 01       	movw	r26, r24
    7850:	cb 01       	movw	r24, r22
    7852:	8b 8b       	std	Y+19, r24	; 0x13
    7854:	9c 8b       	std	Y+20, r25	; 0x14
    7856:	ad 8b       	std	Y+21, r26	; 0x15
    7858:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    785a:	11 e0       	ldi	r17, 0x01	; 1
    785c:	6b 89       	ldd	r22, Y+19	; 0x13
    785e:	7c 89       	ldd	r23, Y+20	; 0x14
    7860:	8d 89       	ldd	r24, Y+21	; 0x15
    7862:	9e 89       	ldd	r25, Y+22	; 0x16
    7864:	20 e0       	ldi	r18, 0x00	; 0
    7866:	30 e0       	ldi	r19, 0x00	; 0
    7868:	40 e8       	ldi	r20, 0x80	; 128
    786a:	5f e3       	ldi	r21, 0x3F	; 63
    786c:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    7870:	88 23       	and	r24, r24
    7872:	0c f0       	brlt	.+2      	; 0x7876 <checkMote+0x17a>
    7874:	10 e0       	ldi	r17, 0x00	; 0
    7876:	11 23       	and	r17, r17
    7878:	29 f0       	breq	.+10     	; 0x7884 <checkMote+0x188>
		__ticks = 1;
    787a:	81 e0       	ldi	r24, 0x01	; 1
    787c:	90 e0       	ldi	r25, 0x00	; 0
    787e:	8f 8b       	std	Y+23, r24	; 0x17
    7880:	98 8f       	std	Y+24, r25	; 0x18
    7882:	46 c0       	rjmp	.+140    	; 0x7910 <checkMote+0x214>
	else if (__tmp > 65535)
    7884:	11 e0       	ldi	r17, 0x01	; 1
    7886:	6b 89       	ldd	r22, Y+19	; 0x13
    7888:	7c 89       	ldd	r23, Y+20	; 0x14
    788a:	8d 89       	ldd	r24, Y+21	; 0x15
    788c:	9e 89       	ldd	r25, Y+22	; 0x16
    788e:	20 e0       	ldi	r18, 0x00	; 0
    7890:	3f ef       	ldi	r19, 0xFF	; 255
    7892:	4f e7       	ldi	r20, 0x7F	; 127
    7894:	57 e4       	ldi	r21, 0x47	; 71
    7896:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    789a:	18 16       	cp	r1, r24
    789c:	0c f0       	brlt	.+2      	; 0x78a0 <checkMote+0x1a4>
    789e:	10 e0       	ldi	r17, 0x00	; 0
    78a0:	11 23       	and	r17, r17
    78a2:	61 f1       	breq	.+88     	; 0x78fc <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    78a4:	6f 85       	ldd	r22, Y+15	; 0x0f
    78a6:	78 89       	ldd	r23, Y+16	; 0x10
    78a8:	89 89       	ldd	r24, Y+17	; 0x11
    78aa:	9a 89       	ldd	r25, Y+18	; 0x12
    78ac:	20 e0       	ldi	r18, 0x00	; 0
    78ae:	30 e0       	ldi	r19, 0x00	; 0
    78b0:	40 e2       	ldi	r20, 0x20	; 32
    78b2:	51 e4       	ldi	r21, 0x41	; 65
    78b4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    78b8:	dc 01       	movw	r26, r24
    78ba:	cb 01       	movw	r24, r22
    78bc:	bc 01       	movw	r22, r24
    78be:	cd 01       	movw	r24, r26
    78c0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    78c4:	dc 01       	movw	r26, r24
    78c6:	cb 01       	movw	r24, r22
    78c8:	8f 8b       	std	Y+23, r24	; 0x17
    78ca:	98 8f       	std	Y+24, r25	; 0x18
    78cc:	12 c0       	rjmp	.+36     	; 0x78f2 <checkMote+0x1f6>
    78ce:	80 e2       	ldi	r24, 0x20	; 32
    78d0:	93 e0       	ldi	r25, 0x03	; 3
    78d2:	89 8f       	std	Y+25, r24	; 0x19
    78d4:	9a 8f       	std	Y+26, r25	; 0x1a
    78d6:	89 8d       	ldd	r24, Y+25	; 0x19
    78d8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    78da:	8c 01       	movw	r16, r24
    78dc:	c8 01       	movw	r24, r16
    78de:	01 97       	sbiw	r24, 0x01	; 1
    78e0:	f1 f7       	brne	.-4      	; 0x78de <checkMote+0x1e2>
    78e2:	8c 01       	movw	r16, r24
    78e4:	09 8f       	std	Y+25, r16	; 0x19
    78e6:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    78e8:	8f 89       	ldd	r24, Y+23	; 0x17
    78ea:	98 8d       	ldd	r25, Y+24	; 0x18
    78ec:	01 97       	sbiw	r24, 0x01	; 1
    78ee:	8f 8b       	std	Y+23, r24	; 0x17
    78f0:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    78f2:	8f 89       	ldd	r24, Y+23	; 0x17
    78f4:	98 8d       	ldd	r25, Y+24	; 0x18
    78f6:	00 97       	sbiw	r24, 0x00	; 0
    78f8:	51 f7       	brne	.-44     	; 0x78ce <checkMote+0x1d2>
    78fa:	17 c0       	rjmp	.+46     	; 0x792a <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    78fc:	6b 89       	ldd	r22, Y+19	; 0x13
    78fe:	7c 89       	ldd	r23, Y+20	; 0x14
    7900:	8d 89       	ldd	r24, Y+21	; 0x15
    7902:	9e 89       	ldd	r25, Y+22	; 0x16
    7904:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    7908:	dc 01       	movw	r26, r24
    790a:	cb 01       	movw	r24, r22
    790c:	8f 8b       	std	Y+23, r24	; 0x17
    790e:	98 8f       	std	Y+24, r25	; 0x18
    7910:	8f 89       	ldd	r24, Y+23	; 0x17
    7912:	98 8d       	ldd	r25, Y+24	; 0x18
    7914:	8b 8f       	std	Y+27, r24	; 0x1b
    7916:	9c 8f       	std	Y+28, r25	; 0x1c
    7918:	8b 8d       	ldd	r24, Y+27	; 0x1b
    791a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    791c:	8c 01       	movw	r16, r24
    791e:	c8 01       	movw	r24, r16
    7920:	01 97       	sbiw	r24, 0x01	; 1
    7922:	f1 f7       	brne	.-4      	; 0x7920 <checkMote+0x224>
    7924:	8c 01       	movw	r16, r24
    7926:	0b 8f       	std	Y+27, r16	; 0x1b
    7928:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    792a:	88 e0       	ldi	r24, 0x08	; 8
    792c:	60 e0       	ldi	r22, 0x00	; 0
    792e:	0e 94 36 34 	call	0x686c	; 0x686c <PortEx_OUTCLR>
    7932:	80 e0       	ldi	r24, 0x00	; 0
    7934:	90 e4       	ldi	r25, 0x40	; 64
    7936:	ac e9       	ldi	r26, 0x9C	; 156
    7938:	b5 e4       	ldi	r27, 0x45	; 69
    793a:	8d 8f       	std	Y+29, r24	; 0x1d
    793c:	9e 8f       	std	Y+30, r25	; 0x1e
    793e:	af 8f       	std	Y+31, r26	; 0x1f
    7940:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7942:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7944:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7946:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7948:	98 a1       	lds	r25, 0x48
    794a:	20 e0       	ldi	r18, 0x00	; 0
    794c:	30 e0       	ldi	r19, 0x00	; 0
    794e:	4a ef       	ldi	r20, 0xFA	; 250
    7950:	55 e4       	ldi	r21, 0x45	; 69
    7952:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    7956:	dc 01       	movw	r26, r24
    7958:	cb 01       	movw	r24, r22
    795a:	89 a3       	lds	r24, 0x59
    795c:	9a a3       	lds	r25, 0x5a
    795e:	ab a3       	lds	r26, 0x5b
    7960:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7962:	11 e0       	ldi	r17, 0x01	; 1
    7964:	69 a1       	lds	r22, 0x49
    7966:	7a a1       	lds	r23, 0x4a
    7968:	8b a1       	lds	r24, 0x4b
    796a:	9c a1       	lds	r25, 0x4c
    796c:	20 e0       	ldi	r18, 0x00	; 0
    796e:	30 e0       	ldi	r19, 0x00	; 0
    7970:	40 e8       	ldi	r20, 0x80	; 128
    7972:	5f e3       	ldi	r21, 0x3F	; 63
    7974:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    7978:	88 23       	and	r24, r24
    797a:	0c f0       	brlt	.+2      	; 0x797e <checkMote+0x282>
    797c:	10 e0       	ldi	r17, 0x00	; 0
    797e:	11 23       	and	r17, r17
    7980:	29 f0       	breq	.+10     	; 0x798c <checkMote+0x290>
		__ticks = 1;
    7982:	81 e0       	ldi	r24, 0x01	; 1
    7984:	90 e0       	ldi	r25, 0x00	; 0
    7986:	8d a3       	lds	r24, 0x5d
    7988:	9e a3       	lds	r25, 0x5e
    798a:	46 c0       	rjmp	.+140    	; 0x7a18 <checkMote+0x31c>
	else if (__tmp > 65535)
    798c:	11 e0       	ldi	r17, 0x01	; 1
    798e:	69 a1       	lds	r22, 0x49
    7990:	7a a1       	lds	r23, 0x4a
    7992:	8b a1       	lds	r24, 0x4b
    7994:	9c a1       	lds	r25, 0x4c
    7996:	20 e0       	ldi	r18, 0x00	; 0
    7998:	3f ef       	ldi	r19, 0xFF	; 255
    799a:	4f e7       	ldi	r20, 0x7F	; 127
    799c:	57 e4       	ldi	r21, 0x47	; 71
    799e:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    79a2:	18 16       	cp	r1, r24
    79a4:	0c f0       	brlt	.+2      	; 0x79a8 <checkMote+0x2ac>
    79a6:	10 e0       	ldi	r17, 0x00	; 0
    79a8:	11 23       	and	r17, r17
    79aa:	61 f1       	breq	.+88     	; 0x7a04 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    79ac:	6d 8d       	ldd	r22, Y+29	; 0x1d
    79ae:	7e 8d       	ldd	r23, Y+30	; 0x1e
    79b0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    79b2:	98 a1       	lds	r25, 0x48
    79b4:	20 e0       	ldi	r18, 0x00	; 0
    79b6:	30 e0       	ldi	r19, 0x00	; 0
    79b8:	40 e2       	ldi	r20, 0x20	; 32
    79ba:	51 e4       	ldi	r21, 0x41	; 65
    79bc:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    79c0:	dc 01       	movw	r26, r24
    79c2:	cb 01       	movw	r24, r22
    79c4:	bc 01       	movw	r22, r24
    79c6:	cd 01       	movw	r24, r26
    79c8:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    79cc:	dc 01       	movw	r26, r24
    79ce:	cb 01       	movw	r24, r22
    79d0:	8d a3       	lds	r24, 0x5d
    79d2:	9e a3       	lds	r25, 0x5e
    79d4:	12 c0       	rjmp	.+36     	; 0x79fa <checkMote+0x2fe>
    79d6:	80 e2       	ldi	r24, 0x20	; 32
    79d8:	93 e0       	ldi	r25, 0x03	; 3
    79da:	8f a3       	lds	r24, 0x5f
    79dc:	98 a7       	lds	r25, 0x78
    79de:	8f a1       	lds	r24, 0x4f
    79e0:	98 a5       	lds	r25, 0x68
    79e2:	8c 01       	movw	r16, r24
    79e4:	c8 01       	movw	r24, r16
    79e6:	01 97       	sbiw	r24, 0x01	; 1
    79e8:	f1 f7       	brne	.-4      	; 0x79e6 <checkMote+0x2ea>
    79ea:	8c 01       	movw	r16, r24
    79ec:	0f a3       	lds	r16, 0x5f
    79ee:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    79f0:	8d a1       	lds	r24, 0x4d
    79f2:	9e a1       	lds	r25, 0x4e
    79f4:	01 97       	sbiw	r24, 0x01	; 1
    79f6:	8d a3       	lds	r24, 0x5d
    79f8:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    79fa:	8d a1       	lds	r24, 0x4d
    79fc:	9e a1       	lds	r25, 0x4e
    79fe:	00 97       	sbiw	r24, 0x00	; 0
    7a00:	51 f7       	brne	.-44     	; 0x79d6 <checkMote+0x2da>
    7a02:	18 c0       	rjmp	.+48     	; 0x7a34 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7a04:	69 a1       	lds	r22, 0x49
    7a06:	7a a1       	lds	r23, 0x4a
    7a08:	8b a1       	lds	r24, 0x4b
    7a0a:	9c a1       	lds	r25, 0x4c
    7a0c:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    7a10:	dc 01       	movw	r26, r24
    7a12:	cb 01       	movw	r24, r22
    7a14:	8d a3       	lds	r24, 0x5d
    7a16:	9e a3       	lds	r25, 0x5e
    7a18:	8d a1       	lds	r24, 0x4d
    7a1a:	9e a1       	lds	r25, 0x4e
    7a1c:	89 a7       	lds	r24, 0x79
    7a1e:	9a a7       	lds	r25, 0x7a
    7a20:	89 a5       	lds	r24, 0x69
    7a22:	9a a5       	lds	r25, 0x6a
    7a24:	8c 01       	movw	r16, r24
    7a26:	c8 01       	movw	r24, r16
    7a28:	01 97       	sbiw	r24, 0x01	; 1
    7a2a:	f1 f7       	brne	.-4      	; 0x7a28 <checkMote+0x32c>
    7a2c:	8c 01       	movw	r16, r24
    7a2e:	09 a7       	lds	r16, 0x79
    7a30:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7a32:	f7 ce       	rjmp	.-530    	; 0x7822 <checkMote+0x126>
    7a34:	f6 ce       	rjmp	.-532    	; 0x7822 <checkMote+0x126>

00007a36 <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7a36:	cf 93       	push	r28
    7a38:	df 93       	push	r29
    7a3a:	cd b7       	in	r28, 0x3d	; 61
    7a3c:	de b7       	in	r29, 0x3e	; 62
    7a3e:	28 97       	sbiw	r28, 0x08	; 8
    7a40:	cd bf       	out	0x3d, r28	; 61
    7a42:	de bf       	out	0x3e, r29	; 62
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7a44:	19 82       	std	Y+1, r1	; 0x01
    7a46:	1a 82       	std	Y+2, r1	; 0x02
    7a48:	0c c0       	rjmp	.+24     	; 0x7a62 <SD_write_and_read_knowns+0x2c>
    7a4a:	29 81       	ldd	r18, Y+1	; 0x01
    7a4c:	89 81       	ldd	r24, Y+1	; 0x01
    7a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    7a50:	82 52       	subi	r24, 0x22	; 34
    7a52:	9c 4d       	sbci	r25, 0xDC	; 220
    7a54:	fc 01       	movw	r30, r24
    7a56:	20 83       	st	Z, r18
    7a58:	89 81       	ldd	r24, Y+1	; 0x01
    7a5a:	9a 81       	ldd	r25, Y+2	; 0x02
    7a5c:	01 96       	adiw	r24, 0x01	; 1
    7a5e:	89 83       	std	Y+1, r24	; 0x01
    7a60:	9a 83       	std	Y+2, r25	; 0x02
    7a62:	89 81       	ldd	r24, Y+1	; 0x01
    7a64:	9a 81       	ldd	r25, Y+2	; 0x02
    7a66:	88 31       	cpi	r24, 0x18	; 24
    7a68:	91 05       	cpc	r25, r1
    7a6a:	7c f3       	brlt	.-34     	; 0x7a4a <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7a6c:	2e ed       	ldi	r18, 0xDE	; 222
    7a6e:	33 e2       	ldi	r19, 0x23	; 35
    7a70:	64 e1       	ldi	r22, 0x14	; 20
    7a72:	70 e0       	ldi	r23, 0x00	; 0
    7a74:	80 e0       	ldi	r24, 0x00	; 0
    7a76:	90 e0       	ldi	r25, 0x00	; 0
    7a78:	a9 01       	movw	r20, r18
    7a7a:	28 e1       	ldi	r18, 0x18	; 24
    7a7c:	30 e0       	ldi	r19, 0x00	; 0
    7a7e:	0e 94 21 4e 	call	0x9c42	; 0x9c42 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7a82:	1b 82       	std	Y+3, r1	; 0x03
    7a84:	1c 82       	std	Y+4, r1	; 0x04
    7a86:	0b c0       	rjmp	.+22     	; 0x7a9e <SD_write_and_read_knowns+0x68>
    7a88:	8b 81       	ldd	r24, Y+3	; 0x03
    7a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    7a8c:	82 52       	subi	r24, 0x22	; 34
    7a8e:	9c 4d       	sbci	r25, 0xDC	; 220
    7a90:	fc 01       	movw	r30, r24
    7a92:	10 82       	st	Z, r1
    7a94:	8b 81       	ldd	r24, Y+3	; 0x03
    7a96:	9c 81       	ldd	r25, Y+4	; 0x04
    7a98:	01 96       	adiw	r24, 0x01	; 1
    7a9a:	8b 83       	std	Y+3, r24	; 0x03
    7a9c:	9c 83       	std	Y+4, r25	; 0x04
    7a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    7aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    7aa2:	88 31       	cpi	r24, 0x18	; 24
    7aa4:	91 05       	cpc	r25, r1
    7aa6:	84 f3       	brlt	.-32     	; 0x7a88 <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7aa8:	2e ed       	ldi	r18, 0xDE	; 222
    7aaa:	33 e2       	ldi	r19, 0x23	; 35
    7aac:	64 e1       	ldi	r22, 0x14	; 20
    7aae:	70 e0       	ldi	r23, 0x00	; 0
    7ab0:	80 e0       	ldi	r24, 0x00	; 0
    7ab2:	90 e0       	ldi	r25, 0x00	; 0
    7ab4:	a9 01       	movw	r20, r18
    7ab6:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7aba:	1d 82       	std	Y+5, r1	; 0x05
    7abc:	1e 82       	std	Y+6, r1	; 0x06
    7abe:	13 c0       	rjmp	.+38     	; 0x7ae6 <SD_write_and_read_knowns+0xb0>
    7ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    7ac2:	9e 81       	ldd	r25, Y+6	; 0x06
    7ac4:	24 e6       	ldi	r18, 0x64	; 100
    7ac6:	30 e0       	ldi	r19, 0x00	; 0
    7ac8:	b9 01       	movw	r22, r18
    7aca:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    7ace:	28 2f       	mov	r18, r24
    7ad0:	8d 81       	ldd	r24, Y+5	; 0x05
    7ad2:	9e 81       	ldd	r25, Y+6	; 0x06
    7ad4:	82 52       	subi	r24, 0x22	; 34
    7ad6:	9c 4d       	sbci	r25, 0xDC	; 220
    7ad8:	fc 01       	movw	r30, r24
    7ada:	20 83       	st	Z, r18
    7adc:	8d 81       	ldd	r24, Y+5	; 0x05
    7ade:	9e 81       	ldd	r25, Y+6	; 0x06
    7ae0:	01 96       	adiw	r24, 0x01	; 1
    7ae2:	8d 83       	std	Y+5, r24	; 0x05
    7ae4:	9e 83       	std	Y+6, r25	; 0x06
    7ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    7ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    7aea:	f4 e0       	ldi	r31, 0x04	; 4
    7aec:	82 3e       	cpi	r24, 0xE2	; 226
    7aee:	9f 07       	cpc	r25, r31
    7af0:	3c f3       	brlt	.-50     	; 0x7ac0 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7af2:	2e ed       	ldi	r18, 0xDE	; 222
    7af4:	33 e2       	ldi	r19, 0x23	; 35
    7af6:	60 e5       	ldi	r22, 0x50	; 80
    7af8:	70 e0       	ldi	r23, 0x00	; 0
    7afa:	80 e0       	ldi	r24, 0x00	; 0
    7afc:	90 e0       	ldi	r25, 0x00	; 0
    7afe:	a9 01       	movw	r20, r18
    7b00:	22 ee       	ldi	r18, 0xE2	; 226
    7b02:	34 e0       	ldi	r19, 0x04	; 4
    7b04:	0e 94 65 4f 	call	0x9eca	; 0x9eca <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7b08:	1f 82       	std	Y+7, r1	; 0x07
    7b0a:	18 86       	std	Y+8, r1	; 0x08
    7b0c:	0b c0       	rjmp	.+22     	; 0x7b24 <SD_write_and_read_knowns+0xee>
    7b0e:	8f 81       	ldd	r24, Y+7	; 0x07
    7b10:	98 85       	ldd	r25, Y+8	; 0x08
    7b12:	82 52       	subi	r24, 0x22	; 34
    7b14:	9c 4d       	sbci	r25, 0xDC	; 220
    7b16:	fc 01       	movw	r30, r24
    7b18:	10 82       	st	Z, r1
    7b1a:	8f 81       	ldd	r24, Y+7	; 0x07
    7b1c:	98 85       	ldd	r25, Y+8	; 0x08
    7b1e:	01 96       	adiw	r24, 0x01	; 1
    7b20:	8f 83       	std	Y+7, r24	; 0x07
    7b22:	98 87       	std	Y+8, r25	; 0x08
    7b24:	8f 81       	ldd	r24, Y+7	; 0x07
    7b26:	98 85       	ldd	r25, Y+8	; 0x08
    7b28:	f4 e0       	ldi	r31, 0x04	; 4
    7b2a:	82 3e       	cpi	r24, 0xE2	; 226
    7b2c:	9f 07       	cpc	r25, r31
    7b2e:	7c f3       	brlt	.-34     	; 0x7b0e <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7b30:	2e ed       	ldi	r18, 0xDE	; 222
    7b32:	33 e2       	ldi	r19, 0x23	; 35
    7b34:	60 e5       	ldi	r22, 0x50	; 80
    7b36:	70 e0       	ldi	r23, 0x00	; 0
    7b38:	80 e0       	ldi	r24, 0x00	; 0
    7b3a:	90 e0       	ldi	r25, 0x00	; 0
    7b3c:	a9 01       	movw	r20, r18
    7b3e:	23 e0       	ldi	r18, 0x03	; 3
    7b40:	30 e0       	ldi	r19, 0x00	; 0
    7b42:	0e 94 c3 50 	call	0xa186	; 0xa186 <SD_read_multiple_blocks>
}
    7b46:	28 96       	adiw	r28, 0x08	; 8
    7b48:	cd bf       	out	0x3d, r28	; 61
    7b4a:	de bf       	out	0x3e, r29	; 62
    7b4c:	df 91       	pop	r29
    7b4e:	cf 91       	pop	r28
    7b50:	08 95       	ret

00007b52 <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7b52:	cf 93       	push	r28
    7b54:	df 93       	push	r29
    7b56:	00 d0       	rcall	.+0      	; 0x7b58 <SD_write_and_read_knowns_FAT+0x6>
    7b58:	0f 92       	push	r0
    7b5a:	cd b7       	in	r28, 0x3d	; 61
    7b5c:	de b7       	in	r29, 0x3e	; 62
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7b5e:	19 82       	std	Y+1, r1	; 0x01
    7b60:	1a 82       	std	Y+2, r1	; 0x02
    7b62:	0c c0       	rjmp	.+24     	; 0x7b7c <SD_write_and_read_knowns_FAT+0x2a>
    7b64:	29 81       	ldd	r18, Y+1	; 0x01
    7b66:	89 81       	ldd	r24, Y+1	; 0x01
    7b68:	9a 81       	ldd	r25, Y+2	; 0x02
    7b6a:	82 52       	subi	r24, 0x22	; 34
    7b6c:	9c 4d       	sbci	r25, 0xDC	; 220
    7b6e:	fc 01       	movw	r30, r24
    7b70:	20 83       	st	Z, r18
    7b72:	89 81       	ldd	r24, Y+1	; 0x01
    7b74:	9a 81       	ldd	r25, Y+2	; 0x02
    7b76:	01 96       	adiw	r24, 0x01	; 1
    7b78:	89 83       	std	Y+1, r24	; 0x01
    7b7a:	9a 83       	std	Y+2, r25	; 0x02
    7b7c:	89 81       	ldd	r24, Y+1	; 0x01
    7b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    7b80:	88 31       	cpi	r24, 0x18	; 24
    7b82:	91 05       	cpc	r25, r1
    7b84:	7c f3       	brlt	.-34     	; 0x7b64 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    7b86:	86 e1       	ldi	r24, 0x16	; 22
    7b88:	90 e2       	ldi	r25, 0x20	; 32
    7b8a:	2e ed       	ldi	r18, 0xDE	; 222
    7b8c:	33 e2       	ldi	r19, 0x23	; 35
    7b8e:	b9 01       	movw	r22, r18
    7b90:	20 e0       	ldi	r18, 0x00	; 0
    7b92:	32 e0       	ldi	r19, 0x02	; 2
    7b94:	40 e0       	ldi	r20, 0x00	; 0
    7b96:	50 e0       	ldi	r21, 0x00	; 0
    7b98:	0e 94 16 46 	call	0x8c2c	; 0x8c2c <writeFile>
    7b9c:	80 93 a2 50 	sts	0x50A2, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7ba0:	1b 82       	std	Y+3, r1	; 0x03
    7ba2:	1c 82       	std	Y+4, r1	; 0x04
    7ba4:	0b c0       	rjmp	.+22     	; 0x7bbc <SD_write_and_read_knowns_FAT+0x6a>
    7ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    7ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    7baa:	82 52       	subi	r24, 0x22	; 34
    7bac:	9c 4d       	sbci	r25, 0xDC	; 220
    7bae:	fc 01       	movw	r30, r24
    7bb0:	10 82       	st	Z, r1
    7bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    7bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    7bb6:	01 96       	adiw	r24, 0x01	; 1
    7bb8:	8b 83       	std	Y+3, r24	; 0x03
    7bba:	9c 83       	std	Y+4, r25	; 0x04
    7bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    7bbe:	9c 81       	ldd	r25, Y+4	; 0x04
    7bc0:	88 31       	cpi	r24, 0x18	; 24
    7bc2:	91 05       	cpc	r25, r1
    7bc4:	84 f3       	brlt	.-32     	; 0x7ba6 <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    7bc6:	26 e1       	ldi	r18, 0x16	; 22
    7bc8:	30 e2       	ldi	r19, 0x20	; 32
    7bca:	80 e0       	ldi	r24, 0x00	; 0
    7bcc:	b9 01       	movw	r22, r18
    7bce:	0e 94 40 44 	call	0x8880	; 0x8880 <readFile>
    7bd2:	80 93 a2 50 	sts	0x50A2, r24
}
    7bd6:	24 96       	adiw	r28, 0x04	; 4
    7bd8:	cd bf       	out	0x3d, r28	; 61
    7bda:	de bf       	out	0x3e, r29	; 62
    7bdc:	df 91       	pop	r29
    7bde:	cf 91       	pop	r28
    7be0:	08 95       	ret

00007be2 <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    7be2:	cf 93       	push	r28
    7be4:	df 93       	push	r29
    7be6:	cd b7       	in	r28, 0x3d	; 61
    7be8:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7bea:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <chb_init>
	chb_set_short_addr(0x0002);
    7bee:	82 e0       	ldi	r24, 0x02	; 2
    7bf0:	90 e0       	ldi	r25, 0x00	; 0
    7bf2:	0e 94 c4 2b 	call	0x5788	; 0x5788 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7bf6:	00 00       	nop
    7bf8:	fe cf       	rjmp	.-4      	; 0x7bf6 <chibi_test_radio+0x14>

00007bfa <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    7bfa:	cf 93       	push	r28
    7bfc:	df 93       	push	r29
    7bfe:	0f 92       	push	r0
    7c00:	0f 92       	push	r0
    7c02:	cd b7       	in	r28, 0x3d	; 61
    7c04:	de b7       	in	r29, 0x3e	; 62
	
	SD_init();
    7c06:	0e 94 7e 4b 	call	0x96fc	; 0x96fc <SD_init>
	getBootSectorData();
    7c0a:	0e 94 91 3f 	call	0x7f22	; 0x7f22 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7c0e:	19 82       	std	Y+1, r1	; 0x01
    7c10:	1a 82       	std	Y+2, r1	; 0x02
    7c12:	13 c0       	rjmp	.+38     	; 0x7c3a <TestCard+0x40>
    7c14:	89 81       	ldd	r24, Y+1	; 0x01
    7c16:	9a 81       	ldd	r25, Y+2	; 0x02
    7c18:	29 e7       	ldi	r18, 0x79	; 121
    7c1a:	30 e0       	ldi	r19, 0x00	; 0
    7c1c:	b9 01       	movw	r22, r18
    7c1e:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    7c22:	28 2f       	mov	r18, r24
    7c24:	89 81       	ldd	r24, Y+1	; 0x01
    7c26:	9a 81       	ldd	r25, Y+2	; 0x02
    7c28:	82 52       	subi	r24, 0x22	; 34
    7c2a:	9c 4d       	sbci	r25, 0xDC	; 220
    7c2c:	fc 01       	movw	r30, r24
    7c2e:	20 83       	st	Z, r18
    7c30:	89 81       	ldd	r24, Y+1	; 0x01
    7c32:	9a 81       	ldd	r25, Y+2	; 0x02
    7c34:	01 96       	adiw	r24, 0x01	; 1
    7c36:	89 83       	std	Y+1, r24	; 0x01
    7c38:	9a 83       	std	Y+2, r25	; 0x02
    7c3a:	89 81       	ldd	r24, Y+1	; 0x01
    7c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    7c3e:	f2 e0       	ldi	r31, 0x02	; 2
    7c40:	80 30       	cpi	r24, 0x00	; 0
    7c42:	9f 07       	cpc	r25, r31
    7c44:	3c f3       	brlt	.-50     	; 0x7c14 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    7c46:	86 e1       	ldi	r24, 0x16	; 22
    7c48:	90 e2       	ldi	r25, 0x20	; 32
    7c4a:	2e ed       	ldi	r18, 0xDE	; 222
    7c4c:	33 e2       	ldi	r19, 0x23	; 35
    7c4e:	b9 01       	movw	r22, r18
    7c50:	20 e0       	ldi	r18, 0x00	; 0
    7c52:	32 e0       	ldi	r19, 0x02	; 2
    7c54:	40 e0       	ldi	r20, 0x00	; 0
    7c56:	50 e0       	ldi	r21, 0x00	; 0
    7c58:	0e 94 16 46 	call	0x8c2c	; 0x8c2c <writeFile>
	nop();
    7c5c:	00 00       	nop
}
    7c5e:	0f 90       	pop	r0
    7c60:	0f 90       	pop	r0
    7c62:	df 91       	pop	r29
    7c64:	cf 91       	pop	r28
    7c66:	08 95       	ret

00007c68 <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    7c68:	1f 92       	push	r1
    7c6a:	0f 92       	push	r0
    7c6c:	0f b6       	in	r0, 0x3f	; 63
    7c6e:	0f 92       	push	r0
    7c70:	00 90 3b 00 	lds	r0, 0x003B
    7c74:	0f 92       	push	r0
    7c76:	11 24       	eor	r1, r1
    7c78:	2f 93       	push	r18
    7c7a:	3f 93       	push	r19
    7c7c:	4f 93       	push	r20
    7c7e:	5f 93       	push	r21
    7c80:	6f 93       	push	r22
    7c82:	7f 93       	push	r23
    7c84:	8f 93       	push	r24
    7c86:	9f 93       	push	r25
    7c88:	af 93       	push	r26
    7c8a:	bf 93       	push	r27
    7c8c:	ef 93       	push	r30
    7c8e:	ff 93       	push	r31
    7c90:	cf 93       	push	r28
    7c92:	df 93       	push	r29
    7c94:	00 d0       	rcall	.+0      	; 0x7c96 <__vector_43+0x2e>
    7c96:	00 d0       	rcall	.+0      	; 0x7c98 <__vector_43+0x30>
    7c98:	cd b7       	in	r28, 0x3d	; 61
    7c9a:	de b7       	in	r29, 0x3e	; 62
	
	chb_rx_data_t* msg = NULL;
    7c9c:	1d 82       	std	Y+5, r1	; 0x05
    7c9e:	1e 82       	std	Y+6, r1	; 0x06
	switch (RadioMonitorMode) {
    7ca0:	80 91 5d 40 	lds	r24, 0x405D
    7ca4:	88 2f       	mov	r24, r24
    7ca6:	90 e0       	ldi	r25, 0x00	; 0
    7ca8:	81 30       	cpi	r24, 0x01	; 1
    7caa:	91 05       	cpc	r25, r1
    7cac:	29 f0       	breq	.+10     	; 0x7cb8 <__vector_43+0x50>
    7cae:	82 30       	cpi	r24, 0x02	; 2
    7cb0:	91 05       	cpc	r25, r1
    7cb2:	09 f4       	brne	.+2      	; 0x7cb6 <__vector_43+0x4e>
    7cb4:	74 c0       	rjmp	.+232    	; 0x7d9e <__vector_43+0x136>
    7cb6:	93 c0       	rjmp	.+294    	; 0x7dde <__vector_43+0x176>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    7cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    7cba:	9e 81       	ldd	r25, Y+6	; 0x06
    7cbc:	0e 94 81 20 	call	0x4102	; 0x4102 <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    7cc0:	8d 81       	ldd	r24, Y+5	; 0x05
    7cc2:	9e 81       	ldd	r25, Y+6	; 0x06
    7cc4:	05 96       	adiw	r24, 0x05	; 5
    7cc6:	2e e1       	ldi	r18, 0x1E	; 30
    7cc8:	30 e2       	ldi	r19, 0x20	; 32
    7cca:	b9 01       	movw	r22, r18
    7ccc:	45 e0       	ldi	r20, 0x05	; 5
    7cce:	50 e0       	ldi	r21, 0x00	; 0
    7cd0:	0e 94 82 5d 	call	0xbb04	; 0xbb04 <strncmp>
    7cd4:	00 97       	sbiw	r24, 0x00	; 0
    7cd6:	51 f4       	brne	.+20     	; 0x7cec <__vector_43+0x84>
				MotesReadyToSynch++;
    7cd8:	80 91 77 50 	lds	r24, 0x5077
    7cdc:	90 91 78 50 	lds	r25, 0x5078
    7ce0:	01 96       	adiw	r24, 0x01	; 1
    7ce2:	80 93 77 50 	sts	0x5077, r24
    7ce6:	90 93 78 50 	sts	0x5078, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7cea:	7b c0       	rjmp	.+246    	; 0x7de2 <__vector_43+0x17a>
			if(!strncmp((const char*)(msg->data),"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    7cec:	19 82       	std	Y+1, r1	; 0x01
    7cee:	1a 82       	std	Y+2, r1	; 0x02
    7cf0:	1b 82       	std	Y+3, r1	; 0x03
    7cf2:	1c 82       	std	Y+4, r1	; 0x04
    7cf4:	1a c0       	rjmp	.+52     	; 0x7d2a <__vector_43+0xc2>
    7cf6:	2d 81       	ldd	r18, Y+5	; 0x05
    7cf8:	3e 81       	ldd	r19, Y+6	; 0x06
    7cfa:	89 81       	ldd	r24, Y+1	; 0x01
    7cfc:	9a 81       	ldd	r25, Y+2	; 0x02
    7cfe:	82 0f       	add	r24, r18
    7d00:	93 1f       	adc	r25, r19
    7d02:	05 96       	adiw	r24, 0x05	; 5
    7d04:	fc 01       	movw	r30, r24
    7d06:	20 81       	ld	r18, Z
    7d08:	89 81       	ldd	r24, Y+1	; 0x01
    7d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    7d0c:	82 52       	subi	r24, 0x22	; 34
    7d0e:	9c 4d       	sbci	r25, 0xDC	; 220
    7d10:	fc 01       	movw	r30, r24
    7d12:	20 83       	st	Z, r18
    7d14:	89 81       	ldd	r24, Y+1	; 0x01
    7d16:	9a 81       	ldd	r25, Y+2	; 0x02
    7d18:	ab 81       	ldd	r26, Y+3	; 0x03
    7d1a:	bc 81       	ldd	r27, Y+4	; 0x04
    7d1c:	01 96       	adiw	r24, 0x01	; 1
    7d1e:	a1 1d       	adc	r26, r1
    7d20:	b1 1d       	adc	r27, r1
    7d22:	89 83       	std	Y+1, r24	; 0x01
    7d24:	9a 83       	std	Y+2, r25	; 0x02
    7d26:	ab 83       	std	Y+3, r26	; 0x03
    7d28:	bc 83       	std	Y+4, r27	; 0x04
    7d2a:	89 81       	ldd	r24, Y+1	; 0x01
    7d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    7d2e:	ab 81       	ldd	r26, Y+3	; 0x03
    7d30:	bc 81       	ldd	r27, Y+4	; 0x04
    7d32:	80 38       	cpi	r24, 0x80	; 128
    7d34:	91 05       	cpc	r25, r1
    7d36:	a1 05       	cpc	r26, r1
    7d38:	b1 05       	cpc	r27, r1
    7d3a:	e8 f2       	brcs	.-70     	; 0x7cf6 <__vector_43+0x8e>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    7d3c:	80 91 c9 50 	lds	r24, 0x50C9
    7d40:	90 91 ca 50 	lds	r25, 0x50CA
    7d44:	a0 91 cb 50 	lds	r26, 0x50CB
    7d48:	b0 91 cc 50 	lds	r27, 0x50CC
    7d4c:	80 58       	subi	r24, 0x80	; 128
    7d4e:	9f 4f       	sbci	r25, 0xFF	; 255
    7d50:	af 4f       	sbci	r26, 0xFF	; 255
    7d52:	bf 4f       	sbci	r27, 0xFF	; 255
    7d54:	80 93 c9 50 	sts	0x50C9, r24
    7d58:	90 93 ca 50 	sts	0x50CA, r25
    7d5c:	a0 93 cb 50 	sts	0x50CB, r26
    7d60:	b0 93 cc 50 	sts	0x50CC, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    7d64:	80 91 c9 50 	lds	r24, 0x50C9
    7d68:	90 91 ca 50 	lds	r25, 0x50CA
    7d6c:	a0 91 cb 50 	lds	r26, 0x50CB
    7d70:	b0 91 cc 50 	lds	r27, 0x50CC
    7d74:	80 58       	subi	r24, 0x80	; 128
    7d76:	9f 4f       	sbci	r25, 0xFF	; 255
    7d78:	af 4f       	sbci	r26, 0xFF	; 255
    7d7a:	bf 4f       	sbci	r27, 0xFF	; 255
    7d7c:	81 37       	cpi	r24, 0x71	; 113
    7d7e:	fc e1       	ldi	r31, 0x1C	; 28
    7d80:	9f 07       	cpc	r25, r31
    7d82:	f0 e0       	ldi	r31, 0x00	; 0
    7d84:	af 07       	cpc	r26, r31
    7d86:	f0 e0       	ldi	r31, 0x00	; 0
    7d88:	bf 07       	cpc	r27, r31
    7d8a:	58 f1       	brcs	.+86     	; 0x7de2 <__vector_43+0x17a>
    7d8c:	10 92 c9 50 	sts	0x50C9, r1
    7d90:	10 92 ca 50 	sts	0x50CA, r1
    7d94:	10 92 cb 50 	sts	0x50CB, r1
    7d98:	10 92 cc 50 	sts	0x50CC, r1
			}			
			break;
    7d9c:	22 c0       	rjmp	.+68     	; 0x7de2 <__vector_43+0x17a>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    7d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    7da0:	9e 81       	ldd	r25, Y+6	; 0x06
    7da2:	0e 94 81 20 	call	0x4102	; 0x4102 <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    7da6:	8d 81       	ldd	r24, Y+5	; 0x05
    7da8:	9e 81       	ldd	r25, Y+6	; 0x06
    7daa:	05 96       	adiw	r24, 0x05	; 5
    7dac:	24 e2       	ldi	r18, 0x24	; 36
    7dae:	30 e2       	ldi	r19, 0x20	; 32
    7db0:	b9 01       	movw	r22, r18
    7db2:	4e e0       	ldi	r20, 0x0E	; 14
    7db4:	50 e0       	ldi	r21, 0x00	; 0
    7db6:	0e 94 82 5d 	call	0xbb04	; 0xbb04 <strncmp>
    7dba:	00 97       	sbiw	r24, 0x00	; 0
    7dbc:	a1 f4       	brne	.+40     	; 0x7de6 <__vector_43+0x17e>
				RadioMonitorMode = SYNCHED;
    7dbe:	83 e0       	ldi	r24, 0x03	; 3
    7dc0:	80 93 5d 40 	sts	0x405D, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    7dc4:	80 e4       	ldi	r24, 0x40	; 64
    7dc6:	99 e0       	ldi	r25, 0x09	; 9
    7dc8:	29 e0       	ldi	r18, 0x09	; 9
    7dca:	fc 01       	movw	r30, r24
    7dcc:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    7dce:	80 e4       	ldi	r24, 0x40	; 64
    7dd0:	98 e0       	ldi	r25, 0x08	; 8
    7dd2:	21 e0       	ldi	r18, 0x01	; 1
    7dd4:	fc 01       	movw	r30, r24
    7dd6:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    7dd8:	0e 94 5f 0c 	call	0x18be	; 0x18be <ADC_Resume_Sampling>
			}
			break;
    7ddc:	04 c0       	rjmp	.+8      	; 0x7de6 <__vector_43+0x17e>
		default:
			break;
    7dde:	00 00       	nop
    7de0:	03 c0       	rjmp	.+6      	; 0x7de8 <__vector_43+0x180>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7de2:	00 00       	nop
    7de4:	01 c0       	rjmp	.+2      	; 0x7de8 <__vector_43+0x180>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    7de6:	00 00       	nop
		default:
			break;
	}
}
    7de8:	26 96       	adiw	r28, 0x06	; 6
    7dea:	cd bf       	out	0x3d, r28	; 61
    7dec:	de bf       	out	0x3e, r29	; 62
    7dee:	df 91       	pop	r29
    7df0:	cf 91       	pop	r28
    7df2:	ff 91       	pop	r31
    7df4:	ef 91       	pop	r30
    7df6:	bf 91       	pop	r27
    7df8:	af 91       	pop	r26
    7dfa:	9f 91       	pop	r25
    7dfc:	8f 91       	pop	r24
    7dfe:	7f 91       	pop	r23
    7e00:	6f 91       	pop	r22
    7e02:	5f 91       	pop	r21
    7e04:	4f 91       	pop	r20
    7e06:	3f 91       	pop	r19
    7e08:	2f 91       	pop	r18
    7e0a:	0f 90       	pop	r0
    7e0c:	00 92 3b 00 	sts	0x003B, r0
    7e10:	0f 90       	pop	r0
    7e12:	0f be       	out	0x3f, r0	; 63
    7e14:	0f 90       	pop	r0
    7e16:	1f 90       	pop	r1
    7e18:	18 95       	reti

00007e1a <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    7e1a:	cf 93       	push	r28
    7e1c:	df 93       	push	r29
    7e1e:	cd b7       	in	r28, 0x3d	; 61
    7e20:	de b7       	in	r29, 0x3e	; 62
    7e22:	a0 97       	sbiw	r28, 0x20	; 32
    7e24:	cd bf       	out	0x3d, r28	; 61
    7e26:	de bf       	out	0x3e, r29	; 62
    7e28:	89 8f       	std	Y+25, r24	; 0x19
    7e2a:	9a 8f       	std	Y+26, r25	; 0x1a
    7e2c:	4b 8f       	std	Y+27, r20	; 0x1b
    7e2e:	5c 8f       	std	Y+28, r21	; 0x1c
    7e30:	6d 8f       	std	Y+29, r22	; 0x1d
    7e32:	7e 8f       	std	Y+30, r23	; 0x1e
    7e34:	2f 8f       	std	Y+31, r18	; 0x1f
    7e36:	38 a3       	lds	r19, 0x58
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    7e38:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7e3a:	98 a1       	lds	r25, 0x48
    7e3c:	fc 01       	movw	r30, r24
    7e3e:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    7e40:	19 82       	std	Y+1, r1	; 0x01
    7e42:	1a 82       	std	Y+2, r1	; 0x02
    7e44:	1b 82       	std	Y+3, r1	; 0x03
    7e46:	1c 82       	std	Y+4, r1	; 0x04
    7e48:	58 c0       	rjmp	.+176    	; 0x7efa <DeciToString+0xe0>
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    7e4a:	89 81       	ldd	r24, Y+1	; 0x01
    7e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    7e4e:	88 0f       	add	r24, r24
    7e50:	99 1f       	adc	r25, r25
    7e52:	88 0f       	add	r24, r24
    7e54:	99 1f       	adc	r25, r25
    7e56:	29 8d       	ldd	r18, Y+25	; 0x19
    7e58:	3a 8d       	ldd	r19, Y+26	; 0x1a
    7e5a:	82 0f       	add	r24, r18
    7e5c:	93 1f       	adc	r25, r19
    7e5e:	fc 01       	movw	r30, r24
    7e60:	80 81       	ld	r24, Z
    7e62:	91 81       	ldd	r25, Z+1	; 0x01
    7e64:	a2 81       	ldd	r26, Z+2	; 0x02
    7e66:	b3 81       	ldd	r27, Z+3	; 0x03
    7e68:	2d b7       	in	r18, 0x3d	; 61
    7e6a:	3e b7       	in	r19, 0x3e	; 62
    7e6c:	28 50       	subi	r18, 0x08	; 8
    7e6e:	30 40       	sbci	r19, 0x00	; 0
    7e70:	2d bf       	out	0x3d, r18	; 61
    7e72:	3e bf       	out	0x3e, r19	; 62
    7e74:	2d b7       	in	r18, 0x3d	; 61
    7e76:	3e b7       	in	r19, 0x3e	; 62
    7e78:	2f 5f       	subi	r18, 0xFF	; 255
    7e7a:	3f 4f       	sbci	r19, 0xFF	; 255
    7e7c:	ae 01       	movw	r20, r28
    7e7e:	4b 5f       	subi	r20, 0xFB	; 251
    7e80:	5f 4f       	sbci	r21, 0xFF	; 255
    7e82:	f9 01       	movw	r30, r18
    7e84:	40 83       	st	Z, r20
    7e86:	51 83       	std	Z+1, r21	; 0x01
    7e88:	43 e3       	ldi	r20, 0x33	; 51
    7e8a:	50 e2       	ldi	r21, 0x20	; 32
    7e8c:	f9 01       	movw	r30, r18
    7e8e:	42 83       	std	Z+2, r20	; 0x02
    7e90:	53 83       	std	Z+3, r21	; 0x03
    7e92:	f9 01       	movw	r30, r18
    7e94:	84 83       	std	Z+4, r24	; 0x04
    7e96:	95 83       	std	Z+5, r25	; 0x05
    7e98:	a6 83       	std	Z+6, r26	; 0x06
    7e9a:	b7 83       	std	Z+7, r27	; 0x07
    7e9c:	0e 94 c3 5d 	call	0xbb86	; 0xbb86 <sprintf>
    7ea0:	2d b7       	in	r18, 0x3d	; 61
    7ea2:	3e b7       	in	r19, 0x3e	; 62
    7ea4:	28 5f       	subi	r18, 0xF8	; 248
    7ea6:	3f 4f       	sbci	r19, 0xFF	; 255
    7ea8:	2d bf       	out	0x3d, r18	; 61
    7eaa:	3e bf       	out	0x3e, r19	; 62
		strcat(ReturnString,b);
    7eac:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7eae:	98 a1       	lds	r25, 0x48
    7eb0:	9e 01       	movw	r18, r28
    7eb2:	2b 5f       	subi	r18, 0xFB	; 251
    7eb4:	3f 4f       	sbci	r19, 0xFF	; 255
    7eb6:	b9 01       	movw	r22, r18
    7eb8:	0e 94 77 5d 	call	0xbaee	; 0xbaee <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    7ebc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7ebe:	98 a1       	lds	r25, 0x48
    7ec0:	9c 01       	movw	r18, r24
    7ec2:	f9 01       	movw	r30, r18
    7ec4:	01 90       	ld	r0, Z+
    7ec6:	00 20       	and	r0, r0
    7ec8:	e9 f7       	brne	.-6      	; 0x7ec4 <DeciToString+0xaa>
    7eca:	cf 01       	movw	r24, r30
    7ecc:	01 97       	sbiw	r24, 0x01	; 1
    7ece:	82 1b       	sub	r24, r18
    7ed0:	93 0b       	sbc	r25, r19
    7ed2:	2f 8d       	ldd	r18, Y+31	; 0x1f
    7ed4:	38 a1       	lds	r19, 0x48
    7ed6:	82 0f       	add	r24, r18
    7ed8:	93 1f       	adc	r25, r19
    7eda:	2a e0       	ldi	r18, 0x0A	; 10
    7edc:	30 e0       	ldi	r19, 0x00	; 0
    7ede:	fc 01       	movw	r30, r24
    7ee0:	20 83       	st	Z, r18
    7ee2:	31 83       	std	Z+1, r19	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    7ee4:	89 81       	ldd	r24, Y+1	; 0x01
    7ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    7ee8:	ab 81       	ldd	r26, Y+3	; 0x03
    7eea:	bc 81       	ldd	r27, Y+4	; 0x04
    7eec:	01 96       	adiw	r24, 0x01	; 1
    7eee:	a1 1d       	adc	r26, r1
    7ef0:	b1 1d       	adc	r27, r1
    7ef2:	89 83       	std	Y+1, r24	; 0x01
    7ef4:	9a 83       	std	Y+2, r25	; 0x02
    7ef6:	ab 83       	std	Y+3, r26	; 0x03
    7ef8:	bc 83       	std	Y+4, r27	; 0x04
    7efa:	29 81       	ldd	r18, Y+1	; 0x01
    7efc:	3a 81       	ldd	r19, Y+2	; 0x02
    7efe:	4b 81       	ldd	r20, Y+3	; 0x03
    7f00:	5c 81       	ldd	r21, Y+4	; 0x04
    7f02:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7f04:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7f06:	ad 8d       	ldd	r26, Y+29	; 0x1d
    7f08:	be 8d       	ldd	r27, Y+30	; 0x1e
    7f0a:	28 17       	cp	r18, r24
    7f0c:	39 07       	cpc	r19, r25
    7f0e:	4a 07       	cpc	r20, r26
    7f10:	5b 07       	cpc	r21, r27
    7f12:	08 f4       	brcc	.+2      	; 0x7f16 <DeciToString+0xfc>
    7f14:	9a cf       	rjmp	.-204    	; 0x7e4a <DeciToString+0x30>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    7f16:	a0 96       	adiw	r28, 0x20	; 32
    7f18:	cd bf       	out	0x3d, r28	; 61
    7f1a:	de bf       	out	0x3e, r29	; 62
    7f1c:	df 91       	pop	r29
    7f1e:	cf 91       	pop	r28
    7f20:	08 95       	ret

00007f22 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    7f22:	ef 92       	push	r14
    7f24:	ff 92       	push	r15
    7f26:	0f 93       	push	r16
    7f28:	1f 93       	push	r17
    7f2a:	cf 93       	push	r28
    7f2c:	df 93       	push	r29
    7f2e:	cd b7       	in	r28, 0x3d	; 61
    7f30:	de b7       	in	r29, 0x3e	; 62
    7f32:	2a 97       	sbiw	r28, 0x0a	; 10
    7f34:	cd bf       	out	0x3d, r28	; 61
    7f36:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    7f38:	10 92 7c 50 	sts	0x507C, r1
    7f3c:	10 92 7d 50 	sts	0x507D, r1
    7f40:	10 92 7e 50 	sts	0x507E, r1
    7f44:	10 92 7f 50 	sts	0x507F, r1

SD_read_block(0,SDBuffer);
    7f48:	25 ed       	ldi	r18, 0xD5	; 213
    7f4a:	31 e2       	ldi	r19, 0x21	; 33
    7f4c:	60 e0       	ldi	r22, 0x00	; 0
    7f4e:	70 e0       	ldi	r23, 0x00	; 0
    7f50:	cb 01       	movw	r24, r22
    7f52:	a9 01       	movw	r20, r18
    7f54:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    7f58:	85 ed       	ldi	r24, 0xD5	; 213
    7f5a:	91 e2       	ldi	r25, 0x21	; 33
    7f5c:	89 83       	std	Y+1, r24	; 0x01
    7f5e:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    7f60:	89 81       	ldd	r24, Y+1	; 0x01
    7f62:	9a 81       	ldd	r25, Y+2	; 0x02
    7f64:	fc 01       	movw	r30, r24
    7f66:	80 81       	ld	r24, Z
    7f68:	89 3e       	cpi	r24, 0xE9	; 233
    7f6a:	09 f4       	brne	.+2      	; 0x7f6e <getBootSectorData+0x4c>
    7f6c:	4d c0       	rjmp	.+154    	; 0x8008 <getBootSectorData+0xe6>
    7f6e:	89 81       	ldd	r24, Y+1	; 0x01
    7f70:	9a 81       	ldd	r25, Y+2	; 0x02
    7f72:	fc 01       	movw	r30, r24
    7f74:	80 81       	ld	r24, Z
    7f76:	8b 3e       	cpi	r24, 0xEB	; 235
    7f78:	09 f4       	brne	.+2      	; 0x7f7c <getBootSectorData+0x5a>
    7f7a:	46 c0       	rjmp	.+140    	; 0x8008 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    7f7c:	85 ed       	ldi	r24, 0xD5	; 213
    7f7e:	91 e2       	ldi	r25, 0x21	; 33
    7f80:	8b 83       	std	Y+3, r24	; 0x03
    7f82:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    7f84:	8b 81       	ldd	r24, Y+3	; 0x03
    7f86:	9c 81       	ldd	r25, Y+4	; 0x04
    7f88:	82 50       	subi	r24, 0x02	; 2
    7f8a:	9e 4f       	sbci	r25, 0xFE	; 254
    7f8c:	fc 01       	movw	r30, r24
    7f8e:	80 81       	ld	r24, Z
    7f90:	91 81       	ldd	r25, Z+1	; 0x01
    7f92:	fa ea       	ldi	r31, 0xAA	; 170
    7f94:	85 35       	cpi	r24, 0x55	; 85
    7f96:	9f 07       	cpc	r25, r31
    7f98:	11 f0       	breq	.+4      	; 0x7f9e <getBootSectorData+0x7c>
    7f9a:	81 e0       	ldi	r24, 0x01	; 1
    7f9c:	01 c1       	rjmp	.+514    	; 0x81a0 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    7f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    7fa0:	9c 81       	ldd	r25, Y+4	; 0x04
    7fa2:	82 54       	subi	r24, 0x42	; 66
    7fa4:	9e 4f       	sbci	r25, 0xFE	; 254
    7fa6:	8d 83       	std	Y+5, r24	; 0x05
    7fa8:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    7faa:	8d 81       	ldd	r24, Y+5	; 0x05
    7fac:	9e 81       	ldd	r25, Y+6	; 0x06
    7fae:	fc 01       	movw	r30, r24
    7fb0:	80 85       	ldd	r24, Z+8	; 0x08
    7fb2:	91 85       	ldd	r25, Z+9	; 0x09
    7fb4:	a2 85       	ldd	r26, Z+10	; 0x0a
    7fb6:	b3 85       	ldd	r27, Z+11	; 0x0b
    7fb8:	80 93 7c 50 	sts	0x507C, r24
    7fbc:	90 93 7d 50 	sts	0x507D, r25
    7fc0:	a0 93 7e 50 	sts	0x507E, r26
    7fc4:	b0 93 7f 50 	sts	0x507F, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    7fc8:	8d 81       	ldd	r24, Y+5	; 0x05
    7fca:	9e 81       	ldd	r25, Y+6	; 0x06
    7fcc:	fc 01       	movw	r30, r24
    7fce:	80 85       	ldd	r24, Z+8	; 0x08
    7fd0:	91 85       	ldd	r25, Z+9	; 0x09
    7fd2:	a2 85       	ldd	r26, Z+10	; 0x0a
    7fd4:	b3 85       	ldd	r27, Z+11	; 0x0b
    7fd6:	25 ed       	ldi	r18, 0xD5	; 213
    7fd8:	31 e2       	ldi	r19, 0x21	; 33
    7fda:	bc 01       	movw	r22, r24
    7fdc:	cd 01       	movw	r24, r26
    7fde:	a9 01       	movw	r20, r18
    7fe0:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    7fe4:	85 ed       	ldi	r24, 0xD5	; 213
    7fe6:	91 e2       	ldi	r25, 0x21	; 33
    7fe8:	89 83       	std	Y+1, r24	; 0x01
    7fea:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    7fec:	89 81       	ldd	r24, Y+1	; 0x01
    7fee:	9a 81       	ldd	r25, Y+2	; 0x02
    7ff0:	fc 01       	movw	r30, r24
    7ff2:	80 81       	ld	r24, Z
    7ff4:	89 3e       	cpi	r24, 0xE9	; 233
    7ff6:	41 f0       	breq	.+16     	; 0x8008 <getBootSectorData+0xe6>
    7ff8:	89 81       	ldd	r24, Y+1	; 0x01
    7ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    7ffc:	fc 01       	movw	r30, r24
    7ffe:	80 81       	ld	r24, Z
    8000:	8b 3e       	cpi	r24, 0xEB	; 235
    8002:	11 f0       	breq	.+4      	; 0x8008 <getBootSectorData+0xe6>
    8004:	81 e0       	ldi	r24, 0x01	; 1
    8006:	cc c0       	rjmp	.+408    	; 0x81a0 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    8008:	89 81       	ldd	r24, Y+1	; 0x01
    800a:	9a 81       	ldd	r25, Y+2	; 0x02
    800c:	fc 01       	movw	r30, r24
    800e:	83 85       	ldd	r24, Z+11	; 0x0b
    8010:	94 85       	ldd	r25, Z+12	; 0x0c
    8012:	80 93 53 40 	sts	0x4053, r24
    8016:	90 93 54 40 	sts	0x4054, r25
sectorPerCluster = bpb->sectorPerCluster;
    801a:	89 81       	ldd	r24, Y+1	; 0x01
    801c:	9a 81       	ldd	r25, Y+2	; 0x02
    801e:	fc 01       	movw	r30, r24
    8020:	85 85       	ldd	r24, Z+13	; 0x0d
    8022:	88 2f       	mov	r24, r24
    8024:	90 e0       	ldi	r25, 0x00	; 0
    8026:	80 93 7a 50 	sts	0x507A, r24
    802a:	90 93 7b 50 	sts	0x507B, r25
reservedSectorCount = bpb->reservedSectorCount;
    802e:	89 81       	ldd	r24, Y+1	; 0x01
    8030:	9a 81       	ldd	r25, Y+2	; 0x02
    8032:	fc 01       	movw	r30, r24
    8034:	86 85       	ldd	r24, Z+14	; 0x0e
    8036:	97 85       	ldd	r25, Z+15	; 0x0f
    8038:	80 93 82 50 	sts	0x5082, r24
    803c:	90 93 83 50 	sts	0x5083, r25
rootCluster = bpb->rootCluster;
    8040:	89 81       	ldd	r24, Y+1	; 0x01
    8042:	9a 81       	ldd	r25, Y+2	; 0x02
    8044:	fc 01       	movw	r30, r24
    8046:	84 a5       	lds	r24, 0x64
    8048:	95 a5       	lds	r25, 0x65
    804a:	a6 a5       	lds	r26, 0x66
    804c:	b7 a5       	lds	r27, 0x67
    804e:	80 93 5e 40 	sts	0x405E, r24
    8052:	90 93 5f 40 	sts	0x405F, r25
    8056:	a0 93 60 40 	sts	0x4060, r26
    805a:	b0 93 61 40 	sts	0x4061, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    805e:	89 81       	ldd	r24, Y+1	; 0x01
    8060:	9a 81       	ldd	r25, Y+2	; 0x02
    8062:	fc 01       	movw	r30, r24
    8064:	24 8d       	ldd	r18, Z+28	; 0x1c
    8066:	35 8d       	ldd	r19, Z+29	; 0x1d
    8068:	46 8d       	ldd	r20, Z+30	; 0x1e
    806a:	57 8d       	ldd	r21, Z+31	; 0x1f
    806c:	80 91 82 50 	lds	r24, 0x5082
    8070:	90 91 83 50 	lds	r25, 0x5083
    8074:	cc 01       	movw	r24, r24
    8076:	a0 e0       	ldi	r26, 0x00	; 0
    8078:	b0 e0       	ldi	r27, 0x00	; 0
    807a:	79 01       	movw	r14, r18
    807c:	8a 01       	movw	r16, r20
    807e:	e8 0e       	add	r14, r24
    8080:	f9 1e       	adc	r15, r25
    8082:	0a 1f       	adc	r16, r26
    8084:	1b 1f       	adc	r17, r27
    8086:	89 81       	ldd	r24, Y+1	; 0x01
    8088:	9a 81       	ldd	r25, Y+2	; 0x02
    808a:	fc 01       	movw	r30, r24
    808c:	80 89       	ldd	r24, Z+16	; 0x10
    808e:	88 2f       	mov	r24, r24
    8090:	90 e0       	ldi	r25, 0x00	; 0
    8092:	a0 e0       	ldi	r26, 0x00	; 0
    8094:	b0 e0       	ldi	r27, 0x00	; 0
    8096:	29 81       	ldd	r18, Y+1	; 0x01
    8098:	3a 81       	ldd	r19, Y+2	; 0x02
    809a:	f9 01       	movw	r30, r18
    809c:	24 a1       	lds	r18, 0x44
    809e:	35 a1       	lds	r19, 0x45
    80a0:	46 a1       	lds	r20, 0x46
    80a2:	57 a1       	lds	r21, 0x47
    80a4:	bc 01       	movw	r22, r24
    80a6:	cd 01       	movw	r24, r26
    80a8:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    80ac:	dc 01       	movw	r26, r24
    80ae:	cb 01       	movw	r24, r22
    80b0:	8e 0d       	add	r24, r14
    80b2:	9f 1d       	adc	r25, r15
    80b4:	a0 1f       	adc	r26, r16
    80b6:	b1 1f       	adc	r27, r17
    80b8:	80 93 da 23 	sts	0x23DA, r24
    80bc:	90 93 db 23 	sts	0x23DB, r25
    80c0:	a0 93 dc 23 	sts	0x23DC, r26
    80c4:	b0 93 dd 23 	sts	0x23DD, r27

dataSectors = bpb->totalSectors_F32
    80c8:	89 81       	ldd	r24, Y+1	; 0x01
    80ca:	9a 81       	ldd	r25, Y+2	; 0x02
    80cc:	fc 01       	movw	r30, r24
    80ce:	20 a1       	lds	r18, 0x40
    80d0:	31 a1       	lds	r19, 0x41
    80d2:	42 a1       	lds	r20, 0x42
    80d4:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    80d6:	89 81       	ldd	r24, Y+1	; 0x01
    80d8:	9a 81       	ldd	r25, Y+2	; 0x02
    80da:	fc 01       	movw	r30, r24
    80dc:	86 85       	ldd	r24, Z+14	; 0x0e
    80de:	97 85       	ldd	r25, Z+15	; 0x0f
    80e0:	cc 01       	movw	r24, r24
    80e2:	a0 e0       	ldi	r26, 0x00	; 0
    80e4:	b0 e0       	ldi	r27, 0x00	; 0
    80e6:	79 01       	movw	r14, r18
    80e8:	8a 01       	movw	r16, r20
    80ea:	e8 1a       	sub	r14, r24
    80ec:	f9 0a       	sbc	r15, r25
    80ee:	0a 0b       	sbc	r16, r26
    80f0:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    80f2:	89 81       	ldd	r24, Y+1	; 0x01
    80f4:	9a 81       	ldd	r25, Y+2	; 0x02
    80f6:	fc 01       	movw	r30, r24
    80f8:	80 89       	ldd	r24, Z+16	; 0x10
    80fa:	88 2f       	mov	r24, r24
    80fc:	90 e0       	ldi	r25, 0x00	; 0
    80fe:	a0 e0       	ldi	r26, 0x00	; 0
    8100:	b0 e0       	ldi	r27, 0x00	; 0
    8102:	29 81       	ldd	r18, Y+1	; 0x01
    8104:	3a 81       	ldd	r19, Y+2	; 0x02
    8106:	f9 01       	movw	r30, r18
    8108:	24 a1       	lds	r18, 0x44
    810a:	35 a1       	lds	r19, 0x45
    810c:	46 a1       	lds	r20, 0x46
    810e:	57 a1       	lds	r21, 0x47
    8110:	bc 01       	movw	r22, r24
    8112:	cd 01       	movw	r24, r26
    8114:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    8118:	dc 01       	movw	r26, r24
    811a:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    811c:	a8 01       	movw	r20, r16
    811e:	97 01       	movw	r18, r14
    8120:	28 1b       	sub	r18, r24
    8122:	39 0b       	sbc	r19, r25
    8124:	4a 0b       	sbc	r20, r26
    8126:	5b 0b       	sbc	r21, r27
    8128:	da 01       	movw	r26, r20
    812a:	c9 01       	movw	r24, r18
    812c:	8f 83       	std	Y+7, r24	; 0x07
    812e:	98 87       	std	Y+8, r25	; 0x08
    8130:	a9 87       	std	Y+9, r26	; 0x09
    8132:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    8134:	80 91 7a 50 	lds	r24, 0x507A
    8138:	90 91 7b 50 	lds	r25, 0x507B
    813c:	9c 01       	movw	r18, r24
    813e:	40 e0       	ldi	r20, 0x00	; 0
    8140:	50 e0       	ldi	r21, 0x00	; 0
    8142:	8f 81       	ldd	r24, Y+7	; 0x07
    8144:	98 85       	ldd	r25, Y+8	; 0x08
    8146:	a9 85       	ldd	r26, Y+9	; 0x09
    8148:	ba 85       	ldd	r27, Y+10	; 0x0a
    814a:	bc 01       	movw	r22, r24
    814c:	cd 01       	movw	r24, r26
    814e:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    8152:	da 01       	movw	r26, r20
    8154:	c9 01       	movw	r24, r18
    8156:	80 93 58 40 	sts	0x4058, r24
    815a:	90 93 59 40 	sts	0x4059, r25
    815e:	a0 93 5a 40 	sts	0x405A, r26
    8162:	b0 93 5b 40 	sts	0x405B, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    8166:	81 e0       	ldi	r24, 0x01	; 1
    8168:	60 e0       	ldi	r22, 0x00	; 0
    816a:	20 e0       	ldi	r18, 0x00	; 0
    816c:	30 e0       	ldi	r19, 0x00	; 0
    816e:	a9 01       	movw	r20, r18
    8170:	0e 94 b5 41 	call	0x836a	; 0x836a <getSetFreeCluster>
    8174:	9b 01       	movw	r18, r22
    8176:	ac 01       	movw	r20, r24
    8178:	80 91 58 40 	lds	r24, 0x4058
    817c:	90 91 59 40 	lds	r25, 0x4059
    8180:	a0 91 5a 40 	lds	r26, 0x405A
    8184:	b0 91 5b 40 	lds	r27, 0x405B
    8188:	82 17       	cp	r24, r18
    818a:	93 07       	cpc	r25, r19
    818c:	a4 07       	cpc	r26, r20
    818e:	b5 07       	cpc	r27, r21
    8190:	18 f4       	brcc	.+6      	; 0x8198 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    8192:	10 92 ce 50 	sts	0x50CE, r1
    8196:	03 c0       	rjmp	.+6      	; 0x819e <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    8198:	81 e0       	ldi	r24, 0x01	; 1
    819a:	80 93 ce 50 	sts	0x50CE, r24
return 0;
    819e:	80 e0       	ldi	r24, 0x00	; 0
}
    81a0:	2a 96       	adiw	r28, 0x0a	; 10
    81a2:	cd bf       	out	0x3d, r28	; 61
    81a4:	de bf       	out	0x3e, r29	; 62
    81a6:	df 91       	pop	r29
    81a8:	cf 91       	pop	r28
    81aa:	1f 91       	pop	r17
    81ac:	0f 91       	pop	r16
    81ae:	ff 90       	pop	r15
    81b0:	ef 90       	pop	r14
    81b2:	08 95       	ret

000081b4 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    81b4:	cf 93       	push	r28
    81b6:	df 93       	push	r29
    81b8:	00 d0       	rcall	.+0      	; 0x81ba <getFirstSector+0x6>
    81ba:	0f 92       	push	r0
    81bc:	cd b7       	in	r28, 0x3d	; 61
    81be:	de b7       	in	r29, 0x3e	; 62
    81c0:	69 83       	std	Y+1, r22	; 0x01
    81c2:	7a 83       	std	Y+2, r23	; 0x02
    81c4:	8b 83       	std	Y+3, r24	; 0x03
    81c6:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    81c8:	89 81       	ldd	r24, Y+1	; 0x01
    81ca:	9a 81       	ldd	r25, Y+2	; 0x02
    81cc:	ab 81       	ldd	r26, Y+3	; 0x03
    81ce:	bc 81       	ldd	r27, Y+4	; 0x04
    81d0:	02 97       	sbiw	r24, 0x02	; 2
    81d2:	a1 09       	sbc	r26, r1
    81d4:	b1 09       	sbc	r27, r1
    81d6:	20 91 7a 50 	lds	r18, 0x507A
    81da:	30 91 7b 50 	lds	r19, 0x507B
    81de:	99 01       	movw	r18, r18
    81e0:	40 e0       	ldi	r20, 0x00	; 0
    81e2:	50 e0       	ldi	r21, 0x00	; 0
    81e4:	bc 01       	movw	r22, r24
    81e6:	cd 01       	movw	r24, r26
    81e8:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    81ec:	9b 01       	movw	r18, r22
    81ee:	ac 01       	movw	r20, r24
    81f0:	80 91 da 23 	lds	r24, 0x23DA
    81f4:	90 91 db 23 	lds	r25, 0x23DB
    81f8:	a0 91 dc 23 	lds	r26, 0x23DC
    81fc:	b0 91 dd 23 	lds	r27, 0x23DD
    8200:	82 0f       	add	r24, r18
    8202:	93 1f       	adc	r25, r19
    8204:	a4 1f       	adc	r26, r20
    8206:	b5 1f       	adc	r27, r21
}
    8208:	bc 01       	movw	r22, r24
    820a:	cd 01       	movw	r24, r26
    820c:	24 96       	adiw	r28, 0x04	; 4
    820e:	cd bf       	out	0x3d, r28	; 61
    8210:	de bf       	out	0x3e, r29	; 62
    8212:	df 91       	pop	r29
    8214:	cf 91       	pop	r28
    8216:	08 95       	ret

00008218 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    8218:	ef 92       	push	r14
    821a:	ff 92       	push	r15
    821c:	0f 93       	push	r16
    821e:	1f 93       	push	r17
    8220:	cf 93       	push	r28
    8222:	df 93       	push	r29
    8224:	cd b7       	in	r28, 0x3d	; 61
    8226:	de b7       	in	r29, 0x3e	; 62
    8228:	61 97       	sbiw	r28, 0x11	; 17
    822a:	cd bf       	out	0x3d, r28	; 61
    822c:	de bf       	out	0x3e, r29	; 62
    822e:	69 87       	std	Y+9, r22	; 0x09
    8230:	7a 87       	std	Y+10, r23	; 0x0a
    8232:	8b 87       	std	Y+11, r24	; 0x0b
    8234:	9c 87       	std	Y+12, r25	; 0x0c
    8236:	4d 87       	std	Y+13, r20	; 0x0d
    8238:	0e 87       	std	Y+14, r16	; 0x0e
    823a:	1f 87       	std	Y+15, r17	; 0x0f
    823c:	28 8b       	std	Y+16, r18	; 0x10
    823e:	39 8b       	std	Y+17, r19	; 0x11
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    8240:	80 91 82 50 	lds	r24, 0x5082
    8244:	90 91 83 50 	lds	r25, 0x5083
    8248:	9c 01       	movw	r18, r24
    824a:	40 e0       	ldi	r20, 0x00	; 0
    824c:	50 e0       	ldi	r21, 0x00	; 0
    824e:	80 91 7c 50 	lds	r24, 0x507C
    8252:	90 91 7d 50 	lds	r25, 0x507D
    8256:	a0 91 7e 50 	lds	r26, 0x507E
    825a:	b0 91 7f 50 	lds	r27, 0x507F
    825e:	79 01       	movw	r14, r18
    8260:	8a 01       	movw	r16, r20
    8262:	e8 0e       	add	r14, r24
    8264:	f9 1e       	adc	r15, r25
    8266:	0a 1f       	adc	r16, r26
    8268:	1b 1f       	adc	r17, r27
    826a:	89 85       	ldd	r24, Y+9	; 0x09
    826c:	9a 85       	ldd	r25, Y+10	; 0x0a
    826e:	ab 85       	ldd	r26, Y+11	; 0x0b
    8270:	bc 85       	ldd	r27, Y+12	; 0x0c
    8272:	88 0f       	add	r24, r24
    8274:	99 1f       	adc	r25, r25
    8276:	aa 1f       	adc	r26, r26
    8278:	bb 1f       	adc	r27, r27
    827a:	88 0f       	add	r24, r24
    827c:	99 1f       	adc	r25, r25
    827e:	aa 1f       	adc	r26, r26
    8280:	bb 1f       	adc	r27, r27
    8282:	20 91 53 40 	lds	r18, 0x4053
    8286:	30 91 54 40 	lds	r19, 0x4054
    828a:	99 01       	movw	r18, r18
    828c:	40 e0       	ldi	r20, 0x00	; 0
    828e:	50 e0       	ldi	r21, 0x00	; 0
    8290:	bc 01       	movw	r22, r24
    8292:	cd 01       	movw	r24, r26
    8294:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    8298:	da 01       	movw	r26, r20
    829a:	c9 01       	movw	r24, r18
    829c:	8e 0d       	add	r24, r14
    829e:	9f 1d       	adc	r25, r15
    82a0:	a0 1f       	adc	r26, r16
    82a2:	b1 1f       	adc	r27, r17
    82a4:	89 83       	std	Y+1, r24	; 0x01
    82a6:	9a 83       	std	Y+2, r25	; 0x02
    82a8:	ab 83       	std	Y+3, r26	; 0x03
    82aa:	bc 83       	std	Y+4, r27	; 0x04

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    82ac:	89 85       	ldd	r24, Y+9	; 0x09
    82ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    82b0:	ab 85       	ldd	r26, Y+11	; 0x0b
    82b2:	bc 85       	ldd	r27, Y+12	; 0x0c
    82b4:	88 0f       	add	r24, r24
    82b6:	99 1f       	adc	r25, r25
    82b8:	aa 1f       	adc	r26, r26
    82ba:	bb 1f       	adc	r27, r27
    82bc:	88 0f       	add	r24, r24
    82be:	99 1f       	adc	r25, r25
    82c0:	aa 1f       	adc	r26, r26
    82c2:	bb 1f       	adc	r27, r27
    82c4:	20 91 53 40 	lds	r18, 0x4053
    82c8:	30 91 54 40 	lds	r19, 0x4054
    82cc:	99 01       	movw	r18, r18
    82ce:	40 e0       	ldi	r20, 0x00	; 0
    82d0:	50 e0       	ldi	r21, 0x00	; 0
    82d2:	bc 01       	movw	r22, r24
    82d4:	cd 01       	movw	r24, r26
    82d6:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    82da:	dc 01       	movw	r26, r24
    82dc:	cb 01       	movw	r24, r22
    82de:	8d 83       	std	Y+5, r24	; 0x05
    82e0:	9e 83       	std	Y+6, r25	; 0x06

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    82e2:	89 81       	ldd	r24, Y+1	; 0x01
    82e4:	9a 81       	ldd	r25, Y+2	; 0x02
    82e6:	ab 81       	ldd	r26, Y+3	; 0x03
    82e8:	bc 81       	ldd	r27, Y+4	; 0x04
    82ea:	25 ed       	ldi	r18, 0xD5	; 213
    82ec:	31 e2       	ldi	r19, 0x21	; 33
    82ee:	bc 01       	movw	r22, r24
    82f0:	cd 01       	movw	r24, r26
    82f2:	a9 01       	movw	r20, r18
    82f4:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    82f8:	8d 81       	ldd	r24, Y+5	; 0x05
    82fa:	9e 81       	ldd	r25, Y+6	; 0x06
    82fc:	8b 52       	subi	r24, 0x2B	; 43
    82fe:	9e 4d       	sbci	r25, 0xDE	; 222
    8300:	8f 83       	std	Y+7, r24	; 0x07
    8302:	98 87       	std	Y+8, r25	; 0x08

if(get_set == GET)
    8304:	8d 85       	ldd	r24, Y+13	; 0x0d
    8306:	88 23       	and	r24, r24
    8308:	49 f4       	brne	.+18     	; 0x831c <getSetNextCluster+0x104>
  return ((*FATEntryValue) & 0x0fffffff);
    830a:	8f 81       	ldd	r24, Y+7	; 0x07
    830c:	98 85       	ldd	r25, Y+8	; 0x08
    830e:	fc 01       	movw	r30, r24
    8310:	80 81       	ld	r24, Z
    8312:	91 81       	ldd	r25, Z+1	; 0x01
    8314:	a2 81       	ldd	r26, Z+2	; 0x02
    8316:	b3 81       	ldd	r27, Z+3	; 0x03
    8318:	bf 70       	andi	r27, 0x0F	; 15
    831a:	1b c0       	rjmp	.+54     	; 0x8352 <getSetNextCluster+0x13a>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    831c:	2f 81       	ldd	r18, Y+7	; 0x07
    831e:	38 85       	ldd	r19, Y+8	; 0x08
    8320:	8e 85       	ldd	r24, Y+14	; 0x0e
    8322:	9f 85       	ldd	r25, Y+15	; 0x0f
    8324:	a8 89       	ldd	r26, Y+16	; 0x10
    8326:	b9 89       	ldd	r27, Y+17	; 0x11
    8328:	f9 01       	movw	r30, r18
    832a:	80 83       	st	Z, r24
    832c:	91 83       	std	Z+1, r25	; 0x01
    832e:	a2 83       	std	Z+2, r26	; 0x02
    8330:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    8332:	89 81       	ldd	r24, Y+1	; 0x01
    8334:	9a 81       	ldd	r25, Y+2	; 0x02
    8336:	ab 81       	ldd	r26, Y+3	; 0x03
    8338:	bc 81       	ldd	r27, Y+4	; 0x04
    833a:	25 ed       	ldi	r18, 0xD5	; 213
    833c:	31 e2       	ldi	r19, 0x21	; 33
    833e:	bc 01       	movw	r22, r24
    8340:	cd 01       	movw	r24, r26
    8342:	a9 01       	movw	r20, r18
    8344:	20 e0       	ldi	r18, 0x00	; 0
    8346:	32 e0       	ldi	r19, 0x02	; 2
    8348:	0e 94 21 4e 	call	0x9c42	; 0x9c42 <SD_write_block>

return (0);
    834c:	80 e0       	ldi	r24, 0x00	; 0
    834e:	90 e0       	ldi	r25, 0x00	; 0
    8350:	dc 01       	movw	r26, r24
}
    8352:	bc 01       	movw	r22, r24
    8354:	cd 01       	movw	r24, r26
    8356:	61 96       	adiw	r28, 0x11	; 17
    8358:	cd bf       	out	0x3d, r28	; 61
    835a:	de bf       	out	0x3e, r29	; 62
    835c:	df 91       	pop	r29
    835e:	cf 91       	pop	r28
    8360:	1f 91       	pop	r17
    8362:	0f 91       	pop	r16
    8364:	ff 90       	pop	r15
    8366:	ef 90       	pop	r14
    8368:	08 95       	ret

0000836a <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    836a:	cf 93       	push	r28
    836c:	df 93       	push	r29
    836e:	cd b7       	in	r28, 0x3d	; 61
    8370:	de b7       	in	r29, 0x3e	; 62
    8372:	28 97       	sbiw	r28, 0x08	; 8
    8374:	cd bf       	out	0x3d, r28	; 61
    8376:	de bf       	out	0x3e, r29	; 62
    8378:	8b 83       	std	Y+3, r24	; 0x03
    837a:	6c 83       	std	Y+4, r22	; 0x04
    837c:	2d 83       	std	Y+5, r18	; 0x05
    837e:	3e 83       	std	Y+6, r19	; 0x06
    8380:	4f 83       	std	Y+7, r20	; 0x07
    8382:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    8384:	85 ed       	ldi	r24, 0xD5	; 213
    8386:	91 e2       	ldi	r25, 0x21	; 33
    8388:	89 83       	std	Y+1, r24	; 0x01
    838a:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    838c:	80 91 7c 50 	lds	r24, 0x507C
    8390:	90 91 7d 50 	lds	r25, 0x507D
    8394:	a0 91 7e 50 	lds	r26, 0x507E
    8398:	b0 91 7f 50 	lds	r27, 0x507F
    839c:	01 96       	adiw	r24, 0x01	; 1
    839e:	a1 1d       	adc	r26, r1
    83a0:	b1 1d       	adc	r27, r1
    83a2:	25 ed       	ldi	r18, 0xD5	; 213
    83a4:	31 e2       	ldi	r19, 0x21	; 33
    83a6:	bc 01       	movw	r22, r24
    83a8:	cd 01       	movw	r24, r26
    83aa:	a9 01       	movw	r20, r18
    83ac:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    83b0:	89 81       	ldd	r24, Y+1	; 0x01
    83b2:	9a 81       	ldd	r25, Y+2	; 0x02
    83b4:	fc 01       	movw	r30, r24
    83b6:	80 81       	ld	r24, Z
    83b8:	91 81       	ldd	r25, Z+1	; 0x01
    83ba:	a2 81       	ldd	r26, Z+2	; 0x02
    83bc:	b3 81       	ldd	r27, Z+3	; 0x03
    83be:	82 35       	cpi	r24, 0x52	; 82
    83c0:	f2 e5       	ldi	r31, 0x52	; 82
    83c2:	9f 07       	cpc	r25, r31
    83c4:	f1 e6       	ldi	r31, 0x61	; 97
    83c6:	af 07       	cpc	r26, r31
    83c8:	f1 e4       	ldi	r31, 0x41	; 65
    83ca:	bf 07       	cpc	r27, r31
    83cc:	11 f5       	brne	.+68     	; 0x8412 <getSetFreeCluster+0xa8>
    83ce:	89 81       	ldd	r24, Y+1	; 0x01
    83d0:	9a 81       	ldd	r25, Y+2	; 0x02
    83d2:	8c 51       	subi	r24, 0x1C	; 28
    83d4:	9e 4f       	sbci	r25, 0xFE	; 254
    83d6:	fc 01       	movw	r30, r24
    83d8:	80 81       	ld	r24, Z
    83da:	91 81       	ldd	r25, Z+1	; 0x01
    83dc:	a2 81       	ldd	r26, Z+2	; 0x02
    83de:	b3 81       	ldd	r27, Z+3	; 0x03
    83e0:	82 37       	cpi	r24, 0x72	; 114
    83e2:	f2 e7       	ldi	r31, 0x72	; 114
    83e4:	9f 07       	cpc	r25, r31
    83e6:	f1 e4       	ldi	r31, 0x41	; 65
    83e8:	af 07       	cpc	r26, r31
    83ea:	f1 e6       	ldi	r31, 0x61	; 97
    83ec:	bf 07       	cpc	r27, r31
    83ee:	89 f4       	brne	.+34     	; 0x8412 <getSetFreeCluster+0xa8>
    83f0:	89 81       	ldd	r24, Y+1	; 0x01
    83f2:	9a 81       	ldd	r25, Y+2	; 0x02
    83f4:	84 50       	subi	r24, 0x04	; 4
    83f6:	9e 4f       	sbci	r25, 0xFE	; 254
    83f8:	fc 01       	movw	r30, r24
    83fa:	80 81       	ld	r24, Z
    83fc:	91 81       	ldd	r25, Z+1	; 0x01
    83fe:	a2 81       	ldd	r26, Z+2	; 0x02
    8400:	b3 81       	ldd	r27, Z+3	; 0x03
    8402:	80 30       	cpi	r24, 0x00	; 0
    8404:	f0 e0       	ldi	r31, 0x00	; 0
    8406:	9f 07       	cpc	r25, r31
    8408:	f5 e5       	ldi	r31, 0x55	; 85
    840a:	af 07       	cpc	r26, r31
    840c:	fa ea       	ldi	r31, 0xAA	; 170
    840e:	bf 07       	cpc	r27, r31
    8410:	21 f0       	breq	.+8      	; 0x841a <getSetFreeCluster+0xb0>
  return 0xffffffff;
    8412:	8f ef       	ldi	r24, 0xFF	; 255
    8414:	9f ef       	ldi	r25, 0xFF	; 255
    8416:	dc 01       	movw	r26, r24
    8418:	51 c0       	rjmp	.+162    	; 0x84bc <getSetFreeCluster+0x152>

 if(get_set == GET)
    841a:	8c 81       	ldd	r24, Y+4	; 0x04
    841c:	88 23       	and	r24, r24
    841e:	b9 f4       	brne	.+46     	; 0x844e <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    8420:	8b 81       	ldd	r24, Y+3	; 0x03
    8422:	81 30       	cpi	r24, 0x01	; 1
    8424:	51 f4       	brne	.+20     	; 0x843a <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    8426:	89 81       	ldd	r24, Y+1	; 0x01
    8428:	9a 81       	ldd	r25, Y+2	; 0x02
    842a:	88 51       	subi	r24, 0x18	; 24
    842c:	9e 4f       	sbci	r25, 0xFE	; 254
    842e:	fc 01       	movw	r30, r24
    8430:	80 81       	ld	r24, Z
    8432:	91 81       	ldd	r25, Z+1	; 0x01
    8434:	a2 81       	ldd	r26, Z+2	; 0x02
    8436:	b3 81       	ldd	r27, Z+3	; 0x03
    8438:	41 c0       	rjmp	.+130    	; 0x84bc <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    843a:	89 81       	ldd	r24, Y+1	; 0x01
    843c:	9a 81       	ldd	r25, Y+2	; 0x02
    843e:	84 51       	subi	r24, 0x14	; 20
    8440:	9e 4f       	sbci	r25, 0xFE	; 254
    8442:	fc 01       	movw	r30, r24
    8444:	80 81       	ld	r24, Z
    8446:	91 81       	ldd	r25, Z+1	; 0x01
    8448:	a2 81       	ldd	r26, Z+2	; 0x02
    844a:	b3 81       	ldd	r27, Z+3	; 0x03
    844c:	37 c0       	rjmp	.+110    	; 0x84bc <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    844e:	8b 81       	ldd	r24, Y+3	; 0x03
    8450:	81 30       	cpi	r24, 0x01	; 1
    8452:	79 f4       	brne	.+30     	; 0x8472 <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    8454:	89 81       	ldd	r24, Y+1	; 0x01
    8456:	9a 81       	ldd	r25, Y+2	; 0x02
    8458:	9c 01       	movw	r18, r24
    845a:	28 51       	subi	r18, 0x18	; 24
    845c:	3e 4f       	sbci	r19, 0xFE	; 254
    845e:	8d 81       	ldd	r24, Y+5	; 0x05
    8460:	9e 81       	ldd	r25, Y+6	; 0x06
    8462:	af 81       	ldd	r26, Y+7	; 0x07
    8464:	b8 85       	ldd	r27, Y+8	; 0x08
    8466:	f9 01       	movw	r30, r18
    8468:	80 83       	st	Z, r24
    846a:	91 83       	std	Z+1, r25	; 0x01
    846c:	a2 83       	std	Z+2, r26	; 0x02
    846e:	b3 83       	std	Z+3, r27	; 0x03
    8470:	0e c0       	rjmp	.+28     	; 0x848e <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    8472:	89 81       	ldd	r24, Y+1	; 0x01
    8474:	9a 81       	ldd	r25, Y+2	; 0x02
    8476:	9c 01       	movw	r18, r24
    8478:	24 51       	subi	r18, 0x14	; 20
    847a:	3e 4f       	sbci	r19, 0xFE	; 254
    847c:	8d 81       	ldd	r24, Y+5	; 0x05
    847e:	9e 81       	ldd	r25, Y+6	; 0x06
    8480:	af 81       	ldd	r26, Y+7	; 0x07
    8482:	b8 85       	ldd	r27, Y+8	; 0x08
    8484:	f9 01       	movw	r30, r18
    8486:	80 83       	st	Z, r24
    8488:	91 83       	std	Z+1, r25	; 0x01
    848a:	a2 83       	std	Z+2, r26	; 0x02
    848c:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    848e:	80 91 7c 50 	lds	r24, 0x507C
    8492:	90 91 7d 50 	lds	r25, 0x507D
    8496:	a0 91 7e 50 	lds	r26, 0x507E
    849a:	b0 91 7f 50 	lds	r27, 0x507F
    849e:	01 96       	adiw	r24, 0x01	; 1
    84a0:	a1 1d       	adc	r26, r1
    84a2:	b1 1d       	adc	r27, r1
    84a4:	25 ed       	ldi	r18, 0xD5	; 213
    84a6:	31 e2       	ldi	r19, 0x21	; 33
    84a8:	bc 01       	movw	r22, r24
    84aa:	cd 01       	movw	r24, r26
    84ac:	a9 01       	movw	r20, r18
    84ae:	20 e0       	ldi	r18, 0x00	; 0
    84b0:	32 e0       	ldi	r19, 0x02	; 2
    84b2:	0e 94 21 4e 	call	0x9c42	; 0x9c42 <SD_write_block>
 }
 return 0xffffffff;
    84b6:	8f ef       	ldi	r24, 0xFF	; 255
    84b8:	9f ef       	ldi	r25, 0xFF	; 255
    84ba:	dc 01       	movw	r26, r24
}
    84bc:	bc 01       	movw	r22, r24
    84be:	cd 01       	movw	r24, r26
    84c0:	28 96       	adiw	r28, 0x08	; 8
    84c2:	cd bf       	out	0x3d, r28	; 61
    84c4:	de bf       	out	0x3e, r29	; 62
    84c6:	df 91       	pop	r29
    84c8:	cf 91       	pop	r28
    84ca:	08 95       	ret

000084cc <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    84cc:	0f 93       	push	r16
    84ce:	1f 93       	push	r17
    84d0:	cf 93       	push	r28
    84d2:	df 93       	push	r29
    84d4:	cd b7       	in	r28, 0x3d	; 61
    84d6:	de b7       	in	r29, 0x3e	; 62
    84d8:	6c 97       	sbiw	r28, 0x1c	; 28
    84da:	cd bf       	out	0x3d, r28	; 61
    84dc:	de bf       	out	0x3e, r29	; 62
    84de:	8a 8f       	std	Y+26, r24	; 0x1a
    84e0:	6b 8f       	std	Y+27, r22	; 0x1b
    84e2:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    84e4:	80 91 5e 40 	lds	r24, 0x405E
    84e8:	90 91 5f 40 	lds	r25, 0x405F
    84ec:	a0 91 60 40 	lds	r26, 0x4060
    84f0:	b0 91 61 40 	lds	r27, 0x4061
    84f4:	89 83       	std	Y+1, r24	; 0x01
    84f6:	9a 83       	std	Y+2, r25	; 0x02
    84f8:	ab 83       	std	Y+3, r26	; 0x03
    84fa:	bc 83       	std	Y+4, r27	; 0x04
    84fc:	01 c0       	rjmp	.+2      	; 0x8500 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    84fe:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    8500:	89 81       	ldd	r24, Y+1	; 0x01
    8502:	9a 81       	ldd	r25, Y+2	; 0x02
    8504:	ab 81       	ldd	r26, Y+3	; 0x03
    8506:	bc 81       	ldd	r27, Y+4	; 0x04
    8508:	bc 01       	movw	r22, r24
    850a:	cd 01       	movw	r24, r26
    850c:	0e 94 da 40 	call	0x81b4	; 0x81b4 <getFirstSector>
    8510:	dc 01       	movw	r26, r24
    8512:	cb 01       	movw	r24, r22
    8514:	88 8b       	std	Y+16, r24	; 0x10
    8516:	99 8b       	std	Y+17, r25	; 0x11
    8518:	aa 8b       	std	Y+18, r26	; 0x12
    851a:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    851c:	1d 82       	std	Y+5, r1	; 0x05
    851e:	1e 82       	std	Y+6, r1	; 0x06
    8520:	1f 82       	std	Y+7, r1	; 0x07
    8522:	18 86       	std	Y+8, r1	; 0x08
    8524:	68 c1       	rjmp	.+720    	; 0x87f6 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    8526:	28 89       	ldd	r18, Y+16	; 0x10
    8528:	39 89       	ldd	r19, Y+17	; 0x11
    852a:	4a 89       	ldd	r20, Y+18	; 0x12
    852c:	5b 89       	ldd	r21, Y+19	; 0x13
    852e:	8d 81       	ldd	r24, Y+5	; 0x05
    8530:	9e 81       	ldd	r25, Y+6	; 0x06
    8532:	af 81       	ldd	r26, Y+7	; 0x07
    8534:	b8 85       	ldd	r27, Y+8	; 0x08
    8536:	82 0f       	add	r24, r18
    8538:	93 1f       	adc	r25, r19
    853a:	a4 1f       	adc	r26, r20
    853c:	b5 1f       	adc	r27, r21
    853e:	25 ed       	ldi	r18, 0xD5	; 213
    8540:	31 e2       	ldi	r19, 0x21	; 33
    8542:	bc 01       	movw	r22, r24
    8544:	cd 01       	movw	r24, r26
    8546:	a9 01       	movw	r20, r18
    8548:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    854c:	1d 86       	std	Y+13, r1	; 0x0d
    854e:	1e 86       	std	Y+14, r1	; 0x0e
    8550:	3d c1       	rjmp	.+634    	; 0x87cc <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    8552:	8d 85       	ldd	r24, Y+13	; 0x0d
    8554:	9e 85       	ldd	r25, Y+14	; 0x0e
    8556:	8b 52       	subi	r24, 0x2B	; 43
    8558:	9e 4d       	sbci	r25, 0xDE	; 222
    855a:	8c 8b       	std	Y+20, r24	; 0x14
    855c:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    855e:	8c 89       	ldd	r24, Y+20	; 0x14
    8560:	9d 89       	ldd	r25, Y+21	; 0x15
    8562:	fc 01       	movw	r30, r24
    8564:	80 81       	ld	r24, Z
    8566:	88 23       	and	r24, r24
    8568:	19 f4       	brne	.+6      	; 0x8570 <findFiles+0xa4>
		{
		  return 0;   
    856a:	80 e0       	ldi	r24, 0x00	; 0
    856c:	90 e0       	ldi	r25, 0x00	; 0
    856e:	80 c1       	rjmp	.+768    	; 0x8870 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    8570:	8c 89       	ldd	r24, Y+20	; 0x14
    8572:	9d 89       	ldd	r25, Y+21	; 0x15
    8574:	fc 01       	movw	r30, r24
    8576:	80 81       	ld	r24, Z
    8578:	85 3e       	cpi	r24, 0xE5	; 229
    857a:	09 f4       	brne	.+2      	; 0x857e <findFiles+0xb2>
    857c:	22 c1       	rjmp	.+580    	; 0x87c2 <findFiles+0x2f6>
    857e:	8c 89       	ldd	r24, Y+20	; 0x14
    8580:	9d 89       	ldd	r25, Y+21	; 0x15
    8582:	fc 01       	movw	r30, r24
    8584:	83 85       	ldd	r24, Z+11	; 0x0b
    8586:	8f 30       	cpi	r24, 0x0F	; 15
    8588:	09 f4       	brne	.+2      	; 0x858c <findFiles+0xc0>
    858a:	1b c1       	rjmp	.+566    	; 0x87c2 <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    858c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    858e:	81 30       	cpi	r24, 0x01	; 1
    8590:	21 f0       	breq	.+8      	; 0x859a <findFiles+0xce>
    8592:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8594:	82 30       	cpi	r24, 0x02	; 2
    8596:	09 f0       	breq	.+2      	; 0x859a <findFiles+0xce>
    8598:	11 c1       	rjmp	.+546    	; 0x87bc <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    859a:	1f 86       	std	Y+15, r1	; 0x0f
    859c:	17 c0       	rjmp	.+46     	; 0x85cc <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    859e:	8f 85       	ldd	r24, Y+15	; 0x0f
    85a0:	88 2f       	mov	r24, r24
    85a2:	90 e0       	ldi	r25, 0x00	; 0
    85a4:	2c 89       	ldd	r18, Y+20	; 0x14
    85a6:	3d 89       	ldd	r19, Y+21	; 0x15
    85a8:	82 0f       	add	r24, r18
    85aa:	93 1f       	adc	r25, r19
    85ac:	fc 01       	movw	r30, r24
    85ae:	40 81       	ld	r20, Z
    85b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    85b2:	88 2f       	mov	r24, r24
    85b4:	90 e0       	ldi	r25, 0x00	; 0
    85b6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    85b8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    85ba:	82 0f       	add	r24, r18
    85bc:	93 1f       	adc	r25, r19
    85be:	fc 01       	movw	r30, r24
    85c0:	80 81       	ld	r24, Z
    85c2:	48 17       	cp	r20, r24
    85c4:	39 f4       	brne	.+14     	; 0x85d4 <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    85c6:	8f 85       	ldd	r24, Y+15	; 0x0f
    85c8:	8f 5f       	subi	r24, 0xFF	; 255
    85ca:	8f 87       	std	Y+15, r24	; 0x0f
    85cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    85ce:	8b 30       	cpi	r24, 0x0B	; 11
    85d0:	30 f3       	brcs	.-52     	; 0x859e <findFiles+0xd2>
    85d2:	01 c0       	rjmp	.+2      	; 0x85d6 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    85d4:	00 00       	nop
            if(j == 11)
    85d6:	8f 85       	ldd	r24, Y+15	; 0x0f
    85d8:	8b 30       	cpi	r24, 0x0B	; 11
    85da:	09 f0       	breq	.+2      	; 0x85de <findFiles+0x112>
    85dc:	f2 c0       	rjmp	.+484    	; 0x87c2 <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    85de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    85e0:	81 30       	cpi	r24, 0x01	; 1
    85e2:	09 f0       	breq	.+2      	; 0x85e6 <findFiles+0x11a>
    85e4:	52 c0       	rjmp	.+164    	; 0x868a <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    85e6:	28 89       	ldd	r18, Y+16	; 0x10
    85e8:	39 89       	ldd	r19, Y+17	; 0x11
    85ea:	4a 89       	ldd	r20, Y+18	; 0x12
    85ec:	5b 89       	ldd	r21, Y+19	; 0x13
    85ee:	8d 81       	ldd	r24, Y+5	; 0x05
    85f0:	9e 81       	ldd	r25, Y+6	; 0x06
    85f2:	af 81       	ldd	r26, Y+7	; 0x07
    85f4:	b8 85       	ldd	r27, Y+8	; 0x08
    85f6:	82 0f       	add	r24, r18
    85f8:	93 1f       	adc	r25, r19
    85fa:	a4 1f       	adc	r26, r20
    85fc:	b5 1f       	adc	r27, r21
    85fe:	80 93 d0 50 	sts	0x50D0, r24
    8602:	90 93 d1 50 	sts	0x50D1, r25
    8606:	a0 93 d2 50 	sts	0x50D2, r26
    860a:	b0 93 d3 50 	sts	0x50D3, r27
				appendFileLocation = i;
    860e:	8d 85       	ldd	r24, Y+13	; 0x0d
    8610:	9e 85       	ldd	r25, Y+14	; 0x0e
    8612:	cc 01       	movw	r24, r24
    8614:	a0 e0       	ldi	r26, 0x00	; 0
    8616:	b0 e0       	ldi	r27, 0x00	; 0
    8618:	80 93 d6 23 	sts	0x23D6, r24
    861c:	90 93 d7 23 	sts	0x23D7, r25
    8620:	a0 93 d8 23 	sts	0x23D8, r26
    8624:	b0 93 d9 23 	sts	0x23D9, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8628:	8c 89       	ldd	r24, Y+20	; 0x14
    862a:	9d 89       	ldd	r25, Y+21	; 0x15
    862c:	fc 01       	movw	r30, r24
    862e:	84 89       	ldd	r24, Z+20	; 0x14
    8630:	95 89       	ldd	r25, Z+21	; 0x15
    8632:	cc 01       	movw	r24, r24
    8634:	a0 e0       	ldi	r26, 0x00	; 0
    8636:	b0 e0       	ldi	r27, 0x00	; 0
    8638:	ac 01       	movw	r20, r24
    863a:	33 27       	eor	r19, r19
    863c:	22 27       	eor	r18, r18
    863e:	8c 89       	ldd	r24, Y+20	; 0x14
    8640:	9d 89       	ldd	r25, Y+21	; 0x15
    8642:	fc 01       	movw	r30, r24
    8644:	82 8d       	ldd	r24, Z+26	; 0x1a
    8646:	93 8d       	ldd	r25, Z+27	; 0x1b
    8648:	cc 01       	movw	r24, r24
    864a:	a0 e0       	ldi	r26, 0x00	; 0
    864c:	b0 e0       	ldi	r27, 0x00	; 0
    864e:	82 2b       	or	r24, r18
    8650:	93 2b       	or	r25, r19
    8652:	a4 2b       	or	r26, r20
    8654:	b5 2b       	or	r27, r21
    8656:	80 93 86 50 	sts	0x5086, r24
    865a:	90 93 87 50 	sts	0x5087, r25
    865e:	a0 93 88 50 	sts	0x5088, r26
    8662:	b0 93 89 50 	sts	0x5089, r27
				fileSize = dir->fileSize;
    8666:	8c 89       	ldd	r24, Y+20	; 0x14
    8668:	9d 89       	ldd	r25, Y+21	; 0x15
    866a:	fc 01       	movw	r30, r24
    866c:	84 8d       	ldd	r24, Z+28	; 0x1c
    866e:	95 8d       	ldd	r25, Z+29	; 0x1d
    8670:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8672:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8674:	80 93 4f 40 	sts	0x404F, r24
    8678:	90 93 50 40 	sts	0x4050, r25
    867c:	a0 93 51 40 	sts	0x4051, r26
    8680:	b0 93 52 40 	sts	0x4052, r27
			    return (dir);
    8684:	8c 89       	ldd	r24, Y+20	; 0x14
    8686:	9d 89       	ldd	r25, Y+21	; 0x15
    8688:	f3 c0       	rjmp	.+486    	; 0x8870 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    868a:	8c 89       	ldd	r24, Y+20	; 0x14
    868c:	9d 89       	ldd	r25, Y+21	; 0x15
    868e:	fc 01       	movw	r30, r24
    8690:	84 89       	ldd	r24, Z+20	; 0x14
    8692:	95 89       	ldd	r25, Z+21	; 0x15
    8694:	cc 01       	movw	r24, r24
    8696:	a0 e0       	ldi	r26, 0x00	; 0
    8698:	b0 e0       	ldi	r27, 0x00	; 0
    869a:	ac 01       	movw	r20, r24
    869c:	33 27       	eor	r19, r19
    869e:	22 27       	eor	r18, r18
    86a0:	8c 89       	ldd	r24, Y+20	; 0x14
    86a2:	9d 89       	ldd	r25, Y+21	; 0x15
    86a4:	fc 01       	movw	r30, r24
    86a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    86a8:	93 8d       	ldd	r25, Z+27	; 0x1b
    86aa:	cc 01       	movw	r24, r24
    86ac:	a0 e0       	ldi	r26, 0x00	; 0
    86ae:	b0 e0       	ldi	r27, 0x00	; 0
    86b0:	82 2b       	or	r24, r18
    86b2:	93 2b       	or	r25, r19
    86b4:	a4 2b       	or	r26, r20
    86b6:	b5 2b       	or	r27, r21
    86b8:	89 87       	std	Y+9, r24	; 0x09
    86ba:	9a 87       	std	Y+10, r25	; 0x0a
    86bc:	ab 87       	std	Y+11, r26	; 0x0b
    86be:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    86c0:	8c 89       	ldd	r24, Y+20	; 0x14
    86c2:	9d 89       	ldd	r25, Y+21	; 0x15
    86c4:	25 ee       	ldi	r18, 0xE5	; 229
    86c6:	fc 01       	movw	r30, r24
    86c8:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    86ca:	28 89       	ldd	r18, Y+16	; 0x10
    86cc:	39 89       	ldd	r19, Y+17	; 0x11
    86ce:	4a 89       	ldd	r20, Y+18	; 0x12
    86d0:	5b 89       	ldd	r21, Y+19	; 0x13
    86d2:	8d 81       	ldd	r24, Y+5	; 0x05
    86d4:	9e 81       	ldd	r25, Y+6	; 0x06
    86d6:	af 81       	ldd	r26, Y+7	; 0x07
    86d8:	b8 85       	ldd	r27, Y+8	; 0x08
    86da:	82 0f       	add	r24, r18
    86dc:	93 1f       	adc	r25, r19
    86de:	a4 1f       	adc	r26, r20
    86e0:	b5 1f       	adc	r27, r21
    86e2:	25 ed       	ldi	r18, 0xD5	; 213
    86e4:	31 e2       	ldi	r19, 0x21	; 33
    86e6:	bc 01       	movw	r22, r24
    86e8:	cd 01       	movw	r24, r26
    86ea:	a9 01       	movw	r20, r18
    86ec:	20 e0       	ldi	r18, 0x00	; 0
    86ee:	32 e0       	ldi	r19, 0x02	; 2
    86f0:	0e 94 21 4e 	call	0x9c42	; 0x9c42 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    86f4:	8c 89       	ldd	r24, Y+20	; 0x14
    86f6:	9d 89       	ldd	r25, Y+21	; 0x15
    86f8:	fc 01       	movw	r30, r24
    86fa:	24 8d       	ldd	r18, Z+28	; 0x1c
    86fc:	35 8d       	ldd	r19, Z+29	; 0x1d
    86fe:	46 8d       	ldd	r20, Z+30	; 0x1e
    8700:	57 8d       	ldd	r21, Z+31	; 0x1f
    8702:	80 e0       	ldi	r24, 0x00	; 0
    8704:	ba 01       	movw	r22, r20
    8706:	a9 01       	movw	r20, r18
    8708:	0e 94 c2 4a 	call	0x9584	; 0x9584 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    870c:	82 e0       	ldi	r24, 0x02	; 2
    870e:	60 e0       	ldi	r22, 0x00	; 0
    8710:	20 e0       	ldi	r18, 0x00	; 0
    8712:	30 e0       	ldi	r19, 0x00	; 0
    8714:	a9 01       	movw	r20, r18
    8716:	0e 94 b5 41 	call	0x836a	; 0x836a <getSetFreeCluster>
    871a:	dc 01       	movw	r26, r24
    871c:	cb 01       	movw	r24, r22
    871e:	89 83       	std	Y+1, r24	; 0x01
    8720:	9a 83       	std	Y+2, r25	; 0x02
    8722:	ab 83       	std	Y+3, r26	; 0x03
    8724:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8726:	29 85       	ldd	r18, Y+9	; 0x09
    8728:	3a 85       	ldd	r19, Y+10	; 0x0a
    872a:	4b 85       	ldd	r20, Y+11	; 0x0b
    872c:	5c 85       	ldd	r21, Y+12	; 0x0c
    872e:	89 81       	ldd	r24, Y+1	; 0x01
    8730:	9a 81       	ldd	r25, Y+2	; 0x02
    8732:	ab 81       	ldd	r26, Y+3	; 0x03
    8734:	bc 81       	ldd	r27, Y+4	; 0x04
    8736:	28 17       	cp	r18, r24
    8738:	39 07       	cpc	r19, r25
    873a:	4a 07       	cpc	r20, r26
    873c:	5b 07       	cpc	r21, r27
    873e:	40 f4       	brcc	.+16     	; 0x8750 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    8740:	29 85       	ldd	r18, Y+9	; 0x09
    8742:	3a 85       	ldd	r19, Y+10	; 0x0a
    8744:	4b 85       	ldd	r20, Y+11	; 0x0b
    8746:	5c 85       	ldd	r21, Y+12	; 0x0c
    8748:	82 e0       	ldi	r24, 0x02	; 2
    874a:	61 e0       	ldi	r22, 0x01	; 1
    874c:	0e 94 b5 41 	call	0x836a	; 0x836a <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    8750:	89 85       	ldd	r24, Y+9	; 0x09
    8752:	9a 85       	ldd	r25, Y+10	; 0x0a
    8754:	ab 85       	ldd	r26, Y+11	; 0x0b
    8756:	bc 85       	ldd	r27, Y+12	; 0x0c
    8758:	bc 01       	movw	r22, r24
    875a:	cd 01       	movw	r24, r26
    875c:	40 e0       	ldi	r20, 0x00	; 0
    875e:	00 e0       	ldi	r16, 0x00	; 0
    8760:	10 e0       	ldi	r17, 0x00	; 0
    8762:	98 01       	movw	r18, r16
    8764:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
    8768:	dc 01       	movw	r26, r24
    876a:	cb 01       	movw	r24, r22
    876c:	8e 8b       	std	Y+22, r24	; 0x16
    876e:	9f 8b       	std	Y+23, r25	; 0x17
    8770:	a8 8f       	std	Y+24, r26	; 0x18
    8772:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8774:	89 85       	ldd	r24, Y+9	; 0x09
    8776:	9a 85       	ldd	r25, Y+10	; 0x0a
    8778:	ab 85       	ldd	r26, Y+11	; 0x0b
    877a:	bc 85       	ldd	r27, Y+12	; 0x0c
    877c:	bc 01       	movw	r22, r24
    877e:	cd 01       	movw	r24, r26
    8780:	41 e0       	ldi	r20, 0x01	; 1
    8782:	00 e0       	ldi	r16, 0x00	; 0
    8784:	10 e0       	ldi	r17, 0x00	; 0
    8786:	98 01       	movw	r18, r16
    8788:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    878c:	8e 89       	ldd	r24, Y+22	; 0x16
    878e:	9f 89       	ldd	r25, Y+23	; 0x17
    8790:	a8 8d       	ldd	r26, Y+24	; 0x18
    8792:	b9 8d       	ldd	r27, Y+25	; 0x19
    8794:	87 3f       	cpi	r24, 0xF7	; 247
    8796:	ff ef       	ldi	r31, 0xFF	; 255
    8798:	9f 07       	cpc	r25, r31
    879a:	ff ef       	ldi	r31, 0xFF	; 255
    879c:	af 07       	cpc	r26, r31
    879e:	ff e0       	ldi	r31, 0x0F	; 15
    87a0:	bf 07       	cpc	r27, r31
    87a2:	18 f0       	brcs	.+6      	; 0x87aa <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    87a4:	80 e0       	ldi	r24, 0x00	; 0
    87a6:	90 e0       	ldi	r25, 0x00	; 0
    87a8:	63 c0       	rjmp	.+198    	; 0x8870 <findFiles+0x3a4>
					firstCluster = nextCluster;
    87aa:	8e 89       	ldd	r24, Y+22	; 0x16
    87ac:	9f 89       	ldd	r25, Y+23	; 0x17
    87ae:	a8 8d       	ldd	r26, Y+24	; 0x18
    87b0:	b9 8d       	ldd	r27, Y+25	; 0x19
    87b2:	89 87       	std	Y+9, r24	; 0x09
    87b4:	9a 87       	std	Y+10, r25	; 0x0a
    87b6:	ab 87       	std	Y+11, r26	; 0x0b
    87b8:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    87ba:	ca cf       	rjmp	.-108    	; 0x8750 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    87bc:	80 e0       	ldi	r24, 0x00	; 0
    87be:	90 e0       	ldi	r25, 0x00	; 0
    87c0:	57 c0       	rjmp	.+174    	; 0x8870 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    87c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    87c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    87c6:	80 96       	adiw	r24, 0x20	; 32
    87c8:	8d 87       	std	Y+13, r24	; 0x0d
    87ca:	9e 87       	std	Y+14, r25	; 0x0e
    87cc:	80 91 53 40 	lds	r24, 0x4053
    87d0:	90 91 54 40 	lds	r25, 0x4054
    87d4:	2d 85       	ldd	r18, Y+13	; 0x0d
    87d6:	3e 85       	ldd	r19, Y+14	; 0x0e
    87d8:	28 17       	cp	r18, r24
    87da:	39 07       	cpc	r19, r25
    87dc:	08 f4       	brcc	.+2      	; 0x87e0 <findFiles+0x314>
    87de:	b9 ce       	rjmp	.-654    	; 0x8552 <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    87e0:	8d 81       	ldd	r24, Y+5	; 0x05
    87e2:	9e 81       	ldd	r25, Y+6	; 0x06
    87e4:	af 81       	ldd	r26, Y+7	; 0x07
    87e6:	b8 85       	ldd	r27, Y+8	; 0x08
    87e8:	01 96       	adiw	r24, 0x01	; 1
    87ea:	a1 1d       	adc	r26, r1
    87ec:	b1 1d       	adc	r27, r1
    87ee:	8d 83       	std	Y+5, r24	; 0x05
    87f0:	9e 83       	std	Y+6, r25	; 0x06
    87f2:	af 83       	std	Y+7, r26	; 0x07
    87f4:	b8 87       	std	Y+8, r27	; 0x08
    87f6:	80 91 7a 50 	lds	r24, 0x507A
    87fa:	90 91 7b 50 	lds	r25, 0x507B
    87fe:	9c 01       	movw	r18, r24
    8800:	40 e0       	ldi	r20, 0x00	; 0
    8802:	50 e0       	ldi	r21, 0x00	; 0
    8804:	8d 81       	ldd	r24, Y+5	; 0x05
    8806:	9e 81       	ldd	r25, Y+6	; 0x06
    8808:	af 81       	ldd	r26, Y+7	; 0x07
    880a:	b8 85       	ldd	r27, Y+8	; 0x08
    880c:	82 17       	cp	r24, r18
    880e:	93 07       	cpc	r25, r19
    8810:	a4 07       	cpc	r26, r20
    8812:	b5 07       	cpc	r27, r21
    8814:	08 f4       	brcc	.+2      	; 0x8818 <findFiles+0x34c>
    8816:	87 ce       	rjmp	.-754    	; 0x8526 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8818:	89 81       	ldd	r24, Y+1	; 0x01
    881a:	9a 81       	ldd	r25, Y+2	; 0x02
    881c:	ab 81       	ldd	r26, Y+3	; 0x03
    881e:	bc 81       	ldd	r27, Y+4	; 0x04
    8820:	bc 01       	movw	r22, r24
    8822:	cd 01       	movw	r24, r26
    8824:	40 e0       	ldi	r20, 0x00	; 0
    8826:	00 e0       	ldi	r16, 0x00	; 0
    8828:	10 e0       	ldi	r17, 0x00	; 0
    882a:	98 01       	movw	r18, r16
    882c:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
    8830:	dc 01       	movw	r26, r24
    8832:	cb 01       	movw	r24, r22
    8834:	89 83       	std	Y+1, r24	; 0x01
    8836:	9a 83       	std	Y+2, r25	; 0x02
    8838:	ab 83       	std	Y+3, r26	; 0x03
    883a:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    883c:	89 81       	ldd	r24, Y+1	; 0x01
    883e:	9a 81       	ldd	r25, Y+2	; 0x02
    8840:	ab 81       	ldd	r26, Y+3	; 0x03
    8842:	bc 81       	ldd	r27, Y+4	; 0x04
    8844:	87 3f       	cpi	r24, 0xF7	; 247
    8846:	2f ef       	ldi	r18, 0xFF	; 255
    8848:	92 07       	cpc	r25, r18
    884a:	2f ef       	ldi	r18, 0xFF	; 255
    884c:	a2 07       	cpc	r26, r18
    884e:	2f e0       	ldi	r18, 0x0F	; 15
    8850:	b2 07       	cpc	r27, r18
    8852:	18 f0       	brcs	.+6      	; 0x885a <findFiles+0x38e>
   	 return 0;
    8854:	80 e0       	ldi	r24, 0x00	; 0
    8856:	90 e0       	ldi	r25, 0x00	; 0
    8858:	0b c0       	rjmp	.+22     	; 0x8870 <findFiles+0x3a4>
   if(cluster == 0) 
    885a:	89 81       	ldd	r24, Y+1	; 0x01
    885c:	9a 81       	ldd	r25, Y+2	; 0x02
    885e:	ab 81       	ldd	r26, Y+3	; 0x03
    8860:	bc 81       	ldd	r27, Y+4	; 0x04
    8862:	00 97       	sbiw	r24, 0x00	; 0
    8864:	a1 05       	cpc	r26, r1
    8866:	b1 05       	cpc	r27, r1
    8868:	09 f0       	breq	.+2      	; 0x886c <findFiles+0x3a0>
    886a:	49 ce       	rjmp	.-878    	; 0x84fe <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    886c:	80 e0       	ldi	r24, 0x00	; 0
    886e:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    8870:	6c 96       	adiw	r28, 0x1c	; 28
    8872:	cd bf       	out	0x3d, r28	; 61
    8874:	de bf       	out	0x3e, r29	; 62
    8876:	df 91       	pop	r29
    8878:	cf 91       	pop	r28
    887a:	1f 91       	pop	r17
    887c:	0f 91       	pop	r16
    887e:	08 95       	ret

00008880 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    8880:	0f 93       	push	r16
    8882:	1f 93       	push	r17
    8884:	cf 93       	push	r28
    8886:	df 93       	push	r29
    8888:	cd b7       	in	r28, 0x3d	; 61
    888a:	de b7       	in	r29, 0x3e	; 62
    888c:	2f 97       	sbiw	r28, 0x0f	; 15
    888e:	cd bf       	out	0x3d, r28	; 61
    8890:	de bf       	out	0x3e, r29	; 62
    8892:	8d 87       	std	Y+13, r24	; 0x0d
    8894:	6e 87       	std	Y+14, r22	; 0x0e
    8896:	7f 87       	std	Y+15, r23	; 0x0f
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8898:	8e 85       	ldd	r24, Y+14	; 0x0e
    889a:	9f 85       	ldd	r25, Y+15	; 0x0f
    889c:	0e 94 e0 44 	call	0x89c0	; 0x89c0 <convertFileName>
    88a0:	8e 83       	std	Y+6, r24	; 0x06
if(error) return 2;
    88a2:	8e 81       	ldd	r24, Y+6	; 0x06
    88a4:	88 23       	and	r24, r24
    88a6:	11 f0       	breq	.+4      	; 0x88ac <readFile+0x2c>
    88a8:	82 e0       	ldi	r24, 0x02	; 2
    88aa:	82 c0       	rjmp	.+260    	; 0x89b0 <readFile+0x130>

dir = findFiles (GET_FILE, Filename); //get the file location
    88ac:	2a eb       	ldi	r18, 0xBA	; 186
    88ae:	30 e5       	ldi	r19, 0x50	; 80
    88b0:	81 e0       	ldi	r24, 0x01	; 1
    88b2:	b9 01       	movw	r22, r18
    88b4:	0e 94 66 42 	call	0x84cc	; 0x84cc <findFiles>
    88b8:	8f 83       	std	Y+7, r24	; 0x07
    88ba:	98 87       	std	Y+8, r25	; 0x08
if(dir == 0) 
    88bc:	8f 81       	ldd	r24, Y+7	; 0x07
    88be:	98 85       	ldd	r25, Y+8	; 0x08
    88c0:	00 97       	sbiw	r24, 0x00	; 0
    88c2:	39 f4       	brne	.+14     	; 0x88d2 <readFile+0x52>
{
  if(flag == READ) return (1);
    88c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    88c6:	88 23       	and	r24, r24
    88c8:	11 f4       	brne	.+4      	; 0x88ce <readFile+0x4e>
    88ca:	81 e0       	ldi	r24, 0x01	; 1
    88cc:	71 c0       	rjmp	.+226    	; 0x89b0 <readFile+0x130>
  else return (0);
    88ce:	80 e0       	ldi	r24, 0x00	; 0
    88d0:	6f c0       	rjmp	.+222    	; 0x89b0 <readFile+0x130>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    88d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    88d4:	81 30       	cpi	r24, 0x01	; 1
    88d6:	11 f4       	brne	.+4      	; 0x88dc <readFile+0x5c>
    88d8:	81 e0       	ldi	r24, 0x01	; 1
    88da:	6a c0       	rjmp	.+212    	; 0x89b0 <readFile+0x130>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    88dc:	8f 81       	ldd	r24, Y+7	; 0x07
    88de:	98 85       	ldd	r25, Y+8	; 0x08
    88e0:	fc 01       	movw	r30, r24
    88e2:	84 89       	ldd	r24, Z+20	; 0x14
    88e4:	95 89       	ldd	r25, Z+21	; 0x15
    88e6:	cc 01       	movw	r24, r24
    88e8:	a0 e0       	ldi	r26, 0x00	; 0
    88ea:	b0 e0       	ldi	r27, 0x00	; 0
    88ec:	ac 01       	movw	r20, r24
    88ee:	33 27       	eor	r19, r19
    88f0:	22 27       	eor	r18, r18
    88f2:	8f 81       	ldd	r24, Y+7	; 0x07
    88f4:	98 85       	ldd	r25, Y+8	; 0x08
    88f6:	fc 01       	movw	r30, r24
    88f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    88fa:	93 8d       	ldd	r25, Z+27	; 0x1b
    88fc:	cc 01       	movw	r24, r24
    88fe:	a0 e0       	ldi	r26, 0x00	; 0
    8900:	b0 e0       	ldi	r27, 0x00	; 0
    8902:	82 2b       	or	r24, r18
    8904:	93 2b       	or	r25, r19
    8906:	a4 2b       	or	r26, r20
    8908:	b5 2b       	or	r27, r21
    890a:	89 83       	std	Y+1, r24	; 0x01
    890c:	9a 83       	std	Y+2, r25	; 0x02
    890e:	ab 83       	std	Y+3, r26	; 0x03
    8910:	bc 83       	std	Y+4, r27	; 0x04
    8912:	01 c0       	rjmp	.+2      	; 0x8916 <readFile+0x96>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8914:	00 00       	nop
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8916:	89 81       	ldd	r24, Y+1	; 0x01
    8918:	9a 81       	ldd	r25, Y+2	; 0x02
    891a:	ab 81       	ldd	r26, Y+3	; 0x03
    891c:	bc 81       	ldd	r27, Y+4	; 0x04
    891e:	bc 01       	movw	r22, r24
    8920:	cd 01       	movw	r24, r26
    8922:	0e 94 da 40 	call	0x81b4	; 0x81b4 <getFirstSector>
    8926:	dc 01       	movw	r26, r24
    8928:	cb 01       	movw	r24, r22
    892a:	89 87       	std	Y+9, r24	; 0x09
    892c:	9a 87       	std	Y+10, r25	; 0x0a
    892e:	ab 87       	std	Y+11, r26	; 0x0b
    8930:	bc 87       	std	Y+12, r27	; 0x0c

  for(j=0; j<sectorPerCluster; j++)
    8932:	1d 82       	std	Y+5, r1	; 0x05
    8934:	17 c0       	rjmp	.+46     	; 0x8964 <readFile+0xe4>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8936:	8d 81       	ldd	r24, Y+5	; 0x05
    8938:	28 2f       	mov	r18, r24
    893a:	30 e0       	ldi	r19, 0x00	; 0
    893c:	40 e0       	ldi	r20, 0x00	; 0
    893e:	50 e0       	ldi	r21, 0x00	; 0
    8940:	89 85       	ldd	r24, Y+9	; 0x09
    8942:	9a 85       	ldd	r25, Y+10	; 0x0a
    8944:	ab 85       	ldd	r26, Y+11	; 0x0b
    8946:	bc 85       	ldd	r27, Y+12	; 0x0c
    8948:	82 0f       	add	r24, r18
    894a:	93 1f       	adc	r25, r19
    894c:	a4 1f       	adc	r26, r20
    894e:	b5 1f       	adc	r27, r21
    8950:	2e ed       	ldi	r18, 0xDE	; 222
    8952:	33 e2       	ldi	r19, 0x23	; 35
    8954:	bc 01       	movw	r22, r24
    8956:	cd 01       	movw	r24, r26
    8958:	a9 01       	movw	r20, r18
    895a:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    895e:	8d 81       	ldd	r24, Y+5	; 0x05
    8960:	8f 5f       	subi	r24, 0xFF	; 255
    8962:	8d 83       	std	Y+5, r24	; 0x05
    8964:	8d 81       	ldd	r24, Y+5	; 0x05
    8966:	28 2f       	mov	r18, r24
    8968:	30 e0       	ldi	r19, 0x00	; 0
    896a:	80 91 7a 50 	lds	r24, 0x507A
    896e:	90 91 7b 50 	lds	r25, 0x507B
    8972:	28 17       	cp	r18, r24
    8974:	39 07       	cpc	r19, r25
    8976:	f8 f2       	brcs	.-66     	; 0x8936 <readFile+0xb6>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8978:	89 81       	ldd	r24, Y+1	; 0x01
    897a:	9a 81       	ldd	r25, Y+2	; 0x02
    897c:	ab 81       	ldd	r26, Y+3	; 0x03
    897e:	bc 81       	ldd	r27, Y+4	; 0x04
    8980:	bc 01       	movw	r22, r24
    8982:	cd 01       	movw	r24, r26
    8984:	40 e0       	ldi	r20, 0x00	; 0
    8986:	00 e0       	ldi	r16, 0x00	; 0
    8988:	10 e0       	ldi	r17, 0x00	; 0
    898a:	98 01       	movw	r18, r16
    898c:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
    8990:	dc 01       	movw	r26, r24
    8992:	cb 01       	movw	r24, r22
    8994:	89 83       	std	Y+1, r24	; 0x01
    8996:	9a 83       	std	Y+2, r25	; 0x02
    8998:	ab 83       	std	Y+3, r26	; 0x03
    899a:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    899c:	89 81       	ldd	r24, Y+1	; 0x01
    899e:	9a 81       	ldd	r25, Y+2	; 0x02
    89a0:	ab 81       	ldd	r26, Y+3	; 0x03
    89a2:	bc 81       	ldd	r27, Y+4	; 0x04
    89a4:	00 97       	sbiw	r24, 0x00	; 0
    89a6:	a1 05       	cpc	r26, r1
    89a8:	b1 05       	cpc	r27, r1
    89aa:	09 f0       	breq	.+2      	; 0x89ae <readFile+0x12e>
    89ac:	b3 cf       	rjmp	.-154    	; 0x8914 <readFile+0x94>
	  return 0;}
    89ae:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    89b0:	2f 96       	adiw	r28, 0x0f	; 15
    89b2:	cd bf       	out	0x3d, r28	; 61
    89b4:	de bf       	out	0x3e, r29	; 62
    89b6:	df 91       	pop	r29
    89b8:	cf 91       	pop	r28
    89ba:	1f 91       	pop	r17
    89bc:	0f 91       	pop	r16
    89be:	08 95       	ret

000089c0 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    89c0:	cf 93       	push	r28
    89c2:	df 93       	push	r29
    89c4:	cd b7       	in	r28, 0x3d	; 61
    89c6:	de b7       	in	r29, 0x3e	; 62
    89c8:	62 97       	sbiw	r28, 0x12	; 18
    89ca:	cd bf       	out	0x3d, r28	; 61
    89cc:	de bf       	out	0x3e, r29	; 62
    89ce:	89 8b       	std	Y+17, r24	; 0x11
    89d0:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    89d2:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    89d4:	89 89       	ldd	r24, Y+17	; 0x11
    89d6:	9a 89       	ldd	r25, Y+18	; 0x12
    89d8:	9c 01       	movw	r18, r24
    89da:	f9 01       	movw	r30, r18
    89dc:	01 90       	ld	r0, Z+
    89de:	00 20       	and	r0, r0
    89e0:	e9 f7       	brne	.-6      	; 0x89dc <convertFileName+0x1c>
    89e2:	cf 01       	movw	r24, r30
    89e4:	01 97       	sbiw	r24, 0x01	; 1
    89e6:	82 1b       	sub	r24, r18
    89e8:	93 0b       	sbc	r25, r19
    89ea:	80 31       	cpi	r24, 0x10	; 16
    89ec:	91 05       	cpc	r25, r1
    89ee:	10 f0       	brcs	.+4      	; 0x89f4 <convertFileName+0x34>
    89f0:	81 e0       	ldi	r24, 0x01	; 1
    89f2:	16 c1       	rjmp	.+556    	; 0x8c20 <convertFileName+0x260>
int i=0;
    89f4:	1c 82       	std	Y+4, r1	; 0x04
    89f6:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen((const char*)fileName); i++){
    89f8:	13 c0       	rjmp	.+38     	; 0x8a20 <convertFileName+0x60>
	Filename[i] = fileName[i];
    89fa:	8c 81       	ldd	r24, Y+4	; 0x04
    89fc:	9d 81       	ldd	r25, Y+5	; 0x05
    89fe:	29 89       	ldd	r18, Y+17	; 0x11
    8a00:	3a 89       	ldd	r19, Y+18	; 0x12
    8a02:	82 0f       	add	r24, r18
    8a04:	93 1f       	adc	r25, r19
    8a06:	fc 01       	movw	r30, r24
    8a08:	20 81       	ld	r18, Z
    8a0a:	8c 81       	ldd	r24, Y+4	; 0x04
    8a0c:	9d 81       	ldd	r25, Y+5	; 0x05
    8a0e:	86 54       	subi	r24, 0x46	; 70
    8a10:	9f 4a       	sbci	r25, 0xAF	; 175
    8a12:	fc 01       	movw	r30, r24
    8a14:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    8a16:	8c 81       	ldd	r24, Y+4	; 0x04
    8a18:	9d 81       	ldd	r25, Y+5	; 0x05
    8a1a:	01 96       	adiw	r24, 0x01	; 1
    8a1c:	8c 83       	std	Y+4, r24	; 0x04
    8a1e:	9d 83       	std	Y+5, r25	; 0x05
    8a20:	4c 81       	ldd	r20, Y+4	; 0x04
    8a22:	5d 81       	ldd	r21, Y+5	; 0x05
    8a24:	89 89       	ldd	r24, Y+17	; 0x11
    8a26:	9a 89       	ldd	r25, Y+18	; 0x12
    8a28:	9c 01       	movw	r18, r24
    8a2a:	f9 01       	movw	r30, r18
    8a2c:	01 90       	ld	r0, Z+
    8a2e:	00 20       	and	r0, r0
    8a30:	e9 f7       	brne	.-6      	; 0x8a2c <convertFileName+0x6c>
    8a32:	cf 01       	movw	r24, r30
    8a34:	01 97       	sbiw	r24, 0x01	; 1
    8a36:	82 1b       	sub	r24, r18
    8a38:	93 0b       	sbc	r25, r19
    8a3a:	48 17       	cp	r20, r24
    8a3c:	59 07       	cpc	r21, r25
    8a3e:	e8 f2       	brcs	.-70     	; 0x89fa <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8a40:	0c c0       	rjmp	.+24     	; 0x8a5a <convertFileName+0x9a>
    8a42:	8c 81       	ldd	r24, Y+4	; 0x04
    8a44:	9d 81       	ldd	r25, Y+5	; 0x05
    8a46:	86 54       	subi	r24, 0x46	; 70
    8a48:	9f 4a       	sbci	r25, 0xAF	; 175
    8a4a:	20 e2       	ldi	r18, 0x20	; 32
    8a4c:	fc 01       	movw	r30, r24
    8a4e:	20 83       	st	Z, r18
    8a50:	8c 81       	ldd	r24, Y+4	; 0x04
    8a52:	9d 81       	ldd	r25, Y+5	; 0x05
    8a54:	01 96       	adiw	r24, 0x01	; 1
    8a56:	8c 83       	std	Y+4, r24	; 0x04
    8a58:	9d 83       	std	Y+5, r25	; 0x05
    8a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    8a5c:	9d 81       	ldd	r25, Y+5	; 0x05
    8a5e:	8f 30       	cpi	r24, 0x0F	; 15
    8a60:	91 05       	cpc	r25, r1
    8a62:	7c f3       	brlt	.-34     	; 0x8a42 <convertFileName+0x82>


for(j=0; j<12; j++)
    8a64:	1a 82       	std	Y+2, r1	; 0x02
    8a66:	0c c0       	rjmp	.+24     	; 0x8a80 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8a68:	8a 81       	ldd	r24, Y+2	; 0x02
    8a6a:	88 2f       	mov	r24, r24
    8a6c:	90 e0       	ldi	r25, 0x00	; 0
    8a6e:	86 54       	subi	r24, 0x46	; 70
    8a70:	9f 4a       	sbci	r25, 0xAF	; 175
    8a72:	fc 01       	movw	r30, r24
    8a74:	80 81       	ld	r24, Z
    8a76:	8e 32       	cpi	r24, 0x2E	; 46
    8a78:	39 f0       	breq	.+14     	; 0x8a88 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    8a7c:	8f 5f       	subi	r24, 0xFF	; 255
    8a7e:	8a 83       	std	Y+2, r24	; 0x02
    8a80:	8a 81       	ldd	r24, Y+2	; 0x02
    8a82:	8c 30       	cpi	r24, 0x0C	; 12
    8a84:	88 f3       	brcs	.-30     	; 0x8a68 <convertFileName+0xa8>
    8a86:	01 c0       	rjmp	.+2      	; 0x8a8a <convertFileName+0xca>
if(Filename[j] == '.') break;
    8a88:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    8a8c:	89 30       	cpi	r24, 0x09	; 9
    8a8e:	28 f0       	brcs	.+10     	; 0x8a9a <convertFileName+0xda>
    8a90:	8a 81       	ldd	r24, Y+2	; 0x02
    8a92:	8c 30       	cpi	r24, 0x0C	; 12
    8a94:	10 f4       	brcc	.+4      	; 0x8a9a <convertFileName+0xda>
	return 1;}
    8a96:	81 e0       	ldi	r24, 0x01	; 1
    8a98:	c3 c0       	rjmp	.+390    	; 0x8c20 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    8a9c:	8c 30       	cpi	r24, 0x0C	; 12
    8a9e:	11 f4       	brne	.+4      	; 0x8aa4 <convertFileName+0xe4>
    8aa0:	81 e0       	ldi	r24, 0x01	; 1
    8aa2:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8aa4:	1b 82       	std	Y+3, r1	; 0x03
    8aa6:	14 c0       	rjmp	.+40     	; 0x8ad0 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    8aaa:	88 2f       	mov	r24, r24
    8aac:	90 e0       	ldi	r25, 0x00	; 0
    8aae:	2b 81       	ldd	r18, Y+3	; 0x03
    8ab0:	22 2f       	mov	r18, r18
    8ab2:	30 e0       	ldi	r19, 0x00	; 0
    8ab4:	26 54       	subi	r18, 0x46	; 70
    8ab6:	3f 4a       	sbci	r19, 0xAF	; 175
    8ab8:	f9 01       	movw	r30, r18
    8aba:	40 81       	ld	r20, Z
    8abc:	9e 01       	movw	r18, r28
    8abe:	2a 5f       	subi	r18, 0xFA	; 250
    8ac0:	3f 4f       	sbci	r19, 0xFF	; 255
    8ac2:	82 0f       	add	r24, r18
    8ac4:	93 1f       	adc	r25, r19
    8ac6:	fc 01       	movw	r30, r24
    8ac8:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8aca:	8b 81       	ldd	r24, Y+3	; 0x03
    8acc:	8f 5f       	subi	r24, 0xFF	; 255
    8ace:	8b 83       	std	Y+3, r24	; 0x03
    8ad0:	9b 81       	ldd	r25, Y+3	; 0x03
    8ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    8ad4:	98 17       	cp	r25, r24
    8ad6:	40 f3       	brcs	.-48     	; 0x8aa8 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8ad8:	8a 81       	ldd	r24, Y+2	; 0x02
    8ada:	8b 83       	std	Y+3, r24	; 0x03
    8adc:	0e c0       	rjmp	.+28     	; 0x8afa <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8ade:	8b 81       	ldd	r24, Y+3	; 0x03
    8ae0:	88 2f       	mov	r24, r24
    8ae2:	90 e0       	ldi	r25, 0x00	; 0
    8ae4:	9e 01       	movw	r18, r28
    8ae6:	2a 5f       	subi	r18, 0xFA	; 250
    8ae8:	3f 4f       	sbci	r19, 0xFF	; 255
    8aea:	82 0f       	add	r24, r18
    8aec:	93 1f       	adc	r25, r19
    8aee:	20 e2       	ldi	r18, 0x20	; 32
    8af0:	fc 01       	movw	r30, r24
    8af2:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8af4:	8b 81       	ldd	r24, Y+3	; 0x03
    8af6:	8f 5f       	subi	r24, 0xFF	; 255
    8af8:	8b 83       	std	Y+3, r24	; 0x03
    8afa:	8b 81       	ldd	r24, Y+3	; 0x03
    8afc:	88 30       	cpi	r24, 0x08	; 8
    8afe:	78 f3       	brcs	.-34     	; 0x8ade <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8b00:	99 81       	ldd	r25, Y+1	; 0x01
    8b02:	81 e0       	ldi	r24, 0x01	; 1
    8b04:	89 27       	eor	r24, r25
    8b06:	88 23       	and	r24, r24
    8b08:	19 f0       	breq	.+6      	; 0x8b10 <convertFileName+0x150>
    8b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    8b0c:	8f 5f       	subi	r24, 0xFF	; 255
    8b0e:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8b10:	88 e0       	ldi	r24, 0x08	; 8
    8b12:	8b 83       	std	Y+3, r24	; 0x03
    8b14:	32 c0       	rjmp	.+100    	; 0x8b7a <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8b16:	8a 81       	ldd	r24, Y+2	; 0x02
    8b18:	88 2f       	mov	r24, r24
    8b1a:	90 e0       	ldi	r25, 0x00	; 0
    8b1c:	86 54       	subi	r24, 0x46	; 70
    8b1e:	9f 4a       	sbci	r25, 0xAF	; 175
    8b20:	fc 01       	movw	r30, r24
    8b22:	80 81       	ld	r24, Z
    8b24:	88 23       	and	r24, r24
    8b26:	19 f1       	breq	.+70     	; 0x8b6e <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8b28:	8b 81       	ldd	r24, Y+3	; 0x03
    8b2a:	88 2f       	mov	r24, r24
    8b2c:	90 e0       	ldi	r25, 0x00	; 0
    8b2e:	2a 81       	ldd	r18, Y+2	; 0x02
    8b30:	22 2f       	mov	r18, r18
    8b32:	30 e0       	ldi	r19, 0x00	; 0
    8b34:	26 54       	subi	r18, 0x46	; 70
    8b36:	3f 4a       	sbci	r19, 0xAF	; 175
    8b38:	f9 01       	movw	r30, r18
    8b3a:	40 81       	ld	r20, Z
    8b3c:	9e 01       	movw	r18, r28
    8b3e:	2a 5f       	subi	r18, 0xFA	; 250
    8b40:	3f 4f       	sbci	r19, 0xFF	; 255
    8b42:	82 0f       	add	r24, r18
    8b44:	93 1f       	adc	r25, r19
    8b46:	fc 01       	movw	r30, r24
    8b48:	40 83       	st	Z, r20
    8b4a:	8a 81       	ldd	r24, Y+2	; 0x02
    8b4c:	8f 5f       	subi	r24, 0xFF	; 255
    8b4e:	8a 83       	std	Y+2, r24	; 0x02
    8b50:	11 c0       	rjmp	.+34     	; 0x8b74 <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8b52:	8b 81       	ldd	r24, Y+3	; 0x03
    8b54:	88 2f       	mov	r24, r24
    8b56:	90 e0       	ldi	r25, 0x00	; 0
    8b58:	9e 01       	movw	r18, r28
    8b5a:	2a 5f       	subi	r18, 0xFA	; 250
    8b5c:	3f 4f       	sbci	r19, 0xFF	; 255
    8b5e:	82 0f       	add	r24, r18
    8b60:	93 1f       	adc	r25, r19
    8b62:	20 e2       	ldi	r18, 0x20	; 32
    8b64:	fc 01       	movw	r30, r24
    8b66:	20 83       	st	Z, r18
    8b68:	8b 81       	ldd	r24, Y+3	; 0x03
    8b6a:	8f 5f       	subi	r24, 0xFF	; 255
    8b6c:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    8b70:	8b 30       	cpi	r24, 0x0B	; 11
    8b72:	78 f3       	brcs	.-34     	; 0x8b52 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8b74:	8b 81       	ldd	r24, Y+3	; 0x03
    8b76:	8f 5f       	subi	r24, 0xFF	; 255
    8b78:	8b 83       	std	Y+3, r24	; 0x03
    8b7a:	8b 81       	ldd	r24, Y+3	; 0x03
    8b7c:	8b 30       	cpi	r24, 0x0B	; 11
    8b7e:	58 f2       	brcs	.-106    	; 0x8b16 <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8b80:	1a 82       	std	Y+2, r1	; 0x02
    8b82:	31 c0       	rjmp	.+98     	; 0x8be6 <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8b84:	8a 81       	ldd	r24, Y+2	; 0x02
    8b86:	88 2f       	mov	r24, r24
    8b88:	90 e0       	ldi	r25, 0x00	; 0
    8b8a:	9e 01       	movw	r18, r28
    8b8c:	2a 5f       	subi	r18, 0xFA	; 250
    8b8e:	3f 4f       	sbci	r19, 0xFF	; 255
    8b90:	82 0f       	add	r24, r18
    8b92:	93 1f       	adc	r25, r19
    8b94:	fc 01       	movw	r30, r24
    8b96:	80 81       	ld	r24, Z
    8b98:	81 36       	cpi	r24, 0x61	; 97
    8b9a:	10 f1       	brcs	.+68     	; 0x8be0 <convertFileName+0x220>
    8b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    8b9e:	88 2f       	mov	r24, r24
    8ba0:	90 e0       	ldi	r25, 0x00	; 0
    8ba2:	9e 01       	movw	r18, r28
    8ba4:	2a 5f       	subi	r18, 0xFA	; 250
    8ba6:	3f 4f       	sbci	r19, 0xFF	; 255
    8ba8:	82 0f       	add	r24, r18
    8baa:	93 1f       	adc	r25, r19
    8bac:	fc 01       	movw	r30, r24
    8bae:	80 81       	ld	r24, Z
    8bb0:	8b 37       	cpi	r24, 0x7B	; 123
    8bb2:	b0 f4       	brcc	.+44     	; 0x8be0 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    8bb6:	88 2f       	mov	r24, r24
    8bb8:	90 e0       	ldi	r25, 0x00	; 0
    8bba:	2a 81       	ldd	r18, Y+2	; 0x02
    8bbc:	22 2f       	mov	r18, r18
    8bbe:	30 e0       	ldi	r19, 0x00	; 0
    8bc0:	ae 01       	movw	r20, r28
    8bc2:	4a 5f       	subi	r20, 0xFA	; 250
    8bc4:	5f 4f       	sbci	r21, 0xFF	; 255
    8bc6:	24 0f       	add	r18, r20
    8bc8:	35 1f       	adc	r19, r21
    8bca:	f9 01       	movw	r30, r18
    8bcc:	20 81       	ld	r18, Z
    8bce:	42 2f       	mov	r20, r18
    8bd0:	40 52       	subi	r20, 0x20	; 32
    8bd2:	9e 01       	movw	r18, r28
    8bd4:	2a 5f       	subi	r18, 0xFA	; 250
    8bd6:	3f 4f       	sbci	r19, 0xFF	; 255
    8bd8:	82 0f       	add	r24, r18
    8bda:	93 1f       	adc	r25, r19
    8bdc:	fc 01       	movw	r30, r24
    8bde:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8be0:	8a 81       	ldd	r24, Y+2	; 0x02
    8be2:	8f 5f       	subi	r24, 0xFF	; 255
    8be4:	8a 83       	std	Y+2, r24	; 0x02
    8be6:	8a 81       	ldd	r24, Y+2	; 0x02
    8be8:	8b 30       	cpi	r24, 0x0B	; 11
    8bea:	60 f2       	brcs	.-104    	; 0x8b84 <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8bec:	1a 82       	std	Y+2, r1	; 0x02
    8bee:	14 c0       	rjmp	.+40     	; 0x8c18 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    8bf2:	88 2f       	mov	r24, r24
    8bf4:	90 e0       	ldi	r25, 0x00	; 0
    8bf6:	2a 81       	ldd	r18, Y+2	; 0x02
    8bf8:	22 2f       	mov	r18, r18
    8bfa:	30 e0       	ldi	r19, 0x00	; 0
    8bfc:	ae 01       	movw	r20, r28
    8bfe:	4a 5f       	subi	r20, 0xFA	; 250
    8c00:	5f 4f       	sbci	r21, 0xFF	; 255
    8c02:	24 0f       	add	r18, r20
    8c04:	35 1f       	adc	r19, r21
    8c06:	f9 01       	movw	r30, r18
    8c08:	20 81       	ld	r18, Z
    8c0a:	86 54       	subi	r24, 0x46	; 70
    8c0c:	9f 4a       	sbci	r25, 0xAF	; 175
    8c0e:	fc 01       	movw	r30, r24
    8c10:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8c12:	8a 81       	ldd	r24, Y+2	; 0x02
    8c14:	8f 5f       	subi	r24, 0xFF	; 255
    8c16:	8a 83       	std	Y+2, r24	; 0x02
    8c18:	8a 81       	ldd	r24, Y+2	; 0x02
    8c1a:	8b 30       	cpi	r24, 0x0B	; 11
    8c1c:	48 f3       	brcs	.-46     	; 0x8bf0 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8c1e:	80 e0       	ldi	r24, 0x00	; 0
}
    8c20:	62 96       	adiw	r28, 0x12	; 18
    8c22:	cd bf       	out	0x3d, r28	; 61
    8c24:	de bf       	out	0x3e, r29	; 62
    8c26:	df 91       	pop	r29
    8c28:	cf 91       	pop	r28
    8c2a:	08 95       	ret

00008c2c <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    8c2c:	ef 92       	push	r14
    8c2e:	ff 92       	push	r15
    8c30:	0f 93       	push	r16
    8c32:	1f 93       	push	r17
    8c34:	cf 93       	push	r28
    8c36:	df 93       	push	r29
    8c38:	cd b7       	in	r28, 0x3d	; 61
    8c3a:	de b7       	in	r29, 0x3e	; 62
    8c3c:	e7 97       	sbiw	r28, 0x37	; 55
    8c3e:	cd bf       	out	0x3d, r28	; 61
    8c40:	de bf       	out	0x3e, r29	; 62
    8c42:	88 ab       	sts	0x58, r24
    8c44:	99 ab       	sts	0x59, r25
    8c46:	6a ab       	sts	0x5a, r22
    8c48:	7b ab       	sts	0x5b, r23
    8c4a:	2c ab       	sts	0x5c, r18
    8c4c:	3d ab       	sts	0x5d, r19
    8c4e:	4e ab       	sts	0x5e, r20
    8c50:	5f ab       	sts	0x5f, r21
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8c52:	1a 82       	std	Y+2, r1	; 0x02
    8c54:	1b 82       	std	Y+3, r1	; 0x03
    8c56:	1c 82       	std	Y+4, r1	; 0x04
    8c58:	1d 82       	std	Y+5, r1	; 0x05
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8c5a:	1e 82       	std	Y+6, r1	; 0x06
    8c5c:	1f 82       	std	Y+7, r1	; 0x07
    8c5e:	18 86       	std	Y+8, r1	; 0x08
    8c60:	19 86       	std	Y+9, r1	; 0x09
    8c62:	1a 86       	std	Y+10, r1	; 0x0a
    8c64:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    8c66:	28 a9       	sts	0x48, r18
    8c68:	39 a9       	sts	0x49, r19
    8c6a:	81 e0       	ldi	r24, 0x01	; 1
    8c6c:	b9 01       	movw	r22, r18
    8c6e:	0e 94 40 44 	call	0x8880	; 0x8880 <readFile>
    8c72:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8c74:	89 81       	ldd	r24, Y+1	; 0x01
    8c76:	81 30       	cpi	r24, 0x01	; 1
    8c78:	09 f0       	breq	.+2      	; 0x8c7c <writeFile+0x50>
    8c7a:	84 c0       	rjmp	.+264    	; 0x8d84 <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    8c7c:	81 e0       	ldi	r24, 0x01	; 1
    8c7e:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8c80:	80 91 86 50 	lds	r24, 0x5086
    8c84:	90 91 87 50 	lds	r25, 0x5087
    8c88:	a0 91 88 50 	lds	r26, 0x5088
    8c8c:	b0 91 89 50 	lds	r27, 0x5089
    8c90:	8c 87       	std	Y+12, r24	; 0x0c
    8c92:	9d 87       	std	Y+13, r25	; 0x0d
    8c94:	ae 87       	std	Y+14, r26	; 0x0e
    8c96:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8c98:	1c 8a       	std	Y+20, r1	; 0x14
    8c9a:	1d 8a       	std	Y+21, r1	; 0x15
    8c9c:	1e 8a       	std	Y+22, r1	; 0x16
    8c9e:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8ca0:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ca2:	9d 85       	ldd	r25, Y+13	; 0x0d
    8ca4:	ae 85       	ldd	r26, Y+14	; 0x0e
    8ca6:	bf 85       	ldd	r27, Y+15	; 0x0f
    8ca8:	bc 01       	movw	r22, r24
    8caa:	cd 01       	movw	r24, r26
    8cac:	40 e0       	ldi	r20, 0x00	; 0
    8cae:	00 e0       	ldi	r16, 0x00	; 0
    8cb0:	10 e0       	ldi	r17, 0x00	; 0
    8cb2:	98 01       	movw	r18, r16
    8cb4:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
    8cb8:	dc 01       	movw	r26, r24
    8cba:	cb 01       	movw	r24, r22
    8cbc:	8a a3       	lds	r24, 0x5a
    8cbe:	9b a3       	lds	r25, 0x5b
    8cc0:	ac a3       	lds	r26, 0x5c
    8cc2:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    8cc4:	8a a1       	lds	r24, 0x4a
    8cc6:	9b a1       	lds	r25, 0x4b
    8cc8:	ac a1       	lds	r26, 0x4c
    8cca:	bd a1       	lds	r27, 0x4d
    8ccc:	8f 3f       	cpi	r24, 0xFF	; 255
    8cce:	0f ef       	ldi	r16, 0xFF	; 255
    8cd0:	90 07       	cpc	r25, r16
    8cd2:	0f ef       	ldi	r16, 0xFF	; 255
    8cd4:	a0 07       	cpc	r26, r16
    8cd6:	0f ef       	ldi	r16, 0xFF	; 255
    8cd8:	b0 07       	cpc	r27, r16
    8cda:	a1 f0       	breq	.+40     	; 0x8d04 <writeFile+0xd8>
	cluster = nextCluster;
    8cdc:	8a a1       	lds	r24, 0x4a
    8cde:	9b a1       	lds	r25, 0x4b
    8ce0:	ac a1       	lds	r26, 0x4c
    8ce2:	bd a1       	lds	r27, 0x4d
    8ce4:	8c 87       	std	Y+12, r24	; 0x0c
    8ce6:	9d 87       	std	Y+13, r25	; 0x0d
    8ce8:	ae 87       	std	Y+14, r26	; 0x0e
    8cea:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8cec:	8c 89       	ldd	r24, Y+20	; 0x14
    8cee:	9d 89       	ldd	r25, Y+21	; 0x15
    8cf0:	ae 89       	ldd	r26, Y+22	; 0x16
    8cf2:	bf 89       	ldd	r27, Y+23	; 0x17
    8cf4:	01 96       	adiw	r24, 0x01	; 1
    8cf6:	a1 1d       	adc	r26, r1
    8cf8:	b1 1d       	adc	r27, r1
    8cfa:	8c 8b       	std	Y+20, r24	; 0x14
    8cfc:	9d 8b       	std	Y+21, r25	; 0x15
    8cfe:	ae 8b       	std	Y+22, r26	; 0x16
    8d00:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8d02:	ce cf       	rjmp	.-100    	; 0x8ca0 <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8d04:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8d06:	e0 90 4f 40 	lds	r14, 0x404F
    8d0a:	f0 90 50 40 	lds	r15, 0x4050
    8d0e:	00 91 51 40 	lds	r16, 0x4051
    8d12:	10 91 52 40 	lds	r17, 0x4052
    8d16:	80 91 7a 50 	lds	r24, 0x507A
    8d1a:	90 91 7b 50 	lds	r25, 0x507B
    8d1e:	cc 01       	movw	r24, r24
    8d20:	a0 e0       	ldi	r26, 0x00	; 0
    8d22:	b0 e0       	ldi	r27, 0x00	; 0
    8d24:	2c 89       	ldd	r18, Y+20	; 0x14
    8d26:	3d 89       	ldd	r19, Y+21	; 0x15
    8d28:	4e 89       	ldd	r20, Y+22	; 0x16
    8d2a:	5f 89       	ldd	r21, Y+23	; 0x17
    8d2c:	bc 01       	movw	r22, r24
    8d2e:	cd 01       	movw	r24, r26
    8d30:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    8d34:	dc 01       	movw	r26, r24
    8d36:	cb 01       	movw	r24, r22
    8d38:	20 91 53 40 	lds	r18, 0x4053
    8d3c:	30 91 54 40 	lds	r19, 0x4054
    8d40:	99 01       	movw	r18, r18
    8d42:	40 e0       	ldi	r20, 0x00	; 0
    8d44:	50 e0       	ldi	r21, 0x00	; 0
    8d46:	bc 01       	movw	r22, r24
    8d48:	cd 01       	movw	r24, r26
    8d4a:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    8d4e:	dc 01       	movw	r26, r24
    8d50:	cb 01       	movw	r24, r22
    8d52:	a8 01       	movw	r20, r16
    8d54:	97 01       	movw	r18, r14
    8d56:	28 1b       	sub	r18, r24
    8d58:	39 0b       	sbc	r19, r25
    8d5a:	4a 0b       	sbc	r20, r26
    8d5c:	5b 0b       	sbc	r21, r27
    8d5e:	da 01       	movw	r26, r20
    8d60:	c9 01       	movw	r24, r18
    8d62:	20 91 53 40 	lds	r18, 0x4053
    8d66:	30 91 54 40 	lds	r19, 0x4054
    8d6a:	99 01       	movw	r18, r18
    8d6c:	40 e0       	ldi	r20, 0x00	; 0
    8d6e:	50 e0       	ldi	r21, 0x00	; 0
    8d70:	bc 01       	movw	r22, r24
    8d72:	cd 01       	movw	r24, r26
    8d74:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    8d78:	da 01       	movw	r26, r20
    8d7a:	c9 01       	movw	r24, r18
    8d7c:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8d7e:	81 e0       	ldi	r24, 0x01	; 1
    8d80:	8b 83       	std	Y+3, r24	; 0x03
    8d82:	68 c0       	rjmp	.+208    	; 0x8e54 <writeFile+0x228>
}
else if(j == 2) 
    8d84:	89 81       	ldd	r24, Y+1	; 0x01
    8d86:	82 30       	cpi	r24, 0x02	; 2
    8d88:	11 f4       	brne	.+4      	; 0x8d8e <writeFile+0x162>
   return 1; //invalid file name
    8d8a:	81 e0       	ldi	r24, 0x01	; 1
    8d8c:	18 c3       	rjmp	.+1584   	; 0x93be <writeFile+0x792>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8d8e:	82 e0       	ldi	r24, 0x02	; 2
    8d90:	60 e0       	ldi	r22, 0x00	; 0
    8d92:	20 e0       	ldi	r18, 0x00	; 0
    8d94:	30 e0       	ldi	r19, 0x00	; 0
    8d96:	a9 01       	movw	r20, r18
    8d98:	0e 94 b5 41 	call	0x836a	; 0x836a <getSetFreeCluster>
    8d9c:	dc 01       	movw	r26, r24
    8d9e:	cb 01       	movw	r24, r22
    8da0:	8c 87       	std	Y+12, r24	; 0x0c
    8da2:	9d 87       	std	Y+13, r25	; 0x0d
    8da4:	ae 87       	std	Y+14, r26	; 0x0e
    8da6:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8da8:	80 91 58 40 	lds	r24, 0x4058
    8dac:	90 91 59 40 	lds	r25, 0x4059
    8db0:	a0 91 5a 40 	lds	r26, 0x405A
    8db4:	b0 91 5b 40 	lds	r27, 0x405B
    8db8:	2c 85       	ldd	r18, Y+12	; 0x0c
    8dba:	3d 85       	ldd	r19, Y+13	; 0x0d
    8dbc:	4e 85       	ldd	r20, Y+14	; 0x0e
    8dbe:	5f 85       	ldd	r21, Y+15	; 0x0f
    8dc0:	82 17       	cp	r24, r18
    8dc2:	93 07       	cpc	r25, r19
    8dc4:	a4 07       	cpc	r26, r20
    8dc6:	b5 07       	cpc	r27, r21
    8dc8:	60 f4       	brcc	.+24     	; 0x8de2 <writeFile+0x1b6>
     cluster = rootCluster;
    8dca:	80 91 5e 40 	lds	r24, 0x405E
    8dce:	90 91 5f 40 	lds	r25, 0x405F
    8dd2:	a0 91 60 40 	lds	r26, 0x4060
    8dd6:	b0 91 61 40 	lds	r27, 0x4061
    8dda:	8c 87       	std	Y+12, r24	; 0x0c
    8ddc:	9d 87       	std	Y+13, r25	; 0x0d
    8dde:	ae 87       	std	Y+14, r26	; 0x0e
    8de0:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8de2:	8c 85       	ldd	r24, Y+12	; 0x0c
    8de4:	9d 85       	ldd	r25, Y+13	; 0x0d
    8de6:	ae 85       	ldd	r26, Y+14	; 0x0e
    8de8:	bf 85       	ldd	r27, Y+15	; 0x0f
    8dea:	bc 01       	movw	r22, r24
    8dec:	cd 01       	movw	r24, r26
    8dee:	0e 94 e9 49 	call	0x93d2	; 0x93d2 <searchNextFreeCluster>
    8df2:	dc 01       	movw	r26, r24
    8df4:	cb 01       	movw	r24, r22
    8df6:	8c 87       	std	Y+12, r24	; 0x0c
    8df8:	9d 87       	std	Y+13, r25	; 0x0d
    8dfa:	ae 87       	std	Y+14, r26	; 0x0e
    8dfc:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8dfe:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e00:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e02:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e04:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e06:	00 97       	sbiw	r24, 0x00	; 0
    8e08:	a1 05       	cpc	r26, r1
    8e0a:	b1 05       	cpc	r27, r1
    8e0c:	11 f4       	brne	.+4      	; 0x8e12 <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    8e0e:	82 e0       	ldi	r24, 0x02	; 2
    8e10:	d6 c2       	rjmp	.+1452   	; 0x93be <writeFile+0x792>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8e12:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e14:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e16:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e18:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e1a:	bc 01       	movw	r22, r24
    8e1c:	cd 01       	movw	r24, r26
    8e1e:	41 e0       	ldi	r20, 0x01	; 1
    8e20:	0f ef       	ldi	r16, 0xFF	; 255
    8e22:	1f ef       	ldi	r17, 0xFF	; 255
    8e24:	98 01       	movw	r18, r16
    8e26:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8e2a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e2c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e2e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e30:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e32:	cd 01       	movw	r24, r26
    8e34:	aa 27       	eor	r26, r26
    8e36:	bb 27       	eor	r27, r27
    8e38:	8e 83       	std	Y+6, r24	; 0x06
    8e3a:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8e3c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e3e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e40:	88 87       	std	Y+8, r24	; 0x08
    8e42:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8e44:	10 92 4f 40 	sts	0x404F, r1
    8e48:	10 92 50 40 	sts	0x4050, r1
    8e4c:	10 92 51 40 	sts	0x4051, r1
    8e50:	10 92 52 40 	sts	0x4052, r1
}

//start writing data here

if(start){
    8e54:	8b 81       	ldd	r24, Y+3	; 0x03
    8e56:	88 23       	and	r24, r24
    8e58:	11 f1       	breq	.+68     	; 0x8e9e <writeFile+0x272>
  start = 0;
    8e5a:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    8e5c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e5e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e60:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e62:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e64:	bc 01       	movw	r22, r24
    8e66:	cd 01       	movw	r24, r26
    8e68:	0e 94 da 40 	call	0x81b4	; 0x81b4 <getFirstSector>
    8e6c:	dc 01       	movw	r26, r24
    8e6e:	cb 01       	movw	r24, r22
    8e70:	9c 01       	movw	r18, r24
    8e72:	8d 81       	ldd	r24, Y+5	; 0x05
    8e74:	88 2f       	mov	r24, r24
    8e76:	90 e0       	ldi	r25, 0x00	; 0
    8e78:	82 0f       	add	r24, r18
    8e7a:	93 1f       	adc	r25, r19
    8e7c:	8a 87       	std	Y+10, r24	; 0x0a
    8e7e:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    8e80:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e82:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e84:	cc 01       	movw	r24, r24
    8e86:	a0 e0       	ldi	r26, 0x00	; 0
    8e88:	b0 e0       	ldi	r27, 0x00	; 0
    8e8a:	25 ed       	ldi	r18, 0xD5	; 213
    8e8c:	31 e2       	ldi	r19, 0x21	; 33
    8e8e:	bc 01       	movw	r22, r24
    8e90:	cd 01       	movw	r24, r26
    8e92:	a9 01       	movw	r20, r18
    8e94:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
  j = sector;
    8e98:	8d 81       	ldd	r24, Y+5	; 0x05
    8e9a:	89 83       	std	Y+1, r24	; 0x01
    8e9c:	0d c0       	rjmp	.+26     	; 0x8eb8 <writeFile+0x28c>
}
else{
  startBlock = getFirstSector (cluster);
    8e9e:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ea0:	9d 85       	ldd	r25, Y+13	; 0x0d
    8ea2:	ae 85       	ldd	r26, Y+14	; 0x0e
    8ea4:	bf 85       	ldd	r27, Y+15	; 0x0f
    8ea6:	bc 01       	movw	r22, r24
    8ea8:	cd 01       	movw	r24, r26
    8eaa:	0e 94 da 40 	call	0x81b4	; 0x81b4 <getFirstSector>
    8eae:	dc 01       	movw	r26, r24
    8eb0:	cb 01       	movw	r24, r22
    8eb2:	8a 87       	std	Y+10, r24	; 0x0a
    8eb4:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    8eb6:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    8eb8:	18 8e       	std	Y+24, r1	; 0x18
    8eba:	19 8e       	std	Y+25, r1	; 0x19
    8ebc:	1a 8e       	std	Y+26, r1	; 0x1a
    8ebe:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    8ec0:	1c 8e       	std	Y+28, r1	; 0x1c
    8ec2:	1d 8e       	std	Y+29, r1	; 0x1d
    8ec4:	1e 8e       	std	Y+30, r1	; 0x1e
    8ec6:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    8ec8:	cc c0       	rjmp	.+408    	; 0x9062 <writeFile+0x436>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    8eca:	8c a9       	sts	0x4c, r24
    8ecc:	9d a9       	sts	0x4d, r25
    8ece:	ae a9       	sts	0x4e, r26
    8ed0:	bf a9       	sts	0x4f, r27
    8ed2:	80 30       	cpi	r24, 0x00	; 0
    8ed4:	32 e0       	ldi	r19, 0x02	; 2
    8ed6:	93 07       	cpc	r25, r19
    8ed8:	30 e0       	ldi	r19, 0x00	; 0
    8eda:	a3 07       	cpc	r26, r19
    8edc:	30 e0       	ldi	r19, 0x00	; 0
    8ede:	b3 07       	cpc	r27, r19
    8ee0:	08 f1       	brcs	.+66     	; 0x8f24 <writeFile+0x2f8>
		 writtenData += 512;
    8ee2:	88 8d       	ldd	r24, Y+24	; 0x18
    8ee4:	99 8d       	ldd	r25, Y+25	; 0x19
    8ee6:	aa 8d       	ldd	r26, Y+26	; 0x1a
    8ee8:	bb 8d       	ldd	r27, Y+27	; 0x1b
    8eea:	80 50       	subi	r24, 0x00	; 0
    8eec:	9e 4f       	sbci	r25, 0xFE	; 254
    8eee:	af 4f       	sbci	r26, 0xFF	; 255
    8ef0:	bf 4f       	sbci	r27, 0xFF	; 255
    8ef2:	88 8f       	std	Y+24, r24	; 0x18
    8ef4:	99 8f       	std	Y+25, r25	; 0x19
    8ef6:	aa 8f       	std	Y+26, r26	; 0x1a
    8ef8:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    8efa:	80 e0       	ldi	r24, 0x00	; 0
    8efc:	92 e0       	ldi	r25, 0x02	; 2
    8efe:	a0 e0       	ldi	r26, 0x00	; 0
    8f00:	b0 e0       	ldi	r27, 0x00	; 0
    8f02:	8c 8f       	std	Y+28, r24	; 0x1c
    8f04:	9d 8f       	std	Y+29, r25	; 0x1d
    8f06:	ae 8f       	std	Y+30, r26	; 0x1e
    8f08:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    8f0a:	8c a9       	sts	0x4c, r24
    8f0c:	9d a9       	sts	0x4d, r25
    8f0e:	ae a9       	sts	0x4e, r26
    8f10:	bf a9       	sts	0x4f, r27
    8f12:	80 50       	subi	r24, 0x00	; 0
    8f14:	92 40       	sbci	r25, 0x02	; 2
    8f16:	a0 40       	sbci	r26, 0x00	; 0
    8f18:	b0 40       	sbci	r27, 0x00	; 0
    8f1a:	8c ab       	sts	0x5c, r24
    8f1c:	9d ab       	sts	0x5d, r25
    8f1e:	ae ab       	sts	0x5e, r26
    8f20:	bf ab       	sts	0x5f, r27
    8f22:	1f c0       	rjmp	.+62     	; 0x8f62 <writeFile+0x336>
	}
	else{
		writtenData += lengthOfData;
    8f24:	28 8d       	ldd	r18, Y+24	; 0x18
    8f26:	39 8d       	ldd	r19, Y+25	; 0x19
    8f28:	4a 8d       	ldd	r20, Y+26	; 0x1a
    8f2a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    8f2c:	8c a9       	sts	0x4c, r24
    8f2e:	9d a9       	sts	0x4d, r25
    8f30:	ae a9       	sts	0x4e, r26
    8f32:	bf a9       	sts	0x4f, r27
    8f34:	82 0f       	add	r24, r18
    8f36:	93 1f       	adc	r25, r19
    8f38:	a4 1f       	adc	r26, r20
    8f3a:	b5 1f       	adc	r27, r21
    8f3c:	88 8f       	std	Y+24, r24	; 0x18
    8f3e:	99 8f       	std	Y+25, r25	; 0x19
    8f40:	aa 8f       	std	Y+26, r26	; 0x1a
    8f42:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    8f44:	8c a9       	sts	0x4c, r24
    8f46:	9d a9       	sts	0x4d, r25
    8f48:	ae a9       	sts	0x4e, r26
    8f4a:	bf a9       	sts	0x4f, r27
    8f4c:	91 70       	andi	r25, 0x01	; 1
    8f4e:	a0 70       	andi	r26, 0x00	; 0
    8f50:	b0 70       	andi	r27, 0x00	; 0
    8f52:	8c 8f       	std	Y+28, r24	; 0x1c
    8f54:	9d 8f       	std	Y+29, r25	; 0x1d
    8f56:	ae 8f       	std	Y+30, r26	; 0x1e
    8f58:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    8f5a:	1c aa       	sts	0x9c, r17
    8f5c:	1d aa       	sts	0x9d, r17
    8f5e:	1e aa       	sts	0x9e, r17
    8f60:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    8f62:	80 91 4f 40 	lds	r24, 0x404F
    8f66:	90 91 50 40 	lds	r25, 0x4050
    8f6a:	a0 91 51 40 	lds	r26, 0x4051
    8f6e:	b0 91 52 40 	lds	r27, 0x4052
    8f72:	80 50       	subi	r24, 0x00	; 0
    8f74:	9e 4f       	sbci	r25, 0xFE	; 254
    8f76:	af 4f       	sbci	r26, 0xFF	; 255
    8f78:	bf 4f       	sbci	r27, 0xFF	; 255
    8f7a:	80 93 4f 40 	sts	0x404F, r24
    8f7e:	90 93 50 40 	sts	0x4050, r25
    8f82:	a0 93 51 40 	sts	0x4051, r26
    8f86:	b0 93 52 40 	sts	0x4052, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    8f8a:	8a 85       	ldd	r24, Y+10	; 0x0a
    8f8c:	9b 85       	ldd	r25, Y+11	; 0x0b
    8f8e:	cc 01       	movw	r24, r24
    8f90:	a0 e0       	ldi	r26, 0x00	; 0
    8f92:	b0 e0       	ldi	r27, 0x00	; 0
    8f94:	48 8d       	ldd	r20, Y+24	; 0x18
    8f96:	59 8d       	ldd	r21, Y+25	; 0x19
    8f98:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8f9a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8f9c:	ba 01       	movw	r22, r20
    8f9e:	62 1b       	sub	r22, r18
    8fa0:	73 0b       	sbc	r23, r19
    8fa2:	9b 01       	movw	r18, r22
    8fa4:	4a a9       	sts	0x4a, r20
    8fa6:	5b a9       	sts	0x4b, r21
    8fa8:	42 0f       	add	r20, r18
    8faa:	53 1f       	adc	r21, r19
    8fac:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8fae:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8fb0:	bc 01       	movw	r22, r24
    8fb2:	cd 01       	movw	r24, r26
    8fb4:	0e 94 21 4e 	call	0x9c42	; 0x9c42 <SD_write_block>
	j++;
    8fb8:	89 81       	ldd	r24, Y+1	; 0x01
    8fba:	8f 5f       	subi	r24, 0xFF	; 255
    8fbc:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    8fbe:	89 81       	ldd	r24, Y+1	; 0x01
    8fc0:	28 2f       	mov	r18, r24
    8fc2:	30 e0       	ldi	r19, 0x00	; 0
    8fc4:	80 91 7a 50 	lds	r24, 0x507A
    8fc8:	90 91 7b 50 	lds	r25, 0x507B
    8fcc:	28 17       	cp	r18, r24
    8fce:	39 07       	cpc	r19, r25
    8fd0:	d9 f5       	brne	.+118    	; 0x9048 <writeFile+0x41c>
		j = 0; 
    8fd2:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    8fd4:	8c 85       	ldd	r24, Y+12	; 0x0c
    8fd6:	9d 85       	ldd	r25, Y+13	; 0x0d
    8fd8:	ae 85       	ldd	r26, Y+14	; 0x0e
    8fda:	bf 85       	ldd	r27, Y+15	; 0x0f
    8fdc:	88 8b       	std	Y+16, r24	; 0x10
    8fde:	99 8b       	std	Y+17, r25	; 0x11
    8fe0:	aa 8b       	std	Y+18, r26	; 0x12
    8fe2:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    8fe4:	88 89       	ldd	r24, Y+16	; 0x10
    8fe6:	99 89       	ldd	r25, Y+17	; 0x11
    8fe8:	aa 89       	ldd	r26, Y+18	; 0x12
    8fea:	bb 89       	ldd	r27, Y+19	; 0x13
    8fec:	bc 01       	movw	r22, r24
    8fee:	cd 01       	movw	r24, r26
    8ff0:	0e 94 e9 49 	call	0x93d2	; 0x93d2 <searchNextFreeCluster>
    8ff4:	dc 01       	movw	r26, r24
    8ff6:	cb 01       	movw	r24, r22
    8ff8:	8c 87       	std	Y+12, r24	; 0x0c
    8ffa:	9d 87       	std	Y+13, r25	; 0x0d
    8ffc:	ae 87       	std	Y+14, r26	; 0x0e
    8ffe:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    9000:	8c 85       	ldd	r24, Y+12	; 0x0c
    9002:	9d 85       	ldd	r25, Y+13	; 0x0d
    9004:	ae 85       	ldd	r26, Y+14	; 0x0e
    9006:	bf 85       	ldd	r27, Y+15	; 0x0f
    9008:	00 97       	sbiw	r24, 0x00	; 0
    900a:	a1 05       	cpc	r26, r1
    900c:	b1 05       	cpc	r27, r1
    900e:	11 f4       	brne	.+4      	; 0x9014 <writeFile+0x3e8>
		  //No free cluster!
		  return 2;
    9010:	82 e0       	ldi	r24, 0x02	; 2
    9012:	d5 c1       	rjmp	.+938    	; 0x93be <writeFile+0x792>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    9014:	88 89       	ldd	r24, Y+16	; 0x10
    9016:	99 89       	ldd	r25, Y+17	; 0x11
    9018:	aa 89       	ldd	r26, Y+18	; 0x12
    901a:	bb 89       	ldd	r27, Y+19	; 0x13
    901c:	0c 85       	ldd	r16, Y+12	; 0x0c
    901e:	1d 85       	ldd	r17, Y+13	; 0x0d
    9020:	2e 85       	ldd	r18, Y+14	; 0x0e
    9022:	3f 85       	ldd	r19, Y+15	; 0x0f
    9024:	bc 01       	movw	r22, r24
    9026:	cd 01       	movw	r24, r26
    9028:	41 e0       	ldi	r20, 0x01	; 1
    902a:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    902e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9030:	9d 85       	ldd	r25, Y+13	; 0x0d
    9032:	ae 85       	ldd	r26, Y+14	; 0x0e
    9034:	bf 85       	ldd	r27, Y+15	; 0x0f
    9036:	bc 01       	movw	r22, r24
    9038:	cd 01       	movw	r24, r26
    903a:	41 e0       	ldi	r20, 0x01	; 1
    903c:	0f ef       	ldi	r16, 0xFF	; 255
    903e:	1f ef       	ldi	r17, 0xFF	; 255
    9040:	98 01       	movw	r18, r16
    9042:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
    9046:	05 c0       	rjmp	.+10     	; 0x9052 <writeFile+0x426>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    9048:	8a 85       	ldd	r24, Y+10	; 0x0a
    904a:	9b 85       	ldd	r25, Y+11	; 0x0b
    904c:	01 96       	adiw	r24, 0x01	; 1
    904e:	8a 87       	std	Y+10, r24	; 0x0a
    9050:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    9052:	2c 85       	ldd	r18, Y+12	; 0x0c
    9054:	3d 85       	ldd	r19, Y+13	; 0x0d
    9056:	4e 85       	ldd	r20, Y+14	; 0x0e
    9058:	5f 85       	ldd	r21, Y+15	; 0x0f
    905a:	82 e0       	ldi	r24, 0x02	; 2
    905c:	61 e0       	ldi	r22, 0x01	; 1
    905e:	0e 94 b5 41 	call	0x836a	; 0x836a <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    9062:	8c a9       	sts	0x4c, r24
    9064:	9d a9       	sts	0x4d, r25
    9066:	ae a9       	sts	0x4e, r26
    9068:	bf a9       	sts	0x4f, r27
    906a:	00 97       	sbiw	r24, 0x00	; 0
    906c:	a1 05       	cpc	r26, r1
    906e:	b1 05       	cpc	r27, r1
    9070:	09 f0       	breq	.+2      	; 0x9074 <writeFile+0x448>
    9072:	2b cf       	rjmp	.-426    	; 0x8eca <writeFile+0x29e>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    9074:	8c 81       	ldd	r24, Y+4	; 0x04
    9076:	88 23       	and	r24, r24
    9078:	09 f4       	brne	.+2      	; 0x907c <writeFile+0x450>
    907a:	66 c0       	rjmp	.+204    	; 0x9148 <writeFile+0x51c>
{
  SD_read_block (appendFileSector,SDBuffer);    
    907c:	80 91 d0 50 	lds	r24, 0x50D0
    9080:	90 91 d1 50 	lds	r25, 0x50D1
    9084:	a0 91 d2 50 	lds	r26, 0x50D2
    9088:	b0 91 d3 50 	lds	r27, 0x50D3
    908c:	25 ed       	ldi	r18, 0xD5	; 213
    908e:	31 e2       	ldi	r19, 0x21	; 33
    9090:	bc 01       	movw	r22, r24
    9092:	cd 01       	movw	r24, r26
    9094:	a9 01       	movw	r20, r18
    9096:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    909a:	80 91 d6 23 	lds	r24, 0x23D6
    909e:	90 91 d7 23 	lds	r25, 0x23D7
    90a2:	a0 91 d8 23 	lds	r26, 0x23D8
    90a6:	b0 91 d9 23 	lds	r27, 0x23D9
    90aa:	8b 52       	subi	r24, 0x2B	; 43
    90ac:	9e 4d       	sbci	r25, 0xDE	; 222
    90ae:	8e a3       	lds	r24, 0x5e
    90b0:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    90b2:	8e a1       	lds	r24, 0x4e
    90b4:	9f a1       	lds	r25, 0x4f
    90b6:	fc 01       	movw	r30, r24
    90b8:	12 8a       	std	Z+18, r1	; 0x12
    90ba:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    90bc:	20 91 4f 40 	lds	r18, 0x404F
    90c0:	30 91 50 40 	lds	r19, 0x4050
    90c4:	40 91 51 40 	lds	r20, 0x4051
    90c8:	50 91 52 40 	lds	r21, 0x4052
    90cc:	8e a1       	lds	r24, 0x4e
    90ce:	9f a1       	lds	r25, 0x4f
    90d0:	fc 01       	movw	r30, r24
    90d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    90d4:	95 8d       	ldd	r25, Z+29	; 0x1d
    90d6:	a6 8d       	ldd	r26, Z+30	; 0x1e
    90d8:	b7 8d       	ldd	r27, Z+31	; 0x1f
    90da:	79 01       	movw	r14, r18
    90dc:	8a 01       	movw	r16, r20
    90de:	e8 1a       	sub	r14, r24
    90e0:	f9 0a       	sbc	r15, r25
    90e2:	0a 0b       	sbc	r16, r26
    90e4:	1b 0b       	sbc	r17, r27
    90e6:	d8 01       	movw	r26, r16
    90e8:	c7 01       	movw	r24, r14
    90ea:	88 a7       	lds	r24, 0x78
    90ec:	99 a7       	lds	r25, 0x79
    90ee:	aa a7       	lds	r26, 0x7a
    90f0:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    90f2:	80 91 4f 40 	lds	r24, 0x404F
    90f6:	90 91 50 40 	lds	r25, 0x4050
    90fa:	a0 91 51 40 	lds	r26, 0x4051
    90fe:	b0 91 52 40 	lds	r27, 0x4052
    9102:	2e a1       	lds	r18, 0x4e
    9104:	3f a1       	lds	r19, 0x4f
    9106:	f9 01       	movw	r30, r18
    9108:	84 8f       	std	Z+28, r24	; 0x1c
    910a:	95 8f       	std	Z+29, r25	; 0x1d
    910c:	a6 8f       	std	Z+30, r26	; 0x1e
    910e:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    9110:	80 91 d0 50 	lds	r24, 0x50D0
    9114:	90 91 d1 50 	lds	r25, 0x50D1
    9118:	a0 91 d2 50 	lds	r26, 0x50D2
    911c:	b0 91 d3 50 	lds	r27, 0x50D3
    9120:	25 ed       	ldi	r18, 0xD5	; 213
    9122:	31 e2       	ldi	r19, 0x21	; 33
    9124:	bc 01       	movw	r22, r24
    9126:	cd 01       	movw	r24, r26
    9128:	a9 01       	movw	r20, r18
    912a:	20 e0       	ldi	r18, 0x00	; 0
    912c:	32 e0       	ldi	r19, 0x02	; 2
    912e:	0e 94 21 4e 	call	0x9c42	; 0x9c42 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    9132:	28 a5       	lds	r18, 0x68
    9134:	39 a5       	lds	r19, 0x69
    9136:	4a a5       	lds	r20, 0x6a
    9138:	5b a5       	lds	r21, 0x6b
    913a:	81 e0       	ldi	r24, 0x01	; 1
    913c:	ba 01       	movw	r22, r20
    913e:	a9 01       	movw	r20, r18
    9140:	0e 94 c2 4a 	call	0x9584	; 0x9584 <freeMemoryUpdate>

 //File appended!
  return 0;
    9144:	80 e0       	ldi	r24, 0x00	; 0
    9146:	3b c1       	rjmp	.+630    	; 0x93be <writeFile+0x792>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9148:	80 91 5e 40 	lds	r24, 0x405E
    914c:	90 91 5f 40 	lds	r25, 0x405F
    9150:	a0 91 60 40 	lds	r26, 0x4060
    9154:	b0 91 61 40 	lds	r27, 0x4061
    9158:	88 8b       	std	Y+16, r24	; 0x10
    915a:	99 8b       	std	Y+17, r25	; 0x11
    915c:	aa 8b       	std	Y+18, r26	; 0x12
    915e:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    9160:	88 89       	ldd	r24, Y+16	; 0x10
    9162:	99 89       	ldd	r25, Y+17	; 0x11
    9164:	aa 89       	ldd	r26, Y+18	; 0x12
    9166:	bb 89       	ldd	r27, Y+19	; 0x13
    9168:	bc 01       	movw	r22, r24
    916a:	cd 01       	movw	r24, r26
    916c:	0e 94 da 40 	call	0x81b4	; 0x81b4 <getFirstSector>
    9170:	dc 01       	movw	r26, r24
    9172:	cb 01       	movw	r24, r22
    9174:	8c a7       	lds	r24, 0x7c
    9176:	9d a7       	lds	r25, 0x7d
    9178:	ae a7       	lds	r26, 0x7e
    917a:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    917c:	1d 82       	std	Y+5, r1	; 0x05
    917e:	ad c0       	rjmp	.+346    	; 0x92da <writeFile+0x6ae>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    9180:	8d 81       	ldd	r24, Y+5	; 0x05
    9182:	28 2f       	mov	r18, r24
    9184:	30 e0       	ldi	r19, 0x00	; 0
    9186:	40 e0       	ldi	r20, 0x00	; 0
    9188:	50 e0       	ldi	r21, 0x00	; 0
    918a:	8c a5       	lds	r24, 0x6c
    918c:	9d a5       	lds	r25, 0x6d
    918e:	ae a5       	lds	r26, 0x6e
    9190:	bf a5       	lds	r27, 0x6f
    9192:	82 0f       	add	r24, r18
    9194:	93 1f       	adc	r25, r19
    9196:	a4 1f       	adc	r26, r20
    9198:	b5 1f       	adc	r27, r21
    919a:	25 ed       	ldi	r18, 0xD5	; 213
    919c:	31 e2       	ldi	r19, 0x21	; 33
    919e:	bc 01       	movw	r22, r24
    91a0:	cd 01       	movw	r24, r26
    91a2:	a9 01       	movw	r20, r18
    91a4:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    91a8:	18 a2       	lds	r17, 0x98
    91aa:	19 a2       	lds	r17, 0x99
    91ac:	89 c0       	rjmp	.+274    	; 0x92c0 <writeFile+0x694>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    91ae:	88 a1       	lds	r24, 0x48
    91b0:	99 a1       	lds	r25, 0x49
    91b2:	8b 52       	subi	r24, 0x2B	; 43
    91b4:	9e 4d       	sbci	r25, 0xDE	; 222
    91b6:	8e a3       	lds	r24, 0x5e
    91b8:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    91ba:	8a 81       	ldd	r24, Y+2	; 0x02
    91bc:	88 23       	and	r24, r24
    91be:	11 f0       	breq	.+4      	; 0x91c4 <writeFile+0x598>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    91c0:	80 e0       	ldi	r24, 0x00	; 0
    91c2:	fd c0       	rjmp	.+506    	; 0x93be <writeFile+0x792>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    91c4:	8e a1       	lds	r24, 0x4e
    91c6:	9f a1       	lds	r25, 0x4f
    91c8:	fc 01       	movw	r30, r24
    91ca:	80 81       	ld	r24, Z
    91cc:	88 23       	and	r24, r24
    91ce:	39 f0       	breq	.+14     	; 0x91de <writeFile+0x5b2>
    91d0:	8e a1       	lds	r24, 0x4e
    91d2:	9f a1       	lds	r25, 0x4f
    91d4:	fc 01       	movw	r30, r24
    91d6:	80 81       	ld	r24, Z
    91d8:	85 3e       	cpi	r24, 0xE5	; 229
    91da:	09 f0       	breq	.+2      	; 0x91de <writeFile+0x5b2>
    91dc:	6c c0       	rjmp	.+216    	; 0x92b6 <writeFile+0x68a>
		{
		  for(j=0; j<11; j++)
    91de:	19 82       	std	Y+1, r1	; 0x01
    91e0:	13 c0       	rjmp	.+38     	; 0x9208 <writeFile+0x5dc>
  			dir->name[j] = Filename[j];
    91e2:	89 81       	ldd	r24, Y+1	; 0x01
    91e4:	88 2f       	mov	r24, r24
    91e6:	90 e0       	ldi	r25, 0x00	; 0
    91e8:	29 81       	ldd	r18, Y+1	; 0x01
    91ea:	22 2f       	mov	r18, r18
    91ec:	30 e0       	ldi	r19, 0x00	; 0
    91ee:	26 54       	subi	r18, 0x46	; 70
    91f0:	3f 4a       	sbci	r19, 0xAF	; 175
    91f2:	f9 01       	movw	r30, r18
    91f4:	40 81       	ld	r20, Z
    91f6:	2e a1       	lds	r18, 0x4e
    91f8:	3f a1       	lds	r19, 0x4f
    91fa:	82 0f       	add	r24, r18
    91fc:	93 1f       	adc	r25, r19
    91fe:	fc 01       	movw	r30, r24
    9200:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    9202:	89 81       	ldd	r24, Y+1	; 0x01
    9204:	8f 5f       	subi	r24, 0xFF	; 255
    9206:	89 83       	std	Y+1, r24	; 0x01
    9208:	89 81       	ldd	r24, Y+1	; 0x01
    920a:	8b 30       	cpi	r24, 0x0B	; 11
    920c:	50 f3       	brcs	.-44     	; 0x91e2 <writeFile+0x5b6>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    920e:	8e a1       	lds	r24, 0x4e
    9210:	9f a1       	lds	r25, 0x4f
    9212:	20 e2       	ldi	r18, 0x20	; 32
    9214:	fc 01       	movw	r30, r24
    9216:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    9218:	8e a1       	lds	r24, 0x4e
    921a:	9f a1       	lds	r25, 0x4f
    921c:	fc 01       	movw	r30, r24
    921e:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    9220:	8e a1       	lds	r24, 0x4e
    9222:	9f a1       	lds	r25, 0x4f
    9224:	fc 01       	movw	r30, r24
    9226:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    9228:	8e a1       	lds	r24, 0x4e
    922a:	9f a1       	lds	r25, 0x4f
    922c:	fc 01       	movw	r30, r24
    922e:	12 8a       	std	Z+18, r1	; 0x12
    9230:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    9232:	8e a1       	lds	r24, 0x4e
    9234:	9f a1       	lds	r25, 0x4f
    9236:	2e 81       	ldd	r18, Y+6	; 0x06
    9238:	3f 81       	ldd	r19, Y+7	; 0x07
    923a:	fc 01       	movw	r30, r24
    923c:	24 8b       	std	Z+20, r18	; 0x14
    923e:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    9240:	8e a1       	lds	r24, 0x4e
    9242:	9f a1       	lds	r25, 0x4f
    9244:	28 85       	ldd	r18, Y+8	; 0x08
    9246:	39 85       	ldd	r19, Y+9	; 0x09
    9248:	fc 01       	movw	r30, r24
    924a:	22 8f       	std	Z+26, r18	; 0x1a
    924c:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    924e:	80 91 4f 40 	lds	r24, 0x404F
    9252:	90 91 50 40 	lds	r25, 0x4050
    9256:	a0 91 51 40 	lds	r26, 0x4051
    925a:	b0 91 52 40 	lds	r27, 0x4052
    925e:	2e a1       	lds	r18, 0x4e
    9260:	3f a1       	lds	r19, 0x4f
    9262:	f9 01       	movw	r30, r18
    9264:	84 8f       	std	Z+28, r24	; 0x1c
    9266:	95 8f       	std	Z+29, r25	; 0x1d
    9268:	a6 8f       	std	Z+30, r26	; 0x1e
    926a:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    926c:	8d 81       	ldd	r24, Y+5	; 0x05
    926e:	28 2f       	mov	r18, r24
    9270:	30 e0       	ldi	r19, 0x00	; 0
    9272:	40 e0       	ldi	r20, 0x00	; 0
    9274:	50 e0       	ldi	r21, 0x00	; 0
    9276:	8c a5       	lds	r24, 0x6c
    9278:	9d a5       	lds	r25, 0x6d
    927a:	ae a5       	lds	r26, 0x6e
    927c:	bf a5       	lds	r27, 0x6f
    927e:	82 0f       	add	r24, r18
    9280:	93 1f       	adc	r25, r19
    9282:	a4 1f       	adc	r26, r20
    9284:	b5 1f       	adc	r27, r21
    9286:	25 ed       	ldi	r18, 0xD5	; 213
    9288:	31 e2       	ldi	r19, 0x21	; 33
    928a:	bc 01       	movw	r22, r24
    928c:	cd 01       	movw	r24, r26
    928e:	a9 01       	movw	r20, r18
    9290:	20 e0       	ldi	r18, 0x00	; 0
    9292:	32 e0       	ldi	r19, 0x02	; 2
    9294:	0e 94 21 4e 	call	0x9c42	; 0x9c42 <SD_write_block>
		  fileCreatedFlag = 1;
    9298:	81 e0       	ldi	r24, 0x01	; 1
    929a:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    929c:	20 91 4f 40 	lds	r18, 0x404F
    92a0:	30 91 50 40 	lds	r19, 0x4050
    92a4:	40 91 51 40 	lds	r20, 0x4051
    92a8:	50 91 52 40 	lds	r21, 0x4052
    92ac:	81 e0       	ldi	r24, 0x01	; 1
    92ae:	ba 01       	movw	r22, r20
    92b0:	a9 01       	movw	r20, r18
    92b2:	0e 94 c2 4a 	call	0x9584	; 0x9584 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    92b6:	88 a1       	lds	r24, 0x48
    92b8:	99 a1       	lds	r25, 0x49
    92ba:	80 96       	adiw	r24, 0x20	; 32
    92bc:	88 a3       	lds	r24, 0x58
    92be:	99 a3       	lds	r25, 0x59
    92c0:	28 a1       	lds	r18, 0x48
    92c2:	39 a1       	lds	r19, 0x49
    92c4:	80 91 53 40 	lds	r24, 0x4053
    92c8:	90 91 54 40 	lds	r25, 0x4054
    92cc:	28 17       	cp	r18, r24
    92ce:	39 07       	cpc	r19, r25
    92d0:	08 f4       	brcc	.+2      	; 0x92d4 <writeFile+0x6a8>
    92d2:	6d cf       	rjmp	.-294    	; 0x91ae <writeFile+0x582>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    92d4:	8d 81       	ldd	r24, Y+5	; 0x05
    92d6:	8f 5f       	subi	r24, 0xFF	; 255
    92d8:	8d 83       	std	Y+5, r24	; 0x05
    92da:	8d 81       	ldd	r24, Y+5	; 0x05
    92dc:	28 2f       	mov	r18, r24
    92de:	30 e0       	ldi	r19, 0x00	; 0
    92e0:	80 91 7a 50 	lds	r24, 0x507A
    92e4:	90 91 7b 50 	lds	r25, 0x507B
    92e8:	28 17       	cp	r18, r24
    92ea:	39 07       	cpc	r19, r25
    92ec:	08 f4       	brcc	.+2      	; 0x92f0 <writeFile+0x6c4>
    92ee:	48 cf       	rjmp	.-368    	; 0x9180 <writeFile+0x554>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    92f0:	88 89       	ldd	r24, Y+16	; 0x10
    92f2:	99 89       	ldd	r25, Y+17	; 0x11
    92f4:	aa 89       	ldd	r26, Y+18	; 0x12
    92f6:	bb 89       	ldd	r27, Y+19	; 0x13
    92f8:	bc 01       	movw	r22, r24
    92fa:	cd 01       	movw	r24, r26
    92fc:	40 e0       	ldi	r20, 0x00	; 0
    92fe:	00 e0       	ldi	r16, 0x00	; 0
    9300:	10 e0       	ldi	r17, 0x00	; 0
    9302:	98 01       	movw	r18, r16
    9304:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
    9308:	dc 01       	movw	r26, r24
    930a:	cb 01       	movw	r24, r22
    930c:	8c 87       	std	Y+12, r24	; 0x0c
    930e:	9d 87       	std	Y+13, r25	; 0x0d
    9310:	ae 87       	std	Y+14, r26	; 0x0e
    9312:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    9314:	8c 85       	ldd	r24, Y+12	; 0x0c
    9316:	9d 85       	ldd	r25, Y+13	; 0x0d
    9318:	ae 85       	ldd	r26, Y+14	; 0x0e
    931a:	bf 85       	ldd	r27, Y+15	; 0x0f
    931c:	87 3f       	cpi	r24, 0xF7	; 247
    931e:	ff ef       	ldi	r31, 0xFF	; 255
    9320:	9f 07       	cpc	r25, r31
    9322:	ff ef       	ldi	r31, 0xFF	; 255
    9324:	af 07       	cpc	r26, r31
    9326:	ff e0       	ldi	r31, 0x0F	; 15
    9328:	bf 07       	cpc	r27, r31
    932a:	b0 f1       	brcs	.+108    	; 0x9398 <writeFile+0x76c>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    932c:	8c 85       	ldd	r24, Y+12	; 0x0c
    932e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9330:	ae 85       	ldd	r26, Y+14	; 0x0e
    9332:	bf 85       	ldd	r27, Y+15	; 0x0f
    9334:	8f 3f       	cpi	r24, 0xFF	; 255
    9336:	0f ef       	ldi	r16, 0xFF	; 255
    9338:	90 07       	cpc	r25, r16
    933a:	0f ef       	ldi	r16, 0xFF	; 255
    933c:	a0 07       	cpc	r26, r16
    933e:	0f ef       	ldi	r16, 0xFF	; 255
    9340:	b0 07       	cpc	r27, r16
    9342:	41 f5       	brne	.+80     	; 0x9394 <writeFile+0x768>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9344:	88 89       	ldd	r24, Y+16	; 0x10
    9346:	99 89       	ldd	r25, Y+17	; 0x11
    9348:	aa 89       	ldd	r26, Y+18	; 0x12
    934a:	bb 89       	ldd	r27, Y+19	; 0x13
    934c:	bc 01       	movw	r22, r24
    934e:	cd 01       	movw	r24, r26
    9350:	0e 94 e9 49 	call	0x93d2	; 0x93d2 <searchNextFreeCluster>
    9354:	dc 01       	movw	r26, r24
    9356:	cb 01       	movw	r24, r22
    9358:	8c 87       	std	Y+12, r24	; 0x0c
    935a:	9d 87       	std	Y+13, r25	; 0x0d
    935c:	ae 87       	std	Y+14, r26	; 0x0e
    935e:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    9360:	88 89       	ldd	r24, Y+16	; 0x10
    9362:	99 89       	ldd	r25, Y+17	; 0x11
    9364:	aa 89       	ldd	r26, Y+18	; 0x12
    9366:	bb 89       	ldd	r27, Y+19	; 0x13
    9368:	0c 85       	ldd	r16, Y+12	; 0x0c
    936a:	1d 85       	ldd	r17, Y+13	; 0x0d
    936c:	2e 85       	ldd	r18, Y+14	; 0x0e
    936e:	3f 85       	ldd	r19, Y+15	; 0x0f
    9370:	bc 01       	movw	r22, r24
    9372:	cd 01       	movw	r24, r26
    9374:	41 e0       	ldi	r20, 0x01	; 1
    9376:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    937a:	8c 85       	ldd	r24, Y+12	; 0x0c
    937c:	9d 85       	ldd	r25, Y+13	; 0x0d
    937e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9380:	bf 85       	ldd	r27, Y+15	; 0x0f
    9382:	bc 01       	movw	r22, r24
    9384:	cd 01       	movw	r24, r26
    9386:	41 e0       	ldi	r20, 0x01	; 1
    9388:	0f ef       	ldi	r16, 0xFF	; 255
    938a:	1f ef       	ldi	r17, 0xFF	; 255
    938c:	98 01       	movw	r18, r16
    938e:	0e 94 0c 41 	call	0x8218	; 0x8218 <getSetNextCluster>
    9392:	02 c0       	rjmp	.+4      	; 0x9398 <writeFile+0x76c>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    9394:	83 e0       	ldi	r24, 0x03	; 3
    9396:	13 c0       	rjmp	.+38     	; 0x93be <writeFile+0x792>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    9398:	8c 85       	ldd	r24, Y+12	; 0x0c
    939a:	9d 85       	ldd	r25, Y+13	; 0x0d
    939c:	ae 85       	ldd	r26, Y+14	; 0x0e
    939e:	bf 85       	ldd	r27, Y+15	; 0x0f
    93a0:	00 97       	sbiw	r24, 0x00	; 0
    93a2:	a1 05       	cpc	r26, r1
    93a4:	b1 05       	cpc	r27, r1
    93a6:	11 f4       	brne	.+4      	; 0x93ac <writeFile+0x780>
	   return 4;
    93a8:	84 e0       	ldi	r24, 0x04	; 4
    93aa:	09 c0       	rjmp	.+18     	; 0x93be <writeFile+0x792>
	}
   
   prevCluster = cluster;
    93ac:	8c 85       	ldd	r24, Y+12	; 0x0c
    93ae:	9d 85       	ldd	r25, Y+13	; 0x0d
    93b0:	ae 85       	ldd	r26, Y+14	; 0x0e
    93b2:	bf 85       	ldd	r27, Y+15	; 0x0f
    93b4:	88 8b       	std	Y+16, r24	; 0x10
    93b6:	99 8b       	std	Y+17, r25	; 0x11
    93b8:	aa 8b       	std	Y+18, r26	; 0x12
    93ba:	bb 8b       	std	Y+19, r27	; 0x13
 }
    93bc:	d1 ce       	rjmp	.-606    	; 0x9160 <writeFile+0x534>
 
 return 0;
}
    93be:	e7 96       	adiw	r28, 0x37	; 55
    93c0:	cd bf       	out	0x3d, r28	; 61
    93c2:	de bf       	out	0x3e, r29	; 62
    93c4:	df 91       	pop	r29
    93c6:	cf 91       	pop	r28
    93c8:	1f 91       	pop	r17
    93ca:	0f 91       	pop	r16
    93cc:	ff 90       	pop	r15
    93ce:	ef 90       	pop	r14
    93d0:	08 95       	ret

000093d2 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    93d2:	ef 92       	push	r14
    93d4:	ff 92       	push	r15
    93d6:	0f 93       	push	r16
    93d8:	1f 93       	push	r17
    93da:	cf 93       	push	r28
    93dc:	df 93       	push	r29
    93de:	cd b7       	in	r28, 0x3d	; 61
    93e0:	de b7       	in	r29, 0x3e	; 62
    93e2:	2f 97       	sbiw	r28, 0x0f	; 15
    93e4:	cd bf       	out	0x3d, r28	; 61
    93e6:	de bf       	out	0x3e, r29	; 62
    93e8:	6c 87       	std	Y+12, r22	; 0x0c
    93ea:	7d 87       	std	Y+13, r23	; 0x0d
    93ec:	8e 87       	std	Y+14, r24	; 0x0e
    93ee:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    93f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    93f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    93f4:	ae 85       	ldd	r26, Y+14	; 0x0e
    93f6:	bf 85       	ldd	r27, Y+15	; 0x0f
    93f8:	80 78       	andi	r24, 0x80	; 128
    93fa:	8c 87       	std	Y+12, r24	; 0x0c
    93fc:	9d 87       	std	Y+13, r25	; 0x0d
    93fe:	ae 87       	std	Y+14, r26	; 0x0e
    9400:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9402:	8c 85       	ldd	r24, Y+12	; 0x0c
    9404:	9d 85       	ldd	r25, Y+13	; 0x0d
    9406:	ae 85       	ldd	r26, Y+14	; 0x0e
    9408:	bf 85       	ldd	r27, Y+15	; 0x0f
    940a:	89 83       	std	Y+1, r24	; 0x01
    940c:	9a 83       	std	Y+2, r25	; 0x02
    940e:	ab 83       	std	Y+3, r26	; 0x03
    9410:	bc 83       	std	Y+4, r27	; 0x04
    9412:	7a c0       	rjmp	.+244    	; 0x9508 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9414:	80 91 82 50 	lds	r24, 0x5082
    9418:	90 91 83 50 	lds	r25, 0x5083
    941c:	9c 01       	movw	r18, r24
    941e:	40 e0       	ldi	r20, 0x00	; 0
    9420:	50 e0       	ldi	r21, 0x00	; 0
    9422:	80 91 7c 50 	lds	r24, 0x507C
    9426:	90 91 7d 50 	lds	r25, 0x507D
    942a:	a0 91 7e 50 	lds	r26, 0x507E
    942e:	b0 91 7f 50 	lds	r27, 0x507F
    9432:	79 01       	movw	r14, r18
    9434:	8a 01       	movw	r16, r20
    9436:	e8 0e       	add	r14, r24
    9438:	f9 1e       	adc	r15, r25
    943a:	0a 1f       	adc	r16, r26
    943c:	1b 1f       	adc	r17, r27
    943e:	89 81       	ldd	r24, Y+1	; 0x01
    9440:	9a 81       	ldd	r25, Y+2	; 0x02
    9442:	ab 81       	ldd	r26, Y+3	; 0x03
    9444:	bc 81       	ldd	r27, Y+4	; 0x04
    9446:	88 0f       	add	r24, r24
    9448:	99 1f       	adc	r25, r25
    944a:	aa 1f       	adc	r26, r26
    944c:	bb 1f       	adc	r27, r27
    944e:	88 0f       	add	r24, r24
    9450:	99 1f       	adc	r25, r25
    9452:	aa 1f       	adc	r26, r26
    9454:	bb 1f       	adc	r27, r27
    9456:	20 91 53 40 	lds	r18, 0x4053
    945a:	30 91 54 40 	lds	r19, 0x4054
    945e:	99 01       	movw	r18, r18
    9460:	40 e0       	ldi	r20, 0x00	; 0
    9462:	50 e0       	ldi	r21, 0x00	; 0
    9464:	bc 01       	movw	r22, r24
    9466:	cd 01       	movw	r24, r26
    9468:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    946c:	da 01       	movw	r26, r20
    946e:	c9 01       	movw	r24, r18
    9470:	8e 0d       	add	r24, r14
    9472:	9f 1d       	adc	r25, r15
    9474:	a0 1f       	adc	r26, r16
    9476:	b1 1f       	adc	r27, r17
    9478:	8e 83       	std	Y+6, r24	; 0x06
    947a:	9f 83       	std	Y+7, r25	; 0x07
    947c:	a8 87       	std	Y+8, r26	; 0x08
    947e:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    9480:	8e 81       	ldd	r24, Y+6	; 0x06
    9482:	9f 81       	ldd	r25, Y+7	; 0x07
    9484:	a8 85       	ldd	r26, Y+8	; 0x08
    9486:	b9 85       	ldd	r27, Y+9	; 0x09
    9488:	25 ed       	ldi	r18, 0xD5	; 213
    948a:	31 e2       	ldi	r19, 0x21	; 33
    948c:	bc 01       	movw	r22, r24
    948e:	cd 01       	movw	r24, r26
    9490:	a9 01       	movw	r20, r18
    9492:	0e 94 ef 4e 	call	0x9dde	; 0x9dde <SD_read_block>
      for(i=0; i<128; i++)
    9496:	1d 82       	std	Y+5, r1	; 0x05
    9498:	28 c0       	rjmp	.+80     	; 0x94ea <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    949a:	8d 81       	ldd	r24, Y+5	; 0x05
    949c:	88 2f       	mov	r24, r24
    949e:	90 e0       	ldi	r25, 0x00	; 0
    94a0:	88 0f       	add	r24, r24
    94a2:	99 1f       	adc	r25, r25
    94a4:	88 0f       	add	r24, r24
    94a6:	99 1f       	adc	r25, r25
    94a8:	8b 52       	subi	r24, 0x2B	; 43
    94aa:	9e 4d       	sbci	r25, 0xDE	; 222
    94ac:	8a 87       	std	Y+10, r24	; 0x0a
    94ae:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    94b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    94b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    94b4:	fc 01       	movw	r30, r24
    94b6:	80 81       	ld	r24, Z
    94b8:	91 81       	ldd	r25, Z+1	; 0x01
    94ba:	a2 81       	ldd	r26, Z+2	; 0x02
    94bc:	b3 81       	ldd	r27, Z+3	; 0x03
    94be:	bf 70       	andi	r27, 0x0F	; 15
    94c0:	00 97       	sbiw	r24, 0x00	; 0
    94c2:	a1 05       	cpc	r26, r1
    94c4:	b1 05       	cpc	r27, r1
    94c6:	71 f4       	brne	.+28     	; 0x94e4 <searchNextFreeCluster+0x112>
            return(cluster+i);
    94c8:	8d 81       	ldd	r24, Y+5	; 0x05
    94ca:	28 2f       	mov	r18, r24
    94cc:	30 e0       	ldi	r19, 0x00	; 0
    94ce:	40 e0       	ldi	r20, 0x00	; 0
    94d0:	50 e0       	ldi	r21, 0x00	; 0
    94d2:	89 81       	ldd	r24, Y+1	; 0x01
    94d4:	9a 81       	ldd	r25, Y+2	; 0x02
    94d6:	ab 81       	ldd	r26, Y+3	; 0x03
    94d8:	bc 81       	ldd	r27, Y+4	; 0x04
    94da:	82 0f       	add	r24, r18
    94dc:	93 1f       	adc	r25, r19
    94de:	a4 1f       	adc	r26, r20
    94e0:	b5 1f       	adc	r27, r21
    94e2:	27 c0       	rjmp	.+78     	; 0x9532 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    94e4:	8d 81       	ldd	r24, Y+5	; 0x05
    94e6:	8f 5f       	subi	r24, 0xFF	; 255
    94e8:	8d 83       	std	Y+5, r24	; 0x05
    94ea:	8d 81       	ldd	r24, Y+5	; 0x05
    94ec:	88 23       	and	r24, r24
    94ee:	ac f6       	brge	.-86     	; 0x949a <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    94f0:	89 81       	ldd	r24, Y+1	; 0x01
    94f2:	9a 81       	ldd	r25, Y+2	; 0x02
    94f4:	ab 81       	ldd	r26, Y+3	; 0x03
    94f6:	bc 81       	ldd	r27, Y+4	; 0x04
    94f8:	80 58       	subi	r24, 0x80	; 128
    94fa:	9f 4f       	sbci	r25, 0xFF	; 255
    94fc:	af 4f       	sbci	r26, 0xFF	; 255
    94fe:	bf 4f       	sbci	r27, 0xFF	; 255
    9500:	89 83       	std	Y+1, r24	; 0x01
    9502:	9a 83       	std	Y+2, r25	; 0x02
    9504:	ab 83       	std	Y+3, r26	; 0x03
    9506:	bc 83       	std	Y+4, r27	; 0x04
    9508:	80 91 58 40 	lds	r24, 0x4058
    950c:	90 91 59 40 	lds	r25, 0x4059
    9510:	a0 91 5a 40 	lds	r26, 0x405A
    9514:	b0 91 5b 40 	lds	r27, 0x405B
    9518:	29 81       	ldd	r18, Y+1	; 0x01
    951a:	3a 81       	ldd	r19, Y+2	; 0x02
    951c:	4b 81       	ldd	r20, Y+3	; 0x03
    951e:	5c 81       	ldd	r21, Y+4	; 0x04
    9520:	28 17       	cp	r18, r24
    9522:	39 07       	cpc	r19, r25
    9524:	4a 07       	cpc	r20, r26
    9526:	5b 07       	cpc	r21, r27
    9528:	08 f4       	brcc	.+2      	; 0x952c <searchNextFreeCluster+0x15a>
    952a:	74 cf       	rjmp	.-280    	; 0x9414 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    952c:	80 e0       	ldi	r24, 0x00	; 0
    952e:	90 e0       	ldi	r25, 0x00	; 0
    9530:	dc 01       	movw	r26, r24
}
    9532:	bc 01       	movw	r22, r24
    9534:	cd 01       	movw	r24, r26
    9536:	2f 96       	adiw	r28, 0x0f	; 15
    9538:	cd bf       	out	0x3d, r28	; 61
    953a:	de bf       	out	0x3e, r29	; 62
    953c:	df 91       	pop	r29
    953e:	cf 91       	pop	r28
    9540:	1f 91       	pop	r17
    9542:	0f 91       	pop	r16
    9544:	ff 90       	pop	r15
    9546:	ef 90       	pop	r14
    9548:	08 95       	ret

0000954a <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    954a:	cf 93       	push	r28
    954c:	df 93       	push	r29
    954e:	00 d0       	rcall	.+0      	; 0x9550 <deleteFile+0x6>
    9550:	cd b7       	in	r28, 0x3d	; 61
    9552:	de b7       	in	r29, 0x3e	; 62
    9554:	8a 83       	std	Y+2, r24	; 0x02
    9556:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9558:	8a 81       	ldd	r24, Y+2	; 0x02
    955a:	9b 81       	ldd	r25, Y+3	; 0x03
    955c:	0e 94 e0 44 	call	0x89c0	; 0x89c0 <convertFileName>
    9560:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9562:	89 81       	ldd	r24, Y+1	; 0x01
    9564:	88 23       	and	r24, r24
    9566:	39 f4       	brne	.+14     	; 0x9576 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9568:	2a eb       	ldi	r18, 0xBA	; 186
    956a:	30 e5       	ldi	r19, 0x50	; 80
    956c:	82 e0       	ldi	r24, 0x02	; 2
    956e:	b9 01       	movw	r22, r18
    9570:	0e 94 66 42 	call	0x84cc	; 0x84cc <findFiles>
    9574:	01 c0       	rjmp	.+2      	; 0x9578 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9576:	00 00       	nop

  findFiles (DELETE, Filename);
}
    9578:	23 96       	adiw	r28, 0x03	; 3
    957a:	cd bf       	out	0x3d, r28	; 61
    957c:	de bf       	out	0x3e, r29	; 62
    957e:	df 91       	pop	r29
    9580:	cf 91       	pop	r28
    9582:	08 95       	ret

00009584 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9584:	ef 92       	push	r14
    9586:	ff 92       	push	r15
    9588:	0f 93       	push	r16
    958a:	1f 93       	push	r17
    958c:	cf 93       	push	r28
    958e:	df 93       	push	r29
    9590:	cd b7       	in	r28, 0x3d	; 61
    9592:	de b7       	in	r29, 0x3e	; 62
    9594:	29 97       	sbiw	r28, 0x09	; 9
    9596:	cd bf       	out	0x3d, r28	; 61
    9598:	de bf       	out	0x3e, r29	; 62
    959a:	8d 83       	std	Y+5, r24	; 0x05
    959c:	4e 83       	std	Y+6, r20	; 0x06
    959e:	5f 83       	std	Y+7, r21	; 0x07
    95a0:	68 87       	std	Y+8, r22	; 0x08
    95a2:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    95a4:	8e 81       	ldd	r24, Y+6	; 0x06
    95a6:	9f 81       	ldd	r25, Y+7	; 0x07
    95a8:	a8 85       	ldd	r26, Y+8	; 0x08
    95aa:	b9 85       	ldd	r27, Y+9	; 0x09
    95ac:	91 70       	andi	r25, 0x01	; 1
    95ae:	a0 70       	andi	r26, 0x00	; 0
    95b0:	b0 70       	andi	r27, 0x00	; 0
    95b2:	00 97       	sbiw	r24, 0x00	; 0
    95b4:	a1 05       	cpc	r26, r1
    95b6:	b1 05       	cpc	r27, r1
    95b8:	91 f4       	brne	.+36     	; 0x95de <freeMemoryUpdate+0x5a>
    95ba:	8e 81       	ldd	r24, Y+6	; 0x06
    95bc:	9f 81       	ldd	r25, Y+7	; 0x07
    95be:	a8 85       	ldd	r26, Y+8	; 0x08
    95c0:	b9 85       	ldd	r27, Y+9	; 0x09
    95c2:	07 2e       	mov	r0, r23
    95c4:	79 e0       	ldi	r23, 0x09	; 9
    95c6:	b6 95       	lsr	r27
    95c8:	a7 95       	ror	r26
    95ca:	97 95       	ror	r25
    95cc:	87 95       	ror	r24
    95ce:	7a 95       	dec	r23
    95d0:	d1 f7       	brne	.-12     	; 0x95c6 <freeMemoryUpdate+0x42>
    95d2:	70 2d       	mov	r23, r0
    95d4:	8e 83       	std	Y+6, r24	; 0x06
    95d6:	9f 83       	std	Y+7, r25	; 0x07
    95d8:	a8 87       	std	Y+8, r26	; 0x08
    95da:	b9 87       	std	Y+9, r27	; 0x09
    95dc:	14 c0       	rjmp	.+40     	; 0x9606 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    95de:	8e 81       	ldd	r24, Y+6	; 0x06
    95e0:	9f 81       	ldd	r25, Y+7	; 0x07
    95e2:	a8 85       	ldd	r26, Y+8	; 0x08
    95e4:	b9 85       	ldd	r27, Y+9	; 0x09
    95e6:	07 2e       	mov	r0, r23
    95e8:	79 e0       	ldi	r23, 0x09	; 9
    95ea:	b6 95       	lsr	r27
    95ec:	a7 95       	ror	r26
    95ee:	97 95       	ror	r25
    95f0:	87 95       	ror	r24
    95f2:	7a 95       	dec	r23
    95f4:	d1 f7       	brne	.-12     	; 0x95ea <freeMemoryUpdate+0x66>
    95f6:	70 2d       	mov	r23, r0
    95f8:	01 96       	adiw	r24, 0x01	; 1
    95fa:	a1 1d       	adc	r26, r1
    95fc:	b1 1d       	adc	r27, r1
    95fe:	8e 83       	std	Y+6, r24	; 0x06
    9600:	9f 83       	std	Y+7, r25	; 0x07
    9602:	a8 87       	std	Y+8, r26	; 0x08
    9604:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9606:	8e 81       	ldd	r24, Y+6	; 0x06
    9608:	9f 81       	ldd	r25, Y+7	; 0x07
    960a:	a8 85       	ldd	r26, Y+8	; 0x08
    960c:	b9 85       	ldd	r27, Y+9	; 0x09
    960e:	87 70       	andi	r24, 0x07	; 7
    9610:	90 70       	andi	r25, 0x00	; 0
    9612:	a0 70       	andi	r26, 0x00	; 0
    9614:	b0 70       	andi	r27, 0x00	; 0
    9616:	00 97       	sbiw	r24, 0x00	; 0
    9618:	a1 05       	cpc	r26, r1
    961a:	b1 05       	cpc	r27, r1
    961c:	89 f4       	brne	.+34     	; 0x9640 <freeMemoryUpdate+0xbc>
    961e:	8e 81       	ldd	r24, Y+6	; 0x06
    9620:	9f 81       	ldd	r25, Y+7	; 0x07
    9622:	a8 85       	ldd	r26, Y+8	; 0x08
    9624:	b9 85       	ldd	r27, Y+9	; 0x09
    9626:	68 94       	set
    9628:	12 f8       	bld	r1, 2
    962a:	b6 95       	lsr	r27
    962c:	a7 95       	ror	r26
    962e:	97 95       	ror	r25
    9630:	87 95       	ror	r24
    9632:	16 94       	lsr	r1
    9634:	d1 f7       	brne	.-12     	; 0x962a <freeMemoryUpdate+0xa6>
    9636:	8e 83       	std	Y+6, r24	; 0x06
    9638:	9f 83       	std	Y+7, r25	; 0x07
    963a:	a8 87       	std	Y+8, r26	; 0x08
    963c:	b9 87       	std	Y+9, r27	; 0x09
    963e:	13 c0       	rjmp	.+38     	; 0x9666 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    9640:	8e 81       	ldd	r24, Y+6	; 0x06
    9642:	9f 81       	ldd	r25, Y+7	; 0x07
    9644:	a8 85       	ldd	r26, Y+8	; 0x08
    9646:	b9 85       	ldd	r27, Y+9	; 0x09
    9648:	68 94       	set
    964a:	12 f8       	bld	r1, 2
    964c:	b6 95       	lsr	r27
    964e:	a7 95       	ror	r26
    9650:	97 95       	ror	r25
    9652:	87 95       	ror	r24
    9654:	16 94       	lsr	r1
    9656:	d1 f7       	brne	.-12     	; 0x964c <freeMemoryUpdate+0xc8>
    9658:	01 96       	adiw	r24, 0x01	; 1
    965a:	a1 1d       	adc	r26, r1
    965c:	b1 1d       	adc	r27, r1
    965e:	8e 83       	std	Y+6, r24	; 0x06
    9660:	9f 83       	std	Y+7, r25	; 0x07
    9662:	a8 87       	std	Y+8, r26	; 0x08
    9664:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9666:	80 91 ce 50 	lds	r24, 0x50CE
    966a:	88 23       	and	r24, r24
    966c:	e9 f1       	breq	.+122    	; 0x96e8 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    966e:	81 e0       	ldi	r24, 0x01	; 1
    9670:	60 e0       	ldi	r22, 0x00	; 0
    9672:	20 e0       	ldi	r18, 0x00	; 0
    9674:	30 e0       	ldi	r19, 0x00	; 0
    9676:	a9 01       	movw	r20, r18
    9678:	0e 94 b5 41 	call	0x836a	; 0x836a <getSetFreeCluster>
    967c:	dc 01       	movw	r26, r24
    967e:	cb 01       	movw	r24, r22
    9680:	89 83       	std	Y+1, r24	; 0x01
    9682:	9a 83       	std	Y+2, r25	; 0x02
    9684:	ab 83       	std	Y+3, r26	; 0x03
    9686:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9688:	8d 81       	ldd	r24, Y+5	; 0x05
    968a:	88 23       	and	r24, r24
    968c:	89 f4       	brne	.+34     	; 0x96b0 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    968e:	29 81       	ldd	r18, Y+1	; 0x01
    9690:	3a 81       	ldd	r19, Y+2	; 0x02
    9692:	4b 81       	ldd	r20, Y+3	; 0x03
    9694:	5c 81       	ldd	r21, Y+4	; 0x04
    9696:	8e 81       	ldd	r24, Y+6	; 0x06
    9698:	9f 81       	ldd	r25, Y+7	; 0x07
    969a:	a8 85       	ldd	r26, Y+8	; 0x08
    969c:	b9 85       	ldd	r27, Y+9	; 0x09
    969e:	82 0f       	add	r24, r18
    96a0:	93 1f       	adc	r25, r19
    96a2:	a4 1f       	adc	r26, r20
    96a4:	b5 1f       	adc	r27, r21
    96a6:	89 83       	std	Y+1, r24	; 0x01
    96a8:	9a 83       	std	Y+2, r25	; 0x02
    96aa:	ab 83       	std	Y+3, r26	; 0x03
    96ac:	bc 83       	std	Y+4, r27	; 0x04
    96ae:	14 c0       	rjmp	.+40     	; 0x96d8 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    96b0:	29 81       	ldd	r18, Y+1	; 0x01
    96b2:	3a 81       	ldd	r19, Y+2	; 0x02
    96b4:	4b 81       	ldd	r20, Y+3	; 0x03
    96b6:	5c 81       	ldd	r21, Y+4	; 0x04
    96b8:	8e 81       	ldd	r24, Y+6	; 0x06
    96ba:	9f 81       	ldd	r25, Y+7	; 0x07
    96bc:	a8 85       	ldd	r26, Y+8	; 0x08
    96be:	b9 85       	ldd	r27, Y+9	; 0x09
    96c0:	79 01       	movw	r14, r18
    96c2:	8a 01       	movw	r16, r20
    96c4:	e8 1a       	sub	r14, r24
    96c6:	f9 0a       	sbc	r15, r25
    96c8:	0a 0b       	sbc	r16, r26
    96ca:	1b 0b       	sbc	r17, r27
    96cc:	d8 01       	movw	r26, r16
    96ce:	c7 01       	movw	r24, r14
    96d0:	89 83       	std	Y+1, r24	; 0x01
    96d2:	9a 83       	std	Y+2, r25	; 0x02
    96d4:	ab 83       	std	Y+3, r26	; 0x03
    96d6:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    96d8:	29 81       	ldd	r18, Y+1	; 0x01
    96da:	3a 81       	ldd	r19, Y+2	; 0x02
    96dc:	4b 81       	ldd	r20, Y+3	; 0x03
    96de:	5c 81       	ldd	r21, Y+4	; 0x04
    96e0:	81 e0       	ldi	r24, 0x01	; 1
    96e2:	61 e0       	ldi	r22, 0x01	; 1
    96e4:	0e 94 b5 41 	call	0x836a	; 0x836a <getSetFreeCluster>
  }
}
    96e8:	29 96       	adiw	r28, 0x09	; 9
    96ea:	cd bf       	out	0x3d, r28	; 61
    96ec:	de bf       	out	0x3e, r29	; 62
    96ee:	df 91       	pop	r29
    96f0:	cf 91       	pop	r28
    96f2:	1f 91       	pop	r17
    96f4:	0f 91       	pop	r16
    96f6:	ff 90       	pop	r15
    96f8:	ef 90       	pop	r14
    96fa:	08 95       	ret

000096fc <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    96fc:	0f 93       	push	r16
    96fe:	1f 93       	push	r17
    9700:	cf 93       	push	r28
    9702:	df 93       	push	r29
    9704:	cd b7       	in	r28, 0x3d	; 61
    9706:	de b7       	in	r29, 0x3e	; 62
    9708:	a9 97       	sbiw	r28, 0x29	; 41
    970a:	cd bf       	out	0x3d, r28	; 61
    970c:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    970e:	81 e0       	ldi	r24, 0x01	; 1
    9710:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9714:	81 e0       	ldi	r24, 0x01	; 1
    9716:	0e 94 9d 34 	call	0x693a	; 0x693a <Ext1Power>
    971a:	80 e0       	ldi	r24, 0x00	; 0
    971c:	90 e0       	ldi	r25, 0x00	; 0
    971e:	a8 ec       	ldi	r26, 0xC8	; 200
    9720:	b2 e4       	ldi	r27, 0x42	; 66
    9722:	8e 87       	std	Y+14, r24	; 0x0e
    9724:	9f 87       	std	Y+15, r25	; 0x0f
    9726:	a8 8b       	std	Y+16, r26	; 0x10
    9728:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    972a:	6e 85       	ldd	r22, Y+14	; 0x0e
    972c:	7f 85       	ldd	r23, Y+15	; 0x0f
    972e:	88 89       	ldd	r24, Y+16	; 0x10
    9730:	99 89       	ldd	r25, Y+17	; 0x11
    9732:	20 e0       	ldi	r18, 0x00	; 0
    9734:	30 e0       	ldi	r19, 0x00	; 0
    9736:	4a ef       	ldi	r20, 0xFA	; 250
    9738:	55 e4       	ldi	r21, 0x45	; 69
    973a:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    973e:	dc 01       	movw	r26, r24
    9740:	cb 01       	movw	r24, r22
    9742:	8a 8b       	std	Y+18, r24	; 0x12
    9744:	9b 8b       	std	Y+19, r25	; 0x13
    9746:	ac 8b       	std	Y+20, r26	; 0x14
    9748:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    974a:	11 e0       	ldi	r17, 0x01	; 1
    974c:	6a 89       	ldd	r22, Y+18	; 0x12
    974e:	7b 89       	ldd	r23, Y+19	; 0x13
    9750:	8c 89       	ldd	r24, Y+20	; 0x14
    9752:	9d 89       	ldd	r25, Y+21	; 0x15
    9754:	20 e0       	ldi	r18, 0x00	; 0
    9756:	30 e0       	ldi	r19, 0x00	; 0
    9758:	40 e8       	ldi	r20, 0x80	; 128
    975a:	5f e3       	ldi	r21, 0x3F	; 63
    975c:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    9760:	88 23       	and	r24, r24
    9762:	0c f0       	brlt	.+2      	; 0x9766 <SD_init+0x6a>
    9764:	10 e0       	ldi	r17, 0x00	; 0
    9766:	11 23       	and	r17, r17
    9768:	29 f0       	breq	.+10     	; 0x9774 <SD_init+0x78>
		__ticks = 1;
    976a:	81 e0       	ldi	r24, 0x01	; 1
    976c:	90 e0       	ldi	r25, 0x00	; 0
    976e:	8e 8b       	std	Y+22, r24	; 0x16
    9770:	9f 8b       	std	Y+23, r25	; 0x17
    9772:	46 c0       	rjmp	.+140    	; 0x9800 <SD_init+0x104>
	else if (__tmp > 65535)
    9774:	11 e0       	ldi	r17, 0x01	; 1
    9776:	6a 89       	ldd	r22, Y+18	; 0x12
    9778:	7b 89       	ldd	r23, Y+19	; 0x13
    977a:	8c 89       	ldd	r24, Y+20	; 0x14
    977c:	9d 89       	ldd	r25, Y+21	; 0x15
    977e:	20 e0       	ldi	r18, 0x00	; 0
    9780:	3f ef       	ldi	r19, 0xFF	; 255
    9782:	4f e7       	ldi	r20, 0x7F	; 127
    9784:	57 e4       	ldi	r21, 0x47	; 71
    9786:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    978a:	18 16       	cp	r1, r24
    978c:	0c f0       	brlt	.+2      	; 0x9790 <SD_init+0x94>
    978e:	10 e0       	ldi	r17, 0x00	; 0
    9790:	11 23       	and	r17, r17
    9792:	61 f1       	breq	.+88     	; 0x97ec <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9794:	6e 85       	ldd	r22, Y+14	; 0x0e
    9796:	7f 85       	ldd	r23, Y+15	; 0x0f
    9798:	88 89       	ldd	r24, Y+16	; 0x10
    979a:	99 89       	ldd	r25, Y+17	; 0x11
    979c:	20 e0       	ldi	r18, 0x00	; 0
    979e:	30 e0       	ldi	r19, 0x00	; 0
    97a0:	40 e2       	ldi	r20, 0x20	; 32
    97a2:	51 e4       	ldi	r21, 0x41	; 65
    97a4:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    97a8:	dc 01       	movw	r26, r24
    97aa:	cb 01       	movw	r24, r22
    97ac:	bc 01       	movw	r22, r24
    97ae:	cd 01       	movw	r24, r26
    97b0:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    97b4:	dc 01       	movw	r26, r24
    97b6:	cb 01       	movw	r24, r22
    97b8:	8e 8b       	std	Y+22, r24	; 0x16
    97ba:	9f 8b       	std	Y+23, r25	; 0x17
    97bc:	12 c0       	rjmp	.+36     	; 0x97e2 <SD_init+0xe6>
    97be:	80 e2       	ldi	r24, 0x20	; 32
    97c0:	93 e0       	ldi	r25, 0x03	; 3
    97c2:	88 8f       	std	Y+24, r24	; 0x18
    97c4:	99 8f       	std	Y+25, r25	; 0x19
    97c6:	88 8d       	ldd	r24, Y+24	; 0x18
    97c8:	99 8d       	ldd	r25, Y+25	; 0x19
    97ca:	8c 01       	movw	r16, r24
    97cc:	c8 01       	movw	r24, r16
    97ce:	01 97       	sbiw	r24, 0x01	; 1
    97d0:	f1 f7       	brne	.-4      	; 0x97ce <SD_init+0xd2>
    97d2:	8c 01       	movw	r16, r24
    97d4:	08 8f       	std	Y+24, r16	; 0x18
    97d6:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    97d8:	8e 89       	ldd	r24, Y+22	; 0x16
    97da:	9f 89       	ldd	r25, Y+23	; 0x17
    97dc:	01 97       	sbiw	r24, 0x01	; 1
    97de:	8e 8b       	std	Y+22, r24	; 0x16
    97e0:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    97e2:	8e 89       	ldd	r24, Y+22	; 0x16
    97e4:	9f 89       	ldd	r25, Y+23	; 0x17
    97e6:	00 97       	sbiw	r24, 0x00	; 0
    97e8:	51 f7       	brne	.-44     	; 0x97be <SD_init+0xc2>
    97ea:	17 c0       	rjmp	.+46     	; 0x981a <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    97ec:	6a 89       	ldd	r22, Y+18	; 0x12
    97ee:	7b 89       	ldd	r23, Y+19	; 0x13
    97f0:	8c 89       	ldd	r24, Y+20	; 0x14
    97f2:	9d 89       	ldd	r25, Y+21	; 0x15
    97f4:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    97f8:	dc 01       	movw	r26, r24
    97fa:	cb 01       	movw	r24, r22
    97fc:	8e 8b       	std	Y+22, r24	; 0x16
    97fe:	9f 8b       	std	Y+23, r25	; 0x17
    9800:	8e 89       	ldd	r24, Y+22	; 0x16
    9802:	9f 89       	ldd	r25, Y+23	; 0x17
    9804:	8a 8f       	std	Y+26, r24	; 0x1a
    9806:	9b 8f       	std	Y+27, r25	; 0x1b
    9808:	8a 8d       	ldd	r24, Y+26	; 0x1a
    980a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    980c:	8c 01       	movw	r16, r24
    980e:	f8 01       	movw	r30, r16
    9810:	31 97       	sbiw	r30, 0x01	; 1
    9812:	f1 f7       	brne	.-4      	; 0x9810 <SD_init+0x114>
    9814:	8f 01       	movw	r16, r30
    9816:	0a 8f       	std	Y+26, r16	; 0x1a
    9818:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    981a:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    981c:	88 e0       	ldi	r24, 0x08	; 8
    981e:	60 e0       	ldi	r22, 0x00	; 0
    9820:	0e 94 07 33 	call	0x660e	; 0x660e <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9824:	88 e0       	ldi	r24, 0x08	; 8
    9826:	60 e0       	ldi	r22, 0x00	; 0
    9828:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    982c:	80 e0       	ldi	r24, 0x00	; 0
    982e:	63 e0       	ldi	r22, 0x03	; 3
    9830:	0e 94 cb 37 	call	0x6f96	; 0x6f96 <SPIInit2>
	SPICS(TRUE);
    9834:	81 e0       	ldi	r24, 0x01	; 1
    9836:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    983a:	1a 82       	std	Y+2, r1	; 0x02
    983c:	1b 82       	std	Y+3, r1	; 0x03
    983e:	17 c0       	rjmp	.+46     	; 0x986e <SD_init+0x172>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9840:	80 ec       	ldi	r24, 0xC0	; 192
    9842:	98 e0       	ldi	r25, 0x08	; 8
    9844:	2f ef       	ldi	r18, 0xFF	; 255
    9846:	fc 01       	movw	r30, r24
    9848:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    984a:	00 00       	nop
    984c:	80 ec       	ldi	r24, 0xC0	; 192
    984e:	98 e0       	ldi	r25, 0x08	; 8
    9850:	fc 01       	movw	r30, r24
    9852:	82 81       	ldd	r24, Z+2	; 0x02
    9854:	88 23       	and	r24, r24
    9856:	d4 f7       	brge	.-12     	; 0x984c <SD_init+0x150>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    9858:	80 ec       	ldi	r24, 0xC0	; 192
    985a:	98 e0       	ldi	r25, 0x08	; 8
    985c:	fc 01       	movw	r30, r24
    985e:	83 81       	ldd	r24, Z+3	; 0x03
    9860:	80 93 b9 50 	sts	0x50B9, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9864:	8a 81       	ldd	r24, Y+2	; 0x02
    9866:	9b 81       	ldd	r25, Y+3	; 0x03
    9868:	01 96       	adiw	r24, 0x01	; 1
    986a:	8a 83       	std	Y+2, r24	; 0x02
    986c:	9b 83       	std	Y+3, r25	; 0x03
    986e:	8a 81       	ldd	r24, Y+2	; 0x02
    9870:	9b 81       	ldd	r25, Y+3	; 0x03
    9872:	8a 30       	cpi	r24, 0x0A	; 10
    9874:	91 05       	cpc	r25, r1
    9876:	24 f3       	brlt	.-56     	; 0x9840 <SD_init+0x144>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    9878:	80 e0       	ldi	r24, 0x00	; 0
    987a:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    987e:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9882:	88 e0       	ldi	r24, 0x08	; 8
    9884:	60 e0       	ldi	r22, 0x00	; 0
    9886:	0e 94 36 34 	call	0x686c	; 0x686c <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    988a:	80 e0       	ldi	r24, 0x00	; 0
    988c:	63 e0       	ldi	r22, 0x03	; 3
    988e:	0e 94 cb 37 	call	0x6f96	; 0x6f96 <SPIInit2>
	SPICS(TRUE);
    9892:	81 e0       	ldi	r24, 0x01	; 1
    9894:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9898:	1c 82       	std	Y+4, r1	; 0x04
    989a:	1d 82       	std	Y+5, r1	; 0x05
    989c:	0d c0       	rjmp	.+26     	; 0x98b8 <SD_init+0x1bc>
		if (i >= 10) {												//try command 10 times before timing out
    989e:	8c 81       	ldd	r24, Y+4	; 0x04
    98a0:	9d 81       	ldd	r25, Y+5	; 0x05
    98a2:	8a 30       	cpi	r24, 0x0A	; 10
    98a4:	91 05       	cpc	r25, r1
    98a6:	1c f0       	brlt	.+6      	; 0x98ae <SD_init+0x1b2>
			//there was no response to the first command
			errorCode = 1;
    98a8:	81 e0       	ldi	r24, 0x01	; 1
    98aa:	89 83       	std	Y+1, r24	; 0x01
			break;
    98ac:	10 c0       	rjmp	.+32     	; 0x98ce <SD_init+0x1d2>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    98ae:	8c 81       	ldd	r24, Y+4	; 0x04
    98b0:	9d 81       	ldd	r25, Y+5	; 0x05
    98b2:	01 96       	adiw	r24, 0x01	; 1
    98b4:	8c 83       	std	Y+4, r24	; 0x04
    98b6:	9d 83       	std	Y+5, r25	; 0x05
    98b8:	80 e0       	ldi	r24, 0x00	; 0
    98ba:	40 e0       	ldi	r20, 0x00	; 0
    98bc:	50 e0       	ldi	r21, 0x00	; 0
    98be:	ba 01       	movw	r22, r20
    98c0:	25 e9       	ldi	r18, 0x95	; 149
    98c2:	08 e0       	ldi	r16, 0x08	; 8
    98c4:	10 e0       	ldi	r17, 0x00	; 0
    98c6:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
    98ca:	81 30       	cpi	r24, 0x01	; 1
    98cc:	41 f7       	brne	.-48     	; 0x989e <SD_init+0x1a2>
    98ce:	80 e0       	ldi	r24, 0x00	; 0
    98d0:	90 e0       	ldi	r25, 0x00	; 0
    98d2:	a8 ec       	ldi	r26, 0xC8	; 200
    98d4:	b2 e4       	ldi	r27, 0x42	; 66
    98d6:	8c 8f       	std	Y+28, r24	; 0x1c
    98d8:	9d 8f       	std	Y+29, r25	; 0x1d
    98da:	ae 8f       	std	Y+30, r26	; 0x1e
    98dc:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    98de:	6c 8d       	ldd	r22, Y+28	; 0x1c
    98e0:	7d 8d       	ldd	r23, Y+29	; 0x1d
    98e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    98e4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    98e6:	20 e0       	ldi	r18, 0x00	; 0
    98e8:	30 e0       	ldi	r19, 0x00	; 0
    98ea:	4a ef       	ldi	r20, 0xFA	; 250
    98ec:	55 e4       	ldi	r21, 0x45	; 69
    98ee:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    98f2:	dc 01       	movw	r26, r24
    98f4:	cb 01       	movw	r24, r22
    98f6:	88 a3       	lds	r24, 0x58
    98f8:	99 a3       	lds	r25, 0x59
    98fa:	aa a3       	lds	r26, 0x5a
    98fc:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    98fe:	11 e0       	ldi	r17, 0x01	; 1
    9900:	68 a1       	lds	r22, 0x48
    9902:	79 a1       	lds	r23, 0x49
    9904:	8a a1       	lds	r24, 0x4a
    9906:	9b a1       	lds	r25, 0x4b
    9908:	20 e0       	ldi	r18, 0x00	; 0
    990a:	30 e0       	ldi	r19, 0x00	; 0
    990c:	40 e8       	ldi	r20, 0x80	; 128
    990e:	5f e3       	ldi	r21, 0x3F	; 63
    9910:	0e 94 f9 5a 	call	0xb5f2	; 0xb5f2 <__cmpsf2>
    9914:	88 23       	and	r24, r24
    9916:	0c f0       	brlt	.+2      	; 0x991a <SD_init+0x21e>
    9918:	10 e0       	ldi	r17, 0x00	; 0
    991a:	11 23       	and	r17, r17
    991c:	29 f0       	breq	.+10     	; 0x9928 <SD_init+0x22c>
		__ticks = 1;
    991e:	81 e0       	ldi	r24, 0x01	; 1
    9920:	90 e0       	ldi	r25, 0x00	; 0
    9922:	8c a3       	lds	r24, 0x5c
    9924:	9d a3       	lds	r25, 0x5d
    9926:	46 c0       	rjmp	.+140    	; 0x99b4 <SD_init+0x2b8>
	else if (__tmp > 65535)
    9928:	11 e0       	ldi	r17, 0x01	; 1
    992a:	68 a1       	lds	r22, 0x48
    992c:	79 a1       	lds	r23, 0x49
    992e:	8a a1       	lds	r24, 0x4a
    9930:	9b a1       	lds	r25, 0x4b
    9932:	20 e0       	ldi	r18, 0x00	; 0
    9934:	3f ef       	ldi	r19, 0xFF	; 255
    9936:	4f e7       	ldi	r20, 0x7F	; 127
    9938:	57 e4       	ldi	r21, 0x47	; 71
    993a:	0e 94 43 5c 	call	0xb886	; 0xb886 <__gesf2>
    993e:	18 16       	cp	r1, r24
    9940:	0c f0       	brlt	.+2      	; 0x9944 <SD_init+0x248>
    9942:	10 e0       	ldi	r17, 0x00	; 0
    9944:	11 23       	and	r17, r17
    9946:	61 f1       	breq	.+88     	; 0x99a0 <SD_init+0x2a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9948:	6c 8d       	ldd	r22, Y+28	; 0x1c
    994a:	7d 8d       	ldd	r23, Y+29	; 0x1d
    994c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    994e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9950:	20 e0       	ldi	r18, 0x00	; 0
    9952:	30 e0       	ldi	r19, 0x00	; 0
    9954:	40 e2       	ldi	r20, 0x20	; 32
    9956:	51 e4       	ldi	r21, 0x41	; 65
    9958:	0e 94 47 5c 	call	0xb88e	; 0xb88e <__mulsf3>
    995c:	dc 01       	movw	r26, r24
    995e:	cb 01       	movw	r24, r22
    9960:	bc 01       	movw	r22, r24
    9962:	cd 01       	movw	r24, r26
    9964:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    9968:	dc 01       	movw	r26, r24
    996a:	cb 01       	movw	r24, r22
    996c:	8c a3       	lds	r24, 0x5c
    996e:	9d a3       	lds	r25, 0x5d
    9970:	12 c0       	rjmp	.+36     	; 0x9996 <SD_init+0x29a>
    9972:	80 e2       	ldi	r24, 0x20	; 32
    9974:	93 e0       	ldi	r25, 0x03	; 3
    9976:	8e a3       	lds	r24, 0x5e
    9978:	9f a3       	lds	r25, 0x5f
    997a:	8e a1       	lds	r24, 0x4e
    997c:	9f a1       	lds	r25, 0x4f
    997e:	8c 01       	movw	r16, r24
    9980:	c8 01       	movw	r24, r16
    9982:	01 97       	sbiw	r24, 0x01	; 1
    9984:	f1 f7       	brne	.-4      	; 0x9982 <SD_init+0x286>
    9986:	8c 01       	movw	r16, r24
    9988:	0e a3       	lds	r16, 0x5e
    998a:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    998c:	8c a1       	lds	r24, 0x4c
    998e:	9d a1       	lds	r25, 0x4d
    9990:	01 97       	sbiw	r24, 0x01	; 1
    9992:	8c a3       	lds	r24, 0x5c
    9994:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9996:	8c a1       	lds	r24, 0x4c
    9998:	9d a1       	lds	r25, 0x4d
    999a:	00 97       	sbiw	r24, 0x00	; 0
    999c:	51 f7       	brne	.-44     	; 0x9972 <SD_init+0x276>
    999e:	17 c0       	rjmp	.+46     	; 0x99ce <SD_init+0x2d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    99a0:	68 a1       	lds	r22, 0x48
    99a2:	79 a1       	lds	r23, 0x49
    99a4:	8a a1       	lds	r24, 0x4a
    99a6:	9b a1       	lds	r25, 0x4b
    99a8:	0e 94 65 5b 	call	0xb6ca	; 0xb6ca <__fixunssfsi>
    99ac:	dc 01       	movw	r26, r24
    99ae:	cb 01       	movw	r24, r22
    99b0:	8c a3       	lds	r24, 0x5c
    99b2:	9d a3       	lds	r25, 0x5d
    99b4:	8c a1       	lds	r24, 0x4c
    99b6:	9d a1       	lds	r25, 0x4d
    99b8:	88 a7       	lds	r24, 0x78
    99ba:	99 a7       	lds	r25, 0x79
    99bc:	88 a5       	lds	r24, 0x68
    99be:	99 a5       	lds	r25, 0x69
    99c0:	8c 01       	movw	r16, r24
    99c2:	f8 01       	movw	r30, r16
    99c4:	31 97       	sbiw	r30, 0x01	; 1
    99c6:	f1 f7       	brne	.-4      	; 0x99c4 <SD_init+0x2c8>
    99c8:	8f 01       	movw	r16, r30
    99ca:	08 a7       	lds	r16, 0x78
    99cc:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    99ce:	1e 82       	std	Y+6, r1	; 0x06
    99d0:	1f 82       	std	Y+7, r1	; 0x07
    99d2:	0d c0       	rjmp	.+26     	; 0x99ee <SD_init+0x2f2>
		if (i >= 10) {
    99d4:	8e 81       	ldd	r24, Y+6	; 0x06
    99d6:	9f 81       	ldd	r25, Y+7	; 0x07
    99d8:	8a 30       	cpi	r24, 0x0A	; 10
    99da:	91 05       	cpc	r25, r1
    99dc:	1c f0       	brlt	.+6      	; 0x99e4 <SD_init+0x2e8>
			//there was no response to the command
			errorCode = 1;
    99de:	81 e0       	ldi	r24, 0x01	; 1
    99e0:	89 83       	std	Y+1, r24	; 0x01
			break;
    99e2:	11 c0       	rjmp	.+34     	; 0x9a06 <SD_init+0x30a>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    99e4:	8e 81       	ldd	r24, Y+6	; 0x06
    99e6:	9f 81       	ldd	r25, Y+7	; 0x07
    99e8:	01 96       	adiw	r24, 0x01	; 1
    99ea:	8e 83       	std	Y+6, r24	; 0x06
    99ec:	9f 83       	std	Y+7, r25	; 0x07
    99ee:	88 e0       	ldi	r24, 0x08	; 8
    99f0:	4a ea       	ldi	r20, 0xAA	; 170
    99f2:	51 e0       	ldi	r21, 0x01	; 1
    99f4:	60 e0       	ldi	r22, 0x00	; 0
    99f6:	70 e0       	ldi	r23, 0x00	; 0
    99f8:	27 e8       	ldi	r18, 0x87	; 135
    99fa:	08 e0       	ldi	r16, 0x08	; 8
    99fc:	10 e0       	ldi	r17, 0x00	; 0
    99fe:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
    9a02:	81 30       	cpi	r24, 0x01	; 1
    9a04:	39 f7       	brne	.-50     	; 0x99d4 <SD_init+0x2d8>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9a06:	18 86       	std	Y+8, r1	; 0x08
    9a08:	19 86       	std	Y+9, r1	; 0x09
    9a0a:	13 c0       	rjmp	.+38     	; 0x9a32 <SD_init+0x336>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9a0c:	88 85       	ldd	r24, Y+8	; 0x08
    9a0e:	99 85       	ldd	r25, Y+9	; 0x09
    9a10:	8c 01       	movw	r16, r24
    9a12:	0e 5f       	subi	r16, 0xFE	; 254
    9a14:	1f 4f       	sbci	r17, 0xFF	; 255
    9a16:	8f ef       	ldi	r24, 0xFF	; 255
    9a18:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9a1c:	28 2f       	mov	r18, r24
    9a1e:	c8 01       	movw	r24, r16
    9a20:	83 55       	subi	r24, 0x53	; 83
    9a22:	9f 4a       	sbci	r25, 0xAF	; 175
    9a24:	fc 01       	movw	r30, r24
    9a26:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9a28:	88 85       	ldd	r24, Y+8	; 0x08
    9a2a:	99 85       	ldd	r25, Y+9	; 0x09
    9a2c:	01 96       	adiw	r24, 0x01	; 1
    9a2e:	88 87       	std	Y+8, r24	; 0x08
    9a30:	99 87       	std	Y+9, r25	; 0x09
    9a32:	88 85       	ldd	r24, Y+8	; 0x08
    9a34:	99 85       	ldd	r25, Y+9	; 0x09
    9a36:	84 30       	cpi	r24, 0x04	; 4
    9a38:	91 05       	cpc	r25, r1
    9a3a:	44 f3       	brlt	.-48     	; 0x9a0c <SD_init+0x310>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9a3c:	80 91 b1 50 	lds	r24, 0x50B1
    9a40:	81 30       	cpi	r24, 0x01	; 1
    9a42:	21 f4       	brne	.+8      	; 0x9a4c <SD_init+0x350>
    9a44:	80 91 b2 50 	lds	r24, 0x50B2
    9a48:	8a 3a       	cpi	r24, 0xAA	; 170
    9a4a:	11 f0       	breq	.+4      	; 0x9a50 <SD_init+0x354>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9a4c:	81 e0       	ldi	r24, 0x01	; 1
    9a4e:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9a50:	87 e3       	ldi	r24, 0x37	; 55
    9a52:	40 e0       	ldi	r20, 0x00	; 0
    9a54:	50 e0       	ldi	r21, 0x00	; 0
    9a56:	ba 01       	movw	r22, r20
    9a58:	2f ef       	ldi	r18, 0xFF	; 255
    9a5a:	08 e0       	ldi	r16, 0x08	; 8
    9a5c:	10 e0       	ldi	r17, 0x00	; 0
    9a5e:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9a62:	81 e0       	ldi	r24, 0x01	; 1
    9a64:	40 e0       	ldi	r20, 0x00	; 0
    9a66:	50 e0       	ldi	r21, 0x00	; 0
    9a68:	60 e0       	ldi	r22, 0x00	; 0
    9a6a:	70 e4       	ldi	r23, 0x40	; 64
    9a6c:	2f ef       	ldi	r18, 0xFF	; 255
    9a6e:	08 e0       	ldi	r16, 0x08	; 8
    9a70:	10 e0       	ldi	r17, 0x00	; 0
    9a72:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
	} while(Buffer[1]!= 0x00);
    9a76:	80 91 ae 50 	lds	r24, 0x50AE
    9a7a:	88 23       	and	r24, r24
    9a7c:	49 f7       	brne	.-46     	; 0x9a50 <SD_init+0x354>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9a7e:	1a 86       	std	Y+10, r1	; 0x0a
    9a80:	1b 86       	std	Y+11, r1	; 0x0b
    9a82:	0d c0       	rjmp	.+26     	; 0x9a9e <SD_init+0x3a2>
		if (i >= 10) {
    9a84:	8a 85       	ldd	r24, Y+10	; 0x0a
    9a86:	9b 85       	ldd	r25, Y+11	; 0x0b
    9a88:	8a 30       	cpi	r24, 0x0A	; 10
    9a8a:	91 05       	cpc	r25, r1
    9a8c:	1c f0       	brlt	.+6      	; 0x9a94 <SD_init+0x398>
			//there was no response to the command
			errorCode = 1;
    9a8e:	81 e0       	ldi	r24, 0x01	; 1
    9a90:	89 83       	std	Y+1, r24	; 0x01
			break;
    9a92:	10 c0       	rjmp	.+32     	; 0x9ab4 <SD_init+0x3b8>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9a94:	8a 85       	ldd	r24, Y+10	; 0x0a
    9a96:	9b 85       	ldd	r25, Y+11	; 0x0b
    9a98:	01 96       	adiw	r24, 0x01	; 1
    9a9a:	8a 87       	std	Y+10, r24	; 0x0a
    9a9c:	9b 87       	std	Y+11, r25	; 0x0b
    9a9e:	8a e3       	ldi	r24, 0x3A	; 58
    9aa0:	40 e0       	ldi	r20, 0x00	; 0
    9aa2:	50 e0       	ldi	r21, 0x00	; 0
    9aa4:	ba 01       	movw	r22, r20
    9aa6:	2f ef       	ldi	r18, 0xFF	; 255
    9aa8:	08 e0       	ldi	r16, 0x08	; 8
    9aaa:	10 e0       	ldi	r17, 0x00	; 0
    9aac:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
    9ab0:	88 23       	and	r24, r24
    9ab2:	41 f7       	brne	.-48     	; 0x9a84 <SD_init+0x388>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9ab4:	1c 86       	std	Y+12, r1	; 0x0c
    9ab6:	1d 86       	std	Y+13, r1	; 0x0d
    9ab8:	0f c0       	rjmp	.+30     	; 0x9ad8 <SD_init+0x3dc>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9aba:	8f ef       	ldi	r24, 0xFF	; 255
    9abc:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9ac0:	28 2f       	mov	r18, r24
    9ac2:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ac4:	9d 85       	ldd	r25, Y+13	; 0x0d
    9ac6:	83 55       	subi	r24, 0x53	; 83
    9ac8:	9f 4a       	sbci	r25, 0xAF	; 175
    9aca:	fc 01       	movw	r30, r24
    9acc:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9ace:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ad0:	9d 85       	ldd	r25, Y+13	; 0x0d
    9ad2:	01 96       	adiw	r24, 0x01	; 1
    9ad4:	8c 87       	std	Y+12, r24	; 0x0c
    9ad6:	9d 87       	std	Y+13, r25	; 0x0d
    9ad8:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ada:	9d 85       	ldd	r25, Y+13	; 0x0d
    9adc:	84 30       	cpi	r24, 0x04	; 4
    9ade:	91 05       	cpc	r25, r1
    9ae0:	64 f3       	brlt	.-40     	; 0x9aba <SD_init+0x3be>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9ae2:	80 91 ad 50 	lds	r24, 0x50AD
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9ae6:	80 e0       	ldi	r24, 0x00	; 0
    9ae8:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    9aec:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9af0:	88 e0       	ldi	r24, 0x08	; 8
    9af2:	60 e0       	ldi	r22, 0x00	; 0
    9af4:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
	return errorCode;	
    9af8:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9afa:	a9 96       	adiw	r28, 0x29	; 41
    9afc:	cd bf       	out	0x3d, r28	; 61
    9afe:	de bf       	out	0x3e, r29	; 62
    9b00:	df 91       	pop	r29
    9b02:	cf 91       	pop	r28
    9b04:	1f 91       	pop	r17
    9b06:	0f 91       	pop	r16
    9b08:	08 95       	ret

00009b0a <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9b0a:	cf 93       	push	r28
    9b0c:	df 93       	push	r29
    9b0e:	0f 92       	push	r0
    9b10:	0f 92       	push	r0
    9b12:	cd b7       	in	r28, 0x3d	; 61
    9b14:	de b7       	in	r29, 0x3e	; 62
    9b16:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9b18:	80 ec       	ldi	r24, 0xC0	; 192
    9b1a:	98 e0       	ldi	r25, 0x08	; 8
    9b1c:	2a 81       	ldd	r18, Y+2	; 0x02
    9b1e:	fc 01       	movw	r30, r24
    9b20:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9b22:	00 00       	nop
    9b24:	80 ec       	ldi	r24, 0xC0	; 192
    9b26:	98 e0       	ldi	r25, 0x08	; 8
    9b28:	fc 01       	movw	r30, r24
    9b2a:	82 81       	ldd	r24, Z+2	; 0x02
    9b2c:	88 23       	and	r24, r24
    9b2e:	d4 f7       	brge	.-12     	; 0x9b24 <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9b30:	80 ec       	ldi	r24, 0xC0	; 192
    9b32:	98 e0       	ldi	r25, 0x08	; 8
    9b34:	fc 01       	movw	r30, r24
    9b36:	83 81       	ldd	r24, Z+3	; 0x03
    9b38:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9b3a:	89 81       	ldd	r24, Y+1	; 0x01
}
    9b3c:	0f 90       	pop	r0
    9b3e:	0f 90       	pop	r0
    9b40:	df 91       	pop	r29
    9b42:	cf 91       	pop	r28
    9b44:	08 95       	ret

00009b46 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9b46:	0f 93       	push	r16
    9b48:	1f 93       	push	r17
    9b4a:	cf 93       	push	r28
    9b4c:	df 93       	push	r29
    9b4e:	cd b7       	in	r28, 0x3d	; 61
    9b50:	de b7       	in	r29, 0x3e	; 62
    9b52:	2a 97       	sbiw	r28, 0x0a	; 10
    9b54:	cd bf       	out	0x3d, r28	; 61
    9b56:	de bf       	out	0x3e, r29	; 62
    9b58:	8b 83       	std	Y+3, r24	; 0x03
    9b5a:	4c 83       	std	Y+4, r20	; 0x04
    9b5c:	5d 83       	std	Y+5, r21	; 0x05
    9b5e:	6e 83       	std	Y+6, r22	; 0x06
    9b60:	7f 83       	std	Y+7, r23	; 0x07
    9b62:	28 87       	std	Y+8, r18	; 0x08
    9b64:	09 87       	std	Y+9, r16	; 0x09
    9b66:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9b68:	8b 81       	ldd	r24, Y+3	; 0x03
    9b6a:	80 64       	ori	r24, 0x40	; 64
    9b6c:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9b70:	8c 81       	ldd	r24, Y+4	; 0x04
    9b72:	9d 81       	ldd	r25, Y+5	; 0x05
    9b74:	ae 81       	ldd	r26, Y+6	; 0x06
    9b76:	bf 81       	ldd	r27, Y+7	; 0x07
    9b78:	8b 2f       	mov	r24, r27
    9b7a:	99 27       	eor	r25, r25
    9b7c:	aa 27       	eor	r26, r26
    9b7e:	bb 27       	eor	r27, r27
    9b80:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9b84:	8c 81       	ldd	r24, Y+4	; 0x04
    9b86:	9d 81       	ldd	r25, Y+5	; 0x05
    9b88:	ae 81       	ldd	r26, Y+6	; 0x06
    9b8a:	bf 81       	ldd	r27, Y+7	; 0x07
    9b8c:	cd 01       	movw	r24, r26
    9b8e:	aa 27       	eor	r26, r26
    9b90:	bb 27       	eor	r27, r27
    9b92:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9b96:	8c 81       	ldd	r24, Y+4	; 0x04
    9b98:	9d 81       	ldd	r25, Y+5	; 0x05
    9b9a:	ae 81       	ldd	r26, Y+6	; 0x06
    9b9c:	bf 81       	ldd	r27, Y+7	; 0x07
    9b9e:	89 2f       	mov	r24, r25
    9ba0:	9a 2f       	mov	r25, r26
    9ba2:	ab 2f       	mov	r26, r27
    9ba4:	bb 27       	eor	r27, r27
    9ba6:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9baa:	8c 81       	ldd	r24, Y+4	; 0x04
    9bac:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
	SPI_write(crc);
    9bb0:	88 85       	ldd	r24, Y+8	; 0x08
    9bb2:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
	
	for(int i=0; i<read; i++){
    9bb6:	19 82       	std	Y+1, r1	; 0x01
    9bb8:	1a 82       	std	Y+2, r1	; 0x02
    9bba:	33 c0       	rjmp	.+102    	; 0x9c22 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9bbc:	89 81       	ldd	r24, Y+1	; 0x01
    9bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    9bc0:	2d e0       	ldi	r18, 0x0D	; 13
    9bc2:	30 e0       	ldi	r19, 0x00	; 0
    9bc4:	b9 01       	movw	r22, r18
    9bc6:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    9bca:	8c 01       	movw	r16, r24
    9bcc:	8f ef       	ldi	r24, 0xFF	; 255
    9bce:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9bd2:	28 2f       	mov	r18, r24
    9bd4:	c8 01       	movw	r24, r16
    9bd6:	83 55       	subi	r24, 0x53	; 83
    9bd8:	9f 4a       	sbci	r25, 0xAF	; 175
    9bda:	fc 01       	movw	r30, r24
    9bdc:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9bde:	89 81       	ldd	r24, Y+1	; 0x01
    9be0:	9a 81       	ldd	r25, Y+2	; 0x02
    9be2:	2d e0       	ldi	r18, 0x0D	; 13
    9be4:	30 e0       	ldi	r19, 0x00	; 0
    9be6:	b9 01       	movw	r22, r18
    9be8:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    9bec:	83 55       	subi	r24, 0x53	; 83
    9bee:	9f 4a       	sbci	r25, 0xAF	; 175
    9bf0:	fc 01       	movw	r30, r24
    9bf2:	80 81       	ld	r24, Z
    9bf4:	8f 3f       	cpi	r24, 0xFF	; 255
    9bf6:	81 f0       	breq	.+32     	; 0x9c18 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9bf8:	89 81       	ldd	r24, Y+1	; 0x01
    9bfa:	9a 81       	ldd	r25, Y+2	; 0x02
    9bfc:	2d e0       	ldi	r18, 0x0D	; 13
    9bfe:	30 e0       	ldi	r19, 0x00	; 0
    9c00:	b9 01       	movw	r22, r18
    9c02:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    9c06:	83 55       	subi	r24, 0x53	; 83
    9c08:	9f 4a       	sbci	r25, 0xAF	; 175
    9c0a:	fc 01       	movw	r30, r24
    9c0c:	80 81       	ld	r24, Z
    9c0e:	80 93 ae 50 	sts	0x50AE, r24
			return Buffer[1];
    9c12:	80 91 ae 50 	lds	r24, 0x50AE
    9c16:	0d c0       	rjmp	.+26     	; 0x9c32 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9c18:	89 81       	ldd	r24, Y+1	; 0x01
    9c1a:	9a 81       	ldd	r25, Y+2	; 0x02
    9c1c:	01 96       	adiw	r24, 0x01	; 1
    9c1e:	89 83       	std	Y+1, r24	; 0x01
    9c20:	9a 83       	std	Y+2, r25	; 0x02
    9c22:	29 81       	ldd	r18, Y+1	; 0x01
    9c24:	3a 81       	ldd	r19, Y+2	; 0x02
    9c26:	89 85       	ldd	r24, Y+9	; 0x09
    9c28:	9a 85       	ldd	r25, Y+10	; 0x0a
    9c2a:	28 17       	cp	r18, r24
    9c2c:	39 07       	cpc	r19, r25
    9c2e:	34 f2       	brlt	.-116    	; 0x9bbc <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9c30:	8f ef       	ldi	r24, 0xFF	; 255
}
    9c32:	2a 96       	adiw	r28, 0x0a	; 10
    9c34:	cd bf       	out	0x3d, r28	; 61
    9c36:	de bf       	out	0x3e, r29	; 62
    9c38:	df 91       	pop	r29
    9c3a:	cf 91       	pop	r28
    9c3c:	1f 91       	pop	r17
    9c3e:	0f 91       	pop	r16
    9c40:	08 95       	ret

00009c42 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9c42:	0f 93       	push	r16
    9c44:	1f 93       	push	r17
    9c46:	cf 93       	push	r28
    9c48:	df 93       	push	r29
    9c4a:	cd b7       	in	r28, 0x3d	; 61
    9c4c:	de b7       	in	r29, 0x3e	; 62
    9c4e:	62 97       	sbiw	r28, 0x12	; 18
    9c50:	cd bf       	out	0x3d, r28	; 61
    9c52:	de bf       	out	0x3e, r29	; 62
    9c54:	6b 87       	std	Y+11, r22	; 0x0b
    9c56:	7c 87       	std	Y+12, r23	; 0x0c
    9c58:	8d 87       	std	Y+13, r24	; 0x0d
    9c5a:	9e 87       	std	Y+14, r25	; 0x0e
    9c5c:	4f 87       	std	Y+15, r20	; 0x0f
    9c5e:	58 8b       	std	Y+16, r21	; 0x10
    9c60:	29 8b       	std	Y+17, r18	; 0x11
    9c62:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9c64:	88 e0       	ldi	r24, 0x08	; 8
    9c66:	60 e0       	ldi	r22, 0x00	; 0
    9c68:	0e 94 36 34 	call	0x686c	; 0x686c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9c6c:	80 e0       	ldi	r24, 0x00	; 0
    9c6e:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    9c72:	81 e0       	ldi	r24, 0x01	; 1
    9c74:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9c78:	20 e0       	ldi	r18, 0x00	; 0
    9c7a:	32 e0       	ldi	r19, 0x02	; 2
    9c7c:	89 89       	ldd	r24, Y+17	; 0x11
    9c7e:	9a 89       	ldd	r25, Y+18	; 0x12
    9c80:	a9 01       	movw	r20, r18
    9c82:	48 1b       	sub	r20, r24
    9c84:	59 0b       	sbc	r21, r25
    9c86:	ca 01       	movw	r24, r20
    9c88:	89 83       	std	Y+1, r24	; 0x01
    9c8a:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9c8c:	89 81       	ldd	r24, Y+1	; 0x01
    9c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    9c90:	52 e0       	ldi	r21, 0x02	; 2
    9c92:	80 30       	cpi	r24, 0x00	; 0
    9c94:	95 07       	cpc	r25, r21
    9c96:	11 f4       	brne	.+4      	; 0x9c9c <SD_write_block+0x5a>
    9c98:	19 82       	std	Y+1, r1	; 0x01
    9c9a:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9c9c:	1b 82       	std	Y+3, r1	; 0x03
    9c9e:	1c 82       	std	Y+4, r1	; 0x04
    9ca0:	0b c0       	rjmp	.+22     	; 0x9cb8 <SD_write_block+0x76>
	if (i >= 10) {
    9ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    9ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    9ca6:	8a 30       	cpi	r24, 0x0A	; 10
    9ca8:	91 05       	cpc	r25, r1
    9caa:	0c f0       	brlt	.+2      	; 0x9cae <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9cac:	ff cf       	rjmp	.-2      	; 0x9cac <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9cae:	8b 81       	ldd	r24, Y+3	; 0x03
    9cb0:	9c 81       	ldd	r25, Y+4	; 0x04
    9cb2:	01 96       	adiw	r24, 0x01	; 1
    9cb4:	8b 83       	std	Y+3, r24	; 0x03
    9cb6:	9c 83       	std	Y+4, r25	; 0x04
    9cb8:	2b 85       	ldd	r18, Y+11	; 0x0b
    9cba:	3c 85       	ldd	r19, Y+12	; 0x0c
    9cbc:	4d 85       	ldd	r20, Y+13	; 0x0d
    9cbe:	5e 85       	ldd	r21, Y+14	; 0x0e
    9cc0:	88 e1       	ldi	r24, 0x18	; 24
    9cc2:	ba 01       	movw	r22, r20
    9cc4:	a9 01       	movw	r20, r18
    9cc6:	2f ef       	ldi	r18, 0xFF	; 255
    9cc8:	08 e0       	ldi	r16, 0x08	; 8
    9cca:	10 e0       	ldi	r17, 0x00	; 0
    9ccc:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
    9cd0:	88 23       	and	r24, r24
    9cd2:	39 f7       	brne	.-50     	; 0x9ca2 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9cd4:	8f ef       	ldi	r24, 0xFF	; 255
    9cd6:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9cda:	80 93 ad 50 	sts	0x50AD, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9cde:	8e ef       	ldi	r24, 0xFE	; 254
    9ce0:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9ce4:	1d 82       	std	Y+5, r1	; 0x05
    9ce6:	1e 82       	std	Y+6, r1	; 0x06
    9ce8:	1d c0       	rjmp	.+58     	; 0x9d24 <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9cea:	8d 81       	ldd	r24, Y+5	; 0x05
    9cec:	9e 81       	ldd	r25, Y+6	; 0x06
    9cee:	2d e0       	ldi	r18, 0x0D	; 13
    9cf0:	30 e0       	ldi	r19, 0x00	; 0
    9cf2:	b9 01       	movw	r22, r18
    9cf4:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    9cf8:	8c 01       	movw	r16, r24
    9cfa:	8d 81       	ldd	r24, Y+5	; 0x05
    9cfc:	9e 81       	ldd	r25, Y+6	; 0x06
    9cfe:	2f 85       	ldd	r18, Y+15	; 0x0f
    9d00:	38 89       	ldd	r19, Y+16	; 0x10
    9d02:	82 0f       	add	r24, r18
    9d04:	93 1f       	adc	r25, r19
    9d06:	fc 01       	movw	r30, r24
    9d08:	80 81       	ld	r24, Z
    9d0a:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9d0e:	28 2f       	mov	r18, r24
    9d10:	c8 01       	movw	r24, r16
    9d12:	83 55       	subi	r24, 0x53	; 83
    9d14:	9f 4a       	sbci	r25, 0xAF	; 175
    9d16:	fc 01       	movw	r30, r24
    9d18:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9d1a:	8d 81       	ldd	r24, Y+5	; 0x05
    9d1c:	9e 81       	ldd	r25, Y+6	; 0x06
    9d1e:	01 96       	adiw	r24, 0x01	; 1
    9d20:	8d 83       	std	Y+5, r24	; 0x05
    9d22:	9e 83       	std	Y+6, r25	; 0x06
    9d24:	2d 81       	ldd	r18, Y+5	; 0x05
    9d26:	3e 81       	ldd	r19, Y+6	; 0x06
    9d28:	89 89       	ldd	r24, Y+17	; 0x11
    9d2a:	9a 89       	ldd	r25, Y+18	; 0x12
    9d2c:	28 17       	cp	r18, r24
    9d2e:	39 07       	cpc	r19, r25
    9d30:	e4 f2       	brlt	.-72     	; 0x9cea <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9d32:	1f 82       	std	Y+7, r1	; 0x07
    9d34:	18 86       	std	Y+8, r1	; 0x08
    9d36:	16 c0       	rjmp	.+44     	; 0x9d64 <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9d38:	8f 81       	ldd	r24, Y+7	; 0x07
    9d3a:	98 85       	ldd	r25, Y+8	; 0x08
    9d3c:	2d e0       	ldi	r18, 0x0D	; 13
    9d3e:	30 e0       	ldi	r19, 0x00	; 0
    9d40:	b9 01       	movw	r22, r18
    9d42:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    9d46:	8c 01       	movw	r16, r24
    9d48:	80 e0       	ldi	r24, 0x00	; 0
    9d4a:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9d4e:	28 2f       	mov	r18, r24
    9d50:	c8 01       	movw	r24, r16
    9d52:	83 55       	subi	r24, 0x53	; 83
    9d54:	9f 4a       	sbci	r25, 0xAF	; 175
    9d56:	fc 01       	movw	r30, r24
    9d58:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9d5a:	8f 81       	ldd	r24, Y+7	; 0x07
    9d5c:	98 85       	ldd	r25, Y+8	; 0x08
    9d5e:	01 96       	adiw	r24, 0x01	; 1
    9d60:	8f 83       	std	Y+7, r24	; 0x07
    9d62:	98 87       	std	Y+8, r25	; 0x08
    9d64:	2f 81       	ldd	r18, Y+7	; 0x07
    9d66:	38 85       	ldd	r19, Y+8	; 0x08
    9d68:	89 81       	ldd	r24, Y+1	; 0x01
    9d6a:	9a 81       	ldd	r25, Y+2	; 0x02
    9d6c:	28 17       	cp	r18, r24
    9d6e:	39 07       	cpc	r19, r25
    9d70:	1c f3       	brlt	.-58     	; 0x9d38 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9d72:	8f ef       	ldi	r24, 0xFF	; 255
    9d74:	80 93 ad 50 	sts	0x50AD, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9d78:	19 86       	std	Y+9, r1	; 0x09
    9d7a:	1a 86       	std	Y+10, r1	; 0x0a
    9d7c:	0a c0       	rjmp	.+20     	; 0x9d92 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9d7e:	8f ef       	ldi	r24, 0xFF	; 255
    9d80:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9d84:	80 93 ad 50 	sts	0x50AD, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9d88:	89 85       	ldd	r24, Y+9	; 0x09
    9d8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    9d8c:	01 96       	adiw	r24, 0x01	; 1
    9d8e:	89 87       	std	Y+9, r24	; 0x09
    9d90:	9a 87       	std	Y+10, r25	; 0x0a
    9d92:	89 85       	ldd	r24, Y+9	; 0x09
    9d94:	9a 85       	ldd	r25, Y+10	; 0x0a
    9d96:	82 30       	cpi	r24, 0x02	; 2
    9d98:	91 05       	cpc	r25, r1
    9d9a:	8c f3       	brlt	.-30     	; 0x9d7e <SD_write_block+0x13c>
    9d9c:	80 91 ad 50 	lds	r24, 0x50AD
    9da0:	8f 3f       	cpi	r24, 0xFF	; 255
    9da2:	69 f3       	breq	.-38     	; 0x9d7e <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9da4:	80 91 ad 50 	lds	r24, 0x50AD
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9da8:	05 c0       	rjmp	.+10     	; 0x9db4 <SD_write_block+0x172>
    9daa:	8f ef       	ldi	r24, 0xFF	; 255
    9dac:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9db0:	80 93 ad 50 	sts	0x50AD, r24
    9db4:	80 91 ad 50 	lds	r24, 0x50AD
    9db8:	8f 3f       	cpi	r24, 0xFF	; 255
    9dba:	b9 f7       	brne	.-18     	; 0x9daa <SD_write_block+0x168>
	SPICS(FALSE);
    9dbc:	80 e0       	ldi	r24, 0x00	; 0
    9dbe:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    9dc2:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9dc6:	88 e0       	ldi	r24, 0x08	; 8
    9dc8:	60 e0       	ldi	r22, 0x00	; 0
    9dca:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
}
    9dce:	62 96       	adiw	r28, 0x12	; 18
    9dd0:	cd bf       	out	0x3d, r28	; 61
    9dd2:	de bf       	out	0x3e, r29	; 62
    9dd4:	df 91       	pop	r29
    9dd6:	cf 91       	pop	r28
    9dd8:	1f 91       	pop	r17
    9dda:	0f 91       	pop	r16
    9ddc:	08 95       	ret

00009dde <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9dde:	0f 93       	push	r16
    9de0:	1f 93       	push	r17
    9de2:	cf 93       	push	r28
    9de4:	df 93       	push	r29
    9de6:	cd b7       	in	r28, 0x3d	; 61
    9de8:	de b7       	in	r29, 0x3e	; 62
    9dea:	2a 97       	sbiw	r28, 0x0a	; 10
    9dec:	cd bf       	out	0x3d, r28	; 61
    9dee:	de bf       	out	0x3e, r29	; 62
    9df0:	6d 83       	std	Y+5, r22	; 0x05
    9df2:	7e 83       	std	Y+6, r23	; 0x06
    9df4:	8f 83       	std	Y+7, r24	; 0x07
    9df6:	98 87       	std	Y+8, r25	; 0x08
    9df8:	49 87       	std	Y+9, r20	; 0x09
    9dfa:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9dfc:	88 e0       	ldi	r24, 0x08	; 8
    9dfe:	60 e0       	ldi	r22, 0x00	; 0
    9e00:	0e 94 36 34 	call	0x686c	; 0x686c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9e04:	80 e0       	ldi	r24, 0x00	; 0
    9e06:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    9e0a:	81 e0       	ldi	r24, 0x01	; 1
    9e0c:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9e10:	19 82       	std	Y+1, r1	; 0x01
    9e12:	1a 82       	std	Y+2, r1	; 0x02
    9e14:	0b c0       	rjmp	.+22     	; 0x9e2c <SD_read_block+0x4e>
		if (i >= 10) {
    9e16:	89 81       	ldd	r24, Y+1	; 0x01
    9e18:	9a 81       	ldd	r25, Y+2	; 0x02
    9e1a:	8a 30       	cpi	r24, 0x0A	; 10
    9e1c:	91 05       	cpc	r25, r1
    9e1e:	0c f0       	brlt	.+2      	; 0x9e22 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9e20:	ff cf       	rjmp	.-2      	; 0x9e20 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9e22:	89 81       	ldd	r24, Y+1	; 0x01
    9e24:	9a 81       	ldd	r25, Y+2	; 0x02
    9e26:	01 96       	adiw	r24, 0x01	; 1
    9e28:	89 83       	std	Y+1, r24	; 0x01
    9e2a:	9a 83       	std	Y+2, r25	; 0x02
    9e2c:	2d 81       	ldd	r18, Y+5	; 0x05
    9e2e:	3e 81       	ldd	r19, Y+6	; 0x06
    9e30:	4f 81       	ldd	r20, Y+7	; 0x07
    9e32:	58 85       	ldd	r21, Y+8	; 0x08
    9e34:	81 e1       	ldi	r24, 0x11	; 17
    9e36:	ba 01       	movw	r22, r20
    9e38:	a9 01       	movw	r20, r18
    9e3a:	2f ef       	ldi	r18, 0xFF	; 255
    9e3c:	08 e0       	ldi	r16, 0x08	; 8
    9e3e:	10 e0       	ldi	r17, 0x00	; 0
    9e40:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
    9e44:	88 23       	and	r24, r24
    9e46:	39 f7       	brne	.-50     	; 0x9e16 <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9e48:	05 c0       	rjmp	.+10     	; 0x9e54 <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9e4a:	8f ef       	ldi	r24, 0xFF	; 255
    9e4c:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9e50:	80 93 ad 50 	sts	0x50AD, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9e54:	80 91 ad 50 	lds	r24, 0x50AD
    9e58:	8e 3f       	cpi	r24, 0xFE	; 254
    9e5a:	b9 f7       	brne	.-18     	; 0x9e4a <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9e5c:	1b 82       	std	Y+3, r1	; 0x03
    9e5e:	1c 82       	std	Y+4, r1	; 0x04
    9e60:	11 c0       	rjmp	.+34     	; 0x9e84 <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9e62:	8b 81       	ldd	r24, Y+3	; 0x03
    9e64:	9c 81       	ldd	r25, Y+4	; 0x04
    9e66:	29 85       	ldd	r18, Y+9	; 0x09
    9e68:	3a 85       	ldd	r19, Y+10	; 0x0a
    9e6a:	89 01       	movw	r16, r18
    9e6c:	08 0f       	add	r16, r24
    9e6e:	19 1f       	adc	r17, r25
    9e70:	8f ef       	ldi	r24, 0xFF	; 255
    9e72:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9e76:	f8 01       	movw	r30, r16
    9e78:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    9e7c:	9c 81       	ldd	r25, Y+4	; 0x04
    9e7e:	01 96       	adiw	r24, 0x01	; 1
    9e80:	8b 83       	std	Y+3, r24	; 0x03
    9e82:	9c 83       	std	Y+4, r25	; 0x04
    9e84:	8b 81       	ldd	r24, Y+3	; 0x03
    9e86:	9c 81       	ldd	r25, Y+4	; 0x04
    9e88:	f2 e0       	ldi	r31, 0x02	; 2
    9e8a:	80 30       	cpi	r24, 0x00	; 0
    9e8c:	9f 07       	cpc	r25, r31
    9e8e:	4c f3       	brlt	.-46     	; 0x9e62 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    9e90:	10 92 b9 50 	sts	0x50B9, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9e94:	05 c0       	rjmp	.+10     	; 0x9ea0 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    9e96:	8f ef       	ldi	r24, 0xFF	; 255
    9e98:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9e9c:	80 93 b9 50 	sts	0x50B9, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9ea0:	80 91 b9 50 	lds	r24, 0x50B9
    9ea4:	8f 3f       	cpi	r24, 0xFF	; 255
    9ea6:	b9 f7       	brne	.-18     	; 0x9e96 <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    9ea8:	80 e0       	ldi	r24, 0x00	; 0
    9eaa:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    9eae:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9eb2:	88 e0       	ldi	r24, 0x08	; 8
    9eb4:	60 e0       	ldi	r22, 0x00	; 0
    9eb6:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
}
    9eba:	2a 96       	adiw	r28, 0x0a	; 10
    9ebc:	cd bf       	out	0x3d, r28	; 61
    9ebe:	de bf       	out	0x3e, r29	; 62
    9ec0:	df 91       	pop	r29
    9ec2:	cf 91       	pop	r28
    9ec4:	1f 91       	pop	r17
    9ec6:	0f 91       	pop	r16
    9ec8:	08 95       	ret

00009eca <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    9eca:	0f 93       	push	r16
    9ecc:	1f 93       	push	r17
    9ece:	cf 93       	push	r28
    9ed0:	df 93       	push	r29
    9ed2:	cd b7       	in	r28, 0x3d	; 61
    9ed4:	de b7       	in	r29, 0x3e	; 62
    9ed6:	6a 97       	sbiw	r28, 0x1a	; 26
    9ed8:	cd bf       	out	0x3d, r28	; 61
    9eda:	de bf       	out	0x3e, r29	; 62
    9edc:	6b 8b       	std	Y+19, r22	; 0x13
    9ede:	7c 8b       	std	Y+20, r23	; 0x14
    9ee0:	8d 8b       	std	Y+21, r24	; 0x15
    9ee2:	9e 8b       	std	Y+22, r25	; 0x16
    9ee4:	4f 8b       	std	Y+23, r20	; 0x17
    9ee6:	58 8f       	std	Y+24, r21	; 0x18
    9ee8:	29 8f       	std	Y+25, r18	; 0x19
    9eea:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9eec:	88 e0       	ldi	r24, 0x08	; 8
    9eee:	60 e0       	ldi	r22, 0x00	; 0
    9ef0:	0e 94 36 34 	call	0x686c	; 0x686c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9ef4:	80 e0       	ldi	r24, 0x00	; 0
    9ef6:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    9efa:	81 e0       	ldi	r24, 0x01	; 1
    9efc:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    9f00:	89 8d       	ldd	r24, Y+25	; 0x19
    9f02:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9f04:	99 23       	and	r25, r25
    9f06:	14 f4       	brge	.+4      	; 0x9f0c <SD_write_multiple_blocks+0x42>
    9f08:	81 50       	subi	r24, 0x01	; 1
    9f0a:	9e 4f       	sbci	r25, 0xFE	; 254
    9f0c:	89 2f       	mov	r24, r25
    9f0e:	99 0f       	add	r25, r25
    9f10:	99 0b       	sbc	r25, r25
    9f12:	85 95       	asr	r24
    9f14:	89 83       	std	Y+1, r24	; 0x01
    9f16:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    9f18:	89 8d       	ldd	r24, Y+25	; 0x19
    9f1a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9f1c:	20 e0       	ldi	r18, 0x00	; 0
    9f1e:	32 e0       	ldi	r19, 0x02	; 2
    9f20:	b9 01       	movw	r22, r18
    9f22:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    9f26:	20 e0       	ldi	r18, 0x00	; 0
    9f28:	32 e0       	ldi	r19, 0x02	; 2
    9f2a:	a9 01       	movw	r20, r18
    9f2c:	48 1b       	sub	r20, r24
    9f2e:	59 0b       	sbc	r21, r25
    9f30:	ca 01       	movw	r24, r20
    9f32:	8b 83       	std	Y+3, r24	; 0x03
    9f34:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9f36:	8b 81       	ldd	r24, Y+3	; 0x03
    9f38:	9c 81       	ldd	r25, Y+4	; 0x04
    9f3a:	52 e0       	ldi	r21, 0x02	; 2
    9f3c:	80 30       	cpi	r24, 0x00	; 0
    9f3e:	95 07       	cpc	r25, r21
    9f40:	19 f4       	brne	.+6      	; 0x9f48 <SD_write_multiple_blocks+0x7e>
    9f42:	1b 82       	std	Y+3, r1	; 0x03
    9f44:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9f46:	05 c0       	rjmp	.+10     	; 0x9f52 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    9f48:	89 81       	ldd	r24, Y+1	; 0x01
    9f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    9f4c:	01 96       	adiw	r24, 0x01	; 1
    9f4e:	89 83       	std	Y+1, r24	; 0x01
    9f50:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9f52:	00 00       	nop
    9f54:	2b 89       	ldd	r18, Y+19	; 0x13
    9f56:	3c 89       	ldd	r19, Y+20	; 0x14
    9f58:	4d 89       	ldd	r20, Y+21	; 0x15
    9f5a:	5e 89       	ldd	r21, Y+22	; 0x16
    9f5c:	89 e1       	ldi	r24, 0x19	; 25
    9f5e:	ba 01       	movw	r22, r20
    9f60:	a9 01       	movw	r20, r18
    9f62:	2f ef       	ldi	r18, 0xFF	; 255
    9f64:	08 e0       	ldi	r16, 0x08	; 8
    9f66:	10 e0       	ldi	r17, 0x00	; 0
    9f68:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
    9f6c:	88 23       	and	r24, r24
    9f6e:	91 f7       	brne	.-28     	; 0x9f54 <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    9f70:	1d 82       	std	Y+5, r1	; 0x05
    9f72:	1e 82       	std	Y+6, r1	; 0x06
    9f74:	ba c0       	rjmp	.+372    	; 0xa0ea <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    9f76:	8f ef       	ldi	r24, 0xFF	; 255
    9f78:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9f7c:	80 93 ae 50 	sts	0x50AE, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    9f80:	8c ef       	ldi	r24, 0xFC	; 252
    9f82:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9f86:	80 93 ae 50 	sts	0x50AE, r24
		if(j == (numSectors-1)){
    9f8a:	89 81       	ldd	r24, Y+1	; 0x01
    9f8c:	9a 81       	ldd	r25, Y+2	; 0x02
    9f8e:	9c 01       	movw	r18, r24
    9f90:	21 50       	subi	r18, 0x01	; 1
    9f92:	30 40       	sbci	r19, 0x00	; 0
    9f94:	8d 81       	ldd	r24, Y+5	; 0x05
    9f96:	9e 81       	ldd	r25, Y+6	; 0x06
    9f98:	28 17       	cp	r18, r24
    9f9a:	39 07       	cpc	r19, r25
    9f9c:	09 f0       	breq	.+2      	; 0x9fa0 <SD_write_multiple_blocks+0xd6>
    9f9e:	54 c0       	rjmp	.+168    	; 0xa048 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9fa0:	1f 82       	std	Y+7, r1	; 0x07
    9fa2:	18 86       	std	Y+8, r1	; 0x08
    9fa4:	25 c0       	rjmp	.+74     	; 0x9ff0 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9fa6:	8f 81       	ldd	r24, Y+7	; 0x07
    9fa8:	98 85       	ldd	r25, Y+8	; 0x08
    9faa:	2c e0       	ldi	r18, 0x0C	; 12
    9fac:	30 e0       	ldi	r19, 0x00	; 0
    9fae:	b9 01       	movw	r22, r18
    9fb0:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    9fb4:	8c 01       	movw	r16, r24
    9fb6:	8d 81       	ldd	r24, Y+5	; 0x05
    9fb8:	9e 81       	ldd	r25, Y+6	; 0x06
    9fba:	9c 01       	movw	r18, r24
    9fbc:	32 2f       	mov	r19, r18
    9fbe:	22 27       	eor	r18, r18
    9fc0:	33 0f       	add	r19, r19
    9fc2:	8f 81       	ldd	r24, Y+7	; 0x07
    9fc4:	98 85       	ldd	r25, Y+8	; 0x08
    9fc6:	82 0f       	add	r24, r18
    9fc8:	93 1f       	adc	r25, r19
    9fca:	2f 89       	ldd	r18, Y+23	; 0x17
    9fcc:	38 8d       	ldd	r19, Y+24	; 0x18
    9fce:	82 0f       	add	r24, r18
    9fd0:	93 1f       	adc	r25, r19
    9fd2:	fc 01       	movw	r30, r24
    9fd4:	80 81       	ld	r24, Z
    9fd6:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    9fda:	28 2f       	mov	r18, r24
    9fdc:	c8 01       	movw	r24, r16
    9fde:	83 55       	subi	r24, 0x53	; 83
    9fe0:	9f 4a       	sbci	r25, 0xAF	; 175
    9fe2:	fc 01       	movw	r30, r24
    9fe4:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9fe6:	8f 81       	ldd	r24, Y+7	; 0x07
    9fe8:	98 85       	ldd	r25, Y+8	; 0x08
    9fea:	01 96       	adiw	r24, 0x01	; 1
    9fec:	8f 83       	std	Y+7, r24	; 0x07
    9fee:	98 87       	std	Y+8, r25	; 0x08
    9ff0:	20 e0       	ldi	r18, 0x00	; 0
    9ff2:	32 e0       	ldi	r19, 0x02	; 2
    9ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    9ff6:	9c 81       	ldd	r25, Y+4	; 0x04
    9ff8:	28 1b       	sub	r18, r24
    9ffa:	39 0b       	sbc	r19, r25
    9ffc:	8f 81       	ldd	r24, Y+7	; 0x07
    9ffe:	98 85       	ldd	r25, Y+8	; 0x08
    a000:	82 17       	cp	r24, r18
    a002:	93 07       	cpc	r25, r19
    a004:	84 f2       	brlt	.-96     	; 0x9fa6 <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a006:	19 86       	std	Y+9, r1	; 0x09
    a008:	1a 86       	std	Y+10, r1	; 0x0a
    a00a:	16 c0       	rjmp	.+44     	; 0xa038 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a00c:	89 85       	ldd	r24, Y+9	; 0x09
    a00e:	9a 85       	ldd	r25, Y+10	; 0x0a
    a010:	2c e0       	ldi	r18, 0x0C	; 12
    a012:	30 e0       	ldi	r19, 0x00	; 0
    a014:	b9 01       	movw	r22, r18
    a016:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    a01a:	8c 01       	movw	r16, r24
    a01c:	80 e0       	ldi	r24, 0x00	; 0
    a01e:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a022:	28 2f       	mov	r18, r24
    a024:	c8 01       	movw	r24, r16
    a026:	83 55       	subi	r24, 0x53	; 83
    a028:	9f 4a       	sbci	r25, 0xAF	; 175
    a02a:	fc 01       	movw	r30, r24
    a02c:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a02e:	89 85       	ldd	r24, Y+9	; 0x09
    a030:	9a 85       	ldd	r25, Y+10	; 0x0a
    a032:	01 96       	adiw	r24, 0x01	; 1
    a034:	89 87       	std	Y+9, r24	; 0x09
    a036:	9a 87       	std	Y+10, r25	; 0x0a
    a038:	29 85       	ldd	r18, Y+9	; 0x09
    a03a:	3a 85       	ldd	r19, Y+10	; 0x0a
    a03c:	8b 81       	ldd	r24, Y+3	; 0x03
    a03e:	9c 81       	ldd	r25, Y+4	; 0x04
    a040:	28 17       	cp	r18, r24
    a042:	39 07       	cpc	r19, r25
    a044:	1c f3       	brlt	.-58     	; 0xa00c <SD_write_multiple_blocks+0x142>
    a046:	2e c0       	rjmp	.+92     	; 0xa0a4 <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a048:	1b 86       	std	Y+11, r1	; 0x0b
    a04a:	1c 86       	std	Y+12, r1	; 0x0c
    a04c:	25 c0       	rjmp	.+74     	; 0xa098 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a04e:	8b 85       	ldd	r24, Y+11	; 0x0b
    a050:	9c 85       	ldd	r25, Y+12	; 0x0c
    a052:	2c e0       	ldi	r18, 0x0C	; 12
    a054:	30 e0       	ldi	r19, 0x00	; 0
    a056:	b9 01       	movw	r22, r18
    a058:	0e 94 dd 5c 	call	0xb9ba	; 0xb9ba <__divmodhi4>
    a05c:	8c 01       	movw	r16, r24
    a05e:	8d 81       	ldd	r24, Y+5	; 0x05
    a060:	9e 81       	ldd	r25, Y+6	; 0x06
    a062:	9c 01       	movw	r18, r24
    a064:	32 2f       	mov	r19, r18
    a066:	22 27       	eor	r18, r18
    a068:	33 0f       	add	r19, r19
    a06a:	8b 85       	ldd	r24, Y+11	; 0x0b
    a06c:	9c 85       	ldd	r25, Y+12	; 0x0c
    a06e:	82 0f       	add	r24, r18
    a070:	93 1f       	adc	r25, r19
    a072:	2f 89       	ldd	r18, Y+23	; 0x17
    a074:	38 8d       	ldd	r19, Y+24	; 0x18
    a076:	82 0f       	add	r24, r18
    a078:	93 1f       	adc	r25, r19
    a07a:	fc 01       	movw	r30, r24
    a07c:	80 81       	ld	r24, Z
    a07e:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a082:	28 2f       	mov	r18, r24
    a084:	c8 01       	movw	r24, r16
    a086:	83 55       	subi	r24, 0x53	; 83
    a088:	9f 4a       	sbci	r25, 0xAF	; 175
    a08a:	fc 01       	movw	r30, r24
    a08c:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a08e:	8b 85       	ldd	r24, Y+11	; 0x0b
    a090:	9c 85       	ldd	r25, Y+12	; 0x0c
    a092:	01 96       	adiw	r24, 0x01	; 1
    a094:	8b 87       	std	Y+11, r24	; 0x0b
    a096:	9c 87       	std	Y+12, r25	; 0x0c
    a098:	8b 85       	ldd	r24, Y+11	; 0x0b
    a09a:	9c 85       	ldd	r25, Y+12	; 0x0c
    a09c:	f2 e0       	ldi	r31, 0x02	; 2
    a09e:	80 30       	cpi	r24, 0x00	; 0
    a0a0:	9f 07       	cpc	r25, r31
    a0a2:	ac f2       	brlt	.-86     	; 0xa04e <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a0a4:	1d 86       	std	Y+13, r1	; 0x0d
    a0a6:	1e 86       	std	Y+14, r1	; 0x0e
    a0a8:	0a c0       	rjmp	.+20     	; 0xa0be <SD_write_multiple_blocks+0x1f4>
    a0aa:	8f ef       	ldi	r24, 0xFF	; 255
    a0ac:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a0b0:	80 93 ae 50 	sts	0x50AE, r24
    a0b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    a0b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    a0b8:	01 96       	adiw	r24, 0x01	; 1
    a0ba:	8d 87       	std	Y+13, r24	; 0x0d
    a0bc:	9e 87       	std	Y+14, r25	; 0x0e
    a0be:	8d 85       	ldd	r24, Y+13	; 0x0d
    a0c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    a0c2:	82 30       	cpi	r24, 0x02	; 2
    a0c4:	91 05       	cpc	r25, r1
    a0c6:	8c f3       	brlt	.-30     	; 0xa0aa <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a0c8:	10 92 ae 50 	sts	0x50AE, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a0cc:	05 c0       	rjmp	.+10     	; 0xa0d8 <SD_write_multiple_blocks+0x20e>
    a0ce:	8f ef       	ldi	r24, 0xFF	; 255
    a0d0:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a0d4:	80 93 ae 50 	sts	0x50AE, r24
    a0d8:	80 91 ae 50 	lds	r24, 0x50AE
    a0dc:	8f 3f       	cpi	r24, 0xFF	; 255
    a0de:	b9 f7       	brne	.-18     	; 0xa0ce <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a0e0:	8d 81       	ldd	r24, Y+5	; 0x05
    a0e2:	9e 81       	ldd	r25, Y+6	; 0x06
    a0e4:	01 96       	adiw	r24, 0x01	; 1
    a0e6:	8d 83       	std	Y+5, r24	; 0x05
    a0e8:	9e 83       	std	Y+6, r25	; 0x06
    a0ea:	2d 81       	ldd	r18, Y+5	; 0x05
    a0ec:	3e 81       	ldd	r19, Y+6	; 0x06
    a0ee:	89 81       	ldd	r24, Y+1	; 0x01
    a0f0:	9a 81       	ldd	r25, Y+2	; 0x02
    a0f2:	28 17       	cp	r18, r24
    a0f4:	39 07       	cpc	r19, r25
    a0f6:	0c f4       	brge	.+2      	; 0xa0fa <SD_write_multiple_blocks+0x230>
    a0f8:	3e cf       	rjmp	.-388    	; 0x9f76 <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a0fa:	1f 86       	std	Y+15, r1	; 0x0f
    a0fc:	18 8a       	std	Y+16, r1	; 0x10
    a0fe:	0a c0       	rjmp	.+20     	; 0xa114 <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a100:	8f ef       	ldi	r24, 0xFF	; 255
    a102:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a106:	80 93 ae 50 	sts	0x50AE, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a10a:	8f 85       	ldd	r24, Y+15	; 0x0f
    a10c:	98 89       	ldd	r25, Y+16	; 0x10
    a10e:	01 96       	adiw	r24, 0x01	; 1
    a110:	8f 87       	std	Y+15, r24	; 0x0f
    a112:	98 8b       	std	Y+16, r25	; 0x10
    a114:	8f 85       	ldd	r24, Y+15	; 0x0f
    a116:	98 89       	ldd	r25, Y+16	; 0x10
    a118:	84 30       	cpi	r24, 0x04	; 4
    a11a:	91 05       	cpc	r25, r1
    a11c:	8c f3       	brlt	.-30     	; 0xa100 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a11e:	8d ef       	ldi	r24, 0xFD	; 253
    a120:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a124:	80 93 ae 50 	sts	0x50AE, r24
	for(int i=0;i<4;i++){
    a128:	19 8a       	std	Y+17, r1	; 0x11
    a12a:	1a 8a       	std	Y+18, r1	; 0x12
    a12c:	0a c0       	rjmp	.+20     	; 0xa142 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a12e:	8f ef       	ldi	r24, 0xFF	; 255
    a130:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a134:	80 93 ae 50 	sts	0x50AE, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a138:	89 89       	ldd	r24, Y+17	; 0x11
    a13a:	9a 89       	ldd	r25, Y+18	; 0x12
    a13c:	01 96       	adiw	r24, 0x01	; 1
    a13e:	89 8b       	std	Y+17, r24	; 0x11
    a140:	9a 8b       	std	Y+18, r25	; 0x12
    a142:	89 89       	ldd	r24, Y+17	; 0x11
    a144:	9a 89       	ldd	r25, Y+18	; 0x12
    a146:	84 30       	cpi	r24, 0x04	; 4
    a148:	91 05       	cpc	r25, r1
    a14a:	8c f3       	brlt	.-30     	; 0xa12e <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a14c:	10 92 ae 50 	sts	0x50AE, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a150:	05 c0       	rjmp	.+10     	; 0xa15c <SD_write_multiple_blocks+0x292>
    a152:	8f ef       	ldi	r24, 0xFF	; 255
    a154:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a158:	80 93 ae 50 	sts	0x50AE, r24
    a15c:	80 91 ae 50 	lds	r24, 0x50AE
    a160:	8f 3f       	cpi	r24, 0xFF	; 255
    a162:	b9 f7       	brne	.-18     	; 0xa152 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a164:	80 e0       	ldi	r24, 0x00	; 0
    a166:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    a16a:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a16e:	88 e0       	ldi	r24, 0x08	; 8
    a170:	60 e0       	ldi	r22, 0x00	; 0
    a172:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
}
    a176:	6a 96       	adiw	r28, 0x1a	; 26
    a178:	cd bf       	out	0x3d, r28	; 61
    a17a:	de bf       	out	0x3e, r29	; 62
    a17c:	df 91       	pop	r29
    a17e:	cf 91       	pop	r28
    a180:	1f 91       	pop	r17
    a182:	0f 91       	pop	r16
    a184:	08 95       	ret

0000a186 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a186:	0f 93       	push	r16
    a188:	1f 93       	push	r17
    a18a:	cf 93       	push	r28
    a18c:	df 93       	push	r29
    a18e:	cd b7       	in	r28, 0x3d	; 61
    a190:	de b7       	in	r29, 0x3e	; 62
    a192:	2e 97       	sbiw	r28, 0x0e	; 14
    a194:	cd bf       	out	0x3d, r28	; 61
    a196:	de bf       	out	0x3e, r29	; 62
    a198:	6f 83       	std	Y+7, r22	; 0x07
    a19a:	78 87       	std	Y+8, r23	; 0x08
    a19c:	89 87       	std	Y+9, r24	; 0x09
    a19e:	9a 87       	std	Y+10, r25	; 0x0a
    a1a0:	4b 87       	std	Y+11, r20	; 0x0b
    a1a2:	5c 87       	std	Y+12, r21	; 0x0c
    a1a4:	2d 87       	std	Y+13, r18	; 0x0d
    a1a6:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a1a8:	88 e0       	ldi	r24, 0x08	; 8
    a1aa:	60 e0       	ldi	r22, 0x00	; 0
    a1ac:	0e 94 36 34 	call	0x686c	; 0x686c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a1b0:	80 e0       	ldi	r24, 0x00	; 0
    a1b2:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    a1b6:	81 e0       	ldi	r24, 0x01	; 1
    a1b8:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a1bc:	00 00       	nop
    a1be:	2f 81       	ldd	r18, Y+7	; 0x07
    a1c0:	38 85       	ldd	r19, Y+8	; 0x08
    a1c2:	49 85       	ldd	r20, Y+9	; 0x09
    a1c4:	5a 85       	ldd	r21, Y+10	; 0x0a
    a1c6:	82 e1       	ldi	r24, 0x12	; 18
    a1c8:	ba 01       	movw	r22, r20
    a1ca:	a9 01       	movw	r20, r18
    a1cc:	2f ef       	ldi	r18, 0xFF	; 255
    a1ce:	08 e0       	ldi	r16, 0x08	; 8
    a1d0:	10 e0       	ldi	r17, 0x00	; 0
    a1d2:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
    a1d6:	88 23       	and	r24, r24
    a1d8:	91 f7       	brne	.-28     	; 0xa1be <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a1da:	19 82       	std	Y+1, r1	; 0x01
    a1dc:	1a 82       	std	Y+2, r1	; 0x02
    a1de:	4b c0       	rjmp	.+150    	; 0xa276 <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a1e0:	8f ef       	ldi	r24, 0xFF	; 255
    a1e2:	80 93 ae 50 	sts	0x50AE, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a1e6:	05 c0       	rjmp	.+10     	; 0xa1f2 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a1e8:	8f ef       	ldi	r24, 0xFF	; 255
    a1ea:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a1ee:	80 93 ae 50 	sts	0x50AE, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a1f2:	80 91 ae 50 	lds	r24, 0x50AE
    a1f6:	8e 3f       	cpi	r24, 0xFE	; 254
    a1f8:	b9 f7       	brne	.-18     	; 0xa1e8 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a1fa:	1b 82       	std	Y+3, r1	; 0x03
    a1fc:	1c 82       	std	Y+4, r1	; 0x04
    a1fe:	19 c0       	rjmp	.+50     	; 0xa232 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a200:	89 81       	ldd	r24, Y+1	; 0x01
    a202:	9a 81       	ldd	r25, Y+2	; 0x02
    a204:	9c 01       	movw	r18, r24
    a206:	32 2f       	mov	r19, r18
    a208:	22 27       	eor	r18, r18
    a20a:	33 0f       	add	r19, r19
    a20c:	8b 81       	ldd	r24, Y+3	; 0x03
    a20e:	9c 81       	ldd	r25, Y+4	; 0x04
    a210:	82 0f       	add	r24, r18
    a212:	93 1f       	adc	r25, r19
    a214:	2b 85       	ldd	r18, Y+11	; 0x0b
    a216:	3c 85       	ldd	r19, Y+12	; 0x0c
    a218:	89 01       	movw	r16, r18
    a21a:	08 0f       	add	r16, r24
    a21c:	19 1f       	adc	r17, r25
    a21e:	8f ef       	ldi	r24, 0xFF	; 255
    a220:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a224:	f8 01       	movw	r30, r16
    a226:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a228:	8b 81       	ldd	r24, Y+3	; 0x03
    a22a:	9c 81       	ldd	r25, Y+4	; 0x04
    a22c:	01 96       	adiw	r24, 0x01	; 1
    a22e:	8b 83       	std	Y+3, r24	; 0x03
    a230:	9c 83       	std	Y+4, r25	; 0x04
    a232:	8b 81       	ldd	r24, Y+3	; 0x03
    a234:	9c 81       	ldd	r25, Y+4	; 0x04
    a236:	f2 e0       	ldi	r31, 0x02	; 2
    a238:	80 30       	cpi	r24, 0x00	; 0
    a23a:	9f 07       	cpc	r25, r31
    a23c:	0c f3       	brlt	.-62     	; 0xa200 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a23e:	1d 82       	std	Y+5, r1	; 0x05
    a240:	1e 82       	std	Y+6, r1	; 0x06
    a242:	0f c0       	rjmp	.+30     	; 0xa262 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a244:	8f ef       	ldi	r24, 0xFF	; 255
    a246:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a24a:	28 2f       	mov	r18, r24
    a24c:	8d 81       	ldd	r24, Y+5	; 0x05
    a24e:	9e 81       	ldd	r25, Y+6	; 0x06
    a250:	83 55       	subi	r24, 0x53	; 83
    a252:	9f 4a       	sbci	r25, 0xAF	; 175
    a254:	fc 01       	movw	r30, r24
    a256:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a258:	8d 81       	ldd	r24, Y+5	; 0x05
    a25a:	9e 81       	ldd	r25, Y+6	; 0x06
    a25c:	01 96       	adiw	r24, 0x01	; 1
    a25e:	8d 83       	std	Y+5, r24	; 0x05
    a260:	9e 83       	std	Y+6, r25	; 0x06
    a262:	8d 81       	ldd	r24, Y+5	; 0x05
    a264:	9e 81       	ldd	r25, Y+6	; 0x06
    a266:	82 30       	cpi	r24, 0x02	; 2
    a268:	91 05       	cpc	r25, r1
    a26a:	64 f3       	brlt	.-40     	; 0xa244 <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a26c:	89 81       	ldd	r24, Y+1	; 0x01
    a26e:	9a 81       	ldd	r25, Y+2	; 0x02
    a270:	01 96       	adiw	r24, 0x01	; 1
    a272:	89 83       	std	Y+1, r24	; 0x01
    a274:	9a 83       	std	Y+2, r25	; 0x02
    a276:	29 81       	ldd	r18, Y+1	; 0x01
    a278:	3a 81       	ldd	r19, Y+2	; 0x02
    a27a:	8d 85       	ldd	r24, Y+13	; 0x0d
    a27c:	9e 85       	ldd	r25, Y+14	; 0x0e
    a27e:	28 17       	cp	r18, r24
    a280:	39 07       	cpc	r19, r25
    a282:	0c f4       	brge	.+2      	; 0xa286 <SD_read_multiple_blocks+0x100>
    a284:	ad cf       	rjmp	.-166    	; 0xa1e0 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a286:	8c e0       	ldi	r24, 0x0C	; 12
    a288:	40 e0       	ldi	r20, 0x00	; 0
    a28a:	50 e0       	ldi	r21, 0x00	; 0
    a28c:	ba 01       	movw	r22, r20
    a28e:	2f ef       	ldi	r18, 0xFF	; 255
    a290:	08 e0       	ldi	r16, 0x08	; 8
    a292:	10 e0       	ldi	r17, 0x00	; 0
    a294:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a298:	8f ef       	ldi	r24, 0xFF	; 255
    a29a:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a29e:	80 93 ad 50 	sts	0x50AD, r24
	Buffer[1] = FILLER_BYTE;
    a2a2:	10 92 ae 50 	sts	0x50AE, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a2a6:	05 c0       	rjmp	.+10     	; 0xa2b2 <SD_read_multiple_blocks+0x12c>
    a2a8:	8f ef       	ldi	r24, 0xFF	; 255
    a2aa:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
    a2ae:	80 93 ae 50 	sts	0x50AE, r24
    a2b2:	80 91 ae 50 	lds	r24, 0x50AE
    a2b6:	8f 3f       	cpi	r24, 0xFF	; 255
    a2b8:	b9 f7       	brne	.-18     	; 0xa2a8 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a2ba:	80 e0       	ldi	r24, 0x00	; 0
    a2bc:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    a2c0:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a2c4:	88 e0       	ldi	r24, 0x08	; 8
    a2c6:	60 e0       	ldi	r22, 0x00	; 0
    a2c8:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
}
    a2cc:	2e 96       	adiw	r28, 0x0e	; 14
    a2ce:	cd bf       	out	0x3d, r28	; 61
    a2d0:	de bf       	out	0x3e, r29	; 62
    a2d2:	df 91       	pop	r29
    a2d4:	cf 91       	pop	r28
    a2d6:	1f 91       	pop	r17
    a2d8:	0f 91       	pop	r16
    a2da:	08 95       	ret

0000a2dc <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a2dc:	cf 93       	push	r28
    a2de:	df 93       	push	r29
    a2e0:	cd b7       	in	r28, 0x3d	; 61
    a2e2:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a2e4:	88 e0       	ldi	r24, 0x08	; 8
    a2e6:	60 e0       	ldi	r22, 0x00	; 0
    a2e8:	0e 94 07 33 	call	0x660e	; 0x660e <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a2ec:	88 e0       	ldi	r24, 0x08	; 8
    a2ee:	60 e0       	ldi	r22, 0x00	; 0
    a2f0:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a2f4:	80 e0       	ldi	r24, 0x00	; 0
    a2f6:	0e 94 a3 37 	call	0x6f46	; 0x6f46 <SPIInit>
	SPICS(TRUE);
    a2fa:	81 e0       	ldi	r24, 0x01	; 1
    a2fc:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a300:	8f ef       	ldi	r24, 0xFF	; 255
    a302:	0e 94 85 4d 	call	0x9b0a	; 0x9b0a <SPI_write>
	SPICS(FALSE);	//stop spi
    a306:	80 e0       	ldi	r24, 0x00	; 0
    a308:	0e 94 f8 37 	call	0x6ff0	; 0x6ff0 <SPICS>
	SPIDisable();
    a30c:	0e 94 10 38 	call	0x7020	; 0x7020 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a310:	80 e0       	ldi	r24, 0x00	; 0
    a312:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a316:	80 e0       	ldi	r24, 0x00	; 0
    a318:	0e 94 9d 34 	call	0x693a	; 0x693a <Ext1Power>
}
    a31c:	df 91       	pop	r29
    a31e:	cf 91       	pop	r28
    a320:	08 95       	ret

0000a322 <__muldi3>:
    a322:	a0 e3       	ldi	r26, 0x30	; 48
    a324:	b0 e0       	ldi	r27, 0x00	; 0
    a326:	e7 e9       	ldi	r30, 0x97	; 151
    a328:	f1 e5       	ldi	r31, 0x51	; 81
    a32a:	0c 94 2f 5d 	jmp	0xba5e	; 0xba5e <__prologue_saves__+0x4>
    a32e:	29 8f       	std	Y+25, r18	; 0x19
    a330:	3a 8f       	std	Y+26, r19	; 0x1a
    a332:	4b 8f       	std	Y+27, r20	; 0x1b
    a334:	5c 8f       	std	Y+28, r21	; 0x1c
    a336:	6d 8f       	std	Y+29, r22	; 0x1d
    a338:	7e 8f       	std	Y+30, r23	; 0x1e
    a33a:	8f 8f       	std	Y+31, r24	; 0x1f
    a33c:	98 a3       	lds	r25, 0x58
    a33e:	a9 8a       	std	Y+17, r10	; 0x11
    a340:	ba 8a       	std	Y+18, r11	; 0x12
    a342:	cb 8a       	std	Y+19, r12	; 0x13
    a344:	dc 8a       	std	Y+20, r13	; 0x14
    a346:	ed 8a       	std	Y+21, r14	; 0x15
    a348:	fe 8a       	std	Y+22, r15	; 0x16
    a34a:	0f 8b       	std	Y+23, r16	; 0x17
    a34c:	18 8f       	std	Y+24, r17	; 0x18
    a34e:	09 8d       	ldd	r16, Y+25	; 0x19
    a350:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a352:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a354:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a356:	09 a3       	lds	r16, 0x59
    a358:	1a a3       	lds	r17, 0x5a
    a35a:	2b a3       	lds	r18, 0x5b
    a35c:	3c a3       	lds	r19, 0x5c
    a35e:	68 01       	movw	r12, r16
    a360:	79 01       	movw	r14, r18
    a362:	8f ef       	ldi	r24, 0xFF	; 255
    a364:	9f ef       	ldi	r25, 0xFF	; 255
    a366:	a0 e0       	ldi	r26, 0x00	; 0
    a368:	b0 e0       	ldi	r27, 0x00	; 0
    a36a:	c8 22       	and	r12, r24
    a36c:	d9 22       	and	r13, r25
    a36e:	ea 22       	and	r14, r26
    a370:	fb 22       	and	r15, r27
    a372:	89 01       	movw	r16, r18
    a374:	22 27       	eor	r18, r18
    a376:	33 27       	eor	r19, r19
    a378:	09 a7       	lds	r16, 0x79
    a37a:	1a a7       	lds	r17, 0x7a
    a37c:	2b a7       	lds	r18, 0x7b
    a37e:	3c a7       	lds	r19, 0x7c
    a380:	09 89       	ldd	r16, Y+17	; 0x11
    a382:	1a 89       	ldd	r17, Y+18	; 0x12
    a384:	2b 89       	ldd	r18, Y+19	; 0x13
    a386:	3c 89       	ldd	r19, Y+20	; 0x14
    a388:	0d a3       	lds	r16, 0x5d
    a38a:	1e a3       	lds	r17, 0x5e
    a38c:	2f a3       	lds	r18, 0x5f
    a38e:	38 a7       	lds	r19, 0x78
    a390:	48 01       	movw	r8, r16
    a392:	59 01       	movw	r10, r18
    a394:	88 22       	and	r8, r24
    a396:	99 22       	and	r9, r25
    a398:	aa 22       	and	r10, r26
    a39a:	bb 22       	and	r11, r27
    a39c:	29 01       	movw	r4, r18
    a39e:	66 24       	eor	r6, r6
    a3a0:	77 24       	eor	r7, r7
    a3a2:	c5 01       	movw	r24, r10
    a3a4:	b4 01       	movw	r22, r8
    a3a6:	a7 01       	movw	r20, r14
    a3a8:	96 01       	movw	r18, r12
    a3aa:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    a3ae:	6d a7       	lds	r22, 0x7d
    a3b0:	7e a7       	lds	r23, 0x7e
    a3b2:	8f a7       	lds	r24, 0x7f
    a3b4:	98 ab       	sts	0x58, r25
    a3b6:	c3 01       	movw	r24, r6
    a3b8:	b2 01       	movw	r22, r4
    a3ba:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    a3be:	6b 01       	movw	r12, r22
    a3c0:	7c 01       	movw	r14, r24
    a3c2:	c5 01       	movw	r24, r10
    a3c4:	b4 01       	movw	r22, r8
    a3c6:	29 a5       	lds	r18, 0x69
    a3c8:	3a a5       	lds	r19, 0x6a
    a3ca:	4b a5       	lds	r20, 0x6b
    a3cc:	5c a5       	lds	r21, 0x6c
    a3ce:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    a3d2:	4b 01       	movw	r8, r22
    a3d4:	5c 01       	movw	r10, r24
    a3d6:	c3 01       	movw	r24, r6
    a3d8:	b2 01       	movw	r22, r4
    a3da:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    a3de:	ab 01       	movw	r20, r22
    a3e0:	bc 01       	movw	r22, r24
    a3e2:	c8 0c       	add	r12, r8
    a3e4:	d9 1c       	adc	r13, r9
    a3e6:	ea 1c       	adc	r14, r10
    a3e8:	fb 1c       	adc	r15, r11
    a3ea:	0d a5       	lds	r16, 0x6d
    a3ec:	1e a5       	lds	r17, 0x6e
    a3ee:	2f a5       	lds	r18, 0x6f
    a3f0:	38 a9       	sts	0x48, r19
    a3f2:	c9 01       	movw	r24, r18
    a3f4:	aa 27       	eor	r26, r26
    a3f6:	bb 27       	eor	r27, r27
    a3f8:	c8 0e       	add	r12, r24
    a3fa:	d9 1e       	adc	r13, r25
    a3fc:	ea 1e       	adc	r14, r26
    a3fe:	fb 1e       	adc	r15, r27
    a400:	c8 14       	cp	r12, r8
    a402:	d9 04       	cpc	r13, r9
    a404:	ea 04       	cpc	r14, r10
    a406:	fb 04       	cpc	r15, r11
    a408:	20 f4       	brcc	.+8      	; 0xa412 <__muldi3+0xf0>
    a40a:	40 50       	subi	r20, 0x00	; 0
    a40c:	50 40       	sbci	r21, 0x00	; 0
    a40e:	6f 4f       	sbci	r22, 0xFF	; 255
    a410:	7f 4f       	sbci	r23, 0xFF	; 255
    a412:	c7 01       	movw	r24, r14
    a414:	aa 27       	eor	r26, r26
    a416:	bb 27       	eor	r27, r27
    a418:	84 0f       	add	r24, r20
    a41a:	95 1f       	adc	r25, r21
    a41c:	a6 1f       	adc	r26, r22
    a41e:	b7 1f       	adc	r27, r23
    a420:	8d 83       	std	Y+5, r24	; 0x05
    a422:	9e 83       	std	Y+6, r25	; 0x06
    a424:	af 83       	std	Y+7, r26	; 0x07
    a426:	b8 87       	std	Y+8, r27	; 0x08
    a428:	76 01       	movw	r14, r12
    a42a:	dd 24       	eor	r13, r13
    a42c:	cc 24       	eor	r12, r12
    a42e:	4d a5       	lds	r20, 0x6d
    a430:	5e a5       	lds	r21, 0x6e
    a432:	6f a5       	lds	r22, 0x6f
    a434:	78 a9       	sts	0x48, r23
    a436:	60 70       	andi	r22, 0x00	; 0
    a438:	70 70       	andi	r23, 0x00	; 0
    a43a:	c4 0e       	add	r12, r20
    a43c:	d5 1e       	adc	r13, r21
    a43e:	e6 1e       	adc	r14, r22
    a440:	f7 1e       	adc	r15, r23
    a442:	c9 82       	std	Y+1, r12	; 0x01
    a444:	da 82       	std	Y+2, r13	; 0x02
    a446:	eb 82       	std	Y+3, r14	; 0x03
    a448:	fc 82       	std	Y+4, r15	; 0x04
    a44a:	1c 2d       	mov	r17, r12
    a44c:	0a 81       	ldd	r16, Y+2	; 0x02
    a44e:	8b 80       	ldd	r8, Y+3	; 0x03
    a450:	4c 80       	ldd	r4, Y+4	; 0x04
    a452:	8d 87       	std	Y+13, r24	; 0x0d
    a454:	8e 81       	ldd	r24, Y+6	; 0x06
    a456:	8e 87       	std	Y+14, r24	; 0x0e
    a458:	8f 81       	ldd	r24, Y+7	; 0x07
    a45a:	8f 87       	std	Y+15, r24	; 0x0f
    a45c:	88 85       	ldd	r24, Y+8	; 0x08
    a45e:	88 8b       	std	Y+16, r24	; 0x10
    a460:	2d 89       	ldd	r18, Y+21	; 0x15
    a462:	3e 89       	ldd	r19, Y+22	; 0x16
    a464:	4f 89       	ldd	r20, Y+23	; 0x17
    a466:	58 8d       	ldd	r21, Y+24	; 0x18
    a468:	69 a1       	lds	r22, 0x49
    a46a:	7a a1       	lds	r23, 0x4a
    a46c:	8b a1       	lds	r24, 0x4b
    a46e:	9c a1       	lds	r25, 0x4c
    a470:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    a474:	6b 01       	movw	r12, r22
    a476:	7c 01       	movw	r14, r24
    a478:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a47a:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a47c:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a47e:	58 a1       	lds	r21, 0x48
    a480:	6d a1       	lds	r22, 0x4d
    a482:	7e a1       	lds	r23, 0x4e
    a484:	8f a1       	lds	r24, 0x4f
    a486:	98 a5       	lds	r25, 0x68
    a488:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    a48c:	dc 01       	movw	r26, r24
    a48e:	cb 01       	movw	r24, r22
    a490:	c8 0e       	add	r12, r24
    a492:	d9 1e       	adc	r13, r25
    a494:	ea 1e       	adc	r14, r26
    a496:	fb 1e       	adc	r15, r27
    a498:	8d 85       	ldd	r24, Y+13	; 0x0d
    a49a:	9e 85       	ldd	r25, Y+14	; 0x0e
    a49c:	af 85       	ldd	r26, Y+15	; 0x0f
    a49e:	b8 89       	ldd	r27, Y+16	; 0x10
    a4a0:	8c 0d       	add	r24, r12
    a4a2:	9d 1d       	adc	r25, r13
    a4a4:	ae 1d       	adc	r26, r14
    a4a6:	bf 1d       	adc	r27, r15
    a4a8:	8d 87       	std	Y+13, r24	; 0x0d
    a4aa:	9e 87       	std	Y+14, r25	; 0x0e
    a4ac:	af 87       	std	Y+15, r26	; 0x0f
    a4ae:	b8 8b       	std	Y+16, r27	; 0x10
    a4b0:	68 2f       	mov	r22, r24
    a4b2:	7e 85       	ldd	r23, Y+14	; 0x0e
    a4b4:	21 2f       	mov	r18, r17
    a4b6:	30 2f       	mov	r19, r16
    a4b8:	48 2d       	mov	r20, r8
    a4ba:	54 2d       	mov	r21, r4
    a4bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    a4be:	98 89       	ldd	r25, Y+16	; 0x10
    a4c0:	e0 96       	adiw	r28, 0x30	; 48
    a4c2:	e0 e1       	ldi	r30, 0x10	; 16
    a4c4:	0c 94 48 5d 	jmp	0xba90	; 0xba90 <__epilogue_restores__+0x4>

0000a4c8 <__ashldi3>:
    a4c8:	cf 92       	push	r12
    a4ca:	df 92       	push	r13
    a4cc:	ef 92       	push	r14
    a4ce:	ff 92       	push	r15
    a4d0:	0f 93       	push	r16
    a4d2:	cf 93       	push	r28
    a4d4:	df 93       	push	r29
    a4d6:	cd b7       	in	r28, 0x3d	; 61
    a4d8:	de b7       	in	r29, 0x3e	; 62
    a4da:	60 97       	sbiw	r28, 0x10	; 16
    a4dc:	cd bf       	out	0x3d, r28	; 61
    a4de:	de bf       	out	0x3e, r29	; 62
    a4e0:	00 23       	and	r16, r16
    a4e2:	09 f4       	brne	.+2      	; 0xa4e6 <__ashldi3+0x1e>
    a4e4:	5a c0       	rjmp	.+180    	; 0xa59a <__ashldi3+0xd2>
    a4e6:	29 87       	std	Y+9, r18	; 0x09
    a4e8:	3a 87       	std	Y+10, r19	; 0x0a
    a4ea:	4b 87       	std	Y+11, r20	; 0x0b
    a4ec:	5c 87       	std	Y+12, r21	; 0x0c
    a4ee:	6d 87       	std	Y+13, r22	; 0x0d
    a4f0:	7e 87       	std	Y+14, r23	; 0x0e
    a4f2:	8f 87       	std	Y+15, r24	; 0x0f
    a4f4:	98 8b       	std	Y+16, r25	; 0x10
    a4f6:	80 e2       	ldi	r24, 0x20	; 32
    a4f8:	80 1b       	sub	r24, r16
    a4fa:	49 85       	ldd	r20, Y+9	; 0x09
    a4fc:	5a 85       	ldd	r21, Y+10	; 0x0a
    a4fe:	6b 85       	ldd	r22, Y+11	; 0x0b
    a500:	7c 85       	ldd	r23, Y+12	; 0x0c
    a502:	18 16       	cp	r1, r24
    a504:	b4 f0       	brlt	.+44     	; 0xa532 <__ashldi3+0x6a>
    a506:	19 82       	std	Y+1, r1	; 0x01
    a508:	1a 82       	std	Y+2, r1	; 0x02
    a50a:	1b 82       	std	Y+3, r1	; 0x03
    a50c:	1c 82       	std	Y+4, r1	; 0x04
    a50e:	99 27       	eor	r25, r25
    a510:	87 fd       	sbrc	r24, 7
    a512:	90 95       	com	r25
    a514:	90 95       	com	r25
    a516:	81 95       	neg	r24
    a518:	9f 4f       	sbci	r25, 0xFF	; 255
    a51a:	04 c0       	rjmp	.+8      	; 0xa524 <__ashldi3+0x5c>
    a51c:	44 0f       	add	r20, r20
    a51e:	55 1f       	adc	r21, r21
    a520:	66 1f       	adc	r22, r22
    a522:	77 1f       	adc	r23, r23
    a524:	8a 95       	dec	r24
    a526:	d2 f7       	brpl	.-12     	; 0xa51c <__ashldi3+0x54>
    a528:	4d 83       	std	Y+5, r20	; 0x05
    a52a:	5e 83       	std	Y+6, r21	; 0x06
    a52c:	6f 83       	std	Y+7, r22	; 0x07
    a52e:	78 87       	std	Y+8, r23	; 0x08
    a530:	2c c0       	rjmp	.+88     	; 0xa58a <__ashldi3+0xc2>
    a532:	6a 01       	movw	r12, r20
    a534:	7b 01       	movw	r14, r22
    a536:	00 2e       	mov	r0, r16
    a538:	04 c0       	rjmp	.+8      	; 0xa542 <__ashldi3+0x7a>
    a53a:	cc 0c       	add	r12, r12
    a53c:	dd 1c       	adc	r13, r13
    a53e:	ee 1c       	adc	r14, r14
    a540:	ff 1c       	adc	r15, r15
    a542:	0a 94       	dec	r0
    a544:	d2 f7       	brpl	.-12     	; 0xa53a <__ashldi3+0x72>
    a546:	c9 82       	std	Y+1, r12	; 0x01
    a548:	da 82       	std	Y+2, r13	; 0x02
    a54a:	eb 82       	std	Y+3, r14	; 0x03
    a54c:	fc 82       	std	Y+4, r15	; 0x04
    a54e:	6a 01       	movw	r12, r20
    a550:	7b 01       	movw	r14, r22
    a552:	04 c0       	rjmp	.+8      	; 0xa55c <__ashldi3+0x94>
    a554:	f6 94       	lsr	r15
    a556:	e7 94       	ror	r14
    a558:	d7 94       	ror	r13
    a55a:	c7 94       	ror	r12
    a55c:	8a 95       	dec	r24
    a55e:	d2 f7       	brpl	.-12     	; 0xa554 <__ashldi3+0x8c>
    a560:	d7 01       	movw	r26, r14
    a562:	c6 01       	movw	r24, r12
    a564:	4d 85       	ldd	r20, Y+13	; 0x0d
    a566:	5e 85       	ldd	r21, Y+14	; 0x0e
    a568:	6f 85       	ldd	r22, Y+15	; 0x0f
    a56a:	78 89       	ldd	r23, Y+16	; 0x10
    a56c:	04 c0       	rjmp	.+8      	; 0xa576 <__ashldi3+0xae>
    a56e:	44 0f       	add	r20, r20
    a570:	55 1f       	adc	r21, r21
    a572:	66 1f       	adc	r22, r22
    a574:	77 1f       	adc	r23, r23
    a576:	0a 95       	dec	r16
    a578:	d2 f7       	brpl	.-12     	; 0xa56e <__ashldi3+0xa6>
    a57a:	84 2b       	or	r24, r20
    a57c:	95 2b       	or	r25, r21
    a57e:	a6 2b       	or	r26, r22
    a580:	b7 2b       	or	r27, r23
    a582:	8d 83       	std	Y+5, r24	; 0x05
    a584:	9e 83       	std	Y+6, r25	; 0x06
    a586:	af 83       	std	Y+7, r26	; 0x07
    a588:	b8 87       	std	Y+8, r27	; 0x08
    a58a:	29 81       	ldd	r18, Y+1	; 0x01
    a58c:	3a 81       	ldd	r19, Y+2	; 0x02
    a58e:	4b 81       	ldd	r20, Y+3	; 0x03
    a590:	5c 81       	ldd	r21, Y+4	; 0x04
    a592:	6d 81       	ldd	r22, Y+5	; 0x05
    a594:	7e 81       	ldd	r23, Y+6	; 0x06
    a596:	8f 81       	ldd	r24, Y+7	; 0x07
    a598:	98 85       	ldd	r25, Y+8	; 0x08
    a59a:	60 96       	adiw	r28, 0x10	; 16
    a59c:	cd bf       	out	0x3d, r28	; 61
    a59e:	de bf       	out	0x3e, r29	; 62
    a5a0:	df 91       	pop	r29
    a5a2:	cf 91       	pop	r28
    a5a4:	0f 91       	pop	r16
    a5a6:	ff 90       	pop	r15
    a5a8:	ef 90       	pop	r14
    a5aa:	df 90       	pop	r13
    a5ac:	cf 90       	pop	r12
    a5ae:	08 95       	ret

0000a5b0 <__divdi3>:
    a5b0:	a8 e4       	ldi	r26, 0x48	; 72
    a5b2:	b0 e0       	ldi	r27, 0x00	; 0
    a5b4:	ee ed       	ldi	r30, 0xDE	; 222
    a5b6:	f2 e5       	ldi	r31, 0x52	; 82
    a5b8:	0c 94 2e 5d 	jmp	0xba5c	; 0xba5c <__prologue_saves__+0x2>
    a5bc:	f5 01       	movw	r30, r10
    a5be:	29 a3       	lds	r18, 0x59
    a5c0:	3a a3       	lds	r19, 0x5a
    a5c2:	4b a3       	lds	r20, 0x5b
    a5c4:	5c a3       	lds	r21, 0x5c
    a5c6:	6d a3       	lds	r22, 0x5d
    a5c8:	7e a3       	lds	r23, 0x5e
    a5ca:	8f a3       	lds	r24, 0x5f
    a5cc:	98 a7       	lds	r25, 0x78
    a5ce:	a9 8e       	std	Y+25, r10	; 0x19
    a5d0:	fa 8f       	std	Y+26, r31	; 0x1a
    a5d2:	cb 8e       	std	Y+27, r12	; 0x1b
    a5d4:	dc 8e       	std	Y+28, r13	; 0x1c
    a5d6:	ed 8e       	std	Y+29, r14	; 0x1d
    a5d8:	fe 8e       	std	Y+30, r15	; 0x1e
    a5da:	0f 8f       	std	Y+31, r16	; 0x1f
    a5dc:	18 a3       	lds	r17, 0x58
    a5de:	8d a0       	lds	r24, 0x8d
    a5e0:	9e a0       	lds	r25, 0x8e
    a5e2:	af a0       	lds	r26, 0x8f
    a5e4:	b8 a4       	lds	r27, 0xa8
    a5e6:	b7 fe       	sbrs	r11, 7
    a5e8:	67 c0       	rjmp	.+206    	; 0xa6b8 <__divdi3+0x108>
    a5ea:	21 95       	neg	r18
    a5ec:	b1 e0       	ldi	r27, 0x01	; 1
    a5ee:	12 16       	cp	r1, r18
    a5f0:	08 f0       	brcs	.+2      	; 0xa5f4 <__divdi3+0x44>
    a5f2:	b0 e0       	ldi	r27, 0x00	; 0
    a5f4:	31 95       	neg	r19
    a5f6:	a1 e0       	ldi	r26, 0x01	; 1
    a5f8:	13 16       	cp	r1, r19
    a5fa:	08 f0       	brcs	.+2      	; 0xa5fe <__divdi3+0x4e>
    a5fc:	a0 e0       	ldi	r26, 0x00	; 0
    a5fe:	b3 2e       	mov	r11, r19
    a600:	bb 1a       	sub	r11, r27
    a602:	bb 2d       	mov	r27, r11
    a604:	88 24       	eor	r8, r8
    a606:	83 94       	inc	r8
    a608:	3b 15       	cp	r19, r11
    a60a:	08 f0       	brcs	.+2      	; 0xa60e <__divdi3+0x5e>
    a60c:	88 24       	eor	r8, r8
    a60e:	a8 29       	or	r26, r8
    a610:	41 95       	neg	r20
    a612:	31 e0       	ldi	r19, 0x01	; 1
    a614:	14 16       	cp	r1, r20
    a616:	08 f0       	brcs	.+2      	; 0xa61a <__divdi3+0x6a>
    a618:	30 e0       	ldi	r19, 0x00	; 0
    a61a:	b4 2e       	mov	r11, r20
    a61c:	ba 1a       	sub	r11, r26
    a61e:	ab 2d       	mov	r26, r11
    a620:	88 24       	eor	r8, r8
    a622:	83 94       	inc	r8
    a624:	4b 15       	cp	r20, r11
    a626:	08 f0       	brcs	.+2      	; 0xa62a <__divdi3+0x7a>
    a628:	88 24       	eor	r8, r8
    a62a:	38 29       	or	r19, r8
    a62c:	51 95       	neg	r21
    a62e:	41 e0       	ldi	r20, 0x01	; 1
    a630:	15 16       	cp	r1, r21
    a632:	08 f0       	brcs	.+2      	; 0xa636 <__divdi3+0x86>
    a634:	40 e0       	ldi	r20, 0x00	; 0
    a636:	45 2e       	mov	r4, r21
    a638:	43 1a       	sub	r4, r19
    a63a:	31 e0       	ldi	r19, 0x01	; 1
    a63c:	54 15       	cp	r21, r4
    a63e:	08 f0       	brcs	.+2      	; 0xa642 <__divdi3+0x92>
    a640:	30 e0       	ldi	r19, 0x00	; 0
    a642:	43 2b       	or	r20, r19
    a644:	61 95       	neg	r22
    a646:	31 e0       	ldi	r19, 0x01	; 1
    a648:	16 16       	cp	r1, r22
    a64a:	08 f0       	brcs	.+2      	; 0xa64e <__divdi3+0x9e>
    a64c:	30 e0       	ldi	r19, 0x00	; 0
    a64e:	86 2e       	mov	r8, r22
    a650:	84 1a       	sub	r8, r20
    a652:	41 e0       	ldi	r20, 0x01	; 1
    a654:	68 15       	cp	r22, r8
    a656:	08 f0       	brcs	.+2      	; 0xa65a <__divdi3+0xaa>
    a658:	40 e0       	ldi	r20, 0x00	; 0
    a65a:	34 2b       	or	r19, r20
    a65c:	71 95       	neg	r23
    a65e:	41 e0       	ldi	r20, 0x01	; 1
    a660:	17 16       	cp	r1, r23
    a662:	08 f0       	brcs	.+2      	; 0xa666 <__divdi3+0xb6>
    a664:	40 e0       	ldi	r20, 0x00	; 0
    a666:	57 2f       	mov	r21, r23
    a668:	53 1b       	sub	r21, r19
    a66a:	31 e0       	ldi	r19, 0x01	; 1
    a66c:	75 17       	cp	r23, r21
    a66e:	08 f0       	brcs	.+2      	; 0xa672 <__divdi3+0xc2>
    a670:	30 e0       	ldi	r19, 0x00	; 0
    a672:	43 2b       	or	r20, r19
    a674:	81 95       	neg	r24
    a676:	31 e0       	ldi	r19, 0x01	; 1
    a678:	18 16       	cp	r1, r24
    a67a:	08 f0       	brcs	.+2      	; 0xa67e <__divdi3+0xce>
    a67c:	30 e0       	ldi	r19, 0x00	; 0
    a67e:	68 2f       	mov	r22, r24
    a680:	64 1b       	sub	r22, r20
    a682:	46 2f       	mov	r20, r22
    a684:	61 e0       	ldi	r22, 0x01	; 1
    a686:	84 17       	cp	r24, r20
    a688:	08 f0       	brcs	.+2      	; 0xa68c <__divdi3+0xdc>
    a68a:	60 e0       	ldi	r22, 0x00	; 0
    a68c:	36 2b       	or	r19, r22
    a68e:	91 95       	neg	r25
    a690:	93 1b       	sub	r25, r19
    a692:	29 a3       	lds	r18, 0x59
    a694:	ba a3       	lds	r27, 0x5a
    a696:	ab a3       	lds	r26, 0x5b
    a698:	4c a2       	lds	r20, 0x9c
    a69a:	8d a2       	lds	r24, 0x9d
    a69c:	5e a3       	lds	r21, 0x5e
    a69e:	4f a3       	lds	r20, 0x5f
    a6a0:	98 a7       	lds	r25, 0x78
    a6a2:	8f ef       	ldi	r24, 0xFF	; 255
    a6a4:	9f ef       	ldi	r25, 0xFF	; 255
    a6a6:	af ef       	ldi	r26, 0xFF	; 255
    a6a8:	bf ef       	ldi	r27, 0xFF	; 255
    a6aa:	25 96       	adiw	r28, 0x05	; 5
    a6ac:	8c af       	sts	0x7c, r24
    a6ae:	9d af       	sts	0x7d, r25
    a6b0:	ae af       	sts	0x7e, r26
    a6b2:	bf af       	sts	0x7f, r27
    a6b4:	25 97       	sbiw	r28, 0x05	; 5
    a6b6:	06 c0       	rjmp	.+12     	; 0xa6c4 <__divdi3+0x114>
    a6b8:	25 96       	adiw	r28, 0x05	; 5
    a6ba:	1c ae       	sts	0xbc, r17
    a6bc:	1d ae       	sts	0xbd, r17
    a6be:	1e ae       	sts	0xbe, r17
    a6c0:	1f ae       	sts	0xbf, r17
    a6c2:	25 97       	sbiw	r28, 0x05	; 5
    a6c4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a6c6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a6c8:	af 8d       	ldd	r26, Y+31	; 0x1f
    a6ca:	b8 a1       	lds	r27, 0x48
    a6cc:	b7 ff       	sbrs	r27, 7
    a6ce:	68 c0       	rjmp	.+208    	; 0xa7a0 <__divdi3+0x1f0>
    a6d0:	25 96       	adiw	r28, 0x05	; 5
    a6d2:	2c ad       	sts	0x6c, r18
    a6d4:	3d ad       	sts	0x6d, r19
    a6d6:	4e ad       	sts	0x6e, r20
    a6d8:	5f ad       	sts	0x6f, r21
    a6da:	25 97       	sbiw	r28, 0x05	; 5
    a6dc:	20 95       	com	r18
    a6de:	30 95       	com	r19
    a6e0:	40 95       	com	r20
    a6e2:	50 95       	com	r21
    a6e4:	25 96       	adiw	r28, 0x05	; 5
    a6e6:	2c af       	sts	0x7c, r18
    a6e8:	3d af       	sts	0x7d, r19
    a6ea:	4e af       	sts	0x7e, r20
    a6ec:	5f af       	sts	0x7f, r21
    a6ee:	25 97       	sbiw	r28, 0x05	; 5
    a6f0:	e1 95       	neg	r30
    a6f2:	81 e0       	ldi	r24, 0x01	; 1
    a6f4:	1e 16       	cp	r1, r30
    a6f6:	08 f0       	brcs	.+2      	; 0xa6fa <__divdi3+0x14a>
    a6f8:	80 e0       	ldi	r24, 0x00	; 0
    a6fa:	f1 95       	neg	r31
    a6fc:	91 e0       	ldi	r25, 0x01	; 1
    a6fe:	1f 16       	cp	r1, r31
    a700:	08 f0       	brcs	.+2      	; 0xa704 <__divdi3+0x154>
    a702:	90 e0       	ldi	r25, 0x00	; 0
    a704:	4f 2f       	mov	r20, r31
    a706:	48 1b       	sub	r20, r24
    a708:	81 e0       	ldi	r24, 0x01	; 1
    a70a:	f4 17       	cp	r31, r20
    a70c:	08 f0       	brcs	.+2      	; 0xa710 <__divdi3+0x160>
    a70e:	80 e0       	ldi	r24, 0x00	; 0
    a710:	98 2b       	or	r25, r24
    a712:	c1 94       	neg	r12
    a714:	81 e0       	ldi	r24, 0x01	; 1
    a716:	1c 14       	cp	r1, r12
    a718:	08 f0       	brcs	.+2      	; 0xa71c <__divdi3+0x16c>
    a71a:	80 e0       	ldi	r24, 0x00	; 0
    a71c:	6c 2d       	mov	r22, r12
    a71e:	69 1b       	sub	r22, r25
    a720:	91 e0       	ldi	r25, 0x01	; 1
    a722:	c6 16       	cp	r12, r22
    a724:	08 f0       	brcs	.+2      	; 0xa728 <__divdi3+0x178>
    a726:	90 e0       	ldi	r25, 0x00	; 0
    a728:	89 2b       	or	r24, r25
    a72a:	d1 94       	neg	r13
    a72c:	91 e0       	ldi	r25, 0x01	; 1
    a72e:	1d 14       	cp	r1, r13
    a730:	08 f0       	brcs	.+2      	; 0xa734 <__divdi3+0x184>
    a732:	90 e0       	ldi	r25, 0x00	; 0
    a734:	5d 2d       	mov	r21, r13
    a736:	58 1b       	sub	r21, r24
    a738:	81 e0       	ldi	r24, 0x01	; 1
    a73a:	d5 16       	cp	r13, r21
    a73c:	08 f0       	brcs	.+2      	; 0xa740 <__divdi3+0x190>
    a73e:	80 e0       	ldi	r24, 0x00	; 0
    a740:	98 2b       	or	r25, r24
    a742:	e1 94       	neg	r14
    a744:	81 e0       	ldi	r24, 0x01	; 1
    a746:	1e 14       	cp	r1, r14
    a748:	08 f0       	brcs	.+2      	; 0xa74c <__divdi3+0x19c>
    a74a:	80 e0       	ldi	r24, 0x00	; 0
    a74c:	3e 2d       	mov	r19, r14
    a74e:	39 1b       	sub	r19, r25
    a750:	91 e0       	ldi	r25, 0x01	; 1
    a752:	e3 16       	cp	r14, r19
    a754:	08 f0       	brcs	.+2      	; 0xa758 <__divdi3+0x1a8>
    a756:	90 e0       	ldi	r25, 0x00	; 0
    a758:	89 2b       	or	r24, r25
    a75a:	f1 94       	neg	r15
    a75c:	91 e0       	ldi	r25, 0x01	; 1
    a75e:	1f 14       	cp	r1, r15
    a760:	08 f0       	brcs	.+2      	; 0xa764 <__divdi3+0x1b4>
    a762:	90 e0       	ldi	r25, 0x00	; 0
    a764:	2f 2d       	mov	r18, r15
    a766:	28 1b       	sub	r18, r24
    a768:	81 e0       	ldi	r24, 0x01	; 1
    a76a:	f2 16       	cp	r15, r18
    a76c:	08 f0       	brcs	.+2      	; 0xa770 <__divdi3+0x1c0>
    a76e:	80 e0       	ldi	r24, 0x00	; 0
    a770:	98 2b       	or	r25, r24
    a772:	01 95       	neg	r16
    a774:	81 e0       	ldi	r24, 0x01	; 1
    a776:	10 16       	cp	r1, r16
    a778:	08 f0       	brcs	.+2      	; 0xa77c <__divdi3+0x1cc>
    a77a:	80 e0       	ldi	r24, 0x00	; 0
    a77c:	70 2f       	mov	r23, r16
    a77e:	79 1b       	sub	r23, r25
    a780:	97 2f       	mov	r25, r23
    a782:	71 e0       	ldi	r23, 0x01	; 1
    a784:	09 17       	cp	r16, r25
    a786:	08 f0       	brcs	.+2      	; 0xa78a <__divdi3+0x1da>
    a788:	70 e0       	ldi	r23, 0x00	; 0
    a78a:	87 2b       	or	r24, r23
    a78c:	11 95       	neg	r17
    a78e:	18 1b       	sub	r17, r24
    a790:	e9 8f       	std	Y+25, r30	; 0x19
    a792:	4a 8f       	std	Y+26, r20	; 0x1a
    a794:	6b 8f       	std	Y+27, r22	; 0x1b
    a796:	5c 8f       	std	Y+28, r21	; 0x1c
    a798:	3d 8f       	std	Y+29, r19	; 0x1d
    a79a:	2e 8f       	std	Y+30, r18	; 0x1e
    a79c:	9f 8f       	std	Y+31, r25	; 0x1f
    a79e:	18 a3       	lds	r17, 0x58
    a7a0:	79 8d       	ldd	r23, Y+25	; 0x19
    a7a2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a7a4:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a7a6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a7a8:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a7aa:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a7ac:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a7ae:	88 a1       	lds	r24, 0x48
    a7b0:	e9 a1       	lds	r30, 0x49
    a7b2:	e9 8b       	std	Y+17, r30	; 0x11
    a7b4:	ea a1       	lds	r30, 0x4a
    a7b6:	ea 8b       	std	Y+18, r30	; 0x12
    a7b8:	eb a1       	lds	r30, 0x4b
    a7ba:	eb 8b       	std	Y+19, r30	; 0x13
    a7bc:	ec a1       	lds	r30, 0x4c
    a7be:	ec 8b       	std	Y+20, r30	; 0x14
    a7c0:	ed a1       	lds	r30, 0x4d
    a7c2:	ed 8b       	std	Y+21, r30	; 0x15
    a7c4:	ee a1       	lds	r30, 0x4e
    a7c6:	ee 8b       	std	Y+22, r30	; 0x16
    a7c8:	ef a1       	lds	r30, 0x4f
    a7ca:	ef 8b       	std	Y+23, r30	; 0x17
    a7cc:	e8 a5       	lds	r30, 0x68
    a7ce:	e8 8f       	std	Y+24, r30	; 0x18
    a7d0:	79 87       	std	Y+9, r23	; 0x09
    a7d2:	6a 87       	std	Y+10, r22	; 0x0a
    a7d4:	5b 87       	std	Y+11, r21	; 0x0b
    a7d6:	4c 87       	std	Y+12, r20	; 0x0c
    a7d8:	3d 87       	std	Y+13, r19	; 0x0d
    a7da:	2e 87       	std	Y+14, r18	; 0x0e
    a7dc:	9f 87       	std	Y+15, r25	; 0x0f
    a7de:	88 8b       	std	Y+16, r24	; 0x10
    a7e0:	89 84       	ldd	r8, Y+9	; 0x09
    a7e2:	9a 84       	ldd	r9, Y+10	; 0x0a
    a7e4:	ab 84       	ldd	r10, Y+11	; 0x0b
    a7e6:	bc 84       	ldd	r11, Y+12	; 0x0c
    a7e8:	8d 85       	ldd	r24, Y+13	; 0x0d
    a7ea:	9e 85       	ldd	r25, Y+14	; 0x0e
    a7ec:	af 85       	ldd	r26, Y+15	; 0x0f
    a7ee:	b8 89       	ldd	r27, Y+16	; 0x10
    a7f0:	e9 88       	ldd	r14, Y+17	; 0x11
    a7f2:	fa 88       	ldd	r15, Y+18	; 0x12
    a7f4:	0b 89       	ldd	r16, Y+19	; 0x13
    a7f6:	1c 89       	ldd	r17, Y+20	; 0x14
    a7f8:	ed aa       	sts	0x9d, r30
    a7fa:	fe aa       	sts	0x9e, r31
    a7fc:	0f ab       	sts	0x5f, r16
    a7fe:	18 af       	sts	0x78, r17
    a800:	cd 88       	ldd	r12, Y+21	; 0x15
    a802:	de 88       	ldd	r13, Y+22	; 0x16
    a804:	ef 88       	ldd	r14, Y+23	; 0x17
    a806:	f8 8c       	ldd	r15, Y+24	; 0x18
    a808:	00 97       	sbiw	r24, 0x00	; 0
    a80a:	a1 05       	cpc	r26, r1
    a80c:	b1 05       	cpc	r27, r1
    a80e:	09 f0       	breq	.+2      	; 0xa812 <__divdi3+0x262>
    a810:	bd c3       	rjmp	.+1914   	; 0xaf8c <__divdi3+0x9dc>
    a812:	c8 14       	cp	r12, r8
    a814:	d9 04       	cpc	r13, r9
    a816:	ea 04       	cpc	r14, r10
    a818:	fb 04       	cpc	r15, r11
    a81a:	08 f0       	brcs	.+2      	; 0xa81e <__divdi3+0x26e>
    a81c:	4d c1       	rjmp	.+666    	; 0xaab8 <__divdi3+0x508>
    a81e:	00 e0       	ldi	r16, 0x00	; 0
    a820:	80 16       	cp	r8, r16
    a822:	00 e0       	ldi	r16, 0x00	; 0
    a824:	90 06       	cpc	r9, r16
    a826:	01 e0       	ldi	r16, 0x01	; 1
    a828:	a0 06       	cpc	r10, r16
    a82a:	00 e0       	ldi	r16, 0x00	; 0
    a82c:	b0 06       	cpc	r11, r16
    a82e:	58 f4       	brcc	.+22     	; 0xa846 <__divdi3+0x296>
    a830:	1f ef       	ldi	r17, 0xFF	; 255
    a832:	81 16       	cp	r8, r17
    a834:	91 04       	cpc	r9, r1
    a836:	a1 04       	cpc	r10, r1
    a838:	b1 04       	cpc	r11, r1
    a83a:	09 f0       	breq	.+2      	; 0xa83e <__divdi3+0x28e>
    a83c:	90 f4       	brcc	.+36     	; 0xa862 <__divdi3+0x2b2>
    a83e:	80 e0       	ldi	r24, 0x00	; 0
    a840:	90 e0       	ldi	r25, 0x00	; 0
    a842:	dc 01       	movw	r26, r24
    a844:	17 c0       	rjmp	.+46     	; 0xa874 <__divdi3+0x2c4>
    a846:	20 e0       	ldi	r18, 0x00	; 0
    a848:	82 16       	cp	r8, r18
    a84a:	20 e0       	ldi	r18, 0x00	; 0
    a84c:	92 06       	cpc	r9, r18
    a84e:	20 e0       	ldi	r18, 0x00	; 0
    a850:	a2 06       	cpc	r10, r18
    a852:	21 e0       	ldi	r18, 0x01	; 1
    a854:	b2 06       	cpc	r11, r18
    a856:	50 f4       	brcc	.+20     	; 0xa86c <__divdi3+0x2bc>
    a858:	80 e1       	ldi	r24, 0x10	; 16
    a85a:	90 e0       	ldi	r25, 0x00	; 0
    a85c:	a0 e0       	ldi	r26, 0x00	; 0
    a85e:	b0 e0       	ldi	r27, 0x00	; 0
    a860:	09 c0       	rjmp	.+18     	; 0xa874 <__divdi3+0x2c4>
    a862:	88 e0       	ldi	r24, 0x08	; 8
    a864:	90 e0       	ldi	r25, 0x00	; 0
    a866:	a0 e0       	ldi	r26, 0x00	; 0
    a868:	b0 e0       	ldi	r27, 0x00	; 0
    a86a:	04 c0       	rjmp	.+8      	; 0xa874 <__divdi3+0x2c4>
    a86c:	88 e1       	ldi	r24, 0x18	; 24
    a86e:	90 e0       	ldi	r25, 0x00	; 0
    a870:	a0 e0       	ldi	r26, 0x00	; 0
    a872:	b0 e0       	ldi	r27, 0x00	; 0
    a874:	b5 01       	movw	r22, r10
    a876:	a4 01       	movw	r20, r8
    a878:	08 2e       	mov	r0, r24
    a87a:	04 c0       	rjmp	.+8      	; 0xa884 <__divdi3+0x2d4>
    a87c:	76 95       	lsr	r23
    a87e:	67 95       	ror	r22
    a880:	57 95       	ror	r21
    a882:	47 95       	ror	r20
    a884:	0a 94       	dec	r0
    a886:	d2 f7       	brpl	.-12     	; 0xa87c <__divdi3+0x2cc>
    a888:	fa 01       	movw	r30, r20
    a88a:	e9 5c       	subi	r30, 0xC9	; 201
    a88c:	ff 4d       	sbci	r31, 0xDF	; 223
    a88e:	20 81       	ld	r18, Z
    a890:	40 e2       	ldi	r20, 0x20	; 32
    a892:	50 e0       	ldi	r21, 0x00	; 0
    a894:	60 e0       	ldi	r22, 0x00	; 0
    a896:	70 e0       	ldi	r23, 0x00	; 0
    a898:	48 1b       	sub	r20, r24
    a89a:	59 0b       	sbc	r21, r25
    a89c:	6a 0b       	sbc	r22, r26
    a89e:	7b 0b       	sbc	r23, r27
    a8a0:	42 1b       	sub	r20, r18
    a8a2:	51 09       	sbc	r21, r1
    a8a4:	61 09       	sbc	r22, r1
    a8a6:	71 09       	sbc	r23, r1
    a8a8:	41 15       	cp	r20, r1
    a8aa:	51 05       	cpc	r21, r1
    a8ac:	61 05       	cpc	r22, r1
    a8ae:	71 05       	cpc	r23, r1
    a8b0:	a1 f1       	breq	.+104    	; 0xa91a <__divdi3+0x36a>
    a8b2:	04 2e       	mov	r0, r20
    a8b4:	04 c0       	rjmp	.+8      	; 0xa8be <__divdi3+0x30e>
    a8b6:	88 0c       	add	r8, r8
    a8b8:	99 1c       	adc	r9, r9
    a8ba:	aa 1c       	adc	r10, r10
    a8bc:	bb 1c       	adc	r11, r11
    a8be:	0a 94       	dec	r0
    a8c0:	d2 f7       	brpl	.-12     	; 0xa8b6 <__divdi3+0x306>
    a8c2:	97 01       	movw	r18, r14
    a8c4:	86 01       	movw	r16, r12
    a8c6:	04 2e       	mov	r0, r20
    a8c8:	04 c0       	rjmp	.+8      	; 0xa8d2 <__divdi3+0x322>
    a8ca:	00 0f       	add	r16, r16
    a8cc:	11 1f       	adc	r17, r17
    a8ce:	22 1f       	adc	r18, r18
    a8d0:	33 1f       	adc	r19, r19
    a8d2:	0a 94       	dec	r0
    a8d4:	d2 f7       	brpl	.-12     	; 0xa8ca <__divdi3+0x31a>
    a8d6:	80 e2       	ldi	r24, 0x20	; 32
    a8d8:	90 e0       	ldi	r25, 0x00	; 0
    a8da:	84 1b       	sub	r24, r20
    a8dc:	95 0b       	sbc	r25, r21
    a8de:	cd a8       	sts	0x8d, r28
    a8e0:	de a8       	sts	0x8e, r29
    a8e2:	ef a8       	sts	0x8f, r30
    a8e4:	f8 ac       	sts	0xa8, r31
    a8e6:	04 c0       	rjmp	.+8      	; 0xa8f0 <__divdi3+0x340>
    a8e8:	f6 94       	lsr	r15
    a8ea:	e7 94       	ror	r14
    a8ec:	d7 94       	ror	r13
    a8ee:	c7 94       	ror	r12
    a8f0:	8a 95       	dec	r24
    a8f2:	d2 f7       	brpl	.-12     	; 0xa8e8 <__divdi3+0x338>
    a8f4:	c0 2a       	or	r12, r16
    a8f6:	d1 2a       	or	r13, r17
    a8f8:	e2 2a       	or	r14, r18
    a8fa:	f3 2a       	or	r15, r19
    a8fc:	0d a9       	sts	0x4d, r16
    a8fe:	1e a9       	sts	0x4e, r17
    a900:	2f a9       	sts	0x4f, r18
    a902:	38 ad       	sts	0x68, r19
    a904:	04 c0       	rjmp	.+8      	; 0xa90e <__divdi3+0x35e>
    a906:	00 0f       	add	r16, r16
    a908:	11 1f       	adc	r17, r17
    a90a:	22 1f       	adc	r18, r18
    a90c:	33 1f       	adc	r19, r19
    a90e:	4a 95       	dec	r20
    a910:	d2 f7       	brpl	.-12     	; 0xa906 <__divdi3+0x356>
    a912:	0d ab       	sts	0x5d, r16
    a914:	1e ab       	sts	0x5e, r17
    a916:	2f ab       	sts	0x5f, r18
    a918:	38 af       	sts	0x78, r19
    a91a:	25 01       	movw	r4, r10
    a91c:	66 24       	eor	r6, r6
    a91e:	77 24       	eor	r7, r7
    a920:	95 01       	movw	r18, r10
    a922:	84 01       	movw	r16, r8
    a924:	20 70       	andi	r18, 0x00	; 0
    a926:	30 70       	andi	r19, 0x00	; 0
    a928:	09 ab       	sts	0x59, r16
    a92a:	1a ab       	sts	0x5a, r17
    a92c:	2b ab       	sts	0x5b, r18
    a92e:	3c ab       	sts	0x5c, r19
    a930:	c7 01       	movw	r24, r14
    a932:	b6 01       	movw	r22, r12
    a934:	a3 01       	movw	r20, r6
    a936:	92 01       	movw	r18, r4
    a938:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    a93c:	2d a7       	lds	r18, 0x7d
    a93e:	3e a7       	lds	r19, 0x7e
    a940:	4f a7       	lds	r20, 0x7f
    a942:	58 ab       	sts	0x58, r21
    a944:	69 a7       	lds	r22, 0x79
    a946:	7a a7       	lds	r23, 0x7a
    a948:	8b a7       	lds	r24, 0x7b
    a94a:	9c a7       	lds	r25, 0x7c
    a94c:	c7 01       	movw	r24, r14
    a94e:	b6 01       	movw	r22, r12
    a950:	a3 01       	movw	r20, r6
    a952:	92 01       	movw	r18, r4
    a954:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    a958:	ca 01       	movw	r24, r20
    a95a:	b9 01       	movw	r22, r18
    a95c:	29 a9       	sts	0x49, r18
    a95e:	3a a9       	sts	0x4a, r19
    a960:	4b a9       	sts	0x4b, r20
    a962:	5c a9       	sts	0x4c, r21
    a964:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    a968:	ab 01       	movw	r20, r22
    a96a:	bc 01       	movw	r22, r24
    a96c:	09 a5       	lds	r16, 0x69
    a96e:	1a a5       	lds	r17, 0x6a
    a970:	2b a5       	lds	r18, 0x6b
    a972:	3c a5       	lds	r19, 0x6c
    a974:	78 01       	movw	r14, r16
    a976:	dd 24       	eor	r13, r13
    a978:	cc 24       	eor	r12, r12
    a97a:	0d a9       	sts	0x4d, r16
    a97c:	1e a9       	sts	0x4e, r17
    a97e:	2f a9       	sts	0x4f, r18
    a980:	38 ad       	sts	0x68, r19
    a982:	c9 01       	movw	r24, r18
    a984:	aa 27       	eor	r26, r26
    a986:	bb 27       	eor	r27, r27
    a988:	c8 2a       	or	r12, r24
    a98a:	d9 2a       	or	r13, r25
    a98c:	ea 2a       	or	r14, r26
    a98e:	fb 2a       	or	r15, r27
    a990:	0d a5       	lds	r16, 0x6d
    a992:	1e a5       	lds	r17, 0x6e
    a994:	2f a5       	lds	r18, 0x6f
    a996:	38 a9       	sts	0x48, r19
    a998:	c4 16       	cp	r12, r20
    a99a:	d5 06       	cpc	r13, r21
    a99c:	e6 06       	cpc	r14, r22
    a99e:	f7 06       	cpc	r15, r23
    a9a0:	38 f5       	brcc	.+78     	; 0xa9f0 <__divdi3+0x440>
    a9a2:	01 50       	subi	r16, 0x01	; 1
    a9a4:	10 40       	sbci	r17, 0x00	; 0
    a9a6:	20 40       	sbci	r18, 0x00	; 0
    a9a8:	30 40       	sbci	r19, 0x00	; 0
    a9aa:	09 a7       	lds	r16, 0x79
    a9ac:	1a a7       	lds	r17, 0x7a
    a9ae:	2b a7       	lds	r18, 0x7b
    a9b0:	3c a7       	lds	r19, 0x7c
    a9b2:	c8 0c       	add	r12, r8
    a9b4:	d9 1c       	adc	r13, r9
    a9b6:	ea 1c       	adc	r14, r10
    a9b8:	fb 1c       	adc	r15, r11
    a9ba:	c8 14       	cp	r12, r8
    a9bc:	d9 04       	cpc	r13, r9
    a9be:	ea 04       	cpc	r14, r10
    a9c0:	fb 04       	cpc	r15, r11
    a9c2:	d0 f0       	brcs	.+52     	; 0xa9f8 <__divdi3+0x448>
    a9c4:	c4 16       	cp	r12, r20
    a9c6:	d5 06       	cpc	r13, r21
    a9c8:	e6 06       	cpc	r14, r22
    a9ca:	f7 06       	cpc	r15, r23
    a9cc:	a8 f4       	brcc	.+42     	; 0xa9f8 <__divdi3+0x448>
    a9ce:	0d a5       	lds	r16, 0x6d
    a9d0:	1e a5       	lds	r17, 0x6e
    a9d2:	2f a5       	lds	r18, 0x6f
    a9d4:	38 a9       	sts	0x48, r19
    a9d6:	02 50       	subi	r16, 0x02	; 2
    a9d8:	10 40       	sbci	r17, 0x00	; 0
    a9da:	20 40       	sbci	r18, 0x00	; 0
    a9dc:	30 40       	sbci	r19, 0x00	; 0
    a9de:	09 a7       	lds	r16, 0x79
    a9e0:	1a a7       	lds	r17, 0x7a
    a9e2:	2b a7       	lds	r18, 0x7b
    a9e4:	3c a7       	lds	r19, 0x7c
    a9e6:	c8 0c       	add	r12, r8
    a9e8:	d9 1c       	adc	r13, r9
    a9ea:	ea 1c       	adc	r14, r10
    a9ec:	fb 1c       	adc	r15, r11
    a9ee:	04 c0       	rjmp	.+8      	; 0xa9f8 <__divdi3+0x448>
    a9f0:	09 a7       	lds	r16, 0x79
    a9f2:	1a a7       	lds	r17, 0x7a
    a9f4:	2b a7       	lds	r18, 0x7b
    a9f6:	3c a7       	lds	r19, 0x7c
    a9f8:	c4 1a       	sub	r12, r20
    a9fa:	d5 0a       	sbc	r13, r21
    a9fc:	e6 0a       	sbc	r14, r22
    a9fe:	f7 0a       	sbc	r15, r23
    aa00:	c7 01       	movw	r24, r14
    aa02:	b6 01       	movw	r22, r12
    aa04:	a3 01       	movw	r20, r6
    aa06:	92 01       	movw	r18, r4
    aa08:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    aa0c:	2d a7       	lds	r18, 0x7d
    aa0e:	3e a7       	lds	r19, 0x7e
    aa10:	4f a7       	lds	r20, 0x7f
    aa12:	58 ab       	sts	0x58, r21
    aa14:	69 af       	sts	0x79, r22
    aa16:	7a af       	sts	0x7a, r23
    aa18:	8b af       	sts	0x7b, r24
    aa1a:	9c af       	sts	0x7c, r25
    aa1c:	c7 01       	movw	r24, r14
    aa1e:	b6 01       	movw	r22, r12
    aa20:	a3 01       	movw	r20, r6
    aa22:	92 01       	movw	r18, r4
    aa24:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    aa28:	ca 01       	movw	r24, r20
    aa2a:	b9 01       	movw	r22, r18
    aa2c:	29 a9       	sts	0x49, r18
    aa2e:	3a a9       	sts	0x4a, r19
    aa30:	4b a9       	sts	0x4b, r20
    aa32:	5c a9       	sts	0x4c, r21
    aa34:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    aa38:	6b 01       	movw	r12, r22
    aa3a:	7c 01       	movw	r14, r24
    aa3c:	49 ad       	sts	0x69, r20
    aa3e:	5a ad       	sts	0x6a, r21
    aa40:	6b ad       	sts	0x6b, r22
    aa42:	7c ad       	sts	0x6c, r23
    aa44:	9a 01       	movw	r18, r20
    aa46:	11 27       	eor	r17, r17
    aa48:	00 27       	eor	r16, r16
    aa4a:	4d a9       	sts	0x4d, r20
    aa4c:	5e a9       	sts	0x4e, r21
    aa4e:	6f a9       	sts	0x4f, r22
    aa50:	78 ad       	sts	0x68, r23
    aa52:	60 70       	andi	r22, 0x00	; 0
    aa54:	70 70       	andi	r23, 0x00	; 0
    aa56:	04 2b       	or	r16, r20
    aa58:	15 2b       	or	r17, r21
    aa5a:	26 2b       	or	r18, r22
    aa5c:	37 2b       	or	r19, r23
    aa5e:	8d a5       	lds	r24, 0x6d
    aa60:	9e a5       	lds	r25, 0x6e
    aa62:	af a5       	lds	r26, 0x6f
    aa64:	b8 a9       	sts	0x48, r27
    aa66:	0c 15       	cp	r16, r12
    aa68:	1d 05       	cpc	r17, r13
    aa6a:	2e 05       	cpc	r18, r14
    aa6c:	3f 05       	cpc	r19, r15
    aa6e:	c0 f4       	brcc	.+48     	; 0xaaa0 <__divdi3+0x4f0>
    aa70:	01 97       	sbiw	r24, 0x01	; 1
    aa72:	a1 09       	sbc	r26, r1
    aa74:	b1 09       	sbc	r27, r1
    aa76:	08 0d       	add	r16, r8
    aa78:	19 1d       	adc	r17, r9
    aa7a:	2a 1d       	adc	r18, r10
    aa7c:	3b 1d       	adc	r19, r11
    aa7e:	08 15       	cp	r16, r8
    aa80:	19 05       	cpc	r17, r9
    aa82:	2a 05       	cpc	r18, r10
    aa84:	3b 05       	cpc	r19, r11
    aa86:	60 f0       	brcs	.+24     	; 0xaaa0 <__divdi3+0x4f0>
    aa88:	0c 15       	cp	r16, r12
    aa8a:	1d 05       	cpc	r17, r13
    aa8c:	2e 05       	cpc	r18, r14
    aa8e:	3f 05       	cpc	r19, r15
    aa90:	38 f4       	brcc	.+14     	; 0xaaa0 <__divdi3+0x4f0>
    aa92:	8d a5       	lds	r24, 0x6d
    aa94:	9e a5       	lds	r25, 0x6e
    aa96:	af a5       	lds	r26, 0x6f
    aa98:	b8 a9       	sts	0x48, r27
    aa9a:	02 97       	sbiw	r24, 0x02	; 2
    aa9c:	a1 09       	sbc	r26, r1
    aa9e:	b1 09       	sbc	r27, r1
    aaa0:	09 a5       	lds	r16, 0x69
    aaa2:	1a a5       	lds	r17, 0x6a
    aaa4:	2b a5       	lds	r18, 0x6b
    aaa6:	3c a5       	lds	r19, 0x6c
    aaa8:	78 01       	movw	r14, r16
    aaaa:	dd 24       	eor	r13, r13
    aaac:	cc 24       	eor	r12, r12
    aaae:	c8 2a       	or	r12, r24
    aab0:	d9 2a       	or	r13, r25
    aab2:	ea 2a       	or	r14, r26
    aab4:	fb 2a       	or	r15, r27
    aab6:	b7 c4       	rjmp	.+2414   	; 0xb426 <__divdi3+0xe76>
    aab8:	81 14       	cp	r8, r1
    aaba:	91 04       	cpc	r9, r1
    aabc:	a1 04       	cpc	r10, r1
    aabe:	b1 04       	cpc	r11, r1
    aac0:	51 f4       	brne	.+20     	; 0xaad6 <__divdi3+0x526>
    aac2:	61 e0       	ldi	r22, 0x01	; 1
    aac4:	70 e0       	ldi	r23, 0x00	; 0
    aac6:	80 e0       	ldi	r24, 0x00	; 0
    aac8:	90 e0       	ldi	r25, 0x00	; 0
    aaca:	a5 01       	movw	r20, r10
    aacc:	94 01       	movw	r18, r8
    aace:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    aad2:	49 01       	movw	r8, r18
    aad4:	5a 01       	movw	r10, r20
    aad6:	10 e0       	ldi	r17, 0x00	; 0
    aad8:	81 16       	cp	r8, r17
    aada:	10 e0       	ldi	r17, 0x00	; 0
    aadc:	91 06       	cpc	r9, r17
    aade:	11 e0       	ldi	r17, 0x01	; 1
    aae0:	a1 06       	cpc	r10, r17
    aae2:	10 e0       	ldi	r17, 0x00	; 0
    aae4:	b1 06       	cpc	r11, r17
    aae6:	58 f4       	brcc	.+22     	; 0xaafe <__divdi3+0x54e>
    aae8:	2f ef       	ldi	r18, 0xFF	; 255
    aaea:	82 16       	cp	r8, r18
    aaec:	91 04       	cpc	r9, r1
    aaee:	a1 04       	cpc	r10, r1
    aaf0:	b1 04       	cpc	r11, r1
    aaf2:	09 f0       	breq	.+2      	; 0xaaf6 <__divdi3+0x546>
    aaf4:	90 f4       	brcc	.+36     	; 0xab1a <__divdi3+0x56a>
    aaf6:	80 e0       	ldi	r24, 0x00	; 0
    aaf8:	90 e0       	ldi	r25, 0x00	; 0
    aafa:	dc 01       	movw	r26, r24
    aafc:	17 c0       	rjmp	.+46     	; 0xab2c <__divdi3+0x57c>
    aafe:	30 e0       	ldi	r19, 0x00	; 0
    ab00:	83 16       	cp	r8, r19
    ab02:	30 e0       	ldi	r19, 0x00	; 0
    ab04:	93 06       	cpc	r9, r19
    ab06:	30 e0       	ldi	r19, 0x00	; 0
    ab08:	a3 06       	cpc	r10, r19
    ab0a:	31 e0       	ldi	r19, 0x01	; 1
    ab0c:	b3 06       	cpc	r11, r19
    ab0e:	50 f4       	brcc	.+20     	; 0xab24 <__divdi3+0x574>
    ab10:	80 e1       	ldi	r24, 0x10	; 16
    ab12:	90 e0       	ldi	r25, 0x00	; 0
    ab14:	a0 e0       	ldi	r26, 0x00	; 0
    ab16:	b0 e0       	ldi	r27, 0x00	; 0
    ab18:	09 c0       	rjmp	.+18     	; 0xab2c <__divdi3+0x57c>
    ab1a:	88 e0       	ldi	r24, 0x08	; 8
    ab1c:	90 e0       	ldi	r25, 0x00	; 0
    ab1e:	a0 e0       	ldi	r26, 0x00	; 0
    ab20:	b0 e0       	ldi	r27, 0x00	; 0
    ab22:	04 c0       	rjmp	.+8      	; 0xab2c <__divdi3+0x57c>
    ab24:	88 e1       	ldi	r24, 0x18	; 24
    ab26:	90 e0       	ldi	r25, 0x00	; 0
    ab28:	a0 e0       	ldi	r26, 0x00	; 0
    ab2a:	b0 e0       	ldi	r27, 0x00	; 0
    ab2c:	b5 01       	movw	r22, r10
    ab2e:	a4 01       	movw	r20, r8
    ab30:	08 2e       	mov	r0, r24
    ab32:	04 c0       	rjmp	.+8      	; 0xab3c <__divdi3+0x58c>
    ab34:	76 95       	lsr	r23
    ab36:	67 95       	ror	r22
    ab38:	57 95       	ror	r21
    ab3a:	47 95       	ror	r20
    ab3c:	0a 94       	dec	r0
    ab3e:	d2 f7       	brpl	.-12     	; 0xab34 <__divdi3+0x584>
    ab40:	fa 01       	movw	r30, r20
    ab42:	e9 5c       	subi	r30, 0xC9	; 201
    ab44:	ff 4d       	sbci	r31, 0xDF	; 223
    ab46:	20 81       	ld	r18, Z
    ab48:	ac 01       	movw	r20, r24
    ab4a:	bd 01       	movw	r22, r26
    ab4c:	42 0f       	add	r20, r18
    ab4e:	51 1d       	adc	r21, r1
    ab50:	61 1d       	adc	r22, r1
    ab52:	71 1d       	adc	r23, r1
    ab54:	80 e2       	ldi	r24, 0x20	; 32
    ab56:	90 e0       	ldi	r25, 0x00	; 0
    ab58:	a0 e0       	ldi	r26, 0x00	; 0
    ab5a:	b0 e0       	ldi	r27, 0x00	; 0
    ab5c:	84 1b       	sub	r24, r20
    ab5e:	95 0b       	sbc	r25, r21
    ab60:	a6 0b       	sbc	r26, r22
    ab62:	b7 0b       	sbc	r27, r23
    ab64:	51 f4       	brne	.+20     	; 0xab7a <__divdi3+0x5ca>
    ab66:	c8 18       	sub	r12, r8
    ab68:	d9 08       	sbc	r13, r9
    ab6a:	ea 08       	sbc	r14, r10
    ab6c:	fb 08       	sbc	r15, r11
    ab6e:	f1 e0       	ldi	r31, 0x01	; 1
    ab70:	4f 2e       	mov	r4, r31
    ab72:	51 2c       	mov	r5, r1
    ab74:	61 2c       	mov	r6, r1
    ab76:	71 2c       	mov	r7, r1
    ab78:	28 c1       	rjmp	.+592    	; 0xadca <__divdi3+0x81a>
    ab7a:	08 2e       	mov	r0, r24
    ab7c:	04 c0       	rjmp	.+8      	; 0xab86 <__divdi3+0x5d6>
    ab7e:	88 0c       	add	r8, r8
    ab80:	99 1c       	adc	r9, r9
    ab82:	aa 1c       	adc	r10, r10
    ab84:	bb 1c       	adc	r11, r11
    ab86:	0a 94       	dec	r0
    ab88:	d2 f7       	brpl	.-12     	; 0xab7e <__divdi3+0x5ce>
    ab8a:	97 01       	movw	r18, r14
    ab8c:	86 01       	movw	r16, r12
    ab8e:	04 2e       	mov	r0, r20
    ab90:	04 c0       	rjmp	.+8      	; 0xab9a <__divdi3+0x5ea>
    ab92:	36 95       	lsr	r19
    ab94:	27 95       	ror	r18
    ab96:	17 95       	ror	r17
    ab98:	07 95       	ror	r16
    ab9a:	0a 94       	dec	r0
    ab9c:	d2 f7       	brpl	.-12     	; 0xab92 <__divdi3+0x5e2>
    ab9e:	09 ab       	sts	0x59, r16
    aba0:	1a ab       	sts	0x5a, r17
    aba2:	2b ab       	sts	0x5b, r18
    aba4:	3c ab       	sts	0x5c, r19
    aba6:	97 01       	movw	r18, r14
    aba8:	86 01       	movw	r16, r12
    abaa:	08 2e       	mov	r0, r24
    abac:	04 c0       	rjmp	.+8      	; 0xabb6 <__divdi3+0x606>
    abae:	00 0f       	add	r16, r16
    abb0:	11 1f       	adc	r17, r17
    abb2:	22 1f       	adc	r18, r18
    abb4:	33 1f       	adc	r19, r19
    abb6:	0a 94       	dec	r0
    abb8:	d2 f7       	brpl	.-12     	; 0xabae <__divdi3+0x5fe>
    abba:	0d a7       	lds	r16, 0x7d
    abbc:	1e a7       	lds	r17, 0x7e
    abbe:	2f a7       	lds	r18, 0x7f
    abc0:	38 ab       	sts	0x58, r19
    abc2:	ed a8       	sts	0x8d, r30
    abc4:	fe a8       	sts	0x8e, r31
    abc6:	0f a9       	sts	0x4f, r16
    abc8:	18 ad       	sts	0x68, r17
    abca:	04 c0       	rjmp	.+8      	; 0xabd4 <__divdi3+0x624>
    abcc:	16 95       	lsr	r17
    abce:	07 95       	ror	r16
    abd0:	f7 94       	ror	r15
    abd2:	e7 94       	ror	r14
    abd4:	4a 95       	dec	r20
    abd6:	d2 f7       	brpl	.-12     	; 0xabcc <__divdi3+0x61c>
    abd8:	b8 01       	movw	r22, r16
    abda:	a7 01       	movw	r20, r14
    abdc:	0d a5       	lds	r16, 0x6d
    abde:	1e a5       	lds	r17, 0x6e
    abe0:	2f a5       	lds	r18, 0x6f
    abe2:	38 a9       	sts	0x48, r19
    abe4:	04 2b       	or	r16, r20
    abe6:	15 2b       	or	r17, r21
    abe8:	26 2b       	or	r18, r22
    abea:	37 2b       	or	r19, r23
    abec:	0d a7       	lds	r16, 0x7d
    abee:	1e a7       	lds	r17, 0x7e
    abf0:	2f a7       	lds	r18, 0x7f
    abf2:	38 ab       	sts	0x58, r19
    abf4:	ed a8       	sts	0x8d, r30
    abf6:	fe a8       	sts	0x8e, r31
    abf8:	0f a9       	sts	0x4f, r16
    abfa:	18 ad       	sts	0x68, r17
    abfc:	04 c0       	rjmp	.+8      	; 0xac06 <__divdi3+0x656>
    abfe:	ee 0c       	add	r14, r14
    ac00:	ff 1c       	adc	r15, r15
    ac02:	00 1f       	adc	r16, r16
    ac04:	11 1f       	adc	r17, r17
    ac06:	8a 95       	dec	r24
    ac08:	d2 f7       	brpl	.-12     	; 0xabfe <__divdi3+0x64e>
    ac0a:	ed aa       	sts	0x9d, r30
    ac0c:	fe aa       	sts	0x9e, r31
    ac0e:	0f ab       	sts	0x5f, r16
    ac10:	18 af       	sts	0x78, r17
    ac12:	25 01       	movw	r4, r10
    ac14:	66 24       	eor	r6, r6
    ac16:	77 24       	eor	r7, r7
    ac18:	95 01       	movw	r18, r10
    ac1a:	84 01       	movw	r16, r8
    ac1c:	20 70       	andi	r18, 0x00	; 0
    ac1e:	30 70       	andi	r19, 0x00	; 0
    ac20:	09 af       	sts	0x79, r16
    ac22:	1a af       	sts	0x7a, r17
    ac24:	2b af       	sts	0x7b, r18
    ac26:	3c af       	sts	0x7c, r19
    ac28:	69 a9       	sts	0x49, r22
    ac2a:	7a a9       	sts	0x4a, r23
    ac2c:	8b a9       	sts	0x4b, r24
    ac2e:	9c a9       	sts	0x4c, r25
    ac30:	a3 01       	movw	r20, r6
    ac32:	92 01       	movw	r18, r4
    ac34:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    ac38:	29 a7       	lds	r18, 0x79
    ac3a:	3a a7       	lds	r19, 0x7a
    ac3c:	4b a7       	lds	r20, 0x7b
    ac3e:	5c a7       	lds	r21, 0x7c
    ac40:	6b 01       	movw	r12, r22
    ac42:	7c 01       	movw	r14, r24
    ac44:	69 a9       	sts	0x49, r22
    ac46:	7a a9       	sts	0x4a, r23
    ac48:	8b a9       	sts	0x4b, r24
    ac4a:	9c a9       	sts	0x4c, r25
    ac4c:	a3 01       	movw	r20, r6
    ac4e:	92 01       	movw	r18, r4
    ac50:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    ac54:	ca 01       	movw	r24, r20
    ac56:	b9 01       	movw	r22, r18
    ac58:	29 ad       	sts	0x69, r18
    ac5a:	3a ad       	sts	0x6a, r19
    ac5c:	4b ad       	sts	0x6b, r20
    ac5e:	5c ad       	sts	0x6c, r21
    ac60:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    ac64:	ab 01       	movw	r20, r22
    ac66:	bc 01       	movw	r22, r24
    ac68:	76 01       	movw	r14, r12
    ac6a:	dd 24       	eor	r13, r13
    ac6c:	cc 24       	eor	r12, r12
    ac6e:	0d a5       	lds	r16, 0x6d
    ac70:	1e a5       	lds	r17, 0x6e
    ac72:	2f a5       	lds	r18, 0x6f
    ac74:	38 a9       	sts	0x48, r19
    ac76:	c9 01       	movw	r24, r18
    ac78:	aa 27       	eor	r26, r26
    ac7a:	bb 27       	eor	r27, r27
    ac7c:	c8 2a       	or	r12, r24
    ac7e:	d9 2a       	or	r13, r25
    ac80:	ea 2a       	or	r14, r26
    ac82:	fb 2a       	or	r15, r27
    ac84:	09 a5       	lds	r16, 0x69
    ac86:	1a a5       	lds	r17, 0x6a
    ac88:	2b a5       	lds	r18, 0x6b
    ac8a:	3c a5       	lds	r19, 0x6c
    ac8c:	c4 16       	cp	r12, r20
    ac8e:	d5 06       	cpc	r13, r21
    ac90:	e6 06       	cpc	r14, r22
    ac92:	f7 06       	cpc	r15, r23
    ac94:	38 f5       	brcc	.+78     	; 0xace4 <__divdi3+0x734>
    ac96:	01 50       	subi	r16, 0x01	; 1
    ac98:	10 40       	sbci	r17, 0x00	; 0
    ac9a:	20 40       	sbci	r18, 0x00	; 0
    ac9c:	30 40       	sbci	r19, 0x00	; 0
    ac9e:	09 ab       	sts	0x59, r16
    aca0:	1a ab       	sts	0x5a, r17
    aca2:	2b ab       	sts	0x5b, r18
    aca4:	3c ab       	sts	0x5c, r19
    aca6:	c8 0c       	add	r12, r8
    aca8:	d9 1c       	adc	r13, r9
    acaa:	ea 1c       	adc	r14, r10
    acac:	fb 1c       	adc	r15, r11
    acae:	c8 14       	cp	r12, r8
    acb0:	d9 04       	cpc	r13, r9
    acb2:	ea 04       	cpc	r14, r10
    acb4:	fb 04       	cpc	r15, r11
    acb6:	d0 f0       	brcs	.+52     	; 0xacec <__divdi3+0x73c>
    acb8:	c4 16       	cp	r12, r20
    acba:	d5 06       	cpc	r13, r21
    acbc:	e6 06       	cpc	r14, r22
    acbe:	f7 06       	cpc	r15, r23
    acc0:	a8 f4       	brcc	.+42     	; 0xacec <__divdi3+0x73c>
    acc2:	09 a5       	lds	r16, 0x69
    acc4:	1a a5       	lds	r17, 0x6a
    acc6:	2b a5       	lds	r18, 0x6b
    acc8:	3c a5       	lds	r19, 0x6c
    acca:	02 50       	subi	r16, 0x02	; 2
    accc:	10 40       	sbci	r17, 0x00	; 0
    acce:	20 40       	sbci	r18, 0x00	; 0
    acd0:	30 40       	sbci	r19, 0x00	; 0
    acd2:	09 ab       	sts	0x59, r16
    acd4:	1a ab       	sts	0x5a, r17
    acd6:	2b ab       	sts	0x5b, r18
    acd8:	3c ab       	sts	0x5c, r19
    acda:	c8 0c       	add	r12, r8
    acdc:	d9 1c       	adc	r13, r9
    acde:	ea 1c       	adc	r14, r10
    ace0:	fb 1c       	adc	r15, r11
    ace2:	04 c0       	rjmp	.+8      	; 0xacec <__divdi3+0x73c>
    ace4:	09 ab       	sts	0x59, r16
    ace6:	1a ab       	sts	0x5a, r17
    ace8:	2b ab       	sts	0x5b, r18
    acea:	3c ab       	sts	0x5c, r19
    acec:	c4 1a       	sub	r12, r20
    acee:	d5 0a       	sbc	r13, r21
    acf0:	e6 0a       	sbc	r14, r22
    acf2:	f7 0a       	sbc	r15, r23
    acf4:	c7 01       	movw	r24, r14
    acf6:	b6 01       	movw	r22, r12
    acf8:	a3 01       	movw	r20, r6
    acfa:	92 01       	movw	r18, r4
    acfc:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    ad00:	29 a7       	lds	r18, 0x79
    ad02:	3a a7       	lds	r19, 0x7a
    ad04:	4b a7       	lds	r20, 0x7b
    ad06:	5c a7       	lds	r21, 0x7c
    ad08:	21 96       	adiw	r28, 0x01	; 1
    ad0a:	6c af       	sts	0x7c, r22
    ad0c:	7d af       	sts	0x7d, r23
    ad0e:	8e af       	sts	0x7e, r24
    ad10:	9f af       	sts	0x7f, r25
    ad12:	21 97       	sbiw	r28, 0x01	; 1
    ad14:	c7 01       	movw	r24, r14
    ad16:	b6 01       	movw	r22, r12
    ad18:	a3 01       	movw	r20, r6
    ad1a:	92 01       	movw	r18, r4
    ad1c:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    ad20:	ca 01       	movw	r24, r20
    ad22:	b9 01       	movw	r22, r18
    ad24:	29 ad       	sts	0x69, r18
    ad26:	3a ad       	sts	0x6a, r19
    ad28:	4b ad       	sts	0x6b, r20
    ad2a:	5c ad       	sts	0x6c, r21
    ad2c:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    ad30:	8b 01       	movw	r16, r22
    ad32:	9c 01       	movw	r18, r24
    ad34:	21 96       	adiw	r28, 0x01	; 1
    ad36:	4c ad       	sts	0x6c, r20
    ad38:	5d ad       	sts	0x6d, r21
    ad3a:	6e ad       	sts	0x6e, r22
    ad3c:	7f ad       	sts	0x6f, r23
    ad3e:	21 97       	sbiw	r28, 0x01	; 1
    ad40:	da 01       	movw	r26, r20
    ad42:	99 27       	eor	r25, r25
    ad44:	88 27       	eor	r24, r24
    ad46:	4d a5       	lds	r20, 0x6d
    ad48:	5e a5       	lds	r21, 0x6e
    ad4a:	6f a5       	lds	r22, 0x6f
    ad4c:	78 a9       	sts	0x48, r23
    ad4e:	60 70       	andi	r22, 0x00	; 0
    ad50:	70 70       	andi	r23, 0x00	; 0
    ad52:	84 2b       	or	r24, r20
    ad54:	95 2b       	or	r25, r21
    ad56:	a6 2b       	or	r26, r22
    ad58:	b7 2b       	or	r27, r23
    ad5a:	49 a5       	lds	r20, 0x69
    ad5c:	5a a5       	lds	r21, 0x6a
    ad5e:	6b a5       	lds	r22, 0x6b
    ad60:	7c a5       	lds	r23, 0x6c
    ad62:	80 17       	cp	r24, r16
    ad64:	91 07       	cpc	r25, r17
    ad66:	a2 07       	cpc	r26, r18
    ad68:	b3 07       	cpc	r27, r19
    ad6a:	f0 f4       	brcc	.+60     	; 0xada8 <__divdi3+0x7f8>
    ad6c:	41 50       	subi	r20, 0x01	; 1
    ad6e:	50 40       	sbci	r21, 0x00	; 0
    ad70:	60 40       	sbci	r22, 0x00	; 0
    ad72:	70 40       	sbci	r23, 0x00	; 0
    ad74:	88 0d       	add	r24, r8
    ad76:	99 1d       	adc	r25, r9
    ad78:	aa 1d       	adc	r26, r10
    ad7a:	bb 1d       	adc	r27, r11
    ad7c:	88 15       	cp	r24, r8
    ad7e:	99 05       	cpc	r25, r9
    ad80:	aa 05       	cpc	r26, r10
    ad82:	bb 05       	cpc	r27, r11
    ad84:	88 f0       	brcs	.+34     	; 0xada8 <__divdi3+0x7f8>
    ad86:	80 17       	cp	r24, r16
    ad88:	91 07       	cpc	r25, r17
    ad8a:	a2 07       	cpc	r26, r18
    ad8c:	b3 07       	cpc	r27, r19
    ad8e:	60 f4       	brcc	.+24     	; 0xada8 <__divdi3+0x7f8>
    ad90:	49 a5       	lds	r20, 0x69
    ad92:	5a a5       	lds	r21, 0x6a
    ad94:	6b a5       	lds	r22, 0x6b
    ad96:	7c a5       	lds	r23, 0x6c
    ad98:	42 50       	subi	r20, 0x02	; 2
    ad9a:	50 40       	sbci	r21, 0x00	; 0
    ad9c:	60 40       	sbci	r22, 0x00	; 0
    ad9e:	70 40       	sbci	r23, 0x00	; 0
    ada0:	88 0d       	add	r24, r8
    ada2:	99 1d       	adc	r25, r9
    ada4:	aa 1d       	adc	r26, r10
    ada6:	bb 1d       	adc	r27, r11
    ada8:	6c 01       	movw	r12, r24
    adaa:	7d 01       	movw	r14, r26
    adac:	c0 1a       	sub	r12, r16
    adae:	d1 0a       	sbc	r13, r17
    adb0:	e2 0a       	sbc	r14, r18
    adb2:	f3 0a       	sbc	r15, r19
    adb4:	09 a9       	sts	0x49, r16
    adb6:	1a a9       	sts	0x4a, r17
    adb8:	2b a9       	sts	0x4b, r18
    adba:	3c a9       	sts	0x4c, r19
    adbc:	38 01       	movw	r6, r16
    adbe:	55 24       	eor	r5, r5
    adc0:	44 24       	eor	r4, r4
    adc2:	44 2a       	or	r4, r20
    adc4:	55 2a       	or	r5, r21
    adc6:	66 2a       	or	r6, r22
    adc8:	77 2a       	or	r7, r23
    adca:	85 01       	movw	r16, r10
    adcc:	22 27       	eor	r18, r18
    adce:	33 27       	eor	r19, r19
    add0:	0d a7       	lds	r16, 0x7d
    add2:	1e a7       	lds	r17, 0x7e
    add4:	2f a7       	lds	r18, 0x7f
    add6:	38 ab       	sts	0x58, r19
    add8:	95 01       	movw	r18, r10
    adda:	84 01       	movw	r16, r8
    addc:	20 70       	andi	r18, 0x00	; 0
    adde:	30 70       	andi	r19, 0x00	; 0
    ade0:	09 af       	sts	0x79, r16
    ade2:	1a af       	sts	0x7a, r17
    ade4:	2b af       	sts	0x7b, r18
    ade6:	3c af       	sts	0x7c, r19
    ade8:	c7 01       	movw	r24, r14
    adea:	b6 01       	movw	r22, r12
    adec:	2d a5       	lds	r18, 0x6d
    adee:	3e a5       	lds	r19, 0x6e
    adf0:	4f a5       	lds	r20, 0x6f
    adf2:	58 a9       	sts	0x48, r21
    adf4:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    adf8:	29 a7       	lds	r18, 0x79
    adfa:	3a a7       	lds	r19, 0x7a
    adfc:	4b a7       	lds	r20, 0x7b
    adfe:	5c a7       	lds	r21, 0x7c
    ae00:	69 ab       	sts	0x59, r22
    ae02:	7a ab       	sts	0x5a, r23
    ae04:	8b ab       	sts	0x5b, r24
    ae06:	9c ab       	sts	0x5c, r25
    ae08:	c7 01       	movw	r24, r14
    ae0a:	b6 01       	movw	r22, r12
    ae0c:	2d a5       	lds	r18, 0x6d
    ae0e:	3e a5       	lds	r19, 0x6e
    ae10:	4f a5       	lds	r20, 0x6f
    ae12:	58 a9       	sts	0x48, r21
    ae14:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    ae18:	ca 01       	movw	r24, r20
    ae1a:	b9 01       	movw	r22, r18
    ae1c:	29 ad       	sts	0x69, r18
    ae1e:	3a ad       	sts	0x6a, r19
    ae20:	4b ad       	sts	0x6b, r20
    ae22:	5c ad       	sts	0x6c, r21
    ae24:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    ae28:	ab 01       	movw	r20, r22
    ae2a:	bc 01       	movw	r22, r24
    ae2c:	09 a9       	sts	0x49, r16
    ae2e:	1a a9       	sts	0x4a, r17
    ae30:	2b a9       	sts	0x4b, r18
    ae32:	3c a9       	sts	0x4c, r19
    ae34:	78 01       	movw	r14, r16
    ae36:	dd 24       	eor	r13, r13
    ae38:	cc 24       	eor	r12, r12
    ae3a:	0d a9       	sts	0x4d, r16
    ae3c:	1e a9       	sts	0x4e, r17
    ae3e:	2f a9       	sts	0x4f, r18
    ae40:	38 ad       	sts	0x68, r19
    ae42:	c9 01       	movw	r24, r18
    ae44:	aa 27       	eor	r26, r26
    ae46:	bb 27       	eor	r27, r27
    ae48:	c8 2a       	or	r12, r24
    ae4a:	d9 2a       	or	r13, r25
    ae4c:	ea 2a       	or	r14, r26
    ae4e:	fb 2a       	or	r15, r27
    ae50:	09 a5       	lds	r16, 0x69
    ae52:	1a a5       	lds	r17, 0x6a
    ae54:	2b a5       	lds	r18, 0x6b
    ae56:	3c a5       	lds	r19, 0x6c
    ae58:	c4 16       	cp	r12, r20
    ae5a:	d5 06       	cpc	r13, r21
    ae5c:	e6 06       	cpc	r14, r22
    ae5e:	f7 06       	cpc	r15, r23
    ae60:	38 f5       	brcc	.+78     	; 0xaeb0 <__divdi3+0x900>
    ae62:	01 50       	subi	r16, 0x01	; 1
    ae64:	10 40       	sbci	r17, 0x00	; 0
    ae66:	20 40       	sbci	r18, 0x00	; 0
    ae68:	30 40       	sbci	r19, 0x00	; 0
    ae6a:	09 ab       	sts	0x59, r16
    ae6c:	1a ab       	sts	0x5a, r17
    ae6e:	2b ab       	sts	0x5b, r18
    ae70:	3c ab       	sts	0x5c, r19
    ae72:	c8 0c       	add	r12, r8
    ae74:	d9 1c       	adc	r13, r9
    ae76:	ea 1c       	adc	r14, r10
    ae78:	fb 1c       	adc	r15, r11
    ae7a:	c8 14       	cp	r12, r8
    ae7c:	d9 04       	cpc	r13, r9
    ae7e:	ea 04       	cpc	r14, r10
    ae80:	fb 04       	cpc	r15, r11
    ae82:	d0 f0       	brcs	.+52     	; 0xaeb8 <__divdi3+0x908>
    ae84:	c4 16       	cp	r12, r20
    ae86:	d5 06       	cpc	r13, r21
    ae88:	e6 06       	cpc	r14, r22
    ae8a:	f7 06       	cpc	r15, r23
    ae8c:	a8 f4       	brcc	.+42     	; 0xaeb8 <__divdi3+0x908>
    ae8e:	09 a5       	lds	r16, 0x69
    ae90:	1a a5       	lds	r17, 0x6a
    ae92:	2b a5       	lds	r18, 0x6b
    ae94:	3c a5       	lds	r19, 0x6c
    ae96:	02 50       	subi	r16, 0x02	; 2
    ae98:	10 40       	sbci	r17, 0x00	; 0
    ae9a:	20 40       	sbci	r18, 0x00	; 0
    ae9c:	30 40       	sbci	r19, 0x00	; 0
    ae9e:	09 ab       	sts	0x59, r16
    aea0:	1a ab       	sts	0x5a, r17
    aea2:	2b ab       	sts	0x5b, r18
    aea4:	3c ab       	sts	0x5c, r19
    aea6:	c8 0c       	add	r12, r8
    aea8:	d9 1c       	adc	r13, r9
    aeaa:	ea 1c       	adc	r14, r10
    aeac:	fb 1c       	adc	r15, r11
    aeae:	04 c0       	rjmp	.+8      	; 0xaeb8 <__divdi3+0x908>
    aeb0:	09 ab       	sts	0x59, r16
    aeb2:	1a ab       	sts	0x5a, r17
    aeb4:	2b ab       	sts	0x5b, r18
    aeb6:	3c ab       	sts	0x5c, r19
    aeb8:	c4 1a       	sub	r12, r20
    aeba:	d5 0a       	sbc	r13, r21
    aebc:	e6 0a       	sbc	r14, r22
    aebe:	f7 0a       	sbc	r15, r23
    aec0:	c7 01       	movw	r24, r14
    aec2:	b6 01       	movw	r22, r12
    aec4:	2d a5       	lds	r18, 0x6d
    aec6:	3e a5       	lds	r19, 0x6e
    aec8:	4f a5       	lds	r20, 0x6f
    aeca:	58 a9       	sts	0x48, r21
    aecc:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    aed0:	29 a7       	lds	r18, 0x79
    aed2:	3a a7       	lds	r19, 0x7a
    aed4:	4b a7       	lds	r20, 0x7b
    aed6:	5c a7       	lds	r21, 0x7c
    aed8:	21 96       	adiw	r28, 0x01	; 1
    aeda:	6c af       	sts	0x7c, r22
    aedc:	7d af       	sts	0x7d, r23
    aede:	8e af       	sts	0x7e, r24
    aee0:	9f af       	sts	0x7f, r25
    aee2:	21 97       	sbiw	r28, 0x01	; 1
    aee4:	c7 01       	movw	r24, r14
    aee6:	b6 01       	movw	r22, r12
    aee8:	2d a5       	lds	r18, 0x6d
    aeea:	3e a5       	lds	r19, 0x6e
    aeec:	4f a5       	lds	r20, 0x6f
    aeee:	58 a9       	sts	0x48, r21
    aef0:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    aef4:	ca 01       	movw	r24, r20
    aef6:	b9 01       	movw	r22, r18
    aef8:	29 ad       	sts	0x69, r18
    aefa:	3a ad       	sts	0x6a, r19
    aefc:	4b ad       	sts	0x6b, r20
    aefe:	5c ad       	sts	0x6c, r21
    af00:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    af04:	8b 01       	movw	r16, r22
    af06:	9c 01       	movw	r18, r24
    af08:	21 96       	adiw	r28, 0x01	; 1
    af0a:	4c ad       	sts	0x6c, r20
    af0c:	5d ad       	sts	0x6d, r21
    af0e:	6e ad       	sts	0x6e, r22
    af10:	7f ad       	sts	0x6f, r23
    af12:	21 97       	sbiw	r28, 0x01	; 1
    af14:	da 01       	movw	r26, r20
    af16:	99 27       	eor	r25, r25
    af18:	88 27       	eor	r24, r24
    af1a:	4d a9       	sts	0x4d, r20
    af1c:	5e a9       	sts	0x4e, r21
    af1e:	6f a9       	sts	0x4f, r22
    af20:	78 ad       	sts	0x68, r23
    af22:	60 70       	andi	r22, 0x00	; 0
    af24:	70 70       	andi	r23, 0x00	; 0
    af26:	84 2b       	or	r24, r20
    af28:	95 2b       	or	r25, r21
    af2a:	a6 2b       	or	r26, r22
    af2c:	b7 2b       	or	r27, r23
    af2e:	49 a5       	lds	r20, 0x69
    af30:	5a a5       	lds	r21, 0x6a
    af32:	6b a5       	lds	r22, 0x6b
    af34:	7c a5       	lds	r23, 0x6c
    af36:	80 17       	cp	r24, r16
    af38:	91 07       	cpc	r25, r17
    af3a:	a2 07       	cpc	r26, r18
    af3c:	b3 07       	cpc	r27, r19
    af3e:	d0 f4       	brcc	.+52     	; 0xaf74 <__divdi3+0x9c4>
    af40:	41 50       	subi	r20, 0x01	; 1
    af42:	50 40       	sbci	r21, 0x00	; 0
    af44:	60 40       	sbci	r22, 0x00	; 0
    af46:	70 40       	sbci	r23, 0x00	; 0
    af48:	88 0d       	add	r24, r8
    af4a:	99 1d       	adc	r25, r9
    af4c:	aa 1d       	adc	r26, r10
    af4e:	bb 1d       	adc	r27, r11
    af50:	88 15       	cp	r24, r8
    af52:	99 05       	cpc	r25, r9
    af54:	aa 05       	cpc	r26, r10
    af56:	bb 05       	cpc	r27, r11
    af58:	68 f0       	brcs	.+26     	; 0xaf74 <__divdi3+0x9c4>
    af5a:	80 17       	cp	r24, r16
    af5c:	91 07       	cpc	r25, r17
    af5e:	a2 07       	cpc	r26, r18
    af60:	b3 07       	cpc	r27, r19
    af62:	40 f4       	brcc	.+16     	; 0xaf74 <__divdi3+0x9c4>
    af64:	49 a5       	lds	r20, 0x69
    af66:	5a a5       	lds	r21, 0x6a
    af68:	6b a5       	lds	r22, 0x6b
    af6a:	7c a5       	lds	r23, 0x6c
    af6c:	42 50       	subi	r20, 0x02	; 2
    af6e:	50 40       	sbci	r21, 0x00	; 0
    af70:	60 40       	sbci	r22, 0x00	; 0
    af72:	70 40       	sbci	r23, 0x00	; 0
    af74:	09 a9       	sts	0x49, r16
    af76:	1a a9       	sts	0x4a, r17
    af78:	2b a9       	sts	0x4b, r18
    af7a:	3c a9       	sts	0x4c, r19
    af7c:	78 01       	movw	r14, r16
    af7e:	dd 24       	eor	r13, r13
    af80:	cc 24       	eor	r12, r12
    af82:	c4 2a       	or	r12, r20
    af84:	d5 2a       	or	r13, r21
    af86:	e6 2a       	or	r14, r22
    af88:	f7 2a       	or	r15, r23
    af8a:	50 c2       	rjmp	.+1184   	; 0xb42c <__divdi3+0xe7c>
    af8c:	c8 16       	cp	r12, r24
    af8e:	d9 06       	cpc	r13, r25
    af90:	ea 06       	cpc	r14, r26
    af92:	fb 06       	cpc	r15, r27
    af94:	08 f4       	brcc	.+2      	; 0xaf98 <__divdi3+0x9e8>
    af96:	37 c2       	rjmp	.+1134   	; 0xb406 <__divdi3+0xe56>
    af98:	80 30       	cpi	r24, 0x00	; 0
    af9a:	10 e0       	ldi	r17, 0x00	; 0
    af9c:	91 07       	cpc	r25, r17
    af9e:	11 e0       	ldi	r17, 0x01	; 1
    afa0:	a1 07       	cpc	r26, r17
    afa2:	10 e0       	ldi	r17, 0x00	; 0
    afa4:	b1 07       	cpc	r27, r17
    afa6:	50 f4       	brcc	.+20     	; 0xafbc <__divdi3+0xa0c>
    afa8:	8f 3f       	cpi	r24, 0xFF	; 255
    afaa:	91 05       	cpc	r25, r1
    afac:	a1 05       	cpc	r26, r1
    afae:	b1 05       	cpc	r27, r1
    afb0:	09 f0       	breq	.+2      	; 0xafb4 <__divdi3+0xa04>
    afb2:	88 f4       	brcc	.+34     	; 0xafd6 <__divdi3+0xa26>
    afb4:	00 e0       	ldi	r16, 0x00	; 0
    afb6:	10 e0       	ldi	r17, 0x00	; 0
    afb8:	98 01       	movw	r18, r16
    afba:	16 c0       	rjmp	.+44     	; 0xafe8 <__divdi3+0xa38>
    afbc:	80 30       	cpi	r24, 0x00	; 0
    afbe:	20 e0       	ldi	r18, 0x00	; 0
    afc0:	92 07       	cpc	r25, r18
    afc2:	20 e0       	ldi	r18, 0x00	; 0
    afc4:	a2 07       	cpc	r26, r18
    afc6:	21 e0       	ldi	r18, 0x01	; 1
    afc8:	b2 07       	cpc	r27, r18
    afca:	50 f4       	brcc	.+20     	; 0xafe0 <__divdi3+0xa30>
    afcc:	00 e1       	ldi	r16, 0x10	; 16
    afce:	10 e0       	ldi	r17, 0x00	; 0
    afd0:	20 e0       	ldi	r18, 0x00	; 0
    afd2:	30 e0       	ldi	r19, 0x00	; 0
    afd4:	09 c0       	rjmp	.+18     	; 0xafe8 <__divdi3+0xa38>
    afd6:	08 e0       	ldi	r16, 0x08	; 8
    afd8:	10 e0       	ldi	r17, 0x00	; 0
    afda:	20 e0       	ldi	r18, 0x00	; 0
    afdc:	30 e0       	ldi	r19, 0x00	; 0
    afde:	04 c0       	rjmp	.+8      	; 0xafe8 <__divdi3+0xa38>
    afe0:	08 e1       	ldi	r16, 0x18	; 24
    afe2:	10 e0       	ldi	r17, 0x00	; 0
    afe4:	20 e0       	ldi	r18, 0x00	; 0
    afe6:	30 e0       	ldi	r19, 0x00	; 0
    afe8:	ac 01       	movw	r20, r24
    afea:	bd 01       	movw	r22, r26
    afec:	00 2e       	mov	r0, r16
    afee:	04 c0       	rjmp	.+8      	; 0xaff8 <__divdi3+0xa48>
    aff0:	76 95       	lsr	r23
    aff2:	67 95       	ror	r22
    aff4:	57 95       	ror	r21
    aff6:	47 95       	ror	r20
    aff8:	0a 94       	dec	r0
    affa:	d2 f7       	brpl	.-12     	; 0xaff0 <__divdi3+0xa40>
    affc:	fa 01       	movw	r30, r20
    affe:	e9 5c       	subi	r30, 0xC9	; 201
    b000:	ff 4d       	sbci	r31, 0xDF	; 223
    b002:	40 81       	ld	r20, Z
    b004:	04 0f       	add	r16, r20
    b006:	11 1d       	adc	r17, r1
    b008:	21 1d       	adc	r18, r1
    b00a:	31 1d       	adc	r19, r1
    b00c:	40 e2       	ldi	r20, 0x20	; 32
    b00e:	50 e0       	ldi	r21, 0x00	; 0
    b010:	60 e0       	ldi	r22, 0x00	; 0
    b012:	70 e0       	ldi	r23, 0x00	; 0
    b014:	40 1b       	sub	r20, r16
    b016:	51 0b       	sbc	r21, r17
    b018:	62 0b       	sbc	r22, r18
    b01a:	73 0b       	sbc	r23, r19
    b01c:	a1 f4       	brne	.+40     	; 0xb046 <__divdi3+0xa96>
    b01e:	8c 15       	cp	r24, r12
    b020:	9d 05       	cpc	r25, r13
    b022:	ae 05       	cpc	r26, r14
    b024:	bf 05       	cpc	r27, r15
    b026:	08 f4       	brcc	.+2      	; 0xb02a <__divdi3+0xa7a>
    b028:	f5 c1       	rjmp	.+1002   	; 0xb414 <__divdi3+0xe64>
    b02a:	ed a8       	sts	0x8d, r30
    b02c:	fe a8       	sts	0x8e, r31
    b02e:	0f a9       	sts	0x4f, r16
    b030:	18 ad       	sts	0x68, r17
    b032:	44 24       	eor	r4, r4
    b034:	55 24       	eor	r5, r5
    b036:	32 01       	movw	r6, r4
    b038:	e8 14       	cp	r14, r8
    b03a:	f9 04       	cpc	r15, r9
    b03c:	0a 05       	cpc	r16, r10
    b03e:	1b 05       	cpc	r17, r11
    b040:	08 f0       	brcs	.+2      	; 0xb044 <__divdi3+0xa94>
    b042:	eb c1       	rjmp	.+982    	; 0xb41a <__divdi3+0xe6a>
    b044:	e3 c1       	rjmp	.+966    	; 0xb40c <__divdi3+0xe5c>
    b046:	34 2e       	mov	r3, r20
    b048:	2c 01       	movw	r4, r24
    b04a:	3d 01       	movw	r6, r26
    b04c:	04 c0       	rjmp	.+8      	; 0xb056 <__divdi3+0xaa6>
    b04e:	44 0c       	add	r4, r4
    b050:	55 1c       	adc	r5, r5
    b052:	66 1c       	adc	r6, r6
    b054:	77 1c       	adc	r7, r7
    b056:	4a 95       	dec	r20
    b058:	d2 f7       	brpl	.-12     	; 0xb04e <__divdi3+0xa9e>
    b05a:	d5 01       	movw	r26, r10
    b05c:	c4 01       	movw	r24, r8
    b05e:	00 2e       	mov	r0, r16
    b060:	04 c0       	rjmp	.+8      	; 0xb06a <__divdi3+0xaba>
    b062:	b6 95       	lsr	r27
    b064:	a7 95       	ror	r26
    b066:	97 95       	ror	r25
    b068:	87 95       	ror	r24
    b06a:	0a 94       	dec	r0
    b06c:	d2 f7       	brpl	.-12     	; 0xb062 <__divdi3+0xab2>
    b06e:	48 2a       	or	r4, r24
    b070:	59 2a       	or	r5, r25
    b072:	6a 2a       	or	r6, r26
    b074:	7b 2a       	or	r7, r27
    b076:	a5 01       	movw	r20, r10
    b078:	94 01       	movw	r18, r8
    b07a:	03 2c       	mov	r0, r3
    b07c:	04 c0       	rjmp	.+8      	; 0xb086 <__divdi3+0xad6>
    b07e:	22 0f       	add	r18, r18
    b080:	33 1f       	adc	r19, r19
    b082:	44 1f       	adc	r20, r20
    b084:	55 1f       	adc	r21, r21
    b086:	0a 94       	dec	r0
    b088:	d2 f7       	brpl	.-12     	; 0xb07e <__divdi3+0xace>
    b08a:	29 af       	sts	0x79, r18
    b08c:	3a af       	sts	0x7a, r19
    b08e:	4b af       	sts	0x7b, r20
    b090:	5c af       	sts	0x7c, r21
    b092:	b7 01       	movw	r22, r14
    b094:	a6 01       	movw	r20, r12
    b096:	00 2e       	mov	r0, r16
    b098:	04 c0       	rjmp	.+8      	; 0xb0a2 <__divdi3+0xaf2>
    b09a:	76 95       	lsr	r23
    b09c:	67 95       	ror	r22
    b09e:	57 95       	ror	r21
    b0a0:	47 95       	ror	r20
    b0a2:	0a 94       	dec	r0
    b0a4:	d2 f7       	brpl	.-12     	; 0xb09a <__divdi3+0xaea>
    b0a6:	49 ab       	sts	0x59, r20
    b0a8:	5a ab       	sts	0x5a, r21
    b0aa:	6b ab       	sts	0x5b, r22
    b0ac:	7c ab       	sts	0x5c, r23
    b0ae:	c7 01       	movw	r24, r14
    b0b0:	b6 01       	movw	r22, r12
    b0b2:	03 2c       	mov	r0, r3
    b0b4:	04 c0       	rjmp	.+8      	; 0xb0be <__divdi3+0xb0e>
    b0b6:	66 0f       	add	r22, r22
    b0b8:	77 1f       	adc	r23, r23
    b0ba:	88 1f       	adc	r24, r24
    b0bc:	99 1f       	adc	r25, r25
    b0be:	0a 94       	dec	r0
    b0c0:	d2 f7       	brpl	.-12     	; 0xb0b6 <__divdi3+0xb06>
    b0c2:	6d a7       	lds	r22, 0x7d
    b0c4:	7e a7       	lds	r23, 0x7e
    b0c6:	8f a7       	lds	r24, 0x7f
    b0c8:	98 ab       	sts	0x58, r25
    b0ca:	8d a9       	sts	0x4d, r24
    b0cc:	9e a9       	sts	0x4e, r25
    b0ce:	af a9       	sts	0x4f, r26
    b0d0:	b8 ad       	sts	0x68, r27
    b0d2:	04 c0       	rjmp	.+8      	; 0xb0dc <__divdi3+0xb2c>
    b0d4:	b6 95       	lsr	r27
    b0d6:	a7 95       	ror	r26
    b0d8:	97 95       	ror	r25
    b0da:	87 95       	ror	r24
    b0dc:	0a 95       	dec	r16
    b0de:	d2 f7       	brpl	.-12     	; 0xb0d4 <__divdi3+0xb24>
    b0e0:	4d a5       	lds	r20, 0x6d
    b0e2:	5e a5       	lds	r21, 0x6e
    b0e4:	6f a5       	lds	r22, 0x6f
    b0e6:	78 a9       	sts	0x48, r23
    b0e8:	48 2b       	or	r20, r24
    b0ea:	59 2b       	or	r21, r25
    b0ec:	6a 2b       	or	r22, r26
    b0ee:	7b 2b       	or	r23, r27
    b0f0:	4d a7       	lds	r20, 0x7d
    b0f2:	5e a7       	lds	r21, 0x7e
    b0f4:	6f a7       	lds	r22, 0x7f
    b0f6:	78 ab       	sts	0x58, r23
    b0f8:	43 01       	movw	r8, r6
    b0fa:	aa 24       	eor	r10, r10
    b0fc:	bb 24       	eor	r11, r11
    b0fe:	93 01       	movw	r18, r6
    b100:	82 01       	movw	r16, r4
    b102:	20 70       	andi	r18, 0x00	; 0
    b104:	30 70       	andi	r19, 0x00	; 0
    b106:	21 96       	adiw	r28, 0x01	; 1
    b108:	0c af       	sts	0x7c, r16
    b10a:	1d af       	sts	0x7d, r17
    b10c:	2e af       	sts	0x7e, r18
    b10e:	3f af       	sts	0x7f, r19
    b110:	21 97       	sbiw	r28, 0x01	; 1
    b112:	69 a9       	sts	0x49, r22
    b114:	7a a9       	sts	0x4a, r23
    b116:	8b a9       	sts	0x4b, r24
    b118:	9c a9       	sts	0x4c, r25
    b11a:	a5 01       	movw	r20, r10
    b11c:	94 01       	movw	r18, r8
    b11e:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    b122:	29 a7       	lds	r18, 0x79
    b124:	3a a7       	lds	r19, 0x7a
    b126:	4b a7       	lds	r20, 0x7b
    b128:	5c a7       	lds	r21, 0x7c
    b12a:	6b 01       	movw	r12, r22
    b12c:	7c 01       	movw	r14, r24
    b12e:	69 a9       	sts	0x49, r22
    b130:	7a a9       	sts	0x4a, r23
    b132:	8b a9       	sts	0x4b, r24
    b134:	9c a9       	sts	0x4c, r25
    b136:	a5 01       	movw	r20, r10
    b138:	94 01       	movw	r18, r8
    b13a:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    b13e:	ca 01       	movw	r24, r20
    b140:	b9 01       	movw	r22, r18
    b142:	21 96       	adiw	r28, 0x01	; 1
    b144:	2c ad       	sts	0x6c, r18
    b146:	3d ad       	sts	0x6d, r19
    b148:	4e ad       	sts	0x6e, r20
    b14a:	5f ad       	sts	0x6f, r21
    b14c:	21 97       	sbiw	r28, 0x01	; 1
    b14e:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    b152:	dc 01       	movw	r26, r24
    b154:	cb 01       	movw	r24, r22
    b156:	76 01       	movw	r14, r12
    b158:	dd 24       	eor	r13, r13
    b15a:	cc 24       	eor	r12, r12
    b15c:	0d a5       	lds	r16, 0x6d
    b15e:	1e a5       	lds	r17, 0x6e
    b160:	2f a5       	lds	r18, 0x6f
    b162:	38 a9       	sts	0x48, r19
    b164:	a9 01       	movw	r20, r18
    b166:	66 27       	eor	r22, r22
    b168:	77 27       	eor	r23, r23
    b16a:	c4 2a       	or	r12, r20
    b16c:	d5 2a       	or	r13, r21
    b16e:	e6 2a       	or	r14, r22
    b170:	f7 2a       	or	r15, r23
    b172:	09 a5       	lds	r16, 0x69
    b174:	1a a5       	lds	r17, 0x6a
    b176:	2b a5       	lds	r18, 0x6b
    b178:	3c a5       	lds	r19, 0x6c
    b17a:	c8 16       	cp	r12, r24
    b17c:	d9 06       	cpc	r13, r25
    b17e:	ea 06       	cpc	r14, r26
    b180:	fb 06       	cpc	r15, r27
    b182:	38 f5       	brcc	.+78     	; 0xb1d2 <__divdi3+0xc22>
    b184:	01 50       	subi	r16, 0x01	; 1
    b186:	10 40       	sbci	r17, 0x00	; 0
    b188:	20 40       	sbci	r18, 0x00	; 0
    b18a:	30 40       	sbci	r19, 0x00	; 0
    b18c:	09 ab       	sts	0x59, r16
    b18e:	1a ab       	sts	0x5a, r17
    b190:	2b ab       	sts	0x5b, r18
    b192:	3c ab       	sts	0x5c, r19
    b194:	c4 0c       	add	r12, r4
    b196:	d5 1c       	adc	r13, r5
    b198:	e6 1c       	adc	r14, r6
    b19a:	f7 1c       	adc	r15, r7
    b19c:	c4 14       	cp	r12, r4
    b19e:	d5 04       	cpc	r13, r5
    b1a0:	e6 04       	cpc	r14, r6
    b1a2:	f7 04       	cpc	r15, r7
    b1a4:	d0 f0       	brcs	.+52     	; 0xb1da <__divdi3+0xc2a>
    b1a6:	c8 16       	cp	r12, r24
    b1a8:	d9 06       	cpc	r13, r25
    b1aa:	ea 06       	cpc	r14, r26
    b1ac:	fb 06       	cpc	r15, r27
    b1ae:	a8 f4       	brcc	.+42     	; 0xb1da <__divdi3+0xc2a>
    b1b0:	09 a5       	lds	r16, 0x69
    b1b2:	1a a5       	lds	r17, 0x6a
    b1b4:	2b a5       	lds	r18, 0x6b
    b1b6:	3c a5       	lds	r19, 0x6c
    b1b8:	02 50       	subi	r16, 0x02	; 2
    b1ba:	10 40       	sbci	r17, 0x00	; 0
    b1bc:	20 40       	sbci	r18, 0x00	; 0
    b1be:	30 40       	sbci	r19, 0x00	; 0
    b1c0:	09 ab       	sts	0x59, r16
    b1c2:	1a ab       	sts	0x5a, r17
    b1c4:	2b ab       	sts	0x5b, r18
    b1c6:	3c ab       	sts	0x5c, r19
    b1c8:	c4 0c       	add	r12, r4
    b1ca:	d5 1c       	adc	r13, r5
    b1cc:	e6 1c       	adc	r14, r6
    b1ce:	f7 1c       	adc	r15, r7
    b1d0:	04 c0       	rjmp	.+8      	; 0xb1da <__divdi3+0xc2a>
    b1d2:	09 ab       	sts	0x59, r16
    b1d4:	1a ab       	sts	0x5a, r17
    b1d6:	2b ab       	sts	0x5b, r18
    b1d8:	3c ab       	sts	0x5c, r19
    b1da:	c8 1a       	sub	r12, r24
    b1dc:	d9 0a       	sbc	r13, r25
    b1de:	ea 0a       	sbc	r14, r26
    b1e0:	fb 0a       	sbc	r15, r27
    b1e2:	c7 01       	movw	r24, r14
    b1e4:	b6 01       	movw	r22, r12
    b1e6:	a5 01       	movw	r20, r10
    b1e8:	94 01       	movw	r18, r8
    b1ea:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    b1ee:	29 a7       	lds	r18, 0x79
    b1f0:	3a a7       	lds	r19, 0x7a
    b1f2:	4b a7       	lds	r20, 0x7b
    b1f4:	5c a7       	lds	r21, 0x7c
    b1f6:	29 96       	adiw	r28, 0x09	; 9
    b1f8:	6c af       	sts	0x7c, r22
    b1fa:	7d af       	sts	0x7d, r23
    b1fc:	8e af       	sts	0x7e, r24
    b1fe:	9f af       	sts	0x7f, r25
    b200:	29 97       	sbiw	r28, 0x09	; 9
    b202:	c7 01       	movw	r24, r14
    b204:	b6 01       	movw	r22, r12
    b206:	a5 01       	movw	r20, r10
    b208:	94 01       	movw	r18, r8
    b20a:	0e 94 f0 5c 	call	0xb9e0	; 0xb9e0 <__udivmodsi4>
    b20e:	ca 01       	movw	r24, r20
    b210:	b9 01       	movw	r22, r18
    b212:	21 96       	adiw	r28, 0x01	; 1
    b214:	2c ad       	sts	0x6c, r18
    b216:	3d ad       	sts	0x6d, r19
    b218:	4e ad       	sts	0x6e, r20
    b21a:	5f ad       	sts	0x6f, r21
    b21c:	21 97       	sbiw	r28, 0x01	; 1
    b21e:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    b222:	4b 01       	movw	r8, r22
    b224:	5c 01       	movw	r10, r24
    b226:	29 96       	adiw	r28, 0x09	; 9
    b228:	4c ad       	sts	0x6c, r20
    b22a:	5d ad       	sts	0x6d, r21
    b22c:	6e ad       	sts	0x6e, r22
    b22e:	7f ad       	sts	0x6f, r23
    b230:	29 97       	sbiw	r28, 0x09	; 9
    b232:	9a 01       	movw	r18, r20
    b234:	11 27       	eor	r17, r17
    b236:	00 27       	eor	r16, r16
    b238:	8d a5       	lds	r24, 0x6d
    b23a:	9e a5       	lds	r25, 0x6e
    b23c:	af a5       	lds	r26, 0x6f
    b23e:	b8 a9       	sts	0x48, r27
    b240:	a0 70       	andi	r26, 0x00	; 0
    b242:	b0 70       	andi	r27, 0x00	; 0
    b244:	08 2b       	or	r16, r24
    b246:	19 2b       	or	r17, r25
    b248:	2a 2b       	or	r18, r26
    b24a:	3b 2b       	or	r19, r27
    b24c:	89 a5       	lds	r24, 0x69
    b24e:	9a a5       	lds	r25, 0x6a
    b250:	ab a5       	lds	r26, 0x6b
    b252:	bc a5       	lds	r27, 0x6c
    b254:	08 15       	cp	r16, r8
    b256:	19 05       	cpc	r17, r9
    b258:	2a 05       	cpc	r18, r10
    b25a:	3b 05       	cpc	r19, r11
    b25c:	e0 f4       	brcc	.+56     	; 0xb296 <__divdi3+0xce6>
    b25e:	01 97       	sbiw	r24, 0x01	; 1
    b260:	a1 09       	sbc	r26, r1
    b262:	b1 09       	sbc	r27, r1
    b264:	04 0d       	add	r16, r4
    b266:	15 1d       	adc	r17, r5
    b268:	26 1d       	adc	r18, r6
    b26a:	37 1d       	adc	r19, r7
    b26c:	04 15       	cp	r16, r4
    b26e:	15 05       	cpc	r17, r5
    b270:	26 05       	cpc	r18, r6
    b272:	37 05       	cpc	r19, r7
    b274:	80 f0       	brcs	.+32     	; 0xb296 <__divdi3+0xce6>
    b276:	08 15       	cp	r16, r8
    b278:	19 05       	cpc	r17, r9
    b27a:	2a 05       	cpc	r18, r10
    b27c:	3b 05       	cpc	r19, r11
    b27e:	58 f4       	brcc	.+22     	; 0xb296 <__divdi3+0xce6>
    b280:	89 a5       	lds	r24, 0x69
    b282:	9a a5       	lds	r25, 0x6a
    b284:	ab a5       	lds	r26, 0x6b
    b286:	bc a5       	lds	r27, 0x6c
    b288:	02 97       	sbiw	r24, 0x02	; 2
    b28a:	a1 09       	sbc	r26, r1
    b28c:	b1 09       	sbc	r27, r1
    b28e:	04 0d       	add	r16, r4
    b290:	15 1d       	adc	r17, r5
    b292:	26 1d       	adc	r18, r6
    b294:	37 1d       	adc	r19, r7
    b296:	b9 01       	movw	r22, r18
    b298:	a8 01       	movw	r20, r16
    b29a:	48 19       	sub	r20, r8
    b29c:	59 09       	sbc	r21, r9
    b29e:	6a 09       	sbc	r22, r10
    b2a0:	7b 09       	sbc	r23, r11
    b2a2:	4d a7       	lds	r20, 0x7d
    b2a4:	5e a7       	lds	r21, 0x7e
    b2a6:	6f a7       	lds	r22, 0x7f
    b2a8:	78 ab       	sts	0x58, r23
    b2aa:	09 a9       	sts	0x49, r16
    b2ac:	1a a9       	sts	0x4a, r17
    b2ae:	2b a9       	sts	0x4b, r18
    b2b0:	3c a9       	sts	0x4c, r19
    b2b2:	78 01       	movw	r14, r16
    b2b4:	dd 24       	eor	r13, r13
    b2b6:	cc 24       	eor	r12, r12
    b2b8:	c8 2a       	or	r12, r24
    b2ba:	d9 2a       	or	r13, r25
    b2bc:	ea 2a       	or	r14, r26
    b2be:	fb 2a       	or	r15, r27
    b2c0:	ff ef       	ldi	r31, 0xFF	; 255
    b2c2:	8f 2e       	mov	r8, r31
    b2c4:	ff ef       	ldi	r31, 0xFF	; 255
    b2c6:	9f 2e       	mov	r9, r31
    b2c8:	a1 2c       	mov	r10, r1
    b2ca:	b1 2c       	mov	r11, r1
    b2cc:	8c 20       	and	r8, r12
    b2ce:	9d 20       	and	r9, r13
    b2d0:	ae 20       	and	r10, r14
    b2d2:	bf 20       	and	r11, r15
    b2d4:	87 01       	movw	r16, r14
    b2d6:	22 27       	eor	r18, r18
    b2d8:	33 27       	eor	r19, r19
    b2da:	09 a7       	lds	r16, 0x79
    b2dc:	1a a7       	lds	r17, 0x7a
    b2de:	2b a7       	lds	r18, 0x7b
    b2e0:	3c a7       	lds	r19, 0x7c
    b2e2:	49 ac       	sts	0xa9, r20
    b2e4:	5a ac       	sts	0xaa, r21
    b2e6:	6b ac       	sts	0xab, r22
    b2e8:	7c ac       	sts	0xac, r23
    b2ea:	2f ef       	ldi	r18, 0xFF	; 255
    b2ec:	3f ef       	ldi	r19, 0xFF	; 255
    b2ee:	40 e0       	ldi	r20, 0x00	; 0
    b2f0:	50 e0       	ldi	r21, 0x00	; 0
    b2f2:	42 22       	and	r4, r18
    b2f4:	53 22       	and	r5, r19
    b2f6:	64 22       	and	r6, r20
    b2f8:	75 22       	and	r7, r21
    b2fa:	29 ad       	sts	0x69, r18
    b2fc:	3a ad       	sts	0x6a, r19
    b2fe:	4b ad       	sts	0x6b, r20
    b300:	5c ad       	sts	0x6c, r21
    b302:	8a 01       	movw	r16, r20
    b304:	22 27       	eor	r18, r18
    b306:	33 27       	eor	r19, r19
    b308:	09 ab       	sts	0x59, r16
    b30a:	1a ab       	sts	0x5a, r17
    b30c:	2b ab       	sts	0x5b, r18
    b30e:	3c ab       	sts	0x5c, r19
    b310:	c5 01       	movw	r24, r10
    b312:	b4 01       	movw	r22, r8
    b314:	a3 01       	movw	r20, r6
    b316:	92 01       	movw	r18, r4
    b318:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    b31c:	69 af       	sts	0x79, r22
    b31e:	7a af       	sts	0x7a, r23
    b320:	8b af       	sts	0x7b, r24
    b322:	9c af       	sts	0x7c, r25
    b324:	c5 01       	movw	r24, r10
    b326:	b4 01       	movw	r22, r8
    b328:	29 a9       	sts	0x49, r18
    b32a:	3a a9       	sts	0x4a, r19
    b32c:	4b a9       	sts	0x4b, r20
    b32e:	5c a9       	sts	0x4c, r21
    b330:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    b334:	4b 01       	movw	r8, r22
    b336:	5c 01       	movw	r10, r24
    b338:	69 a5       	lds	r22, 0x69
    b33a:	7a a5       	lds	r23, 0x6a
    b33c:	8b a5       	lds	r24, 0x6b
    b33e:	9c a5       	lds	r25, 0x6c
    b340:	a3 01       	movw	r20, r6
    b342:	92 01       	movw	r18, r4
    b344:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    b348:	2b 01       	movw	r4, r22
    b34a:	3c 01       	movw	r6, r24
    b34c:	69 a5       	lds	r22, 0x69
    b34e:	7a a5       	lds	r23, 0x6a
    b350:	8b a5       	lds	r24, 0x6b
    b352:	9c a5       	lds	r25, 0x6c
    b354:	29 a9       	sts	0x49, r18
    b356:	3a a9       	sts	0x4a, r19
    b358:	4b a9       	sts	0x4b, r20
    b35a:	5c a9       	sts	0x4c, r21
    b35c:	0e 94 aa 5c 	call	0xb954	; 0xb954 <__mulsi3>
    b360:	ab 01       	movw	r20, r22
    b362:	bc 01       	movw	r22, r24
    b364:	84 0c       	add	r8, r4
    b366:	95 1c       	adc	r9, r5
    b368:	a6 1c       	adc	r10, r6
    b36a:	b7 1c       	adc	r11, r7
    b36c:	09 ad       	sts	0x69, r16
    b36e:	1a ad       	sts	0x6a, r17
    b370:	2b ad       	sts	0x6b, r18
    b372:	3c ad       	sts	0x6c, r19
    b374:	c9 01       	movw	r24, r18
    b376:	aa 27       	eor	r26, r26
    b378:	bb 27       	eor	r27, r27
    b37a:	88 0e       	add	r8, r24
    b37c:	99 1e       	adc	r9, r25
    b37e:	aa 1e       	adc	r10, r26
    b380:	bb 1e       	adc	r11, r27
    b382:	84 14       	cp	r8, r4
    b384:	95 04       	cpc	r9, r5
    b386:	a6 04       	cpc	r10, r6
    b388:	b7 04       	cpc	r11, r7
    b38a:	20 f4       	brcc	.+8      	; 0xb394 <__divdi3+0xde4>
    b38c:	40 50       	subi	r20, 0x00	; 0
    b38e:	50 40       	sbci	r21, 0x00	; 0
    b390:	6f 4f       	sbci	r22, 0xFF	; 255
    b392:	7f 4f       	sbci	r23, 0xFF	; 255
    b394:	c5 01       	movw	r24, r10
    b396:	aa 27       	eor	r26, r26
    b398:	bb 27       	eor	r27, r27
    b39a:	84 0f       	add	r24, r20
    b39c:	95 1f       	adc	r25, r21
    b39e:	a6 1f       	adc	r26, r22
    b3a0:	b7 1f       	adc	r27, r23
    b3a2:	0d a5       	lds	r16, 0x6d
    b3a4:	1e a5       	lds	r17, 0x6e
    b3a6:	2f a5       	lds	r18, 0x6f
    b3a8:	38 a9       	sts	0x48, r19
    b3aa:	08 17       	cp	r16, r24
    b3ac:	19 07       	cpc	r17, r25
    b3ae:	2a 07       	cpc	r18, r26
    b3b0:	3b 07       	cpc	r19, r27
    b3b2:	18 f1       	brcs	.+70     	; 0xb3fa <__divdi3+0xe4a>
    b3b4:	80 17       	cp	r24, r16
    b3b6:	91 07       	cpc	r25, r17
    b3b8:	a2 07       	cpc	r26, r18
    b3ba:	b3 07       	cpc	r27, r19
    b3bc:	a1 f5       	brne	.+104    	; 0xb426 <__divdi3+0xe76>
    b3be:	54 01       	movw	r10, r8
    b3c0:	99 24       	eor	r9, r9
    b3c2:	88 24       	eor	r8, r8
    b3c4:	89 ad       	sts	0x69, r24
    b3c6:	9a ad       	sts	0x6a, r25
    b3c8:	ab ad       	sts	0x6b, r26
    b3ca:	bc ad       	sts	0x6c, r27
    b3cc:	a0 70       	andi	r26, 0x00	; 0
    b3ce:	b0 70       	andi	r27, 0x00	; 0
    b3d0:	88 0e       	add	r8, r24
    b3d2:	99 1e       	adc	r9, r25
    b3d4:	aa 1e       	adc	r10, r26
    b3d6:	bb 1e       	adc	r11, r27
    b3d8:	4d a9       	sts	0x4d, r20
    b3da:	5e a9       	sts	0x4e, r21
    b3dc:	6f a9       	sts	0x4f, r22
    b3de:	78 ad       	sts	0x68, r23
    b3e0:	03 2c       	mov	r0, r3
    b3e2:	04 c0       	rjmp	.+8      	; 0xb3ec <__divdi3+0xe3c>
    b3e4:	44 0f       	add	r20, r20
    b3e6:	55 1f       	adc	r21, r21
    b3e8:	66 1f       	adc	r22, r22
    b3ea:	77 1f       	adc	r23, r23
    b3ec:	0a 94       	dec	r0
    b3ee:	d2 f7       	brpl	.-12     	; 0xb3e4 <__divdi3+0xe34>
    b3f0:	48 15       	cp	r20, r8
    b3f2:	59 05       	cpc	r21, r9
    b3f4:	6a 05       	cpc	r22, r10
    b3f6:	7b 05       	cpc	r23, r11
    b3f8:	b0 f4       	brcc	.+44     	; 0xb426 <__divdi3+0xe76>
    b3fa:	08 94       	sec
    b3fc:	c1 08       	sbc	r12, r1
    b3fe:	d1 08       	sbc	r13, r1
    b400:	e1 08       	sbc	r14, r1
    b402:	f1 08       	sbc	r15, r1
    b404:	10 c0       	rjmp	.+32     	; 0xb426 <__divdi3+0xe76>
    b406:	44 24       	eor	r4, r4
    b408:	55 24       	eor	r5, r5
    b40a:	32 01       	movw	r6, r4
    b40c:	cc 24       	eor	r12, r12
    b40e:	dd 24       	eor	r13, r13
    b410:	76 01       	movw	r14, r12
    b412:	0c c0       	rjmp	.+24     	; 0xb42c <__divdi3+0xe7c>
    b414:	44 24       	eor	r4, r4
    b416:	55 24       	eor	r5, r5
    b418:	32 01       	movw	r6, r4
    b41a:	81 e0       	ldi	r24, 0x01	; 1
    b41c:	c8 2e       	mov	r12, r24
    b41e:	d1 2c       	mov	r13, r1
    b420:	e1 2c       	mov	r14, r1
    b422:	f1 2c       	mov	r15, r1
    b424:	03 c0       	rjmp	.+6      	; 0xb42c <__divdi3+0xe7c>
    b426:	44 24       	eor	r4, r4
    b428:	55 24       	eor	r5, r5
    b42a:	32 01       	movw	r6, r4
    b42c:	fe 01       	movw	r30, r28
    b42e:	31 96       	adiw	r30, 0x01	; 1
    b430:	88 e0       	ldi	r24, 0x08	; 8
    b432:	df 01       	movw	r26, r30
    b434:	1d 92       	st	X+, r1
    b436:	8a 95       	dec	r24
    b438:	e9 f7       	brne	.-6      	; 0xb434 <__divdi3+0xe84>
    b43a:	c9 82       	std	Y+1, r12	; 0x01
    b43c:	da 82       	std	Y+2, r13	; 0x02
    b43e:	eb 82       	std	Y+3, r14	; 0x03
    b440:	fc 82       	std	Y+4, r15	; 0x04
    b442:	4d 82       	std	Y+5, r4	; 0x05
    b444:	5e 82       	std	Y+6, r5	; 0x06
    b446:	6f 82       	std	Y+7, r6	; 0x07
    b448:	78 86       	std	Y+8, r7	; 0x08
    b44a:	2c 2d       	mov	r18, r12
    b44c:	3a 81       	ldd	r19, Y+2	; 0x02
    b44e:	4b 81       	ldd	r20, Y+3	; 0x03
    b450:	5c 81       	ldd	r21, Y+4	; 0x04
    b452:	64 2d       	mov	r22, r4
    b454:	7e 81       	ldd	r23, Y+6	; 0x06
    b456:	8f 81       	ldd	r24, Y+7	; 0x07
    b458:	98 85       	ldd	r25, Y+8	; 0x08
    b45a:	25 96       	adiw	r28, 0x05	; 5
    b45c:	ec ac       	sts	0xac, r30
    b45e:	fd ac       	sts	0xad, r31
    b460:	0e ad       	sts	0x6e, r16
    b462:	1f ad       	sts	0x6f, r17
    b464:	25 97       	sbiw	r28, 0x05	; 5
    b466:	e1 14       	cp	r14, r1
    b468:	f1 04       	cpc	r15, r1
    b46a:	01 05       	cpc	r16, r1
    b46c:	11 05       	cpc	r17, r1
    b46e:	09 f4       	brne	.+2      	; 0xb472 <__divdi3+0xec2>
    b470:	56 c0       	rjmp	.+172    	; 0xb51e <__divdi3+0xf6e>
    b472:	21 95       	neg	r18
    b474:	e1 e0       	ldi	r30, 0x01	; 1
    b476:	12 16       	cp	r1, r18
    b478:	08 f0       	brcs	.+2      	; 0xb47c <__divdi3+0xecc>
    b47a:	e0 e0       	ldi	r30, 0x00	; 0
    b47c:	31 95       	neg	r19
    b47e:	f1 e0       	ldi	r31, 0x01	; 1
    b480:	13 16       	cp	r1, r19
    b482:	08 f0       	brcs	.+2      	; 0xb486 <__divdi3+0xed6>
    b484:	f0 e0       	ldi	r31, 0x00	; 0
    b486:	03 2f       	mov	r16, r19
    b488:	0e 1b       	sub	r16, r30
    b48a:	e1 e0       	ldi	r30, 0x01	; 1
    b48c:	30 17       	cp	r19, r16
    b48e:	08 f0       	brcs	.+2      	; 0xb492 <__divdi3+0xee2>
    b490:	e0 e0       	ldi	r30, 0x00	; 0
    b492:	fe 2b       	or	r31, r30
    b494:	41 95       	neg	r20
    b496:	e1 e0       	ldi	r30, 0x01	; 1
    b498:	14 16       	cp	r1, r20
    b49a:	08 f0       	brcs	.+2      	; 0xb49e <__divdi3+0xeee>
    b49c:	e0 e0       	ldi	r30, 0x00	; 0
    b49e:	14 2f       	mov	r17, r20
    b4a0:	1f 1b       	sub	r17, r31
    b4a2:	31 e0       	ldi	r19, 0x01	; 1
    b4a4:	41 17       	cp	r20, r17
    b4a6:	08 f0       	brcs	.+2      	; 0xb4aa <__divdi3+0xefa>
    b4a8:	30 e0       	ldi	r19, 0x00	; 0
    b4aa:	e3 2b       	or	r30, r19
    b4ac:	51 95       	neg	r21
    b4ae:	f1 e0       	ldi	r31, 0x01	; 1
    b4b0:	15 16       	cp	r1, r21
    b4b2:	08 f0       	brcs	.+2      	; 0xb4b6 <__divdi3+0xf06>
    b4b4:	f0 e0       	ldi	r31, 0x00	; 0
    b4b6:	b5 2f       	mov	r27, r21
    b4b8:	be 1b       	sub	r27, r30
    b4ba:	31 e0       	ldi	r19, 0x01	; 1
    b4bc:	5b 17       	cp	r21, r27
    b4be:	08 f0       	brcs	.+2      	; 0xb4c2 <__divdi3+0xf12>
    b4c0:	30 e0       	ldi	r19, 0x00	; 0
    b4c2:	f3 2b       	or	r31, r19
    b4c4:	61 95       	neg	r22
    b4c6:	e1 e0       	ldi	r30, 0x01	; 1
    b4c8:	16 16       	cp	r1, r22
    b4ca:	08 f0       	brcs	.+2      	; 0xb4ce <__divdi3+0xf1e>
    b4cc:	e0 e0       	ldi	r30, 0x00	; 0
    b4ce:	46 2e       	mov	r4, r22
    b4d0:	4f 1a       	sub	r4, r31
    b4d2:	31 e0       	ldi	r19, 0x01	; 1
    b4d4:	64 15       	cp	r22, r4
    b4d6:	08 f0       	brcs	.+2      	; 0xb4da <__divdi3+0xf2a>
    b4d8:	30 e0       	ldi	r19, 0x00	; 0
    b4da:	e3 2b       	or	r30, r19
    b4dc:	71 95       	neg	r23
    b4de:	f1 e0       	ldi	r31, 0x01	; 1
    b4e0:	17 16       	cp	r1, r23
    b4e2:	08 f0       	brcs	.+2      	; 0xb4e6 <__divdi3+0xf36>
    b4e4:	f0 e0       	ldi	r31, 0x00	; 0
    b4e6:	a7 2f       	mov	r26, r23
    b4e8:	ae 1b       	sub	r26, r30
    b4ea:	31 e0       	ldi	r19, 0x01	; 1
    b4ec:	7a 17       	cp	r23, r26
    b4ee:	08 f0       	brcs	.+2      	; 0xb4f2 <__divdi3+0xf42>
    b4f0:	30 e0       	ldi	r19, 0x00	; 0
    b4f2:	f3 2b       	or	r31, r19
    b4f4:	81 95       	neg	r24
    b4f6:	e1 e0       	ldi	r30, 0x01	; 1
    b4f8:	18 16       	cp	r1, r24
    b4fa:	08 f0       	brcs	.+2      	; 0xb4fe <__divdi3+0xf4e>
    b4fc:	e0 e0       	ldi	r30, 0x00	; 0
    b4fe:	f8 2e       	mov	r15, r24
    b500:	ff 1a       	sub	r15, r31
    b502:	ff 2d       	mov	r31, r15
    b504:	31 e0       	ldi	r19, 0x01	; 1
    b506:	8f 15       	cp	r24, r15
    b508:	08 f0       	brcs	.+2      	; 0xb50c <__divdi3+0xf5c>
    b50a:	30 e0       	ldi	r19, 0x00	; 0
    b50c:	e3 2b       	or	r30, r19
    b50e:	91 95       	neg	r25
    b510:	30 2f       	mov	r19, r16
    b512:	41 2f       	mov	r20, r17
    b514:	5b 2f       	mov	r21, r27
    b516:	64 2d       	mov	r22, r4
    b518:	7a 2f       	mov	r23, r26
    b51a:	8f 2f       	mov	r24, r31
    b51c:	9e 1b       	sub	r25, r30
    b51e:	c8 5b       	subi	r28, 0xB8	; 184
    b520:	df 4f       	sbci	r29, 0xFF	; 255
    b522:	e1 e1       	ldi	r30, 0x11	; 17
    b524:	0c 94 47 5d 	jmp	0xba8e	; 0xba8e <__epilogue_restores__+0x2>

0000b528 <__subsf3>:
    b528:	50 58       	subi	r21, 0x80	; 128

0000b52a <__addsf3>:
    b52a:	bb 27       	eor	r27, r27
    b52c:	aa 27       	eor	r26, r26
    b52e:	0e d0       	rcall	.+28     	; 0xb54c <__addsf3x>
    b530:	70 c1       	rjmp	.+736    	; 0xb812 <__fp_round>
    b532:	61 d1       	rcall	.+706    	; 0xb7f6 <__fp_pscA>
    b534:	30 f0       	brcs	.+12     	; 0xb542 <__addsf3+0x18>
    b536:	66 d1       	rcall	.+716    	; 0xb804 <__fp_pscB>
    b538:	20 f0       	brcs	.+8      	; 0xb542 <__addsf3+0x18>
    b53a:	31 f4       	brne	.+12     	; 0xb548 <__addsf3+0x1e>
    b53c:	9f 3f       	cpi	r25, 0xFF	; 255
    b53e:	11 f4       	brne	.+4      	; 0xb544 <__addsf3+0x1a>
    b540:	1e f4       	brtc	.+6      	; 0xb548 <__addsf3+0x1e>
    b542:	56 c1       	rjmp	.+684    	; 0xb7f0 <__fp_nan>
    b544:	0e f4       	brtc	.+2      	; 0xb548 <__addsf3+0x1e>
    b546:	e0 95       	com	r30
    b548:	e7 fb       	bst	r30, 7
    b54a:	4c c1       	rjmp	.+664    	; 0xb7e4 <__fp_inf>

0000b54c <__addsf3x>:
    b54c:	e9 2f       	mov	r30, r25
    b54e:	72 d1       	rcall	.+740    	; 0xb834 <__fp_split3>
    b550:	80 f3       	brcs	.-32     	; 0xb532 <__addsf3+0x8>
    b552:	ba 17       	cp	r27, r26
    b554:	62 07       	cpc	r22, r18
    b556:	73 07       	cpc	r23, r19
    b558:	84 07       	cpc	r24, r20
    b55a:	95 07       	cpc	r25, r21
    b55c:	18 f0       	brcs	.+6      	; 0xb564 <__addsf3x+0x18>
    b55e:	71 f4       	brne	.+28     	; 0xb57c <__addsf3x+0x30>
    b560:	9e f5       	brtc	.+102    	; 0xb5c8 <__addsf3x+0x7c>
    b562:	8a c1       	rjmp	.+788    	; 0xb878 <__fp_zero>
    b564:	0e f4       	brtc	.+2      	; 0xb568 <__addsf3x+0x1c>
    b566:	e0 95       	com	r30
    b568:	0b 2e       	mov	r0, r27
    b56a:	ba 2f       	mov	r27, r26
    b56c:	a0 2d       	mov	r26, r0
    b56e:	0b 01       	movw	r0, r22
    b570:	b9 01       	movw	r22, r18
    b572:	90 01       	movw	r18, r0
    b574:	0c 01       	movw	r0, r24
    b576:	ca 01       	movw	r24, r20
    b578:	a0 01       	movw	r20, r0
    b57a:	11 24       	eor	r1, r1
    b57c:	ff 27       	eor	r31, r31
    b57e:	59 1b       	sub	r21, r25
    b580:	99 f0       	breq	.+38     	; 0xb5a8 <__addsf3x+0x5c>
    b582:	59 3f       	cpi	r21, 0xF9	; 249
    b584:	50 f4       	brcc	.+20     	; 0xb59a <__addsf3x+0x4e>
    b586:	50 3e       	cpi	r21, 0xE0	; 224
    b588:	68 f1       	brcs	.+90     	; 0xb5e4 <__addsf3x+0x98>
    b58a:	1a 16       	cp	r1, r26
    b58c:	f0 40       	sbci	r31, 0x00	; 0
    b58e:	a2 2f       	mov	r26, r18
    b590:	23 2f       	mov	r18, r19
    b592:	34 2f       	mov	r19, r20
    b594:	44 27       	eor	r20, r20
    b596:	58 5f       	subi	r21, 0xF8	; 248
    b598:	f3 cf       	rjmp	.-26     	; 0xb580 <__addsf3x+0x34>
    b59a:	46 95       	lsr	r20
    b59c:	37 95       	ror	r19
    b59e:	27 95       	ror	r18
    b5a0:	a7 95       	ror	r26
    b5a2:	f0 40       	sbci	r31, 0x00	; 0
    b5a4:	53 95       	inc	r21
    b5a6:	c9 f7       	brne	.-14     	; 0xb59a <__addsf3x+0x4e>
    b5a8:	7e f4       	brtc	.+30     	; 0xb5c8 <__addsf3x+0x7c>
    b5aa:	1f 16       	cp	r1, r31
    b5ac:	ba 0b       	sbc	r27, r26
    b5ae:	62 0b       	sbc	r22, r18
    b5b0:	73 0b       	sbc	r23, r19
    b5b2:	84 0b       	sbc	r24, r20
    b5b4:	ba f0       	brmi	.+46     	; 0xb5e4 <__addsf3x+0x98>
    b5b6:	91 50       	subi	r25, 0x01	; 1
    b5b8:	a1 f0       	breq	.+40     	; 0xb5e2 <__addsf3x+0x96>
    b5ba:	ff 0f       	add	r31, r31
    b5bc:	bb 1f       	adc	r27, r27
    b5be:	66 1f       	adc	r22, r22
    b5c0:	77 1f       	adc	r23, r23
    b5c2:	88 1f       	adc	r24, r24
    b5c4:	c2 f7       	brpl	.-16     	; 0xb5b6 <__addsf3x+0x6a>
    b5c6:	0e c0       	rjmp	.+28     	; 0xb5e4 <__addsf3x+0x98>
    b5c8:	ba 0f       	add	r27, r26
    b5ca:	62 1f       	adc	r22, r18
    b5cc:	73 1f       	adc	r23, r19
    b5ce:	84 1f       	adc	r24, r20
    b5d0:	48 f4       	brcc	.+18     	; 0xb5e4 <__addsf3x+0x98>
    b5d2:	87 95       	ror	r24
    b5d4:	77 95       	ror	r23
    b5d6:	67 95       	ror	r22
    b5d8:	b7 95       	ror	r27
    b5da:	f7 95       	ror	r31
    b5dc:	9e 3f       	cpi	r25, 0xFE	; 254
    b5de:	08 f0       	brcs	.+2      	; 0xb5e2 <__addsf3x+0x96>
    b5e0:	b3 cf       	rjmp	.-154    	; 0xb548 <__addsf3+0x1e>
    b5e2:	93 95       	inc	r25
    b5e4:	88 0f       	add	r24, r24
    b5e6:	08 f0       	brcs	.+2      	; 0xb5ea <__addsf3x+0x9e>
    b5e8:	99 27       	eor	r25, r25
    b5ea:	ee 0f       	add	r30, r30
    b5ec:	97 95       	ror	r25
    b5ee:	87 95       	ror	r24
    b5f0:	08 95       	ret

0000b5f2 <__cmpsf2>:
    b5f2:	d4 d0       	rcall	.+424    	; 0xb79c <__fp_cmp>
    b5f4:	08 f4       	brcc	.+2      	; 0xb5f8 <__cmpsf2+0x6>
    b5f6:	81 e0       	ldi	r24, 0x01	; 1
    b5f8:	08 95       	ret

0000b5fa <__divsf3>:
    b5fa:	0c d0       	rcall	.+24     	; 0xb614 <__divsf3x>
    b5fc:	0a c1       	rjmp	.+532    	; 0xb812 <__fp_round>
    b5fe:	02 d1       	rcall	.+516    	; 0xb804 <__fp_pscB>
    b600:	40 f0       	brcs	.+16     	; 0xb612 <__divsf3+0x18>
    b602:	f9 d0       	rcall	.+498    	; 0xb7f6 <__fp_pscA>
    b604:	30 f0       	brcs	.+12     	; 0xb612 <__divsf3+0x18>
    b606:	21 f4       	brne	.+8      	; 0xb610 <__divsf3+0x16>
    b608:	5f 3f       	cpi	r21, 0xFF	; 255
    b60a:	19 f0       	breq	.+6      	; 0xb612 <__divsf3+0x18>
    b60c:	eb c0       	rjmp	.+470    	; 0xb7e4 <__fp_inf>
    b60e:	51 11       	cpse	r21, r1
    b610:	34 c1       	rjmp	.+616    	; 0xb87a <__fp_szero>
    b612:	ee c0       	rjmp	.+476    	; 0xb7f0 <__fp_nan>

0000b614 <__divsf3x>:
    b614:	0f d1       	rcall	.+542    	; 0xb834 <__fp_split3>
    b616:	98 f3       	brcs	.-26     	; 0xb5fe <__divsf3+0x4>

0000b618 <__divsf3_pse>:
    b618:	99 23       	and	r25, r25
    b61a:	c9 f3       	breq	.-14     	; 0xb60e <__divsf3+0x14>
    b61c:	55 23       	and	r21, r21
    b61e:	b1 f3       	breq	.-20     	; 0xb60c <__divsf3+0x12>
    b620:	95 1b       	sub	r25, r21
    b622:	55 0b       	sbc	r21, r21
    b624:	bb 27       	eor	r27, r27
    b626:	aa 27       	eor	r26, r26
    b628:	62 17       	cp	r22, r18
    b62a:	73 07       	cpc	r23, r19
    b62c:	84 07       	cpc	r24, r20
    b62e:	38 f0       	brcs	.+14     	; 0xb63e <__divsf3_pse+0x26>
    b630:	9f 5f       	subi	r25, 0xFF	; 255
    b632:	5f 4f       	sbci	r21, 0xFF	; 255
    b634:	22 0f       	add	r18, r18
    b636:	33 1f       	adc	r19, r19
    b638:	44 1f       	adc	r20, r20
    b63a:	aa 1f       	adc	r26, r26
    b63c:	a9 f3       	breq	.-22     	; 0xb628 <__divsf3_pse+0x10>
    b63e:	33 d0       	rcall	.+102    	; 0xb6a6 <__divsf3_pse+0x8e>
    b640:	0e 2e       	mov	r0, r30
    b642:	3a f0       	brmi	.+14     	; 0xb652 <__divsf3_pse+0x3a>
    b644:	e0 e8       	ldi	r30, 0x80	; 128
    b646:	30 d0       	rcall	.+96     	; 0xb6a8 <__divsf3_pse+0x90>
    b648:	91 50       	subi	r25, 0x01	; 1
    b64a:	50 40       	sbci	r21, 0x00	; 0
    b64c:	e6 95       	lsr	r30
    b64e:	00 1c       	adc	r0, r0
    b650:	ca f7       	brpl	.-14     	; 0xb644 <__divsf3_pse+0x2c>
    b652:	29 d0       	rcall	.+82     	; 0xb6a6 <__divsf3_pse+0x8e>
    b654:	fe 2f       	mov	r31, r30
    b656:	27 d0       	rcall	.+78     	; 0xb6a6 <__divsf3_pse+0x8e>
    b658:	66 0f       	add	r22, r22
    b65a:	77 1f       	adc	r23, r23
    b65c:	88 1f       	adc	r24, r24
    b65e:	bb 1f       	adc	r27, r27
    b660:	26 17       	cp	r18, r22
    b662:	37 07       	cpc	r19, r23
    b664:	48 07       	cpc	r20, r24
    b666:	ab 07       	cpc	r26, r27
    b668:	b0 e8       	ldi	r27, 0x80	; 128
    b66a:	09 f0       	breq	.+2      	; 0xb66e <__divsf3_pse+0x56>
    b66c:	bb 0b       	sbc	r27, r27
    b66e:	80 2d       	mov	r24, r0
    b670:	bf 01       	movw	r22, r30
    b672:	ff 27       	eor	r31, r31
    b674:	93 58       	subi	r25, 0x83	; 131
    b676:	5f 4f       	sbci	r21, 0xFF	; 255
    b678:	2a f0       	brmi	.+10     	; 0xb684 <__divsf3_pse+0x6c>
    b67a:	9e 3f       	cpi	r25, 0xFE	; 254
    b67c:	51 05       	cpc	r21, r1
    b67e:	68 f0       	brcs	.+26     	; 0xb69a <__divsf3_pse+0x82>
    b680:	b1 c0       	rjmp	.+354    	; 0xb7e4 <__fp_inf>
    b682:	fb c0       	rjmp	.+502    	; 0xb87a <__fp_szero>
    b684:	5f 3f       	cpi	r21, 0xFF	; 255
    b686:	ec f3       	brlt	.-6      	; 0xb682 <__divsf3_pse+0x6a>
    b688:	98 3e       	cpi	r25, 0xE8	; 232
    b68a:	dc f3       	brlt	.-10     	; 0xb682 <__divsf3_pse+0x6a>
    b68c:	86 95       	lsr	r24
    b68e:	77 95       	ror	r23
    b690:	67 95       	ror	r22
    b692:	b7 95       	ror	r27
    b694:	f7 95       	ror	r31
    b696:	9f 5f       	subi	r25, 0xFF	; 255
    b698:	c9 f7       	brne	.-14     	; 0xb68c <__divsf3_pse+0x74>
    b69a:	88 0f       	add	r24, r24
    b69c:	91 1d       	adc	r25, r1
    b69e:	96 95       	lsr	r25
    b6a0:	87 95       	ror	r24
    b6a2:	97 f9       	bld	r25, 7
    b6a4:	08 95       	ret
    b6a6:	e1 e0       	ldi	r30, 0x01	; 1
    b6a8:	66 0f       	add	r22, r22
    b6aa:	77 1f       	adc	r23, r23
    b6ac:	88 1f       	adc	r24, r24
    b6ae:	bb 1f       	adc	r27, r27
    b6b0:	62 17       	cp	r22, r18
    b6b2:	73 07       	cpc	r23, r19
    b6b4:	84 07       	cpc	r24, r20
    b6b6:	ba 07       	cpc	r27, r26
    b6b8:	20 f0       	brcs	.+8      	; 0xb6c2 <__divsf3_pse+0xaa>
    b6ba:	62 1b       	sub	r22, r18
    b6bc:	73 0b       	sbc	r23, r19
    b6be:	84 0b       	sbc	r24, r20
    b6c0:	ba 0b       	sbc	r27, r26
    b6c2:	ee 1f       	adc	r30, r30
    b6c4:	88 f7       	brcc	.-30     	; 0xb6a8 <__divsf3_pse+0x90>
    b6c6:	e0 95       	com	r30
    b6c8:	08 95       	ret

0000b6ca <__fixunssfsi>:
    b6ca:	bc d0       	rcall	.+376    	; 0xb844 <__fp_splitA>
    b6cc:	88 f0       	brcs	.+34     	; 0xb6f0 <__fixunssfsi+0x26>
    b6ce:	9f 57       	subi	r25, 0x7F	; 127
    b6d0:	90 f0       	brcs	.+36     	; 0xb6f6 <__fixunssfsi+0x2c>
    b6d2:	b9 2f       	mov	r27, r25
    b6d4:	99 27       	eor	r25, r25
    b6d6:	b7 51       	subi	r27, 0x17	; 23
    b6d8:	a0 f0       	brcs	.+40     	; 0xb702 <__fixunssfsi+0x38>
    b6da:	d1 f0       	breq	.+52     	; 0xb710 <__fixunssfsi+0x46>
    b6dc:	66 0f       	add	r22, r22
    b6de:	77 1f       	adc	r23, r23
    b6e0:	88 1f       	adc	r24, r24
    b6e2:	99 1f       	adc	r25, r25
    b6e4:	1a f0       	brmi	.+6      	; 0xb6ec <__fixunssfsi+0x22>
    b6e6:	ba 95       	dec	r27
    b6e8:	c9 f7       	brne	.-14     	; 0xb6dc <__fixunssfsi+0x12>
    b6ea:	12 c0       	rjmp	.+36     	; 0xb710 <__fixunssfsi+0x46>
    b6ec:	b1 30       	cpi	r27, 0x01	; 1
    b6ee:	81 f0       	breq	.+32     	; 0xb710 <__fixunssfsi+0x46>
    b6f0:	c3 d0       	rcall	.+390    	; 0xb878 <__fp_zero>
    b6f2:	b1 e0       	ldi	r27, 0x01	; 1
    b6f4:	08 95       	ret
    b6f6:	c0 c0       	rjmp	.+384    	; 0xb878 <__fp_zero>
    b6f8:	67 2f       	mov	r22, r23
    b6fa:	78 2f       	mov	r23, r24
    b6fc:	88 27       	eor	r24, r24
    b6fe:	b8 5f       	subi	r27, 0xF8	; 248
    b700:	39 f0       	breq	.+14     	; 0xb710 <__fixunssfsi+0x46>
    b702:	b9 3f       	cpi	r27, 0xF9	; 249
    b704:	cc f3       	brlt	.-14     	; 0xb6f8 <__fixunssfsi+0x2e>
    b706:	86 95       	lsr	r24
    b708:	77 95       	ror	r23
    b70a:	67 95       	ror	r22
    b70c:	b3 95       	inc	r27
    b70e:	d9 f7       	brne	.-10     	; 0xb706 <__fixunssfsi+0x3c>
    b710:	3e f4       	brtc	.+14     	; 0xb720 <__fixunssfsi+0x56>
    b712:	90 95       	com	r25
    b714:	80 95       	com	r24
    b716:	70 95       	com	r23
    b718:	61 95       	neg	r22
    b71a:	7f 4f       	sbci	r23, 0xFF	; 255
    b71c:	8f 4f       	sbci	r24, 0xFF	; 255
    b71e:	9f 4f       	sbci	r25, 0xFF	; 255
    b720:	08 95       	ret

0000b722 <__floatunsisf>:
    b722:	e8 94       	clt
    b724:	09 c0       	rjmp	.+18     	; 0xb738 <__floatsisf+0x12>

0000b726 <__floatsisf>:
    b726:	97 fb       	bst	r25, 7
    b728:	3e f4       	brtc	.+14     	; 0xb738 <__floatsisf+0x12>
    b72a:	90 95       	com	r25
    b72c:	80 95       	com	r24
    b72e:	70 95       	com	r23
    b730:	61 95       	neg	r22
    b732:	7f 4f       	sbci	r23, 0xFF	; 255
    b734:	8f 4f       	sbci	r24, 0xFF	; 255
    b736:	9f 4f       	sbci	r25, 0xFF	; 255
    b738:	99 23       	and	r25, r25
    b73a:	a9 f0       	breq	.+42     	; 0xb766 <__floatsisf+0x40>
    b73c:	f9 2f       	mov	r31, r25
    b73e:	96 e9       	ldi	r25, 0x96	; 150
    b740:	bb 27       	eor	r27, r27
    b742:	93 95       	inc	r25
    b744:	f6 95       	lsr	r31
    b746:	87 95       	ror	r24
    b748:	77 95       	ror	r23
    b74a:	67 95       	ror	r22
    b74c:	b7 95       	ror	r27
    b74e:	f1 11       	cpse	r31, r1
    b750:	f8 cf       	rjmp	.-16     	; 0xb742 <__floatsisf+0x1c>
    b752:	fa f4       	brpl	.+62     	; 0xb792 <__floatsisf+0x6c>
    b754:	bb 0f       	add	r27, r27
    b756:	11 f4       	brne	.+4      	; 0xb75c <__floatsisf+0x36>
    b758:	60 ff       	sbrs	r22, 0
    b75a:	1b c0       	rjmp	.+54     	; 0xb792 <__floatsisf+0x6c>
    b75c:	6f 5f       	subi	r22, 0xFF	; 255
    b75e:	7f 4f       	sbci	r23, 0xFF	; 255
    b760:	8f 4f       	sbci	r24, 0xFF	; 255
    b762:	9f 4f       	sbci	r25, 0xFF	; 255
    b764:	16 c0       	rjmp	.+44     	; 0xb792 <__floatsisf+0x6c>
    b766:	88 23       	and	r24, r24
    b768:	11 f0       	breq	.+4      	; 0xb76e <__floatsisf+0x48>
    b76a:	96 e9       	ldi	r25, 0x96	; 150
    b76c:	11 c0       	rjmp	.+34     	; 0xb790 <__floatsisf+0x6a>
    b76e:	77 23       	and	r23, r23
    b770:	21 f0       	breq	.+8      	; 0xb77a <__floatsisf+0x54>
    b772:	9e e8       	ldi	r25, 0x8E	; 142
    b774:	87 2f       	mov	r24, r23
    b776:	76 2f       	mov	r23, r22
    b778:	05 c0       	rjmp	.+10     	; 0xb784 <__floatsisf+0x5e>
    b77a:	66 23       	and	r22, r22
    b77c:	71 f0       	breq	.+28     	; 0xb79a <__floatsisf+0x74>
    b77e:	96 e8       	ldi	r25, 0x86	; 134
    b780:	86 2f       	mov	r24, r22
    b782:	70 e0       	ldi	r23, 0x00	; 0
    b784:	60 e0       	ldi	r22, 0x00	; 0
    b786:	2a f0       	brmi	.+10     	; 0xb792 <__floatsisf+0x6c>
    b788:	9a 95       	dec	r25
    b78a:	66 0f       	add	r22, r22
    b78c:	77 1f       	adc	r23, r23
    b78e:	88 1f       	adc	r24, r24
    b790:	da f7       	brpl	.-10     	; 0xb788 <__floatsisf+0x62>
    b792:	88 0f       	add	r24, r24
    b794:	96 95       	lsr	r25
    b796:	87 95       	ror	r24
    b798:	97 f9       	bld	r25, 7
    b79a:	08 95       	ret

0000b79c <__fp_cmp>:
    b79c:	99 0f       	add	r25, r25
    b79e:	00 08       	sbc	r0, r0
    b7a0:	55 0f       	add	r21, r21
    b7a2:	aa 0b       	sbc	r26, r26
    b7a4:	e0 e8       	ldi	r30, 0x80	; 128
    b7a6:	fe ef       	ldi	r31, 0xFE	; 254
    b7a8:	16 16       	cp	r1, r22
    b7aa:	17 06       	cpc	r1, r23
    b7ac:	e8 07       	cpc	r30, r24
    b7ae:	f9 07       	cpc	r31, r25
    b7b0:	c0 f0       	brcs	.+48     	; 0xb7e2 <__fp_cmp+0x46>
    b7b2:	12 16       	cp	r1, r18
    b7b4:	13 06       	cpc	r1, r19
    b7b6:	e4 07       	cpc	r30, r20
    b7b8:	f5 07       	cpc	r31, r21
    b7ba:	98 f0       	brcs	.+38     	; 0xb7e2 <__fp_cmp+0x46>
    b7bc:	62 1b       	sub	r22, r18
    b7be:	73 0b       	sbc	r23, r19
    b7c0:	84 0b       	sbc	r24, r20
    b7c2:	95 0b       	sbc	r25, r21
    b7c4:	39 f4       	brne	.+14     	; 0xb7d4 <__fp_cmp+0x38>
    b7c6:	0a 26       	eor	r0, r26
    b7c8:	61 f0       	breq	.+24     	; 0xb7e2 <__fp_cmp+0x46>
    b7ca:	23 2b       	or	r18, r19
    b7cc:	24 2b       	or	r18, r20
    b7ce:	25 2b       	or	r18, r21
    b7d0:	21 f4       	brne	.+8      	; 0xb7da <__fp_cmp+0x3e>
    b7d2:	08 95       	ret
    b7d4:	0a 26       	eor	r0, r26
    b7d6:	09 f4       	brne	.+2      	; 0xb7da <__fp_cmp+0x3e>
    b7d8:	a1 40       	sbci	r26, 0x01	; 1
    b7da:	a6 95       	lsr	r26
    b7dc:	8f ef       	ldi	r24, 0xFF	; 255
    b7de:	81 1d       	adc	r24, r1
    b7e0:	81 1d       	adc	r24, r1
    b7e2:	08 95       	ret

0000b7e4 <__fp_inf>:
    b7e4:	97 f9       	bld	r25, 7
    b7e6:	9f 67       	ori	r25, 0x7F	; 127
    b7e8:	80 e8       	ldi	r24, 0x80	; 128
    b7ea:	70 e0       	ldi	r23, 0x00	; 0
    b7ec:	60 e0       	ldi	r22, 0x00	; 0
    b7ee:	08 95       	ret

0000b7f0 <__fp_nan>:
    b7f0:	9f ef       	ldi	r25, 0xFF	; 255
    b7f2:	80 ec       	ldi	r24, 0xC0	; 192
    b7f4:	08 95       	ret

0000b7f6 <__fp_pscA>:
    b7f6:	00 24       	eor	r0, r0
    b7f8:	0a 94       	dec	r0
    b7fa:	16 16       	cp	r1, r22
    b7fc:	17 06       	cpc	r1, r23
    b7fe:	18 06       	cpc	r1, r24
    b800:	09 06       	cpc	r0, r25
    b802:	08 95       	ret

0000b804 <__fp_pscB>:
    b804:	00 24       	eor	r0, r0
    b806:	0a 94       	dec	r0
    b808:	12 16       	cp	r1, r18
    b80a:	13 06       	cpc	r1, r19
    b80c:	14 06       	cpc	r1, r20
    b80e:	05 06       	cpc	r0, r21
    b810:	08 95       	ret

0000b812 <__fp_round>:
    b812:	09 2e       	mov	r0, r25
    b814:	03 94       	inc	r0
    b816:	00 0c       	add	r0, r0
    b818:	11 f4       	brne	.+4      	; 0xb81e <__fp_round+0xc>
    b81a:	88 23       	and	r24, r24
    b81c:	52 f0       	brmi	.+20     	; 0xb832 <__fp_round+0x20>
    b81e:	bb 0f       	add	r27, r27
    b820:	40 f4       	brcc	.+16     	; 0xb832 <__fp_round+0x20>
    b822:	bf 2b       	or	r27, r31
    b824:	11 f4       	brne	.+4      	; 0xb82a <__fp_round+0x18>
    b826:	60 ff       	sbrs	r22, 0
    b828:	04 c0       	rjmp	.+8      	; 0xb832 <__fp_round+0x20>
    b82a:	6f 5f       	subi	r22, 0xFF	; 255
    b82c:	7f 4f       	sbci	r23, 0xFF	; 255
    b82e:	8f 4f       	sbci	r24, 0xFF	; 255
    b830:	9f 4f       	sbci	r25, 0xFF	; 255
    b832:	08 95       	ret

0000b834 <__fp_split3>:
    b834:	57 fd       	sbrc	r21, 7
    b836:	90 58       	subi	r25, 0x80	; 128
    b838:	44 0f       	add	r20, r20
    b83a:	55 1f       	adc	r21, r21
    b83c:	59 f0       	breq	.+22     	; 0xb854 <__fp_splitA+0x10>
    b83e:	5f 3f       	cpi	r21, 0xFF	; 255
    b840:	71 f0       	breq	.+28     	; 0xb85e <__fp_splitA+0x1a>
    b842:	47 95       	ror	r20

0000b844 <__fp_splitA>:
    b844:	88 0f       	add	r24, r24
    b846:	97 fb       	bst	r25, 7
    b848:	99 1f       	adc	r25, r25
    b84a:	61 f0       	breq	.+24     	; 0xb864 <__fp_splitA+0x20>
    b84c:	9f 3f       	cpi	r25, 0xFF	; 255
    b84e:	79 f0       	breq	.+30     	; 0xb86e <__fp_splitA+0x2a>
    b850:	87 95       	ror	r24
    b852:	08 95       	ret
    b854:	12 16       	cp	r1, r18
    b856:	13 06       	cpc	r1, r19
    b858:	14 06       	cpc	r1, r20
    b85a:	55 1f       	adc	r21, r21
    b85c:	f2 cf       	rjmp	.-28     	; 0xb842 <__fp_split3+0xe>
    b85e:	46 95       	lsr	r20
    b860:	f1 df       	rcall	.-30     	; 0xb844 <__fp_splitA>
    b862:	08 c0       	rjmp	.+16     	; 0xb874 <__fp_splitA+0x30>
    b864:	16 16       	cp	r1, r22
    b866:	17 06       	cpc	r1, r23
    b868:	18 06       	cpc	r1, r24
    b86a:	99 1f       	adc	r25, r25
    b86c:	f1 cf       	rjmp	.-30     	; 0xb850 <__fp_splitA+0xc>
    b86e:	86 95       	lsr	r24
    b870:	71 05       	cpc	r23, r1
    b872:	61 05       	cpc	r22, r1
    b874:	08 94       	sec
    b876:	08 95       	ret

0000b878 <__fp_zero>:
    b878:	e8 94       	clt

0000b87a <__fp_szero>:
    b87a:	bb 27       	eor	r27, r27
    b87c:	66 27       	eor	r22, r22
    b87e:	77 27       	eor	r23, r23
    b880:	cb 01       	movw	r24, r22
    b882:	97 f9       	bld	r25, 7
    b884:	08 95       	ret

0000b886 <__gesf2>:
    b886:	8a df       	rcall	.-236    	; 0xb79c <__fp_cmp>
    b888:	08 f4       	brcc	.+2      	; 0xb88c <__gesf2+0x6>
    b88a:	8f ef       	ldi	r24, 0xFF	; 255
    b88c:	08 95       	ret

0000b88e <__mulsf3>:
    b88e:	0b d0       	rcall	.+22     	; 0xb8a6 <__mulsf3x>
    b890:	c0 cf       	rjmp	.-128    	; 0xb812 <__fp_round>
    b892:	b1 df       	rcall	.-158    	; 0xb7f6 <__fp_pscA>
    b894:	28 f0       	brcs	.+10     	; 0xb8a0 <__mulsf3+0x12>
    b896:	b6 df       	rcall	.-148    	; 0xb804 <__fp_pscB>
    b898:	18 f0       	brcs	.+6      	; 0xb8a0 <__mulsf3+0x12>
    b89a:	95 23       	and	r25, r21
    b89c:	09 f0       	breq	.+2      	; 0xb8a0 <__mulsf3+0x12>
    b89e:	a2 cf       	rjmp	.-188    	; 0xb7e4 <__fp_inf>
    b8a0:	a7 cf       	rjmp	.-178    	; 0xb7f0 <__fp_nan>
    b8a2:	11 24       	eor	r1, r1
    b8a4:	ea cf       	rjmp	.-44     	; 0xb87a <__fp_szero>

0000b8a6 <__mulsf3x>:
    b8a6:	c6 df       	rcall	.-116    	; 0xb834 <__fp_split3>
    b8a8:	a0 f3       	brcs	.-24     	; 0xb892 <__mulsf3+0x4>

0000b8aa <__mulsf3_pse>:
    b8aa:	95 9f       	mul	r25, r21
    b8ac:	d1 f3       	breq	.-12     	; 0xb8a2 <__mulsf3+0x14>
    b8ae:	95 0f       	add	r25, r21
    b8b0:	50 e0       	ldi	r21, 0x00	; 0
    b8b2:	55 1f       	adc	r21, r21
    b8b4:	62 9f       	mul	r22, r18
    b8b6:	f0 01       	movw	r30, r0
    b8b8:	72 9f       	mul	r23, r18
    b8ba:	bb 27       	eor	r27, r27
    b8bc:	f0 0d       	add	r31, r0
    b8be:	b1 1d       	adc	r27, r1
    b8c0:	63 9f       	mul	r22, r19
    b8c2:	aa 27       	eor	r26, r26
    b8c4:	f0 0d       	add	r31, r0
    b8c6:	b1 1d       	adc	r27, r1
    b8c8:	aa 1f       	adc	r26, r26
    b8ca:	64 9f       	mul	r22, r20
    b8cc:	66 27       	eor	r22, r22
    b8ce:	b0 0d       	add	r27, r0
    b8d0:	a1 1d       	adc	r26, r1
    b8d2:	66 1f       	adc	r22, r22
    b8d4:	82 9f       	mul	r24, r18
    b8d6:	22 27       	eor	r18, r18
    b8d8:	b0 0d       	add	r27, r0
    b8da:	a1 1d       	adc	r26, r1
    b8dc:	62 1f       	adc	r22, r18
    b8de:	73 9f       	mul	r23, r19
    b8e0:	b0 0d       	add	r27, r0
    b8e2:	a1 1d       	adc	r26, r1
    b8e4:	62 1f       	adc	r22, r18
    b8e6:	83 9f       	mul	r24, r19
    b8e8:	a0 0d       	add	r26, r0
    b8ea:	61 1d       	adc	r22, r1
    b8ec:	22 1f       	adc	r18, r18
    b8ee:	74 9f       	mul	r23, r20
    b8f0:	33 27       	eor	r19, r19
    b8f2:	a0 0d       	add	r26, r0
    b8f4:	61 1d       	adc	r22, r1
    b8f6:	23 1f       	adc	r18, r19
    b8f8:	84 9f       	mul	r24, r20
    b8fa:	60 0d       	add	r22, r0
    b8fc:	21 1d       	adc	r18, r1
    b8fe:	82 2f       	mov	r24, r18
    b900:	76 2f       	mov	r23, r22
    b902:	6a 2f       	mov	r22, r26
    b904:	11 24       	eor	r1, r1
    b906:	9f 57       	subi	r25, 0x7F	; 127
    b908:	50 40       	sbci	r21, 0x00	; 0
    b90a:	8a f0       	brmi	.+34     	; 0xb92e <__mulsf3_pse+0x84>
    b90c:	e1 f0       	breq	.+56     	; 0xb946 <__mulsf3_pse+0x9c>
    b90e:	88 23       	and	r24, r24
    b910:	4a f0       	brmi	.+18     	; 0xb924 <__mulsf3_pse+0x7a>
    b912:	ee 0f       	add	r30, r30
    b914:	ff 1f       	adc	r31, r31
    b916:	bb 1f       	adc	r27, r27
    b918:	66 1f       	adc	r22, r22
    b91a:	77 1f       	adc	r23, r23
    b91c:	88 1f       	adc	r24, r24
    b91e:	91 50       	subi	r25, 0x01	; 1
    b920:	50 40       	sbci	r21, 0x00	; 0
    b922:	a9 f7       	brne	.-22     	; 0xb90e <__mulsf3_pse+0x64>
    b924:	9e 3f       	cpi	r25, 0xFE	; 254
    b926:	51 05       	cpc	r21, r1
    b928:	70 f0       	brcs	.+28     	; 0xb946 <__mulsf3_pse+0x9c>
    b92a:	5c cf       	rjmp	.-328    	; 0xb7e4 <__fp_inf>
    b92c:	a6 cf       	rjmp	.-180    	; 0xb87a <__fp_szero>
    b92e:	5f 3f       	cpi	r21, 0xFF	; 255
    b930:	ec f3       	brlt	.-6      	; 0xb92c <__mulsf3_pse+0x82>
    b932:	98 3e       	cpi	r25, 0xE8	; 232
    b934:	dc f3       	brlt	.-10     	; 0xb92c <__mulsf3_pse+0x82>
    b936:	86 95       	lsr	r24
    b938:	77 95       	ror	r23
    b93a:	67 95       	ror	r22
    b93c:	b7 95       	ror	r27
    b93e:	f7 95       	ror	r31
    b940:	e7 95       	ror	r30
    b942:	9f 5f       	subi	r25, 0xFF	; 255
    b944:	c1 f7       	brne	.-16     	; 0xb936 <__mulsf3_pse+0x8c>
    b946:	fe 2b       	or	r31, r30
    b948:	88 0f       	add	r24, r24
    b94a:	91 1d       	adc	r25, r1
    b94c:	96 95       	lsr	r25
    b94e:	87 95       	ror	r24
    b950:	97 f9       	bld	r25, 7
    b952:	08 95       	ret

0000b954 <__mulsi3>:
    b954:	62 9f       	mul	r22, r18
    b956:	d0 01       	movw	r26, r0
    b958:	73 9f       	mul	r23, r19
    b95a:	f0 01       	movw	r30, r0
    b95c:	82 9f       	mul	r24, r18
    b95e:	e0 0d       	add	r30, r0
    b960:	f1 1d       	adc	r31, r1
    b962:	64 9f       	mul	r22, r20
    b964:	e0 0d       	add	r30, r0
    b966:	f1 1d       	adc	r31, r1
    b968:	92 9f       	mul	r25, r18
    b96a:	f0 0d       	add	r31, r0
    b96c:	83 9f       	mul	r24, r19
    b96e:	f0 0d       	add	r31, r0
    b970:	74 9f       	mul	r23, r20
    b972:	f0 0d       	add	r31, r0
    b974:	65 9f       	mul	r22, r21
    b976:	f0 0d       	add	r31, r0
    b978:	99 27       	eor	r25, r25
    b97a:	72 9f       	mul	r23, r18
    b97c:	b0 0d       	add	r27, r0
    b97e:	e1 1d       	adc	r30, r1
    b980:	f9 1f       	adc	r31, r25
    b982:	63 9f       	mul	r22, r19
    b984:	b0 0d       	add	r27, r0
    b986:	e1 1d       	adc	r30, r1
    b988:	f9 1f       	adc	r31, r25
    b98a:	bd 01       	movw	r22, r26
    b98c:	cf 01       	movw	r24, r30
    b98e:	11 24       	eor	r1, r1
    b990:	08 95       	ret

0000b992 <__udivmodhi4>:
    b992:	aa 1b       	sub	r26, r26
    b994:	bb 1b       	sub	r27, r27
    b996:	51 e1       	ldi	r21, 0x11	; 17
    b998:	07 c0       	rjmp	.+14     	; 0xb9a8 <__udivmodhi4_ep>

0000b99a <__udivmodhi4_loop>:
    b99a:	aa 1f       	adc	r26, r26
    b99c:	bb 1f       	adc	r27, r27
    b99e:	a6 17       	cp	r26, r22
    b9a0:	b7 07       	cpc	r27, r23
    b9a2:	10 f0       	brcs	.+4      	; 0xb9a8 <__udivmodhi4_ep>
    b9a4:	a6 1b       	sub	r26, r22
    b9a6:	b7 0b       	sbc	r27, r23

0000b9a8 <__udivmodhi4_ep>:
    b9a8:	88 1f       	adc	r24, r24
    b9aa:	99 1f       	adc	r25, r25
    b9ac:	5a 95       	dec	r21
    b9ae:	a9 f7       	brne	.-22     	; 0xb99a <__udivmodhi4_loop>
    b9b0:	80 95       	com	r24
    b9b2:	90 95       	com	r25
    b9b4:	bc 01       	movw	r22, r24
    b9b6:	cd 01       	movw	r24, r26
    b9b8:	08 95       	ret

0000b9ba <__divmodhi4>:
    b9ba:	97 fb       	bst	r25, 7
    b9bc:	09 2e       	mov	r0, r25
    b9be:	07 26       	eor	r0, r23
    b9c0:	0a d0       	rcall	.+20     	; 0xb9d6 <__divmodhi4_neg1>
    b9c2:	77 fd       	sbrc	r23, 7
    b9c4:	04 d0       	rcall	.+8      	; 0xb9ce <__divmodhi4_neg2>
    b9c6:	e5 df       	rcall	.-54     	; 0xb992 <__udivmodhi4>
    b9c8:	06 d0       	rcall	.+12     	; 0xb9d6 <__divmodhi4_neg1>
    b9ca:	00 20       	and	r0, r0
    b9cc:	1a f4       	brpl	.+6      	; 0xb9d4 <__divmodhi4_exit>

0000b9ce <__divmodhi4_neg2>:
    b9ce:	70 95       	com	r23
    b9d0:	61 95       	neg	r22
    b9d2:	7f 4f       	sbci	r23, 0xFF	; 255

0000b9d4 <__divmodhi4_exit>:
    b9d4:	08 95       	ret

0000b9d6 <__divmodhi4_neg1>:
    b9d6:	f6 f7       	brtc	.-4      	; 0xb9d4 <__divmodhi4_exit>
    b9d8:	90 95       	com	r25
    b9da:	81 95       	neg	r24
    b9dc:	9f 4f       	sbci	r25, 0xFF	; 255
    b9de:	08 95       	ret

0000b9e0 <__udivmodsi4>:
    b9e0:	a1 e2       	ldi	r26, 0x21	; 33
    b9e2:	1a 2e       	mov	r1, r26
    b9e4:	aa 1b       	sub	r26, r26
    b9e6:	bb 1b       	sub	r27, r27
    b9e8:	fd 01       	movw	r30, r26
    b9ea:	0d c0       	rjmp	.+26     	; 0xba06 <__udivmodsi4_ep>

0000b9ec <__udivmodsi4_loop>:
    b9ec:	aa 1f       	adc	r26, r26
    b9ee:	bb 1f       	adc	r27, r27
    b9f0:	ee 1f       	adc	r30, r30
    b9f2:	ff 1f       	adc	r31, r31
    b9f4:	a2 17       	cp	r26, r18
    b9f6:	b3 07       	cpc	r27, r19
    b9f8:	e4 07       	cpc	r30, r20
    b9fa:	f5 07       	cpc	r31, r21
    b9fc:	20 f0       	brcs	.+8      	; 0xba06 <__udivmodsi4_ep>
    b9fe:	a2 1b       	sub	r26, r18
    ba00:	b3 0b       	sbc	r27, r19
    ba02:	e4 0b       	sbc	r30, r20
    ba04:	f5 0b       	sbc	r31, r21

0000ba06 <__udivmodsi4_ep>:
    ba06:	66 1f       	adc	r22, r22
    ba08:	77 1f       	adc	r23, r23
    ba0a:	88 1f       	adc	r24, r24
    ba0c:	99 1f       	adc	r25, r25
    ba0e:	1a 94       	dec	r1
    ba10:	69 f7       	brne	.-38     	; 0xb9ec <__udivmodsi4_loop>
    ba12:	60 95       	com	r22
    ba14:	70 95       	com	r23
    ba16:	80 95       	com	r24
    ba18:	90 95       	com	r25
    ba1a:	9b 01       	movw	r18, r22
    ba1c:	ac 01       	movw	r20, r24
    ba1e:	bd 01       	movw	r22, r26
    ba20:	cf 01       	movw	r24, r30
    ba22:	08 95       	ret

0000ba24 <__divmodsi4>:
    ba24:	97 fb       	bst	r25, 7
    ba26:	09 2e       	mov	r0, r25
    ba28:	05 26       	eor	r0, r21
    ba2a:	0e d0       	rcall	.+28     	; 0xba48 <__divmodsi4_neg1>
    ba2c:	57 fd       	sbrc	r21, 7
    ba2e:	04 d0       	rcall	.+8      	; 0xba38 <__divmodsi4_neg2>
    ba30:	d7 df       	rcall	.-82     	; 0xb9e0 <__udivmodsi4>
    ba32:	0a d0       	rcall	.+20     	; 0xba48 <__divmodsi4_neg1>
    ba34:	00 1c       	adc	r0, r0
    ba36:	38 f4       	brcc	.+14     	; 0xba46 <__divmodsi4_exit>

0000ba38 <__divmodsi4_neg2>:
    ba38:	50 95       	com	r21
    ba3a:	40 95       	com	r20
    ba3c:	30 95       	com	r19
    ba3e:	21 95       	neg	r18
    ba40:	3f 4f       	sbci	r19, 0xFF	; 255
    ba42:	4f 4f       	sbci	r20, 0xFF	; 255
    ba44:	5f 4f       	sbci	r21, 0xFF	; 255

0000ba46 <__divmodsi4_exit>:
    ba46:	08 95       	ret

0000ba48 <__divmodsi4_neg1>:
    ba48:	f6 f7       	brtc	.-4      	; 0xba46 <__divmodsi4_exit>
    ba4a:	90 95       	com	r25
    ba4c:	80 95       	com	r24
    ba4e:	70 95       	com	r23
    ba50:	61 95       	neg	r22
    ba52:	7f 4f       	sbci	r23, 0xFF	; 255
    ba54:	8f 4f       	sbci	r24, 0xFF	; 255
    ba56:	9f 4f       	sbci	r25, 0xFF	; 255
    ba58:	08 95       	ret

0000ba5a <__prologue_saves__>:
    ba5a:	2f 92       	push	r2
    ba5c:	3f 92       	push	r3
    ba5e:	4f 92       	push	r4
    ba60:	5f 92       	push	r5
    ba62:	6f 92       	push	r6
    ba64:	7f 92       	push	r7
    ba66:	8f 92       	push	r8
    ba68:	9f 92       	push	r9
    ba6a:	af 92       	push	r10
    ba6c:	bf 92       	push	r11
    ba6e:	cf 92       	push	r12
    ba70:	df 92       	push	r13
    ba72:	ef 92       	push	r14
    ba74:	ff 92       	push	r15
    ba76:	0f 93       	push	r16
    ba78:	1f 93       	push	r17
    ba7a:	cf 93       	push	r28
    ba7c:	df 93       	push	r29
    ba7e:	cd b7       	in	r28, 0x3d	; 61
    ba80:	de b7       	in	r29, 0x3e	; 62
    ba82:	ca 1b       	sub	r28, r26
    ba84:	db 0b       	sbc	r29, r27
    ba86:	cd bf       	out	0x3d, r28	; 61
    ba88:	de bf       	out	0x3e, r29	; 62
    ba8a:	19 94       	eijmp

0000ba8c <__epilogue_restores__>:
    ba8c:	2a 88       	ldd	r2, Y+18	; 0x12
    ba8e:	39 88       	ldd	r3, Y+17	; 0x11
    ba90:	48 88       	ldd	r4, Y+16	; 0x10
    ba92:	5f 84       	ldd	r5, Y+15	; 0x0f
    ba94:	6e 84       	ldd	r6, Y+14	; 0x0e
    ba96:	7d 84       	ldd	r7, Y+13	; 0x0d
    ba98:	8c 84       	ldd	r8, Y+12	; 0x0c
    ba9a:	9b 84       	ldd	r9, Y+11	; 0x0b
    ba9c:	aa 84       	ldd	r10, Y+10	; 0x0a
    ba9e:	b9 84       	ldd	r11, Y+9	; 0x09
    baa0:	c8 84       	ldd	r12, Y+8	; 0x08
    baa2:	df 80       	ldd	r13, Y+7	; 0x07
    baa4:	ee 80       	ldd	r14, Y+6	; 0x06
    baa6:	fd 80       	ldd	r15, Y+5	; 0x05
    baa8:	0c 81       	ldd	r16, Y+4	; 0x04
    baaa:	1b 81       	ldd	r17, Y+3	; 0x03
    baac:	aa 81       	ldd	r26, Y+2	; 0x02
    baae:	b9 81       	ldd	r27, Y+1	; 0x01
    bab0:	ce 0f       	add	r28, r30
    bab2:	d1 1d       	adc	r29, r1
    bab4:	cd bf       	out	0x3d, r28	; 61
    bab6:	de bf       	out	0x3e, r29	; 62
    bab8:	ed 01       	movw	r28, r26
    baba:	08 95       	ret

0000babc <strcpy_P>:
    babc:	fb 01       	movw	r30, r22
    babe:	dc 01       	movw	r26, r24
    bac0:	05 90       	lpm	r0, Z+
    bac2:	0d 92       	st	X+, r0
    bac4:	00 20       	and	r0, r0
    bac6:	e1 f7       	brne	.-8      	; 0xbac0 <strcpy_P+0x4>
    bac8:	08 95       	ret

0000baca <memmove>:
    baca:	68 17       	cp	r22, r24
    bacc:	79 07       	cpc	r23, r25
    bace:	68 f4       	brcc	.+26     	; 0xbaea <memmove+0x20>
    bad0:	fb 01       	movw	r30, r22
    bad2:	dc 01       	movw	r26, r24
    bad4:	e4 0f       	add	r30, r20
    bad6:	f5 1f       	adc	r31, r21
    bad8:	a4 0f       	add	r26, r20
    bada:	b5 1f       	adc	r27, r21
    badc:	02 c0       	rjmp	.+4      	; 0xbae2 <memmove+0x18>
    bade:	02 90       	ld	r0, -Z
    bae0:	0e 92       	st	-X, r0
    bae2:	41 50       	subi	r20, 0x01	; 1
    bae4:	50 40       	sbci	r21, 0x00	; 0
    bae6:	d8 f7       	brcc	.-10     	; 0xbade <memmove+0x14>
    bae8:	08 95       	ret
    baea:	0c 94 f8 5f 	jmp	0xbff0	; 0xbff0 <memcpy>

0000baee <strcat>:
    baee:	fb 01       	movw	r30, r22
    baf0:	dc 01       	movw	r26, r24
    baf2:	0d 90       	ld	r0, X+
    baf4:	00 20       	and	r0, r0
    baf6:	e9 f7       	brne	.-6      	; 0xbaf2 <strcat+0x4>
    baf8:	11 97       	sbiw	r26, 0x01	; 1
    bafa:	01 90       	ld	r0, Z+
    bafc:	0d 92       	st	X+, r0
    bafe:	00 20       	and	r0, r0
    bb00:	e1 f7       	brne	.-8      	; 0xbafa <strcat+0xc>
    bb02:	08 95       	ret

0000bb04 <strncmp>:
    bb04:	fb 01       	movw	r30, r22
    bb06:	dc 01       	movw	r26, r24
    bb08:	41 50       	subi	r20, 0x01	; 1
    bb0a:	50 40       	sbci	r21, 0x00	; 0
    bb0c:	30 f0       	brcs	.+12     	; 0xbb1a <strncmp+0x16>
    bb0e:	8d 91       	ld	r24, X+
    bb10:	01 90       	ld	r0, Z+
    bb12:	80 19       	sub	r24, r0
    bb14:	19 f4       	brne	.+6      	; 0xbb1c <strncmp+0x18>
    bb16:	00 20       	and	r0, r0
    bb18:	b9 f7       	brne	.-18     	; 0xbb08 <strncmp+0x4>
    bb1a:	88 1b       	sub	r24, r24
    bb1c:	99 0b       	sbc	r25, r25
    bb1e:	08 95       	ret

0000bb20 <itoa>:
    bb20:	fb 01       	movw	r30, r22
    bb22:	9f 01       	movw	r18, r30
    bb24:	e8 94       	clt
    bb26:	42 30       	cpi	r20, 0x02	; 2
    bb28:	c4 f0       	brlt	.+48     	; 0xbb5a <itoa+0x3a>
    bb2a:	45 32       	cpi	r20, 0x25	; 37
    bb2c:	b4 f4       	brge	.+44     	; 0xbb5a <itoa+0x3a>
    bb2e:	4a 30       	cpi	r20, 0x0A	; 10
    bb30:	29 f4       	brne	.+10     	; 0xbb3c <itoa+0x1c>
    bb32:	97 fb       	bst	r25, 7
    bb34:	1e f4       	brtc	.+6      	; 0xbb3c <itoa+0x1c>
    bb36:	90 95       	com	r25
    bb38:	81 95       	neg	r24
    bb3a:	9f 4f       	sbci	r25, 0xFF	; 255
    bb3c:	64 2f       	mov	r22, r20
    bb3e:	77 27       	eor	r23, r23
    bb40:	0e 94 c9 5c 	call	0xb992	; 0xb992 <__udivmodhi4>
    bb44:	80 5d       	subi	r24, 0xD0	; 208
    bb46:	8a 33       	cpi	r24, 0x3A	; 58
    bb48:	0c f0       	brlt	.+2      	; 0xbb4c <itoa+0x2c>
    bb4a:	89 5d       	subi	r24, 0xD9	; 217
    bb4c:	81 93       	st	Z+, r24
    bb4e:	cb 01       	movw	r24, r22
    bb50:	00 97       	sbiw	r24, 0x00	; 0
    bb52:	a1 f7       	brne	.-24     	; 0xbb3c <itoa+0x1c>
    bb54:	16 f4       	brtc	.+4      	; 0xbb5a <itoa+0x3a>
    bb56:	5d e2       	ldi	r21, 0x2D	; 45
    bb58:	51 93       	st	Z+, r21
    bb5a:	10 82       	st	Z, r1
    bb5c:	c9 01       	movw	r24, r18
    bb5e:	0c 94 0c 60 	jmp	0xc018	; 0xc018 <strrev>

0000bb62 <printf>:
    bb62:	cf 93       	push	r28
    bb64:	df 93       	push	r29
    bb66:	cd b7       	in	r28, 0x3d	; 61
    bb68:	de b7       	in	r29, 0x3e	; 62
    bb6a:	fe 01       	movw	r30, r28
    bb6c:	36 96       	adiw	r30, 0x06	; 6
    bb6e:	61 91       	ld	r22, Z+
    bb70:	71 91       	ld	r23, Z+
    bb72:	80 91 e0 50 	lds	r24, 0x50E0
    bb76:	90 91 e1 50 	lds	r25, 0x50E1
    bb7a:	af 01       	movw	r20, r30
    bb7c:	0e 94 ec 5d 	call	0xbbd8	; 0xbbd8 <vfprintf>
    bb80:	df 91       	pop	r29
    bb82:	cf 91       	pop	r28
    bb84:	08 95       	ret

0000bb86 <sprintf>:
    bb86:	0f 93       	push	r16
    bb88:	1f 93       	push	r17
    bb8a:	cf 93       	push	r28
    bb8c:	df 93       	push	r29
    bb8e:	cd b7       	in	r28, 0x3d	; 61
    bb90:	de b7       	in	r29, 0x3e	; 62
    bb92:	2e 97       	sbiw	r28, 0x0e	; 14
    bb94:	cd bf       	out	0x3d, r28	; 61
    bb96:	de bf       	out	0x3e, r29	; 62
    bb98:	0e 89       	ldd	r16, Y+22	; 0x16
    bb9a:	1f 89       	ldd	r17, Y+23	; 0x17
    bb9c:	86 e0       	ldi	r24, 0x06	; 6
    bb9e:	8c 83       	std	Y+4, r24	; 0x04
    bba0:	09 83       	std	Y+1, r16	; 0x01
    bba2:	1a 83       	std	Y+2, r17	; 0x02
    bba4:	8f ef       	ldi	r24, 0xFF	; 255
    bba6:	9f e7       	ldi	r25, 0x7F	; 127
    bba8:	8d 83       	std	Y+5, r24	; 0x05
    bbaa:	9e 83       	std	Y+6, r25	; 0x06
    bbac:	ae 01       	movw	r20, r28
    bbae:	46 5e       	subi	r20, 0xE6	; 230
    bbb0:	5f 4f       	sbci	r21, 0xFF	; 255
    bbb2:	ce 01       	movw	r24, r28
    bbb4:	01 96       	adiw	r24, 0x01	; 1
    bbb6:	68 8d       	ldd	r22, Y+24	; 0x18
    bbb8:	79 8d       	ldd	r23, Y+25	; 0x19
    bbba:	0e 94 ec 5d 	call	0xbbd8	; 0xbbd8 <vfprintf>
    bbbe:	ef 81       	ldd	r30, Y+7	; 0x07
    bbc0:	f8 85       	ldd	r31, Y+8	; 0x08
    bbc2:	e0 0f       	add	r30, r16
    bbc4:	f1 1f       	adc	r31, r17
    bbc6:	10 82       	st	Z, r1
    bbc8:	2e 96       	adiw	r28, 0x0e	; 14
    bbca:	cd bf       	out	0x3d, r28	; 61
    bbcc:	de bf       	out	0x3e, r29	; 62
    bbce:	df 91       	pop	r29
    bbd0:	cf 91       	pop	r28
    bbd2:	1f 91       	pop	r17
    bbd4:	0f 91       	pop	r16
    bbd6:	08 95       	ret

0000bbd8 <vfprintf>:
    bbd8:	2f 92       	push	r2
    bbda:	3f 92       	push	r3
    bbdc:	4f 92       	push	r4
    bbde:	5f 92       	push	r5
    bbe0:	6f 92       	push	r6
    bbe2:	7f 92       	push	r7
    bbe4:	8f 92       	push	r8
    bbe6:	9f 92       	push	r9
    bbe8:	af 92       	push	r10
    bbea:	bf 92       	push	r11
    bbec:	cf 92       	push	r12
    bbee:	df 92       	push	r13
    bbf0:	ef 92       	push	r14
    bbf2:	ff 92       	push	r15
    bbf4:	0f 93       	push	r16
    bbf6:	1f 93       	push	r17
    bbf8:	cf 93       	push	r28
    bbfa:	df 93       	push	r29
    bbfc:	cd b7       	in	r28, 0x3d	; 61
    bbfe:	de b7       	in	r29, 0x3e	; 62
    bc00:	2d 97       	sbiw	r28, 0x0d	; 13
    bc02:	cd bf       	out	0x3d, r28	; 61
    bc04:	de bf       	out	0x3e, r29	; 62
    bc06:	3c 01       	movw	r6, r24
    bc08:	6c 87       	std	Y+12, r22	; 0x0c
    bc0a:	7d 87       	std	Y+13, r23	; 0x0d
    bc0c:	5a 01       	movw	r10, r20
    bc0e:	fc 01       	movw	r30, r24
    bc10:	16 82       	std	Z+6, r1	; 0x06
    bc12:	17 82       	std	Z+7, r1	; 0x07
    bc14:	83 81       	ldd	r24, Z+3	; 0x03
    bc16:	81 ff       	sbrs	r24, 1
    bc18:	c8 c1       	rjmp	.+912    	; 0xbfaa <vfprintf+0x3d2>
    bc1a:	2e 01       	movw	r4, r28
    bc1c:	08 94       	sec
    bc1e:	41 1c       	adc	r4, r1
    bc20:	51 1c       	adc	r5, r1
    bc22:	f3 01       	movw	r30, r6
    bc24:	93 81       	ldd	r25, Z+3	; 0x03
    bc26:	ec 85       	ldd	r30, Y+12	; 0x0c
    bc28:	fd 85       	ldd	r31, Y+13	; 0x0d
    bc2a:	93 fd       	sbrc	r25, 3
    bc2c:	85 91       	lpm	r24, Z+
    bc2e:	93 ff       	sbrs	r25, 3
    bc30:	81 91       	ld	r24, Z+
    bc32:	ec 87       	std	Y+12, r30	; 0x0c
    bc34:	fd 87       	std	Y+13, r31	; 0x0d
    bc36:	88 23       	and	r24, r24
    bc38:	09 f4       	brne	.+2      	; 0xbc3c <vfprintf+0x64>
    bc3a:	b3 c1       	rjmp	.+870    	; 0xbfa2 <vfprintf+0x3ca>
    bc3c:	85 32       	cpi	r24, 0x25	; 37
    bc3e:	41 f4       	brne	.+16     	; 0xbc50 <vfprintf+0x78>
    bc40:	93 fd       	sbrc	r25, 3
    bc42:	85 91       	lpm	r24, Z+
    bc44:	93 ff       	sbrs	r25, 3
    bc46:	81 91       	ld	r24, Z+
    bc48:	ec 87       	std	Y+12, r30	; 0x0c
    bc4a:	fd 87       	std	Y+13, r31	; 0x0d
    bc4c:	85 32       	cpi	r24, 0x25	; 37
    bc4e:	29 f4       	brne	.+10     	; 0xbc5a <vfprintf+0x82>
    bc50:	90 e0       	ldi	r25, 0x00	; 0
    bc52:	b3 01       	movw	r22, r6
    bc54:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bc58:	e4 cf       	rjmp	.-56     	; 0xbc22 <vfprintf+0x4a>
    bc5a:	ff 24       	eor	r15, r15
    bc5c:	ee 24       	eor	r14, r14
    bc5e:	10 e0       	ldi	r17, 0x00	; 0
    bc60:	10 32       	cpi	r17, 0x20	; 32
    bc62:	b0 f4       	brcc	.+44     	; 0xbc90 <vfprintf+0xb8>
    bc64:	8b 32       	cpi	r24, 0x2B	; 43
    bc66:	69 f0       	breq	.+26     	; 0xbc82 <vfprintf+0xaa>
    bc68:	8c 32       	cpi	r24, 0x2C	; 44
    bc6a:	28 f4       	brcc	.+10     	; 0xbc76 <vfprintf+0x9e>
    bc6c:	80 32       	cpi	r24, 0x20	; 32
    bc6e:	51 f0       	breq	.+20     	; 0xbc84 <vfprintf+0xac>
    bc70:	83 32       	cpi	r24, 0x23	; 35
    bc72:	71 f4       	brne	.+28     	; 0xbc90 <vfprintf+0xb8>
    bc74:	0b c0       	rjmp	.+22     	; 0xbc8c <vfprintf+0xb4>
    bc76:	8d 32       	cpi	r24, 0x2D	; 45
    bc78:	39 f0       	breq	.+14     	; 0xbc88 <vfprintf+0xb0>
    bc7a:	80 33       	cpi	r24, 0x30	; 48
    bc7c:	49 f4       	brne	.+18     	; 0xbc90 <vfprintf+0xb8>
    bc7e:	11 60       	ori	r17, 0x01	; 1
    bc80:	2c c0       	rjmp	.+88     	; 0xbcda <vfprintf+0x102>
    bc82:	12 60       	ori	r17, 0x02	; 2
    bc84:	14 60       	ori	r17, 0x04	; 4
    bc86:	29 c0       	rjmp	.+82     	; 0xbcda <vfprintf+0x102>
    bc88:	18 60       	ori	r17, 0x08	; 8
    bc8a:	27 c0       	rjmp	.+78     	; 0xbcda <vfprintf+0x102>
    bc8c:	10 61       	ori	r17, 0x10	; 16
    bc8e:	25 c0       	rjmp	.+74     	; 0xbcda <vfprintf+0x102>
    bc90:	17 fd       	sbrc	r17, 7
    bc92:	2e c0       	rjmp	.+92     	; 0xbcf0 <vfprintf+0x118>
    bc94:	28 2f       	mov	r18, r24
    bc96:	20 53       	subi	r18, 0x30	; 48
    bc98:	2a 30       	cpi	r18, 0x0A	; 10
    bc9a:	98 f4       	brcc	.+38     	; 0xbcc2 <vfprintf+0xea>
    bc9c:	16 ff       	sbrs	r17, 6
    bc9e:	08 c0       	rjmp	.+16     	; 0xbcb0 <vfprintf+0xd8>
    bca0:	8f 2d       	mov	r24, r15
    bca2:	88 0f       	add	r24, r24
    bca4:	f8 2e       	mov	r15, r24
    bca6:	ff 0c       	add	r15, r15
    bca8:	ff 0c       	add	r15, r15
    bcaa:	f8 0e       	add	r15, r24
    bcac:	f2 0e       	add	r15, r18
    bcae:	15 c0       	rjmp	.+42     	; 0xbcda <vfprintf+0x102>
    bcb0:	8e 2d       	mov	r24, r14
    bcb2:	88 0f       	add	r24, r24
    bcb4:	e8 2e       	mov	r14, r24
    bcb6:	ee 0c       	add	r14, r14
    bcb8:	ee 0c       	add	r14, r14
    bcba:	e8 0e       	add	r14, r24
    bcbc:	e2 0e       	add	r14, r18
    bcbe:	10 62       	ori	r17, 0x20	; 32
    bcc0:	0c c0       	rjmp	.+24     	; 0xbcda <vfprintf+0x102>
    bcc2:	8e 32       	cpi	r24, 0x2E	; 46
    bcc4:	21 f4       	brne	.+8      	; 0xbcce <vfprintf+0xf6>
    bcc6:	16 fd       	sbrc	r17, 6
    bcc8:	6c c1       	rjmp	.+728    	; 0xbfa2 <vfprintf+0x3ca>
    bcca:	10 64       	ori	r17, 0x40	; 64
    bccc:	06 c0       	rjmp	.+12     	; 0xbcda <vfprintf+0x102>
    bcce:	8c 36       	cpi	r24, 0x6C	; 108
    bcd0:	11 f4       	brne	.+4      	; 0xbcd6 <vfprintf+0xfe>
    bcd2:	10 68       	ori	r17, 0x80	; 128
    bcd4:	02 c0       	rjmp	.+4      	; 0xbcda <vfprintf+0x102>
    bcd6:	88 36       	cpi	r24, 0x68	; 104
    bcd8:	59 f4       	brne	.+22     	; 0xbcf0 <vfprintf+0x118>
    bcda:	ec 85       	ldd	r30, Y+12	; 0x0c
    bcdc:	fd 85       	ldd	r31, Y+13	; 0x0d
    bcde:	93 fd       	sbrc	r25, 3
    bce0:	85 91       	lpm	r24, Z+
    bce2:	93 ff       	sbrs	r25, 3
    bce4:	81 91       	ld	r24, Z+
    bce6:	ec 87       	std	Y+12, r30	; 0x0c
    bce8:	fd 87       	std	Y+13, r31	; 0x0d
    bcea:	88 23       	and	r24, r24
    bcec:	09 f0       	breq	.+2      	; 0xbcf0 <vfprintf+0x118>
    bcee:	b8 cf       	rjmp	.-144    	; 0xbc60 <vfprintf+0x88>
    bcf0:	98 2f       	mov	r25, r24
    bcf2:	95 54       	subi	r25, 0x45	; 69
    bcf4:	93 30       	cpi	r25, 0x03	; 3
    bcf6:	18 f0       	brcs	.+6      	; 0xbcfe <vfprintf+0x126>
    bcf8:	90 52       	subi	r25, 0x20	; 32
    bcfa:	93 30       	cpi	r25, 0x03	; 3
    bcfc:	38 f4       	brcc	.+14     	; 0xbd0c <vfprintf+0x134>
    bcfe:	24 e0       	ldi	r18, 0x04	; 4
    bd00:	30 e0       	ldi	r19, 0x00	; 0
    bd02:	a2 0e       	add	r10, r18
    bd04:	b3 1e       	adc	r11, r19
    bd06:	3f e3       	ldi	r19, 0x3F	; 63
    bd08:	39 83       	std	Y+1, r19	; 0x01
    bd0a:	0f c0       	rjmp	.+30     	; 0xbd2a <vfprintf+0x152>
    bd0c:	83 36       	cpi	r24, 0x63	; 99
    bd0e:	31 f0       	breq	.+12     	; 0xbd1c <vfprintf+0x144>
    bd10:	83 37       	cpi	r24, 0x73	; 115
    bd12:	81 f0       	breq	.+32     	; 0xbd34 <vfprintf+0x15c>
    bd14:	83 35       	cpi	r24, 0x53	; 83
    bd16:	09 f0       	breq	.+2      	; 0xbd1a <vfprintf+0x142>
    bd18:	5a c0       	rjmp	.+180    	; 0xbdce <vfprintf+0x1f6>
    bd1a:	22 c0       	rjmp	.+68     	; 0xbd60 <vfprintf+0x188>
    bd1c:	f5 01       	movw	r30, r10
    bd1e:	80 81       	ld	r24, Z
    bd20:	89 83       	std	Y+1, r24	; 0x01
    bd22:	22 e0       	ldi	r18, 0x02	; 2
    bd24:	30 e0       	ldi	r19, 0x00	; 0
    bd26:	a2 0e       	add	r10, r18
    bd28:	b3 1e       	adc	r11, r19
    bd2a:	21 e0       	ldi	r18, 0x01	; 1
    bd2c:	c2 2e       	mov	r12, r18
    bd2e:	d1 2c       	mov	r13, r1
    bd30:	42 01       	movw	r8, r4
    bd32:	14 c0       	rjmp	.+40     	; 0xbd5c <vfprintf+0x184>
    bd34:	92 e0       	ldi	r25, 0x02	; 2
    bd36:	29 2e       	mov	r2, r25
    bd38:	31 2c       	mov	r3, r1
    bd3a:	2a 0c       	add	r2, r10
    bd3c:	3b 1c       	adc	r3, r11
    bd3e:	f5 01       	movw	r30, r10
    bd40:	80 80       	ld	r8, Z
    bd42:	91 80       	ldd	r9, Z+1	; 0x01
    bd44:	16 ff       	sbrs	r17, 6
    bd46:	03 c0       	rjmp	.+6      	; 0xbd4e <vfprintf+0x176>
    bd48:	6f 2d       	mov	r22, r15
    bd4a:	70 e0       	ldi	r23, 0x00	; 0
    bd4c:	02 c0       	rjmp	.+4      	; 0xbd52 <vfprintf+0x17a>
    bd4e:	6f ef       	ldi	r22, 0xFF	; 255
    bd50:	7f ef       	ldi	r23, 0xFF	; 255
    bd52:	c4 01       	movw	r24, r8
    bd54:	0e 94 01 60 	call	0xc002	; 0xc002 <strnlen>
    bd58:	6c 01       	movw	r12, r24
    bd5a:	51 01       	movw	r10, r2
    bd5c:	1f 77       	andi	r17, 0x7F	; 127
    bd5e:	15 c0       	rjmp	.+42     	; 0xbd8a <vfprintf+0x1b2>
    bd60:	82 e0       	ldi	r24, 0x02	; 2
    bd62:	28 2e       	mov	r2, r24
    bd64:	31 2c       	mov	r3, r1
    bd66:	2a 0c       	add	r2, r10
    bd68:	3b 1c       	adc	r3, r11
    bd6a:	f5 01       	movw	r30, r10
    bd6c:	80 80       	ld	r8, Z
    bd6e:	91 80       	ldd	r9, Z+1	; 0x01
    bd70:	16 ff       	sbrs	r17, 6
    bd72:	03 c0       	rjmp	.+6      	; 0xbd7a <vfprintf+0x1a2>
    bd74:	6f 2d       	mov	r22, r15
    bd76:	70 e0       	ldi	r23, 0x00	; 0
    bd78:	02 c0       	rjmp	.+4      	; 0xbd7e <vfprintf+0x1a6>
    bd7a:	6f ef       	ldi	r22, 0xFF	; 255
    bd7c:	7f ef       	ldi	r23, 0xFF	; 255
    bd7e:	c4 01       	movw	r24, r8
    bd80:	0e 94 ed 5f 	call	0xbfda	; 0xbfda <strnlen_P>
    bd84:	6c 01       	movw	r12, r24
    bd86:	10 68       	ori	r17, 0x80	; 128
    bd88:	51 01       	movw	r10, r2
    bd8a:	13 fd       	sbrc	r17, 3
    bd8c:	1c c0       	rjmp	.+56     	; 0xbdc6 <vfprintf+0x1ee>
    bd8e:	06 c0       	rjmp	.+12     	; 0xbd9c <vfprintf+0x1c4>
    bd90:	80 e2       	ldi	r24, 0x20	; 32
    bd92:	90 e0       	ldi	r25, 0x00	; 0
    bd94:	b3 01       	movw	r22, r6
    bd96:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bd9a:	ea 94       	dec	r14
    bd9c:	8e 2d       	mov	r24, r14
    bd9e:	90 e0       	ldi	r25, 0x00	; 0
    bda0:	c8 16       	cp	r12, r24
    bda2:	d9 06       	cpc	r13, r25
    bda4:	a8 f3       	brcs	.-22     	; 0xbd90 <vfprintf+0x1b8>
    bda6:	0f c0       	rjmp	.+30     	; 0xbdc6 <vfprintf+0x1ee>
    bda8:	f4 01       	movw	r30, r8
    bdaa:	17 fd       	sbrc	r17, 7
    bdac:	85 91       	lpm	r24, Z+
    bdae:	17 ff       	sbrs	r17, 7
    bdb0:	81 91       	ld	r24, Z+
    bdb2:	4f 01       	movw	r8, r30
    bdb4:	90 e0       	ldi	r25, 0x00	; 0
    bdb6:	b3 01       	movw	r22, r6
    bdb8:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bdbc:	e1 10       	cpse	r14, r1
    bdbe:	ea 94       	dec	r14
    bdc0:	08 94       	sec
    bdc2:	c1 08       	sbc	r12, r1
    bdc4:	d1 08       	sbc	r13, r1
    bdc6:	c1 14       	cp	r12, r1
    bdc8:	d1 04       	cpc	r13, r1
    bdca:	71 f7       	brne	.-36     	; 0xbda8 <vfprintf+0x1d0>
    bdcc:	e7 c0       	rjmp	.+462    	; 0xbf9c <vfprintf+0x3c4>
    bdce:	84 36       	cpi	r24, 0x64	; 100
    bdd0:	11 f0       	breq	.+4      	; 0xbdd6 <vfprintf+0x1fe>
    bdd2:	89 36       	cpi	r24, 0x69	; 105
    bdd4:	51 f5       	brne	.+84     	; 0xbe2a <vfprintf+0x252>
    bdd6:	f5 01       	movw	r30, r10
    bdd8:	17 ff       	sbrs	r17, 7
    bdda:	07 c0       	rjmp	.+14     	; 0xbdea <vfprintf+0x212>
    bddc:	80 81       	ld	r24, Z
    bdde:	91 81       	ldd	r25, Z+1	; 0x01
    bde0:	a2 81       	ldd	r26, Z+2	; 0x02
    bde2:	b3 81       	ldd	r27, Z+3	; 0x03
    bde4:	24 e0       	ldi	r18, 0x04	; 4
    bde6:	30 e0       	ldi	r19, 0x00	; 0
    bde8:	08 c0       	rjmp	.+16     	; 0xbdfa <vfprintf+0x222>
    bdea:	80 81       	ld	r24, Z
    bdec:	91 81       	ldd	r25, Z+1	; 0x01
    bdee:	aa 27       	eor	r26, r26
    bdf0:	97 fd       	sbrc	r25, 7
    bdf2:	a0 95       	com	r26
    bdf4:	ba 2f       	mov	r27, r26
    bdf6:	22 e0       	ldi	r18, 0x02	; 2
    bdf8:	30 e0       	ldi	r19, 0x00	; 0
    bdfa:	a2 0e       	add	r10, r18
    bdfc:	b3 1e       	adc	r11, r19
    bdfe:	01 2f       	mov	r16, r17
    be00:	0f 76       	andi	r16, 0x6F	; 111
    be02:	b7 ff       	sbrs	r27, 7
    be04:	08 c0       	rjmp	.+16     	; 0xbe16 <vfprintf+0x23e>
    be06:	b0 95       	com	r27
    be08:	a0 95       	com	r26
    be0a:	90 95       	com	r25
    be0c:	81 95       	neg	r24
    be0e:	9f 4f       	sbci	r25, 0xFF	; 255
    be10:	af 4f       	sbci	r26, 0xFF	; 255
    be12:	bf 4f       	sbci	r27, 0xFF	; 255
    be14:	00 68       	ori	r16, 0x80	; 128
    be16:	bc 01       	movw	r22, r24
    be18:	cd 01       	movw	r24, r26
    be1a:	a2 01       	movw	r20, r4
    be1c:	2a e0       	ldi	r18, 0x0A	; 10
    be1e:	30 e0       	ldi	r19, 0x00	; 0
    be20:	0e 94 48 60 	call	0xc090	; 0xc090 <__ultoa_invert>
    be24:	d8 2e       	mov	r13, r24
    be26:	d4 18       	sub	r13, r4
    be28:	3f c0       	rjmp	.+126    	; 0xbea8 <vfprintf+0x2d0>
    be2a:	85 37       	cpi	r24, 0x75	; 117
    be2c:	21 f4       	brne	.+8      	; 0xbe36 <vfprintf+0x25e>
    be2e:	1f 7e       	andi	r17, 0xEF	; 239
    be30:	2a e0       	ldi	r18, 0x0A	; 10
    be32:	30 e0       	ldi	r19, 0x00	; 0
    be34:	20 c0       	rjmp	.+64     	; 0xbe76 <vfprintf+0x29e>
    be36:	19 7f       	andi	r17, 0xF9	; 249
    be38:	8f 36       	cpi	r24, 0x6F	; 111
    be3a:	a9 f0       	breq	.+42     	; 0xbe66 <vfprintf+0x28e>
    be3c:	80 37       	cpi	r24, 0x70	; 112
    be3e:	20 f4       	brcc	.+8      	; 0xbe48 <vfprintf+0x270>
    be40:	88 35       	cpi	r24, 0x58	; 88
    be42:	09 f0       	breq	.+2      	; 0xbe46 <vfprintf+0x26e>
    be44:	ae c0       	rjmp	.+348    	; 0xbfa2 <vfprintf+0x3ca>
    be46:	0b c0       	rjmp	.+22     	; 0xbe5e <vfprintf+0x286>
    be48:	80 37       	cpi	r24, 0x70	; 112
    be4a:	21 f0       	breq	.+8      	; 0xbe54 <vfprintf+0x27c>
    be4c:	88 37       	cpi	r24, 0x78	; 120
    be4e:	09 f0       	breq	.+2      	; 0xbe52 <vfprintf+0x27a>
    be50:	a8 c0       	rjmp	.+336    	; 0xbfa2 <vfprintf+0x3ca>
    be52:	01 c0       	rjmp	.+2      	; 0xbe56 <vfprintf+0x27e>
    be54:	10 61       	ori	r17, 0x10	; 16
    be56:	14 ff       	sbrs	r17, 4
    be58:	09 c0       	rjmp	.+18     	; 0xbe6c <vfprintf+0x294>
    be5a:	14 60       	ori	r17, 0x04	; 4
    be5c:	07 c0       	rjmp	.+14     	; 0xbe6c <vfprintf+0x294>
    be5e:	14 ff       	sbrs	r17, 4
    be60:	08 c0       	rjmp	.+16     	; 0xbe72 <vfprintf+0x29a>
    be62:	16 60       	ori	r17, 0x06	; 6
    be64:	06 c0       	rjmp	.+12     	; 0xbe72 <vfprintf+0x29a>
    be66:	28 e0       	ldi	r18, 0x08	; 8
    be68:	30 e0       	ldi	r19, 0x00	; 0
    be6a:	05 c0       	rjmp	.+10     	; 0xbe76 <vfprintf+0x29e>
    be6c:	20 e1       	ldi	r18, 0x10	; 16
    be6e:	30 e0       	ldi	r19, 0x00	; 0
    be70:	02 c0       	rjmp	.+4      	; 0xbe76 <vfprintf+0x29e>
    be72:	20 e1       	ldi	r18, 0x10	; 16
    be74:	32 e0       	ldi	r19, 0x02	; 2
    be76:	f5 01       	movw	r30, r10
    be78:	17 ff       	sbrs	r17, 7
    be7a:	07 c0       	rjmp	.+14     	; 0xbe8a <vfprintf+0x2b2>
    be7c:	60 81       	ld	r22, Z
    be7e:	71 81       	ldd	r23, Z+1	; 0x01
    be80:	82 81       	ldd	r24, Z+2	; 0x02
    be82:	93 81       	ldd	r25, Z+3	; 0x03
    be84:	44 e0       	ldi	r20, 0x04	; 4
    be86:	50 e0       	ldi	r21, 0x00	; 0
    be88:	06 c0       	rjmp	.+12     	; 0xbe96 <vfprintf+0x2be>
    be8a:	60 81       	ld	r22, Z
    be8c:	71 81       	ldd	r23, Z+1	; 0x01
    be8e:	80 e0       	ldi	r24, 0x00	; 0
    be90:	90 e0       	ldi	r25, 0x00	; 0
    be92:	42 e0       	ldi	r20, 0x02	; 2
    be94:	50 e0       	ldi	r21, 0x00	; 0
    be96:	a4 0e       	add	r10, r20
    be98:	b5 1e       	adc	r11, r21
    be9a:	a2 01       	movw	r20, r4
    be9c:	0e 94 48 60 	call	0xc090	; 0xc090 <__ultoa_invert>
    bea0:	d8 2e       	mov	r13, r24
    bea2:	d4 18       	sub	r13, r4
    bea4:	01 2f       	mov	r16, r17
    bea6:	0f 77       	andi	r16, 0x7F	; 127
    bea8:	06 ff       	sbrs	r16, 6
    beaa:	09 c0       	rjmp	.+18     	; 0xbebe <vfprintf+0x2e6>
    beac:	0e 7f       	andi	r16, 0xFE	; 254
    beae:	df 14       	cp	r13, r15
    beb0:	30 f4       	brcc	.+12     	; 0xbebe <vfprintf+0x2e6>
    beb2:	04 ff       	sbrs	r16, 4
    beb4:	06 c0       	rjmp	.+12     	; 0xbec2 <vfprintf+0x2ea>
    beb6:	02 fd       	sbrc	r16, 2
    beb8:	04 c0       	rjmp	.+8      	; 0xbec2 <vfprintf+0x2ea>
    beba:	0f 7e       	andi	r16, 0xEF	; 239
    bebc:	02 c0       	rjmp	.+4      	; 0xbec2 <vfprintf+0x2ea>
    bebe:	1d 2d       	mov	r17, r13
    bec0:	01 c0       	rjmp	.+2      	; 0xbec4 <vfprintf+0x2ec>
    bec2:	1f 2d       	mov	r17, r15
    bec4:	80 2f       	mov	r24, r16
    bec6:	90 e0       	ldi	r25, 0x00	; 0
    bec8:	04 ff       	sbrs	r16, 4
    beca:	0c c0       	rjmp	.+24     	; 0xbee4 <vfprintf+0x30c>
    becc:	fe 01       	movw	r30, r28
    bece:	ed 0d       	add	r30, r13
    bed0:	f1 1d       	adc	r31, r1
    bed2:	20 81       	ld	r18, Z
    bed4:	20 33       	cpi	r18, 0x30	; 48
    bed6:	11 f4       	brne	.+4      	; 0xbedc <vfprintf+0x304>
    bed8:	09 7e       	andi	r16, 0xE9	; 233
    beda:	09 c0       	rjmp	.+18     	; 0xbeee <vfprintf+0x316>
    bedc:	02 ff       	sbrs	r16, 2
    bede:	06 c0       	rjmp	.+12     	; 0xbeec <vfprintf+0x314>
    bee0:	1e 5f       	subi	r17, 0xFE	; 254
    bee2:	05 c0       	rjmp	.+10     	; 0xbeee <vfprintf+0x316>
    bee4:	86 78       	andi	r24, 0x86	; 134
    bee6:	90 70       	andi	r25, 0x00	; 0
    bee8:	00 97       	sbiw	r24, 0x00	; 0
    beea:	09 f0       	breq	.+2      	; 0xbeee <vfprintf+0x316>
    beec:	1f 5f       	subi	r17, 0xFF	; 255
    beee:	80 2e       	mov	r8, r16
    bef0:	99 24       	eor	r9, r9
    bef2:	03 fd       	sbrc	r16, 3
    bef4:	12 c0       	rjmp	.+36     	; 0xbf1a <vfprintf+0x342>
    bef6:	00 ff       	sbrs	r16, 0
    bef8:	0d c0       	rjmp	.+26     	; 0xbf14 <vfprintf+0x33c>
    befa:	fd 2c       	mov	r15, r13
    befc:	1e 15       	cp	r17, r14
    befe:	50 f4       	brcc	.+20     	; 0xbf14 <vfprintf+0x33c>
    bf00:	fe 0c       	add	r15, r14
    bf02:	f1 1a       	sub	r15, r17
    bf04:	1e 2d       	mov	r17, r14
    bf06:	06 c0       	rjmp	.+12     	; 0xbf14 <vfprintf+0x33c>
    bf08:	80 e2       	ldi	r24, 0x20	; 32
    bf0a:	90 e0       	ldi	r25, 0x00	; 0
    bf0c:	b3 01       	movw	r22, r6
    bf0e:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bf12:	1f 5f       	subi	r17, 0xFF	; 255
    bf14:	1e 15       	cp	r17, r14
    bf16:	c0 f3       	brcs	.-16     	; 0xbf08 <vfprintf+0x330>
    bf18:	04 c0       	rjmp	.+8      	; 0xbf22 <vfprintf+0x34a>
    bf1a:	1e 15       	cp	r17, r14
    bf1c:	10 f4       	brcc	.+4      	; 0xbf22 <vfprintf+0x34a>
    bf1e:	e1 1a       	sub	r14, r17
    bf20:	01 c0       	rjmp	.+2      	; 0xbf24 <vfprintf+0x34c>
    bf22:	ee 24       	eor	r14, r14
    bf24:	84 fe       	sbrs	r8, 4
    bf26:	0f c0       	rjmp	.+30     	; 0xbf46 <vfprintf+0x36e>
    bf28:	80 e3       	ldi	r24, 0x30	; 48
    bf2a:	90 e0       	ldi	r25, 0x00	; 0
    bf2c:	b3 01       	movw	r22, r6
    bf2e:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bf32:	82 fe       	sbrs	r8, 2
    bf34:	1f c0       	rjmp	.+62     	; 0xbf74 <vfprintf+0x39c>
    bf36:	81 fe       	sbrs	r8, 1
    bf38:	03 c0       	rjmp	.+6      	; 0xbf40 <vfprintf+0x368>
    bf3a:	88 e5       	ldi	r24, 0x58	; 88
    bf3c:	90 e0       	ldi	r25, 0x00	; 0
    bf3e:	10 c0       	rjmp	.+32     	; 0xbf60 <vfprintf+0x388>
    bf40:	88 e7       	ldi	r24, 0x78	; 120
    bf42:	90 e0       	ldi	r25, 0x00	; 0
    bf44:	0d c0       	rjmp	.+26     	; 0xbf60 <vfprintf+0x388>
    bf46:	c4 01       	movw	r24, r8
    bf48:	86 78       	andi	r24, 0x86	; 134
    bf4a:	90 70       	andi	r25, 0x00	; 0
    bf4c:	00 97       	sbiw	r24, 0x00	; 0
    bf4e:	91 f0       	breq	.+36     	; 0xbf74 <vfprintf+0x39c>
    bf50:	81 fc       	sbrc	r8, 1
    bf52:	02 c0       	rjmp	.+4      	; 0xbf58 <vfprintf+0x380>
    bf54:	80 e2       	ldi	r24, 0x20	; 32
    bf56:	01 c0       	rjmp	.+2      	; 0xbf5a <vfprintf+0x382>
    bf58:	8b e2       	ldi	r24, 0x2B	; 43
    bf5a:	07 fd       	sbrc	r16, 7
    bf5c:	8d e2       	ldi	r24, 0x2D	; 45
    bf5e:	90 e0       	ldi	r25, 0x00	; 0
    bf60:	b3 01       	movw	r22, r6
    bf62:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bf66:	06 c0       	rjmp	.+12     	; 0xbf74 <vfprintf+0x39c>
    bf68:	80 e3       	ldi	r24, 0x30	; 48
    bf6a:	90 e0       	ldi	r25, 0x00	; 0
    bf6c:	b3 01       	movw	r22, r6
    bf6e:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bf72:	fa 94       	dec	r15
    bf74:	df 14       	cp	r13, r15
    bf76:	c0 f3       	brcs	.-16     	; 0xbf68 <vfprintf+0x390>
    bf78:	da 94       	dec	r13
    bf7a:	f2 01       	movw	r30, r4
    bf7c:	ed 0d       	add	r30, r13
    bf7e:	f1 1d       	adc	r31, r1
    bf80:	80 81       	ld	r24, Z
    bf82:	90 e0       	ldi	r25, 0x00	; 0
    bf84:	b3 01       	movw	r22, r6
    bf86:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bf8a:	dd 20       	and	r13, r13
    bf8c:	a9 f7       	brne	.-22     	; 0xbf78 <vfprintf+0x3a0>
    bf8e:	06 c0       	rjmp	.+12     	; 0xbf9c <vfprintf+0x3c4>
    bf90:	80 e2       	ldi	r24, 0x20	; 32
    bf92:	90 e0       	ldi	r25, 0x00	; 0
    bf94:	b3 01       	movw	r22, r6
    bf96:	0e 94 1c 60 	call	0xc038	; 0xc038 <fputc>
    bf9a:	ea 94       	dec	r14
    bf9c:	ee 20       	and	r14, r14
    bf9e:	c1 f7       	brne	.-16     	; 0xbf90 <vfprintf+0x3b8>
    bfa0:	40 ce       	rjmp	.-896    	; 0xbc22 <vfprintf+0x4a>
    bfa2:	f3 01       	movw	r30, r6
    bfa4:	86 81       	ldd	r24, Z+6	; 0x06
    bfa6:	97 81       	ldd	r25, Z+7	; 0x07
    bfa8:	02 c0       	rjmp	.+4      	; 0xbfae <vfprintf+0x3d6>
    bfaa:	8f ef       	ldi	r24, 0xFF	; 255
    bfac:	9f ef       	ldi	r25, 0xFF	; 255
    bfae:	2d 96       	adiw	r28, 0x0d	; 13
    bfb0:	cd bf       	out	0x3d, r28	; 61
    bfb2:	de bf       	out	0x3e, r29	; 62
    bfb4:	df 91       	pop	r29
    bfb6:	cf 91       	pop	r28
    bfb8:	1f 91       	pop	r17
    bfba:	0f 91       	pop	r16
    bfbc:	ff 90       	pop	r15
    bfbe:	ef 90       	pop	r14
    bfc0:	df 90       	pop	r13
    bfc2:	cf 90       	pop	r12
    bfc4:	bf 90       	pop	r11
    bfc6:	af 90       	pop	r10
    bfc8:	9f 90       	pop	r9
    bfca:	8f 90       	pop	r8
    bfcc:	7f 90       	pop	r7
    bfce:	6f 90       	pop	r6
    bfd0:	5f 90       	pop	r5
    bfd2:	4f 90       	pop	r4
    bfd4:	3f 90       	pop	r3
    bfd6:	2f 90       	pop	r2
    bfd8:	08 95       	ret

0000bfda <strnlen_P>:
    bfda:	fc 01       	movw	r30, r24
    bfdc:	05 90       	lpm	r0, Z+
    bfde:	61 50       	subi	r22, 0x01	; 1
    bfe0:	70 40       	sbci	r23, 0x00	; 0
    bfe2:	01 10       	cpse	r0, r1
    bfe4:	d8 f7       	brcc	.-10     	; 0xbfdc <strnlen_P+0x2>
    bfe6:	80 95       	com	r24
    bfe8:	90 95       	com	r25
    bfea:	8e 0f       	add	r24, r30
    bfec:	9f 1f       	adc	r25, r31
    bfee:	08 95       	ret

0000bff0 <memcpy>:
    bff0:	fb 01       	movw	r30, r22
    bff2:	dc 01       	movw	r26, r24
    bff4:	02 c0       	rjmp	.+4      	; 0xbffa <memcpy+0xa>
    bff6:	01 90       	ld	r0, Z+
    bff8:	0d 92       	st	X+, r0
    bffa:	41 50       	subi	r20, 0x01	; 1
    bffc:	50 40       	sbci	r21, 0x00	; 0
    bffe:	d8 f7       	brcc	.-10     	; 0xbff6 <memcpy+0x6>
    c000:	08 95       	ret

0000c002 <strnlen>:
    c002:	fc 01       	movw	r30, r24
    c004:	61 50       	subi	r22, 0x01	; 1
    c006:	70 40       	sbci	r23, 0x00	; 0
    c008:	01 90       	ld	r0, Z+
    c00a:	01 10       	cpse	r0, r1
    c00c:	d8 f7       	brcc	.-10     	; 0xc004 <strnlen+0x2>
    c00e:	80 95       	com	r24
    c010:	90 95       	com	r25
    c012:	8e 0f       	add	r24, r30
    c014:	9f 1f       	adc	r25, r31
    c016:	08 95       	ret

0000c018 <strrev>:
    c018:	dc 01       	movw	r26, r24
    c01a:	fc 01       	movw	r30, r24
    c01c:	67 2f       	mov	r22, r23
    c01e:	71 91       	ld	r23, Z+
    c020:	77 23       	and	r23, r23
    c022:	e1 f7       	brne	.-8      	; 0xc01c <strrev+0x4>
    c024:	32 97       	sbiw	r30, 0x02	; 2
    c026:	04 c0       	rjmp	.+8      	; 0xc030 <strrev+0x18>
    c028:	7c 91       	ld	r23, X
    c02a:	6d 93       	st	X+, r22
    c02c:	70 83       	st	Z, r23
    c02e:	62 91       	ld	r22, -Z
    c030:	ae 17       	cp	r26, r30
    c032:	bf 07       	cpc	r27, r31
    c034:	c8 f3       	brcs	.-14     	; 0xc028 <strrev+0x10>
    c036:	08 95       	ret

0000c038 <fputc>:
    c038:	0f 93       	push	r16
    c03a:	1f 93       	push	r17
    c03c:	cf 93       	push	r28
    c03e:	df 93       	push	r29
    c040:	8c 01       	movw	r16, r24
    c042:	eb 01       	movw	r28, r22
    c044:	8b 81       	ldd	r24, Y+3	; 0x03
    c046:	81 ff       	sbrs	r24, 1
    c048:	1b c0       	rjmp	.+54     	; 0xc080 <fputc+0x48>
    c04a:	82 ff       	sbrs	r24, 2
    c04c:	0d c0       	rjmp	.+26     	; 0xc068 <fputc+0x30>
    c04e:	2e 81       	ldd	r18, Y+6	; 0x06
    c050:	3f 81       	ldd	r19, Y+7	; 0x07
    c052:	8c 81       	ldd	r24, Y+4	; 0x04
    c054:	9d 81       	ldd	r25, Y+5	; 0x05
    c056:	28 17       	cp	r18, r24
    c058:	39 07       	cpc	r19, r25
    c05a:	64 f4       	brge	.+24     	; 0xc074 <fputc+0x3c>
    c05c:	e8 81       	ld	r30, Y
    c05e:	f9 81       	ldd	r31, Y+1	; 0x01
    c060:	01 93       	st	Z+, r16
    c062:	e8 83       	st	Y, r30
    c064:	f9 83       	std	Y+1, r31	; 0x01
    c066:	06 c0       	rjmp	.+12     	; 0xc074 <fputc+0x3c>
    c068:	e8 85       	ldd	r30, Y+8	; 0x08
    c06a:	f9 85       	ldd	r31, Y+9	; 0x09
    c06c:	80 2f       	mov	r24, r16
    c06e:	19 95       	eicall
    c070:	00 97       	sbiw	r24, 0x00	; 0
    c072:	31 f4       	brne	.+12     	; 0xc080 <fputc+0x48>
    c074:	8e 81       	ldd	r24, Y+6	; 0x06
    c076:	9f 81       	ldd	r25, Y+7	; 0x07
    c078:	01 96       	adiw	r24, 0x01	; 1
    c07a:	8e 83       	std	Y+6, r24	; 0x06
    c07c:	9f 83       	std	Y+7, r25	; 0x07
    c07e:	02 c0       	rjmp	.+4      	; 0xc084 <fputc+0x4c>
    c080:	0f ef       	ldi	r16, 0xFF	; 255
    c082:	1f ef       	ldi	r17, 0xFF	; 255
    c084:	c8 01       	movw	r24, r16
    c086:	df 91       	pop	r29
    c088:	cf 91       	pop	r28
    c08a:	1f 91       	pop	r17
    c08c:	0f 91       	pop	r16
    c08e:	08 95       	ret

0000c090 <__ultoa_invert>:
    c090:	fa 01       	movw	r30, r20
    c092:	aa 27       	eor	r26, r26
    c094:	28 30       	cpi	r18, 0x08	; 8
    c096:	51 f1       	breq	.+84     	; 0xc0ec <__ultoa_invert+0x5c>
    c098:	20 31       	cpi	r18, 0x10	; 16
    c09a:	81 f1       	breq	.+96     	; 0xc0fc <__ultoa_invert+0x6c>
    c09c:	e8 94       	clt
    c09e:	6f 93       	push	r22
    c0a0:	6e 7f       	andi	r22, 0xFE	; 254
    c0a2:	6e 5f       	subi	r22, 0xFE	; 254
    c0a4:	7f 4f       	sbci	r23, 0xFF	; 255
    c0a6:	8f 4f       	sbci	r24, 0xFF	; 255
    c0a8:	9f 4f       	sbci	r25, 0xFF	; 255
    c0aa:	af 4f       	sbci	r26, 0xFF	; 255
    c0ac:	b1 e0       	ldi	r27, 0x01	; 1
    c0ae:	3e d0       	rcall	.+124    	; 0xc12c <__ultoa_invert+0x9c>
    c0b0:	b4 e0       	ldi	r27, 0x04	; 4
    c0b2:	3c d0       	rcall	.+120    	; 0xc12c <__ultoa_invert+0x9c>
    c0b4:	67 0f       	add	r22, r23
    c0b6:	78 1f       	adc	r23, r24
    c0b8:	89 1f       	adc	r24, r25
    c0ba:	9a 1f       	adc	r25, r26
    c0bc:	a1 1d       	adc	r26, r1
    c0be:	68 0f       	add	r22, r24
    c0c0:	79 1f       	adc	r23, r25
    c0c2:	8a 1f       	adc	r24, r26
    c0c4:	91 1d       	adc	r25, r1
    c0c6:	a1 1d       	adc	r26, r1
    c0c8:	6a 0f       	add	r22, r26
    c0ca:	71 1d       	adc	r23, r1
    c0cc:	81 1d       	adc	r24, r1
    c0ce:	91 1d       	adc	r25, r1
    c0d0:	a1 1d       	adc	r26, r1
    c0d2:	20 d0       	rcall	.+64     	; 0xc114 <__ultoa_invert+0x84>
    c0d4:	09 f4       	brne	.+2      	; 0xc0d8 <__ultoa_invert+0x48>
    c0d6:	68 94       	set
    c0d8:	3f 91       	pop	r19
    c0da:	2a e0       	ldi	r18, 0x0A	; 10
    c0dc:	26 9f       	mul	r18, r22
    c0de:	11 24       	eor	r1, r1
    c0e0:	30 19       	sub	r19, r0
    c0e2:	30 5d       	subi	r19, 0xD0	; 208
    c0e4:	31 93       	st	Z+, r19
    c0e6:	de f6       	brtc	.-74     	; 0xc09e <__ultoa_invert+0xe>
    c0e8:	cf 01       	movw	r24, r30
    c0ea:	08 95       	ret
    c0ec:	46 2f       	mov	r20, r22
    c0ee:	47 70       	andi	r20, 0x07	; 7
    c0f0:	40 5d       	subi	r20, 0xD0	; 208
    c0f2:	41 93       	st	Z+, r20
    c0f4:	b3 e0       	ldi	r27, 0x03	; 3
    c0f6:	0f d0       	rcall	.+30     	; 0xc116 <__ultoa_invert+0x86>
    c0f8:	c9 f7       	brne	.-14     	; 0xc0ec <__ultoa_invert+0x5c>
    c0fa:	f6 cf       	rjmp	.-20     	; 0xc0e8 <__ultoa_invert+0x58>
    c0fc:	46 2f       	mov	r20, r22
    c0fe:	4f 70       	andi	r20, 0x0F	; 15
    c100:	40 5d       	subi	r20, 0xD0	; 208
    c102:	4a 33       	cpi	r20, 0x3A	; 58
    c104:	18 f0       	brcs	.+6      	; 0xc10c <__ultoa_invert+0x7c>
    c106:	49 5d       	subi	r20, 0xD9	; 217
    c108:	31 fd       	sbrc	r19, 1
    c10a:	40 52       	subi	r20, 0x20	; 32
    c10c:	41 93       	st	Z+, r20
    c10e:	02 d0       	rcall	.+4      	; 0xc114 <__ultoa_invert+0x84>
    c110:	a9 f7       	brne	.-22     	; 0xc0fc <__ultoa_invert+0x6c>
    c112:	ea cf       	rjmp	.-44     	; 0xc0e8 <__ultoa_invert+0x58>
    c114:	b4 e0       	ldi	r27, 0x04	; 4
    c116:	a6 95       	lsr	r26
    c118:	97 95       	ror	r25
    c11a:	87 95       	ror	r24
    c11c:	77 95       	ror	r23
    c11e:	67 95       	ror	r22
    c120:	ba 95       	dec	r27
    c122:	c9 f7       	brne	.-14     	; 0xc116 <__ultoa_invert+0x86>
    c124:	00 97       	sbiw	r24, 0x00	; 0
    c126:	61 05       	cpc	r22, r1
    c128:	71 05       	cpc	r23, r1
    c12a:	08 95       	ret
    c12c:	9b 01       	movw	r18, r22
    c12e:	ac 01       	movw	r20, r24
    c130:	0a 2e       	mov	r0, r26
    c132:	06 94       	lsr	r0
    c134:	57 95       	ror	r21
    c136:	47 95       	ror	r20
    c138:	37 95       	ror	r19
    c13a:	27 95       	ror	r18
    c13c:	ba 95       	dec	r27
    c13e:	c9 f7       	brne	.-14     	; 0xc132 <__ultoa_invert+0xa2>
    c140:	62 0f       	add	r22, r18
    c142:	73 1f       	adc	r23, r19
    c144:	84 1f       	adc	r24, r20
    c146:	95 1f       	adc	r25, r21
    c148:	a0 1d       	adc	r26, r0
    c14a:	08 95       	ret

0000c14c <_exit>:
    c14c:	f8 94       	cli

0000c14e <__stop_program>:
    c14e:	ff cf       	rjmp	.-2      	; 0xc14e <__stop_program>
