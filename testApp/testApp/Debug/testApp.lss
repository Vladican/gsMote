
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c2f0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000012a  00802000  0000c2f0  0000c384  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fab  0080212a  0080212a  0000c4ae  2**0
                  ALLOC
  3 .stab         00002f64  00000000  00000000  0000c4b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b51  00000000  00000000  0000f414  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003e0  00000000  00000000  0000ff68  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cf58  00000000  00000000  00010348  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000220d  00000000  00000000  0001d2a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005a87  00000000  00000000  0001f4ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c90  00000000  00000000  00024f34  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004640  00000000  00000000  00026bc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000051ac  00000000  00000000  0002b204  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b168  00000000  00000000  000303b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000100  00000000  00000000  0018b518  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 a9 11 	jmp	0x2352	; 0x2352 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 bd 10 	jmp	0x217a	; 0x217a <__vector_16>
      44:	0c 94 ed 10 	jmp	0x21da	; 0x21da <__vector_17>
      48:	0c 94 1d 11 	jmp	0x223a	; 0x223a <__vector_18>
      4c:	0c 94 4d 11 	jmp	0x229a	; 0x229a <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 04 3f 	jmp	0x7e08	; 0x7e08 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 cd 2e 	jmp	0x5d9a	; 0x5d9a <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 5c 14 	jmp	0x28b8	; 0x28b8 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 9a 13 	jmp	0x2734	; 0x2734 <__vector_79>
     140:	0c 94 ca 13 	jmp	0x2794	; 0x2794 <__vector_80>
     144:	0c 94 fa 13 	jmp	0x27f4	; 0x27f4 <__vector_81>
     148:	0c 94 2a 14 	jmp	0x2854	; 0x2854 <__vector_82>
     14c:	0c 94 21 03 	jmp	0x642	; 0x642 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__vector_104>
     1a4:	0c 94 ab 0b 	jmp	0x1756	; 0x1756 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e0 ef       	ldi	r30, 0xF0	; 240
     244:	f2 ec       	ldi	r31, 0xC2	; 194
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	aa 32       	cpi	r26, 0x2A	; 42
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	aa e2       	ldi	r26, 0x2A	; 42
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a5 3d       	cpi	r26, 0xD5	; 213
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 9e 02 	call	0x53c	; 0x53c <main>
     26a:	0c 94 76 61 	jmp	0xc2ec	; 0xc2ec <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	ef 92       	push	r14
     274:	ff 92       	push	r15
     276:	0f 93       	push	r16
     278:	1f 93       	push	r17
     27a:	cf 93       	push	r28
     27c:	df 93       	push	r29
     27e:	00 d0       	rcall	.+0      	; 0x280 <StartSerial+0xe>
     280:	00 d0       	rcall	.+0      	; 0x282 <StartSerial+0x10>
     282:	cd b7       	in	r28, 0x3d	; 61
     284:	de b7       	in	r29, 0x3e	; 62
     286:	6b 83       	std	Y+3, r22	; 0x03
     288:	7c 83       	std	Y+4, r23	; 0x04
     28a:	8d 83       	std	Y+5, r24	; 0x05
     28c:	9e 83       	std	Y+6, r25	; 0x06
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     28e:	8b 81       	ldd	r24, Y+3	; 0x03
     290:	9c 81       	ldd	r25, Y+4	; 0x04
     292:	ad 81       	ldd	r26, Y+5	; 0x05
     294:	be 81       	ldd	r27, Y+6	; 0x06
     296:	88 35       	cpi	r24, 0x58	; 88
     298:	22 e0       	ldi	r18, 0x02	; 2
     29a:	92 07       	cpc	r25, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	a2 07       	cpc	r26, r18
     2a0:	20 e0       	ldi	r18, 0x00	; 0
     2a2:	b2 07       	cpc	r27, r18
     2a4:	60 f0       	brcs	.+24     	; 0x2be <StartSerial+0x4c>
     2a6:	8b 81       	ldd	r24, Y+3	; 0x03
     2a8:	9c 81       	ldd	r25, Y+4	; 0x04
     2aa:	ad 81       	ldd	r26, Y+5	; 0x05
     2ac:	be 81       	ldd	r27, Y+6	; 0x06
     2ae:	81 34       	cpi	r24, 0x41	; 65
     2b0:	e2 e4       	ldi	r30, 0x42	; 66
     2b2:	9e 07       	cpc	r25, r30
     2b4:	ef e0       	ldi	r30, 0x0F	; 15
     2b6:	ae 07       	cpc	r26, r30
     2b8:	e0 e0       	ldi	r30, 0x00	; 0
     2ba:	be 07       	cpc	r27, r30
     2bc:	10 f0       	brcs	.+4      	; 0x2c2 <StartSerial+0x50>
		//baud rate too fast or too slow
		return false;
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	af c0       	rjmp	.+350    	; 0x420 <StartSerial+0x1ae>
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2c2:	0e 94 be 32 	call	0x657c	; 0x657c <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2c6:	80 e4       	ldi	r24, 0x40	; 64
     2c8:	96 e0       	ldi	r25, 0x06	; 6
     2ca:	28 e0       	ldi	r18, 0x08	; 8
     2cc:	fc 01       	movw	r30, r24
     2ce:	21 83       	std	Z+1, r18	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2d0:	80 e4       	ldi	r24, 0x40	; 64
     2d2:	96 e0       	ldi	r25, 0x06	; 6
     2d4:	28 e0       	ldi	r18, 0x08	; 8
     2d6:	fc 01       	movw	r30, r24
     2d8:	25 83       	std	Z+5, r18	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2da:	80 e4       	ldi	r24, 0x40	; 64
     2dc:	96 e0       	ldi	r25, 0x06	; 6
     2de:	24 e0       	ldi	r18, 0x04	; 4
     2e0:	fc 01       	movw	r30, r24
     2e2:	22 83       	std	Z+2, r18	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2e4:	8b 81       	ldd	r24, Y+3	; 0x03
     2e6:	9c 81       	ldd	r25, Y+4	; 0x04
     2e8:	ad 81       	ldd	r26, Y+5	; 0x05
     2ea:	be 81       	ldd	r27, Y+6	; 0x06
     2ec:	88 0f       	add	r24, r24
     2ee:	99 1f       	adc	r25, r25
     2f0:	aa 1f       	adc	r26, r26
     2f2:	bb 1f       	adc	r27, r27
     2f4:	88 0f       	add	r24, r24
     2f6:	99 1f       	adc	r25, r25
     2f8:	aa 1f       	adc	r26, r26
     2fa:	bb 1f       	adc	r27, r27
     2fc:	88 0f       	add	r24, r24
     2fe:	99 1f       	adc	r25, r25
     300:	aa 1f       	adc	r26, r26
     302:	bb 1f       	adc	r27, r27
     304:	88 0f       	add	r24, r24
     306:	99 1f       	adc	r25, r25
     308:	aa 1f       	adc	r26, r26
     30a:	bb 1f       	adc	r27, r27
     30c:	bc 01       	movw	r22, r24
     30e:	cd 01       	movw	r24, r26
     310:	0e 94 61 5c 	call	0xb8c2	; 0xb8c2 <__floatunsisf>
     314:	9b 01       	movw	r18, r22
     316:	ac 01       	movw	r20, r24
     318:	60 e0       	ldi	r22, 0x00	; 0
     31a:	74 e2       	ldi	r23, 0x24	; 36
     31c:	84 ef       	ldi	r24, 0xF4	; 244
     31e:	9b e4       	ldi	r25, 0x4B	; 75
     320:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
     324:	dc 01       	movw	r26, r24
     326:	cb 01       	movw	r24, r22
     328:	bc 01       	movw	r22, r24
     32a:	cd 01       	movw	r24, r26
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	40 e8       	ldi	r20, 0x80	; 128
     332:	5f e3       	ldi	r21, 0x3F	; 63
     334:	0e 94 64 5b 	call	0xb6c8	; 0xb6c8 <__subsf3>
     338:	dc 01       	movw	r26, r24
     33a:	cb 01       	movw	r24, r22
     33c:	bc 01       	movw	r22, r24
     33e:	cd 01       	movw	r24, r26
     340:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
     344:	dc 01       	movw	r26, r24
     346:	cb 01       	movw	r24, r22
     348:	89 83       	std	Y+1, r24	; 0x01
     34a:	9a 83       	std	Y+2, r25	; 0x02
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     34c:	8b 81       	ldd	r24, Y+3	; 0x03
     34e:	9c 81       	ldd	r25, Y+4	; 0x04
     350:	ad 81       	ldd	r26, Y+5	; 0x05
     352:	be 81       	ldd	r27, Y+6	; 0x06
     354:	88 0f       	add	r24, r24
     356:	99 1f       	adc	r25, r25
     358:	aa 1f       	adc	r26, r26
     35a:	bb 1f       	adc	r27, r27
     35c:	88 0f       	add	r24, r24
     35e:	99 1f       	adc	r25, r25
     360:	aa 1f       	adc	r26, r26
     362:	bb 1f       	adc	r27, r27
     364:	88 0f       	add	r24, r24
     366:	99 1f       	adc	r25, r25
     368:	aa 1f       	adc	r26, r26
     36a:	bb 1f       	adc	r27, r27
     36c:	88 0f       	add	r24, r24
     36e:	99 1f       	adc	r25, r25
     370:	aa 1f       	adc	r26, r26
     372:	bb 1f       	adc	r27, r27
     374:	bc 01       	movw	r22, r24
     376:	cd 01       	movw	r24, r26
     378:	0e 94 61 5c 	call	0xb8c2	; 0xb8c2 <__floatunsisf>
     37c:	9b 01       	movw	r18, r22
     37e:	ac 01       	movw	r20, r24
     380:	60 e0       	ldi	r22, 0x00	; 0
     382:	74 e2       	ldi	r23, 0x24	; 36
     384:	84 ef       	ldi	r24, 0xF4	; 244
     386:	9b e4       	ldi	r25, 0x4B	; 75
     388:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
     38c:	dc 01       	movw	r26, r24
     38e:	cb 01       	movw	r24, r22
     390:	bc 01       	movw	r22, r24
     392:	cd 01       	movw	r24, r26
     394:	20 e0       	ldi	r18, 0x00	; 0
     396:	30 e0       	ldi	r19, 0x00	; 0
     398:	40 e8       	ldi	r20, 0x80	; 128
     39a:	5f e3       	ldi	r21, 0x3F	; 63
     39c:	0e 94 64 5b 	call	0xb6c8	; 0xb6c8 <__subsf3>
     3a0:	dc 01       	movw	r26, r24
     3a2:	cb 01       	movw	r24, r22
     3a4:	7c 01       	movw	r14, r24
     3a6:	8d 01       	movw	r16, r26
     3a8:	89 81       	ldd	r24, Y+1	; 0x01
     3aa:	9a 81       	ldd	r25, Y+2	; 0x02
     3ac:	cc 01       	movw	r24, r24
     3ae:	a0 e0       	ldi	r26, 0x00	; 0
     3b0:	b0 e0       	ldi	r27, 0x00	; 0
     3b2:	bc 01       	movw	r22, r24
     3b4:	cd 01       	movw	r24, r26
     3b6:	0e 94 61 5c 	call	0xb8c2	; 0xb8c2 <__floatunsisf>
     3ba:	9b 01       	movw	r18, r22
     3bc:	ac 01       	movw	r20, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	b7 01       	movw	r22, r14
     3c2:	0e 94 64 5b 	call	0xb6c8	; 0xb6c8 <__subsf3>
     3c6:	dc 01       	movw	r26, r24
     3c8:	cb 01       	movw	r24, r22
     3ca:	11 e0       	ldi	r17, 0x01	; 1
     3cc:	bc 01       	movw	r22, r24
     3ce:	cd 01       	movw	r24, r26
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	40 e0       	ldi	r20, 0x00	; 0
     3d6:	5f e3       	ldi	r21, 0x3F	; 63
     3d8:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
     3dc:	88 23       	and	r24, r24
     3de:	0c f4       	brge	.+2      	; 0x3e2 <StartSerial+0x170>
     3e0:	10 e0       	ldi	r17, 0x00	; 0
     3e2:	11 23       	and	r17, r17
     3e4:	29 f0       	breq	.+10     	; 0x3f0 <StartSerial+0x17e>
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	9a 81       	ldd	r25, Y+2	; 0x02
     3ea:	01 96       	adiw	r24, 0x01	; 1
     3ec:	89 83       	std	Y+1, r24	; 0x01
     3ee:	9a 83       	std	Y+2, r25	; 0x02
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     3f0:	80 ea       	ldi	r24, 0xA0	; 160
     3f2:	98 e0       	ldi	r25, 0x08	; 8
     3f4:	29 81       	ldd	r18, Y+1	; 0x01
     3f6:	fc 01       	movw	r30, r24
     3f8:	26 83       	std	Z+6, r18	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     3fa:	80 ea       	ldi	r24, 0xA0	; 160
     3fc:	98 e0       	ldi	r25, 0x08	; 8
     3fe:	29 81       	ldd	r18, Y+1	; 0x01
     400:	3a 81       	ldd	r19, Y+2	; 0x02
     402:	23 2f       	mov	r18, r19
     404:	33 27       	eor	r19, r19
     406:	fc 01       	movw	r30, r24
     408:	27 83       	std	Z+7, r18	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     40a:	80 ea       	ldi	r24, 0xA0	; 160
     40c:	98 e0       	ldi	r25, 0x08	; 8
     40e:	23 e0       	ldi	r18, 0x03	; 3
     410:	fc 01       	movw	r30, r24
     412:	25 83       	std	Z+5, r18	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     414:	80 ea       	ldi	r24, 0xA0	; 160
     416:	98 e0       	ldi	r25, 0x08	; 8
     418:	28 e1       	ldi	r18, 0x18	; 24
     41a:	fc 01       	movw	r30, r24
     41c:	24 83       	std	Z+4, r18	; 0x04
	return true;
     41e:	81 e0       	ldi	r24, 0x01	; 1
}
     420:	26 96       	adiw	r28, 0x06	; 6
     422:	cd bf       	out	0x3d, r28	; 61
     424:	de bf       	out	0x3e, r29	; 62
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	0f 91       	pop	r16
     42e:	ff 90       	pop	r15
     430:	ef 90       	pop	r14
     432:	08 95       	ret

00000434 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	0f 92       	push	r0
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
     43e:	89 83       	std	Y+1, r24	; 0x01
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     440:	00 00       	nop
     442:	80 ea       	ldi	r24, 0xA0	; 160
     444:	98 e0       	ldi	r25, 0x08	; 8
     446:	fc 01       	movw	r30, r24
     448:	81 81       	ldd	r24, Z+1	; 0x01
     44a:	88 2f       	mov	r24, r24
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	80 72       	andi	r24, 0x20	; 32
     450:	90 70       	andi	r25, 0x00	; 0
     452:	00 97       	sbiw	r24, 0x00	; 0
     454:	b1 f3       	breq	.-20     	; 0x442 <SerialWriteByte+0xe>
		//wait
	}
	//incremented byte
	USARTC0.DATA = byte;
     456:	80 ea       	ldi	r24, 0xA0	; 160
     458:	98 e0       	ldi	r25, 0x08	; 8
     45a:	29 81       	ldd	r18, Y+1	; 0x01
     45c:	fc 01       	movw	r30, r24
     45e:	20 83       	st	Z, r18
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     460:	0f 90       	pop	r0
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	08 95       	ret

00000468 <SerialReadByte>:

uint8_t SerialReadByte(){
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	0f 92       	push	r0
     46e:	cd b7       	in	r28, 0x3d	; 61
     470:	de b7       	in	r29, 0x3e	; 62
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     472:	00 00       	nop
     474:	80 ea       	ldi	r24, 0xA0	; 160
     476:	98 e0       	ldi	r25, 0x08	; 8
     478:	fc 01       	movw	r30, r24
     47a:	81 81       	ldd	r24, Z+1	; 0x01
     47c:	88 23       	and	r24, r24
     47e:	d4 f7       	brge	.-12     	; 0x474 <SerialReadByte+0xc>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     480:	80 ea       	ldi	r24, 0xA0	; 160
     482:	98 e0       	ldi	r25, 0x08	; 8
     484:	fc 01       	movw	r30, r24
     486:	80 81       	ld	r24, Z
     488:	89 83       	std	Y+1, r24	; 0x01
	return byte;	
     48a:	89 81       	ldd	r24, Y+1	; 0x01
}
     48c:	0f 90       	pop	r0
     48e:	df 91       	pop	r29
     490:	cf 91       	pop	r28
     492:	08 95       	ret

00000494 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     494:	cf 93       	push	r28
     496:	df 93       	push	r29
     498:	cd b7       	in	r28, 0x3d	; 61
     49a:	de b7       	in	r29, 0x3e	; 62
     49c:	2a 97       	sbiw	r28, 0x0a	; 10
     49e:	cd bf       	out	0x3d, r28	; 61
     4a0:	de bf       	out	0x3e, r29	; 62
     4a2:	8d 83       	std	Y+5, r24	; 0x05
     4a4:	9e 83       	std	Y+6, r25	; 0x06
     4a6:	4f 83       	std	Y+7, r20	; 0x07
     4a8:	58 87       	std	Y+8, r21	; 0x08
     4aa:	69 87       	std	Y+9, r22	; 0x09
     4ac:	7a 87       	std	Y+10, r23	; 0x0a
	uint32_t i;
	for(i=0;i<length;i++){
     4ae:	19 82       	std	Y+1, r1	; 0x01
     4b0:	1a 82       	std	Y+2, r1	; 0x02
     4b2:	1b 82       	std	Y+3, r1	; 0x03
     4b4:	1c 82       	std	Y+4, r1	; 0x04
     4b6:	15 c0       	rjmp	.+42     	; 0x4e2 <SerialWriteBuffer+0x4e>
		SerialWriteByte(buffer[i]);
     4b8:	89 81       	ldd	r24, Y+1	; 0x01
     4ba:	9a 81       	ldd	r25, Y+2	; 0x02
     4bc:	2d 81       	ldd	r18, Y+5	; 0x05
     4be:	3e 81       	ldd	r19, Y+6	; 0x06
     4c0:	82 0f       	add	r24, r18
     4c2:	93 1f       	adc	r25, r19
     4c4:	fc 01       	movw	r30, r24
     4c6:	80 81       	ld	r24, Z
     4c8:	0e 94 1a 02 	call	0x434	; 0x434 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     4cc:	89 81       	ldd	r24, Y+1	; 0x01
     4ce:	9a 81       	ldd	r25, Y+2	; 0x02
     4d0:	ab 81       	ldd	r26, Y+3	; 0x03
     4d2:	bc 81       	ldd	r27, Y+4	; 0x04
     4d4:	01 96       	adiw	r24, 0x01	; 1
     4d6:	a1 1d       	adc	r26, r1
     4d8:	b1 1d       	adc	r27, r1
     4da:	89 83       	std	Y+1, r24	; 0x01
     4dc:	9a 83       	std	Y+2, r25	; 0x02
     4de:	ab 83       	std	Y+3, r26	; 0x03
     4e0:	bc 83       	std	Y+4, r27	; 0x04
     4e2:	29 81       	ldd	r18, Y+1	; 0x01
     4e4:	3a 81       	ldd	r19, Y+2	; 0x02
     4e6:	4b 81       	ldd	r20, Y+3	; 0x03
     4e8:	5c 81       	ldd	r21, Y+4	; 0x04
     4ea:	8f 81       	ldd	r24, Y+7	; 0x07
     4ec:	98 85       	ldd	r25, Y+8	; 0x08
     4ee:	a9 85       	ldd	r26, Y+9	; 0x09
     4f0:	ba 85       	ldd	r27, Y+10	; 0x0a
     4f2:	28 17       	cp	r18, r24
     4f4:	39 07       	cpc	r19, r25
     4f6:	4a 07       	cpc	r20, r26
     4f8:	5b 07       	cpc	r21, r27
     4fa:	f0 f2       	brcs	.-68     	; 0x4b8 <SerialWriteBuffer+0x24>
		SerialWriteByte(buffer[i]);
	}
}
     4fc:	2a 96       	adiw	r28, 0x0a	; 10
     4fe:	cd bf       	out	0x3d, r28	; 61
     500:	de bf       	out	0x3e, r29	; 62
     502:	df 91       	pop	r29
     504:	cf 91       	pop	r28
     506:	08 95       	ret

00000508 <StopSerial>:

void StopSerial(){
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	cd b7       	in	r28, 0x3d	; 61
     50e:	de b7       	in	r29, 0x3e	; 62
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     510:	80 ea       	ldi	r24, 0xA0	; 160
     512:	98 e0       	ldi	r25, 0x08	; 8
     514:	20 ea       	ldi	r18, 0xA0	; 160
     516:	38 e0       	ldi	r19, 0x08	; 8
     518:	f9 01       	movw	r30, r18
     51a:	24 81       	ldd	r18, Z+4	; 0x04
     51c:	27 7e       	andi	r18, 0xE7	; 231
     51e:	fc 01       	movw	r30, r24
     520:	24 83       	std	Z+4, r18	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     522:	80 e4       	ldi	r24, 0x40	; 64
     524:	96 e0       	ldi	r25, 0x06	; 6
     526:	28 e0       	ldi	r18, 0x08	; 8
     528:	fc 01       	movw	r30, r24
     52a:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     52c:	80 e4       	ldi	r24, 0x40	; 64
     52e:	96 e0       	ldi	r25, 0x06	; 6
     530:	28 e0       	ldi	r18, 0x08	; 8
     532:	fc 01       	movw	r30, r24
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	df 91       	pop	r29
     538:	cf 91       	pop	r28
     53a:	08 95       	ret

0000053c <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     53c:	cf 92       	push	r12
     53e:	df 92       	push	r13
     540:	ef 92       	push	r14
     542:	ff 92       	push	r15
     544:	0f 93       	push	r16
     546:	1f 93       	push	r17
     548:	cf 93       	push	r28
     54a:	df 93       	push	r29
     54c:	cd b7       	in	r28, 0x3d	; 61
     54e:	de b7       	in	r29, 0x3e	; 62

	pcb_t* pcb;
	chb_init();
     550:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <chb_init>
	chb_set_channel(1);
     554:	81 e0       	ldi	r24, 0x01	; 1
     556:	0e 94 98 26 	call	0x4d30	; 0x4d30 <chb_set_channel>
	chb_set_short_addr(0x0002);
     55a:	82 e0       	ldi	r24, 0x02	; 2
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	0e 94 94 2c 	call	0x5928	; 0x5928 <chb_set_short_addr>
	while(1){
		//collect data
		CO_collectADC(ADC_CH_1_gc, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), GAIN_1_gc, 1000, 32,(int32_t*)FRAMReadBuffer);
     562:	e0 ed       	ldi	r30, 0xD0	; 208
     564:	f3 e2       	ldi	r31, 0x23	; 35
     566:	80 e0       	ldi	r24, 0x00	; 0
     568:	64 ec       	ldi	r22, 0xC4	; 196
     56a:	40 e0       	ldi	r20, 0x00	; 0
     56c:	28 ee       	ldi	r18, 0xE8	; 232
     56e:	33 e0       	ldi	r19, 0x03	; 3
     570:	ee 24       	eor	r14, r14
     572:	ff 24       	eor	r15, r15
     574:	87 01       	movw	r16, r14
     576:	68 94       	set
     578:	e5 f8       	bld	r14, 5
     57a:	6f 01       	movw	r12, r30
     57c:	0e 94 21 0a 	call	0x1442	; 0x1442 <CO_collectADC>
		//send data to base station
		chb_write(0x0000,FRAMReadBuffer,128);
     580:	20 ed       	ldi	r18, 0xD0	; 208
     582:	33 e2       	ldi	r19, 0x23	; 35
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	90 e0       	ldi	r25, 0x00	; 0
     588:	b9 01       	movw	r22, r18
     58a:	20 e8       	ldi	r18, 0x80	; 128
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	40 e0       	ldi	r20, 0x00	; 0
     590:	50 e0       	ldi	r21, 0x00	; 0
     592:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <chb_write>
	}	
     596:	e5 cf       	rjmp	.-54     	; 0x562 <main+0x26>

00000598 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
     59c:	0f 92       	push	r0
     59e:	0f 92       	push	r0
     5a0:	cd b7       	in	r28, 0x3d	; 61
     5a2:	de b7       	in	r29, 0x3e	; 62
     5a4:	89 83       	std	Y+1, r24	; 0x01
     5a6:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     5a8:	81 e0       	ldi	r24, 0x01	; 1
     5aa:	80 93 c1 50 	sts	0x50C1, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     5ae:	83 e0       	ldi	r24, 0x03	; 3
     5b0:	80 93 4f 40 	sts	0x404F, r24
	chb_init();
     5b4:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <chb_init>
	chb_set_short_addr(moteID);
     5b8:	80 91 c1 50 	lds	r24, 0x50C1
     5bc:	88 2f       	mov	r24, r24
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	0e 94 94 2c 	call	0x5928	; 0x5928 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     5c4:	80 e8       	ldi	r24, 0x80	; 128
     5c6:	91 e0       	ldi	r25, 0x01	; 1
     5c8:	28 ec       	ldi	r18, 0xC8	; 200
     5ca:	fc 01       	movw	r30, r24
     5cc:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     5ce:	80 e4       	ldi	r24, 0x40	; 64
     5d0:	99 e0       	ldi	r25, 0x09	; 9
     5d2:	29 e0       	ldi	r18, 0x09	; 9
     5d4:	fc 01       	movw	r30, r24
     5d6:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     5d8:	80 e4       	ldi	r24, 0x40	; 64
     5da:	99 e0       	ldi	r25, 0x09	; 9
     5dc:	22 e0       	ldi	r18, 0x02	; 2
     5de:	fc 01       	movw	r30, r24
     5e0:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     5e2:	80 e4       	ldi	r24, 0x40	; 64
     5e4:	99 e0       	ldi	r25, 0x09	; 9
     5e6:	69 81       	ldd	r22, Y+1	; 0x01
     5e8:	7a 81       	ldd	r23, Y+2	; 0x02
     5ea:	44 ef       	ldi	r20, 0xF4	; 244
     5ec:	51 e0       	ldi	r21, 0x01	; 1
     5ee:	64 9f       	mul	r22, r20
     5f0:	90 01       	movw	r18, r0
     5f2:	65 9f       	mul	r22, r21
     5f4:	30 0d       	add	r19, r0
     5f6:	74 9f       	mul	r23, r20
     5f8:	30 0d       	add	r19, r0
     5fa:	11 24       	eor	r1, r1
     5fc:	fc 01       	movw	r30, r24
     5fe:	26 a3       	lds	r18, 0x56
     600:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     602:	80 e4       	ldi	r24, 0x40	; 64
     604:	98 e0       	ldi	r25, 0x08	; 8
     606:	20 e0       	ldi	r18, 0x00	; 0
     608:	3a ef       	ldi	r19, 0xFA	; 250
     60a:	fc 01       	movw	r30, r24
     60c:	26 a3       	lds	r18, 0x56
     60e:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     610:	80 e4       	ldi	r24, 0x40	; 64
     612:	98 e0       	ldi	r25, 0x08	; 8
     614:	21 e0       	ldi	r18, 0x01	; 1
     616:	fc 01       	movw	r30, r24
     618:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     61a:	80 e4       	ldi	r24, 0x40	; 64
     61c:	98 e0       	ldi	r25, 0x08	; 8
     61e:	21 e0       	ldi	r18, 0x01	; 1
     620:	fc 01       	movw	r30, r24
     622:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     624:	80 ea       	ldi	r24, 0xA0	; 160
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	20 ea       	ldi	r18, 0xA0	; 160
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	f9 01       	movw	r30, r18
     62e:	22 81       	ldd	r18, Z+2	; 0x02
     630:	27 60       	ori	r18, 0x07	; 7
     632:	fc 01       	movw	r30, r24
     634:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     636:	78 94       	sei
}
     638:	0f 90       	pop	r0
     63a:	0f 90       	pop	r0
     63c:	df 91       	pop	r29
     63e:	cf 91       	pop	r28
     640:	08 95       	ret

00000642 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     642:	78 94       	sei
     644:	1f 92       	push	r1
     646:	0f 92       	push	r0
     648:	0f b6       	in	r0, 0x3f	; 63
     64a:	0f 92       	push	r0
     64c:	00 90 3b 00 	lds	r0, 0x003B
     650:	0f 92       	push	r0
     652:	11 24       	eor	r1, r1
     654:	2f 93       	push	r18
     656:	3f 93       	push	r19
     658:	4f 93       	push	r20
     65a:	5f 93       	push	r21
     65c:	6f 93       	push	r22
     65e:	7f 93       	push	r23
     660:	8f 93       	push	r24
     662:	9f 93       	push	r25
     664:	af 93       	push	r26
     666:	bf 93       	push	r27
     668:	ef 93       	push	r30
     66a:	ff 93       	push	r31
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	cd b7       	in	r28, 0x3d	; 61
     672:	de b7       	in	r29, 0x3e	; 62
     674:	28 97       	sbiw	r28, 0x08	; 8
     676:	cd bf       	out	0x3d, r28	; 61
     678:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     67a:	80 e4       	ldi	r24, 0x40	; 64
     67c:	98 e0       	ldi	r25, 0x08	; 8
     67e:	fc 01       	movw	r30, r24
     680:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     682:	80 e4       	ldi	r24, 0x40	; 64
     684:	99 e0       	ldi	r25, 0x09	; 9
     686:	fc 01       	movw	r30, r24
     688:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     68a:	82 e0       	ldi	r24, 0x02	; 2
     68c:	80 93 4f 40 	sts	0x404F, r24
	char message[8];
	strcpy(message,"reset");
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	20 e0       	ldi	r18, 0x00	; 0
     696:	30 e2       	ldi	r19, 0x20	; 32
     698:	46 e0       	ldi	r20, 0x06	; 6
     69a:	f9 01       	movw	r30, r18
     69c:	00 80       	ld	r0, Z
     69e:	2f 5f       	subi	r18, 0xFF	; 255
     6a0:	3f 4f       	sbci	r19, 0xFF	; 255
     6a2:	fc 01       	movw	r30, r24
     6a4:	00 82       	st	Z, r0
     6a6:	01 96       	adiw	r24, 0x01	; 1
     6a8:	41 50       	subi	r20, 0x01	; 1
     6aa:	44 23       	and	r20, r20
     6ac:	b1 f7       	brne	.-20     	; 0x69a <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     6ae:	80 91 c1 50 	lds	r24, 0x50C1
     6b2:	88 2f       	mov	r24, r24
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	27 ec       	ldi	r18, 0xC7	; 199
     6b8:	30 e5       	ldi	r19, 0x50	; 80
     6ba:	b9 01       	movw	r22, r18
     6bc:	4a e0       	ldi	r20, 0x0A	; 10
     6be:	50 e0       	ldi	r21, 0x00	; 0
     6c0:	0e 94 60 5e 	call	0xbcc0	; 0xbcc0 <itoa>
	strcat(message,buff);
     6c4:	27 ec       	ldi	r18, 0xC7	; 199
     6c6:	30 e5       	ldi	r19, 0x50	; 80
     6c8:	ce 01       	movw	r24, r28
     6ca:	01 96       	adiw	r24, 0x01	; 1
     6cc:	b9 01       	movw	r22, r18
     6ce:	0e 94 47 5e 	call	0xbc8e	; 0xbc8e <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     6d2:	0e 94 94 0b 	call	0x1728	; 0x1728 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     6d6:	ce 01       	movw	r24, r28
     6d8:	01 96       	adiw	r24, 0x01	; 1
     6da:	9c 01       	movw	r18, r24
     6dc:	f9 01       	movw	r30, r18
     6de:	01 90       	ld	r0, Z+
     6e0:	00 20       	and	r0, r0
     6e2:	e9 f7       	brne	.-6      	; 0x6de <__vector_83+0x9c>
     6e4:	cf 01       	movw	r24, r30
     6e6:	01 97       	sbiw	r24, 0x01	; 1
     6e8:	82 1b       	sub	r24, r18
     6ea:	93 0b       	sbc	r25, r19
     6ec:	9c 01       	movw	r18, r24
     6ee:	40 e0       	ldi	r20, 0x00	; 0
     6f0:	50 e0       	ldi	r21, 0x00	; 0
     6f2:	80 e0       	ldi	r24, 0x00	; 0
     6f4:	90 e0       	ldi	r25, 0x00	; 0
     6f6:	be 01       	movw	r22, r28
     6f8:	6f 5f       	subi	r22, 0xFF	; 255
     6fa:	7f 4f       	sbci	r23, 0xFF	; 255
     6fc:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <chb_write>
}	
     700:	28 96       	adiw	r28, 0x08	; 8
     702:	cd bf       	out	0x3d, r28	; 61
     704:	de bf       	out	0x3e, r29	; 62
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	ff 91       	pop	r31
     70c:	ef 91       	pop	r30
     70e:	bf 91       	pop	r27
     710:	af 91       	pop	r26
     712:	9f 91       	pop	r25
     714:	8f 91       	pop	r24
     716:	7f 91       	pop	r23
     718:	6f 91       	pop	r22
     71a:	5f 91       	pop	r21
     71c:	4f 91       	pop	r20
     71e:	3f 91       	pop	r19
     720:	2f 91       	pop	r18
     722:	0f 90       	pop	r0
     724:	00 92 3b 00 	sts	0x003B, r0
     728:	0f 90       	pop	r0
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	0f 90       	pop	r0
     72e:	1f 90       	pop	r1
     730:	18 95       	reti

00000732 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	cd b7       	in	r28, 0x3d	; 61
     738:	de b7       	in	r29, 0x3e	; 62
     73a:	6b 97       	sbiw	r28, 0x1b	; 27
     73c:	cd bf       	out	0x3d, r28	; 61
     73e:	de bf       	out	0x3e, r29	; 62
     740:	8e 8b       	std	Y+22, r24	; 0x16
     742:	9f 8b       	std	Y+23, r25	; 0x17
     744:	68 8f       	std	Y+24, r22	; 0x18
     746:	79 8f       	std	Y+25, r23	; 0x19
     748:	4a 8f       	std	Y+26, r20	; 0x1a
     74a:	5b 8f       	std	Y+27, r21	; 0x1b
	
	uint32_t sum = 0;
     74c:	19 82       	std	Y+1, r1	; 0x01
     74e:	1a 82       	std	Y+2, r1	; 0x02
     750:	1b 82       	std	Y+3, r1	; 0x03
     752:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     754:	80 e0       	ldi	r24, 0x00	; 0
     756:	90 e1       	ldi	r25, 0x10	; 16
     758:	a0 e0       	ldi	r26, 0x00	; 0
     75a:	b0 e0       	ldi	r27, 0x00	; 0
     75c:	8d 83       	std	Y+5, r24	; 0x05
     75e:	9e 83       	std	Y+6, r25	; 0x06
     760:	af 83       	std	Y+7, r26	; 0x07
     762:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     764:	19 86       	std	Y+9, r1	; 0x09
     766:	1a 86       	std	Y+10, r1	; 0x0a
     768:	1b 86       	std	Y+11, r1	; 0x0b
     76a:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     772:	80 e0       	ldi	r24, 0x00	; 0
     774:	92 e0       	ldi	r25, 0x02	; 2
     776:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     77a:	80 e0       	ldi	r24, 0x00	; 0
     77c:	92 e0       	ldi	r25, 0x02	; 2
     77e:	20 e0       	ldi	r18, 0x00	; 0
     780:	32 e0       	ldi	r19, 0x02	; 2
     782:	f9 01       	movw	r30, r18
     784:	21 81       	ldd	r18, Z+1	; 0x01
     786:	29 7e       	andi	r18, 0xE9	; 233
     788:	fc 01       	movw	r30, r24
     78a:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	92 e0       	ldi	r25, 0x02	; 2
     790:	20 e0       	ldi	r18, 0x00	; 0
     792:	32 e0       	ldi	r19, 0x02	; 2
     794:	f9 01       	movw	r30, r18
     796:	24 81       	ldd	r18, Z+4	; 0x04
     798:	28 7f       	andi	r18, 0xF8	; 248
     79a:	23 60       	ori	r18, 0x03	; 3
     79c:	fc 01       	movw	r30, r24
     79e:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	92 e0       	ldi	r25, 0x02	; 2
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	32 e0       	ldi	r19, 0x02	; 2
     7a8:	f9 01       	movw	r30, r18
     7aa:	22 81       	ldd	r18, Z+2	; 0x02
     7ac:	2f 7c       	andi	r18, 0xCF	; 207
     7ae:	fc 01       	movw	r30, r24
     7b0:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     7b2:	80 e2       	ldi	r24, 0x20	; 32
     7b4:	92 e0       	ldi	r25, 0x02	; 2
     7b6:	20 e2       	ldi	r18, 0x20	; 32
     7b8:	32 e0       	ldi	r19, 0x02	; 2
     7ba:	f9 01       	movw	r30, r18
     7bc:	20 81       	ld	r18, Z
     7be:	20 7e       	andi	r18, 0xE0	; 224
     7c0:	21 60       	ori	r18, 0x01	; 1
     7c2:	fc 01       	movw	r30, r24
     7c4:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     7c6:	80 e2       	ldi	r24, 0x20	; 32
     7c8:	92 e0       	ldi	r25, 0x02	; 2
     7ca:	29 e0       	ldi	r18, 0x09	; 9
     7cc:	fc 01       	movw	r30, r24
     7ce:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     7d0:	80 e0       	ldi	r24, 0x00	; 0
     7d2:	92 e0       	ldi	r25, 0x02	; 2
     7d4:	20 e0       	ldi	r18, 0x00	; 0
     7d6:	32 e0       	ldi	r19, 0x02	; 2
     7d8:	f9 01       	movw	r30, r18
     7da:	20 81       	ld	r18, Z
     7dc:	21 60       	ori	r18, 0x01	; 1
     7de:	fc 01       	movw	r30, r24
     7e0:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     7e2:	80 e0       	ldi	r24, 0x00	; 0
     7e4:	92 e0       	ldi	r25, 0x02	; 2
     7e6:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     7ea:	80 e0       	ldi	r24, 0x00	; 0
     7ec:	92 e0       	ldi	r25, 0x02	; 2
     7ee:	60 e2       	ldi	r22, 0x20	; 32
     7f0:	72 e0       	ldi	r23, 0x02	; 2
     7f2:	40 e0       	ldi	r20, 0x00	; 0
     7f4:	0e 94 0c 1e 	call	0x3c18	; 0x3c18 <ADC_Offset_Get_Unsigned>
     7f8:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	92 e0       	ldi	r25, 0x02	; 2
     7fe:	20 e0       	ldi	r18, 0x00	; 0
     800:	32 e0       	ldi	r19, 0x02	; 2
     802:	f9 01       	movw	r30, r18
     804:	20 81       	ld	r18, Z
     806:	2e 7f       	andi	r18, 0xFE	; 254
     808:	fc 01       	movw	r30, r24
     80a:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     80c:	80 e2       	ldi	r24, 0x20	; 32
     80e:	92 e0       	ldi	r25, 0x02	; 2
     810:	fc 01       	movw	r30, r24
     812:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	92 e0       	ldi	r25, 0x02	; 2
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	32 e0       	ldi	r19, 0x02	; 2
     81c:	f9 01       	movw	r30, r18
     81e:	23 81       	ldd	r18, Z+3	; 0x03
     820:	2f 73       	andi	r18, 0x3F	; 63
     822:	fc 01       	movw	r30, r24
     824:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     826:	80 e0       	ldi	r24, 0x00	; 0
     828:	92 e0       	ldi	r25, 0x02	; 2
     82a:	20 e0       	ldi	r18, 0x00	; 0
     82c:	32 e0       	ldi	r19, 0x02	; 2
     82e:	f9 01       	movw	r30, r18
     830:	20 81       	ld	r18, Z
     832:	21 60       	ori	r18, 0x01	; 1
     834:	fc 01       	movw	r30, r24
     836:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	92 e0       	ldi	r25, 0x02	; 2
     83c:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     840:	80 e0       	ldi	r24, 0x00	; 0
     842:	92 e0       	ldi	r25, 0x02	; 2
     844:	20 e0       	ldi	r18, 0x00	; 0
     846:	32 e0       	ldi	r19, 0x02	; 2
     848:	f9 01       	movw	r30, r18
     84a:	21 81       	ldd	r18, Z+1	; 0x01
     84c:	28 60       	ori	r18, 0x08	; 8
     84e:	fc 01       	movw	r30, r24
     850:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     852:	1d 86       	std	Y+13, r1	; 0x0d
     854:	1e 86       	std	Y+14, r1	; 0x0e
     856:	56 c0       	rjmp	.+172    	; 0x904 <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     858:	80 e2       	ldi	r24, 0x20	; 32
     85a:	92 e0       	ldi	r25, 0x02	; 2
     85c:	fc 01       	movw	r30, r24
     85e:	83 81       	ldd	r24, Z+3	; 0x03
     860:	88 2f       	mov	r24, r24
     862:	90 e0       	ldi	r25, 0x00	; 0
     864:	81 70       	andi	r24, 0x01	; 1
     866:	90 70       	andi	r25, 0x00	; 0
     868:	00 97       	sbiw	r24, 0x00	; 0
     86a:	b1 f3       	breq	.-20     	; 0x858 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     86c:	2d 89       	ldd	r18, Y+21	; 0x15
     86e:	80 e2       	ldi	r24, 0x20	; 32
     870:	92 e0       	ldi	r25, 0x02	; 2
     872:	62 2f       	mov	r22, r18
     874:	0e 94 b6 1b 	call	0x376c	; 0x376c <ADC_ResultCh_GetWord_Signed>
     878:	8f 87       	std	Y+15, r24	; 0x0f
     87a:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     87c:	8f 85       	ldd	r24, Y+15	; 0x0f
     87e:	98 89       	ldd	r25, Y+16	; 0x10
     880:	cc 01       	movw	r24, r24
     882:	a0 e0       	ldi	r26, 0x00	; 0
     884:	b0 e0       	ldi	r27, 0x00	; 0
     886:	29 81       	ldd	r18, Y+1	; 0x01
     888:	3a 81       	ldd	r19, Y+2	; 0x02
     88a:	4b 81       	ldd	r20, Y+3	; 0x03
     88c:	5c 81       	ldd	r21, Y+4	; 0x04
     88e:	82 0f       	add	r24, r18
     890:	93 1f       	adc	r25, r19
     892:	a4 1f       	adc	r26, r20
     894:	b5 1f       	adc	r27, r21
     896:	89 83       	std	Y+1, r24	; 0x01
     898:	9a 83       	std	Y+2, r25	; 0x02
     89a:	ab 83       	std	Y+3, r26	; 0x03
     89c:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     89e:	8f 85       	ldd	r24, Y+15	; 0x0f
     8a0:	98 89       	ldd	r25, Y+16	; 0x10
     8a2:	9c 01       	movw	r18, r24
     8a4:	40 e0       	ldi	r20, 0x00	; 0
     8a6:	50 e0       	ldi	r21, 0x00	; 0
     8a8:	89 85       	ldd	r24, Y+9	; 0x09
     8aa:	9a 85       	ldd	r25, Y+10	; 0x0a
     8ac:	ab 85       	ldd	r26, Y+11	; 0x0b
     8ae:	bc 85       	ldd	r27, Y+12	; 0x0c
     8b0:	82 17       	cp	r24, r18
     8b2:	93 07       	cpc	r25, r19
     8b4:	a4 07       	cpc	r26, r20
     8b6:	b5 07       	cpc	r27, r21
     8b8:	48 f4       	brcc	.+18     	; 0x8cc <CO_collectTemp+0x19a>
     8ba:	8f 85       	ldd	r24, Y+15	; 0x0f
     8bc:	98 89       	ldd	r25, Y+16	; 0x10
     8be:	cc 01       	movw	r24, r24
     8c0:	a0 e0       	ldi	r26, 0x00	; 0
     8c2:	b0 e0       	ldi	r27, 0x00	; 0
     8c4:	89 87       	std	Y+9, r24	; 0x09
     8c6:	9a 87       	std	Y+10, r25	; 0x0a
     8c8:	ab 87       	std	Y+11, r26	; 0x0b
     8ca:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     8cc:	8f 85       	ldd	r24, Y+15	; 0x0f
     8ce:	98 89       	ldd	r25, Y+16	; 0x10
     8d0:	9c 01       	movw	r18, r24
     8d2:	40 e0       	ldi	r20, 0x00	; 0
     8d4:	50 e0       	ldi	r21, 0x00	; 0
     8d6:	8d 81       	ldd	r24, Y+5	; 0x05
     8d8:	9e 81       	ldd	r25, Y+6	; 0x06
     8da:	af 81       	ldd	r26, Y+7	; 0x07
     8dc:	b8 85       	ldd	r27, Y+8	; 0x08
     8de:	28 17       	cp	r18, r24
     8e0:	39 07       	cpc	r19, r25
     8e2:	4a 07       	cpc	r20, r26
     8e4:	5b 07       	cpc	r21, r27
     8e6:	48 f4       	brcc	.+18     	; 0x8fa <CO_collectTemp+0x1c8>
     8e8:	8f 85       	ldd	r24, Y+15	; 0x0f
     8ea:	98 89       	ldd	r25, Y+16	; 0x10
     8ec:	cc 01       	movw	r24, r24
     8ee:	a0 e0       	ldi	r26, 0x00	; 0
     8f0:	b0 e0       	ldi	r27, 0x00	; 0
     8f2:	8d 83       	std	Y+5, r24	; 0x05
     8f4:	9e 83       	std	Y+6, r25	; 0x06
     8f6:	af 83       	std	Y+7, r26	; 0x07
     8f8:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     8fa:	8d 85       	ldd	r24, Y+13	; 0x0d
     8fc:	9e 85       	ldd	r25, Y+14	; 0x0e
     8fe:	01 96       	adiw	r24, 0x01	; 1
     900:	8d 87       	std	Y+13, r24	; 0x0d
     902:	9e 87       	std	Y+14, r25	; 0x0e
     904:	8d 85       	ldd	r24, Y+13	; 0x0d
     906:	9e 85       	ldd	r25, Y+14	; 0x0e
     908:	f4 e0       	ldi	r31, 0x04	; 4
     90a:	80 30       	cpi	r24, 0x00	; 0
     90c:	9f 07       	cpc	r25, r31
     90e:	08 f4       	brcc	.+2      	; 0x912 <CO_collectTemp+0x1e0>
     910:	a3 cf       	rjmp	.-186    	; 0x858 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     912:	80 e0       	ldi	r24, 0x00	; 0
     914:	92 e0       	ldi	r25, 0x02	; 2
     916:	20 e0       	ldi	r18, 0x00	; 0
     918:	32 e0       	ldi	r19, 0x02	; 2
     91a:	f9 01       	movw	r30, r18
     91c:	21 81       	ldd	r18, Z+1	; 0x01
     91e:	27 7f       	andi	r18, 0xF7	; 247
     920:	fc 01       	movw	r30, r24
     922:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     924:	80 e0       	ldi	r24, 0x00	; 0
     926:	92 e0       	ldi	r25, 0x02	; 2
     928:	20 e0       	ldi	r18, 0x00	; 0
     92a:	32 e0       	ldi	r19, 0x02	; 2
     92c:	f9 01       	movw	r30, r18
     92e:	20 81       	ld	r18, Z
     930:	22 60       	ori	r18, 0x02	; 2
     932:	fc 01       	movw	r30, r24
     934:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     936:	80 e0       	ldi	r24, 0x00	; 0
     938:	92 e0       	ldi	r25, 0x02	; 2
     93a:	20 e0       	ldi	r18, 0x00	; 0
     93c:	32 e0       	ldi	r19, 0x02	; 2
     93e:	f9 01       	movw	r30, r18
     940:	20 81       	ld	r18, Z
     942:	2e 7f       	andi	r18, 0xFE	; 254
     944:	fc 01       	movw	r30, r24
     946:	20 83       	st	Z, r18

	ADCPower(FALSE);
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>

	average = sum / NUM_SAMPLES;
     94e:	89 81       	ldd	r24, Y+1	; 0x01
     950:	9a 81       	ldd	r25, Y+2	; 0x02
     952:	ab 81       	ldd	r26, Y+3	; 0x03
     954:	bc 81       	ldd	r27, Y+4	; 0x04
     956:	07 2e       	mov	r0, r23
     958:	7a e0       	ldi	r23, 0x0A	; 10
     95a:	b6 95       	lsr	r27
     95c:	a7 95       	ror	r26
     95e:	97 95       	ror	r25
     960:	87 95       	ror	r24
     962:	7a 95       	dec	r23
     964:	d1 f7       	brne	.-12     	; 0x95a <CO_collectTemp+0x228>
     966:	70 2d       	mov	r23, r0
     968:	89 8b       	std	Y+17, r24	; 0x11
     96a:	9a 8b       	std	Y+18, r25	; 0x12
     96c:	ab 8b       	std	Y+19, r26	; 0x13
     96e:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     970:	89 89       	ldd	r24, Y+17	; 0x11
     972:	9a 89       	ldd	r25, Y+18	; 0x12
     974:	ab 89       	ldd	r26, Y+19	; 0x13
     976:	bc 89       	ldd	r27, Y+20	; 0x14
     978:	28 ee       	ldi	r18, 0xE8	; 232
     97a:	33 e0       	ldi	r19, 0x03	; 3
     97c:	40 e0       	ldi	r20, 0x00	; 0
     97e:	50 e0       	ldi	r21, 0x00	; 0
     980:	bc 01       	movw	r22, r24
     982:	cd 01       	movw	r24, r26
     984:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
     988:	dc 01       	movw	r26, r24
     98a:	cb 01       	movw	r24, r22
     98c:	2f ef       	ldi	r18, 0xFF	; 255
     98e:	3f e0       	ldi	r19, 0x0F	; 15
     990:	40 e0       	ldi	r20, 0x00	; 0
     992:	50 e0       	ldi	r21, 0x00	; 0
     994:	bc 01       	movw	r22, r24
     996:	cd 01       	movw	r24, r26
     998:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
     99c:	da 01       	movw	r26, r20
     99e:	c9 01       	movw	r24, r18
     9a0:	9c 01       	movw	r18, r24
     9a2:	22 53       	subi	r18, 0x32	; 50
     9a4:	30 40       	sbci	r19, 0x00	; 0
     9a6:	8e 89       	ldd	r24, Y+22	; 0x16
     9a8:	9f 89       	ldd	r25, Y+23	; 0x17
     9aa:	fc 01       	movw	r30, r24
     9ac:	20 83       	st	Z, r18
     9ae:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     9b0:	89 85       	ldd	r24, Y+9	; 0x09
     9b2:	9a 85       	ldd	r25, Y+10	; 0x0a
     9b4:	ab 85       	ldd	r26, Y+11	; 0x0b
     9b6:	bc 85       	ldd	r27, Y+12	; 0x0c
     9b8:	28 ee       	ldi	r18, 0xE8	; 232
     9ba:	33 e0       	ldi	r19, 0x03	; 3
     9bc:	40 e0       	ldi	r20, 0x00	; 0
     9be:	50 e0       	ldi	r21, 0x00	; 0
     9c0:	bc 01       	movw	r22, r24
     9c2:	cd 01       	movw	r24, r26
     9c4:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
     9c8:	dc 01       	movw	r26, r24
     9ca:	cb 01       	movw	r24, r22
     9cc:	2f ef       	ldi	r18, 0xFF	; 255
     9ce:	3f e0       	ldi	r19, 0x0F	; 15
     9d0:	40 e0       	ldi	r20, 0x00	; 0
     9d2:	50 e0       	ldi	r21, 0x00	; 0
     9d4:	bc 01       	movw	r22, r24
     9d6:	cd 01       	movw	r24, r26
     9d8:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
     9dc:	da 01       	movw	r26, r20
     9de:	c9 01       	movw	r24, r18
     9e0:	9c 01       	movw	r18, r24
     9e2:	22 53       	subi	r18, 0x32	; 50
     9e4:	30 40       	sbci	r19, 0x00	; 0
     9e6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     9e8:	9b 8d       	ldd	r25, Y+27	; 0x1b
     9ea:	fc 01       	movw	r30, r24
     9ec:	20 83       	st	Z, r18
     9ee:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     9f0:	8d 81       	ldd	r24, Y+5	; 0x05
     9f2:	9e 81       	ldd	r25, Y+6	; 0x06
     9f4:	af 81       	ldd	r26, Y+7	; 0x07
     9f6:	b8 85       	ldd	r27, Y+8	; 0x08
     9f8:	28 ee       	ldi	r18, 0xE8	; 232
     9fa:	33 e0       	ldi	r19, 0x03	; 3
     9fc:	40 e0       	ldi	r20, 0x00	; 0
     9fe:	50 e0       	ldi	r21, 0x00	; 0
     a00:	bc 01       	movw	r22, r24
     a02:	cd 01       	movw	r24, r26
     a04:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
     a08:	dc 01       	movw	r26, r24
     a0a:	cb 01       	movw	r24, r22
     a0c:	2f ef       	ldi	r18, 0xFF	; 255
     a0e:	3f e0       	ldi	r19, 0x0F	; 15
     a10:	40 e0       	ldi	r20, 0x00	; 0
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	bc 01       	movw	r22, r24
     a16:	cd 01       	movw	r24, r26
     a18:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	9c 01       	movw	r18, r24
     a22:	22 53       	subi	r18, 0x32	; 50
     a24:	30 40       	sbci	r19, 0x00	; 0
     a26:	88 8d       	ldd	r24, Y+24	; 0x18
     a28:	99 8d       	ldd	r25, Y+25	; 0x19
     a2a:	fc 01       	movw	r30, r24
     a2c:	20 83       	st	Z, r18
     a2e:	31 83       	std	Z+1, r19	; 0x01
}
     a30:	6b 96       	adiw	r28, 0x1b	; 27
     a32:	cd bf       	out	0x3d, r28	; 61
     a34:	de bf       	out	0x3e, r29	; 62
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	08 95       	ret

00000a3c <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     a3c:	0f 93       	push	r16
     a3e:	1f 93       	push	r17
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	cd b7       	in	r28, 0x3d	; 61
     a46:	de b7       	in	r29, 0x3e	; 62
     a48:	a9 97       	sbiw	r28, 0x29	; 41
     a4a:	cd bf       	out	0x3d, r28	; 61
     a4c:	de bf       	out	0x3e, r29	; 62
     a4e:	8c a3       	lds	r24, 0x5c
     a50:	9d a3       	lds	r25, 0x5d
     a52:	6e a3       	lds	r22, 0x5e
     a54:	7f a3       	lds	r23, 0x5f
     a56:	48 a7       	lds	r20, 0x78
     a58:	59 a7       	lds	r21, 0x79
	
	uint32_t sum = 0;
     a5a:	19 82       	std	Y+1, r1	; 0x01
     a5c:	1a 82       	std	Y+2, r1	; 0x02
     a5e:	1b 82       	std	Y+3, r1	; 0x03
     a60:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	90 e1       	ldi	r25, 0x10	; 16
     a66:	a0 e0       	ldi	r26, 0x00	; 0
     a68:	b0 e0       	ldi	r27, 0x00	; 0
     a6a:	8d 83       	std	Y+5, r24	; 0x05
     a6c:	9e 83       	std	Y+6, r25	; 0x06
     a6e:	af 83       	std	Y+7, r26	; 0x07
     a70:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     a72:	19 86       	std	Y+9, r1	; 0x09
     a74:	1a 86       	std	Y+10, r1	; 0x0a
     a76:	1b 86       	std	Y+11, r1	; 0x0b
     a78:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     a80:	84 e0       	ldi	r24, 0x04	; 4
     a82:	60 e0       	ldi	r22, 0x00	; 0
     a84:	0e 94 d7 33 	call	0x67ae	; 0x67ae <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     a88:	84 e0       	ldi	r24, 0x04	; 4
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
     a90:	80 e0       	ldi	r24, 0x00	; 0
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	a8 ec       	ldi	r26, 0xC8	; 200
     a96:	b2 e4       	ldi	r27, 0x42	; 66
     a98:	8d 8b       	std	Y+21, r24	; 0x15
     a9a:	9e 8b       	std	Y+22, r25	; 0x16
     a9c:	af 8b       	std	Y+23, r26	; 0x17
     a9e:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     aa0:	6d 89       	ldd	r22, Y+21	; 0x15
     aa2:	7e 89       	ldd	r23, Y+22	; 0x16
     aa4:	8f 89       	ldd	r24, Y+23	; 0x17
     aa6:	98 8d       	ldd	r25, Y+24	; 0x18
     aa8:	20 e0       	ldi	r18, 0x00	; 0
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	4a ef       	ldi	r20, 0xFA	; 250
     aae:	55 e4       	ldi	r21, 0x45	; 69
     ab0:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
     ab4:	dc 01       	movw	r26, r24
     ab6:	cb 01       	movw	r24, r22
     ab8:	89 8f       	std	Y+25, r24	; 0x19
     aba:	9a 8f       	std	Y+26, r25	; 0x1a
     abc:	ab 8f       	std	Y+27, r26	; 0x1b
     abe:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     ac0:	11 e0       	ldi	r17, 0x01	; 1
     ac2:	69 8d       	ldd	r22, Y+25	; 0x19
     ac4:	7a 8d       	ldd	r23, Y+26	; 0x1a
     ac6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ac8:	9c 8d       	ldd	r25, Y+28	; 0x1c
     aca:	20 e0       	ldi	r18, 0x00	; 0
     acc:	30 e0       	ldi	r19, 0x00	; 0
     ace:	40 e8       	ldi	r20, 0x80	; 128
     ad0:	5f e3       	ldi	r21, 0x3F	; 63
     ad2:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
     ad6:	88 23       	and	r24, r24
     ad8:	0c f0       	brlt	.+2      	; 0xadc <CO_collectBatt+0xa0>
     ada:	10 e0       	ldi	r17, 0x00	; 0
     adc:	11 23       	and	r17, r17
     ade:	29 f0       	breq	.+10     	; 0xaea <CO_collectBatt+0xae>
		__ticks = 1;
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	8d 8f       	std	Y+29, r24	; 0x1d
     ae6:	9e 8f       	std	Y+30, r25	; 0x1e
     ae8:	46 c0       	rjmp	.+140    	; 0xb76 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     aea:	11 e0       	ldi	r17, 0x01	; 1
     aec:	69 8d       	ldd	r22, Y+25	; 0x19
     aee:	7a 8d       	ldd	r23, Y+26	; 0x1a
     af0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     af2:	9c 8d       	ldd	r25, Y+28	; 0x1c
     af4:	20 e0       	ldi	r18, 0x00	; 0
     af6:	3f ef       	ldi	r19, 0xFF	; 255
     af8:	4f e7       	ldi	r20, 0x7F	; 127
     afa:	57 e4       	ldi	r21, 0x47	; 71
     afc:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
     b00:	18 16       	cp	r1, r24
     b02:	0c f0       	brlt	.+2      	; 0xb06 <CO_collectBatt+0xca>
     b04:	10 e0       	ldi	r17, 0x00	; 0
     b06:	11 23       	and	r17, r17
     b08:	61 f1       	breq	.+88     	; 0xb62 <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     b0a:	6d 89       	ldd	r22, Y+21	; 0x15
     b0c:	7e 89       	ldd	r23, Y+22	; 0x16
     b0e:	8f 89       	ldd	r24, Y+23	; 0x17
     b10:	98 8d       	ldd	r25, Y+24	; 0x18
     b12:	20 e0       	ldi	r18, 0x00	; 0
     b14:	30 e0       	ldi	r19, 0x00	; 0
     b16:	40 e2       	ldi	r20, 0x20	; 32
     b18:	51 e4       	ldi	r21, 0x41	; 65
     b1a:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
     b1e:	dc 01       	movw	r26, r24
     b20:	cb 01       	movw	r24, r22
     b22:	bc 01       	movw	r22, r24
     b24:	cd 01       	movw	r24, r26
     b26:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
     b2a:	dc 01       	movw	r26, r24
     b2c:	cb 01       	movw	r24, r22
     b2e:	8d 8f       	std	Y+29, r24	; 0x1d
     b30:	9e 8f       	std	Y+30, r25	; 0x1e
     b32:	12 c0       	rjmp	.+36     	; 0xb58 <CO_collectBatt+0x11c>
     b34:	80 e2       	ldi	r24, 0x20	; 32
     b36:	93 e0       	ldi	r25, 0x03	; 3
     b38:	8f 8f       	std	Y+31, r24	; 0x1f
     b3a:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     b3c:	8f 8d       	ldd	r24, Y+31	; 0x1f
     b3e:	98 a1       	lds	r25, 0x48
     b40:	8c 01       	movw	r16, r24
     b42:	c8 01       	movw	r24, r16
     b44:	01 97       	sbiw	r24, 0x01	; 1
     b46:	f1 f7       	brne	.-4      	; 0xb44 <CO_collectBatt+0x108>
     b48:	8c 01       	movw	r16, r24
     b4a:	0f 8f       	std	Y+31, r16	; 0x1f
     b4c:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     b4e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b50:	9e 8d       	ldd	r25, Y+30	; 0x1e
     b52:	01 97       	sbiw	r24, 0x01	; 1
     b54:	8d 8f       	std	Y+29, r24	; 0x1d
     b56:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     b58:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b5a:	9e 8d       	ldd	r25, Y+30	; 0x1e
     b5c:	00 97       	sbiw	r24, 0x00	; 0
     b5e:	51 f7       	brne	.-44     	; 0xb34 <CO_collectBatt+0xf8>
     b60:	17 c0       	rjmp	.+46     	; 0xb90 <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     b62:	69 8d       	ldd	r22, Y+25	; 0x19
     b64:	7a 8d       	ldd	r23, Y+26	; 0x1a
     b66:	8b 8d       	ldd	r24, Y+27	; 0x1b
     b68:	9c 8d       	ldd	r25, Y+28	; 0x1c
     b6a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
     b6e:	dc 01       	movw	r26, r24
     b70:	cb 01       	movw	r24, r22
     b72:	8d 8f       	std	Y+29, r24	; 0x1d
     b74:	9e 8f       	std	Y+30, r25	; 0x1e
     b76:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b78:	9e 8d       	ldd	r25, Y+30	; 0x1e
     b7a:	89 a3       	lds	r24, 0x59
     b7c:	9a a3       	lds	r25, 0x5a
     b7e:	89 a1       	lds	r24, 0x49
     b80:	9a a1       	lds	r25, 0x4a
     b82:	8c 01       	movw	r16, r24
     b84:	f8 01       	movw	r30, r16
     b86:	31 97       	sbiw	r30, 0x01	; 1
     b88:	f1 f7       	brne	.-4      	; 0xb86 <CO_collectBatt+0x14a>
     b8a:	8f 01       	movw	r16, r30
     b8c:	09 a3       	lds	r16, 0x59
     b8e:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     b90:	80 e4       	ldi	r24, 0x40	; 64
     b92:	92 e0       	ldi	r25, 0x02	; 2
     b94:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     b98:	80 e4       	ldi	r24, 0x40	; 64
     b9a:	92 e0       	ldi	r25, 0x02	; 2
     b9c:	20 e4       	ldi	r18, 0x40	; 64
     b9e:	32 e0       	ldi	r19, 0x02	; 2
     ba0:	f9 01       	movw	r30, r18
     ba2:	21 81       	ldd	r18, Z+1	; 0x01
     ba4:	29 7e       	andi	r18, 0xE9	; 233
     ba6:	fc 01       	movw	r30, r24
     ba8:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     baa:	80 e4       	ldi	r24, 0x40	; 64
     bac:	92 e0       	ldi	r25, 0x02	; 2
     bae:	20 e4       	ldi	r18, 0x40	; 64
     bb0:	32 e0       	ldi	r19, 0x02	; 2
     bb2:	f9 01       	movw	r30, r18
     bb4:	24 81       	ldd	r18, Z+4	; 0x04
     bb6:	28 7f       	andi	r18, 0xF8	; 248
     bb8:	23 60       	ori	r18, 0x03	; 3
     bba:	fc 01       	movw	r30, r24
     bbc:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     bbe:	80 e4       	ldi	r24, 0x40	; 64
     bc0:	92 e0       	ldi	r25, 0x02	; 2
     bc2:	20 e4       	ldi	r18, 0x40	; 64
     bc4:	32 e0       	ldi	r19, 0x02	; 2
     bc6:	f9 01       	movw	r30, r18
     bc8:	22 81       	ldd	r18, Z+2	; 0x02
     bca:	2f 7c       	andi	r18, 0xCF	; 207
     bcc:	fc 01       	movw	r30, r24
     bce:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     bd0:	80 e6       	ldi	r24, 0x60	; 96
     bd2:	92 e0       	ldi	r25, 0x02	; 2
     bd4:	20 e6       	ldi	r18, 0x60	; 96
     bd6:	32 e0       	ldi	r19, 0x02	; 2
     bd8:	f9 01       	movw	r30, r18
     bda:	20 81       	ld	r18, Z
     bdc:	20 7e       	andi	r18, 0xE0	; 224
     bde:	21 60       	ori	r18, 0x01	; 1
     be0:	fc 01       	movw	r30, r24
     be2:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     be4:	80 e6       	ldi	r24, 0x60	; 96
     be6:	92 e0       	ldi	r25, 0x02	; 2
     be8:	29 e0       	ldi	r18, 0x09	; 9
     bea:	fc 01       	movw	r30, r24
     bec:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     bee:	80 e4       	ldi	r24, 0x40	; 64
     bf0:	92 e0       	ldi	r25, 0x02	; 2
     bf2:	20 e4       	ldi	r18, 0x40	; 64
     bf4:	32 e0       	ldi	r19, 0x02	; 2
     bf6:	f9 01       	movw	r30, r18
     bf8:	20 81       	ld	r18, Z
     bfa:	21 60       	ori	r18, 0x01	; 1
     bfc:	fc 01       	movw	r30, r24
     bfe:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     c00:	80 e4       	ldi	r24, 0x40	; 64
     c02:	92 e0       	ldi	r25, 0x02	; 2
     c04:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     c08:	80 e4       	ldi	r24, 0x40	; 64
     c0a:	92 e0       	ldi	r25, 0x02	; 2
     c0c:	60 e6       	ldi	r22, 0x60	; 96
     c0e:	72 e0       	ldi	r23, 0x02	; 2
     c10:	40 e0       	ldi	r20, 0x00	; 0
     c12:	0e 94 0c 1e 	call	0x3c18	; 0x3c18 <ADC_Offset_Get_Unsigned>
     c16:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     c18:	80 e4       	ldi	r24, 0x40	; 64
     c1a:	92 e0       	ldi	r25, 0x02	; 2
     c1c:	20 e4       	ldi	r18, 0x40	; 64
     c1e:	32 e0       	ldi	r19, 0x02	; 2
     c20:	f9 01       	movw	r30, r18
     c22:	20 81       	ld	r18, Z
     c24:	2e 7f       	andi	r18, 0xFE	; 254
     c26:	fc 01       	movw	r30, r24
     c28:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     c2a:	80 e6       	ldi	r24, 0x60	; 96
     c2c:	92 e0       	ldi	r25, 0x02	; 2
     c2e:	fc 01       	movw	r30, r24
     c30:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     c32:	80 e4       	ldi	r24, 0x40	; 64
     c34:	92 e0       	ldi	r25, 0x02	; 2
     c36:	20 e4       	ldi	r18, 0x40	; 64
     c38:	32 e0       	ldi	r19, 0x02	; 2
     c3a:	f9 01       	movw	r30, r18
     c3c:	23 81       	ldd	r18, Z+3	; 0x03
     c3e:	2f 73       	andi	r18, 0x3F	; 63
     c40:	fc 01       	movw	r30, r24
     c42:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     c44:	80 e4       	ldi	r24, 0x40	; 64
     c46:	92 e0       	ldi	r25, 0x02	; 2
     c48:	20 e4       	ldi	r18, 0x40	; 64
     c4a:	32 e0       	ldi	r19, 0x02	; 2
     c4c:	f9 01       	movw	r30, r18
     c4e:	20 81       	ld	r18, Z
     c50:	21 60       	ori	r18, 0x01	; 1
     c52:	fc 01       	movw	r30, r24
     c54:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     c56:	80 e4       	ldi	r24, 0x40	; 64
     c58:	92 e0       	ldi	r25, 0x02	; 2
     c5a:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     c5e:	80 e4       	ldi	r24, 0x40	; 64
     c60:	92 e0       	ldi	r25, 0x02	; 2
     c62:	20 e4       	ldi	r18, 0x40	; 64
     c64:	32 e0       	ldi	r19, 0x02	; 2
     c66:	f9 01       	movw	r30, r18
     c68:	21 81       	ldd	r18, Z+1	; 0x01
     c6a:	28 60       	ori	r18, 0x08	; 8
     c6c:	fc 01       	movw	r30, r24
     c6e:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     c70:	1d 86       	std	Y+13, r1	; 0x0d
     c72:	1e 86       	std	Y+14, r1	; 0x0e
     c74:	56 c0       	rjmp	.+172    	; 0xd22 <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     c76:	80 e6       	ldi	r24, 0x60	; 96
     c78:	92 e0       	ldi	r25, 0x02	; 2
     c7a:	fc 01       	movw	r30, r24
     c7c:	83 81       	ldd	r24, Z+3	; 0x03
     c7e:	88 2f       	mov	r24, r24
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	81 70       	andi	r24, 0x01	; 1
     c84:	90 70       	andi	r25, 0x00	; 0
     c86:	00 97       	sbiw	r24, 0x00	; 0
     c88:	b1 f3       	breq	.-20     	; 0xc76 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     c8a:	2b a1       	lds	r18, 0x4b
     c8c:	80 e6       	ldi	r24, 0x60	; 96
     c8e:	92 e0       	ldi	r25, 0x02	; 2
     c90:	62 2f       	mov	r22, r18
     c92:	0e 94 b6 1b 	call	0x376c	; 0x376c <ADC_ResultCh_GetWord_Signed>
     c96:	8f 87       	std	Y+15, r24	; 0x0f
     c98:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     c9a:	8f 85       	ldd	r24, Y+15	; 0x0f
     c9c:	98 89       	ldd	r25, Y+16	; 0x10
     c9e:	cc 01       	movw	r24, r24
     ca0:	a0 e0       	ldi	r26, 0x00	; 0
     ca2:	b0 e0       	ldi	r27, 0x00	; 0
     ca4:	29 81       	ldd	r18, Y+1	; 0x01
     ca6:	3a 81       	ldd	r19, Y+2	; 0x02
     ca8:	4b 81       	ldd	r20, Y+3	; 0x03
     caa:	5c 81       	ldd	r21, Y+4	; 0x04
     cac:	82 0f       	add	r24, r18
     cae:	93 1f       	adc	r25, r19
     cb0:	a4 1f       	adc	r26, r20
     cb2:	b5 1f       	adc	r27, r21
     cb4:	89 83       	std	Y+1, r24	; 0x01
     cb6:	9a 83       	std	Y+2, r25	; 0x02
     cb8:	ab 83       	std	Y+3, r26	; 0x03
     cba:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     cbc:	8f 85       	ldd	r24, Y+15	; 0x0f
     cbe:	98 89       	ldd	r25, Y+16	; 0x10
     cc0:	9c 01       	movw	r18, r24
     cc2:	40 e0       	ldi	r20, 0x00	; 0
     cc4:	50 e0       	ldi	r21, 0x00	; 0
     cc6:	89 85       	ldd	r24, Y+9	; 0x09
     cc8:	9a 85       	ldd	r25, Y+10	; 0x0a
     cca:	ab 85       	ldd	r26, Y+11	; 0x0b
     ccc:	bc 85       	ldd	r27, Y+12	; 0x0c
     cce:	82 17       	cp	r24, r18
     cd0:	93 07       	cpc	r25, r19
     cd2:	a4 07       	cpc	r26, r20
     cd4:	b5 07       	cpc	r27, r21
     cd6:	48 f4       	brcc	.+18     	; 0xcea <CO_collectBatt+0x2ae>
     cd8:	8f 85       	ldd	r24, Y+15	; 0x0f
     cda:	98 89       	ldd	r25, Y+16	; 0x10
     cdc:	cc 01       	movw	r24, r24
     cde:	a0 e0       	ldi	r26, 0x00	; 0
     ce0:	b0 e0       	ldi	r27, 0x00	; 0
     ce2:	89 87       	std	Y+9, r24	; 0x09
     ce4:	9a 87       	std	Y+10, r25	; 0x0a
     ce6:	ab 87       	std	Y+11, r26	; 0x0b
     ce8:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     cea:	8f 85       	ldd	r24, Y+15	; 0x0f
     cec:	98 89       	ldd	r25, Y+16	; 0x10
     cee:	9c 01       	movw	r18, r24
     cf0:	40 e0       	ldi	r20, 0x00	; 0
     cf2:	50 e0       	ldi	r21, 0x00	; 0
     cf4:	8d 81       	ldd	r24, Y+5	; 0x05
     cf6:	9e 81       	ldd	r25, Y+6	; 0x06
     cf8:	af 81       	ldd	r26, Y+7	; 0x07
     cfa:	b8 85       	ldd	r27, Y+8	; 0x08
     cfc:	28 17       	cp	r18, r24
     cfe:	39 07       	cpc	r19, r25
     d00:	4a 07       	cpc	r20, r26
     d02:	5b 07       	cpc	r21, r27
     d04:	48 f4       	brcc	.+18     	; 0xd18 <CO_collectBatt+0x2dc>
     d06:	8f 85       	ldd	r24, Y+15	; 0x0f
     d08:	98 89       	ldd	r25, Y+16	; 0x10
     d0a:	cc 01       	movw	r24, r24
     d0c:	a0 e0       	ldi	r26, 0x00	; 0
     d0e:	b0 e0       	ldi	r27, 0x00	; 0
     d10:	8d 83       	std	Y+5, r24	; 0x05
     d12:	9e 83       	std	Y+6, r25	; 0x06
     d14:	af 83       	std	Y+7, r26	; 0x07
     d16:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     d18:	8d 85       	ldd	r24, Y+13	; 0x0d
     d1a:	9e 85       	ldd	r25, Y+14	; 0x0e
     d1c:	01 96       	adiw	r24, 0x01	; 1
     d1e:	8d 87       	std	Y+13, r24	; 0x0d
     d20:	9e 87       	std	Y+14, r25	; 0x0e
     d22:	8d 85       	ldd	r24, Y+13	; 0x0d
     d24:	9e 85       	ldd	r25, Y+14	; 0x0e
     d26:	f4 e0       	ldi	r31, 0x04	; 4
     d28:	80 30       	cpi	r24, 0x00	; 0
     d2a:	9f 07       	cpc	r25, r31
     d2c:	08 f4       	brcc	.+2      	; 0xd30 <CO_collectBatt+0x2f4>
     d2e:	a3 cf       	rjmp	.-186    	; 0xc76 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     d30:	80 e4       	ldi	r24, 0x40	; 64
     d32:	92 e0       	ldi	r25, 0x02	; 2
     d34:	20 e4       	ldi	r18, 0x40	; 64
     d36:	32 e0       	ldi	r19, 0x02	; 2
     d38:	f9 01       	movw	r30, r18
     d3a:	21 81       	ldd	r18, Z+1	; 0x01
     d3c:	27 7f       	andi	r18, 0xF7	; 247
     d3e:	fc 01       	movw	r30, r24
     d40:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     d42:	80 e4       	ldi	r24, 0x40	; 64
     d44:	92 e0       	ldi	r25, 0x02	; 2
     d46:	20 e4       	ldi	r18, 0x40	; 64
     d48:	32 e0       	ldi	r19, 0x02	; 2
     d4a:	f9 01       	movw	r30, r18
     d4c:	20 81       	ld	r18, Z
     d4e:	2e 7f       	andi	r18, 0xFE	; 254
     d50:	fc 01       	movw	r30, r24
     d52:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     d54:	89 81       	ldd	r24, Y+1	; 0x01
     d56:	9a 81       	ldd	r25, Y+2	; 0x02
     d58:	ab 81       	ldd	r26, Y+3	; 0x03
     d5a:	bc 81       	ldd	r27, Y+4	; 0x04
     d5c:	07 2e       	mov	r0, r23
     d5e:	7a e0       	ldi	r23, 0x0A	; 10
     d60:	b6 95       	lsr	r27
     d62:	a7 95       	ror	r26
     d64:	97 95       	ror	r25
     d66:	87 95       	ror	r24
     d68:	7a 95       	dec	r23
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <CO_collectBatt+0x324>
     d6c:	70 2d       	mov	r23, r0
     d6e:	89 8b       	std	Y+17, r24	; 0x11
     d70:	9a 8b       	std	Y+18, r25	; 0x12
     d72:	ab 8b       	std	Y+19, r26	; 0x13
     d74:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     d76:	84 e0       	ldi	r24, 0x04	; 4
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	0e 94 3b 34 	call	0x6876	; 0x6876 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     d84:	89 89       	ldd	r24, Y+17	; 0x11
     d86:	9a 89       	ldd	r25, Y+18	; 0x12
     d88:	ab 89       	ldd	r26, Y+19	; 0x13
     d8a:	bc 89       	ldd	r27, Y+20	; 0x14
     d8c:	28 ee       	ldi	r18, 0xE8	; 232
     d8e:	33 e0       	ldi	r19, 0x03	; 3
     d90:	40 e0       	ldi	r20, 0x00	; 0
     d92:	50 e0       	ldi	r21, 0x00	; 0
     d94:	bc 01       	movw	r22, r24
     d96:	cd 01       	movw	r24, r26
     d98:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
     d9c:	dc 01       	movw	r26, r24
     d9e:	cb 01       	movw	r24, r22
     da0:	2f ef       	ldi	r18, 0xFF	; 255
     da2:	3f e0       	ldi	r19, 0x0F	; 15
     da4:	40 e0       	ldi	r20, 0x00	; 0
     da6:	50 e0       	ldi	r21, 0x00	; 0
     da8:	bc 01       	movw	r22, r24
     daa:	cd 01       	movw	r24, r26
     dac:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
     db0:	da 01       	movw	r26, r20
     db2:	c9 01       	movw	r24, r18
     db4:	9c 01       	movw	r18, r24
     db6:	22 53       	subi	r18, 0x32	; 50
     db8:	30 40       	sbci	r19, 0x00	; 0
     dba:	8c a1       	lds	r24, 0x4c
     dbc:	9d a1       	lds	r25, 0x4d
     dbe:	fc 01       	movw	r30, r24
     dc0:	20 83       	st	Z, r18
     dc2:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     dc4:	89 85       	ldd	r24, Y+9	; 0x09
     dc6:	9a 85       	ldd	r25, Y+10	; 0x0a
     dc8:	ab 85       	ldd	r26, Y+11	; 0x0b
     dca:	bc 85       	ldd	r27, Y+12	; 0x0c
     dcc:	28 ee       	ldi	r18, 0xE8	; 232
     dce:	33 e0       	ldi	r19, 0x03	; 3
     dd0:	40 e0       	ldi	r20, 0x00	; 0
     dd2:	50 e0       	ldi	r21, 0x00	; 0
     dd4:	bc 01       	movw	r22, r24
     dd6:	cd 01       	movw	r24, r26
     dd8:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
     ddc:	dc 01       	movw	r26, r24
     dde:	cb 01       	movw	r24, r22
     de0:	2f ef       	ldi	r18, 0xFF	; 255
     de2:	3f e0       	ldi	r19, 0x0F	; 15
     de4:	40 e0       	ldi	r20, 0x00	; 0
     de6:	50 e0       	ldi	r21, 0x00	; 0
     de8:	bc 01       	movw	r22, r24
     dea:	cd 01       	movw	r24, r26
     dec:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
     df0:	da 01       	movw	r26, r20
     df2:	c9 01       	movw	r24, r18
     df4:	9c 01       	movw	r18, r24
     df6:	22 53       	subi	r18, 0x32	; 50
     df8:	30 40       	sbci	r19, 0x00	; 0
     dfa:	88 a5       	lds	r24, 0x68
     dfc:	99 a5       	lds	r25, 0x69
     dfe:	fc 01       	movw	r30, r24
     e00:	20 83       	st	Z, r18
     e02:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     e04:	8d 81       	ldd	r24, Y+5	; 0x05
     e06:	9e 81       	ldd	r25, Y+6	; 0x06
     e08:	af 81       	ldd	r26, Y+7	; 0x07
     e0a:	b8 85       	ldd	r27, Y+8	; 0x08
     e0c:	28 ee       	ldi	r18, 0xE8	; 232
     e0e:	33 e0       	ldi	r19, 0x03	; 3
     e10:	40 e0       	ldi	r20, 0x00	; 0
     e12:	50 e0       	ldi	r21, 0x00	; 0
     e14:	bc 01       	movw	r22, r24
     e16:	cd 01       	movw	r24, r26
     e18:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
     e1c:	dc 01       	movw	r26, r24
     e1e:	cb 01       	movw	r24, r22
     e20:	2f ef       	ldi	r18, 0xFF	; 255
     e22:	3f e0       	ldi	r19, 0x0F	; 15
     e24:	40 e0       	ldi	r20, 0x00	; 0
     e26:	50 e0       	ldi	r21, 0x00	; 0
     e28:	bc 01       	movw	r22, r24
     e2a:	cd 01       	movw	r24, r26
     e2c:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
     e30:	da 01       	movw	r26, r20
     e32:	c9 01       	movw	r24, r18
     e34:	9c 01       	movw	r18, r24
     e36:	22 53       	subi	r18, 0x32	; 50
     e38:	30 40       	sbci	r19, 0x00	; 0
     e3a:	8e a1       	lds	r24, 0x4e
     e3c:	9f a1       	lds	r25, 0x4f
     e3e:	fc 01       	movw	r30, r24
     e40:	20 83       	st	Z, r18
     e42:	31 83       	std	Z+1, r19	; 0x01
}
     e44:	a9 96       	adiw	r28, 0x29	; 41
     e46:	cd bf       	out	0x3d, r28	; 61
     e48:	de bf       	out	0x3e, r29	; 62
     e4a:	df 91       	pop	r29
     e4c:	cf 91       	pop	r28
     e4e:	1f 91       	pop	r17
     e50:	0f 91       	pop	r16
     e52:	08 95       	ret

00000e54 <ADCPower>:

void ADCPower(uint8_t on) {
     e54:	0f 93       	push	r16
     e56:	1f 93       	push	r17
     e58:	cf 93       	push	r28
     e5a:	df 93       	push	r29
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
     e60:	2f 97       	sbiw	r28, 0x0f	; 15
     e62:	cd bf       	out	0x3d, r28	; 61
     e64:	de bf       	out	0x3e, r29	; 62
     e66:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
     e68:	8f 85       	ldd	r24, Y+15	; 0x0f
     e6a:	88 23       	and	r24, r24
     e6c:	09 f4       	brne	.+2      	; 0xe70 <ADCPower+0x1c>
     e6e:	ce c0       	rjmp	.+412    	; 0x100c <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     e70:	80 e0       	ldi	r24, 0x00	; 0
     e72:	96 e0       	ldi	r25, 0x06	; 6
     e74:	2e ed       	ldi	r18, 0xDE	; 222
     e76:	fc 01       	movw	r30, r24
     e78:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     e7a:	80 e2       	ldi	r24, 0x20	; 32
     e7c:	96 e0       	ldi	r25, 0x06	; 6
     e7e:	2e e0       	ldi	r18, 0x0E	; 14
     e80:	fc 01       	movw	r30, r24
     e82:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     e84:	80 e4       	ldi	r24, 0x40	; 64
     e86:	96 e0       	ldi	r25, 0x06	; 6
     e88:	23 e0       	ldi	r18, 0x03	; 3
     e8a:	fc 01       	movw	r30, r24
     e8c:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     e8e:	80 e8       	ldi	r24, 0x80	; 128
     e90:	96 e0       	ldi	r25, 0x06	; 6
     e92:	20 e1       	ldi	r18, 0x10	; 16
     e94:	fc 01       	movw	r30, r24
     e96:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     e98:	80 ea       	ldi	r24, 0xA0	; 160
     e9a:	96 e0       	ldi	r25, 0x06	; 6
     e9c:	2e e0       	ldi	r18, 0x0E	; 14
     e9e:	fc 01       	movw	r30, r24
     ea0:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     ea2:	80 e0       	ldi	r24, 0x00	; 0
     ea4:	96 e0       	ldi	r25, 0x06	; 6
     ea6:	2e e9       	ldi	r18, 0x9E	; 158
     ea8:	fc 01       	movw	r30, r24
     eaa:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     eac:	80 e2       	ldi	r24, 0x20	; 32
     eae:	96 e0       	ldi	r25, 0x06	; 6
     eb0:	28 e0       	ldi	r18, 0x08	; 8
     eb2:	fc 01       	movw	r30, r24
     eb4:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     eb6:	80 e4       	ldi	r24, 0x40	; 64
     eb8:	96 e0       	ldi	r25, 0x06	; 6
     eba:	23 e0       	ldi	r18, 0x03	; 3
     ebc:	fc 01       	movw	r30, r24
     ebe:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     ec0:	80 e8       	ldi	r24, 0x80	; 128
     ec2:	96 e0       	ldi	r25, 0x06	; 6
     ec4:	20 e1       	ldi	r18, 0x10	; 16
     ec6:	fc 01       	movw	r30, r24
     ec8:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     eca:	80 ea       	ldi	r24, 0xA0	; 160
     ecc:	96 e0       	ldi	r25, 0x06	; 6
     ece:	2e e0       	ldi	r18, 0x0E	; 14
     ed0:	fc 01       	movw	r30, r24
     ed2:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     ed4:	10 92 72 50 	sts	0x5072, r1
     ed8:	80 e0       	ldi	r24, 0x00	; 0
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	a8 ec       	ldi	r26, 0xC8	; 200
     ede:	b2 e4       	ldi	r27, 0x42	; 66
     ee0:	89 83       	std	Y+1, r24	; 0x01
     ee2:	9a 83       	std	Y+2, r25	; 0x02
     ee4:	ab 83       	std	Y+3, r26	; 0x03
     ee6:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     ee8:	69 81       	ldd	r22, Y+1	; 0x01
     eea:	7a 81       	ldd	r23, Y+2	; 0x02
     eec:	8b 81       	ldd	r24, Y+3	; 0x03
     eee:	9c 81       	ldd	r25, Y+4	; 0x04
     ef0:	20 e0       	ldi	r18, 0x00	; 0
     ef2:	30 e0       	ldi	r19, 0x00	; 0
     ef4:	4a ef       	ldi	r20, 0xFA	; 250
     ef6:	55 e4       	ldi	r21, 0x45	; 69
     ef8:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
     efc:	dc 01       	movw	r26, r24
     efe:	cb 01       	movw	r24, r22
     f00:	8d 83       	std	Y+5, r24	; 0x05
     f02:	9e 83       	std	Y+6, r25	; 0x06
     f04:	af 83       	std	Y+7, r26	; 0x07
     f06:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     f08:	11 e0       	ldi	r17, 0x01	; 1
     f0a:	6d 81       	ldd	r22, Y+5	; 0x05
     f0c:	7e 81       	ldd	r23, Y+6	; 0x06
     f0e:	8f 81       	ldd	r24, Y+7	; 0x07
     f10:	98 85       	ldd	r25, Y+8	; 0x08
     f12:	20 e0       	ldi	r18, 0x00	; 0
     f14:	30 e0       	ldi	r19, 0x00	; 0
     f16:	40 e8       	ldi	r20, 0x80	; 128
     f18:	5f e3       	ldi	r21, 0x3F	; 63
     f1a:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
     f1e:	88 23       	and	r24, r24
     f20:	0c f0       	brlt	.+2      	; 0xf24 <ADCPower+0xd0>
     f22:	10 e0       	ldi	r17, 0x00	; 0
     f24:	11 23       	and	r17, r17
     f26:	29 f0       	breq	.+10     	; 0xf32 <ADCPower+0xde>
		__ticks = 1;
     f28:	81 e0       	ldi	r24, 0x01	; 1
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	89 87       	std	Y+9, r24	; 0x09
     f2e:	9a 87       	std	Y+10, r25	; 0x0a
     f30:	46 c0       	rjmp	.+140    	; 0xfbe <ADCPower+0x16a>
	else if (__tmp > 65535)
     f32:	11 e0       	ldi	r17, 0x01	; 1
     f34:	6d 81       	ldd	r22, Y+5	; 0x05
     f36:	7e 81       	ldd	r23, Y+6	; 0x06
     f38:	8f 81       	ldd	r24, Y+7	; 0x07
     f3a:	98 85       	ldd	r25, Y+8	; 0x08
     f3c:	20 e0       	ldi	r18, 0x00	; 0
     f3e:	3f ef       	ldi	r19, 0xFF	; 255
     f40:	4f e7       	ldi	r20, 0x7F	; 127
     f42:	57 e4       	ldi	r21, 0x47	; 71
     f44:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
     f48:	18 16       	cp	r1, r24
     f4a:	0c f0       	brlt	.+2      	; 0xf4e <ADCPower+0xfa>
     f4c:	10 e0       	ldi	r17, 0x00	; 0
     f4e:	11 23       	and	r17, r17
     f50:	61 f1       	breq	.+88     	; 0xfaa <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f52:	69 81       	ldd	r22, Y+1	; 0x01
     f54:	7a 81       	ldd	r23, Y+2	; 0x02
     f56:	8b 81       	ldd	r24, Y+3	; 0x03
     f58:	9c 81       	ldd	r25, Y+4	; 0x04
     f5a:	20 e0       	ldi	r18, 0x00	; 0
     f5c:	30 e0       	ldi	r19, 0x00	; 0
     f5e:	40 e2       	ldi	r20, 0x20	; 32
     f60:	51 e4       	ldi	r21, 0x41	; 65
     f62:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
     f66:	dc 01       	movw	r26, r24
     f68:	cb 01       	movw	r24, r22
     f6a:	bc 01       	movw	r22, r24
     f6c:	cd 01       	movw	r24, r26
     f6e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
     f72:	dc 01       	movw	r26, r24
     f74:	cb 01       	movw	r24, r22
     f76:	89 87       	std	Y+9, r24	; 0x09
     f78:	9a 87       	std	Y+10, r25	; 0x0a
     f7a:	12 c0       	rjmp	.+36     	; 0xfa0 <ADCPower+0x14c>
     f7c:	80 e2       	ldi	r24, 0x20	; 32
     f7e:	93 e0       	ldi	r25, 0x03	; 3
     f80:	8b 87       	std	Y+11, r24	; 0x0b
     f82:	9c 87       	std	Y+12, r25	; 0x0c
     f84:	8b 85       	ldd	r24, Y+11	; 0x0b
     f86:	9c 85       	ldd	r25, Y+12	; 0x0c
     f88:	8c 01       	movw	r16, r24
     f8a:	c8 01       	movw	r24, r16
     f8c:	01 97       	sbiw	r24, 0x01	; 1
     f8e:	f1 f7       	brne	.-4      	; 0xf8c <ADCPower+0x138>
     f90:	8c 01       	movw	r16, r24
     f92:	0b 87       	std	Y+11, r16	; 0x0b
     f94:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f96:	89 85       	ldd	r24, Y+9	; 0x09
     f98:	9a 85       	ldd	r25, Y+10	; 0x0a
     f9a:	01 97       	sbiw	r24, 0x01	; 1
     f9c:	89 87       	std	Y+9, r24	; 0x09
     f9e:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     fa0:	89 85       	ldd	r24, Y+9	; 0x09
     fa2:	9a 85       	ldd	r25, Y+10	; 0x0a
     fa4:	00 97       	sbiw	r24, 0x00	; 0
     fa6:	51 f7       	brne	.-44     	; 0xf7c <ADCPower+0x128>
     fa8:	17 c0       	rjmp	.+46     	; 0xfd8 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     faa:	6d 81       	ldd	r22, Y+5	; 0x05
     fac:	7e 81       	ldd	r23, Y+6	; 0x06
     fae:	8f 81       	ldd	r24, Y+7	; 0x07
     fb0:	98 85       	ldd	r25, Y+8	; 0x08
     fb2:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
     fb6:	dc 01       	movw	r26, r24
     fb8:	cb 01       	movw	r24, r22
     fba:	89 87       	std	Y+9, r24	; 0x09
     fbc:	9a 87       	std	Y+10, r25	; 0x0a
     fbe:	89 85       	ldd	r24, Y+9	; 0x09
     fc0:	9a 85       	ldd	r25, Y+10	; 0x0a
     fc2:	8d 87       	std	Y+13, r24	; 0x0d
     fc4:	9e 87       	std	Y+14, r25	; 0x0e
     fc6:	8d 85       	ldd	r24, Y+13	; 0x0d
     fc8:	9e 85       	ldd	r25, Y+14	; 0x0e
     fca:	8c 01       	movw	r16, r24
     fcc:	f8 01       	movw	r30, r16
     fce:	31 97       	sbiw	r30, 0x01	; 1
     fd0:	f1 f7       	brne	.-4      	; 0xfce <ADCPower+0x17a>
     fd2:	8f 01       	movw	r16, r30
     fd4:	0d 87       	std	Y+13, r16	; 0x0d
     fd6:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     fd8:	80 e4       	ldi	r24, 0x40	; 64
     fda:	96 e0       	ldi	r25, 0x06	; 6
     fdc:	20 e4       	ldi	r18, 0x40	; 64
     fde:	fc 01       	movw	r30, r24
     fe0:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     fe2:	80 e0       	ldi	r24, 0x00	; 0
     fe4:	80 93 73 50 	sts	0x5073, r24
     fe8:	80 93 c6 50 	sts	0x50C6, r24
     fec:	80 93 c7 23 	sts	0x23C7, r24
     ff0:	80 93 6b 50 	sts	0x506B, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     ff4:	8f ef       	ldi	r24, 0xFF	; 255
     ff6:	61 e0       	ldi	r22, 0x01	; 1
     ff8:	0e 94 d7 33 	call	0x67ae	; 0x67ae <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     ffc:	8f ef       	ldi	r24, 0xFF	; 255
     ffe:	61 e0       	ldi	r22, 0x01	; 1
    1000:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
    1004:	8f ef       	ldi	r24, 0xFF	; 255
    1006:	0e 94 7f 09 	call	0x12fe	; 0x12fe <set_filter>
    100a:	42 c0       	rjmp	.+132    	; 0x1090 <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	96 e0       	ldi	r25, 0x06	; 6
    1010:	2e ed       	ldi	r18, 0xDE	; 222
    1012:	fc 01       	movw	r30, r24
    1014:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
    1016:	80 e2       	ldi	r24, 0x20	; 32
    1018:	96 e0       	ldi	r25, 0x06	; 6
    101a:	2e e0       	ldi	r18, 0x0E	; 14
    101c:	fc 01       	movw	r30, r24
    101e:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
    1020:	80 e4       	ldi	r24, 0x40	; 64
    1022:	96 e0       	ldi	r25, 0x06	; 6
    1024:	23 e0       	ldi	r18, 0x03	; 3
    1026:	fc 01       	movw	r30, r24
    1028:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
    102a:	80 e8       	ldi	r24, 0x80	; 128
    102c:	96 e0       	ldi	r25, 0x06	; 6
    102e:	20 e1       	ldi	r18, 0x10	; 16
    1030:	fc 01       	movw	r30, r24
    1032:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
    1034:	80 ea       	ldi	r24, 0xA0	; 160
    1036:	96 e0       	ldi	r25, 0x06	; 6
    1038:	2e e0       	ldi	r18, 0x0E	; 14
    103a:	fc 01       	movw	r30, r24
    103c:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	96 e0       	ldi	r25, 0x06	; 6
    1042:	2e ed       	ldi	r18, 0xDE	; 222
    1044:	fc 01       	movw	r30, r24
    1046:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
    1048:	80 e2       	ldi	r24, 0x20	; 32
    104a:	96 e0       	ldi	r25, 0x06	; 6
    104c:	2e e0       	ldi	r18, 0x0E	; 14
    104e:	fc 01       	movw	r30, r24
    1050:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
    1052:	80 e4       	ldi	r24, 0x40	; 64
    1054:	96 e0       	ldi	r25, 0x06	; 6
    1056:	23 e0       	ldi	r18, 0x03	; 3
    1058:	fc 01       	movw	r30, r24
    105a:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
    105c:	80 e8       	ldi	r24, 0x80	; 128
    105e:	96 e0       	ldi	r25, 0x06	; 6
    1060:	20 e1       	ldi	r18, 0x10	; 16
    1062:	fc 01       	movw	r30, r24
    1064:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
    1066:	80 ea       	ldi	r24, 0xA0	; 160
    1068:	96 e0       	ldi	r25, 0x06	; 6
    106a:	2e e0       	ldi	r18, 0x0E	; 14
    106c:	fc 01       	movw	r30, r24
    106e:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
    1070:	80 e4       	ldi	r24, 0x40	; 64
    1072:	96 e0       	ldi	r25, 0x06	; 6
    1074:	20 e4       	ldi	r18, 0x40	; 64
    1076:	fc 01       	movw	r30, r24
    1078:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
    107a:	80 e0       	ldi	r24, 0x00	; 0
    107c:	80 93 73 50 	sts	0x5073, r24
    1080:	80 93 c6 50 	sts	0x50C6, r24
    1084:	80 93 c7 23 	sts	0x23C7, r24
    1088:	80 93 6b 50 	sts	0x506B, r24
		channelStatus = 0x00;
    108c:	10 92 72 50 	sts	0x5072, r1
		
	}
}
    1090:	2f 96       	adiw	r28, 0x0f	; 15
    1092:	cd bf       	out	0x3d, r28	; 61
    1094:	de bf       	out	0x3e, r29	; 62
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	1f 91       	pop	r17
    109c:	0f 91       	pop	r16
    109e:	08 95       	ret

000010a0 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    10a0:	0f 93       	push	r16
    10a2:	1f 93       	push	r17
    10a4:	cf 93       	push	r28
    10a6:	df 93       	push	r29
    10a8:	cd b7       	in	r28, 0x3d	; 61
    10aa:	de b7       	in	r29, 0x3e	; 62
    10ac:	6a 97       	sbiw	r28, 0x1a	; 26
    10ae:	cd bf       	out	0x3d, r28	; 61
    10b0:	de bf       	out	0x3e, r29	; 62
    10b2:	89 8f       	std	Y+25, r24	; 0x19
    10b4:	6a 8f       	std	Y+26, r22	; 0x1a
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    10b6:	89 8d       	ldd	r24, Y+25	; 0x19
    10b8:	28 2f       	mov	r18, r24
    10ba:	30 e0       	ldi	r19, 0x00	; 0
    10bc:	81 e0       	ldi	r24, 0x01	; 1
    10be:	90 e0       	ldi	r25, 0x00	; 0
    10c0:	02 c0       	rjmp	.+4      	; 0x10c6 <set_ampGain+0x26>
    10c2:	88 0f       	add	r24, r24
    10c4:	99 1f       	adc	r25, r25
    10c6:	2a 95       	dec	r18
    10c8:	e2 f7       	brpl	.-8      	; 0x10c2 <set_ampGain+0x22>
    10ca:	61 e0       	ldi	r22, 0x01	; 1
    10cc:	0e 94 06 35 	call	0x6a0c	; 0x6a0c <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    10d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10d2:	88 2f       	mov	r24, r24
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	81 70       	andi	r24, 0x01	; 1
    10d8:	90 70       	andi	r25, 0x00	; 0
    10da:	88 23       	and	r24, r24
    10dc:	31 f0       	breq	.+12     	; 0x10ea <set_ampGain+0x4a>
    10de:	80 e0       	ldi	r24, 0x00	; 0
    10e0:	96 e0       	ldi	r25, 0x06	; 6
    10e2:	20 e4       	ldi	r18, 0x40	; 64
    10e4:	fc 01       	movw	r30, r24
    10e6:	25 83       	std	Z+5, r18	; 0x05
    10e8:	05 c0       	rjmp	.+10     	; 0x10f4 <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
    10ea:	80 e0       	ldi	r24, 0x00	; 0
    10ec:	96 e0       	ldi	r25, 0x06	; 6
    10ee:	20 e4       	ldi	r18, 0x40	; 64
    10f0:	fc 01       	movw	r30, r24
    10f2:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    10f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10f6:	88 2f       	mov	r24, r24
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	82 70       	andi	r24, 0x02	; 2
    10fc:	90 70       	andi	r25, 0x00	; 0
    10fe:	00 97       	sbiw	r24, 0x00	; 0
    1100:	31 f0       	breq	.+12     	; 0x110e <set_ampGain+0x6e>
    1102:	80 e2       	ldi	r24, 0x20	; 32
    1104:	96 e0       	ldi	r25, 0x06	; 6
    1106:	22 e0       	ldi	r18, 0x02	; 2
    1108:	fc 01       	movw	r30, r24
    110a:	25 83       	std	Z+5, r18	; 0x05
    110c:	05 c0       	rjmp	.+10     	; 0x1118 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
    110e:	80 e2       	ldi	r24, 0x20	; 32
    1110:	96 e0       	ldi	r25, 0x06	; 6
    1112:	22 e0       	ldi	r18, 0x02	; 2
    1114:	fc 01       	movw	r30, r24
    1116:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    1118:	8a 8d       	ldd	r24, Y+26	; 0x1a
    111a:	88 2f       	mov	r24, r24
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	84 70       	andi	r24, 0x04	; 4
    1120:	90 70       	andi	r25, 0x00	; 0
    1122:	00 97       	sbiw	r24, 0x00	; 0
    1124:	31 f0       	breq	.+12     	; 0x1132 <set_ampGain+0x92>
    1126:	80 e2       	ldi	r24, 0x20	; 32
    1128:	96 e0       	ldi	r25, 0x06	; 6
    112a:	24 e0       	ldi	r18, 0x04	; 4
    112c:	fc 01       	movw	r30, r24
    112e:	25 83       	std	Z+5, r18	; 0x05
    1130:	05 c0       	rjmp	.+10     	; 0x113c <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
    1132:	80 e2       	ldi	r24, 0x20	; 32
    1134:	96 e0       	ldi	r25, 0x06	; 6
    1136:	24 e0       	ldi	r18, 0x04	; 4
    1138:	fc 01       	movw	r30, r24
    113a:	26 83       	std	Z+6, r18	; 0x06
    113c:	80 e0       	ldi	r24, 0x00	; 0
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	a0 e8       	ldi	r26, 0x80	; 128
    1142:	bf e3       	ldi	r27, 0x3F	; 63
    1144:	89 83       	std	Y+1, r24	; 0x01
    1146:	9a 83       	std	Y+2, r25	; 0x02
    1148:	ab 83       	std	Y+3, r26	; 0x03
    114a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    114c:	69 81       	ldd	r22, Y+1	; 0x01
    114e:	7a 81       	ldd	r23, Y+2	; 0x02
    1150:	8b 81       	ldd	r24, Y+3	; 0x03
    1152:	9c 81       	ldd	r25, Y+4	; 0x04
    1154:	2b ea       	ldi	r18, 0xAB	; 171
    1156:	3a ea       	ldi	r19, 0xAA	; 170
    1158:	4a e2       	ldi	r20, 0x2A	; 42
    115a:	51 e4       	ldi	r21, 0x41	; 65
    115c:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    1160:	dc 01       	movw	r26, r24
    1162:	cb 01       	movw	r24, r22
    1164:	8d 83       	std	Y+5, r24	; 0x05
    1166:	9e 83       	std	Y+6, r25	; 0x06
    1168:	af 83       	std	Y+7, r26	; 0x07
    116a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    116c:	11 e0       	ldi	r17, 0x01	; 1
    116e:	6d 81       	ldd	r22, Y+5	; 0x05
    1170:	7e 81       	ldd	r23, Y+6	; 0x06
    1172:	8f 81       	ldd	r24, Y+7	; 0x07
    1174:	98 85       	ldd	r25, Y+8	; 0x08
    1176:	20 e0       	ldi	r18, 0x00	; 0
    1178:	30 e0       	ldi	r19, 0x00	; 0
    117a:	40 e8       	ldi	r20, 0x80	; 128
    117c:	5f e3       	ldi	r21, 0x3F	; 63
    117e:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    1182:	88 23       	and	r24, r24
    1184:	0c f0       	brlt	.+2      	; 0x1188 <set_ampGain+0xe8>
    1186:	10 e0       	ldi	r17, 0x00	; 0
    1188:	11 23       	and	r17, r17
    118a:	19 f0       	breq	.+6      	; 0x1192 <set_ampGain+0xf2>
		__ticks = 1;
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	89 87       	std	Y+9, r24	; 0x09
    1190:	a3 c0       	rjmp	.+326    	; 0x12d8 <set_ampGain+0x238>
	else if (__tmp > 255)
    1192:	11 e0       	ldi	r17, 0x01	; 1
    1194:	6d 81       	ldd	r22, Y+5	; 0x05
    1196:	7e 81       	ldd	r23, Y+6	; 0x06
    1198:	8f 81       	ldd	r24, Y+7	; 0x07
    119a:	98 85       	ldd	r25, Y+8	; 0x08
    119c:	20 e0       	ldi	r18, 0x00	; 0
    119e:	30 e0       	ldi	r19, 0x00	; 0
    11a0:	4f e7       	ldi	r20, 0x7F	; 127
    11a2:	53 e4       	ldi	r21, 0x43	; 67
    11a4:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    11a8:	18 16       	cp	r1, r24
    11aa:	0c f0       	brlt	.+2      	; 0x11ae <set_ampGain+0x10e>
    11ac:	10 e0       	ldi	r17, 0x00	; 0
    11ae:	11 23       	and	r17, r17
    11b0:	09 f4       	brne	.+2      	; 0x11b4 <set_ampGain+0x114>
    11b2:	89 c0       	rjmp	.+274    	; 0x12c6 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
    11b4:	69 81       	ldd	r22, Y+1	; 0x01
    11b6:	7a 81       	ldd	r23, Y+2	; 0x02
    11b8:	8b 81       	ldd	r24, Y+3	; 0x03
    11ba:	9c 81       	ldd	r25, Y+4	; 0x04
    11bc:	20 e0       	ldi	r18, 0x00	; 0
    11be:	30 e0       	ldi	r19, 0x00	; 0
    11c0:	4a e7       	ldi	r20, 0x7A	; 122
    11c2:	54 e4       	ldi	r21, 0x44	; 68
    11c4:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    11c8:	dc 01       	movw	r26, r24
    11ca:	cb 01       	movw	r24, r22
    11cc:	8a 87       	std	Y+10, r24	; 0x0a
    11ce:	9b 87       	std	Y+11, r25	; 0x0b
    11d0:	ac 87       	std	Y+12, r26	; 0x0c
    11d2:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    11d4:	6a 85       	ldd	r22, Y+10	; 0x0a
    11d6:	7b 85       	ldd	r23, Y+11	; 0x0b
    11d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    11da:	9d 85       	ldd	r25, Y+13	; 0x0d
    11dc:	20 e0       	ldi	r18, 0x00	; 0
    11de:	30 e0       	ldi	r19, 0x00	; 0
    11e0:	4a ef       	ldi	r20, 0xFA	; 250
    11e2:	55 e4       	ldi	r21, 0x45	; 69
    11e4:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    11e8:	dc 01       	movw	r26, r24
    11ea:	cb 01       	movw	r24, r22
    11ec:	8e 87       	std	Y+14, r24	; 0x0e
    11ee:	9f 87       	std	Y+15, r25	; 0x0f
    11f0:	a8 8b       	std	Y+16, r26	; 0x10
    11f2:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    11f4:	11 e0       	ldi	r17, 0x01	; 1
    11f6:	6e 85       	ldd	r22, Y+14	; 0x0e
    11f8:	7f 85       	ldd	r23, Y+15	; 0x0f
    11fa:	88 89       	ldd	r24, Y+16	; 0x10
    11fc:	99 89       	ldd	r25, Y+17	; 0x11
    11fe:	20 e0       	ldi	r18, 0x00	; 0
    1200:	30 e0       	ldi	r19, 0x00	; 0
    1202:	40 e8       	ldi	r20, 0x80	; 128
    1204:	5f e3       	ldi	r21, 0x3F	; 63
    1206:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    120a:	88 23       	and	r24, r24
    120c:	0c f0       	brlt	.+2      	; 0x1210 <set_ampGain+0x170>
    120e:	10 e0       	ldi	r17, 0x00	; 0
    1210:	11 23       	and	r17, r17
    1212:	29 f0       	breq	.+10     	; 0x121e <set_ampGain+0x17e>
		__ticks = 1;
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	8a 8b       	std	Y+18, r24	; 0x12
    121a:	9b 8b       	std	Y+19, r25	; 0x13
    121c:	46 c0       	rjmp	.+140    	; 0x12aa <set_ampGain+0x20a>
	else if (__tmp > 65535)
    121e:	11 e0       	ldi	r17, 0x01	; 1
    1220:	6e 85       	ldd	r22, Y+14	; 0x0e
    1222:	7f 85       	ldd	r23, Y+15	; 0x0f
    1224:	88 89       	ldd	r24, Y+16	; 0x10
    1226:	99 89       	ldd	r25, Y+17	; 0x11
    1228:	20 e0       	ldi	r18, 0x00	; 0
    122a:	3f ef       	ldi	r19, 0xFF	; 255
    122c:	4f e7       	ldi	r20, 0x7F	; 127
    122e:	57 e4       	ldi	r21, 0x47	; 71
    1230:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    1234:	18 16       	cp	r1, r24
    1236:	0c f0       	brlt	.+2      	; 0x123a <set_ampGain+0x19a>
    1238:	10 e0       	ldi	r17, 0x00	; 0
    123a:	11 23       	and	r17, r17
    123c:	61 f1       	breq	.+88     	; 0x1296 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    123e:	6a 85       	ldd	r22, Y+10	; 0x0a
    1240:	7b 85       	ldd	r23, Y+11	; 0x0b
    1242:	8c 85       	ldd	r24, Y+12	; 0x0c
    1244:	9d 85       	ldd	r25, Y+13	; 0x0d
    1246:	20 e0       	ldi	r18, 0x00	; 0
    1248:	30 e0       	ldi	r19, 0x00	; 0
    124a:	40 e2       	ldi	r20, 0x20	; 32
    124c:	51 e4       	ldi	r21, 0x41	; 65
    124e:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    1252:	dc 01       	movw	r26, r24
    1254:	cb 01       	movw	r24, r22
    1256:	bc 01       	movw	r22, r24
    1258:	cd 01       	movw	r24, r26
    125a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    125e:	dc 01       	movw	r26, r24
    1260:	cb 01       	movw	r24, r22
    1262:	8a 8b       	std	Y+18, r24	; 0x12
    1264:	9b 8b       	std	Y+19, r25	; 0x13
    1266:	12 c0       	rjmp	.+36     	; 0x128c <set_ampGain+0x1ec>
    1268:	80 e2       	ldi	r24, 0x20	; 32
    126a:	93 e0       	ldi	r25, 0x03	; 3
    126c:	8c 8b       	std	Y+20, r24	; 0x14
    126e:	9d 8b       	std	Y+21, r25	; 0x15
    1270:	8c 89       	ldd	r24, Y+20	; 0x14
    1272:	9d 89       	ldd	r25, Y+21	; 0x15
    1274:	8c 01       	movw	r16, r24
    1276:	c8 01       	movw	r24, r16
    1278:	01 97       	sbiw	r24, 0x01	; 1
    127a:	f1 f7       	brne	.-4      	; 0x1278 <set_ampGain+0x1d8>
    127c:	8c 01       	movw	r16, r24
    127e:	0c 8b       	std	Y+20, r16	; 0x14
    1280:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1282:	8a 89       	ldd	r24, Y+18	; 0x12
    1284:	9b 89       	ldd	r25, Y+19	; 0x13
    1286:	01 97       	sbiw	r24, 0x01	; 1
    1288:	8a 8b       	std	Y+18, r24	; 0x12
    128a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    128c:	8a 89       	ldd	r24, Y+18	; 0x12
    128e:	9b 89       	ldd	r25, Y+19	; 0x13
    1290:	00 97       	sbiw	r24, 0x00	; 0
    1292:	51 f7       	brne	.-44     	; 0x1268 <set_ampGain+0x1c8>
    1294:	28 c0       	rjmp	.+80     	; 0x12e6 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1296:	6e 85       	ldd	r22, Y+14	; 0x0e
    1298:	7f 85       	ldd	r23, Y+15	; 0x0f
    129a:	88 89       	ldd	r24, Y+16	; 0x10
    129c:	99 89       	ldd	r25, Y+17	; 0x11
    129e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    12a2:	dc 01       	movw	r26, r24
    12a4:	cb 01       	movw	r24, r22
    12a6:	8a 8b       	std	Y+18, r24	; 0x12
    12a8:	9b 8b       	std	Y+19, r25	; 0x13
    12aa:	8a 89       	ldd	r24, Y+18	; 0x12
    12ac:	9b 89       	ldd	r25, Y+19	; 0x13
    12ae:	8e 8b       	std	Y+22, r24	; 0x16
    12b0:	9f 8b       	std	Y+23, r25	; 0x17
    12b2:	8e 89       	ldd	r24, Y+22	; 0x16
    12b4:	9f 89       	ldd	r25, Y+23	; 0x17
    12b6:	8c 01       	movw	r16, r24
    12b8:	f8 01       	movw	r30, r16
    12ba:	31 97       	sbiw	r30, 0x01	; 1
    12bc:	f1 f7       	brne	.-4      	; 0x12ba <set_ampGain+0x21a>
    12be:	8f 01       	movw	r16, r30
    12c0:	0e 8b       	std	Y+22, r16	; 0x16
    12c2:	1f 8b       	std	Y+23, r17	; 0x17
    12c4:	10 c0       	rjmp	.+32     	; 0x12e6 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    12c6:	6d 81       	ldd	r22, Y+5	; 0x05
    12c8:	7e 81       	ldd	r23, Y+6	; 0x06
    12ca:	8f 81       	ldd	r24, Y+7	; 0x07
    12cc:	98 85       	ldd	r25, Y+8	; 0x08
    12ce:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    12d2:	dc 01       	movw	r26, r24
    12d4:	cb 01       	movw	r24, r22
    12d6:	89 87       	std	Y+9, r24	; 0x09
    12d8:	89 85       	ldd	r24, Y+9	; 0x09
    12da:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    12dc:	88 8d       	ldd	r24, Y+24	; 0x18
    12de:	18 2f       	mov	r17, r24
    12e0:	1a 95       	dec	r17
    12e2:	f1 f7       	brne	.-4      	; 0x12e0 <set_ampGain+0x240>
    12e4:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    12e6:	8f ef       	ldi	r24, 0xFF	; 255
    12e8:	61 e0       	ldi	r22, 0x01	; 1
    12ea:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    12ee:	6a 96       	adiw	r28, 0x1a	; 26
    12f0:	cd bf       	out	0x3d, r28	; 61
    12f2:	de bf       	out	0x3e, r29	; 62
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	1f 91       	pop	r17
    12fa:	0f 91       	pop	r16
    12fc:	08 95       	ret

000012fe <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	00 d0       	rcall	.+0      	; 0x1304 <set_filter+0x6>
    1304:	cd b7       	in	r28, 0x3d	; 61
    1306:	de b7       	in	r29, 0x3e	; 62
    1308:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    130a:	8b 81       	ldd	r24, Y+3	; 0x03
    130c:	83 70       	andi	r24, 0x03	; 3
    130e:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    1310:	8b 81       	ldd	r24, Y+3	; 0x03
    1312:	8c 70       	andi	r24, 0x0C	; 12
    1314:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    1316:	8b 81       	ldd	r24, Y+3	; 0x03
    1318:	88 2f       	mov	r24, r24
    131a:	90 e0       	ldi	r25, 0x00	; 0
    131c:	85 70       	andi	r24, 0x05	; 5
    131e:	90 70       	andi	r25, 0x00	; 0
    1320:	00 97       	sbiw	r24, 0x00	; 0
    1322:	51 f0       	breq	.+20     	; 0x1338 <set_filter+0x3a>
    1324:	80 91 72 50 	lds	r24, 0x5072
    1328:	98 2f       	mov	r25, r24
    132a:	90 7f       	andi	r25, 0xF0	; 240
    132c:	8b 81       	ldd	r24, Y+3	; 0x03
    132e:	82 95       	swap	r24
    1330:	8f 70       	andi	r24, 0x0F	; 15
    1332:	89 2b       	or	r24, r25
    1334:	80 93 72 50 	sts	0x5072, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    1338:	8b 81       	ldd	r24, Y+3	; 0x03
    133a:	88 2f       	mov	r24, r24
    133c:	90 e0       	ldi	r25, 0x00	; 0
    133e:	8a 70       	andi	r24, 0x0A	; 10
    1340:	90 70       	andi	r25, 0x00	; 0
    1342:	00 97       	sbiw	r24, 0x00	; 0
    1344:	49 f0       	breq	.+18     	; 0x1358 <set_filter+0x5a>
    1346:	8b 81       	ldd	r24, Y+3	; 0x03
    1348:	98 2f       	mov	r25, r24
    134a:	90 7f       	andi	r25, 0xF0	; 240
    134c:	80 91 72 50 	lds	r24, 0x5072
    1350:	8f 70       	andi	r24, 0x0F	; 15
    1352:	89 2b       	or	r24, r25
    1354:	80 93 72 50 	sts	0x5072, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    1358:	84 e0       	ldi	r24, 0x04	; 4
    135a:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    135e:	80 91 72 50 	lds	r24, 0x5072
    1362:	80 93 56 50 	sts	0x5056, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	88 23       	and	r24, r24
    136a:	19 f0       	breq	.+6      	; 0x1372 <set_filter+0x74>
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	0e 94 43 38 	call	0x7086	; 0x7086 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    1372:	8a 81       	ldd	r24, Y+2	; 0x02
    1374:	88 23       	and	r24, r24
    1376:	19 f0       	breq	.+6      	; 0x137e <set_filter+0x80>
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	0e 94 5b 38 	call	0x70b6	; 0x70b6 <upperMuxCS>

	SPICS(TRUE);
    137e:	81 e0       	ldi	r24, 0x01	; 1
    1380:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    1384:	80 ec       	ldi	r24, 0xC0	; 192
    1386:	98 e0       	ldi	r25, 0x08	; 8
    1388:	2f ef       	ldi	r18, 0xFF	; 255
    138a:	fc 01       	movw	r30, r24
    138c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    138e:	00 00       	nop
    1390:	80 ec       	ldi	r24, 0xC0	; 192
    1392:	98 e0       	ldi	r25, 0x08	; 8
    1394:	fc 01       	movw	r30, r24
    1396:	82 81       	ldd	r24, Z+2	; 0x02
    1398:	88 23       	and	r24, r24
    139a:	d4 f7       	brge	.-12     	; 0x1390 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    139c:	80 ec       	ldi	r24, 0xC0	; 192
    139e:	98 e0       	ldi	r25, 0x08	; 8
    13a0:	fc 01       	movw	r30, r24
    13a2:	83 81       	ldd	r24, Z+3	; 0x03
    13a4:	80 93 62 50 	sts	0x5062, r24

	nop();
    13a8:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    13aa:	80 ec       	ldi	r24, 0xC0	; 192
    13ac:	98 e0       	ldi	r25, 0x08	; 8
    13ae:	20 91 56 50 	lds	r18, 0x5056
    13b2:	fc 01       	movw	r30, r24
    13b4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    13b6:	00 00       	nop
    13b8:	80 ec       	ldi	r24, 0xC0	; 192
    13ba:	98 e0       	ldi	r25, 0x08	; 8
    13bc:	fc 01       	movw	r30, r24
    13be:	82 81       	ldd	r24, Z+2	; 0x02
    13c0:	88 23       	and	r24, r24
    13c2:	d4 f7       	brge	.-12     	; 0x13b8 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    13c4:	80 ec       	ldi	r24, 0xC0	; 192
    13c6:	98 e0       	ldi	r25, 0x08	; 8
    13c8:	fc 01       	movw	r30, r24
    13ca:	83 81       	ldd	r24, Z+3	; 0x03
    13cc:	80 93 62 50 	sts	0x5062, r24
	SPICS(FALSE);
    13d0:	80 e0       	ldi	r24, 0x00	; 0
    13d2:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    13d6:	89 81       	ldd	r24, Y+1	; 0x01
    13d8:	88 23       	and	r24, r24
    13da:	19 f0       	breq	.+6      	; 0x13e2 <set_filter+0xe4>
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	0e 94 43 38 	call	0x7086	; 0x7086 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    13e2:	8a 81       	ldd	r24, Y+2	; 0x02
    13e4:	88 23       	and	r24, r24
    13e6:	19 f0       	breq	.+6      	; 0x13ee <set_filter+0xf0>
    13e8:	80 e0       	ldi	r24, 0x00	; 0
    13ea:	0e 94 5b 38 	call	0x70b6	; 0x70b6 <upperMuxCS>
	SPIDisable();
    13ee:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
}
    13f2:	23 96       	adiw	r28, 0x03	; 3
    13f4:	cd bf       	out	0x3d, r28	; 61
    13f6:	de bf       	out	0x3e, r29	; 62
    13f8:	df 91       	pop	r29
    13fa:	cf 91       	pop	r28
    13fc:	08 95       	ret

000013fe <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    13fe:	cf 93       	push	r28
    1400:	df 93       	push	r29
    1402:	0f 92       	push	r0
    1404:	cd b7       	in	r28, 0x3d	; 61
    1406:	de b7       	in	r29, 0x3e	; 62
    1408:	89 83       	std	Y+1, r24	; 0x01
	
	if(on) {
    140a:	89 81       	ldd	r24, Y+1	; 0x01
    140c:	88 23       	and	r24, r24
    140e:	59 f0       	breq	.+22     	; 0x1426 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	96 e0       	ldi	r25, 0x06	; 6
    1414:	20 e2       	ldi	r18, 0x20	; 32
    1416:	fc 01       	movw	r30, r24
    1418:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	96 e0       	ldi	r25, 0x06	; 6
    141e:	20 e2       	ldi	r18, 0x20	; 32
    1420:	fc 01       	movw	r30, r24
    1422:	25 83       	std	Z+5, r18	; 0x05
    1424:	0a c0       	rjmp	.+20     	; 0x143a <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	96 e0       	ldi	r25, 0x06	; 6
    142a:	20 e2       	ldi	r18, 0x20	; 32
    142c:	fc 01       	movw	r30, r24
    142e:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	96 e0       	ldi	r25, 0x06	; 6
    1434:	20 e2       	ldi	r18, 0x20	; 32
    1436:	fc 01       	movw	r30, r24
    1438:	22 83       	std	Z+2, r18	; 0x02
	}
}
    143a:	0f 90       	pop	r0
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	08 95       	ret

00001442 <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint32_t numOfSamples, int32_t* DataArray) {
    1442:	cf 92       	push	r12
    1444:	df 92       	push	r13
    1446:	ef 92       	push	r14
    1448:	ff 92       	push	r15
    144a:	0f 93       	push	r16
    144c:	1f 93       	push	r17
    144e:	cf 93       	push	r28
    1450:	df 93       	push	r29
    1452:	cd b7       	in	r28, 0x3d	; 61
    1454:	de b7       	in	r29, 0x3e	; 62
    1456:	2d 97       	sbiw	r28, 0x0d	; 13
    1458:	cd bf       	out	0x3d, r28	; 61
    145a:	de bf       	out	0x3e, r29	; 62
    145c:	8b 83       	std	Y+3, r24	; 0x03
    145e:	6c 83       	std	Y+4, r22	; 0x04
    1460:	4d 83       	std	Y+5, r20	; 0x05
    1462:	2e 83       	std	Y+6, r18	; 0x06
    1464:	3f 83       	std	Y+7, r19	; 0x07
    1466:	e8 86       	std	Y+8, r14	; 0x08
    1468:	f9 86       	std	Y+9, r15	; 0x09
    146a:	0a 87       	std	Y+10, r16	; 0x0a
    146c:	1b 87       	std	Y+11, r17	; 0x0b
    146e:	cc 86       	std	Y+12, r12	; 0x0c
    1470:	dd 86       	std	Y+13, r13	; 0x0d


	uint16_t period;
	ADC_BUFFER = DataArray;
    1472:	8c 85       	ldd	r24, Y+12	; 0x0c
    1474:	9d 85       	ldd	r25, Y+13	; 0x0d
    1476:	80 93 63 50 	sts	0x5063, r24
    147a:	90 93 64 50 	sts	0x5064, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    1484:	8b 81       	ldd	r24, Y+3	; 0x03
    1486:	6d 81       	ldd	r22, Y+5	; 0x05
    1488:	0e 94 50 08 	call	0x10a0	; 0x10a0 <set_ampGain>
	set_filter(filterConfig);
    148c:	8c 81       	ldd	r24, Y+4	; 0x04
    148e:	0e 94 7f 09 	call	0x12fe	; 0x12fe <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    1492:	8b 81       	ldd	r24, Y+3	; 0x03
    1494:	85 30       	cpi	r24, 0x05	; 5
    1496:	31 f0       	breq	.+12     	; 0x14a4 <CO_collectADC+0x62>
    1498:	8b 81       	ldd	r24, Y+3	; 0x03
    149a:	86 30       	cpi	r24, 0x06	; 6
    149c:	19 f0       	breq	.+6      	; 0x14a4 <CO_collectADC+0x62>
    149e:	8b 81       	ldd	r24, Y+3	; 0x03
    14a0:	87 30       	cpi	r24, 0x07	; 7
    14a2:	19 f4       	brne	.+6      	; 0x14aa <CO_collectADC+0x68>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	0e 94 ff 09 	call	0x13fe	; 0x13fe <enableADCMUX>
	setADCInput(channel);
    14b0:	8b 81       	ldd	r24, Y+3	; 0x03
    14b2:	0e 94 1d 1b 	call	0x363a	; 0x363a <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    14b6:	84 e0       	ldi	r24, 0x04	; 4
    14b8:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    14bc:	80 ec       	ldi	r24, 0xC0	; 192
    14be:	98 e0       	ldi	r25, 0x08	; 8
    14c0:	24 e5       	ldi	r18, 0x54	; 84
    14c2:	fc 01       	movw	r30, r24
    14c4:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    14c6:	80 ea       	ldi	r24, 0xA0	; 160
    14c8:	96 e0       	ldi	r25, 0x06	; 6
    14ca:	21 e0       	ldi	r18, 0x01	; 1
    14cc:	fc 01       	movw	r30, r24
    14ce:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    14d0:	80 ea       	ldi	r24, 0xA0	; 160
    14d2:	96 e0       	ldi	r25, 0x06	; 6
    14d4:	22 e0       	ldi	r18, 0x02	; 2
    14d6:	fc 01       	movw	r30, r24
    14d8:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    14da:	80 ea       	ldi	r24, 0xA0	; 160
    14dc:	96 e0       	ldi	r25, 0x06	; 6
    14de:	21 e0       	ldi	r18, 0x01	; 1
    14e0:	fc 01       	movw	r30, r24
    14e2:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    14e4:	80 ea       	ldi	r24, 0xA0	; 160
    14e6:	96 e0       	ldi	r25, 0x06	; 6
    14e8:	21 e0       	ldi	r18, 0x01	; 1
    14ea:	fc 01       	movw	r30, r24
    14ec:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    14ee:	80 e8       	ldi	r24, 0x80	; 128
    14f0:	96 e0       	ldi	r25, 0x06	; 6
    14f2:	20 e2       	ldi	r18, 0x20	; 32
    14f4:	fc 01       	movw	r30, r24
    14f6:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    14f8:	80 e4       	ldi	r24, 0x40	; 64
    14fa:	9a e0       	ldi	r25, 0x0A	; 10
    14fc:	23 e2       	ldi	r18, 0x23	; 35
    14fe:	fc 01       	movw	r30, r24
    1500:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    1502:	8e 81       	ldd	r24, Y+6	; 0x06
    1504:	9f 81       	ldd	r25, Y+7	; 0x07
    1506:	9c 01       	movw	r18, r24
    1508:	40 e0       	ldi	r20, 0x00	; 0
    150a:	50 e0       	ldi	r21, 0x00	; 0
    150c:	80 e8       	ldi	r24, 0x80	; 128
    150e:	94 e8       	ldi	r25, 0x84	; 132
    1510:	ae e1       	ldi	r26, 0x1E	; 30
    1512:	b0 e0       	ldi	r27, 0x00	; 0
    1514:	bc 01       	movw	r22, r24
    1516:	cd 01       	movw	r24, r26
    1518:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    151c:	da 01       	movw	r26, r20
    151e:	c9 01       	movw	r24, r18
    1520:	89 83       	std	Y+1, r24	; 0x01
    1522:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    1524:	80 e4       	ldi	r24, 0x40	; 64
    1526:	9a e0       	ldi	r25, 0x0A	; 10
    1528:	29 81       	ldd	r18, Y+1	; 0x01
    152a:	3a 81       	ldd	r19, Y+2	; 0x02
    152c:	fc 01       	movw	r30, r24
    152e:	26 a3       	lds	r18, 0x56
    1530:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    1532:	80 e4       	ldi	r24, 0x40	; 64
    1534:	9a e0       	ldi	r25, 0x0A	; 10
    1536:	29 81       	ldd	r18, Y+1	; 0x01
    1538:	3a 81       	ldd	r19, Y+2	; 0x02
    153a:	36 95       	lsr	r19
    153c:	27 95       	ror	r18
    153e:	fc 01       	movw	r30, r24
    1540:	22 af       	sts	0x72, r18
    1542:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1544:	80 e4       	ldi	r24, 0x40	; 64
    1546:	9a e0       	ldi	r25, 0x0A	; 10
    1548:	20 e4       	ldi	r18, 0x40	; 64
    154a:	3a e0       	ldi	r19, 0x0A	; 10
    154c:	f9 01       	movw	r30, r18
    154e:	20 81       	ld	r18, Z
    1550:	20 7f       	andi	r18, 0xF0	; 240
    1552:	21 60       	ori	r18, 0x01	; 1
    1554:	fc 01       	movw	r30, r24
    1556:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1558:	80 ea       	ldi	r24, 0xA0	; 160
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	20 ea       	ldi	r18, 0xA0	; 160
    155e:	30 e0       	ldi	r19, 0x00	; 0
    1560:	f9 01       	movw	r30, r18
    1562:	22 81       	ldd	r18, Z+2	; 0x02
    1564:	21 60       	ori	r18, 0x01	; 1
    1566:	fc 01       	movw	r30, r24
    1568:	22 83       	std	Z+2, r18	; 0x02
	sei();
    156a:	78 94       	sei

	sampleCount = 0;
    156c:	10 92 65 50 	sts	0x5065, r1
    1570:	10 92 66 50 	sts	0x5066, r1
    1574:	10 92 67 50 	sts	0x5067, r1
    1578:	10 92 68 50 	sts	0x5068, r1
	discardCount = 0;
    157c:	10 92 4e 40 	sts	0x404E, r1
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    1580:	00 00       	nop
    1582:	20 91 65 50 	lds	r18, 0x5065
    1586:	30 91 66 50 	lds	r19, 0x5066
    158a:	40 91 67 50 	lds	r20, 0x5067
    158e:	50 91 68 50 	lds	r21, 0x5068
    1592:	88 85       	ldd	r24, Y+8	; 0x08
    1594:	99 85       	ldd	r25, Y+9	; 0x09
    1596:	aa 85       	ldd	r26, Y+10	; 0x0a
    1598:	bb 85       	ldd	r27, Y+11	; 0x0b
    159a:	28 17       	cp	r18, r24
    159c:	39 07       	cpc	r19, r25
    159e:	4a 07       	cpc	r20, r26
    15a0:	5b 07       	cpc	r21, r27
    15a2:	78 f3       	brcs	.-34     	; 0x1582 <CO_collectADC+0x140>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    15a4:	80 e4       	ldi	r24, 0x40	; 64
    15a6:	9a e0       	ldi	r25, 0x0A	; 10
    15a8:	20 e4       	ldi	r18, 0x40	; 64
    15aa:	3a e0       	ldi	r19, 0x0A	; 10
    15ac:	f9 01       	movw	r30, r18
    15ae:	20 81       	ld	r18, Z
    15b0:	20 7f       	andi	r18, 0xF0	; 240
    15b2:	fc 01       	movw	r30, r24
    15b4:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    15b6:	80 ea       	ldi	r24, 0xA0	; 160
    15b8:	90 e0       	ldi	r25, 0x00	; 0
    15ba:	20 ea       	ldi	r18, 0xA0	; 160
    15bc:	30 e0       	ldi	r19, 0x00	; 0
    15be:	f9 01       	movw	r30, r18
    15c0:	22 81       	ldd	r18, Z+2	; 0x02
    15c2:	2e 7f       	andi	r18, 0xFE	; 254
    15c4:	fc 01       	movw	r30, r24
    15c6:	22 83       	std	Z+2, r18	; 0x02
	cli();
    15c8:	f8 94       	cli

	SPIDisable();	
    15ca:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	enableADCMUX(FALSE);
    15ce:	80 e0       	ldi	r24, 0x00	; 0
    15d0:	0e 94 ff 09 	call	0x13fe	; 0x13fe <enableADCMUX>
	//ADCPower(FALSE);
}
    15d4:	2d 96       	adiw	r28, 0x0d	; 13
    15d6:	cd bf       	out	0x3d, r28	; 61
    15d8:	de bf       	out	0x3e, r29	; 62
    15da:	df 91       	pop	r29
    15dc:	cf 91       	pop	r28
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	ff 90       	pop	r15
    15e4:	ef 90       	pop	r14
    15e6:	df 90       	pop	r13
    15e8:	cf 90       	pop	r12
    15ea:	08 95       	ret

000015ec <CO_collectADC_cont>:

//continuously take samples and send them via radio. NOT RECOMMENDET
void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    15ec:	cf 93       	push	r28
    15ee:	df 93       	push	r29
    15f0:	00 d0       	rcall	.+0      	; 0x15f2 <CO_collectADC_cont+0x6>
    15f2:	00 d0       	rcall	.+0      	; 0x15f4 <CO_collectADC_cont+0x8>
    15f4:	cd b7       	in	r28, 0x3d	; 61
    15f6:	de b7       	in	r29, 0x3e	; 62
    15f8:	8b 83       	std	Y+3, r24	; 0x03
    15fa:	6c 83       	std	Y+4, r22	; 0x04
    15fc:	4d 83       	std	Y+5, r20	; 0x05
    15fe:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
//get data to write files to SD card
//getBootSectorData();
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1606:	8b 81       	ldd	r24, Y+3	; 0x03
    1608:	6d 81       	ldd	r22, Y+5	; 0x05
    160a:	0e 94 50 08 	call	0x10a0	; 0x10a0 <set_ampGain>
set_filter(filterConfig);
    160e:	8c 81       	ldd	r24, Y+4	; 0x04
    1610:	0e 94 7f 09 	call	0x12fe	; 0x12fe <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1614:	8b 81       	ldd	r24, Y+3	; 0x03
    1616:	85 30       	cpi	r24, 0x05	; 5
    1618:	31 f0       	breq	.+12     	; 0x1626 <CO_collectADC_cont+0x3a>
    161a:	8b 81       	ldd	r24, Y+3	; 0x03
    161c:	86 30       	cpi	r24, 0x06	; 6
    161e:	19 f0       	breq	.+6      	; 0x1626 <CO_collectADC_cont+0x3a>
    1620:	8b 81       	ldd	r24, Y+3	; 0x03
    1622:	87 30       	cpi	r24, 0x07	; 7
    1624:	19 f4       	brne	.+6      	; 0x162c <CO_collectADC_cont+0x40>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <ACC_DCPassEnable>

enableADCMUX(TRUE);
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	0e 94 ff 09 	call	0x13fe	; 0x13fe <enableADCMUX>
setADCInput(channel);
    1632:	8b 81       	ldd	r24, Y+3	; 0x03
    1634:	0e 94 1d 1b 	call	0x363a	; 0x363a <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1638:	84 e0       	ldi	r24, 0x04	; 4
    163a:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    163e:	80 ec       	ldi	r24, 0xC0	; 192
    1640:	98 e0       	ldi	r25, 0x08	; 8
    1642:	24 e5       	ldi	r18, 0x54	; 84
    1644:	fc 01       	movw	r30, r24
    1646:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1648:	80 ea       	ldi	r24, 0xA0	; 160
    164a:	96 e0       	ldi	r25, 0x06	; 6
    164c:	21 e0       	ldi	r18, 0x01	; 1
    164e:	fc 01       	movw	r30, r24
    1650:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1652:	80 ea       	ldi	r24, 0xA0	; 160
    1654:	96 e0       	ldi	r25, 0x06	; 6
    1656:	22 e0       	ldi	r18, 0x02	; 2
    1658:	fc 01       	movw	r30, r24
    165a:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    165c:	80 ea       	ldi	r24, 0xA0	; 160
    165e:	96 e0       	ldi	r25, 0x06	; 6
    1660:	21 e0       	ldi	r18, 0x01	; 1
    1662:	fc 01       	movw	r30, r24
    1664:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_MED_gc;
    1666:	80 ea       	ldi	r24, 0xA0	; 160
    1668:	96 e0       	ldi	r25, 0x06	; 6
    166a:	28 e0       	ldi	r18, 0x08	; 8
    166c:	fc 01       	movw	r30, r24
    166e:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    1670:	80 e8       	ldi	r24, 0x80	; 128
    1672:	96 e0       	ldi	r25, 0x06	; 6
    1674:	20 e2       	ldi	r18, 0x20	; 32
    1676:	fc 01       	movw	r30, r24
    1678:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    167a:	80 e4       	ldi	r24, 0x40	; 64
    167c:	9a e0       	ldi	r25, 0x0A	; 10
    167e:	23 e2       	ldi	r18, 0x23	; 35
    1680:	fc 01       	movw	r30, r24
    1682:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1684:	8e 81       	ldd	r24, Y+6	; 0x06
    1686:	88 2f       	mov	r24, r24
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	25 e1       	ldi	r18, 0x15	; 21
    168c:	30 e0       	ldi	r19, 0x00	; 0
    168e:	28 1b       	sub	r18, r24
    1690:	39 0b       	sbc	r19, r25
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	02 c0       	rjmp	.+4      	; 0x169c <CO_collectADC_cont+0xb0>
    1698:	88 0f       	add	r24, r24
    169a:	99 1f       	adc	r25, r25
    169c:	2a 95       	dec	r18
    169e:	e2 f7       	brpl	.-8      	; 0x1698 <CO_collectADC_cont+0xac>
    16a0:	01 97       	sbiw	r24, 0x01	; 1
    16a2:	89 83       	std	Y+1, r24	; 0x01
    16a4:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    16a6:	80 e4       	ldi	r24, 0x40	; 64
    16a8:	9a e0       	ldi	r25, 0x0A	; 10
    16aa:	29 81       	ldd	r18, Y+1	; 0x01
    16ac:	3a 81       	ldd	r19, Y+2	; 0x02
    16ae:	fc 01       	movw	r30, r24
    16b0:	26 a3       	lds	r18, 0x56
    16b2:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    16b4:	80 e4       	ldi	r24, 0x40	; 64
    16b6:	9a e0       	ldi	r25, 0x0A	; 10
    16b8:	29 81       	ldd	r18, Y+1	; 0x01
    16ba:	3a 81       	ldd	r19, Y+2	; 0x02
    16bc:	36 95       	lsr	r19
    16be:	27 95       	ror	r18
    16c0:	fc 01       	movw	r30, r24
    16c2:	22 af       	sts	0x72, r18
    16c4:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    16c6:	80 e4       	ldi	r24, 0x40	; 64
    16c8:	9a e0       	ldi	r25, 0x0A	; 10
    16ca:	20 e4       	ldi	r18, 0x40	; 64
    16cc:	3a e0       	ldi	r19, 0x0A	; 10
    16ce:	f9 01       	movw	r30, r18
    16d0:	20 81       	ld	r18, Z
    16d2:	20 7f       	andi	r18, 0xF0	; 240
    16d4:	21 60       	ori	r18, 0x01	; 1
    16d6:	fc 01       	movw	r30, r24
    16d8:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_MEDLVLEN_bm;
    16da:	80 ea       	ldi	r24, 0xA0	; 160
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	20 ea       	ldi	r18, 0xA0	; 160
    16e0:	30 e0       	ldi	r19, 0x00	; 0
    16e2:	f9 01       	movw	r30, r18
    16e4:	22 81       	ldd	r18, Z+2	; 0x02
    16e6:	22 60       	ori	r18, 0x02	; 2
    16e8:	fc 01       	movw	r30, r24
    16ea:	22 83       	std	Z+2, r18	; 0x02
//enable RR of lowlvl interrupts
PMIC.CTRL |= PMIC_RREN_bm; 
    16ec:	80 ea       	ldi	r24, 0xA0	; 160
    16ee:	90 e0       	ldi	r25, 0x00	; 0
    16f0:	20 ea       	ldi	r18, 0xA0	; 160
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	f9 01       	movw	r30, r18
    16f6:	22 81       	ldd	r18, Z+2	; 0x02
    16f8:	20 68       	ori	r18, 0x80	; 128
    16fa:	fc 01       	movw	r30, r24
    16fc:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
// chb_init();
// chb_set_short_addr(moteID);

sampleCount = 0;
    16fe:	10 92 65 50 	sts	0x5065, r1
    1702:	10 92 66 50 	sts	0x5066, r1
    1706:	10 92 67 50 	sts	0x5067, r1
    170a:	10 92 68 50 	sts	0x5068, r1
TotalSampleCount = 0;
    170e:	10 92 95 50 	sts	0x5095, r1
    1712:	10 92 96 50 	sts	0x5096, r1
discardCount = 0;
    1716:	10 92 4e 40 	sts	0x404E, r1
sei();
    171a:	78 94       	sei
}
    171c:	26 96       	adiw	r28, 0x06	; 6
    171e:	cd bf       	out	0x3d, r28	; 61
    1720:	de bf       	out	0x3e, r29	; 62
    1722:	df 91       	pop	r29
    1724:	cf 91       	pop	r28
    1726:	08 95       	ret

00001728 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
    1728:	cf 93       	push	r28
    172a:	df 93       	push	r29
    172c:	cd b7       	in	r28, 0x3d	; 61
    172e:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1730:	80 ea       	ldi	r24, 0xA0	; 160
    1732:	96 e0       	ldi	r25, 0x06	; 6
    1734:	fc 01       	movw	r30, r24
    1736:	13 86       	std	Z+11, r1	; 0x0b
}
    1738:	df 91       	pop	r29
    173a:	cf 91       	pop	r28
    173c:	08 95       	ret

0000173e <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    173e:	cf 93       	push	r28
    1740:	df 93       	push	r29
    1742:	cd b7       	in	r28, 0x3d	; 61
    1744:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1746:	80 ea       	ldi	r24, 0xA0	; 160
    1748:	96 e0       	ldi	r25, 0x06	; 6
    174a:	21 e0       	ldi	r18, 0x01	; 1
    174c:	fc 01       	movw	r30, r24
    174e:	23 87       	std	Z+11, r18	; 0x0b
}	
    1750:	df 91       	pop	r29
    1752:	cf 91       	pop	r28
    1754:	08 95       	ret

00001756 <__vector_105>:

//ISR used by CO_collectADC_cont function
ISR(PORTF_INT1_vect) {
    1756:	1f 92       	push	r1
    1758:	0f 92       	push	r0
    175a:	0f b6       	in	r0, 0x3f	; 63
    175c:	0f 92       	push	r0
    175e:	00 90 3b 00 	lds	r0, 0x003B
    1762:	0f 92       	push	r0
    1764:	11 24       	eor	r1, r1
    1766:	2f 92       	push	r2
    1768:	3f 92       	push	r3
    176a:	4f 92       	push	r4
    176c:	5f 92       	push	r5
    176e:	6f 92       	push	r6
    1770:	7f 92       	push	r7
    1772:	8f 92       	push	r8
    1774:	9f 92       	push	r9
    1776:	af 92       	push	r10
    1778:	bf 92       	push	r11
    177a:	cf 92       	push	r12
    177c:	df 92       	push	r13
    177e:	ef 92       	push	r14
    1780:	ff 92       	push	r15
    1782:	0f 93       	push	r16
    1784:	1f 93       	push	r17
    1786:	2f 93       	push	r18
    1788:	3f 93       	push	r19
    178a:	4f 93       	push	r20
    178c:	5f 93       	push	r21
    178e:	6f 93       	push	r22
    1790:	7f 93       	push	r23
    1792:	8f 93       	push	r24
    1794:	9f 93       	push	r25
    1796:	af 93       	push	r26
    1798:	bf 93       	push	r27
    179a:	ef 93       	push	r30
    179c:	ff 93       	push	r31
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	00 d0       	rcall	.+0      	; 0x17a4 <__vector_105+0x4e>
    17a4:	cd b7       	in	r28, 0x3d	; 61
    17a6:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    17a8:	80 91 4e 40 	lds	r24, 0x404E
    17ac:	88 23       	and	r24, r24
    17ae:	34 f0       	brlt	.+12     	; 0x17bc <__vector_105+0x66>
		discardCount++;
    17b0:	80 91 4e 40 	lds	r24, 0x404E
    17b4:	8f 5f       	subi	r24, 0xFF	; 255
    17b6:	80 93 4e 40 	sts	0x404E, r24
    17ba:	af c1       	rjmp	.+862    	; 0x1b1a <__vector_105+0x3c4>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    17bc:	84 e0       	ldi	r24, 0x04	; 4
    17be:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    17c2:	80 ec       	ldi	r24, 0xC0	; 192
    17c4:	98 e0       	ldi	r25, 0x08	; 8
    17c6:	24 e5       	ldi	r18, 0x54	; 84
    17c8:	fc 01       	movw	r30, r24
    17ca:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    17cc:	81 e0       	ldi	r24, 0x01	; 1
    17ce:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    17d2:	80 ea       	ldi	r24, 0xA0	; 160
    17d4:	96 e0       	ldi	r25, 0x06	; 6
    17d6:	22 e0       	ldi	r18, 0x02	; 2
    17d8:	fc 01       	movw	r30, r24
    17da:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    17dc:	19 82       	std	Y+1, r1	; 0x01
    17de:	1a c0       	rjmp	.+52     	; 0x1814 <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    17e0:	80 ec       	ldi	r24, 0xC0	; 192
    17e2:	98 e0       	ldi	r25, 0x08	; 8
    17e4:	2a ea       	ldi	r18, 0xAA	; 170
    17e6:	fc 01       	movw	r30, r24
    17e8:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    17ea:	00 00       	nop
    17ec:	80 ec       	ldi	r24, 0xC0	; 192
    17ee:	98 e0       	ldi	r25, 0x08	; 8
    17f0:	fc 01       	movw	r30, r24
    17f2:	82 81       	ldd	r24, Z+2	; 0x02
    17f4:	88 23       	and	r24, r24
    17f6:	d4 f7       	brge	.-12     	; 0x17ec <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    17f8:	89 81       	ldd	r24, Y+1	; 0x01
    17fa:	88 2f       	mov	r24, r24
    17fc:	90 e0       	ldi	r25, 0x00	; 0
    17fe:	20 ec       	ldi	r18, 0xC0	; 192
    1800:	38 e0       	ldi	r19, 0x08	; 8
    1802:	f9 01       	movw	r30, r18
    1804:	23 81       	ldd	r18, Z+3	; 0x03
    1806:	8a 5a       	subi	r24, 0xAA	; 170
    1808:	9f 4a       	sbci	r25, 0xAF	; 175
    180a:	fc 01       	movw	r30, r24
    180c:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    180e:	89 81       	ldd	r24, Y+1	; 0x01
    1810:	8f 5f       	subi	r24, 0xFF	; 255
    1812:	89 83       	std	Y+1, r24	; 0x01
    1814:	89 81       	ldd	r24, Y+1	; 0x01
    1816:	83 30       	cpi	r24, 0x03	; 3
    1818:	18 f3       	brcs	.-58     	; 0x17e0 <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    181a:	80 ea       	ldi	r24, 0xA0	; 160
    181c:	96 e0       	ldi	r25, 0x06	; 6
    181e:	22 e0       	ldi	r18, 0x02	; 2
    1820:	fc 01       	movw	r30, r24
    1822:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1824:	80 e0       	ldi	r24, 0x00	; 0
    1826:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    182a:	80 91 56 50 	lds	r24, 0x5056
    182e:	88 23       	and	r24, r24
    1830:	34 f4       	brge	.+12     	; 0x183e <__vector_105+0xe8>
    1832:	87 e5       	ldi	r24, 0x57	; 87
    1834:	90 e4       	ldi	r25, 0x40	; 64
    1836:	2f ef       	ldi	r18, 0xFF	; 255
    1838:	fc 01       	movw	r30, r24
    183a:	20 83       	st	Z, r18
    183c:	04 c0       	rjmp	.+8      	; 0x1846 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    183e:	87 e5       	ldi	r24, 0x57	; 87
    1840:	90 e4       	ldi	r25, 0x40	; 64
    1842:	fc 01       	movw	r30, r24
    1844:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1846:	86 e5       	ldi	r24, 0x56	; 86
    1848:	90 e4       	ldi	r25, 0x40	; 64
    184a:	20 91 56 50 	lds	r18, 0x5056
    184e:	fc 01       	movw	r30, r24
    1850:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1852:	85 e5       	ldi	r24, 0x55	; 85
    1854:	90 e4       	ldi	r25, 0x40	; 64
    1856:	20 91 57 50 	lds	r18, 0x5057
    185a:	fc 01       	movw	r30, r24
    185c:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    185e:	84 e5       	ldi	r24, 0x54	; 84
    1860:	90 e4       	ldi	r25, 0x40	; 64
    1862:	20 91 58 50 	lds	r18, 0x5058
    1866:	fc 01       	movw	r30, r24
    1868:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    186a:	80 91 54 40 	lds	r24, 0x4054
    186e:	90 91 55 40 	lds	r25, 0x4055
    1872:	a0 91 56 40 	lds	r26, 0x4056
    1876:	b0 91 57 40 	lds	r27, 0x4057
    187a:	5c 01       	movw	r10, r24
    187c:	6d 01       	movw	r12, r26
    187e:	bb 0f       	add	r27, r27
    1880:	88 0b       	sbc	r24, r24
    1882:	98 2f       	mov	r25, r24
    1884:	dc 01       	movw	r26, r24
    1886:	e8 2e       	mov	r14, r24
    1888:	f8 2e       	mov	r15, r24
    188a:	08 2f       	mov	r16, r24
    188c:	18 2f       	mov	r17, r24
    188e:	a0 92 97 50 	sts	0x5097, r10
    1892:	b0 92 98 50 	sts	0x5098, r11
    1896:	c0 92 99 50 	sts	0x5099, r12
    189a:	d0 92 9a 50 	sts	0x509A, r13
    189e:	e0 92 9b 50 	sts	0x509B, r14
    18a2:	f0 92 9c 50 	sts	0x509C, r15
    18a6:	00 93 9d 50 	sts	0x509D, r16
    18aa:	10 93 9e 50 	sts	0x509E, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    18ae:	80 91 65 50 	lds	r24, 0x5065
    18b2:	90 91 66 50 	lds	r25, 0x5066
    18b6:	a0 91 67 50 	lds	r26, 0x5067
    18ba:	b0 91 68 50 	lds	r27, 0x5068
    18be:	88 0f       	add	r24, r24
    18c0:	99 1f       	adc	r25, r25
    18c2:	88 0f       	add	r24, r24
    18c4:	99 1f       	adc	r25, r25
    18c6:	9c 01       	movw	r18, r24
    18c8:	20 53       	subi	r18, 0x30	; 48
    18ca:	3c 4d       	sbci	r19, 0xDC	; 220
    18cc:	2a 83       	std	Y+2, r18	; 0x02
    18ce:	3b 83       	std	Y+3, r19	; 0x03
    18d0:	a0 90 97 50 	lds	r10, 0x5097
    18d4:	b0 90 98 50 	lds	r11, 0x5098
    18d8:	c0 90 99 50 	lds	r12, 0x5099
    18dc:	d0 90 9a 50 	lds	r13, 0x509A
    18e0:	e0 90 9b 50 	lds	r14, 0x509B
    18e4:	f0 90 9c 50 	lds	r15, 0x509C
    18e8:	00 91 9d 50 	lds	r16, 0x509D
    18ec:	10 91 9e 50 	lds	r17, 0x509E
    18f0:	2a 2d       	mov	r18, r10
    18f2:	3b 2d       	mov	r19, r11
    18f4:	4c 2d       	mov	r20, r12
    18f6:	5d 2d       	mov	r21, r13
    18f8:	6e 2d       	mov	r22, r14
    18fa:	7f 2d       	mov	r23, r15
    18fc:	80 2f       	mov	r24, r16
    18fe:	91 2f       	mov	r25, r17
    1900:	0f 2e       	mov	r0, r31
    1902:	f0 ea       	ldi	r31, 0xA0	; 160
    1904:	af 2e       	mov	r10, r31
    1906:	f0 2d       	mov	r31, r0
    1908:	0f 2e       	mov	r0, r31
    190a:	f5 e2       	ldi	r31, 0x25	; 37
    190c:	bf 2e       	mov	r11, r31
    190e:	f0 2d       	mov	r31, r0
    1910:	0f 2e       	mov	r0, r31
    1912:	f6 e2       	ldi	r31, 0x26	; 38
    1914:	cf 2e       	mov	r12, r31
    1916:	f0 2d       	mov	r31, r0
    1918:	dd 24       	eor	r13, r13
    191a:	ee 24       	eor	r14, r14
    191c:	ff 24       	eor	r15, r15
    191e:	00 e0       	ldi	r16, 0x00	; 0
    1920:	10 e0       	ldi	r17, 0x00	; 0
    1922:	0e 94 61 52 	call	0xa4c2	; 0xa4c2 <__muldi3>
    1926:	22 2e       	mov	r2, r18
    1928:	33 2e       	mov	r3, r19
    192a:	44 2e       	mov	r4, r20
    192c:	55 2e       	mov	r5, r21
    192e:	66 2e       	mov	r6, r22
    1930:	77 2e       	mov	r7, r23
    1932:	88 2e       	mov	r8, r24
    1934:	99 2e       	mov	r9, r25
    1936:	a2 2c       	mov	r10, r2
    1938:	b3 2c       	mov	r11, r3
    193a:	c4 2c       	mov	r12, r4
    193c:	d5 2c       	mov	r13, r5
    193e:	e6 2c       	mov	r14, r6
    1940:	f7 2c       	mov	r15, r7
    1942:	08 2d       	mov	r16, r8
    1944:	19 2d       	mov	r17, r9
    1946:	2a 2d       	mov	r18, r10
    1948:	3b 2d       	mov	r19, r11
    194a:	4c 2d       	mov	r20, r12
    194c:	5d 2d       	mov	r21, r13
    194e:	6e 2d       	mov	r22, r14
    1950:	7f 2d       	mov	r23, r15
    1952:	80 2f       	mov	r24, r16
    1954:	91 2f       	mov	r25, r17
    1956:	aa 24       	eor	r10, r10
    1958:	aa 94       	dec	r10
    195a:	bb 24       	eor	r11, r11
    195c:	ba 94       	dec	r11
    195e:	0f 2e       	mov	r0, r31
    1960:	ff e7       	ldi	r31, 0x7F	; 127
    1962:	cf 2e       	mov	r12, r31
    1964:	f0 2d       	mov	r31, r0
    1966:	dd 24       	eor	r13, r13
    1968:	ee 24       	eor	r14, r14
    196a:	ff 24       	eor	r15, r15
    196c:	00 e0       	ldi	r16, 0x00	; 0
    196e:	10 e0       	ldi	r17, 0x00	; 0
    1970:	0e 94 a8 53 	call	0xa750	; 0xa750 <__divdi3>
    1974:	22 2e       	mov	r2, r18
    1976:	33 2e       	mov	r3, r19
    1978:	44 2e       	mov	r4, r20
    197a:	55 2e       	mov	r5, r21
    197c:	66 2e       	mov	r6, r22
    197e:	77 2e       	mov	r7, r23
    1980:	88 2e       	mov	r8, r24
    1982:	99 2e       	mov	r9, r25
    1984:	a2 2c       	mov	r10, r2
    1986:	b3 2c       	mov	r11, r3
    1988:	c4 2c       	mov	r12, r4
    198a:	d5 2c       	mov	r13, r5
    198c:	e6 2c       	mov	r14, r6
    198e:	f7 2c       	mov	r15, r7
    1990:	08 2d       	mov	r16, r8
    1992:	19 2d       	mov	r17, r9
    1994:	2a 2d       	mov	r18, r10
    1996:	3b 2d       	mov	r19, r11
    1998:	4c 2d       	mov	r20, r12
    199a:	5d 2d       	mov	r21, r13
    199c:	6e 2d       	mov	r22, r14
    199e:	7f 2d       	mov	r23, r15
    19a0:	80 2f       	mov	r24, r16
    19a2:	91 2f       	mov	r25, r17
    19a4:	01 e0       	ldi	r16, 0x01	; 1
    19a6:	0e 94 34 53 	call	0xa668	; 0xa668 <__ashldi3>
    19aa:	22 2e       	mov	r2, r18
    19ac:	33 2e       	mov	r3, r19
    19ae:	44 2e       	mov	r4, r20
    19b0:	55 2e       	mov	r5, r21
    19b2:	66 2e       	mov	r6, r22
    19b4:	77 2e       	mov	r7, r23
    19b6:	88 2e       	mov	r8, r24
    19b8:	99 2e       	mov	r9, r25
    19ba:	a2 2c       	mov	r10, r2
    19bc:	b3 2c       	mov	r11, r3
    19be:	c4 2c       	mov	r12, r4
    19c0:	d5 2c       	mov	r13, r5
    19c2:	e6 2c       	mov	r14, r6
    19c4:	f7 2c       	mov	r15, r7
    19c6:	08 2d       	mov	r16, r8
    19c8:	19 2d       	mov	r17, r9
    19ca:	2a 2d       	mov	r18, r10
    19cc:	3b 2d       	mov	r19, r11
    19ce:	4c 2d       	mov	r20, r12
    19d0:	5d 2d       	mov	r21, r13
    19d2:	6e 2d       	mov	r22, r14
    19d4:	7f 2d       	mov	r23, r15
    19d6:	80 2f       	mov	r24, r16
    19d8:	91 2f       	mov	r25, r17
    19da:	0f 2e       	mov	r0, r31
    19dc:	f3 e0       	ldi	r31, 0x03	; 3
    19de:	af 2e       	mov	r10, r31
    19e0:	f0 2d       	mov	r31, r0
    19e2:	bb 24       	eor	r11, r11
    19e4:	cc 24       	eor	r12, r12
    19e6:	dd 24       	eor	r13, r13
    19e8:	ee 24       	eor	r14, r14
    19ea:	ff 24       	eor	r15, r15
    19ec:	00 e0       	ldi	r16, 0x00	; 0
    19ee:	10 e0       	ldi	r17, 0x00	; 0
    19f0:	0e 94 a8 53 	call	0xa750	; 0xa750 <__divdi3>
    19f4:	a2 2e       	mov	r10, r18
    19f6:	b3 2e       	mov	r11, r19
    19f8:	c4 2e       	mov	r12, r20
    19fa:	d5 2e       	mov	r13, r21
    19fc:	e6 2e       	mov	r14, r22
    19fe:	f7 2e       	mov	r15, r23
    1a00:	08 2f       	mov	r16, r24
    1a02:	19 2f       	mov	r17, r25
    1a04:	2a 2d       	mov	r18, r10
    1a06:	3b 2d       	mov	r19, r11
    1a08:	4c 2d       	mov	r20, r12
    1a0a:	5d 2d       	mov	r21, r13
    1a0c:	6e 2d       	mov	r22, r14
    1a0e:	7f 2d       	mov	r23, r15
    1a10:	80 2f       	mov	r24, r16
    1a12:	91 2f       	mov	r25, r17
    1a14:	da 01       	movw	r26, r20
    1a16:	c9 01       	movw	r24, r18
    1a18:	b0 95       	com	r27
    1a1a:	a0 95       	com	r26
    1a1c:	90 95       	com	r25
    1a1e:	81 95       	neg	r24
    1a20:	9f 4f       	sbci	r25, 0xFF	; 255
    1a22:	af 4f       	sbci	r26, 0xFF	; 255
    1a24:	bf 4f       	sbci	r27, 0xFF	; 255
    1a26:	ea 81       	ldd	r30, Y+2	; 0x02
    1a28:	fb 81       	ldd	r31, Y+3	; 0x03
    1a2a:	80 83       	st	Z, r24
    1a2c:	91 83       	std	Z+1, r25	; 0x01
    1a2e:	a2 83       	std	Z+2, r26	; 0x02
    1a30:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    1a32:	80 91 65 50 	lds	r24, 0x5065
    1a36:	90 91 66 50 	lds	r25, 0x5066
    1a3a:	a0 91 67 50 	lds	r26, 0x5067
    1a3e:	b0 91 68 50 	lds	r27, 0x5068
    1a42:	01 96       	adiw	r24, 0x01	; 1
    1a44:	a1 1d       	adc	r26, r1
    1a46:	b1 1d       	adc	r27, r1
    1a48:	80 93 65 50 	sts	0x5065, r24
    1a4c:	90 93 66 50 	sts	0x5066, r25
    1a50:	a0 93 67 50 	sts	0x5067, r26
    1a54:	b0 93 68 50 	sts	0x5068, r27
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    1a58:	80 91 65 50 	lds	r24, 0x5065
    1a5c:	90 91 66 50 	lds	r25, 0x5066
    1a60:	a0 91 67 50 	lds	r26, 0x5067
    1a64:	b0 91 68 50 	lds	r27, 0x5068
    1a68:	8e 31       	cpi	r24, 0x1E	; 30
    1a6a:	91 05       	cpc	r25, r1
    1a6c:	a1 05       	cpc	r26, r1
    1a6e:	b1 05       	cpc	r27, r1
    1a70:	08 f4       	brcc	.+2      	; 0x1a74 <__vector_105+0x31e>
    1a72:	53 c0       	rjmp	.+166    	; 0x1b1a <__vector_105+0x3c4>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    1a74:	10 92 65 50 	sts	0x5065, r1
    1a78:	10 92 66 50 	sts	0x5066, r1
    1a7c:	10 92 67 50 	sts	0x5067, r1
    1a80:	10 92 68 50 	sts	0x5068, r1
		TotalSampleCount++;
    1a84:	80 91 95 50 	lds	r24, 0x5095
    1a88:	90 91 96 50 	lds	r25, 0x5096
    1a8c:	01 96       	adiw	r24, 0x01	; 1
    1a8e:	80 93 95 50 	sts	0x5095, r24
    1a92:	90 93 96 50 	sts	0x5096, r25
		discardCount = ADC_DISCARD -1; //discard the next sample after pausing the sampling to send/store data since the sample ready flag will be outdated and the value might be bad
    1a96:	8f e7       	ldi	r24, 0x7F	; 127
    1a98:	80 93 4e 40 	sts	0x404E, r24
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove((void*)FRAMReadBuffer+2,(const void*)FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    1a9c:	80 91 65 50 	lds	r24, 0x5065
    1aa0:	90 91 66 50 	lds	r25, 0x5066
    1aa4:	a0 91 67 50 	lds	r26, 0x5067
    1aa8:	b0 91 68 50 	lds	r27, 0x5068
    1aac:	9c 01       	movw	r18, r24
    1aae:	22 0f       	add	r18, r18
    1ab0:	33 1f       	adc	r19, r19
    1ab2:	22 0f       	add	r18, r18
    1ab4:	33 1f       	adc	r19, r19
    1ab6:	82 ed       	ldi	r24, 0xD2	; 210
    1ab8:	93 e2       	ldi	r25, 0x23	; 35
    1aba:	40 ed       	ldi	r20, 0xD0	; 208
    1abc:	53 e2       	ldi	r21, 0x23	; 35
    1abe:	ba 01       	movw	r22, r20
    1ac0:	a9 01       	movw	r20, r18
    1ac2:	0e 94 35 5e 	call	0xbc6a	; 0xbc6a <memmove>
		FRAMReadBuffer[0] = moteID;		//send moteID of the mote that gathered the data
    1ac6:	80 91 c1 50 	lds	r24, 0x50C1
    1aca:	80 93 d0 23 	sts	0x23D0, r24
		FRAMReadBuffer[1] = (uint8_t)sampleCount;	//send the number of data samples gathered cast as a byte since no more than 30/31 samples should be send at a time
    1ace:	80 91 65 50 	lds	r24, 0x5065
    1ad2:	90 91 66 50 	lds	r25, 0x5066
    1ad6:	a0 91 67 50 	lds	r26, 0x5067
    1ada:	b0 91 68 50 	lds	r27, 0x5068
    1ade:	80 93 d1 23 	sts	0x23D1, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+2);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    1ae2:	80 91 65 50 	lds	r24, 0x5065
    1ae6:	90 91 66 50 	lds	r25, 0x5066
    1aea:	a0 91 67 50 	lds	r26, 0x5067
    1aee:	b0 91 68 50 	lds	r27, 0x5068
    1af2:	88 0f       	add	r24, r24
    1af4:	99 1f       	adc	r25, r25
    1af6:	aa 1f       	adc	r26, r26
    1af8:	bb 1f       	adc	r27, r27
    1afa:	88 0f       	add	r24, r24
    1afc:	99 1f       	adc	r25, r25
    1afe:	aa 1f       	adc	r26, r26
    1b00:	bb 1f       	adc	r27, r27
    1b02:	9c 01       	movw	r18, r24
    1b04:	ad 01       	movw	r20, r26
    1b06:	2e 5f       	subi	r18, 0xFE	; 254
    1b08:	3f 4f       	sbci	r19, 0xFF	; 255
    1b0a:	4f 4f       	sbci	r20, 0xFF	; 255
    1b0c:	5f 4f       	sbci	r21, 0xFF	; 255
    1b0e:	60 ed       	ldi	r22, 0xD0	; 208
    1b10:	73 e2       	ldi	r23, 0x23	; 35
    1b12:	80 e0       	ldi	r24, 0x00	; 0
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <chb_write>
	}	
	}	
}
    1b1a:	23 96       	adiw	r28, 0x03	; 3
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	de bf       	out	0x3e, r29	; 62
    1b20:	df 91       	pop	r29
    1b22:	cf 91       	pop	r28
    1b24:	ff 91       	pop	r31
    1b26:	ef 91       	pop	r30
    1b28:	bf 91       	pop	r27
    1b2a:	af 91       	pop	r26
    1b2c:	9f 91       	pop	r25
    1b2e:	8f 91       	pop	r24
    1b30:	7f 91       	pop	r23
    1b32:	6f 91       	pop	r22
    1b34:	5f 91       	pop	r21
    1b36:	4f 91       	pop	r20
    1b38:	3f 91       	pop	r19
    1b3a:	2f 91       	pop	r18
    1b3c:	1f 91       	pop	r17
    1b3e:	0f 91       	pop	r16
    1b40:	ff 90       	pop	r15
    1b42:	ef 90       	pop	r14
    1b44:	df 90       	pop	r13
    1b46:	cf 90       	pop	r12
    1b48:	bf 90       	pop	r11
    1b4a:	af 90       	pop	r10
    1b4c:	9f 90       	pop	r9
    1b4e:	8f 90       	pop	r8
    1b50:	7f 90       	pop	r7
    1b52:	6f 90       	pop	r6
    1b54:	5f 90       	pop	r5
    1b56:	4f 90       	pop	r4
    1b58:	3f 90       	pop	r3
    1b5a:	2f 90       	pop	r2
    1b5c:	0f 90       	pop	r0
    1b5e:	00 92 3b 00 	sts	0x003B, r0
    1b62:	0f 90       	pop	r0
    1b64:	0f be       	out	0x3f, r0	; 63
    1b66:	0f 90       	pop	r0
    1b68:	1f 90       	pop	r1
    1b6a:	18 95       	reti

00001b6c <__vector_104>:

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    1b6c:	1f 92       	push	r1
    1b6e:	0f 92       	push	r0
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	0f 92       	push	r0
    1b74:	00 90 3b 00 	lds	r0, 0x003B
    1b78:	0f 92       	push	r0
    1b7a:	11 24       	eor	r1, r1
    1b7c:	2f 92       	push	r2
    1b7e:	3f 92       	push	r3
    1b80:	4f 92       	push	r4
    1b82:	5f 92       	push	r5
    1b84:	6f 92       	push	r6
    1b86:	7f 92       	push	r7
    1b88:	8f 92       	push	r8
    1b8a:	9f 92       	push	r9
    1b8c:	af 92       	push	r10
    1b8e:	bf 92       	push	r11
    1b90:	cf 92       	push	r12
    1b92:	df 92       	push	r13
    1b94:	ef 92       	push	r14
    1b96:	ff 92       	push	r15
    1b98:	0f 93       	push	r16
    1b9a:	1f 93       	push	r17
    1b9c:	2f 93       	push	r18
    1b9e:	3f 93       	push	r19
    1ba0:	4f 93       	push	r20
    1ba2:	5f 93       	push	r21
    1ba4:	6f 93       	push	r22
    1ba6:	7f 93       	push	r23
    1ba8:	8f 93       	push	r24
    1baa:	9f 93       	push	r25
    1bac:	af 93       	push	r26
    1bae:	bf 93       	push	r27
    1bb0:	ef 93       	push	r30
    1bb2:	ff 93       	push	r31
    1bb4:	cf 93       	push	r28
    1bb6:	df 93       	push	r29
    1bb8:	cd b7       	in	r28, 0x3d	; 61
    1bba:	de b7       	in	r29, 0x3e	; 62
    1bbc:	27 97       	sbiw	r28, 0x07	; 7
    1bbe:	cd bf       	out	0x3d, r28	; 61
    1bc0:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	if (discardCount < ADC_DISCARD) {
    1bc2:	80 91 4e 40 	lds	r24, 0x404E
    1bc6:	88 23       	and	r24, r24
    1bc8:	34 f0       	brlt	.+12     	; 0x1bd6 <__vector_104+0x6a>
		discardCount++;
    1bca:	80 91 4e 40 	lds	r24, 0x404E
    1bce:	8f 5f       	subi	r24, 0xFF	; 255
    1bd0:	80 93 4e 40 	sts	0x404E, r24
    1bd4:	4a c1       	rjmp	.+660    	; 0x1e6a <__vector_104+0x2fe>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1bd6:	81 e0       	ldi	r24, 0x01	; 1
    1bd8:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1bdc:	80 ea       	ldi	r24, 0xA0	; 160
    1bde:	96 e0       	ldi	r25, 0x06	; 6
    1be0:	22 e0       	ldi	r18, 0x02	; 2
    1be2:	fc 01       	movw	r30, r24
    1be4:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1be6:	19 82       	std	Y+1, r1	; 0x01
    1be8:	1a c0       	rjmp	.+52     	; 0x1c1e <__vector_104+0xb2>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1bea:	80 ec       	ldi	r24, 0xC0	; 192
    1bec:	98 e0       	ldi	r25, 0x08	; 8
    1bee:	2a ea       	ldi	r18, 0xAA	; 170
    1bf0:	fc 01       	movw	r30, r24
    1bf2:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1bf4:	00 00       	nop
    1bf6:	80 ec       	ldi	r24, 0xC0	; 192
    1bf8:	98 e0       	ldi	r25, 0x08	; 8
    1bfa:	fc 01       	movw	r30, r24
    1bfc:	82 81       	ldd	r24, Z+2	; 0x02
    1bfe:	88 23       	and	r24, r24
    1c00:	d4 f7       	brge	.-12     	; 0x1bf6 <__vector_104+0x8a>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1c02:	89 81       	ldd	r24, Y+1	; 0x01
    1c04:	88 2f       	mov	r24, r24
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	20 ec       	ldi	r18, 0xC0	; 192
    1c0a:	38 e0       	ldi	r19, 0x08	; 8
    1c0c:	f9 01       	movw	r30, r18
    1c0e:	23 81       	ldd	r18, Z+3	; 0x03
    1c10:	8a 5a       	subi	r24, 0xAA	; 170
    1c12:	9f 4a       	sbci	r25, 0xAF	; 175
    1c14:	fc 01       	movw	r30, r24
    1c16:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1c18:	89 81       	ldd	r24, Y+1	; 0x01
    1c1a:	8f 5f       	subi	r24, 0xFF	; 255
    1c1c:	89 83       	std	Y+1, r24	; 0x01
    1c1e:	89 81       	ldd	r24, Y+1	; 0x01
    1c20:	83 30       	cpi	r24, 0x03	; 3
    1c22:	18 f3       	brcs	.-58     	; 0x1bea <__vector_104+0x7e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1c24:	80 ea       	ldi	r24, 0xA0	; 160
    1c26:	96 e0       	ldi	r25, 0x06	; 6
    1c28:	22 e0       	ldi	r18, 0x02	; 2
    1c2a:	fc 01       	movw	r30, r24
    1c2c:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1c2e:	80 e0       	ldi	r24, 0x00	; 0
    1c30:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1c34:	80 91 56 50 	lds	r24, 0x5056
    1c38:	88 23       	and	r24, r24
    1c3a:	3c f4       	brge	.+14     	; 0x1c4a <__vector_104+0xde>
    1c3c:	ce 01       	movw	r24, r28
    1c3e:	02 96       	adiw	r24, 0x02	; 2
    1c40:	03 96       	adiw	r24, 0x03	; 3
    1c42:	2f ef       	ldi	r18, 0xFF	; 255
    1c44:	fc 01       	movw	r30, r24
    1c46:	20 83       	st	Z, r18
    1c48:	05 c0       	rjmp	.+10     	; 0x1c54 <__vector_104+0xe8>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1c4a:	ce 01       	movw	r24, r28
    1c4c:	02 96       	adiw	r24, 0x02	; 2
    1c4e:	03 96       	adiw	r24, 0x03	; 3
    1c50:	fc 01       	movw	r30, r24
    1c52:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    1c54:	ce 01       	movw	r24, r28
    1c56:	02 96       	adiw	r24, 0x02	; 2
    1c58:	02 96       	adiw	r24, 0x02	; 2
    1c5a:	20 91 56 50 	lds	r18, 0x5056
    1c5e:	fc 01       	movw	r30, r24
    1c60:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1c62:	ce 01       	movw	r24, r28
    1c64:	02 96       	adiw	r24, 0x02	; 2
    1c66:	01 96       	adiw	r24, 0x01	; 1
    1c68:	20 91 57 50 	lds	r18, 0x5057
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    1c70:	ce 01       	movw	r24, r28
    1c72:	02 96       	adiw	r24, 0x02	; 2
    1c74:	20 91 58 50 	lds	r18, 0x5058
    1c78:	fc 01       	movw	r30, r24
    1c7a:	20 83       	st	Z, r18
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1c80:	ac 81       	ldd	r26, Y+4	; 0x04
    1c82:	bd 81       	ldd	r27, Y+5	; 0x05
    1c84:	5c 01       	movw	r10, r24
    1c86:	6d 01       	movw	r12, r26
    1c88:	bb 0f       	add	r27, r27
    1c8a:	88 0b       	sbc	r24, r24
    1c8c:	98 2f       	mov	r25, r24
    1c8e:	dc 01       	movw	r26, r24
    1c90:	e8 2e       	mov	r14, r24
    1c92:	f8 2e       	mov	r15, r24
    1c94:	08 2f       	mov	r16, r24
    1c96:	18 2f       	mov	r17, r24
    1c98:	a0 92 97 50 	sts	0x5097, r10
    1c9c:	b0 92 98 50 	sts	0x5098, r11
    1ca0:	c0 92 99 50 	sts	0x5099, r12
    1ca4:	d0 92 9a 50 	sts	0x509A, r13
    1ca8:	e0 92 9b 50 	sts	0x509B, r14
    1cac:	f0 92 9c 50 	sts	0x509C, r15
    1cb0:	00 93 9d 50 	sts	0x509D, r16
    1cb4:	10 93 9e 50 	sts	0x509E, r17
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1cb8:	20 91 63 50 	lds	r18, 0x5063
    1cbc:	30 91 64 50 	lds	r19, 0x5064
    1cc0:	80 91 65 50 	lds	r24, 0x5065
    1cc4:	90 91 66 50 	lds	r25, 0x5066
    1cc8:	a0 91 67 50 	lds	r26, 0x5067
    1ccc:	b0 91 68 50 	lds	r27, 0x5068
    1cd0:	88 0f       	add	r24, r24
    1cd2:	99 1f       	adc	r25, r25
    1cd4:	88 0f       	add	r24, r24
    1cd6:	99 1f       	adc	r25, r25
    1cd8:	a9 01       	movw	r20, r18
    1cda:	48 0f       	add	r20, r24
    1cdc:	59 1f       	adc	r21, r25
    1cde:	4e 83       	std	Y+6, r20	; 0x06
    1ce0:	5f 83       	std	Y+7, r21	; 0x07
    1ce2:	a0 90 97 50 	lds	r10, 0x5097
    1ce6:	b0 90 98 50 	lds	r11, 0x5098
    1cea:	c0 90 99 50 	lds	r12, 0x5099
    1cee:	d0 90 9a 50 	lds	r13, 0x509A
    1cf2:	e0 90 9b 50 	lds	r14, 0x509B
    1cf6:	f0 90 9c 50 	lds	r15, 0x509C
    1cfa:	00 91 9d 50 	lds	r16, 0x509D
    1cfe:	10 91 9e 50 	lds	r17, 0x509E
    1d02:	2a 2d       	mov	r18, r10
    1d04:	3b 2d       	mov	r19, r11
    1d06:	4c 2d       	mov	r20, r12
    1d08:	5d 2d       	mov	r21, r13
    1d0a:	6e 2d       	mov	r22, r14
    1d0c:	7f 2d       	mov	r23, r15
    1d0e:	80 2f       	mov	r24, r16
    1d10:	91 2f       	mov	r25, r17
    1d12:	0f 2e       	mov	r0, r31
    1d14:	f0 ea       	ldi	r31, 0xA0	; 160
    1d16:	af 2e       	mov	r10, r31
    1d18:	f0 2d       	mov	r31, r0
    1d1a:	0f 2e       	mov	r0, r31
    1d1c:	f5 e2       	ldi	r31, 0x25	; 37
    1d1e:	bf 2e       	mov	r11, r31
    1d20:	f0 2d       	mov	r31, r0
    1d22:	0f 2e       	mov	r0, r31
    1d24:	f6 e2       	ldi	r31, 0x26	; 38
    1d26:	cf 2e       	mov	r12, r31
    1d28:	f0 2d       	mov	r31, r0
    1d2a:	dd 24       	eor	r13, r13
    1d2c:	ee 24       	eor	r14, r14
    1d2e:	ff 24       	eor	r15, r15
    1d30:	00 e0       	ldi	r16, 0x00	; 0
    1d32:	10 e0       	ldi	r17, 0x00	; 0
    1d34:	0e 94 61 52 	call	0xa4c2	; 0xa4c2 <__muldi3>
    1d38:	22 2e       	mov	r2, r18
    1d3a:	33 2e       	mov	r3, r19
    1d3c:	44 2e       	mov	r4, r20
    1d3e:	55 2e       	mov	r5, r21
    1d40:	66 2e       	mov	r6, r22
    1d42:	77 2e       	mov	r7, r23
    1d44:	88 2e       	mov	r8, r24
    1d46:	99 2e       	mov	r9, r25
    1d48:	a2 2c       	mov	r10, r2
    1d4a:	b3 2c       	mov	r11, r3
    1d4c:	c4 2c       	mov	r12, r4
    1d4e:	d5 2c       	mov	r13, r5
    1d50:	e6 2c       	mov	r14, r6
    1d52:	f7 2c       	mov	r15, r7
    1d54:	08 2d       	mov	r16, r8
    1d56:	19 2d       	mov	r17, r9
    1d58:	2a 2d       	mov	r18, r10
    1d5a:	3b 2d       	mov	r19, r11
    1d5c:	4c 2d       	mov	r20, r12
    1d5e:	5d 2d       	mov	r21, r13
    1d60:	6e 2d       	mov	r22, r14
    1d62:	7f 2d       	mov	r23, r15
    1d64:	80 2f       	mov	r24, r16
    1d66:	91 2f       	mov	r25, r17
    1d68:	aa 24       	eor	r10, r10
    1d6a:	aa 94       	dec	r10
    1d6c:	bb 24       	eor	r11, r11
    1d6e:	ba 94       	dec	r11
    1d70:	0f 2e       	mov	r0, r31
    1d72:	ff e7       	ldi	r31, 0x7F	; 127
    1d74:	cf 2e       	mov	r12, r31
    1d76:	f0 2d       	mov	r31, r0
    1d78:	dd 24       	eor	r13, r13
    1d7a:	ee 24       	eor	r14, r14
    1d7c:	ff 24       	eor	r15, r15
    1d7e:	00 e0       	ldi	r16, 0x00	; 0
    1d80:	10 e0       	ldi	r17, 0x00	; 0
    1d82:	0e 94 a8 53 	call	0xa750	; 0xa750 <__divdi3>
    1d86:	22 2e       	mov	r2, r18
    1d88:	33 2e       	mov	r3, r19
    1d8a:	44 2e       	mov	r4, r20
    1d8c:	55 2e       	mov	r5, r21
    1d8e:	66 2e       	mov	r6, r22
    1d90:	77 2e       	mov	r7, r23
    1d92:	88 2e       	mov	r8, r24
    1d94:	99 2e       	mov	r9, r25
    1d96:	a2 2c       	mov	r10, r2
    1d98:	b3 2c       	mov	r11, r3
    1d9a:	c4 2c       	mov	r12, r4
    1d9c:	d5 2c       	mov	r13, r5
    1d9e:	e6 2c       	mov	r14, r6
    1da0:	f7 2c       	mov	r15, r7
    1da2:	08 2d       	mov	r16, r8
    1da4:	19 2d       	mov	r17, r9
    1da6:	2a 2d       	mov	r18, r10
    1da8:	3b 2d       	mov	r19, r11
    1daa:	4c 2d       	mov	r20, r12
    1dac:	5d 2d       	mov	r21, r13
    1dae:	6e 2d       	mov	r22, r14
    1db0:	7f 2d       	mov	r23, r15
    1db2:	80 2f       	mov	r24, r16
    1db4:	91 2f       	mov	r25, r17
    1db6:	01 e0       	ldi	r16, 0x01	; 1
    1db8:	0e 94 34 53 	call	0xa668	; 0xa668 <__ashldi3>
    1dbc:	22 2e       	mov	r2, r18
    1dbe:	33 2e       	mov	r3, r19
    1dc0:	44 2e       	mov	r4, r20
    1dc2:	55 2e       	mov	r5, r21
    1dc4:	66 2e       	mov	r6, r22
    1dc6:	77 2e       	mov	r7, r23
    1dc8:	88 2e       	mov	r8, r24
    1dca:	99 2e       	mov	r9, r25
    1dcc:	a2 2c       	mov	r10, r2
    1dce:	b3 2c       	mov	r11, r3
    1dd0:	c4 2c       	mov	r12, r4
    1dd2:	d5 2c       	mov	r13, r5
    1dd4:	e6 2c       	mov	r14, r6
    1dd6:	f7 2c       	mov	r15, r7
    1dd8:	08 2d       	mov	r16, r8
    1dda:	19 2d       	mov	r17, r9
    1ddc:	2a 2d       	mov	r18, r10
    1dde:	3b 2d       	mov	r19, r11
    1de0:	4c 2d       	mov	r20, r12
    1de2:	5d 2d       	mov	r21, r13
    1de4:	6e 2d       	mov	r22, r14
    1de6:	7f 2d       	mov	r23, r15
    1de8:	80 2f       	mov	r24, r16
    1dea:	91 2f       	mov	r25, r17
    1dec:	0f 2e       	mov	r0, r31
    1dee:	f3 e0       	ldi	r31, 0x03	; 3
    1df0:	af 2e       	mov	r10, r31
    1df2:	f0 2d       	mov	r31, r0
    1df4:	bb 24       	eor	r11, r11
    1df6:	cc 24       	eor	r12, r12
    1df8:	dd 24       	eor	r13, r13
    1dfa:	ee 24       	eor	r14, r14
    1dfc:	ff 24       	eor	r15, r15
    1dfe:	00 e0       	ldi	r16, 0x00	; 0
    1e00:	10 e0       	ldi	r17, 0x00	; 0
    1e02:	0e 94 a8 53 	call	0xa750	; 0xa750 <__divdi3>
    1e06:	a2 2e       	mov	r10, r18
    1e08:	b3 2e       	mov	r11, r19
    1e0a:	c4 2e       	mov	r12, r20
    1e0c:	d5 2e       	mov	r13, r21
    1e0e:	e6 2e       	mov	r14, r22
    1e10:	f7 2e       	mov	r15, r23
    1e12:	08 2f       	mov	r16, r24
    1e14:	19 2f       	mov	r17, r25
    1e16:	2a 2d       	mov	r18, r10
    1e18:	3b 2d       	mov	r19, r11
    1e1a:	4c 2d       	mov	r20, r12
    1e1c:	5d 2d       	mov	r21, r13
    1e1e:	6e 2d       	mov	r22, r14
    1e20:	7f 2d       	mov	r23, r15
    1e22:	80 2f       	mov	r24, r16
    1e24:	91 2f       	mov	r25, r17
    1e26:	da 01       	movw	r26, r20
    1e28:	c9 01       	movw	r24, r18
    1e2a:	b0 95       	com	r27
    1e2c:	a0 95       	com	r26
    1e2e:	90 95       	com	r25
    1e30:	81 95       	neg	r24
    1e32:	9f 4f       	sbci	r25, 0xFF	; 255
    1e34:	af 4f       	sbci	r26, 0xFF	; 255
    1e36:	bf 4f       	sbci	r27, 0xFF	; 255
    1e38:	ee 81       	ldd	r30, Y+6	; 0x06
    1e3a:	ff 81       	ldd	r31, Y+7	; 0x07
    1e3c:	80 83       	st	Z, r24
    1e3e:	91 83       	std	Z+1, r25	; 0x01
    1e40:	a2 83       	std	Z+2, r26	; 0x02
    1e42:	b3 83       	std	Z+3, r27	; 0x03
		sampleCount++;
    1e44:	80 91 65 50 	lds	r24, 0x5065
    1e48:	90 91 66 50 	lds	r25, 0x5066
    1e4c:	a0 91 67 50 	lds	r26, 0x5067
    1e50:	b0 91 68 50 	lds	r27, 0x5068
    1e54:	01 96       	adiw	r24, 0x01	; 1
    1e56:	a1 1d       	adc	r26, r1
    1e58:	b1 1d       	adc	r27, r1
    1e5a:	80 93 65 50 	sts	0x5065, r24
    1e5e:	90 93 66 50 	sts	0x5066, r25
    1e62:	a0 93 67 50 	sts	0x5067, r26
    1e66:	b0 93 68 50 	sts	0x5068, r27
	}
}
    1e6a:	27 96       	adiw	r28, 0x07	; 7
    1e6c:	cd bf       	out	0x3d, r28	; 61
    1e6e:	de bf       	out	0x3e, r29	; 62
    1e70:	df 91       	pop	r29
    1e72:	cf 91       	pop	r28
    1e74:	ff 91       	pop	r31
    1e76:	ef 91       	pop	r30
    1e78:	bf 91       	pop	r27
    1e7a:	af 91       	pop	r26
    1e7c:	9f 91       	pop	r25
    1e7e:	8f 91       	pop	r24
    1e80:	7f 91       	pop	r23
    1e82:	6f 91       	pop	r22
    1e84:	5f 91       	pop	r21
    1e86:	4f 91       	pop	r20
    1e88:	3f 91       	pop	r19
    1e8a:	2f 91       	pop	r18
    1e8c:	1f 91       	pop	r17
    1e8e:	0f 91       	pop	r16
    1e90:	ff 90       	pop	r15
    1e92:	ef 90       	pop	r14
    1e94:	df 90       	pop	r13
    1e96:	cf 90       	pop	r12
    1e98:	bf 90       	pop	r11
    1e9a:	af 90       	pop	r10
    1e9c:	9f 90       	pop	r9
    1e9e:	8f 90       	pop	r8
    1ea0:	7f 90       	pop	r7
    1ea2:	6f 90       	pop	r6
    1ea4:	5f 90       	pop	r5
    1ea6:	4f 90       	pop	r4
    1ea8:	3f 90       	pop	r3
    1eaa:	2f 90       	pop	r2
    1eac:	0f 90       	pop	r0
    1eae:	00 92 3b 00 	sts	0x003B, r0
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63
    1eb6:	0f 90       	pop	r0
    1eb8:	1f 90       	pop	r1
    1eba:	18 95       	reti

00001ebc <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1ebc:	cf 93       	push	r28
    1ebe:	df 93       	push	r29
    1ec0:	0f 92       	push	r0
    1ec2:	cd b7       	in	r28, 0x3d	; 61
    1ec4:	de b7       	in	r29, 0x3e	; 62
    1ec6:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1ec8:	89 81       	ldd	r24, Y+1	; 0x01
    1eca:	88 23       	and	r24, r24
    1ecc:	49 f0       	breq	.+18     	; 0x1ee0 <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1ece:	80 e2       	ldi	r24, 0x20	; 32
    1ed0:	60 e0       	ldi	r22, 0x00	; 0
    1ed2:	0e 94 d7 33 	call	0x67ae	; 0x67ae <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1ed6:	80 e2       	ldi	r24, 0x20	; 32
    1ed8:	60 e0       	ldi	r22, 0x00	; 0
    1eda:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
    1ede:	04 c0       	rjmp	.+8      	; 0x1ee8 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1ee0:	80 e2       	ldi	r24, 0x20	; 32
    1ee2:	60 e0       	ldi	r22, 0x00	; 0
    1ee4:	0e 94 3b 34 	call	0x6876	; 0x6876 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1ee8:	0f 90       	pop	r0
    1eea:	df 91       	pop	r29
    1eec:	cf 91       	pop	r28
    1eee:	08 95       	ret

00001ef0 <CO_collectSeismic3Axises>:
	
}*/

void CO_collectSeismic3Axises(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    1ef0:	8f 92       	push	r8
    1ef2:	9f 92       	push	r9
    1ef4:	af 92       	push	r10
    1ef6:	bf 92       	push	r11
    1ef8:	cf 92       	push	r12
    1efa:	df 92       	push	r13
    1efc:	ef 92       	push	r14
    1efe:	ff 92       	push	r15
    1f00:	0f 93       	push	r16
    1f02:	1f 93       	push	r17
    1f04:	cf 93       	push	r28
    1f06:	df 93       	push	r29
    1f08:	cd b7       	in	r28, 0x3d	; 61
    1f0a:	de b7       	in	r29, 0x3e	; 62
    1f0c:	2f 97       	sbiw	r28, 0x0f	; 15
    1f0e:	cd bf       	out	0x3d, r28	; 61
    1f10:	de bf       	out	0x3e, r29	; 62
    1f12:	89 83       	std	Y+1, r24	; 0x01
    1f14:	6a 83       	std	Y+2, r22	; 0x02
    1f16:	7b 83       	std	Y+3, r23	; 0x03
    1f18:	4c 83       	std	Y+4, r20	; 0x04
    1f1a:	5d 83       	std	Y+5, r21	; 0x05
    1f1c:	2e 83       	std	Y+6, r18	; 0x06
    1f1e:	0f 83       	std	Y+7, r16	; 0x07
    1f20:	e8 86       	std	Y+8, r14	; 0x08
    1f22:	f9 86       	std	Y+9, r15	; 0x09
    1f24:	ca 86       	std	Y+10, r12	; 0x0a
    1f26:	db 86       	std	Y+11, r13	; 0x0b
    1f28:	ac 86       	std	Y+12, r10	; 0x0c
    1f2a:	bd 86       	std	Y+13, r11	; 0x0d
    1f2c:	8e 86       	std	Y+14, r8	; 0x0e
    1f2e:	9f 86       	std	Y+15, r9	; 0x0f
	
	ADC_BUFFER = DataArray;
    1f30:	8b a1       	lds	r24, 0x4b
    1f32:	9c a1       	lds	r25, 0x4c
    1f34:	80 93 63 50 	sts	0x5063, r24
    1f38:	90 93 64 50 	sts	0x5064, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1f3c:	81 e0       	ldi	r24, 0x01	; 1
    1f3e:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1f42:	8a 81       	ldd	r24, Y+2	; 0x02
    1f44:	9b 81       	ldd	r25, Y+3	; 0x03
    1f46:	fc 01       	movw	r30, r24
    1f48:	90 81       	ld	r25, Z
    1f4a:	85 e0       	ldi	r24, 0x05	; 5
    1f4c:	69 2f       	mov	r22, r25
    1f4e:	0e 94 50 08 	call	0x10a0	; 0x10a0 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1f52:	8a 81       	ldd	r24, Y+2	; 0x02
    1f54:	9b 81       	ldd	r25, Y+3	; 0x03
    1f56:	01 96       	adiw	r24, 0x01	; 1
    1f58:	fc 01       	movw	r30, r24
    1f5a:	90 81       	ld	r25, Z
    1f5c:	86 e0       	ldi	r24, 0x06	; 6
    1f5e:	69 2f       	mov	r22, r25
    1f60:	0e 94 50 08 	call	0x10a0	; 0x10a0 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1f64:	8a 81       	ldd	r24, Y+2	; 0x02
    1f66:	9b 81       	ldd	r25, Y+3	; 0x03
    1f68:	02 96       	adiw	r24, 0x02	; 2
    1f6a:	fc 01       	movw	r30, r24
    1f6c:	90 81       	ld	r25, Z
    1f6e:	87 e0       	ldi	r24, 0x07	; 7
    1f70:	69 2f       	mov	r22, r25
    1f72:	0e 94 50 08 	call	0x10a0	; 0x10a0 <set_ampGain>
	set_filter(filterConfig);
    1f76:	89 81       	ldd	r24, Y+1	; 0x01
    1f78:	0e 94 7f 09 	call	0x12fe	; 0x12fe <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1f7c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f7e:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1f82:	84 e0       	ldi	r24, 0x04	; 4
    1f84:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1f88:	80 ec       	ldi	r24, 0xC0	; 192
    1f8a:	98 e0       	ldi	r25, 0x08	; 8
    1f8c:	24 e5       	ldi	r18, 0x54	; 84
    1f8e:	fc 01       	movw	r30, r24
    1f90:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1f92:	81 e0       	ldi	r24, 0x01	; 1
    1f94:	0e 94 ff 09 	call	0x13fe	; 0x13fe <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1f98:	85 e0       	ldi	r24, 0x05	; 5
    1f9a:	0e 94 1d 1b 	call	0x363a	; 0x363a <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1f9e:	80 ea       	ldi	r24, 0xA0	; 160
    1fa0:	96 e0       	ldi	r25, 0x06	; 6
    1fa2:	22 e0       	ldi	r18, 0x02	; 2
    1fa4:	fc 01       	movw	r30, r24
    1fa6:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1fa8:	80 ea       	ldi	r24, 0xA0	; 160
    1faa:	96 e0       	ldi	r25, 0x06	; 6
    1fac:	21 e0       	ldi	r18, 0x01	; 1
    1fae:	fc 01       	movw	r30, r24
    1fb0:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1fb2:	80 e8       	ldi	r24, 0x80	; 128
    1fb4:	91 e0       	ldi	r25, 0x01	; 1
    1fb6:	28 e7       	ldi	r18, 0x78	; 120
    1fb8:	fc 01       	movw	r30, r24
    1fba:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1fbc:	80 e0       	ldi	r24, 0x00	; 0
    1fbe:	98 e0       	ldi	r25, 0x08	; 8
    1fc0:	20 ef       	ldi	r18, 0xF0	; 240
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1fc6:	80 e0       	ldi	r24, 0x00	; 0
    1fc8:	98 e0       	ldi	r25, 0x08	; 8
    1fca:	28 85       	ldd	r18, Y+8	; 0x08
    1fcc:	39 85       	ldd	r19, Y+9	; 0x09
    1fce:	fc 01       	movw	r30, r24
    1fd0:	20 a7       	lds	r18, 0x70
    1fd2:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1fd4:	80 e0       	ldi	r24, 0x00	; 0
    1fd6:	98 e0       	ldi	r25, 0x08	; 8
    1fd8:	2a 85       	ldd	r18, Y+10	; 0x0a
    1fda:	3b 85       	ldd	r19, Y+11	; 0x0b
    1fdc:	fc 01       	movw	r30, r24
    1fde:	22 a7       	lds	r18, 0x72
    1fe0:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
    1fe4:	98 e0       	ldi	r25, 0x08	; 8
    1fe6:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fe8:	3d 85       	ldd	r19, Y+13	; 0x0d
    1fea:	fc 01       	movw	r30, r24
    1fec:	24 a7       	lds	r18, 0x74
    1fee:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1ff0:	80 e0       	ldi	r24, 0x00	; 0
    1ff2:	98 e0       	ldi	r25, 0x08	; 8
    1ff4:	2e 85       	ldd	r18, Y+14	; 0x0e
    1ff6:	3f 85       	ldd	r19, Y+15	; 0x0f
    1ff8:	fc 01       	movw	r30, r24
    1ffa:	26 a7       	lds	r18, 0x76
    1ffc:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1ffe:	80 e0       	ldi	r24, 0x00	; 0
    2000:	98 e0       	ldi	r25, 0x08	; 8
    2002:	2e 81       	ldd	r18, Y+6	; 0x06
    2004:	22 2f       	mov	r18, r18
    2006:	30 e0       	ldi	r19, 0x00	; 0
    2008:	21 50       	subi	r18, 0x01	; 1
    200a:	30 40       	sbci	r19, 0x00	; 0
    200c:	fc 01       	movw	r30, r24
    200e:	26 a3       	lds	r18, 0x56
    2010:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2012:	80 e0       	ldi	r24, 0x00	; 0
    2014:	98 e0       	ldi	r25, 0x08	; 8
    2016:	22 e0       	ldi	r18, 0x02	; 2
    2018:	fc 01       	movw	r30, r24
    201a:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    201c:	80 e0       	ldi	r24, 0x00	; 0
    201e:	98 e0       	ldi	r25, 0x08	; 8
    2020:	2f ef       	ldi	r18, 0xFF	; 255
    2022:	fc 01       	movw	r30, r24
    2024:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2026:	80 e0       	ldi	r24, 0x00	; 0
    2028:	98 e0       	ldi	r25, 0x08	; 8
    202a:	20 e0       	ldi	r18, 0x00	; 0
    202c:	38 e0       	ldi	r19, 0x08	; 8
    202e:	f9 01       	movw	r30, r18
    2030:	20 81       	ld	r18, Z
    2032:	20 7f       	andi	r18, 0xF0	; 240
    2034:	28 60       	ori	r18, 0x08	; 8
    2036:	fc 01       	movw	r30, r24
    2038:	20 83       	st	Z, r18

	sampleCount = 0;
    203a:	10 92 65 50 	sts	0x5065, r1
    203e:	10 92 66 50 	sts	0x5066, r1
    2042:	10 92 67 50 	sts	0x5067, r1
    2046:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    204a:	10 92 bf 50 	sts	0x50BF, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    204e:	80 e0       	ldi	r24, 0x00	; 0
    2050:	80 93 2c 21 	sts	0x212C, r24
    2054:	80 93 2b 21 	sts	0x212B, r24
    2058:	80 93 2a 21 	sts	0x212A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    205c:	80 ea       	ldi	r24, 0xA0	; 160
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	20 ea       	ldi	r18, 0xA0	; 160
    2062:	30 e0       	ldi	r19, 0x00	; 0
    2064:	f9 01       	movw	r30, r18
    2066:	22 81       	ldd	r18, Z+2	; 0x02
    2068:	26 60       	ori	r18, 0x06	; 6
    206a:	fc 01       	movw	r30, r24
    206c:	22 83       	std	Z+2, r18	; 0x02
	sei();
    206e:	78 94       	sei

	SPICS(TRUE);
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2076:	80 e8       	ldi	r24, 0x80	; 128
    2078:	96 e0       	ldi	r25, 0x06	; 6
    207a:	20 e2       	ldi	r18, 0x20	; 32
    207c:	fc 01       	movw	r30, r24
    207e:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2080:	80 e4       	ldi	r24, 0x40	; 64
    2082:	9a e0       	ldi	r25, 0x0A	; 10
    2084:	23 e2       	ldi	r18, 0x23	; 35
    2086:	fc 01       	movw	r30, r24
    2088:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    208a:	00 e4       	ldi	r16, 0x40	; 64
    208c:	1a e0       	ldi	r17, 0x0A	; 10
    208e:	8c 81       	ldd	r24, Y+4	; 0x04
    2090:	9d 81       	ldd	r25, Y+5	; 0x05
    2092:	9c 01       	movw	r18, r24
    2094:	40 e0       	ldi	r20, 0x00	; 0
    2096:	50 e0       	ldi	r21, 0x00	; 0
    2098:	80 e8       	ldi	r24, 0x80	; 128
    209a:	94 e8       	ldi	r25, 0x84	; 132
    209c:	ae e1       	ldi	r26, 0x1E	; 30
    209e:	b0 e0       	ldi	r27, 0x00	; 0
    20a0:	bc 01       	movw	r22, r24
    20a2:	cd 01       	movw	r24, r26
    20a4:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    20a8:	da 01       	movw	r26, r20
    20aa:	c9 01       	movw	r24, r18
    20ac:	f8 01       	movw	r30, r16
    20ae:	86 a3       	lds	r24, 0x56
    20b0:	97 a3       	lds	r25, 0x57
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    20b2:	00 e4       	ldi	r16, 0x40	; 64
    20b4:	1a e0       	ldi	r17, 0x0A	; 10
    20b6:	8c 81       	ldd	r24, Y+4	; 0x04
    20b8:	9d 81       	ldd	r25, Y+5	; 0x05
    20ba:	9c 01       	movw	r18, r24
    20bc:	40 e0       	ldi	r20, 0x00	; 0
    20be:	50 e0       	ldi	r21, 0x00	; 0
    20c0:	80 e4       	ldi	r24, 0x40	; 64
    20c2:	92 e4       	ldi	r25, 0x42	; 66
    20c4:	af e0       	ldi	r26, 0x0F	; 15
    20c6:	b0 e0       	ldi	r27, 0x00	; 0
    20c8:	bc 01       	movw	r22, r24
    20ca:	cd 01       	movw	r24, r26
    20cc:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    20d0:	da 01       	movw	r26, r20
    20d2:	c9 01       	movw	r24, r18
    20d4:	f8 01       	movw	r30, r16
    20d6:	82 af       	sts	0x72, r24
    20d8:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    20da:	80 e4       	ldi	r24, 0x40	; 64
    20dc:	9a e0       	ldi	r25, 0x0A	; 10
    20de:	20 e4       	ldi	r18, 0x40	; 64
    20e0:	3a e0       	ldi	r19, 0x0A	; 10
    20e2:	f9 01       	movw	r30, r18
    20e4:	20 81       	ld	r18, Z
    20e6:	20 7f       	andi	r18, 0xF0	; 240
    20e8:	21 60       	ori	r18, 0x01	; 1
    20ea:	fc 01       	movw	r30, r24
    20ec:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    20ee:	00 00       	nop
    20f0:	20 91 65 50 	lds	r18, 0x5065
    20f4:	30 91 66 50 	lds	r19, 0x5066
    20f8:	40 91 67 50 	lds	r20, 0x5067
    20fc:	50 91 68 50 	lds	r21, 0x5068
    2100:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2102:	98 a1       	lds	r25, 0x48
    2104:	a9 a1       	lds	r26, 0x49
    2106:	ba a1       	lds	r27, 0x4a
    2108:	28 17       	cp	r18, r24
    210a:	39 07       	cpc	r19, r25
    210c:	4a 07       	cpc	r20, r26
    210e:	5b 07       	cpc	r21, r27
    2110:	78 f3       	brcs	.-34     	; 0x20f0 <CO_collectSeismic3Axises+0x200>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2112:	80 e0       	ldi	r24, 0x00	; 0
    2114:	98 e0       	ldi	r25, 0x08	; 8
    2116:	20 e0       	ldi	r18, 0x00	; 0
    2118:	38 e0       	ldi	r19, 0x08	; 8
    211a:	f9 01       	movw	r30, r18
    211c:	20 81       	ld	r18, Z
    211e:	20 7f       	andi	r18, 0xF0	; 240
    2120:	fc 01       	movw	r30, r24
    2122:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2124:	80 e4       	ldi	r24, 0x40	; 64
    2126:	9a e0       	ldi	r25, 0x0A	; 10
    2128:	20 e4       	ldi	r18, 0x40	; 64
    212a:	3a e0       	ldi	r19, 0x0A	; 10
    212c:	f9 01       	movw	r30, r18
    212e:	20 81       	ld	r18, Z
    2130:	20 7f       	andi	r18, 0xF0	; 240
    2132:	fc 01       	movw	r30, r24
    2134:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2136:	80 ea       	ldi	r24, 0xA0	; 160
    2138:	90 e0       	ldi	r25, 0x00	; 0
    213a:	20 ea       	ldi	r18, 0xA0	; 160
    213c:	30 e0       	ldi	r19, 0x00	; 0
    213e:	f9 01       	movw	r30, r18
    2140:	22 81       	ldd	r18, Z+2	; 0x02
    2142:	29 7f       	andi	r18, 0xF9	; 249
    2144:	fc 01       	movw	r30, r24
    2146:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2148:	f8 94       	cli

	SPICS(FALSE);
    214a:	80 e0       	ldi	r24, 0x00	; 0
    214c:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    2150:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	enableADCMUX(FALSE);
    2154:	80 e0       	ldi	r24, 0x00	; 0
    2156:	0e 94 ff 09 	call	0x13fe	; 0x13fe <enableADCMUX>
	//ADCPower(FALSE);
}
    215a:	2f 96       	adiw	r28, 0x0f	; 15
    215c:	cd bf       	out	0x3d, r28	; 61
    215e:	de bf       	out	0x3e, r29	; 62
    2160:	df 91       	pop	r29
    2162:	cf 91       	pop	r28
    2164:	1f 91       	pop	r17
    2166:	0f 91       	pop	r16
    2168:	ff 90       	pop	r15
    216a:	ef 90       	pop	r14
    216c:	df 90       	pop	r13
    216e:	cf 90       	pop	r12
    2170:	bf 90       	pop	r11
    2172:	af 90       	pop	r10
    2174:	9f 90       	pop	r9
    2176:	8f 90       	pop	r8
    2178:	08 95       	ret

0000217a <__vector_16>:

//first averaging point
ISR(TCC0_CCA_vect) {
    217a:	1f 92       	push	r1
    217c:	0f 92       	push	r0
    217e:	0f b6       	in	r0, 0x3f	; 63
    2180:	0f 92       	push	r0
    2182:	00 90 3b 00 	lds	r0, 0x003B
    2186:	0f 92       	push	r0
    2188:	11 24       	eor	r1, r1
    218a:	2f 93       	push	r18
    218c:	3f 93       	push	r19
    218e:	4f 93       	push	r20
    2190:	5f 93       	push	r21
    2192:	6f 93       	push	r22
    2194:	7f 93       	push	r23
    2196:	8f 93       	push	r24
    2198:	9f 93       	push	r25
    219a:	af 93       	push	r26
    219c:	bf 93       	push	r27
    219e:	ef 93       	push	r30
    21a0:	ff 93       	push	r31
    21a2:	cf 93       	push	r28
    21a4:	df 93       	push	r29
    21a6:	cd b7       	in	r28, 0x3d	; 61
    21a8:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    21aa:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    21ae:	df 91       	pop	r29
    21b0:	cf 91       	pop	r28
    21b2:	ff 91       	pop	r31
    21b4:	ef 91       	pop	r30
    21b6:	bf 91       	pop	r27
    21b8:	af 91       	pop	r26
    21ba:	9f 91       	pop	r25
    21bc:	8f 91       	pop	r24
    21be:	7f 91       	pop	r23
    21c0:	6f 91       	pop	r22
    21c2:	5f 91       	pop	r21
    21c4:	4f 91       	pop	r20
    21c6:	3f 91       	pop	r19
    21c8:	2f 91       	pop	r18
    21ca:	0f 90       	pop	r0
    21cc:	00 92 3b 00 	sts	0x003B, r0
    21d0:	0f 90       	pop	r0
    21d2:	0f be       	out	0x3f, r0	; 63
    21d4:	0f 90       	pop	r0
    21d6:	1f 90       	pop	r1
    21d8:	18 95       	reti

000021da <__vector_17>:

//second averaging point
ISR(TCC0_CCB_vect) {
    21da:	1f 92       	push	r1
    21dc:	0f 92       	push	r0
    21de:	0f b6       	in	r0, 0x3f	; 63
    21e0:	0f 92       	push	r0
    21e2:	00 90 3b 00 	lds	r0, 0x003B
    21e6:	0f 92       	push	r0
    21e8:	11 24       	eor	r1, r1
    21ea:	2f 93       	push	r18
    21ec:	3f 93       	push	r19
    21ee:	4f 93       	push	r20
    21f0:	5f 93       	push	r21
    21f2:	6f 93       	push	r22
    21f4:	7f 93       	push	r23
    21f6:	8f 93       	push	r24
    21f8:	9f 93       	push	r25
    21fa:	af 93       	push	r26
    21fc:	bf 93       	push	r27
    21fe:	ef 93       	push	r30
    2200:	ff 93       	push	r31
    2202:	cf 93       	push	r28
    2204:	df 93       	push	r29
    2206:	cd b7       	in	r28, 0x3d	; 61
    2208:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    220a:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    220e:	df 91       	pop	r29
    2210:	cf 91       	pop	r28
    2212:	ff 91       	pop	r31
    2214:	ef 91       	pop	r30
    2216:	bf 91       	pop	r27
    2218:	af 91       	pop	r26
    221a:	9f 91       	pop	r25
    221c:	8f 91       	pop	r24
    221e:	7f 91       	pop	r23
    2220:	6f 91       	pop	r22
    2222:	5f 91       	pop	r21
    2224:	4f 91       	pop	r20
    2226:	3f 91       	pop	r19
    2228:	2f 91       	pop	r18
    222a:	0f 90       	pop	r0
    222c:	00 92 3b 00 	sts	0x003B, r0
    2230:	0f 90       	pop	r0
    2232:	0f be       	out	0x3f, r0	; 63
    2234:	0f 90       	pop	r0
    2236:	1f 90       	pop	r1
    2238:	18 95       	reti

0000223a <__vector_18>:

//third averaging point
ISR(TCC0_CCC_vect) {
    223a:	1f 92       	push	r1
    223c:	0f 92       	push	r0
    223e:	0f b6       	in	r0, 0x3f	; 63
    2240:	0f 92       	push	r0
    2242:	00 90 3b 00 	lds	r0, 0x003B
    2246:	0f 92       	push	r0
    2248:	11 24       	eor	r1, r1
    224a:	2f 93       	push	r18
    224c:	3f 93       	push	r19
    224e:	4f 93       	push	r20
    2250:	5f 93       	push	r21
    2252:	6f 93       	push	r22
    2254:	7f 93       	push	r23
    2256:	8f 93       	push	r24
    2258:	9f 93       	push	r25
    225a:	af 93       	push	r26
    225c:	bf 93       	push	r27
    225e:	ef 93       	push	r30
    2260:	ff 93       	push	r31
    2262:	cf 93       	push	r28
    2264:	df 93       	push	r29
    2266:	cd b7       	in	r28, 0x3d	; 61
    2268:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    226a:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	ff 91       	pop	r31
    2274:	ef 91       	pop	r30
    2276:	bf 91       	pop	r27
    2278:	af 91       	pop	r26
    227a:	9f 91       	pop	r25
    227c:	8f 91       	pop	r24
    227e:	7f 91       	pop	r23
    2280:	6f 91       	pop	r22
    2282:	5f 91       	pop	r21
    2284:	4f 91       	pop	r20
    2286:	3f 91       	pop	r19
    2288:	2f 91       	pop	r18
    228a:	0f 90       	pop	r0
    228c:	00 92 3b 00 	sts	0x003B, r0
    2290:	0f 90       	pop	r0
    2292:	0f be       	out	0x3f, r0	; 63
    2294:	0f 90       	pop	r0
    2296:	1f 90       	pop	r1
    2298:	18 95       	reti

0000229a <__vector_19>:

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    229a:	1f 92       	push	r1
    229c:	0f 92       	push	r0
    229e:	0f b6       	in	r0, 0x3f	; 63
    22a0:	0f 92       	push	r0
    22a2:	00 90 3b 00 	lds	r0, 0x003B
    22a6:	0f 92       	push	r0
    22a8:	11 24       	eor	r1, r1
    22aa:	2f 93       	push	r18
    22ac:	3f 93       	push	r19
    22ae:	4f 93       	push	r20
    22b0:	5f 93       	push	r21
    22b2:	6f 93       	push	r22
    22b4:	7f 93       	push	r23
    22b6:	8f 93       	push	r24
    22b8:	9f 93       	push	r25
    22ba:	af 93       	push	r26
    22bc:	bf 93       	push	r27
    22be:	ef 93       	push	r30
    22c0:	ff 93       	push	r31
    22c2:	cf 93       	push	r28
    22c4:	df 93       	push	r29
    22c6:	cd b7       	in	r28, 0x3d	; 61
    22c8:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    22ca:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
	SPICount = 0;
    22ce:	10 92 bf 50 	sts	0x50BF, r1
	if(PORTB.OUT & PIN1_bm) {
    22d2:	80 e2       	ldi	r24, 0x20	; 32
    22d4:	96 e0       	ldi	r25, 0x06	; 6
    22d6:	fc 01       	movw	r30, r24
    22d8:	84 81       	ldd	r24, Z+4	; 0x04
    22da:	88 2f       	mov	r24, r24
    22dc:	90 e0       	ldi	r25, 0x00	; 0
    22de:	82 70       	andi	r24, 0x02	; 2
    22e0:	90 70       	andi	r25, 0x00	; 0
    22e2:	00 97       	sbiw	r24, 0x00	; 0
    22e4:	b1 f0       	breq	.+44     	; 0x2312 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    22e6:	80 e0       	ldi	r24, 0x00	; 0
    22e8:	96 e0       	ldi	r25, 0x06	; 6
    22ea:	fc 01       	movw	r30, r24
    22ec:	84 81       	ldd	r24, Z+4	; 0x04
    22ee:	88 2f       	mov	r24, r24
    22f0:	90 e0       	ldi	r25, 0x00	; 0
    22f2:	80 74       	andi	r24, 0x40	; 64
    22f4:	90 70       	andi	r25, 0x00	; 0
    22f6:	00 97       	sbiw	r24, 0x00	; 0
    22f8:	31 f0       	breq	.+12     	; 0x2306 <__vector_19+0x6c>
    22fa:	80 e2       	ldi	r24, 0x20	; 32
    22fc:	96 e0       	ldi	r25, 0x06	; 6
    22fe:	22 e0       	ldi	r18, 0x02	; 2
    2300:	fc 01       	movw	r30, r24
    2302:	27 83       	std	Z+7, r18	; 0x07
    2304:	10 c0       	rjmp	.+32     	; 0x2326 <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    2306:	80 e0       	ldi	r24, 0x00	; 0
    2308:	96 e0       	ldi	r25, 0x06	; 6
    230a:	20 e4       	ldi	r18, 0x40	; 64
    230c:	fc 01       	movw	r30, r24
    230e:	27 83       	std	Z+7, r18	; 0x07
    2310:	0a c0       	rjmp	.+20     	; 0x2326 <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2312:	80 e0       	ldi	r24, 0x00	; 0
    2314:	96 e0       	ldi	r25, 0x06	; 6
    2316:	20 e4       	ldi	r18, 0x40	; 64
    2318:	fc 01       	movw	r30, r24
    231a:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    231c:	80 e2       	ldi	r24, 0x20	; 32
    231e:	96 e0       	ldi	r25, 0x06	; 6
    2320:	22 e0       	ldi	r18, 0x02	; 2
    2322:	fc 01       	movw	r30, r24
    2324:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	ff 91       	pop	r31
    232c:	ef 91       	pop	r30
    232e:	bf 91       	pop	r27
    2330:	af 91       	pop	r26
    2332:	9f 91       	pop	r25
    2334:	8f 91       	pop	r24
    2336:	7f 91       	pop	r23
    2338:	6f 91       	pop	r22
    233a:	5f 91       	pop	r21
    233c:	4f 91       	pop	r20
    233e:	3f 91       	pop	r19
    2340:	2f 91       	pop	r18
    2342:	0f 90       	pop	r0
    2344:	00 92 3b 00 	sts	0x003B, r0
    2348:	0f 90       	pop	r0
    234a:	0f be       	out	0x3f, r0	; 63
    234c:	0f 90       	pop	r0
    234e:	1f 90       	pop	r1
    2350:	18 95       	reti

00002352 <__vector_14>:

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    2352:	1f 92       	push	r1
    2354:	0f 92       	push	r0
    2356:	0f b6       	in	r0, 0x3f	; 63
    2358:	0f 92       	push	r0
    235a:	00 90 3b 00 	lds	r0, 0x003B
    235e:	0f 92       	push	r0
    2360:	11 24       	eor	r1, r1
    2362:	2f 93       	push	r18
    2364:	3f 93       	push	r19
    2366:	4f 93       	push	r20
    2368:	5f 93       	push	r21
    236a:	6f 93       	push	r22
    236c:	7f 93       	push	r23
    236e:	8f 93       	push	r24
    2370:	9f 93       	push	r25
    2372:	af 93       	push	r26
    2374:	bf 93       	push	r27
    2376:	ef 93       	push	r30
    2378:	ff 93       	push	r31
    237a:	cf 93       	push	r28
    237c:	df 93       	push	r29
    237e:	cd b7       	in	r28, 0x3d	; 61
    2380:	de b7       	in	r29, 0x3e	; 62
    2382:	29 97       	sbiw	r28, 0x09	; 9
    2384:	cd bf       	out	0x3d, r28	; 61
    2386:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2388:	1a 82       	std	Y+2, r1	; 0x02
    238a:	1b 82       	std	Y+3, r1	; 0x03
    238c:	1c 82       	std	Y+4, r1	; 0x04
    238e:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2390:	19 82       	std	Y+1, r1	; 0x01
    2392:	4f c0       	rjmp	.+158    	; 0x2432 <__vector_14+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2394:	89 81       	ldd	r24, Y+1	; 0x01
    2396:	88 2f       	mov	r24, r24
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	8a 5a       	subi	r24, 0xAA	; 170
    239c:	9f 4a       	sbci	r25, 0xAF	; 175
    239e:	fc 01       	movw	r30, r24
    23a0:	80 81       	ld	r24, Z
    23a2:	88 23       	and	r24, r24
    23a4:	3c f4       	brge	.+14     	; 0x23b4 <__vector_14+0x62>
    23a6:	ce 01       	movw	r24, r28
    23a8:	06 96       	adiw	r24, 0x06	; 6
    23aa:	03 96       	adiw	r24, 0x03	; 3
    23ac:	2f ef       	ldi	r18, 0xFF	; 255
    23ae:	fc 01       	movw	r30, r24
    23b0:	20 83       	st	Z, r18
    23b2:	05 c0       	rjmp	.+10     	; 0x23be <__vector_14+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    23b4:	ce 01       	movw	r24, r28
    23b6:	06 96       	adiw	r24, 0x06	; 6
    23b8:	03 96       	adiw	r24, 0x03	; 3
    23ba:	fc 01       	movw	r30, r24
    23bc:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    23be:	ce 01       	movw	r24, r28
    23c0:	06 96       	adiw	r24, 0x06	; 6
    23c2:	02 96       	adiw	r24, 0x02	; 2
    23c4:	29 81       	ldd	r18, Y+1	; 0x01
    23c6:	22 2f       	mov	r18, r18
    23c8:	30 e0       	ldi	r19, 0x00	; 0
    23ca:	2a 5a       	subi	r18, 0xAA	; 170
    23cc:	3f 4a       	sbci	r19, 0xAF	; 175
    23ce:	f9 01       	movw	r30, r18
    23d0:	20 81       	ld	r18, Z
    23d2:	fc 01       	movw	r30, r24
    23d4:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    23d6:	ce 01       	movw	r24, r28
    23d8:	06 96       	adiw	r24, 0x06	; 6
    23da:	01 96       	adiw	r24, 0x01	; 1
    23dc:	29 81       	ldd	r18, Y+1	; 0x01
    23de:	22 2f       	mov	r18, r18
    23e0:	30 e0       	ldi	r19, 0x00	; 0
    23e2:	2f 5f       	subi	r18, 0xFF	; 255
    23e4:	3f 4f       	sbci	r19, 0xFF	; 255
    23e6:	2a 5a       	subi	r18, 0xAA	; 170
    23e8:	3f 4a       	sbci	r19, 0xAF	; 175
    23ea:	f9 01       	movw	r30, r18
    23ec:	20 81       	ld	r18, Z
    23ee:	fc 01       	movw	r30, r24
    23f0:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    23f2:	ce 01       	movw	r24, r28
    23f4:	06 96       	adiw	r24, 0x06	; 6
    23f6:	29 81       	ldd	r18, Y+1	; 0x01
    23f8:	22 2f       	mov	r18, r18
    23fa:	30 e0       	ldi	r19, 0x00	; 0
    23fc:	2e 5f       	subi	r18, 0xFE	; 254
    23fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2400:	2a 5a       	subi	r18, 0xAA	; 170
    2402:	3f 4a       	sbci	r19, 0xAF	; 175
    2404:	f9 01       	movw	r30, r18
    2406:	20 81       	ld	r18, Z
    2408:	fc 01       	movw	r30, r24
    240a:	20 83       	st	Z, r18
		sum += currentSample;
    240c:	2a 81       	ldd	r18, Y+2	; 0x02
    240e:	3b 81       	ldd	r19, Y+3	; 0x03
    2410:	4c 81       	ldd	r20, Y+4	; 0x04
    2412:	5d 81       	ldd	r21, Y+5	; 0x05
    2414:	8e 81       	ldd	r24, Y+6	; 0x06
    2416:	9f 81       	ldd	r25, Y+7	; 0x07
    2418:	a8 85       	ldd	r26, Y+8	; 0x08
    241a:	b9 85       	ldd	r27, Y+9	; 0x09
    241c:	82 0f       	add	r24, r18
    241e:	93 1f       	adc	r25, r19
    2420:	a4 1f       	adc	r26, r20
    2422:	b5 1f       	adc	r27, r21
    2424:	8a 83       	std	Y+2, r24	; 0x02
    2426:	9b 83       	std	Y+3, r25	; 0x03
    2428:	ac 83       	std	Y+4, r26	; 0x04
    242a:	bd 83       	std	Y+5, r27	; 0x05
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    242c:	89 81       	ldd	r24, Y+1	; 0x01
    242e:	8d 5f       	subi	r24, 0xFD	; 253
    2430:	89 83       	std	Y+1, r24	; 0x01
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	8c 30       	cpi	r24, 0x0C	; 12
    2436:	08 f4       	brcc	.+2      	; 0x243a <__vector_14+0xe8>
    2438:	ad cf       	rjmp	.-166    	; 0x2394 <__vector_14+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    243a:	8a 81       	ldd	r24, Y+2	; 0x02
    243c:	9b 81       	ldd	r25, Y+3	; 0x03
    243e:	ac 81       	ldd	r26, Y+4	; 0x04
    2440:	bd 81       	ldd	r27, Y+5	; 0x05
    2442:	24 e0       	ldi	r18, 0x04	; 4
    2444:	30 e0       	ldi	r19, 0x00	; 0
    2446:	40 e0       	ldi	r20, 0x00	; 0
    2448:	50 e0       	ldi	r21, 0x00	; 0
    244a:	bc 01       	movw	r22, r24
    244c:	cd 01       	movw	r24, r26
    244e:	0e 94 e2 5d 	call	0xbbc4	; 0xbbc4 <__divmodsi4>
    2452:	da 01       	movw	r26, r20
    2454:	c9 01       	movw	r24, r18
    2456:	8a 83       	std	Y+2, r24	; 0x02
    2458:	9b 83       	std	Y+3, r25	; 0x03
    245a:	ac 83       	std	Y+4, r26	; 0x04
    245c:	bd 83       	std	Y+5, r27	; 0x05
	ADC_BUFFER[sampleCount] = currentSample;
    245e:	20 91 63 50 	lds	r18, 0x5063
    2462:	30 91 64 50 	lds	r19, 0x5064
    2466:	80 91 65 50 	lds	r24, 0x5065
    246a:	90 91 66 50 	lds	r25, 0x5066
    246e:	a0 91 67 50 	lds	r26, 0x5067
    2472:	b0 91 68 50 	lds	r27, 0x5068
    2476:	88 0f       	add	r24, r24
    2478:	99 1f       	adc	r25, r25
    247a:	88 0f       	add	r24, r24
    247c:	99 1f       	adc	r25, r25
    247e:	28 0f       	add	r18, r24
    2480:	39 1f       	adc	r19, r25
    2482:	8e 81       	ldd	r24, Y+6	; 0x06
    2484:	9f 81       	ldd	r25, Y+7	; 0x07
    2486:	a8 85       	ldd	r26, Y+8	; 0x08
    2488:	b9 85       	ldd	r27, Y+9	; 0x09
    248a:	f9 01       	movw	r30, r18
    248c:	80 83       	st	Z, r24
    248e:	91 83       	std	Z+1, r25	; 0x01
    2490:	a2 83       	std	Z+2, r26	; 0x02
    2492:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    2494:	80 91 65 50 	lds	r24, 0x5065
    2498:	90 91 66 50 	lds	r25, 0x5066
    249c:	a0 91 67 50 	lds	r26, 0x5067
    24a0:	b0 91 68 50 	lds	r27, 0x5068
    24a4:	01 96       	adiw	r24, 0x01	; 1
    24a6:	a1 1d       	adc	r26, r1
    24a8:	b1 1d       	adc	r27, r1
    24aa:	80 93 65 50 	sts	0x5065, r24
    24ae:	90 93 66 50 	sts	0x5066, r25
    24b2:	a0 93 67 50 	sts	0x5067, r26
    24b6:	b0 93 68 50 	sts	0x5068, r27

}
    24ba:	29 96       	adiw	r28, 0x09	; 9
    24bc:	cd bf       	out	0x3d, r28	; 61
    24be:	de bf       	out	0x3e, r29	; 62
    24c0:	df 91       	pop	r29
    24c2:	cf 91       	pop	r28
    24c4:	ff 91       	pop	r31
    24c6:	ef 91       	pop	r30
    24c8:	bf 91       	pop	r27
    24ca:	af 91       	pop	r26
    24cc:	9f 91       	pop	r25
    24ce:	8f 91       	pop	r24
    24d0:	7f 91       	pop	r23
    24d2:	6f 91       	pop	r22
    24d4:	5f 91       	pop	r21
    24d6:	4f 91       	pop	r20
    24d8:	3f 91       	pop	r19
    24da:	2f 91       	pop	r18
    24dc:	0f 90       	pop	r0
    24de:	00 92 3b 00 	sts	0x003B, r0
    24e2:	0f 90       	pop	r0
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	0f 90       	pop	r0
    24e8:	1f 90       	pop	r1
    24ea:	18 95       	reti

000024ec <CO_collectSeismic1Channel>:

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    24ec:	8f 92       	push	r8
    24ee:	9f 92       	push	r9
    24f0:	af 92       	push	r10
    24f2:	bf 92       	push	r11
    24f4:	cf 92       	push	r12
    24f6:	df 92       	push	r13
    24f8:	ef 92       	push	r14
    24fa:	0f 93       	push	r16
    24fc:	1f 93       	push	r17
    24fe:	cf 93       	push	r28
    2500:	df 93       	push	r29
    2502:	cd b7       	in	r28, 0x3d	; 61
    2504:	de b7       	in	r29, 0x3e	; 62
    2506:	2d 97       	sbiw	r28, 0x0d	; 13
    2508:	cd bf       	out	0x3d, r28	; 61
    250a:	de bf       	out	0x3e, r29	; 62
    250c:	89 83       	std	Y+1, r24	; 0x01
    250e:	6a 83       	std	Y+2, r22	; 0x02
    2510:	4b 83       	std	Y+3, r20	; 0x03
    2512:	2c 83       	std	Y+4, r18	; 0x04
    2514:	3d 83       	std	Y+5, r19	; 0x05
    2516:	0e 83       	std	Y+6, r16	; 0x06
    2518:	ef 82       	std	Y+7, r14	; 0x07
    251a:	c8 86       	std	Y+8, r12	; 0x08
    251c:	d9 86       	std	Y+9, r13	; 0x09
    251e:	aa 86       	std	Y+10, r10	; 0x0a
    2520:	bb 86       	std	Y+11, r11	; 0x0b
    2522:	8c 86       	std	Y+12, r8	; 0x0c
    2524:	9d 86       	std	Y+13, r9	; 0x0d
	
	ADC_BUFFER=DataArray;
    2526:	8a a1       	lds	r24, 0x4a
    2528:	9b a1       	lds	r25, 0x4b
    252a:	80 93 63 50 	sts	0x5063, r24
    252e:	90 93 64 50 	sts	0x5064, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2532:	81 e0       	ldi	r24, 0x01	; 1
    2534:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2538:	89 81       	ldd	r24, Y+1	; 0x01
    253a:	6b 81       	ldd	r22, Y+3	; 0x03
    253c:	0e 94 50 08 	call	0x10a0	; 0x10a0 <set_ampGain>
	set_filter(filterConfig);
    2540:	8a 81       	ldd	r24, Y+2	; 0x02
    2542:	0e 94 7f 09 	call	0x12fe	; 0x12fe <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2546:	8f 81       	ldd	r24, Y+7	; 0x07
    2548:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    254c:	84 e0       	ldi	r24, 0x04	; 4
    254e:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2552:	80 ec       	ldi	r24, 0xC0	; 192
    2554:	98 e0       	ldi	r25, 0x08	; 8
    2556:	24 e5       	ldi	r18, 0x54	; 84
    2558:	fc 01       	movw	r30, r24
    255a:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    255c:	81 e0       	ldi	r24, 0x01	; 1
    255e:	0e 94 ff 09 	call	0x13fe	; 0x13fe <enableADCMUX>
	setADCInput(channel);
    2562:	89 81       	ldd	r24, Y+1	; 0x01
    2564:	0e 94 1d 1b 	call	0x363a	; 0x363a <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2568:	80 ea       	ldi	r24, 0xA0	; 160
    256a:	96 e0       	ldi	r25, 0x06	; 6
    256c:	22 e0       	ldi	r18, 0x02	; 2
    256e:	fc 01       	movw	r30, r24
    2570:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2572:	80 ea       	ldi	r24, 0xA0	; 160
    2574:	96 e0       	ldi	r25, 0x06	; 6
    2576:	21 e0       	ldi	r18, 0x01	; 1
    2578:	fc 01       	movw	r30, r24
    257a:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    257c:	80 e8       	ldi	r24, 0x80	; 128
    257e:	91 e0       	ldi	r25, 0x01	; 1
    2580:	28 e7       	ldi	r18, 0x78	; 120
    2582:	fc 01       	movw	r30, r24
    2584:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2586:	80 e0       	ldi	r24, 0x00	; 0
    2588:	99 e0       	ldi	r25, 0x09	; 9
    258a:	20 ef       	ldi	r18, 0xF0	; 240
    258c:	fc 01       	movw	r30, r24
    258e:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    2590:	80 e0       	ldi	r24, 0x00	; 0
    2592:	99 e0       	ldi	r25, 0x09	; 9
    2594:	28 85       	ldd	r18, Y+8	; 0x08
    2596:	39 85       	ldd	r19, Y+9	; 0x09
    2598:	fc 01       	movw	r30, r24
    259a:	20 a7       	lds	r18, 0x70
    259c:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    259e:	80 e0       	ldi	r24, 0x00	; 0
    25a0:	99 e0       	ldi	r25, 0x09	; 9
    25a2:	2a 85       	ldd	r18, Y+10	; 0x0a
    25a4:	3b 85       	ldd	r19, Y+11	; 0x0b
    25a6:	fc 01       	movw	r30, r24
    25a8:	22 a7       	lds	r18, 0x72
    25aa:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	99 e0       	ldi	r25, 0x09	; 9
    25b0:	2c 85       	ldd	r18, Y+12	; 0x0c
    25b2:	3d 85       	ldd	r19, Y+13	; 0x0d
    25b4:	fc 01       	movw	r30, r24
    25b6:	24 a7       	lds	r18, 0x74
    25b8:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    25ba:	80 e0       	ldi	r24, 0x00	; 0
    25bc:	99 e0       	ldi	r25, 0x09	; 9
    25be:	2c 8d       	ldd	r18, Y+28	; 0x1c
    25c0:	3d 8d       	ldd	r19, Y+29	; 0x1d
    25c2:	fc 01       	movw	r30, r24
    25c4:	26 a7       	lds	r18, 0x76
    25c6:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    25c8:	80 e0       	ldi	r24, 0x00	; 0
    25ca:	99 e0       	ldi	r25, 0x09	; 9
    25cc:	2e 81       	ldd	r18, Y+6	; 0x06
    25ce:	22 2f       	mov	r18, r18
    25d0:	30 e0       	ldi	r19, 0x00	; 0
    25d2:	21 50       	subi	r18, 0x01	; 1
    25d4:	30 40       	sbci	r19, 0x00	; 0
    25d6:	fc 01       	movw	r30, r24
    25d8:	26 a3       	lds	r18, 0x56
    25da:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    25dc:	80 e0       	ldi	r24, 0x00	; 0
    25de:	99 e0       	ldi	r25, 0x09	; 9
    25e0:	22 e0       	ldi	r18, 0x02	; 2
    25e2:	fc 01       	movw	r30, r24
    25e4:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    25e6:	80 e0       	ldi	r24, 0x00	; 0
    25e8:	99 e0       	ldi	r25, 0x09	; 9
    25ea:	2f ef       	ldi	r18, 0xFF	; 255
    25ec:	fc 01       	movw	r30, r24
    25ee:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    25f0:	80 e0       	ldi	r24, 0x00	; 0
    25f2:	99 e0       	ldi	r25, 0x09	; 9
    25f4:	20 e0       	ldi	r18, 0x00	; 0
    25f6:	39 e0       	ldi	r19, 0x09	; 9
    25f8:	f9 01       	movw	r30, r18
    25fa:	20 81       	ld	r18, Z
    25fc:	20 7f       	andi	r18, 0xF0	; 240
    25fe:	28 60       	ori	r18, 0x08	; 8
    2600:	fc 01       	movw	r30, r24
    2602:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2604:	10 92 65 50 	sts	0x5065, r1
    2608:	10 92 66 50 	sts	0x5066, r1
    260c:	10 92 67 50 	sts	0x5067, r1
    2610:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2614:	10 92 bf 50 	sts	0x50BF, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2618:	80 ea       	ldi	r24, 0xA0	; 160
    261a:	90 e0       	ldi	r25, 0x00	; 0
    261c:	20 ea       	ldi	r18, 0xA0	; 160
    261e:	30 e0       	ldi	r19, 0x00	; 0
    2620:	f9 01       	movw	r30, r18
    2622:	22 81       	ldd	r18, Z+2	; 0x02
    2624:	26 60       	ori	r18, 0x06	; 6
    2626:	fc 01       	movw	r30, r24
    2628:	22 83       	std	Z+2, r18	; 0x02
	sei();
    262a:	78 94       	sei

	SPICS(TRUE);
    262c:	81 e0       	ldi	r24, 0x01	; 1
    262e:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2632:	80 e8       	ldi	r24, 0x80	; 128
    2634:	96 e0       	ldi	r25, 0x06	; 6
    2636:	20 e2       	ldi	r18, 0x20	; 32
    2638:	fc 01       	movw	r30, r24
    263a:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    263c:	80 e4       	ldi	r24, 0x40	; 64
    263e:	9a e0       	ldi	r25, 0x0A	; 10
    2640:	23 e2       	ldi	r18, 0x23	; 35
    2642:	fc 01       	movw	r30, r24
    2644:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2646:	00 e4       	ldi	r16, 0x40	; 64
    2648:	1a e0       	ldi	r17, 0x0A	; 10
    264a:	8c 81       	ldd	r24, Y+4	; 0x04
    264c:	9d 81       	ldd	r25, Y+5	; 0x05
    264e:	9c 01       	movw	r18, r24
    2650:	40 e0       	ldi	r20, 0x00	; 0
    2652:	50 e0       	ldi	r21, 0x00	; 0
    2654:	80 e8       	ldi	r24, 0x80	; 128
    2656:	94 e8       	ldi	r25, 0x84	; 132
    2658:	ae e1       	ldi	r26, 0x1E	; 30
    265a:	b0 e0       	ldi	r27, 0x00	; 0
    265c:	bc 01       	movw	r22, r24
    265e:	cd 01       	movw	r24, r26
    2660:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    2664:	da 01       	movw	r26, r20
    2666:	c9 01       	movw	r24, r18
    2668:	f8 01       	movw	r30, r16
    266a:	86 a3       	lds	r24, 0x56
    266c:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    266e:	00 e4       	ldi	r16, 0x40	; 64
    2670:	1a e0       	ldi	r17, 0x0A	; 10
    2672:	8c 81       	ldd	r24, Y+4	; 0x04
    2674:	9d 81       	ldd	r25, Y+5	; 0x05
    2676:	9c 01       	movw	r18, r24
    2678:	40 e0       	ldi	r20, 0x00	; 0
    267a:	50 e0       	ldi	r21, 0x00	; 0
    267c:	80 e4       	ldi	r24, 0x40	; 64
    267e:	92 e4       	ldi	r25, 0x42	; 66
    2680:	af e0       	ldi	r26, 0x0F	; 15
    2682:	b0 e0       	ldi	r27, 0x00	; 0
    2684:	bc 01       	movw	r22, r24
    2686:	cd 01       	movw	r24, r26
    2688:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    268c:	da 01       	movw	r26, r20
    268e:	c9 01       	movw	r24, r18
    2690:	f8 01       	movw	r30, r16
    2692:	82 af       	sts	0x72, r24
    2694:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2696:	80 e4       	ldi	r24, 0x40	; 64
    2698:	9a e0       	ldi	r25, 0x0A	; 10
    269a:	20 e4       	ldi	r18, 0x40	; 64
    269c:	3a e0       	ldi	r19, 0x0A	; 10
    269e:	f9 01       	movw	r30, r18
    26a0:	20 81       	ld	r18, Z
    26a2:	20 7f       	andi	r18, 0xF0	; 240
    26a4:	21 60       	ori	r18, 0x01	; 1
    26a6:	fc 01       	movw	r30, r24
    26a8:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    26aa:	00 00       	nop
    26ac:	20 91 65 50 	lds	r18, 0x5065
    26b0:	30 91 66 50 	lds	r19, 0x5066
    26b4:	40 91 67 50 	lds	r20, 0x5067
    26b8:	50 91 68 50 	lds	r21, 0x5068
    26bc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    26be:	9f 8d       	ldd	r25, Y+31	; 0x1f
    26c0:	a8 a1       	lds	r26, 0x48
    26c2:	b9 a1       	lds	r27, 0x49
    26c4:	28 17       	cp	r18, r24
    26c6:	39 07       	cpc	r19, r25
    26c8:	4a 07       	cpc	r20, r26
    26ca:	5b 07       	cpc	r21, r27
    26cc:	78 f3       	brcs	.-34     	; 0x26ac <CO_collectSeismic1Channel+0x1c0>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    26ce:	80 e0       	ldi	r24, 0x00	; 0
    26d0:	99 e0       	ldi	r25, 0x09	; 9
    26d2:	20 e0       	ldi	r18, 0x00	; 0
    26d4:	39 e0       	ldi	r19, 0x09	; 9
    26d6:	f9 01       	movw	r30, r18
    26d8:	20 81       	ld	r18, Z
    26da:	20 7f       	andi	r18, 0xF0	; 240
    26dc:	fc 01       	movw	r30, r24
    26de:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    26e0:	80 e4       	ldi	r24, 0x40	; 64
    26e2:	9a e0       	ldi	r25, 0x0A	; 10
    26e4:	20 e4       	ldi	r18, 0x40	; 64
    26e6:	3a e0       	ldi	r19, 0x0A	; 10
    26e8:	f9 01       	movw	r30, r18
    26ea:	20 81       	ld	r18, Z
    26ec:	20 7f       	andi	r18, 0xF0	; 240
    26ee:	fc 01       	movw	r30, r24
    26f0:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    26f2:	80 ea       	ldi	r24, 0xA0	; 160
    26f4:	90 e0       	ldi	r25, 0x00	; 0
    26f6:	20 ea       	ldi	r18, 0xA0	; 160
    26f8:	30 e0       	ldi	r19, 0x00	; 0
    26fa:	f9 01       	movw	r30, r18
    26fc:	22 81       	ldd	r18, Z+2	; 0x02
    26fe:	29 7f       	andi	r18, 0xF9	; 249
    2700:	fc 01       	movw	r30, r24
    2702:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2704:	f8 94       	cli

	SPICS(FALSE);
    2706:	80 e0       	ldi	r24, 0x00	; 0
    2708:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    270c:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	enableADCMUX(FALSE);
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	0e 94 ff 09 	call	0x13fe	; 0x13fe <enableADCMUX>
	
}
    2716:	2d 96       	adiw	r28, 0x0d	; 13
    2718:	cd bf       	out	0x3d, r28	; 61
    271a:	de bf       	out	0x3e, r29	; 62
    271c:	df 91       	pop	r29
    271e:	cf 91       	pop	r28
    2720:	1f 91       	pop	r17
    2722:	0f 91       	pop	r16
    2724:	ef 90       	pop	r14
    2726:	df 90       	pop	r13
    2728:	cf 90       	pop	r12
    272a:	bf 90       	pop	r11
    272c:	af 90       	pop	r10
    272e:	9f 90       	pop	r9
    2730:	8f 90       	pop	r8
    2732:	08 95       	ret

00002734 <__vector_79>:

//first averaging point
ISR(TCD0_CCA_vect) {
    2734:	1f 92       	push	r1
    2736:	0f 92       	push	r0
    2738:	0f b6       	in	r0, 0x3f	; 63
    273a:	0f 92       	push	r0
    273c:	00 90 3b 00 	lds	r0, 0x003B
    2740:	0f 92       	push	r0
    2742:	11 24       	eor	r1, r1
    2744:	2f 93       	push	r18
    2746:	3f 93       	push	r19
    2748:	4f 93       	push	r20
    274a:	5f 93       	push	r21
    274c:	6f 93       	push	r22
    274e:	7f 93       	push	r23
    2750:	8f 93       	push	r24
    2752:	9f 93       	push	r25
    2754:	af 93       	push	r26
    2756:	bf 93       	push	r27
    2758:	ef 93       	push	r30
    275a:	ff 93       	push	r31
    275c:	cf 93       	push	r28
    275e:	df 93       	push	r29
    2760:	cd b7       	in	r28, 0x3d	; 61
    2762:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2764:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    2768:	df 91       	pop	r29
    276a:	cf 91       	pop	r28
    276c:	ff 91       	pop	r31
    276e:	ef 91       	pop	r30
    2770:	bf 91       	pop	r27
    2772:	af 91       	pop	r26
    2774:	9f 91       	pop	r25
    2776:	8f 91       	pop	r24
    2778:	7f 91       	pop	r23
    277a:	6f 91       	pop	r22
    277c:	5f 91       	pop	r21
    277e:	4f 91       	pop	r20
    2780:	3f 91       	pop	r19
    2782:	2f 91       	pop	r18
    2784:	0f 90       	pop	r0
    2786:	00 92 3b 00 	sts	0x003B, r0
    278a:	0f 90       	pop	r0
    278c:	0f be       	out	0x3f, r0	; 63
    278e:	0f 90       	pop	r0
    2790:	1f 90       	pop	r1
    2792:	18 95       	reti

00002794 <__vector_80>:
//second averaging point
ISR(TCD0_CCB_vect) {
    2794:	1f 92       	push	r1
    2796:	0f 92       	push	r0
    2798:	0f b6       	in	r0, 0x3f	; 63
    279a:	0f 92       	push	r0
    279c:	00 90 3b 00 	lds	r0, 0x003B
    27a0:	0f 92       	push	r0
    27a2:	11 24       	eor	r1, r1
    27a4:	2f 93       	push	r18
    27a6:	3f 93       	push	r19
    27a8:	4f 93       	push	r20
    27aa:	5f 93       	push	r21
    27ac:	6f 93       	push	r22
    27ae:	7f 93       	push	r23
    27b0:	8f 93       	push	r24
    27b2:	9f 93       	push	r25
    27b4:	af 93       	push	r26
    27b6:	bf 93       	push	r27
    27b8:	ef 93       	push	r30
    27ba:	ff 93       	push	r31
    27bc:	cf 93       	push	r28
    27be:	df 93       	push	r29
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    27c4:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    27c8:	df 91       	pop	r29
    27ca:	cf 91       	pop	r28
    27cc:	ff 91       	pop	r31
    27ce:	ef 91       	pop	r30
    27d0:	bf 91       	pop	r27
    27d2:	af 91       	pop	r26
    27d4:	9f 91       	pop	r25
    27d6:	8f 91       	pop	r24
    27d8:	7f 91       	pop	r23
    27da:	6f 91       	pop	r22
    27dc:	5f 91       	pop	r21
    27de:	4f 91       	pop	r20
    27e0:	3f 91       	pop	r19
    27e2:	2f 91       	pop	r18
    27e4:	0f 90       	pop	r0
    27e6:	00 92 3b 00 	sts	0x003B, r0
    27ea:	0f 90       	pop	r0
    27ec:	0f be       	out	0x3f, r0	; 63
    27ee:	0f 90       	pop	r0
    27f0:	1f 90       	pop	r1
    27f2:	18 95       	reti

000027f4 <__vector_81>:

//third averaging point
ISR(TCD0_CCC_vect) {
    27f4:	1f 92       	push	r1
    27f6:	0f 92       	push	r0
    27f8:	0f b6       	in	r0, 0x3f	; 63
    27fa:	0f 92       	push	r0
    27fc:	00 90 3b 00 	lds	r0, 0x003B
    2800:	0f 92       	push	r0
    2802:	11 24       	eor	r1, r1
    2804:	2f 93       	push	r18
    2806:	3f 93       	push	r19
    2808:	4f 93       	push	r20
    280a:	5f 93       	push	r21
    280c:	6f 93       	push	r22
    280e:	7f 93       	push	r23
    2810:	8f 93       	push	r24
    2812:	9f 93       	push	r25
    2814:	af 93       	push	r26
    2816:	bf 93       	push	r27
    2818:	ef 93       	push	r30
    281a:	ff 93       	push	r31
    281c:	cf 93       	push	r28
    281e:	df 93       	push	r29
    2820:	cd b7       	in	r28, 0x3d	; 61
    2822:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2824:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
}
    2828:	df 91       	pop	r29
    282a:	cf 91       	pop	r28
    282c:	ff 91       	pop	r31
    282e:	ef 91       	pop	r30
    2830:	bf 91       	pop	r27
    2832:	af 91       	pop	r26
    2834:	9f 91       	pop	r25
    2836:	8f 91       	pop	r24
    2838:	7f 91       	pop	r23
    283a:	6f 91       	pop	r22
    283c:	5f 91       	pop	r21
    283e:	4f 91       	pop	r20
    2840:	3f 91       	pop	r19
    2842:	2f 91       	pop	r18
    2844:	0f 90       	pop	r0
    2846:	00 92 3b 00 	sts	0x003B, r0
    284a:	0f 90       	pop	r0
    284c:	0f be       	out	0x3f, r0	; 63
    284e:	0f 90       	pop	r0
    2850:	1f 90       	pop	r1
    2852:	18 95       	reti

00002854 <__vector_82>:

//final averaging point
ISR(TCD0_CCD_vect) {
    2854:	1f 92       	push	r1
    2856:	0f 92       	push	r0
    2858:	0f b6       	in	r0, 0x3f	; 63
    285a:	0f 92       	push	r0
    285c:	00 90 3b 00 	lds	r0, 0x003B
    2860:	0f 92       	push	r0
    2862:	11 24       	eor	r1, r1
    2864:	2f 93       	push	r18
    2866:	3f 93       	push	r19
    2868:	4f 93       	push	r20
    286a:	5f 93       	push	r21
    286c:	6f 93       	push	r22
    286e:	7f 93       	push	r23
    2870:	8f 93       	push	r24
    2872:	9f 93       	push	r25
    2874:	af 93       	push	r26
    2876:	bf 93       	push	r27
    2878:	ef 93       	push	r30
    287a:	ff 93       	push	r31
    287c:	cf 93       	push	r28
    287e:	df 93       	push	r29
    2880:	cd b7       	in	r28, 0x3d	; 61
    2882:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2884:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sampleCurrentChannel>
	SPICount = 0;
    2888:	10 92 bf 50 	sts	0x50BF, r1
}
    288c:	df 91       	pop	r29
    288e:	cf 91       	pop	r28
    2890:	ff 91       	pop	r31
    2892:	ef 91       	pop	r30
    2894:	bf 91       	pop	r27
    2896:	af 91       	pop	r26
    2898:	9f 91       	pop	r25
    289a:	8f 91       	pop	r24
    289c:	7f 91       	pop	r23
    289e:	6f 91       	pop	r22
    28a0:	5f 91       	pop	r21
    28a2:	4f 91       	pop	r20
    28a4:	3f 91       	pop	r19
    28a6:	2f 91       	pop	r18
    28a8:	0f 90       	pop	r0
    28aa:	00 92 3b 00 	sts	0x003B, r0
    28ae:	0f 90       	pop	r0
    28b0:	0f be       	out	0x3f, r0	; 63
    28b2:	0f 90       	pop	r0
    28b4:	1f 90       	pop	r1
    28b6:	18 95       	reti

000028b8 <__vector_77>:

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    28b8:	1f 92       	push	r1
    28ba:	0f 92       	push	r0
    28bc:	0f b6       	in	r0, 0x3f	; 63
    28be:	0f 92       	push	r0
    28c0:	00 90 3b 00 	lds	r0, 0x003B
    28c4:	0f 92       	push	r0
    28c6:	11 24       	eor	r1, r1
    28c8:	2f 93       	push	r18
    28ca:	3f 93       	push	r19
    28cc:	4f 93       	push	r20
    28ce:	5f 93       	push	r21
    28d0:	6f 93       	push	r22
    28d2:	7f 93       	push	r23
    28d4:	8f 93       	push	r24
    28d6:	9f 93       	push	r25
    28d8:	af 93       	push	r26
    28da:	bf 93       	push	r27
    28dc:	ef 93       	push	r30
    28de:	ff 93       	push	r31
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	cd b7       	in	r28, 0x3d	; 61
    28e6:	de b7       	in	r29, 0x3e	; 62
    28e8:	29 97       	sbiw	r28, 0x09	; 9
    28ea:	cd bf       	out	0x3d, r28	; 61
    28ec:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    28ee:	1a 82       	std	Y+2, r1	; 0x02
    28f0:	1b 82       	std	Y+3, r1	; 0x03
    28f2:	1c 82       	std	Y+4, r1	; 0x04
    28f4:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    28f6:	19 82       	std	Y+1, r1	; 0x01
    28f8:	4f c0       	rjmp	.+158    	; 0x2998 <__vector_77+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    28fa:	89 81       	ldd	r24, Y+1	; 0x01
    28fc:	88 2f       	mov	r24, r24
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	8a 5a       	subi	r24, 0xAA	; 170
    2902:	9f 4a       	sbci	r25, 0xAF	; 175
    2904:	fc 01       	movw	r30, r24
    2906:	80 81       	ld	r24, Z
    2908:	88 23       	and	r24, r24
    290a:	3c f4       	brge	.+14     	; 0x291a <__vector_77+0x62>
    290c:	ce 01       	movw	r24, r28
    290e:	06 96       	adiw	r24, 0x06	; 6
    2910:	03 96       	adiw	r24, 0x03	; 3
    2912:	2f ef       	ldi	r18, 0xFF	; 255
    2914:	fc 01       	movw	r30, r24
    2916:	20 83       	st	Z, r18
    2918:	05 c0       	rjmp	.+10     	; 0x2924 <__vector_77+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    291a:	ce 01       	movw	r24, r28
    291c:	06 96       	adiw	r24, 0x06	; 6
    291e:	03 96       	adiw	r24, 0x03	; 3
    2920:	fc 01       	movw	r30, r24
    2922:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2924:	ce 01       	movw	r24, r28
    2926:	06 96       	adiw	r24, 0x06	; 6
    2928:	02 96       	adiw	r24, 0x02	; 2
    292a:	29 81       	ldd	r18, Y+1	; 0x01
    292c:	22 2f       	mov	r18, r18
    292e:	30 e0       	ldi	r19, 0x00	; 0
    2930:	2a 5a       	subi	r18, 0xAA	; 170
    2932:	3f 4a       	sbci	r19, 0xAF	; 175
    2934:	f9 01       	movw	r30, r18
    2936:	20 81       	ld	r18, Z
    2938:	fc 01       	movw	r30, r24
    293a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    293c:	ce 01       	movw	r24, r28
    293e:	06 96       	adiw	r24, 0x06	; 6
    2940:	01 96       	adiw	r24, 0x01	; 1
    2942:	29 81       	ldd	r18, Y+1	; 0x01
    2944:	22 2f       	mov	r18, r18
    2946:	30 e0       	ldi	r19, 0x00	; 0
    2948:	2f 5f       	subi	r18, 0xFF	; 255
    294a:	3f 4f       	sbci	r19, 0xFF	; 255
    294c:	2a 5a       	subi	r18, 0xAA	; 170
    294e:	3f 4a       	sbci	r19, 0xAF	; 175
    2950:	f9 01       	movw	r30, r18
    2952:	20 81       	ld	r18, Z
    2954:	fc 01       	movw	r30, r24
    2956:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2958:	ce 01       	movw	r24, r28
    295a:	06 96       	adiw	r24, 0x06	; 6
    295c:	29 81       	ldd	r18, Y+1	; 0x01
    295e:	22 2f       	mov	r18, r18
    2960:	30 e0       	ldi	r19, 0x00	; 0
    2962:	2e 5f       	subi	r18, 0xFE	; 254
    2964:	3f 4f       	sbci	r19, 0xFF	; 255
    2966:	2a 5a       	subi	r18, 0xAA	; 170
    2968:	3f 4a       	sbci	r19, 0xAF	; 175
    296a:	f9 01       	movw	r30, r18
    296c:	20 81       	ld	r18, Z
    296e:	fc 01       	movw	r30, r24
    2970:	20 83       	st	Z, r18
		sum += currentSample;
    2972:	2a 81       	ldd	r18, Y+2	; 0x02
    2974:	3b 81       	ldd	r19, Y+3	; 0x03
    2976:	4c 81       	ldd	r20, Y+4	; 0x04
    2978:	5d 81       	ldd	r21, Y+5	; 0x05
    297a:	8e 81       	ldd	r24, Y+6	; 0x06
    297c:	9f 81       	ldd	r25, Y+7	; 0x07
    297e:	a8 85       	ldd	r26, Y+8	; 0x08
    2980:	b9 85       	ldd	r27, Y+9	; 0x09
    2982:	82 0f       	add	r24, r18
    2984:	93 1f       	adc	r25, r19
    2986:	a4 1f       	adc	r26, r20
    2988:	b5 1f       	adc	r27, r21
    298a:	8a 83       	std	Y+2, r24	; 0x02
    298c:	9b 83       	std	Y+3, r25	; 0x03
    298e:	ac 83       	std	Y+4, r26	; 0x04
    2990:	bd 83       	std	Y+5, r27	; 0x05
ISR(TCD0_OVF_vect) {

	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	8d 5f       	subi	r24, 0xFD	; 253
    2996:	89 83       	std	Y+1, r24	; 0x01
    2998:	89 81       	ldd	r24, Y+1	; 0x01
    299a:	8c 30       	cpi	r24, 0x0C	; 12
    299c:	08 f4       	brcc	.+2      	; 0x29a0 <__vector_77+0xe8>
    299e:	ad cf       	rjmp	.-166    	; 0x28fa <__vector_77+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    29a0:	8a 81       	ldd	r24, Y+2	; 0x02
    29a2:	9b 81       	ldd	r25, Y+3	; 0x03
    29a4:	ac 81       	ldd	r26, Y+4	; 0x04
    29a6:	bd 81       	ldd	r27, Y+5	; 0x05
    29a8:	24 e0       	ldi	r18, 0x04	; 4
    29aa:	30 e0       	ldi	r19, 0x00	; 0
    29ac:	40 e0       	ldi	r20, 0x00	; 0
    29ae:	50 e0       	ldi	r21, 0x00	; 0
    29b0:	bc 01       	movw	r22, r24
    29b2:	cd 01       	movw	r24, r26
    29b4:	0e 94 e2 5d 	call	0xbbc4	; 0xbbc4 <__divmodsi4>
    29b8:	da 01       	movw	r26, r20
    29ba:	c9 01       	movw	r24, r18
    29bc:	8a 83       	std	Y+2, r24	; 0x02
    29be:	9b 83       	std	Y+3, r25	; 0x03
    29c0:	ac 83       	std	Y+4, r26	; 0x04
    29c2:	bd 83       	std	Y+5, r27	; 0x05
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    29c4:	20 91 63 50 	lds	r18, 0x5063
    29c8:	30 91 64 50 	lds	r19, 0x5064
    29cc:	80 91 65 50 	lds	r24, 0x5065
    29d0:	90 91 66 50 	lds	r25, 0x5066
    29d4:	a0 91 67 50 	lds	r26, 0x5067
    29d8:	b0 91 68 50 	lds	r27, 0x5068
    29dc:	88 0f       	add	r24, r24
    29de:	99 1f       	adc	r25, r25
    29e0:	88 0f       	add	r24, r24
    29e2:	99 1f       	adc	r25, r25
    29e4:	28 0f       	add	r18, r24
    29e6:	39 1f       	adc	r19, r25
    29e8:	8a 81       	ldd	r24, Y+2	; 0x02
    29ea:	9b 81       	ldd	r25, Y+3	; 0x03
    29ec:	ac 81       	ldd	r26, Y+4	; 0x04
    29ee:	bd 81       	ldd	r27, Y+5	; 0x05
    29f0:	f9 01       	movw	r30, r18
    29f2:	80 83       	st	Z, r24
    29f4:	91 83       	std	Z+1, r25	; 0x01
    29f6:	a2 83       	std	Z+2, r26	; 0x02
    29f8:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    29fa:	80 91 65 50 	lds	r24, 0x5065
    29fe:	90 91 66 50 	lds	r25, 0x5066
    2a02:	a0 91 67 50 	lds	r26, 0x5067
    2a06:	b0 91 68 50 	lds	r27, 0x5068
    2a0a:	01 96       	adiw	r24, 0x01	; 1
    2a0c:	a1 1d       	adc	r26, r1
    2a0e:	b1 1d       	adc	r27, r1
    2a10:	80 93 65 50 	sts	0x5065, r24
    2a14:	90 93 66 50 	sts	0x5066, r25
    2a18:	a0 93 67 50 	sts	0x5067, r26
    2a1c:	b0 93 68 50 	sts	0x5068, r27
}
    2a20:	29 96       	adiw	r28, 0x09	; 9
    2a22:	cd bf       	out	0x3d, r28	; 61
    2a24:	de bf       	out	0x3e, r29	; 62
    2a26:	df 91       	pop	r29
    2a28:	cf 91       	pop	r28
    2a2a:	ff 91       	pop	r31
    2a2c:	ef 91       	pop	r30
    2a2e:	bf 91       	pop	r27
    2a30:	af 91       	pop	r26
    2a32:	9f 91       	pop	r25
    2a34:	8f 91       	pop	r24
    2a36:	7f 91       	pop	r23
    2a38:	6f 91       	pop	r22
    2a3a:	5f 91       	pop	r21
    2a3c:	4f 91       	pop	r20
    2a3e:	3f 91       	pop	r19
    2a40:	2f 91       	pop	r18
    2a42:	0f 90       	pop	r0
    2a44:	00 92 3b 00 	sts	0x003B, r0
    2a48:	0f 90       	pop	r0
    2a4a:	0f be       	out	0x3f, r0	; 63
    2a4c:	0f 90       	pop	r0
    2a4e:	1f 90       	pop	r1
    2a50:	18 95       	reti

00002a52 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
    2a52:	cf 93       	push	r28
    2a54:	df 93       	push	r29
    2a56:	cd b7       	in	r28, 0x3d	; 61
    2a58:	de b7       	in	r29, 0x3e	; 62
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2a5a:	80 ea       	ldi	r24, 0xA0	; 160
    2a5c:	96 e0       	ldi	r25, 0x06	; 6
    2a5e:	22 e0       	ldi	r18, 0x02	; 2
    2a60:	fc 01       	movw	r30, r24
    2a62:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2a64:	80 ec       	ldi	r24, 0xC0	; 192
    2a66:	98 e0       	ldi	r25, 0x08	; 8
    2a68:	2a ea       	ldi	r18, 0xAA	; 170
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a6e:	00 00       	nop
    2a70:	80 ec       	ldi	r24, 0xC0	; 192
    2a72:	98 e0       	ldi	r25, 0x08	; 8
    2a74:	fc 01       	movw	r30, r24
    2a76:	82 81       	ldd	r24, Z+2	; 0x02
    2a78:	88 23       	and	r24, r24
    2a7a:	d4 f7       	brge	.-12     	; 0x2a70 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    2a7c:	80 91 bf 50 	lds	r24, 0x50BF
    2a80:	88 2f       	mov	r24, r24
    2a82:	90 e0       	ldi	r25, 0x00	; 0
    2a84:	20 ec       	ldi	r18, 0xC0	; 192
    2a86:	38 e0       	ldi	r19, 0x08	; 8
    2a88:	f9 01       	movw	r30, r18
    2a8a:	23 81       	ldd	r18, Z+3	; 0x03
    2a8c:	8a 5a       	subi	r24, 0xAA	; 170
    2a8e:	9f 4a       	sbci	r25, 0xAF	; 175
    2a90:	fc 01       	movw	r30, r24
    2a92:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2a94:	80 ec       	ldi	r24, 0xC0	; 192
    2a96:	98 e0       	ldi	r25, 0x08	; 8
    2a98:	2a ea       	ldi	r18, 0xAA	; 170
    2a9a:	fc 01       	movw	r30, r24
    2a9c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a9e:	00 00       	nop
    2aa0:	80 ec       	ldi	r24, 0xC0	; 192
    2aa2:	98 e0       	ldi	r25, 0x08	; 8
    2aa4:	fc 01       	movw	r30, r24
    2aa6:	82 81       	ldd	r24, Z+2	; 0x02
    2aa8:	88 23       	and	r24, r24
    2aaa:	d4 f7       	brge	.-12     	; 0x2aa0 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2aac:	80 91 bf 50 	lds	r24, 0x50BF
    2ab0:	88 2f       	mov	r24, r24
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	01 96       	adiw	r24, 0x01	; 1
    2ab6:	20 ec       	ldi	r18, 0xC0	; 192
    2ab8:	38 e0       	ldi	r19, 0x08	; 8
    2aba:	f9 01       	movw	r30, r18
    2abc:	23 81       	ldd	r18, Z+3	; 0x03
    2abe:	8a 5a       	subi	r24, 0xAA	; 170
    2ac0:	9f 4a       	sbci	r25, 0xAF	; 175
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2ac6:	80 ec       	ldi	r24, 0xC0	; 192
    2ac8:	98 e0       	ldi	r25, 0x08	; 8
    2aca:	2a ea       	ldi	r18, 0xAA	; 170
    2acc:	fc 01       	movw	r30, r24
    2ace:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ad0:	00 00       	nop
    2ad2:	80 ec       	ldi	r24, 0xC0	; 192
    2ad4:	98 e0       	ldi	r25, 0x08	; 8
    2ad6:	fc 01       	movw	r30, r24
    2ad8:	82 81       	ldd	r24, Z+2	; 0x02
    2ada:	88 23       	and	r24, r24
    2adc:	d4 f7       	brge	.-12     	; 0x2ad2 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2ade:	80 91 bf 50 	lds	r24, 0x50BF
    2ae2:	88 2f       	mov	r24, r24
    2ae4:	90 e0       	ldi	r25, 0x00	; 0
    2ae6:	02 96       	adiw	r24, 0x02	; 2
    2ae8:	20 ec       	ldi	r18, 0xC0	; 192
    2aea:	38 e0       	ldi	r19, 0x08	; 8
    2aec:	f9 01       	movw	r30, r18
    2aee:	23 81       	ldd	r18, Z+3	; 0x03
    2af0:	8a 5a       	subi	r24, 0xAA	; 170
    2af2:	9f 4a       	sbci	r25, 0xAF	; 175
    2af4:	fc 01       	movw	r30, r24
    2af6:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2af8:	80 ea       	ldi	r24, 0xA0	; 160
    2afa:	96 e0       	ldi	r25, 0x06	; 6
    2afc:	22 e0       	ldi	r18, 0x02	; 2
    2afe:	fc 01       	movw	r30, r24
    2b00:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2b02:	80 91 bf 50 	lds	r24, 0x50BF
    2b06:	8d 5f       	subi	r24, 0xFD	; 253
    2b08:	80 93 bf 50 	sts	0x50BF, r24
}
    2b0c:	df 91       	pop	r29
    2b0e:	cf 91       	pop	r28
    2b10:	08 95       	ret

00002b12 <writeSE2FRAM>:

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2b12:	cf 93       	push	r28
    2b14:	df 93       	push	r29
    2b16:	cd b7       	in	r28, 0x3d	; 61
    2b18:	de b7       	in	r29, 0x3e	; 62
    2b1a:	29 97       	sbiw	r28, 0x09	; 9
    2b1c:	cd bf       	out	0x3d, r28	; 61
    2b1e:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2b20:	1a 82       	std	Y+2, r1	; 0x02
    2b22:	1b 82       	std	Y+3, r1	; 0x03
    2b24:	1c 82       	std	Y+4, r1	; 0x04
    2b26:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2b28:	80 91 65 50 	lds	r24, 0x5065
    2b2c:	90 91 66 50 	lds	r25, 0x5066
    2b30:	a0 91 67 50 	lds	r26, 0x5067
    2b34:	b0 91 68 50 	lds	r27, 0x5068
    2b38:	01 96       	adiw	r24, 0x01	; 1
    2b3a:	a1 1d       	adc	r26, r1
    2b3c:	b1 1d       	adc	r27, r1
    2b3e:	80 93 65 50 	sts	0x5065, r24
    2b42:	90 93 66 50 	sts	0x5066, r25
    2b46:	a0 93 67 50 	sts	0x5067, r26
    2b4a:	b0 93 68 50 	sts	0x5068, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2b4e:	80 ec       	ldi	r24, 0xC0	; 192
    2b50:	98 e0       	ldi	r25, 0x08	; 8
    2b52:	20 ed       	ldi	r18, 0xD0	; 208
    2b54:	fc 01       	movw	r30, r24
    2b56:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2b58:	19 82       	std	Y+1, r1	; 0x01
    2b5a:	4f c0       	rjmp	.+158    	; 0x2bfa <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2b5c:	89 81       	ldd	r24, Y+1	; 0x01
    2b5e:	88 2f       	mov	r24, r24
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	8a 5a       	subi	r24, 0xAA	; 170
    2b64:	9f 4a       	sbci	r25, 0xAF	; 175
    2b66:	fc 01       	movw	r30, r24
    2b68:	80 81       	ld	r24, Z
    2b6a:	88 23       	and	r24, r24
    2b6c:	3c f4       	brge	.+14     	; 0x2b7c <writeSE2FRAM+0x6a>
    2b6e:	ce 01       	movw	r24, r28
    2b70:	06 96       	adiw	r24, 0x06	; 6
    2b72:	03 96       	adiw	r24, 0x03	; 3
    2b74:	2f ef       	ldi	r18, 0xFF	; 255
    2b76:	fc 01       	movw	r30, r24
    2b78:	20 83       	st	Z, r18
    2b7a:	05 c0       	rjmp	.+10     	; 0x2b86 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2b7c:	ce 01       	movw	r24, r28
    2b7e:	06 96       	adiw	r24, 0x06	; 6
    2b80:	03 96       	adiw	r24, 0x03	; 3
    2b82:	fc 01       	movw	r30, r24
    2b84:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2b86:	ce 01       	movw	r24, r28
    2b88:	06 96       	adiw	r24, 0x06	; 6
    2b8a:	02 96       	adiw	r24, 0x02	; 2
    2b8c:	29 81       	ldd	r18, Y+1	; 0x01
    2b8e:	22 2f       	mov	r18, r18
    2b90:	30 e0       	ldi	r19, 0x00	; 0
    2b92:	2a 5a       	subi	r18, 0xAA	; 170
    2b94:	3f 4a       	sbci	r19, 0xAF	; 175
    2b96:	f9 01       	movw	r30, r18
    2b98:	20 81       	ld	r18, Z
    2b9a:	fc 01       	movw	r30, r24
    2b9c:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2b9e:	ce 01       	movw	r24, r28
    2ba0:	06 96       	adiw	r24, 0x06	; 6
    2ba2:	01 96       	adiw	r24, 0x01	; 1
    2ba4:	29 81       	ldd	r18, Y+1	; 0x01
    2ba6:	22 2f       	mov	r18, r18
    2ba8:	30 e0       	ldi	r19, 0x00	; 0
    2baa:	2f 5f       	subi	r18, 0xFF	; 255
    2bac:	3f 4f       	sbci	r19, 0xFF	; 255
    2bae:	2a 5a       	subi	r18, 0xAA	; 170
    2bb0:	3f 4a       	sbci	r19, 0xAF	; 175
    2bb2:	f9 01       	movw	r30, r18
    2bb4:	20 81       	ld	r18, Z
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2bba:	ce 01       	movw	r24, r28
    2bbc:	06 96       	adiw	r24, 0x06	; 6
    2bbe:	29 81       	ldd	r18, Y+1	; 0x01
    2bc0:	22 2f       	mov	r18, r18
    2bc2:	30 e0       	ldi	r19, 0x00	; 0
    2bc4:	2e 5f       	subi	r18, 0xFE	; 254
    2bc6:	3f 4f       	sbci	r19, 0xFF	; 255
    2bc8:	2a 5a       	subi	r18, 0xAA	; 170
    2bca:	3f 4a       	sbci	r19, 0xAF	; 175
    2bcc:	f9 01       	movw	r30, r18
    2bce:	20 81       	ld	r18, Z
    2bd0:	fc 01       	movw	r30, r24
    2bd2:	20 83       	st	Z, r18
		sum += currentSample;
    2bd4:	2a 81       	ldd	r18, Y+2	; 0x02
    2bd6:	3b 81       	ldd	r19, Y+3	; 0x03
    2bd8:	4c 81       	ldd	r20, Y+4	; 0x04
    2bda:	5d 81       	ldd	r21, Y+5	; 0x05
    2bdc:	8e 81       	ldd	r24, Y+6	; 0x06
    2bde:	9f 81       	ldd	r25, Y+7	; 0x07
    2be0:	a8 85       	ldd	r26, Y+8	; 0x08
    2be2:	b9 85       	ldd	r27, Y+9	; 0x09
    2be4:	82 0f       	add	r24, r18
    2be6:	93 1f       	adc	r25, r19
    2be8:	a4 1f       	adc	r26, r20
    2bea:	b5 1f       	adc	r27, r21
    2bec:	8a 83       	std	Y+2, r24	; 0x02
    2bee:	9b 83       	std	Y+3, r25	; 0x03
    2bf0:	ac 83       	std	Y+4, r26	; 0x04
    2bf2:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2bf4:	89 81       	ldd	r24, Y+1	; 0x01
    2bf6:	8d 5f       	subi	r24, 0xFD	; 253
    2bf8:	89 83       	std	Y+1, r24	; 0x01
    2bfa:	89 81       	ldd	r24, Y+1	; 0x01
    2bfc:	8c 30       	cpi	r24, 0x0C	; 12
    2bfe:	08 f4       	brcc	.+2      	; 0x2c02 <writeSE2FRAM+0xf0>
    2c00:	ad cf       	rjmp	.-166    	; 0x2b5c <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2c02:	8a 81       	ldd	r24, Y+2	; 0x02
    2c04:	9b 81       	ldd	r25, Y+3	; 0x03
    2c06:	ac 81       	ldd	r26, Y+4	; 0x04
    2c08:	bd 81       	ldd	r27, Y+5	; 0x05
    2c0a:	24 e0       	ldi	r18, 0x04	; 4
    2c0c:	30 e0       	ldi	r19, 0x00	; 0
    2c0e:	40 e0       	ldi	r20, 0x00	; 0
    2c10:	50 e0       	ldi	r21, 0x00	; 0
    2c12:	bc 01       	movw	r22, r24
    2c14:	cd 01       	movw	r24, r26
    2c16:	0e 94 e2 5d 	call	0xbbc4	; 0xbbc4 <__divmodsi4>
    2c1a:	da 01       	movw	r26, r20
    2c1c:	c9 01       	movw	r24, r18
    2c1e:	8a 83       	std	Y+2, r24	; 0x02
    2c20:	9b 83       	std	Y+3, r25	; 0x03
    2c22:	ac 83       	std	Y+4, r26	; 0x04
    2c24:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2c26:	ce 01       	movw	r24, r28
    2c28:	02 96       	adiw	r24, 0x02	; 2
    2c2a:	fc 01       	movw	r30, r24
    2c2c:	80 81       	ld	r24, Z
    2c2e:	80 93 58 50 	sts	0x5058, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2c32:	ce 01       	movw	r24, r28
    2c34:	02 96       	adiw	r24, 0x02	; 2
    2c36:	fc 01       	movw	r30, r24
    2c38:	81 81       	ldd	r24, Z+1	; 0x01
    2c3a:	80 93 57 50 	sts	0x5057, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2c3e:	ce 01       	movw	r24, r28
    2c40:	02 96       	adiw	r24, 0x02	; 2
    2c42:	fc 01       	movw	r30, r24
    2c44:	82 81       	ldd	r24, Z+2	; 0x02
    2c46:	80 93 56 50 	sts	0x5056, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2c4a:	80 e4       	ldi	r24, 0x40	; 64
    2c4c:	96 e0       	ldi	r25, 0x06	; 6
    2c4e:	20 e1       	ldi	r18, 0x10	; 16
    2c50:	fc 01       	movw	r30, r24
    2c52:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2c54:	80 e2       	ldi	r24, 0x20	; 32
    2c56:	96 e0       	ldi	r25, 0x06	; 6
    2c58:	28 e0       	ldi	r18, 0x08	; 8
    2c5a:	fc 01       	movw	r30, r24
    2c5c:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2c5e:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2c60:	80 ec       	ldi	r24, 0xC0	; 192
    2c62:	98 e0       	ldi	r25, 0x08	; 8
    2c64:	26 e0       	ldi	r18, 0x06	; 6
    2c66:	fc 01       	movw	r30, r24
    2c68:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2c6a:	00 00       	nop
    2c6c:	80 ec       	ldi	r24, 0xC0	; 192
    2c6e:	98 e0       	ldi	r25, 0x08	; 8
    2c70:	fc 01       	movw	r30, r24
    2c72:	82 81       	ldd	r24, Z+2	; 0x02
    2c74:	88 23       	and	r24, r24
    2c76:	d4 f7       	brge	.-12     	; 0x2c6c <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    2c78:	80 ec       	ldi	r24, 0xC0	; 192
    2c7a:	98 e0       	ldi	r25, 0x08	; 8
    2c7c:	fc 01       	movw	r30, r24
    2c7e:	83 81       	ldd	r24, Z+3	; 0x03
    2c80:	80 93 62 50 	sts	0x5062, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2c84:	80 e2       	ldi	r24, 0x20	; 32
    2c86:	96 e0       	ldi	r25, 0x06	; 6
    2c88:	28 e0       	ldi	r18, 0x08	; 8
    2c8a:	fc 01       	movw	r30, r24
    2c8c:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2c8e:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2c90:	80 e2       	ldi	r24, 0x20	; 32
    2c92:	96 e0       	ldi	r25, 0x06	; 6
    2c94:	28 e0       	ldi	r18, 0x08	; 8
    2c96:	fc 01       	movw	r30, r24
    2c98:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2c9a:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2c9c:	80 ec       	ldi	r24, 0xC0	; 192
    2c9e:	98 e0       	ldi	r25, 0x08	; 8
    2ca0:	22 e0       	ldi	r18, 0x02	; 2
    2ca2:	fc 01       	movw	r30, r24
    2ca4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ca6:	00 00       	nop
    2ca8:	80 ec       	ldi	r24, 0xC0	; 192
    2caa:	98 e0       	ldi	r25, 0x08	; 8
    2cac:	fc 01       	movw	r30, r24
    2cae:	82 81       	ldd	r24, Z+2	; 0x02
    2cb0:	88 23       	and	r24, r24
    2cb2:	d4 f7       	brge	.-12     	; 0x2ca8 <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    2cb4:	80 ec       	ldi	r24, 0xC0	; 192
    2cb6:	98 e0       	ldi	r25, 0x08	; 8
    2cb8:	fc 01       	movw	r30, r24
    2cba:	83 81       	ldd	r24, Z+3	; 0x03
    2cbc:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2cc0:	80 ec       	ldi	r24, 0xC0	; 192
    2cc2:	98 e0       	ldi	r25, 0x08	; 8
    2cc4:	20 91 49 40 	lds	r18, 0x4049
    2cc8:	fc 01       	movw	r30, r24
    2cca:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ccc:	00 00       	nop
    2cce:	80 ec       	ldi	r24, 0xC0	; 192
    2cd0:	98 e0       	ldi	r25, 0x08	; 8
    2cd2:	fc 01       	movw	r30, r24
    2cd4:	82 81       	ldd	r24, Z+2	; 0x02
    2cd6:	88 23       	and	r24, r24
    2cd8:	d4 f7       	brge	.-12     	; 0x2cce <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    2cda:	80 ec       	ldi	r24, 0xC0	; 192
    2cdc:	98 e0       	ldi	r25, 0x08	; 8
    2cde:	fc 01       	movw	r30, r24
    2ce0:	83 81       	ldd	r24, Z+3	; 0x03
    2ce2:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2ce6:	80 ec       	ldi	r24, 0xC0	; 192
    2ce8:	98 e0       	ldi	r25, 0x08	; 8
    2cea:	28 e4       	ldi	r18, 0x48	; 72
    2cec:	30 e4       	ldi	r19, 0x40	; 64
    2cee:	f9 01       	movw	r30, r18
    2cf0:	20 81       	ld	r18, Z
    2cf2:	fc 01       	movw	r30, r24
    2cf4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2cf6:	00 00       	nop
    2cf8:	80 ec       	ldi	r24, 0xC0	; 192
    2cfa:	98 e0       	ldi	r25, 0x08	; 8
    2cfc:	fc 01       	movw	r30, r24
    2cfe:	82 81       	ldd	r24, Z+2	; 0x02
    2d00:	88 23       	and	r24, r24
    2d02:	d4 f7       	brge	.-12     	; 0x2cf8 <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    2d04:	80 ec       	ldi	r24, 0xC0	; 192
    2d06:	98 e0       	ldi	r25, 0x08	; 8
    2d08:	fc 01       	movw	r30, r24
    2d0a:	83 81       	ldd	r24, Z+3	; 0x03
    2d0c:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = SPIBuffer[0];
    2d10:	80 ec       	ldi	r24, 0xC0	; 192
    2d12:	98 e0       	ldi	r25, 0x08	; 8
    2d14:	20 91 56 50 	lds	r18, 0x5056
    2d18:	fc 01       	movw	r30, r24
    2d1a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d1c:	00 00       	nop
    2d1e:	80 ec       	ldi	r24, 0xC0	; 192
    2d20:	98 e0       	ldi	r25, 0x08	; 8
    2d22:	fc 01       	movw	r30, r24
    2d24:	82 81       	ldd	r24, Z+2	; 0x02
    2d26:	88 23       	and	r24, r24
    2d28:	d4 f7       	brge	.-12     	; 0x2d1e <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    2d2a:	80 ec       	ldi	r24, 0xC0	; 192
    2d2c:	98 e0       	ldi	r25, 0x08	; 8
    2d2e:	fc 01       	movw	r30, r24
    2d30:	83 81       	ldd	r24, Z+3	; 0x03
    2d32:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = SPIBuffer[1];
    2d36:	80 ec       	ldi	r24, 0xC0	; 192
    2d38:	98 e0       	ldi	r25, 0x08	; 8
    2d3a:	20 91 57 50 	lds	r18, 0x5057
    2d3e:	fc 01       	movw	r30, r24
    2d40:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d42:	00 00       	nop
    2d44:	80 ec       	ldi	r24, 0xC0	; 192
    2d46:	98 e0       	ldi	r25, 0x08	; 8
    2d48:	fc 01       	movw	r30, r24
    2d4a:	82 81       	ldd	r24, Z+2	; 0x02
    2d4c:	88 23       	and	r24, r24
    2d4e:	d4 f7       	brge	.-12     	; 0x2d44 <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    2d50:	80 ec       	ldi	r24, 0xC0	; 192
    2d52:	98 e0       	ldi	r25, 0x08	; 8
    2d54:	fc 01       	movw	r30, r24
    2d56:	83 81       	ldd	r24, Z+3	; 0x03
    2d58:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = SPIBuffer[2];
    2d5c:	80 ec       	ldi	r24, 0xC0	; 192
    2d5e:	98 e0       	ldi	r25, 0x08	; 8
    2d60:	20 91 58 50 	lds	r18, 0x5058
    2d64:	fc 01       	movw	r30, r24
    2d66:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d68:	00 00       	nop
    2d6a:	80 ec       	ldi	r24, 0xC0	; 192
    2d6c:	98 e0       	ldi	r25, 0x08	; 8
    2d6e:	fc 01       	movw	r30, r24
    2d70:	82 81       	ldd	r24, Z+2	; 0x02
    2d72:	88 23       	and	r24, r24
    2d74:	d4 f7       	brge	.-12     	; 0x2d6a <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    2d76:	80 ec       	ldi	r24, 0xC0	; 192
    2d78:	98 e0       	ldi	r25, 0x08	; 8
    2d7a:	fc 01       	movw	r30, r24
    2d7c:	83 81       	ldd	r24, Z+3	; 0x03
    2d7e:	80 93 62 50 	sts	0x5062, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2d82:	80 e2       	ldi	r24, 0x20	; 32
    2d84:	96 e0       	ldi	r25, 0x06	; 6
    2d86:	28 e0       	ldi	r18, 0x08	; 8
    2d88:	fc 01       	movw	r30, r24
    2d8a:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2d8c:	80 e4       	ldi	r24, 0x40	; 64
    2d8e:	96 e0       	ldi	r25, 0x06	; 6
    2d90:	20 e1       	ldi	r18, 0x10	; 16
    2d92:	fc 01       	movw	r30, r24
    2d94:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2d96:	80 ec       	ldi	r24, 0xC0	; 192
    2d98:	98 e0       	ldi	r25, 0x08	; 8
    2d9a:	24 e5       	ldi	r18, 0x54	; 84
    2d9c:	fc 01       	movw	r30, r24
    2d9e:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2da0:	80 e4       	ldi	r24, 0x40	; 64
    2da2:	96 e0       	ldi	r25, 0x06	; 6
    2da4:	20 e1       	ldi	r18, 0x10	; 16
    2da6:	fc 01       	movw	r30, r24
    2da8:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2daa:	80 91 48 40 	lds	r24, 0x4048
    2dae:	90 91 49 40 	lds	r25, 0x4049
    2db2:	03 96       	adiw	r24, 0x03	; 3
    2db4:	80 93 48 40 	sts	0x4048, r24
    2db8:	90 93 49 40 	sts	0x4049, r25
	checksumADC[0] += SPIBuffer[0];
    2dbc:	90 91 2a 21 	lds	r25, 0x212A
    2dc0:	80 91 56 50 	lds	r24, 0x5056
    2dc4:	89 0f       	add	r24, r25
    2dc6:	80 93 2a 21 	sts	0x212A, r24
	checksumADC[1] += SPIBuffer[1];
    2dca:	90 91 2b 21 	lds	r25, 0x212B
    2dce:	80 91 57 50 	lds	r24, 0x5057
    2dd2:	89 0f       	add	r24, r25
    2dd4:	80 93 2b 21 	sts	0x212B, r24
	checksumADC[2] += SPIBuffer[2];
    2dd8:	90 91 2c 21 	lds	r25, 0x212C
    2ddc:	80 91 58 50 	lds	r24, 0x5058
    2de0:	89 0f       	add	r24, r25
    2de2:	80 93 2c 21 	sts	0x212C, r24
}
    2de6:	29 96       	adiw	r28, 0x09	; 9
    2de8:	cd bf       	out	0x3d, r28	; 61
    2dea:	de bf       	out	0x3e, r29	; 62
    2dec:	df 91       	pop	r29
    2dee:	cf 91       	pop	r28
    2df0:	08 95       	ret

00002df2 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    2df2:	2f 92       	push	r2
    2df4:	3f 92       	push	r3
    2df6:	4f 92       	push	r4
    2df8:	5f 92       	push	r5
    2dfa:	6f 92       	push	r6
    2dfc:	7f 92       	push	r7
    2dfe:	8f 92       	push	r8
    2e00:	9f 92       	push	r9
    2e02:	af 92       	push	r10
    2e04:	bf 92       	push	r11
    2e06:	cf 92       	push	r12
    2e08:	df 92       	push	r13
    2e0a:	ef 92       	push	r14
    2e0c:	ff 92       	push	r15
    2e0e:	0f 93       	push	r16
    2e10:	1f 93       	push	r17
    2e12:	cf 93       	push	r28
    2e14:	df 93       	push	r29
    2e16:	00 d0       	rcall	.+0      	; 0x2e18 <calcChecksumFRAM+0x26>
    2e18:	0f 92       	push	r0
    2e1a:	cd b7       	in	r28, 0x3d	; 61
    2e1c:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2e1e:	aa 24       	eor	r10, r10
    2e20:	bb 24       	eor	r11, r11
    2e22:	cc 24       	eor	r12, r12
    2e24:	dd 24       	eor	r13, r13
    2e26:	ee 24       	eor	r14, r14
    2e28:	ff 24       	eor	r15, r15
    2e2a:	00 e0       	ldi	r16, 0x00	; 0
    2e2c:	10 e0       	ldi	r17, 0x00	; 0
    2e2e:	a0 92 8c 50 	sts	0x508C, r10
    2e32:	b0 92 8d 50 	sts	0x508D, r11
    2e36:	c0 92 8e 50 	sts	0x508E, r12
    2e3a:	d0 92 8f 50 	sts	0x508F, r13
    2e3e:	e0 92 90 50 	sts	0x5090, r14
    2e42:	f0 92 91 50 	sts	0x5091, r15
    2e46:	00 93 92 50 	sts	0x5092, r16
    2e4a:	10 93 93 50 	sts	0x5093, r17
    2e4e:	2a 2d       	mov	r18, r10
    2e50:	3b 2d       	mov	r19, r11
    2e52:	4c 2d       	mov	r20, r12
    2e54:	5d 2d       	mov	r21, r13
    2e56:	6e 2d       	mov	r22, r14
    2e58:	7f 2d       	mov	r23, r15
    2e5a:	80 2f       	mov	r24, r16
    2e5c:	91 2f       	mov	r25, r17
    2e5e:	20 93 84 50 	sts	0x5084, r18
    2e62:	30 93 85 50 	sts	0x5085, r19
    2e66:	40 93 86 50 	sts	0x5086, r20
    2e6a:	50 93 87 50 	sts	0x5087, r21
    2e6e:	60 93 88 50 	sts	0x5088, r22
    2e72:	70 93 89 50 	sts	0x5089, r23
    2e76:	80 93 8a 50 	sts	0x508A, r24
    2e7a:	90 93 8b 50 	sts	0x508B, r25
    2e7e:	20 93 7c 50 	sts	0x507C, r18
    2e82:	30 93 7d 50 	sts	0x507D, r19
    2e86:	40 93 7e 50 	sts	0x507E, r20
    2e8a:	50 93 7f 50 	sts	0x507F, r21
    2e8e:	60 93 80 50 	sts	0x5080, r22
    2e92:	70 93 81 50 	sts	0x5081, r23
    2e96:	80 93 82 50 	sts	0x5082, r24
    2e9a:	90 93 83 50 	sts	0x5083, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2e9e:	80 e0       	ldi	r24, 0x00	; 0
    2ea0:	80 93 2f 21 	sts	0x212F, r24
    2ea4:	80 93 2e 21 	sts	0x212E, r24
    2ea8:	80 93 2d 21 	sts	0x212D, r24
	FRAMAddress = FR_BASEADD;
    2eac:	10 92 48 40 	sts	0x4048, r1
    2eb0:	10 92 49 40 	sts	0x4049, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2eb4:	19 82       	std	Y+1, r1	; 0x01
    2eb6:	1a 82       	std	Y+2, r1	; 0x02
    2eb8:	88 c2       	rjmp	.+1296   	; 0x33ca <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2eba:	81 e7       	ldi	r24, 0x71	; 113
    2ebc:	9c e1       	ldi	r25, 0x1C	; 28
    2ebe:	0e 94 fa 38 	call	0x71f4	; 0x71f4 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2ec2:	80 91 48 40 	lds	r24, 0x4048
    2ec6:	90 91 49 40 	lds	r25, 0x4049
    2eca:	8f 58       	subi	r24, 0x8F	; 143
    2ecc:	93 4e       	sbci	r25, 0xE3	; 227
    2ece:	80 93 48 40 	sts	0x4048, r24
    2ed2:	90 93 49 40 	sts	0x4049, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2ed6:	1b 82       	std	Y+3, r1	; 0x03
    2ed8:	1c 82       	std	Y+4, r1	; 0x04
    2eda:	6b c2       	rjmp	.+1238   	; 0x33b2 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2edc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ede:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee0:	23 e0       	ldi	r18, 0x03	; 3
    2ee2:	30 e0       	ldi	r19, 0x00	; 0
    2ee4:	b9 01       	movw	r22, r18
    2ee6:	0e 94 99 5d 	call	0xbb32	; 0xbb32 <__udivmodhi4>
    2eea:	9c 01       	movw	r18, r24
    2eec:	23 5d       	subi	r18, 0xD3	; 211
    2eee:	3e 4d       	sbci	r19, 0xDE	; 222
    2ef0:	f9 01       	movw	r30, r18
    2ef2:	40 81       	ld	r20, Z
    2ef4:	2b 81       	ldd	r18, Y+3	; 0x03
    2ef6:	3c 81       	ldd	r19, Y+4	; 0x04
    2ef8:	20 53       	subi	r18, 0x30	; 48
    2efa:	3c 4d       	sbci	r19, 0xDC	; 220
    2efc:	f9 01       	movw	r30, r18
    2efe:	20 81       	ld	r18, Z
    2f00:	24 0f       	add	r18, r20
    2f02:	83 5d       	subi	r24, 0xD3	; 211
    2f04:	9e 4d       	sbci	r25, 0xDE	; 222
    2f06:	fc 01       	movw	r30, r24
    2f08:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f0e:	23 e0       	ldi	r18, 0x03	; 3
    2f10:	30 e0       	ldi	r19, 0x00	; 0
    2f12:	b9 01       	movw	r22, r18
    2f14:	0e 94 99 5d 	call	0xbb32	; 0xbb32 <__udivmodhi4>
    2f18:	00 97       	sbiw	r24, 0x00	; 0
    2f1a:	09 f0       	breq	.+2      	; 0x2f1e <calcChecksumFRAM+0x12c>
    2f1c:	44 c0       	rjmp	.+136    	; 0x2fa6 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f20:	9c 81       	ldd	r25, Y+4	; 0x04
    2f22:	80 53       	subi	r24, 0x30	; 48
    2f24:	9c 4d       	sbci	r25, 0xDC	; 220
    2f26:	fc 01       	movw	r30, r24
    2f28:	80 81       	ld	r24, Z
    2f2a:	88 23       	and	r24, r24
    2f2c:	d4 f4       	brge	.+52     	; 0x2f62 <calcChecksumFRAM+0x170>
    2f2e:	80 91 54 50 	lds	r24, 0x5054
    2f32:	90 91 55 50 	lds	r25, 0x5055
    2f36:	fc 01       	movw	r30, r24
    2f38:	10 82       	st	Z, r1
    2f3a:	fc 01       	movw	r30, r24
    2f3c:	11 82       	std	Z+1, r1	; 0x01
    2f3e:	fc 01       	movw	r30, r24
    2f40:	12 82       	std	Z+2, r1	; 0x02
    2f42:	2f ef       	ldi	r18, 0xFF	; 255
    2f44:	fc 01       	movw	r30, r24
    2f46:	23 83       	std	Z+3, r18	; 0x03
    2f48:	2f ef       	ldi	r18, 0xFF	; 255
    2f4a:	fc 01       	movw	r30, r24
    2f4c:	24 83       	std	Z+4, r18	; 0x04
    2f4e:	2f ef       	ldi	r18, 0xFF	; 255
    2f50:	fc 01       	movw	r30, r24
    2f52:	25 83       	std	Z+5, r18	; 0x05
    2f54:	2f ef       	ldi	r18, 0xFF	; 255
    2f56:	fc 01       	movw	r30, r24
    2f58:	26 83       	std	Z+6, r18	; 0x06
    2f5a:	2f ef       	ldi	r18, 0xFF	; 255
    2f5c:	fc 01       	movw	r30, r24
    2f5e:	27 83       	std	Z+7, r18	; 0x07
    2f60:	14 c0       	rjmp	.+40     	; 0x2f8a <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2f62:	80 91 54 50 	lds	r24, 0x5054
    2f66:	90 91 55 50 	lds	r25, 0x5055
    2f6a:	fc 01       	movw	r30, r24
    2f6c:	10 82       	st	Z, r1
    2f6e:	fc 01       	movw	r30, r24
    2f70:	11 82       	std	Z+1, r1	; 0x01
    2f72:	fc 01       	movw	r30, r24
    2f74:	12 82       	std	Z+2, r1	; 0x02
    2f76:	fc 01       	movw	r30, r24
    2f78:	13 82       	std	Z+3, r1	; 0x03
    2f7a:	fc 01       	movw	r30, r24
    2f7c:	14 82       	std	Z+4, r1	; 0x04
    2f7e:	fc 01       	movw	r30, r24
    2f80:	15 82       	std	Z+5, r1	; 0x05
    2f82:	fc 01       	movw	r30, r24
    2f84:	16 82       	std	Z+6, r1	; 0x06
    2f86:	fc 01       	movw	r30, r24
    2f88:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2f8a:	80 91 54 50 	lds	r24, 0x5054
    2f8e:	90 91 55 50 	lds	r25, 0x5055
    2f92:	02 96       	adiw	r24, 0x02	; 2
    2f94:	2b 81       	ldd	r18, Y+3	; 0x03
    2f96:	3c 81       	ldd	r19, Y+4	; 0x04
    2f98:	20 53       	subi	r18, 0x30	; 48
    2f9a:	3c 4d       	sbci	r19, 0xDC	; 220
    2f9c:	f9 01       	movw	r30, r18
    2f9e:	20 81       	ld	r18, Z
    2fa0:	fc 01       	movw	r30, r24
    2fa2:	20 83       	st	Z, r18
    2fa4:	24 c0       	rjmp	.+72     	; 0x2fee <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa8:	9c 81       	ldd	r25, Y+4	; 0x04
    2faa:	23 e0       	ldi	r18, 0x03	; 3
    2fac:	30 e0       	ldi	r19, 0x00	; 0
    2fae:	b9 01       	movw	r22, r18
    2fb0:	0e 94 99 5d 	call	0xbb32	; 0xbb32 <__udivmodhi4>
    2fb4:	81 30       	cpi	r24, 0x01	; 1
    2fb6:	91 05       	cpc	r25, r1
    2fb8:	71 f4       	brne	.+28     	; 0x2fd6 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2fba:	80 91 54 50 	lds	r24, 0x5054
    2fbe:	90 91 55 50 	lds	r25, 0x5055
    2fc2:	01 96       	adiw	r24, 0x01	; 1
    2fc4:	2b 81       	ldd	r18, Y+3	; 0x03
    2fc6:	3c 81       	ldd	r19, Y+4	; 0x04
    2fc8:	20 53       	subi	r18, 0x30	; 48
    2fca:	3c 4d       	sbci	r19, 0xDC	; 220
    2fcc:	f9 01       	movw	r30, r18
    2fce:	20 81       	ld	r18, Z
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	20 83       	st	Z, r18
    2fd4:	0c c0       	rjmp	.+24     	; 0x2fee <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2fd6:	80 91 54 50 	lds	r24, 0x5054
    2fda:	90 91 55 50 	lds	r25, 0x5055
    2fde:	2b 81       	ldd	r18, Y+3	; 0x03
    2fe0:	3c 81       	ldd	r19, Y+4	; 0x04
    2fe2:	20 53       	subi	r18, 0x30	; 48
    2fe4:	3c 4d       	sbci	r19, 0xDC	; 220
    2fe6:	f9 01       	movw	r30, r18
    2fe8:	20 81       	ld	r18, Z
    2fea:	fc 01       	movw	r30, r24
    2fec:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2fee:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff2:	29 e0       	ldi	r18, 0x09	; 9
    2ff4:	30 e0       	ldi	r19, 0x00	; 0
    2ff6:	b9 01       	movw	r22, r18
    2ff8:	0e 94 99 5d 	call	0xbb32	; 0xbb32 <__udivmodhi4>
    2ffc:	82 30       	cpi	r24, 0x02	; 2
    2ffe:	91 05       	cpc	r25, r1
    3000:	09 f0       	breq	.+2      	; 0x3004 <calcChecksumFRAM+0x212>
    3002:	94 c0       	rjmp	.+296    	; 0x312c <calcChecksumFRAM+0x33a>
    3004:	a0 90 7c 50 	lds	r10, 0x507C
    3008:	b0 90 7d 50 	lds	r11, 0x507D
    300c:	c0 90 7e 50 	lds	r12, 0x507E
    3010:	d0 90 7f 50 	lds	r13, 0x507F
    3014:	e0 90 80 50 	lds	r14, 0x5080
    3018:	f0 90 81 50 	lds	r15, 0x5081
    301c:	00 91 82 50 	lds	r16, 0x5082
    3020:	10 91 83 50 	lds	r17, 0x5083
    3024:	80 91 54 50 	lds	r24, 0x5054
    3028:	90 91 55 50 	lds	r25, 0x5055
    302c:	fc 01       	movw	r30, r24
    302e:	20 80       	ld	r2, Z
    3030:	fc 01       	movw	r30, r24
    3032:	31 80       	ldd	r3, Z+1	; 0x01
    3034:	fc 01       	movw	r30, r24
    3036:	42 80       	ldd	r4, Z+2	; 0x02
    3038:	fc 01       	movw	r30, r24
    303a:	53 80       	ldd	r5, Z+3	; 0x03
    303c:	fc 01       	movw	r30, r24
    303e:	64 80       	ldd	r6, Z+4	; 0x04
    3040:	fc 01       	movw	r30, r24
    3042:	75 80       	ldd	r7, Z+5	; 0x05
    3044:	fc 01       	movw	r30, r24
    3046:	86 80       	ldd	r8, Z+6	; 0x06
    3048:	fc 01       	movw	r30, r24
    304a:	97 80       	ldd	r9, Z+7	; 0x07
    304c:	2a 2d       	mov	r18, r10
    304e:	22 0d       	add	r18, r2
    3050:	e1 e0       	ldi	r30, 0x01	; 1
    3052:	2a 15       	cp	r18, r10
    3054:	08 f0       	brcs	.+2      	; 0x3058 <calcChecksumFRAM+0x266>
    3056:	e0 e0       	ldi	r30, 0x00	; 0
    3058:	3b 2d       	mov	r19, r11
    305a:	33 0d       	add	r19, r3
    305c:	f1 e0       	ldi	r31, 0x01	; 1
    305e:	3b 15       	cp	r19, r11
    3060:	08 f0       	brcs	.+2      	; 0x3064 <calcChecksumFRAM+0x272>
    3062:	f0 e0       	ldi	r31, 0x00	; 0
    3064:	e3 0f       	add	r30, r19
    3066:	a1 e0       	ldi	r26, 0x01	; 1
    3068:	e3 17       	cp	r30, r19
    306a:	08 f0       	brcs	.+2      	; 0x306e <calcChecksumFRAM+0x27c>
    306c:	a0 e0       	ldi	r26, 0x00	; 0
    306e:	fa 2b       	or	r31, r26
    3070:	3e 2f       	mov	r19, r30
    3072:	4c 2d       	mov	r20, r12
    3074:	44 0d       	add	r20, r4
    3076:	e1 e0       	ldi	r30, 0x01	; 1
    3078:	4c 15       	cp	r20, r12
    307a:	08 f0       	brcs	.+2      	; 0x307e <calcChecksumFRAM+0x28c>
    307c:	e0 e0       	ldi	r30, 0x00	; 0
    307e:	f4 0f       	add	r31, r20
    3080:	a1 e0       	ldi	r26, 0x01	; 1
    3082:	f4 17       	cp	r31, r20
    3084:	08 f0       	brcs	.+2      	; 0x3088 <calcChecksumFRAM+0x296>
    3086:	a0 e0       	ldi	r26, 0x00	; 0
    3088:	ea 2b       	or	r30, r26
    308a:	4f 2f       	mov	r20, r31
    308c:	5d 2d       	mov	r21, r13
    308e:	55 0d       	add	r21, r5
    3090:	f1 e0       	ldi	r31, 0x01	; 1
    3092:	5d 15       	cp	r21, r13
    3094:	08 f0       	brcs	.+2      	; 0x3098 <calcChecksumFRAM+0x2a6>
    3096:	f0 e0       	ldi	r31, 0x00	; 0
    3098:	e5 0f       	add	r30, r21
    309a:	a1 e0       	ldi	r26, 0x01	; 1
    309c:	e5 17       	cp	r30, r21
    309e:	08 f0       	brcs	.+2      	; 0x30a2 <calcChecksumFRAM+0x2b0>
    30a0:	a0 e0       	ldi	r26, 0x00	; 0
    30a2:	fa 2b       	or	r31, r26
    30a4:	5e 2f       	mov	r21, r30
    30a6:	6e 2d       	mov	r22, r14
    30a8:	66 0d       	add	r22, r6
    30aa:	e1 e0       	ldi	r30, 0x01	; 1
    30ac:	6e 15       	cp	r22, r14
    30ae:	08 f0       	brcs	.+2      	; 0x30b2 <calcChecksumFRAM+0x2c0>
    30b0:	e0 e0       	ldi	r30, 0x00	; 0
    30b2:	f6 0f       	add	r31, r22
    30b4:	a1 e0       	ldi	r26, 0x01	; 1
    30b6:	f6 17       	cp	r31, r22
    30b8:	08 f0       	brcs	.+2      	; 0x30bc <calcChecksumFRAM+0x2ca>
    30ba:	a0 e0       	ldi	r26, 0x00	; 0
    30bc:	ea 2b       	or	r30, r26
    30be:	6f 2f       	mov	r22, r31
    30c0:	7f 2d       	mov	r23, r15
    30c2:	77 0d       	add	r23, r7
    30c4:	f1 e0       	ldi	r31, 0x01	; 1
    30c6:	7f 15       	cp	r23, r15
    30c8:	08 f0       	brcs	.+2      	; 0x30cc <calcChecksumFRAM+0x2da>
    30ca:	f0 e0       	ldi	r31, 0x00	; 0
    30cc:	e7 0f       	add	r30, r23
    30ce:	a1 e0       	ldi	r26, 0x01	; 1
    30d0:	e7 17       	cp	r30, r23
    30d2:	08 f0       	brcs	.+2      	; 0x30d6 <calcChecksumFRAM+0x2e4>
    30d4:	a0 e0       	ldi	r26, 0x00	; 0
    30d6:	fa 2b       	or	r31, r26
    30d8:	7e 2f       	mov	r23, r30
    30da:	80 2f       	mov	r24, r16
    30dc:	88 0d       	add	r24, r8
    30de:	e1 e0       	ldi	r30, 0x01	; 1
    30e0:	80 17       	cp	r24, r16
    30e2:	08 f0       	brcs	.+2      	; 0x30e6 <calcChecksumFRAM+0x2f4>
    30e4:	e0 e0       	ldi	r30, 0x00	; 0
    30e6:	f8 0f       	add	r31, r24
    30e8:	a1 e0       	ldi	r26, 0x01	; 1
    30ea:	f8 17       	cp	r31, r24
    30ec:	08 f0       	brcs	.+2      	; 0x30f0 <calcChecksumFRAM+0x2fe>
    30ee:	a0 e0       	ldi	r26, 0x00	; 0
    30f0:	ea 2b       	or	r30, r26
    30f2:	8f 2f       	mov	r24, r31
    30f4:	91 2f       	mov	r25, r17
    30f6:	99 0d       	add	r25, r9
    30f8:	e9 0f       	add	r30, r25
    30fa:	9e 2f       	mov	r25, r30
    30fc:	a2 2e       	mov	r10, r18
    30fe:	b3 2e       	mov	r11, r19
    3100:	c4 2e       	mov	r12, r20
    3102:	d5 2e       	mov	r13, r21
    3104:	e6 2e       	mov	r14, r22
    3106:	f7 2e       	mov	r15, r23
    3108:	08 2f       	mov	r16, r24
    310a:	19 2f       	mov	r17, r25
    310c:	a0 92 7c 50 	sts	0x507C, r10
    3110:	b0 92 7d 50 	sts	0x507D, r11
    3114:	c0 92 7e 50 	sts	0x507E, r12
    3118:	d0 92 7f 50 	sts	0x507F, r13
    311c:	e0 92 80 50 	sts	0x5080, r14
    3120:	f0 92 81 50 	sts	0x5081, r15
    3124:	00 93 82 50 	sts	0x5082, r16
    3128:	10 93 83 50 	sts	0x5083, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    312c:	8b 81       	ldd	r24, Y+3	; 0x03
    312e:	9c 81       	ldd	r25, Y+4	; 0x04
    3130:	29 e0       	ldi	r18, 0x09	; 9
    3132:	30 e0       	ldi	r19, 0x00	; 0
    3134:	b9 01       	movw	r22, r18
    3136:	0e 94 99 5d 	call	0xbb32	; 0xbb32 <__udivmodhi4>
    313a:	85 30       	cpi	r24, 0x05	; 5
    313c:	91 05       	cpc	r25, r1
    313e:	09 f0       	breq	.+2      	; 0x3142 <calcChecksumFRAM+0x350>
    3140:	94 c0       	rjmp	.+296    	; 0x326a <calcChecksumFRAM+0x478>
    3142:	a0 90 84 50 	lds	r10, 0x5084
    3146:	b0 90 85 50 	lds	r11, 0x5085
    314a:	c0 90 86 50 	lds	r12, 0x5086
    314e:	d0 90 87 50 	lds	r13, 0x5087
    3152:	e0 90 88 50 	lds	r14, 0x5088
    3156:	f0 90 89 50 	lds	r15, 0x5089
    315a:	00 91 8a 50 	lds	r16, 0x508A
    315e:	10 91 8b 50 	lds	r17, 0x508B
    3162:	80 91 54 50 	lds	r24, 0x5054
    3166:	90 91 55 50 	lds	r25, 0x5055
    316a:	fc 01       	movw	r30, r24
    316c:	20 80       	ld	r2, Z
    316e:	fc 01       	movw	r30, r24
    3170:	31 80       	ldd	r3, Z+1	; 0x01
    3172:	fc 01       	movw	r30, r24
    3174:	42 80       	ldd	r4, Z+2	; 0x02
    3176:	fc 01       	movw	r30, r24
    3178:	53 80       	ldd	r5, Z+3	; 0x03
    317a:	fc 01       	movw	r30, r24
    317c:	64 80       	ldd	r6, Z+4	; 0x04
    317e:	fc 01       	movw	r30, r24
    3180:	75 80       	ldd	r7, Z+5	; 0x05
    3182:	fc 01       	movw	r30, r24
    3184:	86 80       	ldd	r8, Z+6	; 0x06
    3186:	fc 01       	movw	r30, r24
    3188:	97 80       	ldd	r9, Z+7	; 0x07
    318a:	2a 2d       	mov	r18, r10
    318c:	22 0d       	add	r18, r2
    318e:	e1 e0       	ldi	r30, 0x01	; 1
    3190:	2a 15       	cp	r18, r10
    3192:	08 f0       	brcs	.+2      	; 0x3196 <calcChecksumFRAM+0x3a4>
    3194:	e0 e0       	ldi	r30, 0x00	; 0
    3196:	3b 2d       	mov	r19, r11
    3198:	33 0d       	add	r19, r3
    319a:	f1 e0       	ldi	r31, 0x01	; 1
    319c:	3b 15       	cp	r19, r11
    319e:	08 f0       	brcs	.+2      	; 0x31a2 <calcChecksumFRAM+0x3b0>
    31a0:	f0 e0       	ldi	r31, 0x00	; 0
    31a2:	e3 0f       	add	r30, r19
    31a4:	a1 e0       	ldi	r26, 0x01	; 1
    31a6:	e3 17       	cp	r30, r19
    31a8:	08 f0       	brcs	.+2      	; 0x31ac <calcChecksumFRAM+0x3ba>
    31aa:	a0 e0       	ldi	r26, 0x00	; 0
    31ac:	fa 2b       	or	r31, r26
    31ae:	3e 2f       	mov	r19, r30
    31b0:	4c 2d       	mov	r20, r12
    31b2:	44 0d       	add	r20, r4
    31b4:	e1 e0       	ldi	r30, 0x01	; 1
    31b6:	4c 15       	cp	r20, r12
    31b8:	08 f0       	brcs	.+2      	; 0x31bc <calcChecksumFRAM+0x3ca>
    31ba:	e0 e0       	ldi	r30, 0x00	; 0
    31bc:	f4 0f       	add	r31, r20
    31be:	a1 e0       	ldi	r26, 0x01	; 1
    31c0:	f4 17       	cp	r31, r20
    31c2:	08 f0       	brcs	.+2      	; 0x31c6 <calcChecksumFRAM+0x3d4>
    31c4:	a0 e0       	ldi	r26, 0x00	; 0
    31c6:	ea 2b       	or	r30, r26
    31c8:	4f 2f       	mov	r20, r31
    31ca:	5d 2d       	mov	r21, r13
    31cc:	55 0d       	add	r21, r5
    31ce:	f1 e0       	ldi	r31, 0x01	; 1
    31d0:	5d 15       	cp	r21, r13
    31d2:	08 f0       	brcs	.+2      	; 0x31d6 <calcChecksumFRAM+0x3e4>
    31d4:	f0 e0       	ldi	r31, 0x00	; 0
    31d6:	e5 0f       	add	r30, r21
    31d8:	a1 e0       	ldi	r26, 0x01	; 1
    31da:	e5 17       	cp	r30, r21
    31dc:	08 f0       	brcs	.+2      	; 0x31e0 <calcChecksumFRAM+0x3ee>
    31de:	a0 e0       	ldi	r26, 0x00	; 0
    31e0:	fa 2b       	or	r31, r26
    31e2:	5e 2f       	mov	r21, r30
    31e4:	6e 2d       	mov	r22, r14
    31e6:	66 0d       	add	r22, r6
    31e8:	e1 e0       	ldi	r30, 0x01	; 1
    31ea:	6e 15       	cp	r22, r14
    31ec:	08 f0       	brcs	.+2      	; 0x31f0 <calcChecksumFRAM+0x3fe>
    31ee:	e0 e0       	ldi	r30, 0x00	; 0
    31f0:	f6 0f       	add	r31, r22
    31f2:	a1 e0       	ldi	r26, 0x01	; 1
    31f4:	f6 17       	cp	r31, r22
    31f6:	08 f0       	brcs	.+2      	; 0x31fa <calcChecksumFRAM+0x408>
    31f8:	a0 e0       	ldi	r26, 0x00	; 0
    31fa:	ea 2b       	or	r30, r26
    31fc:	6f 2f       	mov	r22, r31
    31fe:	7f 2d       	mov	r23, r15
    3200:	77 0d       	add	r23, r7
    3202:	f1 e0       	ldi	r31, 0x01	; 1
    3204:	7f 15       	cp	r23, r15
    3206:	08 f0       	brcs	.+2      	; 0x320a <calcChecksumFRAM+0x418>
    3208:	f0 e0       	ldi	r31, 0x00	; 0
    320a:	e7 0f       	add	r30, r23
    320c:	a1 e0       	ldi	r26, 0x01	; 1
    320e:	e7 17       	cp	r30, r23
    3210:	08 f0       	brcs	.+2      	; 0x3214 <calcChecksumFRAM+0x422>
    3212:	a0 e0       	ldi	r26, 0x00	; 0
    3214:	fa 2b       	or	r31, r26
    3216:	7e 2f       	mov	r23, r30
    3218:	80 2f       	mov	r24, r16
    321a:	88 0d       	add	r24, r8
    321c:	e1 e0       	ldi	r30, 0x01	; 1
    321e:	80 17       	cp	r24, r16
    3220:	08 f0       	brcs	.+2      	; 0x3224 <calcChecksumFRAM+0x432>
    3222:	e0 e0       	ldi	r30, 0x00	; 0
    3224:	f8 0f       	add	r31, r24
    3226:	a1 e0       	ldi	r26, 0x01	; 1
    3228:	f8 17       	cp	r31, r24
    322a:	08 f0       	brcs	.+2      	; 0x322e <calcChecksumFRAM+0x43c>
    322c:	a0 e0       	ldi	r26, 0x00	; 0
    322e:	ea 2b       	or	r30, r26
    3230:	8f 2f       	mov	r24, r31
    3232:	91 2f       	mov	r25, r17
    3234:	99 0d       	add	r25, r9
    3236:	e9 0f       	add	r30, r25
    3238:	9e 2f       	mov	r25, r30
    323a:	a2 2e       	mov	r10, r18
    323c:	b3 2e       	mov	r11, r19
    323e:	c4 2e       	mov	r12, r20
    3240:	d5 2e       	mov	r13, r21
    3242:	e6 2e       	mov	r14, r22
    3244:	f7 2e       	mov	r15, r23
    3246:	08 2f       	mov	r16, r24
    3248:	19 2f       	mov	r17, r25
    324a:	a0 92 84 50 	sts	0x5084, r10
    324e:	b0 92 85 50 	sts	0x5085, r11
    3252:	c0 92 86 50 	sts	0x5086, r12
    3256:	d0 92 87 50 	sts	0x5087, r13
    325a:	e0 92 88 50 	sts	0x5088, r14
    325e:	f0 92 89 50 	sts	0x5089, r15
    3262:	00 93 8a 50 	sts	0x508A, r16
    3266:	10 93 8b 50 	sts	0x508B, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    326a:	8b 81       	ldd	r24, Y+3	; 0x03
    326c:	9c 81       	ldd	r25, Y+4	; 0x04
    326e:	29 e0       	ldi	r18, 0x09	; 9
    3270:	30 e0       	ldi	r19, 0x00	; 0
    3272:	b9 01       	movw	r22, r18
    3274:	0e 94 99 5d 	call	0xbb32	; 0xbb32 <__udivmodhi4>
    3278:	88 30       	cpi	r24, 0x08	; 8
    327a:	91 05       	cpc	r25, r1
    327c:	09 f0       	breq	.+2      	; 0x3280 <calcChecksumFRAM+0x48e>
    327e:	94 c0       	rjmp	.+296    	; 0x33a8 <calcChecksumFRAM+0x5b6>
    3280:	a0 90 8c 50 	lds	r10, 0x508C
    3284:	b0 90 8d 50 	lds	r11, 0x508D
    3288:	c0 90 8e 50 	lds	r12, 0x508E
    328c:	d0 90 8f 50 	lds	r13, 0x508F
    3290:	e0 90 90 50 	lds	r14, 0x5090
    3294:	f0 90 91 50 	lds	r15, 0x5091
    3298:	00 91 92 50 	lds	r16, 0x5092
    329c:	10 91 93 50 	lds	r17, 0x5093
    32a0:	80 91 54 50 	lds	r24, 0x5054
    32a4:	90 91 55 50 	lds	r25, 0x5055
    32a8:	fc 01       	movw	r30, r24
    32aa:	20 80       	ld	r2, Z
    32ac:	fc 01       	movw	r30, r24
    32ae:	31 80       	ldd	r3, Z+1	; 0x01
    32b0:	fc 01       	movw	r30, r24
    32b2:	42 80       	ldd	r4, Z+2	; 0x02
    32b4:	fc 01       	movw	r30, r24
    32b6:	53 80       	ldd	r5, Z+3	; 0x03
    32b8:	fc 01       	movw	r30, r24
    32ba:	64 80       	ldd	r6, Z+4	; 0x04
    32bc:	fc 01       	movw	r30, r24
    32be:	75 80       	ldd	r7, Z+5	; 0x05
    32c0:	fc 01       	movw	r30, r24
    32c2:	86 80       	ldd	r8, Z+6	; 0x06
    32c4:	fc 01       	movw	r30, r24
    32c6:	97 80       	ldd	r9, Z+7	; 0x07
    32c8:	2a 2d       	mov	r18, r10
    32ca:	22 0d       	add	r18, r2
    32cc:	e1 e0       	ldi	r30, 0x01	; 1
    32ce:	2a 15       	cp	r18, r10
    32d0:	08 f0       	brcs	.+2      	; 0x32d4 <calcChecksumFRAM+0x4e2>
    32d2:	e0 e0       	ldi	r30, 0x00	; 0
    32d4:	3b 2d       	mov	r19, r11
    32d6:	33 0d       	add	r19, r3
    32d8:	f1 e0       	ldi	r31, 0x01	; 1
    32da:	3b 15       	cp	r19, r11
    32dc:	08 f0       	brcs	.+2      	; 0x32e0 <calcChecksumFRAM+0x4ee>
    32de:	f0 e0       	ldi	r31, 0x00	; 0
    32e0:	e3 0f       	add	r30, r19
    32e2:	a1 e0       	ldi	r26, 0x01	; 1
    32e4:	e3 17       	cp	r30, r19
    32e6:	08 f0       	brcs	.+2      	; 0x32ea <calcChecksumFRAM+0x4f8>
    32e8:	a0 e0       	ldi	r26, 0x00	; 0
    32ea:	fa 2b       	or	r31, r26
    32ec:	3e 2f       	mov	r19, r30
    32ee:	4c 2d       	mov	r20, r12
    32f0:	44 0d       	add	r20, r4
    32f2:	e1 e0       	ldi	r30, 0x01	; 1
    32f4:	4c 15       	cp	r20, r12
    32f6:	08 f0       	brcs	.+2      	; 0x32fa <calcChecksumFRAM+0x508>
    32f8:	e0 e0       	ldi	r30, 0x00	; 0
    32fa:	f4 0f       	add	r31, r20
    32fc:	a1 e0       	ldi	r26, 0x01	; 1
    32fe:	f4 17       	cp	r31, r20
    3300:	08 f0       	brcs	.+2      	; 0x3304 <calcChecksumFRAM+0x512>
    3302:	a0 e0       	ldi	r26, 0x00	; 0
    3304:	ea 2b       	or	r30, r26
    3306:	4f 2f       	mov	r20, r31
    3308:	5d 2d       	mov	r21, r13
    330a:	55 0d       	add	r21, r5
    330c:	f1 e0       	ldi	r31, 0x01	; 1
    330e:	5d 15       	cp	r21, r13
    3310:	08 f0       	brcs	.+2      	; 0x3314 <calcChecksumFRAM+0x522>
    3312:	f0 e0       	ldi	r31, 0x00	; 0
    3314:	e5 0f       	add	r30, r21
    3316:	a1 e0       	ldi	r26, 0x01	; 1
    3318:	e5 17       	cp	r30, r21
    331a:	08 f0       	brcs	.+2      	; 0x331e <calcChecksumFRAM+0x52c>
    331c:	a0 e0       	ldi	r26, 0x00	; 0
    331e:	fa 2b       	or	r31, r26
    3320:	5e 2f       	mov	r21, r30
    3322:	6e 2d       	mov	r22, r14
    3324:	66 0d       	add	r22, r6
    3326:	e1 e0       	ldi	r30, 0x01	; 1
    3328:	6e 15       	cp	r22, r14
    332a:	08 f0       	brcs	.+2      	; 0x332e <calcChecksumFRAM+0x53c>
    332c:	e0 e0       	ldi	r30, 0x00	; 0
    332e:	f6 0f       	add	r31, r22
    3330:	a1 e0       	ldi	r26, 0x01	; 1
    3332:	f6 17       	cp	r31, r22
    3334:	08 f0       	brcs	.+2      	; 0x3338 <calcChecksumFRAM+0x546>
    3336:	a0 e0       	ldi	r26, 0x00	; 0
    3338:	ea 2b       	or	r30, r26
    333a:	6f 2f       	mov	r22, r31
    333c:	7f 2d       	mov	r23, r15
    333e:	77 0d       	add	r23, r7
    3340:	f1 e0       	ldi	r31, 0x01	; 1
    3342:	7f 15       	cp	r23, r15
    3344:	08 f0       	brcs	.+2      	; 0x3348 <calcChecksumFRAM+0x556>
    3346:	f0 e0       	ldi	r31, 0x00	; 0
    3348:	e7 0f       	add	r30, r23
    334a:	a1 e0       	ldi	r26, 0x01	; 1
    334c:	e7 17       	cp	r30, r23
    334e:	08 f0       	brcs	.+2      	; 0x3352 <calcChecksumFRAM+0x560>
    3350:	a0 e0       	ldi	r26, 0x00	; 0
    3352:	fa 2b       	or	r31, r26
    3354:	7e 2f       	mov	r23, r30
    3356:	80 2f       	mov	r24, r16
    3358:	88 0d       	add	r24, r8
    335a:	e1 e0       	ldi	r30, 0x01	; 1
    335c:	80 17       	cp	r24, r16
    335e:	08 f0       	brcs	.+2      	; 0x3362 <calcChecksumFRAM+0x570>
    3360:	e0 e0       	ldi	r30, 0x00	; 0
    3362:	f8 0f       	add	r31, r24
    3364:	a1 e0       	ldi	r26, 0x01	; 1
    3366:	f8 17       	cp	r31, r24
    3368:	08 f0       	brcs	.+2      	; 0x336c <calcChecksumFRAM+0x57a>
    336a:	a0 e0       	ldi	r26, 0x00	; 0
    336c:	ea 2b       	or	r30, r26
    336e:	8f 2f       	mov	r24, r31
    3370:	91 2f       	mov	r25, r17
    3372:	99 0d       	add	r25, r9
    3374:	e9 0f       	add	r30, r25
    3376:	9e 2f       	mov	r25, r30
    3378:	a2 2e       	mov	r10, r18
    337a:	b3 2e       	mov	r11, r19
    337c:	c4 2e       	mov	r12, r20
    337e:	d5 2e       	mov	r13, r21
    3380:	e6 2e       	mov	r14, r22
    3382:	f7 2e       	mov	r15, r23
    3384:	08 2f       	mov	r16, r24
    3386:	19 2f       	mov	r17, r25
    3388:	a0 92 8c 50 	sts	0x508C, r10
    338c:	b0 92 8d 50 	sts	0x508D, r11
    3390:	c0 92 8e 50 	sts	0x508E, r12
    3394:	d0 92 8f 50 	sts	0x508F, r13
    3398:	e0 92 90 50 	sts	0x5090, r14
    339c:	f0 92 91 50 	sts	0x5091, r15
    33a0:	00 93 92 50 	sts	0x5092, r16
    33a4:	10 93 93 50 	sts	0x5093, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    33a8:	8b 81       	ldd	r24, Y+3	; 0x03
    33aa:	9c 81       	ldd	r25, Y+4	; 0x04
    33ac:	01 96       	adiw	r24, 0x01	; 1
    33ae:	8b 83       	std	Y+3, r24	; 0x03
    33b0:	9c 83       	std	Y+4, r25	; 0x04
    33b2:	8b 81       	ldd	r24, Y+3	; 0x03
    33b4:	9c 81       	ldd	r25, Y+4	; 0x04
    33b6:	fc e1       	ldi	r31, 0x1C	; 28
    33b8:	81 37       	cpi	r24, 0x71	; 113
    33ba:	9f 07       	cpc	r25, r31
    33bc:	08 f4       	brcc	.+2      	; 0x33c0 <calcChecksumFRAM+0x5ce>
    33be:	8e cd       	rjmp	.-1252   	; 0x2edc <calcChecksumFRAM+0xea>
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    33c0:	89 81       	ldd	r24, Y+1	; 0x01
    33c2:	9a 81       	ldd	r25, Y+2	; 0x02
    33c4:	01 96       	adiw	r24, 0x01	; 1
    33c6:	89 83       	std	Y+1, r24	; 0x01
    33c8:	9a 83       	std	Y+2, r25	; 0x02
    33ca:	89 81       	ldd	r24, Y+1	; 0x01
    33cc:	9a 81       	ldd	r25, Y+2	; 0x02
    33ce:	89 30       	cpi	r24, 0x09	; 9
    33d0:	91 05       	cpc	r25, r1
    33d2:	08 f4       	brcc	.+2      	; 0x33d6 <calcChecksumFRAM+0x5e4>
    33d4:	72 cd       	rjmp	.-1308   	; 0x2eba <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    33d6:	24 96       	adiw	r28, 0x04	; 4
    33d8:	cd bf       	out	0x3d, r28	; 61
    33da:	de bf       	out	0x3e, r29	; 62
    33dc:	df 91       	pop	r29
    33de:	cf 91       	pop	r28
    33e0:	1f 91       	pop	r17
    33e2:	0f 91       	pop	r16
    33e4:	ff 90       	pop	r15
    33e6:	ef 90       	pop	r14
    33e8:	df 90       	pop	r13
    33ea:	cf 90       	pop	r12
    33ec:	bf 90       	pop	r11
    33ee:	af 90       	pop	r10
    33f0:	9f 90       	pop	r9
    33f2:	8f 90       	pop	r8
    33f4:	7f 90       	pop	r7
    33f6:	6f 90       	pop	r6
    33f8:	5f 90       	pop	r5
    33fa:	4f 90       	pop	r4
    33fc:	3f 90       	pop	r3
    33fe:	2f 90       	pop	r2
    3400:	08 95       	ret

00003402 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    3402:	cf 93       	push	r28
    3404:	df 93       	push	r29
    3406:	cd b7       	in	r28, 0x3d	; 61
    3408:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    340a:	10 92 48 40 	sts	0x4048, r1
    340e:	10 92 49 40 	sts	0x4049, r1
	sampleCount = 0;
    3412:	10 92 65 50 	sts	0x5065, r1
    3416:	10 92 66 50 	sts	0x5066, r1
    341a:	10 92 67 50 	sts	0x5067, r1
    341e:	10 92 68 50 	sts	0x5068, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3422:	80 e0       	ldi	r24, 0x00	; 0
    3424:	80 93 2c 21 	sts	0x212C, r24
    3428:	80 93 2b 21 	sts	0x212B, r24
    342c:	80 93 2a 21 	sts	0x212A, r24
	
	ADCPower(TRUE);
    3430:	81 e0       	ldi	r24, 0x01	; 1
    3432:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    3436:	84 e0       	ldi	r24, 0x04	; 4
    3438:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    343c:	80 ec       	ldi	r24, 0xC0	; 192
    343e:	98 e0       	ldi	r25, 0x08	; 8
    3440:	20 ed       	ldi	r18, 0xD0	; 208
    3442:	fc 01       	movw	r30, r24
    3444:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    3446:	8d e0       	ldi	r24, 0x0D	; 13
    3448:	80 93 56 50 	sts	0x5056, r24
	SPIBuffer[1] = 0xF3;
    344c:	83 ef       	ldi	r24, 0xF3	; 243
    344e:	80 93 57 50 	sts	0x5057, r24
	SPIBuffer[2] = 0x57;
    3452:	87 e5       	ldi	r24, 0x57	; 87
    3454:	80 93 58 50 	sts	0x5058, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3458:	d7 c0       	rjmp	.+430    	; 0x3608 <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    345a:	80 e4       	ldi	r24, 0x40	; 64
    345c:	96 e0       	ldi	r25, 0x06	; 6
    345e:	20 e1       	ldi	r18, 0x10	; 16
    3460:	fc 01       	movw	r30, r24
    3462:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3464:	80 e2       	ldi	r24, 0x20	; 32
    3466:	96 e0       	ldi	r25, 0x06	; 6
    3468:	28 e0       	ldi	r18, 0x08	; 8
    346a:	fc 01       	movw	r30, r24
    346c:	26 83       	std	Z+6, r18	; 0x06
		nop();
    346e:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3470:	80 ec       	ldi	r24, 0xC0	; 192
    3472:	98 e0       	ldi	r25, 0x08	; 8
    3474:	26 e0       	ldi	r18, 0x06	; 6
    3476:	fc 01       	movw	r30, r24
    3478:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    347a:	00 00       	nop
    347c:	80 ec       	ldi	r24, 0xC0	; 192
    347e:	98 e0       	ldi	r25, 0x08	; 8
    3480:	fc 01       	movw	r30, r24
    3482:	82 81       	ldd	r24, Z+2	; 0x02
    3484:	88 23       	and	r24, r24
    3486:	d4 f7       	brge	.-12     	; 0x347c <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3488:	80 ec       	ldi	r24, 0xC0	; 192
    348a:	98 e0       	ldi	r25, 0x08	; 8
    348c:	fc 01       	movw	r30, r24
    348e:	83 81       	ldd	r24, Z+3	; 0x03
    3490:	80 93 62 50 	sts	0x5062, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3494:	80 e2       	ldi	r24, 0x20	; 32
    3496:	96 e0       	ldi	r25, 0x06	; 6
    3498:	28 e0       	ldi	r18, 0x08	; 8
    349a:	fc 01       	movw	r30, r24
    349c:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    349e:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    34a0:	80 e2       	ldi	r24, 0x20	; 32
    34a2:	96 e0       	ldi	r25, 0x06	; 6
    34a4:	28 e0       	ldi	r18, 0x08	; 8
    34a6:	fc 01       	movw	r30, r24
    34a8:	26 83       	std	Z+6, r18	; 0x06
		nop();
    34aa:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    34ac:	80 ec       	ldi	r24, 0xC0	; 192
    34ae:	98 e0       	ldi	r25, 0x08	; 8
    34b0:	22 e0       	ldi	r18, 0x02	; 2
    34b2:	fc 01       	movw	r30, r24
    34b4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    34b6:	00 00       	nop
    34b8:	80 ec       	ldi	r24, 0xC0	; 192
    34ba:	98 e0       	ldi	r25, 0x08	; 8
    34bc:	fc 01       	movw	r30, r24
    34be:	82 81       	ldd	r24, Z+2	; 0x02
    34c0:	88 23       	and	r24, r24
    34c2:	d4 f7       	brge	.-12     	; 0x34b8 <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    34c4:	80 ec       	ldi	r24, 0xC0	; 192
    34c6:	98 e0       	ldi	r25, 0x08	; 8
    34c8:	fc 01       	movw	r30, r24
    34ca:	83 81       	ldd	r24, Z+3	; 0x03
    34cc:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    34d0:	80 ec       	ldi	r24, 0xC0	; 192
    34d2:	98 e0       	ldi	r25, 0x08	; 8
    34d4:	20 91 49 40 	lds	r18, 0x4049
    34d8:	fc 01       	movw	r30, r24
    34da:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    34dc:	00 00       	nop
    34de:	80 ec       	ldi	r24, 0xC0	; 192
    34e0:	98 e0       	ldi	r25, 0x08	; 8
    34e2:	fc 01       	movw	r30, r24
    34e4:	82 81       	ldd	r24, Z+2	; 0x02
    34e6:	88 23       	and	r24, r24
    34e8:	d4 f7       	brge	.-12     	; 0x34de <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    34ea:	80 ec       	ldi	r24, 0xC0	; 192
    34ec:	98 e0       	ldi	r25, 0x08	; 8
    34ee:	fc 01       	movw	r30, r24
    34f0:	83 81       	ldd	r24, Z+3	; 0x03
    34f2:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    34f6:	80 ec       	ldi	r24, 0xC0	; 192
    34f8:	98 e0       	ldi	r25, 0x08	; 8
    34fa:	28 e4       	ldi	r18, 0x48	; 72
    34fc:	30 e4       	ldi	r19, 0x40	; 64
    34fe:	f9 01       	movw	r30, r18
    3500:	20 81       	ld	r18, Z
    3502:	fc 01       	movw	r30, r24
    3504:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3506:	00 00       	nop
    3508:	80 ec       	ldi	r24, 0xC0	; 192
    350a:	98 e0       	ldi	r25, 0x08	; 8
    350c:	fc 01       	movw	r30, r24
    350e:	82 81       	ldd	r24, Z+2	; 0x02
    3510:	88 23       	and	r24, r24
    3512:	d4 f7       	brge	.-12     	; 0x3508 <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3514:	80 ec       	ldi	r24, 0xC0	; 192
    3516:	98 e0       	ldi	r25, 0x08	; 8
    3518:	fc 01       	movw	r30, r24
    351a:	83 81       	ldd	r24, Z+3	; 0x03
    351c:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = SPIBuffer[0];
    3520:	80 ec       	ldi	r24, 0xC0	; 192
    3522:	98 e0       	ldi	r25, 0x08	; 8
    3524:	20 91 56 50 	lds	r18, 0x5056
    3528:	fc 01       	movw	r30, r24
    352a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    352c:	00 00       	nop
    352e:	80 ec       	ldi	r24, 0xC0	; 192
    3530:	98 e0       	ldi	r25, 0x08	; 8
    3532:	fc 01       	movw	r30, r24
    3534:	82 81       	ldd	r24, Z+2	; 0x02
    3536:	88 23       	and	r24, r24
    3538:	d4 f7       	brge	.-12     	; 0x352e <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    353a:	80 ec       	ldi	r24, 0xC0	; 192
    353c:	98 e0       	ldi	r25, 0x08	; 8
    353e:	fc 01       	movw	r30, r24
    3540:	83 81       	ldd	r24, Z+3	; 0x03
    3542:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = SPIBuffer[1];
    3546:	80 ec       	ldi	r24, 0xC0	; 192
    3548:	98 e0       	ldi	r25, 0x08	; 8
    354a:	20 91 57 50 	lds	r18, 0x5057
    354e:	fc 01       	movw	r30, r24
    3550:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3552:	00 00       	nop
    3554:	80 ec       	ldi	r24, 0xC0	; 192
    3556:	98 e0       	ldi	r25, 0x08	; 8
    3558:	fc 01       	movw	r30, r24
    355a:	82 81       	ldd	r24, Z+2	; 0x02
    355c:	88 23       	and	r24, r24
    355e:	d4 f7       	brge	.-12     	; 0x3554 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    3560:	80 ec       	ldi	r24, 0xC0	; 192
    3562:	98 e0       	ldi	r25, 0x08	; 8
    3564:	fc 01       	movw	r30, r24
    3566:	83 81       	ldd	r24, Z+3	; 0x03
    3568:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = SPIBuffer[2];
    356c:	80 ec       	ldi	r24, 0xC0	; 192
    356e:	98 e0       	ldi	r25, 0x08	; 8
    3570:	20 91 58 50 	lds	r18, 0x5058
    3574:	fc 01       	movw	r30, r24
    3576:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3578:	00 00       	nop
    357a:	80 ec       	ldi	r24, 0xC0	; 192
    357c:	98 e0       	ldi	r25, 0x08	; 8
    357e:	fc 01       	movw	r30, r24
    3580:	82 81       	ldd	r24, Z+2	; 0x02
    3582:	88 23       	and	r24, r24
    3584:	d4 f7       	brge	.-12     	; 0x357a <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    3586:	80 ec       	ldi	r24, 0xC0	; 192
    3588:	98 e0       	ldi	r25, 0x08	; 8
    358a:	fc 01       	movw	r30, r24
    358c:	83 81       	ldd	r24, Z+3	; 0x03
    358e:	80 93 62 50 	sts	0x5062, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3592:	80 e2       	ldi	r24, 0x20	; 32
    3594:	96 e0       	ldi	r25, 0x06	; 6
    3596:	28 e0       	ldi	r18, 0x08	; 8
    3598:	fc 01       	movw	r30, r24
    359a:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    359c:	80 e4       	ldi	r24, 0x40	; 64
    359e:	96 e0       	ldi	r25, 0x06	; 6
    35a0:	20 e1       	ldi	r18, 0x10	; 16
    35a2:	fc 01       	movw	r30, r24
    35a4:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    35a6:	80 91 48 40 	lds	r24, 0x4048
    35aa:	90 91 49 40 	lds	r25, 0x4049
    35ae:	03 96       	adiw	r24, 0x03	; 3
    35b0:	80 93 48 40 	sts	0x4048, r24
    35b4:	90 93 49 40 	sts	0x4049, r25
		checksumADC[0] += SPIBuffer[0];
    35b8:	90 91 2a 21 	lds	r25, 0x212A
    35bc:	80 91 56 50 	lds	r24, 0x5056
    35c0:	89 0f       	add	r24, r25
    35c2:	80 93 2a 21 	sts	0x212A, r24
		checksumADC[1] += SPIBuffer[1];
    35c6:	90 91 2b 21 	lds	r25, 0x212B
    35ca:	80 91 57 50 	lds	r24, 0x5057
    35ce:	89 0f       	add	r24, r25
    35d0:	80 93 2b 21 	sts	0x212B, r24
		checksumADC[2] += SPIBuffer[2];
    35d4:	90 91 2c 21 	lds	r25, 0x212C
    35d8:	80 91 58 50 	lds	r24, 0x5058
    35dc:	89 0f       	add	r24, r25
    35de:	80 93 2c 21 	sts	0x212C, r24
		
		sampleCount++;
    35e2:	80 91 65 50 	lds	r24, 0x5065
    35e6:	90 91 66 50 	lds	r25, 0x5066
    35ea:	a0 91 67 50 	lds	r26, 0x5067
    35ee:	b0 91 68 50 	lds	r27, 0x5068
    35f2:	01 96       	adiw	r24, 0x01	; 1
    35f4:	a1 1d       	adc	r26, r1
    35f6:	b1 1d       	adc	r27, r1
    35f8:	80 93 65 50 	sts	0x5065, r24
    35fc:	90 93 66 50 	sts	0x5066, r25
    3600:	a0 93 67 50 	sts	0x5067, r26
    3604:	b0 93 68 50 	sts	0x5068, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3608:	80 91 65 50 	lds	r24, 0x5065
    360c:	90 91 66 50 	lds	r25, 0x5066
    3610:	a0 91 67 50 	lds	r26, 0x5067
    3614:	b0 91 68 50 	lds	r27, 0x5068
    3618:	83 35       	cpi	r24, 0x53	; 83
    361a:	f5 e5       	ldi	r31, 0x55	; 85
    361c:	9f 07       	cpc	r25, r31
    361e:	f0 e0       	ldi	r31, 0x00	; 0
    3620:	af 07       	cpc	r26, r31
    3622:	f0 e0       	ldi	r31, 0x00	; 0
    3624:	bf 07       	cpc	r27, r31
    3626:	08 f4       	brcc	.+2      	; 0x362a <FRAMWriteKnowns+0x228>
    3628:	18 cf       	rjmp	.-464    	; 0x345a <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    362a:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	ADCPower(FALSE);
    362e:	80 e0       	ldi	r24, 0x00	; 0
    3630:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
}
    3634:	df 91       	pop	r29
    3636:	cf 91       	pop	r28
    3638:	08 95       	ret

0000363a <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    363a:	cf 93       	push	r28
    363c:	df 93       	push	r29
    363e:	0f 92       	push	r0
    3640:	cd b7       	in	r28, 0x3d	; 61
    3642:	de b7       	in	r29, 0x3e	; 62
    3644:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    3646:	89 81       	ldd	r24, Y+1	; 0x01
    3648:	88 2f       	mov	r24, r24
    364a:	90 e0       	ldi	r25, 0x00	; 0
    364c:	81 70       	andi	r24, 0x01	; 1
    364e:	90 70       	andi	r25, 0x00	; 0
    3650:	88 23       	and	r24, r24
    3652:	31 f0       	breq	.+12     	; 0x3660 <setADCInput+0x26>
    3654:	80 e0       	ldi	r24, 0x00	; 0
    3656:	96 e0       	ldi	r25, 0x06	; 6
    3658:	20 e4       	ldi	r18, 0x40	; 64
    365a:	fc 01       	movw	r30, r24
    365c:	25 83       	std	Z+5, r18	; 0x05
    365e:	05 c0       	rjmp	.+10     	; 0x366a <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    3660:	80 e0       	ldi	r24, 0x00	; 0
    3662:	96 e0       	ldi	r25, 0x06	; 6
    3664:	20 e4       	ldi	r18, 0x40	; 64
    3666:	fc 01       	movw	r30, r24
    3668:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    366a:	89 81       	ldd	r24, Y+1	; 0x01
    366c:	88 2f       	mov	r24, r24
    366e:	90 e0       	ldi	r25, 0x00	; 0
    3670:	82 70       	andi	r24, 0x02	; 2
    3672:	90 70       	andi	r25, 0x00	; 0
    3674:	00 97       	sbiw	r24, 0x00	; 0
    3676:	31 f0       	breq	.+12     	; 0x3684 <setADCInput+0x4a>
    3678:	80 e2       	ldi	r24, 0x20	; 32
    367a:	96 e0       	ldi	r25, 0x06	; 6
    367c:	22 e0       	ldi	r18, 0x02	; 2
    367e:	fc 01       	movw	r30, r24
    3680:	25 83       	std	Z+5, r18	; 0x05
    3682:	05 c0       	rjmp	.+10     	; 0x368e <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3684:	80 e2       	ldi	r24, 0x20	; 32
    3686:	96 e0       	ldi	r25, 0x06	; 6
    3688:	22 e0       	ldi	r18, 0x02	; 2
    368a:	fc 01       	movw	r30, r24
    368c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    368e:	89 81       	ldd	r24, Y+1	; 0x01
    3690:	88 2f       	mov	r24, r24
    3692:	90 e0       	ldi	r25, 0x00	; 0
    3694:	84 70       	andi	r24, 0x04	; 4
    3696:	90 70       	andi	r25, 0x00	; 0
    3698:	00 97       	sbiw	r24, 0x00	; 0
    369a:	31 f0       	breq	.+12     	; 0x36a8 <setADCInput+0x6e>
    369c:	80 e2       	ldi	r24, 0x20	; 32
    369e:	96 e0       	ldi	r25, 0x06	; 6
    36a0:	24 e0       	ldi	r18, 0x04	; 4
    36a2:	fc 01       	movw	r30, r24
    36a4:	25 83       	std	Z+5, r18	; 0x05
    36a6:	05 c0       	rjmp	.+10     	; 0x36b2 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    36a8:	80 e2       	ldi	r24, 0x20	; 32
    36aa:	96 e0       	ldi	r25, 0x06	; 6
    36ac:	24 e0       	ldi	r18, 0x04	; 4
    36ae:	fc 01       	movw	r30, r24
    36b0:	26 83       	std	Z+6, r18	; 0x06

}
    36b2:	0f 90       	pop	r0
    36b4:	df 91       	pop	r29
    36b6:	cf 91       	pop	r28
    36b8:	08 95       	ret

000036ba <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    36ba:	cf 93       	push	r28
    36bc:	df 93       	push	r29
    36be:	0f 92       	push	r0
    36c0:	0f 92       	push	r0
    36c2:	cd b7       	in	r28, 0x3d	; 61
    36c4:	de b7       	in	r29, 0x3e	; 62
    36c6:	89 83       	std	Y+1, r24	; 0x01
    36c8:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    36ca:	89 81       	ldd	r24, Y+1	; 0x01
    36cc:	9a 81       	ldd	r25, Y+2	; 0x02
    36ce:	22 e0       	ldi	r18, 0x02	; 2
    36d0:	80 30       	cpi	r24, 0x00	; 0
    36d2:	92 07       	cpc	r25, r18
    36d4:	89 f4       	brne	.+34     	; 0x36f8 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    36d6:	80 e2       	ldi	r24, 0x20	; 32
    36d8:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <SP_ReadCalibrationByte>
    36dc:	28 2f       	mov	r18, r24
    36de:	89 81       	ldd	r24, Y+1	; 0x01
    36e0:	9a 81       	ldd	r25, Y+2	; 0x02
    36e2:	fc 01       	movw	r30, r24
    36e4:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    36e6:	81 e2       	ldi	r24, 0x21	; 33
    36e8:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <SP_ReadCalibrationByte>
    36ec:	28 2f       	mov	r18, r24
    36ee:	89 81       	ldd	r24, Y+1	; 0x01
    36f0:	9a 81       	ldd	r25, Y+2	; 0x02
    36f2:	fc 01       	movw	r30, r24
    36f4:	25 87       	std	Z+13, r18	; 0x0d
    36f6:	10 c0       	rjmp	.+32     	; 0x3718 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    36f8:	84 e2       	ldi	r24, 0x24	; 36
    36fa:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <SP_ReadCalibrationByte>
    36fe:	28 2f       	mov	r18, r24
    3700:	89 81       	ldd	r24, Y+1	; 0x01
    3702:	9a 81       	ldd	r25, Y+2	; 0x02
    3704:	fc 01       	movw	r30, r24
    3706:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3708:	85 e2       	ldi	r24, 0x25	; 37
    370a:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <SP_ReadCalibrationByte>
    370e:	28 2f       	mov	r18, r24
    3710:	89 81       	ldd	r24, Y+1	; 0x01
    3712:	9a 81       	ldd	r25, Y+2	; 0x02
    3714:	fc 01       	movw	r30, r24
    3716:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3718:	0f 90       	pop	r0
    371a:	0f 90       	pop	r0
    371c:	df 91       	pop	r29
    371e:	cf 91       	pop	r28
    3720:	08 95       	ret

00003722 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3722:	cf 93       	push	r28
    3724:	df 93       	push	r29
    3726:	cd b7       	in	r28, 0x3d	; 61
    3728:	de b7       	in	r29, 0x3e	; 62
    372a:	25 97       	sbiw	r28, 0x05	; 5
    372c:	cd bf       	out	0x3d, r28	; 61
    372e:	de bf       	out	0x3e, r29	; 62
    3730:	8b 83       	std	Y+3, r24	; 0x03
    3732:	9c 83       	std	Y+4, r25	; 0x04
    3734:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3736:	8b 81       	ldd	r24, Y+3	; 0x03
    3738:	9c 81       	ldd	r25, Y+4	; 0x04
    373a:	21 e0       	ldi	r18, 0x01	; 1
    373c:	fc 01       	movw	r30, r24
    373e:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    3740:	8b 81       	ldd	r24, Y+3	; 0x03
    3742:	9c 81       	ldd	r25, Y+4	; 0x04
    3744:	fc 01       	movw	r30, r24
    3746:	24 81       	ldd	r18, Z+4	; 0x04
    3748:	35 81       	ldd	r19, Z+5	; 0x05
    374a:	8d 81       	ldd	r24, Y+5	; 0x05
    374c:	88 2f       	mov	r24, r24
    374e:	90 e0       	ldi	r25, 0x00	; 0
    3750:	a9 01       	movw	r20, r18
    3752:	48 1b       	sub	r20, r24
    3754:	59 0b       	sbc	r21, r25
    3756:	ca 01       	movw	r24, r20
    3758:	89 83       	std	Y+1, r24	; 0x01
    375a:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    375c:	89 81       	ldd	r24, Y+1	; 0x01
    375e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3760:	25 96       	adiw	r28, 0x05	; 5
    3762:	cd bf       	out	0x3d, r28	; 61
    3764:	de bf       	out	0x3e, r29	; 62
    3766:	df 91       	pop	r29
    3768:	cf 91       	pop	r28
    376a:	08 95       	ret

0000376c <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    376c:	cf 93       	push	r28
    376e:	df 93       	push	r29
    3770:	cd b7       	in	r28, 0x3d	; 61
    3772:	de b7       	in	r29, 0x3e	; 62
    3774:	25 97       	sbiw	r28, 0x05	; 5
    3776:	cd bf       	out	0x3d, r28	; 61
    3778:	de bf       	out	0x3e, r29	; 62
    377a:	8b 83       	std	Y+3, r24	; 0x03
    377c:	9c 83       	std	Y+4, r25	; 0x04
    377e:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3780:	8b 81       	ldd	r24, Y+3	; 0x03
    3782:	9c 81       	ldd	r25, Y+4	; 0x04
    3784:	21 e0       	ldi	r18, 0x01	; 1
    3786:	fc 01       	movw	r30, r24
    3788:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    378a:	8b 81       	ldd	r24, Y+3	; 0x03
    378c:	9c 81       	ldd	r25, Y+4	; 0x04
    378e:	fc 01       	movw	r30, r24
    3790:	24 81       	ldd	r18, Z+4	; 0x04
    3792:	35 81       	ldd	r19, Z+5	; 0x05
    3794:	8d 81       	ldd	r24, Y+5	; 0x05
    3796:	99 27       	eor	r25, r25
    3798:	87 fd       	sbrc	r24, 7
    379a:	90 95       	com	r25
    379c:	a9 01       	movw	r20, r18
    379e:	48 1b       	sub	r20, r24
    37a0:	59 0b       	sbc	r21, r25
    37a2:	ca 01       	movw	r24, r20
    37a4:	89 83       	std	Y+1, r24	; 0x01
    37a6:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    37a8:	89 81       	ldd	r24, Y+1	; 0x01
    37aa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    37ac:	25 96       	adiw	r28, 0x05	; 5
    37ae:	cd bf       	out	0x3d, r28	; 61
    37b0:	de bf       	out	0x3e, r29	; 62
    37b2:	df 91       	pop	r29
    37b4:	cf 91       	pop	r28
    37b6:	08 95       	ret

000037b8 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    37b8:	cf 93       	push	r28
    37ba:	df 93       	push	r29
    37bc:	0f 92       	push	r0
    37be:	0f 92       	push	r0
    37c0:	cd b7       	in	r28, 0x3d	; 61
    37c2:	de b7       	in	r29, 0x3e	; 62
    37c4:	89 83       	std	Y+1, r24	; 0x01
    37c6:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    37c8:	89 81       	ldd	r24, Y+1	; 0x01
    37ca:	9a 81       	ldd	r25, Y+2	; 0x02
    37cc:	21 e0       	ldi	r18, 0x01	; 1
    37ce:	fc 01       	movw	r30, r24
    37d0:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    37d2:	89 81       	ldd	r24, Y+1	; 0x01
    37d4:	9a 81       	ldd	r25, Y+2	; 0x02
    37d6:	fc 01       	movw	r30, r24
    37d8:	84 81       	ldd	r24, Z+4	; 0x04
    37da:	95 81       	ldd	r25, Z+5	; 0x05
}
    37dc:	0f 90       	pop	r0
    37de:	0f 90       	pop	r0
    37e0:	df 91       	pop	r29
    37e2:	cf 91       	pop	r28
    37e4:	08 95       	ret

000037e6 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    37e6:	cf 93       	push	r28
    37e8:	df 93       	push	r29
    37ea:	0f 92       	push	r0
    37ec:	0f 92       	push	r0
    37ee:	cd b7       	in	r28, 0x3d	; 61
    37f0:	de b7       	in	r29, 0x3e	; 62
    37f2:	89 83       	std	Y+1, r24	; 0x01
    37f4:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    37f6:	89 81       	ldd	r24, Y+1	; 0x01
    37f8:	9a 81       	ldd	r25, Y+2	; 0x02
    37fa:	21 e0       	ldi	r18, 0x01	; 1
    37fc:	fc 01       	movw	r30, r24
    37fe:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3800:	89 81       	ldd	r24, Y+1	; 0x01
    3802:	9a 81       	ldd	r25, Y+2	; 0x02
    3804:	fc 01       	movw	r30, r24
    3806:	84 81       	ldd	r24, Z+4	; 0x04
}
    3808:	0f 90       	pop	r0
    380a:	0f 90       	pop	r0
    380c:	df 91       	pop	r29
    380e:	cf 91       	pop	r28
    3810:	08 95       	ret

00003812 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3812:	cf 93       	push	r28
    3814:	df 93       	push	r29
    3816:	0f 92       	push	r0
    3818:	0f 92       	push	r0
    381a:	cd b7       	in	r28, 0x3d	; 61
    381c:	de b7       	in	r29, 0x3e	; 62
    381e:	89 83       	std	Y+1, r24	; 0x01
    3820:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3822:	89 81       	ldd	r24, Y+1	; 0x01
    3824:	9a 81       	ldd	r25, Y+2	; 0x02
    3826:	21 e0       	ldi	r18, 0x01	; 1
    3828:	fc 01       	movw	r30, r24
    382a:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    382c:	89 81       	ldd	r24, Y+1	; 0x01
    382e:	9a 81       	ldd	r25, Y+2	; 0x02
    3830:	fc 01       	movw	r30, r24
    3832:	85 81       	ldd	r24, Z+5	; 0x05
}
    3834:	0f 90       	pop	r0
    3836:	0f 90       	pop	r0
    3838:	df 91       	pop	r29
    383a:	cf 91       	pop	r28
    383c:	08 95       	ret

0000383e <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    383e:	0f 93       	push	r16
    3840:	1f 93       	push	r17
    3842:	cf 93       	push	r28
    3844:	df 93       	push	r29
    3846:	cd b7       	in	r28, 0x3d	; 61
    3848:	de b7       	in	r29, 0x3e	; 62
    384a:	6b 97       	sbiw	r28, 0x1b	; 27
    384c:	cd bf       	out	0x3d, r28	; 61
    384e:	de bf       	out	0x3e, r29	; 62
    3850:	8a 8f       	std	Y+26, r24	; 0x1a
    3852:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3854:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3856:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3858:	fc 01       	movw	r30, r24
    385a:	84 81       	ldd	r24, Z+4	; 0x04
    385c:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    385e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3860:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3862:	fc 01       	movw	r30, r24
    3864:	14 82       	std	Z+4, r1	; 0x04
    3866:	80 e0       	ldi	r24, 0x00	; 0
    3868:	90 e0       	ldi	r25, 0x00	; 0
    386a:	a0 e8       	ldi	r26, 0x80	; 128
    386c:	b2 e4       	ldi	r27, 0x42	; 66
    386e:	8a 83       	std	Y+2, r24	; 0x02
    3870:	9b 83       	std	Y+3, r25	; 0x03
    3872:	ac 83       	std	Y+4, r26	; 0x04
    3874:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3876:	6a 81       	ldd	r22, Y+2	; 0x02
    3878:	7b 81       	ldd	r23, Y+3	; 0x03
    387a:	8c 81       	ldd	r24, Y+4	; 0x04
    387c:	9d 81       	ldd	r25, Y+5	; 0x05
    387e:	2b ea       	ldi	r18, 0xAB	; 171
    3880:	3a ea       	ldi	r19, 0xAA	; 170
    3882:	4a e2       	ldi	r20, 0x2A	; 42
    3884:	5f e3       	ldi	r21, 0x3F	; 63
    3886:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    388a:	dc 01       	movw	r26, r24
    388c:	cb 01       	movw	r24, r22
    388e:	8e 83       	std	Y+6, r24	; 0x06
    3890:	9f 83       	std	Y+7, r25	; 0x07
    3892:	a8 87       	std	Y+8, r26	; 0x08
    3894:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3896:	11 e0       	ldi	r17, 0x01	; 1
    3898:	6e 81       	ldd	r22, Y+6	; 0x06
    389a:	7f 81       	ldd	r23, Y+7	; 0x07
    389c:	88 85       	ldd	r24, Y+8	; 0x08
    389e:	99 85       	ldd	r25, Y+9	; 0x09
    38a0:	20 e0       	ldi	r18, 0x00	; 0
    38a2:	30 e0       	ldi	r19, 0x00	; 0
    38a4:	40 e8       	ldi	r20, 0x80	; 128
    38a6:	5f e3       	ldi	r21, 0x3F	; 63
    38a8:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    38ac:	88 23       	and	r24, r24
    38ae:	0c f0       	brlt	.+2      	; 0x38b2 <ADC_Wait_8MHz+0x74>
    38b0:	10 e0       	ldi	r17, 0x00	; 0
    38b2:	11 23       	and	r17, r17
    38b4:	19 f0       	breq	.+6      	; 0x38bc <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    38b6:	81 e0       	ldi	r24, 0x01	; 1
    38b8:	8a 87       	std	Y+10, r24	; 0x0a
    38ba:	a3 c0       	rjmp	.+326    	; 0x3a02 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    38bc:	11 e0       	ldi	r17, 0x01	; 1
    38be:	6e 81       	ldd	r22, Y+6	; 0x06
    38c0:	7f 81       	ldd	r23, Y+7	; 0x07
    38c2:	88 85       	ldd	r24, Y+8	; 0x08
    38c4:	99 85       	ldd	r25, Y+9	; 0x09
    38c6:	20 e0       	ldi	r18, 0x00	; 0
    38c8:	30 e0       	ldi	r19, 0x00	; 0
    38ca:	4f e7       	ldi	r20, 0x7F	; 127
    38cc:	53 e4       	ldi	r21, 0x43	; 67
    38ce:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    38d2:	18 16       	cp	r1, r24
    38d4:	0c f0       	brlt	.+2      	; 0x38d8 <ADC_Wait_8MHz+0x9a>
    38d6:	10 e0       	ldi	r17, 0x00	; 0
    38d8:	11 23       	and	r17, r17
    38da:	09 f4       	brne	.+2      	; 0x38de <ADC_Wait_8MHz+0xa0>
    38dc:	89 c0       	rjmp	.+274    	; 0x39f0 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    38de:	6a 81       	ldd	r22, Y+2	; 0x02
    38e0:	7b 81       	ldd	r23, Y+3	; 0x03
    38e2:	8c 81       	ldd	r24, Y+4	; 0x04
    38e4:	9d 81       	ldd	r25, Y+5	; 0x05
    38e6:	20 e0       	ldi	r18, 0x00	; 0
    38e8:	30 e0       	ldi	r19, 0x00	; 0
    38ea:	4a e7       	ldi	r20, 0x7A	; 122
    38ec:	54 e4       	ldi	r21, 0x44	; 68
    38ee:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    38f2:	dc 01       	movw	r26, r24
    38f4:	cb 01       	movw	r24, r22
    38f6:	8b 87       	std	Y+11, r24	; 0x0b
    38f8:	9c 87       	std	Y+12, r25	; 0x0c
    38fa:	ad 87       	std	Y+13, r26	; 0x0d
    38fc:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    38fe:	6b 85       	ldd	r22, Y+11	; 0x0b
    3900:	7c 85       	ldd	r23, Y+12	; 0x0c
    3902:	8d 85       	ldd	r24, Y+13	; 0x0d
    3904:	9e 85       	ldd	r25, Y+14	; 0x0e
    3906:	20 e0       	ldi	r18, 0x00	; 0
    3908:	30 e0       	ldi	r19, 0x00	; 0
    390a:	4a ef       	ldi	r20, 0xFA	; 250
    390c:	53 e4       	ldi	r21, 0x43	; 67
    390e:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    3912:	dc 01       	movw	r26, r24
    3914:	cb 01       	movw	r24, r22
    3916:	8f 87       	std	Y+15, r24	; 0x0f
    3918:	98 8b       	std	Y+16, r25	; 0x10
    391a:	a9 8b       	std	Y+17, r26	; 0x11
    391c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    391e:	11 e0       	ldi	r17, 0x01	; 1
    3920:	6f 85       	ldd	r22, Y+15	; 0x0f
    3922:	78 89       	ldd	r23, Y+16	; 0x10
    3924:	89 89       	ldd	r24, Y+17	; 0x11
    3926:	9a 89       	ldd	r25, Y+18	; 0x12
    3928:	20 e0       	ldi	r18, 0x00	; 0
    392a:	30 e0       	ldi	r19, 0x00	; 0
    392c:	40 e8       	ldi	r20, 0x80	; 128
    392e:	5f e3       	ldi	r21, 0x3F	; 63
    3930:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    3934:	88 23       	and	r24, r24
    3936:	0c f0       	brlt	.+2      	; 0x393a <ADC_Wait_8MHz+0xfc>
    3938:	10 e0       	ldi	r17, 0x00	; 0
    393a:	11 23       	and	r17, r17
    393c:	29 f0       	breq	.+10     	; 0x3948 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    393e:	81 e0       	ldi	r24, 0x01	; 1
    3940:	90 e0       	ldi	r25, 0x00	; 0
    3942:	8b 8b       	std	Y+19, r24	; 0x13
    3944:	9c 8b       	std	Y+20, r25	; 0x14
    3946:	46 c0       	rjmp	.+140    	; 0x39d4 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3948:	11 e0       	ldi	r17, 0x01	; 1
    394a:	6f 85       	ldd	r22, Y+15	; 0x0f
    394c:	78 89       	ldd	r23, Y+16	; 0x10
    394e:	89 89       	ldd	r24, Y+17	; 0x11
    3950:	9a 89       	ldd	r25, Y+18	; 0x12
    3952:	20 e0       	ldi	r18, 0x00	; 0
    3954:	3f ef       	ldi	r19, 0xFF	; 255
    3956:	4f e7       	ldi	r20, 0x7F	; 127
    3958:	57 e4       	ldi	r21, 0x47	; 71
    395a:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    395e:	18 16       	cp	r1, r24
    3960:	0c f0       	brlt	.+2      	; 0x3964 <ADC_Wait_8MHz+0x126>
    3962:	10 e0       	ldi	r17, 0x00	; 0
    3964:	11 23       	and	r17, r17
    3966:	61 f1       	breq	.+88     	; 0x39c0 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3968:	6b 85       	ldd	r22, Y+11	; 0x0b
    396a:	7c 85       	ldd	r23, Y+12	; 0x0c
    396c:	8d 85       	ldd	r24, Y+13	; 0x0d
    396e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3970:	20 e0       	ldi	r18, 0x00	; 0
    3972:	30 e0       	ldi	r19, 0x00	; 0
    3974:	40 e2       	ldi	r20, 0x20	; 32
    3976:	51 e4       	ldi	r21, 0x41	; 65
    3978:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    397c:	dc 01       	movw	r26, r24
    397e:	cb 01       	movw	r24, r22
    3980:	bc 01       	movw	r22, r24
    3982:	cd 01       	movw	r24, r26
    3984:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    3988:	dc 01       	movw	r26, r24
    398a:	cb 01       	movw	r24, r22
    398c:	8b 8b       	std	Y+19, r24	; 0x13
    398e:	9c 8b       	std	Y+20, r25	; 0x14
    3990:	12 c0       	rjmp	.+36     	; 0x39b6 <ADC_Wait_8MHz+0x178>
    3992:	82 e3       	ldi	r24, 0x32	; 50
    3994:	90 e0       	ldi	r25, 0x00	; 0
    3996:	8d 8b       	std	Y+21, r24	; 0x15
    3998:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    399a:	8d 89       	ldd	r24, Y+21	; 0x15
    399c:	9e 89       	ldd	r25, Y+22	; 0x16
    399e:	8c 01       	movw	r16, r24
    39a0:	c8 01       	movw	r24, r16
    39a2:	01 97       	sbiw	r24, 0x01	; 1
    39a4:	f1 f7       	brne	.-4      	; 0x39a2 <ADC_Wait_8MHz+0x164>
    39a6:	8c 01       	movw	r16, r24
    39a8:	0d 8b       	std	Y+21, r16	; 0x15
    39aa:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39ac:	8b 89       	ldd	r24, Y+19	; 0x13
    39ae:	9c 89       	ldd	r25, Y+20	; 0x14
    39b0:	01 97       	sbiw	r24, 0x01	; 1
    39b2:	8b 8b       	std	Y+19, r24	; 0x13
    39b4:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39b6:	8b 89       	ldd	r24, Y+19	; 0x13
    39b8:	9c 89       	ldd	r25, Y+20	; 0x14
    39ba:	00 97       	sbiw	r24, 0x00	; 0
    39bc:	51 f7       	brne	.-44     	; 0x3992 <ADC_Wait_8MHz+0x154>
    39be:	28 c0       	rjmp	.+80     	; 0x3a10 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    39c0:	6f 85       	ldd	r22, Y+15	; 0x0f
    39c2:	78 89       	ldd	r23, Y+16	; 0x10
    39c4:	89 89       	ldd	r24, Y+17	; 0x11
    39c6:	9a 89       	ldd	r25, Y+18	; 0x12
    39c8:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    39cc:	dc 01       	movw	r26, r24
    39ce:	cb 01       	movw	r24, r22
    39d0:	8b 8b       	std	Y+19, r24	; 0x13
    39d2:	9c 8b       	std	Y+20, r25	; 0x14
    39d4:	8b 89       	ldd	r24, Y+19	; 0x13
    39d6:	9c 89       	ldd	r25, Y+20	; 0x14
    39d8:	8f 8b       	std	Y+23, r24	; 0x17
    39da:	98 8f       	std	Y+24, r25	; 0x18
    39dc:	8f 89       	ldd	r24, Y+23	; 0x17
    39de:	98 8d       	ldd	r25, Y+24	; 0x18
    39e0:	8c 01       	movw	r16, r24
    39e2:	f8 01       	movw	r30, r16
    39e4:	31 97       	sbiw	r30, 0x01	; 1
    39e6:	f1 f7       	brne	.-4      	; 0x39e4 <ADC_Wait_8MHz+0x1a6>
    39e8:	8f 01       	movw	r16, r30
    39ea:	0f 8b       	std	Y+23, r16	; 0x17
    39ec:	18 8f       	std	Y+24, r17	; 0x18
    39ee:	10 c0       	rjmp	.+32     	; 0x3a10 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    39f0:	6e 81       	ldd	r22, Y+6	; 0x06
    39f2:	7f 81       	ldd	r23, Y+7	; 0x07
    39f4:	88 85       	ldd	r24, Y+8	; 0x08
    39f6:	99 85       	ldd	r25, Y+9	; 0x09
    39f8:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    39fc:	dc 01       	movw	r26, r24
    39fe:	cb 01       	movw	r24, r22
    3a00:	8a 87       	std	Y+10, r24	; 0x0a
    3a02:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a04:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a06:	89 8d       	ldd	r24, Y+25	; 0x19
    3a08:	18 2f       	mov	r17, r24
    3a0a:	1a 95       	dec	r17
    3a0c:	f1 f7       	brne	.-4      	; 0x3a0a <ADC_Wait_8MHz+0x1cc>
    3a0e:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3a10:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a12:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a14:	29 81       	ldd	r18, Y+1	; 0x01
    3a16:	fc 01       	movw	r30, r24
    3a18:	24 83       	std	Z+4, r18	; 0x04
}
    3a1a:	6b 96       	adiw	r28, 0x1b	; 27
    3a1c:	cd bf       	out	0x3d, r28	; 61
    3a1e:	de bf       	out	0x3e, r29	; 62
    3a20:	df 91       	pop	r29
    3a22:	cf 91       	pop	r28
    3a24:	1f 91       	pop	r17
    3a26:	0f 91       	pop	r16
    3a28:	08 95       	ret

00003a2a <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    3a2a:	0f 93       	push	r16
    3a2c:	1f 93       	push	r17
    3a2e:	cf 93       	push	r28
    3a30:	df 93       	push	r29
    3a32:	cd b7       	in	r28, 0x3d	; 61
    3a34:	de b7       	in	r29, 0x3e	; 62
    3a36:	6b 97       	sbiw	r28, 0x1b	; 27
    3a38:	cd bf       	out	0x3d, r28	; 61
    3a3a:	de bf       	out	0x3e, r29	; 62
    3a3c:	8a 8f       	std	Y+26, r24	; 0x1a
    3a3e:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3a40:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a42:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a44:	fc 01       	movw	r30, r24
    3a46:	84 81       	ldd	r24, Z+4	; 0x04
    3a48:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3a4a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3a4c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a4e:	21 e0       	ldi	r18, 0x01	; 1
    3a50:	fc 01       	movw	r30, r24
    3a52:	24 83       	std	Z+4, r18	; 0x04
    3a54:	80 e0       	ldi	r24, 0x00	; 0
    3a56:	90 e0       	ldi	r25, 0x00	; 0
    3a58:	a0 e0       	ldi	r26, 0x00	; 0
    3a5a:	b3 e4       	ldi	r27, 0x43	; 67
    3a5c:	8a 83       	std	Y+2, r24	; 0x02
    3a5e:	9b 83       	std	Y+3, r25	; 0x03
    3a60:	ac 83       	std	Y+4, r26	; 0x04
    3a62:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3a64:	6a 81       	ldd	r22, Y+2	; 0x02
    3a66:	7b 81       	ldd	r23, Y+3	; 0x03
    3a68:	8c 81       	ldd	r24, Y+4	; 0x04
    3a6a:	9d 81       	ldd	r25, Y+5	; 0x05
    3a6c:	2b ea       	ldi	r18, 0xAB	; 171
    3a6e:	3a ea       	ldi	r19, 0xAA	; 170
    3a70:	4a e2       	ldi	r20, 0x2A	; 42
    3a72:	5f e3       	ldi	r21, 0x3F	; 63
    3a74:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    3a78:	dc 01       	movw	r26, r24
    3a7a:	cb 01       	movw	r24, r22
    3a7c:	8e 83       	std	Y+6, r24	; 0x06
    3a7e:	9f 83       	std	Y+7, r25	; 0x07
    3a80:	a8 87       	std	Y+8, r26	; 0x08
    3a82:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3a84:	11 e0       	ldi	r17, 0x01	; 1
    3a86:	6e 81       	ldd	r22, Y+6	; 0x06
    3a88:	7f 81       	ldd	r23, Y+7	; 0x07
    3a8a:	88 85       	ldd	r24, Y+8	; 0x08
    3a8c:	99 85       	ldd	r25, Y+9	; 0x09
    3a8e:	20 e0       	ldi	r18, 0x00	; 0
    3a90:	30 e0       	ldi	r19, 0x00	; 0
    3a92:	40 e8       	ldi	r20, 0x80	; 128
    3a94:	5f e3       	ldi	r21, 0x3F	; 63
    3a96:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    3a9a:	88 23       	and	r24, r24
    3a9c:	0c f0       	brlt	.+2      	; 0x3aa0 <ADC_Wait_32MHz+0x76>
    3a9e:	10 e0       	ldi	r17, 0x00	; 0
    3aa0:	11 23       	and	r17, r17
    3aa2:	19 f0       	breq	.+6      	; 0x3aaa <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3aa4:	81 e0       	ldi	r24, 0x01	; 1
    3aa6:	8a 87       	std	Y+10, r24	; 0x0a
    3aa8:	a3 c0       	rjmp	.+326    	; 0x3bf0 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3aaa:	11 e0       	ldi	r17, 0x01	; 1
    3aac:	6e 81       	ldd	r22, Y+6	; 0x06
    3aae:	7f 81       	ldd	r23, Y+7	; 0x07
    3ab0:	88 85       	ldd	r24, Y+8	; 0x08
    3ab2:	99 85       	ldd	r25, Y+9	; 0x09
    3ab4:	20 e0       	ldi	r18, 0x00	; 0
    3ab6:	30 e0       	ldi	r19, 0x00	; 0
    3ab8:	4f e7       	ldi	r20, 0x7F	; 127
    3aba:	53 e4       	ldi	r21, 0x43	; 67
    3abc:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    3ac0:	18 16       	cp	r1, r24
    3ac2:	0c f0       	brlt	.+2      	; 0x3ac6 <ADC_Wait_32MHz+0x9c>
    3ac4:	10 e0       	ldi	r17, 0x00	; 0
    3ac6:	11 23       	and	r17, r17
    3ac8:	09 f4       	brne	.+2      	; 0x3acc <ADC_Wait_32MHz+0xa2>
    3aca:	89 c0       	rjmp	.+274    	; 0x3bde <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3acc:	6a 81       	ldd	r22, Y+2	; 0x02
    3ace:	7b 81       	ldd	r23, Y+3	; 0x03
    3ad0:	8c 81       	ldd	r24, Y+4	; 0x04
    3ad2:	9d 81       	ldd	r25, Y+5	; 0x05
    3ad4:	20 e0       	ldi	r18, 0x00	; 0
    3ad6:	30 e0       	ldi	r19, 0x00	; 0
    3ad8:	4a e7       	ldi	r20, 0x7A	; 122
    3ada:	54 e4       	ldi	r21, 0x44	; 68
    3adc:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    3ae0:	dc 01       	movw	r26, r24
    3ae2:	cb 01       	movw	r24, r22
    3ae4:	8b 87       	std	Y+11, r24	; 0x0b
    3ae6:	9c 87       	std	Y+12, r25	; 0x0c
    3ae8:	ad 87       	std	Y+13, r26	; 0x0d
    3aea:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3aec:	6b 85       	ldd	r22, Y+11	; 0x0b
    3aee:	7c 85       	ldd	r23, Y+12	; 0x0c
    3af0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3af2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3af4:	20 e0       	ldi	r18, 0x00	; 0
    3af6:	30 e0       	ldi	r19, 0x00	; 0
    3af8:	4a ef       	ldi	r20, 0xFA	; 250
    3afa:	53 e4       	ldi	r21, 0x43	; 67
    3afc:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    3b00:	dc 01       	movw	r26, r24
    3b02:	cb 01       	movw	r24, r22
    3b04:	8f 87       	std	Y+15, r24	; 0x0f
    3b06:	98 8b       	std	Y+16, r25	; 0x10
    3b08:	a9 8b       	std	Y+17, r26	; 0x11
    3b0a:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3b0c:	11 e0       	ldi	r17, 0x01	; 1
    3b0e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3b10:	78 89       	ldd	r23, Y+16	; 0x10
    3b12:	89 89       	ldd	r24, Y+17	; 0x11
    3b14:	9a 89       	ldd	r25, Y+18	; 0x12
    3b16:	20 e0       	ldi	r18, 0x00	; 0
    3b18:	30 e0       	ldi	r19, 0x00	; 0
    3b1a:	40 e8       	ldi	r20, 0x80	; 128
    3b1c:	5f e3       	ldi	r21, 0x3F	; 63
    3b1e:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    3b22:	88 23       	and	r24, r24
    3b24:	0c f0       	brlt	.+2      	; 0x3b28 <ADC_Wait_32MHz+0xfe>
    3b26:	10 e0       	ldi	r17, 0x00	; 0
    3b28:	11 23       	and	r17, r17
    3b2a:	29 f0       	breq	.+10     	; 0x3b36 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    3b2c:	81 e0       	ldi	r24, 0x01	; 1
    3b2e:	90 e0       	ldi	r25, 0x00	; 0
    3b30:	8b 8b       	std	Y+19, r24	; 0x13
    3b32:	9c 8b       	std	Y+20, r25	; 0x14
    3b34:	46 c0       	rjmp	.+140    	; 0x3bc2 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3b36:	11 e0       	ldi	r17, 0x01	; 1
    3b38:	6f 85       	ldd	r22, Y+15	; 0x0f
    3b3a:	78 89       	ldd	r23, Y+16	; 0x10
    3b3c:	89 89       	ldd	r24, Y+17	; 0x11
    3b3e:	9a 89       	ldd	r25, Y+18	; 0x12
    3b40:	20 e0       	ldi	r18, 0x00	; 0
    3b42:	3f ef       	ldi	r19, 0xFF	; 255
    3b44:	4f e7       	ldi	r20, 0x7F	; 127
    3b46:	57 e4       	ldi	r21, 0x47	; 71
    3b48:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    3b4c:	18 16       	cp	r1, r24
    3b4e:	0c f0       	brlt	.+2      	; 0x3b52 <ADC_Wait_32MHz+0x128>
    3b50:	10 e0       	ldi	r17, 0x00	; 0
    3b52:	11 23       	and	r17, r17
    3b54:	61 f1       	breq	.+88     	; 0x3bae <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b56:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b58:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b5a:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b5c:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b5e:	20 e0       	ldi	r18, 0x00	; 0
    3b60:	30 e0       	ldi	r19, 0x00	; 0
    3b62:	40 e2       	ldi	r20, 0x20	; 32
    3b64:	51 e4       	ldi	r21, 0x41	; 65
    3b66:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    3b6a:	dc 01       	movw	r26, r24
    3b6c:	cb 01       	movw	r24, r22
    3b6e:	bc 01       	movw	r22, r24
    3b70:	cd 01       	movw	r24, r26
    3b72:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    3b76:	dc 01       	movw	r26, r24
    3b78:	cb 01       	movw	r24, r22
    3b7a:	8b 8b       	std	Y+19, r24	; 0x13
    3b7c:	9c 8b       	std	Y+20, r25	; 0x14
    3b7e:	12 c0       	rjmp	.+36     	; 0x3ba4 <ADC_Wait_32MHz+0x17a>
    3b80:	82 e3       	ldi	r24, 0x32	; 50
    3b82:	90 e0       	ldi	r25, 0x00	; 0
    3b84:	8d 8b       	std	Y+21, r24	; 0x15
    3b86:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b88:	8d 89       	ldd	r24, Y+21	; 0x15
    3b8a:	9e 89       	ldd	r25, Y+22	; 0x16
    3b8c:	8c 01       	movw	r16, r24
    3b8e:	c8 01       	movw	r24, r16
    3b90:	01 97       	sbiw	r24, 0x01	; 1
    3b92:	f1 f7       	brne	.-4      	; 0x3b90 <ADC_Wait_32MHz+0x166>
    3b94:	8c 01       	movw	r16, r24
    3b96:	0d 8b       	std	Y+21, r16	; 0x15
    3b98:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b9a:	8b 89       	ldd	r24, Y+19	; 0x13
    3b9c:	9c 89       	ldd	r25, Y+20	; 0x14
    3b9e:	01 97       	sbiw	r24, 0x01	; 1
    3ba0:	8b 8b       	std	Y+19, r24	; 0x13
    3ba2:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3ba4:	8b 89       	ldd	r24, Y+19	; 0x13
    3ba6:	9c 89       	ldd	r25, Y+20	; 0x14
    3ba8:	00 97       	sbiw	r24, 0x00	; 0
    3baa:	51 f7       	brne	.-44     	; 0x3b80 <ADC_Wait_32MHz+0x156>
    3bac:	28 c0       	rjmp	.+80     	; 0x3bfe <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3bae:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bb0:	78 89       	ldd	r23, Y+16	; 0x10
    3bb2:	89 89       	ldd	r24, Y+17	; 0x11
    3bb4:	9a 89       	ldd	r25, Y+18	; 0x12
    3bb6:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    3bba:	dc 01       	movw	r26, r24
    3bbc:	cb 01       	movw	r24, r22
    3bbe:	8b 8b       	std	Y+19, r24	; 0x13
    3bc0:	9c 8b       	std	Y+20, r25	; 0x14
    3bc2:	8b 89       	ldd	r24, Y+19	; 0x13
    3bc4:	9c 89       	ldd	r25, Y+20	; 0x14
    3bc6:	8f 8b       	std	Y+23, r24	; 0x17
    3bc8:	98 8f       	std	Y+24, r25	; 0x18
    3bca:	8f 89       	ldd	r24, Y+23	; 0x17
    3bcc:	98 8d       	ldd	r25, Y+24	; 0x18
    3bce:	8c 01       	movw	r16, r24
    3bd0:	f8 01       	movw	r30, r16
    3bd2:	31 97       	sbiw	r30, 0x01	; 1
    3bd4:	f1 f7       	brne	.-4      	; 0x3bd2 <ADC_Wait_32MHz+0x1a8>
    3bd6:	8f 01       	movw	r16, r30
    3bd8:	0f 8b       	std	Y+23, r16	; 0x17
    3bda:	18 8f       	std	Y+24, r17	; 0x18
    3bdc:	10 c0       	rjmp	.+32     	; 0x3bfe <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3bde:	6e 81       	ldd	r22, Y+6	; 0x06
    3be0:	7f 81       	ldd	r23, Y+7	; 0x07
    3be2:	88 85       	ldd	r24, Y+8	; 0x08
    3be4:	99 85       	ldd	r25, Y+9	; 0x09
    3be6:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    3bea:	dc 01       	movw	r26, r24
    3bec:	cb 01       	movw	r24, r22
    3bee:	8a 87       	std	Y+10, r24	; 0x0a
    3bf0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bf2:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3bf4:	89 8d       	ldd	r24, Y+25	; 0x19
    3bf6:	18 2f       	mov	r17, r24
    3bf8:	1a 95       	dec	r17
    3bfa:	f1 f7       	brne	.-4      	; 0x3bf8 <ADC_Wait_32MHz+0x1ce>
    3bfc:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3bfe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3c00:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3c02:	29 81       	ldd	r18, Y+1	; 0x01
    3c04:	fc 01       	movw	r30, r24
    3c06:	24 83       	std	Z+4, r18	; 0x04
}
    3c08:	6b 96       	adiw	r28, 0x1b	; 27
    3c0a:	cd bf       	out	0x3d, r28	; 61
    3c0c:	de bf       	out	0x3e, r29	; 62
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	1f 91       	pop	r17
    3c14:	0f 91       	pop	r16
    3c16:	08 95       	ret

00003c18 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3c18:	cf 93       	push	r28
    3c1a:	df 93       	push	r29
    3c1c:	cd b7       	in	r28, 0x3d	; 61
    3c1e:	de b7       	in	r29, 0x3e	; 62
    3c20:	2a 97       	sbiw	r28, 0x0a	; 10
    3c22:	cd bf       	out	0x3d, r28	; 61
    3c24:	de bf       	out	0x3e, r29	; 62
    3c26:	8e 83       	std	Y+6, r24	; 0x06
    3c28:	9f 83       	std	Y+7, r25	; 0x07
    3c2a:	68 87       	std	Y+8, r22	; 0x08
    3c2c:	79 87       	std	Y+9, r23	; 0x09
    3c2e:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3c30:	8a 85       	ldd	r24, Y+10	; 0x0a
    3c32:	88 23       	and	r24, r24
    3c34:	a9 f1       	breq	.+106    	; 0x3ca0 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3c36:	19 82       	std	Y+1, r1	; 0x01
    3c38:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3c3a:	1b 82       	std	Y+3, r1	; 0x03
    3c3c:	1c 82       	std	Y+4, r1	; 0x04
    3c3e:	24 c0       	rjmp	.+72     	; 0x3c88 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3c40:	88 85       	ldd	r24, Y+8	; 0x08
    3c42:	99 85       	ldd	r25, Y+9	; 0x09
    3c44:	fc 01       	movw	r30, r24
    3c46:	80 81       	ld	r24, Z
    3c48:	28 2f       	mov	r18, r24
    3c4a:	20 68       	ori	r18, 0x80	; 128
    3c4c:	88 85       	ldd	r24, Y+8	; 0x08
    3c4e:	99 85       	ldd	r25, Y+9	; 0x09
    3c50:	fc 01       	movw	r30, r24
    3c52:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3c54:	88 85       	ldd	r24, Y+8	; 0x08
    3c56:	99 85       	ldd	r25, Y+9	; 0x09
    3c58:	fc 01       	movw	r30, r24
    3c5a:	83 81       	ldd	r24, Z+3	; 0x03
    3c5c:	88 2f       	mov	r24, r24
    3c5e:	90 e0       	ldi	r25, 0x00	; 0
    3c60:	81 70       	andi	r24, 0x01	; 1
    3c62:	90 70       	andi	r25, 0x00	; 0
    3c64:	00 97       	sbiw	r24, 0x00	; 0
    3c66:	b1 f3       	breq	.-20     	; 0x3c54 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3c68:	88 85       	ldd	r24, Y+8	; 0x08
    3c6a:	99 85       	ldd	r25, Y+9	; 0x09
    3c6c:	60 e0       	ldi	r22, 0x00	; 0
    3c6e:	0e 94 91 1b 	call	0x3722	; 0x3722 <ADC_ResultCh_GetWord_Unsigned>
    3c72:	29 81       	ldd	r18, Y+1	; 0x01
    3c74:	3a 81       	ldd	r19, Y+2	; 0x02
    3c76:	82 0f       	add	r24, r18
    3c78:	93 1f       	adc	r25, r19
    3c7a:	89 83       	std	Y+1, r24	; 0x01
    3c7c:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c80:	9c 81       	ldd	r25, Y+4	; 0x04
    3c82:	01 96       	adiw	r24, 0x01	; 1
    3c84:	8b 83       	std	Y+3, r24	; 0x03
    3c86:	9c 83       	std	Y+4, r25	; 0x04
    3c88:	8b 81       	ldd	r24, Y+3	; 0x03
    3c8a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c8c:	84 30       	cpi	r24, 0x04	; 4
    3c8e:	91 05       	cpc	r25, r1
    3c90:	bc f2       	brlt	.-82     	; 0x3c40 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3c92:	89 81       	ldd	r24, Y+1	; 0x01
    3c94:	9a 81       	ldd	r25, Y+2	; 0x02
    3c96:	96 95       	lsr	r25
    3c98:	87 95       	ror	r24
    3c9a:	96 95       	lsr	r25
    3c9c:	87 95       	ror	r24
    3c9e:	1b c0       	rjmp	.+54     	; 0x3cd6 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3ca0:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3ca2:	88 85       	ldd	r24, Y+8	; 0x08
    3ca4:	99 85       	ldd	r25, Y+9	; 0x09
    3ca6:	fc 01       	movw	r30, r24
    3ca8:	80 81       	ld	r24, Z
    3caa:	28 2f       	mov	r18, r24
    3cac:	20 68       	ori	r18, 0x80	; 128
    3cae:	88 85       	ldd	r24, Y+8	; 0x08
    3cb0:	99 85       	ldd	r25, Y+9	; 0x09
    3cb2:	fc 01       	movw	r30, r24
    3cb4:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3cb6:	88 85       	ldd	r24, Y+8	; 0x08
    3cb8:	99 85       	ldd	r25, Y+9	; 0x09
    3cba:	fc 01       	movw	r30, r24
    3cbc:	83 81       	ldd	r24, Z+3	; 0x03
    3cbe:	88 2f       	mov	r24, r24
    3cc0:	90 e0       	ldi	r25, 0x00	; 0
    3cc2:	81 70       	andi	r24, 0x01	; 1
    3cc4:	90 70       	andi	r25, 0x00	; 0
    3cc6:	00 97       	sbiw	r24, 0x00	; 0
    3cc8:	b1 f3       	breq	.-20     	; 0x3cb6 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3cca:	88 85       	ldd	r24, Y+8	; 0x08
    3ccc:	99 85       	ldd	r25, Y+9	; 0x09
    3cce:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <ADC_ResultCh_GetWord>
    3cd2:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3cd4:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3cd6:	2a 96       	adiw	r28, 0x0a	; 10
    3cd8:	cd bf       	out	0x3d, r28	; 61
    3cda:	de bf       	out	0x3e, r29	; 62
    3cdc:	df 91       	pop	r29
    3cde:	cf 91       	pop	r28
    3ce0:	08 95       	ret

00003ce2 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3ce2:	cf 93       	push	r28
    3ce4:	df 93       	push	r29
    3ce6:	cd b7       	in	r28, 0x3d	; 61
    3ce8:	de b7       	in	r29, 0x3e	; 62
    3cea:	2a 97       	sbiw	r28, 0x0a	; 10
    3cec:	cd bf       	out	0x3d, r28	; 61
    3cee:	de bf       	out	0x3e, r29	; 62
    3cf0:	8e 83       	std	Y+6, r24	; 0x06
    3cf2:	9f 83       	std	Y+7, r25	; 0x07
    3cf4:	68 87       	std	Y+8, r22	; 0x08
    3cf6:	79 87       	std	Y+9, r23	; 0x09
    3cf8:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3cfa:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cfc:	88 23       	and	r24, r24
    3cfe:	c1 f1       	breq	.+112    	; 0x3d70 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3d00:	19 82       	std	Y+1, r1	; 0x01
    3d02:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3d04:	1b 82       	std	Y+3, r1	; 0x03
    3d06:	1c 82       	std	Y+4, r1	; 0x04
    3d08:	24 c0       	rjmp	.+72     	; 0x3d52 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3d0a:	88 85       	ldd	r24, Y+8	; 0x08
    3d0c:	99 85       	ldd	r25, Y+9	; 0x09
    3d0e:	fc 01       	movw	r30, r24
    3d10:	80 81       	ld	r24, Z
    3d12:	28 2f       	mov	r18, r24
    3d14:	20 68       	ori	r18, 0x80	; 128
    3d16:	88 85       	ldd	r24, Y+8	; 0x08
    3d18:	99 85       	ldd	r25, Y+9	; 0x09
    3d1a:	fc 01       	movw	r30, r24
    3d1c:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3d1e:	88 85       	ldd	r24, Y+8	; 0x08
    3d20:	99 85       	ldd	r25, Y+9	; 0x09
    3d22:	fc 01       	movw	r30, r24
    3d24:	83 81       	ldd	r24, Z+3	; 0x03
    3d26:	88 2f       	mov	r24, r24
    3d28:	90 e0       	ldi	r25, 0x00	; 0
    3d2a:	81 70       	andi	r24, 0x01	; 1
    3d2c:	90 70       	andi	r25, 0x00	; 0
    3d2e:	00 97       	sbiw	r24, 0x00	; 0
    3d30:	b1 f3       	breq	.-20     	; 0x3d1e <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3d32:	88 85       	ldd	r24, Y+8	; 0x08
    3d34:	99 85       	ldd	r25, Y+9	; 0x09
    3d36:	60 e0       	ldi	r22, 0x00	; 0
    3d38:	0e 94 b6 1b 	call	0x376c	; 0x376c <ADC_ResultCh_GetWord_Signed>
    3d3c:	29 81       	ldd	r18, Y+1	; 0x01
    3d3e:	3a 81       	ldd	r19, Y+2	; 0x02
    3d40:	82 0f       	add	r24, r18
    3d42:	93 1f       	adc	r25, r19
    3d44:	89 83       	std	Y+1, r24	; 0x01
    3d46:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3d48:	8b 81       	ldd	r24, Y+3	; 0x03
    3d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d4c:	01 96       	adiw	r24, 0x01	; 1
    3d4e:	8b 83       	std	Y+3, r24	; 0x03
    3d50:	9c 83       	std	Y+4, r25	; 0x04
    3d52:	8b 81       	ldd	r24, Y+3	; 0x03
    3d54:	9c 81       	ldd	r25, Y+4	; 0x04
    3d56:	84 30       	cpi	r24, 0x04	; 4
    3d58:	91 05       	cpc	r25, r1
    3d5a:	bc f2       	brlt	.-82     	; 0x3d0a <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3d5c:	89 81       	ldd	r24, Y+1	; 0x01
    3d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d60:	99 23       	and	r25, r25
    3d62:	0c f4       	brge	.+2      	; 0x3d66 <ADC_Offset_Get_Signed+0x84>
    3d64:	03 96       	adiw	r24, 0x03	; 3
    3d66:	95 95       	asr	r25
    3d68:	87 95       	ror	r24
    3d6a:	95 95       	asr	r25
    3d6c:	87 95       	ror	r24
    3d6e:	1c c0       	rjmp	.+56     	; 0x3da8 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3d70:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3d72:	88 85       	ldd	r24, Y+8	; 0x08
    3d74:	99 85       	ldd	r25, Y+9	; 0x09
    3d76:	fc 01       	movw	r30, r24
    3d78:	80 81       	ld	r24, Z
    3d7a:	28 2f       	mov	r18, r24
    3d7c:	20 68       	ori	r18, 0x80	; 128
    3d7e:	88 85       	ldd	r24, Y+8	; 0x08
    3d80:	99 85       	ldd	r25, Y+9	; 0x09
    3d82:	fc 01       	movw	r30, r24
    3d84:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3d86:	88 85       	ldd	r24, Y+8	; 0x08
    3d88:	99 85       	ldd	r25, Y+9	; 0x09
    3d8a:	fc 01       	movw	r30, r24
    3d8c:	83 81       	ldd	r24, Z+3	; 0x03
    3d8e:	88 2f       	mov	r24, r24
    3d90:	90 e0       	ldi	r25, 0x00	; 0
    3d92:	81 70       	andi	r24, 0x01	; 1
    3d94:	90 70       	andi	r25, 0x00	; 0
    3d96:	00 97       	sbiw	r24, 0x00	; 0
    3d98:	b1 f3       	breq	.-20     	; 0x3d86 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3d9a:	88 85       	ldd	r24, Y+8	; 0x08
    3d9c:	99 85       	ldd	r25, Y+9	; 0x09
    3d9e:	60 e0       	ldi	r22, 0x00	; 0
    3da0:	0e 94 b6 1b 	call	0x376c	; 0x376c <ADC_ResultCh_GetWord_Signed>
    3da4:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3da6:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3da8:	2a 96       	adiw	r28, 0x0a	; 10
    3daa:	cd bf       	out	0x3d, r28	; 61
    3dac:	de bf       	out	0x3e, r29	; 62
    3dae:	df 91       	pop	r29
    3db0:	cf 91       	pop	r28
    3db2:	08 95       	ret

00003db4 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3db4:	1f 93       	push	r17
    3db6:	cf 93       	push	r28
    3db8:	df 93       	push	r29
    3dba:	cd b7       	in	r28, 0x3d	; 61
    3dbc:	de b7       	in	r29, 0x3e	; 62
    3dbe:	25 97       	sbiw	r28, 0x05	; 5
    3dc0:	cd bf       	out	0x3d, r28	; 61
    3dc2:	de bf       	out	0x3e, r29	; 62
    3dc4:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3dc6:	8a ec       	ldi	r24, 0xCA	; 202
    3dc8:	91 e0       	ldi	r25, 0x01	; 1
    3dca:	22 e0       	ldi	r18, 0x02	; 2
    3dcc:	fc 01       	movw	r30, r24
    3dce:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3dd0:	8d 81       	ldd	r24, Y+5	; 0x05
    3dd2:	88 2f       	mov	r24, r24
    3dd4:	90 e0       	ldi	r25, 0x00	; 0
    3dd6:	89 83       	std	Y+1, r24	; 0x01
    3dd8:	9a 83       	std	Y+2, r25	; 0x02
    3dda:	89 81       	ldd	r24, Y+1	; 0x01
    3ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    3dde:	fc 01       	movw	r30, r24
    3de0:	14 91       	lpm	r17, Z
    3de2:	1b 83       	std	Y+3, r17	; 0x03
    3de4:	8b 81       	ldd	r24, Y+3	; 0x03
    3de6:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3de8:	8a ec       	ldi	r24, 0xCA	; 202
    3dea:	91 e0       	ldi	r25, 0x01	; 1
    3dec:	fc 01       	movw	r30, r24
    3dee:	10 82       	st	Z, r1

	return result;
    3df0:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3df2:	25 96       	adiw	r28, 0x05	; 5
    3df4:	cd bf       	out	0x3d, r28	; 61
    3df6:	de bf       	out	0x3e, r29	; 62
    3df8:	df 91       	pop	r29
    3dfa:	cf 91       	pop	r28
    3dfc:	1f 91       	pop	r17
    3dfe:	08 95       	ret

00003e00 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3e00:	cf 93       	push	r28
    3e02:	df 93       	push	r29
    3e04:	cd b7       	in	r28, 0x3d	; 61
    3e06:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3e08:	24 e1       	ldi	r18, 0x14	; 20
    3e0a:	80 e3       	ldi	r24, 0x30	; 48
    3e0c:	91 e2       	ldi	r25, 0x21	; 33
    3e0e:	fc 01       	movw	r30, r24
    3e10:	32 2f       	mov	r19, r18
    3e12:	11 92       	st	Z+, r1
    3e14:	3a 95       	dec	r19
    3e16:	e9 f7       	brne	.-6      	; 0x3e12 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3e18:	0e 94 c0 2c 	call	0x5980	; 0x5980 <chb_get_short_addr>
    3e1c:	80 93 30 21 	sts	0x2130, r24
    3e20:	90 93 31 21 	sts	0x2131, r25
    chb_drvr_init();
    3e24:	0e 94 b0 2e 	call	0x5d60	; 0x5d60 <chb_drvr_init>
	radio_msg_received_int_enable();
    3e28:	0e 94 19 1f 	call	0x3e32	; 0x3e32 <radio_msg_received_int_enable>
}
    3e2c:	df 91       	pop	r29
    3e2e:	cf 91       	pop	r28
    3e30:	08 95       	ret

00003e32 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    3e32:	cf 93       	push	r28
    3e34:	df 93       	push	r29
    3e36:	cd b7       	in	r28, 0x3d	; 61
    3e38:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    3e3a:	80 e8       	ldi	r24, 0x80	; 128
    3e3c:	96 e0       	ldi	r25, 0x06	; 6
    3e3e:	24 e0       	ldi	r18, 0x04	; 4
    3e40:	fc 01       	movw	r30, r24
    3e42:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3e44:	80 e8       	ldi	r24, 0x80	; 128
    3e46:	96 e0       	ldi	r25, 0x06	; 6
    3e48:	24 e0       	ldi	r18, 0x04	; 4
    3e4a:	fc 01       	movw	r30, r24
    3e4c:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3e4e:	80 e8       	ldi	r24, 0x80	; 128
    3e50:	96 e0       	ldi	r25, 0x06	; 6
    3e52:	22 e0       	ldi	r18, 0x02	; 2
    3e54:	fc 01       	movw	r30, r24
    3e56:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3e58:	80 e8       	ldi	r24, 0x80	; 128
    3e5a:	96 e0       	ldi	r25, 0x06	; 6
    3e5c:	24 e0       	ldi	r18, 0x04	; 4
    3e5e:	fc 01       	movw	r30, r24
    3e60:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3e62:	80 e8       	ldi	r24, 0x80	; 128
    3e64:	96 e0       	ldi	r25, 0x06	; 6
    3e66:	23 e0       	ldi	r18, 0x03	; 3
    3e68:	fc 01       	movw	r30, r24
    3e6a:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3e6c:	80 ea       	ldi	r24, 0xA0	; 160
    3e6e:	90 e0       	ldi	r25, 0x00	; 0
    3e70:	20 ea       	ldi	r18, 0xA0	; 160
    3e72:	30 e0       	ldi	r19, 0x00	; 0
    3e74:	f9 01       	movw	r30, r18
    3e76:	22 81       	ldd	r18, Z+2	; 0x02
    3e78:	24 60       	ori	r18, 0x04	; 4
    3e7a:	fc 01       	movw	r30, r24
    3e7c:	22 83       	std	Z+2, r18	; 0x02
	sei();
    3e7e:	78 94       	sei
}
    3e80:	df 91       	pop	r29
    3e82:	cf 91       	pop	r28
    3e84:	08 95       	ret

00003e86 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3e86:	cf 93       	push	r28
    3e88:	df 93       	push	r29
    3e8a:	cd b7       	in	r28, 0x3d	; 61
    3e8c:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3e8e:	80 e3       	ldi	r24, 0x30	; 48
    3e90:	91 e2       	ldi	r25, 0x21	; 33
}
    3e92:	df 91       	pop	r29
    3e94:	cf 91       	pop	r28
    3e96:	08 95       	ret

00003e98 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3e98:	cf 93       	push	r28
    3e9a:	df 93       	push	r29
    3e9c:	cd b7       	in	r28, 0x3d	; 61
    3e9e:	de b7       	in	r29, 0x3e	; 62
    3ea0:	27 97       	sbiw	r28, 0x07	; 7
    3ea2:	cd bf       	out	0x3d, r28	; 61
    3ea4:	de bf       	out	0x3e, r29	; 62
    3ea6:	8b 83       	std	Y+3, r24	; 0x03
    3ea8:	9c 83       	std	Y+4, r25	; 0x04
    3eaa:	6d 83       	std	Y+5, r22	; 0x05
    3eac:	7e 83       	std	Y+6, r23	; 0x06
    3eae:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    3eb4:	89 83       	std	Y+1, r24	; 0x01
    3eb6:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3eb8:	8f 81       	ldd	r24, Y+7	; 0x07
    3eba:	28 2f       	mov	r18, r24
    3ebc:	25 5f       	subi	r18, 0xF5	; 245
    3ebe:	89 81       	ldd	r24, Y+1	; 0x01
    3ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ec2:	fc 01       	movw	r30, r24
    3ec4:	20 83       	st	Z, r18
    3ec6:	89 81       	ldd	r24, Y+1	; 0x01
    3ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eca:	01 96       	adiw	r24, 0x01	; 1
    3ecc:	89 83       	std	Y+1, r24	; 0x01
    3ece:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3ed0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ed2:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed4:	ff ef       	ldi	r31, 0xFF	; 255
    3ed6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ed8:	9f 07       	cpc	r25, r31
    3eda:	11 f0       	breq	.+4      	; 0x3ee0 <chb_gen_hdr+0x48>
    3edc:	21 e6       	ldi	r18, 0x61	; 97
    3ede:	01 c0       	rjmp	.+2      	; 0x3ee2 <chb_gen_hdr+0x4a>
    3ee0:	21 e4       	ldi	r18, 0x41	; 65
    3ee2:	89 81       	ldd	r24, Y+1	; 0x01
    3ee4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee6:	fc 01       	movw	r30, r24
    3ee8:	20 83       	st	Z, r18
    3eea:	89 81       	ldd	r24, Y+1	; 0x01
    3eec:	9a 81       	ldd	r25, Y+2	; 0x02
    3eee:	01 96       	adiw	r24, 0x01	; 1
    3ef0:	89 83       	std	Y+1, r24	; 0x01
    3ef2:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3ef4:	89 81       	ldd	r24, Y+1	; 0x01
    3ef6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef8:	28 e9       	ldi	r18, 0x98	; 152
    3efa:	fc 01       	movw	r30, r24
    3efc:	20 83       	st	Z, r18
    3efe:	89 81       	ldd	r24, Y+1	; 0x01
    3f00:	9a 81       	ldd	r25, Y+2	; 0x02
    3f02:	01 96       	adiw	r24, 0x01	; 1
    3f04:	89 83       	std	Y+1, r24	; 0x01
    3f06:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3f08:	20 91 32 21 	lds	r18, 0x2132
    3f0c:	89 81       	ldd	r24, Y+1	; 0x01
    3f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f10:	fc 01       	movw	r30, r24
    3f12:	20 83       	st	Z, r18
    3f14:	89 81       	ldd	r24, Y+1	; 0x01
    3f16:	9a 81       	ldd	r25, Y+2	; 0x02
    3f18:	01 96       	adiw	r24, 0x01	; 1
    3f1a:	89 83       	std	Y+1, r24	; 0x01
    3f1c:	9a 83       	std	Y+2, r25	; 0x02
    3f1e:	82 2f       	mov	r24, r18
    3f20:	8f 5f       	subi	r24, 0xFF	; 255
    3f22:	80 93 32 21 	sts	0x2132, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3f26:	89 81       	ldd	r24, Y+1	; 0x01
    3f28:	9a 81       	ldd	r25, Y+2	; 0x02
    3f2a:	24 e3       	ldi	r18, 0x34	; 52
    3f2c:	32 e1       	ldi	r19, 0x12	; 18
    3f2e:	fc 01       	movw	r30, r24
    3f30:	20 83       	st	Z, r18
    3f32:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3f34:	89 81       	ldd	r24, Y+1	; 0x01
    3f36:	9a 81       	ldd	r25, Y+2	; 0x02
    3f38:	02 96       	adiw	r24, 0x02	; 2
    3f3a:	89 83       	std	Y+1, r24	; 0x01
    3f3c:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3f3e:	89 81       	ldd	r24, Y+1	; 0x01
    3f40:	9a 81       	ldd	r25, Y+2	; 0x02
    3f42:	2d 81       	ldd	r18, Y+5	; 0x05
    3f44:	3e 81       	ldd	r19, Y+6	; 0x06
    3f46:	fc 01       	movw	r30, r24
    3f48:	20 83       	st	Z, r18
    3f4a:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3f4c:	89 81       	ldd	r24, Y+1	; 0x01
    3f4e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f50:	02 96       	adiw	r24, 0x02	; 2
    3f52:	89 83       	std	Y+1, r24	; 0x01
    3f54:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3f56:	20 91 30 21 	lds	r18, 0x2130
    3f5a:	30 91 31 21 	lds	r19, 0x2131
    3f5e:	89 81       	ldd	r24, Y+1	; 0x01
    3f60:	9a 81       	ldd	r25, Y+2	; 0x02
    3f62:	fc 01       	movw	r30, r24
    3f64:	20 83       	st	Z, r18
    3f66:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3f68:	89 81       	ldd	r24, Y+1	; 0x01
    3f6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f6c:	02 96       	adiw	r24, 0x02	; 2
    3f6e:	89 83       	std	Y+1, r24	; 0x01
    3f70:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3f72:	29 81       	ldd	r18, Y+1	; 0x01
    3f74:	3a 81       	ldd	r19, Y+2	; 0x02
    3f76:	8b 81       	ldd	r24, Y+3	; 0x03
    3f78:	9c 81       	ldd	r25, Y+4	; 0x04
    3f7a:	a9 01       	movw	r20, r18
    3f7c:	48 1b       	sub	r20, r24
    3f7e:	59 0b       	sbc	r21, r25
    3f80:	ca 01       	movw	r24, r20
}
    3f82:	27 96       	adiw	r28, 0x07	; 7
    3f84:	cd bf       	out	0x3d, r28	; 61
    3f86:	de bf       	out	0x3e, r29	; 62
    3f88:	df 91       	pop	r29
    3f8a:	cf 91       	pop	r28
    3f8c:	08 95       	ret

00003f8e <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3f8e:	ef 92       	push	r14
    3f90:	ff 92       	push	r15
    3f92:	0f 93       	push	r16
    3f94:	1f 93       	push	r17
    3f96:	cf 93       	push	r28
    3f98:	df 93       	push	r29
    3f9a:	cd b7       	in	r28, 0x3d	; 61
    3f9c:	de b7       	in	r29, 0x3e	; 62
    3f9e:	af 97       	sbiw	r28, 0x2f	; 47
    3fa0:	cd bf       	out	0x3d, r28	; 61
    3fa2:	de bf       	out	0x3e, r29	; 62
    3fa4:	88 a7       	lds	r24, 0x78
    3fa6:	99 a7       	lds	r25, 0x79
    3fa8:	6a a7       	lds	r22, 0x7a
    3faa:	7b a7       	lds	r23, 0x7b
    3fac:	2c a7       	lds	r18, 0x7c
    3fae:	3d a7       	lds	r19, 0x7d
    3fb0:	4e a7       	lds	r20, 0x7e
    3fb2:	5f a7       	lds	r21, 0x7f
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    3fb4:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3fb6:	61 c1       	rjmp	.+706    	; 0x427a <chb_write+0x2ec>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3fb8:	8c a5       	lds	r24, 0x6c
    3fba:	9d a5       	lds	r25, 0x6d
    3fbc:	ae a5       	lds	r26, 0x6e
    3fbe:	bf a5       	lds	r27, 0x6f
    3fc0:	85 36       	cpi	r24, 0x65	; 101
    3fc2:	91 05       	cpc	r25, r1
    3fc4:	a1 05       	cpc	r26, r1
    3fc6:	b1 05       	cpc	r27, r1
    3fc8:	20 f0       	brcs	.+8      	; 0x3fd2 <chb_write+0x44>
    3fca:	84 e6       	ldi	r24, 0x64	; 100
    3fcc:	90 e0       	ldi	r25, 0x00	; 0
    3fce:	a0 e0       	ldi	r26, 0x00	; 0
    3fd0:	b0 e0       	ldi	r27, 0x00	; 0
    3fd2:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);
    3fd4:	ce 01       	movw	r24, r28
    3fd6:	4e 96       	adiw	r24, 0x1e	; 30
    3fd8:	28 a5       	lds	r18, 0x68
    3fda:	39 a5       	lds	r19, 0x69
    3fdc:	b9 01       	movw	r22, r18
    3fde:	4c 81       	ldd	r20, Y+4	; 0x04
    3fe0:	0e 94 4c 1f 	call	0x3e98	; 0x3e98 <chb_gen_hdr>

        // send data to chip
		rtry = 0;
    3fe4:	1a 82       	std	Y+2, r1	; 0x02
    3fe6:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3fe8:	89 81       	ldd	r24, Y+1	; 0x01
    3fea:	88 2f       	mov	r24, r24
    3fec:	90 e0       	ldi	r25, 0x00	; 0
    3fee:	2a a5       	lds	r18, 0x6a
    3ff0:	3b a5       	lds	r19, 0x6b
    3ff2:	28 0f       	add	r18, r24
    3ff4:	39 1f       	adc	r19, r25
    3ff6:	ce 01       	movw	r24, r28
    3ff8:	4e 96       	adiw	r24, 0x1e	; 30
    3ffa:	b9 01       	movw	r22, r18
    3ffc:	4c 81       	ldd	r20, Y+4	; 0x04
    3ffe:	0e 94 da 2c 	call	0x59b4	; 0x59b4 <chb_tx>
    4002:	8d 83       	std	Y+5, r24	; 0x05

             switch (status)
    4004:	8d 81       	ldd	r24, Y+5	; 0x05
    4006:	88 2f       	mov	r24, r24
    4008:	90 e0       	ldi	r25, 0x00	; 0
    400a:	83 30       	cpi	r24, 0x03	; 3
    400c:	91 05       	cpc	r25, r1
    400e:	31 f1       	breq	.+76     	; 0x405c <chb_write+0xce>
    4010:	84 30       	cpi	r24, 0x04	; 4
    4012:	91 05       	cpc	r25, r1
    4014:	24 f4       	brge	.+8      	; 0x401e <chb_write+0x90>
    4016:	81 30       	cpi	r24, 0x01	; 1
    4018:	91 05       	cpc	r25, r1
    401a:	39 f0       	breq	.+14     	; 0x402a <chb_write+0x9c>
    401c:	2e c0       	rjmp	.+92     	; 0x407a <chb_write+0xec>
    401e:	85 30       	cpi	r24, 0x05	; 5
    4020:	91 05       	cpc	r25, r1
    4022:	69 f0       	breq	.+26     	; 0x403e <chb_write+0xb0>
    4024:	80 34       	cpi	r24, 0x40	; 64
    4026:	91 05       	cpc	r25, r1
    4028:	41 f5       	brne	.+80     	; 0x407a <chb_write+0xec>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    402a:	80 91 37 21 	lds	r24, 0x2137
    402e:	90 91 38 21 	lds	r25, 0x2138
    4032:	01 96       	adiw	r24, 0x01	; 1
    4034:	80 93 37 21 	sts	0x2137, r24
    4038:	90 93 38 21 	sts	0x2138, r25
                 break;
    403c:	1f c0       	rjmp	.+62     	; 0x407c <chb_write+0xee>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    403e:	80 91 39 21 	lds	r24, 0x2139
    4042:	90 91 3a 21 	lds	r25, 0x213A
    4046:	01 96       	adiw	r24, 0x01	; 1
    4048:	80 93 39 21 	sts	0x2139, r24
    404c:	90 93 3a 21 	sts	0x213A, r25
				 rtry++;
    4050:	8a 81       	ldd	r24, Y+2	; 0x02
    4052:	9b 81       	ldd	r25, Y+3	; 0x03
    4054:	01 96       	adiw	r24, 0x01	; 1
    4056:	8a 83       	std	Y+2, r24	; 0x02
    4058:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    405a:	10 c0       	rjmp	.+32     	; 0x407c <chb_write+0xee>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    405c:	80 91 3b 21 	lds	r24, 0x213B
    4060:	90 91 3c 21 	lds	r25, 0x213C
    4064:	01 96       	adiw	r24, 0x01	; 1
    4066:	80 93 3b 21 	sts	0x213B, r24
    406a:	90 93 3c 21 	sts	0x213C, r25
				 rtry++;
    406e:	8a 81       	ldd	r24, Y+2	; 0x02
    4070:	9b 81       	ldd	r25, Y+3	; 0x03
    4072:	01 96       	adiw	r24, 0x01	; 1
    4074:	8a 83       	std	Y+2, r24	; 0x02
    4076:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    4078:	01 c0       	rjmp	.+2      	; 0x407c <chb_write+0xee>
 
             default:
                 break;
    407a:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    407c:	8a 81       	ldd	r24, Y+2	; 0x02
    407e:	9b 81       	ldd	r25, Y+3	; 0x03
    4080:	18 16       	cp	r1, r24
    4082:	19 06       	cpc	r1, r25
    4084:	0c f0       	brlt	.+2      	; 0x4088 <chb_write+0xfa>
    4086:	d5 c0       	rjmp	.+426    	; 0x4232 <chb_write+0x2a4>
    4088:	80 e0       	ldi	r24, 0x00	; 0
    408a:	90 e0       	ldi	r25, 0x00	; 0
    408c:	a0 e2       	ldi	r26, 0x20	; 32
    408e:	b1 e4       	ldi	r27, 0x41	; 65
    4090:	8e 83       	std	Y+6, r24	; 0x06
    4092:	9f 83       	std	Y+7, r25	; 0x07
    4094:	a8 87       	std	Y+8, r26	; 0x08
    4096:	b9 87       	std	Y+9, r27	; 0x09
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4098:	6e 81       	ldd	r22, Y+6	; 0x06
    409a:	7f 81       	ldd	r23, Y+7	; 0x07
    409c:	88 85       	ldd	r24, Y+8	; 0x08
    409e:	99 85       	ldd	r25, Y+9	; 0x09
    40a0:	2b ea       	ldi	r18, 0xAB	; 171
    40a2:	3a ea       	ldi	r19, 0xAA	; 170
    40a4:	4a e2       	ldi	r20, 0x2A	; 42
    40a6:	51 e4       	ldi	r21, 0x41	; 65
    40a8:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    40ac:	dc 01       	movw	r26, r24
    40ae:	cb 01       	movw	r24, r22
    40b0:	8a 87       	std	Y+10, r24	; 0x0a
    40b2:	9b 87       	std	Y+11, r25	; 0x0b
    40b4:	ac 87       	std	Y+12, r26	; 0x0c
    40b6:	bd 87       	std	Y+13, r27	; 0x0d
	if (__tmp < 1.0)
    40b8:	11 e0       	ldi	r17, 0x01	; 1
    40ba:	6a 85       	ldd	r22, Y+10	; 0x0a
    40bc:	7b 85       	ldd	r23, Y+11	; 0x0b
    40be:	8c 85       	ldd	r24, Y+12	; 0x0c
    40c0:	9d 85       	ldd	r25, Y+13	; 0x0d
    40c2:	20 e0       	ldi	r18, 0x00	; 0
    40c4:	30 e0       	ldi	r19, 0x00	; 0
    40c6:	40 e8       	ldi	r20, 0x80	; 128
    40c8:	5f e3       	ldi	r21, 0x3F	; 63
    40ca:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    40ce:	88 23       	and	r24, r24
    40d0:	0c f0       	brlt	.+2      	; 0x40d4 <chb_write+0x146>
    40d2:	10 e0       	ldi	r17, 0x00	; 0
    40d4:	11 23       	and	r17, r17
    40d6:	19 f0       	breq	.+6      	; 0x40de <chb_write+0x150>
		__ticks = 1;
    40d8:	81 e0       	ldi	r24, 0x01	; 1
    40da:	8e 87       	std	Y+14, r24	; 0x0e
    40dc:	a3 c0       	rjmp	.+326    	; 0x4224 <chb_write+0x296>
	else if (__tmp > 255)
    40de:	11 e0       	ldi	r17, 0x01	; 1
    40e0:	6a 85       	ldd	r22, Y+10	; 0x0a
    40e2:	7b 85       	ldd	r23, Y+11	; 0x0b
    40e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    40e6:	9d 85       	ldd	r25, Y+13	; 0x0d
    40e8:	20 e0       	ldi	r18, 0x00	; 0
    40ea:	30 e0       	ldi	r19, 0x00	; 0
    40ec:	4f e7       	ldi	r20, 0x7F	; 127
    40ee:	53 e4       	ldi	r21, 0x43	; 67
    40f0:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    40f4:	18 16       	cp	r1, r24
    40f6:	0c f0       	brlt	.+2      	; 0x40fa <chb_write+0x16c>
    40f8:	10 e0       	ldi	r17, 0x00	; 0
    40fa:	11 23       	and	r17, r17
    40fc:	09 f4       	brne	.+2      	; 0x4100 <chb_write+0x172>
    40fe:	89 c0       	rjmp	.+274    	; 0x4212 <chb_write+0x284>
	{
		_delay_ms(__us / 1000.0);
    4100:	6e 81       	ldd	r22, Y+6	; 0x06
    4102:	7f 81       	ldd	r23, Y+7	; 0x07
    4104:	88 85       	ldd	r24, Y+8	; 0x08
    4106:	99 85       	ldd	r25, Y+9	; 0x09
    4108:	20 e0       	ldi	r18, 0x00	; 0
    410a:	30 e0       	ldi	r19, 0x00	; 0
    410c:	4a e7       	ldi	r20, 0x7A	; 122
    410e:	54 e4       	ldi	r21, 0x44	; 68
    4110:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    4114:	dc 01       	movw	r26, r24
    4116:	cb 01       	movw	r24, r22
    4118:	8f 87       	std	Y+15, r24	; 0x0f
    411a:	98 8b       	std	Y+16, r25	; 0x10
    411c:	a9 8b       	std	Y+17, r26	; 0x11
    411e:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4120:	6f 85       	ldd	r22, Y+15	; 0x0f
    4122:	78 89       	ldd	r23, Y+16	; 0x10
    4124:	89 89       	ldd	r24, Y+17	; 0x11
    4126:	9a 89       	ldd	r25, Y+18	; 0x12
    4128:	20 e0       	ldi	r18, 0x00	; 0
    412a:	30 e0       	ldi	r19, 0x00	; 0
    412c:	4a ef       	ldi	r20, 0xFA	; 250
    412e:	55 e4       	ldi	r21, 0x45	; 69
    4130:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    4134:	dc 01       	movw	r26, r24
    4136:	cb 01       	movw	r24, r22
    4138:	8b 8b       	std	Y+19, r24	; 0x13
    413a:	9c 8b       	std	Y+20, r25	; 0x14
    413c:	ad 8b       	std	Y+21, r26	; 0x15
    413e:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    4140:	11 e0       	ldi	r17, 0x01	; 1
    4142:	6b 89       	ldd	r22, Y+19	; 0x13
    4144:	7c 89       	ldd	r23, Y+20	; 0x14
    4146:	8d 89       	ldd	r24, Y+21	; 0x15
    4148:	9e 89       	ldd	r25, Y+22	; 0x16
    414a:	20 e0       	ldi	r18, 0x00	; 0
    414c:	30 e0       	ldi	r19, 0x00	; 0
    414e:	40 e8       	ldi	r20, 0x80	; 128
    4150:	5f e3       	ldi	r21, 0x3F	; 63
    4152:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    4156:	88 23       	and	r24, r24
    4158:	0c f0       	brlt	.+2      	; 0x415c <chb_write+0x1ce>
    415a:	10 e0       	ldi	r17, 0x00	; 0
    415c:	11 23       	and	r17, r17
    415e:	29 f0       	breq	.+10     	; 0x416a <chb_write+0x1dc>
		__ticks = 1;
    4160:	81 e0       	ldi	r24, 0x01	; 1
    4162:	90 e0       	ldi	r25, 0x00	; 0
    4164:	8f 8b       	std	Y+23, r24	; 0x17
    4166:	98 8f       	std	Y+24, r25	; 0x18
    4168:	46 c0       	rjmp	.+140    	; 0x41f6 <chb_write+0x268>
	else if (__tmp > 65535)
    416a:	11 e0       	ldi	r17, 0x01	; 1
    416c:	6b 89       	ldd	r22, Y+19	; 0x13
    416e:	7c 89       	ldd	r23, Y+20	; 0x14
    4170:	8d 89       	ldd	r24, Y+21	; 0x15
    4172:	9e 89       	ldd	r25, Y+22	; 0x16
    4174:	20 e0       	ldi	r18, 0x00	; 0
    4176:	3f ef       	ldi	r19, 0xFF	; 255
    4178:	4f e7       	ldi	r20, 0x7F	; 127
    417a:	57 e4       	ldi	r21, 0x47	; 71
    417c:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    4180:	18 16       	cp	r1, r24
    4182:	0c f0       	brlt	.+2      	; 0x4186 <chb_write+0x1f8>
    4184:	10 e0       	ldi	r17, 0x00	; 0
    4186:	11 23       	and	r17, r17
    4188:	61 f1       	breq	.+88     	; 0x41e2 <chb_write+0x254>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    418a:	6f 85       	ldd	r22, Y+15	; 0x0f
    418c:	78 89       	ldd	r23, Y+16	; 0x10
    418e:	89 89       	ldd	r24, Y+17	; 0x11
    4190:	9a 89       	ldd	r25, Y+18	; 0x12
    4192:	20 e0       	ldi	r18, 0x00	; 0
    4194:	30 e0       	ldi	r19, 0x00	; 0
    4196:	40 e2       	ldi	r20, 0x20	; 32
    4198:	51 e4       	ldi	r21, 0x41	; 65
    419a:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    419e:	dc 01       	movw	r26, r24
    41a0:	cb 01       	movw	r24, r22
    41a2:	bc 01       	movw	r22, r24
    41a4:	cd 01       	movw	r24, r26
    41a6:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    41aa:	dc 01       	movw	r26, r24
    41ac:	cb 01       	movw	r24, r22
    41ae:	8f 8b       	std	Y+23, r24	; 0x17
    41b0:	98 8f       	std	Y+24, r25	; 0x18
    41b2:	12 c0       	rjmp	.+36     	; 0x41d8 <chb_write+0x24a>
    41b4:	80 e2       	ldi	r24, 0x20	; 32
    41b6:	93 e0       	ldi	r25, 0x03	; 3
    41b8:	89 8f       	std	Y+25, r24	; 0x19
    41ba:	9a 8f       	std	Y+26, r25	; 0x1a
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    41bc:	89 8d       	ldd	r24, Y+25	; 0x19
    41be:	9a 8d       	ldd	r25, Y+26	; 0x1a
    41c0:	8c 01       	movw	r16, r24
    41c2:	c8 01       	movw	r24, r16
    41c4:	01 97       	sbiw	r24, 0x01	; 1
    41c6:	f1 f7       	brne	.-4      	; 0x41c4 <chb_write+0x236>
    41c8:	8c 01       	movw	r16, r24
    41ca:	09 8f       	std	Y+25, r16	; 0x19
    41cc:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    41ce:	8f 89       	ldd	r24, Y+23	; 0x17
    41d0:	98 8d       	ldd	r25, Y+24	; 0x18
    41d2:	01 97       	sbiw	r24, 0x01	; 1
    41d4:	8f 8b       	std	Y+23, r24	; 0x17
    41d6:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    41d8:	8f 89       	ldd	r24, Y+23	; 0x17
    41da:	98 8d       	ldd	r25, Y+24	; 0x18
    41dc:	00 97       	sbiw	r24, 0x00	; 0
    41de:	51 f7       	brne	.-44     	; 0x41b4 <chb_write+0x226>
    41e0:	28 c0       	rjmp	.+80     	; 0x4232 <chb_write+0x2a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    41e2:	6b 89       	ldd	r22, Y+19	; 0x13
    41e4:	7c 89       	ldd	r23, Y+20	; 0x14
    41e6:	8d 89       	ldd	r24, Y+21	; 0x15
    41e8:	9e 89       	ldd	r25, Y+22	; 0x16
    41ea:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    41ee:	dc 01       	movw	r26, r24
    41f0:	cb 01       	movw	r24, r22
    41f2:	8f 8b       	std	Y+23, r24	; 0x17
    41f4:	98 8f       	std	Y+24, r25	; 0x18
    41f6:	8f 89       	ldd	r24, Y+23	; 0x17
    41f8:	98 8d       	ldd	r25, Y+24	; 0x18
    41fa:	8b 8f       	std	Y+27, r24	; 0x1b
    41fc:	9c 8f       	std	Y+28, r25	; 0x1c
    41fe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4200:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4202:	8c 01       	movw	r16, r24
    4204:	c8 01       	movw	r24, r16
    4206:	01 97       	sbiw	r24, 0x01	; 1
    4208:	f1 f7       	brne	.-4      	; 0x4206 <chb_write+0x278>
    420a:	8c 01       	movw	r16, r24
    420c:	0b 8f       	std	Y+27, r16	; 0x1b
    420e:	1c 8f       	std	Y+28, r17	; 0x1c
    4210:	10 c0       	rjmp	.+32     	; 0x4232 <chb_write+0x2a4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4212:	6a 85       	ldd	r22, Y+10	; 0x0a
    4214:	7b 85       	ldd	r23, Y+11	; 0x0b
    4216:	8c 85       	ldd	r24, Y+12	; 0x0c
    4218:	9d 85       	ldd	r25, Y+13	; 0x0d
    421a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    421e:	dc 01       	movw	r26, r24
    4220:	cb 01       	movw	r24, r22
    4222:	8e 87       	std	Y+14, r24	; 0x0e
    4224:	8e 85       	ldd	r24, Y+14	; 0x0e
    4226:	8d 8f       	std	Y+29, r24	; 0x1d
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4228:	8d 8d       	ldd	r24, Y+29	; 0x1d
    422a:	18 2f       	mov	r17, r24
    422c:	1a 95       	dec	r17
    422e:	f1 f7       	brne	.-4      	; 0x422c <chb_write+0x29e>
    4230:	1d 8f       	std	Y+29, r17	; 0x1d
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    4232:	8a 81       	ldd	r24, Y+2	; 0x02
    4234:	9b 81       	ldd	r25, Y+3	; 0x03
    4236:	84 31       	cpi	r24, 0x14	; 20
    4238:	91 05       	cpc	r25, r1
    423a:	11 f4       	brne	.+4      	; 0x4240 <chb_write+0x2b2>
    423c:	8d 81       	ldd	r24, Y+5	; 0x05
    423e:	27 c0       	rjmp	.+78     	; 0x428e <chb_write+0x300>
		} while(status != CHB_SUCCESS);			
    4240:	8d 81       	ldd	r24, Y+5	; 0x05
    4242:	88 23       	and	r24, r24
    4244:	09 f0       	breq	.+2      	; 0x4248 <chb_write+0x2ba>
    4246:	d0 ce       	rjmp	.-608    	; 0x3fe8 <chb_write+0x5a>
        // adjust len and restart
		frm_offset += frm_len;
    4248:	99 81       	ldd	r25, Y+1	; 0x01
    424a:	8c 81       	ldd	r24, Y+4	; 0x04
    424c:	89 0f       	add	r24, r25
    424e:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    4250:	8c 81       	ldd	r24, Y+4	; 0x04
    4252:	88 2f       	mov	r24, r24
    4254:	90 e0       	ldi	r25, 0x00	; 0
    4256:	a0 e0       	ldi	r26, 0x00	; 0
    4258:	b0 e0       	ldi	r27, 0x00	; 0
    425a:	2c a5       	lds	r18, 0x6c
    425c:	3d a5       	lds	r19, 0x6d
    425e:	4e a5       	lds	r20, 0x6e
    4260:	5f a5       	lds	r21, 0x6f
    4262:	79 01       	movw	r14, r18
    4264:	8a 01       	movw	r16, r20
    4266:	e8 1a       	sub	r14, r24
    4268:	f9 0a       	sbc	r15, r25
    426a:	0a 0b       	sbc	r16, r26
    426c:	1b 0b       	sbc	r17, r27
    426e:	d8 01       	movw	r26, r16
    4270:	c7 01       	movw	r24, r14
    4272:	8c a7       	lds	r24, 0x7c
    4274:	9d a7       	lds	r25, 0x7d
    4276:	ae a7       	lds	r26, 0x7e
    4278:	bf a7       	lds	r27, 0x7f
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    427a:	8c a5       	lds	r24, 0x6c
    427c:	9d a5       	lds	r25, 0x6d
    427e:	ae a5       	lds	r26, 0x6e
    4280:	bf a5       	lds	r27, 0x6f
    4282:	00 97       	sbiw	r24, 0x00	; 0
    4284:	a1 05       	cpc	r26, r1
    4286:	b1 05       	cpc	r27, r1
    4288:	09 f0       	breq	.+2      	; 0x428c <chb_write+0x2fe>
    428a:	96 ce       	rjmp	.-724    	; 0x3fb8 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    428c:	80 e0       	ldi	r24, 0x00	; 0
}
    428e:	af 96       	adiw	r28, 0x2f	; 47
    4290:	cd bf       	out	0x3d, r28	; 61
    4292:	de bf       	out	0x3e, r29	; 62
    4294:	df 91       	pop	r29
    4296:	cf 91       	pop	r28
    4298:	1f 91       	pop	r17
    429a:	0f 91       	pop	r16
    429c:	ff 90       	pop	r15
    429e:	ef 90       	pop	r14
    42a0:	08 95       	ret

000042a2 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    42a2:	cf 93       	push	r28
    42a4:	df 93       	push	r29
    42a6:	cd b7       	in	r28, 0x3d	; 61
    42a8:	de b7       	in	r29, 0x3e	; 62
    42aa:	27 97       	sbiw	r28, 0x07	; 7
    42ac:	cd bf       	out	0x3d, r28	; 61
    42ae:	de bf       	out	0x3e, r29	; 62
    42b0:	8e 83       	std	Y+6, r24	; 0x06
    42b2:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    42b4:	8e 81       	ldd	r24, Y+6	; 0x06
    42b6:	9f 81       	ldd	r25, Y+7	; 0x07
    42b8:	05 96       	adiw	r24, 0x05	; 5
    42ba:	8a 83       	std	Y+2, r24	; 0x02
    42bc:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    42be:	0e 94 1e 22 	call	0x443c	; 0x443c <chb_buf_read>
    42c2:	8c 83       	std	Y+4, r24	; 0x04
    42c4:	8c 81       	ldd	r24, Y+4	; 0x04
    42c6:	88 23       	and	r24, r24
    42c8:	14 f4       	brge	.+4      	; 0x42ce <chb_read+0x2c>
    {
        return 0;
    42ca:	80 e0       	ldi	r24, 0x00	; 0
    42cc:	80 c0       	rjmp	.+256    	; 0x43ce <chb_read+0x12c>
    }
    *data_ptr++ = len;
    42ce:	8a 81       	ldd	r24, Y+2	; 0x02
    42d0:	9b 81       	ldd	r25, Y+3	; 0x03
    42d2:	2c 81       	ldd	r18, Y+4	; 0x04
    42d4:	fc 01       	movw	r30, r24
    42d6:	20 83       	st	Z, r18
    42d8:	8a 81       	ldd	r24, Y+2	; 0x02
    42da:	9b 81       	ldd	r25, Y+3	; 0x03
    42dc:	01 96       	adiw	r24, 0x01	; 1
    42de:	8a 83       	std	Y+2, r24	; 0x02
    42e0:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    42e2:	19 82       	std	Y+1, r1	; 0x01
    42e4:	0f c0       	rjmp	.+30     	; 0x4304 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    42e6:	0e 94 1e 22 	call	0x443c	; 0x443c <chb_buf_read>
    42ea:	28 2f       	mov	r18, r24
    42ec:	8a 81       	ldd	r24, Y+2	; 0x02
    42ee:	9b 81       	ldd	r25, Y+3	; 0x03
    42f0:	fc 01       	movw	r30, r24
    42f2:	20 83       	st	Z, r18
    42f4:	8a 81       	ldd	r24, Y+2	; 0x02
    42f6:	9b 81       	ldd	r25, Y+3	; 0x03
    42f8:	01 96       	adiw	r24, 0x01	; 1
    42fa:	8a 83       	std	Y+2, r24	; 0x02
    42fc:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    42fe:	89 81       	ldd	r24, Y+1	; 0x01
    4300:	8f 5f       	subi	r24, 0xFF	; 255
    4302:	89 83       	std	Y+1, r24	; 0x01
    4304:	99 81       	ldd	r25, Y+1	; 0x01
    4306:	8c 81       	ldd	r24, Y+4	; 0x04
    4308:	98 17       	cp	r25, r24
    430a:	68 f3       	brcs	.-38     	; 0x42e6 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    430c:	8e 81       	ldd	r24, Y+6	; 0x06
    430e:	9f 81       	ldd	r25, Y+7	; 0x07
    4310:	08 96       	adiw	r24, 0x08	; 8
    4312:	8a 83       	std	Y+2, r24	; 0x02
    4314:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4316:	8a 81       	ldd	r24, Y+2	; 0x02
    4318:	9b 81       	ldd	r25, Y+3	; 0x03
    431a:	fc 01       	movw	r30, r24
    431c:	80 81       	ld	r24, Z
    431e:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    4320:	8e 81       	ldd	r24, Y+6	; 0x06
    4322:	9f 81       	ldd	r25, Y+7	; 0x07
    4324:	0b 96       	adiw	r24, 0x0b	; 11
    4326:	8a 83       	std	Y+2, r24	; 0x02
    4328:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    432a:	8a 81       	ldd	r24, Y+2	; 0x02
    432c:	9b 81       	ldd	r25, Y+3	; 0x03
    432e:	fc 01       	movw	r30, r24
    4330:	20 81       	ld	r18, Z
    4332:	31 81       	ldd	r19, Z+1	; 0x01
    4334:	8e 81       	ldd	r24, Y+6	; 0x06
    4336:	9f 81       	ldd	r25, Y+7	; 0x07
    4338:	fc 01       	movw	r30, r24
    433a:	23 83       	std	Z+3, r18	; 0x03
    433c:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    433e:	8a 81       	ldd	r24, Y+2	; 0x02
    4340:	9b 81       	ldd	r25, Y+3	; 0x03
    4342:	02 96       	adiw	r24, 0x02	; 2
    4344:	8a 83       	std	Y+2, r24	; 0x02
    4346:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    4348:	8a 81       	ldd	r24, Y+2	; 0x02
    434a:	9b 81       	ldd	r25, Y+3	; 0x03
    434c:	fc 01       	movw	r30, r24
    434e:	20 81       	ld	r18, Z
    4350:	31 81       	ldd	r19, Z+1	; 0x01
    4352:	8e 81       	ldd	r24, Y+6	; 0x06
    4354:	9f 81       	ldd	r25, Y+7	; 0x07
    4356:	fc 01       	movw	r30, r24
    4358:	21 83       	std	Z+1, r18	; 0x01
    435a:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    435c:	8a 81       	ldd	r24, Y+2	; 0x02
    435e:	9b 81       	ldd	r25, Y+3	; 0x03
    4360:	02 96       	adiw	r24, 0x02	; 2
    4362:	8a 83       	std	Y+2, r24	; 0x02
    4364:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    4366:	0e 94 42 22 	call	0x4484	; 0x4484 <chb_buf_get_len>
    436a:	88 23       	and	r24, r24
    436c:	11 f4       	brne	.+4      	; 0x4372 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    436e:	10 92 33 21 	sts	0x2133, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    4372:	80 91 06 20 	lds	r24, 0x2006
    4376:	9d 81       	ldd	r25, Y+5	; 0x05
    4378:	98 17       	cp	r25, r24
    437a:	71 f4       	brne	.+28     	; 0x4398 <chb_read+0xf6>
    437c:	8e 81       	ldd	r24, Y+6	; 0x06
    437e:	9f 81       	ldd	r25, Y+7	; 0x07
    4380:	fc 01       	movw	r30, r24
    4382:	21 81       	ldd	r18, Z+1	; 0x01
    4384:	32 81       	ldd	r19, Z+2	; 0x02
    4386:	80 91 07 20 	lds	r24, 0x2007
    438a:	90 91 08 20 	lds	r25, 0x2008
    438e:	28 17       	cp	r18, r24
    4390:	39 07       	cpc	r19, r25
    4392:	11 f4       	brne	.+4      	; 0x4398 <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    4394:	80 e0       	ldi	r24, 0x00	; 0
    4396:	1b c0       	rjmp	.+54     	; 0x43ce <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    4398:	8d 81       	ldd	r24, Y+5	; 0x05
    439a:	80 93 06 20 	sts	0x2006, r24
        prev_src_addr = rx->src_addr;
    439e:	8e 81       	ldd	r24, Y+6	; 0x06
    43a0:	9f 81       	ldd	r25, Y+7	; 0x07
    43a2:	fc 01       	movw	r30, r24
    43a4:	81 81       	ldd	r24, Z+1	; 0x01
    43a6:	92 81       	ldd	r25, Z+2	; 0x02
    43a8:	80 93 07 20 	sts	0x2007, r24
    43ac:	90 93 08 20 	sts	0x2008, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    43b0:	8c 81       	ldd	r24, Y+4	; 0x04
    43b2:	88 2f       	mov	r24, r24
    43b4:	90 e0       	ldi	r25, 0x00	; 0
    43b6:	09 97       	sbiw	r24, 0x09	; 9
    43b8:	9c 01       	movw	r18, r24
    43ba:	8e 81       	ldd	r24, Y+6	; 0x06
    43bc:	9f 81       	ldd	r25, Y+7	; 0x07
    43be:	4a 81       	ldd	r20, Y+2	; 0x02
    43c0:	5b 81       	ldd	r21, Y+3	; 0x03
    43c2:	ba 01       	movw	r22, r20
    43c4:	a9 01       	movw	r20, r18
    43c6:	0e 94 35 5e 	call	0xbc6a	; 0xbc6a <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    43ca:	8c 81       	ldd	r24, Y+4	; 0x04
    43cc:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    43ce:	27 96       	adiw	r28, 0x07	; 7
    43d0:	cd bf       	out	0x3d, r28	; 61
    43d2:	de bf       	out	0x3e, r29	; 62
    43d4:	df 91       	pop	r29
    43d6:	cf 91       	pop	r28
    43d8:	08 95       	ret

000043da <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    43da:	cf 93       	push	r28
    43dc:	df 93       	push	r29
    43de:	cd b7       	in	r28, 0x3d	; 61
    43e0:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    43e2:	10 92 c4 21 	sts	0x21C4, r1
    wr_ptr = 0;
    43e6:	10 92 c5 21 	sts	0x21C5, r1
    len = 0;
    43ea:	10 92 c6 21 	sts	0x21C6, r1
}
    43ee:	df 91       	pop	r29
    43f0:	cf 91       	pop	r28
    43f2:	08 95       	ret

000043f4 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    43f4:	cf 93       	push	r28
    43f6:	df 93       	push	r29
    43f8:	0f 92       	push	r0
    43fa:	cd b7       	in	r28, 0x3d	; 61
    43fc:	de b7       	in	r29, 0x3e	; 62
    43fe:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4400:	80 91 c5 21 	lds	r24, 0x21C5
    4404:	88 2f       	mov	r24, r24
    4406:	90 e0       	ldi	r25, 0x00	; 0
    4408:	8c 5b       	subi	r24, 0xBC	; 188
    440a:	9e 4d       	sbci	r25, 0xDE	; 222
    440c:	29 81       	ldd	r18, Y+1	; 0x01
    440e:	fc 01       	movw	r30, r24
    4410:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4412:	80 91 c5 21 	lds	r24, 0x21C5
    4416:	88 2f       	mov	r24, r24
    4418:	90 e0       	ldi	r25, 0x00	; 0
    441a:	01 96       	adiw	r24, 0x01	; 1
    441c:	20 e8       	ldi	r18, 0x80	; 128
    441e:	30 e0       	ldi	r19, 0x00	; 0
    4420:	b9 01       	movw	r22, r18
    4422:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    4426:	80 93 c5 21 	sts	0x21C5, r24
    len++;
    442a:	80 91 c6 21 	lds	r24, 0x21C6
    442e:	8f 5f       	subi	r24, 0xFF	; 255
    4430:	80 93 c6 21 	sts	0x21C6, r24
}
    4434:	0f 90       	pop	r0
    4436:	df 91       	pop	r29
    4438:	cf 91       	pop	r28
    443a:	08 95       	ret

0000443c <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    443c:	cf 93       	push	r28
    443e:	df 93       	push	r29
    4440:	0f 92       	push	r0
    4442:	cd b7       	in	r28, 0x3d	; 61
    4444:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    4446:	80 91 c4 21 	lds	r24, 0x21C4
    444a:	88 2f       	mov	r24, r24
    444c:	90 e0       	ldi	r25, 0x00	; 0
    444e:	8c 5b       	subi	r24, 0xBC	; 188
    4450:	9e 4d       	sbci	r25, 0xDE	; 222
    4452:	fc 01       	movw	r30, r24
    4454:	80 81       	ld	r24, Z
    4456:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    4458:	80 91 c4 21 	lds	r24, 0x21C4
    445c:	88 2f       	mov	r24, r24
    445e:	90 e0       	ldi	r25, 0x00	; 0
    4460:	01 96       	adiw	r24, 0x01	; 1
    4462:	20 e8       	ldi	r18, 0x80	; 128
    4464:	30 e0       	ldi	r19, 0x00	; 0
    4466:	b9 01       	movw	r22, r18
    4468:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    446c:	80 93 c4 21 	sts	0x21C4, r24
    len--;
    4470:	80 91 c6 21 	lds	r24, 0x21C6
    4474:	81 50       	subi	r24, 0x01	; 1
    4476:	80 93 c6 21 	sts	0x21C6, r24
    return data;
    447a:	89 81       	ldd	r24, Y+1	; 0x01
}
    447c:	0f 90       	pop	r0
    447e:	df 91       	pop	r29
    4480:	cf 91       	pop	r28
    4482:	08 95       	ret

00004484 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    4484:	cf 93       	push	r28
    4486:	df 93       	push	r29
    4488:	cd b7       	in	r28, 0x3d	; 61
    448a:	de b7       	in	r29, 0x3e	; 62
    return len;
    448c:	80 91 c6 21 	lds	r24, 0x21C6
}
    4490:	df 91       	pop	r29
    4492:	cf 91       	pop	r28
    4494:	08 95       	ret

00004496 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    4496:	cf 93       	push	r28
    4498:	df 93       	push	r29
    449a:	cd b7       	in	r28, 0x3d	; 61
    449c:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    449e:	81 e0       	ldi	r24, 0x01	; 1
    44a0:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    44a4:	8f 71       	andi	r24, 0x1F	; 31
}
    44a6:	df 91       	pop	r29
    44a8:	cf 91       	pop	r28
    44aa:	08 95       	ret

000044ac <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    44ac:	cf 93       	push	r28
    44ae:	df 93       	push	r29
    44b0:	cd b7       	in	r28, 0x3d	; 61
    44b2:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    44b4:	82 e0       	ldi	r24, 0x02	; 2
    44b6:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    44ba:	82 95       	swap	r24
    44bc:	86 95       	lsr	r24
    44be:	87 70       	andi	r24, 0x07	; 7
}
    44c0:	df 91       	pop	r29
    44c2:	cf 91       	pop	r28
    44c4:	08 95       	ret

000044c6 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    44c6:	0f 93       	push	r16
    44c8:	1f 93       	push	r17
    44ca:	cf 93       	push	r28
    44cc:	df 93       	push	r29
    44ce:	cd b7       	in	r28, 0x3d	; 61
    44d0:	de b7       	in	r29, 0x3e	; 62
    44d2:	e0 97       	sbiw	r28, 0x30	; 48
    44d4:	cd bf       	out	0x3d, r28	; 61
    44d6:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    44d8:	84 e6       	ldi	r24, 0x64	; 100
    44da:	96 e0       	ldi	r25, 0x06	; 6
    44dc:	24 e6       	ldi	r18, 0x64	; 100
    44de:	36 e0       	ldi	r19, 0x06	; 6
    44e0:	f9 01       	movw	r30, r18
    44e2:	20 81       	ld	r18, Z
    44e4:	21 60       	ori	r18, 0x01	; 1
    44e6:	fc 01       	movw	r30, r24
    44e8:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    44ea:	84 e6       	ldi	r24, 0x64	; 100
    44ec:	96 e0       	ldi	r25, 0x06	; 6
    44ee:	24 e6       	ldi	r18, 0x64	; 100
    44f0:	36 e0       	ldi	r19, 0x06	; 6
    44f2:	f9 01       	movw	r30, r18
    44f4:	20 81       	ld	r18, Z
    44f6:	2d 7f       	andi	r18, 0xFD	; 253
    44f8:	fc 01       	movw	r30, r24
    44fa:	20 83       	st	Z, r18
    44fc:	80 e0       	ldi	r24, 0x00	; 0
    44fe:	90 e0       	ldi	r25, 0x00	; 0
    4500:	ae eb       	ldi	r26, 0xBE	; 190
    4502:	b3 e4       	ldi	r27, 0x43	; 67
    4504:	89 83       	std	Y+1, r24	; 0x01
    4506:	9a 83       	std	Y+2, r25	; 0x02
    4508:	ab 83       	std	Y+3, r26	; 0x03
    450a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    450c:	69 81       	ldd	r22, Y+1	; 0x01
    450e:	7a 81       	ldd	r23, Y+2	; 0x02
    4510:	8b 81       	ldd	r24, Y+3	; 0x03
    4512:	9c 81       	ldd	r25, Y+4	; 0x04
    4514:	2b ea       	ldi	r18, 0xAB	; 171
    4516:	3a ea       	ldi	r19, 0xAA	; 170
    4518:	4a e2       	ldi	r20, 0x2A	; 42
    451a:	51 e4       	ldi	r21, 0x41	; 65
    451c:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    4520:	dc 01       	movw	r26, r24
    4522:	cb 01       	movw	r24, r22
    4524:	8d 83       	std	Y+5, r24	; 0x05
    4526:	9e 83       	std	Y+6, r25	; 0x06
    4528:	af 83       	std	Y+7, r26	; 0x07
    452a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    452c:	11 e0       	ldi	r17, 0x01	; 1
    452e:	6d 81       	ldd	r22, Y+5	; 0x05
    4530:	7e 81       	ldd	r23, Y+6	; 0x06
    4532:	8f 81       	ldd	r24, Y+7	; 0x07
    4534:	98 85       	ldd	r25, Y+8	; 0x08
    4536:	20 e0       	ldi	r18, 0x00	; 0
    4538:	30 e0       	ldi	r19, 0x00	; 0
    453a:	40 e8       	ldi	r20, 0x80	; 128
    453c:	5f e3       	ldi	r21, 0x3F	; 63
    453e:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    4542:	88 23       	and	r24, r24
    4544:	0c f0       	brlt	.+2      	; 0x4548 <chb_reset+0x82>
    4546:	10 e0       	ldi	r17, 0x00	; 0
    4548:	11 23       	and	r17, r17
    454a:	19 f0       	breq	.+6      	; 0x4552 <chb_reset+0x8c>
		__ticks = 1;
    454c:	81 e0       	ldi	r24, 0x01	; 1
    454e:	89 87       	std	Y+9, r24	; 0x09
    4550:	a3 c0       	rjmp	.+326    	; 0x4698 <chb_reset+0x1d2>
	else if (__tmp > 255)
    4552:	11 e0       	ldi	r17, 0x01	; 1
    4554:	6d 81       	ldd	r22, Y+5	; 0x05
    4556:	7e 81       	ldd	r23, Y+6	; 0x06
    4558:	8f 81       	ldd	r24, Y+7	; 0x07
    455a:	98 85       	ldd	r25, Y+8	; 0x08
    455c:	20 e0       	ldi	r18, 0x00	; 0
    455e:	30 e0       	ldi	r19, 0x00	; 0
    4560:	4f e7       	ldi	r20, 0x7F	; 127
    4562:	53 e4       	ldi	r21, 0x43	; 67
    4564:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    4568:	18 16       	cp	r1, r24
    456a:	0c f0       	brlt	.+2      	; 0x456e <chb_reset+0xa8>
    456c:	10 e0       	ldi	r17, 0x00	; 0
    456e:	11 23       	and	r17, r17
    4570:	09 f4       	brne	.+2      	; 0x4574 <chb_reset+0xae>
    4572:	89 c0       	rjmp	.+274    	; 0x4686 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    4574:	69 81       	ldd	r22, Y+1	; 0x01
    4576:	7a 81       	ldd	r23, Y+2	; 0x02
    4578:	8b 81       	ldd	r24, Y+3	; 0x03
    457a:	9c 81       	ldd	r25, Y+4	; 0x04
    457c:	20 e0       	ldi	r18, 0x00	; 0
    457e:	30 e0       	ldi	r19, 0x00	; 0
    4580:	4a e7       	ldi	r20, 0x7A	; 122
    4582:	54 e4       	ldi	r21, 0x44	; 68
    4584:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    4588:	dc 01       	movw	r26, r24
    458a:	cb 01       	movw	r24, r22
    458c:	8a 87       	std	Y+10, r24	; 0x0a
    458e:	9b 87       	std	Y+11, r25	; 0x0b
    4590:	ac 87       	std	Y+12, r26	; 0x0c
    4592:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4594:	6a 85       	ldd	r22, Y+10	; 0x0a
    4596:	7b 85       	ldd	r23, Y+11	; 0x0b
    4598:	8c 85       	ldd	r24, Y+12	; 0x0c
    459a:	9d 85       	ldd	r25, Y+13	; 0x0d
    459c:	20 e0       	ldi	r18, 0x00	; 0
    459e:	30 e0       	ldi	r19, 0x00	; 0
    45a0:	4a ef       	ldi	r20, 0xFA	; 250
    45a2:	55 e4       	ldi	r21, 0x45	; 69
    45a4:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    45a8:	dc 01       	movw	r26, r24
    45aa:	cb 01       	movw	r24, r22
    45ac:	8e 87       	std	Y+14, r24	; 0x0e
    45ae:	9f 87       	std	Y+15, r25	; 0x0f
    45b0:	a8 8b       	std	Y+16, r26	; 0x10
    45b2:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    45b4:	11 e0       	ldi	r17, 0x01	; 1
    45b6:	6e 85       	ldd	r22, Y+14	; 0x0e
    45b8:	7f 85       	ldd	r23, Y+15	; 0x0f
    45ba:	88 89       	ldd	r24, Y+16	; 0x10
    45bc:	99 89       	ldd	r25, Y+17	; 0x11
    45be:	20 e0       	ldi	r18, 0x00	; 0
    45c0:	30 e0       	ldi	r19, 0x00	; 0
    45c2:	40 e8       	ldi	r20, 0x80	; 128
    45c4:	5f e3       	ldi	r21, 0x3F	; 63
    45c6:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    45ca:	88 23       	and	r24, r24
    45cc:	0c f0       	brlt	.+2      	; 0x45d0 <chb_reset+0x10a>
    45ce:	10 e0       	ldi	r17, 0x00	; 0
    45d0:	11 23       	and	r17, r17
    45d2:	29 f0       	breq	.+10     	; 0x45de <chb_reset+0x118>
		__ticks = 1;
    45d4:	81 e0       	ldi	r24, 0x01	; 1
    45d6:	90 e0       	ldi	r25, 0x00	; 0
    45d8:	8a 8b       	std	Y+18, r24	; 0x12
    45da:	9b 8b       	std	Y+19, r25	; 0x13
    45dc:	46 c0       	rjmp	.+140    	; 0x466a <chb_reset+0x1a4>
	else if (__tmp > 65535)
    45de:	11 e0       	ldi	r17, 0x01	; 1
    45e0:	6e 85       	ldd	r22, Y+14	; 0x0e
    45e2:	7f 85       	ldd	r23, Y+15	; 0x0f
    45e4:	88 89       	ldd	r24, Y+16	; 0x10
    45e6:	99 89       	ldd	r25, Y+17	; 0x11
    45e8:	20 e0       	ldi	r18, 0x00	; 0
    45ea:	3f ef       	ldi	r19, 0xFF	; 255
    45ec:	4f e7       	ldi	r20, 0x7F	; 127
    45ee:	57 e4       	ldi	r21, 0x47	; 71
    45f0:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    45f4:	18 16       	cp	r1, r24
    45f6:	0c f0       	brlt	.+2      	; 0x45fa <chb_reset+0x134>
    45f8:	10 e0       	ldi	r17, 0x00	; 0
    45fa:	11 23       	and	r17, r17
    45fc:	61 f1       	breq	.+88     	; 0x4656 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    45fe:	6a 85       	ldd	r22, Y+10	; 0x0a
    4600:	7b 85       	ldd	r23, Y+11	; 0x0b
    4602:	8c 85       	ldd	r24, Y+12	; 0x0c
    4604:	9d 85       	ldd	r25, Y+13	; 0x0d
    4606:	20 e0       	ldi	r18, 0x00	; 0
    4608:	30 e0       	ldi	r19, 0x00	; 0
    460a:	40 e2       	ldi	r20, 0x20	; 32
    460c:	51 e4       	ldi	r21, 0x41	; 65
    460e:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    4612:	dc 01       	movw	r26, r24
    4614:	cb 01       	movw	r24, r22
    4616:	bc 01       	movw	r22, r24
    4618:	cd 01       	movw	r24, r26
    461a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    461e:	dc 01       	movw	r26, r24
    4620:	cb 01       	movw	r24, r22
    4622:	8a 8b       	std	Y+18, r24	; 0x12
    4624:	9b 8b       	std	Y+19, r25	; 0x13
    4626:	12 c0       	rjmp	.+36     	; 0x464c <chb_reset+0x186>
    4628:	80 e2       	ldi	r24, 0x20	; 32
    462a:	93 e0       	ldi	r25, 0x03	; 3
    462c:	8c 8b       	std	Y+20, r24	; 0x14
    462e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4630:	8c 89       	ldd	r24, Y+20	; 0x14
    4632:	9d 89       	ldd	r25, Y+21	; 0x15
    4634:	8c 01       	movw	r16, r24
    4636:	c8 01       	movw	r24, r16
    4638:	01 97       	sbiw	r24, 0x01	; 1
    463a:	f1 f7       	brne	.-4      	; 0x4638 <chb_reset+0x172>
    463c:	8c 01       	movw	r16, r24
    463e:	0c 8b       	std	Y+20, r16	; 0x14
    4640:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4642:	8a 89       	ldd	r24, Y+18	; 0x12
    4644:	9b 89       	ldd	r25, Y+19	; 0x13
    4646:	01 97       	sbiw	r24, 0x01	; 1
    4648:	8a 8b       	std	Y+18, r24	; 0x12
    464a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    464c:	8a 89       	ldd	r24, Y+18	; 0x12
    464e:	9b 89       	ldd	r25, Y+19	; 0x13
    4650:	00 97       	sbiw	r24, 0x00	; 0
    4652:	51 f7       	brne	.-44     	; 0x4628 <chb_reset+0x162>
    4654:	28 c0       	rjmp	.+80     	; 0x46a6 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4656:	6e 85       	ldd	r22, Y+14	; 0x0e
    4658:	7f 85       	ldd	r23, Y+15	; 0x0f
    465a:	88 89       	ldd	r24, Y+16	; 0x10
    465c:	99 89       	ldd	r25, Y+17	; 0x11
    465e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    4662:	dc 01       	movw	r26, r24
    4664:	cb 01       	movw	r24, r22
    4666:	8a 8b       	std	Y+18, r24	; 0x12
    4668:	9b 8b       	std	Y+19, r25	; 0x13
    466a:	8a 89       	ldd	r24, Y+18	; 0x12
    466c:	9b 89       	ldd	r25, Y+19	; 0x13
    466e:	8e 8b       	std	Y+22, r24	; 0x16
    4670:	9f 8b       	std	Y+23, r25	; 0x17
    4672:	8e 89       	ldd	r24, Y+22	; 0x16
    4674:	9f 89       	ldd	r25, Y+23	; 0x17
    4676:	8c 01       	movw	r16, r24
    4678:	f8 01       	movw	r30, r16
    467a:	31 97       	sbiw	r30, 0x01	; 1
    467c:	f1 f7       	brne	.-4      	; 0x467a <chb_reset+0x1b4>
    467e:	8f 01       	movw	r16, r30
    4680:	0e 8b       	std	Y+22, r16	; 0x16
    4682:	1f 8b       	std	Y+23, r17	; 0x17
    4684:	10 c0       	rjmp	.+32     	; 0x46a6 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4686:	6d 81       	ldd	r22, Y+5	; 0x05
    4688:	7e 81       	ldd	r23, Y+6	; 0x06
    468a:	8f 81       	ldd	r24, Y+7	; 0x07
    468c:	98 85       	ldd	r25, Y+8	; 0x08
    468e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    4692:	dc 01       	movw	r26, r24
    4694:	cb 01       	movw	r24, r22
    4696:	89 87       	std	Y+9, r24	; 0x09
    4698:	89 85       	ldd	r24, Y+9	; 0x09
    469a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    469c:	88 8d       	ldd	r24, Y+24	; 0x18
    469e:	18 2f       	mov	r17, r24
    46a0:	1a 95       	dec	r17
    46a2:	f1 f7       	brne	.-4      	; 0x46a0 <chb_reset+0x1da>
    46a4:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    46a6:	84 e6       	ldi	r24, 0x64	; 100
    46a8:	96 e0       	ldi	r25, 0x06	; 6
    46aa:	24 e6       	ldi	r18, 0x64	; 100
    46ac:	36 e0       	ldi	r19, 0x06	; 6
    46ae:	f9 01       	movw	r30, r18
    46b0:	20 81       	ld	r18, Z
    46b2:	2e 7f       	andi	r18, 0xFE	; 254
    46b4:	fc 01       	movw	r30, r24
    46b6:	20 83       	st	Z, r18
    46b8:	80 e0       	ldi	r24, 0x00	; 0
    46ba:	90 e0       	ldi	r25, 0x00	; 0
    46bc:	a0 e8       	ldi	r26, 0x80	; 128
    46be:	bf e3       	ldi	r27, 0x3F	; 63
    46c0:	89 8f       	std	Y+25, r24	; 0x19
    46c2:	9a 8f       	std	Y+26, r25	; 0x1a
    46c4:	ab 8f       	std	Y+27, r26	; 0x1b
    46c6:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    46c8:	69 8d       	ldd	r22, Y+25	; 0x19
    46ca:	7a 8d       	ldd	r23, Y+26	; 0x1a
    46cc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    46ce:	9c 8d       	ldd	r25, Y+28	; 0x1c
    46d0:	2b ea       	ldi	r18, 0xAB	; 171
    46d2:	3a ea       	ldi	r19, 0xAA	; 170
    46d4:	4a e2       	ldi	r20, 0x2A	; 42
    46d6:	51 e4       	ldi	r21, 0x41	; 65
    46d8:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    46dc:	dc 01       	movw	r26, r24
    46de:	cb 01       	movw	r24, r22
    46e0:	8d 8f       	std	Y+29, r24	; 0x1d
    46e2:	9e 8f       	std	Y+30, r25	; 0x1e
    46e4:	af 8f       	std	Y+31, r26	; 0x1f
    46e6:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    46e8:	11 e0       	ldi	r17, 0x01	; 1
    46ea:	6d 8d       	ldd	r22, Y+29	; 0x1d
    46ec:	7e 8d       	ldd	r23, Y+30	; 0x1e
    46ee:	8f 8d       	ldd	r24, Y+31	; 0x1f
    46f0:	98 a1       	lds	r25, 0x48
    46f2:	20 e0       	ldi	r18, 0x00	; 0
    46f4:	30 e0       	ldi	r19, 0x00	; 0
    46f6:	40 e8       	ldi	r20, 0x80	; 128
    46f8:	5f e3       	ldi	r21, 0x3F	; 63
    46fa:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    46fe:	88 23       	and	r24, r24
    4700:	0c f0       	brlt	.+2      	; 0x4704 <chb_reset+0x23e>
    4702:	10 e0       	ldi	r17, 0x00	; 0
    4704:	11 23       	and	r17, r17
    4706:	19 f0       	breq	.+6      	; 0x470e <chb_reset+0x248>
		__ticks = 1;
    4708:	81 e0       	ldi	r24, 0x01	; 1
    470a:	89 a3       	lds	r24, 0x59
    470c:	a3 c0       	rjmp	.+326    	; 0x4854 <chb_reset+0x38e>
	else if (__tmp > 255)
    470e:	11 e0       	ldi	r17, 0x01	; 1
    4710:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4712:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4714:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4716:	98 a1       	lds	r25, 0x48
    4718:	20 e0       	ldi	r18, 0x00	; 0
    471a:	30 e0       	ldi	r19, 0x00	; 0
    471c:	4f e7       	ldi	r20, 0x7F	; 127
    471e:	53 e4       	ldi	r21, 0x43	; 67
    4720:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    4724:	18 16       	cp	r1, r24
    4726:	0c f0       	brlt	.+2      	; 0x472a <chb_reset+0x264>
    4728:	10 e0       	ldi	r17, 0x00	; 0
    472a:	11 23       	and	r17, r17
    472c:	09 f4       	brne	.+2      	; 0x4730 <chb_reset+0x26a>
    472e:	89 c0       	rjmp	.+274    	; 0x4842 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    4730:	69 8d       	ldd	r22, Y+25	; 0x19
    4732:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4734:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4736:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4738:	20 e0       	ldi	r18, 0x00	; 0
    473a:	30 e0       	ldi	r19, 0x00	; 0
    473c:	4a e7       	ldi	r20, 0x7A	; 122
    473e:	54 e4       	ldi	r21, 0x44	; 68
    4740:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    4744:	dc 01       	movw	r26, r24
    4746:	cb 01       	movw	r24, r22
    4748:	8a a3       	lds	r24, 0x5a
    474a:	9b a3       	lds	r25, 0x5b
    474c:	ac a3       	lds	r26, 0x5c
    474e:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4750:	6a a1       	lds	r22, 0x4a
    4752:	7b a1       	lds	r23, 0x4b
    4754:	8c a1       	lds	r24, 0x4c
    4756:	9d a1       	lds	r25, 0x4d
    4758:	20 e0       	ldi	r18, 0x00	; 0
    475a:	30 e0       	ldi	r19, 0x00	; 0
    475c:	4a ef       	ldi	r20, 0xFA	; 250
    475e:	55 e4       	ldi	r21, 0x45	; 69
    4760:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    4764:	dc 01       	movw	r26, r24
    4766:	cb 01       	movw	r24, r22
    4768:	8e a3       	lds	r24, 0x5e
    476a:	9f a3       	lds	r25, 0x5f
    476c:	a8 a7       	lds	r26, 0x78
    476e:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    4770:	11 e0       	ldi	r17, 0x01	; 1
    4772:	6e a1       	lds	r22, 0x4e
    4774:	7f a1       	lds	r23, 0x4f
    4776:	88 a5       	lds	r24, 0x68
    4778:	99 a5       	lds	r25, 0x69
    477a:	20 e0       	ldi	r18, 0x00	; 0
    477c:	30 e0       	ldi	r19, 0x00	; 0
    477e:	40 e8       	ldi	r20, 0x80	; 128
    4780:	5f e3       	ldi	r21, 0x3F	; 63
    4782:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    4786:	88 23       	and	r24, r24
    4788:	0c f0       	brlt	.+2      	; 0x478c <chb_reset+0x2c6>
    478a:	10 e0       	ldi	r17, 0x00	; 0
    478c:	11 23       	and	r17, r17
    478e:	29 f0       	breq	.+10     	; 0x479a <chb_reset+0x2d4>
		__ticks = 1;
    4790:	81 e0       	ldi	r24, 0x01	; 1
    4792:	90 e0       	ldi	r25, 0x00	; 0
    4794:	8a a7       	lds	r24, 0x7a
    4796:	9b a7       	lds	r25, 0x7b
    4798:	46 c0       	rjmp	.+140    	; 0x4826 <chb_reset+0x360>
	else if (__tmp > 65535)
    479a:	11 e0       	ldi	r17, 0x01	; 1
    479c:	6e a1       	lds	r22, 0x4e
    479e:	7f a1       	lds	r23, 0x4f
    47a0:	88 a5       	lds	r24, 0x68
    47a2:	99 a5       	lds	r25, 0x69
    47a4:	20 e0       	ldi	r18, 0x00	; 0
    47a6:	3f ef       	ldi	r19, 0xFF	; 255
    47a8:	4f e7       	ldi	r20, 0x7F	; 127
    47aa:	57 e4       	ldi	r21, 0x47	; 71
    47ac:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    47b0:	18 16       	cp	r1, r24
    47b2:	0c f0       	brlt	.+2      	; 0x47b6 <chb_reset+0x2f0>
    47b4:	10 e0       	ldi	r17, 0x00	; 0
    47b6:	11 23       	and	r17, r17
    47b8:	61 f1       	breq	.+88     	; 0x4812 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    47ba:	6a a1       	lds	r22, 0x4a
    47bc:	7b a1       	lds	r23, 0x4b
    47be:	8c a1       	lds	r24, 0x4c
    47c0:	9d a1       	lds	r25, 0x4d
    47c2:	20 e0       	ldi	r18, 0x00	; 0
    47c4:	30 e0       	ldi	r19, 0x00	; 0
    47c6:	40 e2       	ldi	r20, 0x20	; 32
    47c8:	51 e4       	ldi	r21, 0x41	; 65
    47ca:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    47ce:	dc 01       	movw	r26, r24
    47d0:	cb 01       	movw	r24, r22
    47d2:	bc 01       	movw	r22, r24
    47d4:	cd 01       	movw	r24, r26
    47d6:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    47da:	dc 01       	movw	r26, r24
    47dc:	cb 01       	movw	r24, r22
    47de:	8a a7       	lds	r24, 0x7a
    47e0:	9b a7       	lds	r25, 0x7b
    47e2:	12 c0       	rjmp	.+36     	; 0x4808 <chb_reset+0x342>
    47e4:	80 e2       	ldi	r24, 0x20	; 32
    47e6:	93 e0       	ldi	r25, 0x03	; 3
    47e8:	8c a7       	lds	r24, 0x7c
    47ea:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    47ec:	8c a5       	lds	r24, 0x6c
    47ee:	9d a5       	lds	r25, 0x6d
    47f0:	8c 01       	movw	r16, r24
    47f2:	c8 01       	movw	r24, r16
    47f4:	01 97       	sbiw	r24, 0x01	; 1
    47f6:	f1 f7       	brne	.-4      	; 0x47f4 <chb_reset+0x32e>
    47f8:	8c 01       	movw	r16, r24
    47fa:	0c a7       	lds	r16, 0x7c
    47fc:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    47fe:	8a a5       	lds	r24, 0x6a
    4800:	9b a5       	lds	r25, 0x6b
    4802:	01 97       	sbiw	r24, 0x01	; 1
    4804:	8a a7       	lds	r24, 0x7a
    4806:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4808:	8a a5       	lds	r24, 0x6a
    480a:	9b a5       	lds	r25, 0x6b
    480c:	00 97       	sbiw	r24, 0x00	; 0
    480e:	51 f7       	brne	.-44     	; 0x47e4 <chb_reset+0x31e>
    4810:	28 c0       	rjmp	.+80     	; 0x4862 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4812:	6e a1       	lds	r22, 0x4e
    4814:	7f a1       	lds	r23, 0x4f
    4816:	88 a5       	lds	r24, 0x68
    4818:	99 a5       	lds	r25, 0x69
    481a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    481e:	dc 01       	movw	r26, r24
    4820:	cb 01       	movw	r24, r22
    4822:	8a a7       	lds	r24, 0x7a
    4824:	9b a7       	lds	r25, 0x7b
    4826:	8a a5       	lds	r24, 0x6a
    4828:	9b a5       	lds	r25, 0x6b
    482a:	8e a7       	lds	r24, 0x7e
    482c:	9f a7       	lds	r25, 0x7f
    482e:	8e a5       	lds	r24, 0x6e
    4830:	9f a5       	lds	r25, 0x6f
    4832:	8c 01       	movw	r16, r24
    4834:	f8 01       	movw	r30, r16
    4836:	31 97       	sbiw	r30, 0x01	; 1
    4838:	f1 f7       	brne	.-4      	; 0x4836 <chb_reset+0x370>
    483a:	8f 01       	movw	r16, r30
    483c:	0e a7       	lds	r16, 0x7e
    483e:	1f a7       	lds	r17, 0x7f
    4840:	10 c0       	rjmp	.+32     	; 0x4862 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4842:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4844:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4846:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4848:	98 a1       	lds	r25, 0x48
    484a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    484e:	dc 01       	movw	r26, r24
    4850:	cb 01       	movw	r24, r22
    4852:	89 a3       	lds	r24, 0x59
    4854:	89 a1       	lds	r24, 0x49
    4856:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4858:	88 a9       	sts	0x48, r24
    485a:	18 2f       	mov	r17, r24
    485c:	1a 95       	dec	r17
    485e:	f1 f7       	brne	.-4      	; 0x485c <chb_reset+0x396>
    4860:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4862:	84 e6       	ldi	r24, 0x64	; 100
    4864:	96 e0       	ldi	r25, 0x06	; 6
    4866:	24 e6       	ldi	r18, 0x64	; 100
    4868:	36 e0       	ldi	r19, 0x06	; 6
    486a:	f9 01       	movw	r30, r18
    486c:	20 81       	ld	r18, Z
    486e:	21 60       	ori	r18, 0x01	; 1
    4870:	fc 01       	movw	r30, r24
    4872:	20 83       	st	Z, r18
    4874:	01 c0       	rjmp	.+2      	; 0x4878 <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4876:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    4878:	8d e1       	ldi	r24, 0x1D	; 29
    487a:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    487e:	81 30       	cpi	r24, 0x01	; 1
    4880:	d1 f7       	brne	.-12     	; 0x4876 <chb_reset+0x3b0>
    4882:	8c e1       	ldi	r24, 0x1C	; 28
    4884:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    4888:	87 30       	cpi	r24, 0x07	; 7
    488a:	a9 f7       	brne	.-22     	; 0x4876 <chb_reset+0x3b0>
        {
            break;
    488c:	00 00       	nop
        }
    }
	

}
    488e:	e0 96       	adiw	r28, 0x30	; 48
    4890:	cd bf       	out	0x3d, r28	; 61
    4892:	de bf       	out	0x3e, r29	; 62
    4894:	df 91       	pop	r29
    4896:	cf 91       	pop	r28
    4898:	1f 91       	pop	r17
    489a:	0f 91       	pop	r16
    489c:	08 95       	ret

0000489e <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    489e:	cf 93       	push	r28
    48a0:	df 93       	push	r29
    48a2:	0f 92       	push	r0
    48a4:	0f 92       	push	r0
    48a6:	cd b7       	in	r28, 0x3d	; 61
    48a8:	de b7       	in	r29, 0x3e	; 62
    48aa:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    48ac:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    48ae:	8a 81       	ldd	r24, Y+2	; 0x02
    48b0:	80 68       	ori	r24, 0x80	; 128
    48b2:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    48b4:	8f e3       	ldi	r24, 0x3F	; 63
    48b6:	90 e0       	ldi	r25, 0x00	; 0
    48b8:	fc 01       	movw	r30, r24
    48ba:	80 81       	ld	r24, Z
    48bc:	80 93 47 40 	sts	0x4047, r24
    48c0:	f8 94       	cli
    RadioCS(TRUE);
    48c2:	81 e0       	ldi	r24, 0x01	; 1
    48c4:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    48c8:	8a 81       	ldd	r24, Y+2	; 0x02
    48ca:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    48ce:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    48d0:	89 81       	ldd	r24, Y+1	; 0x01
    48d2:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    48d6:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    48d8:	80 e0       	ldi	r24, 0x00	; 0
    48da:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>
    CHB_LEAVE_CRIT();
    48de:	8f e3       	ldi	r24, 0x3F	; 63
    48e0:	90 e0       	ldi	r25, 0x00	; 0
    48e2:	20 91 47 40 	lds	r18, 0x4047
    48e6:	fc 01       	movw	r30, r24
    48e8:	20 83       	st	Z, r18
    48ea:	78 94       	sei

    return val;
    48ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    48ee:	0f 90       	pop	r0
    48f0:	0f 90       	pop	r0
    48f2:	df 91       	pop	r29
    48f4:	cf 91       	pop	r28
    48f6:	08 95       	ret

000048f8 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    48f8:	cf 93       	push	r28
    48fa:	df 93       	push	r29
    48fc:	00 d0       	rcall	.+0      	; 0x48fe <chb_reg_read16+0x6>
    48fe:	0f 92       	push	r0
    4900:	cd b7       	in	r28, 0x3d	; 61
    4902:	de b7       	in	r29, 0x3e	; 62
    4904:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4906:	1a 82       	std	Y+2, r1	; 0x02
    4908:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    490a:	19 82       	std	Y+1, r1	; 0x01
    490c:	1d c0       	rjmp	.+58     	; 0x4948 <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    490e:	9c 81       	ldd	r25, Y+4	; 0x04
    4910:	89 81       	ldd	r24, Y+1	; 0x01
    4912:	89 0f       	add	r24, r25
    4914:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    4918:	88 2f       	mov	r24, r24
    491a:	90 e0       	ldi	r25, 0x00	; 0
    491c:	29 81       	ldd	r18, Y+1	; 0x01
    491e:	22 2f       	mov	r18, r18
    4920:	30 e0       	ldi	r19, 0x00	; 0
    4922:	22 0f       	add	r18, r18
    4924:	33 1f       	adc	r19, r19
    4926:	22 0f       	add	r18, r18
    4928:	33 1f       	adc	r19, r19
    492a:	22 0f       	add	r18, r18
    492c:	33 1f       	adc	r19, r19
    492e:	02 2e       	mov	r0, r18
    4930:	02 c0       	rjmp	.+4      	; 0x4936 <chb_reg_read16+0x3e>
    4932:	88 0f       	add	r24, r24
    4934:	99 1f       	adc	r25, r25
    4936:	0a 94       	dec	r0
    4938:	e2 f7       	brpl	.-8      	; 0x4932 <chb_reg_read16+0x3a>
    493a:	98 2f       	mov	r25, r24
    493c:	8c 81       	ldd	r24, Y+4	; 0x04
    493e:	89 2b       	or	r24, r25
    4940:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4942:	89 81       	ldd	r24, Y+1	; 0x01
    4944:	8f 5f       	subi	r24, 0xFF	; 255
    4946:	89 83       	std	Y+1, r24	; 0x01
    4948:	89 81       	ldd	r24, Y+1	; 0x01
    494a:	82 30       	cpi	r24, 0x02	; 2
    494c:	00 f3       	brcs	.-64     	; 0x490e <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    494e:	8a 81       	ldd	r24, Y+2	; 0x02
    4950:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4952:	24 96       	adiw	r28, 0x04	; 4
    4954:	cd bf       	out	0x3d, r28	; 61
    4956:	de bf       	out	0x3e, r29	; 62
    4958:	df 91       	pop	r29
    495a:	cf 91       	pop	r28
    495c:	08 95       	ret

0000495e <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    495e:	cf 93       	push	r28
    4960:	df 93       	push	r29
    4962:	0f 92       	push	r0
    4964:	0f 92       	push	r0
    4966:	cd b7       	in	r28, 0x3d	; 61
    4968:	de b7       	in	r29, 0x3e	; 62
    496a:	89 83       	std	Y+1, r24	; 0x01
    496c:	6a 83       	std	Y+2, r22	; 0x02
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    496e:	89 81       	ldd	r24, Y+1	; 0x01
    4970:	80 6c       	ori	r24, 0xC0	; 192
    4972:	89 83       	std	Y+1, r24	; 0x01

    CHB_ENTER_CRIT();
    4974:	8f e3       	ldi	r24, 0x3F	; 63
    4976:	90 e0       	ldi	r25, 0x00	; 0
    4978:	fc 01       	movw	r30, r24
    497a:	80 81       	ld	r24, Z
    497c:	80 93 47 40 	sts	0x4047, r24
    4980:	f8 94       	cli
    RadioCS(TRUE);
    4982:	81 e0       	ldi	r24, 0x01	; 1
    4984:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    4988:	89 81       	ldd	r24, Y+1	; 0x01
    498a:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    498e:	8a 81       	ldd	r24, Y+2	; 0x02
    4990:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>

    RadioCS(FALSE);
    4994:	80 e0       	ldi	r24, 0x00	; 0
    4996:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>
    CHB_LEAVE_CRIT();
    499a:	8f e3       	ldi	r24, 0x3F	; 63
    499c:	90 e0       	ldi	r25, 0x00	; 0
    499e:	20 91 47 40 	lds	r18, 0x4047
    49a2:	fc 01       	movw	r30, r24
    49a4:	20 83       	st	Z, r18
    49a6:	78 94       	sei
}
    49a8:	0f 90       	pop	r0
    49aa:	0f 90       	pop	r0
    49ac:	df 91       	pop	r29
    49ae:	cf 91       	pop	r28
    49b0:	08 95       	ret

000049b2 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    49b2:	cf 93       	push	r28
    49b4:	df 93       	push	r29
    49b6:	00 d0       	rcall	.+0      	; 0x49b8 <chb_reg_write16+0x6>
    49b8:	0f 92       	push	r0
    49ba:	cd b7       	in	r28, 0x3d	; 61
    49bc:	de b7       	in	r29, 0x3e	; 62
    49be:	8a 83       	std	Y+2, r24	; 0x02
    49c0:	6b 83       	std	Y+3, r22	; 0x03
    49c2:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    49c4:	19 82       	std	Y+1, r1	; 0x01
    49c6:	1d c0       	rjmp	.+58     	; 0x4a02 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    49c8:	9a 81       	ldd	r25, Y+2	; 0x02
    49ca:	89 81       	ldd	r24, Y+1	; 0x01
    49cc:	49 2f       	mov	r20, r25
    49ce:	48 0f       	add	r20, r24
    49d0:	89 81       	ldd	r24, Y+1	; 0x01
    49d2:	88 2f       	mov	r24, r24
    49d4:	90 e0       	ldi	r25, 0x00	; 0
    49d6:	9c 01       	movw	r18, r24
    49d8:	22 0f       	add	r18, r18
    49da:	33 1f       	adc	r19, r19
    49dc:	22 0f       	add	r18, r18
    49de:	33 1f       	adc	r19, r19
    49e0:	22 0f       	add	r18, r18
    49e2:	33 1f       	adc	r19, r19
    49e4:	8b 81       	ldd	r24, Y+3	; 0x03
    49e6:	9c 81       	ldd	r25, Y+4	; 0x04
    49e8:	02 c0       	rjmp	.+4      	; 0x49ee <chb_reg_write16+0x3c>
    49ea:	96 95       	lsr	r25
    49ec:	87 95       	ror	r24
    49ee:	2a 95       	dec	r18
    49f0:	e2 f7       	brpl	.-8      	; 0x49ea <chb_reg_write16+0x38>
    49f2:	98 2f       	mov	r25, r24
    49f4:	84 2f       	mov	r24, r20
    49f6:	69 2f       	mov	r22, r25
    49f8:	0e 94 af 24 	call	0x495e	; 0x495e <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    49fc:	89 81       	ldd	r24, Y+1	; 0x01
    49fe:	8f 5f       	subi	r24, 0xFF	; 255
    4a00:	89 83       	std	Y+1, r24	; 0x01
    4a02:	89 81       	ldd	r24, Y+1	; 0x01
    4a04:	82 30       	cpi	r24, 0x02	; 2
    4a06:	00 f3       	brcs	.-64     	; 0x49c8 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4a08:	24 96       	adiw	r28, 0x04	; 4
    4a0a:	cd bf       	out	0x3d, r28	; 61
    4a0c:	de bf       	out	0x3e, r29	; 62
    4a0e:	df 91       	pop	r29
    4a10:	cf 91       	pop	r28
    4a12:	08 95       	ret

00004a14 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4a14:	cf 93       	push	r28
    4a16:	df 93       	push	r29
    4a18:	00 d0       	rcall	.+0      	; 0x4a1a <chb_reg_write64+0x6>
    4a1a:	0f 92       	push	r0
    4a1c:	cd b7       	in	r28, 0x3d	; 61
    4a1e:	de b7       	in	r29, 0x3e	; 62
    4a20:	8a 83       	std	Y+2, r24	; 0x02
    4a22:	6b 83       	std	Y+3, r22	; 0x03
    4a24:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4a26:	19 82       	std	Y+1, r1	; 0x01
    4a28:	14 c0       	rjmp	.+40     	; 0x4a52 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a2c:	89 81       	ldd	r24, Y+1	; 0x01
    4a2e:	49 2f       	mov	r20, r25
    4a30:	48 0f       	add	r20, r24
    4a32:	89 81       	ldd	r24, Y+1	; 0x01
    4a34:	88 2f       	mov	r24, r24
    4a36:	90 e0       	ldi	r25, 0x00	; 0
    4a38:	2b 81       	ldd	r18, Y+3	; 0x03
    4a3a:	3c 81       	ldd	r19, Y+4	; 0x04
    4a3c:	82 0f       	add	r24, r18
    4a3e:	93 1f       	adc	r25, r19
    4a40:	fc 01       	movw	r30, r24
    4a42:	90 81       	ld	r25, Z
    4a44:	84 2f       	mov	r24, r20
    4a46:	69 2f       	mov	r22, r25
    4a48:	0e 94 af 24 	call	0x495e	; 0x495e <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4a4c:	89 81       	ldd	r24, Y+1	; 0x01
    4a4e:	8f 5f       	subi	r24, 0xFF	; 255
    4a50:	89 83       	std	Y+1, r24	; 0x01
    4a52:	89 81       	ldd	r24, Y+1	; 0x01
    4a54:	88 30       	cpi	r24, 0x08	; 8
    4a56:	48 f3       	brcs	.-46     	; 0x4a2a <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    4a58:	24 96       	adiw	r28, 0x04	; 4
    4a5a:	cd bf       	out	0x3d, r28	; 61
    4a5c:	de bf       	out	0x3e, r29	; 62
    4a5e:	df 91       	pop	r29
    4a60:	cf 91       	pop	r28
    4a62:	08 95       	ret

00004a64 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    4a64:	cf 93       	push	r28
    4a66:	df 93       	push	r29
    4a68:	00 d0       	rcall	.+0      	; 0x4a6a <chb_reg_read_mod_write+0x6>
    4a6a:	0f 92       	push	r0
    4a6c:	cd b7       	in	r28, 0x3d	; 61
    4a6e:	de b7       	in	r29, 0x3e	; 62
    4a70:	8a 83       	std	Y+2, r24	; 0x02
    4a72:	6b 83       	std	Y+3, r22	; 0x03
    4a74:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    4a76:	8a 81       	ldd	r24, Y+2	; 0x02
    4a78:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    4a7c:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a80:	8c 81       	ldd	r24, Y+4	; 0x04
    4a82:	89 23       	and	r24, r25
    4a84:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4a86:	8c 81       	ldd	r24, Y+4	; 0x04
    4a88:	98 2f       	mov	r25, r24
    4a8a:	90 95       	com	r25
    4a8c:	89 81       	ldd	r24, Y+1	; 0x01
    4a8e:	89 23       	and	r24, r25
    4a90:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4a92:	99 81       	ldd	r25, Y+1	; 0x01
    4a94:	8b 81       	ldd	r24, Y+3	; 0x03
    4a96:	89 2b       	or	r24, r25
    4a98:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a9c:	69 81       	ldd	r22, Y+1	; 0x01
    4a9e:	0e 94 af 24 	call	0x495e	; 0x495e <chb_reg_write>
}
    4aa2:	24 96       	adiw	r28, 0x04	; 4
    4aa4:	cd bf       	out	0x3d, r28	; 61
    4aa6:	de bf       	out	0x3e, r29	; 62
    4aa8:	df 91       	pop	r29
    4aaa:	cf 91       	pop	r28
    4aac:	08 95       	ret

00004aae <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4aae:	cf 93       	push	r28
    4ab0:	df 93       	push	r29
    4ab2:	cd b7       	in	r28, 0x3d	; 61
    4ab4:	de b7       	in	r29, 0x3e	; 62
    4ab6:	27 97       	sbiw	r28, 0x07	; 7
    4ab8:	cd bf       	out	0x3d, r28	; 61
    4aba:	de bf       	out	0x3e, r29	; 62
    4abc:	8a 83       	std	Y+2, r24	; 0x02
    4abe:	9b 83       	std	Y+3, r25	; 0x03
    4ac0:	6c 83       	std	Y+4, r22	; 0x04
    4ac2:	4d 83       	std	Y+5, r20	; 0x05
    4ac4:	5e 83       	std	Y+6, r21	; 0x06
    4ac6:	2f 83       	std	Y+7, r18	; 0x07
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4ac8:	8c 81       	ldd	r24, Y+4	; 0x04
    4aca:	28 2f       	mov	r18, r24
    4acc:	30 e0       	ldi	r19, 0x00	; 0
    4ace:	8f 81       	ldd	r24, Y+7	; 0x07
    4ad0:	88 2f       	mov	r24, r24
    4ad2:	90 e0       	ldi	r25, 0x00	; 0
    4ad4:	82 0f       	add	r24, r18
    4ad6:	93 1f       	adc	r25, r19
    4ad8:	80 38       	cpi	r24, 0x80	; 128
    4ada:	91 05       	cpc	r25, r1
    4adc:	0c f0       	brlt	.+2      	; 0x4ae0 <chb_frame_write+0x32>
    4ade:	42 c0       	rjmp	.+132    	; 0x4b64 <chb_frame_write+0xb6>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4ae0:	8f e3       	ldi	r24, 0x3F	; 63
    4ae2:	90 e0       	ldi	r25, 0x00	; 0
    4ae4:	fc 01       	movw	r30, r24
    4ae6:	80 81       	ld	r24, Z
    4ae8:	80 93 47 40 	sts	0x4047, r24
    4aec:	f8 94       	cli
    RadioCS(TRUE); 
    4aee:	81 e0       	ldi	r24, 0x01	; 1
    4af0:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    4af4:	80 e6       	ldi	r24, 0x60	; 96
    4af6:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4afa:	19 82       	std	Y+1, r1	; 0x01
    4afc:	0f c0       	rjmp	.+30     	; 0x4b1c <chb_frame_write+0x6e>
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    4afe:	8a 81       	ldd	r24, Y+2	; 0x02
    4b00:	9b 81       	ldd	r25, Y+3	; 0x03
    4b02:	fc 01       	movw	r30, r24
    4b04:	20 81       	ld	r18, Z
    4b06:	8a 81       	ldd	r24, Y+2	; 0x02
    4b08:	9b 81       	ldd	r25, Y+3	; 0x03
    4b0a:	01 96       	adiw	r24, 0x01	; 1
    4b0c:	8a 83       	std	Y+2, r24	; 0x02
    4b0e:	9b 83       	std	Y+3, r25	; 0x03
    4b10:	82 2f       	mov	r24, r18
    4b12:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4b16:	89 81       	ldd	r24, Y+1	; 0x01
    4b18:	8f 5f       	subi	r24, 0xFF	; 255
    4b1a:	89 83       	std	Y+1, r24	; 0x01
    4b1c:	99 81       	ldd	r25, Y+1	; 0x01
    4b1e:	8c 81       	ldd	r24, Y+4	; 0x04
    4b20:	98 17       	cp	r25, r24
    4b22:	68 f3       	brcs	.-38     	; 0x4afe <chb_frame_write+0x50>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4b24:	19 82       	std	Y+1, r1	; 0x01
    4b26:	0f c0       	rjmp	.+30     	; 0x4b46 <chb_frame_write+0x98>
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    4b28:	8d 81       	ldd	r24, Y+5	; 0x05
    4b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    4b2c:	fc 01       	movw	r30, r24
    4b2e:	20 81       	ld	r18, Z
    4b30:	8d 81       	ldd	r24, Y+5	; 0x05
    4b32:	9e 81       	ldd	r25, Y+6	; 0x06
    4b34:	01 96       	adiw	r24, 0x01	; 1
    4b36:	8d 83       	std	Y+5, r24	; 0x05
    4b38:	9e 83       	std	Y+6, r25	; 0x06
    4b3a:	82 2f       	mov	r24, r18
    4b3c:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4b40:	89 81       	ldd	r24, Y+1	; 0x01
    4b42:	8f 5f       	subi	r24, 0xFF	; 255
    4b44:	89 83       	std	Y+1, r24	; 0x01
    4b46:	99 81       	ldd	r25, Y+1	; 0x01
    4b48:	8f 81       	ldd	r24, Y+7	; 0x07
    4b4a:	98 17       	cp	r25, r24
    4b4c:	68 f3       	brcs	.-38     	; 0x4b28 <chb_frame_write+0x7a>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    4b4e:	80 e0       	ldi	r24, 0x00	; 0
    4b50:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>
    CHB_LEAVE_CRIT();
    4b54:	8f e3       	ldi	r24, 0x3F	; 63
    4b56:	90 e0       	ldi	r25, 0x00	; 0
    4b58:	20 91 47 40 	lds	r18, 0x4047
    4b5c:	fc 01       	movw	r30, r24
    4b5e:	20 83       	st	Z, r18
    4b60:	78 94       	sei
    4b62:	01 c0       	rjmp	.+2      	; 0x4b66 <chb_frame_write+0xb8>
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4b64:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4b66:	27 96       	adiw	r28, 0x07	; 7
    4b68:	cd bf       	out	0x3d, r28	; 61
    4b6a:	de bf       	out	0x3e, r29	; 62
    4b6c:	df 91       	pop	r29
    4b6e:	cf 91       	pop	r28
    4b70:	08 95       	ret

00004b72 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    4b72:	0f 93       	push	r16
    4b74:	1f 93       	push	r17
    4b76:	cf 93       	push	r28
    4b78:	df 93       	push	r29
    4b7a:	cd b7       	in	r28, 0x3d	; 61
    4b7c:	de b7       	in	r29, 0x3e	; 62
    4b7e:	e7 97       	sbiw	r28, 0x37	; 55
    4b80:	cd bf       	out	0x3d, r28	; 61
    4b82:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4b84:	8f e3       	ldi	r24, 0x3F	; 63
    4b86:	90 e0       	ldi	r25, 0x00	; 0
    4b88:	fc 01       	movw	r30, r24
    4b8a:	80 81       	ld	r24, Z
    4b8c:	80 93 47 40 	sts	0x4047, r24
    4b90:	f8 94       	cli
    RadioCS(TRUE);
    4b92:	81 e0       	ldi	r24, 0x01	; 1
    4b94:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4b98:	80 e2       	ldi	r24, 0x20	; 32
    4b9a:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    len = SPID_write(0);
    4b9e:	80 e0       	ldi	r24, 0x00	; 0
    4ba0:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    4ba4:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4ba6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ba8:	83 30       	cpi	r24, 0x03	; 3
    4baa:	08 f4       	brcc	.+2      	; 0x4bae <chb_frame_read+0x3c>
    4bac:	66 c0       	rjmp	.+204    	; 0x4c7a <chb_frame_read+0x108>
    4bae:	8a 81       	ldd	r24, Y+2	; 0x02
    4bb0:	88 23       	and	r24, r24
    4bb2:	0c f4       	brge	.+2      	; 0x4bb6 <chb_frame_read+0x44>
    4bb4:	62 c0       	rjmp	.+196    	; 0x4c7a <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4bb6:	8a 81       	ldd	r24, Y+2	; 0x02
    4bb8:	08 2f       	mov	r16, r24
    4bba:	10 e0       	ldi	r17, 0x00	; 0
    4bbc:	0e 94 42 22 	call	0x4484	; 0x4484 <chb_buf_get_len>
    4bc0:	88 2f       	mov	r24, r24
    4bc2:	90 e0       	ldi	r25, 0x00	; 0
    4bc4:	20 e8       	ldi	r18, 0x80	; 128
    4bc6:	30 e0       	ldi	r19, 0x00	; 0
    4bc8:	a9 01       	movw	r20, r18
    4bca:	48 1b       	sub	r20, r24
    4bcc:	59 0b       	sbc	r21, r25
    4bce:	ca 01       	movw	r24, r20
    4bd0:	08 17       	cp	r16, r24
    4bd2:	19 07       	cpc	r17, r25
    4bd4:	f4 f4       	brge	.+60     	; 0x4c12 <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4bd6:	8a 81       	ldd	r24, Y+2	; 0x02
    4bd8:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4bdc:	19 82       	std	Y+1, r1	; 0x01
    4bde:	0a c0       	rjmp	.+20     	; 0x4bf4 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4be0:	80 e0       	ldi	r24, 0x00	; 0
    4be2:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    4be6:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4be8:	8b 81       	ldd	r24, Y+3	; 0x03
    4bea:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4bee:	89 81       	ldd	r24, Y+1	; 0x01
    4bf0:	8f 5f       	subi	r24, 0xFF	; 255
    4bf2:	89 83       	std	Y+1, r24	; 0x01
    4bf4:	99 81       	ldd	r25, Y+1	; 0x01
    4bf6:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf8:	98 17       	cp	r25, r24
    4bfa:	90 f3       	brcs	.-28     	; 0x4be0 <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4bfc:	80 e8       	ldi	r24, 0x80	; 128
    4bfe:	96 e0       	ldi	r25, 0x06	; 6
    4c00:	24 e0       	ldi	r18, 0x04	; 4
    4c02:	fc 01       	movw	r30, r24
    4c04:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4c06:	80 e8       	ldi	r24, 0x80	; 128
    4c08:	96 e0       	ldi	r25, 0x06	; 6
    4c0a:	24 e0       	ldi	r18, 0x04	; 4
    4c0c:	fc 01       	movw	r30, r24
    4c0e:	26 83       	std	Z+6, r18	; 0x06
    4c10:	34 c0       	rjmp	.+104    	; 0x4c7a <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4c12:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <chb_get_pcb>
    4c16:	8c 83       	std	Y+4, r24	; 0x04
    4c18:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4c1a:	19 82       	std	Y+1, r1	; 0x01
    4c1c:	07 c0       	rjmp	.+14     	; 0x4c2c <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    4c1e:	80 e0       	ldi	r24, 0x00	; 0
    4c20:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    4c24:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4c26:	89 81       	ldd	r24, Y+1	; 0x01
    4c28:	8f 5f       	subi	r24, 0xFF	; 255
    4c2a:	89 83       	std	Y+1, r24	; 0x01
    4c2c:	99 81       	ldd	r25, Y+1	; 0x01
    4c2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c30:	98 17       	cp	r25, r24
    4c32:	a8 f3       	brcs	.-22     	; 0x4c1e <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4c34:	8c 81       	ldd	r24, Y+4	; 0x04
    4c36:	9d 81       	ldd	r25, Y+5	; 0x05
    4c38:	fc 01       	movw	r30, r24
    4c3a:	85 85       	ldd	r24, Z+13	; 0x0d
    4c3c:	96 85       	ldd	r25, Z+14	; 0x0e
    4c3e:	9c 01       	movw	r18, r24
    4c40:	2f 5f       	subi	r18, 0xFF	; 255
    4c42:	3f 4f       	sbci	r19, 0xFF	; 255
    4c44:	8c 81       	ldd	r24, Y+4	; 0x04
    4c46:	9d 81       	ldd	r25, Y+5	; 0x05
    4c48:	fc 01       	movw	r30, r24
    4c4a:	25 87       	std	Z+13, r18	; 0x0d
    4c4c:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4c4e:	ce 01       	movw	r24, r28
    4c50:	06 96       	adiw	r24, 0x06	; 6
    4c52:	28 ee       	ldi	r18, 0xE8	; 232
    4c54:	31 e0       	ldi	r19, 0x01	; 1
    4c56:	b9 01       	movw	r22, r18
    4c58:	0e 94 2e 5e 	call	0xbc5c	; 0xbc5c <strcpy_P>
            printf(buf);
    4c5c:	0f 92       	push	r0
    4c5e:	0f 92       	push	r0
    4c60:	8d b7       	in	r24, 0x3d	; 61
    4c62:	9e b7       	in	r25, 0x3e	; 62
    4c64:	01 96       	adiw	r24, 0x01	; 1
    4c66:	9e 01       	movw	r18, r28
    4c68:	2a 5f       	subi	r18, 0xFA	; 250
    4c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c6c:	fc 01       	movw	r30, r24
    4c6e:	20 83       	st	Z, r18
    4c70:	31 83       	std	Z+1, r19	; 0x01
    4c72:	0e 94 81 5e 	call	0xbd02	; 0xbd02 <printf>
    4c76:	0f 90       	pop	r0
    4c78:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4c7a:	80 e0       	ldi	r24, 0x00	; 0
    4c7c:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>
    CHB_LEAVE_CRIT();
    4c80:	8f e3       	ldi	r24, 0x3F	; 63
    4c82:	90 e0       	ldi	r25, 0x00	; 0
    4c84:	20 91 47 40 	lds	r18, 0x4047
    4c88:	fc 01       	movw	r30, r24
    4c8a:	20 83       	st	Z, r18
    4c8c:	78 94       	sei
}
    4c8e:	e7 96       	adiw	r28, 0x37	; 55
    4c90:	cd bf       	out	0x3d, r28	; 61
    4c92:	de bf       	out	0x3e, r29	; 62
    4c94:	df 91       	pop	r29
    4c96:	cf 91       	pop	r28
    4c98:	1f 91       	pop	r17
    4c9a:	0f 91       	pop	r16
    4c9c:	08 95       	ret

00004c9e <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4c9e:	cf 93       	push	r28
    4ca0:	df 93       	push	r29
    4ca2:	0f 92       	push	r0
    4ca4:	cd b7       	in	r28, 0x3d	; 61
    4ca6:	de b7       	in	r29, 0x3e	; 62
    4ca8:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4caa:	89 81       	ldd	r24, Y+1	; 0x01
    4cac:	88 2f       	mov	r24, r24
    4cae:	90 e0       	ldi	r25, 0x00	; 0
    4cb0:	81 30       	cpi	r24, 0x01	; 1
    4cb2:	91 05       	cpc	r25, r1
    4cb4:	c1 f0       	breq	.+48     	; 0x4ce6 <chb_set_mode+0x48>
    4cb6:	82 30       	cpi	r24, 0x02	; 2
    4cb8:	91 05       	cpc	r25, r1
    4cba:	1c f4       	brge	.+6      	; 0x4cc2 <chb_set_mode+0x24>
    4cbc:	00 97       	sbiw	r24, 0x00	; 0
    4cbe:	41 f0       	breq	.+16     	; 0x4cd0 <chb_set_mode+0x32>
    4cc0:	33 c0       	rjmp	.+102    	; 0x4d28 <chb_set_mode+0x8a>
    4cc2:	82 30       	cpi	r24, 0x02	; 2
    4cc4:	91 05       	cpc	r25, r1
    4cc6:	d1 f0       	breq	.+52     	; 0x4cfc <chb_set_mode+0x5e>
    4cc8:	83 30       	cpi	r24, 0x03	; 3
    4cca:	91 05       	cpc	r25, r1
    4ccc:	11 f1       	breq	.+68     	; 0x4d12 <chb_set_mode+0x74>
    4cce:	2c c0       	rjmp	.+88     	; 0x4d28 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4cd0:	8c e0       	ldi	r24, 0x0C	; 12
    4cd2:	68 e0       	ldi	r22, 0x08	; 8
    4cd4:	4f e3       	ldi	r20, 0x3F	; 63
    4cd6:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4cda:	86 e1       	ldi	r24, 0x16	; 22
    4cdc:	62 e0       	ldi	r22, 0x02	; 2
    4cde:	43 e0       	ldi	r20, 0x03	; 3
    4ce0:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        break;
    4ce4:	21 c0       	rjmp	.+66     	; 0x4d28 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4ce6:	8c e0       	ldi	r24, 0x0C	; 12
    4ce8:	6c e0       	ldi	r22, 0x0C	; 12
    4cea:	4f e3       	ldi	r20, 0x3F	; 63
    4cec:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4cf0:	86 e1       	ldi	r24, 0x16	; 22
    4cf2:	62 e0       	ldi	r22, 0x02	; 2
    4cf4:	43 e0       	ldi	r20, 0x03	; 3
    4cf6:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        break;
    4cfa:	16 c0       	rjmp	.+44     	; 0x4d28 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4cfc:	8c e0       	ldi	r24, 0x0C	; 12
    4cfe:	6c e1       	ldi	r22, 0x1C	; 28
    4d00:	4f e3       	ldi	r20, 0x3F	; 63
    4d02:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4d06:	86 e1       	ldi	r24, 0x16	; 22
    4d08:	62 e0       	ldi	r22, 0x02	; 2
    4d0a:	43 e0       	ldi	r20, 0x03	; 3
    4d0c:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        break;
    4d10:	0b c0       	rjmp	.+22     	; 0x4d28 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4d12:	8c e0       	ldi	r24, 0x0C	; 12
    4d14:	60 e0       	ldi	r22, 0x00	; 0
    4d16:	4f e3       	ldi	r20, 0x3F	; 63
    4d18:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4d1c:	86 e1       	ldi	r24, 0x16	; 22
    4d1e:	63 e0       	ldi	r22, 0x03	; 3
    4d20:	43 e0       	ldi	r20, 0x03	; 3
    4d22:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
        break;
    4d26:	00 00       	nop
    }
}
    4d28:	0f 90       	pop	r0
    4d2a:	df 91       	pop	r29
    4d2c:	cf 91       	pop	r28
    4d2e:	08 95       	ret

00004d30 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4d30:	0f 93       	push	r16
    4d32:	1f 93       	push	r17
    4d34:	cf 93       	push	r28
    4d36:	df 93       	push	r29
    4d38:	cd b7       	in	r28, 0x3d	; 61
    4d3a:	de b7       	in	r29, 0x3e	; 62
    4d3c:	6a 97       	sbiw	r28, 0x1a	; 26
    4d3e:	cd bf       	out	0x3d, r28	; 61
    4d40:	de bf       	out	0x3e, r29	; 62
    4d42:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4d44:	88 e0       	ldi	r24, 0x08	; 8
    4d46:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4d48:	4f e1       	ldi	r20, 0x1F	; 31
    4d4a:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4d4e:	0e 94 4b 22 	call	0x4496	; 0x4496 <chb_get_state>
    4d52:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4d54:	89 81       	ldd	r24, Y+1	; 0x01
    4d56:	86 30       	cpi	r24, 0x06	; 6
    4d58:	21 f0       	breq	.+8      	; 0x4d62 <chb_set_channel+0x32>
    4d5a:	89 81       	ldd	r24, Y+1	; 0x01
    4d5c:	89 30       	cpi	r24, 0x09	; 9
    4d5e:	09 f0       	breq	.+2      	; 0x4d62 <chb_set_channel+0x32>
    4d60:	d5 c0       	rjmp	.+426    	; 0x4f0c <chb_set_channel+0x1dc>
    4d62:	80 e0       	ldi	r24, 0x00	; 0
    4d64:	90 e0       	ldi	r25, 0x00	; 0
    4d66:	ac ed       	ldi	r26, 0xDC	; 220
    4d68:	b2 e4       	ldi	r27, 0x42	; 66
    4d6a:	8a 83       	std	Y+2, r24	; 0x02
    4d6c:	9b 83       	std	Y+3, r25	; 0x03
    4d6e:	ac 83       	std	Y+4, r26	; 0x04
    4d70:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4d72:	6a 81       	ldd	r22, Y+2	; 0x02
    4d74:	7b 81       	ldd	r23, Y+3	; 0x03
    4d76:	8c 81       	ldd	r24, Y+4	; 0x04
    4d78:	9d 81       	ldd	r25, Y+5	; 0x05
    4d7a:	2b ea       	ldi	r18, 0xAB	; 171
    4d7c:	3a ea       	ldi	r19, 0xAA	; 170
    4d7e:	4a e2       	ldi	r20, 0x2A	; 42
    4d80:	51 e4       	ldi	r21, 0x41	; 65
    4d82:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    4d86:	dc 01       	movw	r26, r24
    4d88:	cb 01       	movw	r24, r22
    4d8a:	8e 83       	std	Y+6, r24	; 0x06
    4d8c:	9f 83       	std	Y+7, r25	; 0x07
    4d8e:	a8 87       	std	Y+8, r26	; 0x08
    4d90:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4d92:	11 e0       	ldi	r17, 0x01	; 1
    4d94:	6e 81       	ldd	r22, Y+6	; 0x06
    4d96:	7f 81       	ldd	r23, Y+7	; 0x07
    4d98:	88 85       	ldd	r24, Y+8	; 0x08
    4d9a:	99 85       	ldd	r25, Y+9	; 0x09
    4d9c:	20 e0       	ldi	r18, 0x00	; 0
    4d9e:	30 e0       	ldi	r19, 0x00	; 0
    4da0:	40 e8       	ldi	r20, 0x80	; 128
    4da2:	5f e3       	ldi	r21, 0x3F	; 63
    4da4:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    4da8:	88 23       	and	r24, r24
    4daa:	0c f0       	brlt	.+2      	; 0x4dae <chb_set_channel+0x7e>
    4dac:	10 e0       	ldi	r17, 0x00	; 0
    4dae:	11 23       	and	r17, r17
    4db0:	19 f0       	breq	.+6      	; 0x4db8 <chb_set_channel+0x88>
		__ticks = 1;
    4db2:	81 e0       	ldi	r24, 0x01	; 1
    4db4:	8a 87       	std	Y+10, r24	; 0x0a
    4db6:	a3 c0       	rjmp	.+326    	; 0x4efe <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4db8:	11 e0       	ldi	r17, 0x01	; 1
    4dba:	6e 81       	ldd	r22, Y+6	; 0x06
    4dbc:	7f 81       	ldd	r23, Y+7	; 0x07
    4dbe:	88 85       	ldd	r24, Y+8	; 0x08
    4dc0:	99 85       	ldd	r25, Y+9	; 0x09
    4dc2:	20 e0       	ldi	r18, 0x00	; 0
    4dc4:	30 e0       	ldi	r19, 0x00	; 0
    4dc6:	4f e7       	ldi	r20, 0x7F	; 127
    4dc8:	53 e4       	ldi	r21, 0x43	; 67
    4dca:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    4dce:	18 16       	cp	r1, r24
    4dd0:	0c f0       	brlt	.+2      	; 0x4dd4 <chb_set_channel+0xa4>
    4dd2:	10 e0       	ldi	r17, 0x00	; 0
    4dd4:	11 23       	and	r17, r17
    4dd6:	09 f4       	brne	.+2      	; 0x4dda <chb_set_channel+0xaa>
    4dd8:	89 c0       	rjmp	.+274    	; 0x4eec <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4dda:	6a 81       	ldd	r22, Y+2	; 0x02
    4ddc:	7b 81       	ldd	r23, Y+3	; 0x03
    4dde:	8c 81       	ldd	r24, Y+4	; 0x04
    4de0:	9d 81       	ldd	r25, Y+5	; 0x05
    4de2:	20 e0       	ldi	r18, 0x00	; 0
    4de4:	30 e0       	ldi	r19, 0x00	; 0
    4de6:	4a e7       	ldi	r20, 0x7A	; 122
    4de8:	54 e4       	ldi	r21, 0x44	; 68
    4dea:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    4dee:	dc 01       	movw	r26, r24
    4df0:	cb 01       	movw	r24, r22
    4df2:	8b 87       	std	Y+11, r24	; 0x0b
    4df4:	9c 87       	std	Y+12, r25	; 0x0c
    4df6:	ad 87       	std	Y+13, r26	; 0x0d
    4df8:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4dfa:	6b 85       	ldd	r22, Y+11	; 0x0b
    4dfc:	7c 85       	ldd	r23, Y+12	; 0x0c
    4dfe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e00:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e02:	20 e0       	ldi	r18, 0x00	; 0
    4e04:	30 e0       	ldi	r19, 0x00	; 0
    4e06:	4a ef       	ldi	r20, 0xFA	; 250
    4e08:	55 e4       	ldi	r21, 0x45	; 69
    4e0a:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    4e0e:	dc 01       	movw	r26, r24
    4e10:	cb 01       	movw	r24, r22
    4e12:	8f 87       	std	Y+15, r24	; 0x0f
    4e14:	98 8b       	std	Y+16, r25	; 0x10
    4e16:	a9 8b       	std	Y+17, r26	; 0x11
    4e18:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4e1a:	11 e0       	ldi	r17, 0x01	; 1
    4e1c:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e1e:	78 89       	ldd	r23, Y+16	; 0x10
    4e20:	89 89       	ldd	r24, Y+17	; 0x11
    4e22:	9a 89       	ldd	r25, Y+18	; 0x12
    4e24:	20 e0       	ldi	r18, 0x00	; 0
    4e26:	30 e0       	ldi	r19, 0x00	; 0
    4e28:	40 e8       	ldi	r20, 0x80	; 128
    4e2a:	5f e3       	ldi	r21, 0x3F	; 63
    4e2c:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    4e30:	88 23       	and	r24, r24
    4e32:	0c f0       	brlt	.+2      	; 0x4e36 <chb_set_channel+0x106>
    4e34:	10 e0       	ldi	r17, 0x00	; 0
    4e36:	11 23       	and	r17, r17
    4e38:	29 f0       	breq	.+10     	; 0x4e44 <chb_set_channel+0x114>
		__ticks = 1;
    4e3a:	81 e0       	ldi	r24, 0x01	; 1
    4e3c:	90 e0       	ldi	r25, 0x00	; 0
    4e3e:	8b 8b       	std	Y+19, r24	; 0x13
    4e40:	9c 8b       	std	Y+20, r25	; 0x14
    4e42:	46 c0       	rjmp	.+140    	; 0x4ed0 <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4e44:	11 e0       	ldi	r17, 0x01	; 1
    4e46:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e48:	78 89       	ldd	r23, Y+16	; 0x10
    4e4a:	89 89       	ldd	r24, Y+17	; 0x11
    4e4c:	9a 89       	ldd	r25, Y+18	; 0x12
    4e4e:	20 e0       	ldi	r18, 0x00	; 0
    4e50:	3f ef       	ldi	r19, 0xFF	; 255
    4e52:	4f e7       	ldi	r20, 0x7F	; 127
    4e54:	57 e4       	ldi	r21, 0x47	; 71
    4e56:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    4e5a:	18 16       	cp	r1, r24
    4e5c:	0c f0       	brlt	.+2      	; 0x4e60 <chb_set_channel+0x130>
    4e5e:	10 e0       	ldi	r17, 0x00	; 0
    4e60:	11 23       	and	r17, r17
    4e62:	61 f1       	breq	.+88     	; 0x4ebc <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e64:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e66:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e68:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e6c:	20 e0       	ldi	r18, 0x00	; 0
    4e6e:	30 e0       	ldi	r19, 0x00	; 0
    4e70:	40 e2       	ldi	r20, 0x20	; 32
    4e72:	51 e4       	ldi	r21, 0x41	; 65
    4e74:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    4e78:	dc 01       	movw	r26, r24
    4e7a:	cb 01       	movw	r24, r22
    4e7c:	bc 01       	movw	r22, r24
    4e7e:	cd 01       	movw	r24, r26
    4e80:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    4e84:	dc 01       	movw	r26, r24
    4e86:	cb 01       	movw	r24, r22
    4e88:	8b 8b       	std	Y+19, r24	; 0x13
    4e8a:	9c 8b       	std	Y+20, r25	; 0x14
    4e8c:	12 c0       	rjmp	.+36     	; 0x4eb2 <chb_set_channel+0x182>
    4e8e:	80 e2       	ldi	r24, 0x20	; 32
    4e90:	93 e0       	ldi	r25, 0x03	; 3
    4e92:	8d 8b       	std	Y+21, r24	; 0x15
    4e94:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4e96:	8d 89       	ldd	r24, Y+21	; 0x15
    4e98:	9e 89       	ldd	r25, Y+22	; 0x16
    4e9a:	8c 01       	movw	r16, r24
    4e9c:	c8 01       	movw	r24, r16
    4e9e:	01 97       	sbiw	r24, 0x01	; 1
    4ea0:	f1 f7       	brne	.-4      	; 0x4e9e <chb_set_channel+0x16e>
    4ea2:	8c 01       	movw	r16, r24
    4ea4:	0d 8b       	std	Y+21, r16	; 0x15
    4ea6:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ea8:	8b 89       	ldd	r24, Y+19	; 0x13
    4eaa:	9c 89       	ldd	r25, Y+20	; 0x14
    4eac:	01 97       	sbiw	r24, 0x01	; 1
    4eae:	8b 8b       	std	Y+19, r24	; 0x13
    4eb0:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4eb2:	8b 89       	ldd	r24, Y+19	; 0x13
    4eb4:	9c 89       	ldd	r25, Y+20	; 0x14
    4eb6:	00 97       	sbiw	r24, 0x00	; 0
    4eb8:	51 f7       	brne	.-44     	; 0x4e8e <chb_set_channel+0x15e>
    4eba:	28 c0       	rjmp	.+80     	; 0x4f0c <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ebc:	6f 85       	ldd	r22, Y+15	; 0x0f
    4ebe:	78 89       	ldd	r23, Y+16	; 0x10
    4ec0:	89 89       	ldd	r24, Y+17	; 0x11
    4ec2:	9a 89       	ldd	r25, Y+18	; 0x12
    4ec4:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    4ec8:	dc 01       	movw	r26, r24
    4eca:	cb 01       	movw	r24, r22
    4ecc:	8b 8b       	std	Y+19, r24	; 0x13
    4ece:	9c 8b       	std	Y+20, r25	; 0x14
    4ed0:	8b 89       	ldd	r24, Y+19	; 0x13
    4ed2:	9c 89       	ldd	r25, Y+20	; 0x14
    4ed4:	8f 8b       	std	Y+23, r24	; 0x17
    4ed6:	98 8f       	std	Y+24, r25	; 0x18
    4ed8:	8f 89       	ldd	r24, Y+23	; 0x17
    4eda:	98 8d       	ldd	r25, Y+24	; 0x18
    4edc:	8c 01       	movw	r16, r24
    4ede:	c8 01       	movw	r24, r16
    4ee0:	01 97       	sbiw	r24, 0x01	; 1
    4ee2:	f1 f7       	brne	.-4      	; 0x4ee0 <chb_set_channel+0x1b0>
    4ee4:	8c 01       	movw	r16, r24
    4ee6:	0f 8b       	std	Y+23, r16	; 0x17
    4ee8:	18 8f       	std	Y+24, r17	; 0x18
    4eea:	10 c0       	rjmp	.+32     	; 0x4f0c <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4eec:	6e 81       	ldd	r22, Y+6	; 0x06
    4eee:	7f 81       	ldd	r23, Y+7	; 0x07
    4ef0:	88 85       	ldd	r24, Y+8	; 0x08
    4ef2:	99 85       	ldd	r25, Y+9	; 0x09
    4ef4:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    4ef8:	dc 01       	movw	r26, r24
    4efa:	cb 01       	movw	r24, r22
    4efc:	8a 87       	std	Y+10, r24	; 0x0a
    4efe:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f00:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4f02:	89 8d       	ldd	r24, Y+25	; 0x19
    4f04:	18 2f       	mov	r17, r24
    4f06:	1a 95       	dec	r17
    4f08:	f1 f7       	brne	.-4      	; 0x4f06 <chb_set_channel+0x1d6>
    4f0a:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4f0c:	88 e0       	ldi	r24, 0x08	; 8
    4f0e:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    4f12:	88 2f       	mov	r24, r24
    4f14:	90 e0       	ldi	r25, 0x00	; 0
    4f16:	9c 01       	movw	r18, r24
    4f18:	2f 71       	andi	r18, 0x1F	; 31
    4f1a:	30 70       	andi	r19, 0x00	; 0
    4f1c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4f1e:	88 2f       	mov	r24, r24
    4f20:	90 e0       	ldi	r25, 0x00	; 0
    4f22:	28 17       	cp	r18, r24
    4f24:	39 07       	cpc	r19, r25
    4f26:	11 f4       	brne	.+4      	; 0x4f2c <chb_set_channel+0x1fc>
    4f28:	80 e4       	ldi	r24, 0x40	; 64
    4f2a:	01 c0       	rjmp	.+2      	; 0x4f2e <chb_set_channel+0x1fe>
    4f2c:	83 e4       	ldi	r24, 0x43	; 67
}
    4f2e:	6a 96       	adiw	r28, 0x1a	; 26
    4f30:	cd bf       	out	0x3d, r28	; 61
    4f32:	de bf       	out	0x3e, r29	; 62
    4f34:	df 91       	pop	r29
    4f36:	cf 91       	pop	r28
    4f38:	1f 91       	pop	r17
    4f3a:	0f 91       	pop	r16
    4f3c:	08 95       	ret

00004f3e <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4f3e:	cf 93       	push	r28
    4f40:	df 93       	push	r29
    4f42:	0f 92       	push	r0
    4f44:	cd b7       	in	r28, 0x3d	; 61
    4f46:	de b7       	in	r29, 0x3e	; 62
    4f48:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4f4a:	85 e0       	ldi	r24, 0x05	; 5
    4f4c:	69 81       	ldd	r22, Y+1	; 0x01
    4f4e:	0e 94 af 24 	call	0x495e	; 0x495e <chb_reg_write>
}
    4f52:	0f 90       	pop	r0
    4f54:	df 91       	pop	r29
    4f56:	cf 91       	pop	r28
    4f58:	08 95       	ret

00004f5a <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4f5a:	0f 93       	push	r16
    4f5c:	1f 93       	push	r17
    4f5e:	cf 93       	push	r28
    4f60:	df 93       	push	r29
    4f62:	cd b7       	in	r28, 0x3d	; 61
    4f64:	de b7       	in	r29, 0x3e	; 62
    4f66:	c2 56       	subi	r28, 0x62	; 98
    4f68:	d0 40       	sbci	r29, 0x00	; 0
    4f6a:	cd bf       	out	0x3d, r28	; 61
    4f6c:	de bf       	out	0x3e, r29	; 62
    4f6e:	9e 01       	movw	r18, r28
    4f70:	2e 59       	subi	r18, 0x9E	; 158
    4f72:	3f 4f       	sbci	r19, 0xFF	; 255
    4f74:	f9 01       	movw	r30, r18
    4f76:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4f78:	84 e6       	ldi	r24, 0x64	; 100
    4f7a:	96 e0       	ldi	r25, 0x06	; 6
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	80 81       	ld	r24, Z
    4f80:	88 2f       	mov	r24, r24
    4f82:	90 e0       	ldi	r25, 0x00	; 0
    4f84:	82 70       	andi	r24, 0x02	; 2
    4f86:	90 70       	andi	r25, 0x00	; 0
    4f88:	00 97       	sbiw	r24, 0x00	; 0
    4f8a:	11 f0       	breq	.+4      	; 0x4f90 <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4f8c:	84 e4       	ldi	r24, 0x44	; 68
    4f8e:	91 c4       	rjmp	.+2338   	; 0x58b2 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4f90:	0e 94 4b 22 	call	0x4496	; 0x4496 <chb_get_state>
    4f94:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4f96:	89 81       	ldd	r24, Y+1	; 0x01
    4f98:	82 31       	cpi	r24, 0x12	; 18
    4f9a:	49 f0       	breq	.+18     	; 0x4fae <chb_set_state+0x54>
    4f9c:	89 81       	ldd	r24, Y+1	; 0x01
    4f9e:	81 31       	cpi	r24, 0x11	; 17
    4fa0:	31 f0       	breq	.+12     	; 0x4fae <chb_set_state+0x54>
    4fa2:	89 81       	ldd	r24, Y+1	; 0x01
    4fa4:	81 30       	cpi	r24, 0x01	; 1
    4fa6:	19 f0       	breq	.+6      	; 0x4fae <chb_set_state+0x54>
    4fa8:	89 81       	ldd	r24, Y+1	; 0x01
    4faa:	82 30       	cpi	r24, 0x02	; 2
    4fac:	39 f4       	brne	.+14     	; 0x4fbc <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4fae:	00 00       	nop
    4fb0:	0e 94 4b 22 	call	0x4496	; 0x4496 <chb_get_state>
    4fb4:	98 2f       	mov	r25, r24
    4fb6:	89 81       	ldd	r24, Y+1	; 0x01
    4fb8:	98 17       	cp	r25, r24
    4fba:	d1 f3       	breq	.-12     	; 0x4fb0 <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4fbc:	ce 01       	movw	r24, r28
    4fbe:	8e 59       	subi	r24, 0x9E	; 158
    4fc0:	9f 4f       	sbci	r25, 0xFF	; 255
    4fc2:	fc 01       	movw	r30, r24
    4fc4:	80 81       	ld	r24, Z
    4fc6:	88 2f       	mov	r24, r24
    4fc8:	90 e0       	ldi	r25, 0x00	; 0
    4fca:	86 31       	cpi	r24, 0x16	; 22
    4fcc:	91 05       	cpc	r25, r1
    4fce:	09 f4       	brne	.+2      	; 0x4fd2 <chb_set_state+0x78>
    4fd0:	cd c1       	rjmp	.+922    	; 0x536c <chb_set_state+0x412>
    4fd2:	89 31       	cpi	r24, 0x19	; 25
    4fd4:	91 05       	cpc	r25, r1
    4fd6:	09 f4       	brne	.+2      	; 0x4fda <chb_set_state+0x80>
    4fd8:	e9 c0       	rjmp	.+466    	; 0x51ac <chb_set_state+0x252>
    4fda:	88 30       	cpi	r24, 0x08	; 8
    4fdc:	91 05       	cpc	r25, r1
    4fde:	09 f0       	breq	.+2      	; 0x4fe2 <chb_set_state+0x88>
    4fe0:	f7 c2       	rjmp	.+1518   	; 0x55d0 <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4fe2:	84 e6       	ldi	r24, 0x64	; 100
    4fe4:	96 e0       	ldi	r25, 0x06	; 6
    4fe6:	24 e6       	ldi	r18, 0x64	; 100
    4fe8:	36 e0       	ldi	r19, 0x06	; 6
    4fea:	f9 01       	movw	r30, r18
    4fec:	20 81       	ld	r18, Z
    4fee:	2d 7f       	andi	r18, 0xFD	; 253
    4ff0:	fc 01       	movw	r30, r24
    4ff2:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4ff4:	82 e0       	ldi	r24, 0x02	; 2
    4ff6:	63 e0       	ldi	r22, 0x03	; 3
    4ff8:	4f e1       	ldi	r20, 0x1F	; 31
    4ffa:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
    4ffe:	80 e0       	ldi	r24, 0x00	; 0
    5000:	90 e0       	ldi	r25, 0x00	; 0
    5002:	a0 e8       	ldi	r26, 0x80	; 128
    5004:	bf e3       	ldi	r27, 0x3F	; 63
    5006:	8a 83       	std	Y+2, r24	; 0x02
    5008:	9b 83       	std	Y+3, r25	; 0x03
    500a:	ac 83       	std	Y+4, r26	; 0x04
    500c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    500e:	6a 81       	ldd	r22, Y+2	; 0x02
    5010:	7b 81       	ldd	r23, Y+3	; 0x03
    5012:	8c 81       	ldd	r24, Y+4	; 0x04
    5014:	9d 81       	ldd	r25, Y+5	; 0x05
    5016:	2b ea       	ldi	r18, 0xAB	; 171
    5018:	3a ea       	ldi	r19, 0xAA	; 170
    501a:	4a e2       	ldi	r20, 0x2A	; 42
    501c:	51 e4       	ldi	r21, 0x41	; 65
    501e:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    5022:	dc 01       	movw	r26, r24
    5024:	cb 01       	movw	r24, r22
    5026:	8e 83       	std	Y+6, r24	; 0x06
    5028:	9f 83       	std	Y+7, r25	; 0x07
    502a:	a8 87       	std	Y+8, r26	; 0x08
    502c:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    502e:	11 e0       	ldi	r17, 0x01	; 1
    5030:	6e 81       	ldd	r22, Y+6	; 0x06
    5032:	7f 81       	ldd	r23, Y+7	; 0x07
    5034:	88 85       	ldd	r24, Y+8	; 0x08
    5036:	99 85       	ldd	r25, Y+9	; 0x09
    5038:	20 e0       	ldi	r18, 0x00	; 0
    503a:	30 e0       	ldi	r19, 0x00	; 0
    503c:	40 e8       	ldi	r20, 0x80	; 128
    503e:	5f e3       	ldi	r21, 0x3F	; 63
    5040:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    5044:	88 23       	and	r24, r24
    5046:	0c f0       	brlt	.+2      	; 0x504a <chb_set_state+0xf0>
    5048:	10 e0       	ldi	r17, 0x00	; 0
    504a:	11 23       	and	r17, r17
    504c:	19 f0       	breq	.+6      	; 0x5054 <chb_set_state+0xfa>
		__ticks = 1;
    504e:	81 e0       	ldi	r24, 0x01	; 1
    5050:	8a 87       	std	Y+10, r24	; 0x0a
    5052:	a3 c0       	rjmp	.+326    	; 0x519a <chb_set_state+0x240>
	else if (__tmp > 255)
    5054:	11 e0       	ldi	r17, 0x01	; 1
    5056:	6e 81       	ldd	r22, Y+6	; 0x06
    5058:	7f 81       	ldd	r23, Y+7	; 0x07
    505a:	88 85       	ldd	r24, Y+8	; 0x08
    505c:	99 85       	ldd	r25, Y+9	; 0x09
    505e:	20 e0       	ldi	r18, 0x00	; 0
    5060:	30 e0       	ldi	r19, 0x00	; 0
    5062:	4f e7       	ldi	r20, 0x7F	; 127
    5064:	53 e4       	ldi	r21, 0x43	; 67
    5066:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    506a:	18 16       	cp	r1, r24
    506c:	0c f0       	brlt	.+2      	; 0x5070 <chb_set_state+0x116>
    506e:	10 e0       	ldi	r17, 0x00	; 0
    5070:	11 23       	and	r17, r17
    5072:	09 f4       	brne	.+2      	; 0x5076 <chb_set_state+0x11c>
    5074:	89 c0       	rjmp	.+274    	; 0x5188 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    5076:	6a 81       	ldd	r22, Y+2	; 0x02
    5078:	7b 81       	ldd	r23, Y+3	; 0x03
    507a:	8c 81       	ldd	r24, Y+4	; 0x04
    507c:	9d 81       	ldd	r25, Y+5	; 0x05
    507e:	20 e0       	ldi	r18, 0x00	; 0
    5080:	30 e0       	ldi	r19, 0x00	; 0
    5082:	4a e7       	ldi	r20, 0x7A	; 122
    5084:	54 e4       	ldi	r21, 0x44	; 68
    5086:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    508a:	dc 01       	movw	r26, r24
    508c:	cb 01       	movw	r24, r22
    508e:	8b 87       	std	Y+11, r24	; 0x0b
    5090:	9c 87       	std	Y+12, r25	; 0x0c
    5092:	ad 87       	std	Y+13, r26	; 0x0d
    5094:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5096:	6b 85       	ldd	r22, Y+11	; 0x0b
    5098:	7c 85       	ldd	r23, Y+12	; 0x0c
    509a:	8d 85       	ldd	r24, Y+13	; 0x0d
    509c:	9e 85       	ldd	r25, Y+14	; 0x0e
    509e:	20 e0       	ldi	r18, 0x00	; 0
    50a0:	30 e0       	ldi	r19, 0x00	; 0
    50a2:	4a ef       	ldi	r20, 0xFA	; 250
    50a4:	55 e4       	ldi	r21, 0x45	; 69
    50a6:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    50aa:	dc 01       	movw	r26, r24
    50ac:	cb 01       	movw	r24, r22
    50ae:	8f 87       	std	Y+15, r24	; 0x0f
    50b0:	98 8b       	std	Y+16, r25	; 0x10
    50b2:	a9 8b       	std	Y+17, r26	; 0x11
    50b4:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    50b6:	11 e0       	ldi	r17, 0x01	; 1
    50b8:	6f 85       	ldd	r22, Y+15	; 0x0f
    50ba:	78 89       	ldd	r23, Y+16	; 0x10
    50bc:	89 89       	ldd	r24, Y+17	; 0x11
    50be:	9a 89       	ldd	r25, Y+18	; 0x12
    50c0:	20 e0       	ldi	r18, 0x00	; 0
    50c2:	30 e0       	ldi	r19, 0x00	; 0
    50c4:	40 e8       	ldi	r20, 0x80	; 128
    50c6:	5f e3       	ldi	r21, 0x3F	; 63
    50c8:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    50cc:	88 23       	and	r24, r24
    50ce:	0c f0       	brlt	.+2      	; 0x50d2 <chb_set_state+0x178>
    50d0:	10 e0       	ldi	r17, 0x00	; 0
    50d2:	11 23       	and	r17, r17
    50d4:	29 f0       	breq	.+10     	; 0x50e0 <chb_set_state+0x186>
		__ticks = 1;
    50d6:	81 e0       	ldi	r24, 0x01	; 1
    50d8:	90 e0       	ldi	r25, 0x00	; 0
    50da:	8b 8b       	std	Y+19, r24	; 0x13
    50dc:	9c 8b       	std	Y+20, r25	; 0x14
    50de:	46 c0       	rjmp	.+140    	; 0x516c <chb_set_state+0x212>
	else if (__tmp > 65535)
    50e0:	11 e0       	ldi	r17, 0x01	; 1
    50e2:	6f 85       	ldd	r22, Y+15	; 0x0f
    50e4:	78 89       	ldd	r23, Y+16	; 0x10
    50e6:	89 89       	ldd	r24, Y+17	; 0x11
    50e8:	9a 89       	ldd	r25, Y+18	; 0x12
    50ea:	20 e0       	ldi	r18, 0x00	; 0
    50ec:	3f ef       	ldi	r19, 0xFF	; 255
    50ee:	4f e7       	ldi	r20, 0x7F	; 127
    50f0:	57 e4       	ldi	r21, 0x47	; 71
    50f2:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    50f6:	18 16       	cp	r1, r24
    50f8:	0c f0       	brlt	.+2      	; 0x50fc <chb_set_state+0x1a2>
    50fa:	10 e0       	ldi	r17, 0x00	; 0
    50fc:	11 23       	and	r17, r17
    50fe:	61 f1       	breq	.+88     	; 0x5158 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5100:	6b 85       	ldd	r22, Y+11	; 0x0b
    5102:	7c 85       	ldd	r23, Y+12	; 0x0c
    5104:	8d 85       	ldd	r24, Y+13	; 0x0d
    5106:	9e 85       	ldd	r25, Y+14	; 0x0e
    5108:	20 e0       	ldi	r18, 0x00	; 0
    510a:	30 e0       	ldi	r19, 0x00	; 0
    510c:	40 e2       	ldi	r20, 0x20	; 32
    510e:	51 e4       	ldi	r21, 0x41	; 65
    5110:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    5114:	dc 01       	movw	r26, r24
    5116:	cb 01       	movw	r24, r22
    5118:	bc 01       	movw	r22, r24
    511a:	cd 01       	movw	r24, r26
    511c:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5120:	dc 01       	movw	r26, r24
    5122:	cb 01       	movw	r24, r22
    5124:	8b 8b       	std	Y+19, r24	; 0x13
    5126:	9c 8b       	std	Y+20, r25	; 0x14
    5128:	12 c0       	rjmp	.+36     	; 0x514e <chb_set_state+0x1f4>
    512a:	80 e2       	ldi	r24, 0x20	; 32
    512c:	93 e0       	ldi	r25, 0x03	; 3
    512e:	8d 8b       	std	Y+21, r24	; 0x15
    5130:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5132:	8d 89       	ldd	r24, Y+21	; 0x15
    5134:	9e 89       	ldd	r25, Y+22	; 0x16
    5136:	8c 01       	movw	r16, r24
    5138:	c8 01       	movw	r24, r16
    513a:	01 97       	sbiw	r24, 0x01	; 1
    513c:	f1 f7       	brne	.-4      	; 0x513a <chb_set_state+0x1e0>
    513e:	8c 01       	movw	r16, r24
    5140:	0d 8b       	std	Y+21, r16	; 0x15
    5142:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5144:	8b 89       	ldd	r24, Y+19	; 0x13
    5146:	9c 89       	ldd	r25, Y+20	; 0x14
    5148:	01 97       	sbiw	r24, 0x01	; 1
    514a:	8b 8b       	std	Y+19, r24	; 0x13
    514c:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    514e:	8b 89       	ldd	r24, Y+19	; 0x13
    5150:	9c 89       	ldd	r25, Y+20	; 0x14
    5152:	00 97       	sbiw	r24, 0x00	; 0
    5154:	51 f7       	brne	.-44     	; 0x512a <chb_set_state+0x1d0>
    5156:	29 c0       	rjmp	.+82     	; 0x51aa <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5158:	6f 85       	ldd	r22, Y+15	; 0x0f
    515a:	78 89       	ldd	r23, Y+16	; 0x10
    515c:	89 89       	ldd	r24, Y+17	; 0x11
    515e:	9a 89       	ldd	r25, Y+18	; 0x12
    5160:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5164:	dc 01       	movw	r26, r24
    5166:	cb 01       	movw	r24, r22
    5168:	8b 8b       	std	Y+19, r24	; 0x13
    516a:	9c 8b       	std	Y+20, r25	; 0x14
    516c:	8b 89       	ldd	r24, Y+19	; 0x13
    516e:	9c 89       	ldd	r25, Y+20	; 0x14
    5170:	8f 8b       	std	Y+23, r24	; 0x17
    5172:	98 8f       	std	Y+24, r25	; 0x18
    5174:	8f 89       	ldd	r24, Y+23	; 0x17
    5176:	98 8d       	ldd	r25, Y+24	; 0x18
    5178:	8c 01       	movw	r16, r24
    517a:	f8 01       	movw	r30, r16
    517c:	31 97       	sbiw	r30, 0x01	; 1
    517e:	f1 f7       	brne	.-4      	; 0x517c <chb_set_state+0x222>
    5180:	8f 01       	movw	r16, r30
    5182:	0f 8b       	std	Y+23, r16	; 0x17
    5184:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    5186:	24 c2       	rjmp	.+1096   	; 0x55d0 <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5188:	6e 81       	ldd	r22, Y+6	; 0x06
    518a:	7f 81       	ldd	r23, Y+7	; 0x07
    518c:	88 85       	ldd	r24, Y+8	; 0x08
    518e:	99 85       	ldd	r25, Y+9	; 0x09
    5190:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5194:	dc 01       	movw	r26, r24
    5196:	cb 01       	movw	r24, r22
    5198:	8a 87       	std	Y+10, r24	; 0x0a
    519a:	8a 85       	ldd	r24, Y+10	; 0x0a
    519c:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    519e:	89 8d       	ldd	r24, Y+25	; 0x19
    51a0:	18 2f       	mov	r17, r24
    51a2:	1a 95       	dec	r17
    51a4:	f1 f7       	brne	.-4      	; 0x51a2 <chb_set_state+0x248>
    51a6:	19 8f       	std	Y+25, r17	; 0x19
    51a8:	13 c2       	rjmp	.+1062   	; 0x55d0 <chb_set_state+0x676>
    51aa:	12 c2       	rjmp	.+1060   	; 0x55d0 <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    51ac:	89 81       	ldd	r24, Y+1	; 0x01
    51ae:	86 31       	cpi	r24, 0x16	; 22
    51b0:	09 f0       	breq	.+2      	; 0x51b4 <chb_set_state+0x25a>
    51b2:	0b c2       	rjmp	.+1046   	; 0x55ca <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    51b4:	82 e0       	ldi	r24, 0x02	; 2
    51b6:	69 e0       	ldi	r22, 0x09	; 9
    51b8:	4f e1       	ldi	r20, 0x1F	; 31
    51ba:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
    51be:	80 e0       	ldi	r24, 0x00	; 0
    51c0:	90 e0       	ldi	r25, 0x00	; 0
    51c2:	a0 e8       	ldi	r26, 0x80	; 128
    51c4:	bf e3       	ldi	r27, 0x3F	; 63
    51c6:	8a 8f       	std	Y+26, r24	; 0x1a
    51c8:	9b 8f       	std	Y+27, r25	; 0x1b
    51ca:	ac 8f       	std	Y+28, r26	; 0x1c
    51cc:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    51ce:	6a 8d       	ldd	r22, Y+26	; 0x1a
    51d0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    51d2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    51d4:	9d 8d       	ldd	r25, Y+29	; 0x1d
    51d6:	2b ea       	ldi	r18, 0xAB	; 171
    51d8:	3a ea       	ldi	r19, 0xAA	; 170
    51da:	4a e2       	ldi	r20, 0x2A	; 42
    51dc:	51 e4       	ldi	r21, 0x41	; 65
    51de:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    51e2:	dc 01       	movw	r26, r24
    51e4:	cb 01       	movw	r24, r22
    51e6:	8e 8f       	std	Y+30, r24	; 0x1e
    51e8:	9f 8f       	std	Y+31, r25	; 0x1f
    51ea:	a8 a3       	lds	r26, 0x58
    51ec:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    51ee:	11 e0       	ldi	r17, 0x01	; 1
    51f0:	6e 8d       	ldd	r22, Y+30	; 0x1e
    51f2:	7f 8d       	ldd	r23, Y+31	; 0x1f
    51f4:	88 a1       	lds	r24, 0x48
    51f6:	99 a1       	lds	r25, 0x49
    51f8:	20 e0       	ldi	r18, 0x00	; 0
    51fa:	30 e0       	ldi	r19, 0x00	; 0
    51fc:	40 e8       	ldi	r20, 0x80	; 128
    51fe:	5f e3       	ldi	r21, 0x3F	; 63
    5200:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    5204:	88 23       	and	r24, r24
    5206:	0c f0       	brlt	.+2      	; 0x520a <chb_set_state+0x2b0>
    5208:	10 e0       	ldi	r17, 0x00	; 0
    520a:	11 23       	and	r17, r17
    520c:	19 f0       	breq	.+6      	; 0x5214 <chb_set_state+0x2ba>
		__ticks = 1;
    520e:	81 e0       	ldi	r24, 0x01	; 1
    5210:	8a a3       	lds	r24, 0x5a
    5212:	a3 c0       	rjmp	.+326    	; 0x535a <chb_set_state+0x400>
	else if (__tmp > 255)
    5214:	11 e0       	ldi	r17, 0x01	; 1
    5216:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5218:	7f 8d       	ldd	r23, Y+31	; 0x1f
    521a:	88 a1       	lds	r24, 0x48
    521c:	99 a1       	lds	r25, 0x49
    521e:	20 e0       	ldi	r18, 0x00	; 0
    5220:	30 e0       	ldi	r19, 0x00	; 0
    5222:	4f e7       	ldi	r20, 0x7F	; 127
    5224:	53 e4       	ldi	r21, 0x43	; 67
    5226:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    522a:	18 16       	cp	r1, r24
    522c:	0c f0       	brlt	.+2      	; 0x5230 <chb_set_state+0x2d6>
    522e:	10 e0       	ldi	r17, 0x00	; 0
    5230:	11 23       	and	r17, r17
    5232:	09 f4       	brne	.+2      	; 0x5236 <chb_set_state+0x2dc>
    5234:	89 c0       	rjmp	.+274    	; 0x5348 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    5236:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5238:	7b 8d       	ldd	r23, Y+27	; 0x1b
    523a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    523c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    523e:	20 e0       	ldi	r18, 0x00	; 0
    5240:	30 e0       	ldi	r19, 0x00	; 0
    5242:	4a e7       	ldi	r20, 0x7A	; 122
    5244:	54 e4       	ldi	r21, 0x44	; 68
    5246:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    524a:	dc 01       	movw	r26, r24
    524c:	cb 01       	movw	r24, r22
    524e:	8b a3       	lds	r24, 0x5b
    5250:	9c a3       	lds	r25, 0x5c
    5252:	ad a3       	lds	r26, 0x5d
    5254:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5256:	6b a1       	lds	r22, 0x4b
    5258:	7c a1       	lds	r23, 0x4c
    525a:	8d a1       	lds	r24, 0x4d
    525c:	9e a1       	lds	r25, 0x4e
    525e:	20 e0       	ldi	r18, 0x00	; 0
    5260:	30 e0       	ldi	r19, 0x00	; 0
    5262:	4a ef       	ldi	r20, 0xFA	; 250
    5264:	55 e4       	ldi	r21, 0x45	; 69
    5266:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    526a:	dc 01       	movw	r26, r24
    526c:	cb 01       	movw	r24, r22
    526e:	8f a3       	lds	r24, 0x5f
    5270:	98 a7       	lds	r25, 0x78
    5272:	a9 a7       	lds	r26, 0x79
    5274:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    5276:	11 e0       	ldi	r17, 0x01	; 1
    5278:	6f a1       	lds	r22, 0x4f
    527a:	78 a5       	lds	r23, 0x68
    527c:	89 a5       	lds	r24, 0x69
    527e:	9a a5       	lds	r25, 0x6a
    5280:	20 e0       	ldi	r18, 0x00	; 0
    5282:	30 e0       	ldi	r19, 0x00	; 0
    5284:	40 e8       	ldi	r20, 0x80	; 128
    5286:	5f e3       	ldi	r21, 0x3F	; 63
    5288:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    528c:	88 23       	and	r24, r24
    528e:	0c f0       	brlt	.+2      	; 0x5292 <chb_set_state+0x338>
    5290:	10 e0       	ldi	r17, 0x00	; 0
    5292:	11 23       	and	r17, r17
    5294:	29 f0       	breq	.+10     	; 0x52a0 <chb_set_state+0x346>
		__ticks = 1;
    5296:	81 e0       	ldi	r24, 0x01	; 1
    5298:	90 e0       	ldi	r25, 0x00	; 0
    529a:	8b a7       	lds	r24, 0x7b
    529c:	9c a7       	lds	r25, 0x7c
    529e:	46 c0       	rjmp	.+140    	; 0x532c <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    52a0:	11 e0       	ldi	r17, 0x01	; 1
    52a2:	6f a1       	lds	r22, 0x4f
    52a4:	78 a5       	lds	r23, 0x68
    52a6:	89 a5       	lds	r24, 0x69
    52a8:	9a a5       	lds	r25, 0x6a
    52aa:	20 e0       	ldi	r18, 0x00	; 0
    52ac:	3f ef       	ldi	r19, 0xFF	; 255
    52ae:	4f e7       	ldi	r20, 0x7F	; 127
    52b0:	57 e4       	ldi	r21, 0x47	; 71
    52b2:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    52b6:	18 16       	cp	r1, r24
    52b8:	0c f0       	brlt	.+2      	; 0x52bc <chb_set_state+0x362>
    52ba:	10 e0       	ldi	r17, 0x00	; 0
    52bc:	11 23       	and	r17, r17
    52be:	61 f1       	breq	.+88     	; 0x5318 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    52c0:	6b a1       	lds	r22, 0x4b
    52c2:	7c a1       	lds	r23, 0x4c
    52c4:	8d a1       	lds	r24, 0x4d
    52c6:	9e a1       	lds	r25, 0x4e
    52c8:	20 e0       	ldi	r18, 0x00	; 0
    52ca:	30 e0       	ldi	r19, 0x00	; 0
    52cc:	40 e2       	ldi	r20, 0x20	; 32
    52ce:	51 e4       	ldi	r21, 0x41	; 65
    52d0:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    52d4:	dc 01       	movw	r26, r24
    52d6:	cb 01       	movw	r24, r22
    52d8:	bc 01       	movw	r22, r24
    52da:	cd 01       	movw	r24, r26
    52dc:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    52e0:	dc 01       	movw	r26, r24
    52e2:	cb 01       	movw	r24, r22
    52e4:	8b a7       	lds	r24, 0x7b
    52e6:	9c a7       	lds	r25, 0x7c
    52e8:	12 c0       	rjmp	.+36     	; 0x530e <chb_set_state+0x3b4>
    52ea:	80 e2       	ldi	r24, 0x20	; 32
    52ec:	93 e0       	ldi	r25, 0x03	; 3
    52ee:	8d a7       	lds	r24, 0x7d
    52f0:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    52f2:	8d a5       	lds	r24, 0x6d
    52f4:	9e a5       	lds	r25, 0x6e
    52f6:	8c 01       	movw	r16, r24
    52f8:	c8 01       	movw	r24, r16
    52fa:	01 97       	sbiw	r24, 0x01	; 1
    52fc:	f1 f7       	brne	.-4      	; 0x52fa <chb_set_state+0x3a0>
    52fe:	8c 01       	movw	r16, r24
    5300:	0d a7       	lds	r16, 0x7d
    5302:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5304:	8b a5       	lds	r24, 0x6b
    5306:	9c a5       	lds	r25, 0x6c
    5308:	01 97       	sbiw	r24, 0x01	; 1
    530a:	8b a7       	lds	r24, 0x7b
    530c:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    530e:	8b a5       	lds	r24, 0x6b
    5310:	9c a5       	lds	r25, 0x6c
    5312:	00 97       	sbiw	r24, 0x00	; 0
    5314:	51 f7       	brne	.-44     	; 0x52ea <chb_set_state+0x390>
    5316:	29 c0       	rjmp	.+82     	; 0x536a <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5318:	6f a1       	lds	r22, 0x4f
    531a:	78 a5       	lds	r23, 0x68
    531c:	89 a5       	lds	r24, 0x69
    531e:	9a a5       	lds	r25, 0x6a
    5320:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5324:	dc 01       	movw	r26, r24
    5326:	cb 01       	movw	r24, r22
    5328:	8b a7       	lds	r24, 0x7b
    532a:	9c a7       	lds	r25, 0x7c
    532c:	8b a5       	lds	r24, 0x6b
    532e:	9c a5       	lds	r25, 0x6c
    5330:	8f a7       	lds	r24, 0x7f
    5332:	98 ab       	sts	0x58, r25
    5334:	8f a5       	lds	r24, 0x6f
    5336:	98 a9       	sts	0x48, r25
    5338:	8c 01       	movw	r16, r24
    533a:	f8 01       	movw	r30, r16
    533c:	31 97       	sbiw	r30, 0x01	; 1
    533e:	f1 f7       	brne	.-4      	; 0x533c <chb_set_state+0x3e2>
    5340:	8f 01       	movw	r16, r30
    5342:	0f a7       	lds	r16, 0x7f
    5344:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5346:	41 c1       	rjmp	.+642    	; 0x55ca <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5348:	6e 8d       	ldd	r22, Y+30	; 0x1e
    534a:	7f 8d       	ldd	r23, Y+31	; 0x1f
    534c:	88 a1       	lds	r24, 0x48
    534e:	99 a1       	lds	r25, 0x49
    5350:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5354:	dc 01       	movw	r26, r24
    5356:	cb 01       	movw	r24, r22
    5358:	8a a3       	lds	r24, 0x5a
    535a:	8a a1       	lds	r24, 0x4a
    535c:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    535e:	89 a9       	sts	0x49, r24
    5360:	18 2f       	mov	r17, r24
    5362:	1a 95       	dec	r17
    5364:	f1 f7       	brne	.-4      	; 0x5362 <chb_set_state+0x408>
    5366:	19 ab       	sts	0x59, r17
    5368:	30 c1       	rjmp	.+608    	; 0x55ca <chb_set_state+0x670>
    536a:	2f c1       	rjmp	.+606    	; 0x55ca <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    536c:	89 81       	ldd	r24, Y+1	; 0x01
    536e:	89 31       	cpi	r24, 0x19	; 25
    5370:	09 f0       	breq	.+2      	; 0x5374 <chb_set_state+0x41a>
    5372:	2d c1       	rjmp	.+602    	; 0x55ce <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5374:	82 e0       	ldi	r24, 0x02	; 2
    5376:	69 e0       	ldi	r22, 0x09	; 9
    5378:	4f e1       	ldi	r20, 0x1F	; 31
    537a:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
    537e:	80 e0       	ldi	r24, 0x00	; 0
    5380:	90 e0       	ldi	r25, 0x00	; 0
    5382:	a0 e8       	ldi	r26, 0x80	; 128
    5384:	bf e3       	ldi	r27, 0x3F	; 63
    5386:	8a ab       	sts	0x5a, r24
    5388:	9b ab       	sts	0x5b, r25
    538a:	ac ab       	sts	0x5c, r26
    538c:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    538e:	6a a9       	sts	0x4a, r22
    5390:	7b a9       	sts	0x4b, r23
    5392:	8c a9       	sts	0x4c, r24
    5394:	9d a9       	sts	0x4d, r25
    5396:	2b ea       	ldi	r18, 0xAB	; 171
    5398:	3a ea       	ldi	r19, 0xAA	; 170
    539a:	4a e2       	ldi	r20, 0x2A	; 42
    539c:	51 e4       	ldi	r21, 0x41	; 65
    539e:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    53a2:	dc 01       	movw	r26, r24
    53a4:	cb 01       	movw	r24, r22
    53a6:	8e ab       	sts	0x5e, r24
    53a8:	9f ab       	sts	0x5f, r25
    53aa:	a8 af       	sts	0x78, r26
    53ac:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    53ae:	11 e0       	ldi	r17, 0x01	; 1
    53b0:	6e a9       	sts	0x4e, r22
    53b2:	7f a9       	sts	0x4f, r23
    53b4:	88 ad       	sts	0x68, r24
    53b6:	99 ad       	sts	0x69, r25
    53b8:	20 e0       	ldi	r18, 0x00	; 0
    53ba:	30 e0       	ldi	r19, 0x00	; 0
    53bc:	40 e8       	ldi	r20, 0x80	; 128
    53be:	5f e3       	ldi	r21, 0x3F	; 63
    53c0:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    53c4:	88 23       	and	r24, r24
    53c6:	0c f0       	brlt	.+2      	; 0x53ca <chb_set_state+0x470>
    53c8:	10 e0       	ldi	r17, 0x00	; 0
    53ca:	11 23       	and	r17, r17
    53cc:	19 f0       	breq	.+6      	; 0x53d4 <chb_set_state+0x47a>
		__ticks = 1;
    53ce:	81 e0       	ldi	r24, 0x01	; 1
    53d0:	8a af       	sts	0x7a, r24
    53d2:	e6 c0       	rjmp	.+460    	; 0x55a0 <chb_set_state+0x646>
	else if (__tmp > 255)
    53d4:	11 e0       	ldi	r17, 0x01	; 1
    53d6:	6e a9       	sts	0x4e, r22
    53d8:	7f a9       	sts	0x4f, r23
    53da:	88 ad       	sts	0x68, r24
    53dc:	99 ad       	sts	0x69, r25
    53de:	20 e0       	ldi	r18, 0x00	; 0
    53e0:	30 e0       	ldi	r19, 0x00	; 0
    53e2:	4f e7       	ldi	r20, 0x7F	; 127
    53e4:	53 e4       	ldi	r21, 0x43	; 67
    53e6:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    53ea:	18 16       	cp	r1, r24
    53ec:	0c f0       	brlt	.+2      	; 0x53f0 <chb_set_state+0x496>
    53ee:	10 e0       	ldi	r17, 0x00	; 0
    53f0:	11 23       	and	r17, r17
    53f2:	09 f4       	brne	.+2      	; 0x53f6 <chb_set_state+0x49c>
    53f4:	cc c0       	rjmp	.+408    	; 0x558e <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    53f6:	6a a9       	sts	0x4a, r22
    53f8:	7b a9       	sts	0x4b, r23
    53fa:	8c a9       	sts	0x4c, r24
    53fc:	9d a9       	sts	0x4d, r25
    53fe:	20 e0       	ldi	r18, 0x00	; 0
    5400:	30 e0       	ldi	r19, 0x00	; 0
    5402:	4a e7       	ldi	r20, 0x7A	; 122
    5404:	54 e4       	ldi	r21, 0x44	; 68
    5406:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    540a:	dc 01       	movw	r26, r24
    540c:	cb 01       	movw	r24, r22
    540e:	8b af       	sts	0x7b, r24
    5410:	9c af       	sts	0x7c, r25
    5412:	ad af       	sts	0x7d, r26
    5414:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5416:	8e 01       	movw	r16, r28
    5418:	01 5c       	subi	r16, 0xC1	; 193
    541a:	1f 4f       	sbci	r17, 0xFF	; 255
    541c:	6b ad       	sts	0x6b, r22
    541e:	7c ad       	sts	0x6c, r23
    5420:	8d ad       	sts	0x6d, r24
    5422:	9e ad       	sts	0x6e, r25
    5424:	20 e0       	ldi	r18, 0x00	; 0
    5426:	30 e0       	ldi	r19, 0x00	; 0
    5428:	4a ef       	ldi	r20, 0xFA	; 250
    542a:	55 e4       	ldi	r21, 0x45	; 69
    542c:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    5430:	dc 01       	movw	r26, r24
    5432:	cb 01       	movw	r24, r22
    5434:	f8 01       	movw	r30, r16
    5436:	80 83       	st	Z, r24
    5438:	91 83       	std	Z+1, r25	; 0x01
    543a:	a2 83       	std	Z+2, r26	; 0x02
    543c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    543e:	ce 01       	movw	r24, r28
    5440:	cf 96       	adiw	r24, 0x3f	; 63
    5442:	11 e0       	ldi	r17, 0x01	; 1
    5444:	fc 01       	movw	r30, r24
    5446:	60 81       	ld	r22, Z
    5448:	71 81       	ldd	r23, Z+1	; 0x01
    544a:	82 81       	ldd	r24, Z+2	; 0x02
    544c:	93 81       	ldd	r25, Z+3	; 0x03
    544e:	20 e0       	ldi	r18, 0x00	; 0
    5450:	30 e0       	ldi	r19, 0x00	; 0
    5452:	40 e8       	ldi	r20, 0x80	; 128
    5454:	5f e3       	ldi	r21, 0x3F	; 63
    5456:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    545a:	88 23       	and	r24, r24
    545c:	0c f0       	brlt	.+2      	; 0x5460 <chb_set_state+0x506>
    545e:	10 e0       	ldi	r17, 0x00	; 0
    5460:	11 23       	and	r17, r17
    5462:	49 f0       	breq	.+18     	; 0x5476 <chb_set_state+0x51c>
		__ticks = 1;
    5464:	ce 01       	movw	r24, r28
    5466:	8d 5b       	subi	r24, 0xBD	; 189
    5468:	9f 4f       	sbci	r25, 0xFF	; 255
    546a:	21 e0       	ldi	r18, 0x01	; 1
    546c:	30 e0       	ldi	r19, 0x00	; 0
    546e:	fc 01       	movw	r30, r24
    5470:	20 83       	st	Z, r18
    5472:	31 83       	std	Z+1, r19	; 0x01
    5474:	6e c0       	rjmp	.+220    	; 0x5552 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    5476:	ce 01       	movw	r24, r28
    5478:	cf 96       	adiw	r24, 0x3f	; 63
    547a:	11 e0       	ldi	r17, 0x01	; 1
    547c:	fc 01       	movw	r30, r24
    547e:	60 81       	ld	r22, Z
    5480:	71 81       	ldd	r23, Z+1	; 0x01
    5482:	82 81       	ldd	r24, Z+2	; 0x02
    5484:	93 81       	ldd	r25, Z+3	; 0x03
    5486:	20 e0       	ldi	r18, 0x00	; 0
    5488:	3f ef       	ldi	r19, 0xFF	; 255
    548a:	4f e7       	ldi	r20, 0x7F	; 127
    548c:	57 e4       	ldi	r21, 0x47	; 71
    548e:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    5492:	18 16       	cp	r1, r24
    5494:	0c f0       	brlt	.+2      	; 0x5498 <chb_set_state+0x53e>
    5496:	10 e0       	ldi	r17, 0x00	; 0
    5498:	11 23       	and	r17, r17
    549a:	09 f4       	brne	.+2      	; 0x549e <chb_set_state+0x544>
    549c:	49 c0       	rjmp	.+146    	; 0x5530 <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    549e:	6b ad       	sts	0x6b, r22
    54a0:	7c ad       	sts	0x6c, r23
    54a2:	8d ad       	sts	0x6d, r24
    54a4:	9e ad       	sts	0x6e, r25
    54a6:	20 e0       	ldi	r18, 0x00	; 0
    54a8:	30 e0       	ldi	r19, 0x00	; 0
    54aa:	40 e2       	ldi	r20, 0x20	; 32
    54ac:	51 e4       	ldi	r21, 0x41	; 65
    54ae:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    54b2:	dc 01       	movw	r26, r24
    54b4:	cb 01       	movw	r24, r22
    54b6:	8e 01       	movw	r16, r28
    54b8:	0d 5b       	subi	r16, 0xBD	; 189
    54ba:	1f 4f       	sbci	r17, 0xFF	; 255
    54bc:	bc 01       	movw	r22, r24
    54be:	cd 01       	movw	r24, r26
    54c0:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    54c4:	dc 01       	movw	r26, r24
    54c6:	cb 01       	movw	r24, r22
    54c8:	f8 01       	movw	r30, r16
    54ca:	80 83       	st	Z, r24
    54cc:	91 83       	std	Z+1, r25	; 0x01
    54ce:	27 c0       	rjmp	.+78     	; 0x551e <chb_set_state+0x5c4>
    54d0:	ce 01       	movw	r24, r28
    54d2:	8b 5b       	subi	r24, 0xBB	; 187
    54d4:	9f 4f       	sbci	r25, 0xFF	; 255
    54d6:	20 e2       	ldi	r18, 0x20	; 32
    54d8:	33 e0       	ldi	r19, 0x03	; 3
    54da:	fc 01       	movw	r30, r24
    54dc:	20 83       	st	Z, r18
    54de:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    54e0:	ce 01       	movw	r24, r28
    54e2:	8b 5b       	subi	r24, 0xBB	; 187
    54e4:	9f 4f       	sbci	r25, 0xFF	; 255
    54e6:	fc 01       	movw	r30, r24
    54e8:	80 81       	ld	r24, Z
    54ea:	91 81       	ldd	r25, Z+1	; 0x01
    54ec:	8c 01       	movw	r16, r24
    54ee:	c8 01       	movw	r24, r16
    54f0:	01 97       	sbiw	r24, 0x01	; 1
    54f2:	f1 f7       	brne	.-4      	; 0x54f0 <chb_set_state+0x596>
    54f4:	8c 01       	movw	r16, r24
    54f6:	ce 01       	movw	r24, r28
    54f8:	8b 5b       	subi	r24, 0xBB	; 187
    54fa:	9f 4f       	sbci	r25, 0xFF	; 255
    54fc:	fc 01       	movw	r30, r24
    54fe:	00 83       	st	Z, r16
    5500:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5502:	ce 01       	movw	r24, r28
    5504:	8d 5b       	subi	r24, 0xBD	; 189
    5506:	9f 4f       	sbci	r25, 0xFF	; 255
    5508:	9e 01       	movw	r18, r28
    550a:	2d 5b       	subi	r18, 0xBD	; 189
    550c:	3f 4f       	sbci	r19, 0xFF	; 255
    550e:	f9 01       	movw	r30, r18
    5510:	20 81       	ld	r18, Z
    5512:	31 81       	ldd	r19, Z+1	; 0x01
    5514:	21 50       	subi	r18, 0x01	; 1
    5516:	30 40       	sbci	r19, 0x00	; 0
    5518:	fc 01       	movw	r30, r24
    551a:	20 83       	st	Z, r18
    551c:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    551e:	ce 01       	movw	r24, r28
    5520:	8d 5b       	subi	r24, 0xBD	; 189
    5522:	9f 4f       	sbci	r25, 0xFF	; 255
    5524:	fc 01       	movw	r30, r24
    5526:	80 81       	ld	r24, Z
    5528:	91 81       	ldd	r25, Z+1	; 0x01
    552a:	00 97       	sbiw	r24, 0x00	; 0
    552c:	89 f6       	brne	.-94     	; 0x54d0 <chb_set_state+0x576>
    552e:	4c c0       	rjmp	.+152    	; 0x55c8 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5530:	8e 01       	movw	r16, r28
    5532:	0d 5b       	subi	r16, 0xBD	; 189
    5534:	1f 4f       	sbci	r17, 0xFF	; 255
    5536:	ce 01       	movw	r24, r28
    5538:	cf 96       	adiw	r24, 0x3f	; 63
    553a:	fc 01       	movw	r30, r24
    553c:	60 81       	ld	r22, Z
    553e:	71 81       	ldd	r23, Z+1	; 0x01
    5540:	82 81       	ldd	r24, Z+2	; 0x02
    5542:	93 81       	ldd	r25, Z+3	; 0x03
    5544:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5548:	dc 01       	movw	r26, r24
    554a:	cb 01       	movw	r24, r22
    554c:	f8 01       	movw	r30, r16
    554e:	80 83       	st	Z, r24
    5550:	91 83       	std	Z+1, r25	; 0x01
    5552:	ce 01       	movw	r24, r28
    5554:	89 5b       	subi	r24, 0xB9	; 185
    5556:	9f 4f       	sbci	r25, 0xFF	; 255
    5558:	9e 01       	movw	r18, r28
    555a:	2d 5b       	subi	r18, 0xBD	; 189
    555c:	3f 4f       	sbci	r19, 0xFF	; 255
    555e:	f9 01       	movw	r30, r18
    5560:	20 81       	ld	r18, Z
    5562:	31 81       	ldd	r19, Z+1	; 0x01
    5564:	fc 01       	movw	r30, r24
    5566:	20 83       	st	Z, r18
    5568:	31 83       	std	Z+1, r19	; 0x01
    556a:	ce 01       	movw	r24, r28
    556c:	89 5b       	subi	r24, 0xB9	; 185
    556e:	9f 4f       	sbci	r25, 0xFF	; 255
    5570:	fc 01       	movw	r30, r24
    5572:	80 81       	ld	r24, Z
    5574:	91 81       	ldd	r25, Z+1	; 0x01
    5576:	8c 01       	movw	r16, r24
    5578:	c8 01       	movw	r24, r16
    557a:	01 97       	sbiw	r24, 0x01	; 1
    557c:	f1 f7       	brne	.-4      	; 0x557a <chb_set_state+0x620>
    557e:	8c 01       	movw	r16, r24
    5580:	ce 01       	movw	r24, r28
    5582:	89 5b       	subi	r24, 0xB9	; 185
    5584:	9f 4f       	sbci	r25, 0xFF	; 255
    5586:	fc 01       	movw	r30, r24
    5588:	00 83       	st	Z, r16
    558a:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    558c:	20 c0       	rjmp	.+64     	; 0x55ce <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    558e:	6e a9       	sts	0x4e, r22
    5590:	7f a9       	sts	0x4f, r23
    5592:	88 ad       	sts	0x68, r24
    5594:	99 ad       	sts	0x69, r25
    5596:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    559a:	dc 01       	movw	r26, r24
    559c:	cb 01       	movw	r24, r22
    559e:	8a af       	sts	0x7a, r24
    55a0:	ce 01       	movw	r24, r28
    55a2:	87 5b       	subi	r24, 0xB7	; 183
    55a4:	9f 4f       	sbci	r25, 0xFF	; 255
    55a6:	2a ad       	sts	0x6a, r18
    55a8:	fc 01       	movw	r30, r24
    55aa:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55ac:	ce 01       	movw	r24, r28
    55ae:	87 5b       	subi	r24, 0xB7	; 183
    55b0:	9f 4f       	sbci	r25, 0xFF	; 255
    55b2:	fc 01       	movw	r30, r24
    55b4:	80 81       	ld	r24, Z
    55b6:	18 2f       	mov	r17, r24
    55b8:	1a 95       	dec	r17
    55ba:	f1 f7       	brne	.-4      	; 0x55b8 <chb_set_state+0x65e>
    55bc:	ce 01       	movw	r24, r28
    55be:	87 5b       	subi	r24, 0xB7	; 183
    55c0:	9f 4f       	sbci	r25, 0xFF	; 255
    55c2:	fc 01       	movw	r30, r24
    55c4:	10 83       	st	Z, r17
    55c6:	03 c0       	rjmp	.+6      	; 0x55ce <chb_set_state+0x674>
    55c8:	02 c0       	rjmp	.+4      	; 0x55ce <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    55ca:	00 00       	nop
    55cc:	01 c0       	rjmp	.+2      	; 0x55d0 <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    55ce:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    55d0:	9e 01       	movw	r18, r28
    55d2:	2e 59       	subi	r18, 0x9E	; 158
    55d4:	3f 4f       	sbci	r19, 0xFF	; 255
    55d6:	82 e0       	ldi	r24, 0x02	; 2
    55d8:	f9 01       	movw	r30, r18
    55da:	60 81       	ld	r22, Z
    55dc:	4f e1       	ldi	r20, 0x1F	; 31
    55de:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
    55e2:	9e 01       	movw	r18, r28
    55e4:	26 5b       	subi	r18, 0xB6	; 182
    55e6:	3f 4f       	sbci	r19, 0xFF	; 255
    55e8:	80 e0       	ldi	r24, 0x00	; 0
    55ea:	90 e0       	ldi	r25, 0x00	; 0
    55ec:	ac ed       	ldi	r26, 0xDC	; 220
    55ee:	b2 e4       	ldi	r27, 0x42	; 66
    55f0:	f9 01       	movw	r30, r18
    55f2:	80 83       	st	Z, r24
    55f4:	91 83       	std	Z+1, r25	; 0x01
    55f6:	a2 83       	std	Z+2, r26	; 0x02
    55f8:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    55fa:	8e 01       	movw	r16, r28
    55fc:	02 5b       	subi	r16, 0xB2	; 178
    55fe:	1f 4f       	sbci	r17, 0xFF	; 255
    5600:	ce 01       	movw	r24, r28
    5602:	86 5b       	subi	r24, 0xB6	; 182
    5604:	9f 4f       	sbci	r25, 0xFF	; 255
    5606:	fc 01       	movw	r30, r24
    5608:	60 81       	ld	r22, Z
    560a:	71 81       	ldd	r23, Z+1	; 0x01
    560c:	82 81       	ldd	r24, Z+2	; 0x02
    560e:	93 81       	ldd	r25, Z+3	; 0x03
    5610:	2b ea       	ldi	r18, 0xAB	; 171
    5612:	3a ea       	ldi	r19, 0xAA	; 170
    5614:	4a e2       	ldi	r20, 0x2A	; 42
    5616:	51 e4       	ldi	r21, 0x41	; 65
    5618:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    561c:	dc 01       	movw	r26, r24
    561e:	cb 01       	movw	r24, r22
    5620:	f8 01       	movw	r30, r16
    5622:	80 83       	st	Z, r24
    5624:	91 83       	std	Z+1, r25	; 0x01
    5626:	a2 83       	std	Z+2, r26	; 0x02
    5628:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    562a:	ce 01       	movw	r24, r28
    562c:	82 5b       	subi	r24, 0xB2	; 178
    562e:	9f 4f       	sbci	r25, 0xFF	; 255
    5630:	11 e0       	ldi	r17, 0x01	; 1
    5632:	fc 01       	movw	r30, r24
    5634:	60 81       	ld	r22, Z
    5636:	71 81       	ldd	r23, Z+1	; 0x01
    5638:	82 81       	ldd	r24, Z+2	; 0x02
    563a:	93 81       	ldd	r25, Z+3	; 0x03
    563c:	20 e0       	ldi	r18, 0x00	; 0
    563e:	30 e0       	ldi	r19, 0x00	; 0
    5640:	40 e8       	ldi	r20, 0x80	; 128
    5642:	5f e3       	ldi	r21, 0x3F	; 63
    5644:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    5648:	88 23       	and	r24, r24
    564a:	0c f0       	brlt	.+2      	; 0x564e <chb_set_state+0x6f4>
    564c:	10 e0       	ldi	r17, 0x00	; 0
    564e:	11 23       	and	r17, r17
    5650:	39 f0       	breq	.+14     	; 0x5660 <chb_set_state+0x706>
		__ticks = 1;
    5652:	ce 01       	movw	r24, r28
    5654:	8e 5a       	subi	r24, 0xAE	; 174
    5656:	9f 4f       	sbci	r25, 0xFF	; 255
    5658:	21 e0       	ldi	r18, 0x01	; 1
    565a:	fc 01       	movw	r30, r24
    565c:	20 83       	st	Z, r18
    565e:	05 c1       	rjmp	.+522    	; 0x586a <chb_set_state+0x910>
	else if (__tmp > 255)
    5660:	ce 01       	movw	r24, r28
    5662:	82 5b       	subi	r24, 0xB2	; 178
    5664:	9f 4f       	sbci	r25, 0xFF	; 255
    5666:	11 e0       	ldi	r17, 0x01	; 1
    5668:	fc 01       	movw	r30, r24
    566a:	60 81       	ld	r22, Z
    566c:	71 81       	ldd	r23, Z+1	; 0x01
    566e:	82 81       	ldd	r24, Z+2	; 0x02
    5670:	93 81       	ldd	r25, Z+3	; 0x03
    5672:	20 e0       	ldi	r18, 0x00	; 0
    5674:	30 e0       	ldi	r19, 0x00	; 0
    5676:	4f e7       	ldi	r20, 0x7F	; 127
    5678:	53 e4       	ldi	r21, 0x43	; 67
    567a:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    567e:	18 16       	cp	r1, r24
    5680:	0c f0       	brlt	.+2      	; 0x5684 <chb_set_state+0x72a>
    5682:	10 e0       	ldi	r17, 0x00	; 0
    5684:	11 23       	and	r17, r17
    5686:	09 f4       	brne	.+2      	; 0x568a <chb_set_state+0x730>
    5688:	df c0       	rjmp	.+446    	; 0x5848 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    568a:	ce 01       	movw	r24, r28
    568c:	86 5b       	subi	r24, 0xB6	; 182
    568e:	9f 4f       	sbci	r25, 0xFF	; 255
    5690:	fc 01       	movw	r30, r24
    5692:	60 81       	ld	r22, Z
    5694:	71 81       	ldd	r23, Z+1	; 0x01
    5696:	82 81       	ldd	r24, Z+2	; 0x02
    5698:	93 81       	ldd	r25, Z+3	; 0x03
    569a:	20 e0       	ldi	r18, 0x00	; 0
    569c:	30 e0       	ldi	r19, 0x00	; 0
    569e:	4a e7       	ldi	r20, 0x7A	; 122
    56a0:	54 e4       	ldi	r21, 0x44	; 68
    56a2:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    56a6:	dc 01       	movw	r26, r24
    56a8:	cb 01       	movw	r24, r22
    56aa:	9e 01       	movw	r18, r28
    56ac:	2d 5a       	subi	r18, 0xAD	; 173
    56ae:	3f 4f       	sbci	r19, 0xFF	; 255
    56b0:	f9 01       	movw	r30, r18
    56b2:	80 83       	st	Z, r24
    56b4:	91 83       	std	Z+1, r25	; 0x01
    56b6:	a2 83       	std	Z+2, r26	; 0x02
    56b8:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    56ba:	8e 01       	movw	r16, r28
    56bc:	09 5a       	subi	r16, 0xA9	; 169
    56be:	1f 4f       	sbci	r17, 0xFF	; 255
    56c0:	ce 01       	movw	r24, r28
    56c2:	8d 5a       	subi	r24, 0xAD	; 173
    56c4:	9f 4f       	sbci	r25, 0xFF	; 255
    56c6:	fc 01       	movw	r30, r24
    56c8:	60 81       	ld	r22, Z
    56ca:	71 81       	ldd	r23, Z+1	; 0x01
    56cc:	82 81       	ldd	r24, Z+2	; 0x02
    56ce:	93 81       	ldd	r25, Z+3	; 0x03
    56d0:	20 e0       	ldi	r18, 0x00	; 0
    56d2:	30 e0       	ldi	r19, 0x00	; 0
    56d4:	4a ef       	ldi	r20, 0xFA	; 250
    56d6:	55 e4       	ldi	r21, 0x45	; 69
    56d8:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    56dc:	dc 01       	movw	r26, r24
    56de:	cb 01       	movw	r24, r22
    56e0:	f8 01       	movw	r30, r16
    56e2:	80 83       	st	Z, r24
    56e4:	91 83       	std	Z+1, r25	; 0x01
    56e6:	a2 83       	std	Z+2, r26	; 0x02
    56e8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    56ea:	ce 01       	movw	r24, r28
    56ec:	89 5a       	subi	r24, 0xA9	; 169
    56ee:	9f 4f       	sbci	r25, 0xFF	; 255
    56f0:	11 e0       	ldi	r17, 0x01	; 1
    56f2:	fc 01       	movw	r30, r24
    56f4:	60 81       	ld	r22, Z
    56f6:	71 81       	ldd	r23, Z+1	; 0x01
    56f8:	82 81       	ldd	r24, Z+2	; 0x02
    56fa:	93 81       	ldd	r25, Z+3	; 0x03
    56fc:	20 e0       	ldi	r18, 0x00	; 0
    56fe:	30 e0       	ldi	r19, 0x00	; 0
    5700:	40 e8       	ldi	r20, 0x80	; 128
    5702:	5f e3       	ldi	r21, 0x3F	; 63
    5704:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    5708:	88 23       	and	r24, r24
    570a:	0c f0       	brlt	.+2      	; 0x570e <chb_set_state+0x7b4>
    570c:	10 e0       	ldi	r17, 0x00	; 0
    570e:	11 23       	and	r17, r17
    5710:	49 f0       	breq	.+18     	; 0x5724 <chb_set_state+0x7ca>
		__ticks = 1;
    5712:	ce 01       	movw	r24, r28
    5714:	85 5a       	subi	r24, 0xA5	; 165
    5716:	9f 4f       	sbci	r25, 0xFF	; 255
    5718:	21 e0       	ldi	r18, 0x01	; 1
    571a:	30 e0       	ldi	r19, 0x00	; 0
    571c:	fc 01       	movw	r30, r24
    571e:	20 83       	st	Z, r18
    5720:	31 83       	std	Z+1, r19	; 0x01
    5722:	74 c0       	rjmp	.+232    	; 0x580c <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    5724:	ce 01       	movw	r24, r28
    5726:	89 5a       	subi	r24, 0xA9	; 169
    5728:	9f 4f       	sbci	r25, 0xFF	; 255
    572a:	11 e0       	ldi	r17, 0x01	; 1
    572c:	fc 01       	movw	r30, r24
    572e:	60 81       	ld	r22, Z
    5730:	71 81       	ldd	r23, Z+1	; 0x01
    5732:	82 81       	ldd	r24, Z+2	; 0x02
    5734:	93 81       	ldd	r25, Z+3	; 0x03
    5736:	20 e0       	ldi	r18, 0x00	; 0
    5738:	3f ef       	ldi	r19, 0xFF	; 255
    573a:	4f e7       	ldi	r20, 0x7F	; 127
    573c:	57 e4       	ldi	r21, 0x47	; 71
    573e:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    5742:	18 16       	cp	r1, r24
    5744:	0c f0       	brlt	.+2      	; 0x5748 <chb_set_state+0x7ee>
    5746:	10 e0       	ldi	r17, 0x00	; 0
    5748:	11 23       	and	r17, r17
    574a:	09 f4       	brne	.+2      	; 0x574e <chb_set_state+0x7f4>
    574c:	4d c0       	rjmp	.+154    	; 0x57e8 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    574e:	ce 01       	movw	r24, r28
    5750:	8d 5a       	subi	r24, 0xAD	; 173
    5752:	9f 4f       	sbci	r25, 0xFF	; 255
    5754:	fc 01       	movw	r30, r24
    5756:	60 81       	ld	r22, Z
    5758:	71 81       	ldd	r23, Z+1	; 0x01
    575a:	82 81       	ldd	r24, Z+2	; 0x02
    575c:	93 81       	ldd	r25, Z+3	; 0x03
    575e:	20 e0       	ldi	r18, 0x00	; 0
    5760:	30 e0       	ldi	r19, 0x00	; 0
    5762:	40 e2       	ldi	r20, 0x20	; 32
    5764:	51 e4       	ldi	r21, 0x41	; 65
    5766:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    576a:	dc 01       	movw	r26, r24
    576c:	cb 01       	movw	r24, r22
    576e:	8e 01       	movw	r16, r28
    5770:	05 5a       	subi	r16, 0xA5	; 165
    5772:	1f 4f       	sbci	r17, 0xFF	; 255
    5774:	bc 01       	movw	r22, r24
    5776:	cd 01       	movw	r24, r26
    5778:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    577c:	dc 01       	movw	r26, r24
    577e:	cb 01       	movw	r24, r22
    5780:	f8 01       	movw	r30, r16
    5782:	80 83       	st	Z, r24
    5784:	91 83       	std	Z+1, r25	; 0x01
    5786:	27 c0       	rjmp	.+78     	; 0x57d6 <chb_set_state+0x87c>
    5788:	ce 01       	movw	r24, r28
    578a:	83 5a       	subi	r24, 0xA3	; 163
    578c:	9f 4f       	sbci	r25, 0xFF	; 255
    578e:	20 e2       	ldi	r18, 0x20	; 32
    5790:	33 e0       	ldi	r19, 0x03	; 3
    5792:	fc 01       	movw	r30, r24
    5794:	20 83       	st	Z, r18
    5796:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5798:	ce 01       	movw	r24, r28
    579a:	83 5a       	subi	r24, 0xA3	; 163
    579c:	9f 4f       	sbci	r25, 0xFF	; 255
    579e:	fc 01       	movw	r30, r24
    57a0:	80 81       	ld	r24, Z
    57a2:	91 81       	ldd	r25, Z+1	; 0x01
    57a4:	8c 01       	movw	r16, r24
    57a6:	c8 01       	movw	r24, r16
    57a8:	01 97       	sbiw	r24, 0x01	; 1
    57aa:	f1 f7       	brne	.-4      	; 0x57a8 <chb_set_state+0x84e>
    57ac:	8c 01       	movw	r16, r24
    57ae:	ce 01       	movw	r24, r28
    57b0:	83 5a       	subi	r24, 0xA3	; 163
    57b2:	9f 4f       	sbci	r25, 0xFF	; 255
    57b4:	fc 01       	movw	r30, r24
    57b6:	00 83       	st	Z, r16
    57b8:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57ba:	ce 01       	movw	r24, r28
    57bc:	85 5a       	subi	r24, 0xA5	; 165
    57be:	9f 4f       	sbci	r25, 0xFF	; 255
    57c0:	9e 01       	movw	r18, r28
    57c2:	25 5a       	subi	r18, 0xA5	; 165
    57c4:	3f 4f       	sbci	r19, 0xFF	; 255
    57c6:	f9 01       	movw	r30, r18
    57c8:	20 81       	ld	r18, Z
    57ca:	31 81       	ldd	r19, Z+1	; 0x01
    57cc:	21 50       	subi	r18, 0x01	; 1
    57ce:	30 40       	sbci	r19, 0x00	; 0
    57d0:	fc 01       	movw	r30, r24
    57d2:	20 83       	st	Z, r18
    57d4:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57d6:	ce 01       	movw	r24, r28
    57d8:	85 5a       	subi	r24, 0xA5	; 165
    57da:	9f 4f       	sbci	r25, 0xFF	; 255
    57dc:	fc 01       	movw	r30, r24
    57de:	80 81       	ld	r24, Z
    57e0:	91 81       	ldd	r25, Z+1	; 0x01
    57e2:	00 97       	sbiw	r24, 0x00	; 0
    57e4:	89 f6       	brne	.-94     	; 0x5788 <chb_set_state+0x82e>
    57e6:	58 c0       	rjmp	.+176    	; 0x5898 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57e8:	8e 01       	movw	r16, r28
    57ea:	05 5a       	subi	r16, 0xA5	; 165
    57ec:	1f 4f       	sbci	r17, 0xFF	; 255
    57ee:	ce 01       	movw	r24, r28
    57f0:	89 5a       	subi	r24, 0xA9	; 169
    57f2:	9f 4f       	sbci	r25, 0xFF	; 255
    57f4:	fc 01       	movw	r30, r24
    57f6:	60 81       	ld	r22, Z
    57f8:	71 81       	ldd	r23, Z+1	; 0x01
    57fa:	82 81       	ldd	r24, Z+2	; 0x02
    57fc:	93 81       	ldd	r25, Z+3	; 0x03
    57fe:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5802:	dc 01       	movw	r26, r24
    5804:	cb 01       	movw	r24, r22
    5806:	f8 01       	movw	r30, r16
    5808:	80 83       	st	Z, r24
    580a:	91 83       	std	Z+1, r25	; 0x01
    580c:	ce 01       	movw	r24, r28
    580e:	81 5a       	subi	r24, 0xA1	; 161
    5810:	9f 4f       	sbci	r25, 0xFF	; 255
    5812:	9e 01       	movw	r18, r28
    5814:	25 5a       	subi	r18, 0xA5	; 165
    5816:	3f 4f       	sbci	r19, 0xFF	; 255
    5818:	f9 01       	movw	r30, r18
    581a:	20 81       	ld	r18, Z
    581c:	31 81       	ldd	r19, Z+1	; 0x01
    581e:	fc 01       	movw	r30, r24
    5820:	20 83       	st	Z, r18
    5822:	31 83       	std	Z+1, r19	; 0x01
    5824:	ce 01       	movw	r24, r28
    5826:	81 5a       	subi	r24, 0xA1	; 161
    5828:	9f 4f       	sbci	r25, 0xFF	; 255
    582a:	fc 01       	movw	r30, r24
    582c:	80 81       	ld	r24, Z
    582e:	91 81       	ldd	r25, Z+1	; 0x01
    5830:	8c 01       	movw	r16, r24
    5832:	c8 01       	movw	r24, r16
    5834:	01 97       	sbiw	r24, 0x01	; 1
    5836:	f1 f7       	brne	.-4      	; 0x5834 <chb_set_state+0x8da>
    5838:	8c 01       	movw	r16, r24
    583a:	ce 01       	movw	r24, r28
    583c:	81 5a       	subi	r24, 0xA1	; 161
    583e:	9f 4f       	sbci	r25, 0xFF	; 255
    5840:	fc 01       	movw	r30, r24
    5842:	00 83       	st	Z, r16
    5844:	11 83       	std	Z+1, r17	; 0x01
    5846:	28 c0       	rjmp	.+80     	; 0x5898 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5848:	8e 01       	movw	r16, r28
    584a:	0e 5a       	subi	r16, 0xAE	; 174
    584c:	1f 4f       	sbci	r17, 0xFF	; 255
    584e:	ce 01       	movw	r24, r28
    5850:	82 5b       	subi	r24, 0xB2	; 178
    5852:	9f 4f       	sbci	r25, 0xFF	; 255
    5854:	fc 01       	movw	r30, r24
    5856:	60 81       	ld	r22, Z
    5858:	71 81       	ldd	r23, Z+1	; 0x01
    585a:	82 81       	ldd	r24, Z+2	; 0x02
    585c:	93 81       	ldd	r25, Z+3	; 0x03
    585e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5862:	dc 01       	movw	r26, r24
    5864:	cb 01       	movw	r24, r22
    5866:	f8 01       	movw	r30, r16
    5868:	80 83       	st	Z, r24
    586a:	ce 01       	movw	r24, r28
    586c:	8f 59       	subi	r24, 0x9F	; 159
    586e:	9f 4f       	sbci	r25, 0xFF	; 255
    5870:	9e 01       	movw	r18, r28
    5872:	2e 5a       	subi	r18, 0xAE	; 174
    5874:	3f 4f       	sbci	r19, 0xFF	; 255
    5876:	f9 01       	movw	r30, r18
    5878:	20 81       	ld	r18, Z
    587a:	fc 01       	movw	r30, r24
    587c:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    587e:	ce 01       	movw	r24, r28
    5880:	8f 59       	subi	r24, 0x9F	; 159
    5882:	9f 4f       	sbci	r25, 0xFF	; 255
    5884:	fc 01       	movw	r30, r24
    5886:	80 81       	ld	r24, Z
    5888:	18 2f       	mov	r17, r24
    588a:	1a 95       	dec	r17
    588c:	f1 f7       	brne	.-4      	; 0x588a <chb_set_state+0x930>
    588e:	ce 01       	movw	r24, r28
    5890:	8f 59       	subi	r24, 0x9F	; 159
    5892:	9f 4f       	sbci	r25, 0xFF	; 255
    5894:	fc 01       	movw	r30, r24
    5896:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5898:	0e 94 4b 22 	call	0x4496	; 0x4496 <chb_get_state>
    589c:	28 2f       	mov	r18, r24
    589e:	ce 01       	movw	r24, r28
    58a0:	8e 59       	subi	r24, 0x9E	; 158
    58a2:	9f 4f       	sbci	r25, 0xFF	; 255
    58a4:	fc 01       	movw	r30, r24
    58a6:	80 81       	ld	r24, Z
    58a8:	28 17       	cp	r18, r24
    58aa:	11 f4       	brne	.+4      	; 0x58b0 <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    58ac:	80 e4       	ldi	r24, 0x40	; 64
    58ae:	01 c0       	rjmp	.+2      	; 0x58b2 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    58b0:	83 e4       	ldi	r24, 0x43	; 67
}
    58b2:	ce 59       	subi	r28, 0x9E	; 158
    58b4:	df 4f       	sbci	r29, 0xFF	; 255
    58b6:	cd bf       	out	0x3d, r28	; 61
    58b8:	de bf       	out	0x3e, r29	; 62
    58ba:	df 91       	pop	r29
    58bc:	cf 91       	pop	r28
    58be:	1f 91       	pop	r17
    58c0:	0f 91       	pop	r16
    58c2:	08 95       	ret

000058c4 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    58c4:	cf 93       	push	r28
    58c6:	df 93       	push	r29
    58c8:	0f 92       	push	r0
    58ca:	0f 92       	push	r0
    58cc:	cd b7       	in	r28, 0x3d	; 61
    58ce:	de b7       	in	r29, 0x3e	; 62
    58d0:	89 83       	std	Y+1, r24	; 0x01
    58d2:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    58d4:	29 81       	ldd	r18, Y+1	; 0x01
    58d6:	3a 81       	ldd	r19, Y+2	; 0x02
    58d8:	80 e0       	ldi	r24, 0x00	; 0
    58da:	90 e0       	ldi	r25, 0x00	; 0
    58dc:	b9 01       	movw	r22, r18
    58de:	48 e0       	ldi	r20, 0x08	; 8
    58e0:	50 e0       	ldi	r21, 0x00	; 0
    58e2:	0e 94 7b 30 	call	0x60f6	; 0x60f6 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    58e6:	29 81       	ldd	r18, Y+1	; 0x01
    58e8:	3a 81       	ldd	r19, Y+2	; 0x02
    58ea:	84 e2       	ldi	r24, 0x24	; 36
    58ec:	b9 01       	movw	r22, r18
    58ee:	0e 94 0a 25 	call	0x4a14	; 0x4a14 <chb_reg_write64>
}
    58f2:	0f 90       	pop	r0
    58f4:	0f 90       	pop	r0
    58f6:	df 91       	pop	r29
    58f8:	cf 91       	pop	r28
    58fa:	08 95       	ret

000058fc <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    58fc:	cf 93       	push	r28
    58fe:	df 93       	push	r29
    5900:	0f 92       	push	r0
    5902:	0f 92       	push	r0
    5904:	cd b7       	in	r28, 0x3d	; 61
    5906:	de b7       	in	r29, 0x3e	; 62
    5908:	89 83       	std	Y+1, r24	; 0x01
    590a:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    590c:	29 81       	ldd	r18, Y+1	; 0x01
    590e:	3a 81       	ldd	r19, Y+2	; 0x02
    5910:	80 e0       	ldi	r24, 0x00	; 0
    5912:	90 e0       	ldi	r25, 0x00	; 0
    5914:	b9 01       	movw	r22, r18
    5916:	48 e0       	ldi	r20, 0x08	; 8
    5918:	50 e0       	ldi	r21, 0x00	; 0
    591a:	0e 94 b7 30 	call	0x616e	; 0x616e <chb_eeprom_read>
}
    591e:	0f 90       	pop	r0
    5920:	0f 90       	pop	r0
    5922:	df 91       	pop	r29
    5924:	cf 91       	pop	r28
    5926:	08 95       	ret

00005928 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5928:	cf 93       	push	r28
    592a:	df 93       	push	r29
    592c:	00 d0       	rcall	.+0      	; 0x592e <chb_set_short_addr+0x6>
    592e:	00 d0       	rcall	.+0      	; 0x5930 <chb_set_short_addr+0x8>
    5930:	cd b7       	in	r28, 0x3d	; 61
    5932:	de b7       	in	r29, 0x3e	; 62
    5934:	8d 83       	std	Y+5, r24	; 0x05
    5936:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5938:	ce 01       	movw	r24, r28
    593a:	05 96       	adiw	r24, 0x05	; 5
    593c:	89 83       	std	Y+1, r24	; 0x01
    593e:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    5940:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <chb_get_pcb>
    5944:	8b 83       	std	Y+3, r24	; 0x03
    5946:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5948:	29 81       	ldd	r18, Y+1	; 0x01
    594a:	3a 81       	ldd	r19, Y+2	; 0x02
    594c:	89 e0       	ldi	r24, 0x09	; 9
    594e:	90 e0       	ldi	r25, 0x00	; 0
    5950:	b9 01       	movw	r22, r18
    5952:	42 e0       	ldi	r20, 0x02	; 2
    5954:	50 e0       	ldi	r21, 0x00	; 0
    5956:	0e 94 7b 30 	call	0x60f6	; 0x60f6 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    595a:	2d 81       	ldd	r18, Y+5	; 0x05
    595c:	3e 81       	ldd	r19, Y+6	; 0x06
    595e:	80 e2       	ldi	r24, 0x20	; 32
    5960:	b9 01       	movw	r22, r18
    5962:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <chb_reg_write16>
    pcb->src_addr = addr;
    5966:	2d 81       	ldd	r18, Y+5	; 0x05
    5968:	3e 81       	ldd	r19, Y+6	; 0x06
    596a:	8b 81       	ldd	r24, Y+3	; 0x03
    596c:	9c 81       	ldd	r25, Y+4	; 0x04
    596e:	fc 01       	movw	r30, r24
    5970:	20 83       	st	Z, r18
    5972:	31 83       	std	Z+1, r19	; 0x01
}
    5974:	26 96       	adiw	r28, 0x06	; 6
    5976:	cd bf       	out	0x3d, r28	; 61
    5978:	de bf       	out	0x3e, r29	; 62
    597a:	df 91       	pop	r29
    597c:	cf 91       	pop	r28
    597e:	08 95       	ret

00005980 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    5980:	cf 93       	push	r28
    5982:	df 93       	push	r29
    5984:	0f 92       	push	r0
    5986:	0f 92       	push	r0
    5988:	cd b7       	in	r28, 0x3d	; 61
    598a:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    598c:	89 e0       	ldi	r24, 0x09	; 9
    598e:	90 e0       	ldi	r25, 0x00	; 0
    5990:	9e 01       	movw	r18, r28
    5992:	2f 5f       	subi	r18, 0xFF	; 255
    5994:	3f 4f       	sbci	r19, 0xFF	; 255
    5996:	b9 01       	movw	r22, r18
    5998:	42 e0       	ldi	r20, 0x02	; 2
    599a:	50 e0       	ldi	r21, 0x00	; 0
    599c:	0e 94 b7 30 	call	0x616e	; 0x616e <chb_eeprom_read>
    return *(U16 *)addr;
    59a0:	ce 01       	movw	r24, r28
    59a2:	01 96       	adiw	r24, 0x01	; 1
    59a4:	fc 01       	movw	r30, r24
    59a6:	80 81       	ld	r24, Z
    59a8:	91 81       	ldd	r25, Z+1	; 0x01
}
    59aa:	0f 90       	pop	r0
    59ac:	0f 90       	pop	r0
    59ae:	df 91       	pop	r29
    59b0:	cf 91       	pop	r28
    59b2:	08 95       	ret

000059b4 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    59b4:	cf 93       	push	r28
    59b6:	df 93       	push	r29
    59b8:	cd b7       	in	r28, 0x3d	; 61
    59ba:	de b7       	in	r29, 0x3e	; 62
    59bc:	28 97       	sbiw	r28, 0x08	; 8
    59be:	cd bf       	out	0x3d, r28	; 61
    59c0:	de bf       	out	0x3e, r29	; 62
    59c2:	8c 83       	std	Y+4, r24	; 0x04
    59c4:	9d 83       	std	Y+5, r25	; 0x05
    59c6:	6e 83       	std	Y+6, r22	; 0x06
    59c8:	7f 83       	std	Y+7, r23	; 0x07
    59ca:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    59cc:	0e 94 4b 22 	call	0x4496	; 0x4496 <chb_get_state>
    59d0:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    59d2:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <chb_get_pcb>
    59d6:	8a 83       	std	Y+2, r24	; 0x02
    59d8:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    59da:	89 81       	ldd	r24, Y+1	; 0x01
    59dc:	82 30       	cpi	r24, 0x02	; 2
    59de:	19 f0       	breq	.+6      	; 0x59e6 <chb_tx+0x32>
    59e0:	89 81       	ldd	r24, Y+1	; 0x01
    59e2:	82 31       	cpi	r24, 0x12	; 18
    59e4:	11 f4       	brne	.+4      	; 0x59ea <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    59e6:	84 e4       	ldi	r24, 0x44	; 68
    59e8:	23 c0       	rjmp	.+70     	; 0x5a30 <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    59ea:	88 e0       	ldi	r24, 0x08	; 8
    59ec:	0e 94 ad 27 	call	0x4f5a	; 0x4f5a <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    59f0:	89 e1       	ldi	r24, 0x19	; 25
    59f2:	0e 94 ad 27 	call	0x4f5a	; 0x4f5a <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    59f6:	8c 81       	ldd	r24, Y+4	; 0x04
    59f8:	9d 81       	ldd	r25, Y+5	; 0x05
    59fa:	2e 81       	ldd	r18, Y+6	; 0x06
    59fc:	3f 81       	ldd	r19, Y+7	; 0x07
    59fe:	6a e0       	ldi	r22, 0x0A	; 10
    5a00:	a9 01       	movw	r20, r18
    5a02:	28 85       	ldd	r18, Y+8	; 0x08
    5a04:	0e 94 57 25 	call	0x4aae	; 0x4aae <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5a08:	82 e0       	ldi	r24, 0x02	; 2
    5a0a:	62 e0       	ldi	r22, 0x02	; 2
    5a0c:	4f e1       	ldi	r20, 0x1F	; 31
    5a0e:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    5a12:	00 00       	nop
    5a14:	8a 81       	ldd	r24, Y+2	; 0x02
    5a16:	9b 81       	ldd	r25, Y+3	; 0x03
    5a18:	fc 01       	movw	r30, r24
    5a1a:	94 81       	ldd	r25, Z+4	; 0x04
    5a1c:	81 e0       	ldi	r24, 0x01	; 1
    5a1e:	89 27       	eor	r24, r25
    5a20:	88 23       	and	r24, r24
    5a22:	c1 f7       	brne	.-16     	; 0x5a14 <chb_tx+0x60>
    pcb->tx_end = false;
    5a24:	8a 81       	ldd	r24, Y+2	; 0x02
    5a26:	9b 81       	ldd	r25, Y+3	; 0x03
    5a28:	fc 01       	movw	r30, r24
    5a2a:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5a2c:	0e 94 56 22 	call	0x44ac	; 0x44ac <chb_get_status>
}
    5a30:	28 96       	adiw	r28, 0x08	; 8
    5a32:	cd bf       	out	0x3d, r28	; 61
    5a34:	de bf       	out	0x3e, r29	; 62
    5a36:	df 91       	pop	r29
    5a38:	cf 91       	pop	r28
    5a3a:	08 95       	ret

00005a3c <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5a3c:	0f 93       	push	r16
    5a3e:	1f 93       	push	r17
    5a40:	cf 93       	push	r28
    5a42:	df 93       	push	r29
    5a44:	cd b7       	in	r28, 0x3d	; 61
    5a46:	de b7       	in	r29, 0x3e	; 62
    5a48:	69 97       	sbiw	r28, 0x19	; 25
    5a4a:	cd bf       	out	0x3d, r28	; 61
    5a4c:	de bf       	out	0x3e, r29	; 62
    5a4e:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    5a50:	89 8d       	ldd	r24, Y+25	; 0x19
    5a52:	88 23       	and	r24, r24
    5a54:	69 f0       	breq	.+26     	; 0x5a70 <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5a56:	88 e0       	ldi	r24, 0x08	; 8
    5a58:	0e 94 ad 27 	call	0x4f5a	; 0x4f5a <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5a5c:	84 e6       	ldi	r24, 0x64	; 100
    5a5e:	96 e0       	ldi	r25, 0x06	; 6
    5a60:	24 e6       	ldi	r18, 0x64	; 100
    5a62:	36 e0       	ldi	r19, 0x06	; 6
    5a64:	f9 01       	movw	r30, r18
    5a66:	20 81       	ld	r18, Z
    5a68:	22 60       	ori	r18, 0x02	; 2
    5a6a:	fc 01       	movw	r30, r24
    5a6c:	20 83       	st	Z, r18
    5a6e:	e1 c0       	rjmp	.+450    	; 0x5c32 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    5a70:	84 e6       	ldi	r24, 0x64	; 100
    5a72:	96 e0       	ldi	r25, 0x06	; 6
    5a74:	24 e6       	ldi	r18, 0x64	; 100
    5a76:	36 e0       	ldi	r19, 0x06	; 6
    5a78:	f9 01       	movw	r30, r18
    5a7a:	20 81       	ld	r18, Z
    5a7c:	2d 7f       	andi	r18, 0xFD	; 253
    5a7e:	fc 01       	movw	r30, r24
    5a80:	20 83       	st	Z, r18
    5a82:	80 e0       	ldi	r24, 0x00	; 0
    5a84:	90 e0       	ldi	r25, 0x00	; 0
    5a86:	a0 e7       	ldi	r26, 0x70	; 112
    5a88:	b3 e4       	ldi	r27, 0x43	; 67
    5a8a:	89 83       	std	Y+1, r24	; 0x01
    5a8c:	9a 83       	std	Y+2, r25	; 0x02
    5a8e:	ab 83       	std	Y+3, r26	; 0x03
    5a90:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5a92:	69 81       	ldd	r22, Y+1	; 0x01
    5a94:	7a 81       	ldd	r23, Y+2	; 0x02
    5a96:	8b 81       	ldd	r24, Y+3	; 0x03
    5a98:	9c 81       	ldd	r25, Y+4	; 0x04
    5a9a:	2b ea       	ldi	r18, 0xAB	; 171
    5a9c:	3a ea       	ldi	r19, 0xAA	; 170
    5a9e:	4a e2       	ldi	r20, 0x2A	; 42
    5aa0:	51 e4       	ldi	r21, 0x41	; 65
    5aa2:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    5aa6:	dc 01       	movw	r26, r24
    5aa8:	cb 01       	movw	r24, r22
    5aaa:	8d 83       	std	Y+5, r24	; 0x05
    5aac:	9e 83       	std	Y+6, r25	; 0x06
    5aae:	af 83       	std	Y+7, r26	; 0x07
    5ab0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5ab2:	11 e0       	ldi	r17, 0x01	; 1
    5ab4:	6d 81       	ldd	r22, Y+5	; 0x05
    5ab6:	7e 81       	ldd	r23, Y+6	; 0x06
    5ab8:	8f 81       	ldd	r24, Y+7	; 0x07
    5aba:	98 85       	ldd	r25, Y+8	; 0x08
    5abc:	20 e0       	ldi	r18, 0x00	; 0
    5abe:	30 e0       	ldi	r19, 0x00	; 0
    5ac0:	40 e8       	ldi	r20, 0x80	; 128
    5ac2:	5f e3       	ldi	r21, 0x3F	; 63
    5ac4:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    5ac8:	88 23       	and	r24, r24
    5aca:	0c f0       	brlt	.+2      	; 0x5ace <chb_sleep+0x92>
    5acc:	10 e0       	ldi	r17, 0x00	; 0
    5ace:	11 23       	and	r17, r17
    5ad0:	19 f0       	breq	.+6      	; 0x5ad8 <chb_sleep+0x9c>
		__ticks = 1;
    5ad2:	81 e0       	ldi	r24, 0x01	; 1
    5ad4:	89 87       	std	Y+9, r24	; 0x09
    5ad6:	a3 c0       	rjmp	.+326    	; 0x5c1e <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5ad8:	11 e0       	ldi	r17, 0x01	; 1
    5ada:	6d 81       	ldd	r22, Y+5	; 0x05
    5adc:	7e 81       	ldd	r23, Y+6	; 0x06
    5ade:	8f 81       	ldd	r24, Y+7	; 0x07
    5ae0:	98 85       	ldd	r25, Y+8	; 0x08
    5ae2:	20 e0       	ldi	r18, 0x00	; 0
    5ae4:	30 e0       	ldi	r19, 0x00	; 0
    5ae6:	4f e7       	ldi	r20, 0x7F	; 127
    5ae8:	53 e4       	ldi	r21, 0x43	; 67
    5aea:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    5aee:	18 16       	cp	r1, r24
    5af0:	0c f0       	brlt	.+2      	; 0x5af4 <chb_sleep+0xb8>
    5af2:	10 e0       	ldi	r17, 0x00	; 0
    5af4:	11 23       	and	r17, r17
    5af6:	09 f4       	brne	.+2      	; 0x5afa <chb_sleep+0xbe>
    5af8:	89 c0       	rjmp	.+274    	; 0x5c0c <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5afa:	69 81       	ldd	r22, Y+1	; 0x01
    5afc:	7a 81       	ldd	r23, Y+2	; 0x02
    5afe:	8b 81       	ldd	r24, Y+3	; 0x03
    5b00:	9c 81       	ldd	r25, Y+4	; 0x04
    5b02:	20 e0       	ldi	r18, 0x00	; 0
    5b04:	30 e0       	ldi	r19, 0x00	; 0
    5b06:	4a e7       	ldi	r20, 0x7A	; 122
    5b08:	54 e4       	ldi	r21, 0x44	; 68
    5b0a:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    5b0e:	dc 01       	movw	r26, r24
    5b10:	cb 01       	movw	r24, r22
    5b12:	8a 87       	std	Y+10, r24	; 0x0a
    5b14:	9b 87       	std	Y+11, r25	; 0x0b
    5b16:	ac 87       	std	Y+12, r26	; 0x0c
    5b18:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5b1a:	6a 85       	ldd	r22, Y+10	; 0x0a
    5b1c:	7b 85       	ldd	r23, Y+11	; 0x0b
    5b1e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b20:	9d 85       	ldd	r25, Y+13	; 0x0d
    5b22:	20 e0       	ldi	r18, 0x00	; 0
    5b24:	30 e0       	ldi	r19, 0x00	; 0
    5b26:	4a ef       	ldi	r20, 0xFA	; 250
    5b28:	55 e4       	ldi	r21, 0x45	; 69
    5b2a:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    5b2e:	dc 01       	movw	r26, r24
    5b30:	cb 01       	movw	r24, r22
    5b32:	8e 87       	std	Y+14, r24	; 0x0e
    5b34:	9f 87       	std	Y+15, r25	; 0x0f
    5b36:	a8 8b       	std	Y+16, r26	; 0x10
    5b38:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5b3a:	11 e0       	ldi	r17, 0x01	; 1
    5b3c:	6e 85       	ldd	r22, Y+14	; 0x0e
    5b3e:	7f 85       	ldd	r23, Y+15	; 0x0f
    5b40:	88 89       	ldd	r24, Y+16	; 0x10
    5b42:	99 89       	ldd	r25, Y+17	; 0x11
    5b44:	20 e0       	ldi	r18, 0x00	; 0
    5b46:	30 e0       	ldi	r19, 0x00	; 0
    5b48:	40 e8       	ldi	r20, 0x80	; 128
    5b4a:	5f e3       	ldi	r21, 0x3F	; 63
    5b4c:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    5b50:	88 23       	and	r24, r24
    5b52:	0c f0       	brlt	.+2      	; 0x5b56 <chb_sleep+0x11a>
    5b54:	10 e0       	ldi	r17, 0x00	; 0
    5b56:	11 23       	and	r17, r17
    5b58:	29 f0       	breq	.+10     	; 0x5b64 <chb_sleep+0x128>
		__ticks = 1;
    5b5a:	81 e0       	ldi	r24, 0x01	; 1
    5b5c:	90 e0       	ldi	r25, 0x00	; 0
    5b5e:	8a 8b       	std	Y+18, r24	; 0x12
    5b60:	9b 8b       	std	Y+19, r25	; 0x13
    5b62:	46 c0       	rjmp	.+140    	; 0x5bf0 <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5b64:	11 e0       	ldi	r17, 0x01	; 1
    5b66:	6e 85       	ldd	r22, Y+14	; 0x0e
    5b68:	7f 85       	ldd	r23, Y+15	; 0x0f
    5b6a:	88 89       	ldd	r24, Y+16	; 0x10
    5b6c:	99 89       	ldd	r25, Y+17	; 0x11
    5b6e:	20 e0       	ldi	r18, 0x00	; 0
    5b70:	3f ef       	ldi	r19, 0xFF	; 255
    5b72:	4f e7       	ldi	r20, 0x7F	; 127
    5b74:	57 e4       	ldi	r21, 0x47	; 71
    5b76:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    5b7a:	18 16       	cp	r1, r24
    5b7c:	0c f0       	brlt	.+2      	; 0x5b80 <chb_sleep+0x144>
    5b7e:	10 e0       	ldi	r17, 0x00	; 0
    5b80:	11 23       	and	r17, r17
    5b82:	61 f1       	breq	.+88     	; 0x5bdc <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5b84:	6a 85       	ldd	r22, Y+10	; 0x0a
    5b86:	7b 85       	ldd	r23, Y+11	; 0x0b
    5b88:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    5b8c:	20 e0       	ldi	r18, 0x00	; 0
    5b8e:	30 e0       	ldi	r19, 0x00	; 0
    5b90:	40 e2       	ldi	r20, 0x20	; 32
    5b92:	51 e4       	ldi	r21, 0x41	; 65
    5b94:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    5b98:	dc 01       	movw	r26, r24
    5b9a:	cb 01       	movw	r24, r22
    5b9c:	bc 01       	movw	r22, r24
    5b9e:	cd 01       	movw	r24, r26
    5ba0:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5ba4:	dc 01       	movw	r26, r24
    5ba6:	cb 01       	movw	r24, r22
    5ba8:	8a 8b       	std	Y+18, r24	; 0x12
    5baa:	9b 8b       	std	Y+19, r25	; 0x13
    5bac:	12 c0       	rjmp	.+36     	; 0x5bd2 <chb_sleep+0x196>
    5bae:	80 e2       	ldi	r24, 0x20	; 32
    5bb0:	93 e0       	ldi	r25, 0x03	; 3
    5bb2:	8c 8b       	std	Y+20, r24	; 0x14
    5bb4:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5bb6:	8c 89       	ldd	r24, Y+20	; 0x14
    5bb8:	9d 89       	ldd	r25, Y+21	; 0x15
    5bba:	8c 01       	movw	r16, r24
    5bbc:	c8 01       	movw	r24, r16
    5bbe:	01 97       	sbiw	r24, 0x01	; 1
    5bc0:	f1 f7       	brne	.-4      	; 0x5bbe <chb_sleep+0x182>
    5bc2:	8c 01       	movw	r16, r24
    5bc4:	0c 8b       	std	Y+20, r16	; 0x14
    5bc6:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5bc8:	8a 89       	ldd	r24, Y+18	; 0x12
    5bca:	9b 89       	ldd	r25, Y+19	; 0x13
    5bcc:	01 97       	sbiw	r24, 0x01	; 1
    5bce:	8a 8b       	std	Y+18, r24	; 0x12
    5bd0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5bd2:	8a 89       	ldd	r24, Y+18	; 0x12
    5bd4:	9b 89       	ldd	r25, Y+19	; 0x13
    5bd6:	00 97       	sbiw	r24, 0x00	; 0
    5bd8:	51 f7       	brne	.-44     	; 0x5bae <chb_sleep+0x172>
    5bda:	28 c0       	rjmp	.+80     	; 0x5c2c <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5bdc:	6e 85       	ldd	r22, Y+14	; 0x0e
    5bde:	7f 85       	ldd	r23, Y+15	; 0x0f
    5be0:	88 89       	ldd	r24, Y+16	; 0x10
    5be2:	99 89       	ldd	r25, Y+17	; 0x11
    5be4:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5be8:	dc 01       	movw	r26, r24
    5bea:	cb 01       	movw	r24, r22
    5bec:	8a 8b       	std	Y+18, r24	; 0x12
    5bee:	9b 8b       	std	Y+19, r25	; 0x13
    5bf0:	8a 89       	ldd	r24, Y+18	; 0x12
    5bf2:	9b 89       	ldd	r25, Y+19	; 0x13
    5bf4:	8e 8b       	std	Y+22, r24	; 0x16
    5bf6:	9f 8b       	std	Y+23, r25	; 0x17
    5bf8:	8e 89       	ldd	r24, Y+22	; 0x16
    5bfa:	9f 89       	ldd	r25, Y+23	; 0x17
    5bfc:	8c 01       	movw	r16, r24
    5bfe:	f8 01       	movw	r30, r16
    5c00:	31 97       	sbiw	r30, 0x01	; 1
    5c02:	f1 f7       	brne	.-4      	; 0x5c00 <chb_sleep+0x1c4>
    5c04:	8f 01       	movw	r16, r30
    5c06:	0e 8b       	std	Y+22, r16	; 0x16
    5c08:	1f 8b       	std	Y+23, r17	; 0x17
    5c0a:	10 c0       	rjmp	.+32     	; 0x5c2c <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5c0c:	6d 81       	ldd	r22, Y+5	; 0x05
    5c0e:	7e 81       	ldd	r23, Y+6	; 0x06
    5c10:	8f 81       	ldd	r24, Y+7	; 0x07
    5c12:	98 85       	ldd	r25, Y+8	; 0x08
    5c14:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    5c18:	dc 01       	movw	r26, r24
    5c1a:	cb 01       	movw	r24, r22
    5c1c:	89 87       	std	Y+9, r24	; 0x09
    5c1e:	89 85       	ldd	r24, Y+9	; 0x09
    5c20:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5c22:	88 8d       	ldd	r24, Y+24	; 0x18
    5c24:	18 2f       	mov	r17, r24
    5c26:	1a 95       	dec	r17
    5c28:	f1 f7       	brne	.-4      	; 0x5c26 <chb_sleep+0x1ea>
    5c2a:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5c2c:	86 e1       	ldi	r24, 0x16	; 22
    5c2e:	0e 94 ad 27 	call	0x4f5a	; 0x4f5a <chb_set_state>
    }
}
    5c32:	69 96       	adiw	r28, 0x19	; 25
    5c34:	cd bf       	out	0x3d, r28	; 61
    5c36:	de bf       	out	0x3e, r29	; 62
    5c38:	df 91       	pop	r29
    5c3a:	cf 91       	pop	r28
    5c3c:	1f 91       	pop	r17
    5c3e:	0f 91       	pop	r16
    5c40:	08 95       	ret

00005c42 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5c42:	cf 93       	push	r28
    5c44:	df 93       	push	r29
    5c46:	cd b7       	in	r28, 0x3d	; 61
    5c48:	de b7       	in	r29, 0x3e	; 62
    5c4a:	ea 97       	sbiw	r28, 0x3a	; 58
    5c4c:	cd bf       	out	0x3d, r28	; 61
    5c4e:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5c50:	0e 94 63 22 	call	0x44c6	; 0x44c6 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5c54:	8e e0       	ldi	r24, 0x0E	; 14
    5c56:	60 e0       	ldi	r22, 0x00	; 0
    5c58:	0e 94 af 24 	call	0x495e	; 0x495e <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5c5c:	82 e0       	ldi	r24, 0x02	; 2
    5c5e:	63 e0       	ldi	r22, 0x03	; 3
    5c60:	4f e1       	ldi	r20, 0x1F	; 31
    5c62:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5c66:	00 00       	nop
    5c68:	81 e0       	ldi	r24, 0x01	; 1
    5c6a:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    5c6e:	88 2f       	mov	r24, r24
    5c70:	90 e0       	ldi	r25, 0x00	; 0
    5c72:	8f 71       	andi	r24, 0x1F	; 31
    5c74:	90 70       	andi	r25, 0x00	; 0
    5c76:	88 30       	cpi	r24, 0x08	; 8
    5c78:	91 05       	cpc	r25, r1
    5c7a:	b1 f7       	brne	.-20     	; 0x5c68 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5c7c:	8e e2       	ldi	r24, 0x2E	; 46
    5c7e:	60 e4       	ldi	r22, 0x40	; 64
    5c80:	40 ec       	ldi	r20, 0xC0	; 192
    5c82:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5c86:	8e e0       	ldi	r24, 0x0E	; 14
    5c88:	6c e0       	ldi	r22, 0x0C	; 12
    5c8a:	0e 94 af 24 	call	0x495e	; 0x495e <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5c8e:	84 e0       	ldi	r24, 0x04	; 4
    5c90:	60 e2       	ldi	r22, 0x20	; 32
    5c92:	40 e2       	ldi	r20, 0x20	; 32
    5c94:	0e 94 32 25 	call	0x4a64	; 0x4a64 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5c98:	81 e0       	ldi	r24, 0x01	; 1
    5c9a:	0e 94 4f 26 	call	0x4c9e	; 0x4c9e <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5c9e:	81 e0       	ldi	r24, 0x01	; 1
    5ca0:	0e 94 98 26 	call	0x4d30	; 0x4d30 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5ca4:	86 e1       	ldi	r24, 0x16	; 22
    5ca6:	0e 94 ad 27 	call	0x4f5a	; 0x4f5a <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5caa:	82 e2       	ldi	r24, 0x22	; 34
    5cac:	64 e3       	ldi	r22, 0x34	; 52
    5cae:	72 e1       	ldi	r23, 0x12	; 18
    5cb0:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5cb4:	0e 94 c0 2c 	call	0x5980	; 0x5980 <chb_get_short_addr>
    5cb8:	9c 01       	movw	r18, r24
    5cba:	80 e2       	ldi	r24, 0x20	; 32
    5cbc:	b9 01       	movw	r22, r18
    5cbe:	0e 94 d9 24 	call	0x49b2	; 0x49b2 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5cc2:	ce 01       	movw	r24, r28
    5cc4:	01 96       	adiw	r24, 0x01	; 1
    5cc6:	0e 94 7e 2c 	call	0x58fc	; 0x58fc <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5cca:	84 e2       	ldi	r24, 0x24	; 36
    5ccc:	9e 01       	movw	r18, r28
    5cce:	2f 5f       	subi	r18, 0xFF	; 255
    5cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    5cd2:	b9 01       	movw	r22, r18
    5cd4:	0e 94 0a 25 	call	0x4a14	; 0x4a14 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5cd8:	82 e7       	ldi	r24, 0x72	; 114
    5cda:	96 e0       	ldi	r25, 0x06	; 6
    5cdc:	22 e7       	ldi	r18, 0x72	; 114
    5cde:	36 e0       	ldi	r19, 0x06	; 6
    5ce0:	f9 01       	movw	r30, r18
    5ce2:	20 81       	ld	r18, Z
    5ce4:	21 60       	ori	r18, 0x01	; 1
    5ce6:	fc 01       	movw	r30, r24
    5ce8:	20 83       	st	Z, r18
    5cea:	89 e6       	ldi	r24, 0x69	; 105
    5cec:	96 e0       	ldi	r25, 0x06	; 6
    5cee:	29 e6       	ldi	r18, 0x69	; 105
    5cf0:	36 e0       	ldi	r19, 0x06	; 6
    5cf2:	f9 01       	movw	r30, r18
    5cf4:	20 81       	ld	r18, Z
    5cf6:	23 60       	ori	r18, 0x03	; 3
    5cf8:	fc 01       	movw	r30, r24
    5cfa:	20 83       	st	Z, r18
    5cfc:	8a e6       	ldi	r24, 0x6A	; 106
    5cfe:	96 e0       	ldi	r25, 0x06	; 6
    5d00:	2a e6       	ldi	r18, 0x6A	; 106
    5d02:	36 e0       	ldi	r19, 0x06	; 6
    5d04:	f9 01       	movw	r30, r18
    5d06:	20 81       	ld	r18, Z
    5d08:	24 60       	ori	r18, 0x04	; 4
    5d0a:	fc 01       	movw	r30, r24
    5d0c:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5d0e:	80 ea       	ldi	r24, 0xA0	; 160
    5d10:	90 e0       	ldi	r25, 0x00	; 0
    5d12:	20 ea       	ldi	r18, 0xA0	; 160
    5d14:	30 e0       	ldi	r19, 0x00	; 0
    5d16:	f9 01       	movw	r30, r18
    5d18:	22 81       	ldd	r18, Z+2	; 0x02
    5d1a:	27 60       	ori	r18, 0x07	; 7
    5d1c:	fc 01       	movw	r30, r24
    5d1e:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5d20:	0e 94 4b 22 	call	0x4496	; 0x4496 <chb_get_state>
    5d24:	86 31       	cpi	r24, 0x16	; 22
    5d26:	b1 f0       	breq	.+44     	; 0x5d54 <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5d28:	ce 01       	movw	r24, r28
    5d2a:	09 96       	adiw	r24, 0x09	; 9
    5d2c:	2c e0       	ldi	r18, 0x0C	; 12
    5d2e:	32 e0       	ldi	r19, 0x02	; 2
    5d30:	b9 01       	movw	r22, r18
    5d32:	0e 94 2e 5e 	call	0xbc5c	; 0xbc5c <strcpy_P>
        printf(buf);
    5d36:	0f 92       	push	r0
    5d38:	0f 92       	push	r0
    5d3a:	8d b7       	in	r24, 0x3d	; 61
    5d3c:	9e b7       	in	r25, 0x3e	; 62
    5d3e:	01 96       	adiw	r24, 0x01	; 1
    5d40:	9e 01       	movw	r18, r28
    5d42:	27 5f       	subi	r18, 0xF7	; 247
    5d44:	3f 4f       	sbci	r19, 0xFF	; 255
    5d46:	fc 01       	movw	r30, r24
    5d48:	20 83       	st	Z, r18
    5d4a:	31 83       	std	Z+1, r19	; 0x01
    5d4c:	0e 94 81 5e 	call	0xbd02	; 0xbd02 <printf>
    5d50:	0f 90       	pop	r0
    5d52:	0f 90       	pop	r0
    }
	//StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
}
    5d54:	ea 96       	adiw	r28, 0x3a	; 58
    5d56:	cd bf       	out	0x3d, r28	; 61
    5d58:	de bf       	out	0x3e, r29	; 62
    5d5a:	df 91       	pop	r29
    5d5c:	cf 91       	pop	r28
    5d5e:	08 95       	ret

00005d60 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5d60:	cf 93       	push	r28
    5d62:	df 93       	push	r29
    5d64:	cd b7       	in	r28, 0x3d	; 61
    5d66:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5d68:	0e 94 f7 30 	call	0x61ee	; 0x61ee <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5d6c:	80 e6       	ldi	r24, 0x60	; 96
    5d6e:	96 e0       	ldi	r25, 0x06	; 6
    5d70:	20 e6       	ldi	r18, 0x60	; 96
    5d72:	36 e0       	ldi	r19, 0x06	; 6
    5d74:	f9 01       	movw	r30, r18
    5d76:	20 81       	ld	r18, Z
    5d78:	22 60       	ori	r18, 0x02	; 2
    5d7a:	fc 01       	movw	r30, r24
    5d7c:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5d7e:	80 e6       	ldi	r24, 0x60	; 96
    5d80:	96 e0       	ldi	r25, 0x06	; 6
    5d82:	20 e6       	ldi	r18, 0x60	; 96
    5d84:	36 e0       	ldi	r19, 0x06	; 6
    5d86:	f9 01       	movw	r30, r18
    5d88:	20 81       	ld	r18, Z
    5d8a:	21 60       	ori	r18, 0x01	; 1
    5d8c:	fc 01       	movw	r30, r24
    5d8e:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5d90:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <chb_radio_init>
}
    5d94:	df 91       	pop	r29
    5d96:	cf 91       	pop	r28
    5d98:	08 95       	ret

00005d9a <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5d9a:	1f 92       	push	r1
    5d9c:	0f 92       	push	r0
    5d9e:	0f b6       	in	r0, 0x3f	; 63
    5da0:	0f 92       	push	r0
    5da2:	00 90 3b 00 	lds	r0, 0x003B
    5da6:	0f 92       	push	r0
    5da8:	11 24       	eor	r1, r1
    5daa:	2f 93       	push	r18
    5dac:	3f 93       	push	r19
    5dae:	4f 93       	push	r20
    5db0:	5f 93       	push	r21
    5db2:	6f 93       	push	r22
    5db4:	7f 93       	push	r23
    5db6:	8f 93       	push	r24
    5db8:	9f 93       	push	r25
    5dba:	af 93       	push	r26
    5dbc:	bf 93       	push	r27
    5dbe:	ef 93       	push	r30
    5dc0:	ff 93       	push	r31
    5dc2:	cf 93       	push	r28
    5dc4:	df 93       	push	r29
    5dc6:	00 d0       	rcall	.+0      	; 0x5dc8 <__vector_64+0x2e>
    5dc8:	0f 92       	push	r0
    5dca:	cd b7       	in	r28, 0x3d	; 61
    5dcc:	de b7       	in	r29, 0x3e	; 62
    U8 state, intp_src = 0;
    5dce:	19 82       	std	Y+1, r1	; 0x01
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    5dd0:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <chb_get_pcb>
    5dd4:	8a 83       	std	Y+2, r24	; 0x02
    5dd6:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5dd8:	8f e3       	ldi	r24, 0x3F	; 63
    5dda:	90 e0       	ldi	r25, 0x00	; 0
    5ddc:	fc 01       	movw	r30, r24
    5dde:	80 81       	ld	r24, Z
    5de0:	80 93 47 40 	sts	0x4047, r24
    5de4:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5de6:	81 e0       	ldi	r24, 0x01	; 1
    5de8:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5dec:	8f e8       	ldi	r24, 0x8F	; 143
    5dee:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    intp_src = SPID_write(0);
    5df2:	80 e0       	ldi	r24, 0x00	; 0
    5df4:	0e 94 22 31 	call	0x6244	; 0x6244 <SPID_write>
    5df8:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5dfa:	80 e0       	ldi	r24, 0x00	; 0
    5dfc:	0e 94 c5 2f 	call	0x5f8a	; 0x5f8a <RadioCS>

    while (intp_src)
    5e00:	9d c0       	rjmp	.+314    	; 0x5f3c <__vector_64+0x1a2>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5e02:	89 81       	ldd	r24, Y+1	; 0x01
    5e04:	88 2f       	mov	r24, r24
    5e06:	90 e0       	ldi	r25, 0x00	; 0
    5e08:	84 70       	andi	r24, 0x04	; 4
    5e0a:	90 70       	andi	r25, 0x00	; 0
    5e0c:	00 97       	sbiw	r24, 0x00	; 0
    5e0e:	21 f0       	breq	.+8      	; 0x5e18 <__vector_64+0x7e>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5e10:	89 81       	ldd	r24, Y+1	; 0x01
    5e12:	8b 7f       	andi	r24, 0xFB	; 251
    5e14:	89 83       	std	Y+1, r24	; 0x01
    5e16:	92 c0       	rjmp	.+292    	; 0x5f3c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5e18:	89 81       	ldd	r24, Y+1	; 0x01
    5e1a:	88 2f       	mov	r24, r24
    5e1c:	90 e0       	ldi	r25, 0x00	; 0
    5e1e:	88 70       	andi	r24, 0x08	; 8
    5e20:	90 70       	andi	r25, 0x00	; 0
    5e22:	00 97       	sbiw	r24, 0x00	; 0
    5e24:	09 f4       	brne	.+2      	; 0x5e28 <__vector_64+0x8e>
    5e26:	4c c0       	rjmp	.+152    	; 0x5ec0 <__vector_64+0x126>
        {
            state = chb_get_state();
    5e28:	0e 94 4b 22 	call	0x4496	; 0x4496 <chb_get_state>
    5e2c:	8c 83       	std	Y+4, r24	; 0x04

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5e2e:	8c 81       	ldd	r24, Y+4	; 0x04
    5e30:	86 30       	cpi	r24, 0x06	; 6
    5e32:	31 f0       	breq	.+12     	; 0x5e40 <__vector_64+0xa6>
    5e34:	8c 81       	ldd	r24, Y+4	; 0x04
    5e36:	86 31       	cpi	r24, 0x16	; 22
    5e38:	19 f0       	breq	.+6      	; 0x5e40 <__vector_64+0xa6>
    5e3a:	8c 81       	ldd	r24, Y+4	; 0x04
    5e3c:	81 31       	cpi	r24, 0x11	; 17
    5e3e:	89 f5       	brne	.+98     	; 0x5ea2 <__vector_64+0x108>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5e40:	88 e0       	ldi	r24, 0x08	; 8
    5e42:	0e 94 ad 27 	call	0x4f5a	; 0x4f5a <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5e46:	87 e0       	ldi	r24, 0x07	; 7
    5e48:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    5e4c:	28 2f       	mov	r18, r24
    5e4e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e50:	9b 81       	ldd	r25, Y+3	; 0x03
    5e52:	fc 01       	movw	r30, r24
    5e54:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5e56:	86 e0       	ldi	r24, 0x06	; 6
    5e58:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
    5e5c:	28 2f       	mov	r18, r24
    5e5e:	22 1f       	adc	r18, r18
    5e60:	22 27       	eor	r18, r18
    5e62:	22 1f       	adc	r18, r18
    5e64:	8a 81       	ldd	r24, Y+2	; 0x02
    5e66:	9b 81       	ldd	r25, Y+3	; 0x03
    5e68:	fc 01       	movw	r30, r24
    5e6a:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e6e:	9b 81       	ldd	r25, Y+3	; 0x03
    5e70:	fc 01       	movw	r30, r24
    5e72:	83 89       	ldd	r24, Z+19	; 0x13
    5e74:	88 23       	and	r24, r24
    5e76:	d1 f0       	breq	.+52     	; 0x5eac <__vector_64+0x112>
                    // get the data
                    chb_frame_read();
    5e78:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <chb_frame_read>
                    pcb->rcvd_xfers++;
    5e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    5e80:	fc 01       	movw	r30, r24
    5e82:	85 81       	ldd	r24, Z+5	; 0x05
    5e84:	96 81       	ldd	r25, Z+6	; 0x06
    5e86:	9c 01       	movw	r18, r24
    5e88:	2f 5f       	subi	r18, 0xFF	; 255
    5e8a:	3f 4f       	sbci	r19, 0xFF	; 255
    5e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    5e90:	fc 01       	movw	r30, r24
    5e92:	25 83       	std	Z+5, r18	; 0x05
    5e94:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5e96:	8a 81       	ldd	r24, Y+2	; 0x02
    5e98:	9b 81       	ldd	r25, Y+3	; 0x03
    5e9a:	21 e0       	ldi	r18, 0x01	; 1
    5e9c:	fc 01       	movw	r30, r24
    5e9e:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5ea0:	05 c0       	rjmp	.+10     	; 0x5eac <__vector_64+0x112>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    5ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ea4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ea6:	21 e0       	ldi	r18, 0x01	; 1
    5ea8:	fc 01       	movw	r30, r24
    5eaa:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5eac:	89 81       	ldd	r24, Y+1	; 0x01
    5eae:	87 7f       	andi	r24, 0xF7	; 247
    5eb0:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5eb2:	00 00       	nop
    5eb4:	86 e1       	ldi	r24, 0x16	; 22
    5eb6:	0e 94 ad 27 	call	0x4f5a	; 0x4f5a <chb_set_state>
    5eba:	80 34       	cpi	r24, 0x40	; 64
    5ebc:	d9 f7       	brne	.-10     	; 0x5eb4 <__vector_64+0x11a>
    5ebe:	3e c0       	rjmp	.+124    	; 0x5f3c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5ec0:	89 81       	ldd	r24, Y+1	; 0x01
    5ec2:	88 2f       	mov	r24, r24
    5ec4:	90 e0       	ldi	r25, 0x00	; 0
    5ec6:	80 74       	andi	r24, 0x40	; 64
    5ec8:	90 70       	andi	r25, 0x00	; 0
    5eca:	00 97       	sbiw	r24, 0x00	; 0
    5ecc:	89 f0       	breq	.+34     	; 0x5ef0 <__vector_64+0x156>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5ece:	89 81       	ldd	r24, Y+1	; 0x01
    5ed0:	8f 7b       	andi	r24, 0xBF	; 191
    5ed2:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5ed4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ed8:	fc 01       	movw	r30, r24
    5eda:	87 85       	ldd	r24, Z+15	; 0x0f
    5edc:	90 89       	ldd	r25, Z+16	; 0x10
    5ede:	9c 01       	movw	r18, r24
    5ee0:	2f 5f       	subi	r18, 0xFF	; 255
    5ee2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ee6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ee8:	fc 01       	movw	r30, r24
    5eea:	27 87       	std	Z+15, r18	; 0x0f
    5eec:	30 8b       	std	Z+16, r19	; 0x10
    5eee:	26 c0       	rjmp	.+76     	; 0x5f3c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5ef0:	89 81       	ldd	r24, Y+1	; 0x01
    5ef2:	88 2f       	mov	r24, r24
    5ef4:	90 e0       	ldi	r25, 0x00	; 0
    5ef6:	82 70       	andi	r24, 0x02	; 2
    5ef8:	90 70       	andi	r25, 0x00	; 0
    5efa:	00 97       	sbiw	r24, 0x00	; 0
    5efc:	21 f0       	breq	.+8      	; 0x5f06 <__vector_64+0x16c>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5efe:	89 81       	ldd	r24, Y+1	; 0x01
    5f00:	8d 7f       	andi	r24, 0xFD	; 253
    5f02:	89 83       	std	Y+1, r24	; 0x01
    5f04:	1b c0       	rjmp	.+54     	; 0x5f3c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5f06:	89 81       	ldd	r24, Y+1	; 0x01
    5f08:	88 2f       	mov	r24, r24
    5f0a:	90 e0       	ldi	r25, 0x00	; 0
    5f0c:	81 70       	andi	r24, 0x01	; 1
    5f0e:	90 70       	andi	r25, 0x00	; 0
    5f10:	88 23       	and	r24, r24
    5f12:	21 f0       	breq	.+8      	; 0x5f1c <__vector_64+0x182>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5f14:	89 81       	ldd	r24, Y+1	; 0x01
    5f16:	8e 7f       	andi	r24, 0xFE	; 254
    5f18:	89 83       	std	Y+1, r24	; 0x01
    5f1a:	10 c0       	rjmp	.+32     	; 0x5f3c <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5f1c:	89 81       	ldd	r24, Y+1	; 0x01
    5f1e:	88 23       	and	r24, r24
    5f20:	6c f4       	brge	.+26     	; 0x5f3c <__vector_64+0x1a2>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5f22:	89 81       	ldd	r24, Y+1	; 0x01
    5f24:	8f 77       	andi	r24, 0x7F	; 127
    5f26:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5f28:	8a 81       	ldd	r24, Y+2	; 0x02
    5f2a:	9b 81       	ldd	r25, Y+3	; 0x03
    5f2c:	fc 01       	movw	r30, r24
    5f2e:	81 89       	ldd	r24, Z+17	; 0x11
    5f30:	28 2f       	mov	r18, r24
    5f32:	2f 5f       	subi	r18, 0xFF	; 255
    5f34:	8a 81       	ldd	r24, Y+2	; 0x02
    5f36:	9b 81       	ldd	r25, Y+3	; 0x03
    5f38:	fc 01       	movw	r30, r24
    5f3a:	21 8b       	std	Z+17, r18	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5f3c:	89 81       	ldd	r24, Y+1	; 0x01
    5f3e:	88 23       	and	r24, r24
    5f40:	09 f0       	breq	.+2      	; 0x5f44 <__vector_64+0x1aa>
    5f42:	5f cf       	rjmp	.-322    	; 0x5e02 <__vector_64+0x68>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5f44:	8f e3       	ldi	r24, 0x3F	; 63
    5f46:	90 e0       	ldi	r25, 0x00	; 0
    5f48:	20 91 47 40 	lds	r18, 0x4047
    5f4c:	fc 01       	movw	r30, r24
    5f4e:	20 83       	st	Z, r18
    5f50:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5f52:	8f e0       	ldi	r24, 0x0F	; 15
    5f54:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_reg_read>
}
    5f58:	24 96       	adiw	r28, 0x04	; 4
    5f5a:	cd bf       	out	0x3d, r28	; 61
    5f5c:	de bf       	out	0x3e, r29	; 62
    5f5e:	df 91       	pop	r29
    5f60:	cf 91       	pop	r28
    5f62:	ff 91       	pop	r31
    5f64:	ef 91       	pop	r30
    5f66:	bf 91       	pop	r27
    5f68:	af 91       	pop	r26
    5f6a:	9f 91       	pop	r25
    5f6c:	8f 91       	pop	r24
    5f6e:	7f 91       	pop	r23
    5f70:	6f 91       	pop	r22
    5f72:	5f 91       	pop	r21
    5f74:	4f 91       	pop	r20
    5f76:	3f 91       	pop	r19
    5f78:	2f 91       	pop	r18
    5f7a:	0f 90       	pop	r0
    5f7c:	00 92 3b 00 	sts	0x003B, r0
    5f80:	0f 90       	pop	r0
    5f82:	0f be       	out	0x3f, r0	; 63
    5f84:	0f 90       	pop	r0
    5f86:	1f 90       	pop	r1
    5f88:	18 95       	reti

00005f8a <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5f8a:	cf 93       	push	r28
    5f8c:	df 93       	push	r29
    5f8e:	0f 92       	push	r0
    5f90:	cd b7       	in	r28, 0x3d	; 61
    5f92:	de b7       	in	r29, 0x3e	; 62
    5f94:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5f96:	89 81       	ldd	r24, Y+1	; 0x01
    5f98:	88 23       	and	r24, r24
    5f9a:	31 f0       	breq	.+12     	; 0x5fa8 <RadioCS+0x1e>
    5f9c:	80 e6       	ldi	r24, 0x60	; 96
    5f9e:	96 e0       	ldi	r25, 0x06	; 6
    5fa0:	20 e1       	ldi	r18, 0x10	; 16
    5fa2:	fc 01       	movw	r30, r24
    5fa4:	26 83       	std	Z+6, r18	; 0x06
    5fa6:	05 c0       	rjmp	.+10     	; 0x5fb2 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5fa8:	80 e6       	ldi	r24, 0x60	; 96
    5faa:	96 e0       	ldi	r25, 0x06	; 6
    5fac:	20 e1       	ldi	r18, 0x10	; 16
    5fae:	fc 01       	movw	r30, r24
    5fb0:	25 83       	std	Z+5, r18	; 0x05
	}
    5fb2:	0f 90       	pop	r0
    5fb4:	df 91       	pop	r29
    5fb6:	cf 91       	pop	r28
    5fb8:	08 95       	ret

00005fba <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5fba:	cf 93       	push	r28
    5fbc:	df 93       	push	r29
    5fbe:	00 d0       	rcall	.+0      	; 0x5fc0 <chb_eep_write_byte+0x6>
    5fc0:	cd b7       	in	r28, 0x3d	; 61
    5fc2:	de b7       	in	r29, 0x3e	; 62
    5fc4:	89 83       	std	Y+1, r24	; 0x01
    5fc6:	9a 83       	std	Y+2, r25	; 0x02
    5fc8:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5fca:	00 00       	nop
    5fcc:	80 ec       	ldi	r24, 0xC0	; 192
    5fce:	91 e0       	ldi	r25, 0x01	; 1
    5fd0:	fc 01       	movw	r30, r24
    5fd2:	87 85       	ldd	r24, Z+15	; 0x0f
    5fd4:	88 23       	and	r24, r24
    5fd6:	d4 f3       	brlt	.-12     	; 0x5fcc <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5fd8:	80 ec       	ldi	r24, 0xC0	; 192
    5fda:	91 e0       	ldi	r25, 0x01	; 1
    5fdc:	fc 01       	movw	r30, r24
    5fde:	87 85       	ldd	r24, Z+15	; 0x0f
    5fe0:	88 2f       	mov	r24, r24
    5fe2:	90 e0       	ldi	r25, 0x00	; 0
    5fe4:	82 70       	andi	r24, 0x02	; 2
    5fe6:	90 70       	andi	r25, 0x00	; 0
    5fe8:	00 97       	sbiw	r24, 0x00	; 0
    5fea:	99 f0       	breq	.+38     	; 0x6012 <__stack+0x13>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5fec:	80 ec       	ldi	r24, 0xC0	; 192
    5fee:	91 e0       	ldi	r25, 0x01	; 1
    5ff0:	26 e3       	ldi	r18, 0x36	; 54
    5ff2:	fc 01       	movw	r30, r24
    5ff4:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5ff6:	ef 93       	push	r30
    5ff8:	ff 93       	push	r31
    5ffa:	0f 93       	push	r16
    5ffc:	2f 93       	push	r18
    5ffe:	eb ec       	ldi	r30, 0xCB	; 203
    6000:	f1 e0       	ldi	r31, 0x01	; 1
    6002:	08 ed       	ldi	r16, 0xD8	; 216
    6004:	21 e0       	ldi	r18, 0x01	; 1
    6006:	04 bf       	out	0x34, r16	; 52
    6008:	20 83       	st	Z, r18
    600a:	2f 91       	pop	r18
    600c:	0f 91       	pop	r16
    600e:	ff 91       	pop	r31
    6010:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    6012:	80 ec       	ldi	r24, 0xC0	; 192
    6014:	91 e0       	ldi	r25, 0x01	; 1
    6016:	23 e3       	ldi	r18, 0x33	; 51
    6018:	fc 01       	movw	r30, r24
    601a:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    601c:	80 ec       	ldi	r24, 0xC0	; 192
    601e:	91 e0       	ldi	r25, 0x01	; 1
    6020:	29 81       	ldd	r18, Y+1	; 0x01
    6022:	fc 01       	movw	r30, r24
    6024:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    6026:	80 ec       	ldi	r24, 0xC0	; 192
    6028:	91 e0       	ldi	r25, 0x01	; 1
    602a:	29 81       	ldd	r18, Y+1	; 0x01
    602c:	3a 81       	ldd	r19, Y+2	; 0x02
    602e:	23 2f       	mov	r18, r19
    6030:	33 27       	eor	r19, r19
    6032:	2f 71       	andi	r18, 0x1F	; 31
    6034:	fc 01       	movw	r30, r24
    6036:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    6038:	80 ec       	ldi	r24, 0xC0	; 192
    603a:	91 e0       	ldi	r25, 0x01	; 1
    603c:	fc 01       	movw	r30, r24
    603e:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    6040:	80 ec       	ldi	r24, 0xC0	; 192
    6042:	91 e0       	ldi	r25, 0x01	; 1
    6044:	2b 81       	ldd	r18, Y+3	; 0x03
    6046:	fc 01       	movw	r30, r24
    6048:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    604a:	80 ec       	ldi	r24, 0xC0	; 192
    604c:	91 e0       	ldi	r25, 0x01	; 1
    604e:	25 e3       	ldi	r18, 0x35	; 53
    6050:	fc 01       	movw	r30, r24
    6052:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    6054:	ef 93       	push	r30
    6056:	ff 93       	push	r31
    6058:	0f 93       	push	r16
    605a:	2f 93       	push	r18
    605c:	eb ec       	ldi	r30, 0xCB	; 203
    605e:	f1 e0       	ldi	r31, 0x01	; 1
    6060:	08 ed       	ldi	r16, 0xD8	; 216
    6062:	21 e0       	ldi	r18, 0x01	; 1
    6064:	04 bf       	out	0x34, r16	; 52
    6066:	20 83       	st	Z, r18
    6068:	2f 91       	pop	r18
    606a:	0f 91       	pop	r16
    606c:	ff 91       	pop	r31
    606e:	ef 91       	pop	r30
}
    6070:	23 96       	adiw	r28, 0x03	; 3
    6072:	cd bf       	out	0x3d, r28	; 61
    6074:	de bf       	out	0x3e, r29	; 62
    6076:	df 91       	pop	r29
    6078:	cf 91       	pop	r28
    607a:	08 95       	ret

0000607c <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    607c:	cf 93       	push	r28
    607e:	df 93       	push	r29
    6080:	0f 92       	push	r0
    6082:	0f 92       	push	r0
    6084:	cd b7       	in	r28, 0x3d	; 61
    6086:	de b7       	in	r29, 0x3e	; 62
    6088:	89 83       	std	Y+1, r24	; 0x01
    608a:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    608c:	00 00       	nop
    608e:	80 ec       	ldi	r24, 0xC0	; 192
    6090:	91 e0       	ldi	r25, 0x01	; 1
    6092:	fc 01       	movw	r30, r24
    6094:	87 85       	ldd	r24, Z+15	; 0x0f
    6096:	88 23       	and	r24, r24
    6098:	d4 f3       	brlt	.-12     	; 0x608e <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    609a:	80 ec       	ldi	r24, 0xC0	; 192
    609c:	91 e0       	ldi	r25, 0x01	; 1
    609e:	29 81       	ldd	r18, Y+1	; 0x01
    60a0:	fc 01       	movw	r30, r24
    60a2:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    60a4:	80 ec       	ldi	r24, 0xC0	; 192
    60a6:	91 e0       	ldi	r25, 0x01	; 1
    60a8:	29 81       	ldd	r18, Y+1	; 0x01
    60aa:	3a 81       	ldd	r19, Y+2	; 0x02
    60ac:	23 2f       	mov	r18, r19
    60ae:	33 27       	eor	r19, r19
    60b0:	2f 71       	andi	r18, 0x1F	; 31
    60b2:	fc 01       	movw	r30, r24
    60b4:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    60b6:	80 ec       	ldi	r24, 0xC0	; 192
    60b8:	91 e0       	ldi	r25, 0x01	; 1
    60ba:	fc 01       	movw	r30, r24
    60bc:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    60be:	80 ec       	ldi	r24, 0xC0	; 192
    60c0:	91 e0       	ldi	r25, 0x01	; 1
    60c2:	26 e0       	ldi	r18, 0x06	; 6
    60c4:	fc 01       	movw	r30, r24
    60c6:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    60c8:	ef 93       	push	r30
    60ca:	ff 93       	push	r31
    60cc:	0f 93       	push	r16
    60ce:	2f 93       	push	r18
    60d0:	eb ec       	ldi	r30, 0xCB	; 203
    60d2:	f1 e0       	ldi	r31, 0x01	; 1
    60d4:	08 ed       	ldi	r16, 0xD8	; 216
    60d6:	21 e0       	ldi	r18, 0x01	; 1
    60d8:	04 bf       	out	0x34, r16	; 52
    60da:	20 83       	st	Z, r18
    60dc:	2f 91       	pop	r18
    60de:	0f 91       	pop	r16
    60e0:	ff 91       	pop	r31
    60e2:	ef 91       	pop	r30

    return NVM.DATA0;
    60e4:	80 ec       	ldi	r24, 0xC0	; 192
    60e6:	91 e0       	ldi	r25, 0x01	; 1
    60e8:	fc 01       	movw	r30, r24
    60ea:	84 81       	ldd	r24, Z+4	; 0x04
}
    60ec:	0f 90       	pop	r0
    60ee:	0f 90       	pop	r0
    60f0:	df 91       	pop	r29
    60f2:	cf 91       	pop	r28
    60f4:	08 95       	ret

000060f6 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    60f6:	cf 93       	push	r28
    60f8:	df 93       	push	r29
    60fa:	cd b7       	in	r28, 0x3d	; 61
    60fc:	de b7       	in	r29, 0x3e	; 62
    60fe:	27 97       	sbiw	r28, 0x07	; 7
    6100:	cd bf       	out	0x3d, r28	; 61
    6102:	de bf       	out	0x3e, r29	; 62
    6104:	8a 83       	std	Y+2, r24	; 0x02
    6106:	9b 83       	std	Y+3, r25	; 0x03
    6108:	6c 83       	std	Y+4, r22	; 0x04
    610a:	7d 83       	std	Y+5, r23	; 0x05
    610c:	4e 83       	std	Y+6, r20	; 0x06
    610e:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    6110:	80 ec       	ldi	r24, 0xC0	; 192
    6112:	91 e0       	ldi	r25, 0x01	; 1
    6114:	20 ec       	ldi	r18, 0xC0	; 192
    6116:	31 e0       	ldi	r19, 0x01	; 1
    6118:	f9 01       	movw	r30, r18
    611a:	24 85       	ldd	r18, Z+12	; 0x0c
    611c:	27 7f       	andi	r18, 0xF7	; 247
    611e:	fc 01       	movw	r30, r24
    6120:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    6122:	19 82       	std	Y+1, r1	; 0x01
    6124:	16 c0       	rjmp	.+44     	; 0x6152 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    6126:	89 81       	ldd	r24, Y+1	; 0x01
    6128:	28 2f       	mov	r18, r24
    612a:	30 e0       	ldi	r19, 0x00	; 0
    612c:	8a 81       	ldd	r24, Y+2	; 0x02
    612e:	9b 81       	ldd	r25, Y+3	; 0x03
    6130:	82 0f       	add	r24, r18
    6132:	93 1f       	adc	r25, r19
    6134:	29 81       	ldd	r18, Y+1	; 0x01
    6136:	22 2f       	mov	r18, r18
    6138:	30 e0       	ldi	r19, 0x00	; 0
    613a:	4c 81       	ldd	r20, Y+4	; 0x04
    613c:	5d 81       	ldd	r21, Y+5	; 0x05
    613e:	24 0f       	add	r18, r20
    6140:	35 1f       	adc	r19, r21
    6142:	f9 01       	movw	r30, r18
    6144:	20 81       	ld	r18, Z
    6146:	62 2f       	mov	r22, r18
    6148:	0e 94 dd 2f 	call	0x5fba	; 0x5fba <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    614c:	89 81       	ldd	r24, Y+1	; 0x01
    614e:	8f 5f       	subi	r24, 0xFF	; 255
    6150:	89 83       	std	Y+1, r24	; 0x01
    6152:	89 81       	ldd	r24, Y+1	; 0x01
    6154:	28 2f       	mov	r18, r24
    6156:	30 e0       	ldi	r19, 0x00	; 0
    6158:	8e 81       	ldd	r24, Y+6	; 0x06
    615a:	9f 81       	ldd	r25, Y+7	; 0x07
    615c:	28 17       	cp	r18, r24
    615e:	39 07       	cpc	r19, r25
    6160:	10 f3       	brcs	.-60     	; 0x6126 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    6162:	27 96       	adiw	r28, 0x07	; 7
    6164:	cd bf       	out	0x3d, r28	; 61
    6166:	de bf       	out	0x3e, r29	; 62
    6168:	df 91       	pop	r29
    616a:	cf 91       	pop	r28
    616c:	08 95       	ret

0000616e <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    616e:	0f 93       	push	r16
    6170:	1f 93       	push	r17
    6172:	cf 93       	push	r28
    6174:	df 93       	push	r29
    6176:	cd b7       	in	r28, 0x3d	; 61
    6178:	de b7       	in	r29, 0x3e	; 62
    617a:	27 97       	sbiw	r28, 0x07	; 7
    617c:	cd bf       	out	0x3d, r28	; 61
    617e:	de bf       	out	0x3e, r29	; 62
    6180:	8a 83       	std	Y+2, r24	; 0x02
    6182:	9b 83       	std	Y+3, r25	; 0x03
    6184:	6c 83       	std	Y+4, r22	; 0x04
    6186:	7d 83       	std	Y+5, r23	; 0x05
    6188:	4e 83       	std	Y+6, r20	; 0x06
    618a:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    618c:	80 ec       	ldi	r24, 0xC0	; 192
    618e:	91 e0       	ldi	r25, 0x01	; 1
    6190:	20 ec       	ldi	r18, 0xC0	; 192
    6192:	31 e0       	ldi	r19, 0x01	; 1
    6194:	f9 01       	movw	r30, r18
    6196:	24 85       	ldd	r18, Z+12	; 0x0c
    6198:	27 7f       	andi	r18, 0xF7	; 247
    619a:	fc 01       	movw	r30, r24
    619c:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    619e:	19 82       	std	Y+1, r1	; 0x01
    61a0:	16 c0       	rjmp	.+44     	; 0x61ce <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    61a2:	89 81       	ldd	r24, Y+1	; 0x01
    61a4:	88 2f       	mov	r24, r24
    61a6:	90 e0       	ldi	r25, 0x00	; 0
    61a8:	2c 81       	ldd	r18, Y+4	; 0x04
    61aa:	3d 81       	ldd	r19, Y+5	; 0x05
    61ac:	89 01       	movw	r16, r18
    61ae:	08 0f       	add	r16, r24
    61b0:	19 1f       	adc	r17, r25
    61b2:	89 81       	ldd	r24, Y+1	; 0x01
    61b4:	28 2f       	mov	r18, r24
    61b6:	30 e0       	ldi	r19, 0x00	; 0
    61b8:	8a 81       	ldd	r24, Y+2	; 0x02
    61ba:	9b 81       	ldd	r25, Y+3	; 0x03
    61bc:	82 0f       	add	r24, r18
    61be:	93 1f       	adc	r25, r19
    61c0:	0e 94 3e 30 	call	0x607c	; 0x607c <chb_eep_read_byte>
    61c4:	f8 01       	movw	r30, r16
    61c6:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    61c8:	89 81       	ldd	r24, Y+1	; 0x01
    61ca:	8f 5f       	subi	r24, 0xFF	; 255
    61cc:	89 83       	std	Y+1, r24	; 0x01
    61ce:	89 81       	ldd	r24, Y+1	; 0x01
    61d0:	28 2f       	mov	r18, r24
    61d2:	30 e0       	ldi	r19, 0x00	; 0
    61d4:	8e 81       	ldd	r24, Y+6	; 0x06
    61d6:	9f 81       	ldd	r25, Y+7	; 0x07
    61d8:	28 17       	cp	r18, r24
    61da:	39 07       	cpc	r19, r25
    61dc:	10 f3       	brcs	.-60     	; 0x61a2 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    61de:	27 96       	adiw	r28, 0x07	; 7
    61e0:	cd bf       	out	0x3d, r28	; 61
    61e2:	de bf       	out	0x3e, r29	; 62
    61e4:	df 91       	pop	r29
    61e6:	cf 91       	pop	r28
    61e8:	1f 91       	pop	r17
    61ea:	0f 91       	pop	r16
    61ec:	08 95       	ret

000061ee <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    61ee:	cf 93       	push	r28
    61f0:	df 93       	push	r29
    61f2:	cd b7       	in	r28, 0x3d	; 61
    61f4:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    61f6:	80 e6       	ldi	r24, 0x60	; 96
    61f8:	96 e0       	ldi	r25, 0x06	; 6
    61fa:	20 e6       	ldi	r18, 0x60	; 96
    61fc:	36 e0       	ldi	r19, 0x06	; 6
    61fe:	f9 01       	movw	r30, r18
    6200:	20 81       	ld	r18, Z
    6202:	20 6b       	ori	r18, 0xB0	; 176
    6204:	fc 01       	movw	r30, r24
    6206:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    6208:	84 e6       	ldi	r24, 0x64	; 100
    620a:	96 e0       	ldi	r25, 0x06	; 6
    620c:	24 e6       	ldi	r18, 0x64	; 100
    620e:	36 e0       	ldi	r19, 0x06	; 6
    6210:	f9 01       	movw	r30, r18
    6212:	20 81       	ld	r18, Z
    6214:	20 61       	ori	r18, 0x10	; 16
    6216:	fc 01       	movw	r30, r24
    6218:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    621a:	80 ec       	ldi	r24, 0xC0	; 192
    621c:	99 e0       	ldi	r25, 0x09	; 9
    621e:	20 ec       	ldi	r18, 0xC0	; 192
    6220:	39 e0       	ldi	r19, 0x09	; 9
    6222:	f9 01       	movw	r30, r18
    6224:	20 81       	ld	r18, Z
    6226:	21 65       	ori	r18, 0x51	; 81
    6228:	fc 01       	movw	r30, r24
    622a:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    622c:	84 e6       	ldi	r24, 0x64	; 100
    622e:	96 e0       	ldi	r25, 0x06	; 6
    6230:	24 e6       	ldi	r18, 0x64	; 100
    6232:	36 e0       	ldi	r19, 0x06	; 6
    6234:	f9 01       	movw	r30, r18
    6236:	20 81       	ld	r18, Z
    6238:	20 61       	ori	r18, 0x10	; 16
    623a:	fc 01       	movw	r30, r24
    623c:	20 83       	st	Z, r18
}
    623e:	df 91       	pop	r29
    6240:	cf 91       	pop	r28
    6242:	08 95       	ret

00006244 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    6244:	cf 93       	push	r28
    6246:	df 93       	push	r29
    6248:	0f 92       	push	r0
    624a:	0f 92       	push	r0
    624c:	cd b7       	in	r28, 0x3d	; 61
    624e:	de b7       	in	r29, 0x3e	; 62
    6250:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    6252:	80 ec       	ldi	r24, 0xC0	; 192
    6254:	99 e0       	ldi	r25, 0x09	; 9
    6256:	2a 81       	ldd	r18, Y+2	; 0x02
    6258:	fc 01       	movw	r30, r24
    625a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    625c:	00 00       	nop
    625e:	80 ec       	ldi	r24, 0xC0	; 192
    6260:	99 e0       	ldi	r25, 0x09	; 9
    6262:	fc 01       	movw	r30, r24
    6264:	82 81       	ldd	r24, Z+2	; 0x02
    6266:	88 23       	and	r24, r24
    6268:	d4 f7       	brge	.-12     	; 0x625e <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    626a:	80 ec       	ldi	r24, 0xC0	; 192
    626c:	99 e0       	ldi	r25, 0x09	; 9
    626e:	fc 01       	movw	r30, r24
    6270:	83 81       	ldd	r24, Z+3	; 0x03
    6272:	89 83       	std	Y+1, r24	; 0x01
	return data;
    6274:	89 81       	ldd	r24, Y+1	; 0x01
    6276:	0f 90       	pop	r0
    6278:	0f 90       	pop	r0
    627a:	df 91       	pop	r29
    627c:	cf 91       	pop	r28
    627e:	08 95       	ret

00006280 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    6280:	0f 93       	push	r16
    6282:	cf 93       	push	r28
    6284:	df 93       	push	r29
    6286:	00 d0       	rcall	.+0      	; 0x6288 <CCPWrite+0x8>
    6288:	00 d0       	rcall	.+0      	; 0x628a <CCPWrite+0xa>
    628a:	cd b7       	in	r28, 0x3d	; 61
    628c:	de b7       	in	r29, 0x3e	; 62
    628e:	8c 83       	std	Y+4, r24	; 0x04
    6290:	9d 83       	std	Y+5, r25	; 0x05
    6292:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    6294:	8f e3       	ldi	r24, 0x3F	; 63
    6296:	90 e0       	ldi	r25, 0x00	; 0
    6298:	fc 01       	movw	r30, r24
    629a:	80 81       	ld	r24, Z
    629c:	8b 83       	std	Y+3, r24	; 0x03
    629e:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    62a0:	8c 81       	ldd	r24, Y+4	; 0x04
    62a2:	9d 81       	ldd	r25, Y+5	; 0x05
    62a4:	89 83       	std	Y+1, r24	; 0x01
    62a6:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    62a8:	8b e3       	ldi	r24, 0x3B	; 59
    62aa:	90 e0       	ldi	r25, 0x00	; 0
    62ac:	fc 01       	movw	r30, r24
    62ae:	10 82       	st	Z, r1
#endif
	asm volatile(
    62b0:	89 81       	ldd	r24, Y+1	; 0x01
    62b2:	9a 81       	ldd	r25, Y+2	; 0x02
    62b4:	2e 81       	ldd	r18, Y+6	; 0x06
    62b6:	fc 01       	movw	r30, r24
    62b8:	08 ed       	ldi	r16, 0xD8	; 216
    62ba:	04 bf       	out	0x34, r16	; 52
    62bc:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    62be:	8f e3       	ldi	r24, 0x3F	; 63
    62c0:	90 e0       	ldi	r25, 0x00	; 0
    62c2:	2b 81       	ldd	r18, Y+3	; 0x03
    62c4:	fc 01       	movw	r30, r24
    62c6:	20 83       	st	Z, r18
#endif
}
    62c8:	26 96       	adiw	r28, 0x06	; 6
    62ca:	cd bf       	out	0x3d, r28	; 61
    62cc:	de bf       	out	0x3e, r29	; 62
    62ce:	df 91       	pop	r29
    62d0:	cf 91       	pop	r28
    62d2:	0f 91       	pop	r16
    62d4:	08 95       	ret

000062d6 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    62d6:	cf 93       	push	r28
    62d8:	df 93       	push	r29
    62da:	00 d0       	rcall	.+0      	; 0x62dc <CLKSYS_XOSC_Config+0x6>
    62dc:	cd b7       	in	r28, 0x3d	; 61
    62de:	de b7       	in	r29, 0x3e	; 62
    62e0:	89 83       	std	Y+1, r24	; 0x01
    62e2:	6a 83       	std	Y+2, r22	; 0x02
    62e4:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    62e6:	80 e5       	ldi	r24, 0x50	; 80
    62e8:	90 e0       	ldi	r25, 0x00	; 0
    62ea:	2a 81       	ldd	r18, Y+2	; 0x02
    62ec:	22 23       	and	r18, r18
    62ee:	11 f0       	breq	.+4      	; 0x62f4 <CLKSYS_XOSC_Config+0x1e>
    62f0:	20 e2       	ldi	r18, 0x20	; 32
    62f2:	01 c0       	rjmp	.+2      	; 0x62f6 <CLKSYS_XOSC_Config+0x20>
    62f4:	20 e0       	ldi	r18, 0x00	; 0
    62f6:	39 81       	ldd	r19, Y+1	; 0x01
    62f8:	32 2b       	or	r19, r18
    62fa:	2b 81       	ldd	r18, Y+3	; 0x03
    62fc:	23 2b       	or	r18, r19
    62fe:	fc 01       	movw	r30, r24
    6300:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    6302:	23 96       	adiw	r28, 0x03	; 3
    6304:	cd bf       	out	0x3d, r28	; 61
    6306:	de bf       	out	0x3e, r29	; 62
    6308:	df 91       	pop	r29
    630a:	cf 91       	pop	r28
    630c:	08 95       	ret

0000630e <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    630e:	cf 93       	push	r28
    6310:	df 93       	push	r29
    6312:	0f 92       	push	r0
    6314:	0f 92       	push	r0
    6316:	cd b7       	in	r28, 0x3d	; 61
    6318:	de b7       	in	r29, 0x3e	; 62
    631a:	89 83       	std	Y+1, r24	; 0x01
    631c:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    631e:	8a 81       	ldd	r24, Y+2	; 0x02
    6320:	8f 71       	andi	r24, 0x1F	; 31
    6322:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    6324:	80 e5       	ldi	r24, 0x50	; 80
    6326:	90 e0       	ldi	r25, 0x00	; 0
    6328:	39 81       	ldd	r19, Y+1	; 0x01
    632a:	2a 81       	ldd	r18, Y+2	; 0x02
    632c:	23 2b       	or	r18, r19
    632e:	fc 01       	movw	r30, r24
    6330:	25 83       	std	Z+5, r18	; 0x05
}
    6332:	0f 90       	pop	r0
    6334:	0f 90       	pop	r0
    6336:	df 91       	pop	r29
    6338:	cf 91       	pop	r28
    633a:	08 95       	ret

0000633c <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    633c:	cf 93       	push	r28
    633e:	df 93       	push	r29
    6340:	0f 92       	push	r0
    6342:	0f 92       	push	r0
    6344:	cd b7       	in	r28, 0x3d	; 61
    6346:	de b7       	in	r29, 0x3e	; 62
    6348:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    634a:	80 e5       	ldi	r24, 0x50	; 80
    634c:	90 e0       	ldi	r25, 0x00	; 0
    634e:	20 e5       	ldi	r18, 0x50	; 80
    6350:	30 e0       	ldi	r19, 0x00	; 0
    6352:	f9 01       	movw	r30, r18
    6354:	20 81       	ld	r18, Z
    6356:	32 2f       	mov	r19, r18
    6358:	2a 81       	ldd	r18, Y+2	; 0x02
    635a:	20 95       	com	r18
    635c:	23 23       	and	r18, r19
    635e:	fc 01       	movw	r30, r24
    6360:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    6362:	80 e5       	ldi	r24, 0x50	; 80
    6364:	90 e0       	ldi	r25, 0x00	; 0
    6366:	fc 01       	movw	r30, r24
    6368:	90 81       	ld	r25, Z
    636a:	8a 81       	ldd	r24, Y+2	; 0x02
    636c:	89 23       	and	r24, r25
    636e:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    6370:	89 81       	ldd	r24, Y+1	; 0x01
}
    6372:	0f 90       	pop	r0
    6374:	0f 90       	pop	r0
    6376:	df 91       	pop	r29
    6378:	cf 91       	pop	r28
    637a:	08 95       	ret

0000637c <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    637c:	cf 93       	push	r28
    637e:	df 93       	push	r29
    6380:	00 d0       	rcall	.+0      	; 0x6382 <CLKSYS_Prescalers_Config+0x6>
    6382:	cd b7       	in	r28, 0x3d	; 61
    6384:	de b7       	in	r29, 0x3e	; 62
    6386:	8a 83       	std	Y+2, r24	; 0x02
    6388:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    638a:	9a 81       	ldd	r25, Y+2	; 0x02
    638c:	8b 81       	ldd	r24, Y+3	; 0x03
    638e:	89 2b       	or	r24, r25
    6390:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    6392:	81 e4       	ldi	r24, 0x41	; 65
    6394:	90 e0       	ldi	r25, 0x00	; 0
    6396:	69 81       	ldd	r22, Y+1	; 0x01
    6398:	0e 94 40 31 	call	0x6280	; 0x6280 <CCPWrite>
}
    639c:	23 96       	adiw	r28, 0x03	; 3
    639e:	cd bf       	out	0x3d, r28	; 61
    63a0:	de bf       	out	0x3e, r29	; 62
    63a2:	df 91       	pop	r29
    63a4:	cf 91       	pop	r28
    63a6:	08 95       	ret

000063a8 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    63a8:	cf 93       	push	r28
    63aa:	df 93       	push	r29
    63ac:	0f 92       	push	r0
    63ae:	0f 92       	push	r0
    63b0:	cd b7       	in	r28, 0x3d	; 61
    63b2:	de b7       	in	r29, 0x3e	; 62
    63b4:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    63b6:	80 e4       	ldi	r24, 0x40	; 64
    63b8:	90 e0       	ldi	r25, 0x00	; 0
    63ba:	fc 01       	movw	r30, r24
    63bc:	80 81       	ld	r24, Z
    63be:	98 2f       	mov	r25, r24
    63c0:	98 7f       	andi	r25, 0xF8	; 248
    63c2:	8a 81       	ldd	r24, Y+2	; 0x02
    63c4:	89 2b       	or	r24, r25
    63c6:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    63c8:	80 e4       	ldi	r24, 0x40	; 64
    63ca:	90 e0       	ldi	r25, 0x00	; 0
    63cc:	69 81       	ldd	r22, Y+1	; 0x01
    63ce:	0e 94 40 31 	call	0x6280	; 0x6280 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    63d2:	80 e4       	ldi	r24, 0x40	; 64
    63d4:	90 e0       	ldi	r25, 0x00	; 0
    63d6:	fc 01       	movw	r30, r24
    63d8:	90 81       	ld	r25, Z
    63da:	8a 81       	ldd	r24, Y+2	; 0x02
    63dc:	89 23       	and	r24, r25
    63de:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    63e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    63e2:	0f 90       	pop	r0
    63e4:	0f 90       	pop	r0
    63e6:	df 91       	pop	r29
    63e8:	cf 91       	pop	r28
    63ea:	08 95       	ret

000063ec <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    63ec:	cf 93       	push	r28
    63ee:	df 93       	push	r29
    63f0:	0f 92       	push	r0
    63f2:	cd b7       	in	r28, 0x3d	; 61
    63f4:	de b7       	in	r29, 0x3e	; 62
    63f6:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    63f8:	80 e4       	ldi	r24, 0x40	; 64
    63fa:	90 e0       	ldi	r25, 0x00	; 0
    63fc:	20 e4       	ldi	r18, 0x40	; 64
    63fe:	30 e0       	ldi	r19, 0x00	; 0
    6400:	f9 01       	movw	r30, r18
    6402:	23 81       	ldd	r18, Z+3	; 0x03
    6404:	32 2f       	mov	r19, r18
    6406:	31 7f       	andi	r19, 0xF1	; 241
    6408:	29 81       	ldd	r18, Y+1	; 0x01
    640a:	23 2b       	or	r18, r19
    640c:	21 60       	ori	r18, 0x01	; 1
    640e:	fc 01       	movw	r30, r24
    6410:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    6412:	0f 90       	pop	r0
    6414:	df 91       	pop	r29
    6416:	cf 91       	pop	r28
    6418:	08 95       	ret

0000641a <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    641a:	cf 93       	push	r28
    641c:	df 93       	push	r29
    641e:	0f 92       	push	r0
    6420:	0f 92       	push	r0
    6422:	cd b7       	in	r28, 0x3d	; 61
    6424:	de b7       	in	r29, 0x3e	; 62
    6426:	89 83       	std	Y+1, r24	; 0x01
    6428:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    642a:	80 e5       	ldi	r24, 0x50	; 80
    642c:	90 e0       	ldi	r25, 0x00	; 0
    642e:	20 e5       	ldi	r18, 0x50	; 80
    6430:	30 e0       	ldi	r19, 0x00	; 0
    6432:	f9 01       	movw	r30, r18
    6434:	26 81       	ldd	r18, Z+6	; 0x06
    6436:	32 2f       	mov	r19, r18
    6438:	29 81       	ldd	r18, Y+1	; 0x01
    643a:	20 95       	com	r18
    643c:	32 23       	and	r19, r18
    643e:	2a 81       	ldd	r18, Y+2	; 0x02
    6440:	22 23       	and	r18, r18
    6442:	11 f0       	breq	.+4      	; 0x6448 <CLKSYS_AutoCalibration_Enable+0x2e>
    6444:	29 81       	ldd	r18, Y+1	; 0x01
    6446:	01 c0       	rjmp	.+2      	; 0x644a <CLKSYS_AutoCalibration_Enable+0x30>
    6448:	20 e0       	ldi	r18, 0x00	; 0
    644a:	23 2b       	or	r18, r19
    644c:	fc 01       	movw	r30, r24
    644e:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    6450:	89 81       	ldd	r24, Y+1	; 0x01
    6452:	81 30       	cpi	r24, 0x01	; 1
    6454:	51 f4       	brne	.+20     	; 0x646a <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    6456:	88 e6       	ldi	r24, 0x68	; 104
    6458:	90 e0       	ldi	r25, 0x00	; 0
    645a:	28 e6       	ldi	r18, 0x68	; 104
    645c:	30 e0       	ldi	r19, 0x00	; 0
    645e:	f9 01       	movw	r30, r18
    6460:	20 81       	ld	r18, Z
    6462:	21 60       	ori	r18, 0x01	; 1
    6464:	fc 01       	movw	r30, r24
    6466:	20 83       	st	Z, r18
    6468:	0c c0       	rjmp	.+24     	; 0x6482 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    646a:	89 81       	ldd	r24, Y+1	; 0x01
    646c:	82 30       	cpi	r24, 0x02	; 2
    646e:	49 f4       	brne	.+18     	; 0x6482 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    6470:	80 e6       	ldi	r24, 0x60	; 96
    6472:	90 e0       	ldi	r25, 0x00	; 0
    6474:	20 e6       	ldi	r18, 0x60	; 96
    6476:	30 e0       	ldi	r19, 0x00	; 0
    6478:	f9 01       	movw	r30, r18
    647a:	20 81       	ld	r18, Z
    647c:	21 60       	ori	r18, 0x01	; 1
    647e:	fc 01       	movw	r30, r24
    6480:	20 83       	st	Z, r18
	}
}
    6482:	0f 90       	pop	r0
    6484:	0f 90       	pop	r0
    6486:	df 91       	pop	r29
    6488:	cf 91       	pop	r28
    648a:	08 95       	ret

0000648c <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    648c:	cf 93       	push	r28
    648e:	df 93       	push	r29
    6490:	cd b7       	in	r28, 0x3d	; 61
    6492:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    6494:	83 e5       	ldi	r24, 0x53	; 83
    6496:	90 e0       	ldi	r25, 0x00	; 0
    6498:	63 e0       	ldi	r22, 0x03	; 3
    649a:	0e 94 40 31 	call	0x6280	; 0x6280 <CCPWrite>
}
    649e:	df 91       	pop	r29
    64a0:	cf 91       	pop	r28
    64a2:	08 95       	ret

000064a4 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    64a4:	cf 93       	push	r28
    64a6:	df 93       	push	r29
    64a8:	cd b7       	in	r28, 0x3d	; 61
    64aa:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    64ac:	82 e4       	ldi	r24, 0x42	; 66
    64ae:	90 e0       	ldi	r25, 0x00	; 0
    64b0:	61 e0       	ldi	r22, 0x01	; 1
    64b2:	0e 94 40 31 	call	0x6280	; 0x6280 <CCPWrite>
}
    64b6:	df 91       	pop	r29
    64b8:	cf 91       	pop	r28
    64ba:	08 95       	ret

000064bc <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    64bc:	cf 93       	push	r28
    64be:	df 93       	push	r29
    64c0:	cd b7       	in	r28, 0x3d	; 61
    64c2:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    64c4:	80 ec       	ldi	r24, 0xC0	; 192
    64c6:	60 e0       	ldi	r22, 0x00	; 0
    64c8:	4b e0       	ldi	r20, 0x0B	; 11
    64ca:	0e 94 6b 31 	call	0x62d6	; 0x62d6 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    64ce:	80 e5       	ldi	r24, 0x50	; 80
    64d0:	90 e0       	ldi	r25, 0x00	; 0
    64d2:	20 e5       	ldi	r18, 0x50	; 80
    64d4:	30 e0       	ldi	r19, 0x00	; 0
    64d6:	f9 01       	movw	r30, r18
    64d8:	20 81       	ld	r18, Z
    64da:	28 60       	ori	r18, 0x08	; 8
    64dc:	fc 01       	movw	r30, r24
    64de:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    64e0:	80 e5       	ldi	r24, 0x50	; 80
    64e2:	90 e0       	ldi	r25, 0x00	; 0
    64e4:	fc 01       	movw	r30, r24
    64e6:	81 81       	ldd	r24, Z+1	; 0x01
    64e8:	88 2f       	mov	r24, r24
    64ea:	90 e0       	ldi	r25, 0x00	; 0
    64ec:	88 70       	andi	r24, 0x08	; 8
    64ee:	90 70       	andi	r25, 0x00	; 0
    64f0:	00 97       	sbiw	r24, 0x00	; 0
    64f2:	b1 f3       	breq	.-20     	; 0x64e0 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    64f4:	80 ec       	ldi	r24, 0xC0	; 192
    64f6:	62 e0       	ldi	r22, 0x02	; 2
    64f8:	0e 94 87 31 	call	0x630e	; 0x630e <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    64fc:	80 e5       	ldi	r24, 0x50	; 80
    64fe:	90 e0       	ldi	r25, 0x00	; 0
    6500:	20 e5       	ldi	r18, 0x50	; 80
    6502:	30 e0       	ldi	r19, 0x00	; 0
    6504:	f9 01       	movw	r30, r18
    6506:	20 81       	ld	r18, Z
    6508:	20 61       	ori	r18, 0x10	; 16
    650a:	fc 01       	movw	r30, r24
    650c:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    650e:	80 e5       	ldi	r24, 0x50	; 80
    6510:	90 e0       	ldi	r25, 0x00	; 0
    6512:	fc 01       	movw	r30, r24
    6514:	81 81       	ldd	r24, Z+1	; 0x01
    6516:	88 2f       	mov	r24, r24
    6518:	90 e0       	ldi	r25, 0x00	; 0
    651a:	80 71       	andi	r24, 0x10	; 16
    651c:	90 70       	andi	r25, 0x00	; 0
    651e:	00 97       	sbiw	r24, 0x00	; 0
    6520:	b1 f3       	breq	.-20     	; 0x650e <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    6522:	84 e0       	ldi	r24, 0x04	; 4
    6524:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6528:	81 e0       	ldi	r24, 0x01	; 1
    652a:	0e 94 9e 31 	call	0x633c	; 0x633c <CLKSYS_Disable>
}
    652e:	df 91       	pop	r29
    6530:	cf 91       	pop	r28
    6532:	08 95       	ret

00006534 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    6534:	cf 93       	push	r28
    6536:	df 93       	push	r29
    6538:	cd b7       	in	r28, 0x3d	; 61
    653a:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    653c:	80 e5       	ldi	r24, 0x50	; 80
    653e:	90 e0       	ldi	r25, 0x00	; 0
    6540:	20 e5       	ldi	r18, 0x50	; 80
    6542:	30 e0       	ldi	r19, 0x00	; 0
    6544:	f9 01       	movw	r30, r18
    6546:	20 81       	ld	r18, Z
    6548:	22 60       	ori	r18, 0x02	; 2
    654a:	fc 01       	movw	r30, r24
    654c:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    654e:	80 e0       	ldi	r24, 0x00	; 0
    6550:	61 e0       	ldi	r22, 0x01	; 1
    6552:	0e 94 be 31 	call	0x637c	; 0x637c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6556:	80 e5       	ldi	r24, 0x50	; 80
    6558:	90 e0       	ldi	r25, 0x00	; 0
    655a:	fc 01       	movw	r30, r24
    655c:	81 81       	ldd	r24, Z+1	; 0x01
    655e:	88 2f       	mov	r24, r24
    6560:	90 e0       	ldi	r25, 0x00	; 0
    6562:	82 70       	andi	r24, 0x02	; 2
    6564:	90 70       	andi	r25, 0x00	; 0
    6566:	00 97       	sbiw	r24, 0x00	; 0
    6568:	b1 f3       	breq	.-20     	; 0x6556 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    656a:	81 e0       	ldi	r24, 0x01	; 1
    656c:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6570:	81 e0       	ldi	r24, 0x01	; 1
    6572:	0e 94 9e 31 	call	0x633c	; 0x633c <CLKSYS_Disable>
	
}
    6576:	df 91       	pop	r29
    6578:	cf 91       	pop	r28
    657a:	08 95       	ret

0000657c <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    657c:	cf 93       	push	r28
    657e:	df 93       	push	r29
    6580:	cd b7       	in	r28, 0x3d	; 61
    6582:	de b7       	in	r29, 0x3e	; 62
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6584:	80 e5       	ldi	r24, 0x50	; 80
    6586:	90 e0       	ldi	r25, 0x00	; 0
    6588:	20 e5       	ldi	r18, 0x50	; 80
    658a:	30 e0       	ldi	r19, 0x00	; 0
    658c:	f9 01       	movw	r30, r18
    658e:	20 81       	ld	r18, Z
    6590:	22 60       	ori	r18, 0x02	; 2
    6592:	fc 01       	movw	r30, r24
    6594:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6596:	80 e0       	ldi	r24, 0x00	; 0
    6598:	60 e0       	ldi	r22, 0x00	; 0
    659a:	0e 94 be 31 	call	0x637c	; 0x637c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    659e:	80 e5       	ldi	r24, 0x50	; 80
    65a0:	90 e0       	ldi	r25, 0x00	; 0
    65a2:	fc 01       	movw	r30, r24
    65a4:	81 81       	ldd	r24, Z+1	; 0x01
    65a6:	88 2f       	mov	r24, r24
    65a8:	90 e0       	ldi	r25, 0x00	; 0
    65aa:	82 70       	andi	r24, 0x02	; 2
    65ac:	90 70       	andi	r25, 0x00	; 0
    65ae:	00 97       	sbiw	r24, 0x00	; 0
    65b0:	b1 f3       	breq	.-20     	; 0x659e <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    65b2:	81 e0       	ldi	r24, 0x01	; 1
    65b4:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    65b8:	81 e0       	ldi	r24, 0x01	; 1
    65ba:	0e 94 9e 31 	call	0x633c	; 0x633c <CLKSYS_Disable>
	
}
    65be:	df 91       	pop	r29
    65c0:	cf 91       	pop	r28
    65c2:	08 95       	ret

000065c4 <portExCS>:


void portExCS(uint8_t write) {
    65c4:	0f 93       	push	r16
    65c6:	1f 93       	push	r17
    65c8:	cf 93       	push	r28
    65ca:	df 93       	push	r29
    65cc:	cd b7       	in	r28, 0x3d	; 61
    65ce:	de b7       	in	r29, 0x3e	; 62
    65d0:	69 97       	sbiw	r28, 0x19	; 25
    65d2:	cd bf       	out	0x3d, r28	; 61
    65d4:	de bf       	out	0x3e, r29	; 62
    65d6:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    65d8:	89 8d       	ldd	r24, Y+25	; 0x19
    65da:	88 23       	and	r24, r24
    65dc:	31 f0       	breq	.+12     	; 0x65ea <portExCS+0x26>
    65de:	80 e0       	ldi	r24, 0x00	; 0
    65e0:	96 e0       	ldi	r25, 0x06	; 6
    65e2:	28 e0       	ldi	r18, 0x08	; 8
    65e4:	fc 01       	movw	r30, r24
    65e6:	26 83       	std	Z+6, r18	; 0x06
    65e8:	05 c0       	rjmp	.+10     	; 0x65f4 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    65ea:	80 e0       	ldi	r24, 0x00	; 0
    65ec:	96 e0       	ldi	r25, 0x06	; 6
    65ee:	28 e0       	ldi	r18, 0x08	; 8
    65f0:	fc 01       	movw	r30, r24
    65f2:	25 83       	std	Z+5, r18	; 0x05
    65f4:	80 e0       	ldi	r24, 0x00	; 0
    65f6:	90 e0       	ldi	r25, 0x00	; 0
    65f8:	a0 e2       	ldi	r26, 0x20	; 32
    65fa:	b1 e4       	ldi	r27, 0x41	; 65
    65fc:	89 83       	std	Y+1, r24	; 0x01
    65fe:	9a 83       	std	Y+2, r25	; 0x02
    6600:	ab 83       	std	Y+3, r26	; 0x03
    6602:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6604:	69 81       	ldd	r22, Y+1	; 0x01
    6606:	7a 81       	ldd	r23, Y+2	; 0x02
    6608:	8b 81       	ldd	r24, Y+3	; 0x03
    660a:	9c 81       	ldd	r25, Y+4	; 0x04
    660c:	2b ea       	ldi	r18, 0xAB	; 171
    660e:	3a ea       	ldi	r19, 0xAA	; 170
    6610:	4a e2       	ldi	r20, 0x2A	; 42
    6612:	51 e4       	ldi	r21, 0x41	; 65
    6614:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6618:	dc 01       	movw	r26, r24
    661a:	cb 01       	movw	r24, r22
    661c:	8d 83       	std	Y+5, r24	; 0x05
    661e:	9e 83       	std	Y+6, r25	; 0x06
    6620:	af 83       	std	Y+7, r26	; 0x07
    6622:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6624:	11 e0       	ldi	r17, 0x01	; 1
    6626:	6d 81       	ldd	r22, Y+5	; 0x05
    6628:	7e 81       	ldd	r23, Y+6	; 0x06
    662a:	8f 81       	ldd	r24, Y+7	; 0x07
    662c:	98 85       	ldd	r25, Y+8	; 0x08
    662e:	20 e0       	ldi	r18, 0x00	; 0
    6630:	30 e0       	ldi	r19, 0x00	; 0
    6632:	40 e8       	ldi	r20, 0x80	; 128
    6634:	5f e3       	ldi	r21, 0x3F	; 63
    6636:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    663a:	88 23       	and	r24, r24
    663c:	0c f0       	brlt	.+2      	; 0x6640 <portExCS+0x7c>
    663e:	10 e0       	ldi	r17, 0x00	; 0
    6640:	11 23       	and	r17, r17
    6642:	19 f0       	breq	.+6      	; 0x664a <portExCS+0x86>
		__ticks = 1;
    6644:	81 e0       	ldi	r24, 0x01	; 1
    6646:	89 87       	std	Y+9, r24	; 0x09
    6648:	a3 c0       	rjmp	.+326    	; 0x6790 <portExCS+0x1cc>
	else if (__tmp > 255)
    664a:	11 e0       	ldi	r17, 0x01	; 1
    664c:	6d 81       	ldd	r22, Y+5	; 0x05
    664e:	7e 81       	ldd	r23, Y+6	; 0x06
    6650:	8f 81       	ldd	r24, Y+7	; 0x07
    6652:	98 85       	ldd	r25, Y+8	; 0x08
    6654:	20 e0       	ldi	r18, 0x00	; 0
    6656:	30 e0       	ldi	r19, 0x00	; 0
    6658:	4f e7       	ldi	r20, 0x7F	; 127
    665a:	53 e4       	ldi	r21, 0x43	; 67
    665c:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    6660:	18 16       	cp	r1, r24
    6662:	0c f0       	brlt	.+2      	; 0x6666 <portExCS+0xa2>
    6664:	10 e0       	ldi	r17, 0x00	; 0
    6666:	11 23       	and	r17, r17
    6668:	09 f4       	brne	.+2      	; 0x666c <portExCS+0xa8>
    666a:	89 c0       	rjmp	.+274    	; 0x677e <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    666c:	69 81       	ldd	r22, Y+1	; 0x01
    666e:	7a 81       	ldd	r23, Y+2	; 0x02
    6670:	8b 81       	ldd	r24, Y+3	; 0x03
    6672:	9c 81       	ldd	r25, Y+4	; 0x04
    6674:	20 e0       	ldi	r18, 0x00	; 0
    6676:	30 e0       	ldi	r19, 0x00	; 0
    6678:	4a e7       	ldi	r20, 0x7A	; 122
    667a:	54 e4       	ldi	r21, 0x44	; 68
    667c:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    6680:	dc 01       	movw	r26, r24
    6682:	cb 01       	movw	r24, r22
    6684:	8a 87       	std	Y+10, r24	; 0x0a
    6686:	9b 87       	std	Y+11, r25	; 0x0b
    6688:	ac 87       	std	Y+12, r26	; 0x0c
    668a:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    668c:	6a 85       	ldd	r22, Y+10	; 0x0a
    668e:	7b 85       	ldd	r23, Y+11	; 0x0b
    6690:	8c 85       	ldd	r24, Y+12	; 0x0c
    6692:	9d 85       	ldd	r25, Y+13	; 0x0d
    6694:	20 e0       	ldi	r18, 0x00	; 0
    6696:	30 e0       	ldi	r19, 0x00	; 0
    6698:	4a ef       	ldi	r20, 0xFA	; 250
    669a:	55 e4       	ldi	r21, 0x45	; 69
    669c:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    66a0:	dc 01       	movw	r26, r24
    66a2:	cb 01       	movw	r24, r22
    66a4:	8e 87       	std	Y+14, r24	; 0x0e
    66a6:	9f 87       	std	Y+15, r25	; 0x0f
    66a8:	a8 8b       	std	Y+16, r26	; 0x10
    66aa:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    66ac:	11 e0       	ldi	r17, 0x01	; 1
    66ae:	6e 85       	ldd	r22, Y+14	; 0x0e
    66b0:	7f 85       	ldd	r23, Y+15	; 0x0f
    66b2:	88 89       	ldd	r24, Y+16	; 0x10
    66b4:	99 89       	ldd	r25, Y+17	; 0x11
    66b6:	20 e0       	ldi	r18, 0x00	; 0
    66b8:	30 e0       	ldi	r19, 0x00	; 0
    66ba:	40 e8       	ldi	r20, 0x80	; 128
    66bc:	5f e3       	ldi	r21, 0x3F	; 63
    66be:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    66c2:	88 23       	and	r24, r24
    66c4:	0c f0       	brlt	.+2      	; 0x66c8 <portExCS+0x104>
    66c6:	10 e0       	ldi	r17, 0x00	; 0
    66c8:	11 23       	and	r17, r17
    66ca:	29 f0       	breq	.+10     	; 0x66d6 <portExCS+0x112>
		__ticks = 1;
    66cc:	81 e0       	ldi	r24, 0x01	; 1
    66ce:	90 e0       	ldi	r25, 0x00	; 0
    66d0:	8a 8b       	std	Y+18, r24	; 0x12
    66d2:	9b 8b       	std	Y+19, r25	; 0x13
    66d4:	46 c0       	rjmp	.+140    	; 0x6762 <portExCS+0x19e>
	else if (__tmp > 65535)
    66d6:	11 e0       	ldi	r17, 0x01	; 1
    66d8:	6e 85       	ldd	r22, Y+14	; 0x0e
    66da:	7f 85       	ldd	r23, Y+15	; 0x0f
    66dc:	88 89       	ldd	r24, Y+16	; 0x10
    66de:	99 89       	ldd	r25, Y+17	; 0x11
    66e0:	20 e0       	ldi	r18, 0x00	; 0
    66e2:	3f ef       	ldi	r19, 0xFF	; 255
    66e4:	4f e7       	ldi	r20, 0x7F	; 127
    66e6:	57 e4       	ldi	r21, 0x47	; 71
    66e8:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    66ec:	18 16       	cp	r1, r24
    66ee:	0c f0       	brlt	.+2      	; 0x66f2 <portExCS+0x12e>
    66f0:	10 e0       	ldi	r17, 0x00	; 0
    66f2:	11 23       	and	r17, r17
    66f4:	61 f1       	breq	.+88     	; 0x674e <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    66f6:	6a 85       	ldd	r22, Y+10	; 0x0a
    66f8:	7b 85       	ldd	r23, Y+11	; 0x0b
    66fa:	8c 85       	ldd	r24, Y+12	; 0x0c
    66fc:	9d 85       	ldd	r25, Y+13	; 0x0d
    66fe:	20 e0       	ldi	r18, 0x00	; 0
    6700:	30 e0       	ldi	r19, 0x00	; 0
    6702:	40 e2       	ldi	r20, 0x20	; 32
    6704:	51 e4       	ldi	r21, 0x41	; 65
    6706:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    670a:	dc 01       	movw	r26, r24
    670c:	cb 01       	movw	r24, r22
    670e:	bc 01       	movw	r22, r24
    6710:	cd 01       	movw	r24, r26
    6712:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6716:	dc 01       	movw	r26, r24
    6718:	cb 01       	movw	r24, r22
    671a:	8a 8b       	std	Y+18, r24	; 0x12
    671c:	9b 8b       	std	Y+19, r25	; 0x13
    671e:	12 c0       	rjmp	.+36     	; 0x6744 <portExCS+0x180>
    6720:	80 e2       	ldi	r24, 0x20	; 32
    6722:	93 e0       	ldi	r25, 0x03	; 3
    6724:	8c 8b       	std	Y+20, r24	; 0x14
    6726:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6728:	8c 89       	ldd	r24, Y+20	; 0x14
    672a:	9d 89       	ldd	r25, Y+21	; 0x15
    672c:	8c 01       	movw	r16, r24
    672e:	c8 01       	movw	r24, r16
    6730:	01 97       	sbiw	r24, 0x01	; 1
    6732:	f1 f7       	brne	.-4      	; 0x6730 <portExCS+0x16c>
    6734:	8c 01       	movw	r16, r24
    6736:	0c 8b       	std	Y+20, r16	; 0x14
    6738:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    673a:	8a 89       	ldd	r24, Y+18	; 0x12
    673c:	9b 89       	ldd	r25, Y+19	; 0x13
    673e:	01 97       	sbiw	r24, 0x01	; 1
    6740:	8a 8b       	std	Y+18, r24	; 0x12
    6742:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6744:	8a 89       	ldd	r24, Y+18	; 0x12
    6746:	9b 89       	ldd	r25, Y+19	; 0x13
    6748:	00 97       	sbiw	r24, 0x00	; 0
    674a:	51 f7       	brne	.-44     	; 0x6720 <portExCS+0x15c>
    674c:	28 c0       	rjmp	.+80     	; 0x679e <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    674e:	6e 85       	ldd	r22, Y+14	; 0x0e
    6750:	7f 85       	ldd	r23, Y+15	; 0x0f
    6752:	88 89       	ldd	r24, Y+16	; 0x10
    6754:	99 89       	ldd	r25, Y+17	; 0x11
    6756:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    675a:	dc 01       	movw	r26, r24
    675c:	cb 01       	movw	r24, r22
    675e:	8a 8b       	std	Y+18, r24	; 0x12
    6760:	9b 8b       	std	Y+19, r25	; 0x13
    6762:	8a 89       	ldd	r24, Y+18	; 0x12
    6764:	9b 89       	ldd	r25, Y+19	; 0x13
    6766:	8e 8b       	std	Y+22, r24	; 0x16
    6768:	9f 8b       	std	Y+23, r25	; 0x17
    676a:	8e 89       	ldd	r24, Y+22	; 0x16
    676c:	9f 89       	ldd	r25, Y+23	; 0x17
    676e:	8c 01       	movw	r16, r24
    6770:	f8 01       	movw	r30, r16
    6772:	31 97       	sbiw	r30, 0x01	; 1
    6774:	f1 f7       	brne	.-4      	; 0x6772 <portExCS+0x1ae>
    6776:	8f 01       	movw	r16, r30
    6778:	0e 8b       	std	Y+22, r16	; 0x16
    677a:	1f 8b       	std	Y+23, r17	; 0x17
    677c:	10 c0       	rjmp	.+32     	; 0x679e <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    677e:	6d 81       	ldd	r22, Y+5	; 0x05
    6780:	7e 81       	ldd	r23, Y+6	; 0x06
    6782:	8f 81       	ldd	r24, Y+7	; 0x07
    6784:	98 85       	ldd	r25, Y+8	; 0x08
    6786:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    678a:	dc 01       	movw	r26, r24
    678c:	cb 01       	movw	r24, r22
    678e:	89 87       	std	Y+9, r24	; 0x09
    6790:	89 85       	ldd	r24, Y+9	; 0x09
    6792:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6794:	88 8d       	ldd	r24, Y+24	; 0x18
    6796:	18 2f       	mov	r17, r24
    6798:	1a 95       	dec	r17
    679a:	f1 f7       	brne	.-4      	; 0x6798 <portExCS+0x1d4>
    679c:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    679e:	69 96       	adiw	r28, 0x19	; 25
    67a0:	cd bf       	out	0x3d, r28	; 61
    67a2:	de bf       	out	0x3e, r29	; 62
    67a4:	df 91       	pop	r29
    67a6:	cf 91       	pop	r28
    67a8:	1f 91       	pop	r17
    67aa:	0f 91       	pop	r16
    67ac:	08 95       	ret

000067ae <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    67ae:	cf 93       	push	r28
    67b0:	df 93       	push	r29
    67b2:	00 d0       	rcall	.+0      	; 0x67b4 <PortEx_DIRSET+0x6>
    67b4:	cd b7       	in	r28, 0x3d	; 61
    67b6:	de b7       	in	r29, 0x3e	; 62
    67b8:	8a 83       	std	Y+2, r24	; 0x02
    67ba:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    67bc:	80 e0       	ldi	r24, 0x00	; 0
    67be:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    67c2:	81 e0       	ldi	r24, 0x01	; 1
    67c4:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	portExCS(TRUE);
    67c8:	81 e0       	ldi	r24, 0x01	; 1
    67ca:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    67ce:	8b 81       	ldd	r24, Y+3	; 0x03
    67d0:	88 23       	and	r24, r24
    67d2:	39 f0       	breq	.+14     	; 0x67e2 <PortEx_DIRSET+0x34>
    67d4:	90 91 6b 50 	lds	r25, 0x506B
    67d8:	8a 81       	ldd	r24, Y+2	; 0x02
    67da:	89 2b       	or	r24, r25
    67dc:	80 93 6b 50 	sts	0x506B, r24
    67e0:	06 c0       	rjmp	.+12     	; 0x67ee <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    67e2:	90 91 c6 50 	lds	r25, 0x50C6
    67e6:	8a 81       	ldd	r24, Y+2	; 0x02
    67e8:	89 2b       	or	r24, r25
    67ea:	80 93 c6 50 	sts	0x50C6, r24
	
	SPIBuffer[0] = PS_WRITE;
    67ee:	80 e4       	ldi	r24, 0x40	; 64
    67f0:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    67f4:	8b 81       	ldd	r24, Y+3	; 0x03
    67f6:	88 23       	and	r24, r24
    67f8:	41 f0       	breq	.+16     	; 0x680a <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    67fa:	10 92 57 50 	sts	0x5057, r1
		SPIBuffer[2] = ~bankA_DIR; 
    67fe:	80 91 6b 50 	lds	r24, 0x506B
    6802:	80 95       	com	r24
    6804:	80 93 58 50 	sts	0x5058, r24
    6808:	08 c0       	rjmp	.+16     	; 0x681a <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    680a:	81 e0       	ldi	r24, 0x01	; 1
    680c:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = ~bankB_DIR;
    6810:	80 91 c6 50 	lds	r24, 0x50C6
    6814:	80 95       	com	r24
    6816:	80 93 58 50 	sts	0x5058, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    681a:	19 82       	std	Y+1, r1	; 0x01
    681c:	1b c0       	rjmp	.+54     	; 0x6854 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    681e:	80 ec       	ldi	r24, 0xC0	; 192
    6820:	98 e0       	ldi	r25, 0x08	; 8
    6822:	29 81       	ldd	r18, Y+1	; 0x01
    6824:	22 2f       	mov	r18, r18
    6826:	30 e0       	ldi	r19, 0x00	; 0
    6828:	2a 5a       	subi	r18, 0xAA	; 170
    682a:	3f 4a       	sbci	r19, 0xAF	; 175
    682c:	f9 01       	movw	r30, r18
    682e:	20 81       	ld	r18, Z
    6830:	fc 01       	movw	r30, r24
    6832:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6834:	00 00       	nop
    6836:	80 ec       	ldi	r24, 0xC0	; 192
    6838:	98 e0       	ldi	r25, 0x08	; 8
    683a:	fc 01       	movw	r30, r24
    683c:	82 81       	ldd	r24, Z+2	; 0x02
    683e:	88 23       	and	r24, r24
    6840:	d4 f7       	brge	.-12     	; 0x6836 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6842:	80 ec       	ldi	r24, 0xC0	; 192
    6844:	98 e0       	ldi	r25, 0x08	; 8
    6846:	fc 01       	movw	r30, r24
    6848:	83 81       	ldd	r24, Z+3	; 0x03
    684a:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    684e:	89 81       	ldd	r24, Y+1	; 0x01
    6850:	8f 5f       	subi	r24, 0xFF	; 255
    6852:	89 83       	std	Y+1, r24	; 0x01
    6854:	89 81       	ldd	r24, Y+1	; 0x01
    6856:	83 30       	cpi	r24, 0x03	; 3
    6858:	10 f3       	brcs	.-60     	; 0x681e <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    685a:	80 e0       	ldi	r24, 0x00	; 0
    685c:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>
	SPICS(FALSE);
    6860:	80 e0       	ldi	r24, 0x00	; 0
    6862:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    6866:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>


}
    686a:	23 96       	adiw	r28, 0x03	; 3
    686c:	cd bf       	out	0x3d, r28	; 61
    686e:	de bf       	out	0x3e, r29	; 62
    6870:	df 91       	pop	r29
    6872:	cf 91       	pop	r28
    6874:	08 95       	ret

00006876 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6876:	cf 93       	push	r28
    6878:	df 93       	push	r29
    687a:	00 d0       	rcall	.+0      	; 0x687c <PortEx_DIRCLR+0x6>
    687c:	cd b7       	in	r28, 0x3d	; 61
    687e:	de b7       	in	r29, 0x3e	; 62
    6880:	8a 83       	std	Y+2, r24	; 0x02
    6882:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    6884:	80 e0       	ldi	r24, 0x00	; 0
    6886:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    688a:	81 e0       	ldi	r24, 0x01	; 1
    688c:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	portExCS(TRUE);
    6890:	81 e0       	ldi	r24, 0x01	; 1
    6892:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6896:	8b 81       	ldd	r24, Y+3	; 0x03
    6898:	88 23       	and	r24, r24
    689a:	49 f0       	breq	.+18     	; 0x68ae <PortEx_DIRCLR+0x38>
    689c:	80 91 6b 50 	lds	r24, 0x506B
    68a0:	98 2f       	mov	r25, r24
    68a2:	90 95       	com	r25
    68a4:	8a 81       	ldd	r24, Y+2	; 0x02
    68a6:	89 23       	and	r24, r25
    68a8:	80 93 6b 50 	sts	0x506B, r24
    68ac:	08 c0       	rjmp	.+16     	; 0x68be <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    68ae:	80 91 c6 50 	lds	r24, 0x50C6
    68b2:	98 2f       	mov	r25, r24
    68b4:	90 95       	com	r25
    68b6:	8a 81       	ldd	r24, Y+2	; 0x02
    68b8:	89 23       	and	r24, r25
    68ba:	80 93 c6 50 	sts	0x50C6, r24
	
	SPIBuffer[0] = PS_WRITE;
    68be:	80 e4       	ldi	r24, 0x40	; 64
    68c0:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    68c4:	8b 81       	ldd	r24, Y+3	; 0x03
    68c6:	88 23       	and	r24, r24
    68c8:	41 f0       	breq	.+16     	; 0x68da <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    68ca:	10 92 57 50 	sts	0x5057, r1
		SPIBuffer[2] = ~bankA_DIR; 
    68ce:	80 91 6b 50 	lds	r24, 0x506B
    68d2:	80 95       	com	r24
    68d4:	80 93 58 50 	sts	0x5058, r24
    68d8:	08 c0       	rjmp	.+16     	; 0x68ea <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    68da:	81 e0       	ldi	r24, 0x01	; 1
    68dc:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = ~bankB_DIR;
    68e0:	80 91 c6 50 	lds	r24, 0x50C6
    68e4:	80 95       	com	r24
    68e6:	80 93 58 50 	sts	0x5058, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    68ea:	19 82       	std	Y+1, r1	; 0x01
    68ec:	1b c0       	rjmp	.+54     	; 0x6924 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    68ee:	80 ec       	ldi	r24, 0xC0	; 192
    68f0:	98 e0       	ldi	r25, 0x08	; 8
    68f2:	29 81       	ldd	r18, Y+1	; 0x01
    68f4:	22 2f       	mov	r18, r18
    68f6:	30 e0       	ldi	r19, 0x00	; 0
    68f8:	2a 5a       	subi	r18, 0xAA	; 170
    68fa:	3f 4a       	sbci	r19, 0xAF	; 175
    68fc:	f9 01       	movw	r30, r18
    68fe:	20 81       	ld	r18, Z
    6900:	fc 01       	movw	r30, r24
    6902:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6904:	00 00       	nop
    6906:	80 ec       	ldi	r24, 0xC0	; 192
    6908:	98 e0       	ldi	r25, 0x08	; 8
    690a:	fc 01       	movw	r30, r24
    690c:	82 81       	ldd	r24, Z+2	; 0x02
    690e:	88 23       	and	r24, r24
    6910:	d4 f7       	brge	.-12     	; 0x6906 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6912:	80 ec       	ldi	r24, 0xC0	; 192
    6914:	98 e0       	ldi	r25, 0x08	; 8
    6916:	fc 01       	movw	r30, r24
    6918:	83 81       	ldd	r24, Z+3	; 0x03
    691a:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    691e:	89 81       	ldd	r24, Y+1	; 0x01
    6920:	8f 5f       	subi	r24, 0xFF	; 255
    6922:	89 83       	std	Y+1, r24	; 0x01
    6924:	89 81       	ldd	r24, Y+1	; 0x01
    6926:	83 30       	cpi	r24, 0x03	; 3
    6928:	10 f3       	brcs	.-60     	; 0x68ee <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    692a:	80 e0       	ldi	r24, 0x00	; 0
    692c:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	portExCS(FALSE);
    6930:	80 e0       	ldi	r24, 0x00	; 0
    6932:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>
	SPIDisable();
    6936:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
}
    693a:	23 96       	adiw	r28, 0x03	; 3
    693c:	cd bf       	out	0x3d, r28	; 61
    693e:	de bf       	out	0x3e, r29	; 62
    6940:	df 91       	pop	r29
    6942:	cf 91       	pop	r28
    6944:	08 95       	ret

00006946 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6946:	cf 93       	push	r28
    6948:	df 93       	push	r29
    694a:	00 d0       	rcall	.+0      	; 0x694c <PortEx_OUTSET+0x6>
    694c:	cd b7       	in	r28, 0x3d	; 61
    694e:	de b7       	in	r29, 0x3e	; 62
    6950:	8a 83       	std	Y+2, r24	; 0x02
    6952:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    6954:	80 e0       	ldi	r24, 0x00	; 0
    6956:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    695a:	81 e0       	ldi	r24, 0x01	; 1
    695c:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	portExCS(TRUE);
    6960:	81 e0       	ldi	r24, 0x01	; 1
    6962:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6966:	8b 81       	ldd	r24, Y+3	; 0x03
    6968:	88 23       	and	r24, r24
    696a:	39 f0       	breq	.+14     	; 0x697a <PortEx_OUTSET+0x34>
    696c:	90 91 c7 23 	lds	r25, 0x23C7
    6970:	8a 81       	ldd	r24, Y+2	; 0x02
    6972:	89 2b       	or	r24, r25
    6974:	80 93 c7 23 	sts	0x23C7, r24
    6978:	06 c0       	rjmp	.+12     	; 0x6986 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    697a:	90 91 73 50 	lds	r25, 0x5073
    697e:	8a 81       	ldd	r24, Y+2	; 0x02
    6980:	89 2b       	or	r24, r25
    6982:	80 93 73 50 	sts	0x5073, r24
	
	SPIBuffer[0] = PS_WRITE;
    6986:	80 e4       	ldi	r24, 0x40	; 64
    6988:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    698c:	8b 81       	ldd	r24, Y+3	; 0x03
    698e:	88 23       	and	r24, r24
    6990:	41 f0       	breq	.+16     	; 0x69a2 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6992:	84 e1       	ldi	r24, 0x14	; 20
    6994:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankA_OUT;
    6998:	80 91 c7 23 	lds	r24, 0x23C7
    699c:	80 93 58 50 	sts	0x5058, r24
    69a0:	07 c0       	rjmp	.+14     	; 0x69b0 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    69a2:	85 e1       	ldi	r24, 0x15	; 21
    69a4:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankB_OUT; 
    69a8:	80 91 73 50 	lds	r24, 0x5073
    69ac:	80 93 58 50 	sts	0x5058, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    69b0:	19 82       	std	Y+1, r1	; 0x01
    69b2:	1b c0       	rjmp	.+54     	; 0x69ea <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    69b4:	80 ec       	ldi	r24, 0xC0	; 192
    69b6:	98 e0       	ldi	r25, 0x08	; 8
    69b8:	29 81       	ldd	r18, Y+1	; 0x01
    69ba:	22 2f       	mov	r18, r18
    69bc:	30 e0       	ldi	r19, 0x00	; 0
    69be:	2a 5a       	subi	r18, 0xAA	; 170
    69c0:	3f 4a       	sbci	r19, 0xAF	; 175
    69c2:	f9 01       	movw	r30, r18
    69c4:	20 81       	ld	r18, Z
    69c6:	fc 01       	movw	r30, r24
    69c8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    69ca:	00 00       	nop
    69cc:	80 ec       	ldi	r24, 0xC0	; 192
    69ce:	98 e0       	ldi	r25, 0x08	; 8
    69d0:	fc 01       	movw	r30, r24
    69d2:	82 81       	ldd	r24, Z+2	; 0x02
    69d4:	88 23       	and	r24, r24
    69d6:	d4 f7       	brge	.-12     	; 0x69cc <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    69d8:	80 ec       	ldi	r24, 0xC0	; 192
    69da:	98 e0       	ldi	r25, 0x08	; 8
    69dc:	fc 01       	movw	r30, r24
    69de:	83 81       	ldd	r24, Z+3	; 0x03
    69e0:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    69e4:	89 81       	ldd	r24, Y+1	; 0x01
    69e6:	8f 5f       	subi	r24, 0xFF	; 255
    69e8:	89 83       	std	Y+1, r24	; 0x01
    69ea:	89 81       	ldd	r24, Y+1	; 0x01
    69ec:	83 30       	cpi	r24, 0x03	; 3
    69ee:	10 f3       	brcs	.-60     	; 0x69b4 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    69f0:	80 e0       	ldi	r24, 0x00	; 0
    69f2:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	portExCS(FALSE);
    69f6:	80 e0       	ldi	r24, 0x00	; 0
    69f8:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>
	SPIDisable();
    69fc:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
}
    6a00:	23 96       	adiw	r28, 0x03	; 3
    6a02:	cd bf       	out	0x3d, r28	; 61
    6a04:	de bf       	out	0x3e, r29	; 62
    6a06:	df 91       	pop	r29
    6a08:	cf 91       	pop	r28
    6a0a:	08 95       	ret

00006a0c <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    6a0c:	cf 93       	push	r28
    6a0e:	df 93       	push	r29
    6a10:	00 d0       	rcall	.+0      	; 0x6a12 <PortEx_OUTCLR+0x6>
    6a12:	cd b7       	in	r28, 0x3d	; 61
    6a14:	de b7       	in	r29, 0x3e	; 62
    6a16:	8a 83       	std	Y+2, r24	; 0x02
    6a18:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    6a1a:	80 e0       	ldi	r24, 0x00	; 0
    6a1c:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    6a20:	81 e0       	ldi	r24, 0x01	; 1
    6a22:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	portExCS(TRUE);
    6a26:	81 e0       	ldi	r24, 0x01	; 1
    6a28:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    6a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    6a2e:	88 23       	and	r24, r24
    6a30:	49 f0       	breq	.+18     	; 0x6a44 <PortEx_OUTCLR+0x38>
    6a32:	8a 81       	ldd	r24, Y+2	; 0x02
    6a34:	98 2f       	mov	r25, r24
    6a36:	90 95       	com	r25
    6a38:	80 91 c7 23 	lds	r24, 0x23C7
    6a3c:	89 23       	and	r24, r25
    6a3e:	80 93 c7 23 	sts	0x23C7, r24
    6a42:	08 c0       	rjmp	.+16     	; 0x6a54 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6a44:	8a 81       	ldd	r24, Y+2	; 0x02
    6a46:	98 2f       	mov	r25, r24
    6a48:	90 95       	com	r25
    6a4a:	80 91 73 50 	lds	r24, 0x5073
    6a4e:	89 23       	and	r24, r25
    6a50:	80 93 73 50 	sts	0x5073, r24
	
	SPIBuffer[0] = PS_WRITE;
    6a54:	80 e4       	ldi	r24, 0x40	; 64
    6a56:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    6a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a5c:	88 23       	and	r24, r24
    6a5e:	41 f0       	breq	.+16     	; 0x6a70 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6a60:	84 e1       	ldi	r24, 0x14	; 20
    6a62:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankA_OUT;
    6a66:	80 91 c7 23 	lds	r24, 0x23C7
    6a6a:	80 93 58 50 	sts	0x5058, r24
    6a6e:	07 c0       	rjmp	.+14     	; 0x6a7e <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6a70:	85 e1       	ldi	r24, 0x15	; 21
    6a72:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankB_OUT; 
    6a76:	80 91 73 50 	lds	r24, 0x5073
    6a7a:	80 93 58 50 	sts	0x5058, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6a7e:	19 82       	std	Y+1, r1	; 0x01
    6a80:	1b c0       	rjmp	.+54     	; 0x6ab8 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6a82:	80 ec       	ldi	r24, 0xC0	; 192
    6a84:	98 e0       	ldi	r25, 0x08	; 8
    6a86:	29 81       	ldd	r18, Y+1	; 0x01
    6a88:	22 2f       	mov	r18, r18
    6a8a:	30 e0       	ldi	r19, 0x00	; 0
    6a8c:	2a 5a       	subi	r18, 0xAA	; 170
    6a8e:	3f 4a       	sbci	r19, 0xAF	; 175
    6a90:	f9 01       	movw	r30, r18
    6a92:	20 81       	ld	r18, Z
    6a94:	fc 01       	movw	r30, r24
    6a96:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6a98:	00 00       	nop
    6a9a:	80 ec       	ldi	r24, 0xC0	; 192
    6a9c:	98 e0       	ldi	r25, 0x08	; 8
    6a9e:	fc 01       	movw	r30, r24
    6aa0:	82 81       	ldd	r24, Z+2	; 0x02
    6aa2:	88 23       	and	r24, r24
    6aa4:	d4 f7       	brge	.-12     	; 0x6a9a <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6aa6:	80 ec       	ldi	r24, 0xC0	; 192
    6aa8:	98 e0       	ldi	r25, 0x08	; 8
    6aaa:	fc 01       	movw	r30, r24
    6aac:	83 81       	ldd	r24, Z+3	; 0x03
    6aae:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6ab2:	89 81       	ldd	r24, Y+1	; 0x01
    6ab4:	8f 5f       	subi	r24, 0xFF	; 255
    6ab6:	89 83       	std	Y+1, r24	; 0x01
    6ab8:	89 81       	ldd	r24, Y+1	; 0x01
    6aba:	83 30       	cpi	r24, 0x03	; 3
    6abc:	10 f3       	brcs	.-60     	; 0x6a82 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6abe:	80 e0       	ldi	r24, 0x00	; 0
    6ac0:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	portExCS(FALSE);
    6ac4:	80 e0       	ldi	r24, 0x00	; 0
    6ac6:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <portExCS>
	SPIDisable();
    6aca:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
}
    6ace:	23 96       	adiw	r28, 0x03	; 3
    6ad0:	cd bf       	out	0x3d, r28	; 61
    6ad2:	de bf       	out	0x3e, r29	; 62
    6ad4:	df 91       	pop	r29
    6ad6:	cf 91       	pop	r28
    6ad8:	08 95       	ret

00006ada <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6ada:	0f 93       	push	r16
    6adc:	1f 93       	push	r17
    6ade:	cf 93       	push	r28
    6ae0:	df 93       	push	r29
    6ae2:	cd b7       	in	r28, 0x3d	; 61
    6ae4:	de b7       	in	r29, 0x3e	; 62
    6ae6:	2f 97       	sbiw	r28, 0x0f	; 15
    6ae8:	cd bf       	out	0x3d, r28	; 61
    6aea:	de bf       	out	0x3e, r29	; 62
    6aec:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
    6aee:	8f 85       	ldd	r24, Y+15	; 0x0f
    6af0:	88 23       	and	r24, r24
    6af2:	09 f4       	brne	.+2      	; 0x6af6 <Ext1Power+0x1c>
    6af4:	8b c0       	rjmp	.+278    	; 0x6c0c <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6af6:	80 ea       	ldi	r24, 0xA0	; 160
    6af8:	96 e0       	ldi	r25, 0x06	; 6
    6afa:	20 e2       	ldi	r18, 0x20	; 32
    6afc:	fc 01       	movw	r30, r24
    6afe:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6b00:	80 ea       	ldi	r24, 0xA0	; 160
    6b02:	96 e0       	ldi	r25, 0x06	; 6
    6b04:	20 e2       	ldi	r18, 0x20	; 32
    6b06:	fc 01       	movw	r30, r24
    6b08:	25 83       	std	Z+5, r18	; 0x05
    6b0a:	80 e0       	ldi	r24, 0x00	; 0
    6b0c:	90 e0       	ldi	r25, 0x00	; 0
    6b0e:	a8 ec       	ldi	r26, 0xC8	; 200
    6b10:	b2 e4       	ldi	r27, 0x42	; 66
    6b12:	89 83       	std	Y+1, r24	; 0x01
    6b14:	9a 83       	std	Y+2, r25	; 0x02
    6b16:	ab 83       	std	Y+3, r26	; 0x03
    6b18:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6b1a:	69 81       	ldd	r22, Y+1	; 0x01
    6b1c:	7a 81       	ldd	r23, Y+2	; 0x02
    6b1e:	8b 81       	ldd	r24, Y+3	; 0x03
    6b20:	9c 81       	ldd	r25, Y+4	; 0x04
    6b22:	20 e0       	ldi	r18, 0x00	; 0
    6b24:	30 e0       	ldi	r19, 0x00	; 0
    6b26:	4a ef       	ldi	r20, 0xFA	; 250
    6b28:	55 e4       	ldi	r21, 0x45	; 69
    6b2a:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6b2e:	dc 01       	movw	r26, r24
    6b30:	cb 01       	movw	r24, r22
    6b32:	8d 83       	std	Y+5, r24	; 0x05
    6b34:	9e 83       	std	Y+6, r25	; 0x06
    6b36:	af 83       	std	Y+7, r26	; 0x07
    6b38:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6b3a:	11 e0       	ldi	r17, 0x01	; 1
    6b3c:	6d 81       	ldd	r22, Y+5	; 0x05
    6b3e:	7e 81       	ldd	r23, Y+6	; 0x06
    6b40:	8f 81       	ldd	r24, Y+7	; 0x07
    6b42:	98 85       	ldd	r25, Y+8	; 0x08
    6b44:	20 e0       	ldi	r18, 0x00	; 0
    6b46:	30 e0       	ldi	r19, 0x00	; 0
    6b48:	40 e8       	ldi	r20, 0x80	; 128
    6b4a:	5f e3       	ldi	r21, 0x3F	; 63
    6b4c:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    6b50:	88 23       	and	r24, r24
    6b52:	0c f0       	brlt	.+2      	; 0x6b56 <Ext1Power+0x7c>
    6b54:	10 e0       	ldi	r17, 0x00	; 0
    6b56:	11 23       	and	r17, r17
    6b58:	29 f0       	breq	.+10     	; 0x6b64 <Ext1Power+0x8a>
		__ticks = 1;
    6b5a:	81 e0       	ldi	r24, 0x01	; 1
    6b5c:	90 e0       	ldi	r25, 0x00	; 0
    6b5e:	89 87       	std	Y+9, r24	; 0x09
    6b60:	9a 87       	std	Y+10, r25	; 0x0a
    6b62:	46 c0       	rjmp	.+140    	; 0x6bf0 <Ext1Power+0x116>
	else if (__tmp > 65535)
    6b64:	11 e0       	ldi	r17, 0x01	; 1
    6b66:	6d 81       	ldd	r22, Y+5	; 0x05
    6b68:	7e 81       	ldd	r23, Y+6	; 0x06
    6b6a:	8f 81       	ldd	r24, Y+7	; 0x07
    6b6c:	98 85       	ldd	r25, Y+8	; 0x08
    6b6e:	20 e0       	ldi	r18, 0x00	; 0
    6b70:	3f ef       	ldi	r19, 0xFF	; 255
    6b72:	4f e7       	ldi	r20, 0x7F	; 127
    6b74:	57 e4       	ldi	r21, 0x47	; 71
    6b76:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    6b7a:	18 16       	cp	r1, r24
    6b7c:	0c f0       	brlt	.+2      	; 0x6b80 <Ext1Power+0xa6>
    6b7e:	10 e0       	ldi	r17, 0x00	; 0
    6b80:	11 23       	and	r17, r17
    6b82:	61 f1       	breq	.+88     	; 0x6bdc <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6b84:	69 81       	ldd	r22, Y+1	; 0x01
    6b86:	7a 81       	ldd	r23, Y+2	; 0x02
    6b88:	8b 81       	ldd	r24, Y+3	; 0x03
    6b8a:	9c 81       	ldd	r25, Y+4	; 0x04
    6b8c:	20 e0       	ldi	r18, 0x00	; 0
    6b8e:	30 e0       	ldi	r19, 0x00	; 0
    6b90:	40 e2       	ldi	r20, 0x20	; 32
    6b92:	51 e4       	ldi	r21, 0x41	; 65
    6b94:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6b98:	dc 01       	movw	r26, r24
    6b9a:	cb 01       	movw	r24, r22
    6b9c:	bc 01       	movw	r22, r24
    6b9e:	cd 01       	movw	r24, r26
    6ba0:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6ba4:	dc 01       	movw	r26, r24
    6ba6:	cb 01       	movw	r24, r22
    6ba8:	89 87       	std	Y+9, r24	; 0x09
    6baa:	9a 87       	std	Y+10, r25	; 0x0a
    6bac:	12 c0       	rjmp	.+36     	; 0x6bd2 <Ext1Power+0xf8>
    6bae:	80 e2       	ldi	r24, 0x20	; 32
    6bb0:	93 e0       	ldi	r25, 0x03	; 3
    6bb2:	8b 87       	std	Y+11, r24	; 0x0b
    6bb4:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6bb6:	8b 85       	ldd	r24, Y+11	; 0x0b
    6bb8:	9c 85       	ldd	r25, Y+12	; 0x0c
    6bba:	8c 01       	movw	r16, r24
    6bbc:	c8 01       	movw	r24, r16
    6bbe:	01 97       	sbiw	r24, 0x01	; 1
    6bc0:	f1 f7       	brne	.-4      	; 0x6bbe <Ext1Power+0xe4>
    6bc2:	8c 01       	movw	r16, r24
    6bc4:	0b 87       	std	Y+11, r16	; 0x0b
    6bc6:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6bc8:	89 85       	ldd	r24, Y+9	; 0x09
    6bca:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bcc:	01 97       	sbiw	r24, 0x01	; 1
    6bce:	89 87       	std	Y+9, r24	; 0x09
    6bd0:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6bd2:	89 85       	ldd	r24, Y+9	; 0x09
    6bd4:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bd6:	00 97       	sbiw	r24, 0x00	; 0
    6bd8:	51 f7       	brne	.-44     	; 0x6bae <Ext1Power+0xd4>
    6bda:	22 c0       	rjmp	.+68     	; 0x6c20 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6bdc:	6d 81       	ldd	r22, Y+5	; 0x05
    6bde:	7e 81       	ldd	r23, Y+6	; 0x06
    6be0:	8f 81       	ldd	r24, Y+7	; 0x07
    6be2:	98 85       	ldd	r25, Y+8	; 0x08
    6be4:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6be8:	dc 01       	movw	r26, r24
    6bea:	cb 01       	movw	r24, r22
    6bec:	89 87       	std	Y+9, r24	; 0x09
    6bee:	9a 87       	std	Y+10, r25	; 0x0a
    6bf0:	89 85       	ldd	r24, Y+9	; 0x09
    6bf2:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bf4:	8d 87       	std	Y+13, r24	; 0x0d
    6bf6:	9e 87       	std	Y+14, r25	; 0x0e
    6bf8:	8d 85       	ldd	r24, Y+13	; 0x0d
    6bfa:	9e 85       	ldd	r25, Y+14	; 0x0e
    6bfc:	8c 01       	movw	r16, r24
    6bfe:	f8 01       	movw	r30, r16
    6c00:	31 97       	sbiw	r30, 0x01	; 1
    6c02:	f1 f7       	brne	.-4      	; 0x6c00 <Ext1Power+0x126>
    6c04:	8f 01       	movw	r16, r30
    6c06:	0d 87       	std	Y+13, r16	; 0x0d
    6c08:	1e 87       	std	Y+14, r17	; 0x0e
    6c0a:	0a c0       	rjmp	.+20     	; 0x6c20 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6c0c:	80 ea       	ldi	r24, 0xA0	; 160
    6c0e:	96 e0       	ldi	r25, 0x06	; 6
    6c10:	20 e2       	ldi	r18, 0x20	; 32
    6c12:	fc 01       	movw	r30, r24
    6c14:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6c16:	80 ea       	ldi	r24, 0xA0	; 160
    6c18:	96 e0       	ldi	r25, 0x06	; 6
    6c1a:	20 e2       	ldi	r18, 0x20	; 32
    6c1c:	fc 01       	movw	r30, r24
    6c1e:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6c20:	2f 96       	adiw	r28, 0x0f	; 15
    6c22:	cd bf       	out	0x3d, r28	; 61
    6c24:	de bf       	out	0x3e, r29	; 62
    6c26:	df 91       	pop	r29
    6c28:	cf 91       	pop	r28
    6c2a:	1f 91       	pop	r17
    6c2c:	0f 91       	pop	r16
    6c2e:	08 95       	ret

00006c30 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6c30:	0f 93       	push	r16
    6c32:	1f 93       	push	r17
    6c34:	cf 93       	push	r28
    6c36:	df 93       	push	r29
    6c38:	cd b7       	in	r28, 0x3d	; 61
    6c3a:	de b7       	in	r29, 0x3e	; 62
    6c3c:	2f 97       	sbiw	r28, 0x0f	; 15
    6c3e:	cd bf       	out	0x3d, r28	; 61
    6c40:	de bf       	out	0x3e, r29	; 62
    6c42:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
    6c44:	8f 85       	ldd	r24, Y+15	; 0x0f
    6c46:	88 23       	and	r24, r24
    6c48:	09 f4       	brne	.+2      	; 0x6c4c <Ext2Power+0x1c>
    6c4a:	8b c0       	rjmp	.+278    	; 0x6d62 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6c4c:	80 ea       	ldi	r24, 0xA0	; 160
    6c4e:	96 e0       	ldi	r25, 0x06	; 6
    6c50:	20 e4       	ldi	r18, 0x40	; 64
    6c52:	fc 01       	movw	r30, r24
    6c54:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6c56:	80 ea       	ldi	r24, 0xA0	; 160
    6c58:	96 e0       	ldi	r25, 0x06	; 6
    6c5a:	20 e4       	ldi	r18, 0x40	; 64
    6c5c:	fc 01       	movw	r30, r24
    6c5e:	25 83       	std	Z+5, r18	; 0x05
    6c60:	80 e0       	ldi	r24, 0x00	; 0
    6c62:	90 e0       	ldi	r25, 0x00	; 0
    6c64:	a8 ec       	ldi	r26, 0xC8	; 200
    6c66:	b2 e4       	ldi	r27, 0x42	; 66
    6c68:	89 83       	std	Y+1, r24	; 0x01
    6c6a:	9a 83       	std	Y+2, r25	; 0x02
    6c6c:	ab 83       	std	Y+3, r26	; 0x03
    6c6e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6c70:	69 81       	ldd	r22, Y+1	; 0x01
    6c72:	7a 81       	ldd	r23, Y+2	; 0x02
    6c74:	8b 81       	ldd	r24, Y+3	; 0x03
    6c76:	9c 81       	ldd	r25, Y+4	; 0x04
    6c78:	20 e0       	ldi	r18, 0x00	; 0
    6c7a:	30 e0       	ldi	r19, 0x00	; 0
    6c7c:	4a ef       	ldi	r20, 0xFA	; 250
    6c7e:	55 e4       	ldi	r21, 0x45	; 69
    6c80:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6c84:	dc 01       	movw	r26, r24
    6c86:	cb 01       	movw	r24, r22
    6c88:	8d 83       	std	Y+5, r24	; 0x05
    6c8a:	9e 83       	std	Y+6, r25	; 0x06
    6c8c:	af 83       	std	Y+7, r26	; 0x07
    6c8e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6c90:	11 e0       	ldi	r17, 0x01	; 1
    6c92:	6d 81       	ldd	r22, Y+5	; 0x05
    6c94:	7e 81       	ldd	r23, Y+6	; 0x06
    6c96:	8f 81       	ldd	r24, Y+7	; 0x07
    6c98:	98 85       	ldd	r25, Y+8	; 0x08
    6c9a:	20 e0       	ldi	r18, 0x00	; 0
    6c9c:	30 e0       	ldi	r19, 0x00	; 0
    6c9e:	40 e8       	ldi	r20, 0x80	; 128
    6ca0:	5f e3       	ldi	r21, 0x3F	; 63
    6ca2:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    6ca6:	88 23       	and	r24, r24
    6ca8:	0c f0       	brlt	.+2      	; 0x6cac <Ext2Power+0x7c>
    6caa:	10 e0       	ldi	r17, 0x00	; 0
    6cac:	11 23       	and	r17, r17
    6cae:	29 f0       	breq	.+10     	; 0x6cba <Ext2Power+0x8a>
		__ticks = 1;
    6cb0:	81 e0       	ldi	r24, 0x01	; 1
    6cb2:	90 e0       	ldi	r25, 0x00	; 0
    6cb4:	89 87       	std	Y+9, r24	; 0x09
    6cb6:	9a 87       	std	Y+10, r25	; 0x0a
    6cb8:	46 c0       	rjmp	.+140    	; 0x6d46 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6cba:	11 e0       	ldi	r17, 0x01	; 1
    6cbc:	6d 81       	ldd	r22, Y+5	; 0x05
    6cbe:	7e 81       	ldd	r23, Y+6	; 0x06
    6cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    6cc2:	98 85       	ldd	r25, Y+8	; 0x08
    6cc4:	20 e0       	ldi	r18, 0x00	; 0
    6cc6:	3f ef       	ldi	r19, 0xFF	; 255
    6cc8:	4f e7       	ldi	r20, 0x7F	; 127
    6cca:	57 e4       	ldi	r21, 0x47	; 71
    6ccc:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    6cd0:	18 16       	cp	r1, r24
    6cd2:	0c f0       	brlt	.+2      	; 0x6cd6 <Ext2Power+0xa6>
    6cd4:	10 e0       	ldi	r17, 0x00	; 0
    6cd6:	11 23       	and	r17, r17
    6cd8:	61 f1       	breq	.+88     	; 0x6d32 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6cda:	69 81       	ldd	r22, Y+1	; 0x01
    6cdc:	7a 81       	ldd	r23, Y+2	; 0x02
    6cde:	8b 81       	ldd	r24, Y+3	; 0x03
    6ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    6ce2:	20 e0       	ldi	r18, 0x00	; 0
    6ce4:	30 e0       	ldi	r19, 0x00	; 0
    6ce6:	40 e2       	ldi	r20, 0x20	; 32
    6ce8:	51 e4       	ldi	r21, 0x41	; 65
    6cea:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6cee:	dc 01       	movw	r26, r24
    6cf0:	cb 01       	movw	r24, r22
    6cf2:	bc 01       	movw	r22, r24
    6cf4:	cd 01       	movw	r24, r26
    6cf6:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6cfa:	dc 01       	movw	r26, r24
    6cfc:	cb 01       	movw	r24, r22
    6cfe:	89 87       	std	Y+9, r24	; 0x09
    6d00:	9a 87       	std	Y+10, r25	; 0x0a
    6d02:	12 c0       	rjmp	.+36     	; 0x6d28 <Ext2Power+0xf8>
    6d04:	80 e2       	ldi	r24, 0x20	; 32
    6d06:	93 e0       	ldi	r25, 0x03	; 3
    6d08:	8b 87       	std	Y+11, r24	; 0x0b
    6d0a:	9c 87       	std	Y+12, r25	; 0x0c
    6d0c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6d0e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6d10:	8c 01       	movw	r16, r24
    6d12:	c8 01       	movw	r24, r16
    6d14:	01 97       	sbiw	r24, 0x01	; 1
    6d16:	f1 f7       	brne	.-4      	; 0x6d14 <Ext2Power+0xe4>
    6d18:	8c 01       	movw	r16, r24
    6d1a:	0b 87       	std	Y+11, r16	; 0x0b
    6d1c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d1e:	89 85       	ldd	r24, Y+9	; 0x09
    6d20:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d22:	01 97       	sbiw	r24, 0x01	; 1
    6d24:	89 87       	std	Y+9, r24	; 0x09
    6d26:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d28:	89 85       	ldd	r24, Y+9	; 0x09
    6d2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d2c:	00 97       	sbiw	r24, 0x00	; 0
    6d2e:	51 f7       	brne	.-44     	; 0x6d04 <Ext2Power+0xd4>
    6d30:	22 c0       	rjmp	.+68     	; 0x6d76 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d32:	6d 81       	ldd	r22, Y+5	; 0x05
    6d34:	7e 81       	ldd	r23, Y+6	; 0x06
    6d36:	8f 81       	ldd	r24, Y+7	; 0x07
    6d38:	98 85       	ldd	r25, Y+8	; 0x08
    6d3a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6d3e:	dc 01       	movw	r26, r24
    6d40:	cb 01       	movw	r24, r22
    6d42:	89 87       	std	Y+9, r24	; 0x09
    6d44:	9a 87       	std	Y+10, r25	; 0x0a
    6d46:	89 85       	ldd	r24, Y+9	; 0x09
    6d48:	9a 85       	ldd	r25, Y+10	; 0x0a
    6d4a:	8d 87       	std	Y+13, r24	; 0x0d
    6d4c:	9e 87       	std	Y+14, r25	; 0x0e
    6d4e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6d50:	9e 85       	ldd	r25, Y+14	; 0x0e
    6d52:	8c 01       	movw	r16, r24
    6d54:	f8 01       	movw	r30, r16
    6d56:	31 97       	sbiw	r30, 0x01	; 1
    6d58:	f1 f7       	brne	.-4      	; 0x6d56 <Ext2Power+0x126>
    6d5a:	8f 01       	movw	r16, r30
    6d5c:	0d 87       	std	Y+13, r16	; 0x0d
    6d5e:	1e 87       	std	Y+14, r17	; 0x0e
    6d60:	0a c0       	rjmp	.+20     	; 0x6d76 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6d62:	80 ea       	ldi	r24, 0xA0	; 160
    6d64:	96 e0       	ldi	r25, 0x06	; 6
    6d66:	20 e4       	ldi	r18, 0x40	; 64
    6d68:	fc 01       	movw	r30, r24
    6d6a:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6d6c:	80 ea       	ldi	r24, 0xA0	; 160
    6d6e:	96 e0       	ldi	r25, 0x06	; 6
    6d70:	20 e4       	ldi	r18, 0x40	; 64
    6d72:	fc 01       	movw	r30, r24
    6d74:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6d76:	2f 96       	adiw	r28, 0x0f	; 15
    6d78:	cd bf       	out	0x3d, r28	; 61
    6d7a:	de bf       	out	0x3e, r29	; 62
    6d7c:	df 91       	pop	r29
    6d7e:	cf 91       	pop	r28
    6d80:	1f 91       	pop	r17
    6d82:	0f 91       	pop	r16
    6d84:	08 95       	ret

00006d86 <HVPower>:

void HVPower(uint8_t on) {
    6d86:	0f 93       	push	r16
    6d88:	1f 93       	push	r17
    6d8a:	cf 93       	push	r28
    6d8c:	df 93       	push	r29
    6d8e:	cd b7       	in	r28, 0x3d	; 61
    6d90:	de b7       	in	r29, 0x3e	; 62
    6d92:	a7 97       	sbiw	r28, 0x27	; 39
    6d94:	cd bf       	out	0x3d, r28	; 61
    6d96:	de bf       	out	0x3e, r29	; 62
    6d98:	8f a3       	lds	r24, 0x5f
	
	if (on) {
    6d9a:	8f a1       	lds	r24, 0x4f
    6d9c:	88 23       	and	r24, r24
    6d9e:	09 f4       	brne	.+2      	; 0x6da2 <HVPower+0x1c>
    6da0:	8b c0       	rjmp	.+278    	; 0x6eb8 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6da2:	80 ea       	ldi	r24, 0xA0	; 160
    6da4:	96 e0       	ldi	r25, 0x06	; 6
    6da6:	20 e8       	ldi	r18, 0x80	; 128
    6da8:	fc 01       	movw	r30, r24
    6daa:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6dac:	80 ea       	ldi	r24, 0xA0	; 160
    6dae:	96 e0       	ldi	r25, 0x06	; 6
    6db0:	20 e8       	ldi	r18, 0x80	; 128
    6db2:	fc 01       	movw	r30, r24
    6db4:	25 83       	std	Z+5, r18	; 0x05
    6db6:	80 e0       	ldi	r24, 0x00	; 0
    6db8:	90 e0       	ldi	r25, 0x00	; 0
    6dba:	a8 ec       	ldi	r26, 0xC8	; 200
    6dbc:	b2 e4       	ldi	r27, 0x42	; 66
    6dbe:	89 83       	std	Y+1, r24	; 0x01
    6dc0:	9a 83       	std	Y+2, r25	; 0x02
    6dc2:	ab 83       	std	Y+3, r26	; 0x03
    6dc4:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6dc6:	69 81       	ldd	r22, Y+1	; 0x01
    6dc8:	7a 81       	ldd	r23, Y+2	; 0x02
    6dca:	8b 81       	ldd	r24, Y+3	; 0x03
    6dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    6dce:	20 e0       	ldi	r18, 0x00	; 0
    6dd0:	30 e0       	ldi	r19, 0x00	; 0
    6dd2:	4a ef       	ldi	r20, 0xFA	; 250
    6dd4:	55 e4       	ldi	r21, 0x45	; 69
    6dd6:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6dda:	dc 01       	movw	r26, r24
    6ddc:	cb 01       	movw	r24, r22
    6dde:	8d 83       	std	Y+5, r24	; 0x05
    6de0:	9e 83       	std	Y+6, r25	; 0x06
    6de2:	af 83       	std	Y+7, r26	; 0x07
    6de4:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6de6:	11 e0       	ldi	r17, 0x01	; 1
    6de8:	6d 81       	ldd	r22, Y+5	; 0x05
    6dea:	7e 81       	ldd	r23, Y+6	; 0x06
    6dec:	8f 81       	ldd	r24, Y+7	; 0x07
    6dee:	98 85       	ldd	r25, Y+8	; 0x08
    6df0:	20 e0       	ldi	r18, 0x00	; 0
    6df2:	30 e0       	ldi	r19, 0x00	; 0
    6df4:	40 e8       	ldi	r20, 0x80	; 128
    6df6:	5f e3       	ldi	r21, 0x3F	; 63
    6df8:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    6dfc:	88 23       	and	r24, r24
    6dfe:	0c f0       	brlt	.+2      	; 0x6e02 <HVPower+0x7c>
    6e00:	10 e0       	ldi	r17, 0x00	; 0
    6e02:	11 23       	and	r17, r17
    6e04:	29 f0       	breq	.+10     	; 0x6e10 <HVPower+0x8a>
		__ticks = 1;
    6e06:	81 e0       	ldi	r24, 0x01	; 1
    6e08:	90 e0       	ldi	r25, 0x00	; 0
    6e0a:	89 87       	std	Y+9, r24	; 0x09
    6e0c:	9a 87       	std	Y+10, r25	; 0x0a
    6e0e:	46 c0       	rjmp	.+140    	; 0x6e9c <HVPower+0x116>
	else if (__tmp > 65535)
    6e10:	11 e0       	ldi	r17, 0x01	; 1
    6e12:	6d 81       	ldd	r22, Y+5	; 0x05
    6e14:	7e 81       	ldd	r23, Y+6	; 0x06
    6e16:	8f 81       	ldd	r24, Y+7	; 0x07
    6e18:	98 85       	ldd	r25, Y+8	; 0x08
    6e1a:	20 e0       	ldi	r18, 0x00	; 0
    6e1c:	3f ef       	ldi	r19, 0xFF	; 255
    6e1e:	4f e7       	ldi	r20, 0x7F	; 127
    6e20:	57 e4       	ldi	r21, 0x47	; 71
    6e22:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    6e26:	18 16       	cp	r1, r24
    6e28:	0c f0       	brlt	.+2      	; 0x6e2c <HVPower+0xa6>
    6e2a:	10 e0       	ldi	r17, 0x00	; 0
    6e2c:	11 23       	and	r17, r17
    6e2e:	61 f1       	breq	.+88     	; 0x6e88 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e30:	69 81       	ldd	r22, Y+1	; 0x01
    6e32:	7a 81       	ldd	r23, Y+2	; 0x02
    6e34:	8b 81       	ldd	r24, Y+3	; 0x03
    6e36:	9c 81       	ldd	r25, Y+4	; 0x04
    6e38:	20 e0       	ldi	r18, 0x00	; 0
    6e3a:	30 e0       	ldi	r19, 0x00	; 0
    6e3c:	40 e2       	ldi	r20, 0x20	; 32
    6e3e:	51 e4       	ldi	r21, 0x41	; 65
    6e40:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6e44:	dc 01       	movw	r26, r24
    6e46:	cb 01       	movw	r24, r22
    6e48:	bc 01       	movw	r22, r24
    6e4a:	cd 01       	movw	r24, r26
    6e4c:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6e50:	dc 01       	movw	r26, r24
    6e52:	cb 01       	movw	r24, r22
    6e54:	89 87       	std	Y+9, r24	; 0x09
    6e56:	9a 87       	std	Y+10, r25	; 0x0a
    6e58:	12 c0       	rjmp	.+36     	; 0x6e7e <HVPower+0xf8>
    6e5a:	80 e2       	ldi	r24, 0x20	; 32
    6e5c:	93 e0       	ldi	r25, 0x03	; 3
    6e5e:	8b 87       	std	Y+11, r24	; 0x0b
    6e60:	9c 87       	std	Y+12, r25	; 0x0c
    6e62:	8b 85       	ldd	r24, Y+11	; 0x0b
    6e64:	9c 85       	ldd	r25, Y+12	; 0x0c
    6e66:	8c 01       	movw	r16, r24
    6e68:	c8 01       	movw	r24, r16
    6e6a:	01 97       	sbiw	r24, 0x01	; 1
    6e6c:	f1 f7       	brne	.-4      	; 0x6e6a <HVPower+0xe4>
    6e6e:	8c 01       	movw	r16, r24
    6e70:	0b 87       	std	Y+11, r16	; 0x0b
    6e72:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e74:	89 85       	ldd	r24, Y+9	; 0x09
    6e76:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e78:	01 97       	sbiw	r24, 0x01	; 1
    6e7a:	89 87       	std	Y+9, r24	; 0x09
    6e7c:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e7e:	89 85       	ldd	r24, Y+9	; 0x09
    6e80:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e82:	00 97       	sbiw	r24, 0x00	; 0
    6e84:	51 f7       	brne	.-44     	; 0x6e5a <HVPower+0xd4>
    6e86:	22 c0       	rjmp	.+68     	; 0x6ecc <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e88:	6d 81       	ldd	r22, Y+5	; 0x05
    6e8a:	7e 81       	ldd	r23, Y+6	; 0x06
    6e8c:	8f 81       	ldd	r24, Y+7	; 0x07
    6e8e:	98 85       	ldd	r25, Y+8	; 0x08
    6e90:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6e94:	dc 01       	movw	r26, r24
    6e96:	cb 01       	movw	r24, r22
    6e98:	89 87       	std	Y+9, r24	; 0x09
    6e9a:	9a 87       	std	Y+10, r25	; 0x0a
    6e9c:	89 85       	ldd	r24, Y+9	; 0x09
    6e9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ea0:	8d 87       	std	Y+13, r24	; 0x0d
    6ea2:	9e 87       	std	Y+14, r25	; 0x0e
    6ea4:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ea6:	9e 85       	ldd	r25, Y+14	; 0x0e
    6ea8:	8c 01       	movw	r16, r24
    6eaa:	f8 01       	movw	r30, r16
    6eac:	31 97       	sbiw	r30, 0x01	; 1
    6eae:	f1 f7       	brne	.-4      	; 0x6eac <HVPower+0x126>
    6eb0:	8f 01       	movw	r16, r30
    6eb2:	0d 87       	std	Y+13, r16	; 0x0d
    6eb4:	1e 87       	std	Y+14, r17	; 0x0e
    6eb6:	0a c0       	rjmp	.+20     	; 0x6ecc <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6eb8:	80 ea       	ldi	r24, 0xA0	; 160
    6eba:	96 e0       	ldi	r25, 0x06	; 6
    6ebc:	20 e8       	ldi	r18, 0x80	; 128
    6ebe:	fc 01       	movw	r30, r24
    6ec0:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6ec2:	80 ea       	ldi	r24, 0xA0	; 160
    6ec4:	96 e0       	ldi	r25, 0x06	; 6
    6ec6:	20 e8       	ldi	r18, 0x80	; 128
    6ec8:	fc 01       	movw	r30, r24
    6eca:	22 83       	std	Z+2, r18	; 0x02
    6ecc:	80 e0       	ldi	r24, 0x00	; 0
    6ece:	90 e0       	ldi	r25, 0x00	; 0
    6ed0:	aa e7       	ldi	r26, 0x7A	; 122
    6ed2:	b4 e4       	ldi	r27, 0x44	; 68
    6ed4:	8f 87       	std	Y+15, r24	; 0x0f
    6ed6:	98 8b       	std	Y+16, r25	; 0x10
    6ed8:	a9 8b       	std	Y+17, r26	; 0x11
    6eda:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6edc:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ede:	78 89       	ldd	r23, Y+16	; 0x10
    6ee0:	89 89       	ldd	r24, Y+17	; 0x11
    6ee2:	9a 89       	ldd	r25, Y+18	; 0x12
    6ee4:	2b ea       	ldi	r18, 0xAB	; 171
    6ee6:	3a ea       	ldi	r19, 0xAA	; 170
    6ee8:	4a e2       	ldi	r20, 0x2A	; 42
    6eea:	51 e4       	ldi	r21, 0x41	; 65
    6eec:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6ef0:	dc 01       	movw	r26, r24
    6ef2:	cb 01       	movw	r24, r22
    6ef4:	8b 8b       	std	Y+19, r24	; 0x13
    6ef6:	9c 8b       	std	Y+20, r25	; 0x14
    6ef8:	ad 8b       	std	Y+21, r26	; 0x15
    6efa:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6efc:	11 e0       	ldi	r17, 0x01	; 1
    6efe:	6b 89       	ldd	r22, Y+19	; 0x13
    6f00:	7c 89       	ldd	r23, Y+20	; 0x14
    6f02:	8d 89       	ldd	r24, Y+21	; 0x15
    6f04:	9e 89       	ldd	r25, Y+22	; 0x16
    6f06:	20 e0       	ldi	r18, 0x00	; 0
    6f08:	30 e0       	ldi	r19, 0x00	; 0
    6f0a:	40 e8       	ldi	r20, 0x80	; 128
    6f0c:	5f e3       	ldi	r21, 0x3F	; 63
    6f0e:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    6f12:	88 23       	and	r24, r24
    6f14:	0c f0       	brlt	.+2      	; 0x6f18 <HVPower+0x192>
    6f16:	10 e0       	ldi	r17, 0x00	; 0
    6f18:	11 23       	and	r17, r17
    6f1a:	19 f0       	breq	.+6      	; 0x6f22 <HVPower+0x19c>
		__ticks = 1;
    6f1c:	81 e0       	ldi	r24, 0x01	; 1
    6f1e:	8f 8b       	std	Y+23, r24	; 0x17
    6f20:	a3 c0       	rjmp	.+326    	; 0x7068 <HVPower+0x2e2>
	else if (__tmp > 255)
    6f22:	11 e0       	ldi	r17, 0x01	; 1
    6f24:	6b 89       	ldd	r22, Y+19	; 0x13
    6f26:	7c 89       	ldd	r23, Y+20	; 0x14
    6f28:	8d 89       	ldd	r24, Y+21	; 0x15
    6f2a:	9e 89       	ldd	r25, Y+22	; 0x16
    6f2c:	20 e0       	ldi	r18, 0x00	; 0
    6f2e:	30 e0       	ldi	r19, 0x00	; 0
    6f30:	4f e7       	ldi	r20, 0x7F	; 127
    6f32:	53 e4       	ldi	r21, 0x43	; 67
    6f34:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    6f38:	18 16       	cp	r1, r24
    6f3a:	0c f0       	brlt	.+2      	; 0x6f3e <HVPower+0x1b8>
    6f3c:	10 e0       	ldi	r17, 0x00	; 0
    6f3e:	11 23       	and	r17, r17
    6f40:	09 f4       	brne	.+2      	; 0x6f44 <HVPower+0x1be>
    6f42:	89 c0       	rjmp	.+274    	; 0x7056 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6f44:	6f 85       	ldd	r22, Y+15	; 0x0f
    6f46:	78 89       	ldd	r23, Y+16	; 0x10
    6f48:	89 89       	ldd	r24, Y+17	; 0x11
    6f4a:	9a 89       	ldd	r25, Y+18	; 0x12
    6f4c:	20 e0       	ldi	r18, 0x00	; 0
    6f4e:	30 e0       	ldi	r19, 0x00	; 0
    6f50:	4a e7       	ldi	r20, 0x7A	; 122
    6f52:	54 e4       	ldi	r21, 0x44	; 68
    6f54:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    6f58:	dc 01       	movw	r26, r24
    6f5a:	cb 01       	movw	r24, r22
    6f5c:	88 8f       	std	Y+24, r24	; 0x18
    6f5e:	99 8f       	std	Y+25, r25	; 0x19
    6f60:	aa 8f       	std	Y+26, r26	; 0x1a
    6f62:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6f64:	68 8d       	ldd	r22, Y+24	; 0x18
    6f66:	79 8d       	ldd	r23, Y+25	; 0x19
    6f68:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6f6a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6f6c:	20 e0       	ldi	r18, 0x00	; 0
    6f6e:	30 e0       	ldi	r19, 0x00	; 0
    6f70:	4a ef       	ldi	r20, 0xFA	; 250
    6f72:	55 e4       	ldi	r21, 0x45	; 69
    6f74:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6f78:	dc 01       	movw	r26, r24
    6f7a:	cb 01       	movw	r24, r22
    6f7c:	8c 8f       	std	Y+28, r24	; 0x1c
    6f7e:	9d 8f       	std	Y+29, r25	; 0x1d
    6f80:	ae 8f       	std	Y+30, r26	; 0x1e
    6f82:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6f84:	11 e0       	ldi	r17, 0x01	; 1
    6f86:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6f88:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6f8a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6f8c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6f8e:	20 e0       	ldi	r18, 0x00	; 0
    6f90:	30 e0       	ldi	r19, 0x00	; 0
    6f92:	40 e8       	ldi	r20, 0x80	; 128
    6f94:	5f e3       	ldi	r21, 0x3F	; 63
    6f96:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    6f9a:	88 23       	and	r24, r24
    6f9c:	0c f0       	brlt	.+2      	; 0x6fa0 <HVPower+0x21a>
    6f9e:	10 e0       	ldi	r17, 0x00	; 0
    6fa0:	11 23       	and	r17, r17
    6fa2:	29 f0       	breq	.+10     	; 0x6fae <HVPower+0x228>
		__ticks = 1;
    6fa4:	81 e0       	ldi	r24, 0x01	; 1
    6fa6:	90 e0       	ldi	r25, 0x00	; 0
    6fa8:	88 a3       	lds	r24, 0x58
    6faa:	99 a3       	lds	r25, 0x59
    6fac:	46 c0       	rjmp	.+140    	; 0x703a <HVPower+0x2b4>
	else if (__tmp > 65535)
    6fae:	11 e0       	ldi	r17, 0x01	; 1
    6fb0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6fb2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6fb4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6fb6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6fb8:	20 e0       	ldi	r18, 0x00	; 0
    6fba:	3f ef       	ldi	r19, 0xFF	; 255
    6fbc:	4f e7       	ldi	r20, 0x7F	; 127
    6fbe:	57 e4       	ldi	r21, 0x47	; 71
    6fc0:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    6fc4:	18 16       	cp	r1, r24
    6fc6:	0c f0       	brlt	.+2      	; 0x6fca <HVPower+0x244>
    6fc8:	10 e0       	ldi	r17, 0x00	; 0
    6fca:	11 23       	and	r17, r17
    6fcc:	61 f1       	breq	.+88     	; 0x7026 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6fce:	68 8d       	ldd	r22, Y+24	; 0x18
    6fd0:	79 8d       	ldd	r23, Y+25	; 0x19
    6fd2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6fd4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6fd6:	20 e0       	ldi	r18, 0x00	; 0
    6fd8:	30 e0       	ldi	r19, 0x00	; 0
    6fda:	40 e2       	ldi	r20, 0x20	; 32
    6fdc:	51 e4       	ldi	r21, 0x41	; 65
    6fde:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    6fe2:	dc 01       	movw	r26, r24
    6fe4:	cb 01       	movw	r24, r22
    6fe6:	bc 01       	movw	r22, r24
    6fe8:	cd 01       	movw	r24, r26
    6fea:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    6fee:	dc 01       	movw	r26, r24
    6ff0:	cb 01       	movw	r24, r22
    6ff2:	88 a3       	lds	r24, 0x58
    6ff4:	99 a3       	lds	r25, 0x59
    6ff6:	12 c0       	rjmp	.+36     	; 0x701c <HVPower+0x296>
    6ff8:	80 e2       	ldi	r24, 0x20	; 32
    6ffa:	93 e0       	ldi	r25, 0x03	; 3
    6ffc:	8a a3       	lds	r24, 0x5a
    6ffe:	9b a3       	lds	r25, 0x5b
    7000:	8a a1       	lds	r24, 0x4a
    7002:	9b a1       	lds	r25, 0x4b
    7004:	8c 01       	movw	r16, r24
    7006:	c8 01       	movw	r24, r16
    7008:	01 97       	sbiw	r24, 0x01	; 1
    700a:	f1 f7       	brne	.-4      	; 0x7008 <HVPower+0x282>
    700c:	8c 01       	movw	r16, r24
    700e:	0a a3       	lds	r16, 0x5a
    7010:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7012:	88 a1       	lds	r24, 0x48
    7014:	99 a1       	lds	r25, 0x49
    7016:	01 97       	sbiw	r24, 0x01	; 1
    7018:	88 a3       	lds	r24, 0x58
    701a:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    701c:	88 a1       	lds	r24, 0x48
    701e:	99 a1       	lds	r25, 0x49
    7020:	00 97       	sbiw	r24, 0x00	; 0
    7022:	51 f7       	brne	.-44     	; 0x6ff8 <HVPower+0x272>
    7024:	28 c0       	rjmp	.+80     	; 0x7076 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7026:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7028:	7d 8d       	ldd	r23, Y+29	; 0x1d
    702a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    702c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    702e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7032:	dc 01       	movw	r26, r24
    7034:	cb 01       	movw	r24, r22
    7036:	88 a3       	lds	r24, 0x58
    7038:	99 a3       	lds	r25, 0x59
    703a:	88 a1       	lds	r24, 0x48
    703c:	99 a1       	lds	r25, 0x49
    703e:	8c a3       	lds	r24, 0x5c
    7040:	9d a3       	lds	r25, 0x5d
    7042:	8c a1       	lds	r24, 0x4c
    7044:	9d a1       	lds	r25, 0x4d
    7046:	8c 01       	movw	r16, r24
    7048:	f8 01       	movw	r30, r16
    704a:	31 97       	sbiw	r30, 0x01	; 1
    704c:	f1 f7       	brne	.-4      	; 0x704a <HVPower+0x2c4>
    704e:	8f 01       	movw	r16, r30
    7050:	0c a3       	lds	r16, 0x5c
    7052:	1d a3       	lds	r17, 0x5d
    7054:	10 c0       	rjmp	.+32     	; 0x7076 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7056:	6b 89       	ldd	r22, Y+19	; 0x13
    7058:	7c 89       	ldd	r23, Y+20	; 0x14
    705a:	8d 89       	ldd	r24, Y+21	; 0x15
    705c:	9e 89       	ldd	r25, Y+22	; 0x16
    705e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7062:	dc 01       	movw	r26, r24
    7064:	cb 01       	movw	r24, r22
    7066:	8f 8b       	std	Y+23, r24	; 0x17
    7068:	8f 89       	ldd	r24, Y+23	; 0x17
    706a:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    706c:	8e a1       	lds	r24, 0x4e
    706e:	18 2f       	mov	r17, r24
    7070:	1a 95       	dec	r17
    7072:	f1 f7       	brne	.-4      	; 0x7070 <HVPower+0x2ea>
    7074:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    7076:	a7 96       	adiw	r28, 0x27	; 39
    7078:	cd bf       	out	0x3d, r28	; 61
    707a:	de bf       	out	0x3e, r29	; 62
    707c:	df 91       	pop	r29
    707e:	cf 91       	pop	r28
    7080:	1f 91       	pop	r17
    7082:	0f 91       	pop	r16
    7084:	08 95       	ret

00007086 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    7086:	cf 93       	push	r28
    7088:	df 93       	push	r29
    708a:	0f 92       	push	r0
    708c:	cd b7       	in	r28, 0x3d	; 61
    708e:	de b7       	in	r29, 0x3e	; 62
    7090:	89 83       	std	Y+1, r24	; 0x01
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    7092:	89 81       	ldd	r24, Y+1	; 0x01
    7094:	88 23       	and	r24, r24
    7096:	31 f0       	breq	.+12     	; 0x70a4 <lowerMuxCS+0x1e>
    7098:	80 e8       	ldi	r24, 0x80	; 128
    709a:	96 e0       	ldi	r25, 0x06	; 6
    709c:	20 e1       	ldi	r18, 0x10	; 16
    709e:	fc 01       	movw	r30, r24
    70a0:	26 83       	std	Z+6, r18	; 0x06
    70a2:	05 c0       	rjmp	.+10     	; 0x70ae <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    70a4:	80 e8       	ldi	r24, 0x80	; 128
    70a6:	96 e0       	ldi	r25, 0x06	; 6
    70a8:	20 e1       	ldi	r18, 0x10	; 16
    70aa:	fc 01       	movw	r30, r24
    70ac:	25 83       	std	Z+5, r18	; 0x05
}
    70ae:	0f 90       	pop	r0
    70b0:	df 91       	pop	r29
    70b2:	cf 91       	pop	r28
    70b4:	08 95       	ret

000070b6 <upperMuxCS>:

void upperMuxCS(uint8_t write) {
    70b6:	cf 93       	push	r28
    70b8:	df 93       	push	r29
    70ba:	0f 92       	push	r0
    70bc:	cd b7       	in	r28, 0x3d	; 61
    70be:	de b7       	in	r29, 0x3e	; 62
    70c0:	89 83       	std	Y+1, r24	; 0x01
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    70c2:	89 81       	ldd	r24, Y+1	; 0x01
    70c4:	88 23       	and	r24, r24
    70c6:	31 f0       	breq	.+12     	; 0x70d4 <upperMuxCS+0x1e>
    70c8:	80 e4       	ldi	r24, 0x40	; 64
    70ca:	96 e0       	ldi	r25, 0x06	; 6
    70cc:	22 e0       	ldi	r18, 0x02	; 2
    70ce:	fc 01       	movw	r30, r24
    70d0:	26 83       	std	Z+6, r18	; 0x06
    70d2:	05 c0       	rjmp	.+10     	; 0x70de <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    70d4:	80 e4       	ldi	r24, 0x40	; 64
    70d6:	96 e0       	ldi	r25, 0x06	; 6
    70d8:	22 e0       	ldi	r18, 0x02	; 2
    70da:	fc 01       	movw	r30, r24
    70dc:	25 83       	std	Z+5, r18	; 0x05
}
    70de:	0f 90       	pop	r0
    70e0:	df 91       	pop	r29
    70e2:	cf 91       	pop	r28
    70e4:	08 95       	ret

000070e6 <SPIInit>:

void SPIInit(uint8_t mode) {
    70e6:	cf 93       	push	r28
    70e8:	df 93       	push	r29
    70ea:	0f 92       	push	r0
    70ec:	cd b7       	in	r28, 0x3d	; 61
    70ee:	de b7       	in	r29, 0x3e	; 62
    70f0:	89 83       	std	Y+1, r24	; 0x01
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    70f2:	80 e4       	ldi	r24, 0x40	; 64
    70f4:	96 e0       	ldi	r25, 0x06	; 6
    70f6:	20 e1       	ldi	r18, 0x10	; 16
    70f8:	fc 01       	movw	r30, r24
    70fa:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    70fc:	80 e4       	ldi	r24, 0x40	; 64
    70fe:	96 e0       	ldi	r25, 0x06	; 6
    7100:	28 e3       	ldi	r18, 0x38	; 56
    7102:	fc 01       	movw	r30, r24
    7104:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    7106:	80 e4       	ldi	r24, 0x40	; 64
    7108:	96 e0       	ldi	r25, 0x06	; 6
    710a:	20 e1       	ldi	r18, 0x10	; 16
    710c:	fc 01       	movw	r30, r24
    710e:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    7110:	80 ec       	ldi	r24, 0xC0	; 192
    7112:	98 e0       	ldi	r25, 0x08	; 8
    7114:	29 81       	ldd	r18, Y+1	; 0x01
    7116:	21 65       	ori	r18, 0x51	; 81
    7118:	fc 01       	movw	r30, r24
    711a:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    711c:	80 ec       	ldi	r24, 0xC0	; 192
    711e:	98 e0       	ldi	r25, 0x08	; 8
    7120:	fc 01       	movw	r30, r24
    7122:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    7124:	80 e4       	ldi	r24, 0x40	; 64
    7126:	96 e0       	ldi	r25, 0x06	; 6
    7128:	20 ea       	ldi	r18, 0xA0	; 160
    712a:	fc 01       	movw	r30, r24
    712c:	21 83       	std	Z+1, r18	; 0x01

	
}
    712e:	0f 90       	pop	r0
    7130:	df 91       	pop	r29
    7132:	cf 91       	pop	r28
    7134:	08 95       	ret

00007136 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    7136:	cf 93       	push	r28
    7138:	df 93       	push	r29
    713a:	0f 92       	push	r0
    713c:	0f 92       	push	r0
    713e:	cd b7       	in	r28, 0x3d	; 61
    7140:	de b7       	in	r29, 0x3e	; 62
    7142:	89 83       	std	Y+1, r24	; 0x01
    7144:	6a 83       	std	Y+2, r22	; 0x02
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    7146:	80 e4       	ldi	r24, 0x40	; 64
    7148:	96 e0       	ldi	r25, 0x06	; 6
    714a:	20 e1       	ldi	r18, 0x10	; 16
    714c:	fc 01       	movw	r30, r24
    714e:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    7150:	80 e4       	ldi	r24, 0x40	; 64
    7152:	96 e0       	ldi	r25, 0x06	; 6
    7154:	28 e3       	ldi	r18, 0x38	; 56
    7156:	fc 01       	movw	r30, r24
    7158:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    715a:	80 e4       	ldi	r24, 0x40	; 64
    715c:	96 e0       	ldi	r25, 0x06	; 6
    715e:	20 e1       	ldi	r18, 0x10	; 16
    7160:	fc 01       	movw	r30, r24
    7162:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    7164:	80 ec       	ldi	r24, 0xC0	; 192
    7166:	98 e0       	ldi	r25, 0x08	; 8
    7168:	3a 81       	ldd	r19, Y+2	; 0x02
    716a:	29 81       	ldd	r18, Y+1	; 0x01
    716c:	23 2b       	or	r18, r19
    716e:	20 65       	ori	r18, 0x50	; 80
    7170:	fc 01       	movw	r30, r24
    7172:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    7174:	80 ec       	ldi	r24, 0xC0	; 192
    7176:	98 e0       	ldi	r25, 0x08	; 8
    7178:	fc 01       	movw	r30, r24
    717a:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    717c:	80 e4       	ldi	r24, 0x40	; 64
    717e:	96 e0       	ldi	r25, 0x06	; 6
    7180:	20 ea       	ldi	r18, 0xA0	; 160
    7182:	fc 01       	movw	r30, r24
    7184:	21 83       	std	Z+1, r18	; 0x01
}
    7186:	0f 90       	pop	r0
    7188:	0f 90       	pop	r0
    718a:	df 91       	pop	r29
    718c:	cf 91       	pop	r28
    718e:	08 95       	ret

00007190 <SPICS>:

void SPICS(uint8_t enable) {
    7190:	cf 93       	push	r28
    7192:	df 93       	push	r29
    7194:	0f 92       	push	r0
    7196:	cd b7       	in	r28, 0x3d	; 61
    7198:	de b7       	in	r29, 0x3e	; 62
    719a:	89 83       	std	Y+1, r24	; 0x01
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    719c:	89 81       	ldd	r24, Y+1	; 0x01
    719e:	88 23       	and	r24, r24
    71a0:	31 f0       	breq	.+12     	; 0x71ae <SPICS+0x1e>
    71a2:	80 e4       	ldi	r24, 0x40	; 64
    71a4:	96 e0       	ldi	r25, 0x06	; 6
    71a6:	20 e1       	ldi	r18, 0x10	; 16
    71a8:	fc 01       	movw	r30, r24
    71aa:	26 83       	std	Z+6, r18	; 0x06
    71ac:	05 c0       	rjmp	.+10     	; 0x71b8 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    71ae:	80 e4       	ldi	r24, 0x40	; 64
    71b0:	96 e0       	ldi	r25, 0x06	; 6
    71b2:	20 e1       	ldi	r18, 0x10	; 16
    71b4:	fc 01       	movw	r30, r24
    71b6:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    71b8:	0f 90       	pop	r0
    71ba:	df 91       	pop	r29
    71bc:	cf 91       	pop	r28
    71be:	08 95       	ret

000071c0 <SPIDisable>:

void SPIDisable() {
    71c0:	cf 93       	push	r28
    71c2:	df 93       	push	r29
    71c4:	cd b7       	in	r28, 0x3d	; 61
    71c6:	de b7       	in	r29, 0x3e	; 62
	
	PORTC.OUTSET = PIN4_bm;
    71c8:	80 e4       	ldi	r24, 0x40	; 64
    71ca:	96 e0       	ldi	r25, 0x06	; 6
    71cc:	20 e1       	ldi	r18, 0x10	; 16
    71ce:	fc 01       	movw	r30, r24
    71d0:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    71d2:	80 ec       	ldi	r24, 0xC0	; 192
    71d4:	98 e0       	ldi	r25, 0x08	; 8
    71d6:	fc 01       	movw	r30, r24
    71d8:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    71da:	80 e4       	ldi	r24, 0x40	; 64
    71dc:	96 e0       	ldi	r25, 0x06	; 6
    71de:	20 e1       	ldi	r18, 0x10	; 16
    71e0:	fc 01       	movw	r30, r24
    71e2:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    71e4:	80 e4       	ldi	r24, 0x40	; 64
    71e6:	96 e0       	ldi	r25, 0x06	; 6
    71e8:	20 eb       	ldi	r18, 0xB0	; 176
    71ea:	fc 01       	movw	r30, r24
    71ec:	22 83       	std	Z+2, r18	; 0x02

}
    71ee:	df 91       	pop	r29
    71f0:	cf 91       	pop	r28
    71f2:	08 95       	ret

000071f4 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    71f4:	cf 93       	push	r28
    71f6:	df 93       	push	r29
    71f8:	00 d0       	rcall	.+0      	; 0x71fa <readFRAM+0x6>
    71fa:	0f 92       	push	r0
    71fc:	cd b7       	in	r28, 0x3d	; 61
    71fe:	de b7       	in	r29, 0x3e	; 62
    7200:	8b 83       	std	Y+3, r24	; 0x03
    7202:	9c 83       	std	Y+4, r25	; 0x04
	
	SPIInit(SPI_MODE_0_gc);
    7204:	80 e0       	ldi	r24, 0x00	; 0
    7206:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    720a:	80 ec       	ldi	r24, 0xC0	; 192
    720c:	98 e0       	ldi	r25, 0x08	; 8
    720e:	20 ed       	ldi	r18, 0xD0	; 208
    7210:	fc 01       	movw	r30, r24
    7212:	20 83       	st	Z, r18
	SPICS(TRUE);
    7214:	81 e0       	ldi	r24, 0x01	; 1
    7216:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    721a:	80 e2       	ldi	r24, 0x20	; 32
    721c:	96 e0       	ldi	r25, 0x06	; 6
    721e:	28 e0       	ldi	r18, 0x08	; 8
    7220:	fc 01       	movw	r30, r24
    7222:	26 83       	std	Z+6, r18	; 0x06
	nop();
    7224:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    7226:	80 ec       	ldi	r24, 0xC0	; 192
    7228:	98 e0       	ldi	r25, 0x08	; 8
    722a:	23 e0       	ldi	r18, 0x03	; 3
    722c:	fc 01       	movw	r30, r24
    722e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7230:	00 00       	nop
    7232:	80 ec       	ldi	r24, 0xC0	; 192
    7234:	98 e0       	ldi	r25, 0x08	; 8
    7236:	fc 01       	movw	r30, r24
    7238:	82 81       	ldd	r24, Z+2	; 0x02
    723a:	88 23       	and	r24, r24
    723c:	d4 f7       	brge	.-12     	; 0x7232 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    723e:	80 ec       	ldi	r24, 0xC0	; 192
    7240:	98 e0       	ldi	r25, 0x08	; 8
    7242:	fc 01       	movw	r30, r24
    7244:	83 81       	ldd	r24, Z+3	; 0x03
    7246:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    724a:	80 ec       	ldi	r24, 0xC0	; 192
    724c:	98 e0       	ldi	r25, 0x08	; 8
    724e:	20 91 49 40 	lds	r18, 0x4049
    7252:	fc 01       	movw	r30, r24
    7254:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7256:	00 00       	nop
    7258:	80 ec       	ldi	r24, 0xC0	; 192
    725a:	98 e0       	ldi	r25, 0x08	; 8
    725c:	fc 01       	movw	r30, r24
    725e:	82 81       	ldd	r24, Z+2	; 0x02
    7260:	88 23       	and	r24, r24
    7262:	d4 f7       	brge	.-12     	; 0x7258 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    7264:	80 ec       	ldi	r24, 0xC0	; 192
    7266:	98 e0       	ldi	r25, 0x08	; 8
    7268:	fc 01       	movw	r30, r24
    726a:	83 81       	ldd	r24, Z+3	; 0x03
    726c:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    7270:	80 ec       	ldi	r24, 0xC0	; 192
    7272:	98 e0       	ldi	r25, 0x08	; 8
    7274:	28 e4       	ldi	r18, 0x48	; 72
    7276:	30 e4       	ldi	r19, 0x40	; 64
    7278:	f9 01       	movw	r30, r18
    727a:	20 81       	ld	r18, Z
    727c:	fc 01       	movw	r30, r24
    727e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7280:	00 00       	nop
    7282:	80 ec       	ldi	r24, 0xC0	; 192
    7284:	98 e0       	ldi	r25, 0x08	; 8
    7286:	fc 01       	movw	r30, r24
    7288:	82 81       	ldd	r24, Z+2	; 0x02
    728a:	88 23       	and	r24, r24
    728c:	d4 f7       	brge	.-12     	; 0x7282 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    728e:	80 ec       	ldi	r24, 0xC0	; 192
    7290:	98 e0       	ldi	r25, 0x08	; 8
    7292:	fc 01       	movw	r30, r24
    7294:	83 81       	ldd	r24, Z+3	; 0x03
    7296:	80 93 62 50 	sts	0x5062, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    729a:	19 82       	std	Y+1, r1	; 0x01
    729c:	1a 82       	std	Y+2, r1	; 0x02
    729e:	1b c0       	rjmp	.+54     	; 0x72d6 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    72a0:	80 ec       	ldi	r24, 0xC0	; 192
    72a2:	98 e0       	ldi	r25, 0x08	; 8
    72a4:	2a ea       	ldi	r18, 0xAA	; 170
    72a6:	fc 01       	movw	r30, r24
    72a8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    72aa:	00 00       	nop
    72ac:	80 ec       	ldi	r24, 0xC0	; 192
    72ae:	98 e0       	ldi	r25, 0x08	; 8
    72b0:	fc 01       	movw	r30, r24
    72b2:	82 81       	ldd	r24, Z+2	; 0x02
    72b4:	88 23       	and	r24, r24
    72b6:	d4 f7       	brge	.-12     	; 0x72ac <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    72b8:	80 ec       	ldi	r24, 0xC0	; 192
    72ba:	98 e0       	ldi	r25, 0x08	; 8
    72bc:	fc 01       	movw	r30, r24
    72be:	23 81       	ldd	r18, Z+3	; 0x03
    72c0:	89 81       	ldd	r24, Y+1	; 0x01
    72c2:	9a 81       	ldd	r25, Y+2	; 0x02
    72c4:	80 53       	subi	r24, 0x30	; 48
    72c6:	9c 4d       	sbci	r25, 0xDC	; 220
    72c8:	fc 01       	movw	r30, r24
    72ca:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    72cc:	89 81       	ldd	r24, Y+1	; 0x01
    72ce:	9a 81       	ldd	r25, Y+2	; 0x02
    72d0:	01 96       	adiw	r24, 0x01	; 1
    72d2:	89 83       	std	Y+1, r24	; 0x01
    72d4:	9a 83       	std	Y+2, r25	; 0x02
    72d6:	29 81       	ldd	r18, Y+1	; 0x01
    72d8:	3a 81       	ldd	r19, Y+2	; 0x02
    72da:	8b 81       	ldd	r24, Y+3	; 0x03
    72dc:	9c 81       	ldd	r25, Y+4	; 0x04
    72de:	28 17       	cp	r18, r24
    72e0:	39 07       	cpc	r19, r25
    72e2:	f0 f2       	brcs	.-68     	; 0x72a0 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    72e4:	80 e2       	ldi	r24, 0x20	; 32
    72e6:	96 e0       	ldi	r25, 0x06	; 6
    72e8:	28 e0       	ldi	r18, 0x08	; 8
    72ea:	fc 01       	movw	r30, r24
    72ec:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    72ee:	80 e0       	ldi	r24, 0x00	; 0
    72f0:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    72f4:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>

}
    72f8:	24 96       	adiw	r28, 0x04	; 4
    72fa:	cd bf       	out	0x3d, r28	; 61
    72fc:	de bf       	out	0x3e, r29	; 62
    72fe:	df 91       	pop	r29
    7300:	cf 91       	pop	r28
    7302:	08 95       	ret

00007304 <FRAMTest3Channel>:

//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
    7304:	0f 93       	push	r16
    7306:	1f 93       	push	r17
    7308:	cf 93       	push	r28
    730a:	df 93       	push	r29
    730c:	cd b7       	in	r28, 0x3d	; 61
    730e:	de b7       	in	r29, 0x3e	; 62
    7310:	68 97       	sbiw	r28, 0x18	; 24
    7312:	cd bf       	out	0x3d, r28	; 61
    7314:	de bf       	out	0x3e, r29	; 62
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7316:	81 e0       	ldi	r24, 0x01	; 1
    7318:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
    731c:	80 e0       	ldi	r24, 0x00	; 0
    731e:	90 e0       	ldi	r25, 0x00	; 0
    7320:	aa e7       	ldi	r26, 0x7A	; 122
    7322:	b3 e4       	ldi	r27, 0x43	; 67
    7324:	89 83       	std	Y+1, r24	; 0x01
    7326:	9a 83       	std	Y+2, r25	; 0x02
    7328:	ab 83       	std	Y+3, r26	; 0x03
    732a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    732c:	69 81       	ldd	r22, Y+1	; 0x01
    732e:	7a 81       	ldd	r23, Y+2	; 0x02
    7330:	8b 81       	ldd	r24, Y+3	; 0x03
    7332:	9c 81       	ldd	r25, Y+4	; 0x04
    7334:	2b ea       	ldi	r18, 0xAB	; 171
    7336:	3a ea       	ldi	r19, 0xAA	; 170
    7338:	4a e2       	ldi	r20, 0x2A	; 42
    733a:	51 e4       	ldi	r21, 0x41	; 65
    733c:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    7340:	dc 01       	movw	r26, r24
    7342:	cb 01       	movw	r24, r22
    7344:	8d 83       	std	Y+5, r24	; 0x05
    7346:	9e 83       	std	Y+6, r25	; 0x06
    7348:	af 83       	std	Y+7, r26	; 0x07
    734a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    734c:	11 e0       	ldi	r17, 0x01	; 1
    734e:	6d 81       	ldd	r22, Y+5	; 0x05
    7350:	7e 81       	ldd	r23, Y+6	; 0x06
    7352:	8f 81       	ldd	r24, Y+7	; 0x07
    7354:	98 85       	ldd	r25, Y+8	; 0x08
    7356:	20 e0       	ldi	r18, 0x00	; 0
    7358:	30 e0       	ldi	r19, 0x00	; 0
    735a:	40 e8       	ldi	r20, 0x80	; 128
    735c:	5f e3       	ldi	r21, 0x3F	; 63
    735e:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    7362:	88 23       	and	r24, r24
    7364:	0c f0       	brlt	.+2      	; 0x7368 <FRAMTest3Channel+0x64>
    7366:	10 e0       	ldi	r17, 0x00	; 0
    7368:	11 23       	and	r17, r17
    736a:	19 f0       	breq	.+6      	; 0x7372 <FRAMTest3Channel+0x6e>
		__ticks = 1;
    736c:	81 e0       	ldi	r24, 0x01	; 1
    736e:	89 87       	std	Y+9, r24	; 0x09
    7370:	a3 c0       	rjmp	.+326    	; 0x74b8 <FRAMTest3Channel+0x1b4>
	else if (__tmp > 255)
    7372:	11 e0       	ldi	r17, 0x01	; 1
    7374:	6d 81       	ldd	r22, Y+5	; 0x05
    7376:	7e 81       	ldd	r23, Y+6	; 0x06
    7378:	8f 81       	ldd	r24, Y+7	; 0x07
    737a:	98 85       	ldd	r25, Y+8	; 0x08
    737c:	20 e0       	ldi	r18, 0x00	; 0
    737e:	30 e0       	ldi	r19, 0x00	; 0
    7380:	4f e7       	ldi	r20, 0x7F	; 127
    7382:	53 e4       	ldi	r21, 0x43	; 67
    7384:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    7388:	18 16       	cp	r1, r24
    738a:	0c f0       	brlt	.+2      	; 0x738e <FRAMTest3Channel+0x8a>
    738c:	10 e0       	ldi	r17, 0x00	; 0
    738e:	11 23       	and	r17, r17
    7390:	09 f4       	brne	.+2      	; 0x7394 <FRAMTest3Channel+0x90>
    7392:	89 c0       	rjmp	.+274    	; 0x74a6 <FRAMTest3Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    7394:	69 81       	ldd	r22, Y+1	; 0x01
    7396:	7a 81       	ldd	r23, Y+2	; 0x02
    7398:	8b 81       	ldd	r24, Y+3	; 0x03
    739a:	9c 81       	ldd	r25, Y+4	; 0x04
    739c:	20 e0       	ldi	r18, 0x00	; 0
    739e:	30 e0       	ldi	r19, 0x00	; 0
    73a0:	4a e7       	ldi	r20, 0x7A	; 122
    73a2:	54 e4       	ldi	r21, 0x44	; 68
    73a4:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    73a8:	dc 01       	movw	r26, r24
    73aa:	cb 01       	movw	r24, r22
    73ac:	8a 87       	std	Y+10, r24	; 0x0a
    73ae:	9b 87       	std	Y+11, r25	; 0x0b
    73b0:	ac 87       	std	Y+12, r26	; 0x0c
    73b2:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    73b4:	6a 85       	ldd	r22, Y+10	; 0x0a
    73b6:	7b 85       	ldd	r23, Y+11	; 0x0b
    73b8:	8c 85       	ldd	r24, Y+12	; 0x0c
    73ba:	9d 85       	ldd	r25, Y+13	; 0x0d
    73bc:	20 e0       	ldi	r18, 0x00	; 0
    73be:	30 e0       	ldi	r19, 0x00	; 0
    73c0:	4a ef       	ldi	r20, 0xFA	; 250
    73c2:	55 e4       	ldi	r21, 0x45	; 69
    73c4:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    73c8:	dc 01       	movw	r26, r24
    73ca:	cb 01       	movw	r24, r22
    73cc:	8e 87       	std	Y+14, r24	; 0x0e
    73ce:	9f 87       	std	Y+15, r25	; 0x0f
    73d0:	a8 8b       	std	Y+16, r26	; 0x10
    73d2:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    73d4:	11 e0       	ldi	r17, 0x01	; 1
    73d6:	6e 85       	ldd	r22, Y+14	; 0x0e
    73d8:	7f 85       	ldd	r23, Y+15	; 0x0f
    73da:	88 89       	ldd	r24, Y+16	; 0x10
    73dc:	99 89       	ldd	r25, Y+17	; 0x11
    73de:	20 e0       	ldi	r18, 0x00	; 0
    73e0:	30 e0       	ldi	r19, 0x00	; 0
    73e2:	40 e8       	ldi	r20, 0x80	; 128
    73e4:	5f e3       	ldi	r21, 0x3F	; 63
    73e6:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    73ea:	88 23       	and	r24, r24
    73ec:	0c f0       	brlt	.+2      	; 0x73f0 <FRAMTest3Channel+0xec>
    73ee:	10 e0       	ldi	r17, 0x00	; 0
    73f0:	11 23       	and	r17, r17
    73f2:	29 f0       	breq	.+10     	; 0x73fe <FRAMTest3Channel+0xfa>
		__ticks = 1;
    73f4:	81 e0       	ldi	r24, 0x01	; 1
    73f6:	90 e0       	ldi	r25, 0x00	; 0
    73f8:	8a 8b       	std	Y+18, r24	; 0x12
    73fa:	9b 8b       	std	Y+19, r25	; 0x13
    73fc:	46 c0       	rjmp	.+140    	; 0x748a <FRAMTest3Channel+0x186>
	else if (__tmp > 65535)
    73fe:	11 e0       	ldi	r17, 0x01	; 1
    7400:	6e 85       	ldd	r22, Y+14	; 0x0e
    7402:	7f 85       	ldd	r23, Y+15	; 0x0f
    7404:	88 89       	ldd	r24, Y+16	; 0x10
    7406:	99 89       	ldd	r25, Y+17	; 0x11
    7408:	20 e0       	ldi	r18, 0x00	; 0
    740a:	3f ef       	ldi	r19, 0xFF	; 255
    740c:	4f e7       	ldi	r20, 0x7F	; 127
    740e:	57 e4       	ldi	r21, 0x47	; 71
    7410:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    7414:	18 16       	cp	r1, r24
    7416:	0c f0       	brlt	.+2      	; 0x741a <FRAMTest3Channel+0x116>
    7418:	10 e0       	ldi	r17, 0x00	; 0
    741a:	11 23       	and	r17, r17
    741c:	61 f1       	breq	.+88     	; 0x7476 <FRAMTest3Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    741e:	6a 85       	ldd	r22, Y+10	; 0x0a
    7420:	7b 85       	ldd	r23, Y+11	; 0x0b
    7422:	8c 85       	ldd	r24, Y+12	; 0x0c
    7424:	9d 85       	ldd	r25, Y+13	; 0x0d
    7426:	20 e0       	ldi	r18, 0x00	; 0
    7428:	30 e0       	ldi	r19, 0x00	; 0
    742a:	40 e2       	ldi	r20, 0x20	; 32
    742c:	51 e4       	ldi	r21, 0x41	; 65
    742e:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    7432:	dc 01       	movw	r26, r24
    7434:	cb 01       	movw	r24, r22
    7436:	bc 01       	movw	r22, r24
    7438:	cd 01       	movw	r24, r26
    743a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    743e:	dc 01       	movw	r26, r24
    7440:	cb 01       	movw	r24, r22
    7442:	8a 8b       	std	Y+18, r24	; 0x12
    7444:	9b 8b       	std	Y+19, r25	; 0x13
    7446:	12 c0       	rjmp	.+36     	; 0x746c <FRAMTest3Channel+0x168>
    7448:	80 e2       	ldi	r24, 0x20	; 32
    744a:	93 e0       	ldi	r25, 0x03	; 3
    744c:	8c 8b       	std	Y+20, r24	; 0x14
    744e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7450:	8c 89       	ldd	r24, Y+20	; 0x14
    7452:	9d 89       	ldd	r25, Y+21	; 0x15
    7454:	8c 01       	movw	r16, r24
    7456:	c8 01       	movw	r24, r16
    7458:	01 97       	sbiw	r24, 0x01	; 1
    745a:	f1 f7       	brne	.-4      	; 0x7458 <FRAMTest3Channel+0x154>
    745c:	8c 01       	movw	r16, r24
    745e:	0c 8b       	std	Y+20, r16	; 0x14
    7460:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7462:	8a 89       	ldd	r24, Y+18	; 0x12
    7464:	9b 89       	ldd	r25, Y+19	; 0x13
    7466:	01 97       	sbiw	r24, 0x01	; 1
    7468:	8a 8b       	std	Y+18, r24	; 0x12
    746a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    746c:	8a 89       	ldd	r24, Y+18	; 0x12
    746e:	9b 89       	ldd	r25, Y+19	; 0x13
    7470:	00 97       	sbiw	r24, 0x00	; 0
    7472:	51 f7       	brne	.-44     	; 0x7448 <FRAMTest3Channel+0x144>
    7474:	28 c0       	rjmp	.+80     	; 0x74c6 <FRAMTest3Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7476:	6e 85       	ldd	r22, Y+14	; 0x0e
    7478:	7f 85       	ldd	r23, Y+15	; 0x0f
    747a:	88 89       	ldd	r24, Y+16	; 0x10
    747c:	99 89       	ldd	r25, Y+17	; 0x11
    747e:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7482:	dc 01       	movw	r26, r24
    7484:	cb 01       	movw	r24, r22
    7486:	8a 8b       	std	Y+18, r24	; 0x12
    7488:	9b 8b       	std	Y+19, r25	; 0x13
    748a:	8a 89       	ldd	r24, Y+18	; 0x12
    748c:	9b 89       	ldd	r25, Y+19	; 0x13
    748e:	8e 8b       	std	Y+22, r24	; 0x16
    7490:	9f 8b       	std	Y+23, r25	; 0x17
    7492:	8e 89       	ldd	r24, Y+22	; 0x16
    7494:	9f 89       	ldd	r25, Y+23	; 0x17
    7496:	8c 01       	movw	r16, r24
    7498:	c8 01       	movw	r24, r16
    749a:	01 97       	sbiw	r24, 0x01	; 1
    749c:	f1 f7       	brne	.-4      	; 0x749a <FRAMTest3Channel+0x196>
    749e:	8c 01       	movw	r16, r24
    74a0:	0e 8b       	std	Y+22, r16	; 0x16
    74a2:	1f 8b       	std	Y+23, r17	; 0x17
    74a4:	10 c0       	rjmp	.+32     	; 0x74c6 <FRAMTest3Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    74a6:	6d 81       	ldd	r22, Y+5	; 0x05
    74a8:	7e 81       	ldd	r23, Y+6	; 0x06
    74aa:	8f 81       	ldd	r24, Y+7	; 0x07
    74ac:	98 85       	ldd	r25, Y+8	; 0x08
    74ae:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    74b2:	dc 01       	movw	r26, r24
    74b4:	cb 01       	movw	r24, r22
    74b6:	89 87       	std	Y+9, r24	; 0x09
    74b8:	89 85       	ldd	r24, Y+9	; 0x09
    74ba:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    74bc:	88 8d       	ldd	r24, Y+24	; 0x18
    74be:	18 2f       	mov	r17, r24
    74c0:	1a 95       	dec	r17
    74c2:	f1 f7       	brne	.-4      	; 0x74c0 <FRAMTest3Channel+0x1bc>
    74c4:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    74c6:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <calcChecksumFRAM>

	ADCPower(FALSE);
    74ca:	80 e0       	ldi	r24, 0x00	; 0
    74cc:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	
}
    74d0:	68 96       	adiw	r28, 0x18	; 24
    74d2:	cd bf       	out	0x3d, r28	; 61
    74d4:	de bf       	out	0x3e, r29	; 62
    74d6:	df 91       	pop	r29
    74d8:	cf 91       	pop	r28
    74da:	1f 91       	pop	r17
    74dc:	0f 91       	pop	r16
    74de:	08 95       	ret

000074e0 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {
    74e0:	0f 93       	push	r16
    74e2:	1f 93       	push	r17
    74e4:	cf 93       	push	r28
    74e6:	df 93       	push	r29
    74e8:	cd b7       	in	r28, 0x3d	; 61
    74ea:	de b7       	in	r29, 0x3e	; 62
    74ec:	68 97       	sbiw	r28, 0x18	; 24
    74ee:	cd bf       	out	0x3d, r28	; 61
    74f0:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    74f2:	81 e0       	ldi	r24, 0x01	; 1
    74f4:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
    74f8:	80 e0       	ldi	r24, 0x00	; 0
    74fa:	90 e0       	ldi	r25, 0x00	; 0
    74fc:	aa e7       	ldi	r26, 0x7A	; 122
    74fe:	b3 e4       	ldi	r27, 0x43	; 67
    7500:	89 83       	std	Y+1, r24	; 0x01
    7502:	9a 83       	std	Y+2, r25	; 0x02
    7504:	ab 83       	std	Y+3, r26	; 0x03
    7506:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7508:	69 81       	ldd	r22, Y+1	; 0x01
    750a:	7a 81       	ldd	r23, Y+2	; 0x02
    750c:	8b 81       	ldd	r24, Y+3	; 0x03
    750e:	9c 81       	ldd	r25, Y+4	; 0x04
    7510:	2b ea       	ldi	r18, 0xAB	; 171
    7512:	3a ea       	ldi	r19, 0xAA	; 170
    7514:	4a e2       	ldi	r20, 0x2A	; 42
    7516:	51 e4       	ldi	r21, 0x41	; 65
    7518:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    751c:	dc 01       	movw	r26, r24
    751e:	cb 01       	movw	r24, r22
    7520:	8d 83       	std	Y+5, r24	; 0x05
    7522:	9e 83       	std	Y+6, r25	; 0x06
    7524:	af 83       	std	Y+7, r26	; 0x07
    7526:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7528:	11 e0       	ldi	r17, 0x01	; 1
    752a:	6d 81       	ldd	r22, Y+5	; 0x05
    752c:	7e 81       	ldd	r23, Y+6	; 0x06
    752e:	8f 81       	ldd	r24, Y+7	; 0x07
    7530:	98 85       	ldd	r25, Y+8	; 0x08
    7532:	20 e0       	ldi	r18, 0x00	; 0
    7534:	30 e0       	ldi	r19, 0x00	; 0
    7536:	40 e8       	ldi	r20, 0x80	; 128
    7538:	5f e3       	ldi	r21, 0x3F	; 63
    753a:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    753e:	88 23       	and	r24, r24
    7540:	0c f0       	brlt	.+2      	; 0x7544 <FRAMTest1Channel+0x64>
    7542:	10 e0       	ldi	r17, 0x00	; 0
    7544:	11 23       	and	r17, r17
    7546:	19 f0       	breq	.+6      	; 0x754e <FRAMTest1Channel+0x6e>
		__ticks = 1;
    7548:	81 e0       	ldi	r24, 0x01	; 1
    754a:	89 87       	std	Y+9, r24	; 0x09
    754c:	a3 c0       	rjmp	.+326    	; 0x7694 <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    754e:	11 e0       	ldi	r17, 0x01	; 1
    7550:	6d 81       	ldd	r22, Y+5	; 0x05
    7552:	7e 81       	ldd	r23, Y+6	; 0x06
    7554:	8f 81       	ldd	r24, Y+7	; 0x07
    7556:	98 85       	ldd	r25, Y+8	; 0x08
    7558:	20 e0       	ldi	r18, 0x00	; 0
    755a:	30 e0       	ldi	r19, 0x00	; 0
    755c:	4f e7       	ldi	r20, 0x7F	; 127
    755e:	53 e4       	ldi	r21, 0x43	; 67
    7560:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    7564:	18 16       	cp	r1, r24
    7566:	0c f0       	brlt	.+2      	; 0x756a <FRAMTest1Channel+0x8a>
    7568:	10 e0       	ldi	r17, 0x00	; 0
    756a:	11 23       	and	r17, r17
    756c:	09 f4       	brne	.+2      	; 0x7570 <FRAMTest1Channel+0x90>
    756e:	89 c0       	rjmp	.+274    	; 0x7682 <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    7570:	69 81       	ldd	r22, Y+1	; 0x01
    7572:	7a 81       	ldd	r23, Y+2	; 0x02
    7574:	8b 81       	ldd	r24, Y+3	; 0x03
    7576:	9c 81       	ldd	r25, Y+4	; 0x04
    7578:	20 e0       	ldi	r18, 0x00	; 0
    757a:	30 e0       	ldi	r19, 0x00	; 0
    757c:	4a e7       	ldi	r20, 0x7A	; 122
    757e:	54 e4       	ldi	r21, 0x44	; 68
    7580:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    7584:	dc 01       	movw	r26, r24
    7586:	cb 01       	movw	r24, r22
    7588:	8a 87       	std	Y+10, r24	; 0x0a
    758a:	9b 87       	std	Y+11, r25	; 0x0b
    758c:	ac 87       	std	Y+12, r26	; 0x0c
    758e:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7590:	6a 85       	ldd	r22, Y+10	; 0x0a
    7592:	7b 85       	ldd	r23, Y+11	; 0x0b
    7594:	8c 85       	ldd	r24, Y+12	; 0x0c
    7596:	9d 85       	ldd	r25, Y+13	; 0x0d
    7598:	20 e0       	ldi	r18, 0x00	; 0
    759a:	30 e0       	ldi	r19, 0x00	; 0
    759c:	4a ef       	ldi	r20, 0xFA	; 250
    759e:	55 e4       	ldi	r21, 0x45	; 69
    75a0:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    75a4:	dc 01       	movw	r26, r24
    75a6:	cb 01       	movw	r24, r22
    75a8:	8e 87       	std	Y+14, r24	; 0x0e
    75aa:	9f 87       	std	Y+15, r25	; 0x0f
    75ac:	a8 8b       	std	Y+16, r26	; 0x10
    75ae:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    75b0:	11 e0       	ldi	r17, 0x01	; 1
    75b2:	6e 85       	ldd	r22, Y+14	; 0x0e
    75b4:	7f 85       	ldd	r23, Y+15	; 0x0f
    75b6:	88 89       	ldd	r24, Y+16	; 0x10
    75b8:	99 89       	ldd	r25, Y+17	; 0x11
    75ba:	20 e0       	ldi	r18, 0x00	; 0
    75bc:	30 e0       	ldi	r19, 0x00	; 0
    75be:	40 e8       	ldi	r20, 0x80	; 128
    75c0:	5f e3       	ldi	r21, 0x3F	; 63
    75c2:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    75c6:	88 23       	and	r24, r24
    75c8:	0c f0       	brlt	.+2      	; 0x75cc <FRAMTest1Channel+0xec>
    75ca:	10 e0       	ldi	r17, 0x00	; 0
    75cc:	11 23       	and	r17, r17
    75ce:	29 f0       	breq	.+10     	; 0x75da <FRAMTest1Channel+0xfa>
		__ticks = 1;
    75d0:	81 e0       	ldi	r24, 0x01	; 1
    75d2:	90 e0       	ldi	r25, 0x00	; 0
    75d4:	8a 8b       	std	Y+18, r24	; 0x12
    75d6:	9b 8b       	std	Y+19, r25	; 0x13
    75d8:	46 c0       	rjmp	.+140    	; 0x7666 <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    75da:	11 e0       	ldi	r17, 0x01	; 1
    75dc:	6e 85       	ldd	r22, Y+14	; 0x0e
    75de:	7f 85       	ldd	r23, Y+15	; 0x0f
    75e0:	88 89       	ldd	r24, Y+16	; 0x10
    75e2:	99 89       	ldd	r25, Y+17	; 0x11
    75e4:	20 e0       	ldi	r18, 0x00	; 0
    75e6:	3f ef       	ldi	r19, 0xFF	; 255
    75e8:	4f e7       	ldi	r20, 0x7F	; 127
    75ea:	57 e4       	ldi	r21, 0x47	; 71
    75ec:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    75f0:	18 16       	cp	r1, r24
    75f2:	0c f0       	brlt	.+2      	; 0x75f6 <FRAMTest1Channel+0x116>
    75f4:	10 e0       	ldi	r17, 0x00	; 0
    75f6:	11 23       	and	r17, r17
    75f8:	61 f1       	breq	.+88     	; 0x7652 <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    75fa:	6a 85       	ldd	r22, Y+10	; 0x0a
    75fc:	7b 85       	ldd	r23, Y+11	; 0x0b
    75fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    7600:	9d 85       	ldd	r25, Y+13	; 0x0d
    7602:	20 e0       	ldi	r18, 0x00	; 0
    7604:	30 e0       	ldi	r19, 0x00	; 0
    7606:	40 e2       	ldi	r20, 0x20	; 32
    7608:	51 e4       	ldi	r21, 0x41	; 65
    760a:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    760e:	dc 01       	movw	r26, r24
    7610:	cb 01       	movw	r24, r22
    7612:	bc 01       	movw	r22, r24
    7614:	cd 01       	movw	r24, r26
    7616:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    761a:	dc 01       	movw	r26, r24
    761c:	cb 01       	movw	r24, r22
    761e:	8a 8b       	std	Y+18, r24	; 0x12
    7620:	9b 8b       	std	Y+19, r25	; 0x13
    7622:	12 c0       	rjmp	.+36     	; 0x7648 <FRAMTest1Channel+0x168>
    7624:	80 e2       	ldi	r24, 0x20	; 32
    7626:	93 e0       	ldi	r25, 0x03	; 3
    7628:	8c 8b       	std	Y+20, r24	; 0x14
    762a:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    762c:	8c 89       	ldd	r24, Y+20	; 0x14
    762e:	9d 89       	ldd	r25, Y+21	; 0x15
    7630:	8c 01       	movw	r16, r24
    7632:	c8 01       	movw	r24, r16
    7634:	01 97       	sbiw	r24, 0x01	; 1
    7636:	f1 f7       	brne	.-4      	; 0x7634 <FRAMTest1Channel+0x154>
    7638:	8c 01       	movw	r16, r24
    763a:	0c 8b       	std	Y+20, r16	; 0x14
    763c:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    763e:	8a 89       	ldd	r24, Y+18	; 0x12
    7640:	9b 89       	ldd	r25, Y+19	; 0x13
    7642:	01 97       	sbiw	r24, 0x01	; 1
    7644:	8a 8b       	std	Y+18, r24	; 0x12
    7646:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7648:	8a 89       	ldd	r24, Y+18	; 0x12
    764a:	9b 89       	ldd	r25, Y+19	; 0x13
    764c:	00 97       	sbiw	r24, 0x00	; 0
    764e:	51 f7       	brne	.-44     	; 0x7624 <FRAMTest1Channel+0x144>
    7650:	28 c0       	rjmp	.+80     	; 0x76a2 <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7652:	6e 85       	ldd	r22, Y+14	; 0x0e
    7654:	7f 85       	ldd	r23, Y+15	; 0x0f
    7656:	88 89       	ldd	r24, Y+16	; 0x10
    7658:	99 89       	ldd	r25, Y+17	; 0x11
    765a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    765e:	dc 01       	movw	r26, r24
    7660:	cb 01       	movw	r24, r22
    7662:	8a 8b       	std	Y+18, r24	; 0x12
    7664:	9b 8b       	std	Y+19, r25	; 0x13
    7666:	8a 89       	ldd	r24, Y+18	; 0x12
    7668:	9b 89       	ldd	r25, Y+19	; 0x13
    766a:	8e 8b       	std	Y+22, r24	; 0x16
    766c:	9f 8b       	std	Y+23, r25	; 0x17
    766e:	8e 89       	ldd	r24, Y+22	; 0x16
    7670:	9f 89       	ldd	r25, Y+23	; 0x17
    7672:	8c 01       	movw	r16, r24
    7674:	c8 01       	movw	r24, r16
    7676:	01 97       	sbiw	r24, 0x01	; 1
    7678:	f1 f7       	brne	.-4      	; 0x7676 <FRAMTest1Channel+0x196>
    767a:	8c 01       	movw	r16, r24
    767c:	0e 8b       	std	Y+22, r16	; 0x16
    767e:	1f 8b       	std	Y+23, r17	; 0x17
    7680:	10 c0       	rjmp	.+32     	; 0x76a2 <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7682:	6d 81       	ldd	r22, Y+5	; 0x05
    7684:	7e 81       	ldd	r23, Y+6	; 0x06
    7686:	8f 81       	ldd	r24, Y+7	; 0x07
    7688:	98 85       	ldd	r25, Y+8	; 0x08
    768a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    768e:	dc 01       	movw	r26, r24
    7690:	cb 01       	movw	r24, r22
    7692:	89 87       	std	Y+9, r24	; 0x09
    7694:	89 85       	ldd	r24, Y+9	; 0x09
    7696:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7698:	88 8d       	ldd	r24, Y+24	; 0x18
    769a:	18 2f       	mov	r17, r24
    769c:	1a 95       	dec	r17
    769e:	f1 f7       	brne	.-4      	; 0x769c <FRAMTest1Channel+0x1bc>
    76a0:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    76a2:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <calcChecksumFRAM>

	ADCPower(FALSE);
    76a6:	80 e0       	ldi	r24, 0x00	; 0
    76a8:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>

}
    76ac:	68 96       	adiw	r28, 0x18	; 24
    76ae:	cd bf       	out	0x3d, r28	; 61
    76b0:	de bf       	out	0x3e, r29	; 62
    76b2:	df 91       	pop	r29
    76b4:	cf 91       	pop	r28
    76b6:	1f 91       	pop	r17
    76b8:	0f 91       	pop	r16
    76ba:	08 95       	ret

000076bc <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    76bc:	0f 93       	push	r16
    76be:	1f 93       	push	r17
    76c0:	cf 93       	push	r28
    76c2:	df 93       	push	r29
    76c4:	cd b7       	in	r28, 0x3d	; 61
    76c6:	de b7       	in	r29, 0x3e	; 62
    76c8:	68 97       	sbiw	r28, 0x18	; 24
    76ca:	cd bf       	out	0x3d, r28	; 61
    76cc:	de bf       	out	0x3e, r29	; 62
	
	FRAMWriteKnowns();
    76ce:	0e 94 01 1a 	call	0x3402	; 0x3402 <FRAMWriteKnowns>
	ADCPower(TRUE);
    76d2:	81 e0       	ldi	r24, 0x01	; 1
    76d4:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
    76d8:	80 e0       	ldi	r24, 0x00	; 0
    76da:	90 e0       	ldi	r25, 0x00	; 0
    76dc:	aa e7       	ldi	r26, 0x7A	; 122
    76de:	b3 e4       	ldi	r27, 0x43	; 67
    76e0:	89 83       	std	Y+1, r24	; 0x01
    76e2:	9a 83       	std	Y+2, r25	; 0x02
    76e4:	ab 83       	std	Y+3, r26	; 0x03
    76e6:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    76e8:	69 81       	ldd	r22, Y+1	; 0x01
    76ea:	7a 81       	ldd	r23, Y+2	; 0x02
    76ec:	8b 81       	ldd	r24, Y+3	; 0x03
    76ee:	9c 81       	ldd	r25, Y+4	; 0x04
    76f0:	2b ea       	ldi	r18, 0xAB	; 171
    76f2:	3a ea       	ldi	r19, 0xAA	; 170
    76f4:	4a e2       	ldi	r20, 0x2A	; 42
    76f6:	51 e4       	ldi	r21, 0x41	; 65
    76f8:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    76fc:	dc 01       	movw	r26, r24
    76fe:	cb 01       	movw	r24, r22
    7700:	8d 83       	std	Y+5, r24	; 0x05
    7702:	9e 83       	std	Y+6, r25	; 0x06
    7704:	af 83       	std	Y+7, r26	; 0x07
    7706:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7708:	11 e0       	ldi	r17, 0x01	; 1
    770a:	6d 81       	ldd	r22, Y+5	; 0x05
    770c:	7e 81       	ldd	r23, Y+6	; 0x06
    770e:	8f 81       	ldd	r24, Y+7	; 0x07
    7710:	98 85       	ldd	r25, Y+8	; 0x08
    7712:	20 e0       	ldi	r18, 0x00	; 0
    7714:	30 e0       	ldi	r19, 0x00	; 0
    7716:	40 e8       	ldi	r20, 0x80	; 128
    7718:	5f e3       	ldi	r21, 0x3F	; 63
    771a:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    771e:	88 23       	and	r24, r24
    7720:	0c f0       	brlt	.+2      	; 0x7724 <FRAMWriteKnownsCheck+0x68>
    7722:	10 e0       	ldi	r17, 0x00	; 0
    7724:	11 23       	and	r17, r17
    7726:	19 f0       	breq	.+6      	; 0x772e <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    7728:	81 e0       	ldi	r24, 0x01	; 1
    772a:	89 87       	std	Y+9, r24	; 0x09
    772c:	a3 c0       	rjmp	.+326    	; 0x7874 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    772e:	11 e0       	ldi	r17, 0x01	; 1
    7730:	6d 81       	ldd	r22, Y+5	; 0x05
    7732:	7e 81       	ldd	r23, Y+6	; 0x06
    7734:	8f 81       	ldd	r24, Y+7	; 0x07
    7736:	98 85       	ldd	r25, Y+8	; 0x08
    7738:	20 e0       	ldi	r18, 0x00	; 0
    773a:	30 e0       	ldi	r19, 0x00	; 0
    773c:	4f e7       	ldi	r20, 0x7F	; 127
    773e:	53 e4       	ldi	r21, 0x43	; 67
    7740:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    7744:	18 16       	cp	r1, r24
    7746:	0c f0       	brlt	.+2      	; 0x774a <FRAMWriteKnownsCheck+0x8e>
    7748:	10 e0       	ldi	r17, 0x00	; 0
    774a:	11 23       	and	r17, r17
    774c:	09 f4       	brne	.+2      	; 0x7750 <FRAMWriteKnownsCheck+0x94>
    774e:	89 c0       	rjmp	.+274    	; 0x7862 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7750:	69 81       	ldd	r22, Y+1	; 0x01
    7752:	7a 81       	ldd	r23, Y+2	; 0x02
    7754:	8b 81       	ldd	r24, Y+3	; 0x03
    7756:	9c 81       	ldd	r25, Y+4	; 0x04
    7758:	20 e0       	ldi	r18, 0x00	; 0
    775a:	30 e0       	ldi	r19, 0x00	; 0
    775c:	4a e7       	ldi	r20, 0x7A	; 122
    775e:	54 e4       	ldi	r21, 0x44	; 68
    7760:	0e 94 cd 5b 	call	0xb79a	; 0xb79a <__divsf3>
    7764:	dc 01       	movw	r26, r24
    7766:	cb 01       	movw	r24, r22
    7768:	8a 87       	std	Y+10, r24	; 0x0a
    776a:	9b 87       	std	Y+11, r25	; 0x0b
    776c:	ac 87       	std	Y+12, r26	; 0x0c
    776e:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7770:	6a 85       	ldd	r22, Y+10	; 0x0a
    7772:	7b 85       	ldd	r23, Y+11	; 0x0b
    7774:	8c 85       	ldd	r24, Y+12	; 0x0c
    7776:	9d 85       	ldd	r25, Y+13	; 0x0d
    7778:	20 e0       	ldi	r18, 0x00	; 0
    777a:	30 e0       	ldi	r19, 0x00	; 0
    777c:	4a ef       	ldi	r20, 0xFA	; 250
    777e:	55 e4       	ldi	r21, 0x45	; 69
    7780:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    7784:	dc 01       	movw	r26, r24
    7786:	cb 01       	movw	r24, r22
    7788:	8e 87       	std	Y+14, r24	; 0x0e
    778a:	9f 87       	std	Y+15, r25	; 0x0f
    778c:	a8 8b       	std	Y+16, r26	; 0x10
    778e:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7790:	11 e0       	ldi	r17, 0x01	; 1
    7792:	6e 85       	ldd	r22, Y+14	; 0x0e
    7794:	7f 85       	ldd	r23, Y+15	; 0x0f
    7796:	88 89       	ldd	r24, Y+16	; 0x10
    7798:	99 89       	ldd	r25, Y+17	; 0x11
    779a:	20 e0       	ldi	r18, 0x00	; 0
    779c:	30 e0       	ldi	r19, 0x00	; 0
    779e:	40 e8       	ldi	r20, 0x80	; 128
    77a0:	5f e3       	ldi	r21, 0x3F	; 63
    77a2:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    77a6:	88 23       	and	r24, r24
    77a8:	0c f0       	brlt	.+2      	; 0x77ac <FRAMWriteKnownsCheck+0xf0>
    77aa:	10 e0       	ldi	r17, 0x00	; 0
    77ac:	11 23       	and	r17, r17
    77ae:	29 f0       	breq	.+10     	; 0x77ba <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    77b0:	81 e0       	ldi	r24, 0x01	; 1
    77b2:	90 e0       	ldi	r25, 0x00	; 0
    77b4:	8a 8b       	std	Y+18, r24	; 0x12
    77b6:	9b 8b       	std	Y+19, r25	; 0x13
    77b8:	46 c0       	rjmp	.+140    	; 0x7846 <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    77ba:	11 e0       	ldi	r17, 0x01	; 1
    77bc:	6e 85       	ldd	r22, Y+14	; 0x0e
    77be:	7f 85       	ldd	r23, Y+15	; 0x0f
    77c0:	88 89       	ldd	r24, Y+16	; 0x10
    77c2:	99 89       	ldd	r25, Y+17	; 0x11
    77c4:	20 e0       	ldi	r18, 0x00	; 0
    77c6:	3f ef       	ldi	r19, 0xFF	; 255
    77c8:	4f e7       	ldi	r20, 0x7F	; 127
    77ca:	57 e4       	ldi	r21, 0x47	; 71
    77cc:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    77d0:	18 16       	cp	r1, r24
    77d2:	0c f0       	brlt	.+2      	; 0x77d6 <FRAMWriteKnownsCheck+0x11a>
    77d4:	10 e0       	ldi	r17, 0x00	; 0
    77d6:	11 23       	and	r17, r17
    77d8:	61 f1       	breq	.+88     	; 0x7832 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    77da:	6a 85       	ldd	r22, Y+10	; 0x0a
    77dc:	7b 85       	ldd	r23, Y+11	; 0x0b
    77de:	8c 85       	ldd	r24, Y+12	; 0x0c
    77e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    77e2:	20 e0       	ldi	r18, 0x00	; 0
    77e4:	30 e0       	ldi	r19, 0x00	; 0
    77e6:	40 e2       	ldi	r20, 0x20	; 32
    77e8:	51 e4       	ldi	r21, 0x41	; 65
    77ea:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    77ee:	dc 01       	movw	r26, r24
    77f0:	cb 01       	movw	r24, r22
    77f2:	bc 01       	movw	r22, r24
    77f4:	cd 01       	movw	r24, r26
    77f6:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    77fa:	dc 01       	movw	r26, r24
    77fc:	cb 01       	movw	r24, r22
    77fe:	8a 8b       	std	Y+18, r24	; 0x12
    7800:	9b 8b       	std	Y+19, r25	; 0x13
    7802:	12 c0       	rjmp	.+36     	; 0x7828 <FRAMWriteKnownsCheck+0x16c>
    7804:	80 e2       	ldi	r24, 0x20	; 32
    7806:	93 e0       	ldi	r25, 0x03	; 3
    7808:	8c 8b       	std	Y+20, r24	; 0x14
    780a:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    780c:	8c 89       	ldd	r24, Y+20	; 0x14
    780e:	9d 89       	ldd	r25, Y+21	; 0x15
    7810:	8c 01       	movw	r16, r24
    7812:	c8 01       	movw	r24, r16
    7814:	01 97       	sbiw	r24, 0x01	; 1
    7816:	f1 f7       	brne	.-4      	; 0x7814 <FRAMWriteKnownsCheck+0x158>
    7818:	8c 01       	movw	r16, r24
    781a:	0c 8b       	std	Y+20, r16	; 0x14
    781c:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    781e:	8a 89       	ldd	r24, Y+18	; 0x12
    7820:	9b 89       	ldd	r25, Y+19	; 0x13
    7822:	01 97       	sbiw	r24, 0x01	; 1
    7824:	8a 8b       	std	Y+18, r24	; 0x12
    7826:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7828:	8a 89       	ldd	r24, Y+18	; 0x12
    782a:	9b 89       	ldd	r25, Y+19	; 0x13
    782c:	00 97       	sbiw	r24, 0x00	; 0
    782e:	51 f7       	brne	.-44     	; 0x7804 <FRAMWriteKnownsCheck+0x148>
    7830:	28 c0       	rjmp	.+80     	; 0x7882 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7832:	6e 85       	ldd	r22, Y+14	; 0x0e
    7834:	7f 85       	ldd	r23, Y+15	; 0x0f
    7836:	88 89       	ldd	r24, Y+16	; 0x10
    7838:	99 89       	ldd	r25, Y+17	; 0x11
    783a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    783e:	dc 01       	movw	r26, r24
    7840:	cb 01       	movw	r24, r22
    7842:	8a 8b       	std	Y+18, r24	; 0x12
    7844:	9b 8b       	std	Y+19, r25	; 0x13
    7846:	8a 89       	ldd	r24, Y+18	; 0x12
    7848:	9b 89       	ldd	r25, Y+19	; 0x13
    784a:	8e 8b       	std	Y+22, r24	; 0x16
    784c:	9f 8b       	std	Y+23, r25	; 0x17
    784e:	8e 89       	ldd	r24, Y+22	; 0x16
    7850:	9f 89       	ldd	r25, Y+23	; 0x17
    7852:	8c 01       	movw	r16, r24
    7854:	c8 01       	movw	r24, r16
    7856:	01 97       	sbiw	r24, 0x01	; 1
    7858:	f1 f7       	brne	.-4      	; 0x7856 <FRAMWriteKnownsCheck+0x19a>
    785a:	8c 01       	movw	r16, r24
    785c:	0e 8b       	std	Y+22, r16	; 0x16
    785e:	1f 8b       	std	Y+23, r17	; 0x17
    7860:	10 c0       	rjmp	.+32     	; 0x7882 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7862:	6d 81       	ldd	r22, Y+5	; 0x05
    7864:	7e 81       	ldd	r23, Y+6	; 0x06
    7866:	8f 81       	ldd	r24, Y+7	; 0x07
    7868:	98 85       	ldd	r25, Y+8	; 0x08
    786a:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    786e:	dc 01       	movw	r26, r24
    7870:	cb 01       	movw	r24, r22
    7872:	89 87       	std	Y+9, r24	; 0x09
    7874:	89 85       	ldd	r24, Y+9	; 0x09
    7876:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7878:	88 8d       	ldd	r24, Y+24	; 0x18
    787a:	18 2f       	mov	r17, r24
    787c:	1a 95       	dec	r17
    787e:	f1 f7       	brne	.-4      	; 0x787c <FRAMWriteKnownsCheck+0x1c0>
    7880:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7882:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <calcChecksumFRAM>

	ADCPower(FALSE);
    7886:	80 e0       	ldi	r24, 0x00	; 0
    7888:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>

}
    788c:	68 96       	adiw	r28, 0x18	; 24
    788e:	cd bf       	out	0x3d, r28	; 61
    7890:	de bf       	out	0x3e, r29	; 62
    7892:	df 91       	pop	r29
    7894:	cf 91       	pop	r28
    7896:	1f 91       	pop	r17
    7898:	0f 91       	pop	r16
    789a:	08 95       	ret

0000789c <checkMote>:

//random function for testing stuff	
void checkMote(){
    789c:	0f 93       	push	r16
    789e:	1f 93       	push	r17
    78a0:	cf 93       	push	r28
    78a2:	df 93       	push	r29
    78a4:	cd b7       	in	r28, 0x3d	; 61
    78a6:	de b7       	in	r29, 0x3e	; 62
    78a8:	aa 97       	sbiw	r28, 0x2a	; 42
    78aa:	cd bf       	out	0x3d, r28	; 61
    78ac:	de bf       	out	0x3e, r29	; 62
	
	ADCPower(TRUE);
    78ae:	81 e0       	ldi	r24, 0x01	; 1
    78b0:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	Ext1Power(TRUE);
    78b4:	81 e0       	ldi	r24, 0x01	; 1
    78b6:	0e 94 6d 35 	call	0x6ada	; 0x6ada <Ext1Power>
    78ba:	80 e0       	ldi	r24, 0x00	; 0
    78bc:	90 e0       	ldi	r25, 0x00	; 0
    78be:	a8 ec       	ldi	r26, 0xC8	; 200
    78c0:	b2 e4       	ldi	r27, 0x42	; 66
    78c2:	89 83       	std	Y+1, r24	; 0x01
    78c4:	9a 83       	std	Y+2, r25	; 0x02
    78c6:	ab 83       	std	Y+3, r26	; 0x03
    78c8:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    78ca:	69 81       	ldd	r22, Y+1	; 0x01
    78cc:	7a 81       	ldd	r23, Y+2	; 0x02
    78ce:	8b 81       	ldd	r24, Y+3	; 0x03
    78d0:	9c 81       	ldd	r25, Y+4	; 0x04
    78d2:	20 e0       	ldi	r18, 0x00	; 0
    78d4:	30 e0       	ldi	r19, 0x00	; 0
    78d6:	4a ef       	ldi	r20, 0xFA	; 250
    78d8:	55 e4       	ldi	r21, 0x45	; 69
    78da:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    78de:	dc 01       	movw	r26, r24
    78e0:	cb 01       	movw	r24, r22
    78e2:	8d 83       	std	Y+5, r24	; 0x05
    78e4:	9e 83       	std	Y+6, r25	; 0x06
    78e6:	af 83       	std	Y+7, r26	; 0x07
    78e8:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    78ea:	11 e0       	ldi	r17, 0x01	; 1
    78ec:	6d 81       	ldd	r22, Y+5	; 0x05
    78ee:	7e 81       	ldd	r23, Y+6	; 0x06
    78f0:	8f 81       	ldd	r24, Y+7	; 0x07
    78f2:	98 85       	ldd	r25, Y+8	; 0x08
    78f4:	20 e0       	ldi	r18, 0x00	; 0
    78f6:	30 e0       	ldi	r19, 0x00	; 0
    78f8:	40 e8       	ldi	r20, 0x80	; 128
    78fa:	5f e3       	ldi	r21, 0x3F	; 63
    78fc:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    7900:	88 23       	and	r24, r24
    7902:	0c f0       	brlt	.+2      	; 0x7906 <checkMote+0x6a>
    7904:	10 e0       	ldi	r17, 0x00	; 0
    7906:	11 23       	and	r17, r17
    7908:	29 f0       	breq	.+10     	; 0x7914 <checkMote+0x78>
		__ticks = 1;
    790a:	81 e0       	ldi	r24, 0x01	; 1
    790c:	90 e0       	ldi	r25, 0x00	; 0
    790e:	89 87       	std	Y+9, r24	; 0x09
    7910:	9a 87       	std	Y+10, r25	; 0x0a
    7912:	46 c0       	rjmp	.+140    	; 0x79a0 <checkMote+0x104>
	else if (__tmp > 65535)
    7914:	11 e0       	ldi	r17, 0x01	; 1
    7916:	6d 81       	ldd	r22, Y+5	; 0x05
    7918:	7e 81       	ldd	r23, Y+6	; 0x06
    791a:	8f 81       	ldd	r24, Y+7	; 0x07
    791c:	98 85       	ldd	r25, Y+8	; 0x08
    791e:	20 e0       	ldi	r18, 0x00	; 0
    7920:	3f ef       	ldi	r19, 0xFF	; 255
    7922:	4f e7       	ldi	r20, 0x7F	; 127
    7924:	57 e4       	ldi	r21, 0x47	; 71
    7926:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    792a:	18 16       	cp	r1, r24
    792c:	0c f0       	brlt	.+2      	; 0x7930 <checkMote+0x94>
    792e:	10 e0       	ldi	r17, 0x00	; 0
    7930:	11 23       	and	r17, r17
    7932:	61 f1       	breq	.+88     	; 0x798c <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7934:	69 81       	ldd	r22, Y+1	; 0x01
    7936:	7a 81       	ldd	r23, Y+2	; 0x02
    7938:	8b 81       	ldd	r24, Y+3	; 0x03
    793a:	9c 81       	ldd	r25, Y+4	; 0x04
    793c:	20 e0       	ldi	r18, 0x00	; 0
    793e:	30 e0       	ldi	r19, 0x00	; 0
    7940:	40 e2       	ldi	r20, 0x20	; 32
    7942:	51 e4       	ldi	r21, 0x41	; 65
    7944:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    7948:	dc 01       	movw	r26, r24
    794a:	cb 01       	movw	r24, r22
    794c:	bc 01       	movw	r22, r24
    794e:	cd 01       	movw	r24, r26
    7950:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7954:	dc 01       	movw	r26, r24
    7956:	cb 01       	movw	r24, r22
    7958:	89 87       	std	Y+9, r24	; 0x09
    795a:	9a 87       	std	Y+10, r25	; 0x0a
    795c:	12 c0       	rjmp	.+36     	; 0x7982 <checkMote+0xe6>
    795e:	80 e2       	ldi	r24, 0x20	; 32
    7960:	93 e0       	ldi	r25, 0x03	; 3
    7962:	8b 87       	std	Y+11, r24	; 0x0b
    7964:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7966:	8b 85       	ldd	r24, Y+11	; 0x0b
    7968:	9c 85       	ldd	r25, Y+12	; 0x0c
    796a:	8c 01       	movw	r16, r24
    796c:	c8 01       	movw	r24, r16
    796e:	01 97       	sbiw	r24, 0x01	; 1
    7970:	f1 f7       	brne	.-4      	; 0x796e <checkMote+0xd2>
    7972:	8c 01       	movw	r16, r24
    7974:	0b 87       	std	Y+11, r16	; 0x0b
    7976:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7978:	89 85       	ldd	r24, Y+9	; 0x09
    797a:	9a 85       	ldd	r25, Y+10	; 0x0a
    797c:	01 97       	sbiw	r24, 0x01	; 1
    797e:	89 87       	std	Y+9, r24	; 0x09
    7980:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7982:	89 85       	ldd	r24, Y+9	; 0x09
    7984:	9a 85       	ldd	r25, Y+10	; 0x0a
    7986:	00 97       	sbiw	r24, 0x00	; 0
    7988:	51 f7       	brne	.-44     	; 0x795e <checkMote+0xc2>
    798a:	17 c0       	rjmp	.+46     	; 0x79ba <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    798c:	6d 81       	ldd	r22, Y+5	; 0x05
    798e:	7e 81       	ldd	r23, Y+6	; 0x06
    7990:	8f 81       	ldd	r24, Y+7	; 0x07
    7992:	98 85       	ldd	r25, Y+8	; 0x08
    7994:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7998:	dc 01       	movw	r26, r24
    799a:	cb 01       	movw	r24, r22
    799c:	89 87       	std	Y+9, r24	; 0x09
    799e:	9a 87       	std	Y+10, r25	; 0x0a
    79a0:	89 85       	ldd	r24, Y+9	; 0x09
    79a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    79a4:	8d 87       	std	Y+13, r24	; 0x0d
    79a6:	9e 87       	std	Y+14, r25	; 0x0e
    79a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    79aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    79ac:	8c 01       	movw	r16, r24
    79ae:	c8 01       	movw	r24, r16
    79b0:	01 97       	sbiw	r24, 0x01	; 1
    79b2:	f1 f7       	brne	.-4      	; 0x79b0 <checkMote+0x114>
    79b4:	8c 01       	movw	r16, r24
    79b6:	0d 87       	std	Y+13, r16	; 0x0d
    79b8:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    79ba:	88 e0       	ldi	r24, 0x08	; 8
    79bc:	60 e0       	ldi	r22, 0x00	; 0
    79be:	0e 94 d7 33 	call	0x67ae	; 0x67ae <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    79c2:	88 e0       	ldi	r24, 0x08	; 8
    79c4:	60 e0       	ldi	r22, 0x00	; 0
    79c6:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
    79ca:	80 e0       	ldi	r24, 0x00	; 0
    79cc:	90 e4       	ldi	r25, 0x40	; 64
    79ce:	ac e9       	ldi	r26, 0x9C	; 156
    79d0:	b5 e4       	ldi	r27, 0x45	; 69
    79d2:	8f 87       	std	Y+15, r24	; 0x0f
    79d4:	98 8b       	std	Y+16, r25	; 0x10
    79d6:	a9 8b       	std	Y+17, r26	; 0x11
    79d8:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    79da:	6f 85       	ldd	r22, Y+15	; 0x0f
    79dc:	78 89       	ldd	r23, Y+16	; 0x10
    79de:	89 89       	ldd	r24, Y+17	; 0x11
    79e0:	9a 89       	ldd	r25, Y+18	; 0x12
    79e2:	20 e0       	ldi	r18, 0x00	; 0
    79e4:	30 e0       	ldi	r19, 0x00	; 0
    79e6:	4a ef       	ldi	r20, 0xFA	; 250
    79e8:	55 e4       	ldi	r21, 0x45	; 69
    79ea:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    79ee:	dc 01       	movw	r26, r24
    79f0:	cb 01       	movw	r24, r22
    79f2:	8b 8b       	std	Y+19, r24	; 0x13
    79f4:	9c 8b       	std	Y+20, r25	; 0x14
    79f6:	ad 8b       	std	Y+21, r26	; 0x15
    79f8:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    79fa:	11 e0       	ldi	r17, 0x01	; 1
    79fc:	6b 89       	ldd	r22, Y+19	; 0x13
    79fe:	7c 89       	ldd	r23, Y+20	; 0x14
    7a00:	8d 89       	ldd	r24, Y+21	; 0x15
    7a02:	9e 89       	ldd	r25, Y+22	; 0x16
    7a04:	20 e0       	ldi	r18, 0x00	; 0
    7a06:	30 e0       	ldi	r19, 0x00	; 0
    7a08:	40 e8       	ldi	r20, 0x80	; 128
    7a0a:	5f e3       	ldi	r21, 0x3F	; 63
    7a0c:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    7a10:	88 23       	and	r24, r24
    7a12:	0c f0       	brlt	.+2      	; 0x7a16 <checkMote+0x17a>
    7a14:	10 e0       	ldi	r17, 0x00	; 0
    7a16:	11 23       	and	r17, r17
    7a18:	29 f0       	breq	.+10     	; 0x7a24 <checkMote+0x188>
		__ticks = 1;
    7a1a:	81 e0       	ldi	r24, 0x01	; 1
    7a1c:	90 e0       	ldi	r25, 0x00	; 0
    7a1e:	8f 8b       	std	Y+23, r24	; 0x17
    7a20:	98 8f       	std	Y+24, r25	; 0x18
    7a22:	46 c0       	rjmp	.+140    	; 0x7ab0 <checkMote+0x214>
	else if (__tmp > 65535)
    7a24:	11 e0       	ldi	r17, 0x01	; 1
    7a26:	6b 89       	ldd	r22, Y+19	; 0x13
    7a28:	7c 89       	ldd	r23, Y+20	; 0x14
    7a2a:	8d 89       	ldd	r24, Y+21	; 0x15
    7a2c:	9e 89       	ldd	r25, Y+22	; 0x16
    7a2e:	20 e0       	ldi	r18, 0x00	; 0
    7a30:	3f ef       	ldi	r19, 0xFF	; 255
    7a32:	4f e7       	ldi	r20, 0x7F	; 127
    7a34:	57 e4       	ldi	r21, 0x47	; 71
    7a36:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    7a3a:	18 16       	cp	r1, r24
    7a3c:	0c f0       	brlt	.+2      	; 0x7a40 <checkMote+0x1a4>
    7a3e:	10 e0       	ldi	r17, 0x00	; 0
    7a40:	11 23       	and	r17, r17
    7a42:	61 f1       	breq	.+88     	; 0x7a9c <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7a44:	6f 85       	ldd	r22, Y+15	; 0x0f
    7a46:	78 89       	ldd	r23, Y+16	; 0x10
    7a48:	89 89       	ldd	r24, Y+17	; 0x11
    7a4a:	9a 89       	ldd	r25, Y+18	; 0x12
    7a4c:	20 e0       	ldi	r18, 0x00	; 0
    7a4e:	30 e0       	ldi	r19, 0x00	; 0
    7a50:	40 e2       	ldi	r20, 0x20	; 32
    7a52:	51 e4       	ldi	r21, 0x41	; 65
    7a54:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    7a58:	dc 01       	movw	r26, r24
    7a5a:	cb 01       	movw	r24, r22
    7a5c:	bc 01       	movw	r22, r24
    7a5e:	cd 01       	movw	r24, r26
    7a60:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7a64:	dc 01       	movw	r26, r24
    7a66:	cb 01       	movw	r24, r22
    7a68:	8f 8b       	std	Y+23, r24	; 0x17
    7a6a:	98 8f       	std	Y+24, r25	; 0x18
    7a6c:	12 c0       	rjmp	.+36     	; 0x7a92 <checkMote+0x1f6>
    7a6e:	80 e2       	ldi	r24, 0x20	; 32
    7a70:	93 e0       	ldi	r25, 0x03	; 3
    7a72:	89 8f       	std	Y+25, r24	; 0x19
    7a74:	9a 8f       	std	Y+26, r25	; 0x1a
    7a76:	89 8d       	ldd	r24, Y+25	; 0x19
    7a78:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7a7a:	8c 01       	movw	r16, r24
    7a7c:	c8 01       	movw	r24, r16
    7a7e:	01 97       	sbiw	r24, 0x01	; 1
    7a80:	f1 f7       	brne	.-4      	; 0x7a7e <checkMote+0x1e2>
    7a82:	8c 01       	movw	r16, r24
    7a84:	09 8f       	std	Y+25, r16	; 0x19
    7a86:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7a88:	8f 89       	ldd	r24, Y+23	; 0x17
    7a8a:	98 8d       	ldd	r25, Y+24	; 0x18
    7a8c:	01 97       	sbiw	r24, 0x01	; 1
    7a8e:	8f 8b       	std	Y+23, r24	; 0x17
    7a90:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7a92:	8f 89       	ldd	r24, Y+23	; 0x17
    7a94:	98 8d       	ldd	r25, Y+24	; 0x18
    7a96:	00 97       	sbiw	r24, 0x00	; 0
    7a98:	51 f7       	brne	.-44     	; 0x7a6e <checkMote+0x1d2>
    7a9a:	17 c0       	rjmp	.+46     	; 0x7aca <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7a9c:	6b 89       	ldd	r22, Y+19	; 0x13
    7a9e:	7c 89       	ldd	r23, Y+20	; 0x14
    7aa0:	8d 89       	ldd	r24, Y+21	; 0x15
    7aa2:	9e 89       	ldd	r25, Y+22	; 0x16
    7aa4:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7aa8:	dc 01       	movw	r26, r24
    7aaa:	cb 01       	movw	r24, r22
    7aac:	8f 8b       	std	Y+23, r24	; 0x17
    7aae:	98 8f       	std	Y+24, r25	; 0x18
    7ab0:	8f 89       	ldd	r24, Y+23	; 0x17
    7ab2:	98 8d       	ldd	r25, Y+24	; 0x18
    7ab4:	8b 8f       	std	Y+27, r24	; 0x1b
    7ab6:	9c 8f       	std	Y+28, r25	; 0x1c
    7ab8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7aba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7abc:	8c 01       	movw	r16, r24
    7abe:	c8 01       	movw	r24, r16
    7ac0:	01 97       	sbiw	r24, 0x01	; 1
    7ac2:	f1 f7       	brne	.-4      	; 0x7ac0 <checkMote+0x224>
    7ac4:	8c 01       	movw	r16, r24
    7ac6:	0b 8f       	std	Y+27, r16	; 0x1b
    7ac8:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7aca:	88 e0       	ldi	r24, 0x08	; 8
    7acc:	60 e0       	ldi	r22, 0x00	; 0
    7ace:	0e 94 06 35 	call	0x6a0c	; 0x6a0c <PortEx_OUTCLR>
    7ad2:	80 e0       	ldi	r24, 0x00	; 0
    7ad4:	90 e4       	ldi	r25, 0x40	; 64
    7ad6:	ac e9       	ldi	r26, 0x9C	; 156
    7ad8:	b5 e4       	ldi	r27, 0x45	; 69
    7ada:	8d 8f       	std	Y+29, r24	; 0x1d
    7adc:	9e 8f       	std	Y+30, r25	; 0x1e
    7ade:	af 8f       	std	Y+31, r26	; 0x1f
    7ae0:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7ae2:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7ae4:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7ae6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7ae8:	98 a1       	lds	r25, 0x48
    7aea:	20 e0       	ldi	r18, 0x00	; 0
    7aec:	30 e0       	ldi	r19, 0x00	; 0
    7aee:	4a ef       	ldi	r20, 0xFA	; 250
    7af0:	55 e4       	ldi	r21, 0x45	; 69
    7af2:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    7af6:	dc 01       	movw	r26, r24
    7af8:	cb 01       	movw	r24, r22
    7afa:	89 a3       	lds	r24, 0x59
    7afc:	9a a3       	lds	r25, 0x5a
    7afe:	ab a3       	lds	r26, 0x5b
    7b00:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7b02:	11 e0       	ldi	r17, 0x01	; 1
    7b04:	69 a1       	lds	r22, 0x49
    7b06:	7a a1       	lds	r23, 0x4a
    7b08:	8b a1       	lds	r24, 0x4b
    7b0a:	9c a1       	lds	r25, 0x4c
    7b0c:	20 e0       	ldi	r18, 0x00	; 0
    7b0e:	30 e0       	ldi	r19, 0x00	; 0
    7b10:	40 e8       	ldi	r20, 0x80	; 128
    7b12:	5f e3       	ldi	r21, 0x3F	; 63
    7b14:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    7b18:	88 23       	and	r24, r24
    7b1a:	0c f0       	brlt	.+2      	; 0x7b1e <checkMote+0x282>
    7b1c:	10 e0       	ldi	r17, 0x00	; 0
    7b1e:	11 23       	and	r17, r17
    7b20:	29 f0       	breq	.+10     	; 0x7b2c <checkMote+0x290>
		__ticks = 1;
    7b22:	81 e0       	ldi	r24, 0x01	; 1
    7b24:	90 e0       	ldi	r25, 0x00	; 0
    7b26:	8d a3       	lds	r24, 0x5d
    7b28:	9e a3       	lds	r25, 0x5e
    7b2a:	46 c0       	rjmp	.+140    	; 0x7bb8 <checkMote+0x31c>
	else if (__tmp > 65535)
    7b2c:	11 e0       	ldi	r17, 0x01	; 1
    7b2e:	69 a1       	lds	r22, 0x49
    7b30:	7a a1       	lds	r23, 0x4a
    7b32:	8b a1       	lds	r24, 0x4b
    7b34:	9c a1       	lds	r25, 0x4c
    7b36:	20 e0       	ldi	r18, 0x00	; 0
    7b38:	3f ef       	ldi	r19, 0xFF	; 255
    7b3a:	4f e7       	ldi	r20, 0x7F	; 127
    7b3c:	57 e4       	ldi	r21, 0x47	; 71
    7b3e:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    7b42:	18 16       	cp	r1, r24
    7b44:	0c f0       	brlt	.+2      	; 0x7b48 <checkMote+0x2ac>
    7b46:	10 e0       	ldi	r17, 0x00	; 0
    7b48:	11 23       	and	r17, r17
    7b4a:	61 f1       	breq	.+88     	; 0x7ba4 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7b4c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7b4e:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7b50:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7b52:	98 a1       	lds	r25, 0x48
    7b54:	20 e0       	ldi	r18, 0x00	; 0
    7b56:	30 e0       	ldi	r19, 0x00	; 0
    7b58:	40 e2       	ldi	r20, 0x20	; 32
    7b5a:	51 e4       	ldi	r21, 0x41	; 65
    7b5c:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    7b60:	dc 01       	movw	r26, r24
    7b62:	cb 01       	movw	r24, r22
    7b64:	bc 01       	movw	r22, r24
    7b66:	cd 01       	movw	r24, r26
    7b68:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7b6c:	dc 01       	movw	r26, r24
    7b6e:	cb 01       	movw	r24, r22
    7b70:	8d a3       	lds	r24, 0x5d
    7b72:	9e a3       	lds	r25, 0x5e
    7b74:	12 c0       	rjmp	.+36     	; 0x7b9a <checkMote+0x2fe>
    7b76:	80 e2       	ldi	r24, 0x20	; 32
    7b78:	93 e0       	ldi	r25, 0x03	; 3
    7b7a:	8f a3       	lds	r24, 0x5f
    7b7c:	98 a7       	lds	r25, 0x78
    7b7e:	8f a1       	lds	r24, 0x4f
    7b80:	98 a5       	lds	r25, 0x68
    7b82:	8c 01       	movw	r16, r24
    7b84:	c8 01       	movw	r24, r16
    7b86:	01 97       	sbiw	r24, 0x01	; 1
    7b88:	f1 f7       	brne	.-4      	; 0x7b86 <checkMote+0x2ea>
    7b8a:	8c 01       	movw	r16, r24
    7b8c:	0f a3       	lds	r16, 0x5f
    7b8e:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b90:	8d a1       	lds	r24, 0x4d
    7b92:	9e a1       	lds	r25, 0x4e
    7b94:	01 97       	sbiw	r24, 0x01	; 1
    7b96:	8d a3       	lds	r24, 0x5d
    7b98:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b9a:	8d a1       	lds	r24, 0x4d
    7b9c:	9e a1       	lds	r25, 0x4e
    7b9e:	00 97       	sbiw	r24, 0x00	; 0
    7ba0:	51 f7       	brne	.-44     	; 0x7b76 <checkMote+0x2da>
    7ba2:	18 c0       	rjmp	.+48     	; 0x7bd4 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ba4:	69 a1       	lds	r22, 0x49
    7ba6:	7a a1       	lds	r23, 0x4a
    7ba8:	8b a1       	lds	r24, 0x4b
    7baa:	9c a1       	lds	r25, 0x4c
    7bac:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    7bb0:	dc 01       	movw	r26, r24
    7bb2:	cb 01       	movw	r24, r22
    7bb4:	8d a3       	lds	r24, 0x5d
    7bb6:	9e a3       	lds	r25, 0x5e
    7bb8:	8d a1       	lds	r24, 0x4d
    7bba:	9e a1       	lds	r25, 0x4e
    7bbc:	89 a7       	lds	r24, 0x79
    7bbe:	9a a7       	lds	r25, 0x7a
    7bc0:	89 a5       	lds	r24, 0x69
    7bc2:	9a a5       	lds	r25, 0x6a
    7bc4:	8c 01       	movw	r16, r24
    7bc6:	c8 01       	movw	r24, r16
    7bc8:	01 97       	sbiw	r24, 0x01	; 1
    7bca:	f1 f7       	brne	.-4      	; 0x7bc8 <checkMote+0x32c>
    7bcc:	8c 01       	movw	r16, r24
    7bce:	09 a7       	lds	r16, 0x79
    7bd0:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7bd2:	f7 ce       	rjmp	.-530    	; 0x79c2 <checkMote+0x126>
    7bd4:	f6 ce       	rjmp	.-532    	; 0x79c2 <checkMote+0x126>

00007bd6 <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7bd6:	cf 93       	push	r28
    7bd8:	df 93       	push	r29
    7bda:	cd b7       	in	r28, 0x3d	; 61
    7bdc:	de b7       	in	r29, 0x3e	; 62
    7bde:	28 97       	sbiw	r28, 0x08	; 8
    7be0:	cd bf       	out	0x3d, r28	; 61
    7be2:	de bf       	out	0x3e, r29	; 62
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7be4:	19 82       	std	Y+1, r1	; 0x01
    7be6:	1a 82       	std	Y+2, r1	; 0x02
    7be8:	0c c0       	rjmp	.+24     	; 0x7c02 <SD_write_and_read_knowns+0x2c>
    7bea:	29 81       	ldd	r18, Y+1	; 0x01
    7bec:	89 81       	ldd	r24, Y+1	; 0x01
    7bee:	9a 81       	ldd	r25, Y+2	; 0x02
    7bf0:	80 53       	subi	r24, 0x30	; 48
    7bf2:	9c 4d       	sbci	r25, 0xDC	; 220
    7bf4:	fc 01       	movw	r30, r24
    7bf6:	20 83       	st	Z, r18
    7bf8:	89 81       	ldd	r24, Y+1	; 0x01
    7bfa:	9a 81       	ldd	r25, Y+2	; 0x02
    7bfc:	01 96       	adiw	r24, 0x01	; 1
    7bfe:	89 83       	std	Y+1, r24	; 0x01
    7c00:	9a 83       	std	Y+2, r25	; 0x02
    7c02:	89 81       	ldd	r24, Y+1	; 0x01
    7c04:	9a 81       	ldd	r25, Y+2	; 0x02
    7c06:	88 31       	cpi	r24, 0x18	; 24
    7c08:	91 05       	cpc	r25, r1
    7c0a:	7c f3       	brlt	.-34     	; 0x7bea <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7c0c:	20 ed       	ldi	r18, 0xD0	; 208
    7c0e:	33 e2       	ldi	r19, 0x23	; 35
    7c10:	64 e1       	ldi	r22, 0x14	; 20
    7c12:	70 e0       	ldi	r23, 0x00	; 0
    7c14:	80 e0       	ldi	r24, 0x00	; 0
    7c16:	90 e0       	ldi	r25, 0x00	; 0
    7c18:	a9 01       	movw	r20, r18
    7c1a:	28 e1       	ldi	r18, 0x18	; 24
    7c1c:	30 e0       	ldi	r19, 0x00	; 0
    7c1e:	0e 94 f1 4e 	call	0x9de2	; 0x9de2 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7c22:	1b 82       	std	Y+3, r1	; 0x03
    7c24:	1c 82       	std	Y+4, r1	; 0x04
    7c26:	0b c0       	rjmp	.+22     	; 0x7c3e <SD_write_and_read_knowns+0x68>
    7c28:	8b 81       	ldd	r24, Y+3	; 0x03
    7c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    7c2c:	80 53       	subi	r24, 0x30	; 48
    7c2e:	9c 4d       	sbci	r25, 0xDC	; 220
    7c30:	fc 01       	movw	r30, r24
    7c32:	10 82       	st	Z, r1
    7c34:	8b 81       	ldd	r24, Y+3	; 0x03
    7c36:	9c 81       	ldd	r25, Y+4	; 0x04
    7c38:	01 96       	adiw	r24, 0x01	; 1
    7c3a:	8b 83       	std	Y+3, r24	; 0x03
    7c3c:	9c 83       	std	Y+4, r25	; 0x04
    7c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    7c40:	9c 81       	ldd	r25, Y+4	; 0x04
    7c42:	88 31       	cpi	r24, 0x18	; 24
    7c44:	91 05       	cpc	r25, r1
    7c46:	84 f3       	brlt	.-32     	; 0x7c28 <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7c48:	20 ed       	ldi	r18, 0xD0	; 208
    7c4a:	33 e2       	ldi	r19, 0x23	; 35
    7c4c:	64 e1       	ldi	r22, 0x14	; 20
    7c4e:	70 e0       	ldi	r23, 0x00	; 0
    7c50:	80 e0       	ldi	r24, 0x00	; 0
    7c52:	90 e0       	ldi	r25, 0x00	; 0
    7c54:	a9 01       	movw	r20, r18
    7c56:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7c5a:	1d 82       	std	Y+5, r1	; 0x05
    7c5c:	1e 82       	std	Y+6, r1	; 0x06
    7c5e:	13 c0       	rjmp	.+38     	; 0x7c86 <SD_write_and_read_knowns+0xb0>
    7c60:	8d 81       	ldd	r24, Y+5	; 0x05
    7c62:	9e 81       	ldd	r25, Y+6	; 0x06
    7c64:	24 e6       	ldi	r18, 0x64	; 100
    7c66:	30 e0       	ldi	r19, 0x00	; 0
    7c68:	b9 01       	movw	r22, r18
    7c6a:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    7c6e:	28 2f       	mov	r18, r24
    7c70:	8d 81       	ldd	r24, Y+5	; 0x05
    7c72:	9e 81       	ldd	r25, Y+6	; 0x06
    7c74:	80 53       	subi	r24, 0x30	; 48
    7c76:	9c 4d       	sbci	r25, 0xDC	; 220
    7c78:	fc 01       	movw	r30, r24
    7c7a:	20 83       	st	Z, r18
    7c7c:	8d 81       	ldd	r24, Y+5	; 0x05
    7c7e:	9e 81       	ldd	r25, Y+6	; 0x06
    7c80:	01 96       	adiw	r24, 0x01	; 1
    7c82:	8d 83       	std	Y+5, r24	; 0x05
    7c84:	9e 83       	std	Y+6, r25	; 0x06
    7c86:	8d 81       	ldd	r24, Y+5	; 0x05
    7c88:	9e 81       	ldd	r25, Y+6	; 0x06
    7c8a:	f4 e0       	ldi	r31, 0x04	; 4
    7c8c:	82 3e       	cpi	r24, 0xE2	; 226
    7c8e:	9f 07       	cpc	r25, r31
    7c90:	3c f3       	brlt	.-50     	; 0x7c60 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7c92:	20 ed       	ldi	r18, 0xD0	; 208
    7c94:	33 e2       	ldi	r19, 0x23	; 35
    7c96:	60 e5       	ldi	r22, 0x50	; 80
    7c98:	70 e0       	ldi	r23, 0x00	; 0
    7c9a:	80 e0       	ldi	r24, 0x00	; 0
    7c9c:	90 e0       	ldi	r25, 0x00	; 0
    7c9e:	a9 01       	movw	r20, r18
    7ca0:	22 ee       	ldi	r18, 0xE2	; 226
    7ca2:	34 e0       	ldi	r19, 0x04	; 4
    7ca4:	0e 94 35 50 	call	0xa06a	; 0xa06a <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7ca8:	1f 82       	std	Y+7, r1	; 0x07
    7caa:	18 86       	std	Y+8, r1	; 0x08
    7cac:	0b c0       	rjmp	.+22     	; 0x7cc4 <SD_write_and_read_knowns+0xee>
    7cae:	8f 81       	ldd	r24, Y+7	; 0x07
    7cb0:	98 85       	ldd	r25, Y+8	; 0x08
    7cb2:	80 53       	subi	r24, 0x30	; 48
    7cb4:	9c 4d       	sbci	r25, 0xDC	; 220
    7cb6:	fc 01       	movw	r30, r24
    7cb8:	10 82       	st	Z, r1
    7cba:	8f 81       	ldd	r24, Y+7	; 0x07
    7cbc:	98 85       	ldd	r25, Y+8	; 0x08
    7cbe:	01 96       	adiw	r24, 0x01	; 1
    7cc0:	8f 83       	std	Y+7, r24	; 0x07
    7cc2:	98 87       	std	Y+8, r25	; 0x08
    7cc4:	8f 81       	ldd	r24, Y+7	; 0x07
    7cc6:	98 85       	ldd	r25, Y+8	; 0x08
    7cc8:	f4 e0       	ldi	r31, 0x04	; 4
    7cca:	82 3e       	cpi	r24, 0xE2	; 226
    7ccc:	9f 07       	cpc	r25, r31
    7cce:	7c f3       	brlt	.-34     	; 0x7cae <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7cd0:	20 ed       	ldi	r18, 0xD0	; 208
    7cd2:	33 e2       	ldi	r19, 0x23	; 35
    7cd4:	60 e5       	ldi	r22, 0x50	; 80
    7cd6:	70 e0       	ldi	r23, 0x00	; 0
    7cd8:	80 e0       	ldi	r24, 0x00	; 0
    7cda:	90 e0       	ldi	r25, 0x00	; 0
    7cdc:	a9 01       	movw	r20, r18
    7cde:	23 e0       	ldi	r18, 0x03	; 3
    7ce0:	30 e0       	ldi	r19, 0x00	; 0
    7ce2:	0e 94 93 51 	call	0xa326	; 0xa326 <SD_read_multiple_blocks>
}
    7ce6:	28 96       	adiw	r28, 0x08	; 8
    7ce8:	cd bf       	out	0x3d, r28	; 61
    7cea:	de bf       	out	0x3e, r29	; 62
    7cec:	df 91       	pop	r29
    7cee:	cf 91       	pop	r28
    7cf0:	08 95       	ret

00007cf2 <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7cf2:	cf 93       	push	r28
    7cf4:	df 93       	push	r29
    7cf6:	00 d0       	rcall	.+0      	; 0x7cf8 <SD_write_and_read_knowns_FAT+0x6>
    7cf8:	0f 92       	push	r0
    7cfa:	cd b7       	in	r28, 0x3d	; 61
    7cfc:	de b7       	in	r29, 0x3e	; 62
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7cfe:	19 82       	std	Y+1, r1	; 0x01
    7d00:	1a 82       	std	Y+2, r1	; 0x02
    7d02:	0c c0       	rjmp	.+24     	; 0x7d1c <SD_write_and_read_knowns_FAT+0x2a>
    7d04:	29 81       	ldd	r18, Y+1	; 0x01
    7d06:	89 81       	ldd	r24, Y+1	; 0x01
    7d08:	9a 81       	ldd	r25, Y+2	; 0x02
    7d0a:	80 53       	subi	r24, 0x30	; 48
    7d0c:	9c 4d       	sbci	r25, 0xDC	; 220
    7d0e:	fc 01       	movw	r30, r24
    7d10:	20 83       	st	Z, r18
    7d12:	89 81       	ldd	r24, Y+1	; 0x01
    7d14:	9a 81       	ldd	r25, Y+2	; 0x02
    7d16:	01 96       	adiw	r24, 0x01	; 1
    7d18:	89 83       	std	Y+1, r24	; 0x01
    7d1a:	9a 83       	std	Y+2, r25	; 0x02
    7d1c:	89 81       	ldd	r24, Y+1	; 0x01
    7d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    7d20:	88 31       	cpi	r24, 0x18	; 24
    7d22:	91 05       	cpc	r25, r1
    7d24:	7c f3       	brlt	.-34     	; 0x7d04 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    7d26:	89 e0       	ldi	r24, 0x09	; 9
    7d28:	90 e2       	ldi	r25, 0x20	; 32
    7d2a:	20 ed       	ldi	r18, 0xD0	; 208
    7d2c:	33 e2       	ldi	r19, 0x23	; 35
    7d2e:	b9 01       	movw	r22, r18
    7d30:	20 e0       	ldi	r18, 0x00	; 0
    7d32:	32 e0       	ldi	r19, 0x02	; 2
    7d34:	40 e0       	ldi	r20, 0x00	; 0
    7d36:	50 e0       	ldi	r21, 0x00	; 0
    7d38:	0e 94 e6 46 	call	0x8dcc	; 0x8dcc <writeFile>
    7d3c:	80 93 94 50 	sts	0x5094, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7d40:	1b 82       	std	Y+3, r1	; 0x03
    7d42:	1c 82       	std	Y+4, r1	; 0x04
    7d44:	0b c0       	rjmp	.+22     	; 0x7d5c <SD_write_and_read_knowns_FAT+0x6a>
    7d46:	8b 81       	ldd	r24, Y+3	; 0x03
    7d48:	9c 81       	ldd	r25, Y+4	; 0x04
    7d4a:	80 53       	subi	r24, 0x30	; 48
    7d4c:	9c 4d       	sbci	r25, 0xDC	; 220
    7d4e:	fc 01       	movw	r30, r24
    7d50:	10 82       	st	Z, r1
    7d52:	8b 81       	ldd	r24, Y+3	; 0x03
    7d54:	9c 81       	ldd	r25, Y+4	; 0x04
    7d56:	01 96       	adiw	r24, 0x01	; 1
    7d58:	8b 83       	std	Y+3, r24	; 0x03
    7d5a:	9c 83       	std	Y+4, r25	; 0x04
    7d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    7d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    7d60:	88 31       	cpi	r24, 0x18	; 24
    7d62:	91 05       	cpc	r25, r1
    7d64:	84 f3       	brlt	.-32     	; 0x7d46 <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    7d66:	29 e0       	ldi	r18, 0x09	; 9
    7d68:	30 e2       	ldi	r19, 0x20	; 32
    7d6a:	80 e0       	ldi	r24, 0x00	; 0
    7d6c:	b9 01       	movw	r22, r18
    7d6e:	0e 94 10 45 	call	0x8a20	; 0x8a20 <readFile>
    7d72:	80 93 94 50 	sts	0x5094, r24
}
    7d76:	24 96       	adiw	r28, 0x04	; 4
    7d78:	cd bf       	out	0x3d, r28	; 61
    7d7a:	de bf       	out	0x3e, r29	; 62
    7d7c:	df 91       	pop	r29
    7d7e:	cf 91       	pop	r28
    7d80:	08 95       	ret

00007d82 <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    7d82:	cf 93       	push	r28
    7d84:	df 93       	push	r29
    7d86:	cd b7       	in	r28, 0x3d	; 61
    7d88:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7d8a:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <chb_init>
	chb_set_short_addr(0x0002);
    7d8e:	82 e0       	ldi	r24, 0x02	; 2
    7d90:	90 e0       	ldi	r25, 0x00	; 0
    7d92:	0e 94 94 2c 	call	0x5928	; 0x5928 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7d96:	00 00       	nop
    7d98:	fe cf       	rjmp	.-4      	; 0x7d96 <chibi_test_radio+0x14>

00007d9a <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    7d9a:	cf 93       	push	r28
    7d9c:	df 93       	push	r29
    7d9e:	0f 92       	push	r0
    7da0:	0f 92       	push	r0
    7da2:	cd b7       	in	r28, 0x3d	; 61
    7da4:	de b7       	in	r29, 0x3e	; 62
	
	SD_init();
    7da6:	0e 94 4e 4c 	call	0x989c	; 0x989c <SD_init>
	getBootSectorData();
    7daa:	0e 94 61 40 	call	0x80c2	; 0x80c2 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7dae:	19 82       	std	Y+1, r1	; 0x01
    7db0:	1a 82       	std	Y+2, r1	; 0x02
    7db2:	13 c0       	rjmp	.+38     	; 0x7dda <TestCard+0x40>
    7db4:	89 81       	ldd	r24, Y+1	; 0x01
    7db6:	9a 81       	ldd	r25, Y+2	; 0x02
    7db8:	29 e7       	ldi	r18, 0x79	; 121
    7dba:	30 e0       	ldi	r19, 0x00	; 0
    7dbc:	b9 01       	movw	r22, r18
    7dbe:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    7dc2:	28 2f       	mov	r18, r24
    7dc4:	89 81       	ldd	r24, Y+1	; 0x01
    7dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    7dc8:	80 53       	subi	r24, 0x30	; 48
    7dca:	9c 4d       	sbci	r25, 0xDC	; 220
    7dcc:	fc 01       	movw	r30, r24
    7dce:	20 83       	st	Z, r18
    7dd0:	89 81       	ldd	r24, Y+1	; 0x01
    7dd2:	9a 81       	ldd	r25, Y+2	; 0x02
    7dd4:	01 96       	adiw	r24, 0x01	; 1
    7dd6:	89 83       	std	Y+1, r24	; 0x01
    7dd8:	9a 83       	std	Y+2, r25	; 0x02
    7dda:	89 81       	ldd	r24, Y+1	; 0x01
    7ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    7dde:	f2 e0       	ldi	r31, 0x02	; 2
    7de0:	80 30       	cpi	r24, 0x00	; 0
    7de2:	9f 07       	cpc	r25, r31
    7de4:	3c f3       	brlt	.-50     	; 0x7db4 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    7de6:	89 e0       	ldi	r24, 0x09	; 9
    7de8:	90 e2       	ldi	r25, 0x20	; 32
    7dea:	20 ed       	ldi	r18, 0xD0	; 208
    7dec:	33 e2       	ldi	r19, 0x23	; 35
    7dee:	b9 01       	movw	r22, r18
    7df0:	20 e0       	ldi	r18, 0x00	; 0
    7df2:	32 e0       	ldi	r19, 0x02	; 2
    7df4:	40 e0       	ldi	r20, 0x00	; 0
    7df6:	50 e0       	ldi	r21, 0x00	; 0
    7df8:	0e 94 e6 46 	call	0x8dcc	; 0x8dcc <writeFile>
	nop();
    7dfc:	00 00       	nop
}
    7dfe:	0f 90       	pop	r0
    7e00:	0f 90       	pop	r0
    7e02:	df 91       	pop	r29
    7e04:	cf 91       	pop	r28
    7e06:	08 95       	ret

00007e08 <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    7e08:	1f 92       	push	r1
    7e0a:	0f 92       	push	r0
    7e0c:	0f b6       	in	r0, 0x3f	; 63
    7e0e:	0f 92       	push	r0
    7e10:	00 90 3b 00 	lds	r0, 0x003B
    7e14:	0f 92       	push	r0
    7e16:	11 24       	eor	r1, r1
    7e18:	2f 93       	push	r18
    7e1a:	3f 93       	push	r19
    7e1c:	4f 93       	push	r20
    7e1e:	5f 93       	push	r21
    7e20:	6f 93       	push	r22
    7e22:	7f 93       	push	r23
    7e24:	8f 93       	push	r24
    7e26:	9f 93       	push	r25
    7e28:	af 93       	push	r26
    7e2a:	bf 93       	push	r27
    7e2c:	ef 93       	push	r30
    7e2e:	ff 93       	push	r31
    7e30:	cf 93       	push	r28
    7e32:	df 93       	push	r29
    7e34:	00 d0       	rcall	.+0      	; 0x7e36 <__vector_43+0x2e>
    7e36:	00 d0       	rcall	.+0      	; 0x7e38 <__vector_43+0x30>
    7e38:	cd b7       	in	r28, 0x3d	; 61
    7e3a:	de b7       	in	r29, 0x3e	; 62
	
	chb_rx_data_t* msg = NULL;
    7e3c:	1d 82       	std	Y+5, r1	; 0x05
    7e3e:	1e 82       	std	Y+6, r1	; 0x06
	switch (RadioMonitorMode) {
    7e40:	80 91 4f 40 	lds	r24, 0x404F
    7e44:	88 2f       	mov	r24, r24
    7e46:	90 e0       	ldi	r25, 0x00	; 0
    7e48:	81 30       	cpi	r24, 0x01	; 1
    7e4a:	91 05       	cpc	r25, r1
    7e4c:	29 f0       	breq	.+10     	; 0x7e58 <__vector_43+0x50>
    7e4e:	82 30       	cpi	r24, 0x02	; 2
    7e50:	91 05       	cpc	r25, r1
    7e52:	09 f4       	brne	.+2      	; 0x7e56 <__vector_43+0x4e>
    7e54:	74 c0       	rjmp	.+232    	; 0x7f3e <__vector_43+0x136>
    7e56:	93 c0       	rjmp	.+294    	; 0x7f7e <__vector_43+0x176>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    7e58:	8d 81       	ldd	r24, Y+5	; 0x05
    7e5a:	9e 81       	ldd	r25, Y+6	; 0x06
    7e5c:	0e 94 51 21 	call	0x42a2	; 0x42a2 <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    7e60:	8d 81       	ldd	r24, Y+5	; 0x05
    7e62:	9e 81       	ldd	r25, Y+6	; 0x06
    7e64:	05 96       	adiw	r24, 0x05	; 5
    7e66:	21 e1       	ldi	r18, 0x11	; 17
    7e68:	30 e2       	ldi	r19, 0x20	; 32
    7e6a:	b9 01       	movw	r22, r18
    7e6c:	45 e0       	ldi	r20, 0x05	; 5
    7e6e:	50 e0       	ldi	r21, 0x00	; 0
    7e70:	0e 94 52 5e 	call	0xbca4	; 0xbca4 <strncmp>
    7e74:	00 97       	sbiw	r24, 0x00	; 0
    7e76:	51 f4       	brne	.+20     	; 0x7e8c <__vector_43+0x84>
				MotesReadyToSynch++;
    7e78:	80 91 69 50 	lds	r24, 0x5069
    7e7c:	90 91 6a 50 	lds	r25, 0x506A
    7e80:	01 96       	adiw	r24, 0x01	; 1
    7e82:	80 93 69 50 	sts	0x5069, r24
    7e86:	90 93 6a 50 	sts	0x506A, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7e8a:	7b c0       	rjmp	.+246    	; 0x7f82 <__vector_43+0x17a>
			if(!strncmp((const char*)(msg->data),"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    7e8c:	19 82       	std	Y+1, r1	; 0x01
    7e8e:	1a 82       	std	Y+2, r1	; 0x02
    7e90:	1b 82       	std	Y+3, r1	; 0x03
    7e92:	1c 82       	std	Y+4, r1	; 0x04
    7e94:	1a c0       	rjmp	.+52     	; 0x7eca <__vector_43+0xc2>
    7e96:	2d 81       	ldd	r18, Y+5	; 0x05
    7e98:	3e 81       	ldd	r19, Y+6	; 0x06
    7e9a:	89 81       	ldd	r24, Y+1	; 0x01
    7e9c:	9a 81       	ldd	r25, Y+2	; 0x02
    7e9e:	82 0f       	add	r24, r18
    7ea0:	93 1f       	adc	r25, r19
    7ea2:	05 96       	adiw	r24, 0x05	; 5
    7ea4:	fc 01       	movw	r30, r24
    7ea6:	20 81       	ld	r18, Z
    7ea8:	89 81       	ldd	r24, Y+1	; 0x01
    7eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    7eac:	80 53       	subi	r24, 0x30	; 48
    7eae:	9c 4d       	sbci	r25, 0xDC	; 220
    7eb0:	fc 01       	movw	r30, r24
    7eb2:	20 83       	st	Z, r18
    7eb4:	89 81       	ldd	r24, Y+1	; 0x01
    7eb6:	9a 81       	ldd	r25, Y+2	; 0x02
    7eb8:	ab 81       	ldd	r26, Y+3	; 0x03
    7eba:	bc 81       	ldd	r27, Y+4	; 0x04
    7ebc:	01 96       	adiw	r24, 0x01	; 1
    7ebe:	a1 1d       	adc	r26, r1
    7ec0:	b1 1d       	adc	r27, r1
    7ec2:	89 83       	std	Y+1, r24	; 0x01
    7ec4:	9a 83       	std	Y+2, r25	; 0x02
    7ec6:	ab 83       	std	Y+3, r26	; 0x03
    7ec8:	bc 83       	std	Y+4, r27	; 0x04
    7eca:	89 81       	ldd	r24, Y+1	; 0x01
    7ecc:	9a 81       	ldd	r25, Y+2	; 0x02
    7ece:	ab 81       	ldd	r26, Y+3	; 0x03
    7ed0:	bc 81       	ldd	r27, Y+4	; 0x04
    7ed2:	80 38       	cpi	r24, 0x80	; 128
    7ed4:	91 05       	cpc	r25, r1
    7ed6:	a1 05       	cpc	r26, r1
    7ed8:	b1 05       	cpc	r27, r1
    7eda:	e8 f2       	brcs	.-70     	; 0x7e96 <__vector_43+0x8e>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    7edc:	80 91 bb 50 	lds	r24, 0x50BB
    7ee0:	90 91 bc 50 	lds	r25, 0x50BC
    7ee4:	a0 91 bd 50 	lds	r26, 0x50BD
    7ee8:	b0 91 be 50 	lds	r27, 0x50BE
    7eec:	80 58       	subi	r24, 0x80	; 128
    7eee:	9f 4f       	sbci	r25, 0xFF	; 255
    7ef0:	af 4f       	sbci	r26, 0xFF	; 255
    7ef2:	bf 4f       	sbci	r27, 0xFF	; 255
    7ef4:	80 93 bb 50 	sts	0x50BB, r24
    7ef8:	90 93 bc 50 	sts	0x50BC, r25
    7efc:	a0 93 bd 50 	sts	0x50BD, r26
    7f00:	b0 93 be 50 	sts	0x50BE, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    7f04:	80 91 bb 50 	lds	r24, 0x50BB
    7f08:	90 91 bc 50 	lds	r25, 0x50BC
    7f0c:	a0 91 bd 50 	lds	r26, 0x50BD
    7f10:	b0 91 be 50 	lds	r27, 0x50BE
    7f14:	80 58       	subi	r24, 0x80	; 128
    7f16:	9f 4f       	sbci	r25, 0xFF	; 255
    7f18:	af 4f       	sbci	r26, 0xFF	; 255
    7f1a:	bf 4f       	sbci	r27, 0xFF	; 255
    7f1c:	81 37       	cpi	r24, 0x71	; 113
    7f1e:	fc e1       	ldi	r31, 0x1C	; 28
    7f20:	9f 07       	cpc	r25, r31
    7f22:	f0 e0       	ldi	r31, 0x00	; 0
    7f24:	af 07       	cpc	r26, r31
    7f26:	f0 e0       	ldi	r31, 0x00	; 0
    7f28:	bf 07       	cpc	r27, r31
    7f2a:	58 f1       	brcs	.+86     	; 0x7f82 <__vector_43+0x17a>
    7f2c:	10 92 bb 50 	sts	0x50BB, r1
    7f30:	10 92 bc 50 	sts	0x50BC, r1
    7f34:	10 92 bd 50 	sts	0x50BD, r1
    7f38:	10 92 be 50 	sts	0x50BE, r1
			}			
			break;
    7f3c:	22 c0       	rjmp	.+68     	; 0x7f82 <__vector_43+0x17a>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    7f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    7f40:	9e 81       	ldd	r25, Y+6	; 0x06
    7f42:	0e 94 51 21 	call	0x42a2	; 0x42a2 <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    7f46:	8d 81       	ldd	r24, Y+5	; 0x05
    7f48:	9e 81       	ldd	r25, Y+6	; 0x06
    7f4a:	05 96       	adiw	r24, 0x05	; 5
    7f4c:	27 e1       	ldi	r18, 0x17	; 23
    7f4e:	30 e2       	ldi	r19, 0x20	; 32
    7f50:	b9 01       	movw	r22, r18
    7f52:	4e e0       	ldi	r20, 0x0E	; 14
    7f54:	50 e0       	ldi	r21, 0x00	; 0
    7f56:	0e 94 52 5e 	call	0xbca4	; 0xbca4 <strncmp>
    7f5a:	00 97       	sbiw	r24, 0x00	; 0
    7f5c:	a1 f4       	brne	.+40     	; 0x7f86 <__vector_43+0x17e>
				RadioMonitorMode = SYNCHED;
    7f5e:	83 e0       	ldi	r24, 0x03	; 3
    7f60:	80 93 4f 40 	sts	0x404F, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    7f64:	80 e4       	ldi	r24, 0x40	; 64
    7f66:	99 e0       	ldi	r25, 0x09	; 9
    7f68:	29 e0       	ldi	r18, 0x09	; 9
    7f6a:	fc 01       	movw	r30, r24
    7f6c:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    7f6e:	80 e4       	ldi	r24, 0x40	; 64
    7f70:	98 e0       	ldi	r25, 0x08	; 8
    7f72:	21 e0       	ldi	r18, 0x01	; 1
    7f74:	fc 01       	movw	r30, r24
    7f76:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    7f78:	0e 94 9f 0b 	call	0x173e	; 0x173e <ADC_Resume_Sampling>
			}
			break;
    7f7c:	04 c0       	rjmp	.+8      	; 0x7f86 <__vector_43+0x17e>
		default:
			break;
    7f7e:	00 00       	nop
    7f80:	03 c0       	rjmp	.+6      	; 0x7f88 <__vector_43+0x180>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7f82:	00 00       	nop
    7f84:	01 c0       	rjmp	.+2      	; 0x7f88 <__vector_43+0x180>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    7f86:	00 00       	nop
		default:
			break;
	}
}
    7f88:	26 96       	adiw	r28, 0x06	; 6
    7f8a:	cd bf       	out	0x3d, r28	; 61
    7f8c:	de bf       	out	0x3e, r29	; 62
    7f8e:	df 91       	pop	r29
    7f90:	cf 91       	pop	r28
    7f92:	ff 91       	pop	r31
    7f94:	ef 91       	pop	r30
    7f96:	bf 91       	pop	r27
    7f98:	af 91       	pop	r26
    7f9a:	9f 91       	pop	r25
    7f9c:	8f 91       	pop	r24
    7f9e:	7f 91       	pop	r23
    7fa0:	6f 91       	pop	r22
    7fa2:	5f 91       	pop	r21
    7fa4:	4f 91       	pop	r20
    7fa6:	3f 91       	pop	r19
    7fa8:	2f 91       	pop	r18
    7faa:	0f 90       	pop	r0
    7fac:	00 92 3b 00 	sts	0x003B, r0
    7fb0:	0f 90       	pop	r0
    7fb2:	0f be       	out	0x3f, r0	; 63
    7fb4:	0f 90       	pop	r0
    7fb6:	1f 90       	pop	r1
    7fb8:	18 95       	reti

00007fba <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    7fba:	cf 93       	push	r28
    7fbc:	df 93       	push	r29
    7fbe:	cd b7       	in	r28, 0x3d	; 61
    7fc0:	de b7       	in	r29, 0x3e	; 62
    7fc2:	a0 97       	sbiw	r28, 0x20	; 32
    7fc4:	cd bf       	out	0x3d, r28	; 61
    7fc6:	de bf       	out	0x3e, r29	; 62
    7fc8:	89 8f       	std	Y+25, r24	; 0x19
    7fca:	9a 8f       	std	Y+26, r25	; 0x1a
    7fcc:	4b 8f       	std	Y+27, r20	; 0x1b
    7fce:	5c 8f       	std	Y+28, r21	; 0x1c
    7fd0:	6d 8f       	std	Y+29, r22	; 0x1d
    7fd2:	7e 8f       	std	Y+30, r23	; 0x1e
    7fd4:	2f 8f       	std	Y+31, r18	; 0x1f
    7fd6:	38 a3       	lds	r19, 0x58
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    7fd8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7fda:	98 a1       	lds	r25, 0x48
    7fdc:	fc 01       	movw	r30, r24
    7fde:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    7fe0:	19 82       	std	Y+1, r1	; 0x01
    7fe2:	1a 82       	std	Y+2, r1	; 0x02
    7fe4:	1b 82       	std	Y+3, r1	; 0x03
    7fe6:	1c 82       	std	Y+4, r1	; 0x04
    7fe8:	58 c0       	rjmp	.+176    	; 0x809a <DeciToString+0xe0>
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    7fea:	89 81       	ldd	r24, Y+1	; 0x01
    7fec:	9a 81       	ldd	r25, Y+2	; 0x02
    7fee:	88 0f       	add	r24, r24
    7ff0:	99 1f       	adc	r25, r25
    7ff2:	88 0f       	add	r24, r24
    7ff4:	99 1f       	adc	r25, r25
    7ff6:	29 8d       	ldd	r18, Y+25	; 0x19
    7ff8:	3a 8d       	ldd	r19, Y+26	; 0x1a
    7ffa:	82 0f       	add	r24, r18
    7ffc:	93 1f       	adc	r25, r19
    7ffe:	fc 01       	movw	r30, r24
    8000:	80 81       	ld	r24, Z
    8002:	91 81       	ldd	r25, Z+1	; 0x01
    8004:	a2 81       	ldd	r26, Z+2	; 0x02
    8006:	b3 81       	ldd	r27, Z+3	; 0x03
    8008:	2d b7       	in	r18, 0x3d	; 61
    800a:	3e b7       	in	r19, 0x3e	; 62
    800c:	28 50       	subi	r18, 0x08	; 8
    800e:	30 40       	sbci	r19, 0x00	; 0
    8010:	2d bf       	out	0x3d, r18	; 61
    8012:	3e bf       	out	0x3e, r19	; 62
    8014:	2d b7       	in	r18, 0x3d	; 61
    8016:	3e b7       	in	r19, 0x3e	; 62
    8018:	2f 5f       	subi	r18, 0xFF	; 255
    801a:	3f 4f       	sbci	r19, 0xFF	; 255
    801c:	ae 01       	movw	r20, r28
    801e:	4b 5f       	subi	r20, 0xFB	; 251
    8020:	5f 4f       	sbci	r21, 0xFF	; 255
    8022:	f9 01       	movw	r30, r18
    8024:	40 83       	st	Z, r20
    8026:	51 83       	std	Z+1, r21	; 0x01
    8028:	46 e2       	ldi	r20, 0x26	; 38
    802a:	50 e2       	ldi	r21, 0x20	; 32
    802c:	f9 01       	movw	r30, r18
    802e:	42 83       	std	Z+2, r20	; 0x02
    8030:	53 83       	std	Z+3, r21	; 0x03
    8032:	f9 01       	movw	r30, r18
    8034:	84 83       	std	Z+4, r24	; 0x04
    8036:	95 83       	std	Z+5, r25	; 0x05
    8038:	a6 83       	std	Z+6, r26	; 0x06
    803a:	b7 83       	std	Z+7, r27	; 0x07
    803c:	0e 94 93 5e 	call	0xbd26	; 0xbd26 <sprintf>
    8040:	2d b7       	in	r18, 0x3d	; 61
    8042:	3e b7       	in	r19, 0x3e	; 62
    8044:	28 5f       	subi	r18, 0xF8	; 248
    8046:	3f 4f       	sbci	r19, 0xFF	; 255
    8048:	2d bf       	out	0x3d, r18	; 61
    804a:	3e bf       	out	0x3e, r19	; 62
		strcat(ReturnString,b);
    804c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    804e:	98 a1       	lds	r25, 0x48
    8050:	9e 01       	movw	r18, r28
    8052:	2b 5f       	subi	r18, 0xFB	; 251
    8054:	3f 4f       	sbci	r19, 0xFF	; 255
    8056:	b9 01       	movw	r22, r18
    8058:	0e 94 47 5e 	call	0xbc8e	; 0xbc8e <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    805c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    805e:	98 a1       	lds	r25, 0x48
    8060:	9c 01       	movw	r18, r24
    8062:	f9 01       	movw	r30, r18
    8064:	01 90       	ld	r0, Z+
    8066:	00 20       	and	r0, r0
    8068:	e9 f7       	brne	.-6      	; 0x8064 <DeciToString+0xaa>
    806a:	cf 01       	movw	r24, r30
    806c:	01 97       	sbiw	r24, 0x01	; 1
    806e:	82 1b       	sub	r24, r18
    8070:	93 0b       	sbc	r25, r19
    8072:	2f 8d       	ldd	r18, Y+31	; 0x1f
    8074:	38 a1       	lds	r19, 0x48
    8076:	82 0f       	add	r24, r18
    8078:	93 1f       	adc	r25, r19
    807a:	2a e0       	ldi	r18, 0x0A	; 10
    807c:	30 e0       	ldi	r19, 0x00	; 0
    807e:	fc 01       	movw	r30, r24
    8080:	20 83       	st	Z, r18
    8082:	31 83       	std	Z+1, r19	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    8084:	89 81       	ldd	r24, Y+1	; 0x01
    8086:	9a 81       	ldd	r25, Y+2	; 0x02
    8088:	ab 81       	ldd	r26, Y+3	; 0x03
    808a:	bc 81       	ldd	r27, Y+4	; 0x04
    808c:	01 96       	adiw	r24, 0x01	; 1
    808e:	a1 1d       	adc	r26, r1
    8090:	b1 1d       	adc	r27, r1
    8092:	89 83       	std	Y+1, r24	; 0x01
    8094:	9a 83       	std	Y+2, r25	; 0x02
    8096:	ab 83       	std	Y+3, r26	; 0x03
    8098:	bc 83       	std	Y+4, r27	; 0x04
    809a:	29 81       	ldd	r18, Y+1	; 0x01
    809c:	3a 81       	ldd	r19, Y+2	; 0x02
    809e:	4b 81       	ldd	r20, Y+3	; 0x03
    80a0:	5c 81       	ldd	r21, Y+4	; 0x04
    80a2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    80a4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    80a6:	ad 8d       	ldd	r26, Y+29	; 0x1d
    80a8:	be 8d       	ldd	r27, Y+30	; 0x1e
    80aa:	28 17       	cp	r18, r24
    80ac:	39 07       	cpc	r19, r25
    80ae:	4a 07       	cpc	r20, r26
    80b0:	5b 07       	cpc	r21, r27
    80b2:	08 f4       	brcc	.+2      	; 0x80b6 <DeciToString+0xfc>
    80b4:	9a cf       	rjmp	.-204    	; 0x7fea <DeciToString+0x30>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    80b6:	a0 96       	adiw	r28, 0x20	; 32
    80b8:	cd bf       	out	0x3d, r28	; 61
    80ba:	de bf       	out	0x3e, r29	; 62
    80bc:	df 91       	pop	r29
    80be:	cf 91       	pop	r28
    80c0:	08 95       	ret

000080c2 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    80c2:	ef 92       	push	r14
    80c4:	ff 92       	push	r15
    80c6:	0f 93       	push	r16
    80c8:	1f 93       	push	r17
    80ca:	cf 93       	push	r28
    80cc:	df 93       	push	r29
    80ce:	cd b7       	in	r28, 0x3d	; 61
    80d0:	de b7       	in	r29, 0x3e	; 62
    80d2:	2a 97       	sbiw	r28, 0x0a	; 10
    80d4:	cd bf       	out	0x3d, r28	; 61
    80d6:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    80d8:	10 92 6e 50 	sts	0x506E, r1
    80dc:	10 92 6f 50 	sts	0x506F, r1
    80e0:	10 92 70 50 	sts	0x5070, r1
    80e4:	10 92 71 50 	sts	0x5071, r1

SD_read_block(0,SDBuffer);
    80e8:	27 ec       	ldi	r18, 0xC7	; 199
    80ea:	31 e2       	ldi	r19, 0x21	; 33
    80ec:	60 e0       	ldi	r22, 0x00	; 0
    80ee:	70 e0       	ldi	r23, 0x00	; 0
    80f0:	cb 01       	movw	r24, r22
    80f2:	a9 01       	movw	r20, r18
    80f4:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    80f8:	87 ec       	ldi	r24, 0xC7	; 199
    80fa:	91 e2       	ldi	r25, 0x21	; 33
    80fc:	89 83       	std	Y+1, r24	; 0x01
    80fe:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    8100:	89 81       	ldd	r24, Y+1	; 0x01
    8102:	9a 81       	ldd	r25, Y+2	; 0x02
    8104:	fc 01       	movw	r30, r24
    8106:	80 81       	ld	r24, Z
    8108:	89 3e       	cpi	r24, 0xE9	; 233
    810a:	09 f4       	brne	.+2      	; 0x810e <getBootSectorData+0x4c>
    810c:	4d c0       	rjmp	.+154    	; 0x81a8 <getBootSectorData+0xe6>
    810e:	89 81       	ldd	r24, Y+1	; 0x01
    8110:	9a 81       	ldd	r25, Y+2	; 0x02
    8112:	fc 01       	movw	r30, r24
    8114:	80 81       	ld	r24, Z
    8116:	8b 3e       	cpi	r24, 0xEB	; 235
    8118:	09 f4       	brne	.+2      	; 0x811c <getBootSectorData+0x5a>
    811a:	46 c0       	rjmp	.+140    	; 0x81a8 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    811c:	87 ec       	ldi	r24, 0xC7	; 199
    811e:	91 e2       	ldi	r25, 0x21	; 33
    8120:	8b 83       	std	Y+3, r24	; 0x03
    8122:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    8124:	8b 81       	ldd	r24, Y+3	; 0x03
    8126:	9c 81       	ldd	r25, Y+4	; 0x04
    8128:	82 50       	subi	r24, 0x02	; 2
    812a:	9e 4f       	sbci	r25, 0xFE	; 254
    812c:	fc 01       	movw	r30, r24
    812e:	80 81       	ld	r24, Z
    8130:	91 81       	ldd	r25, Z+1	; 0x01
    8132:	fa ea       	ldi	r31, 0xAA	; 170
    8134:	85 35       	cpi	r24, 0x55	; 85
    8136:	9f 07       	cpc	r25, r31
    8138:	11 f0       	breq	.+4      	; 0x813e <getBootSectorData+0x7c>
    813a:	81 e0       	ldi	r24, 0x01	; 1
    813c:	01 c1       	rjmp	.+514    	; 0x8340 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    813e:	8b 81       	ldd	r24, Y+3	; 0x03
    8140:	9c 81       	ldd	r25, Y+4	; 0x04
    8142:	82 54       	subi	r24, 0x42	; 66
    8144:	9e 4f       	sbci	r25, 0xFE	; 254
    8146:	8d 83       	std	Y+5, r24	; 0x05
    8148:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    814a:	8d 81       	ldd	r24, Y+5	; 0x05
    814c:	9e 81       	ldd	r25, Y+6	; 0x06
    814e:	fc 01       	movw	r30, r24
    8150:	80 85       	ldd	r24, Z+8	; 0x08
    8152:	91 85       	ldd	r25, Z+9	; 0x09
    8154:	a2 85       	ldd	r26, Z+10	; 0x0a
    8156:	b3 85       	ldd	r27, Z+11	; 0x0b
    8158:	80 93 6e 50 	sts	0x506E, r24
    815c:	90 93 6f 50 	sts	0x506F, r25
    8160:	a0 93 70 50 	sts	0x5070, r26
    8164:	b0 93 71 50 	sts	0x5071, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    8168:	8d 81       	ldd	r24, Y+5	; 0x05
    816a:	9e 81       	ldd	r25, Y+6	; 0x06
    816c:	fc 01       	movw	r30, r24
    816e:	80 85       	ldd	r24, Z+8	; 0x08
    8170:	91 85       	ldd	r25, Z+9	; 0x09
    8172:	a2 85       	ldd	r26, Z+10	; 0x0a
    8174:	b3 85       	ldd	r27, Z+11	; 0x0b
    8176:	27 ec       	ldi	r18, 0xC7	; 199
    8178:	31 e2       	ldi	r19, 0x21	; 33
    817a:	bc 01       	movw	r22, r24
    817c:	cd 01       	movw	r24, r26
    817e:	a9 01       	movw	r20, r18
    8180:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    8184:	87 ec       	ldi	r24, 0xC7	; 199
    8186:	91 e2       	ldi	r25, 0x21	; 33
    8188:	89 83       	std	Y+1, r24	; 0x01
    818a:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    818c:	89 81       	ldd	r24, Y+1	; 0x01
    818e:	9a 81       	ldd	r25, Y+2	; 0x02
    8190:	fc 01       	movw	r30, r24
    8192:	80 81       	ld	r24, Z
    8194:	89 3e       	cpi	r24, 0xE9	; 233
    8196:	41 f0       	breq	.+16     	; 0x81a8 <getBootSectorData+0xe6>
    8198:	89 81       	ldd	r24, Y+1	; 0x01
    819a:	9a 81       	ldd	r25, Y+2	; 0x02
    819c:	fc 01       	movw	r30, r24
    819e:	80 81       	ld	r24, Z
    81a0:	8b 3e       	cpi	r24, 0xEB	; 235
    81a2:	11 f0       	breq	.+4      	; 0x81a8 <getBootSectorData+0xe6>
    81a4:	81 e0       	ldi	r24, 0x01	; 1
    81a6:	cc c0       	rjmp	.+408    	; 0x8340 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    81a8:	89 81       	ldd	r24, Y+1	; 0x01
    81aa:	9a 81       	ldd	r25, Y+2	; 0x02
    81ac:	fc 01       	movw	r30, r24
    81ae:	83 85       	ldd	r24, Z+11	; 0x0b
    81b0:	94 85       	ldd	r25, Z+12	; 0x0c
    81b2:	80 93 45 40 	sts	0x4045, r24
    81b6:	90 93 46 40 	sts	0x4046, r25
sectorPerCluster = bpb->sectorPerCluster;
    81ba:	89 81       	ldd	r24, Y+1	; 0x01
    81bc:	9a 81       	ldd	r25, Y+2	; 0x02
    81be:	fc 01       	movw	r30, r24
    81c0:	85 85       	ldd	r24, Z+13	; 0x0d
    81c2:	88 2f       	mov	r24, r24
    81c4:	90 e0       	ldi	r25, 0x00	; 0
    81c6:	80 93 6c 50 	sts	0x506C, r24
    81ca:	90 93 6d 50 	sts	0x506D, r25
reservedSectorCount = bpb->reservedSectorCount;
    81ce:	89 81       	ldd	r24, Y+1	; 0x01
    81d0:	9a 81       	ldd	r25, Y+2	; 0x02
    81d2:	fc 01       	movw	r30, r24
    81d4:	86 85       	ldd	r24, Z+14	; 0x0e
    81d6:	97 85       	ldd	r25, Z+15	; 0x0f
    81d8:	80 93 74 50 	sts	0x5074, r24
    81dc:	90 93 75 50 	sts	0x5075, r25
rootCluster = bpb->rootCluster;
    81e0:	89 81       	ldd	r24, Y+1	; 0x01
    81e2:	9a 81       	ldd	r25, Y+2	; 0x02
    81e4:	fc 01       	movw	r30, r24
    81e6:	84 a5       	lds	r24, 0x64
    81e8:	95 a5       	lds	r25, 0x65
    81ea:	a6 a5       	lds	r26, 0x66
    81ec:	b7 a5       	lds	r27, 0x67
    81ee:	80 93 50 40 	sts	0x4050, r24
    81f2:	90 93 51 40 	sts	0x4051, r25
    81f6:	a0 93 52 40 	sts	0x4052, r26
    81fa:	b0 93 53 40 	sts	0x4053, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    81fe:	89 81       	ldd	r24, Y+1	; 0x01
    8200:	9a 81       	ldd	r25, Y+2	; 0x02
    8202:	fc 01       	movw	r30, r24
    8204:	24 8d       	ldd	r18, Z+28	; 0x1c
    8206:	35 8d       	ldd	r19, Z+29	; 0x1d
    8208:	46 8d       	ldd	r20, Z+30	; 0x1e
    820a:	57 8d       	ldd	r21, Z+31	; 0x1f
    820c:	80 91 74 50 	lds	r24, 0x5074
    8210:	90 91 75 50 	lds	r25, 0x5075
    8214:	cc 01       	movw	r24, r24
    8216:	a0 e0       	ldi	r26, 0x00	; 0
    8218:	b0 e0       	ldi	r27, 0x00	; 0
    821a:	79 01       	movw	r14, r18
    821c:	8a 01       	movw	r16, r20
    821e:	e8 0e       	add	r14, r24
    8220:	f9 1e       	adc	r15, r25
    8222:	0a 1f       	adc	r16, r26
    8224:	1b 1f       	adc	r17, r27
    8226:	89 81       	ldd	r24, Y+1	; 0x01
    8228:	9a 81       	ldd	r25, Y+2	; 0x02
    822a:	fc 01       	movw	r30, r24
    822c:	80 89       	ldd	r24, Z+16	; 0x10
    822e:	88 2f       	mov	r24, r24
    8230:	90 e0       	ldi	r25, 0x00	; 0
    8232:	a0 e0       	ldi	r26, 0x00	; 0
    8234:	b0 e0       	ldi	r27, 0x00	; 0
    8236:	29 81       	ldd	r18, Y+1	; 0x01
    8238:	3a 81       	ldd	r19, Y+2	; 0x02
    823a:	f9 01       	movw	r30, r18
    823c:	24 a1       	lds	r18, 0x44
    823e:	35 a1       	lds	r19, 0x45
    8240:	46 a1       	lds	r20, 0x46
    8242:	57 a1       	lds	r21, 0x47
    8244:	bc 01       	movw	r22, r24
    8246:	cd 01       	movw	r24, r26
    8248:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    824c:	dc 01       	movw	r26, r24
    824e:	cb 01       	movw	r24, r22
    8250:	8e 0d       	add	r24, r14
    8252:	9f 1d       	adc	r25, r15
    8254:	a0 1f       	adc	r26, r16
    8256:	b1 1f       	adc	r27, r17
    8258:	80 93 cc 23 	sts	0x23CC, r24
    825c:	90 93 cd 23 	sts	0x23CD, r25
    8260:	a0 93 ce 23 	sts	0x23CE, r26
    8264:	b0 93 cf 23 	sts	0x23CF, r27

dataSectors = bpb->totalSectors_F32
    8268:	89 81       	ldd	r24, Y+1	; 0x01
    826a:	9a 81       	ldd	r25, Y+2	; 0x02
    826c:	fc 01       	movw	r30, r24
    826e:	20 a1       	lds	r18, 0x40
    8270:	31 a1       	lds	r19, 0x41
    8272:	42 a1       	lds	r20, 0x42
    8274:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    8276:	89 81       	ldd	r24, Y+1	; 0x01
    8278:	9a 81       	ldd	r25, Y+2	; 0x02
    827a:	fc 01       	movw	r30, r24
    827c:	86 85       	ldd	r24, Z+14	; 0x0e
    827e:	97 85       	ldd	r25, Z+15	; 0x0f
    8280:	cc 01       	movw	r24, r24
    8282:	a0 e0       	ldi	r26, 0x00	; 0
    8284:	b0 e0       	ldi	r27, 0x00	; 0
    8286:	79 01       	movw	r14, r18
    8288:	8a 01       	movw	r16, r20
    828a:	e8 1a       	sub	r14, r24
    828c:	f9 0a       	sbc	r15, r25
    828e:	0a 0b       	sbc	r16, r26
    8290:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    8292:	89 81       	ldd	r24, Y+1	; 0x01
    8294:	9a 81       	ldd	r25, Y+2	; 0x02
    8296:	fc 01       	movw	r30, r24
    8298:	80 89       	ldd	r24, Z+16	; 0x10
    829a:	88 2f       	mov	r24, r24
    829c:	90 e0       	ldi	r25, 0x00	; 0
    829e:	a0 e0       	ldi	r26, 0x00	; 0
    82a0:	b0 e0       	ldi	r27, 0x00	; 0
    82a2:	29 81       	ldd	r18, Y+1	; 0x01
    82a4:	3a 81       	ldd	r19, Y+2	; 0x02
    82a6:	f9 01       	movw	r30, r18
    82a8:	24 a1       	lds	r18, 0x44
    82aa:	35 a1       	lds	r19, 0x45
    82ac:	46 a1       	lds	r20, 0x46
    82ae:	57 a1       	lds	r21, 0x47
    82b0:	bc 01       	movw	r22, r24
    82b2:	cd 01       	movw	r24, r26
    82b4:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    82b8:	dc 01       	movw	r26, r24
    82ba:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    82bc:	a8 01       	movw	r20, r16
    82be:	97 01       	movw	r18, r14
    82c0:	28 1b       	sub	r18, r24
    82c2:	39 0b       	sbc	r19, r25
    82c4:	4a 0b       	sbc	r20, r26
    82c6:	5b 0b       	sbc	r21, r27
    82c8:	da 01       	movw	r26, r20
    82ca:	c9 01       	movw	r24, r18
    82cc:	8f 83       	std	Y+7, r24	; 0x07
    82ce:	98 87       	std	Y+8, r25	; 0x08
    82d0:	a9 87       	std	Y+9, r26	; 0x09
    82d2:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    82d4:	80 91 6c 50 	lds	r24, 0x506C
    82d8:	90 91 6d 50 	lds	r25, 0x506D
    82dc:	9c 01       	movw	r18, r24
    82de:	40 e0       	ldi	r20, 0x00	; 0
    82e0:	50 e0       	ldi	r21, 0x00	; 0
    82e2:	8f 81       	ldd	r24, Y+7	; 0x07
    82e4:	98 85       	ldd	r25, Y+8	; 0x08
    82e6:	a9 85       	ldd	r26, Y+9	; 0x09
    82e8:	ba 85       	ldd	r27, Y+10	; 0x0a
    82ea:	bc 01       	movw	r22, r24
    82ec:	cd 01       	movw	r24, r26
    82ee:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    82f2:	da 01       	movw	r26, r20
    82f4:	c9 01       	movw	r24, r18
    82f6:	80 93 4a 40 	sts	0x404A, r24
    82fa:	90 93 4b 40 	sts	0x404B, r25
    82fe:	a0 93 4c 40 	sts	0x404C, r26
    8302:	b0 93 4d 40 	sts	0x404D, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    8306:	81 e0       	ldi	r24, 0x01	; 1
    8308:	60 e0       	ldi	r22, 0x00	; 0
    830a:	20 e0       	ldi	r18, 0x00	; 0
    830c:	30 e0       	ldi	r19, 0x00	; 0
    830e:	a9 01       	movw	r20, r18
    8310:	0e 94 85 42 	call	0x850a	; 0x850a <getSetFreeCluster>
    8314:	9b 01       	movw	r18, r22
    8316:	ac 01       	movw	r20, r24
    8318:	80 91 4a 40 	lds	r24, 0x404A
    831c:	90 91 4b 40 	lds	r25, 0x404B
    8320:	a0 91 4c 40 	lds	r26, 0x404C
    8324:	b0 91 4d 40 	lds	r27, 0x404D
    8328:	82 17       	cp	r24, r18
    832a:	93 07       	cpc	r25, r19
    832c:	a4 07       	cpc	r26, r20
    832e:	b5 07       	cpc	r27, r21
    8330:	18 f4       	brcc	.+6      	; 0x8338 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    8332:	10 92 c0 50 	sts	0x50C0, r1
    8336:	03 c0       	rjmp	.+6      	; 0x833e <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    8338:	81 e0       	ldi	r24, 0x01	; 1
    833a:	80 93 c0 50 	sts	0x50C0, r24
return 0;
    833e:	80 e0       	ldi	r24, 0x00	; 0
}
    8340:	2a 96       	adiw	r28, 0x0a	; 10
    8342:	cd bf       	out	0x3d, r28	; 61
    8344:	de bf       	out	0x3e, r29	; 62
    8346:	df 91       	pop	r29
    8348:	cf 91       	pop	r28
    834a:	1f 91       	pop	r17
    834c:	0f 91       	pop	r16
    834e:	ff 90       	pop	r15
    8350:	ef 90       	pop	r14
    8352:	08 95       	ret

00008354 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    8354:	cf 93       	push	r28
    8356:	df 93       	push	r29
    8358:	00 d0       	rcall	.+0      	; 0x835a <getFirstSector+0x6>
    835a:	0f 92       	push	r0
    835c:	cd b7       	in	r28, 0x3d	; 61
    835e:	de b7       	in	r29, 0x3e	; 62
    8360:	69 83       	std	Y+1, r22	; 0x01
    8362:	7a 83       	std	Y+2, r23	; 0x02
    8364:	8b 83       	std	Y+3, r24	; 0x03
    8366:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    8368:	89 81       	ldd	r24, Y+1	; 0x01
    836a:	9a 81       	ldd	r25, Y+2	; 0x02
    836c:	ab 81       	ldd	r26, Y+3	; 0x03
    836e:	bc 81       	ldd	r27, Y+4	; 0x04
    8370:	02 97       	sbiw	r24, 0x02	; 2
    8372:	a1 09       	sbc	r26, r1
    8374:	b1 09       	sbc	r27, r1
    8376:	20 91 6c 50 	lds	r18, 0x506C
    837a:	30 91 6d 50 	lds	r19, 0x506D
    837e:	99 01       	movw	r18, r18
    8380:	40 e0       	ldi	r20, 0x00	; 0
    8382:	50 e0       	ldi	r21, 0x00	; 0
    8384:	bc 01       	movw	r22, r24
    8386:	cd 01       	movw	r24, r26
    8388:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    838c:	9b 01       	movw	r18, r22
    838e:	ac 01       	movw	r20, r24
    8390:	80 91 cc 23 	lds	r24, 0x23CC
    8394:	90 91 cd 23 	lds	r25, 0x23CD
    8398:	a0 91 ce 23 	lds	r26, 0x23CE
    839c:	b0 91 cf 23 	lds	r27, 0x23CF
    83a0:	82 0f       	add	r24, r18
    83a2:	93 1f       	adc	r25, r19
    83a4:	a4 1f       	adc	r26, r20
    83a6:	b5 1f       	adc	r27, r21
}
    83a8:	bc 01       	movw	r22, r24
    83aa:	cd 01       	movw	r24, r26
    83ac:	24 96       	adiw	r28, 0x04	; 4
    83ae:	cd bf       	out	0x3d, r28	; 61
    83b0:	de bf       	out	0x3e, r29	; 62
    83b2:	df 91       	pop	r29
    83b4:	cf 91       	pop	r28
    83b6:	08 95       	ret

000083b8 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    83b8:	ef 92       	push	r14
    83ba:	ff 92       	push	r15
    83bc:	0f 93       	push	r16
    83be:	1f 93       	push	r17
    83c0:	cf 93       	push	r28
    83c2:	df 93       	push	r29
    83c4:	cd b7       	in	r28, 0x3d	; 61
    83c6:	de b7       	in	r29, 0x3e	; 62
    83c8:	61 97       	sbiw	r28, 0x11	; 17
    83ca:	cd bf       	out	0x3d, r28	; 61
    83cc:	de bf       	out	0x3e, r29	; 62
    83ce:	69 87       	std	Y+9, r22	; 0x09
    83d0:	7a 87       	std	Y+10, r23	; 0x0a
    83d2:	8b 87       	std	Y+11, r24	; 0x0b
    83d4:	9c 87       	std	Y+12, r25	; 0x0c
    83d6:	4d 87       	std	Y+13, r20	; 0x0d
    83d8:	0e 87       	std	Y+14, r16	; 0x0e
    83da:	1f 87       	std	Y+15, r17	; 0x0f
    83dc:	28 8b       	std	Y+16, r18	; 0x10
    83de:	39 8b       	std	Y+17, r19	; 0x11
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    83e0:	80 91 74 50 	lds	r24, 0x5074
    83e4:	90 91 75 50 	lds	r25, 0x5075
    83e8:	9c 01       	movw	r18, r24
    83ea:	40 e0       	ldi	r20, 0x00	; 0
    83ec:	50 e0       	ldi	r21, 0x00	; 0
    83ee:	80 91 6e 50 	lds	r24, 0x506E
    83f2:	90 91 6f 50 	lds	r25, 0x506F
    83f6:	a0 91 70 50 	lds	r26, 0x5070
    83fa:	b0 91 71 50 	lds	r27, 0x5071
    83fe:	79 01       	movw	r14, r18
    8400:	8a 01       	movw	r16, r20
    8402:	e8 0e       	add	r14, r24
    8404:	f9 1e       	adc	r15, r25
    8406:	0a 1f       	adc	r16, r26
    8408:	1b 1f       	adc	r17, r27
    840a:	89 85       	ldd	r24, Y+9	; 0x09
    840c:	9a 85       	ldd	r25, Y+10	; 0x0a
    840e:	ab 85       	ldd	r26, Y+11	; 0x0b
    8410:	bc 85       	ldd	r27, Y+12	; 0x0c
    8412:	88 0f       	add	r24, r24
    8414:	99 1f       	adc	r25, r25
    8416:	aa 1f       	adc	r26, r26
    8418:	bb 1f       	adc	r27, r27
    841a:	88 0f       	add	r24, r24
    841c:	99 1f       	adc	r25, r25
    841e:	aa 1f       	adc	r26, r26
    8420:	bb 1f       	adc	r27, r27
    8422:	20 91 45 40 	lds	r18, 0x4045
    8426:	30 91 46 40 	lds	r19, 0x4046
    842a:	99 01       	movw	r18, r18
    842c:	40 e0       	ldi	r20, 0x00	; 0
    842e:	50 e0       	ldi	r21, 0x00	; 0
    8430:	bc 01       	movw	r22, r24
    8432:	cd 01       	movw	r24, r26
    8434:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    8438:	da 01       	movw	r26, r20
    843a:	c9 01       	movw	r24, r18
    843c:	8e 0d       	add	r24, r14
    843e:	9f 1d       	adc	r25, r15
    8440:	a0 1f       	adc	r26, r16
    8442:	b1 1f       	adc	r27, r17
    8444:	89 83       	std	Y+1, r24	; 0x01
    8446:	9a 83       	std	Y+2, r25	; 0x02
    8448:	ab 83       	std	Y+3, r26	; 0x03
    844a:	bc 83       	std	Y+4, r27	; 0x04

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    844c:	89 85       	ldd	r24, Y+9	; 0x09
    844e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8450:	ab 85       	ldd	r26, Y+11	; 0x0b
    8452:	bc 85       	ldd	r27, Y+12	; 0x0c
    8454:	88 0f       	add	r24, r24
    8456:	99 1f       	adc	r25, r25
    8458:	aa 1f       	adc	r26, r26
    845a:	bb 1f       	adc	r27, r27
    845c:	88 0f       	add	r24, r24
    845e:	99 1f       	adc	r25, r25
    8460:	aa 1f       	adc	r26, r26
    8462:	bb 1f       	adc	r27, r27
    8464:	20 91 45 40 	lds	r18, 0x4045
    8468:	30 91 46 40 	lds	r19, 0x4046
    846c:	99 01       	movw	r18, r18
    846e:	40 e0       	ldi	r20, 0x00	; 0
    8470:	50 e0       	ldi	r21, 0x00	; 0
    8472:	bc 01       	movw	r22, r24
    8474:	cd 01       	movw	r24, r26
    8476:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    847a:	dc 01       	movw	r26, r24
    847c:	cb 01       	movw	r24, r22
    847e:	8d 83       	std	Y+5, r24	; 0x05
    8480:	9e 83       	std	Y+6, r25	; 0x06

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    8482:	89 81       	ldd	r24, Y+1	; 0x01
    8484:	9a 81       	ldd	r25, Y+2	; 0x02
    8486:	ab 81       	ldd	r26, Y+3	; 0x03
    8488:	bc 81       	ldd	r27, Y+4	; 0x04
    848a:	27 ec       	ldi	r18, 0xC7	; 199
    848c:	31 e2       	ldi	r19, 0x21	; 33
    848e:	bc 01       	movw	r22, r24
    8490:	cd 01       	movw	r24, r26
    8492:	a9 01       	movw	r20, r18
    8494:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    8498:	8d 81       	ldd	r24, Y+5	; 0x05
    849a:	9e 81       	ldd	r25, Y+6	; 0x06
    849c:	89 53       	subi	r24, 0x39	; 57
    849e:	9e 4d       	sbci	r25, 0xDE	; 222
    84a0:	8f 83       	std	Y+7, r24	; 0x07
    84a2:	98 87       	std	Y+8, r25	; 0x08

if(get_set == GET)
    84a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    84a6:	88 23       	and	r24, r24
    84a8:	49 f4       	brne	.+18     	; 0x84bc <getSetNextCluster+0x104>
  return ((*FATEntryValue) & 0x0fffffff);
    84aa:	8f 81       	ldd	r24, Y+7	; 0x07
    84ac:	98 85       	ldd	r25, Y+8	; 0x08
    84ae:	fc 01       	movw	r30, r24
    84b0:	80 81       	ld	r24, Z
    84b2:	91 81       	ldd	r25, Z+1	; 0x01
    84b4:	a2 81       	ldd	r26, Z+2	; 0x02
    84b6:	b3 81       	ldd	r27, Z+3	; 0x03
    84b8:	bf 70       	andi	r27, 0x0F	; 15
    84ba:	1b c0       	rjmp	.+54     	; 0x84f2 <getSetNextCluster+0x13a>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    84bc:	2f 81       	ldd	r18, Y+7	; 0x07
    84be:	38 85       	ldd	r19, Y+8	; 0x08
    84c0:	8e 85       	ldd	r24, Y+14	; 0x0e
    84c2:	9f 85       	ldd	r25, Y+15	; 0x0f
    84c4:	a8 89       	ldd	r26, Y+16	; 0x10
    84c6:	b9 89       	ldd	r27, Y+17	; 0x11
    84c8:	f9 01       	movw	r30, r18
    84ca:	80 83       	st	Z, r24
    84cc:	91 83       	std	Z+1, r25	; 0x01
    84ce:	a2 83       	std	Z+2, r26	; 0x02
    84d0:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    84d2:	89 81       	ldd	r24, Y+1	; 0x01
    84d4:	9a 81       	ldd	r25, Y+2	; 0x02
    84d6:	ab 81       	ldd	r26, Y+3	; 0x03
    84d8:	bc 81       	ldd	r27, Y+4	; 0x04
    84da:	27 ec       	ldi	r18, 0xC7	; 199
    84dc:	31 e2       	ldi	r19, 0x21	; 33
    84de:	bc 01       	movw	r22, r24
    84e0:	cd 01       	movw	r24, r26
    84e2:	a9 01       	movw	r20, r18
    84e4:	20 e0       	ldi	r18, 0x00	; 0
    84e6:	32 e0       	ldi	r19, 0x02	; 2
    84e8:	0e 94 f1 4e 	call	0x9de2	; 0x9de2 <SD_write_block>

return (0);
    84ec:	80 e0       	ldi	r24, 0x00	; 0
    84ee:	90 e0       	ldi	r25, 0x00	; 0
    84f0:	dc 01       	movw	r26, r24
}
    84f2:	bc 01       	movw	r22, r24
    84f4:	cd 01       	movw	r24, r26
    84f6:	61 96       	adiw	r28, 0x11	; 17
    84f8:	cd bf       	out	0x3d, r28	; 61
    84fa:	de bf       	out	0x3e, r29	; 62
    84fc:	df 91       	pop	r29
    84fe:	cf 91       	pop	r28
    8500:	1f 91       	pop	r17
    8502:	0f 91       	pop	r16
    8504:	ff 90       	pop	r15
    8506:	ef 90       	pop	r14
    8508:	08 95       	ret

0000850a <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    850a:	cf 93       	push	r28
    850c:	df 93       	push	r29
    850e:	cd b7       	in	r28, 0x3d	; 61
    8510:	de b7       	in	r29, 0x3e	; 62
    8512:	28 97       	sbiw	r28, 0x08	; 8
    8514:	cd bf       	out	0x3d, r28	; 61
    8516:	de bf       	out	0x3e, r29	; 62
    8518:	8b 83       	std	Y+3, r24	; 0x03
    851a:	6c 83       	std	Y+4, r22	; 0x04
    851c:	2d 83       	std	Y+5, r18	; 0x05
    851e:	3e 83       	std	Y+6, r19	; 0x06
    8520:	4f 83       	std	Y+7, r20	; 0x07
    8522:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    8524:	87 ec       	ldi	r24, 0xC7	; 199
    8526:	91 e2       	ldi	r25, 0x21	; 33
    8528:	89 83       	std	Y+1, r24	; 0x01
    852a:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    852c:	80 91 6e 50 	lds	r24, 0x506E
    8530:	90 91 6f 50 	lds	r25, 0x506F
    8534:	a0 91 70 50 	lds	r26, 0x5070
    8538:	b0 91 71 50 	lds	r27, 0x5071
    853c:	01 96       	adiw	r24, 0x01	; 1
    853e:	a1 1d       	adc	r26, r1
    8540:	b1 1d       	adc	r27, r1
    8542:	27 ec       	ldi	r18, 0xC7	; 199
    8544:	31 e2       	ldi	r19, 0x21	; 33
    8546:	bc 01       	movw	r22, r24
    8548:	cd 01       	movw	r24, r26
    854a:	a9 01       	movw	r20, r18
    854c:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    8550:	89 81       	ldd	r24, Y+1	; 0x01
    8552:	9a 81       	ldd	r25, Y+2	; 0x02
    8554:	fc 01       	movw	r30, r24
    8556:	80 81       	ld	r24, Z
    8558:	91 81       	ldd	r25, Z+1	; 0x01
    855a:	a2 81       	ldd	r26, Z+2	; 0x02
    855c:	b3 81       	ldd	r27, Z+3	; 0x03
    855e:	82 35       	cpi	r24, 0x52	; 82
    8560:	f2 e5       	ldi	r31, 0x52	; 82
    8562:	9f 07       	cpc	r25, r31
    8564:	f1 e6       	ldi	r31, 0x61	; 97
    8566:	af 07       	cpc	r26, r31
    8568:	f1 e4       	ldi	r31, 0x41	; 65
    856a:	bf 07       	cpc	r27, r31
    856c:	11 f5       	brne	.+68     	; 0x85b2 <getSetFreeCluster+0xa8>
    856e:	89 81       	ldd	r24, Y+1	; 0x01
    8570:	9a 81       	ldd	r25, Y+2	; 0x02
    8572:	8c 51       	subi	r24, 0x1C	; 28
    8574:	9e 4f       	sbci	r25, 0xFE	; 254
    8576:	fc 01       	movw	r30, r24
    8578:	80 81       	ld	r24, Z
    857a:	91 81       	ldd	r25, Z+1	; 0x01
    857c:	a2 81       	ldd	r26, Z+2	; 0x02
    857e:	b3 81       	ldd	r27, Z+3	; 0x03
    8580:	82 37       	cpi	r24, 0x72	; 114
    8582:	f2 e7       	ldi	r31, 0x72	; 114
    8584:	9f 07       	cpc	r25, r31
    8586:	f1 e4       	ldi	r31, 0x41	; 65
    8588:	af 07       	cpc	r26, r31
    858a:	f1 e6       	ldi	r31, 0x61	; 97
    858c:	bf 07       	cpc	r27, r31
    858e:	89 f4       	brne	.+34     	; 0x85b2 <getSetFreeCluster+0xa8>
    8590:	89 81       	ldd	r24, Y+1	; 0x01
    8592:	9a 81       	ldd	r25, Y+2	; 0x02
    8594:	84 50       	subi	r24, 0x04	; 4
    8596:	9e 4f       	sbci	r25, 0xFE	; 254
    8598:	fc 01       	movw	r30, r24
    859a:	80 81       	ld	r24, Z
    859c:	91 81       	ldd	r25, Z+1	; 0x01
    859e:	a2 81       	ldd	r26, Z+2	; 0x02
    85a0:	b3 81       	ldd	r27, Z+3	; 0x03
    85a2:	80 30       	cpi	r24, 0x00	; 0
    85a4:	f0 e0       	ldi	r31, 0x00	; 0
    85a6:	9f 07       	cpc	r25, r31
    85a8:	f5 e5       	ldi	r31, 0x55	; 85
    85aa:	af 07       	cpc	r26, r31
    85ac:	fa ea       	ldi	r31, 0xAA	; 170
    85ae:	bf 07       	cpc	r27, r31
    85b0:	21 f0       	breq	.+8      	; 0x85ba <getSetFreeCluster+0xb0>
  return 0xffffffff;
    85b2:	8f ef       	ldi	r24, 0xFF	; 255
    85b4:	9f ef       	ldi	r25, 0xFF	; 255
    85b6:	dc 01       	movw	r26, r24
    85b8:	51 c0       	rjmp	.+162    	; 0x865c <getSetFreeCluster+0x152>

 if(get_set == GET)
    85ba:	8c 81       	ldd	r24, Y+4	; 0x04
    85bc:	88 23       	and	r24, r24
    85be:	b9 f4       	brne	.+46     	; 0x85ee <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    85c0:	8b 81       	ldd	r24, Y+3	; 0x03
    85c2:	81 30       	cpi	r24, 0x01	; 1
    85c4:	51 f4       	brne	.+20     	; 0x85da <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    85c6:	89 81       	ldd	r24, Y+1	; 0x01
    85c8:	9a 81       	ldd	r25, Y+2	; 0x02
    85ca:	88 51       	subi	r24, 0x18	; 24
    85cc:	9e 4f       	sbci	r25, 0xFE	; 254
    85ce:	fc 01       	movw	r30, r24
    85d0:	80 81       	ld	r24, Z
    85d2:	91 81       	ldd	r25, Z+1	; 0x01
    85d4:	a2 81       	ldd	r26, Z+2	; 0x02
    85d6:	b3 81       	ldd	r27, Z+3	; 0x03
    85d8:	41 c0       	rjmp	.+130    	; 0x865c <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    85da:	89 81       	ldd	r24, Y+1	; 0x01
    85dc:	9a 81       	ldd	r25, Y+2	; 0x02
    85de:	84 51       	subi	r24, 0x14	; 20
    85e0:	9e 4f       	sbci	r25, 0xFE	; 254
    85e2:	fc 01       	movw	r30, r24
    85e4:	80 81       	ld	r24, Z
    85e6:	91 81       	ldd	r25, Z+1	; 0x01
    85e8:	a2 81       	ldd	r26, Z+2	; 0x02
    85ea:	b3 81       	ldd	r27, Z+3	; 0x03
    85ec:	37 c0       	rjmp	.+110    	; 0x865c <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    85ee:	8b 81       	ldd	r24, Y+3	; 0x03
    85f0:	81 30       	cpi	r24, 0x01	; 1
    85f2:	79 f4       	brne	.+30     	; 0x8612 <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    85f4:	89 81       	ldd	r24, Y+1	; 0x01
    85f6:	9a 81       	ldd	r25, Y+2	; 0x02
    85f8:	9c 01       	movw	r18, r24
    85fa:	28 51       	subi	r18, 0x18	; 24
    85fc:	3e 4f       	sbci	r19, 0xFE	; 254
    85fe:	8d 81       	ldd	r24, Y+5	; 0x05
    8600:	9e 81       	ldd	r25, Y+6	; 0x06
    8602:	af 81       	ldd	r26, Y+7	; 0x07
    8604:	b8 85       	ldd	r27, Y+8	; 0x08
    8606:	f9 01       	movw	r30, r18
    8608:	80 83       	st	Z, r24
    860a:	91 83       	std	Z+1, r25	; 0x01
    860c:	a2 83       	std	Z+2, r26	; 0x02
    860e:	b3 83       	std	Z+3, r27	; 0x03
    8610:	0e c0       	rjmp	.+28     	; 0x862e <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    8612:	89 81       	ldd	r24, Y+1	; 0x01
    8614:	9a 81       	ldd	r25, Y+2	; 0x02
    8616:	9c 01       	movw	r18, r24
    8618:	24 51       	subi	r18, 0x14	; 20
    861a:	3e 4f       	sbci	r19, 0xFE	; 254
    861c:	8d 81       	ldd	r24, Y+5	; 0x05
    861e:	9e 81       	ldd	r25, Y+6	; 0x06
    8620:	af 81       	ldd	r26, Y+7	; 0x07
    8622:	b8 85       	ldd	r27, Y+8	; 0x08
    8624:	f9 01       	movw	r30, r18
    8626:	80 83       	st	Z, r24
    8628:	91 83       	std	Z+1, r25	; 0x01
    862a:	a2 83       	std	Z+2, r26	; 0x02
    862c:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    862e:	80 91 6e 50 	lds	r24, 0x506E
    8632:	90 91 6f 50 	lds	r25, 0x506F
    8636:	a0 91 70 50 	lds	r26, 0x5070
    863a:	b0 91 71 50 	lds	r27, 0x5071
    863e:	01 96       	adiw	r24, 0x01	; 1
    8640:	a1 1d       	adc	r26, r1
    8642:	b1 1d       	adc	r27, r1
    8644:	27 ec       	ldi	r18, 0xC7	; 199
    8646:	31 e2       	ldi	r19, 0x21	; 33
    8648:	bc 01       	movw	r22, r24
    864a:	cd 01       	movw	r24, r26
    864c:	a9 01       	movw	r20, r18
    864e:	20 e0       	ldi	r18, 0x00	; 0
    8650:	32 e0       	ldi	r19, 0x02	; 2
    8652:	0e 94 f1 4e 	call	0x9de2	; 0x9de2 <SD_write_block>
 }
 return 0xffffffff;
    8656:	8f ef       	ldi	r24, 0xFF	; 255
    8658:	9f ef       	ldi	r25, 0xFF	; 255
    865a:	dc 01       	movw	r26, r24
}
    865c:	bc 01       	movw	r22, r24
    865e:	cd 01       	movw	r24, r26
    8660:	28 96       	adiw	r28, 0x08	; 8
    8662:	cd bf       	out	0x3d, r28	; 61
    8664:	de bf       	out	0x3e, r29	; 62
    8666:	df 91       	pop	r29
    8668:	cf 91       	pop	r28
    866a:	08 95       	ret

0000866c <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    866c:	0f 93       	push	r16
    866e:	1f 93       	push	r17
    8670:	cf 93       	push	r28
    8672:	df 93       	push	r29
    8674:	cd b7       	in	r28, 0x3d	; 61
    8676:	de b7       	in	r29, 0x3e	; 62
    8678:	6c 97       	sbiw	r28, 0x1c	; 28
    867a:	cd bf       	out	0x3d, r28	; 61
    867c:	de bf       	out	0x3e, r29	; 62
    867e:	8a 8f       	std	Y+26, r24	; 0x1a
    8680:	6b 8f       	std	Y+27, r22	; 0x1b
    8682:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    8684:	80 91 50 40 	lds	r24, 0x4050
    8688:	90 91 51 40 	lds	r25, 0x4051
    868c:	a0 91 52 40 	lds	r26, 0x4052
    8690:	b0 91 53 40 	lds	r27, 0x4053
    8694:	89 83       	std	Y+1, r24	; 0x01
    8696:	9a 83       	std	Y+2, r25	; 0x02
    8698:	ab 83       	std	Y+3, r26	; 0x03
    869a:	bc 83       	std	Y+4, r27	; 0x04
    869c:	01 c0       	rjmp	.+2      	; 0x86a0 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    869e:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    86a0:	89 81       	ldd	r24, Y+1	; 0x01
    86a2:	9a 81       	ldd	r25, Y+2	; 0x02
    86a4:	ab 81       	ldd	r26, Y+3	; 0x03
    86a6:	bc 81       	ldd	r27, Y+4	; 0x04
    86a8:	bc 01       	movw	r22, r24
    86aa:	cd 01       	movw	r24, r26
    86ac:	0e 94 aa 41 	call	0x8354	; 0x8354 <getFirstSector>
    86b0:	dc 01       	movw	r26, r24
    86b2:	cb 01       	movw	r24, r22
    86b4:	88 8b       	std	Y+16, r24	; 0x10
    86b6:	99 8b       	std	Y+17, r25	; 0x11
    86b8:	aa 8b       	std	Y+18, r26	; 0x12
    86ba:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    86bc:	1d 82       	std	Y+5, r1	; 0x05
    86be:	1e 82       	std	Y+6, r1	; 0x06
    86c0:	1f 82       	std	Y+7, r1	; 0x07
    86c2:	18 86       	std	Y+8, r1	; 0x08
    86c4:	68 c1       	rjmp	.+720    	; 0x8996 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    86c6:	28 89       	ldd	r18, Y+16	; 0x10
    86c8:	39 89       	ldd	r19, Y+17	; 0x11
    86ca:	4a 89       	ldd	r20, Y+18	; 0x12
    86cc:	5b 89       	ldd	r21, Y+19	; 0x13
    86ce:	8d 81       	ldd	r24, Y+5	; 0x05
    86d0:	9e 81       	ldd	r25, Y+6	; 0x06
    86d2:	af 81       	ldd	r26, Y+7	; 0x07
    86d4:	b8 85       	ldd	r27, Y+8	; 0x08
    86d6:	82 0f       	add	r24, r18
    86d8:	93 1f       	adc	r25, r19
    86da:	a4 1f       	adc	r26, r20
    86dc:	b5 1f       	adc	r27, r21
    86de:	27 ec       	ldi	r18, 0xC7	; 199
    86e0:	31 e2       	ldi	r19, 0x21	; 33
    86e2:	bc 01       	movw	r22, r24
    86e4:	cd 01       	movw	r24, r26
    86e6:	a9 01       	movw	r20, r18
    86e8:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    86ec:	1d 86       	std	Y+13, r1	; 0x0d
    86ee:	1e 86       	std	Y+14, r1	; 0x0e
    86f0:	3d c1       	rjmp	.+634    	; 0x896c <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    86f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    86f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    86f6:	89 53       	subi	r24, 0x39	; 57
    86f8:	9e 4d       	sbci	r25, 0xDE	; 222
    86fa:	8c 8b       	std	Y+20, r24	; 0x14
    86fc:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    86fe:	8c 89       	ldd	r24, Y+20	; 0x14
    8700:	9d 89       	ldd	r25, Y+21	; 0x15
    8702:	fc 01       	movw	r30, r24
    8704:	80 81       	ld	r24, Z
    8706:	88 23       	and	r24, r24
    8708:	19 f4       	brne	.+6      	; 0x8710 <findFiles+0xa4>
		{
		  return 0;   
    870a:	80 e0       	ldi	r24, 0x00	; 0
    870c:	90 e0       	ldi	r25, 0x00	; 0
    870e:	80 c1       	rjmp	.+768    	; 0x8a10 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    8710:	8c 89       	ldd	r24, Y+20	; 0x14
    8712:	9d 89       	ldd	r25, Y+21	; 0x15
    8714:	fc 01       	movw	r30, r24
    8716:	80 81       	ld	r24, Z
    8718:	85 3e       	cpi	r24, 0xE5	; 229
    871a:	09 f4       	brne	.+2      	; 0x871e <findFiles+0xb2>
    871c:	22 c1       	rjmp	.+580    	; 0x8962 <findFiles+0x2f6>
    871e:	8c 89       	ldd	r24, Y+20	; 0x14
    8720:	9d 89       	ldd	r25, Y+21	; 0x15
    8722:	fc 01       	movw	r30, r24
    8724:	83 85       	ldd	r24, Z+11	; 0x0b
    8726:	8f 30       	cpi	r24, 0x0F	; 15
    8728:	09 f4       	brne	.+2      	; 0x872c <findFiles+0xc0>
    872a:	1b c1       	rjmp	.+566    	; 0x8962 <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    872c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    872e:	81 30       	cpi	r24, 0x01	; 1
    8730:	21 f0       	breq	.+8      	; 0x873a <findFiles+0xce>
    8732:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8734:	82 30       	cpi	r24, 0x02	; 2
    8736:	09 f0       	breq	.+2      	; 0x873a <findFiles+0xce>
    8738:	11 c1       	rjmp	.+546    	; 0x895c <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    873a:	1f 86       	std	Y+15, r1	; 0x0f
    873c:	17 c0       	rjmp	.+46     	; 0x876c <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    873e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8740:	88 2f       	mov	r24, r24
    8742:	90 e0       	ldi	r25, 0x00	; 0
    8744:	2c 89       	ldd	r18, Y+20	; 0x14
    8746:	3d 89       	ldd	r19, Y+21	; 0x15
    8748:	82 0f       	add	r24, r18
    874a:	93 1f       	adc	r25, r19
    874c:	fc 01       	movw	r30, r24
    874e:	40 81       	ld	r20, Z
    8750:	8f 85       	ldd	r24, Y+15	; 0x0f
    8752:	88 2f       	mov	r24, r24
    8754:	90 e0       	ldi	r25, 0x00	; 0
    8756:	2b 8d       	ldd	r18, Y+27	; 0x1b
    8758:	3c 8d       	ldd	r19, Y+28	; 0x1c
    875a:	82 0f       	add	r24, r18
    875c:	93 1f       	adc	r25, r19
    875e:	fc 01       	movw	r30, r24
    8760:	80 81       	ld	r24, Z
    8762:	48 17       	cp	r20, r24
    8764:	39 f4       	brne	.+14     	; 0x8774 <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    8766:	8f 85       	ldd	r24, Y+15	; 0x0f
    8768:	8f 5f       	subi	r24, 0xFF	; 255
    876a:	8f 87       	std	Y+15, r24	; 0x0f
    876c:	8f 85       	ldd	r24, Y+15	; 0x0f
    876e:	8b 30       	cpi	r24, 0x0B	; 11
    8770:	30 f3       	brcs	.-52     	; 0x873e <findFiles+0xd2>
    8772:	01 c0       	rjmp	.+2      	; 0x8776 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    8774:	00 00       	nop
            if(j == 11)
    8776:	8f 85       	ldd	r24, Y+15	; 0x0f
    8778:	8b 30       	cpi	r24, 0x0B	; 11
    877a:	09 f0       	breq	.+2      	; 0x877e <findFiles+0x112>
    877c:	f2 c0       	rjmp	.+484    	; 0x8962 <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    877e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8780:	81 30       	cpi	r24, 0x01	; 1
    8782:	09 f0       	breq	.+2      	; 0x8786 <findFiles+0x11a>
    8784:	52 c0       	rjmp	.+164    	; 0x882a <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    8786:	28 89       	ldd	r18, Y+16	; 0x10
    8788:	39 89       	ldd	r19, Y+17	; 0x11
    878a:	4a 89       	ldd	r20, Y+18	; 0x12
    878c:	5b 89       	ldd	r21, Y+19	; 0x13
    878e:	8d 81       	ldd	r24, Y+5	; 0x05
    8790:	9e 81       	ldd	r25, Y+6	; 0x06
    8792:	af 81       	ldd	r26, Y+7	; 0x07
    8794:	b8 85       	ldd	r27, Y+8	; 0x08
    8796:	82 0f       	add	r24, r18
    8798:	93 1f       	adc	r25, r19
    879a:	a4 1f       	adc	r26, r20
    879c:	b5 1f       	adc	r27, r21
    879e:	80 93 c2 50 	sts	0x50C2, r24
    87a2:	90 93 c3 50 	sts	0x50C3, r25
    87a6:	a0 93 c4 50 	sts	0x50C4, r26
    87aa:	b0 93 c5 50 	sts	0x50C5, r27
				appendFileLocation = i;
    87ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    87b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    87b2:	cc 01       	movw	r24, r24
    87b4:	a0 e0       	ldi	r26, 0x00	; 0
    87b6:	b0 e0       	ldi	r27, 0x00	; 0
    87b8:	80 93 c8 23 	sts	0x23C8, r24
    87bc:	90 93 c9 23 	sts	0x23C9, r25
    87c0:	a0 93 ca 23 	sts	0x23CA, r26
    87c4:	b0 93 cb 23 	sts	0x23CB, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    87c8:	8c 89       	ldd	r24, Y+20	; 0x14
    87ca:	9d 89       	ldd	r25, Y+21	; 0x15
    87cc:	fc 01       	movw	r30, r24
    87ce:	84 89       	ldd	r24, Z+20	; 0x14
    87d0:	95 89       	ldd	r25, Z+21	; 0x15
    87d2:	cc 01       	movw	r24, r24
    87d4:	a0 e0       	ldi	r26, 0x00	; 0
    87d6:	b0 e0       	ldi	r27, 0x00	; 0
    87d8:	ac 01       	movw	r20, r24
    87da:	33 27       	eor	r19, r19
    87dc:	22 27       	eor	r18, r18
    87de:	8c 89       	ldd	r24, Y+20	; 0x14
    87e0:	9d 89       	ldd	r25, Y+21	; 0x15
    87e2:	fc 01       	movw	r30, r24
    87e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    87e6:	93 8d       	ldd	r25, Z+27	; 0x1b
    87e8:	cc 01       	movw	r24, r24
    87ea:	a0 e0       	ldi	r26, 0x00	; 0
    87ec:	b0 e0       	ldi	r27, 0x00	; 0
    87ee:	82 2b       	or	r24, r18
    87f0:	93 2b       	or	r25, r19
    87f2:	a4 2b       	or	r26, r20
    87f4:	b5 2b       	or	r27, r21
    87f6:	80 93 78 50 	sts	0x5078, r24
    87fa:	90 93 79 50 	sts	0x5079, r25
    87fe:	a0 93 7a 50 	sts	0x507A, r26
    8802:	b0 93 7b 50 	sts	0x507B, r27
				fileSize = dir->fileSize;
    8806:	8c 89       	ldd	r24, Y+20	; 0x14
    8808:	9d 89       	ldd	r25, Y+21	; 0x15
    880a:	fc 01       	movw	r30, r24
    880c:	84 8d       	ldd	r24, Z+28	; 0x1c
    880e:	95 8d       	ldd	r25, Z+29	; 0x1d
    8810:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8812:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8814:	80 93 41 40 	sts	0x4041, r24
    8818:	90 93 42 40 	sts	0x4042, r25
    881c:	a0 93 43 40 	sts	0x4043, r26
    8820:	b0 93 44 40 	sts	0x4044, r27
			    return (dir);
    8824:	8c 89       	ldd	r24, Y+20	; 0x14
    8826:	9d 89       	ldd	r25, Y+21	; 0x15
    8828:	f3 c0       	rjmp	.+486    	; 0x8a10 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    882a:	8c 89       	ldd	r24, Y+20	; 0x14
    882c:	9d 89       	ldd	r25, Y+21	; 0x15
    882e:	fc 01       	movw	r30, r24
    8830:	84 89       	ldd	r24, Z+20	; 0x14
    8832:	95 89       	ldd	r25, Z+21	; 0x15
    8834:	cc 01       	movw	r24, r24
    8836:	a0 e0       	ldi	r26, 0x00	; 0
    8838:	b0 e0       	ldi	r27, 0x00	; 0
    883a:	ac 01       	movw	r20, r24
    883c:	33 27       	eor	r19, r19
    883e:	22 27       	eor	r18, r18
    8840:	8c 89       	ldd	r24, Y+20	; 0x14
    8842:	9d 89       	ldd	r25, Y+21	; 0x15
    8844:	fc 01       	movw	r30, r24
    8846:	82 8d       	ldd	r24, Z+26	; 0x1a
    8848:	93 8d       	ldd	r25, Z+27	; 0x1b
    884a:	cc 01       	movw	r24, r24
    884c:	a0 e0       	ldi	r26, 0x00	; 0
    884e:	b0 e0       	ldi	r27, 0x00	; 0
    8850:	82 2b       	or	r24, r18
    8852:	93 2b       	or	r25, r19
    8854:	a4 2b       	or	r26, r20
    8856:	b5 2b       	or	r27, r21
    8858:	89 87       	std	Y+9, r24	; 0x09
    885a:	9a 87       	std	Y+10, r25	; 0x0a
    885c:	ab 87       	std	Y+11, r26	; 0x0b
    885e:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8860:	8c 89       	ldd	r24, Y+20	; 0x14
    8862:	9d 89       	ldd	r25, Y+21	; 0x15
    8864:	25 ee       	ldi	r18, 0xE5	; 229
    8866:	fc 01       	movw	r30, r24
    8868:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    886a:	28 89       	ldd	r18, Y+16	; 0x10
    886c:	39 89       	ldd	r19, Y+17	; 0x11
    886e:	4a 89       	ldd	r20, Y+18	; 0x12
    8870:	5b 89       	ldd	r21, Y+19	; 0x13
    8872:	8d 81       	ldd	r24, Y+5	; 0x05
    8874:	9e 81       	ldd	r25, Y+6	; 0x06
    8876:	af 81       	ldd	r26, Y+7	; 0x07
    8878:	b8 85       	ldd	r27, Y+8	; 0x08
    887a:	82 0f       	add	r24, r18
    887c:	93 1f       	adc	r25, r19
    887e:	a4 1f       	adc	r26, r20
    8880:	b5 1f       	adc	r27, r21
    8882:	27 ec       	ldi	r18, 0xC7	; 199
    8884:	31 e2       	ldi	r19, 0x21	; 33
    8886:	bc 01       	movw	r22, r24
    8888:	cd 01       	movw	r24, r26
    888a:	a9 01       	movw	r20, r18
    888c:	20 e0       	ldi	r18, 0x00	; 0
    888e:	32 e0       	ldi	r19, 0x02	; 2
    8890:	0e 94 f1 4e 	call	0x9de2	; 0x9de2 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8894:	8c 89       	ldd	r24, Y+20	; 0x14
    8896:	9d 89       	ldd	r25, Y+21	; 0x15
    8898:	fc 01       	movw	r30, r24
    889a:	24 8d       	ldd	r18, Z+28	; 0x1c
    889c:	35 8d       	ldd	r19, Z+29	; 0x1d
    889e:	46 8d       	ldd	r20, Z+30	; 0x1e
    88a0:	57 8d       	ldd	r21, Z+31	; 0x1f
    88a2:	80 e0       	ldi	r24, 0x00	; 0
    88a4:	ba 01       	movw	r22, r20
    88a6:	a9 01       	movw	r20, r18
    88a8:	0e 94 92 4b 	call	0x9724	; 0x9724 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    88ac:	82 e0       	ldi	r24, 0x02	; 2
    88ae:	60 e0       	ldi	r22, 0x00	; 0
    88b0:	20 e0       	ldi	r18, 0x00	; 0
    88b2:	30 e0       	ldi	r19, 0x00	; 0
    88b4:	a9 01       	movw	r20, r18
    88b6:	0e 94 85 42 	call	0x850a	; 0x850a <getSetFreeCluster>
    88ba:	dc 01       	movw	r26, r24
    88bc:	cb 01       	movw	r24, r22
    88be:	89 83       	std	Y+1, r24	; 0x01
    88c0:	9a 83       	std	Y+2, r25	; 0x02
    88c2:	ab 83       	std	Y+3, r26	; 0x03
    88c4:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    88c6:	29 85       	ldd	r18, Y+9	; 0x09
    88c8:	3a 85       	ldd	r19, Y+10	; 0x0a
    88ca:	4b 85       	ldd	r20, Y+11	; 0x0b
    88cc:	5c 85       	ldd	r21, Y+12	; 0x0c
    88ce:	89 81       	ldd	r24, Y+1	; 0x01
    88d0:	9a 81       	ldd	r25, Y+2	; 0x02
    88d2:	ab 81       	ldd	r26, Y+3	; 0x03
    88d4:	bc 81       	ldd	r27, Y+4	; 0x04
    88d6:	28 17       	cp	r18, r24
    88d8:	39 07       	cpc	r19, r25
    88da:	4a 07       	cpc	r20, r26
    88dc:	5b 07       	cpc	r21, r27
    88de:	40 f4       	brcc	.+16     	; 0x88f0 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    88e0:	29 85       	ldd	r18, Y+9	; 0x09
    88e2:	3a 85       	ldd	r19, Y+10	; 0x0a
    88e4:	4b 85       	ldd	r20, Y+11	; 0x0b
    88e6:	5c 85       	ldd	r21, Y+12	; 0x0c
    88e8:	82 e0       	ldi	r24, 0x02	; 2
    88ea:	61 e0       	ldi	r22, 0x01	; 1
    88ec:	0e 94 85 42 	call	0x850a	; 0x850a <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    88f0:	89 85       	ldd	r24, Y+9	; 0x09
    88f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    88f4:	ab 85       	ldd	r26, Y+11	; 0x0b
    88f6:	bc 85       	ldd	r27, Y+12	; 0x0c
    88f8:	bc 01       	movw	r22, r24
    88fa:	cd 01       	movw	r24, r26
    88fc:	40 e0       	ldi	r20, 0x00	; 0
    88fe:	00 e0       	ldi	r16, 0x00	; 0
    8900:	10 e0       	ldi	r17, 0x00	; 0
    8902:	98 01       	movw	r18, r16
    8904:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
    8908:	dc 01       	movw	r26, r24
    890a:	cb 01       	movw	r24, r22
    890c:	8e 8b       	std	Y+22, r24	; 0x16
    890e:	9f 8b       	std	Y+23, r25	; 0x17
    8910:	a8 8f       	std	Y+24, r26	; 0x18
    8912:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8914:	89 85       	ldd	r24, Y+9	; 0x09
    8916:	9a 85       	ldd	r25, Y+10	; 0x0a
    8918:	ab 85       	ldd	r26, Y+11	; 0x0b
    891a:	bc 85       	ldd	r27, Y+12	; 0x0c
    891c:	bc 01       	movw	r22, r24
    891e:	cd 01       	movw	r24, r26
    8920:	41 e0       	ldi	r20, 0x01	; 1
    8922:	00 e0       	ldi	r16, 0x00	; 0
    8924:	10 e0       	ldi	r17, 0x00	; 0
    8926:	98 01       	movw	r18, r16
    8928:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    892c:	8e 89       	ldd	r24, Y+22	; 0x16
    892e:	9f 89       	ldd	r25, Y+23	; 0x17
    8930:	a8 8d       	ldd	r26, Y+24	; 0x18
    8932:	b9 8d       	ldd	r27, Y+25	; 0x19
    8934:	87 3f       	cpi	r24, 0xF7	; 247
    8936:	ff ef       	ldi	r31, 0xFF	; 255
    8938:	9f 07       	cpc	r25, r31
    893a:	ff ef       	ldi	r31, 0xFF	; 255
    893c:	af 07       	cpc	r26, r31
    893e:	ff e0       	ldi	r31, 0x0F	; 15
    8940:	bf 07       	cpc	r27, r31
    8942:	18 f0       	brcs	.+6      	; 0x894a <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    8944:	80 e0       	ldi	r24, 0x00	; 0
    8946:	90 e0       	ldi	r25, 0x00	; 0
    8948:	63 c0       	rjmp	.+198    	; 0x8a10 <findFiles+0x3a4>
					firstCluster = nextCluster;
    894a:	8e 89       	ldd	r24, Y+22	; 0x16
    894c:	9f 89       	ldd	r25, Y+23	; 0x17
    894e:	a8 8d       	ldd	r26, Y+24	; 0x18
    8950:	b9 8d       	ldd	r27, Y+25	; 0x19
    8952:	89 87       	std	Y+9, r24	; 0x09
    8954:	9a 87       	std	Y+10, r25	; 0x0a
    8956:	ab 87       	std	Y+11, r26	; 0x0b
    8958:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    895a:	ca cf       	rjmp	.-108    	; 0x88f0 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    895c:	80 e0       	ldi	r24, 0x00	; 0
    895e:	90 e0       	ldi	r25, 0x00	; 0
    8960:	57 c0       	rjmp	.+174    	; 0x8a10 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8962:	8d 85       	ldd	r24, Y+13	; 0x0d
    8964:	9e 85       	ldd	r25, Y+14	; 0x0e
    8966:	80 96       	adiw	r24, 0x20	; 32
    8968:	8d 87       	std	Y+13, r24	; 0x0d
    896a:	9e 87       	std	Y+14, r25	; 0x0e
    896c:	80 91 45 40 	lds	r24, 0x4045
    8970:	90 91 46 40 	lds	r25, 0x4046
    8974:	2d 85       	ldd	r18, Y+13	; 0x0d
    8976:	3e 85       	ldd	r19, Y+14	; 0x0e
    8978:	28 17       	cp	r18, r24
    897a:	39 07       	cpc	r19, r25
    897c:	08 f4       	brcc	.+2      	; 0x8980 <findFiles+0x314>
    897e:	b9 ce       	rjmp	.-654    	; 0x86f2 <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8980:	8d 81       	ldd	r24, Y+5	; 0x05
    8982:	9e 81       	ldd	r25, Y+6	; 0x06
    8984:	af 81       	ldd	r26, Y+7	; 0x07
    8986:	b8 85       	ldd	r27, Y+8	; 0x08
    8988:	01 96       	adiw	r24, 0x01	; 1
    898a:	a1 1d       	adc	r26, r1
    898c:	b1 1d       	adc	r27, r1
    898e:	8d 83       	std	Y+5, r24	; 0x05
    8990:	9e 83       	std	Y+6, r25	; 0x06
    8992:	af 83       	std	Y+7, r26	; 0x07
    8994:	b8 87       	std	Y+8, r27	; 0x08
    8996:	80 91 6c 50 	lds	r24, 0x506C
    899a:	90 91 6d 50 	lds	r25, 0x506D
    899e:	9c 01       	movw	r18, r24
    89a0:	40 e0       	ldi	r20, 0x00	; 0
    89a2:	50 e0       	ldi	r21, 0x00	; 0
    89a4:	8d 81       	ldd	r24, Y+5	; 0x05
    89a6:	9e 81       	ldd	r25, Y+6	; 0x06
    89a8:	af 81       	ldd	r26, Y+7	; 0x07
    89aa:	b8 85       	ldd	r27, Y+8	; 0x08
    89ac:	82 17       	cp	r24, r18
    89ae:	93 07       	cpc	r25, r19
    89b0:	a4 07       	cpc	r26, r20
    89b2:	b5 07       	cpc	r27, r21
    89b4:	08 f4       	brcc	.+2      	; 0x89b8 <findFiles+0x34c>
    89b6:	87 ce       	rjmp	.-754    	; 0x86c6 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    89b8:	89 81       	ldd	r24, Y+1	; 0x01
    89ba:	9a 81       	ldd	r25, Y+2	; 0x02
    89bc:	ab 81       	ldd	r26, Y+3	; 0x03
    89be:	bc 81       	ldd	r27, Y+4	; 0x04
    89c0:	bc 01       	movw	r22, r24
    89c2:	cd 01       	movw	r24, r26
    89c4:	40 e0       	ldi	r20, 0x00	; 0
    89c6:	00 e0       	ldi	r16, 0x00	; 0
    89c8:	10 e0       	ldi	r17, 0x00	; 0
    89ca:	98 01       	movw	r18, r16
    89cc:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
    89d0:	dc 01       	movw	r26, r24
    89d2:	cb 01       	movw	r24, r22
    89d4:	89 83       	std	Y+1, r24	; 0x01
    89d6:	9a 83       	std	Y+2, r25	; 0x02
    89d8:	ab 83       	std	Y+3, r26	; 0x03
    89da:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    89dc:	89 81       	ldd	r24, Y+1	; 0x01
    89de:	9a 81       	ldd	r25, Y+2	; 0x02
    89e0:	ab 81       	ldd	r26, Y+3	; 0x03
    89e2:	bc 81       	ldd	r27, Y+4	; 0x04
    89e4:	87 3f       	cpi	r24, 0xF7	; 247
    89e6:	2f ef       	ldi	r18, 0xFF	; 255
    89e8:	92 07       	cpc	r25, r18
    89ea:	2f ef       	ldi	r18, 0xFF	; 255
    89ec:	a2 07       	cpc	r26, r18
    89ee:	2f e0       	ldi	r18, 0x0F	; 15
    89f0:	b2 07       	cpc	r27, r18
    89f2:	18 f0       	brcs	.+6      	; 0x89fa <findFiles+0x38e>
   	 return 0;
    89f4:	80 e0       	ldi	r24, 0x00	; 0
    89f6:	90 e0       	ldi	r25, 0x00	; 0
    89f8:	0b c0       	rjmp	.+22     	; 0x8a10 <findFiles+0x3a4>
   if(cluster == 0) 
    89fa:	89 81       	ldd	r24, Y+1	; 0x01
    89fc:	9a 81       	ldd	r25, Y+2	; 0x02
    89fe:	ab 81       	ldd	r26, Y+3	; 0x03
    8a00:	bc 81       	ldd	r27, Y+4	; 0x04
    8a02:	00 97       	sbiw	r24, 0x00	; 0
    8a04:	a1 05       	cpc	r26, r1
    8a06:	b1 05       	cpc	r27, r1
    8a08:	09 f0       	breq	.+2      	; 0x8a0c <findFiles+0x3a0>
    8a0a:	49 ce       	rjmp	.-878    	; 0x869e <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8a0c:	80 e0       	ldi	r24, 0x00	; 0
    8a0e:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    8a10:	6c 96       	adiw	r28, 0x1c	; 28
    8a12:	cd bf       	out	0x3d, r28	; 61
    8a14:	de bf       	out	0x3e, r29	; 62
    8a16:	df 91       	pop	r29
    8a18:	cf 91       	pop	r28
    8a1a:	1f 91       	pop	r17
    8a1c:	0f 91       	pop	r16
    8a1e:	08 95       	ret

00008a20 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    8a20:	0f 93       	push	r16
    8a22:	1f 93       	push	r17
    8a24:	cf 93       	push	r28
    8a26:	df 93       	push	r29
    8a28:	cd b7       	in	r28, 0x3d	; 61
    8a2a:	de b7       	in	r29, 0x3e	; 62
    8a2c:	2f 97       	sbiw	r28, 0x0f	; 15
    8a2e:	cd bf       	out	0x3d, r28	; 61
    8a30:	de bf       	out	0x3e, r29	; 62
    8a32:	8d 87       	std	Y+13, r24	; 0x0d
    8a34:	6e 87       	std	Y+14, r22	; 0x0e
    8a36:	7f 87       	std	Y+15, r23	; 0x0f
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8a38:	8e 85       	ldd	r24, Y+14	; 0x0e
    8a3a:	9f 85       	ldd	r25, Y+15	; 0x0f
    8a3c:	0e 94 b0 45 	call	0x8b60	; 0x8b60 <convertFileName>
    8a40:	8e 83       	std	Y+6, r24	; 0x06
if(error) return 2;
    8a42:	8e 81       	ldd	r24, Y+6	; 0x06
    8a44:	88 23       	and	r24, r24
    8a46:	11 f0       	breq	.+4      	; 0x8a4c <readFile+0x2c>
    8a48:	82 e0       	ldi	r24, 0x02	; 2
    8a4a:	82 c0       	rjmp	.+260    	; 0x8b50 <readFile+0x130>

dir = findFiles (GET_FILE, Filename); //get the file location
    8a4c:	2c ea       	ldi	r18, 0xAC	; 172
    8a4e:	30 e5       	ldi	r19, 0x50	; 80
    8a50:	81 e0       	ldi	r24, 0x01	; 1
    8a52:	b9 01       	movw	r22, r18
    8a54:	0e 94 36 43 	call	0x866c	; 0x866c <findFiles>
    8a58:	8f 83       	std	Y+7, r24	; 0x07
    8a5a:	98 87       	std	Y+8, r25	; 0x08
if(dir == 0) 
    8a5c:	8f 81       	ldd	r24, Y+7	; 0x07
    8a5e:	98 85       	ldd	r25, Y+8	; 0x08
    8a60:	00 97       	sbiw	r24, 0x00	; 0
    8a62:	39 f4       	brne	.+14     	; 0x8a72 <readFile+0x52>
{
  if(flag == READ) return (1);
    8a64:	8d 85       	ldd	r24, Y+13	; 0x0d
    8a66:	88 23       	and	r24, r24
    8a68:	11 f4       	brne	.+4      	; 0x8a6e <readFile+0x4e>
    8a6a:	81 e0       	ldi	r24, 0x01	; 1
    8a6c:	71 c0       	rjmp	.+226    	; 0x8b50 <readFile+0x130>
  else return (0);
    8a6e:	80 e0       	ldi	r24, 0x00	; 0
    8a70:	6f c0       	rjmp	.+222    	; 0x8b50 <readFile+0x130>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8a72:	8d 85       	ldd	r24, Y+13	; 0x0d
    8a74:	81 30       	cpi	r24, 0x01	; 1
    8a76:	11 f4       	brne	.+4      	; 0x8a7c <readFile+0x5c>
    8a78:	81 e0       	ldi	r24, 0x01	; 1
    8a7a:	6a c0       	rjmp	.+212    	; 0x8b50 <readFile+0x130>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a7c:	8f 81       	ldd	r24, Y+7	; 0x07
    8a7e:	98 85       	ldd	r25, Y+8	; 0x08
    8a80:	fc 01       	movw	r30, r24
    8a82:	84 89       	ldd	r24, Z+20	; 0x14
    8a84:	95 89       	ldd	r25, Z+21	; 0x15
    8a86:	cc 01       	movw	r24, r24
    8a88:	a0 e0       	ldi	r26, 0x00	; 0
    8a8a:	b0 e0       	ldi	r27, 0x00	; 0
    8a8c:	ac 01       	movw	r20, r24
    8a8e:	33 27       	eor	r19, r19
    8a90:	22 27       	eor	r18, r18
    8a92:	8f 81       	ldd	r24, Y+7	; 0x07
    8a94:	98 85       	ldd	r25, Y+8	; 0x08
    8a96:	fc 01       	movw	r30, r24
    8a98:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a9a:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a9c:	cc 01       	movw	r24, r24
    8a9e:	a0 e0       	ldi	r26, 0x00	; 0
    8aa0:	b0 e0       	ldi	r27, 0x00	; 0
    8aa2:	82 2b       	or	r24, r18
    8aa4:	93 2b       	or	r25, r19
    8aa6:	a4 2b       	or	r26, r20
    8aa8:	b5 2b       	or	r27, r21
    8aaa:	89 83       	std	Y+1, r24	; 0x01
    8aac:	9a 83       	std	Y+2, r25	; 0x02
    8aae:	ab 83       	std	Y+3, r26	; 0x03
    8ab0:	bc 83       	std	Y+4, r27	; 0x04
    8ab2:	01 c0       	rjmp	.+2      	; 0x8ab6 <readFile+0x96>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8ab4:	00 00       	nop
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8ab6:	89 81       	ldd	r24, Y+1	; 0x01
    8ab8:	9a 81       	ldd	r25, Y+2	; 0x02
    8aba:	ab 81       	ldd	r26, Y+3	; 0x03
    8abc:	bc 81       	ldd	r27, Y+4	; 0x04
    8abe:	bc 01       	movw	r22, r24
    8ac0:	cd 01       	movw	r24, r26
    8ac2:	0e 94 aa 41 	call	0x8354	; 0x8354 <getFirstSector>
    8ac6:	dc 01       	movw	r26, r24
    8ac8:	cb 01       	movw	r24, r22
    8aca:	89 87       	std	Y+9, r24	; 0x09
    8acc:	9a 87       	std	Y+10, r25	; 0x0a
    8ace:	ab 87       	std	Y+11, r26	; 0x0b
    8ad0:	bc 87       	std	Y+12, r27	; 0x0c

  for(j=0; j<sectorPerCluster; j++)
    8ad2:	1d 82       	std	Y+5, r1	; 0x05
    8ad4:	17 c0       	rjmp	.+46     	; 0x8b04 <readFile+0xe4>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8ad6:	8d 81       	ldd	r24, Y+5	; 0x05
    8ad8:	28 2f       	mov	r18, r24
    8ada:	30 e0       	ldi	r19, 0x00	; 0
    8adc:	40 e0       	ldi	r20, 0x00	; 0
    8ade:	50 e0       	ldi	r21, 0x00	; 0
    8ae0:	89 85       	ldd	r24, Y+9	; 0x09
    8ae2:	9a 85       	ldd	r25, Y+10	; 0x0a
    8ae4:	ab 85       	ldd	r26, Y+11	; 0x0b
    8ae6:	bc 85       	ldd	r27, Y+12	; 0x0c
    8ae8:	82 0f       	add	r24, r18
    8aea:	93 1f       	adc	r25, r19
    8aec:	a4 1f       	adc	r26, r20
    8aee:	b5 1f       	adc	r27, r21
    8af0:	20 ed       	ldi	r18, 0xD0	; 208
    8af2:	33 e2       	ldi	r19, 0x23	; 35
    8af4:	bc 01       	movw	r22, r24
    8af6:	cd 01       	movw	r24, r26
    8af8:	a9 01       	movw	r20, r18
    8afa:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8afe:	8d 81       	ldd	r24, Y+5	; 0x05
    8b00:	8f 5f       	subi	r24, 0xFF	; 255
    8b02:	8d 83       	std	Y+5, r24	; 0x05
    8b04:	8d 81       	ldd	r24, Y+5	; 0x05
    8b06:	28 2f       	mov	r18, r24
    8b08:	30 e0       	ldi	r19, 0x00	; 0
    8b0a:	80 91 6c 50 	lds	r24, 0x506C
    8b0e:	90 91 6d 50 	lds	r25, 0x506D
    8b12:	28 17       	cp	r18, r24
    8b14:	39 07       	cpc	r19, r25
    8b16:	f8 f2       	brcs	.-66     	; 0x8ad6 <readFile+0xb6>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8b18:	89 81       	ldd	r24, Y+1	; 0x01
    8b1a:	9a 81       	ldd	r25, Y+2	; 0x02
    8b1c:	ab 81       	ldd	r26, Y+3	; 0x03
    8b1e:	bc 81       	ldd	r27, Y+4	; 0x04
    8b20:	bc 01       	movw	r22, r24
    8b22:	cd 01       	movw	r24, r26
    8b24:	40 e0       	ldi	r20, 0x00	; 0
    8b26:	00 e0       	ldi	r16, 0x00	; 0
    8b28:	10 e0       	ldi	r17, 0x00	; 0
    8b2a:	98 01       	movw	r18, r16
    8b2c:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
    8b30:	dc 01       	movw	r26, r24
    8b32:	cb 01       	movw	r24, r22
    8b34:	89 83       	std	Y+1, r24	; 0x01
    8b36:	9a 83       	std	Y+2, r25	; 0x02
    8b38:	ab 83       	std	Y+3, r26	; 0x03
    8b3a:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8b3c:	89 81       	ldd	r24, Y+1	; 0x01
    8b3e:	9a 81       	ldd	r25, Y+2	; 0x02
    8b40:	ab 81       	ldd	r26, Y+3	; 0x03
    8b42:	bc 81       	ldd	r27, Y+4	; 0x04
    8b44:	00 97       	sbiw	r24, 0x00	; 0
    8b46:	a1 05       	cpc	r26, r1
    8b48:	b1 05       	cpc	r27, r1
    8b4a:	09 f0       	breq	.+2      	; 0x8b4e <readFile+0x12e>
    8b4c:	b3 cf       	rjmp	.-154    	; 0x8ab4 <readFile+0x94>
	  return 0;}
    8b4e:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8b50:	2f 96       	adiw	r28, 0x0f	; 15
    8b52:	cd bf       	out	0x3d, r28	; 61
    8b54:	de bf       	out	0x3e, r29	; 62
    8b56:	df 91       	pop	r29
    8b58:	cf 91       	pop	r28
    8b5a:	1f 91       	pop	r17
    8b5c:	0f 91       	pop	r16
    8b5e:	08 95       	ret

00008b60 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8b60:	cf 93       	push	r28
    8b62:	df 93       	push	r29
    8b64:	cd b7       	in	r28, 0x3d	; 61
    8b66:	de b7       	in	r29, 0x3e	; 62
    8b68:	62 97       	sbiw	r28, 0x12	; 18
    8b6a:	cd bf       	out	0x3d, r28	; 61
    8b6c:	de bf       	out	0x3e, r29	; 62
    8b6e:	89 8b       	std	Y+17, r24	; 0x11
    8b70:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8b72:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    8b74:	89 89       	ldd	r24, Y+17	; 0x11
    8b76:	9a 89       	ldd	r25, Y+18	; 0x12
    8b78:	9c 01       	movw	r18, r24
    8b7a:	f9 01       	movw	r30, r18
    8b7c:	01 90       	ld	r0, Z+
    8b7e:	00 20       	and	r0, r0
    8b80:	e9 f7       	brne	.-6      	; 0x8b7c <convertFileName+0x1c>
    8b82:	cf 01       	movw	r24, r30
    8b84:	01 97       	sbiw	r24, 0x01	; 1
    8b86:	82 1b       	sub	r24, r18
    8b88:	93 0b       	sbc	r25, r19
    8b8a:	80 31       	cpi	r24, 0x10	; 16
    8b8c:	91 05       	cpc	r25, r1
    8b8e:	10 f0       	brcs	.+4      	; 0x8b94 <convertFileName+0x34>
    8b90:	81 e0       	ldi	r24, 0x01	; 1
    8b92:	16 c1       	rjmp	.+556    	; 0x8dc0 <convertFileName+0x260>
int i=0;
    8b94:	1c 82       	std	Y+4, r1	; 0x04
    8b96:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen((const char*)fileName); i++){
    8b98:	13 c0       	rjmp	.+38     	; 0x8bc0 <convertFileName+0x60>
	Filename[i] = fileName[i];
    8b9a:	8c 81       	ldd	r24, Y+4	; 0x04
    8b9c:	9d 81       	ldd	r25, Y+5	; 0x05
    8b9e:	29 89       	ldd	r18, Y+17	; 0x11
    8ba0:	3a 89       	ldd	r19, Y+18	; 0x12
    8ba2:	82 0f       	add	r24, r18
    8ba4:	93 1f       	adc	r25, r19
    8ba6:	fc 01       	movw	r30, r24
    8ba8:	20 81       	ld	r18, Z
    8baa:	8c 81       	ldd	r24, Y+4	; 0x04
    8bac:	9d 81       	ldd	r25, Y+5	; 0x05
    8bae:	84 55       	subi	r24, 0x54	; 84
    8bb0:	9f 4a       	sbci	r25, 0xAF	; 175
    8bb2:	fc 01       	movw	r30, r24
    8bb4:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    8bb6:	8c 81       	ldd	r24, Y+4	; 0x04
    8bb8:	9d 81       	ldd	r25, Y+5	; 0x05
    8bba:	01 96       	adiw	r24, 0x01	; 1
    8bbc:	8c 83       	std	Y+4, r24	; 0x04
    8bbe:	9d 83       	std	Y+5, r25	; 0x05
    8bc0:	4c 81       	ldd	r20, Y+4	; 0x04
    8bc2:	5d 81       	ldd	r21, Y+5	; 0x05
    8bc4:	89 89       	ldd	r24, Y+17	; 0x11
    8bc6:	9a 89       	ldd	r25, Y+18	; 0x12
    8bc8:	9c 01       	movw	r18, r24
    8bca:	f9 01       	movw	r30, r18
    8bcc:	01 90       	ld	r0, Z+
    8bce:	00 20       	and	r0, r0
    8bd0:	e9 f7       	brne	.-6      	; 0x8bcc <convertFileName+0x6c>
    8bd2:	cf 01       	movw	r24, r30
    8bd4:	01 97       	sbiw	r24, 0x01	; 1
    8bd6:	82 1b       	sub	r24, r18
    8bd8:	93 0b       	sbc	r25, r19
    8bda:	48 17       	cp	r20, r24
    8bdc:	59 07       	cpc	r21, r25
    8bde:	e8 f2       	brcs	.-70     	; 0x8b9a <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8be0:	0c c0       	rjmp	.+24     	; 0x8bfa <convertFileName+0x9a>
    8be2:	8c 81       	ldd	r24, Y+4	; 0x04
    8be4:	9d 81       	ldd	r25, Y+5	; 0x05
    8be6:	84 55       	subi	r24, 0x54	; 84
    8be8:	9f 4a       	sbci	r25, 0xAF	; 175
    8bea:	20 e2       	ldi	r18, 0x20	; 32
    8bec:	fc 01       	movw	r30, r24
    8bee:	20 83       	st	Z, r18
    8bf0:	8c 81       	ldd	r24, Y+4	; 0x04
    8bf2:	9d 81       	ldd	r25, Y+5	; 0x05
    8bf4:	01 96       	adiw	r24, 0x01	; 1
    8bf6:	8c 83       	std	Y+4, r24	; 0x04
    8bf8:	9d 83       	std	Y+5, r25	; 0x05
    8bfa:	8c 81       	ldd	r24, Y+4	; 0x04
    8bfc:	9d 81       	ldd	r25, Y+5	; 0x05
    8bfe:	8f 30       	cpi	r24, 0x0F	; 15
    8c00:	91 05       	cpc	r25, r1
    8c02:	7c f3       	brlt	.-34     	; 0x8be2 <convertFileName+0x82>


for(j=0; j<12; j++)
    8c04:	1a 82       	std	Y+2, r1	; 0x02
    8c06:	0c c0       	rjmp	.+24     	; 0x8c20 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8c08:	8a 81       	ldd	r24, Y+2	; 0x02
    8c0a:	88 2f       	mov	r24, r24
    8c0c:	90 e0       	ldi	r25, 0x00	; 0
    8c0e:	84 55       	subi	r24, 0x54	; 84
    8c10:	9f 4a       	sbci	r25, 0xAF	; 175
    8c12:	fc 01       	movw	r30, r24
    8c14:	80 81       	ld	r24, Z
    8c16:	8e 32       	cpi	r24, 0x2E	; 46
    8c18:	39 f0       	breq	.+14     	; 0x8c28 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8c1a:	8a 81       	ldd	r24, Y+2	; 0x02
    8c1c:	8f 5f       	subi	r24, 0xFF	; 255
    8c1e:	8a 83       	std	Y+2, r24	; 0x02
    8c20:	8a 81       	ldd	r24, Y+2	; 0x02
    8c22:	8c 30       	cpi	r24, 0x0C	; 12
    8c24:	88 f3       	brcs	.-30     	; 0x8c08 <convertFileName+0xa8>
    8c26:	01 c0       	rjmp	.+2      	; 0x8c2a <convertFileName+0xca>
if(Filename[j] == '.') break;
    8c28:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8c2a:	8a 81       	ldd	r24, Y+2	; 0x02
    8c2c:	89 30       	cpi	r24, 0x09	; 9
    8c2e:	28 f0       	brcs	.+10     	; 0x8c3a <convertFileName+0xda>
    8c30:	8a 81       	ldd	r24, Y+2	; 0x02
    8c32:	8c 30       	cpi	r24, 0x0C	; 12
    8c34:	10 f4       	brcc	.+4      	; 0x8c3a <convertFileName+0xda>
	return 1;}
    8c36:	81 e0       	ldi	r24, 0x01	; 1
    8c38:	c3 c0       	rjmp	.+390    	; 0x8dc0 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8c3a:	8a 81       	ldd	r24, Y+2	; 0x02
    8c3c:	8c 30       	cpi	r24, 0x0C	; 12
    8c3e:	11 f4       	brne	.+4      	; 0x8c44 <convertFileName+0xe4>
    8c40:	81 e0       	ldi	r24, 0x01	; 1
    8c42:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8c44:	1b 82       	std	Y+3, r1	; 0x03
    8c46:	14 c0       	rjmp	.+40     	; 0x8c70 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8c48:	8b 81       	ldd	r24, Y+3	; 0x03
    8c4a:	88 2f       	mov	r24, r24
    8c4c:	90 e0       	ldi	r25, 0x00	; 0
    8c4e:	2b 81       	ldd	r18, Y+3	; 0x03
    8c50:	22 2f       	mov	r18, r18
    8c52:	30 e0       	ldi	r19, 0x00	; 0
    8c54:	24 55       	subi	r18, 0x54	; 84
    8c56:	3f 4a       	sbci	r19, 0xAF	; 175
    8c58:	f9 01       	movw	r30, r18
    8c5a:	40 81       	ld	r20, Z
    8c5c:	9e 01       	movw	r18, r28
    8c5e:	2a 5f       	subi	r18, 0xFA	; 250
    8c60:	3f 4f       	sbci	r19, 0xFF	; 255
    8c62:	82 0f       	add	r24, r18
    8c64:	93 1f       	adc	r25, r19
    8c66:	fc 01       	movw	r30, r24
    8c68:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    8c6c:	8f 5f       	subi	r24, 0xFF	; 255
    8c6e:	8b 83       	std	Y+3, r24	; 0x03
    8c70:	9b 81       	ldd	r25, Y+3	; 0x03
    8c72:	8a 81       	ldd	r24, Y+2	; 0x02
    8c74:	98 17       	cp	r25, r24
    8c76:	40 f3       	brcs	.-48     	; 0x8c48 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8c78:	8a 81       	ldd	r24, Y+2	; 0x02
    8c7a:	8b 83       	std	Y+3, r24	; 0x03
    8c7c:	0e c0       	rjmp	.+28     	; 0x8c9a <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    8c80:	88 2f       	mov	r24, r24
    8c82:	90 e0       	ldi	r25, 0x00	; 0
    8c84:	9e 01       	movw	r18, r28
    8c86:	2a 5f       	subi	r18, 0xFA	; 250
    8c88:	3f 4f       	sbci	r19, 0xFF	; 255
    8c8a:	82 0f       	add	r24, r18
    8c8c:	93 1f       	adc	r25, r19
    8c8e:	20 e2       	ldi	r18, 0x20	; 32
    8c90:	fc 01       	movw	r30, r24
    8c92:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8c94:	8b 81       	ldd	r24, Y+3	; 0x03
    8c96:	8f 5f       	subi	r24, 0xFF	; 255
    8c98:	8b 83       	std	Y+3, r24	; 0x03
    8c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    8c9c:	88 30       	cpi	r24, 0x08	; 8
    8c9e:	78 f3       	brcs	.-34     	; 0x8c7e <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8ca0:	99 81       	ldd	r25, Y+1	; 0x01
    8ca2:	81 e0       	ldi	r24, 0x01	; 1
    8ca4:	89 27       	eor	r24, r25
    8ca6:	88 23       	and	r24, r24
    8ca8:	19 f0       	breq	.+6      	; 0x8cb0 <convertFileName+0x150>
    8caa:	8a 81       	ldd	r24, Y+2	; 0x02
    8cac:	8f 5f       	subi	r24, 0xFF	; 255
    8cae:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8cb0:	88 e0       	ldi	r24, 0x08	; 8
    8cb2:	8b 83       	std	Y+3, r24	; 0x03
    8cb4:	32 c0       	rjmp	.+100    	; 0x8d1a <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8cb6:	8a 81       	ldd	r24, Y+2	; 0x02
    8cb8:	88 2f       	mov	r24, r24
    8cba:	90 e0       	ldi	r25, 0x00	; 0
    8cbc:	84 55       	subi	r24, 0x54	; 84
    8cbe:	9f 4a       	sbci	r25, 0xAF	; 175
    8cc0:	fc 01       	movw	r30, r24
    8cc2:	80 81       	ld	r24, Z
    8cc4:	88 23       	and	r24, r24
    8cc6:	19 f1       	breq	.+70     	; 0x8d0e <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    8cca:	88 2f       	mov	r24, r24
    8ccc:	90 e0       	ldi	r25, 0x00	; 0
    8cce:	2a 81       	ldd	r18, Y+2	; 0x02
    8cd0:	22 2f       	mov	r18, r18
    8cd2:	30 e0       	ldi	r19, 0x00	; 0
    8cd4:	24 55       	subi	r18, 0x54	; 84
    8cd6:	3f 4a       	sbci	r19, 0xAF	; 175
    8cd8:	f9 01       	movw	r30, r18
    8cda:	40 81       	ld	r20, Z
    8cdc:	9e 01       	movw	r18, r28
    8cde:	2a 5f       	subi	r18, 0xFA	; 250
    8ce0:	3f 4f       	sbci	r19, 0xFF	; 255
    8ce2:	82 0f       	add	r24, r18
    8ce4:	93 1f       	adc	r25, r19
    8ce6:	fc 01       	movw	r30, r24
    8ce8:	40 83       	st	Z, r20
    8cea:	8a 81       	ldd	r24, Y+2	; 0x02
    8cec:	8f 5f       	subi	r24, 0xFF	; 255
    8cee:	8a 83       	std	Y+2, r24	; 0x02
    8cf0:	11 c0       	rjmp	.+34     	; 0x8d14 <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    8cf4:	88 2f       	mov	r24, r24
    8cf6:	90 e0       	ldi	r25, 0x00	; 0
    8cf8:	9e 01       	movw	r18, r28
    8cfa:	2a 5f       	subi	r18, 0xFA	; 250
    8cfc:	3f 4f       	sbci	r19, 0xFF	; 255
    8cfe:	82 0f       	add	r24, r18
    8d00:	93 1f       	adc	r25, r19
    8d02:	20 e2       	ldi	r18, 0x20	; 32
    8d04:	fc 01       	movw	r30, r24
    8d06:	20 83       	st	Z, r18
    8d08:	8b 81       	ldd	r24, Y+3	; 0x03
    8d0a:	8f 5f       	subi	r24, 0xFF	; 255
    8d0c:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    8d10:	8b 30       	cpi	r24, 0x0B	; 11
    8d12:	78 f3       	brcs	.-34     	; 0x8cf2 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8d14:	8b 81       	ldd	r24, Y+3	; 0x03
    8d16:	8f 5f       	subi	r24, 0xFF	; 255
    8d18:	8b 83       	std	Y+3, r24	; 0x03
    8d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    8d1c:	8b 30       	cpi	r24, 0x0B	; 11
    8d1e:	58 f2       	brcs	.-106    	; 0x8cb6 <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8d20:	1a 82       	std	Y+2, r1	; 0x02
    8d22:	31 c0       	rjmp	.+98     	; 0x8d86 <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8d24:	8a 81       	ldd	r24, Y+2	; 0x02
    8d26:	88 2f       	mov	r24, r24
    8d28:	90 e0       	ldi	r25, 0x00	; 0
    8d2a:	9e 01       	movw	r18, r28
    8d2c:	2a 5f       	subi	r18, 0xFA	; 250
    8d2e:	3f 4f       	sbci	r19, 0xFF	; 255
    8d30:	82 0f       	add	r24, r18
    8d32:	93 1f       	adc	r25, r19
    8d34:	fc 01       	movw	r30, r24
    8d36:	80 81       	ld	r24, Z
    8d38:	81 36       	cpi	r24, 0x61	; 97
    8d3a:	10 f1       	brcs	.+68     	; 0x8d80 <convertFileName+0x220>
    8d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    8d3e:	88 2f       	mov	r24, r24
    8d40:	90 e0       	ldi	r25, 0x00	; 0
    8d42:	9e 01       	movw	r18, r28
    8d44:	2a 5f       	subi	r18, 0xFA	; 250
    8d46:	3f 4f       	sbci	r19, 0xFF	; 255
    8d48:	82 0f       	add	r24, r18
    8d4a:	93 1f       	adc	r25, r19
    8d4c:	fc 01       	movw	r30, r24
    8d4e:	80 81       	ld	r24, Z
    8d50:	8b 37       	cpi	r24, 0x7B	; 123
    8d52:	b0 f4       	brcc	.+44     	; 0x8d80 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8d54:	8a 81       	ldd	r24, Y+2	; 0x02
    8d56:	88 2f       	mov	r24, r24
    8d58:	90 e0       	ldi	r25, 0x00	; 0
    8d5a:	2a 81       	ldd	r18, Y+2	; 0x02
    8d5c:	22 2f       	mov	r18, r18
    8d5e:	30 e0       	ldi	r19, 0x00	; 0
    8d60:	ae 01       	movw	r20, r28
    8d62:	4a 5f       	subi	r20, 0xFA	; 250
    8d64:	5f 4f       	sbci	r21, 0xFF	; 255
    8d66:	24 0f       	add	r18, r20
    8d68:	35 1f       	adc	r19, r21
    8d6a:	f9 01       	movw	r30, r18
    8d6c:	20 81       	ld	r18, Z
    8d6e:	42 2f       	mov	r20, r18
    8d70:	40 52       	subi	r20, 0x20	; 32
    8d72:	9e 01       	movw	r18, r28
    8d74:	2a 5f       	subi	r18, 0xFA	; 250
    8d76:	3f 4f       	sbci	r19, 0xFF	; 255
    8d78:	82 0f       	add	r24, r18
    8d7a:	93 1f       	adc	r25, r19
    8d7c:	fc 01       	movw	r30, r24
    8d7e:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8d80:	8a 81       	ldd	r24, Y+2	; 0x02
    8d82:	8f 5f       	subi	r24, 0xFF	; 255
    8d84:	8a 83       	std	Y+2, r24	; 0x02
    8d86:	8a 81       	ldd	r24, Y+2	; 0x02
    8d88:	8b 30       	cpi	r24, 0x0B	; 11
    8d8a:	60 f2       	brcs	.-104    	; 0x8d24 <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8d8c:	1a 82       	std	Y+2, r1	; 0x02
    8d8e:	14 c0       	rjmp	.+40     	; 0x8db8 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8d90:	8a 81       	ldd	r24, Y+2	; 0x02
    8d92:	88 2f       	mov	r24, r24
    8d94:	90 e0       	ldi	r25, 0x00	; 0
    8d96:	2a 81       	ldd	r18, Y+2	; 0x02
    8d98:	22 2f       	mov	r18, r18
    8d9a:	30 e0       	ldi	r19, 0x00	; 0
    8d9c:	ae 01       	movw	r20, r28
    8d9e:	4a 5f       	subi	r20, 0xFA	; 250
    8da0:	5f 4f       	sbci	r21, 0xFF	; 255
    8da2:	24 0f       	add	r18, r20
    8da4:	35 1f       	adc	r19, r21
    8da6:	f9 01       	movw	r30, r18
    8da8:	20 81       	ld	r18, Z
    8daa:	84 55       	subi	r24, 0x54	; 84
    8dac:	9f 4a       	sbci	r25, 0xAF	; 175
    8dae:	fc 01       	movw	r30, r24
    8db0:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8db2:	8a 81       	ldd	r24, Y+2	; 0x02
    8db4:	8f 5f       	subi	r24, 0xFF	; 255
    8db6:	8a 83       	std	Y+2, r24	; 0x02
    8db8:	8a 81       	ldd	r24, Y+2	; 0x02
    8dba:	8b 30       	cpi	r24, 0x0B	; 11
    8dbc:	48 f3       	brcs	.-46     	; 0x8d90 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8dbe:	80 e0       	ldi	r24, 0x00	; 0
}
    8dc0:	62 96       	adiw	r28, 0x12	; 18
    8dc2:	cd bf       	out	0x3d, r28	; 61
    8dc4:	de bf       	out	0x3e, r29	; 62
    8dc6:	df 91       	pop	r29
    8dc8:	cf 91       	pop	r28
    8dca:	08 95       	ret

00008dcc <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    8dcc:	ef 92       	push	r14
    8dce:	ff 92       	push	r15
    8dd0:	0f 93       	push	r16
    8dd2:	1f 93       	push	r17
    8dd4:	cf 93       	push	r28
    8dd6:	df 93       	push	r29
    8dd8:	cd b7       	in	r28, 0x3d	; 61
    8dda:	de b7       	in	r29, 0x3e	; 62
    8ddc:	e7 97       	sbiw	r28, 0x37	; 55
    8dde:	cd bf       	out	0x3d, r28	; 61
    8de0:	de bf       	out	0x3e, r29	; 62
    8de2:	88 ab       	sts	0x58, r24
    8de4:	99 ab       	sts	0x59, r25
    8de6:	6a ab       	sts	0x5a, r22
    8de8:	7b ab       	sts	0x5b, r23
    8dea:	2c ab       	sts	0x5c, r18
    8dec:	3d ab       	sts	0x5d, r19
    8dee:	4e ab       	sts	0x5e, r20
    8df0:	5f ab       	sts	0x5f, r21
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8df2:	1a 82       	std	Y+2, r1	; 0x02
    8df4:	1b 82       	std	Y+3, r1	; 0x03
    8df6:	1c 82       	std	Y+4, r1	; 0x04
    8df8:	1d 82       	std	Y+5, r1	; 0x05
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8dfa:	1e 82       	std	Y+6, r1	; 0x06
    8dfc:	1f 82       	std	Y+7, r1	; 0x07
    8dfe:	18 86       	std	Y+8, r1	; 0x08
    8e00:	19 86       	std	Y+9, r1	; 0x09
    8e02:	1a 86       	std	Y+10, r1	; 0x0a
    8e04:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    8e06:	28 a9       	sts	0x48, r18
    8e08:	39 a9       	sts	0x49, r19
    8e0a:	81 e0       	ldi	r24, 0x01	; 1
    8e0c:	b9 01       	movw	r22, r18
    8e0e:	0e 94 10 45 	call	0x8a20	; 0x8a20 <readFile>
    8e12:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8e14:	89 81       	ldd	r24, Y+1	; 0x01
    8e16:	81 30       	cpi	r24, 0x01	; 1
    8e18:	09 f0       	breq	.+2      	; 0x8e1c <writeFile+0x50>
    8e1a:	84 c0       	rjmp	.+264    	; 0x8f24 <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    8e1c:	81 e0       	ldi	r24, 0x01	; 1
    8e1e:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8e20:	80 91 78 50 	lds	r24, 0x5078
    8e24:	90 91 79 50 	lds	r25, 0x5079
    8e28:	a0 91 7a 50 	lds	r26, 0x507A
    8e2c:	b0 91 7b 50 	lds	r27, 0x507B
    8e30:	8c 87       	std	Y+12, r24	; 0x0c
    8e32:	9d 87       	std	Y+13, r25	; 0x0d
    8e34:	ae 87       	std	Y+14, r26	; 0x0e
    8e36:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8e38:	1c 8a       	std	Y+20, r1	; 0x14
    8e3a:	1d 8a       	std	Y+21, r1	; 0x15
    8e3c:	1e 8a       	std	Y+22, r1	; 0x16
    8e3e:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8e40:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e42:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e44:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e46:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e48:	bc 01       	movw	r22, r24
    8e4a:	cd 01       	movw	r24, r26
    8e4c:	40 e0       	ldi	r20, 0x00	; 0
    8e4e:	00 e0       	ldi	r16, 0x00	; 0
    8e50:	10 e0       	ldi	r17, 0x00	; 0
    8e52:	98 01       	movw	r18, r16
    8e54:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
    8e58:	dc 01       	movw	r26, r24
    8e5a:	cb 01       	movw	r24, r22
    8e5c:	8a a3       	lds	r24, 0x5a
    8e5e:	9b a3       	lds	r25, 0x5b
    8e60:	ac a3       	lds	r26, 0x5c
    8e62:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    8e64:	8a a1       	lds	r24, 0x4a
    8e66:	9b a1       	lds	r25, 0x4b
    8e68:	ac a1       	lds	r26, 0x4c
    8e6a:	bd a1       	lds	r27, 0x4d
    8e6c:	8f 3f       	cpi	r24, 0xFF	; 255
    8e6e:	0f ef       	ldi	r16, 0xFF	; 255
    8e70:	90 07       	cpc	r25, r16
    8e72:	0f ef       	ldi	r16, 0xFF	; 255
    8e74:	a0 07       	cpc	r26, r16
    8e76:	0f ef       	ldi	r16, 0xFF	; 255
    8e78:	b0 07       	cpc	r27, r16
    8e7a:	a1 f0       	breq	.+40     	; 0x8ea4 <writeFile+0xd8>
	cluster = nextCluster;
    8e7c:	8a a1       	lds	r24, 0x4a
    8e7e:	9b a1       	lds	r25, 0x4b
    8e80:	ac a1       	lds	r26, 0x4c
    8e82:	bd a1       	lds	r27, 0x4d
    8e84:	8c 87       	std	Y+12, r24	; 0x0c
    8e86:	9d 87       	std	Y+13, r25	; 0x0d
    8e88:	ae 87       	std	Y+14, r26	; 0x0e
    8e8a:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8e8c:	8c 89       	ldd	r24, Y+20	; 0x14
    8e8e:	9d 89       	ldd	r25, Y+21	; 0x15
    8e90:	ae 89       	ldd	r26, Y+22	; 0x16
    8e92:	bf 89       	ldd	r27, Y+23	; 0x17
    8e94:	01 96       	adiw	r24, 0x01	; 1
    8e96:	a1 1d       	adc	r26, r1
    8e98:	b1 1d       	adc	r27, r1
    8e9a:	8c 8b       	std	Y+20, r24	; 0x14
    8e9c:	9d 8b       	std	Y+21, r25	; 0x15
    8e9e:	ae 8b       	std	Y+22, r26	; 0x16
    8ea0:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8ea2:	ce cf       	rjmp	.-100    	; 0x8e40 <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8ea4:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8ea6:	e0 90 41 40 	lds	r14, 0x4041
    8eaa:	f0 90 42 40 	lds	r15, 0x4042
    8eae:	00 91 43 40 	lds	r16, 0x4043
    8eb2:	10 91 44 40 	lds	r17, 0x4044
    8eb6:	80 91 6c 50 	lds	r24, 0x506C
    8eba:	90 91 6d 50 	lds	r25, 0x506D
    8ebe:	cc 01       	movw	r24, r24
    8ec0:	a0 e0       	ldi	r26, 0x00	; 0
    8ec2:	b0 e0       	ldi	r27, 0x00	; 0
    8ec4:	2c 89       	ldd	r18, Y+20	; 0x14
    8ec6:	3d 89       	ldd	r19, Y+21	; 0x15
    8ec8:	4e 89       	ldd	r20, Y+22	; 0x16
    8eca:	5f 89       	ldd	r21, Y+23	; 0x17
    8ecc:	bc 01       	movw	r22, r24
    8ece:	cd 01       	movw	r24, r26
    8ed0:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    8ed4:	dc 01       	movw	r26, r24
    8ed6:	cb 01       	movw	r24, r22
    8ed8:	20 91 45 40 	lds	r18, 0x4045
    8edc:	30 91 46 40 	lds	r19, 0x4046
    8ee0:	99 01       	movw	r18, r18
    8ee2:	40 e0       	ldi	r20, 0x00	; 0
    8ee4:	50 e0       	ldi	r21, 0x00	; 0
    8ee6:	bc 01       	movw	r22, r24
    8ee8:	cd 01       	movw	r24, r26
    8eea:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    8eee:	dc 01       	movw	r26, r24
    8ef0:	cb 01       	movw	r24, r22
    8ef2:	a8 01       	movw	r20, r16
    8ef4:	97 01       	movw	r18, r14
    8ef6:	28 1b       	sub	r18, r24
    8ef8:	39 0b       	sbc	r19, r25
    8efa:	4a 0b       	sbc	r20, r26
    8efc:	5b 0b       	sbc	r21, r27
    8efe:	da 01       	movw	r26, r20
    8f00:	c9 01       	movw	r24, r18
    8f02:	20 91 45 40 	lds	r18, 0x4045
    8f06:	30 91 46 40 	lds	r19, 0x4046
    8f0a:	99 01       	movw	r18, r18
    8f0c:	40 e0       	ldi	r20, 0x00	; 0
    8f0e:	50 e0       	ldi	r21, 0x00	; 0
    8f10:	bc 01       	movw	r22, r24
    8f12:	cd 01       	movw	r24, r26
    8f14:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    8f18:	da 01       	movw	r26, r20
    8f1a:	c9 01       	movw	r24, r18
    8f1c:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8f1e:	81 e0       	ldi	r24, 0x01	; 1
    8f20:	8b 83       	std	Y+3, r24	; 0x03
    8f22:	68 c0       	rjmp	.+208    	; 0x8ff4 <writeFile+0x228>
}
else if(j == 2) 
    8f24:	89 81       	ldd	r24, Y+1	; 0x01
    8f26:	82 30       	cpi	r24, 0x02	; 2
    8f28:	11 f4       	brne	.+4      	; 0x8f2e <writeFile+0x162>
   return 1; //invalid file name
    8f2a:	81 e0       	ldi	r24, 0x01	; 1
    8f2c:	18 c3       	rjmp	.+1584   	; 0x955e <writeFile+0x792>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8f2e:	82 e0       	ldi	r24, 0x02	; 2
    8f30:	60 e0       	ldi	r22, 0x00	; 0
    8f32:	20 e0       	ldi	r18, 0x00	; 0
    8f34:	30 e0       	ldi	r19, 0x00	; 0
    8f36:	a9 01       	movw	r20, r18
    8f38:	0e 94 85 42 	call	0x850a	; 0x850a <getSetFreeCluster>
    8f3c:	dc 01       	movw	r26, r24
    8f3e:	cb 01       	movw	r24, r22
    8f40:	8c 87       	std	Y+12, r24	; 0x0c
    8f42:	9d 87       	std	Y+13, r25	; 0x0d
    8f44:	ae 87       	std	Y+14, r26	; 0x0e
    8f46:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8f48:	80 91 4a 40 	lds	r24, 0x404A
    8f4c:	90 91 4b 40 	lds	r25, 0x404B
    8f50:	a0 91 4c 40 	lds	r26, 0x404C
    8f54:	b0 91 4d 40 	lds	r27, 0x404D
    8f58:	2c 85       	ldd	r18, Y+12	; 0x0c
    8f5a:	3d 85       	ldd	r19, Y+13	; 0x0d
    8f5c:	4e 85       	ldd	r20, Y+14	; 0x0e
    8f5e:	5f 85       	ldd	r21, Y+15	; 0x0f
    8f60:	82 17       	cp	r24, r18
    8f62:	93 07       	cpc	r25, r19
    8f64:	a4 07       	cpc	r26, r20
    8f66:	b5 07       	cpc	r27, r21
    8f68:	60 f4       	brcc	.+24     	; 0x8f82 <writeFile+0x1b6>
     cluster = rootCluster;
    8f6a:	80 91 50 40 	lds	r24, 0x4050
    8f6e:	90 91 51 40 	lds	r25, 0x4051
    8f72:	a0 91 52 40 	lds	r26, 0x4052
    8f76:	b0 91 53 40 	lds	r27, 0x4053
    8f7a:	8c 87       	std	Y+12, r24	; 0x0c
    8f7c:	9d 87       	std	Y+13, r25	; 0x0d
    8f7e:	ae 87       	std	Y+14, r26	; 0x0e
    8f80:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8f82:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f84:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f86:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f88:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f8a:	bc 01       	movw	r22, r24
    8f8c:	cd 01       	movw	r24, r26
    8f8e:	0e 94 b9 4a 	call	0x9572	; 0x9572 <searchNextFreeCluster>
    8f92:	dc 01       	movw	r26, r24
    8f94:	cb 01       	movw	r24, r22
    8f96:	8c 87       	std	Y+12, r24	; 0x0c
    8f98:	9d 87       	std	Y+13, r25	; 0x0d
    8f9a:	ae 87       	std	Y+14, r26	; 0x0e
    8f9c:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8f9e:	8c 85       	ldd	r24, Y+12	; 0x0c
    8fa0:	9d 85       	ldd	r25, Y+13	; 0x0d
    8fa2:	ae 85       	ldd	r26, Y+14	; 0x0e
    8fa4:	bf 85       	ldd	r27, Y+15	; 0x0f
    8fa6:	00 97       	sbiw	r24, 0x00	; 0
    8fa8:	a1 05       	cpc	r26, r1
    8faa:	b1 05       	cpc	r27, r1
    8fac:	11 f4       	brne	.+4      	; 0x8fb2 <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    8fae:	82 e0       	ldi	r24, 0x02	; 2
    8fb0:	d6 c2       	rjmp	.+1452   	; 0x955e <writeFile+0x792>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8fb2:	8c 85       	ldd	r24, Y+12	; 0x0c
    8fb4:	9d 85       	ldd	r25, Y+13	; 0x0d
    8fb6:	ae 85       	ldd	r26, Y+14	; 0x0e
    8fb8:	bf 85       	ldd	r27, Y+15	; 0x0f
    8fba:	bc 01       	movw	r22, r24
    8fbc:	cd 01       	movw	r24, r26
    8fbe:	41 e0       	ldi	r20, 0x01	; 1
    8fc0:	0f ef       	ldi	r16, 0xFF	; 255
    8fc2:	1f ef       	ldi	r17, 0xFF	; 255
    8fc4:	98 01       	movw	r18, r16
    8fc6:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8fca:	8c 85       	ldd	r24, Y+12	; 0x0c
    8fcc:	9d 85       	ldd	r25, Y+13	; 0x0d
    8fce:	ae 85       	ldd	r26, Y+14	; 0x0e
    8fd0:	bf 85       	ldd	r27, Y+15	; 0x0f
    8fd2:	cd 01       	movw	r24, r26
    8fd4:	aa 27       	eor	r26, r26
    8fd6:	bb 27       	eor	r27, r27
    8fd8:	8e 83       	std	Y+6, r24	; 0x06
    8fda:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8fdc:	8c 85       	ldd	r24, Y+12	; 0x0c
    8fde:	9d 85       	ldd	r25, Y+13	; 0x0d
    8fe0:	88 87       	std	Y+8, r24	; 0x08
    8fe2:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8fe4:	10 92 41 40 	sts	0x4041, r1
    8fe8:	10 92 42 40 	sts	0x4042, r1
    8fec:	10 92 43 40 	sts	0x4043, r1
    8ff0:	10 92 44 40 	sts	0x4044, r1
}

//start writing data here

if(start){
    8ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    8ff6:	88 23       	and	r24, r24
    8ff8:	11 f1       	breq	.+68     	; 0x903e <writeFile+0x272>
  start = 0;
    8ffa:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    8ffc:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ffe:	9d 85       	ldd	r25, Y+13	; 0x0d
    9000:	ae 85       	ldd	r26, Y+14	; 0x0e
    9002:	bf 85       	ldd	r27, Y+15	; 0x0f
    9004:	bc 01       	movw	r22, r24
    9006:	cd 01       	movw	r24, r26
    9008:	0e 94 aa 41 	call	0x8354	; 0x8354 <getFirstSector>
    900c:	dc 01       	movw	r26, r24
    900e:	cb 01       	movw	r24, r22
    9010:	9c 01       	movw	r18, r24
    9012:	8d 81       	ldd	r24, Y+5	; 0x05
    9014:	88 2f       	mov	r24, r24
    9016:	90 e0       	ldi	r25, 0x00	; 0
    9018:	82 0f       	add	r24, r18
    901a:	93 1f       	adc	r25, r19
    901c:	8a 87       	std	Y+10, r24	; 0x0a
    901e:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    9020:	8a 85       	ldd	r24, Y+10	; 0x0a
    9022:	9b 85       	ldd	r25, Y+11	; 0x0b
    9024:	cc 01       	movw	r24, r24
    9026:	a0 e0       	ldi	r26, 0x00	; 0
    9028:	b0 e0       	ldi	r27, 0x00	; 0
    902a:	27 ec       	ldi	r18, 0xC7	; 199
    902c:	31 e2       	ldi	r19, 0x21	; 33
    902e:	bc 01       	movw	r22, r24
    9030:	cd 01       	movw	r24, r26
    9032:	a9 01       	movw	r20, r18
    9034:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
  j = sector;
    9038:	8d 81       	ldd	r24, Y+5	; 0x05
    903a:	89 83       	std	Y+1, r24	; 0x01
    903c:	0d c0       	rjmp	.+26     	; 0x9058 <writeFile+0x28c>
}
else{
  startBlock = getFirstSector (cluster);
    903e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9040:	9d 85       	ldd	r25, Y+13	; 0x0d
    9042:	ae 85       	ldd	r26, Y+14	; 0x0e
    9044:	bf 85       	ldd	r27, Y+15	; 0x0f
    9046:	bc 01       	movw	r22, r24
    9048:	cd 01       	movw	r24, r26
    904a:	0e 94 aa 41 	call	0x8354	; 0x8354 <getFirstSector>
    904e:	dc 01       	movw	r26, r24
    9050:	cb 01       	movw	r24, r22
    9052:	8a 87       	std	Y+10, r24	; 0x0a
    9054:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    9056:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    9058:	18 8e       	std	Y+24, r1	; 0x18
    905a:	19 8e       	std	Y+25, r1	; 0x19
    905c:	1a 8e       	std	Y+26, r1	; 0x1a
    905e:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    9060:	1c 8e       	std	Y+28, r1	; 0x1c
    9062:	1d 8e       	std	Y+29, r1	; 0x1d
    9064:	1e 8e       	std	Y+30, r1	; 0x1e
    9066:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    9068:	cc c0       	rjmp	.+408    	; 0x9202 <writeFile+0x436>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    906a:	8c a9       	sts	0x4c, r24
    906c:	9d a9       	sts	0x4d, r25
    906e:	ae a9       	sts	0x4e, r26
    9070:	bf a9       	sts	0x4f, r27
    9072:	80 30       	cpi	r24, 0x00	; 0
    9074:	32 e0       	ldi	r19, 0x02	; 2
    9076:	93 07       	cpc	r25, r19
    9078:	30 e0       	ldi	r19, 0x00	; 0
    907a:	a3 07       	cpc	r26, r19
    907c:	30 e0       	ldi	r19, 0x00	; 0
    907e:	b3 07       	cpc	r27, r19
    9080:	08 f1       	brcs	.+66     	; 0x90c4 <writeFile+0x2f8>
		 writtenData += 512;
    9082:	88 8d       	ldd	r24, Y+24	; 0x18
    9084:	99 8d       	ldd	r25, Y+25	; 0x19
    9086:	aa 8d       	ldd	r26, Y+26	; 0x1a
    9088:	bb 8d       	ldd	r27, Y+27	; 0x1b
    908a:	80 50       	subi	r24, 0x00	; 0
    908c:	9e 4f       	sbci	r25, 0xFE	; 254
    908e:	af 4f       	sbci	r26, 0xFF	; 255
    9090:	bf 4f       	sbci	r27, 0xFF	; 255
    9092:	88 8f       	std	Y+24, r24	; 0x18
    9094:	99 8f       	std	Y+25, r25	; 0x19
    9096:	aa 8f       	std	Y+26, r26	; 0x1a
    9098:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    909a:	80 e0       	ldi	r24, 0x00	; 0
    909c:	92 e0       	ldi	r25, 0x02	; 2
    909e:	a0 e0       	ldi	r26, 0x00	; 0
    90a0:	b0 e0       	ldi	r27, 0x00	; 0
    90a2:	8c 8f       	std	Y+28, r24	; 0x1c
    90a4:	9d 8f       	std	Y+29, r25	; 0x1d
    90a6:	ae 8f       	std	Y+30, r26	; 0x1e
    90a8:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    90aa:	8c a9       	sts	0x4c, r24
    90ac:	9d a9       	sts	0x4d, r25
    90ae:	ae a9       	sts	0x4e, r26
    90b0:	bf a9       	sts	0x4f, r27
    90b2:	80 50       	subi	r24, 0x00	; 0
    90b4:	92 40       	sbci	r25, 0x02	; 2
    90b6:	a0 40       	sbci	r26, 0x00	; 0
    90b8:	b0 40       	sbci	r27, 0x00	; 0
    90ba:	8c ab       	sts	0x5c, r24
    90bc:	9d ab       	sts	0x5d, r25
    90be:	ae ab       	sts	0x5e, r26
    90c0:	bf ab       	sts	0x5f, r27
    90c2:	1f c0       	rjmp	.+62     	; 0x9102 <writeFile+0x336>
	}
	else{
		writtenData += lengthOfData;
    90c4:	28 8d       	ldd	r18, Y+24	; 0x18
    90c6:	39 8d       	ldd	r19, Y+25	; 0x19
    90c8:	4a 8d       	ldd	r20, Y+26	; 0x1a
    90ca:	5b 8d       	ldd	r21, Y+27	; 0x1b
    90cc:	8c a9       	sts	0x4c, r24
    90ce:	9d a9       	sts	0x4d, r25
    90d0:	ae a9       	sts	0x4e, r26
    90d2:	bf a9       	sts	0x4f, r27
    90d4:	82 0f       	add	r24, r18
    90d6:	93 1f       	adc	r25, r19
    90d8:	a4 1f       	adc	r26, r20
    90da:	b5 1f       	adc	r27, r21
    90dc:	88 8f       	std	Y+24, r24	; 0x18
    90de:	99 8f       	std	Y+25, r25	; 0x19
    90e0:	aa 8f       	std	Y+26, r26	; 0x1a
    90e2:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    90e4:	8c a9       	sts	0x4c, r24
    90e6:	9d a9       	sts	0x4d, r25
    90e8:	ae a9       	sts	0x4e, r26
    90ea:	bf a9       	sts	0x4f, r27
    90ec:	91 70       	andi	r25, 0x01	; 1
    90ee:	a0 70       	andi	r26, 0x00	; 0
    90f0:	b0 70       	andi	r27, 0x00	; 0
    90f2:	8c 8f       	std	Y+28, r24	; 0x1c
    90f4:	9d 8f       	std	Y+29, r25	; 0x1d
    90f6:	ae 8f       	std	Y+30, r26	; 0x1e
    90f8:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    90fa:	1c aa       	sts	0x9c, r17
    90fc:	1d aa       	sts	0x9d, r17
    90fe:	1e aa       	sts	0x9e, r17
    9100:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    9102:	80 91 41 40 	lds	r24, 0x4041
    9106:	90 91 42 40 	lds	r25, 0x4042
    910a:	a0 91 43 40 	lds	r26, 0x4043
    910e:	b0 91 44 40 	lds	r27, 0x4044
    9112:	80 50       	subi	r24, 0x00	; 0
    9114:	9e 4f       	sbci	r25, 0xFE	; 254
    9116:	af 4f       	sbci	r26, 0xFF	; 255
    9118:	bf 4f       	sbci	r27, 0xFF	; 255
    911a:	80 93 41 40 	sts	0x4041, r24
    911e:	90 93 42 40 	sts	0x4042, r25
    9122:	a0 93 43 40 	sts	0x4043, r26
    9126:	b0 93 44 40 	sts	0x4044, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    912a:	8a 85       	ldd	r24, Y+10	; 0x0a
    912c:	9b 85       	ldd	r25, Y+11	; 0x0b
    912e:	cc 01       	movw	r24, r24
    9130:	a0 e0       	ldi	r26, 0x00	; 0
    9132:	b0 e0       	ldi	r27, 0x00	; 0
    9134:	48 8d       	ldd	r20, Y+24	; 0x18
    9136:	59 8d       	ldd	r21, Y+25	; 0x19
    9138:	2c 8d       	ldd	r18, Y+28	; 0x1c
    913a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    913c:	ba 01       	movw	r22, r20
    913e:	62 1b       	sub	r22, r18
    9140:	73 0b       	sbc	r23, r19
    9142:	9b 01       	movw	r18, r22
    9144:	4a a9       	sts	0x4a, r20
    9146:	5b a9       	sts	0x4b, r21
    9148:	42 0f       	add	r20, r18
    914a:	53 1f       	adc	r21, r19
    914c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    914e:	3d 8d       	ldd	r19, Y+29	; 0x1d
    9150:	bc 01       	movw	r22, r24
    9152:	cd 01       	movw	r24, r26
    9154:	0e 94 f1 4e 	call	0x9de2	; 0x9de2 <SD_write_block>
	j++;
    9158:	89 81       	ldd	r24, Y+1	; 0x01
    915a:	8f 5f       	subi	r24, 0xFF	; 255
    915c:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    915e:	89 81       	ldd	r24, Y+1	; 0x01
    9160:	28 2f       	mov	r18, r24
    9162:	30 e0       	ldi	r19, 0x00	; 0
    9164:	80 91 6c 50 	lds	r24, 0x506C
    9168:	90 91 6d 50 	lds	r25, 0x506D
    916c:	28 17       	cp	r18, r24
    916e:	39 07       	cpc	r19, r25
    9170:	d9 f5       	brne	.+118    	; 0x91e8 <writeFile+0x41c>
		j = 0; 
    9172:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    9174:	8c 85       	ldd	r24, Y+12	; 0x0c
    9176:	9d 85       	ldd	r25, Y+13	; 0x0d
    9178:	ae 85       	ldd	r26, Y+14	; 0x0e
    917a:	bf 85       	ldd	r27, Y+15	; 0x0f
    917c:	88 8b       	std	Y+16, r24	; 0x10
    917e:	99 8b       	std	Y+17, r25	; 0x11
    9180:	aa 8b       	std	Y+18, r26	; 0x12
    9182:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    9184:	88 89       	ldd	r24, Y+16	; 0x10
    9186:	99 89       	ldd	r25, Y+17	; 0x11
    9188:	aa 89       	ldd	r26, Y+18	; 0x12
    918a:	bb 89       	ldd	r27, Y+19	; 0x13
    918c:	bc 01       	movw	r22, r24
    918e:	cd 01       	movw	r24, r26
    9190:	0e 94 b9 4a 	call	0x9572	; 0x9572 <searchNextFreeCluster>
    9194:	dc 01       	movw	r26, r24
    9196:	cb 01       	movw	r24, r22
    9198:	8c 87       	std	Y+12, r24	; 0x0c
    919a:	9d 87       	std	Y+13, r25	; 0x0d
    919c:	ae 87       	std	Y+14, r26	; 0x0e
    919e:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    91a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    91a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    91a4:	ae 85       	ldd	r26, Y+14	; 0x0e
    91a6:	bf 85       	ldd	r27, Y+15	; 0x0f
    91a8:	00 97       	sbiw	r24, 0x00	; 0
    91aa:	a1 05       	cpc	r26, r1
    91ac:	b1 05       	cpc	r27, r1
    91ae:	11 f4       	brne	.+4      	; 0x91b4 <writeFile+0x3e8>
		  //No free cluster!
		  return 2;
    91b0:	82 e0       	ldi	r24, 0x02	; 2
    91b2:	d5 c1       	rjmp	.+938    	; 0x955e <writeFile+0x792>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    91b4:	88 89       	ldd	r24, Y+16	; 0x10
    91b6:	99 89       	ldd	r25, Y+17	; 0x11
    91b8:	aa 89       	ldd	r26, Y+18	; 0x12
    91ba:	bb 89       	ldd	r27, Y+19	; 0x13
    91bc:	0c 85       	ldd	r16, Y+12	; 0x0c
    91be:	1d 85       	ldd	r17, Y+13	; 0x0d
    91c0:	2e 85       	ldd	r18, Y+14	; 0x0e
    91c2:	3f 85       	ldd	r19, Y+15	; 0x0f
    91c4:	bc 01       	movw	r22, r24
    91c6:	cd 01       	movw	r24, r26
    91c8:	41 e0       	ldi	r20, 0x01	; 1
    91ca:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    91ce:	8c 85       	ldd	r24, Y+12	; 0x0c
    91d0:	9d 85       	ldd	r25, Y+13	; 0x0d
    91d2:	ae 85       	ldd	r26, Y+14	; 0x0e
    91d4:	bf 85       	ldd	r27, Y+15	; 0x0f
    91d6:	bc 01       	movw	r22, r24
    91d8:	cd 01       	movw	r24, r26
    91da:	41 e0       	ldi	r20, 0x01	; 1
    91dc:	0f ef       	ldi	r16, 0xFF	; 255
    91de:	1f ef       	ldi	r17, 0xFF	; 255
    91e0:	98 01       	movw	r18, r16
    91e2:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
    91e6:	05 c0       	rjmp	.+10     	; 0x91f2 <writeFile+0x426>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    91e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    91ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    91ec:	01 96       	adiw	r24, 0x01	; 1
    91ee:	8a 87       	std	Y+10, r24	; 0x0a
    91f0:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    91f2:	2c 85       	ldd	r18, Y+12	; 0x0c
    91f4:	3d 85       	ldd	r19, Y+13	; 0x0d
    91f6:	4e 85       	ldd	r20, Y+14	; 0x0e
    91f8:	5f 85       	ldd	r21, Y+15	; 0x0f
    91fa:	82 e0       	ldi	r24, 0x02	; 2
    91fc:	61 e0       	ldi	r22, 0x01	; 1
    91fe:	0e 94 85 42 	call	0x850a	; 0x850a <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    9202:	8c a9       	sts	0x4c, r24
    9204:	9d a9       	sts	0x4d, r25
    9206:	ae a9       	sts	0x4e, r26
    9208:	bf a9       	sts	0x4f, r27
    920a:	00 97       	sbiw	r24, 0x00	; 0
    920c:	a1 05       	cpc	r26, r1
    920e:	b1 05       	cpc	r27, r1
    9210:	09 f0       	breq	.+2      	; 0x9214 <writeFile+0x448>
    9212:	2b cf       	rjmp	.-426    	; 0x906a <writeFile+0x29e>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    9214:	8c 81       	ldd	r24, Y+4	; 0x04
    9216:	88 23       	and	r24, r24
    9218:	09 f4       	brne	.+2      	; 0x921c <writeFile+0x450>
    921a:	66 c0       	rjmp	.+204    	; 0x92e8 <writeFile+0x51c>
{
  SD_read_block (appendFileSector,SDBuffer);    
    921c:	80 91 c2 50 	lds	r24, 0x50C2
    9220:	90 91 c3 50 	lds	r25, 0x50C3
    9224:	a0 91 c4 50 	lds	r26, 0x50C4
    9228:	b0 91 c5 50 	lds	r27, 0x50C5
    922c:	27 ec       	ldi	r18, 0xC7	; 199
    922e:	31 e2       	ldi	r19, 0x21	; 33
    9230:	bc 01       	movw	r22, r24
    9232:	cd 01       	movw	r24, r26
    9234:	a9 01       	movw	r20, r18
    9236:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    923a:	80 91 c8 23 	lds	r24, 0x23C8
    923e:	90 91 c9 23 	lds	r25, 0x23C9
    9242:	a0 91 ca 23 	lds	r26, 0x23CA
    9246:	b0 91 cb 23 	lds	r27, 0x23CB
    924a:	89 53       	subi	r24, 0x39	; 57
    924c:	9e 4d       	sbci	r25, 0xDE	; 222
    924e:	8e a3       	lds	r24, 0x5e
    9250:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    9252:	8e a1       	lds	r24, 0x4e
    9254:	9f a1       	lds	r25, 0x4f
    9256:	fc 01       	movw	r30, r24
    9258:	12 8a       	std	Z+18, r1	; 0x12
    925a:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    925c:	20 91 41 40 	lds	r18, 0x4041
    9260:	30 91 42 40 	lds	r19, 0x4042
    9264:	40 91 43 40 	lds	r20, 0x4043
    9268:	50 91 44 40 	lds	r21, 0x4044
    926c:	8e a1       	lds	r24, 0x4e
    926e:	9f a1       	lds	r25, 0x4f
    9270:	fc 01       	movw	r30, r24
    9272:	84 8d       	ldd	r24, Z+28	; 0x1c
    9274:	95 8d       	ldd	r25, Z+29	; 0x1d
    9276:	a6 8d       	ldd	r26, Z+30	; 0x1e
    9278:	b7 8d       	ldd	r27, Z+31	; 0x1f
    927a:	79 01       	movw	r14, r18
    927c:	8a 01       	movw	r16, r20
    927e:	e8 1a       	sub	r14, r24
    9280:	f9 0a       	sbc	r15, r25
    9282:	0a 0b       	sbc	r16, r26
    9284:	1b 0b       	sbc	r17, r27
    9286:	d8 01       	movw	r26, r16
    9288:	c7 01       	movw	r24, r14
    928a:	88 a7       	lds	r24, 0x78
    928c:	99 a7       	lds	r25, 0x79
    928e:	aa a7       	lds	r26, 0x7a
    9290:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    9292:	80 91 41 40 	lds	r24, 0x4041
    9296:	90 91 42 40 	lds	r25, 0x4042
    929a:	a0 91 43 40 	lds	r26, 0x4043
    929e:	b0 91 44 40 	lds	r27, 0x4044
    92a2:	2e a1       	lds	r18, 0x4e
    92a4:	3f a1       	lds	r19, 0x4f
    92a6:	f9 01       	movw	r30, r18
    92a8:	84 8f       	std	Z+28, r24	; 0x1c
    92aa:	95 8f       	std	Z+29, r25	; 0x1d
    92ac:	a6 8f       	std	Z+30, r26	; 0x1e
    92ae:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    92b0:	80 91 c2 50 	lds	r24, 0x50C2
    92b4:	90 91 c3 50 	lds	r25, 0x50C3
    92b8:	a0 91 c4 50 	lds	r26, 0x50C4
    92bc:	b0 91 c5 50 	lds	r27, 0x50C5
    92c0:	27 ec       	ldi	r18, 0xC7	; 199
    92c2:	31 e2       	ldi	r19, 0x21	; 33
    92c4:	bc 01       	movw	r22, r24
    92c6:	cd 01       	movw	r24, r26
    92c8:	a9 01       	movw	r20, r18
    92ca:	20 e0       	ldi	r18, 0x00	; 0
    92cc:	32 e0       	ldi	r19, 0x02	; 2
    92ce:	0e 94 f1 4e 	call	0x9de2	; 0x9de2 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    92d2:	28 a5       	lds	r18, 0x68
    92d4:	39 a5       	lds	r19, 0x69
    92d6:	4a a5       	lds	r20, 0x6a
    92d8:	5b a5       	lds	r21, 0x6b
    92da:	81 e0       	ldi	r24, 0x01	; 1
    92dc:	ba 01       	movw	r22, r20
    92de:	a9 01       	movw	r20, r18
    92e0:	0e 94 92 4b 	call	0x9724	; 0x9724 <freeMemoryUpdate>

 //File appended!
  return 0;
    92e4:	80 e0       	ldi	r24, 0x00	; 0
    92e6:	3b c1       	rjmp	.+630    	; 0x955e <writeFile+0x792>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    92e8:	80 91 50 40 	lds	r24, 0x4050
    92ec:	90 91 51 40 	lds	r25, 0x4051
    92f0:	a0 91 52 40 	lds	r26, 0x4052
    92f4:	b0 91 53 40 	lds	r27, 0x4053
    92f8:	88 8b       	std	Y+16, r24	; 0x10
    92fa:	99 8b       	std	Y+17, r25	; 0x11
    92fc:	aa 8b       	std	Y+18, r26	; 0x12
    92fe:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    9300:	88 89       	ldd	r24, Y+16	; 0x10
    9302:	99 89       	ldd	r25, Y+17	; 0x11
    9304:	aa 89       	ldd	r26, Y+18	; 0x12
    9306:	bb 89       	ldd	r27, Y+19	; 0x13
    9308:	bc 01       	movw	r22, r24
    930a:	cd 01       	movw	r24, r26
    930c:	0e 94 aa 41 	call	0x8354	; 0x8354 <getFirstSector>
    9310:	dc 01       	movw	r26, r24
    9312:	cb 01       	movw	r24, r22
    9314:	8c a7       	lds	r24, 0x7c
    9316:	9d a7       	lds	r25, 0x7d
    9318:	ae a7       	lds	r26, 0x7e
    931a:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    931c:	1d 82       	std	Y+5, r1	; 0x05
    931e:	ad c0       	rjmp	.+346    	; 0x947a <writeFile+0x6ae>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    9320:	8d 81       	ldd	r24, Y+5	; 0x05
    9322:	28 2f       	mov	r18, r24
    9324:	30 e0       	ldi	r19, 0x00	; 0
    9326:	40 e0       	ldi	r20, 0x00	; 0
    9328:	50 e0       	ldi	r21, 0x00	; 0
    932a:	8c a5       	lds	r24, 0x6c
    932c:	9d a5       	lds	r25, 0x6d
    932e:	ae a5       	lds	r26, 0x6e
    9330:	bf a5       	lds	r27, 0x6f
    9332:	82 0f       	add	r24, r18
    9334:	93 1f       	adc	r25, r19
    9336:	a4 1f       	adc	r26, r20
    9338:	b5 1f       	adc	r27, r21
    933a:	27 ec       	ldi	r18, 0xC7	; 199
    933c:	31 e2       	ldi	r19, 0x21	; 33
    933e:	bc 01       	movw	r22, r24
    9340:	cd 01       	movw	r24, r26
    9342:	a9 01       	movw	r20, r18
    9344:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    9348:	18 a2       	lds	r17, 0x98
    934a:	19 a2       	lds	r17, 0x99
    934c:	89 c0       	rjmp	.+274    	; 0x9460 <writeFile+0x694>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    934e:	88 a1       	lds	r24, 0x48
    9350:	99 a1       	lds	r25, 0x49
    9352:	89 53       	subi	r24, 0x39	; 57
    9354:	9e 4d       	sbci	r25, 0xDE	; 222
    9356:	8e a3       	lds	r24, 0x5e
    9358:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    935a:	8a 81       	ldd	r24, Y+2	; 0x02
    935c:	88 23       	and	r24, r24
    935e:	11 f0       	breq	.+4      	; 0x9364 <writeFile+0x598>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    9360:	80 e0       	ldi	r24, 0x00	; 0
    9362:	fd c0       	rjmp	.+506    	; 0x955e <writeFile+0x792>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    9364:	8e a1       	lds	r24, 0x4e
    9366:	9f a1       	lds	r25, 0x4f
    9368:	fc 01       	movw	r30, r24
    936a:	80 81       	ld	r24, Z
    936c:	88 23       	and	r24, r24
    936e:	39 f0       	breq	.+14     	; 0x937e <writeFile+0x5b2>
    9370:	8e a1       	lds	r24, 0x4e
    9372:	9f a1       	lds	r25, 0x4f
    9374:	fc 01       	movw	r30, r24
    9376:	80 81       	ld	r24, Z
    9378:	85 3e       	cpi	r24, 0xE5	; 229
    937a:	09 f0       	breq	.+2      	; 0x937e <writeFile+0x5b2>
    937c:	6c c0       	rjmp	.+216    	; 0x9456 <writeFile+0x68a>
		{
		  for(j=0; j<11; j++)
    937e:	19 82       	std	Y+1, r1	; 0x01
    9380:	13 c0       	rjmp	.+38     	; 0x93a8 <writeFile+0x5dc>
  			dir->name[j] = Filename[j];
    9382:	89 81       	ldd	r24, Y+1	; 0x01
    9384:	88 2f       	mov	r24, r24
    9386:	90 e0       	ldi	r25, 0x00	; 0
    9388:	29 81       	ldd	r18, Y+1	; 0x01
    938a:	22 2f       	mov	r18, r18
    938c:	30 e0       	ldi	r19, 0x00	; 0
    938e:	24 55       	subi	r18, 0x54	; 84
    9390:	3f 4a       	sbci	r19, 0xAF	; 175
    9392:	f9 01       	movw	r30, r18
    9394:	40 81       	ld	r20, Z
    9396:	2e a1       	lds	r18, 0x4e
    9398:	3f a1       	lds	r19, 0x4f
    939a:	82 0f       	add	r24, r18
    939c:	93 1f       	adc	r25, r19
    939e:	fc 01       	movw	r30, r24
    93a0:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    93a2:	89 81       	ldd	r24, Y+1	; 0x01
    93a4:	8f 5f       	subi	r24, 0xFF	; 255
    93a6:	89 83       	std	Y+1, r24	; 0x01
    93a8:	89 81       	ldd	r24, Y+1	; 0x01
    93aa:	8b 30       	cpi	r24, 0x0B	; 11
    93ac:	50 f3       	brcs	.-44     	; 0x9382 <writeFile+0x5b6>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    93ae:	8e a1       	lds	r24, 0x4e
    93b0:	9f a1       	lds	r25, 0x4f
    93b2:	20 e2       	ldi	r18, 0x20	; 32
    93b4:	fc 01       	movw	r30, r24
    93b6:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    93b8:	8e a1       	lds	r24, 0x4e
    93ba:	9f a1       	lds	r25, 0x4f
    93bc:	fc 01       	movw	r30, r24
    93be:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    93c0:	8e a1       	lds	r24, 0x4e
    93c2:	9f a1       	lds	r25, 0x4f
    93c4:	fc 01       	movw	r30, r24
    93c6:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    93c8:	8e a1       	lds	r24, 0x4e
    93ca:	9f a1       	lds	r25, 0x4f
    93cc:	fc 01       	movw	r30, r24
    93ce:	12 8a       	std	Z+18, r1	; 0x12
    93d0:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    93d2:	8e a1       	lds	r24, 0x4e
    93d4:	9f a1       	lds	r25, 0x4f
    93d6:	2e 81       	ldd	r18, Y+6	; 0x06
    93d8:	3f 81       	ldd	r19, Y+7	; 0x07
    93da:	fc 01       	movw	r30, r24
    93dc:	24 8b       	std	Z+20, r18	; 0x14
    93de:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    93e0:	8e a1       	lds	r24, 0x4e
    93e2:	9f a1       	lds	r25, 0x4f
    93e4:	28 85       	ldd	r18, Y+8	; 0x08
    93e6:	39 85       	ldd	r19, Y+9	; 0x09
    93e8:	fc 01       	movw	r30, r24
    93ea:	22 8f       	std	Z+26, r18	; 0x1a
    93ec:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    93ee:	80 91 41 40 	lds	r24, 0x4041
    93f2:	90 91 42 40 	lds	r25, 0x4042
    93f6:	a0 91 43 40 	lds	r26, 0x4043
    93fa:	b0 91 44 40 	lds	r27, 0x4044
    93fe:	2e a1       	lds	r18, 0x4e
    9400:	3f a1       	lds	r19, 0x4f
    9402:	f9 01       	movw	r30, r18
    9404:	84 8f       	std	Z+28, r24	; 0x1c
    9406:	95 8f       	std	Z+29, r25	; 0x1d
    9408:	a6 8f       	std	Z+30, r26	; 0x1e
    940a:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    940c:	8d 81       	ldd	r24, Y+5	; 0x05
    940e:	28 2f       	mov	r18, r24
    9410:	30 e0       	ldi	r19, 0x00	; 0
    9412:	40 e0       	ldi	r20, 0x00	; 0
    9414:	50 e0       	ldi	r21, 0x00	; 0
    9416:	8c a5       	lds	r24, 0x6c
    9418:	9d a5       	lds	r25, 0x6d
    941a:	ae a5       	lds	r26, 0x6e
    941c:	bf a5       	lds	r27, 0x6f
    941e:	82 0f       	add	r24, r18
    9420:	93 1f       	adc	r25, r19
    9422:	a4 1f       	adc	r26, r20
    9424:	b5 1f       	adc	r27, r21
    9426:	27 ec       	ldi	r18, 0xC7	; 199
    9428:	31 e2       	ldi	r19, 0x21	; 33
    942a:	bc 01       	movw	r22, r24
    942c:	cd 01       	movw	r24, r26
    942e:	a9 01       	movw	r20, r18
    9430:	20 e0       	ldi	r18, 0x00	; 0
    9432:	32 e0       	ldi	r19, 0x02	; 2
    9434:	0e 94 f1 4e 	call	0x9de2	; 0x9de2 <SD_write_block>
		  fileCreatedFlag = 1;
    9438:	81 e0       	ldi	r24, 0x01	; 1
    943a:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    943c:	20 91 41 40 	lds	r18, 0x4041
    9440:	30 91 42 40 	lds	r19, 0x4042
    9444:	40 91 43 40 	lds	r20, 0x4043
    9448:	50 91 44 40 	lds	r21, 0x4044
    944c:	81 e0       	ldi	r24, 0x01	; 1
    944e:	ba 01       	movw	r22, r20
    9450:	a9 01       	movw	r20, r18
    9452:	0e 94 92 4b 	call	0x9724	; 0x9724 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    9456:	88 a1       	lds	r24, 0x48
    9458:	99 a1       	lds	r25, 0x49
    945a:	80 96       	adiw	r24, 0x20	; 32
    945c:	88 a3       	lds	r24, 0x58
    945e:	99 a3       	lds	r25, 0x59
    9460:	28 a1       	lds	r18, 0x48
    9462:	39 a1       	lds	r19, 0x49
    9464:	80 91 45 40 	lds	r24, 0x4045
    9468:	90 91 46 40 	lds	r25, 0x4046
    946c:	28 17       	cp	r18, r24
    946e:	39 07       	cpc	r19, r25
    9470:	08 f4       	brcc	.+2      	; 0x9474 <writeFile+0x6a8>
    9472:	6d cf       	rjmp	.-294    	; 0x934e <writeFile+0x582>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    9474:	8d 81       	ldd	r24, Y+5	; 0x05
    9476:	8f 5f       	subi	r24, 0xFF	; 255
    9478:	8d 83       	std	Y+5, r24	; 0x05
    947a:	8d 81       	ldd	r24, Y+5	; 0x05
    947c:	28 2f       	mov	r18, r24
    947e:	30 e0       	ldi	r19, 0x00	; 0
    9480:	80 91 6c 50 	lds	r24, 0x506C
    9484:	90 91 6d 50 	lds	r25, 0x506D
    9488:	28 17       	cp	r18, r24
    948a:	39 07       	cpc	r19, r25
    948c:	08 f4       	brcc	.+2      	; 0x9490 <writeFile+0x6c4>
    948e:	48 cf       	rjmp	.-368    	; 0x9320 <writeFile+0x554>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    9490:	88 89       	ldd	r24, Y+16	; 0x10
    9492:	99 89       	ldd	r25, Y+17	; 0x11
    9494:	aa 89       	ldd	r26, Y+18	; 0x12
    9496:	bb 89       	ldd	r27, Y+19	; 0x13
    9498:	bc 01       	movw	r22, r24
    949a:	cd 01       	movw	r24, r26
    949c:	40 e0       	ldi	r20, 0x00	; 0
    949e:	00 e0       	ldi	r16, 0x00	; 0
    94a0:	10 e0       	ldi	r17, 0x00	; 0
    94a2:	98 01       	movw	r18, r16
    94a4:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
    94a8:	dc 01       	movw	r26, r24
    94aa:	cb 01       	movw	r24, r22
    94ac:	8c 87       	std	Y+12, r24	; 0x0c
    94ae:	9d 87       	std	Y+13, r25	; 0x0d
    94b0:	ae 87       	std	Y+14, r26	; 0x0e
    94b2:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    94b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    94b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    94b8:	ae 85       	ldd	r26, Y+14	; 0x0e
    94ba:	bf 85       	ldd	r27, Y+15	; 0x0f
    94bc:	87 3f       	cpi	r24, 0xF7	; 247
    94be:	ff ef       	ldi	r31, 0xFF	; 255
    94c0:	9f 07       	cpc	r25, r31
    94c2:	ff ef       	ldi	r31, 0xFF	; 255
    94c4:	af 07       	cpc	r26, r31
    94c6:	ff e0       	ldi	r31, 0x0F	; 15
    94c8:	bf 07       	cpc	r27, r31
    94ca:	b0 f1       	brcs	.+108    	; 0x9538 <writeFile+0x76c>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    94cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    94ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    94d0:	ae 85       	ldd	r26, Y+14	; 0x0e
    94d2:	bf 85       	ldd	r27, Y+15	; 0x0f
    94d4:	8f 3f       	cpi	r24, 0xFF	; 255
    94d6:	0f ef       	ldi	r16, 0xFF	; 255
    94d8:	90 07       	cpc	r25, r16
    94da:	0f ef       	ldi	r16, 0xFF	; 255
    94dc:	a0 07       	cpc	r26, r16
    94de:	0f ef       	ldi	r16, 0xFF	; 255
    94e0:	b0 07       	cpc	r27, r16
    94e2:	41 f5       	brne	.+80     	; 0x9534 <writeFile+0x768>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    94e4:	88 89       	ldd	r24, Y+16	; 0x10
    94e6:	99 89       	ldd	r25, Y+17	; 0x11
    94e8:	aa 89       	ldd	r26, Y+18	; 0x12
    94ea:	bb 89       	ldd	r27, Y+19	; 0x13
    94ec:	bc 01       	movw	r22, r24
    94ee:	cd 01       	movw	r24, r26
    94f0:	0e 94 b9 4a 	call	0x9572	; 0x9572 <searchNextFreeCluster>
    94f4:	dc 01       	movw	r26, r24
    94f6:	cb 01       	movw	r24, r22
    94f8:	8c 87       	std	Y+12, r24	; 0x0c
    94fa:	9d 87       	std	Y+13, r25	; 0x0d
    94fc:	ae 87       	std	Y+14, r26	; 0x0e
    94fe:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    9500:	88 89       	ldd	r24, Y+16	; 0x10
    9502:	99 89       	ldd	r25, Y+17	; 0x11
    9504:	aa 89       	ldd	r26, Y+18	; 0x12
    9506:	bb 89       	ldd	r27, Y+19	; 0x13
    9508:	0c 85       	ldd	r16, Y+12	; 0x0c
    950a:	1d 85       	ldd	r17, Y+13	; 0x0d
    950c:	2e 85       	ldd	r18, Y+14	; 0x0e
    950e:	3f 85       	ldd	r19, Y+15	; 0x0f
    9510:	bc 01       	movw	r22, r24
    9512:	cd 01       	movw	r24, r26
    9514:	41 e0       	ldi	r20, 0x01	; 1
    9516:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    951a:	8c 85       	ldd	r24, Y+12	; 0x0c
    951c:	9d 85       	ldd	r25, Y+13	; 0x0d
    951e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9520:	bf 85       	ldd	r27, Y+15	; 0x0f
    9522:	bc 01       	movw	r22, r24
    9524:	cd 01       	movw	r24, r26
    9526:	41 e0       	ldi	r20, 0x01	; 1
    9528:	0f ef       	ldi	r16, 0xFF	; 255
    952a:	1f ef       	ldi	r17, 0xFF	; 255
    952c:	98 01       	movw	r18, r16
    952e:	0e 94 dc 41 	call	0x83b8	; 0x83b8 <getSetNextCluster>
    9532:	02 c0       	rjmp	.+4      	; 0x9538 <writeFile+0x76c>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    9534:	83 e0       	ldi	r24, 0x03	; 3
    9536:	13 c0       	rjmp	.+38     	; 0x955e <writeFile+0x792>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    9538:	8c 85       	ldd	r24, Y+12	; 0x0c
    953a:	9d 85       	ldd	r25, Y+13	; 0x0d
    953c:	ae 85       	ldd	r26, Y+14	; 0x0e
    953e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9540:	00 97       	sbiw	r24, 0x00	; 0
    9542:	a1 05       	cpc	r26, r1
    9544:	b1 05       	cpc	r27, r1
    9546:	11 f4       	brne	.+4      	; 0x954c <writeFile+0x780>
	   return 4;
    9548:	84 e0       	ldi	r24, 0x04	; 4
    954a:	09 c0       	rjmp	.+18     	; 0x955e <writeFile+0x792>
	}
   
   prevCluster = cluster;
    954c:	8c 85       	ldd	r24, Y+12	; 0x0c
    954e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9550:	ae 85       	ldd	r26, Y+14	; 0x0e
    9552:	bf 85       	ldd	r27, Y+15	; 0x0f
    9554:	88 8b       	std	Y+16, r24	; 0x10
    9556:	99 8b       	std	Y+17, r25	; 0x11
    9558:	aa 8b       	std	Y+18, r26	; 0x12
    955a:	bb 8b       	std	Y+19, r27	; 0x13
 }
    955c:	d1 ce       	rjmp	.-606    	; 0x9300 <writeFile+0x534>
 
 return 0;
}
    955e:	e7 96       	adiw	r28, 0x37	; 55
    9560:	cd bf       	out	0x3d, r28	; 61
    9562:	de bf       	out	0x3e, r29	; 62
    9564:	df 91       	pop	r29
    9566:	cf 91       	pop	r28
    9568:	1f 91       	pop	r17
    956a:	0f 91       	pop	r16
    956c:	ff 90       	pop	r15
    956e:	ef 90       	pop	r14
    9570:	08 95       	ret

00009572 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    9572:	ef 92       	push	r14
    9574:	ff 92       	push	r15
    9576:	0f 93       	push	r16
    9578:	1f 93       	push	r17
    957a:	cf 93       	push	r28
    957c:	df 93       	push	r29
    957e:	cd b7       	in	r28, 0x3d	; 61
    9580:	de b7       	in	r29, 0x3e	; 62
    9582:	2f 97       	sbiw	r28, 0x0f	; 15
    9584:	cd bf       	out	0x3d, r28	; 61
    9586:	de bf       	out	0x3e, r29	; 62
    9588:	6c 87       	std	Y+12, r22	; 0x0c
    958a:	7d 87       	std	Y+13, r23	; 0x0d
    958c:	8e 87       	std	Y+14, r24	; 0x0e
    958e:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    9590:	8c 85       	ldd	r24, Y+12	; 0x0c
    9592:	9d 85       	ldd	r25, Y+13	; 0x0d
    9594:	ae 85       	ldd	r26, Y+14	; 0x0e
    9596:	bf 85       	ldd	r27, Y+15	; 0x0f
    9598:	80 78       	andi	r24, 0x80	; 128
    959a:	8c 87       	std	Y+12, r24	; 0x0c
    959c:	9d 87       	std	Y+13, r25	; 0x0d
    959e:	ae 87       	std	Y+14, r26	; 0x0e
    95a0:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    95a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    95a4:	9d 85       	ldd	r25, Y+13	; 0x0d
    95a6:	ae 85       	ldd	r26, Y+14	; 0x0e
    95a8:	bf 85       	ldd	r27, Y+15	; 0x0f
    95aa:	89 83       	std	Y+1, r24	; 0x01
    95ac:	9a 83       	std	Y+2, r25	; 0x02
    95ae:	ab 83       	std	Y+3, r26	; 0x03
    95b0:	bc 83       	std	Y+4, r27	; 0x04
    95b2:	7a c0       	rjmp	.+244    	; 0x96a8 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    95b4:	80 91 74 50 	lds	r24, 0x5074
    95b8:	90 91 75 50 	lds	r25, 0x5075
    95bc:	9c 01       	movw	r18, r24
    95be:	40 e0       	ldi	r20, 0x00	; 0
    95c0:	50 e0       	ldi	r21, 0x00	; 0
    95c2:	80 91 6e 50 	lds	r24, 0x506E
    95c6:	90 91 6f 50 	lds	r25, 0x506F
    95ca:	a0 91 70 50 	lds	r26, 0x5070
    95ce:	b0 91 71 50 	lds	r27, 0x5071
    95d2:	79 01       	movw	r14, r18
    95d4:	8a 01       	movw	r16, r20
    95d6:	e8 0e       	add	r14, r24
    95d8:	f9 1e       	adc	r15, r25
    95da:	0a 1f       	adc	r16, r26
    95dc:	1b 1f       	adc	r17, r27
    95de:	89 81       	ldd	r24, Y+1	; 0x01
    95e0:	9a 81       	ldd	r25, Y+2	; 0x02
    95e2:	ab 81       	ldd	r26, Y+3	; 0x03
    95e4:	bc 81       	ldd	r27, Y+4	; 0x04
    95e6:	88 0f       	add	r24, r24
    95e8:	99 1f       	adc	r25, r25
    95ea:	aa 1f       	adc	r26, r26
    95ec:	bb 1f       	adc	r27, r27
    95ee:	88 0f       	add	r24, r24
    95f0:	99 1f       	adc	r25, r25
    95f2:	aa 1f       	adc	r26, r26
    95f4:	bb 1f       	adc	r27, r27
    95f6:	20 91 45 40 	lds	r18, 0x4045
    95fa:	30 91 46 40 	lds	r19, 0x4046
    95fe:	99 01       	movw	r18, r18
    9600:	40 e0       	ldi	r20, 0x00	; 0
    9602:	50 e0       	ldi	r21, 0x00	; 0
    9604:	bc 01       	movw	r22, r24
    9606:	cd 01       	movw	r24, r26
    9608:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    960c:	da 01       	movw	r26, r20
    960e:	c9 01       	movw	r24, r18
    9610:	8e 0d       	add	r24, r14
    9612:	9f 1d       	adc	r25, r15
    9614:	a0 1f       	adc	r26, r16
    9616:	b1 1f       	adc	r27, r17
    9618:	8e 83       	std	Y+6, r24	; 0x06
    961a:	9f 83       	std	Y+7, r25	; 0x07
    961c:	a8 87       	std	Y+8, r26	; 0x08
    961e:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    9620:	8e 81       	ldd	r24, Y+6	; 0x06
    9622:	9f 81       	ldd	r25, Y+7	; 0x07
    9624:	a8 85       	ldd	r26, Y+8	; 0x08
    9626:	b9 85       	ldd	r27, Y+9	; 0x09
    9628:	27 ec       	ldi	r18, 0xC7	; 199
    962a:	31 e2       	ldi	r19, 0x21	; 33
    962c:	bc 01       	movw	r22, r24
    962e:	cd 01       	movw	r24, r26
    9630:	a9 01       	movw	r20, r18
    9632:	0e 94 bf 4f 	call	0x9f7e	; 0x9f7e <SD_read_block>
      for(i=0; i<128; i++)
    9636:	1d 82       	std	Y+5, r1	; 0x05
    9638:	28 c0       	rjmp	.+80     	; 0x968a <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    963a:	8d 81       	ldd	r24, Y+5	; 0x05
    963c:	88 2f       	mov	r24, r24
    963e:	90 e0       	ldi	r25, 0x00	; 0
    9640:	88 0f       	add	r24, r24
    9642:	99 1f       	adc	r25, r25
    9644:	88 0f       	add	r24, r24
    9646:	99 1f       	adc	r25, r25
    9648:	89 53       	subi	r24, 0x39	; 57
    964a:	9e 4d       	sbci	r25, 0xDE	; 222
    964c:	8a 87       	std	Y+10, r24	; 0x0a
    964e:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    9650:	8a 85       	ldd	r24, Y+10	; 0x0a
    9652:	9b 85       	ldd	r25, Y+11	; 0x0b
    9654:	fc 01       	movw	r30, r24
    9656:	80 81       	ld	r24, Z
    9658:	91 81       	ldd	r25, Z+1	; 0x01
    965a:	a2 81       	ldd	r26, Z+2	; 0x02
    965c:	b3 81       	ldd	r27, Z+3	; 0x03
    965e:	bf 70       	andi	r27, 0x0F	; 15
    9660:	00 97       	sbiw	r24, 0x00	; 0
    9662:	a1 05       	cpc	r26, r1
    9664:	b1 05       	cpc	r27, r1
    9666:	71 f4       	brne	.+28     	; 0x9684 <searchNextFreeCluster+0x112>
            return(cluster+i);
    9668:	8d 81       	ldd	r24, Y+5	; 0x05
    966a:	28 2f       	mov	r18, r24
    966c:	30 e0       	ldi	r19, 0x00	; 0
    966e:	40 e0       	ldi	r20, 0x00	; 0
    9670:	50 e0       	ldi	r21, 0x00	; 0
    9672:	89 81       	ldd	r24, Y+1	; 0x01
    9674:	9a 81       	ldd	r25, Y+2	; 0x02
    9676:	ab 81       	ldd	r26, Y+3	; 0x03
    9678:	bc 81       	ldd	r27, Y+4	; 0x04
    967a:	82 0f       	add	r24, r18
    967c:	93 1f       	adc	r25, r19
    967e:	a4 1f       	adc	r26, r20
    9680:	b5 1f       	adc	r27, r21
    9682:	27 c0       	rjmp	.+78     	; 0x96d2 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    9684:	8d 81       	ldd	r24, Y+5	; 0x05
    9686:	8f 5f       	subi	r24, 0xFF	; 255
    9688:	8d 83       	std	Y+5, r24	; 0x05
    968a:	8d 81       	ldd	r24, Y+5	; 0x05
    968c:	88 23       	and	r24, r24
    968e:	ac f6       	brge	.-86     	; 0x963a <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9690:	89 81       	ldd	r24, Y+1	; 0x01
    9692:	9a 81       	ldd	r25, Y+2	; 0x02
    9694:	ab 81       	ldd	r26, Y+3	; 0x03
    9696:	bc 81       	ldd	r27, Y+4	; 0x04
    9698:	80 58       	subi	r24, 0x80	; 128
    969a:	9f 4f       	sbci	r25, 0xFF	; 255
    969c:	af 4f       	sbci	r26, 0xFF	; 255
    969e:	bf 4f       	sbci	r27, 0xFF	; 255
    96a0:	89 83       	std	Y+1, r24	; 0x01
    96a2:	9a 83       	std	Y+2, r25	; 0x02
    96a4:	ab 83       	std	Y+3, r26	; 0x03
    96a6:	bc 83       	std	Y+4, r27	; 0x04
    96a8:	80 91 4a 40 	lds	r24, 0x404A
    96ac:	90 91 4b 40 	lds	r25, 0x404B
    96b0:	a0 91 4c 40 	lds	r26, 0x404C
    96b4:	b0 91 4d 40 	lds	r27, 0x404D
    96b8:	29 81       	ldd	r18, Y+1	; 0x01
    96ba:	3a 81       	ldd	r19, Y+2	; 0x02
    96bc:	4b 81       	ldd	r20, Y+3	; 0x03
    96be:	5c 81       	ldd	r21, Y+4	; 0x04
    96c0:	28 17       	cp	r18, r24
    96c2:	39 07       	cpc	r19, r25
    96c4:	4a 07       	cpc	r20, r26
    96c6:	5b 07       	cpc	r21, r27
    96c8:	08 f4       	brcc	.+2      	; 0x96cc <searchNextFreeCluster+0x15a>
    96ca:	74 cf       	rjmp	.-280    	; 0x95b4 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    96cc:	80 e0       	ldi	r24, 0x00	; 0
    96ce:	90 e0       	ldi	r25, 0x00	; 0
    96d0:	dc 01       	movw	r26, r24
}
    96d2:	bc 01       	movw	r22, r24
    96d4:	cd 01       	movw	r24, r26
    96d6:	2f 96       	adiw	r28, 0x0f	; 15
    96d8:	cd bf       	out	0x3d, r28	; 61
    96da:	de bf       	out	0x3e, r29	; 62
    96dc:	df 91       	pop	r29
    96de:	cf 91       	pop	r28
    96e0:	1f 91       	pop	r17
    96e2:	0f 91       	pop	r16
    96e4:	ff 90       	pop	r15
    96e6:	ef 90       	pop	r14
    96e8:	08 95       	ret

000096ea <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    96ea:	cf 93       	push	r28
    96ec:	df 93       	push	r29
    96ee:	00 d0       	rcall	.+0      	; 0x96f0 <deleteFile+0x6>
    96f0:	cd b7       	in	r28, 0x3d	; 61
    96f2:	de b7       	in	r29, 0x3e	; 62
    96f4:	8a 83       	std	Y+2, r24	; 0x02
    96f6:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    96f8:	8a 81       	ldd	r24, Y+2	; 0x02
    96fa:	9b 81       	ldd	r25, Y+3	; 0x03
    96fc:	0e 94 b0 45 	call	0x8b60	; 0x8b60 <convertFileName>
    9700:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9702:	89 81       	ldd	r24, Y+1	; 0x01
    9704:	88 23       	and	r24, r24
    9706:	39 f4       	brne	.+14     	; 0x9716 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9708:	2c ea       	ldi	r18, 0xAC	; 172
    970a:	30 e5       	ldi	r19, 0x50	; 80
    970c:	82 e0       	ldi	r24, 0x02	; 2
    970e:	b9 01       	movw	r22, r18
    9710:	0e 94 36 43 	call	0x866c	; 0x866c <findFiles>
    9714:	01 c0       	rjmp	.+2      	; 0x9718 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9716:	00 00       	nop

  findFiles (DELETE, Filename);
}
    9718:	23 96       	adiw	r28, 0x03	; 3
    971a:	cd bf       	out	0x3d, r28	; 61
    971c:	de bf       	out	0x3e, r29	; 62
    971e:	df 91       	pop	r29
    9720:	cf 91       	pop	r28
    9722:	08 95       	ret

00009724 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9724:	ef 92       	push	r14
    9726:	ff 92       	push	r15
    9728:	0f 93       	push	r16
    972a:	1f 93       	push	r17
    972c:	cf 93       	push	r28
    972e:	df 93       	push	r29
    9730:	cd b7       	in	r28, 0x3d	; 61
    9732:	de b7       	in	r29, 0x3e	; 62
    9734:	29 97       	sbiw	r28, 0x09	; 9
    9736:	cd bf       	out	0x3d, r28	; 61
    9738:	de bf       	out	0x3e, r29	; 62
    973a:	8d 83       	std	Y+5, r24	; 0x05
    973c:	4e 83       	std	Y+6, r20	; 0x06
    973e:	5f 83       	std	Y+7, r21	; 0x07
    9740:	68 87       	std	Y+8, r22	; 0x08
    9742:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    9744:	8e 81       	ldd	r24, Y+6	; 0x06
    9746:	9f 81       	ldd	r25, Y+7	; 0x07
    9748:	a8 85       	ldd	r26, Y+8	; 0x08
    974a:	b9 85       	ldd	r27, Y+9	; 0x09
    974c:	91 70       	andi	r25, 0x01	; 1
    974e:	a0 70       	andi	r26, 0x00	; 0
    9750:	b0 70       	andi	r27, 0x00	; 0
    9752:	00 97       	sbiw	r24, 0x00	; 0
    9754:	a1 05       	cpc	r26, r1
    9756:	b1 05       	cpc	r27, r1
    9758:	91 f4       	brne	.+36     	; 0x977e <freeMemoryUpdate+0x5a>
    975a:	8e 81       	ldd	r24, Y+6	; 0x06
    975c:	9f 81       	ldd	r25, Y+7	; 0x07
    975e:	a8 85       	ldd	r26, Y+8	; 0x08
    9760:	b9 85       	ldd	r27, Y+9	; 0x09
    9762:	07 2e       	mov	r0, r23
    9764:	79 e0       	ldi	r23, 0x09	; 9
    9766:	b6 95       	lsr	r27
    9768:	a7 95       	ror	r26
    976a:	97 95       	ror	r25
    976c:	87 95       	ror	r24
    976e:	7a 95       	dec	r23
    9770:	d1 f7       	brne	.-12     	; 0x9766 <freeMemoryUpdate+0x42>
    9772:	70 2d       	mov	r23, r0
    9774:	8e 83       	std	Y+6, r24	; 0x06
    9776:	9f 83       	std	Y+7, r25	; 0x07
    9778:	a8 87       	std	Y+8, r26	; 0x08
    977a:	b9 87       	std	Y+9, r27	; 0x09
    977c:	14 c0       	rjmp	.+40     	; 0x97a6 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    977e:	8e 81       	ldd	r24, Y+6	; 0x06
    9780:	9f 81       	ldd	r25, Y+7	; 0x07
    9782:	a8 85       	ldd	r26, Y+8	; 0x08
    9784:	b9 85       	ldd	r27, Y+9	; 0x09
    9786:	07 2e       	mov	r0, r23
    9788:	79 e0       	ldi	r23, 0x09	; 9
    978a:	b6 95       	lsr	r27
    978c:	a7 95       	ror	r26
    978e:	97 95       	ror	r25
    9790:	87 95       	ror	r24
    9792:	7a 95       	dec	r23
    9794:	d1 f7       	brne	.-12     	; 0x978a <freeMemoryUpdate+0x66>
    9796:	70 2d       	mov	r23, r0
    9798:	01 96       	adiw	r24, 0x01	; 1
    979a:	a1 1d       	adc	r26, r1
    979c:	b1 1d       	adc	r27, r1
    979e:	8e 83       	std	Y+6, r24	; 0x06
    97a0:	9f 83       	std	Y+7, r25	; 0x07
    97a2:	a8 87       	std	Y+8, r26	; 0x08
    97a4:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    97a6:	8e 81       	ldd	r24, Y+6	; 0x06
    97a8:	9f 81       	ldd	r25, Y+7	; 0x07
    97aa:	a8 85       	ldd	r26, Y+8	; 0x08
    97ac:	b9 85       	ldd	r27, Y+9	; 0x09
    97ae:	87 70       	andi	r24, 0x07	; 7
    97b0:	90 70       	andi	r25, 0x00	; 0
    97b2:	a0 70       	andi	r26, 0x00	; 0
    97b4:	b0 70       	andi	r27, 0x00	; 0
    97b6:	00 97       	sbiw	r24, 0x00	; 0
    97b8:	a1 05       	cpc	r26, r1
    97ba:	b1 05       	cpc	r27, r1
    97bc:	89 f4       	brne	.+34     	; 0x97e0 <freeMemoryUpdate+0xbc>
    97be:	8e 81       	ldd	r24, Y+6	; 0x06
    97c0:	9f 81       	ldd	r25, Y+7	; 0x07
    97c2:	a8 85       	ldd	r26, Y+8	; 0x08
    97c4:	b9 85       	ldd	r27, Y+9	; 0x09
    97c6:	68 94       	set
    97c8:	12 f8       	bld	r1, 2
    97ca:	b6 95       	lsr	r27
    97cc:	a7 95       	ror	r26
    97ce:	97 95       	ror	r25
    97d0:	87 95       	ror	r24
    97d2:	16 94       	lsr	r1
    97d4:	d1 f7       	brne	.-12     	; 0x97ca <freeMemoryUpdate+0xa6>
    97d6:	8e 83       	std	Y+6, r24	; 0x06
    97d8:	9f 83       	std	Y+7, r25	; 0x07
    97da:	a8 87       	std	Y+8, r26	; 0x08
    97dc:	b9 87       	std	Y+9, r27	; 0x09
    97de:	13 c0       	rjmp	.+38     	; 0x9806 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    97e0:	8e 81       	ldd	r24, Y+6	; 0x06
    97e2:	9f 81       	ldd	r25, Y+7	; 0x07
    97e4:	a8 85       	ldd	r26, Y+8	; 0x08
    97e6:	b9 85       	ldd	r27, Y+9	; 0x09
    97e8:	68 94       	set
    97ea:	12 f8       	bld	r1, 2
    97ec:	b6 95       	lsr	r27
    97ee:	a7 95       	ror	r26
    97f0:	97 95       	ror	r25
    97f2:	87 95       	ror	r24
    97f4:	16 94       	lsr	r1
    97f6:	d1 f7       	brne	.-12     	; 0x97ec <freeMemoryUpdate+0xc8>
    97f8:	01 96       	adiw	r24, 0x01	; 1
    97fa:	a1 1d       	adc	r26, r1
    97fc:	b1 1d       	adc	r27, r1
    97fe:	8e 83       	std	Y+6, r24	; 0x06
    9800:	9f 83       	std	Y+7, r25	; 0x07
    9802:	a8 87       	std	Y+8, r26	; 0x08
    9804:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9806:	80 91 c0 50 	lds	r24, 0x50C0
    980a:	88 23       	and	r24, r24
    980c:	e9 f1       	breq	.+122    	; 0x9888 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    980e:	81 e0       	ldi	r24, 0x01	; 1
    9810:	60 e0       	ldi	r22, 0x00	; 0
    9812:	20 e0       	ldi	r18, 0x00	; 0
    9814:	30 e0       	ldi	r19, 0x00	; 0
    9816:	a9 01       	movw	r20, r18
    9818:	0e 94 85 42 	call	0x850a	; 0x850a <getSetFreeCluster>
    981c:	dc 01       	movw	r26, r24
    981e:	cb 01       	movw	r24, r22
    9820:	89 83       	std	Y+1, r24	; 0x01
    9822:	9a 83       	std	Y+2, r25	; 0x02
    9824:	ab 83       	std	Y+3, r26	; 0x03
    9826:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9828:	8d 81       	ldd	r24, Y+5	; 0x05
    982a:	88 23       	and	r24, r24
    982c:	89 f4       	brne	.+34     	; 0x9850 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    982e:	29 81       	ldd	r18, Y+1	; 0x01
    9830:	3a 81       	ldd	r19, Y+2	; 0x02
    9832:	4b 81       	ldd	r20, Y+3	; 0x03
    9834:	5c 81       	ldd	r21, Y+4	; 0x04
    9836:	8e 81       	ldd	r24, Y+6	; 0x06
    9838:	9f 81       	ldd	r25, Y+7	; 0x07
    983a:	a8 85       	ldd	r26, Y+8	; 0x08
    983c:	b9 85       	ldd	r27, Y+9	; 0x09
    983e:	82 0f       	add	r24, r18
    9840:	93 1f       	adc	r25, r19
    9842:	a4 1f       	adc	r26, r20
    9844:	b5 1f       	adc	r27, r21
    9846:	89 83       	std	Y+1, r24	; 0x01
    9848:	9a 83       	std	Y+2, r25	; 0x02
    984a:	ab 83       	std	Y+3, r26	; 0x03
    984c:	bc 83       	std	Y+4, r27	; 0x04
    984e:	14 c0       	rjmp	.+40     	; 0x9878 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    9850:	29 81       	ldd	r18, Y+1	; 0x01
    9852:	3a 81       	ldd	r19, Y+2	; 0x02
    9854:	4b 81       	ldd	r20, Y+3	; 0x03
    9856:	5c 81       	ldd	r21, Y+4	; 0x04
    9858:	8e 81       	ldd	r24, Y+6	; 0x06
    985a:	9f 81       	ldd	r25, Y+7	; 0x07
    985c:	a8 85       	ldd	r26, Y+8	; 0x08
    985e:	b9 85       	ldd	r27, Y+9	; 0x09
    9860:	79 01       	movw	r14, r18
    9862:	8a 01       	movw	r16, r20
    9864:	e8 1a       	sub	r14, r24
    9866:	f9 0a       	sbc	r15, r25
    9868:	0a 0b       	sbc	r16, r26
    986a:	1b 0b       	sbc	r17, r27
    986c:	d8 01       	movw	r26, r16
    986e:	c7 01       	movw	r24, r14
    9870:	89 83       	std	Y+1, r24	; 0x01
    9872:	9a 83       	std	Y+2, r25	; 0x02
    9874:	ab 83       	std	Y+3, r26	; 0x03
    9876:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9878:	29 81       	ldd	r18, Y+1	; 0x01
    987a:	3a 81       	ldd	r19, Y+2	; 0x02
    987c:	4b 81       	ldd	r20, Y+3	; 0x03
    987e:	5c 81       	ldd	r21, Y+4	; 0x04
    9880:	81 e0       	ldi	r24, 0x01	; 1
    9882:	61 e0       	ldi	r22, 0x01	; 1
    9884:	0e 94 85 42 	call	0x850a	; 0x850a <getSetFreeCluster>
  }
}
    9888:	29 96       	adiw	r28, 0x09	; 9
    988a:	cd bf       	out	0x3d, r28	; 61
    988c:	de bf       	out	0x3e, r29	; 62
    988e:	df 91       	pop	r29
    9890:	cf 91       	pop	r28
    9892:	1f 91       	pop	r17
    9894:	0f 91       	pop	r16
    9896:	ff 90       	pop	r15
    9898:	ef 90       	pop	r14
    989a:	08 95       	ret

0000989c <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    989c:	0f 93       	push	r16
    989e:	1f 93       	push	r17
    98a0:	cf 93       	push	r28
    98a2:	df 93       	push	r29
    98a4:	cd b7       	in	r28, 0x3d	; 61
    98a6:	de b7       	in	r29, 0x3e	; 62
    98a8:	a9 97       	sbiw	r28, 0x29	; 41
    98aa:	cd bf       	out	0x3d, r28	; 61
    98ac:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    98ae:	81 e0       	ldi	r24, 0x01	; 1
    98b0:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    98b4:	81 e0       	ldi	r24, 0x01	; 1
    98b6:	0e 94 6d 35 	call	0x6ada	; 0x6ada <Ext1Power>
    98ba:	80 e0       	ldi	r24, 0x00	; 0
    98bc:	90 e0       	ldi	r25, 0x00	; 0
    98be:	a8 ec       	ldi	r26, 0xC8	; 200
    98c0:	b2 e4       	ldi	r27, 0x42	; 66
    98c2:	8e 87       	std	Y+14, r24	; 0x0e
    98c4:	9f 87       	std	Y+15, r25	; 0x0f
    98c6:	a8 8b       	std	Y+16, r26	; 0x10
    98c8:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    98ca:	6e 85       	ldd	r22, Y+14	; 0x0e
    98cc:	7f 85       	ldd	r23, Y+15	; 0x0f
    98ce:	88 89       	ldd	r24, Y+16	; 0x10
    98d0:	99 89       	ldd	r25, Y+17	; 0x11
    98d2:	20 e0       	ldi	r18, 0x00	; 0
    98d4:	30 e0       	ldi	r19, 0x00	; 0
    98d6:	4a ef       	ldi	r20, 0xFA	; 250
    98d8:	55 e4       	ldi	r21, 0x45	; 69
    98da:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    98de:	dc 01       	movw	r26, r24
    98e0:	cb 01       	movw	r24, r22
    98e2:	8a 8b       	std	Y+18, r24	; 0x12
    98e4:	9b 8b       	std	Y+19, r25	; 0x13
    98e6:	ac 8b       	std	Y+20, r26	; 0x14
    98e8:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    98ea:	11 e0       	ldi	r17, 0x01	; 1
    98ec:	6a 89       	ldd	r22, Y+18	; 0x12
    98ee:	7b 89       	ldd	r23, Y+19	; 0x13
    98f0:	8c 89       	ldd	r24, Y+20	; 0x14
    98f2:	9d 89       	ldd	r25, Y+21	; 0x15
    98f4:	20 e0       	ldi	r18, 0x00	; 0
    98f6:	30 e0       	ldi	r19, 0x00	; 0
    98f8:	40 e8       	ldi	r20, 0x80	; 128
    98fa:	5f e3       	ldi	r21, 0x3F	; 63
    98fc:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    9900:	88 23       	and	r24, r24
    9902:	0c f0       	brlt	.+2      	; 0x9906 <SD_init+0x6a>
    9904:	10 e0       	ldi	r17, 0x00	; 0
    9906:	11 23       	and	r17, r17
    9908:	29 f0       	breq	.+10     	; 0x9914 <SD_init+0x78>
		__ticks = 1;
    990a:	81 e0       	ldi	r24, 0x01	; 1
    990c:	90 e0       	ldi	r25, 0x00	; 0
    990e:	8e 8b       	std	Y+22, r24	; 0x16
    9910:	9f 8b       	std	Y+23, r25	; 0x17
    9912:	46 c0       	rjmp	.+140    	; 0x99a0 <SD_init+0x104>
	else if (__tmp > 65535)
    9914:	11 e0       	ldi	r17, 0x01	; 1
    9916:	6a 89       	ldd	r22, Y+18	; 0x12
    9918:	7b 89       	ldd	r23, Y+19	; 0x13
    991a:	8c 89       	ldd	r24, Y+20	; 0x14
    991c:	9d 89       	ldd	r25, Y+21	; 0x15
    991e:	20 e0       	ldi	r18, 0x00	; 0
    9920:	3f ef       	ldi	r19, 0xFF	; 255
    9922:	4f e7       	ldi	r20, 0x7F	; 127
    9924:	57 e4       	ldi	r21, 0x47	; 71
    9926:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    992a:	18 16       	cp	r1, r24
    992c:	0c f0       	brlt	.+2      	; 0x9930 <SD_init+0x94>
    992e:	10 e0       	ldi	r17, 0x00	; 0
    9930:	11 23       	and	r17, r17
    9932:	61 f1       	breq	.+88     	; 0x998c <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9934:	6e 85       	ldd	r22, Y+14	; 0x0e
    9936:	7f 85       	ldd	r23, Y+15	; 0x0f
    9938:	88 89       	ldd	r24, Y+16	; 0x10
    993a:	99 89       	ldd	r25, Y+17	; 0x11
    993c:	20 e0       	ldi	r18, 0x00	; 0
    993e:	30 e0       	ldi	r19, 0x00	; 0
    9940:	40 e2       	ldi	r20, 0x20	; 32
    9942:	51 e4       	ldi	r21, 0x41	; 65
    9944:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    9948:	dc 01       	movw	r26, r24
    994a:	cb 01       	movw	r24, r22
    994c:	bc 01       	movw	r22, r24
    994e:	cd 01       	movw	r24, r26
    9950:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    9954:	dc 01       	movw	r26, r24
    9956:	cb 01       	movw	r24, r22
    9958:	8e 8b       	std	Y+22, r24	; 0x16
    995a:	9f 8b       	std	Y+23, r25	; 0x17
    995c:	12 c0       	rjmp	.+36     	; 0x9982 <SD_init+0xe6>
    995e:	80 e2       	ldi	r24, 0x20	; 32
    9960:	93 e0       	ldi	r25, 0x03	; 3
    9962:	88 8f       	std	Y+24, r24	; 0x18
    9964:	99 8f       	std	Y+25, r25	; 0x19
    9966:	88 8d       	ldd	r24, Y+24	; 0x18
    9968:	99 8d       	ldd	r25, Y+25	; 0x19
    996a:	8c 01       	movw	r16, r24
    996c:	c8 01       	movw	r24, r16
    996e:	01 97       	sbiw	r24, 0x01	; 1
    9970:	f1 f7       	brne	.-4      	; 0x996e <SD_init+0xd2>
    9972:	8c 01       	movw	r16, r24
    9974:	08 8f       	std	Y+24, r16	; 0x18
    9976:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9978:	8e 89       	ldd	r24, Y+22	; 0x16
    997a:	9f 89       	ldd	r25, Y+23	; 0x17
    997c:	01 97       	sbiw	r24, 0x01	; 1
    997e:	8e 8b       	std	Y+22, r24	; 0x16
    9980:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9982:	8e 89       	ldd	r24, Y+22	; 0x16
    9984:	9f 89       	ldd	r25, Y+23	; 0x17
    9986:	00 97       	sbiw	r24, 0x00	; 0
    9988:	51 f7       	brne	.-44     	; 0x995e <SD_init+0xc2>
    998a:	17 c0       	rjmp	.+46     	; 0x99ba <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    998c:	6a 89       	ldd	r22, Y+18	; 0x12
    998e:	7b 89       	ldd	r23, Y+19	; 0x13
    9990:	8c 89       	ldd	r24, Y+20	; 0x14
    9992:	9d 89       	ldd	r25, Y+21	; 0x15
    9994:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    9998:	dc 01       	movw	r26, r24
    999a:	cb 01       	movw	r24, r22
    999c:	8e 8b       	std	Y+22, r24	; 0x16
    999e:	9f 8b       	std	Y+23, r25	; 0x17
    99a0:	8e 89       	ldd	r24, Y+22	; 0x16
    99a2:	9f 89       	ldd	r25, Y+23	; 0x17
    99a4:	8a 8f       	std	Y+26, r24	; 0x1a
    99a6:	9b 8f       	std	Y+27, r25	; 0x1b
    99a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    99aa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    99ac:	8c 01       	movw	r16, r24
    99ae:	f8 01       	movw	r30, r16
    99b0:	31 97       	sbiw	r30, 0x01	; 1
    99b2:	f1 f7       	brne	.-4      	; 0x99b0 <SD_init+0x114>
    99b4:	8f 01       	movw	r16, r30
    99b6:	0a 8f       	std	Y+26, r16	; 0x1a
    99b8:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    99ba:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    99bc:	88 e0       	ldi	r24, 0x08	; 8
    99be:	60 e0       	ldi	r22, 0x00	; 0
    99c0:	0e 94 d7 33 	call	0x67ae	; 0x67ae <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    99c4:	88 e0       	ldi	r24, 0x08	; 8
    99c6:	60 e0       	ldi	r22, 0x00	; 0
    99c8:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    99cc:	80 e0       	ldi	r24, 0x00	; 0
    99ce:	63 e0       	ldi	r22, 0x03	; 3
    99d0:	0e 94 9b 38 	call	0x7136	; 0x7136 <SPIInit2>
	SPICS(TRUE);
    99d4:	81 e0       	ldi	r24, 0x01	; 1
    99d6:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    99da:	1a 82       	std	Y+2, r1	; 0x02
    99dc:	1b 82       	std	Y+3, r1	; 0x03
    99de:	17 c0       	rjmp	.+46     	; 0x9a0e <SD_init+0x172>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    99e0:	80 ec       	ldi	r24, 0xC0	; 192
    99e2:	98 e0       	ldi	r25, 0x08	; 8
    99e4:	2f ef       	ldi	r18, 0xFF	; 255
    99e6:	fc 01       	movw	r30, r24
    99e8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    99ea:	00 00       	nop
    99ec:	80 ec       	ldi	r24, 0xC0	; 192
    99ee:	98 e0       	ldi	r25, 0x08	; 8
    99f0:	fc 01       	movw	r30, r24
    99f2:	82 81       	ldd	r24, Z+2	; 0x02
    99f4:	88 23       	and	r24, r24
    99f6:	d4 f7       	brge	.-12     	; 0x99ec <SD_init+0x150>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    99f8:	80 ec       	ldi	r24, 0xC0	; 192
    99fa:	98 e0       	ldi	r25, 0x08	; 8
    99fc:	fc 01       	movw	r30, r24
    99fe:	83 81       	ldd	r24, Z+3	; 0x03
    9a00:	80 93 ab 50 	sts	0x50AB, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9a04:	8a 81       	ldd	r24, Y+2	; 0x02
    9a06:	9b 81       	ldd	r25, Y+3	; 0x03
    9a08:	01 96       	adiw	r24, 0x01	; 1
    9a0a:	8a 83       	std	Y+2, r24	; 0x02
    9a0c:	9b 83       	std	Y+3, r25	; 0x03
    9a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    9a10:	9b 81       	ldd	r25, Y+3	; 0x03
    9a12:	8a 30       	cpi	r24, 0x0A	; 10
    9a14:	91 05       	cpc	r25, r1
    9a16:	24 f3       	brlt	.-56     	; 0x99e0 <SD_init+0x144>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    9a18:	80 e0       	ldi	r24, 0x00	; 0
    9a1a:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    9a1e:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9a22:	88 e0       	ldi	r24, 0x08	; 8
    9a24:	60 e0       	ldi	r22, 0x00	; 0
    9a26:	0e 94 06 35 	call	0x6a0c	; 0x6a0c <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9a2a:	80 e0       	ldi	r24, 0x00	; 0
    9a2c:	63 e0       	ldi	r22, 0x03	; 3
    9a2e:	0e 94 9b 38 	call	0x7136	; 0x7136 <SPIInit2>
	SPICS(TRUE);
    9a32:	81 e0       	ldi	r24, 0x01	; 1
    9a34:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9a38:	1c 82       	std	Y+4, r1	; 0x04
    9a3a:	1d 82       	std	Y+5, r1	; 0x05
    9a3c:	0d c0       	rjmp	.+26     	; 0x9a58 <SD_init+0x1bc>
		if (i >= 10) {												//try command 10 times before timing out
    9a3e:	8c 81       	ldd	r24, Y+4	; 0x04
    9a40:	9d 81       	ldd	r25, Y+5	; 0x05
    9a42:	8a 30       	cpi	r24, 0x0A	; 10
    9a44:	91 05       	cpc	r25, r1
    9a46:	1c f0       	brlt	.+6      	; 0x9a4e <SD_init+0x1b2>
			//there was no response to the first command
			errorCode = 1;
    9a48:	81 e0       	ldi	r24, 0x01	; 1
    9a4a:	89 83       	std	Y+1, r24	; 0x01
			break;
    9a4c:	10 c0       	rjmp	.+32     	; 0x9a6e <SD_init+0x1d2>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9a4e:	8c 81       	ldd	r24, Y+4	; 0x04
    9a50:	9d 81       	ldd	r25, Y+5	; 0x05
    9a52:	01 96       	adiw	r24, 0x01	; 1
    9a54:	8c 83       	std	Y+4, r24	; 0x04
    9a56:	9d 83       	std	Y+5, r25	; 0x05
    9a58:	80 e0       	ldi	r24, 0x00	; 0
    9a5a:	40 e0       	ldi	r20, 0x00	; 0
    9a5c:	50 e0       	ldi	r21, 0x00	; 0
    9a5e:	ba 01       	movw	r22, r20
    9a60:	25 e9       	ldi	r18, 0x95	; 149
    9a62:	08 e0       	ldi	r16, 0x08	; 8
    9a64:	10 e0       	ldi	r17, 0x00	; 0
    9a66:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
    9a6a:	81 30       	cpi	r24, 0x01	; 1
    9a6c:	41 f7       	brne	.-48     	; 0x9a3e <SD_init+0x1a2>
    9a6e:	80 e0       	ldi	r24, 0x00	; 0
    9a70:	90 e0       	ldi	r25, 0x00	; 0
    9a72:	a8 ec       	ldi	r26, 0xC8	; 200
    9a74:	b2 e4       	ldi	r27, 0x42	; 66
    9a76:	8c 8f       	std	Y+28, r24	; 0x1c
    9a78:	9d 8f       	std	Y+29, r25	; 0x1d
    9a7a:	ae 8f       	std	Y+30, r26	; 0x1e
    9a7c:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9a7e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9a80:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9a82:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9a84:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9a86:	20 e0       	ldi	r18, 0x00	; 0
    9a88:	30 e0       	ldi	r19, 0x00	; 0
    9a8a:	4a ef       	ldi	r20, 0xFA	; 250
    9a8c:	55 e4       	ldi	r21, 0x45	; 69
    9a8e:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    9a92:	dc 01       	movw	r26, r24
    9a94:	cb 01       	movw	r24, r22
    9a96:	88 a3       	lds	r24, 0x58
    9a98:	99 a3       	lds	r25, 0x59
    9a9a:	aa a3       	lds	r26, 0x5a
    9a9c:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    9a9e:	11 e0       	ldi	r17, 0x01	; 1
    9aa0:	68 a1       	lds	r22, 0x48
    9aa2:	79 a1       	lds	r23, 0x49
    9aa4:	8a a1       	lds	r24, 0x4a
    9aa6:	9b a1       	lds	r25, 0x4b
    9aa8:	20 e0       	ldi	r18, 0x00	; 0
    9aaa:	30 e0       	ldi	r19, 0x00	; 0
    9aac:	40 e8       	ldi	r20, 0x80	; 128
    9aae:	5f e3       	ldi	r21, 0x3F	; 63
    9ab0:	0e 94 c9 5b 	call	0xb792	; 0xb792 <__cmpsf2>
    9ab4:	88 23       	and	r24, r24
    9ab6:	0c f0       	brlt	.+2      	; 0x9aba <SD_init+0x21e>
    9ab8:	10 e0       	ldi	r17, 0x00	; 0
    9aba:	11 23       	and	r17, r17
    9abc:	29 f0       	breq	.+10     	; 0x9ac8 <SD_init+0x22c>
		__ticks = 1;
    9abe:	81 e0       	ldi	r24, 0x01	; 1
    9ac0:	90 e0       	ldi	r25, 0x00	; 0
    9ac2:	8c a3       	lds	r24, 0x5c
    9ac4:	9d a3       	lds	r25, 0x5d
    9ac6:	46 c0       	rjmp	.+140    	; 0x9b54 <SD_init+0x2b8>
	else if (__tmp > 65535)
    9ac8:	11 e0       	ldi	r17, 0x01	; 1
    9aca:	68 a1       	lds	r22, 0x48
    9acc:	79 a1       	lds	r23, 0x49
    9ace:	8a a1       	lds	r24, 0x4a
    9ad0:	9b a1       	lds	r25, 0x4b
    9ad2:	20 e0       	ldi	r18, 0x00	; 0
    9ad4:	3f ef       	ldi	r19, 0xFF	; 255
    9ad6:	4f e7       	ldi	r20, 0x7F	; 127
    9ad8:	57 e4       	ldi	r21, 0x47	; 71
    9ada:	0e 94 13 5d 	call	0xba26	; 0xba26 <__gesf2>
    9ade:	18 16       	cp	r1, r24
    9ae0:	0c f0       	brlt	.+2      	; 0x9ae4 <SD_init+0x248>
    9ae2:	10 e0       	ldi	r17, 0x00	; 0
    9ae4:	11 23       	and	r17, r17
    9ae6:	61 f1       	breq	.+88     	; 0x9b40 <SD_init+0x2a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9ae8:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9aea:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9aec:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9aee:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9af0:	20 e0       	ldi	r18, 0x00	; 0
    9af2:	30 e0       	ldi	r19, 0x00	; 0
    9af4:	40 e2       	ldi	r20, 0x20	; 32
    9af6:	51 e4       	ldi	r21, 0x41	; 65
    9af8:	0e 94 17 5d 	call	0xba2e	; 0xba2e <__mulsf3>
    9afc:	dc 01       	movw	r26, r24
    9afe:	cb 01       	movw	r24, r22
    9b00:	bc 01       	movw	r22, r24
    9b02:	cd 01       	movw	r24, r26
    9b04:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    9b08:	dc 01       	movw	r26, r24
    9b0a:	cb 01       	movw	r24, r22
    9b0c:	8c a3       	lds	r24, 0x5c
    9b0e:	9d a3       	lds	r25, 0x5d
    9b10:	12 c0       	rjmp	.+36     	; 0x9b36 <SD_init+0x29a>
    9b12:	80 e2       	ldi	r24, 0x20	; 32
    9b14:	93 e0       	ldi	r25, 0x03	; 3
    9b16:	8e a3       	lds	r24, 0x5e
    9b18:	9f a3       	lds	r25, 0x5f
    9b1a:	8e a1       	lds	r24, 0x4e
    9b1c:	9f a1       	lds	r25, 0x4f
    9b1e:	8c 01       	movw	r16, r24
    9b20:	c8 01       	movw	r24, r16
    9b22:	01 97       	sbiw	r24, 0x01	; 1
    9b24:	f1 f7       	brne	.-4      	; 0x9b22 <SD_init+0x286>
    9b26:	8c 01       	movw	r16, r24
    9b28:	0e a3       	lds	r16, 0x5e
    9b2a:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9b2c:	8c a1       	lds	r24, 0x4c
    9b2e:	9d a1       	lds	r25, 0x4d
    9b30:	01 97       	sbiw	r24, 0x01	; 1
    9b32:	8c a3       	lds	r24, 0x5c
    9b34:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9b36:	8c a1       	lds	r24, 0x4c
    9b38:	9d a1       	lds	r25, 0x4d
    9b3a:	00 97       	sbiw	r24, 0x00	; 0
    9b3c:	51 f7       	brne	.-44     	; 0x9b12 <SD_init+0x276>
    9b3e:	17 c0       	rjmp	.+46     	; 0x9b6e <SD_init+0x2d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9b40:	68 a1       	lds	r22, 0x48
    9b42:	79 a1       	lds	r23, 0x49
    9b44:	8a a1       	lds	r24, 0x4a
    9b46:	9b a1       	lds	r25, 0x4b
    9b48:	0e 94 35 5c 	call	0xb86a	; 0xb86a <__fixunssfsi>
    9b4c:	dc 01       	movw	r26, r24
    9b4e:	cb 01       	movw	r24, r22
    9b50:	8c a3       	lds	r24, 0x5c
    9b52:	9d a3       	lds	r25, 0x5d
    9b54:	8c a1       	lds	r24, 0x4c
    9b56:	9d a1       	lds	r25, 0x4d
    9b58:	88 a7       	lds	r24, 0x78
    9b5a:	99 a7       	lds	r25, 0x79
    9b5c:	88 a5       	lds	r24, 0x68
    9b5e:	99 a5       	lds	r25, 0x69
    9b60:	8c 01       	movw	r16, r24
    9b62:	f8 01       	movw	r30, r16
    9b64:	31 97       	sbiw	r30, 0x01	; 1
    9b66:	f1 f7       	brne	.-4      	; 0x9b64 <SD_init+0x2c8>
    9b68:	8f 01       	movw	r16, r30
    9b6a:	08 a7       	lds	r16, 0x78
    9b6c:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9b6e:	1e 82       	std	Y+6, r1	; 0x06
    9b70:	1f 82       	std	Y+7, r1	; 0x07
    9b72:	0d c0       	rjmp	.+26     	; 0x9b8e <SD_init+0x2f2>
		if (i >= 10) {
    9b74:	8e 81       	ldd	r24, Y+6	; 0x06
    9b76:	9f 81       	ldd	r25, Y+7	; 0x07
    9b78:	8a 30       	cpi	r24, 0x0A	; 10
    9b7a:	91 05       	cpc	r25, r1
    9b7c:	1c f0       	brlt	.+6      	; 0x9b84 <SD_init+0x2e8>
			//there was no response to the command
			errorCode = 1;
    9b7e:	81 e0       	ldi	r24, 0x01	; 1
    9b80:	89 83       	std	Y+1, r24	; 0x01
			break;
    9b82:	11 c0       	rjmp	.+34     	; 0x9ba6 <SD_init+0x30a>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9b84:	8e 81       	ldd	r24, Y+6	; 0x06
    9b86:	9f 81       	ldd	r25, Y+7	; 0x07
    9b88:	01 96       	adiw	r24, 0x01	; 1
    9b8a:	8e 83       	std	Y+6, r24	; 0x06
    9b8c:	9f 83       	std	Y+7, r25	; 0x07
    9b8e:	88 e0       	ldi	r24, 0x08	; 8
    9b90:	4a ea       	ldi	r20, 0xAA	; 170
    9b92:	51 e0       	ldi	r21, 0x01	; 1
    9b94:	60 e0       	ldi	r22, 0x00	; 0
    9b96:	70 e0       	ldi	r23, 0x00	; 0
    9b98:	27 e8       	ldi	r18, 0x87	; 135
    9b9a:	08 e0       	ldi	r16, 0x08	; 8
    9b9c:	10 e0       	ldi	r17, 0x00	; 0
    9b9e:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
    9ba2:	81 30       	cpi	r24, 0x01	; 1
    9ba4:	39 f7       	brne	.-50     	; 0x9b74 <SD_init+0x2d8>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9ba6:	18 86       	std	Y+8, r1	; 0x08
    9ba8:	19 86       	std	Y+9, r1	; 0x09
    9baa:	13 c0       	rjmp	.+38     	; 0x9bd2 <SD_init+0x336>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9bac:	88 85       	ldd	r24, Y+8	; 0x08
    9bae:	99 85       	ldd	r25, Y+9	; 0x09
    9bb0:	8c 01       	movw	r16, r24
    9bb2:	0e 5f       	subi	r16, 0xFE	; 254
    9bb4:	1f 4f       	sbci	r17, 0xFF	; 255
    9bb6:	8f ef       	ldi	r24, 0xFF	; 255
    9bb8:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9bbc:	28 2f       	mov	r18, r24
    9bbe:	c8 01       	movw	r24, r16
    9bc0:	81 56       	subi	r24, 0x61	; 97
    9bc2:	9f 4a       	sbci	r25, 0xAF	; 175
    9bc4:	fc 01       	movw	r30, r24
    9bc6:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9bc8:	88 85       	ldd	r24, Y+8	; 0x08
    9bca:	99 85       	ldd	r25, Y+9	; 0x09
    9bcc:	01 96       	adiw	r24, 0x01	; 1
    9bce:	88 87       	std	Y+8, r24	; 0x08
    9bd0:	99 87       	std	Y+9, r25	; 0x09
    9bd2:	88 85       	ldd	r24, Y+8	; 0x08
    9bd4:	99 85       	ldd	r25, Y+9	; 0x09
    9bd6:	84 30       	cpi	r24, 0x04	; 4
    9bd8:	91 05       	cpc	r25, r1
    9bda:	44 f3       	brlt	.-48     	; 0x9bac <SD_init+0x310>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9bdc:	80 91 a3 50 	lds	r24, 0x50A3
    9be0:	81 30       	cpi	r24, 0x01	; 1
    9be2:	21 f4       	brne	.+8      	; 0x9bec <SD_init+0x350>
    9be4:	80 91 a4 50 	lds	r24, 0x50A4
    9be8:	8a 3a       	cpi	r24, 0xAA	; 170
    9bea:	11 f0       	breq	.+4      	; 0x9bf0 <SD_init+0x354>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9bec:	81 e0       	ldi	r24, 0x01	; 1
    9bee:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9bf0:	87 e3       	ldi	r24, 0x37	; 55
    9bf2:	40 e0       	ldi	r20, 0x00	; 0
    9bf4:	50 e0       	ldi	r21, 0x00	; 0
    9bf6:	ba 01       	movw	r22, r20
    9bf8:	2f ef       	ldi	r18, 0xFF	; 255
    9bfa:	08 e0       	ldi	r16, 0x08	; 8
    9bfc:	10 e0       	ldi	r17, 0x00	; 0
    9bfe:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9c02:	81 e0       	ldi	r24, 0x01	; 1
    9c04:	40 e0       	ldi	r20, 0x00	; 0
    9c06:	50 e0       	ldi	r21, 0x00	; 0
    9c08:	60 e0       	ldi	r22, 0x00	; 0
    9c0a:	70 e4       	ldi	r23, 0x40	; 64
    9c0c:	2f ef       	ldi	r18, 0xFF	; 255
    9c0e:	08 e0       	ldi	r16, 0x08	; 8
    9c10:	10 e0       	ldi	r17, 0x00	; 0
    9c12:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
	} while(Buffer[1]!= 0x00);
    9c16:	80 91 a0 50 	lds	r24, 0x50A0
    9c1a:	88 23       	and	r24, r24
    9c1c:	49 f7       	brne	.-46     	; 0x9bf0 <SD_init+0x354>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9c1e:	1a 86       	std	Y+10, r1	; 0x0a
    9c20:	1b 86       	std	Y+11, r1	; 0x0b
    9c22:	0d c0       	rjmp	.+26     	; 0x9c3e <SD_init+0x3a2>
		if (i >= 10) {
    9c24:	8a 85       	ldd	r24, Y+10	; 0x0a
    9c26:	9b 85       	ldd	r25, Y+11	; 0x0b
    9c28:	8a 30       	cpi	r24, 0x0A	; 10
    9c2a:	91 05       	cpc	r25, r1
    9c2c:	1c f0       	brlt	.+6      	; 0x9c34 <SD_init+0x398>
			//there was no response to the command
			errorCode = 1;
    9c2e:	81 e0       	ldi	r24, 0x01	; 1
    9c30:	89 83       	std	Y+1, r24	; 0x01
			break;
    9c32:	10 c0       	rjmp	.+32     	; 0x9c54 <SD_init+0x3b8>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9c34:	8a 85       	ldd	r24, Y+10	; 0x0a
    9c36:	9b 85       	ldd	r25, Y+11	; 0x0b
    9c38:	01 96       	adiw	r24, 0x01	; 1
    9c3a:	8a 87       	std	Y+10, r24	; 0x0a
    9c3c:	9b 87       	std	Y+11, r25	; 0x0b
    9c3e:	8a e3       	ldi	r24, 0x3A	; 58
    9c40:	40 e0       	ldi	r20, 0x00	; 0
    9c42:	50 e0       	ldi	r21, 0x00	; 0
    9c44:	ba 01       	movw	r22, r20
    9c46:	2f ef       	ldi	r18, 0xFF	; 255
    9c48:	08 e0       	ldi	r16, 0x08	; 8
    9c4a:	10 e0       	ldi	r17, 0x00	; 0
    9c4c:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
    9c50:	88 23       	and	r24, r24
    9c52:	41 f7       	brne	.-48     	; 0x9c24 <SD_init+0x388>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9c54:	1c 86       	std	Y+12, r1	; 0x0c
    9c56:	1d 86       	std	Y+13, r1	; 0x0d
    9c58:	0f c0       	rjmp	.+30     	; 0x9c78 <SD_init+0x3dc>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9c5a:	8f ef       	ldi	r24, 0xFF	; 255
    9c5c:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9c60:	28 2f       	mov	r18, r24
    9c62:	8c 85       	ldd	r24, Y+12	; 0x0c
    9c64:	9d 85       	ldd	r25, Y+13	; 0x0d
    9c66:	81 56       	subi	r24, 0x61	; 97
    9c68:	9f 4a       	sbci	r25, 0xAF	; 175
    9c6a:	fc 01       	movw	r30, r24
    9c6c:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9c6e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9c70:	9d 85       	ldd	r25, Y+13	; 0x0d
    9c72:	01 96       	adiw	r24, 0x01	; 1
    9c74:	8c 87       	std	Y+12, r24	; 0x0c
    9c76:	9d 87       	std	Y+13, r25	; 0x0d
    9c78:	8c 85       	ldd	r24, Y+12	; 0x0c
    9c7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    9c7c:	84 30       	cpi	r24, 0x04	; 4
    9c7e:	91 05       	cpc	r25, r1
    9c80:	64 f3       	brlt	.-40     	; 0x9c5a <SD_init+0x3be>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9c82:	80 91 9f 50 	lds	r24, 0x509F
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9c86:	80 e0       	ldi	r24, 0x00	; 0
    9c88:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    9c8c:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9c90:	88 e0       	ldi	r24, 0x08	; 8
    9c92:	60 e0       	ldi	r22, 0x00	; 0
    9c94:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
	return errorCode;	
    9c98:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9c9a:	a9 96       	adiw	r28, 0x29	; 41
    9c9c:	cd bf       	out	0x3d, r28	; 61
    9c9e:	de bf       	out	0x3e, r29	; 62
    9ca0:	df 91       	pop	r29
    9ca2:	cf 91       	pop	r28
    9ca4:	1f 91       	pop	r17
    9ca6:	0f 91       	pop	r16
    9ca8:	08 95       	ret

00009caa <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9caa:	cf 93       	push	r28
    9cac:	df 93       	push	r29
    9cae:	0f 92       	push	r0
    9cb0:	0f 92       	push	r0
    9cb2:	cd b7       	in	r28, 0x3d	; 61
    9cb4:	de b7       	in	r29, 0x3e	; 62
    9cb6:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9cb8:	80 ec       	ldi	r24, 0xC0	; 192
    9cba:	98 e0       	ldi	r25, 0x08	; 8
    9cbc:	2a 81       	ldd	r18, Y+2	; 0x02
    9cbe:	fc 01       	movw	r30, r24
    9cc0:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9cc2:	00 00       	nop
    9cc4:	80 ec       	ldi	r24, 0xC0	; 192
    9cc6:	98 e0       	ldi	r25, 0x08	; 8
    9cc8:	fc 01       	movw	r30, r24
    9cca:	82 81       	ldd	r24, Z+2	; 0x02
    9ccc:	88 23       	and	r24, r24
    9cce:	d4 f7       	brge	.-12     	; 0x9cc4 <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9cd0:	80 ec       	ldi	r24, 0xC0	; 192
    9cd2:	98 e0       	ldi	r25, 0x08	; 8
    9cd4:	fc 01       	movw	r30, r24
    9cd6:	83 81       	ldd	r24, Z+3	; 0x03
    9cd8:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9cda:	89 81       	ldd	r24, Y+1	; 0x01
}
    9cdc:	0f 90       	pop	r0
    9cde:	0f 90       	pop	r0
    9ce0:	df 91       	pop	r29
    9ce2:	cf 91       	pop	r28
    9ce4:	08 95       	ret

00009ce6 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9ce6:	0f 93       	push	r16
    9ce8:	1f 93       	push	r17
    9cea:	cf 93       	push	r28
    9cec:	df 93       	push	r29
    9cee:	cd b7       	in	r28, 0x3d	; 61
    9cf0:	de b7       	in	r29, 0x3e	; 62
    9cf2:	2a 97       	sbiw	r28, 0x0a	; 10
    9cf4:	cd bf       	out	0x3d, r28	; 61
    9cf6:	de bf       	out	0x3e, r29	; 62
    9cf8:	8b 83       	std	Y+3, r24	; 0x03
    9cfa:	4c 83       	std	Y+4, r20	; 0x04
    9cfc:	5d 83       	std	Y+5, r21	; 0x05
    9cfe:	6e 83       	std	Y+6, r22	; 0x06
    9d00:	7f 83       	std	Y+7, r23	; 0x07
    9d02:	28 87       	std	Y+8, r18	; 0x08
    9d04:	09 87       	std	Y+9, r16	; 0x09
    9d06:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9d08:	8b 81       	ldd	r24, Y+3	; 0x03
    9d0a:	80 64       	ori	r24, 0x40	; 64
    9d0c:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9d10:	8c 81       	ldd	r24, Y+4	; 0x04
    9d12:	9d 81       	ldd	r25, Y+5	; 0x05
    9d14:	ae 81       	ldd	r26, Y+6	; 0x06
    9d16:	bf 81       	ldd	r27, Y+7	; 0x07
    9d18:	8b 2f       	mov	r24, r27
    9d1a:	99 27       	eor	r25, r25
    9d1c:	aa 27       	eor	r26, r26
    9d1e:	bb 27       	eor	r27, r27
    9d20:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9d24:	8c 81       	ldd	r24, Y+4	; 0x04
    9d26:	9d 81       	ldd	r25, Y+5	; 0x05
    9d28:	ae 81       	ldd	r26, Y+6	; 0x06
    9d2a:	bf 81       	ldd	r27, Y+7	; 0x07
    9d2c:	cd 01       	movw	r24, r26
    9d2e:	aa 27       	eor	r26, r26
    9d30:	bb 27       	eor	r27, r27
    9d32:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9d36:	8c 81       	ldd	r24, Y+4	; 0x04
    9d38:	9d 81       	ldd	r25, Y+5	; 0x05
    9d3a:	ae 81       	ldd	r26, Y+6	; 0x06
    9d3c:	bf 81       	ldd	r27, Y+7	; 0x07
    9d3e:	89 2f       	mov	r24, r25
    9d40:	9a 2f       	mov	r25, r26
    9d42:	ab 2f       	mov	r26, r27
    9d44:	bb 27       	eor	r27, r27
    9d46:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9d4a:	8c 81       	ldd	r24, Y+4	; 0x04
    9d4c:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
	SPI_write(crc);
    9d50:	88 85       	ldd	r24, Y+8	; 0x08
    9d52:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
	
	for(int i=0; i<read; i++){
    9d56:	19 82       	std	Y+1, r1	; 0x01
    9d58:	1a 82       	std	Y+2, r1	; 0x02
    9d5a:	33 c0       	rjmp	.+102    	; 0x9dc2 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9d5c:	89 81       	ldd	r24, Y+1	; 0x01
    9d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    9d60:	2d e0       	ldi	r18, 0x0D	; 13
    9d62:	30 e0       	ldi	r19, 0x00	; 0
    9d64:	b9 01       	movw	r22, r18
    9d66:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    9d6a:	8c 01       	movw	r16, r24
    9d6c:	8f ef       	ldi	r24, 0xFF	; 255
    9d6e:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9d72:	28 2f       	mov	r18, r24
    9d74:	c8 01       	movw	r24, r16
    9d76:	81 56       	subi	r24, 0x61	; 97
    9d78:	9f 4a       	sbci	r25, 0xAF	; 175
    9d7a:	fc 01       	movw	r30, r24
    9d7c:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9d7e:	89 81       	ldd	r24, Y+1	; 0x01
    9d80:	9a 81       	ldd	r25, Y+2	; 0x02
    9d82:	2d e0       	ldi	r18, 0x0D	; 13
    9d84:	30 e0       	ldi	r19, 0x00	; 0
    9d86:	b9 01       	movw	r22, r18
    9d88:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    9d8c:	81 56       	subi	r24, 0x61	; 97
    9d8e:	9f 4a       	sbci	r25, 0xAF	; 175
    9d90:	fc 01       	movw	r30, r24
    9d92:	80 81       	ld	r24, Z
    9d94:	8f 3f       	cpi	r24, 0xFF	; 255
    9d96:	81 f0       	breq	.+32     	; 0x9db8 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9d98:	89 81       	ldd	r24, Y+1	; 0x01
    9d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    9d9c:	2d e0       	ldi	r18, 0x0D	; 13
    9d9e:	30 e0       	ldi	r19, 0x00	; 0
    9da0:	b9 01       	movw	r22, r18
    9da2:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    9da6:	81 56       	subi	r24, 0x61	; 97
    9da8:	9f 4a       	sbci	r25, 0xAF	; 175
    9daa:	fc 01       	movw	r30, r24
    9dac:	80 81       	ld	r24, Z
    9dae:	80 93 a0 50 	sts	0x50A0, r24
			return Buffer[1];
    9db2:	80 91 a0 50 	lds	r24, 0x50A0
    9db6:	0d c0       	rjmp	.+26     	; 0x9dd2 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9db8:	89 81       	ldd	r24, Y+1	; 0x01
    9dba:	9a 81       	ldd	r25, Y+2	; 0x02
    9dbc:	01 96       	adiw	r24, 0x01	; 1
    9dbe:	89 83       	std	Y+1, r24	; 0x01
    9dc0:	9a 83       	std	Y+2, r25	; 0x02
    9dc2:	29 81       	ldd	r18, Y+1	; 0x01
    9dc4:	3a 81       	ldd	r19, Y+2	; 0x02
    9dc6:	89 85       	ldd	r24, Y+9	; 0x09
    9dc8:	9a 85       	ldd	r25, Y+10	; 0x0a
    9dca:	28 17       	cp	r18, r24
    9dcc:	39 07       	cpc	r19, r25
    9dce:	34 f2       	brlt	.-116    	; 0x9d5c <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9dd0:	8f ef       	ldi	r24, 0xFF	; 255
}
    9dd2:	2a 96       	adiw	r28, 0x0a	; 10
    9dd4:	cd bf       	out	0x3d, r28	; 61
    9dd6:	de bf       	out	0x3e, r29	; 62
    9dd8:	df 91       	pop	r29
    9dda:	cf 91       	pop	r28
    9ddc:	1f 91       	pop	r17
    9dde:	0f 91       	pop	r16
    9de0:	08 95       	ret

00009de2 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9de2:	0f 93       	push	r16
    9de4:	1f 93       	push	r17
    9de6:	cf 93       	push	r28
    9de8:	df 93       	push	r29
    9dea:	cd b7       	in	r28, 0x3d	; 61
    9dec:	de b7       	in	r29, 0x3e	; 62
    9dee:	62 97       	sbiw	r28, 0x12	; 18
    9df0:	cd bf       	out	0x3d, r28	; 61
    9df2:	de bf       	out	0x3e, r29	; 62
    9df4:	6b 87       	std	Y+11, r22	; 0x0b
    9df6:	7c 87       	std	Y+12, r23	; 0x0c
    9df8:	8d 87       	std	Y+13, r24	; 0x0d
    9dfa:	9e 87       	std	Y+14, r25	; 0x0e
    9dfc:	4f 87       	std	Y+15, r20	; 0x0f
    9dfe:	58 8b       	std	Y+16, r21	; 0x10
    9e00:	29 8b       	std	Y+17, r18	; 0x11
    9e02:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9e04:	88 e0       	ldi	r24, 0x08	; 8
    9e06:	60 e0       	ldi	r22, 0x00	; 0
    9e08:	0e 94 06 35 	call	0x6a0c	; 0x6a0c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9e0c:	80 e0       	ldi	r24, 0x00	; 0
    9e0e:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    9e12:	81 e0       	ldi	r24, 0x01	; 1
    9e14:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9e18:	20 e0       	ldi	r18, 0x00	; 0
    9e1a:	32 e0       	ldi	r19, 0x02	; 2
    9e1c:	89 89       	ldd	r24, Y+17	; 0x11
    9e1e:	9a 89       	ldd	r25, Y+18	; 0x12
    9e20:	a9 01       	movw	r20, r18
    9e22:	48 1b       	sub	r20, r24
    9e24:	59 0b       	sbc	r21, r25
    9e26:	ca 01       	movw	r24, r20
    9e28:	89 83       	std	Y+1, r24	; 0x01
    9e2a:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9e2c:	89 81       	ldd	r24, Y+1	; 0x01
    9e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    9e30:	52 e0       	ldi	r21, 0x02	; 2
    9e32:	80 30       	cpi	r24, 0x00	; 0
    9e34:	95 07       	cpc	r25, r21
    9e36:	11 f4       	brne	.+4      	; 0x9e3c <SD_write_block+0x5a>
    9e38:	19 82       	std	Y+1, r1	; 0x01
    9e3a:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9e3c:	1b 82       	std	Y+3, r1	; 0x03
    9e3e:	1c 82       	std	Y+4, r1	; 0x04
    9e40:	0b c0       	rjmp	.+22     	; 0x9e58 <SD_write_block+0x76>
	if (i >= 10) {
    9e42:	8b 81       	ldd	r24, Y+3	; 0x03
    9e44:	9c 81       	ldd	r25, Y+4	; 0x04
    9e46:	8a 30       	cpi	r24, 0x0A	; 10
    9e48:	91 05       	cpc	r25, r1
    9e4a:	0c f0       	brlt	.+2      	; 0x9e4e <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9e4c:	ff cf       	rjmp	.-2      	; 0x9e4c <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9e4e:	8b 81       	ldd	r24, Y+3	; 0x03
    9e50:	9c 81       	ldd	r25, Y+4	; 0x04
    9e52:	01 96       	adiw	r24, 0x01	; 1
    9e54:	8b 83       	std	Y+3, r24	; 0x03
    9e56:	9c 83       	std	Y+4, r25	; 0x04
    9e58:	2b 85       	ldd	r18, Y+11	; 0x0b
    9e5a:	3c 85       	ldd	r19, Y+12	; 0x0c
    9e5c:	4d 85       	ldd	r20, Y+13	; 0x0d
    9e5e:	5e 85       	ldd	r21, Y+14	; 0x0e
    9e60:	88 e1       	ldi	r24, 0x18	; 24
    9e62:	ba 01       	movw	r22, r20
    9e64:	a9 01       	movw	r20, r18
    9e66:	2f ef       	ldi	r18, 0xFF	; 255
    9e68:	08 e0       	ldi	r16, 0x08	; 8
    9e6a:	10 e0       	ldi	r17, 0x00	; 0
    9e6c:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
    9e70:	88 23       	and	r24, r24
    9e72:	39 f7       	brne	.-50     	; 0x9e42 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9e74:	8f ef       	ldi	r24, 0xFF	; 255
    9e76:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9e7a:	80 93 9f 50 	sts	0x509F, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9e7e:	8e ef       	ldi	r24, 0xFE	; 254
    9e80:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9e84:	1d 82       	std	Y+5, r1	; 0x05
    9e86:	1e 82       	std	Y+6, r1	; 0x06
    9e88:	1d c0       	rjmp	.+58     	; 0x9ec4 <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9e8a:	8d 81       	ldd	r24, Y+5	; 0x05
    9e8c:	9e 81       	ldd	r25, Y+6	; 0x06
    9e8e:	2d e0       	ldi	r18, 0x0D	; 13
    9e90:	30 e0       	ldi	r19, 0x00	; 0
    9e92:	b9 01       	movw	r22, r18
    9e94:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    9e98:	8c 01       	movw	r16, r24
    9e9a:	8d 81       	ldd	r24, Y+5	; 0x05
    9e9c:	9e 81       	ldd	r25, Y+6	; 0x06
    9e9e:	2f 85       	ldd	r18, Y+15	; 0x0f
    9ea0:	38 89       	ldd	r19, Y+16	; 0x10
    9ea2:	82 0f       	add	r24, r18
    9ea4:	93 1f       	adc	r25, r19
    9ea6:	fc 01       	movw	r30, r24
    9ea8:	80 81       	ld	r24, Z
    9eaa:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9eae:	28 2f       	mov	r18, r24
    9eb0:	c8 01       	movw	r24, r16
    9eb2:	81 56       	subi	r24, 0x61	; 97
    9eb4:	9f 4a       	sbci	r25, 0xAF	; 175
    9eb6:	fc 01       	movw	r30, r24
    9eb8:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9eba:	8d 81       	ldd	r24, Y+5	; 0x05
    9ebc:	9e 81       	ldd	r25, Y+6	; 0x06
    9ebe:	01 96       	adiw	r24, 0x01	; 1
    9ec0:	8d 83       	std	Y+5, r24	; 0x05
    9ec2:	9e 83       	std	Y+6, r25	; 0x06
    9ec4:	2d 81       	ldd	r18, Y+5	; 0x05
    9ec6:	3e 81       	ldd	r19, Y+6	; 0x06
    9ec8:	89 89       	ldd	r24, Y+17	; 0x11
    9eca:	9a 89       	ldd	r25, Y+18	; 0x12
    9ecc:	28 17       	cp	r18, r24
    9ece:	39 07       	cpc	r19, r25
    9ed0:	e4 f2       	brlt	.-72     	; 0x9e8a <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9ed2:	1f 82       	std	Y+7, r1	; 0x07
    9ed4:	18 86       	std	Y+8, r1	; 0x08
    9ed6:	16 c0       	rjmp	.+44     	; 0x9f04 <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9ed8:	8f 81       	ldd	r24, Y+7	; 0x07
    9eda:	98 85       	ldd	r25, Y+8	; 0x08
    9edc:	2d e0       	ldi	r18, 0x0D	; 13
    9ede:	30 e0       	ldi	r19, 0x00	; 0
    9ee0:	b9 01       	movw	r22, r18
    9ee2:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    9ee6:	8c 01       	movw	r16, r24
    9ee8:	80 e0       	ldi	r24, 0x00	; 0
    9eea:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9eee:	28 2f       	mov	r18, r24
    9ef0:	c8 01       	movw	r24, r16
    9ef2:	81 56       	subi	r24, 0x61	; 97
    9ef4:	9f 4a       	sbci	r25, 0xAF	; 175
    9ef6:	fc 01       	movw	r30, r24
    9ef8:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9efa:	8f 81       	ldd	r24, Y+7	; 0x07
    9efc:	98 85       	ldd	r25, Y+8	; 0x08
    9efe:	01 96       	adiw	r24, 0x01	; 1
    9f00:	8f 83       	std	Y+7, r24	; 0x07
    9f02:	98 87       	std	Y+8, r25	; 0x08
    9f04:	2f 81       	ldd	r18, Y+7	; 0x07
    9f06:	38 85       	ldd	r19, Y+8	; 0x08
    9f08:	89 81       	ldd	r24, Y+1	; 0x01
    9f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    9f0c:	28 17       	cp	r18, r24
    9f0e:	39 07       	cpc	r19, r25
    9f10:	1c f3       	brlt	.-58     	; 0x9ed8 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9f12:	8f ef       	ldi	r24, 0xFF	; 255
    9f14:	80 93 9f 50 	sts	0x509F, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9f18:	19 86       	std	Y+9, r1	; 0x09
    9f1a:	1a 86       	std	Y+10, r1	; 0x0a
    9f1c:	0a c0       	rjmp	.+20     	; 0x9f32 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9f1e:	8f ef       	ldi	r24, 0xFF	; 255
    9f20:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9f24:	80 93 9f 50 	sts	0x509F, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9f28:	89 85       	ldd	r24, Y+9	; 0x09
    9f2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f2c:	01 96       	adiw	r24, 0x01	; 1
    9f2e:	89 87       	std	Y+9, r24	; 0x09
    9f30:	9a 87       	std	Y+10, r25	; 0x0a
    9f32:	89 85       	ldd	r24, Y+9	; 0x09
    9f34:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f36:	82 30       	cpi	r24, 0x02	; 2
    9f38:	91 05       	cpc	r25, r1
    9f3a:	8c f3       	brlt	.-30     	; 0x9f1e <SD_write_block+0x13c>
    9f3c:	80 91 9f 50 	lds	r24, 0x509F
    9f40:	8f 3f       	cpi	r24, 0xFF	; 255
    9f42:	69 f3       	breq	.-38     	; 0x9f1e <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9f44:	80 91 9f 50 	lds	r24, 0x509F
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9f48:	05 c0       	rjmp	.+10     	; 0x9f54 <SD_write_block+0x172>
    9f4a:	8f ef       	ldi	r24, 0xFF	; 255
    9f4c:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9f50:	80 93 9f 50 	sts	0x509F, r24
    9f54:	80 91 9f 50 	lds	r24, 0x509F
    9f58:	8f 3f       	cpi	r24, 0xFF	; 255
    9f5a:	b9 f7       	brne	.-18     	; 0x9f4a <SD_write_block+0x168>
	SPICS(FALSE);
    9f5c:	80 e0       	ldi	r24, 0x00	; 0
    9f5e:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    9f62:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9f66:	88 e0       	ldi	r24, 0x08	; 8
    9f68:	60 e0       	ldi	r22, 0x00	; 0
    9f6a:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
}
    9f6e:	62 96       	adiw	r28, 0x12	; 18
    9f70:	cd bf       	out	0x3d, r28	; 61
    9f72:	de bf       	out	0x3e, r29	; 62
    9f74:	df 91       	pop	r29
    9f76:	cf 91       	pop	r28
    9f78:	1f 91       	pop	r17
    9f7a:	0f 91       	pop	r16
    9f7c:	08 95       	ret

00009f7e <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9f7e:	0f 93       	push	r16
    9f80:	1f 93       	push	r17
    9f82:	cf 93       	push	r28
    9f84:	df 93       	push	r29
    9f86:	cd b7       	in	r28, 0x3d	; 61
    9f88:	de b7       	in	r29, 0x3e	; 62
    9f8a:	2a 97       	sbiw	r28, 0x0a	; 10
    9f8c:	cd bf       	out	0x3d, r28	; 61
    9f8e:	de bf       	out	0x3e, r29	; 62
    9f90:	6d 83       	std	Y+5, r22	; 0x05
    9f92:	7e 83       	std	Y+6, r23	; 0x06
    9f94:	8f 83       	std	Y+7, r24	; 0x07
    9f96:	98 87       	std	Y+8, r25	; 0x08
    9f98:	49 87       	std	Y+9, r20	; 0x09
    9f9a:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9f9c:	88 e0       	ldi	r24, 0x08	; 8
    9f9e:	60 e0       	ldi	r22, 0x00	; 0
    9fa0:	0e 94 06 35 	call	0x6a0c	; 0x6a0c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9fa4:	80 e0       	ldi	r24, 0x00	; 0
    9fa6:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    9faa:	81 e0       	ldi	r24, 0x01	; 1
    9fac:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9fb0:	19 82       	std	Y+1, r1	; 0x01
    9fb2:	1a 82       	std	Y+2, r1	; 0x02
    9fb4:	0b c0       	rjmp	.+22     	; 0x9fcc <SD_read_block+0x4e>
		if (i >= 10) {
    9fb6:	89 81       	ldd	r24, Y+1	; 0x01
    9fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    9fba:	8a 30       	cpi	r24, 0x0A	; 10
    9fbc:	91 05       	cpc	r25, r1
    9fbe:	0c f0       	brlt	.+2      	; 0x9fc2 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9fc0:	ff cf       	rjmp	.-2      	; 0x9fc0 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9fc2:	89 81       	ldd	r24, Y+1	; 0x01
    9fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    9fc6:	01 96       	adiw	r24, 0x01	; 1
    9fc8:	89 83       	std	Y+1, r24	; 0x01
    9fca:	9a 83       	std	Y+2, r25	; 0x02
    9fcc:	2d 81       	ldd	r18, Y+5	; 0x05
    9fce:	3e 81       	ldd	r19, Y+6	; 0x06
    9fd0:	4f 81       	ldd	r20, Y+7	; 0x07
    9fd2:	58 85       	ldd	r21, Y+8	; 0x08
    9fd4:	81 e1       	ldi	r24, 0x11	; 17
    9fd6:	ba 01       	movw	r22, r20
    9fd8:	a9 01       	movw	r20, r18
    9fda:	2f ef       	ldi	r18, 0xFF	; 255
    9fdc:	08 e0       	ldi	r16, 0x08	; 8
    9fde:	10 e0       	ldi	r17, 0x00	; 0
    9fe0:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
    9fe4:	88 23       	and	r24, r24
    9fe6:	39 f7       	brne	.-50     	; 0x9fb6 <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9fe8:	05 c0       	rjmp	.+10     	; 0x9ff4 <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9fea:	8f ef       	ldi	r24, 0xFF	; 255
    9fec:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    9ff0:	80 93 9f 50 	sts	0x509F, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9ff4:	80 91 9f 50 	lds	r24, 0x509F
    9ff8:	8e 3f       	cpi	r24, 0xFE	; 254
    9ffa:	b9 f7       	brne	.-18     	; 0x9fea <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9ffc:	1b 82       	std	Y+3, r1	; 0x03
    9ffe:	1c 82       	std	Y+4, r1	; 0x04
    a000:	11 c0       	rjmp	.+34     	; 0xa024 <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a002:	8b 81       	ldd	r24, Y+3	; 0x03
    a004:	9c 81       	ldd	r25, Y+4	; 0x04
    a006:	29 85       	ldd	r18, Y+9	; 0x09
    a008:	3a 85       	ldd	r19, Y+10	; 0x0a
    a00a:	89 01       	movw	r16, r18
    a00c:	08 0f       	add	r16, r24
    a00e:	19 1f       	adc	r17, r25
    a010:	8f ef       	ldi	r24, 0xFF	; 255
    a012:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a016:	f8 01       	movw	r30, r16
    a018:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a01a:	8b 81       	ldd	r24, Y+3	; 0x03
    a01c:	9c 81       	ldd	r25, Y+4	; 0x04
    a01e:	01 96       	adiw	r24, 0x01	; 1
    a020:	8b 83       	std	Y+3, r24	; 0x03
    a022:	9c 83       	std	Y+4, r25	; 0x04
    a024:	8b 81       	ldd	r24, Y+3	; 0x03
    a026:	9c 81       	ldd	r25, Y+4	; 0x04
    a028:	f2 e0       	ldi	r31, 0x02	; 2
    a02a:	80 30       	cpi	r24, 0x00	; 0
    a02c:	9f 07       	cpc	r25, r31
    a02e:	4c f3       	brlt	.-46     	; 0xa002 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    a030:	10 92 ab 50 	sts	0x50AB, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a034:	05 c0       	rjmp	.+10     	; 0xa040 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    a036:	8f ef       	ldi	r24, 0xFF	; 255
    a038:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a03c:	80 93 ab 50 	sts	0x50AB, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a040:	80 91 ab 50 	lds	r24, 0x50AB
    a044:	8f 3f       	cpi	r24, 0xFF	; 255
    a046:	b9 f7       	brne	.-18     	; 0xa036 <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    a048:	80 e0       	ldi	r24, 0x00	; 0
    a04a:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    a04e:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a052:	88 e0       	ldi	r24, 0x08	; 8
    a054:	60 e0       	ldi	r22, 0x00	; 0
    a056:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
}
    a05a:	2a 96       	adiw	r28, 0x0a	; 10
    a05c:	cd bf       	out	0x3d, r28	; 61
    a05e:	de bf       	out	0x3e, r29	; 62
    a060:	df 91       	pop	r29
    a062:	cf 91       	pop	r28
    a064:	1f 91       	pop	r17
    a066:	0f 91       	pop	r16
    a068:	08 95       	ret

0000a06a <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    a06a:	0f 93       	push	r16
    a06c:	1f 93       	push	r17
    a06e:	cf 93       	push	r28
    a070:	df 93       	push	r29
    a072:	cd b7       	in	r28, 0x3d	; 61
    a074:	de b7       	in	r29, 0x3e	; 62
    a076:	6a 97       	sbiw	r28, 0x1a	; 26
    a078:	cd bf       	out	0x3d, r28	; 61
    a07a:	de bf       	out	0x3e, r29	; 62
    a07c:	6b 8b       	std	Y+19, r22	; 0x13
    a07e:	7c 8b       	std	Y+20, r23	; 0x14
    a080:	8d 8b       	std	Y+21, r24	; 0x15
    a082:	9e 8b       	std	Y+22, r25	; 0x16
    a084:	4f 8b       	std	Y+23, r20	; 0x17
    a086:	58 8f       	std	Y+24, r21	; 0x18
    a088:	29 8f       	std	Y+25, r18	; 0x19
    a08a:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a08c:	88 e0       	ldi	r24, 0x08	; 8
    a08e:	60 e0       	ldi	r22, 0x00	; 0
    a090:	0e 94 06 35 	call	0x6a0c	; 0x6a0c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a094:	80 e0       	ldi	r24, 0x00	; 0
    a096:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    a09a:	81 e0       	ldi	r24, 0x01	; 1
    a09c:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    a0a0:	89 8d       	ldd	r24, Y+25	; 0x19
    a0a2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a0a4:	99 23       	and	r25, r25
    a0a6:	14 f4       	brge	.+4      	; 0xa0ac <SD_write_multiple_blocks+0x42>
    a0a8:	81 50       	subi	r24, 0x01	; 1
    a0aa:	9e 4f       	sbci	r25, 0xFE	; 254
    a0ac:	89 2f       	mov	r24, r25
    a0ae:	99 0f       	add	r25, r25
    a0b0:	99 0b       	sbc	r25, r25
    a0b2:	85 95       	asr	r24
    a0b4:	89 83       	std	Y+1, r24	; 0x01
    a0b6:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    a0b8:	89 8d       	ldd	r24, Y+25	; 0x19
    a0ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a0bc:	20 e0       	ldi	r18, 0x00	; 0
    a0be:	32 e0       	ldi	r19, 0x02	; 2
    a0c0:	b9 01       	movw	r22, r18
    a0c2:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    a0c6:	20 e0       	ldi	r18, 0x00	; 0
    a0c8:	32 e0       	ldi	r19, 0x02	; 2
    a0ca:	a9 01       	movw	r20, r18
    a0cc:	48 1b       	sub	r20, r24
    a0ce:	59 0b       	sbc	r21, r25
    a0d0:	ca 01       	movw	r24, r20
    a0d2:	8b 83       	std	Y+3, r24	; 0x03
    a0d4:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a0d6:	8b 81       	ldd	r24, Y+3	; 0x03
    a0d8:	9c 81       	ldd	r25, Y+4	; 0x04
    a0da:	52 e0       	ldi	r21, 0x02	; 2
    a0dc:	80 30       	cpi	r24, 0x00	; 0
    a0de:	95 07       	cpc	r25, r21
    a0e0:	19 f4       	brne	.+6      	; 0xa0e8 <SD_write_multiple_blocks+0x7e>
    a0e2:	1b 82       	std	Y+3, r1	; 0x03
    a0e4:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a0e6:	05 c0       	rjmp	.+10     	; 0xa0f2 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    a0e8:	89 81       	ldd	r24, Y+1	; 0x01
    a0ea:	9a 81       	ldd	r25, Y+2	; 0x02
    a0ec:	01 96       	adiw	r24, 0x01	; 1
    a0ee:	89 83       	std	Y+1, r24	; 0x01
    a0f0:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a0f2:	00 00       	nop
    a0f4:	2b 89       	ldd	r18, Y+19	; 0x13
    a0f6:	3c 89       	ldd	r19, Y+20	; 0x14
    a0f8:	4d 89       	ldd	r20, Y+21	; 0x15
    a0fa:	5e 89       	ldd	r21, Y+22	; 0x16
    a0fc:	89 e1       	ldi	r24, 0x19	; 25
    a0fe:	ba 01       	movw	r22, r20
    a100:	a9 01       	movw	r20, r18
    a102:	2f ef       	ldi	r18, 0xFF	; 255
    a104:	08 e0       	ldi	r16, 0x08	; 8
    a106:	10 e0       	ldi	r17, 0x00	; 0
    a108:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
    a10c:	88 23       	and	r24, r24
    a10e:	91 f7       	brne	.-28     	; 0xa0f4 <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    a110:	1d 82       	std	Y+5, r1	; 0x05
    a112:	1e 82       	std	Y+6, r1	; 0x06
    a114:	ba c0       	rjmp	.+372    	; 0xa28a <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    a116:	8f ef       	ldi	r24, 0xFF	; 255
    a118:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a11c:	80 93 a0 50 	sts	0x50A0, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    a120:	8c ef       	ldi	r24, 0xFC	; 252
    a122:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a126:	80 93 a0 50 	sts	0x50A0, r24
		if(j == (numSectors-1)){
    a12a:	89 81       	ldd	r24, Y+1	; 0x01
    a12c:	9a 81       	ldd	r25, Y+2	; 0x02
    a12e:	9c 01       	movw	r18, r24
    a130:	21 50       	subi	r18, 0x01	; 1
    a132:	30 40       	sbci	r19, 0x00	; 0
    a134:	8d 81       	ldd	r24, Y+5	; 0x05
    a136:	9e 81       	ldd	r25, Y+6	; 0x06
    a138:	28 17       	cp	r18, r24
    a13a:	39 07       	cpc	r19, r25
    a13c:	09 f0       	breq	.+2      	; 0xa140 <SD_write_multiple_blocks+0xd6>
    a13e:	54 c0       	rjmp	.+168    	; 0xa1e8 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a140:	1f 82       	std	Y+7, r1	; 0x07
    a142:	18 86       	std	Y+8, r1	; 0x08
    a144:	25 c0       	rjmp	.+74     	; 0xa190 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a146:	8f 81       	ldd	r24, Y+7	; 0x07
    a148:	98 85       	ldd	r25, Y+8	; 0x08
    a14a:	2c e0       	ldi	r18, 0x0C	; 12
    a14c:	30 e0       	ldi	r19, 0x00	; 0
    a14e:	b9 01       	movw	r22, r18
    a150:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    a154:	8c 01       	movw	r16, r24
    a156:	8d 81       	ldd	r24, Y+5	; 0x05
    a158:	9e 81       	ldd	r25, Y+6	; 0x06
    a15a:	9c 01       	movw	r18, r24
    a15c:	32 2f       	mov	r19, r18
    a15e:	22 27       	eor	r18, r18
    a160:	33 0f       	add	r19, r19
    a162:	8f 81       	ldd	r24, Y+7	; 0x07
    a164:	98 85       	ldd	r25, Y+8	; 0x08
    a166:	82 0f       	add	r24, r18
    a168:	93 1f       	adc	r25, r19
    a16a:	2f 89       	ldd	r18, Y+23	; 0x17
    a16c:	38 8d       	ldd	r19, Y+24	; 0x18
    a16e:	82 0f       	add	r24, r18
    a170:	93 1f       	adc	r25, r19
    a172:	fc 01       	movw	r30, r24
    a174:	80 81       	ld	r24, Z
    a176:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a17a:	28 2f       	mov	r18, r24
    a17c:	c8 01       	movw	r24, r16
    a17e:	81 56       	subi	r24, 0x61	; 97
    a180:	9f 4a       	sbci	r25, 0xAF	; 175
    a182:	fc 01       	movw	r30, r24
    a184:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a186:	8f 81       	ldd	r24, Y+7	; 0x07
    a188:	98 85       	ldd	r25, Y+8	; 0x08
    a18a:	01 96       	adiw	r24, 0x01	; 1
    a18c:	8f 83       	std	Y+7, r24	; 0x07
    a18e:	98 87       	std	Y+8, r25	; 0x08
    a190:	20 e0       	ldi	r18, 0x00	; 0
    a192:	32 e0       	ldi	r19, 0x02	; 2
    a194:	8b 81       	ldd	r24, Y+3	; 0x03
    a196:	9c 81       	ldd	r25, Y+4	; 0x04
    a198:	28 1b       	sub	r18, r24
    a19a:	39 0b       	sbc	r19, r25
    a19c:	8f 81       	ldd	r24, Y+7	; 0x07
    a19e:	98 85       	ldd	r25, Y+8	; 0x08
    a1a0:	82 17       	cp	r24, r18
    a1a2:	93 07       	cpc	r25, r19
    a1a4:	84 f2       	brlt	.-96     	; 0xa146 <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a1a6:	19 86       	std	Y+9, r1	; 0x09
    a1a8:	1a 86       	std	Y+10, r1	; 0x0a
    a1aa:	16 c0       	rjmp	.+44     	; 0xa1d8 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a1ac:	89 85       	ldd	r24, Y+9	; 0x09
    a1ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    a1b0:	2c e0       	ldi	r18, 0x0C	; 12
    a1b2:	30 e0       	ldi	r19, 0x00	; 0
    a1b4:	b9 01       	movw	r22, r18
    a1b6:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    a1ba:	8c 01       	movw	r16, r24
    a1bc:	80 e0       	ldi	r24, 0x00	; 0
    a1be:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a1c2:	28 2f       	mov	r18, r24
    a1c4:	c8 01       	movw	r24, r16
    a1c6:	81 56       	subi	r24, 0x61	; 97
    a1c8:	9f 4a       	sbci	r25, 0xAF	; 175
    a1ca:	fc 01       	movw	r30, r24
    a1cc:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a1ce:	89 85       	ldd	r24, Y+9	; 0x09
    a1d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    a1d2:	01 96       	adiw	r24, 0x01	; 1
    a1d4:	89 87       	std	Y+9, r24	; 0x09
    a1d6:	9a 87       	std	Y+10, r25	; 0x0a
    a1d8:	29 85       	ldd	r18, Y+9	; 0x09
    a1da:	3a 85       	ldd	r19, Y+10	; 0x0a
    a1dc:	8b 81       	ldd	r24, Y+3	; 0x03
    a1de:	9c 81       	ldd	r25, Y+4	; 0x04
    a1e0:	28 17       	cp	r18, r24
    a1e2:	39 07       	cpc	r19, r25
    a1e4:	1c f3       	brlt	.-58     	; 0xa1ac <SD_write_multiple_blocks+0x142>
    a1e6:	2e c0       	rjmp	.+92     	; 0xa244 <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a1e8:	1b 86       	std	Y+11, r1	; 0x0b
    a1ea:	1c 86       	std	Y+12, r1	; 0x0c
    a1ec:	25 c0       	rjmp	.+74     	; 0xa238 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a1ee:	8b 85       	ldd	r24, Y+11	; 0x0b
    a1f0:	9c 85       	ldd	r25, Y+12	; 0x0c
    a1f2:	2c e0       	ldi	r18, 0x0C	; 12
    a1f4:	30 e0       	ldi	r19, 0x00	; 0
    a1f6:	b9 01       	movw	r22, r18
    a1f8:	0e 94 ad 5d 	call	0xbb5a	; 0xbb5a <__divmodhi4>
    a1fc:	8c 01       	movw	r16, r24
    a1fe:	8d 81       	ldd	r24, Y+5	; 0x05
    a200:	9e 81       	ldd	r25, Y+6	; 0x06
    a202:	9c 01       	movw	r18, r24
    a204:	32 2f       	mov	r19, r18
    a206:	22 27       	eor	r18, r18
    a208:	33 0f       	add	r19, r19
    a20a:	8b 85       	ldd	r24, Y+11	; 0x0b
    a20c:	9c 85       	ldd	r25, Y+12	; 0x0c
    a20e:	82 0f       	add	r24, r18
    a210:	93 1f       	adc	r25, r19
    a212:	2f 89       	ldd	r18, Y+23	; 0x17
    a214:	38 8d       	ldd	r19, Y+24	; 0x18
    a216:	82 0f       	add	r24, r18
    a218:	93 1f       	adc	r25, r19
    a21a:	fc 01       	movw	r30, r24
    a21c:	80 81       	ld	r24, Z
    a21e:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a222:	28 2f       	mov	r18, r24
    a224:	c8 01       	movw	r24, r16
    a226:	81 56       	subi	r24, 0x61	; 97
    a228:	9f 4a       	sbci	r25, 0xAF	; 175
    a22a:	fc 01       	movw	r30, r24
    a22c:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a22e:	8b 85       	ldd	r24, Y+11	; 0x0b
    a230:	9c 85       	ldd	r25, Y+12	; 0x0c
    a232:	01 96       	adiw	r24, 0x01	; 1
    a234:	8b 87       	std	Y+11, r24	; 0x0b
    a236:	9c 87       	std	Y+12, r25	; 0x0c
    a238:	8b 85       	ldd	r24, Y+11	; 0x0b
    a23a:	9c 85       	ldd	r25, Y+12	; 0x0c
    a23c:	f2 e0       	ldi	r31, 0x02	; 2
    a23e:	80 30       	cpi	r24, 0x00	; 0
    a240:	9f 07       	cpc	r25, r31
    a242:	ac f2       	brlt	.-86     	; 0xa1ee <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a244:	1d 86       	std	Y+13, r1	; 0x0d
    a246:	1e 86       	std	Y+14, r1	; 0x0e
    a248:	0a c0       	rjmp	.+20     	; 0xa25e <SD_write_multiple_blocks+0x1f4>
    a24a:	8f ef       	ldi	r24, 0xFF	; 255
    a24c:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a250:	80 93 a0 50 	sts	0x50A0, r24
    a254:	8d 85       	ldd	r24, Y+13	; 0x0d
    a256:	9e 85       	ldd	r25, Y+14	; 0x0e
    a258:	01 96       	adiw	r24, 0x01	; 1
    a25a:	8d 87       	std	Y+13, r24	; 0x0d
    a25c:	9e 87       	std	Y+14, r25	; 0x0e
    a25e:	8d 85       	ldd	r24, Y+13	; 0x0d
    a260:	9e 85       	ldd	r25, Y+14	; 0x0e
    a262:	82 30       	cpi	r24, 0x02	; 2
    a264:	91 05       	cpc	r25, r1
    a266:	8c f3       	brlt	.-30     	; 0xa24a <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a268:	10 92 a0 50 	sts	0x50A0, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a26c:	05 c0       	rjmp	.+10     	; 0xa278 <SD_write_multiple_blocks+0x20e>
    a26e:	8f ef       	ldi	r24, 0xFF	; 255
    a270:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a274:	80 93 a0 50 	sts	0x50A0, r24
    a278:	80 91 a0 50 	lds	r24, 0x50A0
    a27c:	8f 3f       	cpi	r24, 0xFF	; 255
    a27e:	b9 f7       	brne	.-18     	; 0xa26e <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a280:	8d 81       	ldd	r24, Y+5	; 0x05
    a282:	9e 81       	ldd	r25, Y+6	; 0x06
    a284:	01 96       	adiw	r24, 0x01	; 1
    a286:	8d 83       	std	Y+5, r24	; 0x05
    a288:	9e 83       	std	Y+6, r25	; 0x06
    a28a:	2d 81       	ldd	r18, Y+5	; 0x05
    a28c:	3e 81       	ldd	r19, Y+6	; 0x06
    a28e:	89 81       	ldd	r24, Y+1	; 0x01
    a290:	9a 81       	ldd	r25, Y+2	; 0x02
    a292:	28 17       	cp	r18, r24
    a294:	39 07       	cpc	r19, r25
    a296:	0c f4       	brge	.+2      	; 0xa29a <SD_write_multiple_blocks+0x230>
    a298:	3e cf       	rjmp	.-388    	; 0xa116 <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a29a:	1f 86       	std	Y+15, r1	; 0x0f
    a29c:	18 8a       	std	Y+16, r1	; 0x10
    a29e:	0a c0       	rjmp	.+20     	; 0xa2b4 <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a2a0:	8f ef       	ldi	r24, 0xFF	; 255
    a2a2:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a2a6:	80 93 a0 50 	sts	0x50A0, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a2aa:	8f 85       	ldd	r24, Y+15	; 0x0f
    a2ac:	98 89       	ldd	r25, Y+16	; 0x10
    a2ae:	01 96       	adiw	r24, 0x01	; 1
    a2b0:	8f 87       	std	Y+15, r24	; 0x0f
    a2b2:	98 8b       	std	Y+16, r25	; 0x10
    a2b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    a2b6:	98 89       	ldd	r25, Y+16	; 0x10
    a2b8:	84 30       	cpi	r24, 0x04	; 4
    a2ba:	91 05       	cpc	r25, r1
    a2bc:	8c f3       	brlt	.-30     	; 0xa2a0 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a2be:	8d ef       	ldi	r24, 0xFD	; 253
    a2c0:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a2c4:	80 93 a0 50 	sts	0x50A0, r24
	for(int i=0;i<4;i++){
    a2c8:	19 8a       	std	Y+17, r1	; 0x11
    a2ca:	1a 8a       	std	Y+18, r1	; 0x12
    a2cc:	0a c0       	rjmp	.+20     	; 0xa2e2 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a2ce:	8f ef       	ldi	r24, 0xFF	; 255
    a2d0:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a2d4:	80 93 a0 50 	sts	0x50A0, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a2d8:	89 89       	ldd	r24, Y+17	; 0x11
    a2da:	9a 89       	ldd	r25, Y+18	; 0x12
    a2dc:	01 96       	adiw	r24, 0x01	; 1
    a2de:	89 8b       	std	Y+17, r24	; 0x11
    a2e0:	9a 8b       	std	Y+18, r25	; 0x12
    a2e2:	89 89       	ldd	r24, Y+17	; 0x11
    a2e4:	9a 89       	ldd	r25, Y+18	; 0x12
    a2e6:	84 30       	cpi	r24, 0x04	; 4
    a2e8:	91 05       	cpc	r25, r1
    a2ea:	8c f3       	brlt	.-30     	; 0xa2ce <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a2ec:	10 92 a0 50 	sts	0x50A0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a2f0:	05 c0       	rjmp	.+10     	; 0xa2fc <SD_write_multiple_blocks+0x292>
    a2f2:	8f ef       	ldi	r24, 0xFF	; 255
    a2f4:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a2f8:	80 93 a0 50 	sts	0x50A0, r24
    a2fc:	80 91 a0 50 	lds	r24, 0x50A0
    a300:	8f 3f       	cpi	r24, 0xFF	; 255
    a302:	b9 f7       	brne	.-18     	; 0xa2f2 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a304:	80 e0       	ldi	r24, 0x00	; 0
    a306:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    a30a:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a30e:	88 e0       	ldi	r24, 0x08	; 8
    a310:	60 e0       	ldi	r22, 0x00	; 0
    a312:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
}
    a316:	6a 96       	adiw	r28, 0x1a	; 26
    a318:	cd bf       	out	0x3d, r28	; 61
    a31a:	de bf       	out	0x3e, r29	; 62
    a31c:	df 91       	pop	r29
    a31e:	cf 91       	pop	r28
    a320:	1f 91       	pop	r17
    a322:	0f 91       	pop	r16
    a324:	08 95       	ret

0000a326 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a326:	0f 93       	push	r16
    a328:	1f 93       	push	r17
    a32a:	cf 93       	push	r28
    a32c:	df 93       	push	r29
    a32e:	cd b7       	in	r28, 0x3d	; 61
    a330:	de b7       	in	r29, 0x3e	; 62
    a332:	2e 97       	sbiw	r28, 0x0e	; 14
    a334:	cd bf       	out	0x3d, r28	; 61
    a336:	de bf       	out	0x3e, r29	; 62
    a338:	6f 83       	std	Y+7, r22	; 0x07
    a33a:	78 87       	std	Y+8, r23	; 0x08
    a33c:	89 87       	std	Y+9, r24	; 0x09
    a33e:	9a 87       	std	Y+10, r25	; 0x0a
    a340:	4b 87       	std	Y+11, r20	; 0x0b
    a342:	5c 87       	std	Y+12, r21	; 0x0c
    a344:	2d 87       	std	Y+13, r18	; 0x0d
    a346:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a348:	88 e0       	ldi	r24, 0x08	; 8
    a34a:	60 e0       	ldi	r22, 0x00	; 0
    a34c:	0e 94 06 35 	call	0x6a0c	; 0x6a0c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a350:	80 e0       	ldi	r24, 0x00	; 0
    a352:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    a356:	81 e0       	ldi	r24, 0x01	; 1
    a358:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a35c:	00 00       	nop
    a35e:	2f 81       	ldd	r18, Y+7	; 0x07
    a360:	38 85       	ldd	r19, Y+8	; 0x08
    a362:	49 85       	ldd	r20, Y+9	; 0x09
    a364:	5a 85       	ldd	r21, Y+10	; 0x0a
    a366:	82 e1       	ldi	r24, 0x12	; 18
    a368:	ba 01       	movw	r22, r20
    a36a:	a9 01       	movw	r20, r18
    a36c:	2f ef       	ldi	r18, 0xFF	; 255
    a36e:	08 e0       	ldi	r16, 0x08	; 8
    a370:	10 e0       	ldi	r17, 0x00	; 0
    a372:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
    a376:	88 23       	and	r24, r24
    a378:	91 f7       	brne	.-28     	; 0xa35e <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a37a:	19 82       	std	Y+1, r1	; 0x01
    a37c:	1a 82       	std	Y+2, r1	; 0x02
    a37e:	4b c0       	rjmp	.+150    	; 0xa416 <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a380:	8f ef       	ldi	r24, 0xFF	; 255
    a382:	80 93 a0 50 	sts	0x50A0, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a386:	05 c0       	rjmp	.+10     	; 0xa392 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a388:	8f ef       	ldi	r24, 0xFF	; 255
    a38a:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a38e:	80 93 a0 50 	sts	0x50A0, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a392:	80 91 a0 50 	lds	r24, 0x50A0
    a396:	8e 3f       	cpi	r24, 0xFE	; 254
    a398:	b9 f7       	brne	.-18     	; 0xa388 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a39a:	1b 82       	std	Y+3, r1	; 0x03
    a39c:	1c 82       	std	Y+4, r1	; 0x04
    a39e:	19 c0       	rjmp	.+50     	; 0xa3d2 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a3a0:	89 81       	ldd	r24, Y+1	; 0x01
    a3a2:	9a 81       	ldd	r25, Y+2	; 0x02
    a3a4:	9c 01       	movw	r18, r24
    a3a6:	32 2f       	mov	r19, r18
    a3a8:	22 27       	eor	r18, r18
    a3aa:	33 0f       	add	r19, r19
    a3ac:	8b 81       	ldd	r24, Y+3	; 0x03
    a3ae:	9c 81       	ldd	r25, Y+4	; 0x04
    a3b0:	82 0f       	add	r24, r18
    a3b2:	93 1f       	adc	r25, r19
    a3b4:	2b 85       	ldd	r18, Y+11	; 0x0b
    a3b6:	3c 85       	ldd	r19, Y+12	; 0x0c
    a3b8:	89 01       	movw	r16, r18
    a3ba:	08 0f       	add	r16, r24
    a3bc:	19 1f       	adc	r17, r25
    a3be:	8f ef       	ldi	r24, 0xFF	; 255
    a3c0:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a3c4:	f8 01       	movw	r30, r16
    a3c6:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a3c8:	8b 81       	ldd	r24, Y+3	; 0x03
    a3ca:	9c 81       	ldd	r25, Y+4	; 0x04
    a3cc:	01 96       	adiw	r24, 0x01	; 1
    a3ce:	8b 83       	std	Y+3, r24	; 0x03
    a3d0:	9c 83       	std	Y+4, r25	; 0x04
    a3d2:	8b 81       	ldd	r24, Y+3	; 0x03
    a3d4:	9c 81       	ldd	r25, Y+4	; 0x04
    a3d6:	f2 e0       	ldi	r31, 0x02	; 2
    a3d8:	80 30       	cpi	r24, 0x00	; 0
    a3da:	9f 07       	cpc	r25, r31
    a3dc:	0c f3       	brlt	.-62     	; 0xa3a0 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a3de:	1d 82       	std	Y+5, r1	; 0x05
    a3e0:	1e 82       	std	Y+6, r1	; 0x06
    a3e2:	0f c0       	rjmp	.+30     	; 0xa402 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a3e4:	8f ef       	ldi	r24, 0xFF	; 255
    a3e6:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a3ea:	28 2f       	mov	r18, r24
    a3ec:	8d 81       	ldd	r24, Y+5	; 0x05
    a3ee:	9e 81       	ldd	r25, Y+6	; 0x06
    a3f0:	81 56       	subi	r24, 0x61	; 97
    a3f2:	9f 4a       	sbci	r25, 0xAF	; 175
    a3f4:	fc 01       	movw	r30, r24
    a3f6:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a3f8:	8d 81       	ldd	r24, Y+5	; 0x05
    a3fa:	9e 81       	ldd	r25, Y+6	; 0x06
    a3fc:	01 96       	adiw	r24, 0x01	; 1
    a3fe:	8d 83       	std	Y+5, r24	; 0x05
    a400:	9e 83       	std	Y+6, r25	; 0x06
    a402:	8d 81       	ldd	r24, Y+5	; 0x05
    a404:	9e 81       	ldd	r25, Y+6	; 0x06
    a406:	82 30       	cpi	r24, 0x02	; 2
    a408:	91 05       	cpc	r25, r1
    a40a:	64 f3       	brlt	.-40     	; 0xa3e4 <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a40c:	89 81       	ldd	r24, Y+1	; 0x01
    a40e:	9a 81       	ldd	r25, Y+2	; 0x02
    a410:	01 96       	adiw	r24, 0x01	; 1
    a412:	89 83       	std	Y+1, r24	; 0x01
    a414:	9a 83       	std	Y+2, r25	; 0x02
    a416:	29 81       	ldd	r18, Y+1	; 0x01
    a418:	3a 81       	ldd	r19, Y+2	; 0x02
    a41a:	8d 85       	ldd	r24, Y+13	; 0x0d
    a41c:	9e 85       	ldd	r25, Y+14	; 0x0e
    a41e:	28 17       	cp	r18, r24
    a420:	39 07       	cpc	r19, r25
    a422:	0c f4       	brge	.+2      	; 0xa426 <SD_read_multiple_blocks+0x100>
    a424:	ad cf       	rjmp	.-166    	; 0xa380 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a426:	8c e0       	ldi	r24, 0x0C	; 12
    a428:	40 e0       	ldi	r20, 0x00	; 0
    a42a:	50 e0       	ldi	r21, 0x00	; 0
    a42c:	ba 01       	movw	r22, r20
    a42e:	2f ef       	ldi	r18, 0xFF	; 255
    a430:	08 e0       	ldi	r16, 0x08	; 8
    a432:	10 e0       	ldi	r17, 0x00	; 0
    a434:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a438:	8f ef       	ldi	r24, 0xFF	; 255
    a43a:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a43e:	80 93 9f 50 	sts	0x509F, r24
	Buffer[1] = FILLER_BYTE;
    a442:	10 92 a0 50 	sts	0x50A0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a446:	05 c0       	rjmp	.+10     	; 0xa452 <SD_read_multiple_blocks+0x12c>
    a448:	8f ef       	ldi	r24, 0xFF	; 255
    a44a:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
    a44e:	80 93 a0 50 	sts	0x50A0, r24
    a452:	80 91 a0 50 	lds	r24, 0x50A0
    a456:	8f 3f       	cpi	r24, 0xFF	; 255
    a458:	b9 f7       	brne	.-18     	; 0xa448 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a45a:	80 e0       	ldi	r24, 0x00	; 0
    a45c:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    a460:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a464:	88 e0       	ldi	r24, 0x08	; 8
    a466:	60 e0       	ldi	r22, 0x00	; 0
    a468:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
}
    a46c:	2e 96       	adiw	r28, 0x0e	; 14
    a46e:	cd bf       	out	0x3d, r28	; 61
    a470:	de bf       	out	0x3e, r29	; 62
    a472:	df 91       	pop	r29
    a474:	cf 91       	pop	r28
    a476:	1f 91       	pop	r17
    a478:	0f 91       	pop	r16
    a47a:	08 95       	ret

0000a47c <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a47c:	cf 93       	push	r28
    a47e:	df 93       	push	r29
    a480:	cd b7       	in	r28, 0x3d	; 61
    a482:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a484:	88 e0       	ldi	r24, 0x08	; 8
    a486:	60 e0       	ldi	r22, 0x00	; 0
    a488:	0e 94 d7 33 	call	0x67ae	; 0x67ae <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a48c:	88 e0       	ldi	r24, 0x08	; 8
    a48e:	60 e0       	ldi	r22, 0x00	; 0
    a490:	0e 94 a3 34 	call	0x6946	; 0x6946 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a494:	80 e0       	ldi	r24, 0x00	; 0
    a496:	0e 94 73 38 	call	0x70e6	; 0x70e6 <SPIInit>
	SPICS(TRUE);
    a49a:	81 e0       	ldi	r24, 0x01	; 1
    a49c:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a4a0:	8f ef       	ldi	r24, 0xFF	; 255
    a4a2:	0e 94 55 4e 	call	0x9caa	; 0x9caa <SPI_write>
	SPICS(FALSE);	//stop spi
    a4a6:	80 e0       	ldi	r24, 0x00	; 0
    a4a8:	0e 94 c8 38 	call	0x7190	; 0x7190 <SPICS>
	SPIDisable();
    a4ac:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a4b0:	80 e0       	ldi	r24, 0x00	; 0
    a4b2:	0e 94 2a 07 	call	0xe54	; 0xe54 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a4b6:	80 e0       	ldi	r24, 0x00	; 0
    a4b8:	0e 94 6d 35 	call	0x6ada	; 0x6ada <Ext1Power>
}
    a4bc:	df 91       	pop	r29
    a4be:	cf 91       	pop	r28
    a4c0:	08 95       	ret

0000a4c2 <__muldi3>:
    a4c2:	a0 e3       	ldi	r26, 0x30	; 48
    a4c4:	b0 e0       	ldi	r27, 0x00	; 0
    a4c6:	e7 e6       	ldi	r30, 0x67	; 103
    a4c8:	f2 e5       	ldi	r31, 0x52	; 82
    a4ca:	0c 94 ff 5d 	jmp	0xbbfe	; 0xbbfe <__prologue_saves__+0x4>
    a4ce:	29 8f       	std	Y+25, r18	; 0x19
    a4d0:	3a 8f       	std	Y+26, r19	; 0x1a
    a4d2:	4b 8f       	std	Y+27, r20	; 0x1b
    a4d4:	5c 8f       	std	Y+28, r21	; 0x1c
    a4d6:	6d 8f       	std	Y+29, r22	; 0x1d
    a4d8:	7e 8f       	std	Y+30, r23	; 0x1e
    a4da:	8f 8f       	std	Y+31, r24	; 0x1f
    a4dc:	98 a3       	lds	r25, 0x58
    a4de:	a9 8a       	std	Y+17, r10	; 0x11
    a4e0:	ba 8a       	std	Y+18, r11	; 0x12
    a4e2:	cb 8a       	std	Y+19, r12	; 0x13
    a4e4:	dc 8a       	std	Y+20, r13	; 0x14
    a4e6:	ed 8a       	std	Y+21, r14	; 0x15
    a4e8:	fe 8a       	std	Y+22, r15	; 0x16
    a4ea:	0f 8b       	std	Y+23, r16	; 0x17
    a4ec:	18 8f       	std	Y+24, r17	; 0x18
    a4ee:	09 8d       	ldd	r16, Y+25	; 0x19
    a4f0:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a4f2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a4f4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a4f6:	09 a3       	lds	r16, 0x59
    a4f8:	1a a3       	lds	r17, 0x5a
    a4fa:	2b a3       	lds	r18, 0x5b
    a4fc:	3c a3       	lds	r19, 0x5c
    a4fe:	68 01       	movw	r12, r16
    a500:	79 01       	movw	r14, r18
    a502:	8f ef       	ldi	r24, 0xFF	; 255
    a504:	9f ef       	ldi	r25, 0xFF	; 255
    a506:	a0 e0       	ldi	r26, 0x00	; 0
    a508:	b0 e0       	ldi	r27, 0x00	; 0
    a50a:	c8 22       	and	r12, r24
    a50c:	d9 22       	and	r13, r25
    a50e:	ea 22       	and	r14, r26
    a510:	fb 22       	and	r15, r27
    a512:	89 01       	movw	r16, r18
    a514:	22 27       	eor	r18, r18
    a516:	33 27       	eor	r19, r19
    a518:	09 a7       	lds	r16, 0x79
    a51a:	1a a7       	lds	r17, 0x7a
    a51c:	2b a7       	lds	r18, 0x7b
    a51e:	3c a7       	lds	r19, 0x7c
    a520:	09 89       	ldd	r16, Y+17	; 0x11
    a522:	1a 89       	ldd	r17, Y+18	; 0x12
    a524:	2b 89       	ldd	r18, Y+19	; 0x13
    a526:	3c 89       	ldd	r19, Y+20	; 0x14
    a528:	0d a3       	lds	r16, 0x5d
    a52a:	1e a3       	lds	r17, 0x5e
    a52c:	2f a3       	lds	r18, 0x5f
    a52e:	38 a7       	lds	r19, 0x78
    a530:	48 01       	movw	r8, r16
    a532:	59 01       	movw	r10, r18
    a534:	88 22       	and	r8, r24
    a536:	99 22       	and	r9, r25
    a538:	aa 22       	and	r10, r26
    a53a:	bb 22       	and	r11, r27
    a53c:	29 01       	movw	r4, r18
    a53e:	66 24       	eor	r6, r6
    a540:	77 24       	eor	r7, r7
    a542:	c5 01       	movw	r24, r10
    a544:	b4 01       	movw	r22, r8
    a546:	a7 01       	movw	r20, r14
    a548:	96 01       	movw	r18, r12
    a54a:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    a54e:	6d a7       	lds	r22, 0x7d
    a550:	7e a7       	lds	r23, 0x7e
    a552:	8f a7       	lds	r24, 0x7f
    a554:	98 ab       	sts	0x58, r25
    a556:	c3 01       	movw	r24, r6
    a558:	b2 01       	movw	r22, r4
    a55a:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    a55e:	6b 01       	movw	r12, r22
    a560:	7c 01       	movw	r14, r24
    a562:	c5 01       	movw	r24, r10
    a564:	b4 01       	movw	r22, r8
    a566:	29 a5       	lds	r18, 0x69
    a568:	3a a5       	lds	r19, 0x6a
    a56a:	4b a5       	lds	r20, 0x6b
    a56c:	5c a5       	lds	r21, 0x6c
    a56e:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    a572:	4b 01       	movw	r8, r22
    a574:	5c 01       	movw	r10, r24
    a576:	c3 01       	movw	r24, r6
    a578:	b2 01       	movw	r22, r4
    a57a:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    a57e:	ab 01       	movw	r20, r22
    a580:	bc 01       	movw	r22, r24
    a582:	c8 0c       	add	r12, r8
    a584:	d9 1c       	adc	r13, r9
    a586:	ea 1c       	adc	r14, r10
    a588:	fb 1c       	adc	r15, r11
    a58a:	0d a5       	lds	r16, 0x6d
    a58c:	1e a5       	lds	r17, 0x6e
    a58e:	2f a5       	lds	r18, 0x6f
    a590:	38 a9       	sts	0x48, r19
    a592:	c9 01       	movw	r24, r18
    a594:	aa 27       	eor	r26, r26
    a596:	bb 27       	eor	r27, r27
    a598:	c8 0e       	add	r12, r24
    a59a:	d9 1e       	adc	r13, r25
    a59c:	ea 1e       	adc	r14, r26
    a59e:	fb 1e       	adc	r15, r27
    a5a0:	c8 14       	cp	r12, r8
    a5a2:	d9 04       	cpc	r13, r9
    a5a4:	ea 04       	cpc	r14, r10
    a5a6:	fb 04       	cpc	r15, r11
    a5a8:	20 f4       	brcc	.+8      	; 0xa5b2 <__muldi3+0xf0>
    a5aa:	40 50       	subi	r20, 0x00	; 0
    a5ac:	50 40       	sbci	r21, 0x00	; 0
    a5ae:	6f 4f       	sbci	r22, 0xFF	; 255
    a5b0:	7f 4f       	sbci	r23, 0xFF	; 255
    a5b2:	c7 01       	movw	r24, r14
    a5b4:	aa 27       	eor	r26, r26
    a5b6:	bb 27       	eor	r27, r27
    a5b8:	84 0f       	add	r24, r20
    a5ba:	95 1f       	adc	r25, r21
    a5bc:	a6 1f       	adc	r26, r22
    a5be:	b7 1f       	adc	r27, r23
    a5c0:	8d 83       	std	Y+5, r24	; 0x05
    a5c2:	9e 83       	std	Y+6, r25	; 0x06
    a5c4:	af 83       	std	Y+7, r26	; 0x07
    a5c6:	b8 87       	std	Y+8, r27	; 0x08
    a5c8:	76 01       	movw	r14, r12
    a5ca:	dd 24       	eor	r13, r13
    a5cc:	cc 24       	eor	r12, r12
    a5ce:	4d a5       	lds	r20, 0x6d
    a5d0:	5e a5       	lds	r21, 0x6e
    a5d2:	6f a5       	lds	r22, 0x6f
    a5d4:	78 a9       	sts	0x48, r23
    a5d6:	60 70       	andi	r22, 0x00	; 0
    a5d8:	70 70       	andi	r23, 0x00	; 0
    a5da:	c4 0e       	add	r12, r20
    a5dc:	d5 1e       	adc	r13, r21
    a5de:	e6 1e       	adc	r14, r22
    a5e0:	f7 1e       	adc	r15, r23
    a5e2:	c9 82       	std	Y+1, r12	; 0x01
    a5e4:	da 82       	std	Y+2, r13	; 0x02
    a5e6:	eb 82       	std	Y+3, r14	; 0x03
    a5e8:	fc 82       	std	Y+4, r15	; 0x04
    a5ea:	1c 2d       	mov	r17, r12
    a5ec:	0a 81       	ldd	r16, Y+2	; 0x02
    a5ee:	8b 80       	ldd	r8, Y+3	; 0x03
    a5f0:	4c 80       	ldd	r4, Y+4	; 0x04
    a5f2:	8d 87       	std	Y+13, r24	; 0x0d
    a5f4:	8e 81       	ldd	r24, Y+6	; 0x06
    a5f6:	8e 87       	std	Y+14, r24	; 0x0e
    a5f8:	8f 81       	ldd	r24, Y+7	; 0x07
    a5fa:	8f 87       	std	Y+15, r24	; 0x0f
    a5fc:	88 85       	ldd	r24, Y+8	; 0x08
    a5fe:	88 8b       	std	Y+16, r24	; 0x10
    a600:	2d 89       	ldd	r18, Y+21	; 0x15
    a602:	3e 89       	ldd	r19, Y+22	; 0x16
    a604:	4f 89       	ldd	r20, Y+23	; 0x17
    a606:	58 8d       	ldd	r21, Y+24	; 0x18
    a608:	69 a1       	lds	r22, 0x49
    a60a:	7a a1       	lds	r23, 0x4a
    a60c:	8b a1       	lds	r24, 0x4b
    a60e:	9c a1       	lds	r25, 0x4c
    a610:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    a614:	6b 01       	movw	r12, r22
    a616:	7c 01       	movw	r14, r24
    a618:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a61a:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a61c:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a61e:	58 a1       	lds	r21, 0x48
    a620:	6d a1       	lds	r22, 0x4d
    a622:	7e a1       	lds	r23, 0x4e
    a624:	8f a1       	lds	r24, 0x4f
    a626:	98 a5       	lds	r25, 0x68
    a628:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    a62c:	dc 01       	movw	r26, r24
    a62e:	cb 01       	movw	r24, r22
    a630:	c8 0e       	add	r12, r24
    a632:	d9 1e       	adc	r13, r25
    a634:	ea 1e       	adc	r14, r26
    a636:	fb 1e       	adc	r15, r27
    a638:	8d 85       	ldd	r24, Y+13	; 0x0d
    a63a:	9e 85       	ldd	r25, Y+14	; 0x0e
    a63c:	af 85       	ldd	r26, Y+15	; 0x0f
    a63e:	b8 89       	ldd	r27, Y+16	; 0x10
    a640:	8c 0d       	add	r24, r12
    a642:	9d 1d       	adc	r25, r13
    a644:	ae 1d       	adc	r26, r14
    a646:	bf 1d       	adc	r27, r15
    a648:	8d 87       	std	Y+13, r24	; 0x0d
    a64a:	9e 87       	std	Y+14, r25	; 0x0e
    a64c:	af 87       	std	Y+15, r26	; 0x0f
    a64e:	b8 8b       	std	Y+16, r27	; 0x10
    a650:	68 2f       	mov	r22, r24
    a652:	7e 85       	ldd	r23, Y+14	; 0x0e
    a654:	21 2f       	mov	r18, r17
    a656:	30 2f       	mov	r19, r16
    a658:	48 2d       	mov	r20, r8
    a65a:	54 2d       	mov	r21, r4
    a65c:	8f 85       	ldd	r24, Y+15	; 0x0f
    a65e:	98 89       	ldd	r25, Y+16	; 0x10
    a660:	e0 96       	adiw	r28, 0x30	; 48
    a662:	e0 e1       	ldi	r30, 0x10	; 16
    a664:	0c 94 18 5e 	jmp	0xbc30	; 0xbc30 <__epilogue_restores__+0x4>

0000a668 <__ashldi3>:
    a668:	cf 92       	push	r12
    a66a:	df 92       	push	r13
    a66c:	ef 92       	push	r14
    a66e:	ff 92       	push	r15
    a670:	0f 93       	push	r16
    a672:	cf 93       	push	r28
    a674:	df 93       	push	r29
    a676:	cd b7       	in	r28, 0x3d	; 61
    a678:	de b7       	in	r29, 0x3e	; 62
    a67a:	60 97       	sbiw	r28, 0x10	; 16
    a67c:	cd bf       	out	0x3d, r28	; 61
    a67e:	de bf       	out	0x3e, r29	; 62
    a680:	00 23       	and	r16, r16
    a682:	09 f4       	brne	.+2      	; 0xa686 <__ashldi3+0x1e>
    a684:	5a c0       	rjmp	.+180    	; 0xa73a <__ashldi3+0xd2>
    a686:	29 87       	std	Y+9, r18	; 0x09
    a688:	3a 87       	std	Y+10, r19	; 0x0a
    a68a:	4b 87       	std	Y+11, r20	; 0x0b
    a68c:	5c 87       	std	Y+12, r21	; 0x0c
    a68e:	6d 87       	std	Y+13, r22	; 0x0d
    a690:	7e 87       	std	Y+14, r23	; 0x0e
    a692:	8f 87       	std	Y+15, r24	; 0x0f
    a694:	98 8b       	std	Y+16, r25	; 0x10
    a696:	80 e2       	ldi	r24, 0x20	; 32
    a698:	80 1b       	sub	r24, r16
    a69a:	49 85       	ldd	r20, Y+9	; 0x09
    a69c:	5a 85       	ldd	r21, Y+10	; 0x0a
    a69e:	6b 85       	ldd	r22, Y+11	; 0x0b
    a6a0:	7c 85       	ldd	r23, Y+12	; 0x0c
    a6a2:	18 16       	cp	r1, r24
    a6a4:	b4 f0       	brlt	.+44     	; 0xa6d2 <__ashldi3+0x6a>
    a6a6:	19 82       	std	Y+1, r1	; 0x01
    a6a8:	1a 82       	std	Y+2, r1	; 0x02
    a6aa:	1b 82       	std	Y+3, r1	; 0x03
    a6ac:	1c 82       	std	Y+4, r1	; 0x04
    a6ae:	99 27       	eor	r25, r25
    a6b0:	87 fd       	sbrc	r24, 7
    a6b2:	90 95       	com	r25
    a6b4:	90 95       	com	r25
    a6b6:	81 95       	neg	r24
    a6b8:	9f 4f       	sbci	r25, 0xFF	; 255
    a6ba:	04 c0       	rjmp	.+8      	; 0xa6c4 <__ashldi3+0x5c>
    a6bc:	44 0f       	add	r20, r20
    a6be:	55 1f       	adc	r21, r21
    a6c0:	66 1f       	adc	r22, r22
    a6c2:	77 1f       	adc	r23, r23
    a6c4:	8a 95       	dec	r24
    a6c6:	d2 f7       	brpl	.-12     	; 0xa6bc <__ashldi3+0x54>
    a6c8:	4d 83       	std	Y+5, r20	; 0x05
    a6ca:	5e 83       	std	Y+6, r21	; 0x06
    a6cc:	6f 83       	std	Y+7, r22	; 0x07
    a6ce:	78 87       	std	Y+8, r23	; 0x08
    a6d0:	2c c0       	rjmp	.+88     	; 0xa72a <__ashldi3+0xc2>
    a6d2:	6a 01       	movw	r12, r20
    a6d4:	7b 01       	movw	r14, r22
    a6d6:	00 2e       	mov	r0, r16
    a6d8:	04 c0       	rjmp	.+8      	; 0xa6e2 <__ashldi3+0x7a>
    a6da:	cc 0c       	add	r12, r12
    a6dc:	dd 1c       	adc	r13, r13
    a6de:	ee 1c       	adc	r14, r14
    a6e0:	ff 1c       	adc	r15, r15
    a6e2:	0a 94       	dec	r0
    a6e4:	d2 f7       	brpl	.-12     	; 0xa6da <__ashldi3+0x72>
    a6e6:	c9 82       	std	Y+1, r12	; 0x01
    a6e8:	da 82       	std	Y+2, r13	; 0x02
    a6ea:	eb 82       	std	Y+3, r14	; 0x03
    a6ec:	fc 82       	std	Y+4, r15	; 0x04
    a6ee:	6a 01       	movw	r12, r20
    a6f0:	7b 01       	movw	r14, r22
    a6f2:	04 c0       	rjmp	.+8      	; 0xa6fc <__ashldi3+0x94>
    a6f4:	f6 94       	lsr	r15
    a6f6:	e7 94       	ror	r14
    a6f8:	d7 94       	ror	r13
    a6fa:	c7 94       	ror	r12
    a6fc:	8a 95       	dec	r24
    a6fe:	d2 f7       	brpl	.-12     	; 0xa6f4 <__ashldi3+0x8c>
    a700:	d7 01       	movw	r26, r14
    a702:	c6 01       	movw	r24, r12
    a704:	4d 85       	ldd	r20, Y+13	; 0x0d
    a706:	5e 85       	ldd	r21, Y+14	; 0x0e
    a708:	6f 85       	ldd	r22, Y+15	; 0x0f
    a70a:	78 89       	ldd	r23, Y+16	; 0x10
    a70c:	04 c0       	rjmp	.+8      	; 0xa716 <__ashldi3+0xae>
    a70e:	44 0f       	add	r20, r20
    a710:	55 1f       	adc	r21, r21
    a712:	66 1f       	adc	r22, r22
    a714:	77 1f       	adc	r23, r23
    a716:	0a 95       	dec	r16
    a718:	d2 f7       	brpl	.-12     	; 0xa70e <__ashldi3+0xa6>
    a71a:	84 2b       	or	r24, r20
    a71c:	95 2b       	or	r25, r21
    a71e:	a6 2b       	or	r26, r22
    a720:	b7 2b       	or	r27, r23
    a722:	8d 83       	std	Y+5, r24	; 0x05
    a724:	9e 83       	std	Y+6, r25	; 0x06
    a726:	af 83       	std	Y+7, r26	; 0x07
    a728:	b8 87       	std	Y+8, r27	; 0x08
    a72a:	29 81       	ldd	r18, Y+1	; 0x01
    a72c:	3a 81       	ldd	r19, Y+2	; 0x02
    a72e:	4b 81       	ldd	r20, Y+3	; 0x03
    a730:	5c 81       	ldd	r21, Y+4	; 0x04
    a732:	6d 81       	ldd	r22, Y+5	; 0x05
    a734:	7e 81       	ldd	r23, Y+6	; 0x06
    a736:	8f 81       	ldd	r24, Y+7	; 0x07
    a738:	98 85       	ldd	r25, Y+8	; 0x08
    a73a:	60 96       	adiw	r28, 0x10	; 16
    a73c:	cd bf       	out	0x3d, r28	; 61
    a73e:	de bf       	out	0x3e, r29	; 62
    a740:	df 91       	pop	r29
    a742:	cf 91       	pop	r28
    a744:	0f 91       	pop	r16
    a746:	ff 90       	pop	r15
    a748:	ef 90       	pop	r14
    a74a:	df 90       	pop	r13
    a74c:	cf 90       	pop	r12
    a74e:	08 95       	ret

0000a750 <__divdi3>:
    a750:	a8 e4       	ldi	r26, 0x48	; 72
    a752:	b0 e0       	ldi	r27, 0x00	; 0
    a754:	ee ea       	ldi	r30, 0xAE	; 174
    a756:	f3 e5       	ldi	r31, 0x53	; 83
    a758:	0c 94 fe 5d 	jmp	0xbbfc	; 0xbbfc <__prologue_saves__+0x2>
    a75c:	f5 01       	movw	r30, r10
    a75e:	29 a3       	lds	r18, 0x59
    a760:	3a a3       	lds	r19, 0x5a
    a762:	4b a3       	lds	r20, 0x5b
    a764:	5c a3       	lds	r21, 0x5c
    a766:	6d a3       	lds	r22, 0x5d
    a768:	7e a3       	lds	r23, 0x5e
    a76a:	8f a3       	lds	r24, 0x5f
    a76c:	98 a7       	lds	r25, 0x78
    a76e:	a9 8e       	std	Y+25, r10	; 0x19
    a770:	fa 8f       	std	Y+26, r31	; 0x1a
    a772:	cb 8e       	std	Y+27, r12	; 0x1b
    a774:	dc 8e       	std	Y+28, r13	; 0x1c
    a776:	ed 8e       	std	Y+29, r14	; 0x1d
    a778:	fe 8e       	std	Y+30, r15	; 0x1e
    a77a:	0f 8f       	std	Y+31, r16	; 0x1f
    a77c:	18 a3       	lds	r17, 0x58
    a77e:	8d a0       	lds	r24, 0x8d
    a780:	9e a0       	lds	r25, 0x8e
    a782:	af a0       	lds	r26, 0x8f
    a784:	b8 a4       	lds	r27, 0xa8
    a786:	b7 fe       	sbrs	r11, 7
    a788:	67 c0       	rjmp	.+206    	; 0xa858 <__divdi3+0x108>
    a78a:	21 95       	neg	r18
    a78c:	b1 e0       	ldi	r27, 0x01	; 1
    a78e:	12 16       	cp	r1, r18
    a790:	08 f0       	brcs	.+2      	; 0xa794 <__divdi3+0x44>
    a792:	b0 e0       	ldi	r27, 0x00	; 0
    a794:	31 95       	neg	r19
    a796:	a1 e0       	ldi	r26, 0x01	; 1
    a798:	13 16       	cp	r1, r19
    a79a:	08 f0       	brcs	.+2      	; 0xa79e <__divdi3+0x4e>
    a79c:	a0 e0       	ldi	r26, 0x00	; 0
    a79e:	b3 2e       	mov	r11, r19
    a7a0:	bb 1a       	sub	r11, r27
    a7a2:	bb 2d       	mov	r27, r11
    a7a4:	88 24       	eor	r8, r8
    a7a6:	83 94       	inc	r8
    a7a8:	3b 15       	cp	r19, r11
    a7aa:	08 f0       	brcs	.+2      	; 0xa7ae <__divdi3+0x5e>
    a7ac:	88 24       	eor	r8, r8
    a7ae:	a8 29       	or	r26, r8
    a7b0:	41 95       	neg	r20
    a7b2:	31 e0       	ldi	r19, 0x01	; 1
    a7b4:	14 16       	cp	r1, r20
    a7b6:	08 f0       	brcs	.+2      	; 0xa7ba <__divdi3+0x6a>
    a7b8:	30 e0       	ldi	r19, 0x00	; 0
    a7ba:	b4 2e       	mov	r11, r20
    a7bc:	ba 1a       	sub	r11, r26
    a7be:	ab 2d       	mov	r26, r11
    a7c0:	88 24       	eor	r8, r8
    a7c2:	83 94       	inc	r8
    a7c4:	4b 15       	cp	r20, r11
    a7c6:	08 f0       	brcs	.+2      	; 0xa7ca <__divdi3+0x7a>
    a7c8:	88 24       	eor	r8, r8
    a7ca:	38 29       	or	r19, r8
    a7cc:	51 95       	neg	r21
    a7ce:	41 e0       	ldi	r20, 0x01	; 1
    a7d0:	15 16       	cp	r1, r21
    a7d2:	08 f0       	brcs	.+2      	; 0xa7d6 <__divdi3+0x86>
    a7d4:	40 e0       	ldi	r20, 0x00	; 0
    a7d6:	45 2e       	mov	r4, r21
    a7d8:	43 1a       	sub	r4, r19
    a7da:	31 e0       	ldi	r19, 0x01	; 1
    a7dc:	54 15       	cp	r21, r4
    a7de:	08 f0       	brcs	.+2      	; 0xa7e2 <__divdi3+0x92>
    a7e0:	30 e0       	ldi	r19, 0x00	; 0
    a7e2:	43 2b       	or	r20, r19
    a7e4:	61 95       	neg	r22
    a7e6:	31 e0       	ldi	r19, 0x01	; 1
    a7e8:	16 16       	cp	r1, r22
    a7ea:	08 f0       	brcs	.+2      	; 0xa7ee <__divdi3+0x9e>
    a7ec:	30 e0       	ldi	r19, 0x00	; 0
    a7ee:	86 2e       	mov	r8, r22
    a7f0:	84 1a       	sub	r8, r20
    a7f2:	41 e0       	ldi	r20, 0x01	; 1
    a7f4:	68 15       	cp	r22, r8
    a7f6:	08 f0       	brcs	.+2      	; 0xa7fa <__divdi3+0xaa>
    a7f8:	40 e0       	ldi	r20, 0x00	; 0
    a7fa:	34 2b       	or	r19, r20
    a7fc:	71 95       	neg	r23
    a7fe:	41 e0       	ldi	r20, 0x01	; 1
    a800:	17 16       	cp	r1, r23
    a802:	08 f0       	brcs	.+2      	; 0xa806 <__divdi3+0xb6>
    a804:	40 e0       	ldi	r20, 0x00	; 0
    a806:	57 2f       	mov	r21, r23
    a808:	53 1b       	sub	r21, r19
    a80a:	31 e0       	ldi	r19, 0x01	; 1
    a80c:	75 17       	cp	r23, r21
    a80e:	08 f0       	brcs	.+2      	; 0xa812 <__divdi3+0xc2>
    a810:	30 e0       	ldi	r19, 0x00	; 0
    a812:	43 2b       	or	r20, r19
    a814:	81 95       	neg	r24
    a816:	31 e0       	ldi	r19, 0x01	; 1
    a818:	18 16       	cp	r1, r24
    a81a:	08 f0       	brcs	.+2      	; 0xa81e <__divdi3+0xce>
    a81c:	30 e0       	ldi	r19, 0x00	; 0
    a81e:	68 2f       	mov	r22, r24
    a820:	64 1b       	sub	r22, r20
    a822:	46 2f       	mov	r20, r22
    a824:	61 e0       	ldi	r22, 0x01	; 1
    a826:	84 17       	cp	r24, r20
    a828:	08 f0       	brcs	.+2      	; 0xa82c <__divdi3+0xdc>
    a82a:	60 e0       	ldi	r22, 0x00	; 0
    a82c:	36 2b       	or	r19, r22
    a82e:	91 95       	neg	r25
    a830:	93 1b       	sub	r25, r19
    a832:	29 a3       	lds	r18, 0x59
    a834:	ba a3       	lds	r27, 0x5a
    a836:	ab a3       	lds	r26, 0x5b
    a838:	4c a2       	lds	r20, 0x9c
    a83a:	8d a2       	lds	r24, 0x9d
    a83c:	5e a3       	lds	r21, 0x5e
    a83e:	4f a3       	lds	r20, 0x5f
    a840:	98 a7       	lds	r25, 0x78
    a842:	8f ef       	ldi	r24, 0xFF	; 255
    a844:	9f ef       	ldi	r25, 0xFF	; 255
    a846:	af ef       	ldi	r26, 0xFF	; 255
    a848:	bf ef       	ldi	r27, 0xFF	; 255
    a84a:	25 96       	adiw	r28, 0x05	; 5
    a84c:	8c af       	sts	0x7c, r24
    a84e:	9d af       	sts	0x7d, r25
    a850:	ae af       	sts	0x7e, r26
    a852:	bf af       	sts	0x7f, r27
    a854:	25 97       	sbiw	r28, 0x05	; 5
    a856:	06 c0       	rjmp	.+12     	; 0xa864 <__divdi3+0x114>
    a858:	25 96       	adiw	r28, 0x05	; 5
    a85a:	1c ae       	sts	0xbc, r17
    a85c:	1d ae       	sts	0xbd, r17
    a85e:	1e ae       	sts	0xbe, r17
    a860:	1f ae       	sts	0xbf, r17
    a862:	25 97       	sbiw	r28, 0x05	; 5
    a864:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a866:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a868:	af 8d       	ldd	r26, Y+31	; 0x1f
    a86a:	b8 a1       	lds	r27, 0x48
    a86c:	b7 ff       	sbrs	r27, 7
    a86e:	68 c0       	rjmp	.+208    	; 0xa940 <__divdi3+0x1f0>
    a870:	25 96       	adiw	r28, 0x05	; 5
    a872:	2c ad       	sts	0x6c, r18
    a874:	3d ad       	sts	0x6d, r19
    a876:	4e ad       	sts	0x6e, r20
    a878:	5f ad       	sts	0x6f, r21
    a87a:	25 97       	sbiw	r28, 0x05	; 5
    a87c:	20 95       	com	r18
    a87e:	30 95       	com	r19
    a880:	40 95       	com	r20
    a882:	50 95       	com	r21
    a884:	25 96       	adiw	r28, 0x05	; 5
    a886:	2c af       	sts	0x7c, r18
    a888:	3d af       	sts	0x7d, r19
    a88a:	4e af       	sts	0x7e, r20
    a88c:	5f af       	sts	0x7f, r21
    a88e:	25 97       	sbiw	r28, 0x05	; 5
    a890:	e1 95       	neg	r30
    a892:	81 e0       	ldi	r24, 0x01	; 1
    a894:	1e 16       	cp	r1, r30
    a896:	08 f0       	brcs	.+2      	; 0xa89a <__divdi3+0x14a>
    a898:	80 e0       	ldi	r24, 0x00	; 0
    a89a:	f1 95       	neg	r31
    a89c:	91 e0       	ldi	r25, 0x01	; 1
    a89e:	1f 16       	cp	r1, r31
    a8a0:	08 f0       	brcs	.+2      	; 0xa8a4 <__divdi3+0x154>
    a8a2:	90 e0       	ldi	r25, 0x00	; 0
    a8a4:	4f 2f       	mov	r20, r31
    a8a6:	48 1b       	sub	r20, r24
    a8a8:	81 e0       	ldi	r24, 0x01	; 1
    a8aa:	f4 17       	cp	r31, r20
    a8ac:	08 f0       	brcs	.+2      	; 0xa8b0 <__divdi3+0x160>
    a8ae:	80 e0       	ldi	r24, 0x00	; 0
    a8b0:	98 2b       	or	r25, r24
    a8b2:	c1 94       	neg	r12
    a8b4:	81 e0       	ldi	r24, 0x01	; 1
    a8b6:	1c 14       	cp	r1, r12
    a8b8:	08 f0       	brcs	.+2      	; 0xa8bc <__divdi3+0x16c>
    a8ba:	80 e0       	ldi	r24, 0x00	; 0
    a8bc:	6c 2d       	mov	r22, r12
    a8be:	69 1b       	sub	r22, r25
    a8c0:	91 e0       	ldi	r25, 0x01	; 1
    a8c2:	c6 16       	cp	r12, r22
    a8c4:	08 f0       	brcs	.+2      	; 0xa8c8 <__divdi3+0x178>
    a8c6:	90 e0       	ldi	r25, 0x00	; 0
    a8c8:	89 2b       	or	r24, r25
    a8ca:	d1 94       	neg	r13
    a8cc:	91 e0       	ldi	r25, 0x01	; 1
    a8ce:	1d 14       	cp	r1, r13
    a8d0:	08 f0       	brcs	.+2      	; 0xa8d4 <__divdi3+0x184>
    a8d2:	90 e0       	ldi	r25, 0x00	; 0
    a8d4:	5d 2d       	mov	r21, r13
    a8d6:	58 1b       	sub	r21, r24
    a8d8:	81 e0       	ldi	r24, 0x01	; 1
    a8da:	d5 16       	cp	r13, r21
    a8dc:	08 f0       	brcs	.+2      	; 0xa8e0 <__divdi3+0x190>
    a8de:	80 e0       	ldi	r24, 0x00	; 0
    a8e0:	98 2b       	or	r25, r24
    a8e2:	e1 94       	neg	r14
    a8e4:	81 e0       	ldi	r24, 0x01	; 1
    a8e6:	1e 14       	cp	r1, r14
    a8e8:	08 f0       	brcs	.+2      	; 0xa8ec <__divdi3+0x19c>
    a8ea:	80 e0       	ldi	r24, 0x00	; 0
    a8ec:	3e 2d       	mov	r19, r14
    a8ee:	39 1b       	sub	r19, r25
    a8f0:	91 e0       	ldi	r25, 0x01	; 1
    a8f2:	e3 16       	cp	r14, r19
    a8f4:	08 f0       	brcs	.+2      	; 0xa8f8 <__divdi3+0x1a8>
    a8f6:	90 e0       	ldi	r25, 0x00	; 0
    a8f8:	89 2b       	or	r24, r25
    a8fa:	f1 94       	neg	r15
    a8fc:	91 e0       	ldi	r25, 0x01	; 1
    a8fe:	1f 14       	cp	r1, r15
    a900:	08 f0       	brcs	.+2      	; 0xa904 <__divdi3+0x1b4>
    a902:	90 e0       	ldi	r25, 0x00	; 0
    a904:	2f 2d       	mov	r18, r15
    a906:	28 1b       	sub	r18, r24
    a908:	81 e0       	ldi	r24, 0x01	; 1
    a90a:	f2 16       	cp	r15, r18
    a90c:	08 f0       	brcs	.+2      	; 0xa910 <__divdi3+0x1c0>
    a90e:	80 e0       	ldi	r24, 0x00	; 0
    a910:	98 2b       	or	r25, r24
    a912:	01 95       	neg	r16
    a914:	81 e0       	ldi	r24, 0x01	; 1
    a916:	10 16       	cp	r1, r16
    a918:	08 f0       	brcs	.+2      	; 0xa91c <__divdi3+0x1cc>
    a91a:	80 e0       	ldi	r24, 0x00	; 0
    a91c:	70 2f       	mov	r23, r16
    a91e:	79 1b       	sub	r23, r25
    a920:	97 2f       	mov	r25, r23
    a922:	71 e0       	ldi	r23, 0x01	; 1
    a924:	09 17       	cp	r16, r25
    a926:	08 f0       	brcs	.+2      	; 0xa92a <__divdi3+0x1da>
    a928:	70 e0       	ldi	r23, 0x00	; 0
    a92a:	87 2b       	or	r24, r23
    a92c:	11 95       	neg	r17
    a92e:	18 1b       	sub	r17, r24
    a930:	e9 8f       	std	Y+25, r30	; 0x19
    a932:	4a 8f       	std	Y+26, r20	; 0x1a
    a934:	6b 8f       	std	Y+27, r22	; 0x1b
    a936:	5c 8f       	std	Y+28, r21	; 0x1c
    a938:	3d 8f       	std	Y+29, r19	; 0x1d
    a93a:	2e 8f       	std	Y+30, r18	; 0x1e
    a93c:	9f 8f       	std	Y+31, r25	; 0x1f
    a93e:	18 a3       	lds	r17, 0x58
    a940:	79 8d       	ldd	r23, Y+25	; 0x19
    a942:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a944:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a946:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a948:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a94a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a94c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a94e:	88 a1       	lds	r24, 0x48
    a950:	e9 a1       	lds	r30, 0x49
    a952:	e9 8b       	std	Y+17, r30	; 0x11
    a954:	ea a1       	lds	r30, 0x4a
    a956:	ea 8b       	std	Y+18, r30	; 0x12
    a958:	eb a1       	lds	r30, 0x4b
    a95a:	eb 8b       	std	Y+19, r30	; 0x13
    a95c:	ec a1       	lds	r30, 0x4c
    a95e:	ec 8b       	std	Y+20, r30	; 0x14
    a960:	ed a1       	lds	r30, 0x4d
    a962:	ed 8b       	std	Y+21, r30	; 0x15
    a964:	ee a1       	lds	r30, 0x4e
    a966:	ee 8b       	std	Y+22, r30	; 0x16
    a968:	ef a1       	lds	r30, 0x4f
    a96a:	ef 8b       	std	Y+23, r30	; 0x17
    a96c:	e8 a5       	lds	r30, 0x68
    a96e:	e8 8f       	std	Y+24, r30	; 0x18
    a970:	79 87       	std	Y+9, r23	; 0x09
    a972:	6a 87       	std	Y+10, r22	; 0x0a
    a974:	5b 87       	std	Y+11, r21	; 0x0b
    a976:	4c 87       	std	Y+12, r20	; 0x0c
    a978:	3d 87       	std	Y+13, r19	; 0x0d
    a97a:	2e 87       	std	Y+14, r18	; 0x0e
    a97c:	9f 87       	std	Y+15, r25	; 0x0f
    a97e:	88 8b       	std	Y+16, r24	; 0x10
    a980:	89 84       	ldd	r8, Y+9	; 0x09
    a982:	9a 84       	ldd	r9, Y+10	; 0x0a
    a984:	ab 84       	ldd	r10, Y+11	; 0x0b
    a986:	bc 84       	ldd	r11, Y+12	; 0x0c
    a988:	8d 85       	ldd	r24, Y+13	; 0x0d
    a98a:	9e 85       	ldd	r25, Y+14	; 0x0e
    a98c:	af 85       	ldd	r26, Y+15	; 0x0f
    a98e:	b8 89       	ldd	r27, Y+16	; 0x10
    a990:	e9 88       	ldd	r14, Y+17	; 0x11
    a992:	fa 88       	ldd	r15, Y+18	; 0x12
    a994:	0b 89       	ldd	r16, Y+19	; 0x13
    a996:	1c 89       	ldd	r17, Y+20	; 0x14
    a998:	ed aa       	sts	0x9d, r30
    a99a:	fe aa       	sts	0x9e, r31
    a99c:	0f ab       	sts	0x5f, r16
    a99e:	18 af       	sts	0x78, r17
    a9a0:	cd 88       	ldd	r12, Y+21	; 0x15
    a9a2:	de 88       	ldd	r13, Y+22	; 0x16
    a9a4:	ef 88       	ldd	r14, Y+23	; 0x17
    a9a6:	f8 8c       	ldd	r15, Y+24	; 0x18
    a9a8:	00 97       	sbiw	r24, 0x00	; 0
    a9aa:	a1 05       	cpc	r26, r1
    a9ac:	b1 05       	cpc	r27, r1
    a9ae:	09 f0       	breq	.+2      	; 0xa9b2 <__divdi3+0x262>
    a9b0:	bd c3       	rjmp	.+1914   	; 0xb12c <__divdi3+0x9dc>
    a9b2:	c8 14       	cp	r12, r8
    a9b4:	d9 04       	cpc	r13, r9
    a9b6:	ea 04       	cpc	r14, r10
    a9b8:	fb 04       	cpc	r15, r11
    a9ba:	08 f0       	brcs	.+2      	; 0xa9be <__divdi3+0x26e>
    a9bc:	4d c1       	rjmp	.+666    	; 0xac58 <__divdi3+0x508>
    a9be:	00 e0       	ldi	r16, 0x00	; 0
    a9c0:	80 16       	cp	r8, r16
    a9c2:	00 e0       	ldi	r16, 0x00	; 0
    a9c4:	90 06       	cpc	r9, r16
    a9c6:	01 e0       	ldi	r16, 0x01	; 1
    a9c8:	a0 06       	cpc	r10, r16
    a9ca:	00 e0       	ldi	r16, 0x00	; 0
    a9cc:	b0 06       	cpc	r11, r16
    a9ce:	58 f4       	brcc	.+22     	; 0xa9e6 <__divdi3+0x296>
    a9d0:	1f ef       	ldi	r17, 0xFF	; 255
    a9d2:	81 16       	cp	r8, r17
    a9d4:	91 04       	cpc	r9, r1
    a9d6:	a1 04       	cpc	r10, r1
    a9d8:	b1 04       	cpc	r11, r1
    a9da:	09 f0       	breq	.+2      	; 0xa9de <__divdi3+0x28e>
    a9dc:	90 f4       	brcc	.+36     	; 0xaa02 <__divdi3+0x2b2>
    a9de:	80 e0       	ldi	r24, 0x00	; 0
    a9e0:	90 e0       	ldi	r25, 0x00	; 0
    a9e2:	dc 01       	movw	r26, r24
    a9e4:	17 c0       	rjmp	.+46     	; 0xaa14 <__divdi3+0x2c4>
    a9e6:	20 e0       	ldi	r18, 0x00	; 0
    a9e8:	82 16       	cp	r8, r18
    a9ea:	20 e0       	ldi	r18, 0x00	; 0
    a9ec:	92 06       	cpc	r9, r18
    a9ee:	20 e0       	ldi	r18, 0x00	; 0
    a9f0:	a2 06       	cpc	r10, r18
    a9f2:	21 e0       	ldi	r18, 0x01	; 1
    a9f4:	b2 06       	cpc	r11, r18
    a9f6:	50 f4       	brcc	.+20     	; 0xaa0c <__divdi3+0x2bc>
    a9f8:	80 e1       	ldi	r24, 0x10	; 16
    a9fa:	90 e0       	ldi	r25, 0x00	; 0
    a9fc:	a0 e0       	ldi	r26, 0x00	; 0
    a9fe:	b0 e0       	ldi	r27, 0x00	; 0
    aa00:	09 c0       	rjmp	.+18     	; 0xaa14 <__divdi3+0x2c4>
    aa02:	88 e0       	ldi	r24, 0x08	; 8
    aa04:	90 e0       	ldi	r25, 0x00	; 0
    aa06:	a0 e0       	ldi	r26, 0x00	; 0
    aa08:	b0 e0       	ldi	r27, 0x00	; 0
    aa0a:	04 c0       	rjmp	.+8      	; 0xaa14 <__divdi3+0x2c4>
    aa0c:	88 e1       	ldi	r24, 0x18	; 24
    aa0e:	90 e0       	ldi	r25, 0x00	; 0
    aa10:	a0 e0       	ldi	r26, 0x00	; 0
    aa12:	b0 e0       	ldi	r27, 0x00	; 0
    aa14:	b5 01       	movw	r22, r10
    aa16:	a4 01       	movw	r20, r8
    aa18:	08 2e       	mov	r0, r24
    aa1a:	04 c0       	rjmp	.+8      	; 0xaa24 <__divdi3+0x2d4>
    aa1c:	76 95       	lsr	r23
    aa1e:	67 95       	ror	r22
    aa20:	57 95       	ror	r21
    aa22:	47 95       	ror	r20
    aa24:	0a 94       	dec	r0
    aa26:	d2 f7       	brpl	.-12     	; 0xaa1c <__divdi3+0x2cc>
    aa28:	fa 01       	movw	r30, r20
    aa2a:	e6 5d       	subi	r30, 0xD6	; 214
    aa2c:	ff 4d       	sbci	r31, 0xDF	; 223
    aa2e:	20 81       	ld	r18, Z
    aa30:	40 e2       	ldi	r20, 0x20	; 32
    aa32:	50 e0       	ldi	r21, 0x00	; 0
    aa34:	60 e0       	ldi	r22, 0x00	; 0
    aa36:	70 e0       	ldi	r23, 0x00	; 0
    aa38:	48 1b       	sub	r20, r24
    aa3a:	59 0b       	sbc	r21, r25
    aa3c:	6a 0b       	sbc	r22, r26
    aa3e:	7b 0b       	sbc	r23, r27
    aa40:	42 1b       	sub	r20, r18
    aa42:	51 09       	sbc	r21, r1
    aa44:	61 09       	sbc	r22, r1
    aa46:	71 09       	sbc	r23, r1
    aa48:	41 15       	cp	r20, r1
    aa4a:	51 05       	cpc	r21, r1
    aa4c:	61 05       	cpc	r22, r1
    aa4e:	71 05       	cpc	r23, r1
    aa50:	a1 f1       	breq	.+104    	; 0xaaba <__divdi3+0x36a>
    aa52:	04 2e       	mov	r0, r20
    aa54:	04 c0       	rjmp	.+8      	; 0xaa5e <__divdi3+0x30e>
    aa56:	88 0c       	add	r8, r8
    aa58:	99 1c       	adc	r9, r9
    aa5a:	aa 1c       	adc	r10, r10
    aa5c:	bb 1c       	adc	r11, r11
    aa5e:	0a 94       	dec	r0
    aa60:	d2 f7       	brpl	.-12     	; 0xaa56 <__divdi3+0x306>
    aa62:	97 01       	movw	r18, r14
    aa64:	86 01       	movw	r16, r12
    aa66:	04 2e       	mov	r0, r20
    aa68:	04 c0       	rjmp	.+8      	; 0xaa72 <__divdi3+0x322>
    aa6a:	00 0f       	add	r16, r16
    aa6c:	11 1f       	adc	r17, r17
    aa6e:	22 1f       	adc	r18, r18
    aa70:	33 1f       	adc	r19, r19
    aa72:	0a 94       	dec	r0
    aa74:	d2 f7       	brpl	.-12     	; 0xaa6a <__divdi3+0x31a>
    aa76:	80 e2       	ldi	r24, 0x20	; 32
    aa78:	90 e0       	ldi	r25, 0x00	; 0
    aa7a:	84 1b       	sub	r24, r20
    aa7c:	95 0b       	sbc	r25, r21
    aa7e:	cd a8       	sts	0x8d, r28
    aa80:	de a8       	sts	0x8e, r29
    aa82:	ef a8       	sts	0x8f, r30
    aa84:	f8 ac       	sts	0xa8, r31
    aa86:	04 c0       	rjmp	.+8      	; 0xaa90 <__divdi3+0x340>
    aa88:	f6 94       	lsr	r15
    aa8a:	e7 94       	ror	r14
    aa8c:	d7 94       	ror	r13
    aa8e:	c7 94       	ror	r12
    aa90:	8a 95       	dec	r24
    aa92:	d2 f7       	brpl	.-12     	; 0xaa88 <__divdi3+0x338>
    aa94:	c0 2a       	or	r12, r16
    aa96:	d1 2a       	or	r13, r17
    aa98:	e2 2a       	or	r14, r18
    aa9a:	f3 2a       	or	r15, r19
    aa9c:	0d a9       	sts	0x4d, r16
    aa9e:	1e a9       	sts	0x4e, r17
    aaa0:	2f a9       	sts	0x4f, r18
    aaa2:	38 ad       	sts	0x68, r19
    aaa4:	04 c0       	rjmp	.+8      	; 0xaaae <__divdi3+0x35e>
    aaa6:	00 0f       	add	r16, r16
    aaa8:	11 1f       	adc	r17, r17
    aaaa:	22 1f       	adc	r18, r18
    aaac:	33 1f       	adc	r19, r19
    aaae:	4a 95       	dec	r20
    aab0:	d2 f7       	brpl	.-12     	; 0xaaa6 <__divdi3+0x356>
    aab2:	0d ab       	sts	0x5d, r16
    aab4:	1e ab       	sts	0x5e, r17
    aab6:	2f ab       	sts	0x5f, r18
    aab8:	38 af       	sts	0x78, r19
    aaba:	25 01       	movw	r4, r10
    aabc:	66 24       	eor	r6, r6
    aabe:	77 24       	eor	r7, r7
    aac0:	95 01       	movw	r18, r10
    aac2:	84 01       	movw	r16, r8
    aac4:	20 70       	andi	r18, 0x00	; 0
    aac6:	30 70       	andi	r19, 0x00	; 0
    aac8:	09 ab       	sts	0x59, r16
    aaca:	1a ab       	sts	0x5a, r17
    aacc:	2b ab       	sts	0x5b, r18
    aace:	3c ab       	sts	0x5c, r19
    aad0:	c7 01       	movw	r24, r14
    aad2:	b6 01       	movw	r22, r12
    aad4:	a3 01       	movw	r20, r6
    aad6:	92 01       	movw	r18, r4
    aad8:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    aadc:	2d a7       	lds	r18, 0x7d
    aade:	3e a7       	lds	r19, 0x7e
    aae0:	4f a7       	lds	r20, 0x7f
    aae2:	58 ab       	sts	0x58, r21
    aae4:	69 a7       	lds	r22, 0x79
    aae6:	7a a7       	lds	r23, 0x7a
    aae8:	8b a7       	lds	r24, 0x7b
    aaea:	9c a7       	lds	r25, 0x7c
    aaec:	c7 01       	movw	r24, r14
    aaee:	b6 01       	movw	r22, r12
    aaf0:	a3 01       	movw	r20, r6
    aaf2:	92 01       	movw	r18, r4
    aaf4:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    aaf8:	ca 01       	movw	r24, r20
    aafa:	b9 01       	movw	r22, r18
    aafc:	29 a9       	sts	0x49, r18
    aafe:	3a a9       	sts	0x4a, r19
    ab00:	4b a9       	sts	0x4b, r20
    ab02:	5c a9       	sts	0x4c, r21
    ab04:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    ab08:	ab 01       	movw	r20, r22
    ab0a:	bc 01       	movw	r22, r24
    ab0c:	09 a5       	lds	r16, 0x69
    ab0e:	1a a5       	lds	r17, 0x6a
    ab10:	2b a5       	lds	r18, 0x6b
    ab12:	3c a5       	lds	r19, 0x6c
    ab14:	78 01       	movw	r14, r16
    ab16:	dd 24       	eor	r13, r13
    ab18:	cc 24       	eor	r12, r12
    ab1a:	0d a9       	sts	0x4d, r16
    ab1c:	1e a9       	sts	0x4e, r17
    ab1e:	2f a9       	sts	0x4f, r18
    ab20:	38 ad       	sts	0x68, r19
    ab22:	c9 01       	movw	r24, r18
    ab24:	aa 27       	eor	r26, r26
    ab26:	bb 27       	eor	r27, r27
    ab28:	c8 2a       	or	r12, r24
    ab2a:	d9 2a       	or	r13, r25
    ab2c:	ea 2a       	or	r14, r26
    ab2e:	fb 2a       	or	r15, r27
    ab30:	0d a5       	lds	r16, 0x6d
    ab32:	1e a5       	lds	r17, 0x6e
    ab34:	2f a5       	lds	r18, 0x6f
    ab36:	38 a9       	sts	0x48, r19
    ab38:	c4 16       	cp	r12, r20
    ab3a:	d5 06       	cpc	r13, r21
    ab3c:	e6 06       	cpc	r14, r22
    ab3e:	f7 06       	cpc	r15, r23
    ab40:	38 f5       	brcc	.+78     	; 0xab90 <__divdi3+0x440>
    ab42:	01 50       	subi	r16, 0x01	; 1
    ab44:	10 40       	sbci	r17, 0x00	; 0
    ab46:	20 40       	sbci	r18, 0x00	; 0
    ab48:	30 40       	sbci	r19, 0x00	; 0
    ab4a:	09 a7       	lds	r16, 0x79
    ab4c:	1a a7       	lds	r17, 0x7a
    ab4e:	2b a7       	lds	r18, 0x7b
    ab50:	3c a7       	lds	r19, 0x7c
    ab52:	c8 0c       	add	r12, r8
    ab54:	d9 1c       	adc	r13, r9
    ab56:	ea 1c       	adc	r14, r10
    ab58:	fb 1c       	adc	r15, r11
    ab5a:	c8 14       	cp	r12, r8
    ab5c:	d9 04       	cpc	r13, r9
    ab5e:	ea 04       	cpc	r14, r10
    ab60:	fb 04       	cpc	r15, r11
    ab62:	d0 f0       	brcs	.+52     	; 0xab98 <__divdi3+0x448>
    ab64:	c4 16       	cp	r12, r20
    ab66:	d5 06       	cpc	r13, r21
    ab68:	e6 06       	cpc	r14, r22
    ab6a:	f7 06       	cpc	r15, r23
    ab6c:	a8 f4       	brcc	.+42     	; 0xab98 <__divdi3+0x448>
    ab6e:	0d a5       	lds	r16, 0x6d
    ab70:	1e a5       	lds	r17, 0x6e
    ab72:	2f a5       	lds	r18, 0x6f
    ab74:	38 a9       	sts	0x48, r19
    ab76:	02 50       	subi	r16, 0x02	; 2
    ab78:	10 40       	sbci	r17, 0x00	; 0
    ab7a:	20 40       	sbci	r18, 0x00	; 0
    ab7c:	30 40       	sbci	r19, 0x00	; 0
    ab7e:	09 a7       	lds	r16, 0x79
    ab80:	1a a7       	lds	r17, 0x7a
    ab82:	2b a7       	lds	r18, 0x7b
    ab84:	3c a7       	lds	r19, 0x7c
    ab86:	c8 0c       	add	r12, r8
    ab88:	d9 1c       	adc	r13, r9
    ab8a:	ea 1c       	adc	r14, r10
    ab8c:	fb 1c       	adc	r15, r11
    ab8e:	04 c0       	rjmp	.+8      	; 0xab98 <__divdi3+0x448>
    ab90:	09 a7       	lds	r16, 0x79
    ab92:	1a a7       	lds	r17, 0x7a
    ab94:	2b a7       	lds	r18, 0x7b
    ab96:	3c a7       	lds	r19, 0x7c
    ab98:	c4 1a       	sub	r12, r20
    ab9a:	d5 0a       	sbc	r13, r21
    ab9c:	e6 0a       	sbc	r14, r22
    ab9e:	f7 0a       	sbc	r15, r23
    aba0:	c7 01       	movw	r24, r14
    aba2:	b6 01       	movw	r22, r12
    aba4:	a3 01       	movw	r20, r6
    aba6:	92 01       	movw	r18, r4
    aba8:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    abac:	2d a7       	lds	r18, 0x7d
    abae:	3e a7       	lds	r19, 0x7e
    abb0:	4f a7       	lds	r20, 0x7f
    abb2:	58 ab       	sts	0x58, r21
    abb4:	69 af       	sts	0x79, r22
    abb6:	7a af       	sts	0x7a, r23
    abb8:	8b af       	sts	0x7b, r24
    abba:	9c af       	sts	0x7c, r25
    abbc:	c7 01       	movw	r24, r14
    abbe:	b6 01       	movw	r22, r12
    abc0:	a3 01       	movw	r20, r6
    abc2:	92 01       	movw	r18, r4
    abc4:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    abc8:	ca 01       	movw	r24, r20
    abca:	b9 01       	movw	r22, r18
    abcc:	29 a9       	sts	0x49, r18
    abce:	3a a9       	sts	0x4a, r19
    abd0:	4b a9       	sts	0x4b, r20
    abd2:	5c a9       	sts	0x4c, r21
    abd4:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    abd8:	6b 01       	movw	r12, r22
    abda:	7c 01       	movw	r14, r24
    abdc:	49 ad       	sts	0x69, r20
    abde:	5a ad       	sts	0x6a, r21
    abe0:	6b ad       	sts	0x6b, r22
    abe2:	7c ad       	sts	0x6c, r23
    abe4:	9a 01       	movw	r18, r20
    abe6:	11 27       	eor	r17, r17
    abe8:	00 27       	eor	r16, r16
    abea:	4d a9       	sts	0x4d, r20
    abec:	5e a9       	sts	0x4e, r21
    abee:	6f a9       	sts	0x4f, r22
    abf0:	78 ad       	sts	0x68, r23
    abf2:	60 70       	andi	r22, 0x00	; 0
    abf4:	70 70       	andi	r23, 0x00	; 0
    abf6:	04 2b       	or	r16, r20
    abf8:	15 2b       	or	r17, r21
    abfa:	26 2b       	or	r18, r22
    abfc:	37 2b       	or	r19, r23
    abfe:	8d a5       	lds	r24, 0x6d
    ac00:	9e a5       	lds	r25, 0x6e
    ac02:	af a5       	lds	r26, 0x6f
    ac04:	b8 a9       	sts	0x48, r27
    ac06:	0c 15       	cp	r16, r12
    ac08:	1d 05       	cpc	r17, r13
    ac0a:	2e 05       	cpc	r18, r14
    ac0c:	3f 05       	cpc	r19, r15
    ac0e:	c0 f4       	brcc	.+48     	; 0xac40 <__divdi3+0x4f0>
    ac10:	01 97       	sbiw	r24, 0x01	; 1
    ac12:	a1 09       	sbc	r26, r1
    ac14:	b1 09       	sbc	r27, r1
    ac16:	08 0d       	add	r16, r8
    ac18:	19 1d       	adc	r17, r9
    ac1a:	2a 1d       	adc	r18, r10
    ac1c:	3b 1d       	adc	r19, r11
    ac1e:	08 15       	cp	r16, r8
    ac20:	19 05       	cpc	r17, r9
    ac22:	2a 05       	cpc	r18, r10
    ac24:	3b 05       	cpc	r19, r11
    ac26:	60 f0       	brcs	.+24     	; 0xac40 <__divdi3+0x4f0>
    ac28:	0c 15       	cp	r16, r12
    ac2a:	1d 05       	cpc	r17, r13
    ac2c:	2e 05       	cpc	r18, r14
    ac2e:	3f 05       	cpc	r19, r15
    ac30:	38 f4       	brcc	.+14     	; 0xac40 <__divdi3+0x4f0>
    ac32:	8d a5       	lds	r24, 0x6d
    ac34:	9e a5       	lds	r25, 0x6e
    ac36:	af a5       	lds	r26, 0x6f
    ac38:	b8 a9       	sts	0x48, r27
    ac3a:	02 97       	sbiw	r24, 0x02	; 2
    ac3c:	a1 09       	sbc	r26, r1
    ac3e:	b1 09       	sbc	r27, r1
    ac40:	09 a5       	lds	r16, 0x69
    ac42:	1a a5       	lds	r17, 0x6a
    ac44:	2b a5       	lds	r18, 0x6b
    ac46:	3c a5       	lds	r19, 0x6c
    ac48:	78 01       	movw	r14, r16
    ac4a:	dd 24       	eor	r13, r13
    ac4c:	cc 24       	eor	r12, r12
    ac4e:	c8 2a       	or	r12, r24
    ac50:	d9 2a       	or	r13, r25
    ac52:	ea 2a       	or	r14, r26
    ac54:	fb 2a       	or	r15, r27
    ac56:	b7 c4       	rjmp	.+2414   	; 0xb5c6 <__divdi3+0xe76>
    ac58:	81 14       	cp	r8, r1
    ac5a:	91 04       	cpc	r9, r1
    ac5c:	a1 04       	cpc	r10, r1
    ac5e:	b1 04       	cpc	r11, r1
    ac60:	51 f4       	brne	.+20     	; 0xac76 <__divdi3+0x526>
    ac62:	61 e0       	ldi	r22, 0x01	; 1
    ac64:	70 e0       	ldi	r23, 0x00	; 0
    ac66:	80 e0       	ldi	r24, 0x00	; 0
    ac68:	90 e0       	ldi	r25, 0x00	; 0
    ac6a:	a5 01       	movw	r20, r10
    ac6c:	94 01       	movw	r18, r8
    ac6e:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    ac72:	49 01       	movw	r8, r18
    ac74:	5a 01       	movw	r10, r20
    ac76:	10 e0       	ldi	r17, 0x00	; 0
    ac78:	81 16       	cp	r8, r17
    ac7a:	10 e0       	ldi	r17, 0x00	; 0
    ac7c:	91 06       	cpc	r9, r17
    ac7e:	11 e0       	ldi	r17, 0x01	; 1
    ac80:	a1 06       	cpc	r10, r17
    ac82:	10 e0       	ldi	r17, 0x00	; 0
    ac84:	b1 06       	cpc	r11, r17
    ac86:	58 f4       	brcc	.+22     	; 0xac9e <__divdi3+0x54e>
    ac88:	2f ef       	ldi	r18, 0xFF	; 255
    ac8a:	82 16       	cp	r8, r18
    ac8c:	91 04       	cpc	r9, r1
    ac8e:	a1 04       	cpc	r10, r1
    ac90:	b1 04       	cpc	r11, r1
    ac92:	09 f0       	breq	.+2      	; 0xac96 <__divdi3+0x546>
    ac94:	90 f4       	brcc	.+36     	; 0xacba <__divdi3+0x56a>
    ac96:	80 e0       	ldi	r24, 0x00	; 0
    ac98:	90 e0       	ldi	r25, 0x00	; 0
    ac9a:	dc 01       	movw	r26, r24
    ac9c:	17 c0       	rjmp	.+46     	; 0xaccc <__divdi3+0x57c>
    ac9e:	30 e0       	ldi	r19, 0x00	; 0
    aca0:	83 16       	cp	r8, r19
    aca2:	30 e0       	ldi	r19, 0x00	; 0
    aca4:	93 06       	cpc	r9, r19
    aca6:	30 e0       	ldi	r19, 0x00	; 0
    aca8:	a3 06       	cpc	r10, r19
    acaa:	31 e0       	ldi	r19, 0x01	; 1
    acac:	b3 06       	cpc	r11, r19
    acae:	50 f4       	brcc	.+20     	; 0xacc4 <__divdi3+0x574>
    acb0:	80 e1       	ldi	r24, 0x10	; 16
    acb2:	90 e0       	ldi	r25, 0x00	; 0
    acb4:	a0 e0       	ldi	r26, 0x00	; 0
    acb6:	b0 e0       	ldi	r27, 0x00	; 0
    acb8:	09 c0       	rjmp	.+18     	; 0xaccc <__divdi3+0x57c>
    acba:	88 e0       	ldi	r24, 0x08	; 8
    acbc:	90 e0       	ldi	r25, 0x00	; 0
    acbe:	a0 e0       	ldi	r26, 0x00	; 0
    acc0:	b0 e0       	ldi	r27, 0x00	; 0
    acc2:	04 c0       	rjmp	.+8      	; 0xaccc <__divdi3+0x57c>
    acc4:	88 e1       	ldi	r24, 0x18	; 24
    acc6:	90 e0       	ldi	r25, 0x00	; 0
    acc8:	a0 e0       	ldi	r26, 0x00	; 0
    acca:	b0 e0       	ldi	r27, 0x00	; 0
    accc:	b5 01       	movw	r22, r10
    acce:	a4 01       	movw	r20, r8
    acd0:	08 2e       	mov	r0, r24
    acd2:	04 c0       	rjmp	.+8      	; 0xacdc <__divdi3+0x58c>
    acd4:	76 95       	lsr	r23
    acd6:	67 95       	ror	r22
    acd8:	57 95       	ror	r21
    acda:	47 95       	ror	r20
    acdc:	0a 94       	dec	r0
    acde:	d2 f7       	brpl	.-12     	; 0xacd4 <__divdi3+0x584>
    ace0:	fa 01       	movw	r30, r20
    ace2:	e6 5d       	subi	r30, 0xD6	; 214
    ace4:	ff 4d       	sbci	r31, 0xDF	; 223
    ace6:	20 81       	ld	r18, Z
    ace8:	ac 01       	movw	r20, r24
    acea:	bd 01       	movw	r22, r26
    acec:	42 0f       	add	r20, r18
    acee:	51 1d       	adc	r21, r1
    acf0:	61 1d       	adc	r22, r1
    acf2:	71 1d       	adc	r23, r1
    acf4:	80 e2       	ldi	r24, 0x20	; 32
    acf6:	90 e0       	ldi	r25, 0x00	; 0
    acf8:	a0 e0       	ldi	r26, 0x00	; 0
    acfa:	b0 e0       	ldi	r27, 0x00	; 0
    acfc:	84 1b       	sub	r24, r20
    acfe:	95 0b       	sbc	r25, r21
    ad00:	a6 0b       	sbc	r26, r22
    ad02:	b7 0b       	sbc	r27, r23
    ad04:	51 f4       	brne	.+20     	; 0xad1a <__divdi3+0x5ca>
    ad06:	c8 18       	sub	r12, r8
    ad08:	d9 08       	sbc	r13, r9
    ad0a:	ea 08       	sbc	r14, r10
    ad0c:	fb 08       	sbc	r15, r11
    ad0e:	f1 e0       	ldi	r31, 0x01	; 1
    ad10:	4f 2e       	mov	r4, r31
    ad12:	51 2c       	mov	r5, r1
    ad14:	61 2c       	mov	r6, r1
    ad16:	71 2c       	mov	r7, r1
    ad18:	28 c1       	rjmp	.+592    	; 0xaf6a <__divdi3+0x81a>
    ad1a:	08 2e       	mov	r0, r24
    ad1c:	04 c0       	rjmp	.+8      	; 0xad26 <__divdi3+0x5d6>
    ad1e:	88 0c       	add	r8, r8
    ad20:	99 1c       	adc	r9, r9
    ad22:	aa 1c       	adc	r10, r10
    ad24:	bb 1c       	adc	r11, r11
    ad26:	0a 94       	dec	r0
    ad28:	d2 f7       	brpl	.-12     	; 0xad1e <__divdi3+0x5ce>
    ad2a:	97 01       	movw	r18, r14
    ad2c:	86 01       	movw	r16, r12
    ad2e:	04 2e       	mov	r0, r20
    ad30:	04 c0       	rjmp	.+8      	; 0xad3a <__divdi3+0x5ea>
    ad32:	36 95       	lsr	r19
    ad34:	27 95       	ror	r18
    ad36:	17 95       	ror	r17
    ad38:	07 95       	ror	r16
    ad3a:	0a 94       	dec	r0
    ad3c:	d2 f7       	brpl	.-12     	; 0xad32 <__divdi3+0x5e2>
    ad3e:	09 ab       	sts	0x59, r16
    ad40:	1a ab       	sts	0x5a, r17
    ad42:	2b ab       	sts	0x5b, r18
    ad44:	3c ab       	sts	0x5c, r19
    ad46:	97 01       	movw	r18, r14
    ad48:	86 01       	movw	r16, r12
    ad4a:	08 2e       	mov	r0, r24
    ad4c:	04 c0       	rjmp	.+8      	; 0xad56 <__divdi3+0x606>
    ad4e:	00 0f       	add	r16, r16
    ad50:	11 1f       	adc	r17, r17
    ad52:	22 1f       	adc	r18, r18
    ad54:	33 1f       	adc	r19, r19
    ad56:	0a 94       	dec	r0
    ad58:	d2 f7       	brpl	.-12     	; 0xad4e <__divdi3+0x5fe>
    ad5a:	0d a7       	lds	r16, 0x7d
    ad5c:	1e a7       	lds	r17, 0x7e
    ad5e:	2f a7       	lds	r18, 0x7f
    ad60:	38 ab       	sts	0x58, r19
    ad62:	ed a8       	sts	0x8d, r30
    ad64:	fe a8       	sts	0x8e, r31
    ad66:	0f a9       	sts	0x4f, r16
    ad68:	18 ad       	sts	0x68, r17
    ad6a:	04 c0       	rjmp	.+8      	; 0xad74 <__divdi3+0x624>
    ad6c:	16 95       	lsr	r17
    ad6e:	07 95       	ror	r16
    ad70:	f7 94       	ror	r15
    ad72:	e7 94       	ror	r14
    ad74:	4a 95       	dec	r20
    ad76:	d2 f7       	brpl	.-12     	; 0xad6c <__divdi3+0x61c>
    ad78:	b8 01       	movw	r22, r16
    ad7a:	a7 01       	movw	r20, r14
    ad7c:	0d a5       	lds	r16, 0x6d
    ad7e:	1e a5       	lds	r17, 0x6e
    ad80:	2f a5       	lds	r18, 0x6f
    ad82:	38 a9       	sts	0x48, r19
    ad84:	04 2b       	or	r16, r20
    ad86:	15 2b       	or	r17, r21
    ad88:	26 2b       	or	r18, r22
    ad8a:	37 2b       	or	r19, r23
    ad8c:	0d a7       	lds	r16, 0x7d
    ad8e:	1e a7       	lds	r17, 0x7e
    ad90:	2f a7       	lds	r18, 0x7f
    ad92:	38 ab       	sts	0x58, r19
    ad94:	ed a8       	sts	0x8d, r30
    ad96:	fe a8       	sts	0x8e, r31
    ad98:	0f a9       	sts	0x4f, r16
    ad9a:	18 ad       	sts	0x68, r17
    ad9c:	04 c0       	rjmp	.+8      	; 0xada6 <__divdi3+0x656>
    ad9e:	ee 0c       	add	r14, r14
    ada0:	ff 1c       	adc	r15, r15
    ada2:	00 1f       	adc	r16, r16
    ada4:	11 1f       	adc	r17, r17
    ada6:	8a 95       	dec	r24
    ada8:	d2 f7       	brpl	.-12     	; 0xad9e <__divdi3+0x64e>
    adaa:	ed aa       	sts	0x9d, r30
    adac:	fe aa       	sts	0x9e, r31
    adae:	0f ab       	sts	0x5f, r16
    adb0:	18 af       	sts	0x78, r17
    adb2:	25 01       	movw	r4, r10
    adb4:	66 24       	eor	r6, r6
    adb6:	77 24       	eor	r7, r7
    adb8:	95 01       	movw	r18, r10
    adba:	84 01       	movw	r16, r8
    adbc:	20 70       	andi	r18, 0x00	; 0
    adbe:	30 70       	andi	r19, 0x00	; 0
    adc0:	09 af       	sts	0x79, r16
    adc2:	1a af       	sts	0x7a, r17
    adc4:	2b af       	sts	0x7b, r18
    adc6:	3c af       	sts	0x7c, r19
    adc8:	69 a9       	sts	0x49, r22
    adca:	7a a9       	sts	0x4a, r23
    adcc:	8b a9       	sts	0x4b, r24
    adce:	9c a9       	sts	0x4c, r25
    add0:	a3 01       	movw	r20, r6
    add2:	92 01       	movw	r18, r4
    add4:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    add8:	29 a7       	lds	r18, 0x79
    adda:	3a a7       	lds	r19, 0x7a
    addc:	4b a7       	lds	r20, 0x7b
    adde:	5c a7       	lds	r21, 0x7c
    ade0:	6b 01       	movw	r12, r22
    ade2:	7c 01       	movw	r14, r24
    ade4:	69 a9       	sts	0x49, r22
    ade6:	7a a9       	sts	0x4a, r23
    ade8:	8b a9       	sts	0x4b, r24
    adea:	9c a9       	sts	0x4c, r25
    adec:	a3 01       	movw	r20, r6
    adee:	92 01       	movw	r18, r4
    adf0:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    adf4:	ca 01       	movw	r24, r20
    adf6:	b9 01       	movw	r22, r18
    adf8:	29 ad       	sts	0x69, r18
    adfa:	3a ad       	sts	0x6a, r19
    adfc:	4b ad       	sts	0x6b, r20
    adfe:	5c ad       	sts	0x6c, r21
    ae00:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    ae04:	ab 01       	movw	r20, r22
    ae06:	bc 01       	movw	r22, r24
    ae08:	76 01       	movw	r14, r12
    ae0a:	dd 24       	eor	r13, r13
    ae0c:	cc 24       	eor	r12, r12
    ae0e:	0d a5       	lds	r16, 0x6d
    ae10:	1e a5       	lds	r17, 0x6e
    ae12:	2f a5       	lds	r18, 0x6f
    ae14:	38 a9       	sts	0x48, r19
    ae16:	c9 01       	movw	r24, r18
    ae18:	aa 27       	eor	r26, r26
    ae1a:	bb 27       	eor	r27, r27
    ae1c:	c8 2a       	or	r12, r24
    ae1e:	d9 2a       	or	r13, r25
    ae20:	ea 2a       	or	r14, r26
    ae22:	fb 2a       	or	r15, r27
    ae24:	09 a5       	lds	r16, 0x69
    ae26:	1a a5       	lds	r17, 0x6a
    ae28:	2b a5       	lds	r18, 0x6b
    ae2a:	3c a5       	lds	r19, 0x6c
    ae2c:	c4 16       	cp	r12, r20
    ae2e:	d5 06       	cpc	r13, r21
    ae30:	e6 06       	cpc	r14, r22
    ae32:	f7 06       	cpc	r15, r23
    ae34:	38 f5       	brcc	.+78     	; 0xae84 <__divdi3+0x734>
    ae36:	01 50       	subi	r16, 0x01	; 1
    ae38:	10 40       	sbci	r17, 0x00	; 0
    ae3a:	20 40       	sbci	r18, 0x00	; 0
    ae3c:	30 40       	sbci	r19, 0x00	; 0
    ae3e:	09 ab       	sts	0x59, r16
    ae40:	1a ab       	sts	0x5a, r17
    ae42:	2b ab       	sts	0x5b, r18
    ae44:	3c ab       	sts	0x5c, r19
    ae46:	c8 0c       	add	r12, r8
    ae48:	d9 1c       	adc	r13, r9
    ae4a:	ea 1c       	adc	r14, r10
    ae4c:	fb 1c       	adc	r15, r11
    ae4e:	c8 14       	cp	r12, r8
    ae50:	d9 04       	cpc	r13, r9
    ae52:	ea 04       	cpc	r14, r10
    ae54:	fb 04       	cpc	r15, r11
    ae56:	d0 f0       	brcs	.+52     	; 0xae8c <__divdi3+0x73c>
    ae58:	c4 16       	cp	r12, r20
    ae5a:	d5 06       	cpc	r13, r21
    ae5c:	e6 06       	cpc	r14, r22
    ae5e:	f7 06       	cpc	r15, r23
    ae60:	a8 f4       	brcc	.+42     	; 0xae8c <__divdi3+0x73c>
    ae62:	09 a5       	lds	r16, 0x69
    ae64:	1a a5       	lds	r17, 0x6a
    ae66:	2b a5       	lds	r18, 0x6b
    ae68:	3c a5       	lds	r19, 0x6c
    ae6a:	02 50       	subi	r16, 0x02	; 2
    ae6c:	10 40       	sbci	r17, 0x00	; 0
    ae6e:	20 40       	sbci	r18, 0x00	; 0
    ae70:	30 40       	sbci	r19, 0x00	; 0
    ae72:	09 ab       	sts	0x59, r16
    ae74:	1a ab       	sts	0x5a, r17
    ae76:	2b ab       	sts	0x5b, r18
    ae78:	3c ab       	sts	0x5c, r19
    ae7a:	c8 0c       	add	r12, r8
    ae7c:	d9 1c       	adc	r13, r9
    ae7e:	ea 1c       	adc	r14, r10
    ae80:	fb 1c       	adc	r15, r11
    ae82:	04 c0       	rjmp	.+8      	; 0xae8c <__divdi3+0x73c>
    ae84:	09 ab       	sts	0x59, r16
    ae86:	1a ab       	sts	0x5a, r17
    ae88:	2b ab       	sts	0x5b, r18
    ae8a:	3c ab       	sts	0x5c, r19
    ae8c:	c4 1a       	sub	r12, r20
    ae8e:	d5 0a       	sbc	r13, r21
    ae90:	e6 0a       	sbc	r14, r22
    ae92:	f7 0a       	sbc	r15, r23
    ae94:	c7 01       	movw	r24, r14
    ae96:	b6 01       	movw	r22, r12
    ae98:	a3 01       	movw	r20, r6
    ae9a:	92 01       	movw	r18, r4
    ae9c:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    aea0:	29 a7       	lds	r18, 0x79
    aea2:	3a a7       	lds	r19, 0x7a
    aea4:	4b a7       	lds	r20, 0x7b
    aea6:	5c a7       	lds	r21, 0x7c
    aea8:	21 96       	adiw	r28, 0x01	; 1
    aeaa:	6c af       	sts	0x7c, r22
    aeac:	7d af       	sts	0x7d, r23
    aeae:	8e af       	sts	0x7e, r24
    aeb0:	9f af       	sts	0x7f, r25
    aeb2:	21 97       	sbiw	r28, 0x01	; 1
    aeb4:	c7 01       	movw	r24, r14
    aeb6:	b6 01       	movw	r22, r12
    aeb8:	a3 01       	movw	r20, r6
    aeba:	92 01       	movw	r18, r4
    aebc:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    aec0:	ca 01       	movw	r24, r20
    aec2:	b9 01       	movw	r22, r18
    aec4:	29 ad       	sts	0x69, r18
    aec6:	3a ad       	sts	0x6a, r19
    aec8:	4b ad       	sts	0x6b, r20
    aeca:	5c ad       	sts	0x6c, r21
    aecc:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    aed0:	8b 01       	movw	r16, r22
    aed2:	9c 01       	movw	r18, r24
    aed4:	21 96       	adiw	r28, 0x01	; 1
    aed6:	4c ad       	sts	0x6c, r20
    aed8:	5d ad       	sts	0x6d, r21
    aeda:	6e ad       	sts	0x6e, r22
    aedc:	7f ad       	sts	0x6f, r23
    aede:	21 97       	sbiw	r28, 0x01	; 1
    aee0:	da 01       	movw	r26, r20
    aee2:	99 27       	eor	r25, r25
    aee4:	88 27       	eor	r24, r24
    aee6:	4d a5       	lds	r20, 0x6d
    aee8:	5e a5       	lds	r21, 0x6e
    aeea:	6f a5       	lds	r22, 0x6f
    aeec:	78 a9       	sts	0x48, r23
    aeee:	60 70       	andi	r22, 0x00	; 0
    aef0:	70 70       	andi	r23, 0x00	; 0
    aef2:	84 2b       	or	r24, r20
    aef4:	95 2b       	or	r25, r21
    aef6:	a6 2b       	or	r26, r22
    aef8:	b7 2b       	or	r27, r23
    aefa:	49 a5       	lds	r20, 0x69
    aefc:	5a a5       	lds	r21, 0x6a
    aefe:	6b a5       	lds	r22, 0x6b
    af00:	7c a5       	lds	r23, 0x6c
    af02:	80 17       	cp	r24, r16
    af04:	91 07       	cpc	r25, r17
    af06:	a2 07       	cpc	r26, r18
    af08:	b3 07       	cpc	r27, r19
    af0a:	f0 f4       	brcc	.+60     	; 0xaf48 <__divdi3+0x7f8>
    af0c:	41 50       	subi	r20, 0x01	; 1
    af0e:	50 40       	sbci	r21, 0x00	; 0
    af10:	60 40       	sbci	r22, 0x00	; 0
    af12:	70 40       	sbci	r23, 0x00	; 0
    af14:	88 0d       	add	r24, r8
    af16:	99 1d       	adc	r25, r9
    af18:	aa 1d       	adc	r26, r10
    af1a:	bb 1d       	adc	r27, r11
    af1c:	88 15       	cp	r24, r8
    af1e:	99 05       	cpc	r25, r9
    af20:	aa 05       	cpc	r26, r10
    af22:	bb 05       	cpc	r27, r11
    af24:	88 f0       	brcs	.+34     	; 0xaf48 <__divdi3+0x7f8>
    af26:	80 17       	cp	r24, r16
    af28:	91 07       	cpc	r25, r17
    af2a:	a2 07       	cpc	r26, r18
    af2c:	b3 07       	cpc	r27, r19
    af2e:	60 f4       	brcc	.+24     	; 0xaf48 <__divdi3+0x7f8>
    af30:	49 a5       	lds	r20, 0x69
    af32:	5a a5       	lds	r21, 0x6a
    af34:	6b a5       	lds	r22, 0x6b
    af36:	7c a5       	lds	r23, 0x6c
    af38:	42 50       	subi	r20, 0x02	; 2
    af3a:	50 40       	sbci	r21, 0x00	; 0
    af3c:	60 40       	sbci	r22, 0x00	; 0
    af3e:	70 40       	sbci	r23, 0x00	; 0
    af40:	88 0d       	add	r24, r8
    af42:	99 1d       	adc	r25, r9
    af44:	aa 1d       	adc	r26, r10
    af46:	bb 1d       	adc	r27, r11
    af48:	6c 01       	movw	r12, r24
    af4a:	7d 01       	movw	r14, r26
    af4c:	c0 1a       	sub	r12, r16
    af4e:	d1 0a       	sbc	r13, r17
    af50:	e2 0a       	sbc	r14, r18
    af52:	f3 0a       	sbc	r15, r19
    af54:	09 a9       	sts	0x49, r16
    af56:	1a a9       	sts	0x4a, r17
    af58:	2b a9       	sts	0x4b, r18
    af5a:	3c a9       	sts	0x4c, r19
    af5c:	38 01       	movw	r6, r16
    af5e:	55 24       	eor	r5, r5
    af60:	44 24       	eor	r4, r4
    af62:	44 2a       	or	r4, r20
    af64:	55 2a       	or	r5, r21
    af66:	66 2a       	or	r6, r22
    af68:	77 2a       	or	r7, r23
    af6a:	85 01       	movw	r16, r10
    af6c:	22 27       	eor	r18, r18
    af6e:	33 27       	eor	r19, r19
    af70:	0d a7       	lds	r16, 0x7d
    af72:	1e a7       	lds	r17, 0x7e
    af74:	2f a7       	lds	r18, 0x7f
    af76:	38 ab       	sts	0x58, r19
    af78:	95 01       	movw	r18, r10
    af7a:	84 01       	movw	r16, r8
    af7c:	20 70       	andi	r18, 0x00	; 0
    af7e:	30 70       	andi	r19, 0x00	; 0
    af80:	09 af       	sts	0x79, r16
    af82:	1a af       	sts	0x7a, r17
    af84:	2b af       	sts	0x7b, r18
    af86:	3c af       	sts	0x7c, r19
    af88:	c7 01       	movw	r24, r14
    af8a:	b6 01       	movw	r22, r12
    af8c:	2d a5       	lds	r18, 0x6d
    af8e:	3e a5       	lds	r19, 0x6e
    af90:	4f a5       	lds	r20, 0x6f
    af92:	58 a9       	sts	0x48, r21
    af94:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    af98:	29 a7       	lds	r18, 0x79
    af9a:	3a a7       	lds	r19, 0x7a
    af9c:	4b a7       	lds	r20, 0x7b
    af9e:	5c a7       	lds	r21, 0x7c
    afa0:	69 ab       	sts	0x59, r22
    afa2:	7a ab       	sts	0x5a, r23
    afa4:	8b ab       	sts	0x5b, r24
    afa6:	9c ab       	sts	0x5c, r25
    afa8:	c7 01       	movw	r24, r14
    afaa:	b6 01       	movw	r22, r12
    afac:	2d a5       	lds	r18, 0x6d
    afae:	3e a5       	lds	r19, 0x6e
    afb0:	4f a5       	lds	r20, 0x6f
    afb2:	58 a9       	sts	0x48, r21
    afb4:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    afb8:	ca 01       	movw	r24, r20
    afba:	b9 01       	movw	r22, r18
    afbc:	29 ad       	sts	0x69, r18
    afbe:	3a ad       	sts	0x6a, r19
    afc0:	4b ad       	sts	0x6b, r20
    afc2:	5c ad       	sts	0x6c, r21
    afc4:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    afc8:	ab 01       	movw	r20, r22
    afca:	bc 01       	movw	r22, r24
    afcc:	09 a9       	sts	0x49, r16
    afce:	1a a9       	sts	0x4a, r17
    afd0:	2b a9       	sts	0x4b, r18
    afd2:	3c a9       	sts	0x4c, r19
    afd4:	78 01       	movw	r14, r16
    afd6:	dd 24       	eor	r13, r13
    afd8:	cc 24       	eor	r12, r12
    afda:	0d a9       	sts	0x4d, r16
    afdc:	1e a9       	sts	0x4e, r17
    afde:	2f a9       	sts	0x4f, r18
    afe0:	38 ad       	sts	0x68, r19
    afe2:	c9 01       	movw	r24, r18
    afe4:	aa 27       	eor	r26, r26
    afe6:	bb 27       	eor	r27, r27
    afe8:	c8 2a       	or	r12, r24
    afea:	d9 2a       	or	r13, r25
    afec:	ea 2a       	or	r14, r26
    afee:	fb 2a       	or	r15, r27
    aff0:	09 a5       	lds	r16, 0x69
    aff2:	1a a5       	lds	r17, 0x6a
    aff4:	2b a5       	lds	r18, 0x6b
    aff6:	3c a5       	lds	r19, 0x6c
    aff8:	c4 16       	cp	r12, r20
    affa:	d5 06       	cpc	r13, r21
    affc:	e6 06       	cpc	r14, r22
    affe:	f7 06       	cpc	r15, r23
    b000:	38 f5       	brcc	.+78     	; 0xb050 <__divdi3+0x900>
    b002:	01 50       	subi	r16, 0x01	; 1
    b004:	10 40       	sbci	r17, 0x00	; 0
    b006:	20 40       	sbci	r18, 0x00	; 0
    b008:	30 40       	sbci	r19, 0x00	; 0
    b00a:	09 ab       	sts	0x59, r16
    b00c:	1a ab       	sts	0x5a, r17
    b00e:	2b ab       	sts	0x5b, r18
    b010:	3c ab       	sts	0x5c, r19
    b012:	c8 0c       	add	r12, r8
    b014:	d9 1c       	adc	r13, r9
    b016:	ea 1c       	adc	r14, r10
    b018:	fb 1c       	adc	r15, r11
    b01a:	c8 14       	cp	r12, r8
    b01c:	d9 04       	cpc	r13, r9
    b01e:	ea 04       	cpc	r14, r10
    b020:	fb 04       	cpc	r15, r11
    b022:	d0 f0       	brcs	.+52     	; 0xb058 <__divdi3+0x908>
    b024:	c4 16       	cp	r12, r20
    b026:	d5 06       	cpc	r13, r21
    b028:	e6 06       	cpc	r14, r22
    b02a:	f7 06       	cpc	r15, r23
    b02c:	a8 f4       	brcc	.+42     	; 0xb058 <__divdi3+0x908>
    b02e:	09 a5       	lds	r16, 0x69
    b030:	1a a5       	lds	r17, 0x6a
    b032:	2b a5       	lds	r18, 0x6b
    b034:	3c a5       	lds	r19, 0x6c
    b036:	02 50       	subi	r16, 0x02	; 2
    b038:	10 40       	sbci	r17, 0x00	; 0
    b03a:	20 40       	sbci	r18, 0x00	; 0
    b03c:	30 40       	sbci	r19, 0x00	; 0
    b03e:	09 ab       	sts	0x59, r16
    b040:	1a ab       	sts	0x5a, r17
    b042:	2b ab       	sts	0x5b, r18
    b044:	3c ab       	sts	0x5c, r19
    b046:	c8 0c       	add	r12, r8
    b048:	d9 1c       	adc	r13, r9
    b04a:	ea 1c       	adc	r14, r10
    b04c:	fb 1c       	adc	r15, r11
    b04e:	04 c0       	rjmp	.+8      	; 0xb058 <__divdi3+0x908>
    b050:	09 ab       	sts	0x59, r16
    b052:	1a ab       	sts	0x5a, r17
    b054:	2b ab       	sts	0x5b, r18
    b056:	3c ab       	sts	0x5c, r19
    b058:	c4 1a       	sub	r12, r20
    b05a:	d5 0a       	sbc	r13, r21
    b05c:	e6 0a       	sbc	r14, r22
    b05e:	f7 0a       	sbc	r15, r23
    b060:	c7 01       	movw	r24, r14
    b062:	b6 01       	movw	r22, r12
    b064:	2d a5       	lds	r18, 0x6d
    b066:	3e a5       	lds	r19, 0x6e
    b068:	4f a5       	lds	r20, 0x6f
    b06a:	58 a9       	sts	0x48, r21
    b06c:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    b070:	29 a7       	lds	r18, 0x79
    b072:	3a a7       	lds	r19, 0x7a
    b074:	4b a7       	lds	r20, 0x7b
    b076:	5c a7       	lds	r21, 0x7c
    b078:	21 96       	adiw	r28, 0x01	; 1
    b07a:	6c af       	sts	0x7c, r22
    b07c:	7d af       	sts	0x7d, r23
    b07e:	8e af       	sts	0x7e, r24
    b080:	9f af       	sts	0x7f, r25
    b082:	21 97       	sbiw	r28, 0x01	; 1
    b084:	c7 01       	movw	r24, r14
    b086:	b6 01       	movw	r22, r12
    b088:	2d a5       	lds	r18, 0x6d
    b08a:	3e a5       	lds	r19, 0x6e
    b08c:	4f a5       	lds	r20, 0x6f
    b08e:	58 a9       	sts	0x48, r21
    b090:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    b094:	ca 01       	movw	r24, r20
    b096:	b9 01       	movw	r22, r18
    b098:	29 ad       	sts	0x69, r18
    b09a:	3a ad       	sts	0x6a, r19
    b09c:	4b ad       	sts	0x6b, r20
    b09e:	5c ad       	sts	0x6c, r21
    b0a0:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    b0a4:	8b 01       	movw	r16, r22
    b0a6:	9c 01       	movw	r18, r24
    b0a8:	21 96       	adiw	r28, 0x01	; 1
    b0aa:	4c ad       	sts	0x6c, r20
    b0ac:	5d ad       	sts	0x6d, r21
    b0ae:	6e ad       	sts	0x6e, r22
    b0b0:	7f ad       	sts	0x6f, r23
    b0b2:	21 97       	sbiw	r28, 0x01	; 1
    b0b4:	da 01       	movw	r26, r20
    b0b6:	99 27       	eor	r25, r25
    b0b8:	88 27       	eor	r24, r24
    b0ba:	4d a9       	sts	0x4d, r20
    b0bc:	5e a9       	sts	0x4e, r21
    b0be:	6f a9       	sts	0x4f, r22
    b0c0:	78 ad       	sts	0x68, r23
    b0c2:	60 70       	andi	r22, 0x00	; 0
    b0c4:	70 70       	andi	r23, 0x00	; 0
    b0c6:	84 2b       	or	r24, r20
    b0c8:	95 2b       	or	r25, r21
    b0ca:	a6 2b       	or	r26, r22
    b0cc:	b7 2b       	or	r27, r23
    b0ce:	49 a5       	lds	r20, 0x69
    b0d0:	5a a5       	lds	r21, 0x6a
    b0d2:	6b a5       	lds	r22, 0x6b
    b0d4:	7c a5       	lds	r23, 0x6c
    b0d6:	80 17       	cp	r24, r16
    b0d8:	91 07       	cpc	r25, r17
    b0da:	a2 07       	cpc	r26, r18
    b0dc:	b3 07       	cpc	r27, r19
    b0de:	d0 f4       	brcc	.+52     	; 0xb114 <__divdi3+0x9c4>
    b0e0:	41 50       	subi	r20, 0x01	; 1
    b0e2:	50 40       	sbci	r21, 0x00	; 0
    b0e4:	60 40       	sbci	r22, 0x00	; 0
    b0e6:	70 40       	sbci	r23, 0x00	; 0
    b0e8:	88 0d       	add	r24, r8
    b0ea:	99 1d       	adc	r25, r9
    b0ec:	aa 1d       	adc	r26, r10
    b0ee:	bb 1d       	adc	r27, r11
    b0f0:	88 15       	cp	r24, r8
    b0f2:	99 05       	cpc	r25, r9
    b0f4:	aa 05       	cpc	r26, r10
    b0f6:	bb 05       	cpc	r27, r11
    b0f8:	68 f0       	brcs	.+26     	; 0xb114 <__divdi3+0x9c4>
    b0fa:	80 17       	cp	r24, r16
    b0fc:	91 07       	cpc	r25, r17
    b0fe:	a2 07       	cpc	r26, r18
    b100:	b3 07       	cpc	r27, r19
    b102:	40 f4       	brcc	.+16     	; 0xb114 <__divdi3+0x9c4>
    b104:	49 a5       	lds	r20, 0x69
    b106:	5a a5       	lds	r21, 0x6a
    b108:	6b a5       	lds	r22, 0x6b
    b10a:	7c a5       	lds	r23, 0x6c
    b10c:	42 50       	subi	r20, 0x02	; 2
    b10e:	50 40       	sbci	r21, 0x00	; 0
    b110:	60 40       	sbci	r22, 0x00	; 0
    b112:	70 40       	sbci	r23, 0x00	; 0
    b114:	09 a9       	sts	0x49, r16
    b116:	1a a9       	sts	0x4a, r17
    b118:	2b a9       	sts	0x4b, r18
    b11a:	3c a9       	sts	0x4c, r19
    b11c:	78 01       	movw	r14, r16
    b11e:	dd 24       	eor	r13, r13
    b120:	cc 24       	eor	r12, r12
    b122:	c4 2a       	or	r12, r20
    b124:	d5 2a       	or	r13, r21
    b126:	e6 2a       	or	r14, r22
    b128:	f7 2a       	or	r15, r23
    b12a:	50 c2       	rjmp	.+1184   	; 0xb5cc <__divdi3+0xe7c>
    b12c:	c8 16       	cp	r12, r24
    b12e:	d9 06       	cpc	r13, r25
    b130:	ea 06       	cpc	r14, r26
    b132:	fb 06       	cpc	r15, r27
    b134:	08 f4       	brcc	.+2      	; 0xb138 <__divdi3+0x9e8>
    b136:	37 c2       	rjmp	.+1134   	; 0xb5a6 <__divdi3+0xe56>
    b138:	80 30       	cpi	r24, 0x00	; 0
    b13a:	10 e0       	ldi	r17, 0x00	; 0
    b13c:	91 07       	cpc	r25, r17
    b13e:	11 e0       	ldi	r17, 0x01	; 1
    b140:	a1 07       	cpc	r26, r17
    b142:	10 e0       	ldi	r17, 0x00	; 0
    b144:	b1 07       	cpc	r27, r17
    b146:	50 f4       	brcc	.+20     	; 0xb15c <__divdi3+0xa0c>
    b148:	8f 3f       	cpi	r24, 0xFF	; 255
    b14a:	91 05       	cpc	r25, r1
    b14c:	a1 05       	cpc	r26, r1
    b14e:	b1 05       	cpc	r27, r1
    b150:	09 f0       	breq	.+2      	; 0xb154 <__divdi3+0xa04>
    b152:	88 f4       	brcc	.+34     	; 0xb176 <__divdi3+0xa26>
    b154:	00 e0       	ldi	r16, 0x00	; 0
    b156:	10 e0       	ldi	r17, 0x00	; 0
    b158:	98 01       	movw	r18, r16
    b15a:	16 c0       	rjmp	.+44     	; 0xb188 <__divdi3+0xa38>
    b15c:	80 30       	cpi	r24, 0x00	; 0
    b15e:	20 e0       	ldi	r18, 0x00	; 0
    b160:	92 07       	cpc	r25, r18
    b162:	20 e0       	ldi	r18, 0x00	; 0
    b164:	a2 07       	cpc	r26, r18
    b166:	21 e0       	ldi	r18, 0x01	; 1
    b168:	b2 07       	cpc	r27, r18
    b16a:	50 f4       	brcc	.+20     	; 0xb180 <__divdi3+0xa30>
    b16c:	00 e1       	ldi	r16, 0x10	; 16
    b16e:	10 e0       	ldi	r17, 0x00	; 0
    b170:	20 e0       	ldi	r18, 0x00	; 0
    b172:	30 e0       	ldi	r19, 0x00	; 0
    b174:	09 c0       	rjmp	.+18     	; 0xb188 <__divdi3+0xa38>
    b176:	08 e0       	ldi	r16, 0x08	; 8
    b178:	10 e0       	ldi	r17, 0x00	; 0
    b17a:	20 e0       	ldi	r18, 0x00	; 0
    b17c:	30 e0       	ldi	r19, 0x00	; 0
    b17e:	04 c0       	rjmp	.+8      	; 0xb188 <__divdi3+0xa38>
    b180:	08 e1       	ldi	r16, 0x18	; 24
    b182:	10 e0       	ldi	r17, 0x00	; 0
    b184:	20 e0       	ldi	r18, 0x00	; 0
    b186:	30 e0       	ldi	r19, 0x00	; 0
    b188:	ac 01       	movw	r20, r24
    b18a:	bd 01       	movw	r22, r26
    b18c:	00 2e       	mov	r0, r16
    b18e:	04 c0       	rjmp	.+8      	; 0xb198 <__divdi3+0xa48>
    b190:	76 95       	lsr	r23
    b192:	67 95       	ror	r22
    b194:	57 95       	ror	r21
    b196:	47 95       	ror	r20
    b198:	0a 94       	dec	r0
    b19a:	d2 f7       	brpl	.-12     	; 0xb190 <__divdi3+0xa40>
    b19c:	fa 01       	movw	r30, r20
    b19e:	e6 5d       	subi	r30, 0xD6	; 214
    b1a0:	ff 4d       	sbci	r31, 0xDF	; 223
    b1a2:	40 81       	ld	r20, Z
    b1a4:	04 0f       	add	r16, r20
    b1a6:	11 1d       	adc	r17, r1
    b1a8:	21 1d       	adc	r18, r1
    b1aa:	31 1d       	adc	r19, r1
    b1ac:	40 e2       	ldi	r20, 0x20	; 32
    b1ae:	50 e0       	ldi	r21, 0x00	; 0
    b1b0:	60 e0       	ldi	r22, 0x00	; 0
    b1b2:	70 e0       	ldi	r23, 0x00	; 0
    b1b4:	40 1b       	sub	r20, r16
    b1b6:	51 0b       	sbc	r21, r17
    b1b8:	62 0b       	sbc	r22, r18
    b1ba:	73 0b       	sbc	r23, r19
    b1bc:	a1 f4       	brne	.+40     	; 0xb1e6 <__divdi3+0xa96>
    b1be:	8c 15       	cp	r24, r12
    b1c0:	9d 05       	cpc	r25, r13
    b1c2:	ae 05       	cpc	r26, r14
    b1c4:	bf 05       	cpc	r27, r15
    b1c6:	08 f4       	brcc	.+2      	; 0xb1ca <__divdi3+0xa7a>
    b1c8:	f5 c1       	rjmp	.+1002   	; 0xb5b4 <__divdi3+0xe64>
    b1ca:	ed a8       	sts	0x8d, r30
    b1cc:	fe a8       	sts	0x8e, r31
    b1ce:	0f a9       	sts	0x4f, r16
    b1d0:	18 ad       	sts	0x68, r17
    b1d2:	44 24       	eor	r4, r4
    b1d4:	55 24       	eor	r5, r5
    b1d6:	32 01       	movw	r6, r4
    b1d8:	e8 14       	cp	r14, r8
    b1da:	f9 04       	cpc	r15, r9
    b1dc:	0a 05       	cpc	r16, r10
    b1de:	1b 05       	cpc	r17, r11
    b1e0:	08 f0       	brcs	.+2      	; 0xb1e4 <__divdi3+0xa94>
    b1e2:	eb c1       	rjmp	.+982    	; 0xb5ba <__divdi3+0xe6a>
    b1e4:	e3 c1       	rjmp	.+966    	; 0xb5ac <__divdi3+0xe5c>
    b1e6:	34 2e       	mov	r3, r20
    b1e8:	2c 01       	movw	r4, r24
    b1ea:	3d 01       	movw	r6, r26
    b1ec:	04 c0       	rjmp	.+8      	; 0xb1f6 <__divdi3+0xaa6>
    b1ee:	44 0c       	add	r4, r4
    b1f0:	55 1c       	adc	r5, r5
    b1f2:	66 1c       	adc	r6, r6
    b1f4:	77 1c       	adc	r7, r7
    b1f6:	4a 95       	dec	r20
    b1f8:	d2 f7       	brpl	.-12     	; 0xb1ee <__divdi3+0xa9e>
    b1fa:	d5 01       	movw	r26, r10
    b1fc:	c4 01       	movw	r24, r8
    b1fe:	00 2e       	mov	r0, r16
    b200:	04 c0       	rjmp	.+8      	; 0xb20a <__divdi3+0xaba>
    b202:	b6 95       	lsr	r27
    b204:	a7 95       	ror	r26
    b206:	97 95       	ror	r25
    b208:	87 95       	ror	r24
    b20a:	0a 94       	dec	r0
    b20c:	d2 f7       	brpl	.-12     	; 0xb202 <__divdi3+0xab2>
    b20e:	48 2a       	or	r4, r24
    b210:	59 2a       	or	r5, r25
    b212:	6a 2a       	or	r6, r26
    b214:	7b 2a       	or	r7, r27
    b216:	a5 01       	movw	r20, r10
    b218:	94 01       	movw	r18, r8
    b21a:	03 2c       	mov	r0, r3
    b21c:	04 c0       	rjmp	.+8      	; 0xb226 <__divdi3+0xad6>
    b21e:	22 0f       	add	r18, r18
    b220:	33 1f       	adc	r19, r19
    b222:	44 1f       	adc	r20, r20
    b224:	55 1f       	adc	r21, r21
    b226:	0a 94       	dec	r0
    b228:	d2 f7       	brpl	.-12     	; 0xb21e <__divdi3+0xace>
    b22a:	29 af       	sts	0x79, r18
    b22c:	3a af       	sts	0x7a, r19
    b22e:	4b af       	sts	0x7b, r20
    b230:	5c af       	sts	0x7c, r21
    b232:	b7 01       	movw	r22, r14
    b234:	a6 01       	movw	r20, r12
    b236:	00 2e       	mov	r0, r16
    b238:	04 c0       	rjmp	.+8      	; 0xb242 <__divdi3+0xaf2>
    b23a:	76 95       	lsr	r23
    b23c:	67 95       	ror	r22
    b23e:	57 95       	ror	r21
    b240:	47 95       	ror	r20
    b242:	0a 94       	dec	r0
    b244:	d2 f7       	brpl	.-12     	; 0xb23a <__divdi3+0xaea>
    b246:	49 ab       	sts	0x59, r20
    b248:	5a ab       	sts	0x5a, r21
    b24a:	6b ab       	sts	0x5b, r22
    b24c:	7c ab       	sts	0x5c, r23
    b24e:	c7 01       	movw	r24, r14
    b250:	b6 01       	movw	r22, r12
    b252:	03 2c       	mov	r0, r3
    b254:	04 c0       	rjmp	.+8      	; 0xb25e <__divdi3+0xb0e>
    b256:	66 0f       	add	r22, r22
    b258:	77 1f       	adc	r23, r23
    b25a:	88 1f       	adc	r24, r24
    b25c:	99 1f       	adc	r25, r25
    b25e:	0a 94       	dec	r0
    b260:	d2 f7       	brpl	.-12     	; 0xb256 <__divdi3+0xb06>
    b262:	6d a7       	lds	r22, 0x7d
    b264:	7e a7       	lds	r23, 0x7e
    b266:	8f a7       	lds	r24, 0x7f
    b268:	98 ab       	sts	0x58, r25
    b26a:	8d a9       	sts	0x4d, r24
    b26c:	9e a9       	sts	0x4e, r25
    b26e:	af a9       	sts	0x4f, r26
    b270:	b8 ad       	sts	0x68, r27
    b272:	04 c0       	rjmp	.+8      	; 0xb27c <__divdi3+0xb2c>
    b274:	b6 95       	lsr	r27
    b276:	a7 95       	ror	r26
    b278:	97 95       	ror	r25
    b27a:	87 95       	ror	r24
    b27c:	0a 95       	dec	r16
    b27e:	d2 f7       	brpl	.-12     	; 0xb274 <__divdi3+0xb24>
    b280:	4d a5       	lds	r20, 0x6d
    b282:	5e a5       	lds	r21, 0x6e
    b284:	6f a5       	lds	r22, 0x6f
    b286:	78 a9       	sts	0x48, r23
    b288:	48 2b       	or	r20, r24
    b28a:	59 2b       	or	r21, r25
    b28c:	6a 2b       	or	r22, r26
    b28e:	7b 2b       	or	r23, r27
    b290:	4d a7       	lds	r20, 0x7d
    b292:	5e a7       	lds	r21, 0x7e
    b294:	6f a7       	lds	r22, 0x7f
    b296:	78 ab       	sts	0x58, r23
    b298:	43 01       	movw	r8, r6
    b29a:	aa 24       	eor	r10, r10
    b29c:	bb 24       	eor	r11, r11
    b29e:	93 01       	movw	r18, r6
    b2a0:	82 01       	movw	r16, r4
    b2a2:	20 70       	andi	r18, 0x00	; 0
    b2a4:	30 70       	andi	r19, 0x00	; 0
    b2a6:	21 96       	adiw	r28, 0x01	; 1
    b2a8:	0c af       	sts	0x7c, r16
    b2aa:	1d af       	sts	0x7d, r17
    b2ac:	2e af       	sts	0x7e, r18
    b2ae:	3f af       	sts	0x7f, r19
    b2b0:	21 97       	sbiw	r28, 0x01	; 1
    b2b2:	69 a9       	sts	0x49, r22
    b2b4:	7a a9       	sts	0x4a, r23
    b2b6:	8b a9       	sts	0x4b, r24
    b2b8:	9c a9       	sts	0x4c, r25
    b2ba:	a5 01       	movw	r20, r10
    b2bc:	94 01       	movw	r18, r8
    b2be:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    b2c2:	29 a7       	lds	r18, 0x79
    b2c4:	3a a7       	lds	r19, 0x7a
    b2c6:	4b a7       	lds	r20, 0x7b
    b2c8:	5c a7       	lds	r21, 0x7c
    b2ca:	6b 01       	movw	r12, r22
    b2cc:	7c 01       	movw	r14, r24
    b2ce:	69 a9       	sts	0x49, r22
    b2d0:	7a a9       	sts	0x4a, r23
    b2d2:	8b a9       	sts	0x4b, r24
    b2d4:	9c a9       	sts	0x4c, r25
    b2d6:	a5 01       	movw	r20, r10
    b2d8:	94 01       	movw	r18, r8
    b2da:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    b2de:	ca 01       	movw	r24, r20
    b2e0:	b9 01       	movw	r22, r18
    b2e2:	21 96       	adiw	r28, 0x01	; 1
    b2e4:	2c ad       	sts	0x6c, r18
    b2e6:	3d ad       	sts	0x6d, r19
    b2e8:	4e ad       	sts	0x6e, r20
    b2ea:	5f ad       	sts	0x6f, r21
    b2ec:	21 97       	sbiw	r28, 0x01	; 1
    b2ee:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    b2f2:	dc 01       	movw	r26, r24
    b2f4:	cb 01       	movw	r24, r22
    b2f6:	76 01       	movw	r14, r12
    b2f8:	dd 24       	eor	r13, r13
    b2fa:	cc 24       	eor	r12, r12
    b2fc:	0d a5       	lds	r16, 0x6d
    b2fe:	1e a5       	lds	r17, 0x6e
    b300:	2f a5       	lds	r18, 0x6f
    b302:	38 a9       	sts	0x48, r19
    b304:	a9 01       	movw	r20, r18
    b306:	66 27       	eor	r22, r22
    b308:	77 27       	eor	r23, r23
    b30a:	c4 2a       	or	r12, r20
    b30c:	d5 2a       	or	r13, r21
    b30e:	e6 2a       	or	r14, r22
    b310:	f7 2a       	or	r15, r23
    b312:	09 a5       	lds	r16, 0x69
    b314:	1a a5       	lds	r17, 0x6a
    b316:	2b a5       	lds	r18, 0x6b
    b318:	3c a5       	lds	r19, 0x6c
    b31a:	c8 16       	cp	r12, r24
    b31c:	d9 06       	cpc	r13, r25
    b31e:	ea 06       	cpc	r14, r26
    b320:	fb 06       	cpc	r15, r27
    b322:	38 f5       	brcc	.+78     	; 0xb372 <__divdi3+0xc22>
    b324:	01 50       	subi	r16, 0x01	; 1
    b326:	10 40       	sbci	r17, 0x00	; 0
    b328:	20 40       	sbci	r18, 0x00	; 0
    b32a:	30 40       	sbci	r19, 0x00	; 0
    b32c:	09 ab       	sts	0x59, r16
    b32e:	1a ab       	sts	0x5a, r17
    b330:	2b ab       	sts	0x5b, r18
    b332:	3c ab       	sts	0x5c, r19
    b334:	c4 0c       	add	r12, r4
    b336:	d5 1c       	adc	r13, r5
    b338:	e6 1c       	adc	r14, r6
    b33a:	f7 1c       	adc	r15, r7
    b33c:	c4 14       	cp	r12, r4
    b33e:	d5 04       	cpc	r13, r5
    b340:	e6 04       	cpc	r14, r6
    b342:	f7 04       	cpc	r15, r7
    b344:	d0 f0       	brcs	.+52     	; 0xb37a <__divdi3+0xc2a>
    b346:	c8 16       	cp	r12, r24
    b348:	d9 06       	cpc	r13, r25
    b34a:	ea 06       	cpc	r14, r26
    b34c:	fb 06       	cpc	r15, r27
    b34e:	a8 f4       	brcc	.+42     	; 0xb37a <__divdi3+0xc2a>
    b350:	09 a5       	lds	r16, 0x69
    b352:	1a a5       	lds	r17, 0x6a
    b354:	2b a5       	lds	r18, 0x6b
    b356:	3c a5       	lds	r19, 0x6c
    b358:	02 50       	subi	r16, 0x02	; 2
    b35a:	10 40       	sbci	r17, 0x00	; 0
    b35c:	20 40       	sbci	r18, 0x00	; 0
    b35e:	30 40       	sbci	r19, 0x00	; 0
    b360:	09 ab       	sts	0x59, r16
    b362:	1a ab       	sts	0x5a, r17
    b364:	2b ab       	sts	0x5b, r18
    b366:	3c ab       	sts	0x5c, r19
    b368:	c4 0c       	add	r12, r4
    b36a:	d5 1c       	adc	r13, r5
    b36c:	e6 1c       	adc	r14, r6
    b36e:	f7 1c       	adc	r15, r7
    b370:	04 c0       	rjmp	.+8      	; 0xb37a <__divdi3+0xc2a>
    b372:	09 ab       	sts	0x59, r16
    b374:	1a ab       	sts	0x5a, r17
    b376:	2b ab       	sts	0x5b, r18
    b378:	3c ab       	sts	0x5c, r19
    b37a:	c8 1a       	sub	r12, r24
    b37c:	d9 0a       	sbc	r13, r25
    b37e:	ea 0a       	sbc	r14, r26
    b380:	fb 0a       	sbc	r15, r27
    b382:	c7 01       	movw	r24, r14
    b384:	b6 01       	movw	r22, r12
    b386:	a5 01       	movw	r20, r10
    b388:	94 01       	movw	r18, r8
    b38a:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    b38e:	29 a7       	lds	r18, 0x79
    b390:	3a a7       	lds	r19, 0x7a
    b392:	4b a7       	lds	r20, 0x7b
    b394:	5c a7       	lds	r21, 0x7c
    b396:	29 96       	adiw	r28, 0x09	; 9
    b398:	6c af       	sts	0x7c, r22
    b39a:	7d af       	sts	0x7d, r23
    b39c:	8e af       	sts	0x7e, r24
    b39e:	9f af       	sts	0x7f, r25
    b3a0:	29 97       	sbiw	r28, 0x09	; 9
    b3a2:	c7 01       	movw	r24, r14
    b3a4:	b6 01       	movw	r22, r12
    b3a6:	a5 01       	movw	r20, r10
    b3a8:	94 01       	movw	r18, r8
    b3aa:	0e 94 c0 5d 	call	0xbb80	; 0xbb80 <__udivmodsi4>
    b3ae:	ca 01       	movw	r24, r20
    b3b0:	b9 01       	movw	r22, r18
    b3b2:	21 96       	adiw	r28, 0x01	; 1
    b3b4:	2c ad       	sts	0x6c, r18
    b3b6:	3d ad       	sts	0x6d, r19
    b3b8:	4e ad       	sts	0x6e, r20
    b3ba:	5f ad       	sts	0x6f, r21
    b3bc:	21 97       	sbiw	r28, 0x01	; 1
    b3be:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    b3c2:	4b 01       	movw	r8, r22
    b3c4:	5c 01       	movw	r10, r24
    b3c6:	29 96       	adiw	r28, 0x09	; 9
    b3c8:	4c ad       	sts	0x6c, r20
    b3ca:	5d ad       	sts	0x6d, r21
    b3cc:	6e ad       	sts	0x6e, r22
    b3ce:	7f ad       	sts	0x6f, r23
    b3d0:	29 97       	sbiw	r28, 0x09	; 9
    b3d2:	9a 01       	movw	r18, r20
    b3d4:	11 27       	eor	r17, r17
    b3d6:	00 27       	eor	r16, r16
    b3d8:	8d a5       	lds	r24, 0x6d
    b3da:	9e a5       	lds	r25, 0x6e
    b3dc:	af a5       	lds	r26, 0x6f
    b3de:	b8 a9       	sts	0x48, r27
    b3e0:	a0 70       	andi	r26, 0x00	; 0
    b3e2:	b0 70       	andi	r27, 0x00	; 0
    b3e4:	08 2b       	or	r16, r24
    b3e6:	19 2b       	or	r17, r25
    b3e8:	2a 2b       	or	r18, r26
    b3ea:	3b 2b       	or	r19, r27
    b3ec:	89 a5       	lds	r24, 0x69
    b3ee:	9a a5       	lds	r25, 0x6a
    b3f0:	ab a5       	lds	r26, 0x6b
    b3f2:	bc a5       	lds	r27, 0x6c
    b3f4:	08 15       	cp	r16, r8
    b3f6:	19 05       	cpc	r17, r9
    b3f8:	2a 05       	cpc	r18, r10
    b3fa:	3b 05       	cpc	r19, r11
    b3fc:	e0 f4       	brcc	.+56     	; 0xb436 <__divdi3+0xce6>
    b3fe:	01 97       	sbiw	r24, 0x01	; 1
    b400:	a1 09       	sbc	r26, r1
    b402:	b1 09       	sbc	r27, r1
    b404:	04 0d       	add	r16, r4
    b406:	15 1d       	adc	r17, r5
    b408:	26 1d       	adc	r18, r6
    b40a:	37 1d       	adc	r19, r7
    b40c:	04 15       	cp	r16, r4
    b40e:	15 05       	cpc	r17, r5
    b410:	26 05       	cpc	r18, r6
    b412:	37 05       	cpc	r19, r7
    b414:	80 f0       	brcs	.+32     	; 0xb436 <__divdi3+0xce6>
    b416:	08 15       	cp	r16, r8
    b418:	19 05       	cpc	r17, r9
    b41a:	2a 05       	cpc	r18, r10
    b41c:	3b 05       	cpc	r19, r11
    b41e:	58 f4       	brcc	.+22     	; 0xb436 <__divdi3+0xce6>
    b420:	89 a5       	lds	r24, 0x69
    b422:	9a a5       	lds	r25, 0x6a
    b424:	ab a5       	lds	r26, 0x6b
    b426:	bc a5       	lds	r27, 0x6c
    b428:	02 97       	sbiw	r24, 0x02	; 2
    b42a:	a1 09       	sbc	r26, r1
    b42c:	b1 09       	sbc	r27, r1
    b42e:	04 0d       	add	r16, r4
    b430:	15 1d       	adc	r17, r5
    b432:	26 1d       	adc	r18, r6
    b434:	37 1d       	adc	r19, r7
    b436:	b9 01       	movw	r22, r18
    b438:	a8 01       	movw	r20, r16
    b43a:	48 19       	sub	r20, r8
    b43c:	59 09       	sbc	r21, r9
    b43e:	6a 09       	sbc	r22, r10
    b440:	7b 09       	sbc	r23, r11
    b442:	4d a7       	lds	r20, 0x7d
    b444:	5e a7       	lds	r21, 0x7e
    b446:	6f a7       	lds	r22, 0x7f
    b448:	78 ab       	sts	0x58, r23
    b44a:	09 a9       	sts	0x49, r16
    b44c:	1a a9       	sts	0x4a, r17
    b44e:	2b a9       	sts	0x4b, r18
    b450:	3c a9       	sts	0x4c, r19
    b452:	78 01       	movw	r14, r16
    b454:	dd 24       	eor	r13, r13
    b456:	cc 24       	eor	r12, r12
    b458:	c8 2a       	or	r12, r24
    b45a:	d9 2a       	or	r13, r25
    b45c:	ea 2a       	or	r14, r26
    b45e:	fb 2a       	or	r15, r27
    b460:	ff ef       	ldi	r31, 0xFF	; 255
    b462:	8f 2e       	mov	r8, r31
    b464:	ff ef       	ldi	r31, 0xFF	; 255
    b466:	9f 2e       	mov	r9, r31
    b468:	a1 2c       	mov	r10, r1
    b46a:	b1 2c       	mov	r11, r1
    b46c:	8c 20       	and	r8, r12
    b46e:	9d 20       	and	r9, r13
    b470:	ae 20       	and	r10, r14
    b472:	bf 20       	and	r11, r15
    b474:	87 01       	movw	r16, r14
    b476:	22 27       	eor	r18, r18
    b478:	33 27       	eor	r19, r19
    b47a:	09 a7       	lds	r16, 0x79
    b47c:	1a a7       	lds	r17, 0x7a
    b47e:	2b a7       	lds	r18, 0x7b
    b480:	3c a7       	lds	r19, 0x7c
    b482:	49 ac       	sts	0xa9, r20
    b484:	5a ac       	sts	0xaa, r21
    b486:	6b ac       	sts	0xab, r22
    b488:	7c ac       	sts	0xac, r23
    b48a:	2f ef       	ldi	r18, 0xFF	; 255
    b48c:	3f ef       	ldi	r19, 0xFF	; 255
    b48e:	40 e0       	ldi	r20, 0x00	; 0
    b490:	50 e0       	ldi	r21, 0x00	; 0
    b492:	42 22       	and	r4, r18
    b494:	53 22       	and	r5, r19
    b496:	64 22       	and	r6, r20
    b498:	75 22       	and	r7, r21
    b49a:	29 ad       	sts	0x69, r18
    b49c:	3a ad       	sts	0x6a, r19
    b49e:	4b ad       	sts	0x6b, r20
    b4a0:	5c ad       	sts	0x6c, r21
    b4a2:	8a 01       	movw	r16, r20
    b4a4:	22 27       	eor	r18, r18
    b4a6:	33 27       	eor	r19, r19
    b4a8:	09 ab       	sts	0x59, r16
    b4aa:	1a ab       	sts	0x5a, r17
    b4ac:	2b ab       	sts	0x5b, r18
    b4ae:	3c ab       	sts	0x5c, r19
    b4b0:	c5 01       	movw	r24, r10
    b4b2:	b4 01       	movw	r22, r8
    b4b4:	a3 01       	movw	r20, r6
    b4b6:	92 01       	movw	r18, r4
    b4b8:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    b4bc:	69 af       	sts	0x79, r22
    b4be:	7a af       	sts	0x7a, r23
    b4c0:	8b af       	sts	0x7b, r24
    b4c2:	9c af       	sts	0x7c, r25
    b4c4:	c5 01       	movw	r24, r10
    b4c6:	b4 01       	movw	r22, r8
    b4c8:	29 a9       	sts	0x49, r18
    b4ca:	3a a9       	sts	0x4a, r19
    b4cc:	4b a9       	sts	0x4b, r20
    b4ce:	5c a9       	sts	0x4c, r21
    b4d0:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    b4d4:	4b 01       	movw	r8, r22
    b4d6:	5c 01       	movw	r10, r24
    b4d8:	69 a5       	lds	r22, 0x69
    b4da:	7a a5       	lds	r23, 0x6a
    b4dc:	8b a5       	lds	r24, 0x6b
    b4de:	9c a5       	lds	r25, 0x6c
    b4e0:	a3 01       	movw	r20, r6
    b4e2:	92 01       	movw	r18, r4
    b4e4:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    b4e8:	2b 01       	movw	r4, r22
    b4ea:	3c 01       	movw	r6, r24
    b4ec:	69 a5       	lds	r22, 0x69
    b4ee:	7a a5       	lds	r23, 0x6a
    b4f0:	8b a5       	lds	r24, 0x6b
    b4f2:	9c a5       	lds	r25, 0x6c
    b4f4:	29 a9       	sts	0x49, r18
    b4f6:	3a a9       	sts	0x4a, r19
    b4f8:	4b a9       	sts	0x4b, r20
    b4fa:	5c a9       	sts	0x4c, r21
    b4fc:	0e 94 7a 5d 	call	0xbaf4	; 0xbaf4 <__mulsi3>
    b500:	ab 01       	movw	r20, r22
    b502:	bc 01       	movw	r22, r24
    b504:	84 0c       	add	r8, r4
    b506:	95 1c       	adc	r9, r5
    b508:	a6 1c       	adc	r10, r6
    b50a:	b7 1c       	adc	r11, r7
    b50c:	09 ad       	sts	0x69, r16
    b50e:	1a ad       	sts	0x6a, r17
    b510:	2b ad       	sts	0x6b, r18
    b512:	3c ad       	sts	0x6c, r19
    b514:	c9 01       	movw	r24, r18
    b516:	aa 27       	eor	r26, r26
    b518:	bb 27       	eor	r27, r27
    b51a:	88 0e       	add	r8, r24
    b51c:	99 1e       	adc	r9, r25
    b51e:	aa 1e       	adc	r10, r26
    b520:	bb 1e       	adc	r11, r27
    b522:	84 14       	cp	r8, r4
    b524:	95 04       	cpc	r9, r5
    b526:	a6 04       	cpc	r10, r6
    b528:	b7 04       	cpc	r11, r7
    b52a:	20 f4       	brcc	.+8      	; 0xb534 <__divdi3+0xde4>
    b52c:	40 50       	subi	r20, 0x00	; 0
    b52e:	50 40       	sbci	r21, 0x00	; 0
    b530:	6f 4f       	sbci	r22, 0xFF	; 255
    b532:	7f 4f       	sbci	r23, 0xFF	; 255
    b534:	c5 01       	movw	r24, r10
    b536:	aa 27       	eor	r26, r26
    b538:	bb 27       	eor	r27, r27
    b53a:	84 0f       	add	r24, r20
    b53c:	95 1f       	adc	r25, r21
    b53e:	a6 1f       	adc	r26, r22
    b540:	b7 1f       	adc	r27, r23
    b542:	0d a5       	lds	r16, 0x6d
    b544:	1e a5       	lds	r17, 0x6e
    b546:	2f a5       	lds	r18, 0x6f
    b548:	38 a9       	sts	0x48, r19
    b54a:	08 17       	cp	r16, r24
    b54c:	19 07       	cpc	r17, r25
    b54e:	2a 07       	cpc	r18, r26
    b550:	3b 07       	cpc	r19, r27
    b552:	18 f1       	brcs	.+70     	; 0xb59a <__divdi3+0xe4a>
    b554:	80 17       	cp	r24, r16
    b556:	91 07       	cpc	r25, r17
    b558:	a2 07       	cpc	r26, r18
    b55a:	b3 07       	cpc	r27, r19
    b55c:	a1 f5       	brne	.+104    	; 0xb5c6 <__divdi3+0xe76>
    b55e:	54 01       	movw	r10, r8
    b560:	99 24       	eor	r9, r9
    b562:	88 24       	eor	r8, r8
    b564:	89 ad       	sts	0x69, r24
    b566:	9a ad       	sts	0x6a, r25
    b568:	ab ad       	sts	0x6b, r26
    b56a:	bc ad       	sts	0x6c, r27
    b56c:	a0 70       	andi	r26, 0x00	; 0
    b56e:	b0 70       	andi	r27, 0x00	; 0
    b570:	88 0e       	add	r8, r24
    b572:	99 1e       	adc	r9, r25
    b574:	aa 1e       	adc	r10, r26
    b576:	bb 1e       	adc	r11, r27
    b578:	4d a9       	sts	0x4d, r20
    b57a:	5e a9       	sts	0x4e, r21
    b57c:	6f a9       	sts	0x4f, r22
    b57e:	78 ad       	sts	0x68, r23
    b580:	03 2c       	mov	r0, r3
    b582:	04 c0       	rjmp	.+8      	; 0xb58c <__divdi3+0xe3c>
    b584:	44 0f       	add	r20, r20
    b586:	55 1f       	adc	r21, r21
    b588:	66 1f       	adc	r22, r22
    b58a:	77 1f       	adc	r23, r23
    b58c:	0a 94       	dec	r0
    b58e:	d2 f7       	brpl	.-12     	; 0xb584 <__divdi3+0xe34>
    b590:	48 15       	cp	r20, r8
    b592:	59 05       	cpc	r21, r9
    b594:	6a 05       	cpc	r22, r10
    b596:	7b 05       	cpc	r23, r11
    b598:	b0 f4       	brcc	.+44     	; 0xb5c6 <__divdi3+0xe76>
    b59a:	08 94       	sec
    b59c:	c1 08       	sbc	r12, r1
    b59e:	d1 08       	sbc	r13, r1
    b5a0:	e1 08       	sbc	r14, r1
    b5a2:	f1 08       	sbc	r15, r1
    b5a4:	10 c0       	rjmp	.+32     	; 0xb5c6 <__divdi3+0xe76>
    b5a6:	44 24       	eor	r4, r4
    b5a8:	55 24       	eor	r5, r5
    b5aa:	32 01       	movw	r6, r4
    b5ac:	cc 24       	eor	r12, r12
    b5ae:	dd 24       	eor	r13, r13
    b5b0:	76 01       	movw	r14, r12
    b5b2:	0c c0       	rjmp	.+24     	; 0xb5cc <__divdi3+0xe7c>
    b5b4:	44 24       	eor	r4, r4
    b5b6:	55 24       	eor	r5, r5
    b5b8:	32 01       	movw	r6, r4
    b5ba:	81 e0       	ldi	r24, 0x01	; 1
    b5bc:	c8 2e       	mov	r12, r24
    b5be:	d1 2c       	mov	r13, r1
    b5c0:	e1 2c       	mov	r14, r1
    b5c2:	f1 2c       	mov	r15, r1
    b5c4:	03 c0       	rjmp	.+6      	; 0xb5cc <__divdi3+0xe7c>
    b5c6:	44 24       	eor	r4, r4
    b5c8:	55 24       	eor	r5, r5
    b5ca:	32 01       	movw	r6, r4
    b5cc:	fe 01       	movw	r30, r28
    b5ce:	31 96       	adiw	r30, 0x01	; 1
    b5d0:	88 e0       	ldi	r24, 0x08	; 8
    b5d2:	df 01       	movw	r26, r30
    b5d4:	1d 92       	st	X+, r1
    b5d6:	8a 95       	dec	r24
    b5d8:	e9 f7       	brne	.-6      	; 0xb5d4 <__divdi3+0xe84>
    b5da:	c9 82       	std	Y+1, r12	; 0x01
    b5dc:	da 82       	std	Y+2, r13	; 0x02
    b5de:	eb 82       	std	Y+3, r14	; 0x03
    b5e0:	fc 82       	std	Y+4, r15	; 0x04
    b5e2:	4d 82       	std	Y+5, r4	; 0x05
    b5e4:	5e 82       	std	Y+6, r5	; 0x06
    b5e6:	6f 82       	std	Y+7, r6	; 0x07
    b5e8:	78 86       	std	Y+8, r7	; 0x08
    b5ea:	2c 2d       	mov	r18, r12
    b5ec:	3a 81       	ldd	r19, Y+2	; 0x02
    b5ee:	4b 81       	ldd	r20, Y+3	; 0x03
    b5f0:	5c 81       	ldd	r21, Y+4	; 0x04
    b5f2:	64 2d       	mov	r22, r4
    b5f4:	7e 81       	ldd	r23, Y+6	; 0x06
    b5f6:	8f 81       	ldd	r24, Y+7	; 0x07
    b5f8:	98 85       	ldd	r25, Y+8	; 0x08
    b5fa:	25 96       	adiw	r28, 0x05	; 5
    b5fc:	ec ac       	sts	0xac, r30
    b5fe:	fd ac       	sts	0xad, r31
    b600:	0e ad       	sts	0x6e, r16
    b602:	1f ad       	sts	0x6f, r17
    b604:	25 97       	sbiw	r28, 0x05	; 5
    b606:	e1 14       	cp	r14, r1
    b608:	f1 04       	cpc	r15, r1
    b60a:	01 05       	cpc	r16, r1
    b60c:	11 05       	cpc	r17, r1
    b60e:	09 f4       	brne	.+2      	; 0xb612 <__divdi3+0xec2>
    b610:	56 c0       	rjmp	.+172    	; 0xb6be <__divdi3+0xf6e>
    b612:	21 95       	neg	r18
    b614:	e1 e0       	ldi	r30, 0x01	; 1
    b616:	12 16       	cp	r1, r18
    b618:	08 f0       	brcs	.+2      	; 0xb61c <__divdi3+0xecc>
    b61a:	e0 e0       	ldi	r30, 0x00	; 0
    b61c:	31 95       	neg	r19
    b61e:	f1 e0       	ldi	r31, 0x01	; 1
    b620:	13 16       	cp	r1, r19
    b622:	08 f0       	brcs	.+2      	; 0xb626 <__divdi3+0xed6>
    b624:	f0 e0       	ldi	r31, 0x00	; 0
    b626:	03 2f       	mov	r16, r19
    b628:	0e 1b       	sub	r16, r30
    b62a:	e1 e0       	ldi	r30, 0x01	; 1
    b62c:	30 17       	cp	r19, r16
    b62e:	08 f0       	brcs	.+2      	; 0xb632 <__divdi3+0xee2>
    b630:	e0 e0       	ldi	r30, 0x00	; 0
    b632:	fe 2b       	or	r31, r30
    b634:	41 95       	neg	r20
    b636:	e1 e0       	ldi	r30, 0x01	; 1
    b638:	14 16       	cp	r1, r20
    b63a:	08 f0       	brcs	.+2      	; 0xb63e <__divdi3+0xeee>
    b63c:	e0 e0       	ldi	r30, 0x00	; 0
    b63e:	14 2f       	mov	r17, r20
    b640:	1f 1b       	sub	r17, r31
    b642:	31 e0       	ldi	r19, 0x01	; 1
    b644:	41 17       	cp	r20, r17
    b646:	08 f0       	brcs	.+2      	; 0xb64a <__divdi3+0xefa>
    b648:	30 e0       	ldi	r19, 0x00	; 0
    b64a:	e3 2b       	or	r30, r19
    b64c:	51 95       	neg	r21
    b64e:	f1 e0       	ldi	r31, 0x01	; 1
    b650:	15 16       	cp	r1, r21
    b652:	08 f0       	brcs	.+2      	; 0xb656 <__divdi3+0xf06>
    b654:	f0 e0       	ldi	r31, 0x00	; 0
    b656:	b5 2f       	mov	r27, r21
    b658:	be 1b       	sub	r27, r30
    b65a:	31 e0       	ldi	r19, 0x01	; 1
    b65c:	5b 17       	cp	r21, r27
    b65e:	08 f0       	brcs	.+2      	; 0xb662 <__divdi3+0xf12>
    b660:	30 e0       	ldi	r19, 0x00	; 0
    b662:	f3 2b       	or	r31, r19
    b664:	61 95       	neg	r22
    b666:	e1 e0       	ldi	r30, 0x01	; 1
    b668:	16 16       	cp	r1, r22
    b66a:	08 f0       	brcs	.+2      	; 0xb66e <__divdi3+0xf1e>
    b66c:	e0 e0       	ldi	r30, 0x00	; 0
    b66e:	46 2e       	mov	r4, r22
    b670:	4f 1a       	sub	r4, r31
    b672:	31 e0       	ldi	r19, 0x01	; 1
    b674:	64 15       	cp	r22, r4
    b676:	08 f0       	brcs	.+2      	; 0xb67a <__divdi3+0xf2a>
    b678:	30 e0       	ldi	r19, 0x00	; 0
    b67a:	e3 2b       	or	r30, r19
    b67c:	71 95       	neg	r23
    b67e:	f1 e0       	ldi	r31, 0x01	; 1
    b680:	17 16       	cp	r1, r23
    b682:	08 f0       	brcs	.+2      	; 0xb686 <__divdi3+0xf36>
    b684:	f0 e0       	ldi	r31, 0x00	; 0
    b686:	a7 2f       	mov	r26, r23
    b688:	ae 1b       	sub	r26, r30
    b68a:	31 e0       	ldi	r19, 0x01	; 1
    b68c:	7a 17       	cp	r23, r26
    b68e:	08 f0       	brcs	.+2      	; 0xb692 <__divdi3+0xf42>
    b690:	30 e0       	ldi	r19, 0x00	; 0
    b692:	f3 2b       	or	r31, r19
    b694:	81 95       	neg	r24
    b696:	e1 e0       	ldi	r30, 0x01	; 1
    b698:	18 16       	cp	r1, r24
    b69a:	08 f0       	brcs	.+2      	; 0xb69e <__divdi3+0xf4e>
    b69c:	e0 e0       	ldi	r30, 0x00	; 0
    b69e:	f8 2e       	mov	r15, r24
    b6a0:	ff 1a       	sub	r15, r31
    b6a2:	ff 2d       	mov	r31, r15
    b6a4:	31 e0       	ldi	r19, 0x01	; 1
    b6a6:	8f 15       	cp	r24, r15
    b6a8:	08 f0       	brcs	.+2      	; 0xb6ac <__divdi3+0xf5c>
    b6aa:	30 e0       	ldi	r19, 0x00	; 0
    b6ac:	e3 2b       	or	r30, r19
    b6ae:	91 95       	neg	r25
    b6b0:	30 2f       	mov	r19, r16
    b6b2:	41 2f       	mov	r20, r17
    b6b4:	5b 2f       	mov	r21, r27
    b6b6:	64 2d       	mov	r22, r4
    b6b8:	7a 2f       	mov	r23, r26
    b6ba:	8f 2f       	mov	r24, r31
    b6bc:	9e 1b       	sub	r25, r30
    b6be:	c8 5b       	subi	r28, 0xB8	; 184
    b6c0:	df 4f       	sbci	r29, 0xFF	; 255
    b6c2:	e1 e1       	ldi	r30, 0x11	; 17
    b6c4:	0c 94 17 5e 	jmp	0xbc2e	; 0xbc2e <__epilogue_restores__+0x2>

0000b6c8 <__subsf3>:
    b6c8:	50 58       	subi	r21, 0x80	; 128

0000b6ca <__addsf3>:
    b6ca:	bb 27       	eor	r27, r27
    b6cc:	aa 27       	eor	r26, r26
    b6ce:	0e d0       	rcall	.+28     	; 0xb6ec <__addsf3x>
    b6d0:	70 c1       	rjmp	.+736    	; 0xb9b2 <__fp_round>
    b6d2:	61 d1       	rcall	.+706    	; 0xb996 <__fp_pscA>
    b6d4:	30 f0       	brcs	.+12     	; 0xb6e2 <__addsf3+0x18>
    b6d6:	66 d1       	rcall	.+716    	; 0xb9a4 <__fp_pscB>
    b6d8:	20 f0       	brcs	.+8      	; 0xb6e2 <__addsf3+0x18>
    b6da:	31 f4       	brne	.+12     	; 0xb6e8 <__addsf3+0x1e>
    b6dc:	9f 3f       	cpi	r25, 0xFF	; 255
    b6de:	11 f4       	brne	.+4      	; 0xb6e4 <__addsf3+0x1a>
    b6e0:	1e f4       	brtc	.+6      	; 0xb6e8 <__addsf3+0x1e>
    b6e2:	56 c1       	rjmp	.+684    	; 0xb990 <__fp_nan>
    b6e4:	0e f4       	brtc	.+2      	; 0xb6e8 <__addsf3+0x1e>
    b6e6:	e0 95       	com	r30
    b6e8:	e7 fb       	bst	r30, 7
    b6ea:	4c c1       	rjmp	.+664    	; 0xb984 <__fp_inf>

0000b6ec <__addsf3x>:
    b6ec:	e9 2f       	mov	r30, r25
    b6ee:	72 d1       	rcall	.+740    	; 0xb9d4 <__fp_split3>
    b6f0:	80 f3       	brcs	.-32     	; 0xb6d2 <__addsf3+0x8>
    b6f2:	ba 17       	cp	r27, r26
    b6f4:	62 07       	cpc	r22, r18
    b6f6:	73 07       	cpc	r23, r19
    b6f8:	84 07       	cpc	r24, r20
    b6fa:	95 07       	cpc	r25, r21
    b6fc:	18 f0       	brcs	.+6      	; 0xb704 <__addsf3x+0x18>
    b6fe:	71 f4       	brne	.+28     	; 0xb71c <__addsf3x+0x30>
    b700:	9e f5       	brtc	.+102    	; 0xb768 <__addsf3x+0x7c>
    b702:	8a c1       	rjmp	.+788    	; 0xba18 <__fp_zero>
    b704:	0e f4       	brtc	.+2      	; 0xb708 <__addsf3x+0x1c>
    b706:	e0 95       	com	r30
    b708:	0b 2e       	mov	r0, r27
    b70a:	ba 2f       	mov	r27, r26
    b70c:	a0 2d       	mov	r26, r0
    b70e:	0b 01       	movw	r0, r22
    b710:	b9 01       	movw	r22, r18
    b712:	90 01       	movw	r18, r0
    b714:	0c 01       	movw	r0, r24
    b716:	ca 01       	movw	r24, r20
    b718:	a0 01       	movw	r20, r0
    b71a:	11 24       	eor	r1, r1
    b71c:	ff 27       	eor	r31, r31
    b71e:	59 1b       	sub	r21, r25
    b720:	99 f0       	breq	.+38     	; 0xb748 <__addsf3x+0x5c>
    b722:	59 3f       	cpi	r21, 0xF9	; 249
    b724:	50 f4       	brcc	.+20     	; 0xb73a <__addsf3x+0x4e>
    b726:	50 3e       	cpi	r21, 0xE0	; 224
    b728:	68 f1       	brcs	.+90     	; 0xb784 <__addsf3x+0x98>
    b72a:	1a 16       	cp	r1, r26
    b72c:	f0 40       	sbci	r31, 0x00	; 0
    b72e:	a2 2f       	mov	r26, r18
    b730:	23 2f       	mov	r18, r19
    b732:	34 2f       	mov	r19, r20
    b734:	44 27       	eor	r20, r20
    b736:	58 5f       	subi	r21, 0xF8	; 248
    b738:	f3 cf       	rjmp	.-26     	; 0xb720 <__addsf3x+0x34>
    b73a:	46 95       	lsr	r20
    b73c:	37 95       	ror	r19
    b73e:	27 95       	ror	r18
    b740:	a7 95       	ror	r26
    b742:	f0 40       	sbci	r31, 0x00	; 0
    b744:	53 95       	inc	r21
    b746:	c9 f7       	brne	.-14     	; 0xb73a <__addsf3x+0x4e>
    b748:	7e f4       	brtc	.+30     	; 0xb768 <__addsf3x+0x7c>
    b74a:	1f 16       	cp	r1, r31
    b74c:	ba 0b       	sbc	r27, r26
    b74e:	62 0b       	sbc	r22, r18
    b750:	73 0b       	sbc	r23, r19
    b752:	84 0b       	sbc	r24, r20
    b754:	ba f0       	brmi	.+46     	; 0xb784 <__addsf3x+0x98>
    b756:	91 50       	subi	r25, 0x01	; 1
    b758:	a1 f0       	breq	.+40     	; 0xb782 <__addsf3x+0x96>
    b75a:	ff 0f       	add	r31, r31
    b75c:	bb 1f       	adc	r27, r27
    b75e:	66 1f       	adc	r22, r22
    b760:	77 1f       	adc	r23, r23
    b762:	88 1f       	adc	r24, r24
    b764:	c2 f7       	brpl	.-16     	; 0xb756 <__addsf3x+0x6a>
    b766:	0e c0       	rjmp	.+28     	; 0xb784 <__addsf3x+0x98>
    b768:	ba 0f       	add	r27, r26
    b76a:	62 1f       	adc	r22, r18
    b76c:	73 1f       	adc	r23, r19
    b76e:	84 1f       	adc	r24, r20
    b770:	48 f4       	brcc	.+18     	; 0xb784 <__addsf3x+0x98>
    b772:	87 95       	ror	r24
    b774:	77 95       	ror	r23
    b776:	67 95       	ror	r22
    b778:	b7 95       	ror	r27
    b77a:	f7 95       	ror	r31
    b77c:	9e 3f       	cpi	r25, 0xFE	; 254
    b77e:	08 f0       	brcs	.+2      	; 0xb782 <__addsf3x+0x96>
    b780:	b3 cf       	rjmp	.-154    	; 0xb6e8 <__addsf3+0x1e>
    b782:	93 95       	inc	r25
    b784:	88 0f       	add	r24, r24
    b786:	08 f0       	brcs	.+2      	; 0xb78a <__addsf3x+0x9e>
    b788:	99 27       	eor	r25, r25
    b78a:	ee 0f       	add	r30, r30
    b78c:	97 95       	ror	r25
    b78e:	87 95       	ror	r24
    b790:	08 95       	ret

0000b792 <__cmpsf2>:
    b792:	d4 d0       	rcall	.+424    	; 0xb93c <__fp_cmp>
    b794:	08 f4       	brcc	.+2      	; 0xb798 <__cmpsf2+0x6>
    b796:	81 e0       	ldi	r24, 0x01	; 1
    b798:	08 95       	ret

0000b79a <__divsf3>:
    b79a:	0c d0       	rcall	.+24     	; 0xb7b4 <__divsf3x>
    b79c:	0a c1       	rjmp	.+532    	; 0xb9b2 <__fp_round>
    b79e:	02 d1       	rcall	.+516    	; 0xb9a4 <__fp_pscB>
    b7a0:	40 f0       	brcs	.+16     	; 0xb7b2 <__divsf3+0x18>
    b7a2:	f9 d0       	rcall	.+498    	; 0xb996 <__fp_pscA>
    b7a4:	30 f0       	brcs	.+12     	; 0xb7b2 <__divsf3+0x18>
    b7a6:	21 f4       	brne	.+8      	; 0xb7b0 <__divsf3+0x16>
    b7a8:	5f 3f       	cpi	r21, 0xFF	; 255
    b7aa:	19 f0       	breq	.+6      	; 0xb7b2 <__divsf3+0x18>
    b7ac:	eb c0       	rjmp	.+470    	; 0xb984 <__fp_inf>
    b7ae:	51 11       	cpse	r21, r1
    b7b0:	34 c1       	rjmp	.+616    	; 0xba1a <__fp_szero>
    b7b2:	ee c0       	rjmp	.+476    	; 0xb990 <__fp_nan>

0000b7b4 <__divsf3x>:
    b7b4:	0f d1       	rcall	.+542    	; 0xb9d4 <__fp_split3>
    b7b6:	98 f3       	brcs	.-26     	; 0xb79e <__divsf3+0x4>

0000b7b8 <__divsf3_pse>:
    b7b8:	99 23       	and	r25, r25
    b7ba:	c9 f3       	breq	.-14     	; 0xb7ae <__divsf3+0x14>
    b7bc:	55 23       	and	r21, r21
    b7be:	b1 f3       	breq	.-20     	; 0xb7ac <__divsf3+0x12>
    b7c0:	95 1b       	sub	r25, r21
    b7c2:	55 0b       	sbc	r21, r21
    b7c4:	bb 27       	eor	r27, r27
    b7c6:	aa 27       	eor	r26, r26
    b7c8:	62 17       	cp	r22, r18
    b7ca:	73 07       	cpc	r23, r19
    b7cc:	84 07       	cpc	r24, r20
    b7ce:	38 f0       	brcs	.+14     	; 0xb7de <__divsf3_pse+0x26>
    b7d0:	9f 5f       	subi	r25, 0xFF	; 255
    b7d2:	5f 4f       	sbci	r21, 0xFF	; 255
    b7d4:	22 0f       	add	r18, r18
    b7d6:	33 1f       	adc	r19, r19
    b7d8:	44 1f       	adc	r20, r20
    b7da:	aa 1f       	adc	r26, r26
    b7dc:	a9 f3       	breq	.-22     	; 0xb7c8 <__divsf3_pse+0x10>
    b7de:	33 d0       	rcall	.+102    	; 0xb846 <__divsf3_pse+0x8e>
    b7e0:	0e 2e       	mov	r0, r30
    b7e2:	3a f0       	brmi	.+14     	; 0xb7f2 <__divsf3_pse+0x3a>
    b7e4:	e0 e8       	ldi	r30, 0x80	; 128
    b7e6:	30 d0       	rcall	.+96     	; 0xb848 <__divsf3_pse+0x90>
    b7e8:	91 50       	subi	r25, 0x01	; 1
    b7ea:	50 40       	sbci	r21, 0x00	; 0
    b7ec:	e6 95       	lsr	r30
    b7ee:	00 1c       	adc	r0, r0
    b7f0:	ca f7       	brpl	.-14     	; 0xb7e4 <__divsf3_pse+0x2c>
    b7f2:	29 d0       	rcall	.+82     	; 0xb846 <__divsf3_pse+0x8e>
    b7f4:	fe 2f       	mov	r31, r30
    b7f6:	27 d0       	rcall	.+78     	; 0xb846 <__divsf3_pse+0x8e>
    b7f8:	66 0f       	add	r22, r22
    b7fa:	77 1f       	adc	r23, r23
    b7fc:	88 1f       	adc	r24, r24
    b7fe:	bb 1f       	adc	r27, r27
    b800:	26 17       	cp	r18, r22
    b802:	37 07       	cpc	r19, r23
    b804:	48 07       	cpc	r20, r24
    b806:	ab 07       	cpc	r26, r27
    b808:	b0 e8       	ldi	r27, 0x80	; 128
    b80a:	09 f0       	breq	.+2      	; 0xb80e <__divsf3_pse+0x56>
    b80c:	bb 0b       	sbc	r27, r27
    b80e:	80 2d       	mov	r24, r0
    b810:	bf 01       	movw	r22, r30
    b812:	ff 27       	eor	r31, r31
    b814:	93 58       	subi	r25, 0x83	; 131
    b816:	5f 4f       	sbci	r21, 0xFF	; 255
    b818:	2a f0       	brmi	.+10     	; 0xb824 <__divsf3_pse+0x6c>
    b81a:	9e 3f       	cpi	r25, 0xFE	; 254
    b81c:	51 05       	cpc	r21, r1
    b81e:	68 f0       	brcs	.+26     	; 0xb83a <__divsf3_pse+0x82>
    b820:	b1 c0       	rjmp	.+354    	; 0xb984 <__fp_inf>
    b822:	fb c0       	rjmp	.+502    	; 0xba1a <__fp_szero>
    b824:	5f 3f       	cpi	r21, 0xFF	; 255
    b826:	ec f3       	brlt	.-6      	; 0xb822 <__divsf3_pse+0x6a>
    b828:	98 3e       	cpi	r25, 0xE8	; 232
    b82a:	dc f3       	brlt	.-10     	; 0xb822 <__divsf3_pse+0x6a>
    b82c:	86 95       	lsr	r24
    b82e:	77 95       	ror	r23
    b830:	67 95       	ror	r22
    b832:	b7 95       	ror	r27
    b834:	f7 95       	ror	r31
    b836:	9f 5f       	subi	r25, 0xFF	; 255
    b838:	c9 f7       	brne	.-14     	; 0xb82c <__divsf3_pse+0x74>
    b83a:	88 0f       	add	r24, r24
    b83c:	91 1d       	adc	r25, r1
    b83e:	96 95       	lsr	r25
    b840:	87 95       	ror	r24
    b842:	97 f9       	bld	r25, 7
    b844:	08 95       	ret
    b846:	e1 e0       	ldi	r30, 0x01	; 1
    b848:	66 0f       	add	r22, r22
    b84a:	77 1f       	adc	r23, r23
    b84c:	88 1f       	adc	r24, r24
    b84e:	bb 1f       	adc	r27, r27
    b850:	62 17       	cp	r22, r18
    b852:	73 07       	cpc	r23, r19
    b854:	84 07       	cpc	r24, r20
    b856:	ba 07       	cpc	r27, r26
    b858:	20 f0       	brcs	.+8      	; 0xb862 <__divsf3_pse+0xaa>
    b85a:	62 1b       	sub	r22, r18
    b85c:	73 0b       	sbc	r23, r19
    b85e:	84 0b       	sbc	r24, r20
    b860:	ba 0b       	sbc	r27, r26
    b862:	ee 1f       	adc	r30, r30
    b864:	88 f7       	brcc	.-30     	; 0xb848 <__divsf3_pse+0x90>
    b866:	e0 95       	com	r30
    b868:	08 95       	ret

0000b86a <__fixunssfsi>:
    b86a:	bc d0       	rcall	.+376    	; 0xb9e4 <__fp_splitA>
    b86c:	88 f0       	brcs	.+34     	; 0xb890 <__fixunssfsi+0x26>
    b86e:	9f 57       	subi	r25, 0x7F	; 127
    b870:	90 f0       	brcs	.+36     	; 0xb896 <__fixunssfsi+0x2c>
    b872:	b9 2f       	mov	r27, r25
    b874:	99 27       	eor	r25, r25
    b876:	b7 51       	subi	r27, 0x17	; 23
    b878:	a0 f0       	brcs	.+40     	; 0xb8a2 <__fixunssfsi+0x38>
    b87a:	d1 f0       	breq	.+52     	; 0xb8b0 <__fixunssfsi+0x46>
    b87c:	66 0f       	add	r22, r22
    b87e:	77 1f       	adc	r23, r23
    b880:	88 1f       	adc	r24, r24
    b882:	99 1f       	adc	r25, r25
    b884:	1a f0       	brmi	.+6      	; 0xb88c <__fixunssfsi+0x22>
    b886:	ba 95       	dec	r27
    b888:	c9 f7       	brne	.-14     	; 0xb87c <__fixunssfsi+0x12>
    b88a:	12 c0       	rjmp	.+36     	; 0xb8b0 <__fixunssfsi+0x46>
    b88c:	b1 30       	cpi	r27, 0x01	; 1
    b88e:	81 f0       	breq	.+32     	; 0xb8b0 <__fixunssfsi+0x46>
    b890:	c3 d0       	rcall	.+390    	; 0xba18 <__fp_zero>
    b892:	b1 e0       	ldi	r27, 0x01	; 1
    b894:	08 95       	ret
    b896:	c0 c0       	rjmp	.+384    	; 0xba18 <__fp_zero>
    b898:	67 2f       	mov	r22, r23
    b89a:	78 2f       	mov	r23, r24
    b89c:	88 27       	eor	r24, r24
    b89e:	b8 5f       	subi	r27, 0xF8	; 248
    b8a0:	39 f0       	breq	.+14     	; 0xb8b0 <__fixunssfsi+0x46>
    b8a2:	b9 3f       	cpi	r27, 0xF9	; 249
    b8a4:	cc f3       	brlt	.-14     	; 0xb898 <__fixunssfsi+0x2e>
    b8a6:	86 95       	lsr	r24
    b8a8:	77 95       	ror	r23
    b8aa:	67 95       	ror	r22
    b8ac:	b3 95       	inc	r27
    b8ae:	d9 f7       	brne	.-10     	; 0xb8a6 <__fixunssfsi+0x3c>
    b8b0:	3e f4       	brtc	.+14     	; 0xb8c0 <__fixunssfsi+0x56>
    b8b2:	90 95       	com	r25
    b8b4:	80 95       	com	r24
    b8b6:	70 95       	com	r23
    b8b8:	61 95       	neg	r22
    b8ba:	7f 4f       	sbci	r23, 0xFF	; 255
    b8bc:	8f 4f       	sbci	r24, 0xFF	; 255
    b8be:	9f 4f       	sbci	r25, 0xFF	; 255
    b8c0:	08 95       	ret

0000b8c2 <__floatunsisf>:
    b8c2:	e8 94       	clt
    b8c4:	09 c0       	rjmp	.+18     	; 0xb8d8 <__floatsisf+0x12>

0000b8c6 <__floatsisf>:
    b8c6:	97 fb       	bst	r25, 7
    b8c8:	3e f4       	brtc	.+14     	; 0xb8d8 <__floatsisf+0x12>
    b8ca:	90 95       	com	r25
    b8cc:	80 95       	com	r24
    b8ce:	70 95       	com	r23
    b8d0:	61 95       	neg	r22
    b8d2:	7f 4f       	sbci	r23, 0xFF	; 255
    b8d4:	8f 4f       	sbci	r24, 0xFF	; 255
    b8d6:	9f 4f       	sbci	r25, 0xFF	; 255
    b8d8:	99 23       	and	r25, r25
    b8da:	a9 f0       	breq	.+42     	; 0xb906 <__floatsisf+0x40>
    b8dc:	f9 2f       	mov	r31, r25
    b8de:	96 e9       	ldi	r25, 0x96	; 150
    b8e0:	bb 27       	eor	r27, r27
    b8e2:	93 95       	inc	r25
    b8e4:	f6 95       	lsr	r31
    b8e6:	87 95       	ror	r24
    b8e8:	77 95       	ror	r23
    b8ea:	67 95       	ror	r22
    b8ec:	b7 95       	ror	r27
    b8ee:	f1 11       	cpse	r31, r1
    b8f0:	f8 cf       	rjmp	.-16     	; 0xb8e2 <__floatsisf+0x1c>
    b8f2:	fa f4       	brpl	.+62     	; 0xb932 <__floatsisf+0x6c>
    b8f4:	bb 0f       	add	r27, r27
    b8f6:	11 f4       	brne	.+4      	; 0xb8fc <__floatsisf+0x36>
    b8f8:	60 ff       	sbrs	r22, 0
    b8fa:	1b c0       	rjmp	.+54     	; 0xb932 <__floatsisf+0x6c>
    b8fc:	6f 5f       	subi	r22, 0xFF	; 255
    b8fe:	7f 4f       	sbci	r23, 0xFF	; 255
    b900:	8f 4f       	sbci	r24, 0xFF	; 255
    b902:	9f 4f       	sbci	r25, 0xFF	; 255
    b904:	16 c0       	rjmp	.+44     	; 0xb932 <__floatsisf+0x6c>
    b906:	88 23       	and	r24, r24
    b908:	11 f0       	breq	.+4      	; 0xb90e <__floatsisf+0x48>
    b90a:	96 e9       	ldi	r25, 0x96	; 150
    b90c:	11 c0       	rjmp	.+34     	; 0xb930 <__floatsisf+0x6a>
    b90e:	77 23       	and	r23, r23
    b910:	21 f0       	breq	.+8      	; 0xb91a <__floatsisf+0x54>
    b912:	9e e8       	ldi	r25, 0x8E	; 142
    b914:	87 2f       	mov	r24, r23
    b916:	76 2f       	mov	r23, r22
    b918:	05 c0       	rjmp	.+10     	; 0xb924 <__floatsisf+0x5e>
    b91a:	66 23       	and	r22, r22
    b91c:	71 f0       	breq	.+28     	; 0xb93a <__floatsisf+0x74>
    b91e:	96 e8       	ldi	r25, 0x86	; 134
    b920:	86 2f       	mov	r24, r22
    b922:	70 e0       	ldi	r23, 0x00	; 0
    b924:	60 e0       	ldi	r22, 0x00	; 0
    b926:	2a f0       	brmi	.+10     	; 0xb932 <__floatsisf+0x6c>
    b928:	9a 95       	dec	r25
    b92a:	66 0f       	add	r22, r22
    b92c:	77 1f       	adc	r23, r23
    b92e:	88 1f       	adc	r24, r24
    b930:	da f7       	brpl	.-10     	; 0xb928 <__floatsisf+0x62>
    b932:	88 0f       	add	r24, r24
    b934:	96 95       	lsr	r25
    b936:	87 95       	ror	r24
    b938:	97 f9       	bld	r25, 7
    b93a:	08 95       	ret

0000b93c <__fp_cmp>:
    b93c:	99 0f       	add	r25, r25
    b93e:	00 08       	sbc	r0, r0
    b940:	55 0f       	add	r21, r21
    b942:	aa 0b       	sbc	r26, r26
    b944:	e0 e8       	ldi	r30, 0x80	; 128
    b946:	fe ef       	ldi	r31, 0xFE	; 254
    b948:	16 16       	cp	r1, r22
    b94a:	17 06       	cpc	r1, r23
    b94c:	e8 07       	cpc	r30, r24
    b94e:	f9 07       	cpc	r31, r25
    b950:	c0 f0       	brcs	.+48     	; 0xb982 <__fp_cmp+0x46>
    b952:	12 16       	cp	r1, r18
    b954:	13 06       	cpc	r1, r19
    b956:	e4 07       	cpc	r30, r20
    b958:	f5 07       	cpc	r31, r21
    b95a:	98 f0       	brcs	.+38     	; 0xb982 <__fp_cmp+0x46>
    b95c:	62 1b       	sub	r22, r18
    b95e:	73 0b       	sbc	r23, r19
    b960:	84 0b       	sbc	r24, r20
    b962:	95 0b       	sbc	r25, r21
    b964:	39 f4       	brne	.+14     	; 0xb974 <__fp_cmp+0x38>
    b966:	0a 26       	eor	r0, r26
    b968:	61 f0       	breq	.+24     	; 0xb982 <__fp_cmp+0x46>
    b96a:	23 2b       	or	r18, r19
    b96c:	24 2b       	or	r18, r20
    b96e:	25 2b       	or	r18, r21
    b970:	21 f4       	brne	.+8      	; 0xb97a <__fp_cmp+0x3e>
    b972:	08 95       	ret
    b974:	0a 26       	eor	r0, r26
    b976:	09 f4       	brne	.+2      	; 0xb97a <__fp_cmp+0x3e>
    b978:	a1 40       	sbci	r26, 0x01	; 1
    b97a:	a6 95       	lsr	r26
    b97c:	8f ef       	ldi	r24, 0xFF	; 255
    b97e:	81 1d       	adc	r24, r1
    b980:	81 1d       	adc	r24, r1
    b982:	08 95       	ret

0000b984 <__fp_inf>:
    b984:	97 f9       	bld	r25, 7
    b986:	9f 67       	ori	r25, 0x7F	; 127
    b988:	80 e8       	ldi	r24, 0x80	; 128
    b98a:	70 e0       	ldi	r23, 0x00	; 0
    b98c:	60 e0       	ldi	r22, 0x00	; 0
    b98e:	08 95       	ret

0000b990 <__fp_nan>:
    b990:	9f ef       	ldi	r25, 0xFF	; 255
    b992:	80 ec       	ldi	r24, 0xC0	; 192
    b994:	08 95       	ret

0000b996 <__fp_pscA>:
    b996:	00 24       	eor	r0, r0
    b998:	0a 94       	dec	r0
    b99a:	16 16       	cp	r1, r22
    b99c:	17 06       	cpc	r1, r23
    b99e:	18 06       	cpc	r1, r24
    b9a0:	09 06       	cpc	r0, r25
    b9a2:	08 95       	ret

0000b9a4 <__fp_pscB>:
    b9a4:	00 24       	eor	r0, r0
    b9a6:	0a 94       	dec	r0
    b9a8:	12 16       	cp	r1, r18
    b9aa:	13 06       	cpc	r1, r19
    b9ac:	14 06       	cpc	r1, r20
    b9ae:	05 06       	cpc	r0, r21
    b9b0:	08 95       	ret

0000b9b2 <__fp_round>:
    b9b2:	09 2e       	mov	r0, r25
    b9b4:	03 94       	inc	r0
    b9b6:	00 0c       	add	r0, r0
    b9b8:	11 f4       	brne	.+4      	; 0xb9be <__fp_round+0xc>
    b9ba:	88 23       	and	r24, r24
    b9bc:	52 f0       	brmi	.+20     	; 0xb9d2 <__fp_round+0x20>
    b9be:	bb 0f       	add	r27, r27
    b9c0:	40 f4       	brcc	.+16     	; 0xb9d2 <__fp_round+0x20>
    b9c2:	bf 2b       	or	r27, r31
    b9c4:	11 f4       	brne	.+4      	; 0xb9ca <__fp_round+0x18>
    b9c6:	60 ff       	sbrs	r22, 0
    b9c8:	04 c0       	rjmp	.+8      	; 0xb9d2 <__fp_round+0x20>
    b9ca:	6f 5f       	subi	r22, 0xFF	; 255
    b9cc:	7f 4f       	sbci	r23, 0xFF	; 255
    b9ce:	8f 4f       	sbci	r24, 0xFF	; 255
    b9d0:	9f 4f       	sbci	r25, 0xFF	; 255
    b9d2:	08 95       	ret

0000b9d4 <__fp_split3>:
    b9d4:	57 fd       	sbrc	r21, 7
    b9d6:	90 58       	subi	r25, 0x80	; 128
    b9d8:	44 0f       	add	r20, r20
    b9da:	55 1f       	adc	r21, r21
    b9dc:	59 f0       	breq	.+22     	; 0xb9f4 <__fp_splitA+0x10>
    b9de:	5f 3f       	cpi	r21, 0xFF	; 255
    b9e0:	71 f0       	breq	.+28     	; 0xb9fe <__fp_splitA+0x1a>
    b9e2:	47 95       	ror	r20

0000b9e4 <__fp_splitA>:
    b9e4:	88 0f       	add	r24, r24
    b9e6:	97 fb       	bst	r25, 7
    b9e8:	99 1f       	adc	r25, r25
    b9ea:	61 f0       	breq	.+24     	; 0xba04 <__fp_splitA+0x20>
    b9ec:	9f 3f       	cpi	r25, 0xFF	; 255
    b9ee:	79 f0       	breq	.+30     	; 0xba0e <__fp_splitA+0x2a>
    b9f0:	87 95       	ror	r24
    b9f2:	08 95       	ret
    b9f4:	12 16       	cp	r1, r18
    b9f6:	13 06       	cpc	r1, r19
    b9f8:	14 06       	cpc	r1, r20
    b9fa:	55 1f       	adc	r21, r21
    b9fc:	f2 cf       	rjmp	.-28     	; 0xb9e2 <__fp_split3+0xe>
    b9fe:	46 95       	lsr	r20
    ba00:	f1 df       	rcall	.-30     	; 0xb9e4 <__fp_splitA>
    ba02:	08 c0       	rjmp	.+16     	; 0xba14 <__fp_splitA+0x30>
    ba04:	16 16       	cp	r1, r22
    ba06:	17 06       	cpc	r1, r23
    ba08:	18 06       	cpc	r1, r24
    ba0a:	99 1f       	adc	r25, r25
    ba0c:	f1 cf       	rjmp	.-30     	; 0xb9f0 <__fp_splitA+0xc>
    ba0e:	86 95       	lsr	r24
    ba10:	71 05       	cpc	r23, r1
    ba12:	61 05       	cpc	r22, r1
    ba14:	08 94       	sec
    ba16:	08 95       	ret

0000ba18 <__fp_zero>:
    ba18:	e8 94       	clt

0000ba1a <__fp_szero>:
    ba1a:	bb 27       	eor	r27, r27
    ba1c:	66 27       	eor	r22, r22
    ba1e:	77 27       	eor	r23, r23
    ba20:	cb 01       	movw	r24, r22
    ba22:	97 f9       	bld	r25, 7
    ba24:	08 95       	ret

0000ba26 <__gesf2>:
    ba26:	8a df       	rcall	.-236    	; 0xb93c <__fp_cmp>
    ba28:	08 f4       	brcc	.+2      	; 0xba2c <__gesf2+0x6>
    ba2a:	8f ef       	ldi	r24, 0xFF	; 255
    ba2c:	08 95       	ret

0000ba2e <__mulsf3>:
    ba2e:	0b d0       	rcall	.+22     	; 0xba46 <__mulsf3x>
    ba30:	c0 cf       	rjmp	.-128    	; 0xb9b2 <__fp_round>
    ba32:	b1 df       	rcall	.-158    	; 0xb996 <__fp_pscA>
    ba34:	28 f0       	brcs	.+10     	; 0xba40 <__mulsf3+0x12>
    ba36:	b6 df       	rcall	.-148    	; 0xb9a4 <__fp_pscB>
    ba38:	18 f0       	brcs	.+6      	; 0xba40 <__mulsf3+0x12>
    ba3a:	95 23       	and	r25, r21
    ba3c:	09 f0       	breq	.+2      	; 0xba40 <__mulsf3+0x12>
    ba3e:	a2 cf       	rjmp	.-188    	; 0xb984 <__fp_inf>
    ba40:	a7 cf       	rjmp	.-178    	; 0xb990 <__fp_nan>
    ba42:	11 24       	eor	r1, r1
    ba44:	ea cf       	rjmp	.-44     	; 0xba1a <__fp_szero>

0000ba46 <__mulsf3x>:
    ba46:	c6 df       	rcall	.-116    	; 0xb9d4 <__fp_split3>
    ba48:	a0 f3       	brcs	.-24     	; 0xba32 <__mulsf3+0x4>

0000ba4a <__mulsf3_pse>:
    ba4a:	95 9f       	mul	r25, r21
    ba4c:	d1 f3       	breq	.-12     	; 0xba42 <__mulsf3+0x14>
    ba4e:	95 0f       	add	r25, r21
    ba50:	50 e0       	ldi	r21, 0x00	; 0
    ba52:	55 1f       	adc	r21, r21
    ba54:	62 9f       	mul	r22, r18
    ba56:	f0 01       	movw	r30, r0
    ba58:	72 9f       	mul	r23, r18
    ba5a:	bb 27       	eor	r27, r27
    ba5c:	f0 0d       	add	r31, r0
    ba5e:	b1 1d       	adc	r27, r1
    ba60:	63 9f       	mul	r22, r19
    ba62:	aa 27       	eor	r26, r26
    ba64:	f0 0d       	add	r31, r0
    ba66:	b1 1d       	adc	r27, r1
    ba68:	aa 1f       	adc	r26, r26
    ba6a:	64 9f       	mul	r22, r20
    ba6c:	66 27       	eor	r22, r22
    ba6e:	b0 0d       	add	r27, r0
    ba70:	a1 1d       	adc	r26, r1
    ba72:	66 1f       	adc	r22, r22
    ba74:	82 9f       	mul	r24, r18
    ba76:	22 27       	eor	r18, r18
    ba78:	b0 0d       	add	r27, r0
    ba7a:	a1 1d       	adc	r26, r1
    ba7c:	62 1f       	adc	r22, r18
    ba7e:	73 9f       	mul	r23, r19
    ba80:	b0 0d       	add	r27, r0
    ba82:	a1 1d       	adc	r26, r1
    ba84:	62 1f       	adc	r22, r18
    ba86:	83 9f       	mul	r24, r19
    ba88:	a0 0d       	add	r26, r0
    ba8a:	61 1d       	adc	r22, r1
    ba8c:	22 1f       	adc	r18, r18
    ba8e:	74 9f       	mul	r23, r20
    ba90:	33 27       	eor	r19, r19
    ba92:	a0 0d       	add	r26, r0
    ba94:	61 1d       	adc	r22, r1
    ba96:	23 1f       	adc	r18, r19
    ba98:	84 9f       	mul	r24, r20
    ba9a:	60 0d       	add	r22, r0
    ba9c:	21 1d       	adc	r18, r1
    ba9e:	82 2f       	mov	r24, r18
    baa0:	76 2f       	mov	r23, r22
    baa2:	6a 2f       	mov	r22, r26
    baa4:	11 24       	eor	r1, r1
    baa6:	9f 57       	subi	r25, 0x7F	; 127
    baa8:	50 40       	sbci	r21, 0x00	; 0
    baaa:	8a f0       	brmi	.+34     	; 0xbace <__mulsf3_pse+0x84>
    baac:	e1 f0       	breq	.+56     	; 0xbae6 <__mulsf3_pse+0x9c>
    baae:	88 23       	and	r24, r24
    bab0:	4a f0       	brmi	.+18     	; 0xbac4 <__mulsf3_pse+0x7a>
    bab2:	ee 0f       	add	r30, r30
    bab4:	ff 1f       	adc	r31, r31
    bab6:	bb 1f       	adc	r27, r27
    bab8:	66 1f       	adc	r22, r22
    baba:	77 1f       	adc	r23, r23
    babc:	88 1f       	adc	r24, r24
    babe:	91 50       	subi	r25, 0x01	; 1
    bac0:	50 40       	sbci	r21, 0x00	; 0
    bac2:	a9 f7       	brne	.-22     	; 0xbaae <__mulsf3_pse+0x64>
    bac4:	9e 3f       	cpi	r25, 0xFE	; 254
    bac6:	51 05       	cpc	r21, r1
    bac8:	70 f0       	brcs	.+28     	; 0xbae6 <__mulsf3_pse+0x9c>
    baca:	5c cf       	rjmp	.-328    	; 0xb984 <__fp_inf>
    bacc:	a6 cf       	rjmp	.-180    	; 0xba1a <__fp_szero>
    bace:	5f 3f       	cpi	r21, 0xFF	; 255
    bad0:	ec f3       	brlt	.-6      	; 0xbacc <__mulsf3_pse+0x82>
    bad2:	98 3e       	cpi	r25, 0xE8	; 232
    bad4:	dc f3       	brlt	.-10     	; 0xbacc <__mulsf3_pse+0x82>
    bad6:	86 95       	lsr	r24
    bad8:	77 95       	ror	r23
    bada:	67 95       	ror	r22
    badc:	b7 95       	ror	r27
    bade:	f7 95       	ror	r31
    bae0:	e7 95       	ror	r30
    bae2:	9f 5f       	subi	r25, 0xFF	; 255
    bae4:	c1 f7       	brne	.-16     	; 0xbad6 <__mulsf3_pse+0x8c>
    bae6:	fe 2b       	or	r31, r30
    bae8:	88 0f       	add	r24, r24
    baea:	91 1d       	adc	r25, r1
    baec:	96 95       	lsr	r25
    baee:	87 95       	ror	r24
    baf0:	97 f9       	bld	r25, 7
    baf2:	08 95       	ret

0000baf4 <__mulsi3>:
    baf4:	62 9f       	mul	r22, r18
    baf6:	d0 01       	movw	r26, r0
    baf8:	73 9f       	mul	r23, r19
    bafa:	f0 01       	movw	r30, r0
    bafc:	82 9f       	mul	r24, r18
    bafe:	e0 0d       	add	r30, r0
    bb00:	f1 1d       	adc	r31, r1
    bb02:	64 9f       	mul	r22, r20
    bb04:	e0 0d       	add	r30, r0
    bb06:	f1 1d       	adc	r31, r1
    bb08:	92 9f       	mul	r25, r18
    bb0a:	f0 0d       	add	r31, r0
    bb0c:	83 9f       	mul	r24, r19
    bb0e:	f0 0d       	add	r31, r0
    bb10:	74 9f       	mul	r23, r20
    bb12:	f0 0d       	add	r31, r0
    bb14:	65 9f       	mul	r22, r21
    bb16:	f0 0d       	add	r31, r0
    bb18:	99 27       	eor	r25, r25
    bb1a:	72 9f       	mul	r23, r18
    bb1c:	b0 0d       	add	r27, r0
    bb1e:	e1 1d       	adc	r30, r1
    bb20:	f9 1f       	adc	r31, r25
    bb22:	63 9f       	mul	r22, r19
    bb24:	b0 0d       	add	r27, r0
    bb26:	e1 1d       	adc	r30, r1
    bb28:	f9 1f       	adc	r31, r25
    bb2a:	bd 01       	movw	r22, r26
    bb2c:	cf 01       	movw	r24, r30
    bb2e:	11 24       	eor	r1, r1
    bb30:	08 95       	ret

0000bb32 <__udivmodhi4>:
    bb32:	aa 1b       	sub	r26, r26
    bb34:	bb 1b       	sub	r27, r27
    bb36:	51 e1       	ldi	r21, 0x11	; 17
    bb38:	07 c0       	rjmp	.+14     	; 0xbb48 <__udivmodhi4_ep>

0000bb3a <__udivmodhi4_loop>:
    bb3a:	aa 1f       	adc	r26, r26
    bb3c:	bb 1f       	adc	r27, r27
    bb3e:	a6 17       	cp	r26, r22
    bb40:	b7 07       	cpc	r27, r23
    bb42:	10 f0       	brcs	.+4      	; 0xbb48 <__udivmodhi4_ep>
    bb44:	a6 1b       	sub	r26, r22
    bb46:	b7 0b       	sbc	r27, r23

0000bb48 <__udivmodhi4_ep>:
    bb48:	88 1f       	adc	r24, r24
    bb4a:	99 1f       	adc	r25, r25
    bb4c:	5a 95       	dec	r21
    bb4e:	a9 f7       	brne	.-22     	; 0xbb3a <__udivmodhi4_loop>
    bb50:	80 95       	com	r24
    bb52:	90 95       	com	r25
    bb54:	bc 01       	movw	r22, r24
    bb56:	cd 01       	movw	r24, r26
    bb58:	08 95       	ret

0000bb5a <__divmodhi4>:
    bb5a:	97 fb       	bst	r25, 7
    bb5c:	09 2e       	mov	r0, r25
    bb5e:	07 26       	eor	r0, r23
    bb60:	0a d0       	rcall	.+20     	; 0xbb76 <__divmodhi4_neg1>
    bb62:	77 fd       	sbrc	r23, 7
    bb64:	04 d0       	rcall	.+8      	; 0xbb6e <__divmodhi4_neg2>
    bb66:	e5 df       	rcall	.-54     	; 0xbb32 <__udivmodhi4>
    bb68:	06 d0       	rcall	.+12     	; 0xbb76 <__divmodhi4_neg1>
    bb6a:	00 20       	and	r0, r0
    bb6c:	1a f4       	brpl	.+6      	; 0xbb74 <__divmodhi4_exit>

0000bb6e <__divmodhi4_neg2>:
    bb6e:	70 95       	com	r23
    bb70:	61 95       	neg	r22
    bb72:	7f 4f       	sbci	r23, 0xFF	; 255

0000bb74 <__divmodhi4_exit>:
    bb74:	08 95       	ret

0000bb76 <__divmodhi4_neg1>:
    bb76:	f6 f7       	brtc	.-4      	; 0xbb74 <__divmodhi4_exit>
    bb78:	90 95       	com	r25
    bb7a:	81 95       	neg	r24
    bb7c:	9f 4f       	sbci	r25, 0xFF	; 255
    bb7e:	08 95       	ret

0000bb80 <__udivmodsi4>:
    bb80:	a1 e2       	ldi	r26, 0x21	; 33
    bb82:	1a 2e       	mov	r1, r26
    bb84:	aa 1b       	sub	r26, r26
    bb86:	bb 1b       	sub	r27, r27
    bb88:	fd 01       	movw	r30, r26
    bb8a:	0d c0       	rjmp	.+26     	; 0xbba6 <__udivmodsi4_ep>

0000bb8c <__udivmodsi4_loop>:
    bb8c:	aa 1f       	adc	r26, r26
    bb8e:	bb 1f       	adc	r27, r27
    bb90:	ee 1f       	adc	r30, r30
    bb92:	ff 1f       	adc	r31, r31
    bb94:	a2 17       	cp	r26, r18
    bb96:	b3 07       	cpc	r27, r19
    bb98:	e4 07       	cpc	r30, r20
    bb9a:	f5 07       	cpc	r31, r21
    bb9c:	20 f0       	brcs	.+8      	; 0xbba6 <__udivmodsi4_ep>
    bb9e:	a2 1b       	sub	r26, r18
    bba0:	b3 0b       	sbc	r27, r19
    bba2:	e4 0b       	sbc	r30, r20
    bba4:	f5 0b       	sbc	r31, r21

0000bba6 <__udivmodsi4_ep>:
    bba6:	66 1f       	adc	r22, r22
    bba8:	77 1f       	adc	r23, r23
    bbaa:	88 1f       	adc	r24, r24
    bbac:	99 1f       	adc	r25, r25
    bbae:	1a 94       	dec	r1
    bbb0:	69 f7       	brne	.-38     	; 0xbb8c <__udivmodsi4_loop>
    bbb2:	60 95       	com	r22
    bbb4:	70 95       	com	r23
    bbb6:	80 95       	com	r24
    bbb8:	90 95       	com	r25
    bbba:	9b 01       	movw	r18, r22
    bbbc:	ac 01       	movw	r20, r24
    bbbe:	bd 01       	movw	r22, r26
    bbc0:	cf 01       	movw	r24, r30
    bbc2:	08 95       	ret

0000bbc4 <__divmodsi4>:
    bbc4:	97 fb       	bst	r25, 7
    bbc6:	09 2e       	mov	r0, r25
    bbc8:	05 26       	eor	r0, r21
    bbca:	0e d0       	rcall	.+28     	; 0xbbe8 <__divmodsi4_neg1>
    bbcc:	57 fd       	sbrc	r21, 7
    bbce:	04 d0       	rcall	.+8      	; 0xbbd8 <__divmodsi4_neg2>
    bbd0:	d7 df       	rcall	.-82     	; 0xbb80 <__udivmodsi4>
    bbd2:	0a d0       	rcall	.+20     	; 0xbbe8 <__divmodsi4_neg1>
    bbd4:	00 1c       	adc	r0, r0
    bbd6:	38 f4       	brcc	.+14     	; 0xbbe6 <__divmodsi4_exit>

0000bbd8 <__divmodsi4_neg2>:
    bbd8:	50 95       	com	r21
    bbda:	40 95       	com	r20
    bbdc:	30 95       	com	r19
    bbde:	21 95       	neg	r18
    bbe0:	3f 4f       	sbci	r19, 0xFF	; 255
    bbe2:	4f 4f       	sbci	r20, 0xFF	; 255
    bbe4:	5f 4f       	sbci	r21, 0xFF	; 255

0000bbe6 <__divmodsi4_exit>:
    bbe6:	08 95       	ret

0000bbe8 <__divmodsi4_neg1>:
    bbe8:	f6 f7       	brtc	.-4      	; 0xbbe6 <__divmodsi4_exit>
    bbea:	90 95       	com	r25
    bbec:	80 95       	com	r24
    bbee:	70 95       	com	r23
    bbf0:	61 95       	neg	r22
    bbf2:	7f 4f       	sbci	r23, 0xFF	; 255
    bbf4:	8f 4f       	sbci	r24, 0xFF	; 255
    bbf6:	9f 4f       	sbci	r25, 0xFF	; 255
    bbf8:	08 95       	ret

0000bbfa <__prologue_saves__>:
    bbfa:	2f 92       	push	r2
    bbfc:	3f 92       	push	r3
    bbfe:	4f 92       	push	r4
    bc00:	5f 92       	push	r5
    bc02:	6f 92       	push	r6
    bc04:	7f 92       	push	r7
    bc06:	8f 92       	push	r8
    bc08:	9f 92       	push	r9
    bc0a:	af 92       	push	r10
    bc0c:	bf 92       	push	r11
    bc0e:	cf 92       	push	r12
    bc10:	df 92       	push	r13
    bc12:	ef 92       	push	r14
    bc14:	ff 92       	push	r15
    bc16:	0f 93       	push	r16
    bc18:	1f 93       	push	r17
    bc1a:	cf 93       	push	r28
    bc1c:	df 93       	push	r29
    bc1e:	cd b7       	in	r28, 0x3d	; 61
    bc20:	de b7       	in	r29, 0x3e	; 62
    bc22:	ca 1b       	sub	r28, r26
    bc24:	db 0b       	sbc	r29, r27
    bc26:	cd bf       	out	0x3d, r28	; 61
    bc28:	de bf       	out	0x3e, r29	; 62
    bc2a:	19 94       	eijmp

0000bc2c <__epilogue_restores__>:
    bc2c:	2a 88       	ldd	r2, Y+18	; 0x12
    bc2e:	39 88       	ldd	r3, Y+17	; 0x11
    bc30:	48 88       	ldd	r4, Y+16	; 0x10
    bc32:	5f 84       	ldd	r5, Y+15	; 0x0f
    bc34:	6e 84       	ldd	r6, Y+14	; 0x0e
    bc36:	7d 84       	ldd	r7, Y+13	; 0x0d
    bc38:	8c 84       	ldd	r8, Y+12	; 0x0c
    bc3a:	9b 84       	ldd	r9, Y+11	; 0x0b
    bc3c:	aa 84       	ldd	r10, Y+10	; 0x0a
    bc3e:	b9 84       	ldd	r11, Y+9	; 0x09
    bc40:	c8 84       	ldd	r12, Y+8	; 0x08
    bc42:	df 80       	ldd	r13, Y+7	; 0x07
    bc44:	ee 80       	ldd	r14, Y+6	; 0x06
    bc46:	fd 80       	ldd	r15, Y+5	; 0x05
    bc48:	0c 81       	ldd	r16, Y+4	; 0x04
    bc4a:	1b 81       	ldd	r17, Y+3	; 0x03
    bc4c:	aa 81       	ldd	r26, Y+2	; 0x02
    bc4e:	b9 81       	ldd	r27, Y+1	; 0x01
    bc50:	ce 0f       	add	r28, r30
    bc52:	d1 1d       	adc	r29, r1
    bc54:	cd bf       	out	0x3d, r28	; 61
    bc56:	de bf       	out	0x3e, r29	; 62
    bc58:	ed 01       	movw	r28, r26
    bc5a:	08 95       	ret

0000bc5c <strcpy_P>:
    bc5c:	fb 01       	movw	r30, r22
    bc5e:	dc 01       	movw	r26, r24
    bc60:	05 90       	lpm	r0, Z+
    bc62:	0d 92       	st	X+, r0
    bc64:	00 20       	and	r0, r0
    bc66:	e1 f7       	brne	.-8      	; 0xbc60 <strcpy_P+0x4>
    bc68:	08 95       	ret

0000bc6a <memmove>:
    bc6a:	68 17       	cp	r22, r24
    bc6c:	79 07       	cpc	r23, r25
    bc6e:	68 f4       	brcc	.+26     	; 0xbc8a <memmove+0x20>
    bc70:	fb 01       	movw	r30, r22
    bc72:	dc 01       	movw	r26, r24
    bc74:	e4 0f       	add	r30, r20
    bc76:	f5 1f       	adc	r31, r21
    bc78:	a4 0f       	add	r26, r20
    bc7a:	b5 1f       	adc	r27, r21
    bc7c:	02 c0       	rjmp	.+4      	; 0xbc82 <memmove+0x18>
    bc7e:	02 90       	ld	r0, -Z
    bc80:	0e 92       	st	-X, r0
    bc82:	41 50       	subi	r20, 0x01	; 1
    bc84:	50 40       	sbci	r21, 0x00	; 0
    bc86:	d8 f7       	brcc	.-10     	; 0xbc7e <memmove+0x14>
    bc88:	08 95       	ret
    bc8a:	0c 94 c8 60 	jmp	0xc190	; 0xc190 <memcpy>

0000bc8e <strcat>:
    bc8e:	fb 01       	movw	r30, r22
    bc90:	dc 01       	movw	r26, r24
    bc92:	0d 90       	ld	r0, X+
    bc94:	00 20       	and	r0, r0
    bc96:	e9 f7       	brne	.-6      	; 0xbc92 <strcat+0x4>
    bc98:	11 97       	sbiw	r26, 0x01	; 1
    bc9a:	01 90       	ld	r0, Z+
    bc9c:	0d 92       	st	X+, r0
    bc9e:	00 20       	and	r0, r0
    bca0:	e1 f7       	brne	.-8      	; 0xbc9a <strcat+0xc>
    bca2:	08 95       	ret

0000bca4 <strncmp>:
    bca4:	fb 01       	movw	r30, r22
    bca6:	dc 01       	movw	r26, r24
    bca8:	41 50       	subi	r20, 0x01	; 1
    bcaa:	50 40       	sbci	r21, 0x00	; 0
    bcac:	30 f0       	brcs	.+12     	; 0xbcba <strncmp+0x16>
    bcae:	8d 91       	ld	r24, X+
    bcb0:	01 90       	ld	r0, Z+
    bcb2:	80 19       	sub	r24, r0
    bcb4:	19 f4       	brne	.+6      	; 0xbcbc <strncmp+0x18>
    bcb6:	00 20       	and	r0, r0
    bcb8:	b9 f7       	brne	.-18     	; 0xbca8 <strncmp+0x4>
    bcba:	88 1b       	sub	r24, r24
    bcbc:	99 0b       	sbc	r25, r25
    bcbe:	08 95       	ret

0000bcc0 <itoa>:
    bcc0:	fb 01       	movw	r30, r22
    bcc2:	9f 01       	movw	r18, r30
    bcc4:	e8 94       	clt
    bcc6:	42 30       	cpi	r20, 0x02	; 2
    bcc8:	c4 f0       	brlt	.+48     	; 0xbcfa <itoa+0x3a>
    bcca:	45 32       	cpi	r20, 0x25	; 37
    bccc:	b4 f4       	brge	.+44     	; 0xbcfa <itoa+0x3a>
    bcce:	4a 30       	cpi	r20, 0x0A	; 10
    bcd0:	29 f4       	brne	.+10     	; 0xbcdc <itoa+0x1c>
    bcd2:	97 fb       	bst	r25, 7
    bcd4:	1e f4       	brtc	.+6      	; 0xbcdc <itoa+0x1c>
    bcd6:	90 95       	com	r25
    bcd8:	81 95       	neg	r24
    bcda:	9f 4f       	sbci	r25, 0xFF	; 255
    bcdc:	64 2f       	mov	r22, r20
    bcde:	77 27       	eor	r23, r23
    bce0:	0e 94 99 5d 	call	0xbb32	; 0xbb32 <__udivmodhi4>
    bce4:	80 5d       	subi	r24, 0xD0	; 208
    bce6:	8a 33       	cpi	r24, 0x3A	; 58
    bce8:	0c f0       	brlt	.+2      	; 0xbcec <itoa+0x2c>
    bcea:	89 5d       	subi	r24, 0xD9	; 217
    bcec:	81 93       	st	Z+, r24
    bcee:	cb 01       	movw	r24, r22
    bcf0:	00 97       	sbiw	r24, 0x00	; 0
    bcf2:	a1 f7       	brne	.-24     	; 0xbcdc <itoa+0x1c>
    bcf4:	16 f4       	brtc	.+4      	; 0xbcfa <itoa+0x3a>
    bcf6:	5d e2       	ldi	r21, 0x2D	; 45
    bcf8:	51 93       	st	Z+, r21
    bcfa:	10 82       	st	Z, r1
    bcfc:	c9 01       	movw	r24, r18
    bcfe:	0c 94 dc 60 	jmp	0xc1b8	; 0xc1b8 <strrev>

0000bd02 <printf>:
    bd02:	cf 93       	push	r28
    bd04:	df 93       	push	r29
    bd06:	cd b7       	in	r28, 0x3d	; 61
    bd08:	de b7       	in	r29, 0x3e	; 62
    bd0a:	fe 01       	movw	r30, r28
    bd0c:	36 96       	adiw	r30, 0x06	; 6
    bd0e:	61 91       	ld	r22, Z+
    bd10:	71 91       	ld	r23, Z+
    bd12:	80 91 d1 50 	lds	r24, 0x50D1
    bd16:	90 91 d2 50 	lds	r25, 0x50D2
    bd1a:	af 01       	movw	r20, r30
    bd1c:	0e 94 bc 5e 	call	0xbd78	; 0xbd78 <vfprintf>
    bd20:	df 91       	pop	r29
    bd22:	cf 91       	pop	r28
    bd24:	08 95       	ret

0000bd26 <sprintf>:
    bd26:	0f 93       	push	r16
    bd28:	1f 93       	push	r17
    bd2a:	cf 93       	push	r28
    bd2c:	df 93       	push	r29
    bd2e:	cd b7       	in	r28, 0x3d	; 61
    bd30:	de b7       	in	r29, 0x3e	; 62
    bd32:	2e 97       	sbiw	r28, 0x0e	; 14
    bd34:	cd bf       	out	0x3d, r28	; 61
    bd36:	de bf       	out	0x3e, r29	; 62
    bd38:	0e 89       	ldd	r16, Y+22	; 0x16
    bd3a:	1f 89       	ldd	r17, Y+23	; 0x17
    bd3c:	86 e0       	ldi	r24, 0x06	; 6
    bd3e:	8c 83       	std	Y+4, r24	; 0x04
    bd40:	09 83       	std	Y+1, r16	; 0x01
    bd42:	1a 83       	std	Y+2, r17	; 0x02
    bd44:	8f ef       	ldi	r24, 0xFF	; 255
    bd46:	9f e7       	ldi	r25, 0x7F	; 127
    bd48:	8d 83       	std	Y+5, r24	; 0x05
    bd4a:	9e 83       	std	Y+6, r25	; 0x06
    bd4c:	ae 01       	movw	r20, r28
    bd4e:	46 5e       	subi	r20, 0xE6	; 230
    bd50:	5f 4f       	sbci	r21, 0xFF	; 255
    bd52:	ce 01       	movw	r24, r28
    bd54:	01 96       	adiw	r24, 0x01	; 1
    bd56:	68 8d       	ldd	r22, Y+24	; 0x18
    bd58:	79 8d       	ldd	r23, Y+25	; 0x19
    bd5a:	0e 94 bc 5e 	call	0xbd78	; 0xbd78 <vfprintf>
    bd5e:	ef 81       	ldd	r30, Y+7	; 0x07
    bd60:	f8 85       	ldd	r31, Y+8	; 0x08
    bd62:	e0 0f       	add	r30, r16
    bd64:	f1 1f       	adc	r31, r17
    bd66:	10 82       	st	Z, r1
    bd68:	2e 96       	adiw	r28, 0x0e	; 14
    bd6a:	cd bf       	out	0x3d, r28	; 61
    bd6c:	de bf       	out	0x3e, r29	; 62
    bd6e:	df 91       	pop	r29
    bd70:	cf 91       	pop	r28
    bd72:	1f 91       	pop	r17
    bd74:	0f 91       	pop	r16
    bd76:	08 95       	ret

0000bd78 <vfprintf>:
    bd78:	2f 92       	push	r2
    bd7a:	3f 92       	push	r3
    bd7c:	4f 92       	push	r4
    bd7e:	5f 92       	push	r5
    bd80:	6f 92       	push	r6
    bd82:	7f 92       	push	r7
    bd84:	8f 92       	push	r8
    bd86:	9f 92       	push	r9
    bd88:	af 92       	push	r10
    bd8a:	bf 92       	push	r11
    bd8c:	cf 92       	push	r12
    bd8e:	df 92       	push	r13
    bd90:	ef 92       	push	r14
    bd92:	ff 92       	push	r15
    bd94:	0f 93       	push	r16
    bd96:	1f 93       	push	r17
    bd98:	cf 93       	push	r28
    bd9a:	df 93       	push	r29
    bd9c:	cd b7       	in	r28, 0x3d	; 61
    bd9e:	de b7       	in	r29, 0x3e	; 62
    bda0:	2d 97       	sbiw	r28, 0x0d	; 13
    bda2:	cd bf       	out	0x3d, r28	; 61
    bda4:	de bf       	out	0x3e, r29	; 62
    bda6:	3c 01       	movw	r6, r24
    bda8:	6c 87       	std	Y+12, r22	; 0x0c
    bdaa:	7d 87       	std	Y+13, r23	; 0x0d
    bdac:	5a 01       	movw	r10, r20
    bdae:	fc 01       	movw	r30, r24
    bdb0:	16 82       	std	Z+6, r1	; 0x06
    bdb2:	17 82       	std	Z+7, r1	; 0x07
    bdb4:	83 81       	ldd	r24, Z+3	; 0x03
    bdb6:	81 ff       	sbrs	r24, 1
    bdb8:	c8 c1       	rjmp	.+912    	; 0xc14a <vfprintf+0x3d2>
    bdba:	2e 01       	movw	r4, r28
    bdbc:	08 94       	sec
    bdbe:	41 1c       	adc	r4, r1
    bdc0:	51 1c       	adc	r5, r1
    bdc2:	f3 01       	movw	r30, r6
    bdc4:	93 81       	ldd	r25, Z+3	; 0x03
    bdc6:	ec 85       	ldd	r30, Y+12	; 0x0c
    bdc8:	fd 85       	ldd	r31, Y+13	; 0x0d
    bdca:	93 fd       	sbrc	r25, 3
    bdcc:	85 91       	lpm	r24, Z+
    bdce:	93 ff       	sbrs	r25, 3
    bdd0:	81 91       	ld	r24, Z+
    bdd2:	ec 87       	std	Y+12, r30	; 0x0c
    bdd4:	fd 87       	std	Y+13, r31	; 0x0d
    bdd6:	88 23       	and	r24, r24
    bdd8:	09 f4       	brne	.+2      	; 0xbddc <vfprintf+0x64>
    bdda:	b3 c1       	rjmp	.+870    	; 0xc142 <vfprintf+0x3ca>
    bddc:	85 32       	cpi	r24, 0x25	; 37
    bdde:	41 f4       	brne	.+16     	; 0xbdf0 <vfprintf+0x78>
    bde0:	93 fd       	sbrc	r25, 3
    bde2:	85 91       	lpm	r24, Z+
    bde4:	93 ff       	sbrs	r25, 3
    bde6:	81 91       	ld	r24, Z+
    bde8:	ec 87       	std	Y+12, r30	; 0x0c
    bdea:	fd 87       	std	Y+13, r31	; 0x0d
    bdec:	85 32       	cpi	r24, 0x25	; 37
    bdee:	29 f4       	brne	.+10     	; 0xbdfa <vfprintf+0x82>
    bdf0:	90 e0       	ldi	r25, 0x00	; 0
    bdf2:	b3 01       	movw	r22, r6
    bdf4:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    bdf8:	e4 cf       	rjmp	.-56     	; 0xbdc2 <vfprintf+0x4a>
    bdfa:	ff 24       	eor	r15, r15
    bdfc:	ee 24       	eor	r14, r14
    bdfe:	10 e0       	ldi	r17, 0x00	; 0
    be00:	10 32       	cpi	r17, 0x20	; 32
    be02:	b0 f4       	brcc	.+44     	; 0xbe30 <vfprintf+0xb8>
    be04:	8b 32       	cpi	r24, 0x2B	; 43
    be06:	69 f0       	breq	.+26     	; 0xbe22 <vfprintf+0xaa>
    be08:	8c 32       	cpi	r24, 0x2C	; 44
    be0a:	28 f4       	brcc	.+10     	; 0xbe16 <vfprintf+0x9e>
    be0c:	80 32       	cpi	r24, 0x20	; 32
    be0e:	51 f0       	breq	.+20     	; 0xbe24 <vfprintf+0xac>
    be10:	83 32       	cpi	r24, 0x23	; 35
    be12:	71 f4       	brne	.+28     	; 0xbe30 <vfprintf+0xb8>
    be14:	0b c0       	rjmp	.+22     	; 0xbe2c <vfprintf+0xb4>
    be16:	8d 32       	cpi	r24, 0x2D	; 45
    be18:	39 f0       	breq	.+14     	; 0xbe28 <vfprintf+0xb0>
    be1a:	80 33       	cpi	r24, 0x30	; 48
    be1c:	49 f4       	brne	.+18     	; 0xbe30 <vfprintf+0xb8>
    be1e:	11 60       	ori	r17, 0x01	; 1
    be20:	2c c0       	rjmp	.+88     	; 0xbe7a <vfprintf+0x102>
    be22:	12 60       	ori	r17, 0x02	; 2
    be24:	14 60       	ori	r17, 0x04	; 4
    be26:	29 c0       	rjmp	.+82     	; 0xbe7a <vfprintf+0x102>
    be28:	18 60       	ori	r17, 0x08	; 8
    be2a:	27 c0       	rjmp	.+78     	; 0xbe7a <vfprintf+0x102>
    be2c:	10 61       	ori	r17, 0x10	; 16
    be2e:	25 c0       	rjmp	.+74     	; 0xbe7a <vfprintf+0x102>
    be30:	17 fd       	sbrc	r17, 7
    be32:	2e c0       	rjmp	.+92     	; 0xbe90 <vfprintf+0x118>
    be34:	28 2f       	mov	r18, r24
    be36:	20 53       	subi	r18, 0x30	; 48
    be38:	2a 30       	cpi	r18, 0x0A	; 10
    be3a:	98 f4       	brcc	.+38     	; 0xbe62 <vfprintf+0xea>
    be3c:	16 ff       	sbrs	r17, 6
    be3e:	08 c0       	rjmp	.+16     	; 0xbe50 <vfprintf+0xd8>
    be40:	8f 2d       	mov	r24, r15
    be42:	88 0f       	add	r24, r24
    be44:	f8 2e       	mov	r15, r24
    be46:	ff 0c       	add	r15, r15
    be48:	ff 0c       	add	r15, r15
    be4a:	f8 0e       	add	r15, r24
    be4c:	f2 0e       	add	r15, r18
    be4e:	15 c0       	rjmp	.+42     	; 0xbe7a <vfprintf+0x102>
    be50:	8e 2d       	mov	r24, r14
    be52:	88 0f       	add	r24, r24
    be54:	e8 2e       	mov	r14, r24
    be56:	ee 0c       	add	r14, r14
    be58:	ee 0c       	add	r14, r14
    be5a:	e8 0e       	add	r14, r24
    be5c:	e2 0e       	add	r14, r18
    be5e:	10 62       	ori	r17, 0x20	; 32
    be60:	0c c0       	rjmp	.+24     	; 0xbe7a <vfprintf+0x102>
    be62:	8e 32       	cpi	r24, 0x2E	; 46
    be64:	21 f4       	brne	.+8      	; 0xbe6e <vfprintf+0xf6>
    be66:	16 fd       	sbrc	r17, 6
    be68:	6c c1       	rjmp	.+728    	; 0xc142 <vfprintf+0x3ca>
    be6a:	10 64       	ori	r17, 0x40	; 64
    be6c:	06 c0       	rjmp	.+12     	; 0xbe7a <vfprintf+0x102>
    be6e:	8c 36       	cpi	r24, 0x6C	; 108
    be70:	11 f4       	brne	.+4      	; 0xbe76 <vfprintf+0xfe>
    be72:	10 68       	ori	r17, 0x80	; 128
    be74:	02 c0       	rjmp	.+4      	; 0xbe7a <vfprintf+0x102>
    be76:	88 36       	cpi	r24, 0x68	; 104
    be78:	59 f4       	brne	.+22     	; 0xbe90 <vfprintf+0x118>
    be7a:	ec 85       	ldd	r30, Y+12	; 0x0c
    be7c:	fd 85       	ldd	r31, Y+13	; 0x0d
    be7e:	93 fd       	sbrc	r25, 3
    be80:	85 91       	lpm	r24, Z+
    be82:	93 ff       	sbrs	r25, 3
    be84:	81 91       	ld	r24, Z+
    be86:	ec 87       	std	Y+12, r30	; 0x0c
    be88:	fd 87       	std	Y+13, r31	; 0x0d
    be8a:	88 23       	and	r24, r24
    be8c:	09 f0       	breq	.+2      	; 0xbe90 <vfprintf+0x118>
    be8e:	b8 cf       	rjmp	.-144    	; 0xbe00 <vfprintf+0x88>
    be90:	98 2f       	mov	r25, r24
    be92:	95 54       	subi	r25, 0x45	; 69
    be94:	93 30       	cpi	r25, 0x03	; 3
    be96:	18 f0       	brcs	.+6      	; 0xbe9e <vfprintf+0x126>
    be98:	90 52       	subi	r25, 0x20	; 32
    be9a:	93 30       	cpi	r25, 0x03	; 3
    be9c:	38 f4       	brcc	.+14     	; 0xbeac <vfprintf+0x134>
    be9e:	24 e0       	ldi	r18, 0x04	; 4
    bea0:	30 e0       	ldi	r19, 0x00	; 0
    bea2:	a2 0e       	add	r10, r18
    bea4:	b3 1e       	adc	r11, r19
    bea6:	3f e3       	ldi	r19, 0x3F	; 63
    bea8:	39 83       	std	Y+1, r19	; 0x01
    beaa:	0f c0       	rjmp	.+30     	; 0xbeca <vfprintf+0x152>
    beac:	83 36       	cpi	r24, 0x63	; 99
    beae:	31 f0       	breq	.+12     	; 0xbebc <vfprintf+0x144>
    beb0:	83 37       	cpi	r24, 0x73	; 115
    beb2:	81 f0       	breq	.+32     	; 0xbed4 <vfprintf+0x15c>
    beb4:	83 35       	cpi	r24, 0x53	; 83
    beb6:	09 f0       	breq	.+2      	; 0xbeba <vfprintf+0x142>
    beb8:	5a c0       	rjmp	.+180    	; 0xbf6e <vfprintf+0x1f6>
    beba:	22 c0       	rjmp	.+68     	; 0xbf00 <vfprintf+0x188>
    bebc:	f5 01       	movw	r30, r10
    bebe:	80 81       	ld	r24, Z
    bec0:	89 83       	std	Y+1, r24	; 0x01
    bec2:	22 e0       	ldi	r18, 0x02	; 2
    bec4:	30 e0       	ldi	r19, 0x00	; 0
    bec6:	a2 0e       	add	r10, r18
    bec8:	b3 1e       	adc	r11, r19
    beca:	21 e0       	ldi	r18, 0x01	; 1
    becc:	c2 2e       	mov	r12, r18
    bece:	d1 2c       	mov	r13, r1
    bed0:	42 01       	movw	r8, r4
    bed2:	14 c0       	rjmp	.+40     	; 0xbefc <vfprintf+0x184>
    bed4:	92 e0       	ldi	r25, 0x02	; 2
    bed6:	29 2e       	mov	r2, r25
    bed8:	31 2c       	mov	r3, r1
    beda:	2a 0c       	add	r2, r10
    bedc:	3b 1c       	adc	r3, r11
    bede:	f5 01       	movw	r30, r10
    bee0:	80 80       	ld	r8, Z
    bee2:	91 80       	ldd	r9, Z+1	; 0x01
    bee4:	16 ff       	sbrs	r17, 6
    bee6:	03 c0       	rjmp	.+6      	; 0xbeee <vfprintf+0x176>
    bee8:	6f 2d       	mov	r22, r15
    beea:	70 e0       	ldi	r23, 0x00	; 0
    beec:	02 c0       	rjmp	.+4      	; 0xbef2 <vfprintf+0x17a>
    beee:	6f ef       	ldi	r22, 0xFF	; 255
    bef0:	7f ef       	ldi	r23, 0xFF	; 255
    bef2:	c4 01       	movw	r24, r8
    bef4:	0e 94 d1 60 	call	0xc1a2	; 0xc1a2 <strnlen>
    bef8:	6c 01       	movw	r12, r24
    befa:	51 01       	movw	r10, r2
    befc:	1f 77       	andi	r17, 0x7F	; 127
    befe:	15 c0       	rjmp	.+42     	; 0xbf2a <vfprintf+0x1b2>
    bf00:	82 e0       	ldi	r24, 0x02	; 2
    bf02:	28 2e       	mov	r2, r24
    bf04:	31 2c       	mov	r3, r1
    bf06:	2a 0c       	add	r2, r10
    bf08:	3b 1c       	adc	r3, r11
    bf0a:	f5 01       	movw	r30, r10
    bf0c:	80 80       	ld	r8, Z
    bf0e:	91 80       	ldd	r9, Z+1	; 0x01
    bf10:	16 ff       	sbrs	r17, 6
    bf12:	03 c0       	rjmp	.+6      	; 0xbf1a <vfprintf+0x1a2>
    bf14:	6f 2d       	mov	r22, r15
    bf16:	70 e0       	ldi	r23, 0x00	; 0
    bf18:	02 c0       	rjmp	.+4      	; 0xbf1e <vfprintf+0x1a6>
    bf1a:	6f ef       	ldi	r22, 0xFF	; 255
    bf1c:	7f ef       	ldi	r23, 0xFF	; 255
    bf1e:	c4 01       	movw	r24, r8
    bf20:	0e 94 bd 60 	call	0xc17a	; 0xc17a <strnlen_P>
    bf24:	6c 01       	movw	r12, r24
    bf26:	10 68       	ori	r17, 0x80	; 128
    bf28:	51 01       	movw	r10, r2
    bf2a:	13 fd       	sbrc	r17, 3
    bf2c:	1c c0       	rjmp	.+56     	; 0xbf66 <vfprintf+0x1ee>
    bf2e:	06 c0       	rjmp	.+12     	; 0xbf3c <vfprintf+0x1c4>
    bf30:	80 e2       	ldi	r24, 0x20	; 32
    bf32:	90 e0       	ldi	r25, 0x00	; 0
    bf34:	b3 01       	movw	r22, r6
    bf36:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    bf3a:	ea 94       	dec	r14
    bf3c:	8e 2d       	mov	r24, r14
    bf3e:	90 e0       	ldi	r25, 0x00	; 0
    bf40:	c8 16       	cp	r12, r24
    bf42:	d9 06       	cpc	r13, r25
    bf44:	a8 f3       	brcs	.-22     	; 0xbf30 <vfprintf+0x1b8>
    bf46:	0f c0       	rjmp	.+30     	; 0xbf66 <vfprintf+0x1ee>
    bf48:	f4 01       	movw	r30, r8
    bf4a:	17 fd       	sbrc	r17, 7
    bf4c:	85 91       	lpm	r24, Z+
    bf4e:	17 ff       	sbrs	r17, 7
    bf50:	81 91       	ld	r24, Z+
    bf52:	4f 01       	movw	r8, r30
    bf54:	90 e0       	ldi	r25, 0x00	; 0
    bf56:	b3 01       	movw	r22, r6
    bf58:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    bf5c:	e1 10       	cpse	r14, r1
    bf5e:	ea 94       	dec	r14
    bf60:	08 94       	sec
    bf62:	c1 08       	sbc	r12, r1
    bf64:	d1 08       	sbc	r13, r1
    bf66:	c1 14       	cp	r12, r1
    bf68:	d1 04       	cpc	r13, r1
    bf6a:	71 f7       	brne	.-36     	; 0xbf48 <vfprintf+0x1d0>
    bf6c:	e7 c0       	rjmp	.+462    	; 0xc13c <vfprintf+0x3c4>
    bf6e:	84 36       	cpi	r24, 0x64	; 100
    bf70:	11 f0       	breq	.+4      	; 0xbf76 <vfprintf+0x1fe>
    bf72:	89 36       	cpi	r24, 0x69	; 105
    bf74:	51 f5       	brne	.+84     	; 0xbfca <vfprintf+0x252>
    bf76:	f5 01       	movw	r30, r10
    bf78:	17 ff       	sbrs	r17, 7
    bf7a:	07 c0       	rjmp	.+14     	; 0xbf8a <vfprintf+0x212>
    bf7c:	80 81       	ld	r24, Z
    bf7e:	91 81       	ldd	r25, Z+1	; 0x01
    bf80:	a2 81       	ldd	r26, Z+2	; 0x02
    bf82:	b3 81       	ldd	r27, Z+3	; 0x03
    bf84:	24 e0       	ldi	r18, 0x04	; 4
    bf86:	30 e0       	ldi	r19, 0x00	; 0
    bf88:	08 c0       	rjmp	.+16     	; 0xbf9a <vfprintf+0x222>
    bf8a:	80 81       	ld	r24, Z
    bf8c:	91 81       	ldd	r25, Z+1	; 0x01
    bf8e:	aa 27       	eor	r26, r26
    bf90:	97 fd       	sbrc	r25, 7
    bf92:	a0 95       	com	r26
    bf94:	ba 2f       	mov	r27, r26
    bf96:	22 e0       	ldi	r18, 0x02	; 2
    bf98:	30 e0       	ldi	r19, 0x00	; 0
    bf9a:	a2 0e       	add	r10, r18
    bf9c:	b3 1e       	adc	r11, r19
    bf9e:	01 2f       	mov	r16, r17
    bfa0:	0f 76       	andi	r16, 0x6F	; 111
    bfa2:	b7 ff       	sbrs	r27, 7
    bfa4:	08 c0       	rjmp	.+16     	; 0xbfb6 <vfprintf+0x23e>
    bfa6:	b0 95       	com	r27
    bfa8:	a0 95       	com	r26
    bfaa:	90 95       	com	r25
    bfac:	81 95       	neg	r24
    bfae:	9f 4f       	sbci	r25, 0xFF	; 255
    bfb0:	af 4f       	sbci	r26, 0xFF	; 255
    bfb2:	bf 4f       	sbci	r27, 0xFF	; 255
    bfb4:	00 68       	ori	r16, 0x80	; 128
    bfb6:	bc 01       	movw	r22, r24
    bfb8:	cd 01       	movw	r24, r26
    bfba:	a2 01       	movw	r20, r4
    bfbc:	2a e0       	ldi	r18, 0x0A	; 10
    bfbe:	30 e0       	ldi	r19, 0x00	; 0
    bfc0:	0e 94 18 61 	call	0xc230	; 0xc230 <__ultoa_invert>
    bfc4:	d8 2e       	mov	r13, r24
    bfc6:	d4 18       	sub	r13, r4
    bfc8:	3f c0       	rjmp	.+126    	; 0xc048 <vfprintf+0x2d0>
    bfca:	85 37       	cpi	r24, 0x75	; 117
    bfcc:	21 f4       	brne	.+8      	; 0xbfd6 <vfprintf+0x25e>
    bfce:	1f 7e       	andi	r17, 0xEF	; 239
    bfd0:	2a e0       	ldi	r18, 0x0A	; 10
    bfd2:	30 e0       	ldi	r19, 0x00	; 0
    bfd4:	20 c0       	rjmp	.+64     	; 0xc016 <vfprintf+0x29e>
    bfd6:	19 7f       	andi	r17, 0xF9	; 249
    bfd8:	8f 36       	cpi	r24, 0x6F	; 111
    bfda:	a9 f0       	breq	.+42     	; 0xc006 <vfprintf+0x28e>
    bfdc:	80 37       	cpi	r24, 0x70	; 112
    bfde:	20 f4       	brcc	.+8      	; 0xbfe8 <vfprintf+0x270>
    bfe0:	88 35       	cpi	r24, 0x58	; 88
    bfe2:	09 f0       	breq	.+2      	; 0xbfe6 <vfprintf+0x26e>
    bfe4:	ae c0       	rjmp	.+348    	; 0xc142 <vfprintf+0x3ca>
    bfe6:	0b c0       	rjmp	.+22     	; 0xbffe <vfprintf+0x286>
    bfe8:	80 37       	cpi	r24, 0x70	; 112
    bfea:	21 f0       	breq	.+8      	; 0xbff4 <vfprintf+0x27c>
    bfec:	88 37       	cpi	r24, 0x78	; 120
    bfee:	09 f0       	breq	.+2      	; 0xbff2 <vfprintf+0x27a>
    bff0:	a8 c0       	rjmp	.+336    	; 0xc142 <vfprintf+0x3ca>
    bff2:	01 c0       	rjmp	.+2      	; 0xbff6 <vfprintf+0x27e>
    bff4:	10 61       	ori	r17, 0x10	; 16
    bff6:	14 ff       	sbrs	r17, 4
    bff8:	09 c0       	rjmp	.+18     	; 0xc00c <vfprintf+0x294>
    bffa:	14 60       	ori	r17, 0x04	; 4
    bffc:	07 c0       	rjmp	.+14     	; 0xc00c <vfprintf+0x294>
    bffe:	14 ff       	sbrs	r17, 4
    c000:	08 c0       	rjmp	.+16     	; 0xc012 <vfprintf+0x29a>
    c002:	16 60       	ori	r17, 0x06	; 6
    c004:	06 c0       	rjmp	.+12     	; 0xc012 <vfprintf+0x29a>
    c006:	28 e0       	ldi	r18, 0x08	; 8
    c008:	30 e0       	ldi	r19, 0x00	; 0
    c00a:	05 c0       	rjmp	.+10     	; 0xc016 <vfprintf+0x29e>
    c00c:	20 e1       	ldi	r18, 0x10	; 16
    c00e:	30 e0       	ldi	r19, 0x00	; 0
    c010:	02 c0       	rjmp	.+4      	; 0xc016 <vfprintf+0x29e>
    c012:	20 e1       	ldi	r18, 0x10	; 16
    c014:	32 e0       	ldi	r19, 0x02	; 2
    c016:	f5 01       	movw	r30, r10
    c018:	17 ff       	sbrs	r17, 7
    c01a:	07 c0       	rjmp	.+14     	; 0xc02a <vfprintf+0x2b2>
    c01c:	60 81       	ld	r22, Z
    c01e:	71 81       	ldd	r23, Z+1	; 0x01
    c020:	82 81       	ldd	r24, Z+2	; 0x02
    c022:	93 81       	ldd	r25, Z+3	; 0x03
    c024:	44 e0       	ldi	r20, 0x04	; 4
    c026:	50 e0       	ldi	r21, 0x00	; 0
    c028:	06 c0       	rjmp	.+12     	; 0xc036 <vfprintf+0x2be>
    c02a:	60 81       	ld	r22, Z
    c02c:	71 81       	ldd	r23, Z+1	; 0x01
    c02e:	80 e0       	ldi	r24, 0x00	; 0
    c030:	90 e0       	ldi	r25, 0x00	; 0
    c032:	42 e0       	ldi	r20, 0x02	; 2
    c034:	50 e0       	ldi	r21, 0x00	; 0
    c036:	a4 0e       	add	r10, r20
    c038:	b5 1e       	adc	r11, r21
    c03a:	a2 01       	movw	r20, r4
    c03c:	0e 94 18 61 	call	0xc230	; 0xc230 <__ultoa_invert>
    c040:	d8 2e       	mov	r13, r24
    c042:	d4 18       	sub	r13, r4
    c044:	01 2f       	mov	r16, r17
    c046:	0f 77       	andi	r16, 0x7F	; 127
    c048:	06 ff       	sbrs	r16, 6
    c04a:	09 c0       	rjmp	.+18     	; 0xc05e <vfprintf+0x2e6>
    c04c:	0e 7f       	andi	r16, 0xFE	; 254
    c04e:	df 14       	cp	r13, r15
    c050:	30 f4       	brcc	.+12     	; 0xc05e <vfprintf+0x2e6>
    c052:	04 ff       	sbrs	r16, 4
    c054:	06 c0       	rjmp	.+12     	; 0xc062 <vfprintf+0x2ea>
    c056:	02 fd       	sbrc	r16, 2
    c058:	04 c0       	rjmp	.+8      	; 0xc062 <vfprintf+0x2ea>
    c05a:	0f 7e       	andi	r16, 0xEF	; 239
    c05c:	02 c0       	rjmp	.+4      	; 0xc062 <vfprintf+0x2ea>
    c05e:	1d 2d       	mov	r17, r13
    c060:	01 c0       	rjmp	.+2      	; 0xc064 <vfprintf+0x2ec>
    c062:	1f 2d       	mov	r17, r15
    c064:	80 2f       	mov	r24, r16
    c066:	90 e0       	ldi	r25, 0x00	; 0
    c068:	04 ff       	sbrs	r16, 4
    c06a:	0c c0       	rjmp	.+24     	; 0xc084 <vfprintf+0x30c>
    c06c:	fe 01       	movw	r30, r28
    c06e:	ed 0d       	add	r30, r13
    c070:	f1 1d       	adc	r31, r1
    c072:	20 81       	ld	r18, Z
    c074:	20 33       	cpi	r18, 0x30	; 48
    c076:	11 f4       	brne	.+4      	; 0xc07c <vfprintf+0x304>
    c078:	09 7e       	andi	r16, 0xE9	; 233
    c07a:	09 c0       	rjmp	.+18     	; 0xc08e <vfprintf+0x316>
    c07c:	02 ff       	sbrs	r16, 2
    c07e:	06 c0       	rjmp	.+12     	; 0xc08c <vfprintf+0x314>
    c080:	1e 5f       	subi	r17, 0xFE	; 254
    c082:	05 c0       	rjmp	.+10     	; 0xc08e <vfprintf+0x316>
    c084:	86 78       	andi	r24, 0x86	; 134
    c086:	90 70       	andi	r25, 0x00	; 0
    c088:	00 97       	sbiw	r24, 0x00	; 0
    c08a:	09 f0       	breq	.+2      	; 0xc08e <vfprintf+0x316>
    c08c:	1f 5f       	subi	r17, 0xFF	; 255
    c08e:	80 2e       	mov	r8, r16
    c090:	99 24       	eor	r9, r9
    c092:	03 fd       	sbrc	r16, 3
    c094:	12 c0       	rjmp	.+36     	; 0xc0ba <vfprintf+0x342>
    c096:	00 ff       	sbrs	r16, 0
    c098:	0d c0       	rjmp	.+26     	; 0xc0b4 <vfprintf+0x33c>
    c09a:	fd 2c       	mov	r15, r13
    c09c:	1e 15       	cp	r17, r14
    c09e:	50 f4       	brcc	.+20     	; 0xc0b4 <vfprintf+0x33c>
    c0a0:	fe 0c       	add	r15, r14
    c0a2:	f1 1a       	sub	r15, r17
    c0a4:	1e 2d       	mov	r17, r14
    c0a6:	06 c0       	rjmp	.+12     	; 0xc0b4 <vfprintf+0x33c>
    c0a8:	80 e2       	ldi	r24, 0x20	; 32
    c0aa:	90 e0       	ldi	r25, 0x00	; 0
    c0ac:	b3 01       	movw	r22, r6
    c0ae:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    c0b2:	1f 5f       	subi	r17, 0xFF	; 255
    c0b4:	1e 15       	cp	r17, r14
    c0b6:	c0 f3       	brcs	.-16     	; 0xc0a8 <vfprintf+0x330>
    c0b8:	04 c0       	rjmp	.+8      	; 0xc0c2 <vfprintf+0x34a>
    c0ba:	1e 15       	cp	r17, r14
    c0bc:	10 f4       	brcc	.+4      	; 0xc0c2 <vfprintf+0x34a>
    c0be:	e1 1a       	sub	r14, r17
    c0c0:	01 c0       	rjmp	.+2      	; 0xc0c4 <vfprintf+0x34c>
    c0c2:	ee 24       	eor	r14, r14
    c0c4:	84 fe       	sbrs	r8, 4
    c0c6:	0f c0       	rjmp	.+30     	; 0xc0e6 <vfprintf+0x36e>
    c0c8:	80 e3       	ldi	r24, 0x30	; 48
    c0ca:	90 e0       	ldi	r25, 0x00	; 0
    c0cc:	b3 01       	movw	r22, r6
    c0ce:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    c0d2:	82 fe       	sbrs	r8, 2
    c0d4:	1f c0       	rjmp	.+62     	; 0xc114 <vfprintf+0x39c>
    c0d6:	81 fe       	sbrs	r8, 1
    c0d8:	03 c0       	rjmp	.+6      	; 0xc0e0 <vfprintf+0x368>
    c0da:	88 e5       	ldi	r24, 0x58	; 88
    c0dc:	90 e0       	ldi	r25, 0x00	; 0
    c0de:	10 c0       	rjmp	.+32     	; 0xc100 <vfprintf+0x388>
    c0e0:	88 e7       	ldi	r24, 0x78	; 120
    c0e2:	90 e0       	ldi	r25, 0x00	; 0
    c0e4:	0d c0       	rjmp	.+26     	; 0xc100 <vfprintf+0x388>
    c0e6:	c4 01       	movw	r24, r8
    c0e8:	86 78       	andi	r24, 0x86	; 134
    c0ea:	90 70       	andi	r25, 0x00	; 0
    c0ec:	00 97       	sbiw	r24, 0x00	; 0
    c0ee:	91 f0       	breq	.+36     	; 0xc114 <vfprintf+0x39c>
    c0f0:	81 fc       	sbrc	r8, 1
    c0f2:	02 c0       	rjmp	.+4      	; 0xc0f8 <vfprintf+0x380>
    c0f4:	80 e2       	ldi	r24, 0x20	; 32
    c0f6:	01 c0       	rjmp	.+2      	; 0xc0fa <vfprintf+0x382>
    c0f8:	8b e2       	ldi	r24, 0x2B	; 43
    c0fa:	07 fd       	sbrc	r16, 7
    c0fc:	8d e2       	ldi	r24, 0x2D	; 45
    c0fe:	90 e0       	ldi	r25, 0x00	; 0
    c100:	b3 01       	movw	r22, r6
    c102:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    c106:	06 c0       	rjmp	.+12     	; 0xc114 <vfprintf+0x39c>
    c108:	80 e3       	ldi	r24, 0x30	; 48
    c10a:	90 e0       	ldi	r25, 0x00	; 0
    c10c:	b3 01       	movw	r22, r6
    c10e:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    c112:	fa 94       	dec	r15
    c114:	df 14       	cp	r13, r15
    c116:	c0 f3       	brcs	.-16     	; 0xc108 <vfprintf+0x390>
    c118:	da 94       	dec	r13
    c11a:	f2 01       	movw	r30, r4
    c11c:	ed 0d       	add	r30, r13
    c11e:	f1 1d       	adc	r31, r1
    c120:	80 81       	ld	r24, Z
    c122:	90 e0       	ldi	r25, 0x00	; 0
    c124:	b3 01       	movw	r22, r6
    c126:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    c12a:	dd 20       	and	r13, r13
    c12c:	a9 f7       	brne	.-22     	; 0xc118 <vfprintf+0x3a0>
    c12e:	06 c0       	rjmp	.+12     	; 0xc13c <vfprintf+0x3c4>
    c130:	80 e2       	ldi	r24, 0x20	; 32
    c132:	90 e0       	ldi	r25, 0x00	; 0
    c134:	b3 01       	movw	r22, r6
    c136:	0e 94 ec 60 	call	0xc1d8	; 0xc1d8 <fputc>
    c13a:	ea 94       	dec	r14
    c13c:	ee 20       	and	r14, r14
    c13e:	c1 f7       	brne	.-16     	; 0xc130 <vfprintf+0x3b8>
    c140:	40 ce       	rjmp	.-896    	; 0xbdc2 <vfprintf+0x4a>
    c142:	f3 01       	movw	r30, r6
    c144:	86 81       	ldd	r24, Z+6	; 0x06
    c146:	97 81       	ldd	r25, Z+7	; 0x07
    c148:	02 c0       	rjmp	.+4      	; 0xc14e <vfprintf+0x3d6>
    c14a:	8f ef       	ldi	r24, 0xFF	; 255
    c14c:	9f ef       	ldi	r25, 0xFF	; 255
    c14e:	2d 96       	adiw	r28, 0x0d	; 13
    c150:	cd bf       	out	0x3d, r28	; 61
    c152:	de bf       	out	0x3e, r29	; 62
    c154:	df 91       	pop	r29
    c156:	cf 91       	pop	r28
    c158:	1f 91       	pop	r17
    c15a:	0f 91       	pop	r16
    c15c:	ff 90       	pop	r15
    c15e:	ef 90       	pop	r14
    c160:	df 90       	pop	r13
    c162:	cf 90       	pop	r12
    c164:	bf 90       	pop	r11
    c166:	af 90       	pop	r10
    c168:	9f 90       	pop	r9
    c16a:	8f 90       	pop	r8
    c16c:	7f 90       	pop	r7
    c16e:	6f 90       	pop	r6
    c170:	5f 90       	pop	r5
    c172:	4f 90       	pop	r4
    c174:	3f 90       	pop	r3
    c176:	2f 90       	pop	r2
    c178:	08 95       	ret

0000c17a <strnlen_P>:
    c17a:	fc 01       	movw	r30, r24
    c17c:	05 90       	lpm	r0, Z+
    c17e:	61 50       	subi	r22, 0x01	; 1
    c180:	70 40       	sbci	r23, 0x00	; 0
    c182:	01 10       	cpse	r0, r1
    c184:	d8 f7       	brcc	.-10     	; 0xc17c <strnlen_P+0x2>
    c186:	80 95       	com	r24
    c188:	90 95       	com	r25
    c18a:	8e 0f       	add	r24, r30
    c18c:	9f 1f       	adc	r25, r31
    c18e:	08 95       	ret

0000c190 <memcpy>:
    c190:	fb 01       	movw	r30, r22
    c192:	dc 01       	movw	r26, r24
    c194:	02 c0       	rjmp	.+4      	; 0xc19a <memcpy+0xa>
    c196:	01 90       	ld	r0, Z+
    c198:	0d 92       	st	X+, r0
    c19a:	41 50       	subi	r20, 0x01	; 1
    c19c:	50 40       	sbci	r21, 0x00	; 0
    c19e:	d8 f7       	brcc	.-10     	; 0xc196 <memcpy+0x6>
    c1a0:	08 95       	ret

0000c1a2 <strnlen>:
    c1a2:	fc 01       	movw	r30, r24
    c1a4:	61 50       	subi	r22, 0x01	; 1
    c1a6:	70 40       	sbci	r23, 0x00	; 0
    c1a8:	01 90       	ld	r0, Z+
    c1aa:	01 10       	cpse	r0, r1
    c1ac:	d8 f7       	brcc	.-10     	; 0xc1a4 <strnlen+0x2>
    c1ae:	80 95       	com	r24
    c1b0:	90 95       	com	r25
    c1b2:	8e 0f       	add	r24, r30
    c1b4:	9f 1f       	adc	r25, r31
    c1b6:	08 95       	ret

0000c1b8 <strrev>:
    c1b8:	dc 01       	movw	r26, r24
    c1ba:	fc 01       	movw	r30, r24
    c1bc:	67 2f       	mov	r22, r23
    c1be:	71 91       	ld	r23, Z+
    c1c0:	77 23       	and	r23, r23
    c1c2:	e1 f7       	brne	.-8      	; 0xc1bc <strrev+0x4>
    c1c4:	32 97       	sbiw	r30, 0x02	; 2
    c1c6:	04 c0       	rjmp	.+8      	; 0xc1d0 <strrev+0x18>
    c1c8:	7c 91       	ld	r23, X
    c1ca:	6d 93       	st	X+, r22
    c1cc:	70 83       	st	Z, r23
    c1ce:	62 91       	ld	r22, -Z
    c1d0:	ae 17       	cp	r26, r30
    c1d2:	bf 07       	cpc	r27, r31
    c1d4:	c8 f3       	brcs	.-14     	; 0xc1c8 <strrev+0x10>
    c1d6:	08 95       	ret

0000c1d8 <fputc>:
    c1d8:	0f 93       	push	r16
    c1da:	1f 93       	push	r17
    c1dc:	cf 93       	push	r28
    c1de:	df 93       	push	r29
    c1e0:	8c 01       	movw	r16, r24
    c1e2:	eb 01       	movw	r28, r22
    c1e4:	8b 81       	ldd	r24, Y+3	; 0x03
    c1e6:	81 ff       	sbrs	r24, 1
    c1e8:	1b c0       	rjmp	.+54     	; 0xc220 <fputc+0x48>
    c1ea:	82 ff       	sbrs	r24, 2
    c1ec:	0d c0       	rjmp	.+26     	; 0xc208 <fputc+0x30>
    c1ee:	2e 81       	ldd	r18, Y+6	; 0x06
    c1f0:	3f 81       	ldd	r19, Y+7	; 0x07
    c1f2:	8c 81       	ldd	r24, Y+4	; 0x04
    c1f4:	9d 81       	ldd	r25, Y+5	; 0x05
    c1f6:	28 17       	cp	r18, r24
    c1f8:	39 07       	cpc	r19, r25
    c1fa:	64 f4       	brge	.+24     	; 0xc214 <fputc+0x3c>
    c1fc:	e8 81       	ld	r30, Y
    c1fe:	f9 81       	ldd	r31, Y+1	; 0x01
    c200:	01 93       	st	Z+, r16
    c202:	e8 83       	st	Y, r30
    c204:	f9 83       	std	Y+1, r31	; 0x01
    c206:	06 c0       	rjmp	.+12     	; 0xc214 <fputc+0x3c>
    c208:	e8 85       	ldd	r30, Y+8	; 0x08
    c20a:	f9 85       	ldd	r31, Y+9	; 0x09
    c20c:	80 2f       	mov	r24, r16
    c20e:	19 95       	eicall
    c210:	00 97       	sbiw	r24, 0x00	; 0
    c212:	31 f4       	brne	.+12     	; 0xc220 <fputc+0x48>
    c214:	8e 81       	ldd	r24, Y+6	; 0x06
    c216:	9f 81       	ldd	r25, Y+7	; 0x07
    c218:	01 96       	adiw	r24, 0x01	; 1
    c21a:	8e 83       	std	Y+6, r24	; 0x06
    c21c:	9f 83       	std	Y+7, r25	; 0x07
    c21e:	02 c0       	rjmp	.+4      	; 0xc224 <fputc+0x4c>
    c220:	0f ef       	ldi	r16, 0xFF	; 255
    c222:	1f ef       	ldi	r17, 0xFF	; 255
    c224:	c8 01       	movw	r24, r16
    c226:	df 91       	pop	r29
    c228:	cf 91       	pop	r28
    c22a:	1f 91       	pop	r17
    c22c:	0f 91       	pop	r16
    c22e:	08 95       	ret

0000c230 <__ultoa_invert>:
    c230:	fa 01       	movw	r30, r20
    c232:	aa 27       	eor	r26, r26
    c234:	28 30       	cpi	r18, 0x08	; 8
    c236:	51 f1       	breq	.+84     	; 0xc28c <__ultoa_invert+0x5c>
    c238:	20 31       	cpi	r18, 0x10	; 16
    c23a:	81 f1       	breq	.+96     	; 0xc29c <__ultoa_invert+0x6c>
    c23c:	e8 94       	clt
    c23e:	6f 93       	push	r22
    c240:	6e 7f       	andi	r22, 0xFE	; 254
    c242:	6e 5f       	subi	r22, 0xFE	; 254
    c244:	7f 4f       	sbci	r23, 0xFF	; 255
    c246:	8f 4f       	sbci	r24, 0xFF	; 255
    c248:	9f 4f       	sbci	r25, 0xFF	; 255
    c24a:	af 4f       	sbci	r26, 0xFF	; 255
    c24c:	b1 e0       	ldi	r27, 0x01	; 1
    c24e:	3e d0       	rcall	.+124    	; 0xc2cc <__ultoa_invert+0x9c>
    c250:	b4 e0       	ldi	r27, 0x04	; 4
    c252:	3c d0       	rcall	.+120    	; 0xc2cc <__ultoa_invert+0x9c>
    c254:	67 0f       	add	r22, r23
    c256:	78 1f       	adc	r23, r24
    c258:	89 1f       	adc	r24, r25
    c25a:	9a 1f       	adc	r25, r26
    c25c:	a1 1d       	adc	r26, r1
    c25e:	68 0f       	add	r22, r24
    c260:	79 1f       	adc	r23, r25
    c262:	8a 1f       	adc	r24, r26
    c264:	91 1d       	adc	r25, r1
    c266:	a1 1d       	adc	r26, r1
    c268:	6a 0f       	add	r22, r26
    c26a:	71 1d       	adc	r23, r1
    c26c:	81 1d       	adc	r24, r1
    c26e:	91 1d       	adc	r25, r1
    c270:	a1 1d       	adc	r26, r1
    c272:	20 d0       	rcall	.+64     	; 0xc2b4 <__ultoa_invert+0x84>
    c274:	09 f4       	brne	.+2      	; 0xc278 <__ultoa_invert+0x48>
    c276:	68 94       	set
    c278:	3f 91       	pop	r19
    c27a:	2a e0       	ldi	r18, 0x0A	; 10
    c27c:	26 9f       	mul	r18, r22
    c27e:	11 24       	eor	r1, r1
    c280:	30 19       	sub	r19, r0
    c282:	30 5d       	subi	r19, 0xD0	; 208
    c284:	31 93       	st	Z+, r19
    c286:	de f6       	brtc	.-74     	; 0xc23e <__ultoa_invert+0xe>
    c288:	cf 01       	movw	r24, r30
    c28a:	08 95       	ret
    c28c:	46 2f       	mov	r20, r22
    c28e:	47 70       	andi	r20, 0x07	; 7
    c290:	40 5d       	subi	r20, 0xD0	; 208
    c292:	41 93       	st	Z+, r20
    c294:	b3 e0       	ldi	r27, 0x03	; 3
    c296:	0f d0       	rcall	.+30     	; 0xc2b6 <__ultoa_invert+0x86>
    c298:	c9 f7       	brne	.-14     	; 0xc28c <__ultoa_invert+0x5c>
    c29a:	f6 cf       	rjmp	.-20     	; 0xc288 <__ultoa_invert+0x58>
    c29c:	46 2f       	mov	r20, r22
    c29e:	4f 70       	andi	r20, 0x0F	; 15
    c2a0:	40 5d       	subi	r20, 0xD0	; 208
    c2a2:	4a 33       	cpi	r20, 0x3A	; 58
    c2a4:	18 f0       	brcs	.+6      	; 0xc2ac <__ultoa_invert+0x7c>
    c2a6:	49 5d       	subi	r20, 0xD9	; 217
    c2a8:	31 fd       	sbrc	r19, 1
    c2aa:	40 52       	subi	r20, 0x20	; 32
    c2ac:	41 93       	st	Z+, r20
    c2ae:	02 d0       	rcall	.+4      	; 0xc2b4 <__ultoa_invert+0x84>
    c2b0:	a9 f7       	brne	.-22     	; 0xc29c <__ultoa_invert+0x6c>
    c2b2:	ea cf       	rjmp	.-44     	; 0xc288 <__ultoa_invert+0x58>
    c2b4:	b4 e0       	ldi	r27, 0x04	; 4
    c2b6:	a6 95       	lsr	r26
    c2b8:	97 95       	ror	r25
    c2ba:	87 95       	ror	r24
    c2bc:	77 95       	ror	r23
    c2be:	67 95       	ror	r22
    c2c0:	ba 95       	dec	r27
    c2c2:	c9 f7       	brne	.-14     	; 0xc2b6 <__ultoa_invert+0x86>
    c2c4:	00 97       	sbiw	r24, 0x00	; 0
    c2c6:	61 05       	cpc	r22, r1
    c2c8:	71 05       	cpc	r23, r1
    c2ca:	08 95       	ret
    c2cc:	9b 01       	movw	r18, r22
    c2ce:	ac 01       	movw	r20, r24
    c2d0:	0a 2e       	mov	r0, r26
    c2d2:	06 94       	lsr	r0
    c2d4:	57 95       	ror	r21
    c2d6:	47 95       	ror	r20
    c2d8:	37 95       	ror	r19
    c2da:	27 95       	ror	r18
    c2dc:	ba 95       	dec	r27
    c2de:	c9 f7       	brne	.-14     	; 0xc2d2 <__ultoa_invert+0xa2>
    c2e0:	62 0f       	add	r22, r18
    c2e2:	73 1f       	adc	r23, r19
    c2e4:	84 1f       	adc	r24, r20
    c2e6:	95 1f       	adc	r25, r21
    c2e8:	a0 1d       	adc	r26, r0
    c2ea:	08 95       	ret

0000c2ec <_exit>:
    c2ec:	f8 94       	cli

0000c2ee <__stop_program>:
    c2ee:	ff cf       	rjmp	.-2      	; 0xc2ee <__stop_program>
