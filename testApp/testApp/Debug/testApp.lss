
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007946  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  00007946  000079da  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa9  0080210e  0080210e  00007ae8  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  00007ae8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a3e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000adb0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000bb8b  00000000  00000000  0000b1d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000026c3  00000000  00000000  00016d5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000058b1  00000000  00000000  0001941e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bcc  00000000  00000000  0001ecd0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004661  00000000  00000000  0002089c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008244  00000000  00000000  00024efd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fd97  00000000  00000000  0002d141  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001d8  00000000  00000000  001aced8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 c8 0d 	jmp	0x1b90	; 0x1b90 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 fb 12 	jmp	0x25f6	; 0x25f6 <__vector_16>
      44:	0c 94 d3 12 	jmp	0x25a6	; 0x25a6 <__vector_17>
      48:	0c 94 ab 12 	jmp	0x2556	; 0x2556 <__vector_18>
      4c:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <__vector_19>
      50:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 c0 1d 	jmp	0x3b80	; 0x3b80 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 a7 0f 	jmp	0x1f4e	; 0x1f4e <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 3d 12 	jmp	0x247a	; 0x247a <__vector_79>
     140:	0c 94 15 12 	jmp	0x242a	; 0x242a <__vector_80>
     144:	0c 94 ed 11 	jmp	0x23da	; 0x23da <__vector_81>
     148:	0c 94 c3 11 	jmp	0x2386	; 0x2386 <__vector_82>
     14c:	0c 94 ea 08 	jmp	0x11d4	; 0x11d4 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 77 0c 	jmp	0x18ee	; 0x18ee <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e6 e4       	ldi	r30, 0x46	; 70
     244:	f9 e7       	ldi	r31, 0x79	; 121
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a7 3b       	cpi	r26, 0xB7	; 183
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 db 06 	call	0xdb6	; 0xdb6 <main>
     26a:	0c 94 a1 3c 	jmp	0x7942	; 0x7942 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 2c 3e 	sts	0x3E2C, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 2c 3e 	sts	0x3E2C, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 1e 3e 	lds	r24, 0x3E1E
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 1d 3e 	lds	r24, 0x3E1D
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 2c 3e 	sts	0x3E2C, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	2c e2       	ldi	r18, 0x2C	; 44
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 1d 3e 	lds	r24, 0x3E1D
     376:	90 91 1e 3e 	lds	r25, 0x3E1E
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 1d 3e 	sts	0x3E1D, r16
     382:	10 93 1e 3e 	sts	0x3E1E, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 2c 3e 	sts	0x3E2C, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	ec ea       	ldi	r30, 0xAC	; 172
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 fd 37 	call	0x6ffa	; 0x6ffa <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 04 37 	call	0x6e08	; 0x6e08 <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 d1 37 	call	0x6fa2	; 0x6fa2 <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 fd 37 	call	0x6ffa	; 0x6ffa <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 04 37 	call	0x6e08	; 0x6e08 <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 8b 38 	call	0x7116	; 0x7116 <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     608:	10 92 32 3e 	sts	0x3E32, r1
}
     60c:	08 95       	ret

0000060e <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     60e:	80 ec       	ldi	r24, 0xC0	; 192
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	4b e0       	ldi	r20, 0x0B	; 11
     614:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     618:	e0 e5       	ldi	r30, 0x50	; 80
     61a:	f0 e0       	ldi	r31, 0x00	; 0
     61c:	80 81       	ld	r24, Z
     61e:	88 60       	ori	r24, 0x08	; 8
     620:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     622:	81 81       	ldd	r24, Z+1	; 0x01
     624:	83 ff       	sbrs	r24, 3
     626:	fd cf       	rjmp	.-6      	; 0x622 <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     628:	80 ec       	ldi	r24, 0xC0	; 192
     62a:	62 e0       	ldi	r22, 0x02	; 2
     62c:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     630:	e0 e5       	ldi	r30, 0x50	; 80
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	80 61       	ori	r24, 0x10	; 16
     638:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	84 ff       	sbrs	r24, 4
     63e:	fd cf       	rjmp	.-6      	; 0x63a <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     640:	84 e0       	ldi	r24, 0x04	; 4
     642:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     646:	81 e0       	ldi	r24, 0x01	; 1
     648:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <CLKSYS_Disable>
}
     64c:	08 95       	ret

0000064e <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     64e:	e0 e5       	ldi	r30, 0x50	; 80
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	82 60       	ori	r24, 0x02	; 2
     656:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     658:	80 e0       	ldi	r24, 0x00	; 0
     65a:	61 e0       	ldi	r22, 0x01	; 1
     65c:	0e 94 bc 1f 	call	0x3f78	; 0x3f78 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     660:	e0 e5       	ldi	r30, 0x50	; 80
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	81 81       	ldd	r24, Z+1	; 0x01
     666:	81 ff       	sbrs	r24, 1
     668:	fd cf       	rjmp	.-6      	; 0x664 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <CLKSYS_Disable>
	
}
     676:	08 95       	ret

00000678 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     678:	e0 e5       	ldi	r30, 0x50	; 80
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	80 81       	ld	r24, Z
     67e:	82 60       	ori	r24, 0x02	; 2
     680:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     682:	80 e0       	ldi	r24, 0x00	; 0
     684:	60 e0       	ldi	r22, 0x00	; 0
     686:	0e 94 bc 1f 	call	0x3f78	; 0x3f78 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     68a:	e0 e5       	ldi	r30, 0x50	; 80
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	81 81       	ldd	r24, Z+1	; 0x01
     690:	81 ff       	sbrs	r24, 1
     692:	fd cf       	rjmp	.-6      	; 0x68e <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     694:	81 e0       	ldi	r24, 0x01	; 1
     696:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <CLKSYS_Disable>
	
}
     6a0:	08 95       	ret

000006a2 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     6a2:	88 23       	and	r24, r24
     6a4:	29 f0       	breq	.+10     	; 0x6b0 <portExCS+0xe>
     6a6:	88 e0       	ldi	r24, 0x08	; 8
     6a8:	e0 e0       	ldi	r30, 0x00	; 0
     6aa:	f6 e0       	ldi	r31, 0x06	; 6
     6ac:	86 83       	std	Z+6, r24	; 0x06
     6ae:	04 c0       	rjmp	.+8      	; 0x6b8 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     6b0:	88 e0       	ldi	r24, 0x08	; 8
     6b2:	e0 e0       	ldi	r30, 0x00	; 0
     6b4:	f6 e0       	ldi	r31, 0x06	; 6
     6b6:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6b8:	8a e6       	ldi	r24, 0x6A	; 106
     6ba:	8a 95       	dec	r24
     6bc:	f1 f7       	brne	.-4      	; 0x6ba <portExCS+0x18>
     6be:	00 c0       	rjmp	.+0      	; 0x6c0 <portExCS+0x1e>
	}
	_delay_us(10);
}
     6c0:	08 95       	ret

000006c2 <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     6c2:	88 23       	and	r24, r24
     6c4:	79 f0       	breq	.+30     	; 0x6e4 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     6c6:	e0 ea       	ldi	r30, 0xA0	; 160
     6c8:	f6 e0       	ldi	r31, 0x06	; 6
     6ca:	80 e2       	ldi	r24, 0x20	; 32
     6cc:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     6ce:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	93 ec       	ldi	r25, 0xC3	; 195
     6d4:	a9 e0       	ldi	r26, 0x09	; 9
     6d6:	81 50       	subi	r24, 0x01	; 1
     6d8:	90 40       	sbci	r25, 0x00	; 0
     6da:	a0 40       	sbci	r26, 0x00	; 0
     6dc:	e1 f7       	brne	.-8      	; 0x6d6 <Ext1Power+0x14>
     6de:	00 c0       	rjmp	.+0      	; 0x6e0 <Ext1Power+0x1e>
     6e0:	00 00       	nop
     6e2:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     6e4:	e0 ea       	ldi	r30, 0xA0	; 160
     6e6:	f6 e0       	ldi	r31, 0x06	; 6
     6e8:	80 e2       	ldi	r24, 0x20	; 32
     6ea:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     6ec:	82 83       	std	Z+2, r24	; 0x02
     6ee:	08 95       	ret

000006f0 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     6f0:	88 23       	and	r24, r24
     6f2:	79 f0       	breq	.+30     	; 0x712 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     6f4:	e0 ea       	ldi	r30, 0xA0	; 160
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	80 e4       	ldi	r24, 0x40	; 64
     6fa:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     6fc:	85 83       	std	Z+5, r24	; 0x05
     6fe:	8f ef       	ldi	r24, 0xFF	; 255
     700:	93 ec       	ldi	r25, 0xC3	; 195
     702:	a9 e0       	ldi	r26, 0x09	; 9
     704:	81 50       	subi	r24, 0x01	; 1
     706:	90 40       	sbci	r25, 0x00	; 0
     708:	a0 40       	sbci	r26, 0x00	; 0
     70a:	e1 f7       	brne	.-8      	; 0x704 <Ext2Power+0x14>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <Ext2Power+0x1e>
     70e:	00 00       	nop
     710:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     712:	e0 ea       	ldi	r30, 0xA0	; 160
     714:	f6 e0       	ldi	r31, 0x06	; 6
     716:	80 e4       	ldi	r24, 0x40	; 64
     718:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     71a:	82 83       	std	Z+2, r24	; 0x02
     71c:	08 95       	ret

0000071e <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     71e:	88 23       	and	r24, r24
     720:	79 f0       	breq	.+30     	; 0x740 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     722:	e0 ea       	ldi	r30, 0xA0	; 160
     724:	f6 e0       	ldi	r31, 0x06	; 6
     726:	80 e8       	ldi	r24, 0x80	; 128
     728:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     72a:	85 83       	std	Z+5, r24	; 0x05
     72c:	8f ef       	ldi	r24, 0xFF	; 255
     72e:	93 ec       	ldi	r25, 0xC3	; 195
     730:	a9 e0       	ldi	r26, 0x09	; 9
     732:	81 50       	subi	r24, 0x01	; 1
     734:	90 40       	sbci	r25, 0x00	; 0
     736:	a0 40       	sbci	r26, 0x00	; 0
     738:	e1 f7       	brne	.-8      	; 0x732 <HVPower+0x14>
     73a:	00 c0       	rjmp	.+0      	; 0x73c <HVPower+0x1e>
     73c:	00 00       	nop
     73e:	05 c0       	rjmp	.+10     	; 0x74a <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f6 e0       	ldi	r31, 0x06	; 6
     744:	80 e8       	ldi	r24, 0x80	; 128
     746:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     748:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     74a:	af e3       	ldi	r26, 0x3F	; 63
     74c:	bf e1       	ldi	r27, 0x1F	; 31
     74e:	11 97       	sbiw	r26, 0x01	; 1
     750:	f1 f7       	brne	.-4      	; 0x74e <HVPower+0x30>
     752:	00 c0       	rjmp	.+0      	; 0x754 <HVPower+0x36>
     754:	00 00       	nop
	}
	_delay_us(1000);
}
     756:	08 95       	ret

00000758 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     758:	88 23       	and	r24, r24
     75a:	29 f0       	breq	.+10     	; 0x766 <lowerMuxCS+0xe>
     75c:	80 e1       	ldi	r24, 0x10	; 16
     75e:	e0 e8       	ldi	r30, 0x80	; 128
     760:	f6 e0       	ldi	r31, 0x06	; 6
     762:	86 83       	std	Z+6, r24	; 0x06
     764:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     766:	80 e1       	ldi	r24, 0x10	; 16
     768:	e0 e8       	ldi	r30, 0x80	; 128
     76a:	f6 e0       	ldi	r31, 0x06	; 6
     76c:	85 83       	std	Z+5, r24	; 0x05
     76e:	08 95       	ret

00000770 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     770:	88 23       	and	r24, r24
     772:	29 f0       	breq	.+10     	; 0x77e <upperMuxCS+0xe>
     774:	82 e0       	ldi	r24, 0x02	; 2
     776:	e0 e4       	ldi	r30, 0x40	; 64
     778:	f6 e0       	ldi	r31, 0x06	; 6
     77a:	86 83       	std	Z+6, r24	; 0x06
     77c:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     77e:	82 e0       	ldi	r24, 0x02	; 2
     780:	e0 e4       	ldi	r30, 0x40	; 64
     782:	f6 e0       	ldi	r31, 0x06	; 6
     784:	85 83       	std	Z+5, r24	; 0x05
     786:	08 95       	ret

00000788 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     788:	e0 e4       	ldi	r30, 0x40	; 64
     78a:	f6 e0       	ldi	r31, 0x06	; 6
     78c:	90 e1       	ldi	r25, 0x10	; 16
     78e:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     790:	28 e3       	ldi	r18, 0x38	; 56
     792:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     794:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     796:	81 65       	ori	r24, 0x51	; 81
     798:	a0 ec       	ldi	r26, 0xC0	; 192
     79a:	b8 e0       	ldi	r27, 0x08	; 8
     79c:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     79e:	11 96       	adiw	r26, 0x01	; 1
     7a0:	1c 92       	st	X, r1
     7a2:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7a4:	80 ea       	ldi	r24, 0xA0	; 160
     7a6:	81 83       	std	Z+1, r24	; 0x01

	
}
     7a8:	08 95       	ret

000007aa <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     7aa:	e0 e4       	ldi	r30, 0x40	; 64
     7ac:	f6 e0       	ldi	r31, 0x06	; 6
     7ae:	90 e1       	ldi	r25, 0x10	; 16
     7b0:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     7b2:	28 e3       	ldi	r18, 0x38	; 56
     7b4:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     7b6:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     7b8:	80 65       	ori	r24, 0x50	; 80
     7ba:	68 2b       	or	r22, r24
     7bc:	a0 ec       	ldi	r26, 0xC0	; 192
     7be:	b8 e0       	ldi	r27, 0x08	; 8
     7c0:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     7c2:	11 96       	adiw	r26, 0x01	; 1
     7c4:	1c 92       	st	X, r1
     7c6:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7c8:	80 ea       	ldi	r24, 0xA0	; 160
     7ca:	81 83       	std	Z+1, r24	; 0x01
}
     7cc:	08 95       	ret

000007ce <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     7ce:	88 23       	and	r24, r24
     7d0:	29 f0       	breq	.+10     	; 0x7dc <SPICS+0xe>
     7d2:	80 e1       	ldi	r24, 0x10	; 16
     7d4:	e0 e4       	ldi	r30, 0x40	; 64
     7d6:	f6 e0       	ldi	r31, 0x06	; 6
     7d8:	86 83       	std	Z+6, r24	; 0x06
     7da:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     7dc:	80 e1       	ldi	r24, 0x10	; 16
     7de:	e0 e4       	ldi	r30, 0x40	; 64
     7e0:	f6 e0       	ldi	r31, 0x06	; 6
     7e2:	85 83       	std	Z+5, r24	; 0x05
     7e4:	08 95       	ret

000007e6 <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     7e6:	e0 e4       	ldi	r30, 0x40	; 64
     7e8:	f6 e0       	ldi	r31, 0x06	; 6
     7ea:	80 e1       	ldi	r24, 0x10	; 16
     7ec:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     7ee:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     7f2:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     7f4:	80 eb       	ldi	r24, 0xB0	; 176
     7f6:	82 83       	std	Z+2, r24	; 0x02

}
     7f8:	08 95       	ret

000007fa <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     7fe:	c8 2f       	mov	r28, r24
     800:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     802:	d8 2f       	mov	r29, r24
     804:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	a9 01       	movw	r20, r18
     80c:	45 70       	andi	r20, 0x05	; 5
     80e:	50 70       	andi	r21, 0x00	; 0
     810:	41 15       	cp	r20, r1
     812:	51 05       	cpc	r21, r1
     814:	49 f0       	breq	.+18     	; 0x828 <set_filter+0x2e>
     816:	90 91 30 3e 	lds	r25, 0x3E30
     81a:	48 2f       	mov	r20, r24
     81c:	42 95       	swap	r20
     81e:	4f 70       	andi	r20, 0x0F	; 15
     820:	90 7f       	andi	r25, 0xF0	; 240
     822:	94 2b       	or	r25, r20
     824:	90 93 30 3e 	sts	0x3E30, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     828:	2a 70       	andi	r18, 0x0A	; 10
     82a:	30 70       	andi	r19, 0x00	; 0
     82c:	21 15       	cp	r18, r1
     82e:	31 05       	cpc	r19, r1
     830:	39 f0       	breq	.+14     	; 0x840 <set_filter+0x46>
     832:	90 91 30 3e 	lds	r25, 0x3E30
     836:	80 7f       	andi	r24, 0xF0	; 240
     838:	9f 70       	andi	r25, 0x0F	; 15
     83a:	89 2b       	or	r24, r25
     83c:	80 93 30 3e 	sts	0x3E30, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     840:	84 e0       	ldi	r24, 0x04	; 4
     842:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     846:	80 91 30 3e 	lds	r24, 0x3E30
     84a:	80 93 20 3e 	sts	0x3E20, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     84e:	cc 23       	and	r28, r28
     850:	19 f0       	breq	.+6      	; 0x858 <set_filter+0x5e>
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     858:	dd 23       	and	r29, r29
     85a:	19 f0       	breq	.+6      	; 0x862 <set_filter+0x68>
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>

	SPICS(TRUE);
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     868:	8f ef       	ldi	r24, 0xFF	; 255
     86a:	e0 ec       	ldi	r30, 0xC0	; 192
     86c:	f8 e0       	ldi	r31, 0x08	; 8
     86e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     870:	82 81       	ldd	r24, Z+2	; 0x02
     872:	88 23       	and	r24, r24
     874:	ec f7       	brge	.-6      	; 0x870 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     876:	e0 ec       	ldi	r30, 0xC0	; 192
     878:	f8 e0       	ldi	r31, 0x08	; 8
     87a:	83 81       	ldd	r24, Z+3	; 0x03
     87c:	80 93 2c 3e 	sts	0x3E2C, r24

	nop();
     880:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     882:	ac e2       	ldi	r26, 0x2C	; 44
     884:	be e3       	ldi	r27, 0x3E	; 62
     886:	1c 97       	sbiw	r26, 0x0c	; 12
     888:	8c 91       	ld	r24, X
     88a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     88c:	82 81       	ldd	r24, Z+2	; 0x02
     88e:	88 23       	and	r24, r24
     890:	ec f7       	brge	.-6      	; 0x88c <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     892:	e0 ec       	ldi	r30, 0xC0	; 192
     894:	f8 e0       	ldi	r31, 0x08	; 8
     896:	83 81       	ldd	r24, Z+3	; 0x03
     898:	80 93 2c 3e 	sts	0x3E2C, r24
	SPICS(FALSE);
     89c:	80 e0       	ldi	r24, 0x00	; 0
     89e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     8a2:	cc 23       	and	r28, r28
     8a4:	19 f0       	breq	.+6      	; 0x8ac <set_filter+0xb2>
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     8ac:	dd 23       	and	r29, r29
     8ae:	19 f0       	breq	.+6      	; 0x8b6 <set_filter+0xbc>
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>
	SPIDisable();
     8b6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	08 95       	ret

000008c0 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     8c0:	cf 93       	push	r28
     8c2:	df 93       	push	r29
     8c4:	c8 2f       	mov	r28, r24
     8c6:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     8da:	dd 23       	and	r29, r29
     8dc:	89 f0       	breq	.+34     	; 0x900 <PortEx_OUTCLR+0x40>
     8de:	80 91 ab 21 	lds	r24, 0x21AB
     8e2:	c0 95       	com	r28
     8e4:	c8 23       	and	r28, r24
     8e6:	c0 93 ab 21 	sts	0x21AB, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     8ea:	80 e4       	ldi	r24, 0x40	; 64
     8ec:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     8f0:	84 e1       	ldi	r24, 0x14	; 20
     8f2:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankA_OUT;
     8f6:	80 91 ab 21 	lds	r24, 0x21AB
     8fa:	80 93 22 3e 	sts	0x3E22, r24
     8fe:	10 c0       	rjmp	.+32     	; 0x920 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     900:	80 91 31 3e 	lds	r24, 0x3E31
     904:	c0 95       	com	r28
     906:	c8 23       	and	r28, r24
     908:	c0 93 31 3e 	sts	0x3E31, r28
	
	SPIBuffer[0] = PS_WRITE;
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     912:	85 e1       	ldi	r24, 0x15	; 21
     914:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankB_OUT; 
     918:	80 91 31 3e 	lds	r24, 0x3E31
     91c:	80 93 22 3e 	sts	0x3E22, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     920:	80 e0       	ldi	r24, 0x00	; 0
     922:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     924:	20 e2       	ldi	r18, 0x20	; 32
     926:	3e e3       	ldi	r19, 0x3E	; 62
     928:	a0 ec       	ldi	r26, 0xC0	; 192
     92a:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     92c:	cc e2       	ldi	r28, 0x2C	; 44
     92e:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     930:	f9 01       	movw	r30, r18
     932:	e8 0f       	add	r30, r24
     934:	f9 1f       	adc	r31, r25
     936:	40 81       	ld	r20, Z
     938:	13 96       	adiw	r26, 0x03	; 3
     93a:	4c 93       	st	X, r20
     93c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     93e:	12 96       	adiw	r26, 0x02	; 2
     940:	4c 91       	ld	r20, X
     942:	12 97       	sbiw	r26, 0x02	; 2
     944:	44 23       	and	r20, r20
     946:	dc f7       	brge	.-10     	; 0x93e <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     948:	13 96       	adiw	r26, 0x03	; 3
     94a:	4c 91       	ld	r20, X
     94c:	13 97       	sbiw	r26, 0x03	; 3
     94e:	48 83       	st	Y, r20
     950:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     952:	83 30       	cpi	r24, 0x03	; 3
     954:	91 05       	cpc	r25, r1
     956:	61 f7       	brne	.-40     	; 0x930 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     964:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
     96c:	08 95       	ret

0000096e <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	c8 2f       	mov	r28, r24
     974:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     988:	dd 23       	and	r29, r29
     98a:	81 f0       	breq	.+32     	; 0x9ac <PortEx_OUTSET+0x3e>
     98c:	80 91 ab 21 	lds	r24, 0x21AB
     990:	c8 2b       	or	r28, r24
     992:	c0 93 ab 21 	sts	0x21AB, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     996:	80 e4       	ldi	r24, 0x40	; 64
     998:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     99c:	84 e1       	ldi	r24, 0x14	; 20
     99e:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankA_OUT;
     9a2:	80 91 ab 21 	lds	r24, 0x21AB
     9a6:	80 93 22 3e 	sts	0x3E22, r24
     9aa:	0f c0       	rjmp	.+30     	; 0x9ca <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     9ac:	80 91 31 3e 	lds	r24, 0x3E31
     9b0:	c8 2b       	or	r28, r24
     9b2:	c0 93 31 3e 	sts	0x3E31, r28
	
	SPIBuffer[0] = PS_WRITE;
     9b6:	80 e4       	ldi	r24, 0x40	; 64
     9b8:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     9bc:	85 e1       	ldi	r24, 0x15	; 21
     9be:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankB_OUT; 
     9c2:	80 91 31 3e 	lds	r24, 0x3E31
     9c6:	80 93 22 3e 	sts	0x3E22, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9ce:	20 e2       	ldi	r18, 0x20	; 32
     9d0:	3e e3       	ldi	r19, 0x3E	; 62
     9d2:	a0 ec       	ldi	r26, 0xC0	; 192
     9d4:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     9d6:	cc e2       	ldi	r28, 0x2C	; 44
     9d8:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9da:	f9 01       	movw	r30, r18
     9dc:	e8 0f       	add	r30, r24
     9de:	f9 1f       	adc	r31, r25
     9e0:	40 81       	ld	r20, Z
     9e2:	13 96       	adiw	r26, 0x03	; 3
     9e4:	4c 93       	st	X, r20
     9e6:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     9e8:	12 96       	adiw	r26, 0x02	; 2
     9ea:	4c 91       	ld	r20, X
     9ec:	12 97       	sbiw	r26, 0x02	; 2
     9ee:	44 23       	and	r20, r20
     9f0:	dc f7       	brge	.-10     	; 0x9e8 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     9f2:	13 96       	adiw	r26, 0x03	; 3
     9f4:	4c 91       	ld	r20, X
     9f6:	13 97       	sbiw	r26, 0x03	; 3
     9f8:	48 83       	st	Y, r20
     9fa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     9fc:	83 30       	cpi	r24, 0x03	; 3
     9fe:	91 05       	cpc	r25, r1
     a00:	61 f7       	brne	.-40     	; 0x9da <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     a02:	80 e0       	ldi	r24, 0x00	; 0
     a04:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     a0e:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     a12:	df 91       	pop	r29
     a14:	cf 91       	pop	r28
     a16:	08 95       	ret

00000a18 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	c8 2f       	mov	r28, r24
     a1e:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     a2c:	81 e0       	ldi	r24, 0x01	; 1
     a2e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     a32:	dd 23       	and	r29, r29
     a34:	89 f0       	breq	.+34     	; 0xa58 <PortEx_DIRCLR+0x40>
     a36:	80 91 2f 3e 	lds	r24, 0x3E2F
     a3a:	80 95       	com	r24
     a3c:	c8 23       	and	r28, r24
     a3e:	c0 93 2f 3e 	sts	0x3E2F, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     a42:	80 e4       	ldi	r24, 0x40	; 64
     a44:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     a48:	10 92 21 3e 	sts	0x3E21, r1
		SPIBuffer[2] = ~bankA_DIR; 
     a4c:	80 91 2f 3e 	lds	r24, 0x3E2F
     a50:	80 95       	com	r24
     a52:	80 93 22 3e 	sts	0x3E22, r24
     a56:	11 c0       	rjmp	.+34     	; 0xa7a <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     a58:	80 91 46 3e 	lds	r24, 0x3E46
     a5c:	80 95       	com	r24
     a5e:	c8 23       	and	r28, r24
     a60:	c0 93 46 3e 	sts	0x3E46, r28
	
	SPIBuffer[0] = PS_WRITE;
     a64:	80 e4       	ldi	r24, 0x40	; 64
     a66:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = ~bankB_DIR;
     a70:	80 91 46 3e 	lds	r24, 0x3E46
     a74:	80 95       	com	r24
     a76:	80 93 22 3e 	sts	0x3E22, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a7e:	20 e2       	ldi	r18, 0x20	; 32
     a80:	3e e3       	ldi	r19, 0x3E	; 62
     a82:	a0 ec       	ldi	r26, 0xC0	; 192
     a84:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     a86:	cc e2       	ldi	r28, 0x2C	; 44
     a88:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a8a:	f9 01       	movw	r30, r18
     a8c:	e8 0f       	add	r30, r24
     a8e:	f9 1f       	adc	r31, r25
     a90:	40 81       	ld	r20, Z
     a92:	13 96       	adiw	r26, 0x03	; 3
     a94:	4c 93       	st	X, r20
     a96:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     a98:	12 96       	adiw	r26, 0x02	; 2
     a9a:	4c 91       	ld	r20, X
     a9c:	12 97       	sbiw	r26, 0x02	; 2
     a9e:	44 23       	and	r20, r20
     aa0:	dc f7       	brge	.-10     	; 0xa98 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     aa2:	13 96       	adiw	r26, 0x03	; 3
     aa4:	4c 91       	ld	r20, X
     aa6:	13 97       	sbiw	r26, 0x03	; 3
     aa8:	48 83       	st	Y, r20
     aaa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     aac:	83 30       	cpi	r24, 0x03	; 3
     aae:	91 05       	cpc	r25, r1
     ab0:	61 f7       	brne	.-40     	; 0xa8a <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     ab8:	80 e0       	ldi	r24, 0x00	; 0
     aba:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     abe:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	08 95       	ret

00000ac8 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	c8 2f       	mov	r28, r24
     ace:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     ad0:	80 e0       	ldi	r24, 0x00	; 0
     ad2:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     ae2:	dd 23       	and	r29, r29
     ae4:	81 f0       	breq	.+32     	; 0xb06 <PortEx_DIRSET+0x3e>
     ae6:	80 91 2f 3e 	lds	r24, 0x3E2F
     aea:	c8 2b       	or	r28, r24
     aec:	c0 93 2f 3e 	sts	0x3E2F, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     af0:	80 e4       	ldi	r24, 0x40	; 64
     af2:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     af6:	10 92 21 3e 	sts	0x3E21, r1
		SPIBuffer[2] = ~bankA_DIR; 
     afa:	80 91 2f 3e 	lds	r24, 0x3E2F
     afe:	80 95       	com	r24
     b00:	80 93 22 3e 	sts	0x3E22, r24
     b04:	10 c0       	rjmp	.+32     	; 0xb26 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     b06:	80 91 46 3e 	lds	r24, 0x3E46
     b0a:	c8 2b       	or	r28, r24
     b0c:	c0 93 46 3e 	sts	0x3E46, r28
	
	SPIBuffer[0] = PS_WRITE;
     b10:	80 e4       	ldi	r24, 0x40	; 64
     b12:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     b16:	81 e0       	ldi	r24, 0x01	; 1
     b18:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = ~bankB_DIR;
     b1c:	80 91 46 3e 	lds	r24, 0x3E46
     b20:	80 95       	com	r24
     b22:	80 93 22 3e 	sts	0x3E22, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     b26:	80 e0       	ldi	r24, 0x00	; 0
     b28:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b2a:	20 e2       	ldi	r18, 0x20	; 32
     b2c:	3e e3       	ldi	r19, 0x3E	; 62
     b2e:	a0 ec       	ldi	r26, 0xC0	; 192
     b30:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b32:	cc e2       	ldi	r28, 0x2C	; 44
     b34:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b36:	f9 01       	movw	r30, r18
     b38:	e8 0f       	add	r30, r24
     b3a:	f9 1f       	adc	r31, r25
     b3c:	40 81       	ld	r20, Z
     b3e:	13 96       	adiw	r26, 0x03	; 3
     b40:	4c 93       	st	X, r20
     b42:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     b44:	12 96       	adiw	r26, 0x02	; 2
     b46:	4c 91       	ld	r20, X
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	44 23       	and	r20, r20
     b4c:	dc f7       	brge	.-10     	; 0xb44 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b4e:	13 96       	adiw	r26, 0x03	; 3
     b50:	4c 91       	ld	r20, X
     b52:	13 97       	sbiw	r26, 0x03	; 3
     b54:	48 83       	st	Y, r20
     b56:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     b58:	83 30       	cpi	r24, 0x03	; 3
     b5a:	91 05       	cpc	r25, r1
     b5c:	61 f7       	brne	.-40     	; 0xb36 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPICS(FALSE);
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
     b6a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>


}
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	08 95       	ret

00000b74 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     b74:	0f 93       	push	r16
     b76:	1f 93       	push	r17
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     b7c:	88 23       	and	r24, r24
     b7e:	09 f4       	brne	.+2      	; 0xb82 <ADCPower+0xe>
     b80:	4e c0       	rjmp	.+156    	; 0xc1e <ADCPower+0xaa>
     b82:	80 91 32 3e 	lds	r24, 0x3E32
     b86:	88 23       	and	r24, r24
     b88:	09 f0       	breq	.+2      	; 0xb8c <ADCPower+0x18>
     b8a:	81 c0       	rjmp	.+258    	; 0xc8e <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     b8c:	00 e0       	ldi	r16, 0x00	; 0
     b8e:	16 e0       	ldi	r17, 0x06	; 6
     b90:	8e ed       	ldi	r24, 0xDE	; 222
     b92:	d8 01       	movw	r26, r16
     b94:	11 96       	adiw	r26, 0x01	; 1
     b96:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b98:	c0 e2       	ldi	r28, 0x20	; 32
     b9a:	d6 e0       	ldi	r29, 0x06	; 6
     b9c:	4e e0       	ldi	r20, 0x0E	; 14
     b9e:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     ba0:	e0 e4       	ldi	r30, 0x40	; 64
     ba2:	f6 e0       	ldi	r31, 0x06	; 6
     ba4:	63 e0       	ldi	r22, 0x03	; 3
     ba6:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     ba8:	80 e8       	ldi	r24, 0x80	; 128
     baa:	96 e0       	ldi	r25, 0x06	; 6
     bac:	50 e1       	ldi	r21, 0x10	; 16
     bae:	dc 01       	movw	r26, r24
     bb0:	11 96       	adiw	r26, 0x01	; 1
     bb2:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     bb4:	20 ea       	ldi	r18, 0xA0	; 160
     bb6:	36 e0       	ldi	r19, 0x06	; 6
     bb8:	d9 01       	movw	r26, r18
     bba:	11 96       	adiw	r26, 0x01	; 1
     bbc:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     bbe:	7e e9       	ldi	r23, 0x9E	; 158
     bc0:	d8 01       	movw	r26, r16
     bc2:	15 96       	adiw	r26, 0x05	; 5
     bc4:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     bc6:	78 e0       	ldi	r23, 0x08	; 8
     bc8:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     bca:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     bcc:	ec 01       	movw	r28, r24
     bce:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     bd0:	d9 01       	movw	r26, r18
     bd2:	15 96       	adiw	r26, 0x05	; 5
     bd4:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     bd6:	10 92 30 3e 	sts	0x3E30, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     bda:	8f ef       	ldi	r24, 0xFF	; 255
     bdc:	93 ec       	ldi	r25, 0xC3	; 195
     bde:	a9 e0       	ldi	r26, 0x09	; 9
     be0:	81 50       	subi	r24, 0x01	; 1
     be2:	90 40       	sbci	r25, 0x00	; 0
     be4:	a0 40       	sbci	r26, 0x00	; 0
     be6:	e1 f7       	brne	.-8      	; 0xbe0 <ADCPower+0x6c>
     be8:	00 c0       	rjmp	.+0      	; 0xbea <ADCPower+0x76>
     bea:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     bec:	80 e4       	ldi	r24, 0x40	; 64
     bee:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     bf0:	10 92 31 3e 	sts	0x3E31, r1
     bf4:	10 92 46 3e 	sts	0x3E46, r1
     bf8:	10 92 ab 21 	sts	0x21AB, r1
     bfc:	10 92 2f 3e 	sts	0x3E2F, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     c00:	8f ef       	ldi	r24, 0xFF	; 255
     c02:	61 e0       	ldi	r22, 0x01	; 1
     c04:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	61 e0       	ldi	r22, 0x01	; 1
     c0c:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
		ADC_POWER_ON = TRUE;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	80 93 32 3e 	sts	0x3E32, r24
     c1c:	38 c0       	rjmp	.+112    	; 0xc8e <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     c1e:	80 91 32 3e 	lds	r24, 0x3E32
     c22:	88 23       	and	r24, r24
     c24:	a1 f1       	breq	.+104    	; 0xc8e <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     c26:	00 e0       	ldi	r16, 0x00	; 0
     c28:	16 e0       	ldi	r17, 0x06	; 6
     c2a:	7e ed       	ldi	r23, 0xDE	; 222
     c2c:	d8 01       	movw	r26, r16
     c2e:	16 96       	adiw	r26, 0x06	; 6
     c30:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c32:	a0 e2       	ldi	r26, 0x20	; 32
     c34:	b6 e0       	ldi	r27, 0x06	; 6
     c36:	4e e0       	ldi	r20, 0x0E	; 14
     c38:	16 96       	adiw	r26, 0x06	; 6
     c3a:	4c 93       	st	X, r20
     c3c:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c3e:	20 e4       	ldi	r18, 0x40	; 64
     c40:	36 e0       	ldi	r19, 0x06	; 6
     c42:	63 e0       	ldi	r22, 0x03	; 3
     c44:	e9 01       	movw	r28, r18
     c46:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     c48:	c0 e8       	ldi	r28, 0x80	; 128
     c4a:	d6 e0       	ldi	r29, 0x06	; 6
     c4c:	50 e1       	ldi	r21, 0x10	; 16
     c4e:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c50:	80 ea       	ldi	r24, 0xA0	; 160
     c52:	96 e0       	ldi	r25, 0x06	; 6
     c54:	fc 01       	movw	r30, r24
     c56:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     c58:	f8 01       	movw	r30, r16
     c5a:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     c5c:	12 96       	adiw	r26, 0x02	; 2
     c5e:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     c60:	d9 01       	movw	r26, r18
     c62:	12 96       	adiw	r26, 0x02	; 2
     c64:	6c 93       	st	X, r22
     c66:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     c68:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     c6a:	ec 01       	movw	r28, r24
     c6c:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     c6e:	80 e4       	ldi	r24, 0x40	; 64
     c70:	12 96       	adiw	r26, 0x02	; 2
     c72:	8c 93       	st	X, r24
     c74:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     c76:	10 92 31 3e 	sts	0x3E31, r1
     c7a:	10 92 46 3e 	sts	0x3E46, r1
     c7e:	10 92 ab 21 	sts	0x21AB, r1
     c82:	10 92 2f 3e 	sts	0x3E2F, r1
		channelStatus = 0x00;
     c86:	10 92 30 3e 	sts	0x3E30, r1
		ADC_POWER_ON = FALSE;
     c8a:	10 92 32 3e 	sts	0x3E32, r1
	}
}
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	08 95       	ret

00000c98 <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     c98:	2f 92       	push	r2
     c9a:	3f 92       	push	r3
     c9c:	4f 92       	push	r4
     c9e:	5f 92       	push	r5
     ca0:	6f 92       	push	r6
     ca2:	7f 92       	push	r7
     ca4:	8f 92       	push	r8
     ca6:	9f 92       	push	r9
     ca8:	af 92       	push	r10
     caa:	bf 92       	push	r11
     cac:	cf 92       	push	r12
     cae:	df 92       	push	r13
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
     cc0:	64 97       	sbiw	r28, 0x14	; 20
     cc2:	cd bf       	out	0x3d, r28	; 61
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	2a 01       	movw	r4, r20
     cc8:	3b 01       	movw	r6, r22
     cca:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     ccc:	f9 01       	movw	r30, r18
     cce:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     cd0:	41 15       	cp	r20, r1
     cd2:	51 05       	cpc	r21, r1
     cd4:	61 05       	cpc	r22, r1
     cd6:	71 05       	cpc	r23, r1
     cd8:	09 f4       	brne	.+2      	; 0xcdc <DeciToString+0x44>
     cda:	4d c0       	rjmp	.+154    	; 0xd76 <DeciToString+0xde>
     cdc:	88 2e       	mov	r8, r24
     cde:	99 2e       	mov	r9, r25
     ce0:	cc 24       	eor	r12, r12
     ce2:	dd 24       	eor	r13, r13
     ce4:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     ce6:	5e 01       	movw	r10, r28
     ce8:	08 94       	sec
     cea:	a1 1c       	adc	r10, r1
     cec:	b1 1c       	adc	r11, r1
     cee:	0f 2e       	mov	r0, r31
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	2f 2e       	mov	r2, r31
     cf4:	f0 e2       	ldi	r31, 0x20	; 32
     cf6:	3f 2e       	mov	r3, r31
     cf8:	f0 2d       	mov	r31, r0
     cfa:	f4 01       	movw	r30, r8
     cfc:	81 91       	ld	r24, Z+
     cfe:	91 91       	ld	r25, Z+
     d00:	a1 91       	ld	r26, Z+
     d02:	b1 91       	ld	r27, Z+
     d04:	4f 01       	movw	r8, r30
     d06:	2d b7       	in	r18, 0x3d	; 61
     d08:	3e b7       	in	r19, 0x3e	; 62
     d0a:	28 50       	subi	r18, 0x08	; 8
     d0c:	30 40       	sbci	r19, 0x00	; 0
     d0e:	2d bf       	out	0x3d, r18	; 61
     d10:	3e bf       	out	0x3e, r19	; 62
     d12:	2f 5f       	subi	r18, 0xFF	; 255
     d14:	3f 4f       	sbci	r19, 0xFF	; 255
     d16:	ed b7       	in	r30, 0x3d	; 61
     d18:	fe b7       	in	r31, 0x3e	; 62
     d1a:	a1 82       	std	Z+1, r10	; 0x01
     d1c:	b2 82       	std	Z+2, r11	; 0x02
     d1e:	f9 01       	movw	r30, r18
     d20:	22 82       	std	Z+2, r2	; 0x02
     d22:	33 82       	std	Z+3, r3	; 0x03
     d24:	84 83       	std	Z+4, r24	; 0x04
     d26:	95 83       	std	Z+5, r25	; 0x05
     d28:	a6 83       	std	Z+6, r26	; 0x06
     d2a:	b7 83       	std	Z+7, r27	; 0x07
     d2c:	0e 94 be 39 	call	0x737c	; 0x737c <sprintf>
		strcat(ReturnString,b);
     d30:	2d b7       	in	r18, 0x3d	; 61
     d32:	3e b7       	in	r19, 0x3e	; 62
     d34:	28 5f       	subi	r18, 0xF8	; 248
     d36:	3f 4f       	sbci	r19, 0xFF	; 255
     d38:	2d bf       	out	0x3d, r18	; 61
     d3a:	3e bf       	out	0x3e, r19	; 62
     d3c:	c8 01       	movw	r24, r16
     d3e:	b5 01       	movw	r22, r10
     d40:	0e 94 80 39 	call	0x7300	; 0x7300 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     d44:	a0 2f       	mov	r26, r16
     d46:	b1 2f       	mov	r27, r17
     d48:	fd 01       	movw	r30, r26
     d4a:	01 90       	ld	r0, Z+
     d4c:	00 20       	and	r0, r0
     d4e:	e9 f7       	brne	.-6      	; 0xd4a <DeciToString+0xb2>
     d50:	31 97       	sbiw	r30, 0x01	; 1
     d52:	ea 1b       	sub	r30, r26
     d54:	fb 0b       	sbc	r31, r27
     d56:	e0 0f       	add	r30, r16
     d58:	f1 1f       	adc	r31, r17
     d5a:	8a e0       	ldi	r24, 0x0A	; 10
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	80 83       	st	Z, r24
     d60:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     d62:	08 94       	sec
     d64:	c1 1c       	adc	r12, r1
     d66:	d1 1c       	adc	r13, r1
     d68:	e1 1c       	adc	r14, r1
     d6a:	f1 1c       	adc	r15, r1
     d6c:	c4 14       	cp	r12, r4
     d6e:	d5 04       	cpc	r13, r5
     d70:	e6 04       	cpc	r14, r6
     d72:	f7 04       	cpc	r15, r7
     d74:	11 f6       	brne	.-124    	; 0xcfa <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     d76:	64 96       	adiw	r28, 0x14	; 20
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ff 90       	pop	r15
     d86:	ef 90       	pop	r14
     d88:	df 90       	pop	r13
     d8a:	cf 90       	pop	r12
     d8c:	bf 90       	pop	r11
     d8e:	af 90       	pop	r10
     d90:	9f 90       	pop	r9
     d92:	8f 90       	pop	r8
     d94:	7f 90       	pop	r7
     d96:	6f 90       	pop	r6
     d98:	5f 90       	pop	r5
     d9a:	4f 90       	pop	r4
     d9c:	3f 90       	pop	r3
     d9e:	2f 90       	pop	r2
     da0:	08 95       	ret

00000da2 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     da2:	e0 ec       	ldi	r30, 0xC0	; 192
     da4:	f8 e0       	ldi	r31, 0x08	; 8
     da6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     da8:	82 81       	ldd	r24, Z+2	; 0x02
     daa:	88 23       	and	r24, r24
     dac:	ec f7       	brge	.-6      	; 0xda8 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     dae:	e0 ec       	ldi	r30, 0xC0	; 192
     db0:	f8 e0       	ldi	r31, 0x08	; 8
     db2:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     db4:	08 95       	ret

00000db6 <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     db6:	cf 93       	push	r28
     db8:	df 93       	push	r29
     dba:	cd b7       	in	r28, 0x3d	; 61
     dbc:	de b7       	in	r29, 0x3e	; 62
     dbe:	6e 97       	sbiw	r28, 0x1e	; 30
     dc0:	cd bf       	out	0x3d, r28	; 61
     dc2:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
     dc4:	19 82       	std	Y+1, r1	; 0x01
     dc6:	1a 82       	std	Y+2, r1	; 0x02
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
	volatile uint32_t samples = 0;
     dc8:	1c 82       	std	Y+4, r1	; 0x04
     dca:	1d 82       	std	Y+5, r1	; 0x05
     dcc:	1e 82       	std	Y+6, r1	; 0x06
     dce:	1f 82       	std	Y+7, r1	; 0x07
	DataAvailable = 0;
     dd0:	10 92 47 3e 	sts	0x3E47, r1
	ADC_Sampling_Finished = 1;
     dd4:	81 e0       	ldi	r24, 0x01	; 1
     dd6:	80 93 a6 50 	sts	0x50A6, r24
	uint8_t RadioMessageBuffer[20];
	unsigned char ofile[] = {'o','u','t','p','u','t'};
	set_32MHz();
     dda:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	chb_init();
     dde:	0e 94 7c 19 	call	0x32f8	; 0x32f8 <chb_init>
	chb_set_channel(1);
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <chb_set_channel>
	chb_set_short_addr(0x0001);
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	0e 94 ae 1b 	call	0x375c	; 0x375c <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     df0:	0e 94 9d 19 	call	0x333a	; 0x333a <chb_get_pcb>
     df4:	3c 01       	movw	r6, r24
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
     df6:	0f 2e       	mov	r0, r31
     df8:	f0 ed       	ldi	r31, 0xD0	; 208
     dfa:	4f 2e       	mov	r4, r31
     dfc:	f7 e0       	ldi	r31, 0x07	; 7
     dfe:	5f 2e       	mov	r5, r31
     e00:	f0 2d       	mov	r31, r0
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     e02:	1e 8e       	std	Y+30, r1	; 0x1e
									chb_write(0x0000,FRAMReadBuffer,7200);
									i += 7200;
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
									chb_write(0x0000,FRAMReadBuffer,samples*4 - i);
     e04:	8c ea       	ldi	r24, 0xAC	; 172
     e06:	91 e2       	ldi	r25, 0x21	; 33
     e08:	38 2e       	mov	r3, r24
     e0a:	29 2e       	mov	r2, r25
	chb_set_short_addr(0x0001);
	pcb_t* pcb = chb_get_pcb();
	//SD_init();
	//getBootSectorData();
	while(1){
		if(pcb->data_rcv){
     e0c:	d3 01       	movw	r26, r6
     e0e:	13 96       	adiw	r26, 0x03	; 3
     e10:	8c 91       	ld	r24, X
     e12:	13 97       	sbiw	r26, 0x03	; 3
     e14:	88 23       	and	r24, r24
     e16:	d1 f3       	breq	.-12     	; 0xe0c <main+0x56>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     e18:	ce 01       	movw	r24, r28
     e1a:	08 96       	adiw	r24, 0x08	; 8
     e1c:	0e 94 4f 1a 	call	0x349e	; 0x349e <chb_read>
			//length should be >1 for setting gain/freq commands: the value is likely sent in a separate message
				switch ( RadioMessageBuffer[0])
     e20:	88 85       	ldd	r24, Y+8	; 0x08
     e22:	82 35       	cpi	r24, 0x52	; 82
     e24:	71 f0       	breq	.+28     	; 0xe42 <main+0x8c>
     e26:	83 35       	cpi	r24, 0x53	; 83
     e28:	30 f4       	brcc	.+12     	; 0xe36 <main+0x80>
     e2a:	86 34       	cpi	r24, 0x46	; 70
     e2c:	09 f4       	brne	.+2      	; 0xe30 <main+0x7a>
     e2e:	89 c0       	rjmp	.+274    	; 0xf42 <main+0x18c>
     e30:	87 34       	cpi	r24, 0x47	; 71
     e32:	61 f7       	brne	.-40     	; 0xe0c <main+0x56>
     e34:	4a c0       	rjmp	.+148    	; 0xeca <main+0x114>
     e36:	83 35       	cpi	r24, 0x53	; 83
     e38:	09 f4       	brne	.+2      	; 0xe3c <main+0x86>
     e3a:	91 c0       	rjmp	.+290    	; 0xf5e <main+0x1a8>
     e3c:	84 35       	cpi	r24, 0x54	; 84
     e3e:	31 f7       	brne	.-52     	; 0xe0c <main+0x56>
     e40:	a0 c0       	rjmp	.+320    	; 0xf82 <main+0x1cc>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     e42:	80 91 a6 50 	lds	r24, 0x50A6
     e46:	88 23       	and	r24, r24
     e48:	a1 f1       	breq	.+104    	; 0xeb2 <main+0xfc>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, 10000, (int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, FALSE, 1, 2, 3, 4, 16000,(int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
     e4a:	ed b7       	in	r30, 0x3d	; 61
     e4c:	fe b7       	in	r31, 0x3e	; 62
     e4e:	37 97       	sbiw	r30, 0x07	; 7
     e50:	ed bf       	out	0x3d, r30	; 61
     e52:	fe bf       	out	0x3e, r31	; 62
     e54:	31 96       	adiw	r30, 0x01	; 1
     e56:	80 e8       	ldi	r24, 0x80	; 128
     e58:	9e e3       	ldi	r25, 0x3E	; 62
     e5a:	ad b7       	in	r26, 0x3d	; 61
     e5c:	be b7       	in	r27, 0x3e	; 62
     e5e:	11 96       	adiw	r26, 0x01	; 1
     e60:	8d 93       	st	X+, r24
     e62:	9c 93       	st	X, r25
     e64:	12 97       	sbiw	r26, 0x02	; 2
     e66:	ac ea       	ldi	r26, 0xAC	; 172
     e68:	b1 e2       	ldi	r27, 0x21	; 33
     e6a:	a2 83       	std	Z+2, r26	; 0x02
     e6c:	b3 83       	std	Z+3, r27	; 0x03
     e6e:	8c e1       	ldi	r24, 0x1C	; 28
     e70:	97 e0       	ldi	r25, 0x07	; 7
     e72:	84 83       	std	Z+4, r24	; 0x04
     e74:	95 83       	std	Z+5, r25	; 0x05
     e76:	91 e0       	ldi	r25, 0x01	; 1
     e78:	96 83       	std	Z+6, r25	; 0x06
     e7a:	87 e0       	ldi	r24, 0x07	; 7
     e7c:	6e 8d       	ldd	r22, Y+30	; 0x1e
     e7e:	a2 01       	movw	r20, r4
     e80:	26 e0       	ldi	r18, 0x06	; 6
     e82:	00 e0       	ldi	r16, 0x00	; 0
     e84:	ee 24       	eor	r14, r14
     e86:	ff 24       	eor	r15, r15
     e88:	e3 94       	inc	r14
     e8a:	cc 24       	eor	r12, r12
     e8c:	dd 24       	eor	r13, r13
     e8e:	68 94       	set
     e90:	c1 f8       	bld	r12, 1
     e92:	0f 2e       	mov	r0, r31
     e94:	f3 e0       	ldi	r31, 0x03	; 3
     e96:	af 2e       	mov	r10, r31
     e98:	bb 24       	eor	r11, r11
     e9a:	f0 2d       	mov	r31, r0
     e9c:	88 24       	eor	r8, r8
     e9e:	99 24       	eor	r9, r9
     ea0:	68 94       	set
     ea2:	82 f8       	bld	r8, 2
     ea4:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <CO_collectSeismic1Channel>
     ea8:	ad b7       	in	r26, 0x3d	; 61
     eaa:	be b7       	in	r27, 0x3e	; 62
     eac:	17 96       	adiw	r26, 0x07	; 7
     eae:	ad bf       	out	0x3d, r26	; 61
     eb0:	be bf       	out	0x3e, r27	; 62
					}
					//send acknowledgment
					chb_write(0x0000,&ack,2);						
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	be 01       	movw	r22, r28
     eb8:	6f 5f       	subi	r22, 0xFF	; 255
     eba:	7f 4f       	sbci	r23, 0xFF	; 255
     ebc:	22 e0       	ldi	r18, 0x02	; 2
     ebe:	30 e0       	ldi	r19, 0x00	; 0
     ec0:	40 e0       	ldi	r20, 0x00	; 0
     ec2:	50 e0       	ldi	r21, 0x00	; 0
     ec4:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
					break;
     ec8:	a1 cf       	rjmp	.-190    	; 0xe0c <main+0x56>
				case 'G':
					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
     eca:	89 85       	ldd	r24, Y+9	; 0x09
     ecc:	8b 83       	std	Y+3, r24	; 0x03
					switch(RawGain){
     ece:	8b 81       	ldd	r24, Y+3	; 0x03
     ed0:	88 30       	cpi	r24, 0x08	; 8
     ed2:	d9 f0       	breq	.+54     	; 0xf0a <main+0x154>
     ed4:	89 30       	cpi	r24, 0x09	; 9
     ed6:	38 f4       	brcc	.+14     	; 0xee6 <main+0x130>
     ed8:	82 30       	cpi	r24, 0x02	; 2
     eda:	89 f0       	breq	.+34     	; 0xefe <main+0x148>
     edc:	84 30       	cpi	r24, 0x04	; 4
     ede:	91 f0       	breq	.+36     	; 0xf04 <main+0x14e>
     ee0:	81 30       	cpi	r24, 0x01	; 1
     ee2:	19 f5       	brne	.+70     	; 0xf2a <main+0x174>
     ee4:	21 c0       	rjmp	.+66     	; 0xf28 <main+0x172>
     ee6:	80 32       	cpi	r24, 0x20	; 32
     ee8:	b1 f0       	breq	.+44     	; 0xf16 <main+0x160>
     eea:	81 32       	cpi	r24, 0x21	; 33
     eec:	18 f4       	brcc	.+6      	; 0xef4 <main+0x13e>
     eee:	80 31       	cpi	r24, 0x10	; 16
     ef0:	e1 f4       	brne	.+56     	; 0xf2a <main+0x174>
     ef2:	0e c0       	rjmp	.+28     	; 0xf10 <main+0x15a>
     ef4:	80 34       	cpi	r24, 0x40	; 64
     ef6:	91 f0       	breq	.+36     	; 0xf1c <main+0x166>
     ef8:	80 38       	cpi	r24, 0x80	; 128
     efa:	b9 f4       	brne	.+46     	; 0xf2a <main+0x174>
     efc:	12 c0       	rjmp	.+36     	; 0xf22 <main+0x16c>
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     efe:	b1 e0       	ldi	r27, 0x01	; 1
     f00:	be 8f       	std	Y+30, r27	; 0x1e
							break;
     f02:	13 c0       	rjmp	.+38     	; 0xf2a <main+0x174>
						case 4:
							gain = GAIN_4_gc;
     f04:	e2 e0       	ldi	r30, 0x02	; 2
     f06:	ee 8f       	std	Y+30, r30	; 0x1e
							break;
     f08:	10 c0       	rjmp	.+32     	; 0xf2a <main+0x174>
						case 8:
							gain = GAIN_8_gc;
     f0a:	f3 e0       	ldi	r31, 0x03	; 3
     f0c:	fe 8f       	std	Y+30, r31	; 0x1e
							break;
     f0e:	0d c0       	rjmp	.+26     	; 0xf2a <main+0x174>
						case 16:
							gain = GAIN_16_gc;
     f10:	24 e0       	ldi	r18, 0x04	; 4
     f12:	2e 8f       	std	Y+30, r18	; 0x1e
							break;
     f14:	0a c0       	rjmp	.+20     	; 0xf2a <main+0x174>
						case 32:
							gain = GAIN_32_gc;
     f16:	85 e0       	ldi	r24, 0x05	; 5
     f18:	8e 8f       	std	Y+30, r24	; 0x1e
							break;
     f1a:	07 c0       	rjmp	.+14     	; 0xf2a <main+0x174>
						case 64:
							gain = GAIN_64_gc;
     f1c:	96 e0       	ldi	r25, 0x06	; 6
     f1e:	9e 8f       	std	Y+30, r25	; 0x1e
							break;
     f20:	04 c0       	rjmp	.+8      	; 0xf2a <main+0x174>
						case 128:
							gain = GAIN_128_gc;
     f22:	a7 e0       	ldi	r26, 0x07	; 7
     f24:	ae 8f       	std	Y+30, r26	; 0x1e
							break;
     f26:	01 c0       	rjmp	.+2      	; 0xf2a <main+0x174>
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
					switch(RawGain){
						case 1:
							gain = GAIN_1_gc;
     f28:	1e 8e       	std	Y+30, r1	; 0x1e
						default:
							//chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
							break;
					}
					//send acknowledgment
					chb_write(0x0000,&ack,2);					
     f2a:	80 e0       	ldi	r24, 0x00	; 0
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	be 01       	movw	r22, r28
     f30:	6f 5f       	subi	r22, 0xFF	; 255
     f32:	7f 4f       	sbci	r23, 0xFF	; 255
     f34:	22 e0       	ldi	r18, 0x02	; 2
     f36:	30 e0       	ldi	r19, 0x00	; 0
     f38:	40 e0       	ldi	r20, 0x00	; 0
     f3a:	50 e0       	ldi	r21, 0x00	; 0
     f3c:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
					break;
     f40:	65 cf       	rjmp	.-310    	; 0xe0c <main+0x56>
				case 'F':

					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set sampling frequency to what is specified
					freq = (uint16_t)(*(int32_t*)(RadioMessageBuffer+1));
     f42:	49 84       	ldd	r4, Y+9	; 0x09
     f44:	5a 84       	ldd	r5, Y+10	; 0x0a
					//send acknowledgment
					chb_write(0x0000,&ack,2);
     f46:	80 e0       	ldi	r24, 0x00	; 0
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	be 01       	movw	r22, r28
     f4c:	6f 5f       	subi	r22, 0xFF	; 255
     f4e:	7f 4f       	sbci	r23, 0xFF	; 255
     f50:	22 e0       	ldi	r18, 0x02	; 2
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	40 e0       	ldi	r20, 0x00	; 0
     f56:	50 e0       	ldi	r21, 0x00	; 0
     f58:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
					break;
     f5c:	57 cf       	rjmp	.-338    	; 0xe0c <main+0x56>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     f5e:	80 91 a6 50 	lds	r24, 0x50A6
     f62:	88 23       	and	r24, r24
     f64:	11 f4       	brne	.+4      	; 0xf6a <main+0x1b4>
						ADC_Stop_Sampling();
     f66:	0e 94 2b 0c 	call	0x1856	; 0x1856 <ADC_Stop_Sampling>
					}
					//otherwise, the ADC has finished sampling on its own and the data is ready to be transmitted
					//send acknowledgment
					chb_write(0x0000,&ack,2);
     f6a:	80 e0       	ldi	r24, 0x00	; 0
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	be 01       	movw	r22, r28
     f70:	6f 5f       	subi	r22, 0xFF	; 255
     f72:	7f 4f       	sbci	r23, 0xFF	; 255
     f74:	22 e0       	ldi	r18, 0x02	; 2
     f76:	30 e0       	ldi	r19, 0x00	; 0
     f78:	40 e0       	ldi	r20, 0x00	; 0
     f7a:	50 e0       	ldi	r21, 0x00	; 0
     f7c:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
					break;
     f80:	45 cf       	rjmp	.-374    	; 0xe0c <main+0x56>
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     f82:	80 91 a6 50 	lds	r24, 0x50A6
     f86:	88 23       	and	r24, r24
     f88:	09 f4       	brne	.+2      	; 0xf8c <main+0x1d6>
     f8a:	40 cf       	rjmp	.-384    	; 0xe0c <main+0x56>
     f8c:	80 91 47 3e 	lds	r24, 0x3E47
     f90:	88 23       	and	r24, r24
     f92:	09 f4       	brne	.+2      	; 0xf96 <main+0x1e0>
     f94:	3b cf       	rjmp	.-394    	; 0xe0c <main+0x56>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     f96:	0e 94 4c 0c 	call	0x1898	; 0x1898 <ADC_Get_Num_Samples>
     f9a:	a0 e0       	ldi	r26, 0x00	; 0
     f9c:	b0 e0       	ldi	r27, 0x00	; 0
     f9e:	8c 83       	std	Y+4, r24	; 0x04
     fa0:	9d 83       	std	Y+5, r25	; 0x05
     fa2:	ae 83       	std	Y+6, r26	; 0x06
     fa4:	bf 83       	std	Y+7, r27	; 0x07
						if(samples > 0){	
     fa6:	8c 81       	ldd	r24, Y+4	; 0x04
     fa8:	9d 81       	ldd	r25, Y+5	; 0x05
     faa:	ae 81       	ldd	r26, Y+6	; 0x06
     fac:	bf 81       	ldd	r27, Y+7	; 0x07
     fae:	00 97       	sbiw	r24, 0x00	; 0
     fb0:	a1 05       	cpc	r26, r1
     fb2:	b1 05       	cpc	r27, r1
     fb4:	09 f4       	brne	.+2      	; 0xfb8 <main+0x202>
     fb6:	d3 c0       	rjmp	.+422    	; 0x115e <main+0x3a8>
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     fb8:	8c 81       	ldd	r24, Y+4	; 0x04
     fba:	9d 81       	ldd	r25, Y+5	; 0x05
     fbc:	ae 81       	ldd	r26, Y+6	; 0x06
     fbe:	bf 81       	ldd	r27, Y+7	; 0x07
     fc0:	bc 01       	movw	r22, r24
     fc2:	cd 01       	movw	r24, r26
     fc4:	66 0f       	add	r22, r22
     fc6:	77 1f       	adc	r23, r23
     fc8:	88 1f       	adc	r24, r24
     fca:	99 1f       	adc	r25, r25
     fcc:	66 0f       	add	r22, r22
     fce:	77 1f       	adc	r23, r23
     fd0:	88 1f       	adc	r24, r24
     fd2:	99 1f       	adc	r25, r25
     fd4:	24 e6       	ldi	r18, 0x64	; 100
     fd6:	30 e0       	ldi	r19, 0x00	; 0
     fd8:	40 e0       	ldi	r20, 0x00	; 0
     fda:	50 e0       	ldi	r21, 0x00	; 0
     fdc:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
     fe0:	89 01       	movw	r16, r18
     fe2:	9a 01       	movw	r18, r20
     fe4:	68 01       	movw	r12, r16
     fe6:	0c 8f       	std	Y+28, r16	; 0x1c
     fe8:	1d 8f       	std	Y+29, r17	; 0x1d
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
     fea:	8c 81       	ldd	r24, Y+4	; 0x04
     fec:	9d 81       	ldd	r25, Y+5	; 0x05
     fee:	ae 81       	ldd	r26, Y+6	; 0x06
     ff0:	bf 81       	ldd	r27, Y+7	; 0x07
     ff2:	bc 01       	movw	r22, r24
     ff4:	cd 01       	movw	r24, r26
     ff6:	66 0f       	add	r22, r22
     ff8:	77 1f       	adc	r23, r23
     ffa:	88 1f       	adc	r24, r24
     ffc:	99 1f       	adc	r25, r25
     ffe:	66 0f       	add	r22, r22
    1000:	77 1f       	adc	r23, r23
    1002:	88 1f       	adc	r24, r24
    1004:	99 1f       	adc	r25, r25
    1006:	24 e6       	ldi	r18, 0x64	; 100
    1008:	30 e0       	ldi	r19, 0x00	; 0
    100a:	40 e0       	ldi	r20, 0x00	; 0
    100c:	50 e0       	ldi	r21, 0x00	; 0
    100e:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    1012:	dc 01       	movw	r26, r24
    1014:	cb 01       	movw	r24, r22
    1016:	00 97       	sbiw	r24, 0x00	; 0
    1018:	a1 05       	cpc	r26, r1
    101a:	b1 05       	cpc	r27, r1
    101c:	21 f0       	breq	.+8      	; 0x1026 <main+0x270>
    101e:	c6 01       	movw	r24, r12
    1020:	01 96       	adiw	r24, 0x01	; 1
    1022:	8c 8f       	std	Y+28, r24	; 0x1c
    1024:	9d 8f       	std	Y+29, r25	; 0x1d
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,2);  
    1026:	80 e0       	ldi	r24, 0x00	; 0
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	be 01       	movw	r22, r28
    102c:	64 5e       	subi	r22, 0xE4	; 228
    102e:	7f 4f       	sbci	r23, 0xFF	; 255
    1030:	22 e0       	ldi	r18, 0x02	; 2
    1032:	30 e0       	ldi	r19, 0x00	; 0
    1034:	40 e0       	ldi	r20, 0x00	; 0
    1036:	50 e0       	ldi	r21, 0x00	; 0
    1038:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    103c:	00 e0       	ldi	r16, 0x00	; 0
    103e:	10 e0       	ldi	r17, 0x00	; 0
    1040:	79 c0       	rjmp	.+242    	; 0x1134 <main+0x37e>
								if(samples*4 - i > 7200){
    1042:	8c 81       	ldd	r24, Y+4	; 0x04
    1044:	9d 81       	ldd	r25, Y+5	; 0x05
    1046:	ae 81       	ldd	r26, Y+6	; 0x06
    1048:	bf 81       	ldd	r27, Y+7	; 0x07
    104a:	88 0f       	add	r24, r24
    104c:	99 1f       	adc	r25, r25
    104e:	aa 1f       	adc	r26, r26
    1050:	bb 1f       	adc	r27, r27
    1052:	88 0f       	add	r24, r24
    1054:	99 1f       	adc	r25, r25
    1056:	aa 1f       	adc	r26, r26
    1058:	bb 1f       	adc	r27, r27
    105a:	8c 19       	sub	r24, r12
    105c:	9d 09       	sbc	r25, r13
    105e:	ae 09       	sbc	r26, r14
    1060:	bf 09       	sbc	r27, r15
    1062:	81 32       	cpi	r24, 0x21	; 33
    1064:	ec e1       	ldi	r30, 0x1C	; 28
    1066:	9e 07       	cpc	r25, r30
    1068:	e0 e0       	ldi	r30, 0x00	; 0
    106a:	ae 07       	cpc	r26, r30
    106c:	e0 e0       	ldi	r30, 0x00	; 0
    106e:	be 07       	cpc	r27, r30
    1070:	08 f1       	brcs	.+66     	; 0x10b4 <main+0x2fe>
									readFRAM(7200,(FRAMAddress-(samples*4))+i);						
    1072:	60 91 1d 3e 	lds	r22, 0x3E1D
    1076:	70 91 1e 3e 	lds	r23, 0x3E1E
    107a:	8c 81       	ldd	r24, Y+4	; 0x04
    107c:	9d 81       	ldd	r25, Y+5	; 0x05
    107e:	ae 81       	ldd	r26, Y+6	; 0x06
    1080:	bf 81       	ldd	r27, Y+7	; 0x07
    1082:	88 0f       	add	r24, r24
    1084:	99 1f       	adc	r25, r25
    1086:	88 0f       	add	r24, r24
    1088:	99 1f       	adc	r25, r25
    108a:	68 1b       	sub	r22, r24
    108c:	79 0b       	sbc	r23, r25
    108e:	60 0f       	add	r22, r16
    1090:	71 1f       	adc	r23, r17
    1092:	80 e2       	ldi	r24, 0x20	; 32
    1094:	9c e1       	ldi	r25, 0x1C	; 28
    1096:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									chb_write(0x0000,FRAMReadBuffer,7200);
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	90 e0       	ldi	r25, 0x00	; 0
    109e:	63 2d       	mov	r22, r3
    10a0:	72 2d       	mov	r23, r2
    10a2:	20 e2       	ldi	r18, 0x20	; 32
    10a4:	3c e1       	ldi	r19, 0x1C	; 28
    10a6:	40 e0       	ldi	r20, 0x00	; 0
    10a8:	50 e0       	ldi	r21, 0x00	; 0
    10aa:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
									i += 7200;
    10ae:	00 5e       	subi	r16, 0xE0	; 224
    10b0:	13 4e       	sbci	r17, 0xE3	; 227
    10b2:	40 c0       	rjmp	.+128    	; 0x1134 <main+0x37e>
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
    10b4:	8c 81       	ldd	r24, Y+4	; 0x04
    10b6:	9d 81       	ldd	r25, Y+5	; 0x05
    10b8:	ae 81       	ldd	r26, Y+6	; 0x06
    10ba:	bf 81       	ldd	r27, Y+7	; 0x07
    10bc:	e0 91 1d 3e 	lds	r30, 0x3E1D
    10c0:	f0 91 1e 3e 	lds	r31, 0x3E1E
    10c4:	4c 81       	ldd	r20, Y+4	; 0x04
    10c6:	5d 81       	ldd	r21, Y+5	; 0x05
    10c8:	6e 81       	ldd	r22, Y+6	; 0x06
    10ca:	7f 81       	ldd	r23, Y+7	; 0x07
    10cc:	9c 01       	movw	r18, r24
    10ce:	22 0f       	add	r18, r18
    10d0:	33 1f       	adc	r19, r19
    10d2:	22 0f       	add	r18, r18
    10d4:	33 1f       	adc	r19, r19
    10d6:	ca 01       	movw	r24, r20
    10d8:	88 0f       	add	r24, r24
    10da:	99 1f       	adc	r25, r25
    10dc:	88 0f       	add	r24, r24
    10de:	99 1f       	adc	r25, r25
    10e0:	bf 01       	movw	r22, r30
    10e2:	68 1b       	sub	r22, r24
    10e4:	79 0b       	sbc	r23, r25
    10e6:	60 0f       	add	r22, r16
    10e8:	71 1f       	adc	r23, r17
    10ea:	c9 01       	movw	r24, r18
    10ec:	80 1b       	sub	r24, r16
    10ee:	91 0b       	sbc	r25, r17
    10f0:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									chb_write(0x0000,FRAMReadBuffer,samples*4 - i);
    10f4:	8c 81       	ldd	r24, Y+4	; 0x04
    10f6:	9d 81       	ldd	r25, Y+5	; 0x05
    10f8:	ae 81       	ldd	r26, Y+6	; 0x06
    10fa:	bf 81       	ldd	r27, Y+7	; 0x07
    10fc:	88 0f       	add	r24, r24
    10fe:	99 1f       	adc	r25, r25
    1100:	aa 1f       	adc	r26, r26
    1102:	bb 1f       	adc	r27, r27
    1104:	88 0f       	add	r24, r24
    1106:	99 1f       	adc	r25, r25
    1108:	aa 1f       	adc	r26, r26
    110a:	bb 1f       	adc	r27, r27
    110c:	9c 01       	movw	r18, r24
    110e:	ad 01       	movw	r20, r26
    1110:	2c 19       	sub	r18, r12
    1112:	3d 09       	sbc	r19, r13
    1114:	4e 09       	sbc	r20, r14
    1116:	5f 09       	sbc	r21, r15
    1118:	80 e0       	ldi	r24, 0x00	; 0
    111a:	90 e0       	ldi	r25, 0x00	; 0
    111c:	63 2d       	mov	r22, r3
    111e:	72 2d       	mov	r23, r2
    1120:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
									i += samples*4 - i;
    1124:	0c 81       	ldd	r16, Y+4	; 0x04
    1126:	1d 81       	ldd	r17, Y+5	; 0x05
    1128:	2e 81       	ldd	r18, Y+6	; 0x06
    112a:	3f 81       	ldd	r19, Y+7	; 0x07
    112c:	00 0f       	add	r16, r16
    112e:	11 1f       	adc	r17, r17
    1130:	00 0f       	add	r16, r16
    1132:	11 1f       	adc	r17, r17
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,2);  
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    1134:	68 01       	movw	r12, r16
    1136:	ee 24       	eor	r14, r14
    1138:	ff 24       	eor	r15, r15
    113a:	8c 81       	ldd	r24, Y+4	; 0x04
    113c:	9d 81       	ldd	r25, Y+5	; 0x05
    113e:	ae 81       	ldd	r26, Y+6	; 0x06
    1140:	bf 81       	ldd	r27, Y+7	; 0x07
    1142:	88 0f       	add	r24, r24
    1144:	99 1f       	adc	r25, r25
    1146:	aa 1f       	adc	r26, r26
    1148:	bb 1f       	adc	r27, r27
    114a:	88 0f       	add	r24, r24
    114c:	99 1f       	adc	r25, r25
    114e:	aa 1f       	adc	r26, r26
    1150:	bb 1f       	adc	r27, r27
    1152:	c8 16       	cp	r12, r24
    1154:	d9 06       	cpc	r13, r25
    1156:	ea 06       	cpc	r14, r26
    1158:	fb 06       	cpc	r15, r27
    115a:	08 f4       	brcc	.+2      	; 0x115e <main+0x3a8>
    115c:	72 cf       	rjmp	.-284    	; 0x1042 <main+0x28c>
							}
							//chb_write(0x0000,FRAMReadBuffer,samples*4);								
							//write the data to SD card for good measure (make sure transmitted and collected data is the same)	
							//writeFile(ofile, FRAMReadBuffer, samples*4);			
						}							
						DataAvailable = 0;
    115e:	10 92 47 3e 	sts	0x3E47, r1
    1162:	54 ce       	rjmp	.-856    	; 0xe0c <main+0x56>

00001164 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
    1164:	0f 93       	push	r16
    1166:	1f 93       	push	r17
    1168:	cf 93       	push	r28
    116a:	8c 01       	movw	r16, r24
	moteID = 1;
    116c:	c1 e0       	ldi	r28, 0x01	; 1
    116e:	c0 93 45 3e 	sts	0x3E45, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
    1172:	83 e0       	ldi	r24, 0x03	; 3
    1174:	80 93 1f 3e 	sts	0x3E1F, r24
	chb_init();
    1178:	0e 94 7c 19 	call	0x32f8	; 0x32f8 <chb_init>
	chb_set_short_addr(moteID);
    117c:	80 91 45 3e 	lds	r24, 0x3E45
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	0e 94 ae 1b 	call	0x375c	; 0x375c <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
    1186:	88 ec       	ldi	r24, 0xC8	; 200
    1188:	e0 e8       	ldi	r30, 0x80	; 128
    118a:	f1 e0       	ldi	r31, 0x01	; 1
    118c:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
    118e:	e0 e4       	ldi	r30, 0x40	; 64
    1190:	f9 e0       	ldi	r31, 0x09	; 9
    1192:	89 e0       	ldi	r24, 0x09	; 9
    1194:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
    1196:	82 e0       	ldi	r24, 0x02	; 2
    1198:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
    119a:	24 ef       	ldi	r18, 0xF4	; 244
    119c:	31 e0       	ldi	r19, 0x01	; 1
    119e:	02 9f       	mul	r16, r18
    11a0:	c0 01       	movw	r24, r0
    11a2:	03 9f       	mul	r16, r19
    11a4:	90 0d       	add	r25, r0
    11a6:	12 9f       	mul	r17, r18
    11a8:	90 0d       	add	r25, r0
    11aa:	11 24       	eor	r1, r1
    11ac:	86 a3       	lds	r24, 0x56
    11ae:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
    11b0:	e0 e4       	ldi	r30, 0x40	; 64
    11b2:	f8 e0       	ldi	r31, 0x08	; 8
    11b4:	80 e0       	ldi	r24, 0x00	; 0
    11b6:	9a ef       	ldi	r25, 0xFA	; 250
    11b8:	86 a3       	lds	r24, 0x56
    11ba:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
    11bc:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
    11be:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
    11c0:	e0 ea       	ldi	r30, 0xA0	; 160
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	82 81       	ldd	r24, Z+2	; 0x02
    11c6:	87 60       	ori	r24, 0x07	; 7
    11c8:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
    11ca:	78 94       	sei
}
    11cc:	cf 91       	pop	r28
    11ce:	1f 91       	pop	r17
    11d0:	0f 91       	pop	r16
    11d2:	08 95       	ret

000011d4 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
    11d4:	78 94       	sei
    11d6:	1f 92       	push	r1
    11d8:	0f 92       	push	r0
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	0f 92       	push	r0
    11de:	0b b6       	in	r0, 0x3b	; 59
    11e0:	0f 92       	push	r0
    11e2:	11 24       	eor	r1, r1
    11e4:	ef 92       	push	r14
    11e6:	ff 92       	push	r15
    11e8:	0f 93       	push	r16
    11ea:	1f 93       	push	r17
    11ec:	2f 93       	push	r18
    11ee:	3f 93       	push	r19
    11f0:	4f 93       	push	r20
    11f2:	5f 93       	push	r21
    11f4:	6f 93       	push	r22
    11f6:	7f 93       	push	r23
    11f8:	8f 93       	push	r24
    11fa:	9f 93       	push	r25
    11fc:	af 93       	push	r26
    11fe:	bf 93       	push	r27
    1200:	ef 93       	push	r30
    1202:	ff 93       	push	r31
    1204:	cf 93       	push	r28
    1206:	df 93       	push	r29
    1208:	cd b7       	in	r28, 0x3d	; 61
    120a:	de b7       	in	r29, 0x3e	; 62
    120c:	28 97       	sbiw	r28, 0x08	; 8
    120e:	cd bf       	out	0x3d, r28	; 61
    1210:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    1212:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    1216:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    121a:	82 e0       	ldi	r24, 0x02	; 2
    121c:	80 93 1f 3e 	sts	0x3E1F, r24
	char message[8];
	strcpy(message,"reset");
    1220:	de 01       	movw	r26, r28
    1222:	11 96       	adiw	r26, 0x01	; 1
    1224:	e4 e0       	ldi	r30, 0x04	; 4
    1226:	f0 e2       	ldi	r31, 0x20	; 32
    1228:	86 e0       	ldi	r24, 0x06	; 6
    122a:	01 90       	ld	r0, Z+
    122c:	0d 92       	st	X+, r0
    122e:	81 50       	subi	r24, 0x01	; 1
    1230:	e1 f7       	brne	.-8      	; 0x122a <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    1232:	09 ea       	ldi	r16, 0xA9	; 169
    1234:	10 e5       	ldi	r17, 0x50	; 80
    1236:	80 91 45 3e 	lds	r24, 0x3E45
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	b8 01       	movw	r22, r16
    123e:	4a e0       	ldi	r20, 0x0A	; 10
    1240:	50 e0       	ldi	r21, 0x00	; 0
    1242:	0e 94 8b 39 	call	0x7316	; 0x7316 <itoa>
	strcat(message,buff);
    1246:	7e 01       	movw	r14, r28
    1248:	08 94       	sec
    124a:	e1 1c       	adc	r14, r1
    124c:	f1 1c       	adc	r15, r1
    124e:	c7 01       	movw	r24, r14
    1250:	b8 01       	movw	r22, r16
    1252:	0e 94 80 39 	call	0x7300	; 0x7300 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    1256:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    125a:	f7 01       	movw	r30, r14
    125c:	01 90       	ld	r0, Z+
    125e:	00 20       	and	r0, r0
    1260:	e9 f7       	brne	.-6      	; 0x125c <__vector_83+0x88>
    1262:	31 97       	sbiw	r30, 0x01	; 1
    1264:	ee 19       	sub	r30, r14
    1266:	ff 09       	sbc	r31, r15
    1268:	9f 01       	movw	r18, r30
    126a:	40 e0       	ldi	r20, 0x00	; 0
    126c:	50 e0       	ldi	r21, 0x00	; 0
    126e:	80 e0       	ldi	r24, 0x00	; 0
    1270:	90 e0       	ldi	r25, 0x00	; 0
    1272:	b7 01       	movw	r22, r14
    1274:	0e 94 a0 19 	call	0x3340	; 0x3340 <chb_write>
}	
    1278:	28 96       	adiw	r28, 0x08	; 8
    127a:	cd bf       	out	0x3d, r28	; 61
    127c:	de bf       	out	0x3e, r29	; 62
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	ff 91       	pop	r31
    1284:	ef 91       	pop	r30
    1286:	bf 91       	pop	r27
    1288:	af 91       	pop	r26
    128a:	9f 91       	pop	r25
    128c:	8f 91       	pop	r24
    128e:	7f 91       	pop	r23
    1290:	6f 91       	pop	r22
    1292:	5f 91       	pop	r21
    1294:	4f 91       	pop	r20
    1296:	3f 91       	pop	r19
    1298:	2f 91       	pop	r18
    129a:	1f 91       	pop	r17
    129c:	0f 91       	pop	r16
    129e:	ff 90       	pop	r15
    12a0:	ef 90       	pop	r14
    12a2:	0f 90       	pop	r0
    12a4:	0b be       	out	0x3b, r0	; 59
    12a6:	0f 90       	pop	r0
    12a8:	0f be       	out	0x3f, r0	; 63
    12aa:	0f 90       	pop	r0
    12ac:	1f 90       	pop	r1
    12ae:	18 95       	reti

000012b0 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    12b0:	4f 92       	push	r4
    12b2:	5f 92       	push	r5
    12b4:	6f 92       	push	r6
    12b6:	7f 92       	push	r7
    12b8:	8f 92       	push	r8
    12ba:	9f 92       	push	r9
    12bc:	af 92       	push	r10
    12be:	bf 92       	push	r11
    12c0:	ef 92       	push	r14
    12c2:	ff 92       	push	r15
    12c4:	0f 93       	push	r16
    12c6:	1f 93       	push	r17
    12c8:	cf 93       	push	r28
    12ca:	df 93       	push	r29
    12cc:	cd b7       	in	r28, 0x3d	; 61
    12ce:	de b7       	in	r29, 0x3e	; 62
    12d0:	2b 97       	sbiw	r28, 0x0b	; 11
    12d2:	cd bf       	out	0x3d, r28	; 61
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	8e 83       	std	Y+6, r24	; 0x06
    12d8:	9f 83       	std	Y+7, r25	; 0x07
    12da:	68 87       	std	Y+8, r22	; 0x08
    12dc:	79 87       	std	Y+9, r23	; 0x09
    12de:	4a 87       	std	Y+10, r20	; 0x0a
    12e0:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    12e8:	80 e0       	ldi	r24, 0x00	; 0
    12ea:	92 e0       	ldi	r25, 0x02	; 2
    12ec:	0e 94 5f 19 	call	0x32be	; 0x32be <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    12f0:	00 e0       	ldi	r16, 0x00	; 0
    12f2:	12 e0       	ldi	r17, 0x02	; 2
    12f4:	d8 01       	movw	r26, r16
    12f6:	11 96       	adiw	r26, 0x01	; 1
    12f8:	8c 91       	ld	r24, X
    12fa:	11 97       	sbiw	r26, 0x01	; 1
    12fc:	89 7e       	andi	r24, 0xE9	; 233
    12fe:	11 96       	adiw	r26, 0x01	; 1
    1300:	8c 93       	st	X, r24
    1302:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    1304:	14 96       	adiw	r26, 0x04	; 4
    1306:	8c 91       	ld	r24, X
    1308:	14 97       	sbiw	r26, 0x04	; 4
    130a:	88 7f       	andi	r24, 0xF8	; 248
    130c:	83 60       	ori	r24, 0x03	; 3
    130e:	14 96       	adiw	r26, 0x04	; 4
    1310:	8c 93       	st	X, r24
    1312:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    1314:	12 96       	adiw	r26, 0x02	; 2
    1316:	8c 91       	ld	r24, X
    1318:	12 97       	sbiw	r26, 0x02	; 2
    131a:	8f 7c       	andi	r24, 0xCF	; 207
    131c:	12 96       	adiw	r26, 0x02	; 2
    131e:	8c 93       	st	X, r24
    1320:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    1322:	0f 2e       	mov	r0, r31
    1324:	f0 e2       	ldi	r31, 0x20	; 32
    1326:	ef 2e       	mov	r14, r31
    1328:	f2 e0       	ldi	r31, 0x02	; 2
    132a:	ff 2e       	mov	r15, r31
    132c:	f0 2d       	mov	r31, r0
    132e:	f7 01       	movw	r30, r14
    1330:	80 81       	ld	r24, Z
    1332:	80 7e       	andi	r24, 0xE0	; 224
    1334:	81 60       	ori	r24, 0x01	; 1
    1336:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1338:	89 e0       	ldi	r24, 0x09	; 9
    133a:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    133c:	8c 91       	ld	r24, X
    133e:	81 60       	ori	r24, 0x01	; 1
    1340:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1342:	80 e0       	ldi	r24, 0x00	; 0
    1344:	92 e0       	ldi	r25, 0x02	; 2
    1346:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    134a:	80 e0       	ldi	r24, 0x00	; 0
    134c:	92 e0       	ldi	r25, 0x02	; 2
    134e:	60 e2       	ldi	r22, 0x20	; 32
    1350:	72 e0       	ldi	r23, 0x02	; 2
    1352:	40 e0       	ldi	r20, 0x00	; 0
    1354:	0e 94 ee 18 	call	0x31dc	; 0x31dc <ADC_Offset_Get_Unsigned>
    1358:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    135a:	d8 01       	movw	r26, r16
    135c:	8c 91       	ld	r24, X
    135e:	8e 7f       	andi	r24, 0xFE	; 254
    1360:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1362:	f7 01       	movw	r30, r14
    1364:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    1366:	13 96       	adiw	r26, 0x03	; 3
    1368:	8c 91       	ld	r24, X
    136a:	13 97       	sbiw	r26, 0x03	; 3
    136c:	8f 73       	andi	r24, 0x3F	; 63
    136e:	13 96       	adiw	r26, 0x03	; 3
    1370:	8c 93       	st	X, r24
    1372:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    1374:	8c 91       	ld	r24, X
    1376:	81 60       	ori	r24, 0x01	; 1
    1378:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    137a:	80 e0       	ldi	r24, 0x00	; 0
    137c:	92 e0       	ldi	r25, 0x02	; 2
    137e:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    1382:	d8 01       	movw	r26, r16
    1384:	11 96       	adiw	r26, 0x01	; 1
    1386:	8c 91       	ld	r24, X
    1388:	11 97       	sbiw	r26, 0x01	; 1
    138a:	88 60       	ori	r24, 0x08	; 8
    138c:	11 96       	adiw	r26, 0x01	; 1
    138e:	8c 93       	st	X, r24
    1390:	ee 24       	eor	r14, r14
    1392:	ff 24       	eor	r15, r15
    1394:	68 94       	set
    1396:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    1398:	44 24       	eor	r4, r4
    139a:	55 24       	eor	r5, r5
    139c:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    139e:	20 e0       	ldi	r18, 0x00	; 0
    13a0:	30 e1       	ldi	r19, 0x10	; 16
    13a2:	40 e0       	ldi	r20, 0x00	; 0
    13a4:	50 e0       	ldi	r21, 0x00	; 0
    13a6:	2a 83       	std	Y+2, r18	; 0x02
    13a8:	3b 83       	std	Y+3, r19	; 0x03
    13aa:	4c 83       	std	Y+4, r20	; 0x04
    13ac:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    13ae:	88 24       	eor	r8, r8
    13b0:	99 24       	eor	r9, r9
    13b2:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    13b4:	00 e2       	ldi	r16, 0x20	; 32
    13b6:	12 e0       	ldi	r17, 0x02	; 2
    13b8:	d8 01       	movw	r26, r16
    13ba:	13 96       	adiw	r26, 0x03	; 3
    13bc:	8c 91       	ld	r24, X
    13be:	13 97       	sbiw	r26, 0x03	; 3
    13c0:	80 ff       	sbrs	r24, 0
    13c2:	fa cf       	rjmp	.-12     	; 0x13b8 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    13c4:	69 81       	ldd	r22, Y+1	; 0x01
    13c6:	c8 01       	movw	r24, r16
    13c8:	0e 94 c0 18 	call	0x3180	; 0x3180 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    13cc:	a0 e0       	ldi	r26, 0x00	; 0
    13ce:	b0 e0       	ldi	r27, 0x00	; 0
    13d0:	88 0e       	add	r8, r24
    13d2:	99 1e       	adc	r9, r25
    13d4:	aa 1e       	adc	r10, r26
    13d6:	bb 1e       	adc	r11, r27
    13d8:	48 16       	cp	r4, r24
    13da:	59 06       	cpc	r5, r25
    13dc:	6a 06       	cpc	r6, r26
    13de:	7b 06       	cpc	r7, r27
    13e0:	10 f4       	brcc	.+4      	; 0x13e6 <CO_collectTemp+0x136>
    13e2:	2c 01       	movw	r4, r24
    13e4:	3d 01       	movw	r6, r26
    13e6:	2a 81       	ldd	r18, Y+2	; 0x02
    13e8:	3b 81       	ldd	r19, Y+3	; 0x03
    13ea:	4c 81       	ldd	r20, Y+4	; 0x04
    13ec:	5d 81       	ldd	r21, Y+5	; 0x05
    13ee:	82 17       	cp	r24, r18
    13f0:	93 07       	cpc	r25, r19
    13f2:	a4 07       	cpc	r26, r20
    13f4:	b5 07       	cpc	r27, r21
    13f6:	20 f4       	brcc	.+8      	; 0x1400 <CO_collectTemp+0x150>
    13f8:	8a 83       	std	Y+2, r24	; 0x02
    13fa:	9b 83       	std	Y+3, r25	; 0x03
    13fc:	ac 83       	std	Y+4, r26	; 0x04
    13fe:	bd 83       	std	Y+5, r27	; 0x05
    1400:	08 94       	sec
    1402:	e1 08       	sbc	r14, r1
    1404:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1406:	e1 14       	cp	r14, r1
    1408:	f1 04       	cpc	r15, r1
    140a:	b1 f6       	brne	.-84     	; 0x13b8 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    140c:	e0 e0       	ldi	r30, 0x00	; 0
    140e:	f2 e0       	ldi	r31, 0x02	; 2
    1410:	81 81       	ldd	r24, Z+1	; 0x01
    1412:	87 7f       	andi	r24, 0xF7	; 247
    1414:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    1416:	80 81       	ld	r24, Z
    1418:	82 60       	ori	r24, 0x02	; 2
    141a:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    141c:	80 81       	ld	r24, Z
    141e:	8e 7f       	andi	r24, 0xFE	; 254
    1420:	80 83       	st	Z, r24

	ADCPower(FALSE);
    1422:	80 e0       	ldi	r24, 0x00	; 0
    1424:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	average = sum / NUM_SAMPLES;
    1428:	c5 01       	movw	r24, r10
    142a:	b4 01       	movw	r22, r8
    142c:	05 2e       	mov	r0, r21
    142e:	5a e0       	ldi	r21, 0x0A	; 10
    1430:	96 95       	lsr	r25
    1432:	87 95       	ror	r24
    1434:	77 95       	ror	r23
    1436:	67 95       	ror	r22
    1438:	5a 95       	dec	r21
    143a:	d1 f7       	brne	.-12     	; 0x1430 <CO_collectTemp+0x180>
    143c:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    143e:	28 ee       	ldi	r18, 0xE8	; 232
    1440:	33 e0       	ldi	r19, 0x03	; 3
    1442:	40 e0       	ldi	r20, 0x00	; 0
    1444:	50 e0       	ldi	r21, 0x00	; 0
    1446:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    144a:	0f 2e       	mov	r0, r31
    144c:	ff ef       	ldi	r31, 0xFF	; 255
    144e:	8f 2e       	mov	r8, r31
    1450:	ff e0       	ldi	r31, 0x0F	; 15
    1452:	9f 2e       	mov	r9, r31
    1454:	f0 e0       	ldi	r31, 0x00	; 0
    1456:	af 2e       	mov	r10, r31
    1458:	f0 e0       	ldi	r31, 0x00	; 0
    145a:	bf 2e       	mov	r11, r31
    145c:	f0 2d       	mov	r31, r0
    145e:	a5 01       	movw	r20, r10
    1460:	94 01       	movw	r18, r8
    1462:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    1466:	c9 01       	movw	r24, r18
    1468:	c2 97       	sbiw	r24, 0x32	; 50
    146a:	ae 81       	ldd	r26, Y+6	; 0x06
    146c:	bf 81       	ldd	r27, Y+7	; 0x07
    146e:	8d 93       	st	X+, r24
    1470:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1472:	c3 01       	movw	r24, r6
    1474:	b2 01       	movw	r22, r4
    1476:	28 ee       	ldi	r18, 0xE8	; 232
    1478:	33 e0       	ldi	r19, 0x03	; 3
    147a:	40 e0       	ldi	r20, 0x00	; 0
    147c:	50 e0       	ldi	r21, 0x00	; 0
    147e:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    1482:	a5 01       	movw	r20, r10
    1484:	94 01       	movw	r18, r8
    1486:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    148a:	c9 01       	movw	r24, r18
    148c:	c2 97       	sbiw	r24, 0x32	; 50
    148e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1490:	fb 85       	ldd	r31, Y+11	; 0x0b
    1492:	80 83       	st	Z, r24
    1494:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    1496:	6a 81       	ldd	r22, Y+2	; 0x02
    1498:	7b 81       	ldd	r23, Y+3	; 0x03
    149a:	8c 81       	ldd	r24, Y+4	; 0x04
    149c:	9d 81       	ldd	r25, Y+5	; 0x05
    149e:	28 ee       	ldi	r18, 0xE8	; 232
    14a0:	33 e0       	ldi	r19, 0x03	; 3
    14a2:	40 e0       	ldi	r20, 0x00	; 0
    14a4:	50 e0       	ldi	r21, 0x00	; 0
    14a6:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    14aa:	a5 01       	movw	r20, r10
    14ac:	94 01       	movw	r18, r8
    14ae:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    14b2:	22 53       	subi	r18, 0x32	; 50
    14b4:	30 40       	sbci	r19, 0x00	; 0
    14b6:	a8 85       	ldd	r26, Y+8	; 0x08
    14b8:	b9 85       	ldd	r27, Y+9	; 0x09
    14ba:	2d 93       	st	X+, r18
    14bc:	3c 93       	st	X, r19
    14be:	11 97       	sbiw	r26, 0x01	; 1
}
    14c0:	2b 96       	adiw	r28, 0x0b	; 11
    14c2:	cd bf       	out	0x3d, r28	; 61
    14c4:	de bf       	out	0x3e, r29	; 62
    14c6:	df 91       	pop	r29
    14c8:	cf 91       	pop	r28
    14ca:	1f 91       	pop	r17
    14cc:	0f 91       	pop	r16
    14ce:	ff 90       	pop	r15
    14d0:	ef 90       	pop	r14
    14d2:	bf 90       	pop	r11
    14d4:	af 90       	pop	r10
    14d6:	9f 90       	pop	r9
    14d8:	8f 90       	pop	r8
    14da:	7f 90       	pop	r7
    14dc:	6f 90       	pop	r6
    14de:	5f 90       	pop	r5
    14e0:	4f 90       	pop	r4
    14e2:	08 95       	ret

000014e4 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    14e4:	4f 92       	push	r4
    14e6:	5f 92       	push	r5
    14e8:	6f 92       	push	r6
    14ea:	7f 92       	push	r7
    14ec:	8f 92       	push	r8
    14ee:	9f 92       	push	r9
    14f0:	af 92       	push	r10
    14f2:	bf 92       	push	r11
    14f4:	ef 92       	push	r14
    14f6:	ff 92       	push	r15
    14f8:	0f 93       	push	r16
    14fa:	1f 93       	push	r17
    14fc:	cf 93       	push	r28
    14fe:	df 93       	push	r29
    1500:	cd b7       	in	r28, 0x3d	; 61
    1502:	de b7       	in	r29, 0x3e	; 62
    1504:	2b 97       	sbiw	r28, 0x0b	; 11
    1506:	cd bf       	out	0x3d, r28	; 61
    1508:	de bf       	out	0x3e, r29	; 62
    150a:	8e 83       	std	Y+6, r24	; 0x06
    150c:	9f 83       	std	Y+7, r25	; 0x07
    150e:	68 87       	std	Y+8, r22	; 0x08
    1510:	79 87       	std	Y+9, r23	; 0x09
    1512:	4a 87       	std	Y+10, r20	; 0x0a
    1514:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    151c:	84 e0       	ldi	r24, 0x04	; 4
    151e:	60 e0       	ldi	r22, 0x00	; 0
    1520:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    1524:	84 e0       	ldi	r24, 0x04	; 4
    1526:	60 e0       	ldi	r22, 0x00	; 0
    1528:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    152c:	2f ef       	ldi	r18, 0xFF	; 255
    152e:	33 ec       	ldi	r19, 0xC3	; 195
    1530:	49 e0       	ldi	r20, 0x09	; 9
    1532:	21 50       	subi	r18, 0x01	; 1
    1534:	30 40       	sbci	r19, 0x00	; 0
    1536:	40 40       	sbci	r20, 0x00	; 0
    1538:	e1 f7       	brne	.-8      	; 0x1532 <CO_collectBatt+0x4e>
    153a:	00 c0       	rjmp	.+0      	; 0x153c <CO_collectBatt+0x58>
    153c:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    153e:	80 e4       	ldi	r24, 0x40	; 64
    1540:	92 e0       	ldi	r25, 0x02	; 2
    1542:	0e 94 5f 19 	call	0x32be	; 0x32be <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    1546:	00 e4       	ldi	r16, 0x40	; 64
    1548:	12 e0       	ldi	r17, 0x02	; 2
    154a:	d8 01       	movw	r26, r16
    154c:	11 96       	adiw	r26, 0x01	; 1
    154e:	8c 91       	ld	r24, X
    1550:	11 97       	sbiw	r26, 0x01	; 1
    1552:	89 7e       	andi	r24, 0xE9	; 233
    1554:	11 96       	adiw	r26, 0x01	; 1
    1556:	8c 93       	st	X, r24
    1558:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    155a:	14 96       	adiw	r26, 0x04	; 4
    155c:	8c 91       	ld	r24, X
    155e:	14 97       	sbiw	r26, 0x04	; 4
    1560:	88 7f       	andi	r24, 0xF8	; 248
    1562:	83 60       	ori	r24, 0x03	; 3
    1564:	14 96       	adiw	r26, 0x04	; 4
    1566:	8c 93       	st	X, r24
    1568:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    156a:	12 96       	adiw	r26, 0x02	; 2
    156c:	8c 91       	ld	r24, X
    156e:	12 97       	sbiw	r26, 0x02	; 2
    1570:	8f 7c       	andi	r24, 0xCF	; 207
    1572:	12 96       	adiw	r26, 0x02	; 2
    1574:	8c 93       	st	X, r24
    1576:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    1578:	0f 2e       	mov	r0, r31
    157a:	f0 e6       	ldi	r31, 0x60	; 96
    157c:	ef 2e       	mov	r14, r31
    157e:	f2 e0       	ldi	r31, 0x02	; 2
    1580:	ff 2e       	mov	r15, r31
    1582:	f0 2d       	mov	r31, r0
    1584:	f7 01       	movw	r30, r14
    1586:	80 81       	ld	r24, Z
    1588:	80 7e       	andi	r24, 0xE0	; 224
    158a:	81 60       	ori	r24, 0x01	; 1
    158c:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    158e:	89 e0       	ldi	r24, 0x09	; 9
    1590:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    1592:	8c 91       	ld	r24, X
    1594:	81 60       	ori	r24, 0x01	; 1
    1596:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    1598:	80 e4       	ldi	r24, 0x40	; 64
    159a:	92 e0       	ldi	r25, 0x02	; 2
    159c:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    15a0:	80 e4       	ldi	r24, 0x40	; 64
    15a2:	92 e0       	ldi	r25, 0x02	; 2
    15a4:	60 e6       	ldi	r22, 0x60	; 96
    15a6:	72 e0       	ldi	r23, 0x02	; 2
    15a8:	40 e0       	ldi	r20, 0x00	; 0
    15aa:	0e 94 ee 18 	call	0x31dc	; 0x31dc <ADC_Offset_Get_Unsigned>
    15ae:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    15b0:	d8 01       	movw	r26, r16
    15b2:	8c 91       	ld	r24, X
    15b4:	8e 7f       	andi	r24, 0xFE	; 254
    15b6:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    15b8:	f7 01       	movw	r30, r14
    15ba:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    15bc:	13 96       	adiw	r26, 0x03	; 3
    15be:	8c 91       	ld	r24, X
    15c0:	13 97       	sbiw	r26, 0x03	; 3
    15c2:	8f 73       	andi	r24, 0x3F	; 63
    15c4:	13 96       	adiw	r26, 0x03	; 3
    15c6:	8c 93       	st	X, r24
    15c8:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    15ca:	8c 91       	ld	r24, X
    15cc:	81 60       	ori	r24, 0x01	; 1
    15ce:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    15d0:	80 e4       	ldi	r24, 0x40	; 64
    15d2:	92 e0       	ldi	r25, 0x02	; 2
    15d4:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    15d8:	d8 01       	movw	r26, r16
    15da:	11 96       	adiw	r26, 0x01	; 1
    15dc:	8c 91       	ld	r24, X
    15de:	11 97       	sbiw	r26, 0x01	; 1
    15e0:	88 60       	ori	r24, 0x08	; 8
    15e2:	11 96       	adiw	r26, 0x01	; 1
    15e4:	8c 93       	st	X, r24
    15e6:	ee 24       	eor	r14, r14
    15e8:	ff 24       	eor	r15, r15
    15ea:	68 94       	set
    15ec:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    15ee:	44 24       	eor	r4, r4
    15f0:	55 24       	eor	r5, r5
    15f2:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    15f4:	20 e0       	ldi	r18, 0x00	; 0
    15f6:	30 e1       	ldi	r19, 0x10	; 16
    15f8:	40 e0       	ldi	r20, 0x00	; 0
    15fa:	50 e0       	ldi	r21, 0x00	; 0
    15fc:	2a 83       	std	Y+2, r18	; 0x02
    15fe:	3b 83       	std	Y+3, r19	; 0x03
    1600:	4c 83       	std	Y+4, r20	; 0x04
    1602:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    1604:	88 24       	eor	r8, r8
    1606:	99 24       	eor	r9, r9
    1608:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    160a:	00 e6       	ldi	r16, 0x60	; 96
    160c:	12 e0       	ldi	r17, 0x02	; 2
    160e:	d8 01       	movw	r26, r16
    1610:	13 96       	adiw	r26, 0x03	; 3
    1612:	8c 91       	ld	r24, X
    1614:	13 97       	sbiw	r26, 0x03	; 3
    1616:	80 ff       	sbrs	r24, 0
    1618:	fa cf       	rjmp	.-12     	; 0x160e <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    161a:	69 81       	ldd	r22, Y+1	; 0x01
    161c:	c8 01       	movw	r24, r16
    161e:	0e 94 c0 18 	call	0x3180	; 0x3180 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    1622:	a0 e0       	ldi	r26, 0x00	; 0
    1624:	b0 e0       	ldi	r27, 0x00	; 0
    1626:	88 0e       	add	r8, r24
    1628:	99 1e       	adc	r9, r25
    162a:	aa 1e       	adc	r10, r26
    162c:	bb 1e       	adc	r11, r27
    162e:	48 16       	cp	r4, r24
    1630:	59 06       	cpc	r5, r25
    1632:	6a 06       	cpc	r6, r26
    1634:	7b 06       	cpc	r7, r27
    1636:	10 f4       	brcc	.+4      	; 0x163c <CO_collectBatt+0x158>
    1638:	2c 01       	movw	r4, r24
    163a:	3d 01       	movw	r6, r26
    163c:	2a 81       	ldd	r18, Y+2	; 0x02
    163e:	3b 81       	ldd	r19, Y+3	; 0x03
    1640:	4c 81       	ldd	r20, Y+4	; 0x04
    1642:	5d 81       	ldd	r21, Y+5	; 0x05
    1644:	82 17       	cp	r24, r18
    1646:	93 07       	cpc	r25, r19
    1648:	a4 07       	cpc	r26, r20
    164a:	b5 07       	cpc	r27, r21
    164c:	20 f4       	brcc	.+8      	; 0x1656 <CO_collectBatt+0x172>
    164e:	8a 83       	std	Y+2, r24	; 0x02
    1650:	9b 83       	std	Y+3, r25	; 0x03
    1652:	ac 83       	std	Y+4, r26	; 0x04
    1654:	bd 83       	std	Y+5, r27	; 0x05
    1656:	08 94       	sec
    1658:	e1 08       	sbc	r14, r1
    165a:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    165c:	e1 14       	cp	r14, r1
    165e:	f1 04       	cpc	r15, r1
    1660:	b1 f6       	brne	.-84     	; 0x160e <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    1662:	e0 e4       	ldi	r30, 0x40	; 64
    1664:	f2 e0       	ldi	r31, 0x02	; 2
    1666:	81 81       	ldd	r24, Z+1	; 0x01
    1668:	87 7f       	andi	r24, 0xF7	; 247
    166a:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    166c:	80 81       	ld	r24, Z
    166e:	8e 7f       	andi	r24, 0xFE	; 254
    1670:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    1672:	84 e0       	ldi	r24, 0x04	; 4
    1674:	60 e0       	ldi	r22, 0x00	; 0
    1676:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    167a:	80 e0       	ldi	r24, 0x00	; 0
    167c:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    1680:	c5 01       	movw	r24, r10
    1682:	b4 01       	movw	r22, r8
    1684:	05 2e       	mov	r0, r21
    1686:	5a e0       	ldi	r21, 0x0A	; 10
    1688:	96 95       	lsr	r25
    168a:	87 95       	ror	r24
    168c:	77 95       	ror	r23
    168e:	67 95       	ror	r22
    1690:	5a 95       	dec	r21
    1692:	d1 f7       	brne	.-12     	; 0x1688 <CO_collectBatt+0x1a4>
    1694:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1696:	28 ee       	ldi	r18, 0xE8	; 232
    1698:	33 e0       	ldi	r19, 0x03	; 3
    169a:	40 e0       	ldi	r20, 0x00	; 0
    169c:	50 e0       	ldi	r21, 0x00	; 0
    169e:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    16a2:	0f 2e       	mov	r0, r31
    16a4:	ff ef       	ldi	r31, 0xFF	; 255
    16a6:	8f 2e       	mov	r8, r31
    16a8:	ff e0       	ldi	r31, 0x0F	; 15
    16aa:	9f 2e       	mov	r9, r31
    16ac:	f0 e0       	ldi	r31, 0x00	; 0
    16ae:	af 2e       	mov	r10, r31
    16b0:	f0 e0       	ldi	r31, 0x00	; 0
    16b2:	bf 2e       	mov	r11, r31
    16b4:	f0 2d       	mov	r31, r0
    16b6:	a5 01       	movw	r20, r10
    16b8:	94 01       	movw	r18, r8
    16ba:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    16be:	c9 01       	movw	r24, r18
    16c0:	c2 97       	sbiw	r24, 0x32	; 50
    16c2:	ae 81       	ldd	r26, Y+6	; 0x06
    16c4:	bf 81       	ldd	r27, Y+7	; 0x07
    16c6:	8d 93       	st	X+, r24
    16c8:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    16ca:	c3 01       	movw	r24, r6
    16cc:	b2 01       	movw	r22, r4
    16ce:	28 ee       	ldi	r18, 0xE8	; 232
    16d0:	33 e0       	ldi	r19, 0x03	; 3
    16d2:	40 e0       	ldi	r20, 0x00	; 0
    16d4:	50 e0       	ldi	r21, 0x00	; 0
    16d6:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    16da:	a5 01       	movw	r20, r10
    16dc:	94 01       	movw	r18, r8
    16de:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    16e2:	c9 01       	movw	r24, r18
    16e4:	c2 97       	sbiw	r24, 0x32	; 50
    16e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    16e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    16ea:	80 83       	st	Z, r24
    16ec:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    16ee:	6a 81       	ldd	r22, Y+2	; 0x02
    16f0:	7b 81       	ldd	r23, Y+3	; 0x03
    16f2:	8c 81       	ldd	r24, Y+4	; 0x04
    16f4:	9d 81       	ldd	r25, Y+5	; 0x05
    16f6:	28 ee       	ldi	r18, 0xE8	; 232
    16f8:	33 e0       	ldi	r19, 0x03	; 3
    16fa:	40 e0       	ldi	r20, 0x00	; 0
    16fc:	50 e0       	ldi	r21, 0x00	; 0
    16fe:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    1702:	a5 01       	movw	r20, r10
    1704:	94 01       	movw	r18, r8
    1706:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    170a:	22 53       	subi	r18, 0x32	; 50
    170c:	30 40       	sbci	r19, 0x00	; 0
    170e:	a8 85       	ldd	r26, Y+8	; 0x08
    1710:	b9 85       	ldd	r27, Y+9	; 0x09
    1712:	2d 93       	st	X+, r18
    1714:	3c 93       	st	X, r19
    1716:	11 97       	sbiw	r26, 0x01	; 1
}
    1718:	2b 96       	adiw	r28, 0x0b	; 11
    171a:	cd bf       	out	0x3d, r28	; 61
    171c:	de bf       	out	0x3e, r29	; 62
    171e:	df 91       	pop	r29
    1720:	cf 91       	pop	r28
    1722:	1f 91       	pop	r17
    1724:	0f 91       	pop	r16
    1726:	ff 90       	pop	r15
    1728:	ef 90       	pop	r14
    172a:	bf 90       	pop	r11
    172c:	af 90       	pop	r10
    172e:	9f 90       	pop	r9
    1730:	8f 90       	pop	r8
    1732:	7f 90       	pop	r7
    1734:	6f 90       	pop	r6
    1736:	5f 90       	pop	r5
    1738:	4f 90       	pop	r4
    173a:	08 95       	ret

0000173c <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    173c:	cf 93       	push	r28
    173e:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    1740:	21 e0       	ldi	r18, 0x01	; 1
    1742:	30 e0       	ldi	r19, 0x00	; 0
    1744:	a9 01       	movw	r20, r18
    1746:	02 c0       	rjmp	.+4      	; 0x174c <set_ampGain+0x10>
    1748:	44 0f       	add	r20, r20
    174a:	55 1f       	adc	r21, r21
    174c:	8a 95       	dec	r24
    174e:	e2 f7       	brpl	.-8      	; 0x1748 <set_ampGain+0xc>
    1750:	ca 01       	movw	r24, r20
    1752:	61 e0       	ldi	r22, 0x01	; 1
    1754:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    1758:	c0 ff       	sbrs	r28, 0
    175a:	05 c0       	rjmp	.+10     	; 0x1766 <set_ampGain+0x2a>
    175c:	80 e4       	ldi	r24, 0x40	; 64
    175e:	e0 e0       	ldi	r30, 0x00	; 0
    1760:	f6 e0       	ldi	r31, 0x06	; 6
    1762:	85 83       	std	Z+5, r24	; 0x05
    1764:	04 c0       	rjmp	.+8      	; 0x176e <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    1766:	80 e4       	ldi	r24, 0x40	; 64
    1768:	e0 e0       	ldi	r30, 0x00	; 0
    176a:	f6 e0       	ldi	r31, 0x06	; 6
    176c:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    176e:	c1 ff       	sbrs	r28, 1
    1770:	05 c0       	rjmp	.+10     	; 0x177c <set_ampGain+0x40>
    1772:	82 e0       	ldi	r24, 0x02	; 2
    1774:	e0 e2       	ldi	r30, 0x20	; 32
    1776:	f6 e0       	ldi	r31, 0x06	; 6
    1778:	85 83       	std	Z+5, r24	; 0x05
    177a:	04 c0       	rjmp	.+8      	; 0x1784 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    177c:	82 e0       	ldi	r24, 0x02	; 2
    177e:	e0 e2       	ldi	r30, 0x20	; 32
    1780:	f6 e0       	ldi	r31, 0x06	; 6
    1782:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    1784:	c2 ff       	sbrs	r28, 2
    1786:	05 c0       	rjmp	.+10     	; 0x1792 <set_ampGain+0x56>
    1788:	84 e0       	ldi	r24, 0x04	; 4
    178a:	e0 e2       	ldi	r30, 0x20	; 32
    178c:	f6 e0       	ldi	r31, 0x06	; 6
    178e:	85 83       	std	Z+5, r24	; 0x05
    1790:	04 c0       	rjmp	.+8      	; 0x179a <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    1792:	84 e0       	ldi	r24, 0x04	; 4
    1794:	e0 e2       	ldi	r30, 0x20	; 32
    1796:	f6 e0       	ldi	r31, 0x06	; 6
    1798:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    179a:	5a e0       	ldi	r21, 0x0A	; 10
    179c:	5a 95       	dec	r21
    179e:	f1 f7       	brne	.-4      	; 0x179c <set_ampGain+0x60>
    17a0:	00 c0       	rjmp	.+0      	; 0x17a2 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    17a2:	8f ef       	ldi	r24, 0xFF	; 255
    17a4:	61 e0       	ldi	r22, 0x01	; 1
    17a6:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    17aa:	cf 91       	pop	r28
    17ac:	08 95       	ret

000017ae <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    17ae:	88 23       	and	r24, r24
    17b0:	31 f0       	breq	.+12     	; 0x17be <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    17b2:	e0 e0       	ldi	r30, 0x00	; 0
    17b4:	f6 e0       	ldi	r31, 0x06	; 6
    17b6:	80 e2       	ldi	r24, 0x20	; 32
    17b8:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    17ba:	85 83       	std	Z+5, r24	; 0x05
    17bc:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    17be:	e0 e0       	ldi	r30, 0x00	; 0
    17c0:	f6 e0       	ldi	r31, 0x06	; 6
    17c2:	80 e2       	ldi	r24, 0x20	; 32
    17c4:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    17c6:	82 83       	std	Z+2, r24	; 0x02
    17c8:	08 95       	ret

000017ca <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    17ca:	1f 92       	push	r1
    17cc:	0f 92       	push	r0
    17ce:	0f b6       	in	r0, 0x3f	; 63
    17d0:	0f 92       	push	r0
    17d2:	0b b6       	in	r0, 0x3b	; 59
    17d4:	0f 92       	push	r0
    17d6:	11 24       	eor	r1, r1
    17d8:	2f 93       	push	r18
    17da:	3f 93       	push	r19
    17dc:	4f 93       	push	r20
    17de:	5f 93       	push	r21
    17e0:	6f 93       	push	r22
    17e2:	7f 93       	push	r23
    17e4:	8f 93       	push	r24
    17e6:	9f 93       	push	r25
    17e8:	af 93       	push	r26
    17ea:	bf 93       	push	r27
    17ec:	ef 93       	push	r30
    17ee:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    17f0:	e0 e4       	ldi	r30, 0x40	; 64
    17f2:	fa e0       	ldi	r31, 0x0A	; 10
    17f4:	80 81       	ld	r24, Z
    17f6:	80 7f       	andi	r24, 0xF0	; 240
    17f8:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    17fa:	a0 e0       	ldi	r26, 0x00	; 0
    17fc:	b8 e0       	ldi	r27, 0x08	; 8
    17fe:	8c 91       	ld	r24, X
    1800:	80 7f       	andi	r24, 0xF0	; 240
    1802:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1804:	a0 e0       	ldi	r26, 0x00	; 0
    1806:	b9 e0       	ldi	r27, 0x09	; 9
    1808:	8c 91       	ld	r24, X
    180a:	80 7f       	andi	r24, 0xF0	; 240
    180c:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    180e:	80 81       	ld	r24, Z
    1810:	80 7f       	andi	r24, 0xF0	; 240
    1812:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1816:	80 e0       	ldi	r24, 0x00	; 0
    1818:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    181c:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    1820:	80 e0       	ldi	r24, 0x00	; 0
    1822:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	80 93 a6 50 	sts	0x50A6, r24
	DataAvailable = 1;
    182c:	80 93 47 3e 	sts	0x3E47, r24
}
    1830:	ff 91       	pop	r31
    1832:	ef 91       	pop	r30
    1834:	bf 91       	pop	r27
    1836:	af 91       	pop	r26
    1838:	9f 91       	pop	r25
    183a:	8f 91       	pop	r24
    183c:	7f 91       	pop	r23
    183e:	6f 91       	pop	r22
    1840:	5f 91       	pop	r21
    1842:	4f 91       	pop	r20
    1844:	3f 91       	pop	r19
    1846:	2f 91       	pop	r18
    1848:	0f 90       	pop	r0
    184a:	0b be       	out	0x3b, r0	; 59
    184c:	0f 90       	pop	r0
    184e:	0f be       	out	0x3f, r0	; 63
    1850:	0f 90       	pop	r0
    1852:	1f 90       	pop	r1
    1854:	18 95       	reti

00001856 <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1856:	e0 e4       	ldi	r30, 0x40	; 64
    1858:	fa e0       	ldi	r31, 0x0A	; 10
    185a:	80 81       	ld	r24, Z
    185c:	80 7f       	andi	r24, 0xF0	; 240
    185e:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1860:	a0 e0       	ldi	r26, 0x00	; 0
    1862:	b8 e0       	ldi	r27, 0x08	; 8
    1864:	8c 91       	ld	r24, X
    1866:	80 7f       	andi	r24, 0xF0	; 240
    1868:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    186a:	a0 e0       	ldi	r26, 0x00	; 0
    186c:	b9 e0       	ldi	r27, 0x09	; 9
    186e:	8c 91       	ld	r24, X
    1870:	80 7f       	andi	r24, 0xF0	; 240
    1872:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1874:	80 81       	ld	r24, Z
    1876:	80 7f       	andi	r24, 0xF0	; 240
    1878:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    187c:	80 e0       	ldi	r24, 0x00	; 0
    187e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    1882:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    1886:	80 e0       	ldi	r24, 0x00	; 0
    1888:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <enableADCMUX>
	ADC_Sampling_Finished = 1;
    188c:	81 e0       	ldi	r24, 0x01	; 1
    188e:	80 93 a6 50 	sts	0x50A6, r24
	DataAvailable = 1;
    1892:	80 93 47 3e 	sts	0x3E47, r24
}
    1896:	08 95       	ret

00001898 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    1898:	cf 93       	push	r28
    189a:	df 93       	push	r29
    189c:	0f 92       	push	r0
    189e:	0f 92       	push	r0
    18a0:	cd b7       	in	r28, 0x3d	; 61
    18a2:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    18a4:	80 91 a6 50 	lds	r24, 0x50A6
    18a8:	88 23       	and	r24, r24
    18aa:	89 f0       	breq	.+34     	; 0x18ce <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    18ac:	e0 e4       	ldi	r30, 0x40	; 64
    18ae:	f8 e0       	ldi	r31, 0x08	; 8
    18b0:	80 a1       	lds	r24, 0x40
    18b2:	91 a1       	lds	r25, 0x41
    18b4:	89 83       	std	Y+1, r24	; 0x01
    18b6:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    18b8:	89 81       	ldd	r24, Y+1	; 0x01
    18ba:	9a 81       	ldd	r25, Y+2	; 0x02
    18bc:	00 97       	sbiw	r24, 0x00	; 0
    18be:	21 f4       	brne	.+8      	; 0x18c8 <ADC_Get_Num_Samples+0x30>
    18c0:	86 a1       	lds	r24, 0x46
    18c2:	97 a1       	lds	r25, 0x47
    18c4:	89 83       	std	Y+1, r24	; 0x01
    18c6:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    18c8:	89 81       	ldd	r24, Y+1	; 0x01
    18ca:	9a 81       	ldd	r25, Y+2	; 0x02
    18cc:	02 c0       	rjmp	.+4      	; 0x18d2 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    18ce:	80 e0       	ldi	r24, 0x00	; 0
    18d0:	90 e0       	ldi	r25, 0x00	; 0
}
    18d2:	0f 90       	pop	r0
    18d4:	0f 90       	pop	r0
    18d6:	df 91       	pop	r29
    18d8:	cf 91       	pop	r28
    18da:	08 95       	ret

000018dc <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    18dc:	e0 ea       	ldi	r30, 0xA0	; 160
    18de:	f6 e0       	ldi	r31, 0x06	; 6
    18e0:	13 86       	std	Z+11, r1	; 0x0b
}
    18e2:	08 95       	ret

000018e4 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    18e4:	81 e0       	ldi	r24, 0x01	; 1
    18e6:	e0 ea       	ldi	r30, 0xA0	; 160
    18e8:	f6 e0       	ldi	r31, 0x06	; 6
    18ea:	83 87       	std	Z+11, r24	; 0x0b
}	
    18ec:	08 95       	ret

000018ee <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    18ee:	1f 92       	push	r1
    18f0:	0f 92       	push	r0
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	0f 92       	push	r0
    18f6:	0b b6       	in	r0, 0x3b	; 59
    18f8:	0f 92       	push	r0
    18fa:	11 24       	eor	r1, r1
    18fc:	6f 92       	push	r6
    18fe:	7f 92       	push	r7
    1900:	8f 92       	push	r8
    1902:	9f 92       	push	r9
    1904:	af 92       	push	r10
    1906:	bf 92       	push	r11
    1908:	cf 92       	push	r12
    190a:	df 92       	push	r13
    190c:	ef 92       	push	r14
    190e:	ff 92       	push	r15
    1910:	0f 93       	push	r16
    1912:	1f 93       	push	r17
    1914:	2f 93       	push	r18
    1916:	3f 93       	push	r19
    1918:	4f 93       	push	r20
    191a:	5f 93       	push	r21
    191c:	6f 93       	push	r22
    191e:	7f 93       	push	r23
    1920:	8f 93       	push	r24
    1922:	9f 93       	push	r25
    1924:	af 93       	push	r26
    1926:	bf 93       	push	r27
    1928:	ef 93       	push	r30
    192a:	ff 93       	push	r31
    192c:	cf 93       	push	r28
    192e:	df 93       	push	r29
    1930:	cd b7       	in	r28, 0x3d	; 61
    1932:	de b7       	in	r29, 0x3e	; 62
    1934:	2c 97       	sbiw	r28, 0x0c	; 12
    1936:	cd bf       	out	0x3d, r28	; 61
    1938:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    193a:	80 91 5c 40 	lds	r24, 0x405C
    193e:	88 23       	and	r24, r24
    1940:	8c f0       	brlt	.+34     	; 0x1964 <__vector_104+0x76>
		discardCount++;
    1942:	80 91 5c 40 	lds	r24, 0x405C
    1946:	8f 5f       	subi	r24, 0xFF	; 255
    1948:	80 93 5c 40 	sts	0x405C, r24
		if(discardCount == ADC_DISCARD){
    194c:	80 91 5c 40 	lds	r24, 0x405C
    1950:	80 38       	cpi	r24, 0x80	; 128
    1952:	09 f0       	breq	.+2      	; 0x1956 <__vector_104+0x68>
    1954:	e9 c0       	rjmp	.+466    	; 0x1b28 <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1956:	e0 e4       	ldi	r30, 0x40	; 64
    1958:	f8 e0       	ldi	r31, 0x08	; 8
    195a:	80 81       	ld	r24, Z
    195c:	80 7f       	andi	r24, 0xF0	; 240
    195e:	89 60       	ori	r24, 0x09	; 9
    1960:	80 83       	st	Z, r24
    1962:	e2 c0       	rjmp	.+452    	; 0x1b28 <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    196a:	82 e0       	ldi	r24, 0x02	; 2
    196c:	e0 ea       	ldi	r30, 0xA0	; 160
    196e:	f6 e0       	ldi	r31, 0x06	; 6
    1970:	86 83       	std	Z+6, r24	; 0x06
    1972:	80 e0       	ldi	r24, 0x00	; 0
    1974:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1976:	e0 ec       	ldi	r30, 0xC0	; 192
    1978:	f8 e0       	ldi	r31, 0x08	; 8
    197a:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    197c:	20 e2       	ldi	r18, 0x20	; 32
    197e:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1980:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1982:	42 81       	ldd	r20, Z+2	; 0x02
    1984:	44 23       	and	r20, r20
    1986:	ec f7       	brge	.-6      	; 0x1982 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1988:	43 81       	ldd	r20, Z+3	; 0x03
    198a:	d9 01       	movw	r26, r18
    198c:	a8 0f       	add	r26, r24
    198e:	b9 1f       	adc	r27, r25
    1990:	4c 93       	st	X, r20
    1992:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1994:	83 30       	cpi	r24, 0x03	; 3
    1996:	91 05       	cpc	r25, r1
    1998:	99 f7       	brne	.-26     	; 0x1980 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    199a:	82 e0       	ldi	r24, 0x02	; 2
    199c:	e0 ea       	ldi	r30, 0xA0	; 160
    199e:	f6 e0       	ldi	r31, 0x06	; 6
    19a0:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    19a2:	80 e0       	ldi	r24, 0x00	; 0
    19a4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    19a8:	80 91 20 3e 	lds	r24, 0x3E20
    19ac:	88 23       	and	r24, r24
    19ae:	1c f4       	brge	.+6      	; 0x19b6 <__vector_104+0xc8>
    19b0:	8f ef       	ldi	r24, 0xFF	; 255
    19b2:	8c 83       	std	Y+4, r24	; 0x04
    19b4:	01 c0       	rjmp	.+2      	; 0x19b8 <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    19b6:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    19b8:	80 91 20 3e 	lds	r24, 0x3E20
    19bc:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    19be:	80 91 21 3e 	lds	r24, 0x3E21
    19c2:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    19c4:	80 91 22 3e 	lds	r24, 0x3E22
    19c8:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	9a 81       	ldd	r25, Y+2	; 0x02
    19ce:	ab 81       	ldd	r26, Y+3	; 0x03
    19d0:	bc 81       	ldd	r27, Y+4	; 0x04
    19d2:	ac 01       	movw	r20, r24
    19d4:	bd 01       	movw	r22, r26
    19d6:	77 0f       	add	r23, r23
    19d8:	44 0b       	sbc	r20, r20
    19da:	54 2f       	mov	r21, r20
    19dc:	ba 01       	movw	r22, r20
    19de:	8d 83       	std	Y+5, r24	; 0x05
    19e0:	9e 83       	std	Y+6, r25	; 0x06
    19e2:	af 83       	std	Y+7, r26	; 0x07
    19e4:	b8 87       	std	Y+8, r27	; 0x08
    19e6:	49 87       	std	Y+9, r20	; 0x09
    19e8:	4a 87       	std	Y+10, r20	; 0x0a
    19ea:	4b 87       	std	Y+11, r20	; 0x0b
    19ec:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    19ee:	60 91 65 50 	lds	r22, 0x5065
    19f2:	70 91 66 50 	lds	r23, 0x5066
    19f6:	80 91 67 50 	lds	r24, 0x5067
    19fa:	90 91 68 50 	lds	r25, 0x5068
    19fe:	8d 80       	ldd	r8, Y+5	; 0x05
    1a00:	1e 81       	ldd	r17, Y+6	; 0x06
    1a02:	0f 81       	ldd	r16, Y+7	; 0x07
    1a04:	f8 84       	ldd	r15, Y+8	; 0x08
    1a06:	e9 84       	ldd	r14, Y+9	; 0x09
    1a08:	da 84       	ldd	r13, Y+10	; 0x0a
    1a0a:	cb 84       	ldd	r12, Y+11	; 0x0b
    1a0c:	bc 84       	ldd	r11, Y+12	; 0x0c
    1a0e:	20 91 a7 50 	lds	r18, 0x50A7
    1a12:	30 91 a8 50 	lds	r19, 0x50A8
    1a16:	40 e0       	ldi	r20, 0x00	; 0
    1a18:	50 e0       	ldi	r21, 0x00	; 0
    1a1a:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    1a1e:	66 0f       	add	r22, r22
    1a20:	77 1f       	adc	r23, r23
    1a22:	66 0f       	add	r22, r22
    1a24:	77 1f       	adc	r23, r23
    1a26:	80 91 63 50 	lds	r24, 0x5063
    1a2a:	90 91 64 50 	lds	r25, 0x5064
    1a2e:	3c 01       	movw	r6, r24
    1a30:	66 0e       	add	r6, r22
    1a32:	77 1e       	adc	r7, r23
    1a34:	28 2d       	mov	r18, r8
    1a36:	31 2f       	mov	r19, r17
    1a38:	40 2f       	mov	r20, r16
    1a3a:	5f 2d       	mov	r21, r15
    1a3c:	6e 2d       	mov	r22, r14
    1a3e:	7d 2d       	mov	r23, r13
    1a40:	8c 2d       	mov	r24, r12
    1a42:	9b 2d       	mov	r25, r11
    1a44:	0f 2e       	mov	r0, r31
    1a46:	f0 ea       	ldi	r31, 0xA0	; 160
    1a48:	af 2e       	mov	r10, r31
    1a4a:	f0 2d       	mov	r31, r0
    1a4c:	0f 2e       	mov	r0, r31
    1a4e:	f5 e2       	ldi	r31, 0x25	; 37
    1a50:	bf 2e       	mov	r11, r31
    1a52:	f0 2d       	mov	r31, r0
    1a54:	0f 2e       	mov	r0, r31
    1a56:	f6 e2       	ldi	r31, 0x26	; 38
    1a58:	cf 2e       	mov	r12, r31
    1a5a:	f0 2d       	mov	r31, r0
    1a5c:	dd 24       	eor	r13, r13
    1a5e:	ee 24       	eor	r14, r14
    1a60:	ff 24       	eor	r15, r15
    1a62:	00 e0       	ldi	r16, 0x00	; 0
    1a64:	10 e0       	ldi	r17, 0x00	; 0
    1a66:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <__muldi3>
    1a6a:	aa 24       	eor	r10, r10
    1a6c:	aa 94       	dec	r10
    1a6e:	bb 24       	eor	r11, r11
    1a70:	ba 94       	dec	r11
    1a72:	0f 2e       	mov	r0, r31
    1a74:	ff e7       	ldi	r31, 0x7F	; 127
    1a76:	cf 2e       	mov	r12, r31
    1a78:	f0 2d       	mov	r31, r0
    1a7a:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <__divdi3>
    1a7e:	01 e0       	ldi	r16, 0x01	; 1
    1a80:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <__ashldi3>
    1a84:	0f 2e       	mov	r0, r31
    1a86:	f3 e0       	ldi	r31, 0x03	; 3
    1a88:	af 2e       	mov	r10, r31
    1a8a:	f0 2d       	mov	r31, r0
    1a8c:	bb 24       	eor	r11, r11
    1a8e:	cc 24       	eor	r12, r12
    1a90:	00 e0       	ldi	r16, 0x00	; 0
    1a92:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <__divdi3>
    1a96:	82 2e       	mov	r8, r18
    1a98:	93 2e       	mov	r9, r19
    1a9a:	a4 2e       	mov	r10, r20
    1a9c:	b5 2e       	mov	r11, r21
    1a9e:	b0 94       	com	r11
    1aa0:	a0 94       	com	r10
    1aa2:	90 94       	com	r9
    1aa4:	80 94       	com	r8
    1aa6:	81 1c       	adc	r8, r1
    1aa8:	91 1c       	adc	r9, r1
    1aaa:	a1 1c       	adc	r10, r1
    1aac:	b1 1c       	adc	r11, r1
    1aae:	f3 01       	movw	r30, r6
    1ab0:	80 82       	st	Z, r8
    1ab2:	91 82       	std	Z+1, r9	; 0x01
    1ab4:	a2 82       	std	Z+2, r10	; 0x02
    1ab6:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    1ab8:	80 91 48 40 	lds	r24, 0x4048
    1abc:	88 23       	and	r24, r24
    1abe:	09 f1       	breq	.+66     	; 0x1b02 <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1ac0:	60 91 65 50 	lds	r22, 0x5065
    1ac4:	70 91 66 50 	lds	r23, 0x5066
    1ac8:	80 91 67 50 	lds	r24, 0x5067
    1acc:	90 91 68 50 	lds	r25, 0x5068
    1ad0:	20 91 a7 50 	lds	r18, 0x50A7
    1ad4:	30 91 a8 50 	lds	r19, 0x50A8
    1ad8:	40 e0       	ldi	r20, 0x00	; 0
    1ada:	50 e0       	ldi	r21, 0x00	; 0
    1adc:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    1ae0:	dc 01       	movw	r26, r24
    1ae2:	cb 01       	movw	r24, r22
    1ae4:	9c 01       	movw	r18, r24
    1ae6:	22 0f       	add	r18, r18
    1ae8:	33 1f       	adc	r19, r19
    1aea:	22 0f       	add	r18, r18
    1aec:	33 1f       	adc	r19, r19
    1aee:	80 91 63 50 	lds	r24, 0x5063
    1af2:	90 91 64 50 	lds	r25, 0x5064
    1af6:	82 0f       	add	r24, r18
    1af8:	93 1f       	adc	r25, r19
    1afa:	64 e0       	ldi	r22, 0x04	; 4
    1afc:	70 e0       	ldi	r23, 0x00	; 0
    1afe:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    1b02:	80 91 65 50 	lds	r24, 0x5065
    1b06:	90 91 66 50 	lds	r25, 0x5066
    1b0a:	a0 91 67 50 	lds	r26, 0x5067
    1b0e:	b0 91 68 50 	lds	r27, 0x5068
    1b12:	01 96       	adiw	r24, 0x01	; 1
    1b14:	a1 1d       	adc	r26, r1
    1b16:	b1 1d       	adc	r27, r1
    1b18:	80 93 65 50 	sts	0x5065, r24
    1b1c:	90 93 66 50 	sts	0x5066, r25
    1b20:	a0 93 67 50 	sts	0x5067, r26
    1b24:	b0 93 68 50 	sts	0x5068, r27
	}
}
    1b28:	2c 96       	adiw	r28, 0x0c	; 12
    1b2a:	cd bf       	out	0x3d, r28	; 61
    1b2c:	de bf       	out	0x3e, r29	; 62
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	ff 91       	pop	r31
    1b34:	ef 91       	pop	r30
    1b36:	bf 91       	pop	r27
    1b38:	af 91       	pop	r26
    1b3a:	9f 91       	pop	r25
    1b3c:	8f 91       	pop	r24
    1b3e:	7f 91       	pop	r23
    1b40:	6f 91       	pop	r22
    1b42:	5f 91       	pop	r21
    1b44:	4f 91       	pop	r20
    1b46:	3f 91       	pop	r19
    1b48:	2f 91       	pop	r18
    1b4a:	1f 91       	pop	r17
    1b4c:	0f 91       	pop	r16
    1b4e:	ff 90       	pop	r15
    1b50:	ef 90       	pop	r14
    1b52:	df 90       	pop	r13
    1b54:	cf 90       	pop	r12
    1b56:	bf 90       	pop	r11
    1b58:	af 90       	pop	r10
    1b5a:	9f 90       	pop	r9
    1b5c:	8f 90       	pop	r8
    1b5e:	7f 90       	pop	r7
    1b60:	6f 90       	pop	r6
    1b62:	0f 90       	pop	r0
    1b64:	0b be       	out	0x3b, r0	; 59
    1b66:	0f 90       	pop	r0
    1b68:	0f be       	out	0x3f, r0	; 63
    1b6a:	0f 90       	pop	r0
    1b6c:	1f 90       	pop	r1
    1b6e:	18 95       	reti

00001b70 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1b70:	88 23       	and	r24, r24
    1b72:	49 f0       	breq	.+18     	; 0x1b86 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1b74:	80 e2       	ldi	r24, 0x20	; 32
    1b76:	60 e0       	ldi	r22, 0x00	; 0
    1b78:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1b7c:	80 e2       	ldi	r24, 0x20	; 32
    1b7e:	60 e0       	ldi	r22, 0x00	; 0
    1b80:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    1b84:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1b86:	80 e2       	ldi	r24, 0x20	; 32
    1b88:	60 e0       	ldi	r22, 0x00	; 0
    1b8a:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
    1b8e:	08 95       	ret

00001b90 <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1b90:	1f 92       	push	r1
    1b92:	0f 92       	push	r0
    1b94:	0f b6       	in	r0, 0x3f	; 63
    1b96:	0f 92       	push	r0
    1b98:	0b b6       	in	r0, 0x3b	; 59
    1b9a:	0f 92       	push	r0
    1b9c:	11 24       	eor	r1, r1
    1b9e:	6f 92       	push	r6
    1ba0:	7f 92       	push	r7
    1ba2:	8f 92       	push	r8
    1ba4:	9f 92       	push	r9
    1ba6:	af 92       	push	r10
    1ba8:	bf 92       	push	r11
    1baa:	cf 92       	push	r12
    1bac:	df 92       	push	r13
    1bae:	ef 92       	push	r14
    1bb0:	ff 92       	push	r15
    1bb2:	0f 93       	push	r16
    1bb4:	1f 93       	push	r17
    1bb6:	2f 93       	push	r18
    1bb8:	3f 93       	push	r19
    1bba:	4f 93       	push	r20
    1bbc:	5f 93       	push	r21
    1bbe:	6f 93       	push	r22
    1bc0:	7f 93       	push	r23
    1bc2:	8f 93       	push	r24
    1bc4:	9f 93       	push	r25
    1bc6:	af 93       	push	r26
    1bc8:	bf 93       	push	r27
    1bca:	ef 93       	push	r30
    1bcc:	ff 93       	push	r31
    1bce:	cf 93       	push	r28
    1bd0:	df 93       	push	r29
    1bd2:	cd b7       	in	r28, 0x3d	; 61
    1bd4:	de b7       	in	r29, 0x3e	; 62
    1bd6:	2c 97       	sbiw	r28, 0x0c	; 12
    1bd8:	cd bf       	out	0x3d, r28	; 61
    1bda:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1bdc:	19 82       	std	Y+1, r1	; 0x01
    1bde:	1a 82       	std	Y+2, r1	; 0x02
    1be0:	1b 82       	std	Y+3, r1	; 0x03
    1be2:	1c 82       	std	Y+4, r1	; 0x04
    1be4:	1d 82       	std	Y+5, r1	; 0x05
    1be6:	1e 82       	std	Y+6, r1	; 0x06
    1be8:	1f 82       	std	Y+7, r1	; 0x07
    1bea:	18 86       	std	Y+8, r1	; 0x08
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1bf0:	20 e2       	ldi	r18, 0x20	; 32
    1bf2:	3e e3       	ldi	r19, 0x3E	; 62
    1bf4:	88 24       	eor	r8, r8
    1bf6:	8a 94       	dec	r8
    1bf8:	ac 01       	movw	r20, r24
    1bfa:	f9 01       	movw	r30, r18
    1bfc:	e8 0f       	add	r30, r24
    1bfe:	f9 1f       	adc	r31, r25
    1c00:	60 81       	ld	r22, Z
    1c02:	66 23       	and	r22, r22
    1c04:	14 f4       	brge	.+4      	; 0x1c0a <__vector_14+0x7a>
    1c06:	8c 86       	std	Y+12, r8	; 0x0c
    1c08:	01 c0       	rjmp	.+2      	; 0x1c0c <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1c0a:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1c0c:	42 0f       	add	r20, r18
    1c0e:	53 1f       	adc	r21, r19
    1c10:	fa 01       	movw	r30, r20
    1c12:	40 81       	ld	r20, Z
    1c14:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1c16:	fc 01       	movw	r30, r24
    1c18:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1c1a:	e2 0f       	add	r30, r18
    1c1c:	f3 1f       	adc	r31, r19
    1c1e:	40 81       	ld	r20, Z
    1c20:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1c22:	fc 01       	movw	r30, r24
    1c24:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1c26:	e2 0f       	add	r30, r18
    1c28:	f3 1f       	adc	r31, r19
    1c2a:	40 81       	ld	r20, Z
    1c2c:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1c2e:	49 85       	ldd	r20, Y+9	; 0x09
    1c30:	5a 85       	ldd	r21, Y+10	; 0x0a
    1c32:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c34:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c36:	a9 80       	ldd	r10, Y+1	; 0x01
    1c38:	ba 80       	ldd	r11, Y+2	; 0x02
    1c3a:	cb 80       	ldd	r12, Y+3	; 0x03
    1c3c:	dc 80       	ldd	r13, Y+4	; 0x04
    1c3e:	ed 80       	ldd	r14, Y+5	; 0x05
    1c40:	fe 80       	ldd	r15, Y+6	; 0x06
    1c42:	0f 81       	ldd	r16, Y+7	; 0x07
    1c44:	18 85       	ldd	r17, Y+8	; 0x08
    1c46:	b4 2f       	mov	r27, r20
    1c48:	a5 2f       	mov	r26, r21
    1c4a:	f6 2f       	mov	r31, r22
    1c4c:	e7 2f       	mov	r30, r23
    1c4e:	77 0f       	add	r23, r23
    1c50:	44 0b       	sbc	r20, r20
    1c52:	54 2f       	mov	r21, r20
    1c54:	ba 01       	movw	r22, r20
    1c56:	64 2e       	mov	r6, r20
    1c58:	74 2e       	mov	r7, r20
    1c5a:	94 2e       	mov	r9, r20
    1c5c:	ab 0e       	add	r10, r27
    1c5e:	61 e0       	ldi	r22, 0x01	; 1
    1c60:	ab 16       	cp	r10, r27
    1c62:	08 f0       	brcs	.+2      	; 0x1c66 <__vector_14+0xd6>
    1c64:	60 e0       	ldi	r22, 0x00	; 0
    1c66:	ba 0e       	add	r11, r26
    1c68:	51 e0       	ldi	r21, 0x01	; 1
    1c6a:	ba 16       	cp	r11, r26
    1c6c:	08 f0       	brcs	.+2      	; 0x1c70 <__vector_14+0xe0>
    1c6e:	50 e0       	ldi	r21, 0x00	; 0
    1c70:	a6 2f       	mov	r26, r22
    1c72:	ab 0d       	add	r26, r11
    1c74:	61 e0       	ldi	r22, 0x01	; 1
    1c76:	ab 15       	cp	r26, r11
    1c78:	08 f0       	brcs	.+2      	; 0x1c7c <__vector_14+0xec>
    1c7a:	60 e0       	ldi	r22, 0x00	; 0
    1c7c:	56 2b       	or	r21, r22
    1c7e:	cf 0e       	add	r12, r31
    1c80:	61 e0       	ldi	r22, 0x01	; 1
    1c82:	cf 16       	cp	r12, r31
    1c84:	08 f0       	brcs	.+2      	; 0x1c88 <__vector_14+0xf8>
    1c86:	60 e0       	ldi	r22, 0x00	; 0
    1c88:	f5 2f       	mov	r31, r21
    1c8a:	fc 0d       	add	r31, r12
    1c8c:	51 e0       	ldi	r21, 0x01	; 1
    1c8e:	fc 15       	cp	r31, r12
    1c90:	08 f0       	brcs	.+2      	; 0x1c94 <__vector_14+0x104>
    1c92:	50 e0       	ldi	r21, 0x00	; 0
    1c94:	65 2b       	or	r22, r21
    1c96:	de 0e       	add	r13, r30
    1c98:	51 e0       	ldi	r21, 0x01	; 1
    1c9a:	de 16       	cp	r13, r30
    1c9c:	08 f0       	brcs	.+2      	; 0x1ca0 <__vector_14+0x110>
    1c9e:	50 e0       	ldi	r21, 0x00	; 0
    1ca0:	e6 2f       	mov	r30, r22
    1ca2:	ed 0d       	add	r30, r13
    1ca4:	61 e0       	ldi	r22, 0x01	; 1
    1ca6:	ed 15       	cp	r30, r13
    1ca8:	08 f0       	brcs	.+2      	; 0x1cac <__vector_14+0x11c>
    1caa:	60 e0       	ldi	r22, 0x00	; 0
    1cac:	56 2b       	or	r21, r22
    1cae:	e6 0c       	add	r14, r6
    1cb0:	71 e0       	ldi	r23, 0x01	; 1
    1cb2:	e6 14       	cp	r14, r6
    1cb4:	08 f0       	brcs	.+2      	; 0x1cb8 <__vector_14+0x128>
    1cb6:	70 e0       	ldi	r23, 0x00	; 0
    1cb8:	b5 2f       	mov	r27, r21
    1cba:	be 0d       	add	r27, r14
    1cbc:	51 e0       	ldi	r21, 0x01	; 1
    1cbe:	be 15       	cp	r27, r14
    1cc0:	08 f0       	brcs	.+2      	; 0x1cc4 <__vector_14+0x134>
    1cc2:	50 e0       	ldi	r21, 0x00	; 0
    1cc4:	75 2b       	or	r23, r21
    1cc6:	f7 0c       	add	r15, r7
    1cc8:	61 e0       	ldi	r22, 0x01	; 1
    1cca:	f7 14       	cp	r15, r7
    1ccc:	08 f0       	brcs	.+2      	; 0x1cd0 <__vector_14+0x140>
    1cce:	60 e0       	ldi	r22, 0x00	; 0
    1cd0:	7f 0d       	add	r23, r15
    1cd2:	51 e0       	ldi	r21, 0x01	; 1
    1cd4:	7f 15       	cp	r23, r15
    1cd6:	08 f0       	brcs	.+2      	; 0x1cda <__vector_14+0x14a>
    1cd8:	50 e0       	ldi	r21, 0x00	; 0
    1cda:	65 2b       	or	r22, r21
    1cdc:	09 0d       	add	r16, r9
    1cde:	51 e0       	ldi	r21, 0x01	; 1
    1ce0:	09 15       	cp	r16, r9
    1ce2:	08 f0       	brcs	.+2      	; 0x1ce6 <__vector_14+0x156>
    1ce4:	50 e0       	ldi	r21, 0x00	; 0
    1ce6:	60 0f       	add	r22, r16
    1ce8:	ff 24       	eor	r15, r15
    1cea:	f3 94       	inc	r15
    1cec:	60 17       	cp	r22, r16
    1cee:	08 f0       	brcs	.+2      	; 0x1cf2 <__vector_14+0x162>
    1cf0:	ff 24       	eor	r15, r15
    1cf2:	5f 29       	or	r21, r15
    1cf4:	41 0f       	add	r20, r17
    1cf6:	54 0f       	add	r21, r20
    1cf8:	a9 82       	std	Y+1, r10	; 0x01
    1cfa:	aa 83       	std	Y+2, r26	; 0x02
    1cfc:	fb 83       	std	Y+3, r31	; 0x03
    1cfe:	ec 83       	std	Y+4, r30	; 0x04
    1d00:	bd 83       	std	Y+5, r27	; 0x05
    1d02:	7e 83       	std	Y+6, r23	; 0x06
    1d04:	6f 83       	std	Y+7, r22	; 0x07
    1d06:	58 87       	std	Y+8, r21	; 0x08
    1d08:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1d0a:	8c 30       	cpi	r24, 0x0C	; 12
    1d0c:	91 05       	cpc	r25, r1
    1d0e:	09 f0       	breq	.+2      	; 0x1d12 <__vector_14+0x182>
    1d10:	73 cf       	rjmp	.-282    	; 0x1bf8 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1d12:	e9 80       	ldd	r14, Y+1	; 0x01
    1d14:	fa 80       	ldd	r15, Y+2	; 0x02
    1d16:	0b 81       	ldd	r16, Y+3	; 0x03
    1d18:	1c 81       	ldd	r17, Y+4	; 0x04
    1d1a:	bd 81       	ldd	r27, Y+5	; 0x05
    1d1c:	ae 81       	ldd	r26, Y+6	; 0x06
    1d1e:	ff 81       	ldd	r31, Y+7	; 0x07
    1d20:	e8 85       	ldd	r30, Y+8	; 0x08
    1d22:	2e 2d       	mov	r18, r14
    1d24:	3f 2d       	mov	r19, r15
    1d26:	40 2f       	mov	r20, r16
    1d28:	51 2f       	mov	r21, r17
    1d2a:	6b 2f       	mov	r22, r27
    1d2c:	7a 2f       	mov	r23, r26
    1d2e:	8f 2f       	mov	r24, r31
    1d30:	9e 2f       	mov	r25, r30
    1d32:	ee 23       	and	r30, r30
    1d34:	0c f0       	brlt	.+2      	; 0x1d38 <__vector_14+0x1a8>
    1d36:	4a c0       	rjmp	.+148    	; 0x1dcc <__vector_14+0x23c>
    1d38:	93 e0       	ldi	r25, 0x03	; 3
    1d3a:	e9 0e       	add	r14, r25
    1d3c:	91 e0       	ldi	r25, 0x01	; 1
    1d3e:	e2 16       	cp	r14, r18
    1d40:	08 f0       	brcs	.+2      	; 0x1d44 <__vector_14+0x1b4>
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	21 e0       	ldi	r18, 0x01	; 1
    1d46:	f3 16       	cp	r15, r19
    1d48:	08 f0       	brcs	.+2      	; 0x1d4c <__vector_14+0x1bc>
    1d4a:	20 e0       	ldi	r18, 0x00	; 0
    1d4c:	39 2f       	mov	r19, r25
    1d4e:	3f 0d       	add	r19, r15
    1d50:	91 e0       	ldi	r25, 0x01	; 1
    1d52:	3f 15       	cp	r19, r15
    1d54:	08 f0       	brcs	.+2      	; 0x1d58 <__vector_14+0x1c8>
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	29 2b       	or	r18, r25
    1d5a:	91 e0       	ldi	r25, 0x01	; 1
    1d5c:	04 17       	cp	r16, r20
    1d5e:	08 f0       	brcs	.+2      	; 0x1d62 <__vector_14+0x1d2>
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	42 2f       	mov	r20, r18
    1d64:	40 0f       	add	r20, r16
    1d66:	21 e0       	ldi	r18, 0x01	; 1
    1d68:	40 17       	cp	r20, r16
    1d6a:	08 f0       	brcs	.+2      	; 0x1d6e <__vector_14+0x1de>
    1d6c:	20 e0       	ldi	r18, 0x00	; 0
    1d6e:	92 2b       	or	r25, r18
    1d70:	21 e0       	ldi	r18, 0x01	; 1
    1d72:	15 17       	cp	r17, r21
    1d74:	08 f0       	brcs	.+2      	; 0x1d78 <__vector_14+0x1e8>
    1d76:	20 e0       	ldi	r18, 0x00	; 0
    1d78:	59 2f       	mov	r21, r25
    1d7a:	51 0f       	add	r21, r17
    1d7c:	91 e0       	ldi	r25, 0x01	; 1
    1d7e:	51 17       	cp	r21, r17
    1d80:	08 f0       	brcs	.+2      	; 0x1d84 <__vector_14+0x1f4>
    1d82:	90 e0       	ldi	r25, 0x00	; 0
    1d84:	29 2b       	or	r18, r25
    1d86:	91 e0       	ldi	r25, 0x01	; 1
    1d88:	b6 17       	cp	r27, r22
    1d8a:	08 f0       	brcs	.+2      	; 0x1d8e <__vector_14+0x1fe>
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	62 2f       	mov	r22, r18
    1d90:	6b 0f       	add	r22, r27
    1d92:	21 e0       	ldi	r18, 0x01	; 1
    1d94:	6b 17       	cp	r22, r27
    1d96:	08 f0       	brcs	.+2      	; 0x1d9a <__vector_14+0x20a>
    1d98:	20 e0       	ldi	r18, 0x00	; 0
    1d9a:	92 2b       	or	r25, r18
    1d9c:	21 e0       	ldi	r18, 0x01	; 1
    1d9e:	a7 17       	cp	r26, r23
    1da0:	08 f0       	brcs	.+2      	; 0x1da4 <__vector_14+0x214>
    1da2:	20 e0       	ldi	r18, 0x00	; 0
    1da4:	79 2f       	mov	r23, r25
    1da6:	7a 0f       	add	r23, r26
    1da8:	91 e0       	ldi	r25, 0x01	; 1
    1daa:	7a 17       	cp	r23, r26
    1dac:	08 f0       	brcs	.+2      	; 0x1db0 <__vector_14+0x220>
    1dae:	90 e0       	ldi	r25, 0x00	; 0
    1db0:	29 2b       	or	r18, r25
    1db2:	91 e0       	ldi	r25, 0x01	; 1
    1db4:	f8 17       	cp	r31, r24
    1db6:	08 f0       	brcs	.+2      	; 0x1dba <__vector_14+0x22a>
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	82 2f       	mov	r24, r18
    1dbc:	8f 0f       	add	r24, r31
    1dbe:	21 e0       	ldi	r18, 0x01	; 1
    1dc0:	8f 17       	cp	r24, r31
    1dc2:	08 f0       	brcs	.+2      	; 0x1dc6 <__vector_14+0x236>
    1dc4:	20 e0       	ldi	r18, 0x00	; 0
    1dc6:	92 2b       	or	r25, r18
    1dc8:	2e 2d       	mov	r18, r14
    1dca:	9e 0f       	add	r25, r30
    1dcc:	02 e0       	ldi	r16, 0x02	; 2
    1dce:	0e 94 e0 2e 	call	0x5dc0	; 0x5dc0 <__ashrdi3>
    1dd2:	29 83       	std	Y+1, r18	; 0x01
    1dd4:	3a 83       	std	Y+2, r19	; 0x02
    1dd6:	4b 83       	std	Y+3, r20	; 0x03
    1dd8:	5c 83       	std	Y+4, r21	; 0x04
    1dda:	6d 83       	std	Y+5, r22	; 0x05
    1ddc:	7e 83       	std	Y+6, r23	; 0x06
    1dde:	8f 83       	std	Y+7, r24	; 0x07
    1de0:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1de2:	60 91 65 50 	lds	r22, 0x5065
    1de6:	70 91 66 50 	lds	r23, 0x5066
    1dea:	80 91 67 50 	lds	r24, 0x5067
    1dee:	90 91 68 50 	lds	r25, 0x5068
    1df2:	19 81       	ldd	r17, Y+1	; 0x01
    1df4:	0a 81       	ldd	r16, Y+2	; 0x02
    1df6:	fb 80       	ldd	r15, Y+3	; 0x03
    1df8:	ec 80       	ldd	r14, Y+4	; 0x04
    1dfa:	dd 80       	ldd	r13, Y+5	; 0x05
    1dfc:	ce 80       	ldd	r12, Y+6	; 0x06
    1dfe:	bf 80       	ldd	r11, Y+7	; 0x07
    1e00:	a8 84       	ldd	r10, Y+8	; 0x08
    1e02:	20 91 a7 50 	lds	r18, 0x50A7
    1e06:	30 91 a8 50 	lds	r19, 0x50A8
    1e0a:	40 e0       	ldi	r20, 0x00	; 0
    1e0c:	50 e0       	ldi	r21, 0x00	; 0
    1e0e:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    1e12:	dc 01       	movw	r26, r24
    1e14:	cb 01       	movw	r24, r22
    1e16:	88 0f       	add	r24, r24
    1e18:	99 1f       	adc	r25, r25
    1e1a:	88 0f       	add	r24, r24
    1e1c:	99 1f       	adc	r25, r25
    1e1e:	80 90 63 50 	lds	r8, 0x5063
    1e22:	90 90 64 50 	lds	r9, 0x5064
    1e26:	88 0e       	add	r8, r24
    1e28:	99 1e       	adc	r9, r25
    1e2a:	21 2f       	mov	r18, r17
    1e2c:	30 2f       	mov	r19, r16
    1e2e:	4f 2d       	mov	r20, r15
    1e30:	5e 2d       	mov	r21, r14
    1e32:	6d 2d       	mov	r22, r13
    1e34:	7c 2d       	mov	r23, r12
    1e36:	8b 2d       	mov	r24, r11
    1e38:	9a 2d       	mov	r25, r10
    1e3a:	0f 2e       	mov	r0, r31
    1e3c:	f0 ea       	ldi	r31, 0xA0	; 160
    1e3e:	af 2e       	mov	r10, r31
    1e40:	f0 2d       	mov	r31, r0
    1e42:	0f 2e       	mov	r0, r31
    1e44:	f5 e2       	ldi	r31, 0x25	; 37
    1e46:	bf 2e       	mov	r11, r31
    1e48:	f0 2d       	mov	r31, r0
    1e4a:	0f 2e       	mov	r0, r31
    1e4c:	f6 e2       	ldi	r31, 0x26	; 38
    1e4e:	cf 2e       	mov	r12, r31
    1e50:	f0 2d       	mov	r31, r0
    1e52:	dd 24       	eor	r13, r13
    1e54:	ee 24       	eor	r14, r14
    1e56:	ff 24       	eor	r15, r15
    1e58:	00 e0       	ldi	r16, 0x00	; 0
    1e5a:	10 e0       	ldi	r17, 0x00	; 0
    1e5c:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <__muldi3>
    1e60:	aa 24       	eor	r10, r10
    1e62:	aa 94       	dec	r10
    1e64:	bb 24       	eor	r11, r11
    1e66:	ba 94       	dec	r11
    1e68:	0f 2e       	mov	r0, r31
    1e6a:	ff e7       	ldi	r31, 0x7F	; 127
    1e6c:	cf 2e       	mov	r12, r31
    1e6e:	f0 2d       	mov	r31, r0
    1e70:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <__divdi3>
    1e74:	01 e0       	ldi	r16, 0x01	; 1
    1e76:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <__ashldi3>
    1e7a:	0f 2e       	mov	r0, r31
    1e7c:	f3 e0       	ldi	r31, 0x03	; 3
    1e7e:	af 2e       	mov	r10, r31
    1e80:	f0 2d       	mov	r31, r0
    1e82:	bb 24       	eor	r11, r11
    1e84:	cc 24       	eor	r12, r12
    1e86:	00 e0       	ldi	r16, 0x00	; 0
    1e88:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <__divdi3>
    1e8c:	f4 01       	movw	r30, r8
    1e8e:	20 83       	st	Z, r18
    1e90:	31 83       	std	Z+1, r19	; 0x01
    1e92:	42 83       	std	Z+2, r20	; 0x02
    1e94:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    1e96:	80 91 48 40 	lds	r24, 0x4048
    1e9a:	88 23       	and	r24, r24
    1e9c:	09 f1       	breq	.+66     	; 0x1ee0 <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1e9e:	60 91 65 50 	lds	r22, 0x5065
    1ea2:	70 91 66 50 	lds	r23, 0x5066
    1ea6:	80 91 67 50 	lds	r24, 0x5067
    1eaa:	90 91 68 50 	lds	r25, 0x5068
    1eae:	20 91 a7 50 	lds	r18, 0x50A7
    1eb2:	30 91 a8 50 	lds	r19, 0x50A8
    1eb6:	40 e0       	ldi	r20, 0x00	; 0
    1eb8:	50 e0       	ldi	r21, 0x00	; 0
    1eba:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    1ebe:	dc 01       	movw	r26, r24
    1ec0:	cb 01       	movw	r24, r22
    1ec2:	9c 01       	movw	r18, r24
    1ec4:	22 0f       	add	r18, r18
    1ec6:	33 1f       	adc	r19, r19
    1ec8:	22 0f       	add	r18, r18
    1eca:	33 1f       	adc	r19, r19
    1ecc:	80 91 63 50 	lds	r24, 0x5063
    1ed0:	90 91 64 50 	lds	r25, 0x5064
    1ed4:	82 0f       	add	r24, r18
    1ed6:	93 1f       	adc	r25, r19
    1ed8:	64 e0       	ldi	r22, 0x04	; 4
    1eda:	70 e0       	ldi	r23, 0x00	; 0
    1edc:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    1ee0:	80 91 65 50 	lds	r24, 0x5065
    1ee4:	90 91 66 50 	lds	r25, 0x5066
    1ee8:	a0 91 67 50 	lds	r26, 0x5067
    1eec:	b0 91 68 50 	lds	r27, 0x5068
    1ef0:	01 96       	adiw	r24, 0x01	; 1
    1ef2:	a1 1d       	adc	r26, r1
    1ef4:	b1 1d       	adc	r27, r1
    1ef6:	80 93 65 50 	sts	0x5065, r24
    1efa:	90 93 66 50 	sts	0x5066, r25
    1efe:	a0 93 67 50 	sts	0x5067, r26
    1f02:	b0 93 68 50 	sts	0x5068, r27

}
    1f06:	2c 96       	adiw	r28, 0x0c	; 12
    1f08:	cd bf       	out	0x3d, r28	; 61
    1f0a:	de bf       	out	0x3e, r29	; 62
    1f0c:	df 91       	pop	r29
    1f0e:	cf 91       	pop	r28
    1f10:	ff 91       	pop	r31
    1f12:	ef 91       	pop	r30
    1f14:	bf 91       	pop	r27
    1f16:	af 91       	pop	r26
    1f18:	9f 91       	pop	r25
    1f1a:	8f 91       	pop	r24
    1f1c:	7f 91       	pop	r23
    1f1e:	6f 91       	pop	r22
    1f20:	5f 91       	pop	r21
    1f22:	4f 91       	pop	r20
    1f24:	3f 91       	pop	r19
    1f26:	2f 91       	pop	r18
    1f28:	1f 91       	pop	r17
    1f2a:	0f 91       	pop	r16
    1f2c:	ff 90       	pop	r15
    1f2e:	ef 90       	pop	r14
    1f30:	df 90       	pop	r13
    1f32:	cf 90       	pop	r12
    1f34:	bf 90       	pop	r11
    1f36:	af 90       	pop	r10
    1f38:	9f 90       	pop	r9
    1f3a:	8f 90       	pop	r8
    1f3c:	7f 90       	pop	r7
    1f3e:	6f 90       	pop	r6
    1f40:	0f 90       	pop	r0
    1f42:	0b be       	out	0x3b, r0	; 59
    1f44:	0f 90       	pop	r0
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	0f 90       	pop	r0
    1f4a:	1f 90       	pop	r1
    1f4c:	18 95       	reti

00001f4e <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1f4e:	1f 92       	push	r1
    1f50:	0f 92       	push	r0
    1f52:	0f b6       	in	r0, 0x3f	; 63
    1f54:	0f 92       	push	r0
    1f56:	0b b6       	in	r0, 0x3b	; 59
    1f58:	0f 92       	push	r0
    1f5a:	11 24       	eor	r1, r1
    1f5c:	6f 92       	push	r6
    1f5e:	7f 92       	push	r7
    1f60:	8f 92       	push	r8
    1f62:	9f 92       	push	r9
    1f64:	af 92       	push	r10
    1f66:	bf 92       	push	r11
    1f68:	cf 92       	push	r12
    1f6a:	df 92       	push	r13
    1f6c:	ef 92       	push	r14
    1f6e:	ff 92       	push	r15
    1f70:	0f 93       	push	r16
    1f72:	1f 93       	push	r17
    1f74:	2f 93       	push	r18
    1f76:	3f 93       	push	r19
    1f78:	4f 93       	push	r20
    1f7a:	5f 93       	push	r21
    1f7c:	6f 93       	push	r22
    1f7e:	7f 93       	push	r23
    1f80:	8f 93       	push	r24
    1f82:	9f 93       	push	r25
    1f84:	af 93       	push	r26
    1f86:	bf 93       	push	r27
    1f88:	ef 93       	push	r30
    1f8a:	ff 93       	push	r31
    1f8c:	cf 93       	push	r28
    1f8e:	df 93       	push	r29
    1f90:	cd b7       	in	r28, 0x3d	; 61
    1f92:	de b7       	in	r29, 0x3e	; 62
    1f94:	2c 97       	sbiw	r28, 0x0c	; 12
    1f96:	cd bf       	out	0x3d, r28	; 61
    1f98:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    1f9a:	19 82       	std	Y+1, r1	; 0x01
    1f9c:	1a 82       	std	Y+2, r1	; 0x02
    1f9e:	1b 82       	std	Y+3, r1	; 0x03
    1fa0:	1c 82       	std	Y+4, r1	; 0x04
    1fa2:	1d 82       	std	Y+5, r1	; 0x05
    1fa4:	1e 82       	std	Y+6, r1	; 0x06
    1fa6:	1f 82       	std	Y+7, r1	; 0x07
    1fa8:	18 86       	std	Y+8, r1	; 0x08
    1faa:	80 e0       	ldi	r24, 0x00	; 0
    1fac:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1fae:	20 e2       	ldi	r18, 0x20	; 32
    1fb0:	3e e3       	ldi	r19, 0x3E	; 62
    1fb2:	88 24       	eor	r8, r8
    1fb4:	8a 94       	dec	r8
    1fb6:	ac 01       	movw	r20, r24
    1fb8:	f9 01       	movw	r30, r18
    1fba:	e8 0f       	add	r30, r24
    1fbc:	f9 1f       	adc	r31, r25
    1fbe:	60 81       	ld	r22, Z
    1fc0:	66 23       	and	r22, r22
    1fc2:	14 f4       	brge	.+4      	; 0x1fc8 <__vector_77+0x7a>
    1fc4:	8c 86       	std	Y+12, r8	; 0x0c
    1fc6:	01 c0       	rjmp	.+2      	; 0x1fca <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1fc8:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1fca:	42 0f       	add	r20, r18
    1fcc:	53 1f       	adc	r21, r19
    1fce:	fa 01       	movw	r30, r20
    1fd0:	40 81       	ld	r20, Z
    1fd2:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1fd8:	e2 0f       	add	r30, r18
    1fda:	f3 1f       	adc	r31, r19
    1fdc:	40 81       	ld	r20, Z
    1fde:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1fe0:	fc 01       	movw	r30, r24
    1fe2:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1fe4:	e2 0f       	add	r30, r18
    1fe6:	f3 1f       	adc	r31, r19
    1fe8:	40 81       	ld	r20, Z
    1fea:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1fec:	49 85       	ldd	r20, Y+9	; 0x09
    1fee:	5a 85       	ldd	r21, Y+10	; 0x0a
    1ff0:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ff2:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ff4:	a9 80       	ldd	r10, Y+1	; 0x01
    1ff6:	ba 80       	ldd	r11, Y+2	; 0x02
    1ff8:	cb 80       	ldd	r12, Y+3	; 0x03
    1ffa:	dc 80       	ldd	r13, Y+4	; 0x04
    1ffc:	ed 80       	ldd	r14, Y+5	; 0x05
    1ffe:	fe 80       	ldd	r15, Y+6	; 0x06
    2000:	0f 81       	ldd	r16, Y+7	; 0x07
    2002:	18 85       	ldd	r17, Y+8	; 0x08
    2004:	b4 2f       	mov	r27, r20
    2006:	a5 2f       	mov	r26, r21
    2008:	f6 2f       	mov	r31, r22
    200a:	e7 2f       	mov	r30, r23
    200c:	77 0f       	add	r23, r23
    200e:	44 0b       	sbc	r20, r20
    2010:	54 2f       	mov	r21, r20
    2012:	ba 01       	movw	r22, r20
    2014:	64 2e       	mov	r6, r20
    2016:	74 2e       	mov	r7, r20
    2018:	94 2e       	mov	r9, r20
    201a:	ab 0e       	add	r10, r27
    201c:	61 e0       	ldi	r22, 0x01	; 1
    201e:	ab 16       	cp	r10, r27
    2020:	08 f0       	brcs	.+2      	; 0x2024 <__vector_77+0xd6>
    2022:	60 e0       	ldi	r22, 0x00	; 0
    2024:	ba 0e       	add	r11, r26
    2026:	51 e0       	ldi	r21, 0x01	; 1
    2028:	ba 16       	cp	r11, r26
    202a:	08 f0       	brcs	.+2      	; 0x202e <__vector_77+0xe0>
    202c:	50 e0       	ldi	r21, 0x00	; 0
    202e:	a6 2f       	mov	r26, r22
    2030:	ab 0d       	add	r26, r11
    2032:	61 e0       	ldi	r22, 0x01	; 1
    2034:	ab 15       	cp	r26, r11
    2036:	08 f0       	brcs	.+2      	; 0x203a <__vector_77+0xec>
    2038:	60 e0       	ldi	r22, 0x00	; 0
    203a:	56 2b       	or	r21, r22
    203c:	cf 0e       	add	r12, r31
    203e:	61 e0       	ldi	r22, 0x01	; 1
    2040:	cf 16       	cp	r12, r31
    2042:	08 f0       	brcs	.+2      	; 0x2046 <__vector_77+0xf8>
    2044:	60 e0       	ldi	r22, 0x00	; 0
    2046:	f5 2f       	mov	r31, r21
    2048:	fc 0d       	add	r31, r12
    204a:	51 e0       	ldi	r21, 0x01	; 1
    204c:	fc 15       	cp	r31, r12
    204e:	08 f0       	brcs	.+2      	; 0x2052 <__vector_77+0x104>
    2050:	50 e0       	ldi	r21, 0x00	; 0
    2052:	65 2b       	or	r22, r21
    2054:	de 0e       	add	r13, r30
    2056:	51 e0       	ldi	r21, 0x01	; 1
    2058:	de 16       	cp	r13, r30
    205a:	08 f0       	brcs	.+2      	; 0x205e <__vector_77+0x110>
    205c:	50 e0       	ldi	r21, 0x00	; 0
    205e:	e6 2f       	mov	r30, r22
    2060:	ed 0d       	add	r30, r13
    2062:	61 e0       	ldi	r22, 0x01	; 1
    2064:	ed 15       	cp	r30, r13
    2066:	08 f0       	brcs	.+2      	; 0x206a <__vector_77+0x11c>
    2068:	60 e0       	ldi	r22, 0x00	; 0
    206a:	56 2b       	or	r21, r22
    206c:	e6 0c       	add	r14, r6
    206e:	71 e0       	ldi	r23, 0x01	; 1
    2070:	e6 14       	cp	r14, r6
    2072:	08 f0       	brcs	.+2      	; 0x2076 <__vector_77+0x128>
    2074:	70 e0       	ldi	r23, 0x00	; 0
    2076:	b5 2f       	mov	r27, r21
    2078:	be 0d       	add	r27, r14
    207a:	51 e0       	ldi	r21, 0x01	; 1
    207c:	be 15       	cp	r27, r14
    207e:	08 f0       	brcs	.+2      	; 0x2082 <__vector_77+0x134>
    2080:	50 e0       	ldi	r21, 0x00	; 0
    2082:	75 2b       	or	r23, r21
    2084:	f7 0c       	add	r15, r7
    2086:	61 e0       	ldi	r22, 0x01	; 1
    2088:	f7 14       	cp	r15, r7
    208a:	08 f0       	brcs	.+2      	; 0x208e <__vector_77+0x140>
    208c:	60 e0       	ldi	r22, 0x00	; 0
    208e:	7f 0d       	add	r23, r15
    2090:	51 e0       	ldi	r21, 0x01	; 1
    2092:	7f 15       	cp	r23, r15
    2094:	08 f0       	brcs	.+2      	; 0x2098 <__vector_77+0x14a>
    2096:	50 e0       	ldi	r21, 0x00	; 0
    2098:	65 2b       	or	r22, r21
    209a:	09 0d       	add	r16, r9
    209c:	51 e0       	ldi	r21, 0x01	; 1
    209e:	09 15       	cp	r16, r9
    20a0:	08 f0       	brcs	.+2      	; 0x20a4 <__vector_77+0x156>
    20a2:	50 e0       	ldi	r21, 0x00	; 0
    20a4:	60 0f       	add	r22, r16
    20a6:	ff 24       	eor	r15, r15
    20a8:	f3 94       	inc	r15
    20aa:	60 17       	cp	r22, r16
    20ac:	08 f0       	brcs	.+2      	; 0x20b0 <__vector_77+0x162>
    20ae:	ff 24       	eor	r15, r15
    20b0:	5f 29       	or	r21, r15
    20b2:	41 0f       	add	r20, r17
    20b4:	54 0f       	add	r21, r20
    20b6:	a9 82       	std	Y+1, r10	; 0x01
    20b8:	aa 83       	std	Y+2, r26	; 0x02
    20ba:	fb 83       	std	Y+3, r31	; 0x03
    20bc:	ec 83       	std	Y+4, r30	; 0x04
    20be:	bd 83       	std	Y+5, r27	; 0x05
    20c0:	7e 83       	std	Y+6, r23	; 0x06
    20c2:	6f 83       	std	Y+7, r22	; 0x07
    20c4:	58 87       	std	Y+8, r21	; 0x08
    20c6:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    20c8:	8c 30       	cpi	r24, 0x0C	; 12
    20ca:	91 05       	cpc	r25, r1
    20cc:	09 f0       	breq	.+2      	; 0x20d0 <__vector_77+0x182>
    20ce:	73 cf       	rjmp	.-282    	; 0x1fb6 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    20d0:	e9 80       	ldd	r14, Y+1	; 0x01
    20d2:	fa 80       	ldd	r15, Y+2	; 0x02
    20d4:	0b 81       	ldd	r16, Y+3	; 0x03
    20d6:	1c 81       	ldd	r17, Y+4	; 0x04
    20d8:	bd 81       	ldd	r27, Y+5	; 0x05
    20da:	ae 81       	ldd	r26, Y+6	; 0x06
    20dc:	ff 81       	ldd	r31, Y+7	; 0x07
    20de:	e8 85       	ldd	r30, Y+8	; 0x08
    20e0:	2e 2d       	mov	r18, r14
    20e2:	3f 2d       	mov	r19, r15
    20e4:	40 2f       	mov	r20, r16
    20e6:	51 2f       	mov	r21, r17
    20e8:	6b 2f       	mov	r22, r27
    20ea:	7a 2f       	mov	r23, r26
    20ec:	8f 2f       	mov	r24, r31
    20ee:	9e 2f       	mov	r25, r30
    20f0:	ee 23       	and	r30, r30
    20f2:	0c f0       	brlt	.+2      	; 0x20f6 <__vector_77+0x1a8>
    20f4:	4a c0       	rjmp	.+148    	; 0x218a <__vector_77+0x23c>
    20f6:	93 e0       	ldi	r25, 0x03	; 3
    20f8:	e9 0e       	add	r14, r25
    20fa:	91 e0       	ldi	r25, 0x01	; 1
    20fc:	e2 16       	cp	r14, r18
    20fe:	08 f0       	brcs	.+2      	; 0x2102 <__vector_77+0x1b4>
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	21 e0       	ldi	r18, 0x01	; 1
    2104:	f3 16       	cp	r15, r19
    2106:	08 f0       	brcs	.+2      	; 0x210a <__vector_77+0x1bc>
    2108:	20 e0       	ldi	r18, 0x00	; 0
    210a:	39 2f       	mov	r19, r25
    210c:	3f 0d       	add	r19, r15
    210e:	91 e0       	ldi	r25, 0x01	; 1
    2110:	3f 15       	cp	r19, r15
    2112:	08 f0       	brcs	.+2      	; 0x2116 <__vector_77+0x1c8>
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	29 2b       	or	r18, r25
    2118:	91 e0       	ldi	r25, 0x01	; 1
    211a:	04 17       	cp	r16, r20
    211c:	08 f0       	brcs	.+2      	; 0x2120 <__vector_77+0x1d2>
    211e:	90 e0       	ldi	r25, 0x00	; 0
    2120:	42 2f       	mov	r20, r18
    2122:	40 0f       	add	r20, r16
    2124:	21 e0       	ldi	r18, 0x01	; 1
    2126:	40 17       	cp	r20, r16
    2128:	08 f0       	brcs	.+2      	; 0x212c <__vector_77+0x1de>
    212a:	20 e0       	ldi	r18, 0x00	; 0
    212c:	92 2b       	or	r25, r18
    212e:	21 e0       	ldi	r18, 0x01	; 1
    2130:	15 17       	cp	r17, r21
    2132:	08 f0       	brcs	.+2      	; 0x2136 <__vector_77+0x1e8>
    2134:	20 e0       	ldi	r18, 0x00	; 0
    2136:	59 2f       	mov	r21, r25
    2138:	51 0f       	add	r21, r17
    213a:	91 e0       	ldi	r25, 0x01	; 1
    213c:	51 17       	cp	r21, r17
    213e:	08 f0       	brcs	.+2      	; 0x2142 <__vector_77+0x1f4>
    2140:	90 e0       	ldi	r25, 0x00	; 0
    2142:	29 2b       	or	r18, r25
    2144:	91 e0       	ldi	r25, 0x01	; 1
    2146:	b6 17       	cp	r27, r22
    2148:	08 f0       	brcs	.+2      	; 0x214c <__vector_77+0x1fe>
    214a:	90 e0       	ldi	r25, 0x00	; 0
    214c:	62 2f       	mov	r22, r18
    214e:	6b 0f       	add	r22, r27
    2150:	21 e0       	ldi	r18, 0x01	; 1
    2152:	6b 17       	cp	r22, r27
    2154:	08 f0       	brcs	.+2      	; 0x2158 <__vector_77+0x20a>
    2156:	20 e0       	ldi	r18, 0x00	; 0
    2158:	92 2b       	or	r25, r18
    215a:	21 e0       	ldi	r18, 0x01	; 1
    215c:	a7 17       	cp	r26, r23
    215e:	08 f0       	brcs	.+2      	; 0x2162 <__vector_77+0x214>
    2160:	20 e0       	ldi	r18, 0x00	; 0
    2162:	79 2f       	mov	r23, r25
    2164:	7a 0f       	add	r23, r26
    2166:	91 e0       	ldi	r25, 0x01	; 1
    2168:	7a 17       	cp	r23, r26
    216a:	08 f0       	brcs	.+2      	; 0x216e <__vector_77+0x220>
    216c:	90 e0       	ldi	r25, 0x00	; 0
    216e:	29 2b       	or	r18, r25
    2170:	91 e0       	ldi	r25, 0x01	; 1
    2172:	f8 17       	cp	r31, r24
    2174:	08 f0       	brcs	.+2      	; 0x2178 <__vector_77+0x22a>
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	82 2f       	mov	r24, r18
    217a:	8f 0f       	add	r24, r31
    217c:	21 e0       	ldi	r18, 0x01	; 1
    217e:	8f 17       	cp	r24, r31
    2180:	08 f0       	brcs	.+2      	; 0x2184 <__vector_77+0x236>
    2182:	20 e0       	ldi	r18, 0x00	; 0
    2184:	92 2b       	or	r25, r18
    2186:	2e 2d       	mov	r18, r14
    2188:	9e 0f       	add	r25, r30
    218a:	02 e0       	ldi	r16, 0x02	; 2
    218c:	0e 94 e0 2e 	call	0x5dc0	; 0x5dc0 <__ashrdi3>
    2190:	29 83       	std	Y+1, r18	; 0x01
    2192:	3a 83       	std	Y+2, r19	; 0x02
    2194:	4b 83       	std	Y+3, r20	; 0x03
    2196:	5c 83       	std	Y+4, r21	; 0x04
    2198:	6d 83       	std	Y+5, r22	; 0x05
    219a:	7e 83       	std	Y+6, r23	; 0x06
    219c:	8f 83       	std	Y+7, r24	; 0x07
    219e:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    21a0:	60 91 65 50 	lds	r22, 0x5065
    21a4:	70 91 66 50 	lds	r23, 0x5066
    21a8:	80 91 67 50 	lds	r24, 0x5067
    21ac:	90 91 68 50 	lds	r25, 0x5068
    21b0:	19 81       	ldd	r17, Y+1	; 0x01
    21b2:	0a 81       	ldd	r16, Y+2	; 0x02
    21b4:	fb 80       	ldd	r15, Y+3	; 0x03
    21b6:	ec 80       	ldd	r14, Y+4	; 0x04
    21b8:	dd 80       	ldd	r13, Y+5	; 0x05
    21ba:	ce 80       	ldd	r12, Y+6	; 0x06
    21bc:	bf 80       	ldd	r11, Y+7	; 0x07
    21be:	a8 84       	ldd	r10, Y+8	; 0x08
    21c0:	20 91 a7 50 	lds	r18, 0x50A7
    21c4:	30 91 a8 50 	lds	r19, 0x50A8
    21c8:	40 e0       	ldi	r20, 0x00	; 0
    21ca:	50 e0       	ldi	r21, 0x00	; 0
    21cc:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    21d0:	dc 01       	movw	r26, r24
    21d2:	cb 01       	movw	r24, r22
    21d4:	88 0f       	add	r24, r24
    21d6:	99 1f       	adc	r25, r25
    21d8:	88 0f       	add	r24, r24
    21da:	99 1f       	adc	r25, r25
    21dc:	80 90 63 50 	lds	r8, 0x5063
    21e0:	90 90 64 50 	lds	r9, 0x5064
    21e4:	88 0e       	add	r8, r24
    21e6:	99 1e       	adc	r9, r25
    21e8:	21 2f       	mov	r18, r17
    21ea:	30 2f       	mov	r19, r16
    21ec:	4f 2d       	mov	r20, r15
    21ee:	5e 2d       	mov	r21, r14
    21f0:	6d 2d       	mov	r22, r13
    21f2:	7c 2d       	mov	r23, r12
    21f4:	8b 2d       	mov	r24, r11
    21f6:	9a 2d       	mov	r25, r10
    21f8:	0f 2e       	mov	r0, r31
    21fa:	f0 ea       	ldi	r31, 0xA0	; 160
    21fc:	af 2e       	mov	r10, r31
    21fe:	f0 2d       	mov	r31, r0
    2200:	0f 2e       	mov	r0, r31
    2202:	f5 e2       	ldi	r31, 0x25	; 37
    2204:	bf 2e       	mov	r11, r31
    2206:	f0 2d       	mov	r31, r0
    2208:	0f 2e       	mov	r0, r31
    220a:	f6 e2       	ldi	r31, 0x26	; 38
    220c:	cf 2e       	mov	r12, r31
    220e:	f0 2d       	mov	r31, r0
    2210:	dd 24       	eor	r13, r13
    2212:	ee 24       	eor	r14, r14
    2214:	ff 24       	eor	r15, r15
    2216:	00 e0       	ldi	r16, 0x00	; 0
    2218:	10 e0       	ldi	r17, 0x00	; 0
    221a:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <__muldi3>
    221e:	aa 24       	eor	r10, r10
    2220:	aa 94       	dec	r10
    2222:	bb 24       	eor	r11, r11
    2224:	ba 94       	dec	r11
    2226:	0f 2e       	mov	r0, r31
    2228:	ff e7       	ldi	r31, 0x7F	; 127
    222a:	cf 2e       	mov	r12, r31
    222c:	f0 2d       	mov	r31, r0
    222e:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <__divdi3>
    2232:	01 e0       	ldi	r16, 0x01	; 1
    2234:	0e 94 6c 2e 	call	0x5cd8	; 0x5cd8 <__ashldi3>
    2238:	0f 2e       	mov	r0, r31
    223a:	f3 e0       	ldi	r31, 0x03	; 3
    223c:	af 2e       	mov	r10, r31
    223e:	f0 2d       	mov	r31, r0
    2240:	bb 24       	eor	r11, r11
    2242:	cc 24       	eor	r12, r12
    2244:	00 e0       	ldi	r16, 0x00	; 0
    2246:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <__divdi3>
    224a:	f4 01       	movw	r30, r8
    224c:	20 83       	st	Z, r18
    224e:	31 83       	std	Z+1, r19	; 0x01
    2250:	42 83       	std	Z+2, r20	; 0x02
    2252:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    2254:	80 91 48 40 	lds	r24, 0x4048
    2258:	88 23       	and	r24, r24
    225a:	09 f1       	breq	.+66     	; 0x229e <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    225c:	60 91 65 50 	lds	r22, 0x5065
    2260:	70 91 66 50 	lds	r23, 0x5066
    2264:	80 91 67 50 	lds	r24, 0x5067
    2268:	90 91 68 50 	lds	r25, 0x5068
    226c:	20 91 a7 50 	lds	r18, 0x50A7
    2270:	30 91 a8 50 	lds	r19, 0x50A8
    2274:	40 e0       	ldi	r20, 0x00	; 0
    2276:	50 e0       	ldi	r21, 0x00	; 0
    2278:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    227c:	dc 01       	movw	r26, r24
    227e:	cb 01       	movw	r24, r22
    2280:	9c 01       	movw	r18, r24
    2282:	22 0f       	add	r18, r18
    2284:	33 1f       	adc	r19, r19
    2286:	22 0f       	add	r18, r18
    2288:	33 1f       	adc	r19, r19
    228a:	80 91 63 50 	lds	r24, 0x5063
    228e:	90 91 64 50 	lds	r25, 0x5064
    2292:	82 0f       	add	r24, r18
    2294:	93 1f       	adc	r25, r19
    2296:	64 e0       	ldi	r22, 0x04	; 4
    2298:	70 e0       	ldi	r23, 0x00	; 0
    229a:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    229e:	80 91 65 50 	lds	r24, 0x5065
    22a2:	90 91 66 50 	lds	r25, 0x5066
    22a6:	a0 91 67 50 	lds	r26, 0x5067
    22aa:	b0 91 68 50 	lds	r27, 0x5068
    22ae:	01 96       	adiw	r24, 0x01	; 1
    22b0:	a1 1d       	adc	r26, r1
    22b2:	b1 1d       	adc	r27, r1
    22b4:	80 93 65 50 	sts	0x5065, r24
    22b8:	90 93 66 50 	sts	0x5066, r25
    22bc:	a0 93 67 50 	sts	0x5067, r26
    22c0:	b0 93 68 50 	sts	0x5068, r27
}
    22c4:	2c 96       	adiw	r28, 0x0c	; 12
    22c6:	cd bf       	out	0x3d, r28	; 61
    22c8:	de bf       	out	0x3e, r29	; 62
    22ca:	df 91       	pop	r29
    22cc:	cf 91       	pop	r28
    22ce:	ff 91       	pop	r31
    22d0:	ef 91       	pop	r30
    22d2:	bf 91       	pop	r27
    22d4:	af 91       	pop	r26
    22d6:	9f 91       	pop	r25
    22d8:	8f 91       	pop	r24
    22da:	7f 91       	pop	r23
    22dc:	6f 91       	pop	r22
    22de:	5f 91       	pop	r21
    22e0:	4f 91       	pop	r20
    22e2:	3f 91       	pop	r19
    22e4:	2f 91       	pop	r18
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	ff 90       	pop	r15
    22ec:	ef 90       	pop	r14
    22ee:	df 90       	pop	r13
    22f0:	cf 90       	pop	r12
    22f2:	bf 90       	pop	r11
    22f4:	af 90       	pop	r10
    22f6:	9f 90       	pop	r9
    22f8:	8f 90       	pop	r8
    22fa:	7f 90       	pop	r7
    22fc:	6f 90       	pop	r6
    22fe:	0f 90       	pop	r0
    2300:	0b be       	out	0x3b, r0	; 59
    2302:	0f 90       	pop	r0
    2304:	0f be       	out	0x3f, r0	; 63
    2306:	0f 90       	pop	r0
    2308:	1f 90       	pop	r1
    230a:	18 95       	reti

0000230c <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    230c:	82 e0       	ldi	r24, 0x02	; 2
    230e:	e0 ea       	ldi	r30, 0xA0	; 160
    2310:	f6 e0       	ldi	r31, 0x06	; 6
    2312:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2314:	8a ea       	ldi	r24, 0xAA	; 170
    2316:	e0 ec       	ldi	r30, 0xC0	; 192
    2318:	f8 e0       	ldi	r31, 0x08	; 8
    231a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    231c:	82 81       	ldd	r24, Z+2	; 0x02
    231e:	88 23       	and	r24, r24
    2320:	ec f7       	brge	.-6      	; 0x231c <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    2322:	90 91 a0 50 	lds	r25, 0x50A0
    2326:	e0 ec       	ldi	r30, 0xC0	; 192
    2328:	f8 e0       	ldi	r31, 0x08	; 8
    232a:	83 81       	ldd	r24, Z+3	; 0x03
    232c:	a0 e2       	ldi	r26, 0x20	; 32
    232e:	be e3       	ldi	r27, 0x3E	; 62
    2330:	a9 0f       	add	r26, r25
    2332:	b1 1d       	adc	r27, r1
    2334:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2336:	8a ea       	ldi	r24, 0xAA	; 170
    2338:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    233a:	82 81       	ldd	r24, Z+2	; 0x02
    233c:	88 23       	and	r24, r24
    233e:	ec f7       	brge	.-6      	; 0x233a <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2340:	a0 91 a0 50 	lds	r26, 0x50A0
    2344:	b0 e0       	ldi	r27, 0x00	; 0
    2346:	e0 ec       	ldi	r30, 0xC0	; 192
    2348:	f8 e0       	ldi	r31, 0x08	; 8
    234a:	83 81       	ldd	r24, Z+3	; 0x03
    234c:	af 5d       	subi	r26, 0xDF	; 223
    234e:	b1 4c       	sbci	r27, 0xC1	; 193
    2350:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2352:	8a ea       	ldi	r24, 0xAA	; 170
    2354:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2356:	82 81       	ldd	r24, Z+2	; 0x02
    2358:	88 23       	and	r24, r24
    235a:	ec f7       	brge	.-6      	; 0x2356 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    235c:	e0 91 a0 50 	lds	r30, 0x50A0
    2360:	f0 e0       	ldi	r31, 0x00	; 0
    2362:	a0 ec       	ldi	r26, 0xC0	; 192
    2364:	b8 e0       	ldi	r27, 0x08	; 8
    2366:	13 96       	adiw	r26, 0x03	; 3
    2368:	8c 91       	ld	r24, X
    236a:	13 97       	sbiw	r26, 0x03	; 3
    236c:	ee 5d       	subi	r30, 0xDE	; 222
    236e:	f1 4c       	sbci	r31, 0xC1	; 193
    2370:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2372:	82 e0       	ldi	r24, 0x02	; 2
    2374:	e0 ea       	ldi	r30, 0xA0	; 160
    2376:	f6 e0       	ldi	r31, 0x06	; 6
    2378:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    237a:	80 91 a0 50 	lds	r24, 0x50A0
    237e:	8d 5f       	subi	r24, 0xFD	; 253
    2380:	80 93 a0 50 	sts	0x50A0, r24
}
    2384:	08 95       	ret

00002386 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    2386:	1f 92       	push	r1
    2388:	0f 92       	push	r0
    238a:	0f b6       	in	r0, 0x3f	; 63
    238c:	0f 92       	push	r0
    238e:	0b b6       	in	r0, 0x3b	; 59
    2390:	0f 92       	push	r0
    2392:	11 24       	eor	r1, r1
    2394:	2f 93       	push	r18
    2396:	3f 93       	push	r19
    2398:	4f 93       	push	r20
    239a:	5f 93       	push	r21
    239c:	6f 93       	push	r22
    239e:	7f 93       	push	r23
    23a0:	8f 93       	push	r24
    23a2:	9f 93       	push	r25
    23a4:	af 93       	push	r26
    23a6:	bf 93       	push	r27
    23a8:	ef 93       	push	r30
    23aa:	ff 93       	push	r31
	sampleCurrentChannel();
    23ac:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
	SPICount = 0;
    23b0:	10 92 a0 50 	sts	0x50A0, r1
}
    23b4:	ff 91       	pop	r31
    23b6:	ef 91       	pop	r30
    23b8:	bf 91       	pop	r27
    23ba:	af 91       	pop	r26
    23bc:	9f 91       	pop	r25
    23be:	8f 91       	pop	r24
    23c0:	7f 91       	pop	r23
    23c2:	6f 91       	pop	r22
    23c4:	5f 91       	pop	r21
    23c6:	4f 91       	pop	r20
    23c8:	3f 91       	pop	r19
    23ca:	2f 91       	pop	r18
    23cc:	0f 90       	pop	r0
    23ce:	0b be       	out	0x3b, r0	; 59
    23d0:	0f 90       	pop	r0
    23d2:	0f be       	out	0x3f, r0	; 63
    23d4:	0f 90       	pop	r0
    23d6:	1f 90       	pop	r1
    23d8:	18 95       	reti

000023da <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    23da:	1f 92       	push	r1
    23dc:	0f 92       	push	r0
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	0f 92       	push	r0
    23e2:	0b b6       	in	r0, 0x3b	; 59
    23e4:	0f 92       	push	r0
    23e6:	11 24       	eor	r1, r1
    23e8:	2f 93       	push	r18
    23ea:	3f 93       	push	r19
    23ec:	4f 93       	push	r20
    23ee:	5f 93       	push	r21
    23f0:	6f 93       	push	r22
    23f2:	7f 93       	push	r23
    23f4:	8f 93       	push	r24
    23f6:	9f 93       	push	r25
    23f8:	af 93       	push	r26
    23fa:	bf 93       	push	r27
    23fc:	ef 93       	push	r30
    23fe:	ff 93       	push	r31
	sampleCurrentChannel();
    2400:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
}
    2404:	ff 91       	pop	r31
    2406:	ef 91       	pop	r30
    2408:	bf 91       	pop	r27
    240a:	af 91       	pop	r26
    240c:	9f 91       	pop	r25
    240e:	8f 91       	pop	r24
    2410:	7f 91       	pop	r23
    2412:	6f 91       	pop	r22
    2414:	5f 91       	pop	r21
    2416:	4f 91       	pop	r20
    2418:	3f 91       	pop	r19
    241a:	2f 91       	pop	r18
    241c:	0f 90       	pop	r0
    241e:	0b be       	out	0x3b, r0	; 59
    2420:	0f 90       	pop	r0
    2422:	0f be       	out	0x3f, r0	; 63
    2424:	0f 90       	pop	r0
    2426:	1f 90       	pop	r1
    2428:	18 95       	reti

0000242a <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    242a:	1f 92       	push	r1
    242c:	0f 92       	push	r0
    242e:	0f b6       	in	r0, 0x3f	; 63
    2430:	0f 92       	push	r0
    2432:	0b b6       	in	r0, 0x3b	; 59
    2434:	0f 92       	push	r0
    2436:	11 24       	eor	r1, r1
    2438:	2f 93       	push	r18
    243a:	3f 93       	push	r19
    243c:	4f 93       	push	r20
    243e:	5f 93       	push	r21
    2440:	6f 93       	push	r22
    2442:	7f 93       	push	r23
    2444:	8f 93       	push	r24
    2446:	9f 93       	push	r25
    2448:	af 93       	push	r26
    244a:	bf 93       	push	r27
    244c:	ef 93       	push	r30
    244e:	ff 93       	push	r31
	sampleCurrentChannel();
    2450:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
}
    2454:	ff 91       	pop	r31
    2456:	ef 91       	pop	r30
    2458:	bf 91       	pop	r27
    245a:	af 91       	pop	r26
    245c:	9f 91       	pop	r25
    245e:	8f 91       	pop	r24
    2460:	7f 91       	pop	r23
    2462:	6f 91       	pop	r22
    2464:	5f 91       	pop	r21
    2466:	4f 91       	pop	r20
    2468:	3f 91       	pop	r19
    246a:	2f 91       	pop	r18
    246c:	0f 90       	pop	r0
    246e:	0b be       	out	0x3b, r0	; 59
    2470:	0f 90       	pop	r0
    2472:	0f be       	out	0x3f, r0	; 63
    2474:	0f 90       	pop	r0
    2476:	1f 90       	pop	r1
    2478:	18 95       	reti

0000247a <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    247a:	1f 92       	push	r1
    247c:	0f 92       	push	r0
    247e:	0f b6       	in	r0, 0x3f	; 63
    2480:	0f 92       	push	r0
    2482:	0b b6       	in	r0, 0x3b	; 59
    2484:	0f 92       	push	r0
    2486:	11 24       	eor	r1, r1
    2488:	2f 93       	push	r18
    248a:	3f 93       	push	r19
    248c:	4f 93       	push	r20
    248e:	5f 93       	push	r21
    2490:	6f 93       	push	r22
    2492:	7f 93       	push	r23
    2494:	8f 93       	push	r24
    2496:	9f 93       	push	r25
    2498:	af 93       	push	r26
    249a:	bf 93       	push	r27
    249c:	ef 93       	push	r30
    249e:	ff 93       	push	r31
	sampleCurrentChannel();
    24a0:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
}
    24a4:	ff 91       	pop	r31
    24a6:	ef 91       	pop	r30
    24a8:	bf 91       	pop	r27
    24aa:	af 91       	pop	r26
    24ac:	9f 91       	pop	r25
    24ae:	8f 91       	pop	r24
    24b0:	7f 91       	pop	r23
    24b2:	6f 91       	pop	r22
    24b4:	5f 91       	pop	r21
    24b6:	4f 91       	pop	r20
    24b8:	3f 91       	pop	r19
    24ba:	2f 91       	pop	r18
    24bc:	0f 90       	pop	r0
    24be:	0b be       	out	0x3b, r0	; 59
    24c0:	0f 90       	pop	r0
    24c2:	0f be       	out	0x3f, r0	; 63
    24c4:	0f 90       	pop	r0
    24c6:	1f 90       	pop	r1
    24c8:	18 95       	reti

000024ca <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    24ca:	1f 92       	push	r1
    24cc:	0f 92       	push	r0
    24ce:	0f b6       	in	r0, 0x3f	; 63
    24d0:	0f 92       	push	r0
    24d2:	0b b6       	in	r0, 0x3b	; 59
    24d4:	0f 92       	push	r0
    24d6:	11 24       	eor	r1, r1
    24d8:	2f 93       	push	r18
    24da:	3f 93       	push	r19
    24dc:	4f 93       	push	r20
    24de:	5f 93       	push	r21
    24e0:	6f 93       	push	r22
    24e2:	7f 93       	push	r23
    24e4:	8f 93       	push	r24
    24e6:	9f 93       	push	r25
    24e8:	af 93       	push	r26
    24ea:	bf 93       	push	r27
    24ec:	ef 93       	push	r30
    24ee:	ff 93       	push	r31
	sampleCurrentChannel();
    24f0:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
	SPICount = 0;
    24f4:	10 92 a0 50 	sts	0x50A0, r1
	if(PORTB.OUT & PIN1_bm) {
    24f8:	e0 e2       	ldi	r30, 0x20	; 32
    24fa:	f6 e0       	ldi	r31, 0x06	; 6
    24fc:	84 81       	ldd	r24, Z+4	; 0x04
    24fe:	81 ff       	sbrs	r24, 1
    2500:	0f c0       	rjmp	.+30     	; 0x2520 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2502:	e0 e0       	ldi	r30, 0x00	; 0
    2504:	f6 e0       	ldi	r31, 0x06	; 6
    2506:	84 81       	ldd	r24, Z+4	; 0x04
    2508:	86 ff       	sbrs	r24, 6
    250a:	05 c0       	rjmp	.+10     	; 0x2516 <__vector_19+0x4c>
    250c:	82 e0       	ldi	r24, 0x02	; 2
    250e:	e0 e2       	ldi	r30, 0x20	; 32
    2510:	f6 e0       	ldi	r31, 0x06	; 6
    2512:	87 83       	std	Z+7, r24	; 0x07
    2514:	0d c0       	rjmp	.+26     	; 0x2530 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    2516:	80 e4       	ldi	r24, 0x40	; 64
    2518:	e0 e0       	ldi	r30, 0x00	; 0
    251a:	f6 e0       	ldi	r31, 0x06	; 6
    251c:	87 83       	std	Z+7, r24	; 0x07
    251e:	08 c0       	rjmp	.+16     	; 0x2530 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2520:	80 e4       	ldi	r24, 0x40	; 64
    2522:	e0 e0       	ldi	r30, 0x00	; 0
    2524:	f6 e0       	ldi	r31, 0x06	; 6
    2526:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2528:	82 e0       	ldi	r24, 0x02	; 2
    252a:	e0 e2       	ldi	r30, 0x20	; 32
    252c:	f6 e0       	ldi	r31, 0x06	; 6
    252e:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    2530:	ff 91       	pop	r31
    2532:	ef 91       	pop	r30
    2534:	bf 91       	pop	r27
    2536:	af 91       	pop	r26
    2538:	9f 91       	pop	r25
    253a:	8f 91       	pop	r24
    253c:	7f 91       	pop	r23
    253e:	6f 91       	pop	r22
    2540:	5f 91       	pop	r21
    2542:	4f 91       	pop	r20
    2544:	3f 91       	pop	r19
    2546:	2f 91       	pop	r18
    2548:	0f 90       	pop	r0
    254a:	0b be       	out	0x3b, r0	; 59
    254c:	0f 90       	pop	r0
    254e:	0f be       	out	0x3f, r0	; 63
    2550:	0f 90       	pop	r0
    2552:	1f 90       	pop	r1
    2554:	18 95       	reti

00002556 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    2556:	1f 92       	push	r1
    2558:	0f 92       	push	r0
    255a:	0f b6       	in	r0, 0x3f	; 63
    255c:	0f 92       	push	r0
    255e:	0b b6       	in	r0, 0x3b	; 59
    2560:	0f 92       	push	r0
    2562:	11 24       	eor	r1, r1
    2564:	2f 93       	push	r18
    2566:	3f 93       	push	r19
    2568:	4f 93       	push	r20
    256a:	5f 93       	push	r21
    256c:	6f 93       	push	r22
    256e:	7f 93       	push	r23
    2570:	8f 93       	push	r24
    2572:	9f 93       	push	r25
    2574:	af 93       	push	r26
    2576:	bf 93       	push	r27
    2578:	ef 93       	push	r30
    257a:	ff 93       	push	r31
	sampleCurrentChannel();
    257c:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
}
    2580:	ff 91       	pop	r31
    2582:	ef 91       	pop	r30
    2584:	bf 91       	pop	r27
    2586:	af 91       	pop	r26
    2588:	9f 91       	pop	r25
    258a:	8f 91       	pop	r24
    258c:	7f 91       	pop	r23
    258e:	6f 91       	pop	r22
    2590:	5f 91       	pop	r21
    2592:	4f 91       	pop	r20
    2594:	3f 91       	pop	r19
    2596:	2f 91       	pop	r18
    2598:	0f 90       	pop	r0
    259a:	0b be       	out	0x3b, r0	; 59
    259c:	0f 90       	pop	r0
    259e:	0f be       	out	0x3f, r0	; 63
    25a0:	0f 90       	pop	r0
    25a2:	1f 90       	pop	r1
    25a4:	18 95       	reti

000025a6 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    25a6:	1f 92       	push	r1
    25a8:	0f 92       	push	r0
    25aa:	0f b6       	in	r0, 0x3f	; 63
    25ac:	0f 92       	push	r0
    25ae:	0b b6       	in	r0, 0x3b	; 59
    25b0:	0f 92       	push	r0
    25b2:	11 24       	eor	r1, r1
    25b4:	2f 93       	push	r18
    25b6:	3f 93       	push	r19
    25b8:	4f 93       	push	r20
    25ba:	5f 93       	push	r21
    25bc:	6f 93       	push	r22
    25be:	7f 93       	push	r23
    25c0:	8f 93       	push	r24
    25c2:	9f 93       	push	r25
    25c4:	af 93       	push	r26
    25c6:	bf 93       	push	r27
    25c8:	ef 93       	push	r30
    25ca:	ff 93       	push	r31
	sampleCurrentChannel();
    25cc:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
}
    25d0:	ff 91       	pop	r31
    25d2:	ef 91       	pop	r30
    25d4:	bf 91       	pop	r27
    25d6:	af 91       	pop	r26
    25d8:	9f 91       	pop	r25
    25da:	8f 91       	pop	r24
    25dc:	7f 91       	pop	r23
    25de:	6f 91       	pop	r22
    25e0:	5f 91       	pop	r21
    25e2:	4f 91       	pop	r20
    25e4:	3f 91       	pop	r19
    25e6:	2f 91       	pop	r18
    25e8:	0f 90       	pop	r0
    25ea:	0b be       	out	0x3b, r0	; 59
    25ec:	0f 90       	pop	r0
    25ee:	0f be       	out	0x3f, r0	; 63
    25f0:	0f 90       	pop	r0
    25f2:	1f 90       	pop	r1
    25f4:	18 95       	reti

000025f6 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    25f6:	1f 92       	push	r1
    25f8:	0f 92       	push	r0
    25fa:	0f b6       	in	r0, 0x3f	; 63
    25fc:	0f 92       	push	r0
    25fe:	0b b6       	in	r0, 0x3b	; 59
    2600:	0f 92       	push	r0
    2602:	11 24       	eor	r1, r1
    2604:	2f 93       	push	r18
    2606:	3f 93       	push	r19
    2608:	4f 93       	push	r20
    260a:	5f 93       	push	r21
    260c:	6f 93       	push	r22
    260e:	7f 93       	push	r23
    2610:	8f 93       	push	r24
    2612:	9f 93       	push	r25
    2614:	af 93       	push	r26
    2616:	bf 93       	push	r27
    2618:	ef 93       	push	r30
    261a:	ff 93       	push	r31
	sampleCurrentChannel();
    261c:	0e 94 86 11 	call	0x230c	; 0x230c <sampleCurrentChannel>
}
    2620:	ff 91       	pop	r31
    2622:	ef 91       	pop	r30
    2624:	bf 91       	pop	r27
    2626:	af 91       	pop	r26
    2628:	9f 91       	pop	r25
    262a:	8f 91       	pop	r24
    262c:	7f 91       	pop	r23
    262e:	6f 91       	pop	r22
    2630:	5f 91       	pop	r21
    2632:	4f 91       	pop	r20
    2634:	3f 91       	pop	r19
    2636:	2f 91       	pop	r18
    2638:	0f 90       	pop	r0
    263a:	0b be       	out	0x3b, r0	; 59
    263c:	0f 90       	pop	r0
    263e:	0f be       	out	0x3f, r0	; 63
    2640:	0f 90       	pop	r0
    2642:	1f 90       	pop	r1
    2644:	18 95       	reti

00002646 <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2646:	ff 92       	push	r15
    2648:	0f 93       	push	r16
    264a:	1f 93       	push	r17
    264c:	cf 93       	push	r28
    264e:	df 93       	push	r29
    2650:	cd b7       	in	r28, 0x3d	; 61
    2652:	de b7       	in	r29, 0x3e	; 62
    2654:	28 97       	sbiw	r28, 0x08	; 8
    2656:	cd bf       	out	0x3d, r28	; 61
    2658:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    265a:	19 82       	std	Y+1, r1	; 0x01
    265c:	1a 82       	std	Y+2, r1	; 0x02
    265e:	1b 82       	std	Y+3, r1	; 0x03
    2660:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2662:	80 91 65 50 	lds	r24, 0x5065
    2666:	90 91 66 50 	lds	r25, 0x5066
    266a:	a0 91 67 50 	lds	r26, 0x5067
    266e:	b0 91 68 50 	lds	r27, 0x5068
    2672:	01 96       	adiw	r24, 0x01	; 1
    2674:	a1 1d       	adc	r26, r1
    2676:	b1 1d       	adc	r27, r1
    2678:	80 93 65 50 	sts	0x5065, r24
    267c:	90 93 66 50 	sts	0x5066, r25
    2680:	a0 93 67 50 	sts	0x5067, r26
    2684:	b0 93 68 50 	sts	0x5068, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2688:	80 ed       	ldi	r24, 0xD0	; 208
    268a:	80 93 c0 08 	sts	0x08C0, r24
    268e:	20 e0       	ldi	r18, 0x00	; 0
    2690:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2692:	00 e2       	ldi	r16, 0x20	; 32
    2694:	1e e3       	ldi	r17, 0x3E	; 62
    2696:	ff 24       	eor	r15, r15
    2698:	fa 94       	dec	r15
    269a:	c9 01       	movw	r24, r18
    269c:	f8 01       	movw	r30, r16
    269e:	e2 0f       	add	r30, r18
    26a0:	f3 1f       	adc	r31, r19
    26a2:	40 81       	ld	r20, Z
    26a4:	44 23       	and	r20, r20
    26a6:	14 f4       	brge	.+4      	; 0x26ac <writeSE2FRAM+0x66>
    26a8:	f8 86       	std	Y+8, r15	; 0x08
    26aa:	01 c0       	rjmp	.+2      	; 0x26ae <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    26ac:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    26ae:	80 0f       	add	r24, r16
    26b0:	91 1f       	adc	r25, r17
    26b2:	fc 01       	movw	r30, r24
    26b4:	80 81       	ld	r24, Z
    26b6:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    26b8:	f9 01       	movw	r30, r18
    26ba:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    26bc:	e0 0f       	add	r30, r16
    26be:	f1 1f       	adc	r31, r17
    26c0:	80 81       	ld	r24, Z
    26c2:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    26c4:	f9 01       	movw	r30, r18
    26c6:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    26c8:	e0 0f       	add	r30, r16
    26ca:	f1 1f       	adc	r31, r17
    26cc:	80 81       	ld	r24, Z
    26ce:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    26d0:	49 81       	ldd	r20, Y+1	; 0x01
    26d2:	5a 81       	ldd	r21, Y+2	; 0x02
    26d4:	6b 81       	ldd	r22, Y+3	; 0x03
    26d6:	7c 81       	ldd	r23, Y+4	; 0x04
    26d8:	8d 81       	ldd	r24, Y+5	; 0x05
    26da:	9e 81       	ldd	r25, Y+6	; 0x06
    26dc:	af 81       	ldd	r26, Y+7	; 0x07
    26de:	b8 85       	ldd	r27, Y+8	; 0x08
    26e0:	84 0f       	add	r24, r20
    26e2:	95 1f       	adc	r25, r21
    26e4:	a6 1f       	adc	r26, r22
    26e6:	b7 1f       	adc	r27, r23
    26e8:	89 83       	std	Y+1, r24	; 0x01
    26ea:	9a 83       	std	Y+2, r25	; 0x02
    26ec:	ab 83       	std	Y+3, r26	; 0x03
    26ee:	bc 83       	std	Y+4, r27	; 0x04
    26f0:	2d 5f       	subi	r18, 0xFD	; 253
    26f2:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    26f4:	2c 30       	cpi	r18, 0x0C	; 12
    26f6:	31 05       	cpc	r19, r1
    26f8:	81 f6       	brne	.-96     	; 0x269a <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    26fa:	69 81       	ldd	r22, Y+1	; 0x01
    26fc:	7a 81       	ldd	r23, Y+2	; 0x02
    26fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2700:	9c 81       	ldd	r25, Y+4	; 0x04
    2702:	24 e0       	ldi	r18, 0x04	; 4
    2704:	30 e0       	ldi	r19, 0x00	; 0
    2706:	40 e0       	ldi	r20, 0x00	; 0
    2708:	50 e0       	ldi	r21, 0x00	; 0
    270a:	0e 94 07 39 	call	0x720e	; 0x720e <__divmodsi4>
    270e:	29 83       	std	Y+1, r18	; 0x01
    2710:	3a 83       	std	Y+2, r19	; 0x02
    2712:	4b 83       	std	Y+3, r20	; 0x03
    2714:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2716:	29 81       	ldd	r18, Y+1	; 0x01
    2718:	82 e2       	ldi	r24, 0x22	; 34
    271a:	9e e3       	ldi	r25, 0x3E	; 62
    271c:	20 93 22 3e 	sts	0x3E22, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2720:	2a 81       	ldd	r18, Y+2	; 0x02
    2722:	fc 01       	movw	r30, r24
    2724:	31 97       	sbiw	r30, 0x01	; 1
    2726:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2728:	2b 81       	ldd	r18, Y+3	; 0x03
    272a:	02 97       	sbiw	r24, 0x02	; 2
    272c:	fc 01       	movw	r30, r24
    272e:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2730:	80 e1       	ldi	r24, 0x10	; 16
    2732:	e0 e4       	ldi	r30, 0x40	; 64
    2734:	f6 e0       	ldi	r31, 0x06	; 6
    2736:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2738:	88 e0       	ldi	r24, 0x08	; 8
    273a:	e0 e2       	ldi	r30, 0x20	; 32
    273c:	f6 e0       	ldi	r31, 0x06	; 6
    273e:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2740:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2742:	86 e0       	ldi	r24, 0x06	; 6
    2744:	e0 ec       	ldi	r30, 0xC0	; 192
    2746:	f8 e0       	ldi	r31, 0x08	; 8
    2748:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    274a:	82 81       	ldd	r24, Z+2	; 0x02
    274c:	88 23       	and	r24, r24
    274e:	ec f7       	brge	.-6      	; 0x274a <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    2750:	e0 ec       	ldi	r30, 0xC0	; 192
    2752:	f8 e0       	ldi	r31, 0x08	; 8
    2754:	83 81       	ldd	r24, Z+3	; 0x03
    2756:	80 93 2c 3e 	sts	0x3E2C, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    275a:	a0 e2       	ldi	r26, 0x20	; 32
    275c:	b6 e0       	ldi	r27, 0x06	; 6
    275e:	88 e0       	ldi	r24, 0x08	; 8
    2760:	15 96       	adiw	r26, 0x05	; 5
    2762:	8c 93       	st	X, r24
    2764:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    2766:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2768:	16 96       	adiw	r26, 0x06	; 6
    276a:	8c 93       	st	X, r24
    276c:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    276e:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2770:	82 e0       	ldi	r24, 0x02	; 2
    2772:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2774:	82 81       	ldd	r24, Z+2	; 0x02
    2776:	88 23       	and	r24, r24
    2778:	ec f7       	brge	.-6      	; 0x2774 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    277a:	e0 ec       	ldi	r30, 0xC0	; 192
    277c:	f8 e0       	ldi	r31, 0x08	; 8
    277e:	83 81       	ldd	r24, Z+3	; 0x03
    2780:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2784:	80 91 1e 3e 	lds	r24, 0x3E1E
    2788:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    278a:	82 81       	ldd	r24, Z+2	; 0x02
    278c:	88 23       	and	r24, r24
    278e:	ec f7       	brge	.-6      	; 0x278a <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    2790:	e0 ec       	ldi	r30, 0xC0	; 192
    2792:	f8 e0       	ldi	r31, 0x08	; 8
    2794:	83 81       	ldd	r24, Z+3	; 0x03
    2796:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    279a:	80 91 1d 3e 	lds	r24, 0x3E1D
    279e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27a0:	82 81       	ldd	r24, Z+2	; 0x02
    27a2:	88 23       	and	r24, r24
    27a4:	ec f7       	brge	.-6      	; 0x27a0 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    27a6:	e0 ec       	ldi	r30, 0xC0	; 192
    27a8:	f8 e0       	ldi	r31, 0x08	; 8
    27aa:	83 81       	ldd	r24, Z+3	; 0x03
    27ac:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[0];
    27b0:	80 91 20 3e 	lds	r24, 0x3E20
    27b4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27b6:	82 81       	ldd	r24, Z+2	; 0x02
    27b8:	88 23       	and	r24, r24
    27ba:	ec f7       	brge	.-6      	; 0x27b6 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    27bc:	e0 ec       	ldi	r30, 0xC0	; 192
    27be:	f8 e0       	ldi	r31, 0x08	; 8
    27c0:	83 81       	ldd	r24, Z+3	; 0x03
    27c2:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[1];
    27c6:	80 91 21 3e 	lds	r24, 0x3E21
    27ca:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27cc:	82 81       	ldd	r24, Z+2	; 0x02
    27ce:	88 23       	and	r24, r24
    27d0:	ec f7       	brge	.-6      	; 0x27cc <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    27d2:	e0 ec       	ldi	r30, 0xC0	; 192
    27d4:	f8 e0       	ldi	r31, 0x08	; 8
    27d6:	83 81       	ldd	r24, Z+3	; 0x03
    27d8:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[2];
    27dc:	80 91 22 3e 	lds	r24, 0x3E22
    27e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27e2:	82 81       	ldd	r24, Z+2	; 0x02
    27e4:	88 23       	and	r24, r24
    27e6:	ec f7       	brge	.-6      	; 0x27e2 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    27e8:	a0 ec       	ldi	r26, 0xC0	; 192
    27ea:	b8 e0       	ldi	r27, 0x08	; 8
    27ec:	13 96       	adiw	r26, 0x03	; 3
    27ee:	8c 91       	ld	r24, X
    27f0:	13 97       	sbiw	r26, 0x03	; 3
    27f2:	80 93 2c 3e 	sts	0x3E2C, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    27f6:	88 e0       	ldi	r24, 0x08	; 8
    27f8:	e0 e2       	ldi	r30, 0x20	; 32
    27fa:	f6 e0       	ldi	r31, 0x06	; 6
    27fc:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    27fe:	e0 e4       	ldi	r30, 0x40	; 64
    2800:	f6 e0       	ldi	r31, 0x06	; 6
    2802:	80 e1       	ldi	r24, 0x10	; 16
    2804:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2806:	94 e5       	ldi	r25, 0x54	; 84
    2808:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    280a:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    280c:	80 91 1d 3e 	lds	r24, 0x3E1D
    2810:	90 91 1e 3e 	lds	r25, 0x3E1E
    2814:	03 96       	adiw	r24, 0x03	; 3
    2816:	80 93 1d 3e 	sts	0x3E1D, r24
    281a:	90 93 1e 3e 	sts	0x3E1E, r25
	checksumADC[0] += SPIBuffer[0];
    281e:	80 91 11 21 	lds	r24, 0x2111
    2822:	e0 e2       	ldi	r30, 0x20	; 32
    2824:	fe e3       	ldi	r31, 0x3E	; 62
    2826:	90 81       	ld	r25, Z
    2828:	89 0f       	add	r24, r25
    282a:	80 93 11 21 	sts	0x2111, r24
	checksumADC[1] += SPIBuffer[1];
    282e:	80 91 12 21 	lds	r24, 0x2112
    2832:	91 81       	ldd	r25, Z+1	; 0x01
    2834:	89 0f       	add	r24, r25
    2836:	80 93 12 21 	sts	0x2112, r24
	checksumADC[2] += SPIBuffer[2];
    283a:	80 91 13 21 	lds	r24, 0x2113
    283e:	92 81       	ldd	r25, Z+2	; 0x02
    2840:	89 0f       	add	r24, r25
    2842:	80 93 13 21 	sts	0x2113, r24
}
    2846:	28 96       	adiw	r28, 0x08	; 8
    2848:	cd bf       	out	0x3d, r28	; 61
    284a:	de bf       	out	0x3e, r29	; 62
    284c:	df 91       	pop	r29
    284e:	cf 91       	pop	r28
    2850:	1f 91       	pop	r17
    2852:	0f 91       	pop	r16
    2854:	ff 90       	pop	r15
    2856:	08 95       	ret

00002858 <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    2858:	2f 92       	push	r2
    285a:	3f 92       	push	r3
    285c:	4f 92       	push	r4
    285e:	5f 92       	push	r5
    2860:	6f 92       	push	r6
    2862:	7f 92       	push	r7
    2864:	8f 92       	push	r8
    2866:	9f 92       	push	r9
    2868:	af 92       	push	r10
    286a:	bf 92       	push	r11
    286c:	cf 92       	push	r12
    286e:	df 92       	push	r13
    2870:	ef 92       	push	r14
    2872:	ff 92       	push	r15
    2874:	0f 93       	push	r16
    2876:	1f 93       	push	r17
    2878:	cf 93       	push	r28
    287a:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    287c:	10 92 1d 3e 	sts	0x3E1D, r1
    2880:	10 92 1e 3e 	sts	0x3E1E, r1
	sampleCount = 0;
    2884:	10 92 65 50 	sts	0x5065, r1
    2888:	10 92 66 50 	sts	0x5066, r1
    288c:	10 92 67 50 	sts	0x5067, r1
    2890:	10 92 68 50 	sts	0x5068, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2894:	83 e1       	ldi	r24, 0x13	; 19
    2896:	91 e2       	ldi	r25, 0x21	; 33
    2898:	10 92 13 21 	sts	0x2113, r1
    289c:	fc 01       	movw	r30, r24
    289e:	31 97       	sbiw	r30, 0x01	; 1
    28a0:	10 82       	st	Z, r1
    28a2:	02 97       	sbiw	r24, 0x02	; 2
    28a4:	dc 01       	movw	r26, r24
    28a6:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    28a8:	81 e0       	ldi	r24, 0x01	; 1
    28aa:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    28ae:	84 e0       	ldi	r24, 0x04	; 4
    28b0:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    28b4:	80 ed       	ldi	r24, 0xD0	; 208
    28b6:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    28ba:	8d e0       	ldi	r24, 0x0D	; 13
    28bc:	80 93 20 3e 	sts	0x3E20, r24
	SPIBuffer[1] = 0xF3;
    28c0:	83 ef       	ldi	r24, 0xF3	; 243
    28c2:	80 93 21 3e 	sts	0x3E21, r24
	SPIBuffer[2] = 0x57;
    28c6:	87 e5       	ldi	r24, 0x57	; 87
    28c8:	80 93 22 3e 	sts	0x3E22, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    28cc:	80 91 65 50 	lds	r24, 0x5065
    28d0:	90 91 66 50 	lds	r25, 0x5066
    28d4:	a0 91 67 50 	lds	r26, 0x5067
    28d8:	b0 91 68 50 	lds	r27, 0x5068
    28dc:	83 35       	cpi	r24, 0x53	; 83
    28de:	e5 e5       	ldi	r30, 0x55	; 85
    28e0:	9e 07       	cpc	r25, r30
    28e2:	e0 e0       	ldi	r30, 0x00	; 0
    28e4:	ae 07       	cpc	r26, r30
    28e6:	e0 e0       	ldi	r30, 0x00	; 0
    28e8:	be 07       	cpc	r27, r30
    28ea:	08 f0       	brcs	.+2      	; 0x28ee <FRAMWriteKnowns+0x96>
    28ec:	cc c0       	rjmp	.+408    	; 0x2a86 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    28ee:	0f 2e       	mov	r0, r31
    28f0:	f0 e4       	ldi	r31, 0x40	; 64
    28f2:	ef 2e       	mov	r14, r31
    28f4:	f6 e0       	ldi	r31, 0x06	; 6
    28f6:	ff 2e       	mov	r15, r31
    28f8:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    28fa:	40 e2       	ldi	r20, 0x20	; 32
    28fc:	56 e0       	ldi	r21, 0x06	; 6
    28fe:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2900:	e0 ec       	ldi	r30, 0xC0	; 192
    2902:	f8 e0       	ldi	r31, 0x08	; 8
    2904:	0f 2e       	mov	r0, r31
    2906:	f6 e0       	ldi	r31, 0x06	; 6
    2908:	7f 2e       	mov	r7, r31
    290a:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    290c:	cc e2       	ldi	r28, 0x2C	; 44
    290e:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2910:	66 24       	eor	r6, r6
    2912:	68 94       	set
    2914:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2916:	0f 2e       	mov	r0, r31
    2918:	fd e1       	ldi	r31, 0x1D	; 29
    291a:	cf 2e       	mov	r12, r31
    291c:	fe e3       	ldi	r31, 0x3E	; 62
    291e:	df 2e       	mov	r13, r31
    2920:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2922:	8e 01       	movw	r16, r28
    2924:	0c 50       	subi	r16, 0x0C	; 12
    2926:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2928:	0f 2e       	mov	r0, r31
    292a:	f5 ef       	ldi	r31, 0xF5	; 245
    292c:	4f 2e       	mov	r4, r31
    292e:	ff ef       	ldi	r31, 0xFF	; 255
    2930:	5f 2e       	mov	r5, r31
    2932:	f0 2d       	mov	r31, r0
    2934:	4c 0e       	add	r4, r28
    2936:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2938:	0f 2e       	mov	r0, r31
    293a:	f6 ef       	ldi	r31, 0xF6	; 246
    293c:	2f 2e       	mov	r2, r31
    293e:	ff ef       	ldi	r31, 0xFF	; 255
    2940:	3f 2e       	mov	r3, r31
    2942:	f0 2d       	mov	r31, r0
    2944:	2c 0e       	add	r2, r28
    2946:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2948:	61 e1       	ldi	r22, 0x11	; 17
    294a:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    294c:	5b 01       	movw	r10, r22
    294e:	08 94       	sec
    2950:	a1 1c       	adc	r10, r1
    2952:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2954:	88 24       	eor	r8, r8
    2956:	99 24       	eor	r9, r9
    2958:	68 94       	set
    295a:	81 f8       	bld	r8, 1
    295c:	86 0e       	add	r8, r22
    295e:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2960:	30 e1       	ldi	r19, 0x10	; 16
    2962:	d7 01       	movw	r26, r14
    2964:	16 96       	adiw	r26, 0x06	; 6
    2966:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2968:	da 01       	movw	r26, r20
    296a:	16 96       	adiw	r26, 0x06	; 6
    296c:	2c 93       	st	X, r18
    296e:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2970:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2972:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2974:	82 81       	ldd	r24, Z+2	; 0x02
    2976:	88 23       	and	r24, r24
    2978:	ec f7       	brge	.-6      	; 0x2974 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    297a:	83 81       	ldd	r24, Z+3	; 0x03
    297c:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    297e:	da 01       	movw	r26, r20
    2980:	15 96       	adiw	r26, 0x05	; 5
    2982:	2c 93       	st	X, r18
    2984:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2986:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2988:	16 96       	adiw	r26, 0x06	; 6
    298a:	2c 93       	st	X, r18
    298c:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    298e:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2990:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2992:	82 81       	ldd	r24, Z+2	; 0x02
    2994:	88 23       	and	r24, r24
    2996:	ec f7       	brge	.-6      	; 0x2992 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    2998:	83 81       	ldd	r24, Z+3	; 0x03
    299a:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    299c:	d6 01       	movw	r26, r12
    299e:	11 96       	adiw	r26, 0x01	; 1
    29a0:	8c 91       	ld	r24, X
    29a2:	11 97       	sbiw	r26, 0x01	; 1
    29a4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    29a6:	82 81       	ldd	r24, Z+2	; 0x02
    29a8:	88 23       	and	r24, r24
    29aa:	ec f7       	brge	.-6      	; 0x29a6 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    29ac:	83 81       	ldd	r24, Z+3	; 0x03
    29ae:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    29b0:	d6 01       	movw	r26, r12
    29b2:	8c 91       	ld	r24, X
    29b4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    29b6:	82 81       	ldd	r24, Z+2	; 0x02
    29b8:	88 23       	and	r24, r24
    29ba:	ec f7       	brge	.-6      	; 0x29b6 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    29bc:	83 81       	ldd	r24, Z+3	; 0x03
    29be:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    29c0:	d8 01       	movw	r26, r16
    29c2:	8c 91       	ld	r24, X
    29c4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    29c6:	82 81       	ldd	r24, Z+2	; 0x02
    29c8:	88 23       	and	r24, r24
    29ca:	ec f7       	brge	.-6      	; 0x29c6 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    29cc:	83 81       	ldd	r24, Z+3	; 0x03
    29ce:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    29d0:	d2 01       	movw	r26, r4
    29d2:	8c 91       	ld	r24, X
    29d4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    29d6:	82 81       	ldd	r24, Z+2	; 0x02
    29d8:	88 23       	and	r24, r24
    29da:	ec f7       	brge	.-6      	; 0x29d6 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    29dc:	83 81       	ldd	r24, Z+3	; 0x03
    29de:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    29e0:	d1 01       	movw	r26, r2
    29e2:	8c 91       	ld	r24, X
    29e4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    29e6:	82 81       	ldd	r24, Z+2	; 0x02
    29e8:	88 23       	and	r24, r24
    29ea:	ec f7       	brge	.-6      	; 0x29e6 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    29ec:	83 81       	ldd	r24, Z+3	; 0x03
    29ee:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    29f0:	da 01       	movw	r26, r20
    29f2:	15 96       	adiw	r26, 0x05	; 5
    29f4:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    29f6:	30 e1       	ldi	r19, 0x10	; 16
    29f8:	d7 01       	movw	r26, r14
    29fa:	15 96       	adiw	r26, 0x05	; 5
    29fc:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    29fe:	80 91 1d 3e 	lds	r24, 0x3E1D
    2a02:	90 91 1e 3e 	lds	r25, 0x3E1E
    2a06:	03 96       	adiw	r24, 0x03	; 3
    2a08:	80 93 1d 3e 	sts	0x3E1D, r24
    2a0c:	90 93 1e 3e 	sts	0x3E1E, r25
		checksumADC[0] += SPIBuffer[0];
    2a10:	db 01       	movw	r26, r22
    2a12:	8c 91       	ld	r24, X
    2a14:	d8 01       	movw	r26, r16
    2a16:	9c 91       	ld	r25, X
    2a18:	89 0f       	add	r24, r25
    2a1a:	db 01       	movw	r26, r22
    2a1c:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2a1e:	d5 01       	movw	r26, r10
    2a20:	8c 91       	ld	r24, X
    2a22:	a1 e2       	ldi	r26, 0x21	; 33
    2a24:	be e3       	ldi	r27, 0x3E	; 62
    2a26:	9c 91       	ld	r25, X
    2a28:	89 0f       	add	r24, r25
    2a2a:	d5 01       	movw	r26, r10
    2a2c:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2a2e:	d4 01       	movw	r26, r8
    2a30:	8c 91       	ld	r24, X
    2a32:	a2 e2       	ldi	r26, 0x22	; 34
    2a34:	be e3       	ldi	r27, 0x3E	; 62
    2a36:	9c 91       	ld	r25, X
    2a38:	89 0f       	add	r24, r25
    2a3a:	d4 01       	movw	r26, r8
    2a3c:	8c 93       	st	X, r24
		
		sampleCount++;
    2a3e:	80 91 65 50 	lds	r24, 0x5065
    2a42:	90 91 66 50 	lds	r25, 0x5066
    2a46:	a0 91 67 50 	lds	r26, 0x5067
    2a4a:	b0 91 68 50 	lds	r27, 0x5068
    2a4e:	01 96       	adiw	r24, 0x01	; 1
    2a50:	a1 1d       	adc	r26, r1
    2a52:	b1 1d       	adc	r27, r1
    2a54:	80 93 65 50 	sts	0x5065, r24
    2a58:	90 93 66 50 	sts	0x5066, r25
    2a5c:	a0 93 67 50 	sts	0x5067, r26
    2a60:	b0 93 68 50 	sts	0x5068, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2a64:	80 91 65 50 	lds	r24, 0x5065
    2a68:	90 91 66 50 	lds	r25, 0x5066
    2a6c:	a0 91 67 50 	lds	r26, 0x5067
    2a70:	b0 91 68 50 	lds	r27, 0x5068
    2a74:	83 35       	cpi	r24, 0x53	; 83
    2a76:	35 e5       	ldi	r19, 0x55	; 85
    2a78:	93 07       	cpc	r25, r19
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	a3 07       	cpc	r26, r19
    2a7e:	30 e0       	ldi	r19, 0x00	; 0
    2a80:	b3 07       	cpc	r27, r19
    2a82:	08 f4       	brcc	.+2      	; 0x2a86 <FRAMWriteKnowns+0x22e>
    2a84:	6d cf       	rjmp	.-294    	; 0x2960 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2a86:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	ADCPower(FALSE);
    2a8a:	80 e0       	ldi	r24, 0x00	; 0
    2a8c:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
}
    2a90:	df 91       	pop	r29
    2a92:	cf 91       	pop	r28
    2a94:	1f 91       	pop	r17
    2a96:	0f 91       	pop	r16
    2a98:	ff 90       	pop	r15
    2a9a:	ef 90       	pop	r14
    2a9c:	df 90       	pop	r13
    2a9e:	cf 90       	pop	r12
    2aa0:	bf 90       	pop	r11
    2aa2:	af 90       	pop	r10
    2aa4:	9f 90       	pop	r9
    2aa6:	8f 90       	pop	r8
    2aa8:	7f 90       	pop	r7
    2aaa:	6f 90       	pop	r6
    2aac:	5f 90       	pop	r5
    2aae:	4f 90       	pop	r4
    2ab0:	3f 90       	pop	r3
    2ab2:	2f 90       	pop	r2
    2ab4:	08 95       	ret

00002ab6 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2ab6:	80 ff       	sbrs	r24, 0
    2ab8:	05 c0       	rjmp	.+10     	; 0x2ac4 <setADCInput+0xe>
    2aba:	20 e4       	ldi	r18, 0x40	; 64
    2abc:	e0 e0       	ldi	r30, 0x00	; 0
    2abe:	f6 e0       	ldi	r31, 0x06	; 6
    2ac0:	25 83       	std	Z+5, r18	; 0x05
    2ac2:	04 c0       	rjmp	.+8      	; 0x2acc <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2ac4:	20 e4       	ldi	r18, 0x40	; 64
    2ac6:	e0 e0       	ldi	r30, 0x00	; 0
    2ac8:	f6 e0       	ldi	r31, 0x06	; 6
    2aca:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2acc:	81 ff       	sbrs	r24, 1
    2ace:	05 c0       	rjmp	.+10     	; 0x2ada <setADCInput+0x24>
    2ad0:	22 e0       	ldi	r18, 0x02	; 2
    2ad2:	e0 e2       	ldi	r30, 0x20	; 32
    2ad4:	f6 e0       	ldi	r31, 0x06	; 6
    2ad6:	25 83       	std	Z+5, r18	; 0x05
    2ad8:	04 c0       	rjmp	.+8      	; 0x2ae2 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2ada:	22 e0       	ldi	r18, 0x02	; 2
    2adc:	e0 e2       	ldi	r30, 0x20	; 32
    2ade:	f6 e0       	ldi	r31, 0x06	; 6
    2ae0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2ae2:	82 ff       	sbrs	r24, 2
    2ae4:	05 c0       	rjmp	.+10     	; 0x2af0 <setADCInput+0x3a>
    2ae6:	84 e0       	ldi	r24, 0x04	; 4
    2ae8:	e0 e2       	ldi	r30, 0x20	; 32
    2aea:	f6 e0       	ldi	r31, 0x06	; 6
    2aec:	85 83       	std	Z+5, r24	; 0x05
    2aee:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2af0:	84 e0       	ldi	r24, 0x04	; 4
    2af2:	e0 e2       	ldi	r30, 0x20	; 32
    2af4:	f6 e0       	ldi	r31, 0x06	; 6
    2af6:	86 83       	std	Z+6, r24	; 0x06
    2af8:	08 95       	ret

00002afa <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2afa:	2f 92       	push	r2
    2afc:	3f 92       	push	r3
    2afe:	4f 92       	push	r4
    2b00:	5f 92       	push	r5
    2b02:	7f 92       	push	r7
    2b04:	8f 92       	push	r8
    2b06:	9f 92       	push	r9
    2b08:	af 92       	push	r10
    2b0a:	bf 92       	push	r11
    2b0c:	cf 92       	push	r12
    2b0e:	df 92       	push	r13
    2b10:	ef 92       	push	r14
    2b12:	ff 92       	push	r15
    2b14:	0f 93       	push	r16
    2b16:	1f 93       	push	r17
    2b18:	cf 93       	push	r28
    2b1a:	df 93       	push	r29
    2b1c:	cd b7       	in	r28, 0x3d	; 61
    2b1e:	de b7       	in	r29, 0x3e	; 62
    2b20:	18 2f       	mov	r17, r24
    2b22:	76 2e       	mov	r7, r22
    2b24:	f4 2e       	mov	r15, r20
    2b26:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    2b28:	89 8d       	ldd	r24, Y+25	; 0x19
    2b2a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2b2c:	80 93 63 50 	sts	0x5063, r24
    2b30:	90 93 64 50 	sts	0x5064, r25
	ADC_Sampling_Finished = 0;
    2b34:	10 92 a6 50 	sts	0x50A6, r1
	ADC_buffer_size = BufferSize;
    2b38:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2b3a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2b3c:	80 93 a7 50 	sts	0x50A7, r24
    2b40:	90 93 a8 50 	sts	0x50A8, r25
	if(use_FRAM){
    2b44:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2b46:	88 23       	and	r24, r24
    2b48:	21 f0       	breq	.+8      	; 0x2b52 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    2b4a:	81 e0       	ldi	r24, 0x01	; 1
    2b4c:	80 93 48 40 	sts	0x4048, r24
    2b50:	02 c0       	rjmp	.+4      	; 0x2b56 <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2b52:	10 92 48 40 	sts	0x4048, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2b56:	81 e0       	ldi	r24, 0x01	; 1
    2b58:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2b5c:	81 2f       	mov	r24, r17
    2b5e:	6f 2d       	mov	r22, r15
    2b60:	0e 94 9e 0b 	call	0x173c	; 0x173c <set_ampGain>
	set_filter(filterConfig);
    2b64:	87 2d       	mov	r24, r7
    2b66:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2b6a:	8e 2d       	mov	r24, r14
    2b6c:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2b70:	84 e0       	ldi	r24, 0x04	; 4
    2b72:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2b76:	84 e5       	ldi	r24, 0x54	; 84
    2b78:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2b7c:	81 e0       	ldi	r24, 0x01	; 1
    2b7e:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <enableADCMUX>
	setADCInput(channel);
    2b82:	81 2f       	mov	r24, r17
    2b84:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2b88:	e0 ea       	ldi	r30, 0xA0	; 160
    2b8a:	f6 e0       	ldi	r31, 0x06	; 6
    2b8c:	22 e0       	ldi	r18, 0x02	; 2
    2b8e:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2b90:	77 24       	eor	r7, r7
    2b92:	73 94       	inc	r7
    2b94:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2b96:	0f 2e       	mov	r0, r31
    2b98:	f0 e8       	ldi	r31, 0x80	; 128
    2b9a:	4f 2e       	mov	r4, r31
    2b9c:	f1 e0       	ldi	r31, 0x01	; 1
    2b9e:	5f 2e       	mov	r5, r31
    2ba0:	f0 2d       	mov	r31, r0
    2ba2:	88 e7       	ldi	r24, 0x78	; 120
    2ba4:	d2 01       	movw	r26, r4
    2ba6:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2ba8:	e0 e0       	ldi	r30, 0x00	; 0
    2baa:	f9 e0       	ldi	r31, 0x09	; 9
    2bac:	80 ef       	ldi	r24, 0xF0	; 240
    2bae:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2bb0:	c0 a6       	lds	r28, 0xb0
    2bb2:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2bb4:	a2 a6       	lds	r26, 0xb2
    2bb6:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2bb8:	84 a6       	lds	r24, 0xb4
    2bba:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2bbc:	8d 89       	ldd	r24, Y+21	; 0x15
    2bbe:	9e 89       	ldd	r25, Y+22	; 0x16
    2bc0:	86 a7       	lds	r24, 0x76
    2bc2:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2bc4:	80 2f       	mov	r24, r16
    2bc6:	90 e0       	ldi	r25, 0x00	; 0
    2bc8:	01 97       	sbiw	r24, 0x01	; 1
    2bca:	86 a3       	lds	r24, 0x56
    2bcc:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2bce:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2bd0:	8f ef       	ldi	r24, 0xFF	; 255
    2bd2:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2bd4:	80 81       	ld	r24, Z
    2bd6:	80 7f       	andi	r24, 0xF0	; 240
    2bd8:	88 60       	ori	r24, 0x08	; 8
    2bda:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2bdc:	10 92 65 50 	sts	0x5065, r1
    2be0:	10 92 66 50 	sts	0x5066, r1
    2be4:	10 92 67 50 	sts	0x5067, r1
    2be8:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2bec:	10 92 a0 50 	sts	0x50A0, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2bf0:	e0 ea       	ldi	r30, 0xA0	; 160
    2bf2:	f0 e0       	ldi	r31, 0x00	; 0
    2bf4:	82 81       	ldd	r24, Z+2	; 0x02
    2bf6:	87 60       	ori	r24, 0x07	; 7
    2bf8:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2bfa:	78 94       	sei

	SPICS(TRUE);
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2c02:	80 e2       	ldi	r24, 0x20	; 32
    2c04:	e0 e8       	ldi	r30, 0x80	; 128
    2c06:	f6 e0       	ldi	r31, 0x06	; 6
    2c08:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2c0a:	00 e4       	ldi	r16, 0x40	; 64
    2c0c:	1a e0       	ldi	r17, 0x0A	; 10
    2c0e:	83 e2       	ldi	r24, 0x23	; 35
    2c10:	f8 01       	movw	r30, r16
    2c12:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2c14:	61 01       	movw	r12, r2
    2c16:	ee 24       	eor	r14, r14
    2c18:	ff 24       	eor	r15, r15
    2c1a:	60 e8       	ldi	r22, 0x80	; 128
    2c1c:	74 e8       	ldi	r23, 0x84	; 132
    2c1e:	8e e1       	ldi	r24, 0x1E	; 30
    2c20:	90 e0       	ldi	r25, 0x00	; 0
    2c22:	a7 01       	movw	r20, r14
    2c24:	96 01       	movw	r18, r12
    2c26:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    2c2a:	d8 01       	movw	r26, r16
    2c2c:	96 96       	adiw	r26, 0x26	; 38
    2c2e:	2d 93       	st	X+, r18
    2c30:	3c 93       	st	X, r19
    2c32:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2c34:	60 e4       	ldi	r22, 0x40	; 64
    2c36:	72 e4       	ldi	r23, 0x42	; 66
    2c38:	8f e0       	ldi	r24, 0x0F	; 15
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	a7 01       	movw	r20, r14
    2c3e:	96 01       	movw	r18, r12
    2c40:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    2c44:	f8 01       	movw	r30, r16
    2c46:	22 af       	sts	0x72, r18
    2c48:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2c4a:	e0 e4       	ldi	r30, 0x40	; 64
    2c4c:	f8 e0       	ldi	r31, 0x08	; 8
    2c4e:	8f 89       	ldd	r24, Y+23	; 0x17
    2c50:	98 8d       	ldd	r25, Y+24	; 0x18
    2c52:	86 a3       	lds	r24, 0x56
    2c54:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2c56:	80 ed       	ldi	r24, 0xD0	; 208
    2c58:	d2 01       	movw	r26, r4
    2c5a:	11 96       	adiw	r26, 0x01	; 1
    2c5c:	8c 93       	st	X, r24
    2c5e:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2c60:	76 82       	std	Z+6, r7	; 0x06
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2c62:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    2c64:	8c e0       	ldi	r24, 0x0C	; 12
    2c66:	81 87       	std	Z+9, r24	; 0x09
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2c68:	80 81       	ld	r24, Z
    2c6a:	80 7f       	andi	r24, 0xF0	; 240
    2c6c:	89 60       	ori	r24, 0x09	; 9
    2c6e:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2c70:	f8 01       	movw	r30, r16
    2c72:	80 81       	ld	r24, Z
    2c74:	80 7f       	andi	r24, 0xF0	; 240
    2c76:	81 60       	ori	r24, 0x01	; 1
    2c78:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2c7a:	df 91       	pop	r29
    2c7c:	cf 91       	pop	r28
    2c7e:	1f 91       	pop	r17
    2c80:	0f 91       	pop	r16
    2c82:	ff 90       	pop	r15
    2c84:	ef 90       	pop	r14
    2c86:	df 90       	pop	r13
    2c88:	cf 90       	pop	r12
    2c8a:	bf 90       	pop	r11
    2c8c:	af 90       	pop	r10
    2c8e:	9f 90       	pop	r9
    2c90:	8f 90       	pop	r8
    2c92:	7f 90       	pop	r7
    2c94:	5f 90       	pop	r5
    2c96:	4f 90       	pop	r4
    2c98:	3f 90       	pop	r3
    2c9a:	2f 90       	pop	r2
    2c9c:	08 95       	ret

00002c9e <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2c9e:	2f 92       	push	r2
    2ca0:	3f 92       	push	r3
    2ca2:	4f 92       	push	r4
    2ca4:	5f 92       	push	r5
    2ca6:	6f 92       	push	r6
    2ca8:	7f 92       	push	r7
    2caa:	8f 92       	push	r8
    2cac:	9f 92       	push	r9
    2cae:	af 92       	push	r10
    2cb0:	bf 92       	push	r11
    2cb2:	cf 92       	push	r12
    2cb4:	df 92       	push	r13
    2cb6:	ef 92       	push	r14
    2cb8:	ff 92       	push	r15
    2cba:	0f 93       	push	r16
    2cbc:	cf 93       	push	r28
    2cbe:	df 93       	push	r29
    2cc0:	0f 92       	push	r0
    2cc2:	0f 92       	push	r0
    2cc4:	cd b7       	in	r28, 0x3d	; 61
    2cc6:	de b7       	in	r29, 0x3e	; 62
    2cc8:	96 2f       	mov	r25, r22
    2cca:	49 83       	std	Y+1, r20	; 0x01
    2ccc:	5a 83       	std	Y+2, r21	; 0x02
    2cce:	52 2f       	mov	r21, r18
    2cd0:	70 2f       	mov	r23, r16
    2cd2:	37 01       	movw	r6, r14
    2cd4:	26 01       	movw	r4, r12
    2cd6:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2cd8:	2d b7       	in	r18, 0x3d	; 61
    2cda:	3e b7       	in	r19, 0x3e	; 62
    2cdc:	29 50       	subi	r18, 0x09	; 9
    2cde:	30 40       	sbci	r19, 0x00	; 0
    2ce0:	2d bf       	out	0x3d, r18	; 61
    2ce2:	3e bf       	out	0x3e, r19	; 62
    2ce4:	ed b7       	in	r30, 0x3d	; 61
    2ce6:	fe b7       	in	r31, 0x3e	; 62
    2ce8:	31 96       	adiw	r30, 0x01	; 1
    2cea:	ad b7       	in	r26, 0x3d	; 61
    2cec:	be b7       	in	r27, 0x3e	; 62
    2cee:	11 96       	adiw	r26, 0x01	; 1
    2cf0:	8d 92       	st	X+, r8
    2cf2:	9c 92       	st	X, r9
    2cf4:	12 97       	sbiw	r26, 0x02	; 2
    2cf6:	2f 89       	ldd	r18, Y+23	; 0x17
    2cf8:	38 8d       	ldd	r19, Y+24	; 0x18
    2cfa:	22 83       	std	Z+2, r18	; 0x02
    2cfc:	33 83       	std	Z+3, r19	; 0x03
    2cfe:	29 8d       	ldd	r18, Y+25	; 0x19
    2d00:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2d02:	24 83       	std	Z+4, r18	; 0x04
    2d04:	35 83       	std	Z+5, r19	; 0x05
    2d06:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2d08:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2d0a:	26 83       	std	Z+6, r18	; 0x06
    2d0c:	37 83       	std	Z+7, r19	; 0x07
    2d0e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2d10:	20 87       	std	Z+8, r18	; 0x08
    2d12:	64 ec       	ldi	r22, 0xC4	; 196
    2d14:	49 2f       	mov	r20, r25
    2d16:	29 81       	ldd	r18, Y+1	; 0x01
    2d18:	3a 81       	ldd	r19, Y+2	; 0x02
    2d1a:	05 2f       	mov	r16, r21
    2d1c:	e7 2e       	mov	r14, r23
    2d1e:	63 01       	movw	r12, r6
    2d20:	52 01       	movw	r10, r4
    2d22:	41 01       	movw	r8, r2
    2d24:	0e 94 7d 15 	call	0x2afa	; 0x2afa <CO_collectSeismic1Channel_ext>
    2d28:	2d b7       	in	r18, 0x3d	; 61
    2d2a:	3e b7       	in	r19, 0x3e	; 62
    2d2c:	27 5f       	subi	r18, 0xF7	; 247
    2d2e:	3f 4f       	sbci	r19, 0xFF	; 255
    2d30:	2d bf       	out	0x3d, r18	; 61
    2d32:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2d34:	0f 90       	pop	r0
    2d36:	0f 90       	pop	r0
    2d38:	df 91       	pop	r29
    2d3a:	cf 91       	pop	r28
    2d3c:	0f 91       	pop	r16
    2d3e:	ff 90       	pop	r15
    2d40:	ef 90       	pop	r14
    2d42:	df 90       	pop	r13
    2d44:	cf 90       	pop	r12
    2d46:	bf 90       	pop	r11
    2d48:	af 90       	pop	r10
    2d4a:	9f 90       	pop	r9
    2d4c:	8f 90       	pop	r8
    2d4e:	7f 90       	pop	r7
    2d50:	6f 90       	pop	r6
    2d52:	5f 90       	pop	r5
    2d54:	4f 90       	pop	r4
    2d56:	3f 90       	pop	r3
    2d58:	2f 90       	pop	r2
    2d5a:	08 95       	ret

00002d5c <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2d5c:	2f 92       	push	r2
    2d5e:	3f 92       	push	r3
    2d60:	5f 92       	push	r5
    2d62:	6f 92       	push	r6
    2d64:	7f 92       	push	r7
    2d66:	8f 92       	push	r8
    2d68:	9f 92       	push	r9
    2d6a:	af 92       	push	r10
    2d6c:	bf 92       	push	r11
    2d6e:	cf 92       	push	r12
    2d70:	df 92       	push	r13
    2d72:	ef 92       	push	r14
    2d74:	ff 92       	push	r15
    2d76:	0f 93       	push	r16
    2d78:	1f 93       	push	r17
    2d7a:	cf 93       	push	r28
    2d7c:	df 93       	push	r29
    2d7e:	0f 92       	push	r0
    2d80:	0f 92       	push	r0
    2d82:	cd b7       	in	r28, 0x3d	; 61
    2d84:	de b7       	in	r29, 0x3e	; 62
    2d86:	18 2f       	mov	r17, r24
    2d88:	3b 01       	movw	r6, r22
    2d8a:	49 83       	std	Y+1, r20	; 0x01
    2d8c:	5a 83       	std	Y+2, r21	; 0x02
    2d8e:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2d90:	89 8d       	ldd	r24, Y+25	; 0x19
    2d92:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2d94:	80 93 63 50 	sts	0x5063, r24
    2d98:	90 93 64 50 	sts	0x5064, r25
	ADC_Sampling_Finished = 0;
    2d9c:	10 92 a6 50 	sts	0x50A6, r1
	ADC_buffer_size = BufferSize;
    2da0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2da2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2da4:	80 93 a7 50 	sts	0x50A7, r24
    2da8:	90 93 a8 50 	sts	0x50A8, r25
	if(use_FRAM){
    2dac:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2dae:	88 23       	and	r24, r24
    2db0:	21 f0       	breq	.+8      	; 0x2dba <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2db2:	81 e0       	ldi	r24, 0x01	; 1
    2db4:	80 93 48 40 	sts	0x4048, r24
    2db8:	02 c0       	rjmp	.+4      	; 0x2dbe <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2dba:	10 92 48 40 	sts	0x4048, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2dbe:	81 e0       	ldi	r24, 0x01	; 1
    2dc0:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2dc4:	85 e0       	ldi	r24, 0x05	; 5
    2dc6:	d3 01       	movw	r26, r6
    2dc8:	6c 91       	ld	r22, X
    2dca:	0e 94 9e 0b 	call	0x173c	; 0x173c <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2dce:	86 e0       	ldi	r24, 0x06	; 6
    2dd0:	f3 01       	movw	r30, r6
    2dd2:	61 81       	ldd	r22, Z+1	; 0x01
    2dd4:	0e 94 9e 0b 	call	0x173c	; 0x173c <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2dd8:	87 e0       	ldi	r24, 0x07	; 7
    2dda:	d3 01       	movw	r26, r6
    2ddc:	12 96       	adiw	r26, 0x02	; 2
    2dde:	6c 91       	ld	r22, X
    2de0:	0e 94 9e 0b 	call	0x173c	; 0x173c <set_ampGain>
	set_filter(filterConfig);
    2de4:	81 2f       	mov	r24, r17
    2de6:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2dea:	80 2f       	mov	r24, r16
    2dec:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2df0:	84 e0       	ldi	r24, 0x04	; 4
    2df2:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2df6:	84 e5       	ldi	r24, 0x54	; 84
    2df8:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2dfc:	81 e0       	ldi	r24, 0x01	; 1
    2dfe:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2e02:	85 e0       	ldi	r24, 0x05	; 5
    2e04:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2e08:	e0 ea       	ldi	r30, 0xA0	; 160
    2e0a:	f6 e0       	ldi	r31, 0x06	; 6
    2e0c:	22 e0       	ldi	r18, 0x02	; 2
    2e0e:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2e10:	66 24       	eor	r6, r6
    2e12:	63 94       	inc	r6
    2e14:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2e16:	0f 2e       	mov	r0, r31
    2e18:	f0 e8       	ldi	r31, 0x80	; 128
    2e1a:	2f 2e       	mov	r2, r31
    2e1c:	f1 e0       	ldi	r31, 0x01	; 1
    2e1e:	3f 2e       	mov	r3, r31
    2e20:	f0 2d       	mov	r31, r0
    2e22:	88 e7       	ldi	r24, 0x78	; 120
    2e24:	f1 01       	movw	r30, r2
    2e26:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2e28:	e0 e0       	ldi	r30, 0x00	; 0
    2e2a:	f8 e0       	ldi	r31, 0x08	; 8
    2e2c:	80 ef       	ldi	r24, 0xF0	; 240
    2e2e:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2e30:	e0 a6       	lds	r30, 0xb0
    2e32:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2e34:	c2 a6       	lds	r28, 0xb2
    2e36:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2e38:	a4 a6       	lds	r26, 0xb4
    2e3a:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2e3c:	86 a6       	lds	r24, 0xb6
    2e3e:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2e40:	85 2d       	mov	r24, r5
    2e42:	90 e0       	ldi	r25, 0x00	; 0
    2e44:	01 97       	sbiw	r24, 0x01	; 1
    2e46:	86 a3       	lds	r24, 0x56
    2e48:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2e4a:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2e4c:	8f ef       	ldi	r24, 0xFF	; 255
    2e4e:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2e50:	80 81       	ld	r24, Z
    2e52:	80 7f       	andi	r24, 0xF0	; 240
    2e54:	88 60       	ori	r24, 0x08	; 8
    2e56:	80 83       	st	Z, r24

	sampleCount = 0;
    2e58:	10 92 65 50 	sts	0x5065, r1
    2e5c:	10 92 66 50 	sts	0x5066, r1
    2e60:	10 92 67 50 	sts	0x5067, r1
    2e64:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2e68:	10 92 a0 50 	sts	0x50A0, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2e6c:	83 e1       	ldi	r24, 0x13	; 19
    2e6e:	91 e2       	ldi	r25, 0x21	; 33
    2e70:	10 92 13 21 	sts	0x2113, r1
    2e74:	fc 01       	movw	r30, r24
    2e76:	31 97       	sbiw	r30, 0x01	; 1
    2e78:	10 82       	st	Z, r1
    2e7a:	02 97       	sbiw	r24, 0x02	; 2
    2e7c:	dc 01       	movw	r26, r24
    2e7e:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    2e80:	e0 ea       	ldi	r30, 0xA0	; 160
    2e82:	f0 e0       	ldi	r31, 0x00	; 0
    2e84:	82 81       	ldd	r24, Z+2	; 0x02
    2e86:	87 60       	ori	r24, 0x07	; 7
    2e88:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2e8a:	78 94       	sei

	SPICS(TRUE);
    2e8c:	81 e0       	ldi	r24, 0x01	; 1
    2e8e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2e92:	80 e2       	ldi	r24, 0x20	; 32
    2e94:	e0 e8       	ldi	r30, 0x80	; 128
    2e96:	f6 e0       	ldi	r31, 0x06	; 6
    2e98:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2e9a:	00 e4       	ldi	r16, 0x40	; 64
    2e9c:	1a e0       	ldi	r17, 0x0A	; 10
    2e9e:	83 e2       	ldi	r24, 0x23	; 35
    2ea0:	f8 01       	movw	r30, r16
    2ea2:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2ea4:	89 81       	ldd	r24, Y+1	; 0x01
    2ea6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea8:	6c 01       	movw	r12, r24
    2eaa:	ee 24       	eor	r14, r14
    2eac:	ff 24       	eor	r15, r15
    2eae:	60 e8       	ldi	r22, 0x80	; 128
    2eb0:	74 e8       	ldi	r23, 0x84	; 132
    2eb2:	8e e1       	ldi	r24, 0x1E	; 30
    2eb4:	90 e0       	ldi	r25, 0x00	; 0
    2eb6:	a7 01       	movw	r20, r14
    2eb8:	96 01       	movw	r18, r12
    2eba:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    2ebe:	d8 01       	movw	r26, r16
    2ec0:	96 96       	adiw	r26, 0x26	; 38
    2ec2:	2d 93       	st	X+, r18
    2ec4:	3c 93       	st	X, r19
    2ec6:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2ec8:	60 e4       	ldi	r22, 0x40	; 64
    2eca:	72 e4       	ldi	r23, 0x42	; 66
    2ecc:	8f e0       	ldi	r24, 0x0F	; 15
    2ece:	90 e0       	ldi	r25, 0x00	; 0
    2ed0:	a7 01       	movw	r20, r14
    2ed2:	96 01       	movw	r18, r12
    2ed4:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    2ed8:	f8 01       	movw	r30, r16
    2eda:	22 af       	sts	0x72, r18
    2edc:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2ede:	e0 e4       	ldi	r30, 0x40	; 64
    2ee0:	f8 e0       	ldi	r31, 0x08	; 8
    2ee2:	8f 89       	ldd	r24, Y+23	; 0x17
    2ee4:	98 8d       	ldd	r25, Y+24	; 0x18
    2ee6:	86 a3       	lds	r24, 0x56
    2ee8:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2eea:	80 ec       	ldi	r24, 0xC0	; 192
    2eec:	d1 01       	movw	r26, r2
    2eee:	11 96       	adiw	r26, 0x01	; 1
    2ef0:	8c 93       	st	X, r24
    2ef2:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2ef4:	66 82       	std	Z+6, r6	; 0x06
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2ef6:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    2ef8:	8c e0       	ldi	r24, 0x0C	; 12
    2efa:	81 87       	std	Z+9, r24	; 0x09
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2efc:	80 81       	ld	r24, Z
    2efe:	80 7f       	andi	r24, 0xF0	; 240
    2f00:	89 60       	ori	r24, 0x09	; 9
    2f02:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2f04:	f8 01       	movw	r30, r16
    2f06:	80 81       	ld	r24, Z
    2f08:	80 7f       	andi	r24, 0xF0	; 240
    2f0a:	81 60       	ori	r24, 0x01	; 1
    2f0c:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2f0e:	0f 90       	pop	r0
    2f10:	0f 90       	pop	r0
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	1f 91       	pop	r17
    2f18:	0f 91       	pop	r16
    2f1a:	ff 90       	pop	r15
    2f1c:	ef 90       	pop	r14
    2f1e:	df 90       	pop	r13
    2f20:	cf 90       	pop	r12
    2f22:	bf 90       	pop	r11
    2f24:	af 90       	pop	r10
    2f26:	9f 90       	pop	r9
    2f28:	8f 90       	pop	r8
    2f2a:	7f 90       	pop	r7
    2f2c:	6f 90       	pop	r6
    2f2e:	5f 90       	pop	r5
    2f30:	3f 90       	pop	r3
    2f32:	2f 90       	pop	r2
    2f34:	08 95       	ret

00002f36 <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2f36:	2f 92       	push	r2
    2f38:	3f 92       	push	r3
    2f3a:	4f 92       	push	r4
    2f3c:	5f 92       	push	r5
    2f3e:	6f 92       	push	r6
    2f40:	7f 92       	push	r7
    2f42:	8f 92       	push	r8
    2f44:	9f 92       	push	r9
    2f46:	af 92       	push	r10
    2f48:	bf 92       	push	r11
    2f4a:	cf 92       	push	r12
    2f4c:	df 92       	push	r13
    2f4e:	ef 92       	push	r14
    2f50:	ff 92       	push	r15
    2f52:	0f 93       	push	r16
    2f54:	1f 93       	push	r17
    2f56:	cf 93       	push	r28
    2f58:	df 93       	push	r29
    2f5a:	00 d0       	rcall	.+0      	; 0x2f5c <CO_collectSeismic3Axises+0x26>
    2f5c:	0f 92       	push	r0
    2f5e:	cd b7       	in	r28, 0x3d	; 61
    2f60:	de b7       	in	r29, 0x3e	; 62
    2f62:	dc 01       	movw	r26, r24
    2f64:	3b 01       	movw	r6, r22
    2f66:	94 2f       	mov	r25, r20
    2f68:	32 2f       	mov	r19, r18
    2f6a:	28 01       	movw	r4, r16
    2f6c:	17 01       	movw	r2, r14
    2f6e:	c9 82       	std	Y+1, r12	; 0x01
    2f70:	da 82       	std	Y+2, r13	; 0x02
    2f72:	ab 82       	std	Y+3, r10	; 0x03
    2f74:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    2f76:	4d b7       	in	r20, 0x3d	; 61
    2f78:	5e b7       	in	r21, 0x3e	; 62
    2f7a:	47 50       	subi	r20, 0x07	; 7
    2f7c:	50 40       	sbci	r21, 0x00	; 0
    2f7e:	4d bf       	out	0x3d, r20	; 61
    2f80:	5e bf       	out	0x3e, r21	; 62
    2f82:	6d b7       	in	r22, 0x3d	; 61
    2f84:	7e b7       	in	r23, 0x3e	; 62
    2f86:	6f 5f       	subi	r22, 0xFF	; 255
    2f88:	7f 4f       	sbci	r23, 0xFF	; 255
    2f8a:	ed b7       	in	r30, 0x3d	; 61
    2f8c:	fe b7       	in	r31, 0x3e	; 62
    2f8e:	81 82       	std	Z+1, r8	; 0x01
    2f90:	92 82       	std	Z+2, r9	; 0x02
    2f92:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2f94:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2f96:	fb 01       	movw	r30, r22
    2f98:	42 83       	std	Z+2, r20	; 0x02
    2f9a:	53 83       	std	Z+3, r21	; 0x03
    2f9c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2f9e:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2fa0:	44 83       	std	Z+4, r20	; 0x04
    2fa2:	55 83       	std	Z+5, r21	; 0x05
    2fa4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2fa6:	86 83       	std	Z+6, r24	; 0x06
    2fa8:	84 ec       	ldi	r24, 0xC4	; 196
    2faa:	bd 01       	movw	r22, r26
    2fac:	a3 01       	movw	r20, r6
    2fae:	29 2f       	mov	r18, r25
    2fb0:	03 2f       	mov	r16, r19
    2fb2:	72 01       	movw	r14, r4
    2fb4:	61 01       	movw	r12, r2
    2fb6:	a9 80       	ldd	r10, Y+1	; 0x01
    2fb8:	ba 80       	ldd	r11, Y+2	; 0x02
    2fba:	8b 80       	ldd	r8, Y+3	; 0x03
    2fbc:	9c 80       	ldd	r9, Y+4	; 0x04
    2fbe:	0e 94 ae 16 	call	0x2d5c	; 0x2d5c <CO_collectSeismic3Axises_ext>
    2fc2:	4d b7       	in	r20, 0x3d	; 61
    2fc4:	5e b7       	in	r21, 0x3e	; 62
    2fc6:	49 5f       	subi	r20, 0xF9	; 249
    2fc8:	5f 4f       	sbci	r21, 0xFF	; 255
    2fca:	4d bf       	out	0x3d, r20	; 61
    2fcc:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    2fce:	24 96       	adiw	r28, 0x04	; 4
    2fd0:	cd bf       	out	0x3d, r28	; 61
    2fd2:	de bf       	out	0x3e, r29	; 62
    2fd4:	df 91       	pop	r29
    2fd6:	cf 91       	pop	r28
    2fd8:	1f 91       	pop	r17
    2fda:	0f 91       	pop	r16
    2fdc:	ff 90       	pop	r15
    2fde:	ef 90       	pop	r14
    2fe0:	df 90       	pop	r13
    2fe2:	cf 90       	pop	r12
    2fe4:	bf 90       	pop	r11
    2fe6:	af 90       	pop	r10
    2fe8:	9f 90       	pop	r9
    2fea:	8f 90       	pop	r8
    2fec:	7f 90       	pop	r7
    2fee:	6f 90       	pop	r6
    2ff0:	5f 90       	pop	r5
    2ff2:	4f 90       	pop	r4
    2ff4:	3f 90       	pop	r3
    2ff6:	2f 90       	pop	r2
    2ff8:	08 95       	ret

00002ffa <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2ffa:	6f 92       	push	r6
    2ffc:	7f 92       	push	r7
    2ffe:	8f 92       	push	r8
    3000:	9f 92       	push	r9
    3002:	af 92       	push	r10
    3004:	bf 92       	push	r11
    3006:	cf 92       	push	r12
    3008:	df 92       	push	r13
    300a:	ef 92       	push	r14
    300c:	ff 92       	push	r15
    300e:	0f 93       	push	r16
    3010:	1f 93       	push	r17
    3012:	cf 93       	push	r28
    3014:	df 93       	push	r29
    3016:	c8 2f       	mov	r28, r24
    3018:	b6 2e       	mov	r11, r22
    301a:	d4 2f       	mov	r29, r20
    301c:	49 01       	movw	r8, r18
    301e:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    3020:	e0 92 63 50 	sts	0x5063, r14
    3024:	f0 92 64 50 	sts	0x5064, r15
	ADC_Sampling_Finished = 0;
    3028:	10 92 a6 50 	sts	0x50A6, r1
	ADC_buffer_size = BufferSize;
    302c:	c0 92 a7 50 	sts	0x50A7, r12
    3030:	d0 92 a8 50 	sts	0x50A8, r13
	if(use_FRAM){
    3034:	aa 20       	and	r10, r10
    3036:	21 f0       	breq	.+8      	; 0x3040 <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	80 93 48 40 	sts	0x4048, r24
    303e:	02 c0       	rjmp	.+4      	; 0x3044 <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    3040:	10 92 48 40 	sts	0x4048, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    3044:	81 e0       	ldi	r24, 0x01	; 1
    3046:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    304a:	8c 2f       	mov	r24, r28
    304c:	6d 2f       	mov	r22, r29
    304e:	0e 94 9e 0b 	call	0x173c	; 0x173c <set_ampGain>
	set_filter(filterConfig);
    3052:	8b 2d       	mov	r24, r11
    3054:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    3058:	8c 2f       	mov	r24, r28
    305a:	85 50       	subi	r24, 0x05	; 5
    305c:	83 30       	cpi	r24, 0x03	; 3
    305e:	18 f4       	brcc	.+6      	; 0x3066 <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    3060:	81 e0       	ldi	r24, 0x01	; 1
    3062:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    3066:	81 e0       	ldi	r24, 0x01	; 1
    3068:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <enableADCMUX>
	setADCInput(channel);
    306c:	8c 2f       	mov	r24, r28
    306e:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    3072:	84 e0       	ldi	r24, 0x04	; 4
    3074:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    3078:	84 e5       	ldi	r24, 0x54	; 84
    307a:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    307e:	e0 ea       	ldi	r30, 0xA0	; 160
    3080:	f6 e0       	ldi	r31, 0x06	; 6
    3082:	ee 24       	eor	r14, r14
    3084:	e3 94       	inc	r14
    3086:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3088:	82 e0       	ldi	r24, 0x02	; 2
    308a:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    308c:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    308e:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    3090:	80 e2       	ldi	r24, 0x20	; 32
    3092:	e0 e8       	ldi	r30, 0x80	; 128
    3094:	f6 e0       	ldi	r31, 0x06	; 6
    3096:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    3098:	c0 e4       	ldi	r28, 0x40	; 64
    309a:	da e0       	ldi	r29, 0x0A	; 10
    309c:	83 e2       	ldi	r24, 0x23	; 35
    309e:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    30a0:	94 01       	movw	r18, r8
    30a2:	40 e0       	ldi	r20, 0x00	; 0
    30a4:	50 e0       	ldi	r21, 0x00	; 0
    30a6:	60 e8       	ldi	r22, 0x80	; 128
    30a8:	74 e8       	ldi	r23, 0x84	; 132
    30aa:	8e e1       	ldi	r24, 0x1E	; 30
    30ac:	90 e0       	ldi	r25, 0x00	; 0
    30ae:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    30b2:	89 01       	movw	r16, r18
    30b4:	9a 01       	movw	r18, r20
    30b6:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    30b8:	0e a3       	lds	r16, 0x5e
    30ba:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    30bc:	96 95       	lsr	r25
    30be:	87 95       	ror	r24
    30c0:	8a af       	sts	0x7a, r24
    30c2:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    30c4:	e0 e4       	ldi	r30, 0x40	; 64
    30c6:	f8 e0       	ldi	r31, 0x08	; 8
    30c8:	66 a2       	lds	r22, 0x96
    30ca:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    30cc:	88 e7       	ldi	r24, 0x78	; 120
    30ce:	a0 e8       	ldi	r26, 0x80	; 128
    30d0:	b1 e0       	ldi	r27, 0x01	; 1
    30d2:	11 96       	adiw	r26, 0x01	; 1
    30d4:	8c 93       	st	X, r24
    30d6:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    30d8:	e6 82       	std	Z+6, r14	; 0x06
	//reset count to zero
	TCC1.CTRLA = 0x00;
    30da:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    30dc:	8c e0       	ldi	r24, 0x0C	; 12
    30de:	81 87       	std	Z+9, r24	; 0x09
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    30e0:	88 81       	ld	r24, Y
    30e2:	80 7f       	andi	r24, 0xF0	; 240
    30e4:	81 60       	ori	r24, 0x01	; 1
    30e6:	88 83       	st	Y, r24
	
	sampleCount = 0;
    30e8:	10 92 65 50 	sts	0x5065, r1
    30ec:	10 92 66 50 	sts	0x5066, r1
    30f0:	10 92 67 50 	sts	0x5067, r1
    30f4:	10 92 68 50 	sts	0x5068, r1
	discardCount = 0;
    30f8:	10 92 5c 40 	sts	0x405C, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    30fc:	e0 ea       	ldi	r30, 0xA0	; 160
    30fe:	f0 e0       	ldi	r31, 0x00	; 0
    3100:	82 81       	ldd	r24, Z+2	; 0x02
    3102:	83 60       	ori	r24, 0x03	; 3
    3104:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3106:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    3108:	df 91       	pop	r29
    310a:	cf 91       	pop	r28
    310c:	1f 91       	pop	r17
    310e:	0f 91       	pop	r16
    3110:	ff 90       	pop	r15
    3112:	ef 90       	pop	r14
    3114:	df 90       	pop	r13
    3116:	cf 90       	pop	r12
    3118:	bf 90       	pop	r11
    311a:	af 90       	pop	r10
    311c:	9f 90       	pop	r9
    311e:	8f 90       	pop	r8
    3120:	7f 90       	pop	r7
    3122:	6f 90       	pop	r6
    3124:	08 95       	ret

00003126 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    3126:	8f 92       	push	r8
    3128:	9f 92       	push	r9
    312a:	af 92       	push	r10
    312c:	cf 92       	push	r12
    312e:	df 92       	push	r13
    3130:	ef 92       	push	r14
    3132:	ff 92       	push	r15
    3134:	0f 93       	push	r16
    3136:	1f 93       	push	r17
    3138:	cf 93       	push	r28
    313a:	df 93       	push	r29
    313c:	96 2f       	mov	r25, r22
    313e:	fa 01       	movw	r30, r20
    3140:	d9 01       	movw	r26, r18
    3142:	e8 01       	movw	r28, r16
    3144:	47 01       	movw	r8, r14
    3146:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    3148:	61 ec       	ldi	r22, 0xC1	; 193
    314a:	49 2f       	mov	r20, r25
    314c:	9f 01       	movw	r18, r30
    314e:	8d 01       	movw	r16, r26
    3150:	7e 01       	movw	r14, r28
    3152:	64 01       	movw	r12, r8
    3154:	0e 94 fd 17 	call	0x2ffa	; 0x2ffa <CO_collectADC_ext>
}
    3158:	df 91       	pop	r29
    315a:	cf 91       	pop	r28
    315c:	1f 91       	pop	r17
    315e:	0f 91       	pop	r16
    3160:	ff 90       	pop	r15
    3162:	ef 90       	pop	r14
    3164:	df 90       	pop	r13
    3166:	cf 90       	pop	r12
    3168:	af 90       	pop	r10
    316a:	9f 90       	pop	r9
    316c:	8f 90       	pop	r8
    316e:	08 95       	ret

00003170 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3170:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3172:	81 e0       	ldi	r24, 0x01	; 1
    3174:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    3176:	84 81       	ldd	r24, Z+4	; 0x04
    3178:	95 81       	ldd	r25, Z+5	; 0x05
    317a:	86 1b       	sub	r24, r22
    317c:	91 09       	sbc	r25, r1

	return answer;
}
    317e:	08 95       	ret

00003180 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    3180:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3182:	81 e0       	ldi	r24, 0x01	; 1
    3184:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3186:	84 81       	ldd	r24, Z+4	; 0x04
    3188:	95 81       	ldd	r25, Z+5	; 0x05
    318a:	77 27       	eor	r23, r23
    318c:	67 fd       	sbrc	r22, 7
    318e:	70 95       	com	r23
    3190:	86 1b       	sub	r24, r22
    3192:	97 0b       	sbc	r25, r23

	return answer;
}
    3194:	08 95       	ret

00003196 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3196:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3198:	81 e0       	ldi	r24, 0x01	; 1
    319a:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    319c:	84 81       	ldd	r24, Z+4	; 0x04
    319e:	95 81       	ldd	r25, Z+5	; 0x05
}
    31a0:	08 95       	ret

000031a2 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    31a2:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    31a4:	81 e0       	ldi	r24, 0x01	; 1
    31a6:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    31a8:	84 81       	ldd	r24, Z+4	; 0x04
}
    31aa:	08 95       	ret

000031ac <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    31ac:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    31ae:	81 e0       	ldi	r24, 0x01	; 1
    31b0:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    31b2:	85 81       	ldd	r24, Z+5	; 0x05
}
    31b4:	08 95       	ret

000031b6 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    31b6:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    31b8:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    31ba:	14 82       	std	Z+4, r1	; 0x04
    31bc:	9a e2       	ldi	r25, 0x2A	; 42
    31be:	9a 95       	dec	r25
    31c0:	f1 f7       	brne	.-4      	; 0x31be <ADC_Wait_8MHz+0x8>
    31c2:	00 c0       	rjmp	.+0      	; 0x31c4 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    31c4:	84 83       	std	Z+4, r24	; 0x04
}
    31c6:	08 95       	ret

000031c8 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    31c8:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    31ca:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    31cc:	91 e0       	ldi	r25, 0x01	; 1
    31ce:	94 83       	std	Z+4, r25	; 0x04
    31d0:	95 e5       	ldi	r25, 0x55	; 85
    31d2:	9a 95       	dec	r25
    31d4:	f1 f7       	brne	.-4      	; 0x31d2 <ADC_Wait_32MHz+0xa>
    31d6:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    31d8:	84 83       	std	Z+4, r24	; 0x04
}
    31da:	08 95       	ret

000031dc <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    31dc:	ef 92       	push	r14
    31de:	ff 92       	push	r15
    31e0:	0f 93       	push	r16
    31e2:	1f 93       	push	r17
    31e4:	cf 93       	push	r28
    31e6:	df 93       	push	r29
    31e8:	eb 01       	movw	r28, r22
    if (oversampling)
    31ea:	44 23       	and	r20, r20
    31ec:	c9 f0       	breq	.+50     	; 0x3220 <ADC_Offset_Get_Unsigned+0x44>
    31ee:	04 e0       	ldi	r16, 0x04	; 4
    31f0:	10 e0       	ldi	r17, 0x00	; 0
    31f2:	ee 24       	eor	r14, r14
    31f4:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    31f6:	88 81       	ld	r24, Y
    31f8:	80 68       	ori	r24, 0x80	; 128
    31fa:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    31fc:	8b 81       	ldd	r24, Y+3	; 0x03
    31fe:	80 ff       	sbrs	r24, 0
    3200:	fd cf       	rjmp	.-6      	; 0x31fc <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3202:	ce 01       	movw	r24, r28
    3204:	60 e0       	ldi	r22, 0x00	; 0
    3206:	0e 94 b8 18 	call	0x3170	; 0x3170 <ADC_ResultCh_GetWord_Unsigned>
    320a:	e8 0e       	add	r14, r24
    320c:	f9 1e       	adc	r15, r25
    320e:	01 50       	subi	r16, 0x01	; 1
    3210:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3212:	89 f7       	brne	.-30     	; 0x31f6 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3214:	c7 01       	movw	r24, r14
    3216:	96 95       	lsr	r25
    3218:	87 95       	ror	r24
    321a:	96 95       	lsr	r25
    321c:	87 95       	ror	r24
    321e:	09 c0       	rjmp	.+18     	; 0x3232 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3220:	88 81       	ld	r24, Y
    3222:	80 68       	ori	r24, 0x80	; 128
    3224:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3226:	8b 81       	ldd	r24, Y+3	; 0x03
    3228:	80 ff       	sbrs	r24, 0
    322a:	fd cf       	rjmp	.-6      	; 0x3226 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    322c:	ce 01       	movw	r24, r28
    322e:	0e 94 cb 18 	call	0x3196	; 0x3196 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    3232:	df 91       	pop	r29
    3234:	cf 91       	pop	r28
    3236:	1f 91       	pop	r17
    3238:	0f 91       	pop	r16
    323a:	ff 90       	pop	r15
    323c:	ef 90       	pop	r14
    323e:	08 95       	ret

00003240 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3240:	ef 92       	push	r14
    3242:	ff 92       	push	r15
    3244:	0f 93       	push	r16
    3246:	1f 93       	push	r17
    3248:	cf 93       	push	r28
    324a:	df 93       	push	r29
    324c:	eb 01       	movw	r28, r22
    if (oversampling)
    324e:	44 23       	and	r20, r20
    3250:	e1 f0       	breq	.+56     	; 0x328a <ADC_Offset_Get_Signed+0x4a>
    3252:	04 e0       	ldi	r16, 0x04	; 4
    3254:	10 e0       	ldi	r17, 0x00	; 0
    3256:	ee 24       	eor	r14, r14
    3258:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    325a:	88 81       	ld	r24, Y
    325c:	80 68       	ori	r24, 0x80	; 128
    325e:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3260:	8b 81       	ldd	r24, Y+3	; 0x03
    3262:	80 ff       	sbrs	r24, 0
    3264:	fd cf       	rjmp	.-6      	; 0x3260 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3266:	ce 01       	movw	r24, r28
    3268:	60 e0       	ldi	r22, 0x00	; 0
    326a:	0e 94 c0 18 	call	0x3180	; 0x3180 <ADC_ResultCh_GetWord_Signed>
    326e:	e8 0e       	add	r14, r24
    3270:	f9 1e       	adc	r15, r25
    3272:	01 50       	subi	r16, 0x01	; 1
    3274:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3276:	89 f7       	brne	.-30     	; 0x325a <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3278:	c7 01       	movw	r24, r14
    327a:	99 23       	and	r25, r25
    327c:	0c f4       	brge	.+2      	; 0x3280 <ADC_Offset_Get_Signed+0x40>
    327e:	03 96       	adiw	r24, 0x03	; 3
    3280:	95 95       	asr	r25
    3282:	87 95       	ror	r24
    3284:	95 95       	asr	r25
    3286:	87 95       	ror	r24
    3288:	0a c0       	rjmp	.+20     	; 0x329e <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    328a:	88 81       	ld	r24, Y
    328c:	80 68       	ori	r24, 0x80	; 128
    328e:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3290:	8b 81       	ldd	r24, Y+3	; 0x03
    3292:	80 ff       	sbrs	r24, 0
    3294:	fd cf       	rjmp	.-6      	; 0x3290 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3296:	ce 01       	movw	r24, r28
    3298:	60 e0       	ldi	r22, 0x00	; 0
    329a:	0e 94 c0 18 	call	0x3180	; 0x3180 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    329e:	df 91       	pop	r29
    32a0:	cf 91       	pop	r28
    32a2:	1f 91       	pop	r17
    32a4:	0f 91       	pop	r16
    32a6:	ff 90       	pop	r15
    32a8:	ef 90       	pop	r14
    32aa:	08 95       	ret

000032ac <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    32ac:	aa ec       	ldi	r26, 0xCA	; 202
    32ae:	b1 e0       	ldi	r27, 0x01	; 1
    32b0:	92 e0       	ldi	r25, 0x02	; 2
    32b2:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    32b4:	e8 2f       	mov	r30, r24
    32b6:	f0 e0       	ldi	r31, 0x00	; 0
    32b8:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    32ba:	1c 92       	st	X, r1

	return result;
}
    32bc:	08 95       	ret

000032be <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    32be:	cf 93       	push	r28
    32c0:	df 93       	push	r29
    32c2:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    32c4:	82 e0       	ldi	r24, 0x02	; 2
    32c6:	c0 30       	cpi	r28, 0x00	; 0
    32c8:	d8 07       	cpc	r29, r24
    32ca:	59 f4       	brne	.+22     	; 0x32e2 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    32cc:	80 e2       	ldi	r24, 0x20	; 32
    32ce:	0e 94 56 19 	call	0x32ac	; 0x32ac <SP_ReadCalibrationByte>
    32d2:	c0 e0       	ldi	r28, 0x00	; 0
    32d4:	d2 e0       	ldi	r29, 0x02	; 2
    32d6:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    32d8:	81 e2       	ldi	r24, 0x21	; 33
    32da:	0e 94 56 19 	call	0x32ac	; 0x32ac <SP_ReadCalibrationByte>
    32de:	8d 87       	std	Y+13, r24	; 0x0d
    32e0:	08 c0       	rjmp	.+16     	; 0x32f2 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    32e2:	84 e2       	ldi	r24, 0x24	; 36
    32e4:	0e 94 56 19 	call	0x32ac	; 0x32ac <SP_ReadCalibrationByte>
    32e8:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    32ea:	85 e2       	ldi	r24, 0x25	; 37
    32ec:	0e 94 56 19 	call	0x32ac	; 0x32ac <SP_ReadCalibrationByte>
    32f0:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    32f2:	df 91       	pop	r29
    32f4:	cf 91       	pop	r28
    32f6:	08 95       	ret

000032f8 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    32f8:	84 e1       	ldi	r24, 0x14	; 20
    32fa:	e4 e1       	ldi	r30, 0x14	; 20
    32fc:	f1 e2       	ldi	r31, 0x21	; 33
    32fe:	df 01       	movw	r26, r30
    3300:	1d 92       	st	X+, r1
    3302:	8a 95       	dec	r24
    3304:	e9 f7       	brne	.-6      	; 0x3300 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    3306:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <chb_get_short_addr>
    330a:	80 93 14 21 	sts	0x2114, r24
    330e:	90 93 15 21 	sts	0x2115, r25
    chb_drvr_init();
    3312:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    3316:	08 95       	ret

00003318 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    3318:	e0 e8       	ldi	r30, 0x80	; 128
    331a:	f6 e0       	ldi	r31, 0x06	; 6
    331c:	84 e0       	ldi	r24, 0x04	; 4
    331e:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3320:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3322:	92 e0       	ldi	r25, 0x02	; 2
    3324:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3326:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3328:	83 e0       	ldi	r24, 0x03	; 3
    332a:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    332c:	e0 ea       	ldi	r30, 0xA0	; 160
    332e:	f0 e0       	ldi	r31, 0x00	; 0
    3330:	82 81       	ldd	r24, Z+2	; 0x02
    3332:	84 60       	ori	r24, 0x04	; 4
    3334:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3336:	78 94       	sei
}
    3338:	08 95       	ret

0000333a <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    333a:	84 e1       	ldi	r24, 0x14	; 20
    333c:	91 e2       	ldi	r25, 0x21	; 33
    333e:	08 95       	ret

00003340 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3340:	2f 92       	push	r2
    3342:	3f 92       	push	r3
    3344:	4f 92       	push	r4
    3346:	5f 92       	push	r5
    3348:	6f 92       	push	r6
    334a:	7f 92       	push	r7
    334c:	8f 92       	push	r8
    334e:	9f 92       	push	r9
    3350:	af 92       	push	r10
    3352:	bf 92       	push	r11
    3354:	cf 92       	push	r12
    3356:	df 92       	push	r13
    3358:	ef 92       	push	r14
    335a:	ff 92       	push	r15
    335c:	0f 93       	push	r16
    335e:	1f 93       	push	r17
    3360:	cf 93       	push	r28
    3362:	df 93       	push	r29
    3364:	cd b7       	in	r28, 0x3d	; 61
    3366:	de b7       	in	r29, 0x3e	; 62
    3368:	2a 97       	sbiw	r28, 0x0a	; 10
    336a:	cd bf       	out	0x3d, r28	; 61
    336c:	de bf       	out	0x3e, r29	; 62
    336e:	2c 01       	movw	r4, r24
    3370:	1b 01       	movw	r2, r22
    3372:	69 01       	movw	r12, r18
    3374:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3376:	21 15       	cp	r18, r1
    3378:	31 05       	cpc	r19, r1
    337a:	41 05       	cpc	r20, r1
    337c:	51 05       	cpc	r21, r1
    337e:	09 f4       	brne	.+2      	; 0x3382 <chb_write+0x42>
    3380:	77 c0       	rjmp	.+238    	; 0x3470 <chb_write+0x130>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    3382:	88 24       	eor	r8, r8
    3384:	99 24       	eor	r9, r9
    3386:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3388:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    338a:	0f 2e       	mov	r0, r31
    338c:	f6 e1       	ldi	r31, 0x16	; 22
    338e:	6f 2e       	mov	r6, r31
    3390:	f1 e2       	ldi	r31, 0x21	; 33
    3392:	7f 2e       	mov	r7, r31
    3394:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3396:	1c 2d       	mov	r17, r12
    3398:	25 e6       	ldi	r18, 0x65	; 101
    339a:	c2 16       	cp	r12, r18
    339c:	d1 04       	cpc	r13, r1
    339e:	e1 04       	cpc	r14, r1
    33a0:	f1 04       	cpc	r15, r1
    33a2:	08 f0       	brcs	.+2      	; 0x33a6 <chb_write+0x66>
    33a4:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    33a6:	81 2f       	mov	r24, r17
    33a8:	85 5f       	subi	r24, 0xF5	; 245
    33aa:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    33ac:	3f ef       	ldi	r19, 0xFF	; 255
    33ae:	43 16       	cp	r4, r19
    33b0:	3f ef       	ldi	r19, 0xFF	; 255
    33b2:	53 06       	cpc	r5, r19
    33b4:	11 f0       	breq	.+4      	; 0x33ba <chb_write+0x7a>
    33b6:	81 e6       	ldi	r24, 0x61	; 97
    33b8:	01 c0       	rjmp	.+2      	; 0x33bc <chb_write+0x7c>
    33ba:	81 e4       	ldi	r24, 0x41	; 65
    33bc:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    33be:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    33c0:	f3 01       	movw	r30, r6
    33c2:	80 81       	ld	r24, Z
    33c4:	8c 83       	std	Y+4, r24	; 0x04
    33c6:	8f 5f       	subi	r24, 0xFF	; 255
    33c8:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    33ca:	24 e3       	ldi	r18, 0x34	; 52
    33cc:	32 e1       	ldi	r19, 0x12	; 18
    33ce:	2d 83       	std	Y+5, r18	; 0x05
    33d0:	3e 83       	std	Y+6, r19	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    33d2:	4f 82       	std	Y+7, r4	; 0x07
    33d4:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    33d6:	e4 e1       	ldi	r30, 0x14	; 20
    33d8:	f1 e2       	ldi	r31, 0x21	; 33
    33da:	80 81       	ld	r24, Z
    33dc:	91 81       	ldd	r25, Z+1	; 0x01
    33de:	89 87       	std	Y+9, r24	; 0x09
    33e0:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    33e2:	b1 01       	movw	r22, r2
    33e4:	68 0d       	add	r22, r8
    33e6:	79 1d       	adc	r23, r9
    33e8:	ce 01       	movw	r24, r28
    33ea:	01 96       	adiw	r24, 0x01	; 1
    33ec:	41 2f       	mov	r20, r17
    33ee:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <chb_tx>

             switch (status)
    33f2:	83 30       	cpi	r24, 0x03	; 3
    33f4:	c9 f0       	breq	.+50     	; 0x3428 <chb_write+0xe8>
    33f6:	84 30       	cpi	r24, 0x04	; 4
    33f8:	18 f4       	brcc	.+6      	; 0x3400 <chb_write+0xc0>
    33fa:	81 30       	cpi	r24, 0x01	; 1
    33fc:	e1 f4       	brne	.+56     	; 0x3436 <chb_write+0xf6>
    33fe:	04 c0       	rjmp	.+8      	; 0x3408 <chb_write+0xc8>
    3400:	85 30       	cpi	r24, 0x05	; 5
    3402:	51 f0       	breq	.+20     	; 0x3418 <chb_write+0xd8>
    3404:	80 34       	cpi	r24, 0x40	; 64
    3406:	b9 f4       	brne	.+46     	; 0x3436 <chb_write+0xf6>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3408:	eb e1       	ldi	r30, 0x1B	; 27
    340a:	f1 e2       	ldi	r31, 0x21	; 33
    340c:	80 81       	ld	r24, Z
    340e:	91 81       	ldd	r25, Z+1	; 0x01
    3410:	01 96       	adiw	r24, 0x01	; 1
    3412:	80 83       	st	Z, r24
    3414:	91 83       	std	Z+1, r25	; 0x01
                 break;
    3416:	0f c0       	rjmp	.+30     	; 0x3436 <chb_write+0xf6>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3418:	ed e1       	ldi	r30, 0x1D	; 29
    341a:	f1 e2       	ldi	r31, 0x21	; 33
    341c:	80 81       	ld	r24, Z
    341e:	91 81       	ldd	r25, Z+1	; 0x01
    3420:	01 96       	adiw	r24, 0x01	; 1
    3422:	80 83       	st	Z, r24
    3424:	91 83       	std	Z+1, r25	; 0x01
				 //rtry++;
                 break;
    3426:	07 c0       	rjmp	.+14     	; 0x3436 <chb_write+0xf6>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3428:	ef e1       	ldi	r30, 0x1F	; 31
    342a:	f1 e2       	ldi	r31, 0x21	; 33
    342c:	80 81       	ld	r24, Z
    342e:	91 81       	ldd	r25, Z+1	; 0x01
    3430:	01 96       	adiw	r24, 0x01	; 1
    3432:	80 83       	st	Z, r24
    3434:	91 83       	std	Z+1, r25	; 0x01
             }
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    3436:	81 2f       	mov	r24, r17
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	a0 e0       	ldi	r26, 0x00	; 0
    343c:	b0 e0       	ldi	r27, 0x00	; 0
    343e:	88 0e       	add	r8, r24
    3440:	99 1e       	adc	r9, r25
    3442:	aa 1e       	adc	r10, r26
    3444:	bb 1e       	adc	r11, r27
		if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
    3446:	f5 e6       	ldi	r31, 0x65	; 101
    3448:	cf 16       	cp	r12, r31
    344a:	d1 04       	cpc	r13, r1
    344c:	e1 04       	cpc	r14, r1
    344e:	f1 04       	cpc	r15, r1
    3450:	48 f0       	brcs	.+18     	; 0x3464 <chb_write+0x124>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3452:	2f ef       	ldi	r18, 0xFF	; 255
    3454:	33 ec       	ldi	r19, 0xC3	; 195
    3456:	49 e0       	ldi	r20, 0x09	; 9
    3458:	21 50       	subi	r18, 0x01	; 1
    345a:	30 40       	sbci	r19, 0x00	; 0
    345c:	40 40       	sbci	r20, 0x00	; 0
    345e:	e1 f7       	brne	.-8      	; 0x3458 <chb_write+0x118>
    3460:	00 c0       	rjmp	.+0      	; 0x3462 <chb_write+0x122>
    3462:	00 00       	nop
        len = len - frm_len;
    3464:	c8 1a       	sub	r12, r24
    3466:	d9 0a       	sbc	r13, r25
    3468:	ea 0a       	sbc	r14, r26
    346a:	fb 0a       	sbc	r15, r27
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    346c:	09 f0       	breq	.+2      	; 0x3470 <chb_write+0x130>
    346e:	93 cf       	rjmp	.-218    	; 0x3396 <chb_write+0x56>
		frm_offset += frm_len;
		if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
    return CHB_SUCCESS;
}
    3470:	80 e0       	ldi	r24, 0x00	; 0
    3472:	2a 96       	adiw	r28, 0x0a	; 10
    3474:	cd bf       	out	0x3d, r28	; 61
    3476:	de bf       	out	0x3e, r29	; 62
    3478:	df 91       	pop	r29
    347a:	cf 91       	pop	r28
    347c:	1f 91       	pop	r17
    347e:	0f 91       	pop	r16
    3480:	ff 90       	pop	r15
    3482:	ef 90       	pop	r14
    3484:	df 90       	pop	r13
    3486:	cf 90       	pop	r12
    3488:	bf 90       	pop	r11
    348a:	af 90       	pop	r10
    348c:	9f 90       	pop	r9
    348e:	8f 90       	pop	r8
    3490:	7f 90       	pop	r7
    3492:	6f 90       	pop	r6
    3494:	5f 90       	pop	r5
    3496:	4f 90       	pop	r4
    3498:	3f 90       	pop	r3
    349a:	2f 90       	pop	r2
    349c:	08 95       	ret

0000349e <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    349e:	df 92       	push	r13
    34a0:	ef 92       	push	r14
    34a2:	ff 92       	push	r15
    34a4:	0f 93       	push	r16
    34a6:	1f 93       	push	r17
    34a8:	cf 93       	push	r28
    34aa:	df 93       	push	r29
    34ac:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    34ae:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_buf_read>
    34b2:	d8 2e       	mov	r13, r24
    34b4:	88 23       	and	r24, r24
    34b6:	0c f4       	brge	.+2      	; 0x34ba <chb_read+0x1c>
    34b8:	46 c0       	rjmp	.+140    	; 0x3546 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    34ba:	f7 01       	movw	r30, r14
    34bc:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    34be:	88 23       	and	r24, r24
    34c0:	71 f0       	breq	.+28     	; 0x34de <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    34c2:	e7 01       	movw	r28, r14
    34c4:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    34c6:	87 01       	movw	r16, r14
    34c8:	09 5f       	subi	r16, 0xF9	; 249
    34ca:	1f 4f       	sbci	r17, 0xFF	; 255
    34cc:	81 50       	subi	r24, 0x01	; 1
    34ce:	08 0f       	add	r16, r24
    34d0:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    34d2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <chb_buf_read>
    34d6:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    34d8:	c0 17       	cp	r28, r16
    34da:	d1 07       	cpc	r29, r17
    34dc:	d1 f7       	brne	.-12     	; 0x34d2 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    34de:	f7 01       	movw	r30, r14
    34e0:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    34e2:	83 85       	ldd	r24, Z+11	; 0x0b
    34e4:	94 85       	ldd	r25, Z+12	; 0x0c
    34e6:	83 83       	std	Z+3, r24	; 0x03
    34e8:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    34ea:	85 85       	ldd	r24, Z+13	; 0x0d
    34ec:	96 85       	ldd	r25, Z+14	; 0x0e
    34ee:	81 83       	std	Z+1, r24	; 0x01
    34f0:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    34f2:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <chb_buf_get_len>
    34f6:	88 23       	and	r24, r24
    34f8:	11 f4       	brne	.+4      	; 0x34fe <chb_read+0x60>
    {
        pcb.data_rcv = false;
    34fa:	10 92 17 21 	sts	0x2117, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    34fe:	80 91 0a 20 	lds	r24, 0x200A
    3502:	c8 17       	cp	r28, r24
    3504:	51 f4       	brne	.+20     	; 0x351a <chb_read+0x7c>
    3506:	f7 01       	movw	r30, r14
    3508:	21 81       	ldd	r18, Z+1	; 0x01
    350a:	32 81       	ldd	r19, Z+2	; 0x02
    350c:	80 91 0b 20 	lds	r24, 0x200B
    3510:	90 91 0c 20 	lds	r25, 0x200C
    3514:	28 17       	cp	r18, r24
    3516:	39 07       	cpc	r19, r25
    3518:	c1 f0       	breq	.+48     	; 0x354a <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    351a:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    351e:	f7 01       	movw	r30, r14
    3520:	81 81       	ldd	r24, Z+1	; 0x01
    3522:	92 81       	ldd	r25, Z+2	; 0x02
    3524:	80 93 0b 20 	sts	0x200B, r24
    3528:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    352c:	b7 01       	movw	r22, r14
    352e:	61 5f       	subi	r22, 0xF1	; 241
    3530:	7f 4f       	sbci	r23, 0xFF	; 255
    3532:	4d 2d       	mov	r20, r13
    3534:	50 e0       	ldi	r21, 0x00	; 0
    3536:	49 50       	subi	r20, 0x09	; 9
    3538:	50 40       	sbci	r21, 0x00	; 0
    353a:	c7 01       	movw	r24, r14
    353c:	0e 94 6e 39 	call	0x72dc	; 0x72dc <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    3540:	8d 2d       	mov	r24, r13
    3542:	8b 50       	subi	r24, 0x0B	; 11
    3544:	03 c0       	rjmp	.+6      	; 0x354c <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    3546:	80 e0       	ldi	r24, 0x00	; 0
    3548:	01 c0       	rjmp	.+2      	; 0x354c <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    354a:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    354c:	df 91       	pop	r29
    354e:	cf 91       	pop	r28
    3550:	1f 91       	pop	r17
    3552:	0f 91       	pop	r16
    3554:	ff 90       	pop	r15
    3556:	ef 90       	pop	r14
    3558:	df 90       	pop	r13
    355a:	08 95       	ret

0000355c <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    355c:	10 92 28 21 	sts	0x2128, r1
    wr_ptr = 0;
    3560:	10 92 29 21 	sts	0x2129, r1
    len = 0;
    3564:	10 92 2a 21 	sts	0x212A, r1
}
    3568:	08 95       	ret

0000356a <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    356a:	20 91 29 21 	lds	r18, 0x2129
    356e:	30 e0       	ldi	r19, 0x00	; 0
    3570:	f9 01       	movw	r30, r18
    3572:	e5 5d       	subi	r30, 0xD5	; 213
    3574:	fe 4d       	sbci	r31, 0xDE	; 222
    3576:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    3578:	c9 01       	movw	r24, r18
    357a:	01 96       	adiw	r24, 0x01	; 1
    357c:	60 e8       	ldi	r22, 0x80	; 128
    357e:	70 e0       	ldi	r23, 0x00	; 0
    3580:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    3584:	80 93 29 21 	sts	0x2129, r24
    len++;
    3588:	80 91 2a 21 	lds	r24, 0x212A
    358c:	8f 5f       	subi	r24, 0xFF	; 255
    358e:	80 93 2a 21 	sts	0x212A, r24
}
    3592:	08 95       	ret

00003594 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    3594:	20 91 28 21 	lds	r18, 0x2128
    3598:	30 e0       	ldi	r19, 0x00	; 0
    359a:	f9 01       	movw	r30, r18
    359c:	e5 5d       	subi	r30, 0xD5	; 213
    359e:	fe 4d       	sbci	r31, 0xDE	; 222
    35a0:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    35a2:	2f 5f       	subi	r18, 0xFF	; 255
    35a4:	3f 4f       	sbci	r19, 0xFF	; 255
    35a6:	c9 01       	movw	r24, r18
    35a8:	60 e8       	ldi	r22, 0x80	; 128
    35aa:	70 e0       	ldi	r23, 0x00	; 0
    35ac:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    35b0:	80 93 28 21 	sts	0x2128, r24
    len--;
    35b4:	80 91 2a 21 	lds	r24, 0x212A
    35b8:	81 50       	subi	r24, 0x01	; 1
    35ba:	80 93 2a 21 	sts	0x212A, r24
    return data;
}
    35be:	84 2f       	mov	r24, r20
    35c0:	08 95       	ret

000035c2 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    35c2:	80 91 2a 21 	lds	r24, 0x212A
    35c6:	08 95       	ret

000035c8 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    35c8:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    35ca:	80 e0       	ldi	r24, 0x00	; 0
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	48 e0       	ldi	r20, 0x08	; 8
    35d0:	50 e0       	ldi	r21, 0x00	; 0
    35d2:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <chb_eeprom_read>
}
    35d6:	08 95       	ret

000035d8 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    35d8:	cf 93       	push	r28
    35da:	df 93       	push	r29
    35dc:	0f 92       	push	r0
    35de:	0f 92       	push	r0
    35e0:	cd b7       	in	r28, 0x3d	; 61
    35e2:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    35e4:	89 e0       	ldi	r24, 0x09	; 9
    35e6:	90 e0       	ldi	r25, 0x00	; 0
    35e8:	be 01       	movw	r22, r28
    35ea:	6f 5f       	subi	r22, 0xFF	; 255
    35ec:	7f 4f       	sbci	r23, 0xFF	; 255
    35ee:	42 e0       	ldi	r20, 0x02	; 2
    35f0:	50 e0       	ldi	r21, 0x00	; 0
    35f2:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <chb_eeprom_read>
    return *(U16 *)addr;
}
    35f6:	89 81       	ldd	r24, Y+1	; 0x01
    35f8:	9a 81       	ldd	r25, Y+2	; 0x02
    35fa:	0f 90       	pop	r0
    35fc:	0f 90       	pop	r0
    35fe:	df 91       	pop	r29
    3600:	cf 91       	pop	r28
    3602:	08 95       	ret

00003604 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    3604:	88 23       	and	r24, r24
    3606:	29 f0       	breq	.+10     	; 0x3612 <RadioCS+0xe>
    3608:	80 e1       	ldi	r24, 0x10	; 16
    360a:	e0 e6       	ldi	r30, 0x60	; 96
    360c:	f6 e0       	ldi	r31, 0x06	; 6
    360e:	86 83       	std	Z+6, r24	; 0x06
    3610:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    3612:	80 e1       	ldi	r24, 0x10	; 16
    3614:	e0 e6       	ldi	r30, 0x60	; 96
    3616:	f6 e0       	ldi	r31, 0x06	; 6
    3618:	85 83       	std	Z+5, r24	; 0x05
    361a:	08 95       	ret

0000361c <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    361c:	df 92       	push	r13
    361e:	ef 92       	push	r14
    3620:	ff 92       	push	r15
    3622:	0f 93       	push	r16
    3624:	1f 93       	push	r17
    3626:	cf 93       	push	r28
    3628:	df 93       	push	r29
    362a:	8c 01       	movw	r16, r24
    362c:	c6 2f       	mov	r28, r22
    362e:	7a 01       	movw	r14, r20
    3630:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    3632:	82 2f       	mov	r24, r18
    3634:	90 e0       	ldi	r25, 0x00	; 0
    3636:	86 0f       	add	r24, r22
    3638:	91 1d       	adc	r25, r1
    363a:	80 38       	cpi	r24, 0x80	; 128
    363c:	91 05       	cpc	r25, r1
    363e:	8c f5       	brge	.+98     	; 0x36a2 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3640:	8f b7       	in	r24, 0x3f	; 63
    3642:	80 93 57 40 	sts	0x4057, r24
    3646:	f8 94       	cli
    RadioCS(TRUE); 
    3648:	81 e0       	ldi	r24, 0x01	; 1
    364a:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    364e:	80 e6       	ldi	r24, 0x60	; 96
    3650:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3654:	cc 23       	and	r28, r28
    3656:	79 f0       	breq	.+30     	; 0x3676 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    3658:	c8 01       	movw	r24, r16
    365a:	01 96       	adiw	r24, 0x01	; 1
    365c:	c1 50       	subi	r28, 0x01	; 1
    365e:	9c 01       	movw	r18, r24
    3660:	2c 0f       	add	r18, r28
    3662:	31 1d       	adc	r19, r1
    3664:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    3666:	f8 01       	movw	r30, r16
    3668:	81 91       	ld	r24, Z+
    366a:	8f 01       	movw	r16, r30
    366c:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3670:	0c 17       	cp	r16, r28
    3672:	1d 07       	cpc	r17, r29
    3674:	c1 f7       	brne	.-16     	; 0x3666 <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3676:	dd 20       	and	r13, r13
    3678:	69 f0       	breq	.+26     	; 0x3694 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    367a:	e7 01       	movw	r28, r14
    367c:	21 96       	adiw	r28, 0x01	; 1
    367e:	da 94       	dec	r13
    3680:	cd 0d       	add	r28, r13
    3682:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    3684:	f7 01       	movw	r30, r14
    3686:	81 91       	ld	r24, Z+
    3688:	7f 01       	movw	r14, r30
    368a:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    368e:	ec 16       	cp	r14, r28
    3690:	fd 06       	cpc	r15, r29
    3692:	c1 f7       	brne	.-16     	; 0x3684 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    3694:	80 e0       	ldi	r24, 0x00	; 0
    3696:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>
    CHB_LEAVE_CRIT();
    369a:	80 91 57 40 	lds	r24, 0x4057
    369e:	8f bf       	out	0x3f, r24	; 63
    36a0:	78 94       	sei
}
    36a2:	df 91       	pop	r29
    36a4:	cf 91       	pop	r28
    36a6:	1f 91       	pop	r17
    36a8:	0f 91       	pop	r16
    36aa:	ff 90       	pop	r15
    36ac:	ef 90       	pop	r14
    36ae:	df 90       	pop	r13
    36b0:	08 95       	ret

000036b2 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    36b2:	cf 93       	push	r28
    36b4:	df 93       	push	r29
    36b6:	d8 2f       	mov	r29, r24
    36b8:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    36ba:	8f b7       	in	r24, 0x3f	; 63
    36bc:	80 93 57 40 	sts	0x4057, r24
    36c0:	f8 94       	cli
    RadioCS(TRUE);
    36c2:	81 e0       	ldi	r24, 0x01	; 1
    36c4:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    36c8:	8d 2f       	mov	r24, r29
    36ca:	80 6c       	ori	r24, 0xC0	; 192
    36cc:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    36d0:	8c 2f       	mov	r24, r28
    36d2:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>

    RadioCS(FALSE);
    36d6:	80 e0       	ldi	r24, 0x00	; 0
    36d8:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>
    CHB_LEAVE_CRIT();
    36dc:	80 91 57 40 	lds	r24, 0x4057
    36e0:	8f bf       	out	0x3f, r24	; 63
    36e2:	78 94       	sei
}
    36e4:	df 91       	pop	r29
    36e6:	cf 91       	pop	r28
    36e8:	08 95       	ret

000036ea <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    36ea:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    36ec:	85 e0       	ldi	r24, 0x05	; 5
    36ee:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <chb_reg_write>
}
    36f2:	08 95       	ret

000036f4 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    36f4:	0f 93       	push	r16
    36f6:	1f 93       	push	r17
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    36fe:	c6 2f       	mov	r28, r22
    3700:	d7 2f       	mov	r29, r23
    3702:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    3704:	69 91       	ld	r22, Y+
    3706:	81 2f       	mov	r24, r17
    3708:	80 0f       	add	r24, r16
    370a:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    370e:	1f 5f       	subi	r17, 0xFF	; 255
    3710:	18 30       	cpi	r17, 0x08	; 8
    3712:	c1 f7       	brne	.-16     	; 0x3704 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    3714:	df 91       	pop	r29
    3716:	cf 91       	pop	r28
    3718:	1f 91       	pop	r17
    371a:	0f 91       	pop	r16
    371c:	08 95       	ret

0000371e <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    371e:	cf 93       	push	r28
    3720:	df 93       	push	r29
    3722:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    3724:	80 e0       	ldi	r24, 0x00	; 0
    3726:	90 e0       	ldi	r25, 0x00	; 0
    3728:	be 01       	movw	r22, r28
    372a:	48 e0       	ldi	r20, 0x08	; 8
    372c:	50 e0       	ldi	r21, 0x00	; 0
    372e:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    3732:	84 e2       	ldi	r24, 0x24	; 36
    3734:	be 01       	movw	r22, r28
    3736:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <chb_reg_write64>
}
    373a:	df 91       	pop	r29
    373c:	cf 91       	pop	r28
    373e:	08 95       	ret

00003740 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3740:	cf 93       	push	r28
    3742:	df 93       	push	r29
    3744:	c8 2f       	mov	r28, r24
    3746:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    3748:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <chb_reg_write>
    374c:	8c 2f       	mov	r24, r28
    374e:	8f 5f       	subi	r24, 0xFF	; 255
    3750:	6d 2f       	mov	r22, r29
    3752:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <chb_reg_write>
    }
}
    3756:	df 91       	pop	r29
    3758:	cf 91       	pop	r28
    375a:	08 95       	ret

0000375c <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    375c:	0f 93       	push	r16
    375e:	1f 93       	push	r17
    3760:	cf 93       	push	r28
    3762:	df 93       	push	r29
    3764:	0f 92       	push	r0
    3766:	0f 92       	push	r0
    3768:	cd b7       	in	r28, 0x3d	; 61
    376a:	de b7       	in	r29, 0x3e	; 62
    376c:	89 83       	std	Y+1, r24	; 0x01
    376e:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3770:	0e 94 9d 19 	call	0x333a	; 0x333a <chb_get_pcb>
    3774:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    3776:	89 e0       	ldi	r24, 0x09	; 9
    3778:	90 e0       	ldi	r25, 0x00	; 0
    377a:	be 01       	movw	r22, r28
    377c:	6f 5f       	subi	r22, 0xFF	; 255
    377e:	7f 4f       	sbci	r23, 0xFF	; 255
    3780:	42 e0       	ldi	r20, 0x02	; 2
    3782:	50 e0       	ldi	r21, 0x00	; 0
    3784:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    3788:	69 81       	ldd	r22, Y+1	; 0x01
    378a:	7a 81       	ldd	r23, Y+2	; 0x02
    378c:	80 e2       	ldi	r24, 0x20	; 32
    378e:	0e 94 a0 1b 	call	0x3740	; 0x3740 <chb_reg_write16>
    pcb->src_addr = addr;
    3792:	89 81       	ldd	r24, Y+1	; 0x01
    3794:	9a 81       	ldd	r25, Y+2	; 0x02
    3796:	f8 01       	movw	r30, r16
    3798:	80 83       	st	Z, r24
    379a:	91 83       	std	Z+1, r25	; 0x01
}
    379c:	0f 90       	pop	r0
    379e:	0f 90       	pop	r0
    37a0:	df 91       	pop	r29
    37a2:	cf 91       	pop	r28
    37a4:	1f 91       	pop	r17
    37a6:	0f 91       	pop	r16
    37a8:	08 95       	ret

000037aa <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    37aa:	cf 93       	push	r28
    37ac:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    37ae:	8f b7       	in	r24, 0x3f	; 63
    37b0:	80 93 57 40 	sts	0x4057, r24
    37b4:	f8 94       	cli
    RadioCS(TRUE);
    37b6:	81 e0       	ldi	r24, 0x01	; 1
    37b8:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    37bc:	8c 2f       	mov	r24, r28
    37be:	80 68       	ori	r24, 0x80	; 128
    37c0:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    val = SPID_write(val);
    37c4:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    37c8:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    37ca:	80 e0       	ldi	r24, 0x00	; 0
    37cc:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>
    CHB_LEAVE_CRIT();
    37d0:	80 91 57 40 	lds	r24, 0x4057
    37d4:	8f bf       	out	0x3f, r24	; 63
    37d6:	78 94       	sei

    return val;
}
    37d8:	8c 2f       	mov	r24, r28
    37da:	cf 91       	pop	r28
    37dc:	08 95       	ret

000037de <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    37de:	81 e0       	ldi	r24, 0x01	; 1
    37e0:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
}
    37e4:	8f 71       	andi	r24, 0x1F	; 31
    37e6:	08 95       	ret

000037e8 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    37e8:	1f 93       	push	r17
    37ea:	cf 93       	push	r28
    37ec:	df 93       	push	r29
    37ee:	c8 2f       	mov	r28, r24
    37f0:	16 2f       	mov	r17, r22
    37f2:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    37f4:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    37f8:	6d 2f       	mov	r22, r29
    37fa:	60 95       	com	r22
    37fc:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    37fe:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3800:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    3802:	8c 2f       	mov	r24, r28
    3804:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <chb_reg_write>
}
    3808:	df 91       	pop	r29
    380a:	cf 91       	pop	r28
    380c:	1f 91       	pop	r17
    380e:	08 95       	ret

00003810 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3810:	cf 93       	push	r28
    3812:	df 93       	push	r29
    3814:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    3816:	80 91 64 06 	lds	r24, 0x0664
    381a:	81 fd       	sbrc	r24, 1
    381c:	4b c0       	rjmp	.+150    	; 0x38b4 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    381e:	0e 94 ef 1b 	call	0x37de	; 0x37de <chb_get_state>
    3822:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    3824:	81 51       	subi	r24, 0x11	; 17
    3826:	82 30       	cpi	r24, 0x02	; 2
    3828:	20 f0       	brcs	.+8      	; 0x3832 <chb_set_state+0x22>
    382a:	c1 30       	cpi	r28, 0x01	; 1
    382c:	11 f0       	breq	.+4      	; 0x3832 <chb_set_state+0x22>
    382e:	c2 30       	cpi	r28, 0x02	; 2
    3830:	21 f4       	brne	.+8      	; 0x383a <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    3832:	0e 94 ef 1b 	call	0x37de	; 0x37de <chb_get_state>
    3836:	8c 17       	cp	r24, r28
    3838:	e1 f3       	breq	.-8      	; 0x3832 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    383a:	d6 31       	cpi	r29, 0x16	; 22
    383c:	f9 f0       	breq	.+62     	; 0x387c <chb_set_state+0x6c>
    383e:	d9 31       	cpi	r29, 0x19	; 25
    3840:	89 f0       	breq	.+34     	; 0x3864 <chb_set_state+0x54>
    3842:	d8 30       	cpi	r29, 0x08	; 8
    3844:	31 f5       	brne	.+76     	; 0x3892 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    3846:	e4 e6       	ldi	r30, 0x64	; 100
    3848:	f6 e0       	ldi	r31, 0x06	; 6
    384a:	80 81       	ld	r24, Z
    384c:	8d 7f       	andi	r24, 0xFD	; 253
    384e:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3850:	82 e0       	ldi	r24, 0x02	; 2
    3852:	63 e0       	ldi	r22, 0x03	; 3
    3854:	4f e1       	ldi	r20, 0x1F	; 31
    3856:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    385a:	8a e0       	ldi	r24, 0x0A	; 10
    385c:	8a 95       	dec	r24
    385e:	f1 f7       	brne	.-4      	; 0x385c <chb_set_state+0x4c>
    3860:	00 c0       	rjmp	.+0      	; 0x3862 <chb_set_state+0x52>
    3862:	17 c0       	rjmp	.+46     	; 0x3892 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3864:	c6 31       	cpi	r28, 0x16	; 22
    3866:	a9 f4       	brne	.+42     	; 0x3892 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3868:	82 e0       	ldi	r24, 0x02	; 2
    386a:	69 e0       	ldi	r22, 0x09	; 9
    386c:	4f e1       	ldi	r20, 0x1F	; 31
    386e:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
    3872:	9a e0       	ldi	r25, 0x0A	; 10
    3874:	9a 95       	dec	r25
    3876:	f1 f7       	brne	.-4      	; 0x3874 <chb_set_state+0x64>
    3878:	00 c0       	rjmp	.+0      	; 0x387a <chb_set_state+0x6a>
    387a:	0b c0       	rjmp	.+22     	; 0x3892 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    387c:	c9 31       	cpi	r28, 0x19	; 25
    387e:	49 f4       	brne	.+18     	; 0x3892 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3880:	82 e0       	ldi	r24, 0x02	; 2
    3882:	69 e0       	ldi	r22, 0x09	; 9
    3884:	4f e1       	ldi	r20, 0x1F	; 31
    3886:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
    388a:	8a e0       	ldi	r24, 0x0A	; 10
    388c:	8a 95       	dec	r24
    388e:	f1 f7       	brne	.-4      	; 0x388c <chb_set_state+0x7c>
    3890:	00 c0       	rjmp	.+0      	; 0x3892 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3892:	82 e0       	ldi	r24, 0x02	; 2
    3894:	6d 2f       	mov	r22, r29
    3896:	4f e1       	ldi	r20, 0x1F	; 31
    3898:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
    389c:	8f e6       	ldi	r24, 0x6F	; 111
    389e:	93 e0       	ldi	r25, 0x03	; 3
    38a0:	01 97       	sbiw	r24, 0x01	; 1
    38a2:	f1 f7       	brne	.-4      	; 0x38a0 <chb_set_state+0x90>
    38a4:	00 c0       	rjmp	.+0      	; 0x38a6 <chb_set_state+0x96>
    38a6:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    38a8:	0e 94 ef 1b 	call	0x37de	; 0x37de <chb_get_state>
    38ac:	8d 17       	cp	r24, r29
    38ae:	21 f4       	brne	.+8      	; 0x38b8 <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    38b0:	80 e4       	ldi	r24, 0x40	; 64
    38b2:	03 c0       	rjmp	.+6      	; 0x38ba <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    38b4:	84 e4       	ldi	r24, 0x44	; 68
    38b6:	01 c0       	rjmp	.+2      	; 0x38ba <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    38b8:	83 e4       	ldi	r24, 0x43	; 67
}
    38ba:	df 91       	pop	r29
    38bc:	cf 91       	pop	r28
    38be:	08 95       	ret

000038c0 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    38c0:	88 23       	and	r24, r24
    38c2:	49 f0       	breq	.+18     	; 0x38d6 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    38c4:	88 e0       	ldi	r24, 0x08	; 8
    38c6:	0e 94 08 1c 	call	0x3810	; 0x3810 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    38ca:	e4 e6       	ldi	r30, 0x64	; 100
    38cc:	f6 e0       	ldi	r31, 0x06	; 6
    38ce:	80 81       	ld	r24, Z
    38d0:	82 60       	ori	r24, 0x02	; 2
    38d2:	80 83       	st	Z, r24
    38d4:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    38d6:	e4 e6       	ldi	r30, 0x64	; 100
    38d8:	f6 e0       	ldi	r31, 0x06	; 6
    38da:	80 81       	ld	r24, Z
    38dc:	8d 7f       	andi	r24, 0xFD	; 253
    38de:	80 83       	st	Z, r24
    38e0:	8f e7       	ldi	r24, 0x7F	; 127
    38e2:	97 e0       	ldi	r25, 0x07	; 7
    38e4:	01 97       	sbiw	r24, 0x01	; 1
    38e6:	f1 f7       	brne	.-4      	; 0x38e4 <chb_sleep+0x24>
    38e8:	00 c0       	rjmp	.+0      	; 0x38ea <chb_sleep+0x2a>
    38ea:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    38ec:	86 e1       	ldi	r24, 0x16	; 22
    38ee:	0e 94 08 1c 	call	0x3810	; 0x3810 <chb_set_state>
    38f2:	08 95       	ret

000038f4 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    38f4:	cf 92       	push	r12
    38f6:	df 92       	push	r13
    38f8:	ef 92       	push	r14
    38fa:	ff 92       	push	r15
    38fc:	0f 93       	push	r16
    38fe:	1f 93       	push	r17
    3900:	cf 93       	push	r28
    3902:	df 93       	push	r29
    3904:	7c 01       	movw	r14, r24
    3906:	6b 01       	movw	r12, r22
    3908:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    390a:	0e 94 ef 1b 	call	0x37de	; 0x37de <chb_get_state>
    390e:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3910:	0e 94 9d 19 	call	0x333a	; 0x333a <chb_get_pcb>
    3914:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3916:	12 30       	cpi	r17, 0x02	; 2
    3918:	f1 f0       	breq	.+60     	; 0x3956 <chb_tx+0x62>
    391a:	12 31       	cpi	r17, 0x12	; 18
    391c:	f1 f0       	breq	.+60     	; 0x395a <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    391e:	88 e0       	ldi	r24, 0x08	; 8
    3920:	0e 94 08 1c 	call	0x3810	; 0x3810 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    3924:	89 e1       	ldi	r24, 0x19	; 25
    3926:	0e 94 08 1c 	call	0x3810	; 0x3810 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    392a:	c7 01       	movw	r24, r14
    392c:	6a e0       	ldi	r22, 0x0A	; 10
    392e:	a6 01       	movw	r20, r12
    3930:	20 2f       	mov	r18, r16
    3932:	0e 94 0e 1b 	call	0x361c	; 0x361c <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3936:	82 e0       	ldi	r24, 0x02	; 2
    3938:	62 e0       	ldi	r22, 0x02	; 2
    393a:	4f e1       	ldi	r20, 0x1F	; 31
    393c:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3940:	8c 81       	ldd	r24, Y+4	; 0x04
    3942:	88 23       	and	r24, r24
    3944:	e9 f3       	breq	.-6      	; 0x3940 <chb_tx+0x4c>
    pcb->tx_end = false;
    3946:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3948:	82 e0       	ldi	r24, 0x02	; 2
    394a:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    394e:	82 95       	swap	r24
    3950:	86 95       	lsr	r24
    3952:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3954:	03 c0       	rjmp	.+6      	; 0x395c <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3956:	84 e4       	ldi	r24, 0x44	; 68
    3958:	01 c0       	rjmp	.+2      	; 0x395c <chb_tx+0x68>
    395a:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    395c:	df 91       	pop	r29
    395e:	cf 91       	pop	r28
    3960:	1f 91       	pop	r17
    3962:	0f 91       	pop	r16
    3964:	ff 90       	pop	r15
    3966:	ef 90       	pop	r14
    3968:	df 90       	pop	r13
    396a:	cf 90       	pop	r12
    396c:	08 95       	ret

0000396e <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    396e:	81 30       	cpi	r24, 0x01	; 1
    3970:	91 f0       	breq	.+36     	; 0x3996 <chb_set_mode+0x28>
    3972:	81 30       	cpi	r24, 0x01	; 1
    3974:	28 f0       	brcs	.+10     	; 0x3980 <chb_set_mode+0x12>
    3976:	82 30       	cpi	r24, 0x02	; 2
    3978:	c9 f0       	breq	.+50     	; 0x39ac <chb_set_mode+0x3e>
    397a:	83 30       	cpi	r24, 0x03	; 3
    397c:	61 f5       	brne	.+88     	; 0x39d6 <chb_set_mode+0x68>
    397e:	21 c0       	rjmp	.+66     	; 0x39c2 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3980:	8c e0       	ldi	r24, 0x0C	; 12
    3982:	68 e0       	ldi	r22, 0x08	; 8
    3984:	4f e3       	ldi	r20, 0x3F	; 63
    3986:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    398a:	86 e1       	ldi	r24, 0x16	; 22
    398c:	62 e0       	ldi	r22, 0x02	; 2
    398e:	43 e0       	ldi	r20, 0x03	; 3
    3990:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
        break;
    3994:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    3996:	8c e0       	ldi	r24, 0x0C	; 12
    3998:	6c e0       	ldi	r22, 0x0C	; 12
    399a:	4f e3       	ldi	r20, 0x3F	; 63
    399c:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    39a0:	86 e1       	ldi	r24, 0x16	; 22
    39a2:	62 e0       	ldi	r22, 0x02	; 2
    39a4:	43 e0       	ldi	r20, 0x03	; 3
    39a6:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
        break;
    39aa:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    39ac:	8c e0       	ldi	r24, 0x0C	; 12
    39ae:	6c e1       	ldi	r22, 0x1C	; 28
    39b0:	4f e3       	ldi	r20, 0x3F	; 63
    39b2:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    39b6:	86 e1       	ldi	r24, 0x16	; 22
    39b8:	62 e0       	ldi	r22, 0x02	; 2
    39ba:	43 e0       	ldi	r20, 0x03	; 3
    39bc:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
        break;
    39c0:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    39c2:	8c e0       	ldi	r24, 0x0C	; 12
    39c4:	60 e0       	ldi	r22, 0x00	; 0
    39c6:	4f e3       	ldi	r20, 0x3F	; 63
    39c8:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    39cc:	86 e1       	ldi	r24, 0x16	; 22
    39ce:	63 e0       	ldi	r22, 0x03	; 3
    39d0:	43 e0       	ldi	r20, 0x03	; 3
    39d2:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
    39d6:	08 95       	ret

000039d8 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    39d8:	cf 93       	push	r28
    39da:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    39dc:	88 e0       	ldi	r24, 0x08	; 8
    39de:	6c 2f       	mov	r22, r28
    39e0:	4f e1       	ldi	r20, 0x1F	; 31
    39e2:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    39e6:	0e 94 ef 1b 	call	0x37de	; 0x37de <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    39ea:	86 30       	cpi	r24, 0x06	; 6
    39ec:	11 f0       	breq	.+4      	; 0x39f2 <chb_set_channel+0x1a>
    39ee:	89 30       	cpi	r24, 0x09	; 9
    39f0:	31 f4       	brne	.+12     	; 0x39fe <chb_set_channel+0x26>
    39f2:	8f e6       	ldi	r24, 0x6F	; 111
    39f4:	93 e0       	ldi	r25, 0x03	; 3
    39f6:	01 97       	sbiw	r24, 0x01	; 1
    39f8:	f1 f7       	brne	.-4      	; 0x39f6 <chb_set_channel+0x1e>
    39fa:	00 c0       	rjmp	.+0      	; 0x39fc <chb_set_channel+0x24>
    39fc:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    39fe:	88 e0       	ldi	r24, 0x08	; 8
    3a00:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    3a04:	90 e0       	ldi	r25, 0x00	; 0
    3a06:	8f 71       	andi	r24, 0x1F	; 31
    3a08:	90 70       	andi	r25, 0x00	; 0
    3a0a:	6c 2f       	mov	r22, r28
    3a0c:	70 e0       	ldi	r23, 0x00	; 0
    3a0e:	86 17       	cp	r24, r22
    3a10:	97 07       	cpc	r25, r23
    3a12:	11 f4       	brne	.+4      	; 0x3a18 <chb_set_channel+0x40>
    3a14:	80 e4       	ldi	r24, 0x40	; 64
    3a16:	01 c0       	rjmp	.+2      	; 0x3a1a <chb_set_channel+0x42>
    3a18:	83 e4       	ldi	r24, 0x43	; 67
}
    3a1a:	cf 91       	pop	r28
    3a1c:	08 95       	ret

00003a1e <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3a1e:	cf 93       	push	r28
    3a20:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3a22:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    3a26:	8c 2b       	or	r24, r28
    3a28:	8f 5f       	subi	r24, 0xFF	; 255
    3a2a:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    }
    return val;
}
    3a2e:	80 e0       	ldi	r24, 0x00	; 0
    3a30:	90 e0       	ldi	r25, 0x00	; 0
    3a32:	cf 91       	pop	r28
    3a34:	08 95       	ret

00003a36 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3a36:	e4 e6       	ldi	r30, 0x64	; 100
    3a38:	f6 e0       	ldi	r31, 0x06	; 6
    3a3a:	80 81       	ld	r24, Z
    3a3c:	81 60       	ori	r24, 0x01	; 1
    3a3e:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3a40:	80 81       	ld	r24, Z
    3a42:	8d 7f       	andi	r24, 0xFD	; 253
    3a44:	80 83       	st	Z, r24
    3a46:	8f ed       	ldi	r24, 0xDF	; 223
    3a48:	9b e0       	ldi	r25, 0x0B	; 11
    3a4a:	01 97       	sbiw	r24, 0x01	; 1
    3a4c:	f1 f7       	brne	.-4      	; 0x3a4a <chb_reset+0x14>
    3a4e:	00 c0       	rjmp	.+0      	; 0x3a50 <chb_reset+0x1a>
    3a50:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3a52:	80 81       	ld	r24, Z
    3a54:	8e 7f       	andi	r24, 0xFE	; 254
    3a56:	80 83       	st	Z, r24
    3a58:	9a e0       	ldi	r25, 0x0A	; 10
    3a5a:	9a 95       	dec	r25
    3a5c:	f1 f7       	brne	.-4      	; 0x3a5a <chb_reset+0x24>
    3a5e:	00 c0       	rjmp	.+0      	; 0x3a60 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3a60:	80 81       	ld	r24, Z
    3a62:	81 60       	ori	r24, 0x01	; 1
    3a64:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3a66:	8d e1       	ldi	r24, 0x1D	; 29
    3a68:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    3a6c:	81 30       	cpi	r24, 0x01	; 1
    3a6e:	d9 f7       	brne	.-10     	; 0x3a66 <chb_reset+0x30>
    3a70:	8c e1       	ldi	r24, 0x1C	; 28
    3a72:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    3a76:	87 30       	cpi	r24, 0x07	; 7
    3a78:	b1 f7       	brne	.-20     	; 0x3a66 <chb_reset+0x30>
            break;
        }
    }
	

}
    3a7a:	08 95       	ret

00003a7c <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3a7c:	0f 93       	push	r16
    3a7e:	1f 93       	push	r17
    3a80:	cf 93       	push	r28
    3a82:	df 93       	push	r29
    3a84:	cd b7       	in	r28, 0x3d	; 61
    3a86:	de b7       	in	r29, 0x3e	; 62
    3a88:	ea 97       	sbiw	r28, 0x3a	; 58
    3a8a:	cd bf       	out	0x3d, r28	; 61
    3a8c:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3a8e:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3a92:	e0 e6       	ldi	r30, 0x60	; 96
    3a94:	f6 e0       	ldi	r31, 0x06	; 6
    3a96:	80 81       	ld	r24, Z
    3a98:	82 60       	ori	r24, 0x02	; 2
    3a9a:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3a9c:	80 81       	ld	r24, Z
    3a9e:	81 60       	ori	r24, 0x01	; 1
    3aa0:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    3aa2:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    3aa6:	8e e0       	ldi	r24, 0x0E	; 14
    3aa8:	60 e0       	ldi	r22, 0x00	; 0
    3aaa:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3aae:	82 e0       	ldi	r24, 0x02	; 2
    3ab0:	63 e0       	ldi	r22, 0x03	; 3
    3ab2:	4f e1       	ldi	r20, 0x1F	; 31
    3ab4:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    3ab8:	81 e0       	ldi	r24, 0x01	; 1
    3aba:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    3abe:	8f 71       	andi	r24, 0x1F	; 31
    3ac0:	88 30       	cpi	r24, 0x08	; 8
    3ac2:	d1 f7       	brne	.-12     	; 0x3ab8 <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    3ac4:	8e e2       	ldi	r24, 0x2E	; 46
    3ac6:	60 e4       	ldi	r22, 0x40	; 64
    3ac8:	40 ec       	ldi	r20, 0xC0	; 192
    3aca:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3ace:	8e e0       	ldi	r24, 0x0E	; 14
    3ad0:	6c e0       	ldi	r22, 0x0C	; 12
    3ad2:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    3ad6:	84 e0       	ldi	r24, 0x04	; 4
    3ad8:	60 e2       	ldi	r22, 0x20	; 32
    3ada:	40 e2       	ldi	r20, 0x20	; 32
    3adc:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3ae0:	81 e0       	ldi	r24, 0x01	; 1
    3ae2:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    3ae6:	81 e0       	ldi	r24, 0x01	; 1
    3ae8:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3aec:	86 e1       	ldi	r24, 0x16	; 22
    3aee:	0e 94 08 1c 	call	0x3810	; 0x3810 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3af2:	82 e2       	ldi	r24, 0x22	; 34
    3af4:	64 e3       	ldi	r22, 0x34	; 52
    3af6:	72 e1       	ldi	r23, 0x12	; 18
    3af8:	0e 94 a0 1b 	call	0x3740	; 0x3740 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3afc:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <chb_get_short_addr>
    3b00:	bc 01       	movw	r22, r24
    3b02:	80 e2       	ldi	r24, 0x20	; 32
    3b04:	0e 94 a0 1b 	call	0x3740	; 0x3740 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3b08:	ce 01       	movw	r24, r28
    3b0a:	01 96       	adiw	r24, 0x01	; 1
    3b0c:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3b10:	84 e2       	ldi	r24, 0x24	; 36
    3b12:	be 01       	movw	r22, r28
    3b14:	6f 5f       	subi	r22, 0xFF	; 255
    3b16:	7f 4f       	sbci	r23, 0xFF	; 255
    3b18:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3b1c:	e2 e7       	ldi	r30, 0x72	; 114
    3b1e:	f6 e0       	ldi	r31, 0x06	; 6
    3b20:	80 81       	ld	r24, Z
    3b22:	81 60       	ori	r24, 0x01	; 1
    3b24:	80 83       	st	Z, r24
    3b26:	e9 e6       	ldi	r30, 0x69	; 105
    3b28:	f6 e0       	ldi	r31, 0x06	; 6
    3b2a:	80 81       	ld	r24, Z
    3b2c:	83 60       	ori	r24, 0x03	; 3
    3b2e:	80 83       	st	Z, r24
    3b30:	ea e6       	ldi	r30, 0x6A	; 106
    3b32:	f6 e0       	ldi	r31, 0x06	; 6
    3b34:	80 81       	ld	r24, Z
    3b36:	84 60       	ori	r24, 0x04	; 4
    3b38:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3b3a:	e0 ea       	ldi	r30, 0xA0	; 160
    3b3c:	f0 e0       	ldi	r31, 0x00	; 0
    3b3e:	82 81       	ldd	r24, Z+2	; 0x02
    3b40:	87 60       	ori	r24, 0x07	; 7
    3b42:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3b44:	0e 94 ef 1b 	call	0x37de	; 0x37de <chb_get_state>
    3b48:	86 31       	cpi	r24, 0x16	; 22
    3b4a:	91 f0       	breq	.+36     	; 0x3b70 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3b4c:	8e 01       	movw	r16, r28
    3b4e:	07 5f       	subi	r16, 0xF7	; 247
    3b50:	1f 4f       	sbci	r17, 0xFF	; 255
    3b52:	c8 01       	movw	r24, r16
    3b54:	68 ee       	ldi	r22, 0xE8	; 232
    3b56:	71 e0       	ldi	r23, 0x01	; 1
    3b58:	0e 94 67 39 	call	0x72ce	; 0x72ce <strcpy_P>
        printf(buf);
    3b5c:	0f 92       	push	r0
    3b5e:	0f 92       	push	r0
    3b60:	ed b7       	in	r30, 0x3d	; 61
    3b62:	fe b7       	in	r31, 0x3e	; 62
    3b64:	01 83       	std	Z+1, r16	; 0x01
    3b66:	12 83       	std	Z+2, r17	; 0x02
    3b68:	0e 94 ac 39 	call	0x7358	; 0x7358 <printf>
    3b6c:	0f 90       	pop	r0
    3b6e:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3b70:	ea 96       	adiw	r28, 0x3a	; 58
    3b72:	cd bf       	out	0x3d, r28	; 61
    3b74:	de bf       	out	0x3e, r29	; 62
    3b76:	df 91       	pop	r29
    3b78:	cf 91       	pop	r28
    3b7a:	1f 91       	pop	r17
    3b7c:	0f 91       	pop	r16
    3b7e:	08 95       	ret

00003b80 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3b80:	1f 92       	push	r1
    3b82:	0f 92       	push	r0
    3b84:	0f b6       	in	r0, 0x3f	; 63
    3b86:	0f 92       	push	r0
    3b88:	0b b6       	in	r0, 0x3b	; 59
    3b8a:	0f 92       	push	r0
    3b8c:	11 24       	eor	r1, r1
    3b8e:	6f 92       	push	r6
    3b90:	7f 92       	push	r7
    3b92:	8f 92       	push	r8
    3b94:	9f 92       	push	r9
    3b96:	af 92       	push	r10
    3b98:	bf 92       	push	r11
    3b9a:	df 92       	push	r13
    3b9c:	ef 92       	push	r14
    3b9e:	ff 92       	push	r15
    3ba0:	0f 93       	push	r16
    3ba2:	1f 93       	push	r17
    3ba4:	2f 93       	push	r18
    3ba6:	3f 93       	push	r19
    3ba8:	4f 93       	push	r20
    3baa:	5f 93       	push	r21
    3bac:	6f 93       	push	r22
    3bae:	7f 93       	push	r23
    3bb0:	8f 93       	push	r24
    3bb2:	9f 93       	push	r25
    3bb4:	af 93       	push	r26
    3bb6:	bf 93       	push	r27
    3bb8:	ef 93       	push	r30
    3bba:	ff 93       	push	r31
    3bbc:	cf 93       	push	r28
    3bbe:	df 93       	push	r29
    3bc0:	cd b7       	in	r28, 0x3d	; 61
    3bc2:	de b7       	in	r29, 0x3e	; 62
    3bc4:	e2 97       	sbiw	r28, 0x32	; 50
    3bc6:	cd bf       	out	0x3d, r28	; 61
    3bc8:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3bca:	0e 94 9d 19 	call	0x333a	; 0x333a <chb_get_pcb>
    3bce:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    3bd0:	8f b7       	in	r24, 0x3f	; 63
    3bd2:	80 93 57 40 	sts	0x4057, r24
    3bd6:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3bd8:	81 e0       	ldi	r24, 0x01	; 1
    3bda:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3bde:	8f e8       	ldi	r24, 0x8F	; 143
    3be0:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    intp_src = SPID_write(0);
    3be4:	80 e0       	ldi	r24, 0x00	; 0
    3be6:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    3bea:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3bec:	80 e0       	ldi	r24, 0x00	; 0
    3bee:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>

    while (intp_src)
    3bf2:	11 23       	and	r17, r17
    3bf4:	09 f4       	brne	.+2      	; 0x3bf8 <__vector_64+0x78>
    3bf6:	ae c0       	rjmp	.+348    	; 0x3d54 <__vector_64+0x1d4>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3bf8:	aa 24       	eor	r10, r10
    3bfa:	bb 24       	eor	r11, r11
    3bfc:	68 94       	set
    3bfe:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3c00:	0f 2e       	mov	r0, r31
    3c02:	f8 e0       	ldi	r31, 0x08	; 8
    3c04:	8f 2e       	mov	r8, r31
    3c06:	f2 e0       	ldi	r31, 0x02	; 2
    3c08:	9f 2e       	mov	r9, r31
    3c0a:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3c0c:	12 ff       	sbrs	r17, 2
    3c0e:	02 c0       	rjmp	.+4      	; 0x3c14 <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3c10:	1b 7f       	andi	r17, 0xFB	; 251
    3c12:	9d c0       	rjmp	.+314    	; 0x3d4e <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3c14:	13 ff       	sbrs	r17, 3
    3c16:	82 c0       	rjmp	.+260    	; 0x3d1c <__vector_64+0x19c>
        {
            state = chb_get_state();
    3c18:	0e 94 ef 1b 	call	0x37de	; 0x37de <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3c1c:	86 30       	cpi	r24, 0x06	; 6
    3c1e:	29 f0       	breq	.+10     	; 0x3c2a <__vector_64+0xaa>
    3c20:	86 31       	cpi	r24, 0x16	; 22
    3c22:	19 f0       	breq	.+6      	; 0x3c2a <__vector_64+0xaa>
    3c24:	81 31       	cpi	r24, 0x11	; 17
    3c26:	09 f0       	breq	.+2      	; 0x3c2a <__vector_64+0xaa>
    3c28:	6f c0       	rjmp	.+222    	; 0x3d08 <__vector_64+0x188>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				//chb_set_state(CHB_TRX_OFF);
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3c2a:	87 e0       	ldi	r24, 0x07	; 7
    3c2c:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    3c30:	f7 01       	movw	r30, r14
    3c32:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3c34:	86 e0       	ldi	r24, 0x06	; 6
    3c36:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
    3c3a:	88 1f       	adc	r24, r24
    3c3c:	88 27       	eor	r24, r24
    3c3e:	88 1f       	adc	r24, r24
    3c40:	f7 01       	movw	r30, r14
    3c42:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3c44:	88 23       	and	r24, r24
    3c46:	09 f4       	brne	.+2      	; 0x3c4a <__vector_64+0xca>
    3c48:	62 c0       	rjmp	.+196    	; 0x3d0e <__vector_64+0x18e>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3c4a:	8f b7       	in	r24, 0x3f	; 63
    3c4c:	80 93 57 40 	sts	0x4057, r24
    3c50:	f8 94       	cli
    RadioCS(TRUE);
    3c52:	81 e0       	ldi	r24, 0x01	; 1
    3c54:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3c58:	80 e2       	ldi	r24, 0x20	; 32
    3c5a:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    len = SPID_write(0);
    3c5e:	80 e0       	ldi	r24, 0x00	; 0
    3c60:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
    3c64:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3c66:	83 50       	subi	r24, 0x03	; 3
    3c68:	8d 37       	cpi	r24, 0x7D	; 125
    3c6a:	f0 f5       	brcc	.+124    	; 0x3ce8 <__vector_64+0x168>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3c6c:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <chb_buf_get_len>
    3c70:	2d 2d       	mov	r18, r13
    3c72:	30 e0       	ldi	r19, 0x00	; 0
    3c74:	a5 01       	movw	r20, r10
    3c76:	48 1b       	sub	r20, r24
    3c78:	51 09       	sbc	r21, r1
    3c7a:	24 17       	cp	r18, r20
    3c7c:	35 07       	cpc	r19, r21
    3c7e:	7c f4       	brge	.+30     	; 0x3c9e <__vector_64+0x11e>
        {
            chb_buf_write(len);
    3c80:	8d 2d       	mov	r24, r13
    3c82:	0e 94 b5 1a 	call	0x356a	; 0x356a <chb_buf_write>
            
            for (i=0; i<len; i++)
    3c86:	dd 20       	and	r13, r13
    3c88:	79 f1       	breq	.+94     	; 0x3ce8 <__vector_64+0x168>
    3c8a:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3c8c:	80 e0       	ldi	r24, 0x00	; 0
    3c8e:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
                chb_buf_write(data);
    3c92:	0e 94 b5 1a 	call	0x356a	; 0x356a <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3c96:	0f 5f       	subi	r16, 0xFF	; 255
    3c98:	0d 15       	cp	r16, r13
    3c9a:	c1 f7       	brne	.-16     	; 0x3c8c <__vector_64+0x10c>
    3c9c:	25 c0       	rjmp	.+74     	; 0x3ce8 <__vector_64+0x168>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3c9e:	0e 94 9d 19 	call	0x333a	; 0x333a <chb_get_pcb>
    3ca2:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3ca4:	dd 20       	and	r13, r13
    3ca6:	39 f0       	breq	.+14     	; 0x3cb6 <__vector_64+0x136>
    3ca8:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3caa:	80 e0       	ldi	r24, 0x00	; 0
    3cac:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3cb0:	0f 5f       	subi	r16, 0xFF	; 255
    3cb2:	0d 15       	cp	r16, r13
    3cb4:	d1 f7       	brne	.-12     	; 0x3caa <__vector_64+0x12a>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3cb6:	f3 01       	movw	r30, r6
    3cb8:	85 85       	ldd	r24, Z+13	; 0x0d
    3cba:	96 85       	ldd	r25, Z+14	; 0x0e
    3cbc:	01 96       	adiw	r24, 0x01	; 1
    3cbe:	85 87       	std	Z+13, r24	; 0x0d
    3cc0:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3cc2:	ce 01       	movw	r24, r28
    3cc4:	01 96       	adiw	r24, 0x01	; 1
    3cc6:	b4 01       	movw	r22, r8
    3cc8:	0e 94 67 39 	call	0x72ce	; 0x72ce <strcpy_P>
            printf(buf);
    3ccc:	0f 92       	push	r0
    3cce:	0f 92       	push	r0
    3cd0:	41 e0       	ldi	r20, 0x01	; 1
    3cd2:	50 e0       	ldi	r21, 0x00	; 0
    3cd4:	4c 0f       	add	r20, r28
    3cd6:	5d 1f       	adc	r21, r29
    3cd8:	ed b7       	in	r30, 0x3d	; 61
    3cda:	fe b7       	in	r31, 0x3e	; 62
    3cdc:	41 83       	std	Z+1, r20	; 0x01
    3cde:	52 83       	std	Z+2, r21	; 0x02
    3ce0:	0e 94 ac 39 	call	0x7358	; 0x7358 <printf>
    3ce4:	0f 90       	pop	r0
    3ce6:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3ce8:	80 e0       	ldi	r24, 0x00	; 0
    3cea:	0e 94 02 1b 	call	0x3604	; 0x3604 <RadioCS>
    CHB_LEAVE_CRIT();
    3cee:	80 91 57 40 	lds	r24, 0x4057
    3cf2:	8f bf       	out	0x3f, r24	; 63
    3cf4:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3cf6:	f7 01       	movw	r30, r14
    3cf8:	85 81       	ldd	r24, Z+5	; 0x05
    3cfa:	96 81       	ldd	r25, Z+6	; 0x06
    3cfc:	01 96       	adiw	r24, 0x01	; 1
    3cfe:	85 83       	std	Z+5, r24	; 0x05
    3d00:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3d02:	81 e0       	ldi	r24, 0x01	; 1
    3d04:	83 83       	std	Z+3, r24	; 0x03
    3d06:	03 c0       	rjmp	.+6      	; 0x3d0e <__vector_64+0x18e>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    3d08:	81 e0       	ldi	r24, 0x01	; 1
    3d0a:	f7 01       	movw	r30, r14
    3d0c:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3d0e:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3d10:	86 e1       	ldi	r24, 0x16	; 22
    3d12:	0e 94 08 1c 	call	0x3810	; 0x3810 <chb_set_state>
    3d16:	80 34       	cpi	r24, 0x40	; 64
    3d18:	d9 f7       	brne	.-10     	; 0x3d10 <__vector_64+0x190>
    3d1a:	19 c0       	rjmp	.+50     	; 0x3d4e <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3d1c:	16 ff       	sbrs	r17, 6
    3d1e:	08 c0       	rjmp	.+16     	; 0x3d30 <__vector_64+0x1b0>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3d20:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3d22:	f7 01       	movw	r30, r14
    3d24:	87 85       	ldd	r24, Z+15	; 0x0f
    3d26:	90 89       	ldd	r25, Z+16	; 0x10
    3d28:	01 96       	adiw	r24, 0x01	; 1
    3d2a:	87 87       	std	Z+15, r24	; 0x0f
    3d2c:	90 8b       	std	Z+16, r25	; 0x10
    3d2e:	0f c0       	rjmp	.+30     	; 0x3d4e <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3d30:	11 ff       	sbrs	r17, 1
    3d32:	02 c0       	rjmp	.+4      	; 0x3d38 <__vector_64+0x1b8>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3d34:	1d 7f       	andi	r17, 0xFD	; 253
    3d36:	0b c0       	rjmp	.+22     	; 0x3d4e <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3d38:	10 ff       	sbrs	r17, 0
    3d3a:	02 c0       	rjmp	.+4      	; 0x3d40 <__vector_64+0x1c0>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3d3c:	1e 7f       	andi	r17, 0xFE	; 254
    3d3e:	07 c0       	rjmp	.+14     	; 0x3d4e <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3d40:	11 23       	and	r17, r17
    3d42:	2c f4       	brge	.+10     	; 0x3d4e <__vector_64+0x1ce>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3d44:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    3d46:	f7 01       	movw	r30, r14
    3d48:	81 89       	ldd	r24, Z+17	; 0x11
    3d4a:	8f 5f       	subi	r24, 0xFF	; 255
    3d4c:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3d4e:	11 23       	and	r17, r17
    3d50:	09 f0       	breq	.+2      	; 0x3d54 <__vector_64+0x1d4>
    3d52:	5c cf       	rjmp	.-328    	; 0x3c0c <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3d54:	80 91 57 40 	lds	r24, 0x4057
    3d58:	8f bf       	out	0x3f, r24	; 63
    3d5a:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3d5c:	8f e0       	ldi	r24, 0x0F	; 15
    3d5e:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <chb_reg_read>
}
    3d62:	e2 96       	adiw	r28, 0x32	; 50
    3d64:	cd bf       	out	0x3d, r28	; 61
    3d66:	de bf       	out	0x3e, r29	; 62
    3d68:	df 91       	pop	r29
    3d6a:	cf 91       	pop	r28
    3d6c:	ff 91       	pop	r31
    3d6e:	ef 91       	pop	r30
    3d70:	bf 91       	pop	r27
    3d72:	af 91       	pop	r26
    3d74:	9f 91       	pop	r25
    3d76:	8f 91       	pop	r24
    3d78:	7f 91       	pop	r23
    3d7a:	6f 91       	pop	r22
    3d7c:	5f 91       	pop	r21
    3d7e:	4f 91       	pop	r20
    3d80:	3f 91       	pop	r19
    3d82:	2f 91       	pop	r18
    3d84:	1f 91       	pop	r17
    3d86:	0f 91       	pop	r16
    3d88:	ff 90       	pop	r15
    3d8a:	ef 90       	pop	r14
    3d8c:	df 90       	pop	r13
    3d8e:	bf 90       	pop	r11
    3d90:	af 90       	pop	r10
    3d92:	9f 90       	pop	r9
    3d94:	8f 90       	pop	r8
    3d96:	7f 90       	pop	r7
    3d98:	6f 90       	pop	r6
    3d9a:	0f 90       	pop	r0
    3d9c:	0b be       	out	0x3b, r0	; 59
    3d9e:	0f 90       	pop	r0
    3da0:	0f be       	out	0x3f, r0	; 63
    3da2:	0f 90       	pop	r0
    3da4:	1f 90       	pop	r1
    3da6:	18 95       	reti

00003da8 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3da8:	0f 93       	push	r16
    3daa:	1f 93       	push	r17
    3dac:	cf 93       	push	r28
    3dae:	df 93       	push	r29
    3db0:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3db2:	e0 ec       	ldi	r30, 0xC0	; 192
    3db4:	f1 e0       	ldi	r31, 0x01	; 1
    3db6:	84 85       	ldd	r24, Z+12	; 0x0c
    3db8:	87 7f       	andi	r24, 0xF7	; 247
    3dba:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3dbc:	41 15       	cp	r20, r1
    3dbe:	51 05       	cpc	r21, r1
    3dc0:	09 f4       	brne	.+2      	; 0x3dc4 <chb_eeprom_write+0x1c>
    3dc2:	50 c0       	rjmp	.+160    	; 0x3e64 <chb_eeprom_write+0xbc>
    3dc4:	e0 e0       	ldi	r30, 0x00	; 0
    3dc6:	f0 e0       	ldi	r31, 0x00	; 0
    3dc8:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3dca:	a0 ec       	ldi	r26, 0xC0	; 192
    3dcc:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3dce:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3dd0:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3dd2:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3dd4:	cf 01       	movw	r24, r30
    3dd6:	80 0f       	add	r24, r16
    3dd8:	91 1f       	adc	r25, r17
    3dda:	e6 0f       	add	r30, r22
    3ddc:	f7 1f       	adc	r31, r23
    3dde:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3de0:	1f 96       	adiw	r26, 0x0f	; 15
    3de2:	ec 91       	ld	r30, X
    3de4:	1f 97       	sbiw	r26, 0x0f	; 15
    3de6:	ee 23       	and	r30, r30
    3de8:	dc f3       	brlt	.-10     	; 0x3de0 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3dea:	1f 96       	adiw	r26, 0x0f	; 15
    3dec:	ec 91       	ld	r30, X
    3dee:	1f 97       	sbiw	r26, 0x0f	; 15
    3df0:	e1 ff       	sbrs	r30, 1
    3df2:	11 c0       	rjmp	.+34     	; 0x3e16 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3df4:	1a 96       	adiw	r26, 0x0a	; 10
    3df6:	dc 93       	st	X, r29
    3df8:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3dfa:	ef 93       	push	r30
    3dfc:	ff 93       	push	r31
    3dfe:	0f 93       	push	r16
    3e00:	2f 93       	push	r18
    3e02:	eb ec       	ldi	r30, 0xCB	; 203
    3e04:	f1 e0       	ldi	r31, 0x01	; 1
    3e06:	08 ed       	ldi	r16, 0xD8	; 216
    3e08:	21 e0       	ldi	r18, 0x01	; 1
    3e0a:	04 bf       	out	0x34, r16	; 52
    3e0c:	20 83       	st	Z, r18
    3e0e:	2f 91       	pop	r18
    3e10:	0f 91       	pop	r16
    3e12:	ff 91       	pop	r31
    3e14:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3e16:	1a 96       	adiw	r26, 0x0a	; 10
    3e18:	cc 93       	st	X, r28
    3e1a:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3e1c:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3e1e:	89 2f       	mov	r24, r25
    3e20:	8f 71       	andi	r24, 0x1F	; 31
    3e22:	11 96       	adiw	r26, 0x01	; 1
    3e24:	8c 93       	st	X, r24
    3e26:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3e28:	12 96       	adiw	r26, 0x02	; 2
    3e2a:	1c 92       	st	X, r1
    3e2c:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3e2e:	14 96       	adiw	r26, 0x04	; 4
    3e30:	fc 93       	st	X, r31
    3e32:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3e34:	1a 96       	adiw	r26, 0x0a	; 10
    3e36:	3c 93       	st	X, r19
    3e38:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3e3a:	ef 93       	push	r30
    3e3c:	ff 93       	push	r31
    3e3e:	0f 93       	push	r16
    3e40:	2f 93       	push	r18
    3e42:	eb ec       	ldi	r30, 0xCB	; 203
    3e44:	f1 e0       	ldi	r31, 0x01	; 1
    3e46:	08 ed       	ldi	r16, 0xD8	; 216
    3e48:	21 e0       	ldi	r18, 0x01	; 1
    3e4a:	04 bf       	out	0x34, r16	; 52
    3e4c:	20 83       	st	Z, r18
    3e4e:	2f 91       	pop	r18
    3e50:	0f 91       	pop	r16
    3e52:	ff 91       	pop	r31
    3e54:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3e56:	2f 5f       	subi	r18, 0xFF	; 255
    3e58:	e2 2f       	mov	r30, r18
    3e5a:	f0 e0       	ldi	r31, 0x00	; 0
    3e5c:	e4 17       	cp	r30, r20
    3e5e:	f5 07       	cpc	r31, r21
    3e60:	08 f4       	brcc	.+2      	; 0x3e64 <chb_eeprom_write+0xbc>
    3e62:	b8 cf       	rjmp	.-144    	; 0x3dd4 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3e64:	df 91       	pop	r29
    3e66:	cf 91       	pop	r28
    3e68:	1f 91       	pop	r17
    3e6a:	0f 91       	pop	r16
    3e6c:	08 95       	ret

00003e6e <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3e6e:	1f 93       	push	r17
    3e70:	cf 93       	push	r28
    3e72:	df 93       	push	r29
    3e74:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3e76:	e0 ec       	ldi	r30, 0xC0	; 192
    3e78:	f1 e0       	ldi	r31, 0x01	; 1
    3e7a:	84 85       	ldd	r24, Z+12	; 0x0c
    3e7c:	87 7f       	andi	r24, 0xF7	; 247
    3e7e:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3e80:	41 15       	cp	r20, r1
    3e82:	51 05       	cpc	r21, r1
    3e84:	41 f1       	breq	.+80     	; 0x3ed6 <chb_eeprom_read+0x68>
    3e86:	80 e0       	ldi	r24, 0x00	; 0
    3e88:	90 e0       	ldi	r25, 0x00	; 0
    3e8a:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3e8c:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3e8e:	db 01       	movw	r26, r22
    3e90:	a8 0f       	add	r26, r24
    3e92:	b9 1f       	adc	r27, r25
    3e94:	82 0f       	add	r24, r18
    3e96:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3e98:	17 85       	ldd	r17, Z+15	; 0x0f
    3e9a:	11 23       	and	r17, r17
    3e9c:	ec f3       	brlt	.-6      	; 0x3e98 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3e9e:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3ea0:	89 2f       	mov	r24, r25
    3ea2:	8f 71       	andi	r24, 0x1F	; 31
    3ea4:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3ea6:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3ea8:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3eaa:	ef 93       	push	r30
    3eac:	ff 93       	push	r31
    3eae:	0f 93       	push	r16
    3eb0:	2f 93       	push	r18
    3eb2:	eb ec       	ldi	r30, 0xCB	; 203
    3eb4:	f1 e0       	ldi	r31, 0x01	; 1
    3eb6:	08 ed       	ldi	r16, 0xD8	; 216
    3eb8:	21 e0       	ldi	r18, 0x01	; 1
    3eba:	04 bf       	out	0x34, r16	; 52
    3ebc:	20 83       	st	Z, r18
    3ebe:	2f 91       	pop	r18
    3ec0:	0f 91       	pop	r16
    3ec2:	ff 91       	pop	r31
    3ec4:	ef 91       	pop	r30

    return NVM.DATA0;
    3ec6:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3ec8:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3eca:	cf 5f       	subi	r28, 0xFF	; 255
    3ecc:	8c 2f       	mov	r24, r28
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	84 17       	cp	r24, r20
    3ed2:	95 07       	cpc	r25, r21
    3ed4:	e0 f2       	brcs	.-72     	; 0x3e8e <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3ed6:	df 91       	pop	r29
    3ed8:	cf 91       	pop	r28
    3eda:	1f 91       	pop	r17
    3edc:	08 95       	ret

00003ede <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3ede:	e0 e6       	ldi	r30, 0x60	; 96
    3ee0:	f6 e0       	ldi	r31, 0x06	; 6
    3ee2:	80 81       	ld	r24, Z
    3ee4:	80 6b       	ori	r24, 0xB0	; 176
    3ee6:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3ee8:	e4 e6       	ldi	r30, 0x64	; 100
    3eea:	f6 e0       	ldi	r31, 0x06	; 6
    3eec:	80 81       	ld	r24, Z
    3eee:	80 61       	ori	r24, 0x10	; 16
    3ef0:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3ef2:	a0 ec       	ldi	r26, 0xC0	; 192
    3ef4:	b9 e0       	ldi	r27, 0x09	; 9
    3ef6:	8c 91       	ld	r24, X
    3ef8:	81 65       	ori	r24, 0x51	; 81
    3efa:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3efc:	80 81       	ld	r24, Z
    3efe:	80 61       	ori	r24, 0x10	; 16
    3f00:	80 83       	st	Z, r24
}
    3f02:	08 95       	ret

00003f04 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3f04:	e0 ec       	ldi	r30, 0xC0	; 192
    3f06:	f9 e0       	ldi	r31, 0x09	; 9
    3f08:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3f0a:	82 81       	ldd	r24, Z+2	; 0x02
    3f0c:	88 23       	and	r24, r24
    3f0e:	ec f7       	brge	.-6      	; 0x3f0a <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3f10:	e0 ec       	ldi	r30, 0xC0	; 192
    3f12:	f9 e0       	ldi	r31, 0x09	; 9
    3f14:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3f16:	08 95       	ret

00003f18 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3f18:	0f 93       	push	r16
    3f1a:	cf 93       	push	r28
    3f1c:	df 93       	push	r29
    3f1e:	0f 92       	push	r0
    3f20:	cd b7       	in	r28, 0x3d	; 61
    3f22:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    3f24:	2f b7       	in	r18, 0x3f	; 63
    3f26:	29 83       	std	Y+1, r18	; 0x01
    3f28:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3f2a:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3f2c:	fc 01       	movw	r30, r24
    3f2e:	08 ed       	ldi	r16, 0xD8	; 216
    3f30:	04 bf       	out	0x34, r16	; 52
    3f32:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    3f34:	89 81       	ldd	r24, Y+1	; 0x01
    3f36:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3f38:	0f 90       	pop	r0
    3f3a:	df 91       	pop	r29
    3f3c:	cf 91       	pop	r28
    3f3e:	0f 91       	pop	r16
    3f40:	08 95       	ret

00003f42 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    3f42:	66 23       	and	r22, r22
    3f44:	11 f0       	breq	.+4      	; 0x3f4a <CLKSYS_XOSC_Config+0x8>
    3f46:	90 e2       	ldi	r25, 0x20	; 32
    3f48:	01 c0       	rjmp	.+2      	; 0x3f4c <CLKSYS_XOSC_Config+0xa>
    3f4a:	90 e0       	ldi	r25, 0x00	; 0
    3f4c:	84 2b       	or	r24, r20
    3f4e:	89 2b       	or	r24, r25
    3f50:	e0 e5       	ldi	r30, 0x50	; 80
    3f52:	f0 e0       	ldi	r31, 0x00	; 0
    3f54:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3f56:	08 95       	ret

00003f58 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3f58:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3f5a:	86 2b       	or	r24, r22
    3f5c:	e0 e5       	ldi	r30, 0x50	; 80
    3f5e:	f0 e0       	ldi	r31, 0x00	; 0
    3f60:	85 83       	std	Z+5, r24	; 0x05
}
    3f62:	08 95       	ret

00003f64 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    3f64:	e0 e5       	ldi	r30, 0x50	; 80
    3f66:	f0 e0       	ldi	r31, 0x00	; 0
    3f68:	90 81       	ld	r25, Z
    3f6a:	28 2f       	mov	r18, r24
    3f6c:	20 95       	com	r18
    3f6e:	92 23       	and	r25, r18
    3f70:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    3f72:	90 81       	ld	r25, Z
	return clkEnabled;
}
    3f74:	89 23       	and	r24, r25
    3f76:	08 95       	ret

00003f78 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    3f78:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    3f7a:	81 e4       	ldi	r24, 0x41	; 65
    3f7c:	90 e0       	ldi	r25, 0x00	; 0
    3f7e:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <CCPWrite>
}
    3f82:	08 95       	ret

00003f84 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    3f84:	1f 93       	push	r17
    3f86:	cf 93       	push	r28
    3f88:	df 93       	push	r29
    3f8a:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    3f8c:	c0 e4       	ldi	r28, 0x40	; 64
    3f8e:	d0 e0       	ldi	r29, 0x00	; 0
    3f90:	68 81       	ld	r22, Y
    3f92:	68 7f       	andi	r22, 0xF8	; 248
    3f94:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    3f96:	80 e4       	ldi	r24, 0x40	; 64
    3f98:	90 e0       	ldi	r25, 0x00	; 0
    3f9a:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    3f9e:	88 81       	ld	r24, Y
	return clkCtrl;
}
    3fa0:	81 23       	and	r24, r17
    3fa2:	df 91       	pop	r29
    3fa4:	cf 91       	pop	r28
    3fa6:	1f 91       	pop	r17
    3fa8:	08 95       	ret

00003faa <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    3faa:	e0 e4       	ldi	r30, 0x40	; 64
    3fac:	f0 e0       	ldi	r31, 0x00	; 0
    3fae:	93 81       	ldd	r25, Z+3	; 0x03
    3fb0:	91 7f       	andi	r25, 0xF1	; 241
    3fb2:	91 60       	ori	r25, 0x01	; 1
    3fb4:	89 2b       	or	r24, r25
    3fb6:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    3fb8:	08 95       	ret

00003fba <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    3fba:	e0 e5       	ldi	r30, 0x50	; 80
    3fbc:	f0 e0       	ldi	r31, 0x00	; 0
    3fbe:	26 81       	ldd	r18, Z+6	; 0x06
    3fc0:	98 2f       	mov	r25, r24
    3fc2:	38 2f       	mov	r19, r24
    3fc4:	30 95       	com	r19
    3fc6:	23 23       	and	r18, r19
    3fc8:	66 23       	and	r22, r22
    3fca:	09 f4       	brne	.+2      	; 0x3fce <CLKSYS_AutoCalibration_Enable+0x14>
    3fcc:	90 e0       	ldi	r25, 0x00	; 0
    3fce:	92 2b       	or	r25, r18
    3fd0:	e0 e5       	ldi	r30, 0x50	; 80
    3fd2:	f0 e0       	ldi	r31, 0x00	; 0
    3fd4:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3fd6:	81 30       	cpi	r24, 0x01	; 1
    3fd8:	31 f4       	brne	.+12     	; 0x3fe6 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3fda:	e8 e6       	ldi	r30, 0x68	; 104
    3fdc:	f0 e0       	ldi	r31, 0x00	; 0
    3fde:	80 81       	ld	r24, Z
    3fe0:	81 60       	ori	r24, 0x01	; 1
    3fe2:	80 83       	st	Z, r24
    3fe4:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3fe6:	82 30       	cpi	r24, 0x02	; 2
    3fe8:	29 f4       	brne	.+10     	; 0x3ff4 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3fea:	e0 e6       	ldi	r30, 0x60	; 96
    3fec:	f0 e0       	ldi	r31, 0x00	; 0
    3fee:	80 81       	ld	r24, Z
    3ff0:	81 60       	ori	r24, 0x01	; 1
    3ff2:	80 83       	st	Z, r24
    3ff4:	08 95       	ret

00003ff6 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3ff6:	83 e5       	ldi	r24, 0x53	; 83
    3ff8:	90 e0       	ldi	r25, 0x00	; 0
    3ffa:	63 e0       	ldi	r22, 0x03	; 3
    3ffc:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <CCPWrite>
}
    4000:	08 95       	ret

00004002 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    4002:	82 e4       	ldi	r24, 0x42	; 66
    4004:	90 e0       	ldi	r25, 0x00	; 0
    4006:	61 e0       	ldi	r22, 0x01	; 1
    4008:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <CCPWrite>
}
    400c:	08 95       	ret

0000400e <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    400e:	cf 92       	push	r12
    4010:	df 92       	push	r13
    4012:	ef 92       	push	r14
    4014:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    4016:	20 91 69 50 	lds	r18, 0x5069
    401a:	30 91 6a 50 	lds	r19, 0x506A
    401e:	c0 90 4d 40 	lds	r12, 0x404D
    4022:	d0 90 4e 40 	lds	r13, 0x404E
    4026:	e0 90 4f 40 	lds	r14, 0x404F
    402a:	f0 90 50 40 	lds	r15, 0x4050
    402e:	62 50       	subi	r22, 0x02	; 2
    4030:	70 40       	sbci	r23, 0x00	; 0
    4032:	80 40       	sbci	r24, 0x00	; 0
    4034:	90 40       	sbci	r25, 0x00	; 0
    4036:	40 e0       	ldi	r20, 0x00	; 0
    4038:	50 e0       	ldi	r21, 0x00	; 0
    403a:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    403e:	dc 01       	movw	r26, r24
    4040:	cb 01       	movw	r24, r22
    4042:	c8 0e       	add	r12, r24
    4044:	d9 1e       	adc	r13, r25
    4046:	ea 1e       	adc	r14, r26
    4048:	fb 1e       	adc	r15, r27
}
    404a:	6c 2d       	mov	r22, r12
    404c:	7d 2d       	mov	r23, r13
    404e:	8e 2d       	mov	r24, r14
    4050:	9f 2d       	mov	r25, r15
    4052:	ff 90       	pop	r15
    4054:	ef 90       	pop	r14
    4056:	df 90       	pop	r13
    4058:	cf 90       	pop	r12
    405a:	08 95       	ret

0000405c <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    405c:	3f 92       	push	r3
    405e:	4f 92       	push	r4
    4060:	5f 92       	push	r5
    4062:	6f 92       	push	r6
    4064:	7f 92       	push	r7
    4066:	8f 92       	push	r8
    4068:	9f 92       	push	r9
    406a:	af 92       	push	r10
    406c:	bf 92       	push	r11
    406e:	cf 92       	push	r12
    4070:	df 92       	push	r13
    4072:	ef 92       	push	r14
    4074:	ff 92       	push	r15
    4076:	0f 93       	push	r16
    4078:	1f 93       	push	r17
    407a:	cf 93       	push	r28
    407c:	df 93       	push	r29
    407e:	00 d0       	rcall	.+0      	; 0x4080 <getSetNextCluster+0x24>
    4080:	0f 92       	push	r0
    4082:	cd b7       	in	r28, 0x3d	; 61
    4084:	de b7       	in	r29, 0x3e	; 62
    4086:	dc 01       	movw	r26, r24
    4088:	cb 01       	movw	r24, r22
    408a:	34 2e       	mov	r3, r20
    408c:	09 83       	std	Y+1, r16	; 0x01
    408e:	1a 83       	std	Y+2, r17	; 0x02
    4090:	2b 83       	std	Y+3, r18	; 0x03
    4092:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    4094:	80 90 6f 50 	lds	r8, 0x506F
    4098:	90 90 70 50 	lds	r9, 0x5070
    409c:	2c 01       	movw	r4, r24
    409e:	3d 01       	movw	r6, r26
    40a0:	44 0c       	add	r4, r4
    40a2:	55 1c       	adc	r5, r5
    40a4:	66 1c       	adc	r6, r6
    40a6:	77 1c       	adc	r7, r7
    40a8:	44 0c       	add	r4, r4
    40aa:	55 1c       	adc	r5, r5
    40ac:	66 1c       	adc	r6, r6
    40ae:	77 1c       	adc	r7, r7
    40b0:	20 91 55 40 	lds	r18, 0x4055
    40b4:	30 91 56 40 	lds	r19, 0x4056
    40b8:	aa 24       	eor	r10, r10
    40ba:	bb 24       	eor	r11, r11
    40bc:	80 91 6b 50 	lds	r24, 0x506B
    40c0:	90 91 6c 50 	lds	r25, 0x506C
    40c4:	a0 91 6d 50 	lds	r26, 0x506D
    40c8:	b0 91 6e 50 	lds	r27, 0x506E
    40cc:	88 0e       	add	r8, r24
    40ce:	99 1e       	adc	r9, r25
    40d0:	aa 1e       	adc	r10, r26
    40d2:	bb 1e       	adc	r11, r27
    40d4:	40 e0       	ldi	r20, 0x00	; 0
    40d6:	50 e0       	ldi	r21, 0x00	; 0
    40d8:	c3 01       	movw	r24, r6
    40da:	b2 01       	movw	r22, r4
    40dc:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    40e0:	69 01       	movw	r12, r18
    40e2:	7a 01       	movw	r14, r20
    40e4:	c8 0c       	add	r12, r8
    40e6:	d9 1c       	adc	r13, r9
    40e8:	ea 1c       	adc	r14, r10
    40ea:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    40ec:	00 91 55 40 	lds	r16, 0x4055
    40f0:	10 91 56 40 	lds	r17, 0x4056

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    40f4:	c7 01       	movw	r24, r14
    40f6:	b6 01       	movw	r22, r12
    40f8:	48 e4       	ldi	r20, 0x48	; 72
    40fa:	5e e3       	ldi	r21, 0x3E	; 62
    40fc:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    4100:	98 01       	movw	r18, r16
    4102:	40 e0       	ldi	r20, 0x00	; 0
    4104:	50 e0       	ldi	r21, 0x00	; 0
    4106:	c3 01       	movw	r24, r6
    4108:	b2 01       	movw	r22, r4
    410a:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    410e:	68 5b       	subi	r22, 0xB8	; 184
    4110:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    4112:	33 20       	and	r3, r3
    4114:	41 f4       	brne	.+16     	; 0x4126 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    4116:	db 01       	movw	r26, r22
    4118:	0d 91       	ld	r16, X+
    411a:	1d 91       	ld	r17, X+
    411c:	2d 91       	ld	r18, X+
    411e:	3c 91       	ld	r19, X
    4120:	13 97       	sbiw	r26, 0x03	; 3
    4122:	3f 70       	andi	r19, 0x0F	; 15
    4124:	14 c0       	rjmp	.+40     	; 0x414e <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4126:	89 81       	ldd	r24, Y+1	; 0x01
    4128:	9a 81       	ldd	r25, Y+2	; 0x02
    412a:	ab 81       	ldd	r26, Y+3	; 0x03
    412c:	bc 81       	ldd	r27, Y+4	; 0x04
    412e:	fb 01       	movw	r30, r22
    4130:	80 83       	st	Z, r24
    4132:	91 83       	std	Z+1, r25	; 0x01
    4134:	a2 83       	std	Z+2, r26	; 0x02
    4136:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    4138:	c7 01       	movw	r24, r14
    413a:	b6 01       	movw	r22, r12
    413c:	48 e4       	ldi	r20, 0x48	; 72
    413e:	5e e3       	ldi	r21, 0x3E	; 62
    4140:	20 e0       	ldi	r18, 0x00	; 0
    4142:	32 e0       	ldi	r19, 0x02	; 2
    4144:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <SD_write_block>

return (0);
    4148:	00 e0       	ldi	r16, 0x00	; 0
    414a:	10 e0       	ldi	r17, 0x00	; 0
    414c:	98 01       	movw	r18, r16
}
    414e:	60 2f       	mov	r22, r16
    4150:	71 2f       	mov	r23, r17
    4152:	82 2f       	mov	r24, r18
    4154:	93 2f       	mov	r25, r19
    4156:	24 96       	adiw	r28, 0x04	; 4
    4158:	cd bf       	out	0x3d, r28	; 61
    415a:	de bf       	out	0x3e, r29	; 62
    415c:	df 91       	pop	r29
    415e:	cf 91       	pop	r28
    4160:	1f 91       	pop	r17
    4162:	0f 91       	pop	r16
    4164:	ff 90       	pop	r15
    4166:	ef 90       	pop	r14
    4168:	df 90       	pop	r13
    416a:	cf 90       	pop	r12
    416c:	bf 90       	pop	r11
    416e:	af 90       	pop	r10
    4170:	9f 90       	pop	r9
    4172:	8f 90       	pop	r8
    4174:	7f 90       	pop	r7
    4176:	6f 90       	pop	r6
    4178:	5f 90       	pop	r5
    417a:	4f 90       	pop	r4
    417c:	3f 90       	pop	r3
    417e:	08 95       	ret

00004180 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    4180:	cf 92       	push	r12
    4182:	df 92       	push	r13
    4184:	ef 92       	push	r14
    4186:	ff 92       	push	r15
    4188:	0f 93       	push	r16
    418a:	1f 93       	push	r17
    418c:	cf 93       	push	r28
    418e:	c8 2f       	mov	r28, r24
    4190:	06 2f       	mov	r16, r22
    4192:	69 01       	movw	r12, r18
    4194:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4196:	80 91 6b 50 	lds	r24, 0x506B
    419a:	90 91 6c 50 	lds	r25, 0x506C
    419e:	a0 91 6d 50 	lds	r26, 0x506D
    41a2:	b0 91 6e 50 	lds	r27, 0x506E
    41a6:	bc 01       	movw	r22, r24
    41a8:	cd 01       	movw	r24, r26
    41aa:	6f 5f       	subi	r22, 0xFF	; 255
    41ac:	7f 4f       	sbci	r23, 0xFF	; 255
    41ae:	8f 4f       	sbci	r24, 0xFF	; 255
    41b0:	9f 4f       	sbci	r25, 0xFF	; 255
    41b2:	48 e4       	ldi	r20, 0x48	; 72
    41b4:	5e e3       	ldi	r21, 0x3E	; 62
    41b6:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    41ba:	80 91 48 3e 	lds	r24, 0x3E48
    41be:	90 91 49 3e 	lds	r25, 0x3E49
    41c2:	a0 91 4a 3e 	lds	r26, 0x3E4A
    41c6:	b0 91 4b 3e 	lds	r27, 0x3E4B
    41ca:	82 35       	cpi	r24, 0x52	; 82
    41cc:	22 e5       	ldi	r18, 0x52	; 82
    41ce:	92 07       	cpc	r25, r18
    41d0:	21 e6       	ldi	r18, 0x61	; 97
    41d2:	a2 07       	cpc	r26, r18
    41d4:	21 e4       	ldi	r18, 0x41	; 65
    41d6:	b2 07       	cpc	r27, r18
    41d8:	09 f0       	breq	.+2      	; 0x41dc <getSetFreeCluster+0x5c>
    41da:	63 c0       	rjmp	.+198    	; 0x42a2 <getSetFreeCluster+0x122>
    41dc:	80 91 2c 40 	lds	r24, 0x402C
    41e0:	90 91 2d 40 	lds	r25, 0x402D
    41e4:	a0 91 2e 40 	lds	r26, 0x402E
    41e8:	b0 91 2f 40 	lds	r27, 0x402F
    41ec:	82 37       	cpi	r24, 0x72	; 114
    41ee:	22 e7       	ldi	r18, 0x72	; 114
    41f0:	92 07       	cpc	r25, r18
    41f2:	21 e4       	ldi	r18, 0x41	; 65
    41f4:	a2 07       	cpc	r26, r18
    41f6:	21 e6       	ldi	r18, 0x61	; 97
    41f8:	b2 07       	cpc	r27, r18
    41fa:	09 f0       	breq	.+2      	; 0x41fe <getSetFreeCluster+0x7e>
    41fc:	56 c0       	rjmp	.+172    	; 0x42aa <getSetFreeCluster+0x12a>
    41fe:	80 91 44 40 	lds	r24, 0x4044
    4202:	90 91 45 40 	lds	r25, 0x4045
    4206:	a0 91 46 40 	lds	r26, 0x4046
    420a:	b0 91 47 40 	lds	r27, 0x4047
    420e:	80 30       	cpi	r24, 0x00	; 0
    4210:	20 e0       	ldi	r18, 0x00	; 0
    4212:	92 07       	cpc	r25, r18
    4214:	25 e5       	ldi	r18, 0x55	; 85
    4216:	a2 07       	cpc	r26, r18
    4218:	2a ea       	ldi	r18, 0xAA	; 170
    421a:	b2 07       	cpc	r27, r18
    421c:	09 f0       	breq	.+2      	; 0x4220 <getSetFreeCluster+0xa0>
    421e:	49 c0       	rjmp	.+146    	; 0x42b2 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4220:	00 23       	and	r16, r16
    4222:	a1 f4       	brne	.+40     	; 0x424c <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4224:	c1 30       	cpi	r28, 0x01	; 1
    4226:	49 f4       	brne	.+18     	; 0x423a <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    4228:	00 91 30 40 	lds	r16, 0x4030
    422c:	10 91 31 40 	lds	r17, 0x4031
    4230:	20 91 32 40 	lds	r18, 0x4032
    4234:	30 91 33 40 	lds	r19, 0x4033
    4238:	3f c0       	rjmp	.+126    	; 0x42b8 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    423a:	00 91 34 40 	lds	r16, 0x4034
    423e:	10 91 35 40 	lds	r17, 0x4035
    4242:	20 91 36 40 	lds	r18, 0x4036
    4246:	30 91 37 40 	lds	r19, 0x4037
    424a:	36 c0       	rjmp	.+108    	; 0x42b8 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    424c:	c1 30       	cpi	r28, 0x01	; 1
    424e:	49 f4       	brne	.+18     	; 0x4262 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    4250:	c0 92 30 40 	sts	0x4030, r12
    4254:	d0 92 31 40 	sts	0x4031, r13
    4258:	e0 92 32 40 	sts	0x4032, r14
    425c:	f0 92 33 40 	sts	0x4033, r15
    4260:	08 c0       	rjmp	.+16     	; 0x4272 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    4262:	c0 92 34 40 	sts	0x4034, r12
    4266:	d0 92 35 40 	sts	0x4035, r13
    426a:	e0 92 36 40 	sts	0x4036, r14
    426e:	f0 92 37 40 	sts	0x4037, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4272:	80 91 6b 50 	lds	r24, 0x506B
    4276:	90 91 6c 50 	lds	r25, 0x506C
    427a:	a0 91 6d 50 	lds	r26, 0x506D
    427e:	b0 91 6e 50 	lds	r27, 0x506E
    4282:	bc 01       	movw	r22, r24
    4284:	cd 01       	movw	r24, r26
    4286:	6f 5f       	subi	r22, 0xFF	; 255
    4288:	7f 4f       	sbci	r23, 0xFF	; 255
    428a:	8f 4f       	sbci	r24, 0xFF	; 255
    428c:	9f 4f       	sbci	r25, 0xFF	; 255
    428e:	48 e4       	ldi	r20, 0x48	; 72
    4290:	5e e3       	ldi	r21, 0x3E	; 62
    4292:	20 e0       	ldi	r18, 0x00	; 0
    4294:	32 e0       	ldi	r19, 0x02	; 2
    4296:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <SD_write_block>
 }
 return 0xffffffff;
    429a:	0f ef       	ldi	r16, 0xFF	; 255
    429c:	1f ef       	ldi	r17, 0xFF	; 255
    429e:	98 01       	movw	r18, r16
    42a0:	0b c0       	rjmp	.+22     	; 0x42b8 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    42a2:	0f ef       	ldi	r16, 0xFF	; 255
    42a4:	1f ef       	ldi	r17, 0xFF	; 255
    42a6:	98 01       	movw	r18, r16
    42a8:	07 c0       	rjmp	.+14     	; 0x42b8 <getSetFreeCluster+0x138>
    42aa:	0f ef       	ldi	r16, 0xFF	; 255
    42ac:	1f ef       	ldi	r17, 0xFF	; 255
    42ae:	98 01       	movw	r18, r16
    42b0:	03 c0       	rjmp	.+6      	; 0x42b8 <getSetFreeCluster+0x138>
    42b2:	0f ef       	ldi	r16, 0xFF	; 255
    42b4:	1f ef       	ldi	r17, 0xFF	; 255
    42b6:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    42b8:	60 2f       	mov	r22, r16
    42ba:	71 2f       	mov	r23, r17
    42bc:	82 2f       	mov	r24, r18
    42be:	93 2f       	mov	r25, r19
    42c0:	cf 91       	pop	r28
    42c2:	1f 91       	pop	r17
    42c4:	0f 91       	pop	r16
    42c6:	ff 90       	pop	r15
    42c8:	ef 90       	pop	r14
    42ca:	df 90       	pop	r13
    42cc:	cf 90       	pop	r12
    42ce:	08 95       	ret

000042d0 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    42d0:	ef 92       	push	r14
    42d2:	ff 92       	push	r15
    42d4:	0f 93       	push	r16
    42d6:	1f 93       	push	r17
    42d8:	cf 93       	push	r28
    42da:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    42dc:	10 92 6b 50 	sts	0x506B, r1
    42e0:	10 92 6c 50 	sts	0x506C, r1
    42e4:	10 92 6d 50 	sts	0x506D, r1
    42e8:	10 92 6e 50 	sts	0x506E, r1

SD_read_block(0,SDBuffer);
    42ec:	60 e0       	ldi	r22, 0x00	; 0
    42ee:	70 e0       	ldi	r23, 0x00	; 0
    42f0:	cb 01       	movw	r24, r22
    42f2:	48 e4       	ldi	r20, 0x48	; 72
    42f4:	5e e3       	ldi	r21, 0x3E	; 62
    42f6:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    42fa:	80 91 48 3e 	lds	r24, 0x3E48
    42fe:	89 3e       	cpi	r24, 0xE9	; 233
    4300:	31 f1       	breq	.+76     	; 0x434e <getBootSectorData+0x7e>
    4302:	8b 3e       	cpi	r24, 0xEB	; 235
    4304:	21 f1       	breq	.+72     	; 0x434e <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4306:	80 91 46 40 	lds	r24, 0x4046
    430a:	90 91 47 40 	lds	r25, 0x4047
    430e:	2a ea       	ldi	r18, 0xAA	; 170
    4310:	85 35       	cpi	r24, 0x55	; 85
    4312:	92 07       	cpc	r25, r18
    4314:	09 f0       	breq	.+2      	; 0x4318 <getBootSectorData+0x48>
    4316:	b7 c0       	rjmp	.+366    	; 0x4486 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    4318:	60 91 0e 40 	lds	r22, 0x400E
    431c:	70 91 0f 40 	lds	r23, 0x400F
    4320:	80 91 10 40 	lds	r24, 0x4010
    4324:	90 91 11 40 	lds	r25, 0x4011
    4328:	60 93 6b 50 	sts	0x506B, r22
    432c:	70 93 6c 50 	sts	0x506C, r23
    4330:	80 93 6d 50 	sts	0x506D, r24
    4334:	90 93 6e 50 	sts	0x506E, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    4338:	48 e4       	ldi	r20, 0x48	; 72
    433a:	5e e3       	ldi	r21, 0x3E	; 62
    433c:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4340:	80 91 48 3e 	lds	r24, 0x3E48
    4344:	89 3e       	cpi	r24, 0xE9	; 233
    4346:	19 f0       	breq	.+6      	; 0x434e <getBootSectorData+0x7e>
    4348:	8b 3e       	cpi	r24, 0xEB	; 235
    434a:	09 f0       	breq	.+2      	; 0x434e <getBootSectorData+0x7e>
    434c:	9e c0       	rjmp	.+316    	; 0x448a <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    434e:	80 91 53 3e 	lds	r24, 0x3E53
    4352:	90 91 54 3e 	lds	r25, 0x3E54
    4356:	80 93 55 40 	sts	0x4055, r24
    435a:	90 93 56 40 	sts	0x4056, r25
sectorPerCluster = bpb->sectorPerCluster;
    435e:	80 91 55 3e 	lds	r24, 0x3E55
    4362:	90 e0       	ldi	r25, 0x00	; 0
    4364:	80 93 69 50 	sts	0x5069, r24
    4368:	90 93 6a 50 	sts	0x506A, r25
reservedSectorCount = bpb->reservedSectorCount;
    436c:	e0 90 56 3e 	lds	r14, 0x3E56
    4370:	f0 90 57 3e 	lds	r15, 0x3E57
    4374:	e0 92 6f 50 	sts	0x506F, r14
    4378:	f0 92 70 50 	sts	0x5070, r15
rootCluster = bpb->rootCluster;
    437c:	80 91 74 3e 	lds	r24, 0x3E74
    4380:	90 91 75 3e 	lds	r25, 0x3E75
    4384:	a0 91 76 3e 	lds	r26, 0x3E76
    4388:	b0 91 77 3e 	lds	r27, 0x3E77
    438c:	80 93 5d 40 	sts	0x405D, r24
    4390:	90 93 5e 40 	sts	0x405E, r25
    4394:	a0 93 5f 40 	sts	0x405F, r26
    4398:	b0 93 60 40 	sts	0x4060, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    439c:	c0 91 6f 50 	lds	r28, 0x506F
    43a0:	d0 91 70 50 	lds	r29, 0x5070
    43a4:	60 91 58 3e 	lds	r22, 0x3E58
    43a8:	70 e0       	ldi	r23, 0x00	; 0
    43aa:	80 e0       	ldi	r24, 0x00	; 0
    43ac:	90 e0       	ldi	r25, 0x00	; 0
    43ae:	20 91 6c 3e 	lds	r18, 0x3E6C
    43b2:	30 91 6d 3e 	lds	r19, 0x3E6D
    43b6:	40 91 6e 3e 	lds	r20, 0x3E6E
    43ba:	50 91 6f 3e 	lds	r21, 0x3E6F
    43be:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    43c2:	8b 01       	movw	r16, r22
    43c4:	9c 01       	movw	r18, r24
    43c6:	ae 01       	movw	r20, r28
    43c8:	60 e0       	ldi	r22, 0x00	; 0
    43ca:	70 e0       	ldi	r23, 0x00	; 0
    43cc:	80 91 64 3e 	lds	r24, 0x3E64
    43d0:	90 91 65 3e 	lds	r25, 0x3E65
    43d4:	a0 91 66 3e 	lds	r26, 0x3E66
    43d8:	b0 91 67 3e 	lds	r27, 0x3E67
    43dc:	84 0f       	add	r24, r20
    43de:	95 1f       	adc	r25, r21
    43e0:	a6 1f       	adc	r26, r22
    43e2:	b7 1f       	adc	r27, r23
    43e4:	80 0f       	add	r24, r16
    43e6:	91 1f       	adc	r25, r17
    43e8:	a2 1f       	adc	r26, r18
    43ea:	b3 1f       	adc	r27, r19
    43ec:	80 93 4d 40 	sts	0x404D, r24
    43f0:	90 93 4e 40 	sts	0x404E, r25
    43f4:	a0 93 4f 40 	sts	0x404F, r26
    43f8:	b0 93 50 40 	sts	0x4050, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    43fc:	e0 91 69 50 	lds	r30, 0x5069
    4400:	f0 91 6a 50 	lds	r31, 0x506A
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4404:	c7 01       	movw	r24, r14
    4406:	a0 e0       	ldi	r26, 0x00	; 0
    4408:	b0 e0       	ldi	r27, 0x00	; 0
    440a:	40 91 68 3e 	lds	r20, 0x3E68
    440e:	50 91 69 3e 	lds	r21, 0x3E69
    4412:	60 91 6a 3e 	lds	r22, 0x3E6A
    4416:	70 91 6b 3e 	lds	r23, 0x3E6B
    441a:	48 1b       	sub	r20, r24
    441c:	59 0b       	sbc	r21, r25
    441e:	6a 0b       	sbc	r22, r26
    4420:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4422:	cb 01       	movw	r24, r22
    4424:	ba 01       	movw	r22, r20
    4426:	60 1b       	sub	r22, r16
    4428:	71 0b       	sbc	r23, r17
    442a:	82 0b       	sbc	r24, r18
    442c:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    442e:	9f 01       	movw	r18, r30
    4430:	40 e0       	ldi	r20, 0x00	; 0
    4432:	50 e0       	ldi	r21, 0x00	; 0
    4434:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    4438:	20 93 58 40 	sts	0x4058, r18
    443c:	30 93 59 40 	sts	0x4059, r19
    4440:	40 93 5a 40 	sts	0x405A, r20
    4444:	50 93 5b 40 	sts	0x405B, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    4448:	81 e0       	ldi	r24, 0x01	; 1
    444a:	60 e0       	ldi	r22, 0x00	; 0
    444c:	20 e0       	ldi	r18, 0x00	; 0
    444e:	30 e0       	ldi	r19, 0x00	; 0
    4450:	a9 01       	movw	r20, r18
    4452:	0e 94 c0 20 	call	0x4180	; 0x4180 <getSetFreeCluster>
    4456:	ab 01       	movw	r20, r22
    4458:	bc 01       	movw	r22, r24
    445a:	80 91 58 40 	lds	r24, 0x4058
    445e:	90 91 59 40 	lds	r25, 0x4059
    4462:	a0 91 5a 40 	lds	r26, 0x405A
    4466:	b0 91 5b 40 	lds	r27, 0x405B
    446a:	84 17       	cp	r24, r20
    446c:	95 07       	cpc	r25, r21
    446e:	a6 07       	cpc	r26, r22
    4470:	b7 07       	cpc	r27, r23
    4472:	20 f4       	brcc	.+8      	; 0x447c <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4474:	10 92 a1 50 	sts	0x50A1, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4478:	80 e0       	ldi	r24, 0x00	; 0
    447a:	08 c0       	rjmp	.+16     	; 0x448c <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    447c:	81 e0       	ldi	r24, 0x01	; 1
    447e:	80 93 a1 50 	sts	0x50A1, r24
return 0;
    4482:	80 e0       	ldi	r24, 0x00	; 0
    4484:	03 c0       	rjmp	.+6      	; 0x448c <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4486:	81 e0       	ldi	r24, 0x01	; 1
    4488:	01 c0       	rjmp	.+2      	; 0x448c <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    448a:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    448c:	df 91       	pop	r29
    448e:	cf 91       	pop	r28
    4490:	1f 91       	pop	r17
    4492:	0f 91       	pop	r16
    4494:	ff 90       	pop	r15
    4496:	ef 90       	pop	r14
    4498:	08 95       	ret

0000449a <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    449a:	0f 93       	push	r16
    449c:	1f 93       	push	r17
    449e:	cf 93       	push	r28
    44a0:	df 93       	push	r29
    44a2:	cd b7       	in	r28, 0x3d	; 61
    44a4:	de b7       	in	r29, 0x3e	; 62
    44a6:	2b 97       	sbiw	r28, 0x0b	; 11
    44a8:	cd bf       	out	0x3d, r28	; 61
    44aa:	de bf       	out	0x3e, r29	; 62
    44ac:	78 2f       	mov	r23, r24
    44ae:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    44b0:	e8 2f       	mov	r30, r24
    44b2:	f9 2f       	mov	r31, r25
    44b4:	df 01       	movw	r26, r30
    44b6:	0d 90       	ld	r0, X+
    44b8:	00 20       	and	r0, r0
    44ba:	e9 f7       	brne	.-6      	; 0x44b6 <convertFileName+0x1c>
    44bc:	11 97       	sbiw	r26, 0x01	; 1
    44be:	ae 1b       	sub	r26, r30
    44c0:	bf 0b       	sbc	r27, r31
    44c2:	a0 31       	cpi	r26, 0x10	; 16
    44c4:	b1 05       	cpc	r27, r1
    44c6:	08 f0       	brcs	.+2      	; 0x44ca <convertFileName+0x30>
    44c8:	9c c0       	rjmp	.+312    	; 0x4602 <convertFileName+0x168>
    44ca:	28 2f       	mov	r18, r24
    44cc:	39 2f       	mov	r19, r25
    44ce:	01 e9       	ldi	r16, 0x91	; 145
    44d0:	10 e5       	ldi	r17, 0x50	; 80
    44d2:	a8 01       	movw	r20, r16
    44d4:	80 e0       	ldi	r24, 0x00	; 0
    44d6:	90 e0       	ldi	r25, 0x00	; 0
    44d8:	07 c0       	rjmp	.+14     	; 0x44e8 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    44da:	d9 01       	movw	r26, r18
    44dc:	ed 91       	ld	r30, X+
    44de:	9d 01       	movw	r18, r26
    44e0:	da 01       	movw	r26, r20
    44e2:	ed 93       	st	X+, r30
    44e4:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    44e6:	01 96       	adiw	r24, 0x01	; 1
    44e8:	a7 2f       	mov	r26, r23
    44ea:	b6 2f       	mov	r27, r22
    44ec:	fd 01       	movw	r30, r26
    44ee:	01 90       	ld	r0, Z+
    44f0:	00 20       	and	r0, r0
    44f2:	e9 f7       	brne	.-6      	; 0x44ee <convertFileName+0x54>
    44f4:	31 97       	sbiw	r30, 0x01	; 1
    44f6:	ea 1b       	sub	r30, r26
    44f8:	fb 0b       	sbc	r31, r27
    44fa:	8e 17       	cp	r24, r30
    44fc:	9f 07       	cpc	r25, r31
    44fe:	68 f3       	brcs	.-38     	; 0x44da <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4500:	8f 30       	cpi	r24, 0x0F	; 15
    4502:	91 05       	cpc	r25, r1
    4504:	54 f4       	brge	.+20     	; 0x451a <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4506:	fc 01       	movw	r30, r24
    4508:	ef 56       	subi	r30, 0x6F	; 111
    450a:	ff 4a       	sbci	r31, 0xAF	; 175
    450c:	80 ea       	ldi	r24, 0xA0	; 160
    450e:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4510:	20 e2       	ldi	r18, 0x20	; 32
    4512:	21 93       	st	Z+, r18
    4514:	e8 17       	cp	r30, r24
    4516:	f9 07       	cpc	r31, r25
    4518:	e1 f7       	brne	.-8      	; 0x4512 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    451a:	80 91 91 50 	lds	r24, 0x5091
    451e:	8e 32       	cpi	r24, 0x2E	; 46
    4520:	91 f0       	breq	.+36     	; 0x4546 <convertFileName+0xac>
    4522:	e2 e9       	ldi	r30, 0x92	; 146
    4524:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4526:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    4528:	81 91       	ld	r24, Z+
    452a:	8e 32       	cpi	r24, 0x2E	; 46
    452c:	21 f0       	breq	.+8      	; 0x4536 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    452e:	2f 5f       	subi	r18, 0xFF	; 255
    4530:	2c 30       	cpi	r18, 0x0C	; 12
    4532:	d1 f7       	brne	.-12     	; 0x4528 <convertFileName+0x8e>
    4534:	05 c0       	rjmp	.+10     	; 0x4540 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    4536:	82 2f       	mov	r24, r18
    4538:	89 50       	subi	r24, 0x09	; 9
    453a:	83 30       	cpi	r24, 0x03	; 3
    453c:	08 f4       	brcc	.+2      	; 0x4540 <convertFileName+0xa6>
    453e:	63 c0       	rjmp	.+198    	; 0x4606 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4540:	22 23       	and	r18, r18
    4542:	29 f4       	brne	.+10     	; 0x454e <convertFileName+0xb4>
    4544:	01 c0       	rjmp	.+2      	; 0x4548 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4546:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4548:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    454a:	90 e2       	ldi	r25, 0x20	; 32
    454c:	10 c0       	rjmp	.+32     	; 0x456e <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    454e:	de 01       	movw	r26, r28
    4550:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4552:	82 2f       	mov	r24, r18
    4554:	81 50       	subi	r24, 0x01	; 1
    4556:	90 e0       	ldi	r25, 0x00	; 0
    4558:	8e 56       	subi	r24, 0x6E	; 110
    455a:	9f 4a       	sbci	r25, 0xAF	; 175
    455c:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    455e:	31 91       	ld	r19, Z+
    4560:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4562:	e8 17       	cp	r30, r24
    4564:	f9 07       	cpc	r31, r25
    4566:	d9 f7       	brne	.-10     	; 0x455e <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4568:	28 30       	cpi	r18, 0x08	; 8
    456a:	70 f3       	brcs	.-36     	; 0x4548 <convertFileName+0xae>
    456c:	0a c0       	rjmp	.+20     	; 0x4582 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    456e:	e1 e0       	ldi	r30, 0x01	; 1
    4570:	f0 e0       	ldi	r31, 0x00	; 0
    4572:	ec 0f       	add	r30, r28
    4574:	fd 1f       	adc	r31, r29
    4576:	e8 0f       	add	r30, r24
    4578:	f1 1d       	adc	r31, r1
    457a:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    457c:	8f 5f       	subi	r24, 0xFF	; 255
    457e:	88 30       	cpi	r24, 0x08	; 8
    4580:	b0 f3       	brcs	.-20     	; 0x456e <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4582:	2c 30       	cpi	r18, 0x0C	; 12
    4584:	09 f0       	breq	.+2      	; 0x4588 <convertFileName+0xee>
    4586:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4588:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    458a:	81 e9       	ldi	r24, 0x91	; 145
    458c:	90 e5       	ldi	r25, 0x50	; 80
    458e:	fc 01       	movw	r30, r24
    4590:	e2 0f       	add	r30, r18
    4592:	f1 1d       	adc	r31, r1
    4594:	40 81       	ld	r20, Z
    4596:	44 23       	and	r20, r20
    4598:	19 f4       	brne	.+6      	; 0x45a0 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    459a:	3b 30       	cpi	r19, 0x0B	; 11
    459c:	50 f0       	brcs	.+20     	; 0x45b2 <convertFileName+0x118>
    459e:	15 c0       	rjmp	.+42     	; 0x45ca <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    45a0:	e1 e0       	ldi	r30, 0x01	; 1
    45a2:	f0 e0       	ldi	r31, 0x00	; 0
    45a4:	ec 0f       	add	r30, r28
    45a6:	fd 1f       	adc	r31, r29
    45a8:	e3 0f       	add	r30, r19
    45aa:	f1 1d       	adc	r31, r1
    45ac:	40 83       	st	Z, r20
    45ae:	2f 5f       	subi	r18, 0xFF	; 255
    45b0:	0c c0       	rjmp	.+24     	; 0x45ca <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    45b2:	80 e2       	ldi	r24, 0x20	; 32
    45b4:	e1 e0       	ldi	r30, 0x01	; 1
    45b6:	f0 e0       	ldi	r31, 0x00	; 0
    45b8:	ec 0f       	add	r30, r28
    45ba:	fd 1f       	adc	r31, r29
    45bc:	e3 0f       	add	r30, r19
    45be:	f1 1d       	adc	r31, r1
    45c0:	80 83       	st	Z, r24
    45c2:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    45c4:	3b 30       	cpi	r19, 0x0B	; 11
    45c6:	b1 f7       	brne	.-20     	; 0x45b4 <convertFileName+0x11a>
    45c8:	03 c0       	rjmp	.+6      	; 0x45d0 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    45ca:	3f 5f       	subi	r19, 0xFF	; 255
    45cc:	3b 30       	cpi	r19, 0x0B	; 11
    45ce:	f8 f2       	brcs	.-66     	; 0x458e <convertFileName+0xf4>
    45d0:	de 01       	movw	r26, r28
    45d2:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    45d4:	ce 01       	movw	r24, r28
    45d6:	0c 96       	adiw	r24, 0x0c	; 12
    45d8:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    45da:	20 81       	ld	r18, Z
    45dc:	32 2f       	mov	r19, r18
    45de:	31 56       	subi	r19, 0x61	; 97
    45e0:	3a 31       	cpi	r19, 0x1A	; 26
    45e2:	10 f4       	brcc	.+4      	; 0x45e8 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    45e4:	20 52       	subi	r18, 0x20	; 32
    45e6:	20 83       	st	Z, r18
    45e8:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    45ea:	e8 17       	cp	r30, r24
    45ec:	f9 07       	cpc	r31, r25
    45ee:	a9 f7       	brne	.-22     	; 0x45da <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    45f0:	2d 91       	ld	r18, X+
    45f2:	f8 01       	movw	r30, r16
    45f4:	21 93       	st	Z+, r18
    45f6:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    45f8:	a8 17       	cp	r26, r24
    45fa:	b9 07       	cpc	r27, r25
    45fc:	c9 f7       	brne	.-14     	; 0x45f0 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    45fe:	80 e0       	ldi	r24, 0x00	; 0
    4600:	03 c0       	rjmp	.+6      	; 0x4608 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4602:	81 e0       	ldi	r24, 0x01	; 1
    4604:	01 c0       	rjmp	.+2      	; 0x4608 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4606:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    4608:	2b 96       	adiw	r28, 0x0b	; 11
    460a:	cd bf       	out	0x3d, r28	; 61
    460c:	de bf       	out	0x3e, r29	; 62
    460e:	df 91       	pop	r29
    4610:	cf 91       	pop	r28
    4612:	1f 91       	pop	r17
    4614:	0f 91       	pop	r16
    4616:	08 95       	ret

00004618 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4618:	4f 92       	push	r4
    461a:	5f 92       	push	r5
    461c:	6f 92       	push	r6
    461e:	7f 92       	push	r7
    4620:	8f 92       	push	r8
    4622:	9f 92       	push	r9
    4624:	af 92       	push	r10
    4626:	bf 92       	push	r11
    4628:	cf 92       	push	r12
    462a:	df 92       	push	r13
    462c:	ef 92       	push	r14
    462e:	ff 92       	push	r15
    4630:	cf 93       	push	r28
    4632:	df 93       	push	r29
    4634:	2b 01       	movw	r4, r22
    4636:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4638:	20 e8       	ldi	r18, 0x80	; 128
    463a:	3f ef       	ldi	r19, 0xFF	; 255
    463c:	4f ef       	ldi	r20, 0xFF	; 255
    463e:	5f ef       	ldi	r21, 0xFF	; 255
    4640:	42 22       	and	r4, r18
    4642:	53 22       	and	r5, r19
    4644:	64 22       	and	r6, r20
    4646:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4648:	80 91 58 40 	lds	r24, 0x4058
    464c:	90 91 59 40 	lds	r25, 0x4059
    4650:	a0 91 5a 40 	lds	r26, 0x405A
    4654:	b0 91 5b 40 	lds	r27, 0x405B
    4658:	48 16       	cp	r4, r24
    465a:	59 06       	cpc	r5, r25
    465c:	6a 06       	cpc	r6, r26
    465e:	7b 06       	cpc	r7, r27
    4660:	08 f0       	brcs	.+2      	; 0x4664 <searchNextFreeCluster+0x4c>
    4662:	77 c0       	rjmp	.+238    	; 0x4752 <searchNextFreeCluster+0x13a>
    4664:	53 01       	movw	r10, r6
    4666:	42 01       	movw	r8, r4
    4668:	88 0c       	add	r8, r8
    466a:	99 1c       	adc	r9, r9
    466c:	aa 1c       	adc	r10, r10
    466e:	bb 1c       	adc	r11, r11
    4670:	88 0c       	add	r8, r8
    4672:	99 1c       	adc	r9, r9
    4674:	aa 1c       	adc	r10, r10
    4676:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4678:	c8 e4       	ldi	r28, 0x48	; 72
    467a:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    467c:	c0 90 6f 50 	lds	r12, 0x506F
    4680:	d0 90 70 50 	lds	r13, 0x5070
    4684:	20 91 55 40 	lds	r18, 0x4055
    4688:	30 91 56 40 	lds	r19, 0x4056
    468c:	ee 24       	eor	r14, r14
    468e:	ff 24       	eor	r15, r15
    4690:	80 91 6b 50 	lds	r24, 0x506B
    4694:	90 91 6c 50 	lds	r25, 0x506C
    4698:	a0 91 6d 50 	lds	r26, 0x506D
    469c:	b0 91 6e 50 	lds	r27, 0x506E
    46a0:	c8 0e       	add	r12, r24
    46a2:	d9 1e       	adc	r13, r25
    46a4:	ea 1e       	adc	r14, r26
    46a6:	fb 1e       	adc	r15, r27
    46a8:	40 e0       	ldi	r20, 0x00	; 0
    46aa:	50 e0       	ldi	r21, 0x00	; 0
    46ac:	c5 01       	movw	r24, r10
    46ae:	b4 01       	movw	r22, r8
    46b0:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    46b4:	c7 01       	movw	r24, r14
    46b6:	b6 01       	movw	r22, r12
    46b8:	62 0f       	add	r22, r18
    46ba:	73 1f       	adc	r23, r19
    46bc:	84 1f       	adc	r24, r20
    46be:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    46c0:	ae 01       	movw	r20, r28
    46c2:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    46c6:	88 81       	ld	r24, Y
    46c8:	99 81       	ldd	r25, Y+1	; 0x01
    46ca:	aa 81       	ldd	r26, Y+2	; 0x02
    46cc:	bb 81       	ldd	r27, Y+3	; 0x03
    46ce:	bf 70       	andi	r27, 0x0F	; 15
    46d0:	00 97       	sbiw	r24, 0x00	; 0
    46d2:	a1 05       	cpc	r26, r1
    46d4:	b1 05       	cpc	r27, r1
    46d6:	99 f0       	breq	.+38     	; 0x46fe <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    46d8:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    46da:	e2 2f       	mov	r30, r18
    46dc:	f0 e0       	ldi	r31, 0x00	; 0
    46de:	ee 0f       	add	r30, r30
    46e0:	ff 1f       	adc	r31, r31
    46e2:	ee 0f       	add	r30, r30
    46e4:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    46e6:	e8 5b       	subi	r30, 0xB8	; 184
    46e8:	f1 4c       	sbci	r31, 0xC1	; 193
    46ea:	80 81       	ld	r24, Z
    46ec:	91 81       	ldd	r25, Z+1	; 0x01
    46ee:	a2 81       	ldd	r26, Z+2	; 0x02
    46f0:	b3 81       	ldd	r27, Z+3	; 0x03
    46f2:	bf 70       	andi	r27, 0x0F	; 15
    46f4:	00 97       	sbiw	r24, 0x00	; 0
    46f6:	a1 05       	cpc	r26, r1
    46f8:	b1 05       	cpc	r27, r1
    46fa:	39 f4       	brne	.+14     	; 0x470a <searchNextFreeCluster+0xf2>
    46fc:	01 c0       	rjmp	.+2      	; 0x4700 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    46fe:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4700:	42 0e       	add	r4, r18
    4702:	51 1c       	adc	r5, r1
    4704:	61 1c       	adc	r6, r1
    4706:	71 1c       	adc	r7, r1
    4708:	27 c0       	rjmp	.+78     	; 0x4758 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    470a:	2f 5f       	subi	r18, 0xFF	; 255
    470c:	32 f7       	brpl	.-52     	; 0x46da <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    470e:	80 e8       	ldi	r24, 0x80	; 128
    4710:	90 e0       	ldi	r25, 0x00	; 0
    4712:	a0 e0       	ldi	r26, 0x00	; 0
    4714:	b0 e0       	ldi	r27, 0x00	; 0
    4716:	48 0e       	add	r4, r24
    4718:	59 1e       	adc	r5, r25
    471a:	6a 1e       	adc	r6, r26
    471c:	7b 1e       	adc	r7, r27
    471e:	80 91 58 40 	lds	r24, 0x4058
    4722:	90 91 59 40 	lds	r25, 0x4059
    4726:	a0 91 5a 40 	lds	r26, 0x405A
    472a:	b0 91 5b 40 	lds	r27, 0x405B
    472e:	20 e0       	ldi	r18, 0x00	; 0
    4730:	32 e0       	ldi	r19, 0x02	; 2
    4732:	40 e0       	ldi	r20, 0x00	; 0
    4734:	50 e0       	ldi	r21, 0x00	; 0
    4736:	82 0e       	add	r8, r18
    4738:	93 1e       	adc	r9, r19
    473a:	a4 1e       	adc	r10, r20
    473c:	b5 1e       	adc	r11, r21
    473e:	48 16       	cp	r4, r24
    4740:	59 06       	cpc	r5, r25
    4742:	6a 06       	cpc	r6, r26
    4744:	7b 06       	cpc	r7, r27
    4746:	08 f4       	brcc	.+2      	; 0x474a <searchNextFreeCluster+0x132>
    4748:	99 cf       	rjmp	.-206    	; 0x467c <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    474a:	44 24       	eor	r4, r4
    474c:	55 24       	eor	r5, r5
    474e:	32 01       	movw	r6, r4
    4750:	03 c0       	rjmp	.+6      	; 0x4758 <searchNextFreeCluster+0x140>
    4752:	44 24       	eor	r4, r4
    4754:	55 24       	eor	r5, r5
    4756:	32 01       	movw	r6, r4
}
    4758:	64 2d       	mov	r22, r4
    475a:	75 2d       	mov	r23, r5
    475c:	86 2d       	mov	r24, r6
    475e:	97 2d       	mov	r25, r7
    4760:	df 91       	pop	r29
    4762:	cf 91       	pop	r28
    4764:	ff 90       	pop	r15
    4766:	ef 90       	pop	r14
    4768:	df 90       	pop	r13
    476a:	cf 90       	pop	r12
    476c:	bf 90       	pop	r11
    476e:	af 90       	pop	r10
    4770:	9f 90       	pop	r9
    4772:	8f 90       	pop	r8
    4774:	7f 90       	pop	r7
    4776:	6f 90       	pop	r6
    4778:	5f 90       	pop	r5
    477a:	4f 90       	pop	r4
    477c:	08 95       	ret

0000477e <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    477e:	cf 92       	push	r12
    4780:	df 92       	push	r13
    4782:	ef 92       	push	r14
    4784:	ff 92       	push	r15
    4786:	cf 93       	push	r28
    4788:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    478a:	db 01       	movw	r26, r22
    478c:	ca 01       	movw	r24, r20
    478e:	91 70       	andi	r25, 0x01	; 1
    4790:	a0 70       	andi	r26, 0x00	; 0
    4792:	b0 70       	andi	r27, 0x00	; 0
    4794:	00 97       	sbiw	r24, 0x00	; 0
    4796:	a1 05       	cpc	r26, r1
    4798:	b1 05       	cpc	r27, r1
    479a:	51 f4       	brne	.+20     	; 0x47b0 <freeMemoryUpdate+0x32>
    479c:	03 2e       	mov	r0, r19
    479e:	39 e0       	ldi	r19, 0x09	; 9
    47a0:	76 95       	lsr	r23
    47a2:	67 95       	ror	r22
    47a4:	57 95       	ror	r21
    47a6:	47 95       	ror	r20
    47a8:	3a 95       	dec	r19
    47aa:	d1 f7       	brne	.-12     	; 0x47a0 <freeMemoryUpdate+0x22>
    47ac:	30 2d       	mov	r19, r0
    47ae:	0d c0       	rjmp	.+26     	; 0x47ca <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    47b0:	03 2e       	mov	r0, r19
    47b2:	39 e0       	ldi	r19, 0x09	; 9
    47b4:	76 95       	lsr	r23
    47b6:	67 95       	ror	r22
    47b8:	57 95       	ror	r21
    47ba:	47 95       	ror	r20
    47bc:	3a 95       	dec	r19
    47be:	d1 f7       	brne	.-12     	; 0x47b4 <freeMemoryUpdate+0x36>
    47c0:	30 2d       	mov	r19, r0
    47c2:	4f 5f       	subi	r20, 0xFF	; 255
    47c4:	5f 4f       	sbci	r21, 0xFF	; 255
    47c6:	6f 4f       	sbci	r22, 0xFF	; 255
    47c8:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    47ca:	db 01       	movw	r26, r22
    47cc:	ca 01       	movw	r24, r20
    47ce:	87 70       	andi	r24, 0x07	; 7
    47d0:	90 70       	andi	r25, 0x00	; 0
    47d2:	a0 70       	andi	r26, 0x00	; 0
    47d4:	b0 70       	andi	r27, 0x00	; 0
    47d6:	00 97       	sbiw	r24, 0x00	; 0
    47d8:	a1 05       	cpc	r26, r1
    47da:	b1 05       	cpc	r27, r1
    47dc:	59 f4       	brne	.+22     	; 0x47f4 <freeMemoryUpdate+0x76>
    47de:	6a 01       	movw	r12, r20
    47e0:	7b 01       	movw	r14, r22
    47e2:	68 94       	set
    47e4:	12 f8       	bld	r1, 2
    47e6:	f6 94       	lsr	r15
    47e8:	e7 94       	ror	r14
    47ea:	d7 94       	ror	r13
    47ec:	c7 94       	ror	r12
    47ee:	16 94       	lsr	r1
    47f0:	d1 f7       	brne	.-12     	; 0x47e6 <freeMemoryUpdate+0x68>
    47f2:	0f c0       	rjmp	.+30     	; 0x4812 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    47f4:	6a 01       	movw	r12, r20
    47f6:	7b 01       	movw	r14, r22
    47f8:	68 94       	set
    47fa:	12 f8       	bld	r1, 2
    47fc:	f6 94       	lsr	r15
    47fe:	e7 94       	ror	r14
    4800:	d7 94       	ror	r13
    4802:	c7 94       	ror	r12
    4804:	16 94       	lsr	r1
    4806:	d1 f7       	brne	.-12     	; 0x47fc <freeMemoryUpdate+0x7e>
    4808:	08 94       	sec
    480a:	c1 1c       	adc	r12, r1
    480c:	d1 1c       	adc	r13, r1
    480e:	e1 1c       	adc	r14, r1
    4810:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4812:	80 91 a1 50 	lds	r24, 0x50A1
    4816:	88 23       	and	r24, r24
    4818:	d1 f0       	breq	.+52     	; 0x484e <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    481a:	81 e0       	ldi	r24, 0x01	; 1
    481c:	60 e0       	ldi	r22, 0x00	; 0
    481e:	20 e0       	ldi	r18, 0x00	; 0
    4820:	30 e0       	ldi	r19, 0x00	; 0
    4822:	a9 01       	movw	r20, r18
    4824:	0e 94 c0 20 	call	0x4180	; 0x4180 <getSetFreeCluster>
	if(flag == ADD)
    4828:	cc 23       	and	r28, r28
    482a:	39 f4       	brne	.+14     	; 0x483a <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    482c:	9b 01       	movw	r18, r22
    482e:	ac 01       	movw	r20, r24
    4830:	2c 0d       	add	r18, r12
    4832:	3d 1d       	adc	r19, r13
    4834:	4e 1d       	adc	r20, r14
    4836:	5f 1d       	adc	r21, r15
    4838:	06 c0       	rjmp	.+12     	; 0x4846 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    483a:	9b 01       	movw	r18, r22
    483c:	ac 01       	movw	r20, r24
    483e:	2c 19       	sub	r18, r12
    4840:	3d 09       	sbc	r19, r13
    4842:	4e 09       	sbc	r20, r14
    4844:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4846:	81 e0       	ldi	r24, 0x01	; 1
    4848:	61 e0       	ldi	r22, 0x01	; 1
    484a:	0e 94 c0 20 	call	0x4180	; 0x4180 <getSetFreeCluster>
  }
}
    484e:	cf 91       	pop	r28
    4850:	ff 90       	pop	r15
    4852:	ef 90       	pop	r14
    4854:	df 90       	pop	r13
    4856:	cf 90       	pop	r12
    4858:	08 95       	ret

0000485a <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    485a:	2f 92       	push	r2
    485c:	3f 92       	push	r3
    485e:	4f 92       	push	r4
    4860:	5f 92       	push	r5
    4862:	6f 92       	push	r6
    4864:	7f 92       	push	r7
    4866:	8f 92       	push	r8
    4868:	9f 92       	push	r9
    486a:	af 92       	push	r10
    486c:	bf 92       	push	r11
    486e:	cf 92       	push	r12
    4870:	df 92       	push	r13
    4872:	ef 92       	push	r14
    4874:	ff 92       	push	r15
    4876:	0f 93       	push	r16
    4878:	1f 93       	push	r17
    487a:	cf 93       	push	r28
    487c:	df 93       	push	r29
    487e:	cd b7       	in	r28, 0x3d	; 61
    4880:	de b7       	in	r29, 0x3e	; 62
    4882:	2c 97       	sbiw	r28, 0x0c	; 12
    4884:	cd bf       	out	0x3d, r28	; 61
    4886:	de bf       	out	0x3e, r29	; 62
    4888:	88 2e       	mov	r8, r24
    488a:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    488c:	80 91 5d 40 	lds	r24, 0x405D
    4890:	90 91 5e 40 	lds	r25, 0x405E
    4894:	a0 91 5f 40 	lds	r26, 0x405F
    4898:	b0 91 60 40 	lds	r27, 0x4060
    489c:	89 87       	std	Y+9, r24	; 0x09
    489e:	9a 87       	std	Y+10, r25	; 0x0a
    48a0:	ab 87       	std	Y+11, r26	; 0x0b
    48a2:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    48a4:	0f 2e       	mov	r0, r31
    48a6:	f8 e4       	ldi	r31, 0x48	; 72
    48a8:	2f 2e       	mov	r2, r31
    48aa:	fe e3       	ldi	r31, 0x3E	; 62
    48ac:	3f 2e       	mov	r3, r31
    48ae:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    48b0:	c8 2c       	mov	r12, r8
    48b2:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    48b4:	d2 2c       	mov	r13, r2
    48b6:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    48b8:	5b 01       	movw	r10, r22
    48ba:	08 94       	sec
    48bc:	a1 1c       	adc	r10, r1
    48be:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    48c0:	69 85       	ldd	r22, Y+9	; 0x09
    48c2:	7a 85       	ldd	r23, Y+10	; 0x0a
    48c4:	8b 85       	ldd	r24, Y+11	; 0x0b
    48c6:	9c 85       	ldd	r25, Y+12	; 0x0c
    48c8:	0e 94 07 20 	call	0x400e	; 0x400e <getFirstSector>
    48cc:	6d 83       	std	Y+5, r22	; 0x05
    48ce:	7e 83       	std	Y+6, r23	; 0x06
    48d0:	8f 83       	std	Y+7, r24	; 0x07
    48d2:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    48d4:	80 91 69 50 	lds	r24, 0x5069
    48d8:	90 91 6a 50 	lds	r25, 0x506A
    48dc:	00 97       	sbiw	r24, 0x00	; 0
    48de:	09 f4       	brne	.+2      	; 0x48e2 <findFiles+0x88>
    48e0:	13 c1       	rjmp	.+550    	; 0x4b08 <findFiles+0x2ae>
    48e2:	44 24       	eor	r4, r4
    48e4:	55 24       	eor	r5, r5
    48e6:	32 01       	movw	r6, r4
    48e8:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    48ea:	8d 81       	ldd	r24, Y+5	; 0x05
    48ec:	9e 81       	ldd	r25, Y+6	; 0x06
    48ee:	af 81       	ldd	r26, Y+7	; 0x07
    48f0:	b8 85       	ldd	r27, Y+8	; 0x08
    48f2:	84 0d       	add	r24, r4
    48f4:	95 1d       	adc	r25, r5
    48f6:	a6 1d       	adc	r26, r6
    48f8:	b7 1d       	adc	r27, r7
    48fa:	89 83       	std	Y+1, r24	; 0x01
    48fc:	9a 83       	std	Y+2, r25	; 0x02
    48fe:	ab 83       	std	Y+3, r26	; 0x03
    4900:	bc 83       	std	Y+4, r27	; 0x04
    4902:	bc 01       	movw	r22, r24
    4904:	cd 01       	movw	r24, r26
    4906:	4d 2d       	mov	r20, r13
    4908:	59 2d       	mov	r21, r9
    490a:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    490e:	80 91 55 40 	lds	r24, 0x4055
    4912:	90 91 56 40 	lds	r25, 0x4056
    4916:	00 97       	sbiw	r24, 0x00	; 0
    4918:	09 f4       	brne	.+2      	; 0x491c <findFiles+0xc2>
    491a:	e4 c0       	rjmp	.+456    	; 0x4ae4 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    491c:	d1 01       	movw	r26, r2
    491e:	8c 91       	ld	r24, X
    4920:	88 23       	and	r24, r24
    4922:	09 f4       	brne	.+2      	; 0x4926 <findFiles+0xcc>
    4924:	10 c1       	rjmp	.+544    	; 0x4b46 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4926:	4d 2d       	mov	r20, r13
    4928:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    492a:	20 e0       	ldi	r18, 0x00	; 0
    492c:	30 e0       	ldi	r19, 0x00	; 0
    492e:	08 c0       	rjmp	.+16     	; 0x4940 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4930:	a9 01       	movw	r20, r18
    4932:	48 5b       	subi	r20, 0xB8	; 184
    4934:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4936:	fa 01       	movw	r30, r20
    4938:	80 81       	ld	r24, Z
    493a:	88 23       	and	r24, r24
    493c:	09 f4       	brne	.+2      	; 0x4940 <findFiles+0xe6>
    493e:	06 c1       	rjmp	.+524    	; 0x4b4c <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4940:	85 3e       	cpi	r24, 0xE5	; 229
    4942:	09 f4       	brne	.+2      	; 0x4946 <findFiles+0xec>
    4944:	c5 c0       	rjmp	.+394    	; 0x4ad0 <findFiles+0x276>
    4946:	da 01       	movw	r26, r20
    4948:	1b 96       	adiw	r26, 0x0b	; 11
    494a:	8c 91       	ld	r24, X
    494c:	1b 97       	sbiw	r26, 0x0b	; 11
    494e:	8f 30       	cpi	r24, 0x0F	; 15
    4950:	09 f4       	brne	.+2      	; 0x4954 <findFiles+0xfa>
    4952:	be c0       	rjmp	.+380    	; 0x4ad0 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4954:	12 30       	cpi	r17, 0x02	; 2
    4956:	08 f0       	brcs	.+2      	; 0x495a <findFiles+0x100>
    4958:	fc c0       	rjmp	.+504    	; 0x4b52 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    495a:	9c 91       	ld	r25, X
    495c:	f7 01       	movw	r30, r14
    495e:	80 81       	ld	r24, Z
    4960:	98 17       	cp	r25, r24
    4962:	09 f0       	breq	.+2      	; 0x4966 <findFiles+0x10c>
    4964:	b5 c0       	rjmp	.+362    	; 0x4ad0 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4966:	fa 01       	movw	r30, r20
    4968:	31 96       	adiw	r30, 0x01	; 1
    496a:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    496c:	81 e0       	ldi	r24, 0x01	; 1
    496e:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4970:	41 91       	ld	r20, Z+
    4972:	9d 91       	ld	r25, X+
    4974:	49 17       	cp	r20, r25
    4976:	31 f4       	brne	.+12     	; 0x4984 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4978:	8f 5f       	subi	r24, 0xFF	; 255
    497a:	8b 30       	cpi	r24, 0x0B	; 11
    497c:	c9 f7       	brne	.-14     	; 0x4970 <findFiles+0x116>
    497e:	8b 01       	movw	r16, r22
    4980:	6b 01       	movw	r12, r22
    4982:	05 c0       	rjmp	.+10     	; 0x498e <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4984:	8b 30       	cpi	r24, 0x0B	; 11
    4986:	09 f0       	breq	.+2      	; 0x498a <findFiles+0x130>
    4988:	a3 c0       	rjmp	.+326    	; 0x4ad0 <findFiles+0x276>
    498a:	8b 01       	movw	r16, r22
    498c:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    498e:	f1 e0       	ldi	r31, 0x01	; 1
    4990:	8f 16       	cp	r8, r31
    4992:	09 f0       	breq	.+2      	; 0x4996 <findFiles+0x13c>
    4994:	41 c0       	rjmp	.+130    	; 0x4a18 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4996:	89 81       	ldd	r24, Y+1	; 0x01
    4998:	9a 81       	ldd	r25, Y+2	; 0x02
    499a:	ab 81       	ldd	r26, Y+3	; 0x03
    499c:	bc 81       	ldd	r27, Y+4	; 0x04
    499e:	80 93 a2 50 	sts	0x50A2, r24
    49a2:	90 93 a3 50 	sts	0x50A3, r25
    49a6:	a0 93 a4 50 	sts	0x50A4, r26
    49aa:	b0 93 a5 50 	sts	0x50A5, r27
				appendFileLocation = i;
    49ae:	c9 01       	movw	r24, r18
    49b0:	a0 e0       	ldi	r26, 0x00	; 0
    49b2:	b0 e0       	ldi	r27, 0x00	; 0
    49b4:	80 93 49 40 	sts	0x4049, r24
    49b8:	90 93 4a 40 	sts	0x404A, r25
    49bc:	a0 93 4b 40 	sts	0x404B, r26
    49c0:	b0 93 4c 40 	sts	0x404C, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    49c4:	d6 01       	movw	r26, r12
    49c6:	54 96       	adiw	r26, 0x14	; 20
    49c8:	4d 91       	ld	r20, X+
    49ca:	5c 91       	ld	r21, X
    49cc:	55 97       	sbiw	r26, 0x15	; 21
    49ce:	60 e0       	ldi	r22, 0x00	; 0
    49d0:	70 e0       	ldi	r23, 0x00	; 0
    49d2:	ba 01       	movw	r22, r20
    49d4:	55 27       	eor	r21, r21
    49d6:	44 27       	eor	r20, r20
    49d8:	5a 96       	adiw	r26, 0x1a	; 26
    49da:	8d 91       	ld	r24, X+
    49dc:	9c 91       	ld	r25, X
    49de:	5b 97       	sbiw	r26, 0x1b	; 27
    49e0:	a0 e0       	ldi	r26, 0x00	; 0
    49e2:	b0 e0       	ldi	r27, 0x00	; 0
    49e4:	84 2b       	or	r24, r20
    49e6:	95 2b       	or	r25, r21
    49e8:	a6 2b       	or	r26, r22
    49ea:	b7 2b       	or	r27, r23
    49ec:	80 93 73 50 	sts	0x5073, r24
    49f0:	90 93 74 50 	sts	0x5074, r25
    49f4:	a0 93 75 50 	sts	0x5075, r26
    49f8:	b0 93 76 50 	sts	0x5076, r27
				fileSize = dir->fileSize;
    49fc:	f6 01       	movw	r30, r12
    49fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    4a00:	95 8d       	ldd	r25, Z+29	; 0x1d
    4a02:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4a04:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4a06:	80 93 51 40 	sts	0x4051, r24
    4a0a:	90 93 52 40 	sts	0x4052, r25
    4a0e:	a0 93 53 40 	sts	0x4053, r26
    4a12:	b0 93 54 40 	sts	0x4054, r27
			    return (dir);
    4a16:	a5 c0       	rjmp	.+330    	; 0x4b62 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4a18:	d6 01       	movw	r26, r12
    4a1a:	54 96       	adiw	r26, 0x14	; 20
    4a1c:	8d 91       	ld	r24, X+
    4a1e:	9c 91       	ld	r25, X
    4a20:	55 97       	sbiw	r26, 0x15	; 21
    4a22:	a0 e0       	ldi	r26, 0x00	; 0
    4a24:	b0 e0       	ldi	r27, 0x00	; 0
    4a26:	3c 01       	movw	r6, r24
    4a28:	55 24       	eor	r5, r5
    4a2a:	44 24       	eor	r4, r4
    4a2c:	f6 01       	movw	r30, r12
    4a2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a30:	93 8d       	ldd	r25, Z+27	; 0x1b
    4a32:	a0 e0       	ldi	r26, 0x00	; 0
    4a34:	b0 e0       	ldi	r27, 0x00	; 0
    4a36:	48 2a       	or	r4, r24
    4a38:	59 2a       	or	r5, r25
    4a3a:	6a 2a       	or	r6, r26
    4a3c:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4a3e:	85 ee       	ldi	r24, 0xE5	; 229
    4a40:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4a42:	69 81       	ldd	r22, Y+1	; 0x01
    4a44:	7a 81       	ldd	r23, Y+2	; 0x02
    4a46:	8b 81       	ldd	r24, Y+3	; 0x03
    4a48:	9c 81       	ldd	r25, Y+4	; 0x04
    4a4a:	48 e4       	ldi	r20, 0x48	; 72
    4a4c:	5e e3       	ldi	r21, 0x3E	; 62
    4a4e:	20 e0       	ldi	r18, 0x00	; 0
    4a50:	32 e0       	ldi	r19, 0x02	; 2
    4a52:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4a56:	d6 01       	movw	r26, r12
    4a58:	5c 96       	adiw	r26, 0x1c	; 28
    4a5a:	4d 91       	ld	r20, X+
    4a5c:	5d 91       	ld	r21, X+
    4a5e:	6d 91       	ld	r22, X+
    4a60:	7c 91       	ld	r23, X
    4a62:	5f 97       	sbiw	r26, 0x1f	; 31
    4a64:	80 e0       	ldi	r24, 0x00	; 0
    4a66:	0e 94 bf 23 	call	0x477e	; 0x477e <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4a6a:	82 e0       	ldi	r24, 0x02	; 2
    4a6c:	60 e0       	ldi	r22, 0x00	; 0
    4a6e:	20 e0       	ldi	r18, 0x00	; 0
    4a70:	30 e0       	ldi	r19, 0x00	; 0
    4a72:	a9 01       	movw	r20, r18
    4a74:	0e 94 c0 20 	call	0x4180	; 0x4180 <getSetFreeCluster>
    4a78:	dc 01       	movw	r26, r24
    4a7a:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4a7c:	48 16       	cp	r4, r24
    4a7e:	59 06       	cpc	r5, r25
    4a80:	6a 06       	cpc	r6, r26
    4a82:	7b 06       	cpc	r7, r27
    4a84:	30 f4       	brcc	.+12     	; 0x4a92 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4a86:	82 e0       	ldi	r24, 0x02	; 2
    4a88:	61 e0       	ldi	r22, 0x01	; 1
    4a8a:	a3 01       	movw	r20, r6
    4a8c:	92 01       	movw	r18, r4
    4a8e:	0e 94 c0 20 	call	0x4180	; 0x4180 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4a92:	c3 01       	movw	r24, r6
    4a94:	b2 01       	movw	r22, r4
    4a96:	40 e0       	ldi	r20, 0x00	; 0
    4a98:	00 e0       	ldi	r16, 0x00	; 0
    4a9a:	10 e0       	ldi	r17, 0x00	; 0
    4a9c:	98 01       	movw	r18, r16
    4a9e:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
    4aa2:	6b 01       	movw	r12, r22
    4aa4:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4aa6:	c3 01       	movw	r24, r6
    4aa8:	b2 01       	movw	r22, r4
    4aaa:	41 e0       	ldi	r20, 0x01	; 1
    4aac:	00 e0       	ldi	r16, 0x00	; 0
    4aae:	10 e0       	ldi	r17, 0x00	; 0
    4ab0:	98 01       	movw	r18, r16
    4ab2:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4ab6:	b7 ef       	ldi	r27, 0xF7	; 247
    4ab8:	cb 16       	cp	r12, r27
    4aba:	bf ef       	ldi	r27, 0xFF	; 255
    4abc:	db 06       	cpc	r13, r27
    4abe:	bf ef       	ldi	r27, 0xFF	; 255
    4ac0:	eb 06       	cpc	r14, r27
    4ac2:	bf e0       	ldi	r27, 0x0F	; 15
    4ac4:	fb 06       	cpc	r15, r27
    4ac6:	08 f0       	brcs	.+2      	; 0x4aca <findFiles+0x270>
    4ac8:	47 c0       	rjmp	.+142    	; 0x4b58 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4aca:	26 01       	movw	r4, r12
    4acc:	37 01       	movw	r6, r14
    4ace:	e1 cf       	rjmp	.-62     	; 0x4a92 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4ad0:	20 5e       	subi	r18, 0xE0	; 224
    4ad2:	3f 4f       	sbci	r19, 0xFF	; 255
    4ad4:	80 91 55 40 	lds	r24, 0x4055
    4ad8:	90 91 56 40 	lds	r25, 0x4056
    4adc:	28 17       	cp	r18, r24
    4ade:	39 07       	cpc	r19, r25
    4ae0:	08 f4       	brcc	.+2      	; 0x4ae4 <findFiles+0x28a>
    4ae2:	26 cf       	rjmp	.-436    	; 0x4930 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4ae4:	08 94       	sec
    4ae6:	41 1c       	adc	r4, r1
    4ae8:	51 1c       	adc	r5, r1
    4aea:	61 1c       	adc	r6, r1
    4aec:	71 1c       	adc	r7, r1
    4aee:	80 91 69 50 	lds	r24, 0x5069
    4af2:	90 91 6a 50 	lds	r25, 0x506A
    4af6:	a0 e0       	ldi	r26, 0x00	; 0
    4af8:	b0 e0       	ldi	r27, 0x00	; 0
    4afa:	48 16       	cp	r4, r24
    4afc:	59 06       	cpc	r5, r25
    4afe:	6a 06       	cpc	r6, r26
    4b00:	7b 06       	cpc	r7, r27
    4b02:	08 f4       	brcc	.+2      	; 0x4b06 <findFiles+0x2ac>
    4b04:	f2 ce       	rjmp	.-540    	; 0x48ea <findFiles+0x90>
    4b06:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4b08:	69 85       	ldd	r22, Y+9	; 0x09
    4b0a:	7a 85       	ldd	r23, Y+10	; 0x0a
    4b0c:	8b 85       	ldd	r24, Y+11	; 0x0b
    4b0e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4b10:	40 e0       	ldi	r20, 0x00	; 0
    4b12:	00 e0       	ldi	r16, 0x00	; 0
    4b14:	10 e0       	ldi	r17, 0x00	; 0
    4b16:	98 01       	movw	r18, r16
    4b18:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
    4b1c:	69 87       	std	Y+9, r22	; 0x09
    4b1e:	7a 87       	std	Y+10, r23	; 0x0a
    4b20:	8b 87       	std	Y+11, r24	; 0x0b
    4b22:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4b24:	67 3f       	cpi	r22, 0xF7	; 247
    4b26:	ef ef       	ldi	r30, 0xFF	; 255
    4b28:	7e 07       	cpc	r23, r30
    4b2a:	ef ef       	ldi	r30, 0xFF	; 255
    4b2c:	8e 07       	cpc	r24, r30
    4b2e:	ef e0       	ldi	r30, 0x0F	; 15
    4b30:	9e 07       	cpc	r25, r30
    4b32:	a8 f4       	brcc	.+42     	; 0x4b5e <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4b34:	61 15       	cp	r22, r1
    4b36:	71 05       	cpc	r23, r1
    4b38:	81 05       	cpc	r24, r1
    4b3a:	91 05       	cpc	r25, r1
    4b3c:	09 f0       	breq	.+2      	; 0x4b40 <findFiles+0x2e6>
    4b3e:	c0 ce       	rjmp	.-640    	; 0x48c0 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4b40:	00 e0       	ldi	r16, 0x00	; 0
    4b42:	10 e0       	ldi	r17, 0x00	; 0
    4b44:	0e c0       	rjmp	.+28     	; 0x4b62 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4b46:	00 e0       	ldi	r16, 0x00	; 0
    4b48:	10 e0       	ldi	r17, 0x00	; 0
    4b4a:	0b c0       	rjmp	.+22     	; 0x4b62 <findFiles+0x308>
    4b4c:	00 e0       	ldi	r16, 0x00	; 0
    4b4e:	10 e0       	ldi	r17, 0x00	; 0
    4b50:	08 c0       	rjmp	.+16     	; 0x4b62 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4b52:	00 e0       	ldi	r16, 0x00	; 0
    4b54:	10 e0       	ldi	r17, 0x00	; 0
    4b56:	05 c0       	rjmp	.+10     	; 0x4b62 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4b58:	00 e0       	ldi	r16, 0x00	; 0
    4b5a:	10 e0       	ldi	r17, 0x00	; 0
    4b5c:	02 c0       	rjmp	.+4      	; 0x4b62 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4b5e:	00 e0       	ldi	r16, 0x00	; 0
    4b60:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4b62:	80 2f       	mov	r24, r16
    4b64:	91 2f       	mov	r25, r17
    4b66:	2c 96       	adiw	r28, 0x0c	; 12
    4b68:	cd bf       	out	0x3d, r28	; 61
    4b6a:	de bf       	out	0x3e, r29	; 62
    4b6c:	df 91       	pop	r29
    4b6e:	cf 91       	pop	r28
    4b70:	1f 91       	pop	r17
    4b72:	0f 91       	pop	r16
    4b74:	ff 90       	pop	r15
    4b76:	ef 90       	pop	r14
    4b78:	df 90       	pop	r13
    4b7a:	cf 90       	pop	r12
    4b7c:	bf 90       	pop	r11
    4b7e:	af 90       	pop	r10
    4b80:	9f 90       	pop	r9
    4b82:	8f 90       	pop	r8
    4b84:	7f 90       	pop	r7
    4b86:	6f 90       	pop	r6
    4b88:	5f 90       	pop	r5
    4b8a:	4f 90       	pop	r4
    4b8c:	3f 90       	pop	r3
    4b8e:	2f 90       	pop	r2
    4b90:	08 95       	ret

00004b92 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4b92:	0e 94 4d 22 	call	0x449a	; 0x449a <convertFileName>
  if(error) return;
    4b96:	88 23       	and	r24, r24
    4b98:	29 f4       	brne	.+10     	; 0x4ba4 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4b9a:	82 e0       	ldi	r24, 0x02	; 2
    4b9c:	61 e9       	ldi	r22, 0x91	; 145
    4b9e:	70 e5       	ldi	r23, 0x50	; 80
    4ba0:	0e 94 2d 24 	call	0x485a	; 0x485a <findFiles>
    4ba4:	08 95       	ret

00004ba6 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4ba6:	4f 92       	push	r4
    4ba8:	5f 92       	push	r5
    4baa:	6f 92       	push	r6
    4bac:	7f 92       	push	r7
    4bae:	af 92       	push	r10
    4bb0:	bf 92       	push	r11
    4bb2:	cf 92       	push	r12
    4bb4:	df 92       	push	r13
    4bb6:	ef 92       	push	r14
    4bb8:	ff 92       	push	r15
    4bba:	0f 93       	push	r16
    4bbc:	1f 93       	push	r17
    4bbe:	cf 93       	push	r28
    4bc0:	c8 2f       	mov	r28, r24
    4bc2:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4bc4:	0e 94 4d 22 	call	0x449a	; 0x449a <convertFileName>
if(error) return 2;
    4bc8:	88 23       	and	r24, r24
    4bca:	09 f0       	breq	.+2      	; 0x4bce <readFile+0x28>
    4bcc:	57 c0       	rjmp	.+174    	; 0x4c7c <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4bce:	81 e0       	ldi	r24, 0x01	; 1
    4bd0:	61 e9       	ldi	r22, 0x91	; 145
    4bd2:	70 e5       	ldi	r23, 0x50	; 80
    4bd4:	0e 94 2d 24 	call	0x485a	; 0x485a <findFiles>
    4bd8:	fc 01       	movw	r30, r24
if(dir == 0) 
    4bda:	00 97       	sbiw	r24, 0x00	; 0
    4bdc:	31 f4       	brne	.+12     	; 0x4bea <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4bde:	81 e0       	ldi	r24, 0x01	; 1
    4be0:	cc 23       	and	r28, r28
    4be2:	09 f4       	brne	.+2      	; 0x4be6 <readFile+0x40>
    4be4:	4e c0       	rjmp	.+156    	; 0x4c82 <readFile+0xdc>
    4be6:	80 e0       	ldi	r24, 0x00	; 0
    4be8:	4c c0       	rjmp	.+152    	; 0x4c82 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4bea:	c1 30       	cpi	r28, 0x01	; 1
    4bec:	09 f4       	brne	.+2      	; 0x4bf0 <readFile+0x4a>
    4bee:	48 c0       	rjmp	.+144    	; 0x4c80 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4bf0:	44 88       	ldd	r4, Z+20	; 0x14
    4bf2:	55 88       	ldd	r5, Z+21	; 0x15
    4bf4:	66 24       	eor	r6, r6
    4bf6:	77 24       	eor	r7, r7
    4bf8:	32 01       	movw	r6, r4
    4bfa:	55 24       	eor	r5, r5
    4bfc:	44 24       	eor	r4, r4
    4bfe:	82 8d       	ldd	r24, Z+26	; 0x1a
    4c00:	93 8d       	ldd	r25, Z+27	; 0x1b
    4c02:	a0 e0       	ldi	r26, 0x00	; 0
    4c04:	b0 e0       	ldi	r27, 0x00	; 0
    4c06:	48 2a       	or	r4, r24
    4c08:	59 2a       	or	r5, r25
    4c0a:	6a 2a       	or	r6, r26
    4c0c:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4c0e:	0f 2e       	mov	r0, r31
    4c10:	fc ea       	ldi	r31, 0xAC	; 172
    4c12:	af 2e       	mov	r10, r31
    4c14:	f1 e2       	ldi	r31, 0x21	; 33
    4c16:	bf 2e       	mov	r11, r31
    4c18:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4c1a:	c3 01       	movw	r24, r6
    4c1c:	b2 01       	movw	r22, r4
    4c1e:	0e 94 07 20 	call	0x400e	; 0x400e <getFirstSector>
    4c22:	6b 01       	movw	r12, r22
    4c24:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4c26:	80 91 69 50 	lds	r24, 0x5069
    4c2a:	90 91 6a 50 	lds	r25, 0x506A
    4c2e:	00 97       	sbiw	r24, 0x00	; 0
    4c30:	a1 f0       	breq	.+40     	; 0x4c5a <readFile+0xb4>
    4c32:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4c34:	c7 01       	movw	r24, r14
    4c36:	b6 01       	movw	r22, r12
    4c38:	6c 0f       	add	r22, r28
    4c3a:	71 1d       	adc	r23, r1
    4c3c:	81 1d       	adc	r24, r1
    4c3e:	91 1d       	adc	r25, r1
    4c40:	a5 01       	movw	r20, r10
    4c42:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4c46:	cf 5f       	subi	r28, 0xFF	; 255
    4c48:	80 91 69 50 	lds	r24, 0x5069
    4c4c:	90 91 6a 50 	lds	r25, 0x506A
    4c50:	2c 2f       	mov	r18, r28
    4c52:	30 e0       	ldi	r19, 0x00	; 0
    4c54:	28 17       	cp	r18, r24
    4c56:	39 07       	cpc	r19, r25
    4c58:	68 f3       	brcs	.-38     	; 0x4c34 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4c5a:	c3 01       	movw	r24, r6
    4c5c:	b2 01       	movw	r22, r4
    4c5e:	40 e0       	ldi	r20, 0x00	; 0
    4c60:	00 e0       	ldi	r16, 0x00	; 0
    4c62:	10 e0       	ldi	r17, 0x00	; 0
    4c64:	98 01       	movw	r18, r16
    4c66:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
    4c6a:	2b 01       	movw	r4, r22
    4c6c:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4c6e:	61 15       	cp	r22, r1
    4c70:	71 05       	cpc	r23, r1
    4c72:	81 05       	cpc	r24, r1
    4c74:	91 05       	cpc	r25, r1
    4c76:	89 f6       	brne	.-94     	; 0x4c1a <readFile+0x74>
	  return 0;}
    4c78:	80 e0       	ldi	r24, 0x00	; 0
    4c7a:	03 c0       	rjmp	.+6      	; 0x4c82 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4c7c:	82 e0       	ldi	r24, 0x02	; 2
    4c7e:	01 c0       	rjmp	.+2      	; 0x4c82 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4c80:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4c82:	cf 91       	pop	r28
    4c84:	1f 91       	pop	r17
    4c86:	0f 91       	pop	r16
    4c88:	ff 90       	pop	r15
    4c8a:	ef 90       	pop	r14
    4c8c:	df 90       	pop	r13
    4c8e:	cf 90       	pop	r12
    4c90:	bf 90       	pop	r11
    4c92:	af 90       	pop	r10
    4c94:	7f 90       	pop	r7
    4c96:	6f 90       	pop	r6
    4c98:	5f 90       	pop	r5
    4c9a:	4f 90       	pop	r4
    4c9c:	08 95       	ret

00004c9e <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4c9e:	2f 92       	push	r2
    4ca0:	3f 92       	push	r3
    4ca2:	4f 92       	push	r4
    4ca4:	5f 92       	push	r5
    4ca6:	6f 92       	push	r6
    4ca8:	7f 92       	push	r7
    4caa:	8f 92       	push	r8
    4cac:	9f 92       	push	r9
    4cae:	af 92       	push	r10
    4cb0:	bf 92       	push	r11
    4cb2:	cf 92       	push	r12
    4cb4:	df 92       	push	r13
    4cb6:	ef 92       	push	r14
    4cb8:	ff 92       	push	r15
    4cba:	0f 93       	push	r16
    4cbc:	1f 93       	push	r17
    4cbe:	cf 93       	push	r28
    4cc0:	df 93       	push	r29
    4cc2:	cd b7       	in	r28, 0x3d	; 61
    4cc4:	de b7       	in	r29, 0x3e	; 62
    4cc6:	60 97       	sbiw	r28, 0x10	; 16
    4cc8:	cd bf       	out	0x3d, r28	; 61
    4cca:	de bf       	out	0x3e, r29	; 62
    4ccc:	fc 01       	movw	r30, r24
    4cce:	6d 83       	std	Y+5, r22	; 0x05
    4cd0:	7e 83       	std	Y+6, r23	; 0x06
    4cd2:	49 01       	movw	r8, r18
    4cd4:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4cd6:	81 e0       	ldi	r24, 0x01	; 1
    4cd8:	bf 01       	movw	r22, r30
    4cda:	0e 94 d3 25 	call	0x4ba6	; 0x4ba6 <readFile>

if(j == 1) 
    4cde:	81 30       	cpi	r24, 0x01	; 1
    4ce0:	09 f0       	breq	.+2      	; 0x4ce4 <writeFile+0x46>
    4ce2:	7b c0       	rjmp	.+246    	; 0x4dda <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4ce4:	00 91 73 50 	lds	r16, 0x5073
    4ce8:	10 91 74 50 	lds	r17, 0x5074
    4cec:	20 91 75 50 	lds	r18, 0x5075
    4cf0:	30 91 76 50 	lds	r19, 0x5076
    4cf4:	09 83       	std	Y+1, r16	; 0x01
    4cf6:	1a 83       	std	Y+2, r17	; 0x02
    4cf8:	2b 83       	std	Y+3, r18	; 0x03
    4cfa:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4cfc:	cc 24       	eor	r12, r12
    4cfe:	dd 24       	eor	r13, r13
    4d00:	76 01       	movw	r14, r12
    4d02:	24 01       	movw	r4, r8
    4d04:	35 01       	movw	r6, r10
    4d06:	48 01       	movw	r8, r16
    4d08:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4d0a:	c5 01       	movw	r24, r10
    4d0c:	b4 01       	movw	r22, r8
    4d0e:	40 e0       	ldi	r20, 0x00	; 0
    4d10:	00 e0       	ldi	r16, 0x00	; 0
    4d12:	10 e0       	ldi	r17, 0x00	; 0
    4d14:	98 01       	movw	r18, r16
    4d16:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
    4d1a:	dc 01       	movw	r26, r24
    4d1c:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4d1e:	8f 3f       	cpi	r24, 0xFF	; 255
    4d20:	1f ef       	ldi	r17, 0xFF	; 255
    4d22:	91 07       	cpc	r25, r17
    4d24:	1f ef       	ldi	r17, 0xFF	; 255
    4d26:	a1 07       	cpc	r26, r17
    4d28:	1f ef       	ldi	r17, 0xFF	; 255
    4d2a:	b1 07       	cpc	r27, r17
    4d2c:	41 f0       	breq	.+16     	; 0x4d3e <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4d2e:	08 94       	sec
    4d30:	c1 1c       	adc	r12, r1
    4d32:	d1 1c       	adc	r13, r1
    4d34:	e1 1c       	adc	r14, r1
    4d36:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4d38:	4c 01       	movw	r8, r24
    4d3a:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4d3c:	e6 cf       	rjmp	.-52     	; 0x4d0a <writeFile+0x6c>
    4d3e:	89 82       	std	Y+1, r8	; 0x01
    4d40:	9a 82       	std	Y+2, r9	; 0x02
    4d42:	ab 82       	std	Y+3, r10	; 0x03
    4d44:	bc 82       	std	Y+4, r11	; 0x04
    4d46:	53 01       	movw	r10, r6
    4d48:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4d4a:	20 91 69 50 	lds	r18, 0x5069
    4d4e:	30 91 6a 50 	lds	r19, 0x506A
    4d52:	80 91 55 40 	lds	r24, 0x4055
    4d56:	90 91 56 40 	lds	r25, 0x4056
    4d5a:	60 90 55 40 	lds	r6, 0x4055
    4d5e:	70 90 56 40 	lds	r7, 0x4056
    4d62:	bc 01       	movw	r22, r24
    4d64:	80 e0       	ldi	r24, 0x00	; 0
    4d66:	90 e0       	ldi	r25, 0x00	; 0
    4d68:	40 e0       	ldi	r20, 0x00	; 0
    4d6a:	50 e0       	ldi	r21, 0x00	; 0
    4d6c:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    4d70:	a7 01       	movw	r20, r14
    4d72:	96 01       	movw	r18, r12
    4d74:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    4d78:	dc 01       	movw	r26, r24
    4d7a:	cb 01       	movw	r24, r22
    4d7c:	40 91 51 40 	lds	r20, 0x4051
    4d80:	50 91 52 40 	lds	r21, 0x4052
    4d84:	60 91 53 40 	lds	r22, 0x4053
    4d88:	70 91 54 40 	lds	r23, 0x4054
    4d8c:	8a 01       	movw	r16, r20
    4d8e:	9b 01       	movw	r18, r22
    4d90:	08 1b       	sub	r16, r24
    4d92:	19 0b       	sbc	r17, r25
    4d94:	2a 0b       	sbc	r18, r26
    4d96:	3b 0b       	sbc	r19, r27
    4d98:	c9 01       	movw	r24, r18
    4d9a:	b8 01       	movw	r22, r16
    4d9c:	93 01       	movw	r18, r6
    4d9e:	40 e0       	ldi	r20, 0x00	; 0
    4da0:	50 e0       	ldi	r21, 0x00	; 0
    4da2:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    4da6:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4da8:	69 81       	ldd	r22, Y+1	; 0x01
    4daa:	7a 81       	ldd	r23, Y+2	; 0x02
    4dac:	8b 81       	ldd	r24, Y+3	; 0x03
    4dae:	9c 81       	ldd	r25, Y+4	; 0x04
    4db0:	0e 94 07 20 	call	0x400e	; 0x400e <getFirstSector>
    4db4:	dc 01       	movw	r26, r24
    4db6:	cb 01       	movw	r24, r22
    4db8:	20 2e       	mov	r2, r16
    4dba:	33 24       	eor	r3, r3
    4dbc:	28 0e       	add	r2, r24
    4dbe:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4dc0:	b1 01       	movw	r22, r2
    4dc2:	80 e0       	ldi	r24, 0x00	; 0
    4dc4:	90 e0       	ldi	r25, 0x00	; 0
    4dc6:	48 e4       	ldi	r20, 0x48	; 72
    4dc8:	5e e3       	ldi	r21, 0x3E	; 62
    4dca:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4dce:	1f 86       	std	Y+15, r1	; 0x0f
    4dd0:	18 8a       	std	Y+16, r1	; 0x10
    4dd2:	19 86       	std	Y+9, r1	; 0x09
    4dd4:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4dd6:	11 e0       	ldi	r17, 0x01	; 1
    4dd8:	4c c0       	rjmp	.+152    	; 0x4e72 <writeFile+0x1d4>
}
else if(j == 2) 
    4dda:	82 30       	cpi	r24, 0x02	; 2
    4ddc:	09 f4       	brne	.+2      	; 0x4de0 <writeFile+0x142>
    4dde:	0c c2       	rjmp	.+1048   	; 0x51f8 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4de0:	82 e0       	ldi	r24, 0x02	; 2
    4de2:	60 e0       	ldi	r22, 0x00	; 0
    4de4:	20 e0       	ldi	r18, 0x00	; 0
    4de6:	30 e0       	ldi	r19, 0x00	; 0
    4de8:	a9 01       	movw	r20, r18
    4dea:	0e 94 c0 20 	call	0x4180	; 0x4180 <getSetFreeCluster>
  if(cluster > totalClusters)
    4dee:	00 91 58 40 	lds	r16, 0x4058
    4df2:	10 91 59 40 	lds	r17, 0x4059
    4df6:	20 91 5a 40 	lds	r18, 0x405A
    4dfa:	30 91 5b 40 	lds	r19, 0x405B
    4dfe:	06 17       	cp	r16, r22
    4e00:	17 07       	cpc	r17, r23
    4e02:	28 07       	cpc	r18, r24
    4e04:	39 07       	cpc	r19, r25
    4e06:	40 f4       	brcc	.+16     	; 0x4e18 <writeFile+0x17a>
     cluster = rootCluster;
    4e08:	60 91 5d 40 	lds	r22, 0x405D
    4e0c:	70 91 5e 40 	lds	r23, 0x405E
    4e10:	80 91 5f 40 	lds	r24, 0x405F
    4e14:	90 91 60 40 	lds	r25, 0x4060

  cluster = searchNextFreeCluster(cluster);
    4e18:	0e 94 0c 23 	call	0x4618	; 0x4618 <searchNextFreeCluster>
    4e1c:	69 83       	std	Y+1, r22	; 0x01
    4e1e:	7a 83       	std	Y+2, r23	; 0x02
    4e20:	8b 83       	std	Y+3, r24	; 0x03
    4e22:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4e24:	61 15       	cp	r22, r1
    4e26:	71 05       	cpc	r23, r1
    4e28:	81 05       	cpc	r24, r1
    4e2a:	91 05       	cpc	r25, r1
    4e2c:	09 f4       	brne	.+2      	; 0x4e30 <writeFile+0x192>
    4e2e:	e6 c1       	rjmp	.+972    	; 0x51fc <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4e30:	41 e0       	ldi	r20, 0x01	; 1
    4e32:	0f ef       	ldi	r16, 0xFF	; 255
    4e34:	1f ef       	ldi	r17, 0xFF	; 255
    4e36:	98 01       	movw	r18, r16
    4e38:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4e3c:	2b 81       	ldd	r18, Y+3	; 0x03
    4e3e:	3c 81       	ldd	r19, Y+4	; 0x04
    4e40:	29 87       	std	Y+9, r18	; 0x09
    4e42:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4e44:	89 81       	ldd	r24, Y+1	; 0x01
    4e46:	9a 81       	ldd	r25, Y+2	; 0x02
    4e48:	8f 87       	std	Y+15, r24	; 0x0f
    4e4a:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4e4c:	10 92 51 40 	sts	0x4051, r1
    4e50:	10 92 52 40 	sts	0x4052, r1
    4e54:	10 92 53 40 	sts	0x4053, r1
    4e58:	10 92 54 40 	sts	0x4054, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4e5c:	69 81       	ldd	r22, Y+1	; 0x01
    4e5e:	7a 81       	ldd	r23, Y+2	; 0x02
    4e60:	8b 81       	ldd	r24, Y+3	; 0x03
    4e62:	9c 81       	ldd	r25, Y+4	; 0x04
    4e64:	0e 94 07 20 	call	0x400e	; 0x400e <getFirstSector>
    4e68:	dc 01       	movw	r26, r24
    4e6a:	cb 01       	movw	r24, r22
    4e6c:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4e6e:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4e70:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4e72:	81 14       	cp	r8, r1
    4e74:	91 04       	cpc	r9, r1
    4e76:	a1 04       	cpc	r10, r1
    4e78:	b1 04       	cpc	r11, r1
    4e7a:	09 f4       	brne	.+2      	; 0x4e7e <writeFile+0x1e0>
    4e7c:	8d c0       	rjmp	.+282    	; 0x4f98 <writeFile+0x2fa>
    4e7e:	44 24       	eor	r4, r4
    4e80:	55 24       	eor	r5, r5
    4e82:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4e84:	c0 2e       	mov	r12, r16
    4e86:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4e88:	90 e0       	ldi	r25, 0x00	; 0
    4e8a:	89 16       	cp	r8, r25
    4e8c:	92 e0       	ldi	r25, 0x02	; 2
    4e8e:	99 06       	cpc	r9, r25
    4e90:	90 e0       	ldi	r25, 0x00	; 0
    4e92:	a9 06       	cpc	r10, r25
    4e94:	90 e0       	ldi	r25, 0x00	; 0
    4e96:	b9 06       	cpc	r11, r25
    4e98:	88 f0       	brcs	.+34     	; 0x4ebc <writeFile+0x21e>
		 writtenData += 512;
    4e9a:	00 e0       	ldi	r16, 0x00	; 0
    4e9c:	12 e0       	ldi	r17, 0x02	; 2
    4e9e:	20 e0       	ldi	r18, 0x00	; 0
    4ea0:	30 e0       	ldi	r19, 0x00	; 0
    4ea2:	40 0e       	add	r4, r16
    4ea4:	51 1e       	adc	r5, r17
    4ea6:	62 1e       	adc	r6, r18
    4ea8:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4eaa:	80 e0       	ldi	r24, 0x00	; 0
    4eac:	9e ef       	ldi	r25, 0xFE	; 254
    4eae:	af ef       	ldi	r26, 0xFF	; 255
    4eb0:	bf ef       	ldi	r27, 0xFF	; 255
    4eb2:	88 0e       	add	r8, r24
    4eb4:	99 1e       	adc	r9, r25
    4eb6:	aa 1e       	adc	r10, r26
    4eb8:	bb 1e       	adc	r11, r27
    4eba:	0c c0       	rjmp	.+24     	; 0x4ed4 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4ebc:	48 0c       	add	r4, r8
    4ebe:	59 1c       	adc	r5, r9
    4ec0:	6a 1c       	adc	r6, r10
    4ec2:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4ec4:	95 01       	movw	r18, r10
    4ec6:	84 01       	movw	r16, r8
    4ec8:	11 70       	andi	r17, 0x01	; 1
    4eca:	20 70       	andi	r18, 0x00	; 0
    4ecc:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4ece:	88 24       	eor	r8, r8
    4ed0:	99 24       	eor	r9, r9
    4ed2:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4ed4:	80 91 51 40 	lds	r24, 0x4051
    4ed8:	90 91 52 40 	lds	r25, 0x4052
    4edc:	a0 91 53 40 	lds	r26, 0x4053
    4ee0:	b0 91 54 40 	lds	r27, 0x4054
    4ee4:	80 50       	subi	r24, 0x00	; 0
    4ee6:	9e 4f       	sbci	r25, 0xFE	; 254
    4ee8:	af 4f       	sbci	r26, 0xFF	; 255
    4eea:	bf 4f       	sbci	r27, 0xFF	; 255
    4eec:	80 93 51 40 	sts	0x4051, r24
    4ef0:	90 93 52 40 	sts	0x4052, r25
    4ef4:	a0 93 53 40 	sts	0x4053, r26
    4ef8:	b0 93 54 40 	sts	0x4054, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4efc:	b1 01       	movw	r22, r2
    4efe:	80 e0       	ldi	r24, 0x00	; 0
    4f00:	90 e0       	ldi	r25, 0x00	; 0
    4f02:	a2 01       	movw	r20, r4
    4f04:	40 1b       	sub	r20, r16
    4f06:	51 0b       	sbc	r21, r17
    4f08:	ad 81       	ldd	r26, Y+5	; 0x05
    4f0a:	be 81       	ldd	r27, Y+6	; 0x06
    4f0c:	4a 0f       	add	r20, r26
    4f0e:	5b 1f       	adc	r21, r27
    4f10:	98 01       	movw	r18, r16
    4f12:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <SD_write_block>
	j++;
    4f16:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4f18:	20 91 69 50 	lds	r18, 0x5069
    4f1c:	30 91 6a 50 	lds	r19, 0x506A
    4f20:	8c 2d       	mov	r24, r12
    4f22:	90 e0       	ldi	r25, 0x00	; 0
    4f24:	82 17       	cp	r24, r18
    4f26:	93 07       	cpc	r25, r19
    4f28:	29 f5       	brne	.+74     	; 0x4f74 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4f2a:	69 81       	ldd	r22, Y+1	; 0x01
    4f2c:	7a 81       	ldd	r23, Y+2	; 0x02
    4f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f30:	9c 81       	ldd	r25, Y+4	; 0x04
    4f32:	0e 94 0c 23 	call	0x4618	; 0x4618 <searchNextFreeCluster>
    4f36:	6b 01       	movw	r12, r22
    4f38:	7c 01       	movw	r14, r24
		if(cluster == 0){
    4f3a:	61 15       	cp	r22, r1
    4f3c:	71 05       	cpc	r23, r1
    4f3e:	81 05       	cpc	r24, r1
    4f40:	91 05       	cpc	r25, r1
    4f42:	09 f4       	brne	.+2      	; 0x4f46 <writeFile+0x2a8>
    4f44:	5d c1       	rjmp	.+698    	; 0x5200 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    4f46:	69 81       	ldd	r22, Y+1	; 0x01
    4f48:	7a 81       	ldd	r23, Y+2	; 0x02
    4f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4f4e:	41 e0       	ldi	r20, 0x01	; 1
    4f50:	97 01       	movw	r18, r14
    4f52:	86 01       	movw	r16, r12
    4f54:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    4f58:	c7 01       	movw	r24, r14
    4f5a:	b6 01       	movw	r22, r12
    4f5c:	41 e0       	ldi	r20, 0x01	; 1
    4f5e:	0f ef       	ldi	r16, 0xFF	; 255
    4f60:	1f ef       	ldi	r17, 0xFF	; 255
    4f62:	98 01       	movw	r18, r16
    4f64:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4f68:	c9 82       	std	Y+1, r12	; 0x01
    4f6a:	da 82       	std	Y+2, r13	; 0x02
    4f6c:	eb 82       	std	Y+3, r14	; 0x03
    4f6e:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    4f70:	cc 24       	eor	r12, r12
    4f72:	03 c0       	rjmp	.+6      	; 0x4f7a <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    4f74:	08 94       	sec
    4f76:	21 1c       	adc	r2, r1
    4f78:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    4f7a:	82 e0       	ldi	r24, 0x02	; 2
    4f7c:	61 e0       	ldi	r22, 0x01	; 1
    4f7e:	29 81       	ldd	r18, Y+1	; 0x01
    4f80:	3a 81       	ldd	r19, Y+2	; 0x02
    4f82:	4b 81       	ldd	r20, Y+3	; 0x03
    4f84:	5c 81       	ldd	r21, Y+4	; 0x04
    4f86:	0e 94 c0 20 	call	0x4180	; 0x4180 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4f8a:	81 14       	cp	r8, r1
    4f8c:	91 04       	cpc	r9, r1
    4f8e:	a1 04       	cpc	r10, r1
    4f90:	b1 04       	cpc	r11, r1
    4f92:	09 f0       	breq	.+2      	; 0x4f96 <writeFile+0x2f8>
    4f94:	79 cf       	rjmp	.-270    	; 0x4e88 <writeFile+0x1ea>
    4f96:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    4f98:	11 23       	and	r17, r17
    4f9a:	09 f4       	brne	.+2      	; 0x4f9e <writeFile+0x300>
    4f9c:	3f c0       	rjmp	.+126    	; 0x501c <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    4f9e:	60 91 a2 50 	lds	r22, 0x50A2
    4fa2:	70 91 a3 50 	lds	r23, 0x50A3
    4fa6:	80 91 a4 50 	lds	r24, 0x50A4
    4faa:	90 91 a5 50 	lds	r25, 0x50A5
    4fae:	08 e4       	ldi	r16, 0x48	; 72
    4fb0:	1e e3       	ldi	r17, 0x3E	; 62
    4fb2:	a8 01       	movw	r20, r16
    4fb4:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4fb8:	e0 91 49 40 	lds	r30, 0x4049
    4fbc:	f0 91 4a 40 	lds	r31, 0x404A
    4fc0:	e0 0f       	add	r30, r16
    4fc2:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4fc4:	12 8a       	std	Z+18, r1	; 0x12
    4fc6:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4fc8:	80 91 51 40 	lds	r24, 0x4051
    4fcc:	90 91 52 40 	lds	r25, 0x4052
    4fd0:	a0 91 53 40 	lds	r26, 0x4053
    4fd4:	b0 91 54 40 	lds	r27, 0x4054
    4fd8:	44 8d       	ldd	r20, Z+28	; 0x1c
    4fda:	55 8d       	ldd	r21, Z+29	; 0x1d
    4fdc:	66 8d       	ldd	r22, Z+30	; 0x1e
    4fde:	77 8d       	ldd	r23, Z+31	; 0x1f
    4fe0:	6c 01       	movw	r12, r24
    4fe2:	7d 01       	movw	r14, r26
    4fe4:	c4 1a       	sub	r12, r20
    4fe6:	d5 0a       	sbc	r13, r21
    4fe8:	e6 0a       	sbc	r14, r22
    4fea:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4fec:	84 8f       	std	Z+28, r24	; 0x1c
    4fee:	95 8f       	std	Z+29, r25	; 0x1d
    4ff0:	a6 8f       	std	Z+30, r26	; 0x1e
    4ff2:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4ff4:	60 91 a2 50 	lds	r22, 0x50A2
    4ff8:	70 91 a3 50 	lds	r23, 0x50A3
    4ffc:	80 91 a4 50 	lds	r24, 0x50A4
    5000:	90 91 a5 50 	lds	r25, 0x50A5
    5004:	a8 01       	movw	r20, r16
    5006:	20 e0       	ldi	r18, 0x00	; 0
    5008:	32 e0       	ldi	r19, 0x02	; 2
    500a:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    500e:	81 e0       	ldi	r24, 0x01	; 1
    5010:	b7 01       	movw	r22, r14
    5012:	a6 01       	movw	r20, r12
    5014:	0e 94 bf 23 	call	0x477e	; 0x477e <freeMemoryUpdate>

 //File appended!
  return 0;
    5018:	80 e0       	ldi	r24, 0x00	; 0
    501a:	f9 c0       	rjmp	.+498    	; 0x520e <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    501c:	00 91 5d 40 	lds	r16, 0x405D
    5020:	10 91 5e 40 	lds	r17, 0x405E
    5024:	20 91 5f 40 	lds	r18, 0x405F
    5028:	30 91 60 40 	lds	r19, 0x4060
    502c:	0b 87       	std	Y+11, r16	; 0x0b
    502e:	1c 87       	std	Y+12, r17	; 0x0c
    5030:	2d 87       	std	Y+13, r18	; 0x0d
    5032:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    5034:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5036:	81 e9       	ldi	r24, 0x91	; 145
    5038:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    503a:	0f 2e       	mov	r0, r31
    503c:	fb e0       	ldi	r31, 0x0B	; 11
    503e:	af 2e       	mov	r10, r31
    5040:	bb 24       	eor	r11, r11
    5042:	f0 2d       	mov	r31, r0
    5044:	a8 0e       	add	r10, r24
    5046:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    5048:	88 24       	eor	r8, r8
    504a:	68 94       	set
    504c:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    504e:	0f 2e       	mov	r0, r31
    5050:	f8 e4       	ldi	r31, 0x48	; 72
    5052:	4f 2e       	mov	r4, r31
    5054:	fe e3       	ldi	r31, 0x3E	; 62
    5056:	5f 2e       	mov	r5, r31
    5058:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    505a:	28 2e       	mov	r2, r24
    505c:	99 2e       	mov	r9, r25
    505e:	37 2c       	mov	r3, r7
    5060:	6f 84       	ldd	r6, Y+15	; 0x0f
    5062:	78 88       	ldd	r7, Y+16	; 0x10
    5064:	04 c0       	rjmp	.+8      	; 0x506e <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    5066:	cb 86       	std	Y+11, r12	; 0x0b
    5068:	dc 86       	std	Y+12, r13	; 0x0c
    506a:	ed 86       	std	Y+13, r14	; 0x0d
    506c:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    506e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5070:	7c 85       	ldd	r23, Y+12	; 0x0c
    5072:	8d 85       	ldd	r24, Y+13	; 0x0d
    5074:	9e 85       	ldd	r25, Y+14	; 0x0e
    5076:	0e 94 07 20 	call	0x400e	; 0x400e <getFirstSector>
    507a:	6d 83       	std	Y+5, r22	; 0x05
    507c:	7e 83       	std	Y+6, r23	; 0x06
    507e:	8f 83       	std	Y+7, r24	; 0x07
    5080:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    5082:	80 91 69 50 	lds	r24, 0x5069
    5086:	90 91 6a 50 	lds	r25, 0x506A
    508a:	00 97       	sbiw	r24, 0x00	; 0
    508c:	09 f4       	brne	.+2      	; 0x5090 <writeFile+0x3f2>
    508e:	77 c0       	rjmp	.+238    	; 0x517e <writeFile+0x4e0>
    5090:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5092:	cd 80       	ldd	r12, Y+5	; 0x05
    5094:	de 80       	ldd	r13, Y+6	; 0x06
    5096:	ef 80       	ldd	r14, Y+7	; 0x07
    5098:	f8 84       	ldd	r15, Y+8	; 0x08
    509a:	19 81       	ldd	r17, Y+1	; 0x01
    509c:	c1 0e       	add	r12, r17
    509e:	d1 1c       	adc	r13, r1
    50a0:	e1 1c       	adc	r14, r1
    50a2:	f1 1c       	adc	r15, r1
    50a4:	c7 01       	movw	r24, r14
    50a6:	b6 01       	movw	r22, r12
    50a8:	a2 01       	movw	r20, r4
    50aa:	0e 94 0d 2b 	call	0x561a	; 0x561a <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    50ae:	80 91 55 40 	lds	r24, 0x4055
    50b2:	90 91 56 40 	lds	r25, 0x4056
    50b6:	00 97       	sbiw	r24, 0x00	; 0
    50b8:	09 f4       	brne	.+2      	; 0x50bc <writeFile+0x41e>
    50ba:	54 c0       	rjmp	.+168    	; 0x5164 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    50bc:	33 20       	and	r3, r3
    50be:	09 f0       	breq	.+2      	; 0x50c2 <writeFile+0x424>
    50c0:	a1 c0       	rjmp	.+322    	; 0x5204 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    50c2:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    50c4:	00 e0       	ldi	r16, 0x00	; 0
    50c6:	10 e0       	ldi	r17, 0x00	; 0
    50c8:	06 c0       	rjmp	.+12     	; 0x50d6 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    50ca:	a8 01       	movw	r20, r16
    50cc:	48 5b       	subi	r20, 0xB8	; 184
    50ce:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    50d0:	22 23       	and	r18, r18
    50d2:	09 f0       	breq	.+2      	; 0x50d6 <writeFile+0x438>
    50d4:	99 c0       	rjmp	.+306    	; 0x5208 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    50d6:	da 01       	movw	r26, r20
    50d8:	8c 91       	ld	r24, X
    50da:	88 23       	and	r24, r24
    50dc:	21 f4       	brne	.+8      	; 0x50e6 <writeFile+0x448>
    50de:	e2 2d       	mov	r30, r2
    50e0:	f9 2d       	mov	r31, r9
    50e2:	da 01       	movw	r26, r20
    50e4:	04 c0       	rjmp	.+8      	; 0x50ee <writeFile+0x450>
    50e6:	85 3e       	cpi	r24, 0xE5	; 229
    50e8:	d1 f3       	breq	.-12     	; 0x50de <writeFile+0x440>
    50ea:	23 2d       	mov	r18, r3
    50ec:	30 c0       	rjmp	.+96     	; 0x514e <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    50ee:	81 91       	ld	r24, Z+
    50f0:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    50f2:	ea 15       	cp	r30, r10
    50f4:	fb 05       	cpc	r31, r11
    50f6:	d9 f7       	brne	.-10     	; 0x50ee <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    50f8:	fa 01       	movw	r30, r20
    50fa:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    50fc:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    50fe:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    5100:	12 8a       	std	Z+18, r1	; 0x12
    5102:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    5104:	29 85       	ldd	r18, Y+9	; 0x09
    5106:	3a 85       	ldd	r19, Y+10	; 0x0a
    5108:	24 8b       	std	Z+20, r18	; 0x14
    510a:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    510c:	62 8e       	std	Z+26, r6	; 0x1a
    510e:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    5110:	80 91 51 40 	lds	r24, 0x4051
    5114:	90 91 52 40 	lds	r25, 0x4052
    5118:	a0 91 53 40 	lds	r26, 0x4053
    511c:	b0 91 54 40 	lds	r27, 0x4054
    5120:	84 8f       	std	Z+28, r24	; 0x1c
    5122:	95 8f       	std	Z+29, r25	; 0x1d
    5124:	a6 8f       	std	Z+30, r26	; 0x1e
    5126:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    5128:	c7 01       	movw	r24, r14
    512a:	b6 01       	movw	r22, r12
    512c:	a2 01       	movw	r20, r4
    512e:	20 e0       	ldi	r18, 0x00	; 0
    5130:	32 e0       	ldi	r19, 0x02	; 2
    5132:	0e 94 58 2a 	call	0x54b0	; 0x54b0 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    5136:	40 91 51 40 	lds	r20, 0x4051
    513a:	50 91 52 40 	lds	r21, 0x4052
    513e:	60 91 53 40 	lds	r22, 0x4053
    5142:	70 91 54 40 	lds	r23, 0x4054
    5146:	81 e0       	ldi	r24, 0x01	; 1
    5148:	0e 94 bf 23 	call	0x477e	; 0x477e <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    514c:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    514e:	00 5e       	subi	r16, 0xE0	; 224
    5150:	1f 4f       	sbci	r17, 0xFF	; 255
    5152:	80 91 55 40 	lds	r24, 0x4055
    5156:	90 91 56 40 	lds	r25, 0x4056
    515a:	08 17       	cp	r16, r24
    515c:	19 07       	cpc	r17, r25
    515e:	08 f4       	brcc	.+2      	; 0x5162 <writeFile+0x4c4>
    5160:	b4 cf       	rjmp	.-152    	; 0x50ca <writeFile+0x42c>
    5162:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    5164:	09 81       	ldd	r16, Y+1	; 0x01
    5166:	0f 5f       	subi	r16, 0xFF	; 255
    5168:	09 83       	std	Y+1, r16	; 0x01
    516a:	20 91 69 50 	lds	r18, 0x5069
    516e:	30 91 6a 50 	lds	r19, 0x506A
    5172:	80 2f       	mov	r24, r16
    5174:	90 e0       	ldi	r25, 0x00	; 0
    5176:	82 17       	cp	r24, r18
    5178:	93 07       	cpc	r25, r19
    517a:	08 f4       	brcc	.+2      	; 0x517e <writeFile+0x4e0>
    517c:	8a cf       	rjmp	.-236    	; 0x5092 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    517e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5180:	7c 85       	ldd	r23, Y+12	; 0x0c
    5182:	8d 85       	ldd	r24, Y+13	; 0x0d
    5184:	9e 85       	ldd	r25, Y+14	; 0x0e
    5186:	40 e0       	ldi	r20, 0x00	; 0
    5188:	00 e0       	ldi	r16, 0x00	; 0
    518a:	10 e0       	ldi	r17, 0x00	; 0
    518c:	98 01       	movw	r18, r16
    518e:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
    5192:	6b 01       	movw	r12, r22
    5194:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5196:	67 3f       	cpi	r22, 0xF7	; 247
    5198:	1f ef       	ldi	r17, 0xFF	; 255
    519a:	71 07       	cpc	r23, r17
    519c:	1f ef       	ldi	r17, 0xFF	; 255
    519e:	81 07       	cpc	r24, r17
    51a0:	1f e0       	ldi	r17, 0x0F	; 15
    51a2:	91 07       	cpc	r25, r17
    51a4:	08 f1       	brcs	.+66     	; 0x51e8 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    51a6:	6f 3f       	cpi	r22, 0xFF	; 255
    51a8:	2f ef       	ldi	r18, 0xFF	; 255
    51aa:	72 07       	cpc	r23, r18
    51ac:	2f ef       	ldi	r18, 0xFF	; 255
    51ae:	82 07       	cpc	r24, r18
    51b0:	2f ef       	ldi	r18, 0xFF	; 255
    51b2:	92 07       	cpc	r25, r18
    51b4:	59 f5       	brne	.+86     	; 0x520c <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    51b6:	6b 85       	ldd	r22, Y+11	; 0x0b
    51b8:	7c 85       	ldd	r23, Y+12	; 0x0c
    51ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    51bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    51be:	0e 94 0c 23 	call	0x4618	; 0x4618 <searchNextFreeCluster>
    51c2:	6b 01       	movw	r12, r22
    51c4:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    51c6:	6b 85       	ldd	r22, Y+11	; 0x0b
    51c8:	7c 85       	ldd	r23, Y+12	; 0x0c
    51ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    51cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    51ce:	41 e0       	ldi	r20, 0x01	; 1
    51d0:	97 01       	movw	r18, r14
    51d2:	86 01       	movw	r16, r12
    51d4:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    51d8:	c7 01       	movw	r24, r14
    51da:	b6 01       	movw	r22, r12
    51dc:	41 e0       	ldi	r20, 0x01	; 1
    51de:	0f ef       	ldi	r16, 0xFF	; 255
    51e0:	1f ef       	ldi	r17, 0xFF	; 255
    51e2:	98 01       	movw	r18, r16
    51e4:	0e 94 2e 20 	call	0x405c	; 0x405c <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    51e8:	c1 14       	cp	r12, r1
    51ea:	d1 04       	cpc	r13, r1
    51ec:	e1 04       	cpc	r14, r1
    51ee:	f1 04       	cpc	r15, r1
    51f0:	09 f0       	breq	.+2      	; 0x51f4 <writeFile+0x556>
    51f2:	39 cf       	rjmp	.-398    	; 0x5066 <writeFile+0x3c8>
	   return 4;
    51f4:	84 e0       	ldi	r24, 0x04	; 4
    51f6:	0b c0       	rjmp	.+22     	; 0x520e <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    51f8:	81 e0       	ldi	r24, 0x01	; 1
    51fa:	09 c0       	rjmp	.+18     	; 0x520e <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    51fc:	82 e0       	ldi	r24, 0x02	; 2
    51fe:	07 c0       	rjmp	.+14     	; 0x520e <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    5200:	82 e0       	ldi	r24, 0x02	; 2
    5202:	05 c0       	rjmp	.+10     	; 0x520e <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    5204:	80 e0       	ldi	r24, 0x00	; 0
    5206:	03 c0       	rjmp	.+6      	; 0x520e <writeFile+0x570>
    5208:	80 e0       	ldi	r24, 0x00	; 0
    520a:	01 c0       	rjmp	.+2      	; 0x520e <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    520c:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    520e:	60 96       	adiw	r28, 0x10	; 16
    5210:	cd bf       	out	0x3d, r28	; 61
    5212:	de bf       	out	0x3e, r29	; 62
    5214:	df 91       	pop	r29
    5216:	cf 91       	pop	r28
    5218:	1f 91       	pop	r17
    521a:	0f 91       	pop	r16
    521c:	ff 90       	pop	r15
    521e:	ef 90       	pop	r14
    5220:	df 90       	pop	r13
    5222:	cf 90       	pop	r12
    5224:	bf 90       	pop	r11
    5226:	af 90       	pop	r10
    5228:	9f 90       	pop	r9
    522a:	8f 90       	pop	r8
    522c:	7f 90       	pop	r7
    522e:	6f 90       	pop	r6
    5230:	5f 90       	pop	r5
    5232:	4f 90       	pop	r4
    5234:	3f 90       	pop	r3
    5236:	2f 90       	pop	r2
    5238:	08 95       	ret

0000523a <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    523a:	8f 92       	push	r8
    523c:	9f 92       	push	r9
    523e:	af 92       	push	r10
    5240:	bf 92       	push	r11
    5242:	cf 92       	push	r12
    5244:	df 92       	push	r13
    5246:	ef 92       	push	r14
    5248:	ff 92       	push	r15
    524a:	0f 93       	push	r16
    524c:	1f 93       	push	r17
    524e:	cf 93       	push	r28
    5250:	df 93       	push	r29
    5252:	84 2e       	mov	r8, r20
    5254:	a5 2e       	mov	r10, r21
    5256:	c6 2e       	mov	r12, r22
    5258:	c7 2f       	mov	r28, r23
    525a:	d2 2f       	mov	r29, r18
    525c:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    525e:	80 64       	ori	r24, 0x40	; 64
    5260:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5264:	8c 2f       	mov	r24, r28
    5266:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    526a:	8c 2d       	mov	r24, r12
    526c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    5270:	8a 2d       	mov	r24, r10
    5272:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5276:	88 2d       	mov	r24, r8
    5278:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(crc);
    527c:	8d 2f       	mov	r24, r29
    527e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	
	for(int i=0; i<read; i++){
    5282:	10 16       	cp	r1, r16
    5284:	11 06       	cpc	r1, r17
    5286:	64 f5       	brge	.+88     	; 0x52e0 <SD_command+0xa6>
    5288:	00 e0       	ldi	r16, 0x00	; 0
    528a:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    528c:	0f 2e       	mov	r0, r31
    528e:	fd e0       	ldi	r31, 0x0D	; 13
    5290:	cf 2e       	mov	r12, r31
    5292:	dd 24       	eor	r13, r13
    5294:	f0 2d       	mov	r31, r0
    5296:	0f 2e       	mov	r0, r31
    5298:	f4 e3       	ldi	r31, 0x34	; 52
    529a:	af 2e       	mov	r10, r31
    529c:	fe e3       	ldi	r31, 0x3E	; 62
    529e:	bf 2e       	mov	r11, r31
    52a0:	f0 2d       	mov	r31, r0
    52a2:	c8 01       	movw	r24, r16
    52a4:	b6 01       	movw	r22, r12
    52a6:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    52aa:	ec 01       	movw	r28, r24
    52ac:	8f ef       	ldi	r24, 0xFF	; 255
    52ae:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    52b2:	f5 01       	movw	r30, r10
    52b4:	ec 0f       	add	r30, r28
    52b6:	fd 1f       	adc	r31, r29
    52b8:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    52ba:	80 81       	ld	r24, Z
    52bc:	8f 3f       	cpi	r24, 0xFF	; 255
    52be:	49 f0       	breq	.+18     	; 0x52d2 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    52c0:	fe 01       	movw	r30, r28
    52c2:	ec 5c       	subi	r30, 0xCC	; 204
    52c4:	f1 4c       	sbci	r31, 0xC1	; 193
    52c6:	80 81       	ld	r24, Z
    52c8:	80 93 35 3e 	sts	0x3E35, r24
			return Buffer[1];
    52cc:	80 91 35 3e 	lds	r24, 0x3E35
    52d0:	08 c0       	rjmp	.+16     	; 0x52e2 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    52d2:	0f 5f       	subi	r16, 0xFF	; 255
    52d4:	1f 4f       	sbci	r17, 0xFF	; 255
    52d6:	0e 15       	cp	r16, r14
    52d8:	1f 05       	cpc	r17, r15
    52da:	19 f7       	brne	.-58     	; 0x52a2 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    52dc:	8f ef       	ldi	r24, 0xFF	; 255
    52de:	01 c0       	rjmp	.+2      	; 0x52e2 <SD_command+0xa8>
    52e0:	8f ef       	ldi	r24, 0xFF	; 255
}
    52e2:	df 91       	pop	r29
    52e4:	cf 91       	pop	r28
    52e6:	1f 91       	pop	r17
    52e8:	0f 91       	pop	r16
    52ea:	ff 90       	pop	r15
    52ec:	ef 90       	pop	r14
    52ee:	df 90       	pop	r13
    52f0:	cf 90       	pop	r12
    52f2:	bf 90       	pop	r11
    52f4:	af 90       	pop	r10
    52f6:	9f 90       	pop	r9
    52f8:	8f 90       	pop	r8
    52fa:	08 95       	ret

000052fc <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    52fc:	ff 92       	push	r15
    52fe:	0f 93       	push	r16
    5300:	1f 93       	push	r17
    5302:	cf 93       	push	r28
    5304:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    5306:	81 e0       	ldi	r24, 0x01	; 1
    5308:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    530c:	81 e0       	ldi	r24, 0x01	; 1
    530e:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5312:	8f ef       	ldi	r24, 0xFF	; 255
    5314:	93 ec       	ldi	r25, 0xC3	; 195
    5316:	a9 e0       	ldi	r26, 0x09	; 9
    5318:	81 50       	subi	r24, 0x01	; 1
    531a:	90 40       	sbci	r25, 0x00	; 0
    531c:	a0 40       	sbci	r26, 0x00	; 0
    531e:	e1 f7       	brne	.-8      	; 0x5318 <SD_init+0x1c>
    5320:	00 c0       	rjmp	.+0      	; 0x5322 <SD_init+0x26>
    5322:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    5324:	88 e0       	ldi	r24, 0x08	; 8
    5326:	60 e0       	ldi	r22, 0x00	; 0
    5328:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    532c:	88 e0       	ldi	r24, 0x08	; 8
    532e:	60 e0       	ldi	r22, 0x00	; 0
    5330:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5334:	80 e0       	ldi	r24, 0x00	; 0
    5336:	63 e0       	ldi	r22, 0x03	; 3
    5338:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    533c:	81 e0       	ldi	r24, 0x01	; 1
    533e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
    5342:	8a e0       	ldi	r24, 0x0A	; 10
    5344:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5346:	e0 ec       	ldi	r30, 0xC0	; 192
    5348:	f8 e0       	ldi	r31, 0x08	; 8
    534a:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    534c:	a0 e4       	ldi	r26, 0x40	; 64
    534e:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5350:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    5352:	22 81       	ldd	r18, Z+2	; 0x02
    5354:	22 23       	and	r18, r18
    5356:	ec f7       	brge	.-6      	; 0x5352 <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    5358:	23 81       	ldd	r18, Z+3	; 0x03
    535a:	2c 93       	st	X, r18
    535c:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    535e:	c1 f7       	brne	.-16     	; 0x5350 <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    5360:	80 e0       	ldi	r24, 0x00	; 0
    5362:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5366:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    536a:	88 e0       	ldi	r24, 0x08	; 8
    536c:	60 e0       	ldi	r22, 0x00	; 0
    536e:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5372:	80 e0       	ldi	r24, 0x00	; 0
    5374:	63 e0       	ldi	r22, 0x03	; 3
    5376:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    537a:	81 e0       	ldi	r24, 0x01	; 1
    537c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    5380:	cb e0       	ldi	r28, 0x0B	; 11
    5382:	d0 e0       	ldi	r29, 0x00	; 0
    5384:	02 c0       	rjmp	.+4      	; 0x538a <SD_init+0x8e>
    5386:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    5388:	69 f0       	breq	.+26     	; 0x53a4 <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    538a:	80 e0       	ldi	r24, 0x00	; 0
    538c:	40 e0       	ldi	r20, 0x00	; 0
    538e:	50 e0       	ldi	r21, 0x00	; 0
    5390:	ba 01       	movw	r22, r20
    5392:	25 e9       	ldi	r18, 0x95	; 149
    5394:	08 e0       	ldi	r16, 0x08	; 8
    5396:	10 e0       	ldi	r17, 0x00	; 0
    5398:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
    539c:	81 30       	cpi	r24, 0x01	; 1
    539e:	99 f7       	brne	.-26     	; 0x5386 <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    53a0:	ff 24       	eor	r15, r15
    53a2:	02 c0       	rjmp	.+4      	; 0x53a8 <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    53a4:	ff 24       	eor	r15, r15
    53a6:	f3 94       	inc	r15
    53a8:	8f ef       	ldi	r24, 0xFF	; 255
    53aa:	93 ec       	ldi	r25, 0xC3	; 195
    53ac:	a9 e0       	ldi	r26, 0x09	; 9
    53ae:	81 50       	subi	r24, 0x01	; 1
    53b0:	90 40       	sbci	r25, 0x00	; 0
    53b2:	a0 40       	sbci	r26, 0x00	; 0
    53b4:	e1 f7       	brne	.-8      	; 0x53ae <SD_init+0xb2>
    53b6:	00 c0       	rjmp	.+0      	; 0x53b8 <SD_init+0xbc>
    53b8:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    53ba:	cb e0       	ldi	r28, 0x0B	; 11
    53bc:	d0 e0       	ldi	r29, 0x00	; 0
    53be:	02 c0       	rjmp	.+4      	; 0x53c4 <SD_init+0xc8>
    53c0:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    53c2:	69 f0       	breq	.+26     	; 0x53de <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    53c4:	88 e0       	ldi	r24, 0x08	; 8
    53c6:	4a ea       	ldi	r20, 0xAA	; 170
    53c8:	51 e0       	ldi	r21, 0x01	; 1
    53ca:	60 e0       	ldi	r22, 0x00	; 0
    53cc:	70 e0       	ldi	r23, 0x00	; 0
    53ce:	27 e8       	ldi	r18, 0x87	; 135
    53d0:	08 e0       	ldi	r16, 0x08	; 8
    53d2:	10 e0       	ldi	r17, 0x00	; 0
    53d4:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
    53d8:	81 30       	cpi	r24, 0x01	; 1
    53da:	91 f7       	brne	.-28     	; 0x53c0 <SD_init+0xc4>
    53dc:	02 c0       	rjmp	.+4      	; 0x53e2 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    53de:	ff 24       	eor	r15, r15
    53e0:	f3 94       	inc	r15
    53e2:	c2 e0       	ldi	r28, 0x02	; 2
    53e4:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    53e6:	04 e3       	ldi	r16, 0x34	; 52
    53e8:	1e e3       	ldi	r17, 0x3E	; 62
    53ea:	8f ef       	ldi	r24, 0xFF	; 255
    53ec:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    53f0:	f8 01       	movw	r30, r16
    53f2:	ec 0f       	add	r30, r28
    53f4:	fd 1f       	adc	r31, r29
    53f6:	80 83       	st	Z, r24
    53f8:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    53fa:	c6 30       	cpi	r28, 0x06	; 6
    53fc:	d1 05       	cpc	r29, r1
    53fe:	a9 f7       	brne	.-22     	; 0x53ea <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    5400:	80 91 38 3e 	lds	r24, 0x3E38
    5404:	81 30       	cpi	r24, 0x01	; 1
    5406:	29 f4       	brne	.+10     	; 0x5412 <SD_init+0x116>
    5408:	80 91 39 3e 	lds	r24, 0x3E39
    540c:	8a 3a       	cpi	r24, 0xAA	; 170
    540e:	21 f4       	brne	.+8      	; 0x5418 <SD_init+0x11c>
    5410:	05 c0       	rjmp	.+10     	; 0x541c <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    5412:	ff 24       	eor	r15, r15
    5414:	f3 94       	inc	r15
    5416:	02 c0       	rjmp	.+4      	; 0x541c <SD_init+0x120>
    5418:	ff 24       	eor	r15, r15
    541a:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    541c:	c5 e3       	ldi	r28, 0x35	; 53
    541e:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    5420:	87 e3       	ldi	r24, 0x37	; 55
    5422:	40 e0       	ldi	r20, 0x00	; 0
    5424:	50 e0       	ldi	r21, 0x00	; 0
    5426:	ba 01       	movw	r22, r20
    5428:	2f ef       	ldi	r18, 0xFF	; 255
    542a:	08 e0       	ldi	r16, 0x08	; 8
    542c:	10 e0       	ldi	r17, 0x00	; 0
    542e:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    5432:	81 e0       	ldi	r24, 0x01	; 1
    5434:	40 e0       	ldi	r20, 0x00	; 0
    5436:	50 e0       	ldi	r21, 0x00	; 0
    5438:	60 e0       	ldi	r22, 0x00	; 0
    543a:	70 e4       	ldi	r23, 0x40	; 64
    543c:	2f ef       	ldi	r18, 0xFF	; 255
    543e:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
	} while(Buffer[1]!= 0x00);	
    5442:	88 81       	ld	r24, Y
    5444:	88 23       	and	r24, r24
    5446:	61 f7       	brne	.-40     	; 0x5420 <SD_init+0x124>
    5448:	cb e0       	ldi	r28, 0x0B	; 11
    544a:	d0 e0       	ldi	r29, 0x00	; 0
    544c:	02 c0       	rjmp	.+4      	; 0x5452 <SD_init+0x156>
    544e:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    5450:	61 f0       	breq	.+24     	; 0x546a <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    5452:	8a e3       	ldi	r24, 0x3A	; 58
    5454:	40 e0       	ldi	r20, 0x00	; 0
    5456:	50 e0       	ldi	r21, 0x00	; 0
    5458:	ba 01       	movw	r22, r20
    545a:	2f ef       	ldi	r18, 0xFF	; 255
    545c:	08 e0       	ldi	r16, 0x08	; 8
    545e:	10 e0       	ldi	r17, 0x00	; 0
    5460:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
    5464:	88 23       	and	r24, r24
    5466:	99 f7       	brne	.-26     	; 0x544e <SD_init+0x152>
    5468:	02 c0       	rjmp	.+4      	; 0x546e <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    546a:	ff 24       	eor	r15, r15
    546c:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    546e:	c0 e0       	ldi	r28, 0x00	; 0
    5470:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5472:	04 e3       	ldi	r16, 0x34	; 52
    5474:	1e e3       	ldi	r17, 0x3E	; 62
    5476:	8f ef       	ldi	r24, 0xFF	; 255
    5478:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    547c:	f8 01       	movw	r30, r16
    547e:	ec 0f       	add	r30, r28
    5480:	fd 1f       	adc	r31, r29
    5482:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5484:	21 96       	adiw	r28, 0x01	; 1
    5486:	c4 30       	cpi	r28, 0x04	; 4
    5488:	d1 05       	cpc	r29, r1
    548a:	a9 f7       	brne	.-22     	; 0x5476 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    548c:	80 91 34 3e 	lds	r24, 0x3E34
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    5490:	80 e0       	ldi	r24, 0x00	; 0
    5492:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5496:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    549a:	88 e0       	ldi	r24, 0x08	; 8
    549c:	60 e0       	ldi	r22, 0x00	; 0
    549e:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	return errorCode;					
}
    54a2:	8f 2d       	mov	r24, r15
    54a4:	df 91       	pop	r29
    54a6:	cf 91       	pop	r28
    54a8:	1f 91       	pop	r17
    54aa:	0f 91       	pop	r16
    54ac:	ff 90       	pop	r15
    54ae:	08 95       	ret

000054b0 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    54b0:	6f 92       	push	r6
    54b2:	7f 92       	push	r7
    54b4:	8f 92       	push	r8
    54b6:	9f 92       	push	r9
    54b8:	af 92       	push	r10
    54ba:	bf 92       	push	r11
    54bc:	cf 92       	push	r12
    54be:	df 92       	push	r13
    54c0:	ef 92       	push	r14
    54c2:	ff 92       	push	r15
    54c4:	0f 93       	push	r16
    54c6:	1f 93       	push	r17
    54c8:	cf 93       	push	r28
    54ca:	df 93       	push	r29
    54cc:	4b 01       	movw	r8, r22
    54ce:	5c 01       	movw	r10, r24
    54d0:	74 2e       	mov	r7, r20
    54d2:	65 2e       	mov	r6, r21
    54d4:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    54d6:	88 e0       	ldi	r24, 0x08	; 8
    54d8:	60 e0       	ldi	r22, 0x00	; 0
    54da:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    54de:	80 e0       	ldi	r24, 0x00	; 0
    54e0:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    54e4:	81 e0       	ldi	r24, 0x01	; 1
    54e6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    54ea:	80 e0       	ldi	r24, 0x00	; 0
    54ec:	92 e0       	ldi	r25, 0x02	; 2
    54ee:	7c 01       	movw	r14, r24
    54f0:	ec 18       	sub	r14, r12
    54f2:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    54f4:	80 e0       	ldi	r24, 0x00	; 0
    54f6:	e8 16       	cp	r14, r24
    54f8:	82 e0       	ldi	r24, 0x02	; 2
    54fa:	f8 06       	cpc	r15, r24
    54fc:	11 f4       	brne	.+4      	; 0x5502 <SD_write_block+0x52>
    54fe:	ee 24       	eor	r14, r14
    5500:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5502:	cb e0       	ldi	r28, 0x0B	; 11
    5504:	d0 e0       	ldi	r29, 0x00	; 0
    5506:	03 c0       	rjmp	.+6      	; 0x550e <SD_write_block+0x5e>
    5508:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    550a:	09 f4       	brne	.+2      	; 0x550e <SD_write_block+0x5e>
    550c:	ff cf       	rjmp	.-2      	; 0x550c <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    550e:	88 e1       	ldi	r24, 0x18	; 24
    5510:	b5 01       	movw	r22, r10
    5512:	a4 01       	movw	r20, r8
    5514:	2f ef       	ldi	r18, 0xFF	; 255
    5516:	08 e0       	ldi	r16, 0x08	; 8
    5518:	10 e0       	ldi	r17, 0x00	; 0
    551a:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
    551e:	88 23       	and	r24, r24
    5520:	99 f7       	brne	.-26     	; 0x5508 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    5522:	8f ef       	ldi	r24, 0xFF	; 255
    5524:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5528:	80 93 34 3e 	sts	0x3E34, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    552c:	8e ef       	ldi	r24, 0xFE	; 254
    552e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5532:	1c 14       	cp	r1, r12
    5534:	1d 04       	cpc	r1, r13
    5536:	bc f4       	brge	.+46     	; 0x5566 <SD_write_block+0xb6>
    5538:	87 2c       	mov	r8, r7
    553a:	96 2c       	mov	r9, r6
    553c:	00 e0       	ldi	r16, 0x00	; 0
    553e:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    5540:	c8 01       	movw	r24, r16
    5542:	6d e0       	ldi	r22, 0x0D	; 13
    5544:	70 e0       	ldi	r23, 0x00	; 0
    5546:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    554a:	ec 01       	movw	r28, r24
    554c:	f4 01       	movw	r30, r8
    554e:	81 91       	ld	r24, Z+
    5550:	4f 01       	movw	r8, r30
    5552:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5556:	cc 5c       	subi	r28, 0xCC	; 204
    5558:	d1 4c       	sbci	r29, 0xC1	; 193
    555a:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    555c:	0f 5f       	subi	r16, 0xFF	; 255
    555e:	1f 4f       	sbci	r17, 0xFF	; 255
    5560:	0c 15       	cp	r16, r12
    5562:	1d 05       	cpc	r17, r13
    5564:	69 f7       	brne	.-38     	; 0x5540 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5566:	1e 14       	cp	r1, r14
    5568:	1f 04       	cpc	r1, r15
    556a:	ec f4       	brge	.+58     	; 0x55a6 <SD_write_block+0xf6>
    556c:	00 e0       	ldi	r16, 0x00	; 0
    556e:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    5570:	0f 2e       	mov	r0, r31
    5572:	fd e0       	ldi	r31, 0x0D	; 13
    5574:	cf 2e       	mov	r12, r31
    5576:	dd 24       	eor	r13, r13
    5578:	f0 2d       	mov	r31, r0
    557a:	0f 2e       	mov	r0, r31
    557c:	f4 e3       	ldi	r31, 0x34	; 52
    557e:	8f 2e       	mov	r8, r31
    5580:	fe e3       	ldi	r31, 0x3E	; 62
    5582:	9f 2e       	mov	r9, r31
    5584:	f0 2d       	mov	r31, r0
    5586:	c8 01       	movw	r24, r16
    5588:	b6 01       	movw	r22, r12
    558a:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    558e:	ec 01       	movw	r28, r24
    5590:	80 e0       	ldi	r24, 0x00	; 0
    5592:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5596:	c8 0d       	add	r28, r8
    5598:	d9 1d       	adc	r29, r9
    559a:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    559c:	0f 5f       	subi	r16, 0xFF	; 255
    559e:	1f 4f       	sbci	r17, 0xFF	; 255
    55a0:	0e 15       	cp	r16, r14
    55a2:	1f 05       	cpc	r17, r15
    55a4:	81 f7       	brne	.-32     	; 0x5586 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    55a6:	8f ef       	ldi	r24, 0xFF	; 255
    55a8:	80 93 34 3e 	sts	0x3E34, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    55ac:	c0 e0       	ldi	r28, 0x00	; 0
    55ae:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    55b0:	04 e3       	ldi	r16, 0x34	; 52
    55b2:	1e e3       	ldi	r17, 0x3E	; 62
    55b4:	8f ef       	ldi	r24, 0xFF	; 255
    55b6:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    55ba:	f8 01       	movw	r30, r16
    55bc:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    55be:	21 96       	adiw	r28, 0x01	; 1
    55c0:	c2 30       	cpi	r28, 0x02	; 2
    55c2:	d1 05       	cpc	r29, r1
    55c4:	bc f3       	brlt	.-18     	; 0x55b4 <SD_write_block+0x104>
    55c6:	80 81       	ld	r24, Z
    55c8:	8f 3f       	cpi	r24, 0xFF	; 255
    55ca:	a1 f3       	breq	.-24     	; 0x55b4 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    55cc:	80 91 34 3e 	lds	r24, 0x3E34
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    55d0:	80 91 34 3e 	lds	r24, 0x3E34
    55d4:	8f 3f       	cpi	r24, 0xFF	; 255
    55d6:	49 f0       	breq	.+18     	; 0x55ea <SD_write_block+0x13a>
    55d8:	c4 e3       	ldi	r28, 0x34	; 52
    55da:	de e3       	ldi	r29, 0x3E	; 62
    55dc:	8f ef       	ldi	r24, 0xFF	; 255
    55de:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    55e2:	88 83       	st	Y, r24
    55e4:	88 81       	ld	r24, Y
    55e6:	8f 3f       	cpi	r24, 0xFF	; 255
    55e8:	c9 f7       	brne	.-14     	; 0x55dc <SD_write_block+0x12c>
	SPICS(FALSE);
    55ea:	80 e0       	ldi	r24, 0x00	; 0
    55ec:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    55f0:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    55f4:	88 e0       	ldi	r24, 0x08	; 8
    55f6:	60 e0       	ldi	r22, 0x00	; 0
    55f8:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    55fc:	df 91       	pop	r29
    55fe:	cf 91       	pop	r28
    5600:	1f 91       	pop	r17
    5602:	0f 91       	pop	r16
    5604:	ff 90       	pop	r15
    5606:	ef 90       	pop	r14
    5608:	df 90       	pop	r13
    560a:	cf 90       	pop	r12
    560c:	bf 90       	pop	r11
    560e:	af 90       	pop	r10
    5610:	9f 90       	pop	r9
    5612:	8f 90       	pop	r8
    5614:	7f 90       	pop	r7
    5616:	6f 90       	pop	r6
    5618:	08 95       	ret

0000561a <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    561a:	af 92       	push	r10
    561c:	bf 92       	push	r11
    561e:	cf 92       	push	r12
    5620:	df 92       	push	r13
    5622:	ef 92       	push	r14
    5624:	ff 92       	push	r15
    5626:	0f 93       	push	r16
    5628:	1f 93       	push	r17
    562a:	cf 93       	push	r28
    562c:	df 93       	push	r29
    562e:	6b 01       	movw	r12, r22
    5630:	7c 01       	movw	r14, r24
    5632:	b4 2e       	mov	r11, r20
    5634:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5636:	88 e0       	ldi	r24, 0x08	; 8
    5638:	60 e0       	ldi	r22, 0x00	; 0
    563a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    563e:	80 e0       	ldi	r24, 0x00	; 0
    5640:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5644:	81 e0       	ldi	r24, 0x01	; 1
    5646:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    564a:	cb e0       	ldi	r28, 0x0B	; 11
    564c:	d0 e0       	ldi	r29, 0x00	; 0
    564e:	03 c0       	rjmp	.+6      	; 0x5656 <SD_read_block+0x3c>
    5650:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5652:	09 f4       	brne	.+2      	; 0x5656 <SD_read_block+0x3c>
    5654:	ff cf       	rjmp	.-2      	; 0x5654 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5656:	81 e1       	ldi	r24, 0x11	; 17
    5658:	b7 01       	movw	r22, r14
    565a:	a6 01       	movw	r20, r12
    565c:	2f ef       	ldi	r18, 0xFF	; 255
    565e:	08 e0       	ldi	r16, 0x08	; 8
    5660:	10 e0       	ldi	r17, 0x00	; 0
    5662:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
    5666:	88 23       	and	r24, r24
    5668:	99 f7       	brne	.-26     	; 0x5650 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    566a:	80 91 34 3e 	lds	r24, 0x3E34
    566e:	8e 3f       	cpi	r24, 0xFE	; 254
    5670:	49 f0       	breq	.+18     	; 0x5684 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5672:	c4 e3       	ldi	r28, 0x34	; 52
    5674:	de e3       	ldi	r29, 0x3E	; 62
    5676:	8f ef       	ldi	r24, 0xFF	; 255
    5678:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    567c:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    567e:	88 81       	ld	r24, Y
    5680:	8e 3f       	cpi	r24, 0xFE	; 254
    5682:	c9 f7       	brne	.-14     	; 0x5676 <SD_read_block+0x5c>
    5684:	0b 2d       	mov	r16, r11
    5686:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5688:	c0 e0       	ldi	r28, 0x00	; 0
    568a:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    568c:	8f ef       	ldi	r24, 0xFF	; 255
    568e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5692:	f8 01       	movw	r30, r16
    5694:	81 93       	st	Z+, r24
    5696:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5698:	21 96       	adiw	r28, 0x01	; 1
    569a:	f2 e0       	ldi	r31, 0x02	; 2
    569c:	c0 30       	cpi	r28, 0x00	; 0
    569e:	df 07       	cpc	r29, r31
    56a0:	a9 f7       	brne	.-22     	; 0x568c <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    56a2:	10 92 40 3e 	sts	0x3E40, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    56a6:	80 91 40 3e 	lds	r24, 0x3E40
    56aa:	8f 3f       	cpi	r24, 0xFF	; 255
    56ac:	49 f0       	breq	.+18     	; 0x56c0 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    56ae:	c0 e4       	ldi	r28, 0x40	; 64
    56b0:	de e3       	ldi	r29, 0x3E	; 62
    56b2:	8f ef       	ldi	r24, 0xFF	; 255
    56b4:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    56b8:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    56ba:	88 81       	ld	r24, Y
    56bc:	8f 3f       	cpi	r24, 0xFF	; 255
    56be:	c9 f7       	brne	.-14     	; 0x56b2 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    56c0:	80 e0       	ldi	r24, 0x00	; 0
    56c2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    56c6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    56ca:	88 e0       	ldi	r24, 0x08	; 8
    56cc:	60 e0       	ldi	r22, 0x00	; 0
    56ce:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    56d2:	df 91       	pop	r29
    56d4:	cf 91       	pop	r28
    56d6:	1f 91       	pop	r17
    56d8:	0f 91       	pop	r16
    56da:	ff 90       	pop	r15
    56dc:	ef 90       	pop	r14
    56de:	df 90       	pop	r13
    56e0:	cf 90       	pop	r12
    56e2:	bf 90       	pop	r11
    56e4:	af 90       	pop	r10
    56e6:	08 95       	ret

000056e8 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    56e8:	2f 92       	push	r2
    56ea:	3f 92       	push	r3
    56ec:	4f 92       	push	r4
    56ee:	5f 92       	push	r5
    56f0:	6f 92       	push	r6
    56f2:	7f 92       	push	r7
    56f4:	8f 92       	push	r8
    56f6:	9f 92       	push	r9
    56f8:	af 92       	push	r10
    56fa:	bf 92       	push	r11
    56fc:	cf 92       	push	r12
    56fe:	df 92       	push	r13
    5700:	ef 92       	push	r14
    5702:	ff 92       	push	r15
    5704:	0f 93       	push	r16
    5706:	1f 93       	push	r17
    5708:	cf 93       	push	r28
    570a:	df 93       	push	r29
    570c:	cd b7       	in	r28, 0x3d	; 61
    570e:	de b7       	in	r29, 0x3e	; 62
    5710:	2a 97       	sbiw	r28, 0x0a	; 10
    5712:	cd bf       	out	0x3d, r28	; 61
    5714:	de bf       	out	0x3e, r29	; 62
    5716:	6b 01       	movw	r12, r22
    5718:	7c 01       	movw	r14, r24
    571a:	4f 83       	std	Y+7, r20	; 0x07
    571c:	58 87       	std	Y+8, r21	; 0x08
    571e:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5720:	88 e0       	ldi	r24, 0x08	; 8
    5722:	60 e0       	ldi	r22, 0x00	; 0
    5724:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5728:	80 e0       	ldi	r24, 0x00	; 0
    572a:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    572e:	81 e0       	ldi	r24, 0x01	; 1
    5730:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5734:	c8 01       	movw	r24, r16
    5736:	11 23       	and	r17, r17
    5738:	14 f4       	brge	.+4      	; 0x573e <SD_write_multiple_blocks+0x56>
    573a:	81 50       	subi	r24, 0x01	; 1
    573c:	9e 4f       	sbci	r25, 0xFE	; 254
    573e:	9c 01       	movw	r18, r24
    5740:	23 2f       	mov	r18, r19
    5742:	33 0f       	add	r19, r19
    5744:	33 0b       	sbc	r19, r19
    5746:	25 95       	asr	r18
    5748:	2b 83       	std	Y+3, r18	; 0x03
    574a:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    574c:	20 e0       	ldi	r18, 0x00	; 0
    574e:	32 e0       	ldi	r19, 0x02	; 2
    5750:	c8 01       	movw	r24, r16
    5752:	b9 01       	movw	r22, r18
    5754:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    5758:	29 01       	movw	r4, r18
    575a:	48 1a       	sub	r4, r24
    575c:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    575e:	30 e0       	ldi	r19, 0x00	; 0
    5760:	43 16       	cp	r4, r19
    5762:	32 e0       	ldi	r19, 0x02	; 2
    5764:	53 06       	cpc	r5, r19
    5766:	31 f0       	breq	.+12     	; 0x5774 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5768:	8b 81       	ldd	r24, Y+3	; 0x03
    576a:	9c 81       	ldd	r25, Y+4	; 0x04
    576c:	01 96       	adiw	r24, 0x01	; 1
    576e:	8b 83       	std	Y+3, r24	; 0x03
    5770:	9c 83       	std	Y+4, r25	; 0x04
    5772:	02 c0       	rjmp	.+4      	; 0x5778 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5774:	44 24       	eor	r4, r4
    5776:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5778:	89 e1       	ldi	r24, 0x19	; 25
    577a:	b7 01       	movw	r22, r14
    577c:	a6 01       	movw	r20, r12
    577e:	2f ef       	ldi	r18, 0xFF	; 255
    5780:	08 e0       	ldi	r16, 0x08	; 8
    5782:	10 e0       	ldi	r17, 0x00	; 0
    5784:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
    5788:	88 23       	and	r24, r24
    578a:	b1 f7       	brne	.-20     	; 0x5778 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    578c:	eb 81       	ldd	r30, Y+3	; 0x03
    578e:	fc 81       	ldd	r31, Y+4	; 0x04
    5790:	1e 16       	cp	r1, r30
    5792:	1f 06       	cpc	r1, r31
    5794:	0c f0       	brlt	.+2      	; 0x5798 <SD_write_multiple_blocks+0xb0>
    5796:	ac c0       	rjmp	.+344    	; 0x58f0 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5798:	31 97       	sbiw	r30, 0x01	; 1
    579a:	ed 83       	std	Y+5, r30	; 0x05
    579c:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    579e:	9f 01       	movw	r18, r30
    57a0:	32 2f       	mov	r19, r18
    57a2:	22 27       	eor	r18, r18
    57a4:	33 0f       	add	r19, r19
    57a6:	8f 81       	ldd	r24, Y+7	; 0x07
    57a8:	98 85       	ldd	r25, Y+8	; 0x08
    57aa:	89 83       	std	Y+1, r24	; 0x01
    57ac:	9a 83       	std	Y+2, r25	; 0x02
    57ae:	66 24       	eor	r6, r6
    57b0:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    57b2:	0f 2e       	mov	r0, r31
    57b4:	f5 e3       	ldi	r31, 0x35	; 53
    57b6:	8f 2e       	mov	r8, r31
    57b8:	fe e3       	ldi	r31, 0x3E	; 62
    57ba:	9f 2e       	mov	r9, r31
    57bc:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    57be:	0f 2e       	mov	r0, r31
    57c0:	fc e0       	ldi	r31, 0x0C	; 12
    57c2:	cf 2e       	mov	r12, r31
    57c4:	dd 24       	eor	r13, r13
    57c6:	f0 2d       	mov	r31, r0
    57c8:	0f 2e       	mov	r0, r31
    57ca:	f4 e3       	ldi	r31, 0x34	; 52
    57cc:	af 2e       	mov	r10, r31
    57ce:	fe e3       	ldi	r31, 0x3E	; 62
    57d0:	bf 2e       	mov	r11, r31
    57d2:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    57d4:	80 e0       	ldi	r24, 0x00	; 0
    57d6:	92 e0       	ldi	r25, 0x02	; 2
    57d8:	1c 01       	movw	r2, r24
    57da:	24 18       	sub	r2, r4
    57dc:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    57de:	ef 81       	ldd	r30, Y+7	; 0x07
    57e0:	f8 85       	ldd	r31, Y+8	; 0x08
    57e2:	e2 0f       	add	r30, r18
    57e4:	f3 1f       	adc	r31, r19
    57e6:	ef 83       	std	Y+7, r30	; 0x07
    57e8:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    57ea:	8f ef       	ldi	r24, 0xFF	; 255
    57ec:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    57f0:	f4 01       	movw	r30, r8
    57f2:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    57f4:	8c ef       	ldi	r24, 0xFC	; 252
    57f6:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    57fa:	f4 01       	movw	r30, r8
    57fc:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    57fe:	2d 81       	ldd	r18, Y+5	; 0x05
    5800:	3e 81       	ldd	r19, Y+6	; 0x06
    5802:	26 15       	cp	r18, r6
    5804:	37 05       	cpc	r19, r7
    5806:	09 f0       	breq	.+2      	; 0x580a <SD_write_multiple_blocks+0x122>
    5808:	41 c0       	rjmp	.+130    	; 0x588c <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    580a:	12 14       	cp	r1, r2
    580c:	13 04       	cpc	r1, r3
    580e:	cc f4       	brge	.+50     	; 0x5842 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5810:	ef 80       	ldd	r14, Y+7	; 0x07
    5812:	f8 84       	ldd	r15, Y+8	; 0x08
    5814:	00 e0       	ldi	r16, 0x00	; 0
    5816:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5818:	c8 01       	movw	r24, r16
    581a:	b6 01       	movw	r22, r12
    581c:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    5820:	89 87       	std	Y+9, r24	; 0x09
    5822:	9a 87       	std	Y+10, r25	; 0x0a
    5824:	f7 01       	movw	r30, r14
    5826:	81 91       	ld	r24, Z+
    5828:	7f 01       	movw	r14, r30
    582a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    582e:	e9 85       	ldd	r30, Y+9	; 0x09
    5830:	fa 85       	ldd	r31, Y+10	; 0x0a
    5832:	ea 0d       	add	r30, r10
    5834:	fb 1d       	adc	r31, r11
    5836:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5838:	0f 5f       	subi	r16, 0xFF	; 255
    583a:	1f 4f       	sbci	r17, 0xFF	; 255
    583c:	02 15       	cp	r16, r2
    583e:	13 05       	cpc	r17, r3
    5840:	59 f7       	brne	.-42     	; 0x5818 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5842:	14 14       	cp	r1, r4
    5844:	15 04       	cpc	r1, r5
    5846:	9c f4       	brge	.+38     	; 0x586e <SD_write_multiple_blocks+0x186>
    5848:	00 e0       	ldi	r16, 0x00	; 0
    584a:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    584c:	c8 01       	movw	r24, r16
    584e:	b6 01       	movw	r22, r12
    5850:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    5854:	7c 01       	movw	r14, r24
    5856:	80 e0       	ldi	r24, 0x00	; 0
    5858:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    585c:	f5 01       	movw	r30, r10
    585e:	ee 0d       	add	r30, r14
    5860:	ff 1d       	adc	r31, r15
    5862:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5864:	0f 5f       	subi	r16, 0xFF	; 255
    5866:	1f 4f       	sbci	r17, 0xFF	; 255
    5868:	04 15       	cp	r16, r4
    586a:	15 05       	cpc	r17, r5
    586c:	79 f7       	brne	.-34     	; 0x584c <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    586e:	8f ef       	ldi	r24, 0xFF	; 255
    5870:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5874:	f4 01       	movw	r30, r8
    5876:	80 83       	st	Z, r24
    5878:	8f ef       	ldi	r24, 0xFF	; 255
    587a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    587e:	f4 01       	movw	r30, r8
    5880:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5882:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5884:	80 81       	ld	r24, Z
    5886:	8f 3f       	cpi	r24, 0xFF	; 255
    5888:	e1 f4       	brne	.+56     	; 0x58c2 <SD_write_multiple_blocks+0x1da>
    588a:	23 c0       	rjmp	.+70     	; 0x58d2 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    588c:	e9 80       	ldd	r14, Y+1	; 0x01
    588e:	fa 80       	ldd	r15, Y+2	; 0x02
    5890:	00 e0       	ldi	r16, 0x00	; 0
    5892:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5894:	c8 01       	movw	r24, r16
    5896:	b6 01       	movw	r22, r12
    5898:	0e 94 d2 38 	call	0x71a4	; 0x71a4 <__divmodhi4>
    589c:	89 87       	std	Y+9, r24	; 0x09
    589e:	9a 87       	std	Y+10, r25	; 0x0a
    58a0:	f7 01       	movw	r30, r14
    58a2:	81 91       	ld	r24, Z+
    58a4:	7f 01       	movw	r14, r30
    58a6:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    58aa:	e9 85       	ldd	r30, Y+9	; 0x09
    58ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    58ae:	ea 0d       	add	r30, r10
    58b0:	fb 1d       	adc	r31, r11
    58b2:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    58b4:	0f 5f       	subi	r16, 0xFF	; 255
    58b6:	1f 4f       	sbci	r17, 0xFF	; 255
    58b8:	f2 e0       	ldi	r31, 0x02	; 2
    58ba:	00 30       	cpi	r16, 0x00	; 0
    58bc:	1f 07       	cpc	r17, r31
    58be:	51 f7       	brne	.-44     	; 0x5894 <SD_write_multiple_blocks+0x1ac>
    58c0:	d6 cf       	rjmp	.-84     	; 0x586e <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    58c2:	8f ef       	ldi	r24, 0xFF	; 255
    58c4:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    58c8:	f4 01       	movw	r30, r8
    58ca:	80 83       	st	Z, r24
    58cc:	80 81       	ld	r24, Z
    58ce:	8f 3f       	cpi	r24, 0xFF	; 255
    58d0:	c1 f7       	brne	.-16     	; 0x58c2 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    58d2:	08 94       	sec
    58d4:	61 1c       	adc	r6, r1
    58d6:	71 1c       	adc	r7, r1
    58d8:	29 81       	ldd	r18, Y+1	; 0x01
    58da:	3a 81       	ldd	r19, Y+2	; 0x02
    58dc:	20 50       	subi	r18, 0x00	; 0
    58de:	3e 4f       	sbci	r19, 0xFE	; 254
    58e0:	29 83       	std	Y+1, r18	; 0x01
    58e2:	3a 83       	std	Y+2, r19	; 0x02
    58e4:	8b 81       	ldd	r24, Y+3	; 0x03
    58e6:	9c 81       	ldd	r25, Y+4	; 0x04
    58e8:	68 16       	cp	r6, r24
    58ea:	79 06       	cpc	r7, r25
    58ec:	09 f0       	breq	.+2      	; 0x58f0 <SD_write_multiple_blocks+0x208>
    58ee:	7d cf       	rjmp	.-262    	; 0x57ea <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    58f0:	ee 24       	eor	r14, r14
    58f2:	ff 24       	eor	r15, r15
    58f4:	68 94       	set
    58f6:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    58f8:	05 e3       	ldi	r16, 0x35	; 53
    58fa:	1e e3       	ldi	r17, 0x3E	; 62
    58fc:	8f ef       	ldi	r24, 0xFF	; 255
    58fe:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5902:	f8 01       	movw	r30, r16
    5904:	80 83       	st	Z, r24
    5906:	08 94       	sec
    5908:	e1 08       	sbc	r14, r1
    590a:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    590c:	e1 14       	cp	r14, r1
    590e:	f1 04       	cpc	r15, r1
    5910:	a9 f7       	brne	.-22     	; 0x58fc <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5912:	8d ef       	ldi	r24, 0xFD	; 253
    5914:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5918:	80 93 35 3e 	sts	0x3E35, r24
    591c:	ee 24       	eor	r14, r14
    591e:	ff 24       	eor	r15, r15
    5920:	68 94       	set
    5922:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5924:	05 e3       	ldi	r16, 0x35	; 53
    5926:	1e e3       	ldi	r17, 0x3E	; 62
    5928:	8f ef       	ldi	r24, 0xFF	; 255
    592a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    592e:	f8 01       	movw	r30, r16
    5930:	80 83       	st	Z, r24
    5932:	08 94       	sec
    5934:	e1 08       	sbc	r14, r1
    5936:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5938:	e1 14       	cp	r14, r1
    593a:	f1 04       	cpc	r15, r1
    593c:	a9 f7       	brne	.-22     	; 0x5928 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    593e:	10 92 35 3e 	sts	0x3E35, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5942:	80 91 35 3e 	lds	r24, 0x3E35
    5946:	8f 3f       	cpi	r24, 0xFF	; 255
    5948:	51 f0       	breq	.+20     	; 0x595e <SD_write_multiple_blocks+0x276>
    594a:	05 e3       	ldi	r16, 0x35	; 53
    594c:	1e e3       	ldi	r17, 0x3E	; 62
    594e:	8f ef       	ldi	r24, 0xFF	; 255
    5950:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5954:	f8 01       	movw	r30, r16
    5956:	80 83       	st	Z, r24
    5958:	80 81       	ld	r24, Z
    595a:	8f 3f       	cpi	r24, 0xFF	; 255
    595c:	c1 f7       	brne	.-16     	; 0x594e <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    595e:	80 e0       	ldi	r24, 0x00	; 0
    5960:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5964:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5968:	88 e0       	ldi	r24, 0x08	; 8
    596a:	60 e0       	ldi	r22, 0x00	; 0
    596c:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5970:	2a 96       	adiw	r28, 0x0a	; 10
    5972:	cd bf       	out	0x3d, r28	; 61
    5974:	de bf       	out	0x3e, r29	; 62
    5976:	df 91       	pop	r29
    5978:	cf 91       	pop	r28
    597a:	1f 91       	pop	r17
    597c:	0f 91       	pop	r16
    597e:	ff 90       	pop	r15
    5980:	ef 90       	pop	r14
    5982:	df 90       	pop	r13
    5984:	cf 90       	pop	r12
    5986:	bf 90       	pop	r11
    5988:	af 90       	pop	r10
    598a:	9f 90       	pop	r9
    598c:	8f 90       	pop	r8
    598e:	7f 90       	pop	r7
    5990:	6f 90       	pop	r6
    5992:	5f 90       	pop	r5
    5994:	4f 90       	pop	r4
    5996:	3f 90       	pop	r3
    5998:	2f 90       	pop	r2
    599a:	08 95       	ret

0000599c <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    599c:	2f 92       	push	r2
    599e:	3f 92       	push	r3
    59a0:	4f 92       	push	r4
    59a2:	5f 92       	push	r5
    59a4:	6f 92       	push	r6
    59a6:	7f 92       	push	r7
    59a8:	8f 92       	push	r8
    59aa:	9f 92       	push	r9
    59ac:	af 92       	push	r10
    59ae:	bf 92       	push	r11
    59b0:	cf 92       	push	r12
    59b2:	df 92       	push	r13
    59b4:	ef 92       	push	r14
    59b6:	ff 92       	push	r15
    59b8:	0f 93       	push	r16
    59ba:	1f 93       	push	r17
    59bc:	cf 93       	push	r28
    59be:	df 93       	push	r29
    59c0:	6b 01       	movw	r12, r22
    59c2:	7c 01       	movw	r14, r24
    59c4:	c4 2f       	mov	r28, r20
    59c6:	85 2e       	mov	r8, r21
    59c8:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    59ca:	88 e0       	ldi	r24, 0x08	; 8
    59cc:	60 e0       	ldi	r22, 0x00	; 0
    59ce:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    59d2:	80 e0       	ldi	r24, 0x00	; 0
    59d4:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    59d8:	81 e0       	ldi	r24, 0x01	; 1
    59da:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    59de:	82 e1       	ldi	r24, 0x12	; 18
    59e0:	b7 01       	movw	r22, r14
    59e2:	a6 01       	movw	r20, r12
    59e4:	2f ef       	ldi	r18, 0xFF	; 255
    59e6:	08 e0       	ldi	r16, 0x08	; 8
    59e8:	10 e0       	ldi	r17, 0x00	; 0
    59ea:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
    59ee:	88 23       	and	r24, r24
    59f0:	b1 f7       	brne	.-20     	; 0x59de <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    59f2:	16 14       	cp	r1, r6
    59f4:	17 04       	cpc	r1, r7
    59f6:	0c f0       	brlt	.+2      	; 0x59fa <SD_read_multiple_blocks+0x5e>
    59f8:	46 c0       	rjmp	.+140    	; 0x5a86 <SD_read_multiple_blocks+0xea>
    59fa:	ac 2e       	mov	r10, r28
    59fc:	b8 2c       	mov	r11, r8
    59fe:	88 24       	eor	r8, r8
    5a00:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5a02:	0f 2e       	mov	r0, r31
    5a04:	f5 e3       	ldi	r31, 0x35	; 53
    5a06:	cf 2e       	mov	r12, r31
    5a08:	fe e3       	ldi	r31, 0x3E	; 62
    5a0a:	df 2e       	mov	r13, r31
    5a0c:	f0 2d       	mov	r31, r0
    5a0e:	ff 24       	eor	r15, r15
    5a10:	fa 94       	dec	r15
    5a12:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5a14:	0f 2e       	mov	r0, r31
    5a16:	f4 e3       	ldi	r31, 0x34	; 52
    5a18:	4f 2e       	mov	r4, r31
    5a1a:	fe e3       	ldi	r31, 0x3E	; 62
    5a1c:	5f 2e       	mov	r5, r31
    5a1e:	f0 2d       	mov	r31, r0
    5a20:	12 01       	movw	r2, r4
    5a22:	08 94       	sec
    5a24:	21 1c       	adc	r2, r1
    5a26:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5a28:	f6 01       	movw	r30, r12
    5a2a:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5a2c:	80 81       	ld	r24, Z
    5a2e:	8e 3f       	cpi	r24, 0xFE	; 254
    5a30:	41 f0       	breq	.+16     	; 0x5a42 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5a32:	8f 2d       	mov	r24, r15
    5a34:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a38:	f6 01       	movw	r30, r12
    5a3a:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5a3c:	80 81       	ld	r24, Z
    5a3e:	8e 3f       	cpi	r24, 0xFE	; 254
    5a40:	c1 f7       	brne	.-16     	; 0x5a32 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5a42:	85 01       	movw	r16, r10
    5a44:	c0 e0       	ldi	r28, 0x00	; 0
    5a46:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5a48:	8f 2d       	mov	r24, r15
    5a4a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a4e:	f8 01       	movw	r30, r16
    5a50:	81 93       	st	Z+, r24
    5a52:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5a54:	21 96       	adiw	r28, 0x01	; 1
    5a56:	f2 e0       	ldi	r31, 0x02	; 2
    5a58:	c0 30       	cpi	r28, 0x00	; 0
    5a5a:	df 07       	cpc	r29, r31
    5a5c:	a9 f7       	brne	.-22     	; 0x5a48 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5a5e:	8f 2d       	mov	r24, r15
    5a60:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a64:	f2 01       	movw	r30, r4
    5a66:	80 83       	st	Z, r24
    5a68:	8f 2d       	mov	r24, r15
    5a6a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a6e:	f1 01       	movw	r30, r2
    5a70:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5a72:	08 94       	sec
    5a74:	81 1c       	adc	r8, r1
    5a76:	91 1c       	adc	r9, r1
    5a78:	80 e0       	ldi	r24, 0x00	; 0
    5a7a:	92 e0       	ldi	r25, 0x02	; 2
    5a7c:	a8 0e       	add	r10, r24
    5a7e:	b9 1e       	adc	r11, r25
    5a80:	86 14       	cp	r8, r6
    5a82:	97 04       	cpc	r9, r7
    5a84:	89 f6       	brne	.-94     	; 0x5a28 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5a86:	8c e0       	ldi	r24, 0x0C	; 12
    5a88:	40 e0       	ldi	r20, 0x00	; 0
    5a8a:	50 e0       	ldi	r21, 0x00	; 0
    5a8c:	ba 01       	movw	r22, r20
    5a8e:	2f ef       	ldi	r18, 0xFF	; 255
    5a90:	08 e0       	ldi	r16, 0x08	; 8
    5a92:	10 e0       	ldi	r17, 0x00	; 0
    5a94:	0e 94 1d 29 	call	0x523a	; 0x523a <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5a98:	8f ef       	ldi	r24, 0xFF	; 255
    5a9a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a9e:	80 93 34 3e 	sts	0x3E34, r24
	Buffer[1] = FILLER_BYTE;
    5aa2:	10 92 35 3e 	sts	0x3E35, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5aa6:	80 91 35 3e 	lds	r24, 0x3E35
    5aaa:	8f 3f       	cpi	r24, 0xFF	; 255
    5aac:	49 f0       	breq	.+18     	; 0x5ac0 <SD_read_multiple_blocks+0x124>
    5aae:	c5 e3       	ldi	r28, 0x35	; 53
    5ab0:	de e3       	ldi	r29, 0x3E	; 62
    5ab2:	8f ef       	ldi	r24, 0xFF	; 255
    5ab4:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5ab8:	88 83       	st	Y, r24
    5aba:	88 81       	ld	r24, Y
    5abc:	8f 3f       	cpi	r24, 0xFF	; 255
    5abe:	c9 f7       	brne	.-14     	; 0x5ab2 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5ac0:	80 e0       	ldi	r24, 0x00	; 0
    5ac2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5ac6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5aca:	88 e0       	ldi	r24, 0x08	; 8
    5acc:	60 e0       	ldi	r22, 0x00	; 0
    5ace:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5ad2:	df 91       	pop	r29
    5ad4:	cf 91       	pop	r28
    5ad6:	1f 91       	pop	r17
    5ad8:	0f 91       	pop	r16
    5ada:	ff 90       	pop	r15
    5adc:	ef 90       	pop	r14
    5ade:	df 90       	pop	r13
    5ae0:	cf 90       	pop	r12
    5ae2:	bf 90       	pop	r11
    5ae4:	af 90       	pop	r10
    5ae6:	9f 90       	pop	r9
    5ae8:	8f 90       	pop	r8
    5aea:	7f 90       	pop	r7
    5aec:	6f 90       	pop	r6
    5aee:	5f 90       	pop	r5
    5af0:	4f 90       	pop	r4
    5af2:	3f 90       	pop	r3
    5af4:	2f 90       	pop	r2
    5af6:	08 95       	ret

00005af8 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5af8:	88 e0       	ldi	r24, 0x08	; 8
    5afa:	60 e0       	ldi	r22, 0x00	; 0
    5afc:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5b00:	88 e0       	ldi	r24, 0x08	; 8
    5b02:	60 e0       	ldi	r22, 0x00	; 0
    5b04:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5b08:	80 e0       	ldi	r24, 0x00	; 0
    5b0a:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5b0e:	81 e0       	ldi	r24, 0x01	; 1
    5b10:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5b14:	8f ef       	ldi	r24, 0xFF	; 255
    5b16:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPICS(FALSE);	//stop spi
    5b1a:	80 e0       	ldi	r24, 0x00	; 0
    5b1c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5b20:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5b24:	80 e0       	ldi	r24, 0x00	; 0
    5b26:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5b2a:	80 e0       	ldi	r24, 0x00	; 0
    5b2c:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
}
    5b30:	08 95       	ret

00005b32 <__muldi3>:
    5b32:	a0 e3       	ldi	r26, 0x30	; 48
    5b34:	b0 e0       	ldi	r27, 0x00	; 0
    5b36:	ef e9       	ldi	r30, 0x9F	; 159
    5b38:	fd e2       	ldi	r31, 0x2D	; 45
    5b3a:	0c 94 38 39 	jmp	0x7270	; 0x7270 <__prologue_saves__+0x4>
    5b3e:	29 8f       	std	Y+25, r18	; 0x19
    5b40:	3a 8f       	std	Y+26, r19	; 0x1a
    5b42:	4b 8f       	std	Y+27, r20	; 0x1b
    5b44:	5c 8f       	std	Y+28, r21	; 0x1c
    5b46:	6d 8f       	std	Y+29, r22	; 0x1d
    5b48:	7e 8f       	std	Y+30, r23	; 0x1e
    5b4a:	8f 8f       	std	Y+31, r24	; 0x1f
    5b4c:	98 a3       	lds	r25, 0x58
    5b4e:	a9 8a       	std	Y+17, r10	; 0x11
    5b50:	ba 8a       	std	Y+18, r11	; 0x12
    5b52:	cb 8a       	std	Y+19, r12	; 0x13
    5b54:	dc 8a       	std	Y+20, r13	; 0x14
    5b56:	ed 8a       	std	Y+21, r14	; 0x15
    5b58:	fe 8a       	std	Y+22, r15	; 0x16
    5b5a:	0f 8b       	std	Y+23, r16	; 0x17
    5b5c:	18 8f       	std	Y+24, r17	; 0x18
    5b5e:	09 8d       	ldd	r16, Y+25	; 0x19
    5b60:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5b62:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5b64:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5b66:	09 a3       	lds	r16, 0x59
    5b68:	1a a3       	lds	r17, 0x5a
    5b6a:	2b a3       	lds	r18, 0x5b
    5b6c:	3c a3       	lds	r19, 0x5c
    5b6e:	68 01       	movw	r12, r16
    5b70:	79 01       	movw	r14, r18
    5b72:	8f ef       	ldi	r24, 0xFF	; 255
    5b74:	9f ef       	ldi	r25, 0xFF	; 255
    5b76:	a0 e0       	ldi	r26, 0x00	; 0
    5b78:	b0 e0       	ldi	r27, 0x00	; 0
    5b7a:	c8 22       	and	r12, r24
    5b7c:	d9 22       	and	r13, r25
    5b7e:	ea 22       	and	r14, r26
    5b80:	fb 22       	and	r15, r27
    5b82:	89 01       	movw	r16, r18
    5b84:	22 27       	eor	r18, r18
    5b86:	33 27       	eor	r19, r19
    5b88:	09 a7       	lds	r16, 0x79
    5b8a:	1a a7       	lds	r17, 0x7a
    5b8c:	2b a7       	lds	r18, 0x7b
    5b8e:	3c a7       	lds	r19, 0x7c
    5b90:	09 89       	ldd	r16, Y+17	; 0x11
    5b92:	1a 89       	ldd	r17, Y+18	; 0x12
    5b94:	2b 89       	ldd	r18, Y+19	; 0x13
    5b96:	3c 89       	ldd	r19, Y+20	; 0x14
    5b98:	0d a3       	lds	r16, 0x5d
    5b9a:	1e a3       	lds	r17, 0x5e
    5b9c:	2f a3       	lds	r18, 0x5f
    5b9e:	38 a7       	lds	r19, 0x78
    5ba0:	48 01       	movw	r8, r16
    5ba2:	59 01       	movw	r10, r18
    5ba4:	88 22       	and	r8, r24
    5ba6:	99 22       	and	r9, r25
    5ba8:	aa 22       	and	r10, r26
    5baa:	bb 22       	and	r11, r27
    5bac:	29 01       	movw	r4, r18
    5bae:	66 24       	eor	r6, r6
    5bb0:	77 24       	eor	r7, r7
    5bb2:	c5 01       	movw	r24, r10
    5bb4:	b4 01       	movw	r22, r8
    5bb6:	a7 01       	movw	r20, r14
    5bb8:	96 01       	movw	r18, r12
    5bba:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    5bbe:	6d a7       	lds	r22, 0x7d
    5bc0:	7e a7       	lds	r23, 0x7e
    5bc2:	8f a7       	lds	r24, 0x7f
    5bc4:	98 ab       	sts	0x58, r25
    5bc6:	c3 01       	movw	r24, r6
    5bc8:	b2 01       	movw	r22, r4
    5bca:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    5bce:	6b 01       	movw	r12, r22
    5bd0:	7c 01       	movw	r14, r24
    5bd2:	c5 01       	movw	r24, r10
    5bd4:	b4 01       	movw	r22, r8
    5bd6:	29 a5       	lds	r18, 0x69
    5bd8:	3a a5       	lds	r19, 0x6a
    5bda:	4b a5       	lds	r20, 0x6b
    5bdc:	5c a5       	lds	r21, 0x6c
    5bde:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    5be2:	4b 01       	movw	r8, r22
    5be4:	5c 01       	movw	r10, r24
    5be6:	c3 01       	movw	r24, r6
    5be8:	b2 01       	movw	r22, r4
    5bea:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    5bee:	ab 01       	movw	r20, r22
    5bf0:	bc 01       	movw	r22, r24
    5bf2:	c8 0c       	add	r12, r8
    5bf4:	d9 1c       	adc	r13, r9
    5bf6:	ea 1c       	adc	r14, r10
    5bf8:	fb 1c       	adc	r15, r11
    5bfa:	0d a5       	lds	r16, 0x6d
    5bfc:	1e a5       	lds	r17, 0x6e
    5bfe:	2f a5       	lds	r18, 0x6f
    5c00:	38 a9       	sts	0x48, r19
    5c02:	c9 01       	movw	r24, r18
    5c04:	aa 27       	eor	r26, r26
    5c06:	bb 27       	eor	r27, r27
    5c08:	c8 0e       	add	r12, r24
    5c0a:	d9 1e       	adc	r13, r25
    5c0c:	ea 1e       	adc	r14, r26
    5c0e:	fb 1e       	adc	r15, r27
    5c10:	c8 14       	cp	r12, r8
    5c12:	d9 04       	cpc	r13, r9
    5c14:	ea 04       	cpc	r14, r10
    5c16:	fb 04       	cpc	r15, r11
    5c18:	20 f4       	brcc	.+8      	; 0x5c22 <__muldi3+0xf0>
    5c1a:	40 50       	subi	r20, 0x00	; 0
    5c1c:	50 40       	sbci	r21, 0x00	; 0
    5c1e:	6f 4f       	sbci	r22, 0xFF	; 255
    5c20:	7f 4f       	sbci	r23, 0xFF	; 255
    5c22:	c7 01       	movw	r24, r14
    5c24:	aa 27       	eor	r26, r26
    5c26:	bb 27       	eor	r27, r27
    5c28:	84 0f       	add	r24, r20
    5c2a:	95 1f       	adc	r25, r21
    5c2c:	a6 1f       	adc	r26, r22
    5c2e:	b7 1f       	adc	r27, r23
    5c30:	8d 83       	std	Y+5, r24	; 0x05
    5c32:	9e 83       	std	Y+6, r25	; 0x06
    5c34:	af 83       	std	Y+7, r26	; 0x07
    5c36:	b8 87       	std	Y+8, r27	; 0x08
    5c38:	76 01       	movw	r14, r12
    5c3a:	dd 24       	eor	r13, r13
    5c3c:	cc 24       	eor	r12, r12
    5c3e:	4d a5       	lds	r20, 0x6d
    5c40:	5e a5       	lds	r21, 0x6e
    5c42:	6f a5       	lds	r22, 0x6f
    5c44:	78 a9       	sts	0x48, r23
    5c46:	60 70       	andi	r22, 0x00	; 0
    5c48:	70 70       	andi	r23, 0x00	; 0
    5c4a:	c4 0e       	add	r12, r20
    5c4c:	d5 1e       	adc	r13, r21
    5c4e:	e6 1e       	adc	r14, r22
    5c50:	f7 1e       	adc	r15, r23
    5c52:	c9 82       	std	Y+1, r12	; 0x01
    5c54:	da 82       	std	Y+2, r13	; 0x02
    5c56:	eb 82       	std	Y+3, r14	; 0x03
    5c58:	fc 82       	std	Y+4, r15	; 0x04
    5c5a:	1c 2d       	mov	r17, r12
    5c5c:	0a 81       	ldd	r16, Y+2	; 0x02
    5c5e:	8b 80       	ldd	r8, Y+3	; 0x03
    5c60:	4c 80       	ldd	r4, Y+4	; 0x04
    5c62:	8d 87       	std	Y+13, r24	; 0x0d
    5c64:	8e 81       	ldd	r24, Y+6	; 0x06
    5c66:	8e 87       	std	Y+14, r24	; 0x0e
    5c68:	8f 81       	ldd	r24, Y+7	; 0x07
    5c6a:	8f 87       	std	Y+15, r24	; 0x0f
    5c6c:	88 85       	ldd	r24, Y+8	; 0x08
    5c6e:	88 8b       	std	Y+16, r24	; 0x10
    5c70:	2d 89       	ldd	r18, Y+21	; 0x15
    5c72:	3e 89       	ldd	r19, Y+22	; 0x16
    5c74:	4f 89       	ldd	r20, Y+23	; 0x17
    5c76:	58 8d       	ldd	r21, Y+24	; 0x18
    5c78:	69 a1       	lds	r22, 0x49
    5c7a:	7a a1       	lds	r23, 0x4a
    5c7c:	8b a1       	lds	r24, 0x4b
    5c7e:	9c a1       	lds	r25, 0x4c
    5c80:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    5c84:	6b 01       	movw	r12, r22
    5c86:	7c 01       	movw	r14, r24
    5c88:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5c8a:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5c8c:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5c8e:	58 a1       	lds	r21, 0x48
    5c90:	6d a1       	lds	r22, 0x4d
    5c92:	7e a1       	lds	r23, 0x4e
    5c94:	8f a1       	lds	r24, 0x4f
    5c96:	98 a5       	lds	r25, 0x68
    5c98:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    5c9c:	dc 01       	movw	r26, r24
    5c9e:	cb 01       	movw	r24, r22
    5ca0:	c8 0e       	add	r12, r24
    5ca2:	d9 1e       	adc	r13, r25
    5ca4:	ea 1e       	adc	r14, r26
    5ca6:	fb 1e       	adc	r15, r27
    5ca8:	8d 85       	ldd	r24, Y+13	; 0x0d
    5caa:	9e 85       	ldd	r25, Y+14	; 0x0e
    5cac:	af 85       	ldd	r26, Y+15	; 0x0f
    5cae:	b8 89       	ldd	r27, Y+16	; 0x10
    5cb0:	8c 0d       	add	r24, r12
    5cb2:	9d 1d       	adc	r25, r13
    5cb4:	ae 1d       	adc	r26, r14
    5cb6:	bf 1d       	adc	r27, r15
    5cb8:	8d 87       	std	Y+13, r24	; 0x0d
    5cba:	9e 87       	std	Y+14, r25	; 0x0e
    5cbc:	af 87       	std	Y+15, r26	; 0x0f
    5cbe:	b8 8b       	std	Y+16, r27	; 0x10
    5cc0:	68 2f       	mov	r22, r24
    5cc2:	7e 85       	ldd	r23, Y+14	; 0x0e
    5cc4:	21 2f       	mov	r18, r17
    5cc6:	30 2f       	mov	r19, r16
    5cc8:	48 2d       	mov	r20, r8
    5cca:	54 2d       	mov	r21, r4
    5ccc:	8f 85       	ldd	r24, Y+15	; 0x0f
    5cce:	98 89       	ldd	r25, Y+16	; 0x10
    5cd0:	e0 96       	adiw	r28, 0x30	; 48
    5cd2:	e0 e1       	ldi	r30, 0x10	; 16
    5cd4:	0c 94 51 39 	jmp	0x72a2	; 0x72a2 <__epilogue_restores__+0x4>

00005cd8 <__ashldi3>:
    5cd8:	cf 92       	push	r12
    5cda:	df 92       	push	r13
    5cdc:	ef 92       	push	r14
    5cde:	ff 92       	push	r15
    5ce0:	0f 93       	push	r16
    5ce2:	cf 93       	push	r28
    5ce4:	df 93       	push	r29
    5ce6:	cd b7       	in	r28, 0x3d	; 61
    5ce8:	de b7       	in	r29, 0x3e	; 62
    5cea:	60 97       	sbiw	r28, 0x10	; 16
    5cec:	cd bf       	out	0x3d, r28	; 61
    5cee:	de bf       	out	0x3e, r29	; 62
    5cf0:	00 23       	and	r16, r16
    5cf2:	09 f4       	brne	.+2      	; 0x5cf6 <__ashldi3+0x1e>
    5cf4:	5a c0       	rjmp	.+180    	; 0x5daa <__ashldi3+0xd2>
    5cf6:	29 87       	std	Y+9, r18	; 0x09
    5cf8:	3a 87       	std	Y+10, r19	; 0x0a
    5cfa:	4b 87       	std	Y+11, r20	; 0x0b
    5cfc:	5c 87       	std	Y+12, r21	; 0x0c
    5cfe:	6d 87       	std	Y+13, r22	; 0x0d
    5d00:	7e 87       	std	Y+14, r23	; 0x0e
    5d02:	8f 87       	std	Y+15, r24	; 0x0f
    5d04:	98 8b       	std	Y+16, r25	; 0x10
    5d06:	80 e2       	ldi	r24, 0x20	; 32
    5d08:	80 1b       	sub	r24, r16
    5d0a:	49 85       	ldd	r20, Y+9	; 0x09
    5d0c:	5a 85       	ldd	r21, Y+10	; 0x0a
    5d0e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5d10:	7c 85       	ldd	r23, Y+12	; 0x0c
    5d12:	18 16       	cp	r1, r24
    5d14:	b4 f0       	brlt	.+44     	; 0x5d42 <__ashldi3+0x6a>
    5d16:	19 82       	std	Y+1, r1	; 0x01
    5d18:	1a 82       	std	Y+2, r1	; 0x02
    5d1a:	1b 82       	std	Y+3, r1	; 0x03
    5d1c:	1c 82       	std	Y+4, r1	; 0x04
    5d1e:	99 27       	eor	r25, r25
    5d20:	87 fd       	sbrc	r24, 7
    5d22:	90 95       	com	r25
    5d24:	90 95       	com	r25
    5d26:	81 95       	neg	r24
    5d28:	9f 4f       	sbci	r25, 0xFF	; 255
    5d2a:	04 c0       	rjmp	.+8      	; 0x5d34 <__ashldi3+0x5c>
    5d2c:	44 0f       	add	r20, r20
    5d2e:	55 1f       	adc	r21, r21
    5d30:	66 1f       	adc	r22, r22
    5d32:	77 1f       	adc	r23, r23
    5d34:	8a 95       	dec	r24
    5d36:	d2 f7       	brpl	.-12     	; 0x5d2c <__ashldi3+0x54>
    5d38:	4d 83       	std	Y+5, r20	; 0x05
    5d3a:	5e 83       	std	Y+6, r21	; 0x06
    5d3c:	6f 83       	std	Y+7, r22	; 0x07
    5d3e:	78 87       	std	Y+8, r23	; 0x08
    5d40:	2c c0       	rjmp	.+88     	; 0x5d9a <__ashldi3+0xc2>
    5d42:	6a 01       	movw	r12, r20
    5d44:	7b 01       	movw	r14, r22
    5d46:	00 2e       	mov	r0, r16
    5d48:	04 c0       	rjmp	.+8      	; 0x5d52 <__ashldi3+0x7a>
    5d4a:	cc 0c       	add	r12, r12
    5d4c:	dd 1c       	adc	r13, r13
    5d4e:	ee 1c       	adc	r14, r14
    5d50:	ff 1c       	adc	r15, r15
    5d52:	0a 94       	dec	r0
    5d54:	d2 f7       	brpl	.-12     	; 0x5d4a <__ashldi3+0x72>
    5d56:	c9 82       	std	Y+1, r12	; 0x01
    5d58:	da 82       	std	Y+2, r13	; 0x02
    5d5a:	eb 82       	std	Y+3, r14	; 0x03
    5d5c:	fc 82       	std	Y+4, r15	; 0x04
    5d5e:	6a 01       	movw	r12, r20
    5d60:	7b 01       	movw	r14, r22
    5d62:	04 c0       	rjmp	.+8      	; 0x5d6c <__ashldi3+0x94>
    5d64:	f6 94       	lsr	r15
    5d66:	e7 94       	ror	r14
    5d68:	d7 94       	ror	r13
    5d6a:	c7 94       	ror	r12
    5d6c:	8a 95       	dec	r24
    5d6e:	d2 f7       	brpl	.-12     	; 0x5d64 <__ashldi3+0x8c>
    5d70:	d7 01       	movw	r26, r14
    5d72:	c6 01       	movw	r24, r12
    5d74:	4d 85       	ldd	r20, Y+13	; 0x0d
    5d76:	5e 85       	ldd	r21, Y+14	; 0x0e
    5d78:	6f 85       	ldd	r22, Y+15	; 0x0f
    5d7a:	78 89       	ldd	r23, Y+16	; 0x10
    5d7c:	04 c0       	rjmp	.+8      	; 0x5d86 <__ashldi3+0xae>
    5d7e:	44 0f       	add	r20, r20
    5d80:	55 1f       	adc	r21, r21
    5d82:	66 1f       	adc	r22, r22
    5d84:	77 1f       	adc	r23, r23
    5d86:	0a 95       	dec	r16
    5d88:	d2 f7       	brpl	.-12     	; 0x5d7e <__ashldi3+0xa6>
    5d8a:	84 2b       	or	r24, r20
    5d8c:	95 2b       	or	r25, r21
    5d8e:	a6 2b       	or	r26, r22
    5d90:	b7 2b       	or	r27, r23
    5d92:	8d 83       	std	Y+5, r24	; 0x05
    5d94:	9e 83       	std	Y+6, r25	; 0x06
    5d96:	af 83       	std	Y+7, r26	; 0x07
    5d98:	b8 87       	std	Y+8, r27	; 0x08
    5d9a:	29 81       	ldd	r18, Y+1	; 0x01
    5d9c:	3a 81       	ldd	r19, Y+2	; 0x02
    5d9e:	4b 81       	ldd	r20, Y+3	; 0x03
    5da0:	5c 81       	ldd	r21, Y+4	; 0x04
    5da2:	6d 81       	ldd	r22, Y+5	; 0x05
    5da4:	7e 81       	ldd	r23, Y+6	; 0x06
    5da6:	8f 81       	ldd	r24, Y+7	; 0x07
    5da8:	98 85       	ldd	r25, Y+8	; 0x08
    5daa:	60 96       	adiw	r28, 0x10	; 16
    5dac:	cd bf       	out	0x3d, r28	; 61
    5dae:	de bf       	out	0x3e, r29	; 62
    5db0:	df 91       	pop	r29
    5db2:	cf 91       	pop	r28
    5db4:	0f 91       	pop	r16
    5db6:	ff 90       	pop	r15
    5db8:	ef 90       	pop	r14
    5dba:	df 90       	pop	r13
    5dbc:	cf 90       	pop	r12
    5dbe:	08 95       	ret

00005dc0 <__ashrdi3>:
    5dc0:	0f 93       	push	r16
    5dc2:	cf 93       	push	r28
    5dc4:	df 93       	push	r29
    5dc6:	cd b7       	in	r28, 0x3d	; 61
    5dc8:	de b7       	in	r29, 0x3e	; 62
    5dca:	60 97       	sbiw	r28, 0x10	; 16
    5dcc:	cd bf       	out	0x3d, r28	; 61
    5dce:	de bf       	out	0x3e, r29	; 62
    5dd0:	00 23       	and	r16, r16
    5dd2:	09 f4       	brne	.+2      	; 0x5dd6 <__ashrdi3+0x16>
    5dd4:	56 c0       	rjmp	.+172    	; 0x5e82 <__ashrdi3+0xc2>
    5dd6:	29 87       	std	Y+9, r18	; 0x09
    5dd8:	3a 87       	std	Y+10, r19	; 0x0a
    5dda:	4b 87       	std	Y+11, r20	; 0x0b
    5ddc:	5c 87       	std	Y+12, r21	; 0x0c
    5dde:	6d 87       	std	Y+13, r22	; 0x0d
    5de0:	7e 87       	std	Y+14, r23	; 0x0e
    5de2:	8f 87       	std	Y+15, r24	; 0x0f
    5de4:	98 8b       	std	Y+16, r25	; 0x10
    5de6:	20 e2       	ldi	r18, 0x20	; 32
    5de8:	20 1b       	sub	r18, r16
    5dea:	8d 85       	ldd	r24, Y+13	; 0x0d
    5dec:	9e 85       	ldd	r25, Y+14	; 0x0e
    5dee:	af 85       	ldd	r26, Y+15	; 0x0f
    5df0:	b8 89       	ldd	r27, Y+16	; 0x10
    5df2:	ac 01       	movw	r20, r24
    5df4:	bd 01       	movw	r22, r26
    5df6:	12 16       	cp	r1, r18
    5df8:	b4 f0       	brlt	.+44     	; 0x5e26 <__ashrdi3+0x66>
    5dfa:	77 0f       	add	r23, r23
    5dfc:	44 0b       	sbc	r20, r20
    5dfe:	54 2f       	mov	r21, r20
    5e00:	ba 01       	movw	r22, r20
    5e02:	4d 83       	std	Y+5, r20	; 0x05
    5e04:	5e 83       	std	Y+6, r21	; 0x06
    5e06:	6f 83       	std	Y+7, r22	; 0x07
    5e08:	78 87       	std	Y+8, r23	; 0x08
    5e0a:	33 27       	eor	r19, r19
    5e0c:	27 fd       	sbrc	r18, 7
    5e0e:	30 95       	com	r19
    5e10:	30 95       	com	r19
    5e12:	21 95       	neg	r18
    5e14:	3f 4f       	sbci	r19, 0xFF	; 255
    5e16:	04 c0       	rjmp	.+8      	; 0x5e20 <__ashrdi3+0x60>
    5e18:	b5 95       	asr	r27
    5e1a:	a7 95       	ror	r26
    5e1c:	97 95       	ror	r25
    5e1e:	87 95       	ror	r24
    5e20:	2a 95       	dec	r18
    5e22:	d2 f7       	brpl	.-12     	; 0x5e18 <__ashrdi3+0x58>
    5e24:	22 c0       	rjmp	.+68     	; 0x5e6a <__ashrdi3+0xaa>
    5e26:	00 2e       	mov	r0, r16
    5e28:	04 c0       	rjmp	.+8      	; 0x5e32 <__ashrdi3+0x72>
    5e2a:	75 95       	asr	r23
    5e2c:	67 95       	ror	r22
    5e2e:	57 95       	ror	r21
    5e30:	47 95       	ror	r20
    5e32:	0a 94       	dec	r0
    5e34:	d2 f7       	brpl	.-12     	; 0x5e2a <__ashrdi3+0x6a>
    5e36:	4d 83       	std	Y+5, r20	; 0x05
    5e38:	5e 83       	std	Y+6, r21	; 0x06
    5e3a:	6f 83       	std	Y+7, r22	; 0x07
    5e3c:	78 87       	std	Y+8, r23	; 0x08
    5e3e:	04 c0       	rjmp	.+8      	; 0x5e48 <__ashrdi3+0x88>
    5e40:	88 0f       	add	r24, r24
    5e42:	99 1f       	adc	r25, r25
    5e44:	aa 1f       	adc	r26, r26
    5e46:	bb 1f       	adc	r27, r27
    5e48:	2a 95       	dec	r18
    5e4a:	d2 f7       	brpl	.-12     	; 0x5e40 <__ashrdi3+0x80>
    5e4c:	49 85       	ldd	r20, Y+9	; 0x09
    5e4e:	5a 85       	ldd	r21, Y+10	; 0x0a
    5e50:	6b 85       	ldd	r22, Y+11	; 0x0b
    5e52:	7c 85       	ldd	r23, Y+12	; 0x0c
    5e54:	04 c0       	rjmp	.+8      	; 0x5e5e <__ashrdi3+0x9e>
    5e56:	76 95       	lsr	r23
    5e58:	67 95       	ror	r22
    5e5a:	57 95       	ror	r21
    5e5c:	47 95       	ror	r20
    5e5e:	0a 95       	dec	r16
    5e60:	d2 f7       	brpl	.-12     	; 0x5e56 <__ashrdi3+0x96>
    5e62:	84 2b       	or	r24, r20
    5e64:	95 2b       	or	r25, r21
    5e66:	a6 2b       	or	r26, r22
    5e68:	b7 2b       	or	r27, r23
    5e6a:	89 83       	std	Y+1, r24	; 0x01
    5e6c:	9a 83       	std	Y+2, r25	; 0x02
    5e6e:	ab 83       	std	Y+3, r26	; 0x03
    5e70:	bc 83       	std	Y+4, r27	; 0x04
    5e72:	29 81       	ldd	r18, Y+1	; 0x01
    5e74:	3a 81       	ldd	r19, Y+2	; 0x02
    5e76:	4b 81       	ldd	r20, Y+3	; 0x03
    5e78:	5c 81       	ldd	r21, Y+4	; 0x04
    5e7a:	6d 81       	ldd	r22, Y+5	; 0x05
    5e7c:	7e 81       	ldd	r23, Y+6	; 0x06
    5e7e:	8f 81       	ldd	r24, Y+7	; 0x07
    5e80:	98 85       	ldd	r25, Y+8	; 0x08
    5e82:	60 96       	adiw	r28, 0x10	; 16
    5e84:	cd bf       	out	0x3d, r28	; 61
    5e86:	de bf       	out	0x3e, r29	; 62
    5e88:	df 91       	pop	r29
    5e8a:	cf 91       	pop	r28
    5e8c:	0f 91       	pop	r16
    5e8e:	08 95       	ret

00005e90 <__divdi3>:
    5e90:	a8 e4       	ldi	r26, 0x48	; 72
    5e92:	b0 e0       	ldi	r27, 0x00	; 0
    5e94:	ee e4       	ldi	r30, 0x4E	; 78
    5e96:	ff e2       	ldi	r31, 0x2F	; 47
    5e98:	0c 94 37 39 	jmp	0x726e	; 0x726e <__prologue_saves__+0x2>
    5e9c:	f5 01       	movw	r30, r10
    5e9e:	29 a3       	lds	r18, 0x59
    5ea0:	3a a3       	lds	r19, 0x5a
    5ea2:	4b a3       	lds	r20, 0x5b
    5ea4:	5c a3       	lds	r21, 0x5c
    5ea6:	6d a3       	lds	r22, 0x5d
    5ea8:	7e a3       	lds	r23, 0x5e
    5eaa:	8f a3       	lds	r24, 0x5f
    5eac:	98 a7       	lds	r25, 0x78
    5eae:	a9 8e       	std	Y+25, r10	; 0x19
    5eb0:	fa 8f       	std	Y+26, r31	; 0x1a
    5eb2:	cb 8e       	std	Y+27, r12	; 0x1b
    5eb4:	dc 8e       	std	Y+28, r13	; 0x1c
    5eb6:	ed 8e       	std	Y+29, r14	; 0x1d
    5eb8:	fe 8e       	std	Y+30, r15	; 0x1e
    5eba:	0f 8f       	std	Y+31, r16	; 0x1f
    5ebc:	18 a3       	lds	r17, 0x58
    5ebe:	8d a0       	lds	r24, 0x8d
    5ec0:	9e a0       	lds	r25, 0x8e
    5ec2:	af a0       	lds	r26, 0x8f
    5ec4:	b8 a4       	lds	r27, 0xa8
    5ec6:	b7 fe       	sbrs	r11, 7
    5ec8:	67 c0       	rjmp	.+206    	; 0x5f98 <__divdi3+0x108>
    5eca:	21 95       	neg	r18
    5ecc:	b1 e0       	ldi	r27, 0x01	; 1
    5ece:	12 16       	cp	r1, r18
    5ed0:	08 f0       	brcs	.+2      	; 0x5ed4 <__divdi3+0x44>
    5ed2:	b0 e0       	ldi	r27, 0x00	; 0
    5ed4:	31 95       	neg	r19
    5ed6:	a1 e0       	ldi	r26, 0x01	; 1
    5ed8:	13 16       	cp	r1, r19
    5eda:	08 f0       	brcs	.+2      	; 0x5ede <__divdi3+0x4e>
    5edc:	a0 e0       	ldi	r26, 0x00	; 0
    5ede:	b3 2e       	mov	r11, r19
    5ee0:	bb 1a       	sub	r11, r27
    5ee2:	bb 2d       	mov	r27, r11
    5ee4:	88 24       	eor	r8, r8
    5ee6:	83 94       	inc	r8
    5ee8:	3b 15       	cp	r19, r11
    5eea:	08 f0       	brcs	.+2      	; 0x5eee <__divdi3+0x5e>
    5eec:	88 24       	eor	r8, r8
    5eee:	a8 29       	or	r26, r8
    5ef0:	41 95       	neg	r20
    5ef2:	31 e0       	ldi	r19, 0x01	; 1
    5ef4:	14 16       	cp	r1, r20
    5ef6:	08 f0       	brcs	.+2      	; 0x5efa <__divdi3+0x6a>
    5ef8:	30 e0       	ldi	r19, 0x00	; 0
    5efa:	b4 2e       	mov	r11, r20
    5efc:	ba 1a       	sub	r11, r26
    5efe:	ab 2d       	mov	r26, r11
    5f00:	88 24       	eor	r8, r8
    5f02:	83 94       	inc	r8
    5f04:	4b 15       	cp	r20, r11
    5f06:	08 f0       	brcs	.+2      	; 0x5f0a <__divdi3+0x7a>
    5f08:	88 24       	eor	r8, r8
    5f0a:	38 29       	or	r19, r8
    5f0c:	51 95       	neg	r21
    5f0e:	41 e0       	ldi	r20, 0x01	; 1
    5f10:	15 16       	cp	r1, r21
    5f12:	08 f0       	brcs	.+2      	; 0x5f16 <__divdi3+0x86>
    5f14:	40 e0       	ldi	r20, 0x00	; 0
    5f16:	45 2e       	mov	r4, r21
    5f18:	43 1a       	sub	r4, r19
    5f1a:	31 e0       	ldi	r19, 0x01	; 1
    5f1c:	54 15       	cp	r21, r4
    5f1e:	08 f0       	brcs	.+2      	; 0x5f22 <__divdi3+0x92>
    5f20:	30 e0       	ldi	r19, 0x00	; 0
    5f22:	43 2b       	or	r20, r19
    5f24:	61 95       	neg	r22
    5f26:	31 e0       	ldi	r19, 0x01	; 1
    5f28:	16 16       	cp	r1, r22
    5f2a:	08 f0       	brcs	.+2      	; 0x5f2e <__divdi3+0x9e>
    5f2c:	30 e0       	ldi	r19, 0x00	; 0
    5f2e:	86 2e       	mov	r8, r22
    5f30:	84 1a       	sub	r8, r20
    5f32:	41 e0       	ldi	r20, 0x01	; 1
    5f34:	68 15       	cp	r22, r8
    5f36:	08 f0       	brcs	.+2      	; 0x5f3a <__divdi3+0xaa>
    5f38:	40 e0       	ldi	r20, 0x00	; 0
    5f3a:	34 2b       	or	r19, r20
    5f3c:	71 95       	neg	r23
    5f3e:	41 e0       	ldi	r20, 0x01	; 1
    5f40:	17 16       	cp	r1, r23
    5f42:	08 f0       	brcs	.+2      	; 0x5f46 <__divdi3+0xb6>
    5f44:	40 e0       	ldi	r20, 0x00	; 0
    5f46:	57 2f       	mov	r21, r23
    5f48:	53 1b       	sub	r21, r19
    5f4a:	31 e0       	ldi	r19, 0x01	; 1
    5f4c:	75 17       	cp	r23, r21
    5f4e:	08 f0       	brcs	.+2      	; 0x5f52 <__divdi3+0xc2>
    5f50:	30 e0       	ldi	r19, 0x00	; 0
    5f52:	43 2b       	or	r20, r19
    5f54:	81 95       	neg	r24
    5f56:	31 e0       	ldi	r19, 0x01	; 1
    5f58:	18 16       	cp	r1, r24
    5f5a:	08 f0       	brcs	.+2      	; 0x5f5e <__divdi3+0xce>
    5f5c:	30 e0       	ldi	r19, 0x00	; 0
    5f5e:	68 2f       	mov	r22, r24
    5f60:	64 1b       	sub	r22, r20
    5f62:	46 2f       	mov	r20, r22
    5f64:	61 e0       	ldi	r22, 0x01	; 1
    5f66:	84 17       	cp	r24, r20
    5f68:	08 f0       	brcs	.+2      	; 0x5f6c <__divdi3+0xdc>
    5f6a:	60 e0       	ldi	r22, 0x00	; 0
    5f6c:	36 2b       	or	r19, r22
    5f6e:	91 95       	neg	r25
    5f70:	93 1b       	sub	r25, r19
    5f72:	29 a3       	lds	r18, 0x59
    5f74:	ba a3       	lds	r27, 0x5a
    5f76:	ab a3       	lds	r26, 0x5b
    5f78:	4c a2       	lds	r20, 0x9c
    5f7a:	8d a2       	lds	r24, 0x9d
    5f7c:	5e a3       	lds	r21, 0x5e
    5f7e:	4f a3       	lds	r20, 0x5f
    5f80:	98 a7       	lds	r25, 0x78
    5f82:	8f ef       	ldi	r24, 0xFF	; 255
    5f84:	9f ef       	ldi	r25, 0xFF	; 255
    5f86:	af ef       	ldi	r26, 0xFF	; 255
    5f88:	bf ef       	ldi	r27, 0xFF	; 255
    5f8a:	25 96       	adiw	r28, 0x05	; 5
    5f8c:	8c af       	sts	0x7c, r24
    5f8e:	9d af       	sts	0x7d, r25
    5f90:	ae af       	sts	0x7e, r26
    5f92:	bf af       	sts	0x7f, r27
    5f94:	25 97       	sbiw	r28, 0x05	; 5
    5f96:	06 c0       	rjmp	.+12     	; 0x5fa4 <__divdi3+0x114>
    5f98:	25 96       	adiw	r28, 0x05	; 5
    5f9a:	1c ae       	sts	0xbc, r17
    5f9c:	1d ae       	sts	0xbd, r17
    5f9e:	1e ae       	sts	0xbe, r17
    5fa0:	1f ae       	sts	0xbf, r17
    5fa2:	25 97       	sbiw	r28, 0x05	; 5
    5fa4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5fa6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5fa8:	af 8d       	ldd	r26, Y+31	; 0x1f
    5faa:	b8 a1       	lds	r27, 0x48
    5fac:	b7 ff       	sbrs	r27, 7
    5fae:	68 c0       	rjmp	.+208    	; 0x6080 <__stack+0x81>
    5fb0:	25 96       	adiw	r28, 0x05	; 5
    5fb2:	2c ad       	sts	0x6c, r18
    5fb4:	3d ad       	sts	0x6d, r19
    5fb6:	4e ad       	sts	0x6e, r20
    5fb8:	5f ad       	sts	0x6f, r21
    5fba:	25 97       	sbiw	r28, 0x05	; 5
    5fbc:	20 95       	com	r18
    5fbe:	30 95       	com	r19
    5fc0:	40 95       	com	r20
    5fc2:	50 95       	com	r21
    5fc4:	25 96       	adiw	r28, 0x05	; 5
    5fc6:	2c af       	sts	0x7c, r18
    5fc8:	3d af       	sts	0x7d, r19
    5fca:	4e af       	sts	0x7e, r20
    5fcc:	5f af       	sts	0x7f, r21
    5fce:	25 97       	sbiw	r28, 0x05	; 5
    5fd0:	e1 95       	neg	r30
    5fd2:	81 e0       	ldi	r24, 0x01	; 1
    5fd4:	1e 16       	cp	r1, r30
    5fd6:	08 f0       	brcs	.+2      	; 0x5fda <__divdi3+0x14a>
    5fd8:	80 e0       	ldi	r24, 0x00	; 0
    5fda:	f1 95       	neg	r31
    5fdc:	91 e0       	ldi	r25, 0x01	; 1
    5fde:	1f 16       	cp	r1, r31
    5fe0:	08 f0       	brcs	.+2      	; 0x5fe4 <__divdi3+0x154>
    5fe2:	90 e0       	ldi	r25, 0x00	; 0
    5fe4:	4f 2f       	mov	r20, r31
    5fe6:	48 1b       	sub	r20, r24
    5fe8:	81 e0       	ldi	r24, 0x01	; 1
    5fea:	f4 17       	cp	r31, r20
    5fec:	08 f0       	brcs	.+2      	; 0x5ff0 <__divdi3+0x160>
    5fee:	80 e0       	ldi	r24, 0x00	; 0
    5ff0:	98 2b       	or	r25, r24
    5ff2:	c1 94       	neg	r12
    5ff4:	81 e0       	ldi	r24, 0x01	; 1
    5ff6:	1c 14       	cp	r1, r12
    5ff8:	08 f0       	brcs	.+2      	; 0x5ffc <__divdi3+0x16c>
    5ffa:	80 e0       	ldi	r24, 0x00	; 0
    5ffc:	6c 2d       	mov	r22, r12
    5ffe:	69 1b       	sub	r22, r25
    6000:	91 e0       	ldi	r25, 0x01	; 1
    6002:	c6 16       	cp	r12, r22
    6004:	08 f0       	brcs	.+2      	; 0x6008 <__stack+0x9>
    6006:	90 e0       	ldi	r25, 0x00	; 0
    6008:	89 2b       	or	r24, r25
    600a:	d1 94       	neg	r13
    600c:	91 e0       	ldi	r25, 0x01	; 1
    600e:	1d 14       	cp	r1, r13
    6010:	08 f0       	brcs	.+2      	; 0x6014 <__stack+0x15>
    6012:	90 e0       	ldi	r25, 0x00	; 0
    6014:	5d 2d       	mov	r21, r13
    6016:	58 1b       	sub	r21, r24
    6018:	81 e0       	ldi	r24, 0x01	; 1
    601a:	d5 16       	cp	r13, r21
    601c:	08 f0       	brcs	.+2      	; 0x6020 <__stack+0x21>
    601e:	80 e0       	ldi	r24, 0x00	; 0
    6020:	98 2b       	or	r25, r24
    6022:	e1 94       	neg	r14
    6024:	81 e0       	ldi	r24, 0x01	; 1
    6026:	1e 14       	cp	r1, r14
    6028:	08 f0       	brcs	.+2      	; 0x602c <__stack+0x2d>
    602a:	80 e0       	ldi	r24, 0x00	; 0
    602c:	3e 2d       	mov	r19, r14
    602e:	39 1b       	sub	r19, r25
    6030:	91 e0       	ldi	r25, 0x01	; 1
    6032:	e3 16       	cp	r14, r19
    6034:	08 f0       	brcs	.+2      	; 0x6038 <__stack+0x39>
    6036:	90 e0       	ldi	r25, 0x00	; 0
    6038:	89 2b       	or	r24, r25
    603a:	f1 94       	neg	r15
    603c:	91 e0       	ldi	r25, 0x01	; 1
    603e:	1f 14       	cp	r1, r15
    6040:	08 f0       	brcs	.+2      	; 0x6044 <__stack+0x45>
    6042:	90 e0       	ldi	r25, 0x00	; 0
    6044:	2f 2d       	mov	r18, r15
    6046:	28 1b       	sub	r18, r24
    6048:	81 e0       	ldi	r24, 0x01	; 1
    604a:	f2 16       	cp	r15, r18
    604c:	08 f0       	brcs	.+2      	; 0x6050 <__stack+0x51>
    604e:	80 e0       	ldi	r24, 0x00	; 0
    6050:	98 2b       	or	r25, r24
    6052:	01 95       	neg	r16
    6054:	81 e0       	ldi	r24, 0x01	; 1
    6056:	10 16       	cp	r1, r16
    6058:	08 f0       	brcs	.+2      	; 0x605c <__stack+0x5d>
    605a:	80 e0       	ldi	r24, 0x00	; 0
    605c:	70 2f       	mov	r23, r16
    605e:	79 1b       	sub	r23, r25
    6060:	97 2f       	mov	r25, r23
    6062:	71 e0       	ldi	r23, 0x01	; 1
    6064:	09 17       	cp	r16, r25
    6066:	08 f0       	brcs	.+2      	; 0x606a <__stack+0x6b>
    6068:	70 e0       	ldi	r23, 0x00	; 0
    606a:	87 2b       	or	r24, r23
    606c:	11 95       	neg	r17
    606e:	18 1b       	sub	r17, r24
    6070:	e9 8f       	std	Y+25, r30	; 0x19
    6072:	4a 8f       	std	Y+26, r20	; 0x1a
    6074:	6b 8f       	std	Y+27, r22	; 0x1b
    6076:	5c 8f       	std	Y+28, r21	; 0x1c
    6078:	3d 8f       	std	Y+29, r19	; 0x1d
    607a:	2e 8f       	std	Y+30, r18	; 0x1e
    607c:	9f 8f       	std	Y+31, r25	; 0x1f
    607e:	18 a3       	lds	r17, 0x58
    6080:	79 8d       	ldd	r23, Y+25	; 0x19
    6082:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6084:	5b 8d       	ldd	r21, Y+27	; 0x1b
    6086:	4c 8d       	ldd	r20, Y+28	; 0x1c
    6088:	3d 8d       	ldd	r19, Y+29	; 0x1d
    608a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    608c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    608e:	88 a1       	lds	r24, 0x48
    6090:	e9 a1       	lds	r30, 0x49
    6092:	e9 8b       	std	Y+17, r30	; 0x11
    6094:	ea a1       	lds	r30, 0x4a
    6096:	ea 8b       	std	Y+18, r30	; 0x12
    6098:	eb a1       	lds	r30, 0x4b
    609a:	eb 8b       	std	Y+19, r30	; 0x13
    609c:	ec a1       	lds	r30, 0x4c
    609e:	ec 8b       	std	Y+20, r30	; 0x14
    60a0:	ed a1       	lds	r30, 0x4d
    60a2:	ed 8b       	std	Y+21, r30	; 0x15
    60a4:	ee a1       	lds	r30, 0x4e
    60a6:	ee 8b       	std	Y+22, r30	; 0x16
    60a8:	ef a1       	lds	r30, 0x4f
    60aa:	ef 8b       	std	Y+23, r30	; 0x17
    60ac:	e8 a5       	lds	r30, 0x68
    60ae:	e8 8f       	std	Y+24, r30	; 0x18
    60b0:	79 87       	std	Y+9, r23	; 0x09
    60b2:	6a 87       	std	Y+10, r22	; 0x0a
    60b4:	5b 87       	std	Y+11, r21	; 0x0b
    60b6:	4c 87       	std	Y+12, r20	; 0x0c
    60b8:	3d 87       	std	Y+13, r19	; 0x0d
    60ba:	2e 87       	std	Y+14, r18	; 0x0e
    60bc:	9f 87       	std	Y+15, r25	; 0x0f
    60be:	88 8b       	std	Y+16, r24	; 0x10
    60c0:	89 84       	ldd	r8, Y+9	; 0x09
    60c2:	9a 84       	ldd	r9, Y+10	; 0x0a
    60c4:	ab 84       	ldd	r10, Y+11	; 0x0b
    60c6:	bc 84       	ldd	r11, Y+12	; 0x0c
    60c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    60ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    60cc:	af 85       	ldd	r26, Y+15	; 0x0f
    60ce:	b8 89       	ldd	r27, Y+16	; 0x10
    60d0:	e9 88       	ldd	r14, Y+17	; 0x11
    60d2:	fa 88       	ldd	r15, Y+18	; 0x12
    60d4:	0b 89       	ldd	r16, Y+19	; 0x13
    60d6:	1c 89       	ldd	r17, Y+20	; 0x14
    60d8:	ed aa       	sts	0x9d, r30
    60da:	fe aa       	sts	0x9e, r31
    60dc:	0f ab       	sts	0x5f, r16
    60de:	18 af       	sts	0x78, r17
    60e0:	cd 88       	ldd	r12, Y+21	; 0x15
    60e2:	de 88       	ldd	r13, Y+22	; 0x16
    60e4:	ef 88       	ldd	r14, Y+23	; 0x17
    60e6:	f8 8c       	ldd	r15, Y+24	; 0x18
    60e8:	00 97       	sbiw	r24, 0x00	; 0
    60ea:	a1 05       	cpc	r26, r1
    60ec:	b1 05       	cpc	r27, r1
    60ee:	09 f0       	breq	.+2      	; 0x60f2 <__stack+0xf3>
    60f0:	bd c3       	rjmp	.+1914   	; 0x686c <__stack+0x86d>
    60f2:	c8 14       	cp	r12, r8
    60f4:	d9 04       	cpc	r13, r9
    60f6:	ea 04       	cpc	r14, r10
    60f8:	fb 04       	cpc	r15, r11
    60fa:	08 f0       	brcs	.+2      	; 0x60fe <__stack+0xff>
    60fc:	4d c1       	rjmp	.+666    	; 0x6398 <__stack+0x399>
    60fe:	00 e0       	ldi	r16, 0x00	; 0
    6100:	80 16       	cp	r8, r16
    6102:	00 e0       	ldi	r16, 0x00	; 0
    6104:	90 06       	cpc	r9, r16
    6106:	01 e0       	ldi	r16, 0x01	; 1
    6108:	a0 06       	cpc	r10, r16
    610a:	00 e0       	ldi	r16, 0x00	; 0
    610c:	b0 06       	cpc	r11, r16
    610e:	58 f4       	brcc	.+22     	; 0x6126 <__stack+0x127>
    6110:	1f ef       	ldi	r17, 0xFF	; 255
    6112:	81 16       	cp	r8, r17
    6114:	91 04       	cpc	r9, r1
    6116:	a1 04       	cpc	r10, r1
    6118:	b1 04       	cpc	r11, r1
    611a:	09 f0       	breq	.+2      	; 0x611e <__stack+0x11f>
    611c:	90 f4       	brcc	.+36     	; 0x6142 <__stack+0x143>
    611e:	80 e0       	ldi	r24, 0x00	; 0
    6120:	90 e0       	ldi	r25, 0x00	; 0
    6122:	dc 01       	movw	r26, r24
    6124:	17 c0       	rjmp	.+46     	; 0x6154 <__stack+0x155>
    6126:	20 e0       	ldi	r18, 0x00	; 0
    6128:	82 16       	cp	r8, r18
    612a:	20 e0       	ldi	r18, 0x00	; 0
    612c:	92 06       	cpc	r9, r18
    612e:	20 e0       	ldi	r18, 0x00	; 0
    6130:	a2 06       	cpc	r10, r18
    6132:	21 e0       	ldi	r18, 0x01	; 1
    6134:	b2 06       	cpc	r11, r18
    6136:	50 f4       	brcc	.+20     	; 0x614c <__stack+0x14d>
    6138:	80 e1       	ldi	r24, 0x10	; 16
    613a:	90 e0       	ldi	r25, 0x00	; 0
    613c:	a0 e0       	ldi	r26, 0x00	; 0
    613e:	b0 e0       	ldi	r27, 0x00	; 0
    6140:	09 c0       	rjmp	.+18     	; 0x6154 <__stack+0x155>
    6142:	88 e0       	ldi	r24, 0x08	; 8
    6144:	90 e0       	ldi	r25, 0x00	; 0
    6146:	a0 e0       	ldi	r26, 0x00	; 0
    6148:	b0 e0       	ldi	r27, 0x00	; 0
    614a:	04 c0       	rjmp	.+8      	; 0x6154 <__stack+0x155>
    614c:	88 e1       	ldi	r24, 0x18	; 24
    614e:	90 e0       	ldi	r25, 0x00	; 0
    6150:	a0 e0       	ldi	r26, 0x00	; 0
    6152:	b0 e0       	ldi	r27, 0x00	; 0
    6154:	b5 01       	movw	r22, r10
    6156:	a4 01       	movw	r20, r8
    6158:	08 2e       	mov	r0, r24
    615a:	04 c0       	rjmp	.+8      	; 0x6164 <__stack+0x165>
    615c:	76 95       	lsr	r23
    615e:	67 95       	ror	r22
    6160:	57 95       	ror	r21
    6162:	47 95       	ror	r20
    6164:	0a 94       	dec	r0
    6166:	d2 f7       	brpl	.-12     	; 0x615c <__stack+0x15d>
    6168:	fa 01       	movw	r30, r20
    616a:	e3 5f       	subi	r30, 0xF3	; 243
    616c:	ff 4d       	sbci	r31, 0xDF	; 223
    616e:	20 81       	ld	r18, Z
    6170:	40 e2       	ldi	r20, 0x20	; 32
    6172:	50 e0       	ldi	r21, 0x00	; 0
    6174:	60 e0       	ldi	r22, 0x00	; 0
    6176:	70 e0       	ldi	r23, 0x00	; 0
    6178:	48 1b       	sub	r20, r24
    617a:	59 0b       	sbc	r21, r25
    617c:	6a 0b       	sbc	r22, r26
    617e:	7b 0b       	sbc	r23, r27
    6180:	42 1b       	sub	r20, r18
    6182:	51 09       	sbc	r21, r1
    6184:	61 09       	sbc	r22, r1
    6186:	71 09       	sbc	r23, r1
    6188:	41 15       	cp	r20, r1
    618a:	51 05       	cpc	r21, r1
    618c:	61 05       	cpc	r22, r1
    618e:	71 05       	cpc	r23, r1
    6190:	a1 f1       	breq	.+104    	; 0x61fa <__stack+0x1fb>
    6192:	04 2e       	mov	r0, r20
    6194:	04 c0       	rjmp	.+8      	; 0x619e <__stack+0x19f>
    6196:	88 0c       	add	r8, r8
    6198:	99 1c       	adc	r9, r9
    619a:	aa 1c       	adc	r10, r10
    619c:	bb 1c       	adc	r11, r11
    619e:	0a 94       	dec	r0
    61a0:	d2 f7       	brpl	.-12     	; 0x6196 <__stack+0x197>
    61a2:	97 01       	movw	r18, r14
    61a4:	86 01       	movw	r16, r12
    61a6:	04 2e       	mov	r0, r20
    61a8:	04 c0       	rjmp	.+8      	; 0x61b2 <__stack+0x1b3>
    61aa:	00 0f       	add	r16, r16
    61ac:	11 1f       	adc	r17, r17
    61ae:	22 1f       	adc	r18, r18
    61b0:	33 1f       	adc	r19, r19
    61b2:	0a 94       	dec	r0
    61b4:	d2 f7       	brpl	.-12     	; 0x61aa <__stack+0x1ab>
    61b6:	80 e2       	ldi	r24, 0x20	; 32
    61b8:	90 e0       	ldi	r25, 0x00	; 0
    61ba:	84 1b       	sub	r24, r20
    61bc:	95 0b       	sbc	r25, r21
    61be:	cd a8       	sts	0x8d, r28
    61c0:	de a8       	sts	0x8e, r29
    61c2:	ef a8       	sts	0x8f, r30
    61c4:	f8 ac       	sts	0xa8, r31
    61c6:	04 c0       	rjmp	.+8      	; 0x61d0 <__stack+0x1d1>
    61c8:	f6 94       	lsr	r15
    61ca:	e7 94       	ror	r14
    61cc:	d7 94       	ror	r13
    61ce:	c7 94       	ror	r12
    61d0:	8a 95       	dec	r24
    61d2:	d2 f7       	brpl	.-12     	; 0x61c8 <__stack+0x1c9>
    61d4:	c0 2a       	or	r12, r16
    61d6:	d1 2a       	or	r13, r17
    61d8:	e2 2a       	or	r14, r18
    61da:	f3 2a       	or	r15, r19
    61dc:	0d a9       	sts	0x4d, r16
    61de:	1e a9       	sts	0x4e, r17
    61e0:	2f a9       	sts	0x4f, r18
    61e2:	38 ad       	sts	0x68, r19
    61e4:	04 c0       	rjmp	.+8      	; 0x61ee <__stack+0x1ef>
    61e6:	00 0f       	add	r16, r16
    61e8:	11 1f       	adc	r17, r17
    61ea:	22 1f       	adc	r18, r18
    61ec:	33 1f       	adc	r19, r19
    61ee:	4a 95       	dec	r20
    61f0:	d2 f7       	brpl	.-12     	; 0x61e6 <__stack+0x1e7>
    61f2:	0d ab       	sts	0x5d, r16
    61f4:	1e ab       	sts	0x5e, r17
    61f6:	2f ab       	sts	0x5f, r18
    61f8:	38 af       	sts	0x78, r19
    61fa:	25 01       	movw	r4, r10
    61fc:	66 24       	eor	r6, r6
    61fe:	77 24       	eor	r7, r7
    6200:	95 01       	movw	r18, r10
    6202:	84 01       	movw	r16, r8
    6204:	20 70       	andi	r18, 0x00	; 0
    6206:	30 70       	andi	r19, 0x00	; 0
    6208:	09 ab       	sts	0x59, r16
    620a:	1a ab       	sts	0x5a, r17
    620c:	2b ab       	sts	0x5b, r18
    620e:	3c ab       	sts	0x5c, r19
    6210:	c7 01       	movw	r24, r14
    6212:	b6 01       	movw	r22, r12
    6214:	a3 01       	movw	r20, r6
    6216:	92 01       	movw	r18, r4
    6218:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    621c:	2d a7       	lds	r18, 0x7d
    621e:	3e a7       	lds	r19, 0x7e
    6220:	4f a7       	lds	r20, 0x7f
    6222:	58 ab       	sts	0x58, r21
    6224:	69 a7       	lds	r22, 0x79
    6226:	7a a7       	lds	r23, 0x7a
    6228:	8b a7       	lds	r24, 0x7b
    622a:	9c a7       	lds	r25, 0x7c
    622c:	c7 01       	movw	r24, r14
    622e:	b6 01       	movw	r22, r12
    6230:	a3 01       	movw	r20, r6
    6232:	92 01       	movw	r18, r4
    6234:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6238:	ca 01       	movw	r24, r20
    623a:	b9 01       	movw	r22, r18
    623c:	29 a9       	sts	0x49, r18
    623e:	3a a9       	sts	0x4a, r19
    6240:	4b a9       	sts	0x4b, r20
    6242:	5c a9       	sts	0x4c, r21
    6244:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6248:	ab 01       	movw	r20, r22
    624a:	bc 01       	movw	r22, r24
    624c:	09 a5       	lds	r16, 0x69
    624e:	1a a5       	lds	r17, 0x6a
    6250:	2b a5       	lds	r18, 0x6b
    6252:	3c a5       	lds	r19, 0x6c
    6254:	78 01       	movw	r14, r16
    6256:	dd 24       	eor	r13, r13
    6258:	cc 24       	eor	r12, r12
    625a:	0d a9       	sts	0x4d, r16
    625c:	1e a9       	sts	0x4e, r17
    625e:	2f a9       	sts	0x4f, r18
    6260:	38 ad       	sts	0x68, r19
    6262:	c9 01       	movw	r24, r18
    6264:	aa 27       	eor	r26, r26
    6266:	bb 27       	eor	r27, r27
    6268:	c8 2a       	or	r12, r24
    626a:	d9 2a       	or	r13, r25
    626c:	ea 2a       	or	r14, r26
    626e:	fb 2a       	or	r15, r27
    6270:	0d a5       	lds	r16, 0x6d
    6272:	1e a5       	lds	r17, 0x6e
    6274:	2f a5       	lds	r18, 0x6f
    6276:	38 a9       	sts	0x48, r19
    6278:	c4 16       	cp	r12, r20
    627a:	d5 06       	cpc	r13, r21
    627c:	e6 06       	cpc	r14, r22
    627e:	f7 06       	cpc	r15, r23
    6280:	38 f5       	brcc	.+78     	; 0x62d0 <__stack+0x2d1>
    6282:	01 50       	subi	r16, 0x01	; 1
    6284:	10 40       	sbci	r17, 0x00	; 0
    6286:	20 40       	sbci	r18, 0x00	; 0
    6288:	30 40       	sbci	r19, 0x00	; 0
    628a:	09 a7       	lds	r16, 0x79
    628c:	1a a7       	lds	r17, 0x7a
    628e:	2b a7       	lds	r18, 0x7b
    6290:	3c a7       	lds	r19, 0x7c
    6292:	c8 0c       	add	r12, r8
    6294:	d9 1c       	adc	r13, r9
    6296:	ea 1c       	adc	r14, r10
    6298:	fb 1c       	adc	r15, r11
    629a:	c8 14       	cp	r12, r8
    629c:	d9 04       	cpc	r13, r9
    629e:	ea 04       	cpc	r14, r10
    62a0:	fb 04       	cpc	r15, r11
    62a2:	d0 f0       	brcs	.+52     	; 0x62d8 <__stack+0x2d9>
    62a4:	c4 16       	cp	r12, r20
    62a6:	d5 06       	cpc	r13, r21
    62a8:	e6 06       	cpc	r14, r22
    62aa:	f7 06       	cpc	r15, r23
    62ac:	a8 f4       	brcc	.+42     	; 0x62d8 <__stack+0x2d9>
    62ae:	0d a5       	lds	r16, 0x6d
    62b0:	1e a5       	lds	r17, 0x6e
    62b2:	2f a5       	lds	r18, 0x6f
    62b4:	38 a9       	sts	0x48, r19
    62b6:	02 50       	subi	r16, 0x02	; 2
    62b8:	10 40       	sbci	r17, 0x00	; 0
    62ba:	20 40       	sbci	r18, 0x00	; 0
    62bc:	30 40       	sbci	r19, 0x00	; 0
    62be:	09 a7       	lds	r16, 0x79
    62c0:	1a a7       	lds	r17, 0x7a
    62c2:	2b a7       	lds	r18, 0x7b
    62c4:	3c a7       	lds	r19, 0x7c
    62c6:	c8 0c       	add	r12, r8
    62c8:	d9 1c       	adc	r13, r9
    62ca:	ea 1c       	adc	r14, r10
    62cc:	fb 1c       	adc	r15, r11
    62ce:	04 c0       	rjmp	.+8      	; 0x62d8 <__stack+0x2d9>
    62d0:	09 a7       	lds	r16, 0x79
    62d2:	1a a7       	lds	r17, 0x7a
    62d4:	2b a7       	lds	r18, 0x7b
    62d6:	3c a7       	lds	r19, 0x7c
    62d8:	c4 1a       	sub	r12, r20
    62da:	d5 0a       	sbc	r13, r21
    62dc:	e6 0a       	sbc	r14, r22
    62de:	f7 0a       	sbc	r15, r23
    62e0:	c7 01       	movw	r24, r14
    62e2:	b6 01       	movw	r22, r12
    62e4:	a3 01       	movw	r20, r6
    62e6:	92 01       	movw	r18, r4
    62e8:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    62ec:	2d a7       	lds	r18, 0x7d
    62ee:	3e a7       	lds	r19, 0x7e
    62f0:	4f a7       	lds	r20, 0x7f
    62f2:	58 ab       	sts	0x58, r21
    62f4:	69 af       	sts	0x79, r22
    62f6:	7a af       	sts	0x7a, r23
    62f8:	8b af       	sts	0x7b, r24
    62fa:	9c af       	sts	0x7c, r25
    62fc:	c7 01       	movw	r24, r14
    62fe:	b6 01       	movw	r22, r12
    6300:	a3 01       	movw	r20, r6
    6302:	92 01       	movw	r18, r4
    6304:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6308:	ca 01       	movw	r24, r20
    630a:	b9 01       	movw	r22, r18
    630c:	29 a9       	sts	0x49, r18
    630e:	3a a9       	sts	0x4a, r19
    6310:	4b a9       	sts	0x4b, r20
    6312:	5c a9       	sts	0x4c, r21
    6314:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6318:	6b 01       	movw	r12, r22
    631a:	7c 01       	movw	r14, r24
    631c:	49 ad       	sts	0x69, r20
    631e:	5a ad       	sts	0x6a, r21
    6320:	6b ad       	sts	0x6b, r22
    6322:	7c ad       	sts	0x6c, r23
    6324:	9a 01       	movw	r18, r20
    6326:	11 27       	eor	r17, r17
    6328:	00 27       	eor	r16, r16
    632a:	4d a9       	sts	0x4d, r20
    632c:	5e a9       	sts	0x4e, r21
    632e:	6f a9       	sts	0x4f, r22
    6330:	78 ad       	sts	0x68, r23
    6332:	60 70       	andi	r22, 0x00	; 0
    6334:	70 70       	andi	r23, 0x00	; 0
    6336:	04 2b       	or	r16, r20
    6338:	15 2b       	or	r17, r21
    633a:	26 2b       	or	r18, r22
    633c:	37 2b       	or	r19, r23
    633e:	8d a5       	lds	r24, 0x6d
    6340:	9e a5       	lds	r25, 0x6e
    6342:	af a5       	lds	r26, 0x6f
    6344:	b8 a9       	sts	0x48, r27
    6346:	0c 15       	cp	r16, r12
    6348:	1d 05       	cpc	r17, r13
    634a:	2e 05       	cpc	r18, r14
    634c:	3f 05       	cpc	r19, r15
    634e:	c0 f4       	brcc	.+48     	; 0x6380 <__stack+0x381>
    6350:	01 97       	sbiw	r24, 0x01	; 1
    6352:	a1 09       	sbc	r26, r1
    6354:	b1 09       	sbc	r27, r1
    6356:	08 0d       	add	r16, r8
    6358:	19 1d       	adc	r17, r9
    635a:	2a 1d       	adc	r18, r10
    635c:	3b 1d       	adc	r19, r11
    635e:	08 15       	cp	r16, r8
    6360:	19 05       	cpc	r17, r9
    6362:	2a 05       	cpc	r18, r10
    6364:	3b 05       	cpc	r19, r11
    6366:	60 f0       	brcs	.+24     	; 0x6380 <__stack+0x381>
    6368:	0c 15       	cp	r16, r12
    636a:	1d 05       	cpc	r17, r13
    636c:	2e 05       	cpc	r18, r14
    636e:	3f 05       	cpc	r19, r15
    6370:	38 f4       	brcc	.+14     	; 0x6380 <__stack+0x381>
    6372:	8d a5       	lds	r24, 0x6d
    6374:	9e a5       	lds	r25, 0x6e
    6376:	af a5       	lds	r26, 0x6f
    6378:	b8 a9       	sts	0x48, r27
    637a:	02 97       	sbiw	r24, 0x02	; 2
    637c:	a1 09       	sbc	r26, r1
    637e:	b1 09       	sbc	r27, r1
    6380:	09 a5       	lds	r16, 0x69
    6382:	1a a5       	lds	r17, 0x6a
    6384:	2b a5       	lds	r18, 0x6b
    6386:	3c a5       	lds	r19, 0x6c
    6388:	78 01       	movw	r14, r16
    638a:	dd 24       	eor	r13, r13
    638c:	cc 24       	eor	r12, r12
    638e:	c8 2a       	or	r12, r24
    6390:	d9 2a       	or	r13, r25
    6392:	ea 2a       	or	r14, r26
    6394:	fb 2a       	or	r15, r27
    6396:	b7 c4       	rjmp	.+2414   	; 0x6d06 <__stack+0xd07>
    6398:	81 14       	cp	r8, r1
    639a:	91 04       	cpc	r9, r1
    639c:	a1 04       	cpc	r10, r1
    639e:	b1 04       	cpc	r11, r1
    63a0:	51 f4       	brne	.+20     	; 0x63b6 <__stack+0x3b7>
    63a2:	61 e0       	ldi	r22, 0x01	; 1
    63a4:	70 e0       	ldi	r23, 0x00	; 0
    63a6:	80 e0       	ldi	r24, 0x00	; 0
    63a8:	90 e0       	ldi	r25, 0x00	; 0
    63aa:	a5 01       	movw	r20, r10
    63ac:	94 01       	movw	r18, r8
    63ae:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    63b2:	49 01       	movw	r8, r18
    63b4:	5a 01       	movw	r10, r20
    63b6:	10 e0       	ldi	r17, 0x00	; 0
    63b8:	81 16       	cp	r8, r17
    63ba:	10 e0       	ldi	r17, 0x00	; 0
    63bc:	91 06       	cpc	r9, r17
    63be:	11 e0       	ldi	r17, 0x01	; 1
    63c0:	a1 06       	cpc	r10, r17
    63c2:	10 e0       	ldi	r17, 0x00	; 0
    63c4:	b1 06       	cpc	r11, r17
    63c6:	58 f4       	brcc	.+22     	; 0x63de <__stack+0x3df>
    63c8:	2f ef       	ldi	r18, 0xFF	; 255
    63ca:	82 16       	cp	r8, r18
    63cc:	91 04       	cpc	r9, r1
    63ce:	a1 04       	cpc	r10, r1
    63d0:	b1 04       	cpc	r11, r1
    63d2:	09 f0       	breq	.+2      	; 0x63d6 <__stack+0x3d7>
    63d4:	90 f4       	brcc	.+36     	; 0x63fa <__stack+0x3fb>
    63d6:	80 e0       	ldi	r24, 0x00	; 0
    63d8:	90 e0       	ldi	r25, 0x00	; 0
    63da:	dc 01       	movw	r26, r24
    63dc:	17 c0       	rjmp	.+46     	; 0x640c <__stack+0x40d>
    63de:	30 e0       	ldi	r19, 0x00	; 0
    63e0:	83 16       	cp	r8, r19
    63e2:	30 e0       	ldi	r19, 0x00	; 0
    63e4:	93 06       	cpc	r9, r19
    63e6:	30 e0       	ldi	r19, 0x00	; 0
    63e8:	a3 06       	cpc	r10, r19
    63ea:	31 e0       	ldi	r19, 0x01	; 1
    63ec:	b3 06       	cpc	r11, r19
    63ee:	50 f4       	brcc	.+20     	; 0x6404 <__stack+0x405>
    63f0:	80 e1       	ldi	r24, 0x10	; 16
    63f2:	90 e0       	ldi	r25, 0x00	; 0
    63f4:	a0 e0       	ldi	r26, 0x00	; 0
    63f6:	b0 e0       	ldi	r27, 0x00	; 0
    63f8:	09 c0       	rjmp	.+18     	; 0x640c <__stack+0x40d>
    63fa:	88 e0       	ldi	r24, 0x08	; 8
    63fc:	90 e0       	ldi	r25, 0x00	; 0
    63fe:	a0 e0       	ldi	r26, 0x00	; 0
    6400:	b0 e0       	ldi	r27, 0x00	; 0
    6402:	04 c0       	rjmp	.+8      	; 0x640c <__stack+0x40d>
    6404:	88 e1       	ldi	r24, 0x18	; 24
    6406:	90 e0       	ldi	r25, 0x00	; 0
    6408:	a0 e0       	ldi	r26, 0x00	; 0
    640a:	b0 e0       	ldi	r27, 0x00	; 0
    640c:	b5 01       	movw	r22, r10
    640e:	a4 01       	movw	r20, r8
    6410:	08 2e       	mov	r0, r24
    6412:	04 c0       	rjmp	.+8      	; 0x641c <__stack+0x41d>
    6414:	76 95       	lsr	r23
    6416:	67 95       	ror	r22
    6418:	57 95       	ror	r21
    641a:	47 95       	ror	r20
    641c:	0a 94       	dec	r0
    641e:	d2 f7       	brpl	.-12     	; 0x6414 <__stack+0x415>
    6420:	fa 01       	movw	r30, r20
    6422:	e3 5f       	subi	r30, 0xF3	; 243
    6424:	ff 4d       	sbci	r31, 0xDF	; 223
    6426:	20 81       	ld	r18, Z
    6428:	ac 01       	movw	r20, r24
    642a:	bd 01       	movw	r22, r26
    642c:	42 0f       	add	r20, r18
    642e:	51 1d       	adc	r21, r1
    6430:	61 1d       	adc	r22, r1
    6432:	71 1d       	adc	r23, r1
    6434:	80 e2       	ldi	r24, 0x20	; 32
    6436:	90 e0       	ldi	r25, 0x00	; 0
    6438:	a0 e0       	ldi	r26, 0x00	; 0
    643a:	b0 e0       	ldi	r27, 0x00	; 0
    643c:	84 1b       	sub	r24, r20
    643e:	95 0b       	sbc	r25, r21
    6440:	a6 0b       	sbc	r26, r22
    6442:	b7 0b       	sbc	r27, r23
    6444:	51 f4       	brne	.+20     	; 0x645a <__stack+0x45b>
    6446:	c8 18       	sub	r12, r8
    6448:	d9 08       	sbc	r13, r9
    644a:	ea 08       	sbc	r14, r10
    644c:	fb 08       	sbc	r15, r11
    644e:	f1 e0       	ldi	r31, 0x01	; 1
    6450:	4f 2e       	mov	r4, r31
    6452:	51 2c       	mov	r5, r1
    6454:	61 2c       	mov	r6, r1
    6456:	71 2c       	mov	r7, r1
    6458:	28 c1       	rjmp	.+592    	; 0x66aa <__stack+0x6ab>
    645a:	08 2e       	mov	r0, r24
    645c:	04 c0       	rjmp	.+8      	; 0x6466 <__stack+0x467>
    645e:	88 0c       	add	r8, r8
    6460:	99 1c       	adc	r9, r9
    6462:	aa 1c       	adc	r10, r10
    6464:	bb 1c       	adc	r11, r11
    6466:	0a 94       	dec	r0
    6468:	d2 f7       	brpl	.-12     	; 0x645e <__stack+0x45f>
    646a:	97 01       	movw	r18, r14
    646c:	86 01       	movw	r16, r12
    646e:	04 2e       	mov	r0, r20
    6470:	04 c0       	rjmp	.+8      	; 0x647a <__stack+0x47b>
    6472:	36 95       	lsr	r19
    6474:	27 95       	ror	r18
    6476:	17 95       	ror	r17
    6478:	07 95       	ror	r16
    647a:	0a 94       	dec	r0
    647c:	d2 f7       	brpl	.-12     	; 0x6472 <__stack+0x473>
    647e:	09 ab       	sts	0x59, r16
    6480:	1a ab       	sts	0x5a, r17
    6482:	2b ab       	sts	0x5b, r18
    6484:	3c ab       	sts	0x5c, r19
    6486:	97 01       	movw	r18, r14
    6488:	86 01       	movw	r16, r12
    648a:	08 2e       	mov	r0, r24
    648c:	04 c0       	rjmp	.+8      	; 0x6496 <__stack+0x497>
    648e:	00 0f       	add	r16, r16
    6490:	11 1f       	adc	r17, r17
    6492:	22 1f       	adc	r18, r18
    6494:	33 1f       	adc	r19, r19
    6496:	0a 94       	dec	r0
    6498:	d2 f7       	brpl	.-12     	; 0x648e <__stack+0x48f>
    649a:	0d a7       	lds	r16, 0x7d
    649c:	1e a7       	lds	r17, 0x7e
    649e:	2f a7       	lds	r18, 0x7f
    64a0:	38 ab       	sts	0x58, r19
    64a2:	ed a8       	sts	0x8d, r30
    64a4:	fe a8       	sts	0x8e, r31
    64a6:	0f a9       	sts	0x4f, r16
    64a8:	18 ad       	sts	0x68, r17
    64aa:	04 c0       	rjmp	.+8      	; 0x64b4 <__stack+0x4b5>
    64ac:	16 95       	lsr	r17
    64ae:	07 95       	ror	r16
    64b0:	f7 94       	ror	r15
    64b2:	e7 94       	ror	r14
    64b4:	4a 95       	dec	r20
    64b6:	d2 f7       	brpl	.-12     	; 0x64ac <__stack+0x4ad>
    64b8:	b8 01       	movw	r22, r16
    64ba:	a7 01       	movw	r20, r14
    64bc:	0d a5       	lds	r16, 0x6d
    64be:	1e a5       	lds	r17, 0x6e
    64c0:	2f a5       	lds	r18, 0x6f
    64c2:	38 a9       	sts	0x48, r19
    64c4:	04 2b       	or	r16, r20
    64c6:	15 2b       	or	r17, r21
    64c8:	26 2b       	or	r18, r22
    64ca:	37 2b       	or	r19, r23
    64cc:	0d a7       	lds	r16, 0x7d
    64ce:	1e a7       	lds	r17, 0x7e
    64d0:	2f a7       	lds	r18, 0x7f
    64d2:	38 ab       	sts	0x58, r19
    64d4:	ed a8       	sts	0x8d, r30
    64d6:	fe a8       	sts	0x8e, r31
    64d8:	0f a9       	sts	0x4f, r16
    64da:	18 ad       	sts	0x68, r17
    64dc:	04 c0       	rjmp	.+8      	; 0x64e6 <__stack+0x4e7>
    64de:	ee 0c       	add	r14, r14
    64e0:	ff 1c       	adc	r15, r15
    64e2:	00 1f       	adc	r16, r16
    64e4:	11 1f       	adc	r17, r17
    64e6:	8a 95       	dec	r24
    64e8:	d2 f7       	brpl	.-12     	; 0x64de <__stack+0x4df>
    64ea:	ed aa       	sts	0x9d, r30
    64ec:	fe aa       	sts	0x9e, r31
    64ee:	0f ab       	sts	0x5f, r16
    64f0:	18 af       	sts	0x78, r17
    64f2:	25 01       	movw	r4, r10
    64f4:	66 24       	eor	r6, r6
    64f6:	77 24       	eor	r7, r7
    64f8:	95 01       	movw	r18, r10
    64fa:	84 01       	movw	r16, r8
    64fc:	20 70       	andi	r18, 0x00	; 0
    64fe:	30 70       	andi	r19, 0x00	; 0
    6500:	09 af       	sts	0x79, r16
    6502:	1a af       	sts	0x7a, r17
    6504:	2b af       	sts	0x7b, r18
    6506:	3c af       	sts	0x7c, r19
    6508:	69 a9       	sts	0x49, r22
    650a:	7a a9       	sts	0x4a, r23
    650c:	8b a9       	sts	0x4b, r24
    650e:	9c a9       	sts	0x4c, r25
    6510:	a3 01       	movw	r20, r6
    6512:	92 01       	movw	r18, r4
    6514:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6518:	29 a7       	lds	r18, 0x79
    651a:	3a a7       	lds	r19, 0x7a
    651c:	4b a7       	lds	r20, 0x7b
    651e:	5c a7       	lds	r21, 0x7c
    6520:	6b 01       	movw	r12, r22
    6522:	7c 01       	movw	r14, r24
    6524:	69 a9       	sts	0x49, r22
    6526:	7a a9       	sts	0x4a, r23
    6528:	8b a9       	sts	0x4b, r24
    652a:	9c a9       	sts	0x4c, r25
    652c:	a3 01       	movw	r20, r6
    652e:	92 01       	movw	r18, r4
    6530:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6534:	ca 01       	movw	r24, r20
    6536:	b9 01       	movw	r22, r18
    6538:	29 ad       	sts	0x69, r18
    653a:	3a ad       	sts	0x6a, r19
    653c:	4b ad       	sts	0x6b, r20
    653e:	5c ad       	sts	0x6c, r21
    6540:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6544:	ab 01       	movw	r20, r22
    6546:	bc 01       	movw	r22, r24
    6548:	76 01       	movw	r14, r12
    654a:	dd 24       	eor	r13, r13
    654c:	cc 24       	eor	r12, r12
    654e:	0d a5       	lds	r16, 0x6d
    6550:	1e a5       	lds	r17, 0x6e
    6552:	2f a5       	lds	r18, 0x6f
    6554:	38 a9       	sts	0x48, r19
    6556:	c9 01       	movw	r24, r18
    6558:	aa 27       	eor	r26, r26
    655a:	bb 27       	eor	r27, r27
    655c:	c8 2a       	or	r12, r24
    655e:	d9 2a       	or	r13, r25
    6560:	ea 2a       	or	r14, r26
    6562:	fb 2a       	or	r15, r27
    6564:	09 a5       	lds	r16, 0x69
    6566:	1a a5       	lds	r17, 0x6a
    6568:	2b a5       	lds	r18, 0x6b
    656a:	3c a5       	lds	r19, 0x6c
    656c:	c4 16       	cp	r12, r20
    656e:	d5 06       	cpc	r13, r21
    6570:	e6 06       	cpc	r14, r22
    6572:	f7 06       	cpc	r15, r23
    6574:	38 f5       	brcc	.+78     	; 0x65c4 <__stack+0x5c5>
    6576:	01 50       	subi	r16, 0x01	; 1
    6578:	10 40       	sbci	r17, 0x00	; 0
    657a:	20 40       	sbci	r18, 0x00	; 0
    657c:	30 40       	sbci	r19, 0x00	; 0
    657e:	09 ab       	sts	0x59, r16
    6580:	1a ab       	sts	0x5a, r17
    6582:	2b ab       	sts	0x5b, r18
    6584:	3c ab       	sts	0x5c, r19
    6586:	c8 0c       	add	r12, r8
    6588:	d9 1c       	adc	r13, r9
    658a:	ea 1c       	adc	r14, r10
    658c:	fb 1c       	adc	r15, r11
    658e:	c8 14       	cp	r12, r8
    6590:	d9 04       	cpc	r13, r9
    6592:	ea 04       	cpc	r14, r10
    6594:	fb 04       	cpc	r15, r11
    6596:	d0 f0       	brcs	.+52     	; 0x65cc <__stack+0x5cd>
    6598:	c4 16       	cp	r12, r20
    659a:	d5 06       	cpc	r13, r21
    659c:	e6 06       	cpc	r14, r22
    659e:	f7 06       	cpc	r15, r23
    65a0:	a8 f4       	brcc	.+42     	; 0x65cc <__stack+0x5cd>
    65a2:	09 a5       	lds	r16, 0x69
    65a4:	1a a5       	lds	r17, 0x6a
    65a6:	2b a5       	lds	r18, 0x6b
    65a8:	3c a5       	lds	r19, 0x6c
    65aa:	02 50       	subi	r16, 0x02	; 2
    65ac:	10 40       	sbci	r17, 0x00	; 0
    65ae:	20 40       	sbci	r18, 0x00	; 0
    65b0:	30 40       	sbci	r19, 0x00	; 0
    65b2:	09 ab       	sts	0x59, r16
    65b4:	1a ab       	sts	0x5a, r17
    65b6:	2b ab       	sts	0x5b, r18
    65b8:	3c ab       	sts	0x5c, r19
    65ba:	c8 0c       	add	r12, r8
    65bc:	d9 1c       	adc	r13, r9
    65be:	ea 1c       	adc	r14, r10
    65c0:	fb 1c       	adc	r15, r11
    65c2:	04 c0       	rjmp	.+8      	; 0x65cc <__stack+0x5cd>
    65c4:	09 ab       	sts	0x59, r16
    65c6:	1a ab       	sts	0x5a, r17
    65c8:	2b ab       	sts	0x5b, r18
    65ca:	3c ab       	sts	0x5c, r19
    65cc:	c4 1a       	sub	r12, r20
    65ce:	d5 0a       	sbc	r13, r21
    65d0:	e6 0a       	sbc	r14, r22
    65d2:	f7 0a       	sbc	r15, r23
    65d4:	c7 01       	movw	r24, r14
    65d6:	b6 01       	movw	r22, r12
    65d8:	a3 01       	movw	r20, r6
    65da:	92 01       	movw	r18, r4
    65dc:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    65e0:	29 a7       	lds	r18, 0x79
    65e2:	3a a7       	lds	r19, 0x7a
    65e4:	4b a7       	lds	r20, 0x7b
    65e6:	5c a7       	lds	r21, 0x7c
    65e8:	21 96       	adiw	r28, 0x01	; 1
    65ea:	6c af       	sts	0x7c, r22
    65ec:	7d af       	sts	0x7d, r23
    65ee:	8e af       	sts	0x7e, r24
    65f0:	9f af       	sts	0x7f, r25
    65f2:	21 97       	sbiw	r28, 0x01	; 1
    65f4:	c7 01       	movw	r24, r14
    65f6:	b6 01       	movw	r22, r12
    65f8:	a3 01       	movw	r20, r6
    65fa:	92 01       	movw	r18, r4
    65fc:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6600:	ca 01       	movw	r24, r20
    6602:	b9 01       	movw	r22, r18
    6604:	29 ad       	sts	0x69, r18
    6606:	3a ad       	sts	0x6a, r19
    6608:	4b ad       	sts	0x6b, r20
    660a:	5c ad       	sts	0x6c, r21
    660c:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6610:	8b 01       	movw	r16, r22
    6612:	9c 01       	movw	r18, r24
    6614:	21 96       	adiw	r28, 0x01	; 1
    6616:	4c ad       	sts	0x6c, r20
    6618:	5d ad       	sts	0x6d, r21
    661a:	6e ad       	sts	0x6e, r22
    661c:	7f ad       	sts	0x6f, r23
    661e:	21 97       	sbiw	r28, 0x01	; 1
    6620:	da 01       	movw	r26, r20
    6622:	99 27       	eor	r25, r25
    6624:	88 27       	eor	r24, r24
    6626:	4d a5       	lds	r20, 0x6d
    6628:	5e a5       	lds	r21, 0x6e
    662a:	6f a5       	lds	r22, 0x6f
    662c:	78 a9       	sts	0x48, r23
    662e:	60 70       	andi	r22, 0x00	; 0
    6630:	70 70       	andi	r23, 0x00	; 0
    6632:	84 2b       	or	r24, r20
    6634:	95 2b       	or	r25, r21
    6636:	a6 2b       	or	r26, r22
    6638:	b7 2b       	or	r27, r23
    663a:	49 a5       	lds	r20, 0x69
    663c:	5a a5       	lds	r21, 0x6a
    663e:	6b a5       	lds	r22, 0x6b
    6640:	7c a5       	lds	r23, 0x6c
    6642:	80 17       	cp	r24, r16
    6644:	91 07       	cpc	r25, r17
    6646:	a2 07       	cpc	r26, r18
    6648:	b3 07       	cpc	r27, r19
    664a:	f0 f4       	brcc	.+60     	; 0x6688 <__stack+0x689>
    664c:	41 50       	subi	r20, 0x01	; 1
    664e:	50 40       	sbci	r21, 0x00	; 0
    6650:	60 40       	sbci	r22, 0x00	; 0
    6652:	70 40       	sbci	r23, 0x00	; 0
    6654:	88 0d       	add	r24, r8
    6656:	99 1d       	adc	r25, r9
    6658:	aa 1d       	adc	r26, r10
    665a:	bb 1d       	adc	r27, r11
    665c:	88 15       	cp	r24, r8
    665e:	99 05       	cpc	r25, r9
    6660:	aa 05       	cpc	r26, r10
    6662:	bb 05       	cpc	r27, r11
    6664:	88 f0       	brcs	.+34     	; 0x6688 <__stack+0x689>
    6666:	80 17       	cp	r24, r16
    6668:	91 07       	cpc	r25, r17
    666a:	a2 07       	cpc	r26, r18
    666c:	b3 07       	cpc	r27, r19
    666e:	60 f4       	brcc	.+24     	; 0x6688 <__stack+0x689>
    6670:	49 a5       	lds	r20, 0x69
    6672:	5a a5       	lds	r21, 0x6a
    6674:	6b a5       	lds	r22, 0x6b
    6676:	7c a5       	lds	r23, 0x6c
    6678:	42 50       	subi	r20, 0x02	; 2
    667a:	50 40       	sbci	r21, 0x00	; 0
    667c:	60 40       	sbci	r22, 0x00	; 0
    667e:	70 40       	sbci	r23, 0x00	; 0
    6680:	88 0d       	add	r24, r8
    6682:	99 1d       	adc	r25, r9
    6684:	aa 1d       	adc	r26, r10
    6686:	bb 1d       	adc	r27, r11
    6688:	6c 01       	movw	r12, r24
    668a:	7d 01       	movw	r14, r26
    668c:	c0 1a       	sub	r12, r16
    668e:	d1 0a       	sbc	r13, r17
    6690:	e2 0a       	sbc	r14, r18
    6692:	f3 0a       	sbc	r15, r19
    6694:	09 a9       	sts	0x49, r16
    6696:	1a a9       	sts	0x4a, r17
    6698:	2b a9       	sts	0x4b, r18
    669a:	3c a9       	sts	0x4c, r19
    669c:	38 01       	movw	r6, r16
    669e:	55 24       	eor	r5, r5
    66a0:	44 24       	eor	r4, r4
    66a2:	44 2a       	or	r4, r20
    66a4:	55 2a       	or	r5, r21
    66a6:	66 2a       	or	r6, r22
    66a8:	77 2a       	or	r7, r23
    66aa:	85 01       	movw	r16, r10
    66ac:	22 27       	eor	r18, r18
    66ae:	33 27       	eor	r19, r19
    66b0:	0d a7       	lds	r16, 0x7d
    66b2:	1e a7       	lds	r17, 0x7e
    66b4:	2f a7       	lds	r18, 0x7f
    66b6:	38 ab       	sts	0x58, r19
    66b8:	95 01       	movw	r18, r10
    66ba:	84 01       	movw	r16, r8
    66bc:	20 70       	andi	r18, 0x00	; 0
    66be:	30 70       	andi	r19, 0x00	; 0
    66c0:	09 af       	sts	0x79, r16
    66c2:	1a af       	sts	0x7a, r17
    66c4:	2b af       	sts	0x7b, r18
    66c6:	3c af       	sts	0x7c, r19
    66c8:	c7 01       	movw	r24, r14
    66ca:	b6 01       	movw	r22, r12
    66cc:	2d a5       	lds	r18, 0x6d
    66ce:	3e a5       	lds	r19, 0x6e
    66d0:	4f a5       	lds	r20, 0x6f
    66d2:	58 a9       	sts	0x48, r21
    66d4:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    66d8:	29 a7       	lds	r18, 0x79
    66da:	3a a7       	lds	r19, 0x7a
    66dc:	4b a7       	lds	r20, 0x7b
    66de:	5c a7       	lds	r21, 0x7c
    66e0:	69 ab       	sts	0x59, r22
    66e2:	7a ab       	sts	0x5a, r23
    66e4:	8b ab       	sts	0x5b, r24
    66e6:	9c ab       	sts	0x5c, r25
    66e8:	c7 01       	movw	r24, r14
    66ea:	b6 01       	movw	r22, r12
    66ec:	2d a5       	lds	r18, 0x6d
    66ee:	3e a5       	lds	r19, 0x6e
    66f0:	4f a5       	lds	r20, 0x6f
    66f2:	58 a9       	sts	0x48, r21
    66f4:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    66f8:	ca 01       	movw	r24, r20
    66fa:	b9 01       	movw	r22, r18
    66fc:	29 ad       	sts	0x69, r18
    66fe:	3a ad       	sts	0x6a, r19
    6700:	4b ad       	sts	0x6b, r20
    6702:	5c ad       	sts	0x6c, r21
    6704:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6708:	ab 01       	movw	r20, r22
    670a:	bc 01       	movw	r22, r24
    670c:	09 a9       	sts	0x49, r16
    670e:	1a a9       	sts	0x4a, r17
    6710:	2b a9       	sts	0x4b, r18
    6712:	3c a9       	sts	0x4c, r19
    6714:	78 01       	movw	r14, r16
    6716:	dd 24       	eor	r13, r13
    6718:	cc 24       	eor	r12, r12
    671a:	0d a9       	sts	0x4d, r16
    671c:	1e a9       	sts	0x4e, r17
    671e:	2f a9       	sts	0x4f, r18
    6720:	38 ad       	sts	0x68, r19
    6722:	c9 01       	movw	r24, r18
    6724:	aa 27       	eor	r26, r26
    6726:	bb 27       	eor	r27, r27
    6728:	c8 2a       	or	r12, r24
    672a:	d9 2a       	or	r13, r25
    672c:	ea 2a       	or	r14, r26
    672e:	fb 2a       	or	r15, r27
    6730:	09 a5       	lds	r16, 0x69
    6732:	1a a5       	lds	r17, 0x6a
    6734:	2b a5       	lds	r18, 0x6b
    6736:	3c a5       	lds	r19, 0x6c
    6738:	c4 16       	cp	r12, r20
    673a:	d5 06       	cpc	r13, r21
    673c:	e6 06       	cpc	r14, r22
    673e:	f7 06       	cpc	r15, r23
    6740:	38 f5       	brcc	.+78     	; 0x6790 <__stack+0x791>
    6742:	01 50       	subi	r16, 0x01	; 1
    6744:	10 40       	sbci	r17, 0x00	; 0
    6746:	20 40       	sbci	r18, 0x00	; 0
    6748:	30 40       	sbci	r19, 0x00	; 0
    674a:	09 ab       	sts	0x59, r16
    674c:	1a ab       	sts	0x5a, r17
    674e:	2b ab       	sts	0x5b, r18
    6750:	3c ab       	sts	0x5c, r19
    6752:	c8 0c       	add	r12, r8
    6754:	d9 1c       	adc	r13, r9
    6756:	ea 1c       	adc	r14, r10
    6758:	fb 1c       	adc	r15, r11
    675a:	c8 14       	cp	r12, r8
    675c:	d9 04       	cpc	r13, r9
    675e:	ea 04       	cpc	r14, r10
    6760:	fb 04       	cpc	r15, r11
    6762:	d0 f0       	brcs	.+52     	; 0x6798 <__stack+0x799>
    6764:	c4 16       	cp	r12, r20
    6766:	d5 06       	cpc	r13, r21
    6768:	e6 06       	cpc	r14, r22
    676a:	f7 06       	cpc	r15, r23
    676c:	a8 f4       	brcc	.+42     	; 0x6798 <__stack+0x799>
    676e:	09 a5       	lds	r16, 0x69
    6770:	1a a5       	lds	r17, 0x6a
    6772:	2b a5       	lds	r18, 0x6b
    6774:	3c a5       	lds	r19, 0x6c
    6776:	02 50       	subi	r16, 0x02	; 2
    6778:	10 40       	sbci	r17, 0x00	; 0
    677a:	20 40       	sbci	r18, 0x00	; 0
    677c:	30 40       	sbci	r19, 0x00	; 0
    677e:	09 ab       	sts	0x59, r16
    6780:	1a ab       	sts	0x5a, r17
    6782:	2b ab       	sts	0x5b, r18
    6784:	3c ab       	sts	0x5c, r19
    6786:	c8 0c       	add	r12, r8
    6788:	d9 1c       	adc	r13, r9
    678a:	ea 1c       	adc	r14, r10
    678c:	fb 1c       	adc	r15, r11
    678e:	04 c0       	rjmp	.+8      	; 0x6798 <__stack+0x799>
    6790:	09 ab       	sts	0x59, r16
    6792:	1a ab       	sts	0x5a, r17
    6794:	2b ab       	sts	0x5b, r18
    6796:	3c ab       	sts	0x5c, r19
    6798:	c4 1a       	sub	r12, r20
    679a:	d5 0a       	sbc	r13, r21
    679c:	e6 0a       	sbc	r14, r22
    679e:	f7 0a       	sbc	r15, r23
    67a0:	c7 01       	movw	r24, r14
    67a2:	b6 01       	movw	r22, r12
    67a4:	2d a5       	lds	r18, 0x6d
    67a6:	3e a5       	lds	r19, 0x6e
    67a8:	4f a5       	lds	r20, 0x6f
    67aa:	58 a9       	sts	0x48, r21
    67ac:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    67b0:	29 a7       	lds	r18, 0x79
    67b2:	3a a7       	lds	r19, 0x7a
    67b4:	4b a7       	lds	r20, 0x7b
    67b6:	5c a7       	lds	r21, 0x7c
    67b8:	21 96       	adiw	r28, 0x01	; 1
    67ba:	6c af       	sts	0x7c, r22
    67bc:	7d af       	sts	0x7d, r23
    67be:	8e af       	sts	0x7e, r24
    67c0:	9f af       	sts	0x7f, r25
    67c2:	21 97       	sbiw	r28, 0x01	; 1
    67c4:	c7 01       	movw	r24, r14
    67c6:	b6 01       	movw	r22, r12
    67c8:	2d a5       	lds	r18, 0x6d
    67ca:	3e a5       	lds	r19, 0x6e
    67cc:	4f a5       	lds	r20, 0x6f
    67ce:	58 a9       	sts	0x48, r21
    67d0:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    67d4:	ca 01       	movw	r24, r20
    67d6:	b9 01       	movw	r22, r18
    67d8:	29 ad       	sts	0x69, r18
    67da:	3a ad       	sts	0x6a, r19
    67dc:	4b ad       	sts	0x6b, r20
    67de:	5c ad       	sts	0x6c, r21
    67e0:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    67e4:	8b 01       	movw	r16, r22
    67e6:	9c 01       	movw	r18, r24
    67e8:	21 96       	adiw	r28, 0x01	; 1
    67ea:	4c ad       	sts	0x6c, r20
    67ec:	5d ad       	sts	0x6d, r21
    67ee:	6e ad       	sts	0x6e, r22
    67f0:	7f ad       	sts	0x6f, r23
    67f2:	21 97       	sbiw	r28, 0x01	; 1
    67f4:	da 01       	movw	r26, r20
    67f6:	99 27       	eor	r25, r25
    67f8:	88 27       	eor	r24, r24
    67fa:	4d a9       	sts	0x4d, r20
    67fc:	5e a9       	sts	0x4e, r21
    67fe:	6f a9       	sts	0x4f, r22
    6800:	78 ad       	sts	0x68, r23
    6802:	60 70       	andi	r22, 0x00	; 0
    6804:	70 70       	andi	r23, 0x00	; 0
    6806:	84 2b       	or	r24, r20
    6808:	95 2b       	or	r25, r21
    680a:	a6 2b       	or	r26, r22
    680c:	b7 2b       	or	r27, r23
    680e:	49 a5       	lds	r20, 0x69
    6810:	5a a5       	lds	r21, 0x6a
    6812:	6b a5       	lds	r22, 0x6b
    6814:	7c a5       	lds	r23, 0x6c
    6816:	80 17       	cp	r24, r16
    6818:	91 07       	cpc	r25, r17
    681a:	a2 07       	cpc	r26, r18
    681c:	b3 07       	cpc	r27, r19
    681e:	d0 f4       	brcc	.+52     	; 0x6854 <__stack+0x855>
    6820:	41 50       	subi	r20, 0x01	; 1
    6822:	50 40       	sbci	r21, 0x00	; 0
    6824:	60 40       	sbci	r22, 0x00	; 0
    6826:	70 40       	sbci	r23, 0x00	; 0
    6828:	88 0d       	add	r24, r8
    682a:	99 1d       	adc	r25, r9
    682c:	aa 1d       	adc	r26, r10
    682e:	bb 1d       	adc	r27, r11
    6830:	88 15       	cp	r24, r8
    6832:	99 05       	cpc	r25, r9
    6834:	aa 05       	cpc	r26, r10
    6836:	bb 05       	cpc	r27, r11
    6838:	68 f0       	brcs	.+26     	; 0x6854 <__stack+0x855>
    683a:	80 17       	cp	r24, r16
    683c:	91 07       	cpc	r25, r17
    683e:	a2 07       	cpc	r26, r18
    6840:	b3 07       	cpc	r27, r19
    6842:	40 f4       	brcc	.+16     	; 0x6854 <__stack+0x855>
    6844:	49 a5       	lds	r20, 0x69
    6846:	5a a5       	lds	r21, 0x6a
    6848:	6b a5       	lds	r22, 0x6b
    684a:	7c a5       	lds	r23, 0x6c
    684c:	42 50       	subi	r20, 0x02	; 2
    684e:	50 40       	sbci	r21, 0x00	; 0
    6850:	60 40       	sbci	r22, 0x00	; 0
    6852:	70 40       	sbci	r23, 0x00	; 0
    6854:	09 a9       	sts	0x49, r16
    6856:	1a a9       	sts	0x4a, r17
    6858:	2b a9       	sts	0x4b, r18
    685a:	3c a9       	sts	0x4c, r19
    685c:	78 01       	movw	r14, r16
    685e:	dd 24       	eor	r13, r13
    6860:	cc 24       	eor	r12, r12
    6862:	c4 2a       	or	r12, r20
    6864:	d5 2a       	or	r13, r21
    6866:	e6 2a       	or	r14, r22
    6868:	f7 2a       	or	r15, r23
    686a:	50 c2       	rjmp	.+1184   	; 0x6d0c <__stack+0xd0d>
    686c:	c8 16       	cp	r12, r24
    686e:	d9 06       	cpc	r13, r25
    6870:	ea 06       	cpc	r14, r26
    6872:	fb 06       	cpc	r15, r27
    6874:	08 f4       	brcc	.+2      	; 0x6878 <__stack+0x879>
    6876:	37 c2       	rjmp	.+1134   	; 0x6ce6 <__stack+0xce7>
    6878:	80 30       	cpi	r24, 0x00	; 0
    687a:	10 e0       	ldi	r17, 0x00	; 0
    687c:	91 07       	cpc	r25, r17
    687e:	11 e0       	ldi	r17, 0x01	; 1
    6880:	a1 07       	cpc	r26, r17
    6882:	10 e0       	ldi	r17, 0x00	; 0
    6884:	b1 07       	cpc	r27, r17
    6886:	50 f4       	brcc	.+20     	; 0x689c <__stack+0x89d>
    6888:	8f 3f       	cpi	r24, 0xFF	; 255
    688a:	91 05       	cpc	r25, r1
    688c:	a1 05       	cpc	r26, r1
    688e:	b1 05       	cpc	r27, r1
    6890:	09 f0       	breq	.+2      	; 0x6894 <__stack+0x895>
    6892:	88 f4       	brcc	.+34     	; 0x68b6 <__stack+0x8b7>
    6894:	00 e0       	ldi	r16, 0x00	; 0
    6896:	10 e0       	ldi	r17, 0x00	; 0
    6898:	98 01       	movw	r18, r16
    689a:	16 c0       	rjmp	.+44     	; 0x68c8 <__stack+0x8c9>
    689c:	80 30       	cpi	r24, 0x00	; 0
    689e:	20 e0       	ldi	r18, 0x00	; 0
    68a0:	92 07       	cpc	r25, r18
    68a2:	20 e0       	ldi	r18, 0x00	; 0
    68a4:	a2 07       	cpc	r26, r18
    68a6:	21 e0       	ldi	r18, 0x01	; 1
    68a8:	b2 07       	cpc	r27, r18
    68aa:	50 f4       	brcc	.+20     	; 0x68c0 <__stack+0x8c1>
    68ac:	00 e1       	ldi	r16, 0x10	; 16
    68ae:	10 e0       	ldi	r17, 0x00	; 0
    68b0:	20 e0       	ldi	r18, 0x00	; 0
    68b2:	30 e0       	ldi	r19, 0x00	; 0
    68b4:	09 c0       	rjmp	.+18     	; 0x68c8 <__stack+0x8c9>
    68b6:	08 e0       	ldi	r16, 0x08	; 8
    68b8:	10 e0       	ldi	r17, 0x00	; 0
    68ba:	20 e0       	ldi	r18, 0x00	; 0
    68bc:	30 e0       	ldi	r19, 0x00	; 0
    68be:	04 c0       	rjmp	.+8      	; 0x68c8 <__stack+0x8c9>
    68c0:	08 e1       	ldi	r16, 0x18	; 24
    68c2:	10 e0       	ldi	r17, 0x00	; 0
    68c4:	20 e0       	ldi	r18, 0x00	; 0
    68c6:	30 e0       	ldi	r19, 0x00	; 0
    68c8:	ac 01       	movw	r20, r24
    68ca:	bd 01       	movw	r22, r26
    68cc:	00 2e       	mov	r0, r16
    68ce:	04 c0       	rjmp	.+8      	; 0x68d8 <__stack+0x8d9>
    68d0:	76 95       	lsr	r23
    68d2:	67 95       	ror	r22
    68d4:	57 95       	ror	r21
    68d6:	47 95       	ror	r20
    68d8:	0a 94       	dec	r0
    68da:	d2 f7       	brpl	.-12     	; 0x68d0 <__stack+0x8d1>
    68dc:	fa 01       	movw	r30, r20
    68de:	e3 5f       	subi	r30, 0xF3	; 243
    68e0:	ff 4d       	sbci	r31, 0xDF	; 223
    68e2:	40 81       	ld	r20, Z
    68e4:	04 0f       	add	r16, r20
    68e6:	11 1d       	adc	r17, r1
    68e8:	21 1d       	adc	r18, r1
    68ea:	31 1d       	adc	r19, r1
    68ec:	40 e2       	ldi	r20, 0x20	; 32
    68ee:	50 e0       	ldi	r21, 0x00	; 0
    68f0:	60 e0       	ldi	r22, 0x00	; 0
    68f2:	70 e0       	ldi	r23, 0x00	; 0
    68f4:	40 1b       	sub	r20, r16
    68f6:	51 0b       	sbc	r21, r17
    68f8:	62 0b       	sbc	r22, r18
    68fa:	73 0b       	sbc	r23, r19
    68fc:	a1 f4       	brne	.+40     	; 0x6926 <__stack+0x927>
    68fe:	8c 15       	cp	r24, r12
    6900:	9d 05       	cpc	r25, r13
    6902:	ae 05       	cpc	r26, r14
    6904:	bf 05       	cpc	r27, r15
    6906:	08 f4       	brcc	.+2      	; 0x690a <__stack+0x90b>
    6908:	f5 c1       	rjmp	.+1002   	; 0x6cf4 <__stack+0xcf5>
    690a:	ed a8       	sts	0x8d, r30
    690c:	fe a8       	sts	0x8e, r31
    690e:	0f a9       	sts	0x4f, r16
    6910:	18 ad       	sts	0x68, r17
    6912:	44 24       	eor	r4, r4
    6914:	55 24       	eor	r5, r5
    6916:	32 01       	movw	r6, r4
    6918:	e8 14       	cp	r14, r8
    691a:	f9 04       	cpc	r15, r9
    691c:	0a 05       	cpc	r16, r10
    691e:	1b 05       	cpc	r17, r11
    6920:	08 f0       	brcs	.+2      	; 0x6924 <__stack+0x925>
    6922:	eb c1       	rjmp	.+982    	; 0x6cfa <__stack+0xcfb>
    6924:	e3 c1       	rjmp	.+966    	; 0x6cec <__stack+0xced>
    6926:	34 2e       	mov	r3, r20
    6928:	2c 01       	movw	r4, r24
    692a:	3d 01       	movw	r6, r26
    692c:	04 c0       	rjmp	.+8      	; 0x6936 <__stack+0x937>
    692e:	44 0c       	add	r4, r4
    6930:	55 1c       	adc	r5, r5
    6932:	66 1c       	adc	r6, r6
    6934:	77 1c       	adc	r7, r7
    6936:	4a 95       	dec	r20
    6938:	d2 f7       	brpl	.-12     	; 0x692e <__stack+0x92f>
    693a:	d5 01       	movw	r26, r10
    693c:	c4 01       	movw	r24, r8
    693e:	00 2e       	mov	r0, r16
    6940:	04 c0       	rjmp	.+8      	; 0x694a <__stack+0x94b>
    6942:	b6 95       	lsr	r27
    6944:	a7 95       	ror	r26
    6946:	97 95       	ror	r25
    6948:	87 95       	ror	r24
    694a:	0a 94       	dec	r0
    694c:	d2 f7       	brpl	.-12     	; 0x6942 <__stack+0x943>
    694e:	48 2a       	or	r4, r24
    6950:	59 2a       	or	r5, r25
    6952:	6a 2a       	or	r6, r26
    6954:	7b 2a       	or	r7, r27
    6956:	a5 01       	movw	r20, r10
    6958:	94 01       	movw	r18, r8
    695a:	03 2c       	mov	r0, r3
    695c:	04 c0       	rjmp	.+8      	; 0x6966 <__stack+0x967>
    695e:	22 0f       	add	r18, r18
    6960:	33 1f       	adc	r19, r19
    6962:	44 1f       	adc	r20, r20
    6964:	55 1f       	adc	r21, r21
    6966:	0a 94       	dec	r0
    6968:	d2 f7       	brpl	.-12     	; 0x695e <__stack+0x95f>
    696a:	29 af       	sts	0x79, r18
    696c:	3a af       	sts	0x7a, r19
    696e:	4b af       	sts	0x7b, r20
    6970:	5c af       	sts	0x7c, r21
    6972:	b7 01       	movw	r22, r14
    6974:	a6 01       	movw	r20, r12
    6976:	00 2e       	mov	r0, r16
    6978:	04 c0       	rjmp	.+8      	; 0x6982 <__stack+0x983>
    697a:	76 95       	lsr	r23
    697c:	67 95       	ror	r22
    697e:	57 95       	ror	r21
    6980:	47 95       	ror	r20
    6982:	0a 94       	dec	r0
    6984:	d2 f7       	brpl	.-12     	; 0x697a <__stack+0x97b>
    6986:	49 ab       	sts	0x59, r20
    6988:	5a ab       	sts	0x5a, r21
    698a:	6b ab       	sts	0x5b, r22
    698c:	7c ab       	sts	0x5c, r23
    698e:	c7 01       	movw	r24, r14
    6990:	b6 01       	movw	r22, r12
    6992:	03 2c       	mov	r0, r3
    6994:	04 c0       	rjmp	.+8      	; 0x699e <__stack+0x99f>
    6996:	66 0f       	add	r22, r22
    6998:	77 1f       	adc	r23, r23
    699a:	88 1f       	adc	r24, r24
    699c:	99 1f       	adc	r25, r25
    699e:	0a 94       	dec	r0
    69a0:	d2 f7       	brpl	.-12     	; 0x6996 <__stack+0x997>
    69a2:	6d a7       	lds	r22, 0x7d
    69a4:	7e a7       	lds	r23, 0x7e
    69a6:	8f a7       	lds	r24, 0x7f
    69a8:	98 ab       	sts	0x58, r25
    69aa:	8d a9       	sts	0x4d, r24
    69ac:	9e a9       	sts	0x4e, r25
    69ae:	af a9       	sts	0x4f, r26
    69b0:	b8 ad       	sts	0x68, r27
    69b2:	04 c0       	rjmp	.+8      	; 0x69bc <__stack+0x9bd>
    69b4:	b6 95       	lsr	r27
    69b6:	a7 95       	ror	r26
    69b8:	97 95       	ror	r25
    69ba:	87 95       	ror	r24
    69bc:	0a 95       	dec	r16
    69be:	d2 f7       	brpl	.-12     	; 0x69b4 <__stack+0x9b5>
    69c0:	4d a5       	lds	r20, 0x6d
    69c2:	5e a5       	lds	r21, 0x6e
    69c4:	6f a5       	lds	r22, 0x6f
    69c6:	78 a9       	sts	0x48, r23
    69c8:	48 2b       	or	r20, r24
    69ca:	59 2b       	or	r21, r25
    69cc:	6a 2b       	or	r22, r26
    69ce:	7b 2b       	or	r23, r27
    69d0:	4d a7       	lds	r20, 0x7d
    69d2:	5e a7       	lds	r21, 0x7e
    69d4:	6f a7       	lds	r22, 0x7f
    69d6:	78 ab       	sts	0x58, r23
    69d8:	43 01       	movw	r8, r6
    69da:	aa 24       	eor	r10, r10
    69dc:	bb 24       	eor	r11, r11
    69de:	93 01       	movw	r18, r6
    69e0:	82 01       	movw	r16, r4
    69e2:	20 70       	andi	r18, 0x00	; 0
    69e4:	30 70       	andi	r19, 0x00	; 0
    69e6:	21 96       	adiw	r28, 0x01	; 1
    69e8:	0c af       	sts	0x7c, r16
    69ea:	1d af       	sts	0x7d, r17
    69ec:	2e af       	sts	0x7e, r18
    69ee:	3f af       	sts	0x7f, r19
    69f0:	21 97       	sbiw	r28, 0x01	; 1
    69f2:	69 a9       	sts	0x49, r22
    69f4:	7a a9       	sts	0x4a, r23
    69f6:	8b a9       	sts	0x4b, r24
    69f8:	9c a9       	sts	0x4c, r25
    69fa:	a5 01       	movw	r20, r10
    69fc:	94 01       	movw	r18, r8
    69fe:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6a02:	29 a7       	lds	r18, 0x79
    6a04:	3a a7       	lds	r19, 0x7a
    6a06:	4b a7       	lds	r20, 0x7b
    6a08:	5c a7       	lds	r21, 0x7c
    6a0a:	6b 01       	movw	r12, r22
    6a0c:	7c 01       	movw	r14, r24
    6a0e:	69 a9       	sts	0x49, r22
    6a10:	7a a9       	sts	0x4a, r23
    6a12:	8b a9       	sts	0x4b, r24
    6a14:	9c a9       	sts	0x4c, r25
    6a16:	a5 01       	movw	r20, r10
    6a18:	94 01       	movw	r18, r8
    6a1a:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6a1e:	ca 01       	movw	r24, r20
    6a20:	b9 01       	movw	r22, r18
    6a22:	21 96       	adiw	r28, 0x01	; 1
    6a24:	2c ad       	sts	0x6c, r18
    6a26:	3d ad       	sts	0x6d, r19
    6a28:	4e ad       	sts	0x6e, r20
    6a2a:	5f ad       	sts	0x6f, r21
    6a2c:	21 97       	sbiw	r28, 0x01	; 1
    6a2e:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6a32:	dc 01       	movw	r26, r24
    6a34:	cb 01       	movw	r24, r22
    6a36:	76 01       	movw	r14, r12
    6a38:	dd 24       	eor	r13, r13
    6a3a:	cc 24       	eor	r12, r12
    6a3c:	0d a5       	lds	r16, 0x6d
    6a3e:	1e a5       	lds	r17, 0x6e
    6a40:	2f a5       	lds	r18, 0x6f
    6a42:	38 a9       	sts	0x48, r19
    6a44:	a9 01       	movw	r20, r18
    6a46:	66 27       	eor	r22, r22
    6a48:	77 27       	eor	r23, r23
    6a4a:	c4 2a       	or	r12, r20
    6a4c:	d5 2a       	or	r13, r21
    6a4e:	e6 2a       	or	r14, r22
    6a50:	f7 2a       	or	r15, r23
    6a52:	09 a5       	lds	r16, 0x69
    6a54:	1a a5       	lds	r17, 0x6a
    6a56:	2b a5       	lds	r18, 0x6b
    6a58:	3c a5       	lds	r19, 0x6c
    6a5a:	c8 16       	cp	r12, r24
    6a5c:	d9 06       	cpc	r13, r25
    6a5e:	ea 06       	cpc	r14, r26
    6a60:	fb 06       	cpc	r15, r27
    6a62:	38 f5       	brcc	.+78     	; 0x6ab2 <__stack+0xab3>
    6a64:	01 50       	subi	r16, 0x01	; 1
    6a66:	10 40       	sbci	r17, 0x00	; 0
    6a68:	20 40       	sbci	r18, 0x00	; 0
    6a6a:	30 40       	sbci	r19, 0x00	; 0
    6a6c:	09 ab       	sts	0x59, r16
    6a6e:	1a ab       	sts	0x5a, r17
    6a70:	2b ab       	sts	0x5b, r18
    6a72:	3c ab       	sts	0x5c, r19
    6a74:	c4 0c       	add	r12, r4
    6a76:	d5 1c       	adc	r13, r5
    6a78:	e6 1c       	adc	r14, r6
    6a7a:	f7 1c       	adc	r15, r7
    6a7c:	c4 14       	cp	r12, r4
    6a7e:	d5 04       	cpc	r13, r5
    6a80:	e6 04       	cpc	r14, r6
    6a82:	f7 04       	cpc	r15, r7
    6a84:	d0 f0       	brcs	.+52     	; 0x6aba <__stack+0xabb>
    6a86:	c8 16       	cp	r12, r24
    6a88:	d9 06       	cpc	r13, r25
    6a8a:	ea 06       	cpc	r14, r26
    6a8c:	fb 06       	cpc	r15, r27
    6a8e:	a8 f4       	brcc	.+42     	; 0x6aba <__stack+0xabb>
    6a90:	09 a5       	lds	r16, 0x69
    6a92:	1a a5       	lds	r17, 0x6a
    6a94:	2b a5       	lds	r18, 0x6b
    6a96:	3c a5       	lds	r19, 0x6c
    6a98:	02 50       	subi	r16, 0x02	; 2
    6a9a:	10 40       	sbci	r17, 0x00	; 0
    6a9c:	20 40       	sbci	r18, 0x00	; 0
    6a9e:	30 40       	sbci	r19, 0x00	; 0
    6aa0:	09 ab       	sts	0x59, r16
    6aa2:	1a ab       	sts	0x5a, r17
    6aa4:	2b ab       	sts	0x5b, r18
    6aa6:	3c ab       	sts	0x5c, r19
    6aa8:	c4 0c       	add	r12, r4
    6aaa:	d5 1c       	adc	r13, r5
    6aac:	e6 1c       	adc	r14, r6
    6aae:	f7 1c       	adc	r15, r7
    6ab0:	04 c0       	rjmp	.+8      	; 0x6aba <__stack+0xabb>
    6ab2:	09 ab       	sts	0x59, r16
    6ab4:	1a ab       	sts	0x5a, r17
    6ab6:	2b ab       	sts	0x5b, r18
    6ab8:	3c ab       	sts	0x5c, r19
    6aba:	c8 1a       	sub	r12, r24
    6abc:	d9 0a       	sbc	r13, r25
    6abe:	ea 0a       	sbc	r14, r26
    6ac0:	fb 0a       	sbc	r15, r27
    6ac2:	c7 01       	movw	r24, r14
    6ac4:	b6 01       	movw	r22, r12
    6ac6:	a5 01       	movw	r20, r10
    6ac8:	94 01       	movw	r18, r8
    6aca:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6ace:	29 a7       	lds	r18, 0x79
    6ad0:	3a a7       	lds	r19, 0x7a
    6ad2:	4b a7       	lds	r20, 0x7b
    6ad4:	5c a7       	lds	r21, 0x7c
    6ad6:	29 96       	adiw	r28, 0x09	; 9
    6ad8:	6c af       	sts	0x7c, r22
    6ada:	7d af       	sts	0x7d, r23
    6adc:	8e af       	sts	0x7e, r24
    6ade:	9f af       	sts	0x7f, r25
    6ae0:	29 97       	sbiw	r28, 0x09	; 9
    6ae2:	c7 01       	movw	r24, r14
    6ae4:	b6 01       	movw	r22, r12
    6ae6:	a5 01       	movw	r20, r10
    6ae8:	94 01       	movw	r18, r8
    6aea:	0e 94 e5 38 	call	0x71ca	; 0x71ca <__udivmodsi4>
    6aee:	ca 01       	movw	r24, r20
    6af0:	b9 01       	movw	r22, r18
    6af2:	21 96       	adiw	r28, 0x01	; 1
    6af4:	2c ad       	sts	0x6c, r18
    6af6:	3d ad       	sts	0x6d, r19
    6af8:	4e ad       	sts	0x6e, r20
    6afa:	5f ad       	sts	0x6f, r21
    6afc:	21 97       	sbiw	r28, 0x01	; 1
    6afe:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6b02:	4b 01       	movw	r8, r22
    6b04:	5c 01       	movw	r10, r24
    6b06:	29 96       	adiw	r28, 0x09	; 9
    6b08:	4c ad       	sts	0x6c, r20
    6b0a:	5d ad       	sts	0x6d, r21
    6b0c:	6e ad       	sts	0x6e, r22
    6b0e:	7f ad       	sts	0x6f, r23
    6b10:	29 97       	sbiw	r28, 0x09	; 9
    6b12:	9a 01       	movw	r18, r20
    6b14:	11 27       	eor	r17, r17
    6b16:	00 27       	eor	r16, r16
    6b18:	8d a5       	lds	r24, 0x6d
    6b1a:	9e a5       	lds	r25, 0x6e
    6b1c:	af a5       	lds	r26, 0x6f
    6b1e:	b8 a9       	sts	0x48, r27
    6b20:	a0 70       	andi	r26, 0x00	; 0
    6b22:	b0 70       	andi	r27, 0x00	; 0
    6b24:	08 2b       	or	r16, r24
    6b26:	19 2b       	or	r17, r25
    6b28:	2a 2b       	or	r18, r26
    6b2a:	3b 2b       	or	r19, r27
    6b2c:	89 a5       	lds	r24, 0x69
    6b2e:	9a a5       	lds	r25, 0x6a
    6b30:	ab a5       	lds	r26, 0x6b
    6b32:	bc a5       	lds	r27, 0x6c
    6b34:	08 15       	cp	r16, r8
    6b36:	19 05       	cpc	r17, r9
    6b38:	2a 05       	cpc	r18, r10
    6b3a:	3b 05       	cpc	r19, r11
    6b3c:	e0 f4       	brcc	.+56     	; 0x6b76 <__stack+0xb77>
    6b3e:	01 97       	sbiw	r24, 0x01	; 1
    6b40:	a1 09       	sbc	r26, r1
    6b42:	b1 09       	sbc	r27, r1
    6b44:	04 0d       	add	r16, r4
    6b46:	15 1d       	adc	r17, r5
    6b48:	26 1d       	adc	r18, r6
    6b4a:	37 1d       	adc	r19, r7
    6b4c:	04 15       	cp	r16, r4
    6b4e:	15 05       	cpc	r17, r5
    6b50:	26 05       	cpc	r18, r6
    6b52:	37 05       	cpc	r19, r7
    6b54:	80 f0       	brcs	.+32     	; 0x6b76 <__stack+0xb77>
    6b56:	08 15       	cp	r16, r8
    6b58:	19 05       	cpc	r17, r9
    6b5a:	2a 05       	cpc	r18, r10
    6b5c:	3b 05       	cpc	r19, r11
    6b5e:	58 f4       	brcc	.+22     	; 0x6b76 <__stack+0xb77>
    6b60:	89 a5       	lds	r24, 0x69
    6b62:	9a a5       	lds	r25, 0x6a
    6b64:	ab a5       	lds	r26, 0x6b
    6b66:	bc a5       	lds	r27, 0x6c
    6b68:	02 97       	sbiw	r24, 0x02	; 2
    6b6a:	a1 09       	sbc	r26, r1
    6b6c:	b1 09       	sbc	r27, r1
    6b6e:	04 0d       	add	r16, r4
    6b70:	15 1d       	adc	r17, r5
    6b72:	26 1d       	adc	r18, r6
    6b74:	37 1d       	adc	r19, r7
    6b76:	b9 01       	movw	r22, r18
    6b78:	a8 01       	movw	r20, r16
    6b7a:	48 19       	sub	r20, r8
    6b7c:	59 09       	sbc	r21, r9
    6b7e:	6a 09       	sbc	r22, r10
    6b80:	7b 09       	sbc	r23, r11
    6b82:	4d a7       	lds	r20, 0x7d
    6b84:	5e a7       	lds	r21, 0x7e
    6b86:	6f a7       	lds	r22, 0x7f
    6b88:	78 ab       	sts	0x58, r23
    6b8a:	09 a9       	sts	0x49, r16
    6b8c:	1a a9       	sts	0x4a, r17
    6b8e:	2b a9       	sts	0x4b, r18
    6b90:	3c a9       	sts	0x4c, r19
    6b92:	78 01       	movw	r14, r16
    6b94:	dd 24       	eor	r13, r13
    6b96:	cc 24       	eor	r12, r12
    6b98:	c8 2a       	or	r12, r24
    6b9a:	d9 2a       	or	r13, r25
    6b9c:	ea 2a       	or	r14, r26
    6b9e:	fb 2a       	or	r15, r27
    6ba0:	ff ef       	ldi	r31, 0xFF	; 255
    6ba2:	8f 2e       	mov	r8, r31
    6ba4:	ff ef       	ldi	r31, 0xFF	; 255
    6ba6:	9f 2e       	mov	r9, r31
    6ba8:	a1 2c       	mov	r10, r1
    6baa:	b1 2c       	mov	r11, r1
    6bac:	8c 20       	and	r8, r12
    6bae:	9d 20       	and	r9, r13
    6bb0:	ae 20       	and	r10, r14
    6bb2:	bf 20       	and	r11, r15
    6bb4:	87 01       	movw	r16, r14
    6bb6:	22 27       	eor	r18, r18
    6bb8:	33 27       	eor	r19, r19
    6bba:	09 a7       	lds	r16, 0x79
    6bbc:	1a a7       	lds	r17, 0x7a
    6bbe:	2b a7       	lds	r18, 0x7b
    6bc0:	3c a7       	lds	r19, 0x7c
    6bc2:	49 ac       	sts	0xa9, r20
    6bc4:	5a ac       	sts	0xaa, r21
    6bc6:	6b ac       	sts	0xab, r22
    6bc8:	7c ac       	sts	0xac, r23
    6bca:	2f ef       	ldi	r18, 0xFF	; 255
    6bcc:	3f ef       	ldi	r19, 0xFF	; 255
    6bce:	40 e0       	ldi	r20, 0x00	; 0
    6bd0:	50 e0       	ldi	r21, 0x00	; 0
    6bd2:	42 22       	and	r4, r18
    6bd4:	53 22       	and	r5, r19
    6bd6:	64 22       	and	r6, r20
    6bd8:	75 22       	and	r7, r21
    6bda:	29 ad       	sts	0x69, r18
    6bdc:	3a ad       	sts	0x6a, r19
    6bde:	4b ad       	sts	0x6b, r20
    6be0:	5c ad       	sts	0x6c, r21
    6be2:	8a 01       	movw	r16, r20
    6be4:	22 27       	eor	r18, r18
    6be6:	33 27       	eor	r19, r19
    6be8:	09 ab       	sts	0x59, r16
    6bea:	1a ab       	sts	0x5a, r17
    6bec:	2b ab       	sts	0x5b, r18
    6bee:	3c ab       	sts	0x5c, r19
    6bf0:	c5 01       	movw	r24, r10
    6bf2:	b4 01       	movw	r22, r8
    6bf4:	a3 01       	movw	r20, r6
    6bf6:	92 01       	movw	r18, r4
    6bf8:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6bfc:	69 af       	sts	0x79, r22
    6bfe:	7a af       	sts	0x7a, r23
    6c00:	8b af       	sts	0x7b, r24
    6c02:	9c af       	sts	0x7c, r25
    6c04:	c5 01       	movw	r24, r10
    6c06:	b4 01       	movw	r22, r8
    6c08:	29 a9       	sts	0x49, r18
    6c0a:	3a a9       	sts	0x4a, r19
    6c0c:	4b a9       	sts	0x4b, r20
    6c0e:	5c a9       	sts	0x4c, r21
    6c10:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6c14:	4b 01       	movw	r8, r22
    6c16:	5c 01       	movw	r10, r24
    6c18:	69 a5       	lds	r22, 0x69
    6c1a:	7a a5       	lds	r23, 0x6a
    6c1c:	8b a5       	lds	r24, 0x6b
    6c1e:	9c a5       	lds	r25, 0x6c
    6c20:	a3 01       	movw	r20, r6
    6c22:	92 01       	movw	r18, r4
    6c24:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6c28:	2b 01       	movw	r4, r22
    6c2a:	3c 01       	movw	r6, r24
    6c2c:	69 a5       	lds	r22, 0x69
    6c2e:	7a a5       	lds	r23, 0x6a
    6c30:	8b a5       	lds	r24, 0x6b
    6c32:	9c a5       	lds	r25, 0x6c
    6c34:	29 a9       	sts	0x49, r18
    6c36:	3a a9       	sts	0x4a, r19
    6c38:	4b a9       	sts	0x4b, r20
    6c3a:	5c a9       	sts	0x4c, r21
    6c3c:	0e 94 b3 38 	call	0x7166	; 0x7166 <__mulsi3>
    6c40:	ab 01       	movw	r20, r22
    6c42:	bc 01       	movw	r22, r24
    6c44:	84 0c       	add	r8, r4
    6c46:	95 1c       	adc	r9, r5
    6c48:	a6 1c       	adc	r10, r6
    6c4a:	b7 1c       	adc	r11, r7
    6c4c:	09 ad       	sts	0x69, r16
    6c4e:	1a ad       	sts	0x6a, r17
    6c50:	2b ad       	sts	0x6b, r18
    6c52:	3c ad       	sts	0x6c, r19
    6c54:	c9 01       	movw	r24, r18
    6c56:	aa 27       	eor	r26, r26
    6c58:	bb 27       	eor	r27, r27
    6c5a:	88 0e       	add	r8, r24
    6c5c:	99 1e       	adc	r9, r25
    6c5e:	aa 1e       	adc	r10, r26
    6c60:	bb 1e       	adc	r11, r27
    6c62:	84 14       	cp	r8, r4
    6c64:	95 04       	cpc	r9, r5
    6c66:	a6 04       	cpc	r10, r6
    6c68:	b7 04       	cpc	r11, r7
    6c6a:	20 f4       	brcc	.+8      	; 0x6c74 <__stack+0xc75>
    6c6c:	40 50       	subi	r20, 0x00	; 0
    6c6e:	50 40       	sbci	r21, 0x00	; 0
    6c70:	6f 4f       	sbci	r22, 0xFF	; 255
    6c72:	7f 4f       	sbci	r23, 0xFF	; 255
    6c74:	c5 01       	movw	r24, r10
    6c76:	aa 27       	eor	r26, r26
    6c78:	bb 27       	eor	r27, r27
    6c7a:	84 0f       	add	r24, r20
    6c7c:	95 1f       	adc	r25, r21
    6c7e:	a6 1f       	adc	r26, r22
    6c80:	b7 1f       	adc	r27, r23
    6c82:	0d a5       	lds	r16, 0x6d
    6c84:	1e a5       	lds	r17, 0x6e
    6c86:	2f a5       	lds	r18, 0x6f
    6c88:	38 a9       	sts	0x48, r19
    6c8a:	08 17       	cp	r16, r24
    6c8c:	19 07       	cpc	r17, r25
    6c8e:	2a 07       	cpc	r18, r26
    6c90:	3b 07       	cpc	r19, r27
    6c92:	18 f1       	brcs	.+70     	; 0x6cda <__stack+0xcdb>
    6c94:	80 17       	cp	r24, r16
    6c96:	91 07       	cpc	r25, r17
    6c98:	a2 07       	cpc	r26, r18
    6c9a:	b3 07       	cpc	r27, r19
    6c9c:	a1 f5       	brne	.+104    	; 0x6d06 <__stack+0xd07>
    6c9e:	54 01       	movw	r10, r8
    6ca0:	99 24       	eor	r9, r9
    6ca2:	88 24       	eor	r8, r8
    6ca4:	89 ad       	sts	0x69, r24
    6ca6:	9a ad       	sts	0x6a, r25
    6ca8:	ab ad       	sts	0x6b, r26
    6caa:	bc ad       	sts	0x6c, r27
    6cac:	a0 70       	andi	r26, 0x00	; 0
    6cae:	b0 70       	andi	r27, 0x00	; 0
    6cb0:	88 0e       	add	r8, r24
    6cb2:	99 1e       	adc	r9, r25
    6cb4:	aa 1e       	adc	r10, r26
    6cb6:	bb 1e       	adc	r11, r27
    6cb8:	4d a9       	sts	0x4d, r20
    6cba:	5e a9       	sts	0x4e, r21
    6cbc:	6f a9       	sts	0x4f, r22
    6cbe:	78 ad       	sts	0x68, r23
    6cc0:	03 2c       	mov	r0, r3
    6cc2:	04 c0       	rjmp	.+8      	; 0x6ccc <__stack+0xccd>
    6cc4:	44 0f       	add	r20, r20
    6cc6:	55 1f       	adc	r21, r21
    6cc8:	66 1f       	adc	r22, r22
    6cca:	77 1f       	adc	r23, r23
    6ccc:	0a 94       	dec	r0
    6cce:	d2 f7       	brpl	.-12     	; 0x6cc4 <__stack+0xcc5>
    6cd0:	48 15       	cp	r20, r8
    6cd2:	59 05       	cpc	r21, r9
    6cd4:	6a 05       	cpc	r22, r10
    6cd6:	7b 05       	cpc	r23, r11
    6cd8:	b0 f4       	brcc	.+44     	; 0x6d06 <__stack+0xd07>
    6cda:	08 94       	sec
    6cdc:	c1 08       	sbc	r12, r1
    6cde:	d1 08       	sbc	r13, r1
    6ce0:	e1 08       	sbc	r14, r1
    6ce2:	f1 08       	sbc	r15, r1
    6ce4:	10 c0       	rjmp	.+32     	; 0x6d06 <__stack+0xd07>
    6ce6:	44 24       	eor	r4, r4
    6ce8:	55 24       	eor	r5, r5
    6cea:	32 01       	movw	r6, r4
    6cec:	cc 24       	eor	r12, r12
    6cee:	dd 24       	eor	r13, r13
    6cf0:	76 01       	movw	r14, r12
    6cf2:	0c c0       	rjmp	.+24     	; 0x6d0c <__stack+0xd0d>
    6cf4:	44 24       	eor	r4, r4
    6cf6:	55 24       	eor	r5, r5
    6cf8:	32 01       	movw	r6, r4
    6cfa:	81 e0       	ldi	r24, 0x01	; 1
    6cfc:	c8 2e       	mov	r12, r24
    6cfe:	d1 2c       	mov	r13, r1
    6d00:	e1 2c       	mov	r14, r1
    6d02:	f1 2c       	mov	r15, r1
    6d04:	03 c0       	rjmp	.+6      	; 0x6d0c <__stack+0xd0d>
    6d06:	44 24       	eor	r4, r4
    6d08:	55 24       	eor	r5, r5
    6d0a:	32 01       	movw	r6, r4
    6d0c:	fe 01       	movw	r30, r28
    6d0e:	31 96       	adiw	r30, 0x01	; 1
    6d10:	88 e0       	ldi	r24, 0x08	; 8
    6d12:	df 01       	movw	r26, r30
    6d14:	1d 92       	st	X+, r1
    6d16:	8a 95       	dec	r24
    6d18:	e9 f7       	brne	.-6      	; 0x6d14 <__stack+0xd15>
    6d1a:	c9 82       	std	Y+1, r12	; 0x01
    6d1c:	da 82       	std	Y+2, r13	; 0x02
    6d1e:	eb 82       	std	Y+3, r14	; 0x03
    6d20:	fc 82       	std	Y+4, r15	; 0x04
    6d22:	4d 82       	std	Y+5, r4	; 0x05
    6d24:	5e 82       	std	Y+6, r5	; 0x06
    6d26:	6f 82       	std	Y+7, r6	; 0x07
    6d28:	78 86       	std	Y+8, r7	; 0x08
    6d2a:	2c 2d       	mov	r18, r12
    6d2c:	3a 81       	ldd	r19, Y+2	; 0x02
    6d2e:	4b 81       	ldd	r20, Y+3	; 0x03
    6d30:	5c 81       	ldd	r21, Y+4	; 0x04
    6d32:	64 2d       	mov	r22, r4
    6d34:	7e 81       	ldd	r23, Y+6	; 0x06
    6d36:	8f 81       	ldd	r24, Y+7	; 0x07
    6d38:	98 85       	ldd	r25, Y+8	; 0x08
    6d3a:	25 96       	adiw	r28, 0x05	; 5
    6d3c:	ec ac       	sts	0xac, r30
    6d3e:	fd ac       	sts	0xad, r31
    6d40:	0e ad       	sts	0x6e, r16
    6d42:	1f ad       	sts	0x6f, r17
    6d44:	25 97       	sbiw	r28, 0x05	; 5
    6d46:	e1 14       	cp	r14, r1
    6d48:	f1 04       	cpc	r15, r1
    6d4a:	01 05       	cpc	r16, r1
    6d4c:	11 05       	cpc	r17, r1
    6d4e:	09 f4       	brne	.+2      	; 0x6d52 <__stack+0xd53>
    6d50:	56 c0       	rjmp	.+172    	; 0x6dfe <__stack+0xdff>
    6d52:	21 95       	neg	r18
    6d54:	e1 e0       	ldi	r30, 0x01	; 1
    6d56:	12 16       	cp	r1, r18
    6d58:	08 f0       	brcs	.+2      	; 0x6d5c <__stack+0xd5d>
    6d5a:	e0 e0       	ldi	r30, 0x00	; 0
    6d5c:	31 95       	neg	r19
    6d5e:	f1 e0       	ldi	r31, 0x01	; 1
    6d60:	13 16       	cp	r1, r19
    6d62:	08 f0       	brcs	.+2      	; 0x6d66 <__stack+0xd67>
    6d64:	f0 e0       	ldi	r31, 0x00	; 0
    6d66:	03 2f       	mov	r16, r19
    6d68:	0e 1b       	sub	r16, r30
    6d6a:	e1 e0       	ldi	r30, 0x01	; 1
    6d6c:	30 17       	cp	r19, r16
    6d6e:	08 f0       	brcs	.+2      	; 0x6d72 <__stack+0xd73>
    6d70:	e0 e0       	ldi	r30, 0x00	; 0
    6d72:	fe 2b       	or	r31, r30
    6d74:	41 95       	neg	r20
    6d76:	e1 e0       	ldi	r30, 0x01	; 1
    6d78:	14 16       	cp	r1, r20
    6d7a:	08 f0       	brcs	.+2      	; 0x6d7e <__stack+0xd7f>
    6d7c:	e0 e0       	ldi	r30, 0x00	; 0
    6d7e:	14 2f       	mov	r17, r20
    6d80:	1f 1b       	sub	r17, r31
    6d82:	31 e0       	ldi	r19, 0x01	; 1
    6d84:	41 17       	cp	r20, r17
    6d86:	08 f0       	brcs	.+2      	; 0x6d8a <__stack+0xd8b>
    6d88:	30 e0       	ldi	r19, 0x00	; 0
    6d8a:	e3 2b       	or	r30, r19
    6d8c:	51 95       	neg	r21
    6d8e:	f1 e0       	ldi	r31, 0x01	; 1
    6d90:	15 16       	cp	r1, r21
    6d92:	08 f0       	brcs	.+2      	; 0x6d96 <__stack+0xd97>
    6d94:	f0 e0       	ldi	r31, 0x00	; 0
    6d96:	b5 2f       	mov	r27, r21
    6d98:	be 1b       	sub	r27, r30
    6d9a:	31 e0       	ldi	r19, 0x01	; 1
    6d9c:	5b 17       	cp	r21, r27
    6d9e:	08 f0       	brcs	.+2      	; 0x6da2 <__stack+0xda3>
    6da0:	30 e0       	ldi	r19, 0x00	; 0
    6da2:	f3 2b       	or	r31, r19
    6da4:	61 95       	neg	r22
    6da6:	e1 e0       	ldi	r30, 0x01	; 1
    6da8:	16 16       	cp	r1, r22
    6daa:	08 f0       	brcs	.+2      	; 0x6dae <__stack+0xdaf>
    6dac:	e0 e0       	ldi	r30, 0x00	; 0
    6dae:	46 2e       	mov	r4, r22
    6db0:	4f 1a       	sub	r4, r31
    6db2:	31 e0       	ldi	r19, 0x01	; 1
    6db4:	64 15       	cp	r22, r4
    6db6:	08 f0       	brcs	.+2      	; 0x6dba <__stack+0xdbb>
    6db8:	30 e0       	ldi	r19, 0x00	; 0
    6dba:	e3 2b       	or	r30, r19
    6dbc:	71 95       	neg	r23
    6dbe:	f1 e0       	ldi	r31, 0x01	; 1
    6dc0:	17 16       	cp	r1, r23
    6dc2:	08 f0       	brcs	.+2      	; 0x6dc6 <__stack+0xdc7>
    6dc4:	f0 e0       	ldi	r31, 0x00	; 0
    6dc6:	a7 2f       	mov	r26, r23
    6dc8:	ae 1b       	sub	r26, r30
    6dca:	31 e0       	ldi	r19, 0x01	; 1
    6dcc:	7a 17       	cp	r23, r26
    6dce:	08 f0       	brcs	.+2      	; 0x6dd2 <__stack+0xdd3>
    6dd0:	30 e0       	ldi	r19, 0x00	; 0
    6dd2:	f3 2b       	or	r31, r19
    6dd4:	81 95       	neg	r24
    6dd6:	e1 e0       	ldi	r30, 0x01	; 1
    6dd8:	18 16       	cp	r1, r24
    6dda:	08 f0       	brcs	.+2      	; 0x6dde <__stack+0xddf>
    6ddc:	e0 e0       	ldi	r30, 0x00	; 0
    6dde:	f8 2e       	mov	r15, r24
    6de0:	ff 1a       	sub	r15, r31
    6de2:	ff 2d       	mov	r31, r15
    6de4:	31 e0       	ldi	r19, 0x01	; 1
    6de6:	8f 15       	cp	r24, r15
    6de8:	08 f0       	brcs	.+2      	; 0x6dec <__stack+0xded>
    6dea:	30 e0       	ldi	r19, 0x00	; 0
    6dec:	e3 2b       	or	r30, r19
    6dee:	91 95       	neg	r25
    6df0:	30 2f       	mov	r19, r16
    6df2:	41 2f       	mov	r20, r17
    6df4:	5b 2f       	mov	r21, r27
    6df6:	64 2d       	mov	r22, r4
    6df8:	7a 2f       	mov	r23, r26
    6dfa:	8f 2f       	mov	r24, r31
    6dfc:	9e 1b       	sub	r25, r30
    6dfe:	c8 5b       	subi	r28, 0xB8	; 184
    6e00:	df 4f       	sbci	r29, 0xFF	; 255
    6e02:	e1 e1       	ldi	r30, 0x11	; 17
    6e04:	0c 94 50 39 	jmp	0x72a0	; 0x72a0 <__epilogue_restores__+0x2>

00006e08 <__subsf3>:
    6e08:	50 58       	subi	r21, 0x80	; 128

00006e0a <__addsf3>:
    6e0a:	bb 27       	eor	r27, r27
    6e0c:	aa 27       	eor	r26, r26
    6e0e:	0e d0       	rcall	.+28     	; 0x6e2c <__addsf3x>
    6e10:	48 c1       	rjmp	.+656    	; 0x70a2 <__fp_round>
    6e12:	39 d1       	rcall	.+626    	; 0x7086 <__fp_pscA>
    6e14:	30 f0       	brcs	.+12     	; 0x6e22 <__addsf3+0x18>
    6e16:	3e d1       	rcall	.+636    	; 0x7094 <__fp_pscB>
    6e18:	20 f0       	brcs	.+8      	; 0x6e22 <__addsf3+0x18>
    6e1a:	31 f4       	brne	.+12     	; 0x6e28 <__addsf3+0x1e>
    6e1c:	9f 3f       	cpi	r25, 0xFF	; 255
    6e1e:	11 f4       	brne	.+4      	; 0x6e24 <__addsf3+0x1a>
    6e20:	1e f4       	brtc	.+6      	; 0x6e28 <__addsf3+0x1e>
    6e22:	2e c1       	rjmp	.+604    	; 0x7080 <__fp_nan>
    6e24:	0e f4       	brtc	.+2      	; 0x6e28 <__addsf3+0x1e>
    6e26:	e0 95       	com	r30
    6e28:	e7 fb       	bst	r30, 7
    6e2a:	24 c1       	rjmp	.+584    	; 0x7074 <__fp_inf>

00006e2c <__addsf3x>:
    6e2c:	e9 2f       	mov	r30, r25
    6e2e:	4a d1       	rcall	.+660    	; 0x70c4 <__fp_split3>
    6e30:	80 f3       	brcs	.-32     	; 0x6e12 <__addsf3+0x8>
    6e32:	ba 17       	cp	r27, r26
    6e34:	62 07       	cpc	r22, r18
    6e36:	73 07       	cpc	r23, r19
    6e38:	84 07       	cpc	r24, r20
    6e3a:	95 07       	cpc	r25, r21
    6e3c:	18 f0       	brcs	.+6      	; 0x6e44 <__addsf3x+0x18>
    6e3e:	71 f4       	brne	.+28     	; 0x6e5c <__addsf3x+0x30>
    6e40:	9e f5       	brtc	.+102    	; 0x6ea8 <__addsf3x+0x7c>
    6e42:	62 c1       	rjmp	.+708    	; 0x7108 <__fp_zero>
    6e44:	0e f4       	brtc	.+2      	; 0x6e48 <__addsf3x+0x1c>
    6e46:	e0 95       	com	r30
    6e48:	0b 2e       	mov	r0, r27
    6e4a:	ba 2f       	mov	r27, r26
    6e4c:	a0 2d       	mov	r26, r0
    6e4e:	0b 01       	movw	r0, r22
    6e50:	b9 01       	movw	r22, r18
    6e52:	90 01       	movw	r18, r0
    6e54:	0c 01       	movw	r0, r24
    6e56:	ca 01       	movw	r24, r20
    6e58:	a0 01       	movw	r20, r0
    6e5a:	11 24       	eor	r1, r1
    6e5c:	ff 27       	eor	r31, r31
    6e5e:	59 1b       	sub	r21, r25
    6e60:	99 f0       	breq	.+38     	; 0x6e88 <__addsf3x+0x5c>
    6e62:	59 3f       	cpi	r21, 0xF9	; 249
    6e64:	50 f4       	brcc	.+20     	; 0x6e7a <__addsf3x+0x4e>
    6e66:	50 3e       	cpi	r21, 0xE0	; 224
    6e68:	68 f1       	brcs	.+90     	; 0x6ec4 <__addsf3x+0x98>
    6e6a:	1a 16       	cp	r1, r26
    6e6c:	f0 40       	sbci	r31, 0x00	; 0
    6e6e:	a2 2f       	mov	r26, r18
    6e70:	23 2f       	mov	r18, r19
    6e72:	34 2f       	mov	r19, r20
    6e74:	44 27       	eor	r20, r20
    6e76:	58 5f       	subi	r21, 0xF8	; 248
    6e78:	f3 cf       	rjmp	.-26     	; 0x6e60 <__addsf3x+0x34>
    6e7a:	46 95       	lsr	r20
    6e7c:	37 95       	ror	r19
    6e7e:	27 95       	ror	r18
    6e80:	a7 95       	ror	r26
    6e82:	f0 40       	sbci	r31, 0x00	; 0
    6e84:	53 95       	inc	r21
    6e86:	c9 f7       	brne	.-14     	; 0x6e7a <__addsf3x+0x4e>
    6e88:	7e f4       	brtc	.+30     	; 0x6ea8 <__addsf3x+0x7c>
    6e8a:	1f 16       	cp	r1, r31
    6e8c:	ba 0b       	sbc	r27, r26
    6e8e:	62 0b       	sbc	r22, r18
    6e90:	73 0b       	sbc	r23, r19
    6e92:	84 0b       	sbc	r24, r20
    6e94:	ba f0       	brmi	.+46     	; 0x6ec4 <__addsf3x+0x98>
    6e96:	91 50       	subi	r25, 0x01	; 1
    6e98:	a1 f0       	breq	.+40     	; 0x6ec2 <__addsf3x+0x96>
    6e9a:	ff 0f       	add	r31, r31
    6e9c:	bb 1f       	adc	r27, r27
    6e9e:	66 1f       	adc	r22, r22
    6ea0:	77 1f       	adc	r23, r23
    6ea2:	88 1f       	adc	r24, r24
    6ea4:	c2 f7       	brpl	.-16     	; 0x6e96 <__addsf3x+0x6a>
    6ea6:	0e c0       	rjmp	.+28     	; 0x6ec4 <__addsf3x+0x98>
    6ea8:	ba 0f       	add	r27, r26
    6eaa:	62 1f       	adc	r22, r18
    6eac:	73 1f       	adc	r23, r19
    6eae:	84 1f       	adc	r24, r20
    6eb0:	48 f4       	brcc	.+18     	; 0x6ec4 <__addsf3x+0x98>
    6eb2:	87 95       	ror	r24
    6eb4:	77 95       	ror	r23
    6eb6:	67 95       	ror	r22
    6eb8:	b7 95       	ror	r27
    6eba:	f7 95       	ror	r31
    6ebc:	9e 3f       	cpi	r25, 0xFE	; 254
    6ebe:	08 f0       	brcs	.+2      	; 0x6ec2 <__addsf3x+0x96>
    6ec0:	b3 cf       	rjmp	.-154    	; 0x6e28 <__addsf3+0x1e>
    6ec2:	93 95       	inc	r25
    6ec4:	88 0f       	add	r24, r24
    6ec6:	08 f0       	brcs	.+2      	; 0x6eca <__addsf3x+0x9e>
    6ec8:	99 27       	eor	r25, r25
    6eca:	ee 0f       	add	r30, r30
    6ecc:	97 95       	ror	r25
    6ece:	87 95       	ror	r24
    6ed0:	08 95       	ret

00006ed2 <__divsf3>:
    6ed2:	0c d0       	rcall	.+24     	; 0x6eec <__divsf3x>
    6ed4:	e6 c0       	rjmp	.+460    	; 0x70a2 <__fp_round>
    6ed6:	de d0       	rcall	.+444    	; 0x7094 <__fp_pscB>
    6ed8:	40 f0       	brcs	.+16     	; 0x6eea <__divsf3+0x18>
    6eda:	d5 d0       	rcall	.+426    	; 0x7086 <__fp_pscA>
    6edc:	30 f0       	brcs	.+12     	; 0x6eea <__divsf3+0x18>
    6ede:	21 f4       	brne	.+8      	; 0x6ee8 <__divsf3+0x16>
    6ee0:	5f 3f       	cpi	r21, 0xFF	; 255
    6ee2:	19 f0       	breq	.+6      	; 0x6eea <__divsf3+0x18>
    6ee4:	c7 c0       	rjmp	.+398    	; 0x7074 <__fp_inf>
    6ee6:	51 11       	cpse	r21, r1
    6ee8:	10 c1       	rjmp	.+544    	; 0x710a <__fp_szero>
    6eea:	ca c0       	rjmp	.+404    	; 0x7080 <__fp_nan>

00006eec <__divsf3x>:
    6eec:	eb d0       	rcall	.+470    	; 0x70c4 <__fp_split3>
    6eee:	98 f3       	brcs	.-26     	; 0x6ed6 <__divsf3+0x4>

00006ef0 <__divsf3_pse>:
    6ef0:	99 23       	and	r25, r25
    6ef2:	c9 f3       	breq	.-14     	; 0x6ee6 <__divsf3+0x14>
    6ef4:	55 23       	and	r21, r21
    6ef6:	b1 f3       	breq	.-20     	; 0x6ee4 <__divsf3+0x12>
    6ef8:	95 1b       	sub	r25, r21
    6efa:	55 0b       	sbc	r21, r21
    6efc:	bb 27       	eor	r27, r27
    6efe:	aa 27       	eor	r26, r26
    6f00:	62 17       	cp	r22, r18
    6f02:	73 07       	cpc	r23, r19
    6f04:	84 07       	cpc	r24, r20
    6f06:	38 f0       	brcs	.+14     	; 0x6f16 <__divsf3_pse+0x26>
    6f08:	9f 5f       	subi	r25, 0xFF	; 255
    6f0a:	5f 4f       	sbci	r21, 0xFF	; 255
    6f0c:	22 0f       	add	r18, r18
    6f0e:	33 1f       	adc	r19, r19
    6f10:	44 1f       	adc	r20, r20
    6f12:	aa 1f       	adc	r26, r26
    6f14:	a9 f3       	breq	.-22     	; 0x6f00 <__divsf3_pse+0x10>
    6f16:	33 d0       	rcall	.+102    	; 0x6f7e <__divsf3_pse+0x8e>
    6f18:	0e 2e       	mov	r0, r30
    6f1a:	3a f0       	brmi	.+14     	; 0x6f2a <__divsf3_pse+0x3a>
    6f1c:	e0 e8       	ldi	r30, 0x80	; 128
    6f1e:	30 d0       	rcall	.+96     	; 0x6f80 <__divsf3_pse+0x90>
    6f20:	91 50       	subi	r25, 0x01	; 1
    6f22:	50 40       	sbci	r21, 0x00	; 0
    6f24:	e6 95       	lsr	r30
    6f26:	00 1c       	adc	r0, r0
    6f28:	ca f7       	brpl	.-14     	; 0x6f1c <__divsf3_pse+0x2c>
    6f2a:	29 d0       	rcall	.+82     	; 0x6f7e <__divsf3_pse+0x8e>
    6f2c:	fe 2f       	mov	r31, r30
    6f2e:	27 d0       	rcall	.+78     	; 0x6f7e <__divsf3_pse+0x8e>
    6f30:	66 0f       	add	r22, r22
    6f32:	77 1f       	adc	r23, r23
    6f34:	88 1f       	adc	r24, r24
    6f36:	bb 1f       	adc	r27, r27
    6f38:	26 17       	cp	r18, r22
    6f3a:	37 07       	cpc	r19, r23
    6f3c:	48 07       	cpc	r20, r24
    6f3e:	ab 07       	cpc	r26, r27
    6f40:	b0 e8       	ldi	r27, 0x80	; 128
    6f42:	09 f0       	breq	.+2      	; 0x6f46 <__divsf3_pse+0x56>
    6f44:	bb 0b       	sbc	r27, r27
    6f46:	80 2d       	mov	r24, r0
    6f48:	bf 01       	movw	r22, r30
    6f4a:	ff 27       	eor	r31, r31
    6f4c:	93 58       	subi	r25, 0x83	; 131
    6f4e:	5f 4f       	sbci	r21, 0xFF	; 255
    6f50:	2a f0       	brmi	.+10     	; 0x6f5c <__divsf3_pse+0x6c>
    6f52:	9e 3f       	cpi	r25, 0xFE	; 254
    6f54:	51 05       	cpc	r21, r1
    6f56:	68 f0       	brcs	.+26     	; 0x6f72 <__divsf3_pse+0x82>
    6f58:	8d c0       	rjmp	.+282    	; 0x7074 <__fp_inf>
    6f5a:	d7 c0       	rjmp	.+430    	; 0x710a <__fp_szero>
    6f5c:	5f 3f       	cpi	r21, 0xFF	; 255
    6f5e:	ec f3       	brlt	.-6      	; 0x6f5a <__divsf3_pse+0x6a>
    6f60:	98 3e       	cpi	r25, 0xE8	; 232
    6f62:	dc f3       	brlt	.-10     	; 0x6f5a <__divsf3_pse+0x6a>
    6f64:	86 95       	lsr	r24
    6f66:	77 95       	ror	r23
    6f68:	67 95       	ror	r22
    6f6a:	b7 95       	ror	r27
    6f6c:	f7 95       	ror	r31
    6f6e:	9f 5f       	subi	r25, 0xFF	; 255
    6f70:	c9 f7       	brne	.-14     	; 0x6f64 <__divsf3_pse+0x74>
    6f72:	88 0f       	add	r24, r24
    6f74:	91 1d       	adc	r25, r1
    6f76:	96 95       	lsr	r25
    6f78:	87 95       	ror	r24
    6f7a:	97 f9       	bld	r25, 7
    6f7c:	08 95       	ret
    6f7e:	e1 e0       	ldi	r30, 0x01	; 1
    6f80:	66 0f       	add	r22, r22
    6f82:	77 1f       	adc	r23, r23
    6f84:	88 1f       	adc	r24, r24
    6f86:	bb 1f       	adc	r27, r27
    6f88:	62 17       	cp	r22, r18
    6f8a:	73 07       	cpc	r23, r19
    6f8c:	84 07       	cpc	r24, r20
    6f8e:	ba 07       	cpc	r27, r26
    6f90:	20 f0       	brcs	.+8      	; 0x6f9a <__divsf3_pse+0xaa>
    6f92:	62 1b       	sub	r22, r18
    6f94:	73 0b       	sbc	r23, r19
    6f96:	84 0b       	sbc	r24, r20
    6f98:	ba 0b       	sbc	r27, r26
    6f9a:	ee 1f       	adc	r30, r30
    6f9c:	88 f7       	brcc	.-30     	; 0x6f80 <__divsf3_pse+0x90>
    6f9e:	e0 95       	com	r30
    6fa0:	08 95       	ret

00006fa2 <__fixunssfsi>:
    6fa2:	98 d0       	rcall	.+304    	; 0x70d4 <__fp_splitA>
    6fa4:	88 f0       	brcs	.+34     	; 0x6fc8 <__fixunssfsi+0x26>
    6fa6:	9f 57       	subi	r25, 0x7F	; 127
    6fa8:	90 f0       	brcs	.+36     	; 0x6fce <__fixunssfsi+0x2c>
    6faa:	b9 2f       	mov	r27, r25
    6fac:	99 27       	eor	r25, r25
    6fae:	b7 51       	subi	r27, 0x17	; 23
    6fb0:	a0 f0       	brcs	.+40     	; 0x6fda <__fixunssfsi+0x38>
    6fb2:	d1 f0       	breq	.+52     	; 0x6fe8 <__fixunssfsi+0x46>
    6fb4:	66 0f       	add	r22, r22
    6fb6:	77 1f       	adc	r23, r23
    6fb8:	88 1f       	adc	r24, r24
    6fba:	99 1f       	adc	r25, r25
    6fbc:	1a f0       	brmi	.+6      	; 0x6fc4 <__fixunssfsi+0x22>
    6fbe:	ba 95       	dec	r27
    6fc0:	c9 f7       	brne	.-14     	; 0x6fb4 <__fixunssfsi+0x12>
    6fc2:	12 c0       	rjmp	.+36     	; 0x6fe8 <__fixunssfsi+0x46>
    6fc4:	b1 30       	cpi	r27, 0x01	; 1
    6fc6:	81 f0       	breq	.+32     	; 0x6fe8 <__fixunssfsi+0x46>
    6fc8:	9f d0       	rcall	.+318    	; 0x7108 <__fp_zero>
    6fca:	b1 e0       	ldi	r27, 0x01	; 1
    6fcc:	08 95       	ret
    6fce:	9c c0       	rjmp	.+312    	; 0x7108 <__fp_zero>
    6fd0:	67 2f       	mov	r22, r23
    6fd2:	78 2f       	mov	r23, r24
    6fd4:	88 27       	eor	r24, r24
    6fd6:	b8 5f       	subi	r27, 0xF8	; 248
    6fd8:	39 f0       	breq	.+14     	; 0x6fe8 <__fixunssfsi+0x46>
    6fda:	b9 3f       	cpi	r27, 0xF9	; 249
    6fdc:	cc f3       	brlt	.-14     	; 0x6fd0 <__fixunssfsi+0x2e>
    6fde:	86 95       	lsr	r24
    6fe0:	77 95       	ror	r23
    6fe2:	67 95       	ror	r22
    6fe4:	b3 95       	inc	r27
    6fe6:	d9 f7       	brne	.-10     	; 0x6fde <__fixunssfsi+0x3c>
    6fe8:	3e f4       	brtc	.+14     	; 0x6ff8 <__fixunssfsi+0x56>
    6fea:	90 95       	com	r25
    6fec:	80 95       	com	r24
    6fee:	70 95       	com	r23
    6ff0:	61 95       	neg	r22
    6ff2:	7f 4f       	sbci	r23, 0xFF	; 255
    6ff4:	8f 4f       	sbci	r24, 0xFF	; 255
    6ff6:	9f 4f       	sbci	r25, 0xFF	; 255
    6ff8:	08 95       	ret

00006ffa <__floatunsisf>:
    6ffa:	e8 94       	clt
    6ffc:	09 c0       	rjmp	.+18     	; 0x7010 <__floatsisf+0x12>

00006ffe <__floatsisf>:
    6ffe:	97 fb       	bst	r25, 7
    7000:	3e f4       	brtc	.+14     	; 0x7010 <__floatsisf+0x12>
    7002:	90 95       	com	r25
    7004:	80 95       	com	r24
    7006:	70 95       	com	r23
    7008:	61 95       	neg	r22
    700a:	7f 4f       	sbci	r23, 0xFF	; 255
    700c:	8f 4f       	sbci	r24, 0xFF	; 255
    700e:	9f 4f       	sbci	r25, 0xFF	; 255
    7010:	99 23       	and	r25, r25
    7012:	a9 f0       	breq	.+42     	; 0x703e <__floatsisf+0x40>
    7014:	f9 2f       	mov	r31, r25
    7016:	96 e9       	ldi	r25, 0x96	; 150
    7018:	bb 27       	eor	r27, r27
    701a:	93 95       	inc	r25
    701c:	f6 95       	lsr	r31
    701e:	87 95       	ror	r24
    7020:	77 95       	ror	r23
    7022:	67 95       	ror	r22
    7024:	b7 95       	ror	r27
    7026:	f1 11       	cpse	r31, r1
    7028:	f8 cf       	rjmp	.-16     	; 0x701a <__floatsisf+0x1c>
    702a:	fa f4       	brpl	.+62     	; 0x706a <__floatsisf+0x6c>
    702c:	bb 0f       	add	r27, r27
    702e:	11 f4       	brne	.+4      	; 0x7034 <__floatsisf+0x36>
    7030:	60 ff       	sbrs	r22, 0
    7032:	1b c0       	rjmp	.+54     	; 0x706a <__floatsisf+0x6c>
    7034:	6f 5f       	subi	r22, 0xFF	; 255
    7036:	7f 4f       	sbci	r23, 0xFF	; 255
    7038:	8f 4f       	sbci	r24, 0xFF	; 255
    703a:	9f 4f       	sbci	r25, 0xFF	; 255
    703c:	16 c0       	rjmp	.+44     	; 0x706a <__floatsisf+0x6c>
    703e:	88 23       	and	r24, r24
    7040:	11 f0       	breq	.+4      	; 0x7046 <__floatsisf+0x48>
    7042:	96 e9       	ldi	r25, 0x96	; 150
    7044:	11 c0       	rjmp	.+34     	; 0x7068 <__floatsisf+0x6a>
    7046:	77 23       	and	r23, r23
    7048:	21 f0       	breq	.+8      	; 0x7052 <__floatsisf+0x54>
    704a:	9e e8       	ldi	r25, 0x8E	; 142
    704c:	87 2f       	mov	r24, r23
    704e:	76 2f       	mov	r23, r22
    7050:	05 c0       	rjmp	.+10     	; 0x705c <__floatsisf+0x5e>
    7052:	66 23       	and	r22, r22
    7054:	71 f0       	breq	.+28     	; 0x7072 <__floatsisf+0x74>
    7056:	96 e8       	ldi	r25, 0x86	; 134
    7058:	86 2f       	mov	r24, r22
    705a:	70 e0       	ldi	r23, 0x00	; 0
    705c:	60 e0       	ldi	r22, 0x00	; 0
    705e:	2a f0       	brmi	.+10     	; 0x706a <__floatsisf+0x6c>
    7060:	9a 95       	dec	r25
    7062:	66 0f       	add	r22, r22
    7064:	77 1f       	adc	r23, r23
    7066:	88 1f       	adc	r24, r24
    7068:	da f7       	brpl	.-10     	; 0x7060 <__floatsisf+0x62>
    706a:	88 0f       	add	r24, r24
    706c:	96 95       	lsr	r25
    706e:	87 95       	ror	r24
    7070:	97 f9       	bld	r25, 7
    7072:	08 95       	ret

00007074 <__fp_inf>:
    7074:	97 f9       	bld	r25, 7
    7076:	9f 67       	ori	r25, 0x7F	; 127
    7078:	80 e8       	ldi	r24, 0x80	; 128
    707a:	70 e0       	ldi	r23, 0x00	; 0
    707c:	60 e0       	ldi	r22, 0x00	; 0
    707e:	08 95       	ret

00007080 <__fp_nan>:
    7080:	9f ef       	ldi	r25, 0xFF	; 255
    7082:	80 ec       	ldi	r24, 0xC0	; 192
    7084:	08 95       	ret

00007086 <__fp_pscA>:
    7086:	00 24       	eor	r0, r0
    7088:	0a 94       	dec	r0
    708a:	16 16       	cp	r1, r22
    708c:	17 06       	cpc	r1, r23
    708e:	18 06       	cpc	r1, r24
    7090:	09 06       	cpc	r0, r25
    7092:	08 95       	ret

00007094 <__fp_pscB>:
    7094:	00 24       	eor	r0, r0
    7096:	0a 94       	dec	r0
    7098:	12 16       	cp	r1, r18
    709a:	13 06       	cpc	r1, r19
    709c:	14 06       	cpc	r1, r20
    709e:	05 06       	cpc	r0, r21
    70a0:	08 95       	ret

000070a2 <__fp_round>:
    70a2:	09 2e       	mov	r0, r25
    70a4:	03 94       	inc	r0
    70a6:	00 0c       	add	r0, r0
    70a8:	11 f4       	brne	.+4      	; 0x70ae <__fp_round+0xc>
    70aa:	88 23       	and	r24, r24
    70ac:	52 f0       	brmi	.+20     	; 0x70c2 <__fp_round+0x20>
    70ae:	bb 0f       	add	r27, r27
    70b0:	40 f4       	brcc	.+16     	; 0x70c2 <__fp_round+0x20>
    70b2:	bf 2b       	or	r27, r31
    70b4:	11 f4       	brne	.+4      	; 0x70ba <__fp_round+0x18>
    70b6:	60 ff       	sbrs	r22, 0
    70b8:	04 c0       	rjmp	.+8      	; 0x70c2 <__fp_round+0x20>
    70ba:	6f 5f       	subi	r22, 0xFF	; 255
    70bc:	7f 4f       	sbci	r23, 0xFF	; 255
    70be:	8f 4f       	sbci	r24, 0xFF	; 255
    70c0:	9f 4f       	sbci	r25, 0xFF	; 255
    70c2:	08 95       	ret

000070c4 <__fp_split3>:
    70c4:	57 fd       	sbrc	r21, 7
    70c6:	90 58       	subi	r25, 0x80	; 128
    70c8:	44 0f       	add	r20, r20
    70ca:	55 1f       	adc	r21, r21
    70cc:	59 f0       	breq	.+22     	; 0x70e4 <__fp_splitA+0x10>
    70ce:	5f 3f       	cpi	r21, 0xFF	; 255
    70d0:	71 f0       	breq	.+28     	; 0x70ee <__fp_splitA+0x1a>
    70d2:	47 95       	ror	r20

000070d4 <__fp_splitA>:
    70d4:	88 0f       	add	r24, r24
    70d6:	97 fb       	bst	r25, 7
    70d8:	99 1f       	adc	r25, r25
    70da:	61 f0       	breq	.+24     	; 0x70f4 <__fp_splitA+0x20>
    70dc:	9f 3f       	cpi	r25, 0xFF	; 255
    70de:	79 f0       	breq	.+30     	; 0x70fe <__fp_splitA+0x2a>
    70e0:	87 95       	ror	r24
    70e2:	08 95       	ret
    70e4:	12 16       	cp	r1, r18
    70e6:	13 06       	cpc	r1, r19
    70e8:	14 06       	cpc	r1, r20
    70ea:	55 1f       	adc	r21, r21
    70ec:	f2 cf       	rjmp	.-28     	; 0x70d2 <__fp_split3+0xe>
    70ee:	46 95       	lsr	r20
    70f0:	f1 df       	rcall	.-30     	; 0x70d4 <__fp_splitA>
    70f2:	08 c0       	rjmp	.+16     	; 0x7104 <__fp_splitA+0x30>
    70f4:	16 16       	cp	r1, r22
    70f6:	17 06       	cpc	r1, r23
    70f8:	18 06       	cpc	r1, r24
    70fa:	99 1f       	adc	r25, r25
    70fc:	f1 cf       	rjmp	.-30     	; 0x70e0 <__fp_splitA+0xc>
    70fe:	86 95       	lsr	r24
    7100:	71 05       	cpc	r23, r1
    7102:	61 05       	cpc	r22, r1
    7104:	08 94       	sec
    7106:	08 95       	ret

00007108 <__fp_zero>:
    7108:	e8 94       	clt

0000710a <__fp_szero>:
    710a:	bb 27       	eor	r27, r27
    710c:	66 27       	eor	r22, r22
    710e:	77 27       	eor	r23, r23
    7110:	cb 01       	movw	r24, r22
    7112:	97 f9       	bld	r25, 7
    7114:	08 95       	ret

00007116 <__gesf2>:
    7116:	03 d0       	rcall	.+6      	; 0x711e <__fp_cmp>
    7118:	08 f4       	brcc	.+2      	; 0x711c <__gesf2+0x6>
    711a:	8f ef       	ldi	r24, 0xFF	; 255
    711c:	08 95       	ret

0000711e <__fp_cmp>:
    711e:	99 0f       	add	r25, r25
    7120:	00 08       	sbc	r0, r0
    7122:	55 0f       	add	r21, r21
    7124:	aa 0b       	sbc	r26, r26
    7126:	e0 e8       	ldi	r30, 0x80	; 128
    7128:	fe ef       	ldi	r31, 0xFE	; 254
    712a:	16 16       	cp	r1, r22
    712c:	17 06       	cpc	r1, r23
    712e:	e8 07       	cpc	r30, r24
    7130:	f9 07       	cpc	r31, r25
    7132:	c0 f0       	brcs	.+48     	; 0x7164 <__fp_cmp+0x46>
    7134:	12 16       	cp	r1, r18
    7136:	13 06       	cpc	r1, r19
    7138:	e4 07       	cpc	r30, r20
    713a:	f5 07       	cpc	r31, r21
    713c:	98 f0       	brcs	.+38     	; 0x7164 <__fp_cmp+0x46>
    713e:	62 1b       	sub	r22, r18
    7140:	73 0b       	sbc	r23, r19
    7142:	84 0b       	sbc	r24, r20
    7144:	95 0b       	sbc	r25, r21
    7146:	39 f4       	brne	.+14     	; 0x7156 <__fp_cmp+0x38>
    7148:	0a 26       	eor	r0, r26
    714a:	61 f0       	breq	.+24     	; 0x7164 <__fp_cmp+0x46>
    714c:	23 2b       	or	r18, r19
    714e:	24 2b       	or	r18, r20
    7150:	25 2b       	or	r18, r21
    7152:	21 f4       	brne	.+8      	; 0x715c <__fp_cmp+0x3e>
    7154:	08 95       	ret
    7156:	0a 26       	eor	r0, r26
    7158:	09 f4       	brne	.+2      	; 0x715c <__fp_cmp+0x3e>
    715a:	a1 40       	sbci	r26, 0x01	; 1
    715c:	a6 95       	lsr	r26
    715e:	8f ef       	ldi	r24, 0xFF	; 255
    7160:	81 1d       	adc	r24, r1
    7162:	81 1d       	adc	r24, r1
    7164:	08 95       	ret

00007166 <__mulsi3>:
    7166:	62 9f       	mul	r22, r18
    7168:	d0 01       	movw	r26, r0
    716a:	73 9f       	mul	r23, r19
    716c:	f0 01       	movw	r30, r0
    716e:	82 9f       	mul	r24, r18
    7170:	e0 0d       	add	r30, r0
    7172:	f1 1d       	adc	r31, r1
    7174:	64 9f       	mul	r22, r20
    7176:	e0 0d       	add	r30, r0
    7178:	f1 1d       	adc	r31, r1
    717a:	92 9f       	mul	r25, r18
    717c:	f0 0d       	add	r31, r0
    717e:	83 9f       	mul	r24, r19
    7180:	f0 0d       	add	r31, r0
    7182:	74 9f       	mul	r23, r20
    7184:	f0 0d       	add	r31, r0
    7186:	65 9f       	mul	r22, r21
    7188:	f0 0d       	add	r31, r0
    718a:	99 27       	eor	r25, r25
    718c:	72 9f       	mul	r23, r18
    718e:	b0 0d       	add	r27, r0
    7190:	e1 1d       	adc	r30, r1
    7192:	f9 1f       	adc	r31, r25
    7194:	63 9f       	mul	r22, r19
    7196:	b0 0d       	add	r27, r0
    7198:	e1 1d       	adc	r30, r1
    719a:	f9 1f       	adc	r31, r25
    719c:	bd 01       	movw	r22, r26
    719e:	cf 01       	movw	r24, r30
    71a0:	11 24       	eor	r1, r1
    71a2:	08 95       	ret

000071a4 <__divmodhi4>:
    71a4:	97 fb       	bst	r25, 7
    71a6:	09 2e       	mov	r0, r25
    71a8:	07 26       	eor	r0, r23
    71aa:	0a d0       	rcall	.+20     	; 0x71c0 <__divmodhi4_neg1>
    71ac:	77 fd       	sbrc	r23, 7
    71ae:	04 d0       	rcall	.+8      	; 0x71b8 <__divmodhi4_neg2>
    71b0:	49 d0       	rcall	.+146    	; 0x7244 <__udivmodhi4>
    71b2:	06 d0       	rcall	.+12     	; 0x71c0 <__divmodhi4_neg1>
    71b4:	00 20       	and	r0, r0
    71b6:	1a f4       	brpl	.+6      	; 0x71be <__divmodhi4_exit>

000071b8 <__divmodhi4_neg2>:
    71b8:	70 95       	com	r23
    71ba:	61 95       	neg	r22
    71bc:	7f 4f       	sbci	r23, 0xFF	; 255

000071be <__divmodhi4_exit>:
    71be:	08 95       	ret

000071c0 <__divmodhi4_neg1>:
    71c0:	f6 f7       	brtc	.-4      	; 0x71be <__divmodhi4_exit>
    71c2:	90 95       	com	r25
    71c4:	81 95       	neg	r24
    71c6:	9f 4f       	sbci	r25, 0xFF	; 255
    71c8:	08 95       	ret

000071ca <__udivmodsi4>:
    71ca:	a1 e2       	ldi	r26, 0x21	; 33
    71cc:	1a 2e       	mov	r1, r26
    71ce:	aa 1b       	sub	r26, r26
    71d0:	bb 1b       	sub	r27, r27
    71d2:	fd 01       	movw	r30, r26
    71d4:	0d c0       	rjmp	.+26     	; 0x71f0 <__udivmodsi4_ep>

000071d6 <__udivmodsi4_loop>:
    71d6:	aa 1f       	adc	r26, r26
    71d8:	bb 1f       	adc	r27, r27
    71da:	ee 1f       	adc	r30, r30
    71dc:	ff 1f       	adc	r31, r31
    71de:	a2 17       	cp	r26, r18
    71e0:	b3 07       	cpc	r27, r19
    71e2:	e4 07       	cpc	r30, r20
    71e4:	f5 07       	cpc	r31, r21
    71e6:	20 f0       	brcs	.+8      	; 0x71f0 <__udivmodsi4_ep>
    71e8:	a2 1b       	sub	r26, r18
    71ea:	b3 0b       	sbc	r27, r19
    71ec:	e4 0b       	sbc	r30, r20
    71ee:	f5 0b       	sbc	r31, r21

000071f0 <__udivmodsi4_ep>:
    71f0:	66 1f       	adc	r22, r22
    71f2:	77 1f       	adc	r23, r23
    71f4:	88 1f       	adc	r24, r24
    71f6:	99 1f       	adc	r25, r25
    71f8:	1a 94       	dec	r1
    71fa:	69 f7       	brne	.-38     	; 0x71d6 <__udivmodsi4_loop>
    71fc:	60 95       	com	r22
    71fe:	70 95       	com	r23
    7200:	80 95       	com	r24
    7202:	90 95       	com	r25
    7204:	9b 01       	movw	r18, r22
    7206:	ac 01       	movw	r20, r24
    7208:	bd 01       	movw	r22, r26
    720a:	cf 01       	movw	r24, r30
    720c:	08 95       	ret

0000720e <__divmodsi4>:
    720e:	97 fb       	bst	r25, 7
    7210:	09 2e       	mov	r0, r25
    7212:	05 26       	eor	r0, r21
    7214:	0e d0       	rcall	.+28     	; 0x7232 <__divmodsi4_neg1>
    7216:	57 fd       	sbrc	r21, 7
    7218:	04 d0       	rcall	.+8      	; 0x7222 <__divmodsi4_neg2>
    721a:	d7 df       	rcall	.-82     	; 0x71ca <__udivmodsi4>
    721c:	0a d0       	rcall	.+20     	; 0x7232 <__divmodsi4_neg1>
    721e:	00 1c       	adc	r0, r0
    7220:	38 f4       	brcc	.+14     	; 0x7230 <__divmodsi4_exit>

00007222 <__divmodsi4_neg2>:
    7222:	50 95       	com	r21
    7224:	40 95       	com	r20
    7226:	30 95       	com	r19
    7228:	21 95       	neg	r18
    722a:	3f 4f       	sbci	r19, 0xFF	; 255
    722c:	4f 4f       	sbci	r20, 0xFF	; 255
    722e:	5f 4f       	sbci	r21, 0xFF	; 255

00007230 <__divmodsi4_exit>:
    7230:	08 95       	ret

00007232 <__divmodsi4_neg1>:
    7232:	f6 f7       	brtc	.-4      	; 0x7230 <__divmodsi4_exit>
    7234:	90 95       	com	r25
    7236:	80 95       	com	r24
    7238:	70 95       	com	r23
    723a:	61 95       	neg	r22
    723c:	7f 4f       	sbci	r23, 0xFF	; 255
    723e:	8f 4f       	sbci	r24, 0xFF	; 255
    7240:	9f 4f       	sbci	r25, 0xFF	; 255
    7242:	08 95       	ret

00007244 <__udivmodhi4>:
    7244:	aa 1b       	sub	r26, r26
    7246:	bb 1b       	sub	r27, r27
    7248:	51 e1       	ldi	r21, 0x11	; 17
    724a:	07 c0       	rjmp	.+14     	; 0x725a <__udivmodhi4_ep>

0000724c <__udivmodhi4_loop>:
    724c:	aa 1f       	adc	r26, r26
    724e:	bb 1f       	adc	r27, r27
    7250:	a6 17       	cp	r26, r22
    7252:	b7 07       	cpc	r27, r23
    7254:	10 f0       	brcs	.+4      	; 0x725a <__udivmodhi4_ep>
    7256:	a6 1b       	sub	r26, r22
    7258:	b7 0b       	sbc	r27, r23

0000725a <__udivmodhi4_ep>:
    725a:	88 1f       	adc	r24, r24
    725c:	99 1f       	adc	r25, r25
    725e:	5a 95       	dec	r21
    7260:	a9 f7       	brne	.-22     	; 0x724c <__udivmodhi4_loop>
    7262:	80 95       	com	r24
    7264:	90 95       	com	r25
    7266:	bc 01       	movw	r22, r24
    7268:	cd 01       	movw	r24, r26
    726a:	08 95       	ret

0000726c <__prologue_saves__>:
    726c:	2f 92       	push	r2
    726e:	3f 92       	push	r3
    7270:	4f 92       	push	r4
    7272:	5f 92       	push	r5
    7274:	6f 92       	push	r6
    7276:	7f 92       	push	r7
    7278:	8f 92       	push	r8
    727a:	9f 92       	push	r9
    727c:	af 92       	push	r10
    727e:	bf 92       	push	r11
    7280:	cf 92       	push	r12
    7282:	df 92       	push	r13
    7284:	ef 92       	push	r14
    7286:	ff 92       	push	r15
    7288:	0f 93       	push	r16
    728a:	1f 93       	push	r17
    728c:	cf 93       	push	r28
    728e:	df 93       	push	r29
    7290:	cd b7       	in	r28, 0x3d	; 61
    7292:	de b7       	in	r29, 0x3e	; 62
    7294:	ca 1b       	sub	r28, r26
    7296:	db 0b       	sbc	r29, r27
    7298:	cd bf       	out	0x3d, r28	; 61
    729a:	de bf       	out	0x3e, r29	; 62
    729c:	19 94       	eijmp

0000729e <__epilogue_restores__>:
    729e:	2a 88       	ldd	r2, Y+18	; 0x12
    72a0:	39 88       	ldd	r3, Y+17	; 0x11
    72a2:	48 88       	ldd	r4, Y+16	; 0x10
    72a4:	5f 84       	ldd	r5, Y+15	; 0x0f
    72a6:	6e 84       	ldd	r6, Y+14	; 0x0e
    72a8:	7d 84       	ldd	r7, Y+13	; 0x0d
    72aa:	8c 84       	ldd	r8, Y+12	; 0x0c
    72ac:	9b 84       	ldd	r9, Y+11	; 0x0b
    72ae:	aa 84       	ldd	r10, Y+10	; 0x0a
    72b0:	b9 84       	ldd	r11, Y+9	; 0x09
    72b2:	c8 84       	ldd	r12, Y+8	; 0x08
    72b4:	df 80       	ldd	r13, Y+7	; 0x07
    72b6:	ee 80       	ldd	r14, Y+6	; 0x06
    72b8:	fd 80       	ldd	r15, Y+5	; 0x05
    72ba:	0c 81       	ldd	r16, Y+4	; 0x04
    72bc:	1b 81       	ldd	r17, Y+3	; 0x03
    72be:	aa 81       	ldd	r26, Y+2	; 0x02
    72c0:	b9 81       	ldd	r27, Y+1	; 0x01
    72c2:	ce 0f       	add	r28, r30
    72c4:	d1 1d       	adc	r29, r1
    72c6:	cd bf       	out	0x3d, r28	; 61
    72c8:	de bf       	out	0x3e, r29	; 62
    72ca:	ed 01       	movw	r28, r26
    72cc:	08 95       	ret

000072ce <strcpy_P>:
    72ce:	fb 01       	movw	r30, r22
    72d0:	dc 01       	movw	r26, r24
    72d2:	05 90       	lpm	r0, Z+
    72d4:	0d 92       	st	X+, r0
    72d6:	00 20       	and	r0, r0
    72d8:	e1 f7       	brne	.-8      	; 0x72d2 <strcpy_P+0x4>
    72da:	08 95       	ret

000072dc <memmove>:
    72dc:	68 17       	cp	r22, r24
    72de:	79 07       	cpc	r23, r25
    72e0:	68 f4       	brcc	.+26     	; 0x72fc <memmove+0x20>
    72e2:	fb 01       	movw	r30, r22
    72e4:	dc 01       	movw	r26, r24
    72e6:	e4 0f       	add	r30, r20
    72e8:	f5 1f       	adc	r31, r21
    72ea:	a4 0f       	add	r26, r20
    72ec:	b5 1f       	adc	r27, r21
    72ee:	02 c0       	rjmp	.+4      	; 0x72f4 <memmove+0x18>
    72f0:	02 90       	ld	r0, -Z
    72f2:	0e 92       	st	-X, r0
    72f4:	41 50       	subi	r20, 0x01	; 1
    72f6:	50 40       	sbci	r21, 0x00	; 0
    72f8:	d8 f7       	brcc	.-10     	; 0x72f0 <memmove+0x14>
    72fa:	08 95       	ret
    72fc:	0c 94 f3 3b 	jmp	0x77e6	; 0x77e6 <memcpy>

00007300 <strcat>:
    7300:	fb 01       	movw	r30, r22
    7302:	dc 01       	movw	r26, r24
    7304:	0d 90       	ld	r0, X+
    7306:	00 20       	and	r0, r0
    7308:	e9 f7       	brne	.-6      	; 0x7304 <strcat+0x4>
    730a:	11 97       	sbiw	r26, 0x01	; 1
    730c:	01 90       	ld	r0, Z+
    730e:	0d 92       	st	X+, r0
    7310:	00 20       	and	r0, r0
    7312:	e1 f7       	brne	.-8      	; 0x730c <strcat+0xc>
    7314:	08 95       	ret

00007316 <itoa>:
    7316:	fb 01       	movw	r30, r22
    7318:	9f 01       	movw	r18, r30
    731a:	e8 94       	clt
    731c:	42 30       	cpi	r20, 0x02	; 2
    731e:	c4 f0       	brlt	.+48     	; 0x7350 <itoa+0x3a>
    7320:	45 32       	cpi	r20, 0x25	; 37
    7322:	b4 f4       	brge	.+44     	; 0x7350 <itoa+0x3a>
    7324:	4a 30       	cpi	r20, 0x0A	; 10
    7326:	29 f4       	brne	.+10     	; 0x7332 <itoa+0x1c>
    7328:	97 fb       	bst	r25, 7
    732a:	1e f4       	brtc	.+6      	; 0x7332 <itoa+0x1c>
    732c:	90 95       	com	r25
    732e:	81 95       	neg	r24
    7330:	9f 4f       	sbci	r25, 0xFF	; 255
    7332:	64 2f       	mov	r22, r20
    7334:	77 27       	eor	r23, r23
    7336:	0e 94 22 39 	call	0x7244	; 0x7244 <__udivmodhi4>
    733a:	80 5d       	subi	r24, 0xD0	; 208
    733c:	8a 33       	cpi	r24, 0x3A	; 58
    733e:	0c f0       	brlt	.+2      	; 0x7342 <itoa+0x2c>
    7340:	89 5d       	subi	r24, 0xD9	; 217
    7342:	81 93       	st	Z+, r24
    7344:	cb 01       	movw	r24, r22
    7346:	00 97       	sbiw	r24, 0x00	; 0
    7348:	a1 f7       	brne	.-24     	; 0x7332 <itoa+0x1c>
    734a:	16 f4       	brtc	.+4      	; 0x7350 <itoa+0x3a>
    734c:	5d e2       	ldi	r21, 0x2D	; 45
    734e:	51 93       	st	Z+, r21
    7350:	10 82       	st	Z, r1
    7352:	c9 01       	movw	r24, r18
    7354:	0c 94 07 3c 	jmp	0x780e	; 0x780e <strrev>

00007358 <printf>:
    7358:	cf 93       	push	r28
    735a:	df 93       	push	r29
    735c:	cd b7       	in	r28, 0x3d	; 61
    735e:	de b7       	in	r29, 0x3e	; 62
    7360:	fe 01       	movw	r30, r28
    7362:	36 96       	adiw	r30, 0x06	; 6
    7364:	61 91       	ld	r22, Z+
    7366:	71 91       	ld	r23, Z+
    7368:	80 91 b3 50 	lds	r24, 0x50B3
    736c:	90 91 b4 50 	lds	r25, 0x50B4
    7370:	af 01       	movw	r20, r30
    7372:	0e 94 e7 39 	call	0x73ce	; 0x73ce <vfprintf>
    7376:	df 91       	pop	r29
    7378:	cf 91       	pop	r28
    737a:	08 95       	ret

0000737c <sprintf>:
    737c:	0f 93       	push	r16
    737e:	1f 93       	push	r17
    7380:	cf 93       	push	r28
    7382:	df 93       	push	r29
    7384:	cd b7       	in	r28, 0x3d	; 61
    7386:	de b7       	in	r29, 0x3e	; 62
    7388:	2e 97       	sbiw	r28, 0x0e	; 14
    738a:	cd bf       	out	0x3d, r28	; 61
    738c:	de bf       	out	0x3e, r29	; 62
    738e:	0e 89       	ldd	r16, Y+22	; 0x16
    7390:	1f 89       	ldd	r17, Y+23	; 0x17
    7392:	86 e0       	ldi	r24, 0x06	; 6
    7394:	8c 83       	std	Y+4, r24	; 0x04
    7396:	09 83       	std	Y+1, r16	; 0x01
    7398:	1a 83       	std	Y+2, r17	; 0x02
    739a:	8f ef       	ldi	r24, 0xFF	; 255
    739c:	9f e7       	ldi	r25, 0x7F	; 127
    739e:	8d 83       	std	Y+5, r24	; 0x05
    73a0:	9e 83       	std	Y+6, r25	; 0x06
    73a2:	ae 01       	movw	r20, r28
    73a4:	46 5e       	subi	r20, 0xE6	; 230
    73a6:	5f 4f       	sbci	r21, 0xFF	; 255
    73a8:	ce 01       	movw	r24, r28
    73aa:	01 96       	adiw	r24, 0x01	; 1
    73ac:	68 8d       	ldd	r22, Y+24	; 0x18
    73ae:	79 8d       	ldd	r23, Y+25	; 0x19
    73b0:	0e 94 e7 39 	call	0x73ce	; 0x73ce <vfprintf>
    73b4:	ef 81       	ldd	r30, Y+7	; 0x07
    73b6:	f8 85       	ldd	r31, Y+8	; 0x08
    73b8:	e0 0f       	add	r30, r16
    73ba:	f1 1f       	adc	r31, r17
    73bc:	10 82       	st	Z, r1
    73be:	2e 96       	adiw	r28, 0x0e	; 14
    73c0:	cd bf       	out	0x3d, r28	; 61
    73c2:	de bf       	out	0x3e, r29	; 62
    73c4:	df 91       	pop	r29
    73c6:	cf 91       	pop	r28
    73c8:	1f 91       	pop	r17
    73ca:	0f 91       	pop	r16
    73cc:	08 95       	ret

000073ce <vfprintf>:
    73ce:	2f 92       	push	r2
    73d0:	3f 92       	push	r3
    73d2:	4f 92       	push	r4
    73d4:	5f 92       	push	r5
    73d6:	6f 92       	push	r6
    73d8:	7f 92       	push	r7
    73da:	8f 92       	push	r8
    73dc:	9f 92       	push	r9
    73de:	af 92       	push	r10
    73e0:	bf 92       	push	r11
    73e2:	cf 92       	push	r12
    73e4:	df 92       	push	r13
    73e6:	ef 92       	push	r14
    73e8:	ff 92       	push	r15
    73ea:	0f 93       	push	r16
    73ec:	1f 93       	push	r17
    73ee:	cf 93       	push	r28
    73f0:	df 93       	push	r29
    73f2:	cd b7       	in	r28, 0x3d	; 61
    73f4:	de b7       	in	r29, 0x3e	; 62
    73f6:	2d 97       	sbiw	r28, 0x0d	; 13
    73f8:	cd bf       	out	0x3d, r28	; 61
    73fa:	de bf       	out	0x3e, r29	; 62
    73fc:	3c 01       	movw	r6, r24
    73fe:	6c 87       	std	Y+12, r22	; 0x0c
    7400:	7d 87       	std	Y+13, r23	; 0x0d
    7402:	5a 01       	movw	r10, r20
    7404:	fc 01       	movw	r30, r24
    7406:	16 82       	std	Z+6, r1	; 0x06
    7408:	17 82       	std	Z+7, r1	; 0x07
    740a:	83 81       	ldd	r24, Z+3	; 0x03
    740c:	81 ff       	sbrs	r24, 1
    740e:	c8 c1       	rjmp	.+912    	; 0x77a0 <vfprintf+0x3d2>
    7410:	2e 01       	movw	r4, r28
    7412:	08 94       	sec
    7414:	41 1c       	adc	r4, r1
    7416:	51 1c       	adc	r5, r1
    7418:	f3 01       	movw	r30, r6
    741a:	93 81       	ldd	r25, Z+3	; 0x03
    741c:	ec 85       	ldd	r30, Y+12	; 0x0c
    741e:	fd 85       	ldd	r31, Y+13	; 0x0d
    7420:	93 fd       	sbrc	r25, 3
    7422:	85 91       	lpm	r24, Z+
    7424:	93 ff       	sbrs	r25, 3
    7426:	81 91       	ld	r24, Z+
    7428:	ec 87       	std	Y+12, r30	; 0x0c
    742a:	fd 87       	std	Y+13, r31	; 0x0d
    742c:	88 23       	and	r24, r24
    742e:	09 f4       	brne	.+2      	; 0x7432 <vfprintf+0x64>
    7430:	b3 c1       	rjmp	.+870    	; 0x7798 <vfprintf+0x3ca>
    7432:	85 32       	cpi	r24, 0x25	; 37
    7434:	41 f4       	brne	.+16     	; 0x7446 <vfprintf+0x78>
    7436:	93 fd       	sbrc	r25, 3
    7438:	85 91       	lpm	r24, Z+
    743a:	93 ff       	sbrs	r25, 3
    743c:	81 91       	ld	r24, Z+
    743e:	ec 87       	std	Y+12, r30	; 0x0c
    7440:	fd 87       	std	Y+13, r31	; 0x0d
    7442:	85 32       	cpi	r24, 0x25	; 37
    7444:	29 f4       	brne	.+10     	; 0x7450 <vfprintf+0x82>
    7446:	90 e0       	ldi	r25, 0x00	; 0
    7448:	b3 01       	movw	r22, r6
    744a:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    744e:	e4 cf       	rjmp	.-56     	; 0x7418 <vfprintf+0x4a>
    7450:	ff 24       	eor	r15, r15
    7452:	ee 24       	eor	r14, r14
    7454:	10 e0       	ldi	r17, 0x00	; 0
    7456:	10 32       	cpi	r17, 0x20	; 32
    7458:	b0 f4       	brcc	.+44     	; 0x7486 <vfprintf+0xb8>
    745a:	8b 32       	cpi	r24, 0x2B	; 43
    745c:	69 f0       	breq	.+26     	; 0x7478 <vfprintf+0xaa>
    745e:	8c 32       	cpi	r24, 0x2C	; 44
    7460:	28 f4       	brcc	.+10     	; 0x746c <vfprintf+0x9e>
    7462:	80 32       	cpi	r24, 0x20	; 32
    7464:	51 f0       	breq	.+20     	; 0x747a <vfprintf+0xac>
    7466:	83 32       	cpi	r24, 0x23	; 35
    7468:	71 f4       	brne	.+28     	; 0x7486 <vfprintf+0xb8>
    746a:	0b c0       	rjmp	.+22     	; 0x7482 <vfprintf+0xb4>
    746c:	8d 32       	cpi	r24, 0x2D	; 45
    746e:	39 f0       	breq	.+14     	; 0x747e <vfprintf+0xb0>
    7470:	80 33       	cpi	r24, 0x30	; 48
    7472:	49 f4       	brne	.+18     	; 0x7486 <vfprintf+0xb8>
    7474:	11 60       	ori	r17, 0x01	; 1
    7476:	2c c0       	rjmp	.+88     	; 0x74d0 <vfprintf+0x102>
    7478:	12 60       	ori	r17, 0x02	; 2
    747a:	14 60       	ori	r17, 0x04	; 4
    747c:	29 c0       	rjmp	.+82     	; 0x74d0 <vfprintf+0x102>
    747e:	18 60       	ori	r17, 0x08	; 8
    7480:	27 c0       	rjmp	.+78     	; 0x74d0 <vfprintf+0x102>
    7482:	10 61       	ori	r17, 0x10	; 16
    7484:	25 c0       	rjmp	.+74     	; 0x74d0 <vfprintf+0x102>
    7486:	17 fd       	sbrc	r17, 7
    7488:	2e c0       	rjmp	.+92     	; 0x74e6 <vfprintf+0x118>
    748a:	28 2f       	mov	r18, r24
    748c:	20 53       	subi	r18, 0x30	; 48
    748e:	2a 30       	cpi	r18, 0x0A	; 10
    7490:	98 f4       	brcc	.+38     	; 0x74b8 <vfprintf+0xea>
    7492:	16 ff       	sbrs	r17, 6
    7494:	08 c0       	rjmp	.+16     	; 0x74a6 <vfprintf+0xd8>
    7496:	8f 2d       	mov	r24, r15
    7498:	88 0f       	add	r24, r24
    749a:	f8 2e       	mov	r15, r24
    749c:	ff 0c       	add	r15, r15
    749e:	ff 0c       	add	r15, r15
    74a0:	f8 0e       	add	r15, r24
    74a2:	f2 0e       	add	r15, r18
    74a4:	15 c0       	rjmp	.+42     	; 0x74d0 <vfprintf+0x102>
    74a6:	8e 2d       	mov	r24, r14
    74a8:	88 0f       	add	r24, r24
    74aa:	e8 2e       	mov	r14, r24
    74ac:	ee 0c       	add	r14, r14
    74ae:	ee 0c       	add	r14, r14
    74b0:	e8 0e       	add	r14, r24
    74b2:	e2 0e       	add	r14, r18
    74b4:	10 62       	ori	r17, 0x20	; 32
    74b6:	0c c0       	rjmp	.+24     	; 0x74d0 <vfprintf+0x102>
    74b8:	8e 32       	cpi	r24, 0x2E	; 46
    74ba:	21 f4       	brne	.+8      	; 0x74c4 <vfprintf+0xf6>
    74bc:	16 fd       	sbrc	r17, 6
    74be:	6c c1       	rjmp	.+728    	; 0x7798 <vfprintf+0x3ca>
    74c0:	10 64       	ori	r17, 0x40	; 64
    74c2:	06 c0       	rjmp	.+12     	; 0x74d0 <vfprintf+0x102>
    74c4:	8c 36       	cpi	r24, 0x6C	; 108
    74c6:	11 f4       	brne	.+4      	; 0x74cc <vfprintf+0xfe>
    74c8:	10 68       	ori	r17, 0x80	; 128
    74ca:	02 c0       	rjmp	.+4      	; 0x74d0 <vfprintf+0x102>
    74cc:	88 36       	cpi	r24, 0x68	; 104
    74ce:	59 f4       	brne	.+22     	; 0x74e6 <vfprintf+0x118>
    74d0:	ec 85       	ldd	r30, Y+12	; 0x0c
    74d2:	fd 85       	ldd	r31, Y+13	; 0x0d
    74d4:	93 fd       	sbrc	r25, 3
    74d6:	85 91       	lpm	r24, Z+
    74d8:	93 ff       	sbrs	r25, 3
    74da:	81 91       	ld	r24, Z+
    74dc:	ec 87       	std	Y+12, r30	; 0x0c
    74de:	fd 87       	std	Y+13, r31	; 0x0d
    74e0:	88 23       	and	r24, r24
    74e2:	09 f0       	breq	.+2      	; 0x74e6 <vfprintf+0x118>
    74e4:	b8 cf       	rjmp	.-144    	; 0x7456 <vfprintf+0x88>
    74e6:	98 2f       	mov	r25, r24
    74e8:	95 54       	subi	r25, 0x45	; 69
    74ea:	93 30       	cpi	r25, 0x03	; 3
    74ec:	18 f0       	brcs	.+6      	; 0x74f4 <vfprintf+0x126>
    74ee:	90 52       	subi	r25, 0x20	; 32
    74f0:	93 30       	cpi	r25, 0x03	; 3
    74f2:	38 f4       	brcc	.+14     	; 0x7502 <vfprintf+0x134>
    74f4:	24 e0       	ldi	r18, 0x04	; 4
    74f6:	30 e0       	ldi	r19, 0x00	; 0
    74f8:	a2 0e       	add	r10, r18
    74fa:	b3 1e       	adc	r11, r19
    74fc:	3f e3       	ldi	r19, 0x3F	; 63
    74fe:	39 83       	std	Y+1, r19	; 0x01
    7500:	0f c0       	rjmp	.+30     	; 0x7520 <vfprintf+0x152>
    7502:	83 36       	cpi	r24, 0x63	; 99
    7504:	31 f0       	breq	.+12     	; 0x7512 <vfprintf+0x144>
    7506:	83 37       	cpi	r24, 0x73	; 115
    7508:	81 f0       	breq	.+32     	; 0x752a <vfprintf+0x15c>
    750a:	83 35       	cpi	r24, 0x53	; 83
    750c:	09 f0       	breq	.+2      	; 0x7510 <vfprintf+0x142>
    750e:	5a c0       	rjmp	.+180    	; 0x75c4 <vfprintf+0x1f6>
    7510:	22 c0       	rjmp	.+68     	; 0x7556 <vfprintf+0x188>
    7512:	f5 01       	movw	r30, r10
    7514:	80 81       	ld	r24, Z
    7516:	89 83       	std	Y+1, r24	; 0x01
    7518:	22 e0       	ldi	r18, 0x02	; 2
    751a:	30 e0       	ldi	r19, 0x00	; 0
    751c:	a2 0e       	add	r10, r18
    751e:	b3 1e       	adc	r11, r19
    7520:	21 e0       	ldi	r18, 0x01	; 1
    7522:	c2 2e       	mov	r12, r18
    7524:	d1 2c       	mov	r13, r1
    7526:	42 01       	movw	r8, r4
    7528:	14 c0       	rjmp	.+40     	; 0x7552 <vfprintf+0x184>
    752a:	92 e0       	ldi	r25, 0x02	; 2
    752c:	29 2e       	mov	r2, r25
    752e:	31 2c       	mov	r3, r1
    7530:	2a 0c       	add	r2, r10
    7532:	3b 1c       	adc	r3, r11
    7534:	f5 01       	movw	r30, r10
    7536:	80 80       	ld	r8, Z
    7538:	91 80       	ldd	r9, Z+1	; 0x01
    753a:	16 ff       	sbrs	r17, 6
    753c:	03 c0       	rjmp	.+6      	; 0x7544 <vfprintf+0x176>
    753e:	6f 2d       	mov	r22, r15
    7540:	70 e0       	ldi	r23, 0x00	; 0
    7542:	02 c0       	rjmp	.+4      	; 0x7548 <vfprintf+0x17a>
    7544:	6f ef       	ldi	r22, 0xFF	; 255
    7546:	7f ef       	ldi	r23, 0xFF	; 255
    7548:	c4 01       	movw	r24, r8
    754a:	0e 94 fc 3b 	call	0x77f8	; 0x77f8 <strnlen>
    754e:	6c 01       	movw	r12, r24
    7550:	51 01       	movw	r10, r2
    7552:	1f 77       	andi	r17, 0x7F	; 127
    7554:	15 c0       	rjmp	.+42     	; 0x7580 <vfprintf+0x1b2>
    7556:	82 e0       	ldi	r24, 0x02	; 2
    7558:	28 2e       	mov	r2, r24
    755a:	31 2c       	mov	r3, r1
    755c:	2a 0c       	add	r2, r10
    755e:	3b 1c       	adc	r3, r11
    7560:	f5 01       	movw	r30, r10
    7562:	80 80       	ld	r8, Z
    7564:	91 80       	ldd	r9, Z+1	; 0x01
    7566:	16 ff       	sbrs	r17, 6
    7568:	03 c0       	rjmp	.+6      	; 0x7570 <vfprintf+0x1a2>
    756a:	6f 2d       	mov	r22, r15
    756c:	70 e0       	ldi	r23, 0x00	; 0
    756e:	02 c0       	rjmp	.+4      	; 0x7574 <vfprintf+0x1a6>
    7570:	6f ef       	ldi	r22, 0xFF	; 255
    7572:	7f ef       	ldi	r23, 0xFF	; 255
    7574:	c4 01       	movw	r24, r8
    7576:	0e 94 e8 3b 	call	0x77d0	; 0x77d0 <strnlen_P>
    757a:	6c 01       	movw	r12, r24
    757c:	10 68       	ori	r17, 0x80	; 128
    757e:	51 01       	movw	r10, r2
    7580:	13 fd       	sbrc	r17, 3
    7582:	1c c0       	rjmp	.+56     	; 0x75bc <vfprintf+0x1ee>
    7584:	06 c0       	rjmp	.+12     	; 0x7592 <vfprintf+0x1c4>
    7586:	80 e2       	ldi	r24, 0x20	; 32
    7588:	90 e0       	ldi	r25, 0x00	; 0
    758a:	b3 01       	movw	r22, r6
    758c:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    7590:	ea 94       	dec	r14
    7592:	8e 2d       	mov	r24, r14
    7594:	90 e0       	ldi	r25, 0x00	; 0
    7596:	c8 16       	cp	r12, r24
    7598:	d9 06       	cpc	r13, r25
    759a:	a8 f3       	brcs	.-22     	; 0x7586 <vfprintf+0x1b8>
    759c:	0f c0       	rjmp	.+30     	; 0x75bc <vfprintf+0x1ee>
    759e:	f4 01       	movw	r30, r8
    75a0:	17 fd       	sbrc	r17, 7
    75a2:	85 91       	lpm	r24, Z+
    75a4:	17 ff       	sbrs	r17, 7
    75a6:	81 91       	ld	r24, Z+
    75a8:	4f 01       	movw	r8, r30
    75aa:	90 e0       	ldi	r25, 0x00	; 0
    75ac:	b3 01       	movw	r22, r6
    75ae:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    75b2:	e1 10       	cpse	r14, r1
    75b4:	ea 94       	dec	r14
    75b6:	08 94       	sec
    75b8:	c1 08       	sbc	r12, r1
    75ba:	d1 08       	sbc	r13, r1
    75bc:	c1 14       	cp	r12, r1
    75be:	d1 04       	cpc	r13, r1
    75c0:	71 f7       	brne	.-36     	; 0x759e <vfprintf+0x1d0>
    75c2:	e7 c0       	rjmp	.+462    	; 0x7792 <vfprintf+0x3c4>
    75c4:	84 36       	cpi	r24, 0x64	; 100
    75c6:	11 f0       	breq	.+4      	; 0x75cc <vfprintf+0x1fe>
    75c8:	89 36       	cpi	r24, 0x69	; 105
    75ca:	51 f5       	brne	.+84     	; 0x7620 <vfprintf+0x252>
    75cc:	f5 01       	movw	r30, r10
    75ce:	17 ff       	sbrs	r17, 7
    75d0:	07 c0       	rjmp	.+14     	; 0x75e0 <vfprintf+0x212>
    75d2:	80 81       	ld	r24, Z
    75d4:	91 81       	ldd	r25, Z+1	; 0x01
    75d6:	a2 81       	ldd	r26, Z+2	; 0x02
    75d8:	b3 81       	ldd	r27, Z+3	; 0x03
    75da:	24 e0       	ldi	r18, 0x04	; 4
    75dc:	30 e0       	ldi	r19, 0x00	; 0
    75de:	08 c0       	rjmp	.+16     	; 0x75f0 <vfprintf+0x222>
    75e0:	80 81       	ld	r24, Z
    75e2:	91 81       	ldd	r25, Z+1	; 0x01
    75e4:	aa 27       	eor	r26, r26
    75e6:	97 fd       	sbrc	r25, 7
    75e8:	a0 95       	com	r26
    75ea:	ba 2f       	mov	r27, r26
    75ec:	22 e0       	ldi	r18, 0x02	; 2
    75ee:	30 e0       	ldi	r19, 0x00	; 0
    75f0:	a2 0e       	add	r10, r18
    75f2:	b3 1e       	adc	r11, r19
    75f4:	01 2f       	mov	r16, r17
    75f6:	0f 76       	andi	r16, 0x6F	; 111
    75f8:	b7 ff       	sbrs	r27, 7
    75fa:	08 c0       	rjmp	.+16     	; 0x760c <vfprintf+0x23e>
    75fc:	b0 95       	com	r27
    75fe:	a0 95       	com	r26
    7600:	90 95       	com	r25
    7602:	81 95       	neg	r24
    7604:	9f 4f       	sbci	r25, 0xFF	; 255
    7606:	af 4f       	sbci	r26, 0xFF	; 255
    7608:	bf 4f       	sbci	r27, 0xFF	; 255
    760a:	00 68       	ori	r16, 0x80	; 128
    760c:	bc 01       	movw	r22, r24
    760e:	cd 01       	movw	r24, r26
    7610:	a2 01       	movw	r20, r4
    7612:	2a e0       	ldi	r18, 0x0A	; 10
    7614:	30 e0       	ldi	r19, 0x00	; 0
    7616:	0e 94 43 3c 	call	0x7886	; 0x7886 <__ultoa_invert>
    761a:	d8 2e       	mov	r13, r24
    761c:	d4 18       	sub	r13, r4
    761e:	3f c0       	rjmp	.+126    	; 0x769e <vfprintf+0x2d0>
    7620:	85 37       	cpi	r24, 0x75	; 117
    7622:	21 f4       	brne	.+8      	; 0x762c <vfprintf+0x25e>
    7624:	1f 7e       	andi	r17, 0xEF	; 239
    7626:	2a e0       	ldi	r18, 0x0A	; 10
    7628:	30 e0       	ldi	r19, 0x00	; 0
    762a:	20 c0       	rjmp	.+64     	; 0x766c <vfprintf+0x29e>
    762c:	19 7f       	andi	r17, 0xF9	; 249
    762e:	8f 36       	cpi	r24, 0x6F	; 111
    7630:	a9 f0       	breq	.+42     	; 0x765c <vfprintf+0x28e>
    7632:	80 37       	cpi	r24, 0x70	; 112
    7634:	20 f4       	brcc	.+8      	; 0x763e <vfprintf+0x270>
    7636:	88 35       	cpi	r24, 0x58	; 88
    7638:	09 f0       	breq	.+2      	; 0x763c <vfprintf+0x26e>
    763a:	ae c0       	rjmp	.+348    	; 0x7798 <vfprintf+0x3ca>
    763c:	0b c0       	rjmp	.+22     	; 0x7654 <vfprintf+0x286>
    763e:	80 37       	cpi	r24, 0x70	; 112
    7640:	21 f0       	breq	.+8      	; 0x764a <vfprintf+0x27c>
    7642:	88 37       	cpi	r24, 0x78	; 120
    7644:	09 f0       	breq	.+2      	; 0x7648 <vfprintf+0x27a>
    7646:	a8 c0       	rjmp	.+336    	; 0x7798 <vfprintf+0x3ca>
    7648:	01 c0       	rjmp	.+2      	; 0x764c <vfprintf+0x27e>
    764a:	10 61       	ori	r17, 0x10	; 16
    764c:	14 ff       	sbrs	r17, 4
    764e:	09 c0       	rjmp	.+18     	; 0x7662 <vfprintf+0x294>
    7650:	14 60       	ori	r17, 0x04	; 4
    7652:	07 c0       	rjmp	.+14     	; 0x7662 <vfprintf+0x294>
    7654:	14 ff       	sbrs	r17, 4
    7656:	08 c0       	rjmp	.+16     	; 0x7668 <vfprintf+0x29a>
    7658:	16 60       	ori	r17, 0x06	; 6
    765a:	06 c0       	rjmp	.+12     	; 0x7668 <vfprintf+0x29a>
    765c:	28 e0       	ldi	r18, 0x08	; 8
    765e:	30 e0       	ldi	r19, 0x00	; 0
    7660:	05 c0       	rjmp	.+10     	; 0x766c <vfprintf+0x29e>
    7662:	20 e1       	ldi	r18, 0x10	; 16
    7664:	30 e0       	ldi	r19, 0x00	; 0
    7666:	02 c0       	rjmp	.+4      	; 0x766c <vfprintf+0x29e>
    7668:	20 e1       	ldi	r18, 0x10	; 16
    766a:	32 e0       	ldi	r19, 0x02	; 2
    766c:	f5 01       	movw	r30, r10
    766e:	17 ff       	sbrs	r17, 7
    7670:	07 c0       	rjmp	.+14     	; 0x7680 <vfprintf+0x2b2>
    7672:	60 81       	ld	r22, Z
    7674:	71 81       	ldd	r23, Z+1	; 0x01
    7676:	82 81       	ldd	r24, Z+2	; 0x02
    7678:	93 81       	ldd	r25, Z+3	; 0x03
    767a:	44 e0       	ldi	r20, 0x04	; 4
    767c:	50 e0       	ldi	r21, 0x00	; 0
    767e:	06 c0       	rjmp	.+12     	; 0x768c <vfprintf+0x2be>
    7680:	60 81       	ld	r22, Z
    7682:	71 81       	ldd	r23, Z+1	; 0x01
    7684:	80 e0       	ldi	r24, 0x00	; 0
    7686:	90 e0       	ldi	r25, 0x00	; 0
    7688:	42 e0       	ldi	r20, 0x02	; 2
    768a:	50 e0       	ldi	r21, 0x00	; 0
    768c:	a4 0e       	add	r10, r20
    768e:	b5 1e       	adc	r11, r21
    7690:	a2 01       	movw	r20, r4
    7692:	0e 94 43 3c 	call	0x7886	; 0x7886 <__ultoa_invert>
    7696:	d8 2e       	mov	r13, r24
    7698:	d4 18       	sub	r13, r4
    769a:	01 2f       	mov	r16, r17
    769c:	0f 77       	andi	r16, 0x7F	; 127
    769e:	06 ff       	sbrs	r16, 6
    76a0:	09 c0       	rjmp	.+18     	; 0x76b4 <vfprintf+0x2e6>
    76a2:	0e 7f       	andi	r16, 0xFE	; 254
    76a4:	df 14       	cp	r13, r15
    76a6:	30 f4       	brcc	.+12     	; 0x76b4 <vfprintf+0x2e6>
    76a8:	04 ff       	sbrs	r16, 4
    76aa:	06 c0       	rjmp	.+12     	; 0x76b8 <vfprintf+0x2ea>
    76ac:	02 fd       	sbrc	r16, 2
    76ae:	04 c0       	rjmp	.+8      	; 0x76b8 <vfprintf+0x2ea>
    76b0:	0f 7e       	andi	r16, 0xEF	; 239
    76b2:	02 c0       	rjmp	.+4      	; 0x76b8 <vfprintf+0x2ea>
    76b4:	1d 2d       	mov	r17, r13
    76b6:	01 c0       	rjmp	.+2      	; 0x76ba <vfprintf+0x2ec>
    76b8:	1f 2d       	mov	r17, r15
    76ba:	80 2f       	mov	r24, r16
    76bc:	90 e0       	ldi	r25, 0x00	; 0
    76be:	04 ff       	sbrs	r16, 4
    76c0:	0c c0       	rjmp	.+24     	; 0x76da <vfprintf+0x30c>
    76c2:	fe 01       	movw	r30, r28
    76c4:	ed 0d       	add	r30, r13
    76c6:	f1 1d       	adc	r31, r1
    76c8:	20 81       	ld	r18, Z
    76ca:	20 33       	cpi	r18, 0x30	; 48
    76cc:	11 f4       	brne	.+4      	; 0x76d2 <vfprintf+0x304>
    76ce:	09 7e       	andi	r16, 0xE9	; 233
    76d0:	09 c0       	rjmp	.+18     	; 0x76e4 <vfprintf+0x316>
    76d2:	02 ff       	sbrs	r16, 2
    76d4:	06 c0       	rjmp	.+12     	; 0x76e2 <vfprintf+0x314>
    76d6:	1e 5f       	subi	r17, 0xFE	; 254
    76d8:	05 c0       	rjmp	.+10     	; 0x76e4 <vfprintf+0x316>
    76da:	86 78       	andi	r24, 0x86	; 134
    76dc:	90 70       	andi	r25, 0x00	; 0
    76de:	00 97       	sbiw	r24, 0x00	; 0
    76e0:	09 f0       	breq	.+2      	; 0x76e4 <vfprintf+0x316>
    76e2:	1f 5f       	subi	r17, 0xFF	; 255
    76e4:	80 2e       	mov	r8, r16
    76e6:	99 24       	eor	r9, r9
    76e8:	03 fd       	sbrc	r16, 3
    76ea:	12 c0       	rjmp	.+36     	; 0x7710 <vfprintf+0x342>
    76ec:	00 ff       	sbrs	r16, 0
    76ee:	0d c0       	rjmp	.+26     	; 0x770a <vfprintf+0x33c>
    76f0:	fd 2c       	mov	r15, r13
    76f2:	1e 15       	cp	r17, r14
    76f4:	50 f4       	brcc	.+20     	; 0x770a <vfprintf+0x33c>
    76f6:	fe 0c       	add	r15, r14
    76f8:	f1 1a       	sub	r15, r17
    76fa:	1e 2d       	mov	r17, r14
    76fc:	06 c0       	rjmp	.+12     	; 0x770a <vfprintf+0x33c>
    76fe:	80 e2       	ldi	r24, 0x20	; 32
    7700:	90 e0       	ldi	r25, 0x00	; 0
    7702:	b3 01       	movw	r22, r6
    7704:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    7708:	1f 5f       	subi	r17, 0xFF	; 255
    770a:	1e 15       	cp	r17, r14
    770c:	c0 f3       	brcs	.-16     	; 0x76fe <vfprintf+0x330>
    770e:	04 c0       	rjmp	.+8      	; 0x7718 <vfprintf+0x34a>
    7710:	1e 15       	cp	r17, r14
    7712:	10 f4       	brcc	.+4      	; 0x7718 <vfprintf+0x34a>
    7714:	e1 1a       	sub	r14, r17
    7716:	01 c0       	rjmp	.+2      	; 0x771a <vfprintf+0x34c>
    7718:	ee 24       	eor	r14, r14
    771a:	84 fe       	sbrs	r8, 4
    771c:	0f c0       	rjmp	.+30     	; 0x773c <vfprintf+0x36e>
    771e:	80 e3       	ldi	r24, 0x30	; 48
    7720:	90 e0       	ldi	r25, 0x00	; 0
    7722:	b3 01       	movw	r22, r6
    7724:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    7728:	82 fe       	sbrs	r8, 2
    772a:	1f c0       	rjmp	.+62     	; 0x776a <vfprintf+0x39c>
    772c:	81 fe       	sbrs	r8, 1
    772e:	03 c0       	rjmp	.+6      	; 0x7736 <vfprintf+0x368>
    7730:	88 e5       	ldi	r24, 0x58	; 88
    7732:	90 e0       	ldi	r25, 0x00	; 0
    7734:	10 c0       	rjmp	.+32     	; 0x7756 <vfprintf+0x388>
    7736:	88 e7       	ldi	r24, 0x78	; 120
    7738:	90 e0       	ldi	r25, 0x00	; 0
    773a:	0d c0       	rjmp	.+26     	; 0x7756 <vfprintf+0x388>
    773c:	c4 01       	movw	r24, r8
    773e:	86 78       	andi	r24, 0x86	; 134
    7740:	90 70       	andi	r25, 0x00	; 0
    7742:	00 97       	sbiw	r24, 0x00	; 0
    7744:	91 f0       	breq	.+36     	; 0x776a <vfprintf+0x39c>
    7746:	81 fc       	sbrc	r8, 1
    7748:	02 c0       	rjmp	.+4      	; 0x774e <vfprintf+0x380>
    774a:	80 e2       	ldi	r24, 0x20	; 32
    774c:	01 c0       	rjmp	.+2      	; 0x7750 <vfprintf+0x382>
    774e:	8b e2       	ldi	r24, 0x2B	; 43
    7750:	07 fd       	sbrc	r16, 7
    7752:	8d e2       	ldi	r24, 0x2D	; 45
    7754:	90 e0       	ldi	r25, 0x00	; 0
    7756:	b3 01       	movw	r22, r6
    7758:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    775c:	06 c0       	rjmp	.+12     	; 0x776a <vfprintf+0x39c>
    775e:	80 e3       	ldi	r24, 0x30	; 48
    7760:	90 e0       	ldi	r25, 0x00	; 0
    7762:	b3 01       	movw	r22, r6
    7764:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    7768:	fa 94       	dec	r15
    776a:	df 14       	cp	r13, r15
    776c:	c0 f3       	brcs	.-16     	; 0x775e <vfprintf+0x390>
    776e:	da 94       	dec	r13
    7770:	f2 01       	movw	r30, r4
    7772:	ed 0d       	add	r30, r13
    7774:	f1 1d       	adc	r31, r1
    7776:	80 81       	ld	r24, Z
    7778:	90 e0       	ldi	r25, 0x00	; 0
    777a:	b3 01       	movw	r22, r6
    777c:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    7780:	dd 20       	and	r13, r13
    7782:	a9 f7       	brne	.-22     	; 0x776e <vfprintf+0x3a0>
    7784:	06 c0       	rjmp	.+12     	; 0x7792 <vfprintf+0x3c4>
    7786:	80 e2       	ldi	r24, 0x20	; 32
    7788:	90 e0       	ldi	r25, 0x00	; 0
    778a:	b3 01       	movw	r22, r6
    778c:	0e 94 17 3c 	call	0x782e	; 0x782e <fputc>
    7790:	ea 94       	dec	r14
    7792:	ee 20       	and	r14, r14
    7794:	c1 f7       	brne	.-16     	; 0x7786 <vfprintf+0x3b8>
    7796:	40 ce       	rjmp	.-896    	; 0x7418 <vfprintf+0x4a>
    7798:	f3 01       	movw	r30, r6
    779a:	86 81       	ldd	r24, Z+6	; 0x06
    779c:	97 81       	ldd	r25, Z+7	; 0x07
    779e:	02 c0       	rjmp	.+4      	; 0x77a4 <vfprintf+0x3d6>
    77a0:	8f ef       	ldi	r24, 0xFF	; 255
    77a2:	9f ef       	ldi	r25, 0xFF	; 255
    77a4:	2d 96       	adiw	r28, 0x0d	; 13
    77a6:	cd bf       	out	0x3d, r28	; 61
    77a8:	de bf       	out	0x3e, r29	; 62
    77aa:	df 91       	pop	r29
    77ac:	cf 91       	pop	r28
    77ae:	1f 91       	pop	r17
    77b0:	0f 91       	pop	r16
    77b2:	ff 90       	pop	r15
    77b4:	ef 90       	pop	r14
    77b6:	df 90       	pop	r13
    77b8:	cf 90       	pop	r12
    77ba:	bf 90       	pop	r11
    77bc:	af 90       	pop	r10
    77be:	9f 90       	pop	r9
    77c0:	8f 90       	pop	r8
    77c2:	7f 90       	pop	r7
    77c4:	6f 90       	pop	r6
    77c6:	5f 90       	pop	r5
    77c8:	4f 90       	pop	r4
    77ca:	3f 90       	pop	r3
    77cc:	2f 90       	pop	r2
    77ce:	08 95       	ret

000077d0 <strnlen_P>:
    77d0:	fc 01       	movw	r30, r24
    77d2:	05 90       	lpm	r0, Z+
    77d4:	61 50       	subi	r22, 0x01	; 1
    77d6:	70 40       	sbci	r23, 0x00	; 0
    77d8:	01 10       	cpse	r0, r1
    77da:	d8 f7       	brcc	.-10     	; 0x77d2 <strnlen_P+0x2>
    77dc:	80 95       	com	r24
    77de:	90 95       	com	r25
    77e0:	8e 0f       	add	r24, r30
    77e2:	9f 1f       	adc	r25, r31
    77e4:	08 95       	ret

000077e6 <memcpy>:
    77e6:	fb 01       	movw	r30, r22
    77e8:	dc 01       	movw	r26, r24
    77ea:	02 c0       	rjmp	.+4      	; 0x77f0 <memcpy+0xa>
    77ec:	01 90       	ld	r0, Z+
    77ee:	0d 92       	st	X+, r0
    77f0:	41 50       	subi	r20, 0x01	; 1
    77f2:	50 40       	sbci	r21, 0x00	; 0
    77f4:	d8 f7       	brcc	.-10     	; 0x77ec <memcpy+0x6>
    77f6:	08 95       	ret

000077f8 <strnlen>:
    77f8:	fc 01       	movw	r30, r24
    77fa:	61 50       	subi	r22, 0x01	; 1
    77fc:	70 40       	sbci	r23, 0x00	; 0
    77fe:	01 90       	ld	r0, Z+
    7800:	01 10       	cpse	r0, r1
    7802:	d8 f7       	brcc	.-10     	; 0x77fa <strnlen+0x2>
    7804:	80 95       	com	r24
    7806:	90 95       	com	r25
    7808:	8e 0f       	add	r24, r30
    780a:	9f 1f       	adc	r25, r31
    780c:	08 95       	ret

0000780e <strrev>:
    780e:	dc 01       	movw	r26, r24
    7810:	fc 01       	movw	r30, r24
    7812:	67 2f       	mov	r22, r23
    7814:	71 91       	ld	r23, Z+
    7816:	77 23       	and	r23, r23
    7818:	e1 f7       	brne	.-8      	; 0x7812 <strrev+0x4>
    781a:	32 97       	sbiw	r30, 0x02	; 2
    781c:	04 c0       	rjmp	.+8      	; 0x7826 <strrev+0x18>
    781e:	7c 91       	ld	r23, X
    7820:	6d 93       	st	X+, r22
    7822:	70 83       	st	Z, r23
    7824:	62 91       	ld	r22, -Z
    7826:	ae 17       	cp	r26, r30
    7828:	bf 07       	cpc	r27, r31
    782a:	c8 f3       	brcs	.-14     	; 0x781e <strrev+0x10>
    782c:	08 95       	ret

0000782e <fputc>:
    782e:	0f 93       	push	r16
    7830:	1f 93       	push	r17
    7832:	cf 93       	push	r28
    7834:	df 93       	push	r29
    7836:	8c 01       	movw	r16, r24
    7838:	eb 01       	movw	r28, r22
    783a:	8b 81       	ldd	r24, Y+3	; 0x03
    783c:	81 ff       	sbrs	r24, 1
    783e:	1b c0       	rjmp	.+54     	; 0x7876 <fputc+0x48>
    7840:	82 ff       	sbrs	r24, 2
    7842:	0d c0       	rjmp	.+26     	; 0x785e <fputc+0x30>
    7844:	2e 81       	ldd	r18, Y+6	; 0x06
    7846:	3f 81       	ldd	r19, Y+7	; 0x07
    7848:	8c 81       	ldd	r24, Y+4	; 0x04
    784a:	9d 81       	ldd	r25, Y+5	; 0x05
    784c:	28 17       	cp	r18, r24
    784e:	39 07       	cpc	r19, r25
    7850:	64 f4       	brge	.+24     	; 0x786a <fputc+0x3c>
    7852:	e8 81       	ld	r30, Y
    7854:	f9 81       	ldd	r31, Y+1	; 0x01
    7856:	01 93       	st	Z+, r16
    7858:	e8 83       	st	Y, r30
    785a:	f9 83       	std	Y+1, r31	; 0x01
    785c:	06 c0       	rjmp	.+12     	; 0x786a <fputc+0x3c>
    785e:	e8 85       	ldd	r30, Y+8	; 0x08
    7860:	f9 85       	ldd	r31, Y+9	; 0x09
    7862:	80 2f       	mov	r24, r16
    7864:	19 95       	eicall
    7866:	00 97       	sbiw	r24, 0x00	; 0
    7868:	31 f4       	brne	.+12     	; 0x7876 <fputc+0x48>
    786a:	8e 81       	ldd	r24, Y+6	; 0x06
    786c:	9f 81       	ldd	r25, Y+7	; 0x07
    786e:	01 96       	adiw	r24, 0x01	; 1
    7870:	8e 83       	std	Y+6, r24	; 0x06
    7872:	9f 83       	std	Y+7, r25	; 0x07
    7874:	02 c0       	rjmp	.+4      	; 0x787a <fputc+0x4c>
    7876:	0f ef       	ldi	r16, 0xFF	; 255
    7878:	1f ef       	ldi	r17, 0xFF	; 255
    787a:	c8 01       	movw	r24, r16
    787c:	df 91       	pop	r29
    787e:	cf 91       	pop	r28
    7880:	1f 91       	pop	r17
    7882:	0f 91       	pop	r16
    7884:	08 95       	ret

00007886 <__ultoa_invert>:
    7886:	fa 01       	movw	r30, r20
    7888:	aa 27       	eor	r26, r26
    788a:	28 30       	cpi	r18, 0x08	; 8
    788c:	51 f1       	breq	.+84     	; 0x78e2 <__ultoa_invert+0x5c>
    788e:	20 31       	cpi	r18, 0x10	; 16
    7890:	81 f1       	breq	.+96     	; 0x78f2 <__ultoa_invert+0x6c>
    7892:	e8 94       	clt
    7894:	6f 93       	push	r22
    7896:	6e 7f       	andi	r22, 0xFE	; 254
    7898:	6e 5f       	subi	r22, 0xFE	; 254
    789a:	7f 4f       	sbci	r23, 0xFF	; 255
    789c:	8f 4f       	sbci	r24, 0xFF	; 255
    789e:	9f 4f       	sbci	r25, 0xFF	; 255
    78a0:	af 4f       	sbci	r26, 0xFF	; 255
    78a2:	b1 e0       	ldi	r27, 0x01	; 1
    78a4:	3e d0       	rcall	.+124    	; 0x7922 <__ultoa_invert+0x9c>
    78a6:	b4 e0       	ldi	r27, 0x04	; 4
    78a8:	3c d0       	rcall	.+120    	; 0x7922 <__ultoa_invert+0x9c>
    78aa:	67 0f       	add	r22, r23
    78ac:	78 1f       	adc	r23, r24
    78ae:	89 1f       	adc	r24, r25
    78b0:	9a 1f       	adc	r25, r26
    78b2:	a1 1d       	adc	r26, r1
    78b4:	68 0f       	add	r22, r24
    78b6:	79 1f       	adc	r23, r25
    78b8:	8a 1f       	adc	r24, r26
    78ba:	91 1d       	adc	r25, r1
    78bc:	a1 1d       	adc	r26, r1
    78be:	6a 0f       	add	r22, r26
    78c0:	71 1d       	adc	r23, r1
    78c2:	81 1d       	adc	r24, r1
    78c4:	91 1d       	adc	r25, r1
    78c6:	a1 1d       	adc	r26, r1
    78c8:	20 d0       	rcall	.+64     	; 0x790a <__ultoa_invert+0x84>
    78ca:	09 f4       	brne	.+2      	; 0x78ce <__ultoa_invert+0x48>
    78cc:	68 94       	set
    78ce:	3f 91       	pop	r19
    78d0:	2a e0       	ldi	r18, 0x0A	; 10
    78d2:	26 9f       	mul	r18, r22
    78d4:	11 24       	eor	r1, r1
    78d6:	30 19       	sub	r19, r0
    78d8:	30 5d       	subi	r19, 0xD0	; 208
    78da:	31 93       	st	Z+, r19
    78dc:	de f6       	brtc	.-74     	; 0x7894 <__ultoa_invert+0xe>
    78de:	cf 01       	movw	r24, r30
    78e0:	08 95       	ret
    78e2:	46 2f       	mov	r20, r22
    78e4:	47 70       	andi	r20, 0x07	; 7
    78e6:	40 5d       	subi	r20, 0xD0	; 208
    78e8:	41 93       	st	Z+, r20
    78ea:	b3 e0       	ldi	r27, 0x03	; 3
    78ec:	0f d0       	rcall	.+30     	; 0x790c <__ultoa_invert+0x86>
    78ee:	c9 f7       	brne	.-14     	; 0x78e2 <__ultoa_invert+0x5c>
    78f0:	f6 cf       	rjmp	.-20     	; 0x78de <__ultoa_invert+0x58>
    78f2:	46 2f       	mov	r20, r22
    78f4:	4f 70       	andi	r20, 0x0F	; 15
    78f6:	40 5d       	subi	r20, 0xD0	; 208
    78f8:	4a 33       	cpi	r20, 0x3A	; 58
    78fa:	18 f0       	brcs	.+6      	; 0x7902 <__ultoa_invert+0x7c>
    78fc:	49 5d       	subi	r20, 0xD9	; 217
    78fe:	31 fd       	sbrc	r19, 1
    7900:	40 52       	subi	r20, 0x20	; 32
    7902:	41 93       	st	Z+, r20
    7904:	02 d0       	rcall	.+4      	; 0x790a <__ultoa_invert+0x84>
    7906:	a9 f7       	brne	.-22     	; 0x78f2 <__ultoa_invert+0x6c>
    7908:	ea cf       	rjmp	.-44     	; 0x78de <__ultoa_invert+0x58>
    790a:	b4 e0       	ldi	r27, 0x04	; 4
    790c:	a6 95       	lsr	r26
    790e:	97 95       	ror	r25
    7910:	87 95       	ror	r24
    7912:	77 95       	ror	r23
    7914:	67 95       	ror	r22
    7916:	ba 95       	dec	r27
    7918:	c9 f7       	brne	.-14     	; 0x790c <__ultoa_invert+0x86>
    791a:	00 97       	sbiw	r24, 0x00	; 0
    791c:	61 05       	cpc	r22, r1
    791e:	71 05       	cpc	r23, r1
    7920:	08 95       	ret
    7922:	9b 01       	movw	r18, r22
    7924:	ac 01       	movw	r20, r24
    7926:	0a 2e       	mov	r0, r26
    7928:	06 94       	lsr	r0
    792a:	57 95       	ror	r21
    792c:	47 95       	ror	r20
    792e:	37 95       	ror	r19
    7930:	27 95       	ror	r18
    7932:	ba 95       	dec	r27
    7934:	c9 f7       	brne	.-14     	; 0x7928 <__ultoa_invert+0xa2>
    7936:	62 0f       	add	r22, r18
    7938:	73 1f       	adc	r23, r19
    793a:	84 1f       	adc	r24, r20
    793c:	95 1f       	adc	r25, r21
    793e:	a0 1d       	adc	r26, r0
    7940:	08 95       	ret

00007942 <_exit>:
    7942:	f8 94       	cli

00007944 <__stop_program>:
    7944:	ff cf       	rjmp	.-2      	; 0x7944 <__stop_program>
