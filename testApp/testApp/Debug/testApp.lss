
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000caf2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000126  00802000  0000caf2  0000cb86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00003205  00802126  00802126  0000ccac  2**0
                  ALLOC
  3 .stab         00002718  00000000  00000000  0000ccac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2a  00000000  00000000  0000f3c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  0000fdf0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cac5  00000000  00000000  000101b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021d6  00000000  00000000  0001cc75  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e93  00000000  00000000  0001ee4b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bbc  00000000  00000000  00022ce0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000455c  00000000  00000000  0002489c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006102  00000000  00000000  00028df8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  0002eefa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 3b 10 	jmp	0x2076	; 0x2076 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 4f 0f 	jmp	0x1e9e	; 0x1e9e <__vector_16>
      44:	0c 94 7f 0f 	jmp	0x1efe	; 0x1efe <__vector_17>
      48:	0c 94 af 0f 	jmp	0x1f5e	; 0x1f5e <__vector_18>
      4c:	0c 94 df 0f 	jmp	0x1fbe	; 0x1fbe <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 9f 3d 	jmp	0x7b3e	; 0x7b3e <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 63 2d 	jmp	0x5ac6	; 0x5ac6 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 e4 12 	jmp	0x25c8	; 0x25c8 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 22 12 	jmp	0x2444	; 0x2444 <__vector_79>
     140:	0c 94 52 12 	jmp	0x24a4	; 0x24a4 <__vector_80>
     144:	0c 94 82 12 	jmp	0x2504	; 0x2504 <__vector_81>
     148:	0c 94 b2 12 	jmp	0x2564	; 0x2564 <__vector_82>
     14c:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__vector_104>
     1a4:	0c 94 1a 0a 	jmp	0x1434	; 0x1434 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e2 ef       	ldi	r30, 0xF2	; 242
     244:	fa ec       	ldi	r31, 0xCA	; 202
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a6 32       	cpi	r26, 0x26	; 38
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	13 e5       	ldi	r17, 0x53	; 83
     258:	a6 e2       	ldi	r26, 0x26	; 38
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ab 32       	cpi	r26, 0x2B	; 43
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 8e 50 	call	0xa11c	; 0xa11c <main>
     26a:	0c 94 77 65 	jmp	0xcaee	; 0xcaee <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	0f 92       	push	r0
     278:	0f 92       	push	r0
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
     27e:	89 83       	std	Y+1, r24	; 0x01
     280:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     282:	81 e0       	ldi	r24, 0x01	; 1
     284:	80 93 c5 50 	sts	0x50C5, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     288:	83 e0       	ldi	r24, 0x03	; 3
     28a:	80 93 53 40 	sts	0x4053, r24
	chb_init();
     28e:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <chb_init>
	chb_set_short_addr(moteID);
     292:	80 91 c5 50 	lds	r24, 0x50C5
     296:	88 2f       	mov	r24, r24
     298:	90 e0       	ldi	r25, 0x00	; 0
     29a:	0e 94 22 2b 	call	0x5644	; 0x5644 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     29e:	80 e8       	ldi	r24, 0x80	; 128
     2a0:	91 e0       	ldi	r25, 0x01	; 1
     2a2:	28 ec       	ldi	r18, 0xC8	; 200
     2a4:	fc 01       	movw	r30, r24
     2a6:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     2a8:	80 e4       	ldi	r24, 0x40	; 64
     2aa:	99 e0       	ldi	r25, 0x09	; 9
     2ac:	29 e0       	ldi	r18, 0x09	; 9
     2ae:	fc 01       	movw	r30, r24
     2b0:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     2b2:	80 e4       	ldi	r24, 0x40	; 64
     2b4:	99 e0       	ldi	r25, 0x09	; 9
     2b6:	22 e0       	ldi	r18, 0x02	; 2
     2b8:	fc 01       	movw	r30, r24
     2ba:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     2bc:	80 e4       	ldi	r24, 0x40	; 64
     2be:	99 e0       	ldi	r25, 0x09	; 9
     2c0:	69 81       	ldd	r22, Y+1	; 0x01
     2c2:	7a 81       	ldd	r23, Y+2	; 0x02
     2c4:	44 ef       	ldi	r20, 0xF4	; 244
     2c6:	51 e0       	ldi	r21, 0x01	; 1
     2c8:	64 9f       	mul	r22, r20
     2ca:	90 01       	movw	r18, r0
     2cc:	65 9f       	mul	r22, r21
     2ce:	30 0d       	add	r19, r0
     2d0:	74 9f       	mul	r23, r20
     2d2:	30 0d       	add	r19, r0
     2d4:	11 24       	eor	r1, r1
     2d6:	fc 01       	movw	r30, r24
     2d8:	26 a3       	lds	r18, 0x56
     2da:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     2dc:	80 e4       	ldi	r24, 0x40	; 64
     2de:	98 e0       	ldi	r25, 0x08	; 8
     2e0:	20 e0       	ldi	r18, 0x00	; 0
     2e2:	3a ef       	ldi	r19, 0xFA	; 250
     2e4:	fc 01       	movw	r30, r24
     2e6:	26 a3       	lds	r18, 0x56
     2e8:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     2ea:	80 e4       	ldi	r24, 0x40	; 64
     2ec:	98 e0       	ldi	r25, 0x08	; 8
     2ee:	21 e0       	ldi	r18, 0x01	; 1
     2f0:	fc 01       	movw	r30, r24
     2f2:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     2f4:	80 e4       	ldi	r24, 0x40	; 64
     2f6:	98 e0       	ldi	r25, 0x08	; 8
     2f8:	21 e0       	ldi	r18, 0x01	; 1
     2fa:	fc 01       	movw	r30, r24
     2fc:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     2fe:	80 ea       	ldi	r24, 0xA0	; 160
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	20 ea       	ldi	r18, 0xA0	; 160
     304:	30 e0       	ldi	r19, 0x00	; 0
     306:	f9 01       	movw	r30, r18
     308:	22 81       	ldd	r18, Z+2	; 0x02
     30a:	27 60       	ori	r18, 0x07	; 7
     30c:	fc 01       	movw	r30, r24
     30e:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     310:	78 94       	sei
}
     312:	0f 90       	pop	r0
     314:	0f 90       	pop	r0
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	08 95       	ret

0000031c <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     31c:	78 94       	sei
     31e:	1f 92       	push	r1
     320:	0f 92       	push	r0
     322:	0f b6       	in	r0, 0x3f	; 63
     324:	0f 92       	push	r0
     326:	00 90 3b 00 	lds	r0, 0x003B
     32a:	0f 92       	push	r0
     32c:	11 24       	eor	r1, r1
     32e:	2f 93       	push	r18
     330:	3f 93       	push	r19
     332:	4f 93       	push	r20
     334:	5f 93       	push	r21
     336:	6f 93       	push	r22
     338:	7f 93       	push	r23
     33a:	8f 93       	push	r24
     33c:	9f 93       	push	r25
     33e:	af 93       	push	r26
     340:	bf 93       	push	r27
     342:	ef 93       	push	r30
     344:	ff 93       	push	r31
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	cd b7       	in	r28, 0x3d	; 61
     34c:	de b7       	in	r29, 0x3e	; 62
     34e:	28 97       	sbiw	r28, 0x08	; 8
     350:	cd bf       	out	0x3d, r28	; 61
     352:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     354:	80 e4       	ldi	r24, 0x40	; 64
     356:	98 e0       	ldi	r25, 0x08	; 8
     358:	fc 01       	movw	r30, r24
     35a:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     35c:	80 e4       	ldi	r24, 0x40	; 64
     35e:	99 e0       	ldi	r25, 0x09	; 9
     360:	fc 01       	movw	r30, r24
     362:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     364:	82 e0       	ldi	r24, 0x02	; 2
     366:	80 93 53 40 	sts	0x4053, r24
	unsigned char message[8];
	strcpy(message,"reset");
     36a:	ce 01       	movw	r24, r28
     36c:	01 96       	adiw	r24, 0x01	; 1
     36e:	20 e0       	ldi	r18, 0x00	; 0
     370:	30 e2       	ldi	r19, 0x20	; 32
     372:	46 e0       	ldi	r20, 0x06	; 6
     374:	f9 01       	movw	r30, r18
     376:	00 80       	ld	r0, Z
     378:	2f 5f       	subi	r18, 0xFF	; 255
     37a:	3f 4f       	sbci	r19, 0xFF	; 255
     37c:	fc 01       	movw	r30, r24
     37e:	00 82       	st	Z, r0
     380:	01 96       	adiw	r24, 0x01	; 1
     382:	41 50       	subi	r20, 0x01	; 1
     384:	44 23       	and	r20, r20
     386:	b1 f7       	brne	.-20     	; 0x374 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     388:	80 91 c5 50 	lds	r24, 0x50C5
     38c:	88 2f       	mov	r24, r24
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	26 e4       	ldi	r18, 0x46	; 70
     392:	30 e4       	ldi	r19, 0x40	; 64
     394:	b9 01       	movw	r22, r18
     396:	4a e0       	ldi	r20, 0x0A	; 10
     398:	50 e0       	ldi	r21, 0x00	; 0
     39a:	0e 94 93 62 	call	0xc526	; 0xc526 <itoa>
	strcat(message,buff);
     39e:	26 e4       	ldi	r18, 0x46	; 70
     3a0:	30 e4       	ldi	r19, 0x40	; 64
     3a2:	ce 01       	movw	r24, r28
     3a4:	01 96       	adiw	r24, 0x01	; 1
     3a6:	b9 01       	movw	r22, r18
     3a8:	0e 94 7a 62 	call	0xc4f4	; 0xc4f4 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     3ac:	0e 94 03 0a 	call	0x1406	; 0x1406 <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     3b0:	ce 01       	movw	r24, r28
     3b2:	01 96       	adiw	r24, 0x01	; 1
     3b4:	9c 01       	movw	r18, r24
     3b6:	f9 01       	movw	r30, r18
     3b8:	01 90       	ld	r0, Z+
     3ba:	00 20       	and	r0, r0
     3bc:	e9 f7       	brne	.-6      	; 0x3b8 <__vector_83+0x9c>
     3be:	cf 01       	movw	r24, r30
     3c0:	01 97       	sbiw	r24, 0x01	; 1
     3c2:	82 1b       	sub	r24, r18
     3c4:	93 0b       	sbc	r25, r19
     3c6:	9c 01       	movw	r18, r24
     3c8:	40 e0       	ldi	r20, 0x00	; 0
     3ca:	50 e0       	ldi	r21, 0x00	; 0
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	be 01       	movw	r22, r28
     3d2:	6f 5f       	subi	r22, 0xFF	; 255
     3d4:	7f 4f       	sbci	r23, 0xFF	; 255
     3d6:	0e 94 4f 1e 	call	0x3c9e	; 0x3c9e <chb_write>
}	
     3da:	28 96       	adiw	r28, 0x08	; 8
     3dc:	cd bf       	out	0x3d, r28	; 61
     3de:	de bf       	out	0x3e, r29	; 62
     3e0:	df 91       	pop	r29
     3e2:	cf 91       	pop	r28
     3e4:	ff 91       	pop	r31
     3e6:	ef 91       	pop	r30
     3e8:	bf 91       	pop	r27
     3ea:	af 91       	pop	r26
     3ec:	9f 91       	pop	r25
     3ee:	8f 91       	pop	r24
     3f0:	7f 91       	pop	r23
     3f2:	6f 91       	pop	r22
     3f4:	5f 91       	pop	r21
     3f6:	4f 91       	pop	r20
     3f8:	3f 91       	pop	r19
     3fa:	2f 91       	pop	r18
     3fc:	0f 90       	pop	r0
     3fe:	00 92 3b 00 	sts	0x003B, r0
     402:	0f 90       	pop	r0
     404:	0f be       	out	0x3f, r0	; 63
     406:	0f 90       	pop	r0
     408:	1f 90       	pop	r1
     40a:	18 95       	reti

0000040c <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     40c:	cf 93       	push	r28
     40e:	df 93       	push	r29
     410:	cd b7       	in	r28, 0x3d	; 61
     412:	de b7       	in	r29, 0x3e	; 62
     414:	6b 97       	sbiw	r28, 0x1b	; 27
     416:	cd bf       	out	0x3d, r28	; 61
     418:	de bf       	out	0x3e, r29	; 62
     41a:	8e 8b       	std	Y+22, r24	; 0x16
     41c:	9f 8b       	std	Y+23, r25	; 0x17
     41e:	68 8f       	std	Y+24, r22	; 0x18
     420:	79 8f       	std	Y+25, r23	; 0x19
     422:	4a 8f       	std	Y+26, r20	; 0x1a
     424:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     426:	19 82       	std	Y+1, r1	; 0x01
     428:	1a 82       	std	Y+2, r1	; 0x02
     42a:	1b 82       	std	Y+3, r1	; 0x03
     42c:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	90 e1       	ldi	r25, 0x10	; 16
     432:	a0 e0       	ldi	r26, 0x00	; 0
     434:	b0 e0       	ldi	r27, 0x00	; 0
     436:	8d 83       	std	Y+5, r24	; 0x05
     438:	9e 83       	std	Y+6, r25	; 0x06
     43a:	af 83       	std	Y+7, r26	; 0x07
     43c:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     43e:	19 86       	std	Y+9, r1	; 0x09
     440:	1a 86       	std	Y+10, r1	; 0x0a
     442:	1b 86       	std	Y+11, r1	; 0x0b
     444:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     44c:	80 e0       	ldi	r24, 0x00	; 0
     44e:	92 e0       	ldi	r25, 0x02	; 2
     450:	0e 94 e5 19 	call	0x33ca	; 0x33ca <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     454:	80 e0       	ldi	r24, 0x00	; 0
     456:	92 e0       	ldi	r25, 0x02	; 2
     458:	20 e0       	ldi	r18, 0x00	; 0
     45a:	32 e0       	ldi	r19, 0x02	; 2
     45c:	f9 01       	movw	r30, r18
     45e:	21 81       	ldd	r18, Z+1	; 0x01
     460:	29 7e       	andi	r18, 0xE9	; 233
     462:	fc 01       	movw	r30, r24
     464:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	92 e0       	ldi	r25, 0x02	; 2
     46a:	20 e0       	ldi	r18, 0x00	; 0
     46c:	32 e0       	ldi	r19, 0x02	; 2
     46e:	f9 01       	movw	r30, r18
     470:	24 81       	ldd	r18, Z+4	; 0x04
     472:	28 7f       	andi	r18, 0xF8	; 248
     474:	23 60       	ori	r18, 0x03	; 3
     476:	fc 01       	movw	r30, r24
     478:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     47a:	80 e0       	ldi	r24, 0x00	; 0
     47c:	92 e0       	ldi	r25, 0x02	; 2
     47e:	20 e0       	ldi	r18, 0x00	; 0
     480:	32 e0       	ldi	r19, 0x02	; 2
     482:	f9 01       	movw	r30, r18
     484:	22 81       	ldd	r18, Z+2	; 0x02
     486:	2f 7c       	andi	r18, 0xCF	; 207
     488:	fc 01       	movw	r30, r24
     48a:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     48c:	80 e2       	ldi	r24, 0x20	; 32
     48e:	92 e0       	ldi	r25, 0x02	; 2
     490:	20 e2       	ldi	r18, 0x20	; 32
     492:	32 e0       	ldi	r19, 0x02	; 2
     494:	f9 01       	movw	r30, r18
     496:	20 81       	ld	r18, Z
     498:	20 7e       	andi	r18, 0xE0	; 224
     49a:	21 60       	ori	r18, 0x01	; 1
     49c:	fc 01       	movw	r30, r24
     49e:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     4a0:	80 e2       	ldi	r24, 0x20	; 32
     4a2:	92 e0       	ldi	r25, 0x02	; 2
     4a4:	29 e0       	ldi	r18, 0x09	; 9
     4a6:	fc 01       	movw	r30, r24
     4a8:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     4aa:	80 e0       	ldi	r24, 0x00	; 0
     4ac:	92 e0       	ldi	r25, 0x02	; 2
     4ae:	20 e0       	ldi	r18, 0x00	; 0
     4b0:	32 e0       	ldi	r19, 0x02	; 2
     4b2:	f9 01       	movw	r30, r18
     4b4:	20 81       	ld	r18, Z
     4b6:	21 60       	ori	r18, 0x01	; 1
     4b8:	fc 01       	movw	r30, r24
     4ba:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	92 e0       	ldi	r25, 0x02	; 2
     4c0:	0e 94 9d 1b 	call	0x373a	; 0x373a <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     4c4:	80 e0       	ldi	r24, 0x00	; 0
     4c6:	92 e0       	ldi	r25, 0x02	; 2
     4c8:	60 e2       	ldi	r22, 0x20	; 32
     4ca:	72 e0       	ldi	r23, 0x02	; 2
     4cc:	40 e0       	ldi	r20, 0x00	; 0
     4ce:	0e 94 94 1c 	call	0x3928	; 0x3928 <ADC_Offset_Get_Unsigned>
     4d2:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	92 e0       	ldi	r25, 0x02	; 2
     4d8:	20 e0       	ldi	r18, 0x00	; 0
     4da:	32 e0       	ldi	r19, 0x02	; 2
     4dc:	f9 01       	movw	r30, r18
     4de:	20 81       	ld	r18, Z
     4e0:	2e 7f       	andi	r18, 0xFE	; 254
     4e2:	fc 01       	movw	r30, r24
     4e4:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     4e6:	80 e2       	ldi	r24, 0x20	; 32
     4e8:	92 e0       	ldi	r25, 0x02	; 2
     4ea:	fc 01       	movw	r30, r24
     4ec:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     4ee:	80 e0       	ldi	r24, 0x00	; 0
     4f0:	92 e0       	ldi	r25, 0x02	; 2
     4f2:	20 e0       	ldi	r18, 0x00	; 0
     4f4:	32 e0       	ldi	r19, 0x02	; 2
     4f6:	f9 01       	movw	r30, r18
     4f8:	23 81       	ldd	r18, Z+3	; 0x03
     4fa:	2f 73       	andi	r18, 0x3F	; 63
     4fc:	fc 01       	movw	r30, r24
     4fe:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     500:	80 e0       	ldi	r24, 0x00	; 0
     502:	92 e0       	ldi	r25, 0x02	; 2
     504:	20 e0       	ldi	r18, 0x00	; 0
     506:	32 e0       	ldi	r19, 0x02	; 2
     508:	f9 01       	movw	r30, r18
     50a:	20 81       	ld	r18, Z
     50c:	21 60       	ori	r18, 0x01	; 1
     50e:	fc 01       	movw	r30, r24
     510:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     512:	80 e0       	ldi	r24, 0x00	; 0
     514:	92 e0       	ldi	r25, 0x02	; 2
     516:	0e 94 9d 1b 	call	0x373a	; 0x373a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     51a:	80 e0       	ldi	r24, 0x00	; 0
     51c:	92 e0       	ldi	r25, 0x02	; 2
     51e:	20 e0       	ldi	r18, 0x00	; 0
     520:	32 e0       	ldi	r19, 0x02	; 2
     522:	f9 01       	movw	r30, r18
     524:	21 81       	ldd	r18, Z+1	; 0x01
     526:	28 60       	ori	r18, 0x08	; 8
     528:	fc 01       	movw	r30, r24
     52a:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     52c:	1d 86       	std	Y+13, r1	; 0x0d
     52e:	1e 86       	std	Y+14, r1	; 0x0e
     530:	56 c0       	rjmp	.+172    	; 0x5de <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     532:	80 e2       	ldi	r24, 0x20	; 32
     534:	92 e0       	ldi	r25, 0x02	; 2
     536:	fc 01       	movw	r30, r24
     538:	83 81       	ldd	r24, Z+3	; 0x03
     53a:	88 2f       	mov	r24, r24
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	81 70       	andi	r24, 0x01	; 1
     540:	90 70       	andi	r25, 0x00	; 0
     542:	00 97       	sbiw	r24, 0x00	; 0
     544:	b1 f3       	breq	.-20     	; 0x532 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     546:	2d 89       	ldd	r18, Y+21	; 0x15
     548:	80 e2       	ldi	r24, 0x20	; 32
     54a:	92 e0       	ldi	r25, 0x02	; 2
     54c:	62 2f       	mov	r22, r18
     54e:	0e 94 3e 1a 	call	0x347c	; 0x347c <ADC_ResultCh_GetWord_Signed>
     552:	8f 87       	std	Y+15, r24	; 0x0f
     554:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     556:	8f 85       	ldd	r24, Y+15	; 0x0f
     558:	98 89       	ldd	r25, Y+16	; 0x10
     55a:	cc 01       	movw	r24, r24
     55c:	a0 e0       	ldi	r26, 0x00	; 0
     55e:	b0 e0       	ldi	r27, 0x00	; 0
     560:	29 81       	ldd	r18, Y+1	; 0x01
     562:	3a 81       	ldd	r19, Y+2	; 0x02
     564:	4b 81       	ldd	r20, Y+3	; 0x03
     566:	5c 81       	ldd	r21, Y+4	; 0x04
     568:	82 0f       	add	r24, r18
     56a:	93 1f       	adc	r25, r19
     56c:	a4 1f       	adc	r26, r20
     56e:	b5 1f       	adc	r27, r21
     570:	89 83       	std	Y+1, r24	; 0x01
     572:	9a 83       	std	Y+2, r25	; 0x02
     574:	ab 83       	std	Y+3, r26	; 0x03
     576:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     578:	8f 85       	ldd	r24, Y+15	; 0x0f
     57a:	98 89       	ldd	r25, Y+16	; 0x10
     57c:	9c 01       	movw	r18, r24
     57e:	40 e0       	ldi	r20, 0x00	; 0
     580:	50 e0       	ldi	r21, 0x00	; 0
     582:	89 85       	ldd	r24, Y+9	; 0x09
     584:	9a 85       	ldd	r25, Y+10	; 0x0a
     586:	ab 85       	ldd	r26, Y+11	; 0x0b
     588:	bc 85       	ldd	r27, Y+12	; 0x0c
     58a:	82 17       	cp	r24, r18
     58c:	93 07       	cpc	r25, r19
     58e:	a4 07       	cpc	r26, r20
     590:	b5 07       	cpc	r27, r21
     592:	48 f4       	brcc	.+18     	; 0x5a6 <CO_collectTemp+0x19a>
     594:	8f 85       	ldd	r24, Y+15	; 0x0f
     596:	98 89       	ldd	r25, Y+16	; 0x10
     598:	cc 01       	movw	r24, r24
     59a:	a0 e0       	ldi	r26, 0x00	; 0
     59c:	b0 e0       	ldi	r27, 0x00	; 0
     59e:	89 87       	std	Y+9, r24	; 0x09
     5a0:	9a 87       	std	Y+10, r25	; 0x0a
     5a2:	ab 87       	std	Y+11, r26	; 0x0b
     5a4:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     5a6:	8f 85       	ldd	r24, Y+15	; 0x0f
     5a8:	98 89       	ldd	r25, Y+16	; 0x10
     5aa:	9c 01       	movw	r18, r24
     5ac:	40 e0       	ldi	r20, 0x00	; 0
     5ae:	50 e0       	ldi	r21, 0x00	; 0
     5b0:	8d 81       	ldd	r24, Y+5	; 0x05
     5b2:	9e 81       	ldd	r25, Y+6	; 0x06
     5b4:	af 81       	ldd	r26, Y+7	; 0x07
     5b6:	b8 85       	ldd	r27, Y+8	; 0x08
     5b8:	28 17       	cp	r18, r24
     5ba:	39 07       	cpc	r19, r25
     5bc:	4a 07       	cpc	r20, r26
     5be:	5b 07       	cpc	r21, r27
     5c0:	48 f4       	brcc	.+18     	; 0x5d4 <CO_collectTemp+0x1c8>
     5c2:	8f 85       	ldd	r24, Y+15	; 0x0f
     5c4:	98 89       	ldd	r25, Y+16	; 0x10
     5c6:	cc 01       	movw	r24, r24
     5c8:	a0 e0       	ldi	r26, 0x00	; 0
     5ca:	b0 e0       	ldi	r27, 0x00	; 0
     5cc:	8d 83       	std	Y+5, r24	; 0x05
     5ce:	9e 83       	std	Y+6, r25	; 0x06
     5d0:	af 83       	std	Y+7, r26	; 0x07
     5d2:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     5d4:	8d 85       	ldd	r24, Y+13	; 0x0d
     5d6:	9e 85       	ldd	r25, Y+14	; 0x0e
     5d8:	01 96       	adiw	r24, 0x01	; 1
     5da:	8d 87       	std	Y+13, r24	; 0x0d
     5dc:	9e 87       	std	Y+14, r25	; 0x0e
     5de:	8d 85       	ldd	r24, Y+13	; 0x0d
     5e0:	9e 85       	ldd	r25, Y+14	; 0x0e
     5e2:	f4 e0       	ldi	r31, 0x04	; 4
     5e4:	80 30       	cpi	r24, 0x00	; 0
     5e6:	9f 07       	cpc	r25, r31
     5e8:	08 f4       	brcc	.+2      	; 0x5ec <CO_collectTemp+0x1e0>
     5ea:	a3 cf       	rjmp	.-186    	; 0x532 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	92 e0       	ldi	r25, 0x02	; 2
     5f0:	20 e0       	ldi	r18, 0x00	; 0
     5f2:	32 e0       	ldi	r19, 0x02	; 2
     5f4:	f9 01       	movw	r30, r18
     5f6:	21 81       	ldd	r18, Z+1	; 0x01
     5f8:	27 7f       	andi	r18, 0xF7	; 247
     5fa:	fc 01       	movw	r30, r24
     5fc:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     5fe:	80 e0       	ldi	r24, 0x00	; 0
     600:	92 e0       	ldi	r25, 0x02	; 2
     602:	20 e0       	ldi	r18, 0x00	; 0
     604:	32 e0       	ldi	r19, 0x02	; 2
     606:	f9 01       	movw	r30, r18
     608:	20 81       	ld	r18, Z
     60a:	22 60       	ori	r18, 0x02	; 2
     60c:	fc 01       	movw	r30, r24
     60e:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     610:	80 e0       	ldi	r24, 0x00	; 0
     612:	92 e0       	ldi	r25, 0x02	; 2
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	32 e0       	ldi	r19, 0x02	; 2
     618:	f9 01       	movw	r30, r18
     61a:	20 81       	ld	r18, Z
     61c:	2e 7f       	andi	r18, 0xFE	; 254
     61e:	fc 01       	movw	r30, r24
     620:	20 83       	st	Z, r18

	ADCPower(FALSE);
     622:	80 e0       	ldi	r24, 0x00	; 0
     624:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

	average = sum / NUM_SAMPLES;
     628:	89 81       	ldd	r24, Y+1	; 0x01
     62a:	9a 81       	ldd	r25, Y+2	; 0x02
     62c:	ab 81       	ldd	r26, Y+3	; 0x03
     62e:	bc 81       	ldd	r27, Y+4	; 0x04
     630:	07 2e       	mov	r0, r23
     632:	7a e0       	ldi	r23, 0x0A	; 10
     634:	b6 95       	lsr	r27
     636:	a7 95       	ror	r26
     638:	97 95       	ror	r25
     63a:	87 95       	ror	r24
     63c:	7a 95       	dec	r23
     63e:	d1 f7       	brne	.-12     	; 0x634 <CO_collectTemp+0x228>
     640:	70 2d       	mov	r23, r0
     642:	89 8b       	std	Y+17, r24	; 0x11
     644:	9a 8b       	std	Y+18, r25	; 0x12
     646:	ab 8b       	std	Y+19, r26	; 0x13
     648:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     64a:	89 89       	ldd	r24, Y+17	; 0x11
     64c:	9a 89       	ldd	r25, Y+18	; 0x12
     64e:	ab 89       	ldd	r26, Y+19	; 0x13
     650:	bc 89       	ldd	r27, Y+20	; 0x14
     652:	28 ee       	ldi	r18, 0xE8	; 232
     654:	33 e0       	ldi	r19, 0x03	; 3
     656:	40 e0       	ldi	r20, 0x00	; 0
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	bc 01       	movw	r22, r24
     65c:	cd 01       	movw	r24, r26
     65e:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
     662:	dc 01       	movw	r26, r24
     664:	cb 01       	movw	r24, r22
     666:	2f ef       	ldi	r18, 0xFF	; 255
     668:	3f e0       	ldi	r19, 0x0F	; 15
     66a:	40 e0       	ldi	r20, 0x00	; 0
     66c:	50 e0       	ldi	r21, 0x00	; 0
     66e:	bc 01       	movw	r22, r24
     670:	cd 01       	movw	r24, r26
     672:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
     676:	da 01       	movw	r26, r20
     678:	c9 01       	movw	r24, r18
     67a:	9c 01       	movw	r18, r24
     67c:	22 53       	subi	r18, 0x32	; 50
     67e:	30 40       	sbci	r19, 0x00	; 0
     680:	8e 89       	ldd	r24, Y+22	; 0x16
     682:	9f 89       	ldd	r25, Y+23	; 0x17
     684:	fc 01       	movw	r30, r24
     686:	20 83       	st	Z, r18
     688:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     68a:	89 85       	ldd	r24, Y+9	; 0x09
     68c:	9a 85       	ldd	r25, Y+10	; 0x0a
     68e:	ab 85       	ldd	r26, Y+11	; 0x0b
     690:	bc 85       	ldd	r27, Y+12	; 0x0c
     692:	28 ee       	ldi	r18, 0xE8	; 232
     694:	33 e0       	ldi	r19, 0x03	; 3
     696:	40 e0       	ldi	r20, 0x00	; 0
     698:	50 e0       	ldi	r21, 0x00	; 0
     69a:	bc 01       	movw	r22, r24
     69c:	cd 01       	movw	r24, r26
     69e:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
     6a2:	dc 01       	movw	r26, r24
     6a4:	cb 01       	movw	r24, r22
     6a6:	2f ef       	ldi	r18, 0xFF	; 255
     6a8:	3f e0       	ldi	r19, 0x0F	; 15
     6aa:	40 e0       	ldi	r20, 0x00	; 0
     6ac:	50 e0       	ldi	r21, 0x00	; 0
     6ae:	bc 01       	movw	r22, r24
     6b0:	cd 01       	movw	r24, r26
     6b2:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
     6b6:	da 01       	movw	r26, r20
     6b8:	c9 01       	movw	r24, r18
     6ba:	9c 01       	movw	r18, r24
     6bc:	22 53       	subi	r18, 0x32	; 50
     6be:	30 40       	sbci	r19, 0x00	; 0
     6c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6c2:	9b 8d       	ldd	r25, Y+27	; 0x1b
     6c4:	fc 01       	movw	r30, r24
     6c6:	20 83       	st	Z, r18
     6c8:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     6ca:	8d 81       	ldd	r24, Y+5	; 0x05
     6cc:	9e 81       	ldd	r25, Y+6	; 0x06
     6ce:	af 81       	ldd	r26, Y+7	; 0x07
     6d0:	b8 85       	ldd	r27, Y+8	; 0x08
     6d2:	28 ee       	ldi	r18, 0xE8	; 232
     6d4:	33 e0       	ldi	r19, 0x03	; 3
     6d6:	40 e0       	ldi	r20, 0x00	; 0
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	bc 01       	movw	r22, r24
     6dc:	cd 01       	movw	r24, r26
     6de:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
     6e2:	dc 01       	movw	r26, r24
     6e4:	cb 01       	movw	r24, r22
     6e6:	2f ef       	ldi	r18, 0xFF	; 255
     6e8:	3f e0       	ldi	r19, 0x0F	; 15
     6ea:	40 e0       	ldi	r20, 0x00	; 0
     6ec:	50 e0       	ldi	r21, 0x00	; 0
     6ee:	bc 01       	movw	r22, r24
     6f0:	cd 01       	movw	r24, r26
     6f2:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
     6f6:	da 01       	movw	r26, r20
     6f8:	c9 01       	movw	r24, r18
     6fa:	9c 01       	movw	r18, r24
     6fc:	22 53       	subi	r18, 0x32	; 50
     6fe:	30 40       	sbci	r19, 0x00	; 0
     700:	88 8d       	ldd	r24, Y+24	; 0x18
     702:	99 8d       	ldd	r25, Y+25	; 0x19
     704:	fc 01       	movw	r30, r24
     706:	20 83       	st	Z, r18
     708:	31 83       	std	Z+1, r19	; 0x01
}
     70a:	6b 96       	adiw	r28, 0x1b	; 27
     70c:	cd bf       	out	0x3d, r28	; 61
     70e:	de bf       	out	0x3e, r29	; 62
     710:	df 91       	pop	r29
     712:	cf 91       	pop	r28
     714:	08 95       	ret

00000716 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     716:	0f 93       	push	r16
     718:	1f 93       	push	r17
     71a:	cf 93       	push	r28
     71c:	df 93       	push	r29
     71e:	cd b7       	in	r28, 0x3d	; 61
     720:	de b7       	in	r29, 0x3e	; 62
     722:	a9 97       	sbiw	r28, 0x29	; 41
     724:	cd bf       	out	0x3d, r28	; 61
     726:	de bf       	out	0x3e, r29	; 62
     728:	8c a3       	lds	r24, 0x5c
     72a:	9d a3       	lds	r25, 0x5d
     72c:	6e a3       	lds	r22, 0x5e
     72e:	7f a3       	lds	r23, 0x5f
     730:	48 a7       	lds	r20, 0x78
     732:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     734:	19 82       	std	Y+1, r1	; 0x01
     736:	1a 82       	std	Y+2, r1	; 0x02
     738:	1b 82       	std	Y+3, r1	; 0x03
     73a:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     73c:	80 e0       	ldi	r24, 0x00	; 0
     73e:	90 e1       	ldi	r25, 0x10	; 16
     740:	a0 e0       	ldi	r26, 0x00	; 0
     742:	b0 e0       	ldi	r27, 0x00	; 0
     744:	8d 83       	std	Y+5, r24	; 0x05
     746:	9e 83       	std	Y+6, r25	; 0x06
     748:	af 83       	std	Y+7, r26	; 0x07
     74a:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     74c:	19 86       	std	Y+9, r1	; 0x09
     74e:	1a 86       	std	Y+10, r1	; 0x0a
     750:	1b 86       	std	Y+11, r1	; 0x0b
     752:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     754:	81 e0       	ldi	r24, 0x01	; 1
     756:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     75a:	84 e0       	ldi	r24, 0x04	; 4
     75c:	60 e0       	ldi	r22, 0x00	; 0
     75e:	0e 94 6f 32 	call	0x64de	; 0x64de <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     762:	84 e0       	ldi	r24, 0x04	; 4
     764:	60 e0       	ldi	r22, 0x00	; 0
     766:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
     76a:	80 e0       	ldi	r24, 0x00	; 0
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	a8 ec       	ldi	r26, 0xC8	; 200
     770:	b2 e4       	ldi	r27, 0x42	; 66
     772:	8d 8b       	std	Y+21, r24	; 0x15
     774:	9e 8b       	std	Y+22, r25	; 0x16
     776:	af 8b       	std	Y+23, r26	; 0x17
     778:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     77a:	6d 89       	ldd	r22, Y+21	; 0x15
     77c:	7e 89       	ldd	r23, Y+22	; 0x16
     77e:	8f 89       	ldd	r24, Y+23	; 0x17
     780:	98 8d       	ldd	r25, Y+24	; 0x18
     782:	20 e0       	ldi	r18, 0x00	; 0
     784:	30 e0       	ldi	r19, 0x00	; 0
     786:	4a ef       	ldi	r20, 0xFA	; 250
     788:	55 e4       	ldi	r21, 0x45	; 69
     78a:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
     78e:	dc 01       	movw	r26, r24
     790:	cb 01       	movw	r24, r22
     792:	89 8f       	std	Y+25, r24	; 0x19
     794:	9a 8f       	std	Y+26, r25	; 0x1a
     796:	ab 8f       	std	Y+27, r26	; 0x1b
     798:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     79a:	11 e0       	ldi	r17, 0x01	; 1
     79c:	69 8d       	ldd	r22, Y+25	; 0x19
     79e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     7a0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7a2:	9c 8d       	ldd	r25, Y+28	; 0x1c
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	40 e8       	ldi	r20, 0x80	; 128
     7aa:	5f e3       	ldi	r21, 0x3F	; 63
     7ac:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
     7b0:	88 23       	and	r24, r24
     7b2:	0c f0       	brlt	.+2      	; 0x7b6 <CO_collectBatt+0xa0>
     7b4:	10 e0       	ldi	r17, 0x00	; 0
     7b6:	11 23       	and	r17, r17
     7b8:	29 f0       	breq	.+10     	; 0x7c4 <CO_collectBatt+0xae>
		__ticks = 1;
     7ba:	81 e0       	ldi	r24, 0x01	; 1
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	8d 8f       	std	Y+29, r24	; 0x1d
     7c0:	9e 8f       	std	Y+30, r25	; 0x1e
     7c2:	46 c0       	rjmp	.+140    	; 0x850 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     7c4:	11 e0       	ldi	r17, 0x01	; 1
     7c6:	69 8d       	ldd	r22, Y+25	; 0x19
     7c8:	7a 8d       	ldd	r23, Y+26	; 0x1a
     7ca:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7cc:	9c 8d       	ldd	r25, Y+28	; 0x1c
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	3f ef       	ldi	r19, 0xFF	; 255
     7d2:	4f e7       	ldi	r20, 0x7F	; 127
     7d4:	57 e4       	ldi	r21, 0x47	; 71
     7d6:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
     7da:	18 16       	cp	r1, r24
     7dc:	0c f0       	brlt	.+2      	; 0x7e0 <CO_collectBatt+0xca>
     7de:	10 e0       	ldi	r17, 0x00	; 0
     7e0:	11 23       	and	r17, r17
     7e2:	61 f1       	breq	.+88     	; 0x83c <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     7e4:	6d 89       	ldd	r22, Y+21	; 0x15
     7e6:	7e 89       	ldd	r23, Y+22	; 0x16
     7e8:	8f 89       	ldd	r24, Y+23	; 0x17
     7ea:	98 8d       	ldd	r25, Y+24	; 0x18
     7ec:	20 e0       	ldi	r18, 0x00	; 0
     7ee:	30 e0       	ldi	r19, 0x00	; 0
     7f0:	40 e2       	ldi	r20, 0x20	; 32
     7f2:	51 e4       	ldi	r21, 0x41	; 65
     7f4:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
     7f8:	dc 01       	movw	r26, r24
     7fa:	cb 01       	movw	r24, r22
     7fc:	bc 01       	movw	r22, r24
     7fe:	cd 01       	movw	r24, r26
     800:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
     804:	dc 01       	movw	r26, r24
     806:	cb 01       	movw	r24, r22
     808:	8d 8f       	std	Y+29, r24	; 0x1d
     80a:	9e 8f       	std	Y+30, r25	; 0x1e
     80c:	12 c0       	rjmp	.+36     	; 0x832 <CO_collectBatt+0x11c>
     80e:	80 e2       	ldi	r24, 0x20	; 32
     810:	93 e0       	ldi	r25, 0x03	; 3
     812:	8f 8f       	std	Y+31, r24	; 0x1f
     814:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     816:	8f 8d       	ldd	r24, Y+31	; 0x1f
     818:	98 a1       	lds	r25, 0x48
     81a:	8c 01       	movw	r16, r24
     81c:	c8 01       	movw	r24, r16
     81e:	01 97       	sbiw	r24, 0x01	; 1
     820:	f1 f7       	brne	.-4      	; 0x81e <CO_collectBatt+0x108>
     822:	8c 01       	movw	r16, r24
     824:	0f 8f       	std	Y+31, r16	; 0x1f
     826:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     828:	8d 8d       	ldd	r24, Y+29	; 0x1d
     82a:	9e 8d       	ldd	r25, Y+30	; 0x1e
     82c:	01 97       	sbiw	r24, 0x01	; 1
     82e:	8d 8f       	std	Y+29, r24	; 0x1d
     830:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     832:	8d 8d       	ldd	r24, Y+29	; 0x1d
     834:	9e 8d       	ldd	r25, Y+30	; 0x1e
     836:	00 97       	sbiw	r24, 0x00	; 0
     838:	51 f7       	brne	.-44     	; 0x80e <CO_collectBatt+0xf8>
     83a:	17 c0       	rjmp	.+46     	; 0x86a <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     83c:	69 8d       	ldd	r22, Y+25	; 0x19
     83e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     840:	8b 8d       	ldd	r24, Y+27	; 0x1b
     842:	9c 8d       	ldd	r25, Y+28	; 0x1c
     844:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
     848:	dc 01       	movw	r26, r24
     84a:	cb 01       	movw	r24, r22
     84c:	8d 8f       	std	Y+29, r24	; 0x1d
     84e:	9e 8f       	std	Y+30, r25	; 0x1e
     850:	8d 8d       	ldd	r24, Y+29	; 0x1d
     852:	9e 8d       	ldd	r25, Y+30	; 0x1e
     854:	89 a3       	lds	r24, 0x59
     856:	9a a3       	lds	r25, 0x5a
     858:	89 a1       	lds	r24, 0x49
     85a:	9a a1       	lds	r25, 0x4a
     85c:	8c 01       	movw	r16, r24
     85e:	f8 01       	movw	r30, r16
     860:	31 97       	sbiw	r30, 0x01	; 1
     862:	f1 f7       	brne	.-4      	; 0x860 <CO_collectBatt+0x14a>
     864:	8f 01       	movw	r16, r30
     866:	09 a3       	lds	r16, 0x59
     868:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     86a:	80 e4       	ldi	r24, 0x40	; 64
     86c:	92 e0       	ldi	r25, 0x02	; 2
     86e:	0e 94 e5 19 	call	0x33ca	; 0x33ca <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     872:	80 e4       	ldi	r24, 0x40	; 64
     874:	92 e0       	ldi	r25, 0x02	; 2
     876:	20 e4       	ldi	r18, 0x40	; 64
     878:	32 e0       	ldi	r19, 0x02	; 2
     87a:	f9 01       	movw	r30, r18
     87c:	21 81       	ldd	r18, Z+1	; 0x01
     87e:	29 7e       	andi	r18, 0xE9	; 233
     880:	fc 01       	movw	r30, r24
     882:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     884:	80 e4       	ldi	r24, 0x40	; 64
     886:	92 e0       	ldi	r25, 0x02	; 2
     888:	20 e4       	ldi	r18, 0x40	; 64
     88a:	32 e0       	ldi	r19, 0x02	; 2
     88c:	f9 01       	movw	r30, r18
     88e:	24 81       	ldd	r18, Z+4	; 0x04
     890:	28 7f       	andi	r18, 0xF8	; 248
     892:	23 60       	ori	r18, 0x03	; 3
     894:	fc 01       	movw	r30, r24
     896:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     898:	80 e4       	ldi	r24, 0x40	; 64
     89a:	92 e0       	ldi	r25, 0x02	; 2
     89c:	20 e4       	ldi	r18, 0x40	; 64
     89e:	32 e0       	ldi	r19, 0x02	; 2
     8a0:	f9 01       	movw	r30, r18
     8a2:	22 81       	ldd	r18, Z+2	; 0x02
     8a4:	2f 7c       	andi	r18, 0xCF	; 207
     8a6:	fc 01       	movw	r30, r24
     8a8:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     8aa:	80 e6       	ldi	r24, 0x60	; 96
     8ac:	92 e0       	ldi	r25, 0x02	; 2
     8ae:	20 e6       	ldi	r18, 0x60	; 96
     8b0:	32 e0       	ldi	r19, 0x02	; 2
     8b2:	f9 01       	movw	r30, r18
     8b4:	20 81       	ld	r18, Z
     8b6:	20 7e       	andi	r18, 0xE0	; 224
     8b8:	21 60       	ori	r18, 0x01	; 1
     8ba:	fc 01       	movw	r30, r24
     8bc:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     8be:	80 e6       	ldi	r24, 0x60	; 96
     8c0:	92 e0       	ldi	r25, 0x02	; 2
     8c2:	29 e0       	ldi	r18, 0x09	; 9
     8c4:	fc 01       	movw	r30, r24
     8c6:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     8c8:	80 e4       	ldi	r24, 0x40	; 64
     8ca:	92 e0       	ldi	r25, 0x02	; 2
     8cc:	20 e4       	ldi	r18, 0x40	; 64
     8ce:	32 e0       	ldi	r19, 0x02	; 2
     8d0:	f9 01       	movw	r30, r18
     8d2:	20 81       	ld	r18, Z
     8d4:	21 60       	ori	r18, 0x01	; 1
     8d6:	fc 01       	movw	r30, r24
     8d8:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     8da:	80 e4       	ldi	r24, 0x40	; 64
     8dc:	92 e0       	ldi	r25, 0x02	; 2
     8de:	0e 94 9d 1b 	call	0x373a	; 0x373a <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     8e2:	80 e4       	ldi	r24, 0x40	; 64
     8e4:	92 e0       	ldi	r25, 0x02	; 2
     8e6:	60 e6       	ldi	r22, 0x60	; 96
     8e8:	72 e0       	ldi	r23, 0x02	; 2
     8ea:	40 e0       	ldi	r20, 0x00	; 0
     8ec:	0e 94 94 1c 	call	0x3928	; 0x3928 <ADC_Offset_Get_Unsigned>
     8f0:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     8f2:	80 e4       	ldi	r24, 0x40	; 64
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	20 e4       	ldi	r18, 0x40	; 64
     8f8:	32 e0       	ldi	r19, 0x02	; 2
     8fa:	f9 01       	movw	r30, r18
     8fc:	20 81       	ld	r18, Z
     8fe:	2e 7f       	andi	r18, 0xFE	; 254
     900:	fc 01       	movw	r30, r24
     902:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     904:	80 e6       	ldi	r24, 0x60	; 96
     906:	92 e0       	ldi	r25, 0x02	; 2
     908:	fc 01       	movw	r30, r24
     90a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	92 e0       	ldi	r25, 0x02	; 2
     910:	20 e4       	ldi	r18, 0x40	; 64
     912:	32 e0       	ldi	r19, 0x02	; 2
     914:	f9 01       	movw	r30, r18
     916:	23 81       	ldd	r18, Z+3	; 0x03
     918:	2f 73       	andi	r18, 0x3F	; 63
     91a:	fc 01       	movw	r30, r24
     91c:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     91e:	80 e4       	ldi	r24, 0x40	; 64
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	20 e4       	ldi	r18, 0x40	; 64
     924:	32 e0       	ldi	r19, 0x02	; 2
     926:	f9 01       	movw	r30, r18
     928:	20 81       	ld	r18, Z
     92a:	21 60       	ori	r18, 0x01	; 1
     92c:	fc 01       	movw	r30, r24
     92e:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     930:	80 e4       	ldi	r24, 0x40	; 64
     932:	92 e0       	ldi	r25, 0x02	; 2
     934:	0e 94 9d 1b 	call	0x373a	; 0x373a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     938:	80 e4       	ldi	r24, 0x40	; 64
     93a:	92 e0       	ldi	r25, 0x02	; 2
     93c:	20 e4       	ldi	r18, 0x40	; 64
     93e:	32 e0       	ldi	r19, 0x02	; 2
     940:	f9 01       	movw	r30, r18
     942:	21 81       	ldd	r18, Z+1	; 0x01
     944:	28 60       	ori	r18, 0x08	; 8
     946:	fc 01       	movw	r30, r24
     948:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     94a:	1d 86       	std	Y+13, r1	; 0x0d
     94c:	1e 86       	std	Y+14, r1	; 0x0e
     94e:	56 c0       	rjmp	.+172    	; 0x9fc <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     950:	80 e6       	ldi	r24, 0x60	; 96
     952:	92 e0       	ldi	r25, 0x02	; 2
     954:	fc 01       	movw	r30, r24
     956:	83 81       	ldd	r24, Z+3	; 0x03
     958:	88 2f       	mov	r24, r24
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	81 70       	andi	r24, 0x01	; 1
     95e:	90 70       	andi	r25, 0x00	; 0
     960:	00 97       	sbiw	r24, 0x00	; 0
     962:	b1 f3       	breq	.-20     	; 0x950 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     964:	2b a1       	lds	r18, 0x4b
     966:	80 e6       	ldi	r24, 0x60	; 96
     968:	92 e0       	ldi	r25, 0x02	; 2
     96a:	62 2f       	mov	r22, r18
     96c:	0e 94 3e 1a 	call	0x347c	; 0x347c <ADC_ResultCh_GetWord_Signed>
     970:	8f 87       	std	Y+15, r24	; 0x0f
     972:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     974:	8f 85       	ldd	r24, Y+15	; 0x0f
     976:	98 89       	ldd	r25, Y+16	; 0x10
     978:	cc 01       	movw	r24, r24
     97a:	a0 e0       	ldi	r26, 0x00	; 0
     97c:	b0 e0       	ldi	r27, 0x00	; 0
     97e:	29 81       	ldd	r18, Y+1	; 0x01
     980:	3a 81       	ldd	r19, Y+2	; 0x02
     982:	4b 81       	ldd	r20, Y+3	; 0x03
     984:	5c 81       	ldd	r21, Y+4	; 0x04
     986:	82 0f       	add	r24, r18
     988:	93 1f       	adc	r25, r19
     98a:	a4 1f       	adc	r26, r20
     98c:	b5 1f       	adc	r27, r21
     98e:	89 83       	std	Y+1, r24	; 0x01
     990:	9a 83       	std	Y+2, r25	; 0x02
     992:	ab 83       	std	Y+3, r26	; 0x03
     994:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     996:	8f 85       	ldd	r24, Y+15	; 0x0f
     998:	98 89       	ldd	r25, Y+16	; 0x10
     99a:	9c 01       	movw	r18, r24
     99c:	40 e0       	ldi	r20, 0x00	; 0
     99e:	50 e0       	ldi	r21, 0x00	; 0
     9a0:	89 85       	ldd	r24, Y+9	; 0x09
     9a2:	9a 85       	ldd	r25, Y+10	; 0x0a
     9a4:	ab 85       	ldd	r26, Y+11	; 0x0b
     9a6:	bc 85       	ldd	r27, Y+12	; 0x0c
     9a8:	82 17       	cp	r24, r18
     9aa:	93 07       	cpc	r25, r19
     9ac:	a4 07       	cpc	r26, r20
     9ae:	b5 07       	cpc	r27, r21
     9b0:	48 f4       	brcc	.+18     	; 0x9c4 <CO_collectBatt+0x2ae>
     9b2:	8f 85       	ldd	r24, Y+15	; 0x0f
     9b4:	98 89       	ldd	r25, Y+16	; 0x10
     9b6:	cc 01       	movw	r24, r24
     9b8:	a0 e0       	ldi	r26, 0x00	; 0
     9ba:	b0 e0       	ldi	r27, 0x00	; 0
     9bc:	89 87       	std	Y+9, r24	; 0x09
     9be:	9a 87       	std	Y+10, r25	; 0x0a
     9c0:	ab 87       	std	Y+11, r26	; 0x0b
     9c2:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     9c4:	8f 85       	ldd	r24, Y+15	; 0x0f
     9c6:	98 89       	ldd	r25, Y+16	; 0x10
     9c8:	9c 01       	movw	r18, r24
     9ca:	40 e0       	ldi	r20, 0x00	; 0
     9cc:	50 e0       	ldi	r21, 0x00	; 0
     9ce:	8d 81       	ldd	r24, Y+5	; 0x05
     9d0:	9e 81       	ldd	r25, Y+6	; 0x06
     9d2:	af 81       	ldd	r26, Y+7	; 0x07
     9d4:	b8 85       	ldd	r27, Y+8	; 0x08
     9d6:	28 17       	cp	r18, r24
     9d8:	39 07       	cpc	r19, r25
     9da:	4a 07       	cpc	r20, r26
     9dc:	5b 07       	cpc	r21, r27
     9de:	48 f4       	brcc	.+18     	; 0x9f2 <CO_collectBatt+0x2dc>
     9e0:	8f 85       	ldd	r24, Y+15	; 0x0f
     9e2:	98 89       	ldd	r25, Y+16	; 0x10
     9e4:	cc 01       	movw	r24, r24
     9e6:	a0 e0       	ldi	r26, 0x00	; 0
     9e8:	b0 e0       	ldi	r27, 0x00	; 0
     9ea:	8d 83       	std	Y+5, r24	; 0x05
     9ec:	9e 83       	std	Y+6, r25	; 0x06
     9ee:	af 83       	std	Y+7, r26	; 0x07
     9f0:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     9f2:	8d 85       	ldd	r24, Y+13	; 0x0d
     9f4:	9e 85       	ldd	r25, Y+14	; 0x0e
     9f6:	01 96       	adiw	r24, 0x01	; 1
     9f8:	8d 87       	std	Y+13, r24	; 0x0d
     9fa:	9e 87       	std	Y+14, r25	; 0x0e
     9fc:	8d 85       	ldd	r24, Y+13	; 0x0d
     9fe:	9e 85       	ldd	r25, Y+14	; 0x0e
     a00:	f4 e0       	ldi	r31, 0x04	; 4
     a02:	80 30       	cpi	r24, 0x00	; 0
     a04:	9f 07       	cpc	r25, r31
     a06:	08 f4       	brcc	.+2      	; 0xa0a <CO_collectBatt+0x2f4>
     a08:	a3 cf       	rjmp	.-186    	; 0x950 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     a0a:	80 e4       	ldi	r24, 0x40	; 64
     a0c:	92 e0       	ldi	r25, 0x02	; 2
     a0e:	20 e4       	ldi	r18, 0x40	; 64
     a10:	32 e0       	ldi	r19, 0x02	; 2
     a12:	f9 01       	movw	r30, r18
     a14:	21 81       	ldd	r18, Z+1	; 0x01
     a16:	27 7f       	andi	r18, 0xF7	; 247
     a18:	fc 01       	movw	r30, r24
     a1a:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     a1c:	80 e4       	ldi	r24, 0x40	; 64
     a1e:	92 e0       	ldi	r25, 0x02	; 2
     a20:	20 e4       	ldi	r18, 0x40	; 64
     a22:	32 e0       	ldi	r19, 0x02	; 2
     a24:	f9 01       	movw	r30, r18
     a26:	20 81       	ld	r18, Z
     a28:	2e 7f       	andi	r18, 0xFE	; 254
     a2a:	fc 01       	movw	r30, r24
     a2c:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     a2e:	89 81       	ldd	r24, Y+1	; 0x01
     a30:	9a 81       	ldd	r25, Y+2	; 0x02
     a32:	ab 81       	ldd	r26, Y+3	; 0x03
     a34:	bc 81       	ldd	r27, Y+4	; 0x04
     a36:	07 2e       	mov	r0, r23
     a38:	7a e0       	ldi	r23, 0x0A	; 10
     a3a:	b6 95       	lsr	r27
     a3c:	a7 95       	ror	r26
     a3e:	97 95       	ror	r25
     a40:	87 95       	ror	r24
     a42:	7a 95       	dec	r23
     a44:	d1 f7       	brne	.-12     	; 0xa3a <CO_collectBatt+0x324>
     a46:	70 2d       	mov	r23, r0
     a48:	89 8b       	std	Y+17, r24	; 0x11
     a4a:	9a 8b       	std	Y+18, r25	; 0x12
     a4c:	ab 8b       	std	Y+19, r26	; 0x13
     a4e:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     a50:	84 e0       	ldi	r24, 0x04	; 4
     a52:	60 e0       	ldi	r22, 0x00	; 0
     a54:	0e 94 d3 32 	call	0x65a6	; 0x65a6 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     a58:	80 e0       	ldi	r24, 0x00	; 0
     a5a:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     a5e:	89 89       	ldd	r24, Y+17	; 0x11
     a60:	9a 89       	ldd	r25, Y+18	; 0x12
     a62:	ab 89       	ldd	r26, Y+19	; 0x13
     a64:	bc 89       	ldd	r27, Y+20	; 0x14
     a66:	28 ee       	ldi	r18, 0xE8	; 232
     a68:	33 e0       	ldi	r19, 0x03	; 3
     a6a:	40 e0       	ldi	r20, 0x00	; 0
     a6c:	50 e0       	ldi	r21, 0x00	; 0
     a6e:	bc 01       	movw	r22, r24
     a70:	cd 01       	movw	r24, r26
     a72:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
     a76:	dc 01       	movw	r26, r24
     a78:	cb 01       	movw	r24, r22
     a7a:	2f ef       	ldi	r18, 0xFF	; 255
     a7c:	3f e0       	ldi	r19, 0x0F	; 15
     a7e:	40 e0       	ldi	r20, 0x00	; 0
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	bc 01       	movw	r22, r24
     a84:	cd 01       	movw	r24, r26
     a86:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
     a8a:	da 01       	movw	r26, r20
     a8c:	c9 01       	movw	r24, r18
     a8e:	9c 01       	movw	r18, r24
     a90:	22 53       	subi	r18, 0x32	; 50
     a92:	30 40       	sbci	r19, 0x00	; 0
     a94:	8c a1       	lds	r24, 0x4c
     a96:	9d a1       	lds	r25, 0x4d
     a98:	fc 01       	movw	r30, r24
     a9a:	20 83       	st	Z, r18
     a9c:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     a9e:	89 85       	ldd	r24, Y+9	; 0x09
     aa0:	9a 85       	ldd	r25, Y+10	; 0x0a
     aa2:	ab 85       	ldd	r26, Y+11	; 0x0b
     aa4:	bc 85       	ldd	r27, Y+12	; 0x0c
     aa6:	28 ee       	ldi	r18, 0xE8	; 232
     aa8:	33 e0       	ldi	r19, 0x03	; 3
     aaa:	40 e0       	ldi	r20, 0x00	; 0
     aac:	50 e0       	ldi	r21, 0x00	; 0
     aae:	bc 01       	movw	r22, r24
     ab0:	cd 01       	movw	r24, r26
     ab2:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
     ab6:	dc 01       	movw	r26, r24
     ab8:	cb 01       	movw	r24, r22
     aba:	2f ef       	ldi	r18, 0xFF	; 255
     abc:	3f e0       	ldi	r19, 0x0F	; 15
     abe:	40 e0       	ldi	r20, 0x00	; 0
     ac0:	50 e0       	ldi	r21, 0x00	; 0
     ac2:	bc 01       	movw	r22, r24
     ac4:	cd 01       	movw	r24, r26
     ac6:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
     aca:	da 01       	movw	r26, r20
     acc:	c9 01       	movw	r24, r18
     ace:	9c 01       	movw	r18, r24
     ad0:	22 53       	subi	r18, 0x32	; 50
     ad2:	30 40       	sbci	r19, 0x00	; 0
     ad4:	88 a5       	lds	r24, 0x68
     ad6:	99 a5       	lds	r25, 0x69
     ad8:	fc 01       	movw	r30, r24
     ada:	20 83       	st	Z, r18
     adc:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     ade:	8d 81       	ldd	r24, Y+5	; 0x05
     ae0:	9e 81       	ldd	r25, Y+6	; 0x06
     ae2:	af 81       	ldd	r26, Y+7	; 0x07
     ae4:	b8 85       	ldd	r27, Y+8	; 0x08
     ae6:	28 ee       	ldi	r18, 0xE8	; 232
     ae8:	33 e0       	ldi	r19, 0x03	; 3
     aea:	40 e0       	ldi	r20, 0x00	; 0
     aec:	50 e0       	ldi	r21, 0x00	; 0
     aee:	bc 01       	movw	r22, r24
     af0:	cd 01       	movw	r24, r26
     af2:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
     af6:	dc 01       	movw	r26, r24
     af8:	cb 01       	movw	r24, r22
     afa:	2f ef       	ldi	r18, 0xFF	; 255
     afc:	3f e0       	ldi	r19, 0x0F	; 15
     afe:	40 e0       	ldi	r20, 0x00	; 0
     b00:	50 e0       	ldi	r21, 0x00	; 0
     b02:	bc 01       	movw	r22, r24
     b04:	cd 01       	movw	r24, r26
     b06:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
     b0a:	da 01       	movw	r26, r20
     b0c:	c9 01       	movw	r24, r18
     b0e:	9c 01       	movw	r18, r24
     b10:	22 53       	subi	r18, 0x32	; 50
     b12:	30 40       	sbci	r19, 0x00	; 0
     b14:	8e a1       	lds	r24, 0x4e
     b16:	9f a1       	lds	r25, 0x4f
     b18:	fc 01       	movw	r30, r24
     b1a:	20 83       	st	Z, r18
     b1c:	31 83       	std	Z+1, r19	; 0x01
}
     b1e:	a9 96       	adiw	r28, 0x29	; 41
     b20:	cd bf       	out	0x3d, r28	; 61
     b22:	de bf       	out	0x3e, r29	; 62
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	1f 91       	pop	r17
     b2a:	0f 91       	pop	r16
     b2c:	08 95       	ret

00000b2e <ADCPower>:

void ADCPower(uint8_t on) {
     b2e:	0f 93       	push	r16
     b30:	1f 93       	push	r17
     b32:	cf 93       	push	r28
     b34:	df 93       	push	r29
     b36:	cd b7       	in	r28, 0x3d	; 61
     b38:	de b7       	in	r29, 0x3e	; 62
     b3a:	2f 97       	sbiw	r28, 0x0f	; 15
     b3c:	cd bf       	out	0x3d, r28	; 61
     b3e:	de bf       	out	0x3e, r29	; 62
     b40:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     b42:	8f 85       	ldd	r24, Y+15	; 0x0f
     b44:	88 23       	and	r24, r24
     b46:	09 f4       	brne	.+2      	; 0xb4a <ADCPower+0x1c>
     b48:	ce c0       	rjmp	.+412    	; 0xce6 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	96 e0       	ldi	r25, 0x06	; 6
     b4e:	2e ed       	ldi	r18, 0xDE	; 222
     b50:	fc 01       	movw	r30, r24
     b52:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b54:	80 e2       	ldi	r24, 0x20	; 32
     b56:	96 e0       	ldi	r25, 0x06	; 6
     b58:	2e e0       	ldi	r18, 0x0E	; 14
     b5a:	fc 01       	movw	r30, r24
     b5c:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     b5e:	80 e4       	ldi	r24, 0x40	; 64
     b60:	96 e0       	ldi	r25, 0x06	; 6
     b62:	23 e0       	ldi	r18, 0x03	; 3
     b64:	fc 01       	movw	r30, r24
     b66:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     b68:	80 e8       	ldi	r24, 0x80	; 128
     b6a:	96 e0       	ldi	r25, 0x06	; 6
     b6c:	20 e1       	ldi	r18, 0x10	; 16
     b6e:	fc 01       	movw	r30, r24
     b70:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     b72:	80 ea       	ldi	r24, 0xA0	; 160
     b74:	96 e0       	ldi	r25, 0x06	; 6
     b76:	2e e0       	ldi	r18, 0x0E	; 14
     b78:	fc 01       	movw	r30, r24
     b7a:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	96 e0       	ldi	r25, 0x06	; 6
     b80:	2e e9       	ldi	r18, 0x9E	; 158
     b82:	fc 01       	movw	r30, r24
     b84:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     b86:	80 e2       	ldi	r24, 0x20	; 32
     b88:	96 e0       	ldi	r25, 0x06	; 6
     b8a:	28 e0       	ldi	r18, 0x08	; 8
     b8c:	fc 01       	movw	r30, r24
     b8e:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     b90:	80 e4       	ldi	r24, 0x40	; 64
     b92:	96 e0       	ldi	r25, 0x06	; 6
     b94:	23 e0       	ldi	r18, 0x03	; 3
     b96:	fc 01       	movw	r30, r24
     b98:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     b9a:	80 e8       	ldi	r24, 0x80	; 128
     b9c:	96 e0       	ldi	r25, 0x06	; 6
     b9e:	20 e1       	ldi	r18, 0x10	; 16
     ba0:	fc 01       	movw	r30, r24
     ba2:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     ba4:	80 ea       	ldi	r24, 0xA0	; 160
     ba6:	96 e0       	ldi	r25, 0x06	; 6
     ba8:	2e e0       	ldi	r18, 0x0E	; 14
     baa:	fc 01       	movw	r30, r24
     bac:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     bae:	10 92 76 50 	sts	0x5076, r1
     bb2:	80 e0       	ldi	r24, 0x00	; 0
     bb4:	90 e0       	ldi	r25, 0x00	; 0
     bb6:	a8 ec       	ldi	r26, 0xC8	; 200
     bb8:	b2 e4       	ldi	r27, 0x42	; 66
     bba:	89 83       	std	Y+1, r24	; 0x01
     bbc:	9a 83       	std	Y+2, r25	; 0x02
     bbe:	ab 83       	std	Y+3, r26	; 0x03
     bc0:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     bc2:	69 81       	ldd	r22, Y+1	; 0x01
     bc4:	7a 81       	ldd	r23, Y+2	; 0x02
     bc6:	8b 81       	ldd	r24, Y+3	; 0x03
     bc8:	9c 81       	ldd	r25, Y+4	; 0x04
     bca:	20 e0       	ldi	r18, 0x00	; 0
     bcc:	30 e0       	ldi	r19, 0x00	; 0
     bce:	4a ef       	ldi	r20, 0xFA	; 250
     bd0:	55 e4       	ldi	r21, 0x45	; 69
     bd2:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
     bd6:	dc 01       	movw	r26, r24
     bd8:	cb 01       	movw	r24, r22
     bda:	8d 83       	std	Y+5, r24	; 0x05
     bdc:	9e 83       	std	Y+6, r25	; 0x06
     bde:	af 83       	std	Y+7, r26	; 0x07
     be0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     be2:	11 e0       	ldi	r17, 0x01	; 1
     be4:	6d 81       	ldd	r22, Y+5	; 0x05
     be6:	7e 81       	ldd	r23, Y+6	; 0x06
     be8:	8f 81       	ldd	r24, Y+7	; 0x07
     bea:	98 85       	ldd	r25, Y+8	; 0x08
     bec:	20 e0       	ldi	r18, 0x00	; 0
     bee:	30 e0       	ldi	r19, 0x00	; 0
     bf0:	40 e8       	ldi	r20, 0x80	; 128
     bf2:	5f e3       	ldi	r21, 0x3F	; 63
     bf4:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
     bf8:	88 23       	and	r24, r24
     bfa:	0c f0       	brlt	.+2      	; 0xbfe <ADCPower+0xd0>
     bfc:	10 e0       	ldi	r17, 0x00	; 0
     bfe:	11 23       	and	r17, r17
     c00:	29 f0       	breq	.+10     	; 0xc0c <ADCPower+0xde>
		__ticks = 1;
     c02:	81 e0       	ldi	r24, 0x01	; 1
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	89 87       	std	Y+9, r24	; 0x09
     c08:	9a 87       	std	Y+10, r25	; 0x0a
     c0a:	46 c0       	rjmp	.+140    	; 0xc98 <ADCPower+0x16a>
	else if (__tmp > 65535)
     c0c:	11 e0       	ldi	r17, 0x01	; 1
     c0e:	6d 81       	ldd	r22, Y+5	; 0x05
     c10:	7e 81       	ldd	r23, Y+6	; 0x06
     c12:	8f 81       	ldd	r24, Y+7	; 0x07
     c14:	98 85       	ldd	r25, Y+8	; 0x08
     c16:	20 e0       	ldi	r18, 0x00	; 0
     c18:	3f ef       	ldi	r19, 0xFF	; 255
     c1a:	4f e7       	ldi	r20, 0x7F	; 127
     c1c:	57 e4       	ldi	r21, 0x47	; 71
     c1e:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
     c22:	18 16       	cp	r1, r24
     c24:	0c f0       	brlt	.+2      	; 0xc28 <ADCPower+0xfa>
     c26:	10 e0       	ldi	r17, 0x00	; 0
     c28:	11 23       	and	r17, r17
     c2a:	61 f1       	breq	.+88     	; 0xc84 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c2c:	69 81       	ldd	r22, Y+1	; 0x01
     c2e:	7a 81       	ldd	r23, Y+2	; 0x02
     c30:	8b 81       	ldd	r24, Y+3	; 0x03
     c32:	9c 81       	ldd	r25, Y+4	; 0x04
     c34:	20 e0       	ldi	r18, 0x00	; 0
     c36:	30 e0       	ldi	r19, 0x00	; 0
     c38:	40 e2       	ldi	r20, 0x20	; 32
     c3a:	51 e4       	ldi	r21, 0x41	; 65
     c3c:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
     c40:	dc 01       	movw	r26, r24
     c42:	cb 01       	movw	r24, r22
     c44:	bc 01       	movw	r22, r24
     c46:	cd 01       	movw	r24, r26
     c48:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
     c4c:	dc 01       	movw	r26, r24
     c4e:	cb 01       	movw	r24, r22
     c50:	89 87       	std	Y+9, r24	; 0x09
     c52:	9a 87       	std	Y+10, r25	; 0x0a
     c54:	12 c0       	rjmp	.+36     	; 0xc7a <ADCPower+0x14c>
     c56:	80 e2       	ldi	r24, 0x20	; 32
     c58:	93 e0       	ldi	r25, 0x03	; 3
     c5a:	8b 87       	std	Y+11, r24	; 0x0b
     c5c:	9c 87       	std	Y+12, r25	; 0x0c
     c5e:	8b 85       	ldd	r24, Y+11	; 0x0b
     c60:	9c 85       	ldd	r25, Y+12	; 0x0c
     c62:	8c 01       	movw	r16, r24
     c64:	c8 01       	movw	r24, r16
     c66:	01 97       	sbiw	r24, 0x01	; 1
     c68:	f1 f7       	brne	.-4      	; 0xc66 <ADCPower+0x138>
     c6a:	8c 01       	movw	r16, r24
     c6c:	0b 87       	std	Y+11, r16	; 0x0b
     c6e:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c70:	89 85       	ldd	r24, Y+9	; 0x09
     c72:	9a 85       	ldd	r25, Y+10	; 0x0a
     c74:	01 97       	sbiw	r24, 0x01	; 1
     c76:	89 87       	std	Y+9, r24	; 0x09
     c78:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c7a:	89 85       	ldd	r24, Y+9	; 0x09
     c7c:	9a 85       	ldd	r25, Y+10	; 0x0a
     c7e:	00 97       	sbiw	r24, 0x00	; 0
     c80:	51 f7       	brne	.-44     	; 0xc56 <ADCPower+0x128>
     c82:	17 c0       	rjmp	.+46     	; 0xcb2 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     c84:	6d 81       	ldd	r22, Y+5	; 0x05
     c86:	7e 81       	ldd	r23, Y+6	; 0x06
     c88:	8f 81       	ldd	r24, Y+7	; 0x07
     c8a:	98 85       	ldd	r25, Y+8	; 0x08
     c8c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
     c90:	dc 01       	movw	r26, r24
     c92:	cb 01       	movw	r24, r22
     c94:	89 87       	std	Y+9, r24	; 0x09
     c96:	9a 87       	std	Y+10, r25	; 0x0a
     c98:	89 85       	ldd	r24, Y+9	; 0x09
     c9a:	9a 85       	ldd	r25, Y+10	; 0x0a
     c9c:	8d 87       	std	Y+13, r24	; 0x0d
     c9e:	9e 87       	std	Y+14, r25	; 0x0e
     ca0:	8d 85       	ldd	r24, Y+13	; 0x0d
     ca2:	9e 85       	ldd	r25, Y+14	; 0x0e
     ca4:	8c 01       	movw	r16, r24
     ca6:	f8 01       	movw	r30, r16
     ca8:	31 97       	sbiw	r30, 0x01	; 1
     caa:	f1 f7       	brne	.-4      	; 0xca8 <ADCPower+0x17a>
     cac:	8f 01       	movw	r16, r30
     cae:	0d 87       	std	Y+13, r16	; 0x0d
     cb0:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     cb2:	80 e4       	ldi	r24, 0x40	; 64
     cb4:	96 e0       	ldi	r25, 0x06	; 6
     cb6:	20 e4       	ldi	r18, 0x40	; 64
     cb8:	fc 01       	movw	r30, r24
     cba:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     cbc:	80 e0       	ldi	r24, 0x00	; 0
     cbe:	80 93 77 50 	sts	0x5077, r24
     cc2:	80 93 ca 50 	sts	0x50CA, r24
     cc6:	80 93 c3 23 	sts	0x23C3, r24
     cca:	80 93 6f 50 	sts	0x506F, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     cce:	8f ef       	ldi	r24, 0xFF	; 255
     cd0:	61 e0       	ldi	r22, 0x01	; 1
     cd2:	0e 94 6f 32 	call	0x64de	; 0x64de <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     cd6:	8f ef       	ldi	r24, 0xFF	; 255
     cd8:	61 e0       	ldi	r22, 0x01	; 1
     cda:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     cde:	8f ef       	ldi	r24, 0xFF	; 255
     ce0:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>
     ce4:	42 c0       	rjmp	.+132    	; 0xd6a <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     ce6:	80 e0       	ldi	r24, 0x00	; 0
     ce8:	96 e0       	ldi	r25, 0x06	; 6
     cea:	2e ed       	ldi	r18, 0xDE	; 222
     cec:	fc 01       	movw	r30, r24
     cee:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     cf0:	80 e2       	ldi	r24, 0x20	; 32
     cf2:	96 e0       	ldi	r25, 0x06	; 6
     cf4:	2e e0       	ldi	r18, 0x0E	; 14
     cf6:	fc 01       	movw	r30, r24
     cf8:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     cfa:	80 e4       	ldi	r24, 0x40	; 64
     cfc:	96 e0       	ldi	r25, 0x06	; 6
     cfe:	23 e0       	ldi	r18, 0x03	; 3
     d00:	fc 01       	movw	r30, r24
     d02:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     d04:	80 e8       	ldi	r24, 0x80	; 128
     d06:	96 e0       	ldi	r25, 0x06	; 6
     d08:	20 e1       	ldi	r18, 0x10	; 16
     d0a:	fc 01       	movw	r30, r24
     d0c:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     d0e:	80 ea       	ldi	r24, 0xA0	; 160
     d10:	96 e0       	ldi	r25, 0x06	; 6
     d12:	2e e0       	ldi	r18, 0x0E	; 14
     d14:	fc 01       	movw	r30, r24
     d16:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     d18:	80 e0       	ldi	r24, 0x00	; 0
     d1a:	96 e0       	ldi	r25, 0x06	; 6
     d1c:	2e ed       	ldi	r18, 0xDE	; 222
     d1e:	fc 01       	movw	r30, r24
     d20:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     d22:	80 e2       	ldi	r24, 0x20	; 32
     d24:	96 e0       	ldi	r25, 0x06	; 6
     d26:	2e e0       	ldi	r18, 0x0E	; 14
     d28:	fc 01       	movw	r30, r24
     d2a:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     d2c:	80 e4       	ldi	r24, 0x40	; 64
     d2e:	96 e0       	ldi	r25, 0x06	; 6
     d30:	23 e0       	ldi	r18, 0x03	; 3
     d32:	fc 01       	movw	r30, r24
     d34:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     d36:	80 e8       	ldi	r24, 0x80	; 128
     d38:	96 e0       	ldi	r25, 0x06	; 6
     d3a:	20 e1       	ldi	r18, 0x10	; 16
     d3c:	fc 01       	movw	r30, r24
     d3e:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     d40:	80 ea       	ldi	r24, 0xA0	; 160
     d42:	96 e0       	ldi	r25, 0x06	; 6
     d44:	2e e0       	ldi	r18, 0x0E	; 14
     d46:	fc 01       	movw	r30, r24
     d48:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     d4a:	80 e4       	ldi	r24, 0x40	; 64
     d4c:	96 e0       	ldi	r25, 0x06	; 6
     d4e:	20 e4       	ldi	r18, 0x40	; 64
     d50:	fc 01       	movw	r30, r24
     d52:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     d54:	80 e0       	ldi	r24, 0x00	; 0
     d56:	80 93 77 50 	sts	0x5077, r24
     d5a:	80 93 ca 50 	sts	0x50CA, r24
     d5e:	80 93 c3 23 	sts	0x23C3, r24
     d62:	80 93 6f 50 	sts	0x506F, r24
		channelStatus = 0x00;
     d66:	10 92 76 50 	sts	0x5076, r1
		
	}
}
     d6a:	2f 96       	adiw	r28, 0x0f	; 15
     d6c:	cd bf       	out	0x3d, r28	; 61
     d6e:	de bf       	out	0x3e, r29	; 62
     d70:	df 91       	pop	r29
     d72:	cf 91       	pop	r28
     d74:	1f 91       	pop	r17
     d76:	0f 91       	pop	r16
     d78:	08 95       	ret

00000d7a <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     d7a:	0f 93       	push	r16
     d7c:	1f 93       	push	r17
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
     d82:	cd b7       	in	r28, 0x3d	; 61
     d84:	de b7       	in	r29, 0x3e	; 62
     d86:	6a 97       	sbiw	r28, 0x1a	; 26
     d88:	cd bf       	out	0x3d, r28	; 61
     d8a:	de bf       	out	0x3e, r29	; 62
     d8c:	89 8f       	std	Y+25, r24	; 0x19
     d8e:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     d90:	89 8d       	ldd	r24, Y+25	; 0x19
     d92:	28 2f       	mov	r18, r24
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <set_ampGain+0x26>
     d9c:	88 0f       	add	r24, r24
     d9e:	99 1f       	adc	r25, r25
     da0:	2a 95       	dec	r18
     da2:	e2 f7       	brpl	.-8      	; 0xd9c <set_ampGain+0x22>
     da4:	61 e0       	ldi	r22, 0x01	; 1
     da6:	0e 94 9e 33 	call	0x673c	; 0x673c <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     daa:	8a 8d       	ldd	r24, Y+26	; 0x1a
     dac:	88 2f       	mov	r24, r24
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	81 70       	andi	r24, 0x01	; 1
     db2:	90 70       	andi	r25, 0x00	; 0
     db4:	88 23       	and	r24, r24
     db6:	31 f0       	breq	.+12     	; 0xdc4 <set_ampGain+0x4a>
     db8:	80 e0       	ldi	r24, 0x00	; 0
     dba:	96 e0       	ldi	r25, 0x06	; 6
     dbc:	20 e4       	ldi	r18, 0x40	; 64
     dbe:	fc 01       	movw	r30, r24
     dc0:	25 83       	std	Z+5, r18	; 0x05
     dc2:	05 c0       	rjmp	.+10     	; 0xdce <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	96 e0       	ldi	r25, 0x06	; 6
     dc8:	20 e4       	ldi	r18, 0x40	; 64
     dca:	fc 01       	movw	r30, r24
     dcc:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     dce:	8a 8d       	ldd	r24, Y+26	; 0x1a
     dd0:	88 2f       	mov	r24, r24
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	82 70       	andi	r24, 0x02	; 2
     dd6:	90 70       	andi	r25, 0x00	; 0
     dd8:	00 97       	sbiw	r24, 0x00	; 0
     dda:	31 f0       	breq	.+12     	; 0xde8 <set_ampGain+0x6e>
     ddc:	80 e2       	ldi	r24, 0x20	; 32
     dde:	96 e0       	ldi	r25, 0x06	; 6
     de0:	22 e0       	ldi	r18, 0x02	; 2
     de2:	fc 01       	movw	r30, r24
     de4:	25 83       	std	Z+5, r18	; 0x05
     de6:	05 c0       	rjmp	.+10     	; 0xdf2 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     de8:	80 e2       	ldi	r24, 0x20	; 32
     dea:	96 e0       	ldi	r25, 0x06	; 6
     dec:	22 e0       	ldi	r18, 0x02	; 2
     dee:	fc 01       	movw	r30, r24
     df0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     df2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     df4:	88 2f       	mov	r24, r24
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	84 70       	andi	r24, 0x04	; 4
     dfa:	90 70       	andi	r25, 0x00	; 0
     dfc:	00 97       	sbiw	r24, 0x00	; 0
     dfe:	31 f0       	breq	.+12     	; 0xe0c <set_ampGain+0x92>
     e00:	80 e2       	ldi	r24, 0x20	; 32
     e02:	96 e0       	ldi	r25, 0x06	; 6
     e04:	24 e0       	ldi	r18, 0x04	; 4
     e06:	fc 01       	movw	r30, r24
     e08:	25 83       	std	Z+5, r18	; 0x05
     e0a:	05 c0       	rjmp	.+10     	; 0xe16 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     e0c:	80 e2       	ldi	r24, 0x20	; 32
     e0e:	96 e0       	ldi	r25, 0x06	; 6
     e10:	24 e0       	ldi	r18, 0x04	; 4
     e12:	fc 01       	movw	r30, r24
     e14:	26 83       	std	Z+6, r18	; 0x06
     e16:	80 e0       	ldi	r24, 0x00	; 0
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	a0 e8       	ldi	r26, 0x80	; 128
     e1c:	bf e3       	ldi	r27, 0x3F	; 63
     e1e:	89 83       	std	Y+1, r24	; 0x01
     e20:	9a 83       	std	Y+2, r25	; 0x02
     e22:	ab 83       	std	Y+3, r26	; 0x03
     e24:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     e26:	69 81       	ldd	r22, Y+1	; 0x01
     e28:	7a 81       	ldd	r23, Y+2	; 0x02
     e2a:	8b 81       	ldd	r24, Y+3	; 0x03
     e2c:	9c 81       	ldd	r25, Y+4	; 0x04
     e2e:	2b ea       	ldi	r18, 0xAB	; 171
     e30:	3a ea       	ldi	r19, 0xAA	; 170
     e32:	4a e2       	ldi	r20, 0x2A	; 42
     e34:	51 e4       	ldi	r21, 0x41	; 65
     e36:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
     e3a:	dc 01       	movw	r26, r24
     e3c:	cb 01       	movw	r24, r22
     e3e:	8d 83       	std	Y+5, r24	; 0x05
     e40:	9e 83       	std	Y+6, r25	; 0x06
     e42:	af 83       	std	Y+7, r26	; 0x07
     e44:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     e46:	11 e0       	ldi	r17, 0x01	; 1
     e48:	6d 81       	ldd	r22, Y+5	; 0x05
     e4a:	7e 81       	ldd	r23, Y+6	; 0x06
     e4c:	8f 81       	ldd	r24, Y+7	; 0x07
     e4e:	98 85       	ldd	r25, Y+8	; 0x08
     e50:	20 e0       	ldi	r18, 0x00	; 0
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	40 e8       	ldi	r20, 0x80	; 128
     e56:	5f e3       	ldi	r21, 0x3F	; 63
     e58:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
     e5c:	88 23       	and	r24, r24
     e5e:	0c f0       	brlt	.+2      	; 0xe62 <set_ampGain+0xe8>
     e60:	10 e0       	ldi	r17, 0x00	; 0
     e62:	11 23       	and	r17, r17
     e64:	19 f0       	breq	.+6      	; 0xe6c <set_ampGain+0xf2>
		__ticks = 1;
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	89 87       	std	Y+9, r24	; 0x09
     e6a:	a3 c0       	rjmp	.+326    	; 0xfb2 <set_ampGain+0x238>
	else if (__tmp > 255)
     e6c:	11 e0       	ldi	r17, 0x01	; 1
     e6e:	6d 81       	ldd	r22, Y+5	; 0x05
     e70:	7e 81       	ldd	r23, Y+6	; 0x06
     e72:	8f 81       	ldd	r24, Y+7	; 0x07
     e74:	98 85       	ldd	r25, Y+8	; 0x08
     e76:	20 e0       	ldi	r18, 0x00	; 0
     e78:	30 e0       	ldi	r19, 0x00	; 0
     e7a:	4f e7       	ldi	r20, 0x7F	; 127
     e7c:	53 e4       	ldi	r21, 0x43	; 67
     e7e:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
     e82:	18 16       	cp	r1, r24
     e84:	0c f0       	brlt	.+2      	; 0xe88 <set_ampGain+0x10e>
     e86:	10 e0       	ldi	r17, 0x00	; 0
     e88:	11 23       	and	r17, r17
     e8a:	09 f4       	brne	.+2      	; 0xe8e <set_ampGain+0x114>
     e8c:	89 c0       	rjmp	.+274    	; 0xfa0 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     e8e:	69 81       	ldd	r22, Y+1	; 0x01
     e90:	7a 81       	ldd	r23, Y+2	; 0x02
     e92:	8b 81       	ldd	r24, Y+3	; 0x03
     e94:	9c 81       	ldd	r25, Y+4	; 0x04
     e96:	20 e0       	ldi	r18, 0x00	; 0
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	4a e7       	ldi	r20, 0x7A	; 122
     e9c:	54 e4       	ldi	r21, 0x44	; 68
     e9e:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
     ea2:	dc 01       	movw	r26, r24
     ea4:	cb 01       	movw	r24, r22
     ea6:	8a 87       	std	Y+10, r24	; 0x0a
     ea8:	9b 87       	std	Y+11, r25	; 0x0b
     eaa:	ac 87       	std	Y+12, r26	; 0x0c
     eac:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     eae:	6a 85       	ldd	r22, Y+10	; 0x0a
     eb0:	7b 85       	ldd	r23, Y+11	; 0x0b
     eb2:	8c 85       	ldd	r24, Y+12	; 0x0c
     eb4:	9d 85       	ldd	r25, Y+13	; 0x0d
     eb6:	20 e0       	ldi	r18, 0x00	; 0
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	4a ef       	ldi	r20, 0xFA	; 250
     ebc:	55 e4       	ldi	r21, 0x45	; 69
     ebe:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
     ec2:	dc 01       	movw	r26, r24
     ec4:	cb 01       	movw	r24, r22
     ec6:	8e 87       	std	Y+14, r24	; 0x0e
     ec8:	9f 87       	std	Y+15, r25	; 0x0f
     eca:	a8 8b       	std	Y+16, r26	; 0x10
     ecc:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     ece:	11 e0       	ldi	r17, 0x01	; 1
     ed0:	6e 85       	ldd	r22, Y+14	; 0x0e
     ed2:	7f 85       	ldd	r23, Y+15	; 0x0f
     ed4:	88 89       	ldd	r24, Y+16	; 0x10
     ed6:	99 89       	ldd	r25, Y+17	; 0x11
     ed8:	20 e0       	ldi	r18, 0x00	; 0
     eda:	30 e0       	ldi	r19, 0x00	; 0
     edc:	40 e8       	ldi	r20, 0x80	; 128
     ede:	5f e3       	ldi	r21, 0x3F	; 63
     ee0:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
     ee4:	88 23       	and	r24, r24
     ee6:	0c f0       	brlt	.+2      	; 0xeea <set_ampGain+0x170>
     ee8:	10 e0       	ldi	r17, 0x00	; 0
     eea:	11 23       	and	r17, r17
     eec:	29 f0       	breq	.+10     	; 0xef8 <set_ampGain+0x17e>
		__ticks = 1;
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	8a 8b       	std	Y+18, r24	; 0x12
     ef4:	9b 8b       	std	Y+19, r25	; 0x13
     ef6:	46 c0       	rjmp	.+140    	; 0xf84 <set_ampGain+0x20a>
	else if (__tmp > 65535)
     ef8:	11 e0       	ldi	r17, 0x01	; 1
     efa:	6e 85       	ldd	r22, Y+14	; 0x0e
     efc:	7f 85       	ldd	r23, Y+15	; 0x0f
     efe:	88 89       	ldd	r24, Y+16	; 0x10
     f00:	99 89       	ldd	r25, Y+17	; 0x11
     f02:	20 e0       	ldi	r18, 0x00	; 0
     f04:	3f ef       	ldi	r19, 0xFF	; 255
     f06:	4f e7       	ldi	r20, 0x7F	; 127
     f08:	57 e4       	ldi	r21, 0x47	; 71
     f0a:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
     f0e:	18 16       	cp	r1, r24
     f10:	0c f0       	brlt	.+2      	; 0xf14 <set_ampGain+0x19a>
     f12:	10 e0       	ldi	r17, 0x00	; 0
     f14:	11 23       	and	r17, r17
     f16:	61 f1       	breq	.+88     	; 0xf70 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f18:	6a 85       	ldd	r22, Y+10	; 0x0a
     f1a:	7b 85       	ldd	r23, Y+11	; 0x0b
     f1c:	8c 85       	ldd	r24, Y+12	; 0x0c
     f1e:	9d 85       	ldd	r25, Y+13	; 0x0d
     f20:	20 e0       	ldi	r18, 0x00	; 0
     f22:	30 e0       	ldi	r19, 0x00	; 0
     f24:	40 e2       	ldi	r20, 0x20	; 32
     f26:	51 e4       	ldi	r21, 0x41	; 65
     f28:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
     f2c:	dc 01       	movw	r26, r24
     f2e:	cb 01       	movw	r24, r22
     f30:	bc 01       	movw	r22, r24
     f32:	cd 01       	movw	r24, r26
     f34:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
     f38:	dc 01       	movw	r26, r24
     f3a:	cb 01       	movw	r24, r22
     f3c:	8a 8b       	std	Y+18, r24	; 0x12
     f3e:	9b 8b       	std	Y+19, r25	; 0x13
     f40:	12 c0       	rjmp	.+36     	; 0xf66 <set_ampGain+0x1ec>
     f42:	80 e2       	ldi	r24, 0x20	; 32
     f44:	93 e0       	ldi	r25, 0x03	; 3
     f46:	8c 8b       	std	Y+20, r24	; 0x14
     f48:	9d 8b       	std	Y+21, r25	; 0x15
     f4a:	8c 89       	ldd	r24, Y+20	; 0x14
     f4c:	9d 89       	ldd	r25, Y+21	; 0x15
     f4e:	8c 01       	movw	r16, r24
     f50:	c8 01       	movw	r24, r16
     f52:	01 97       	sbiw	r24, 0x01	; 1
     f54:	f1 f7       	brne	.-4      	; 0xf52 <set_ampGain+0x1d8>
     f56:	8c 01       	movw	r16, r24
     f58:	0c 8b       	std	Y+20, r16	; 0x14
     f5a:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f5c:	8a 89       	ldd	r24, Y+18	; 0x12
     f5e:	9b 89       	ldd	r25, Y+19	; 0x13
     f60:	01 97       	sbiw	r24, 0x01	; 1
     f62:	8a 8b       	std	Y+18, r24	; 0x12
     f64:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f66:	8a 89       	ldd	r24, Y+18	; 0x12
     f68:	9b 89       	ldd	r25, Y+19	; 0x13
     f6a:	00 97       	sbiw	r24, 0x00	; 0
     f6c:	51 f7       	brne	.-44     	; 0xf42 <set_ampGain+0x1c8>
     f6e:	28 c0       	rjmp	.+80     	; 0xfc0 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f70:	6e 85       	ldd	r22, Y+14	; 0x0e
     f72:	7f 85       	ldd	r23, Y+15	; 0x0f
     f74:	88 89       	ldd	r24, Y+16	; 0x10
     f76:	99 89       	ldd	r25, Y+17	; 0x11
     f78:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
     f7c:	dc 01       	movw	r26, r24
     f7e:	cb 01       	movw	r24, r22
     f80:	8a 8b       	std	Y+18, r24	; 0x12
     f82:	9b 8b       	std	Y+19, r25	; 0x13
     f84:	8a 89       	ldd	r24, Y+18	; 0x12
     f86:	9b 89       	ldd	r25, Y+19	; 0x13
     f88:	8e 8b       	std	Y+22, r24	; 0x16
     f8a:	9f 8b       	std	Y+23, r25	; 0x17
     f8c:	8e 89       	ldd	r24, Y+22	; 0x16
     f8e:	9f 89       	ldd	r25, Y+23	; 0x17
     f90:	8c 01       	movw	r16, r24
     f92:	f8 01       	movw	r30, r16
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	f1 f7       	brne	.-4      	; 0xf94 <set_ampGain+0x21a>
     f98:	8f 01       	movw	r16, r30
     f9a:	0e 8b       	std	Y+22, r16	; 0x16
     f9c:	1f 8b       	std	Y+23, r17	; 0x17
     f9e:	10 c0       	rjmp	.+32     	; 0xfc0 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     fa0:	6d 81       	ldd	r22, Y+5	; 0x05
     fa2:	7e 81       	ldd	r23, Y+6	; 0x06
     fa4:	8f 81       	ldd	r24, Y+7	; 0x07
     fa6:	98 85       	ldd	r25, Y+8	; 0x08
     fa8:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
     fac:	dc 01       	movw	r26, r24
     fae:	cb 01       	movw	r24, r22
     fb0:	89 87       	std	Y+9, r24	; 0x09
     fb2:	89 85       	ldd	r24, Y+9	; 0x09
     fb4:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     fb6:	88 8d       	ldd	r24, Y+24	; 0x18
     fb8:	18 2f       	mov	r17, r24
     fba:	1a 95       	dec	r17
     fbc:	f1 f7       	brne	.-4      	; 0xfba <set_ampGain+0x240>
     fbe:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     fc0:	8f ef       	ldi	r24, 0xFF	; 255
     fc2:	61 e0       	ldi	r22, 0x01	; 1
     fc4:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     fc8:	6a 96       	adiw	r28, 0x1a	; 26
     fca:	cd bf       	out	0x3d, r28	; 61
     fcc:	de bf       	out	0x3e, r29	; 62
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	1f 91       	pop	r17
     fd4:	0f 91       	pop	r16
     fd6:	08 95       	ret

00000fd8 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	00 d0       	rcall	.+0      	; 0xfde <set_filter+0x6>
     fde:	cd b7       	in	r28, 0x3d	; 61
     fe0:	de b7       	in	r29, 0x3e	; 62
     fe2:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	83 70       	andi	r24, 0x03	; 3
     fe8:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	8c 70       	andi	r24, 0x0C	; 12
     fee:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	88 2f       	mov	r24, r24
     ff4:	90 e0       	ldi	r25, 0x00	; 0
     ff6:	85 70       	andi	r24, 0x05	; 5
     ff8:	90 70       	andi	r25, 0x00	; 0
     ffa:	00 97       	sbiw	r24, 0x00	; 0
     ffc:	51 f0       	breq	.+20     	; 0x1012 <set_filter+0x3a>
     ffe:	80 91 76 50 	lds	r24, 0x5076
    1002:	98 2f       	mov	r25, r24
    1004:	90 7f       	andi	r25, 0xF0	; 240
    1006:	8b 81       	ldd	r24, Y+3	; 0x03
    1008:	82 95       	swap	r24
    100a:	8f 70       	andi	r24, 0x0F	; 15
    100c:	89 2b       	or	r24, r25
    100e:	80 93 76 50 	sts	0x5076, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    1012:	8b 81       	ldd	r24, Y+3	; 0x03
    1014:	88 2f       	mov	r24, r24
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	8a 70       	andi	r24, 0x0A	; 10
    101a:	90 70       	andi	r25, 0x00	; 0
    101c:	00 97       	sbiw	r24, 0x00	; 0
    101e:	49 f0       	breq	.+18     	; 0x1032 <set_filter+0x5a>
    1020:	8b 81       	ldd	r24, Y+3	; 0x03
    1022:	98 2f       	mov	r25, r24
    1024:	90 7f       	andi	r25, 0xF0	; 240
    1026:	80 91 76 50 	lds	r24, 0x5076
    102a:	8f 70       	andi	r24, 0x0F	; 15
    102c:	89 2b       	or	r24, r25
    102e:	80 93 76 50 	sts	0x5076, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    1032:	84 e0       	ldi	r24, 0x04	; 4
    1034:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    1038:	80 91 76 50 	lds	r24, 0x5076
    103c:	80 93 5a 50 	sts	0x505A, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    1040:	89 81       	ldd	r24, Y+1	; 0x01
    1042:	88 23       	and	r24, r24
    1044:	19 f0       	breq	.+6      	; 0x104c <set_filter+0x74>
    1046:	81 e0       	ldi	r24, 0x01	; 1
    1048:	0e 94 db 36 	call	0x6db6	; 0x6db6 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    104c:	8a 81       	ldd	r24, Y+2	; 0x02
    104e:	88 23       	and	r24, r24
    1050:	19 f0       	breq	.+6      	; 0x1058 <set_filter+0x80>
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	0e 94 f3 36 	call	0x6de6	; 0x6de6 <upperMuxCS>

	SPICS(TRUE);
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    105e:	80 ec       	ldi	r24, 0xC0	; 192
    1060:	98 e0       	ldi	r25, 0x08	; 8
    1062:	2f ef       	ldi	r18, 0xFF	; 255
    1064:	fc 01       	movw	r30, r24
    1066:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1068:	00 00       	nop
    106a:	80 ec       	ldi	r24, 0xC0	; 192
    106c:	98 e0       	ldi	r25, 0x08	; 8
    106e:	fc 01       	movw	r30, r24
    1070:	82 81       	ldd	r24, Z+2	; 0x02
    1072:	88 23       	and	r24, r24
    1074:	d4 f7       	brge	.-12     	; 0x106a <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    1076:	80 ec       	ldi	r24, 0xC0	; 192
    1078:	98 e0       	ldi	r25, 0x08	; 8
    107a:	fc 01       	movw	r30, r24
    107c:	83 81       	ldd	r24, Z+3	; 0x03
    107e:	80 93 66 50 	sts	0x5066, r24

	nop();
    1082:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    1084:	80 ec       	ldi	r24, 0xC0	; 192
    1086:	98 e0       	ldi	r25, 0x08	; 8
    1088:	20 91 5a 50 	lds	r18, 0x505A
    108c:	fc 01       	movw	r30, r24
    108e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1090:	00 00       	nop
    1092:	80 ec       	ldi	r24, 0xC0	; 192
    1094:	98 e0       	ldi	r25, 0x08	; 8
    1096:	fc 01       	movw	r30, r24
    1098:	82 81       	ldd	r24, Z+2	; 0x02
    109a:	88 23       	and	r24, r24
    109c:	d4 f7       	brge	.-12     	; 0x1092 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    109e:	80 ec       	ldi	r24, 0xC0	; 192
    10a0:	98 e0       	ldi	r25, 0x08	; 8
    10a2:	fc 01       	movw	r30, r24
    10a4:	83 81       	ldd	r24, Z+3	; 0x03
    10a6:	80 93 66 50 	sts	0x5066, r24
	SPICS(FALSE);
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    10b0:	89 81       	ldd	r24, Y+1	; 0x01
    10b2:	88 23       	and	r24, r24
    10b4:	19 f0       	breq	.+6      	; 0x10bc <set_filter+0xe4>
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	0e 94 db 36 	call	0x6db6	; 0x6db6 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    10bc:	8a 81       	ldd	r24, Y+2	; 0x02
    10be:	88 23       	and	r24, r24
    10c0:	19 f0       	breq	.+6      	; 0x10c8 <set_filter+0xf0>
    10c2:	80 e0       	ldi	r24, 0x00	; 0
    10c4:	0e 94 f3 36 	call	0x6de6	; 0x6de6 <upperMuxCS>
	SPIDisable();
    10c8:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
}
    10cc:	23 96       	adiw	r28, 0x03	; 3
    10ce:	cd bf       	out	0x3d, r28	; 61
    10d0:	de bf       	out	0x3e, r29	; 62
    10d2:	df 91       	pop	r29
    10d4:	cf 91       	pop	r28
    10d6:	08 95       	ret

000010d8 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    10d8:	cf 93       	push	r28
    10da:	df 93       	push	r29
    10dc:	0f 92       	push	r0
    10de:	cd b7       	in	r28, 0x3d	; 61
    10e0:	de b7       	in	r29, 0x3e	; 62
    10e2:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    10e4:	89 81       	ldd	r24, Y+1	; 0x01
    10e6:	88 23       	and	r24, r24
    10e8:	59 f0       	breq	.+22     	; 0x1100 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    10ea:	80 e0       	ldi	r24, 0x00	; 0
    10ec:	96 e0       	ldi	r25, 0x06	; 6
    10ee:	20 e2       	ldi	r18, 0x20	; 32
    10f0:	fc 01       	movw	r30, r24
    10f2:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    10f4:	80 e0       	ldi	r24, 0x00	; 0
    10f6:	96 e0       	ldi	r25, 0x06	; 6
    10f8:	20 e2       	ldi	r18, 0x20	; 32
    10fa:	fc 01       	movw	r30, r24
    10fc:	25 83       	std	Z+5, r18	; 0x05
    10fe:	0a c0       	rjmp	.+20     	; 0x1114 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	96 e0       	ldi	r25, 0x06	; 6
    1104:	20 e2       	ldi	r18, 0x20	; 32
    1106:	fc 01       	movw	r30, r24
    1108:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	96 e0       	ldi	r25, 0x06	; 6
    110e:	20 e2       	ldi	r18, 0x20	; 32
    1110:	fc 01       	movw	r30, r24
    1112:	22 83       	std	Z+2, r18	; 0x02
	}
}
    1114:	0f 90       	pop	r0
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	08 95       	ret

0000111c <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent, uint32_t numOfSamples, int32_t* DataArray) {
    111c:	cf 92       	push	r12
    111e:	df 92       	push	r13
    1120:	ef 92       	push	r14
    1122:	ff 92       	push	r15
    1124:	0f 93       	push	r16
    1126:	1f 93       	push	r17
    1128:	cf 93       	push	r28
    112a:	df 93       	push	r29
    112c:	cd b7       	in	r28, 0x3d	; 61
    112e:	de b7       	in	r29, 0x3e	; 62
    1130:	2c 97       	sbiw	r28, 0x0c	; 12
    1132:	cd bf       	out	0x3d, r28	; 61
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	8b 83       	std	Y+3, r24	; 0x03
    1138:	6c 83       	std	Y+4, r22	; 0x04
    113a:	4d 83       	std	Y+5, r20	; 0x05
    113c:	2e 83       	std	Y+6, r18	; 0x06
    113e:	ef 82       	std	Y+7, r14	; 0x07
    1140:	f8 86       	std	Y+8, r15	; 0x08
    1142:	09 87       	std	Y+9, r16	; 0x09
    1144:	1a 87       	std	Y+10, r17	; 0x0a
    1146:	cb 86       	std	Y+11, r12	; 0x0b
    1148:	dc 86       	std	Y+12, r13	; 0x0c


	uint16_t period;
	ADC_BUFFER = DataArray;
    114a:	8b 85       	ldd	r24, Y+11	; 0x0b
    114c:	9c 85       	ldd	r25, Y+12	; 0x0c
    114e:	80 93 67 50 	sts	0x5067, r24
    1152:	90 93 68 50 	sts	0x5068, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    115c:	8b 81       	ldd	r24, Y+3	; 0x03
    115e:	6d 81       	ldd	r22, Y+5	; 0x05
    1160:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_filter(filterConfig);
    1164:	8c 81       	ldd	r24, Y+4	; 0x04
    1166:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    116a:	8b 81       	ldd	r24, Y+3	; 0x03
    116c:	85 30       	cpi	r24, 0x05	; 5
    116e:	31 f0       	breq	.+12     	; 0x117c <CO_collectADC+0x60>
    1170:	8b 81       	ldd	r24, Y+3	; 0x03
    1172:	86 30       	cpi	r24, 0x06	; 6
    1174:	19 f0       	breq	.+6      	; 0x117c <CO_collectADC+0x60>
    1176:	8b 81       	ldd	r24, Y+3	; 0x03
    1178:	87 30       	cpi	r24, 0x07	; 7
    117a:	19 f4       	brne	.+6      	; 0x1182 <CO_collectADC+0x66>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1182:	81 e0       	ldi	r24, 0x01	; 1
    1184:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	setADCInput(channel);
    1188:	8b 81       	ldd	r24, Y+3	; 0x03
    118a:	0e 94 a5 19 	call	0x334a	; 0x334a <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    118e:	84 e0       	ldi	r24, 0x04	; 4
    1190:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1194:	80 ec       	ldi	r24, 0xC0	; 192
    1196:	98 e0       	ldi	r25, 0x08	; 8
    1198:	24 e5       	ldi	r18, 0x54	; 84
    119a:	fc 01       	movw	r30, r24
    119c:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    119e:	80 ea       	ldi	r24, 0xA0	; 160
    11a0:	96 e0       	ldi	r25, 0x06	; 6
    11a2:	21 e0       	ldi	r18, 0x01	; 1
    11a4:	fc 01       	movw	r30, r24
    11a6:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    11a8:	80 ea       	ldi	r24, 0xA0	; 160
    11aa:	96 e0       	ldi	r25, 0x06	; 6
    11ac:	22 e0       	ldi	r18, 0x02	; 2
    11ae:	fc 01       	movw	r30, r24
    11b0:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    11b2:	80 ea       	ldi	r24, 0xA0	; 160
    11b4:	96 e0       	ldi	r25, 0x06	; 6
    11b6:	21 e0       	ldi	r18, 0x01	; 1
    11b8:	fc 01       	movw	r30, r24
    11ba:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    11bc:	80 ea       	ldi	r24, 0xA0	; 160
    11be:	96 e0       	ldi	r25, 0x06	; 6
    11c0:	21 e0       	ldi	r18, 0x01	; 1
    11c2:	fc 01       	movw	r30, r24
    11c4:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    11c6:	80 e8       	ldi	r24, 0x80	; 128
    11c8:	96 e0       	ldi	r25, 0x06	; 6
    11ca:	20 e2       	ldi	r18, 0x20	; 32
    11cc:	fc 01       	movw	r30, r24
    11ce:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    11d0:	80 e4       	ldi	r24, 0x40	; 64
    11d2:	9a e0       	ldi	r25, 0x0A	; 10
    11d4:	23 e2       	ldi	r18, 0x23	; 35
    11d6:	fc 01       	movw	r30, r24
    11d8:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    11da:	8e 81       	ldd	r24, Y+6	; 0x06
    11dc:	88 2f       	mov	r24, r24
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	25 e1       	ldi	r18, 0x15	; 21
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	28 1b       	sub	r18, r24
    11e6:	39 0b       	sbc	r19, r25
    11e8:	81 e0       	ldi	r24, 0x01	; 1
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	02 c0       	rjmp	.+4      	; 0x11f2 <CO_collectADC+0xd6>
    11ee:	88 0f       	add	r24, r24
    11f0:	99 1f       	adc	r25, r25
    11f2:	2a 95       	dec	r18
    11f4:	e2 f7       	brpl	.-8      	; 0x11ee <CO_collectADC+0xd2>
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	89 83       	std	Y+1, r24	; 0x01
    11fa:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    11fc:	80 e4       	ldi	r24, 0x40	; 64
    11fe:	9a e0       	ldi	r25, 0x0A	; 10
    1200:	29 81       	ldd	r18, Y+1	; 0x01
    1202:	3a 81       	ldd	r19, Y+2	; 0x02
    1204:	fc 01       	movw	r30, r24
    1206:	26 a3       	lds	r18, 0x56
    1208:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    120a:	80 e4       	ldi	r24, 0x40	; 64
    120c:	9a e0       	ldi	r25, 0x0A	; 10
    120e:	29 81       	ldd	r18, Y+1	; 0x01
    1210:	3a 81       	ldd	r19, Y+2	; 0x02
    1212:	36 95       	lsr	r19
    1214:	27 95       	ror	r18
    1216:	fc 01       	movw	r30, r24
    1218:	22 af       	sts	0x72, r18
    121a:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    121c:	80 e4       	ldi	r24, 0x40	; 64
    121e:	9a e0       	ldi	r25, 0x0A	; 10
    1220:	20 e4       	ldi	r18, 0x40	; 64
    1222:	3a e0       	ldi	r19, 0x0A	; 10
    1224:	f9 01       	movw	r30, r18
    1226:	20 81       	ld	r18, Z
    1228:	20 7f       	andi	r18, 0xF0	; 240
    122a:	21 60       	ori	r18, 0x01	; 1
    122c:	fc 01       	movw	r30, r24
    122e:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1230:	80 ea       	ldi	r24, 0xA0	; 160
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	20 ea       	ldi	r18, 0xA0	; 160
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	f9 01       	movw	r30, r18
    123a:	22 81       	ldd	r18, Z+2	; 0x02
    123c:	21 60       	ori	r18, 0x01	; 1
    123e:	fc 01       	movw	r30, r24
    1240:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1242:	78 94       	sei

	sampleCount = 0;
    1244:	10 92 69 50 	sts	0x5069, r1
    1248:	10 92 6a 50 	sts	0x506A, r1
    124c:	10 92 6b 50 	sts	0x506B, r1
    1250:	10 92 6c 50 	sts	0x506C, r1
	discardCount = 0;
    1254:	10 92 52 40 	sts	0x4052, r1
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    1258:	00 00       	nop
    125a:	20 91 69 50 	lds	r18, 0x5069
    125e:	30 91 6a 50 	lds	r19, 0x506A
    1262:	40 91 6b 50 	lds	r20, 0x506B
    1266:	50 91 6c 50 	lds	r21, 0x506C
    126a:	8f 81       	ldd	r24, Y+7	; 0x07
    126c:	98 85       	ldd	r25, Y+8	; 0x08
    126e:	a9 85       	ldd	r26, Y+9	; 0x09
    1270:	ba 85       	ldd	r27, Y+10	; 0x0a
    1272:	28 17       	cp	r18, r24
    1274:	39 07       	cpc	r19, r25
    1276:	4a 07       	cpc	r20, r26
    1278:	5b 07       	cpc	r21, r27
    127a:	78 f3       	brcs	.-34     	; 0x125a <CO_collectADC+0x13e>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    127c:	80 e4       	ldi	r24, 0x40	; 64
    127e:	9a e0       	ldi	r25, 0x0A	; 10
    1280:	20 e4       	ldi	r18, 0x40	; 64
    1282:	3a e0       	ldi	r19, 0x0A	; 10
    1284:	f9 01       	movw	r30, r18
    1286:	20 81       	ld	r18, Z
    1288:	20 7f       	andi	r18, 0xF0	; 240
    128a:	fc 01       	movw	r30, r24
    128c:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    128e:	80 ea       	ldi	r24, 0xA0	; 160
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	20 ea       	ldi	r18, 0xA0	; 160
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	f9 01       	movw	r30, r18
    1298:	22 81       	ldd	r18, Z+2	; 0x02
    129a:	2e 7f       	andi	r18, 0xFE	; 254
    129c:	fc 01       	movw	r30, r24
    129e:	22 83       	std	Z+2, r18	; 0x02
	cli();
    12a0:	f8 94       	cli

	SPIDisable();	
    12a2:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	enableADCMUX(FALSE);
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	ADCPower(FALSE);
    12ac:	80 e0       	ldi	r24, 0x00	; 0
    12ae:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
}
    12b2:	2c 96       	adiw	r28, 0x0c	; 12
    12b4:	cd bf       	out	0x3d, r28	; 61
    12b6:	de bf       	out	0x3e, r29	; 62
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	ff 90       	pop	r15
    12c2:	ef 90       	pop	r14
    12c4:	df 90       	pop	r13
    12c6:	cf 90       	pop	r12
    12c8:	08 95       	ret

000012ca <CO_collectADC_cont>:

//continuously take samples and send them via radio. NOT RECOMMENDET
void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    12ca:	cf 93       	push	r28
    12cc:	df 93       	push	r29
    12ce:	00 d0       	rcall	.+0      	; 0x12d0 <CO_collectADC_cont+0x6>
    12d0:	00 d0       	rcall	.+0      	; 0x12d2 <CO_collectADC_cont+0x8>
    12d2:	cd b7       	in	r28, 0x3d	; 61
    12d4:	de b7       	in	r29, 0x3e	; 62
    12d6:	8b 83       	std	Y+3, r24	; 0x03
    12d8:	6c 83       	std	Y+4, r22	; 0x04
    12da:	4d 83       	std	Y+5, r20	; 0x05
    12dc:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
//get data to write files to SD card
//getBootSectorData();
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    12e4:	8b 81       	ldd	r24, Y+3	; 0x03
    12e6:	6d 81       	ldd	r22, Y+5	; 0x05
    12e8:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
set_filter(filterConfig);
    12ec:	8c 81       	ldd	r24, Y+4	; 0x04
    12ee:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	85 30       	cpi	r24, 0x05	; 5
    12f6:	31 f0       	breq	.+12     	; 0x1304 <CO_collectADC_cont+0x3a>
    12f8:	8b 81       	ldd	r24, Y+3	; 0x03
    12fa:	86 30       	cpi	r24, 0x06	; 6
    12fc:	19 f0       	breq	.+6      	; 0x1304 <CO_collectADC_cont+0x3a>
    12fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1300:	87 30       	cpi	r24, 0x07	; 7
    1302:	19 f4       	brne	.+6      	; 0x130a <CO_collectADC_cont+0x40>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>

enableADCMUX(TRUE);
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
setADCInput(channel);
    1310:	8b 81       	ldd	r24, Y+3	; 0x03
    1312:	0e 94 a5 19 	call	0x334a	; 0x334a <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1316:	84 e0       	ldi	r24, 0x04	; 4
    1318:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    131c:	80 ec       	ldi	r24, 0xC0	; 192
    131e:	98 e0       	ldi	r25, 0x08	; 8
    1320:	24 e5       	ldi	r18, 0x54	; 84
    1322:	fc 01       	movw	r30, r24
    1324:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1326:	80 ea       	ldi	r24, 0xA0	; 160
    1328:	96 e0       	ldi	r25, 0x06	; 6
    132a:	21 e0       	ldi	r18, 0x01	; 1
    132c:	fc 01       	movw	r30, r24
    132e:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1330:	80 ea       	ldi	r24, 0xA0	; 160
    1332:	96 e0       	ldi	r25, 0x06	; 6
    1334:	22 e0       	ldi	r18, 0x02	; 2
    1336:	fc 01       	movw	r30, r24
    1338:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    133a:	80 ea       	ldi	r24, 0xA0	; 160
    133c:	96 e0       	ldi	r25, 0x06	; 6
    133e:	21 e0       	ldi	r18, 0x01	; 1
    1340:	fc 01       	movw	r30, r24
    1342:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_MED_gc;
    1344:	80 ea       	ldi	r24, 0xA0	; 160
    1346:	96 e0       	ldi	r25, 0x06	; 6
    1348:	28 e0       	ldi	r18, 0x08	; 8
    134a:	fc 01       	movw	r30, r24
    134c:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    134e:	80 e8       	ldi	r24, 0x80	; 128
    1350:	96 e0       	ldi	r25, 0x06	; 6
    1352:	20 e2       	ldi	r18, 0x20	; 32
    1354:	fc 01       	movw	r30, r24
    1356:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1358:	80 e4       	ldi	r24, 0x40	; 64
    135a:	9a e0       	ldi	r25, 0x0A	; 10
    135c:	23 e2       	ldi	r18, 0x23	; 35
    135e:	fc 01       	movw	r30, r24
    1360:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1362:	8e 81       	ldd	r24, Y+6	; 0x06
    1364:	88 2f       	mov	r24, r24
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	25 e1       	ldi	r18, 0x15	; 21
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	28 1b       	sub	r18, r24
    136e:	39 0b       	sbc	r19, r25
    1370:	81 e0       	ldi	r24, 0x01	; 1
    1372:	90 e0       	ldi	r25, 0x00	; 0
    1374:	02 c0       	rjmp	.+4      	; 0x137a <CO_collectADC_cont+0xb0>
    1376:	88 0f       	add	r24, r24
    1378:	99 1f       	adc	r25, r25
    137a:	2a 95       	dec	r18
    137c:	e2 f7       	brpl	.-8      	; 0x1376 <CO_collectADC_cont+0xac>
    137e:	01 97       	sbiw	r24, 0x01	; 1
    1380:	89 83       	std	Y+1, r24	; 0x01
    1382:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1384:	80 e4       	ldi	r24, 0x40	; 64
    1386:	9a e0       	ldi	r25, 0x0A	; 10
    1388:	29 81       	ldd	r18, Y+1	; 0x01
    138a:	3a 81       	ldd	r19, Y+2	; 0x02
    138c:	fc 01       	movw	r30, r24
    138e:	26 a3       	lds	r18, 0x56
    1390:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1392:	80 e4       	ldi	r24, 0x40	; 64
    1394:	9a e0       	ldi	r25, 0x0A	; 10
    1396:	29 81       	ldd	r18, Y+1	; 0x01
    1398:	3a 81       	ldd	r19, Y+2	; 0x02
    139a:	36 95       	lsr	r19
    139c:	27 95       	ror	r18
    139e:	fc 01       	movw	r30, r24
    13a0:	22 af       	sts	0x72, r18
    13a2:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    13a4:	80 e4       	ldi	r24, 0x40	; 64
    13a6:	9a e0       	ldi	r25, 0x0A	; 10
    13a8:	20 e4       	ldi	r18, 0x40	; 64
    13aa:	3a e0       	ldi	r19, 0x0A	; 10
    13ac:	f9 01       	movw	r30, r18
    13ae:	20 81       	ld	r18, Z
    13b0:	20 7f       	andi	r18, 0xF0	; 240
    13b2:	21 60       	ori	r18, 0x01	; 1
    13b4:	fc 01       	movw	r30, r24
    13b6:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_MEDLVLEN_bm;
    13b8:	80 ea       	ldi	r24, 0xA0	; 160
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	20 ea       	ldi	r18, 0xA0	; 160
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	f9 01       	movw	r30, r18
    13c2:	22 81       	ldd	r18, Z+2	; 0x02
    13c4:	22 60       	ori	r18, 0x02	; 2
    13c6:	fc 01       	movw	r30, r24
    13c8:	22 83       	std	Z+2, r18	; 0x02
//enable RR of lowlvl interrupts
PMIC.CTRL |= PMIC_RREN_bm; 
    13ca:	80 ea       	ldi	r24, 0xA0	; 160
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	20 ea       	ldi	r18, 0xA0	; 160
    13d0:	30 e0       	ldi	r19, 0x00	; 0
    13d2:	f9 01       	movw	r30, r18
    13d4:	22 81       	ldd	r18, Z+2	; 0x02
    13d6:	20 68       	ori	r18, 0x80	; 128
    13d8:	fc 01       	movw	r30, r24
    13da:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
// chb_init();
// chb_set_short_addr(moteID);

sampleCount = 0;
    13dc:	10 92 69 50 	sts	0x5069, r1
    13e0:	10 92 6a 50 	sts	0x506A, r1
    13e4:	10 92 6b 50 	sts	0x506B, r1
    13e8:	10 92 6c 50 	sts	0x506C, r1
TotalSampleCount = 0;
    13ec:	10 92 99 50 	sts	0x5099, r1
    13f0:	10 92 9a 50 	sts	0x509A, r1
discardCount = 0;
    13f4:	10 92 52 40 	sts	0x4052, r1
sei();
    13f8:	78 94       	sei
}
    13fa:	26 96       	adiw	r28, 0x06	; 6
    13fc:	cd bf       	out	0x3d, r28	; 61
    13fe:	de bf       	out	0x3e, r29	; 62
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	08 95       	ret

00001406 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	cd b7       	in	r28, 0x3d	; 61
    140c:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    140e:	80 ea       	ldi	r24, 0xA0	; 160
    1410:	96 e0       	ldi	r25, 0x06	; 6
    1412:	fc 01       	movw	r30, r24
    1414:	13 86       	std	Z+11, r1	; 0x0b
}
    1416:	df 91       	pop	r29
    1418:	cf 91       	pop	r28
    141a:	08 95       	ret

0000141c <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	cd b7       	in	r28, 0x3d	; 61
    1422:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1424:	80 ea       	ldi	r24, 0xA0	; 160
    1426:	96 e0       	ldi	r25, 0x06	; 6
    1428:	21 e0       	ldi	r18, 0x01	; 1
    142a:	fc 01       	movw	r30, r24
    142c:	23 87       	std	Z+11, r18	; 0x0b
}	
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	08 95       	ret

00001434 <__vector_105>:

//ISR used by CO_collectADC_cont function
ISR(PORTF_INT1_vect) {
    1434:	1f 92       	push	r1
    1436:	0f 92       	push	r0
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	0f 92       	push	r0
    143c:	00 90 3b 00 	lds	r0, 0x003B
    1440:	0f 92       	push	r0
    1442:	11 24       	eor	r1, r1
    1444:	2f 92       	push	r2
    1446:	3f 92       	push	r3
    1448:	4f 92       	push	r4
    144a:	5f 92       	push	r5
    144c:	6f 92       	push	r6
    144e:	7f 92       	push	r7
    1450:	8f 92       	push	r8
    1452:	9f 92       	push	r9
    1454:	af 92       	push	r10
    1456:	bf 92       	push	r11
    1458:	cf 92       	push	r12
    145a:	df 92       	push	r13
    145c:	ef 92       	push	r14
    145e:	ff 92       	push	r15
    1460:	0f 93       	push	r16
    1462:	1f 93       	push	r17
    1464:	2f 93       	push	r18
    1466:	3f 93       	push	r19
    1468:	4f 93       	push	r20
    146a:	5f 93       	push	r21
    146c:	6f 93       	push	r22
    146e:	7f 93       	push	r23
    1470:	8f 93       	push	r24
    1472:	9f 93       	push	r25
    1474:	af 93       	push	r26
    1476:	bf 93       	push	r27
    1478:	ef 93       	push	r30
    147a:	ff 93       	push	r31
    147c:	cf 93       	push	r28
    147e:	df 93       	push	r29
    1480:	00 d0       	rcall	.+0      	; 0x1482 <__vector_105+0x4e>
    1482:	cd b7       	in	r28, 0x3d	; 61
    1484:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1486:	80 91 52 40 	lds	r24, 0x4052
    148a:	88 23       	and	r24, r24
    148c:	34 f0       	brlt	.+12     	; 0x149a <__vector_105+0x66>
		discardCount++;
    148e:	80 91 52 40 	lds	r24, 0x4052
    1492:	8f 5f       	subi	r24, 0xFF	; 255
    1494:	80 93 52 40 	sts	0x4052, r24
    1498:	af c1       	rjmp	.+862    	; 0x17f8 <__vector_105+0x3c4>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    149a:	84 e0       	ldi	r24, 0x04	; 4
    149c:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    14a0:	80 ec       	ldi	r24, 0xC0	; 192
    14a2:	98 e0       	ldi	r25, 0x08	; 8
    14a4:	24 e5       	ldi	r18, 0x54	; 84
    14a6:	fc 01       	movw	r30, r24
    14a8:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    14b0:	80 ea       	ldi	r24, 0xA0	; 160
    14b2:	96 e0       	ldi	r25, 0x06	; 6
    14b4:	22 e0       	ldi	r18, 0x02	; 2
    14b6:	fc 01       	movw	r30, r24
    14b8:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    14ba:	19 82       	std	Y+1, r1	; 0x01
    14bc:	1a c0       	rjmp	.+52     	; 0x14f2 <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    14be:	80 ec       	ldi	r24, 0xC0	; 192
    14c0:	98 e0       	ldi	r25, 0x08	; 8
    14c2:	2a ea       	ldi	r18, 0xAA	; 170
    14c4:	fc 01       	movw	r30, r24
    14c6:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    14c8:	00 00       	nop
    14ca:	80 ec       	ldi	r24, 0xC0	; 192
    14cc:	98 e0       	ldi	r25, 0x08	; 8
    14ce:	fc 01       	movw	r30, r24
    14d0:	82 81       	ldd	r24, Z+2	; 0x02
    14d2:	88 23       	and	r24, r24
    14d4:	d4 f7       	brge	.-12     	; 0x14ca <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	88 2f       	mov	r24, r24
    14da:	90 e0       	ldi	r25, 0x00	; 0
    14dc:	20 ec       	ldi	r18, 0xC0	; 192
    14de:	38 e0       	ldi	r19, 0x08	; 8
    14e0:	f9 01       	movw	r30, r18
    14e2:	23 81       	ldd	r18, Z+3	; 0x03
    14e4:	86 5a       	subi	r24, 0xA6	; 166
    14e6:	9f 4a       	sbci	r25, 0xAF	; 175
    14e8:	fc 01       	movw	r30, r24
    14ea:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    14ec:	89 81       	ldd	r24, Y+1	; 0x01
    14ee:	8f 5f       	subi	r24, 0xFF	; 255
    14f0:	89 83       	std	Y+1, r24	; 0x01
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
    14f4:	83 30       	cpi	r24, 0x03	; 3
    14f6:	18 f3       	brcs	.-58     	; 0x14be <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    14f8:	80 ea       	ldi	r24, 0xA0	; 160
    14fa:	96 e0       	ldi	r25, 0x06	; 6
    14fc:	22 e0       	ldi	r18, 0x02	; 2
    14fe:	fc 01       	movw	r30, r24
    1500:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1502:	80 e0       	ldi	r24, 0x00	; 0
    1504:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1508:	80 91 5a 50 	lds	r24, 0x505A
    150c:	88 23       	and	r24, r24
    150e:	34 f4       	brge	.+12     	; 0x151c <__vector_105+0xe8>
    1510:	8b e5       	ldi	r24, 0x5B	; 91
    1512:	90 e4       	ldi	r25, 0x40	; 64
    1514:	2f ef       	ldi	r18, 0xFF	; 255
    1516:	fc 01       	movw	r30, r24
    1518:	20 83       	st	Z, r18
    151a:	04 c0       	rjmp	.+8      	; 0x1524 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    151c:	8b e5       	ldi	r24, 0x5B	; 91
    151e:	90 e4       	ldi	r25, 0x40	; 64
    1520:	fc 01       	movw	r30, r24
    1522:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1524:	8a e5       	ldi	r24, 0x5A	; 90
    1526:	90 e4       	ldi	r25, 0x40	; 64
    1528:	20 91 5a 50 	lds	r18, 0x505A
    152c:	fc 01       	movw	r30, r24
    152e:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1530:	89 e5       	ldi	r24, 0x59	; 89
    1532:	90 e4       	ldi	r25, 0x40	; 64
    1534:	20 91 5b 50 	lds	r18, 0x505B
    1538:	fc 01       	movw	r30, r24
    153a:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    153c:	88 e5       	ldi	r24, 0x58	; 88
    153e:	90 e4       	ldi	r25, 0x40	; 64
    1540:	20 91 5c 50 	lds	r18, 0x505C
    1544:	fc 01       	movw	r30, r24
    1546:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    1548:	80 91 58 40 	lds	r24, 0x4058
    154c:	90 91 59 40 	lds	r25, 0x4059
    1550:	a0 91 5a 40 	lds	r26, 0x405A
    1554:	b0 91 5b 40 	lds	r27, 0x405B
    1558:	5c 01       	movw	r10, r24
    155a:	6d 01       	movw	r12, r26
    155c:	bb 0f       	add	r27, r27
    155e:	88 0b       	sbc	r24, r24
    1560:	98 2f       	mov	r25, r24
    1562:	dc 01       	movw	r26, r24
    1564:	e8 2e       	mov	r14, r24
    1566:	f8 2e       	mov	r15, r24
    1568:	08 2f       	mov	r16, r24
    156a:	18 2f       	mov	r17, r24
    156c:	a0 92 9b 50 	sts	0x509B, r10
    1570:	b0 92 9c 50 	sts	0x509C, r11
    1574:	c0 92 9d 50 	sts	0x509D, r12
    1578:	d0 92 9e 50 	sts	0x509E, r13
    157c:	e0 92 9f 50 	sts	0x509F, r14
    1580:	f0 92 a0 50 	sts	0x50A0, r15
    1584:	00 93 a1 50 	sts	0x50A1, r16
    1588:	10 93 a2 50 	sts	0x50A2, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    158c:	80 91 69 50 	lds	r24, 0x5069
    1590:	90 91 6a 50 	lds	r25, 0x506A
    1594:	a0 91 6b 50 	lds	r26, 0x506B
    1598:	b0 91 6c 50 	lds	r27, 0x506C
    159c:	88 0f       	add	r24, r24
    159e:	99 1f       	adc	r25, r25
    15a0:	88 0f       	add	r24, r24
    15a2:	99 1f       	adc	r25, r25
    15a4:	9c 01       	movw	r18, r24
    15a6:	24 53       	subi	r18, 0x34	; 52
    15a8:	3c 4d       	sbci	r19, 0xDC	; 220
    15aa:	2a 83       	std	Y+2, r18	; 0x02
    15ac:	3b 83       	std	Y+3, r19	; 0x03
    15ae:	a0 90 9b 50 	lds	r10, 0x509B
    15b2:	b0 90 9c 50 	lds	r11, 0x509C
    15b6:	c0 90 9d 50 	lds	r12, 0x509D
    15ba:	d0 90 9e 50 	lds	r13, 0x509E
    15be:	e0 90 9f 50 	lds	r14, 0x509F
    15c2:	f0 90 a0 50 	lds	r15, 0x50A0
    15c6:	00 91 a1 50 	lds	r16, 0x50A1
    15ca:	10 91 a2 50 	lds	r17, 0x50A2
    15ce:	2a 2d       	mov	r18, r10
    15d0:	3b 2d       	mov	r19, r11
    15d2:	4c 2d       	mov	r20, r12
    15d4:	5d 2d       	mov	r21, r13
    15d6:	6e 2d       	mov	r22, r14
    15d8:	7f 2d       	mov	r23, r15
    15da:	80 2f       	mov	r24, r16
    15dc:	91 2f       	mov	r25, r17
    15de:	0f 2e       	mov	r0, r31
    15e0:	f0 ea       	ldi	r31, 0xA0	; 160
    15e2:	af 2e       	mov	r10, r31
    15e4:	f0 2d       	mov	r31, r0
    15e6:	0f 2e       	mov	r0, r31
    15e8:	f5 e2       	ldi	r31, 0x25	; 37
    15ea:	bf 2e       	mov	r11, r31
    15ec:	f0 2d       	mov	r31, r0
    15ee:	0f 2e       	mov	r0, r31
    15f0:	f6 e2       	ldi	r31, 0x26	; 38
    15f2:	cf 2e       	mov	r12, r31
    15f4:	f0 2d       	mov	r31, r0
    15f6:	dd 24       	eor	r13, r13
    15f8:	ee 24       	eor	r14, r14
    15fa:	ff 24       	eor	r15, r15
    15fc:	00 e0       	ldi	r16, 0x00	; 0
    15fe:	10 e0       	ldi	r17, 0x00	; 0
    1600:	0e 94 e8 50 	call	0xa1d0	; 0xa1d0 <__muldi3>
    1604:	22 2e       	mov	r2, r18
    1606:	33 2e       	mov	r3, r19
    1608:	44 2e       	mov	r4, r20
    160a:	55 2e       	mov	r5, r21
    160c:	66 2e       	mov	r6, r22
    160e:	77 2e       	mov	r7, r23
    1610:	88 2e       	mov	r8, r24
    1612:	99 2e       	mov	r9, r25
    1614:	a2 2c       	mov	r10, r2
    1616:	b3 2c       	mov	r11, r3
    1618:	c4 2c       	mov	r12, r4
    161a:	d5 2c       	mov	r13, r5
    161c:	e6 2c       	mov	r14, r6
    161e:	f7 2c       	mov	r15, r7
    1620:	08 2d       	mov	r16, r8
    1622:	19 2d       	mov	r17, r9
    1624:	2a 2d       	mov	r18, r10
    1626:	3b 2d       	mov	r19, r11
    1628:	4c 2d       	mov	r20, r12
    162a:	5d 2d       	mov	r21, r13
    162c:	6e 2d       	mov	r22, r14
    162e:	7f 2d       	mov	r23, r15
    1630:	80 2f       	mov	r24, r16
    1632:	91 2f       	mov	r25, r17
    1634:	aa 24       	eor	r10, r10
    1636:	aa 94       	dec	r10
    1638:	bb 24       	eor	r11, r11
    163a:	ba 94       	dec	r11
    163c:	0f 2e       	mov	r0, r31
    163e:	ff e7       	ldi	r31, 0x7F	; 127
    1640:	cf 2e       	mov	r12, r31
    1642:	f0 2d       	mov	r31, r0
    1644:	dd 24       	eor	r13, r13
    1646:	ee 24       	eor	r14, r14
    1648:	ff 24       	eor	r15, r15
    164a:	00 e0       	ldi	r16, 0x00	; 0
    164c:	10 e0       	ldi	r17, 0x00	; 0
    164e:	0e 94 2f 52 	call	0xa45e	; 0xa45e <__divdi3>
    1652:	22 2e       	mov	r2, r18
    1654:	33 2e       	mov	r3, r19
    1656:	44 2e       	mov	r4, r20
    1658:	55 2e       	mov	r5, r21
    165a:	66 2e       	mov	r6, r22
    165c:	77 2e       	mov	r7, r23
    165e:	88 2e       	mov	r8, r24
    1660:	99 2e       	mov	r9, r25
    1662:	a2 2c       	mov	r10, r2
    1664:	b3 2c       	mov	r11, r3
    1666:	c4 2c       	mov	r12, r4
    1668:	d5 2c       	mov	r13, r5
    166a:	e6 2c       	mov	r14, r6
    166c:	f7 2c       	mov	r15, r7
    166e:	08 2d       	mov	r16, r8
    1670:	19 2d       	mov	r17, r9
    1672:	2a 2d       	mov	r18, r10
    1674:	3b 2d       	mov	r19, r11
    1676:	4c 2d       	mov	r20, r12
    1678:	5d 2d       	mov	r21, r13
    167a:	6e 2d       	mov	r22, r14
    167c:	7f 2d       	mov	r23, r15
    167e:	80 2f       	mov	r24, r16
    1680:	91 2f       	mov	r25, r17
    1682:	01 e0       	ldi	r16, 0x01	; 1
    1684:	0e 94 bb 51 	call	0xa376	; 0xa376 <__ashldi3>
    1688:	22 2e       	mov	r2, r18
    168a:	33 2e       	mov	r3, r19
    168c:	44 2e       	mov	r4, r20
    168e:	55 2e       	mov	r5, r21
    1690:	66 2e       	mov	r6, r22
    1692:	77 2e       	mov	r7, r23
    1694:	88 2e       	mov	r8, r24
    1696:	99 2e       	mov	r9, r25
    1698:	a2 2c       	mov	r10, r2
    169a:	b3 2c       	mov	r11, r3
    169c:	c4 2c       	mov	r12, r4
    169e:	d5 2c       	mov	r13, r5
    16a0:	e6 2c       	mov	r14, r6
    16a2:	f7 2c       	mov	r15, r7
    16a4:	08 2d       	mov	r16, r8
    16a6:	19 2d       	mov	r17, r9
    16a8:	2a 2d       	mov	r18, r10
    16aa:	3b 2d       	mov	r19, r11
    16ac:	4c 2d       	mov	r20, r12
    16ae:	5d 2d       	mov	r21, r13
    16b0:	6e 2d       	mov	r22, r14
    16b2:	7f 2d       	mov	r23, r15
    16b4:	80 2f       	mov	r24, r16
    16b6:	91 2f       	mov	r25, r17
    16b8:	0f 2e       	mov	r0, r31
    16ba:	f3 e0       	ldi	r31, 0x03	; 3
    16bc:	af 2e       	mov	r10, r31
    16be:	f0 2d       	mov	r31, r0
    16c0:	bb 24       	eor	r11, r11
    16c2:	cc 24       	eor	r12, r12
    16c4:	dd 24       	eor	r13, r13
    16c6:	ee 24       	eor	r14, r14
    16c8:	ff 24       	eor	r15, r15
    16ca:	00 e0       	ldi	r16, 0x00	; 0
    16cc:	10 e0       	ldi	r17, 0x00	; 0
    16ce:	0e 94 2f 52 	call	0xa45e	; 0xa45e <__divdi3>
    16d2:	a2 2e       	mov	r10, r18
    16d4:	b3 2e       	mov	r11, r19
    16d6:	c4 2e       	mov	r12, r20
    16d8:	d5 2e       	mov	r13, r21
    16da:	e6 2e       	mov	r14, r22
    16dc:	f7 2e       	mov	r15, r23
    16de:	08 2f       	mov	r16, r24
    16e0:	19 2f       	mov	r17, r25
    16e2:	2a 2d       	mov	r18, r10
    16e4:	3b 2d       	mov	r19, r11
    16e6:	4c 2d       	mov	r20, r12
    16e8:	5d 2d       	mov	r21, r13
    16ea:	6e 2d       	mov	r22, r14
    16ec:	7f 2d       	mov	r23, r15
    16ee:	80 2f       	mov	r24, r16
    16f0:	91 2f       	mov	r25, r17
    16f2:	da 01       	movw	r26, r20
    16f4:	c9 01       	movw	r24, r18
    16f6:	b0 95       	com	r27
    16f8:	a0 95       	com	r26
    16fa:	90 95       	com	r25
    16fc:	81 95       	neg	r24
    16fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1700:	af 4f       	sbci	r26, 0xFF	; 255
    1702:	bf 4f       	sbci	r27, 0xFF	; 255
    1704:	ea 81       	ldd	r30, Y+2	; 0x02
    1706:	fb 81       	ldd	r31, Y+3	; 0x03
    1708:	80 83       	st	Z, r24
    170a:	91 83       	std	Z+1, r25	; 0x01
    170c:	a2 83       	std	Z+2, r26	; 0x02
    170e:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    1710:	80 91 69 50 	lds	r24, 0x5069
    1714:	90 91 6a 50 	lds	r25, 0x506A
    1718:	a0 91 6b 50 	lds	r26, 0x506B
    171c:	b0 91 6c 50 	lds	r27, 0x506C
    1720:	01 96       	adiw	r24, 0x01	; 1
    1722:	a1 1d       	adc	r26, r1
    1724:	b1 1d       	adc	r27, r1
    1726:	80 93 69 50 	sts	0x5069, r24
    172a:	90 93 6a 50 	sts	0x506A, r25
    172e:	a0 93 6b 50 	sts	0x506B, r26
    1732:	b0 93 6c 50 	sts	0x506C, r27
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    1736:	80 91 69 50 	lds	r24, 0x5069
    173a:	90 91 6a 50 	lds	r25, 0x506A
    173e:	a0 91 6b 50 	lds	r26, 0x506B
    1742:	b0 91 6c 50 	lds	r27, 0x506C
    1746:	8e 31       	cpi	r24, 0x1E	; 30
    1748:	91 05       	cpc	r25, r1
    174a:	a1 05       	cpc	r26, r1
    174c:	b1 05       	cpc	r27, r1
    174e:	08 f4       	brcc	.+2      	; 0x1752 <__vector_105+0x31e>
    1750:	53 c0       	rjmp	.+166    	; 0x17f8 <__vector_105+0x3c4>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    1752:	10 92 69 50 	sts	0x5069, r1
    1756:	10 92 6a 50 	sts	0x506A, r1
    175a:	10 92 6b 50 	sts	0x506B, r1
    175e:	10 92 6c 50 	sts	0x506C, r1
		TotalSampleCount++;
    1762:	80 91 99 50 	lds	r24, 0x5099
    1766:	90 91 9a 50 	lds	r25, 0x509A
    176a:	01 96       	adiw	r24, 0x01	; 1
    176c:	80 93 99 50 	sts	0x5099, r24
    1770:	90 93 9a 50 	sts	0x509A, r25
		discardCount = ADC_DISCARD -1; //discard the next sample after pausing the sampling to send/store data since the sample ready flag will be outdated and the value might be bad
    1774:	8f e7       	ldi	r24, 0x7F	; 127
    1776:	80 93 52 40 	sts	0x4052, r24
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove(FRAMReadBuffer+2,FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    177a:	80 91 69 50 	lds	r24, 0x5069
    177e:	90 91 6a 50 	lds	r25, 0x506A
    1782:	a0 91 6b 50 	lds	r26, 0x506B
    1786:	b0 91 6c 50 	lds	r27, 0x506C
    178a:	9c 01       	movw	r18, r24
    178c:	22 0f       	add	r18, r18
    178e:	33 1f       	adc	r19, r19
    1790:	22 0f       	add	r18, r18
    1792:	33 1f       	adc	r19, r19
    1794:	8e ec       	ldi	r24, 0xCE	; 206
    1796:	93 e2       	ldi	r25, 0x23	; 35
    1798:	4c ec       	ldi	r20, 0xCC	; 204
    179a:	53 e2       	ldi	r21, 0x23	; 35
    179c:	ba 01       	movw	r22, r20
    179e:	a9 01       	movw	r20, r18
    17a0:	0e 94 5f 62 	call	0xc4be	; 0xc4be <memcpy>
		FRAMReadBuffer[0] = moteID;		//send moteID of the mote that gathered the data
    17a4:	80 91 c5 50 	lds	r24, 0x50C5
    17a8:	80 93 cc 23 	sts	0x23CC, r24
		FRAMReadBuffer[1] = (uint8_t)sampleCount;	//send the number of data samples gathered cast as a byte since no more than 30/31 samples should be send at a time
    17ac:	80 91 69 50 	lds	r24, 0x5069
    17b0:	90 91 6a 50 	lds	r25, 0x506A
    17b4:	a0 91 6b 50 	lds	r26, 0x506B
    17b8:	b0 91 6c 50 	lds	r27, 0x506C
    17bc:	80 93 cd 23 	sts	0x23CD, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+2);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    17c0:	80 91 69 50 	lds	r24, 0x5069
    17c4:	90 91 6a 50 	lds	r25, 0x506A
    17c8:	a0 91 6b 50 	lds	r26, 0x506B
    17cc:	b0 91 6c 50 	lds	r27, 0x506C
    17d0:	88 0f       	add	r24, r24
    17d2:	99 1f       	adc	r25, r25
    17d4:	aa 1f       	adc	r26, r26
    17d6:	bb 1f       	adc	r27, r27
    17d8:	88 0f       	add	r24, r24
    17da:	99 1f       	adc	r25, r25
    17dc:	aa 1f       	adc	r26, r26
    17de:	bb 1f       	adc	r27, r27
    17e0:	9c 01       	movw	r18, r24
    17e2:	ad 01       	movw	r20, r26
    17e4:	2e 5f       	subi	r18, 0xFE	; 254
    17e6:	3f 4f       	sbci	r19, 0xFF	; 255
    17e8:	4f 4f       	sbci	r20, 0xFF	; 255
    17ea:	5f 4f       	sbci	r21, 0xFF	; 255
    17ec:	6c ec       	ldi	r22, 0xCC	; 204
    17ee:	73 e2       	ldi	r23, 0x23	; 35
    17f0:	80 e0       	ldi	r24, 0x00	; 0
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	0e 94 4f 1e 	call	0x3c9e	; 0x3c9e <chb_write>
	}	
	}	
}
    17f8:	23 96       	adiw	r28, 0x03	; 3
    17fa:	cd bf       	out	0x3d, r28	; 61
    17fc:	de bf       	out	0x3e, r29	; 62
    17fe:	df 91       	pop	r29
    1800:	cf 91       	pop	r28
    1802:	ff 91       	pop	r31
    1804:	ef 91       	pop	r30
    1806:	bf 91       	pop	r27
    1808:	af 91       	pop	r26
    180a:	9f 91       	pop	r25
    180c:	8f 91       	pop	r24
    180e:	7f 91       	pop	r23
    1810:	6f 91       	pop	r22
    1812:	5f 91       	pop	r21
    1814:	4f 91       	pop	r20
    1816:	3f 91       	pop	r19
    1818:	2f 91       	pop	r18
    181a:	1f 91       	pop	r17
    181c:	0f 91       	pop	r16
    181e:	ff 90       	pop	r15
    1820:	ef 90       	pop	r14
    1822:	df 90       	pop	r13
    1824:	cf 90       	pop	r12
    1826:	bf 90       	pop	r11
    1828:	af 90       	pop	r10
    182a:	9f 90       	pop	r9
    182c:	8f 90       	pop	r8
    182e:	7f 90       	pop	r7
    1830:	6f 90       	pop	r6
    1832:	5f 90       	pop	r5
    1834:	4f 90       	pop	r4
    1836:	3f 90       	pop	r3
    1838:	2f 90       	pop	r2
    183a:	0f 90       	pop	r0
    183c:	00 92 3b 00 	sts	0x003B, r0
    1840:	0f 90       	pop	r0
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	0f 90       	pop	r0
    1846:	1f 90       	pop	r1
    1848:	18 95       	reti

0000184a <__vector_104>:

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    184a:	1f 92       	push	r1
    184c:	0f 92       	push	r0
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	0f 92       	push	r0
    1852:	00 90 3b 00 	lds	r0, 0x003B
    1856:	0f 92       	push	r0
    1858:	11 24       	eor	r1, r1
    185a:	2f 92       	push	r2
    185c:	3f 92       	push	r3
    185e:	4f 92       	push	r4
    1860:	5f 92       	push	r5
    1862:	6f 92       	push	r6
    1864:	7f 92       	push	r7
    1866:	8f 92       	push	r8
    1868:	9f 92       	push	r9
    186a:	af 92       	push	r10
    186c:	bf 92       	push	r11
    186e:	cf 92       	push	r12
    1870:	df 92       	push	r13
    1872:	ef 92       	push	r14
    1874:	ff 92       	push	r15
    1876:	0f 93       	push	r16
    1878:	1f 93       	push	r17
    187a:	2f 93       	push	r18
    187c:	3f 93       	push	r19
    187e:	4f 93       	push	r20
    1880:	5f 93       	push	r21
    1882:	6f 93       	push	r22
    1884:	7f 93       	push	r23
    1886:	8f 93       	push	r24
    1888:	9f 93       	push	r25
    188a:	af 93       	push	r26
    188c:	bf 93       	push	r27
    188e:	ef 93       	push	r30
    1890:	ff 93       	push	r31
    1892:	cf 93       	push	r28
    1894:	df 93       	push	r29
    1896:	00 d0       	rcall	.+0      	; 0x1898 <__vector_104+0x4e>
    1898:	cd b7       	in	r28, 0x3d	; 61
    189a:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    189c:	80 91 52 40 	lds	r24, 0x4052
    18a0:	88 23       	and	r24, r24
    18a2:	34 f0       	brlt	.+12     	; 0x18b0 <__vector_104+0x66>
		discardCount++;
    18a4:	80 91 52 40 	lds	r24, 0x4052
    18a8:	8f 5f       	subi	r24, 0xFF	; 255
    18aa:	80 93 52 40 	sts	0x4052, r24
    18ae:	75 c1       	rjmp	.+746    	; 0x1b9a <__vector_104+0x350>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    18b6:	80 ea       	ldi	r24, 0xA0	; 160
    18b8:	96 e0       	ldi	r25, 0x06	; 6
    18ba:	22 e0       	ldi	r18, 0x02	; 2
    18bc:	fc 01       	movw	r30, r24
    18be:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    18c0:	19 82       	std	Y+1, r1	; 0x01
    18c2:	1a c0       	rjmp	.+52     	; 0x18f8 <__vector_104+0xae>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    18c4:	80 ec       	ldi	r24, 0xC0	; 192
    18c6:	98 e0       	ldi	r25, 0x08	; 8
    18c8:	2a ea       	ldi	r18, 0xAA	; 170
    18ca:	fc 01       	movw	r30, r24
    18cc:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    18ce:	00 00       	nop
    18d0:	80 ec       	ldi	r24, 0xC0	; 192
    18d2:	98 e0       	ldi	r25, 0x08	; 8
    18d4:	fc 01       	movw	r30, r24
    18d6:	82 81       	ldd	r24, Z+2	; 0x02
    18d8:	88 23       	and	r24, r24
    18da:	d4 f7       	brge	.-12     	; 0x18d0 <__vector_104+0x86>
			SPIBuffer[bufIndex] = SPIC.DATA;
    18dc:	89 81       	ldd	r24, Y+1	; 0x01
    18de:	88 2f       	mov	r24, r24
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	20 ec       	ldi	r18, 0xC0	; 192
    18e4:	38 e0       	ldi	r19, 0x08	; 8
    18e6:	f9 01       	movw	r30, r18
    18e8:	23 81       	ldd	r18, Z+3	; 0x03
    18ea:	86 5a       	subi	r24, 0xA6	; 166
    18ec:	9f 4a       	sbci	r25, 0xAF	; 175
    18ee:	fc 01       	movw	r30, r24
    18f0:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	8f 5f       	subi	r24, 0xFF	; 255
    18f6:	89 83       	std	Y+1, r24	; 0x01
    18f8:	89 81       	ldd	r24, Y+1	; 0x01
    18fa:	83 30       	cpi	r24, 0x03	; 3
    18fc:	18 f3       	brcs	.-58     	; 0x18c4 <__vector_104+0x7a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    18fe:	80 ea       	ldi	r24, 0xA0	; 160
    1900:	96 e0       	ldi	r25, 0x06	; 6
    1902:	22 e0       	ldi	r18, 0x02	; 2
    1904:	fc 01       	movw	r30, r24
    1906:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1908:	80 e0       	ldi	r24, 0x00	; 0
    190a:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    190e:	80 91 5a 50 	lds	r24, 0x505A
    1912:	88 23       	and	r24, r24
    1914:	9c f4       	brge	.+38     	; 0x193c <__vector_104+0xf2>
    1916:	80 91 69 50 	lds	r24, 0x5069
    191a:	90 91 6a 50 	lds	r25, 0x506A
    191e:	a0 91 6b 50 	lds	r26, 0x506B
    1922:	b0 91 6c 50 	lds	r27, 0x506C
    1926:	88 0f       	add	r24, r24
    1928:	99 1f       	adc	r25, r25
    192a:	88 0f       	add	r24, r24
    192c:	99 1f       	adc	r25, r25
    192e:	03 96       	adiw	r24, 0x03	; 3
    1930:	88 5a       	subi	r24, 0xA8	; 168
    1932:	9f 4b       	sbci	r25, 0xBF	; 191
    1934:	2f ef       	ldi	r18, 0xFF	; 255
    1936:	fc 01       	movw	r30, r24
    1938:	20 83       	st	Z, r18
    193a:	11 c0       	rjmp	.+34     	; 0x195e <__vector_104+0x114>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    193c:	80 91 69 50 	lds	r24, 0x5069
    1940:	90 91 6a 50 	lds	r25, 0x506A
    1944:	a0 91 6b 50 	lds	r26, 0x506B
    1948:	b0 91 6c 50 	lds	r27, 0x506C
    194c:	88 0f       	add	r24, r24
    194e:	99 1f       	adc	r25, r25
    1950:	88 0f       	add	r24, r24
    1952:	99 1f       	adc	r25, r25
    1954:	03 96       	adiw	r24, 0x03	; 3
    1956:	88 5a       	subi	r24, 0xA8	; 168
    1958:	9f 4b       	sbci	r25, 0xBF	; 191
    195a:	fc 01       	movw	r30, r24
    195c:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    195e:	80 91 69 50 	lds	r24, 0x5069
    1962:	90 91 6a 50 	lds	r25, 0x506A
    1966:	a0 91 6b 50 	lds	r26, 0x506B
    196a:	b0 91 6c 50 	lds	r27, 0x506C
    196e:	88 0f       	add	r24, r24
    1970:	99 1f       	adc	r25, r25
    1972:	88 0f       	add	r24, r24
    1974:	99 1f       	adc	r25, r25
    1976:	02 96       	adiw	r24, 0x02	; 2
    1978:	88 5a       	subi	r24, 0xA8	; 168
    197a:	9f 4b       	sbci	r25, 0xBF	; 191
    197c:	20 91 5a 50 	lds	r18, 0x505A
    1980:	fc 01       	movw	r30, r24
    1982:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    1984:	80 91 69 50 	lds	r24, 0x5069
    1988:	90 91 6a 50 	lds	r25, 0x506A
    198c:	a0 91 6b 50 	lds	r26, 0x506B
    1990:	b0 91 6c 50 	lds	r27, 0x506C
    1994:	88 0f       	add	r24, r24
    1996:	99 1f       	adc	r25, r25
    1998:	88 0f       	add	r24, r24
    199a:	99 1f       	adc	r25, r25
    199c:	01 96       	adiw	r24, 0x01	; 1
    199e:	88 5a       	subi	r24, 0xA8	; 168
    19a0:	9f 4b       	sbci	r25, 0xBF	; 191
    19a2:	20 91 5b 50 	lds	r18, 0x505B
    19a6:	fc 01       	movw	r30, r24
    19a8:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    19aa:	80 91 69 50 	lds	r24, 0x5069
    19ae:	90 91 6a 50 	lds	r25, 0x506A
    19b2:	a0 91 6b 50 	lds	r26, 0x506B
    19b6:	b0 91 6c 50 	lds	r27, 0x506C
    19ba:	88 0f       	add	r24, r24
    19bc:	99 1f       	adc	r25, r25
    19be:	88 0f       	add	r24, r24
    19c0:	99 1f       	adc	r25, r25
    19c2:	88 5a       	subi	r24, 0xA8	; 168
    19c4:	9f 4b       	sbci	r25, 0xBF	; 191
    19c6:	20 91 5c 50 	lds	r18, 0x505C
    19ca:	fc 01       	movw	r30, r24
    19cc:	20 83       	st	Z, r18
		
		ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)data24Bit[sampleCount] * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    19ce:	20 91 67 50 	lds	r18, 0x5067
    19d2:	30 91 68 50 	lds	r19, 0x5068
    19d6:	80 91 69 50 	lds	r24, 0x5069
    19da:	90 91 6a 50 	lds	r25, 0x506A
    19de:	a0 91 6b 50 	lds	r26, 0x506B
    19e2:	b0 91 6c 50 	lds	r27, 0x506C
    19e6:	88 0f       	add	r24, r24
    19e8:	99 1f       	adc	r25, r25
    19ea:	88 0f       	add	r24, r24
    19ec:	99 1f       	adc	r25, r25
    19ee:	a9 01       	movw	r20, r18
    19f0:	48 0f       	add	r20, r24
    19f2:	59 1f       	adc	r21, r25
    19f4:	4a 83       	std	Y+2, r20	; 0x02
    19f6:	5b 83       	std	Y+3, r21	; 0x03
    19f8:	80 91 69 50 	lds	r24, 0x5069
    19fc:	90 91 6a 50 	lds	r25, 0x506A
    1a00:	a0 91 6b 50 	lds	r26, 0x506B
    1a04:	b0 91 6c 50 	lds	r27, 0x506C
    1a08:	88 0f       	add	r24, r24
    1a0a:	99 1f       	adc	r25, r25
    1a0c:	88 0f       	add	r24, r24
    1a0e:	99 1f       	adc	r25, r25
    1a10:	88 5a       	subi	r24, 0xA8	; 168
    1a12:	9f 4b       	sbci	r25, 0xBF	; 191
    1a14:	fc 01       	movw	r30, r24
    1a16:	80 81       	ld	r24, Z
    1a18:	91 81       	ldd	r25, Z+1	; 0x01
    1a1a:	a2 81       	ldd	r26, Z+2	; 0x02
    1a1c:	b3 81       	ldd	r27, Z+3	; 0x03
    1a1e:	5c 01       	movw	r10, r24
    1a20:	6d 01       	movw	r12, r26
    1a22:	bb 0f       	add	r27, r27
    1a24:	88 0b       	sbc	r24, r24
    1a26:	98 2f       	mov	r25, r24
    1a28:	dc 01       	movw	r26, r24
    1a2a:	e8 2e       	mov	r14, r24
    1a2c:	f8 2e       	mov	r15, r24
    1a2e:	08 2f       	mov	r16, r24
    1a30:	18 2f       	mov	r17, r24
    1a32:	2a 2d       	mov	r18, r10
    1a34:	3b 2d       	mov	r19, r11
    1a36:	4c 2d       	mov	r20, r12
    1a38:	5d 2d       	mov	r21, r13
    1a3a:	6e 2d       	mov	r22, r14
    1a3c:	7f 2d       	mov	r23, r15
    1a3e:	80 2f       	mov	r24, r16
    1a40:	91 2f       	mov	r25, r17
    1a42:	0f 2e       	mov	r0, r31
    1a44:	f0 ea       	ldi	r31, 0xA0	; 160
    1a46:	af 2e       	mov	r10, r31
    1a48:	f0 2d       	mov	r31, r0
    1a4a:	0f 2e       	mov	r0, r31
    1a4c:	f5 e2       	ldi	r31, 0x25	; 37
    1a4e:	bf 2e       	mov	r11, r31
    1a50:	f0 2d       	mov	r31, r0
    1a52:	0f 2e       	mov	r0, r31
    1a54:	f6 e2       	ldi	r31, 0x26	; 38
    1a56:	cf 2e       	mov	r12, r31
    1a58:	f0 2d       	mov	r31, r0
    1a5a:	dd 24       	eor	r13, r13
    1a5c:	ee 24       	eor	r14, r14
    1a5e:	ff 24       	eor	r15, r15
    1a60:	00 e0       	ldi	r16, 0x00	; 0
    1a62:	10 e0       	ldi	r17, 0x00	; 0
    1a64:	0e 94 e8 50 	call	0xa1d0	; 0xa1d0 <__muldi3>
    1a68:	22 2e       	mov	r2, r18
    1a6a:	33 2e       	mov	r3, r19
    1a6c:	44 2e       	mov	r4, r20
    1a6e:	55 2e       	mov	r5, r21
    1a70:	66 2e       	mov	r6, r22
    1a72:	77 2e       	mov	r7, r23
    1a74:	88 2e       	mov	r8, r24
    1a76:	99 2e       	mov	r9, r25
    1a78:	a2 2c       	mov	r10, r2
    1a7a:	b3 2c       	mov	r11, r3
    1a7c:	c4 2c       	mov	r12, r4
    1a7e:	d5 2c       	mov	r13, r5
    1a80:	e6 2c       	mov	r14, r6
    1a82:	f7 2c       	mov	r15, r7
    1a84:	08 2d       	mov	r16, r8
    1a86:	19 2d       	mov	r17, r9
    1a88:	2a 2d       	mov	r18, r10
    1a8a:	3b 2d       	mov	r19, r11
    1a8c:	4c 2d       	mov	r20, r12
    1a8e:	5d 2d       	mov	r21, r13
    1a90:	6e 2d       	mov	r22, r14
    1a92:	7f 2d       	mov	r23, r15
    1a94:	80 2f       	mov	r24, r16
    1a96:	91 2f       	mov	r25, r17
    1a98:	aa 24       	eor	r10, r10
    1a9a:	aa 94       	dec	r10
    1a9c:	bb 24       	eor	r11, r11
    1a9e:	ba 94       	dec	r11
    1aa0:	0f 2e       	mov	r0, r31
    1aa2:	ff e7       	ldi	r31, 0x7F	; 127
    1aa4:	cf 2e       	mov	r12, r31
    1aa6:	f0 2d       	mov	r31, r0
    1aa8:	dd 24       	eor	r13, r13
    1aaa:	ee 24       	eor	r14, r14
    1aac:	ff 24       	eor	r15, r15
    1aae:	00 e0       	ldi	r16, 0x00	; 0
    1ab0:	10 e0       	ldi	r17, 0x00	; 0
    1ab2:	0e 94 eb 59 	call	0xb3d6	; 0xb3d6 <__udivdi3>
    1ab6:	22 2e       	mov	r2, r18
    1ab8:	33 2e       	mov	r3, r19
    1aba:	44 2e       	mov	r4, r20
    1abc:	55 2e       	mov	r5, r21
    1abe:	66 2e       	mov	r6, r22
    1ac0:	77 2e       	mov	r7, r23
    1ac2:	88 2e       	mov	r8, r24
    1ac4:	99 2e       	mov	r9, r25
    1ac6:	a2 2c       	mov	r10, r2
    1ac8:	b3 2c       	mov	r11, r3
    1aca:	c4 2c       	mov	r12, r4
    1acc:	d5 2c       	mov	r13, r5
    1ace:	e6 2c       	mov	r14, r6
    1ad0:	f7 2c       	mov	r15, r7
    1ad2:	08 2d       	mov	r16, r8
    1ad4:	19 2d       	mov	r17, r9
    1ad6:	2a 2d       	mov	r18, r10
    1ad8:	3b 2d       	mov	r19, r11
    1ada:	4c 2d       	mov	r20, r12
    1adc:	5d 2d       	mov	r21, r13
    1ade:	6e 2d       	mov	r22, r14
    1ae0:	7f 2d       	mov	r23, r15
    1ae2:	80 2f       	mov	r24, r16
    1ae4:	91 2f       	mov	r25, r17
    1ae6:	01 e0       	ldi	r16, 0x01	; 1
    1ae8:	0e 94 bb 51 	call	0xa376	; 0xa376 <__ashldi3>
    1aec:	22 2e       	mov	r2, r18
    1aee:	33 2e       	mov	r3, r19
    1af0:	44 2e       	mov	r4, r20
    1af2:	55 2e       	mov	r5, r21
    1af4:	66 2e       	mov	r6, r22
    1af6:	77 2e       	mov	r7, r23
    1af8:	88 2e       	mov	r8, r24
    1afa:	99 2e       	mov	r9, r25
    1afc:	a2 2c       	mov	r10, r2
    1afe:	b3 2c       	mov	r11, r3
    1b00:	c4 2c       	mov	r12, r4
    1b02:	d5 2c       	mov	r13, r5
    1b04:	e6 2c       	mov	r14, r6
    1b06:	f7 2c       	mov	r15, r7
    1b08:	08 2d       	mov	r16, r8
    1b0a:	19 2d       	mov	r17, r9
    1b0c:	2a 2d       	mov	r18, r10
    1b0e:	3b 2d       	mov	r19, r11
    1b10:	4c 2d       	mov	r20, r12
    1b12:	5d 2d       	mov	r21, r13
    1b14:	6e 2d       	mov	r22, r14
    1b16:	7f 2d       	mov	r23, r15
    1b18:	80 2f       	mov	r24, r16
    1b1a:	91 2f       	mov	r25, r17
    1b1c:	0f 2e       	mov	r0, r31
    1b1e:	f3 e0       	ldi	r31, 0x03	; 3
    1b20:	af 2e       	mov	r10, r31
    1b22:	f0 2d       	mov	r31, r0
    1b24:	bb 24       	eor	r11, r11
    1b26:	cc 24       	eor	r12, r12
    1b28:	dd 24       	eor	r13, r13
    1b2a:	ee 24       	eor	r14, r14
    1b2c:	ff 24       	eor	r15, r15
    1b2e:	00 e0       	ldi	r16, 0x00	; 0
    1b30:	10 e0       	ldi	r17, 0x00	; 0
    1b32:	0e 94 eb 59 	call	0xb3d6	; 0xb3d6 <__udivdi3>
    1b36:	a2 2e       	mov	r10, r18
    1b38:	b3 2e       	mov	r11, r19
    1b3a:	c4 2e       	mov	r12, r20
    1b3c:	d5 2e       	mov	r13, r21
    1b3e:	e6 2e       	mov	r14, r22
    1b40:	f7 2e       	mov	r15, r23
    1b42:	08 2f       	mov	r16, r24
    1b44:	19 2f       	mov	r17, r25
    1b46:	2a 2d       	mov	r18, r10
    1b48:	3b 2d       	mov	r19, r11
    1b4a:	4c 2d       	mov	r20, r12
    1b4c:	5d 2d       	mov	r21, r13
    1b4e:	6e 2d       	mov	r22, r14
    1b50:	7f 2d       	mov	r23, r15
    1b52:	80 2f       	mov	r24, r16
    1b54:	91 2f       	mov	r25, r17
    1b56:	da 01       	movw	r26, r20
    1b58:	c9 01       	movw	r24, r18
    1b5a:	b0 95       	com	r27
    1b5c:	a0 95       	com	r26
    1b5e:	90 95       	com	r25
    1b60:	81 95       	neg	r24
    1b62:	9f 4f       	sbci	r25, 0xFF	; 255
    1b64:	af 4f       	sbci	r26, 0xFF	; 255
    1b66:	bf 4f       	sbci	r27, 0xFF	; 255
    1b68:	ea 81       	ldd	r30, Y+2	; 0x02
    1b6a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b6c:	80 83       	st	Z, r24
    1b6e:	91 83       	std	Z+1, r25	; 0x01
    1b70:	a2 83       	std	Z+2, r26	; 0x02
    1b72:	b3 83       	std	Z+3, r27	; 0x03

		sampleCount++;
    1b74:	80 91 69 50 	lds	r24, 0x5069
    1b78:	90 91 6a 50 	lds	r25, 0x506A
    1b7c:	a0 91 6b 50 	lds	r26, 0x506B
    1b80:	b0 91 6c 50 	lds	r27, 0x506C
    1b84:	01 96       	adiw	r24, 0x01	; 1
    1b86:	a1 1d       	adc	r26, r1
    1b88:	b1 1d       	adc	r27, r1
    1b8a:	80 93 69 50 	sts	0x5069, r24
    1b8e:	90 93 6a 50 	sts	0x506A, r25
    1b92:	a0 93 6b 50 	sts	0x506B, r26
    1b96:	b0 93 6c 50 	sts	0x506C, r27
	}
}
    1b9a:	23 96       	adiw	r28, 0x03	; 3
    1b9c:	cd bf       	out	0x3d, r28	; 61
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	df 91       	pop	r29
    1ba2:	cf 91       	pop	r28
    1ba4:	ff 91       	pop	r31
    1ba6:	ef 91       	pop	r30
    1ba8:	bf 91       	pop	r27
    1baa:	af 91       	pop	r26
    1bac:	9f 91       	pop	r25
    1bae:	8f 91       	pop	r24
    1bb0:	7f 91       	pop	r23
    1bb2:	6f 91       	pop	r22
    1bb4:	5f 91       	pop	r21
    1bb6:	4f 91       	pop	r20
    1bb8:	3f 91       	pop	r19
    1bba:	2f 91       	pop	r18
    1bbc:	1f 91       	pop	r17
    1bbe:	0f 91       	pop	r16
    1bc0:	ff 90       	pop	r15
    1bc2:	ef 90       	pop	r14
    1bc4:	df 90       	pop	r13
    1bc6:	cf 90       	pop	r12
    1bc8:	bf 90       	pop	r11
    1bca:	af 90       	pop	r10
    1bcc:	9f 90       	pop	r9
    1bce:	8f 90       	pop	r8
    1bd0:	7f 90       	pop	r7
    1bd2:	6f 90       	pop	r6
    1bd4:	5f 90       	pop	r5
    1bd6:	4f 90       	pop	r4
    1bd8:	3f 90       	pop	r3
    1bda:	2f 90       	pop	r2
    1bdc:	0f 90       	pop	r0
    1bde:	00 92 3b 00 	sts	0x003B, r0
    1be2:	0f 90       	pop	r0
    1be4:	0f be       	out	0x3f, r0	; 63
    1be6:	0f 90       	pop	r0
    1be8:	1f 90       	pop	r1
    1bea:	18 95       	reti

00001bec <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	0f 92       	push	r0
    1bf2:	cd b7       	in	r28, 0x3d	; 61
    1bf4:	de b7       	in	r29, 0x3e	; 62
    1bf6:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1bf8:	89 81       	ldd	r24, Y+1	; 0x01
    1bfa:	88 23       	and	r24, r24
    1bfc:	49 f0       	breq	.+18     	; 0x1c10 <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1bfe:	80 e2       	ldi	r24, 0x20	; 32
    1c00:	60 e0       	ldi	r22, 0x00	; 0
    1c02:	0e 94 6f 32 	call	0x64de	; 0x64de <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c06:	80 e2       	ldi	r24, 0x20	; 32
    1c08:	60 e0       	ldi	r22, 0x00	; 0
    1c0a:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
    1c0e:	04 c0       	rjmp	.+8      	; 0x1c18 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c10:	80 e2       	ldi	r24, 0x20	; 32
    1c12:	60 e0       	ldi	r22, 0x00	; 0
    1c14:	0e 94 d3 32 	call	0x65a6	; 0x65a6 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1c18:	0f 90       	pop	r0
    1c1a:	df 91       	pop	r29
    1c1c:	cf 91       	pop	r28
    1c1e:	08 95       	ret

00001c20 <CO_collectSeismic3Axises>:
	
}*/

void CO_collectSeismic3Axises(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, uint32_t* DataArray) {
    1c20:	8f 92       	push	r8
    1c22:	9f 92       	push	r9
    1c24:	af 92       	push	r10
    1c26:	bf 92       	push	r11
    1c28:	cf 92       	push	r12
    1c2a:	df 92       	push	r13
    1c2c:	ef 92       	push	r14
    1c2e:	ff 92       	push	r15
    1c30:	0f 93       	push	r16
    1c32:	cf 93       	push	r28
    1c34:	df 93       	push	r29
    1c36:	cd b7       	in	r28, 0x3d	; 61
    1c38:	de b7       	in	r29, 0x3e	; 62
    1c3a:	2e 97       	sbiw	r28, 0x0e	; 14
    1c3c:	cd bf       	out	0x3d, r28	; 61
    1c3e:	de bf       	out	0x3e, r29	; 62
    1c40:	89 83       	std	Y+1, r24	; 0x01
    1c42:	6a 83       	std	Y+2, r22	; 0x02
    1c44:	7b 83       	std	Y+3, r23	; 0x03
    1c46:	4c 83       	std	Y+4, r20	; 0x04
    1c48:	2d 83       	std	Y+5, r18	; 0x05
    1c4a:	0e 83       	std	Y+6, r16	; 0x06
    1c4c:	ef 82       	std	Y+7, r14	; 0x07
    1c4e:	f8 86       	std	Y+8, r15	; 0x08
    1c50:	c9 86       	std	Y+9, r12	; 0x09
    1c52:	da 86       	std	Y+10, r13	; 0x0a
    1c54:	ab 86       	std	Y+11, r10	; 0x0b
    1c56:	bc 86       	std	Y+12, r11	; 0x0c
    1c58:	8d 86       	std	Y+13, r8	; 0x0d
    1c5a:	9e 86       	std	Y+14, r9	; 0x0e
	
	ADC_BUFFER = DataArray;
    1c5c:	89 a1       	lds	r24, 0x49
    1c5e:	9a a1       	lds	r25, 0x4a
    1c60:	80 93 67 50 	sts	0x5067, r24
    1c64:	90 93 68 50 	sts	0x5068, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1c6e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c70:	9b 81       	ldd	r25, Y+3	; 0x03
    1c72:	fc 01       	movw	r30, r24
    1c74:	90 81       	ld	r25, Z
    1c76:	85 e0       	ldi	r24, 0x05	; 5
    1c78:	69 2f       	mov	r22, r25
    1c7a:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1c7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c80:	9b 81       	ldd	r25, Y+3	; 0x03
    1c82:	01 96       	adiw	r24, 0x01	; 1
    1c84:	fc 01       	movw	r30, r24
    1c86:	90 81       	ld	r25, Z
    1c88:	86 e0       	ldi	r24, 0x06	; 6
    1c8a:	69 2f       	mov	r22, r25
    1c8c:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1c90:	8a 81       	ldd	r24, Y+2	; 0x02
    1c92:	9b 81       	ldd	r25, Y+3	; 0x03
    1c94:	02 96       	adiw	r24, 0x02	; 2
    1c96:	fc 01       	movw	r30, r24
    1c98:	90 81       	ld	r25, Z
    1c9a:	87 e0       	ldi	r24, 0x07	; 7
    1c9c:	69 2f       	mov	r22, r25
    1c9e:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_filter(filterConfig);
    1ca2:	89 81       	ldd	r24, Y+1	; 0x01
    1ca4:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1ca8:	8e 81       	ldd	r24, Y+6	; 0x06
    1caa:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1cae:	84 e0       	ldi	r24, 0x04	; 4
    1cb0:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1cb4:	80 ec       	ldi	r24, 0xC0	; 192
    1cb6:	98 e0       	ldi	r25, 0x08	; 8
    1cb8:	24 e5       	ldi	r18, 0x54	; 84
    1cba:	fc 01       	movw	r30, r24
    1cbc:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1cc4:	85 e0       	ldi	r24, 0x05	; 5
    1cc6:	0e 94 a5 19 	call	0x334a	; 0x334a <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1cca:	80 ea       	ldi	r24, 0xA0	; 160
    1ccc:	96 e0       	ldi	r25, 0x06	; 6
    1cce:	22 e0       	ldi	r18, 0x02	; 2
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1cd4:	80 ea       	ldi	r24, 0xA0	; 160
    1cd6:	96 e0       	ldi	r25, 0x06	; 6
    1cd8:	21 e0       	ldi	r18, 0x01	; 1
    1cda:	fc 01       	movw	r30, r24
    1cdc:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1cde:	80 e8       	ldi	r24, 0x80	; 128
    1ce0:	91 e0       	ldi	r25, 0x01	; 1
    1ce2:	28 e7       	ldi	r18, 0x78	; 120
    1ce4:	fc 01       	movw	r30, r24
    1ce6:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1ce8:	80 e0       	ldi	r24, 0x00	; 0
    1cea:	98 e0       	ldi	r25, 0x08	; 8
    1cec:	20 ef       	ldi	r18, 0xF0	; 240
    1cee:	fc 01       	movw	r30, r24
    1cf0:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1cf2:	80 e0       	ldi	r24, 0x00	; 0
    1cf4:	98 e0       	ldi	r25, 0x08	; 8
    1cf6:	2f 81       	ldd	r18, Y+7	; 0x07
    1cf8:	38 85       	ldd	r19, Y+8	; 0x08
    1cfa:	fc 01       	movw	r30, r24
    1cfc:	20 a7       	lds	r18, 0x70
    1cfe:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1d00:	80 e0       	ldi	r24, 0x00	; 0
    1d02:	98 e0       	ldi	r25, 0x08	; 8
    1d04:	29 85       	ldd	r18, Y+9	; 0x09
    1d06:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d08:	fc 01       	movw	r30, r24
    1d0a:	22 a7       	lds	r18, 0x72
    1d0c:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	98 e0       	ldi	r25, 0x08	; 8
    1d12:	2b 85       	ldd	r18, Y+11	; 0x0b
    1d14:	3c 85       	ldd	r19, Y+12	; 0x0c
    1d16:	fc 01       	movw	r30, r24
    1d18:	24 a7       	lds	r18, 0x74
    1d1a:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1d1c:	80 e0       	ldi	r24, 0x00	; 0
    1d1e:	98 e0       	ldi	r25, 0x08	; 8
    1d20:	2d 85       	ldd	r18, Y+13	; 0x0d
    1d22:	3e 85       	ldd	r19, Y+14	; 0x0e
    1d24:	fc 01       	movw	r30, r24
    1d26:	26 a7       	lds	r18, 0x76
    1d28:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1d2a:	80 e0       	ldi	r24, 0x00	; 0
    1d2c:	98 e0       	ldi	r25, 0x08	; 8
    1d2e:	2d 81       	ldd	r18, Y+5	; 0x05
    1d30:	22 2f       	mov	r18, r18
    1d32:	30 e0       	ldi	r19, 0x00	; 0
    1d34:	21 50       	subi	r18, 0x01	; 1
    1d36:	30 40       	sbci	r19, 0x00	; 0
    1d38:	fc 01       	movw	r30, r24
    1d3a:	26 a3       	lds	r18, 0x56
    1d3c:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1d3e:	80 e0       	ldi	r24, 0x00	; 0
    1d40:	98 e0       	ldi	r25, 0x08	; 8
    1d42:	22 e0       	ldi	r18, 0x02	; 2
    1d44:	fc 01       	movw	r30, r24
    1d46:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1d48:	80 e0       	ldi	r24, 0x00	; 0
    1d4a:	98 e0       	ldi	r25, 0x08	; 8
    1d4c:	2f ef       	ldi	r18, 0xFF	; 255
    1d4e:	fc 01       	movw	r30, r24
    1d50:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1d52:	80 e0       	ldi	r24, 0x00	; 0
    1d54:	98 e0       	ldi	r25, 0x08	; 8
    1d56:	20 e0       	ldi	r18, 0x00	; 0
    1d58:	38 e0       	ldi	r19, 0x08	; 8
    1d5a:	f9 01       	movw	r30, r18
    1d5c:	20 81       	ld	r18, Z
    1d5e:	20 7f       	andi	r18, 0xF0	; 240
    1d60:	28 60       	ori	r18, 0x08	; 8
    1d62:	fc 01       	movw	r30, r24
    1d64:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    1d66:	10 92 44 40 	sts	0x4044, r1
    1d6a:	10 92 45 40 	sts	0x4045, r1
	sampleCount = 0;
    1d6e:	10 92 69 50 	sts	0x5069, r1
    1d72:	10 92 6a 50 	sts	0x506A, r1
    1d76:	10 92 6b 50 	sts	0x506B, r1
    1d7a:	10 92 6c 50 	sts	0x506C, r1
	SPICount = 0;
    1d7e:	10 92 c3 50 	sts	0x50C3, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1d82:	80 e0       	ldi	r24, 0x00	; 0
    1d84:	80 93 28 21 	sts	0x2128, r24
    1d88:	80 93 27 21 	sts	0x2127, r24
    1d8c:	80 93 26 21 	sts	0x2126, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1d90:	80 ea       	ldi	r24, 0xA0	; 160
    1d92:	90 e0       	ldi	r25, 0x00	; 0
    1d94:	20 ea       	ldi	r18, 0xA0	; 160
    1d96:	30 e0       	ldi	r19, 0x00	; 0
    1d98:	f9 01       	movw	r30, r18
    1d9a:	22 81       	ldd	r18, Z+2	; 0x02
    1d9c:	26 60       	ori	r18, 0x06	; 6
    1d9e:	fc 01       	movw	r30, r24
    1da0:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1da2:	78 94       	sei

	SPICS(TRUE);
    1da4:	81 e0       	ldi	r24, 0x01	; 1
    1da6:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1daa:	80 e8       	ldi	r24, 0x80	; 128
    1dac:	96 e0       	ldi	r25, 0x06	; 6
    1dae:	20 e2       	ldi	r18, 0x20	; 32
    1db0:	fc 01       	movw	r30, r24
    1db2:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1db4:	80 e4       	ldi	r24, 0x40	; 64
    1db6:	9a e0       	ldi	r25, 0x0A	; 10
    1db8:	23 e2       	ldi	r18, 0x23	; 35
    1dba:	fc 01       	movw	r30, r24
    1dbc:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    1dbe:	80 e4       	ldi	r24, 0x40	; 64
    1dc0:	9a e0       	ldi	r25, 0x0A	; 10
    1dc2:	2c 81       	ldd	r18, Y+4	; 0x04
    1dc4:	42 2f       	mov	r20, r18
    1dc6:	50 e0       	ldi	r21, 0x00	; 0
    1dc8:	20 e2       	ldi	r18, 0x20	; 32
    1dca:	30 e0       	ldi	r19, 0x00	; 0
    1dcc:	02 c0       	rjmp	.+4      	; 0x1dd2 <CO_collectSeismic3Axises+0x1b2>
    1dce:	22 0f       	add	r18, r18
    1dd0:	33 1f       	adc	r19, r19
    1dd2:	4a 95       	dec	r20
    1dd4:	e2 f7       	brpl	.-8      	; 0x1dce <CO_collectSeismic3Axises+0x1ae>
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	26 a3       	lds	r18, 0x56
    1dda:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    1ddc:	80 e4       	ldi	r24, 0x40	; 64
    1dde:	9a e0       	ldi	r25, 0x0A	; 10
    1de0:	2c 81       	ldd	r18, Y+4	; 0x04
    1de2:	42 2f       	mov	r20, r18
    1de4:	50 e0       	ldi	r21, 0x00	; 0
    1de6:	20 e1       	ldi	r18, 0x10	; 16
    1de8:	30 e0       	ldi	r19, 0x00	; 0
    1dea:	02 c0       	rjmp	.+4      	; 0x1df0 <CO_collectSeismic3Axises+0x1d0>
    1dec:	22 0f       	add	r18, r18
    1dee:	33 1f       	adc	r19, r19
    1df0:	4a 95       	dec	r20
    1df2:	e2 f7       	brpl	.-8      	; 0x1dec <CO_collectSeismic3Axises+0x1cc>
    1df4:	fc 01       	movw	r30, r24
    1df6:	22 af       	sts	0x72, r18
    1df8:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1dfa:	80 e4       	ldi	r24, 0x40	; 64
    1dfc:	9a e0       	ldi	r25, 0x0A	; 10
    1dfe:	20 e4       	ldi	r18, 0x40	; 64
    1e00:	3a e0       	ldi	r19, 0x0A	; 10
    1e02:	f9 01       	movw	r30, r18
    1e04:	20 81       	ld	r18, Z
    1e06:	20 7f       	andi	r18, 0xF0	; 240
    1e08:	21 60       	ori	r18, 0x01	; 1
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    1e0e:	00 00       	nop
    1e10:	20 91 69 50 	lds	r18, 0x5069
    1e14:	30 91 6a 50 	lds	r19, 0x506A
    1e18:	40 91 6b 50 	lds	r20, 0x506B
    1e1c:	50 91 6c 50 	lds	r21, 0x506C
    1e20:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e22:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1e24:	af 8d       	ldd	r26, Y+31	; 0x1f
    1e26:	b8 a1       	lds	r27, 0x48
    1e28:	28 17       	cp	r18, r24
    1e2a:	39 07       	cpc	r19, r25
    1e2c:	4a 07       	cpc	r20, r26
    1e2e:	5b 07       	cpc	r21, r27
    1e30:	78 f3       	brcs	.-34     	; 0x1e10 <CO_collectSeismic3Axises+0x1f0>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e32:	80 e0       	ldi	r24, 0x00	; 0
    1e34:	98 e0       	ldi	r25, 0x08	; 8
    1e36:	20 e0       	ldi	r18, 0x00	; 0
    1e38:	38 e0       	ldi	r19, 0x08	; 8
    1e3a:	f9 01       	movw	r30, r18
    1e3c:	20 81       	ld	r18, Z
    1e3e:	20 7f       	andi	r18, 0xF0	; 240
    1e40:	fc 01       	movw	r30, r24
    1e42:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e44:	80 e4       	ldi	r24, 0x40	; 64
    1e46:	9a e0       	ldi	r25, 0x0A	; 10
    1e48:	20 e4       	ldi	r18, 0x40	; 64
    1e4a:	3a e0       	ldi	r19, 0x0A	; 10
    1e4c:	f9 01       	movw	r30, r18
    1e4e:	20 81       	ld	r18, Z
    1e50:	20 7f       	andi	r18, 0xF0	; 240
    1e52:	fc 01       	movw	r30, r24
    1e54:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1e56:	80 ea       	ldi	r24, 0xA0	; 160
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	20 ea       	ldi	r18, 0xA0	; 160
    1e5c:	30 e0       	ldi	r19, 0x00	; 0
    1e5e:	f9 01       	movw	r30, r18
    1e60:	22 81       	ldd	r18, Z+2	; 0x02
    1e62:	29 7f       	andi	r18, 0xF9	; 249
    1e64:	fc 01       	movw	r30, r24
    1e66:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1e68:	f8 94       	cli

	SPICS(FALSE);
    1e6a:	80 e0       	ldi	r24, 0x00	; 0
    1e6c:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    1e70:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	enableADCMUX(FALSE);
    1e74:	80 e0       	ldi	r24, 0x00	; 0
    1e76:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	ADCPower(FALSE);
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
}
    1e80:	2e 96       	adiw	r28, 0x0e	; 14
    1e82:	cd bf       	out	0x3d, r28	; 61
    1e84:	de bf       	out	0x3e, r29	; 62
    1e86:	df 91       	pop	r29
    1e88:	cf 91       	pop	r28
    1e8a:	0f 91       	pop	r16
    1e8c:	ff 90       	pop	r15
    1e8e:	ef 90       	pop	r14
    1e90:	df 90       	pop	r13
    1e92:	cf 90       	pop	r12
    1e94:	bf 90       	pop	r11
    1e96:	af 90       	pop	r10
    1e98:	9f 90       	pop	r9
    1e9a:	8f 90       	pop	r8
    1e9c:	08 95       	ret

00001e9e <__vector_16>:

//first averaging point
ISR(TCC0_CCA_vect) {
    1e9e:	1f 92       	push	r1
    1ea0:	0f 92       	push	r0
    1ea2:	0f b6       	in	r0, 0x3f	; 63
    1ea4:	0f 92       	push	r0
    1ea6:	00 90 3b 00 	lds	r0, 0x003B
    1eaa:	0f 92       	push	r0
    1eac:	11 24       	eor	r1, r1
    1eae:	2f 93       	push	r18
    1eb0:	3f 93       	push	r19
    1eb2:	4f 93       	push	r20
    1eb4:	5f 93       	push	r21
    1eb6:	6f 93       	push	r22
    1eb8:	7f 93       	push	r23
    1eba:	8f 93       	push	r24
    1ebc:	9f 93       	push	r25
    1ebe:	af 93       	push	r26
    1ec0:	bf 93       	push	r27
    1ec2:	ef 93       	push	r30
    1ec4:	ff 93       	push	r31
    1ec6:	cf 93       	push	r28
    1ec8:	df 93       	push	r29
    1eca:	cd b7       	in	r28, 0x3d	; 61
    1ecc:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1ece:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
}
    1ed2:	df 91       	pop	r29
    1ed4:	cf 91       	pop	r28
    1ed6:	ff 91       	pop	r31
    1ed8:	ef 91       	pop	r30
    1eda:	bf 91       	pop	r27
    1edc:	af 91       	pop	r26
    1ede:	9f 91       	pop	r25
    1ee0:	8f 91       	pop	r24
    1ee2:	7f 91       	pop	r23
    1ee4:	6f 91       	pop	r22
    1ee6:	5f 91       	pop	r21
    1ee8:	4f 91       	pop	r20
    1eea:	3f 91       	pop	r19
    1eec:	2f 91       	pop	r18
    1eee:	0f 90       	pop	r0
    1ef0:	00 92 3b 00 	sts	0x003B, r0
    1ef4:	0f 90       	pop	r0
    1ef6:	0f be       	out	0x3f, r0	; 63
    1ef8:	0f 90       	pop	r0
    1efa:	1f 90       	pop	r1
    1efc:	18 95       	reti

00001efe <__vector_17>:

//second averaging point
ISR(TCC0_CCB_vect) {
    1efe:	1f 92       	push	r1
    1f00:	0f 92       	push	r0
    1f02:	0f b6       	in	r0, 0x3f	; 63
    1f04:	0f 92       	push	r0
    1f06:	00 90 3b 00 	lds	r0, 0x003B
    1f0a:	0f 92       	push	r0
    1f0c:	11 24       	eor	r1, r1
    1f0e:	2f 93       	push	r18
    1f10:	3f 93       	push	r19
    1f12:	4f 93       	push	r20
    1f14:	5f 93       	push	r21
    1f16:	6f 93       	push	r22
    1f18:	7f 93       	push	r23
    1f1a:	8f 93       	push	r24
    1f1c:	9f 93       	push	r25
    1f1e:	af 93       	push	r26
    1f20:	bf 93       	push	r27
    1f22:	ef 93       	push	r30
    1f24:	ff 93       	push	r31
    1f26:	cf 93       	push	r28
    1f28:	df 93       	push	r29
    1f2a:	cd b7       	in	r28, 0x3d	; 61
    1f2c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f2e:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
}
    1f32:	df 91       	pop	r29
    1f34:	cf 91       	pop	r28
    1f36:	ff 91       	pop	r31
    1f38:	ef 91       	pop	r30
    1f3a:	bf 91       	pop	r27
    1f3c:	af 91       	pop	r26
    1f3e:	9f 91       	pop	r25
    1f40:	8f 91       	pop	r24
    1f42:	7f 91       	pop	r23
    1f44:	6f 91       	pop	r22
    1f46:	5f 91       	pop	r21
    1f48:	4f 91       	pop	r20
    1f4a:	3f 91       	pop	r19
    1f4c:	2f 91       	pop	r18
    1f4e:	0f 90       	pop	r0
    1f50:	00 92 3b 00 	sts	0x003B, r0
    1f54:	0f 90       	pop	r0
    1f56:	0f be       	out	0x3f, r0	; 63
    1f58:	0f 90       	pop	r0
    1f5a:	1f 90       	pop	r1
    1f5c:	18 95       	reti

00001f5e <__vector_18>:

//third averaging point
ISR(TCC0_CCC_vect) {
    1f5e:	1f 92       	push	r1
    1f60:	0f 92       	push	r0
    1f62:	0f b6       	in	r0, 0x3f	; 63
    1f64:	0f 92       	push	r0
    1f66:	00 90 3b 00 	lds	r0, 0x003B
    1f6a:	0f 92       	push	r0
    1f6c:	11 24       	eor	r1, r1
    1f6e:	2f 93       	push	r18
    1f70:	3f 93       	push	r19
    1f72:	4f 93       	push	r20
    1f74:	5f 93       	push	r21
    1f76:	6f 93       	push	r22
    1f78:	7f 93       	push	r23
    1f7a:	8f 93       	push	r24
    1f7c:	9f 93       	push	r25
    1f7e:	af 93       	push	r26
    1f80:	bf 93       	push	r27
    1f82:	ef 93       	push	r30
    1f84:	ff 93       	push	r31
    1f86:	cf 93       	push	r28
    1f88:	df 93       	push	r29
    1f8a:	cd b7       	in	r28, 0x3d	; 61
    1f8c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f8e:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
}
    1f92:	df 91       	pop	r29
    1f94:	cf 91       	pop	r28
    1f96:	ff 91       	pop	r31
    1f98:	ef 91       	pop	r30
    1f9a:	bf 91       	pop	r27
    1f9c:	af 91       	pop	r26
    1f9e:	9f 91       	pop	r25
    1fa0:	8f 91       	pop	r24
    1fa2:	7f 91       	pop	r23
    1fa4:	6f 91       	pop	r22
    1fa6:	5f 91       	pop	r21
    1fa8:	4f 91       	pop	r20
    1faa:	3f 91       	pop	r19
    1fac:	2f 91       	pop	r18
    1fae:	0f 90       	pop	r0
    1fb0:	00 92 3b 00 	sts	0x003B, r0
    1fb4:	0f 90       	pop	r0
    1fb6:	0f be       	out	0x3f, r0	; 63
    1fb8:	0f 90       	pop	r0
    1fba:	1f 90       	pop	r1
    1fbc:	18 95       	reti

00001fbe <__vector_19>:

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    1fbe:	1f 92       	push	r1
    1fc0:	0f 92       	push	r0
    1fc2:	0f b6       	in	r0, 0x3f	; 63
    1fc4:	0f 92       	push	r0
    1fc6:	00 90 3b 00 	lds	r0, 0x003B
    1fca:	0f 92       	push	r0
    1fcc:	11 24       	eor	r1, r1
    1fce:	2f 93       	push	r18
    1fd0:	3f 93       	push	r19
    1fd2:	4f 93       	push	r20
    1fd4:	5f 93       	push	r21
    1fd6:	6f 93       	push	r22
    1fd8:	7f 93       	push	r23
    1fda:	8f 93       	push	r24
    1fdc:	9f 93       	push	r25
    1fde:	af 93       	push	r26
    1fe0:	bf 93       	push	r27
    1fe2:	ef 93       	push	r30
    1fe4:	ff 93       	push	r31
    1fe6:	cf 93       	push	r28
    1fe8:	df 93       	push	r29
    1fea:	cd b7       	in	r28, 0x3d	; 61
    1fec:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1fee:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
	SPICount = 0;
    1ff2:	10 92 c3 50 	sts	0x50C3, r1
	if(PORTB.OUT & PIN1_bm) {
    1ff6:	80 e2       	ldi	r24, 0x20	; 32
    1ff8:	96 e0       	ldi	r25, 0x06	; 6
    1ffa:	fc 01       	movw	r30, r24
    1ffc:	84 81       	ldd	r24, Z+4	; 0x04
    1ffe:	88 2f       	mov	r24, r24
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	82 70       	andi	r24, 0x02	; 2
    2004:	90 70       	andi	r25, 0x00	; 0
    2006:	00 97       	sbiw	r24, 0x00	; 0
    2008:	b1 f0       	breq	.+44     	; 0x2036 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    200a:	80 e0       	ldi	r24, 0x00	; 0
    200c:	96 e0       	ldi	r25, 0x06	; 6
    200e:	fc 01       	movw	r30, r24
    2010:	84 81       	ldd	r24, Z+4	; 0x04
    2012:	88 2f       	mov	r24, r24
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	80 74       	andi	r24, 0x40	; 64
    2018:	90 70       	andi	r25, 0x00	; 0
    201a:	00 97       	sbiw	r24, 0x00	; 0
    201c:	31 f0       	breq	.+12     	; 0x202a <__vector_19+0x6c>
    201e:	80 e2       	ldi	r24, 0x20	; 32
    2020:	96 e0       	ldi	r25, 0x06	; 6
    2022:	22 e0       	ldi	r18, 0x02	; 2
    2024:	fc 01       	movw	r30, r24
    2026:	27 83       	std	Z+7, r18	; 0x07
    2028:	10 c0       	rjmp	.+32     	; 0x204a <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    202a:	80 e0       	ldi	r24, 0x00	; 0
    202c:	96 e0       	ldi	r25, 0x06	; 6
    202e:	20 e4       	ldi	r18, 0x40	; 64
    2030:	fc 01       	movw	r30, r24
    2032:	27 83       	std	Z+7, r18	; 0x07
    2034:	0a c0       	rjmp	.+20     	; 0x204a <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2036:	80 e0       	ldi	r24, 0x00	; 0
    2038:	96 e0       	ldi	r25, 0x06	; 6
    203a:	20 e4       	ldi	r18, 0x40	; 64
    203c:	fc 01       	movw	r30, r24
    203e:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2040:	80 e2       	ldi	r24, 0x20	; 32
    2042:	96 e0       	ldi	r25, 0x06	; 6
    2044:	22 e0       	ldi	r18, 0x02	; 2
    2046:	fc 01       	movw	r30, r24
    2048:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	ff 91       	pop	r31
    2050:	ef 91       	pop	r30
    2052:	bf 91       	pop	r27
    2054:	af 91       	pop	r26
    2056:	9f 91       	pop	r25
    2058:	8f 91       	pop	r24
    205a:	7f 91       	pop	r23
    205c:	6f 91       	pop	r22
    205e:	5f 91       	pop	r21
    2060:	4f 91       	pop	r20
    2062:	3f 91       	pop	r19
    2064:	2f 91       	pop	r18
    2066:	0f 90       	pop	r0
    2068:	00 92 3b 00 	sts	0x003B, r0
    206c:	0f 90       	pop	r0
    206e:	0f be       	out	0x3f, r0	; 63
    2070:	0f 90       	pop	r0
    2072:	1f 90       	pop	r1
    2074:	18 95       	reti

00002076 <__vector_14>:

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    2076:	1f 92       	push	r1
    2078:	0f 92       	push	r0
    207a:	0f b6       	in	r0, 0x3f	; 63
    207c:	0f 92       	push	r0
    207e:	00 90 3b 00 	lds	r0, 0x003B
    2082:	0f 92       	push	r0
    2084:	11 24       	eor	r1, r1
    2086:	2f 93       	push	r18
    2088:	3f 93       	push	r19
    208a:	4f 93       	push	r20
    208c:	5f 93       	push	r21
    208e:	6f 93       	push	r22
    2090:	7f 93       	push	r23
    2092:	8f 93       	push	r24
    2094:	9f 93       	push	r25
    2096:	af 93       	push	r26
    2098:	bf 93       	push	r27
    209a:	ef 93       	push	r30
    209c:	ff 93       	push	r31
    209e:	cf 93       	push	r28
    20a0:	df 93       	push	r29
    20a2:	cd b7       	in	r28, 0x3d	; 61
    20a4:	de b7       	in	r29, 0x3e	; 62
    20a6:	29 97       	sbiw	r28, 0x09	; 9
    20a8:	cd bf       	out	0x3d, r28	; 61
    20aa:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    20ac:	1a 82       	std	Y+2, r1	; 0x02
    20ae:	1b 82       	std	Y+3, r1	; 0x03
    20b0:	1c 82       	std	Y+4, r1	; 0x04
    20b2:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    20b4:	19 82       	std	Y+1, r1	; 0x01
    20b6:	4f c0       	rjmp	.+158    	; 0x2156 <__vector_14+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    20b8:	89 81       	ldd	r24, Y+1	; 0x01
    20ba:	88 2f       	mov	r24, r24
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	86 5a       	subi	r24, 0xA6	; 166
    20c0:	9f 4a       	sbci	r25, 0xAF	; 175
    20c2:	fc 01       	movw	r30, r24
    20c4:	80 81       	ld	r24, Z
    20c6:	88 23       	and	r24, r24
    20c8:	3c f4       	brge	.+14     	; 0x20d8 <__vector_14+0x62>
    20ca:	ce 01       	movw	r24, r28
    20cc:	06 96       	adiw	r24, 0x06	; 6
    20ce:	03 96       	adiw	r24, 0x03	; 3
    20d0:	2f ef       	ldi	r18, 0xFF	; 255
    20d2:	fc 01       	movw	r30, r24
    20d4:	20 83       	st	Z, r18
    20d6:	05 c0       	rjmp	.+10     	; 0x20e2 <__vector_14+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    20d8:	ce 01       	movw	r24, r28
    20da:	06 96       	adiw	r24, 0x06	; 6
    20dc:	03 96       	adiw	r24, 0x03	; 3
    20de:	fc 01       	movw	r30, r24
    20e0:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    20e2:	ce 01       	movw	r24, r28
    20e4:	06 96       	adiw	r24, 0x06	; 6
    20e6:	02 96       	adiw	r24, 0x02	; 2
    20e8:	29 81       	ldd	r18, Y+1	; 0x01
    20ea:	22 2f       	mov	r18, r18
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	26 5a       	subi	r18, 0xA6	; 166
    20f0:	3f 4a       	sbci	r19, 0xAF	; 175
    20f2:	f9 01       	movw	r30, r18
    20f4:	20 81       	ld	r18, Z
    20f6:	fc 01       	movw	r30, r24
    20f8:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    20fa:	ce 01       	movw	r24, r28
    20fc:	06 96       	adiw	r24, 0x06	; 6
    20fe:	01 96       	adiw	r24, 0x01	; 1
    2100:	29 81       	ldd	r18, Y+1	; 0x01
    2102:	22 2f       	mov	r18, r18
    2104:	30 e0       	ldi	r19, 0x00	; 0
    2106:	2f 5f       	subi	r18, 0xFF	; 255
    2108:	3f 4f       	sbci	r19, 0xFF	; 255
    210a:	26 5a       	subi	r18, 0xA6	; 166
    210c:	3f 4a       	sbci	r19, 0xAF	; 175
    210e:	f9 01       	movw	r30, r18
    2110:	20 81       	ld	r18, Z
    2112:	fc 01       	movw	r30, r24
    2114:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2116:	ce 01       	movw	r24, r28
    2118:	06 96       	adiw	r24, 0x06	; 6
    211a:	29 81       	ldd	r18, Y+1	; 0x01
    211c:	22 2f       	mov	r18, r18
    211e:	30 e0       	ldi	r19, 0x00	; 0
    2120:	2e 5f       	subi	r18, 0xFE	; 254
    2122:	3f 4f       	sbci	r19, 0xFF	; 255
    2124:	26 5a       	subi	r18, 0xA6	; 166
    2126:	3f 4a       	sbci	r19, 0xAF	; 175
    2128:	f9 01       	movw	r30, r18
    212a:	20 81       	ld	r18, Z
    212c:	fc 01       	movw	r30, r24
    212e:	20 83       	st	Z, r18
		sum += currentSample;
    2130:	2a 81       	ldd	r18, Y+2	; 0x02
    2132:	3b 81       	ldd	r19, Y+3	; 0x03
    2134:	4c 81       	ldd	r20, Y+4	; 0x04
    2136:	5d 81       	ldd	r21, Y+5	; 0x05
    2138:	8e 81       	ldd	r24, Y+6	; 0x06
    213a:	9f 81       	ldd	r25, Y+7	; 0x07
    213c:	a8 85       	ldd	r26, Y+8	; 0x08
    213e:	b9 85       	ldd	r27, Y+9	; 0x09
    2140:	82 0f       	add	r24, r18
    2142:	93 1f       	adc	r25, r19
    2144:	a4 1f       	adc	r26, r20
    2146:	b5 1f       	adc	r27, r21
    2148:	8a 83       	std	Y+2, r24	; 0x02
    214a:	9b 83       	std	Y+3, r25	; 0x03
    214c:	ac 83       	std	Y+4, r26	; 0x04
    214e:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2150:	89 81       	ldd	r24, Y+1	; 0x01
    2152:	8d 5f       	subi	r24, 0xFD	; 253
    2154:	89 83       	std	Y+1, r24	; 0x01
    2156:	89 81       	ldd	r24, Y+1	; 0x01
    2158:	8c 30       	cpi	r24, 0x0C	; 12
    215a:	08 f4       	brcc	.+2      	; 0x215e <__vector_14+0xe8>
    215c:	ad cf       	rjmp	.-166    	; 0x20b8 <__vector_14+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    215e:	8a 81       	ldd	r24, Y+2	; 0x02
    2160:	9b 81       	ldd	r25, Y+3	; 0x03
    2162:	ac 81       	ldd	r26, Y+4	; 0x04
    2164:	bd 81       	ldd	r27, Y+5	; 0x05
    2166:	24 e0       	ldi	r18, 0x04	; 4
    2168:	30 e0       	ldi	r19, 0x00	; 0
    216a:	40 e0       	ldi	r20, 0x00	; 0
    216c:	50 e0       	ldi	r21, 0x00	; 0
    216e:	bc 01       	movw	r22, r24
    2170:	cd 01       	movw	r24, r26
    2172:	0e 94 0c 62 	call	0xc418	; 0xc418 <__divmodsi4>
    2176:	da 01       	movw	r26, r20
    2178:	c9 01       	movw	r24, r18
    217a:	8a 83       	std	Y+2, r24	; 0x02
    217c:	9b 83       	std	Y+3, r25	; 0x03
    217e:	ac 83       	std	Y+4, r26	; 0x04
    2180:	bd 83       	std	Y+5, r27	; 0x05
	ADC_BUFFER[sampleCount] = currentSample;
    2182:	20 91 67 50 	lds	r18, 0x5067
    2186:	30 91 68 50 	lds	r19, 0x5068
    218a:	80 91 69 50 	lds	r24, 0x5069
    218e:	90 91 6a 50 	lds	r25, 0x506A
    2192:	a0 91 6b 50 	lds	r26, 0x506B
    2196:	b0 91 6c 50 	lds	r27, 0x506C
    219a:	88 0f       	add	r24, r24
    219c:	99 1f       	adc	r25, r25
    219e:	88 0f       	add	r24, r24
    21a0:	99 1f       	adc	r25, r25
    21a2:	28 0f       	add	r18, r24
    21a4:	39 1f       	adc	r19, r25
    21a6:	8e 81       	ldd	r24, Y+6	; 0x06
    21a8:	9f 81       	ldd	r25, Y+7	; 0x07
    21aa:	a8 85       	ldd	r26, Y+8	; 0x08
    21ac:	b9 85       	ldd	r27, Y+9	; 0x09
    21ae:	f9 01       	movw	r30, r18
    21b0:	80 83       	st	Z, r24
    21b2:	91 83       	std	Z+1, r25	; 0x01
    21b4:	a2 83       	std	Z+2, r26	; 0x02
    21b6:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    21b8:	80 91 69 50 	lds	r24, 0x5069
    21bc:	90 91 6a 50 	lds	r25, 0x506A
    21c0:	a0 91 6b 50 	lds	r26, 0x506B
    21c4:	b0 91 6c 50 	lds	r27, 0x506C
    21c8:	01 96       	adiw	r24, 0x01	; 1
    21ca:	a1 1d       	adc	r26, r1
    21cc:	b1 1d       	adc	r27, r1
    21ce:	80 93 69 50 	sts	0x5069, r24
    21d2:	90 93 6a 50 	sts	0x506A, r25
    21d6:	a0 93 6b 50 	sts	0x506B, r26
    21da:	b0 93 6c 50 	sts	0x506C, r27

}
    21de:	29 96       	adiw	r28, 0x09	; 9
    21e0:	cd bf       	out	0x3d, r28	; 61
    21e2:	de bf       	out	0x3e, r29	; 62
    21e4:	df 91       	pop	r29
    21e6:	cf 91       	pop	r28
    21e8:	ff 91       	pop	r31
    21ea:	ef 91       	pop	r30
    21ec:	bf 91       	pop	r27
    21ee:	af 91       	pop	r26
    21f0:	9f 91       	pop	r25
    21f2:	8f 91       	pop	r24
    21f4:	7f 91       	pop	r23
    21f6:	6f 91       	pop	r22
    21f8:	5f 91       	pop	r21
    21fa:	4f 91       	pop	r20
    21fc:	3f 91       	pop	r19
    21fe:	2f 91       	pop	r18
    2200:	0f 90       	pop	r0
    2202:	00 92 3b 00 	sts	0x003B, r0
    2206:	0f 90       	pop	r0
    2208:	0f be       	out	0x3f, r0	; 63
    220a:	0f 90       	pop	r0
    220c:	1f 90       	pop	r1
    220e:	18 95       	reti

00002210 <CO_collectSeismic1Channel>:

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    2210:	8f 92       	push	r8
    2212:	9f 92       	push	r9
    2214:	af 92       	push	r10
    2216:	bf 92       	push	r11
    2218:	cf 92       	push	r12
    221a:	df 92       	push	r13
    221c:	ef 92       	push	r14
    221e:	0f 93       	push	r16
    2220:	cf 93       	push	r28
    2222:	df 93       	push	r29
    2224:	cd b7       	in	r28, 0x3d	; 61
    2226:	de b7       	in	r29, 0x3e	; 62
    2228:	2c 97       	sbiw	r28, 0x0c	; 12
    222a:	cd bf       	out	0x3d, r28	; 61
    222c:	de bf       	out	0x3e, r29	; 62
    222e:	89 83       	std	Y+1, r24	; 0x01
    2230:	6a 83       	std	Y+2, r22	; 0x02
    2232:	4b 83       	std	Y+3, r20	; 0x03
    2234:	2c 83       	std	Y+4, r18	; 0x04
    2236:	0d 83       	std	Y+5, r16	; 0x05
    2238:	ee 82       	std	Y+6, r14	; 0x06
    223a:	cf 82       	std	Y+7, r12	; 0x07
    223c:	d8 86       	std	Y+8, r13	; 0x08
    223e:	a9 86       	std	Y+9, r10	; 0x09
    2240:	ba 86       	std	Y+10, r11	; 0x0a
    2242:	8b 86       	std	Y+11, r8	; 0x0b
    2244:	9c 86       	std	Y+12, r9	; 0x0c
	
	uint16_t period;
	ADC_BUFFER=DataArray;
    2246:	88 a1       	lds	r24, 0x48
    2248:	99 a1       	lds	r25, 0x49
    224a:	80 93 67 50 	sts	0x5067, r24
    224e:	90 93 68 50 	sts	0x5068, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2252:	81 e0       	ldi	r24, 0x01	; 1
    2254:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2258:	89 81       	ldd	r24, Y+1	; 0x01
    225a:	6b 81       	ldd	r22, Y+3	; 0x03
    225c:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_filter(filterConfig);
    2260:	8a 81       	ldd	r24, Y+2	; 0x02
    2262:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2266:	8e 81       	ldd	r24, Y+6	; 0x06
    2268:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    226c:	84 e0       	ldi	r24, 0x04	; 4
    226e:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2272:	80 ec       	ldi	r24, 0xC0	; 192
    2274:	98 e0       	ldi	r25, 0x08	; 8
    2276:	24 e5       	ldi	r18, 0x54	; 84
    2278:	fc 01       	movw	r30, r24
    227a:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    227c:	81 e0       	ldi	r24, 0x01	; 1
    227e:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	setADCInput(channel);
    2282:	89 81       	ldd	r24, Y+1	; 0x01
    2284:	0e 94 a5 19 	call	0x334a	; 0x334a <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2288:	80 ea       	ldi	r24, 0xA0	; 160
    228a:	96 e0       	ldi	r25, 0x06	; 6
    228c:	22 e0       	ldi	r18, 0x02	; 2
    228e:	fc 01       	movw	r30, r24
    2290:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2292:	80 ea       	ldi	r24, 0xA0	; 160
    2294:	96 e0       	ldi	r25, 0x06	; 6
    2296:	21 e0       	ldi	r18, 0x01	; 1
    2298:	fc 01       	movw	r30, r24
    229a:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    229c:	80 e8       	ldi	r24, 0x80	; 128
    229e:	91 e0       	ldi	r25, 0x01	; 1
    22a0:	28 e7       	ldi	r18, 0x78	; 120
    22a2:	fc 01       	movw	r30, r24
    22a4:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    22a6:	80 e0       	ldi	r24, 0x00	; 0
    22a8:	99 e0       	ldi	r25, 0x09	; 9
    22aa:	20 ef       	ldi	r18, 0xF0	; 240
    22ac:	fc 01       	movw	r30, r24
    22ae:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    22b0:	80 e0       	ldi	r24, 0x00	; 0
    22b2:	99 e0       	ldi	r25, 0x09	; 9
    22b4:	2f 81       	ldd	r18, Y+7	; 0x07
    22b6:	38 85       	ldd	r19, Y+8	; 0x08
    22b8:	fc 01       	movw	r30, r24
    22ba:	20 a7       	lds	r18, 0x70
    22bc:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    22be:	80 e0       	ldi	r24, 0x00	; 0
    22c0:	99 e0       	ldi	r25, 0x09	; 9
    22c2:	29 85       	ldd	r18, Y+9	; 0x09
    22c4:	3a 85       	ldd	r19, Y+10	; 0x0a
    22c6:	fc 01       	movw	r30, r24
    22c8:	22 a7       	lds	r18, 0x72
    22ca:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    22cc:	80 e0       	ldi	r24, 0x00	; 0
    22ce:	99 e0       	ldi	r25, 0x09	; 9
    22d0:	2b 85       	ldd	r18, Y+11	; 0x0b
    22d2:	3c 85       	ldd	r19, Y+12	; 0x0c
    22d4:	fc 01       	movw	r30, r24
    22d6:	24 a7       	lds	r18, 0x74
    22d8:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    22da:	80 e0       	ldi	r24, 0x00	; 0
    22dc:	99 e0       	ldi	r25, 0x09	; 9
    22de:	2a 8d       	ldd	r18, Y+26	; 0x1a
    22e0:	3b 8d       	ldd	r19, Y+27	; 0x1b
    22e2:	fc 01       	movw	r30, r24
    22e4:	26 a7       	lds	r18, 0x76
    22e6:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	99 e0       	ldi	r25, 0x09	; 9
    22ec:	2d 81       	ldd	r18, Y+5	; 0x05
    22ee:	22 2f       	mov	r18, r18
    22f0:	30 e0       	ldi	r19, 0x00	; 0
    22f2:	21 50       	subi	r18, 0x01	; 1
    22f4:	30 40       	sbci	r19, 0x00	; 0
    22f6:	fc 01       	movw	r30, r24
    22f8:	26 a3       	lds	r18, 0x56
    22fa:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    22fc:	80 e0       	ldi	r24, 0x00	; 0
    22fe:	99 e0       	ldi	r25, 0x09	; 9
    2300:	22 e0       	ldi	r18, 0x02	; 2
    2302:	fc 01       	movw	r30, r24
    2304:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2306:	80 e0       	ldi	r24, 0x00	; 0
    2308:	99 e0       	ldi	r25, 0x09	; 9
    230a:	2f ef       	ldi	r18, 0xFF	; 255
    230c:	fc 01       	movw	r30, r24
    230e:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2310:	80 e0       	ldi	r24, 0x00	; 0
    2312:	99 e0       	ldi	r25, 0x09	; 9
    2314:	20 e0       	ldi	r18, 0x00	; 0
    2316:	39 e0       	ldi	r19, 0x09	; 9
    2318:	f9 01       	movw	r30, r18
    231a:	20 81       	ld	r18, Z
    231c:	20 7f       	andi	r18, 0xF0	; 240
    231e:	28 60       	ori	r18, 0x08	; 8
    2320:	fc 01       	movw	r30, r24
    2322:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2324:	10 92 69 50 	sts	0x5069, r1
    2328:	10 92 6a 50 	sts	0x506A, r1
    232c:	10 92 6b 50 	sts	0x506B, r1
    2330:	10 92 6c 50 	sts	0x506C, r1
	SPICount = 0;
    2334:	10 92 c3 50 	sts	0x50C3, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2338:	80 ea       	ldi	r24, 0xA0	; 160
    233a:	90 e0       	ldi	r25, 0x00	; 0
    233c:	20 ea       	ldi	r18, 0xA0	; 160
    233e:	30 e0       	ldi	r19, 0x00	; 0
    2340:	f9 01       	movw	r30, r18
    2342:	22 81       	ldd	r18, Z+2	; 0x02
    2344:	26 60       	ori	r18, 0x06	; 6
    2346:	fc 01       	movw	r30, r24
    2348:	22 83       	std	Z+2, r18	; 0x02
	sei();
    234a:	78 94       	sei

	SPICS(TRUE);
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2352:	80 e8       	ldi	r24, 0x80	; 128
    2354:	96 e0       	ldi	r25, 0x06	; 6
    2356:	20 e2       	ldi	r18, 0x20	; 32
    2358:	fc 01       	movw	r30, r24
    235a:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    235c:	80 e4       	ldi	r24, 0x40	; 64
    235e:	9a e0       	ldi	r25, 0x0A	; 10
    2360:	23 e2       	ldi	r18, 0x23	; 35
    2362:	fc 01       	movw	r30, r24
    2364:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2366:	80 e4       	ldi	r24, 0x40	; 64
    2368:	9a e0       	ldi	r25, 0x0A	; 10
    236a:	2c 81       	ldd	r18, Y+4	; 0x04
    236c:	42 2f       	mov	r20, r18
    236e:	50 e0       	ldi	r21, 0x00	; 0
    2370:	20 e2       	ldi	r18, 0x20	; 32
    2372:	30 e0       	ldi	r19, 0x00	; 0
    2374:	02 c0       	rjmp	.+4      	; 0x237a <CO_collectSeismic1Channel+0x16a>
    2376:	22 0f       	add	r18, r18
    2378:	33 1f       	adc	r19, r19
    237a:	4a 95       	dec	r20
    237c:	e2 f7       	brpl	.-8      	; 0x2376 <CO_collectSeismic1Channel+0x166>
    237e:	fc 01       	movw	r30, r24
    2380:	26 a3       	lds	r18, 0x56
    2382:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2384:	80 e4       	ldi	r24, 0x40	; 64
    2386:	9a e0       	ldi	r25, 0x0A	; 10
    2388:	2c 81       	ldd	r18, Y+4	; 0x04
    238a:	42 2f       	mov	r20, r18
    238c:	50 e0       	ldi	r21, 0x00	; 0
    238e:	20 e1       	ldi	r18, 0x10	; 16
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	02 c0       	rjmp	.+4      	; 0x2398 <CO_collectSeismic1Channel+0x188>
    2394:	22 0f       	add	r18, r18
    2396:	33 1f       	adc	r19, r19
    2398:	4a 95       	dec	r20
    239a:	e2 f7       	brpl	.-8      	; 0x2394 <CO_collectSeismic1Channel+0x184>
    239c:	fc 01       	movw	r30, r24
    239e:	22 af       	sts	0x72, r18
    23a0:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    23a2:	80 e4       	ldi	r24, 0x40	; 64
    23a4:	9a e0       	ldi	r25, 0x0A	; 10
    23a6:	20 e4       	ldi	r18, 0x40	; 64
    23a8:	3a e0       	ldi	r19, 0x0A	; 10
    23aa:	f9 01       	movw	r30, r18
    23ac:	20 81       	ld	r18, Z
    23ae:	20 7f       	andi	r18, 0xF0	; 240
    23b0:	21 60       	ori	r18, 0x01	; 1
    23b2:	fc 01       	movw	r30, r24
    23b4:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    23b6:	00 00       	nop
    23b8:	20 91 69 50 	lds	r18, 0x5069
    23bc:	30 91 6a 50 	lds	r19, 0x506A
    23c0:	40 91 6b 50 	lds	r20, 0x506B
    23c4:	50 91 6c 50 	lds	r21, 0x506C
    23c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    23ca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    23cc:	ae 8d       	ldd	r26, Y+30	; 0x1e
    23ce:	bf 8d       	ldd	r27, Y+31	; 0x1f
    23d0:	28 17       	cp	r18, r24
    23d2:	39 07       	cpc	r19, r25
    23d4:	4a 07       	cpc	r20, r26
    23d6:	5b 07       	cpc	r21, r27
    23d8:	78 f3       	brcs	.-34     	; 0x23b8 <CO_collectSeismic1Channel+0x1a8>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    23da:	80 e0       	ldi	r24, 0x00	; 0
    23dc:	99 e0       	ldi	r25, 0x09	; 9
    23de:	20 e0       	ldi	r18, 0x00	; 0
    23e0:	39 e0       	ldi	r19, 0x09	; 9
    23e2:	f9 01       	movw	r30, r18
    23e4:	20 81       	ld	r18, Z
    23e6:	20 7f       	andi	r18, 0xF0	; 240
    23e8:	fc 01       	movw	r30, r24
    23ea:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    23ec:	80 e4       	ldi	r24, 0x40	; 64
    23ee:	9a e0       	ldi	r25, 0x0A	; 10
    23f0:	20 e4       	ldi	r18, 0x40	; 64
    23f2:	3a e0       	ldi	r19, 0x0A	; 10
    23f4:	f9 01       	movw	r30, r18
    23f6:	20 81       	ld	r18, Z
    23f8:	20 7f       	andi	r18, 0xF0	; 240
    23fa:	fc 01       	movw	r30, r24
    23fc:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    23fe:	80 ea       	ldi	r24, 0xA0	; 160
    2400:	90 e0       	ldi	r25, 0x00	; 0
    2402:	20 ea       	ldi	r18, 0xA0	; 160
    2404:	30 e0       	ldi	r19, 0x00	; 0
    2406:	f9 01       	movw	r30, r18
    2408:	22 81       	ldd	r18, Z+2	; 0x02
    240a:	29 7f       	andi	r18, 0xF9	; 249
    240c:	fc 01       	movw	r30, r24
    240e:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2410:	f8 94       	cli

	SPICS(FALSE);
    2412:	80 e0       	ldi	r24, 0x00	; 0
    2414:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    2418:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	enableADCMUX(FALSE);
    241c:	80 e0       	ldi	r24, 0x00	; 0
    241e:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	ADCPower(FALSE);
    2422:	80 e0       	ldi	r24, 0x00	; 0
    2424:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
}
    2428:	2c 96       	adiw	r28, 0x0c	; 12
    242a:	cd bf       	out	0x3d, r28	; 61
    242c:	de bf       	out	0x3e, r29	; 62
    242e:	df 91       	pop	r29
    2430:	cf 91       	pop	r28
    2432:	0f 91       	pop	r16
    2434:	ef 90       	pop	r14
    2436:	df 90       	pop	r13
    2438:	cf 90       	pop	r12
    243a:	bf 90       	pop	r11
    243c:	af 90       	pop	r10
    243e:	9f 90       	pop	r9
    2440:	8f 90       	pop	r8
    2442:	08 95       	ret

00002444 <__vector_79>:

//first averaging point
ISR(TCD0_CCA_vect) {
    2444:	1f 92       	push	r1
    2446:	0f 92       	push	r0
    2448:	0f b6       	in	r0, 0x3f	; 63
    244a:	0f 92       	push	r0
    244c:	00 90 3b 00 	lds	r0, 0x003B
    2450:	0f 92       	push	r0
    2452:	11 24       	eor	r1, r1
    2454:	2f 93       	push	r18
    2456:	3f 93       	push	r19
    2458:	4f 93       	push	r20
    245a:	5f 93       	push	r21
    245c:	6f 93       	push	r22
    245e:	7f 93       	push	r23
    2460:	8f 93       	push	r24
    2462:	9f 93       	push	r25
    2464:	af 93       	push	r26
    2466:	bf 93       	push	r27
    2468:	ef 93       	push	r30
    246a:	ff 93       	push	r31
    246c:	cf 93       	push	r28
    246e:	df 93       	push	r29
    2470:	cd b7       	in	r28, 0x3d	; 61
    2472:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2474:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
}
    2478:	df 91       	pop	r29
    247a:	cf 91       	pop	r28
    247c:	ff 91       	pop	r31
    247e:	ef 91       	pop	r30
    2480:	bf 91       	pop	r27
    2482:	af 91       	pop	r26
    2484:	9f 91       	pop	r25
    2486:	8f 91       	pop	r24
    2488:	7f 91       	pop	r23
    248a:	6f 91       	pop	r22
    248c:	5f 91       	pop	r21
    248e:	4f 91       	pop	r20
    2490:	3f 91       	pop	r19
    2492:	2f 91       	pop	r18
    2494:	0f 90       	pop	r0
    2496:	00 92 3b 00 	sts	0x003B, r0
    249a:	0f 90       	pop	r0
    249c:	0f be       	out	0x3f, r0	; 63
    249e:	0f 90       	pop	r0
    24a0:	1f 90       	pop	r1
    24a2:	18 95       	reti

000024a4 <__vector_80>:
//second averaging point
ISR(TCD0_CCB_vect) {
    24a4:	1f 92       	push	r1
    24a6:	0f 92       	push	r0
    24a8:	0f b6       	in	r0, 0x3f	; 63
    24aa:	0f 92       	push	r0
    24ac:	00 90 3b 00 	lds	r0, 0x003B
    24b0:	0f 92       	push	r0
    24b2:	11 24       	eor	r1, r1
    24b4:	2f 93       	push	r18
    24b6:	3f 93       	push	r19
    24b8:	4f 93       	push	r20
    24ba:	5f 93       	push	r21
    24bc:	6f 93       	push	r22
    24be:	7f 93       	push	r23
    24c0:	8f 93       	push	r24
    24c2:	9f 93       	push	r25
    24c4:	af 93       	push	r26
    24c6:	bf 93       	push	r27
    24c8:	ef 93       	push	r30
    24ca:	ff 93       	push	r31
    24cc:	cf 93       	push	r28
    24ce:	df 93       	push	r29
    24d0:	cd b7       	in	r28, 0x3d	; 61
    24d2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    24d4:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
}
    24d8:	df 91       	pop	r29
    24da:	cf 91       	pop	r28
    24dc:	ff 91       	pop	r31
    24de:	ef 91       	pop	r30
    24e0:	bf 91       	pop	r27
    24e2:	af 91       	pop	r26
    24e4:	9f 91       	pop	r25
    24e6:	8f 91       	pop	r24
    24e8:	7f 91       	pop	r23
    24ea:	6f 91       	pop	r22
    24ec:	5f 91       	pop	r21
    24ee:	4f 91       	pop	r20
    24f0:	3f 91       	pop	r19
    24f2:	2f 91       	pop	r18
    24f4:	0f 90       	pop	r0
    24f6:	00 92 3b 00 	sts	0x003B, r0
    24fa:	0f 90       	pop	r0
    24fc:	0f be       	out	0x3f, r0	; 63
    24fe:	0f 90       	pop	r0
    2500:	1f 90       	pop	r1
    2502:	18 95       	reti

00002504 <__vector_81>:

//third averaging point
ISR(TCD0_CCC_vect) {
    2504:	1f 92       	push	r1
    2506:	0f 92       	push	r0
    2508:	0f b6       	in	r0, 0x3f	; 63
    250a:	0f 92       	push	r0
    250c:	00 90 3b 00 	lds	r0, 0x003B
    2510:	0f 92       	push	r0
    2512:	11 24       	eor	r1, r1
    2514:	2f 93       	push	r18
    2516:	3f 93       	push	r19
    2518:	4f 93       	push	r20
    251a:	5f 93       	push	r21
    251c:	6f 93       	push	r22
    251e:	7f 93       	push	r23
    2520:	8f 93       	push	r24
    2522:	9f 93       	push	r25
    2524:	af 93       	push	r26
    2526:	bf 93       	push	r27
    2528:	ef 93       	push	r30
    252a:	ff 93       	push	r31
    252c:	cf 93       	push	r28
    252e:	df 93       	push	r29
    2530:	cd b7       	in	r28, 0x3d	; 61
    2532:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2534:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
}
    2538:	df 91       	pop	r29
    253a:	cf 91       	pop	r28
    253c:	ff 91       	pop	r31
    253e:	ef 91       	pop	r30
    2540:	bf 91       	pop	r27
    2542:	af 91       	pop	r26
    2544:	9f 91       	pop	r25
    2546:	8f 91       	pop	r24
    2548:	7f 91       	pop	r23
    254a:	6f 91       	pop	r22
    254c:	5f 91       	pop	r21
    254e:	4f 91       	pop	r20
    2550:	3f 91       	pop	r19
    2552:	2f 91       	pop	r18
    2554:	0f 90       	pop	r0
    2556:	00 92 3b 00 	sts	0x003B, r0
    255a:	0f 90       	pop	r0
    255c:	0f be       	out	0x3f, r0	; 63
    255e:	0f 90       	pop	r0
    2560:	1f 90       	pop	r1
    2562:	18 95       	reti

00002564 <__vector_82>:

//final averaging point
ISR(TCD0_CCD_vect) {
    2564:	1f 92       	push	r1
    2566:	0f 92       	push	r0
    2568:	0f b6       	in	r0, 0x3f	; 63
    256a:	0f 92       	push	r0
    256c:	00 90 3b 00 	lds	r0, 0x003B
    2570:	0f 92       	push	r0
    2572:	11 24       	eor	r1, r1
    2574:	2f 93       	push	r18
    2576:	3f 93       	push	r19
    2578:	4f 93       	push	r20
    257a:	5f 93       	push	r21
    257c:	6f 93       	push	r22
    257e:	7f 93       	push	r23
    2580:	8f 93       	push	r24
    2582:	9f 93       	push	r25
    2584:	af 93       	push	r26
    2586:	bf 93       	push	r27
    2588:	ef 93       	push	r30
    258a:	ff 93       	push	r31
    258c:	cf 93       	push	r28
    258e:	df 93       	push	r29
    2590:	cd b7       	in	r28, 0x3d	; 61
    2592:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2594:	0e 94 b1 13 	call	0x2762	; 0x2762 <sampleCurrentChannel>
	SPICount = 0;
    2598:	10 92 c3 50 	sts	0x50C3, r1
}
    259c:	df 91       	pop	r29
    259e:	cf 91       	pop	r28
    25a0:	ff 91       	pop	r31
    25a2:	ef 91       	pop	r30
    25a4:	bf 91       	pop	r27
    25a6:	af 91       	pop	r26
    25a8:	9f 91       	pop	r25
    25aa:	8f 91       	pop	r24
    25ac:	7f 91       	pop	r23
    25ae:	6f 91       	pop	r22
    25b0:	5f 91       	pop	r21
    25b2:	4f 91       	pop	r20
    25b4:	3f 91       	pop	r19
    25b6:	2f 91       	pop	r18
    25b8:	0f 90       	pop	r0
    25ba:	00 92 3b 00 	sts	0x003B, r0
    25be:	0f 90       	pop	r0
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	0f 90       	pop	r0
    25c4:	1f 90       	pop	r1
    25c6:	18 95       	reti

000025c8 <__vector_77>:

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    25c8:	1f 92       	push	r1
    25ca:	0f 92       	push	r0
    25cc:	0f b6       	in	r0, 0x3f	; 63
    25ce:	0f 92       	push	r0
    25d0:	00 90 3b 00 	lds	r0, 0x003B
    25d4:	0f 92       	push	r0
    25d6:	11 24       	eor	r1, r1
    25d8:	2f 93       	push	r18
    25da:	3f 93       	push	r19
    25dc:	4f 93       	push	r20
    25de:	5f 93       	push	r21
    25e0:	6f 93       	push	r22
    25e2:	7f 93       	push	r23
    25e4:	8f 93       	push	r24
    25e6:	9f 93       	push	r25
    25e8:	af 93       	push	r26
    25ea:	bf 93       	push	r27
    25ec:	ef 93       	push	r30
    25ee:	ff 93       	push	r31
    25f0:	cf 93       	push	r28
    25f2:	df 93       	push	r29
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	29 97       	sbiw	r28, 0x09	; 9
    25fa:	cd bf       	out	0x3d, r28	; 61
    25fc:	de bf       	out	0x3e, r29	; 62
	//writeSE2FRAM();
	volatile int32_t sum = 0;
    25fe:	1a 82       	std	Y+2, r1	; 0x02
    2600:	1b 82       	std	Y+3, r1	; 0x03
    2602:	1c 82       	std	Y+4, r1	; 0x04
    2604:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2606:	19 82       	std	Y+1, r1	; 0x01
    2608:	4f c0       	rjmp	.+158    	; 0x26a8 <__vector_77+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    260a:	89 81       	ldd	r24, Y+1	; 0x01
    260c:	88 2f       	mov	r24, r24
    260e:	90 e0       	ldi	r25, 0x00	; 0
    2610:	86 5a       	subi	r24, 0xA6	; 166
    2612:	9f 4a       	sbci	r25, 0xAF	; 175
    2614:	fc 01       	movw	r30, r24
    2616:	80 81       	ld	r24, Z
    2618:	88 23       	and	r24, r24
    261a:	3c f4       	brge	.+14     	; 0x262a <__vector_77+0x62>
    261c:	ce 01       	movw	r24, r28
    261e:	06 96       	adiw	r24, 0x06	; 6
    2620:	03 96       	adiw	r24, 0x03	; 3
    2622:	2f ef       	ldi	r18, 0xFF	; 255
    2624:	fc 01       	movw	r30, r24
    2626:	20 83       	st	Z, r18
    2628:	05 c0       	rjmp	.+10     	; 0x2634 <__vector_77+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    262a:	ce 01       	movw	r24, r28
    262c:	06 96       	adiw	r24, 0x06	; 6
    262e:	03 96       	adiw	r24, 0x03	; 3
    2630:	fc 01       	movw	r30, r24
    2632:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2634:	ce 01       	movw	r24, r28
    2636:	06 96       	adiw	r24, 0x06	; 6
    2638:	02 96       	adiw	r24, 0x02	; 2
    263a:	29 81       	ldd	r18, Y+1	; 0x01
    263c:	22 2f       	mov	r18, r18
    263e:	30 e0       	ldi	r19, 0x00	; 0
    2640:	26 5a       	subi	r18, 0xA6	; 166
    2642:	3f 4a       	sbci	r19, 0xAF	; 175
    2644:	f9 01       	movw	r30, r18
    2646:	20 81       	ld	r18, Z
    2648:	fc 01       	movw	r30, r24
    264a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    264c:	ce 01       	movw	r24, r28
    264e:	06 96       	adiw	r24, 0x06	; 6
    2650:	01 96       	adiw	r24, 0x01	; 1
    2652:	29 81       	ldd	r18, Y+1	; 0x01
    2654:	22 2f       	mov	r18, r18
    2656:	30 e0       	ldi	r19, 0x00	; 0
    2658:	2f 5f       	subi	r18, 0xFF	; 255
    265a:	3f 4f       	sbci	r19, 0xFF	; 255
    265c:	26 5a       	subi	r18, 0xA6	; 166
    265e:	3f 4a       	sbci	r19, 0xAF	; 175
    2660:	f9 01       	movw	r30, r18
    2662:	20 81       	ld	r18, Z
    2664:	fc 01       	movw	r30, r24
    2666:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2668:	ce 01       	movw	r24, r28
    266a:	06 96       	adiw	r24, 0x06	; 6
    266c:	29 81       	ldd	r18, Y+1	; 0x01
    266e:	22 2f       	mov	r18, r18
    2670:	30 e0       	ldi	r19, 0x00	; 0
    2672:	2e 5f       	subi	r18, 0xFE	; 254
    2674:	3f 4f       	sbci	r19, 0xFF	; 255
    2676:	26 5a       	subi	r18, 0xA6	; 166
    2678:	3f 4a       	sbci	r19, 0xAF	; 175
    267a:	f9 01       	movw	r30, r18
    267c:	20 81       	ld	r18, Z
    267e:	fc 01       	movw	r30, r24
    2680:	20 83       	st	Z, r18
		sum += currentSample;
    2682:	2a 81       	ldd	r18, Y+2	; 0x02
    2684:	3b 81       	ldd	r19, Y+3	; 0x03
    2686:	4c 81       	ldd	r20, Y+4	; 0x04
    2688:	5d 81       	ldd	r21, Y+5	; 0x05
    268a:	8e 81       	ldd	r24, Y+6	; 0x06
    268c:	9f 81       	ldd	r25, Y+7	; 0x07
    268e:	a8 85       	ldd	r26, Y+8	; 0x08
    2690:	b9 85       	ldd	r27, Y+9	; 0x09
    2692:	82 0f       	add	r24, r18
    2694:	93 1f       	adc	r25, r19
    2696:	a4 1f       	adc	r26, r20
    2698:	b5 1f       	adc	r27, r21
    269a:	8a 83       	std	Y+2, r24	; 0x02
    269c:	9b 83       	std	Y+3, r25	; 0x03
    269e:	ac 83       	std	Y+4, r26	; 0x04
    26a0:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    26a2:	89 81       	ldd	r24, Y+1	; 0x01
    26a4:	8d 5f       	subi	r24, 0xFD	; 253
    26a6:	89 83       	std	Y+1, r24	; 0x01
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	8c 30       	cpi	r24, 0x0C	; 12
    26ac:	08 f4       	brcc	.+2      	; 0x26b0 <__vector_77+0xe8>
    26ae:	ad cf       	rjmp	.-166    	; 0x260a <__vector_77+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    26b0:	8a 81       	ldd	r24, Y+2	; 0x02
    26b2:	9b 81       	ldd	r25, Y+3	; 0x03
    26b4:	ac 81       	ldd	r26, Y+4	; 0x04
    26b6:	bd 81       	ldd	r27, Y+5	; 0x05
    26b8:	24 e0       	ldi	r18, 0x04	; 4
    26ba:	30 e0       	ldi	r19, 0x00	; 0
    26bc:	40 e0       	ldi	r20, 0x00	; 0
    26be:	50 e0       	ldi	r21, 0x00	; 0
    26c0:	bc 01       	movw	r22, r24
    26c2:	cd 01       	movw	r24, r26
    26c4:	0e 94 0c 62 	call	0xc418	; 0xc418 <__divmodsi4>
    26c8:	da 01       	movw	r26, r20
    26ca:	c9 01       	movw	r24, r18
    26cc:	8a 83       	std	Y+2, r24	; 0x02
    26ce:	9b 83       	std	Y+3, r25	; 0x03
    26d0:	ac 83       	std	Y+4, r26	; 0x04
    26d2:	bd 83       	std	Y+5, r27	; 0x05
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    26d4:	20 91 67 50 	lds	r18, 0x5067
    26d8:	30 91 68 50 	lds	r19, 0x5068
    26dc:	80 91 69 50 	lds	r24, 0x5069
    26e0:	90 91 6a 50 	lds	r25, 0x506A
    26e4:	a0 91 6b 50 	lds	r26, 0x506B
    26e8:	b0 91 6c 50 	lds	r27, 0x506C
    26ec:	88 0f       	add	r24, r24
    26ee:	99 1f       	adc	r25, r25
    26f0:	88 0f       	add	r24, r24
    26f2:	99 1f       	adc	r25, r25
    26f4:	28 0f       	add	r18, r24
    26f6:	39 1f       	adc	r19, r25
    26f8:	8a 81       	ldd	r24, Y+2	; 0x02
    26fa:	9b 81       	ldd	r25, Y+3	; 0x03
    26fc:	ac 81       	ldd	r26, Y+4	; 0x04
    26fe:	bd 81       	ldd	r27, Y+5	; 0x05
    2700:	f9 01       	movw	r30, r18
    2702:	80 83       	st	Z, r24
    2704:	91 83       	std	Z+1, r25	; 0x01
    2706:	a2 83       	std	Z+2, r26	; 0x02
    2708:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    270a:	80 91 69 50 	lds	r24, 0x5069
    270e:	90 91 6a 50 	lds	r25, 0x506A
    2712:	a0 91 6b 50 	lds	r26, 0x506B
    2716:	b0 91 6c 50 	lds	r27, 0x506C
    271a:	01 96       	adiw	r24, 0x01	; 1
    271c:	a1 1d       	adc	r26, r1
    271e:	b1 1d       	adc	r27, r1
    2720:	80 93 69 50 	sts	0x5069, r24
    2724:	90 93 6a 50 	sts	0x506A, r25
    2728:	a0 93 6b 50 	sts	0x506B, r26
    272c:	b0 93 6c 50 	sts	0x506C, r27
}
    2730:	29 96       	adiw	r28, 0x09	; 9
    2732:	cd bf       	out	0x3d, r28	; 61
    2734:	de bf       	out	0x3e, r29	; 62
    2736:	df 91       	pop	r29
    2738:	cf 91       	pop	r28
    273a:	ff 91       	pop	r31
    273c:	ef 91       	pop	r30
    273e:	bf 91       	pop	r27
    2740:	af 91       	pop	r26
    2742:	9f 91       	pop	r25
    2744:	8f 91       	pop	r24
    2746:	7f 91       	pop	r23
    2748:	6f 91       	pop	r22
    274a:	5f 91       	pop	r21
    274c:	4f 91       	pop	r20
    274e:	3f 91       	pop	r19
    2750:	2f 91       	pop	r18
    2752:	0f 90       	pop	r0
    2754:	00 92 3b 00 	sts	0x003B, r0
    2758:	0f 90       	pop	r0
    275a:	0f be       	out	0x3f, r0	; 63
    275c:	0f 90       	pop	r0
    275e:	1f 90       	pop	r1
    2760:	18 95       	reti

00002762 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
    2762:	cf 93       	push	r28
    2764:	df 93       	push	r29
    2766:	cd b7       	in	r28, 0x3d	; 61
    2768:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    276a:	80 ea       	ldi	r24, 0xA0	; 160
    276c:	96 e0       	ldi	r25, 0x06	; 6
    276e:	22 e0       	ldi	r18, 0x02	; 2
    2770:	fc 01       	movw	r30, r24
    2772:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2774:	80 ec       	ldi	r24, 0xC0	; 192
    2776:	98 e0       	ldi	r25, 0x08	; 8
    2778:	2a ea       	ldi	r18, 0xAA	; 170
    277a:	fc 01       	movw	r30, r24
    277c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    277e:	00 00       	nop
    2780:	80 ec       	ldi	r24, 0xC0	; 192
    2782:	98 e0       	ldi	r25, 0x08	; 8
    2784:	fc 01       	movw	r30, r24
    2786:	82 81       	ldd	r24, Z+2	; 0x02
    2788:	88 23       	and	r24, r24
    278a:	d4 f7       	brge	.-12     	; 0x2780 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    278c:	80 91 c3 50 	lds	r24, 0x50C3
    2790:	88 2f       	mov	r24, r24
    2792:	90 e0       	ldi	r25, 0x00	; 0
    2794:	20 ec       	ldi	r18, 0xC0	; 192
    2796:	38 e0       	ldi	r19, 0x08	; 8
    2798:	f9 01       	movw	r30, r18
    279a:	23 81       	ldd	r18, Z+3	; 0x03
    279c:	86 5a       	subi	r24, 0xA6	; 166
    279e:	9f 4a       	sbci	r25, 0xAF	; 175
    27a0:	fc 01       	movw	r30, r24
    27a2:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    27a4:	80 ec       	ldi	r24, 0xC0	; 192
    27a6:	98 e0       	ldi	r25, 0x08	; 8
    27a8:	2a ea       	ldi	r18, 0xAA	; 170
    27aa:	fc 01       	movw	r30, r24
    27ac:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27ae:	00 00       	nop
    27b0:	80 ec       	ldi	r24, 0xC0	; 192
    27b2:	98 e0       	ldi	r25, 0x08	; 8
    27b4:	fc 01       	movw	r30, r24
    27b6:	82 81       	ldd	r24, Z+2	; 0x02
    27b8:	88 23       	and	r24, r24
    27ba:	d4 f7       	brge	.-12     	; 0x27b0 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    27bc:	80 91 c3 50 	lds	r24, 0x50C3
    27c0:	88 2f       	mov	r24, r24
    27c2:	90 e0       	ldi	r25, 0x00	; 0
    27c4:	01 96       	adiw	r24, 0x01	; 1
    27c6:	20 ec       	ldi	r18, 0xC0	; 192
    27c8:	38 e0       	ldi	r19, 0x08	; 8
    27ca:	f9 01       	movw	r30, r18
    27cc:	23 81       	ldd	r18, Z+3	; 0x03
    27ce:	86 5a       	subi	r24, 0xA6	; 166
    27d0:	9f 4a       	sbci	r25, 0xAF	; 175
    27d2:	fc 01       	movw	r30, r24
    27d4:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    27d6:	80 ec       	ldi	r24, 0xC0	; 192
    27d8:	98 e0       	ldi	r25, 0x08	; 8
    27da:	2a ea       	ldi	r18, 0xAA	; 170
    27dc:	fc 01       	movw	r30, r24
    27de:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27e0:	00 00       	nop
    27e2:	80 ec       	ldi	r24, 0xC0	; 192
    27e4:	98 e0       	ldi	r25, 0x08	; 8
    27e6:	fc 01       	movw	r30, r24
    27e8:	82 81       	ldd	r24, Z+2	; 0x02
    27ea:	88 23       	and	r24, r24
    27ec:	d4 f7       	brge	.-12     	; 0x27e2 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    27ee:	80 91 c3 50 	lds	r24, 0x50C3
    27f2:	88 2f       	mov	r24, r24
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	02 96       	adiw	r24, 0x02	; 2
    27f8:	20 ec       	ldi	r18, 0xC0	; 192
    27fa:	38 e0       	ldi	r19, 0x08	; 8
    27fc:	f9 01       	movw	r30, r18
    27fe:	23 81       	ldd	r18, Z+3	; 0x03
    2800:	86 5a       	subi	r24, 0xA6	; 166
    2802:	9f 4a       	sbci	r25, 0xAF	; 175
    2804:	fc 01       	movw	r30, r24
    2806:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2808:	80 ea       	ldi	r24, 0xA0	; 160
    280a:	96 e0       	ldi	r25, 0x06	; 6
    280c:	22 e0       	ldi	r18, 0x02	; 2
    280e:	fc 01       	movw	r30, r24
    2810:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2812:	80 91 c3 50 	lds	r24, 0x50C3
    2816:	8d 5f       	subi	r24, 0xFD	; 253
    2818:	80 93 c3 50 	sts	0x50C3, r24
}
    281c:	df 91       	pop	r29
    281e:	cf 91       	pop	r28
    2820:	08 95       	ret

00002822 <writeSE2FRAM>:

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2822:	cf 93       	push	r28
    2824:	df 93       	push	r29
    2826:	cd b7       	in	r28, 0x3d	; 61
    2828:	de b7       	in	r29, 0x3e	; 62
    282a:	29 97       	sbiw	r28, 0x09	; 9
    282c:	cd bf       	out	0x3d, r28	; 61
    282e:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2830:	1a 82       	std	Y+2, r1	; 0x02
    2832:	1b 82       	std	Y+3, r1	; 0x03
    2834:	1c 82       	std	Y+4, r1	; 0x04
    2836:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2838:	80 91 69 50 	lds	r24, 0x5069
    283c:	90 91 6a 50 	lds	r25, 0x506A
    2840:	a0 91 6b 50 	lds	r26, 0x506B
    2844:	b0 91 6c 50 	lds	r27, 0x506C
    2848:	01 96       	adiw	r24, 0x01	; 1
    284a:	a1 1d       	adc	r26, r1
    284c:	b1 1d       	adc	r27, r1
    284e:	80 93 69 50 	sts	0x5069, r24
    2852:	90 93 6a 50 	sts	0x506A, r25
    2856:	a0 93 6b 50 	sts	0x506B, r26
    285a:	b0 93 6c 50 	sts	0x506C, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    285e:	80 ec       	ldi	r24, 0xC0	; 192
    2860:	98 e0       	ldi	r25, 0x08	; 8
    2862:	20 ed       	ldi	r18, 0xD0	; 208
    2864:	fc 01       	movw	r30, r24
    2866:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2868:	19 82       	std	Y+1, r1	; 0x01
    286a:	4f c0       	rjmp	.+158    	; 0x290a <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    286c:	89 81       	ldd	r24, Y+1	; 0x01
    286e:	88 2f       	mov	r24, r24
    2870:	90 e0       	ldi	r25, 0x00	; 0
    2872:	86 5a       	subi	r24, 0xA6	; 166
    2874:	9f 4a       	sbci	r25, 0xAF	; 175
    2876:	fc 01       	movw	r30, r24
    2878:	80 81       	ld	r24, Z
    287a:	88 23       	and	r24, r24
    287c:	3c f4       	brge	.+14     	; 0x288c <writeSE2FRAM+0x6a>
    287e:	ce 01       	movw	r24, r28
    2880:	06 96       	adiw	r24, 0x06	; 6
    2882:	03 96       	adiw	r24, 0x03	; 3
    2884:	2f ef       	ldi	r18, 0xFF	; 255
    2886:	fc 01       	movw	r30, r24
    2888:	20 83       	st	Z, r18
    288a:	05 c0       	rjmp	.+10     	; 0x2896 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    288c:	ce 01       	movw	r24, r28
    288e:	06 96       	adiw	r24, 0x06	; 6
    2890:	03 96       	adiw	r24, 0x03	; 3
    2892:	fc 01       	movw	r30, r24
    2894:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2896:	ce 01       	movw	r24, r28
    2898:	06 96       	adiw	r24, 0x06	; 6
    289a:	02 96       	adiw	r24, 0x02	; 2
    289c:	29 81       	ldd	r18, Y+1	; 0x01
    289e:	22 2f       	mov	r18, r18
    28a0:	30 e0       	ldi	r19, 0x00	; 0
    28a2:	26 5a       	subi	r18, 0xA6	; 166
    28a4:	3f 4a       	sbci	r19, 0xAF	; 175
    28a6:	f9 01       	movw	r30, r18
    28a8:	20 81       	ld	r18, Z
    28aa:	fc 01       	movw	r30, r24
    28ac:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    28ae:	ce 01       	movw	r24, r28
    28b0:	06 96       	adiw	r24, 0x06	; 6
    28b2:	01 96       	adiw	r24, 0x01	; 1
    28b4:	29 81       	ldd	r18, Y+1	; 0x01
    28b6:	22 2f       	mov	r18, r18
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	2f 5f       	subi	r18, 0xFF	; 255
    28bc:	3f 4f       	sbci	r19, 0xFF	; 255
    28be:	26 5a       	subi	r18, 0xA6	; 166
    28c0:	3f 4a       	sbci	r19, 0xAF	; 175
    28c2:	f9 01       	movw	r30, r18
    28c4:	20 81       	ld	r18, Z
    28c6:	fc 01       	movw	r30, r24
    28c8:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    28ca:	ce 01       	movw	r24, r28
    28cc:	06 96       	adiw	r24, 0x06	; 6
    28ce:	29 81       	ldd	r18, Y+1	; 0x01
    28d0:	22 2f       	mov	r18, r18
    28d2:	30 e0       	ldi	r19, 0x00	; 0
    28d4:	2e 5f       	subi	r18, 0xFE	; 254
    28d6:	3f 4f       	sbci	r19, 0xFF	; 255
    28d8:	26 5a       	subi	r18, 0xA6	; 166
    28da:	3f 4a       	sbci	r19, 0xAF	; 175
    28dc:	f9 01       	movw	r30, r18
    28de:	20 81       	ld	r18, Z
    28e0:	fc 01       	movw	r30, r24
    28e2:	20 83       	st	Z, r18
		sum += currentSample;
    28e4:	2a 81       	ldd	r18, Y+2	; 0x02
    28e6:	3b 81       	ldd	r19, Y+3	; 0x03
    28e8:	4c 81       	ldd	r20, Y+4	; 0x04
    28ea:	5d 81       	ldd	r21, Y+5	; 0x05
    28ec:	8e 81       	ldd	r24, Y+6	; 0x06
    28ee:	9f 81       	ldd	r25, Y+7	; 0x07
    28f0:	a8 85       	ldd	r26, Y+8	; 0x08
    28f2:	b9 85       	ldd	r27, Y+9	; 0x09
    28f4:	82 0f       	add	r24, r18
    28f6:	93 1f       	adc	r25, r19
    28f8:	a4 1f       	adc	r26, r20
    28fa:	b5 1f       	adc	r27, r21
    28fc:	8a 83       	std	Y+2, r24	; 0x02
    28fe:	9b 83       	std	Y+3, r25	; 0x03
    2900:	ac 83       	std	Y+4, r26	; 0x04
    2902:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2904:	89 81       	ldd	r24, Y+1	; 0x01
    2906:	8d 5f       	subi	r24, 0xFD	; 253
    2908:	89 83       	std	Y+1, r24	; 0x01
    290a:	89 81       	ldd	r24, Y+1	; 0x01
    290c:	8c 30       	cpi	r24, 0x0C	; 12
    290e:	08 f4       	brcc	.+2      	; 0x2912 <writeSE2FRAM+0xf0>
    2910:	ad cf       	rjmp	.-166    	; 0x286c <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2912:	8a 81       	ldd	r24, Y+2	; 0x02
    2914:	9b 81       	ldd	r25, Y+3	; 0x03
    2916:	ac 81       	ldd	r26, Y+4	; 0x04
    2918:	bd 81       	ldd	r27, Y+5	; 0x05
    291a:	24 e0       	ldi	r18, 0x04	; 4
    291c:	30 e0       	ldi	r19, 0x00	; 0
    291e:	40 e0       	ldi	r20, 0x00	; 0
    2920:	50 e0       	ldi	r21, 0x00	; 0
    2922:	bc 01       	movw	r22, r24
    2924:	cd 01       	movw	r24, r26
    2926:	0e 94 0c 62 	call	0xc418	; 0xc418 <__divmodsi4>
    292a:	da 01       	movw	r26, r20
    292c:	c9 01       	movw	r24, r18
    292e:	8a 83       	std	Y+2, r24	; 0x02
    2930:	9b 83       	std	Y+3, r25	; 0x03
    2932:	ac 83       	std	Y+4, r26	; 0x04
    2934:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2936:	ce 01       	movw	r24, r28
    2938:	02 96       	adiw	r24, 0x02	; 2
    293a:	fc 01       	movw	r30, r24
    293c:	80 81       	ld	r24, Z
    293e:	80 93 5c 50 	sts	0x505C, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2942:	ce 01       	movw	r24, r28
    2944:	02 96       	adiw	r24, 0x02	; 2
    2946:	fc 01       	movw	r30, r24
    2948:	81 81       	ldd	r24, Z+1	; 0x01
    294a:	80 93 5b 50 	sts	0x505B, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    294e:	ce 01       	movw	r24, r28
    2950:	02 96       	adiw	r24, 0x02	; 2
    2952:	fc 01       	movw	r30, r24
    2954:	82 81       	ldd	r24, Z+2	; 0x02
    2956:	80 93 5a 50 	sts	0x505A, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    295a:	80 e4       	ldi	r24, 0x40	; 64
    295c:	96 e0       	ldi	r25, 0x06	; 6
    295e:	20 e1       	ldi	r18, 0x10	; 16
    2960:	fc 01       	movw	r30, r24
    2962:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2964:	80 e2       	ldi	r24, 0x20	; 32
    2966:	96 e0       	ldi	r25, 0x06	; 6
    2968:	28 e0       	ldi	r18, 0x08	; 8
    296a:	fc 01       	movw	r30, r24
    296c:	26 83       	std	Z+6, r18	; 0x06
	nop();
    296e:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2970:	80 ec       	ldi	r24, 0xC0	; 192
    2972:	98 e0       	ldi	r25, 0x08	; 8
    2974:	26 e0       	ldi	r18, 0x06	; 6
    2976:	fc 01       	movw	r30, r24
    2978:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    297a:	00 00       	nop
    297c:	80 ec       	ldi	r24, 0xC0	; 192
    297e:	98 e0       	ldi	r25, 0x08	; 8
    2980:	fc 01       	movw	r30, r24
    2982:	82 81       	ldd	r24, Z+2	; 0x02
    2984:	88 23       	and	r24, r24
    2986:	d4 f7       	brge	.-12     	; 0x297c <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    2988:	80 ec       	ldi	r24, 0xC0	; 192
    298a:	98 e0       	ldi	r25, 0x08	; 8
    298c:	fc 01       	movw	r30, r24
    298e:	83 81       	ldd	r24, Z+3	; 0x03
    2990:	80 93 66 50 	sts	0x5066, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2994:	80 e2       	ldi	r24, 0x20	; 32
    2996:	96 e0       	ldi	r25, 0x06	; 6
    2998:	28 e0       	ldi	r18, 0x08	; 8
    299a:	fc 01       	movw	r30, r24
    299c:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    299e:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    29a0:	80 e2       	ldi	r24, 0x20	; 32
    29a2:	96 e0       	ldi	r25, 0x06	; 6
    29a4:	28 e0       	ldi	r18, 0x08	; 8
    29a6:	fc 01       	movw	r30, r24
    29a8:	26 83       	std	Z+6, r18	; 0x06
	nop();
    29aa:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    29ac:	80 ec       	ldi	r24, 0xC0	; 192
    29ae:	98 e0       	ldi	r25, 0x08	; 8
    29b0:	22 e0       	ldi	r18, 0x02	; 2
    29b2:	fc 01       	movw	r30, r24
    29b4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29b6:	00 00       	nop
    29b8:	80 ec       	ldi	r24, 0xC0	; 192
    29ba:	98 e0       	ldi	r25, 0x08	; 8
    29bc:	fc 01       	movw	r30, r24
    29be:	82 81       	ldd	r24, Z+2	; 0x02
    29c0:	88 23       	and	r24, r24
    29c2:	d4 f7       	brge	.-12     	; 0x29b8 <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    29c4:	80 ec       	ldi	r24, 0xC0	; 192
    29c6:	98 e0       	ldi	r25, 0x08	; 8
    29c8:	fc 01       	movw	r30, r24
    29ca:	83 81       	ldd	r24, Z+3	; 0x03
    29cc:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    29d0:	80 ec       	ldi	r24, 0xC0	; 192
    29d2:	98 e0       	ldi	r25, 0x08	; 8
    29d4:	20 91 45 40 	lds	r18, 0x4045
    29d8:	fc 01       	movw	r30, r24
    29da:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29dc:	00 00       	nop
    29de:	80 ec       	ldi	r24, 0xC0	; 192
    29e0:	98 e0       	ldi	r25, 0x08	; 8
    29e2:	fc 01       	movw	r30, r24
    29e4:	82 81       	ldd	r24, Z+2	; 0x02
    29e6:	88 23       	and	r24, r24
    29e8:	d4 f7       	brge	.-12     	; 0x29de <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    29ea:	80 ec       	ldi	r24, 0xC0	; 192
    29ec:	98 e0       	ldi	r25, 0x08	; 8
    29ee:	fc 01       	movw	r30, r24
    29f0:	83 81       	ldd	r24, Z+3	; 0x03
    29f2:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    29f6:	80 ec       	ldi	r24, 0xC0	; 192
    29f8:	98 e0       	ldi	r25, 0x08	; 8
    29fa:	24 e4       	ldi	r18, 0x44	; 68
    29fc:	30 e4       	ldi	r19, 0x40	; 64
    29fe:	f9 01       	movw	r30, r18
    2a00:	20 81       	ld	r18, Z
    2a02:	fc 01       	movw	r30, r24
    2a04:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a06:	00 00       	nop
    2a08:	80 ec       	ldi	r24, 0xC0	; 192
    2a0a:	98 e0       	ldi	r25, 0x08	; 8
    2a0c:	fc 01       	movw	r30, r24
    2a0e:	82 81       	ldd	r24, Z+2	; 0x02
    2a10:	88 23       	and	r24, r24
    2a12:	d4 f7       	brge	.-12     	; 0x2a08 <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    2a14:	80 ec       	ldi	r24, 0xC0	; 192
    2a16:	98 e0       	ldi	r25, 0x08	; 8
    2a18:	fc 01       	movw	r30, r24
    2a1a:	83 81       	ldd	r24, Z+3	; 0x03
    2a1c:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[0];
    2a20:	80 ec       	ldi	r24, 0xC0	; 192
    2a22:	98 e0       	ldi	r25, 0x08	; 8
    2a24:	20 91 5a 50 	lds	r18, 0x505A
    2a28:	fc 01       	movw	r30, r24
    2a2a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a2c:	00 00       	nop
    2a2e:	80 ec       	ldi	r24, 0xC0	; 192
    2a30:	98 e0       	ldi	r25, 0x08	; 8
    2a32:	fc 01       	movw	r30, r24
    2a34:	82 81       	ldd	r24, Z+2	; 0x02
    2a36:	88 23       	and	r24, r24
    2a38:	d4 f7       	brge	.-12     	; 0x2a2e <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    2a3a:	80 ec       	ldi	r24, 0xC0	; 192
    2a3c:	98 e0       	ldi	r25, 0x08	; 8
    2a3e:	fc 01       	movw	r30, r24
    2a40:	83 81       	ldd	r24, Z+3	; 0x03
    2a42:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[1];
    2a46:	80 ec       	ldi	r24, 0xC0	; 192
    2a48:	98 e0       	ldi	r25, 0x08	; 8
    2a4a:	20 91 5b 50 	lds	r18, 0x505B
    2a4e:	fc 01       	movw	r30, r24
    2a50:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a52:	00 00       	nop
    2a54:	80 ec       	ldi	r24, 0xC0	; 192
    2a56:	98 e0       	ldi	r25, 0x08	; 8
    2a58:	fc 01       	movw	r30, r24
    2a5a:	82 81       	ldd	r24, Z+2	; 0x02
    2a5c:	88 23       	and	r24, r24
    2a5e:	d4 f7       	brge	.-12     	; 0x2a54 <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    2a60:	80 ec       	ldi	r24, 0xC0	; 192
    2a62:	98 e0       	ldi	r25, 0x08	; 8
    2a64:	fc 01       	movw	r30, r24
    2a66:	83 81       	ldd	r24, Z+3	; 0x03
    2a68:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[2];
    2a6c:	80 ec       	ldi	r24, 0xC0	; 192
    2a6e:	98 e0       	ldi	r25, 0x08	; 8
    2a70:	20 91 5c 50 	lds	r18, 0x505C
    2a74:	fc 01       	movw	r30, r24
    2a76:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a78:	00 00       	nop
    2a7a:	80 ec       	ldi	r24, 0xC0	; 192
    2a7c:	98 e0       	ldi	r25, 0x08	; 8
    2a7e:	fc 01       	movw	r30, r24
    2a80:	82 81       	ldd	r24, Z+2	; 0x02
    2a82:	88 23       	and	r24, r24
    2a84:	d4 f7       	brge	.-12     	; 0x2a7a <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    2a86:	80 ec       	ldi	r24, 0xC0	; 192
    2a88:	98 e0       	ldi	r25, 0x08	; 8
    2a8a:	fc 01       	movw	r30, r24
    2a8c:	83 81       	ldd	r24, Z+3	; 0x03
    2a8e:	80 93 66 50 	sts	0x5066, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2a92:	80 e2       	ldi	r24, 0x20	; 32
    2a94:	96 e0       	ldi	r25, 0x06	; 6
    2a96:	28 e0       	ldi	r18, 0x08	; 8
    2a98:	fc 01       	movw	r30, r24
    2a9a:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2a9c:	80 e4       	ldi	r24, 0x40	; 64
    2a9e:	96 e0       	ldi	r25, 0x06	; 6
    2aa0:	20 e1       	ldi	r18, 0x10	; 16
    2aa2:	fc 01       	movw	r30, r24
    2aa4:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2aa6:	80 ec       	ldi	r24, 0xC0	; 192
    2aa8:	98 e0       	ldi	r25, 0x08	; 8
    2aaa:	24 e5       	ldi	r18, 0x54	; 84
    2aac:	fc 01       	movw	r30, r24
    2aae:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2ab0:	80 e4       	ldi	r24, 0x40	; 64
    2ab2:	96 e0       	ldi	r25, 0x06	; 6
    2ab4:	20 e1       	ldi	r18, 0x10	; 16
    2ab6:	fc 01       	movw	r30, r24
    2ab8:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2aba:	80 91 44 40 	lds	r24, 0x4044
    2abe:	90 91 45 40 	lds	r25, 0x4045
    2ac2:	03 96       	adiw	r24, 0x03	; 3
    2ac4:	80 93 44 40 	sts	0x4044, r24
    2ac8:	90 93 45 40 	sts	0x4045, r25
	checksumADC[0] += SPIBuffer[0];
    2acc:	90 91 26 21 	lds	r25, 0x2126
    2ad0:	80 91 5a 50 	lds	r24, 0x505A
    2ad4:	89 0f       	add	r24, r25
    2ad6:	80 93 26 21 	sts	0x2126, r24
	checksumADC[1] += SPIBuffer[1];
    2ada:	90 91 27 21 	lds	r25, 0x2127
    2ade:	80 91 5b 50 	lds	r24, 0x505B
    2ae2:	89 0f       	add	r24, r25
    2ae4:	80 93 27 21 	sts	0x2127, r24
	checksumADC[2] += SPIBuffer[2];
    2ae8:	90 91 28 21 	lds	r25, 0x2128
    2aec:	80 91 5c 50 	lds	r24, 0x505C
    2af0:	89 0f       	add	r24, r25
    2af2:	80 93 28 21 	sts	0x2128, r24
}
    2af6:	29 96       	adiw	r28, 0x09	; 9
    2af8:	cd bf       	out	0x3d, r28	; 61
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	df 91       	pop	r29
    2afe:	cf 91       	pop	r28
    2b00:	08 95       	ret

00002b02 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    2b02:	2f 92       	push	r2
    2b04:	3f 92       	push	r3
    2b06:	4f 92       	push	r4
    2b08:	5f 92       	push	r5
    2b0a:	6f 92       	push	r6
    2b0c:	7f 92       	push	r7
    2b0e:	8f 92       	push	r8
    2b10:	9f 92       	push	r9
    2b12:	af 92       	push	r10
    2b14:	bf 92       	push	r11
    2b16:	cf 92       	push	r12
    2b18:	df 92       	push	r13
    2b1a:	ef 92       	push	r14
    2b1c:	ff 92       	push	r15
    2b1e:	0f 93       	push	r16
    2b20:	1f 93       	push	r17
    2b22:	cf 93       	push	r28
    2b24:	df 93       	push	r29
    2b26:	00 d0       	rcall	.+0      	; 0x2b28 <calcChecksumFRAM+0x26>
    2b28:	0f 92       	push	r0
    2b2a:	cd b7       	in	r28, 0x3d	; 61
    2b2c:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2b2e:	aa 24       	eor	r10, r10
    2b30:	bb 24       	eor	r11, r11
    2b32:	cc 24       	eor	r12, r12
    2b34:	dd 24       	eor	r13, r13
    2b36:	ee 24       	eor	r14, r14
    2b38:	ff 24       	eor	r15, r15
    2b3a:	00 e0       	ldi	r16, 0x00	; 0
    2b3c:	10 e0       	ldi	r17, 0x00	; 0
    2b3e:	a0 92 90 50 	sts	0x5090, r10
    2b42:	b0 92 91 50 	sts	0x5091, r11
    2b46:	c0 92 92 50 	sts	0x5092, r12
    2b4a:	d0 92 93 50 	sts	0x5093, r13
    2b4e:	e0 92 94 50 	sts	0x5094, r14
    2b52:	f0 92 95 50 	sts	0x5095, r15
    2b56:	00 93 96 50 	sts	0x5096, r16
    2b5a:	10 93 97 50 	sts	0x5097, r17
    2b5e:	2a 2d       	mov	r18, r10
    2b60:	3b 2d       	mov	r19, r11
    2b62:	4c 2d       	mov	r20, r12
    2b64:	5d 2d       	mov	r21, r13
    2b66:	6e 2d       	mov	r22, r14
    2b68:	7f 2d       	mov	r23, r15
    2b6a:	80 2f       	mov	r24, r16
    2b6c:	91 2f       	mov	r25, r17
    2b6e:	20 93 88 50 	sts	0x5088, r18
    2b72:	30 93 89 50 	sts	0x5089, r19
    2b76:	40 93 8a 50 	sts	0x508A, r20
    2b7a:	50 93 8b 50 	sts	0x508B, r21
    2b7e:	60 93 8c 50 	sts	0x508C, r22
    2b82:	70 93 8d 50 	sts	0x508D, r23
    2b86:	80 93 8e 50 	sts	0x508E, r24
    2b8a:	90 93 8f 50 	sts	0x508F, r25
    2b8e:	20 93 80 50 	sts	0x5080, r18
    2b92:	30 93 81 50 	sts	0x5081, r19
    2b96:	40 93 82 50 	sts	0x5082, r20
    2b9a:	50 93 83 50 	sts	0x5083, r21
    2b9e:	60 93 84 50 	sts	0x5084, r22
    2ba2:	70 93 85 50 	sts	0x5085, r23
    2ba6:	80 93 86 50 	sts	0x5086, r24
    2baa:	90 93 87 50 	sts	0x5087, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2bae:	80 e0       	ldi	r24, 0x00	; 0
    2bb0:	80 93 2b 21 	sts	0x212B, r24
    2bb4:	80 93 2a 21 	sts	0x212A, r24
    2bb8:	80 93 29 21 	sts	0x2129, r24
	FRAMAddress = FR_BASEADD;
    2bbc:	10 92 44 40 	sts	0x4044, r1
    2bc0:	10 92 45 40 	sts	0x4045, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2bc4:	19 82       	std	Y+1, r1	; 0x01
    2bc6:	1a 82       	std	Y+2, r1	; 0x02
    2bc8:	88 c2       	rjmp	.+1296   	; 0x30da <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2bca:	81 e7       	ldi	r24, 0x71	; 113
    2bcc:	9c e1       	ldi	r25, 0x1C	; 28
    2bce:	0e 94 92 37 	call	0x6f24	; 0x6f24 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2bd2:	80 91 44 40 	lds	r24, 0x4044
    2bd6:	90 91 45 40 	lds	r25, 0x4045
    2bda:	8f 58       	subi	r24, 0x8F	; 143
    2bdc:	93 4e       	sbci	r25, 0xE3	; 227
    2bde:	80 93 44 40 	sts	0x4044, r24
    2be2:	90 93 45 40 	sts	0x4045, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2be6:	1b 82       	std	Y+3, r1	; 0x03
    2be8:	1c 82       	std	Y+4, r1	; 0x04
    2bea:	6b c2       	rjmp	.+1238   	; 0x30c2 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2bec:	8b 81       	ldd	r24, Y+3	; 0x03
    2bee:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf0:	23 e0       	ldi	r18, 0x03	; 3
    2bf2:	30 e0       	ldi	r19, 0x00	; 0
    2bf4:	b9 01       	movw	r22, r18
    2bf6:	0e 94 c3 61 	call	0xc386	; 0xc386 <__udivmodhi4>
    2bfa:	9c 01       	movw	r18, r24
    2bfc:	27 5d       	subi	r18, 0xD7	; 215
    2bfe:	3e 4d       	sbci	r19, 0xDE	; 222
    2c00:	f9 01       	movw	r30, r18
    2c02:	40 81       	ld	r20, Z
    2c04:	2b 81       	ldd	r18, Y+3	; 0x03
    2c06:	3c 81       	ldd	r19, Y+4	; 0x04
    2c08:	24 53       	subi	r18, 0x34	; 52
    2c0a:	3c 4d       	sbci	r19, 0xDC	; 220
    2c0c:	f9 01       	movw	r30, r18
    2c0e:	20 81       	ld	r18, Z
    2c10:	24 0f       	add	r18, r20
    2c12:	87 5d       	subi	r24, 0xD7	; 215
    2c14:	9e 4d       	sbci	r25, 0xDE	; 222
    2c16:	fc 01       	movw	r30, r24
    2c18:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1e:	23 e0       	ldi	r18, 0x03	; 3
    2c20:	30 e0       	ldi	r19, 0x00	; 0
    2c22:	b9 01       	movw	r22, r18
    2c24:	0e 94 c3 61 	call	0xc386	; 0xc386 <__udivmodhi4>
    2c28:	00 97       	sbiw	r24, 0x00	; 0
    2c2a:	09 f0       	breq	.+2      	; 0x2c2e <calcChecksumFRAM+0x12c>
    2c2c:	44 c0       	rjmp	.+136    	; 0x2cb6 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c30:	9c 81       	ldd	r25, Y+4	; 0x04
    2c32:	84 53       	subi	r24, 0x34	; 52
    2c34:	9c 4d       	sbci	r25, 0xDC	; 220
    2c36:	fc 01       	movw	r30, r24
    2c38:	80 81       	ld	r24, Z
    2c3a:	88 23       	and	r24, r24
    2c3c:	d4 f4       	brge	.+52     	; 0x2c72 <calcChecksumFRAM+0x170>
    2c3e:	80 91 58 50 	lds	r24, 0x5058
    2c42:	90 91 59 50 	lds	r25, 0x5059
    2c46:	fc 01       	movw	r30, r24
    2c48:	10 82       	st	Z, r1
    2c4a:	fc 01       	movw	r30, r24
    2c4c:	11 82       	std	Z+1, r1	; 0x01
    2c4e:	fc 01       	movw	r30, r24
    2c50:	12 82       	std	Z+2, r1	; 0x02
    2c52:	2f ef       	ldi	r18, 0xFF	; 255
    2c54:	fc 01       	movw	r30, r24
    2c56:	23 83       	std	Z+3, r18	; 0x03
    2c58:	2f ef       	ldi	r18, 0xFF	; 255
    2c5a:	fc 01       	movw	r30, r24
    2c5c:	24 83       	std	Z+4, r18	; 0x04
    2c5e:	2f ef       	ldi	r18, 0xFF	; 255
    2c60:	fc 01       	movw	r30, r24
    2c62:	25 83       	std	Z+5, r18	; 0x05
    2c64:	2f ef       	ldi	r18, 0xFF	; 255
    2c66:	fc 01       	movw	r30, r24
    2c68:	26 83       	std	Z+6, r18	; 0x06
    2c6a:	2f ef       	ldi	r18, 0xFF	; 255
    2c6c:	fc 01       	movw	r30, r24
    2c6e:	27 83       	std	Z+7, r18	; 0x07
    2c70:	14 c0       	rjmp	.+40     	; 0x2c9a <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2c72:	80 91 58 50 	lds	r24, 0x5058
    2c76:	90 91 59 50 	lds	r25, 0x5059
    2c7a:	fc 01       	movw	r30, r24
    2c7c:	10 82       	st	Z, r1
    2c7e:	fc 01       	movw	r30, r24
    2c80:	11 82       	std	Z+1, r1	; 0x01
    2c82:	fc 01       	movw	r30, r24
    2c84:	12 82       	std	Z+2, r1	; 0x02
    2c86:	fc 01       	movw	r30, r24
    2c88:	13 82       	std	Z+3, r1	; 0x03
    2c8a:	fc 01       	movw	r30, r24
    2c8c:	14 82       	std	Z+4, r1	; 0x04
    2c8e:	fc 01       	movw	r30, r24
    2c90:	15 82       	std	Z+5, r1	; 0x05
    2c92:	fc 01       	movw	r30, r24
    2c94:	16 82       	std	Z+6, r1	; 0x06
    2c96:	fc 01       	movw	r30, r24
    2c98:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2c9a:	80 91 58 50 	lds	r24, 0x5058
    2c9e:	90 91 59 50 	lds	r25, 0x5059
    2ca2:	02 96       	adiw	r24, 0x02	; 2
    2ca4:	2b 81       	ldd	r18, Y+3	; 0x03
    2ca6:	3c 81       	ldd	r19, Y+4	; 0x04
    2ca8:	24 53       	subi	r18, 0x34	; 52
    2caa:	3c 4d       	sbci	r19, 0xDC	; 220
    2cac:	f9 01       	movw	r30, r18
    2cae:	20 81       	ld	r18, Z
    2cb0:	fc 01       	movw	r30, r24
    2cb2:	20 83       	st	Z, r18
    2cb4:	24 c0       	rjmp	.+72     	; 0x2cfe <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cba:	23 e0       	ldi	r18, 0x03	; 3
    2cbc:	30 e0       	ldi	r19, 0x00	; 0
    2cbe:	b9 01       	movw	r22, r18
    2cc0:	0e 94 c3 61 	call	0xc386	; 0xc386 <__udivmodhi4>
    2cc4:	81 30       	cpi	r24, 0x01	; 1
    2cc6:	91 05       	cpc	r25, r1
    2cc8:	71 f4       	brne	.+28     	; 0x2ce6 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2cca:	80 91 58 50 	lds	r24, 0x5058
    2cce:	90 91 59 50 	lds	r25, 0x5059
    2cd2:	01 96       	adiw	r24, 0x01	; 1
    2cd4:	2b 81       	ldd	r18, Y+3	; 0x03
    2cd6:	3c 81       	ldd	r19, Y+4	; 0x04
    2cd8:	24 53       	subi	r18, 0x34	; 52
    2cda:	3c 4d       	sbci	r19, 0xDC	; 220
    2cdc:	f9 01       	movw	r30, r18
    2cde:	20 81       	ld	r18, Z
    2ce0:	fc 01       	movw	r30, r24
    2ce2:	20 83       	st	Z, r18
    2ce4:	0c c0       	rjmp	.+24     	; 0x2cfe <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2ce6:	80 91 58 50 	lds	r24, 0x5058
    2cea:	90 91 59 50 	lds	r25, 0x5059
    2cee:	2b 81       	ldd	r18, Y+3	; 0x03
    2cf0:	3c 81       	ldd	r19, Y+4	; 0x04
    2cf2:	24 53       	subi	r18, 0x34	; 52
    2cf4:	3c 4d       	sbci	r19, 0xDC	; 220
    2cf6:	f9 01       	movw	r30, r18
    2cf8:	20 81       	ld	r18, Z
    2cfa:	fc 01       	movw	r30, r24
    2cfc:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2d00:	9c 81       	ldd	r25, Y+4	; 0x04
    2d02:	29 e0       	ldi	r18, 0x09	; 9
    2d04:	30 e0       	ldi	r19, 0x00	; 0
    2d06:	b9 01       	movw	r22, r18
    2d08:	0e 94 c3 61 	call	0xc386	; 0xc386 <__udivmodhi4>
    2d0c:	82 30       	cpi	r24, 0x02	; 2
    2d0e:	91 05       	cpc	r25, r1
    2d10:	09 f0       	breq	.+2      	; 0x2d14 <calcChecksumFRAM+0x212>
    2d12:	94 c0       	rjmp	.+296    	; 0x2e3c <calcChecksumFRAM+0x33a>
    2d14:	a0 90 80 50 	lds	r10, 0x5080
    2d18:	b0 90 81 50 	lds	r11, 0x5081
    2d1c:	c0 90 82 50 	lds	r12, 0x5082
    2d20:	d0 90 83 50 	lds	r13, 0x5083
    2d24:	e0 90 84 50 	lds	r14, 0x5084
    2d28:	f0 90 85 50 	lds	r15, 0x5085
    2d2c:	00 91 86 50 	lds	r16, 0x5086
    2d30:	10 91 87 50 	lds	r17, 0x5087
    2d34:	80 91 58 50 	lds	r24, 0x5058
    2d38:	90 91 59 50 	lds	r25, 0x5059
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	20 80       	ld	r2, Z
    2d40:	fc 01       	movw	r30, r24
    2d42:	31 80       	ldd	r3, Z+1	; 0x01
    2d44:	fc 01       	movw	r30, r24
    2d46:	42 80       	ldd	r4, Z+2	; 0x02
    2d48:	fc 01       	movw	r30, r24
    2d4a:	53 80       	ldd	r5, Z+3	; 0x03
    2d4c:	fc 01       	movw	r30, r24
    2d4e:	64 80       	ldd	r6, Z+4	; 0x04
    2d50:	fc 01       	movw	r30, r24
    2d52:	75 80       	ldd	r7, Z+5	; 0x05
    2d54:	fc 01       	movw	r30, r24
    2d56:	86 80       	ldd	r8, Z+6	; 0x06
    2d58:	fc 01       	movw	r30, r24
    2d5a:	97 80       	ldd	r9, Z+7	; 0x07
    2d5c:	2a 2d       	mov	r18, r10
    2d5e:	22 0d       	add	r18, r2
    2d60:	e1 e0       	ldi	r30, 0x01	; 1
    2d62:	2a 15       	cp	r18, r10
    2d64:	08 f0       	brcs	.+2      	; 0x2d68 <calcChecksumFRAM+0x266>
    2d66:	e0 e0       	ldi	r30, 0x00	; 0
    2d68:	3b 2d       	mov	r19, r11
    2d6a:	33 0d       	add	r19, r3
    2d6c:	f1 e0       	ldi	r31, 0x01	; 1
    2d6e:	3b 15       	cp	r19, r11
    2d70:	08 f0       	brcs	.+2      	; 0x2d74 <calcChecksumFRAM+0x272>
    2d72:	f0 e0       	ldi	r31, 0x00	; 0
    2d74:	e3 0f       	add	r30, r19
    2d76:	a1 e0       	ldi	r26, 0x01	; 1
    2d78:	e3 17       	cp	r30, r19
    2d7a:	08 f0       	brcs	.+2      	; 0x2d7e <calcChecksumFRAM+0x27c>
    2d7c:	a0 e0       	ldi	r26, 0x00	; 0
    2d7e:	fa 2b       	or	r31, r26
    2d80:	3e 2f       	mov	r19, r30
    2d82:	4c 2d       	mov	r20, r12
    2d84:	44 0d       	add	r20, r4
    2d86:	e1 e0       	ldi	r30, 0x01	; 1
    2d88:	4c 15       	cp	r20, r12
    2d8a:	08 f0       	brcs	.+2      	; 0x2d8e <calcChecksumFRAM+0x28c>
    2d8c:	e0 e0       	ldi	r30, 0x00	; 0
    2d8e:	f4 0f       	add	r31, r20
    2d90:	a1 e0       	ldi	r26, 0x01	; 1
    2d92:	f4 17       	cp	r31, r20
    2d94:	08 f0       	brcs	.+2      	; 0x2d98 <calcChecksumFRAM+0x296>
    2d96:	a0 e0       	ldi	r26, 0x00	; 0
    2d98:	ea 2b       	or	r30, r26
    2d9a:	4f 2f       	mov	r20, r31
    2d9c:	5d 2d       	mov	r21, r13
    2d9e:	55 0d       	add	r21, r5
    2da0:	f1 e0       	ldi	r31, 0x01	; 1
    2da2:	5d 15       	cp	r21, r13
    2da4:	08 f0       	brcs	.+2      	; 0x2da8 <calcChecksumFRAM+0x2a6>
    2da6:	f0 e0       	ldi	r31, 0x00	; 0
    2da8:	e5 0f       	add	r30, r21
    2daa:	a1 e0       	ldi	r26, 0x01	; 1
    2dac:	e5 17       	cp	r30, r21
    2dae:	08 f0       	brcs	.+2      	; 0x2db2 <calcChecksumFRAM+0x2b0>
    2db0:	a0 e0       	ldi	r26, 0x00	; 0
    2db2:	fa 2b       	or	r31, r26
    2db4:	5e 2f       	mov	r21, r30
    2db6:	6e 2d       	mov	r22, r14
    2db8:	66 0d       	add	r22, r6
    2dba:	e1 e0       	ldi	r30, 0x01	; 1
    2dbc:	6e 15       	cp	r22, r14
    2dbe:	08 f0       	brcs	.+2      	; 0x2dc2 <calcChecksumFRAM+0x2c0>
    2dc0:	e0 e0       	ldi	r30, 0x00	; 0
    2dc2:	f6 0f       	add	r31, r22
    2dc4:	a1 e0       	ldi	r26, 0x01	; 1
    2dc6:	f6 17       	cp	r31, r22
    2dc8:	08 f0       	brcs	.+2      	; 0x2dcc <calcChecksumFRAM+0x2ca>
    2dca:	a0 e0       	ldi	r26, 0x00	; 0
    2dcc:	ea 2b       	or	r30, r26
    2dce:	6f 2f       	mov	r22, r31
    2dd0:	7f 2d       	mov	r23, r15
    2dd2:	77 0d       	add	r23, r7
    2dd4:	f1 e0       	ldi	r31, 0x01	; 1
    2dd6:	7f 15       	cp	r23, r15
    2dd8:	08 f0       	brcs	.+2      	; 0x2ddc <calcChecksumFRAM+0x2da>
    2dda:	f0 e0       	ldi	r31, 0x00	; 0
    2ddc:	e7 0f       	add	r30, r23
    2dde:	a1 e0       	ldi	r26, 0x01	; 1
    2de0:	e7 17       	cp	r30, r23
    2de2:	08 f0       	brcs	.+2      	; 0x2de6 <calcChecksumFRAM+0x2e4>
    2de4:	a0 e0       	ldi	r26, 0x00	; 0
    2de6:	fa 2b       	or	r31, r26
    2de8:	7e 2f       	mov	r23, r30
    2dea:	80 2f       	mov	r24, r16
    2dec:	88 0d       	add	r24, r8
    2dee:	e1 e0       	ldi	r30, 0x01	; 1
    2df0:	80 17       	cp	r24, r16
    2df2:	08 f0       	brcs	.+2      	; 0x2df6 <calcChecksumFRAM+0x2f4>
    2df4:	e0 e0       	ldi	r30, 0x00	; 0
    2df6:	f8 0f       	add	r31, r24
    2df8:	a1 e0       	ldi	r26, 0x01	; 1
    2dfa:	f8 17       	cp	r31, r24
    2dfc:	08 f0       	brcs	.+2      	; 0x2e00 <calcChecksumFRAM+0x2fe>
    2dfe:	a0 e0       	ldi	r26, 0x00	; 0
    2e00:	ea 2b       	or	r30, r26
    2e02:	8f 2f       	mov	r24, r31
    2e04:	91 2f       	mov	r25, r17
    2e06:	99 0d       	add	r25, r9
    2e08:	e9 0f       	add	r30, r25
    2e0a:	9e 2f       	mov	r25, r30
    2e0c:	a2 2e       	mov	r10, r18
    2e0e:	b3 2e       	mov	r11, r19
    2e10:	c4 2e       	mov	r12, r20
    2e12:	d5 2e       	mov	r13, r21
    2e14:	e6 2e       	mov	r14, r22
    2e16:	f7 2e       	mov	r15, r23
    2e18:	08 2f       	mov	r16, r24
    2e1a:	19 2f       	mov	r17, r25
    2e1c:	a0 92 80 50 	sts	0x5080, r10
    2e20:	b0 92 81 50 	sts	0x5081, r11
    2e24:	c0 92 82 50 	sts	0x5082, r12
    2e28:	d0 92 83 50 	sts	0x5083, r13
    2e2c:	e0 92 84 50 	sts	0x5084, r14
    2e30:	f0 92 85 50 	sts	0x5085, r15
    2e34:	00 93 86 50 	sts	0x5086, r16
    2e38:	10 93 87 50 	sts	0x5087, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    2e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e40:	29 e0       	ldi	r18, 0x09	; 9
    2e42:	30 e0       	ldi	r19, 0x00	; 0
    2e44:	b9 01       	movw	r22, r18
    2e46:	0e 94 c3 61 	call	0xc386	; 0xc386 <__udivmodhi4>
    2e4a:	85 30       	cpi	r24, 0x05	; 5
    2e4c:	91 05       	cpc	r25, r1
    2e4e:	09 f0       	breq	.+2      	; 0x2e52 <calcChecksumFRAM+0x350>
    2e50:	94 c0       	rjmp	.+296    	; 0x2f7a <calcChecksumFRAM+0x478>
    2e52:	a0 90 88 50 	lds	r10, 0x5088
    2e56:	b0 90 89 50 	lds	r11, 0x5089
    2e5a:	c0 90 8a 50 	lds	r12, 0x508A
    2e5e:	d0 90 8b 50 	lds	r13, 0x508B
    2e62:	e0 90 8c 50 	lds	r14, 0x508C
    2e66:	f0 90 8d 50 	lds	r15, 0x508D
    2e6a:	00 91 8e 50 	lds	r16, 0x508E
    2e6e:	10 91 8f 50 	lds	r17, 0x508F
    2e72:	80 91 58 50 	lds	r24, 0x5058
    2e76:	90 91 59 50 	lds	r25, 0x5059
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	20 80       	ld	r2, Z
    2e7e:	fc 01       	movw	r30, r24
    2e80:	31 80       	ldd	r3, Z+1	; 0x01
    2e82:	fc 01       	movw	r30, r24
    2e84:	42 80       	ldd	r4, Z+2	; 0x02
    2e86:	fc 01       	movw	r30, r24
    2e88:	53 80       	ldd	r5, Z+3	; 0x03
    2e8a:	fc 01       	movw	r30, r24
    2e8c:	64 80       	ldd	r6, Z+4	; 0x04
    2e8e:	fc 01       	movw	r30, r24
    2e90:	75 80       	ldd	r7, Z+5	; 0x05
    2e92:	fc 01       	movw	r30, r24
    2e94:	86 80       	ldd	r8, Z+6	; 0x06
    2e96:	fc 01       	movw	r30, r24
    2e98:	97 80       	ldd	r9, Z+7	; 0x07
    2e9a:	2a 2d       	mov	r18, r10
    2e9c:	22 0d       	add	r18, r2
    2e9e:	e1 e0       	ldi	r30, 0x01	; 1
    2ea0:	2a 15       	cp	r18, r10
    2ea2:	08 f0       	brcs	.+2      	; 0x2ea6 <calcChecksumFRAM+0x3a4>
    2ea4:	e0 e0       	ldi	r30, 0x00	; 0
    2ea6:	3b 2d       	mov	r19, r11
    2ea8:	33 0d       	add	r19, r3
    2eaa:	f1 e0       	ldi	r31, 0x01	; 1
    2eac:	3b 15       	cp	r19, r11
    2eae:	08 f0       	brcs	.+2      	; 0x2eb2 <calcChecksumFRAM+0x3b0>
    2eb0:	f0 e0       	ldi	r31, 0x00	; 0
    2eb2:	e3 0f       	add	r30, r19
    2eb4:	a1 e0       	ldi	r26, 0x01	; 1
    2eb6:	e3 17       	cp	r30, r19
    2eb8:	08 f0       	brcs	.+2      	; 0x2ebc <calcChecksumFRAM+0x3ba>
    2eba:	a0 e0       	ldi	r26, 0x00	; 0
    2ebc:	fa 2b       	or	r31, r26
    2ebe:	3e 2f       	mov	r19, r30
    2ec0:	4c 2d       	mov	r20, r12
    2ec2:	44 0d       	add	r20, r4
    2ec4:	e1 e0       	ldi	r30, 0x01	; 1
    2ec6:	4c 15       	cp	r20, r12
    2ec8:	08 f0       	brcs	.+2      	; 0x2ecc <calcChecksumFRAM+0x3ca>
    2eca:	e0 e0       	ldi	r30, 0x00	; 0
    2ecc:	f4 0f       	add	r31, r20
    2ece:	a1 e0       	ldi	r26, 0x01	; 1
    2ed0:	f4 17       	cp	r31, r20
    2ed2:	08 f0       	brcs	.+2      	; 0x2ed6 <calcChecksumFRAM+0x3d4>
    2ed4:	a0 e0       	ldi	r26, 0x00	; 0
    2ed6:	ea 2b       	or	r30, r26
    2ed8:	4f 2f       	mov	r20, r31
    2eda:	5d 2d       	mov	r21, r13
    2edc:	55 0d       	add	r21, r5
    2ede:	f1 e0       	ldi	r31, 0x01	; 1
    2ee0:	5d 15       	cp	r21, r13
    2ee2:	08 f0       	brcs	.+2      	; 0x2ee6 <calcChecksumFRAM+0x3e4>
    2ee4:	f0 e0       	ldi	r31, 0x00	; 0
    2ee6:	e5 0f       	add	r30, r21
    2ee8:	a1 e0       	ldi	r26, 0x01	; 1
    2eea:	e5 17       	cp	r30, r21
    2eec:	08 f0       	brcs	.+2      	; 0x2ef0 <calcChecksumFRAM+0x3ee>
    2eee:	a0 e0       	ldi	r26, 0x00	; 0
    2ef0:	fa 2b       	or	r31, r26
    2ef2:	5e 2f       	mov	r21, r30
    2ef4:	6e 2d       	mov	r22, r14
    2ef6:	66 0d       	add	r22, r6
    2ef8:	e1 e0       	ldi	r30, 0x01	; 1
    2efa:	6e 15       	cp	r22, r14
    2efc:	08 f0       	brcs	.+2      	; 0x2f00 <calcChecksumFRAM+0x3fe>
    2efe:	e0 e0       	ldi	r30, 0x00	; 0
    2f00:	f6 0f       	add	r31, r22
    2f02:	a1 e0       	ldi	r26, 0x01	; 1
    2f04:	f6 17       	cp	r31, r22
    2f06:	08 f0       	brcs	.+2      	; 0x2f0a <calcChecksumFRAM+0x408>
    2f08:	a0 e0       	ldi	r26, 0x00	; 0
    2f0a:	ea 2b       	or	r30, r26
    2f0c:	6f 2f       	mov	r22, r31
    2f0e:	7f 2d       	mov	r23, r15
    2f10:	77 0d       	add	r23, r7
    2f12:	f1 e0       	ldi	r31, 0x01	; 1
    2f14:	7f 15       	cp	r23, r15
    2f16:	08 f0       	brcs	.+2      	; 0x2f1a <calcChecksumFRAM+0x418>
    2f18:	f0 e0       	ldi	r31, 0x00	; 0
    2f1a:	e7 0f       	add	r30, r23
    2f1c:	a1 e0       	ldi	r26, 0x01	; 1
    2f1e:	e7 17       	cp	r30, r23
    2f20:	08 f0       	brcs	.+2      	; 0x2f24 <calcChecksumFRAM+0x422>
    2f22:	a0 e0       	ldi	r26, 0x00	; 0
    2f24:	fa 2b       	or	r31, r26
    2f26:	7e 2f       	mov	r23, r30
    2f28:	80 2f       	mov	r24, r16
    2f2a:	88 0d       	add	r24, r8
    2f2c:	e1 e0       	ldi	r30, 0x01	; 1
    2f2e:	80 17       	cp	r24, r16
    2f30:	08 f0       	brcs	.+2      	; 0x2f34 <calcChecksumFRAM+0x432>
    2f32:	e0 e0       	ldi	r30, 0x00	; 0
    2f34:	f8 0f       	add	r31, r24
    2f36:	a1 e0       	ldi	r26, 0x01	; 1
    2f38:	f8 17       	cp	r31, r24
    2f3a:	08 f0       	brcs	.+2      	; 0x2f3e <calcChecksumFRAM+0x43c>
    2f3c:	a0 e0       	ldi	r26, 0x00	; 0
    2f3e:	ea 2b       	or	r30, r26
    2f40:	8f 2f       	mov	r24, r31
    2f42:	91 2f       	mov	r25, r17
    2f44:	99 0d       	add	r25, r9
    2f46:	e9 0f       	add	r30, r25
    2f48:	9e 2f       	mov	r25, r30
    2f4a:	a2 2e       	mov	r10, r18
    2f4c:	b3 2e       	mov	r11, r19
    2f4e:	c4 2e       	mov	r12, r20
    2f50:	d5 2e       	mov	r13, r21
    2f52:	e6 2e       	mov	r14, r22
    2f54:	f7 2e       	mov	r15, r23
    2f56:	08 2f       	mov	r16, r24
    2f58:	19 2f       	mov	r17, r25
    2f5a:	a0 92 88 50 	sts	0x5088, r10
    2f5e:	b0 92 89 50 	sts	0x5089, r11
    2f62:	c0 92 8a 50 	sts	0x508A, r12
    2f66:	d0 92 8b 50 	sts	0x508B, r13
    2f6a:	e0 92 8c 50 	sts	0x508C, r14
    2f6e:	f0 92 8d 50 	sts	0x508D, r15
    2f72:	00 93 8e 50 	sts	0x508E, r16
    2f76:	10 93 8f 50 	sts	0x508F, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    2f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f7e:	29 e0       	ldi	r18, 0x09	; 9
    2f80:	30 e0       	ldi	r19, 0x00	; 0
    2f82:	b9 01       	movw	r22, r18
    2f84:	0e 94 c3 61 	call	0xc386	; 0xc386 <__udivmodhi4>
    2f88:	88 30       	cpi	r24, 0x08	; 8
    2f8a:	91 05       	cpc	r25, r1
    2f8c:	09 f0       	breq	.+2      	; 0x2f90 <calcChecksumFRAM+0x48e>
    2f8e:	94 c0       	rjmp	.+296    	; 0x30b8 <calcChecksumFRAM+0x5b6>
    2f90:	a0 90 90 50 	lds	r10, 0x5090
    2f94:	b0 90 91 50 	lds	r11, 0x5091
    2f98:	c0 90 92 50 	lds	r12, 0x5092
    2f9c:	d0 90 93 50 	lds	r13, 0x5093
    2fa0:	e0 90 94 50 	lds	r14, 0x5094
    2fa4:	f0 90 95 50 	lds	r15, 0x5095
    2fa8:	00 91 96 50 	lds	r16, 0x5096
    2fac:	10 91 97 50 	lds	r17, 0x5097
    2fb0:	80 91 58 50 	lds	r24, 0x5058
    2fb4:	90 91 59 50 	lds	r25, 0x5059
    2fb8:	fc 01       	movw	r30, r24
    2fba:	20 80       	ld	r2, Z
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	31 80       	ldd	r3, Z+1	; 0x01
    2fc0:	fc 01       	movw	r30, r24
    2fc2:	42 80       	ldd	r4, Z+2	; 0x02
    2fc4:	fc 01       	movw	r30, r24
    2fc6:	53 80       	ldd	r5, Z+3	; 0x03
    2fc8:	fc 01       	movw	r30, r24
    2fca:	64 80       	ldd	r6, Z+4	; 0x04
    2fcc:	fc 01       	movw	r30, r24
    2fce:	75 80       	ldd	r7, Z+5	; 0x05
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	86 80       	ldd	r8, Z+6	; 0x06
    2fd4:	fc 01       	movw	r30, r24
    2fd6:	97 80       	ldd	r9, Z+7	; 0x07
    2fd8:	2a 2d       	mov	r18, r10
    2fda:	22 0d       	add	r18, r2
    2fdc:	e1 e0       	ldi	r30, 0x01	; 1
    2fde:	2a 15       	cp	r18, r10
    2fe0:	08 f0       	brcs	.+2      	; 0x2fe4 <calcChecksumFRAM+0x4e2>
    2fe2:	e0 e0       	ldi	r30, 0x00	; 0
    2fe4:	3b 2d       	mov	r19, r11
    2fe6:	33 0d       	add	r19, r3
    2fe8:	f1 e0       	ldi	r31, 0x01	; 1
    2fea:	3b 15       	cp	r19, r11
    2fec:	08 f0       	brcs	.+2      	; 0x2ff0 <calcChecksumFRAM+0x4ee>
    2fee:	f0 e0       	ldi	r31, 0x00	; 0
    2ff0:	e3 0f       	add	r30, r19
    2ff2:	a1 e0       	ldi	r26, 0x01	; 1
    2ff4:	e3 17       	cp	r30, r19
    2ff6:	08 f0       	brcs	.+2      	; 0x2ffa <calcChecksumFRAM+0x4f8>
    2ff8:	a0 e0       	ldi	r26, 0x00	; 0
    2ffa:	fa 2b       	or	r31, r26
    2ffc:	3e 2f       	mov	r19, r30
    2ffe:	4c 2d       	mov	r20, r12
    3000:	44 0d       	add	r20, r4
    3002:	e1 e0       	ldi	r30, 0x01	; 1
    3004:	4c 15       	cp	r20, r12
    3006:	08 f0       	brcs	.+2      	; 0x300a <calcChecksumFRAM+0x508>
    3008:	e0 e0       	ldi	r30, 0x00	; 0
    300a:	f4 0f       	add	r31, r20
    300c:	a1 e0       	ldi	r26, 0x01	; 1
    300e:	f4 17       	cp	r31, r20
    3010:	08 f0       	brcs	.+2      	; 0x3014 <calcChecksumFRAM+0x512>
    3012:	a0 e0       	ldi	r26, 0x00	; 0
    3014:	ea 2b       	or	r30, r26
    3016:	4f 2f       	mov	r20, r31
    3018:	5d 2d       	mov	r21, r13
    301a:	55 0d       	add	r21, r5
    301c:	f1 e0       	ldi	r31, 0x01	; 1
    301e:	5d 15       	cp	r21, r13
    3020:	08 f0       	brcs	.+2      	; 0x3024 <calcChecksumFRAM+0x522>
    3022:	f0 e0       	ldi	r31, 0x00	; 0
    3024:	e5 0f       	add	r30, r21
    3026:	a1 e0       	ldi	r26, 0x01	; 1
    3028:	e5 17       	cp	r30, r21
    302a:	08 f0       	brcs	.+2      	; 0x302e <calcChecksumFRAM+0x52c>
    302c:	a0 e0       	ldi	r26, 0x00	; 0
    302e:	fa 2b       	or	r31, r26
    3030:	5e 2f       	mov	r21, r30
    3032:	6e 2d       	mov	r22, r14
    3034:	66 0d       	add	r22, r6
    3036:	e1 e0       	ldi	r30, 0x01	; 1
    3038:	6e 15       	cp	r22, r14
    303a:	08 f0       	brcs	.+2      	; 0x303e <calcChecksumFRAM+0x53c>
    303c:	e0 e0       	ldi	r30, 0x00	; 0
    303e:	f6 0f       	add	r31, r22
    3040:	a1 e0       	ldi	r26, 0x01	; 1
    3042:	f6 17       	cp	r31, r22
    3044:	08 f0       	brcs	.+2      	; 0x3048 <calcChecksumFRAM+0x546>
    3046:	a0 e0       	ldi	r26, 0x00	; 0
    3048:	ea 2b       	or	r30, r26
    304a:	6f 2f       	mov	r22, r31
    304c:	7f 2d       	mov	r23, r15
    304e:	77 0d       	add	r23, r7
    3050:	f1 e0       	ldi	r31, 0x01	; 1
    3052:	7f 15       	cp	r23, r15
    3054:	08 f0       	brcs	.+2      	; 0x3058 <calcChecksumFRAM+0x556>
    3056:	f0 e0       	ldi	r31, 0x00	; 0
    3058:	e7 0f       	add	r30, r23
    305a:	a1 e0       	ldi	r26, 0x01	; 1
    305c:	e7 17       	cp	r30, r23
    305e:	08 f0       	brcs	.+2      	; 0x3062 <calcChecksumFRAM+0x560>
    3060:	a0 e0       	ldi	r26, 0x00	; 0
    3062:	fa 2b       	or	r31, r26
    3064:	7e 2f       	mov	r23, r30
    3066:	80 2f       	mov	r24, r16
    3068:	88 0d       	add	r24, r8
    306a:	e1 e0       	ldi	r30, 0x01	; 1
    306c:	80 17       	cp	r24, r16
    306e:	08 f0       	brcs	.+2      	; 0x3072 <calcChecksumFRAM+0x570>
    3070:	e0 e0       	ldi	r30, 0x00	; 0
    3072:	f8 0f       	add	r31, r24
    3074:	a1 e0       	ldi	r26, 0x01	; 1
    3076:	f8 17       	cp	r31, r24
    3078:	08 f0       	brcs	.+2      	; 0x307c <calcChecksumFRAM+0x57a>
    307a:	a0 e0       	ldi	r26, 0x00	; 0
    307c:	ea 2b       	or	r30, r26
    307e:	8f 2f       	mov	r24, r31
    3080:	91 2f       	mov	r25, r17
    3082:	99 0d       	add	r25, r9
    3084:	e9 0f       	add	r30, r25
    3086:	9e 2f       	mov	r25, r30
    3088:	a2 2e       	mov	r10, r18
    308a:	b3 2e       	mov	r11, r19
    308c:	c4 2e       	mov	r12, r20
    308e:	d5 2e       	mov	r13, r21
    3090:	e6 2e       	mov	r14, r22
    3092:	f7 2e       	mov	r15, r23
    3094:	08 2f       	mov	r16, r24
    3096:	19 2f       	mov	r17, r25
    3098:	a0 92 90 50 	sts	0x5090, r10
    309c:	b0 92 91 50 	sts	0x5091, r11
    30a0:	c0 92 92 50 	sts	0x5092, r12
    30a4:	d0 92 93 50 	sts	0x5093, r13
    30a8:	e0 92 94 50 	sts	0x5094, r14
    30ac:	f0 92 95 50 	sts	0x5095, r15
    30b0:	00 93 96 50 	sts	0x5096, r16
    30b4:	10 93 97 50 	sts	0x5097, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    30b8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ba:	9c 81       	ldd	r25, Y+4	; 0x04
    30bc:	01 96       	adiw	r24, 0x01	; 1
    30be:	8b 83       	std	Y+3, r24	; 0x03
    30c0:	9c 83       	std	Y+4, r25	; 0x04
    30c2:	8b 81       	ldd	r24, Y+3	; 0x03
    30c4:	9c 81       	ldd	r25, Y+4	; 0x04
    30c6:	fc e1       	ldi	r31, 0x1C	; 28
    30c8:	81 37       	cpi	r24, 0x71	; 113
    30ca:	9f 07       	cpc	r25, r31
    30cc:	08 f4       	brcc	.+2      	; 0x30d0 <calcChecksumFRAM+0x5ce>
    30ce:	8e cd       	rjmp	.-1252   	; 0x2bec <calcChecksumFRAM+0xea>
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    30d0:	89 81       	ldd	r24, Y+1	; 0x01
    30d2:	9a 81       	ldd	r25, Y+2	; 0x02
    30d4:	01 96       	adiw	r24, 0x01	; 1
    30d6:	89 83       	std	Y+1, r24	; 0x01
    30d8:	9a 83       	std	Y+2, r25	; 0x02
    30da:	89 81       	ldd	r24, Y+1	; 0x01
    30dc:	9a 81       	ldd	r25, Y+2	; 0x02
    30de:	89 30       	cpi	r24, 0x09	; 9
    30e0:	91 05       	cpc	r25, r1
    30e2:	08 f4       	brcc	.+2      	; 0x30e6 <calcChecksumFRAM+0x5e4>
    30e4:	72 cd       	rjmp	.-1308   	; 0x2bca <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    30e6:	24 96       	adiw	r28, 0x04	; 4
    30e8:	cd bf       	out	0x3d, r28	; 61
    30ea:	de bf       	out	0x3e, r29	; 62
    30ec:	df 91       	pop	r29
    30ee:	cf 91       	pop	r28
    30f0:	1f 91       	pop	r17
    30f2:	0f 91       	pop	r16
    30f4:	ff 90       	pop	r15
    30f6:	ef 90       	pop	r14
    30f8:	df 90       	pop	r13
    30fa:	cf 90       	pop	r12
    30fc:	bf 90       	pop	r11
    30fe:	af 90       	pop	r10
    3100:	9f 90       	pop	r9
    3102:	8f 90       	pop	r8
    3104:	7f 90       	pop	r7
    3106:	6f 90       	pop	r6
    3108:	5f 90       	pop	r5
    310a:	4f 90       	pop	r4
    310c:	3f 90       	pop	r3
    310e:	2f 90       	pop	r2
    3110:	08 95       	ret

00003112 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    3112:	cf 93       	push	r28
    3114:	df 93       	push	r29
    3116:	cd b7       	in	r28, 0x3d	; 61
    3118:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    311a:	10 92 44 40 	sts	0x4044, r1
    311e:	10 92 45 40 	sts	0x4045, r1
	sampleCount = 0;
    3122:	10 92 69 50 	sts	0x5069, r1
    3126:	10 92 6a 50 	sts	0x506A, r1
    312a:	10 92 6b 50 	sts	0x506B, r1
    312e:	10 92 6c 50 	sts	0x506C, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3132:	80 e0       	ldi	r24, 0x00	; 0
    3134:	80 93 28 21 	sts	0x2128, r24
    3138:	80 93 27 21 	sts	0x2127, r24
    313c:	80 93 26 21 	sts	0x2126, r24
	
	ADCPower(TRUE);
    3140:	81 e0       	ldi	r24, 0x01	; 1
    3142:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    3146:	84 e0       	ldi	r24, 0x04	; 4
    3148:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    314c:	80 ec       	ldi	r24, 0xC0	; 192
    314e:	98 e0       	ldi	r25, 0x08	; 8
    3150:	20 ed       	ldi	r18, 0xD0	; 208
    3152:	fc 01       	movw	r30, r24
    3154:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    3156:	8d e0       	ldi	r24, 0x0D	; 13
    3158:	80 93 5a 50 	sts	0x505A, r24
	SPIBuffer[1] = 0xF3;
    315c:	83 ef       	ldi	r24, 0xF3	; 243
    315e:	80 93 5b 50 	sts	0x505B, r24
	SPIBuffer[2] = 0x57;
    3162:	87 e5       	ldi	r24, 0x57	; 87
    3164:	80 93 5c 50 	sts	0x505C, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3168:	d7 c0       	rjmp	.+430    	; 0x3318 <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    316a:	80 e4       	ldi	r24, 0x40	; 64
    316c:	96 e0       	ldi	r25, 0x06	; 6
    316e:	20 e1       	ldi	r18, 0x10	; 16
    3170:	fc 01       	movw	r30, r24
    3172:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3174:	80 e2       	ldi	r24, 0x20	; 32
    3176:	96 e0       	ldi	r25, 0x06	; 6
    3178:	28 e0       	ldi	r18, 0x08	; 8
    317a:	fc 01       	movw	r30, r24
    317c:	26 83       	std	Z+6, r18	; 0x06
		nop();
    317e:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3180:	80 ec       	ldi	r24, 0xC0	; 192
    3182:	98 e0       	ldi	r25, 0x08	; 8
    3184:	26 e0       	ldi	r18, 0x06	; 6
    3186:	fc 01       	movw	r30, r24
    3188:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    318a:	00 00       	nop
    318c:	80 ec       	ldi	r24, 0xC0	; 192
    318e:	98 e0       	ldi	r25, 0x08	; 8
    3190:	fc 01       	movw	r30, r24
    3192:	82 81       	ldd	r24, Z+2	; 0x02
    3194:	88 23       	and	r24, r24
    3196:	d4 f7       	brge	.-12     	; 0x318c <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3198:	80 ec       	ldi	r24, 0xC0	; 192
    319a:	98 e0       	ldi	r25, 0x08	; 8
    319c:	fc 01       	movw	r30, r24
    319e:	83 81       	ldd	r24, Z+3	; 0x03
    31a0:	80 93 66 50 	sts	0x5066, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    31a4:	80 e2       	ldi	r24, 0x20	; 32
    31a6:	96 e0       	ldi	r25, 0x06	; 6
    31a8:	28 e0       	ldi	r18, 0x08	; 8
    31aa:	fc 01       	movw	r30, r24
    31ac:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    31ae:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    31b0:	80 e2       	ldi	r24, 0x20	; 32
    31b2:	96 e0       	ldi	r25, 0x06	; 6
    31b4:	28 e0       	ldi	r18, 0x08	; 8
    31b6:	fc 01       	movw	r30, r24
    31b8:	26 83       	std	Z+6, r18	; 0x06
		nop();
    31ba:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    31bc:	80 ec       	ldi	r24, 0xC0	; 192
    31be:	98 e0       	ldi	r25, 0x08	; 8
    31c0:	22 e0       	ldi	r18, 0x02	; 2
    31c2:	fc 01       	movw	r30, r24
    31c4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    31c6:	00 00       	nop
    31c8:	80 ec       	ldi	r24, 0xC0	; 192
    31ca:	98 e0       	ldi	r25, 0x08	; 8
    31cc:	fc 01       	movw	r30, r24
    31ce:	82 81       	ldd	r24, Z+2	; 0x02
    31d0:	88 23       	and	r24, r24
    31d2:	d4 f7       	brge	.-12     	; 0x31c8 <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    31d4:	80 ec       	ldi	r24, 0xC0	; 192
    31d6:	98 e0       	ldi	r25, 0x08	; 8
    31d8:	fc 01       	movw	r30, r24
    31da:	83 81       	ldd	r24, Z+3	; 0x03
    31dc:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    31e0:	80 ec       	ldi	r24, 0xC0	; 192
    31e2:	98 e0       	ldi	r25, 0x08	; 8
    31e4:	20 91 45 40 	lds	r18, 0x4045
    31e8:	fc 01       	movw	r30, r24
    31ea:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    31ec:	00 00       	nop
    31ee:	80 ec       	ldi	r24, 0xC0	; 192
    31f0:	98 e0       	ldi	r25, 0x08	; 8
    31f2:	fc 01       	movw	r30, r24
    31f4:	82 81       	ldd	r24, Z+2	; 0x02
    31f6:	88 23       	and	r24, r24
    31f8:	d4 f7       	brge	.-12     	; 0x31ee <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    31fa:	80 ec       	ldi	r24, 0xC0	; 192
    31fc:	98 e0       	ldi	r25, 0x08	; 8
    31fe:	fc 01       	movw	r30, r24
    3200:	83 81       	ldd	r24, Z+3	; 0x03
    3202:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    3206:	80 ec       	ldi	r24, 0xC0	; 192
    3208:	98 e0       	ldi	r25, 0x08	; 8
    320a:	24 e4       	ldi	r18, 0x44	; 68
    320c:	30 e4       	ldi	r19, 0x40	; 64
    320e:	f9 01       	movw	r30, r18
    3210:	20 81       	ld	r18, Z
    3212:	fc 01       	movw	r30, r24
    3214:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3216:	00 00       	nop
    3218:	80 ec       	ldi	r24, 0xC0	; 192
    321a:	98 e0       	ldi	r25, 0x08	; 8
    321c:	fc 01       	movw	r30, r24
    321e:	82 81       	ldd	r24, Z+2	; 0x02
    3220:	88 23       	and	r24, r24
    3222:	d4 f7       	brge	.-12     	; 0x3218 <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3224:	80 ec       	ldi	r24, 0xC0	; 192
    3226:	98 e0       	ldi	r25, 0x08	; 8
    3228:	fc 01       	movw	r30, r24
    322a:	83 81       	ldd	r24, Z+3	; 0x03
    322c:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[0];
    3230:	80 ec       	ldi	r24, 0xC0	; 192
    3232:	98 e0       	ldi	r25, 0x08	; 8
    3234:	20 91 5a 50 	lds	r18, 0x505A
    3238:	fc 01       	movw	r30, r24
    323a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    323c:	00 00       	nop
    323e:	80 ec       	ldi	r24, 0xC0	; 192
    3240:	98 e0       	ldi	r25, 0x08	; 8
    3242:	fc 01       	movw	r30, r24
    3244:	82 81       	ldd	r24, Z+2	; 0x02
    3246:	88 23       	and	r24, r24
    3248:	d4 f7       	brge	.-12     	; 0x323e <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    324a:	80 ec       	ldi	r24, 0xC0	; 192
    324c:	98 e0       	ldi	r25, 0x08	; 8
    324e:	fc 01       	movw	r30, r24
    3250:	83 81       	ldd	r24, Z+3	; 0x03
    3252:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[1];
    3256:	80 ec       	ldi	r24, 0xC0	; 192
    3258:	98 e0       	ldi	r25, 0x08	; 8
    325a:	20 91 5b 50 	lds	r18, 0x505B
    325e:	fc 01       	movw	r30, r24
    3260:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3262:	00 00       	nop
    3264:	80 ec       	ldi	r24, 0xC0	; 192
    3266:	98 e0       	ldi	r25, 0x08	; 8
    3268:	fc 01       	movw	r30, r24
    326a:	82 81       	ldd	r24, Z+2	; 0x02
    326c:	88 23       	and	r24, r24
    326e:	d4 f7       	brge	.-12     	; 0x3264 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    3270:	80 ec       	ldi	r24, 0xC0	; 192
    3272:	98 e0       	ldi	r25, 0x08	; 8
    3274:	fc 01       	movw	r30, r24
    3276:	83 81       	ldd	r24, Z+3	; 0x03
    3278:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[2];
    327c:	80 ec       	ldi	r24, 0xC0	; 192
    327e:	98 e0       	ldi	r25, 0x08	; 8
    3280:	20 91 5c 50 	lds	r18, 0x505C
    3284:	fc 01       	movw	r30, r24
    3286:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3288:	00 00       	nop
    328a:	80 ec       	ldi	r24, 0xC0	; 192
    328c:	98 e0       	ldi	r25, 0x08	; 8
    328e:	fc 01       	movw	r30, r24
    3290:	82 81       	ldd	r24, Z+2	; 0x02
    3292:	88 23       	and	r24, r24
    3294:	d4 f7       	brge	.-12     	; 0x328a <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    3296:	80 ec       	ldi	r24, 0xC0	; 192
    3298:	98 e0       	ldi	r25, 0x08	; 8
    329a:	fc 01       	movw	r30, r24
    329c:	83 81       	ldd	r24, Z+3	; 0x03
    329e:	80 93 66 50 	sts	0x5066, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    32a2:	80 e2       	ldi	r24, 0x20	; 32
    32a4:	96 e0       	ldi	r25, 0x06	; 6
    32a6:	28 e0       	ldi	r18, 0x08	; 8
    32a8:	fc 01       	movw	r30, r24
    32aa:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    32ac:	80 e4       	ldi	r24, 0x40	; 64
    32ae:	96 e0       	ldi	r25, 0x06	; 6
    32b0:	20 e1       	ldi	r18, 0x10	; 16
    32b2:	fc 01       	movw	r30, r24
    32b4:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    32b6:	80 91 44 40 	lds	r24, 0x4044
    32ba:	90 91 45 40 	lds	r25, 0x4045
    32be:	03 96       	adiw	r24, 0x03	; 3
    32c0:	80 93 44 40 	sts	0x4044, r24
    32c4:	90 93 45 40 	sts	0x4045, r25
		checksumADC[0] += SPIBuffer[0];
    32c8:	90 91 26 21 	lds	r25, 0x2126
    32cc:	80 91 5a 50 	lds	r24, 0x505A
    32d0:	89 0f       	add	r24, r25
    32d2:	80 93 26 21 	sts	0x2126, r24
		checksumADC[1] += SPIBuffer[1];
    32d6:	90 91 27 21 	lds	r25, 0x2127
    32da:	80 91 5b 50 	lds	r24, 0x505B
    32de:	89 0f       	add	r24, r25
    32e0:	80 93 27 21 	sts	0x2127, r24
		checksumADC[2] += SPIBuffer[2];
    32e4:	90 91 28 21 	lds	r25, 0x2128
    32e8:	80 91 5c 50 	lds	r24, 0x505C
    32ec:	89 0f       	add	r24, r25
    32ee:	80 93 28 21 	sts	0x2128, r24
		
		sampleCount++;
    32f2:	80 91 69 50 	lds	r24, 0x5069
    32f6:	90 91 6a 50 	lds	r25, 0x506A
    32fa:	a0 91 6b 50 	lds	r26, 0x506B
    32fe:	b0 91 6c 50 	lds	r27, 0x506C
    3302:	01 96       	adiw	r24, 0x01	; 1
    3304:	a1 1d       	adc	r26, r1
    3306:	b1 1d       	adc	r27, r1
    3308:	80 93 69 50 	sts	0x5069, r24
    330c:	90 93 6a 50 	sts	0x506A, r25
    3310:	a0 93 6b 50 	sts	0x506B, r26
    3314:	b0 93 6c 50 	sts	0x506C, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3318:	80 91 69 50 	lds	r24, 0x5069
    331c:	90 91 6a 50 	lds	r25, 0x506A
    3320:	a0 91 6b 50 	lds	r26, 0x506B
    3324:	b0 91 6c 50 	lds	r27, 0x506C
    3328:	83 35       	cpi	r24, 0x53	; 83
    332a:	f5 e5       	ldi	r31, 0x55	; 85
    332c:	9f 07       	cpc	r25, r31
    332e:	f0 e0       	ldi	r31, 0x00	; 0
    3330:	af 07       	cpc	r26, r31
    3332:	f0 e0       	ldi	r31, 0x00	; 0
    3334:	bf 07       	cpc	r27, r31
    3336:	08 f4       	brcc	.+2      	; 0x333a <FRAMWriteKnowns+0x228>
    3338:	18 cf       	rjmp	.-464    	; 0x316a <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    333a:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	ADCPower(FALSE);
    333e:	80 e0       	ldi	r24, 0x00	; 0
    3340:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
}
    3344:	df 91       	pop	r29
    3346:	cf 91       	pop	r28
    3348:	08 95       	ret

0000334a <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    334a:	cf 93       	push	r28
    334c:	df 93       	push	r29
    334e:	0f 92       	push	r0
    3350:	cd b7       	in	r28, 0x3d	; 61
    3352:	de b7       	in	r29, 0x3e	; 62
    3354:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    3356:	89 81       	ldd	r24, Y+1	; 0x01
    3358:	88 2f       	mov	r24, r24
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	81 70       	andi	r24, 0x01	; 1
    335e:	90 70       	andi	r25, 0x00	; 0
    3360:	88 23       	and	r24, r24
    3362:	31 f0       	breq	.+12     	; 0x3370 <setADCInput+0x26>
    3364:	80 e0       	ldi	r24, 0x00	; 0
    3366:	96 e0       	ldi	r25, 0x06	; 6
    3368:	20 e4       	ldi	r18, 0x40	; 64
    336a:	fc 01       	movw	r30, r24
    336c:	25 83       	std	Z+5, r18	; 0x05
    336e:	05 c0       	rjmp	.+10     	; 0x337a <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    3370:	80 e0       	ldi	r24, 0x00	; 0
    3372:	96 e0       	ldi	r25, 0x06	; 6
    3374:	20 e4       	ldi	r18, 0x40	; 64
    3376:	fc 01       	movw	r30, r24
    3378:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    337a:	89 81       	ldd	r24, Y+1	; 0x01
    337c:	88 2f       	mov	r24, r24
    337e:	90 e0       	ldi	r25, 0x00	; 0
    3380:	82 70       	andi	r24, 0x02	; 2
    3382:	90 70       	andi	r25, 0x00	; 0
    3384:	00 97       	sbiw	r24, 0x00	; 0
    3386:	31 f0       	breq	.+12     	; 0x3394 <setADCInput+0x4a>
    3388:	80 e2       	ldi	r24, 0x20	; 32
    338a:	96 e0       	ldi	r25, 0x06	; 6
    338c:	22 e0       	ldi	r18, 0x02	; 2
    338e:	fc 01       	movw	r30, r24
    3390:	25 83       	std	Z+5, r18	; 0x05
    3392:	05 c0       	rjmp	.+10     	; 0x339e <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3394:	80 e2       	ldi	r24, 0x20	; 32
    3396:	96 e0       	ldi	r25, 0x06	; 6
    3398:	22 e0       	ldi	r18, 0x02	; 2
    339a:	fc 01       	movw	r30, r24
    339c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    339e:	89 81       	ldd	r24, Y+1	; 0x01
    33a0:	88 2f       	mov	r24, r24
    33a2:	90 e0       	ldi	r25, 0x00	; 0
    33a4:	84 70       	andi	r24, 0x04	; 4
    33a6:	90 70       	andi	r25, 0x00	; 0
    33a8:	00 97       	sbiw	r24, 0x00	; 0
    33aa:	31 f0       	breq	.+12     	; 0x33b8 <setADCInput+0x6e>
    33ac:	80 e2       	ldi	r24, 0x20	; 32
    33ae:	96 e0       	ldi	r25, 0x06	; 6
    33b0:	24 e0       	ldi	r18, 0x04	; 4
    33b2:	fc 01       	movw	r30, r24
    33b4:	25 83       	std	Z+5, r18	; 0x05
    33b6:	05 c0       	rjmp	.+10     	; 0x33c2 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    33b8:	80 e2       	ldi	r24, 0x20	; 32
    33ba:	96 e0       	ldi	r25, 0x06	; 6
    33bc:	24 e0       	ldi	r18, 0x04	; 4
    33be:	fc 01       	movw	r30, r24
    33c0:	26 83       	std	Z+6, r18	; 0x06

}
    33c2:	0f 90       	pop	r0
    33c4:	df 91       	pop	r29
    33c6:	cf 91       	pop	r28
    33c8:	08 95       	ret

000033ca <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    33ca:	cf 93       	push	r28
    33cc:	df 93       	push	r29
    33ce:	0f 92       	push	r0
    33d0:	0f 92       	push	r0
    33d2:	cd b7       	in	r28, 0x3d	; 61
    33d4:	de b7       	in	r29, 0x3e	; 62
    33d6:	89 83       	std	Y+1, r24	; 0x01
    33d8:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    33da:	89 81       	ldd	r24, Y+1	; 0x01
    33dc:	9a 81       	ldd	r25, Y+2	; 0x02
    33de:	22 e0       	ldi	r18, 0x02	; 2
    33e0:	80 30       	cpi	r24, 0x00	; 0
    33e2:	92 07       	cpc	r25, r18
    33e4:	89 f4       	brne	.+34     	; 0x3408 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    33e6:	80 e2       	ldi	r24, 0x20	; 32
    33e8:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <SP_ReadCalibrationByte>
    33ec:	28 2f       	mov	r18, r24
    33ee:	89 81       	ldd	r24, Y+1	; 0x01
    33f0:	9a 81       	ldd	r25, Y+2	; 0x02
    33f2:	fc 01       	movw	r30, r24
    33f4:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    33f6:	81 e2       	ldi	r24, 0x21	; 33
    33f8:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <SP_ReadCalibrationByte>
    33fc:	28 2f       	mov	r18, r24
    33fe:	89 81       	ldd	r24, Y+1	; 0x01
    3400:	9a 81       	ldd	r25, Y+2	; 0x02
    3402:	fc 01       	movw	r30, r24
    3404:	25 87       	std	Z+13, r18	; 0x0d
    3406:	10 c0       	rjmp	.+32     	; 0x3428 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3408:	84 e2       	ldi	r24, 0x24	; 36
    340a:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <SP_ReadCalibrationByte>
    340e:	28 2f       	mov	r18, r24
    3410:	89 81       	ldd	r24, Y+1	; 0x01
    3412:	9a 81       	ldd	r25, Y+2	; 0x02
    3414:	fc 01       	movw	r30, r24
    3416:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3418:	85 e2       	ldi	r24, 0x25	; 37
    341a:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <SP_ReadCalibrationByte>
    341e:	28 2f       	mov	r18, r24
    3420:	89 81       	ldd	r24, Y+1	; 0x01
    3422:	9a 81       	ldd	r25, Y+2	; 0x02
    3424:	fc 01       	movw	r30, r24
    3426:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3428:	0f 90       	pop	r0
    342a:	0f 90       	pop	r0
    342c:	df 91       	pop	r29
    342e:	cf 91       	pop	r28
    3430:	08 95       	ret

00003432 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3432:	cf 93       	push	r28
    3434:	df 93       	push	r29
    3436:	cd b7       	in	r28, 0x3d	; 61
    3438:	de b7       	in	r29, 0x3e	; 62
    343a:	25 97       	sbiw	r28, 0x05	; 5
    343c:	cd bf       	out	0x3d, r28	; 61
    343e:	de bf       	out	0x3e, r29	; 62
    3440:	8b 83       	std	Y+3, r24	; 0x03
    3442:	9c 83       	std	Y+4, r25	; 0x04
    3444:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3446:	8b 81       	ldd	r24, Y+3	; 0x03
    3448:	9c 81       	ldd	r25, Y+4	; 0x04
    344a:	21 e0       	ldi	r18, 0x01	; 1
    344c:	fc 01       	movw	r30, r24
    344e:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    3450:	8b 81       	ldd	r24, Y+3	; 0x03
    3452:	9c 81       	ldd	r25, Y+4	; 0x04
    3454:	fc 01       	movw	r30, r24
    3456:	24 81       	ldd	r18, Z+4	; 0x04
    3458:	35 81       	ldd	r19, Z+5	; 0x05
    345a:	8d 81       	ldd	r24, Y+5	; 0x05
    345c:	88 2f       	mov	r24, r24
    345e:	90 e0       	ldi	r25, 0x00	; 0
    3460:	a9 01       	movw	r20, r18
    3462:	48 1b       	sub	r20, r24
    3464:	59 0b       	sbc	r21, r25
    3466:	ca 01       	movw	r24, r20
    3468:	89 83       	std	Y+1, r24	; 0x01
    346a:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    346c:	89 81       	ldd	r24, Y+1	; 0x01
    346e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3470:	25 96       	adiw	r28, 0x05	; 5
    3472:	cd bf       	out	0x3d, r28	; 61
    3474:	de bf       	out	0x3e, r29	; 62
    3476:	df 91       	pop	r29
    3478:	cf 91       	pop	r28
    347a:	08 95       	ret

0000347c <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    347c:	cf 93       	push	r28
    347e:	df 93       	push	r29
    3480:	cd b7       	in	r28, 0x3d	; 61
    3482:	de b7       	in	r29, 0x3e	; 62
    3484:	25 97       	sbiw	r28, 0x05	; 5
    3486:	cd bf       	out	0x3d, r28	; 61
    3488:	de bf       	out	0x3e, r29	; 62
    348a:	8b 83       	std	Y+3, r24	; 0x03
    348c:	9c 83       	std	Y+4, r25	; 0x04
    348e:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3490:	8b 81       	ldd	r24, Y+3	; 0x03
    3492:	9c 81       	ldd	r25, Y+4	; 0x04
    3494:	21 e0       	ldi	r18, 0x01	; 1
    3496:	fc 01       	movw	r30, r24
    3498:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
    349c:	9c 81       	ldd	r25, Y+4	; 0x04
    349e:	fc 01       	movw	r30, r24
    34a0:	24 81       	ldd	r18, Z+4	; 0x04
    34a2:	35 81       	ldd	r19, Z+5	; 0x05
    34a4:	8d 81       	ldd	r24, Y+5	; 0x05
    34a6:	99 27       	eor	r25, r25
    34a8:	87 fd       	sbrc	r24, 7
    34aa:	90 95       	com	r25
    34ac:	a9 01       	movw	r20, r18
    34ae:	48 1b       	sub	r20, r24
    34b0:	59 0b       	sbc	r21, r25
    34b2:	ca 01       	movw	r24, r20
    34b4:	89 83       	std	Y+1, r24	; 0x01
    34b6:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    34b8:	89 81       	ldd	r24, Y+1	; 0x01
    34ba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    34bc:	25 96       	adiw	r28, 0x05	; 5
    34be:	cd bf       	out	0x3d, r28	; 61
    34c0:	de bf       	out	0x3e, r29	; 62
    34c2:	df 91       	pop	r29
    34c4:	cf 91       	pop	r28
    34c6:	08 95       	ret

000034c8 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    34c8:	cf 93       	push	r28
    34ca:	df 93       	push	r29
    34cc:	0f 92       	push	r0
    34ce:	0f 92       	push	r0
    34d0:	cd b7       	in	r28, 0x3d	; 61
    34d2:	de b7       	in	r29, 0x3e	; 62
    34d4:	89 83       	std	Y+1, r24	; 0x01
    34d6:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    34d8:	89 81       	ldd	r24, Y+1	; 0x01
    34da:	9a 81       	ldd	r25, Y+2	; 0x02
    34dc:	21 e0       	ldi	r18, 0x01	; 1
    34de:	fc 01       	movw	r30, r24
    34e0:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    34e2:	89 81       	ldd	r24, Y+1	; 0x01
    34e4:	9a 81       	ldd	r25, Y+2	; 0x02
    34e6:	fc 01       	movw	r30, r24
    34e8:	84 81       	ldd	r24, Z+4	; 0x04
    34ea:	95 81       	ldd	r25, Z+5	; 0x05
}
    34ec:	0f 90       	pop	r0
    34ee:	0f 90       	pop	r0
    34f0:	df 91       	pop	r29
    34f2:	cf 91       	pop	r28
    34f4:	08 95       	ret

000034f6 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    34f6:	cf 93       	push	r28
    34f8:	df 93       	push	r29
    34fa:	0f 92       	push	r0
    34fc:	0f 92       	push	r0
    34fe:	cd b7       	in	r28, 0x3d	; 61
    3500:	de b7       	in	r29, 0x3e	; 62
    3502:	89 83       	std	Y+1, r24	; 0x01
    3504:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3506:	89 81       	ldd	r24, Y+1	; 0x01
    3508:	9a 81       	ldd	r25, Y+2	; 0x02
    350a:	21 e0       	ldi	r18, 0x01	; 1
    350c:	fc 01       	movw	r30, r24
    350e:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3510:	89 81       	ldd	r24, Y+1	; 0x01
    3512:	9a 81       	ldd	r25, Y+2	; 0x02
    3514:	fc 01       	movw	r30, r24
    3516:	84 81       	ldd	r24, Z+4	; 0x04
}
    3518:	0f 90       	pop	r0
    351a:	0f 90       	pop	r0
    351c:	df 91       	pop	r29
    351e:	cf 91       	pop	r28
    3520:	08 95       	ret

00003522 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3522:	cf 93       	push	r28
    3524:	df 93       	push	r29
    3526:	0f 92       	push	r0
    3528:	0f 92       	push	r0
    352a:	cd b7       	in	r28, 0x3d	; 61
    352c:	de b7       	in	r29, 0x3e	; 62
    352e:	89 83       	std	Y+1, r24	; 0x01
    3530:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3532:	89 81       	ldd	r24, Y+1	; 0x01
    3534:	9a 81       	ldd	r25, Y+2	; 0x02
    3536:	21 e0       	ldi	r18, 0x01	; 1
    3538:	fc 01       	movw	r30, r24
    353a:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    353c:	89 81       	ldd	r24, Y+1	; 0x01
    353e:	9a 81       	ldd	r25, Y+2	; 0x02
    3540:	fc 01       	movw	r30, r24
    3542:	85 81       	ldd	r24, Z+5	; 0x05
}
    3544:	0f 90       	pop	r0
    3546:	0f 90       	pop	r0
    3548:	df 91       	pop	r29
    354a:	cf 91       	pop	r28
    354c:	08 95       	ret

0000354e <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    354e:	0f 93       	push	r16
    3550:	1f 93       	push	r17
    3552:	cf 93       	push	r28
    3554:	df 93       	push	r29
    3556:	cd b7       	in	r28, 0x3d	; 61
    3558:	de b7       	in	r29, 0x3e	; 62
    355a:	6b 97       	sbiw	r28, 0x1b	; 27
    355c:	cd bf       	out	0x3d, r28	; 61
    355e:	de bf       	out	0x3e, r29	; 62
    3560:	8a 8f       	std	Y+26, r24	; 0x1a
    3562:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3564:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3566:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3568:	fc 01       	movw	r30, r24
    356a:	84 81       	ldd	r24, Z+4	; 0x04
    356c:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    356e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3570:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3572:	fc 01       	movw	r30, r24
    3574:	14 82       	std	Z+4, r1	; 0x04
    3576:	80 e0       	ldi	r24, 0x00	; 0
    3578:	90 e0       	ldi	r25, 0x00	; 0
    357a:	a0 e8       	ldi	r26, 0x80	; 128
    357c:	b2 e4       	ldi	r27, 0x42	; 66
    357e:	8a 83       	std	Y+2, r24	; 0x02
    3580:	9b 83       	std	Y+3, r25	; 0x03
    3582:	ac 83       	std	Y+4, r26	; 0x04
    3584:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3586:	6a 81       	ldd	r22, Y+2	; 0x02
    3588:	7b 81       	ldd	r23, Y+3	; 0x03
    358a:	8c 81       	ldd	r24, Y+4	; 0x04
    358c:	9d 81       	ldd	r25, Y+5	; 0x05
    358e:	2b ea       	ldi	r18, 0xAB	; 171
    3590:	3a ea       	ldi	r19, 0xAA	; 170
    3592:	4a e2       	ldi	r20, 0x2A	; 42
    3594:	5f e3       	ldi	r21, 0x3F	; 63
    3596:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    359a:	dc 01       	movw	r26, r24
    359c:	cb 01       	movw	r24, r22
    359e:	8e 83       	std	Y+6, r24	; 0x06
    35a0:	9f 83       	std	Y+7, r25	; 0x07
    35a2:	a8 87       	std	Y+8, r26	; 0x08
    35a4:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    35a6:	11 e0       	ldi	r17, 0x01	; 1
    35a8:	6e 81       	ldd	r22, Y+6	; 0x06
    35aa:	7f 81       	ldd	r23, Y+7	; 0x07
    35ac:	88 85       	ldd	r24, Y+8	; 0x08
    35ae:	99 85       	ldd	r25, Y+9	; 0x09
    35b0:	20 e0       	ldi	r18, 0x00	; 0
    35b2:	30 e0       	ldi	r19, 0x00	; 0
    35b4:	40 e8       	ldi	r20, 0x80	; 128
    35b6:	5f e3       	ldi	r21, 0x3F	; 63
    35b8:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    35bc:	88 23       	and	r24, r24
    35be:	0c f0       	brlt	.+2      	; 0x35c2 <ADC_Wait_8MHz+0x74>
    35c0:	10 e0       	ldi	r17, 0x00	; 0
    35c2:	11 23       	and	r17, r17
    35c4:	19 f0       	breq	.+6      	; 0x35cc <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    35c6:	81 e0       	ldi	r24, 0x01	; 1
    35c8:	8a 87       	std	Y+10, r24	; 0x0a
    35ca:	a3 c0       	rjmp	.+326    	; 0x3712 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    35cc:	11 e0       	ldi	r17, 0x01	; 1
    35ce:	6e 81       	ldd	r22, Y+6	; 0x06
    35d0:	7f 81       	ldd	r23, Y+7	; 0x07
    35d2:	88 85       	ldd	r24, Y+8	; 0x08
    35d4:	99 85       	ldd	r25, Y+9	; 0x09
    35d6:	20 e0       	ldi	r18, 0x00	; 0
    35d8:	30 e0       	ldi	r19, 0x00	; 0
    35da:	4f e7       	ldi	r20, 0x7F	; 127
    35dc:	53 e4       	ldi	r21, 0x43	; 67
    35de:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    35e2:	18 16       	cp	r1, r24
    35e4:	0c f0       	brlt	.+2      	; 0x35e8 <ADC_Wait_8MHz+0x9a>
    35e6:	10 e0       	ldi	r17, 0x00	; 0
    35e8:	11 23       	and	r17, r17
    35ea:	09 f4       	brne	.+2      	; 0x35ee <ADC_Wait_8MHz+0xa0>
    35ec:	89 c0       	rjmp	.+274    	; 0x3700 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    35ee:	6a 81       	ldd	r22, Y+2	; 0x02
    35f0:	7b 81       	ldd	r23, Y+3	; 0x03
    35f2:	8c 81       	ldd	r24, Y+4	; 0x04
    35f4:	9d 81       	ldd	r25, Y+5	; 0x05
    35f6:	20 e0       	ldi	r18, 0x00	; 0
    35f8:	30 e0       	ldi	r19, 0x00	; 0
    35fa:	4a e7       	ldi	r20, 0x7A	; 122
    35fc:	54 e4       	ldi	r21, 0x44	; 68
    35fe:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    3602:	dc 01       	movw	r26, r24
    3604:	cb 01       	movw	r24, r22
    3606:	8b 87       	std	Y+11, r24	; 0x0b
    3608:	9c 87       	std	Y+12, r25	; 0x0c
    360a:	ad 87       	std	Y+13, r26	; 0x0d
    360c:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    360e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3610:	7c 85       	ldd	r23, Y+12	; 0x0c
    3612:	8d 85       	ldd	r24, Y+13	; 0x0d
    3614:	9e 85       	ldd	r25, Y+14	; 0x0e
    3616:	20 e0       	ldi	r18, 0x00	; 0
    3618:	30 e0       	ldi	r19, 0x00	; 0
    361a:	4a ef       	ldi	r20, 0xFA	; 250
    361c:	53 e4       	ldi	r21, 0x43	; 67
    361e:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    3622:	dc 01       	movw	r26, r24
    3624:	cb 01       	movw	r24, r22
    3626:	8f 87       	std	Y+15, r24	; 0x0f
    3628:	98 8b       	std	Y+16, r25	; 0x10
    362a:	a9 8b       	std	Y+17, r26	; 0x11
    362c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    362e:	11 e0       	ldi	r17, 0x01	; 1
    3630:	6f 85       	ldd	r22, Y+15	; 0x0f
    3632:	78 89       	ldd	r23, Y+16	; 0x10
    3634:	89 89       	ldd	r24, Y+17	; 0x11
    3636:	9a 89       	ldd	r25, Y+18	; 0x12
    3638:	20 e0       	ldi	r18, 0x00	; 0
    363a:	30 e0       	ldi	r19, 0x00	; 0
    363c:	40 e8       	ldi	r20, 0x80	; 128
    363e:	5f e3       	ldi	r21, 0x3F	; 63
    3640:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    3644:	88 23       	and	r24, r24
    3646:	0c f0       	brlt	.+2      	; 0x364a <ADC_Wait_8MHz+0xfc>
    3648:	10 e0       	ldi	r17, 0x00	; 0
    364a:	11 23       	and	r17, r17
    364c:	29 f0       	breq	.+10     	; 0x3658 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	90 e0       	ldi	r25, 0x00	; 0
    3652:	8b 8b       	std	Y+19, r24	; 0x13
    3654:	9c 8b       	std	Y+20, r25	; 0x14
    3656:	46 c0       	rjmp	.+140    	; 0x36e4 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3658:	11 e0       	ldi	r17, 0x01	; 1
    365a:	6f 85       	ldd	r22, Y+15	; 0x0f
    365c:	78 89       	ldd	r23, Y+16	; 0x10
    365e:	89 89       	ldd	r24, Y+17	; 0x11
    3660:	9a 89       	ldd	r25, Y+18	; 0x12
    3662:	20 e0       	ldi	r18, 0x00	; 0
    3664:	3f ef       	ldi	r19, 0xFF	; 255
    3666:	4f e7       	ldi	r20, 0x7F	; 127
    3668:	57 e4       	ldi	r21, 0x47	; 71
    366a:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    366e:	18 16       	cp	r1, r24
    3670:	0c f0       	brlt	.+2      	; 0x3674 <ADC_Wait_8MHz+0x126>
    3672:	10 e0       	ldi	r17, 0x00	; 0
    3674:	11 23       	and	r17, r17
    3676:	61 f1       	breq	.+88     	; 0x36d0 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3678:	6b 85       	ldd	r22, Y+11	; 0x0b
    367a:	7c 85       	ldd	r23, Y+12	; 0x0c
    367c:	8d 85       	ldd	r24, Y+13	; 0x0d
    367e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3680:	20 e0       	ldi	r18, 0x00	; 0
    3682:	30 e0       	ldi	r19, 0x00	; 0
    3684:	40 e2       	ldi	r20, 0x20	; 32
    3686:	51 e4       	ldi	r21, 0x41	; 65
    3688:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    368c:	dc 01       	movw	r26, r24
    368e:	cb 01       	movw	r24, r22
    3690:	bc 01       	movw	r22, r24
    3692:	cd 01       	movw	r24, r26
    3694:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    3698:	dc 01       	movw	r26, r24
    369a:	cb 01       	movw	r24, r22
    369c:	8b 8b       	std	Y+19, r24	; 0x13
    369e:	9c 8b       	std	Y+20, r25	; 0x14
    36a0:	12 c0       	rjmp	.+36     	; 0x36c6 <ADC_Wait_8MHz+0x178>
    36a2:	82 e3       	ldi	r24, 0x32	; 50
    36a4:	90 e0       	ldi	r25, 0x00	; 0
    36a6:	8d 8b       	std	Y+21, r24	; 0x15
    36a8:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    36aa:	8d 89       	ldd	r24, Y+21	; 0x15
    36ac:	9e 89       	ldd	r25, Y+22	; 0x16
    36ae:	8c 01       	movw	r16, r24
    36b0:	c8 01       	movw	r24, r16
    36b2:	01 97       	sbiw	r24, 0x01	; 1
    36b4:	f1 f7       	brne	.-4      	; 0x36b2 <ADC_Wait_8MHz+0x164>
    36b6:	8c 01       	movw	r16, r24
    36b8:	0d 8b       	std	Y+21, r16	; 0x15
    36ba:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36bc:	8b 89       	ldd	r24, Y+19	; 0x13
    36be:	9c 89       	ldd	r25, Y+20	; 0x14
    36c0:	01 97       	sbiw	r24, 0x01	; 1
    36c2:	8b 8b       	std	Y+19, r24	; 0x13
    36c4:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    36c6:	8b 89       	ldd	r24, Y+19	; 0x13
    36c8:	9c 89       	ldd	r25, Y+20	; 0x14
    36ca:	00 97       	sbiw	r24, 0x00	; 0
    36cc:	51 f7       	brne	.-44     	; 0x36a2 <ADC_Wait_8MHz+0x154>
    36ce:	28 c0       	rjmp	.+80     	; 0x3720 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    36d0:	6f 85       	ldd	r22, Y+15	; 0x0f
    36d2:	78 89       	ldd	r23, Y+16	; 0x10
    36d4:	89 89       	ldd	r24, Y+17	; 0x11
    36d6:	9a 89       	ldd	r25, Y+18	; 0x12
    36d8:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    36dc:	dc 01       	movw	r26, r24
    36de:	cb 01       	movw	r24, r22
    36e0:	8b 8b       	std	Y+19, r24	; 0x13
    36e2:	9c 8b       	std	Y+20, r25	; 0x14
    36e4:	8b 89       	ldd	r24, Y+19	; 0x13
    36e6:	9c 89       	ldd	r25, Y+20	; 0x14
    36e8:	8f 8b       	std	Y+23, r24	; 0x17
    36ea:	98 8f       	std	Y+24, r25	; 0x18
    36ec:	8f 89       	ldd	r24, Y+23	; 0x17
    36ee:	98 8d       	ldd	r25, Y+24	; 0x18
    36f0:	8c 01       	movw	r16, r24
    36f2:	f8 01       	movw	r30, r16
    36f4:	31 97       	sbiw	r30, 0x01	; 1
    36f6:	f1 f7       	brne	.-4      	; 0x36f4 <ADC_Wait_8MHz+0x1a6>
    36f8:	8f 01       	movw	r16, r30
    36fa:	0f 8b       	std	Y+23, r16	; 0x17
    36fc:	18 8f       	std	Y+24, r17	; 0x18
    36fe:	10 c0       	rjmp	.+32     	; 0x3720 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3700:	6e 81       	ldd	r22, Y+6	; 0x06
    3702:	7f 81       	ldd	r23, Y+7	; 0x07
    3704:	88 85       	ldd	r24, Y+8	; 0x08
    3706:	99 85       	ldd	r25, Y+9	; 0x09
    3708:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    370c:	dc 01       	movw	r26, r24
    370e:	cb 01       	movw	r24, r22
    3710:	8a 87       	std	Y+10, r24	; 0x0a
    3712:	8a 85       	ldd	r24, Y+10	; 0x0a
    3714:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3716:	89 8d       	ldd	r24, Y+25	; 0x19
    3718:	18 2f       	mov	r17, r24
    371a:	1a 95       	dec	r17
    371c:	f1 f7       	brne	.-4      	; 0x371a <ADC_Wait_8MHz+0x1cc>
    371e:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3720:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3722:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3724:	29 81       	ldd	r18, Y+1	; 0x01
    3726:	fc 01       	movw	r30, r24
    3728:	24 83       	std	Z+4, r18	; 0x04
}
    372a:	6b 96       	adiw	r28, 0x1b	; 27
    372c:	cd bf       	out	0x3d, r28	; 61
    372e:	de bf       	out	0x3e, r29	; 62
    3730:	df 91       	pop	r29
    3732:	cf 91       	pop	r28
    3734:	1f 91       	pop	r17
    3736:	0f 91       	pop	r16
    3738:	08 95       	ret

0000373a <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    373a:	0f 93       	push	r16
    373c:	1f 93       	push	r17
    373e:	cf 93       	push	r28
    3740:	df 93       	push	r29
    3742:	cd b7       	in	r28, 0x3d	; 61
    3744:	de b7       	in	r29, 0x3e	; 62
    3746:	6b 97       	sbiw	r28, 0x1b	; 27
    3748:	cd bf       	out	0x3d, r28	; 61
    374a:	de bf       	out	0x3e, r29	; 62
    374c:	8a 8f       	std	Y+26, r24	; 0x1a
    374e:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3750:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3752:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3754:	fc 01       	movw	r30, r24
    3756:	84 81       	ldd	r24, Z+4	; 0x04
    3758:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    375a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    375c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    375e:	21 e0       	ldi	r18, 0x01	; 1
    3760:	fc 01       	movw	r30, r24
    3762:	24 83       	std	Z+4, r18	; 0x04
    3764:	80 e0       	ldi	r24, 0x00	; 0
    3766:	90 e0       	ldi	r25, 0x00	; 0
    3768:	a0 e0       	ldi	r26, 0x00	; 0
    376a:	b3 e4       	ldi	r27, 0x43	; 67
    376c:	8a 83       	std	Y+2, r24	; 0x02
    376e:	9b 83       	std	Y+3, r25	; 0x03
    3770:	ac 83       	std	Y+4, r26	; 0x04
    3772:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3774:	6a 81       	ldd	r22, Y+2	; 0x02
    3776:	7b 81       	ldd	r23, Y+3	; 0x03
    3778:	8c 81       	ldd	r24, Y+4	; 0x04
    377a:	9d 81       	ldd	r25, Y+5	; 0x05
    377c:	2b ea       	ldi	r18, 0xAB	; 171
    377e:	3a ea       	ldi	r19, 0xAA	; 170
    3780:	4a e2       	ldi	r20, 0x2A	; 42
    3782:	5f e3       	ldi	r21, 0x3F	; 63
    3784:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    3788:	dc 01       	movw	r26, r24
    378a:	cb 01       	movw	r24, r22
    378c:	8e 83       	std	Y+6, r24	; 0x06
    378e:	9f 83       	std	Y+7, r25	; 0x07
    3790:	a8 87       	std	Y+8, r26	; 0x08
    3792:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3794:	11 e0       	ldi	r17, 0x01	; 1
    3796:	6e 81       	ldd	r22, Y+6	; 0x06
    3798:	7f 81       	ldd	r23, Y+7	; 0x07
    379a:	88 85       	ldd	r24, Y+8	; 0x08
    379c:	99 85       	ldd	r25, Y+9	; 0x09
    379e:	20 e0       	ldi	r18, 0x00	; 0
    37a0:	30 e0       	ldi	r19, 0x00	; 0
    37a2:	40 e8       	ldi	r20, 0x80	; 128
    37a4:	5f e3       	ldi	r21, 0x3F	; 63
    37a6:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    37aa:	88 23       	and	r24, r24
    37ac:	0c f0       	brlt	.+2      	; 0x37b0 <ADC_Wait_32MHz+0x76>
    37ae:	10 e0       	ldi	r17, 0x00	; 0
    37b0:	11 23       	and	r17, r17
    37b2:	19 f0       	breq	.+6      	; 0x37ba <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    37b4:	81 e0       	ldi	r24, 0x01	; 1
    37b6:	8a 87       	std	Y+10, r24	; 0x0a
    37b8:	a3 c0       	rjmp	.+326    	; 0x3900 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    37ba:	11 e0       	ldi	r17, 0x01	; 1
    37bc:	6e 81       	ldd	r22, Y+6	; 0x06
    37be:	7f 81       	ldd	r23, Y+7	; 0x07
    37c0:	88 85       	ldd	r24, Y+8	; 0x08
    37c2:	99 85       	ldd	r25, Y+9	; 0x09
    37c4:	20 e0       	ldi	r18, 0x00	; 0
    37c6:	30 e0       	ldi	r19, 0x00	; 0
    37c8:	4f e7       	ldi	r20, 0x7F	; 127
    37ca:	53 e4       	ldi	r21, 0x43	; 67
    37cc:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    37d0:	18 16       	cp	r1, r24
    37d2:	0c f0       	brlt	.+2      	; 0x37d6 <ADC_Wait_32MHz+0x9c>
    37d4:	10 e0       	ldi	r17, 0x00	; 0
    37d6:	11 23       	and	r17, r17
    37d8:	09 f4       	brne	.+2      	; 0x37dc <ADC_Wait_32MHz+0xa2>
    37da:	89 c0       	rjmp	.+274    	; 0x38ee <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    37dc:	6a 81       	ldd	r22, Y+2	; 0x02
    37de:	7b 81       	ldd	r23, Y+3	; 0x03
    37e0:	8c 81       	ldd	r24, Y+4	; 0x04
    37e2:	9d 81       	ldd	r25, Y+5	; 0x05
    37e4:	20 e0       	ldi	r18, 0x00	; 0
    37e6:	30 e0       	ldi	r19, 0x00	; 0
    37e8:	4a e7       	ldi	r20, 0x7A	; 122
    37ea:	54 e4       	ldi	r21, 0x44	; 68
    37ec:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    37f0:	dc 01       	movw	r26, r24
    37f2:	cb 01       	movw	r24, r22
    37f4:	8b 87       	std	Y+11, r24	; 0x0b
    37f6:	9c 87       	std	Y+12, r25	; 0x0c
    37f8:	ad 87       	std	Y+13, r26	; 0x0d
    37fa:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    37fc:	6b 85       	ldd	r22, Y+11	; 0x0b
    37fe:	7c 85       	ldd	r23, Y+12	; 0x0c
    3800:	8d 85       	ldd	r24, Y+13	; 0x0d
    3802:	9e 85       	ldd	r25, Y+14	; 0x0e
    3804:	20 e0       	ldi	r18, 0x00	; 0
    3806:	30 e0       	ldi	r19, 0x00	; 0
    3808:	4a ef       	ldi	r20, 0xFA	; 250
    380a:	53 e4       	ldi	r21, 0x43	; 67
    380c:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    3810:	dc 01       	movw	r26, r24
    3812:	cb 01       	movw	r24, r22
    3814:	8f 87       	std	Y+15, r24	; 0x0f
    3816:	98 8b       	std	Y+16, r25	; 0x10
    3818:	a9 8b       	std	Y+17, r26	; 0x11
    381a:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    381c:	11 e0       	ldi	r17, 0x01	; 1
    381e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3820:	78 89       	ldd	r23, Y+16	; 0x10
    3822:	89 89       	ldd	r24, Y+17	; 0x11
    3824:	9a 89       	ldd	r25, Y+18	; 0x12
    3826:	20 e0       	ldi	r18, 0x00	; 0
    3828:	30 e0       	ldi	r19, 0x00	; 0
    382a:	40 e8       	ldi	r20, 0x80	; 128
    382c:	5f e3       	ldi	r21, 0x3F	; 63
    382e:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    3832:	88 23       	and	r24, r24
    3834:	0c f0       	brlt	.+2      	; 0x3838 <ADC_Wait_32MHz+0xfe>
    3836:	10 e0       	ldi	r17, 0x00	; 0
    3838:	11 23       	and	r17, r17
    383a:	29 f0       	breq	.+10     	; 0x3846 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    383c:	81 e0       	ldi	r24, 0x01	; 1
    383e:	90 e0       	ldi	r25, 0x00	; 0
    3840:	8b 8b       	std	Y+19, r24	; 0x13
    3842:	9c 8b       	std	Y+20, r25	; 0x14
    3844:	46 c0       	rjmp	.+140    	; 0x38d2 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3846:	11 e0       	ldi	r17, 0x01	; 1
    3848:	6f 85       	ldd	r22, Y+15	; 0x0f
    384a:	78 89       	ldd	r23, Y+16	; 0x10
    384c:	89 89       	ldd	r24, Y+17	; 0x11
    384e:	9a 89       	ldd	r25, Y+18	; 0x12
    3850:	20 e0       	ldi	r18, 0x00	; 0
    3852:	3f ef       	ldi	r19, 0xFF	; 255
    3854:	4f e7       	ldi	r20, 0x7F	; 127
    3856:	57 e4       	ldi	r21, 0x47	; 71
    3858:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    385c:	18 16       	cp	r1, r24
    385e:	0c f0       	brlt	.+2      	; 0x3862 <ADC_Wait_32MHz+0x128>
    3860:	10 e0       	ldi	r17, 0x00	; 0
    3862:	11 23       	and	r17, r17
    3864:	61 f1       	breq	.+88     	; 0x38be <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3866:	6b 85       	ldd	r22, Y+11	; 0x0b
    3868:	7c 85       	ldd	r23, Y+12	; 0x0c
    386a:	8d 85       	ldd	r24, Y+13	; 0x0d
    386c:	9e 85       	ldd	r25, Y+14	; 0x0e
    386e:	20 e0       	ldi	r18, 0x00	; 0
    3870:	30 e0       	ldi	r19, 0x00	; 0
    3872:	40 e2       	ldi	r20, 0x20	; 32
    3874:	51 e4       	ldi	r21, 0x41	; 65
    3876:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    387a:	dc 01       	movw	r26, r24
    387c:	cb 01       	movw	r24, r22
    387e:	bc 01       	movw	r22, r24
    3880:	cd 01       	movw	r24, r26
    3882:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    3886:	dc 01       	movw	r26, r24
    3888:	cb 01       	movw	r24, r22
    388a:	8b 8b       	std	Y+19, r24	; 0x13
    388c:	9c 8b       	std	Y+20, r25	; 0x14
    388e:	12 c0       	rjmp	.+36     	; 0x38b4 <ADC_Wait_32MHz+0x17a>
    3890:	82 e3       	ldi	r24, 0x32	; 50
    3892:	90 e0       	ldi	r25, 0x00	; 0
    3894:	8d 8b       	std	Y+21, r24	; 0x15
    3896:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3898:	8d 89       	ldd	r24, Y+21	; 0x15
    389a:	9e 89       	ldd	r25, Y+22	; 0x16
    389c:	8c 01       	movw	r16, r24
    389e:	c8 01       	movw	r24, r16
    38a0:	01 97       	sbiw	r24, 0x01	; 1
    38a2:	f1 f7       	brne	.-4      	; 0x38a0 <ADC_Wait_32MHz+0x166>
    38a4:	8c 01       	movw	r16, r24
    38a6:	0d 8b       	std	Y+21, r16	; 0x15
    38a8:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38aa:	8b 89       	ldd	r24, Y+19	; 0x13
    38ac:	9c 89       	ldd	r25, Y+20	; 0x14
    38ae:	01 97       	sbiw	r24, 0x01	; 1
    38b0:	8b 8b       	std	Y+19, r24	; 0x13
    38b2:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    38b4:	8b 89       	ldd	r24, Y+19	; 0x13
    38b6:	9c 89       	ldd	r25, Y+20	; 0x14
    38b8:	00 97       	sbiw	r24, 0x00	; 0
    38ba:	51 f7       	brne	.-44     	; 0x3890 <ADC_Wait_32MHz+0x156>
    38bc:	28 c0       	rjmp	.+80     	; 0x390e <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    38be:	6f 85       	ldd	r22, Y+15	; 0x0f
    38c0:	78 89       	ldd	r23, Y+16	; 0x10
    38c2:	89 89       	ldd	r24, Y+17	; 0x11
    38c4:	9a 89       	ldd	r25, Y+18	; 0x12
    38c6:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    38ca:	dc 01       	movw	r26, r24
    38cc:	cb 01       	movw	r24, r22
    38ce:	8b 8b       	std	Y+19, r24	; 0x13
    38d0:	9c 8b       	std	Y+20, r25	; 0x14
    38d2:	8b 89       	ldd	r24, Y+19	; 0x13
    38d4:	9c 89       	ldd	r25, Y+20	; 0x14
    38d6:	8f 8b       	std	Y+23, r24	; 0x17
    38d8:	98 8f       	std	Y+24, r25	; 0x18
    38da:	8f 89       	ldd	r24, Y+23	; 0x17
    38dc:	98 8d       	ldd	r25, Y+24	; 0x18
    38de:	8c 01       	movw	r16, r24
    38e0:	f8 01       	movw	r30, r16
    38e2:	31 97       	sbiw	r30, 0x01	; 1
    38e4:	f1 f7       	brne	.-4      	; 0x38e2 <ADC_Wait_32MHz+0x1a8>
    38e6:	8f 01       	movw	r16, r30
    38e8:	0f 8b       	std	Y+23, r16	; 0x17
    38ea:	18 8f       	std	Y+24, r17	; 0x18
    38ec:	10 c0       	rjmp	.+32     	; 0x390e <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    38ee:	6e 81       	ldd	r22, Y+6	; 0x06
    38f0:	7f 81       	ldd	r23, Y+7	; 0x07
    38f2:	88 85       	ldd	r24, Y+8	; 0x08
    38f4:	99 85       	ldd	r25, Y+9	; 0x09
    38f6:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    38fa:	dc 01       	movw	r26, r24
    38fc:	cb 01       	movw	r24, r22
    38fe:	8a 87       	std	Y+10, r24	; 0x0a
    3900:	8a 85       	ldd	r24, Y+10	; 0x0a
    3902:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3904:	89 8d       	ldd	r24, Y+25	; 0x19
    3906:	18 2f       	mov	r17, r24
    3908:	1a 95       	dec	r17
    390a:	f1 f7       	brne	.-4      	; 0x3908 <ADC_Wait_32MHz+0x1ce>
    390c:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    390e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3910:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3912:	29 81       	ldd	r18, Y+1	; 0x01
    3914:	fc 01       	movw	r30, r24
    3916:	24 83       	std	Z+4, r18	; 0x04
}
    3918:	6b 96       	adiw	r28, 0x1b	; 27
    391a:	cd bf       	out	0x3d, r28	; 61
    391c:	de bf       	out	0x3e, r29	; 62
    391e:	df 91       	pop	r29
    3920:	cf 91       	pop	r28
    3922:	1f 91       	pop	r17
    3924:	0f 91       	pop	r16
    3926:	08 95       	ret

00003928 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3928:	cf 93       	push	r28
    392a:	df 93       	push	r29
    392c:	cd b7       	in	r28, 0x3d	; 61
    392e:	de b7       	in	r29, 0x3e	; 62
    3930:	2a 97       	sbiw	r28, 0x0a	; 10
    3932:	cd bf       	out	0x3d, r28	; 61
    3934:	de bf       	out	0x3e, r29	; 62
    3936:	8e 83       	std	Y+6, r24	; 0x06
    3938:	9f 83       	std	Y+7, r25	; 0x07
    393a:	68 87       	std	Y+8, r22	; 0x08
    393c:	79 87       	std	Y+9, r23	; 0x09
    393e:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3940:	8a 85       	ldd	r24, Y+10	; 0x0a
    3942:	88 23       	and	r24, r24
    3944:	a9 f1       	breq	.+106    	; 0x39b0 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3946:	19 82       	std	Y+1, r1	; 0x01
    3948:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    394a:	1b 82       	std	Y+3, r1	; 0x03
    394c:	1c 82       	std	Y+4, r1	; 0x04
    394e:	24 c0       	rjmp	.+72     	; 0x3998 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3950:	88 85       	ldd	r24, Y+8	; 0x08
    3952:	99 85       	ldd	r25, Y+9	; 0x09
    3954:	fc 01       	movw	r30, r24
    3956:	80 81       	ld	r24, Z
    3958:	28 2f       	mov	r18, r24
    395a:	20 68       	ori	r18, 0x80	; 128
    395c:	88 85       	ldd	r24, Y+8	; 0x08
    395e:	99 85       	ldd	r25, Y+9	; 0x09
    3960:	fc 01       	movw	r30, r24
    3962:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3964:	88 85       	ldd	r24, Y+8	; 0x08
    3966:	99 85       	ldd	r25, Y+9	; 0x09
    3968:	fc 01       	movw	r30, r24
    396a:	83 81       	ldd	r24, Z+3	; 0x03
    396c:	88 2f       	mov	r24, r24
    396e:	90 e0       	ldi	r25, 0x00	; 0
    3970:	81 70       	andi	r24, 0x01	; 1
    3972:	90 70       	andi	r25, 0x00	; 0
    3974:	00 97       	sbiw	r24, 0x00	; 0
    3976:	b1 f3       	breq	.-20     	; 0x3964 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3978:	88 85       	ldd	r24, Y+8	; 0x08
    397a:	99 85       	ldd	r25, Y+9	; 0x09
    397c:	60 e0       	ldi	r22, 0x00	; 0
    397e:	0e 94 19 1a 	call	0x3432	; 0x3432 <ADC_ResultCh_GetWord_Unsigned>
    3982:	29 81       	ldd	r18, Y+1	; 0x01
    3984:	3a 81       	ldd	r19, Y+2	; 0x02
    3986:	82 0f       	add	r24, r18
    3988:	93 1f       	adc	r25, r19
    398a:	89 83       	std	Y+1, r24	; 0x01
    398c:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    398e:	8b 81       	ldd	r24, Y+3	; 0x03
    3990:	9c 81       	ldd	r25, Y+4	; 0x04
    3992:	01 96       	adiw	r24, 0x01	; 1
    3994:	8b 83       	std	Y+3, r24	; 0x03
    3996:	9c 83       	std	Y+4, r25	; 0x04
    3998:	8b 81       	ldd	r24, Y+3	; 0x03
    399a:	9c 81       	ldd	r25, Y+4	; 0x04
    399c:	84 30       	cpi	r24, 0x04	; 4
    399e:	91 05       	cpc	r25, r1
    39a0:	bc f2       	brlt	.-82     	; 0x3950 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    39a2:	89 81       	ldd	r24, Y+1	; 0x01
    39a4:	9a 81       	ldd	r25, Y+2	; 0x02
    39a6:	96 95       	lsr	r25
    39a8:	87 95       	ror	r24
    39aa:	96 95       	lsr	r25
    39ac:	87 95       	ror	r24
    39ae:	1b c0       	rjmp	.+54     	; 0x39e6 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    39b0:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    39b2:	88 85       	ldd	r24, Y+8	; 0x08
    39b4:	99 85       	ldd	r25, Y+9	; 0x09
    39b6:	fc 01       	movw	r30, r24
    39b8:	80 81       	ld	r24, Z
    39ba:	28 2f       	mov	r18, r24
    39bc:	20 68       	ori	r18, 0x80	; 128
    39be:	88 85       	ldd	r24, Y+8	; 0x08
    39c0:	99 85       	ldd	r25, Y+9	; 0x09
    39c2:	fc 01       	movw	r30, r24
    39c4:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    39c6:	88 85       	ldd	r24, Y+8	; 0x08
    39c8:	99 85       	ldd	r25, Y+9	; 0x09
    39ca:	fc 01       	movw	r30, r24
    39cc:	83 81       	ldd	r24, Z+3	; 0x03
    39ce:	88 2f       	mov	r24, r24
    39d0:	90 e0       	ldi	r25, 0x00	; 0
    39d2:	81 70       	andi	r24, 0x01	; 1
    39d4:	90 70       	andi	r25, 0x00	; 0
    39d6:	00 97       	sbiw	r24, 0x00	; 0
    39d8:	b1 f3       	breq	.-20     	; 0x39c6 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    39da:	88 85       	ldd	r24, Y+8	; 0x08
    39dc:	99 85       	ldd	r25, Y+9	; 0x09
    39de:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <ADC_ResultCh_GetWord>
    39e2:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    39e4:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    39e6:	2a 96       	adiw	r28, 0x0a	; 10
    39e8:	cd bf       	out	0x3d, r28	; 61
    39ea:	de bf       	out	0x3e, r29	; 62
    39ec:	df 91       	pop	r29
    39ee:	cf 91       	pop	r28
    39f0:	08 95       	ret

000039f2 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    39f2:	cf 93       	push	r28
    39f4:	df 93       	push	r29
    39f6:	cd b7       	in	r28, 0x3d	; 61
    39f8:	de b7       	in	r29, 0x3e	; 62
    39fa:	2a 97       	sbiw	r28, 0x0a	; 10
    39fc:	cd bf       	out	0x3d, r28	; 61
    39fe:	de bf       	out	0x3e, r29	; 62
    3a00:	8e 83       	std	Y+6, r24	; 0x06
    3a02:	9f 83       	std	Y+7, r25	; 0x07
    3a04:	68 87       	std	Y+8, r22	; 0x08
    3a06:	79 87       	std	Y+9, r23	; 0x09
    3a08:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3a0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a0c:	88 23       	and	r24, r24
    3a0e:	c1 f1       	breq	.+112    	; 0x3a80 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3a10:	19 82       	std	Y+1, r1	; 0x01
    3a12:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3a14:	1b 82       	std	Y+3, r1	; 0x03
    3a16:	1c 82       	std	Y+4, r1	; 0x04
    3a18:	24 c0       	rjmp	.+72     	; 0x3a62 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3a1a:	88 85       	ldd	r24, Y+8	; 0x08
    3a1c:	99 85       	ldd	r25, Y+9	; 0x09
    3a1e:	fc 01       	movw	r30, r24
    3a20:	80 81       	ld	r24, Z
    3a22:	28 2f       	mov	r18, r24
    3a24:	20 68       	ori	r18, 0x80	; 128
    3a26:	88 85       	ldd	r24, Y+8	; 0x08
    3a28:	99 85       	ldd	r25, Y+9	; 0x09
    3a2a:	fc 01       	movw	r30, r24
    3a2c:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3a2e:	88 85       	ldd	r24, Y+8	; 0x08
    3a30:	99 85       	ldd	r25, Y+9	; 0x09
    3a32:	fc 01       	movw	r30, r24
    3a34:	83 81       	ldd	r24, Z+3	; 0x03
    3a36:	88 2f       	mov	r24, r24
    3a38:	90 e0       	ldi	r25, 0x00	; 0
    3a3a:	81 70       	andi	r24, 0x01	; 1
    3a3c:	90 70       	andi	r25, 0x00	; 0
    3a3e:	00 97       	sbiw	r24, 0x00	; 0
    3a40:	b1 f3       	breq	.-20     	; 0x3a2e <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3a42:	88 85       	ldd	r24, Y+8	; 0x08
    3a44:	99 85       	ldd	r25, Y+9	; 0x09
    3a46:	60 e0       	ldi	r22, 0x00	; 0
    3a48:	0e 94 3e 1a 	call	0x347c	; 0x347c <ADC_ResultCh_GetWord_Signed>
    3a4c:	29 81       	ldd	r18, Y+1	; 0x01
    3a4e:	3a 81       	ldd	r19, Y+2	; 0x02
    3a50:	82 0f       	add	r24, r18
    3a52:	93 1f       	adc	r25, r19
    3a54:	89 83       	std	Y+1, r24	; 0x01
    3a56:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3a58:	8b 81       	ldd	r24, Y+3	; 0x03
    3a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a5c:	01 96       	adiw	r24, 0x01	; 1
    3a5e:	8b 83       	std	Y+3, r24	; 0x03
    3a60:	9c 83       	std	Y+4, r25	; 0x04
    3a62:	8b 81       	ldd	r24, Y+3	; 0x03
    3a64:	9c 81       	ldd	r25, Y+4	; 0x04
    3a66:	84 30       	cpi	r24, 0x04	; 4
    3a68:	91 05       	cpc	r25, r1
    3a6a:	bc f2       	brlt	.-82     	; 0x3a1a <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3a6c:	89 81       	ldd	r24, Y+1	; 0x01
    3a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a70:	99 23       	and	r25, r25
    3a72:	0c f4       	brge	.+2      	; 0x3a76 <ADC_Offset_Get_Signed+0x84>
    3a74:	03 96       	adiw	r24, 0x03	; 3
    3a76:	95 95       	asr	r25
    3a78:	87 95       	ror	r24
    3a7a:	95 95       	asr	r25
    3a7c:	87 95       	ror	r24
    3a7e:	1c c0       	rjmp	.+56     	; 0x3ab8 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3a80:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3a82:	88 85       	ldd	r24, Y+8	; 0x08
    3a84:	99 85       	ldd	r25, Y+9	; 0x09
    3a86:	fc 01       	movw	r30, r24
    3a88:	80 81       	ld	r24, Z
    3a8a:	28 2f       	mov	r18, r24
    3a8c:	20 68       	ori	r18, 0x80	; 128
    3a8e:	88 85       	ldd	r24, Y+8	; 0x08
    3a90:	99 85       	ldd	r25, Y+9	; 0x09
    3a92:	fc 01       	movw	r30, r24
    3a94:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3a96:	88 85       	ldd	r24, Y+8	; 0x08
    3a98:	99 85       	ldd	r25, Y+9	; 0x09
    3a9a:	fc 01       	movw	r30, r24
    3a9c:	83 81       	ldd	r24, Z+3	; 0x03
    3a9e:	88 2f       	mov	r24, r24
    3aa0:	90 e0       	ldi	r25, 0x00	; 0
    3aa2:	81 70       	andi	r24, 0x01	; 1
    3aa4:	90 70       	andi	r25, 0x00	; 0
    3aa6:	00 97       	sbiw	r24, 0x00	; 0
    3aa8:	b1 f3       	breq	.-20     	; 0x3a96 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3aaa:	88 85       	ldd	r24, Y+8	; 0x08
    3aac:	99 85       	ldd	r25, Y+9	; 0x09
    3aae:	60 e0       	ldi	r22, 0x00	; 0
    3ab0:	0e 94 3e 1a 	call	0x347c	; 0x347c <ADC_ResultCh_GetWord_Signed>
    3ab4:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3ab6:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3ab8:	2a 96       	adiw	r28, 0x0a	; 10
    3aba:	cd bf       	out	0x3d, r28	; 61
    3abc:	de bf       	out	0x3e, r29	; 62
    3abe:	df 91       	pop	r29
    3ac0:	cf 91       	pop	r28
    3ac2:	08 95       	ret

00003ac4 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3ac4:	1f 93       	push	r17
    3ac6:	cf 93       	push	r28
    3ac8:	df 93       	push	r29
    3aca:	cd b7       	in	r28, 0x3d	; 61
    3acc:	de b7       	in	r29, 0x3e	; 62
    3ace:	25 97       	sbiw	r28, 0x05	; 5
    3ad0:	cd bf       	out	0x3d, r28	; 61
    3ad2:	de bf       	out	0x3e, r29	; 62
    3ad4:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3ad6:	8a ec       	ldi	r24, 0xCA	; 202
    3ad8:	91 e0       	ldi	r25, 0x01	; 1
    3ada:	22 e0       	ldi	r18, 0x02	; 2
    3adc:	fc 01       	movw	r30, r24
    3ade:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3ae0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ae2:	88 2f       	mov	r24, r24
    3ae4:	90 e0       	ldi	r25, 0x00	; 0
    3ae6:	89 83       	std	Y+1, r24	; 0x01
    3ae8:	9a 83       	std	Y+2, r25	; 0x02
    3aea:	89 81       	ldd	r24, Y+1	; 0x01
    3aec:	9a 81       	ldd	r25, Y+2	; 0x02
    3aee:	fc 01       	movw	r30, r24
    3af0:	14 91       	lpm	r17, Z
    3af2:	1b 83       	std	Y+3, r17	; 0x03
    3af4:	8b 81       	ldd	r24, Y+3	; 0x03
    3af6:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3af8:	8a ec       	ldi	r24, 0xCA	; 202
    3afa:	91 e0       	ldi	r25, 0x01	; 1
    3afc:	fc 01       	movw	r30, r24
    3afe:	10 82       	st	Z, r1

	return result;
    3b00:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3b02:	25 96       	adiw	r28, 0x05	; 5
    3b04:	cd bf       	out	0x3d, r28	; 61
    3b06:	de bf       	out	0x3e, r29	; 62
    3b08:	df 91       	pop	r29
    3b0a:	cf 91       	pop	r28
    3b0c:	1f 91       	pop	r17
    3b0e:	08 95       	ret

00003b10 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3b10:	cf 93       	push	r28
    3b12:	df 93       	push	r29
    3b14:	cd b7       	in	r28, 0x3d	; 61
    3b16:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3b18:	24 e1       	ldi	r18, 0x14	; 20
    3b1a:	8c e2       	ldi	r24, 0x2C	; 44
    3b1c:	91 e2       	ldi	r25, 0x21	; 33
    3b1e:	fc 01       	movw	r30, r24
    3b20:	32 2f       	mov	r19, r18
    3b22:	11 92       	st	Z+, r1
    3b24:	3a 95       	dec	r19
    3b26:	e9 f7       	brne	.-6      	; 0x3b22 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3b28:	0e 94 4e 2b 	call	0x569c	; 0x569c <chb_get_short_addr>
    3b2c:	80 93 2c 21 	sts	0x212C, r24
    3b30:	90 93 2d 21 	sts	0x212D, r25
    chb_drvr_init();
    3b34:	0e 94 46 2d 	call	0x5a8c	; 0x5a8c <chb_drvr_init>
	radio_msg_received_int_enable();
    3b38:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <radio_msg_received_int_enable>
}
    3b3c:	df 91       	pop	r29
    3b3e:	cf 91       	pop	r28
    3b40:	08 95       	ret

00003b42 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    3b42:	cf 93       	push	r28
    3b44:	df 93       	push	r29
    3b46:	cd b7       	in	r28, 0x3d	; 61
    3b48:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    3b4a:	80 e8       	ldi	r24, 0x80	; 128
    3b4c:	96 e0       	ldi	r25, 0x06	; 6
    3b4e:	24 e0       	ldi	r18, 0x04	; 4
    3b50:	fc 01       	movw	r30, r24
    3b52:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3b54:	80 e8       	ldi	r24, 0x80	; 128
    3b56:	96 e0       	ldi	r25, 0x06	; 6
    3b58:	24 e0       	ldi	r18, 0x04	; 4
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3b5e:	80 e8       	ldi	r24, 0x80	; 128
    3b60:	96 e0       	ldi	r25, 0x06	; 6
    3b62:	22 e0       	ldi	r18, 0x02	; 2
    3b64:	fc 01       	movw	r30, r24
    3b66:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3b68:	80 e8       	ldi	r24, 0x80	; 128
    3b6a:	96 e0       	ldi	r25, 0x06	; 6
    3b6c:	24 e0       	ldi	r18, 0x04	; 4
    3b6e:	fc 01       	movw	r30, r24
    3b70:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3b72:	80 e8       	ldi	r24, 0x80	; 128
    3b74:	96 e0       	ldi	r25, 0x06	; 6
    3b76:	23 e0       	ldi	r18, 0x03	; 3
    3b78:	fc 01       	movw	r30, r24
    3b7a:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3b7c:	80 ea       	ldi	r24, 0xA0	; 160
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	20 ea       	ldi	r18, 0xA0	; 160
    3b82:	30 e0       	ldi	r19, 0x00	; 0
    3b84:	f9 01       	movw	r30, r18
    3b86:	22 81       	ldd	r18, Z+2	; 0x02
    3b88:	24 60       	ori	r18, 0x04	; 4
    3b8a:	fc 01       	movw	r30, r24
    3b8c:	22 83       	std	Z+2, r18	; 0x02
	sei();
    3b8e:	78 94       	sei
}
    3b90:	df 91       	pop	r29
    3b92:	cf 91       	pop	r28
    3b94:	08 95       	ret

00003b96 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3b96:	cf 93       	push	r28
    3b98:	df 93       	push	r29
    3b9a:	cd b7       	in	r28, 0x3d	; 61
    3b9c:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3b9e:	8c e2       	ldi	r24, 0x2C	; 44
    3ba0:	91 e2       	ldi	r25, 0x21	; 33
}
    3ba2:	df 91       	pop	r29
    3ba4:	cf 91       	pop	r28
    3ba6:	08 95       	ret

00003ba8 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3ba8:	cf 93       	push	r28
    3baa:	df 93       	push	r29
    3bac:	cd b7       	in	r28, 0x3d	; 61
    3bae:	de b7       	in	r29, 0x3e	; 62
    3bb0:	27 97       	sbiw	r28, 0x07	; 7
    3bb2:	cd bf       	out	0x3d, r28	; 61
    3bb4:	de bf       	out	0x3e, r29	; 62
    3bb6:	8b 83       	std	Y+3, r24	; 0x03
    3bb8:	9c 83       	std	Y+4, r25	; 0x04
    3bba:	6d 83       	std	Y+5, r22	; 0x05
    3bbc:	7e 83       	std	Y+6, r23	; 0x06
    3bbe:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3bc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3bc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3bc4:	89 83       	std	Y+1, r24	; 0x01
    3bc6:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3bc8:	8f 81       	ldd	r24, Y+7	; 0x07
    3bca:	28 2f       	mov	r18, r24
    3bcc:	25 5f       	subi	r18, 0xF5	; 245
    3bce:	89 81       	ldd	r24, Y+1	; 0x01
    3bd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3bd2:	fc 01       	movw	r30, r24
    3bd4:	20 83       	st	Z, r18
    3bd6:	89 81       	ldd	r24, Y+1	; 0x01
    3bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bda:	01 96       	adiw	r24, 0x01	; 1
    3bdc:	89 83       	std	Y+1, r24	; 0x01
    3bde:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3be0:	8d 81       	ldd	r24, Y+5	; 0x05
    3be2:	9e 81       	ldd	r25, Y+6	; 0x06
    3be4:	ff ef       	ldi	r31, 0xFF	; 255
    3be6:	8f 3f       	cpi	r24, 0xFF	; 255
    3be8:	9f 07       	cpc	r25, r31
    3bea:	11 f0       	breq	.+4      	; 0x3bf0 <chb_gen_hdr+0x48>
    3bec:	21 e6       	ldi	r18, 0x61	; 97
    3bee:	01 c0       	rjmp	.+2      	; 0x3bf2 <chb_gen_hdr+0x4a>
    3bf0:	21 e4       	ldi	r18, 0x41	; 65
    3bf2:	89 81       	ldd	r24, Y+1	; 0x01
    3bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf6:	fc 01       	movw	r30, r24
    3bf8:	20 83       	st	Z, r18
    3bfa:	89 81       	ldd	r24, Y+1	; 0x01
    3bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bfe:	01 96       	adiw	r24, 0x01	; 1
    3c00:	89 83       	std	Y+1, r24	; 0x01
    3c02:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3c04:	89 81       	ldd	r24, Y+1	; 0x01
    3c06:	9a 81       	ldd	r25, Y+2	; 0x02
    3c08:	28 e9       	ldi	r18, 0x98	; 152
    3c0a:	fc 01       	movw	r30, r24
    3c0c:	20 83       	st	Z, r18
    3c0e:	89 81       	ldd	r24, Y+1	; 0x01
    3c10:	9a 81       	ldd	r25, Y+2	; 0x02
    3c12:	01 96       	adiw	r24, 0x01	; 1
    3c14:	89 83       	std	Y+1, r24	; 0x01
    3c16:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3c18:	20 91 2e 21 	lds	r18, 0x212E
    3c1c:	89 81       	ldd	r24, Y+1	; 0x01
    3c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c20:	fc 01       	movw	r30, r24
    3c22:	20 83       	st	Z, r18
    3c24:	89 81       	ldd	r24, Y+1	; 0x01
    3c26:	9a 81       	ldd	r25, Y+2	; 0x02
    3c28:	01 96       	adiw	r24, 0x01	; 1
    3c2a:	89 83       	std	Y+1, r24	; 0x01
    3c2c:	9a 83       	std	Y+2, r25	; 0x02
    3c2e:	82 2f       	mov	r24, r18
    3c30:	8f 5f       	subi	r24, 0xFF	; 255
    3c32:	80 93 2e 21 	sts	0x212E, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3c36:	89 81       	ldd	r24, Y+1	; 0x01
    3c38:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3a:	24 e3       	ldi	r18, 0x34	; 52
    3c3c:	32 e1       	ldi	r19, 0x12	; 18
    3c3e:	fc 01       	movw	r30, r24
    3c40:	20 83       	st	Z, r18
    3c42:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3c44:	89 81       	ldd	r24, Y+1	; 0x01
    3c46:	9a 81       	ldd	r25, Y+2	; 0x02
    3c48:	02 96       	adiw	r24, 0x02	; 2
    3c4a:	89 83       	std	Y+1, r24	; 0x01
    3c4c:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3c4e:	89 81       	ldd	r24, Y+1	; 0x01
    3c50:	9a 81       	ldd	r25, Y+2	; 0x02
    3c52:	2d 81       	ldd	r18, Y+5	; 0x05
    3c54:	3e 81       	ldd	r19, Y+6	; 0x06
    3c56:	fc 01       	movw	r30, r24
    3c58:	20 83       	st	Z, r18
    3c5a:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3c5c:	89 81       	ldd	r24, Y+1	; 0x01
    3c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c60:	02 96       	adiw	r24, 0x02	; 2
    3c62:	89 83       	std	Y+1, r24	; 0x01
    3c64:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3c66:	20 91 2c 21 	lds	r18, 0x212C
    3c6a:	30 91 2d 21 	lds	r19, 0x212D
    3c6e:	89 81       	ldd	r24, Y+1	; 0x01
    3c70:	9a 81       	ldd	r25, Y+2	; 0x02
    3c72:	fc 01       	movw	r30, r24
    3c74:	20 83       	st	Z, r18
    3c76:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3c78:	89 81       	ldd	r24, Y+1	; 0x01
    3c7a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c7c:	02 96       	adiw	r24, 0x02	; 2
    3c7e:	89 83       	std	Y+1, r24	; 0x01
    3c80:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3c82:	29 81       	ldd	r18, Y+1	; 0x01
    3c84:	3a 81       	ldd	r19, Y+2	; 0x02
    3c86:	8b 81       	ldd	r24, Y+3	; 0x03
    3c88:	9c 81       	ldd	r25, Y+4	; 0x04
    3c8a:	a9 01       	movw	r20, r18
    3c8c:	48 1b       	sub	r20, r24
    3c8e:	59 0b       	sbc	r21, r25
    3c90:	ca 01       	movw	r24, r20
}
    3c92:	27 96       	adiw	r28, 0x07	; 7
    3c94:	cd bf       	out	0x3d, r28	; 61
    3c96:	de bf       	out	0x3e, r29	; 62
    3c98:	df 91       	pop	r29
    3c9a:	cf 91       	pop	r28
    3c9c:	08 95       	ret

00003c9e <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3c9e:	ef 92       	push	r14
    3ca0:	ff 92       	push	r15
    3ca2:	0f 93       	push	r16
    3ca4:	1f 93       	push	r17
    3ca6:	cf 93       	push	r28
    3ca8:	df 93       	push	r29
    3caa:	cd b7       	in	r28, 0x3d	; 61
    3cac:	de b7       	in	r29, 0x3e	; 62
    3cae:	e0 97       	sbiw	r28, 0x30	; 48
    3cb0:	cd bf       	out	0x3d, r28	; 61
    3cb2:	de bf       	out	0x3e, r29	; 62
    3cb4:	89 a7       	lds	r24, 0x79
    3cb6:	9a a7       	lds	r25, 0x7a
    3cb8:	6b a7       	lds	r22, 0x7b
    3cba:	7c a7       	lds	r23, 0x7c
    3cbc:	2d a7       	lds	r18, 0x7d
    3cbe:	3e a7       	lds	r19, 0x7e
    3cc0:	4f a7       	lds	r20, 0x7f
    3cc2:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    3cc4:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3cc6:	62 c1       	rjmp	.+708    	; 0x3f8c <chb_write+0x2ee>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3cc8:	8d a5       	lds	r24, 0x6d
    3cca:	9e a5       	lds	r25, 0x6e
    3ccc:	af a5       	lds	r26, 0x6f
    3cce:	b8 a9       	sts	0x48, r27
    3cd0:	85 36       	cpi	r24, 0x65	; 101
    3cd2:	91 05       	cpc	r25, r1
    3cd4:	a1 05       	cpc	r26, r1
    3cd6:	b1 05       	cpc	r27, r1
    3cd8:	20 f0       	brcs	.+8      	; 0x3ce2 <chb_write+0x44>
    3cda:	84 e6       	ldi	r24, 0x64	; 100
    3cdc:	90 e0       	ldi	r25, 0x00	; 0
    3cde:	a0 e0       	ldi	r26, 0x00	; 0
    3ce0:	b0 e0       	ldi	r27, 0x00	; 0
    3ce2:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    3ce4:	ce 01       	movw	r24, r28
    3ce6:	4f 96       	adiw	r24, 0x1f	; 31
    3ce8:	29 a5       	lds	r18, 0x69
    3cea:	3a a5       	lds	r19, 0x6a
    3cec:	b9 01       	movw	r22, r18
    3cee:	4c 81       	ldd	r20, Y+4	; 0x04
    3cf0:	0e 94 d4 1d 	call	0x3ba8	; 0x3ba8 <chb_gen_hdr>
    3cf4:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    3cf6:	1a 82       	std	Y+2, r1	; 0x02
    3cf8:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3cfa:	89 81       	ldd	r24, Y+1	; 0x01
    3cfc:	88 2f       	mov	r24, r24
    3cfe:	90 e0       	ldi	r25, 0x00	; 0
    3d00:	2b a5       	lds	r18, 0x6b
    3d02:	3c a5       	lds	r19, 0x6c
    3d04:	28 0f       	add	r18, r24
    3d06:	39 1f       	adc	r19, r25
    3d08:	ce 01       	movw	r24, r28
    3d0a:	4f 96       	adiw	r24, 0x1f	; 31
    3d0c:	b9 01       	movw	r22, r18
    3d0e:	4c 81       	ldd	r20, Y+4	; 0x04
    3d10:	0e 94 68 2b 	call	0x56d0	; 0x56d0 <chb_tx>
    3d14:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    3d16:	8e 81       	ldd	r24, Y+6	; 0x06
    3d18:	88 2f       	mov	r24, r24
    3d1a:	90 e0       	ldi	r25, 0x00	; 0
    3d1c:	83 30       	cpi	r24, 0x03	; 3
    3d1e:	91 05       	cpc	r25, r1
    3d20:	31 f1       	breq	.+76     	; 0x3d6e <chb_write+0xd0>
    3d22:	84 30       	cpi	r24, 0x04	; 4
    3d24:	91 05       	cpc	r25, r1
    3d26:	24 f4       	brge	.+8      	; 0x3d30 <chb_write+0x92>
    3d28:	81 30       	cpi	r24, 0x01	; 1
    3d2a:	91 05       	cpc	r25, r1
    3d2c:	39 f0       	breq	.+14     	; 0x3d3c <chb_write+0x9e>
    3d2e:	2e c0       	rjmp	.+92     	; 0x3d8c <chb_write+0xee>
    3d30:	85 30       	cpi	r24, 0x05	; 5
    3d32:	91 05       	cpc	r25, r1
    3d34:	69 f0       	breq	.+26     	; 0x3d50 <chb_write+0xb2>
    3d36:	80 34       	cpi	r24, 0x40	; 64
    3d38:	91 05       	cpc	r25, r1
    3d3a:	41 f5       	brne	.+80     	; 0x3d8c <chb_write+0xee>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3d3c:	80 91 33 21 	lds	r24, 0x2133
    3d40:	90 91 34 21 	lds	r25, 0x2134
    3d44:	01 96       	adiw	r24, 0x01	; 1
    3d46:	80 93 33 21 	sts	0x2133, r24
    3d4a:	90 93 34 21 	sts	0x2134, r25
                 break;
    3d4e:	1f c0       	rjmp	.+62     	; 0x3d8e <chb_write+0xf0>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3d50:	80 91 35 21 	lds	r24, 0x2135
    3d54:	90 91 36 21 	lds	r25, 0x2136
    3d58:	01 96       	adiw	r24, 0x01	; 1
    3d5a:	80 93 35 21 	sts	0x2135, r24
    3d5e:	90 93 36 21 	sts	0x2136, r25
				 rtry++;
    3d62:	8a 81       	ldd	r24, Y+2	; 0x02
    3d64:	9b 81       	ldd	r25, Y+3	; 0x03
    3d66:	01 96       	adiw	r24, 0x01	; 1
    3d68:	8a 83       	std	Y+2, r24	; 0x02
    3d6a:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3d6c:	10 c0       	rjmp	.+32     	; 0x3d8e <chb_write+0xf0>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3d6e:	80 91 37 21 	lds	r24, 0x2137
    3d72:	90 91 38 21 	lds	r25, 0x2138
    3d76:	01 96       	adiw	r24, 0x01	; 1
    3d78:	80 93 37 21 	sts	0x2137, r24
    3d7c:	90 93 38 21 	sts	0x2138, r25
				 rtry++;
    3d80:	8a 81       	ldd	r24, Y+2	; 0x02
    3d82:	9b 81       	ldd	r25, Y+3	; 0x03
    3d84:	01 96       	adiw	r24, 0x01	; 1
    3d86:	8a 83       	std	Y+2, r24	; 0x02
    3d88:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3d8a:	01 c0       	rjmp	.+2      	; 0x3d8e <chb_write+0xf0>
 
             default:
                 break;
    3d8c:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    3d8e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d90:	9b 81       	ldd	r25, Y+3	; 0x03
    3d92:	18 16       	cp	r1, r24
    3d94:	19 06       	cpc	r1, r25
    3d96:	0c f0       	brlt	.+2      	; 0x3d9a <chb_write+0xfc>
    3d98:	d5 c0       	rjmp	.+426    	; 0x3f44 <chb_write+0x2a6>
    3d9a:	80 e0       	ldi	r24, 0x00	; 0
    3d9c:	90 e0       	ldi	r25, 0x00	; 0
    3d9e:	a0 e2       	ldi	r26, 0x20	; 32
    3da0:	b1 e4       	ldi	r27, 0x41	; 65
    3da2:	8f 83       	std	Y+7, r24	; 0x07
    3da4:	98 87       	std	Y+8, r25	; 0x08
    3da6:	a9 87       	std	Y+9, r26	; 0x09
    3da8:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3daa:	6f 81       	ldd	r22, Y+7	; 0x07
    3dac:	78 85       	ldd	r23, Y+8	; 0x08
    3dae:	89 85       	ldd	r24, Y+9	; 0x09
    3db0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3db2:	2b ea       	ldi	r18, 0xAB	; 171
    3db4:	3a ea       	ldi	r19, 0xAA	; 170
    3db6:	4a ea       	ldi	r20, 0xAA	; 170
    3db8:	5e e3       	ldi	r21, 0x3E	; 62
    3dba:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    3dbe:	dc 01       	movw	r26, r24
    3dc0:	cb 01       	movw	r24, r22
    3dc2:	8b 87       	std	Y+11, r24	; 0x0b
    3dc4:	9c 87       	std	Y+12, r25	; 0x0c
    3dc6:	ad 87       	std	Y+13, r26	; 0x0d
    3dc8:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    3dca:	11 e0       	ldi	r17, 0x01	; 1
    3dcc:	6b 85       	ldd	r22, Y+11	; 0x0b
    3dce:	7c 85       	ldd	r23, Y+12	; 0x0c
    3dd0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3dd2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3dd4:	20 e0       	ldi	r18, 0x00	; 0
    3dd6:	30 e0       	ldi	r19, 0x00	; 0
    3dd8:	40 e8       	ldi	r20, 0x80	; 128
    3dda:	5f e3       	ldi	r21, 0x3F	; 63
    3ddc:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    3de0:	88 23       	and	r24, r24
    3de2:	0c f0       	brlt	.+2      	; 0x3de6 <chb_write+0x148>
    3de4:	10 e0       	ldi	r17, 0x00	; 0
    3de6:	11 23       	and	r17, r17
    3de8:	19 f0       	breq	.+6      	; 0x3df0 <chb_write+0x152>
		__ticks = 1;
    3dea:	81 e0       	ldi	r24, 0x01	; 1
    3dec:	8f 87       	std	Y+15, r24	; 0x0f
    3dee:	a3 c0       	rjmp	.+326    	; 0x3f36 <chb_write+0x298>
	else if (__tmp > 255)
    3df0:	11 e0       	ldi	r17, 0x01	; 1
    3df2:	6b 85       	ldd	r22, Y+11	; 0x0b
    3df4:	7c 85       	ldd	r23, Y+12	; 0x0c
    3df6:	8d 85       	ldd	r24, Y+13	; 0x0d
    3df8:	9e 85       	ldd	r25, Y+14	; 0x0e
    3dfa:	20 e0       	ldi	r18, 0x00	; 0
    3dfc:	30 e0       	ldi	r19, 0x00	; 0
    3dfe:	4f e7       	ldi	r20, 0x7F	; 127
    3e00:	53 e4       	ldi	r21, 0x43	; 67
    3e02:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    3e06:	18 16       	cp	r1, r24
    3e08:	0c f0       	brlt	.+2      	; 0x3e0c <chb_write+0x16e>
    3e0a:	10 e0       	ldi	r17, 0x00	; 0
    3e0c:	11 23       	and	r17, r17
    3e0e:	09 f4       	brne	.+2      	; 0x3e12 <chb_write+0x174>
    3e10:	89 c0       	rjmp	.+274    	; 0x3f24 <chb_write+0x286>
	{
		_delay_ms(__us / 1000.0);
    3e12:	6f 81       	ldd	r22, Y+7	; 0x07
    3e14:	78 85       	ldd	r23, Y+8	; 0x08
    3e16:	89 85       	ldd	r24, Y+9	; 0x09
    3e18:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e1a:	20 e0       	ldi	r18, 0x00	; 0
    3e1c:	30 e0       	ldi	r19, 0x00	; 0
    3e1e:	4a e7       	ldi	r20, 0x7A	; 122
    3e20:	54 e4       	ldi	r21, 0x44	; 68
    3e22:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    3e26:	dc 01       	movw	r26, r24
    3e28:	cb 01       	movw	r24, r22
    3e2a:	88 8b       	std	Y+16, r24	; 0x10
    3e2c:	99 8b       	std	Y+17, r25	; 0x11
    3e2e:	aa 8b       	std	Y+18, r26	; 0x12
    3e30:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3e32:	68 89       	ldd	r22, Y+16	; 0x10
    3e34:	79 89       	ldd	r23, Y+17	; 0x11
    3e36:	8a 89       	ldd	r24, Y+18	; 0x12
    3e38:	9b 89       	ldd	r25, Y+19	; 0x13
    3e3a:	20 e0       	ldi	r18, 0x00	; 0
    3e3c:	30 e0       	ldi	r19, 0x00	; 0
    3e3e:	4a e7       	ldi	r20, 0x7A	; 122
    3e40:	53 e4       	ldi	r21, 0x43	; 67
    3e42:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    3e46:	dc 01       	movw	r26, r24
    3e48:	cb 01       	movw	r24, r22
    3e4a:	8c 8b       	std	Y+20, r24	; 0x14
    3e4c:	9d 8b       	std	Y+21, r25	; 0x15
    3e4e:	ae 8b       	std	Y+22, r26	; 0x16
    3e50:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    3e52:	11 e0       	ldi	r17, 0x01	; 1
    3e54:	6c 89       	ldd	r22, Y+20	; 0x14
    3e56:	7d 89       	ldd	r23, Y+21	; 0x15
    3e58:	8e 89       	ldd	r24, Y+22	; 0x16
    3e5a:	9f 89       	ldd	r25, Y+23	; 0x17
    3e5c:	20 e0       	ldi	r18, 0x00	; 0
    3e5e:	30 e0       	ldi	r19, 0x00	; 0
    3e60:	40 e8       	ldi	r20, 0x80	; 128
    3e62:	5f e3       	ldi	r21, 0x3F	; 63
    3e64:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    3e68:	88 23       	and	r24, r24
    3e6a:	0c f0       	brlt	.+2      	; 0x3e6e <chb_write+0x1d0>
    3e6c:	10 e0       	ldi	r17, 0x00	; 0
    3e6e:	11 23       	and	r17, r17
    3e70:	29 f0       	breq	.+10     	; 0x3e7c <chb_write+0x1de>
		__ticks = 1;
    3e72:	81 e0       	ldi	r24, 0x01	; 1
    3e74:	90 e0       	ldi	r25, 0x00	; 0
    3e76:	88 8f       	std	Y+24, r24	; 0x18
    3e78:	99 8f       	std	Y+25, r25	; 0x19
    3e7a:	46 c0       	rjmp	.+140    	; 0x3f08 <chb_write+0x26a>
	else if (__tmp > 65535)
    3e7c:	11 e0       	ldi	r17, 0x01	; 1
    3e7e:	6c 89       	ldd	r22, Y+20	; 0x14
    3e80:	7d 89       	ldd	r23, Y+21	; 0x15
    3e82:	8e 89       	ldd	r24, Y+22	; 0x16
    3e84:	9f 89       	ldd	r25, Y+23	; 0x17
    3e86:	20 e0       	ldi	r18, 0x00	; 0
    3e88:	3f ef       	ldi	r19, 0xFF	; 255
    3e8a:	4f e7       	ldi	r20, 0x7F	; 127
    3e8c:	57 e4       	ldi	r21, 0x47	; 71
    3e8e:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    3e92:	18 16       	cp	r1, r24
    3e94:	0c f0       	brlt	.+2      	; 0x3e98 <chb_write+0x1fa>
    3e96:	10 e0       	ldi	r17, 0x00	; 0
    3e98:	11 23       	and	r17, r17
    3e9a:	61 f1       	breq	.+88     	; 0x3ef4 <chb_write+0x256>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3e9c:	68 89       	ldd	r22, Y+16	; 0x10
    3e9e:	79 89       	ldd	r23, Y+17	; 0x11
    3ea0:	8a 89       	ldd	r24, Y+18	; 0x12
    3ea2:	9b 89       	ldd	r25, Y+19	; 0x13
    3ea4:	20 e0       	ldi	r18, 0x00	; 0
    3ea6:	30 e0       	ldi	r19, 0x00	; 0
    3ea8:	40 e2       	ldi	r20, 0x20	; 32
    3eaa:	51 e4       	ldi	r21, 0x41	; 65
    3eac:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    3eb0:	dc 01       	movw	r26, r24
    3eb2:	cb 01       	movw	r24, r22
    3eb4:	bc 01       	movw	r22, r24
    3eb6:	cd 01       	movw	r24, r26
    3eb8:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    3ebc:	dc 01       	movw	r26, r24
    3ebe:	cb 01       	movw	r24, r22
    3ec0:	88 8f       	std	Y+24, r24	; 0x18
    3ec2:	99 8f       	std	Y+25, r25	; 0x19
    3ec4:	12 c0       	rjmp	.+36     	; 0x3eea <chb_write+0x24c>
    3ec6:	89 e1       	ldi	r24, 0x19	; 25
    3ec8:	90 e0       	ldi	r25, 0x00	; 0
    3eca:	8a 8f       	std	Y+26, r24	; 0x1a
    3ecc:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3ece:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ed0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ed2:	8c 01       	movw	r16, r24
    3ed4:	c8 01       	movw	r24, r16
    3ed6:	01 97       	sbiw	r24, 0x01	; 1
    3ed8:	f1 f7       	brne	.-4      	; 0x3ed6 <chb_write+0x238>
    3eda:	8c 01       	movw	r16, r24
    3edc:	0a 8f       	std	Y+26, r16	; 0x1a
    3ede:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ee0:	88 8d       	ldd	r24, Y+24	; 0x18
    3ee2:	99 8d       	ldd	r25, Y+25	; 0x19
    3ee4:	01 97       	sbiw	r24, 0x01	; 1
    3ee6:	88 8f       	std	Y+24, r24	; 0x18
    3ee8:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3eea:	88 8d       	ldd	r24, Y+24	; 0x18
    3eec:	99 8d       	ldd	r25, Y+25	; 0x19
    3eee:	00 97       	sbiw	r24, 0x00	; 0
    3ef0:	51 f7       	brne	.-44     	; 0x3ec6 <chb_write+0x228>
    3ef2:	28 c0       	rjmp	.+80     	; 0x3f44 <chb_write+0x2a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3ef4:	6c 89       	ldd	r22, Y+20	; 0x14
    3ef6:	7d 89       	ldd	r23, Y+21	; 0x15
    3ef8:	8e 89       	ldd	r24, Y+22	; 0x16
    3efa:	9f 89       	ldd	r25, Y+23	; 0x17
    3efc:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    3f00:	dc 01       	movw	r26, r24
    3f02:	cb 01       	movw	r24, r22
    3f04:	88 8f       	std	Y+24, r24	; 0x18
    3f06:	99 8f       	std	Y+25, r25	; 0x19
    3f08:	88 8d       	ldd	r24, Y+24	; 0x18
    3f0a:	99 8d       	ldd	r25, Y+25	; 0x19
    3f0c:	8c 8f       	std	Y+28, r24	; 0x1c
    3f0e:	9d 8f       	std	Y+29, r25	; 0x1d
    3f10:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3f12:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3f14:	8c 01       	movw	r16, r24
    3f16:	c8 01       	movw	r24, r16
    3f18:	01 97       	sbiw	r24, 0x01	; 1
    3f1a:	f1 f7       	brne	.-4      	; 0x3f18 <chb_write+0x27a>
    3f1c:	8c 01       	movw	r16, r24
    3f1e:	0c 8f       	std	Y+28, r16	; 0x1c
    3f20:	1d 8f       	std	Y+29, r17	; 0x1d
    3f22:	10 c0       	rjmp	.+32     	; 0x3f44 <chb_write+0x2a6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3f24:	6b 85       	ldd	r22, Y+11	; 0x0b
    3f26:	7c 85       	ldd	r23, Y+12	; 0x0c
    3f28:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f2c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    3f30:	dc 01       	movw	r26, r24
    3f32:	cb 01       	movw	r24, r22
    3f34:	8f 87       	std	Y+15, r24	; 0x0f
    3f36:	8f 85       	ldd	r24, Y+15	; 0x0f
    3f38:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3f3a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3f3c:	18 2f       	mov	r17, r24
    3f3e:	1a 95       	dec	r17
    3f40:	f1 f7       	brne	.-4      	; 0x3f3e <chb_write+0x2a0>
    3f42:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    3f44:	8a 81       	ldd	r24, Y+2	; 0x02
    3f46:	9b 81       	ldd	r25, Y+3	; 0x03
    3f48:	84 31       	cpi	r24, 0x14	; 20
    3f4a:	91 05       	cpc	r25, r1
    3f4c:	11 f4       	brne	.+4      	; 0x3f52 <chb_write+0x2b4>
    3f4e:	8e 81       	ldd	r24, Y+6	; 0x06
    3f50:	27 c0       	rjmp	.+78     	; 0x3fa0 <chb_write+0x302>
		} while(status != CHB_SUCCESS);			
    3f52:	8e 81       	ldd	r24, Y+6	; 0x06
    3f54:	88 23       	and	r24, r24
    3f56:	09 f0       	breq	.+2      	; 0x3f5a <chb_write+0x2bc>
    3f58:	d0 ce       	rjmp	.-608    	; 0x3cfa <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    3f5a:	99 81       	ldd	r25, Y+1	; 0x01
    3f5c:	8c 81       	ldd	r24, Y+4	; 0x04
    3f5e:	89 0f       	add	r24, r25
    3f60:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    3f62:	8c 81       	ldd	r24, Y+4	; 0x04
    3f64:	88 2f       	mov	r24, r24
    3f66:	90 e0       	ldi	r25, 0x00	; 0
    3f68:	a0 e0       	ldi	r26, 0x00	; 0
    3f6a:	b0 e0       	ldi	r27, 0x00	; 0
    3f6c:	2d a5       	lds	r18, 0x6d
    3f6e:	3e a5       	lds	r19, 0x6e
    3f70:	4f a5       	lds	r20, 0x6f
    3f72:	58 a9       	sts	0x48, r21
    3f74:	79 01       	movw	r14, r18
    3f76:	8a 01       	movw	r16, r20
    3f78:	e8 1a       	sub	r14, r24
    3f7a:	f9 0a       	sbc	r15, r25
    3f7c:	0a 0b       	sbc	r16, r26
    3f7e:	1b 0b       	sbc	r17, r27
    3f80:	d8 01       	movw	r26, r16
    3f82:	c7 01       	movw	r24, r14
    3f84:	8d a7       	lds	r24, 0x7d
    3f86:	9e a7       	lds	r25, 0x7e
    3f88:	af a7       	lds	r26, 0x7f
    3f8a:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3f8c:	8d a5       	lds	r24, 0x6d
    3f8e:	9e a5       	lds	r25, 0x6e
    3f90:	af a5       	lds	r26, 0x6f
    3f92:	b8 a9       	sts	0x48, r27
    3f94:	00 97       	sbiw	r24, 0x00	; 0
    3f96:	a1 05       	cpc	r26, r1
    3f98:	b1 05       	cpc	r27, r1
    3f9a:	09 f0       	breq	.+2      	; 0x3f9e <chb_write+0x300>
    3f9c:	95 ce       	rjmp	.-726    	; 0x3cc8 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    3f9e:	80 e0       	ldi	r24, 0x00	; 0
}
    3fa0:	e0 96       	adiw	r28, 0x30	; 48
    3fa2:	cd bf       	out	0x3d, r28	; 61
    3fa4:	de bf       	out	0x3e, r29	; 62
    3fa6:	df 91       	pop	r29
    3fa8:	cf 91       	pop	r28
    3faa:	1f 91       	pop	r17
    3fac:	0f 91       	pop	r16
    3fae:	ff 90       	pop	r15
    3fb0:	ef 90       	pop	r14
    3fb2:	08 95       	ret

00003fb4 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3fb4:	cf 93       	push	r28
    3fb6:	df 93       	push	r29
    3fb8:	cd b7       	in	r28, 0x3d	; 61
    3fba:	de b7       	in	r29, 0x3e	; 62
    3fbc:	27 97       	sbiw	r28, 0x07	; 7
    3fbe:	cd bf       	out	0x3d, r28	; 61
    3fc0:	de bf       	out	0x3e, r29	; 62
    3fc2:	8e 83       	std	Y+6, r24	; 0x06
    3fc4:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    3fc6:	8e 81       	ldd	r24, Y+6	; 0x06
    3fc8:	9f 81       	ldd	r25, Y+7	; 0x07
    3fca:	05 96       	adiw	r24, 0x05	; 5
    3fcc:	8a 83       	std	Y+2, r24	; 0x02
    3fce:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    3fd0:	0e 94 a7 20 	call	0x414e	; 0x414e <chb_buf_read>
    3fd4:	8c 83       	std	Y+4, r24	; 0x04
    3fd6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fd8:	88 23       	and	r24, r24
    3fda:	14 f4       	brge	.+4      	; 0x3fe0 <chb_read+0x2c>
    {
        return 0;
    3fdc:	80 e0       	ldi	r24, 0x00	; 0
    3fde:	80 c0       	rjmp	.+256    	; 0x40e0 <chb_read+0x12c>
    }
    *data_ptr++ = len;
    3fe0:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe2:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe4:	2c 81       	ldd	r18, Y+4	; 0x04
    3fe6:	fc 01       	movw	r30, r24
    3fe8:	20 83       	st	Z, r18
    3fea:	8a 81       	ldd	r24, Y+2	; 0x02
    3fec:	9b 81       	ldd	r25, Y+3	; 0x03
    3fee:	01 96       	adiw	r24, 0x01	; 1
    3ff0:	8a 83       	std	Y+2, r24	; 0x02
    3ff2:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    3ff4:	19 82       	std	Y+1, r1	; 0x01
    3ff6:	0f c0       	rjmp	.+30     	; 0x4016 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    3ff8:	0e 94 a7 20 	call	0x414e	; 0x414e <chb_buf_read>
    3ffc:	28 2f       	mov	r18, r24
    3ffe:	8a 81       	ldd	r24, Y+2	; 0x02
    4000:	9b 81       	ldd	r25, Y+3	; 0x03
    4002:	fc 01       	movw	r30, r24
    4004:	20 83       	st	Z, r18
    4006:	8a 81       	ldd	r24, Y+2	; 0x02
    4008:	9b 81       	ldd	r25, Y+3	; 0x03
    400a:	01 96       	adiw	r24, 0x01	; 1
    400c:	8a 83       	std	Y+2, r24	; 0x02
    400e:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4010:	89 81       	ldd	r24, Y+1	; 0x01
    4012:	8f 5f       	subi	r24, 0xFF	; 255
    4014:	89 83       	std	Y+1, r24	; 0x01
    4016:	99 81       	ldd	r25, Y+1	; 0x01
    4018:	8c 81       	ldd	r24, Y+4	; 0x04
    401a:	98 17       	cp	r25, r24
    401c:	68 f3       	brcs	.-38     	; 0x3ff8 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    401e:	8e 81       	ldd	r24, Y+6	; 0x06
    4020:	9f 81       	ldd	r25, Y+7	; 0x07
    4022:	08 96       	adiw	r24, 0x08	; 8
    4024:	8a 83       	std	Y+2, r24	; 0x02
    4026:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4028:	8a 81       	ldd	r24, Y+2	; 0x02
    402a:	9b 81       	ldd	r25, Y+3	; 0x03
    402c:	fc 01       	movw	r30, r24
    402e:	80 81       	ld	r24, Z
    4030:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    4032:	8e 81       	ldd	r24, Y+6	; 0x06
    4034:	9f 81       	ldd	r25, Y+7	; 0x07
    4036:	0b 96       	adiw	r24, 0x0b	; 11
    4038:	8a 83       	std	Y+2, r24	; 0x02
    403a:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    403c:	8a 81       	ldd	r24, Y+2	; 0x02
    403e:	9b 81       	ldd	r25, Y+3	; 0x03
    4040:	fc 01       	movw	r30, r24
    4042:	20 81       	ld	r18, Z
    4044:	31 81       	ldd	r19, Z+1	; 0x01
    4046:	8e 81       	ldd	r24, Y+6	; 0x06
    4048:	9f 81       	ldd	r25, Y+7	; 0x07
    404a:	fc 01       	movw	r30, r24
    404c:	23 83       	std	Z+3, r18	; 0x03
    404e:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    4050:	8a 81       	ldd	r24, Y+2	; 0x02
    4052:	9b 81       	ldd	r25, Y+3	; 0x03
    4054:	02 96       	adiw	r24, 0x02	; 2
    4056:	8a 83       	std	Y+2, r24	; 0x02
    4058:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    405a:	8a 81       	ldd	r24, Y+2	; 0x02
    405c:	9b 81       	ldd	r25, Y+3	; 0x03
    405e:	fc 01       	movw	r30, r24
    4060:	20 81       	ld	r18, Z
    4062:	31 81       	ldd	r19, Z+1	; 0x01
    4064:	8e 81       	ldd	r24, Y+6	; 0x06
    4066:	9f 81       	ldd	r25, Y+7	; 0x07
    4068:	fc 01       	movw	r30, r24
    406a:	21 83       	std	Z+1, r18	; 0x01
    406c:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    406e:	8a 81       	ldd	r24, Y+2	; 0x02
    4070:	9b 81       	ldd	r25, Y+3	; 0x03
    4072:	02 96       	adiw	r24, 0x02	; 2
    4074:	8a 83       	std	Y+2, r24	; 0x02
    4076:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    4078:	0e 94 cb 20 	call	0x4196	; 0x4196 <chb_buf_get_len>
    407c:	88 23       	and	r24, r24
    407e:	11 f4       	brne	.+4      	; 0x4084 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    4080:	10 92 2f 21 	sts	0x212F, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    4084:	80 91 06 20 	lds	r24, 0x2006
    4088:	9d 81       	ldd	r25, Y+5	; 0x05
    408a:	98 17       	cp	r25, r24
    408c:	71 f4       	brne	.+28     	; 0x40aa <chb_read+0xf6>
    408e:	8e 81       	ldd	r24, Y+6	; 0x06
    4090:	9f 81       	ldd	r25, Y+7	; 0x07
    4092:	fc 01       	movw	r30, r24
    4094:	21 81       	ldd	r18, Z+1	; 0x01
    4096:	32 81       	ldd	r19, Z+2	; 0x02
    4098:	80 91 07 20 	lds	r24, 0x2007
    409c:	90 91 08 20 	lds	r25, 0x2008
    40a0:	28 17       	cp	r18, r24
    40a2:	39 07       	cpc	r19, r25
    40a4:	11 f4       	brne	.+4      	; 0x40aa <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    40a6:	80 e0       	ldi	r24, 0x00	; 0
    40a8:	1b c0       	rjmp	.+54     	; 0x40e0 <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    40aa:	8d 81       	ldd	r24, Y+5	; 0x05
    40ac:	80 93 06 20 	sts	0x2006, r24
        prev_src_addr = rx->src_addr;
    40b0:	8e 81       	ldd	r24, Y+6	; 0x06
    40b2:	9f 81       	ldd	r25, Y+7	; 0x07
    40b4:	fc 01       	movw	r30, r24
    40b6:	81 81       	ldd	r24, Z+1	; 0x01
    40b8:	92 81       	ldd	r25, Z+2	; 0x02
    40ba:	80 93 07 20 	sts	0x2007, r24
    40be:	90 93 08 20 	sts	0x2008, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    40c2:	8c 81       	ldd	r24, Y+4	; 0x04
    40c4:	88 2f       	mov	r24, r24
    40c6:	90 e0       	ldi	r25, 0x00	; 0
    40c8:	09 97       	sbiw	r24, 0x09	; 9
    40ca:	9c 01       	movw	r18, r24
    40cc:	8e 81       	ldd	r24, Y+6	; 0x06
    40ce:	9f 81       	ldd	r25, Y+7	; 0x07
    40d0:	4a 81       	ldd	r20, Y+2	; 0x02
    40d2:	5b 81       	ldd	r21, Y+3	; 0x03
    40d4:	ba 01       	movw	r22, r20
    40d6:	a9 01       	movw	r20, r18
    40d8:	0e 94 68 62 	call	0xc4d0	; 0xc4d0 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    40dc:	8c 81       	ldd	r24, Y+4	; 0x04
    40de:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    40e0:	27 96       	adiw	r28, 0x07	; 7
    40e2:	cd bf       	out	0x3d, r28	; 61
    40e4:	de bf       	out	0x3e, r29	; 62
    40e6:	df 91       	pop	r29
    40e8:	cf 91       	pop	r28
    40ea:	08 95       	ret

000040ec <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    40ec:	cf 93       	push	r28
    40ee:	df 93       	push	r29
    40f0:	cd b7       	in	r28, 0x3d	; 61
    40f2:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    40f4:	10 92 c0 21 	sts	0x21C0, r1
    wr_ptr = 0;
    40f8:	10 92 c1 21 	sts	0x21C1, r1
    len = 0;
    40fc:	10 92 c2 21 	sts	0x21C2, r1
}
    4100:	df 91       	pop	r29
    4102:	cf 91       	pop	r28
    4104:	08 95       	ret

00004106 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4106:	cf 93       	push	r28
    4108:	df 93       	push	r29
    410a:	0f 92       	push	r0
    410c:	cd b7       	in	r28, 0x3d	; 61
    410e:	de b7       	in	r29, 0x3e	; 62
    4110:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4112:	80 91 c1 21 	lds	r24, 0x21C1
    4116:	88 2f       	mov	r24, r24
    4118:	90 e0       	ldi	r25, 0x00	; 0
    411a:	80 5c       	subi	r24, 0xC0	; 192
    411c:	9e 4d       	sbci	r25, 0xDE	; 222
    411e:	29 81       	ldd	r18, Y+1	; 0x01
    4120:	fc 01       	movw	r30, r24
    4122:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4124:	80 91 c1 21 	lds	r24, 0x21C1
    4128:	88 2f       	mov	r24, r24
    412a:	90 e0       	ldi	r25, 0x00	; 0
    412c:	01 96       	adiw	r24, 0x01	; 1
    412e:	20 e8       	ldi	r18, 0x80	; 128
    4130:	30 e0       	ldi	r19, 0x00	; 0
    4132:	b9 01       	movw	r22, r18
    4134:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    4138:	80 93 c1 21 	sts	0x21C1, r24
    len++;
    413c:	80 91 c2 21 	lds	r24, 0x21C2
    4140:	8f 5f       	subi	r24, 0xFF	; 255
    4142:	80 93 c2 21 	sts	0x21C2, r24
}
    4146:	0f 90       	pop	r0
    4148:	df 91       	pop	r29
    414a:	cf 91       	pop	r28
    414c:	08 95       	ret

0000414e <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    414e:	cf 93       	push	r28
    4150:	df 93       	push	r29
    4152:	0f 92       	push	r0
    4154:	cd b7       	in	r28, 0x3d	; 61
    4156:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    4158:	80 91 c0 21 	lds	r24, 0x21C0
    415c:	88 2f       	mov	r24, r24
    415e:	90 e0       	ldi	r25, 0x00	; 0
    4160:	80 5c       	subi	r24, 0xC0	; 192
    4162:	9e 4d       	sbci	r25, 0xDE	; 222
    4164:	fc 01       	movw	r30, r24
    4166:	80 81       	ld	r24, Z
    4168:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    416a:	80 91 c0 21 	lds	r24, 0x21C0
    416e:	88 2f       	mov	r24, r24
    4170:	90 e0       	ldi	r25, 0x00	; 0
    4172:	01 96       	adiw	r24, 0x01	; 1
    4174:	20 e8       	ldi	r18, 0x80	; 128
    4176:	30 e0       	ldi	r19, 0x00	; 0
    4178:	b9 01       	movw	r22, r18
    417a:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    417e:	80 93 c0 21 	sts	0x21C0, r24
    len--;
    4182:	80 91 c2 21 	lds	r24, 0x21C2
    4186:	81 50       	subi	r24, 0x01	; 1
    4188:	80 93 c2 21 	sts	0x21C2, r24
    return data;
    418c:	89 81       	ldd	r24, Y+1	; 0x01
}
    418e:	0f 90       	pop	r0
    4190:	df 91       	pop	r29
    4192:	cf 91       	pop	r28
    4194:	08 95       	ret

00004196 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    4196:	cf 93       	push	r28
    4198:	df 93       	push	r29
    419a:	cd b7       	in	r28, 0x3d	; 61
    419c:	de b7       	in	r29, 0x3e	; 62
    return len;
    419e:	80 91 c2 21 	lds	r24, 0x21C2
}
    41a2:	df 91       	pop	r29
    41a4:	cf 91       	pop	r28
    41a6:	08 95       	ret

000041a8 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    41a8:	cf 93       	push	r28
    41aa:	df 93       	push	r29
    41ac:	cd b7       	in	r28, 0x3d	; 61
    41ae:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    41b0:	81 e0       	ldi	r24, 0x01	; 1
    41b2:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    41b6:	8f 71       	andi	r24, 0x1F	; 31
}
    41b8:	df 91       	pop	r29
    41ba:	cf 91       	pop	r28
    41bc:	08 95       	ret

000041be <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    41be:	cf 93       	push	r28
    41c0:	df 93       	push	r29
    41c2:	cd b7       	in	r28, 0x3d	; 61
    41c4:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    41c6:	82 e0       	ldi	r24, 0x02	; 2
    41c8:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    41cc:	82 95       	swap	r24
    41ce:	86 95       	lsr	r24
    41d0:	87 70       	andi	r24, 0x07	; 7
}
    41d2:	df 91       	pop	r29
    41d4:	cf 91       	pop	r28
    41d6:	08 95       	ret

000041d8 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    41d8:	0f 93       	push	r16
    41da:	1f 93       	push	r17
    41dc:	cf 93       	push	r28
    41de:	df 93       	push	r29
    41e0:	cd b7       	in	r28, 0x3d	; 61
    41e2:	de b7       	in	r29, 0x3e	; 62
    41e4:	e0 97       	sbiw	r28, 0x30	; 48
    41e6:	cd bf       	out	0x3d, r28	; 61
    41e8:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    41ea:	84 e6       	ldi	r24, 0x64	; 100
    41ec:	96 e0       	ldi	r25, 0x06	; 6
    41ee:	24 e6       	ldi	r18, 0x64	; 100
    41f0:	36 e0       	ldi	r19, 0x06	; 6
    41f2:	f9 01       	movw	r30, r18
    41f4:	20 81       	ld	r18, Z
    41f6:	21 60       	ori	r18, 0x01	; 1
    41f8:	fc 01       	movw	r30, r24
    41fa:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    41fc:	84 e6       	ldi	r24, 0x64	; 100
    41fe:	96 e0       	ldi	r25, 0x06	; 6
    4200:	24 e6       	ldi	r18, 0x64	; 100
    4202:	36 e0       	ldi	r19, 0x06	; 6
    4204:	f9 01       	movw	r30, r18
    4206:	20 81       	ld	r18, Z
    4208:	2d 7f       	andi	r18, 0xFD	; 253
    420a:	fc 01       	movw	r30, r24
    420c:	20 83       	st	Z, r18
    420e:	80 e0       	ldi	r24, 0x00	; 0
    4210:	90 e0       	ldi	r25, 0x00	; 0
    4212:	ae eb       	ldi	r26, 0xBE	; 190
    4214:	b3 e4       	ldi	r27, 0x43	; 67
    4216:	89 83       	std	Y+1, r24	; 0x01
    4218:	9a 83       	std	Y+2, r25	; 0x02
    421a:	ab 83       	std	Y+3, r26	; 0x03
    421c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    421e:	69 81       	ldd	r22, Y+1	; 0x01
    4220:	7a 81       	ldd	r23, Y+2	; 0x02
    4222:	8b 81       	ldd	r24, Y+3	; 0x03
    4224:	9c 81       	ldd	r25, Y+4	; 0x04
    4226:	2b ea       	ldi	r18, 0xAB	; 171
    4228:	3a ea       	ldi	r19, 0xAA	; 170
    422a:	4a ea       	ldi	r20, 0xAA	; 170
    422c:	5e e3       	ldi	r21, 0x3E	; 62
    422e:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4232:	dc 01       	movw	r26, r24
    4234:	cb 01       	movw	r24, r22
    4236:	8d 83       	std	Y+5, r24	; 0x05
    4238:	9e 83       	std	Y+6, r25	; 0x06
    423a:	af 83       	std	Y+7, r26	; 0x07
    423c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    423e:	11 e0       	ldi	r17, 0x01	; 1
    4240:	6d 81       	ldd	r22, Y+5	; 0x05
    4242:	7e 81       	ldd	r23, Y+6	; 0x06
    4244:	8f 81       	ldd	r24, Y+7	; 0x07
    4246:	98 85       	ldd	r25, Y+8	; 0x08
    4248:	20 e0       	ldi	r18, 0x00	; 0
    424a:	30 e0       	ldi	r19, 0x00	; 0
    424c:	40 e8       	ldi	r20, 0x80	; 128
    424e:	5f e3       	ldi	r21, 0x3F	; 63
    4250:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4254:	88 23       	and	r24, r24
    4256:	0c f0       	brlt	.+2      	; 0x425a <chb_reset+0x82>
    4258:	10 e0       	ldi	r17, 0x00	; 0
    425a:	11 23       	and	r17, r17
    425c:	19 f0       	breq	.+6      	; 0x4264 <chb_reset+0x8c>
		__ticks = 1;
    425e:	81 e0       	ldi	r24, 0x01	; 1
    4260:	89 87       	std	Y+9, r24	; 0x09
    4262:	a3 c0       	rjmp	.+326    	; 0x43aa <chb_reset+0x1d2>
	else if (__tmp > 255)
    4264:	11 e0       	ldi	r17, 0x01	; 1
    4266:	6d 81       	ldd	r22, Y+5	; 0x05
    4268:	7e 81       	ldd	r23, Y+6	; 0x06
    426a:	8f 81       	ldd	r24, Y+7	; 0x07
    426c:	98 85       	ldd	r25, Y+8	; 0x08
    426e:	20 e0       	ldi	r18, 0x00	; 0
    4270:	30 e0       	ldi	r19, 0x00	; 0
    4272:	4f e7       	ldi	r20, 0x7F	; 127
    4274:	53 e4       	ldi	r21, 0x43	; 67
    4276:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    427a:	18 16       	cp	r1, r24
    427c:	0c f0       	brlt	.+2      	; 0x4280 <chb_reset+0xa8>
    427e:	10 e0       	ldi	r17, 0x00	; 0
    4280:	11 23       	and	r17, r17
    4282:	09 f4       	brne	.+2      	; 0x4286 <chb_reset+0xae>
    4284:	89 c0       	rjmp	.+274    	; 0x4398 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    4286:	69 81       	ldd	r22, Y+1	; 0x01
    4288:	7a 81       	ldd	r23, Y+2	; 0x02
    428a:	8b 81       	ldd	r24, Y+3	; 0x03
    428c:	9c 81       	ldd	r25, Y+4	; 0x04
    428e:	20 e0       	ldi	r18, 0x00	; 0
    4290:	30 e0       	ldi	r19, 0x00	; 0
    4292:	4a e7       	ldi	r20, 0x7A	; 122
    4294:	54 e4       	ldi	r21, 0x44	; 68
    4296:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    429a:	dc 01       	movw	r26, r24
    429c:	cb 01       	movw	r24, r22
    429e:	8a 87       	std	Y+10, r24	; 0x0a
    42a0:	9b 87       	std	Y+11, r25	; 0x0b
    42a2:	ac 87       	std	Y+12, r26	; 0x0c
    42a4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    42a6:	6a 85       	ldd	r22, Y+10	; 0x0a
    42a8:	7b 85       	ldd	r23, Y+11	; 0x0b
    42aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    42ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    42ae:	20 e0       	ldi	r18, 0x00	; 0
    42b0:	30 e0       	ldi	r19, 0x00	; 0
    42b2:	4a e7       	ldi	r20, 0x7A	; 122
    42b4:	53 e4       	ldi	r21, 0x43	; 67
    42b6:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    42ba:	dc 01       	movw	r26, r24
    42bc:	cb 01       	movw	r24, r22
    42be:	8e 87       	std	Y+14, r24	; 0x0e
    42c0:	9f 87       	std	Y+15, r25	; 0x0f
    42c2:	a8 8b       	std	Y+16, r26	; 0x10
    42c4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    42c6:	11 e0       	ldi	r17, 0x01	; 1
    42c8:	6e 85       	ldd	r22, Y+14	; 0x0e
    42ca:	7f 85       	ldd	r23, Y+15	; 0x0f
    42cc:	88 89       	ldd	r24, Y+16	; 0x10
    42ce:	99 89       	ldd	r25, Y+17	; 0x11
    42d0:	20 e0       	ldi	r18, 0x00	; 0
    42d2:	30 e0       	ldi	r19, 0x00	; 0
    42d4:	40 e8       	ldi	r20, 0x80	; 128
    42d6:	5f e3       	ldi	r21, 0x3F	; 63
    42d8:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    42dc:	88 23       	and	r24, r24
    42de:	0c f0       	brlt	.+2      	; 0x42e2 <chb_reset+0x10a>
    42e0:	10 e0       	ldi	r17, 0x00	; 0
    42e2:	11 23       	and	r17, r17
    42e4:	29 f0       	breq	.+10     	; 0x42f0 <chb_reset+0x118>
		__ticks = 1;
    42e6:	81 e0       	ldi	r24, 0x01	; 1
    42e8:	90 e0       	ldi	r25, 0x00	; 0
    42ea:	8a 8b       	std	Y+18, r24	; 0x12
    42ec:	9b 8b       	std	Y+19, r25	; 0x13
    42ee:	46 c0       	rjmp	.+140    	; 0x437c <chb_reset+0x1a4>
	else if (__tmp > 65535)
    42f0:	11 e0       	ldi	r17, 0x01	; 1
    42f2:	6e 85       	ldd	r22, Y+14	; 0x0e
    42f4:	7f 85       	ldd	r23, Y+15	; 0x0f
    42f6:	88 89       	ldd	r24, Y+16	; 0x10
    42f8:	99 89       	ldd	r25, Y+17	; 0x11
    42fa:	20 e0       	ldi	r18, 0x00	; 0
    42fc:	3f ef       	ldi	r19, 0xFF	; 255
    42fe:	4f e7       	ldi	r20, 0x7F	; 127
    4300:	57 e4       	ldi	r21, 0x47	; 71
    4302:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4306:	18 16       	cp	r1, r24
    4308:	0c f0       	brlt	.+2      	; 0x430c <chb_reset+0x134>
    430a:	10 e0       	ldi	r17, 0x00	; 0
    430c:	11 23       	and	r17, r17
    430e:	61 f1       	breq	.+88     	; 0x4368 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4310:	6a 85       	ldd	r22, Y+10	; 0x0a
    4312:	7b 85       	ldd	r23, Y+11	; 0x0b
    4314:	8c 85       	ldd	r24, Y+12	; 0x0c
    4316:	9d 85       	ldd	r25, Y+13	; 0x0d
    4318:	20 e0       	ldi	r18, 0x00	; 0
    431a:	30 e0       	ldi	r19, 0x00	; 0
    431c:	40 e2       	ldi	r20, 0x20	; 32
    431e:	51 e4       	ldi	r21, 0x41	; 65
    4320:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4324:	dc 01       	movw	r26, r24
    4326:	cb 01       	movw	r24, r22
    4328:	bc 01       	movw	r22, r24
    432a:	cd 01       	movw	r24, r26
    432c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4330:	dc 01       	movw	r26, r24
    4332:	cb 01       	movw	r24, r22
    4334:	8a 8b       	std	Y+18, r24	; 0x12
    4336:	9b 8b       	std	Y+19, r25	; 0x13
    4338:	12 c0       	rjmp	.+36     	; 0x435e <chb_reset+0x186>
    433a:	89 e1       	ldi	r24, 0x19	; 25
    433c:	90 e0       	ldi	r25, 0x00	; 0
    433e:	8c 8b       	std	Y+20, r24	; 0x14
    4340:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4342:	8c 89       	ldd	r24, Y+20	; 0x14
    4344:	9d 89       	ldd	r25, Y+21	; 0x15
    4346:	8c 01       	movw	r16, r24
    4348:	c8 01       	movw	r24, r16
    434a:	01 97       	sbiw	r24, 0x01	; 1
    434c:	f1 f7       	brne	.-4      	; 0x434a <chb_reset+0x172>
    434e:	8c 01       	movw	r16, r24
    4350:	0c 8b       	std	Y+20, r16	; 0x14
    4352:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4354:	8a 89       	ldd	r24, Y+18	; 0x12
    4356:	9b 89       	ldd	r25, Y+19	; 0x13
    4358:	01 97       	sbiw	r24, 0x01	; 1
    435a:	8a 8b       	std	Y+18, r24	; 0x12
    435c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    435e:	8a 89       	ldd	r24, Y+18	; 0x12
    4360:	9b 89       	ldd	r25, Y+19	; 0x13
    4362:	00 97       	sbiw	r24, 0x00	; 0
    4364:	51 f7       	brne	.-44     	; 0x433a <chb_reset+0x162>
    4366:	28 c0       	rjmp	.+80     	; 0x43b8 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4368:	6e 85       	ldd	r22, Y+14	; 0x0e
    436a:	7f 85       	ldd	r23, Y+15	; 0x0f
    436c:	88 89       	ldd	r24, Y+16	; 0x10
    436e:	99 89       	ldd	r25, Y+17	; 0x11
    4370:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4374:	dc 01       	movw	r26, r24
    4376:	cb 01       	movw	r24, r22
    4378:	8a 8b       	std	Y+18, r24	; 0x12
    437a:	9b 8b       	std	Y+19, r25	; 0x13
    437c:	8a 89       	ldd	r24, Y+18	; 0x12
    437e:	9b 89       	ldd	r25, Y+19	; 0x13
    4380:	8e 8b       	std	Y+22, r24	; 0x16
    4382:	9f 8b       	std	Y+23, r25	; 0x17
    4384:	8e 89       	ldd	r24, Y+22	; 0x16
    4386:	9f 89       	ldd	r25, Y+23	; 0x17
    4388:	8c 01       	movw	r16, r24
    438a:	f8 01       	movw	r30, r16
    438c:	31 97       	sbiw	r30, 0x01	; 1
    438e:	f1 f7       	brne	.-4      	; 0x438c <chb_reset+0x1b4>
    4390:	8f 01       	movw	r16, r30
    4392:	0e 8b       	std	Y+22, r16	; 0x16
    4394:	1f 8b       	std	Y+23, r17	; 0x17
    4396:	10 c0       	rjmp	.+32     	; 0x43b8 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4398:	6d 81       	ldd	r22, Y+5	; 0x05
    439a:	7e 81       	ldd	r23, Y+6	; 0x06
    439c:	8f 81       	ldd	r24, Y+7	; 0x07
    439e:	98 85       	ldd	r25, Y+8	; 0x08
    43a0:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    43a4:	dc 01       	movw	r26, r24
    43a6:	cb 01       	movw	r24, r22
    43a8:	89 87       	std	Y+9, r24	; 0x09
    43aa:	89 85       	ldd	r24, Y+9	; 0x09
    43ac:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    43ae:	88 8d       	ldd	r24, Y+24	; 0x18
    43b0:	18 2f       	mov	r17, r24
    43b2:	1a 95       	dec	r17
    43b4:	f1 f7       	brne	.-4      	; 0x43b2 <chb_reset+0x1da>
    43b6:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    43b8:	84 e6       	ldi	r24, 0x64	; 100
    43ba:	96 e0       	ldi	r25, 0x06	; 6
    43bc:	24 e6       	ldi	r18, 0x64	; 100
    43be:	36 e0       	ldi	r19, 0x06	; 6
    43c0:	f9 01       	movw	r30, r18
    43c2:	20 81       	ld	r18, Z
    43c4:	2e 7f       	andi	r18, 0xFE	; 254
    43c6:	fc 01       	movw	r30, r24
    43c8:	20 83       	st	Z, r18
    43ca:	80 e0       	ldi	r24, 0x00	; 0
    43cc:	90 e0       	ldi	r25, 0x00	; 0
    43ce:	a0 e8       	ldi	r26, 0x80	; 128
    43d0:	bf e3       	ldi	r27, 0x3F	; 63
    43d2:	89 8f       	std	Y+25, r24	; 0x19
    43d4:	9a 8f       	std	Y+26, r25	; 0x1a
    43d6:	ab 8f       	std	Y+27, r26	; 0x1b
    43d8:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    43da:	69 8d       	ldd	r22, Y+25	; 0x19
    43dc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    43de:	8b 8d       	ldd	r24, Y+27	; 0x1b
    43e0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    43e2:	2b ea       	ldi	r18, 0xAB	; 171
    43e4:	3a ea       	ldi	r19, 0xAA	; 170
    43e6:	4a ea       	ldi	r20, 0xAA	; 170
    43e8:	5e e3       	ldi	r21, 0x3E	; 62
    43ea:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    43ee:	dc 01       	movw	r26, r24
    43f0:	cb 01       	movw	r24, r22
    43f2:	8d 8f       	std	Y+29, r24	; 0x1d
    43f4:	9e 8f       	std	Y+30, r25	; 0x1e
    43f6:	af 8f       	std	Y+31, r26	; 0x1f
    43f8:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    43fa:	11 e0       	ldi	r17, 0x01	; 1
    43fc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    43fe:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4400:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4402:	98 a1       	lds	r25, 0x48
    4404:	20 e0       	ldi	r18, 0x00	; 0
    4406:	30 e0       	ldi	r19, 0x00	; 0
    4408:	40 e8       	ldi	r20, 0x80	; 128
    440a:	5f e3       	ldi	r21, 0x3F	; 63
    440c:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4410:	88 23       	and	r24, r24
    4412:	0c f0       	brlt	.+2      	; 0x4416 <chb_reset+0x23e>
    4414:	10 e0       	ldi	r17, 0x00	; 0
    4416:	11 23       	and	r17, r17
    4418:	19 f0       	breq	.+6      	; 0x4420 <chb_reset+0x248>
		__ticks = 1;
    441a:	81 e0       	ldi	r24, 0x01	; 1
    441c:	89 a3       	lds	r24, 0x59
    441e:	a3 c0       	rjmp	.+326    	; 0x4566 <chb_reset+0x38e>
	else if (__tmp > 255)
    4420:	11 e0       	ldi	r17, 0x01	; 1
    4422:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4424:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4426:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4428:	98 a1       	lds	r25, 0x48
    442a:	20 e0       	ldi	r18, 0x00	; 0
    442c:	30 e0       	ldi	r19, 0x00	; 0
    442e:	4f e7       	ldi	r20, 0x7F	; 127
    4430:	53 e4       	ldi	r21, 0x43	; 67
    4432:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4436:	18 16       	cp	r1, r24
    4438:	0c f0       	brlt	.+2      	; 0x443c <chb_reset+0x264>
    443a:	10 e0       	ldi	r17, 0x00	; 0
    443c:	11 23       	and	r17, r17
    443e:	09 f4       	brne	.+2      	; 0x4442 <chb_reset+0x26a>
    4440:	89 c0       	rjmp	.+274    	; 0x4554 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    4442:	69 8d       	ldd	r22, Y+25	; 0x19
    4444:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4446:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4448:	9c 8d       	ldd	r25, Y+28	; 0x1c
    444a:	20 e0       	ldi	r18, 0x00	; 0
    444c:	30 e0       	ldi	r19, 0x00	; 0
    444e:	4a e7       	ldi	r20, 0x7A	; 122
    4450:	54 e4       	ldi	r21, 0x44	; 68
    4452:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    4456:	dc 01       	movw	r26, r24
    4458:	cb 01       	movw	r24, r22
    445a:	8a a3       	lds	r24, 0x5a
    445c:	9b a3       	lds	r25, 0x5b
    445e:	ac a3       	lds	r26, 0x5c
    4460:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4462:	6a a1       	lds	r22, 0x4a
    4464:	7b a1       	lds	r23, 0x4b
    4466:	8c a1       	lds	r24, 0x4c
    4468:	9d a1       	lds	r25, 0x4d
    446a:	20 e0       	ldi	r18, 0x00	; 0
    446c:	30 e0       	ldi	r19, 0x00	; 0
    446e:	4a e7       	ldi	r20, 0x7A	; 122
    4470:	53 e4       	ldi	r21, 0x43	; 67
    4472:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4476:	dc 01       	movw	r26, r24
    4478:	cb 01       	movw	r24, r22
    447a:	8e a3       	lds	r24, 0x5e
    447c:	9f a3       	lds	r25, 0x5f
    447e:	a8 a7       	lds	r26, 0x78
    4480:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    4482:	11 e0       	ldi	r17, 0x01	; 1
    4484:	6e a1       	lds	r22, 0x4e
    4486:	7f a1       	lds	r23, 0x4f
    4488:	88 a5       	lds	r24, 0x68
    448a:	99 a5       	lds	r25, 0x69
    448c:	20 e0       	ldi	r18, 0x00	; 0
    448e:	30 e0       	ldi	r19, 0x00	; 0
    4490:	40 e8       	ldi	r20, 0x80	; 128
    4492:	5f e3       	ldi	r21, 0x3F	; 63
    4494:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4498:	88 23       	and	r24, r24
    449a:	0c f0       	brlt	.+2      	; 0x449e <chb_reset+0x2c6>
    449c:	10 e0       	ldi	r17, 0x00	; 0
    449e:	11 23       	and	r17, r17
    44a0:	29 f0       	breq	.+10     	; 0x44ac <chb_reset+0x2d4>
		__ticks = 1;
    44a2:	81 e0       	ldi	r24, 0x01	; 1
    44a4:	90 e0       	ldi	r25, 0x00	; 0
    44a6:	8a a7       	lds	r24, 0x7a
    44a8:	9b a7       	lds	r25, 0x7b
    44aa:	46 c0       	rjmp	.+140    	; 0x4538 <chb_reset+0x360>
	else if (__tmp > 65535)
    44ac:	11 e0       	ldi	r17, 0x01	; 1
    44ae:	6e a1       	lds	r22, 0x4e
    44b0:	7f a1       	lds	r23, 0x4f
    44b2:	88 a5       	lds	r24, 0x68
    44b4:	99 a5       	lds	r25, 0x69
    44b6:	20 e0       	ldi	r18, 0x00	; 0
    44b8:	3f ef       	ldi	r19, 0xFF	; 255
    44ba:	4f e7       	ldi	r20, 0x7F	; 127
    44bc:	57 e4       	ldi	r21, 0x47	; 71
    44be:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    44c2:	18 16       	cp	r1, r24
    44c4:	0c f0       	brlt	.+2      	; 0x44c8 <chb_reset+0x2f0>
    44c6:	10 e0       	ldi	r17, 0x00	; 0
    44c8:	11 23       	and	r17, r17
    44ca:	61 f1       	breq	.+88     	; 0x4524 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    44cc:	6a a1       	lds	r22, 0x4a
    44ce:	7b a1       	lds	r23, 0x4b
    44d0:	8c a1       	lds	r24, 0x4c
    44d2:	9d a1       	lds	r25, 0x4d
    44d4:	20 e0       	ldi	r18, 0x00	; 0
    44d6:	30 e0       	ldi	r19, 0x00	; 0
    44d8:	40 e2       	ldi	r20, 0x20	; 32
    44da:	51 e4       	ldi	r21, 0x41	; 65
    44dc:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    44e0:	dc 01       	movw	r26, r24
    44e2:	cb 01       	movw	r24, r22
    44e4:	bc 01       	movw	r22, r24
    44e6:	cd 01       	movw	r24, r26
    44e8:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    44ec:	dc 01       	movw	r26, r24
    44ee:	cb 01       	movw	r24, r22
    44f0:	8a a7       	lds	r24, 0x7a
    44f2:	9b a7       	lds	r25, 0x7b
    44f4:	12 c0       	rjmp	.+36     	; 0x451a <chb_reset+0x342>
    44f6:	89 e1       	ldi	r24, 0x19	; 25
    44f8:	90 e0       	ldi	r25, 0x00	; 0
    44fa:	8c a7       	lds	r24, 0x7c
    44fc:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    44fe:	8c a5       	lds	r24, 0x6c
    4500:	9d a5       	lds	r25, 0x6d
    4502:	8c 01       	movw	r16, r24
    4504:	c8 01       	movw	r24, r16
    4506:	01 97       	sbiw	r24, 0x01	; 1
    4508:	f1 f7       	brne	.-4      	; 0x4506 <chb_reset+0x32e>
    450a:	8c 01       	movw	r16, r24
    450c:	0c a7       	lds	r16, 0x7c
    450e:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4510:	8a a5       	lds	r24, 0x6a
    4512:	9b a5       	lds	r25, 0x6b
    4514:	01 97       	sbiw	r24, 0x01	; 1
    4516:	8a a7       	lds	r24, 0x7a
    4518:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    451a:	8a a5       	lds	r24, 0x6a
    451c:	9b a5       	lds	r25, 0x6b
    451e:	00 97       	sbiw	r24, 0x00	; 0
    4520:	51 f7       	brne	.-44     	; 0x44f6 <chb_reset+0x31e>
    4522:	28 c0       	rjmp	.+80     	; 0x4574 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4524:	6e a1       	lds	r22, 0x4e
    4526:	7f a1       	lds	r23, 0x4f
    4528:	88 a5       	lds	r24, 0x68
    452a:	99 a5       	lds	r25, 0x69
    452c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4530:	dc 01       	movw	r26, r24
    4532:	cb 01       	movw	r24, r22
    4534:	8a a7       	lds	r24, 0x7a
    4536:	9b a7       	lds	r25, 0x7b
    4538:	8a a5       	lds	r24, 0x6a
    453a:	9b a5       	lds	r25, 0x6b
    453c:	8e a7       	lds	r24, 0x7e
    453e:	9f a7       	lds	r25, 0x7f
    4540:	8e a5       	lds	r24, 0x6e
    4542:	9f a5       	lds	r25, 0x6f
    4544:	8c 01       	movw	r16, r24
    4546:	f8 01       	movw	r30, r16
    4548:	31 97       	sbiw	r30, 0x01	; 1
    454a:	f1 f7       	brne	.-4      	; 0x4548 <chb_reset+0x370>
    454c:	8f 01       	movw	r16, r30
    454e:	0e a7       	lds	r16, 0x7e
    4550:	1f a7       	lds	r17, 0x7f
    4552:	10 c0       	rjmp	.+32     	; 0x4574 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4554:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4556:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4558:	8f 8d       	ldd	r24, Y+31	; 0x1f
    455a:	98 a1       	lds	r25, 0x48
    455c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4560:	dc 01       	movw	r26, r24
    4562:	cb 01       	movw	r24, r22
    4564:	89 a3       	lds	r24, 0x59
    4566:	89 a1       	lds	r24, 0x49
    4568:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    456a:	88 a9       	sts	0x48, r24
    456c:	18 2f       	mov	r17, r24
    456e:	1a 95       	dec	r17
    4570:	f1 f7       	brne	.-4      	; 0x456e <chb_reset+0x396>
    4572:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4574:	84 e6       	ldi	r24, 0x64	; 100
    4576:	96 e0       	ldi	r25, 0x06	; 6
    4578:	24 e6       	ldi	r18, 0x64	; 100
    457a:	36 e0       	ldi	r19, 0x06	; 6
    457c:	f9 01       	movw	r30, r18
    457e:	20 81       	ld	r18, Z
    4580:	21 60       	ori	r18, 0x01	; 1
    4582:	fc 01       	movw	r30, r24
    4584:	20 83       	st	Z, r18
    4586:	01 c0       	rjmp	.+2      	; 0x458a <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4588:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    458a:	8d e1       	ldi	r24, 0x1D	; 29
    458c:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    4590:	81 30       	cpi	r24, 0x01	; 1
    4592:	d1 f7       	brne	.-12     	; 0x4588 <chb_reset+0x3b0>
    4594:	8c e1       	ldi	r24, 0x1C	; 28
    4596:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    459a:	87 30       	cpi	r24, 0x07	; 7
    459c:	a9 f7       	brne	.-22     	; 0x4588 <chb_reset+0x3b0>
        {
            break;
    459e:	00 00       	nop
        }
    }
	

}
    45a0:	e0 96       	adiw	r28, 0x30	; 48
    45a2:	cd bf       	out	0x3d, r28	; 61
    45a4:	de bf       	out	0x3e, r29	; 62
    45a6:	df 91       	pop	r29
    45a8:	cf 91       	pop	r28
    45aa:	1f 91       	pop	r17
    45ac:	0f 91       	pop	r16
    45ae:	08 95       	ret

000045b0 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    45b0:	cf 93       	push	r28
    45b2:	df 93       	push	r29
    45b4:	0f 92       	push	r0
    45b6:	0f 92       	push	r0
    45b8:	cd b7       	in	r28, 0x3d	; 61
    45ba:	de b7       	in	r29, 0x3e	; 62
    45bc:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    45be:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    45c0:	8a 81       	ldd	r24, Y+2	; 0x02
    45c2:	80 68       	ori	r24, 0x80	; 128
    45c4:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    45c6:	8f e3       	ldi	r24, 0x3F	; 63
    45c8:	90 e0       	ldi	r25, 0x00	; 0
    45ca:	fc 01       	movw	r30, r24
    45cc:	80 81       	ld	r24, Z
    45ce:	80 93 43 40 	sts	0x4043, r24
    45d2:	f8 94       	cli
    RadioCS(TRUE);
    45d4:	81 e0       	ldi	r24, 0x01	; 1
    45d6:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    45da:	8a 81       	ldd	r24, Y+2	; 0x02
    45dc:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    45e0:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    45e2:	89 81       	ldd	r24, Y+1	; 0x01
    45e4:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    45e8:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    45ea:	80 e0       	ldi	r24, 0x00	; 0
    45ec:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>
    CHB_LEAVE_CRIT();
    45f0:	8f e3       	ldi	r24, 0x3F	; 63
    45f2:	90 e0       	ldi	r25, 0x00	; 0
    45f4:	20 91 43 40 	lds	r18, 0x4043
    45f8:	fc 01       	movw	r30, r24
    45fa:	20 83       	st	Z, r18
    45fc:	78 94       	sei

    return val;
    45fe:	89 81       	ldd	r24, Y+1	; 0x01
}
    4600:	0f 90       	pop	r0
    4602:	0f 90       	pop	r0
    4604:	df 91       	pop	r29
    4606:	cf 91       	pop	r28
    4608:	08 95       	ret

0000460a <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    460a:	cf 93       	push	r28
    460c:	df 93       	push	r29
    460e:	00 d0       	rcall	.+0      	; 0x4610 <chb_reg_read16+0x6>
    4610:	0f 92       	push	r0
    4612:	cd b7       	in	r28, 0x3d	; 61
    4614:	de b7       	in	r29, 0x3e	; 62
    4616:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4618:	1a 82       	std	Y+2, r1	; 0x02
    461a:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    461c:	19 82       	std	Y+1, r1	; 0x01
    461e:	1d c0       	rjmp	.+58     	; 0x465a <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4620:	9c 81       	ldd	r25, Y+4	; 0x04
    4622:	89 81       	ldd	r24, Y+1	; 0x01
    4624:	89 0f       	add	r24, r25
    4626:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    462a:	88 2f       	mov	r24, r24
    462c:	90 e0       	ldi	r25, 0x00	; 0
    462e:	29 81       	ldd	r18, Y+1	; 0x01
    4630:	22 2f       	mov	r18, r18
    4632:	30 e0       	ldi	r19, 0x00	; 0
    4634:	22 0f       	add	r18, r18
    4636:	33 1f       	adc	r19, r19
    4638:	22 0f       	add	r18, r18
    463a:	33 1f       	adc	r19, r19
    463c:	22 0f       	add	r18, r18
    463e:	33 1f       	adc	r19, r19
    4640:	02 2e       	mov	r0, r18
    4642:	02 c0       	rjmp	.+4      	; 0x4648 <chb_reg_read16+0x3e>
    4644:	88 0f       	add	r24, r24
    4646:	99 1f       	adc	r25, r25
    4648:	0a 94       	dec	r0
    464a:	e2 f7       	brpl	.-8      	; 0x4644 <chb_reg_read16+0x3a>
    464c:	98 2f       	mov	r25, r24
    464e:	8c 81       	ldd	r24, Y+4	; 0x04
    4650:	89 2b       	or	r24, r25
    4652:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4654:	89 81       	ldd	r24, Y+1	; 0x01
    4656:	8f 5f       	subi	r24, 0xFF	; 255
    4658:	89 83       	std	Y+1, r24	; 0x01
    465a:	89 81       	ldd	r24, Y+1	; 0x01
    465c:	82 30       	cpi	r24, 0x02	; 2
    465e:	00 f3       	brcs	.-64     	; 0x4620 <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    4660:	8a 81       	ldd	r24, Y+2	; 0x02
    4662:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4664:	24 96       	adiw	r28, 0x04	; 4
    4666:	cd bf       	out	0x3d, r28	; 61
    4668:	de bf       	out	0x3e, r29	; 62
    466a:	df 91       	pop	r29
    466c:	cf 91       	pop	r28
    466e:	08 95       	ret

00004670 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    4670:	cf 93       	push	r28
    4672:	df 93       	push	r29
    4674:	00 d0       	rcall	.+0      	; 0x4676 <chb_reg_write+0x6>
    4676:	cd b7       	in	r28, 0x3d	; 61
    4678:	de b7       	in	r29, 0x3e	; 62
    467a:	8a 83       	std	Y+2, r24	; 0x02
    467c:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    467e:	8a 81       	ldd	r24, Y+2	; 0x02
    4680:	80 6c       	ori	r24, 0xC0	; 192
    4682:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4684:	8f e3       	ldi	r24, 0x3F	; 63
    4686:	90 e0       	ldi	r25, 0x00	; 0
    4688:	fc 01       	movw	r30, r24
    468a:	80 81       	ld	r24, Z
    468c:	80 93 43 40 	sts	0x4043, r24
    4690:	f8 94       	cli
    RadioCS(TRUE);
    4692:	81 e0       	ldi	r24, 0x01	; 1
    4694:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    4698:	8a 81       	ldd	r24, Y+2	; 0x02
    469a:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    469e:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    46a0:	8b 81       	ldd	r24, Y+3	; 0x03
    46a2:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    46a6:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    46a8:	80 e0       	ldi	r24, 0x00	; 0
    46aa:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>
    CHB_LEAVE_CRIT();
    46ae:	8f e3       	ldi	r24, 0x3F	; 63
    46b0:	90 e0       	ldi	r25, 0x00	; 0
    46b2:	20 91 43 40 	lds	r18, 0x4043
    46b6:	fc 01       	movw	r30, r24
    46b8:	20 83       	st	Z, r18
    46ba:	78 94       	sei
}
    46bc:	23 96       	adiw	r28, 0x03	; 3
    46be:	cd bf       	out	0x3d, r28	; 61
    46c0:	de bf       	out	0x3e, r29	; 62
    46c2:	df 91       	pop	r29
    46c4:	cf 91       	pop	r28
    46c6:	08 95       	ret

000046c8 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    46c8:	cf 93       	push	r28
    46ca:	df 93       	push	r29
    46cc:	00 d0       	rcall	.+0      	; 0x46ce <chb_reg_write16+0x6>
    46ce:	0f 92       	push	r0
    46d0:	cd b7       	in	r28, 0x3d	; 61
    46d2:	de b7       	in	r29, 0x3e	; 62
    46d4:	8a 83       	std	Y+2, r24	; 0x02
    46d6:	6b 83       	std	Y+3, r22	; 0x03
    46d8:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    46da:	19 82       	std	Y+1, r1	; 0x01
    46dc:	1d c0       	rjmp	.+58     	; 0x4718 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    46de:	9a 81       	ldd	r25, Y+2	; 0x02
    46e0:	89 81       	ldd	r24, Y+1	; 0x01
    46e2:	49 2f       	mov	r20, r25
    46e4:	48 0f       	add	r20, r24
    46e6:	89 81       	ldd	r24, Y+1	; 0x01
    46e8:	88 2f       	mov	r24, r24
    46ea:	90 e0       	ldi	r25, 0x00	; 0
    46ec:	9c 01       	movw	r18, r24
    46ee:	22 0f       	add	r18, r18
    46f0:	33 1f       	adc	r19, r19
    46f2:	22 0f       	add	r18, r18
    46f4:	33 1f       	adc	r19, r19
    46f6:	22 0f       	add	r18, r18
    46f8:	33 1f       	adc	r19, r19
    46fa:	8b 81       	ldd	r24, Y+3	; 0x03
    46fc:	9c 81       	ldd	r25, Y+4	; 0x04
    46fe:	02 c0       	rjmp	.+4      	; 0x4704 <chb_reg_write16+0x3c>
    4700:	96 95       	lsr	r25
    4702:	87 95       	ror	r24
    4704:	2a 95       	dec	r18
    4706:	e2 f7       	brpl	.-8      	; 0x4700 <chb_reg_write16+0x38>
    4708:	98 2f       	mov	r25, r24
    470a:	84 2f       	mov	r24, r20
    470c:	69 2f       	mov	r22, r25
    470e:	0e 94 38 23 	call	0x4670	; 0x4670 <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4712:	89 81       	ldd	r24, Y+1	; 0x01
    4714:	8f 5f       	subi	r24, 0xFF	; 255
    4716:	89 83       	std	Y+1, r24	; 0x01
    4718:	89 81       	ldd	r24, Y+1	; 0x01
    471a:	82 30       	cpi	r24, 0x02	; 2
    471c:	00 f3       	brcs	.-64     	; 0x46de <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    471e:	24 96       	adiw	r28, 0x04	; 4
    4720:	cd bf       	out	0x3d, r28	; 61
    4722:	de bf       	out	0x3e, r29	; 62
    4724:	df 91       	pop	r29
    4726:	cf 91       	pop	r28
    4728:	08 95       	ret

0000472a <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    472a:	cf 93       	push	r28
    472c:	df 93       	push	r29
    472e:	00 d0       	rcall	.+0      	; 0x4730 <chb_reg_write64+0x6>
    4730:	0f 92       	push	r0
    4732:	cd b7       	in	r28, 0x3d	; 61
    4734:	de b7       	in	r29, 0x3e	; 62
    4736:	8a 83       	std	Y+2, r24	; 0x02
    4738:	6b 83       	std	Y+3, r22	; 0x03
    473a:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    473c:	19 82       	std	Y+1, r1	; 0x01
    473e:	14 c0       	rjmp	.+40     	; 0x4768 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4740:	9a 81       	ldd	r25, Y+2	; 0x02
    4742:	89 81       	ldd	r24, Y+1	; 0x01
    4744:	49 2f       	mov	r20, r25
    4746:	48 0f       	add	r20, r24
    4748:	89 81       	ldd	r24, Y+1	; 0x01
    474a:	88 2f       	mov	r24, r24
    474c:	90 e0       	ldi	r25, 0x00	; 0
    474e:	2b 81       	ldd	r18, Y+3	; 0x03
    4750:	3c 81       	ldd	r19, Y+4	; 0x04
    4752:	82 0f       	add	r24, r18
    4754:	93 1f       	adc	r25, r19
    4756:	fc 01       	movw	r30, r24
    4758:	90 81       	ld	r25, Z
    475a:	84 2f       	mov	r24, r20
    475c:	69 2f       	mov	r22, r25
    475e:	0e 94 38 23 	call	0x4670	; 0x4670 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4762:	89 81       	ldd	r24, Y+1	; 0x01
    4764:	8f 5f       	subi	r24, 0xFF	; 255
    4766:	89 83       	std	Y+1, r24	; 0x01
    4768:	89 81       	ldd	r24, Y+1	; 0x01
    476a:	88 30       	cpi	r24, 0x08	; 8
    476c:	48 f3       	brcs	.-46     	; 0x4740 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    476e:	24 96       	adiw	r28, 0x04	; 4
    4770:	cd bf       	out	0x3d, r28	; 61
    4772:	de bf       	out	0x3e, r29	; 62
    4774:	df 91       	pop	r29
    4776:	cf 91       	pop	r28
    4778:	08 95       	ret

0000477a <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    477a:	cf 93       	push	r28
    477c:	df 93       	push	r29
    477e:	00 d0       	rcall	.+0      	; 0x4780 <chb_reg_read_mod_write+0x6>
    4780:	0f 92       	push	r0
    4782:	cd b7       	in	r28, 0x3d	; 61
    4784:	de b7       	in	r29, 0x3e	; 62
    4786:	8a 83       	std	Y+2, r24	; 0x02
    4788:	6b 83       	std	Y+3, r22	; 0x03
    478a:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    478c:	8a 81       	ldd	r24, Y+2	; 0x02
    478e:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    4792:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4794:	9b 81       	ldd	r25, Y+3	; 0x03
    4796:	8c 81       	ldd	r24, Y+4	; 0x04
    4798:	89 23       	and	r24, r25
    479a:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    479c:	8c 81       	ldd	r24, Y+4	; 0x04
    479e:	98 2f       	mov	r25, r24
    47a0:	90 95       	com	r25
    47a2:	89 81       	ldd	r24, Y+1	; 0x01
    47a4:	89 23       	and	r24, r25
    47a6:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    47a8:	99 81       	ldd	r25, Y+1	; 0x01
    47aa:	8b 81       	ldd	r24, Y+3	; 0x03
    47ac:	89 2b       	or	r24, r25
    47ae:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    47b0:	8a 81       	ldd	r24, Y+2	; 0x02
    47b2:	69 81       	ldd	r22, Y+1	; 0x01
    47b4:	0e 94 38 23 	call	0x4670	; 0x4670 <chb_reg_write>
}
    47b8:	24 96       	adiw	r28, 0x04	; 4
    47ba:	cd bf       	out	0x3d, r28	; 61
    47bc:	de bf       	out	0x3e, r29	; 62
    47be:	df 91       	pop	r29
    47c0:	cf 91       	pop	r28
    47c2:	08 95       	ret

000047c4 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    47c4:	cf 93       	push	r28
    47c6:	df 93       	push	r29
    47c8:	cd b7       	in	r28, 0x3d	; 61
    47ca:	de b7       	in	r29, 0x3e	; 62
    47cc:	28 97       	sbiw	r28, 0x08	; 8
    47ce:	cd bf       	out	0x3d, r28	; 61
    47d0:	de bf       	out	0x3e, r29	; 62
    47d2:	8b 83       	std	Y+3, r24	; 0x03
    47d4:	9c 83       	std	Y+4, r25	; 0x04
    47d6:	6d 83       	std	Y+5, r22	; 0x05
    47d8:	4e 83       	std	Y+6, r20	; 0x06
    47da:	5f 83       	std	Y+7, r21	; 0x07
    47dc:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    47de:	8d 81       	ldd	r24, Y+5	; 0x05
    47e0:	28 2f       	mov	r18, r24
    47e2:	30 e0       	ldi	r19, 0x00	; 0
    47e4:	88 85       	ldd	r24, Y+8	; 0x08
    47e6:	88 2f       	mov	r24, r24
    47e8:	90 e0       	ldi	r25, 0x00	; 0
    47ea:	82 0f       	add	r24, r18
    47ec:	93 1f       	adc	r25, r19
    47ee:	80 38       	cpi	r24, 0x80	; 128
    47f0:	91 05       	cpc	r25, r1
    47f2:	0c f0       	brlt	.+2      	; 0x47f6 <chb_frame_write+0x32>
    47f4:	45 c0       	rjmp	.+138    	; 0x4880 <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    47f6:	8f e3       	ldi	r24, 0x3F	; 63
    47f8:	90 e0       	ldi	r25, 0x00	; 0
    47fa:	fc 01       	movw	r30, r24
    47fc:	80 81       	ld	r24, Z
    47fe:	80 93 43 40 	sts	0x4043, r24
    4802:	f8 94       	cli
    RadioCS(TRUE); 
    4804:	81 e0       	ldi	r24, 0x01	; 1
    4806:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    480a:	80 e6       	ldi	r24, 0x60	; 96
    480c:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    4810:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4812:	19 82       	std	Y+1, r1	; 0x01
    4814:	10 c0       	rjmp	.+32     	; 0x4836 <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4816:	8b 81       	ldd	r24, Y+3	; 0x03
    4818:	9c 81       	ldd	r25, Y+4	; 0x04
    481a:	fc 01       	movw	r30, r24
    481c:	20 81       	ld	r18, Z
    481e:	8b 81       	ldd	r24, Y+3	; 0x03
    4820:	9c 81       	ldd	r25, Y+4	; 0x04
    4822:	01 96       	adiw	r24, 0x01	; 1
    4824:	8b 83       	std	Y+3, r24	; 0x03
    4826:	9c 83       	std	Y+4, r25	; 0x04
    4828:	82 2f       	mov	r24, r18
    482a:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    482e:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4830:	89 81       	ldd	r24, Y+1	; 0x01
    4832:	8f 5f       	subi	r24, 0xFF	; 255
    4834:	89 83       	std	Y+1, r24	; 0x01
    4836:	99 81       	ldd	r25, Y+1	; 0x01
    4838:	8d 81       	ldd	r24, Y+5	; 0x05
    483a:	98 17       	cp	r25, r24
    483c:	60 f3       	brcs	.-40     	; 0x4816 <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    483e:	19 82       	std	Y+1, r1	; 0x01
    4840:	10 c0       	rjmp	.+32     	; 0x4862 <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4842:	8e 81       	ldd	r24, Y+6	; 0x06
    4844:	9f 81       	ldd	r25, Y+7	; 0x07
    4846:	fc 01       	movw	r30, r24
    4848:	20 81       	ld	r18, Z
    484a:	8e 81       	ldd	r24, Y+6	; 0x06
    484c:	9f 81       	ldd	r25, Y+7	; 0x07
    484e:	01 96       	adiw	r24, 0x01	; 1
    4850:	8e 83       	std	Y+6, r24	; 0x06
    4852:	9f 83       	std	Y+7, r25	; 0x07
    4854:	82 2f       	mov	r24, r18
    4856:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    485a:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    485c:	89 81       	ldd	r24, Y+1	; 0x01
    485e:	8f 5f       	subi	r24, 0xFF	; 255
    4860:	89 83       	std	Y+1, r24	; 0x01
    4862:	99 81       	ldd	r25, Y+1	; 0x01
    4864:	88 85       	ldd	r24, Y+8	; 0x08
    4866:	98 17       	cp	r25, r24
    4868:	60 f3       	brcs	.-40     	; 0x4842 <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    486a:	80 e0       	ldi	r24, 0x00	; 0
    486c:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>
    CHB_LEAVE_CRIT();
    4870:	8f e3       	ldi	r24, 0x3F	; 63
    4872:	90 e0       	ldi	r25, 0x00	; 0
    4874:	20 91 43 40 	lds	r18, 0x4043
    4878:	fc 01       	movw	r30, r24
    487a:	20 83       	st	Z, r18
    487c:	78 94       	sei
    487e:	01 c0       	rjmp	.+2      	; 0x4882 <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4880:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4882:	28 96       	adiw	r28, 0x08	; 8
    4884:	cd bf       	out	0x3d, r28	; 61
    4886:	de bf       	out	0x3e, r29	; 62
    4888:	df 91       	pop	r29
    488a:	cf 91       	pop	r28
    488c:	08 95       	ret

0000488e <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    488e:	0f 93       	push	r16
    4890:	1f 93       	push	r17
    4892:	cf 93       	push	r28
    4894:	df 93       	push	r29
    4896:	cd b7       	in	r28, 0x3d	; 61
    4898:	de b7       	in	r29, 0x3e	; 62
    489a:	e7 97       	sbiw	r28, 0x37	; 55
    489c:	cd bf       	out	0x3d, r28	; 61
    489e:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    48a0:	8f e3       	ldi	r24, 0x3F	; 63
    48a2:	90 e0       	ldi	r25, 0x00	; 0
    48a4:	fc 01       	movw	r30, r24
    48a6:	80 81       	ld	r24, Z
    48a8:	80 93 43 40 	sts	0x4043, r24
    48ac:	f8 94       	cli
    RadioCS(TRUE);
    48ae:	81 e0       	ldi	r24, 0x01	; 1
    48b0:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    48b4:	80 e2       	ldi	r24, 0x20	; 32
    48b6:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    len = SPID_write(0);
    48ba:	80 e0       	ldi	r24, 0x00	; 0
    48bc:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    48c0:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    48c2:	8a 81       	ldd	r24, Y+2	; 0x02
    48c4:	83 30       	cpi	r24, 0x03	; 3
    48c6:	08 f4       	brcc	.+2      	; 0x48ca <chb_frame_read+0x3c>
    48c8:	66 c0       	rjmp	.+204    	; 0x4996 <chb_frame_read+0x108>
    48ca:	8a 81       	ldd	r24, Y+2	; 0x02
    48cc:	88 23       	and	r24, r24
    48ce:	0c f4       	brge	.+2      	; 0x48d2 <chb_frame_read+0x44>
    48d0:	62 c0       	rjmp	.+196    	; 0x4996 <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    48d2:	8a 81       	ldd	r24, Y+2	; 0x02
    48d4:	08 2f       	mov	r16, r24
    48d6:	10 e0       	ldi	r17, 0x00	; 0
    48d8:	0e 94 cb 20 	call	0x4196	; 0x4196 <chb_buf_get_len>
    48dc:	88 2f       	mov	r24, r24
    48de:	90 e0       	ldi	r25, 0x00	; 0
    48e0:	20 e8       	ldi	r18, 0x80	; 128
    48e2:	30 e0       	ldi	r19, 0x00	; 0
    48e4:	a9 01       	movw	r20, r18
    48e6:	48 1b       	sub	r20, r24
    48e8:	59 0b       	sbc	r21, r25
    48ea:	ca 01       	movw	r24, r20
    48ec:	08 17       	cp	r16, r24
    48ee:	19 07       	cpc	r17, r25
    48f0:	f4 f4       	brge	.+60     	; 0x492e <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    48f2:	8a 81       	ldd	r24, Y+2	; 0x02
    48f4:	0e 94 83 20 	call	0x4106	; 0x4106 <chb_buf_write>
            
            for (i=0; i<len; i++)
    48f8:	19 82       	std	Y+1, r1	; 0x01
    48fa:	0a c0       	rjmp	.+20     	; 0x4910 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    48fc:	80 e0       	ldi	r24, 0x00	; 0
    48fe:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    4902:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4904:	8b 81       	ldd	r24, Y+3	; 0x03
    4906:	0e 94 83 20 	call	0x4106	; 0x4106 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    490a:	89 81       	ldd	r24, Y+1	; 0x01
    490c:	8f 5f       	subi	r24, 0xFF	; 255
    490e:	89 83       	std	Y+1, r24	; 0x01
    4910:	99 81       	ldd	r25, Y+1	; 0x01
    4912:	8a 81       	ldd	r24, Y+2	; 0x02
    4914:	98 17       	cp	r25, r24
    4916:	90 f3       	brcs	.-28     	; 0x48fc <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4918:	80 e8       	ldi	r24, 0x80	; 128
    491a:	96 e0       	ldi	r25, 0x06	; 6
    491c:	24 e0       	ldi	r18, 0x04	; 4
    491e:	fc 01       	movw	r30, r24
    4920:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4922:	80 e8       	ldi	r24, 0x80	; 128
    4924:	96 e0       	ldi	r25, 0x06	; 6
    4926:	24 e0       	ldi	r18, 0x04	; 4
    4928:	fc 01       	movw	r30, r24
    492a:	26 83       	std	Z+6, r18	; 0x06
    492c:	34 c0       	rjmp	.+104    	; 0x4996 <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    492e:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <chb_get_pcb>
    4932:	8c 83       	std	Y+4, r24	; 0x04
    4934:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4936:	19 82       	std	Y+1, r1	; 0x01
    4938:	07 c0       	rjmp	.+14     	; 0x4948 <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    493a:	80 e0       	ldi	r24, 0x00	; 0
    493c:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    4940:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4942:	89 81       	ldd	r24, Y+1	; 0x01
    4944:	8f 5f       	subi	r24, 0xFF	; 255
    4946:	89 83       	std	Y+1, r24	; 0x01
    4948:	99 81       	ldd	r25, Y+1	; 0x01
    494a:	8a 81       	ldd	r24, Y+2	; 0x02
    494c:	98 17       	cp	r25, r24
    494e:	a8 f3       	brcs	.-22     	; 0x493a <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4950:	8c 81       	ldd	r24, Y+4	; 0x04
    4952:	9d 81       	ldd	r25, Y+5	; 0x05
    4954:	fc 01       	movw	r30, r24
    4956:	85 85       	ldd	r24, Z+13	; 0x0d
    4958:	96 85       	ldd	r25, Z+14	; 0x0e
    495a:	9c 01       	movw	r18, r24
    495c:	2f 5f       	subi	r18, 0xFF	; 255
    495e:	3f 4f       	sbci	r19, 0xFF	; 255
    4960:	8c 81       	ldd	r24, Y+4	; 0x04
    4962:	9d 81       	ldd	r25, Y+5	; 0x05
    4964:	fc 01       	movw	r30, r24
    4966:	25 87       	std	Z+13, r18	; 0x0d
    4968:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    496a:	ce 01       	movw	r24, r28
    496c:	06 96       	adiw	r24, 0x06	; 6
    496e:	28 ee       	ldi	r18, 0xE8	; 232
    4970:	31 e0       	ldi	r19, 0x01	; 1
    4972:	b9 01       	movw	r22, r18
    4974:	0e 94 58 62 	call	0xc4b0	; 0xc4b0 <strcpy_P>
            printf(buf);
    4978:	0f 92       	push	r0
    497a:	0f 92       	push	r0
    497c:	8d b7       	in	r24, 0x3d	; 61
    497e:	9e b7       	in	r25, 0x3e	; 62
    4980:	01 96       	adiw	r24, 0x01	; 1
    4982:	9e 01       	movw	r18, r28
    4984:	2a 5f       	subi	r18, 0xFA	; 250
    4986:	3f 4f       	sbci	r19, 0xFF	; 255
    4988:	fc 01       	movw	r30, r24
    498a:	20 83       	st	Z, r18
    498c:	31 83       	std	Z+1, r19	; 0x01
    498e:	0e 94 b4 62 	call	0xc568	; 0xc568 <printf>
    4992:	0f 90       	pop	r0
    4994:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4996:	80 e0       	ldi	r24, 0x00	; 0
    4998:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>
    CHB_LEAVE_CRIT();
    499c:	8f e3       	ldi	r24, 0x3F	; 63
    499e:	90 e0       	ldi	r25, 0x00	; 0
    49a0:	20 91 43 40 	lds	r18, 0x4043
    49a4:	fc 01       	movw	r30, r24
    49a6:	20 83       	st	Z, r18
    49a8:	78 94       	sei
}
    49aa:	e7 96       	adiw	r28, 0x37	; 55
    49ac:	cd bf       	out	0x3d, r28	; 61
    49ae:	de bf       	out	0x3e, r29	; 62
    49b0:	df 91       	pop	r29
    49b2:	cf 91       	pop	r28
    49b4:	1f 91       	pop	r17
    49b6:	0f 91       	pop	r16
    49b8:	08 95       	ret

000049ba <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    49ba:	cf 93       	push	r28
    49bc:	df 93       	push	r29
    49be:	0f 92       	push	r0
    49c0:	cd b7       	in	r28, 0x3d	; 61
    49c2:	de b7       	in	r29, 0x3e	; 62
    49c4:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    49c6:	89 81       	ldd	r24, Y+1	; 0x01
    49c8:	88 2f       	mov	r24, r24
    49ca:	90 e0       	ldi	r25, 0x00	; 0
    49cc:	81 30       	cpi	r24, 0x01	; 1
    49ce:	91 05       	cpc	r25, r1
    49d0:	c1 f0       	breq	.+48     	; 0x4a02 <chb_set_mode+0x48>
    49d2:	82 30       	cpi	r24, 0x02	; 2
    49d4:	91 05       	cpc	r25, r1
    49d6:	1c f4       	brge	.+6      	; 0x49de <chb_set_mode+0x24>
    49d8:	00 97       	sbiw	r24, 0x00	; 0
    49da:	41 f0       	breq	.+16     	; 0x49ec <chb_set_mode+0x32>
    49dc:	33 c0       	rjmp	.+102    	; 0x4a44 <chb_set_mode+0x8a>
    49de:	82 30       	cpi	r24, 0x02	; 2
    49e0:	91 05       	cpc	r25, r1
    49e2:	d1 f0       	breq	.+52     	; 0x4a18 <chb_set_mode+0x5e>
    49e4:	83 30       	cpi	r24, 0x03	; 3
    49e6:	91 05       	cpc	r25, r1
    49e8:	11 f1       	breq	.+68     	; 0x4a2e <chb_set_mode+0x74>
    49ea:	2c c0       	rjmp	.+88     	; 0x4a44 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    49ec:	8c e0       	ldi	r24, 0x0C	; 12
    49ee:	68 e0       	ldi	r22, 0x08	; 8
    49f0:	4f e3       	ldi	r20, 0x3F	; 63
    49f2:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    49f6:	86 e1       	ldi	r24, 0x16	; 22
    49f8:	62 e0       	ldi	r22, 0x02	; 2
    49fa:	43 e0       	ldi	r20, 0x03	; 3
    49fc:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        break;
    4a00:	21 c0       	rjmp	.+66     	; 0x4a44 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4a02:	8c e0       	ldi	r24, 0x0C	; 12
    4a04:	6c e0       	ldi	r22, 0x0C	; 12
    4a06:	4f e3       	ldi	r20, 0x3F	; 63
    4a08:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a0c:	86 e1       	ldi	r24, 0x16	; 22
    4a0e:	62 e0       	ldi	r22, 0x02	; 2
    4a10:	43 e0       	ldi	r20, 0x03	; 3
    4a12:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        break;
    4a16:	16 c0       	rjmp	.+44     	; 0x4a44 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4a18:	8c e0       	ldi	r24, 0x0C	; 12
    4a1a:	6c e1       	ldi	r22, 0x1C	; 28
    4a1c:	4f e3       	ldi	r20, 0x3F	; 63
    4a1e:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a22:	86 e1       	ldi	r24, 0x16	; 22
    4a24:	62 e0       	ldi	r22, 0x02	; 2
    4a26:	43 e0       	ldi	r20, 0x03	; 3
    4a28:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        break;
    4a2c:	0b c0       	rjmp	.+22     	; 0x4a44 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4a2e:	8c e0       	ldi	r24, 0x0C	; 12
    4a30:	60 e0       	ldi	r22, 0x00	; 0
    4a32:	4f e3       	ldi	r20, 0x3F	; 63
    4a34:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4a38:	86 e1       	ldi	r24, 0x16	; 22
    4a3a:	63 e0       	ldi	r22, 0x03	; 3
    4a3c:	43 e0       	ldi	r20, 0x03	; 3
    4a3e:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
        break;
    4a42:	00 00       	nop
    }
}
    4a44:	0f 90       	pop	r0
    4a46:	df 91       	pop	r29
    4a48:	cf 91       	pop	r28
    4a4a:	08 95       	ret

00004a4c <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4a4c:	0f 93       	push	r16
    4a4e:	1f 93       	push	r17
    4a50:	cf 93       	push	r28
    4a52:	df 93       	push	r29
    4a54:	cd b7       	in	r28, 0x3d	; 61
    4a56:	de b7       	in	r29, 0x3e	; 62
    4a58:	6a 97       	sbiw	r28, 0x1a	; 26
    4a5a:	cd bf       	out	0x3d, r28	; 61
    4a5c:	de bf       	out	0x3e, r29	; 62
    4a5e:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4a60:	88 e0       	ldi	r24, 0x08	; 8
    4a62:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4a64:	4f e1       	ldi	r20, 0x1F	; 31
    4a66:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4a6a:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <chb_get_state>
    4a6e:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4a70:	89 81       	ldd	r24, Y+1	; 0x01
    4a72:	86 30       	cpi	r24, 0x06	; 6
    4a74:	21 f0       	breq	.+8      	; 0x4a7e <chb_set_channel+0x32>
    4a76:	89 81       	ldd	r24, Y+1	; 0x01
    4a78:	89 30       	cpi	r24, 0x09	; 9
    4a7a:	09 f0       	breq	.+2      	; 0x4a7e <chb_set_channel+0x32>
    4a7c:	d5 c0       	rjmp	.+426    	; 0x4c28 <chb_set_channel+0x1dc>
    4a7e:	80 e0       	ldi	r24, 0x00	; 0
    4a80:	90 e0       	ldi	r25, 0x00	; 0
    4a82:	ac ed       	ldi	r26, 0xDC	; 220
    4a84:	b2 e4       	ldi	r27, 0x42	; 66
    4a86:	8a 83       	std	Y+2, r24	; 0x02
    4a88:	9b 83       	std	Y+3, r25	; 0x03
    4a8a:	ac 83       	std	Y+4, r26	; 0x04
    4a8c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4a8e:	6a 81       	ldd	r22, Y+2	; 0x02
    4a90:	7b 81       	ldd	r23, Y+3	; 0x03
    4a92:	8c 81       	ldd	r24, Y+4	; 0x04
    4a94:	9d 81       	ldd	r25, Y+5	; 0x05
    4a96:	2b ea       	ldi	r18, 0xAB	; 171
    4a98:	3a ea       	ldi	r19, 0xAA	; 170
    4a9a:	4a ea       	ldi	r20, 0xAA	; 170
    4a9c:	5e e3       	ldi	r21, 0x3E	; 62
    4a9e:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4aa2:	dc 01       	movw	r26, r24
    4aa4:	cb 01       	movw	r24, r22
    4aa6:	8e 83       	std	Y+6, r24	; 0x06
    4aa8:	9f 83       	std	Y+7, r25	; 0x07
    4aaa:	a8 87       	std	Y+8, r26	; 0x08
    4aac:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4aae:	11 e0       	ldi	r17, 0x01	; 1
    4ab0:	6e 81       	ldd	r22, Y+6	; 0x06
    4ab2:	7f 81       	ldd	r23, Y+7	; 0x07
    4ab4:	88 85       	ldd	r24, Y+8	; 0x08
    4ab6:	99 85       	ldd	r25, Y+9	; 0x09
    4ab8:	20 e0       	ldi	r18, 0x00	; 0
    4aba:	30 e0       	ldi	r19, 0x00	; 0
    4abc:	40 e8       	ldi	r20, 0x80	; 128
    4abe:	5f e3       	ldi	r21, 0x3F	; 63
    4ac0:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4ac4:	88 23       	and	r24, r24
    4ac6:	0c f0       	brlt	.+2      	; 0x4aca <chb_set_channel+0x7e>
    4ac8:	10 e0       	ldi	r17, 0x00	; 0
    4aca:	11 23       	and	r17, r17
    4acc:	19 f0       	breq	.+6      	; 0x4ad4 <chb_set_channel+0x88>
		__ticks = 1;
    4ace:	81 e0       	ldi	r24, 0x01	; 1
    4ad0:	8a 87       	std	Y+10, r24	; 0x0a
    4ad2:	a3 c0       	rjmp	.+326    	; 0x4c1a <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4ad4:	11 e0       	ldi	r17, 0x01	; 1
    4ad6:	6e 81       	ldd	r22, Y+6	; 0x06
    4ad8:	7f 81       	ldd	r23, Y+7	; 0x07
    4ada:	88 85       	ldd	r24, Y+8	; 0x08
    4adc:	99 85       	ldd	r25, Y+9	; 0x09
    4ade:	20 e0       	ldi	r18, 0x00	; 0
    4ae0:	30 e0       	ldi	r19, 0x00	; 0
    4ae2:	4f e7       	ldi	r20, 0x7F	; 127
    4ae4:	53 e4       	ldi	r21, 0x43	; 67
    4ae6:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4aea:	18 16       	cp	r1, r24
    4aec:	0c f0       	brlt	.+2      	; 0x4af0 <chb_set_channel+0xa4>
    4aee:	10 e0       	ldi	r17, 0x00	; 0
    4af0:	11 23       	and	r17, r17
    4af2:	09 f4       	brne	.+2      	; 0x4af6 <chb_set_channel+0xaa>
    4af4:	89 c0       	rjmp	.+274    	; 0x4c08 <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4af6:	6a 81       	ldd	r22, Y+2	; 0x02
    4af8:	7b 81       	ldd	r23, Y+3	; 0x03
    4afa:	8c 81       	ldd	r24, Y+4	; 0x04
    4afc:	9d 81       	ldd	r25, Y+5	; 0x05
    4afe:	20 e0       	ldi	r18, 0x00	; 0
    4b00:	30 e0       	ldi	r19, 0x00	; 0
    4b02:	4a e7       	ldi	r20, 0x7A	; 122
    4b04:	54 e4       	ldi	r21, 0x44	; 68
    4b06:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    4b0a:	dc 01       	movw	r26, r24
    4b0c:	cb 01       	movw	r24, r22
    4b0e:	8b 87       	std	Y+11, r24	; 0x0b
    4b10:	9c 87       	std	Y+12, r25	; 0x0c
    4b12:	ad 87       	std	Y+13, r26	; 0x0d
    4b14:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4b16:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b18:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b1e:	20 e0       	ldi	r18, 0x00	; 0
    4b20:	30 e0       	ldi	r19, 0x00	; 0
    4b22:	4a e7       	ldi	r20, 0x7A	; 122
    4b24:	53 e4       	ldi	r21, 0x43	; 67
    4b26:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4b2a:	dc 01       	movw	r26, r24
    4b2c:	cb 01       	movw	r24, r22
    4b2e:	8f 87       	std	Y+15, r24	; 0x0f
    4b30:	98 8b       	std	Y+16, r25	; 0x10
    4b32:	a9 8b       	std	Y+17, r26	; 0x11
    4b34:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4b36:	11 e0       	ldi	r17, 0x01	; 1
    4b38:	6f 85       	ldd	r22, Y+15	; 0x0f
    4b3a:	78 89       	ldd	r23, Y+16	; 0x10
    4b3c:	89 89       	ldd	r24, Y+17	; 0x11
    4b3e:	9a 89       	ldd	r25, Y+18	; 0x12
    4b40:	20 e0       	ldi	r18, 0x00	; 0
    4b42:	30 e0       	ldi	r19, 0x00	; 0
    4b44:	40 e8       	ldi	r20, 0x80	; 128
    4b46:	5f e3       	ldi	r21, 0x3F	; 63
    4b48:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4b4c:	88 23       	and	r24, r24
    4b4e:	0c f0       	brlt	.+2      	; 0x4b52 <chb_set_channel+0x106>
    4b50:	10 e0       	ldi	r17, 0x00	; 0
    4b52:	11 23       	and	r17, r17
    4b54:	29 f0       	breq	.+10     	; 0x4b60 <chb_set_channel+0x114>
		__ticks = 1;
    4b56:	81 e0       	ldi	r24, 0x01	; 1
    4b58:	90 e0       	ldi	r25, 0x00	; 0
    4b5a:	8b 8b       	std	Y+19, r24	; 0x13
    4b5c:	9c 8b       	std	Y+20, r25	; 0x14
    4b5e:	46 c0       	rjmp	.+140    	; 0x4bec <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4b60:	11 e0       	ldi	r17, 0x01	; 1
    4b62:	6f 85       	ldd	r22, Y+15	; 0x0f
    4b64:	78 89       	ldd	r23, Y+16	; 0x10
    4b66:	89 89       	ldd	r24, Y+17	; 0x11
    4b68:	9a 89       	ldd	r25, Y+18	; 0x12
    4b6a:	20 e0       	ldi	r18, 0x00	; 0
    4b6c:	3f ef       	ldi	r19, 0xFF	; 255
    4b6e:	4f e7       	ldi	r20, 0x7F	; 127
    4b70:	57 e4       	ldi	r21, 0x47	; 71
    4b72:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4b76:	18 16       	cp	r1, r24
    4b78:	0c f0       	brlt	.+2      	; 0x4b7c <chb_set_channel+0x130>
    4b7a:	10 e0       	ldi	r17, 0x00	; 0
    4b7c:	11 23       	and	r17, r17
    4b7e:	61 f1       	breq	.+88     	; 0x4bd8 <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4b80:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b82:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b84:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b86:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b88:	20 e0       	ldi	r18, 0x00	; 0
    4b8a:	30 e0       	ldi	r19, 0x00	; 0
    4b8c:	40 e2       	ldi	r20, 0x20	; 32
    4b8e:	51 e4       	ldi	r21, 0x41	; 65
    4b90:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4b94:	dc 01       	movw	r26, r24
    4b96:	cb 01       	movw	r24, r22
    4b98:	bc 01       	movw	r22, r24
    4b9a:	cd 01       	movw	r24, r26
    4b9c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4ba0:	dc 01       	movw	r26, r24
    4ba2:	cb 01       	movw	r24, r22
    4ba4:	8b 8b       	std	Y+19, r24	; 0x13
    4ba6:	9c 8b       	std	Y+20, r25	; 0x14
    4ba8:	12 c0       	rjmp	.+36     	; 0x4bce <chb_set_channel+0x182>
    4baa:	89 e1       	ldi	r24, 0x19	; 25
    4bac:	90 e0       	ldi	r25, 0x00	; 0
    4bae:	8d 8b       	std	Y+21, r24	; 0x15
    4bb0:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4bb2:	8d 89       	ldd	r24, Y+21	; 0x15
    4bb4:	9e 89       	ldd	r25, Y+22	; 0x16
    4bb6:	8c 01       	movw	r16, r24
    4bb8:	c8 01       	movw	r24, r16
    4bba:	01 97       	sbiw	r24, 0x01	; 1
    4bbc:	f1 f7       	brne	.-4      	; 0x4bba <chb_set_channel+0x16e>
    4bbe:	8c 01       	movw	r16, r24
    4bc0:	0d 8b       	std	Y+21, r16	; 0x15
    4bc2:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4bc4:	8b 89       	ldd	r24, Y+19	; 0x13
    4bc6:	9c 89       	ldd	r25, Y+20	; 0x14
    4bc8:	01 97       	sbiw	r24, 0x01	; 1
    4bca:	8b 8b       	std	Y+19, r24	; 0x13
    4bcc:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4bce:	8b 89       	ldd	r24, Y+19	; 0x13
    4bd0:	9c 89       	ldd	r25, Y+20	; 0x14
    4bd2:	00 97       	sbiw	r24, 0x00	; 0
    4bd4:	51 f7       	brne	.-44     	; 0x4baa <chb_set_channel+0x15e>
    4bd6:	28 c0       	rjmp	.+80     	; 0x4c28 <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4bd8:	6f 85       	ldd	r22, Y+15	; 0x0f
    4bda:	78 89       	ldd	r23, Y+16	; 0x10
    4bdc:	89 89       	ldd	r24, Y+17	; 0x11
    4bde:	9a 89       	ldd	r25, Y+18	; 0x12
    4be0:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4be4:	dc 01       	movw	r26, r24
    4be6:	cb 01       	movw	r24, r22
    4be8:	8b 8b       	std	Y+19, r24	; 0x13
    4bea:	9c 8b       	std	Y+20, r25	; 0x14
    4bec:	8b 89       	ldd	r24, Y+19	; 0x13
    4bee:	9c 89       	ldd	r25, Y+20	; 0x14
    4bf0:	8f 8b       	std	Y+23, r24	; 0x17
    4bf2:	98 8f       	std	Y+24, r25	; 0x18
    4bf4:	8f 89       	ldd	r24, Y+23	; 0x17
    4bf6:	98 8d       	ldd	r25, Y+24	; 0x18
    4bf8:	8c 01       	movw	r16, r24
    4bfa:	c8 01       	movw	r24, r16
    4bfc:	01 97       	sbiw	r24, 0x01	; 1
    4bfe:	f1 f7       	brne	.-4      	; 0x4bfc <chb_set_channel+0x1b0>
    4c00:	8c 01       	movw	r16, r24
    4c02:	0f 8b       	std	Y+23, r16	; 0x17
    4c04:	18 8f       	std	Y+24, r17	; 0x18
    4c06:	10 c0       	rjmp	.+32     	; 0x4c28 <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4c08:	6e 81       	ldd	r22, Y+6	; 0x06
    4c0a:	7f 81       	ldd	r23, Y+7	; 0x07
    4c0c:	88 85       	ldd	r24, Y+8	; 0x08
    4c0e:	99 85       	ldd	r25, Y+9	; 0x09
    4c10:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4c14:	dc 01       	movw	r26, r24
    4c16:	cb 01       	movw	r24, r22
    4c18:	8a 87       	std	Y+10, r24	; 0x0a
    4c1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c1c:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4c1e:	89 8d       	ldd	r24, Y+25	; 0x19
    4c20:	18 2f       	mov	r17, r24
    4c22:	1a 95       	dec	r17
    4c24:	f1 f7       	brne	.-4      	; 0x4c22 <chb_set_channel+0x1d6>
    4c26:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4c28:	88 e0       	ldi	r24, 0x08	; 8
    4c2a:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    4c2e:	88 2f       	mov	r24, r24
    4c30:	90 e0       	ldi	r25, 0x00	; 0
    4c32:	9c 01       	movw	r18, r24
    4c34:	2f 71       	andi	r18, 0x1F	; 31
    4c36:	30 70       	andi	r19, 0x00	; 0
    4c38:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c3a:	88 2f       	mov	r24, r24
    4c3c:	90 e0       	ldi	r25, 0x00	; 0
    4c3e:	28 17       	cp	r18, r24
    4c40:	39 07       	cpc	r19, r25
    4c42:	11 f4       	brne	.+4      	; 0x4c48 <chb_set_channel+0x1fc>
    4c44:	80 e4       	ldi	r24, 0x40	; 64
    4c46:	01 c0       	rjmp	.+2      	; 0x4c4a <chb_set_channel+0x1fe>
    4c48:	83 e4       	ldi	r24, 0x43	; 67
}
    4c4a:	6a 96       	adiw	r28, 0x1a	; 26
    4c4c:	cd bf       	out	0x3d, r28	; 61
    4c4e:	de bf       	out	0x3e, r29	; 62
    4c50:	df 91       	pop	r29
    4c52:	cf 91       	pop	r28
    4c54:	1f 91       	pop	r17
    4c56:	0f 91       	pop	r16
    4c58:	08 95       	ret

00004c5a <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4c5a:	cf 93       	push	r28
    4c5c:	df 93       	push	r29
    4c5e:	0f 92       	push	r0
    4c60:	cd b7       	in	r28, 0x3d	; 61
    4c62:	de b7       	in	r29, 0x3e	; 62
    4c64:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4c66:	85 e0       	ldi	r24, 0x05	; 5
    4c68:	69 81       	ldd	r22, Y+1	; 0x01
    4c6a:	0e 94 38 23 	call	0x4670	; 0x4670 <chb_reg_write>
}
    4c6e:	0f 90       	pop	r0
    4c70:	df 91       	pop	r29
    4c72:	cf 91       	pop	r28
    4c74:	08 95       	ret

00004c76 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4c76:	0f 93       	push	r16
    4c78:	1f 93       	push	r17
    4c7a:	cf 93       	push	r28
    4c7c:	df 93       	push	r29
    4c7e:	cd b7       	in	r28, 0x3d	; 61
    4c80:	de b7       	in	r29, 0x3e	; 62
    4c82:	c2 56       	subi	r28, 0x62	; 98
    4c84:	d0 40       	sbci	r29, 0x00	; 0
    4c86:	cd bf       	out	0x3d, r28	; 61
    4c88:	de bf       	out	0x3e, r29	; 62
    4c8a:	9e 01       	movw	r18, r28
    4c8c:	2e 59       	subi	r18, 0x9E	; 158
    4c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    4c90:	f9 01       	movw	r30, r18
    4c92:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4c94:	84 e6       	ldi	r24, 0x64	; 100
    4c96:	96 e0       	ldi	r25, 0x06	; 6
    4c98:	fc 01       	movw	r30, r24
    4c9a:	80 81       	ld	r24, Z
    4c9c:	88 2f       	mov	r24, r24
    4c9e:	90 e0       	ldi	r25, 0x00	; 0
    4ca0:	82 70       	andi	r24, 0x02	; 2
    4ca2:	90 70       	andi	r25, 0x00	; 0
    4ca4:	00 97       	sbiw	r24, 0x00	; 0
    4ca6:	11 f0       	breq	.+4      	; 0x4cac <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4ca8:	84 e4       	ldi	r24, 0x44	; 68
    4caa:	91 c4       	rjmp	.+2338   	; 0x55ce <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4cac:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <chb_get_state>
    4cb0:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4cb2:	89 81       	ldd	r24, Y+1	; 0x01
    4cb4:	82 31       	cpi	r24, 0x12	; 18
    4cb6:	49 f0       	breq	.+18     	; 0x4cca <chb_set_state+0x54>
    4cb8:	89 81       	ldd	r24, Y+1	; 0x01
    4cba:	81 31       	cpi	r24, 0x11	; 17
    4cbc:	31 f0       	breq	.+12     	; 0x4cca <chb_set_state+0x54>
    4cbe:	89 81       	ldd	r24, Y+1	; 0x01
    4cc0:	81 30       	cpi	r24, 0x01	; 1
    4cc2:	19 f0       	breq	.+6      	; 0x4cca <chb_set_state+0x54>
    4cc4:	89 81       	ldd	r24, Y+1	; 0x01
    4cc6:	82 30       	cpi	r24, 0x02	; 2
    4cc8:	39 f4       	brne	.+14     	; 0x4cd8 <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4cca:	00 00       	nop
    4ccc:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <chb_get_state>
    4cd0:	98 2f       	mov	r25, r24
    4cd2:	89 81       	ldd	r24, Y+1	; 0x01
    4cd4:	98 17       	cp	r25, r24
    4cd6:	d1 f3       	breq	.-12     	; 0x4ccc <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4cd8:	ce 01       	movw	r24, r28
    4cda:	8e 59       	subi	r24, 0x9E	; 158
    4cdc:	9f 4f       	sbci	r25, 0xFF	; 255
    4cde:	fc 01       	movw	r30, r24
    4ce0:	80 81       	ld	r24, Z
    4ce2:	88 2f       	mov	r24, r24
    4ce4:	90 e0       	ldi	r25, 0x00	; 0
    4ce6:	86 31       	cpi	r24, 0x16	; 22
    4ce8:	91 05       	cpc	r25, r1
    4cea:	09 f4       	brne	.+2      	; 0x4cee <chb_set_state+0x78>
    4cec:	cd c1       	rjmp	.+922    	; 0x5088 <chb_set_state+0x412>
    4cee:	89 31       	cpi	r24, 0x19	; 25
    4cf0:	91 05       	cpc	r25, r1
    4cf2:	09 f4       	brne	.+2      	; 0x4cf6 <chb_set_state+0x80>
    4cf4:	e9 c0       	rjmp	.+466    	; 0x4ec8 <chb_set_state+0x252>
    4cf6:	88 30       	cpi	r24, 0x08	; 8
    4cf8:	91 05       	cpc	r25, r1
    4cfa:	09 f0       	breq	.+2      	; 0x4cfe <chb_set_state+0x88>
    4cfc:	f7 c2       	rjmp	.+1518   	; 0x52ec <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4cfe:	84 e6       	ldi	r24, 0x64	; 100
    4d00:	96 e0       	ldi	r25, 0x06	; 6
    4d02:	24 e6       	ldi	r18, 0x64	; 100
    4d04:	36 e0       	ldi	r19, 0x06	; 6
    4d06:	f9 01       	movw	r30, r18
    4d08:	20 81       	ld	r18, Z
    4d0a:	2d 7f       	andi	r18, 0xFD	; 253
    4d0c:	fc 01       	movw	r30, r24
    4d0e:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4d10:	82 e0       	ldi	r24, 0x02	; 2
    4d12:	63 e0       	ldi	r22, 0x03	; 3
    4d14:	4f e1       	ldi	r20, 0x1F	; 31
    4d16:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
    4d1a:	80 e0       	ldi	r24, 0x00	; 0
    4d1c:	90 e0       	ldi	r25, 0x00	; 0
    4d1e:	a0 e8       	ldi	r26, 0x80	; 128
    4d20:	bf e3       	ldi	r27, 0x3F	; 63
    4d22:	8a 83       	std	Y+2, r24	; 0x02
    4d24:	9b 83       	std	Y+3, r25	; 0x03
    4d26:	ac 83       	std	Y+4, r26	; 0x04
    4d28:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4d2a:	6a 81       	ldd	r22, Y+2	; 0x02
    4d2c:	7b 81       	ldd	r23, Y+3	; 0x03
    4d2e:	8c 81       	ldd	r24, Y+4	; 0x04
    4d30:	9d 81       	ldd	r25, Y+5	; 0x05
    4d32:	2b ea       	ldi	r18, 0xAB	; 171
    4d34:	3a ea       	ldi	r19, 0xAA	; 170
    4d36:	4a ea       	ldi	r20, 0xAA	; 170
    4d38:	5e e3       	ldi	r21, 0x3E	; 62
    4d3a:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4d3e:	dc 01       	movw	r26, r24
    4d40:	cb 01       	movw	r24, r22
    4d42:	8e 83       	std	Y+6, r24	; 0x06
    4d44:	9f 83       	std	Y+7, r25	; 0x07
    4d46:	a8 87       	std	Y+8, r26	; 0x08
    4d48:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4d4a:	11 e0       	ldi	r17, 0x01	; 1
    4d4c:	6e 81       	ldd	r22, Y+6	; 0x06
    4d4e:	7f 81       	ldd	r23, Y+7	; 0x07
    4d50:	88 85       	ldd	r24, Y+8	; 0x08
    4d52:	99 85       	ldd	r25, Y+9	; 0x09
    4d54:	20 e0       	ldi	r18, 0x00	; 0
    4d56:	30 e0       	ldi	r19, 0x00	; 0
    4d58:	40 e8       	ldi	r20, 0x80	; 128
    4d5a:	5f e3       	ldi	r21, 0x3F	; 63
    4d5c:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4d60:	88 23       	and	r24, r24
    4d62:	0c f0       	brlt	.+2      	; 0x4d66 <chb_set_state+0xf0>
    4d64:	10 e0       	ldi	r17, 0x00	; 0
    4d66:	11 23       	and	r17, r17
    4d68:	19 f0       	breq	.+6      	; 0x4d70 <chb_set_state+0xfa>
		__ticks = 1;
    4d6a:	81 e0       	ldi	r24, 0x01	; 1
    4d6c:	8a 87       	std	Y+10, r24	; 0x0a
    4d6e:	a3 c0       	rjmp	.+326    	; 0x4eb6 <chb_set_state+0x240>
	else if (__tmp > 255)
    4d70:	11 e0       	ldi	r17, 0x01	; 1
    4d72:	6e 81       	ldd	r22, Y+6	; 0x06
    4d74:	7f 81       	ldd	r23, Y+7	; 0x07
    4d76:	88 85       	ldd	r24, Y+8	; 0x08
    4d78:	99 85       	ldd	r25, Y+9	; 0x09
    4d7a:	20 e0       	ldi	r18, 0x00	; 0
    4d7c:	30 e0       	ldi	r19, 0x00	; 0
    4d7e:	4f e7       	ldi	r20, 0x7F	; 127
    4d80:	53 e4       	ldi	r21, 0x43	; 67
    4d82:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4d86:	18 16       	cp	r1, r24
    4d88:	0c f0       	brlt	.+2      	; 0x4d8c <chb_set_state+0x116>
    4d8a:	10 e0       	ldi	r17, 0x00	; 0
    4d8c:	11 23       	and	r17, r17
    4d8e:	09 f4       	brne	.+2      	; 0x4d92 <chb_set_state+0x11c>
    4d90:	89 c0       	rjmp	.+274    	; 0x4ea4 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    4d92:	6a 81       	ldd	r22, Y+2	; 0x02
    4d94:	7b 81       	ldd	r23, Y+3	; 0x03
    4d96:	8c 81       	ldd	r24, Y+4	; 0x04
    4d98:	9d 81       	ldd	r25, Y+5	; 0x05
    4d9a:	20 e0       	ldi	r18, 0x00	; 0
    4d9c:	30 e0       	ldi	r19, 0x00	; 0
    4d9e:	4a e7       	ldi	r20, 0x7A	; 122
    4da0:	54 e4       	ldi	r21, 0x44	; 68
    4da2:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    4da6:	dc 01       	movw	r26, r24
    4da8:	cb 01       	movw	r24, r22
    4daa:	8b 87       	std	Y+11, r24	; 0x0b
    4dac:	9c 87       	std	Y+12, r25	; 0x0c
    4dae:	ad 87       	std	Y+13, r26	; 0x0d
    4db0:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4db2:	6b 85       	ldd	r22, Y+11	; 0x0b
    4db4:	7c 85       	ldd	r23, Y+12	; 0x0c
    4db6:	8d 85       	ldd	r24, Y+13	; 0x0d
    4db8:	9e 85       	ldd	r25, Y+14	; 0x0e
    4dba:	20 e0       	ldi	r18, 0x00	; 0
    4dbc:	30 e0       	ldi	r19, 0x00	; 0
    4dbe:	4a e7       	ldi	r20, 0x7A	; 122
    4dc0:	53 e4       	ldi	r21, 0x43	; 67
    4dc2:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4dc6:	dc 01       	movw	r26, r24
    4dc8:	cb 01       	movw	r24, r22
    4dca:	8f 87       	std	Y+15, r24	; 0x0f
    4dcc:	98 8b       	std	Y+16, r25	; 0x10
    4dce:	a9 8b       	std	Y+17, r26	; 0x11
    4dd0:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4dd2:	11 e0       	ldi	r17, 0x01	; 1
    4dd4:	6f 85       	ldd	r22, Y+15	; 0x0f
    4dd6:	78 89       	ldd	r23, Y+16	; 0x10
    4dd8:	89 89       	ldd	r24, Y+17	; 0x11
    4dda:	9a 89       	ldd	r25, Y+18	; 0x12
    4ddc:	20 e0       	ldi	r18, 0x00	; 0
    4dde:	30 e0       	ldi	r19, 0x00	; 0
    4de0:	40 e8       	ldi	r20, 0x80	; 128
    4de2:	5f e3       	ldi	r21, 0x3F	; 63
    4de4:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4de8:	88 23       	and	r24, r24
    4dea:	0c f0       	brlt	.+2      	; 0x4dee <chb_set_state+0x178>
    4dec:	10 e0       	ldi	r17, 0x00	; 0
    4dee:	11 23       	and	r17, r17
    4df0:	29 f0       	breq	.+10     	; 0x4dfc <chb_set_state+0x186>
		__ticks = 1;
    4df2:	81 e0       	ldi	r24, 0x01	; 1
    4df4:	90 e0       	ldi	r25, 0x00	; 0
    4df6:	8b 8b       	std	Y+19, r24	; 0x13
    4df8:	9c 8b       	std	Y+20, r25	; 0x14
    4dfa:	46 c0       	rjmp	.+140    	; 0x4e88 <chb_set_state+0x212>
	else if (__tmp > 65535)
    4dfc:	11 e0       	ldi	r17, 0x01	; 1
    4dfe:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e00:	78 89       	ldd	r23, Y+16	; 0x10
    4e02:	89 89       	ldd	r24, Y+17	; 0x11
    4e04:	9a 89       	ldd	r25, Y+18	; 0x12
    4e06:	20 e0       	ldi	r18, 0x00	; 0
    4e08:	3f ef       	ldi	r19, 0xFF	; 255
    4e0a:	4f e7       	ldi	r20, 0x7F	; 127
    4e0c:	57 e4       	ldi	r21, 0x47	; 71
    4e0e:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4e12:	18 16       	cp	r1, r24
    4e14:	0c f0       	brlt	.+2      	; 0x4e18 <chb_set_state+0x1a2>
    4e16:	10 e0       	ldi	r17, 0x00	; 0
    4e18:	11 23       	and	r17, r17
    4e1a:	61 f1       	breq	.+88     	; 0x4e74 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e1c:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e1e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e20:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e22:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e24:	20 e0       	ldi	r18, 0x00	; 0
    4e26:	30 e0       	ldi	r19, 0x00	; 0
    4e28:	40 e2       	ldi	r20, 0x20	; 32
    4e2a:	51 e4       	ldi	r21, 0x41	; 65
    4e2c:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4e30:	dc 01       	movw	r26, r24
    4e32:	cb 01       	movw	r24, r22
    4e34:	bc 01       	movw	r22, r24
    4e36:	cd 01       	movw	r24, r26
    4e38:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4e3c:	dc 01       	movw	r26, r24
    4e3e:	cb 01       	movw	r24, r22
    4e40:	8b 8b       	std	Y+19, r24	; 0x13
    4e42:	9c 8b       	std	Y+20, r25	; 0x14
    4e44:	12 c0       	rjmp	.+36     	; 0x4e6a <chb_set_state+0x1f4>
    4e46:	89 e1       	ldi	r24, 0x19	; 25
    4e48:	90 e0       	ldi	r25, 0x00	; 0
    4e4a:	8d 8b       	std	Y+21, r24	; 0x15
    4e4c:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4e4e:	8d 89       	ldd	r24, Y+21	; 0x15
    4e50:	9e 89       	ldd	r25, Y+22	; 0x16
    4e52:	8c 01       	movw	r16, r24
    4e54:	c8 01       	movw	r24, r16
    4e56:	01 97       	sbiw	r24, 0x01	; 1
    4e58:	f1 f7       	brne	.-4      	; 0x4e56 <chb_set_state+0x1e0>
    4e5a:	8c 01       	movw	r16, r24
    4e5c:	0d 8b       	std	Y+21, r16	; 0x15
    4e5e:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4e60:	8b 89       	ldd	r24, Y+19	; 0x13
    4e62:	9c 89       	ldd	r25, Y+20	; 0x14
    4e64:	01 97       	sbiw	r24, 0x01	; 1
    4e66:	8b 8b       	std	Y+19, r24	; 0x13
    4e68:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e6a:	8b 89       	ldd	r24, Y+19	; 0x13
    4e6c:	9c 89       	ldd	r25, Y+20	; 0x14
    4e6e:	00 97       	sbiw	r24, 0x00	; 0
    4e70:	51 f7       	brne	.-44     	; 0x4e46 <chb_set_state+0x1d0>
    4e72:	29 c0       	rjmp	.+82     	; 0x4ec6 <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4e74:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e76:	78 89       	ldd	r23, Y+16	; 0x10
    4e78:	89 89       	ldd	r24, Y+17	; 0x11
    4e7a:	9a 89       	ldd	r25, Y+18	; 0x12
    4e7c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4e80:	dc 01       	movw	r26, r24
    4e82:	cb 01       	movw	r24, r22
    4e84:	8b 8b       	std	Y+19, r24	; 0x13
    4e86:	9c 8b       	std	Y+20, r25	; 0x14
    4e88:	8b 89       	ldd	r24, Y+19	; 0x13
    4e8a:	9c 89       	ldd	r25, Y+20	; 0x14
    4e8c:	8f 8b       	std	Y+23, r24	; 0x17
    4e8e:	98 8f       	std	Y+24, r25	; 0x18
    4e90:	8f 89       	ldd	r24, Y+23	; 0x17
    4e92:	98 8d       	ldd	r25, Y+24	; 0x18
    4e94:	8c 01       	movw	r16, r24
    4e96:	f8 01       	movw	r30, r16
    4e98:	31 97       	sbiw	r30, 0x01	; 1
    4e9a:	f1 f7       	brne	.-4      	; 0x4e98 <chb_set_state+0x222>
    4e9c:	8f 01       	movw	r16, r30
    4e9e:	0f 8b       	std	Y+23, r16	; 0x17
    4ea0:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    4ea2:	24 c2       	rjmp	.+1096   	; 0x52ec <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4ea4:	6e 81       	ldd	r22, Y+6	; 0x06
    4ea6:	7f 81       	ldd	r23, Y+7	; 0x07
    4ea8:	88 85       	ldd	r24, Y+8	; 0x08
    4eaa:	99 85       	ldd	r25, Y+9	; 0x09
    4eac:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4eb0:	dc 01       	movw	r26, r24
    4eb2:	cb 01       	movw	r24, r22
    4eb4:	8a 87       	std	Y+10, r24	; 0x0a
    4eb6:	8a 85       	ldd	r24, Y+10	; 0x0a
    4eb8:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4eba:	89 8d       	ldd	r24, Y+25	; 0x19
    4ebc:	18 2f       	mov	r17, r24
    4ebe:	1a 95       	dec	r17
    4ec0:	f1 f7       	brne	.-4      	; 0x4ebe <chb_set_state+0x248>
    4ec2:	19 8f       	std	Y+25, r17	; 0x19
    4ec4:	13 c2       	rjmp	.+1062   	; 0x52ec <chb_set_state+0x676>
    4ec6:	12 c2       	rjmp	.+1060   	; 0x52ec <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    4ec8:	89 81       	ldd	r24, Y+1	; 0x01
    4eca:	86 31       	cpi	r24, 0x16	; 22
    4ecc:	09 f0       	breq	.+2      	; 0x4ed0 <chb_set_state+0x25a>
    4ece:	0b c2       	rjmp	.+1046   	; 0x52e6 <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    4ed0:	82 e0       	ldi	r24, 0x02	; 2
    4ed2:	69 e0       	ldi	r22, 0x09	; 9
    4ed4:	4f e1       	ldi	r20, 0x1F	; 31
    4ed6:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
    4eda:	80 e0       	ldi	r24, 0x00	; 0
    4edc:	90 e0       	ldi	r25, 0x00	; 0
    4ede:	a0 e8       	ldi	r26, 0x80	; 128
    4ee0:	bf e3       	ldi	r27, 0x3F	; 63
    4ee2:	8a 8f       	std	Y+26, r24	; 0x1a
    4ee4:	9b 8f       	std	Y+27, r25	; 0x1b
    4ee6:	ac 8f       	std	Y+28, r26	; 0x1c
    4ee8:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4eea:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4eec:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4eee:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4ef0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4ef2:	2b ea       	ldi	r18, 0xAB	; 171
    4ef4:	3a ea       	ldi	r19, 0xAA	; 170
    4ef6:	4a ea       	ldi	r20, 0xAA	; 170
    4ef8:	5e e3       	ldi	r21, 0x3E	; 62
    4efa:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4efe:	dc 01       	movw	r26, r24
    4f00:	cb 01       	movw	r24, r22
    4f02:	8e 8f       	std	Y+30, r24	; 0x1e
    4f04:	9f 8f       	std	Y+31, r25	; 0x1f
    4f06:	a8 a3       	lds	r26, 0x58
    4f08:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    4f0a:	11 e0       	ldi	r17, 0x01	; 1
    4f0c:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4f0e:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4f10:	88 a1       	lds	r24, 0x48
    4f12:	99 a1       	lds	r25, 0x49
    4f14:	20 e0       	ldi	r18, 0x00	; 0
    4f16:	30 e0       	ldi	r19, 0x00	; 0
    4f18:	40 e8       	ldi	r20, 0x80	; 128
    4f1a:	5f e3       	ldi	r21, 0x3F	; 63
    4f1c:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4f20:	88 23       	and	r24, r24
    4f22:	0c f0       	brlt	.+2      	; 0x4f26 <chb_set_state+0x2b0>
    4f24:	10 e0       	ldi	r17, 0x00	; 0
    4f26:	11 23       	and	r17, r17
    4f28:	19 f0       	breq	.+6      	; 0x4f30 <chb_set_state+0x2ba>
		__ticks = 1;
    4f2a:	81 e0       	ldi	r24, 0x01	; 1
    4f2c:	8a a3       	lds	r24, 0x5a
    4f2e:	a3 c0       	rjmp	.+326    	; 0x5076 <chb_set_state+0x400>
	else if (__tmp > 255)
    4f30:	11 e0       	ldi	r17, 0x01	; 1
    4f32:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4f34:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4f36:	88 a1       	lds	r24, 0x48
    4f38:	99 a1       	lds	r25, 0x49
    4f3a:	20 e0       	ldi	r18, 0x00	; 0
    4f3c:	30 e0       	ldi	r19, 0x00	; 0
    4f3e:	4f e7       	ldi	r20, 0x7F	; 127
    4f40:	53 e4       	ldi	r21, 0x43	; 67
    4f42:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4f46:	18 16       	cp	r1, r24
    4f48:	0c f0       	brlt	.+2      	; 0x4f4c <chb_set_state+0x2d6>
    4f4a:	10 e0       	ldi	r17, 0x00	; 0
    4f4c:	11 23       	and	r17, r17
    4f4e:	09 f4       	brne	.+2      	; 0x4f52 <chb_set_state+0x2dc>
    4f50:	89 c0       	rjmp	.+274    	; 0x5064 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    4f52:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4f54:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4f56:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4f58:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f5a:	20 e0       	ldi	r18, 0x00	; 0
    4f5c:	30 e0       	ldi	r19, 0x00	; 0
    4f5e:	4a e7       	ldi	r20, 0x7A	; 122
    4f60:	54 e4       	ldi	r21, 0x44	; 68
    4f62:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    4f66:	dc 01       	movw	r26, r24
    4f68:	cb 01       	movw	r24, r22
    4f6a:	8b a3       	lds	r24, 0x5b
    4f6c:	9c a3       	lds	r25, 0x5c
    4f6e:	ad a3       	lds	r26, 0x5d
    4f70:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4f72:	6b a1       	lds	r22, 0x4b
    4f74:	7c a1       	lds	r23, 0x4c
    4f76:	8d a1       	lds	r24, 0x4d
    4f78:	9e a1       	lds	r25, 0x4e
    4f7a:	20 e0       	ldi	r18, 0x00	; 0
    4f7c:	30 e0       	ldi	r19, 0x00	; 0
    4f7e:	4a e7       	ldi	r20, 0x7A	; 122
    4f80:	53 e4       	ldi	r21, 0x43	; 67
    4f82:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4f86:	dc 01       	movw	r26, r24
    4f88:	cb 01       	movw	r24, r22
    4f8a:	8f a3       	lds	r24, 0x5f
    4f8c:	98 a7       	lds	r25, 0x78
    4f8e:	a9 a7       	lds	r26, 0x79
    4f90:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    4f92:	11 e0       	ldi	r17, 0x01	; 1
    4f94:	6f a1       	lds	r22, 0x4f
    4f96:	78 a5       	lds	r23, 0x68
    4f98:	89 a5       	lds	r24, 0x69
    4f9a:	9a a5       	lds	r25, 0x6a
    4f9c:	20 e0       	ldi	r18, 0x00	; 0
    4f9e:	30 e0       	ldi	r19, 0x00	; 0
    4fa0:	40 e8       	ldi	r20, 0x80	; 128
    4fa2:	5f e3       	ldi	r21, 0x3F	; 63
    4fa4:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    4fa8:	88 23       	and	r24, r24
    4faa:	0c f0       	brlt	.+2      	; 0x4fae <chb_set_state+0x338>
    4fac:	10 e0       	ldi	r17, 0x00	; 0
    4fae:	11 23       	and	r17, r17
    4fb0:	29 f0       	breq	.+10     	; 0x4fbc <chb_set_state+0x346>
		__ticks = 1;
    4fb2:	81 e0       	ldi	r24, 0x01	; 1
    4fb4:	90 e0       	ldi	r25, 0x00	; 0
    4fb6:	8b a7       	lds	r24, 0x7b
    4fb8:	9c a7       	lds	r25, 0x7c
    4fba:	46 c0       	rjmp	.+140    	; 0x5048 <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    4fbc:	11 e0       	ldi	r17, 0x01	; 1
    4fbe:	6f a1       	lds	r22, 0x4f
    4fc0:	78 a5       	lds	r23, 0x68
    4fc2:	89 a5       	lds	r24, 0x69
    4fc4:	9a a5       	lds	r25, 0x6a
    4fc6:	20 e0       	ldi	r18, 0x00	; 0
    4fc8:	3f ef       	ldi	r19, 0xFF	; 255
    4fca:	4f e7       	ldi	r20, 0x7F	; 127
    4fcc:	57 e4       	ldi	r21, 0x47	; 71
    4fce:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    4fd2:	18 16       	cp	r1, r24
    4fd4:	0c f0       	brlt	.+2      	; 0x4fd8 <chb_set_state+0x362>
    4fd6:	10 e0       	ldi	r17, 0x00	; 0
    4fd8:	11 23       	and	r17, r17
    4fda:	61 f1       	breq	.+88     	; 0x5034 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4fdc:	6b a1       	lds	r22, 0x4b
    4fde:	7c a1       	lds	r23, 0x4c
    4fe0:	8d a1       	lds	r24, 0x4d
    4fe2:	9e a1       	lds	r25, 0x4e
    4fe4:	20 e0       	ldi	r18, 0x00	; 0
    4fe6:	30 e0       	ldi	r19, 0x00	; 0
    4fe8:	40 e2       	ldi	r20, 0x20	; 32
    4fea:	51 e4       	ldi	r21, 0x41	; 65
    4fec:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    4ff0:	dc 01       	movw	r26, r24
    4ff2:	cb 01       	movw	r24, r22
    4ff4:	bc 01       	movw	r22, r24
    4ff6:	cd 01       	movw	r24, r26
    4ff8:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    4ffc:	dc 01       	movw	r26, r24
    4ffe:	cb 01       	movw	r24, r22
    5000:	8b a7       	lds	r24, 0x7b
    5002:	9c a7       	lds	r25, 0x7c
    5004:	12 c0       	rjmp	.+36     	; 0x502a <chb_set_state+0x3b4>
    5006:	89 e1       	ldi	r24, 0x19	; 25
    5008:	90 e0       	ldi	r25, 0x00	; 0
    500a:	8d a7       	lds	r24, 0x7d
    500c:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    500e:	8d a5       	lds	r24, 0x6d
    5010:	9e a5       	lds	r25, 0x6e
    5012:	8c 01       	movw	r16, r24
    5014:	c8 01       	movw	r24, r16
    5016:	01 97       	sbiw	r24, 0x01	; 1
    5018:	f1 f7       	brne	.-4      	; 0x5016 <chb_set_state+0x3a0>
    501a:	8c 01       	movw	r16, r24
    501c:	0d a7       	lds	r16, 0x7d
    501e:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5020:	8b a5       	lds	r24, 0x6b
    5022:	9c a5       	lds	r25, 0x6c
    5024:	01 97       	sbiw	r24, 0x01	; 1
    5026:	8b a7       	lds	r24, 0x7b
    5028:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    502a:	8b a5       	lds	r24, 0x6b
    502c:	9c a5       	lds	r25, 0x6c
    502e:	00 97       	sbiw	r24, 0x00	; 0
    5030:	51 f7       	brne	.-44     	; 0x5006 <chb_set_state+0x390>
    5032:	29 c0       	rjmp	.+82     	; 0x5086 <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5034:	6f a1       	lds	r22, 0x4f
    5036:	78 a5       	lds	r23, 0x68
    5038:	89 a5       	lds	r24, 0x69
    503a:	9a a5       	lds	r25, 0x6a
    503c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    5040:	dc 01       	movw	r26, r24
    5042:	cb 01       	movw	r24, r22
    5044:	8b a7       	lds	r24, 0x7b
    5046:	9c a7       	lds	r25, 0x7c
    5048:	8b a5       	lds	r24, 0x6b
    504a:	9c a5       	lds	r25, 0x6c
    504c:	8f a7       	lds	r24, 0x7f
    504e:	98 ab       	sts	0x58, r25
    5050:	8f a5       	lds	r24, 0x6f
    5052:	98 a9       	sts	0x48, r25
    5054:	8c 01       	movw	r16, r24
    5056:	f8 01       	movw	r30, r16
    5058:	31 97       	sbiw	r30, 0x01	; 1
    505a:	f1 f7       	brne	.-4      	; 0x5058 <chb_set_state+0x3e2>
    505c:	8f 01       	movw	r16, r30
    505e:	0f a7       	lds	r16, 0x7f
    5060:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5062:	41 c1       	rjmp	.+642    	; 0x52e6 <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5064:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5066:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5068:	88 a1       	lds	r24, 0x48
    506a:	99 a1       	lds	r25, 0x49
    506c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    5070:	dc 01       	movw	r26, r24
    5072:	cb 01       	movw	r24, r22
    5074:	8a a3       	lds	r24, 0x5a
    5076:	8a a1       	lds	r24, 0x4a
    5078:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    507a:	89 a9       	sts	0x49, r24
    507c:	18 2f       	mov	r17, r24
    507e:	1a 95       	dec	r17
    5080:	f1 f7       	brne	.-4      	; 0x507e <chb_set_state+0x408>
    5082:	19 ab       	sts	0x59, r17
    5084:	30 c1       	rjmp	.+608    	; 0x52e6 <chb_set_state+0x670>
    5086:	2f c1       	rjmp	.+606    	; 0x52e6 <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    5088:	89 81       	ldd	r24, Y+1	; 0x01
    508a:	89 31       	cpi	r24, 0x19	; 25
    508c:	09 f0       	breq	.+2      	; 0x5090 <chb_set_state+0x41a>
    508e:	2d c1       	rjmp	.+602    	; 0x52ea <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5090:	82 e0       	ldi	r24, 0x02	; 2
    5092:	69 e0       	ldi	r22, 0x09	; 9
    5094:	4f e1       	ldi	r20, 0x1F	; 31
    5096:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
    509a:	80 e0       	ldi	r24, 0x00	; 0
    509c:	90 e0       	ldi	r25, 0x00	; 0
    509e:	a0 e8       	ldi	r26, 0x80	; 128
    50a0:	bf e3       	ldi	r27, 0x3F	; 63
    50a2:	8a ab       	sts	0x5a, r24
    50a4:	9b ab       	sts	0x5b, r25
    50a6:	ac ab       	sts	0x5c, r26
    50a8:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    50aa:	6a a9       	sts	0x4a, r22
    50ac:	7b a9       	sts	0x4b, r23
    50ae:	8c a9       	sts	0x4c, r24
    50b0:	9d a9       	sts	0x4d, r25
    50b2:	2b ea       	ldi	r18, 0xAB	; 171
    50b4:	3a ea       	ldi	r19, 0xAA	; 170
    50b6:	4a ea       	ldi	r20, 0xAA	; 170
    50b8:	5e e3       	ldi	r21, 0x3E	; 62
    50ba:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    50be:	dc 01       	movw	r26, r24
    50c0:	cb 01       	movw	r24, r22
    50c2:	8e ab       	sts	0x5e, r24
    50c4:	9f ab       	sts	0x5f, r25
    50c6:	a8 af       	sts	0x78, r26
    50c8:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    50ca:	11 e0       	ldi	r17, 0x01	; 1
    50cc:	6e a9       	sts	0x4e, r22
    50ce:	7f a9       	sts	0x4f, r23
    50d0:	88 ad       	sts	0x68, r24
    50d2:	99 ad       	sts	0x69, r25
    50d4:	20 e0       	ldi	r18, 0x00	; 0
    50d6:	30 e0       	ldi	r19, 0x00	; 0
    50d8:	40 e8       	ldi	r20, 0x80	; 128
    50da:	5f e3       	ldi	r21, 0x3F	; 63
    50dc:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    50e0:	88 23       	and	r24, r24
    50e2:	0c f0       	brlt	.+2      	; 0x50e6 <chb_set_state+0x470>
    50e4:	10 e0       	ldi	r17, 0x00	; 0
    50e6:	11 23       	and	r17, r17
    50e8:	19 f0       	breq	.+6      	; 0x50f0 <chb_set_state+0x47a>
		__ticks = 1;
    50ea:	81 e0       	ldi	r24, 0x01	; 1
    50ec:	8a af       	sts	0x7a, r24
    50ee:	e6 c0       	rjmp	.+460    	; 0x52bc <chb_set_state+0x646>
	else if (__tmp > 255)
    50f0:	11 e0       	ldi	r17, 0x01	; 1
    50f2:	6e a9       	sts	0x4e, r22
    50f4:	7f a9       	sts	0x4f, r23
    50f6:	88 ad       	sts	0x68, r24
    50f8:	99 ad       	sts	0x69, r25
    50fa:	20 e0       	ldi	r18, 0x00	; 0
    50fc:	30 e0       	ldi	r19, 0x00	; 0
    50fe:	4f e7       	ldi	r20, 0x7F	; 127
    5100:	53 e4       	ldi	r21, 0x43	; 67
    5102:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    5106:	18 16       	cp	r1, r24
    5108:	0c f0       	brlt	.+2      	; 0x510c <chb_set_state+0x496>
    510a:	10 e0       	ldi	r17, 0x00	; 0
    510c:	11 23       	and	r17, r17
    510e:	09 f4       	brne	.+2      	; 0x5112 <chb_set_state+0x49c>
    5110:	cc c0       	rjmp	.+408    	; 0x52aa <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5112:	6a a9       	sts	0x4a, r22
    5114:	7b a9       	sts	0x4b, r23
    5116:	8c a9       	sts	0x4c, r24
    5118:	9d a9       	sts	0x4d, r25
    511a:	20 e0       	ldi	r18, 0x00	; 0
    511c:	30 e0       	ldi	r19, 0x00	; 0
    511e:	4a e7       	ldi	r20, 0x7A	; 122
    5120:	54 e4       	ldi	r21, 0x44	; 68
    5122:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    5126:	dc 01       	movw	r26, r24
    5128:	cb 01       	movw	r24, r22
    512a:	8b af       	sts	0x7b, r24
    512c:	9c af       	sts	0x7c, r25
    512e:	ad af       	sts	0x7d, r26
    5130:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5132:	8e 01       	movw	r16, r28
    5134:	01 5c       	subi	r16, 0xC1	; 193
    5136:	1f 4f       	sbci	r17, 0xFF	; 255
    5138:	6b ad       	sts	0x6b, r22
    513a:	7c ad       	sts	0x6c, r23
    513c:	8d ad       	sts	0x6d, r24
    513e:	9e ad       	sts	0x6e, r25
    5140:	20 e0       	ldi	r18, 0x00	; 0
    5142:	30 e0       	ldi	r19, 0x00	; 0
    5144:	4a e7       	ldi	r20, 0x7A	; 122
    5146:	53 e4       	ldi	r21, 0x43	; 67
    5148:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    514c:	dc 01       	movw	r26, r24
    514e:	cb 01       	movw	r24, r22
    5150:	f8 01       	movw	r30, r16
    5152:	80 83       	st	Z, r24
    5154:	91 83       	std	Z+1, r25	; 0x01
    5156:	a2 83       	std	Z+2, r26	; 0x02
    5158:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    515a:	ce 01       	movw	r24, r28
    515c:	cf 96       	adiw	r24, 0x3f	; 63
    515e:	11 e0       	ldi	r17, 0x01	; 1
    5160:	fc 01       	movw	r30, r24
    5162:	60 81       	ld	r22, Z
    5164:	71 81       	ldd	r23, Z+1	; 0x01
    5166:	82 81       	ldd	r24, Z+2	; 0x02
    5168:	93 81       	ldd	r25, Z+3	; 0x03
    516a:	20 e0       	ldi	r18, 0x00	; 0
    516c:	30 e0       	ldi	r19, 0x00	; 0
    516e:	40 e8       	ldi	r20, 0x80	; 128
    5170:	5f e3       	ldi	r21, 0x3F	; 63
    5172:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    5176:	88 23       	and	r24, r24
    5178:	0c f0       	brlt	.+2      	; 0x517c <chb_set_state+0x506>
    517a:	10 e0       	ldi	r17, 0x00	; 0
    517c:	11 23       	and	r17, r17
    517e:	49 f0       	breq	.+18     	; 0x5192 <chb_set_state+0x51c>
		__ticks = 1;
    5180:	ce 01       	movw	r24, r28
    5182:	8d 5b       	subi	r24, 0xBD	; 189
    5184:	9f 4f       	sbci	r25, 0xFF	; 255
    5186:	21 e0       	ldi	r18, 0x01	; 1
    5188:	30 e0       	ldi	r19, 0x00	; 0
    518a:	fc 01       	movw	r30, r24
    518c:	20 83       	st	Z, r18
    518e:	31 83       	std	Z+1, r19	; 0x01
    5190:	6e c0       	rjmp	.+220    	; 0x526e <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    5192:	ce 01       	movw	r24, r28
    5194:	cf 96       	adiw	r24, 0x3f	; 63
    5196:	11 e0       	ldi	r17, 0x01	; 1
    5198:	fc 01       	movw	r30, r24
    519a:	60 81       	ld	r22, Z
    519c:	71 81       	ldd	r23, Z+1	; 0x01
    519e:	82 81       	ldd	r24, Z+2	; 0x02
    51a0:	93 81       	ldd	r25, Z+3	; 0x03
    51a2:	20 e0       	ldi	r18, 0x00	; 0
    51a4:	3f ef       	ldi	r19, 0xFF	; 255
    51a6:	4f e7       	ldi	r20, 0x7F	; 127
    51a8:	57 e4       	ldi	r21, 0x47	; 71
    51aa:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    51ae:	18 16       	cp	r1, r24
    51b0:	0c f0       	brlt	.+2      	; 0x51b4 <chb_set_state+0x53e>
    51b2:	10 e0       	ldi	r17, 0x00	; 0
    51b4:	11 23       	and	r17, r17
    51b6:	09 f4       	brne	.+2      	; 0x51ba <chb_set_state+0x544>
    51b8:	49 c0       	rjmp	.+146    	; 0x524c <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    51ba:	6b ad       	sts	0x6b, r22
    51bc:	7c ad       	sts	0x6c, r23
    51be:	8d ad       	sts	0x6d, r24
    51c0:	9e ad       	sts	0x6e, r25
    51c2:	20 e0       	ldi	r18, 0x00	; 0
    51c4:	30 e0       	ldi	r19, 0x00	; 0
    51c6:	40 e2       	ldi	r20, 0x20	; 32
    51c8:	51 e4       	ldi	r21, 0x41	; 65
    51ca:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    51ce:	dc 01       	movw	r26, r24
    51d0:	cb 01       	movw	r24, r22
    51d2:	8e 01       	movw	r16, r28
    51d4:	0d 5b       	subi	r16, 0xBD	; 189
    51d6:	1f 4f       	sbci	r17, 0xFF	; 255
    51d8:	bc 01       	movw	r22, r24
    51da:	cd 01       	movw	r24, r26
    51dc:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    51e0:	dc 01       	movw	r26, r24
    51e2:	cb 01       	movw	r24, r22
    51e4:	f8 01       	movw	r30, r16
    51e6:	80 83       	st	Z, r24
    51e8:	91 83       	std	Z+1, r25	; 0x01
    51ea:	27 c0       	rjmp	.+78     	; 0x523a <chb_set_state+0x5c4>
    51ec:	ce 01       	movw	r24, r28
    51ee:	8b 5b       	subi	r24, 0xBB	; 187
    51f0:	9f 4f       	sbci	r25, 0xFF	; 255
    51f2:	29 e1       	ldi	r18, 0x19	; 25
    51f4:	30 e0       	ldi	r19, 0x00	; 0
    51f6:	fc 01       	movw	r30, r24
    51f8:	20 83       	st	Z, r18
    51fa:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    51fc:	ce 01       	movw	r24, r28
    51fe:	8b 5b       	subi	r24, 0xBB	; 187
    5200:	9f 4f       	sbci	r25, 0xFF	; 255
    5202:	fc 01       	movw	r30, r24
    5204:	80 81       	ld	r24, Z
    5206:	91 81       	ldd	r25, Z+1	; 0x01
    5208:	8c 01       	movw	r16, r24
    520a:	c8 01       	movw	r24, r16
    520c:	01 97       	sbiw	r24, 0x01	; 1
    520e:	f1 f7       	brne	.-4      	; 0x520c <chb_set_state+0x596>
    5210:	8c 01       	movw	r16, r24
    5212:	ce 01       	movw	r24, r28
    5214:	8b 5b       	subi	r24, 0xBB	; 187
    5216:	9f 4f       	sbci	r25, 0xFF	; 255
    5218:	fc 01       	movw	r30, r24
    521a:	00 83       	st	Z, r16
    521c:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    521e:	ce 01       	movw	r24, r28
    5220:	8d 5b       	subi	r24, 0xBD	; 189
    5222:	9f 4f       	sbci	r25, 0xFF	; 255
    5224:	9e 01       	movw	r18, r28
    5226:	2d 5b       	subi	r18, 0xBD	; 189
    5228:	3f 4f       	sbci	r19, 0xFF	; 255
    522a:	f9 01       	movw	r30, r18
    522c:	20 81       	ld	r18, Z
    522e:	31 81       	ldd	r19, Z+1	; 0x01
    5230:	21 50       	subi	r18, 0x01	; 1
    5232:	30 40       	sbci	r19, 0x00	; 0
    5234:	fc 01       	movw	r30, r24
    5236:	20 83       	st	Z, r18
    5238:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    523a:	ce 01       	movw	r24, r28
    523c:	8d 5b       	subi	r24, 0xBD	; 189
    523e:	9f 4f       	sbci	r25, 0xFF	; 255
    5240:	fc 01       	movw	r30, r24
    5242:	80 81       	ld	r24, Z
    5244:	91 81       	ldd	r25, Z+1	; 0x01
    5246:	00 97       	sbiw	r24, 0x00	; 0
    5248:	89 f6       	brne	.-94     	; 0x51ec <chb_set_state+0x576>
    524a:	4c c0       	rjmp	.+152    	; 0x52e4 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    524c:	8e 01       	movw	r16, r28
    524e:	0d 5b       	subi	r16, 0xBD	; 189
    5250:	1f 4f       	sbci	r17, 0xFF	; 255
    5252:	ce 01       	movw	r24, r28
    5254:	cf 96       	adiw	r24, 0x3f	; 63
    5256:	fc 01       	movw	r30, r24
    5258:	60 81       	ld	r22, Z
    525a:	71 81       	ldd	r23, Z+1	; 0x01
    525c:	82 81       	ldd	r24, Z+2	; 0x02
    525e:	93 81       	ldd	r25, Z+3	; 0x03
    5260:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    5264:	dc 01       	movw	r26, r24
    5266:	cb 01       	movw	r24, r22
    5268:	f8 01       	movw	r30, r16
    526a:	80 83       	st	Z, r24
    526c:	91 83       	std	Z+1, r25	; 0x01
    526e:	ce 01       	movw	r24, r28
    5270:	89 5b       	subi	r24, 0xB9	; 185
    5272:	9f 4f       	sbci	r25, 0xFF	; 255
    5274:	9e 01       	movw	r18, r28
    5276:	2d 5b       	subi	r18, 0xBD	; 189
    5278:	3f 4f       	sbci	r19, 0xFF	; 255
    527a:	f9 01       	movw	r30, r18
    527c:	20 81       	ld	r18, Z
    527e:	31 81       	ldd	r19, Z+1	; 0x01
    5280:	fc 01       	movw	r30, r24
    5282:	20 83       	st	Z, r18
    5284:	31 83       	std	Z+1, r19	; 0x01
    5286:	ce 01       	movw	r24, r28
    5288:	89 5b       	subi	r24, 0xB9	; 185
    528a:	9f 4f       	sbci	r25, 0xFF	; 255
    528c:	fc 01       	movw	r30, r24
    528e:	80 81       	ld	r24, Z
    5290:	91 81       	ldd	r25, Z+1	; 0x01
    5292:	8c 01       	movw	r16, r24
    5294:	c8 01       	movw	r24, r16
    5296:	01 97       	sbiw	r24, 0x01	; 1
    5298:	f1 f7       	brne	.-4      	; 0x5296 <chb_set_state+0x620>
    529a:	8c 01       	movw	r16, r24
    529c:	ce 01       	movw	r24, r28
    529e:	89 5b       	subi	r24, 0xB9	; 185
    52a0:	9f 4f       	sbci	r25, 0xFF	; 255
    52a2:	fc 01       	movw	r30, r24
    52a4:	00 83       	st	Z, r16
    52a6:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    52a8:	20 c0       	rjmp	.+64     	; 0x52ea <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    52aa:	6e a9       	sts	0x4e, r22
    52ac:	7f a9       	sts	0x4f, r23
    52ae:	88 ad       	sts	0x68, r24
    52b0:	99 ad       	sts	0x69, r25
    52b2:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    52b6:	dc 01       	movw	r26, r24
    52b8:	cb 01       	movw	r24, r22
    52ba:	8a af       	sts	0x7a, r24
    52bc:	ce 01       	movw	r24, r28
    52be:	87 5b       	subi	r24, 0xB7	; 183
    52c0:	9f 4f       	sbci	r25, 0xFF	; 255
    52c2:	2a ad       	sts	0x6a, r18
    52c4:	fc 01       	movw	r30, r24
    52c6:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    52c8:	ce 01       	movw	r24, r28
    52ca:	87 5b       	subi	r24, 0xB7	; 183
    52cc:	9f 4f       	sbci	r25, 0xFF	; 255
    52ce:	fc 01       	movw	r30, r24
    52d0:	80 81       	ld	r24, Z
    52d2:	18 2f       	mov	r17, r24
    52d4:	1a 95       	dec	r17
    52d6:	f1 f7       	brne	.-4      	; 0x52d4 <chb_set_state+0x65e>
    52d8:	ce 01       	movw	r24, r28
    52da:	87 5b       	subi	r24, 0xB7	; 183
    52dc:	9f 4f       	sbci	r25, 0xFF	; 255
    52de:	fc 01       	movw	r30, r24
    52e0:	10 83       	st	Z, r17
    52e2:	03 c0       	rjmp	.+6      	; 0x52ea <chb_set_state+0x674>
    52e4:	02 c0       	rjmp	.+4      	; 0x52ea <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    52e6:	00 00       	nop
    52e8:	01 c0       	rjmp	.+2      	; 0x52ec <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    52ea:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    52ec:	9e 01       	movw	r18, r28
    52ee:	2e 59       	subi	r18, 0x9E	; 158
    52f0:	3f 4f       	sbci	r19, 0xFF	; 255
    52f2:	82 e0       	ldi	r24, 0x02	; 2
    52f4:	f9 01       	movw	r30, r18
    52f6:	60 81       	ld	r22, Z
    52f8:	4f e1       	ldi	r20, 0x1F	; 31
    52fa:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
    52fe:	9e 01       	movw	r18, r28
    5300:	26 5b       	subi	r18, 0xB6	; 182
    5302:	3f 4f       	sbci	r19, 0xFF	; 255
    5304:	80 e0       	ldi	r24, 0x00	; 0
    5306:	90 e0       	ldi	r25, 0x00	; 0
    5308:	ac ed       	ldi	r26, 0xDC	; 220
    530a:	b2 e4       	ldi	r27, 0x42	; 66
    530c:	f9 01       	movw	r30, r18
    530e:	80 83       	st	Z, r24
    5310:	91 83       	std	Z+1, r25	; 0x01
    5312:	a2 83       	std	Z+2, r26	; 0x02
    5314:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5316:	8e 01       	movw	r16, r28
    5318:	02 5b       	subi	r16, 0xB2	; 178
    531a:	1f 4f       	sbci	r17, 0xFF	; 255
    531c:	ce 01       	movw	r24, r28
    531e:	86 5b       	subi	r24, 0xB6	; 182
    5320:	9f 4f       	sbci	r25, 0xFF	; 255
    5322:	fc 01       	movw	r30, r24
    5324:	60 81       	ld	r22, Z
    5326:	71 81       	ldd	r23, Z+1	; 0x01
    5328:	82 81       	ldd	r24, Z+2	; 0x02
    532a:	93 81       	ldd	r25, Z+3	; 0x03
    532c:	2b ea       	ldi	r18, 0xAB	; 171
    532e:	3a ea       	ldi	r19, 0xAA	; 170
    5330:	4a ea       	ldi	r20, 0xAA	; 170
    5332:	5e e3       	ldi	r21, 0x3E	; 62
    5334:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    5338:	dc 01       	movw	r26, r24
    533a:	cb 01       	movw	r24, r22
    533c:	f8 01       	movw	r30, r16
    533e:	80 83       	st	Z, r24
    5340:	91 83       	std	Z+1, r25	; 0x01
    5342:	a2 83       	std	Z+2, r26	; 0x02
    5344:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5346:	ce 01       	movw	r24, r28
    5348:	82 5b       	subi	r24, 0xB2	; 178
    534a:	9f 4f       	sbci	r25, 0xFF	; 255
    534c:	11 e0       	ldi	r17, 0x01	; 1
    534e:	fc 01       	movw	r30, r24
    5350:	60 81       	ld	r22, Z
    5352:	71 81       	ldd	r23, Z+1	; 0x01
    5354:	82 81       	ldd	r24, Z+2	; 0x02
    5356:	93 81       	ldd	r25, Z+3	; 0x03
    5358:	20 e0       	ldi	r18, 0x00	; 0
    535a:	30 e0       	ldi	r19, 0x00	; 0
    535c:	40 e8       	ldi	r20, 0x80	; 128
    535e:	5f e3       	ldi	r21, 0x3F	; 63
    5360:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    5364:	88 23       	and	r24, r24
    5366:	0c f0       	brlt	.+2      	; 0x536a <chb_set_state+0x6f4>
    5368:	10 e0       	ldi	r17, 0x00	; 0
    536a:	11 23       	and	r17, r17
    536c:	39 f0       	breq	.+14     	; 0x537c <chb_set_state+0x706>
		__ticks = 1;
    536e:	ce 01       	movw	r24, r28
    5370:	8e 5a       	subi	r24, 0xAE	; 174
    5372:	9f 4f       	sbci	r25, 0xFF	; 255
    5374:	21 e0       	ldi	r18, 0x01	; 1
    5376:	fc 01       	movw	r30, r24
    5378:	20 83       	st	Z, r18
    537a:	05 c1       	rjmp	.+522    	; 0x5586 <chb_set_state+0x910>
	else if (__tmp > 255)
    537c:	ce 01       	movw	r24, r28
    537e:	82 5b       	subi	r24, 0xB2	; 178
    5380:	9f 4f       	sbci	r25, 0xFF	; 255
    5382:	11 e0       	ldi	r17, 0x01	; 1
    5384:	fc 01       	movw	r30, r24
    5386:	60 81       	ld	r22, Z
    5388:	71 81       	ldd	r23, Z+1	; 0x01
    538a:	82 81       	ldd	r24, Z+2	; 0x02
    538c:	93 81       	ldd	r25, Z+3	; 0x03
    538e:	20 e0       	ldi	r18, 0x00	; 0
    5390:	30 e0       	ldi	r19, 0x00	; 0
    5392:	4f e7       	ldi	r20, 0x7F	; 127
    5394:	53 e4       	ldi	r21, 0x43	; 67
    5396:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    539a:	18 16       	cp	r1, r24
    539c:	0c f0       	brlt	.+2      	; 0x53a0 <chb_set_state+0x72a>
    539e:	10 e0       	ldi	r17, 0x00	; 0
    53a0:	11 23       	and	r17, r17
    53a2:	09 f4       	brne	.+2      	; 0x53a6 <chb_set_state+0x730>
    53a4:	df c0       	rjmp	.+446    	; 0x5564 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    53a6:	ce 01       	movw	r24, r28
    53a8:	86 5b       	subi	r24, 0xB6	; 182
    53aa:	9f 4f       	sbci	r25, 0xFF	; 255
    53ac:	fc 01       	movw	r30, r24
    53ae:	60 81       	ld	r22, Z
    53b0:	71 81       	ldd	r23, Z+1	; 0x01
    53b2:	82 81       	ldd	r24, Z+2	; 0x02
    53b4:	93 81       	ldd	r25, Z+3	; 0x03
    53b6:	20 e0       	ldi	r18, 0x00	; 0
    53b8:	30 e0       	ldi	r19, 0x00	; 0
    53ba:	4a e7       	ldi	r20, 0x7A	; 122
    53bc:	54 e4       	ldi	r21, 0x44	; 68
    53be:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    53c2:	dc 01       	movw	r26, r24
    53c4:	cb 01       	movw	r24, r22
    53c6:	9e 01       	movw	r18, r28
    53c8:	2d 5a       	subi	r18, 0xAD	; 173
    53ca:	3f 4f       	sbci	r19, 0xFF	; 255
    53cc:	f9 01       	movw	r30, r18
    53ce:	80 83       	st	Z, r24
    53d0:	91 83       	std	Z+1, r25	; 0x01
    53d2:	a2 83       	std	Z+2, r26	; 0x02
    53d4:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    53d6:	8e 01       	movw	r16, r28
    53d8:	09 5a       	subi	r16, 0xA9	; 169
    53da:	1f 4f       	sbci	r17, 0xFF	; 255
    53dc:	ce 01       	movw	r24, r28
    53de:	8d 5a       	subi	r24, 0xAD	; 173
    53e0:	9f 4f       	sbci	r25, 0xFF	; 255
    53e2:	fc 01       	movw	r30, r24
    53e4:	60 81       	ld	r22, Z
    53e6:	71 81       	ldd	r23, Z+1	; 0x01
    53e8:	82 81       	ldd	r24, Z+2	; 0x02
    53ea:	93 81       	ldd	r25, Z+3	; 0x03
    53ec:	20 e0       	ldi	r18, 0x00	; 0
    53ee:	30 e0       	ldi	r19, 0x00	; 0
    53f0:	4a e7       	ldi	r20, 0x7A	; 122
    53f2:	53 e4       	ldi	r21, 0x43	; 67
    53f4:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    53f8:	dc 01       	movw	r26, r24
    53fa:	cb 01       	movw	r24, r22
    53fc:	f8 01       	movw	r30, r16
    53fe:	80 83       	st	Z, r24
    5400:	91 83       	std	Z+1, r25	; 0x01
    5402:	a2 83       	std	Z+2, r26	; 0x02
    5404:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5406:	ce 01       	movw	r24, r28
    5408:	89 5a       	subi	r24, 0xA9	; 169
    540a:	9f 4f       	sbci	r25, 0xFF	; 255
    540c:	11 e0       	ldi	r17, 0x01	; 1
    540e:	fc 01       	movw	r30, r24
    5410:	60 81       	ld	r22, Z
    5412:	71 81       	ldd	r23, Z+1	; 0x01
    5414:	82 81       	ldd	r24, Z+2	; 0x02
    5416:	93 81       	ldd	r25, Z+3	; 0x03
    5418:	20 e0       	ldi	r18, 0x00	; 0
    541a:	30 e0       	ldi	r19, 0x00	; 0
    541c:	40 e8       	ldi	r20, 0x80	; 128
    541e:	5f e3       	ldi	r21, 0x3F	; 63
    5420:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    5424:	88 23       	and	r24, r24
    5426:	0c f0       	brlt	.+2      	; 0x542a <chb_set_state+0x7b4>
    5428:	10 e0       	ldi	r17, 0x00	; 0
    542a:	11 23       	and	r17, r17
    542c:	49 f0       	breq	.+18     	; 0x5440 <chb_set_state+0x7ca>
		__ticks = 1;
    542e:	ce 01       	movw	r24, r28
    5430:	85 5a       	subi	r24, 0xA5	; 165
    5432:	9f 4f       	sbci	r25, 0xFF	; 255
    5434:	21 e0       	ldi	r18, 0x01	; 1
    5436:	30 e0       	ldi	r19, 0x00	; 0
    5438:	fc 01       	movw	r30, r24
    543a:	20 83       	st	Z, r18
    543c:	31 83       	std	Z+1, r19	; 0x01
    543e:	74 c0       	rjmp	.+232    	; 0x5528 <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    5440:	ce 01       	movw	r24, r28
    5442:	89 5a       	subi	r24, 0xA9	; 169
    5444:	9f 4f       	sbci	r25, 0xFF	; 255
    5446:	11 e0       	ldi	r17, 0x01	; 1
    5448:	fc 01       	movw	r30, r24
    544a:	60 81       	ld	r22, Z
    544c:	71 81       	ldd	r23, Z+1	; 0x01
    544e:	82 81       	ldd	r24, Z+2	; 0x02
    5450:	93 81       	ldd	r25, Z+3	; 0x03
    5452:	20 e0       	ldi	r18, 0x00	; 0
    5454:	3f ef       	ldi	r19, 0xFF	; 255
    5456:	4f e7       	ldi	r20, 0x7F	; 127
    5458:	57 e4       	ldi	r21, 0x47	; 71
    545a:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    545e:	18 16       	cp	r1, r24
    5460:	0c f0       	brlt	.+2      	; 0x5464 <chb_set_state+0x7ee>
    5462:	10 e0       	ldi	r17, 0x00	; 0
    5464:	11 23       	and	r17, r17
    5466:	09 f4       	brne	.+2      	; 0x546a <chb_set_state+0x7f4>
    5468:	4d c0       	rjmp	.+154    	; 0x5504 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    546a:	ce 01       	movw	r24, r28
    546c:	8d 5a       	subi	r24, 0xAD	; 173
    546e:	9f 4f       	sbci	r25, 0xFF	; 255
    5470:	fc 01       	movw	r30, r24
    5472:	60 81       	ld	r22, Z
    5474:	71 81       	ldd	r23, Z+1	; 0x01
    5476:	82 81       	ldd	r24, Z+2	; 0x02
    5478:	93 81       	ldd	r25, Z+3	; 0x03
    547a:	20 e0       	ldi	r18, 0x00	; 0
    547c:	30 e0       	ldi	r19, 0x00	; 0
    547e:	40 e2       	ldi	r20, 0x20	; 32
    5480:	51 e4       	ldi	r21, 0x41	; 65
    5482:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    5486:	dc 01       	movw	r26, r24
    5488:	cb 01       	movw	r24, r22
    548a:	8e 01       	movw	r16, r28
    548c:	05 5a       	subi	r16, 0xA5	; 165
    548e:	1f 4f       	sbci	r17, 0xFF	; 255
    5490:	bc 01       	movw	r22, r24
    5492:	cd 01       	movw	r24, r26
    5494:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    5498:	dc 01       	movw	r26, r24
    549a:	cb 01       	movw	r24, r22
    549c:	f8 01       	movw	r30, r16
    549e:	80 83       	st	Z, r24
    54a0:	91 83       	std	Z+1, r25	; 0x01
    54a2:	27 c0       	rjmp	.+78     	; 0x54f2 <chb_set_state+0x87c>
    54a4:	ce 01       	movw	r24, r28
    54a6:	83 5a       	subi	r24, 0xA3	; 163
    54a8:	9f 4f       	sbci	r25, 0xFF	; 255
    54aa:	29 e1       	ldi	r18, 0x19	; 25
    54ac:	30 e0       	ldi	r19, 0x00	; 0
    54ae:	fc 01       	movw	r30, r24
    54b0:	20 83       	st	Z, r18
    54b2:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    54b4:	ce 01       	movw	r24, r28
    54b6:	83 5a       	subi	r24, 0xA3	; 163
    54b8:	9f 4f       	sbci	r25, 0xFF	; 255
    54ba:	fc 01       	movw	r30, r24
    54bc:	80 81       	ld	r24, Z
    54be:	91 81       	ldd	r25, Z+1	; 0x01
    54c0:	8c 01       	movw	r16, r24
    54c2:	c8 01       	movw	r24, r16
    54c4:	01 97       	sbiw	r24, 0x01	; 1
    54c6:	f1 f7       	brne	.-4      	; 0x54c4 <chb_set_state+0x84e>
    54c8:	8c 01       	movw	r16, r24
    54ca:	ce 01       	movw	r24, r28
    54cc:	83 5a       	subi	r24, 0xA3	; 163
    54ce:	9f 4f       	sbci	r25, 0xFF	; 255
    54d0:	fc 01       	movw	r30, r24
    54d2:	00 83       	st	Z, r16
    54d4:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    54d6:	ce 01       	movw	r24, r28
    54d8:	85 5a       	subi	r24, 0xA5	; 165
    54da:	9f 4f       	sbci	r25, 0xFF	; 255
    54dc:	9e 01       	movw	r18, r28
    54de:	25 5a       	subi	r18, 0xA5	; 165
    54e0:	3f 4f       	sbci	r19, 0xFF	; 255
    54e2:	f9 01       	movw	r30, r18
    54e4:	20 81       	ld	r18, Z
    54e6:	31 81       	ldd	r19, Z+1	; 0x01
    54e8:	21 50       	subi	r18, 0x01	; 1
    54ea:	30 40       	sbci	r19, 0x00	; 0
    54ec:	fc 01       	movw	r30, r24
    54ee:	20 83       	st	Z, r18
    54f0:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54f2:	ce 01       	movw	r24, r28
    54f4:	85 5a       	subi	r24, 0xA5	; 165
    54f6:	9f 4f       	sbci	r25, 0xFF	; 255
    54f8:	fc 01       	movw	r30, r24
    54fa:	80 81       	ld	r24, Z
    54fc:	91 81       	ldd	r25, Z+1	; 0x01
    54fe:	00 97       	sbiw	r24, 0x00	; 0
    5500:	89 f6       	brne	.-94     	; 0x54a4 <chb_set_state+0x82e>
    5502:	58 c0       	rjmp	.+176    	; 0x55b4 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5504:	8e 01       	movw	r16, r28
    5506:	05 5a       	subi	r16, 0xA5	; 165
    5508:	1f 4f       	sbci	r17, 0xFF	; 255
    550a:	ce 01       	movw	r24, r28
    550c:	89 5a       	subi	r24, 0xA9	; 169
    550e:	9f 4f       	sbci	r25, 0xFF	; 255
    5510:	fc 01       	movw	r30, r24
    5512:	60 81       	ld	r22, Z
    5514:	71 81       	ldd	r23, Z+1	; 0x01
    5516:	82 81       	ldd	r24, Z+2	; 0x02
    5518:	93 81       	ldd	r25, Z+3	; 0x03
    551a:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    551e:	dc 01       	movw	r26, r24
    5520:	cb 01       	movw	r24, r22
    5522:	f8 01       	movw	r30, r16
    5524:	80 83       	st	Z, r24
    5526:	91 83       	std	Z+1, r25	; 0x01
    5528:	ce 01       	movw	r24, r28
    552a:	81 5a       	subi	r24, 0xA1	; 161
    552c:	9f 4f       	sbci	r25, 0xFF	; 255
    552e:	9e 01       	movw	r18, r28
    5530:	25 5a       	subi	r18, 0xA5	; 165
    5532:	3f 4f       	sbci	r19, 0xFF	; 255
    5534:	f9 01       	movw	r30, r18
    5536:	20 81       	ld	r18, Z
    5538:	31 81       	ldd	r19, Z+1	; 0x01
    553a:	fc 01       	movw	r30, r24
    553c:	20 83       	st	Z, r18
    553e:	31 83       	std	Z+1, r19	; 0x01
    5540:	ce 01       	movw	r24, r28
    5542:	81 5a       	subi	r24, 0xA1	; 161
    5544:	9f 4f       	sbci	r25, 0xFF	; 255
    5546:	fc 01       	movw	r30, r24
    5548:	80 81       	ld	r24, Z
    554a:	91 81       	ldd	r25, Z+1	; 0x01
    554c:	8c 01       	movw	r16, r24
    554e:	c8 01       	movw	r24, r16
    5550:	01 97       	sbiw	r24, 0x01	; 1
    5552:	f1 f7       	brne	.-4      	; 0x5550 <chb_set_state+0x8da>
    5554:	8c 01       	movw	r16, r24
    5556:	ce 01       	movw	r24, r28
    5558:	81 5a       	subi	r24, 0xA1	; 161
    555a:	9f 4f       	sbci	r25, 0xFF	; 255
    555c:	fc 01       	movw	r30, r24
    555e:	00 83       	st	Z, r16
    5560:	11 83       	std	Z+1, r17	; 0x01
    5562:	28 c0       	rjmp	.+80     	; 0x55b4 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5564:	8e 01       	movw	r16, r28
    5566:	0e 5a       	subi	r16, 0xAE	; 174
    5568:	1f 4f       	sbci	r17, 0xFF	; 255
    556a:	ce 01       	movw	r24, r28
    556c:	82 5b       	subi	r24, 0xB2	; 178
    556e:	9f 4f       	sbci	r25, 0xFF	; 255
    5570:	fc 01       	movw	r30, r24
    5572:	60 81       	ld	r22, Z
    5574:	71 81       	ldd	r23, Z+1	; 0x01
    5576:	82 81       	ldd	r24, Z+2	; 0x02
    5578:	93 81       	ldd	r25, Z+3	; 0x03
    557a:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    557e:	dc 01       	movw	r26, r24
    5580:	cb 01       	movw	r24, r22
    5582:	f8 01       	movw	r30, r16
    5584:	80 83       	st	Z, r24
    5586:	ce 01       	movw	r24, r28
    5588:	8f 59       	subi	r24, 0x9F	; 159
    558a:	9f 4f       	sbci	r25, 0xFF	; 255
    558c:	9e 01       	movw	r18, r28
    558e:	2e 5a       	subi	r18, 0xAE	; 174
    5590:	3f 4f       	sbci	r19, 0xFF	; 255
    5592:	f9 01       	movw	r30, r18
    5594:	20 81       	ld	r18, Z
    5596:	fc 01       	movw	r30, r24
    5598:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    559a:	ce 01       	movw	r24, r28
    559c:	8f 59       	subi	r24, 0x9F	; 159
    559e:	9f 4f       	sbci	r25, 0xFF	; 255
    55a0:	fc 01       	movw	r30, r24
    55a2:	80 81       	ld	r24, Z
    55a4:	18 2f       	mov	r17, r24
    55a6:	1a 95       	dec	r17
    55a8:	f1 f7       	brne	.-4      	; 0x55a6 <chb_set_state+0x930>
    55aa:	ce 01       	movw	r24, r28
    55ac:	8f 59       	subi	r24, 0x9F	; 159
    55ae:	9f 4f       	sbci	r25, 0xFF	; 255
    55b0:	fc 01       	movw	r30, r24
    55b2:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    55b4:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <chb_get_state>
    55b8:	28 2f       	mov	r18, r24
    55ba:	ce 01       	movw	r24, r28
    55bc:	8e 59       	subi	r24, 0x9E	; 158
    55be:	9f 4f       	sbci	r25, 0xFF	; 255
    55c0:	fc 01       	movw	r30, r24
    55c2:	80 81       	ld	r24, Z
    55c4:	28 17       	cp	r18, r24
    55c6:	11 f4       	brne	.+4      	; 0x55cc <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    55c8:	80 e4       	ldi	r24, 0x40	; 64
    55ca:	01 c0       	rjmp	.+2      	; 0x55ce <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    55cc:	83 e4       	ldi	r24, 0x43	; 67
}
    55ce:	ce 59       	subi	r28, 0x9E	; 158
    55d0:	df 4f       	sbci	r29, 0xFF	; 255
    55d2:	cd bf       	out	0x3d, r28	; 61
    55d4:	de bf       	out	0x3e, r29	; 62
    55d6:	df 91       	pop	r29
    55d8:	cf 91       	pop	r28
    55da:	1f 91       	pop	r17
    55dc:	0f 91       	pop	r16
    55de:	08 95       	ret

000055e0 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    55e0:	cf 93       	push	r28
    55e2:	df 93       	push	r29
    55e4:	0f 92       	push	r0
    55e6:	0f 92       	push	r0
    55e8:	cd b7       	in	r28, 0x3d	; 61
    55ea:	de b7       	in	r29, 0x3e	; 62
    55ec:	89 83       	std	Y+1, r24	; 0x01
    55ee:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    55f0:	29 81       	ldd	r18, Y+1	; 0x01
    55f2:	3a 81       	ldd	r19, Y+2	; 0x02
    55f4:	80 e0       	ldi	r24, 0x00	; 0
    55f6:	90 e0       	ldi	r25, 0x00	; 0
    55f8:	b9 01       	movw	r22, r18
    55fa:	48 e0       	ldi	r20, 0x08	; 8
    55fc:	50 e0       	ldi	r21, 0x00	; 0
    55fe:	0e 94 13 2f 	call	0x5e26	; 0x5e26 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5602:	29 81       	ldd	r18, Y+1	; 0x01
    5604:	3a 81       	ldd	r19, Y+2	; 0x02
    5606:	84 e2       	ldi	r24, 0x24	; 36
    5608:	b9 01       	movw	r22, r18
    560a:	0e 94 95 23 	call	0x472a	; 0x472a <chb_reg_write64>
}
    560e:	0f 90       	pop	r0
    5610:	0f 90       	pop	r0
    5612:	df 91       	pop	r29
    5614:	cf 91       	pop	r28
    5616:	08 95       	ret

00005618 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5618:	cf 93       	push	r28
    561a:	df 93       	push	r29
    561c:	0f 92       	push	r0
    561e:	0f 92       	push	r0
    5620:	cd b7       	in	r28, 0x3d	; 61
    5622:	de b7       	in	r29, 0x3e	; 62
    5624:	89 83       	std	Y+1, r24	; 0x01
    5626:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5628:	29 81       	ldd	r18, Y+1	; 0x01
    562a:	3a 81       	ldd	r19, Y+2	; 0x02
    562c:	80 e0       	ldi	r24, 0x00	; 0
    562e:	90 e0       	ldi	r25, 0x00	; 0
    5630:	b9 01       	movw	r22, r18
    5632:	48 e0       	ldi	r20, 0x08	; 8
    5634:	50 e0       	ldi	r21, 0x00	; 0
    5636:	0e 94 4f 2f 	call	0x5e9e	; 0x5e9e <chb_eeprom_read>
}
    563a:	0f 90       	pop	r0
    563c:	0f 90       	pop	r0
    563e:	df 91       	pop	r29
    5640:	cf 91       	pop	r28
    5642:	08 95       	ret

00005644 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5644:	cf 93       	push	r28
    5646:	df 93       	push	r29
    5648:	00 d0       	rcall	.+0      	; 0x564a <chb_set_short_addr+0x6>
    564a:	00 d0       	rcall	.+0      	; 0x564c <chb_set_short_addr+0x8>
    564c:	cd b7       	in	r28, 0x3d	; 61
    564e:	de b7       	in	r29, 0x3e	; 62
    5650:	8d 83       	std	Y+5, r24	; 0x05
    5652:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5654:	ce 01       	movw	r24, r28
    5656:	05 96       	adiw	r24, 0x05	; 5
    5658:	89 83       	std	Y+1, r24	; 0x01
    565a:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    565c:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <chb_get_pcb>
    5660:	8b 83       	std	Y+3, r24	; 0x03
    5662:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5664:	29 81       	ldd	r18, Y+1	; 0x01
    5666:	3a 81       	ldd	r19, Y+2	; 0x02
    5668:	89 e0       	ldi	r24, 0x09	; 9
    566a:	90 e0       	ldi	r25, 0x00	; 0
    566c:	b9 01       	movw	r22, r18
    566e:	42 e0       	ldi	r20, 0x02	; 2
    5670:	50 e0       	ldi	r21, 0x00	; 0
    5672:	0e 94 13 2f 	call	0x5e26	; 0x5e26 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    5676:	2d 81       	ldd	r18, Y+5	; 0x05
    5678:	3e 81       	ldd	r19, Y+6	; 0x06
    567a:	80 e2       	ldi	r24, 0x20	; 32
    567c:	b9 01       	movw	r22, r18
    567e:	0e 94 64 23 	call	0x46c8	; 0x46c8 <chb_reg_write16>
    pcb->src_addr = addr;
    5682:	2d 81       	ldd	r18, Y+5	; 0x05
    5684:	3e 81       	ldd	r19, Y+6	; 0x06
    5686:	8b 81       	ldd	r24, Y+3	; 0x03
    5688:	9c 81       	ldd	r25, Y+4	; 0x04
    568a:	fc 01       	movw	r30, r24
    568c:	20 83       	st	Z, r18
    568e:	31 83       	std	Z+1, r19	; 0x01
}
    5690:	26 96       	adiw	r28, 0x06	; 6
    5692:	cd bf       	out	0x3d, r28	; 61
    5694:	de bf       	out	0x3e, r29	; 62
    5696:	df 91       	pop	r29
    5698:	cf 91       	pop	r28
    569a:	08 95       	ret

0000569c <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    569c:	cf 93       	push	r28
    569e:	df 93       	push	r29
    56a0:	0f 92       	push	r0
    56a2:	0f 92       	push	r0
    56a4:	cd b7       	in	r28, 0x3d	; 61
    56a6:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    56a8:	89 e0       	ldi	r24, 0x09	; 9
    56aa:	90 e0       	ldi	r25, 0x00	; 0
    56ac:	9e 01       	movw	r18, r28
    56ae:	2f 5f       	subi	r18, 0xFF	; 255
    56b0:	3f 4f       	sbci	r19, 0xFF	; 255
    56b2:	b9 01       	movw	r22, r18
    56b4:	42 e0       	ldi	r20, 0x02	; 2
    56b6:	50 e0       	ldi	r21, 0x00	; 0
    56b8:	0e 94 4f 2f 	call	0x5e9e	; 0x5e9e <chb_eeprom_read>
    return *(U16 *)addr;
    56bc:	ce 01       	movw	r24, r28
    56be:	01 96       	adiw	r24, 0x01	; 1
    56c0:	fc 01       	movw	r30, r24
    56c2:	80 81       	ld	r24, Z
    56c4:	91 81       	ldd	r25, Z+1	; 0x01
}
    56c6:	0f 90       	pop	r0
    56c8:	0f 90       	pop	r0
    56ca:	df 91       	pop	r29
    56cc:	cf 91       	pop	r28
    56ce:	08 95       	ret

000056d0 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    56d0:	cf 93       	push	r28
    56d2:	df 93       	push	r29
    56d4:	cd b7       	in	r28, 0x3d	; 61
    56d6:	de b7       	in	r29, 0x3e	; 62
    56d8:	28 97       	sbiw	r28, 0x08	; 8
    56da:	cd bf       	out	0x3d, r28	; 61
    56dc:	de bf       	out	0x3e, r29	; 62
    56de:	8c 83       	std	Y+4, r24	; 0x04
    56e0:	9d 83       	std	Y+5, r25	; 0x05
    56e2:	6e 83       	std	Y+6, r22	; 0x06
    56e4:	7f 83       	std	Y+7, r23	; 0x07
    56e6:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    56e8:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <chb_get_state>
    56ec:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    56ee:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <chb_get_pcb>
    56f2:	8a 83       	std	Y+2, r24	; 0x02
    56f4:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    56f6:	89 81       	ldd	r24, Y+1	; 0x01
    56f8:	82 30       	cpi	r24, 0x02	; 2
    56fa:	19 f0       	breq	.+6      	; 0x5702 <chb_tx+0x32>
    56fc:	89 81       	ldd	r24, Y+1	; 0x01
    56fe:	82 31       	cpi	r24, 0x12	; 18
    5700:	11 f4       	brne	.+4      	; 0x5706 <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5702:	84 e4       	ldi	r24, 0x44	; 68
    5704:	23 c0       	rjmp	.+70     	; 0x574c <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5706:	88 e0       	ldi	r24, 0x08	; 8
    5708:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    570c:	89 e1       	ldi	r24, 0x19	; 25
    570e:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5712:	8c 81       	ldd	r24, Y+4	; 0x04
    5714:	9d 81       	ldd	r25, Y+5	; 0x05
    5716:	2e 81       	ldd	r18, Y+6	; 0x06
    5718:	3f 81       	ldd	r19, Y+7	; 0x07
    571a:	6a e0       	ldi	r22, 0x0A	; 10
    571c:	a9 01       	movw	r20, r18
    571e:	28 85       	ldd	r18, Y+8	; 0x08
    5720:	0e 94 e2 23 	call	0x47c4	; 0x47c4 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5724:	82 e0       	ldi	r24, 0x02	; 2
    5726:	62 e0       	ldi	r22, 0x02	; 2
    5728:	4f e1       	ldi	r20, 0x1F	; 31
    572a:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    572e:	00 00       	nop
    5730:	8a 81       	ldd	r24, Y+2	; 0x02
    5732:	9b 81       	ldd	r25, Y+3	; 0x03
    5734:	fc 01       	movw	r30, r24
    5736:	94 81       	ldd	r25, Z+4	; 0x04
    5738:	81 e0       	ldi	r24, 0x01	; 1
    573a:	89 27       	eor	r24, r25
    573c:	88 23       	and	r24, r24
    573e:	c1 f7       	brne	.-16     	; 0x5730 <chb_tx+0x60>
    pcb->tx_end = false;
    5740:	8a 81       	ldd	r24, Y+2	; 0x02
    5742:	9b 81       	ldd	r25, Y+3	; 0x03
    5744:	fc 01       	movw	r30, r24
    5746:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5748:	0e 94 df 20 	call	0x41be	; 0x41be <chb_get_status>
}
    574c:	28 96       	adiw	r28, 0x08	; 8
    574e:	cd bf       	out	0x3d, r28	; 61
    5750:	de bf       	out	0x3e, r29	; 62
    5752:	df 91       	pop	r29
    5754:	cf 91       	pop	r28
    5756:	08 95       	ret

00005758 <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5758:	0f 93       	push	r16
    575a:	1f 93       	push	r17
    575c:	cf 93       	push	r28
    575e:	df 93       	push	r29
    5760:	cd b7       	in	r28, 0x3d	; 61
    5762:	de b7       	in	r29, 0x3e	; 62
    5764:	69 97       	sbiw	r28, 0x19	; 25
    5766:	cd bf       	out	0x3d, r28	; 61
    5768:	de bf       	out	0x3e, r29	; 62
    576a:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    576c:	89 8d       	ldd	r24, Y+25	; 0x19
    576e:	88 23       	and	r24, r24
    5770:	69 f0       	breq	.+26     	; 0x578c <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5772:	88 e0       	ldi	r24, 0x08	; 8
    5774:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5778:	84 e6       	ldi	r24, 0x64	; 100
    577a:	96 e0       	ldi	r25, 0x06	; 6
    577c:	24 e6       	ldi	r18, 0x64	; 100
    577e:	36 e0       	ldi	r19, 0x06	; 6
    5780:	f9 01       	movw	r30, r18
    5782:	20 81       	ld	r18, Z
    5784:	22 60       	ori	r18, 0x02	; 2
    5786:	fc 01       	movw	r30, r24
    5788:	20 83       	st	Z, r18
    578a:	e1 c0       	rjmp	.+450    	; 0x594e <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    578c:	84 e6       	ldi	r24, 0x64	; 100
    578e:	96 e0       	ldi	r25, 0x06	; 6
    5790:	24 e6       	ldi	r18, 0x64	; 100
    5792:	36 e0       	ldi	r19, 0x06	; 6
    5794:	f9 01       	movw	r30, r18
    5796:	20 81       	ld	r18, Z
    5798:	2d 7f       	andi	r18, 0xFD	; 253
    579a:	fc 01       	movw	r30, r24
    579c:	20 83       	st	Z, r18
    579e:	80 e0       	ldi	r24, 0x00	; 0
    57a0:	90 e0       	ldi	r25, 0x00	; 0
    57a2:	a0 e7       	ldi	r26, 0x70	; 112
    57a4:	b3 e4       	ldi	r27, 0x43	; 67
    57a6:	89 83       	std	Y+1, r24	; 0x01
    57a8:	9a 83       	std	Y+2, r25	; 0x02
    57aa:	ab 83       	std	Y+3, r26	; 0x03
    57ac:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    57ae:	69 81       	ldd	r22, Y+1	; 0x01
    57b0:	7a 81       	ldd	r23, Y+2	; 0x02
    57b2:	8b 81       	ldd	r24, Y+3	; 0x03
    57b4:	9c 81       	ldd	r25, Y+4	; 0x04
    57b6:	2b ea       	ldi	r18, 0xAB	; 171
    57b8:	3a ea       	ldi	r19, 0xAA	; 170
    57ba:	4a ea       	ldi	r20, 0xAA	; 170
    57bc:	5e e3       	ldi	r21, 0x3E	; 62
    57be:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    57c2:	dc 01       	movw	r26, r24
    57c4:	cb 01       	movw	r24, r22
    57c6:	8d 83       	std	Y+5, r24	; 0x05
    57c8:	9e 83       	std	Y+6, r25	; 0x06
    57ca:	af 83       	std	Y+7, r26	; 0x07
    57cc:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    57ce:	11 e0       	ldi	r17, 0x01	; 1
    57d0:	6d 81       	ldd	r22, Y+5	; 0x05
    57d2:	7e 81       	ldd	r23, Y+6	; 0x06
    57d4:	8f 81       	ldd	r24, Y+7	; 0x07
    57d6:	98 85       	ldd	r25, Y+8	; 0x08
    57d8:	20 e0       	ldi	r18, 0x00	; 0
    57da:	30 e0       	ldi	r19, 0x00	; 0
    57dc:	40 e8       	ldi	r20, 0x80	; 128
    57de:	5f e3       	ldi	r21, 0x3F	; 63
    57e0:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    57e4:	88 23       	and	r24, r24
    57e6:	0c f0       	brlt	.+2      	; 0x57ea <chb_sleep+0x92>
    57e8:	10 e0       	ldi	r17, 0x00	; 0
    57ea:	11 23       	and	r17, r17
    57ec:	19 f0       	breq	.+6      	; 0x57f4 <chb_sleep+0x9c>
		__ticks = 1;
    57ee:	81 e0       	ldi	r24, 0x01	; 1
    57f0:	89 87       	std	Y+9, r24	; 0x09
    57f2:	a3 c0       	rjmp	.+326    	; 0x593a <chb_sleep+0x1e2>
	else if (__tmp > 255)
    57f4:	11 e0       	ldi	r17, 0x01	; 1
    57f6:	6d 81       	ldd	r22, Y+5	; 0x05
    57f8:	7e 81       	ldd	r23, Y+6	; 0x06
    57fa:	8f 81       	ldd	r24, Y+7	; 0x07
    57fc:	98 85       	ldd	r25, Y+8	; 0x08
    57fe:	20 e0       	ldi	r18, 0x00	; 0
    5800:	30 e0       	ldi	r19, 0x00	; 0
    5802:	4f e7       	ldi	r20, 0x7F	; 127
    5804:	53 e4       	ldi	r21, 0x43	; 67
    5806:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    580a:	18 16       	cp	r1, r24
    580c:	0c f0       	brlt	.+2      	; 0x5810 <chb_sleep+0xb8>
    580e:	10 e0       	ldi	r17, 0x00	; 0
    5810:	11 23       	and	r17, r17
    5812:	09 f4       	brne	.+2      	; 0x5816 <chb_sleep+0xbe>
    5814:	89 c0       	rjmp	.+274    	; 0x5928 <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5816:	69 81       	ldd	r22, Y+1	; 0x01
    5818:	7a 81       	ldd	r23, Y+2	; 0x02
    581a:	8b 81       	ldd	r24, Y+3	; 0x03
    581c:	9c 81       	ldd	r25, Y+4	; 0x04
    581e:	20 e0       	ldi	r18, 0x00	; 0
    5820:	30 e0       	ldi	r19, 0x00	; 0
    5822:	4a e7       	ldi	r20, 0x7A	; 122
    5824:	54 e4       	ldi	r21, 0x44	; 68
    5826:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    582a:	dc 01       	movw	r26, r24
    582c:	cb 01       	movw	r24, r22
    582e:	8a 87       	std	Y+10, r24	; 0x0a
    5830:	9b 87       	std	Y+11, r25	; 0x0b
    5832:	ac 87       	std	Y+12, r26	; 0x0c
    5834:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5836:	6a 85       	ldd	r22, Y+10	; 0x0a
    5838:	7b 85       	ldd	r23, Y+11	; 0x0b
    583a:	8c 85       	ldd	r24, Y+12	; 0x0c
    583c:	9d 85       	ldd	r25, Y+13	; 0x0d
    583e:	20 e0       	ldi	r18, 0x00	; 0
    5840:	30 e0       	ldi	r19, 0x00	; 0
    5842:	4a e7       	ldi	r20, 0x7A	; 122
    5844:	53 e4       	ldi	r21, 0x43	; 67
    5846:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    584a:	dc 01       	movw	r26, r24
    584c:	cb 01       	movw	r24, r22
    584e:	8e 87       	std	Y+14, r24	; 0x0e
    5850:	9f 87       	std	Y+15, r25	; 0x0f
    5852:	a8 8b       	std	Y+16, r26	; 0x10
    5854:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5856:	11 e0       	ldi	r17, 0x01	; 1
    5858:	6e 85       	ldd	r22, Y+14	; 0x0e
    585a:	7f 85       	ldd	r23, Y+15	; 0x0f
    585c:	88 89       	ldd	r24, Y+16	; 0x10
    585e:	99 89       	ldd	r25, Y+17	; 0x11
    5860:	20 e0       	ldi	r18, 0x00	; 0
    5862:	30 e0       	ldi	r19, 0x00	; 0
    5864:	40 e8       	ldi	r20, 0x80	; 128
    5866:	5f e3       	ldi	r21, 0x3F	; 63
    5868:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    586c:	88 23       	and	r24, r24
    586e:	0c f0       	brlt	.+2      	; 0x5872 <chb_sleep+0x11a>
    5870:	10 e0       	ldi	r17, 0x00	; 0
    5872:	11 23       	and	r17, r17
    5874:	29 f0       	breq	.+10     	; 0x5880 <chb_sleep+0x128>
		__ticks = 1;
    5876:	81 e0       	ldi	r24, 0x01	; 1
    5878:	90 e0       	ldi	r25, 0x00	; 0
    587a:	8a 8b       	std	Y+18, r24	; 0x12
    587c:	9b 8b       	std	Y+19, r25	; 0x13
    587e:	46 c0       	rjmp	.+140    	; 0x590c <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5880:	11 e0       	ldi	r17, 0x01	; 1
    5882:	6e 85       	ldd	r22, Y+14	; 0x0e
    5884:	7f 85       	ldd	r23, Y+15	; 0x0f
    5886:	88 89       	ldd	r24, Y+16	; 0x10
    5888:	99 89       	ldd	r25, Y+17	; 0x11
    588a:	20 e0       	ldi	r18, 0x00	; 0
    588c:	3f ef       	ldi	r19, 0xFF	; 255
    588e:	4f e7       	ldi	r20, 0x7F	; 127
    5890:	57 e4       	ldi	r21, 0x47	; 71
    5892:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    5896:	18 16       	cp	r1, r24
    5898:	0c f0       	brlt	.+2      	; 0x589c <chb_sleep+0x144>
    589a:	10 e0       	ldi	r17, 0x00	; 0
    589c:	11 23       	and	r17, r17
    589e:	61 f1       	breq	.+88     	; 0x58f8 <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    58a0:	6a 85       	ldd	r22, Y+10	; 0x0a
    58a2:	7b 85       	ldd	r23, Y+11	; 0x0b
    58a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    58a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    58a8:	20 e0       	ldi	r18, 0x00	; 0
    58aa:	30 e0       	ldi	r19, 0x00	; 0
    58ac:	40 e2       	ldi	r20, 0x20	; 32
    58ae:	51 e4       	ldi	r21, 0x41	; 65
    58b0:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    58b4:	dc 01       	movw	r26, r24
    58b6:	cb 01       	movw	r24, r22
    58b8:	bc 01       	movw	r22, r24
    58ba:	cd 01       	movw	r24, r26
    58bc:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    58c0:	dc 01       	movw	r26, r24
    58c2:	cb 01       	movw	r24, r22
    58c4:	8a 8b       	std	Y+18, r24	; 0x12
    58c6:	9b 8b       	std	Y+19, r25	; 0x13
    58c8:	12 c0       	rjmp	.+36     	; 0x58ee <chb_sleep+0x196>
    58ca:	89 e1       	ldi	r24, 0x19	; 25
    58cc:	90 e0       	ldi	r25, 0x00	; 0
    58ce:	8c 8b       	std	Y+20, r24	; 0x14
    58d0:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    58d2:	8c 89       	ldd	r24, Y+20	; 0x14
    58d4:	9d 89       	ldd	r25, Y+21	; 0x15
    58d6:	8c 01       	movw	r16, r24
    58d8:	c8 01       	movw	r24, r16
    58da:	01 97       	sbiw	r24, 0x01	; 1
    58dc:	f1 f7       	brne	.-4      	; 0x58da <chb_sleep+0x182>
    58de:	8c 01       	movw	r16, r24
    58e0:	0c 8b       	std	Y+20, r16	; 0x14
    58e2:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    58e4:	8a 89       	ldd	r24, Y+18	; 0x12
    58e6:	9b 89       	ldd	r25, Y+19	; 0x13
    58e8:	01 97       	sbiw	r24, 0x01	; 1
    58ea:	8a 8b       	std	Y+18, r24	; 0x12
    58ec:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    58ee:	8a 89       	ldd	r24, Y+18	; 0x12
    58f0:	9b 89       	ldd	r25, Y+19	; 0x13
    58f2:	00 97       	sbiw	r24, 0x00	; 0
    58f4:	51 f7       	brne	.-44     	; 0x58ca <chb_sleep+0x172>
    58f6:	28 c0       	rjmp	.+80     	; 0x5948 <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    58f8:	6e 85       	ldd	r22, Y+14	; 0x0e
    58fa:	7f 85       	ldd	r23, Y+15	; 0x0f
    58fc:	88 89       	ldd	r24, Y+16	; 0x10
    58fe:	99 89       	ldd	r25, Y+17	; 0x11
    5900:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    5904:	dc 01       	movw	r26, r24
    5906:	cb 01       	movw	r24, r22
    5908:	8a 8b       	std	Y+18, r24	; 0x12
    590a:	9b 8b       	std	Y+19, r25	; 0x13
    590c:	8a 89       	ldd	r24, Y+18	; 0x12
    590e:	9b 89       	ldd	r25, Y+19	; 0x13
    5910:	8e 8b       	std	Y+22, r24	; 0x16
    5912:	9f 8b       	std	Y+23, r25	; 0x17
    5914:	8e 89       	ldd	r24, Y+22	; 0x16
    5916:	9f 89       	ldd	r25, Y+23	; 0x17
    5918:	8c 01       	movw	r16, r24
    591a:	f8 01       	movw	r30, r16
    591c:	31 97       	sbiw	r30, 0x01	; 1
    591e:	f1 f7       	brne	.-4      	; 0x591c <chb_sleep+0x1c4>
    5920:	8f 01       	movw	r16, r30
    5922:	0e 8b       	std	Y+22, r16	; 0x16
    5924:	1f 8b       	std	Y+23, r17	; 0x17
    5926:	10 c0       	rjmp	.+32     	; 0x5948 <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5928:	6d 81       	ldd	r22, Y+5	; 0x05
    592a:	7e 81       	ldd	r23, Y+6	; 0x06
    592c:	8f 81       	ldd	r24, Y+7	; 0x07
    592e:	98 85       	ldd	r25, Y+8	; 0x08
    5930:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    5934:	dc 01       	movw	r26, r24
    5936:	cb 01       	movw	r24, r22
    5938:	89 87       	std	Y+9, r24	; 0x09
    593a:	89 85       	ldd	r24, Y+9	; 0x09
    593c:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    593e:	88 8d       	ldd	r24, Y+24	; 0x18
    5940:	18 2f       	mov	r17, r24
    5942:	1a 95       	dec	r17
    5944:	f1 f7       	brne	.-4      	; 0x5942 <chb_sleep+0x1ea>
    5946:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5948:	86 e1       	ldi	r24, 0x16	; 22
    594a:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <chb_set_state>
    }
}
    594e:	69 96       	adiw	r28, 0x19	; 25
    5950:	cd bf       	out	0x3d, r28	; 61
    5952:	de bf       	out	0x3e, r29	; 62
    5954:	df 91       	pop	r29
    5956:	cf 91       	pop	r28
    5958:	1f 91       	pop	r17
    595a:	0f 91       	pop	r16
    595c:	08 95       	ret

0000595e <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    595e:	cf 93       	push	r28
    5960:	df 93       	push	r29
    5962:	cd b7       	in	r28, 0x3d	; 61
    5964:	de b7       	in	r29, 0x3e	; 62
    5966:	ea 97       	sbiw	r28, 0x3a	; 58
    5968:	cd bf       	out	0x3d, r28	; 61
    596a:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    596c:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5970:	8e e0       	ldi	r24, 0x0E	; 14
    5972:	60 e0       	ldi	r22, 0x00	; 0
    5974:	0e 94 38 23 	call	0x4670	; 0x4670 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5978:	82 e0       	ldi	r24, 0x02	; 2
    597a:	63 e0       	ldi	r22, 0x03	; 3
    597c:	4f e1       	ldi	r20, 0x1F	; 31
    597e:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5982:	00 00       	nop
    5984:	81 e0       	ldi	r24, 0x01	; 1
    5986:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    598a:	88 2f       	mov	r24, r24
    598c:	90 e0       	ldi	r25, 0x00	; 0
    598e:	8f 71       	andi	r24, 0x1F	; 31
    5990:	90 70       	andi	r25, 0x00	; 0
    5992:	88 30       	cpi	r24, 0x08	; 8
    5994:	91 05       	cpc	r25, r1
    5996:	b1 f7       	brne	.-20     	; 0x5984 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5998:	8e e2       	ldi	r24, 0x2E	; 46
    599a:	60 e4       	ldi	r22, 0x40	; 64
    599c:	40 ec       	ldi	r20, 0xC0	; 192
    599e:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    59a2:	8e e0       	ldi	r24, 0x0E	; 14
    59a4:	6c e0       	ldi	r22, 0x0C	; 12
    59a6:	0e 94 38 23 	call	0x4670	; 0x4670 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    59aa:	84 e0       	ldi	r24, 0x04	; 4
    59ac:	60 e2       	ldi	r22, 0x20	; 32
    59ae:	40 e2       	ldi	r20, 0x20	; 32
    59b0:	0e 94 bd 23 	call	0x477a	; 0x477a <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    59b4:	81 e0       	ldi	r24, 0x01	; 1
    59b6:	0e 94 dd 24 	call	0x49ba	; 0x49ba <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    59ba:	81 e0       	ldi	r24, 0x01	; 1
    59bc:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    59c0:	86 e1       	ldi	r24, 0x16	; 22
    59c2:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    59c6:	82 e2       	ldi	r24, 0x22	; 34
    59c8:	64 e3       	ldi	r22, 0x34	; 52
    59ca:	72 e1       	ldi	r23, 0x12	; 18
    59cc:	0e 94 64 23 	call	0x46c8	; 0x46c8 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    59d0:	0e 94 4e 2b 	call	0x569c	; 0x569c <chb_get_short_addr>
    59d4:	9c 01       	movw	r18, r24
    59d6:	80 e2       	ldi	r24, 0x20	; 32
    59d8:	b9 01       	movw	r22, r18
    59da:	0e 94 64 23 	call	0x46c8	; 0x46c8 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    59de:	ce 01       	movw	r24, r28
    59e0:	01 96       	adiw	r24, 0x01	; 1
    59e2:	0e 94 0c 2b 	call	0x5618	; 0x5618 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    59e6:	84 e2       	ldi	r24, 0x24	; 36
    59e8:	9e 01       	movw	r18, r28
    59ea:	2f 5f       	subi	r18, 0xFF	; 255
    59ec:	3f 4f       	sbci	r19, 0xFF	; 255
    59ee:	b9 01       	movw	r22, r18
    59f0:	0e 94 95 23 	call	0x472a	; 0x472a <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    59f4:	82 e7       	ldi	r24, 0x72	; 114
    59f6:	96 e0       	ldi	r25, 0x06	; 6
    59f8:	22 e7       	ldi	r18, 0x72	; 114
    59fa:	36 e0       	ldi	r19, 0x06	; 6
    59fc:	f9 01       	movw	r30, r18
    59fe:	20 81       	ld	r18, Z
    5a00:	21 60       	ori	r18, 0x01	; 1
    5a02:	fc 01       	movw	r30, r24
    5a04:	20 83       	st	Z, r18
    5a06:	89 e6       	ldi	r24, 0x69	; 105
    5a08:	96 e0       	ldi	r25, 0x06	; 6
    5a0a:	29 e6       	ldi	r18, 0x69	; 105
    5a0c:	36 e0       	ldi	r19, 0x06	; 6
    5a0e:	f9 01       	movw	r30, r18
    5a10:	20 81       	ld	r18, Z
    5a12:	23 60       	ori	r18, 0x03	; 3
    5a14:	fc 01       	movw	r30, r24
    5a16:	20 83       	st	Z, r18
    5a18:	8a e6       	ldi	r24, 0x6A	; 106
    5a1a:	96 e0       	ldi	r25, 0x06	; 6
    5a1c:	2a e6       	ldi	r18, 0x6A	; 106
    5a1e:	36 e0       	ldi	r19, 0x06	; 6
    5a20:	f9 01       	movw	r30, r18
    5a22:	20 81       	ld	r18, Z
    5a24:	24 60       	ori	r18, 0x04	; 4
    5a26:	fc 01       	movw	r30, r24
    5a28:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5a2a:	80 ea       	ldi	r24, 0xA0	; 160
    5a2c:	90 e0       	ldi	r25, 0x00	; 0
    5a2e:	20 ea       	ldi	r18, 0xA0	; 160
    5a30:	30 e0       	ldi	r19, 0x00	; 0
    5a32:	f9 01       	movw	r30, r18
    5a34:	22 81       	ldd	r18, Z+2	; 0x02
    5a36:	27 60       	ori	r18, 0x07	; 7
    5a38:	fc 01       	movw	r30, r24
    5a3a:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5a3c:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <chb_get_state>
    5a40:	86 31       	cpi	r24, 0x16	; 22
    5a42:	b1 f0       	breq	.+44     	; 0x5a70 <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5a44:	ce 01       	movw	r24, r28
    5a46:	09 96       	adiw	r24, 0x09	; 9
    5a48:	2c e0       	ldi	r18, 0x0C	; 12
    5a4a:	32 e0       	ldi	r19, 0x02	; 2
    5a4c:	b9 01       	movw	r22, r18
    5a4e:	0e 94 58 62 	call	0xc4b0	; 0xc4b0 <strcpy_P>
        printf(buf);
    5a52:	0f 92       	push	r0
    5a54:	0f 92       	push	r0
    5a56:	8d b7       	in	r24, 0x3d	; 61
    5a58:	9e b7       	in	r25, 0x3e	; 62
    5a5a:	01 96       	adiw	r24, 0x01	; 1
    5a5c:	9e 01       	movw	r18, r28
    5a5e:	27 5f       	subi	r18, 0xF7	; 247
    5a60:	3f 4f       	sbci	r19, 0xFF	; 255
    5a62:	fc 01       	movw	r30, r24
    5a64:	20 83       	st	Z, r18
    5a66:	31 83       	std	Z+1, r19	; 0x01
    5a68:	0e 94 b4 62 	call	0xc568	; 0xc568 <printf>
    5a6c:	0f 90       	pop	r0
    5a6e:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5a70:	10 92 bf 50 	sts	0x50BF, r1
    5a74:	10 92 c0 50 	sts	0x50C0, r1
    5a78:	10 92 c1 50 	sts	0x50C1, r1
    5a7c:	10 92 c2 50 	sts	0x50C2, r1
}
    5a80:	ea 96       	adiw	r28, 0x3a	; 58
    5a82:	cd bf       	out	0x3d, r28	; 61
    5a84:	de bf       	out	0x3e, r29	; 62
    5a86:	df 91       	pop	r29
    5a88:	cf 91       	pop	r28
    5a8a:	08 95       	ret

00005a8c <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5a8c:	cf 93       	push	r28
    5a8e:	df 93       	push	r29
    5a90:	cd b7       	in	r28, 0x3d	; 61
    5a92:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5a94:	0e 94 8f 2f 	call	0x5f1e	; 0x5f1e <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5a98:	80 e6       	ldi	r24, 0x60	; 96
    5a9a:	96 e0       	ldi	r25, 0x06	; 6
    5a9c:	20 e6       	ldi	r18, 0x60	; 96
    5a9e:	36 e0       	ldi	r19, 0x06	; 6
    5aa0:	f9 01       	movw	r30, r18
    5aa2:	20 81       	ld	r18, Z
    5aa4:	22 60       	ori	r18, 0x02	; 2
    5aa6:	fc 01       	movw	r30, r24
    5aa8:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5aaa:	80 e6       	ldi	r24, 0x60	; 96
    5aac:	96 e0       	ldi	r25, 0x06	; 6
    5aae:	20 e6       	ldi	r18, 0x60	; 96
    5ab0:	36 e0       	ldi	r19, 0x06	; 6
    5ab2:	f9 01       	movw	r30, r18
    5ab4:	20 81       	ld	r18, Z
    5ab6:	21 60       	ori	r18, 0x01	; 1
    5ab8:	fc 01       	movw	r30, r24
    5aba:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5abc:	0e 94 af 2c 	call	0x595e	; 0x595e <chb_radio_init>
}
    5ac0:	df 91       	pop	r29
    5ac2:	cf 91       	pop	r28
    5ac4:	08 95       	ret

00005ac6 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5ac6:	1f 92       	push	r1
    5ac8:	0f 92       	push	r0
    5aca:	0f b6       	in	r0, 0x3f	; 63
    5acc:	0f 92       	push	r0
    5ace:	00 90 3b 00 	lds	r0, 0x003B
    5ad2:	0f 92       	push	r0
    5ad4:	11 24       	eor	r1, r1
    5ad6:	2f 93       	push	r18
    5ad8:	3f 93       	push	r19
    5ada:	4f 93       	push	r20
    5adc:	5f 93       	push	r21
    5ade:	6f 93       	push	r22
    5ae0:	7f 93       	push	r23
    5ae2:	8f 93       	push	r24
    5ae4:	9f 93       	push	r25
    5ae6:	af 93       	push	r26
    5ae8:	bf 93       	push	r27
    5aea:	ef 93       	push	r30
    5aec:	ff 93       	push	r31
    5aee:	cf 93       	push	r28
    5af0:	df 93       	push	r29
    5af2:	cd b7       	in	r28, 0x3d	; 61
    5af4:	de b7       	in	r29, 0x3e	; 62
    5af6:	25 97       	sbiw	r28, 0x05	; 5
    5af8:	cd bf       	out	0x3d, r28	; 61
    5afa:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    5afc:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5afe:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <chb_get_pcb>
    5b02:	8a 83       	std	Y+2, r24	; 0x02
    5b04:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5b06:	8f e3       	ldi	r24, 0x3F	; 63
    5b08:	90 e0       	ldi	r25, 0x00	; 0
    5b0a:	fc 01       	movw	r30, r24
    5b0c:	80 81       	ld	r24, Z
    5b0e:	80 93 43 40 	sts	0x4043, r24
    5b12:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5b14:	81 e0       	ldi	r24, 0x01	; 1
    5b16:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5b1a:	8f e8       	ldi	r24, 0x8F	; 143
    5b1c:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    5b20:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    5b22:	80 e0       	ldi	r24, 0x00	; 0
    5b24:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <SPID_write>
    5b28:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5b2a:	80 e0       	ldi	r24, 0x00	; 0
    5b2c:	0e 94 5d 2e 	call	0x5cba	; 0x5cba <RadioCS>

    while (intp_src)
    5b30:	9d c0       	rjmp	.+314    	; 0x5c6c <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5b32:	89 81       	ldd	r24, Y+1	; 0x01
    5b34:	88 2f       	mov	r24, r24
    5b36:	90 e0       	ldi	r25, 0x00	; 0
    5b38:	84 70       	andi	r24, 0x04	; 4
    5b3a:	90 70       	andi	r25, 0x00	; 0
    5b3c:	00 97       	sbiw	r24, 0x00	; 0
    5b3e:	21 f0       	breq	.+8      	; 0x5b48 <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5b40:	89 81       	ldd	r24, Y+1	; 0x01
    5b42:	8b 7f       	andi	r24, 0xFB	; 251
    5b44:	89 83       	std	Y+1, r24	; 0x01
    5b46:	92 c0       	rjmp	.+292    	; 0x5c6c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5b48:	89 81       	ldd	r24, Y+1	; 0x01
    5b4a:	88 2f       	mov	r24, r24
    5b4c:	90 e0       	ldi	r25, 0x00	; 0
    5b4e:	88 70       	andi	r24, 0x08	; 8
    5b50:	90 70       	andi	r25, 0x00	; 0
    5b52:	00 97       	sbiw	r24, 0x00	; 0
    5b54:	09 f4       	brne	.+2      	; 0x5b58 <__vector_64+0x92>
    5b56:	4c c0       	rjmp	.+152    	; 0x5bf0 <__vector_64+0x12a>
        {
            state = chb_get_state();
    5b58:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <chb_get_state>
    5b5c:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5b5e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b60:	86 30       	cpi	r24, 0x06	; 6
    5b62:	31 f0       	breq	.+12     	; 0x5b70 <__vector_64+0xaa>
    5b64:	8d 81       	ldd	r24, Y+5	; 0x05
    5b66:	86 31       	cpi	r24, 0x16	; 22
    5b68:	19 f0       	breq	.+6      	; 0x5b70 <__vector_64+0xaa>
    5b6a:	8d 81       	ldd	r24, Y+5	; 0x05
    5b6c:	81 31       	cpi	r24, 0x11	; 17
    5b6e:	89 f5       	brne	.+98     	; 0x5bd2 <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5b70:	88 e0       	ldi	r24, 0x08	; 8
    5b72:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5b76:	87 e0       	ldi	r24, 0x07	; 7
    5b78:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    5b7c:	28 2f       	mov	r18, r24
    5b7e:	8a 81       	ldd	r24, Y+2	; 0x02
    5b80:	9b 81       	ldd	r25, Y+3	; 0x03
    5b82:	fc 01       	movw	r30, r24
    5b84:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5b86:	86 e0       	ldi	r24, 0x06	; 6
    5b88:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
    5b8c:	28 2f       	mov	r18, r24
    5b8e:	22 1f       	adc	r18, r18
    5b90:	22 27       	eor	r18, r18
    5b92:	22 1f       	adc	r18, r18
    5b94:	8a 81       	ldd	r24, Y+2	; 0x02
    5b96:	9b 81       	ldd	r25, Y+3	; 0x03
    5b98:	fc 01       	movw	r30, r24
    5b9a:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    5b9e:	9b 81       	ldd	r25, Y+3	; 0x03
    5ba0:	fc 01       	movw	r30, r24
    5ba2:	83 89       	ldd	r24, Z+19	; 0x13
    5ba4:	88 23       	and	r24, r24
    5ba6:	d1 f0       	breq	.+52     	; 0x5bdc <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    5ba8:	0e 94 47 24 	call	0x488e	; 0x488e <chb_frame_read>
                    pcb->rcvd_xfers++;
    5bac:	8a 81       	ldd	r24, Y+2	; 0x02
    5bae:	9b 81       	ldd	r25, Y+3	; 0x03
    5bb0:	fc 01       	movw	r30, r24
    5bb2:	85 81       	ldd	r24, Z+5	; 0x05
    5bb4:	96 81       	ldd	r25, Z+6	; 0x06
    5bb6:	9c 01       	movw	r18, r24
    5bb8:	2f 5f       	subi	r18, 0xFF	; 255
    5bba:	3f 4f       	sbci	r19, 0xFF	; 255
    5bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    5bbe:	9b 81       	ldd	r25, Y+3	; 0x03
    5bc0:	fc 01       	movw	r30, r24
    5bc2:	25 83       	std	Z+5, r18	; 0x05
    5bc4:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    5bc8:	9b 81       	ldd	r25, Y+3	; 0x03
    5bca:	21 e0       	ldi	r18, 0x01	; 1
    5bcc:	fc 01       	movw	r30, r24
    5bce:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5bd0:	05 c0       	rjmp	.+10     	; 0x5bdc <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    5bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    5bd4:	9b 81       	ldd	r25, Y+3	; 0x03
    5bd6:	21 e0       	ldi	r18, 0x01	; 1
    5bd8:	fc 01       	movw	r30, r24
    5bda:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5bdc:	89 81       	ldd	r24, Y+1	; 0x01
    5bde:	87 7f       	andi	r24, 0xF7	; 247
    5be0:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5be2:	00 00       	nop
    5be4:	86 e1       	ldi	r24, 0x16	; 22
    5be6:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <chb_set_state>
    5bea:	80 34       	cpi	r24, 0x40	; 64
    5bec:	d9 f7       	brne	.-10     	; 0x5be4 <__vector_64+0x11e>
    5bee:	3e c0       	rjmp	.+124    	; 0x5c6c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5bf0:	89 81       	ldd	r24, Y+1	; 0x01
    5bf2:	88 2f       	mov	r24, r24
    5bf4:	90 e0       	ldi	r25, 0x00	; 0
    5bf6:	80 74       	andi	r24, 0x40	; 64
    5bf8:	90 70       	andi	r25, 0x00	; 0
    5bfa:	00 97       	sbiw	r24, 0x00	; 0
    5bfc:	89 f0       	breq	.+34     	; 0x5c20 <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5bfe:	89 81       	ldd	r24, Y+1	; 0x01
    5c00:	8f 7b       	andi	r24, 0xBF	; 191
    5c02:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5c04:	8a 81       	ldd	r24, Y+2	; 0x02
    5c06:	9b 81       	ldd	r25, Y+3	; 0x03
    5c08:	fc 01       	movw	r30, r24
    5c0a:	87 85       	ldd	r24, Z+15	; 0x0f
    5c0c:	90 89       	ldd	r25, Z+16	; 0x10
    5c0e:	9c 01       	movw	r18, r24
    5c10:	2f 5f       	subi	r18, 0xFF	; 255
    5c12:	3f 4f       	sbci	r19, 0xFF	; 255
    5c14:	8a 81       	ldd	r24, Y+2	; 0x02
    5c16:	9b 81       	ldd	r25, Y+3	; 0x03
    5c18:	fc 01       	movw	r30, r24
    5c1a:	27 87       	std	Z+15, r18	; 0x0f
    5c1c:	30 8b       	std	Z+16, r19	; 0x10
    5c1e:	26 c0       	rjmp	.+76     	; 0x5c6c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5c20:	89 81       	ldd	r24, Y+1	; 0x01
    5c22:	88 2f       	mov	r24, r24
    5c24:	90 e0       	ldi	r25, 0x00	; 0
    5c26:	82 70       	andi	r24, 0x02	; 2
    5c28:	90 70       	andi	r25, 0x00	; 0
    5c2a:	00 97       	sbiw	r24, 0x00	; 0
    5c2c:	21 f0       	breq	.+8      	; 0x5c36 <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5c2e:	89 81       	ldd	r24, Y+1	; 0x01
    5c30:	8d 7f       	andi	r24, 0xFD	; 253
    5c32:	89 83       	std	Y+1, r24	; 0x01
    5c34:	1b c0       	rjmp	.+54     	; 0x5c6c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5c36:	89 81       	ldd	r24, Y+1	; 0x01
    5c38:	88 2f       	mov	r24, r24
    5c3a:	90 e0       	ldi	r25, 0x00	; 0
    5c3c:	81 70       	andi	r24, 0x01	; 1
    5c3e:	90 70       	andi	r25, 0x00	; 0
    5c40:	88 23       	and	r24, r24
    5c42:	21 f0       	breq	.+8      	; 0x5c4c <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5c44:	89 81       	ldd	r24, Y+1	; 0x01
    5c46:	8e 7f       	andi	r24, 0xFE	; 254
    5c48:	89 83       	std	Y+1, r24	; 0x01
    5c4a:	10 c0       	rjmp	.+32     	; 0x5c6c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5c4c:	89 81       	ldd	r24, Y+1	; 0x01
    5c4e:	88 23       	and	r24, r24
    5c50:	6c f4       	brge	.+26     	; 0x5c6c <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5c52:	89 81       	ldd	r24, Y+1	; 0x01
    5c54:	8f 77       	andi	r24, 0x7F	; 127
    5c56:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5c58:	8a 81       	ldd	r24, Y+2	; 0x02
    5c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c5c:	fc 01       	movw	r30, r24
    5c5e:	81 89       	ldd	r24, Z+17	; 0x11
    5c60:	28 2f       	mov	r18, r24
    5c62:	2f 5f       	subi	r18, 0xFF	; 255
    5c64:	8a 81       	ldd	r24, Y+2	; 0x02
    5c66:	9b 81       	ldd	r25, Y+3	; 0x03
    5c68:	fc 01       	movw	r30, r24
    5c6a:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5c6c:	89 81       	ldd	r24, Y+1	; 0x01
    5c6e:	88 23       	and	r24, r24
    5c70:	09 f0       	breq	.+2      	; 0x5c74 <__vector_64+0x1ae>
    5c72:	5f cf       	rjmp	.-322    	; 0x5b32 <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5c74:	8f e3       	ldi	r24, 0x3F	; 63
    5c76:	90 e0       	ldi	r25, 0x00	; 0
    5c78:	20 91 43 40 	lds	r18, 0x4043
    5c7c:	fc 01       	movw	r30, r24
    5c7e:	20 83       	st	Z, r18
    5c80:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5c82:	8f e0       	ldi	r24, 0x0F	; 15
    5c84:	0e 94 d8 22 	call	0x45b0	; 0x45b0 <chb_reg_read>
}
    5c88:	25 96       	adiw	r28, 0x05	; 5
    5c8a:	cd bf       	out	0x3d, r28	; 61
    5c8c:	de bf       	out	0x3e, r29	; 62
    5c8e:	df 91       	pop	r29
    5c90:	cf 91       	pop	r28
    5c92:	ff 91       	pop	r31
    5c94:	ef 91       	pop	r30
    5c96:	bf 91       	pop	r27
    5c98:	af 91       	pop	r26
    5c9a:	9f 91       	pop	r25
    5c9c:	8f 91       	pop	r24
    5c9e:	7f 91       	pop	r23
    5ca0:	6f 91       	pop	r22
    5ca2:	5f 91       	pop	r21
    5ca4:	4f 91       	pop	r20
    5ca6:	3f 91       	pop	r19
    5ca8:	2f 91       	pop	r18
    5caa:	0f 90       	pop	r0
    5cac:	00 92 3b 00 	sts	0x003B, r0
    5cb0:	0f 90       	pop	r0
    5cb2:	0f be       	out	0x3f, r0	; 63
    5cb4:	0f 90       	pop	r0
    5cb6:	1f 90       	pop	r1
    5cb8:	18 95       	reti

00005cba <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5cba:	cf 93       	push	r28
    5cbc:	df 93       	push	r29
    5cbe:	0f 92       	push	r0
    5cc0:	cd b7       	in	r28, 0x3d	; 61
    5cc2:	de b7       	in	r29, 0x3e	; 62
    5cc4:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5cc6:	89 81       	ldd	r24, Y+1	; 0x01
    5cc8:	88 23       	and	r24, r24
    5cca:	31 f0       	breq	.+12     	; 0x5cd8 <RadioCS+0x1e>
    5ccc:	80 e6       	ldi	r24, 0x60	; 96
    5cce:	96 e0       	ldi	r25, 0x06	; 6
    5cd0:	20 e1       	ldi	r18, 0x10	; 16
    5cd2:	fc 01       	movw	r30, r24
    5cd4:	26 83       	std	Z+6, r18	; 0x06
    5cd6:	05 c0       	rjmp	.+10     	; 0x5ce2 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5cd8:	80 e6       	ldi	r24, 0x60	; 96
    5cda:	96 e0       	ldi	r25, 0x06	; 6
    5cdc:	20 e1       	ldi	r18, 0x10	; 16
    5cde:	fc 01       	movw	r30, r24
    5ce0:	25 83       	std	Z+5, r18	; 0x05
	}
    5ce2:	0f 90       	pop	r0
    5ce4:	df 91       	pop	r29
    5ce6:	cf 91       	pop	r28
    5ce8:	08 95       	ret

00005cea <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5cea:	cf 93       	push	r28
    5cec:	df 93       	push	r29
    5cee:	00 d0       	rcall	.+0      	; 0x5cf0 <chb_eep_write_byte+0x6>
    5cf0:	cd b7       	in	r28, 0x3d	; 61
    5cf2:	de b7       	in	r29, 0x3e	; 62
    5cf4:	89 83       	std	Y+1, r24	; 0x01
    5cf6:	9a 83       	std	Y+2, r25	; 0x02
    5cf8:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5cfa:	00 00       	nop
    5cfc:	80 ec       	ldi	r24, 0xC0	; 192
    5cfe:	91 e0       	ldi	r25, 0x01	; 1
    5d00:	fc 01       	movw	r30, r24
    5d02:	87 85       	ldd	r24, Z+15	; 0x0f
    5d04:	88 23       	and	r24, r24
    5d06:	d4 f3       	brlt	.-12     	; 0x5cfc <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5d08:	80 ec       	ldi	r24, 0xC0	; 192
    5d0a:	91 e0       	ldi	r25, 0x01	; 1
    5d0c:	fc 01       	movw	r30, r24
    5d0e:	87 85       	ldd	r24, Z+15	; 0x0f
    5d10:	88 2f       	mov	r24, r24
    5d12:	90 e0       	ldi	r25, 0x00	; 0
    5d14:	82 70       	andi	r24, 0x02	; 2
    5d16:	90 70       	andi	r25, 0x00	; 0
    5d18:	00 97       	sbiw	r24, 0x00	; 0
    5d1a:	99 f0       	breq	.+38     	; 0x5d42 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5d1c:	80 ec       	ldi	r24, 0xC0	; 192
    5d1e:	91 e0       	ldi	r25, 0x01	; 1
    5d20:	26 e3       	ldi	r18, 0x36	; 54
    5d22:	fc 01       	movw	r30, r24
    5d24:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5d26:	ef 93       	push	r30
    5d28:	ff 93       	push	r31
    5d2a:	0f 93       	push	r16
    5d2c:	2f 93       	push	r18
    5d2e:	eb ec       	ldi	r30, 0xCB	; 203
    5d30:	f1 e0       	ldi	r31, 0x01	; 1
    5d32:	08 ed       	ldi	r16, 0xD8	; 216
    5d34:	21 e0       	ldi	r18, 0x01	; 1
    5d36:	04 bf       	out	0x34, r16	; 52
    5d38:	20 83       	st	Z, r18
    5d3a:	2f 91       	pop	r18
    5d3c:	0f 91       	pop	r16
    5d3e:	ff 91       	pop	r31
    5d40:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    5d42:	80 ec       	ldi	r24, 0xC0	; 192
    5d44:	91 e0       	ldi	r25, 0x01	; 1
    5d46:	23 e3       	ldi	r18, 0x33	; 51
    5d48:	fc 01       	movw	r30, r24
    5d4a:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    5d4c:	80 ec       	ldi	r24, 0xC0	; 192
    5d4e:	91 e0       	ldi	r25, 0x01	; 1
    5d50:	29 81       	ldd	r18, Y+1	; 0x01
    5d52:	fc 01       	movw	r30, r24
    5d54:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5d56:	80 ec       	ldi	r24, 0xC0	; 192
    5d58:	91 e0       	ldi	r25, 0x01	; 1
    5d5a:	29 81       	ldd	r18, Y+1	; 0x01
    5d5c:	3a 81       	ldd	r19, Y+2	; 0x02
    5d5e:	23 2f       	mov	r18, r19
    5d60:	33 27       	eor	r19, r19
    5d62:	2f 71       	andi	r18, 0x1F	; 31
    5d64:	fc 01       	movw	r30, r24
    5d66:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5d68:	80 ec       	ldi	r24, 0xC0	; 192
    5d6a:	91 e0       	ldi	r25, 0x01	; 1
    5d6c:	fc 01       	movw	r30, r24
    5d6e:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    5d70:	80 ec       	ldi	r24, 0xC0	; 192
    5d72:	91 e0       	ldi	r25, 0x01	; 1
    5d74:	2b 81       	ldd	r18, Y+3	; 0x03
    5d76:	fc 01       	movw	r30, r24
    5d78:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    5d7a:	80 ec       	ldi	r24, 0xC0	; 192
    5d7c:	91 e0       	ldi	r25, 0x01	; 1
    5d7e:	25 e3       	ldi	r18, 0x35	; 53
    5d80:	fc 01       	movw	r30, r24
    5d82:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5d84:	ef 93       	push	r30
    5d86:	ff 93       	push	r31
    5d88:	0f 93       	push	r16
    5d8a:	2f 93       	push	r18
    5d8c:	eb ec       	ldi	r30, 0xCB	; 203
    5d8e:	f1 e0       	ldi	r31, 0x01	; 1
    5d90:	08 ed       	ldi	r16, 0xD8	; 216
    5d92:	21 e0       	ldi	r18, 0x01	; 1
    5d94:	04 bf       	out	0x34, r16	; 52
    5d96:	20 83       	st	Z, r18
    5d98:	2f 91       	pop	r18
    5d9a:	0f 91       	pop	r16
    5d9c:	ff 91       	pop	r31
    5d9e:	ef 91       	pop	r30
}
    5da0:	23 96       	adiw	r28, 0x03	; 3
    5da2:	cd bf       	out	0x3d, r28	; 61
    5da4:	de bf       	out	0x3e, r29	; 62
    5da6:	df 91       	pop	r29
    5da8:	cf 91       	pop	r28
    5daa:	08 95       	ret

00005dac <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    5dac:	cf 93       	push	r28
    5dae:	df 93       	push	r29
    5db0:	0f 92       	push	r0
    5db2:	0f 92       	push	r0
    5db4:	cd b7       	in	r28, 0x3d	; 61
    5db6:	de b7       	in	r29, 0x3e	; 62
    5db8:	89 83       	std	Y+1, r24	; 0x01
    5dba:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5dbc:	00 00       	nop
    5dbe:	80 ec       	ldi	r24, 0xC0	; 192
    5dc0:	91 e0       	ldi	r25, 0x01	; 1
    5dc2:	fc 01       	movw	r30, r24
    5dc4:	87 85       	ldd	r24, Z+15	; 0x0f
    5dc6:	88 23       	and	r24, r24
    5dc8:	d4 f3       	brlt	.-12     	; 0x5dbe <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    5dca:	80 ec       	ldi	r24, 0xC0	; 192
    5dcc:	91 e0       	ldi	r25, 0x01	; 1
    5dce:	29 81       	ldd	r18, Y+1	; 0x01
    5dd0:	fc 01       	movw	r30, r24
    5dd2:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5dd4:	80 ec       	ldi	r24, 0xC0	; 192
    5dd6:	91 e0       	ldi	r25, 0x01	; 1
    5dd8:	29 81       	ldd	r18, Y+1	; 0x01
    5dda:	3a 81       	ldd	r19, Y+2	; 0x02
    5ddc:	23 2f       	mov	r18, r19
    5dde:	33 27       	eor	r19, r19
    5de0:	2f 71       	andi	r18, 0x1F	; 31
    5de2:	fc 01       	movw	r30, r24
    5de4:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5de6:	80 ec       	ldi	r24, 0xC0	; 192
    5de8:	91 e0       	ldi	r25, 0x01	; 1
    5dea:	fc 01       	movw	r30, r24
    5dec:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    5dee:	80 ec       	ldi	r24, 0xC0	; 192
    5df0:	91 e0       	ldi	r25, 0x01	; 1
    5df2:	26 e0       	ldi	r18, 0x06	; 6
    5df4:	fc 01       	movw	r30, r24
    5df6:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5df8:	ef 93       	push	r30
    5dfa:	ff 93       	push	r31
    5dfc:	0f 93       	push	r16
    5dfe:	2f 93       	push	r18
    5e00:	eb ec       	ldi	r30, 0xCB	; 203
    5e02:	f1 e0       	ldi	r31, 0x01	; 1
    5e04:	08 ed       	ldi	r16, 0xD8	; 216
    5e06:	21 e0       	ldi	r18, 0x01	; 1
    5e08:	04 bf       	out	0x34, r16	; 52
    5e0a:	20 83       	st	Z, r18
    5e0c:	2f 91       	pop	r18
    5e0e:	0f 91       	pop	r16
    5e10:	ff 91       	pop	r31
    5e12:	ef 91       	pop	r30

    return NVM.DATA0;
    5e14:	80 ec       	ldi	r24, 0xC0	; 192
    5e16:	91 e0       	ldi	r25, 0x01	; 1
    5e18:	fc 01       	movw	r30, r24
    5e1a:	84 81       	ldd	r24, Z+4	; 0x04
}
    5e1c:	0f 90       	pop	r0
    5e1e:	0f 90       	pop	r0
    5e20:	df 91       	pop	r29
    5e22:	cf 91       	pop	r28
    5e24:	08 95       	ret

00005e26 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    5e26:	cf 93       	push	r28
    5e28:	df 93       	push	r29
    5e2a:	cd b7       	in	r28, 0x3d	; 61
    5e2c:	de b7       	in	r29, 0x3e	; 62
    5e2e:	27 97       	sbiw	r28, 0x07	; 7
    5e30:	cd bf       	out	0x3d, r28	; 61
    5e32:	de bf       	out	0x3e, r29	; 62
    5e34:	8a 83       	std	Y+2, r24	; 0x02
    5e36:	9b 83       	std	Y+3, r25	; 0x03
    5e38:	6c 83       	std	Y+4, r22	; 0x04
    5e3a:	7d 83       	std	Y+5, r23	; 0x05
    5e3c:	4e 83       	std	Y+6, r20	; 0x06
    5e3e:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5e40:	80 ec       	ldi	r24, 0xC0	; 192
    5e42:	91 e0       	ldi	r25, 0x01	; 1
    5e44:	20 ec       	ldi	r18, 0xC0	; 192
    5e46:	31 e0       	ldi	r19, 0x01	; 1
    5e48:	f9 01       	movw	r30, r18
    5e4a:	24 85       	ldd	r18, Z+12	; 0x0c
    5e4c:	27 7f       	andi	r18, 0xF7	; 247
    5e4e:	fc 01       	movw	r30, r24
    5e50:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    5e52:	19 82       	std	Y+1, r1	; 0x01
    5e54:	16 c0       	rjmp	.+44     	; 0x5e82 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    5e56:	89 81       	ldd	r24, Y+1	; 0x01
    5e58:	28 2f       	mov	r18, r24
    5e5a:	30 e0       	ldi	r19, 0x00	; 0
    5e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e5e:	9b 81       	ldd	r25, Y+3	; 0x03
    5e60:	82 0f       	add	r24, r18
    5e62:	93 1f       	adc	r25, r19
    5e64:	29 81       	ldd	r18, Y+1	; 0x01
    5e66:	22 2f       	mov	r18, r18
    5e68:	30 e0       	ldi	r19, 0x00	; 0
    5e6a:	4c 81       	ldd	r20, Y+4	; 0x04
    5e6c:	5d 81       	ldd	r21, Y+5	; 0x05
    5e6e:	24 0f       	add	r18, r20
    5e70:	35 1f       	adc	r19, r21
    5e72:	f9 01       	movw	r30, r18
    5e74:	20 81       	ld	r18, Z
    5e76:	62 2f       	mov	r22, r18
    5e78:	0e 94 75 2e 	call	0x5cea	; 0x5cea <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    5e7c:	89 81       	ldd	r24, Y+1	; 0x01
    5e7e:	8f 5f       	subi	r24, 0xFF	; 255
    5e80:	89 83       	std	Y+1, r24	; 0x01
    5e82:	89 81       	ldd	r24, Y+1	; 0x01
    5e84:	28 2f       	mov	r18, r24
    5e86:	30 e0       	ldi	r19, 0x00	; 0
    5e88:	8e 81       	ldd	r24, Y+6	; 0x06
    5e8a:	9f 81       	ldd	r25, Y+7	; 0x07
    5e8c:	28 17       	cp	r18, r24
    5e8e:	39 07       	cpc	r19, r25
    5e90:	10 f3       	brcs	.-60     	; 0x5e56 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    5e92:	27 96       	adiw	r28, 0x07	; 7
    5e94:	cd bf       	out	0x3d, r28	; 61
    5e96:	de bf       	out	0x3e, r29	; 62
    5e98:	df 91       	pop	r29
    5e9a:	cf 91       	pop	r28
    5e9c:	08 95       	ret

00005e9e <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    5e9e:	0f 93       	push	r16
    5ea0:	1f 93       	push	r17
    5ea2:	cf 93       	push	r28
    5ea4:	df 93       	push	r29
    5ea6:	cd b7       	in	r28, 0x3d	; 61
    5ea8:	de b7       	in	r29, 0x3e	; 62
    5eaa:	27 97       	sbiw	r28, 0x07	; 7
    5eac:	cd bf       	out	0x3d, r28	; 61
    5eae:	de bf       	out	0x3e, r29	; 62
    5eb0:	8a 83       	std	Y+2, r24	; 0x02
    5eb2:	9b 83       	std	Y+3, r25	; 0x03
    5eb4:	6c 83       	std	Y+4, r22	; 0x04
    5eb6:	7d 83       	std	Y+5, r23	; 0x05
    5eb8:	4e 83       	std	Y+6, r20	; 0x06
    5eba:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5ebc:	80 ec       	ldi	r24, 0xC0	; 192
    5ebe:	91 e0       	ldi	r25, 0x01	; 1
    5ec0:	20 ec       	ldi	r18, 0xC0	; 192
    5ec2:	31 e0       	ldi	r19, 0x01	; 1
    5ec4:	f9 01       	movw	r30, r18
    5ec6:	24 85       	ldd	r18, Z+12	; 0x0c
    5ec8:	27 7f       	andi	r18, 0xF7	; 247
    5eca:	fc 01       	movw	r30, r24
    5ecc:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5ece:	19 82       	std	Y+1, r1	; 0x01
    5ed0:	16 c0       	rjmp	.+44     	; 0x5efe <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    5ed2:	89 81       	ldd	r24, Y+1	; 0x01
    5ed4:	88 2f       	mov	r24, r24
    5ed6:	90 e0       	ldi	r25, 0x00	; 0
    5ed8:	2c 81       	ldd	r18, Y+4	; 0x04
    5eda:	3d 81       	ldd	r19, Y+5	; 0x05
    5edc:	89 01       	movw	r16, r18
    5ede:	08 0f       	add	r16, r24
    5ee0:	19 1f       	adc	r17, r25
    5ee2:	89 81       	ldd	r24, Y+1	; 0x01
    5ee4:	28 2f       	mov	r18, r24
    5ee6:	30 e0       	ldi	r19, 0x00	; 0
    5ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eea:	9b 81       	ldd	r25, Y+3	; 0x03
    5eec:	82 0f       	add	r24, r18
    5eee:	93 1f       	adc	r25, r19
    5ef0:	0e 94 d6 2e 	call	0x5dac	; 0x5dac <chb_eep_read_byte>
    5ef4:	f8 01       	movw	r30, r16
    5ef6:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5ef8:	89 81       	ldd	r24, Y+1	; 0x01
    5efa:	8f 5f       	subi	r24, 0xFF	; 255
    5efc:	89 83       	std	Y+1, r24	; 0x01
    5efe:	89 81       	ldd	r24, Y+1	; 0x01
    5f00:	28 2f       	mov	r18, r24
    5f02:	30 e0       	ldi	r19, 0x00	; 0
    5f04:	8e 81       	ldd	r24, Y+6	; 0x06
    5f06:	9f 81       	ldd	r25, Y+7	; 0x07
    5f08:	28 17       	cp	r18, r24
    5f0a:	39 07       	cpc	r19, r25
    5f0c:	10 f3       	brcs	.-60     	; 0x5ed2 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    5f0e:	27 96       	adiw	r28, 0x07	; 7
    5f10:	cd bf       	out	0x3d, r28	; 61
    5f12:	de bf       	out	0x3e, r29	; 62
    5f14:	df 91       	pop	r29
    5f16:	cf 91       	pop	r28
    5f18:	1f 91       	pop	r17
    5f1a:	0f 91       	pop	r16
    5f1c:	08 95       	ret

00005f1e <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    5f1e:	cf 93       	push	r28
    5f20:	df 93       	push	r29
    5f22:	cd b7       	in	r28, 0x3d	; 61
    5f24:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    5f26:	80 e6       	ldi	r24, 0x60	; 96
    5f28:	96 e0       	ldi	r25, 0x06	; 6
    5f2a:	20 e6       	ldi	r18, 0x60	; 96
    5f2c:	36 e0       	ldi	r19, 0x06	; 6
    5f2e:	f9 01       	movw	r30, r18
    5f30:	20 81       	ld	r18, Z
    5f32:	20 6b       	ori	r18, 0xB0	; 176
    5f34:	fc 01       	movw	r30, r24
    5f36:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    5f38:	84 e6       	ldi	r24, 0x64	; 100
    5f3a:	96 e0       	ldi	r25, 0x06	; 6
    5f3c:	24 e6       	ldi	r18, 0x64	; 100
    5f3e:	36 e0       	ldi	r19, 0x06	; 6
    5f40:	f9 01       	movw	r30, r18
    5f42:	20 81       	ld	r18, Z
    5f44:	20 61       	ori	r18, 0x10	; 16
    5f46:	fc 01       	movw	r30, r24
    5f48:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    5f4a:	80 ec       	ldi	r24, 0xC0	; 192
    5f4c:	99 e0       	ldi	r25, 0x09	; 9
    5f4e:	20 ec       	ldi	r18, 0xC0	; 192
    5f50:	39 e0       	ldi	r19, 0x09	; 9
    5f52:	f9 01       	movw	r30, r18
    5f54:	20 81       	ld	r18, Z
    5f56:	21 65       	ori	r18, 0x51	; 81
    5f58:	fc 01       	movw	r30, r24
    5f5a:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    5f5c:	84 e6       	ldi	r24, 0x64	; 100
    5f5e:	96 e0       	ldi	r25, 0x06	; 6
    5f60:	24 e6       	ldi	r18, 0x64	; 100
    5f62:	36 e0       	ldi	r19, 0x06	; 6
    5f64:	f9 01       	movw	r30, r18
    5f66:	20 81       	ld	r18, Z
    5f68:	20 61       	ori	r18, 0x10	; 16
    5f6a:	fc 01       	movw	r30, r24
    5f6c:	20 83       	st	Z, r18
}
    5f6e:	df 91       	pop	r29
    5f70:	cf 91       	pop	r28
    5f72:	08 95       	ret

00005f74 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    5f74:	cf 93       	push	r28
    5f76:	df 93       	push	r29
    5f78:	0f 92       	push	r0
    5f7a:	0f 92       	push	r0
    5f7c:	cd b7       	in	r28, 0x3d	; 61
    5f7e:	de b7       	in	r29, 0x3e	; 62
    5f80:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    5f82:	80 ec       	ldi	r24, 0xC0	; 192
    5f84:	99 e0       	ldi	r25, 0x09	; 9
    5f86:	2a 81       	ldd	r18, Y+2	; 0x02
    5f88:	fc 01       	movw	r30, r24
    5f8a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5f8c:	00 00       	nop
    5f8e:	80 ec       	ldi	r24, 0xC0	; 192
    5f90:	99 e0       	ldi	r25, 0x09	; 9
    5f92:	fc 01       	movw	r30, r24
    5f94:	82 81       	ldd	r24, Z+2	; 0x02
    5f96:	88 23       	and	r24, r24
    5f98:	d4 f7       	brge	.-12     	; 0x5f8e <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    5f9a:	80 ec       	ldi	r24, 0xC0	; 192
    5f9c:	99 e0       	ldi	r25, 0x09	; 9
    5f9e:	fc 01       	movw	r30, r24
    5fa0:	83 81       	ldd	r24, Z+3	; 0x03
    5fa2:	89 83       	std	Y+1, r24	; 0x01
	return data;
    5fa4:	89 81       	ldd	r24, Y+1	; 0x01
    5fa6:	0f 90       	pop	r0
    5fa8:	0f 90       	pop	r0
    5faa:	df 91       	pop	r29
    5fac:	cf 91       	pop	r28
    5fae:	08 95       	ret

00005fb0 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    5fb0:	0f 93       	push	r16
    5fb2:	cf 93       	push	r28
    5fb4:	df 93       	push	r29
    5fb6:	00 d0       	rcall	.+0      	; 0x5fb8 <CCPWrite+0x8>
    5fb8:	00 d0       	rcall	.+0      	; 0x5fba <CCPWrite+0xa>
    5fba:	cd b7       	in	r28, 0x3d	; 61
    5fbc:	de b7       	in	r29, 0x3e	; 62
    5fbe:	8c 83       	std	Y+4, r24	; 0x04
    5fc0:	9d 83       	std	Y+5, r25	; 0x05
    5fc2:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    5fc4:	8f e3       	ldi	r24, 0x3F	; 63
    5fc6:	90 e0       	ldi	r25, 0x00	; 0
    5fc8:	fc 01       	movw	r30, r24
    5fca:	80 81       	ld	r24, Z
    5fcc:	8b 83       	std	Y+3, r24	; 0x03
    5fce:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    5fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    5fd2:	9d 81       	ldd	r25, Y+5	; 0x05
    5fd4:	89 83       	std	Y+1, r24	; 0x01
    5fd6:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    5fd8:	8b e3       	ldi	r24, 0x3B	; 59
    5fda:	90 e0       	ldi	r25, 0x00	; 0
    5fdc:	fc 01       	movw	r30, r24
    5fde:	10 82       	st	Z, r1
#endif
	asm volatile(
    5fe0:	89 81       	ldd	r24, Y+1	; 0x01
    5fe2:	9a 81       	ldd	r25, Y+2	; 0x02
    5fe4:	2e 81       	ldd	r18, Y+6	; 0x06
    5fe6:	fc 01       	movw	r30, r24
    5fe8:	08 ed       	ldi	r16, 0xD8	; 216
    5fea:	04 bf       	out	0x34, r16	; 52
    5fec:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    5fee:	8f e3       	ldi	r24, 0x3F	; 63
    5ff0:	90 e0       	ldi	r25, 0x00	; 0
    5ff2:	2b 81       	ldd	r18, Y+3	; 0x03
    5ff4:	fc 01       	movw	r30, r24
    5ff6:	20 83       	st	Z, r18
#endif
}
    5ff8:	26 96       	adiw	r28, 0x06	; 6
    5ffa:	cd bf       	out	0x3d, r28	; 61
    5ffc:	de bf       	out	0x3e, r29	; 62
    5ffe:	df 91       	pop	r29
    6000:	cf 91       	pop	r28
    6002:	0f 91       	pop	r16
    6004:	08 95       	ret

00006006 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6006:	cf 93       	push	r28
    6008:	df 93       	push	r29
    600a:	00 d0       	rcall	.+0      	; 0x600c <CLKSYS_XOSC_Config+0x6>
    600c:	cd b7       	in	r28, 0x3d	; 61
    600e:	de b7       	in	r29, 0x3e	; 62
    6010:	89 83       	std	Y+1, r24	; 0x01
    6012:	6a 83       	std	Y+2, r22	; 0x02
    6014:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6016:	80 e5       	ldi	r24, 0x50	; 80
    6018:	90 e0       	ldi	r25, 0x00	; 0
    601a:	2a 81       	ldd	r18, Y+2	; 0x02
    601c:	22 23       	and	r18, r18
    601e:	11 f0       	breq	.+4      	; 0x6024 <CLKSYS_XOSC_Config+0x1e>
    6020:	20 e2       	ldi	r18, 0x20	; 32
    6022:	01 c0       	rjmp	.+2      	; 0x6026 <CLKSYS_XOSC_Config+0x20>
    6024:	20 e0       	ldi	r18, 0x00	; 0
    6026:	39 81       	ldd	r19, Y+1	; 0x01
    6028:	32 2b       	or	r19, r18
    602a:	2b 81       	ldd	r18, Y+3	; 0x03
    602c:	23 2b       	or	r18, r19
    602e:	fc 01       	movw	r30, r24
    6030:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    6032:	23 96       	adiw	r28, 0x03	; 3
    6034:	cd bf       	out	0x3d, r28	; 61
    6036:	de bf       	out	0x3e, r29	; 62
    6038:	df 91       	pop	r29
    603a:	cf 91       	pop	r28
    603c:	08 95       	ret

0000603e <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    603e:	cf 93       	push	r28
    6040:	df 93       	push	r29
    6042:	0f 92       	push	r0
    6044:	0f 92       	push	r0
    6046:	cd b7       	in	r28, 0x3d	; 61
    6048:	de b7       	in	r29, 0x3e	; 62
    604a:	89 83       	std	Y+1, r24	; 0x01
    604c:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    604e:	8a 81       	ldd	r24, Y+2	; 0x02
    6050:	8f 71       	andi	r24, 0x1F	; 31
    6052:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    6054:	80 e5       	ldi	r24, 0x50	; 80
    6056:	90 e0       	ldi	r25, 0x00	; 0
    6058:	39 81       	ldd	r19, Y+1	; 0x01
    605a:	2a 81       	ldd	r18, Y+2	; 0x02
    605c:	23 2b       	or	r18, r19
    605e:	fc 01       	movw	r30, r24
    6060:	25 83       	std	Z+5, r18	; 0x05
}
    6062:	0f 90       	pop	r0
    6064:	0f 90       	pop	r0
    6066:	df 91       	pop	r29
    6068:	cf 91       	pop	r28
    606a:	08 95       	ret

0000606c <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    606c:	cf 93       	push	r28
    606e:	df 93       	push	r29
    6070:	0f 92       	push	r0
    6072:	0f 92       	push	r0
    6074:	cd b7       	in	r28, 0x3d	; 61
    6076:	de b7       	in	r29, 0x3e	; 62
    6078:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    607a:	80 e5       	ldi	r24, 0x50	; 80
    607c:	90 e0       	ldi	r25, 0x00	; 0
    607e:	20 e5       	ldi	r18, 0x50	; 80
    6080:	30 e0       	ldi	r19, 0x00	; 0
    6082:	f9 01       	movw	r30, r18
    6084:	20 81       	ld	r18, Z
    6086:	32 2f       	mov	r19, r18
    6088:	2a 81       	ldd	r18, Y+2	; 0x02
    608a:	20 95       	com	r18
    608c:	23 23       	and	r18, r19
    608e:	fc 01       	movw	r30, r24
    6090:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    6092:	80 e5       	ldi	r24, 0x50	; 80
    6094:	90 e0       	ldi	r25, 0x00	; 0
    6096:	fc 01       	movw	r30, r24
    6098:	90 81       	ld	r25, Z
    609a:	8a 81       	ldd	r24, Y+2	; 0x02
    609c:	89 23       	and	r24, r25
    609e:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    60a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    60a2:	0f 90       	pop	r0
    60a4:	0f 90       	pop	r0
    60a6:	df 91       	pop	r29
    60a8:	cf 91       	pop	r28
    60aa:	08 95       	ret

000060ac <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    60ac:	cf 93       	push	r28
    60ae:	df 93       	push	r29
    60b0:	00 d0       	rcall	.+0      	; 0x60b2 <CLKSYS_Prescalers_Config+0x6>
    60b2:	cd b7       	in	r28, 0x3d	; 61
    60b4:	de b7       	in	r29, 0x3e	; 62
    60b6:	8a 83       	std	Y+2, r24	; 0x02
    60b8:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    60ba:	9a 81       	ldd	r25, Y+2	; 0x02
    60bc:	8b 81       	ldd	r24, Y+3	; 0x03
    60be:	89 2b       	or	r24, r25
    60c0:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    60c2:	81 e4       	ldi	r24, 0x41	; 65
    60c4:	90 e0       	ldi	r25, 0x00	; 0
    60c6:	69 81       	ldd	r22, Y+1	; 0x01
    60c8:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <CCPWrite>
}
    60cc:	23 96       	adiw	r28, 0x03	; 3
    60ce:	cd bf       	out	0x3d, r28	; 61
    60d0:	de bf       	out	0x3e, r29	; 62
    60d2:	df 91       	pop	r29
    60d4:	cf 91       	pop	r28
    60d6:	08 95       	ret

000060d8 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    60d8:	cf 93       	push	r28
    60da:	df 93       	push	r29
    60dc:	0f 92       	push	r0
    60de:	0f 92       	push	r0
    60e0:	cd b7       	in	r28, 0x3d	; 61
    60e2:	de b7       	in	r29, 0x3e	; 62
    60e4:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    60e6:	80 e4       	ldi	r24, 0x40	; 64
    60e8:	90 e0       	ldi	r25, 0x00	; 0
    60ea:	fc 01       	movw	r30, r24
    60ec:	80 81       	ld	r24, Z
    60ee:	98 2f       	mov	r25, r24
    60f0:	98 7f       	andi	r25, 0xF8	; 248
    60f2:	8a 81       	ldd	r24, Y+2	; 0x02
    60f4:	89 2b       	or	r24, r25
    60f6:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    60f8:	80 e4       	ldi	r24, 0x40	; 64
    60fa:	90 e0       	ldi	r25, 0x00	; 0
    60fc:	69 81       	ldd	r22, Y+1	; 0x01
    60fe:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    6102:	80 e4       	ldi	r24, 0x40	; 64
    6104:	90 e0       	ldi	r25, 0x00	; 0
    6106:	fc 01       	movw	r30, r24
    6108:	90 81       	ld	r25, Z
    610a:	8a 81       	ldd	r24, Y+2	; 0x02
    610c:	89 23       	and	r24, r25
    610e:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    6110:	89 81       	ldd	r24, Y+1	; 0x01
}
    6112:	0f 90       	pop	r0
    6114:	0f 90       	pop	r0
    6116:	df 91       	pop	r29
    6118:	cf 91       	pop	r28
    611a:	08 95       	ret

0000611c <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    611c:	cf 93       	push	r28
    611e:	df 93       	push	r29
    6120:	0f 92       	push	r0
    6122:	cd b7       	in	r28, 0x3d	; 61
    6124:	de b7       	in	r29, 0x3e	; 62
    6126:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6128:	80 e4       	ldi	r24, 0x40	; 64
    612a:	90 e0       	ldi	r25, 0x00	; 0
    612c:	20 e4       	ldi	r18, 0x40	; 64
    612e:	30 e0       	ldi	r19, 0x00	; 0
    6130:	f9 01       	movw	r30, r18
    6132:	23 81       	ldd	r18, Z+3	; 0x03
    6134:	32 2f       	mov	r19, r18
    6136:	31 7f       	andi	r19, 0xF1	; 241
    6138:	29 81       	ldd	r18, Y+1	; 0x01
    613a:	23 2b       	or	r18, r19
    613c:	21 60       	ori	r18, 0x01	; 1
    613e:	fc 01       	movw	r30, r24
    6140:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    6142:	0f 90       	pop	r0
    6144:	df 91       	pop	r29
    6146:	cf 91       	pop	r28
    6148:	08 95       	ret

0000614a <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    614a:	cf 93       	push	r28
    614c:	df 93       	push	r29
    614e:	0f 92       	push	r0
    6150:	0f 92       	push	r0
    6152:	cd b7       	in	r28, 0x3d	; 61
    6154:	de b7       	in	r29, 0x3e	; 62
    6156:	89 83       	std	Y+1, r24	; 0x01
    6158:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    615a:	80 e5       	ldi	r24, 0x50	; 80
    615c:	90 e0       	ldi	r25, 0x00	; 0
    615e:	20 e5       	ldi	r18, 0x50	; 80
    6160:	30 e0       	ldi	r19, 0x00	; 0
    6162:	f9 01       	movw	r30, r18
    6164:	26 81       	ldd	r18, Z+6	; 0x06
    6166:	32 2f       	mov	r19, r18
    6168:	29 81       	ldd	r18, Y+1	; 0x01
    616a:	20 95       	com	r18
    616c:	32 23       	and	r19, r18
    616e:	2a 81       	ldd	r18, Y+2	; 0x02
    6170:	22 23       	and	r18, r18
    6172:	11 f0       	breq	.+4      	; 0x6178 <CLKSYS_AutoCalibration_Enable+0x2e>
    6174:	29 81       	ldd	r18, Y+1	; 0x01
    6176:	01 c0       	rjmp	.+2      	; 0x617a <CLKSYS_AutoCalibration_Enable+0x30>
    6178:	20 e0       	ldi	r18, 0x00	; 0
    617a:	23 2b       	or	r18, r19
    617c:	fc 01       	movw	r30, r24
    617e:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    6180:	89 81       	ldd	r24, Y+1	; 0x01
    6182:	81 30       	cpi	r24, 0x01	; 1
    6184:	51 f4       	brne	.+20     	; 0x619a <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    6186:	88 e6       	ldi	r24, 0x68	; 104
    6188:	90 e0       	ldi	r25, 0x00	; 0
    618a:	28 e6       	ldi	r18, 0x68	; 104
    618c:	30 e0       	ldi	r19, 0x00	; 0
    618e:	f9 01       	movw	r30, r18
    6190:	20 81       	ld	r18, Z
    6192:	21 60       	ori	r18, 0x01	; 1
    6194:	fc 01       	movw	r30, r24
    6196:	20 83       	st	Z, r18
    6198:	0c c0       	rjmp	.+24     	; 0x61b2 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    619a:	89 81       	ldd	r24, Y+1	; 0x01
    619c:	82 30       	cpi	r24, 0x02	; 2
    619e:	49 f4       	brne	.+18     	; 0x61b2 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    61a0:	80 e6       	ldi	r24, 0x60	; 96
    61a2:	90 e0       	ldi	r25, 0x00	; 0
    61a4:	20 e6       	ldi	r18, 0x60	; 96
    61a6:	30 e0       	ldi	r19, 0x00	; 0
    61a8:	f9 01       	movw	r30, r18
    61aa:	20 81       	ld	r18, Z
    61ac:	21 60       	ori	r18, 0x01	; 1
    61ae:	fc 01       	movw	r30, r24
    61b0:	20 83       	st	Z, r18
	}
}
    61b2:	0f 90       	pop	r0
    61b4:	0f 90       	pop	r0
    61b6:	df 91       	pop	r29
    61b8:	cf 91       	pop	r28
    61ba:	08 95       	ret

000061bc <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    61bc:	cf 93       	push	r28
    61be:	df 93       	push	r29
    61c0:	cd b7       	in	r28, 0x3d	; 61
    61c2:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    61c4:	83 e5       	ldi	r24, 0x53	; 83
    61c6:	90 e0       	ldi	r25, 0x00	; 0
    61c8:	63 e0       	ldi	r22, 0x03	; 3
    61ca:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <CCPWrite>
}
    61ce:	df 91       	pop	r29
    61d0:	cf 91       	pop	r28
    61d2:	08 95       	ret

000061d4 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    61d4:	cf 93       	push	r28
    61d6:	df 93       	push	r29
    61d8:	cd b7       	in	r28, 0x3d	; 61
    61da:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    61dc:	82 e4       	ldi	r24, 0x42	; 66
    61de:	90 e0       	ldi	r25, 0x00	; 0
    61e0:	61 e0       	ldi	r22, 0x01	; 1
    61e2:	0e 94 d8 2f 	call	0x5fb0	; 0x5fb0 <CCPWrite>
}
    61e6:	df 91       	pop	r29
    61e8:	cf 91       	pop	r28
    61ea:	08 95       	ret

000061ec <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    61ec:	cf 93       	push	r28
    61ee:	df 93       	push	r29
    61f0:	cd b7       	in	r28, 0x3d	; 61
    61f2:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    61f4:	80 ec       	ldi	r24, 0xC0	; 192
    61f6:	60 e0       	ldi	r22, 0x00	; 0
    61f8:	4b e0       	ldi	r20, 0x0B	; 11
    61fa:	0e 94 03 30 	call	0x6006	; 0x6006 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    61fe:	80 e5       	ldi	r24, 0x50	; 80
    6200:	90 e0       	ldi	r25, 0x00	; 0
    6202:	20 e5       	ldi	r18, 0x50	; 80
    6204:	30 e0       	ldi	r19, 0x00	; 0
    6206:	f9 01       	movw	r30, r18
    6208:	20 81       	ld	r18, Z
    620a:	28 60       	ori	r18, 0x08	; 8
    620c:	fc 01       	movw	r30, r24
    620e:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    6210:	80 e5       	ldi	r24, 0x50	; 80
    6212:	90 e0       	ldi	r25, 0x00	; 0
    6214:	fc 01       	movw	r30, r24
    6216:	81 81       	ldd	r24, Z+1	; 0x01
    6218:	88 2f       	mov	r24, r24
    621a:	90 e0       	ldi	r25, 0x00	; 0
    621c:	88 70       	andi	r24, 0x08	; 8
    621e:	90 70       	andi	r25, 0x00	; 0
    6220:	00 97       	sbiw	r24, 0x00	; 0
    6222:	b1 f3       	breq	.-20     	; 0x6210 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6224:	80 ec       	ldi	r24, 0xC0	; 192
    6226:	62 e0       	ldi	r22, 0x02	; 2
    6228:	0e 94 1f 30 	call	0x603e	; 0x603e <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    622c:	80 e5       	ldi	r24, 0x50	; 80
    622e:	90 e0       	ldi	r25, 0x00	; 0
    6230:	20 e5       	ldi	r18, 0x50	; 80
    6232:	30 e0       	ldi	r19, 0x00	; 0
    6234:	f9 01       	movw	r30, r18
    6236:	20 81       	ld	r18, Z
    6238:	20 61       	ori	r18, 0x10	; 16
    623a:	fc 01       	movw	r30, r24
    623c:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    623e:	80 e5       	ldi	r24, 0x50	; 80
    6240:	90 e0       	ldi	r25, 0x00	; 0
    6242:	fc 01       	movw	r30, r24
    6244:	81 81       	ldd	r24, Z+1	; 0x01
    6246:	88 2f       	mov	r24, r24
    6248:	90 e0       	ldi	r25, 0x00	; 0
    624a:	80 71       	andi	r24, 0x10	; 16
    624c:	90 70       	andi	r25, 0x00	; 0
    624e:	00 97       	sbiw	r24, 0x00	; 0
    6250:	b1 f3       	breq	.-20     	; 0x623e <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    6252:	84 e0       	ldi	r24, 0x04	; 4
    6254:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6258:	81 e0       	ldi	r24, 0x01	; 1
    625a:	0e 94 36 30 	call	0x606c	; 0x606c <CLKSYS_Disable>
}
    625e:	df 91       	pop	r29
    6260:	cf 91       	pop	r28
    6262:	08 95       	ret

00006264 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    6264:	cf 93       	push	r28
    6266:	df 93       	push	r29
    6268:	cd b7       	in	r28, 0x3d	; 61
    626a:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    626c:	80 e5       	ldi	r24, 0x50	; 80
    626e:	90 e0       	ldi	r25, 0x00	; 0
    6270:	20 e5       	ldi	r18, 0x50	; 80
    6272:	30 e0       	ldi	r19, 0x00	; 0
    6274:	f9 01       	movw	r30, r18
    6276:	20 81       	ld	r18, Z
    6278:	22 60       	ori	r18, 0x02	; 2
    627a:	fc 01       	movw	r30, r24
    627c:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    627e:	80 e0       	ldi	r24, 0x00	; 0
    6280:	61 e0       	ldi	r22, 0x01	; 1
    6282:	0e 94 56 30 	call	0x60ac	; 0x60ac <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6286:	80 e5       	ldi	r24, 0x50	; 80
    6288:	90 e0       	ldi	r25, 0x00	; 0
    628a:	fc 01       	movw	r30, r24
    628c:	81 81       	ldd	r24, Z+1	; 0x01
    628e:	88 2f       	mov	r24, r24
    6290:	90 e0       	ldi	r25, 0x00	; 0
    6292:	82 70       	andi	r24, 0x02	; 2
    6294:	90 70       	andi	r25, 0x00	; 0
    6296:	00 97       	sbiw	r24, 0x00	; 0
    6298:	b1 f3       	breq	.-20     	; 0x6286 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    629a:	81 e0       	ldi	r24, 0x01	; 1
    629c:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    62a0:	81 e0       	ldi	r24, 0x01	; 1
    62a2:	0e 94 36 30 	call	0x606c	; 0x606c <CLKSYS_Disable>
	
}
    62a6:	df 91       	pop	r29
    62a8:	cf 91       	pop	r28
    62aa:	08 95       	ret

000062ac <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    62ac:	cf 93       	push	r28
    62ae:	df 93       	push	r29
    62b0:	cd b7       	in	r28, 0x3d	; 61
    62b2:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    62b4:	80 e5       	ldi	r24, 0x50	; 80
    62b6:	90 e0       	ldi	r25, 0x00	; 0
    62b8:	20 e5       	ldi	r18, 0x50	; 80
    62ba:	30 e0       	ldi	r19, 0x00	; 0
    62bc:	f9 01       	movw	r30, r18
    62be:	20 81       	ld	r18, Z
    62c0:	22 60       	ori	r18, 0x02	; 2
    62c2:	fc 01       	movw	r30, r24
    62c4:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    62c6:	80 e0       	ldi	r24, 0x00	; 0
    62c8:	60 e0       	ldi	r22, 0x00	; 0
    62ca:	0e 94 56 30 	call	0x60ac	; 0x60ac <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    62ce:	80 e5       	ldi	r24, 0x50	; 80
    62d0:	90 e0       	ldi	r25, 0x00	; 0
    62d2:	fc 01       	movw	r30, r24
    62d4:	81 81       	ldd	r24, Z+1	; 0x01
    62d6:	88 2f       	mov	r24, r24
    62d8:	90 e0       	ldi	r25, 0x00	; 0
    62da:	82 70       	andi	r24, 0x02	; 2
    62dc:	90 70       	andi	r25, 0x00	; 0
    62de:	00 97       	sbiw	r24, 0x00	; 0
    62e0:	b1 f3       	breq	.-20     	; 0x62ce <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    62e2:	81 e0       	ldi	r24, 0x01	; 1
    62e4:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    62e8:	81 e0       	ldi	r24, 0x01	; 1
    62ea:	0e 94 36 30 	call	0x606c	; 0x606c <CLKSYS_Disable>
	
}
    62ee:	df 91       	pop	r29
    62f0:	cf 91       	pop	r28
    62f2:	08 95       	ret

000062f4 <portExCS>:


void portExCS(uint8_t write) {
    62f4:	0f 93       	push	r16
    62f6:	1f 93       	push	r17
    62f8:	cf 93       	push	r28
    62fa:	df 93       	push	r29
    62fc:	cd b7       	in	r28, 0x3d	; 61
    62fe:	de b7       	in	r29, 0x3e	; 62
    6300:	69 97       	sbiw	r28, 0x19	; 25
    6302:	cd bf       	out	0x3d, r28	; 61
    6304:	de bf       	out	0x3e, r29	; 62
    6306:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6308:	89 8d       	ldd	r24, Y+25	; 0x19
    630a:	88 23       	and	r24, r24
    630c:	31 f0       	breq	.+12     	; 0x631a <portExCS+0x26>
    630e:	80 e0       	ldi	r24, 0x00	; 0
    6310:	96 e0       	ldi	r25, 0x06	; 6
    6312:	28 e0       	ldi	r18, 0x08	; 8
    6314:	fc 01       	movw	r30, r24
    6316:	26 83       	std	Z+6, r18	; 0x06
    6318:	05 c0       	rjmp	.+10     	; 0x6324 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    631a:	80 e0       	ldi	r24, 0x00	; 0
    631c:	96 e0       	ldi	r25, 0x06	; 6
    631e:	28 e0       	ldi	r18, 0x08	; 8
    6320:	fc 01       	movw	r30, r24
    6322:	25 83       	std	Z+5, r18	; 0x05
    6324:	80 e0       	ldi	r24, 0x00	; 0
    6326:	90 e0       	ldi	r25, 0x00	; 0
    6328:	a0 e2       	ldi	r26, 0x20	; 32
    632a:	b1 e4       	ldi	r27, 0x41	; 65
    632c:	89 83       	std	Y+1, r24	; 0x01
    632e:	9a 83       	std	Y+2, r25	; 0x02
    6330:	ab 83       	std	Y+3, r26	; 0x03
    6332:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6334:	69 81       	ldd	r22, Y+1	; 0x01
    6336:	7a 81       	ldd	r23, Y+2	; 0x02
    6338:	8b 81       	ldd	r24, Y+3	; 0x03
    633a:	9c 81       	ldd	r25, Y+4	; 0x04
    633c:	2b ea       	ldi	r18, 0xAB	; 171
    633e:	3a ea       	ldi	r19, 0xAA	; 170
    6340:	4a e2       	ldi	r20, 0x2A	; 42
    6342:	51 e4       	ldi	r21, 0x41	; 65
    6344:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    6348:	dc 01       	movw	r26, r24
    634a:	cb 01       	movw	r24, r22
    634c:	8d 83       	std	Y+5, r24	; 0x05
    634e:	9e 83       	std	Y+6, r25	; 0x06
    6350:	af 83       	std	Y+7, r26	; 0x07
    6352:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6354:	11 e0       	ldi	r17, 0x01	; 1
    6356:	6d 81       	ldd	r22, Y+5	; 0x05
    6358:	7e 81       	ldd	r23, Y+6	; 0x06
    635a:	8f 81       	ldd	r24, Y+7	; 0x07
    635c:	98 85       	ldd	r25, Y+8	; 0x08
    635e:	20 e0       	ldi	r18, 0x00	; 0
    6360:	30 e0       	ldi	r19, 0x00	; 0
    6362:	40 e8       	ldi	r20, 0x80	; 128
    6364:	5f e3       	ldi	r21, 0x3F	; 63
    6366:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    636a:	88 23       	and	r24, r24
    636c:	0c f0       	brlt	.+2      	; 0x6370 <portExCS+0x7c>
    636e:	10 e0       	ldi	r17, 0x00	; 0
    6370:	11 23       	and	r17, r17
    6372:	19 f0       	breq	.+6      	; 0x637a <portExCS+0x86>
		__ticks = 1;
    6374:	81 e0       	ldi	r24, 0x01	; 1
    6376:	89 87       	std	Y+9, r24	; 0x09
    6378:	a3 c0       	rjmp	.+326    	; 0x64c0 <portExCS+0x1cc>
	else if (__tmp > 255)
    637a:	11 e0       	ldi	r17, 0x01	; 1
    637c:	6d 81       	ldd	r22, Y+5	; 0x05
    637e:	7e 81       	ldd	r23, Y+6	; 0x06
    6380:	8f 81       	ldd	r24, Y+7	; 0x07
    6382:	98 85       	ldd	r25, Y+8	; 0x08
    6384:	20 e0       	ldi	r18, 0x00	; 0
    6386:	30 e0       	ldi	r19, 0x00	; 0
    6388:	4f e7       	ldi	r20, 0x7F	; 127
    638a:	53 e4       	ldi	r21, 0x43	; 67
    638c:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    6390:	18 16       	cp	r1, r24
    6392:	0c f0       	brlt	.+2      	; 0x6396 <portExCS+0xa2>
    6394:	10 e0       	ldi	r17, 0x00	; 0
    6396:	11 23       	and	r17, r17
    6398:	09 f4       	brne	.+2      	; 0x639c <portExCS+0xa8>
    639a:	89 c0       	rjmp	.+274    	; 0x64ae <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    639c:	69 81       	ldd	r22, Y+1	; 0x01
    639e:	7a 81       	ldd	r23, Y+2	; 0x02
    63a0:	8b 81       	ldd	r24, Y+3	; 0x03
    63a2:	9c 81       	ldd	r25, Y+4	; 0x04
    63a4:	20 e0       	ldi	r18, 0x00	; 0
    63a6:	30 e0       	ldi	r19, 0x00	; 0
    63a8:	4a e7       	ldi	r20, 0x7A	; 122
    63aa:	54 e4       	ldi	r21, 0x44	; 68
    63ac:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    63b0:	dc 01       	movw	r26, r24
    63b2:	cb 01       	movw	r24, r22
    63b4:	8a 87       	std	Y+10, r24	; 0x0a
    63b6:	9b 87       	std	Y+11, r25	; 0x0b
    63b8:	ac 87       	std	Y+12, r26	; 0x0c
    63ba:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    63bc:	6a 85       	ldd	r22, Y+10	; 0x0a
    63be:	7b 85       	ldd	r23, Y+11	; 0x0b
    63c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    63c2:	9d 85       	ldd	r25, Y+13	; 0x0d
    63c4:	20 e0       	ldi	r18, 0x00	; 0
    63c6:	30 e0       	ldi	r19, 0x00	; 0
    63c8:	4a ef       	ldi	r20, 0xFA	; 250
    63ca:	55 e4       	ldi	r21, 0x45	; 69
    63cc:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    63d0:	dc 01       	movw	r26, r24
    63d2:	cb 01       	movw	r24, r22
    63d4:	8e 87       	std	Y+14, r24	; 0x0e
    63d6:	9f 87       	std	Y+15, r25	; 0x0f
    63d8:	a8 8b       	std	Y+16, r26	; 0x10
    63da:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    63dc:	11 e0       	ldi	r17, 0x01	; 1
    63de:	6e 85       	ldd	r22, Y+14	; 0x0e
    63e0:	7f 85       	ldd	r23, Y+15	; 0x0f
    63e2:	88 89       	ldd	r24, Y+16	; 0x10
    63e4:	99 89       	ldd	r25, Y+17	; 0x11
    63e6:	20 e0       	ldi	r18, 0x00	; 0
    63e8:	30 e0       	ldi	r19, 0x00	; 0
    63ea:	40 e8       	ldi	r20, 0x80	; 128
    63ec:	5f e3       	ldi	r21, 0x3F	; 63
    63ee:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    63f2:	88 23       	and	r24, r24
    63f4:	0c f0       	brlt	.+2      	; 0x63f8 <portExCS+0x104>
    63f6:	10 e0       	ldi	r17, 0x00	; 0
    63f8:	11 23       	and	r17, r17
    63fa:	29 f0       	breq	.+10     	; 0x6406 <portExCS+0x112>
		__ticks = 1;
    63fc:	81 e0       	ldi	r24, 0x01	; 1
    63fe:	90 e0       	ldi	r25, 0x00	; 0
    6400:	8a 8b       	std	Y+18, r24	; 0x12
    6402:	9b 8b       	std	Y+19, r25	; 0x13
    6404:	46 c0       	rjmp	.+140    	; 0x6492 <portExCS+0x19e>
	else if (__tmp > 65535)
    6406:	11 e0       	ldi	r17, 0x01	; 1
    6408:	6e 85       	ldd	r22, Y+14	; 0x0e
    640a:	7f 85       	ldd	r23, Y+15	; 0x0f
    640c:	88 89       	ldd	r24, Y+16	; 0x10
    640e:	99 89       	ldd	r25, Y+17	; 0x11
    6410:	20 e0       	ldi	r18, 0x00	; 0
    6412:	3f ef       	ldi	r19, 0xFF	; 255
    6414:	4f e7       	ldi	r20, 0x7F	; 127
    6416:	57 e4       	ldi	r21, 0x47	; 71
    6418:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    641c:	18 16       	cp	r1, r24
    641e:	0c f0       	brlt	.+2      	; 0x6422 <portExCS+0x12e>
    6420:	10 e0       	ldi	r17, 0x00	; 0
    6422:	11 23       	and	r17, r17
    6424:	61 f1       	breq	.+88     	; 0x647e <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6426:	6a 85       	ldd	r22, Y+10	; 0x0a
    6428:	7b 85       	ldd	r23, Y+11	; 0x0b
    642a:	8c 85       	ldd	r24, Y+12	; 0x0c
    642c:	9d 85       	ldd	r25, Y+13	; 0x0d
    642e:	20 e0       	ldi	r18, 0x00	; 0
    6430:	30 e0       	ldi	r19, 0x00	; 0
    6432:	40 e2       	ldi	r20, 0x20	; 32
    6434:	51 e4       	ldi	r21, 0x41	; 65
    6436:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    643a:	dc 01       	movw	r26, r24
    643c:	cb 01       	movw	r24, r22
    643e:	bc 01       	movw	r22, r24
    6440:	cd 01       	movw	r24, r26
    6442:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6446:	dc 01       	movw	r26, r24
    6448:	cb 01       	movw	r24, r22
    644a:	8a 8b       	std	Y+18, r24	; 0x12
    644c:	9b 8b       	std	Y+19, r25	; 0x13
    644e:	12 c0       	rjmp	.+36     	; 0x6474 <portExCS+0x180>
    6450:	80 e2       	ldi	r24, 0x20	; 32
    6452:	93 e0       	ldi	r25, 0x03	; 3
    6454:	8c 8b       	std	Y+20, r24	; 0x14
    6456:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6458:	8c 89       	ldd	r24, Y+20	; 0x14
    645a:	9d 89       	ldd	r25, Y+21	; 0x15
    645c:	8c 01       	movw	r16, r24
    645e:	c8 01       	movw	r24, r16
    6460:	01 97       	sbiw	r24, 0x01	; 1
    6462:	f1 f7       	brne	.-4      	; 0x6460 <portExCS+0x16c>
    6464:	8c 01       	movw	r16, r24
    6466:	0c 8b       	std	Y+20, r16	; 0x14
    6468:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    646a:	8a 89       	ldd	r24, Y+18	; 0x12
    646c:	9b 89       	ldd	r25, Y+19	; 0x13
    646e:	01 97       	sbiw	r24, 0x01	; 1
    6470:	8a 8b       	std	Y+18, r24	; 0x12
    6472:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6474:	8a 89       	ldd	r24, Y+18	; 0x12
    6476:	9b 89       	ldd	r25, Y+19	; 0x13
    6478:	00 97       	sbiw	r24, 0x00	; 0
    647a:	51 f7       	brne	.-44     	; 0x6450 <portExCS+0x15c>
    647c:	28 c0       	rjmp	.+80     	; 0x64ce <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    647e:	6e 85       	ldd	r22, Y+14	; 0x0e
    6480:	7f 85       	ldd	r23, Y+15	; 0x0f
    6482:	88 89       	ldd	r24, Y+16	; 0x10
    6484:	99 89       	ldd	r25, Y+17	; 0x11
    6486:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    648a:	dc 01       	movw	r26, r24
    648c:	cb 01       	movw	r24, r22
    648e:	8a 8b       	std	Y+18, r24	; 0x12
    6490:	9b 8b       	std	Y+19, r25	; 0x13
    6492:	8a 89       	ldd	r24, Y+18	; 0x12
    6494:	9b 89       	ldd	r25, Y+19	; 0x13
    6496:	8e 8b       	std	Y+22, r24	; 0x16
    6498:	9f 8b       	std	Y+23, r25	; 0x17
    649a:	8e 89       	ldd	r24, Y+22	; 0x16
    649c:	9f 89       	ldd	r25, Y+23	; 0x17
    649e:	8c 01       	movw	r16, r24
    64a0:	f8 01       	movw	r30, r16
    64a2:	31 97       	sbiw	r30, 0x01	; 1
    64a4:	f1 f7       	brne	.-4      	; 0x64a2 <portExCS+0x1ae>
    64a6:	8f 01       	movw	r16, r30
    64a8:	0e 8b       	std	Y+22, r16	; 0x16
    64aa:	1f 8b       	std	Y+23, r17	; 0x17
    64ac:	10 c0       	rjmp	.+32     	; 0x64ce <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    64ae:	6d 81       	ldd	r22, Y+5	; 0x05
    64b0:	7e 81       	ldd	r23, Y+6	; 0x06
    64b2:	8f 81       	ldd	r24, Y+7	; 0x07
    64b4:	98 85       	ldd	r25, Y+8	; 0x08
    64b6:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    64ba:	dc 01       	movw	r26, r24
    64bc:	cb 01       	movw	r24, r22
    64be:	89 87       	std	Y+9, r24	; 0x09
    64c0:	89 85       	ldd	r24, Y+9	; 0x09
    64c2:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    64c4:	88 8d       	ldd	r24, Y+24	; 0x18
    64c6:	18 2f       	mov	r17, r24
    64c8:	1a 95       	dec	r17
    64ca:	f1 f7       	brne	.-4      	; 0x64c8 <portExCS+0x1d4>
    64cc:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    64ce:	69 96       	adiw	r28, 0x19	; 25
    64d0:	cd bf       	out	0x3d, r28	; 61
    64d2:	de bf       	out	0x3e, r29	; 62
    64d4:	df 91       	pop	r29
    64d6:	cf 91       	pop	r28
    64d8:	1f 91       	pop	r17
    64da:	0f 91       	pop	r16
    64dc:	08 95       	ret

000064de <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    64de:	cf 93       	push	r28
    64e0:	df 93       	push	r29
    64e2:	00 d0       	rcall	.+0      	; 0x64e4 <PortEx_DIRSET+0x6>
    64e4:	cd b7       	in	r28, 0x3d	; 61
    64e6:	de b7       	in	r29, 0x3e	; 62
    64e8:	8a 83       	std	Y+2, r24	; 0x02
    64ea:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    64ec:	80 e0       	ldi	r24, 0x00	; 0
    64ee:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    64f2:	81 e0       	ldi	r24, 0x01	; 1
    64f4:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	portExCS(TRUE);
    64f8:	81 e0       	ldi	r24, 0x01	; 1
    64fa:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    64fe:	8b 81       	ldd	r24, Y+3	; 0x03
    6500:	88 23       	and	r24, r24
    6502:	39 f0       	breq	.+14     	; 0x6512 <PortEx_DIRSET+0x34>
    6504:	90 91 6f 50 	lds	r25, 0x506F
    6508:	8a 81       	ldd	r24, Y+2	; 0x02
    650a:	89 2b       	or	r24, r25
    650c:	80 93 6f 50 	sts	0x506F, r24
    6510:	06 c0       	rjmp	.+12     	; 0x651e <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6512:	90 91 ca 50 	lds	r25, 0x50CA
    6516:	8a 81       	ldd	r24, Y+2	; 0x02
    6518:	89 2b       	or	r24, r25
    651a:	80 93 ca 50 	sts	0x50CA, r24
	
	SPIBuffer[0] = PS_WRITE;
    651e:	80 e4       	ldi	r24, 0x40	; 64
    6520:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    6524:	8b 81       	ldd	r24, Y+3	; 0x03
    6526:	88 23       	and	r24, r24
    6528:	41 f0       	breq	.+16     	; 0x653a <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    652a:	10 92 5b 50 	sts	0x505B, r1
		SPIBuffer[2] = ~bankA_DIR; 
    652e:	80 91 6f 50 	lds	r24, 0x506F
    6532:	80 95       	com	r24
    6534:	80 93 5c 50 	sts	0x505C, r24
    6538:	08 c0       	rjmp	.+16     	; 0x654a <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    653a:	81 e0       	ldi	r24, 0x01	; 1
    653c:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = ~bankB_DIR;
    6540:	80 91 ca 50 	lds	r24, 0x50CA
    6544:	80 95       	com	r24
    6546:	80 93 5c 50 	sts	0x505C, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    654a:	19 82       	std	Y+1, r1	; 0x01
    654c:	1b c0       	rjmp	.+54     	; 0x6584 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    654e:	80 ec       	ldi	r24, 0xC0	; 192
    6550:	98 e0       	ldi	r25, 0x08	; 8
    6552:	29 81       	ldd	r18, Y+1	; 0x01
    6554:	22 2f       	mov	r18, r18
    6556:	30 e0       	ldi	r19, 0x00	; 0
    6558:	26 5a       	subi	r18, 0xA6	; 166
    655a:	3f 4a       	sbci	r19, 0xAF	; 175
    655c:	f9 01       	movw	r30, r18
    655e:	20 81       	ld	r18, Z
    6560:	fc 01       	movw	r30, r24
    6562:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6564:	00 00       	nop
    6566:	80 ec       	ldi	r24, 0xC0	; 192
    6568:	98 e0       	ldi	r25, 0x08	; 8
    656a:	fc 01       	movw	r30, r24
    656c:	82 81       	ldd	r24, Z+2	; 0x02
    656e:	88 23       	and	r24, r24
    6570:	d4 f7       	brge	.-12     	; 0x6566 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6572:	80 ec       	ldi	r24, 0xC0	; 192
    6574:	98 e0       	ldi	r25, 0x08	; 8
    6576:	fc 01       	movw	r30, r24
    6578:	83 81       	ldd	r24, Z+3	; 0x03
    657a:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    657e:	89 81       	ldd	r24, Y+1	; 0x01
    6580:	8f 5f       	subi	r24, 0xFF	; 255
    6582:	89 83       	std	Y+1, r24	; 0x01
    6584:	89 81       	ldd	r24, Y+1	; 0x01
    6586:	83 30       	cpi	r24, 0x03	; 3
    6588:	10 f3       	brcs	.-60     	; 0x654e <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    658a:	80 e0       	ldi	r24, 0x00	; 0
    658c:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>
	SPICS(FALSE);
    6590:	80 e0       	ldi	r24, 0x00	; 0
    6592:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    6596:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>


}
    659a:	23 96       	adiw	r28, 0x03	; 3
    659c:	cd bf       	out	0x3d, r28	; 61
    659e:	de bf       	out	0x3e, r29	; 62
    65a0:	df 91       	pop	r29
    65a2:	cf 91       	pop	r28
    65a4:	08 95       	ret

000065a6 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    65a6:	cf 93       	push	r28
    65a8:	df 93       	push	r29
    65aa:	00 d0       	rcall	.+0      	; 0x65ac <PortEx_DIRCLR+0x6>
    65ac:	cd b7       	in	r28, 0x3d	; 61
    65ae:	de b7       	in	r29, 0x3e	; 62
    65b0:	8a 83       	std	Y+2, r24	; 0x02
    65b2:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    65b4:	80 e0       	ldi	r24, 0x00	; 0
    65b6:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    65ba:	81 e0       	ldi	r24, 0x01	; 1
    65bc:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	portExCS(TRUE);
    65c0:	81 e0       	ldi	r24, 0x01	; 1
    65c2:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    65c6:	8b 81       	ldd	r24, Y+3	; 0x03
    65c8:	88 23       	and	r24, r24
    65ca:	49 f0       	breq	.+18     	; 0x65de <PortEx_DIRCLR+0x38>
    65cc:	80 91 6f 50 	lds	r24, 0x506F
    65d0:	98 2f       	mov	r25, r24
    65d2:	90 95       	com	r25
    65d4:	8a 81       	ldd	r24, Y+2	; 0x02
    65d6:	89 23       	and	r24, r25
    65d8:	80 93 6f 50 	sts	0x506F, r24
    65dc:	08 c0       	rjmp	.+16     	; 0x65ee <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    65de:	80 91 ca 50 	lds	r24, 0x50CA
    65e2:	98 2f       	mov	r25, r24
    65e4:	90 95       	com	r25
    65e6:	8a 81       	ldd	r24, Y+2	; 0x02
    65e8:	89 23       	and	r24, r25
    65ea:	80 93 ca 50 	sts	0x50CA, r24
	
	SPIBuffer[0] = PS_WRITE;
    65ee:	80 e4       	ldi	r24, 0x40	; 64
    65f0:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    65f4:	8b 81       	ldd	r24, Y+3	; 0x03
    65f6:	88 23       	and	r24, r24
    65f8:	41 f0       	breq	.+16     	; 0x660a <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    65fa:	10 92 5b 50 	sts	0x505B, r1
		SPIBuffer[2] = ~bankA_DIR; 
    65fe:	80 91 6f 50 	lds	r24, 0x506F
    6602:	80 95       	com	r24
    6604:	80 93 5c 50 	sts	0x505C, r24
    6608:	08 c0       	rjmp	.+16     	; 0x661a <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    660a:	81 e0       	ldi	r24, 0x01	; 1
    660c:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = ~bankB_DIR;
    6610:	80 91 ca 50 	lds	r24, 0x50CA
    6614:	80 95       	com	r24
    6616:	80 93 5c 50 	sts	0x505C, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    661a:	19 82       	std	Y+1, r1	; 0x01
    661c:	1b c0       	rjmp	.+54     	; 0x6654 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    661e:	80 ec       	ldi	r24, 0xC0	; 192
    6620:	98 e0       	ldi	r25, 0x08	; 8
    6622:	29 81       	ldd	r18, Y+1	; 0x01
    6624:	22 2f       	mov	r18, r18
    6626:	30 e0       	ldi	r19, 0x00	; 0
    6628:	26 5a       	subi	r18, 0xA6	; 166
    662a:	3f 4a       	sbci	r19, 0xAF	; 175
    662c:	f9 01       	movw	r30, r18
    662e:	20 81       	ld	r18, Z
    6630:	fc 01       	movw	r30, r24
    6632:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6634:	00 00       	nop
    6636:	80 ec       	ldi	r24, 0xC0	; 192
    6638:	98 e0       	ldi	r25, 0x08	; 8
    663a:	fc 01       	movw	r30, r24
    663c:	82 81       	ldd	r24, Z+2	; 0x02
    663e:	88 23       	and	r24, r24
    6640:	d4 f7       	brge	.-12     	; 0x6636 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6642:	80 ec       	ldi	r24, 0xC0	; 192
    6644:	98 e0       	ldi	r25, 0x08	; 8
    6646:	fc 01       	movw	r30, r24
    6648:	83 81       	ldd	r24, Z+3	; 0x03
    664a:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    664e:	89 81       	ldd	r24, Y+1	; 0x01
    6650:	8f 5f       	subi	r24, 0xFF	; 255
    6652:	89 83       	std	Y+1, r24	; 0x01
    6654:	89 81       	ldd	r24, Y+1	; 0x01
    6656:	83 30       	cpi	r24, 0x03	; 3
    6658:	10 f3       	brcs	.-60     	; 0x661e <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    665a:	80 e0       	ldi	r24, 0x00	; 0
    665c:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	portExCS(FALSE);
    6660:	80 e0       	ldi	r24, 0x00	; 0
    6662:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>
	SPIDisable();
    6666:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
}
    666a:	23 96       	adiw	r28, 0x03	; 3
    666c:	cd bf       	out	0x3d, r28	; 61
    666e:	de bf       	out	0x3e, r29	; 62
    6670:	df 91       	pop	r29
    6672:	cf 91       	pop	r28
    6674:	08 95       	ret

00006676 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6676:	cf 93       	push	r28
    6678:	df 93       	push	r29
    667a:	00 d0       	rcall	.+0      	; 0x667c <PortEx_OUTSET+0x6>
    667c:	cd b7       	in	r28, 0x3d	; 61
    667e:	de b7       	in	r29, 0x3e	; 62
    6680:	8a 83       	std	Y+2, r24	; 0x02
    6682:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6684:	80 e0       	ldi	r24, 0x00	; 0
    6686:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    668a:	81 e0       	ldi	r24, 0x01	; 1
    668c:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	portExCS(TRUE);
    6690:	81 e0       	ldi	r24, 0x01	; 1
    6692:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6696:	8b 81       	ldd	r24, Y+3	; 0x03
    6698:	88 23       	and	r24, r24
    669a:	39 f0       	breq	.+14     	; 0x66aa <PortEx_OUTSET+0x34>
    669c:	90 91 c3 23 	lds	r25, 0x23C3
    66a0:	8a 81       	ldd	r24, Y+2	; 0x02
    66a2:	89 2b       	or	r24, r25
    66a4:	80 93 c3 23 	sts	0x23C3, r24
    66a8:	06 c0       	rjmp	.+12     	; 0x66b6 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    66aa:	90 91 77 50 	lds	r25, 0x5077
    66ae:	8a 81       	ldd	r24, Y+2	; 0x02
    66b0:	89 2b       	or	r24, r25
    66b2:	80 93 77 50 	sts	0x5077, r24
	
	SPIBuffer[0] = PS_WRITE;
    66b6:	80 e4       	ldi	r24, 0x40	; 64
    66b8:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    66bc:	8b 81       	ldd	r24, Y+3	; 0x03
    66be:	88 23       	and	r24, r24
    66c0:	41 f0       	breq	.+16     	; 0x66d2 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    66c2:	84 e1       	ldi	r24, 0x14	; 20
    66c4:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankA_OUT;
    66c8:	80 91 c3 23 	lds	r24, 0x23C3
    66cc:	80 93 5c 50 	sts	0x505C, r24
    66d0:	07 c0       	rjmp	.+14     	; 0x66e0 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    66d2:	85 e1       	ldi	r24, 0x15	; 21
    66d4:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankB_OUT; 
    66d8:	80 91 77 50 	lds	r24, 0x5077
    66dc:	80 93 5c 50 	sts	0x505C, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    66e0:	19 82       	std	Y+1, r1	; 0x01
    66e2:	1b c0       	rjmp	.+54     	; 0x671a <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    66e4:	80 ec       	ldi	r24, 0xC0	; 192
    66e6:	98 e0       	ldi	r25, 0x08	; 8
    66e8:	29 81       	ldd	r18, Y+1	; 0x01
    66ea:	22 2f       	mov	r18, r18
    66ec:	30 e0       	ldi	r19, 0x00	; 0
    66ee:	26 5a       	subi	r18, 0xA6	; 166
    66f0:	3f 4a       	sbci	r19, 0xAF	; 175
    66f2:	f9 01       	movw	r30, r18
    66f4:	20 81       	ld	r18, Z
    66f6:	fc 01       	movw	r30, r24
    66f8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    66fa:	00 00       	nop
    66fc:	80 ec       	ldi	r24, 0xC0	; 192
    66fe:	98 e0       	ldi	r25, 0x08	; 8
    6700:	fc 01       	movw	r30, r24
    6702:	82 81       	ldd	r24, Z+2	; 0x02
    6704:	88 23       	and	r24, r24
    6706:	d4 f7       	brge	.-12     	; 0x66fc <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6708:	80 ec       	ldi	r24, 0xC0	; 192
    670a:	98 e0       	ldi	r25, 0x08	; 8
    670c:	fc 01       	movw	r30, r24
    670e:	83 81       	ldd	r24, Z+3	; 0x03
    6710:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6714:	89 81       	ldd	r24, Y+1	; 0x01
    6716:	8f 5f       	subi	r24, 0xFF	; 255
    6718:	89 83       	std	Y+1, r24	; 0x01
    671a:	89 81       	ldd	r24, Y+1	; 0x01
    671c:	83 30       	cpi	r24, 0x03	; 3
    671e:	10 f3       	brcs	.-60     	; 0x66e4 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6720:	80 e0       	ldi	r24, 0x00	; 0
    6722:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	portExCS(FALSE);
    6726:	80 e0       	ldi	r24, 0x00	; 0
    6728:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>
	SPIDisable();
    672c:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
}
    6730:	23 96       	adiw	r28, 0x03	; 3
    6732:	cd bf       	out	0x3d, r28	; 61
    6734:	de bf       	out	0x3e, r29	; 62
    6736:	df 91       	pop	r29
    6738:	cf 91       	pop	r28
    673a:	08 95       	ret

0000673c <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    673c:	cf 93       	push	r28
    673e:	df 93       	push	r29
    6740:	00 d0       	rcall	.+0      	; 0x6742 <PortEx_OUTCLR+0x6>
    6742:	cd b7       	in	r28, 0x3d	; 61
    6744:	de b7       	in	r29, 0x3e	; 62
    6746:	8a 83       	std	Y+2, r24	; 0x02
    6748:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    674a:	80 e0       	ldi	r24, 0x00	; 0
    674c:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    6750:	81 e0       	ldi	r24, 0x01	; 1
    6752:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	portExCS(TRUE);
    6756:	81 e0       	ldi	r24, 0x01	; 1
    6758:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    675c:	8b 81       	ldd	r24, Y+3	; 0x03
    675e:	88 23       	and	r24, r24
    6760:	49 f0       	breq	.+18     	; 0x6774 <PortEx_OUTCLR+0x38>
    6762:	8a 81       	ldd	r24, Y+2	; 0x02
    6764:	98 2f       	mov	r25, r24
    6766:	90 95       	com	r25
    6768:	80 91 c3 23 	lds	r24, 0x23C3
    676c:	89 23       	and	r24, r25
    676e:	80 93 c3 23 	sts	0x23C3, r24
    6772:	08 c0       	rjmp	.+16     	; 0x6784 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6774:	8a 81       	ldd	r24, Y+2	; 0x02
    6776:	98 2f       	mov	r25, r24
    6778:	90 95       	com	r25
    677a:	80 91 77 50 	lds	r24, 0x5077
    677e:	89 23       	and	r24, r25
    6780:	80 93 77 50 	sts	0x5077, r24
	
	SPIBuffer[0] = PS_WRITE;
    6784:	80 e4       	ldi	r24, 0x40	; 64
    6786:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    678a:	8b 81       	ldd	r24, Y+3	; 0x03
    678c:	88 23       	and	r24, r24
    678e:	41 f0       	breq	.+16     	; 0x67a0 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6790:	84 e1       	ldi	r24, 0x14	; 20
    6792:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankA_OUT;
    6796:	80 91 c3 23 	lds	r24, 0x23C3
    679a:	80 93 5c 50 	sts	0x505C, r24
    679e:	07 c0       	rjmp	.+14     	; 0x67ae <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    67a0:	85 e1       	ldi	r24, 0x15	; 21
    67a2:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankB_OUT; 
    67a6:	80 91 77 50 	lds	r24, 0x5077
    67aa:	80 93 5c 50 	sts	0x505C, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    67ae:	19 82       	std	Y+1, r1	; 0x01
    67b0:	1b c0       	rjmp	.+54     	; 0x67e8 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    67b2:	80 ec       	ldi	r24, 0xC0	; 192
    67b4:	98 e0       	ldi	r25, 0x08	; 8
    67b6:	29 81       	ldd	r18, Y+1	; 0x01
    67b8:	22 2f       	mov	r18, r18
    67ba:	30 e0       	ldi	r19, 0x00	; 0
    67bc:	26 5a       	subi	r18, 0xA6	; 166
    67be:	3f 4a       	sbci	r19, 0xAF	; 175
    67c0:	f9 01       	movw	r30, r18
    67c2:	20 81       	ld	r18, Z
    67c4:	fc 01       	movw	r30, r24
    67c6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    67c8:	00 00       	nop
    67ca:	80 ec       	ldi	r24, 0xC0	; 192
    67cc:	98 e0       	ldi	r25, 0x08	; 8
    67ce:	fc 01       	movw	r30, r24
    67d0:	82 81       	ldd	r24, Z+2	; 0x02
    67d2:	88 23       	and	r24, r24
    67d4:	d4 f7       	brge	.-12     	; 0x67ca <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    67d6:	80 ec       	ldi	r24, 0xC0	; 192
    67d8:	98 e0       	ldi	r25, 0x08	; 8
    67da:	fc 01       	movw	r30, r24
    67dc:	83 81       	ldd	r24, Z+3	; 0x03
    67de:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    67e2:	89 81       	ldd	r24, Y+1	; 0x01
    67e4:	8f 5f       	subi	r24, 0xFF	; 255
    67e6:	89 83       	std	Y+1, r24	; 0x01
    67e8:	89 81       	ldd	r24, Y+1	; 0x01
    67ea:	83 30       	cpi	r24, 0x03	; 3
    67ec:	10 f3       	brcs	.-60     	; 0x67b2 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    67ee:	80 e0       	ldi	r24, 0x00	; 0
    67f0:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	portExCS(FALSE);
    67f4:	80 e0       	ldi	r24, 0x00	; 0
    67f6:	0e 94 7a 31 	call	0x62f4	; 0x62f4 <portExCS>
	SPIDisable();
    67fa:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
}
    67fe:	23 96       	adiw	r28, 0x03	; 3
    6800:	cd bf       	out	0x3d, r28	; 61
    6802:	de bf       	out	0x3e, r29	; 62
    6804:	df 91       	pop	r29
    6806:	cf 91       	pop	r28
    6808:	08 95       	ret

0000680a <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    680a:	0f 93       	push	r16
    680c:	1f 93       	push	r17
    680e:	cf 93       	push	r28
    6810:	df 93       	push	r29
    6812:	cd b7       	in	r28, 0x3d	; 61
    6814:	de b7       	in	r29, 0x3e	; 62
    6816:	2f 97       	sbiw	r28, 0x0f	; 15
    6818:	cd bf       	out	0x3d, r28	; 61
    681a:	de bf       	out	0x3e, r29	; 62
    681c:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    681e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6820:	88 23       	and	r24, r24
    6822:	09 f4       	brne	.+2      	; 0x6826 <Ext1Power+0x1c>
    6824:	8b c0       	rjmp	.+278    	; 0x693c <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6826:	80 ea       	ldi	r24, 0xA0	; 160
    6828:	96 e0       	ldi	r25, 0x06	; 6
    682a:	20 e2       	ldi	r18, 0x20	; 32
    682c:	fc 01       	movw	r30, r24
    682e:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6830:	80 ea       	ldi	r24, 0xA0	; 160
    6832:	96 e0       	ldi	r25, 0x06	; 6
    6834:	20 e2       	ldi	r18, 0x20	; 32
    6836:	fc 01       	movw	r30, r24
    6838:	25 83       	std	Z+5, r18	; 0x05
    683a:	80 e0       	ldi	r24, 0x00	; 0
    683c:	90 e0       	ldi	r25, 0x00	; 0
    683e:	a8 ec       	ldi	r26, 0xC8	; 200
    6840:	b2 e4       	ldi	r27, 0x42	; 66
    6842:	89 83       	std	Y+1, r24	; 0x01
    6844:	9a 83       	std	Y+2, r25	; 0x02
    6846:	ab 83       	std	Y+3, r26	; 0x03
    6848:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    684a:	69 81       	ldd	r22, Y+1	; 0x01
    684c:	7a 81       	ldd	r23, Y+2	; 0x02
    684e:	8b 81       	ldd	r24, Y+3	; 0x03
    6850:	9c 81       	ldd	r25, Y+4	; 0x04
    6852:	20 e0       	ldi	r18, 0x00	; 0
    6854:	30 e0       	ldi	r19, 0x00	; 0
    6856:	4a ef       	ldi	r20, 0xFA	; 250
    6858:	55 e4       	ldi	r21, 0x45	; 69
    685a:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    685e:	dc 01       	movw	r26, r24
    6860:	cb 01       	movw	r24, r22
    6862:	8d 83       	std	Y+5, r24	; 0x05
    6864:	9e 83       	std	Y+6, r25	; 0x06
    6866:	af 83       	std	Y+7, r26	; 0x07
    6868:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    686a:	11 e0       	ldi	r17, 0x01	; 1
    686c:	6d 81       	ldd	r22, Y+5	; 0x05
    686e:	7e 81       	ldd	r23, Y+6	; 0x06
    6870:	8f 81       	ldd	r24, Y+7	; 0x07
    6872:	98 85       	ldd	r25, Y+8	; 0x08
    6874:	20 e0       	ldi	r18, 0x00	; 0
    6876:	30 e0       	ldi	r19, 0x00	; 0
    6878:	40 e8       	ldi	r20, 0x80	; 128
    687a:	5f e3       	ldi	r21, 0x3F	; 63
    687c:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    6880:	88 23       	and	r24, r24
    6882:	0c f0       	brlt	.+2      	; 0x6886 <Ext1Power+0x7c>
    6884:	10 e0       	ldi	r17, 0x00	; 0
    6886:	11 23       	and	r17, r17
    6888:	29 f0       	breq	.+10     	; 0x6894 <Ext1Power+0x8a>
		__ticks = 1;
    688a:	81 e0       	ldi	r24, 0x01	; 1
    688c:	90 e0       	ldi	r25, 0x00	; 0
    688e:	89 87       	std	Y+9, r24	; 0x09
    6890:	9a 87       	std	Y+10, r25	; 0x0a
    6892:	46 c0       	rjmp	.+140    	; 0x6920 <Ext1Power+0x116>
	else if (__tmp > 65535)
    6894:	11 e0       	ldi	r17, 0x01	; 1
    6896:	6d 81       	ldd	r22, Y+5	; 0x05
    6898:	7e 81       	ldd	r23, Y+6	; 0x06
    689a:	8f 81       	ldd	r24, Y+7	; 0x07
    689c:	98 85       	ldd	r25, Y+8	; 0x08
    689e:	20 e0       	ldi	r18, 0x00	; 0
    68a0:	3f ef       	ldi	r19, 0xFF	; 255
    68a2:	4f e7       	ldi	r20, 0x7F	; 127
    68a4:	57 e4       	ldi	r21, 0x47	; 71
    68a6:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    68aa:	18 16       	cp	r1, r24
    68ac:	0c f0       	brlt	.+2      	; 0x68b0 <Ext1Power+0xa6>
    68ae:	10 e0       	ldi	r17, 0x00	; 0
    68b0:	11 23       	and	r17, r17
    68b2:	61 f1       	breq	.+88     	; 0x690c <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    68b4:	69 81       	ldd	r22, Y+1	; 0x01
    68b6:	7a 81       	ldd	r23, Y+2	; 0x02
    68b8:	8b 81       	ldd	r24, Y+3	; 0x03
    68ba:	9c 81       	ldd	r25, Y+4	; 0x04
    68bc:	20 e0       	ldi	r18, 0x00	; 0
    68be:	30 e0       	ldi	r19, 0x00	; 0
    68c0:	40 e2       	ldi	r20, 0x20	; 32
    68c2:	51 e4       	ldi	r21, 0x41	; 65
    68c4:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    68c8:	dc 01       	movw	r26, r24
    68ca:	cb 01       	movw	r24, r22
    68cc:	bc 01       	movw	r22, r24
    68ce:	cd 01       	movw	r24, r26
    68d0:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    68d4:	dc 01       	movw	r26, r24
    68d6:	cb 01       	movw	r24, r22
    68d8:	89 87       	std	Y+9, r24	; 0x09
    68da:	9a 87       	std	Y+10, r25	; 0x0a
    68dc:	12 c0       	rjmp	.+36     	; 0x6902 <Ext1Power+0xf8>
    68de:	80 e2       	ldi	r24, 0x20	; 32
    68e0:	93 e0       	ldi	r25, 0x03	; 3
    68e2:	8b 87       	std	Y+11, r24	; 0x0b
    68e4:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    68e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    68e8:	9c 85       	ldd	r25, Y+12	; 0x0c
    68ea:	8c 01       	movw	r16, r24
    68ec:	c8 01       	movw	r24, r16
    68ee:	01 97       	sbiw	r24, 0x01	; 1
    68f0:	f1 f7       	brne	.-4      	; 0x68ee <Ext1Power+0xe4>
    68f2:	8c 01       	movw	r16, r24
    68f4:	0b 87       	std	Y+11, r16	; 0x0b
    68f6:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    68f8:	89 85       	ldd	r24, Y+9	; 0x09
    68fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    68fc:	01 97       	sbiw	r24, 0x01	; 1
    68fe:	89 87       	std	Y+9, r24	; 0x09
    6900:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6902:	89 85       	ldd	r24, Y+9	; 0x09
    6904:	9a 85       	ldd	r25, Y+10	; 0x0a
    6906:	00 97       	sbiw	r24, 0x00	; 0
    6908:	51 f7       	brne	.-44     	; 0x68de <Ext1Power+0xd4>
    690a:	22 c0       	rjmp	.+68     	; 0x6950 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    690c:	6d 81       	ldd	r22, Y+5	; 0x05
    690e:	7e 81       	ldd	r23, Y+6	; 0x06
    6910:	8f 81       	ldd	r24, Y+7	; 0x07
    6912:	98 85       	ldd	r25, Y+8	; 0x08
    6914:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6918:	dc 01       	movw	r26, r24
    691a:	cb 01       	movw	r24, r22
    691c:	89 87       	std	Y+9, r24	; 0x09
    691e:	9a 87       	std	Y+10, r25	; 0x0a
    6920:	89 85       	ldd	r24, Y+9	; 0x09
    6922:	9a 85       	ldd	r25, Y+10	; 0x0a
    6924:	8d 87       	std	Y+13, r24	; 0x0d
    6926:	9e 87       	std	Y+14, r25	; 0x0e
    6928:	8d 85       	ldd	r24, Y+13	; 0x0d
    692a:	9e 85       	ldd	r25, Y+14	; 0x0e
    692c:	8c 01       	movw	r16, r24
    692e:	f8 01       	movw	r30, r16
    6930:	31 97       	sbiw	r30, 0x01	; 1
    6932:	f1 f7       	brne	.-4      	; 0x6930 <Ext1Power+0x126>
    6934:	8f 01       	movw	r16, r30
    6936:	0d 87       	std	Y+13, r16	; 0x0d
    6938:	1e 87       	std	Y+14, r17	; 0x0e
    693a:	0a c0       	rjmp	.+20     	; 0x6950 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    693c:	80 ea       	ldi	r24, 0xA0	; 160
    693e:	96 e0       	ldi	r25, 0x06	; 6
    6940:	20 e2       	ldi	r18, 0x20	; 32
    6942:	fc 01       	movw	r30, r24
    6944:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6946:	80 ea       	ldi	r24, 0xA0	; 160
    6948:	96 e0       	ldi	r25, 0x06	; 6
    694a:	20 e2       	ldi	r18, 0x20	; 32
    694c:	fc 01       	movw	r30, r24
    694e:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6950:	2f 96       	adiw	r28, 0x0f	; 15
    6952:	cd bf       	out	0x3d, r28	; 61
    6954:	de bf       	out	0x3e, r29	; 62
    6956:	df 91       	pop	r29
    6958:	cf 91       	pop	r28
    695a:	1f 91       	pop	r17
    695c:	0f 91       	pop	r16
    695e:	08 95       	ret

00006960 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6960:	0f 93       	push	r16
    6962:	1f 93       	push	r17
    6964:	cf 93       	push	r28
    6966:	df 93       	push	r29
    6968:	cd b7       	in	r28, 0x3d	; 61
    696a:	de b7       	in	r29, 0x3e	; 62
    696c:	2f 97       	sbiw	r28, 0x0f	; 15
    696e:	cd bf       	out	0x3d, r28	; 61
    6970:	de bf       	out	0x3e, r29	; 62
    6972:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6974:	8f 85       	ldd	r24, Y+15	; 0x0f
    6976:	88 23       	and	r24, r24
    6978:	09 f4       	brne	.+2      	; 0x697c <Ext2Power+0x1c>
    697a:	8b c0       	rjmp	.+278    	; 0x6a92 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    697c:	80 ea       	ldi	r24, 0xA0	; 160
    697e:	96 e0       	ldi	r25, 0x06	; 6
    6980:	20 e4       	ldi	r18, 0x40	; 64
    6982:	fc 01       	movw	r30, r24
    6984:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6986:	80 ea       	ldi	r24, 0xA0	; 160
    6988:	96 e0       	ldi	r25, 0x06	; 6
    698a:	20 e4       	ldi	r18, 0x40	; 64
    698c:	fc 01       	movw	r30, r24
    698e:	25 83       	std	Z+5, r18	; 0x05
    6990:	80 e0       	ldi	r24, 0x00	; 0
    6992:	90 e0       	ldi	r25, 0x00	; 0
    6994:	a8 ec       	ldi	r26, 0xC8	; 200
    6996:	b2 e4       	ldi	r27, 0x42	; 66
    6998:	89 83       	std	Y+1, r24	; 0x01
    699a:	9a 83       	std	Y+2, r25	; 0x02
    699c:	ab 83       	std	Y+3, r26	; 0x03
    699e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    69a0:	69 81       	ldd	r22, Y+1	; 0x01
    69a2:	7a 81       	ldd	r23, Y+2	; 0x02
    69a4:	8b 81       	ldd	r24, Y+3	; 0x03
    69a6:	9c 81       	ldd	r25, Y+4	; 0x04
    69a8:	20 e0       	ldi	r18, 0x00	; 0
    69aa:	30 e0       	ldi	r19, 0x00	; 0
    69ac:	4a ef       	ldi	r20, 0xFA	; 250
    69ae:	55 e4       	ldi	r21, 0x45	; 69
    69b0:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    69b4:	dc 01       	movw	r26, r24
    69b6:	cb 01       	movw	r24, r22
    69b8:	8d 83       	std	Y+5, r24	; 0x05
    69ba:	9e 83       	std	Y+6, r25	; 0x06
    69bc:	af 83       	std	Y+7, r26	; 0x07
    69be:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    69c0:	11 e0       	ldi	r17, 0x01	; 1
    69c2:	6d 81       	ldd	r22, Y+5	; 0x05
    69c4:	7e 81       	ldd	r23, Y+6	; 0x06
    69c6:	8f 81       	ldd	r24, Y+7	; 0x07
    69c8:	98 85       	ldd	r25, Y+8	; 0x08
    69ca:	20 e0       	ldi	r18, 0x00	; 0
    69cc:	30 e0       	ldi	r19, 0x00	; 0
    69ce:	40 e8       	ldi	r20, 0x80	; 128
    69d0:	5f e3       	ldi	r21, 0x3F	; 63
    69d2:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    69d6:	88 23       	and	r24, r24
    69d8:	0c f0       	brlt	.+2      	; 0x69dc <Ext2Power+0x7c>
    69da:	10 e0       	ldi	r17, 0x00	; 0
    69dc:	11 23       	and	r17, r17
    69de:	29 f0       	breq	.+10     	; 0x69ea <Ext2Power+0x8a>
		__ticks = 1;
    69e0:	81 e0       	ldi	r24, 0x01	; 1
    69e2:	90 e0       	ldi	r25, 0x00	; 0
    69e4:	89 87       	std	Y+9, r24	; 0x09
    69e6:	9a 87       	std	Y+10, r25	; 0x0a
    69e8:	46 c0       	rjmp	.+140    	; 0x6a76 <Ext2Power+0x116>
	else if (__tmp > 65535)
    69ea:	11 e0       	ldi	r17, 0x01	; 1
    69ec:	6d 81       	ldd	r22, Y+5	; 0x05
    69ee:	7e 81       	ldd	r23, Y+6	; 0x06
    69f0:	8f 81       	ldd	r24, Y+7	; 0x07
    69f2:	98 85       	ldd	r25, Y+8	; 0x08
    69f4:	20 e0       	ldi	r18, 0x00	; 0
    69f6:	3f ef       	ldi	r19, 0xFF	; 255
    69f8:	4f e7       	ldi	r20, 0x7F	; 127
    69fa:	57 e4       	ldi	r21, 0x47	; 71
    69fc:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    6a00:	18 16       	cp	r1, r24
    6a02:	0c f0       	brlt	.+2      	; 0x6a06 <Ext2Power+0xa6>
    6a04:	10 e0       	ldi	r17, 0x00	; 0
    6a06:	11 23       	and	r17, r17
    6a08:	61 f1       	breq	.+88     	; 0x6a62 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6a0a:	69 81       	ldd	r22, Y+1	; 0x01
    6a0c:	7a 81       	ldd	r23, Y+2	; 0x02
    6a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a10:	9c 81       	ldd	r25, Y+4	; 0x04
    6a12:	20 e0       	ldi	r18, 0x00	; 0
    6a14:	30 e0       	ldi	r19, 0x00	; 0
    6a16:	40 e2       	ldi	r20, 0x20	; 32
    6a18:	51 e4       	ldi	r21, 0x41	; 65
    6a1a:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    6a1e:	dc 01       	movw	r26, r24
    6a20:	cb 01       	movw	r24, r22
    6a22:	bc 01       	movw	r22, r24
    6a24:	cd 01       	movw	r24, r26
    6a26:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6a2a:	dc 01       	movw	r26, r24
    6a2c:	cb 01       	movw	r24, r22
    6a2e:	89 87       	std	Y+9, r24	; 0x09
    6a30:	9a 87       	std	Y+10, r25	; 0x0a
    6a32:	12 c0       	rjmp	.+36     	; 0x6a58 <Ext2Power+0xf8>
    6a34:	80 e2       	ldi	r24, 0x20	; 32
    6a36:	93 e0       	ldi	r25, 0x03	; 3
    6a38:	8b 87       	std	Y+11, r24	; 0x0b
    6a3a:	9c 87       	std	Y+12, r25	; 0x0c
    6a3c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a3e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a40:	8c 01       	movw	r16, r24
    6a42:	c8 01       	movw	r24, r16
    6a44:	01 97       	sbiw	r24, 0x01	; 1
    6a46:	f1 f7       	brne	.-4      	; 0x6a44 <Ext2Power+0xe4>
    6a48:	8c 01       	movw	r16, r24
    6a4a:	0b 87       	std	Y+11, r16	; 0x0b
    6a4c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6a4e:	89 85       	ldd	r24, Y+9	; 0x09
    6a50:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a52:	01 97       	sbiw	r24, 0x01	; 1
    6a54:	89 87       	std	Y+9, r24	; 0x09
    6a56:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6a58:	89 85       	ldd	r24, Y+9	; 0x09
    6a5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a5c:	00 97       	sbiw	r24, 0x00	; 0
    6a5e:	51 f7       	brne	.-44     	; 0x6a34 <Ext2Power+0xd4>
    6a60:	22 c0       	rjmp	.+68     	; 0x6aa6 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6a62:	6d 81       	ldd	r22, Y+5	; 0x05
    6a64:	7e 81       	ldd	r23, Y+6	; 0x06
    6a66:	8f 81       	ldd	r24, Y+7	; 0x07
    6a68:	98 85       	ldd	r25, Y+8	; 0x08
    6a6a:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6a6e:	dc 01       	movw	r26, r24
    6a70:	cb 01       	movw	r24, r22
    6a72:	89 87       	std	Y+9, r24	; 0x09
    6a74:	9a 87       	std	Y+10, r25	; 0x0a
    6a76:	89 85       	ldd	r24, Y+9	; 0x09
    6a78:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a7a:	8d 87       	std	Y+13, r24	; 0x0d
    6a7c:	9e 87       	std	Y+14, r25	; 0x0e
    6a7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6a80:	9e 85       	ldd	r25, Y+14	; 0x0e
    6a82:	8c 01       	movw	r16, r24
    6a84:	f8 01       	movw	r30, r16
    6a86:	31 97       	sbiw	r30, 0x01	; 1
    6a88:	f1 f7       	brne	.-4      	; 0x6a86 <Ext2Power+0x126>
    6a8a:	8f 01       	movw	r16, r30
    6a8c:	0d 87       	std	Y+13, r16	; 0x0d
    6a8e:	1e 87       	std	Y+14, r17	; 0x0e
    6a90:	0a c0       	rjmp	.+20     	; 0x6aa6 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6a92:	80 ea       	ldi	r24, 0xA0	; 160
    6a94:	96 e0       	ldi	r25, 0x06	; 6
    6a96:	20 e4       	ldi	r18, 0x40	; 64
    6a98:	fc 01       	movw	r30, r24
    6a9a:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6a9c:	80 ea       	ldi	r24, 0xA0	; 160
    6a9e:	96 e0       	ldi	r25, 0x06	; 6
    6aa0:	20 e4       	ldi	r18, 0x40	; 64
    6aa2:	fc 01       	movw	r30, r24
    6aa4:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6aa6:	2f 96       	adiw	r28, 0x0f	; 15
    6aa8:	cd bf       	out	0x3d, r28	; 61
    6aaa:	de bf       	out	0x3e, r29	; 62
    6aac:	df 91       	pop	r29
    6aae:	cf 91       	pop	r28
    6ab0:	1f 91       	pop	r17
    6ab2:	0f 91       	pop	r16
    6ab4:	08 95       	ret

00006ab6 <HVPower>:

void HVPower(uint8_t on) {
    6ab6:	0f 93       	push	r16
    6ab8:	1f 93       	push	r17
    6aba:	cf 93       	push	r28
    6abc:	df 93       	push	r29
    6abe:	cd b7       	in	r28, 0x3d	; 61
    6ac0:	de b7       	in	r29, 0x3e	; 62
    6ac2:	a7 97       	sbiw	r28, 0x27	; 39
    6ac4:	cd bf       	out	0x3d, r28	; 61
    6ac6:	de bf       	out	0x3e, r29	; 62
    6ac8:	8f a3       	lds	r24, 0x5f
	if (on) {
    6aca:	8f a1       	lds	r24, 0x4f
    6acc:	88 23       	and	r24, r24
    6ace:	09 f4       	brne	.+2      	; 0x6ad2 <HVPower+0x1c>
    6ad0:	8b c0       	rjmp	.+278    	; 0x6be8 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6ad2:	80 ea       	ldi	r24, 0xA0	; 160
    6ad4:	96 e0       	ldi	r25, 0x06	; 6
    6ad6:	20 e8       	ldi	r18, 0x80	; 128
    6ad8:	fc 01       	movw	r30, r24
    6ada:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6adc:	80 ea       	ldi	r24, 0xA0	; 160
    6ade:	96 e0       	ldi	r25, 0x06	; 6
    6ae0:	20 e8       	ldi	r18, 0x80	; 128
    6ae2:	fc 01       	movw	r30, r24
    6ae4:	25 83       	std	Z+5, r18	; 0x05
    6ae6:	80 e0       	ldi	r24, 0x00	; 0
    6ae8:	90 e0       	ldi	r25, 0x00	; 0
    6aea:	a8 ec       	ldi	r26, 0xC8	; 200
    6aec:	b2 e4       	ldi	r27, 0x42	; 66
    6aee:	89 83       	std	Y+1, r24	; 0x01
    6af0:	9a 83       	std	Y+2, r25	; 0x02
    6af2:	ab 83       	std	Y+3, r26	; 0x03
    6af4:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6af6:	69 81       	ldd	r22, Y+1	; 0x01
    6af8:	7a 81       	ldd	r23, Y+2	; 0x02
    6afa:	8b 81       	ldd	r24, Y+3	; 0x03
    6afc:	9c 81       	ldd	r25, Y+4	; 0x04
    6afe:	20 e0       	ldi	r18, 0x00	; 0
    6b00:	30 e0       	ldi	r19, 0x00	; 0
    6b02:	4a ef       	ldi	r20, 0xFA	; 250
    6b04:	55 e4       	ldi	r21, 0x45	; 69
    6b06:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    6b0a:	dc 01       	movw	r26, r24
    6b0c:	cb 01       	movw	r24, r22
    6b0e:	8d 83       	std	Y+5, r24	; 0x05
    6b10:	9e 83       	std	Y+6, r25	; 0x06
    6b12:	af 83       	std	Y+7, r26	; 0x07
    6b14:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6b16:	11 e0       	ldi	r17, 0x01	; 1
    6b18:	6d 81       	ldd	r22, Y+5	; 0x05
    6b1a:	7e 81       	ldd	r23, Y+6	; 0x06
    6b1c:	8f 81       	ldd	r24, Y+7	; 0x07
    6b1e:	98 85       	ldd	r25, Y+8	; 0x08
    6b20:	20 e0       	ldi	r18, 0x00	; 0
    6b22:	30 e0       	ldi	r19, 0x00	; 0
    6b24:	40 e8       	ldi	r20, 0x80	; 128
    6b26:	5f e3       	ldi	r21, 0x3F	; 63
    6b28:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    6b2c:	88 23       	and	r24, r24
    6b2e:	0c f0       	brlt	.+2      	; 0x6b32 <HVPower+0x7c>
    6b30:	10 e0       	ldi	r17, 0x00	; 0
    6b32:	11 23       	and	r17, r17
    6b34:	29 f0       	breq	.+10     	; 0x6b40 <HVPower+0x8a>
		__ticks = 1;
    6b36:	81 e0       	ldi	r24, 0x01	; 1
    6b38:	90 e0       	ldi	r25, 0x00	; 0
    6b3a:	89 87       	std	Y+9, r24	; 0x09
    6b3c:	9a 87       	std	Y+10, r25	; 0x0a
    6b3e:	46 c0       	rjmp	.+140    	; 0x6bcc <HVPower+0x116>
	else if (__tmp > 65535)
    6b40:	11 e0       	ldi	r17, 0x01	; 1
    6b42:	6d 81       	ldd	r22, Y+5	; 0x05
    6b44:	7e 81       	ldd	r23, Y+6	; 0x06
    6b46:	8f 81       	ldd	r24, Y+7	; 0x07
    6b48:	98 85       	ldd	r25, Y+8	; 0x08
    6b4a:	20 e0       	ldi	r18, 0x00	; 0
    6b4c:	3f ef       	ldi	r19, 0xFF	; 255
    6b4e:	4f e7       	ldi	r20, 0x7F	; 127
    6b50:	57 e4       	ldi	r21, 0x47	; 71
    6b52:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    6b56:	18 16       	cp	r1, r24
    6b58:	0c f0       	brlt	.+2      	; 0x6b5c <HVPower+0xa6>
    6b5a:	10 e0       	ldi	r17, 0x00	; 0
    6b5c:	11 23       	and	r17, r17
    6b5e:	61 f1       	breq	.+88     	; 0x6bb8 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6b60:	69 81       	ldd	r22, Y+1	; 0x01
    6b62:	7a 81       	ldd	r23, Y+2	; 0x02
    6b64:	8b 81       	ldd	r24, Y+3	; 0x03
    6b66:	9c 81       	ldd	r25, Y+4	; 0x04
    6b68:	20 e0       	ldi	r18, 0x00	; 0
    6b6a:	30 e0       	ldi	r19, 0x00	; 0
    6b6c:	40 e2       	ldi	r20, 0x20	; 32
    6b6e:	51 e4       	ldi	r21, 0x41	; 65
    6b70:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    6b74:	dc 01       	movw	r26, r24
    6b76:	cb 01       	movw	r24, r22
    6b78:	bc 01       	movw	r22, r24
    6b7a:	cd 01       	movw	r24, r26
    6b7c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6b80:	dc 01       	movw	r26, r24
    6b82:	cb 01       	movw	r24, r22
    6b84:	89 87       	std	Y+9, r24	; 0x09
    6b86:	9a 87       	std	Y+10, r25	; 0x0a
    6b88:	12 c0       	rjmp	.+36     	; 0x6bae <HVPower+0xf8>
    6b8a:	80 e2       	ldi	r24, 0x20	; 32
    6b8c:	93 e0       	ldi	r25, 0x03	; 3
    6b8e:	8b 87       	std	Y+11, r24	; 0x0b
    6b90:	9c 87       	std	Y+12, r25	; 0x0c
    6b92:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b94:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b96:	8c 01       	movw	r16, r24
    6b98:	c8 01       	movw	r24, r16
    6b9a:	01 97       	sbiw	r24, 0x01	; 1
    6b9c:	f1 f7       	brne	.-4      	; 0x6b9a <HVPower+0xe4>
    6b9e:	8c 01       	movw	r16, r24
    6ba0:	0b 87       	std	Y+11, r16	; 0x0b
    6ba2:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6ba4:	89 85       	ldd	r24, Y+9	; 0x09
    6ba6:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ba8:	01 97       	sbiw	r24, 0x01	; 1
    6baa:	89 87       	std	Y+9, r24	; 0x09
    6bac:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6bae:	89 85       	ldd	r24, Y+9	; 0x09
    6bb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bb2:	00 97       	sbiw	r24, 0x00	; 0
    6bb4:	51 f7       	brne	.-44     	; 0x6b8a <HVPower+0xd4>
    6bb6:	22 c0       	rjmp	.+68     	; 0x6bfc <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6bb8:	6d 81       	ldd	r22, Y+5	; 0x05
    6bba:	7e 81       	ldd	r23, Y+6	; 0x06
    6bbc:	8f 81       	ldd	r24, Y+7	; 0x07
    6bbe:	98 85       	ldd	r25, Y+8	; 0x08
    6bc0:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6bc4:	dc 01       	movw	r26, r24
    6bc6:	cb 01       	movw	r24, r22
    6bc8:	89 87       	std	Y+9, r24	; 0x09
    6bca:	9a 87       	std	Y+10, r25	; 0x0a
    6bcc:	89 85       	ldd	r24, Y+9	; 0x09
    6bce:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bd0:	8d 87       	std	Y+13, r24	; 0x0d
    6bd2:	9e 87       	std	Y+14, r25	; 0x0e
    6bd4:	8d 85       	ldd	r24, Y+13	; 0x0d
    6bd6:	9e 85       	ldd	r25, Y+14	; 0x0e
    6bd8:	8c 01       	movw	r16, r24
    6bda:	f8 01       	movw	r30, r16
    6bdc:	31 97       	sbiw	r30, 0x01	; 1
    6bde:	f1 f7       	brne	.-4      	; 0x6bdc <HVPower+0x126>
    6be0:	8f 01       	movw	r16, r30
    6be2:	0d 87       	std	Y+13, r16	; 0x0d
    6be4:	1e 87       	std	Y+14, r17	; 0x0e
    6be6:	0a c0       	rjmp	.+20     	; 0x6bfc <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6be8:	80 ea       	ldi	r24, 0xA0	; 160
    6bea:	96 e0       	ldi	r25, 0x06	; 6
    6bec:	20 e8       	ldi	r18, 0x80	; 128
    6bee:	fc 01       	movw	r30, r24
    6bf0:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6bf2:	80 ea       	ldi	r24, 0xA0	; 160
    6bf4:	96 e0       	ldi	r25, 0x06	; 6
    6bf6:	20 e8       	ldi	r18, 0x80	; 128
    6bf8:	fc 01       	movw	r30, r24
    6bfa:	22 83       	std	Z+2, r18	; 0x02
    6bfc:	80 e0       	ldi	r24, 0x00	; 0
    6bfe:	90 e0       	ldi	r25, 0x00	; 0
    6c00:	aa e7       	ldi	r26, 0x7A	; 122
    6c02:	b4 e4       	ldi	r27, 0x44	; 68
    6c04:	8f 87       	std	Y+15, r24	; 0x0f
    6c06:	98 8b       	std	Y+16, r25	; 0x10
    6c08:	a9 8b       	std	Y+17, r26	; 0x11
    6c0a:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6c0c:	6f 85       	ldd	r22, Y+15	; 0x0f
    6c0e:	78 89       	ldd	r23, Y+16	; 0x10
    6c10:	89 89       	ldd	r24, Y+17	; 0x11
    6c12:	9a 89       	ldd	r25, Y+18	; 0x12
    6c14:	2b ea       	ldi	r18, 0xAB	; 171
    6c16:	3a ea       	ldi	r19, 0xAA	; 170
    6c18:	4a e2       	ldi	r20, 0x2A	; 42
    6c1a:	51 e4       	ldi	r21, 0x41	; 65
    6c1c:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    6c20:	dc 01       	movw	r26, r24
    6c22:	cb 01       	movw	r24, r22
    6c24:	8b 8b       	std	Y+19, r24	; 0x13
    6c26:	9c 8b       	std	Y+20, r25	; 0x14
    6c28:	ad 8b       	std	Y+21, r26	; 0x15
    6c2a:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6c2c:	11 e0       	ldi	r17, 0x01	; 1
    6c2e:	6b 89       	ldd	r22, Y+19	; 0x13
    6c30:	7c 89       	ldd	r23, Y+20	; 0x14
    6c32:	8d 89       	ldd	r24, Y+21	; 0x15
    6c34:	9e 89       	ldd	r25, Y+22	; 0x16
    6c36:	20 e0       	ldi	r18, 0x00	; 0
    6c38:	30 e0       	ldi	r19, 0x00	; 0
    6c3a:	40 e8       	ldi	r20, 0x80	; 128
    6c3c:	5f e3       	ldi	r21, 0x3F	; 63
    6c3e:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    6c42:	88 23       	and	r24, r24
    6c44:	0c f0       	brlt	.+2      	; 0x6c48 <HVPower+0x192>
    6c46:	10 e0       	ldi	r17, 0x00	; 0
    6c48:	11 23       	and	r17, r17
    6c4a:	19 f0       	breq	.+6      	; 0x6c52 <HVPower+0x19c>
		__ticks = 1;
    6c4c:	81 e0       	ldi	r24, 0x01	; 1
    6c4e:	8f 8b       	std	Y+23, r24	; 0x17
    6c50:	a3 c0       	rjmp	.+326    	; 0x6d98 <HVPower+0x2e2>
	else if (__tmp > 255)
    6c52:	11 e0       	ldi	r17, 0x01	; 1
    6c54:	6b 89       	ldd	r22, Y+19	; 0x13
    6c56:	7c 89       	ldd	r23, Y+20	; 0x14
    6c58:	8d 89       	ldd	r24, Y+21	; 0x15
    6c5a:	9e 89       	ldd	r25, Y+22	; 0x16
    6c5c:	20 e0       	ldi	r18, 0x00	; 0
    6c5e:	30 e0       	ldi	r19, 0x00	; 0
    6c60:	4f e7       	ldi	r20, 0x7F	; 127
    6c62:	53 e4       	ldi	r21, 0x43	; 67
    6c64:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    6c68:	18 16       	cp	r1, r24
    6c6a:	0c f0       	brlt	.+2      	; 0x6c6e <HVPower+0x1b8>
    6c6c:	10 e0       	ldi	r17, 0x00	; 0
    6c6e:	11 23       	and	r17, r17
    6c70:	09 f4       	brne	.+2      	; 0x6c74 <HVPower+0x1be>
    6c72:	89 c0       	rjmp	.+274    	; 0x6d86 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6c74:	6f 85       	ldd	r22, Y+15	; 0x0f
    6c76:	78 89       	ldd	r23, Y+16	; 0x10
    6c78:	89 89       	ldd	r24, Y+17	; 0x11
    6c7a:	9a 89       	ldd	r25, Y+18	; 0x12
    6c7c:	20 e0       	ldi	r18, 0x00	; 0
    6c7e:	30 e0       	ldi	r19, 0x00	; 0
    6c80:	4a e7       	ldi	r20, 0x7A	; 122
    6c82:	54 e4       	ldi	r21, 0x44	; 68
    6c84:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    6c88:	dc 01       	movw	r26, r24
    6c8a:	cb 01       	movw	r24, r22
    6c8c:	88 8f       	std	Y+24, r24	; 0x18
    6c8e:	99 8f       	std	Y+25, r25	; 0x19
    6c90:	aa 8f       	std	Y+26, r26	; 0x1a
    6c92:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6c94:	68 8d       	ldd	r22, Y+24	; 0x18
    6c96:	79 8d       	ldd	r23, Y+25	; 0x19
    6c98:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6c9a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6c9c:	20 e0       	ldi	r18, 0x00	; 0
    6c9e:	30 e0       	ldi	r19, 0x00	; 0
    6ca0:	4a ef       	ldi	r20, 0xFA	; 250
    6ca2:	55 e4       	ldi	r21, 0x45	; 69
    6ca4:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    6ca8:	dc 01       	movw	r26, r24
    6caa:	cb 01       	movw	r24, r22
    6cac:	8c 8f       	std	Y+28, r24	; 0x1c
    6cae:	9d 8f       	std	Y+29, r25	; 0x1d
    6cb0:	ae 8f       	std	Y+30, r26	; 0x1e
    6cb2:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6cb4:	11 e0       	ldi	r17, 0x01	; 1
    6cb6:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6cb8:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6cba:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6cbc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6cbe:	20 e0       	ldi	r18, 0x00	; 0
    6cc0:	30 e0       	ldi	r19, 0x00	; 0
    6cc2:	40 e8       	ldi	r20, 0x80	; 128
    6cc4:	5f e3       	ldi	r21, 0x3F	; 63
    6cc6:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    6cca:	88 23       	and	r24, r24
    6ccc:	0c f0       	brlt	.+2      	; 0x6cd0 <HVPower+0x21a>
    6cce:	10 e0       	ldi	r17, 0x00	; 0
    6cd0:	11 23       	and	r17, r17
    6cd2:	29 f0       	breq	.+10     	; 0x6cde <HVPower+0x228>
		__ticks = 1;
    6cd4:	81 e0       	ldi	r24, 0x01	; 1
    6cd6:	90 e0       	ldi	r25, 0x00	; 0
    6cd8:	88 a3       	lds	r24, 0x58
    6cda:	99 a3       	lds	r25, 0x59
    6cdc:	46 c0       	rjmp	.+140    	; 0x6d6a <HVPower+0x2b4>
	else if (__tmp > 65535)
    6cde:	11 e0       	ldi	r17, 0x01	; 1
    6ce0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6ce2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6ce4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6ce6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6ce8:	20 e0       	ldi	r18, 0x00	; 0
    6cea:	3f ef       	ldi	r19, 0xFF	; 255
    6cec:	4f e7       	ldi	r20, 0x7F	; 127
    6cee:	57 e4       	ldi	r21, 0x47	; 71
    6cf0:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    6cf4:	18 16       	cp	r1, r24
    6cf6:	0c f0       	brlt	.+2      	; 0x6cfa <HVPower+0x244>
    6cf8:	10 e0       	ldi	r17, 0x00	; 0
    6cfa:	11 23       	and	r17, r17
    6cfc:	61 f1       	breq	.+88     	; 0x6d56 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6cfe:	68 8d       	ldd	r22, Y+24	; 0x18
    6d00:	79 8d       	ldd	r23, Y+25	; 0x19
    6d02:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d04:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d06:	20 e0       	ldi	r18, 0x00	; 0
    6d08:	30 e0       	ldi	r19, 0x00	; 0
    6d0a:	40 e2       	ldi	r20, 0x20	; 32
    6d0c:	51 e4       	ldi	r21, 0x41	; 65
    6d0e:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    6d12:	dc 01       	movw	r26, r24
    6d14:	cb 01       	movw	r24, r22
    6d16:	bc 01       	movw	r22, r24
    6d18:	cd 01       	movw	r24, r26
    6d1a:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6d1e:	dc 01       	movw	r26, r24
    6d20:	cb 01       	movw	r24, r22
    6d22:	88 a3       	lds	r24, 0x58
    6d24:	99 a3       	lds	r25, 0x59
    6d26:	12 c0       	rjmp	.+36     	; 0x6d4c <HVPower+0x296>
    6d28:	80 e2       	ldi	r24, 0x20	; 32
    6d2a:	93 e0       	ldi	r25, 0x03	; 3
    6d2c:	8a a3       	lds	r24, 0x5a
    6d2e:	9b a3       	lds	r25, 0x5b
    6d30:	8a a1       	lds	r24, 0x4a
    6d32:	9b a1       	lds	r25, 0x4b
    6d34:	8c 01       	movw	r16, r24
    6d36:	c8 01       	movw	r24, r16
    6d38:	01 97       	sbiw	r24, 0x01	; 1
    6d3a:	f1 f7       	brne	.-4      	; 0x6d38 <HVPower+0x282>
    6d3c:	8c 01       	movw	r16, r24
    6d3e:	0a a3       	lds	r16, 0x5a
    6d40:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d42:	88 a1       	lds	r24, 0x48
    6d44:	99 a1       	lds	r25, 0x49
    6d46:	01 97       	sbiw	r24, 0x01	; 1
    6d48:	88 a3       	lds	r24, 0x58
    6d4a:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d4c:	88 a1       	lds	r24, 0x48
    6d4e:	99 a1       	lds	r25, 0x49
    6d50:	00 97       	sbiw	r24, 0x00	; 0
    6d52:	51 f7       	brne	.-44     	; 0x6d28 <HVPower+0x272>
    6d54:	28 c0       	rjmp	.+80     	; 0x6da6 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d56:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6d58:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6d5a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d5c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d5e:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6d62:	dc 01       	movw	r26, r24
    6d64:	cb 01       	movw	r24, r22
    6d66:	88 a3       	lds	r24, 0x58
    6d68:	99 a3       	lds	r25, 0x59
    6d6a:	88 a1       	lds	r24, 0x48
    6d6c:	99 a1       	lds	r25, 0x49
    6d6e:	8c a3       	lds	r24, 0x5c
    6d70:	9d a3       	lds	r25, 0x5d
    6d72:	8c a1       	lds	r24, 0x4c
    6d74:	9d a1       	lds	r25, 0x4d
    6d76:	8c 01       	movw	r16, r24
    6d78:	f8 01       	movw	r30, r16
    6d7a:	31 97       	sbiw	r30, 0x01	; 1
    6d7c:	f1 f7       	brne	.-4      	; 0x6d7a <HVPower+0x2c4>
    6d7e:	8f 01       	movw	r16, r30
    6d80:	0c a3       	lds	r16, 0x5c
    6d82:	1d a3       	lds	r17, 0x5d
    6d84:	10 c0       	rjmp	.+32     	; 0x6da6 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6d86:	6b 89       	ldd	r22, Y+19	; 0x13
    6d88:	7c 89       	ldd	r23, Y+20	; 0x14
    6d8a:	8d 89       	ldd	r24, Y+21	; 0x15
    6d8c:	9e 89       	ldd	r25, Y+22	; 0x16
    6d8e:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    6d92:	dc 01       	movw	r26, r24
    6d94:	cb 01       	movw	r24, r22
    6d96:	8f 8b       	std	Y+23, r24	; 0x17
    6d98:	8f 89       	ldd	r24, Y+23	; 0x17
    6d9a:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6d9c:	8e a1       	lds	r24, 0x4e
    6d9e:	18 2f       	mov	r17, r24
    6da0:	1a 95       	dec	r17
    6da2:	f1 f7       	brne	.-4      	; 0x6da0 <HVPower+0x2ea>
    6da4:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    6da6:	a7 96       	adiw	r28, 0x27	; 39
    6da8:	cd bf       	out	0x3d, r28	; 61
    6daa:	de bf       	out	0x3e, r29	; 62
    6dac:	df 91       	pop	r29
    6dae:	cf 91       	pop	r28
    6db0:	1f 91       	pop	r17
    6db2:	0f 91       	pop	r16
    6db4:	08 95       	ret

00006db6 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    6db6:	cf 93       	push	r28
    6db8:	df 93       	push	r29
    6dba:	0f 92       	push	r0
    6dbc:	cd b7       	in	r28, 0x3d	; 61
    6dbe:	de b7       	in	r29, 0x3e	; 62
    6dc0:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    6dc2:	89 81       	ldd	r24, Y+1	; 0x01
    6dc4:	88 23       	and	r24, r24
    6dc6:	31 f0       	breq	.+12     	; 0x6dd4 <lowerMuxCS+0x1e>
    6dc8:	80 e8       	ldi	r24, 0x80	; 128
    6dca:	96 e0       	ldi	r25, 0x06	; 6
    6dcc:	20 e1       	ldi	r18, 0x10	; 16
    6dce:	fc 01       	movw	r30, r24
    6dd0:	26 83       	std	Z+6, r18	; 0x06
    6dd2:	05 c0       	rjmp	.+10     	; 0x6dde <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    6dd4:	80 e8       	ldi	r24, 0x80	; 128
    6dd6:	96 e0       	ldi	r25, 0x06	; 6
    6dd8:	20 e1       	ldi	r18, 0x10	; 16
    6dda:	fc 01       	movw	r30, r24
    6ddc:	25 83       	std	Z+5, r18	; 0x05
}
    6dde:	0f 90       	pop	r0
    6de0:	df 91       	pop	r29
    6de2:	cf 91       	pop	r28
    6de4:	08 95       	ret

00006de6 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    6de6:	cf 93       	push	r28
    6de8:	df 93       	push	r29
    6dea:	0f 92       	push	r0
    6dec:	cd b7       	in	r28, 0x3d	; 61
    6dee:	de b7       	in	r29, 0x3e	; 62
    6df0:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    6df2:	89 81       	ldd	r24, Y+1	; 0x01
    6df4:	88 23       	and	r24, r24
    6df6:	31 f0       	breq	.+12     	; 0x6e04 <upperMuxCS+0x1e>
    6df8:	80 e4       	ldi	r24, 0x40	; 64
    6dfa:	96 e0       	ldi	r25, 0x06	; 6
    6dfc:	22 e0       	ldi	r18, 0x02	; 2
    6dfe:	fc 01       	movw	r30, r24
    6e00:	26 83       	std	Z+6, r18	; 0x06
    6e02:	05 c0       	rjmp	.+10     	; 0x6e0e <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    6e04:	80 e4       	ldi	r24, 0x40	; 64
    6e06:	96 e0       	ldi	r25, 0x06	; 6
    6e08:	22 e0       	ldi	r18, 0x02	; 2
    6e0a:	fc 01       	movw	r30, r24
    6e0c:	25 83       	std	Z+5, r18	; 0x05
}
    6e0e:	0f 90       	pop	r0
    6e10:	df 91       	pop	r29
    6e12:	cf 91       	pop	r28
    6e14:	08 95       	ret

00006e16 <SPIInit>:

void SPIInit(uint8_t mode) {
    6e16:	cf 93       	push	r28
    6e18:	df 93       	push	r29
    6e1a:	0f 92       	push	r0
    6e1c:	cd b7       	in	r28, 0x3d	; 61
    6e1e:	de b7       	in	r29, 0x3e	; 62
    6e20:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6e22:	80 e4       	ldi	r24, 0x40	; 64
    6e24:	96 e0       	ldi	r25, 0x06	; 6
    6e26:	20 e1       	ldi	r18, 0x10	; 16
    6e28:	fc 01       	movw	r30, r24
    6e2a:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6e2c:	80 e4       	ldi	r24, 0x40	; 64
    6e2e:	96 e0       	ldi	r25, 0x06	; 6
    6e30:	28 e3       	ldi	r18, 0x38	; 56
    6e32:	fc 01       	movw	r30, r24
    6e34:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6e36:	80 e4       	ldi	r24, 0x40	; 64
    6e38:	96 e0       	ldi	r25, 0x06	; 6
    6e3a:	20 e1       	ldi	r18, 0x10	; 16
    6e3c:	fc 01       	movw	r30, r24
    6e3e:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    6e40:	80 ec       	ldi	r24, 0xC0	; 192
    6e42:	98 e0       	ldi	r25, 0x08	; 8
    6e44:	29 81       	ldd	r18, Y+1	; 0x01
    6e46:	21 65       	ori	r18, 0x51	; 81
    6e48:	fc 01       	movw	r30, r24
    6e4a:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6e4c:	80 ec       	ldi	r24, 0xC0	; 192
    6e4e:	98 e0       	ldi	r25, 0x08	; 8
    6e50:	fc 01       	movw	r30, r24
    6e52:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6e54:	80 e4       	ldi	r24, 0x40	; 64
    6e56:	96 e0       	ldi	r25, 0x06	; 6
    6e58:	20 ea       	ldi	r18, 0xA0	; 160
    6e5a:	fc 01       	movw	r30, r24
    6e5c:	21 83       	std	Z+1, r18	; 0x01

	
}
    6e5e:	0f 90       	pop	r0
    6e60:	df 91       	pop	r29
    6e62:	cf 91       	pop	r28
    6e64:	08 95       	ret

00006e66 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    6e66:	cf 93       	push	r28
    6e68:	df 93       	push	r29
    6e6a:	0f 92       	push	r0
    6e6c:	0f 92       	push	r0
    6e6e:	cd b7       	in	r28, 0x3d	; 61
    6e70:	de b7       	in	r29, 0x3e	; 62
    6e72:	89 83       	std	Y+1, r24	; 0x01
    6e74:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6e76:	80 e4       	ldi	r24, 0x40	; 64
    6e78:	96 e0       	ldi	r25, 0x06	; 6
    6e7a:	20 e1       	ldi	r18, 0x10	; 16
    6e7c:	fc 01       	movw	r30, r24
    6e7e:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6e80:	80 e4       	ldi	r24, 0x40	; 64
    6e82:	96 e0       	ldi	r25, 0x06	; 6
    6e84:	28 e3       	ldi	r18, 0x38	; 56
    6e86:	fc 01       	movw	r30, r24
    6e88:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6e8a:	80 e4       	ldi	r24, 0x40	; 64
    6e8c:	96 e0       	ldi	r25, 0x06	; 6
    6e8e:	20 e1       	ldi	r18, 0x10	; 16
    6e90:	fc 01       	movw	r30, r24
    6e92:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    6e94:	80 ec       	ldi	r24, 0xC0	; 192
    6e96:	98 e0       	ldi	r25, 0x08	; 8
    6e98:	3a 81       	ldd	r19, Y+2	; 0x02
    6e9a:	29 81       	ldd	r18, Y+1	; 0x01
    6e9c:	23 2b       	or	r18, r19
    6e9e:	20 65       	ori	r18, 0x50	; 80
    6ea0:	fc 01       	movw	r30, r24
    6ea2:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6ea4:	80 ec       	ldi	r24, 0xC0	; 192
    6ea6:	98 e0       	ldi	r25, 0x08	; 8
    6ea8:	fc 01       	movw	r30, r24
    6eaa:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6eac:	80 e4       	ldi	r24, 0x40	; 64
    6eae:	96 e0       	ldi	r25, 0x06	; 6
    6eb0:	20 ea       	ldi	r18, 0xA0	; 160
    6eb2:	fc 01       	movw	r30, r24
    6eb4:	21 83       	std	Z+1, r18	; 0x01
}
    6eb6:	0f 90       	pop	r0
    6eb8:	0f 90       	pop	r0
    6eba:	df 91       	pop	r29
    6ebc:	cf 91       	pop	r28
    6ebe:	08 95       	ret

00006ec0 <SPICS>:

void SPICS(uint8_t enable) {
    6ec0:	cf 93       	push	r28
    6ec2:	df 93       	push	r29
    6ec4:	0f 92       	push	r0
    6ec6:	cd b7       	in	r28, 0x3d	; 61
    6ec8:	de b7       	in	r29, 0x3e	; 62
    6eca:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    6ecc:	89 81       	ldd	r24, Y+1	; 0x01
    6ece:	88 23       	and	r24, r24
    6ed0:	31 f0       	breq	.+12     	; 0x6ede <SPICS+0x1e>
    6ed2:	80 e4       	ldi	r24, 0x40	; 64
    6ed4:	96 e0       	ldi	r25, 0x06	; 6
    6ed6:	20 e1       	ldi	r18, 0x10	; 16
    6ed8:	fc 01       	movw	r30, r24
    6eda:	26 83       	std	Z+6, r18	; 0x06
    6edc:	05 c0       	rjmp	.+10     	; 0x6ee8 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    6ede:	80 e4       	ldi	r24, 0x40	; 64
    6ee0:	96 e0       	ldi	r25, 0x06	; 6
    6ee2:	20 e1       	ldi	r18, 0x10	; 16
    6ee4:	fc 01       	movw	r30, r24
    6ee6:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    6ee8:	0f 90       	pop	r0
    6eea:	df 91       	pop	r29
    6eec:	cf 91       	pop	r28
    6eee:	08 95       	ret

00006ef0 <SPIDisable>:

void SPIDisable() {
    6ef0:	cf 93       	push	r28
    6ef2:	df 93       	push	r29
    6ef4:	cd b7       	in	r28, 0x3d	; 61
    6ef6:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    6ef8:	80 e4       	ldi	r24, 0x40	; 64
    6efa:	96 e0       	ldi	r25, 0x06	; 6
    6efc:	20 e1       	ldi	r18, 0x10	; 16
    6efe:	fc 01       	movw	r30, r24
    6f00:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    6f02:	80 ec       	ldi	r24, 0xC0	; 192
    6f04:	98 e0       	ldi	r25, 0x08	; 8
    6f06:	fc 01       	movw	r30, r24
    6f08:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    6f0a:	80 e4       	ldi	r24, 0x40	; 64
    6f0c:	96 e0       	ldi	r25, 0x06	; 6
    6f0e:	20 e1       	ldi	r18, 0x10	; 16
    6f10:	fc 01       	movw	r30, r24
    6f12:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    6f14:	80 e4       	ldi	r24, 0x40	; 64
    6f16:	96 e0       	ldi	r25, 0x06	; 6
    6f18:	20 eb       	ldi	r18, 0xB0	; 176
    6f1a:	fc 01       	movw	r30, r24
    6f1c:	22 83       	std	Z+2, r18	; 0x02

}
    6f1e:	df 91       	pop	r29
    6f20:	cf 91       	pop	r28
    6f22:	08 95       	ret

00006f24 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    6f24:	cf 93       	push	r28
    6f26:	df 93       	push	r29
    6f28:	00 d0       	rcall	.+0      	; 0x6f2a <readFRAM+0x6>
    6f2a:	0f 92       	push	r0
    6f2c:	cd b7       	in	r28, 0x3d	; 61
    6f2e:	de b7       	in	r29, 0x3e	; 62
    6f30:	8b 83       	std	Y+3, r24	; 0x03
    6f32:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    6f34:	80 e0       	ldi	r24, 0x00	; 0
    6f36:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    6f3a:	80 ec       	ldi	r24, 0xC0	; 192
    6f3c:	98 e0       	ldi	r25, 0x08	; 8
    6f3e:	20 ed       	ldi	r18, 0xD0	; 208
    6f40:	fc 01       	movw	r30, r24
    6f42:	20 83       	st	Z, r18
	SPICS(TRUE);
    6f44:	81 e0       	ldi	r24, 0x01	; 1
    6f46:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    6f4a:	80 e2       	ldi	r24, 0x20	; 32
    6f4c:	96 e0       	ldi	r25, 0x06	; 6
    6f4e:	28 e0       	ldi	r18, 0x08	; 8
    6f50:	fc 01       	movw	r30, r24
    6f52:	26 83       	std	Z+6, r18	; 0x06
	nop();
    6f54:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    6f56:	80 ec       	ldi	r24, 0xC0	; 192
    6f58:	98 e0       	ldi	r25, 0x08	; 8
    6f5a:	23 e0       	ldi	r18, 0x03	; 3
    6f5c:	fc 01       	movw	r30, r24
    6f5e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6f60:	00 00       	nop
    6f62:	80 ec       	ldi	r24, 0xC0	; 192
    6f64:	98 e0       	ldi	r25, 0x08	; 8
    6f66:	fc 01       	movw	r30, r24
    6f68:	82 81       	ldd	r24, Z+2	; 0x02
    6f6a:	88 23       	and	r24, r24
    6f6c:	d4 f7       	brge	.-12     	; 0x6f62 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    6f6e:	80 ec       	ldi	r24, 0xC0	; 192
    6f70:	98 e0       	ldi	r25, 0x08	; 8
    6f72:	fc 01       	movw	r30, r24
    6f74:	83 81       	ldd	r24, Z+3	; 0x03
    6f76:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    6f7a:	80 ec       	ldi	r24, 0xC0	; 192
    6f7c:	98 e0       	ldi	r25, 0x08	; 8
    6f7e:	20 91 45 40 	lds	r18, 0x4045
    6f82:	fc 01       	movw	r30, r24
    6f84:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6f86:	00 00       	nop
    6f88:	80 ec       	ldi	r24, 0xC0	; 192
    6f8a:	98 e0       	ldi	r25, 0x08	; 8
    6f8c:	fc 01       	movw	r30, r24
    6f8e:	82 81       	ldd	r24, Z+2	; 0x02
    6f90:	88 23       	and	r24, r24
    6f92:	d4 f7       	brge	.-12     	; 0x6f88 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    6f94:	80 ec       	ldi	r24, 0xC0	; 192
    6f96:	98 e0       	ldi	r25, 0x08	; 8
    6f98:	fc 01       	movw	r30, r24
    6f9a:	83 81       	ldd	r24, Z+3	; 0x03
    6f9c:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    6fa0:	80 ec       	ldi	r24, 0xC0	; 192
    6fa2:	98 e0       	ldi	r25, 0x08	; 8
    6fa4:	24 e4       	ldi	r18, 0x44	; 68
    6fa6:	30 e4       	ldi	r19, 0x40	; 64
    6fa8:	f9 01       	movw	r30, r18
    6faa:	20 81       	ld	r18, Z
    6fac:	fc 01       	movw	r30, r24
    6fae:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6fb0:	00 00       	nop
    6fb2:	80 ec       	ldi	r24, 0xC0	; 192
    6fb4:	98 e0       	ldi	r25, 0x08	; 8
    6fb6:	fc 01       	movw	r30, r24
    6fb8:	82 81       	ldd	r24, Z+2	; 0x02
    6fba:	88 23       	and	r24, r24
    6fbc:	d4 f7       	brge	.-12     	; 0x6fb2 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    6fbe:	80 ec       	ldi	r24, 0xC0	; 192
    6fc0:	98 e0       	ldi	r25, 0x08	; 8
    6fc2:	fc 01       	movw	r30, r24
    6fc4:	83 81       	ldd	r24, Z+3	; 0x03
    6fc6:	80 93 66 50 	sts	0x5066, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    6fca:	19 82       	std	Y+1, r1	; 0x01
    6fcc:	1a 82       	std	Y+2, r1	; 0x02
    6fce:	1b c0       	rjmp	.+54     	; 0x7006 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    6fd0:	80 ec       	ldi	r24, 0xC0	; 192
    6fd2:	98 e0       	ldi	r25, 0x08	; 8
    6fd4:	2a ea       	ldi	r18, 0xAA	; 170
    6fd6:	fc 01       	movw	r30, r24
    6fd8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6fda:	00 00       	nop
    6fdc:	80 ec       	ldi	r24, 0xC0	; 192
    6fde:	98 e0       	ldi	r25, 0x08	; 8
    6fe0:	fc 01       	movw	r30, r24
    6fe2:	82 81       	ldd	r24, Z+2	; 0x02
    6fe4:	88 23       	and	r24, r24
    6fe6:	d4 f7       	brge	.-12     	; 0x6fdc <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    6fe8:	80 ec       	ldi	r24, 0xC0	; 192
    6fea:	98 e0       	ldi	r25, 0x08	; 8
    6fec:	fc 01       	movw	r30, r24
    6fee:	23 81       	ldd	r18, Z+3	; 0x03
    6ff0:	89 81       	ldd	r24, Y+1	; 0x01
    6ff2:	9a 81       	ldd	r25, Y+2	; 0x02
    6ff4:	84 53       	subi	r24, 0x34	; 52
    6ff6:	9c 4d       	sbci	r25, 0xDC	; 220
    6ff8:	fc 01       	movw	r30, r24
    6ffa:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    6ffc:	89 81       	ldd	r24, Y+1	; 0x01
    6ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    7000:	01 96       	adiw	r24, 0x01	; 1
    7002:	89 83       	std	Y+1, r24	; 0x01
    7004:	9a 83       	std	Y+2, r25	; 0x02
    7006:	29 81       	ldd	r18, Y+1	; 0x01
    7008:	3a 81       	ldd	r19, Y+2	; 0x02
    700a:	8b 81       	ldd	r24, Y+3	; 0x03
    700c:	9c 81       	ldd	r25, Y+4	; 0x04
    700e:	28 17       	cp	r18, r24
    7010:	39 07       	cpc	r19, r25
    7012:	f0 f2       	brcs	.-68     	; 0x6fd0 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7014:	80 e2       	ldi	r24, 0x20	; 32
    7016:	96 e0       	ldi	r25, 0x06	; 6
    7018:	28 e0       	ldi	r18, 0x08	; 8
    701a:	fc 01       	movw	r30, r24
    701c:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    701e:	80 e0       	ldi	r24, 0x00	; 0
    7020:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    7024:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>

}
    7028:	24 96       	adiw	r28, 0x04	; 4
    702a:	cd bf       	out	0x3d, r28	; 61
    702c:	de bf       	out	0x3e, r29	; 62
    702e:	df 91       	pop	r29
    7030:	cf 91       	pop	r28
    7032:	08 95       	ret

00007034 <FRAMTest3Channel>:

//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
    7034:	0f 93       	push	r16
    7036:	1f 93       	push	r17
    7038:	cf 93       	push	r28
    703a:	df 93       	push	r29
    703c:	cd b7       	in	r28, 0x3d	; 61
    703e:	de b7       	in	r29, 0x3e	; 62
    7040:	6b 97       	sbiw	r28, 0x1b	; 27
    7042:	cd bf       	out	0x3d, r28	; 61
    7044:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    7046:	19 8e       	std	Y+25, r1	; 0x19
    7048:	1a 8e       	std	Y+26, r1	; 0x1a
    704a:	1b 8e       	std	Y+27, r1	; 0x1b
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    704c:	81 e0       	ldi	r24, 0x01	; 1
    704e:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
    7052:	80 e0       	ldi	r24, 0x00	; 0
    7054:	90 e0       	ldi	r25, 0x00	; 0
    7056:	aa e7       	ldi	r26, 0x7A	; 122
    7058:	b3 e4       	ldi	r27, 0x43	; 67
    705a:	89 83       	std	Y+1, r24	; 0x01
    705c:	9a 83       	std	Y+2, r25	; 0x02
    705e:	ab 83       	std	Y+3, r26	; 0x03
    7060:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7062:	69 81       	ldd	r22, Y+1	; 0x01
    7064:	7a 81       	ldd	r23, Y+2	; 0x02
    7066:	8b 81       	ldd	r24, Y+3	; 0x03
    7068:	9c 81       	ldd	r25, Y+4	; 0x04
    706a:	2b ea       	ldi	r18, 0xAB	; 171
    706c:	3a ea       	ldi	r19, 0xAA	; 170
    706e:	4a e2       	ldi	r20, 0x2A	; 42
    7070:	51 e4       	ldi	r21, 0x41	; 65
    7072:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7076:	dc 01       	movw	r26, r24
    7078:	cb 01       	movw	r24, r22
    707a:	8d 83       	std	Y+5, r24	; 0x05
    707c:	9e 83       	std	Y+6, r25	; 0x06
    707e:	af 83       	std	Y+7, r26	; 0x07
    7080:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7082:	11 e0       	ldi	r17, 0x01	; 1
    7084:	6d 81       	ldd	r22, Y+5	; 0x05
    7086:	7e 81       	ldd	r23, Y+6	; 0x06
    7088:	8f 81       	ldd	r24, Y+7	; 0x07
    708a:	98 85       	ldd	r25, Y+8	; 0x08
    708c:	20 e0       	ldi	r18, 0x00	; 0
    708e:	30 e0       	ldi	r19, 0x00	; 0
    7090:	40 e8       	ldi	r20, 0x80	; 128
    7092:	5f e3       	ldi	r21, 0x3F	; 63
    7094:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    7098:	88 23       	and	r24, r24
    709a:	0c f0       	brlt	.+2      	; 0x709e <FRAMTest3Channel+0x6a>
    709c:	10 e0       	ldi	r17, 0x00	; 0
    709e:	11 23       	and	r17, r17
    70a0:	19 f0       	breq	.+6      	; 0x70a8 <FRAMTest3Channel+0x74>
		__ticks = 1;
    70a2:	81 e0       	ldi	r24, 0x01	; 1
    70a4:	89 87       	std	Y+9, r24	; 0x09
    70a6:	a3 c0       	rjmp	.+326    	; 0x71ee <FRAMTest3Channel+0x1ba>
	else if (__tmp > 255)
    70a8:	11 e0       	ldi	r17, 0x01	; 1
    70aa:	6d 81       	ldd	r22, Y+5	; 0x05
    70ac:	7e 81       	ldd	r23, Y+6	; 0x06
    70ae:	8f 81       	ldd	r24, Y+7	; 0x07
    70b0:	98 85       	ldd	r25, Y+8	; 0x08
    70b2:	20 e0       	ldi	r18, 0x00	; 0
    70b4:	30 e0       	ldi	r19, 0x00	; 0
    70b6:	4f e7       	ldi	r20, 0x7F	; 127
    70b8:	53 e4       	ldi	r21, 0x43	; 67
    70ba:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    70be:	18 16       	cp	r1, r24
    70c0:	0c f0       	brlt	.+2      	; 0x70c4 <FRAMTest3Channel+0x90>
    70c2:	10 e0       	ldi	r17, 0x00	; 0
    70c4:	11 23       	and	r17, r17
    70c6:	09 f4       	brne	.+2      	; 0x70ca <FRAMTest3Channel+0x96>
    70c8:	89 c0       	rjmp	.+274    	; 0x71dc <FRAMTest3Channel+0x1a8>
	{
		_delay_ms(__us / 1000.0);
    70ca:	69 81       	ldd	r22, Y+1	; 0x01
    70cc:	7a 81       	ldd	r23, Y+2	; 0x02
    70ce:	8b 81       	ldd	r24, Y+3	; 0x03
    70d0:	9c 81       	ldd	r25, Y+4	; 0x04
    70d2:	20 e0       	ldi	r18, 0x00	; 0
    70d4:	30 e0       	ldi	r19, 0x00	; 0
    70d6:	4a e7       	ldi	r20, 0x7A	; 122
    70d8:	54 e4       	ldi	r21, 0x44	; 68
    70da:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    70de:	dc 01       	movw	r26, r24
    70e0:	cb 01       	movw	r24, r22
    70e2:	8a 87       	std	Y+10, r24	; 0x0a
    70e4:	9b 87       	std	Y+11, r25	; 0x0b
    70e6:	ac 87       	std	Y+12, r26	; 0x0c
    70e8:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    70ea:	6a 85       	ldd	r22, Y+10	; 0x0a
    70ec:	7b 85       	ldd	r23, Y+11	; 0x0b
    70ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    70f0:	9d 85       	ldd	r25, Y+13	; 0x0d
    70f2:	20 e0       	ldi	r18, 0x00	; 0
    70f4:	30 e0       	ldi	r19, 0x00	; 0
    70f6:	4a ef       	ldi	r20, 0xFA	; 250
    70f8:	55 e4       	ldi	r21, 0x45	; 69
    70fa:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    70fe:	dc 01       	movw	r26, r24
    7100:	cb 01       	movw	r24, r22
    7102:	8e 87       	std	Y+14, r24	; 0x0e
    7104:	9f 87       	std	Y+15, r25	; 0x0f
    7106:	a8 8b       	std	Y+16, r26	; 0x10
    7108:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    710a:	11 e0       	ldi	r17, 0x01	; 1
    710c:	6e 85       	ldd	r22, Y+14	; 0x0e
    710e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7110:	88 89       	ldd	r24, Y+16	; 0x10
    7112:	99 89       	ldd	r25, Y+17	; 0x11
    7114:	20 e0       	ldi	r18, 0x00	; 0
    7116:	30 e0       	ldi	r19, 0x00	; 0
    7118:	40 e8       	ldi	r20, 0x80	; 128
    711a:	5f e3       	ldi	r21, 0x3F	; 63
    711c:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    7120:	88 23       	and	r24, r24
    7122:	0c f0       	brlt	.+2      	; 0x7126 <FRAMTest3Channel+0xf2>
    7124:	10 e0       	ldi	r17, 0x00	; 0
    7126:	11 23       	and	r17, r17
    7128:	29 f0       	breq	.+10     	; 0x7134 <FRAMTest3Channel+0x100>
		__ticks = 1;
    712a:	81 e0       	ldi	r24, 0x01	; 1
    712c:	90 e0       	ldi	r25, 0x00	; 0
    712e:	8a 8b       	std	Y+18, r24	; 0x12
    7130:	9b 8b       	std	Y+19, r25	; 0x13
    7132:	46 c0       	rjmp	.+140    	; 0x71c0 <FRAMTest3Channel+0x18c>
	else if (__tmp > 65535)
    7134:	11 e0       	ldi	r17, 0x01	; 1
    7136:	6e 85       	ldd	r22, Y+14	; 0x0e
    7138:	7f 85       	ldd	r23, Y+15	; 0x0f
    713a:	88 89       	ldd	r24, Y+16	; 0x10
    713c:	99 89       	ldd	r25, Y+17	; 0x11
    713e:	20 e0       	ldi	r18, 0x00	; 0
    7140:	3f ef       	ldi	r19, 0xFF	; 255
    7142:	4f e7       	ldi	r20, 0x7F	; 127
    7144:	57 e4       	ldi	r21, 0x47	; 71
    7146:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    714a:	18 16       	cp	r1, r24
    714c:	0c f0       	brlt	.+2      	; 0x7150 <FRAMTest3Channel+0x11c>
    714e:	10 e0       	ldi	r17, 0x00	; 0
    7150:	11 23       	and	r17, r17
    7152:	61 f1       	breq	.+88     	; 0x71ac <FRAMTest3Channel+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7154:	6a 85       	ldd	r22, Y+10	; 0x0a
    7156:	7b 85       	ldd	r23, Y+11	; 0x0b
    7158:	8c 85       	ldd	r24, Y+12	; 0x0c
    715a:	9d 85       	ldd	r25, Y+13	; 0x0d
    715c:	20 e0       	ldi	r18, 0x00	; 0
    715e:	30 e0       	ldi	r19, 0x00	; 0
    7160:	40 e2       	ldi	r20, 0x20	; 32
    7162:	51 e4       	ldi	r21, 0x41	; 65
    7164:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7168:	dc 01       	movw	r26, r24
    716a:	cb 01       	movw	r24, r22
    716c:	bc 01       	movw	r22, r24
    716e:	cd 01       	movw	r24, r26
    7170:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    7174:	dc 01       	movw	r26, r24
    7176:	cb 01       	movw	r24, r22
    7178:	8a 8b       	std	Y+18, r24	; 0x12
    717a:	9b 8b       	std	Y+19, r25	; 0x13
    717c:	12 c0       	rjmp	.+36     	; 0x71a2 <FRAMTest3Channel+0x16e>
    717e:	80 e2       	ldi	r24, 0x20	; 32
    7180:	93 e0       	ldi	r25, 0x03	; 3
    7182:	8c 8b       	std	Y+20, r24	; 0x14
    7184:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7186:	8c 89       	ldd	r24, Y+20	; 0x14
    7188:	9d 89       	ldd	r25, Y+21	; 0x15
    718a:	8c 01       	movw	r16, r24
    718c:	c8 01       	movw	r24, r16
    718e:	01 97       	sbiw	r24, 0x01	; 1
    7190:	f1 f7       	brne	.-4      	; 0x718e <FRAMTest3Channel+0x15a>
    7192:	8c 01       	movw	r16, r24
    7194:	0c 8b       	std	Y+20, r16	; 0x14
    7196:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7198:	8a 89       	ldd	r24, Y+18	; 0x12
    719a:	9b 89       	ldd	r25, Y+19	; 0x13
    719c:	01 97       	sbiw	r24, 0x01	; 1
    719e:	8a 8b       	std	Y+18, r24	; 0x12
    71a0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    71a2:	8a 89       	ldd	r24, Y+18	; 0x12
    71a4:	9b 89       	ldd	r25, Y+19	; 0x13
    71a6:	00 97       	sbiw	r24, 0x00	; 0
    71a8:	51 f7       	brne	.-44     	; 0x717e <FRAMTest3Channel+0x14a>
    71aa:	28 c0       	rjmp	.+80     	; 0x71fc <FRAMTest3Channel+0x1c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    71ac:	6e 85       	ldd	r22, Y+14	; 0x0e
    71ae:	7f 85       	ldd	r23, Y+15	; 0x0f
    71b0:	88 89       	ldd	r24, Y+16	; 0x10
    71b2:	99 89       	ldd	r25, Y+17	; 0x11
    71b4:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    71b8:	dc 01       	movw	r26, r24
    71ba:	cb 01       	movw	r24, r22
    71bc:	8a 8b       	std	Y+18, r24	; 0x12
    71be:	9b 8b       	std	Y+19, r25	; 0x13
    71c0:	8a 89       	ldd	r24, Y+18	; 0x12
    71c2:	9b 89       	ldd	r25, Y+19	; 0x13
    71c4:	8e 8b       	std	Y+22, r24	; 0x16
    71c6:	9f 8b       	std	Y+23, r25	; 0x17
    71c8:	8e 89       	ldd	r24, Y+22	; 0x16
    71ca:	9f 89       	ldd	r25, Y+23	; 0x17
    71cc:	8c 01       	movw	r16, r24
    71ce:	c8 01       	movw	r24, r16
    71d0:	01 97       	sbiw	r24, 0x01	; 1
    71d2:	f1 f7       	brne	.-4      	; 0x71d0 <FRAMTest3Channel+0x19c>
    71d4:	8c 01       	movw	r16, r24
    71d6:	0e 8b       	std	Y+22, r16	; 0x16
    71d8:	1f 8b       	std	Y+23, r17	; 0x17
    71da:	10 c0       	rjmp	.+32     	; 0x71fc <FRAMTest3Channel+0x1c8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    71dc:	6d 81       	ldd	r22, Y+5	; 0x05
    71de:	7e 81       	ldd	r23, Y+6	; 0x06
    71e0:	8f 81       	ldd	r24, Y+7	; 0x07
    71e2:	98 85       	ldd	r25, Y+8	; 0x08
    71e4:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    71e8:	dc 01       	movw	r26, r24
    71ea:	cb 01       	movw	r24, r22
    71ec:	89 87       	std	Y+9, r24	; 0x09
    71ee:	89 85       	ldd	r24, Y+9	; 0x09
    71f0:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    71f2:	88 8d       	ldd	r24, Y+24	; 0x18
    71f4:	18 2f       	mov	r17, r24
    71f6:	1a 95       	dec	r17
    71f8:	f1 f7       	brne	.-4      	; 0x71f6 <FRAMTest3Channel+0x1c2>
    71fa:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    71fc:	0e 94 81 15 	call	0x2b02	; 0x2b02 <calcChecksumFRAM>

	ADCPower(FALSE);
    7200:	80 e0       	ldi	r24, 0x00	; 0
    7202:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
}
    7206:	6b 96       	adiw	r28, 0x1b	; 27
    7208:	cd bf       	out	0x3d, r28	; 61
    720a:	de bf       	out	0x3e, r29	; 62
    720c:	df 91       	pop	r29
    720e:	cf 91       	pop	r28
    7210:	1f 91       	pop	r17
    7212:	0f 91       	pop	r16
    7214:	08 95       	ret

00007216 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {
    7216:	0f 93       	push	r16
    7218:	1f 93       	push	r17
    721a:	cf 93       	push	r28
    721c:	df 93       	push	r29
    721e:	cd b7       	in	r28, 0x3d	; 61
    7220:	de b7       	in	r29, 0x3e	; 62
    7222:	68 97       	sbiw	r28, 0x18	; 24
    7224:	cd bf       	out	0x3d, r28	; 61
    7226:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7228:	81 e0       	ldi	r24, 0x01	; 1
    722a:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
    722e:	80 e0       	ldi	r24, 0x00	; 0
    7230:	90 e0       	ldi	r25, 0x00	; 0
    7232:	aa e7       	ldi	r26, 0x7A	; 122
    7234:	b3 e4       	ldi	r27, 0x43	; 67
    7236:	89 83       	std	Y+1, r24	; 0x01
    7238:	9a 83       	std	Y+2, r25	; 0x02
    723a:	ab 83       	std	Y+3, r26	; 0x03
    723c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    723e:	69 81       	ldd	r22, Y+1	; 0x01
    7240:	7a 81       	ldd	r23, Y+2	; 0x02
    7242:	8b 81       	ldd	r24, Y+3	; 0x03
    7244:	9c 81       	ldd	r25, Y+4	; 0x04
    7246:	2b ea       	ldi	r18, 0xAB	; 171
    7248:	3a ea       	ldi	r19, 0xAA	; 170
    724a:	4a e2       	ldi	r20, 0x2A	; 42
    724c:	51 e4       	ldi	r21, 0x41	; 65
    724e:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7252:	dc 01       	movw	r26, r24
    7254:	cb 01       	movw	r24, r22
    7256:	8d 83       	std	Y+5, r24	; 0x05
    7258:	9e 83       	std	Y+6, r25	; 0x06
    725a:	af 83       	std	Y+7, r26	; 0x07
    725c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    725e:	11 e0       	ldi	r17, 0x01	; 1
    7260:	6d 81       	ldd	r22, Y+5	; 0x05
    7262:	7e 81       	ldd	r23, Y+6	; 0x06
    7264:	8f 81       	ldd	r24, Y+7	; 0x07
    7266:	98 85       	ldd	r25, Y+8	; 0x08
    7268:	20 e0       	ldi	r18, 0x00	; 0
    726a:	30 e0       	ldi	r19, 0x00	; 0
    726c:	40 e8       	ldi	r20, 0x80	; 128
    726e:	5f e3       	ldi	r21, 0x3F	; 63
    7270:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    7274:	88 23       	and	r24, r24
    7276:	0c f0       	brlt	.+2      	; 0x727a <FRAMTest1Channel+0x64>
    7278:	10 e0       	ldi	r17, 0x00	; 0
    727a:	11 23       	and	r17, r17
    727c:	19 f0       	breq	.+6      	; 0x7284 <FRAMTest1Channel+0x6e>
		__ticks = 1;
    727e:	81 e0       	ldi	r24, 0x01	; 1
    7280:	89 87       	std	Y+9, r24	; 0x09
    7282:	a3 c0       	rjmp	.+326    	; 0x73ca <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    7284:	11 e0       	ldi	r17, 0x01	; 1
    7286:	6d 81       	ldd	r22, Y+5	; 0x05
    7288:	7e 81       	ldd	r23, Y+6	; 0x06
    728a:	8f 81       	ldd	r24, Y+7	; 0x07
    728c:	98 85       	ldd	r25, Y+8	; 0x08
    728e:	20 e0       	ldi	r18, 0x00	; 0
    7290:	30 e0       	ldi	r19, 0x00	; 0
    7292:	4f e7       	ldi	r20, 0x7F	; 127
    7294:	53 e4       	ldi	r21, 0x43	; 67
    7296:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    729a:	18 16       	cp	r1, r24
    729c:	0c f0       	brlt	.+2      	; 0x72a0 <FRAMTest1Channel+0x8a>
    729e:	10 e0       	ldi	r17, 0x00	; 0
    72a0:	11 23       	and	r17, r17
    72a2:	09 f4       	brne	.+2      	; 0x72a6 <FRAMTest1Channel+0x90>
    72a4:	89 c0       	rjmp	.+274    	; 0x73b8 <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    72a6:	69 81       	ldd	r22, Y+1	; 0x01
    72a8:	7a 81       	ldd	r23, Y+2	; 0x02
    72aa:	8b 81       	ldd	r24, Y+3	; 0x03
    72ac:	9c 81       	ldd	r25, Y+4	; 0x04
    72ae:	20 e0       	ldi	r18, 0x00	; 0
    72b0:	30 e0       	ldi	r19, 0x00	; 0
    72b2:	4a e7       	ldi	r20, 0x7A	; 122
    72b4:	54 e4       	ldi	r21, 0x44	; 68
    72b6:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    72ba:	dc 01       	movw	r26, r24
    72bc:	cb 01       	movw	r24, r22
    72be:	8a 87       	std	Y+10, r24	; 0x0a
    72c0:	9b 87       	std	Y+11, r25	; 0x0b
    72c2:	ac 87       	std	Y+12, r26	; 0x0c
    72c4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    72c6:	6a 85       	ldd	r22, Y+10	; 0x0a
    72c8:	7b 85       	ldd	r23, Y+11	; 0x0b
    72ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    72cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    72ce:	20 e0       	ldi	r18, 0x00	; 0
    72d0:	30 e0       	ldi	r19, 0x00	; 0
    72d2:	4a ef       	ldi	r20, 0xFA	; 250
    72d4:	55 e4       	ldi	r21, 0x45	; 69
    72d6:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    72da:	dc 01       	movw	r26, r24
    72dc:	cb 01       	movw	r24, r22
    72de:	8e 87       	std	Y+14, r24	; 0x0e
    72e0:	9f 87       	std	Y+15, r25	; 0x0f
    72e2:	a8 8b       	std	Y+16, r26	; 0x10
    72e4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    72e6:	11 e0       	ldi	r17, 0x01	; 1
    72e8:	6e 85       	ldd	r22, Y+14	; 0x0e
    72ea:	7f 85       	ldd	r23, Y+15	; 0x0f
    72ec:	88 89       	ldd	r24, Y+16	; 0x10
    72ee:	99 89       	ldd	r25, Y+17	; 0x11
    72f0:	20 e0       	ldi	r18, 0x00	; 0
    72f2:	30 e0       	ldi	r19, 0x00	; 0
    72f4:	40 e8       	ldi	r20, 0x80	; 128
    72f6:	5f e3       	ldi	r21, 0x3F	; 63
    72f8:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    72fc:	88 23       	and	r24, r24
    72fe:	0c f0       	brlt	.+2      	; 0x7302 <FRAMTest1Channel+0xec>
    7300:	10 e0       	ldi	r17, 0x00	; 0
    7302:	11 23       	and	r17, r17
    7304:	29 f0       	breq	.+10     	; 0x7310 <FRAMTest1Channel+0xfa>
		__ticks = 1;
    7306:	81 e0       	ldi	r24, 0x01	; 1
    7308:	90 e0       	ldi	r25, 0x00	; 0
    730a:	8a 8b       	std	Y+18, r24	; 0x12
    730c:	9b 8b       	std	Y+19, r25	; 0x13
    730e:	46 c0       	rjmp	.+140    	; 0x739c <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    7310:	11 e0       	ldi	r17, 0x01	; 1
    7312:	6e 85       	ldd	r22, Y+14	; 0x0e
    7314:	7f 85       	ldd	r23, Y+15	; 0x0f
    7316:	88 89       	ldd	r24, Y+16	; 0x10
    7318:	99 89       	ldd	r25, Y+17	; 0x11
    731a:	20 e0       	ldi	r18, 0x00	; 0
    731c:	3f ef       	ldi	r19, 0xFF	; 255
    731e:	4f e7       	ldi	r20, 0x7F	; 127
    7320:	57 e4       	ldi	r21, 0x47	; 71
    7322:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    7326:	18 16       	cp	r1, r24
    7328:	0c f0       	brlt	.+2      	; 0x732c <FRAMTest1Channel+0x116>
    732a:	10 e0       	ldi	r17, 0x00	; 0
    732c:	11 23       	and	r17, r17
    732e:	61 f1       	breq	.+88     	; 0x7388 <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7330:	6a 85       	ldd	r22, Y+10	; 0x0a
    7332:	7b 85       	ldd	r23, Y+11	; 0x0b
    7334:	8c 85       	ldd	r24, Y+12	; 0x0c
    7336:	9d 85       	ldd	r25, Y+13	; 0x0d
    7338:	20 e0       	ldi	r18, 0x00	; 0
    733a:	30 e0       	ldi	r19, 0x00	; 0
    733c:	40 e2       	ldi	r20, 0x20	; 32
    733e:	51 e4       	ldi	r21, 0x41	; 65
    7340:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7344:	dc 01       	movw	r26, r24
    7346:	cb 01       	movw	r24, r22
    7348:	bc 01       	movw	r22, r24
    734a:	cd 01       	movw	r24, r26
    734c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    7350:	dc 01       	movw	r26, r24
    7352:	cb 01       	movw	r24, r22
    7354:	8a 8b       	std	Y+18, r24	; 0x12
    7356:	9b 8b       	std	Y+19, r25	; 0x13
    7358:	12 c0       	rjmp	.+36     	; 0x737e <FRAMTest1Channel+0x168>
    735a:	80 e2       	ldi	r24, 0x20	; 32
    735c:	93 e0       	ldi	r25, 0x03	; 3
    735e:	8c 8b       	std	Y+20, r24	; 0x14
    7360:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7362:	8c 89       	ldd	r24, Y+20	; 0x14
    7364:	9d 89       	ldd	r25, Y+21	; 0x15
    7366:	8c 01       	movw	r16, r24
    7368:	c8 01       	movw	r24, r16
    736a:	01 97       	sbiw	r24, 0x01	; 1
    736c:	f1 f7       	brne	.-4      	; 0x736a <FRAMTest1Channel+0x154>
    736e:	8c 01       	movw	r16, r24
    7370:	0c 8b       	std	Y+20, r16	; 0x14
    7372:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7374:	8a 89       	ldd	r24, Y+18	; 0x12
    7376:	9b 89       	ldd	r25, Y+19	; 0x13
    7378:	01 97       	sbiw	r24, 0x01	; 1
    737a:	8a 8b       	std	Y+18, r24	; 0x12
    737c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    737e:	8a 89       	ldd	r24, Y+18	; 0x12
    7380:	9b 89       	ldd	r25, Y+19	; 0x13
    7382:	00 97       	sbiw	r24, 0x00	; 0
    7384:	51 f7       	brne	.-44     	; 0x735a <FRAMTest1Channel+0x144>
    7386:	28 c0       	rjmp	.+80     	; 0x73d8 <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7388:	6e 85       	ldd	r22, Y+14	; 0x0e
    738a:	7f 85       	ldd	r23, Y+15	; 0x0f
    738c:	88 89       	ldd	r24, Y+16	; 0x10
    738e:	99 89       	ldd	r25, Y+17	; 0x11
    7390:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    7394:	dc 01       	movw	r26, r24
    7396:	cb 01       	movw	r24, r22
    7398:	8a 8b       	std	Y+18, r24	; 0x12
    739a:	9b 8b       	std	Y+19, r25	; 0x13
    739c:	8a 89       	ldd	r24, Y+18	; 0x12
    739e:	9b 89       	ldd	r25, Y+19	; 0x13
    73a0:	8e 8b       	std	Y+22, r24	; 0x16
    73a2:	9f 8b       	std	Y+23, r25	; 0x17
    73a4:	8e 89       	ldd	r24, Y+22	; 0x16
    73a6:	9f 89       	ldd	r25, Y+23	; 0x17
    73a8:	8c 01       	movw	r16, r24
    73aa:	c8 01       	movw	r24, r16
    73ac:	01 97       	sbiw	r24, 0x01	; 1
    73ae:	f1 f7       	brne	.-4      	; 0x73ac <FRAMTest1Channel+0x196>
    73b0:	8c 01       	movw	r16, r24
    73b2:	0e 8b       	std	Y+22, r16	; 0x16
    73b4:	1f 8b       	std	Y+23, r17	; 0x17
    73b6:	10 c0       	rjmp	.+32     	; 0x73d8 <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    73b8:	6d 81       	ldd	r22, Y+5	; 0x05
    73ba:	7e 81       	ldd	r23, Y+6	; 0x06
    73bc:	8f 81       	ldd	r24, Y+7	; 0x07
    73be:	98 85       	ldd	r25, Y+8	; 0x08
    73c0:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    73c4:	dc 01       	movw	r26, r24
    73c6:	cb 01       	movw	r24, r22
    73c8:	89 87       	std	Y+9, r24	; 0x09
    73ca:	89 85       	ldd	r24, Y+9	; 0x09
    73cc:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    73ce:	88 8d       	ldd	r24, Y+24	; 0x18
    73d0:	18 2f       	mov	r17, r24
    73d2:	1a 95       	dec	r17
    73d4:	f1 f7       	brne	.-4      	; 0x73d2 <FRAMTest1Channel+0x1bc>
    73d6:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    73d8:	0e 94 81 15 	call	0x2b02	; 0x2b02 <calcChecksumFRAM>

	ADCPower(FALSE);
    73dc:	80 e0       	ldi	r24, 0x00	; 0
    73de:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

}
    73e2:	68 96       	adiw	r28, 0x18	; 24
    73e4:	cd bf       	out	0x3d, r28	; 61
    73e6:	de bf       	out	0x3e, r29	; 62
    73e8:	df 91       	pop	r29
    73ea:	cf 91       	pop	r28
    73ec:	1f 91       	pop	r17
    73ee:	0f 91       	pop	r16
    73f0:	08 95       	ret

000073f2 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    73f2:	0f 93       	push	r16
    73f4:	1f 93       	push	r17
    73f6:	cf 93       	push	r28
    73f8:	df 93       	push	r29
    73fa:	cd b7       	in	r28, 0x3d	; 61
    73fc:	de b7       	in	r29, 0x3e	; 62
    73fe:	68 97       	sbiw	r28, 0x18	; 24
    7400:	cd bf       	out	0x3d, r28	; 61
    7402:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    7404:	0e 94 89 18 	call	0x3112	; 0x3112 <FRAMWriteKnowns>
	ADCPower(TRUE);
    7408:	81 e0       	ldi	r24, 0x01	; 1
    740a:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
    740e:	80 e0       	ldi	r24, 0x00	; 0
    7410:	90 e0       	ldi	r25, 0x00	; 0
    7412:	aa e7       	ldi	r26, 0x7A	; 122
    7414:	b3 e4       	ldi	r27, 0x43	; 67
    7416:	89 83       	std	Y+1, r24	; 0x01
    7418:	9a 83       	std	Y+2, r25	; 0x02
    741a:	ab 83       	std	Y+3, r26	; 0x03
    741c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    741e:	69 81       	ldd	r22, Y+1	; 0x01
    7420:	7a 81       	ldd	r23, Y+2	; 0x02
    7422:	8b 81       	ldd	r24, Y+3	; 0x03
    7424:	9c 81       	ldd	r25, Y+4	; 0x04
    7426:	2b ea       	ldi	r18, 0xAB	; 171
    7428:	3a ea       	ldi	r19, 0xAA	; 170
    742a:	4a e2       	ldi	r20, 0x2A	; 42
    742c:	51 e4       	ldi	r21, 0x41	; 65
    742e:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7432:	dc 01       	movw	r26, r24
    7434:	cb 01       	movw	r24, r22
    7436:	8d 83       	std	Y+5, r24	; 0x05
    7438:	9e 83       	std	Y+6, r25	; 0x06
    743a:	af 83       	std	Y+7, r26	; 0x07
    743c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    743e:	11 e0       	ldi	r17, 0x01	; 1
    7440:	6d 81       	ldd	r22, Y+5	; 0x05
    7442:	7e 81       	ldd	r23, Y+6	; 0x06
    7444:	8f 81       	ldd	r24, Y+7	; 0x07
    7446:	98 85       	ldd	r25, Y+8	; 0x08
    7448:	20 e0       	ldi	r18, 0x00	; 0
    744a:	30 e0       	ldi	r19, 0x00	; 0
    744c:	40 e8       	ldi	r20, 0x80	; 128
    744e:	5f e3       	ldi	r21, 0x3F	; 63
    7450:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    7454:	88 23       	and	r24, r24
    7456:	0c f0       	brlt	.+2      	; 0x745a <FRAMWriteKnownsCheck+0x68>
    7458:	10 e0       	ldi	r17, 0x00	; 0
    745a:	11 23       	and	r17, r17
    745c:	19 f0       	breq	.+6      	; 0x7464 <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    745e:	81 e0       	ldi	r24, 0x01	; 1
    7460:	89 87       	std	Y+9, r24	; 0x09
    7462:	a3 c0       	rjmp	.+326    	; 0x75aa <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7464:	11 e0       	ldi	r17, 0x01	; 1
    7466:	6d 81       	ldd	r22, Y+5	; 0x05
    7468:	7e 81       	ldd	r23, Y+6	; 0x06
    746a:	8f 81       	ldd	r24, Y+7	; 0x07
    746c:	98 85       	ldd	r25, Y+8	; 0x08
    746e:	20 e0       	ldi	r18, 0x00	; 0
    7470:	30 e0       	ldi	r19, 0x00	; 0
    7472:	4f e7       	ldi	r20, 0x7F	; 127
    7474:	53 e4       	ldi	r21, 0x43	; 67
    7476:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    747a:	18 16       	cp	r1, r24
    747c:	0c f0       	brlt	.+2      	; 0x7480 <FRAMWriteKnownsCheck+0x8e>
    747e:	10 e0       	ldi	r17, 0x00	; 0
    7480:	11 23       	and	r17, r17
    7482:	09 f4       	brne	.+2      	; 0x7486 <FRAMWriteKnownsCheck+0x94>
    7484:	89 c0       	rjmp	.+274    	; 0x7598 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7486:	69 81       	ldd	r22, Y+1	; 0x01
    7488:	7a 81       	ldd	r23, Y+2	; 0x02
    748a:	8b 81       	ldd	r24, Y+3	; 0x03
    748c:	9c 81       	ldd	r25, Y+4	; 0x04
    748e:	20 e0       	ldi	r18, 0x00	; 0
    7490:	30 e0       	ldi	r19, 0x00	; 0
    7492:	4a e7       	ldi	r20, 0x7A	; 122
    7494:	54 e4       	ldi	r21, 0x44	; 68
    7496:	0e 94 34 60 	call	0xc068	; 0xc068 <__divsf3>
    749a:	dc 01       	movw	r26, r24
    749c:	cb 01       	movw	r24, r22
    749e:	8a 87       	std	Y+10, r24	; 0x0a
    74a0:	9b 87       	std	Y+11, r25	; 0x0b
    74a2:	ac 87       	std	Y+12, r26	; 0x0c
    74a4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    74a6:	6a 85       	ldd	r22, Y+10	; 0x0a
    74a8:	7b 85       	ldd	r23, Y+11	; 0x0b
    74aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    74ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    74ae:	20 e0       	ldi	r18, 0x00	; 0
    74b0:	30 e0       	ldi	r19, 0x00	; 0
    74b2:	4a ef       	ldi	r20, 0xFA	; 250
    74b4:	55 e4       	ldi	r21, 0x45	; 69
    74b6:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    74ba:	dc 01       	movw	r26, r24
    74bc:	cb 01       	movw	r24, r22
    74be:	8e 87       	std	Y+14, r24	; 0x0e
    74c0:	9f 87       	std	Y+15, r25	; 0x0f
    74c2:	a8 8b       	std	Y+16, r26	; 0x10
    74c4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    74c6:	11 e0       	ldi	r17, 0x01	; 1
    74c8:	6e 85       	ldd	r22, Y+14	; 0x0e
    74ca:	7f 85       	ldd	r23, Y+15	; 0x0f
    74cc:	88 89       	ldd	r24, Y+16	; 0x10
    74ce:	99 89       	ldd	r25, Y+17	; 0x11
    74d0:	20 e0       	ldi	r18, 0x00	; 0
    74d2:	30 e0       	ldi	r19, 0x00	; 0
    74d4:	40 e8       	ldi	r20, 0x80	; 128
    74d6:	5f e3       	ldi	r21, 0x3F	; 63
    74d8:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    74dc:	88 23       	and	r24, r24
    74de:	0c f0       	brlt	.+2      	; 0x74e2 <FRAMWriteKnownsCheck+0xf0>
    74e0:	10 e0       	ldi	r17, 0x00	; 0
    74e2:	11 23       	and	r17, r17
    74e4:	29 f0       	breq	.+10     	; 0x74f0 <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    74e6:	81 e0       	ldi	r24, 0x01	; 1
    74e8:	90 e0       	ldi	r25, 0x00	; 0
    74ea:	8a 8b       	std	Y+18, r24	; 0x12
    74ec:	9b 8b       	std	Y+19, r25	; 0x13
    74ee:	46 c0       	rjmp	.+140    	; 0x757c <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    74f0:	11 e0       	ldi	r17, 0x01	; 1
    74f2:	6e 85       	ldd	r22, Y+14	; 0x0e
    74f4:	7f 85       	ldd	r23, Y+15	; 0x0f
    74f6:	88 89       	ldd	r24, Y+16	; 0x10
    74f8:	99 89       	ldd	r25, Y+17	; 0x11
    74fa:	20 e0       	ldi	r18, 0x00	; 0
    74fc:	3f ef       	ldi	r19, 0xFF	; 255
    74fe:	4f e7       	ldi	r20, 0x7F	; 127
    7500:	57 e4       	ldi	r21, 0x47	; 71
    7502:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    7506:	18 16       	cp	r1, r24
    7508:	0c f0       	brlt	.+2      	; 0x750c <FRAMWriteKnownsCheck+0x11a>
    750a:	10 e0       	ldi	r17, 0x00	; 0
    750c:	11 23       	and	r17, r17
    750e:	61 f1       	breq	.+88     	; 0x7568 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7510:	6a 85       	ldd	r22, Y+10	; 0x0a
    7512:	7b 85       	ldd	r23, Y+11	; 0x0b
    7514:	8c 85       	ldd	r24, Y+12	; 0x0c
    7516:	9d 85       	ldd	r25, Y+13	; 0x0d
    7518:	20 e0       	ldi	r18, 0x00	; 0
    751a:	30 e0       	ldi	r19, 0x00	; 0
    751c:	40 e2       	ldi	r20, 0x20	; 32
    751e:	51 e4       	ldi	r21, 0x41	; 65
    7520:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7524:	dc 01       	movw	r26, r24
    7526:	cb 01       	movw	r24, r22
    7528:	bc 01       	movw	r22, r24
    752a:	cd 01       	movw	r24, r26
    752c:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    7530:	dc 01       	movw	r26, r24
    7532:	cb 01       	movw	r24, r22
    7534:	8a 8b       	std	Y+18, r24	; 0x12
    7536:	9b 8b       	std	Y+19, r25	; 0x13
    7538:	12 c0       	rjmp	.+36     	; 0x755e <FRAMWriteKnownsCheck+0x16c>
    753a:	80 e2       	ldi	r24, 0x20	; 32
    753c:	93 e0       	ldi	r25, 0x03	; 3
    753e:	8c 8b       	std	Y+20, r24	; 0x14
    7540:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7542:	8c 89       	ldd	r24, Y+20	; 0x14
    7544:	9d 89       	ldd	r25, Y+21	; 0x15
    7546:	8c 01       	movw	r16, r24
    7548:	c8 01       	movw	r24, r16
    754a:	01 97       	sbiw	r24, 0x01	; 1
    754c:	f1 f7       	brne	.-4      	; 0x754a <FRAMWriteKnownsCheck+0x158>
    754e:	8c 01       	movw	r16, r24
    7550:	0c 8b       	std	Y+20, r16	; 0x14
    7552:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7554:	8a 89       	ldd	r24, Y+18	; 0x12
    7556:	9b 89       	ldd	r25, Y+19	; 0x13
    7558:	01 97       	sbiw	r24, 0x01	; 1
    755a:	8a 8b       	std	Y+18, r24	; 0x12
    755c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    755e:	8a 89       	ldd	r24, Y+18	; 0x12
    7560:	9b 89       	ldd	r25, Y+19	; 0x13
    7562:	00 97       	sbiw	r24, 0x00	; 0
    7564:	51 f7       	brne	.-44     	; 0x753a <FRAMWriteKnownsCheck+0x148>
    7566:	28 c0       	rjmp	.+80     	; 0x75b8 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7568:	6e 85       	ldd	r22, Y+14	; 0x0e
    756a:	7f 85       	ldd	r23, Y+15	; 0x0f
    756c:	88 89       	ldd	r24, Y+16	; 0x10
    756e:	99 89       	ldd	r25, Y+17	; 0x11
    7570:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    7574:	dc 01       	movw	r26, r24
    7576:	cb 01       	movw	r24, r22
    7578:	8a 8b       	std	Y+18, r24	; 0x12
    757a:	9b 8b       	std	Y+19, r25	; 0x13
    757c:	8a 89       	ldd	r24, Y+18	; 0x12
    757e:	9b 89       	ldd	r25, Y+19	; 0x13
    7580:	8e 8b       	std	Y+22, r24	; 0x16
    7582:	9f 8b       	std	Y+23, r25	; 0x17
    7584:	8e 89       	ldd	r24, Y+22	; 0x16
    7586:	9f 89       	ldd	r25, Y+23	; 0x17
    7588:	8c 01       	movw	r16, r24
    758a:	c8 01       	movw	r24, r16
    758c:	01 97       	sbiw	r24, 0x01	; 1
    758e:	f1 f7       	brne	.-4      	; 0x758c <FRAMWriteKnownsCheck+0x19a>
    7590:	8c 01       	movw	r16, r24
    7592:	0e 8b       	std	Y+22, r16	; 0x16
    7594:	1f 8b       	std	Y+23, r17	; 0x17
    7596:	10 c0       	rjmp	.+32     	; 0x75b8 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7598:	6d 81       	ldd	r22, Y+5	; 0x05
    759a:	7e 81       	ldd	r23, Y+6	; 0x06
    759c:	8f 81       	ldd	r24, Y+7	; 0x07
    759e:	98 85       	ldd	r25, Y+8	; 0x08
    75a0:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    75a4:	dc 01       	movw	r26, r24
    75a6:	cb 01       	movw	r24, r22
    75a8:	89 87       	std	Y+9, r24	; 0x09
    75aa:	89 85       	ldd	r24, Y+9	; 0x09
    75ac:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    75ae:	88 8d       	ldd	r24, Y+24	; 0x18
    75b0:	18 2f       	mov	r17, r24
    75b2:	1a 95       	dec	r17
    75b4:	f1 f7       	brne	.-4      	; 0x75b2 <FRAMWriteKnownsCheck+0x1c0>
    75b6:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    75b8:	0e 94 81 15 	call	0x2b02	; 0x2b02 <calcChecksumFRAM>

	ADCPower(FALSE);
    75bc:	80 e0       	ldi	r24, 0x00	; 0
    75be:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

}
    75c2:	68 96       	adiw	r28, 0x18	; 24
    75c4:	cd bf       	out	0x3d, r28	; 61
    75c6:	de bf       	out	0x3e, r29	; 62
    75c8:	df 91       	pop	r29
    75ca:	cf 91       	pop	r28
    75cc:	1f 91       	pop	r17
    75ce:	0f 91       	pop	r16
    75d0:	08 95       	ret

000075d2 <checkMote>:

//random function for testing stuff	
void checkMote(){
    75d2:	0f 93       	push	r16
    75d4:	1f 93       	push	r17
    75d6:	cf 93       	push	r28
    75d8:	df 93       	push	r29
    75da:	cd b7       	in	r28, 0x3d	; 61
    75dc:	de b7       	in	r29, 0x3e	; 62
    75de:	aa 97       	sbiw	r28, 0x2a	; 42
    75e0:	cd bf       	out	0x3d, r28	; 61
    75e2:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    75e4:	81 e0       	ldi	r24, 0x01	; 1
    75e6:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	Ext1Power(TRUE);
    75ea:	81 e0       	ldi	r24, 0x01	; 1
    75ec:	0e 94 05 34 	call	0x680a	; 0x680a <Ext1Power>
    75f0:	80 e0       	ldi	r24, 0x00	; 0
    75f2:	90 e0       	ldi	r25, 0x00	; 0
    75f4:	a8 ec       	ldi	r26, 0xC8	; 200
    75f6:	b2 e4       	ldi	r27, 0x42	; 66
    75f8:	89 83       	std	Y+1, r24	; 0x01
    75fa:	9a 83       	std	Y+2, r25	; 0x02
    75fc:	ab 83       	std	Y+3, r26	; 0x03
    75fe:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7600:	69 81       	ldd	r22, Y+1	; 0x01
    7602:	7a 81       	ldd	r23, Y+2	; 0x02
    7604:	8b 81       	ldd	r24, Y+3	; 0x03
    7606:	9c 81       	ldd	r25, Y+4	; 0x04
    7608:	20 e0       	ldi	r18, 0x00	; 0
    760a:	30 e0       	ldi	r19, 0x00	; 0
    760c:	4a ef       	ldi	r20, 0xFA	; 250
    760e:	55 e4       	ldi	r21, 0x45	; 69
    7610:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7614:	dc 01       	movw	r26, r24
    7616:	cb 01       	movw	r24, r22
    7618:	8d 83       	std	Y+5, r24	; 0x05
    761a:	9e 83       	std	Y+6, r25	; 0x06
    761c:	af 83       	std	Y+7, r26	; 0x07
    761e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7620:	11 e0       	ldi	r17, 0x01	; 1
    7622:	6d 81       	ldd	r22, Y+5	; 0x05
    7624:	7e 81       	ldd	r23, Y+6	; 0x06
    7626:	8f 81       	ldd	r24, Y+7	; 0x07
    7628:	98 85       	ldd	r25, Y+8	; 0x08
    762a:	20 e0       	ldi	r18, 0x00	; 0
    762c:	30 e0       	ldi	r19, 0x00	; 0
    762e:	40 e8       	ldi	r20, 0x80	; 128
    7630:	5f e3       	ldi	r21, 0x3F	; 63
    7632:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    7636:	88 23       	and	r24, r24
    7638:	0c f0       	brlt	.+2      	; 0x763c <checkMote+0x6a>
    763a:	10 e0       	ldi	r17, 0x00	; 0
    763c:	11 23       	and	r17, r17
    763e:	29 f0       	breq	.+10     	; 0x764a <checkMote+0x78>
		__ticks = 1;
    7640:	81 e0       	ldi	r24, 0x01	; 1
    7642:	90 e0       	ldi	r25, 0x00	; 0
    7644:	89 87       	std	Y+9, r24	; 0x09
    7646:	9a 87       	std	Y+10, r25	; 0x0a
    7648:	46 c0       	rjmp	.+140    	; 0x76d6 <checkMote+0x104>
	else if (__tmp > 65535)
    764a:	11 e0       	ldi	r17, 0x01	; 1
    764c:	6d 81       	ldd	r22, Y+5	; 0x05
    764e:	7e 81       	ldd	r23, Y+6	; 0x06
    7650:	8f 81       	ldd	r24, Y+7	; 0x07
    7652:	98 85       	ldd	r25, Y+8	; 0x08
    7654:	20 e0       	ldi	r18, 0x00	; 0
    7656:	3f ef       	ldi	r19, 0xFF	; 255
    7658:	4f e7       	ldi	r20, 0x7F	; 127
    765a:	57 e4       	ldi	r21, 0x47	; 71
    765c:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    7660:	18 16       	cp	r1, r24
    7662:	0c f0       	brlt	.+2      	; 0x7666 <checkMote+0x94>
    7664:	10 e0       	ldi	r17, 0x00	; 0
    7666:	11 23       	and	r17, r17
    7668:	61 f1       	breq	.+88     	; 0x76c2 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    766a:	69 81       	ldd	r22, Y+1	; 0x01
    766c:	7a 81       	ldd	r23, Y+2	; 0x02
    766e:	8b 81       	ldd	r24, Y+3	; 0x03
    7670:	9c 81       	ldd	r25, Y+4	; 0x04
    7672:	20 e0       	ldi	r18, 0x00	; 0
    7674:	30 e0       	ldi	r19, 0x00	; 0
    7676:	40 e2       	ldi	r20, 0x20	; 32
    7678:	51 e4       	ldi	r21, 0x41	; 65
    767a:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    767e:	dc 01       	movw	r26, r24
    7680:	cb 01       	movw	r24, r22
    7682:	bc 01       	movw	r22, r24
    7684:	cd 01       	movw	r24, r26
    7686:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    768a:	dc 01       	movw	r26, r24
    768c:	cb 01       	movw	r24, r22
    768e:	89 87       	std	Y+9, r24	; 0x09
    7690:	9a 87       	std	Y+10, r25	; 0x0a
    7692:	12 c0       	rjmp	.+36     	; 0x76b8 <checkMote+0xe6>
    7694:	80 e2       	ldi	r24, 0x20	; 32
    7696:	93 e0       	ldi	r25, 0x03	; 3
    7698:	8b 87       	std	Y+11, r24	; 0x0b
    769a:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    769c:	8b 85       	ldd	r24, Y+11	; 0x0b
    769e:	9c 85       	ldd	r25, Y+12	; 0x0c
    76a0:	8c 01       	movw	r16, r24
    76a2:	c8 01       	movw	r24, r16
    76a4:	01 97       	sbiw	r24, 0x01	; 1
    76a6:	f1 f7       	brne	.-4      	; 0x76a4 <checkMote+0xd2>
    76a8:	8c 01       	movw	r16, r24
    76aa:	0b 87       	std	Y+11, r16	; 0x0b
    76ac:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    76ae:	89 85       	ldd	r24, Y+9	; 0x09
    76b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    76b2:	01 97       	sbiw	r24, 0x01	; 1
    76b4:	89 87       	std	Y+9, r24	; 0x09
    76b6:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    76b8:	89 85       	ldd	r24, Y+9	; 0x09
    76ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    76bc:	00 97       	sbiw	r24, 0x00	; 0
    76be:	51 f7       	brne	.-44     	; 0x7694 <checkMote+0xc2>
    76c0:	17 c0       	rjmp	.+46     	; 0x76f0 <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    76c2:	6d 81       	ldd	r22, Y+5	; 0x05
    76c4:	7e 81       	ldd	r23, Y+6	; 0x06
    76c6:	8f 81       	ldd	r24, Y+7	; 0x07
    76c8:	98 85       	ldd	r25, Y+8	; 0x08
    76ca:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    76ce:	dc 01       	movw	r26, r24
    76d0:	cb 01       	movw	r24, r22
    76d2:	89 87       	std	Y+9, r24	; 0x09
    76d4:	9a 87       	std	Y+10, r25	; 0x0a
    76d6:	89 85       	ldd	r24, Y+9	; 0x09
    76d8:	9a 85       	ldd	r25, Y+10	; 0x0a
    76da:	8d 87       	std	Y+13, r24	; 0x0d
    76dc:	9e 87       	std	Y+14, r25	; 0x0e
    76de:	8d 85       	ldd	r24, Y+13	; 0x0d
    76e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    76e2:	8c 01       	movw	r16, r24
    76e4:	c8 01       	movw	r24, r16
    76e6:	01 97       	sbiw	r24, 0x01	; 1
    76e8:	f1 f7       	brne	.-4      	; 0x76e6 <checkMote+0x114>
    76ea:	8c 01       	movw	r16, r24
    76ec:	0d 87       	std	Y+13, r16	; 0x0d
    76ee:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    76f0:	88 e0       	ldi	r24, 0x08	; 8
    76f2:	60 e0       	ldi	r22, 0x00	; 0
    76f4:	0e 94 6f 32 	call	0x64de	; 0x64de <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    76f8:	88 e0       	ldi	r24, 0x08	; 8
    76fa:	60 e0       	ldi	r22, 0x00	; 0
    76fc:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
    7700:	80 e0       	ldi	r24, 0x00	; 0
    7702:	90 e4       	ldi	r25, 0x40	; 64
    7704:	ac e9       	ldi	r26, 0x9C	; 156
    7706:	b5 e4       	ldi	r27, 0x45	; 69
    7708:	8f 87       	std	Y+15, r24	; 0x0f
    770a:	98 8b       	std	Y+16, r25	; 0x10
    770c:	a9 8b       	std	Y+17, r26	; 0x11
    770e:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7710:	6f 85       	ldd	r22, Y+15	; 0x0f
    7712:	78 89       	ldd	r23, Y+16	; 0x10
    7714:	89 89       	ldd	r24, Y+17	; 0x11
    7716:	9a 89       	ldd	r25, Y+18	; 0x12
    7718:	20 e0       	ldi	r18, 0x00	; 0
    771a:	30 e0       	ldi	r19, 0x00	; 0
    771c:	4a ef       	ldi	r20, 0xFA	; 250
    771e:	55 e4       	ldi	r21, 0x45	; 69
    7720:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7724:	dc 01       	movw	r26, r24
    7726:	cb 01       	movw	r24, r22
    7728:	8b 8b       	std	Y+19, r24	; 0x13
    772a:	9c 8b       	std	Y+20, r25	; 0x14
    772c:	ad 8b       	std	Y+21, r26	; 0x15
    772e:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7730:	11 e0       	ldi	r17, 0x01	; 1
    7732:	6b 89       	ldd	r22, Y+19	; 0x13
    7734:	7c 89       	ldd	r23, Y+20	; 0x14
    7736:	8d 89       	ldd	r24, Y+21	; 0x15
    7738:	9e 89       	ldd	r25, Y+22	; 0x16
    773a:	20 e0       	ldi	r18, 0x00	; 0
    773c:	30 e0       	ldi	r19, 0x00	; 0
    773e:	40 e8       	ldi	r20, 0x80	; 128
    7740:	5f e3       	ldi	r21, 0x3F	; 63
    7742:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    7746:	88 23       	and	r24, r24
    7748:	0c f0       	brlt	.+2      	; 0x774c <checkMote+0x17a>
    774a:	10 e0       	ldi	r17, 0x00	; 0
    774c:	11 23       	and	r17, r17
    774e:	29 f0       	breq	.+10     	; 0x775a <checkMote+0x188>
		__ticks = 1;
    7750:	81 e0       	ldi	r24, 0x01	; 1
    7752:	90 e0       	ldi	r25, 0x00	; 0
    7754:	8f 8b       	std	Y+23, r24	; 0x17
    7756:	98 8f       	std	Y+24, r25	; 0x18
    7758:	46 c0       	rjmp	.+140    	; 0x77e6 <checkMote+0x214>
	else if (__tmp > 65535)
    775a:	11 e0       	ldi	r17, 0x01	; 1
    775c:	6b 89       	ldd	r22, Y+19	; 0x13
    775e:	7c 89       	ldd	r23, Y+20	; 0x14
    7760:	8d 89       	ldd	r24, Y+21	; 0x15
    7762:	9e 89       	ldd	r25, Y+22	; 0x16
    7764:	20 e0       	ldi	r18, 0x00	; 0
    7766:	3f ef       	ldi	r19, 0xFF	; 255
    7768:	4f e7       	ldi	r20, 0x7F	; 127
    776a:	57 e4       	ldi	r21, 0x47	; 71
    776c:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    7770:	18 16       	cp	r1, r24
    7772:	0c f0       	brlt	.+2      	; 0x7776 <checkMote+0x1a4>
    7774:	10 e0       	ldi	r17, 0x00	; 0
    7776:	11 23       	and	r17, r17
    7778:	61 f1       	breq	.+88     	; 0x77d2 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    777a:	6f 85       	ldd	r22, Y+15	; 0x0f
    777c:	78 89       	ldd	r23, Y+16	; 0x10
    777e:	89 89       	ldd	r24, Y+17	; 0x11
    7780:	9a 89       	ldd	r25, Y+18	; 0x12
    7782:	20 e0       	ldi	r18, 0x00	; 0
    7784:	30 e0       	ldi	r19, 0x00	; 0
    7786:	40 e2       	ldi	r20, 0x20	; 32
    7788:	51 e4       	ldi	r21, 0x41	; 65
    778a:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    778e:	dc 01       	movw	r26, r24
    7790:	cb 01       	movw	r24, r22
    7792:	bc 01       	movw	r22, r24
    7794:	cd 01       	movw	r24, r26
    7796:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    779a:	dc 01       	movw	r26, r24
    779c:	cb 01       	movw	r24, r22
    779e:	8f 8b       	std	Y+23, r24	; 0x17
    77a0:	98 8f       	std	Y+24, r25	; 0x18
    77a2:	12 c0       	rjmp	.+36     	; 0x77c8 <checkMote+0x1f6>
    77a4:	80 e2       	ldi	r24, 0x20	; 32
    77a6:	93 e0       	ldi	r25, 0x03	; 3
    77a8:	89 8f       	std	Y+25, r24	; 0x19
    77aa:	9a 8f       	std	Y+26, r25	; 0x1a
    77ac:	89 8d       	ldd	r24, Y+25	; 0x19
    77ae:	9a 8d       	ldd	r25, Y+26	; 0x1a
    77b0:	8c 01       	movw	r16, r24
    77b2:	c8 01       	movw	r24, r16
    77b4:	01 97       	sbiw	r24, 0x01	; 1
    77b6:	f1 f7       	brne	.-4      	; 0x77b4 <checkMote+0x1e2>
    77b8:	8c 01       	movw	r16, r24
    77ba:	09 8f       	std	Y+25, r16	; 0x19
    77bc:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    77be:	8f 89       	ldd	r24, Y+23	; 0x17
    77c0:	98 8d       	ldd	r25, Y+24	; 0x18
    77c2:	01 97       	sbiw	r24, 0x01	; 1
    77c4:	8f 8b       	std	Y+23, r24	; 0x17
    77c6:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    77c8:	8f 89       	ldd	r24, Y+23	; 0x17
    77ca:	98 8d       	ldd	r25, Y+24	; 0x18
    77cc:	00 97       	sbiw	r24, 0x00	; 0
    77ce:	51 f7       	brne	.-44     	; 0x77a4 <checkMote+0x1d2>
    77d0:	17 c0       	rjmp	.+46     	; 0x7800 <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    77d2:	6b 89       	ldd	r22, Y+19	; 0x13
    77d4:	7c 89       	ldd	r23, Y+20	; 0x14
    77d6:	8d 89       	ldd	r24, Y+21	; 0x15
    77d8:	9e 89       	ldd	r25, Y+22	; 0x16
    77da:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    77de:	dc 01       	movw	r26, r24
    77e0:	cb 01       	movw	r24, r22
    77e2:	8f 8b       	std	Y+23, r24	; 0x17
    77e4:	98 8f       	std	Y+24, r25	; 0x18
    77e6:	8f 89       	ldd	r24, Y+23	; 0x17
    77e8:	98 8d       	ldd	r25, Y+24	; 0x18
    77ea:	8b 8f       	std	Y+27, r24	; 0x1b
    77ec:	9c 8f       	std	Y+28, r25	; 0x1c
    77ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    77f0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    77f2:	8c 01       	movw	r16, r24
    77f4:	c8 01       	movw	r24, r16
    77f6:	01 97       	sbiw	r24, 0x01	; 1
    77f8:	f1 f7       	brne	.-4      	; 0x77f6 <checkMote+0x224>
    77fa:	8c 01       	movw	r16, r24
    77fc:	0b 8f       	std	Y+27, r16	; 0x1b
    77fe:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7800:	88 e0       	ldi	r24, 0x08	; 8
    7802:	60 e0       	ldi	r22, 0x00	; 0
    7804:	0e 94 9e 33 	call	0x673c	; 0x673c <PortEx_OUTCLR>
    7808:	80 e0       	ldi	r24, 0x00	; 0
    780a:	90 e4       	ldi	r25, 0x40	; 64
    780c:	ac e9       	ldi	r26, 0x9C	; 156
    780e:	b5 e4       	ldi	r27, 0x45	; 69
    7810:	8d 8f       	std	Y+29, r24	; 0x1d
    7812:	9e 8f       	std	Y+30, r25	; 0x1e
    7814:	af 8f       	std	Y+31, r26	; 0x1f
    7816:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7818:	6d 8d       	ldd	r22, Y+29	; 0x1d
    781a:	7e 8d       	ldd	r23, Y+30	; 0x1e
    781c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    781e:	98 a1       	lds	r25, 0x48
    7820:	20 e0       	ldi	r18, 0x00	; 0
    7822:	30 e0       	ldi	r19, 0x00	; 0
    7824:	4a ef       	ldi	r20, 0xFA	; 250
    7826:	55 e4       	ldi	r21, 0x45	; 69
    7828:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    782c:	dc 01       	movw	r26, r24
    782e:	cb 01       	movw	r24, r22
    7830:	89 a3       	lds	r24, 0x59
    7832:	9a a3       	lds	r25, 0x5a
    7834:	ab a3       	lds	r26, 0x5b
    7836:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7838:	11 e0       	ldi	r17, 0x01	; 1
    783a:	69 a1       	lds	r22, 0x49
    783c:	7a a1       	lds	r23, 0x4a
    783e:	8b a1       	lds	r24, 0x4b
    7840:	9c a1       	lds	r25, 0x4c
    7842:	20 e0       	ldi	r18, 0x00	; 0
    7844:	30 e0       	ldi	r19, 0x00	; 0
    7846:	40 e8       	ldi	r20, 0x80	; 128
    7848:	5f e3       	ldi	r21, 0x3F	; 63
    784a:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    784e:	88 23       	and	r24, r24
    7850:	0c f0       	brlt	.+2      	; 0x7854 <checkMote+0x282>
    7852:	10 e0       	ldi	r17, 0x00	; 0
    7854:	11 23       	and	r17, r17
    7856:	29 f0       	breq	.+10     	; 0x7862 <checkMote+0x290>
		__ticks = 1;
    7858:	81 e0       	ldi	r24, 0x01	; 1
    785a:	90 e0       	ldi	r25, 0x00	; 0
    785c:	8d a3       	lds	r24, 0x5d
    785e:	9e a3       	lds	r25, 0x5e
    7860:	46 c0       	rjmp	.+140    	; 0x78ee <checkMote+0x31c>
	else if (__tmp > 65535)
    7862:	11 e0       	ldi	r17, 0x01	; 1
    7864:	69 a1       	lds	r22, 0x49
    7866:	7a a1       	lds	r23, 0x4a
    7868:	8b a1       	lds	r24, 0x4b
    786a:	9c a1       	lds	r25, 0x4c
    786c:	20 e0       	ldi	r18, 0x00	; 0
    786e:	3f ef       	ldi	r19, 0xFF	; 255
    7870:	4f e7       	ldi	r20, 0x7F	; 127
    7872:	57 e4       	ldi	r21, 0x47	; 71
    7874:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    7878:	18 16       	cp	r1, r24
    787a:	0c f0       	brlt	.+2      	; 0x787e <checkMote+0x2ac>
    787c:	10 e0       	ldi	r17, 0x00	; 0
    787e:	11 23       	and	r17, r17
    7880:	61 f1       	breq	.+88     	; 0x78da <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7882:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7884:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7886:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7888:	98 a1       	lds	r25, 0x48
    788a:	20 e0       	ldi	r18, 0x00	; 0
    788c:	30 e0       	ldi	r19, 0x00	; 0
    788e:	40 e2       	ldi	r20, 0x20	; 32
    7890:	51 e4       	ldi	r21, 0x41	; 65
    7892:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    7896:	dc 01       	movw	r26, r24
    7898:	cb 01       	movw	r24, r22
    789a:	bc 01       	movw	r22, r24
    789c:	cd 01       	movw	r24, r26
    789e:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    78a2:	dc 01       	movw	r26, r24
    78a4:	cb 01       	movw	r24, r22
    78a6:	8d a3       	lds	r24, 0x5d
    78a8:	9e a3       	lds	r25, 0x5e
    78aa:	12 c0       	rjmp	.+36     	; 0x78d0 <checkMote+0x2fe>
    78ac:	80 e2       	ldi	r24, 0x20	; 32
    78ae:	93 e0       	ldi	r25, 0x03	; 3
    78b0:	8f a3       	lds	r24, 0x5f
    78b2:	98 a7       	lds	r25, 0x78
    78b4:	8f a1       	lds	r24, 0x4f
    78b6:	98 a5       	lds	r25, 0x68
    78b8:	8c 01       	movw	r16, r24
    78ba:	c8 01       	movw	r24, r16
    78bc:	01 97       	sbiw	r24, 0x01	; 1
    78be:	f1 f7       	brne	.-4      	; 0x78bc <checkMote+0x2ea>
    78c0:	8c 01       	movw	r16, r24
    78c2:	0f a3       	lds	r16, 0x5f
    78c4:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    78c6:	8d a1       	lds	r24, 0x4d
    78c8:	9e a1       	lds	r25, 0x4e
    78ca:	01 97       	sbiw	r24, 0x01	; 1
    78cc:	8d a3       	lds	r24, 0x5d
    78ce:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    78d0:	8d a1       	lds	r24, 0x4d
    78d2:	9e a1       	lds	r25, 0x4e
    78d4:	00 97       	sbiw	r24, 0x00	; 0
    78d6:	51 f7       	brne	.-44     	; 0x78ac <checkMote+0x2da>
    78d8:	18 c0       	rjmp	.+48     	; 0x790a <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    78da:	69 a1       	lds	r22, 0x49
    78dc:	7a a1       	lds	r23, 0x4a
    78de:	8b a1       	lds	r24, 0x4b
    78e0:	9c a1       	lds	r25, 0x4c
    78e2:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    78e6:	dc 01       	movw	r26, r24
    78e8:	cb 01       	movw	r24, r22
    78ea:	8d a3       	lds	r24, 0x5d
    78ec:	9e a3       	lds	r25, 0x5e
    78ee:	8d a1       	lds	r24, 0x4d
    78f0:	9e a1       	lds	r25, 0x4e
    78f2:	89 a7       	lds	r24, 0x79
    78f4:	9a a7       	lds	r25, 0x7a
    78f6:	89 a5       	lds	r24, 0x69
    78f8:	9a a5       	lds	r25, 0x6a
    78fa:	8c 01       	movw	r16, r24
    78fc:	c8 01       	movw	r24, r16
    78fe:	01 97       	sbiw	r24, 0x01	; 1
    7900:	f1 f7       	brne	.-4      	; 0x78fe <checkMote+0x32c>
    7902:	8c 01       	movw	r16, r24
    7904:	09 a7       	lds	r16, 0x79
    7906:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7908:	f7 ce       	rjmp	.-530    	; 0x76f8 <checkMote+0x126>
    790a:	f6 ce       	rjmp	.-532    	; 0x76f8 <checkMote+0x126>

0000790c <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    790c:	cf 93       	push	r28
    790e:	df 93       	push	r29
    7910:	cd b7       	in	r28, 0x3d	; 61
    7912:	de b7       	in	r29, 0x3e	; 62
    7914:	28 97       	sbiw	r28, 0x08	; 8
    7916:	cd bf       	out	0x3d, r28	; 61
    7918:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    791a:	19 82       	std	Y+1, r1	; 0x01
    791c:	1a 82       	std	Y+2, r1	; 0x02
    791e:	0c c0       	rjmp	.+24     	; 0x7938 <SD_write_and_read_knowns+0x2c>
    7920:	29 81       	ldd	r18, Y+1	; 0x01
    7922:	89 81       	ldd	r24, Y+1	; 0x01
    7924:	9a 81       	ldd	r25, Y+2	; 0x02
    7926:	84 53       	subi	r24, 0x34	; 52
    7928:	9c 4d       	sbci	r25, 0xDC	; 220
    792a:	fc 01       	movw	r30, r24
    792c:	20 83       	st	Z, r18
    792e:	89 81       	ldd	r24, Y+1	; 0x01
    7930:	9a 81       	ldd	r25, Y+2	; 0x02
    7932:	01 96       	adiw	r24, 0x01	; 1
    7934:	89 83       	std	Y+1, r24	; 0x01
    7936:	9a 83       	std	Y+2, r25	; 0x02
    7938:	89 81       	ldd	r24, Y+1	; 0x01
    793a:	9a 81       	ldd	r25, Y+2	; 0x02
    793c:	88 31       	cpi	r24, 0x18	; 24
    793e:	91 05       	cpc	r25, r1
    7940:	7c f3       	brlt	.-34     	; 0x7920 <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7942:	2c ec       	ldi	r18, 0xCC	; 204
    7944:	33 e2       	ldi	r19, 0x23	; 35
    7946:	64 e1       	ldi	r22, 0x14	; 20
    7948:	70 e0       	ldi	r23, 0x00	; 0
    794a:	80 e0       	ldi	r24, 0x00	; 0
    794c:	90 e0       	ldi	r25, 0x00	; 0
    794e:	a9 01       	movw	r20, r18
    7950:	28 e1       	ldi	r18, 0x18	; 24
    7952:	30 e0       	ldi	r19, 0x00	; 0
    7954:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7958:	1b 82       	std	Y+3, r1	; 0x03
    795a:	1c 82       	std	Y+4, r1	; 0x04
    795c:	0b c0       	rjmp	.+22     	; 0x7974 <SD_write_and_read_knowns+0x68>
    795e:	8b 81       	ldd	r24, Y+3	; 0x03
    7960:	9c 81       	ldd	r25, Y+4	; 0x04
    7962:	84 53       	subi	r24, 0x34	; 52
    7964:	9c 4d       	sbci	r25, 0xDC	; 220
    7966:	fc 01       	movw	r30, r24
    7968:	10 82       	st	Z, r1
    796a:	8b 81       	ldd	r24, Y+3	; 0x03
    796c:	9c 81       	ldd	r25, Y+4	; 0x04
    796e:	01 96       	adiw	r24, 0x01	; 1
    7970:	8b 83       	std	Y+3, r24	; 0x03
    7972:	9c 83       	std	Y+4, r25	; 0x04
    7974:	8b 81       	ldd	r24, Y+3	; 0x03
    7976:	9c 81       	ldd	r25, Y+4	; 0x04
    7978:	88 31       	cpi	r24, 0x18	; 24
    797a:	91 05       	cpc	r25, r1
    797c:	84 f3       	brlt	.-32     	; 0x795e <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    797e:	2c ec       	ldi	r18, 0xCC	; 204
    7980:	33 e2       	ldi	r19, 0x23	; 35
    7982:	64 e1       	ldi	r22, 0x14	; 20
    7984:	70 e0       	ldi	r23, 0x00	; 0
    7986:	80 e0       	ldi	r24, 0x00	; 0
    7988:	90 e0       	ldi	r25, 0x00	; 0
    798a:	a9 01       	movw	r20, r18
    798c:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7990:	1d 82       	std	Y+5, r1	; 0x05
    7992:	1e 82       	std	Y+6, r1	; 0x06
    7994:	13 c0       	rjmp	.+38     	; 0x79bc <SD_write_and_read_knowns+0xb0>
    7996:	8d 81       	ldd	r24, Y+5	; 0x05
    7998:	9e 81       	ldd	r25, Y+6	; 0x06
    799a:	24 e6       	ldi	r18, 0x64	; 100
    799c:	30 e0       	ldi	r19, 0x00	; 0
    799e:	b9 01       	movw	r22, r18
    79a0:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    79a4:	28 2f       	mov	r18, r24
    79a6:	8d 81       	ldd	r24, Y+5	; 0x05
    79a8:	9e 81       	ldd	r25, Y+6	; 0x06
    79aa:	84 53       	subi	r24, 0x34	; 52
    79ac:	9c 4d       	sbci	r25, 0xDC	; 220
    79ae:	fc 01       	movw	r30, r24
    79b0:	20 83       	st	Z, r18
    79b2:	8d 81       	ldd	r24, Y+5	; 0x05
    79b4:	9e 81       	ldd	r25, Y+6	; 0x06
    79b6:	01 96       	adiw	r24, 0x01	; 1
    79b8:	8d 83       	std	Y+5, r24	; 0x05
    79ba:	9e 83       	std	Y+6, r25	; 0x06
    79bc:	8d 81       	ldd	r24, Y+5	; 0x05
    79be:	9e 81       	ldd	r25, Y+6	; 0x06
    79c0:	f4 e0       	ldi	r31, 0x04	; 4
    79c2:	82 3e       	cpi	r24, 0xE2	; 226
    79c4:	9f 07       	cpc	r25, r31
    79c6:	3c f3       	brlt	.-50     	; 0x7996 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    79c8:	2c ec       	ldi	r18, 0xCC	; 204
    79ca:	33 e2       	ldi	r19, 0x23	; 35
    79cc:	60 e5       	ldi	r22, 0x50	; 80
    79ce:	70 e0       	ldi	r23, 0x00	; 0
    79d0:	80 e0       	ldi	r24, 0x00	; 0
    79d2:	90 e0       	ldi	r25, 0x00	; 0
    79d4:	a9 01       	movw	r20, r18
    79d6:	22 ee       	ldi	r18, 0xE2	; 226
    79d8:	34 e0       	ldi	r19, 0x04	; 4
    79da:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    79de:	1f 82       	std	Y+7, r1	; 0x07
    79e0:	18 86       	std	Y+8, r1	; 0x08
    79e2:	0b c0       	rjmp	.+22     	; 0x79fa <SD_write_and_read_knowns+0xee>
    79e4:	8f 81       	ldd	r24, Y+7	; 0x07
    79e6:	98 85       	ldd	r25, Y+8	; 0x08
    79e8:	84 53       	subi	r24, 0x34	; 52
    79ea:	9c 4d       	sbci	r25, 0xDC	; 220
    79ec:	fc 01       	movw	r30, r24
    79ee:	10 82       	st	Z, r1
    79f0:	8f 81       	ldd	r24, Y+7	; 0x07
    79f2:	98 85       	ldd	r25, Y+8	; 0x08
    79f4:	01 96       	adiw	r24, 0x01	; 1
    79f6:	8f 83       	std	Y+7, r24	; 0x07
    79f8:	98 87       	std	Y+8, r25	; 0x08
    79fa:	8f 81       	ldd	r24, Y+7	; 0x07
    79fc:	98 85       	ldd	r25, Y+8	; 0x08
    79fe:	f4 e0       	ldi	r31, 0x04	; 4
    7a00:	82 3e       	cpi	r24, 0xE2	; 226
    7a02:	9f 07       	cpc	r25, r31
    7a04:	7c f3       	brlt	.-34     	; 0x79e4 <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7a06:	2c ec       	ldi	r18, 0xCC	; 204
    7a08:	33 e2       	ldi	r19, 0x23	; 35
    7a0a:	60 e5       	ldi	r22, 0x50	; 80
    7a0c:	70 e0       	ldi	r23, 0x00	; 0
    7a0e:	80 e0       	ldi	r24, 0x00	; 0
    7a10:	90 e0       	ldi	r25, 0x00	; 0
    7a12:	a9 01       	movw	r20, r18
    7a14:	23 e0       	ldi	r18, 0x03	; 3
    7a16:	30 e0       	ldi	r19, 0x00	; 0
    7a18:	0e 94 c0 4f 	call	0x9f80	; 0x9f80 <SD_read_multiple_blocks>
}
    7a1c:	28 96       	adiw	r28, 0x08	; 8
    7a1e:	cd bf       	out	0x3d, r28	; 61
    7a20:	de bf       	out	0x3e, r29	; 62
    7a22:	df 91       	pop	r29
    7a24:	cf 91       	pop	r28
    7a26:	08 95       	ret

00007a28 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7a28:	cf 93       	push	r28
    7a2a:	df 93       	push	r29
    7a2c:	00 d0       	rcall	.+0      	; 0x7a2e <SD_write_and_read_knowns_FAT+0x6>
    7a2e:	0f 92       	push	r0
    7a30:	cd b7       	in	r28, 0x3d	; 61
    7a32:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7a34:	19 82       	std	Y+1, r1	; 0x01
    7a36:	1a 82       	std	Y+2, r1	; 0x02
    7a38:	0c c0       	rjmp	.+24     	; 0x7a52 <SD_write_and_read_knowns_FAT+0x2a>
    7a3a:	29 81       	ldd	r18, Y+1	; 0x01
    7a3c:	89 81       	ldd	r24, Y+1	; 0x01
    7a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    7a40:	84 53       	subi	r24, 0x34	; 52
    7a42:	9c 4d       	sbci	r25, 0xDC	; 220
    7a44:	fc 01       	movw	r30, r24
    7a46:	20 83       	st	Z, r18
    7a48:	89 81       	ldd	r24, Y+1	; 0x01
    7a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    7a4c:	01 96       	adiw	r24, 0x01	; 1
    7a4e:	89 83       	std	Y+1, r24	; 0x01
    7a50:	9a 83       	std	Y+2, r25	; 0x02
    7a52:	89 81       	ldd	r24, Y+1	; 0x01
    7a54:	9a 81       	ldd	r25, Y+2	; 0x02
    7a56:	88 31       	cpi	r24, 0x18	; 24
    7a58:	91 05       	cpc	r25, r1
    7a5a:	7c f3       	brlt	.-34     	; 0x7a3a <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",FRAMReadBuffer,512);
    7a5c:	89 e0       	ldi	r24, 0x09	; 9
    7a5e:	90 e2       	ldi	r25, 0x20	; 32
    7a60:	2c ec       	ldi	r18, 0xCC	; 204
    7a62:	33 e2       	ldi	r19, 0x23	; 35
    7a64:	b9 01       	movw	r22, r18
    7a66:	20 e0       	ldi	r18, 0x00	; 0
    7a68:	32 e0       	ldi	r19, 0x02	; 2
    7a6a:	40 e0       	ldi	r20, 0x00	; 0
    7a6c:	50 e0       	ldi	r21, 0x00	; 0
    7a6e:	0e 94 0c 45 	call	0x8a18	; 0x8a18 <writeFile>
    7a72:	80 93 98 50 	sts	0x5098, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7a76:	1b 82       	std	Y+3, r1	; 0x03
    7a78:	1c 82       	std	Y+4, r1	; 0x04
    7a7a:	0b c0       	rjmp	.+22     	; 0x7a92 <SD_write_and_read_knowns_FAT+0x6a>
    7a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    7a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    7a80:	84 53       	subi	r24, 0x34	; 52
    7a82:	9c 4d       	sbci	r25, 0xDC	; 220
    7a84:	fc 01       	movw	r30, r24
    7a86:	10 82       	st	Z, r1
    7a88:	8b 81       	ldd	r24, Y+3	; 0x03
    7a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    7a8c:	01 96       	adiw	r24, 0x01	; 1
    7a8e:	8b 83       	std	Y+3, r24	; 0x03
    7a90:	9c 83       	std	Y+4, r25	; 0x04
    7a92:	8b 81       	ldd	r24, Y+3	; 0x03
    7a94:	9c 81       	ldd	r25, Y+4	; 0x04
    7a96:	88 31       	cpi	r24, 0x18	; 24
    7a98:	91 05       	cpc	r25, r1
    7a9a:	84 f3       	brlt	.-32     	; 0x7a7c <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    7a9c:	29 e0       	ldi	r18, 0x09	; 9
    7a9e:	30 e2       	ldi	r19, 0x20	; 32
    7aa0:	80 e0       	ldi	r24, 0x00	; 0
    7aa2:	b9 01       	movw	r22, r18
    7aa4:	0e 94 27 43 	call	0x864e	; 0x864e <readFile>
    7aa8:	80 93 98 50 	sts	0x5098, r24
}
    7aac:	24 96       	adiw	r28, 0x04	; 4
    7aae:	cd bf       	out	0x3d, r28	; 61
    7ab0:	de bf       	out	0x3e, r29	; 62
    7ab2:	df 91       	pop	r29
    7ab4:	cf 91       	pop	r28
    7ab6:	08 95       	ret

00007ab8 <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    7ab8:	cf 93       	push	r28
    7aba:	df 93       	push	r29
    7abc:	cd b7       	in	r28, 0x3d	; 61
    7abe:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7ac0:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <chb_init>
	chb_set_short_addr(0x0002);
    7ac4:	82 e0       	ldi	r24, 0x02	; 2
    7ac6:	90 e0       	ldi	r25, 0x00	; 0
    7ac8:	0e 94 22 2b 	call	0x5644	; 0x5644 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7acc:	00 00       	nop
    7ace:	fe cf       	rjmp	.-4      	; 0x7acc <chibi_test_radio+0x14>

00007ad0 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    7ad0:	cf 93       	push	r28
    7ad2:	df 93       	push	r29
    7ad4:	0f 92       	push	r0
    7ad6:	0f 92       	push	r0
    7ad8:	cd b7       	in	r28, 0x3d	; 61
    7ada:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    7adc:	0e 94 77 4a 	call	0x94ee	; 0x94ee <SD_init>
	getBootSectorData();
    7ae0:	0e 94 77 3e 	call	0x7cee	; 0x7cee <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7ae4:	19 82       	std	Y+1, r1	; 0x01
    7ae6:	1a 82       	std	Y+2, r1	; 0x02
    7ae8:	13 c0       	rjmp	.+38     	; 0x7b10 <TestCard+0x40>
    7aea:	89 81       	ldd	r24, Y+1	; 0x01
    7aec:	9a 81       	ldd	r25, Y+2	; 0x02
    7aee:	29 e7       	ldi	r18, 0x79	; 121
    7af0:	30 e0       	ldi	r19, 0x00	; 0
    7af2:	b9 01       	movw	r22, r18
    7af4:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    7af8:	28 2f       	mov	r18, r24
    7afa:	89 81       	ldd	r24, Y+1	; 0x01
    7afc:	9a 81       	ldd	r25, Y+2	; 0x02
    7afe:	84 53       	subi	r24, 0x34	; 52
    7b00:	9c 4d       	sbci	r25, 0xDC	; 220
    7b02:	fc 01       	movw	r30, r24
    7b04:	20 83       	st	Z, r18
    7b06:	89 81       	ldd	r24, Y+1	; 0x01
    7b08:	9a 81       	ldd	r25, Y+2	; 0x02
    7b0a:	01 96       	adiw	r24, 0x01	; 1
    7b0c:	89 83       	std	Y+1, r24	; 0x01
    7b0e:	9a 83       	std	Y+2, r25	; 0x02
    7b10:	89 81       	ldd	r24, Y+1	; 0x01
    7b12:	9a 81       	ldd	r25, Y+2	; 0x02
    7b14:	f2 e0       	ldi	r31, 0x02	; 2
    7b16:	80 30       	cpi	r24, 0x00	; 0
    7b18:	9f 07       	cpc	r25, r31
    7b1a:	3c f3       	brlt	.-50     	; 0x7aea <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",FRAMReadBuffer,512);//}
    7b1c:	89 e0       	ldi	r24, 0x09	; 9
    7b1e:	90 e2       	ldi	r25, 0x20	; 32
    7b20:	2c ec       	ldi	r18, 0xCC	; 204
    7b22:	33 e2       	ldi	r19, 0x23	; 35
    7b24:	b9 01       	movw	r22, r18
    7b26:	20 e0       	ldi	r18, 0x00	; 0
    7b28:	32 e0       	ldi	r19, 0x02	; 2
    7b2a:	40 e0       	ldi	r20, 0x00	; 0
    7b2c:	50 e0       	ldi	r21, 0x00	; 0
    7b2e:	0e 94 0c 45 	call	0x8a18	; 0x8a18 <writeFile>
	nop();
    7b32:	00 00       	nop
}
    7b34:	0f 90       	pop	r0
    7b36:	0f 90       	pop	r0
    7b38:	df 91       	pop	r29
    7b3a:	cf 91       	pop	r28
    7b3c:	08 95       	ret

00007b3e <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    7b3e:	1f 92       	push	r1
    7b40:	0f 92       	push	r0
    7b42:	0f b6       	in	r0, 0x3f	; 63
    7b44:	0f 92       	push	r0
    7b46:	00 90 3b 00 	lds	r0, 0x003B
    7b4a:	0f 92       	push	r0
    7b4c:	11 24       	eor	r1, r1
    7b4e:	2f 93       	push	r18
    7b50:	3f 93       	push	r19
    7b52:	4f 93       	push	r20
    7b54:	5f 93       	push	r21
    7b56:	6f 93       	push	r22
    7b58:	7f 93       	push	r23
    7b5a:	8f 93       	push	r24
    7b5c:	9f 93       	push	r25
    7b5e:	af 93       	push	r26
    7b60:	bf 93       	push	r27
    7b62:	ef 93       	push	r30
    7b64:	ff 93       	push	r31
    7b66:	cf 93       	push	r28
    7b68:	df 93       	push	r29
    7b6a:	cd b7       	in	r28, 0x3d	; 61
    7b6c:	de b7       	in	r29, 0x3e	; 62
    7b6e:	c4 58       	subi	r28, 0x84	; 132
    7b70:	d0 40       	sbci	r29, 0x00	; 0
    7b72:	cd bf       	out	0x3d, r28	; 61
    7b74:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    7b76:	80 91 53 40 	lds	r24, 0x4053
    7b7a:	88 2f       	mov	r24, r24
    7b7c:	90 e0       	ldi	r25, 0x00	; 0
    7b7e:	81 30       	cpi	r24, 0x01	; 1
    7b80:	91 05       	cpc	r25, r1
    7b82:	29 f0       	breq	.+10     	; 0x7b8e <__vector_43+0x50>
    7b84:	82 30       	cpi	r24, 0x02	; 2
    7b86:	91 05       	cpc	r25, r1
    7b88:	09 f4       	brne	.+2      	; 0x7b8c <__vector_43+0x4e>
    7b8a:	73 c0       	rjmp	.+230    	; 0x7c72 <__vector_43+0x134>
    7b8c:	91 c0       	rjmp	.+290    	; 0x7cb0 <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    7b8e:	ce 01       	movw	r24, r28
    7b90:	05 96       	adiw	r24, 0x05	; 5
    7b92:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <chb_read>
			if(!strncmp(msg,"reset",5)){
    7b96:	ce 01       	movw	r24, r28
    7b98:	05 96       	adiw	r24, 0x05	; 5
    7b9a:	21 e1       	ldi	r18, 0x11	; 17
    7b9c:	30 e2       	ldi	r19, 0x20	; 32
    7b9e:	b9 01       	movw	r22, r18
    7ba0:	45 e0       	ldi	r20, 0x05	; 5
    7ba2:	50 e0       	ldi	r21, 0x00	; 0
    7ba4:	0e 94 85 62 	call	0xc50a	; 0xc50a <strncmp>
    7ba8:	00 97       	sbiw	r24, 0x00	; 0
    7baa:	51 f4       	brne	.+20     	; 0x7bc0 <__vector_43+0x82>
				MotesReadyToSynch++;
    7bac:	80 91 6d 50 	lds	r24, 0x506D
    7bb0:	90 91 6e 50 	lds	r25, 0x506E
    7bb4:	01 96       	adiw	r24, 0x01	; 1
    7bb6:	80 93 6d 50 	sts	0x506D, r24
    7bba:	90 93 6e 50 	sts	0x506E, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7bbe:	7a c0       	rjmp	.+244    	; 0x7cb4 <__vector_43+0x176>
			if(!strncmp(msg,"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    7bc0:	19 82       	std	Y+1, r1	; 0x01
    7bc2:	1a 82       	std	Y+2, r1	; 0x02
    7bc4:	1b 82       	std	Y+3, r1	; 0x03
    7bc6:	1c 82       	std	Y+4, r1	; 0x04
    7bc8:	1a c0       	rjmp	.+52     	; 0x7bfe <__vector_43+0xc0>
    7bca:	9e 01       	movw	r18, r28
    7bcc:	2b 5f       	subi	r18, 0xFB	; 251
    7bce:	3f 4f       	sbci	r19, 0xFF	; 255
    7bd0:	89 81       	ldd	r24, Y+1	; 0x01
    7bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    7bd4:	82 0f       	add	r24, r18
    7bd6:	93 1f       	adc	r25, r19
    7bd8:	fc 01       	movw	r30, r24
    7bda:	20 81       	ld	r18, Z
    7bdc:	89 81       	ldd	r24, Y+1	; 0x01
    7bde:	9a 81       	ldd	r25, Y+2	; 0x02
    7be0:	84 53       	subi	r24, 0x34	; 52
    7be2:	9c 4d       	sbci	r25, 0xDC	; 220
    7be4:	fc 01       	movw	r30, r24
    7be6:	20 83       	st	Z, r18
    7be8:	89 81       	ldd	r24, Y+1	; 0x01
    7bea:	9a 81       	ldd	r25, Y+2	; 0x02
    7bec:	ab 81       	ldd	r26, Y+3	; 0x03
    7bee:	bc 81       	ldd	r27, Y+4	; 0x04
    7bf0:	01 96       	adiw	r24, 0x01	; 1
    7bf2:	a1 1d       	adc	r26, r1
    7bf4:	b1 1d       	adc	r27, r1
    7bf6:	89 83       	std	Y+1, r24	; 0x01
    7bf8:	9a 83       	std	Y+2, r25	; 0x02
    7bfa:	ab 83       	std	Y+3, r26	; 0x03
    7bfc:	bc 83       	std	Y+4, r27	; 0x04
    7bfe:	89 81       	ldd	r24, Y+1	; 0x01
    7c00:	9a 81       	ldd	r25, Y+2	; 0x02
    7c02:	ab 81       	ldd	r26, Y+3	; 0x03
    7c04:	bc 81       	ldd	r27, Y+4	; 0x04
    7c06:	80 38       	cpi	r24, 0x80	; 128
    7c08:	91 05       	cpc	r25, r1
    7c0a:	a1 05       	cpc	r26, r1
    7c0c:	b1 05       	cpc	r27, r1
    7c0e:	e8 f2       	brcs	.-70     	; 0x7bca <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    7c10:	80 91 bf 50 	lds	r24, 0x50BF
    7c14:	90 91 c0 50 	lds	r25, 0x50C0
    7c18:	a0 91 c1 50 	lds	r26, 0x50C1
    7c1c:	b0 91 c2 50 	lds	r27, 0x50C2
    7c20:	80 58       	subi	r24, 0x80	; 128
    7c22:	9f 4f       	sbci	r25, 0xFF	; 255
    7c24:	af 4f       	sbci	r26, 0xFF	; 255
    7c26:	bf 4f       	sbci	r27, 0xFF	; 255
    7c28:	80 93 bf 50 	sts	0x50BF, r24
    7c2c:	90 93 c0 50 	sts	0x50C0, r25
    7c30:	a0 93 c1 50 	sts	0x50C1, r26
    7c34:	b0 93 c2 50 	sts	0x50C2, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    7c38:	80 91 bf 50 	lds	r24, 0x50BF
    7c3c:	90 91 c0 50 	lds	r25, 0x50C0
    7c40:	a0 91 c1 50 	lds	r26, 0x50C1
    7c44:	b0 91 c2 50 	lds	r27, 0x50C2
    7c48:	80 58       	subi	r24, 0x80	; 128
    7c4a:	9f 4f       	sbci	r25, 0xFF	; 255
    7c4c:	af 4f       	sbci	r26, 0xFF	; 255
    7c4e:	bf 4f       	sbci	r27, 0xFF	; 255
    7c50:	81 37       	cpi	r24, 0x71	; 113
    7c52:	fc e1       	ldi	r31, 0x1C	; 28
    7c54:	9f 07       	cpc	r25, r31
    7c56:	f0 e0       	ldi	r31, 0x00	; 0
    7c58:	af 07       	cpc	r26, r31
    7c5a:	f0 e0       	ldi	r31, 0x00	; 0
    7c5c:	bf 07       	cpc	r27, r31
    7c5e:	50 f1       	brcs	.+84     	; 0x7cb4 <__vector_43+0x176>
    7c60:	10 92 bf 50 	sts	0x50BF, r1
    7c64:	10 92 c0 50 	sts	0x50C0, r1
    7c68:	10 92 c1 50 	sts	0x50C1, r1
    7c6c:	10 92 c2 50 	sts	0x50C2, r1
			}			
			break;
    7c70:	21 c0       	rjmp	.+66     	; 0x7cb4 <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    7c72:	ce 01       	movw	r24, r28
    7c74:	05 96       	adiw	r24, 0x05	; 5
    7c76:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <chb_read>
			if(!strncmp(msg,"start sampling",14)){	//if basestation synch response message received, do the following
    7c7a:	ce 01       	movw	r24, r28
    7c7c:	05 96       	adiw	r24, 0x05	; 5
    7c7e:	27 e1       	ldi	r18, 0x17	; 23
    7c80:	30 e2       	ldi	r19, 0x20	; 32
    7c82:	b9 01       	movw	r22, r18
    7c84:	4e e0       	ldi	r20, 0x0E	; 14
    7c86:	50 e0       	ldi	r21, 0x00	; 0
    7c88:	0e 94 85 62 	call	0xc50a	; 0xc50a <strncmp>
    7c8c:	00 97       	sbiw	r24, 0x00	; 0
    7c8e:	a1 f4       	brne	.+40     	; 0x7cb8 <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    7c90:	83 e0       	ldi	r24, 0x03	; 3
    7c92:	80 93 53 40 	sts	0x4053, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    7c96:	80 e4       	ldi	r24, 0x40	; 64
    7c98:	99 e0       	ldi	r25, 0x09	; 9
    7c9a:	29 e0       	ldi	r18, 0x09	; 9
    7c9c:	fc 01       	movw	r30, r24
    7c9e:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    7ca0:	80 e4       	ldi	r24, 0x40	; 64
    7ca2:	98 e0       	ldi	r25, 0x08	; 8
    7ca4:	21 e0       	ldi	r18, 0x01	; 1
    7ca6:	fc 01       	movw	r30, r24
    7ca8:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    7caa:	0e 94 0e 0a 	call	0x141c	; 0x141c <ADC_Resume_Sampling>
			}
			break;
    7cae:	04 c0       	rjmp	.+8      	; 0x7cb8 <__vector_43+0x17a>
		default:
			break;
    7cb0:	00 00       	nop
    7cb2:	03 c0       	rjmp	.+6      	; 0x7cba <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7cb4:	00 00       	nop
    7cb6:	01 c0       	rjmp	.+2      	; 0x7cba <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    7cb8:	00 00       	nop
		default:
			break;
	}
    7cba:	cc 57       	subi	r28, 0x7C	; 124
    7cbc:	df 4f       	sbci	r29, 0xFF	; 255
    7cbe:	cd bf       	out	0x3d, r28	; 61
    7cc0:	de bf       	out	0x3e, r29	; 62
    7cc2:	df 91       	pop	r29
    7cc4:	cf 91       	pop	r28
    7cc6:	ff 91       	pop	r31
    7cc8:	ef 91       	pop	r30
    7cca:	bf 91       	pop	r27
    7ccc:	af 91       	pop	r26
    7cce:	9f 91       	pop	r25
    7cd0:	8f 91       	pop	r24
    7cd2:	7f 91       	pop	r23
    7cd4:	6f 91       	pop	r22
    7cd6:	5f 91       	pop	r21
    7cd8:	4f 91       	pop	r20
    7cda:	3f 91       	pop	r19
    7cdc:	2f 91       	pop	r18
    7cde:	0f 90       	pop	r0
    7ce0:	00 92 3b 00 	sts	0x003B, r0
    7ce4:	0f 90       	pop	r0
    7ce6:	0f be       	out	0x3f, r0	; 63
    7ce8:	0f 90       	pop	r0
    7cea:	1f 90       	pop	r1
    7cec:	18 95       	reti

00007cee <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    7cee:	ef 92       	push	r14
    7cf0:	ff 92       	push	r15
    7cf2:	0f 93       	push	r16
    7cf4:	1f 93       	push	r17
    7cf6:	cf 93       	push	r28
    7cf8:	df 93       	push	r29
    7cfa:	cd b7       	in	r28, 0x3d	; 61
    7cfc:	de b7       	in	r29, 0x3e	; 62
    7cfe:	2a 97       	sbiw	r28, 0x0a	; 10
    7d00:	cd bf       	out	0x3d, r28	; 61
    7d02:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    7d04:	10 92 72 50 	sts	0x5072, r1
    7d08:	10 92 73 50 	sts	0x5073, r1
    7d0c:	10 92 74 50 	sts	0x5074, r1
    7d10:	10 92 75 50 	sts	0x5075, r1

SD_read_block(0,SDBuffer);
    7d14:	23 ec       	ldi	r18, 0xC3	; 195
    7d16:	31 e2       	ldi	r19, 0x21	; 33
    7d18:	60 e0       	ldi	r22, 0x00	; 0
    7d1a:	70 e0       	ldi	r23, 0x00	; 0
    7d1c:	cb 01       	movw	r24, r22
    7d1e:	a9 01       	movw	r20, r18
    7d20:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    7d24:	83 ec       	ldi	r24, 0xC3	; 195
    7d26:	91 e2       	ldi	r25, 0x21	; 33
    7d28:	89 83       	std	Y+1, r24	; 0x01
    7d2a:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    7d2c:	89 81       	ldd	r24, Y+1	; 0x01
    7d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    7d30:	fc 01       	movw	r30, r24
    7d32:	80 81       	ld	r24, Z
    7d34:	89 3e       	cpi	r24, 0xE9	; 233
    7d36:	09 f4       	brne	.+2      	; 0x7d3a <getBootSectorData+0x4c>
    7d38:	4d c0       	rjmp	.+154    	; 0x7dd4 <getBootSectorData+0xe6>
    7d3a:	89 81       	ldd	r24, Y+1	; 0x01
    7d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    7d3e:	fc 01       	movw	r30, r24
    7d40:	80 81       	ld	r24, Z
    7d42:	8b 3e       	cpi	r24, 0xEB	; 235
    7d44:	09 f4       	brne	.+2      	; 0x7d48 <getBootSectorData+0x5a>
    7d46:	46 c0       	rjmp	.+140    	; 0x7dd4 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    7d48:	83 ec       	ldi	r24, 0xC3	; 195
    7d4a:	91 e2       	ldi	r25, 0x21	; 33
    7d4c:	8b 83       	std	Y+3, r24	; 0x03
    7d4e:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    7d50:	8b 81       	ldd	r24, Y+3	; 0x03
    7d52:	9c 81       	ldd	r25, Y+4	; 0x04
    7d54:	82 50       	subi	r24, 0x02	; 2
    7d56:	9e 4f       	sbci	r25, 0xFE	; 254
    7d58:	fc 01       	movw	r30, r24
    7d5a:	80 81       	ld	r24, Z
    7d5c:	91 81       	ldd	r25, Z+1	; 0x01
    7d5e:	fa ea       	ldi	r31, 0xAA	; 170
    7d60:	85 35       	cpi	r24, 0x55	; 85
    7d62:	9f 07       	cpc	r25, r31
    7d64:	11 f0       	breq	.+4      	; 0x7d6a <getBootSectorData+0x7c>
    7d66:	81 e0       	ldi	r24, 0x01	; 1
    7d68:	01 c1       	rjmp	.+514    	; 0x7f6c <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    7d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    7d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    7d6e:	82 54       	subi	r24, 0x42	; 66
    7d70:	9e 4f       	sbci	r25, 0xFE	; 254
    7d72:	8d 83       	std	Y+5, r24	; 0x05
    7d74:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    7d76:	8d 81       	ldd	r24, Y+5	; 0x05
    7d78:	9e 81       	ldd	r25, Y+6	; 0x06
    7d7a:	fc 01       	movw	r30, r24
    7d7c:	80 85       	ldd	r24, Z+8	; 0x08
    7d7e:	91 85       	ldd	r25, Z+9	; 0x09
    7d80:	a2 85       	ldd	r26, Z+10	; 0x0a
    7d82:	b3 85       	ldd	r27, Z+11	; 0x0b
    7d84:	80 93 72 50 	sts	0x5072, r24
    7d88:	90 93 73 50 	sts	0x5073, r25
    7d8c:	a0 93 74 50 	sts	0x5074, r26
    7d90:	b0 93 75 50 	sts	0x5075, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    7d94:	8d 81       	ldd	r24, Y+5	; 0x05
    7d96:	9e 81       	ldd	r25, Y+6	; 0x06
    7d98:	fc 01       	movw	r30, r24
    7d9a:	80 85       	ldd	r24, Z+8	; 0x08
    7d9c:	91 85       	ldd	r25, Z+9	; 0x09
    7d9e:	a2 85       	ldd	r26, Z+10	; 0x0a
    7da0:	b3 85       	ldd	r27, Z+11	; 0x0b
    7da2:	23 ec       	ldi	r18, 0xC3	; 195
    7da4:	31 e2       	ldi	r19, 0x21	; 33
    7da6:	bc 01       	movw	r22, r24
    7da8:	cd 01       	movw	r24, r26
    7daa:	a9 01       	movw	r20, r18
    7dac:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    7db0:	83 ec       	ldi	r24, 0xC3	; 195
    7db2:	91 e2       	ldi	r25, 0x21	; 33
    7db4:	89 83       	std	Y+1, r24	; 0x01
    7db6:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    7db8:	89 81       	ldd	r24, Y+1	; 0x01
    7dba:	9a 81       	ldd	r25, Y+2	; 0x02
    7dbc:	fc 01       	movw	r30, r24
    7dbe:	80 81       	ld	r24, Z
    7dc0:	89 3e       	cpi	r24, 0xE9	; 233
    7dc2:	41 f0       	breq	.+16     	; 0x7dd4 <getBootSectorData+0xe6>
    7dc4:	89 81       	ldd	r24, Y+1	; 0x01
    7dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    7dc8:	fc 01       	movw	r30, r24
    7dca:	80 81       	ld	r24, Z
    7dcc:	8b 3e       	cpi	r24, 0xEB	; 235
    7dce:	11 f0       	breq	.+4      	; 0x7dd4 <getBootSectorData+0xe6>
    7dd0:	81 e0       	ldi	r24, 0x01	; 1
    7dd2:	cc c0       	rjmp	.+408    	; 0x7f6c <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    7dd4:	89 81       	ldd	r24, Y+1	; 0x01
    7dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    7dd8:	fc 01       	movw	r30, r24
    7dda:	83 85       	ldd	r24, Z+11	; 0x0b
    7ddc:	94 85       	ldd	r25, Z+12	; 0x0c
    7dde:	80 93 41 40 	sts	0x4041, r24
    7de2:	90 93 42 40 	sts	0x4042, r25
sectorPerCluster = bpb->sectorPerCluster;
    7de6:	89 81       	ldd	r24, Y+1	; 0x01
    7de8:	9a 81       	ldd	r25, Y+2	; 0x02
    7dea:	fc 01       	movw	r30, r24
    7dec:	85 85       	ldd	r24, Z+13	; 0x0d
    7dee:	88 2f       	mov	r24, r24
    7df0:	90 e0       	ldi	r25, 0x00	; 0
    7df2:	80 93 70 50 	sts	0x5070, r24
    7df6:	90 93 71 50 	sts	0x5071, r25
reservedSectorCount = bpb->reservedSectorCount;
    7dfa:	89 81       	ldd	r24, Y+1	; 0x01
    7dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    7dfe:	fc 01       	movw	r30, r24
    7e00:	86 85       	ldd	r24, Z+14	; 0x0e
    7e02:	97 85       	ldd	r25, Z+15	; 0x0f
    7e04:	80 93 78 50 	sts	0x5078, r24
    7e08:	90 93 79 50 	sts	0x5079, r25
rootCluster = bpb->rootCluster;
    7e0c:	89 81       	ldd	r24, Y+1	; 0x01
    7e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    7e10:	fc 01       	movw	r30, r24
    7e12:	84 a5       	lds	r24, 0x64
    7e14:	95 a5       	lds	r25, 0x65
    7e16:	a6 a5       	lds	r26, 0x66
    7e18:	b7 a5       	lds	r27, 0x67
    7e1a:	80 93 54 40 	sts	0x4054, r24
    7e1e:	90 93 55 40 	sts	0x4055, r25
    7e22:	a0 93 56 40 	sts	0x4056, r26
    7e26:	b0 93 57 40 	sts	0x4057, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    7e2a:	89 81       	ldd	r24, Y+1	; 0x01
    7e2c:	9a 81       	ldd	r25, Y+2	; 0x02
    7e2e:	fc 01       	movw	r30, r24
    7e30:	24 8d       	ldd	r18, Z+28	; 0x1c
    7e32:	35 8d       	ldd	r19, Z+29	; 0x1d
    7e34:	46 8d       	ldd	r20, Z+30	; 0x1e
    7e36:	57 8d       	ldd	r21, Z+31	; 0x1f
    7e38:	80 91 78 50 	lds	r24, 0x5078
    7e3c:	90 91 79 50 	lds	r25, 0x5079
    7e40:	cc 01       	movw	r24, r24
    7e42:	a0 e0       	ldi	r26, 0x00	; 0
    7e44:	b0 e0       	ldi	r27, 0x00	; 0
    7e46:	79 01       	movw	r14, r18
    7e48:	8a 01       	movw	r16, r20
    7e4a:	e8 0e       	add	r14, r24
    7e4c:	f9 1e       	adc	r15, r25
    7e4e:	0a 1f       	adc	r16, r26
    7e50:	1b 1f       	adc	r17, r27
    7e52:	89 81       	ldd	r24, Y+1	; 0x01
    7e54:	9a 81       	ldd	r25, Y+2	; 0x02
    7e56:	fc 01       	movw	r30, r24
    7e58:	80 89       	ldd	r24, Z+16	; 0x10
    7e5a:	88 2f       	mov	r24, r24
    7e5c:	90 e0       	ldi	r25, 0x00	; 0
    7e5e:	a0 e0       	ldi	r26, 0x00	; 0
    7e60:	b0 e0       	ldi	r27, 0x00	; 0
    7e62:	29 81       	ldd	r18, Y+1	; 0x01
    7e64:	3a 81       	ldd	r19, Y+2	; 0x02
    7e66:	f9 01       	movw	r30, r18
    7e68:	24 a1       	lds	r18, 0x44
    7e6a:	35 a1       	lds	r19, 0x45
    7e6c:	46 a1       	lds	r20, 0x46
    7e6e:	57 a1       	lds	r21, 0x47
    7e70:	bc 01       	movw	r22, r24
    7e72:	cd 01       	movw	r24, r26
    7e74:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    7e78:	dc 01       	movw	r26, r24
    7e7a:	cb 01       	movw	r24, r22
    7e7c:	8e 0d       	add	r24, r14
    7e7e:	9f 1d       	adc	r25, r15
    7e80:	a0 1f       	adc	r26, r16
    7e82:	b1 1f       	adc	r27, r17
    7e84:	80 93 c8 23 	sts	0x23C8, r24
    7e88:	90 93 c9 23 	sts	0x23C9, r25
    7e8c:	a0 93 ca 23 	sts	0x23CA, r26
    7e90:	b0 93 cb 23 	sts	0x23CB, r27

dataSectors = bpb->totalSectors_F32
    7e94:	89 81       	ldd	r24, Y+1	; 0x01
    7e96:	9a 81       	ldd	r25, Y+2	; 0x02
    7e98:	fc 01       	movw	r30, r24
    7e9a:	20 a1       	lds	r18, 0x40
    7e9c:	31 a1       	lds	r19, 0x41
    7e9e:	42 a1       	lds	r20, 0x42
    7ea0:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    7ea2:	89 81       	ldd	r24, Y+1	; 0x01
    7ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    7ea6:	fc 01       	movw	r30, r24
    7ea8:	86 85       	ldd	r24, Z+14	; 0x0e
    7eaa:	97 85       	ldd	r25, Z+15	; 0x0f
    7eac:	cc 01       	movw	r24, r24
    7eae:	a0 e0       	ldi	r26, 0x00	; 0
    7eb0:	b0 e0       	ldi	r27, 0x00	; 0
    7eb2:	79 01       	movw	r14, r18
    7eb4:	8a 01       	movw	r16, r20
    7eb6:	e8 1a       	sub	r14, r24
    7eb8:	f9 0a       	sbc	r15, r25
    7eba:	0a 0b       	sbc	r16, r26
    7ebc:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    7ebe:	89 81       	ldd	r24, Y+1	; 0x01
    7ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    7ec2:	fc 01       	movw	r30, r24
    7ec4:	80 89       	ldd	r24, Z+16	; 0x10
    7ec6:	88 2f       	mov	r24, r24
    7ec8:	90 e0       	ldi	r25, 0x00	; 0
    7eca:	a0 e0       	ldi	r26, 0x00	; 0
    7ecc:	b0 e0       	ldi	r27, 0x00	; 0
    7ece:	29 81       	ldd	r18, Y+1	; 0x01
    7ed0:	3a 81       	ldd	r19, Y+2	; 0x02
    7ed2:	f9 01       	movw	r30, r18
    7ed4:	24 a1       	lds	r18, 0x44
    7ed6:	35 a1       	lds	r19, 0x45
    7ed8:	46 a1       	lds	r20, 0x46
    7eda:	57 a1       	lds	r21, 0x47
    7edc:	bc 01       	movw	r22, r24
    7ede:	cd 01       	movw	r24, r26
    7ee0:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    7ee4:	dc 01       	movw	r26, r24
    7ee6:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    7ee8:	a8 01       	movw	r20, r16
    7eea:	97 01       	movw	r18, r14
    7eec:	28 1b       	sub	r18, r24
    7eee:	39 0b       	sbc	r19, r25
    7ef0:	4a 0b       	sbc	r20, r26
    7ef2:	5b 0b       	sbc	r21, r27
    7ef4:	da 01       	movw	r26, r20
    7ef6:	c9 01       	movw	r24, r18
    7ef8:	8f 83       	std	Y+7, r24	; 0x07
    7efa:	98 87       	std	Y+8, r25	; 0x08
    7efc:	a9 87       	std	Y+9, r26	; 0x09
    7efe:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    7f00:	80 91 70 50 	lds	r24, 0x5070
    7f04:	90 91 71 50 	lds	r25, 0x5071
    7f08:	9c 01       	movw	r18, r24
    7f0a:	40 e0       	ldi	r20, 0x00	; 0
    7f0c:	50 e0       	ldi	r21, 0x00	; 0
    7f0e:	8f 81       	ldd	r24, Y+7	; 0x07
    7f10:	98 85       	ldd	r25, Y+8	; 0x08
    7f12:	a9 85       	ldd	r26, Y+9	; 0x09
    7f14:	ba 85       	ldd	r27, Y+10	; 0x0a
    7f16:	bc 01       	movw	r22, r24
    7f18:	cd 01       	movw	r24, r26
    7f1a:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    7f1e:	da 01       	movw	r26, r20
    7f20:	c9 01       	movw	r24, r18
    7f22:	80 93 4e 40 	sts	0x404E, r24
    7f26:	90 93 4f 40 	sts	0x404F, r25
    7f2a:	a0 93 50 40 	sts	0x4050, r26
    7f2e:	b0 93 51 40 	sts	0x4051, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    7f32:	81 e0       	ldi	r24, 0x01	; 1
    7f34:	60 e0       	ldi	r22, 0x00	; 0
    7f36:	20 e0       	ldi	r18, 0x00	; 0
    7f38:	30 e0       	ldi	r19, 0x00	; 0
    7f3a:	a9 01       	movw	r20, r18
    7f3c:	0e 94 9c 40 	call	0x8138	; 0x8138 <getSetFreeCluster>
    7f40:	9b 01       	movw	r18, r22
    7f42:	ac 01       	movw	r20, r24
    7f44:	80 91 4e 40 	lds	r24, 0x404E
    7f48:	90 91 4f 40 	lds	r25, 0x404F
    7f4c:	a0 91 50 40 	lds	r26, 0x4050
    7f50:	b0 91 51 40 	lds	r27, 0x4051
    7f54:	82 17       	cp	r24, r18
    7f56:	93 07       	cpc	r25, r19
    7f58:	a4 07       	cpc	r26, r20
    7f5a:	b5 07       	cpc	r27, r21
    7f5c:	18 f4       	brcc	.+6      	; 0x7f64 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    7f5e:	10 92 c4 50 	sts	0x50C4, r1
    7f62:	03 c0       	rjmp	.+6      	; 0x7f6a <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    7f64:	81 e0       	ldi	r24, 0x01	; 1
    7f66:	80 93 c4 50 	sts	0x50C4, r24
return 0;
    7f6a:	80 e0       	ldi	r24, 0x00	; 0
}
    7f6c:	2a 96       	adiw	r28, 0x0a	; 10
    7f6e:	cd bf       	out	0x3d, r28	; 61
    7f70:	de bf       	out	0x3e, r29	; 62
    7f72:	df 91       	pop	r29
    7f74:	cf 91       	pop	r28
    7f76:	1f 91       	pop	r17
    7f78:	0f 91       	pop	r16
    7f7a:	ff 90       	pop	r15
    7f7c:	ef 90       	pop	r14
    7f7e:	08 95       	ret

00007f80 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    7f80:	cf 93       	push	r28
    7f82:	df 93       	push	r29
    7f84:	00 d0       	rcall	.+0      	; 0x7f86 <getFirstSector+0x6>
    7f86:	0f 92       	push	r0
    7f88:	cd b7       	in	r28, 0x3d	; 61
    7f8a:	de b7       	in	r29, 0x3e	; 62
    7f8c:	69 83       	std	Y+1, r22	; 0x01
    7f8e:	7a 83       	std	Y+2, r23	; 0x02
    7f90:	8b 83       	std	Y+3, r24	; 0x03
    7f92:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    7f94:	89 81       	ldd	r24, Y+1	; 0x01
    7f96:	9a 81       	ldd	r25, Y+2	; 0x02
    7f98:	ab 81       	ldd	r26, Y+3	; 0x03
    7f9a:	bc 81       	ldd	r27, Y+4	; 0x04
    7f9c:	02 97       	sbiw	r24, 0x02	; 2
    7f9e:	a1 09       	sbc	r26, r1
    7fa0:	b1 09       	sbc	r27, r1
    7fa2:	20 91 70 50 	lds	r18, 0x5070
    7fa6:	30 91 71 50 	lds	r19, 0x5071
    7faa:	99 01       	movw	r18, r18
    7fac:	40 e0       	ldi	r20, 0x00	; 0
    7fae:	50 e0       	ldi	r21, 0x00	; 0
    7fb0:	bc 01       	movw	r22, r24
    7fb2:	cd 01       	movw	r24, r26
    7fb4:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    7fb8:	9b 01       	movw	r18, r22
    7fba:	ac 01       	movw	r20, r24
    7fbc:	80 91 c8 23 	lds	r24, 0x23C8
    7fc0:	90 91 c9 23 	lds	r25, 0x23C9
    7fc4:	a0 91 ca 23 	lds	r26, 0x23CA
    7fc8:	b0 91 cb 23 	lds	r27, 0x23CB
    7fcc:	82 0f       	add	r24, r18
    7fce:	93 1f       	adc	r25, r19
    7fd0:	a4 1f       	adc	r26, r20
    7fd2:	b5 1f       	adc	r27, r21
}
    7fd4:	bc 01       	movw	r22, r24
    7fd6:	cd 01       	movw	r24, r26
    7fd8:	24 96       	adiw	r28, 0x04	; 4
    7fda:	cd bf       	out	0x3d, r28	; 61
    7fdc:	de bf       	out	0x3e, r29	; 62
    7fde:	df 91       	pop	r29
    7fe0:	cf 91       	pop	r28
    7fe2:	08 95       	ret

00007fe4 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    7fe4:	ef 92       	push	r14
    7fe6:	ff 92       	push	r15
    7fe8:	0f 93       	push	r16
    7fea:	1f 93       	push	r17
    7fec:	cf 93       	push	r28
    7fee:	df 93       	push	r29
    7ff0:	cd b7       	in	r28, 0x3d	; 61
    7ff2:	de b7       	in	r29, 0x3e	; 62
    7ff4:	62 97       	sbiw	r28, 0x12	; 18
    7ff6:	cd bf       	out	0x3d, r28	; 61
    7ff8:	de bf       	out	0x3e, r29	; 62
    7ffa:	6a 87       	std	Y+10, r22	; 0x0a
    7ffc:	7b 87       	std	Y+11, r23	; 0x0b
    7ffe:	8c 87       	std	Y+12, r24	; 0x0c
    8000:	9d 87       	std	Y+13, r25	; 0x0d
    8002:	4e 87       	std	Y+14, r20	; 0x0e
    8004:	0f 87       	std	Y+15, r16	; 0x0f
    8006:	18 8b       	std	Y+16, r17	; 0x10
    8008:	29 8b       	std	Y+17, r18	; 0x11
    800a:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    800c:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    800e:	80 91 78 50 	lds	r24, 0x5078
    8012:	90 91 79 50 	lds	r25, 0x5079
    8016:	9c 01       	movw	r18, r24
    8018:	40 e0       	ldi	r20, 0x00	; 0
    801a:	50 e0       	ldi	r21, 0x00	; 0
    801c:	80 91 72 50 	lds	r24, 0x5072
    8020:	90 91 73 50 	lds	r25, 0x5073
    8024:	a0 91 74 50 	lds	r26, 0x5074
    8028:	b0 91 75 50 	lds	r27, 0x5075
    802c:	79 01       	movw	r14, r18
    802e:	8a 01       	movw	r16, r20
    8030:	e8 0e       	add	r14, r24
    8032:	f9 1e       	adc	r15, r25
    8034:	0a 1f       	adc	r16, r26
    8036:	1b 1f       	adc	r17, r27
    8038:	8a 85       	ldd	r24, Y+10	; 0x0a
    803a:	9b 85       	ldd	r25, Y+11	; 0x0b
    803c:	ac 85       	ldd	r26, Y+12	; 0x0c
    803e:	bd 85       	ldd	r27, Y+13	; 0x0d
    8040:	88 0f       	add	r24, r24
    8042:	99 1f       	adc	r25, r25
    8044:	aa 1f       	adc	r26, r26
    8046:	bb 1f       	adc	r27, r27
    8048:	88 0f       	add	r24, r24
    804a:	99 1f       	adc	r25, r25
    804c:	aa 1f       	adc	r26, r26
    804e:	bb 1f       	adc	r27, r27
    8050:	20 91 41 40 	lds	r18, 0x4041
    8054:	30 91 42 40 	lds	r19, 0x4042
    8058:	99 01       	movw	r18, r18
    805a:	40 e0       	ldi	r20, 0x00	; 0
    805c:	50 e0       	ldi	r21, 0x00	; 0
    805e:	bc 01       	movw	r22, r24
    8060:	cd 01       	movw	r24, r26
    8062:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    8066:	da 01       	movw	r26, r20
    8068:	c9 01       	movw	r24, r18
    806a:	8e 0d       	add	r24, r14
    806c:	9f 1d       	adc	r25, r15
    806e:	a0 1f       	adc	r26, r16
    8070:	b1 1f       	adc	r27, r17
    8072:	8a 83       	std	Y+2, r24	; 0x02
    8074:	9b 83       	std	Y+3, r25	; 0x03
    8076:	ac 83       	std	Y+4, r26	; 0x04
    8078:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    807a:	8a 85       	ldd	r24, Y+10	; 0x0a
    807c:	9b 85       	ldd	r25, Y+11	; 0x0b
    807e:	ac 85       	ldd	r26, Y+12	; 0x0c
    8080:	bd 85       	ldd	r27, Y+13	; 0x0d
    8082:	88 0f       	add	r24, r24
    8084:	99 1f       	adc	r25, r25
    8086:	aa 1f       	adc	r26, r26
    8088:	bb 1f       	adc	r27, r27
    808a:	88 0f       	add	r24, r24
    808c:	99 1f       	adc	r25, r25
    808e:	aa 1f       	adc	r26, r26
    8090:	bb 1f       	adc	r27, r27
    8092:	20 91 41 40 	lds	r18, 0x4041
    8096:	30 91 42 40 	lds	r19, 0x4042
    809a:	99 01       	movw	r18, r18
    809c:	40 e0       	ldi	r20, 0x00	; 0
    809e:	50 e0       	ldi	r21, 0x00	; 0
    80a0:	bc 01       	movw	r22, r24
    80a2:	cd 01       	movw	r24, r26
    80a4:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    80a8:	dc 01       	movw	r26, r24
    80aa:	cb 01       	movw	r24, r22
    80ac:	8e 83       	std	Y+6, r24	; 0x06
    80ae:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    80b0:	8a 81       	ldd	r24, Y+2	; 0x02
    80b2:	9b 81       	ldd	r25, Y+3	; 0x03
    80b4:	ac 81       	ldd	r26, Y+4	; 0x04
    80b6:	bd 81       	ldd	r27, Y+5	; 0x05
    80b8:	23 ec       	ldi	r18, 0xC3	; 195
    80ba:	31 e2       	ldi	r19, 0x21	; 33
    80bc:	bc 01       	movw	r22, r24
    80be:	cd 01       	movw	r24, r26
    80c0:	a9 01       	movw	r20, r18
    80c2:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    80c6:	8e 81       	ldd	r24, Y+6	; 0x06
    80c8:	9f 81       	ldd	r25, Y+7	; 0x07
    80ca:	8d 53       	subi	r24, 0x3D	; 61
    80cc:	9e 4d       	sbci	r25, 0xDE	; 222
    80ce:	88 87       	std	Y+8, r24	; 0x08
    80d0:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    80d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    80d4:	88 23       	and	r24, r24
    80d6:	49 f4       	brne	.+18     	; 0x80ea <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    80d8:	88 85       	ldd	r24, Y+8	; 0x08
    80da:	99 85       	ldd	r25, Y+9	; 0x09
    80dc:	fc 01       	movw	r30, r24
    80de:	80 81       	ld	r24, Z
    80e0:	91 81       	ldd	r25, Z+1	; 0x01
    80e2:	a2 81       	ldd	r26, Z+2	; 0x02
    80e4:	b3 81       	ldd	r27, Z+3	; 0x03
    80e6:	bf 70       	andi	r27, 0x0F	; 15
    80e8:	1b c0       	rjmp	.+54     	; 0x8120 <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    80ea:	28 85       	ldd	r18, Y+8	; 0x08
    80ec:	39 85       	ldd	r19, Y+9	; 0x09
    80ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    80f0:	98 89       	ldd	r25, Y+16	; 0x10
    80f2:	a9 89       	ldd	r26, Y+17	; 0x11
    80f4:	ba 89       	ldd	r27, Y+18	; 0x12
    80f6:	f9 01       	movw	r30, r18
    80f8:	80 83       	st	Z, r24
    80fa:	91 83       	std	Z+1, r25	; 0x01
    80fc:	a2 83       	std	Z+2, r26	; 0x02
    80fe:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    8100:	8a 81       	ldd	r24, Y+2	; 0x02
    8102:	9b 81       	ldd	r25, Y+3	; 0x03
    8104:	ac 81       	ldd	r26, Y+4	; 0x04
    8106:	bd 81       	ldd	r27, Y+5	; 0x05
    8108:	23 ec       	ldi	r18, 0xC3	; 195
    810a:	31 e2       	ldi	r19, 0x21	; 33
    810c:	bc 01       	movw	r22, r24
    810e:	cd 01       	movw	r24, r26
    8110:	a9 01       	movw	r20, r18
    8112:	20 e0       	ldi	r18, 0x00	; 0
    8114:	32 e0       	ldi	r19, 0x02	; 2
    8116:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <SD_write_block>

return (0);
    811a:	80 e0       	ldi	r24, 0x00	; 0
    811c:	90 e0       	ldi	r25, 0x00	; 0
    811e:	dc 01       	movw	r26, r24
}
    8120:	bc 01       	movw	r22, r24
    8122:	cd 01       	movw	r24, r26
    8124:	62 96       	adiw	r28, 0x12	; 18
    8126:	cd bf       	out	0x3d, r28	; 61
    8128:	de bf       	out	0x3e, r29	; 62
    812a:	df 91       	pop	r29
    812c:	cf 91       	pop	r28
    812e:	1f 91       	pop	r17
    8130:	0f 91       	pop	r16
    8132:	ff 90       	pop	r15
    8134:	ef 90       	pop	r14
    8136:	08 95       	ret

00008138 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    8138:	cf 93       	push	r28
    813a:	df 93       	push	r29
    813c:	cd b7       	in	r28, 0x3d	; 61
    813e:	de b7       	in	r29, 0x3e	; 62
    8140:	28 97       	sbiw	r28, 0x08	; 8
    8142:	cd bf       	out	0x3d, r28	; 61
    8144:	de bf       	out	0x3e, r29	; 62
    8146:	8b 83       	std	Y+3, r24	; 0x03
    8148:	6c 83       	std	Y+4, r22	; 0x04
    814a:	2d 83       	std	Y+5, r18	; 0x05
    814c:	3e 83       	std	Y+6, r19	; 0x06
    814e:	4f 83       	std	Y+7, r20	; 0x07
    8150:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    8152:	83 ec       	ldi	r24, 0xC3	; 195
    8154:	91 e2       	ldi	r25, 0x21	; 33
    8156:	89 83       	std	Y+1, r24	; 0x01
    8158:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    815a:	80 91 72 50 	lds	r24, 0x5072
    815e:	90 91 73 50 	lds	r25, 0x5073
    8162:	a0 91 74 50 	lds	r26, 0x5074
    8166:	b0 91 75 50 	lds	r27, 0x5075
    816a:	01 96       	adiw	r24, 0x01	; 1
    816c:	a1 1d       	adc	r26, r1
    816e:	b1 1d       	adc	r27, r1
    8170:	23 ec       	ldi	r18, 0xC3	; 195
    8172:	31 e2       	ldi	r19, 0x21	; 33
    8174:	bc 01       	movw	r22, r24
    8176:	cd 01       	movw	r24, r26
    8178:	a9 01       	movw	r20, r18
    817a:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    817e:	89 81       	ldd	r24, Y+1	; 0x01
    8180:	9a 81       	ldd	r25, Y+2	; 0x02
    8182:	fc 01       	movw	r30, r24
    8184:	80 81       	ld	r24, Z
    8186:	91 81       	ldd	r25, Z+1	; 0x01
    8188:	a2 81       	ldd	r26, Z+2	; 0x02
    818a:	b3 81       	ldd	r27, Z+3	; 0x03
    818c:	82 35       	cpi	r24, 0x52	; 82
    818e:	f2 e5       	ldi	r31, 0x52	; 82
    8190:	9f 07       	cpc	r25, r31
    8192:	f1 e6       	ldi	r31, 0x61	; 97
    8194:	af 07       	cpc	r26, r31
    8196:	f1 e4       	ldi	r31, 0x41	; 65
    8198:	bf 07       	cpc	r27, r31
    819a:	11 f5       	brne	.+68     	; 0x81e0 <getSetFreeCluster+0xa8>
    819c:	89 81       	ldd	r24, Y+1	; 0x01
    819e:	9a 81       	ldd	r25, Y+2	; 0x02
    81a0:	8c 51       	subi	r24, 0x1C	; 28
    81a2:	9e 4f       	sbci	r25, 0xFE	; 254
    81a4:	fc 01       	movw	r30, r24
    81a6:	80 81       	ld	r24, Z
    81a8:	91 81       	ldd	r25, Z+1	; 0x01
    81aa:	a2 81       	ldd	r26, Z+2	; 0x02
    81ac:	b3 81       	ldd	r27, Z+3	; 0x03
    81ae:	82 37       	cpi	r24, 0x72	; 114
    81b0:	f2 e7       	ldi	r31, 0x72	; 114
    81b2:	9f 07       	cpc	r25, r31
    81b4:	f1 e4       	ldi	r31, 0x41	; 65
    81b6:	af 07       	cpc	r26, r31
    81b8:	f1 e6       	ldi	r31, 0x61	; 97
    81ba:	bf 07       	cpc	r27, r31
    81bc:	89 f4       	brne	.+34     	; 0x81e0 <getSetFreeCluster+0xa8>
    81be:	89 81       	ldd	r24, Y+1	; 0x01
    81c0:	9a 81       	ldd	r25, Y+2	; 0x02
    81c2:	84 50       	subi	r24, 0x04	; 4
    81c4:	9e 4f       	sbci	r25, 0xFE	; 254
    81c6:	fc 01       	movw	r30, r24
    81c8:	80 81       	ld	r24, Z
    81ca:	91 81       	ldd	r25, Z+1	; 0x01
    81cc:	a2 81       	ldd	r26, Z+2	; 0x02
    81ce:	b3 81       	ldd	r27, Z+3	; 0x03
    81d0:	80 30       	cpi	r24, 0x00	; 0
    81d2:	f0 e0       	ldi	r31, 0x00	; 0
    81d4:	9f 07       	cpc	r25, r31
    81d6:	f5 e5       	ldi	r31, 0x55	; 85
    81d8:	af 07       	cpc	r26, r31
    81da:	fa ea       	ldi	r31, 0xAA	; 170
    81dc:	bf 07       	cpc	r27, r31
    81de:	21 f0       	breq	.+8      	; 0x81e8 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    81e0:	8f ef       	ldi	r24, 0xFF	; 255
    81e2:	9f ef       	ldi	r25, 0xFF	; 255
    81e4:	dc 01       	movw	r26, r24
    81e6:	51 c0       	rjmp	.+162    	; 0x828a <getSetFreeCluster+0x152>

 if(get_set == GET)
    81e8:	8c 81       	ldd	r24, Y+4	; 0x04
    81ea:	88 23       	and	r24, r24
    81ec:	b9 f4       	brne	.+46     	; 0x821c <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    81ee:	8b 81       	ldd	r24, Y+3	; 0x03
    81f0:	81 30       	cpi	r24, 0x01	; 1
    81f2:	51 f4       	brne	.+20     	; 0x8208 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    81f4:	89 81       	ldd	r24, Y+1	; 0x01
    81f6:	9a 81       	ldd	r25, Y+2	; 0x02
    81f8:	88 51       	subi	r24, 0x18	; 24
    81fa:	9e 4f       	sbci	r25, 0xFE	; 254
    81fc:	fc 01       	movw	r30, r24
    81fe:	80 81       	ld	r24, Z
    8200:	91 81       	ldd	r25, Z+1	; 0x01
    8202:	a2 81       	ldd	r26, Z+2	; 0x02
    8204:	b3 81       	ldd	r27, Z+3	; 0x03
    8206:	41 c0       	rjmp	.+130    	; 0x828a <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    8208:	89 81       	ldd	r24, Y+1	; 0x01
    820a:	9a 81       	ldd	r25, Y+2	; 0x02
    820c:	84 51       	subi	r24, 0x14	; 20
    820e:	9e 4f       	sbci	r25, 0xFE	; 254
    8210:	fc 01       	movw	r30, r24
    8212:	80 81       	ld	r24, Z
    8214:	91 81       	ldd	r25, Z+1	; 0x01
    8216:	a2 81       	ldd	r26, Z+2	; 0x02
    8218:	b3 81       	ldd	r27, Z+3	; 0x03
    821a:	37 c0       	rjmp	.+110    	; 0x828a <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    821c:	8b 81       	ldd	r24, Y+3	; 0x03
    821e:	81 30       	cpi	r24, 0x01	; 1
    8220:	79 f4       	brne	.+30     	; 0x8240 <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    8222:	89 81       	ldd	r24, Y+1	; 0x01
    8224:	9a 81       	ldd	r25, Y+2	; 0x02
    8226:	9c 01       	movw	r18, r24
    8228:	28 51       	subi	r18, 0x18	; 24
    822a:	3e 4f       	sbci	r19, 0xFE	; 254
    822c:	8d 81       	ldd	r24, Y+5	; 0x05
    822e:	9e 81       	ldd	r25, Y+6	; 0x06
    8230:	af 81       	ldd	r26, Y+7	; 0x07
    8232:	b8 85       	ldd	r27, Y+8	; 0x08
    8234:	f9 01       	movw	r30, r18
    8236:	80 83       	st	Z, r24
    8238:	91 83       	std	Z+1, r25	; 0x01
    823a:	a2 83       	std	Z+2, r26	; 0x02
    823c:	b3 83       	std	Z+3, r27	; 0x03
    823e:	0e c0       	rjmp	.+28     	; 0x825c <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    8240:	89 81       	ldd	r24, Y+1	; 0x01
    8242:	9a 81       	ldd	r25, Y+2	; 0x02
    8244:	9c 01       	movw	r18, r24
    8246:	24 51       	subi	r18, 0x14	; 20
    8248:	3e 4f       	sbci	r19, 0xFE	; 254
    824a:	8d 81       	ldd	r24, Y+5	; 0x05
    824c:	9e 81       	ldd	r25, Y+6	; 0x06
    824e:	af 81       	ldd	r26, Y+7	; 0x07
    8250:	b8 85       	ldd	r27, Y+8	; 0x08
    8252:	f9 01       	movw	r30, r18
    8254:	80 83       	st	Z, r24
    8256:	91 83       	std	Z+1, r25	; 0x01
    8258:	a2 83       	std	Z+2, r26	; 0x02
    825a:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    825c:	80 91 72 50 	lds	r24, 0x5072
    8260:	90 91 73 50 	lds	r25, 0x5073
    8264:	a0 91 74 50 	lds	r26, 0x5074
    8268:	b0 91 75 50 	lds	r27, 0x5075
    826c:	01 96       	adiw	r24, 0x01	; 1
    826e:	a1 1d       	adc	r26, r1
    8270:	b1 1d       	adc	r27, r1
    8272:	23 ec       	ldi	r18, 0xC3	; 195
    8274:	31 e2       	ldi	r19, 0x21	; 33
    8276:	bc 01       	movw	r22, r24
    8278:	cd 01       	movw	r24, r26
    827a:	a9 01       	movw	r20, r18
    827c:	20 e0       	ldi	r18, 0x00	; 0
    827e:	32 e0       	ldi	r19, 0x02	; 2
    8280:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <SD_write_block>
 }
 return 0xffffffff;
    8284:	8f ef       	ldi	r24, 0xFF	; 255
    8286:	9f ef       	ldi	r25, 0xFF	; 255
    8288:	dc 01       	movw	r26, r24
}
    828a:	bc 01       	movw	r22, r24
    828c:	cd 01       	movw	r24, r26
    828e:	28 96       	adiw	r28, 0x08	; 8
    8290:	cd bf       	out	0x3d, r28	; 61
    8292:	de bf       	out	0x3e, r29	; 62
    8294:	df 91       	pop	r29
    8296:	cf 91       	pop	r28
    8298:	08 95       	ret

0000829a <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    829a:	0f 93       	push	r16
    829c:	1f 93       	push	r17
    829e:	cf 93       	push	r28
    82a0:	df 93       	push	r29
    82a2:	cd b7       	in	r28, 0x3d	; 61
    82a4:	de b7       	in	r29, 0x3e	; 62
    82a6:	6c 97       	sbiw	r28, 0x1c	; 28
    82a8:	cd bf       	out	0x3d, r28	; 61
    82aa:	de bf       	out	0x3e, r29	; 62
    82ac:	8a 8f       	std	Y+26, r24	; 0x1a
    82ae:	6b 8f       	std	Y+27, r22	; 0x1b
    82b0:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    82b2:	80 91 54 40 	lds	r24, 0x4054
    82b6:	90 91 55 40 	lds	r25, 0x4055
    82ba:	a0 91 56 40 	lds	r26, 0x4056
    82be:	b0 91 57 40 	lds	r27, 0x4057
    82c2:	89 83       	std	Y+1, r24	; 0x01
    82c4:	9a 83       	std	Y+2, r25	; 0x02
    82c6:	ab 83       	std	Y+3, r26	; 0x03
    82c8:	bc 83       	std	Y+4, r27	; 0x04
    82ca:	01 c0       	rjmp	.+2      	; 0x82ce <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    82cc:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    82ce:	89 81       	ldd	r24, Y+1	; 0x01
    82d0:	9a 81       	ldd	r25, Y+2	; 0x02
    82d2:	ab 81       	ldd	r26, Y+3	; 0x03
    82d4:	bc 81       	ldd	r27, Y+4	; 0x04
    82d6:	bc 01       	movw	r22, r24
    82d8:	cd 01       	movw	r24, r26
    82da:	0e 94 c0 3f 	call	0x7f80	; 0x7f80 <getFirstSector>
    82de:	dc 01       	movw	r26, r24
    82e0:	cb 01       	movw	r24, r22
    82e2:	88 8b       	std	Y+16, r24	; 0x10
    82e4:	99 8b       	std	Y+17, r25	; 0x11
    82e6:	aa 8b       	std	Y+18, r26	; 0x12
    82e8:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    82ea:	1d 82       	std	Y+5, r1	; 0x05
    82ec:	1e 82       	std	Y+6, r1	; 0x06
    82ee:	1f 82       	std	Y+7, r1	; 0x07
    82f0:	18 86       	std	Y+8, r1	; 0x08
    82f2:	68 c1       	rjmp	.+720    	; 0x85c4 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    82f4:	28 89       	ldd	r18, Y+16	; 0x10
    82f6:	39 89       	ldd	r19, Y+17	; 0x11
    82f8:	4a 89       	ldd	r20, Y+18	; 0x12
    82fa:	5b 89       	ldd	r21, Y+19	; 0x13
    82fc:	8d 81       	ldd	r24, Y+5	; 0x05
    82fe:	9e 81       	ldd	r25, Y+6	; 0x06
    8300:	af 81       	ldd	r26, Y+7	; 0x07
    8302:	b8 85       	ldd	r27, Y+8	; 0x08
    8304:	82 0f       	add	r24, r18
    8306:	93 1f       	adc	r25, r19
    8308:	a4 1f       	adc	r26, r20
    830a:	b5 1f       	adc	r27, r21
    830c:	23 ec       	ldi	r18, 0xC3	; 195
    830e:	31 e2       	ldi	r19, 0x21	; 33
    8310:	bc 01       	movw	r22, r24
    8312:	cd 01       	movw	r24, r26
    8314:	a9 01       	movw	r20, r18
    8316:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    831a:	1d 86       	std	Y+13, r1	; 0x0d
    831c:	1e 86       	std	Y+14, r1	; 0x0e
    831e:	3d c1       	rjmp	.+634    	; 0x859a <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    8320:	8d 85       	ldd	r24, Y+13	; 0x0d
    8322:	9e 85       	ldd	r25, Y+14	; 0x0e
    8324:	8d 53       	subi	r24, 0x3D	; 61
    8326:	9e 4d       	sbci	r25, 0xDE	; 222
    8328:	8c 8b       	std	Y+20, r24	; 0x14
    832a:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    832c:	8c 89       	ldd	r24, Y+20	; 0x14
    832e:	9d 89       	ldd	r25, Y+21	; 0x15
    8330:	fc 01       	movw	r30, r24
    8332:	80 81       	ld	r24, Z
    8334:	88 23       	and	r24, r24
    8336:	19 f4       	brne	.+6      	; 0x833e <findFiles+0xa4>
		{
		  return 0;   
    8338:	80 e0       	ldi	r24, 0x00	; 0
    833a:	90 e0       	ldi	r25, 0x00	; 0
    833c:	80 c1       	rjmp	.+768    	; 0x863e <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    833e:	8c 89       	ldd	r24, Y+20	; 0x14
    8340:	9d 89       	ldd	r25, Y+21	; 0x15
    8342:	fc 01       	movw	r30, r24
    8344:	80 81       	ld	r24, Z
    8346:	85 3e       	cpi	r24, 0xE5	; 229
    8348:	09 f4       	brne	.+2      	; 0x834c <findFiles+0xb2>
    834a:	22 c1       	rjmp	.+580    	; 0x8590 <findFiles+0x2f6>
    834c:	8c 89       	ldd	r24, Y+20	; 0x14
    834e:	9d 89       	ldd	r25, Y+21	; 0x15
    8350:	fc 01       	movw	r30, r24
    8352:	83 85       	ldd	r24, Z+11	; 0x0b
    8354:	8f 30       	cpi	r24, 0x0F	; 15
    8356:	09 f4       	brne	.+2      	; 0x835a <findFiles+0xc0>
    8358:	1b c1       	rjmp	.+566    	; 0x8590 <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    835a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    835c:	81 30       	cpi	r24, 0x01	; 1
    835e:	21 f0       	breq	.+8      	; 0x8368 <findFiles+0xce>
    8360:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8362:	82 30       	cpi	r24, 0x02	; 2
    8364:	09 f0       	breq	.+2      	; 0x8368 <findFiles+0xce>
    8366:	11 c1       	rjmp	.+546    	; 0x858a <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8368:	1f 86       	std	Y+15, r1	; 0x0f
    836a:	17 c0       	rjmp	.+46     	; 0x839a <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    836c:	8f 85       	ldd	r24, Y+15	; 0x0f
    836e:	88 2f       	mov	r24, r24
    8370:	90 e0       	ldi	r25, 0x00	; 0
    8372:	2c 89       	ldd	r18, Y+20	; 0x14
    8374:	3d 89       	ldd	r19, Y+21	; 0x15
    8376:	82 0f       	add	r24, r18
    8378:	93 1f       	adc	r25, r19
    837a:	fc 01       	movw	r30, r24
    837c:	40 81       	ld	r20, Z
    837e:	8f 85       	ldd	r24, Y+15	; 0x0f
    8380:	88 2f       	mov	r24, r24
    8382:	90 e0       	ldi	r25, 0x00	; 0
    8384:	2b 8d       	ldd	r18, Y+27	; 0x1b
    8386:	3c 8d       	ldd	r19, Y+28	; 0x1c
    8388:	82 0f       	add	r24, r18
    838a:	93 1f       	adc	r25, r19
    838c:	fc 01       	movw	r30, r24
    838e:	80 81       	ld	r24, Z
    8390:	48 17       	cp	r20, r24
    8392:	39 f4       	brne	.+14     	; 0x83a2 <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    8394:	8f 85       	ldd	r24, Y+15	; 0x0f
    8396:	8f 5f       	subi	r24, 0xFF	; 255
    8398:	8f 87       	std	Y+15, r24	; 0x0f
    839a:	8f 85       	ldd	r24, Y+15	; 0x0f
    839c:	8b 30       	cpi	r24, 0x0B	; 11
    839e:	30 f3       	brcs	.-52     	; 0x836c <findFiles+0xd2>
    83a0:	01 c0       	rjmp	.+2      	; 0x83a4 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    83a2:	00 00       	nop
            if(j == 11)
    83a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    83a6:	8b 30       	cpi	r24, 0x0B	; 11
    83a8:	09 f0       	breq	.+2      	; 0x83ac <findFiles+0x112>
    83aa:	f2 c0       	rjmp	.+484    	; 0x8590 <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    83ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    83ae:	81 30       	cpi	r24, 0x01	; 1
    83b0:	09 f0       	breq	.+2      	; 0x83b4 <findFiles+0x11a>
    83b2:	52 c0       	rjmp	.+164    	; 0x8458 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    83b4:	28 89       	ldd	r18, Y+16	; 0x10
    83b6:	39 89       	ldd	r19, Y+17	; 0x11
    83b8:	4a 89       	ldd	r20, Y+18	; 0x12
    83ba:	5b 89       	ldd	r21, Y+19	; 0x13
    83bc:	8d 81       	ldd	r24, Y+5	; 0x05
    83be:	9e 81       	ldd	r25, Y+6	; 0x06
    83c0:	af 81       	ldd	r26, Y+7	; 0x07
    83c2:	b8 85       	ldd	r27, Y+8	; 0x08
    83c4:	82 0f       	add	r24, r18
    83c6:	93 1f       	adc	r25, r19
    83c8:	a4 1f       	adc	r26, r20
    83ca:	b5 1f       	adc	r27, r21
    83cc:	80 93 c6 50 	sts	0x50C6, r24
    83d0:	90 93 c7 50 	sts	0x50C7, r25
    83d4:	a0 93 c8 50 	sts	0x50C8, r26
    83d8:	b0 93 c9 50 	sts	0x50C9, r27
				appendFileLocation = i;
    83dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    83de:	9e 85       	ldd	r25, Y+14	; 0x0e
    83e0:	cc 01       	movw	r24, r24
    83e2:	a0 e0       	ldi	r26, 0x00	; 0
    83e4:	b0 e0       	ldi	r27, 0x00	; 0
    83e6:	80 93 c4 23 	sts	0x23C4, r24
    83ea:	90 93 c5 23 	sts	0x23C5, r25
    83ee:	a0 93 c6 23 	sts	0x23C6, r26
    83f2:	b0 93 c7 23 	sts	0x23C7, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    83f6:	8c 89       	ldd	r24, Y+20	; 0x14
    83f8:	9d 89       	ldd	r25, Y+21	; 0x15
    83fa:	fc 01       	movw	r30, r24
    83fc:	84 89       	ldd	r24, Z+20	; 0x14
    83fe:	95 89       	ldd	r25, Z+21	; 0x15
    8400:	cc 01       	movw	r24, r24
    8402:	a0 e0       	ldi	r26, 0x00	; 0
    8404:	b0 e0       	ldi	r27, 0x00	; 0
    8406:	ac 01       	movw	r20, r24
    8408:	33 27       	eor	r19, r19
    840a:	22 27       	eor	r18, r18
    840c:	8c 89       	ldd	r24, Y+20	; 0x14
    840e:	9d 89       	ldd	r25, Y+21	; 0x15
    8410:	fc 01       	movw	r30, r24
    8412:	82 8d       	ldd	r24, Z+26	; 0x1a
    8414:	93 8d       	ldd	r25, Z+27	; 0x1b
    8416:	cc 01       	movw	r24, r24
    8418:	a0 e0       	ldi	r26, 0x00	; 0
    841a:	b0 e0       	ldi	r27, 0x00	; 0
    841c:	82 2b       	or	r24, r18
    841e:	93 2b       	or	r25, r19
    8420:	a4 2b       	or	r26, r20
    8422:	b5 2b       	or	r27, r21
    8424:	80 93 7c 50 	sts	0x507C, r24
    8428:	90 93 7d 50 	sts	0x507D, r25
    842c:	a0 93 7e 50 	sts	0x507E, r26
    8430:	b0 93 7f 50 	sts	0x507F, r27
				fileSize = dir->fileSize;
    8434:	8c 89       	ldd	r24, Y+20	; 0x14
    8436:	9d 89       	ldd	r25, Y+21	; 0x15
    8438:	fc 01       	movw	r30, r24
    843a:	84 8d       	ldd	r24, Z+28	; 0x1c
    843c:	95 8d       	ldd	r25, Z+29	; 0x1d
    843e:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8440:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8442:	80 93 3d 40 	sts	0x403D, r24
    8446:	90 93 3e 40 	sts	0x403E, r25
    844a:	a0 93 3f 40 	sts	0x403F, r26
    844e:	b0 93 40 40 	sts	0x4040, r27
			    return (dir);
    8452:	8c 89       	ldd	r24, Y+20	; 0x14
    8454:	9d 89       	ldd	r25, Y+21	; 0x15
    8456:	f3 c0       	rjmp	.+486    	; 0x863e <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8458:	8c 89       	ldd	r24, Y+20	; 0x14
    845a:	9d 89       	ldd	r25, Y+21	; 0x15
    845c:	fc 01       	movw	r30, r24
    845e:	84 89       	ldd	r24, Z+20	; 0x14
    8460:	95 89       	ldd	r25, Z+21	; 0x15
    8462:	cc 01       	movw	r24, r24
    8464:	a0 e0       	ldi	r26, 0x00	; 0
    8466:	b0 e0       	ldi	r27, 0x00	; 0
    8468:	ac 01       	movw	r20, r24
    846a:	33 27       	eor	r19, r19
    846c:	22 27       	eor	r18, r18
    846e:	8c 89       	ldd	r24, Y+20	; 0x14
    8470:	9d 89       	ldd	r25, Y+21	; 0x15
    8472:	fc 01       	movw	r30, r24
    8474:	82 8d       	ldd	r24, Z+26	; 0x1a
    8476:	93 8d       	ldd	r25, Z+27	; 0x1b
    8478:	cc 01       	movw	r24, r24
    847a:	a0 e0       	ldi	r26, 0x00	; 0
    847c:	b0 e0       	ldi	r27, 0x00	; 0
    847e:	82 2b       	or	r24, r18
    8480:	93 2b       	or	r25, r19
    8482:	a4 2b       	or	r26, r20
    8484:	b5 2b       	or	r27, r21
    8486:	89 87       	std	Y+9, r24	; 0x09
    8488:	9a 87       	std	Y+10, r25	; 0x0a
    848a:	ab 87       	std	Y+11, r26	; 0x0b
    848c:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    848e:	8c 89       	ldd	r24, Y+20	; 0x14
    8490:	9d 89       	ldd	r25, Y+21	; 0x15
    8492:	25 ee       	ldi	r18, 0xE5	; 229
    8494:	fc 01       	movw	r30, r24
    8496:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8498:	28 89       	ldd	r18, Y+16	; 0x10
    849a:	39 89       	ldd	r19, Y+17	; 0x11
    849c:	4a 89       	ldd	r20, Y+18	; 0x12
    849e:	5b 89       	ldd	r21, Y+19	; 0x13
    84a0:	8d 81       	ldd	r24, Y+5	; 0x05
    84a2:	9e 81       	ldd	r25, Y+6	; 0x06
    84a4:	af 81       	ldd	r26, Y+7	; 0x07
    84a6:	b8 85       	ldd	r27, Y+8	; 0x08
    84a8:	82 0f       	add	r24, r18
    84aa:	93 1f       	adc	r25, r19
    84ac:	a4 1f       	adc	r26, r20
    84ae:	b5 1f       	adc	r27, r21
    84b0:	23 ec       	ldi	r18, 0xC3	; 195
    84b2:	31 e2       	ldi	r19, 0x21	; 33
    84b4:	bc 01       	movw	r22, r24
    84b6:	cd 01       	movw	r24, r26
    84b8:	a9 01       	movw	r20, r18
    84ba:	20 e0       	ldi	r18, 0x00	; 0
    84bc:	32 e0       	ldi	r19, 0x02	; 2
    84be:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    84c2:	8c 89       	ldd	r24, Y+20	; 0x14
    84c4:	9d 89       	ldd	r25, Y+21	; 0x15
    84c6:	fc 01       	movw	r30, r24
    84c8:	24 8d       	ldd	r18, Z+28	; 0x1c
    84ca:	35 8d       	ldd	r19, Z+29	; 0x1d
    84cc:	46 8d       	ldd	r20, Z+30	; 0x1e
    84ce:	57 8d       	ldd	r21, Z+31	; 0x1f
    84d0:	80 e0       	ldi	r24, 0x00	; 0
    84d2:	ba 01       	movw	r22, r20
    84d4:	a9 01       	movw	r20, r18
    84d6:	0e 94 bb 49 	call	0x9376	; 0x9376 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    84da:	82 e0       	ldi	r24, 0x02	; 2
    84dc:	60 e0       	ldi	r22, 0x00	; 0
    84de:	20 e0       	ldi	r18, 0x00	; 0
    84e0:	30 e0       	ldi	r19, 0x00	; 0
    84e2:	a9 01       	movw	r20, r18
    84e4:	0e 94 9c 40 	call	0x8138	; 0x8138 <getSetFreeCluster>
    84e8:	dc 01       	movw	r26, r24
    84ea:	cb 01       	movw	r24, r22
    84ec:	89 83       	std	Y+1, r24	; 0x01
    84ee:	9a 83       	std	Y+2, r25	; 0x02
    84f0:	ab 83       	std	Y+3, r26	; 0x03
    84f2:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    84f4:	29 85       	ldd	r18, Y+9	; 0x09
    84f6:	3a 85       	ldd	r19, Y+10	; 0x0a
    84f8:	4b 85       	ldd	r20, Y+11	; 0x0b
    84fa:	5c 85       	ldd	r21, Y+12	; 0x0c
    84fc:	89 81       	ldd	r24, Y+1	; 0x01
    84fe:	9a 81       	ldd	r25, Y+2	; 0x02
    8500:	ab 81       	ldd	r26, Y+3	; 0x03
    8502:	bc 81       	ldd	r27, Y+4	; 0x04
    8504:	28 17       	cp	r18, r24
    8506:	39 07       	cpc	r19, r25
    8508:	4a 07       	cpc	r20, r26
    850a:	5b 07       	cpc	r21, r27
    850c:	40 f4       	brcc	.+16     	; 0x851e <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    850e:	29 85       	ldd	r18, Y+9	; 0x09
    8510:	3a 85       	ldd	r19, Y+10	; 0x0a
    8512:	4b 85       	ldd	r20, Y+11	; 0x0b
    8514:	5c 85       	ldd	r21, Y+12	; 0x0c
    8516:	82 e0       	ldi	r24, 0x02	; 2
    8518:	61 e0       	ldi	r22, 0x01	; 1
    851a:	0e 94 9c 40 	call	0x8138	; 0x8138 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    851e:	89 85       	ldd	r24, Y+9	; 0x09
    8520:	9a 85       	ldd	r25, Y+10	; 0x0a
    8522:	ab 85       	ldd	r26, Y+11	; 0x0b
    8524:	bc 85       	ldd	r27, Y+12	; 0x0c
    8526:	bc 01       	movw	r22, r24
    8528:	cd 01       	movw	r24, r26
    852a:	40 e0       	ldi	r20, 0x00	; 0
    852c:	00 e0       	ldi	r16, 0x00	; 0
    852e:	10 e0       	ldi	r17, 0x00	; 0
    8530:	98 01       	movw	r18, r16
    8532:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
    8536:	dc 01       	movw	r26, r24
    8538:	cb 01       	movw	r24, r22
    853a:	8e 8b       	std	Y+22, r24	; 0x16
    853c:	9f 8b       	std	Y+23, r25	; 0x17
    853e:	a8 8f       	std	Y+24, r26	; 0x18
    8540:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8542:	89 85       	ldd	r24, Y+9	; 0x09
    8544:	9a 85       	ldd	r25, Y+10	; 0x0a
    8546:	ab 85       	ldd	r26, Y+11	; 0x0b
    8548:	bc 85       	ldd	r27, Y+12	; 0x0c
    854a:	bc 01       	movw	r22, r24
    854c:	cd 01       	movw	r24, r26
    854e:	41 e0       	ldi	r20, 0x01	; 1
    8550:	00 e0       	ldi	r16, 0x00	; 0
    8552:	10 e0       	ldi	r17, 0x00	; 0
    8554:	98 01       	movw	r18, r16
    8556:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    855a:	8e 89       	ldd	r24, Y+22	; 0x16
    855c:	9f 89       	ldd	r25, Y+23	; 0x17
    855e:	a8 8d       	ldd	r26, Y+24	; 0x18
    8560:	b9 8d       	ldd	r27, Y+25	; 0x19
    8562:	87 3f       	cpi	r24, 0xF7	; 247
    8564:	ff ef       	ldi	r31, 0xFF	; 255
    8566:	9f 07       	cpc	r25, r31
    8568:	ff ef       	ldi	r31, 0xFF	; 255
    856a:	af 07       	cpc	r26, r31
    856c:	ff e0       	ldi	r31, 0x0F	; 15
    856e:	bf 07       	cpc	r27, r31
    8570:	18 f0       	brcs	.+6      	; 0x8578 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    8572:	80 e0       	ldi	r24, 0x00	; 0
    8574:	90 e0       	ldi	r25, 0x00	; 0
    8576:	63 c0       	rjmp	.+198    	; 0x863e <findFiles+0x3a4>
					firstCluster = nextCluster;
    8578:	8e 89       	ldd	r24, Y+22	; 0x16
    857a:	9f 89       	ldd	r25, Y+23	; 0x17
    857c:	a8 8d       	ldd	r26, Y+24	; 0x18
    857e:	b9 8d       	ldd	r27, Y+25	; 0x19
    8580:	89 87       	std	Y+9, r24	; 0x09
    8582:	9a 87       	std	Y+10, r25	; 0x0a
    8584:	ab 87       	std	Y+11, r26	; 0x0b
    8586:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8588:	ca cf       	rjmp	.-108    	; 0x851e <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    858a:	80 e0       	ldi	r24, 0x00	; 0
    858c:	90 e0       	ldi	r25, 0x00	; 0
    858e:	57 c0       	rjmp	.+174    	; 0x863e <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8590:	8d 85       	ldd	r24, Y+13	; 0x0d
    8592:	9e 85       	ldd	r25, Y+14	; 0x0e
    8594:	80 96       	adiw	r24, 0x20	; 32
    8596:	8d 87       	std	Y+13, r24	; 0x0d
    8598:	9e 87       	std	Y+14, r25	; 0x0e
    859a:	80 91 41 40 	lds	r24, 0x4041
    859e:	90 91 42 40 	lds	r25, 0x4042
    85a2:	2d 85       	ldd	r18, Y+13	; 0x0d
    85a4:	3e 85       	ldd	r19, Y+14	; 0x0e
    85a6:	28 17       	cp	r18, r24
    85a8:	39 07       	cpc	r19, r25
    85aa:	08 f4       	brcc	.+2      	; 0x85ae <findFiles+0x314>
    85ac:	b9 ce       	rjmp	.-654    	; 0x8320 <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    85ae:	8d 81       	ldd	r24, Y+5	; 0x05
    85b0:	9e 81       	ldd	r25, Y+6	; 0x06
    85b2:	af 81       	ldd	r26, Y+7	; 0x07
    85b4:	b8 85       	ldd	r27, Y+8	; 0x08
    85b6:	01 96       	adiw	r24, 0x01	; 1
    85b8:	a1 1d       	adc	r26, r1
    85ba:	b1 1d       	adc	r27, r1
    85bc:	8d 83       	std	Y+5, r24	; 0x05
    85be:	9e 83       	std	Y+6, r25	; 0x06
    85c0:	af 83       	std	Y+7, r26	; 0x07
    85c2:	b8 87       	std	Y+8, r27	; 0x08
    85c4:	80 91 70 50 	lds	r24, 0x5070
    85c8:	90 91 71 50 	lds	r25, 0x5071
    85cc:	9c 01       	movw	r18, r24
    85ce:	40 e0       	ldi	r20, 0x00	; 0
    85d0:	50 e0       	ldi	r21, 0x00	; 0
    85d2:	8d 81       	ldd	r24, Y+5	; 0x05
    85d4:	9e 81       	ldd	r25, Y+6	; 0x06
    85d6:	af 81       	ldd	r26, Y+7	; 0x07
    85d8:	b8 85       	ldd	r27, Y+8	; 0x08
    85da:	82 17       	cp	r24, r18
    85dc:	93 07       	cpc	r25, r19
    85de:	a4 07       	cpc	r26, r20
    85e0:	b5 07       	cpc	r27, r21
    85e2:	08 f4       	brcc	.+2      	; 0x85e6 <findFiles+0x34c>
    85e4:	87 ce       	rjmp	.-754    	; 0x82f4 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    85e6:	89 81       	ldd	r24, Y+1	; 0x01
    85e8:	9a 81       	ldd	r25, Y+2	; 0x02
    85ea:	ab 81       	ldd	r26, Y+3	; 0x03
    85ec:	bc 81       	ldd	r27, Y+4	; 0x04
    85ee:	bc 01       	movw	r22, r24
    85f0:	cd 01       	movw	r24, r26
    85f2:	40 e0       	ldi	r20, 0x00	; 0
    85f4:	00 e0       	ldi	r16, 0x00	; 0
    85f6:	10 e0       	ldi	r17, 0x00	; 0
    85f8:	98 01       	movw	r18, r16
    85fa:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
    85fe:	dc 01       	movw	r26, r24
    8600:	cb 01       	movw	r24, r22
    8602:	89 83       	std	Y+1, r24	; 0x01
    8604:	9a 83       	std	Y+2, r25	; 0x02
    8606:	ab 83       	std	Y+3, r26	; 0x03
    8608:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    860a:	89 81       	ldd	r24, Y+1	; 0x01
    860c:	9a 81       	ldd	r25, Y+2	; 0x02
    860e:	ab 81       	ldd	r26, Y+3	; 0x03
    8610:	bc 81       	ldd	r27, Y+4	; 0x04
    8612:	87 3f       	cpi	r24, 0xF7	; 247
    8614:	2f ef       	ldi	r18, 0xFF	; 255
    8616:	92 07       	cpc	r25, r18
    8618:	2f ef       	ldi	r18, 0xFF	; 255
    861a:	a2 07       	cpc	r26, r18
    861c:	2f e0       	ldi	r18, 0x0F	; 15
    861e:	b2 07       	cpc	r27, r18
    8620:	18 f0       	brcs	.+6      	; 0x8628 <findFiles+0x38e>
   	 return 0;
    8622:	80 e0       	ldi	r24, 0x00	; 0
    8624:	90 e0       	ldi	r25, 0x00	; 0
    8626:	0b c0       	rjmp	.+22     	; 0x863e <findFiles+0x3a4>
   if(cluster == 0) 
    8628:	89 81       	ldd	r24, Y+1	; 0x01
    862a:	9a 81       	ldd	r25, Y+2	; 0x02
    862c:	ab 81       	ldd	r26, Y+3	; 0x03
    862e:	bc 81       	ldd	r27, Y+4	; 0x04
    8630:	00 97       	sbiw	r24, 0x00	; 0
    8632:	a1 05       	cpc	r26, r1
    8634:	b1 05       	cpc	r27, r1
    8636:	09 f0       	breq	.+2      	; 0x863a <findFiles+0x3a0>
    8638:	49 ce       	rjmp	.-878    	; 0x82cc <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    863a:	80 e0       	ldi	r24, 0x00	; 0
    863c:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    863e:	6c 96       	adiw	r28, 0x1c	; 28
    8640:	cd bf       	out	0x3d, r28	; 61
    8642:	de bf       	out	0x3e, r29	; 62
    8644:	df 91       	pop	r29
    8646:	cf 91       	pop	r28
    8648:	1f 91       	pop	r17
    864a:	0f 91       	pop	r16
    864c:	08 95       	ret

0000864e <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    864e:	0f 93       	push	r16
    8650:	1f 93       	push	r17
    8652:	cf 93       	push	r28
    8654:	df 93       	push	r29
    8656:	cd b7       	in	r28, 0x3d	; 61
    8658:	de b7       	in	r29, 0x3e	; 62
    865a:	67 97       	sbiw	r28, 0x17	; 23
    865c:	cd bf       	out	0x3d, r28	; 61
    865e:	de bf       	out	0x3e, r29	; 62
    8660:	8d 8b       	std	Y+21, r24	; 0x15
    8662:	6e 8b       	std	Y+22, r22	; 0x16
    8664:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8666:	1e 82       	std	Y+6, r1	; 0x06
    8668:	1f 82       	std	Y+7, r1	; 0x07
    866a:	18 86       	std	Y+8, r1	; 0x08
    866c:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    866e:	8e 89       	ldd	r24, Y+22	; 0x16
    8670:	9f 89       	ldd	r25, Y+23	; 0x17
    8672:	0e 94 d6 43 	call	0x87ac	; 0x87ac <convertFileName>
    8676:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8678:	8a 85       	ldd	r24, Y+10	; 0x0a
    867a:	88 23       	and	r24, r24
    867c:	11 f0       	breq	.+4      	; 0x8682 <readFile+0x34>
    867e:	82 e0       	ldi	r24, 0x02	; 2
    8680:	8d c0       	rjmp	.+282    	; 0x879c <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    8682:	20 eb       	ldi	r18, 0xB0	; 176
    8684:	30 e5       	ldi	r19, 0x50	; 80
    8686:	81 e0       	ldi	r24, 0x01	; 1
    8688:	b9 01       	movw	r22, r18
    868a:	0e 94 4d 41 	call	0x829a	; 0x829a <findFiles>
    868e:	8b 87       	std	Y+11, r24	; 0x0b
    8690:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    8692:	8b 85       	ldd	r24, Y+11	; 0x0b
    8694:	9c 85       	ldd	r25, Y+12	; 0x0c
    8696:	00 97       	sbiw	r24, 0x00	; 0
    8698:	39 f4       	brne	.+14     	; 0x86a8 <readFile+0x5a>
{
  if(flag == READ) return (1);
    869a:	8d 89       	ldd	r24, Y+21	; 0x15
    869c:	88 23       	and	r24, r24
    869e:	11 f4       	brne	.+4      	; 0x86a4 <readFile+0x56>
    86a0:	81 e0       	ldi	r24, 0x01	; 1
    86a2:	7c c0       	rjmp	.+248    	; 0x879c <readFile+0x14e>
  else return (0);
    86a4:	80 e0       	ldi	r24, 0x00	; 0
    86a6:	7a c0       	rjmp	.+244    	; 0x879c <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    86a8:	8d 89       	ldd	r24, Y+21	; 0x15
    86aa:	81 30       	cpi	r24, 0x01	; 1
    86ac:	11 f4       	brne	.+4      	; 0x86b2 <readFile+0x64>
    86ae:	81 e0       	ldi	r24, 0x01	; 1
    86b0:	75 c0       	rjmp	.+234    	; 0x879c <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    86b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    86b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    86b6:	fc 01       	movw	r30, r24
    86b8:	84 89       	ldd	r24, Z+20	; 0x14
    86ba:	95 89       	ldd	r25, Z+21	; 0x15
    86bc:	cc 01       	movw	r24, r24
    86be:	a0 e0       	ldi	r26, 0x00	; 0
    86c0:	b0 e0       	ldi	r27, 0x00	; 0
    86c2:	ac 01       	movw	r20, r24
    86c4:	33 27       	eor	r19, r19
    86c6:	22 27       	eor	r18, r18
    86c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    86ca:	9c 85       	ldd	r25, Y+12	; 0x0c
    86cc:	fc 01       	movw	r30, r24
    86ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    86d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    86d2:	cc 01       	movw	r24, r24
    86d4:	a0 e0       	ldi	r26, 0x00	; 0
    86d6:	b0 e0       	ldi	r27, 0x00	; 0
    86d8:	82 2b       	or	r24, r18
    86da:	93 2b       	or	r25, r19
    86dc:	a4 2b       	or	r26, r20
    86de:	b5 2b       	or	r27, r21
    86e0:	89 83       	std	Y+1, r24	; 0x01
    86e2:	9a 83       	std	Y+2, r25	; 0x02
    86e4:	ab 83       	std	Y+3, r26	; 0x03
    86e6:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    86e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    86ea:	9c 85       	ldd	r25, Y+12	; 0x0c
    86ec:	fc 01       	movw	r30, r24
    86ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    86f0:	95 8d       	ldd	r25, Z+29	; 0x1d
    86f2:	a6 8d       	ldd	r26, Z+30	; 0x1e
    86f4:	b7 8d       	ldd	r27, Z+31	; 0x1f
    86f6:	8d 87       	std	Y+13, r24	; 0x0d
    86f8:	9e 87       	std	Y+14, r25	; 0x0e
    86fa:	af 87       	std	Y+15, r26	; 0x0f
    86fc:	b8 8b       	std	Y+16, r27	; 0x10
    86fe:	01 c0       	rjmp	.+2      	; 0x8702 <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8700:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8702:	89 81       	ldd	r24, Y+1	; 0x01
    8704:	9a 81       	ldd	r25, Y+2	; 0x02
    8706:	ab 81       	ldd	r26, Y+3	; 0x03
    8708:	bc 81       	ldd	r27, Y+4	; 0x04
    870a:	bc 01       	movw	r22, r24
    870c:	cd 01       	movw	r24, r26
    870e:	0e 94 c0 3f 	call	0x7f80	; 0x7f80 <getFirstSector>
    8712:	dc 01       	movw	r26, r24
    8714:	cb 01       	movw	r24, r22
    8716:	89 8b       	std	Y+17, r24	; 0x11
    8718:	9a 8b       	std	Y+18, r25	; 0x12
    871a:	ab 8b       	std	Y+19, r26	; 0x13
    871c:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    871e:	1d 82       	std	Y+5, r1	; 0x05
    8720:	17 c0       	rjmp	.+46     	; 0x8750 <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8722:	8d 81       	ldd	r24, Y+5	; 0x05
    8724:	28 2f       	mov	r18, r24
    8726:	30 e0       	ldi	r19, 0x00	; 0
    8728:	40 e0       	ldi	r20, 0x00	; 0
    872a:	50 e0       	ldi	r21, 0x00	; 0
    872c:	89 89       	ldd	r24, Y+17	; 0x11
    872e:	9a 89       	ldd	r25, Y+18	; 0x12
    8730:	ab 89       	ldd	r26, Y+19	; 0x13
    8732:	bc 89       	ldd	r27, Y+20	; 0x14
    8734:	82 0f       	add	r24, r18
    8736:	93 1f       	adc	r25, r19
    8738:	a4 1f       	adc	r26, r20
    873a:	b5 1f       	adc	r27, r21
    873c:	2c ec       	ldi	r18, 0xCC	; 204
    873e:	33 e2       	ldi	r19, 0x23	; 35
    8740:	bc 01       	movw	r22, r24
    8742:	cd 01       	movw	r24, r26
    8744:	a9 01       	movw	r20, r18
    8746:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    874a:	8d 81       	ldd	r24, Y+5	; 0x05
    874c:	8f 5f       	subi	r24, 0xFF	; 255
    874e:	8d 83       	std	Y+5, r24	; 0x05
    8750:	8d 81       	ldd	r24, Y+5	; 0x05
    8752:	28 2f       	mov	r18, r24
    8754:	30 e0       	ldi	r19, 0x00	; 0
    8756:	80 91 70 50 	lds	r24, 0x5070
    875a:	90 91 71 50 	lds	r25, 0x5071
    875e:	28 17       	cp	r18, r24
    8760:	39 07       	cpc	r19, r25
    8762:	f8 f2       	brcs	.-66     	; 0x8722 <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8764:	89 81       	ldd	r24, Y+1	; 0x01
    8766:	9a 81       	ldd	r25, Y+2	; 0x02
    8768:	ab 81       	ldd	r26, Y+3	; 0x03
    876a:	bc 81       	ldd	r27, Y+4	; 0x04
    876c:	bc 01       	movw	r22, r24
    876e:	cd 01       	movw	r24, r26
    8770:	40 e0       	ldi	r20, 0x00	; 0
    8772:	00 e0       	ldi	r16, 0x00	; 0
    8774:	10 e0       	ldi	r17, 0x00	; 0
    8776:	98 01       	movw	r18, r16
    8778:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
    877c:	dc 01       	movw	r26, r24
    877e:	cb 01       	movw	r24, r22
    8780:	89 83       	std	Y+1, r24	; 0x01
    8782:	9a 83       	std	Y+2, r25	; 0x02
    8784:	ab 83       	std	Y+3, r26	; 0x03
    8786:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8788:	89 81       	ldd	r24, Y+1	; 0x01
    878a:	9a 81       	ldd	r25, Y+2	; 0x02
    878c:	ab 81       	ldd	r26, Y+3	; 0x03
    878e:	bc 81       	ldd	r27, Y+4	; 0x04
    8790:	00 97       	sbiw	r24, 0x00	; 0
    8792:	a1 05       	cpc	r26, r1
    8794:	b1 05       	cpc	r27, r1
    8796:	09 f0       	breq	.+2      	; 0x879a <readFile+0x14c>
    8798:	b3 cf       	rjmp	.-154    	; 0x8700 <readFile+0xb2>
	  return 0;}
    879a:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    879c:	67 96       	adiw	r28, 0x17	; 23
    879e:	cd bf       	out	0x3d, r28	; 61
    87a0:	de bf       	out	0x3e, r29	; 62
    87a2:	df 91       	pop	r29
    87a4:	cf 91       	pop	r28
    87a6:	1f 91       	pop	r17
    87a8:	0f 91       	pop	r16
    87aa:	08 95       	ret

000087ac <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    87ac:	cf 93       	push	r28
    87ae:	df 93       	push	r29
    87b0:	cd b7       	in	r28, 0x3d	; 61
    87b2:	de b7       	in	r29, 0x3e	; 62
    87b4:	62 97       	sbiw	r28, 0x12	; 18
    87b6:	cd bf       	out	0x3d, r28	; 61
    87b8:	de bf       	out	0x3e, r29	; 62
    87ba:	89 8b       	std	Y+17, r24	; 0x11
    87bc:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    87be:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    87c0:	89 89       	ldd	r24, Y+17	; 0x11
    87c2:	9a 89       	ldd	r25, Y+18	; 0x12
    87c4:	9c 01       	movw	r18, r24
    87c6:	f9 01       	movw	r30, r18
    87c8:	01 90       	ld	r0, Z+
    87ca:	00 20       	and	r0, r0
    87cc:	e9 f7       	brne	.-6      	; 0x87c8 <convertFileName+0x1c>
    87ce:	cf 01       	movw	r24, r30
    87d0:	01 97       	sbiw	r24, 0x01	; 1
    87d2:	82 1b       	sub	r24, r18
    87d4:	93 0b       	sbc	r25, r19
    87d6:	80 31       	cpi	r24, 0x10	; 16
    87d8:	91 05       	cpc	r25, r1
    87da:	10 f0       	brcs	.+4      	; 0x87e0 <convertFileName+0x34>
    87dc:	81 e0       	ldi	r24, 0x01	; 1
    87de:	16 c1       	rjmp	.+556    	; 0x8a0c <convertFileName+0x260>
int i=0;
    87e0:	1c 82       	std	Y+4, r1	; 0x04
    87e2:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    87e4:	13 c0       	rjmp	.+38     	; 0x880c <convertFileName+0x60>
	Filename[i] = fileName[i];
    87e6:	8c 81       	ldd	r24, Y+4	; 0x04
    87e8:	9d 81       	ldd	r25, Y+5	; 0x05
    87ea:	29 89       	ldd	r18, Y+17	; 0x11
    87ec:	3a 89       	ldd	r19, Y+18	; 0x12
    87ee:	82 0f       	add	r24, r18
    87f0:	93 1f       	adc	r25, r19
    87f2:	fc 01       	movw	r30, r24
    87f4:	20 81       	ld	r18, Z
    87f6:	8c 81       	ldd	r24, Y+4	; 0x04
    87f8:	9d 81       	ldd	r25, Y+5	; 0x05
    87fa:	80 55       	subi	r24, 0x50	; 80
    87fc:	9f 4a       	sbci	r25, 0xAF	; 175
    87fe:	fc 01       	movw	r30, r24
    8800:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    8802:	8c 81       	ldd	r24, Y+4	; 0x04
    8804:	9d 81       	ldd	r25, Y+5	; 0x05
    8806:	01 96       	adiw	r24, 0x01	; 1
    8808:	8c 83       	std	Y+4, r24	; 0x04
    880a:	9d 83       	std	Y+5, r25	; 0x05
    880c:	4c 81       	ldd	r20, Y+4	; 0x04
    880e:	5d 81       	ldd	r21, Y+5	; 0x05
    8810:	89 89       	ldd	r24, Y+17	; 0x11
    8812:	9a 89       	ldd	r25, Y+18	; 0x12
    8814:	9c 01       	movw	r18, r24
    8816:	f9 01       	movw	r30, r18
    8818:	01 90       	ld	r0, Z+
    881a:	00 20       	and	r0, r0
    881c:	e9 f7       	brne	.-6      	; 0x8818 <convertFileName+0x6c>
    881e:	cf 01       	movw	r24, r30
    8820:	01 97       	sbiw	r24, 0x01	; 1
    8822:	82 1b       	sub	r24, r18
    8824:	93 0b       	sbc	r25, r19
    8826:	48 17       	cp	r20, r24
    8828:	59 07       	cpc	r21, r25
    882a:	e8 f2       	brcs	.-70     	; 0x87e6 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    882c:	0c c0       	rjmp	.+24     	; 0x8846 <convertFileName+0x9a>
    882e:	8c 81       	ldd	r24, Y+4	; 0x04
    8830:	9d 81       	ldd	r25, Y+5	; 0x05
    8832:	80 55       	subi	r24, 0x50	; 80
    8834:	9f 4a       	sbci	r25, 0xAF	; 175
    8836:	20 e2       	ldi	r18, 0x20	; 32
    8838:	fc 01       	movw	r30, r24
    883a:	20 83       	st	Z, r18
    883c:	8c 81       	ldd	r24, Y+4	; 0x04
    883e:	9d 81       	ldd	r25, Y+5	; 0x05
    8840:	01 96       	adiw	r24, 0x01	; 1
    8842:	8c 83       	std	Y+4, r24	; 0x04
    8844:	9d 83       	std	Y+5, r25	; 0x05
    8846:	8c 81       	ldd	r24, Y+4	; 0x04
    8848:	9d 81       	ldd	r25, Y+5	; 0x05
    884a:	8f 30       	cpi	r24, 0x0F	; 15
    884c:	91 05       	cpc	r25, r1
    884e:	7c f3       	brlt	.-34     	; 0x882e <convertFileName+0x82>


for(j=0; j<12; j++)
    8850:	1a 82       	std	Y+2, r1	; 0x02
    8852:	0c c0       	rjmp	.+24     	; 0x886c <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8854:	8a 81       	ldd	r24, Y+2	; 0x02
    8856:	88 2f       	mov	r24, r24
    8858:	90 e0       	ldi	r25, 0x00	; 0
    885a:	80 55       	subi	r24, 0x50	; 80
    885c:	9f 4a       	sbci	r25, 0xAF	; 175
    885e:	fc 01       	movw	r30, r24
    8860:	80 81       	ld	r24, Z
    8862:	8e 32       	cpi	r24, 0x2E	; 46
    8864:	39 f0       	breq	.+14     	; 0x8874 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8866:	8a 81       	ldd	r24, Y+2	; 0x02
    8868:	8f 5f       	subi	r24, 0xFF	; 255
    886a:	8a 83       	std	Y+2, r24	; 0x02
    886c:	8a 81       	ldd	r24, Y+2	; 0x02
    886e:	8c 30       	cpi	r24, 0x0C	; 12
    8870:	88 f3       	brcs	.-30     	; 0x8854 <convertFileName+0xa8>
    8872:	01 c0       	rjmp	.+2      	; 0x8876 <convertFileName+0xca>
if(Filename[j] == '.') break;
    8874:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8876:	8a 81       	ldd	r24, Y+2	; 0x02
    8878:	89 30       	cpi	r24, 0x09	; 9
    887a:	28 f0       	brcs	.+10     	; 0x8886 <convertFileName+0xda>
    887c:	8a 81       	ldd	r24, Y+2	; 0x02
    887e:	8c 30       	cpi	r24, 0x0C	; 12
    8880:	10 f4       	brcc	.+4      	; 0x8886 <convertFileName+0xda>
	return 1;}
    8882:	81 e0       	ldi	r24, 0x01	; 1
    8884:	c3 c0       	rjmp	.+390    	; 0x8a0c <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8886:	8a 81       	ldd	r24, Y+2	; 0x02
    8888:	8c 30       	cpi	r24, 0x0C	; 12
    888a:	11 f4       	brne	.+4      	; 0x8890 <convertFileName+0xe4>
    888c:	81 e0       	ldi	r24, 0x01	; 1
    888e:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8890:	1b 82       	std	Y+3, r1	; 0x03
    8892:	14 c0       	rjmp	.+40     	; 0x88bc <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8894:	8b 81       	ldd	r24, Y+3	; 0x03
    8896:	88 2f       	mov	r24, r24
    8898:	90 e0       	ldi	r25, 0x00	; 0
    889a:	2b 81       	ldd	r18, Y+3	; 0x03
    889c:	22 2f       	mov	r18, r18
    889e:	30 e0       	ldi	r19, 0x00	; 0
    88a0:	20 55       	subi	r18, 0x50	; 80
    88a2:	3f 4a       	sbci	r19, 0xAF	; 175
    88a4:	f9 01       	movw	r30, r18
    88a6:	40 81       	ld	r20, Z
    88a8:	9e 01       	movw	r18, r28
    88aa:	2a 5f       	subi	r18, 0xFA	; 250
    88ac:	3f 4f       	sbci	r19, 0xFF	; 255
    88ae:	82 0f       	add	r24, r18
    88b0:	93 1f       	adc	r25, r19
    88b2:	fc 01       	movw	r30, r24
    88b4:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    88b6:	8b 81       	ldd	r24, Y+3	; 0x03
    88b8:	8f 5f       	subi	r24, 0xFF	; 255
    88ba:	8b 83       	std	Y+3, r24	; 0x03
    88bc:	9b 81       	ldd	r25, Y+3	; 0x03
    88be:	8a 81       	ldd	r24, Y+2	; 0x02
    88c0:	98 17       	cp	r25, r24
    88c2:	40 f3       	brcs	.-48     	; 0x8894 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    88c4:	8a 81       	ldd	r24, Y+2	; 0x02
    88c6:	8b 83       	std	Y+3, r24	; 0x03
    88c8:	0e c0       	rjmp	.+28     	; 0x88e6 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    88ca:	8b 81       	ldd	r24, Y+3	; 0x03
    88cc:	88 2f       	mov	r24, r24
    88ce:	90 e0       	ldi	r25, 0x00	; 0
    88d0:	9e 01       	movw	r18, r28
    88d2:	2a 5f       	subi	r18, 0xFA	; 250
    88d4:	3f 4f       	sbci	r19, 0xFF	; 255
    88d6:	82 0f       	add	r24, r18
    88d8:	93 1f       	adc	r25, r19
    88da:	20 e2       	ldi	r18, 0x20	; 32
    88dc:	fc 01       	movw	r30, r24
    88de:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    88e0:	8b 81       	ldd	r24, Y+3	; 0x03
    88e2:	8f 5f       	subi	r24, 0xFF	; 255
    88e4:	8b 83       	std	Y+3, r24	; 0x03
    88e6:	8b 81       	ldd	r24, Y+3	; 0x03
    88e8:	88 30       	cpi	r24, 0x08	; 8
    88ea:	78 f3       	brcs	.-34     	; 0x88ca <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    88ec:	99 81       	ldd	r25, Y+1	; 0x01
    88ee:	81 e0       	ldi	r24, 0x01	; 1
    88f0:	89 27       	eor	r24, r25
    88f2:	88 23       	and	r24, r24
    88f4:	19 f0       	breq	.+6      	; 0x88fc <convertFileName+0x150>
    88f6:	8a 81       	ldd	r24, Y+2	; 0x02
    88f8:	8f 5f       	subi	r24, 0xFF	; 255
    88fa:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    88fc:	88 e0       	ldi	r24, 0x08	; 8
    88fe:	8b 83       	std	Y+3, r24	; 0x03
    8900:	32 c0       	rjmp	.+100    	; 0x8966 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8902:	8a 81       	ldd	r24, Y+2	; 0x02
    8904:	88 2f       	mov	r24, r24
    8906:	90 e0       	ldi	r25, 0x00	; 0
    8908:	80 55       	subi	r24, 0x50	; 80
    890a:	9f 4a       	sbci	r25, 0xAF	; 175
    890c:	fc 01       	movw	r30, r24
    890e:	80 81       	ld	r24, Z
    8910:	88 23       	and	r24, r24
    8912:	19 f1       	breq	.+70     	; 0x895a <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8914:	8b 81       	ldd	r24, Y+3	; 0x03
    8916:	88 2f       	mov	r24, r24
    8918:	90 e0       	ldi	r25, 0x00	; 0
    891a:	2a 81       	ldd	r18, Y+2	; 0x02
    891c:	22 2f       	mov	r18, r18
    891e:	30 e0       	ldi	r19, 0x00	; 0
    8920:	20 55       	subi	r18, 0x50	; 80
    8922:	3f 4a       	sbci	r19, 0xAF	; 175
    8924:	f9 01       	movw	r30, r18
    8926:	40 81       	ld	r20, Z
    8928:	9e 01       	movw	r18, r28
    892a:	2a 5f       	subi	r18, 0xFA	; 250
    892c:	3f 4f       	sbci	r19, 0xFF	; 255
    892e:	82 0f       	add	r24, r18
    8930:	93 1f       	adc	r25, r19
    8932:	fc 01       	movw	r30, r24
    8934:	40 83       	st	Z, r20
    8936:	8a 81       	ldd	r24, Y+2	; 0x02
    8938:	8f 5f       	subi	r24, 0xFF	; 255
    893a:	8a 83       	std	Y+2, r24	; 0x02
    893c:	11 c0       	rjmp	.+34     	; 0x8960 <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    893e:	8b 81       	ldd	r24, Y+3	; 0x03
    8940:	88 2f       	mov	r24, r24
    8942:	90 e0       	ldi	r25, 0x00	; 0
    8944:	9e 01       	movw	r18, r28
    8946:	2a 5f       	subi	r18, 0xFA	; 250
    8948:	3f 4f       	sbci	r19, 0xFF	; 255
    894a:	82 0f       	add	r24, r18
    894c:	93 1f       	adc	r25, r19
    894e:	20 e2       	ldi	r18, 0x20	; 32
    8950:	fc 01       	movw	r30, r24
    8952:	20 83       	st	Z, r18
    8954:	8b 81       	ldd	r24, Y+3	; 0x03
    8956:	8f 5f       	subi	r24, 0xFF	; 255
    8958:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    895a:	8b 81       	ldd	r24, Y+3	; 0x03
    895c:	8b 30       	cpi	r24, 0x0B	; 11
    895e:	78 f3       	brcs	.-34     	; 0x893e <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8960:	8b 81       	ldd	r24, Y+3	; 0x03
    8962:	8f 5f       	subi	r24, 0xFF	; 255
    8964:	8b 83       	std	Y+3, r24	; 0x03
    8966:	8b 81       	ldd	r24, Y+3	; 0x03
    8968:	8b 30       	cpi	r24, 0x0B	; 11
    896a:	58 f2       	brcs	.-106    	; 0x8902 <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    896c:	1a 82       	std	Y+2, r1	; 0x02
    896e:	31 c0       	rjmp	.+98     	; 0x89d2 <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8970:	8a 81       	ldd	r24, Y+2	; 0x02
    8972:	88 2f       	mov	r24, r24
    8974:	90 e0       	ldi	r25, 0x00	; 0
    8976:	9e 01       	movw	r18, r28
    8978:	2a 5f       	subi	r18, 0xFA	; 250
    897a:	3f 4f       	sbci	r19, 0xFF	; 255
    897c:	82 0f       	add	r24, r18
    897e:	93 1f       	adc	r25, r19
    8980:	fc 01       	movw	r30, r24
    8982:	80 81       	ld	r24, Z
    8984:	81 36       	cpi	r24, 0x61	; 97
    8986:	10 f1       	brcs	.+68     	; 0x89cc <convertFileName+0x220>
    8988:	8a 81       	ldd	r24, Y+2	; 0x02
    898a:	88 2f       	mov	r24, r24
    898c:	90 e0       	ldi	r25, 0x00	; 0
    898e:	9e 01       	movw	r18, r28
    8990:	2a 5f       	subi	r18, 0xFA	; 250
    8992:	3f 4f       	sbci	r19, 0xFF	; 255
    8994:	82 0f       	add	r24, r18
    8996:	93 1f       	adc	r25, r19
    8998:	fc 01       	movw	r30, r24
    899a:	80 81       	ld	r24, Z
    899c:	8b 37       	cpi	r24, 0x7B	; 123
    899e:	b0 f4       	brcc	.+44     	; 0x89cc <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    89a0:	8a 81       	ldd	r24, Y+2	; 0x02
    89a2:	88 2f       	mov	r24, r24
    89a4:	90 e0       	ldi	r25, 0x00	; 0
    89a6:	2a 81       	ldd	r18, Y+2	; 0x02
    89a8:	22 2f       	mov	r18, r18
    89aa:	30 e0       	ldi	r19, 0x00	; 0
    89ac:	ae 01       	movw	r20, r28
    89ae:	4a 5f       	subi	r20, 0xFA	; 250
    89b0:	5f 4f       	sbci	r21, 0xFF	; 255
    89b2:	24 0f       	add	r18, r20
    89b4:	35 1f       	adc	r19, r21
    89b6:	f9 01       	movw	r30, r18
    89b8:	20 81       	ld	r18, Z
    89ba:	42 2f       	mov	r20, r18
    89bc:	40 52       	subi	r20, 0x20	; 32
    89be:	9e 01       	movw	r18, r28
    89c0:	2a 5f       	subi	r18, 0xFA	; 250
    89c2:	3f 4f       	sbci	r19, 0xFF	; 255
    89c4:	82 0f       	add	r24, r18
    89c6:	93 1f       	adc	r25, r19
    89c8:	fc 01       	movw	r30, r24
    89ca:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    89cc:	8a 81       	ldd	r24, Y+2	; 0x02
    89ce:	8f 5f       	subi	r24, 0xFF	; 255
    89d0:	8a 83       	std	Y+2, r24	; 0x02
    89d2:	8a 81       	ldd	r24, Y+2	; 0x02
    89d4:	8b 30       	cpi	r24, 0x0B	; 11
    89d6:	60 f2       	brcs	.-104    	; 0x8970 <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    89d8:	1a 82       	std	Y+2, r1	; 0x02
    89da:	14 c0       	rjmp	.+40     	; 0x8a04 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    89dc:	8a 81       	ldd	r24, Y+2	; 0x02
    89de:	88 2f       	mov	r24, r24
    89e0:	90 e0       	ldi	r25, 0x00	; 0
    89e2:	2a 81       	ldd	r18, Y+2	; 0x02
    89e4:	22 2f       	mov	r18, r18
    89e6:	30 e0       	ldi	r19, 0x00	; 0
    89e8:	ae 01       	movw	r20, r28
    89ea:	4a 5f       	subi	r20, 0xFA	; 250
    89ec:	5f 4f       	sbci	r21, 0xFF	; 255
    89ee:	24 0f       	add	r18, r20
    89f0:	35 1f       	adc	r19, r21
    89f2:	f9 01       	movw	r30, r18
    89f4:	20 81       	ld	r18, Z
    89f6:	80 55       	subi	r24, 0x50	; 80
    89f8:	9f 4a       	sbci	r25, 0xAF	; 175
    89fa:	fc 01       	movw	r30, r24
    89fc:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    89fe:	8a 81       	ldd	r24, Y+2	; 0x02
    8a00:	8f 5f       	subi	r24, 0xFF	; 255
    8a02:	8a 83       	std	Y+2, r24	; 0x02
    8a04:	8a 81       	ldd	r24, Y+2	; 0x02
    8a06:	8b 30       	cpi	r24, 0x0B	; 11
    8a08:	48 f3       	brcs	.-46     	; 0x89dc <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8a0a:	80 e0       	ldi	r24, 0x00	; 0
}
    8a0c:	62 96       	adiw	r28, 0x12	; 18
    8a0e:	cd bf       	out	0x3d, r28	; 61
    8a10:	de bf       	out	0x3e, r29	; 62
    8a12:	df 91       	pop	r29
    8a14:	cf 91       	pop	r28
    8a16:	08 95       	ret

00008a18 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    8a18:	ef 92       	push	r14
    8a1a:	ff 92       	push	r15
    8a1c:	0f 93       	push	r16
    8a1e:	1f 93       	push	r17
    8a20:	cf 93       	push	r28
    8a22:	df 93       	push	r29
    8a24:	cd b7       	in	r28, 0x3d	; 61
    8a26:	de b7       	in	r29, 0x3e	; 62
    8a28:	e7 97       	sbiw	r28, 0x37	; 55
    8a2a:	cd bf       	out	0x3d, r28	; 61
    8a2c:	de bf       	out	0x3e, r29	; 62
    8a2e:	88 ab       	sts	0x58, r24
    8a30:	99 ab       	sts	0x59, r25
    8a32:	6a ab       	sts	0x5a, r22
    8a34:	7b ab       	sts	0x5b, r23
    8a36:	2c ab       	sts	0x5c, r18
    8a38:	3d ab       	sts	0x5d, r19
    8a3a:	4e ab       	sts	0x5e, r20
    8a3c:	5f ab       	sts	0x5f, r21
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8a3e:	1a 82       	std	Y+2, r1	; 0x02
    8a40:	1b 82       	std	Y+3, r1	; 0x03
    8a42:	1c 82       	std	Y+4, r1	; 0x04
    8a44:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8a46:	1e 82       	std	Y+6, r1	; 0x06
    8a48:	1f 82       	std	Y+7, r1	; 0x07
    8a4a:	18 86       	std	Y+8, r1	; 0x08
    8a4c:	19 86       	std	Y+9, r1	; 0x09
    8a4e:	1a 86       	std	Y+10, r1	; 0x0a
    8a50:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    8a52:	28 a9       	sts	0x48, r18
    8a54:	39 a9       	sts	0x49, r19
    8a56:	81 e0       	ldi	r24, 0x01	; 1
    8a58:	b9 01       	movw	r22, r18
    8a5a:	0e 94 27 43 	call	0x864e	; 0x864e <readFile>
    8a5e:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8a60:	89 81       	ldd	r24, Y+1	; 0x01
    8a62:	81 30       	cpi	r24, 0x01	; 1
    8a64:	09 f0       	breq	.+2      	; 0x8a68 <writeFile+0x50>
    8a66:	84 c0       	rjmp	.+264    	; 0x8b70 <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    8a68:	81 e0       	ldi	r24, 0x01	; 1
    8a6a:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8a6c:	80 91 7c 50 	lds	r24, 0x507C
    8a70:	90 91 7d 50 	lds	r25, 0x507D
    8a74:	a0 91 7e 50 	lds	r26, 0x507E
    8a78:	b0 91 7f 50 	lds	r27, 0x507F
    8a7c:	8c 87       	std	Y+12, r24	; 0x0c
    8a7e:	9d 87       	std	Y+13, r25	; 0x0d
    8a80:	ae 87       	std	Y+14, r26	; 0x0e
    8a82:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8a84:	1c 8a       	std	Y+20, r1	; 0x14
    8a86:	1d 8a       	std	Y+21, r1	; 0x15
    8a88:	1e 8a       	std	Y+22, r1	; 0x16
    8a8a:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8a8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8a8e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8a90:	ae 85       	ldd	r26, Y+14	; 0x0e
    8a92:	bf 85       	ldd	r27, Y+15	; 0x0f
    8a94:	bc 01       	movw	r22, r24
    8a96:	cd 01       	movw	r24, r26
    8a98:	40 e0       	ldi	r20, 0x00	; 0
    8a9a:	00 e0       	ldi	r16, 0x00	; 0
    8a9c:	10 e0       	ldi	r17, 0x00	; 0
    8a9e:	98 01       	movw	r18, r16
    8aa0:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
    8aa4:	dc 01       	movw	r26, r24
    8aa6:	cb 01       	movw	r24, r22
    8aa8:	8a a3       	lds	r24, 0x5a
    8aaa:	9b a3       	lds	r25, 0x5b
    8aac:	ac a3       	lds	r26, 0x5c
    8aae:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    8ab0:	8a a1       	lds	r24, 0x4a
    8ab2:	9b a1       	lds	r25, 0x4b
    8ab4:	ac a1       	lds	r26, 0x4c
    8ab6:	bd a1       	lds	r27, 0x4d
    8ab8:	8f 3f       	cpi	r24, 0xFF	; 255
    8aba:	0f ef       	ldi	r16, 0xFF	; 255
    8abc:	90 07       	cpc	r25, r16
    8abe:	0f ef       	ldi	r16, 0xFF	; 255
    8ac0:	a0 07       	cpc	r26, r16
    8ac2:	0f e0       	ldi	r16, 0x0F	; 15
    8ac4:	b0 07       	cpc	r27, r16
    8ac6:	a1 f0       	breq	.+40     	; 0x8af0 <writeFile+0xd8>
	cluster = nextCluster;
    8ac8:	8a a1       	lds	r24, 0x4a
    8aca:	9b a1       	lds	r25, 0x4b
    8acc:	ac a1       	lds	r26, 0x4c
    8ace:	bd a1       	lds	r27, 0x4d
    8ad0:	8c 87       	std	Y+12, r24	; 0x0c
    8ad2:	9d 87       	std	Y+13, r25	; 0x0d
    8ad4:	ae 87       	std	Y+14, r26	; 0x0e
    8ad6:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8ad8:	8c 89       	ldd	r24, Y+20	; 0x14
    8ada:	9d 89       	ldd	r25, Y+21	; 0x15
    8adc:	ae 89       	ldd	r26, Y+22	; 0x16
    8ade:	bf 89       	ldd	r27, Y+23	; 0x17
    8ae0:	01 96       	adiw	r24, 0x01	; 1
    8ae2:	a1 1d       	adc	r26, r1
    8ae4:	b1 1d       	adc	r27, r1
    8ae6:	8c 8b       	std	Y+20, r24	; 0x14
    8ae8:	9d 8b       	std	Y+21, r25	; 0x15
    8aea:	ae 8b       	std	Y+22, r26	; 0x16
    8aec:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8aee:	ce cf       	rjmp	.-100    	; 0x8a8c <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8af0:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8af2:	e0 90 3d 40 	lds	r14, 0x403D
    8af6:	f0 90 3e 40 	lds	r15, 0x403E
    8afa:	00 91 3f 40 	lds	r16, 0x403F
    8afe:	10 91 40 40 	lds	r17, 0x4040
    8b02:	80 91 70 50 	lds	r24, 0x5070
    8b06:	90 91 71 50 	lds	r25, 0x5071
    8b0a:	cc 01       	movw	r24, r24
    8b0c:	a0 e0       	ldi	r26, 0x00	; 0
    8b0e:	b0 e0       	ldi	r27, 0x00	; 0
    8b10:	2c 89       	ldd	r18, Y+20	; 0x14
    8b12:	3d 89       	ldd	r19, Y+21	; 0x15
    8b14:	4e 89       	ldd	r20, Y+22	; 0x16
    8b16:	5f 89       	ldd	r21, Y+23	; 0x17
    8b18:	bc 01       	movw	r22, r24
    8b1a:	cd 01       	movw	r24, r26
    8b1c:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    8b20:	dc 01       	movw	r26, r24
    8b22:	cb 01       	movw	r24, r22
    8b24:	20 91 41 40 	lds	r18, 0x4041
    8b28:	30 91 42 40 	lds	r19, 0x4042
    8b2c:	99 01       	movw	r18, r18
    8b2e:	40 e0       	ldi	r20, 0x00	; 0
    8b30:	50 e0       	ldi	r21, 0x00	; 0
    8b32:	bc 01       	movw	r22, r24
    8b34:	cd 01       	movw	r24, r26
    8b36:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    8b3a:	dc 01       	movw	r26, r24
    8b3c:	cb 01       	movw	r24, r22
    8b3e:	a8 01       	movw	r20, r16
    8b40:	97 01       	movw	r18, r14
    8b42:	28 1b       	sub	r18, r24
    8b44:	39 0b       	sbc	r19, r25
    8b46:	4a 0b       	sbc	r20, r26
    8b48:	5b 0b       	sbc	r21, r27
    8b4a:	da 01       	movw	r26, r20
    8b4c:	c9 01       	movw	r24, r18
    8b4e:	20 91 41 40 	lds	r18, 0x4041
    8b52:	30 91 42 40 	lds	r19, 0x4042
    8b56:	99 01       	movw	r18, r18
    8b58:	40 e0       	ldi	r20, 0x00	; 0
    8b5a:	50 e0       	ldi	r21, 0x00	; 0
    8b5c:	bc 01       	movw	r22, r24
    8b5e:	cd 01       	movw	r24, r26
    8b60:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    8b64:	da 01       	movw	r26, r20
    8b66:	c9 01       	movw	r24, r18
    8b68:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8b6a:	81 e0       	ldi	r24, 0x01	; 1
    8b6c:	8b 83       	std	Y+3, r24	; 0x03
    8b6e:	69 c0       	rjmp	.+210    	; 0x8c42 <writeFile+0x22a>
}
else if(j == 2) 
    8b70:	89 81       	ldd	r24, Y+1	; 0x01
    8b72:	82 30       	cpi	r24, 0x02	; 2
    8b74:	11 f4       	brne	.+4      	; 0x8b7a <writeFile+0x162>
   return 1; //invalid file name
    8b76:	81 e0       	ldi	r24, 0x01	; 1
    8b78:	1b c3       	rjmp	.+1590   	; 0x91b0 <writeFile+0x798>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8b7a:	82 e0       	ldi	r24, 0x02	; 2
    8b7c:	60 e0       	ldi	r22, 0x00	; 0
    8b7e:	20 e0       	ldi	r18, 0x00	; 0
    8b80:	30 e0       	ldi	r19, 0x00	; 0
    8b82:	a9 01       	movw	r20, r18
    8b84:	0e 94 9c 40 	call	0x8138	; 0x8138 <getSetFreeCluster>
    8b88:	dc 01       	movw	r26, r24
    8b8a:	cb 01       	movw	r24, r22
    8b8c:	8c 87       	std	Y+12, r24	; 0x0c
    8b8e:	9d 87       	std	Y+13, r25	; 0x0d
    8b90:	ae 87       	std	Y+14, r26	; 0x0e
    8b92:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8b94:	80 91 4e 40 	lds	r24, 0x404E
    8b98:	90 91 4f 40 	lds	r25, 0x404F
    8b9c:	a0 91 50 40 	lds	r26, 0x4050
    8ba0:	b0 91 51 40 	lds	r27, 0x4051
    8ba4:	2c 85       	ldd	r18, Y+12	; 0x0c
    8ba6:	3d 85       	ldd	r19, Y+13	; 0x0d
    8ba8:	4e 85       	ldd	r20, Y+14	; 0x0e
    8baa:	5f 85       	ldd	r21, Y+15	; 0x0f
    8bac:	82 17       	cp	r24, r18
    8bae:	93 07       	cpc	r25, r19
    8bb0:	a4 07       	cpc	r26, r20
    8bb2:	b5 07       	cpc	r27, r21
    8bb4:	60 f4       	brcc	.+24     	; 0x8bce <writeFile+0x1b6>
     cluster = rootCluster;
    8bb6:	80 91 54 40 	lds	r24, 0x4054
    8bba:	90 91 55 40 	lds	r25, 0x4055
    8bbe:	a0 91 56 40 	lds	r26, 0x4056
    8bc2:	b0 91 57 40 	lds	r27, 0x4057
    8bc6:	8c 87       	std	Y+12, r24	; 0x0c
    8bc8:	9d 87       	std	Y+13, r25	; 0x0d
    8bca:	ae 87       	std	Y+14, r26	; 0x0e
    8bcc:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8bce:	8c 85       	ldd	r24, Y+12	; 0x0c
    8bd0:	9d 85       	ldd	r25, Y+13	; 0x0d
    8bd2:	ae 85       	ldd	r26, Y+14	; 0x0e
    8bd4:	bf 85       	ldd	r27, Y+15	; 0x0f
    8bd6:	bc 01       	movw	r22, r24
    8bd8:	cd 01       	movw	r24, r26
    8bda:	0e 94 e2 48 	call	0x91c4	; 0x91c4 <searchNextFreeCluster>
    8bde:	dc 01       	movw	r26, r24
    8be0:	cb 01       	movw	r24, r22
    8be2:	8c 87       	std	Y+12, r24	; 0x0c
    8be4:	9d 87       	std	Y+13, r25	; 0x0d
    8be6:	ae 87       	std	Y+14, r26	; 0x0e
    8be8:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8bea:	8c 85       	ldd	r24, Y+12	; 0x0c
    8bec:	9d 85       	ldd	r25, Y+13	; 0x0d
    8bee:	ae 85       	ldd	r26, Y+14	; 0x0e
    8bf0:	bf 85       	ldd	r27, Y+15	; 0x0f
    8bf2:	00 97       	sbiw	r24, 0x00	; 0
    8bf4:	a1 05       	cpc	r26, r1
    8bf6:	b1 05       	cpc	r27, r1
    8bf8:	11 f4       	brne	.+4      	; 0x8bfe <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    8bfa:	82 e0       	ldi	r24, 0x02	; 2
    8bfc:	d9 c2       	rjmp	.+1458   	; 0x91b0 <writeFile+0x798>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8bfe:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c00:	9d 85       	ldd	r25, Y+13	; 0x0d
    8c02:	ae 85       	ldd	r26, Y+14	; 0x0e
    8c04:	bf 85       	ldd	r27, Y+15	; 0x0f
    8c06:	bc 01       	movw	r22, r24
    8c08:	cd 01       	movw	r24, r26
    8c0a:	41 e0       	ldi	r20, 0x01	; 1
    8c0c:	0f ef       	ldi	r16, 0xFF	; 255
    8c0e:	1f ef       	ldi	r17, 0xFF	; 255
    8c10:	2f ef       	ldi	r18, 0xFF	; 255
    8c12:	3f e0       	ldi	r19, 0x0F	; 15
    8c14:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8c18:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c1a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8c1c:	ae 85       	ldd	r26, Y+14	; 0x0e
    8c1e:	bf 85       	ldd	r27, Y+15	; 0x0f
    8c20:	cd 01       	movw	r24, r26
    8c22:	aa 27       	eor	r26, r26
    8c24:	bb 27       	eor	r27, r27
    8c26:	8e 83       	std	Y+6, r24	; 0x06
    8c28:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8c2a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c2c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8c2e:	88 87       	std	Y+8, r24	; 0x08
    8c30:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8c32:	10 92 3d 40 	sts	0x403D, r1
    8c36:	10 92 3e 40 	sts	0x403E, r1
    8c3a:	10 92 3f 40 	sts	0x403F, r1
    8c3e:	10 92 40 40 	sts	0x4040, r1
}

//start writing data here

if(start){
    8c42:	8b 81       	ldd	r24, Y+3	; 0x03
    8c44:	88 23       	and	r24, r24
    8c46:	11 f1       	breq	.+68     	; 0x8c8c <writeFile+0x274>
  start = 0;
    8c48:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    8c4a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c4c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8c4e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8c50:	bf 85       	ldd	r27, Y+15	; 0x0f
    8c52:	bc 01       	movw	r22, r24
    8c54:	cd 01       	movw	r24, r26
    8c56:	0e 94 c0 3f 	call	0x7f80	; 0x7f80 <getFirstSector>
    8c5a:	dc 01       	movw	r26, r24
    8c5c:	cb 01       	movw	r24, r22
    8c5e:	9c 01       	movw	r18, r24
    8c60:	8d 81       	ldd	r24, Y+5	; 0x05
    8c62:	88 2f       	mov	r24, r24
    8c64:	90 e0       	ldi	r25, 0x00	; 0
    8c66:	82 0f       	add	r24, r18
    8c68:	93 1f       	adc	r25, r19
    8c6a:	8a 87       	std	Y+10, r24	; 0x0a
    8c6c:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    8c6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    8c70:	9b 85       	ldd	r25, Y+11	; 0x0b
    8c72:	cc 01       	movw	r24, r24
    8c74:	a0 e0       	ldi	r26, 0x00	; 0
    8c76:	b0 e0       	ldi	r27, 0x00	; 0
    8c78:	23 ec       	ldi	r18, 0xC3	; 195
    8c7a:	31 e2       	ldi	r19, 0x21	; 33
    8c7c:	bc 01       	movw	r22, r24
    8c7e:	cd 01       	movw	r24, r26
    8c80:	a9 01       	movw	r20, r18
    8c82:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
  j = sector;
    8c86:	8d 81       	ldd	r24, Y+5	; 0x05
    8c88:	89 83       	std	Y+1, r24	; 0x01
    8c8a:	0d c0       	rjmp	.+26     	; 0x8ca6 <writeFile+0x28e>
}
else{
  startBlock = getFirstSector (cluster);
    8c8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c8e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8c90:	ae 85       	ldd	r26, Y+14	; 0x0e
    8c92:	bf 85       	ldd	r27, Y+15	; 0x0f
    8c94:	bc 01       	movw	r22, r24
    8c96:	cd 01       	movw	r24, r26
    8c98:	0e 94 c0 3f 	call	0x7f80	; 0x7f80 <getFirstSector>
    8c9c:	dc 01       	movw	r26, r24
    8c9e:	cb 01       	movw	r24, r22
    8ca0:	8a 87       	std	Y+10, r24	; 0x0a
    8ca2:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    8ca4:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    8ca6:	18 8e       	std	Y+24, r1	; 0x18
    8ca8:	19 8e       	std	Y+25, r1	; 0x19
    8caa:	1a 8e       	std	Y+26, r1	; 0x1a
    8cac:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    8cae:	1c 8e       	std	Y+28, r1	; 0x1c
    8cb0:	1d 8e       	std	Y+29, r1	; 0x1d
    8cb2:	1e 8e       	std	Y+30, r1	; 0x1e
    8cb4:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    8cb6:	cd c0       	rjmp	.+410    	; 0x8e52 <writeFile+0x43a>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    8cb8:	8c a9       	sts	0x4c, r24
    8cba:	9d a9       	sts	0x4d, r25
    8cbc:	ae a9       	sts	0x4e, r26
    8cbe:	bf a9       	sts	0x4f, r27
    8cc0:	80 30       	cpi	r24, 0x00	; 0
    8cc2:	32 e0       	ldi	r19, 0x02	; 2
    8cc4:	93 07       	cpc	r25, r19
    8cc6:	30 e0       	ldi	r19, 0x00	; 0
    8cc8:	a3 07       	cpc	r26, r19
    8cca:	30 e0       	ldi	r19, 0x00	; 0
    8ccc:	b3 07       	cpc	r27, r19
    8cce:	08 f1       	brcs	.+66     	; 0x8d12 <writeFile+0x2fa>
		 writtenData += 512;
    8cd0:	88 8d       	ldd	r24, Y+24	; 0x18
    8cd2:	99 8d       	ldd	r25, Y+25	; 0x19
    8cd4:	aa 8d       	ldd	r26, Y+26	; 0x1a
    8cd6:	bb 8d       	ldd	r27, Y+27	; 0x1b
    8cd8:	80 50       	subi	r24, 0x00	; 0
    8cda:	9e 4f       	sbci	r25, 0xFE	; 254
    8cdc:	af 4f       	sbci	r26, 0xFF	; 255
    8cde:	bf 4f       	sbci	r27, 0xFF	; 255
    8ce0:	88 8f       	std	Y+24, r24	; 0x18
    8ce2:	99 8f       	std	Y+25, r25	; 0x19
    8ce4:	aa 8f       	std	Y+26, r26	; 0x1a
    8ce6:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    8ce8:	80 e0       	ldi	r24, 0x00	; 0
    8cea:	92 e0       	ldi	r25, 0x02	; 2
    8cec:	a0 e0       	ldi	r26, 0x00	; 0
    8cee:	b0 e0       	ldi	r27, 0x00	; 0
    8cf0:	8c 8f       	std	Y+28, r24	; 0x1c
    8cf2:	9d 8f       	std	Y+29, r25	; 0x1d
    8cf4:	ae 8f       	std	Y+30, r26	; 0x1e
    8cf6:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    8cf8:	8c a9       	sts	0x4c, r24
    8cfa:	9d a9       	sts	0x4d, r25
    8cfc:	ae a9       	sts	0x4e, r26
    8cfe:	bf a9       	sts	0x4f, r27
    8d00:	80 50       	subi	r24, 0x00	; 0
    8d02:	92 40       	sbci	r25, 0x02	; 2
    8d04:	a0 40       	sbci	r26, 0x00	; 0
    8d06:	b0 40       	sbci	r27, 0x00	; 0
    8d08:	8c ab       	sts	0x5c, r24
    8d0a:	9d ab       	sts	0x5d, r25
    8d0c:	ae ab       	sts	0x5e, r26
    8d0e:	bf ab       	sts	0x5f, r27
    8d10:	1f c0       	rjmp	.+62     	; 0x8d50 <writeFile+0x338>
	}
	else{
		writtenData += lengthOfData;
    8d12:	28 8d       	ldd	r18, Y+24	; 0x18
    8d14:	39 8d       	ldd	r19, Y+25	; 0x19
    8d16:	4a 8d       	ldd	r20, Y+26	; 0x1a
    8d18:	5b 8d       	ldd	r21, Y+27	; 0x1b
    8d1a:	8c a9       	sts	0x4c, r24
    8d1c:	9d a9       	sts	0x4d, r25
    8d1e:	ae a9       	sts	0x4e, r26
    8d20:	bf a9       	sts	0x4f, r27
    8d22:	82 0f       	add	r24, r18
    8d24:	93 1f       	adc	r25, r19
    8d26:	a4 1f       	adc	r26, r20
    8d28:	b5 1f       	adc	r27, r21
    8d2a:	88 8f       	std	Y+24, r24	; 0x18
    8d2c:	99 8f       	std	Y+25, r25	; 0x19
    8d2e:	aa 8f       	std	Y+26, r26	; 0x1a
    8d30:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    8d32:	8c a9       	sts	0x4c, r24
    8d34:	9d a9       	sts	0x4d, r25
    8d36:	ae a9       	sts	0x4e, r26
    8d38:	bf a9       	sts	0x4f, r27
    8d3a:	91 70       	andi	r25, 0x01	; 1
    8d3c:	a0 70       	andi	r26, 0x00	; 0
    8d3e:	b0 70       	andi	r27, 0x00	; 0
    8d40:	8c 8f       	std	Y+28, r24	; 0x1c
    8d42:	9d 8f       	std	Y+29, r25	; 0x1d
    8d44:	ae 8f       	std	Y+30, r26	; 0x1e
    8d46:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    8d48:	1c aa       	sts	0x9c, r17
    8d4a:	1d aa       	sts	0x9d, r17
    8d4c:	1e aa       	sts	0x9e, r17
    8d4e:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    8d50:	80 91 3d 40 	lds	r24, 0x403D
    8d54:	90 91 3e 40 	lds	r25, 0x403E
    8d58:	a0 91 3f 40 	lds	r26, 0x403F
    8d5c:	b0 91 40 40 	lds	r27, 0x4040
    8d60:	80 50       	subi	r24, 0x00	; 0
    8d62:	9e 4f       	sbci	r25, 0xFE	; 254
    8d64:	af 4f       	sbci	r26, 0xFF	; 255
    8d66:	bf 4f       	sbci	r27, 0xFF	; 255
    8d68:	80 93 3d 40 	sts	0x403D, r24
    8d6c:	90 93 3e 40 	sts	0x403E, r25
    8d70:	a0 93 3f 40 	sts	0x403F, r26
    8d74:	b0 93 40 40 	sts	0x4040, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    8d78:	8a 85       	ldd	r24, Y+10	; 0x0a
    8d7a:	9b 85       	ldd	r25, Y+11	; 0x0b
    8d7c:	cc 01       	movw	r24, r24
    8d7e:	a0 e0       	ldi	r26, 0x00	; 0
    8d80:	b0 e0       	ldi	r27, 0x00	; 0
    8d82:	48 8d       	ldd	r20, Y+24	; 0x18
    8d84:	59 8d       	ldd	r21, Y+25	; 0x19
    8d86:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8d88:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8d8a:	ba 01       	movw	r22, r20
    8d8c:	62 1b       	sub	r22, r18
    8d8e:	73 0b       	sbc	r23, r19
    8d90:	9b 01       	movw	r18, r22
    8d92:	4a a9       	sts	0x4a, r20
    8d94:	5b a9       	sts	0x4b, r21
    8d96:	42 0f       	add	r20, r18
    8d98:	53 1f       	adc	r21, r19
    8d9a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8d9c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8d9e:	bc 01       	movw	r22, r24
    8da0:	cd 01       	movw	r24, r26
    8da2:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <SD_write_block>
	j++;
    8da6:	89 81       	ldd	r24, Y+1	; 0x01
    8da8:	8f 5f       	subi	r24, 0xFF	; 255
    8daa:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    8dac:	89 81       	ldd	r24, Y+1	; 0x01
    8dae:	28 2f       	mov	r18, r24
    8db0:	30 e0       	ldi	r19, 0x00	; 0
    8db2:	80 91 70 50 	lds	r24, 0x5070
    8db6:	90 91 71 50 	lds	r25, 0x5071
    8dba:	28 17       	cp	r18, r24
    8dbc:	39 07       	cpc	r19, r25
    8dbe:	e1 f5       	brne	.+120    	; 0x8e38 <writeFile+0x420>
		j = 0; 
    8dc0:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    8dc2:	8c 85       	ldd	r24, Y+12	; 0x0c
    8dc4:	9d 85       	ldd	r25, Y+13	; 0x0d
    8dc6:	ae 85       	ldd	r26, Y+14	; 0x0e
    8dc8:	bf 85       	ldd	r27, Y+15	; 0x0f
    8dca:	88 8b       	std	Y+16, r24	; 0x10
    8dcc:	99 8b       	std	Y+17, r25	; 0x11
    8dce:	aa 8b       	std	Y+18, r26	; 0x12
    8dd0:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    8dd2:	88 89       	ldd	r24, Y+16	; 0x10
    8dd4:	99 89       	ldd	r25, Y+17	; 0x11
    8dd6:	aa 89       	ldd	r26, Y+18	; 0x12
    8dd8:	bb 89       	ldd	r27, Y+19	; 0x13
    8dda:	bc 01       	movw	r22, r24
    8ddc:	cd 01       	movw	r24, r26
    8dde:	0e 94 e2 48 	call	0x91c4	; 0x91c4 <searchNextFreeCluster>
    8de2:	dc 01       	movw	r26, r24
    8de4:	cb 01       	movw	r24, r22
    8de6:	8c 87       	std	Y+12, r24	; 0x0c
    8de8:	9d 87       	std	Y+13, r25	; 0x0d
    8dea:	ae 87       	std	Y+14, r26	; 0x0e
    8dec:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    8dee:	8c 85       	ldd	r24, Y+12	; 0x0c
    8df0:	9d 85       	ldd	r25, Y+13	; 0x0d
    8df2:	ae 85       	ldd	r26, Y+14	; 0x0e
    8df4:	bf 85       	ldd	r27, Y+15	; 0x0f
    8df6:	00 97       	sbiw	r24, 0x00	; 0
    8df8:	a1 05       	cpc	r26, r1
    8dfa:	b1 05       	cpc	r27, r1
    8dfc:	11 f4       	brne	.+4      	; 0x8e02 <writeFile+0x3ea>
		  //No free cluster!
		  return 2;
    8dfe:	82 e0       	ldi	r24, 0x02	; 2
    8e00:	d7 c1       	rjmp	.+942    	; 0x91b0 <writeFile+0x798>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    8e02:	88 89       	ldd	r24, Y+16	; 0x10
    8e04:	99 89       	ldd	r25, Y+17	; 0x11
    8e06:	aa 89       	ldd	r26, Y+18	; 0x12
    8e08:	bb 89       	ldd	r27, Y+19	; 0x13
    8e0a:	0c 85       	ldd	r16, Y+12	; 0x0c
    8e0c:	1d 85       	ldd	r17, Y+13	; 0x0d
    8e0e:	2e 85       	ldd	r18, Y+14	; 0x0e
    8e10:	3f 85       	ldd	r19, Y+15	; 0x0f
    8e12:	bc 01       	movw	r22, r24
    8e14:	cd 01       	movw	r24, r26
    8e16:	41 e0       	ldi	r20, 0x01	; 1
    8e18:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    8e1c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e1e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e20:	ae 85       	ldd	r26, Y+14	; 0x0e
    8e22:	bf 85       	ldd	r27, Y+15	; 0x0f
    8e24:	bc 01       	movw	r22, r24
    8e26:	cd 01       	movw	r24, r26
    8e28:	41 e0       	ldi	r20, 0x01	; 1
    8e2a:	0f ef       	ldi	r16, 0xFF	; 255
    8e2c:	1f ef       	ldi	r17, 0xFF	; 255
    8e2e:	2f ef       	ldi	r18, 0xFF	; 255
    8e30:	3f e0       	ldi	r19, 0x0F	; 15
    8e32:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
    8e36:	05 c0       	rjmp	.+10     	; 0x8e42 <writeFile+0x42a>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    8e38:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e3a:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e3c:	01 96       	adiw	r24, 0x01	; 1
    8e3e:	8a 87       	std	Y+10, r24	; 0x0a
    8e40:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    8e42:	2c 85       	ldd	r18, Y+12	; 0x0c
    8e44:	3d 85       	ldd	r19, Y+13	; 0x0d
    8e46:	4e 85       	ldd	r20, Y+14	; 0x0e
    8e48:	5f 85       	ldd	r21, Y+15	; 0x0f
    8e4a:	82 e0       	ldi	r24, 0x02	; 2
    8e4c:	61 e0       	ldi	r22, 0x01	; 1
    8e4e:	0e 94 9c 40 	call	0x8138	; 0x8138 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    8e52:	8c a9       	sts	0x4c, r24
    8e54:	9d a9       	sts	0x4d, r25
    8e56:	ae a9       	sts	0x4e, r26
    8e58:	bf a9       	sts	0x4f, r27
    8e5a:	00 97       	sbiw	r24, 0x00	; 0
    8e5c:	a1 05       	cpc	r26, r1
    8e5e:	b1 05       	cpc	r27, r1
    8e60:	09 f0       	breq	.+2      	; 0x8e64 <writeFile+0x44c>
    8e62:	2a cf       	rjmp	.-428    	; 0x8cb8 <writeFile+0x2a0>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    8e64:	8c 81       	ldd	r24, Y+4	; 0x04
    8e66:	88 23       	and	r24, r24
    8e68:	09 f4       	brne	.+2      	; 0x8e6c <writeFile+0x454>
    8e6a:	66 c0       	rjmp	.+204    	; 0x8f38 <writeFile+0x520>
{
  SD_read_block (appendFileSector,SDBuffer);    
    8e6c:	80 91 c6 50 	lds	r24, 0x50C6
    8e70:	90 91 c7 50 	lds	r25, 0x50C7
    8e74:	a0 91 c8 50 	lds	r26, 0x50C8
    8e78:	b0 91 c9 50 	lds	r27, 0x50C9
    8e7c:	23 ec       	ldi	r18, 0xC3	; 195
    8e7e:	31 e2       	ldi	r19, 0x21	; 33
    8e80:	bc 01       	movw	r22, r24
    8e82:	cd 01       	movw	r24, r26
    8e84:	a9 01       	movw	r20, r18
    8e86:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    8e8a:	80 91 c4 23 	lds	r24, 0x23C4
    8e8e:	90 91 c5 23 	lds	r25, 0x23C5
    8e92:	a0 91 c6 23 	lds	r26, 0x23C6
    8e96:	b0 91 c7 23 	lds	r27, 0x23C7
    8e9a:	8d 53       	subi	r24, 0x3D	; 61
    8e9c:	9e 4d       	sbci	r25, 0xDE	; 222
    8e9e:	8e a3       	lds	r24, 0x5e
    8ea0:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    8ea2:	8e a1       	lds	r24, 0x4e
    8ea4:	9f a1       	lds	r25, 0x4f
    8ea6:	fc 01       	movw	r30, r24
    8ea8:	12 8a       	std	Z+18, r1	; 0x12
    8eaa:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    8eac:	20 91 3d 40 	lds	r18, 0x403D
    8eb0:	30 91 3e 40 	lds	r19, 0x403E
    8eb4:	40 91 3f 40 	lds	r20, 0x403F
    8eb8:	50 91 40 40 	lds	r21, 0x4040
    8ebc:	8e a1       	lds	r24, 0x4e
    8ebe:	9f a1       	lds	r25, 0x4f
    8ec0:	fc 01       	movw	r30, r24
    8ec2:	84 8d       	ldd	r24, Z+28	; 0x1c
    8ec4:	95 8d       	ldd	r25, Z+29	; 0x1d
    8ec6:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8ec8:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8eca:	79 01       	movw	r14, r18
    8ecc:	8a 01       	movw	r16, r20
    8ece:	e8 1a       	sub	r14, r24
    8ed0:	f9 0a       	sbc	r15, r25
    8ed2:	0a 0b       	sbc	r16, r26
    8ed4:	1b 0b       	sbc	r17, r27
    8ed6:	d8 01       	movw	r26, r16
    8ed8:	c7 01       	movw	r24, r14
    8eda:	88 a7       	lds	r24, 0x78
    8edc:	99 a7       	lds	r25, 0x79
    8ede:	aa a7       	lds	r26, 0x7a
    8ee0:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    8ee2:	80 91 3d 40 	lds	r24, 0x403D
    8ee6:	90 91 3e 40 	lds	r25, 0x403E
    8eea:	a0 91 3f 40 	lds	r26, 0x403F
    8eee:	b0 91 40 40 	lds	r27, 0x4040
    8ef2:	2e a1       	lds	r18, 0x4e
    8ef4:	3f a1       	lds	r19, 0x4f
    8ef6:	f9 01       	movw	r30, r18
    8ef8:	84 8f       	std	Z+28, r24	; 0x1c
    8efa:	95 8f       	std	Z+29, r25	; 0x1d
    8efc:	a6 8f       	std	Z+30, r26	; 0x1e
    8efe:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    8f00:	80 91 c6 50 	lds	r24, 0x50C6
    8f04:	90 91 c7 50 	lds	r25, 0x50C7
    8f08:	a0 91 c8 50 	lds	r26, 0x50C8
    8f0c:	b0 91 c9 50 	lds	r27, 0x50C9
    8f10:	23 ec       	ldi	r18, 0xC3	; 195
    8f12:	31 e2       	ldi	r19, 0x21	; 33
    8f14:	bc 01       	movw	r22, r24
    8f16:	cd 01       	movw	r24, r26
    8f18:	a9 01       	movw	r20, r18
    8f1a:	20 e0       	ldi	r18, 0x00	; 0
    8f1c:	32 e0       	ldi	r19, 0x02	; 2
    8f1e:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    8f22:	28 a5       	lds	r18, 0x68
    8f24:	39 a5       	lds	r19, 0x69
    8f26:	4a a5       	lds	r20, 0x6a
    8f28:	5b a5       	lds	r21, 0x6b
    8f2a:	81 e0       	ldi	r24, 0x01	; 1
    8f2c:	ba 01       	movw	r22, r20
    8f2e:	a9 01       	movw	r20, r18
    8f30:	0e 94 bb 49 	call	0x9376	; 0x9376 <freeMemoryUpdate>

 //File appended!
  return 0;
    8f34:	80 e0       	ldi	r24, 0x00	; 0
    8f36:	3c c1       	rjmp	.+632    	; 0x91b0 <writeFile+0x798>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    8f38:	80 91 54 40 	lds	r24, 0x4054
    8f3c:	90 91 55 40 	lds	r25, 0x4055
    8f40:	a0 91 56 40 	lds	r26, 0x4056
    8f44:	b0 91 57 40 	lds	r27, 0x4057
    8f48:	88 8b       	std	Y+16, r24	; 0x10
    8f4a:	99 8b       	std	Y+17, r25	; 0x11
    8f4c:	aa 8b       	std	Y+18, r26	; 0x12
    8f4e:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    8f50:	88 89       	ldd	r24, Y+16	; 0x10
    8f52:	99 89       	ldd	r25, Y+17	; 0x11
    8f54:	aa 89       	ldd	r26, Y+18	; 0x12
    8f56:	bb 89       	ldd	r27, Y+19	; 0x13
    8f58:	bc 01       	movw	r22, r24
    8f5a:	cd 01       	movw	r24, r26
    8f5c:	0e 94 c0 3f 	call	0x7f80	; 0x7f80 <getFirstSector>
    8f60:	dc 01       	movw	r26, r24
    8f62:	cb 01       	movw	r24, r22
    8f64:	8c a7       	lds	r24, 0x7c
    8f66:	9d a7       	lds	r25, 0x7d
    8f68:	ae a7       	lds	r26, 0x7e
    8f6a:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    8f6c:	1d 82       	std	Y+5, r1	; 0x05
    8f6e:	ad c0       	rjmp	.+346    	; 0x90ca <writeFile+0x6b2>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    8f70:	8d 81       	ldd	r24, Y+5	; 0x05
    8f72:	28 2f       	mov	r18, r24
    8f74:	30 e0       	ldi	r19, 0x00	; 0
    8f76:	40 e0       	ldi	r20, 0x00	; 0
    8f78:	50 e0       	ldi	r21, 0x00	; 0
    8f7a:	8c a5       	lds	r24, 0x6c
    8f7c:	9d a5       	lds	r25, 0x6d
    8f7e:	ae a5       	lds	r26, 0x6e
    8f80:	bf a5       	lds	r27, 0x6f
    8f82:	82 0f       	add	r24, r18
    8f84:	93 1f       	adc	r25, r19
    8f86:	a4 1f       	adc	r26, r20
    8f88:	b5 1f       	adc	r27, r21
    8f8a:	23 ec       	ldi	r18, 0xC3	; 195
    8f8c:	31 e2       	ldi	r19, 0x21	; 33
    8f8e:	bc 01       	movw	r22, r24
    8f90:	cd 01       	movw	r24, r26
    8f92:	a9 01       	movw	r20, r18
    8f94:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    8f98:	18 a2       	lds	r17, 0x98
    8f9a:	19 a2       	lds	r17, 0x99
    8f9c:	89 c0       	rjmp	.+274    	; 0x90b0 <writeFile+0x698>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    8f9e:	88 a1       	lds	r24, 0x48
    8fa0:	99 a1       	lds	r25, 0x49
    8fa2:	8d 53       	subi	r24, 0x3D	; 61
    8fa4:	9e 4d       	sbci	r25, 0xDE	; 222
    8fa6:	8e a3       	lds	r24, 0x5e
    8fa8:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    8faa:	8a 81       	ldd	r24, Y+2	; 0x02
    8fac:	88 23       	and	r24, r24
    8fae:	11 f0       	breq	.+4      	; 0x8fb4 <writeFile+0x59c>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    8fb0:	80 e0       	ldi	r24, 0x00	; 0
    8fb2:	fe c0       	rjmp	.+508    	; 0x91b0 <writeFile+0x798>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    8fb4:	8e a1       	lds	r24, 0x4e
    8fb6:	9f a1       	lds	r25, 0x4f
    8fb8:	fc 01       	movw	r30, r24
    8fba:	80 81       	ld	r24, Z
    8fbc:	88 23       	and	r24, r24
    8fbe:	39 f0       	breq	.+14     	; 0x8fce <writeFile+0x5b6>
    8fc0:	8e a1       	lds	r24, 0x4e
    8fc2:	9f a1       	lds	r25, 0x4f
    8fc4:	fc 01       	movw	r30, r24
    8fc6:	80 81       	ld	r24, Z
    8fc8:	85 3e       	cpi	r24, 0xE5	; 229
    8fca:	09 f0       	breq	.+2      	; 0x8fce <writeFile+0x5b6>
    8fcc:	6c c0       	rjmp	.+216    	; 0x90a6 <writeFile+0x68e>
		{
		  for(j=0; j<11; j++)
    8fce:	19 82       	std	Y+1, r1	; 0x01
    8fd0:	13 c0       	rjmp	.+38     	; 0x8ff8 <writeFile+0x5e0>
  			dir->name[j] = Filename[j];
    8fd2:	89 81       	ldd	r24, Y+1	; 0x01
    8fd4:	88 2f       	mov	r24, r24
    8fd6:	90 e0       	ldi	r25, 0x00	; 0
    8fd8:	29 81       	ldd	r18, Y+1	; 0x01
    8fda:	22 2f       	mov	r18, r18
    8fdc:	30 e0       	ldi	r19, 0x00	; 0
    8fde:	20 55       	subi	r18, 0x50	; 80
    8fe0:	3f 4a       	sbci	r19, 0xAF	; 175
    8fe2:	f9 01       	movw	r30, r18
    8fe4:	40 81       	ld	r20, Z
    8fe6:	2e a1       	lds	r18, 0x4e
    8fe8:	3f a1       	lds	r19, 0x4f
    8fea:	82 0f       	add	r24, r18
    8fec:	93 1f       	adc	r25, r19
    8fee:	fc 01       	movw	r30, r24
    8ff0:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    8ff2:	89 81       	ldd	r24, Y+1	; 0x01
    8ff4:	8f 5f       	subi	r24, 0xFF	; 255
    8ff6:	89 83       	std	Y+1, r24	; 0x01
    8ff8:	89 81       	ldd	r24, Y+1	; 0x01
    8ffa:	8b 30       	cpi	r24, 0x0B	; 11
    8ffc:	50 f3       	brcs	.-44     	; 0x8fd2 <writeFile+0x5ba>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    8ffe:	8e a1       	lds	r24, 0x4e
    9000:	9f a1       	lds	r25, 0x4f
    9002:	20 e2       	ldi	r18, 0x20	; 32
    9004:	fc 01       	movw	r30, r24
    9006:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    9008:	8e a1       	lds	r24, 0x4e
    900a:	9f a1       	lds	r25, 0x4f
    900c:	fc 01       	movw	r30, r24
    900e:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    9010:	8e a1       	lds	r24, 0x4e
    9012:	9f a1       	lds	r25, 0x4f
    9014:	fc 01       	movw	r30, r24
    9016:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    9018:	8e a1       	lds	r24, 0x4e
    901a:	9f a1       	lds	r25, 0x4f
    901c:	fc 01       	movw	r30, r24
    901e:	12 8a       	std	Z+18, r1	; 0x12
    9020:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    9022:	8e a1       	lds	r24, 0x4e
    9024:	9f a1       	lds	r25, 0x4f
    9026:	2e 81       	ldd	r18, Y+6	; 0x06
    9028:	3f 81       	ldd	r19, Y+7	; 0x07
    902a:	fc 01       	movw	r30, r24
    902c:	24 8b       	std	Z+20, r18	; 0x14
    902e:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    9030:	8e a1       	lds	r24, 0x4e
    9032:	9f a1       	lds	r25, 0x4f
    9034:	28 85       	ldd	r18, Y+8	; 0x08
    9036:	39 85       	ldd	r19, Y+9	; 0x09
    9038:	fc 01       	movw	r30, r24
    903a:	22 8f       	std	Z+26, r18	; 0x1a
    903c:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    903e:	80 91 3d 40 	lds	r24, 0x403D
    9042:	90 91 3e 40 	lds	r25, 0x403E
    9046:	a0 91 3f 40 	lds	r26, 0x403F
    904a:	b0 91 40 40 	lds	r27, 0x4040
    904e:	2e a1       	lds	r18, 0x4e
    9050:	3f a1       	lds	r19, 0x4f
    9052:	f9 01       	movw	r30, r18
    9054:	84 8f       	std	Z+28, r24	; 0x1c
    9056:	95 8f       	std	Z+29, r25	; 0x1d
    9058:	a6 8f       	std	Z+30, r26	; 0x1e
    905a:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    905c:	8d 81       	ldd	r24, Y+5	; 0x05
    905e:	28 2f       	mov	r18, r24
    9060:	30 e0       	ldi	r19, 0x00	; 0
    9062:	40 e0       	ldi	r20, 0x00	; 0
    9064:	50 e0       	ldi	r21, 0x00	; 0
    9066:	8c a5       	lds	r24, 0x6c
    9068:	9d a5       	lds	r25, 0x6d
    906a:	ae a5       	lds	r26, 0x6e
    906c:	bf a5       	lds	r27, 0x6f
    906e:	82 0f       	add	r24, r18
    9070:	93 1f       	adc	r25, r19
    9072:	a4 1f       	adc	r26, r20
    9074:	b5 1f       	adc	r27, r21
    9076:	23 ec       	ldi	r18, 0xC3	; 195
    9078:	31 e2       	ldi	r19, 0x21	; 33
    907a:	bc 01       	movw	r22, r24
    907c:	cd 01       	movw	r24, r26
    907e:	a9 01       	movw	r20, r18
    9080:	20 e0       	ldi	r18, 0x00	; 0
    9082:	32 e0       	ldi	r19, 0x02	; 2
    9084:	0e 94 1e 4d 	call	0x9a3c	; 0x9a3c <SD_write_block>
		  fileCreatedFlag = 1;
    9088:	81 e0       	ldi	r24, 0x01	; 1
    908a:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    908c:	20 91 3d 40 	lds	r18, 0x403D
    9090:	30 91 3e 40 	lds	r19, 0x403E
    9094:	40 91 3f 40 	lds	r20, 0x403F
    9098:	50 91 40 40 	lds	r21, 0x4040
    909c:	81 e0       	ldi	r24, 0x01	; 1
    909e:	ba 01       	movw	r22, r20
    90a0:	a9 01       	movw	r20, r18
    90a2:	0e 94 bb 49 	call	0x9376	; 0x9376 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    90a6:	88 a1       	lds	r24, 0x48
    90a8:	99 a1       	lds	r25, 0x49
    90aa:	80 96       	adiw	r24, 0x20	; 32
    90ac:	88 a3       	lds	r24, 0x58
    90ae:	99 a3       	lds	r25, 0x59
    90b0:	28 a1       	lds	r18, 0x48
    90b2:	39 a1       	lds	r19, 0x49
    90b4:	80 91 41 40 	lds	r24, 0x4041
    90b8:	90 91 42 40 	lds	r25, 0x4042
    90bc:	28 17       	cp	r18, r24
    90be:	39 07       	cpc	r19, r25
    90c0:	08 f4       	brcc	.+2      	; 0x90c4 <writeFile+0x6ac>
    90c2:	6d cf       	rjmp	.-294    	; 0x8f9e <writeFile+0x586>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    90c4:	8d 81       	ldd	r24, Y+5	; 0x05
    90c6:	8f 5f       	subi	r24, 0xFF	; 255
    90c8:	8d 83       	std	Y+5, r24	; 0x05
    90ca:	8d 81       	ldd	r24, Y+5	; 0x05
    90cc:	28 2f       	mov	r18, r24
    90ce:	30 e0       	ldi	r19, 0x00	; 0
    90d0:	80 91 70 50 	lds	r24, 0x5070
    90d4:	90 91 71 50 	lds	r25, 0x5071
    90d8:	28 17       	cp	r18, r24
    90da:	39 07       	cpc	r19, r25
    90dc:	08 f4       	brcc	.+2      	; 0x90e0 <writeFile+0x6c8>
    90de:	48 cf       	rjmp	.-368    	; 0x8f70 <writeFile+0x558>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    90e0:	88 89       	ldd	r24, Y+16	; 0x10
    90e2:	99 89       	ldd	r25, Y+17	; 0x11
    90e4:	aa 89       	ldd	r26, Y+18	; 0x12
    90e6:	bb 89       	ldd	r27, Y+19	; 0x13
    90e8:	bc 01       	movw	r22, r24
    90ea:	cd 01       	movw	r24, r26
    90ec:	40 e0       	ldi	r20, 0x00	; 0
    90ee:	00 e0       	ldi	r16, 0x00	; 0
    90f0:	10 e0       	ldi	r17, 0x00	; 0
    90f2:	98 01       	movw	r18, r16
    90f4:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
    90f8:	dc 01       	movw	r26, r24
    90fa:	cb 01       	movw	r24, r22
    90fc:	8c 87       	std	Y+12, r24	; 0x0c
    90fe:	9d 87       	std	Y+13, r25	; 0x0d
    9100:	ae 87       	std	Y+14, r26	; 0x0e
    9102:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    9104:	8c 85       	ldd	r24, Y+12	; 0x0c
    9106:	9d 85       	ldd	r25, Y+13	; 0x0d
    9108:	ae 85       	ldd	r26, Y+14	; 0x0e
    910a:	bf 85       	ldd	r27, Y+15	; 0x0f
    910c:	87 3f       	cpi	r24, 0xF7	; 247
    910e:	ff ef       	ldi	r31, 0xFF	; 255
    9110:	9f 07       	cpc	r25, r31
    9112:	ff ef       	ldi	r31, 0xFF	; 255
    9114:	af 07       	cpc	r26, r31
    9116:	ff e0       	ldi	r31, 0x0F	; 15
    9118:	bf 07       	cpc	r27, r31
    911a:	b8 f1       	brcs	.+110    	; 0x918a <writeFile+0x772>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    911c:	8c 85       	ldd	r24, Y+12	; 0x0c
    911e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9120:	ae 85       	ldd	r26, Y+14	; 0x0e
    9122:	bf 85       	ldd	r27, Y+15	; 0x0f
    9124:	8f 3f       	cpi	r24, 0xFF	; 255
    9126:	0f ef       	ldi	r16, 0xFF	; 255
    9128:	90 07       	cpc	r25, r16
    912a:	0f ef       	ldi	r16, 0xFF	; 255
    912c:	a0 07       	cpc	r26, r16
    912e:	0f e0       	ldi	r16, 0x0F	; 15
    9130:	b0 07       	cpc	r27, r16
    9132:	49 f5       	brne	.+82     	; 0x9186 <writeFile+0x76e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9134:	88 89       	ldd	r24, Y+16	; 0x10
    9136:	99 89       	ldd	r25, Y+17	; 0x11
    9138:	aa 89       	ldd	r26, Y+18	; 0x12
    913a:	bb 89       	ldd	r27, Y+19	; 0x13
    913c:	bc 01       	movw	r22, r24
    913e:	cd 01       	movw	r24, r26
    9140:	0e 94 e2 48 	call	0x91c4	; 0x91c4 <searchNextFreeCluster>
    9144:	dc 01       	movw	r26, r24
    9146:	cb 01       	movw	r24, r22
    9148:	8c 87       	std	Y+12, r24	; 0x0c
    914a:	9d 87       	std	Y+13, r25	; 0x0d
    914c:	ae 87       	std	Y+14, r26	; 0x0e
    914e:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    9150:	88 89       	ldd	r24, Y+16	; 0x10
    9152:	99 89       	ldd	r25, Y+17	; 0x11
    9154:	aa 89       	ldd	r26, Y+18	; 0x12
    9156:	bb 89       	ldd	r27, Y+19	; 0x13
    9158:	0c 85       	ldd	r16, Y+12	; 0x0c
    915a:	1d 85       	ldd	r17, Y+13	; 0x0d
    915c:	2e 85       	ldd	r18, Y+14	; 0x0e
    915e:	3f 85       	ldd	r19, Y+15	; 0x0f
    9160:	bc 01       	movw	r22, r24
    9162:	cd 01       	movw	r24, r26
    9164:	41 e0       	ldi	r20, 0x01	; 1
    9166:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    916a:	8c 85       	ldd	r24, Y+12	; 0x0c
    916c:	9d 85       	ldd	r25, Y+13	; 0x0d
    916e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9170:	bf 85       	ldd	r27, Y+15	; 0x0f
    9172:	bc 01       	movw	r22, r24
    9174:	cd 01       	movw	r24, r26
    9176:	41 e0       	ldi	r20, 0x01	; 1
    9178:	0f ef       	ldi	r16, 0xFF	; 255
    917a:	1f ef       	ldi	r17, 0xFF	; 255
    917c:	2f ef       	ldi	r18, 0xFF	; 255
    917e:	3f e0       	ldi	r19, 0x0F	; 15
    9180:	0e 94 f2 3f 	call	0x7fe4	; 0x7fe4 <getSetNextCluster>
    9184:	02 c0       	rjmp	.+4      	; 0x918a <writeFile+0x772>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    9186:	83 e0       	ldi	r24, 0x03	; 3
    9188:	13 c0       	rjmp	.+38     	; 0x91b0 <writeFile+0x798>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    918a:	8c 85       	ldd	r24, Y+12	; 0x0c
    918c:	9d 85       	ldd	r25, Y+13	; 0x0d
    918e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9190:	bf 85       	ldd	r27, Y+15	; 0x0f
    9192:	00 97       	sbiw	r24, 0x00	; 0
    9194:	a1 05       	cpc	r26, r1
    9196:	b1 05       	cpc	r27, r1
    9198:	11 f4       	brne	.+4      	; 0x919e <writeFile+0x786>
	   return 4;
    919a:	84 e0       	ldi	r24, 0x04	; 4
    919c:	09 c0       	rjmp	.+18     	; 0x91b0 <writeFile+0x798>
	}
   
   prevCluster = cluster;
    919e:	8c 85       	ldd	r24, Y+12	; 0x0c
    91a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    91a2:	ae 85       	ldd	r26, Y+14	; 0x0e
    91a4:	bf 85       	ldd	r27, Y+15	; 0x0f
    91a6:	88 8b       	std	Y+16, r24	; 0x10
    91a8:	99 8b       	std	Y+17, r25	; 0x11
    91aa:	aa 8b       	std	Y+18, r26	; 0x12
    91ac:	bb 8b       	std	Y+19, r27	; 0x13
 }
    91ae:	d0 ce       	rjmp	.-608    	; 0x8f50 <writeFile+0x538>
 
 return 0;
}
    91b0:	e7 96       	adiw	r28, 0x37	; 55
    91b2:	cd bf       	out	0x3d, r28	; 61
    91b4:	de bf       	out	0x3e, r29	; 62
    91b6:	df 91       	pop	r29
    91b8:	cf 91       	pop	r28
    91ba:	1f 91       	pop	r17
    91bc:	0f 91       	pop	r16
    91be:	ff 90       	pop	r15
    91c0:	ef 90       	pop	r14
    91c2:	08 95       	ret

000091c4 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    91c4:	ef 92       	push	r14
    91c6:	ff 92       	push	r15
    91c8:	0f 93       	push	r16
    91ca:	1f 93       	push	r17
    91cc:	cf 93       	push	r28
    91ce:	df 93       	push	r29
    91d0:	cd b7       	in	r28, 0x3d	; 61
    91d2:	de b7       	in	r29, 0x3e	; 62
    91d4:	2f 97       	sbiw	r28, 0x0f	; 15
    91d6:	cd bf       	out	0x3d, r28	; 61
    91d8:	de bf       	out	0x3e, r29	; 62
    91da:	6c 87       	std	Y+12, r22	; 0x0c
    91dc:	7d 87       	std	Y+13, r23	; 0x0d
    91de:	8e 87       	std	Y+14, r24	; 0x0e
    91e0:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    91e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    91e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    91e6:	ae 85       	ldd	r26, Y+14	; 0x0e
    91e8:	bf 85       	ldd	r27, Y+15	; 0x0f
    91ea:	80 78       	andi	r24, 0x80	; 128
    91ec:	8c 87       	std	Y+12, r24	; 0x0c
    91ee:	9d 87       	std	Y+13, r25	; 0x0d
    91f0:	ae 87       	std	Y+14, r26	; 0x0e
    91f2:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    91f4:	8c 85       	ldd	r24, Y+12	; 0x0c
    91f6:	9d 85       	ldd	r25, Y+13	; 0x0d
    91f8:	ae 85       	ldd	r26, Y+14	; 0x0e
    91fa:	bf 85       	ldd	r27, Y+15	; 0x0f
    91fc:	89 83       	std	Y+1, r24	; 0x01
    91fe:	9a 83       	std	Y+2, r25	; 0x02
    9200:	ab 83       	std	Y+3, r26	; 0x03
    9202:	bc 83       	std	Y+4, r27	; 0x04
    9204:	7a c0       	rjmp	.+244    	; 0x92fa <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9206:	80 91 78 50 	lds	r24, 0x5078
    920a:	90 91 79 50 	lds	r25, 0x5079
    920e:	9c 01       	movw	r18, r24
    9210:	40 e0       	ldi	r20, 0x00	; 0
    9212:	50 e0       	ldi	r21, 0x00	; 0
    9214:	80 91 72 50 	lds	r24, 0x5072
    9218:	90 91 73 50 	lds	r25, 0x5073
    921c:	a0 91 74 50 	lds	r26, 0x5074
    9220:	b0 91 75 50 	lds	r27, 0x5075
    9224:	79 01       	movw	r14, r18
    9226:	8a 01       	movw	r16, r20
    9228:	e8 0e       	add	r14, r24
    922a:	f9 1e       	adc	r15, r25
    922c:	0a 1f       	adc	r16, r26
    922e:	1b 1f       	adc	r17, r27
    9230:	89 81       	ldd	r24, Y+1	; 0x01
    9232:	9a 81       	ldd	r25, Y+2	; 0x02
    9234:	ab 81       	ldd	r26, Y+3	; 0x03
    9236:	bc 81       	ldd	r27, Y+4	; 0x04
    9238:	88 0f       	add	r24, r24
    923a:	99 1f       	adc	r25, r25
    923c:	aa 1f       	adc	r26, r26
    923e:	bb 1f       	adc	r27, r27
    9240:	88 0f       	add	r24, r24
    9242:	99 1f       	adc	r25, r25
    9244:	aa 1f       	adc	r26, r26
    9246:	bb 1f       	adc	r27, r27
    9248:	20 91 41 40 	lds	r18, 0x4041
    924c:	30 91 42 40 	lds	r19, 0x4042
    9250:	99 01       	movw	r18, r18
    9252:	40 e0       	ldi	r20, 0x00	; 0
    9254:	50 e0       	ldi	r21, 0x00	; 0
    9256:	bc 01       	movw	r22, r24
    9258:	cd 01       	movw	r24, r26
    925a:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    925e:	da 01       	movw	r26, r20
    9260:	c9 01       	movw	r24, r18
    9262:	8e 0d       	add	r24, r14
    9264:	9f 1d       	adc	r25, r15
    9266:	a0 1f       	adc	r26, r16
    9268:	b1 1f       	adc	r27, r17
    926a:	8e 83       	std	Y+6, r24	; 0x06
    926c:	9f 83       	std	Y+7, r25	; 0x07
    926e:	a8 87       	std	Y+8, r26	; 0x08
    9270:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    9272:	8e 81       	ldd	r24, Y+6	; 0x06
    9274:	9f 81       	ldd	r25, Y+7	; 0x07
    9276:	a8 85       	ldd	r26, Y+8	; 0x08
    9278:	b9 85       	ldd	r27, Y+9	; 0x09
    927a:	23 ec       	ldi	r18, 0xC3	; 195
    927c:	31 e2       	ldi	r19, 0x21	; 33
    927e:	bc 01       	movw	r22, r24
    9280:	cd 01       	movw	r24, r26
    9282:	a9 01       	movw	r20, r18
    9284:	0e 94 ec 4d 	call	0x9bd8	; 0x9bd8 <SD_read_block>
      for(i=0; i<128; i++)
    9288:	1d 82       	std	Y+5, r1	; 0x05
    928a:	28 c0       	rjmp	.+80     	; 0x92dc <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    928c:	8d 81       	ldd	r24, Y+5	; 0x05
    928e:	88 2f       	mov	r24, r24
    9290:	90 e0       	ldi	r25, 0x00	; 0
    9292:	88 0f       	add	r24, r24
    9294:	99 1f       	adc	r25, r25
    9296:	88 0f       	add	r24, r24
    9298:	99 1f       	adc	r25, r25
    929a:	8d 53       	subi	r24, 0x3D	; 61
    929c:	9e 4d       	sbci	r25, 0xDE	; 222
    929e:	8a 87       	std	Y+10, r24	; 0x0a
    92a0:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    92a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    92a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    92a6:	fc 01       	movw	r30, r24
    92a8:	80 81       	ld	r24, Z
    92aa:	91 81       	ldd	r25, Z+1	; 0x01
    92ac:	a2 81       	ldd	r26, Z+2	; 0x02
    92ae:	b3 81       	ldd	r27, Z+3	; 0x03
    92b0:	bf 70       	andi	r27, 0x0F	; 15
    92b2:	00 97       	sbiw	r24, 0x00	; 0
    92b4:	a1 05       	cpc	r26, r1
    92b6:	b1 05       	cpc	r27, r1
    92b8:	71 f4       	brne	.+28     	; 0x92d6 <searchNextFreeCluster+0x112>
            return(cluster+i);
    92ba:	8d 81       	ldd	r24, Y+5	; 0x05
    92bc:	28 2f       	mov	r18, r24
    92be:	30 e0       	ldi	r19, 0x00	; 0
    92c0:	40 e0       	ldi	r20, 0x00	; 0
    92c2:	50 e0       	ldi	r21, 0x00	; 0
    92c4:	89 81       	ldd	r24, Y+1	; 0x01
    92c6:	9a 81       	ldd	r25, Y+2	; 0x02
    92c8:	ab 81       	ldd	r26, Y+3	; 0x03
    92ca:	bc 81       	ldd	r27, Y+4	; 0x04
    92cc:	82 0f       	add	r24, r18
    92ce:	93 1f       	adc	r25, r19
    92d0:	a4 1f       	adc	r26, r20
    92d2:	b5 1f       	adc	r27, r21
    92d4:	27 c0       	rjmp	.+78     	; 0x9324 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    92d6:	8d 81       	ldd	r24, Y+5	; 0x05
    92d8:	8f 5f       	subi	r24, 0xFF	; 255
    92da:	8d 83       	std	Y+5, r24	; 0x05
    92dc:	8d 81       	ldd	r24, Y+5	; 0x05
    92de:	88 23       	and	r24, r24
    92e0:	ac f6       	brge	.-86     	; 0x928c <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    92e2:	89 81       	ldd	r24, Y+1	; 0x01
    92e4:	9a 81       	ldd	r25, Y+2	; 0x02
    92e6:	ab 81       	ldd	r26, Y+3	; 0x03
    92e8:	bc 81       	ldd	r27, Y+4	; 0x04
    92ea:	80 58       	subi	r24, 0x80	; 128
    92ec:	9f 4f       	sbci	r25, 0xFF	; 255
    92ee:	af 4f       	sbci	r26, 0xFF	; 255
    92f0:	bf 4f       	sbci	r27, 0xFF	; 255
    92f2:	89 83       	std	Y+1, r24	; 0x01
    92f4:	9a 83       	std	Y+2, r25	; 0x02
    92f6:	ab 83       	std	Y+3, r26	; 0x03
    92f8:	bc 83       	std	Y+4, r27	; 0x04
    92fa:	80 91 4e 40 	lds	r24, 0x404E
    92fe:	90 91 4f 40 	lds	r25, 0x404F
    9302:	a0 91 50 40 	lds	r26, 0x4050
    9306:	b0 91 51 40 	lds	r27, 0x4051
    930a:	29 81       	ldd	r18, Y+1	; 0x01
    930c:	3a 81       	ldd	r19, Y+2	; 0x02
    930e:	4b 81       	ldd	r20, Y+3	; 0x03
    9310:	5c 81       	ldd	r21, Y+4	; 0x04
    9312:	28 17       	cp	r18, r24
    9314:	39 07       	cpc	r19, r25
    9316:	4a 07       	cpc	r20, r26
    9318:	5b 07       	cpc	r21, r27
    931a:	08 f4       	brcc	.+2      	; 0x931e <searchNextFreeCluster+0x15a>
    931c:	74 cf       	rjmp	.-280    	; 0x9206 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    931e:	80 e0       	ldi	r24, 0x00	; 0
    9320:	90 e0       	ldi	r25, 0x00	; 0
    9322:	dc 01       	movw	r26, r24
}
    9324:	bc 01       	movw	r22, r24
    9326:	cd 01       	movw	r24, r26
    9328:	2f 96       	adiw	r28, 0x0f	; 15
    932a:	cd bf       	out	0x3d, r28	; 61
    932c:	de bf       	out	0x3e, r29	; 62
    932e:	df 91       	pop	r29
    9330:	cf 91       	pop	r28
    9332:	1f 91       	pop	r17
    9334:	0f 91       	pop	r16
    9336:	ff 90       	pop	r15
    9338:	ef 90       	pop	r14
    933a:	08 95       	ret

0000933c <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    933c:	cf 93       	push	r28
    933e:	df 93       	push	r29
    9340:	00 d0       	rcall	.+0      	; 0x9342 <deleteFile+0x6>
    9342:	cd b7       	in	r28, 0x3d	; 61
    9344:	de b7       	in	r29, 0x3e	; 62
    9346:	8a 83       	std	Y+2, r24	; 0x02
    9348:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    934a:	8a 81       	ldd	r24, Y+2	; 0x02
    934c:	9b 81       	ldd	r25, Y+3	; 0x03
    934e:	0e 94 d6 43 	call	0x87ac	; 0x87ac <convertFileName>
    9352:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9354:	89 81       	ldd	r24, Y+1	; 0x01
    9356:	88 23       	and	r24, r24
    9358:	39 f4       	brne	.+14     	; 0x9368 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    935a:	20 eb       	ldi	r18, 0xB0	; 176
    935c:	30 e5       	ldi	r19, 0x50	; 80
    935e:	82 e0       	ldi	r24, 0x02	; 2
    9360:	b9 01       	movw	r22, r18
    9362:	0e 94 4d 41 	call	0x829a	; 0x829a <findFiles>
    9366:	01 c0       	rjmp	.+2      	; 0x936a <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9368:	00 00       	nop

  findFiles (DELETE, Filename);
}
    936a:	23 96       	adiw	r28, 0x03	; 3
    936c:	cd bf       	out	0x3d, r28	; 61
    936e:	de bf       	out	0x3e, r29	; 62
    9370:	df 91       	pop	r29
    9372:	cf 91       	pop	r28
    9374:	08 95       	ret

00009376 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9376:	ef 92       	push	r14
    9378:	ff 92       	push	r15
    937a:	0f 93       	push	r16
    937c:	1f 93       	push	r17
    937e:	cf 93       	push	r28
    9380:	df 93       	push	r29
    9382:	cd b7       	in	r28, 0x3d	; 61
    9384:	de b7       	in	r29, 0x3e	; 62
    9386:	29 97       	sbiw	r28, 0x09	; 9
    9388:	cd bf       	out	0x3d, r28	; 61
    938a:	de bf       	out	0x3e, r29	; 62
    938c:	8d 83       	std	Y+5, r24	; 0x05
    938e:	4e 83       	std	Y+6, r20	; 0x06
    9390:	5f 83       	std	Y+7, r21	; 0x07
    9392:	68 87       	std	Y+8, r22	; 0x08
    9394:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    9396:	8e 81       	ldd	r24, Y+6	; 0x06
    9398:	9f 81       	ldd	r25, Y+7	; 0x07
    939a:	a8 85       	ldd	r26, Y+8	; 0x08
    939c:	b9 85       	ldd	r27, Y+9	; 0x09
    939e:	91 70       	andi	r25, 0x01	; 1
    93a0:	a0 70       	andi	r26, 0x00	; 0
    93a2:	b0 70       	andi	r27, 0x00	; 0
    93a4:	00 97       	sbiw	r24, 0x00	; 0
    93a6:	a1 05       	cpc	r26, r1
    93a8:	b1 05       	cpc	r27, r1
    93aa:	91 f4       	brne	.+36     	; 0x93d0 <freeMemoryUpdate+0x5a>
    93ac:	8e 81       	ldd	r24, Y+6	; 0x06
    93ae:	9f 81       	ldd	r25, Y+7	; 0x07
    93b0:	a8 85       	ldd	r26, Y+8	; 0x08
    93b2:	b9 85       	ldd	r27, Y+9	; 0x09
    93b4:	07 2e       	mov	r0, r23
    93b6:	79 e0       	ldi	r23, 0x09	; 9
    93b8:	b6 95       	lsr	r27
    93ba:	a7 95       	ror	r26
    93bc:	97 95       	ror	r25
    93be:	87 95       	ror	r24
    93c0:	7a 95       	dec	r23
    93c2:	d1 f7       	brne	.-12     	; 0x93b8 <freeMemoryUpdate+0x42>
    93c4:	70 2d       	mov	r23, r0
    93c6:	8e 83       	std	Y+6, r24	; 0x06
    93c8:	9f 83       	std	Y+7, r25	; 0x07
    93ca:	a8 87       	std	Y+8, r26	; 0x08
    93cc:	b9 87       	std	Y+9, r27	; 0x09
    93ce:	14 c0       	rjmp	.+40     	; 0x93f8 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    93d0:	8e 81       	ldd	r24, Y+6	; 0x06
    93d2:	9f 81       	ldd	r25, Y+7	; 0x07
    93d4:	a8 85       	ldd	r26, Y+8	; 0x08
    93d6:	b9 85       	ldd	r27, Y+9	; 0x09
    93d8:	07 2e       	mov	r0, r23
    93da:	79 e0       	ldi	r23, 0x09	; 9
    93dc:	b6 95       	lsr	r27
    93de:	a7 95       	ror	r26
    93e0:	97 95       	ror	r25
    93e2:	87 95       	ror	r24
    93e4:	7a 95       	dec	r23
    93e6:	d1 f7       	brne	.-12     	; 0x93dc <freeMemoryUpdate+0x66>
    93e8:	70 2d       	mov	r23, r0
    93ea:	01 96       	adiw	r24, 0x01	; 1
    93ec:	a1 1d       	adc	r26, r1
    93ee:	b1 1d       	adc	r27, r1
    93f0:	8e 83       	std	Y+6, r24	; 0x06
    93f2:	9f 83       	std	Y+7, r25	; 0x07
    93f4:	a8 87       	std	Y+8, r26	; 0x08
    93f6:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    93f8:	8e 81       	ldd	r24, Y+6	; 0x06
    93fa:	9f 81       	ldd	r25, Y+7	; 0x07
    93fc:	a8 85       	ldd	r26, Y+8	; 0x08
    93fe:	b9 85       	ldd	r27, Y+9	; 0x09
    9400:	87 70       	andi	r24, 0x07	; 7
    9402:	90 70       	andi	r25, 0x00	; 0
    9404:	a0 70       	andi	r26, 0x00	; 0
    9406:	b0 70       	andi	r27, 0x00	; 0
    9408:	00 97       	sbiw	r24, 0x00	; 0
    940a:	a1 05       	cpc	r26, r1
    940c:	b1 05       	cpc	r27, r1
    940e:	89 f4       	brne	.+34     	; 0x9432 <freeMemoryUpdate+0xbc>
    9410:	8e 81       	ldd	r24, Y+6	; 0x06
    9412:	9f 81       	ldd	r25, Y+7	; 0x07
    9414:	a8 85       	ldd	r26, Y+8	; 0x08
    9416:	b9 85       	ldd	r27, Y+9	; 0x09
    9418:	68 94       	set
    941a:	12 f8       	bld	r1, 2
    941c:	b6 95       	lsr	r27
    941e:	a7 95       	ror	r26
    9420:	97 95       	ror	r25
    9422:	87 95       	ror	r24
    9424:	16 94       	lsr	r1
    9426:	d1 f7       	brne	.-12     	; 0x941c <freeMemoryUpdate+0xa6>
    9428:	8e 83       	std	Y+6, r24	; 0x06
    942a:	9f 83       	std	Y+7, r25	; 0x07
    942c:	a8 87       	std	Y+8, r26	; 0x08
    942e:	b9 87       	std	Y+9, r27	; 0x09
    9430:	13 c0       	rjmp	.+38     	; 0x9458 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    9432:	8e 81       	ldd	r24, Y+6	; 0x06
    9434:	9f 81       	ldd	r25, Y+7	; 0x07
    9436:	a8 85       	ldd	r26, Y+8	; 0x08
    9438:	b9 85       	ldd	r27, Y+9	; 0x09
    943a:	68 94       	set
    943c:	12 f8       	bld	r1, 2
    943e:	b6 95       	lsr	r27
    9440:	a7 95       	ror	r26
    9442:	97 95       	ror	r25
    9444:	87 95       	ror	r24
    9446:	16 94       	lsr	r1
    9448:	d1 f7       	brne	.-12     	; 0x943e <freeMemoryUpdate+0xc8>
    944a:	01 96       	adiw	r24, 0x01	; 1
    944c:	a1 1d       	adc	r26, r1
    944e:	b1 1d       	adc	r27, r1
    9450:	8e 83       	std	Y+6, r24	; 0x06
    9452:	9f 83       	std	Y+7, r25	; 0x07
    9454:	a8 87       	std	Y+8, r26	; 0x08
    9456:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9458:	80 91 c4 50 	lds	r24, 0x50C4
    945c:	88 23       	and	r24, r24
    945e:	e9 f1       	breq	.+122    	; 0x94da <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    9460:	81 e0       	ldi	r24, 0x01	; 1
    9462:	60 e0       	ldi	r22, 0x00	; 0
    9464:	20 e0       	ldi	r18, 0x00	; 0
    9466:	30 e0       	ldi	r19, 0x00	; 0
    9468:	a9 01       	movw	r20, r18
    946a:	0e 94 9c 40 	call	0x8138	; 0x8138 <getSetFreeCluster>
    946e:	dc 01       	movw	r26, r24
    9470:	cb 01       	movw	r24, r22
    9472:	89 83       	std	Y+1, r24	; 0x01
    9474:	9a 83       	std	Y+2, r25	; 0x02
    9476:	ab 83       	std	Y+3, r26	; 0x03
    9478:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    947a:	8d 81       	ldd	r24, Y+5	; 0x05
    947c:	88 23       	and	r24, r24
    947e:	89 f4       	brne	.+34     	; 0x94a2 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    9480:	29 81       	ldd	r18, Y+1	; 0x01
    9482:	3a 81       	ldd	r19, Y+2	; 0x02
    9484:	4b 81       	ldd	r20, Y+3	; 0x03
    9486:	5c 81       	ldd	r21, Y+4	; 0x04
    9488:	8e 81       	ldd	r24, Y+6	; 0x06
    948a:	9f 81       	ldd	r25, Y+7	; 0x07
    948c:	a8 85       	ldd	r26, Y+8	; 0x08
    948e:	b9 85       	ldd	r27, Y+9	; 0x09
    9490:	82 0f       	add	r24, r18
    9492:	93 1f       	adc	r25, r19
    9494:	a4 1f       	adc	r26, r20
    9496:	b5 1f       	adc	r27, r21
    9498:	89 83       	std	Y+1, r24	; 0x01
    949a:	9a 83       	std	Y+2, r25	; 0x02
    949c:	ab 83       	std	Y+3, r26	; 0x03
    949e:	bc 83       	std	Y+4, r27	; 0x04
    94a0:	14 c0       	rjmp	.+40     	; 0x94ca <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    94a2:	29 81       	ldd	r18, Y+1	; 0x01
    94a4:	3a 81       	ldd	r19, Y+2	; 0x02
    94a6:	4b 81       	ldd	r20, Y+3	; 0x03
    94a8:	5c 81       	ldd	r21, Y+4	; 0x04
    94aa:	8e 81       	ldd	r24, Y+6	; 0x06
    94ac:	9f 81       	ldd	r25, Y+7	; 0x07
    94ae:	a8 85       	ldd	r26, Y+8	; 0x08
    94b0:	b9 85       	ldd	r27, Y+9	; 0x09
    94b2:	79 01       	movw	r14, r18
    94b4:	8a 01       	movw	r16, r20
    94b6:	e8 1a       	sub	r14, r24
    94b8:	f9 0a       	sbc	r15, r25
    94ba:	0a 0b       	sbc	r16, r26
    94bc:	1b 0b       	sbc	r17, r27
    94be:	d8 01       	movw	r26, r16
    94c0:	c7 01       	movw	r24, r14
    94c2:	89 83       	std	Y+1, r24	; 0x01
    94c4:	9a 83       	std	Y+2, r25	; 0x02
    94c6:	ab 83       	std	Y+3, r26	; 0x03
    94c8:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    94ca:	29 81       	ldd	r18, Y+1	; 0x01
    94cc:	3a 81       	ldd	r19, Y+2	; 0x02
    94ce:	4b 81       	ldd	r20, Y+3	; 0x03
    94d0:	5c 81       	ldd	r21, Y+4	; 0x04
    94d2:	81 e0       	ldi	r24, 0x01	; 1
    94d4:	61 e0       	ldi	r22, 0x01	; 1
    94d6:	0e 94 9c 40 	call	0x8138	; 0x8138 <getSetFreeCluster>
  }
}
    94da:	29 96       	adiw	r28, 0x09	; 9
    94dc:	cd bf       	out	0x3d, r28	; 61
    94de:	de bf       	out	0x3e, r29	; 62
    94e0:	df 91       	pop	r29
    94e2:	cf 91       	pop	r28
    94e4:	1f 91       	pop	r17
    94e6:	0f 91       	pop	r16
    94e8:	ff 90       	pop	r15
    94ea:	ef 90       	pop	r14
    94ec:	08 95       	ret

000094ee <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    94ee:	0f 93       	push	r16
    94f0:	1f 93       	push	r17
    94f2:	cf 93       	push	r28
    94f4:	df 93       	push	r29
    94f6:	cd b7       	in	r28, 0x3d	; 61
    94f8:	de b7       	in	r29, 0x3e	; 62
    94fa:	a9 97       	sbiw	r28, 0x29	; 41
    94fc:	cd bf       	out	0x3d, r28	; 61
    94fe:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    9500:	81 e0       	ldi	r24, 0x01	; 1
    9502:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9506:	81 e0       	ldi	r24, 0x01	; 1
    9508:	0e 94 05 34 	call	0x680a	; 0x680a <Ext1Power>
    950c:	80 e0       	ldi	r24, 0x00	; 0
    950e:	90 e0       	ldi	r25, 0x00	; 0
    9510:	a8 ec       	ldi	r26, 0xC8	; 200
    9512:	b2 e4       	ldi	r27, 0x42	; 66
    9514:	8e 87       	std	Y+14, r24	; 0x0e
    9516:	9f 87       	std	Y+15, r25	; 0x0f
    9518:	a8 8b       	std	Y+16, r26	; 0x10
    951a:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    951c:	6e 85       	ldd	r22, Y+14	; 0x0e
    951e:	7f 85       	ldd	r23, Y+15	; 0x0f
    9520:	88 89       	ldd	r24, Y+16	; 0x10
    9522:	99 89       	ldd	r25, Y+17	; 0x11
    9524:	20 e0       	ldi	r18, 0x00	; 0
    9526:	30 e0       	ldi	r19, 0x00	; 0
    9528:	4a ef       	ldi	r20, 0xFA	; 250
    952a:	55 e4       	ldi	r21, 0x45	; 69
    952c:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    9530:	dc 01       	movw	r26, r24
    9532:	cb 01       	movw	r24, r22
    9534:	8a 8b       	std	Y+18, r24	; 0x12
    9536:	9b 8b       	std	Y+19, r25	; 0x13
    9538:	ac 8b       	std	Y+20, r26	; 0x14
    953a:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    953c:	11 e0       	ldi	r17, 0x01	; 1
    953e:	6a 89       	ldd	r22, Y+18	; 0x12
    9540:	7b 89       	ldd	r23, Y+19	; 0x13
    9542:	8c 89       	ldd	r24, Y+20	; 0x14
    9544:	9d 89       	ldd	r25, Y+21	; 0x15
    9546:	20 e0       	ldi	r18, 0x00	; 0
    9548:	30 e0       	ldi	r19, 0x00	; 0
    954a:	40 e8       	ldi	r20, 0x80	; 128
    954c:	5f e3       	ldi	r21, 0x3F	; 63
    954e:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    9552:	88 23       	and	r24, r24
    9554:	0c f0       	brlt	.+2      	; 0x9558 <SD_init+0x6a>
    9556:	10 e0       	ldi	r17, 0x00	; 0
    9558:	11 23       	and	r17, r17
    955a:	29 f0       	breq	.+10     	; 0x9566 <SD_init+0x78>
		__ticks = 1;
    955c:	81 e0       	ldi	r24, 0x01	; 1
    955e:	90 e0       	ldi	r25, 0x00	; 0
    9560:	8e 8b       	std	Y+22, r24	; 0x16
    9562:	9f 8b       	std	Y+23, r25	; 0x17
    9564:	46 c0       	rjmp	.+140    	; 0x95f2 <SD_init+0x104>
	else if (__tmp > 65535)
    9566:	11 e0       	ldi	r17, 0x01	; 1
    9568:	6a 89       	ldd	r22, Y+18	; 0x12
    956a:	7b 89       	ldd	r23, Y+19	; 0x13
    956c:	8c 89       	ldd	r24, Y+20	; 0x14
    956e:	9d 89       	ldd	r25, Y+21	; 0x15
    9570:	20 e0       	ldi	r18, 0x00	; 0
    9572:	3f ef       	ldi	r19, 0xFF	; 255
    9574:	4f e7       	ldi	r20, 0x7F	; 127
    9576:	57 e4       	ldi	r21, 0x47	; 71
    9578:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    957c:	18 16       	cp	r1, r24
    957e:	0c f0       	brlt	.+2      	; 0x9582 <SD_init+0x94>
    9580:	10 e0       	ldi	r17, 0x00	; 0
    9582:	11 23       	and	r17, r17
    9584:	61 f1       	breq	.+88     	; 0x95de <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9586:	6e 85       	ldd	r22, Y+14	; 0x0e
    9588:	7f 85       	ldd	r23, Y+15	; 0x0f
    958a:	88 89       	ldd	r24, Y+16	; 0x10
    958c:	99 89       	ldd	r25, Y+17	; 0x11
    958e:	20 e0       	ldi	r18, 0x00	; 0
    9590:	30 e0       	ldi	r19, 0x00	; 0
    9592:	40 e2       	ldi	r20, 0x20	; 32
    9594:	51 e4       	ldi	r21, 0x41	; 65
    9596:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    959a:	dc 01       	movw	r26, r24
    959c:	cb 01       	movw	r24, r22
    959e:	bc 01       	movw	r22, r24
    95a0:	cd 01       	movw	r24, r26
    95a2:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    95a6:	dc 01       	movw	r26, r24
    95a8:	cb 01       	movw	r24, r22
    95aa:	8e 8b       	std	Y+22, r24	; 0x16
    95ac:	9f 8b       	std	Y+23, r25	; 0x17
    95ae:	12 c0       	rjmp	.+36     	; 0x95d4 <SD_init+0xe6>
    95b0:	80 e2       	ldi	r24, 0x20	; 32
    95b2:	93 e0       	ldi	r25, 0x03	; 3
    95b4:	88 8f       	std	Y+24, r24	; 0x18
    95b6:	99 8f       	std	Y+25, r25	; 0x19
    95b8:	88 8d       	ldd	r24, Y+24	; 0x18
    95ba:	99 8d       	ldd	r25, Y+25	; 0x19
    95bc:	8c 01       	movw	r16, r24
    95be:	c8 01       	movw	r24, r16
    95c0:	01 97       	sbiw	r24, 0x01	; 1
    95c2:	f1 f7       	brne	.-4      	; 0x95c0 <SD_init+0xd2>
    95c4:	8c 01       	movw	r16, r24
    95c6:	08 8f       	std	Y+24, r16	; 0x18
    95c8:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    95ca:	8e 89       	ldd	r24, Y+22	; 0x16
    95cc:	9f 89       	ldd	r25, Y+23	; 0x17
    95ce:	01 97       	sbiw	r24, 0x01	; 1
    95d0:	8e 8b       	std	Y+22, r24	; 0x16
    95d2:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    95d4:	8e 89       	ldd	r24, Y+22	; 0x16
    95d6:	9f 89       	ldd	r25, Y+23	; 0x17
    95d8:	00 97       	sbiw	r24, 0x00	; 0
    95da:	51 f7       	brne	.-44     	; 0x95b0 <SD_init+0xc2>
    95dc:	17 c0       	rjmp	.+46     	; 0x960c <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    95de:	6a 89       	ldd	r22, Y+18	; 0x12
    95e0:	7b 89       	ldd	r23, Y+19	; 0x13
    95e2:	8c 89       	ldd	r24, Y+20	; 0x14
    95e4:	9d 89       	ldd	r25, Y+21	; 0x15
    95e6:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    95ea:	dc 01       	movw	r26, r24
    95ec:	cb 01       	movw	r24, r22
    95ee:	8e 8b       	std	Y+22, r24	; 0x16
    95f0:	9f 8b       	std	Y+23, r25	; 0x17
    95f2:	8e 89       	ldd	r24, Y+22	; 0x16
    95f4:	9f 89       	ldd	r25, Y+23	; 0x17
    95f6:	8a 8f       	std	Y+26, r24	; 0x1a
    95f8:	9b 8f       	std	Y+27, r25	; 0x1b
    95fa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    95fc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    95fe:	8c 01       	movw	r16, r24
    9600:	f8 01       	movw	r30, r16
    9602:	31 97       	sbiw	r30, 0x01	; 1
    9604:	f1 f7       	brne	.-4      	; 0x9602 <SD_init+0x114>
    9606:	8f 01       	movw	r16, r30
    9608:	0a 8f       	std	Y+26, r16	; 0x1a
    960a:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    960c:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    960e:	88 e0       	ldi	r24, 0x08	; 8
    9610:	60 e0       	ldi	r22, 0x00	; 0
    9612:	0e 94 6f 32 	call	0x64de	; 0x64de <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9616:	88 e0       	ldi	r24, 0x08	; 8
    9618:	60 e0       	ldi	r22, 0x00	; 0
    961a:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    961e:	80 e0       	ldi	r24, 0x00	; 0
    9620:	90 e0       	ldi	r25, 0x00	; 0
    9622:	63 e0       	ldi	r22, 0x03	; 3
    9624:	70 e0       	ldi	r23, 0x00	; 0
    9626:	0e 94 33 37 	call	0x6e66	; 0x6e66 <SPIInit2>
	SPICS(TRUE);
    962a:	81 e0       	ldi	r24, 0x01	; 1
    962c:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9630:	1a 82       	std	Y+2, r1	; 0x02
    9632:	1b 82       	std	Y+3, r1	; 0x03
    9634:	17 c0       	rjmp	.+46     	; 0x9664 <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9636:	80 ec       	ldi	r24, 0xC0	; 192
    9638:	98 e0       	ldi	r25, 0x08	; 8
    963a:	2f ef       	ldi	r18, 0xFF	; 255
    963c:	fc 01       	movw	r30, r24
    963e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9640:	00 00       	nop
    9642:	80 ec       	ldi	r24, 0xC0	; 192
    9644:	98 e0       	ldi	r25, 0x08	; 8
    9646:	fc 01       	movw	r30, r24
    9648:	82 81       	ldd	r24, Z+2	; 0x02
    964a:	88 23       	and	r24, r24
    964c:	d4 f7       	brge	.-12     	; 0x9642 <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    964e:	80 ec       	ldi	r24, 0xC0	; 192
    9650:	98 e0       	ldi	r25, 0x08	; 8
    9652:	fc 01       	movw	r30, r24
    9654:	83 81       	ldd	r24, Z+3	; 0x03
    9656:	80 93 af 50 	sts	0x50AF, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    965a:	8a 81       	ldd	r24, Y+2	; 0x02
    965c:	9b 81       	ldd	r25, Y+3	; 0x03
    965e:	01 96       	adiw	r24, 0x01	; 1
    9660:	8a 83       	std	Y+2, r24	; 0x02
    9662:	9b 83       	std	Y+3, r25	; 0x03
    9664:	8a 81       	ldd	r24, Y+2	; 0x02
    9666:	9b 81       	ldd	r25, Y+3	; 0x03
    9668:	8a 30       	cpi	r24, 0x0A	; 10
    966a:	91 05       	cpc	r25, r1
    966c:	24 f3       	brlt	.-56     	; 0x9636 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    966e:	80 e0       	ldi	r24, 0x00	; 0
    9670:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    9674:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9678:	88 e0       	ldi	r24, 0x08	; 8
    967a:	60 e0       	ldi	r22, 0x00	; 0
    967c:	0e 94 9e 33 	call	0x673c	; 0x673c <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9680:	80 e0       	ldi	r24, 0x00	; 0
    9682:	90 e0       	ldi	r25, 0x00	; 0
    9684:	63 e0       	ldi	r22, 0x03	; 3
    9686:	70 e0       	ldi	r23, 0x00	; 0
    9688:	0e 94 33 37 	call	0x6e66	; 0x6e66 <SPIInit2>
	SPICS(TRUE);
    968c:	81 e0       	ldi	r24, 0x01	; 1
    968e:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9692:	1c 82       	std	Y+4, r1	; 0x04
    9694:	1d 82       	std	Y+5, r1	; 0x05
    9696:	0d c0       	rjmp	.+26     	; 0x96b2 <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    9698:	8c 81       	ldd	r24, Y+4	; 0x04
    969a:	9d 81       	ldd	r25, Y+5	; 0x05
    969c:	8a 30       	cpi	r24, 0x0A	; 10
    969e:	91 05       	cpc	r25, r1
    96a0:	1c f0       	brlt	.+6      	; 0x96a8 <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    96a2:	81 e0       	ldi	r24, 0x01	; 1
    96a4:	89 83       	std	Y+1, r24	; 0x01
			break;
    96a6:	10 c0       	rjmp	.+32     	; 0x96c8 <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    96a8:	8c 81       	ldd	r24, Y+4	; 0x04
    96aa:	9d 81       	ldd	r25, Y+5	; 0x05
    96ac:	01 96       	adiw	r24, 0x01	; 1
    96ae:	8c 83       	std	Y+4, r24	; 0x04
    96b0:	9d 83       	std	Y+5, r25	; 0x05
    96b2:	80 e0       	ldi	r24, 0x00	; 0
    96b4:	40 e0       	ldi	r20, 0x00	; 0
    96b6:	50 e0       	ldi	r21, 0x00	; 0
    96b8:	ba 01       	movw	r22, r20
    96ba:	25 e9       	ldi	r18, 0x95	; 149
    96bc:	08 e0       	ldi	r16, 0x08	; 8
    96be:	10 e0       	ldi	r17, 0x00	; 0
    96c0:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
    96c4:	81 30       	cpi	r24, 0x01	; 1
    96c6:	41 f7       	brne	.-48     	; 0x9698 <SD_init+0x1aa>
    96c8:	80 e0       	ldi	r24, 0x00	; 0
    96ca:	90 e0       	ldi	r25, 0x00	; 0
    96cc:	a8 ec       	ldi	r26, 0xC8	; 200
    96ce:	b2 e4       	ldi	r27, 0x42	; 66
    96d0:	8c 8f       	std	Y+28, r24	; 0x1c
    96d2:	9d 8f       	std	Y+29, r25	; 0x1d
    96d4:	ae 8f       	std	Y+30, r26	; 0x1e
    96d6:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    96d8:	6c 8d       	ldd	r22, Y+28	; 0x1c
    96da:	7d 8d       	ldd	r23, Y+29	; 0x1d
    96dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    96de:	9f 8d       	ldd	r25, Y+31	; 0x1f
    96e0:	20 e0       	ldi	r18, 0x00	; 0
    96e2:	30 e0       	ldi	r19, 0x00	; 0
    96e4:	4a ef       	ldi	r20, 0xFA	; 250
    96e6:	55 e4       	ldi	r21, 0x45	; 69
    96e8:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    96ec:	dc 01       	movw	r26, r24
    96ee:	cb 01       	movw	r24, r22
    96f0:	88 a3       	lds	r24, 0x58
    96f2:	99 a3       	lds	r25, 0x59
    96f4:	aa a3       	lds	r26, 0x5a
    96f6:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    96f8:	11 e0       	ldi	r17, 0x01	; 1
    96fa:	68 a1       	lds	r22, 0x48
    96fc:	79 a1       	lds	r23, 0x49
    96fe:	8a a1       	lds	r24, 0x4a
    9700:	9b a1       	lds	r25, 0x4b
    9702:	20 e0       	ldi	r18, 0x00	; 0
    9704:	30 e0       	ldi	r19, 0x00	; 0
    9706:	40 e8       	ldi	r20, 0x80	; 128
    9708:	5f e3       	ldi	r21, 0x3F	; 63
    970a:	0e 94 30 60 	call	0xc060	; 0xc060 <__cmpsf2>
    970e:	88 23       	and	r24, r24
    9710:	0c f0       	brlt	.+2      	; 0x9714 <SD_init+0x226>
    9712:	10 e0       	ldi	r17, 0x00	; 0
    9714:	11 23       	and	r17, r17
    9716:	29 f0       	breq	.+10     	; 0x9722 <SD_init+0x234>
		__ticks = 1;
    9718:	81 e0       	ldi	r24, 0x01	; 1
    971a:	90 e0       	ldi	r25, 0x00	; 0
    971c:	8c a3       	lds	r24, 0x5c
    971e:	9d a3       	lds	r25, 0x5d
    9720:	46 c0       	rjmp	.+140    	; 0x97ae <SD_init+0x2c0>
	else if (__tmp > 65535)
    9722:	11 e0       	ldi	r17, 0x01	; 1
    9724:	68 a1       	lds	r22, 0x48
    9726:	79 a1       	lds	r23, 0x49
    9728:	8a a1       	lds	r24, 0x4a
    972a:	9b a1       	lds	r25, 0x4b
    972c:	20 e0       	ldi	r18, 0x00	; 0
    972e:	3f ef       	ldi	r19, 0xFF	; 255
    9730:	4f e7       	ldi	r20, 0x7F	; 127
    9732:	57 e4       	ldi	r21, 0x47	; 71
    9734:	0e 94 3d 61 	call	0xc27a	; 0xc27a <__gesf2>
    9738:	18 16       	cp	r1, r24
    973a:	0c f0       	brlt	.+2      	; 0x973e <SD_init+0x250>
    973c:	10 e0       	ldi	r17, 0x00	; 0
    973e:	11 23       	and	r17, r17
    9740:	61 f1       	breq	.+88     	; 0x979a <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9742:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9744:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9746:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9748:	9f 8d       	ldd	r25, Y+31	; 0x1f
    974a:	20 e0       	ldi	r18, 0x00	; 0
    974c:	30 e0       	ldi	r19, 0x00	; 0
    974e:	40 e2       	ldi	r20, 0x20	; 32
    9750:	51 e4       	ldi	r21, 0x41	; 65
    9752:	0e 94 41 61 	call	0xc282	; 0xc282 <__mulsf3>
    9756:	dc 01       	movw	r26, r24
    9758:	cb 01       	movw	r24, r22
    975a:	bc 01       	movw	r22, r24
    975c:	cd 01       	movw	r24, r26
    975e:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    9762:	dc 01       	movw	r26, r24
    9764:	cb 01       	movw	r24, r22
    9766:	8c a3       	lds	r24, 0x5c
    9768:	9d a3       	lds	r25, 0x5d
    976a:	12 c0       	rjmp	.+36     	; 0x9790 <SD_init+0x2a2>
    976c:	80 e2       	ldi	r24, 0x20	; 32
    976e:	93 e0       	ldi	r25, 0x03	; 3
    9770:	8e a3       	lds	r24, 0x5e
    9772:	9f a3       	lds	r25, 0x5f
    9774:	8e a1       	lds	r24, 0x4e
    9776:	9f a1       	lds	r25, 0x4f
    9778:	8c 01       	movw	r16, r24
    977a:	c8 01       	movw	r24, r16
    977c:	01 97       	sbiw	r24, 0x01	; 1
    977e:	f1 f7       	brne	.-4      	; 0x977c <SD_init+0x28e>
    9780:	8c 01       	movw	r16, r24
    9782:	0e a3       	lds	r16, 0x5e
    9784:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9786:	8c a1       	lds	r24, 0x4c
    9788:	9d a1       	lds	r25, 0x4d
    978a:	01 97       	sbiw	r24, 0x01	; 1
    978c:	8c a3       	lds	r24, 0x5c
    978e:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9790:	8c a1       	lds	r24, 0x4c
    9792:	9d a1       	lds	r25, 0x4d
    9794:	00 97       	sbiw	r24, 0x00	; 0
    9796:	51 f7       	brne	.-44     	; 0x976c <SD_init+0x27e>
    9798:	17 c0       	rjmp	.+46     	; 0x97c8 <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    979a:	68 a1       	lds	r22, 0x48
    979c:	79 a1       	lds	r23, 0x49
    979e:	8a a1       	lds	r24, 0x4a
    97a0:	9b a1       	lds	r25, 0x4b
    97a2:	0e 94 9c 60 	call	0xc138	; 0xc138 <__fixunssfsi>
    97a6:	dc 01       	movw	r26, r24
    97a8:	cb 01       	movw	r24, r22
    97aa:	8c a3       	lds	r24, 0x5c
    97ac:	9d a3       	lds	r25, 0x5d
    97ae:	8c a1       	lds	r24, 0x4c
    97b0:	9d a1       	lds	r25, 0x4d
    97b2:	88 a7       	lds	r24, 0x78
    97b4:	99 a7       	lds	r25, 0x79
    97b6:	88 a5       	lds	r24, 0x68
    97b8:	99 a5       	lds	r25, 0x69
    97ba:	8c 01       	movw	r16, r24
    97bc:	f8 01       	movw	r30, r16
    97be:	31 97       	sbiw	r30, 0x01	; 1
    97c0:	f1 f7       	brne	.-4      	; 0x97be <SD_init+0x2d0>
    97c2:	8f 01       	movw	r16, r30
    97c4:	08 a7       	lds	r16, 0x78
    97c6:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    97c8:	1e 82       	std	Y+6, r1	; 0x06
    97ca:	1f 82       	std	Y+7, r1	; 0x07
    97cc:	0d c0       	rjmp	.+26     	; 0x97e8 <SD_init+0x2fa>
		if (i >= 10) {
    97ce:	8e 81       	ldd	r24, Y+6	; 0x06
    97d0:	9f 81       	ldd	r25, Y+7	; 0x07
    97d2:	8a 30       	cpi	r24, 0x0A	; 10
    97d4:	91 05       	cpc	r25, r1
    97d6:	1c f0       	brlt	.+6      	; 0x97de <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    97d8:	81 e0       	ldi	r24, 0x01	; 1
    97da:	89 83       	std	Y+1, r24	; 0x01
			break;
    97dc:	11 c0       	rjmp	.+34     	; 0x9800 <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    97de:	8e 81       	ldd	r24, Y+6	; 0x06
    97e0:	9f 81       	ldd	r25, Y+7	; 0x07
    97e2:	01 96       	adiw	r24, 0x01	; 1
    97e4:	8e 83       	std	Y+6, r24	; 0x06
    97e6:	9f 83       	std	Y+7, r25	; 0x07
    97e8:	88 e0       	ldi	r24, 0x08	; 8
    97ea:	4a ea       	ldi	r20, 0xAA	; 170
    97ec:	51 e0       	ldi	r21, 0x01	; 1
    97ee:	60 e0       	ldi	r22, 0x00	; 0
    97f0:	70 e0       	ldi	r23, 0x00	; 0
    97f2:	27 e8       	ldi	r18, 0x87	; 135
    97f4:	08 e0       	ldi	r16, 0x08	; 8
    97f6:	10 e0       	ldi	r17, 0x00	; 0
    97f8:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
    97fc:	81 30       	cpi	r24, 0x01	; 1
    97fe:	39 f7       	brne	.-50     	; 0x97ce <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9800:	18 86       	std	Y+8, r1	; 0x08
    9802:	19 86       	std	Y+9, r1	; 0x09
    9804:	13 c0       	rjmp	.+38     	; 0x982c <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9806:	88 85       	ldd	r24, Y+8	; 0x08
    9808:	99 85       	ldd	r25, Y+9	; 0x09
    980a:	8c 01       	movw	r16, r24
    980c:	0e 5f       	subi	r16, 0xFE	; 254
    980e:	1f 4f       	sbci	r17, 0xFF	; 255
    9810:	8f ef       	ldi	r24, 0xFF	; 255
    9812:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9816:	28 2f       	mov	r18, r24
    9818:	c8 01       	movw	r24, r16
    981a:	8d 55       	subi	r24, 0x5D	; 93
    981c:	9f 4a       	sbci	r25, 0xAF	; 175
    981e:	fc 01       	movw	r30, r24
    9820:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9822:	88 85       	ldd	r24, Y+8	; 0x08
    9824:	99 85       	ldd	r25, Y+9	; 0x09
    9826:	01 96       	adiw	r24, 0x01	; 1
    9828:	88 87       	std	Y+8, r24	; 0x08
    982a:	99 87       	std	Y+9, r25	; 0x09
    982c:	88 85       	ldd	r24, Y+8	; 0x08
    982e:	99 85       	ldd	r25, Y+9	; 0x09
    9830:	84 30       	cpi	r24, 0x04	; 4
    9832:	91 05       	cpc	r25, r1
    9834:	44 f3       	brlt	.-48     	; 0x9806 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9836:	80 91 a7 50 	lds	r24, 0x50A7
    983a:	81 30       	cpi	r24, 0x01	; 1
    983c:	21 f4       	brne	.+8      	; 0x9846 <SD_init+0x358>
    983e:	80 91 a8 50 	lds	r24, 0x50A8
    9842:	8a 3a       	cpi	r24, 0xAA	; 170
    9844:	11 f0       	breq	.+4      	; 0x984a <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9846:	81 e0       	ldi	r24, 0x01	; 1
    9848:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    984a:	87 e3       	ldi	r24, 0x37	; 55
    984c:	40 e0       	ldi	r20, 0x00	; 0
    984e:	50 e0       	ldi	r21, 0x00	; 0
    9850:	ba 01       	movw	r22, r20
    9852:	2f ef       	ldi	r18, 0xFF	; 255
    9854:	08 e0       	ldi	r16, 0x08	; 8
    9856:	10 e0       	ldi	r17, 0x00	; 0
    9858:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    985c:	81 e0       	ldi	r24, 0x01	; 1
    985e:	40 e0       	ldi	r20, 0x00	; 0
    9860:	50 e0       	ldi	r21, 0x00	; 0
    9862:	60 e0       	ldi	r22, 0x00	; 0
    9864:	70 e4       	ldi	r23, 0x40	; 64
    9866:	2f ef       	ldi	r18, 0xFF	; 255
    9868:	08 e0       	ldi	r16, 0x08	; 8
    986a:	10 e0       	ldi	r17, 0x00	; 0
    986c:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
	} while(Buffer[1]!= 0x00);
    9870:	80 91 a4 50 	lds	r24, 0x50A4
    9874:	88 23       	and	r24, r24
    9876:	49 f7       	brne	.-46     	; 0x984a <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9878:	1a 86       	std	Y+10, r1	; 0x0a
    987a:	1b 86       	std	Y+11, r1	; 0x0b
    987c:	0d c0       	rjmp	.+26     	; 0x9898 <SD_init+0x3aa>
		if (i >= 10) {
    987e:	8a 85       	ldd	r24, Y+10	; 0x0a
    9880:	9b 85       	ldd	r25, Y+11	; 0x0b
    9882:	8a 30       	cpi	r24, 0x0A	; 10
    9884:	91 05       	cpc	r25, r1
    9886:	1c f0       	brlt	.+6      	; 0x988e <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    9888:	81 e0       	ldi	r24, 0x01	; 1
    988a:	89 83       	std	Y+1, r24	; 0x01
			break;
    988c:	10 c0       	rjmp	.+32     	; 0x98ae <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    988e:	8a 85       	ldd	r24, Y+10	; 0x0a
    9890:	9b 85       	ldd	r25, Y+11	; 0x0b
    9892:	01 96       	adiw	r24, 0x01	; 1
    9894:	8a 87       	std	Y+10, r24	; 0x0a
    9896:	9b 87       	std	Y+11, r25	; 0x0b
    9898:	8a e3       	ldi	r24, 0x3A	; 58
    989a:	40 e0       	ldi	r20, 0x00	; 0
    989c:	50 e0       	ldi	r21, 0x00	; 0
    989e:	ba 01       	movw	r22, r20
    98a0:	2f ef       	ldi	r18, 0xFF	; 255
    98a2:	08 e0       	ldi	r16, 0x08	; 8
    98a4:	10 e0       	ldi	r17, 0x00	; 0
    98a6:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
    98aa:	88 23       	and	r24, r24
    98ac:	41 f7       	brne	.-48     	; 0x987e <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    98ae:	1c 86       	std	Y+12, r1	; 0x0c
    98b0:	1d 86       	std	Y+13, r1	; 0x0d
    98b2:	0f c0       	rjmp	.+30     	; 0x98d2 <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    98b4:	8f ef       	ldi	r24, 0xFF	; 255
    98b6:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    98ba:	28 2f       	mov	r18, r24
    98bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    98be:	9d 85       	ldd	r25, Y+13	; 0x0d
    98c0:	8d 55       	subi	r24, 0x5D	; 93
    98c2:	9f 4a       	sbci	r25, 0xAF	; 175
    98c4:	fc 01       	movw	r30, r24
    98c6:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    98c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    98ca:	9d 85       	ldd	r25, Y+13	; 0x0d
    98cc:	01 96       	adiw	r24, 0x01	; 1
    98ce:	8c 87       	std	Y+12, r24	; 0x0c
    98d0:	9d 87       	std	Y+13, r25	; 0x0d
    98d2:	8c 85       	ldd	r24, Y+12	; 0x0c
    98d4:	9d 85       	ldd	r25, Y+13	; 0x0d
    98d6:	84 30       	cpi	r24, 0x04	; 4
    98d8:	91 05       	cpc	r25, r1
    98da:	64 f3       	brlt	.-40     	; 0x98b4 <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    98dc:	80 91 a3 50 	lds	r24, 0x50A3
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    98e0:	80 e0       	ldi	r24, 0x00	; 0
    98e2:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    98e6:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    98ea:	88 e0       	ldi	r24, 0x08	; 8
    98ec:	60 e0       	ldi	r22, 0x00	; 0
    98ee:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
	return errorCode;	
    98f2:	89 81       	ldd	r24, Y+1	; 0x01
}	
    98f4:	a9 96       	adiw	r28, 0x29	; 41
    98f6:	cd bf       	out	0x3d, r28	; 61
    98f8:	de bf       	out	0x3e, r29	; 62
    98fa:	df 91       	pop	r29
    98fc:	cf 91       	pop	r28
    98fe:	1f 91       	pop	r17
    9900:	0f 91       	pop	r16
    9902:	08 95       	ret

00009904 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9904:	cf 93       	push	r28
    9906:	df 93       	push	r29
    9908:	0f 92       	push	r0
    990a:	0f 92       	push	r0
    990c:	cd b7       	in	r28, 0x3d	; 61
    990e:	de b7       	in	r29, 0x3e	; 62
    9910:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9912:	80 ec       	ldi	r24, 0xC0	; 192
    9914:	98 e0       	ldi	r25, 0x08	; 8
    9916:	2a 81       	ldd	r18, Y+2	; 0x02
    9918:	fc 01       	movw	r30, r24
    991a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    991c:	00 00       	nop
    991e:	80 ec       	ldi	r24, 0xC0	; 192
    9920:	98 e0       	ldi	r25, 0x08	; 8
    9922:	fc 01       	movw	r30, r24
    9924:	82 81       	ldd	r24, Z+2	; 0x02
    9926:	88 23       	and	r24, r24
    9928:	d4 f7       	brge	.-12     	; 0x991e <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    992a:	80 ec       	ldi	r24, 0xC0	; 192
    992c:	98 e0       	ldi	r25, 0x08	; 8
    992e:	fc 01       	movw	r30, r24
    9930:	83 81       	ldd	r24, Z+3	; 0x03
    9932:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9934:	89 81       	ldd	r24, Y+1	; 0x01
}
    9936:	0f 90       	pop	r0
    9938:	0f 90       	pop	r0
    993a:	df 91       	pop	r29
    993c:	cf 91       	pop	r28
    993e:	08 95       	ret

00009940 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9940:	0f 93       	push	r16
    9942:	1f 93       	push	r17
    9944:	cf 93       	push	r28
    9946:	df 93       	push	r29
    9948:	cd b7       	in	r28, 0x3d	; 61
    994a:	de b7       	in	r29, 0x3e	; 62
    994c:	2a 97       	sbiw	r28, 0x0a	; 10
    994e:	cd bf       	out	0x3d, r28	; 61
    9950:	de bf       	out	0x3e, r29	; 62
    9952:	8b 83       	std	Y+3, r24	; 0x03
    9954:	4c 83       	std	Y+4, r20	; 0x04
    9956:	5d 83       	std	Y+5, r21	; 0x05
    9958:	6e 83       	std	Y+6, r22	; 0x06
    995a:	7f 83       	std	Y+7, r23	; 0x07
    995c:	28 87       	std	Y+8, r18	; 0x08
    995e:	09 87       	std	Y+9, r16	; 0x09
    9960:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9962:	8b 81       	ldd	r24, Y+3	; 0x03
    9964:	80 64       	ori	r24, 0x40	; 64
    9966:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    996a:	8c 81       	ldd	r24, Y+4	; 0x04
    996c:	9d 81       	ldd	r25, Y+5	; 0x05
    996e:	ae 81       	ldd	r26, Y+6	; 0x06
    9970:	bf 81       	ldd	r27, Y+7	; 0x07
    9972:	8b 2f       	mov	r24, r27
    9974:	99 27       	eor	r25, r25
    9976:	aa 27       	eor	r26, r26
    9978:	bb 27       	eor	r27, r27
    997a:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    997e:	8c 81       	ldd	r24, Y+4	; 0x04
    9980:	9d 81       	ldd	r25, Y+5	; 0x05
    9982:	ae 81       	ldd	r26, Y+6	; 0x06
    9984:	bf 81       	ldd	r27, Y+7	; 0x07
    9986:	cd 01       	movw	r24, r26
    9988:	aa 27       	eor	r26, r26
    998a:	bb 27       	eor	r27, r27
    998c:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9990:	8c 81       	ldd	r24, Y+4	; 0x04
    9992:	9d 81       	ldd	r25, Y+5	; 0x05
    9994:	ae 81       	ldd	r26, Y+6	; 0x06
    9996:	bf 81       	ldd	r27, Y+7	; 0x07
    9998:	89 2f       	mov	r24, r25
    999a:	9a 2f       	mov	r25, r26
    999c:	ab 2f       	mov	r26, r27
    999e:	bb 27       	eor	r27, r27
    99a0:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    99a4:	8c 81       	ldd	r24, Y+4	; 0x04
    99a6:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
	SPI_write(crc);
    99aa:	88 85       	ldd	r24, Y+8	; 0x08
    99ac:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
	
	for(int i=0; i<read; i++){
    99b0:	19 82       	std	Y+1, r1	; 0x01
    99b2:	1a 82       	std	Y+2, r1	; 0x02
    99b4:	33 c0       	rjmp	.+102    	; 0x9a1c <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    99b6:	89 81       	ldd	r24, Y+1	; 0x01
    99b8:	9a 81       	ldd	r25, Y+2	; 0x02
    99ba:	2d e0       	ldi	r18, 0x0D	; 13
    99bc:	30 e0       	ldi	r19, 0x00	; 0
    99be:	b9 01       	movw	r22, r18
    99c0:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    99c4:	8c 01       	movw	r16, r24
    99c6:	8f ef       	ldi	r24, 0xFF	; 255
    99c8:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    99cc:	28 2f       	mov	r18, r24
    99ce:	c8 01       	movw	r24, r16
    99d0:	8d 55       	subi	r24, 0x5D	; 93
    99d2:	9f 4a       	sbci	r25, 0xAF	; 175
    99d4:	fc 01       	movw	r30, r24
    99d6:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    99d8:	89 81       	ldd	r24, Y+1	; 0x01
    99da:	9a 81       	ldd	r25, Y+2	; 0x02
    99dc:	2d e0       	ldi	r18, 0x0D	; 13
    99de:	30 e0       	ldi	r19, 0x00	; 0
    99e0:	b9 01       	movw	r22, r18
    99e2:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    99e6:	8d 55       	subi	r24, 0x5D	; 93
    99e8:	9f 4a       	sbci	r25, 0xAF	; 175
    99ea:	fc 01       	movw	r30, r24
    99ec:	80 81       	ld	r24, Z
    99ee:	8f 3f       	cpi	r24, 0xFF	; 255
    99f0:	81 f0       	breq	.+32     	; 0x9a12 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    99f2:	89 81       	ldd	r24, Y+1	; 0x01
    99f4:	9a 81       	ldd	r25, Y+2	; 0x02
    99f6:	2d e0       	ldi	r18, 0x0D	; 13
    99f8:	30 e0       	ldi	r19, 0x00	; 0
    99fa:	b9 01       	movw	r22, r18
    99fc:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    9a00:	8d 55       	subi	r24, 0x5D	; 93
    9a02:	9f 4a       	sbci	r25, 0xAF	; 175
    9a04:	fc 01       	movw	r30, r24
    9a06:	80 81       	ld	r24, Z
    9a08:	80 93 a4 50 	sts	0x50A4, r24
			return Buffer[1];
    9a0c:	80 91 a4 50 	lds	r24, 0x50A4
    9a10:	0d c0       	rjmp	.+26     	; 0x9a2c <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9a12:	89 81       	ldd	r24, Y+1	; 0x01
    9a14:	9a 81       	ldd	r25, Y+2	; 0x02
    9a16:	01 96       	adiw	r24, 0x01	; 1
    9a18:	89 83       	std	Y+1, r24	; 0x01
    9a1a:	9a 83       	std	Y+2, r25	; 0x02
    9a1c:	29 81       	ldd	r18, Y+1	; 0x01
    9a1e:	3a 81       	ldd	r19, Y+2	; 0x02
    9a20:	89 85       	ldd	r24, Y+9	; 0x09
    9a22:	9a 85       	ldd	r25, Y+10	; 0x0a
    9a24:	28 17       	cp	r18, r24
    9a26:	39 07       	cpc	r19, r25
    9a28:	34 f2       	brlt	.-116    	; 0x99b6 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9a2a:	8f ef       	ldi	r24, 0xFF	; 255
}
    9a2c:	2a 96       	adiw	r28, 0x0a	; 10
    9a2e:	cd bf       	out	0x3d, r28	; 61
    9a30:	de bf       	out	0x3e, r29	; 62
    9a32:	df 91       	pop	r29
    9a34:	cf 91       	pop	r28
    9a36:	1f 91       	pop	r17
    9a38:	0f 91       	pop	r16
    9a3a:	08 95       	ret

00009a3c <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9a3c:	0f 93       	push	r16
    9a3e:	1f 93       	push	r17
    9a40:	cf 93       	push	r28
    9a42:	df 93       	push	r29
    9a44:	cd b7       	in	r28, 0x3d	; 61
    9a46:	de b7       	in	r29, 0x3e	; 62
    9a48:	62 97       	sbiw	r28, 0x12	; 18
    9a4a:	cd bf       	out	0x3d, r28	; 61
    9a4c:	de bf       	out	0x3e, r29	; 62
    9a4e:	6b 87       	std	Y+11, r22	; 0x0b
    9a50:	7c 87       	std	Y+12, r23	; 0x0c
    9a52:	8d 87       	std	Y+13, r24	; 0x0d
    9a54:	9e 87       	std	Y+14, r25	; 0x0e
    9a56:	4f 87       	std	Y+15, r20	; 0x0f
    9a58:	58 8b       	std	Y+16, r21	; 0x10
    9a5a:	29 8b       	std	Y+17, r18	; 0x11
    9a5c:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9a5e:	88 e0       	ldi	r24, 0x08	; 8
    9a60:	60 e0       	ldi	r22, 0x00	; 0
    9a62:	0e 94 9e 33 	call	0x673c	; 0x673c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9a66:	80 e0       	ldi	r24, 0x00	; 0
    9a68:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    9a6c:	81 e0       	ldi	r24, 0x01	; 1
    9a6e:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9a72:	20 e0       	ldi	r18, 0x00	; 0
    9a74:	32 e0       	ldi	r19, 0x02	; 2
    9a76:	89 89       	ldd	r24, Y+17	; 0x11
    9a78:	9a 89       	ldd	r25, Y+18	; 0x12
    9a7a:	a9 01       	movw	r20, r18
    9a7c:	48 1b       	sub	r20, r24
    9a7e:	59 0b       	sbc	r21, r25
    9a80:	ca 01       	movw	r24, r20
    9a82:	89 83       	std	Y+1, r24	; 0x01
    9a84:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9a86:	89 81       	ldd	r24, Y+1	; 0x01
    9a88:	9a 81       	ldd	r25, Y+2	; 0x02
    9a8a:	52 e0       	ldi	r21, 0x02	; 2
    9a8c:	80 30       	cpi	r24, 0x00	; 0
    9a8e:	95 07       	cpc	r25, r21
    9a90:	11 f4       	brne	.+4      	; 0x9a96 <SD_write_block+0x5a>
    9a92:	19 82       	std	Y+1, r1	; 0x01
    9a94:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9a96:	1b 82       	std	Y+3, r1	; 0x03
    9a98:	1c 82       	std	Y+4, r1	; 0x04
    9a9a:	0b c0       	rjmp	.+22     	; 0x9ab2 <SD_write_block+0x76>
	if (i >= 10) {
    9a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    9a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    9aa0:	8a 30       	cpi	r24, 0x0A	; 10
    9aa2:	91 05       	cpc	r25, r1
    9aa4:	0c f0       	brlt	.+2      	; 0x9aa8 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9aa6:	ff cf       	rjmp	.-2      	; 0x9aa6 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    9aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    9aac:	01 96       	adiw	r24, 0x01	; 1
    9aae:	8b 83       	std	Y+3, r24	; 0x03
    9ab0:	9c 83       	std	Y+4, r25	; 0x04
    9ab2:	2b 85       	ldd	r18, Y+11	; 0x0b
    9ab4:	3c 85       	ldd	r19, Y+12	; 0x0c
    9ab6:	4d 85       	ldd	r20, Y+13	; 0x0d
    9ab8:	5e 85       	ldd	r21, Y+14	; 0x0e
    9aba:	88 e1       	ldi	r24, 0x18	; 24
    9abc:	ba 01       	movw	r22, r20
    9abe:	a9 01       	movw	r20, r18
    9ac0:	2f ef       	ldi	r18, 0xFF	; 255
    9ac2:	08 e0       	ldi	r16, 0x08	; 8
    9ac4:	10 e0       	ldi	r17, 0x00	; 0
    9ac6:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
    9aca:	88 23       	and	r24, r24
    9acc:	39 f7       	brne	.-50     	; 0x9a9c <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9ace:	8f ef       	ldi	r24, 0xFF	; 255
    9ad0:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9ad4:	80 93 a3 50 	sts	0x50A3, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9ad8:	8e ef       	ldi	r24, 0xFE	; 254
    9ada:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9ade:	1d 82       	std	Y+5, r1	; 0x05
    9ae0:	1e 82       	std	Y+6, r1	; 0x06
    9ae2:	1d c0       	rjmp	.+58     	; 0x9b1e <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9ae4:	8d 81       	ldd	r24, Y+5	; 0x05
    9ae6:	9e 81       	ldd	r25, Y+6	; 0x06
    9ae8:	2d e0       	ldi	r18, 0x0D	; 13
    9aea:	30 e0       	ldi	r19, 0x00	; 0
    9aec:	b9 01       	movw	r22, r18
    9aee:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    9af2:	8c 01       	movw	r16, r24
    9af4:	8d 81       	ldd	r24, Y+5	; 0x05
    9af6:	9e 81       	ldd	r25, Y+6	; 0x06
    9af8:	2f 85       	ldd	r18, Y+15	; 0x0f
    9afa:	38 89       	ldd	r19, Y+16	; 0x10
    9afc:	82 0f       	add	r24, r18
    9afe:	93 1f       	adc	r25, r19
    9b00:	fc 01       	movw	r30, r24
    9b02:	80 81       	ld	r24, Z
    9b04:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9b08:	28 2f       	mov	r18, r24
    9b0a:	c8 01       	movw	r24, r16
    9b0c:	8d 55       	subi	r24, 0x5D	; 93
    9b0e:	9f 4a       	sbci	r25, 0xAF	; 175
    9b10:	fc 01       	movw	r30, r24
    9b12:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9b14:	8d 81       	ldd	r24, Y+5	; 0x05
    9b16:	9e 81       	ldd	r25, Y+6	; 0x06
    9b18:	01 96       	adiw	r24, 0x01	; 1
    9b1a:	8d 83       	std	Y+5, r24	; 0x05
    9b1c:	9e 83       	std	Y+6, r25	; 0x06
    9b1e:	2d 81       	ldd	r18, Y+5	; 0x05
    9b20:	3e 81       	ldd	r19, Y+6	; 0x06
    9b22:	89 89       	ldd	r24, Y+17	; 0x11
    9b24:	9a 89       	ldd	r25, Y+18	; 0x12
    9b26:	28 17       	cp	r18, r24
    9b28:	39 07       	cpc	r19, r25
    9b2a:	e4 f2       	brlt	.-72     	; 0x9ae4 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9b2c:	1f 82       	std	Y+7, r1	; 0x07
    9b2e:	18 86       	std	Y+8, r1	; 0x08
    9b30:	16 c0       	rjmp	.+44     	; 0x9b5e <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9b32:	8f 81       	ldd	r24, Y+7	; 0x07
    9b34:	98 85       	ldd	r25, Y+8	; 0x08
    9b36:	2d e0       	ldi	r18, 0x0D	; 13
    9b38:	30 e0       	ldi	r19, 0x00	; 0
    9b3a:	b9 01       	movw	r22, r18
    9b3c:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    9b40:	8c 01       	movw	r16, r24
    9b42:	80 e0       	ldi	r24, 0x00	; 0
    9b44:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9b48:	28 2f       	mov	r18, r24
    9b4a:	c8 01       	movw	r24, r16
    9b4c:	8d 55       	subi	r24, 0x5D	; 93
    9b4e:	9f 4a       	sbci	r25, 0xAF	; 175
    9b50:	fc 01       	movw	r30, r24
    9b52:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9b54:	8f 81       	ldd	r24, Y+7	; 0x07
    9b56:	98 85       	ldd	r25, Y+8	; 0x08
    9b58:	01 96       	adiw	r24, 0x01	; 1
    9b5a:	8f 83       	std	Y+7, r24	; 0x07
    9b5c:	98 87       	std	Y+8, r25	; 0x08
    9b5e:	2f 81       	ldd	r18, Y+7	; 0x07
    9b60:	38 85       	ldd	r19, Y+8	; 0x08
    9b62:	89 81       	ldd	r24, Y+1	; 0x01
    9b64:	9a 81       	ldd	r25, Y+2	; 0x02
    9b66:	28 17       	cp	r18, r24
    9b68:	39 07       	cpc	r19, r25
    9b6a:	1c f3       	brlt	.-58     	; 0x9b32 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9b6c:	8f ef       	ldi	r24, 0xFF	; 255
    9b6e:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9b72:	19 86       	std	Y+9, r1	; 0x09
    9b74:	1a 86       	std	Y+10, r1	; 0x0a
    9b76:	0a c0       	rjmp	.+20     	; 0x9b8c <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9b78:	8f ef       	ldi	r24, 0xFF	; 255
    9b7a:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9b7e:	80 93 a3 50 	sts	0x50A3, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9b82:	89 85       	ldd	r24, Y+9	; 0x09
    9b84:	9a 85       	ldd	r25, Y+10	; 0x0a
    9b86:	01 96       	adiw	r24, 0x01	; 1
    9b88:	89 87       	std	Y+9, r24	; 0x09
    9b8a:	9a 87       	std	Y+10, r25	; 0x0a
    9b8c:	89 85       	ldd	r24, Y+9	; 0x09
    9b8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9b90:	82 30       	cpi	r24, 0x02	; 2
    9b92:	91 05       	cpc	r25, r1
    9b94:	8c f3       	brlt	.-30     	; 0x9b78 <SD_write_block+0x13c>
    9b96:	80 91 a3 50 	lds	r24, 0x50A3
    9b9a:	8f 3f       	cpi	r24, 0xFF	; 255
    9b9c:	69 f3       	breq	.-38     	; 0x9b78 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9b9e:	80 91 a3 50 	lds	r24, 0x50A3
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9ba2:	05 c0       	rjmp	.+10     	; 0x9bae <SD_write_block+0x172>
    9ba4:	8f ef       	ldi	r24, 0xFF	; 255
    9ba6:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9baa:	80 93 a3 50 	sts	0x50A3, r24
    9bae:	80 91 a3 50 	lds	r24, 0x50A3
    9bb2:	8f 3f       	cpi	r24, 0xFF	; 255
    9bb4:	b9 f7       	brne	.-18     	; 0x9ba4 <SD_write_block+0x168>
	SPICS(FALSE);
    9bb6:	80 e0       	ldi	r24, 0x00	; 0
    9bb8:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    9bbc:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9bc0:	88 e0       	ldi	r24, 0x08	; 8
    9bc2:	60 e0       	ldi	r22, 0x00	; 0
    9bc4:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
}
    9bc8:	62 96       	adiw	r28, 0x12	; 18
    9bca:	cd bf       	out	0x3d, r28	; 61
    9bcc:	de bf       	out	0x3e, r29	; 62
    9bce:	df 91       	pop	r29
    9bd0:	cf 91       	pop	r28
    9bd2:	1f 91       	pop	r17
    9bd4:	0f 91       	pop	r16
    9bd6:	08 95       	ret

00009bd8 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9bd8:	0f 93       	push	r16
    9bda:	1f 93       	push	r17
    9bdc:	cf 93       	push	r28
    9bde:	df 93       	push	r29
    9be0:	cd b7       	in	r28, 0x3d	; 61
    9be2:	de b7       	in	r29, 0x3e	; 62
    9be4:	2a 97       	sbiw	r28, 0x0a	; 10
    9be6:	cd bf       	out	0x3d, r28	; 61
    9be8:	de bf       	out	0x3e, r29	; 62
    9bea:	6d 83       	std	Y+5, r22	; 0x05
    9bec:	7e 83       	std	Y+6, r23	; 0x06
    9bee:	8f 83       	std	Y+7, r24	; 0x07
    9bf0:	98 87       	std	Y+8, r25	; 0x08
    9bf2:	49 87       	std	Y+9, r20	; 0x09
    9bf4:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9bf6:	88 e0       	ldi	r24, 0x08	; 8
    9bf8:	60 e0       	ldi	r22, 0x00	; 0
    9bfa:	0e 94 9e 33 	call	0x673c	; 0x673c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9bfe:	80 e0       	ldi	r24, 0x00	; 0
    9c00:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    9c04:	81 e0       	ldi	r24, 0x01	; 1
    9c06:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9c0a:	19 82       	std	Y+1, r1	; 0x01
    9c0c:	1a 82       	std	Y+2, r1	; 0x02
    9c0e:	0b c0       	rjmp	.+22     	; 0x9c26 <SD_read_block+0x4e>
		if (i >= 10) {
    9c10:	89 81       	ldd	r24, Y+1	; 0x01
    9c12:	9a 81       	ldd	r25, Y+2	; 0x02
    9c14:	8a 30       	cpi	r24, 0x0A	; 10
    9c16:	91 05       	cpc	r25, r1
    9c18:	0c f0       	brlt	.+2      	; 0x9c1c <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9c1a:	ff cf       	rjmp	.-2      	; 0x9c1a <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9c1c:	89 81       	ldd	r24, Y+1	; 0x01
    9c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    9c20:	01 96       	adiw	r24, 0x01	; 1
    9c22:	89 83       	std	Y+1, r24	; 0x01
    9c24:	9a 83       	std	Y+2, r25	; 0x02
    9c26:	2d 81       	ldd	r18, Y+5	; 0x05
    9c28:	3e 81       	ldd	r19, Y+6	; 0x06
    9c2a:	4f 81       	ldd	r20, Y+7	; 0x07
    9c2c:	58 85       	ldd	r21, Y+8	; 0x08
    9c2e:	81 e1       	ldi	r24, 0x11	; 17
    9c30:	ba 01       	movw	r22, r20
    9c32:	a9 01       	movw	r20, r18
    9c34:	2f ef       	ldi	r18, 0xFF	; 255
    9c36:	08 e0       	ldi	r16, 0x08	; 8
    9c38:	10 e0       	ldi	r17, 0x00	; 0
    9c3a:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
    9c3e:	88 23       	and	r24, r24
    9c40:	39 f7       	brne	.-50     	; 0x9c10 <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9c42:	05 c0       	rjmp	.+10     	; 0x9c4e <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9c44:	8f ef       	ldi	r24, 0xFF	; 255
    9c46:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9c4a:	80 93 a3 50 	sts	0x50A3, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9c4e:	80 91 a3 50 	lds	r24, 0x50A3
    9c52:	8e 3f       	cpi	r24, 0xFE	; 254
    9c54:	b9 f7       	brne	.-18     	; 0x9c44 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9c56:	1b 82       	std	Y+3, r1	; 0x03
    9c58:	1c 82       	std	Y+4, r1	; 0x04
    9c5a:	11 c0       	rjmp	.+34     	; 0x9c7e <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9c5c:	8b 81       	ldd	r24, Y+3	; 0x03
    9c5e:	9c 81       	ldd	r25, Y+4	; 0x04
    9c60:	29 85       	ldd	r18, Y+9	; 0x09
    9c62:	3a 85       	ldd	r19, Y+10	; 0x0a
    9c64:	89 01       	movw	r16, r18
    9c66:	08 0f       	add	r16, r24
    9c68:	19 1f       	adc	r17, r25
    9c6a:	8f ef       	ldi	r24, 0xFF	; 255
    9c6c:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9c70:	f8 01       	movw	r30, r16
    9c72:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9c74:	8b 81       	ldd	r24, Y+3	; 0x03
    9c76:	9c 81       	ldd	r25, Y+4	; 0x04
    9c78:	01 96       	adiw	r24, 0x01	; 1
    9c7a:	8b 83       	std	Y+3, r24	; 0x03
    9c7c:	9c 83       	std	Y+4, r25	; 0x04
    9c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    9c80:	9c 81       	ldd	r25, Y+4	; 0x04
    9c82:	f2 e0       	ldi	r31, 0x02	; 2
    9c84:	80 30       	cpi	r24, 0x00	; 0
    9c86:	9f 07       	cpc	r25, r31
    9c88:	4c f3       	brlt	.-46     	; 0x9c5c <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    9c8a:	10 92 af 50 	sts	0x50AF, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9c8e:	05 c0       	rjmp	.+10     	; 0x9c9a <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    9c90:	8f ef       	ldi	r24, 0xFF	; 255
    9c92:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9c96:	80 93 af 50 	sts	0x50AF, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9c9a:	80 91 af 50 	lds	r24, 0x50AF
    9c9e:	8f 3f       	cpi	r24, 0xFF	; 255
    9ca0:	b9 f7       	brne	.-18     	; 0x9c90 <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    9ca2:	80 e0       	ldi	r24, 0x00	; 0
    9ca4:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    9ca8:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9cac:	88 e0       	ldi	r24, 0x08	; 8
    9cae:	60 e0       	ldi	r22, 0x00	; 0
    9cb0:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
}
    9cb4:	2a 96       	adiw	r28, 0x0a	; 10
    9cb6:	cd bf       	out	0x3d, r28	; 61
    9cb8:	de bf       	out	0x3e, r29	; 62
    9cba:	df 91       	pop	r29
    9cbc:	cf 91       	pop	r28
    9cbe:	1f 91       	pop	r17
    9cc0:	0f 91       	pop	r16
    9cc2:	08 95       	ret

00009cc4 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    9cc4:	0f 93       	push	r16
    9cc6:	1f 93       	push	r17
    9cc8:	cf 93       	push	r28
    9cca:	df 93       	push	r29
    9ccc:	cd b7       	in	r28, 0x3d	; 61
    9cce:	de b7       	in	r29, 0x3e	; 62
    9cd0:	6a 97       	sbiw	r28, 0x1a	; 26
    9cd2:	cd bf       	out	0x3d, r28	; 61
    9cd4:	de bf       	out	0x3e, r29	; 62
    9cd6:	6b 8b       	std	Y+19, r22	; 0x13
    9cd8:	7c 8b       	std	Y+20, r23	; 0x14
    9cda:	8d 8b       	std	Y+21, r24	; 0x15
    9cdc:	9e 8b       	std	Y+22, r25	; 0x16
    9cde:	4f 8b       	std	Y+23, r20	; 0x17
    9ce0:	58 8f       	std	Y+24, r21	; 0x18
    9ce2:	29 8f       	std	Y+25, r18	; 0x19
    9ce4:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9ce6:	88 e0       	ldi	r24, 0x08	; 8
    9ce8:	60 e0       	ldi	r22, 0x00	; 0
    9cea:	0e 94 9e 33 	call	0x673c	; 0x673c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9cee:	80 e0       	ldi	r24, 0x00	; 0
    9cf0:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    9cf4:	81 e0       	ldi	r24, 0x01	; 1
    9cf6:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    9cfa:	89 8d       	ldd	r24, Y+25	; 0x19
    9cfc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9cfe:	99 23       	and	r25, r25
    9d00:	14 f4       	brge	.+4      	; 0x9d06 <SD_write_multiple_blocks+0x42>
    9d02:	81 50       	subi	r24, 0x01	; 1
    9d04:	9e 4f       	sbci	r25, 0xFE	; 254
    9d06:	89 2f       	mov	r24, r25
    9d08:	99 0f       	add	r25, r25
    9d0a:	99 0b       	sbc	r25, r25
    9d0c:	85 95       	asr	r24
    9d0e:	89 83       	std	Y+1, r24	; 0x01
    9d10:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    9d12:	89 8d       	ldd	r24, Y+25	; 0x19
    9d14:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9d16:	20 e0       	ldi	r18, 0x00	; 0
    9d18:	32 e0       	ldi	r19, 0x02	; 2
    9d1a:	b9 01       	movw	r22, r18
    9d1c:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    9d20:	20 e0       	ldi	r18, 0x00	; 0
    9d22:	32 e0       	ldi	r19, 0x02	; 2
    9d24:	a9 01       	movw	r20, r18
    9d26:	48 1b       	sub	r20, r24
    9d28:	59 0b       	sbc	r21, r25
    9d2a:	ca 01       	movw	r24, r20
    9d2c:	8b 83       	std	Y+3, r24	; 0x03
    9d2e:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9d30:	8b 81       	ldd	r24, Y+3	; 0x03
    9d32:	9c 81       	ldd	r25, Y+4	; 0x04
    9d34:	52 e0       	ldi	r21, 0x02	; 2
    9d36:	80 30       	cpi	r24, 0x00	; 0
    9d38:	95 07       	cpc	r25, r21
    9d3a:	19 f4       	brne	.+6      	; 0x9d42 <SD_write_multiple_blocks+0x7e>
    9d3c:	1b 82       	std	Y+3, r1	; 0x03
    9d3e:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9d40:	05 c0       	rjmp	.+10     	; 0x9d4c <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    9d42:	89 81       	ldd	r24, Y+1	; 0x01
    9d44:	9a 81       	ldd	r25, Y+2	; 0x02
    9d46:	01 96       	adiw	r24, 0x01	; 1
    9d48:	89 83       	std	Y+1, r24	; 0x01
    9d4a:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9d4c:	00 00       	nop
    9d4e:	2b 89       	ldd	r18, Y+19	; 0x13
    9d50:	3c 89       	ldd	r19, Y+20	; 0x14
    9d52:	4d 89       	ldd	r20, Y+21	; 0x15
    9d54:	5e 89       	ldd	r21, Y+22	; 0x16
    9d56:	89 e1       	ldi	r24, 0x19	; 25
    9d58:	ba 01       	movw	r22, r20
    9d5a:	a9 01       	movw	r20, r18
    9d5c:	2f ef       	ldi	r18, 0xFF	; 255
    9d5e:	08 e0       	ldi	r16, 0x08	; 8
    9d60:	10 e0       	ldi	r17, 0x00	; 0
    9d62:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
    9d66:	88 23       	and	r24, r24
    9d68:	91 f7       	brne	.-28     	; 0x9d4e <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    9d6a:	1d 82       	std	Y+5, r1	; 0x05
    9d6c:	1e 82       	std	Y+6, r1	; 0x06
    9d6e:	ba c0       	rjmp	.+372    	; 0x9ee4 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    9d70:	8f ef       	ldi	r24, 0xFF	; 255
    9d72:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9d76:	80 93 a4 50 	sts	0x50A4, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    9d7a:	8c ef       	ldi	r24, 0xFC	; 252
    9d7c:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9d80:	80 93 a4 50 	sts	0x50A4, r24
		if(j == (numSectors-1)){
    9d84:	89 81       	ldd	r24, Y+1	; 0x01
    9d86:	9a 81       	ldd	r25, Y+2	; 0x02
    9d88:	9c 01       	movw	r18, r24
    9d8a:	21 50       	subi	r18, 0x01	; 1
    9d8c:	30 40       	sbci	r19, 0x00	; 0
    9d8e:	8d 81       	ldd	r24, Y+5	; 0x05
    9d90:	9e 81       	ldd	r25, Y+6	; 0x06
    9d92:	28 17       	cp	r18, r24
    9d94:	39 07       	cpc	r19, r25
    9d96:	09 f0       	breq	.+2      	; 0x9d9a <SD_write_multiple_blocks+0xd6>
    9d98:	54 c0       	rjmp	.+168    	; 0x9e42 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9d9a:	1f 82       	std	Y+7, r1	; 0x07
    9d9c:	18 86       	std	Y+8, r1	; 0x08
    9d9e:	25 c0       	rjmp	.+74     	; 0x9dea <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9da0:	8f 81       	ldd	r24, Y+7	; 0x07
    9da2:	98 85       	ldd	r25, Y+8	; 0x08
    9da4:	2c e0       	ldi	r18, 0x0C	; 12
    9da6:	30 e0       	ldi	r19, 0x00	; 0
    9da8:	b9 01       	movw	r22, r18
    9daa:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    9dae:	8c 01       	movw	r16, r24
    9db0:	8d 81       	ldd	r24, Y+5	; 0x05
    9db2:	9e 81       	ldd	r25, Y+6	; 0x06
    9db4:	9c 01       	movw	r18, r24
    9db6:	32 2f       	mov	r19, r18
    9db8:	22 27       	eor	r18, r18
    9dba:	33 0f       	add	r19, r19
    9dbc:	8f 81       	ldd	r24, Y+7	; 0x07
    9dbe:	98 85       	ldd	r25, Y+8	; 0x08
    9dc0:	82 0f       	add	r24, r18
    9dc2:	93 1f       	adc	r25, r19
    9dc4:	2f 89       	ldd	r18, Y+23	; 0x17
    9dc6:	38 8d       	ldd	r19, Y+24	; 0x18
    9dc8:	82 0f       	add	r24, r18
    9dca:	93 1f       	adc	r25, r19
    9dcc:	fc 01       	movw	r30, r24
    9dce:	80 81       	ld	r24, Z
    9dd0:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9dd4:	28 2f       	mov	r18, r24
    9dd6:	c8 01       	movw	r24, r16
    9dd8:	8d 55       	subi	r24, 0x5D	; 93
    9dda:	9f 4a       	sbci	r25, 0xAF	; 175
    9ddc:	fc 01       	movw	r30, r24
    9dde:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9de0:	8f 81       	ldd	r24, Y+7	; 0x07
    9de2:	98 85       	ldd	r25, Y+8	; 0x08
    9de4:	01 96       	adiw	r24, 0x01	; 1
    9de6:	8f 83       	std	Y+7, r24	; 0x07
    9de8:	98 87       	std	Y+8, r25	; 0x08
    9dea:	20 e0       	ldi	r18, 0x00	; 0
    9dec:	32 e0       	ldi	r19, 0x02	; 2
    9dee:	8b 81       	ldd	r24, Y+3	; 0x03
    9df0:	9c 81       	ldd	r25, Y+4	; 0x04
    9df2:	28 1b       	sub	r18, r24
    9df4:	39 0b       	sbc	r19, r25
    9df6:	8f 81       	ldd	r24, Y+7	; 0x07
    9df8:	98 85       	ldd	r25, Y+8	; 0x08
    9dfa:	82 17       	cp	r24, r18
    9dfc:	93 07       	cpc	r25, r19
    9dfe:	84 f2       	brlt	.-96     	; 0x9da0 <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9e00:	19 86       	std	Y+9, r1	; 0x09
    9e02:	1a 86       	std	Y+10, r1	; 0x0a
    9e04:	16 c0       	rjmp	.+44     	; 0x9e32 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    9e06:	89 85       	ldd	r24, Y+9	; 0x09
    9e08:	9a 85       	ldd	r25, Y+10	; 0x0a
    9e0a:	2c e0       	ldi	r18, 0x0C	; 12
    9e0c:	30 e0       	ldi	r19, 0x00	; 0
    9e0e:	b9 01       	movw	r22, r18
    9e10:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    9e14:	8c 01       	movw	r16, r24
    9e16:	80 e0       	ldi	r24, 0x00	; 0
    9e18:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9e1c:	28 2f       	mov	r18, r24
    9e1e:	c8 01       	movw	r24, r16
    9e20:	8d 55       	subi	r24, 0x5D	; 93
    9e22:	9f 4a       	sbci	r25, 0xAF	; 175
    9e24:	fc 01       	movw	r30, r24
    9e26:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9e28:	89 85       	ldd	r24, Y+9	; 0x09
    9e2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    9e2c:	01 96       	adiw	r24, 0x01	; 1
    9e2e:	89 87       	std	Y+9, r24	; 0x09
    9e30:	9a 87       	std	Y+10, r25	; 0x0a
    9e32:	29 85       	ldd	r18, Y+9	; 0x09
    9e34:	3a 85       	ldd	r19, Y+10	; 0x0a
    9e36:	8b 81       	ldd	r24, Y+3	; 0x03
    9e38:	9c 81       	ldd	r25, Y+4	; 0x04
    9e3a:	28 17       	cp	r18, r24
    9e3c:	39 07       	cpc	r19, r25
    9e3e:	1c f3       	brlt	.-58     	; 0x9e06 <SD_write_multiple_blocks+0x142>
    9e40:	2e c0       	rjmp	.+92     	; 0x9e9e <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9e42:	1b 86       	std	Y+11, r1	; 0x0b
    9e44:	1c 86       	std	Y+12, r1	; 0x0c
    9e46:	25 c0       	rjmp	.+74     	; 0x9e92 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9e48:	8b 85       	ldd	r24, Y+11	; 0x0b
    9e4a:	9c 85       	ldd	r25, Y+12	; 0x0c
    9e4c:	2c e0       	ldi	r18, 0x0C	; 12
    9e4e:	30 e0       	ldi	r19, 0x00	; 0
    9e50:	b9 01       	movw	r22, r18
    9e52:	0e 94 d7 61 	call	0xc3ae	; 0xc3ae <__divmodhi4>
    9e56:	8c 01       	movw	r16, r24
    9e58:	8d 81       	ldd	r24, Y+5	; 0x05
    9e5a:	9e 81       	ldd	r25, Y+6	; 0x06
    9e5c:	9c 01       	movw	r18, r24
    9e5e:	32 2f       	mov	r19, r18
    9e60:	22 27       	eor	r18, r18
    9e62:	33 0f       	add	r19, r19
    9e64:	8b 85       	ldd	r24, Y+11	; 0x0b
    9e66:	9c 85       	ldd	r25, Y+12	; 0x0c
    9e68:	82 0f       	add	r24, r18
    9e6a:	93 1f       	adc	r25, r19
    9e6c:	2f 89       	ldd	r18, Y+23	; 0x17
    9e6e:	38 8d       	ldd	r19, Y+24	; 0x18
    9e70:	82 0f       	add	r24, r18
    9e72:	93 1f       	adc	r25, r19
    9e74:	fc 01       	movw	r30, r24
    9e76:	80 81       	ld	r24, Z
    9e78:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9e7c:	28 2f       	mov	r18, r24
    9e7e:	c8 01       	movw	r24, r16
    9e80:	8d 55       	subi	r24, 0x5D	; 93
    9e82:	9f 4a       	sbci	r25, 0xAF	; 175
    9e84:	fc 01       	movw	r30, r24
    9e86:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9e88:	8b 85       	ldd	r24, Y+11	; 0x0b
    9e8a:	9c 85       	ldd	r25, Y+12	; 0x0c
    9e8c:	01 96       	adiw	r24, 0x01	; 1
    9e8e:	8b 87       	std	Y+11, r24	; 0x0b
    9e90:	9c 87       	std	Y+12, r25	; 0x0c
    9e92:	8b 85       	ldd	r24, Y+11	; 0x0b
    9e94:	9c 85       	ldd	r25, Y+12	; 0x0c
    9e96:	f2 e0       	ldi	r31, 0x02	; 2
    9e98:	80 30       	cpi	r24, 0x00	; 0
    9e9a:	9f 07       	cpc	r25, r31
    9e9c:	ac f2       	brlt	.-86     	; 0x9e48 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    9e9e:	1d 86       	std	Y+13, r1	; 0x0d
    9ea0:	1e 86       	std	Y+14, r1	; 0x0e
    9ea2:	0a c0       	rjmp	.+20     	; 0x9eb8 <SD_write_multiple_blocks+0x1f4>
    9ea4:	8f ef       	ldi	r24, 0xFF	; 255
    9ea6:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9eaa:	80 93 a4 50 	sts	0x50A4, r24
    9eae:	8d 85       	ldd	r24, Y+13	; 0x0d
    9eb0:	9e 85       	ldd	r25, Y+14	; 0x0e
    9eb2:	01 96       	adiw	r24, 0x01	; 1
    9eb4:	8d 87       	std	Y+13, r24	; 0x0d
    9eb6:	9e 87       	std	Y+14, r25	; 0x0e
    9eb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    9eba:	9e 85       	ldd	r25, Y+14	; 0x0e
    9ebc:	82 30       	cpi	r24, 0x02	; 2
    9ebe:	91 05       	cpc	r25, r1
    9ec0:	8c f3       	brlt	.-30     	; 0x9ea4 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    9ec2:	10 92 a4 50 	sts	0x50A4, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    9ec6:	05 c0       	rjmp	.+10     	; 0x9ed2 <SD_write_multiple_blocks+0x20e>
    9ec8:	8f ef       	ldi	r24, 0xFF	; 255
    9eca:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9ece:	80 93 a4 50 	sts	0x50A4, r24
    9ed2:	80 91 a4 50 	lds	r24, 0x50A4
    9ed6:	8f 3f       	cpi	r24, 0xFF	; 255
    9ed8:	b9 f7       	brne	.-18     	; 0x9ec8 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    9eda:	8d 81       	ldd	r24, Y+5	; 0x05
    9edc:	9e 81       	ldd	r25, Y+6	; 0x06
    9ede:	01 96       	adiw	r24, 0x01	; 1
    9ee0:	8d 83       	std	Y+5, r24	; 0x05
    9ee2:	9e 83       	std	Y+6, r25	; 0x06
    9ee4:	2d 81       	ldd	r18, Y+5	; 0x05
    9ee6:	3e 81       	ldd	r19, Y+6	; 0x06
    9ee8:	89 81       	ldd	r24, Y+1	; 0x01
    9eea:	9a 81       	ldd	r25, Y+2	; 0x02
    9eec:	28 17       	cp	r18, r24
    9eee:	39 07       	cpc	r19, r25
    9ef0:	0c f4       	brge	.+2      	; 0x9ef4 <SD_write_multiple_blocks+0x230>
    9ef2:	3e cf       	rjmp	.-388    	; 0x9d70 <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    9ef4:	1f 86       	std	Y+15, r1	; 0x0f
    9ef6:	18 8a       	std	Y+16, r1	; 0x10
    9ef8:	0a c0       	rjmp	.+20     	; 0x9f0e <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    9efa:	8f ef       	ldi	r24, 0xFF	; 255
    9efc:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9f00:	80 93 a4 50 	sts	0x50A4, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    9f04:	8f 85       	ldd	r24, Y+15	; 0x0f
    9f06:	98 89       	ldd	r25, Y+16	; 0x10
    9f08:	01 96       	adiw	r24, 0x01	; 1
    9f0a:	8f 87       	std	Y+15, r24	; 0x0f
    9f0c:	98 8b       	std	Y+16, r25	; 0x10
    9f0e:	8f 85       	ldd	r24, Y+15	; 0x0f
    9f10:	98 89       	ldd	r25, Y+16	; 0x10
    9f12:	84 30       	cpi	r24, 0x04	; 4
    9f14:	91 05       	cpc	r25, r1
    9f16:	8c f3       	brlt	.-30     	; 0x9efa <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    9f18:	8d ef       	ldi	r24, 0xFD	; 253
    9f1a:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9f1e:	80 93 a4 50 	sts	0x50A4, r24
	for(int i=0;i<4;i++){
    9f22:	19 8a       	std	Y+17, r1	; 0x11
    9f24:	1a 8a       	std	Y+18, r1	; 0x12
    9f26:	0a c0       	rjmp	.+20     	; 0x9f3c <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    9f28:	8f ef       	ldi	r24, 0xFF	; 255
    9f2a:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9f2e:	80 93 a4 50 	sts	0x50A4, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    9f32:	89 89       	ldd	r24, Y+17	; 0x11
    9f34:	9a 89       	ldd	r25, Y+18	; 0x12
    9f36:	01 96       	adiw	r24, 0x01	; 1
    9f38:	89 8b       	std	Y+17, r24	; 0x11
    9f3a:	9a 8b       	std	Y+18, r25	; 0x12
    9f3c:	89 89       	ldd	r24, Y+17	; 0x11
    9f3e:	9a 89       	ldd	r25, Y+18	; 0x12
    9f40:	84 30       	cpi	r24, 0x04	; 4
    9f42:	91 05       	cpc	r25, r1
    9f44:	8c f3       	brlt	.-30     	; 0x9f28 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    9f46:	10 92 a4 50 	sts	0x50A4, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    9f4a:	05 c0       	rjmp	.+10     	; 0x9f56 <SD_write_multiple_blocks+0x292>
    9f4c:	8f ef       	ldi	r24, 0xFF	; 255
    9f4e:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9f52:	80 93 a4 50 	sts	0x50A4, r24
    9f56:	80 91 a4 50 	lds	r24, 0x50A4
    9f5a:	8f 3f       	cpi	r24, 0xFF	; 255
    9f5c:	b9 f7       	brne	.-18     	; 0x9f4c <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    9f5e:	80 e0       	ldi	r24, 0x00	; 0
    9f60:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    9f64:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9f68:	88 e0       	ldi	r24, 0x08	; 8
    9f6a:	60 e0       	ldi	r22, 0x00	; 0
    9f6c:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
}
    9f70:	6a 96       	adiw	r28, 0x1a	; 26
    9f72:	cd bf       	out	0x3d, r28	; 61
    9f74:	de bf       	out	0x3e, r29	; 62
    9f76:	df 91       	pop	r29
    9f78:	cf 91       	pop	r28
    9f7a:	1f 91       	pop	r17
    9f7c:	0f 91       	pop	r16
    9f7e:	08 95       	ret

00009f80 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    9f80:	0f 93       	push	r16
    9f82:	1f 93       	push	r17
    9f84:	cf 93       	push	r28
    9f86:	df 93       	push	r29
    9f88:	cd b7       	in	r28, 0x3d	; 61
    9f8a:	de b7       	in	r29, 0x3e	; 62
    9f8c:	2e 97       	sbiw	r28, 0x0e	; 14
    9f8e:	cd bf       	out	0x3d, r28	; 61
    9f90:	de bf       	out	0x3e, r29	; 62
    9f92:	6f 83       	std	Y+7, r22	; 0x07
    9f94:	78 87       	std	Y+8, r23	; 0x08
    9f96:	89 87       	std	Y+9, r24	; 0x09
    9f98:	9a 87       	std	Y+10, r25	; 0x0a
    9f9a:	4b 87       	std	Y+11, r20	; 0x0b
    9f9c:	5c 87       	std	Y+12, r21	; 0x0c
    9f9e:	2d 87       	std	Y+13, r18	; 0x0d
    9fa0:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9fa2:	88 e0       	ldi	r24, 0x08	; 8
    9fa4:	60 e0       	ldi	r22, 0x00	; 0
    9fa6:	0e 94 9e 33 	call	0x673c	; 0x673c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9faa:	80 e0       	ldi	r24, 0x00	; 0
    9fac:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    9fb0:	81 e0       	ldi	r24, 0x01	; 1
    9fb2:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    9fb6:	00 00       	nop
    9fb8:	2f 81       	ldd	r18, Y+7	; 0x07
    9fba:	38 85       	ldd	r19, Y+8	; 0x08
    9fbc:	49 85       	ldd	r20, Y+9	; 0x09
    9fbe:	5a 85       	ldd	r21, Y+10	; 0x0a
    9fc0:	82 e1       	ldi	r24, 0x12	; 18
    9fc2:	ba 01       	movw	r22, r20
    9fc4:	a9 01       	movw	r20, r18
    9fc6:	2f ef       	ldi	r18, 0xFF	; 255
    9fc8:	08 e0       	ldi	r16, 0x08	; 8
    9fca:	10 e0       	ldi	r17, 0x00	; 0
    9fcc:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
    9fd0:	88 23       	and	r24, r24
    9fd2:	91 f7       	brne	.-28     	; 0x9fb8 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    9fd4:	19 82       	std	Y+1, r1	; 0x01
    9fd6:	1a 82       	std	Y+2, r1	; 0x02
    9fd8:	4b c0       	rjmp	.+150    	; 0xa070 <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    9fda:	8f ef       	ldi	r24, 0xFF	; 255
    9fdc:	80 93 a4 50 	sts	0x50A4, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    9fe0:	05 c0       	rjmp	.+10     	; 0x9fec <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    9fe2:	8f ef       	ldi	r24, 0xFF	; 255
    9fe4:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    9fe8:	80 93 a4 50 	sts	0x50A4, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    9fec:	80 91 a4 50 	lds	r24, 0x50A4
    9ff0:	8e 3f       	cpi	r24, 0xFE	; 254
    9ff2:	b9 f7       	brne	.-18     	; 0x9fe2 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9ff4:	1b 82       	std	Y+3, r1	; 0x03
    9ff6:	1c 82       	std	Y+4, r1	; 0x04
    9ff8:	19 c0       	rjmp	.+50     	; 0xa02c <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9ffa:	89 81       	ldd	r24, Y+1	; 0x01
    9ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    9ffe:	9c 01       	movw	r18, r24
    a000:	32 2f       	mov	r19, r18
    a002:	22 27       	eor	r18, r18
    a004:	33 0f       	add	r19, r19
    a006:	8b 81       	ldd	r24, Y+3	; 0x03
    a008:	9c 81       	ldd	r25, Y+4	; 0x04
    a00a:	82 0f       	add	r24, r18
    a00c:	93 1f       	adc	r25, r19
    a00e:	2b 85       	ldd	r18, Y+11	; 0x0b
    a010:	3c 85       	ldd	r19, Y+12	; 0x0c
    a012:	89 01       	movw	r16, r18
    a014:	08 0f       	add	r16, r24
    a016:	19 1f       	adc	r17, r25
    a018:	8f ef       	ldi	r24, 0xFF	; 255
    a01a:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    a01e:	f8 01       	movw	r30, r16
    a020:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a022:	8b 81       	ldd	r24, Y+3	; 0x03
    a024:	9c 81       	ldd	r25, Y+4	; 0x04
    a026:	01 96       	adiw	r24, 0x01	; 1
    a028:	8b 83       	std	Y+3, r24	; 0x03
    a02a:	9c 83       	std	Y+4, r25	; 0x04
    a02c:	8b 81       	ldd	r24, Y+3	; 0x03
    a02e:	9c 81       	ldd	r25, Y+4	; 0x04
    a030:	f2 e0       	ldi	r31, 0x02	; 2
    a032:	80 30       	cpi	r24, 0x00	; 0
    a034:	9f 07       	cpc	r25, r31
    a036:	0c f3       	brlt	.-62     	; 0x9ffa <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a038:	1d 82       	std	Y+5, r1	; 0x05
    a03a:	1e 82       	std	Y+6, r1	; 0x06
    a03c:	0f c0       	rjmp	.+30     	; 0xa05c <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a03e:	8f ef       	ldi	r24, 0xFF	; 255
    a040:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    a044:	28 2f       	mov	r18, r24
    a046:	8d 81       	ldd	r24, Y+5	; 0x05
    a048:	9e 81       	ldd	r25, Y+6	; 0x06
    a04a:	8d 55       	subi	r24, 0x5D	; 93
    a04c:	9f 4a       	sbci	r25, 0xAF	; 175
    a04e:	fc 01       	movw	r30, r24
    a050:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a052:	8d 81       	ldd	r24, Y+5	; 0x05
    a054:	9e 81       	ldd	r25, Y+6	; 0x06
    a056:	01 96       	adiw	r24, 0x01	; 1
    a058:	8d 83       	std	Y+5, r24	; 0x05
    a05a:	9e 83       	std	Y+6, r25	; 0x06
    a05c:	8d 81       	ldd	r24, Y+5	; 0x05
    a05e:	9e 81       	ldd	r25, Y+6	; 0x06
    a060:	82 30       	cpi	r24, 0x02	; 2
    a062:	91 05       	cpc	r25, r1
    a064:	64 f3       	brlt	.-40     	; 0xa03e <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a066:	89 81       	ldd	r24, Y+1	; 0x01
    a068:	9a 81       	ldd	r25, Y+2	; 0x02
    a06a:	01 96       	adiw	r24, 0x01	; 1
    a06c:	89 83       	std	Y+1, r24	; 0x01
    a06e:	9a 83       	std	Y+2, r25	; 0x02
    a070:	29 81       	ldd	r18, Y+1	; 0x01
    a072:	3a 81       	ldd	r19, Y+2	; 0x02
    a074:	8d 85       	ldd	r24, Y+13	; 0x0d
    a076:	9e 85       	ldd	r25, Y+14	; 0x0e
    a078:	28 17       	cp	r18, r24
    a07a:	39 07       	cpc	r19, r25
    a07c:	0c f4       	brge	.+2      	; 0xa080 <SD_read_multiple_blocks+0x100>
    a07e:	ad cf       	rjmp	.-166    	; 0x9fda <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a080:	8c e0       	ldi	r24, 0x0C	; 12
    a082:	40 e0       	ldi	r20, 0x00	; 0
    a084:	50 e0       	ldi	r21, 0x00	; 0
    a086:	ba 01       	movw	r22, r20
    a088:	2f ef       	ldi	r18, 0xFF	; 255
    a08a:	08 e0       	ldi	r16, 0x08	; 8
    a08c:	10 e0       	ldi	r17, 0x00	; 0
    a08e:	0e 94 a0 4c 	call	0x9940	; 0x9940 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a092:	8f ef       	ldi	r24, 0xFF	; 255
    a094:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    a098:	80 93 a3 50 	sts	0x50A3, r24
	Buffer[1] = FILLER_BYTE;
    a09c:	10 92 a4 50 	sts	0x50A4, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a0a0:	05 c0       	rjmp	.+10     	; 0xa0ac <SD_read_multiple_blocks+0x12c>
    a0a2:	8f ef       	ldi	r24, 0xFF	; 255
    a0a4:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
    a0a8:	80 93 a4 50 	sts	0x50A4, r24
    a0ac:	80 91 a4 50 	lds	r24, 0x50A4
    a0b0:	8f 3f       	cpi	r24, 0xFF	; 255
    a0b2:	b9 f7       	brne	.-18     	; 0xa0a2 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a0b4:	80 e0       	ldi	r24, 0x00	; 0
    a0b6:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    a0ba:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a0be:	88 e0       	ldi	r24, 0x08	; 8
    a0c0:	60 e0       	ldi	r22, 0x00	; 0
    a0c2:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
}
    a0c6:	2e 96       	adiw	r28, 0x0e	; 14
    a0c8:	cd bf       	out	0x3d, r28	; 61
    a0ca:	de bf       	out	0x3e, r29	; 62
    a0cc:	df 91       	pop	r29
    a0ce:	cf 91       	pop	r28
    a0d0:	1f 91       	pop	r17
    a0d2:	0f 91       	pop	r16
    a0d4:	08 95       	ret

0000a0d6 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a0d6:	cf 93       	push	r28
    a0d8:	df 93       	push	r29
    a0da:	cd b7       	in	r28, 0x3d	; 61
    a0dc:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a0de:	88 e0       	ldi	r24, 0x08	; 8
    a0e0:	60 e0       	ldi	r22, 0x00	; 0
    a0e2:	0e 94 6f 32 	call	0x64de	; 0x64de <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a0e6:	88 e0       	ldi	r24, 0x08	; 8
    a0e8:	60 e0       	ldi	r22, 0x00	; 0
    a0ea:	0e 94 3b 33 	call	0x6676	; 0x6676 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a0ee:	80 e0       	ldi	r24, 0x00	; 0
    a0f0:	0e 94 0b 37 	call	0x6e16	; 0x6e16 <SPIInit>
	SPICS(TRUE);
    a0f4:	81 e0       	ldi	r24, 0x01	; 1
    a0f6:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a0fa:	8f ef       	ldi	r24, 0xFF	; 255
    a0fc:	0e 94 82 4c 	call	0x9904	; 0x9904 <SPI_write>
	SPICS(FALSE);	//stop spi
    a100:	80 e0       	ldi	r24, 0x00	; 0
    a102:	0e 94 60 37 	call	0x6ec0	; 0x6ec0 <SPICS>
	SPIDisable();
    a106:	0e 94 78 37 	call	0x6ef0	; 0x6ef0 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a10a:	80 e0       	ldi	r24, 0x00	; 0
    a10c:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a110:	80 e0       	ldi	r24, 0x00	; 0
    a112:	0e 94 05 34 	call	0x680a	; 0x680a <Ext1Power>
}
    a116:	df 91       	pop	r29
    a118:	cf 91       	pop	r28
    a11a:	08 95       	ret

0000a11c <main>:
#include "E-000001-000009_firmware_rev_1_0.h"

volatile int numOfSamples;
int32_t testArray[150];

int main(void) {
    a11c:	8f 92       	push	r8
    a11e:	9f 92       	push	r9
    a120:	af 92       	push	r10
    a122:	bf 92       	push	r11
    a124:	cf 92       	push	r12
    a126:	df 92       	push	r13
    a128:	ef 92       	push	r14
    a12a:	0f 93       	push	r16
    a12c:	cf 93       	push	r28
    a12e:	df 93       	push	r29
    a130:	00 d0       	rcall	.+0      	; 0xa132 <main+0x16>
    a132:	00 d0       	rcall	.+0      	; 0xa134 <main+0x18>
    a134:	cd b7       	in	r28, 0x3d	; 61
    a136:	de b7       	in	r29, 0x3e	; 62
	
	int UnityGain[] = {0,0,0};
    a138:	19 82       	std	Y+1, r1	; 0x01
    a13a:	1a 82       	std	Y+2, r1	; 0x02
    a13c:	1b 82       	std	Y+3, r1	; 0x03
    a13e:	1c 82       	std	Y+4, r1	; 0x04
    a140:	1d 82       	std	Y+5, r1	; 0x05
    a142:	1e 82       	std	Y+6, r1	; 0x06
// 	nop();
// 	while(1){
// 		nop();
// 	}
	//CO_collectADC(ADC_CH_8_gc, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), GAIN_16_gc, SPS_4K_gc, 100, testArray);
	CO_collectSeismic1Channel(ADC_CH_8_gc,(uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc),GAIN_1_gc, SSPS_SE_4K_gc, 5, TRUE, 1, 2, 3, 4,100,testArray);
    a144:	8d b7       	in	r24, 0x3d	; 61
    a146:	9e b7       	in	r25, 0x3e	; 62
    a148:	08 97       	sbiw	r24, 0x08	; 8
    a14a:	8d bf       	out	0x3d, r24	; 61
    a14c:	9e bf       	out	0x3e, r25	; 62
    a14e:	2d b7       	in	r18, 0x3d	; 61
    a150:	3e b7       	in	r19, 0x3e	; 62
    a152:	2f 5f       	subi	r18, 0xFF	; 255
    a154:	3f 4f       	sbci	r19, 0xFF	; 255
    a156:	84 e0       	ldi	r24, 0x04	; 4
    a158:	90 e0       	ldi	r25, 0x00	; 0
    a15a:	f9 01       	movw	r30, r18
    a15c:	80 83       	st	Z, r24
    a15e:	91 83       	std	Z+1, r25	; 0x01
    a160:	84 e6       	ldi	r24, 0x64	; 100
    a162:	90 e0       	ldi	r25, 0x00	; 0
    a164:	a0 e0       	ldi	r26, 0x00	; 0
    a166:	b0 e0       	ldi	r27, 0x00	; 0
    a168:	f9 01       	movw	r30, r18
    a16a:	82 83       	std	Z+2, r24	; 0x02
    a16c:	93 83       	std	Z+3, r25	; 0x03
    a16e:	a4 83       	std	Z+4, r26	; 0x04
    a170:	b5 83       	std	Z+5, r27	; 0x05
    a172:	8b ec       	ldi	r24, 0xCB	; 203
    a174:	90 e5       	ldi	r25, 0x50	; 80
    a176:	f9 01       	movw	r30, r18
    a178:	86 83       	std	Z+6, r24	; 0x06
    a17a:	97 83       	std	Z+7, r25	; 0x07
    a17c:	87 e0       	ldi	r24, 0x07	; 7
    a17e:	64 ec       	ldi	r22, 0xC4	; 196
    a180:	40 e0       	ldi	r20, 0x00	; 0
    a182:	24 e0       	ldi	r18, 0x04	; 4
    a184:	05 e0       	ldi	r16, 0x05	; 5
    a186:	ee 24       	eor	r14, r14
    a188:	e3 94       	inc	r14
    a18a:	cc 24       	eor	r12, r12
    a18c:	dd 24       	eor	r13, r13
    a18e:	c3 94       	inc	r12
    a190:	aa 24       	eor	r10, r10
    a192:	bb 24       	eor	r11, r11
    a194:	68 94       	set
    a196:	a1 f8       	bld	r10, 1
    a198:	0f 2e       	mov	r0, r31
    a19a:	f3 e0       	ldi	r31, 0x03	; 3
    a19c:	8f 2e       	mov	r8, r31
    a19e:	99 24       	eor	r9, r9
    a1a0:	f0 2d       	mov	r31, r0
    a1a2:	0e 94 08 11 	call	0x2210	; 0x2210 <CO_collectSeismic1Channel>
    a1a6:	8d b7       	in	r24, 0x3d	; 61
    a1a8:	9e b7       	in	r25, 0x3e	; 62
    a1aa:	08 96       	adiw	r24, 0x08	; 8
    a1ac:	8d bf       	out	0x3d, r24	; 61
    a1ae:	9e bf       	out	0x3e, r25	; 62
    a1b0:	80 e0       	ldi	r24, 0x00	; 0
    a1b2:	90 e0       	ldi	r25, 0x00	; 0
	//CO_collectSeismic3Axises((uint8_t) (FILTER_CH_3AND7_bm | FILTER_CH_2AND6_bm | FILTER_HP_0_bm | FILTER_LP_600_gc),UnityGain, SSPS_SE_4K_gc, 5, TRUE, 1, 2, 3, 4,100,testArray);
    a1b4:	26 96       	adiw	r28, 0x06	; 6
    a1b6:	cd bf       	out	0x3d, r28	; 61
    a1b8:	de bf       	out	0x3e, r29	; 62
    a1ba:	df 91       	pop	r29
    a1bc:	cf 91       	pop	r28
    a1be:	0f 91       	pop	r16
    a1c0:	ef 90       	pop	r14
    a1c2:	df 90       	pop	r13
    a1c4:	cf 90       	pop	r12
    a1c6:	bf 90       	pop	r11
    a1c8:	af 90       	pop	r10
    a1ca:	9f 90       	pop	r9
    a1cc:	8f 90       	pop	r8
    a1ce:	08 95       	ret

0000a1d0 <__muldi3>:
    a1d0:	a0 e3       	ldi	r26, 0x30	; 48
    a1d2:	b0 e0       	ldi	r27, 0x00	; 0
    a1d4:	ee ee       	ldi	r30, 0xEE	; 238
    a1d6:	f0 e5       	ldi	r31, 0x50	; 80
    a1d8:	0c 94 29 62 	jmp	0xc452	; 0xc452 <__prologue_saves__+0x4>
    a1dc:	29 8f       	std	Y+25, r18	; 0x19
    a1de:	3a 8f       	std	Y+26, r19	; 0x1a
    a1e0:	4b 8f       	std	Y+27, r20	; 0x1b
    a1e2:	5c 8f       	std	Y+28, r21	; 0x1c
    a1e4:	6d 8f       	std	Y+29, r22	; 0x1d
    a1e6:	7e 8f       	std	Y+30, r23	; 0x1e
    a1e8:	8f 8f       	std	Y+31, r24	; 0x1f
    a1ea:	98 a3       	lds	r25, 0x58
    a1ec:	a9 8a       	std	Y+17, r10	; 0x11
    a1ee:	ba 8a       	std	Y+18, r11	; 0x12
    a1f0:	cb 8a       	std	Y+19, r12	; 0x13
    a1f2:	dc 8a       	std	Y+20, r13	; 0x14
    a1f4:	ed 8a       	std	Y+21, r14	; 0x15
    a1f6:	fe 8a       	std	Y+22, r15	; 0x16
    a1f8:	0f 8b       	std	Y+23, r16	; 0x17
    a1fa:	18 8f       	std	Y+24, r17	; 0x18
    a1fc:	09 8d       	ldd	r16, Y+25	; 0x19
    a1fe:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a200:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a202:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a204:	09 a3       	lds	r16, 0x59
    a206:	1a a3       	lds	r17, 0x5a
    a208:	2b a3       	lds	r18, 0x5b
    a20a:	3c a3       	lds	r19, 0x5c
    a20c:	68 01       	movw	r12, r16
    a20e:	79 01       	movw	r14, r18
    a210:	8f ef       	ldi	r24, 0xFF	; 255
    a212:	9f ef       	ldi	r25, 0xFF	; 255
    a214:	a0 e0       	ldi	r26, 0x00	; 0
    a216:	b0 e0       	ldi	r27, 0x00	; 0
    a218:	c8 22       	and	r12, r24
    a21a:	d9 22       	and	r13, r25
    a21c:	ea 22       	and	r14, r26
    a21e:	fb 22       	and	r15, r27
    a220:	89 01       	movw	r16, r18
    a222:	22 27       	eor	r18, r18
    a224:	33 27       	eor	r19, r19
    a226:	09 a7       	lds	r16, 0x79
    a228:	1a a7       	lds	r17, 0x7a
    a22a:	2b a7       	lds	r18, 0x7b
    a22c:	3c a7       	lds	r19, 0x7c
    a22e:	09 89       	ldd	r16, Y+17	; 0x11
    a230:	1a 89       	ldd	r17, Y+18	; 0x12
    a232:	2b 89       	ldd	r18, Y+19	; 0x13
    a234:	3c 89       	ldd	r19, Y+20	; 0x14
    a236:	0d a3       	lds	r16, 0x5d
    a238:	1e a3       	lds	r17, 0x5e
    a23a:	2f a3       	lds	r18, 0x5f
    a23c:	38 a7       	lds	r19, 0x78
    a23e:	48 01       	movw	r8, r16
    a240:	59 01       	movw	r10, r18
    a242:	88 22       	and	r8, r24
    a244:	99 22       	and	r9, r25
    a246:	aa 22       	and	r10, r26
    a248:	bb 22       	and	r11, r27
    a24a:	29 01       	movw	r4, r18
    a24c:	66 24       	eor	r6, r6
    a24e:	77 24       	eor	r7, r7
    a250:	c5 01       	movw	r24, r10
    a252:	b4 01       	movw	r22, r8
    a254:	a7 01       	movw	r20, r14
    a256:	96 01       	movw	r18, r12
    a258:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a25c:	6d a7       	lds	r22, 0x7d
    a25e:	7e a7       	lds	r23, 0x7e
    a260:	8f a7       	lds	r24, 0x7f
    a262:	98 ab       	sts	0x58, r25
    a264:	c3 01       	movw	r24, r6
    a266:	b2 01       	movw	r22, r4
    a268:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a26c:	6b 01       	movw	r12, r22
    a26e:	7c 01       	movw	r14, r24
    a270:	c5 01       	movw	r24, r10
    a272:	b4 01       	movw	r22, r8
    a274:	29 a5       	lds	r18, 0x69
    a276:	3a a5       	lds	r19, 0x6a
    a278:	4b a5       	lds	r20, 0x6b
    a27a:	5c a5       	lds	r21, 0x6c
    a27c:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a280:	4b 01       	movw	r8, r22
    a282:	5c 01       	movw	r10, r24
    a284:	c3 01       	movw	r24, r6
    a286:	b2 01       	movw	r22, r4
    a288:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a28c:	ab 01       	movw	r20, r22
    a28e:	bc 01       	movw	r22, r24
    a290:	c8 0c       	add	r12, r8
    a292:	d9 1c       	adc	r13, r9
    a294:	ea 1c       	adc	r14, r10
    a296:	fb 1c       	adc	r15, r11
    a298:	0d a5       	lds	r16, 0x6d
    a29a:	1e a5       	lds	r17, 0x6e
    a29c:	2f a5       	lds	r18, 0x6f
    a29e:	38 a9       	sts	0x48, r19
    a2a0:	c9 01       	movw	r24, r18
    a2a2:	aa 27       	eor	r26, r26
    a2a4:	bb 27       	eor	r27, r27
    a2a6:	c8 0e       	add	r12, r24
    a2a8:	d9 1e       	adc	r13, r25
    a2aa:	ea 1e       	adc	r14, r26
    a2ac:	fb 1e       	adc	r15, r27
    a2ae:	c8 14       	cp	r12, r8
    a2b0:	d9 04       	cpc	r13, r9
    a2b2:	ea 04       	cpc	r14, r10
    a2b4:	fb 04       	cpc	r15, r11
    a2b6:	20 f4       	brcc	.+8      	; 0xa2c0 <__muldi3+0xf0>
    a2b8:	40 50       	subi	r20, 0x00	; 0
    a2ba:	50 40       	sbci	r21, 0x00	; 0
    a2bc:	6f 4f       	sbci	r22, 0xFF	; 255
    a2be:	7f 4f       	sbci	r23, 0xFF	; 255
    a2c0:	c7 01       	movw	r24, r14
    a2c2:	aa 27       	eor	r26, r26
    a2c4:	bb 27       	eor	r27, r27
    a2c6:	84 0f       	add	r24, r20
    a2c8:	95 1f       	adc	r25, r21
    a2ca:	a6 1f       	adc	r26, r22
    a2cc:	b7 1f       	adc	r27, r23
    a2ce:	8d 83       	std	Y+5, r24	; 0x05
    a2d0:	9e 83       	std	Y+6, r25	; 0x06
    a2d2:	af 83       	std	Y+7, r26	; 0x07
    a2d4:	b8 87       	std	Y+8, r27	; 0x08
    a2d6:	76 01       	movw	r14, r12
    a2d8:	dd 24       	eor	r13, r13
    a2da:	cc 24       	eor	r12, r12
    a2dc:	4d a5       	lds	r20, 0x6d
    a2de:	5e a5       	lds	r21, 0x6e
    a2e0:	6f a5       	lds	r22, 0x6f
    a2e2:	78 a9       	sts	0x48, r23
    a2e4:	60 70       	andi	r22, 0x00	; 0
    a2e6:	70 70       	andi	r23, 0x00	; 0
    a2e8:	c4 0e       	add	r12, r20
    a2ea:	d5 1e       	adc	r13, r21
    a2ec:	e6 1e       	adc	r14, r22
    a2ee:	f7 1e       	adc	r15, r23
    a2f0:	c9 82       	std	Y+1, r12	; 0x01
    a2f2:	da 82       	std	Y+2, r13	; 0x02
    a2f4:	eb 82       	std	Y+3, r14	; 0x03
    a2f6:	fc 82       	std	Y+4, r15	; 0x04
    a2f8:	1c 2d       	mov	r17, r12
    a2fa:	0a 81       	ldd	r16, Y+2	; 0x02
    a2fc:	8b 80       	ldd	r8, Y+3	; 0x03
    a2fe:	4c 80       	ldd	r4, Y+4	; 0x04
    a300:	8d 87       	std	Y+13, r24	; 0x0d
    a302:	8e 81       	ldd	r24, Y+6	; 0x06
    a304:	8e 87       	std	Y+14, r24	; 0x0e
    a306:	8f 81       	ldd	r24, Y+7	; 0x07
    a308:	8f 87       	std	Y+15, r24	; 0x0f
    a30a:	88 85       	ldd	r24, Y+8	; 0x08
    a30c:	88 8b       	std	Y+16, r24	; 0x10
    a30e:	2d 89       	ldd	r18, Y+21	; 0x15
    a310:	3e 89       	ldd	r19, Y+22	; 0x16
    a312:	4f 89       	ldd	r20, Y+23	; 0x17
    a314:	58 8d       	ldd	r21, Y+24	; 0x18
    a316:	69 a1       	lds	r22, 0x49
    a318:	7a a1       	lds	r23, 0x4a
    a31a:	8b a1       	lds	r24, 0x4b
    a31c:	9c a1       	lds	r25, 0x4c
    a31e:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a322:	6b 01       	movw	r12, r22
    a324:	7c 01       	movw	r14, r24
    a326:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a328:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a32a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a32c:	58 a1       	lds	r21, 0x48
    a32e:	6d a1       	lds	r22, 0x4d
    a330:	7e a1       	lds	r23, 0x4e
    a332:	8f a1       	lds	r24, 0x4f
    a334:	98 a5       	lds	r25, 0x68
    a336:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a33a:	dc 01       	movw	r26, r24
    a33c:	cb 01       	movw	r24, r22
    a33e:	c8 0e       	add	r12, r24
    a340:	d9 1e       	adc	r13, r25
    a342:	ea 1e       	adc	r14, r26
    a344:	fb 1e       	adc	r15, r27
    a346:	8d 85       	ldd	r24, Y+13	; 0x0d
    a348:	9e 85       	ldd	r25, Y+14	; 0x0e
    a34a:	af 85       	ldd	r26, Y+15	; 0x0f
    a34c:	b8 89       	ldd	r27, Y+16	; 0x10
    a34e:	8c 0d       	add	r24, r12
    a350:	9d 1d       	adc	r25, r13
    a352:	ae 1d       	adc	r26, r14
    a354:	bf 1d       	adc	r27, r15
    a356:	8d 87       	std	Y+13, r24	; 0x0d
    a358:	9e 87       	std	Y+14, r25	; 0x0e
    a35a:	af 87       	std	Y+15, r26	; 0x0f
    a35c:	b8 8b       	std	Y+16, r27	; 0x10
    a35e:	68 2f       	mov	r22, r24
    a360:	7e 85       	ldd	r23, Y+14	; 0x0e
    a362:	21 2f       	mov	r18, r17
    a364:	30 2f       	mov	r19, r16
    a366:	48 2d       	mov	r20, r8
    a368:	54 2d       	mov	r21, r4
    a36a:	8f 85       	ldd	r24, Y+15	; 0x0f
    a36c:	98 89       	ldd	r25, Y+16	; 0x10
    a36e:	e0 96       	adiw	r28, 0x30	; 48
    a370:	e0 e1       	ldi	r30, 0x10	; 16
    a372:	0c 94 42 62 	jmp	0xc484	; 0xc484 <__epilogue_restores__+0x4>

0000a376 <__ashldi3>:
    a376:	cf 92       	push	r12
    a378:	df 92       	push	r13
    a37a:	ef 92       	push	r14
    a37c:	ff 92       	push	r15
    a37e:	0f 93       	push	r16
    a380:	cf 93       	push	r28
    a382:	df 93       	push	r29
    a384:	cd b7       	in	r28, 0x3d	; 61
    a386:	de b7       	in	r29, 0x3e	; 62
    a388:	60 97       	sbiw	r28, 0x10	; 16
    a38a:	cd bf       	out	0x3d, r28	; 61
    a38c:	de bf       	out	0x3e, r29	; 62
    a38e:	00 23       	and	r16, r16
    a390:	09 f4       	brne	.+2      	; 0xa394 <__ashldi3+0x1e>
    a392:	5a c0       	rjmp	.+180    	; 0xa448 <__ashldi3+0xd2>
    a394:	29 87       	std	Y+9, r18	; 0x09
    a396:	3a 87       	std	Y+10, r19	; 0x0a
    a398:	4b 87       	std	Y+11, r20	; 0x0b
    a39a:	5c 87       	std	Y+12, r21	; 0x0c
    a39c:	6d 87       	std	Y+13, r22	; 0x0d
    a39e:	7e 87       	std	Y+14, r23	; 0x0e
    a3a0:	8f 87       	std	Y+15, r24	; 0x0f
    a3a2:	98 8b       	std	Y+16, r25	; 0x10
    a3a4:	80 e2       	ldi	r24, 0x20	; 32
    a3a6:	80 1b       	sub	r24, r16
    a3a8:	49 85       	ldd	r20, Y+9	; 0x09
    a3aa:	5a 85       	ldd	r21, Y+10	; 0x0a
    a3ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    a3ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    a3b0:	18 16       	cp	r1, r24
    a3b2:	b4 f0       	brlt	.+44     	; 0xa3e0 <__ashldi3+0x6a>
    a3b4:	19 82       	std	Y+1, r1	; 0x01
    a3b6:	1a 82       	std	Y+2, r1	; 0x02
    a3b8:	1b 82       	std	Y+3, r1	; 0x03
    a3ba:	1c 82       	std	Y+4, r1	; 0x04
    a3bc:	99 27       	eor	r25, r25
    a3be:	87 fd       	sbrc	r24, 7
    a3c0:	90 95       	com	r25
    a3c2:	90 95       	com	r25
    a3c4:	81 95       	neg	r24
    a3c6:	9f 4f       	sbci	r25, 0xFF	; 255
    a3c8:	04 c0       	rjmp	.+8      	; 0xa3d2 <__ashldi3+0x5c>
    a3ca:	44 0f       	add	r20, r20
    a3cc:	55 1f       	adc	r21, r21
    a3ce:	66 1f       	adc	r22, r22
    a3d0:	77 1f       	adc	r23, r23
    a3d2:	8a 95       	dec	r24
    a3d4:	d2 f7       	brpl	.-12     	; 0xa3ca <__ashldi3+0x54>
    a3d6:	4d 83       	std	Y+5, r20	; 0x05
    a3d8:	5e 83       	std	Y+6, r21	; 0x06
    a3da:	6f 83       	std	Y+7, r22	; 0x07
    a3dc:	78 87       	std	Y+8, r23	; 0x08
    a3de:	2c c0       	rjmp	.+88     	; 0xa438 <__ashldi3+0xc2>
    a3e0:	6a 01       	movw	r12, r20
    a3e2:	7b 01       	movw	r14, r22
    a3e4:	00 2e       	mov	r0, r16
    a3e6:	04 c0       	rjmp	.+8      	; 0xa3f0 <__ashldi3+0x7a>
    a3e8:	cc 0c       	add	r12, r12
    a3ea:	dd 1c       	adc	r13, r13
    a3ec:	ee 1c       	adc	r14, r14
    a3ee:	ff 1c       	adc	r15, r15
    a3f0:	0a 94       	dec	r0
    a3f2:	d2 f7       	brpl	.-12     	; 0xa3e8 <__ashldi3+0x72>
    a3f4:	c9 82       	std	Y+1, r12	; 0x01
    a3f6:	da 82       	std	Y+2, r13	; 0x02
    a3f8:	eb 82       	std	Y+3, r14	; 0x03
    a3fa:	fc 82       	std	Y+4, r15	; 0x04
    a3fc:	6a 01       	movw	r12, r20
    a3fe:	7b 01       	movw	r14, r22
    a400:	04 c0       	rjmp	.+8      	; 0xa40a <__ashldi3+0x94>
    a402:	f6 94       	lsr	r15
    a404:	e7 94       	ror	r14
    a406:	d7 94       	ror	r13
    a408:	c7 94       	ror	r12
    a40a:	8a 95       	dec	r24
    a40c:	d2 f7       	brpl	.-12     	; 0xa402 <__ashldi3+0x8c>
    a40e:	d7 01       	movw	r26, r14
    a410:	c6 01       	movw	r24, r12
    a412:	4d 85       	ldd	r20, Y+13	; 0x0d
    a414:	5e 85       	ldd	r21, Y+14	; 0x0e
    a416:	6f 85       	ldd	r22, Y+15	; 0x0f
    a418:	78 89       	ldd	r23, Y+16	; 0x10
    a41a:	04 c0       	rjmp	.+8      	; 0xa424 <__ashldi3+0xae>
    a41c:	44 0f       	add	r20, r20
    a41e:	55 1f       	adc	r21, r21
    a420:	66 1f       	adc	r22, r22
    a422:	77 1f       	adc	r23, r23
    a424:	0a 95       	dec	r16
    a426:	d2 f7       	brpl	.-12     	; 0xa41c <__ashldi3+0xa6>
    a428:	84 2b       	or	r24, r20
    a42a:	95 2b       	or	r25, r21
    a42c:	a6 2b       	or	r26, r22
    a42e:	b7 2b       	or	r27, r23
    a430:	8d 83       	std	Y+5, r24	; 0x05
    a432:	9e 83       	std	Y+6, r25	; 0x06
    a434:	af 83       	std	Y+7, r26	; 0x07
    a436:	b8 87       	std	Y+8, r27	; 0x08
    a438:	29 81       	ldd	r18, Y+1	; 0x01
    a43a:	3a 81       	ldd	r19, Y+2	; 0x02
    a43c:	4b 81       	ldd	r20, Y+3	; 0x03
    a43e:	5c 81       	ldd	r21, Y+4	; 0x04
    a440:	6d 81       	ldd	r22, Y+5	; 0x05
    a442:	7e 81       	ldd	r23, Y+6	; 0x06
    a444:	8f 81       	ldd	r24, Y+7	; 0x07
    a446:	98 85       	ldd	r25, Y+8	; 0x08
    a448:	60 96       	adiw	r28, 0x10	; 16
    a44a:	cd bf       	out	0x3d, r28	; 61
    a44c:	de bf       	out	0x3e, r29	; 62
    a44e:	df 91       	pop	r29
    a450:	cf 91       	pop	r28
    a452:	0f 91       	pop	r16
    a454:	ff 90       	pop	r15
    a456:	ef 90       	pop	r14
    a458:	df 90       	pop	r13
    a45a:	cf 90       	pop	r12
    a45c:	08 95       	ret

0000a45e <__divdi3>:
    a45e:	a8 e4       	ldi	r26, 0x48	; 72
    a460:	b0 e0       	ldi	r27, 0x00	; 0
    a462:	e5 e3       	ldi	r30, 0x35	; 53
    a464:	f2 e5       	ldi	r31, 0x52	; 82
    a466:	0c 94 28 62 	jmp	0xc450	; 0xc450 <__prologue_saves__+0x2>
    a46a:	f5 01       	movw	r30, r10
    a46c:	29 a3       	lds	r18, 0x59
    a46e:	3a a3       	lds	r19, 0x5a
    a470:	4b a3       	lds	r20, 0x5b
    a472:	5c a3       	lds	r21, 0x5c
    a474:	6d a3       	lds	r22, 0x5d
    a476:	7e a3       	lds	r23, 0x5e
    a478:	8f a3       	lds	r24, 0x5f
    a47a:	98 a7       	lds	r25, 0x78
    a47c:	a9 8e       	std	Y+25, r10	; 0x19
    a47e:	fa 8f       	std	Y+26, r31	; 0x1a
    a480:	cb 8e       	std	Y+27, r12	; 0x1b
    a482:	dc 8e       	std	Y+28, r13	; 0x1c
    a484:	ed 8e       	std	Y+29, r14	; 0x1d
    a486:	fe 8e       	std	Y+30, r15	; 0x1e
    a488:	0f 8f       	std	Y+31, r16	; 0x1f
    a48a:	18 a3       	lds	r17, 0x58
    a48c:	8d a0       	lds	r24, 0x8d
    a48e:	9e a0       	lds	r25, 0x8e
    a490:	af a0       	lds	r26, 0x8f
    a492:	b8 a4       	lds	r27, 0xa8
    a494:	b7 fe       	sbrs	r11, 7
    a496:	67 c0       	rjmp	.+206    	; 0xa566 <__divdi3+0x108>
    a498:	21 95       	neg	r18
    a49a:	b1 e0       	ldi	r27, 0x01	; 1
    a49c:	12 16       	cp	r1, r18
    a49e:	08 f0       	brcs	.+2      	; 0xa4a2 <__divdi3+0x44>
    a4a0:	b0 e0       	ldi	r27, 0x00	; 0
    a4a2:	31 95       	neg	r19
    a4a4:	a1 e0       	ldi	r26, 0x01	; 1
    a4a6:	13 16       	cp	r1, r19
    a4a8:	08 f0       	brcs	.+2      	; 0xa4ac <__divdi3+0x4e>
    a4aa:	a0 e0       	ldi	r26, 0x00	; 0
    a4ac:	b3 2e       	mov	r11, r19
    a4ae:	bb 1a       	sub	r11, r27
    a4b0:	bb 2d       	mov	r27, r11
    a4b2:	88 24       	eor	r8, r8
    a4b4:	83 94       	inc	r8
    a4b6:	3b 15       	cp	r19, r11
    a4b8:	08 f0       	brcs	.+2      	; 0xa4bc <__divdi3+0x5e>
    a4ba:	88 24       	eor	r8, r8
    a4bc:	a8 29       	or	r26, r8
    a4be:	41 95       	neg	r20
    a4c0:	31 e0       	ldi	r19, 0x01	; 1
    a4c2:	14 16       	cp	r1, r20
    a4c4:	08 f0       	brcs	.+2      	; 0xa4c8 <__divdi3+0x6a>
    a4c6:	30 e0       	ldi	r19, 0x00	; 0
    a4c8:	b4 2e       	mov	r11, r20
    a4ca:	ba 1a       	sub	r11, r26
    a4cc:	ab 2d       	mov	r26, r11
    a4ce:	88 24       	eor	r8, r8
    a4d0:	83 94       	inc	r8
    a4d2:	4b 15       	cp	r20, r11
    a4d4:	08 f0       	brcs	.+2      	; 0xa4d8 <__divdi3+0x7a>
    a4d6:	88 24       	eor	r8, r8
    a4d8:	38 29       	or	r19, r8
    a4da:	51 95       	neg	r21
    a4dc:	41 e0       	ldi	r20, 0x01	; 1
    a4de:	15 16       	cp	r1, r21
    a4e0:	08 f0       	brcs	.+2      	; 0xa4e4 <__divdi3+0x86>
    a4e2:	40 e0       	ldi	r20, 0x00	; 0
    a4e4:	45 2e       	mov	r4, r21
    a4e6:	43 1a       	sub	r4, r19
    a4e8:	31 e0       	ldi	r19, 0x01	; 1
    a4ea:	54 15       	cp	r21, r4
    a4ec:	08 f0       	brcs	.+2      	; 0xa4f0 <__divdi3+0x92>
    a4ee:	30 e0       	ldi	r19, 0x00	; 0
    a4f0:	43 2b       	or	r20, r19
    a4f2:	61 95       	neg	r22
    a4f4:	31 e0       	ldi	r19, 0x01	; 1
    a4f6:	16 16       	cp	r1, r22
    a4f8:	08 f0       	brcs	.+2      	; 0xa4fc <__divdi3+0x9e>
    a4fa:	30 e0       	ldi	r19, 0x00	; 0
    a4fc:	86 2e       	mov	r8, r22
    a4fe:	84 1a       	sub	r8, r20
    a500:	41 e0       	ldi	r20, 0x01	; 1
    a502:	68 15       	cp	r22, r8
    a504:	08 f0       	brcs	.+2      	; 0xa508 <__divdi3+0xaa>
    a506:	40 e0       	ldi	r20, 0x00	; 0
    a508:	34 2b       	or	r19, r20
    a50a:	71 95       	neg	r23
    a50c:	41 e0       	ldi	r20, 0x01	; 1
    a50e:	17 16       	cp	r1, r23
    a510:	08 f0       	brcs	.+2      	; 0xa514 <__divdi3+0xb6>
    a512:	40 e0       	ldi	r20, 0x00	; 0
    a514:	57 2f       	mov	r21, r23
    a516:	53 1b       	sub	r21, r19
    a518:	31 e0       	ldi	r19, 0x01	; 1
    a51a:	75 17       	cp	r23, r21
    a51c:	08 f0       	brcs	.+2      	; 0xa520 <__divdi3+0xc2>
    a51e:	30 e0       	ldi	r19, 0x00	; 0
    a520:	43 2b       	or	r20, r19
    a522:	81 95       	neg	r24
    a524:	31 e0       	ldi	r19, 0x01	; 1
    a526:	18 16       	cp	r1, r24
    a528:	08 f0       	brcs	.+2      	; 0xa52c <__divdi3+0xce>
    a52a:	30 e0       	ldi	r19, 0x00	; 0
    a52c:	68 2f       	mov	r22, r24
    a52e:	64 1b       	sub	r22, r20
    a530:	46 2f       	mov	r20, r22
    a532:	61 e0       	ldi	r22, 0x01	; 1
    a534:	84 17       	cp	r24, r20
    a536:	08 f0       	brcs	.+2      	; 0xa53a <__divdi3+0xdc>
    a538:	60 e0       	ldi	r22, 0x00	; 0
    a53a:	36 2b       	or	r19, r22
    a53c:	91 95       	neg	r25
    a53e:	93 1b       	sub	r25, r19
    a540:	29 a3       	lds	r18, 0x59
    a542:	ba a3       	lds	r27, 0x5a
    a544:	ab a3       	lds	r26, 0x5b
    a546:	4c a2       	lds	r20, 0x9c
    a548:	8d a2       	lds	r24, 0x9d
    a54a:	5e a3       	lds	r21, 0x5e
    a54c:	4f a3       	lds	r20, 0x5f
    a54e:	98 a7       	lds	r25, 0x78
    a550:	8f ef       	ldi	r24, 0xFF	; 255
    a552:	9f ef       	ldi	r25, 0xFF	; 255
    a554:	af ef       	ldi	r26, 0xFF	; 255
    a556:	bf ef       	ldi	r27, 0xFF	; 255
    a558:	25 96       	adiw	r28, 0x05	; 5
    a55a:	8c af       	sts	0x7c, r24
    a55c:	9d af       	sts	0x7d, r25
    a55e:	ae af       	sts	0x7e, r26
    a560:	bf af       	sts	0x7f, r27
    a562:	25 97       	sbiw	r28, 0x05	; 5
    a564:	06 c0       	rjmp	.+12     	; 0xa572 <__divdi3+0x114>
    a566:	25 96       	adiw	r28, 0x05	; 5
    a568:	1c ae       	sts	0xbc, r17
    a56a:	1d ae       	sts	0xbd, r17
    a56c:	1e ae       	sts	0xbe, r17
    a56e:	1f ae       	sts	0xbf, r17
    a570:	25 97       	sbiw	r28, 0x05	; 5
    a572:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a574:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a576:	af 8d       	ldd	r26, Y+31	; 0x1f
    a578:	b8 a1       	lds	r27, 0x48
    a57a:	b7 ff       	sbrs	r27, 7
    a57c:	68 c0       	rjmp	.+208    	; 0xa64e <__divdi3+0x1f0>
    a57e:	25 96       	adiw	r28, 0x05	; 5
    a580:	2c ad       	sts	0x6c, r18
    a582:	3d ad       	sts	0x6d, r19
    a584:	4e ad       	sts	0x6e, r20
    a586:	5f ad       	sts	0x6f, r21
    a588:	25 97       	sbiw	r28, 0x05	; 5
    a58a:	20 95       	com	r18
    a58c:	30 95       	com	r19
    a58e:	40 95       	com	r20
    a590:	50 95       	com	r21
    a592:	25 96       	adiw	r28, 0x05	; 5
    a594:	2c af       	sts	0x7c, r18
    a596:	3d af       	sts	0x7d, r19
    a598:	4e af       	sts	0x7e, r20
    a59a:	5f af       	sts	0x7f, r21
    a59c:	25 97       	sbiw	r28, 0x05	; 5
    a59e:	e1 95       	neg	r30
    a5a0:	81 e0       	ldi	r24, 0x01	; 1
    a5a2:	1e 16       	cp	r1, r30
    a5a4:	08 f0       	brcs	.+2      	; 0xa5a8 <__divdi3+0x14a>
    a5a6:	80 e0       	ldi	r24, 0x00	; 0
    a5a8:	f1 95       	neg	r31
    a5aa:	91 e0       	ldi	r25, 0x01	; 1
    a5ac:	1f 16       	cp	r1, r31
    a5ae:	08 f0       	brcs	.+2      	; 0xa5b2 <__divdi3+0x154>
    a5b0:	90 e0       	ldi	r25, 0x00	; 0
    a5b2:	4f 2f       	mov	r20, r31
    a5b4:	48 1b       	sub	r20, r24
    a5b6:	81 e0       	ldi	r24, 0x01	; 1
    a5b8:	f4 17       	cp	r31, r20
    a5ba:	08 f0       	brcs	.+2      	; 0xa5be <__divdi3+0x160>
    a5bc:	80 e0       	ldi	r24, 0x00	; 0
    a5be:	98 2b       	or	r25, r24
    a5c0:	c1 94       	neg	r12
    a5c2:	81 e0       	ldi	r24, 0x01	; 1
    a5c4:	1c 14       	cp	r1, r12
    a5c6:	08 f0       	brcs	.+2      	; 0xa5ca <__divdi3+0x16c>
    a5c8:	80 e0       	ldi	r24, 0x00	; 0
    a5ca:	6c 2d       	mov	r22, r12
    a5cc:	69 1b       	sub	r22, r25
    a5ce:	91 e0       	ldi	r25, 0x01	; 1
    a5d0:	c6 16       	cp	r12, r22
    a5d2:	08 f0       	brcs	.+2      	; 0xa5d6 <__divdi3+0x178>
    a5d4:	90 e0       	ldi	r25, 0x00	; 0
    a5d6:	89 2b       	or	r24, r25
    a5d8:	d1 94       	neg	r13
    a5da:	91 e0       	ldi	r25, 0x01	; 1
    a5dc:	1d 14       	cp	r1, r13
    a5de:	08 f0       	brcs	.+2      	; 0xa5e2 <__divdi3+0x184>
    a5e0:	90 e0       	ldi	r25, 0x00	; 0
    a5e2:	5d 2d       	mov	r21, r13
    a5e4:	58 1b       	sub	r21, r24
    a5e6:	81 e0       	ldi	r24, 0x01	; 1
    a5e8:	d5 16       	cp	r13, r21
    a5ea:	08 f0       	brcs	.+2      	; 0xa5ee <__divdi3+0x190>
    a5ec:	80 e0       	ldi	r24, 0x00	; 0
    a5ee:	98 2b       	or	r25, r24
    a5f0:	e1 94       	neg	r14
    a5f2:	81 e0       	ldi	r24, 0x01	; 1
    a5f4:	1e 14       	cp	r1, r14
    a5f6:	08 f0       	brcs	.+2      	; 0xa5fa <__divdi3+0x19c>
    a5f8:	80 e0       	ldi	r24, 0x00	; 0
    a5fa:	3e 2d       	mov	r19, r14
    a5fc:	39 1b       	sub	r19, r25
    a5fe:	91 e0       	ldi	r25, 0x01	; 1
    a600:	e3 16       	cp	r14, r19
    a602:	08 f0       	brcs	.+2      	; 0xa606 <__divdi3+0x1a8>
    a604:	90 e0       	ldi	r25, 0x00	; 0
    a606:	89 2b       	or	r24, r25
    a608:	f1 94       	neg	r15
    a60a:	91 e0       	ldi	r25, 0x01	; 1
    a60c:	1f 14       	cp	r1, r15
    a60e:	08 f0       	brcs	.+2      	; 0xa612 <__divdi3+0x1b4>
    a610:	90 e0       	ldi	r25, 0x00	; 0
    a612:	2f 2d       	mov	r18, r15
    a614:	28 1b       	sub	r18, r24
    a616:	81 e0       	ldi	r24, 0x01	; 1
    a618:	f2 16       	cp	r15, r18
    a61a:	08 f0       	brcs	.+2      	; 0xa61e <__divdi3+0x1c0>
    a61c:	80 e0       	ldi	r24, 0x00	; 0
    a61e:	98 2b       	or	r25, r24
    a620:	01 95       	neg	r16
    a622:	81 e0       	ldi	r24, 0x01	; 1
    a624:	10 16       	cp	r1, r16
    a626:	08 f0       	brcs	.+2      	; 0xa62a <__divdi3+0x1cc>
    a628:	80 e0       	ldi	r24, 0x00	; 0
    a62a:	70 2f       	mov	r23, r16
    a62c:	79 1b       	sub	r23, r25
    a62e:	97 2f       	mov	r25, r23
    a630:	71 e0       	ldi	r23, 0x01	; 1
    a632:	09 17       	cp	r16, r25
    a634:	08 f0       	brcs	.+2      	; 0xa638 <__divdi3+0x1da>
    a636:	70 e0       	ldi	r23, 0x00	; 0
    a638:	87 2b       	or	r24, r23
    a63a:	11 95       	neg	r17
    a63c:	18 1b       	sub	r17, r24
    a63e:	e9 8f       	std	Y+25, r30	; 0x19
    a640:	4a 8f       	std	Y+26, r20	; 0x1a
    a642:	6b 8f       	std	Y+27, r22	; 0x1b
    a644:	5c 8f       	std	Y+28, r21	; 0x1c
    a646:	3d 8f       	std	Y+29, r19	; 0x1d
    a648:	2e 8f       	std	Y+30, r18	; 0x1e
    a64a:	9f 8f       	std	Y+31, r25	; 0x1f
    a64c:	18 a3       	lds	r17, 0x58
    a64e:	79 8d       	ldd	r23, Y+25	; 0x19
    a650:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a652:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a654:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a656:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a658:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a65a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a65c:	88 a1       	lds	r24, 0x48
    a65e:	e9 a1       	lds	r30, 0x49
    a660:	e9 8b       	std	Y+17, r30	; 0x11
    a662:	ea a1       	lds	r30, 0x4a
    a664:	ea 8b       	std	Y+18, r30	; 0x12
    a666:	eb a1       	lds	r30, 0x4b
    a668:	eb 8b       	std	Y+19, r30	; 0x13
    a66a:	ec a1       	lds	r30, 0x4c
    a66c:	ec 8b       	std	Y+20, r30	; 0x14
    a66e:	ed a1       	lds	r30, 0x4d
    a670:	ed 8b       	std	Y+21, r30	; 0x15
    a672:	ee a1       	lds	r30, 0x4e
    a674:	ee 8b       	std	Y+22, r30	; 0x16
    a676:	ef a1       	lds	r30, 0x4f
    a678:	ef 8b       	std	Y+23, r30	; 0x17
    a67a:	e8 a5       	lds	r30, 0x68
    a67c:	e8 8f       	std	Y+24, r30	; 0x18
    a67e:	79 87       	std	Y+9, r23	; 0x09
    a680:	6a 87       	std	Y+10, r22	; 0x0a
    a682:	5b 87       	std	Y+11, r21	; 0x0b
    a684:	4c 87       	std	Y+12, r20	; 0x0c
    a686:	3d 87       	std	Y+13, r19	; 0x0d
    a688:	2e 87       	std	Y+14, r18	; 0x0e
    a68a:	9f 87       	std	Y+15, r25	; 0x0f
    a68c:	88 8b       	std	Y+16, r24	; 0x10
    a68e:	89 84       	ldd	r8, Y+9	; 0x09
    a690:	9a 84       	ldd	r9, Y+10	; 0x0a
    a692:	ab 84       	ldd	r10, Y+11	; 0x0b
    a694:	bc 84       	ldd	r11, Y+12	; 0x0c
    a696:	8d 85       	ldd	r24, Y+13	; 0x0d
    a698:	9e 85       	ldd	r25, Y+14	; 0x0e
    a69a:	af 85       	ldd	r26, Y+15	; 0x0f
    a69c:	b8 89       	ldd	r27, Y+16	; 0x10
    a69e:	e9 88       	ldd	r14, Y+17	; 0x11
    a6a0:	fa 88       	ldd	r15, Y+18	; 0x12
    a6a2:	0b 89       	ldd	r16, Y+19	; 0x13
    a6a4:	1c 89       	ldd	r17, Y+20	; 0x14
    a6a6:	ed aa       	sts	0x9d, r30
    a6a8:	fe aa       	sts	0x9e, r31
    a6aa:	0f ab       	sts	0x5f, r16
    a6ac:	18 af       	sts	0x78, r17
    a6ae:	cd 88       	ldd	r12, Y+21	; 0x15
    a6b0:	de 88       	ldd	r13, Y+22	; 0x16
    a6b2:	ef 88       	ldd	r14, Y+23	; 0x17
    a6b4:	f8 8c       	ldd	r15, Y+24	; 0x18
    a6b6:	00 97       	sbiw	r24, 0x00	; 0
    a6b8:	a1 05       	cpc	r26, r1
    a6ba:	b1 05       	cpc	r27, r1
    a6bc:	09 f0       	breq	.+2      	; 0xa6c0 <__divdi3+0x262>
    a6be:	bd c3       	rjmp	.+1914   	; 0xae3a <__divdi3+0x9dc>
    a6c0:	c8 14       	cp	r12, r8
    a6c2:	d9 04       	cpc	r13, r9
    a6c4:	ea 04       	cpc	r14, r10
    a6c6:	fb 04       	cpc	r15, r11
    a6c8:	08 f0       	brcs	.+2      	; 0xa6cc <__divdi3+0x26e>
    a6ca:	4d c1       	rjmp	.+666    	; 0xa966 <__divdi3+0x508>
    a6cc:	00 e0       	ldi	r16, 0x00	; 0
    a6ce:	80 16       	cp	r8, r16
    a6d0:	00 e0       	ldi	r16, 0x00	; 0
    a6d2:	90 06       	cpc	r9, r16
    a6d4:	01 e0       	ldi	r16, 0x01	; 1
    a6d6:	a0 06       	cpc	r10, r16
    a6d8:	00 e0       	ldi	r16, 0x00	; 0
    a6da:	b0 06       	cpc	r11, r16
    a6dc:	58 f4       	brcc	.+22     	; 0xa6f4 <__divdi3+0x296>
    a6de:	1f ef       	ldi	r17, 0xFF	; 255
    a6e0:	81 16       	cp	r8, r17
    a6e2:	91 04       	cpc	r9, r1
    a6e4:	a1 04       	cpc	r10, r1
    a6e6:	b1 04       	cpc	r11, r1
    a6e8:	09 f0       	breq	.+2      	; 0xa6ec <__divdi3+0x28e>
    a6ea:	90 f4       	brcc	.+36     	; 0xa710 <__divdi3+0x2b2>
    a6ec:	80 e0       	ldi	r24, 0x00	; 0
    a6ee:	90 e0       	ldi	r25, 0x00	; 0
    a6f0:	dc 01       	movw	r26, r24
    a6f2:	17 c0       	rjmp	.+46     	; 0xa722 <__divdi3+0x2c4>
    a6f4:	20 e0       	ldi	r18, 0x00	; 0
    a6f6:	82 16       	cp	r8, r18
    a6f8:	20 e0       	ldi	r18, 0x00	; 0
    a6fa:	92 06       	cpc	r9, r18
    a6fc:	20 e0       	ldi	r18, 0x00	; 0
    a6fe:	a2 06       	cpc	r10, r18
    a700:	21 e0       	ldi	r18, 0x01	; 1
    a702:	b2 06       	cpc	r11, r18
    a704:	50 f4       	brcc	.+20     	; 0xa71a <__divdi3+0x2bc>
    a706:	80 e1       	ldi	r24, 0x10	; 16
    a708:	90 e0       	ldi	r25, 0x00	; 0
    a70a:	a0 e0       	ldi	r26, 0x00	; 0
    a70c:	b0 e0       	ldi	r27, 0x00	; 0
    a70e:	09 c0       	rjmp	.+18     	; 0xa722 <__divdi3+0x2c4>
    a710:	88 e0       	ldi	r24, 0x08	; 8
    a712:	90 e0       	ldi	r25, 0x00	; 0
    a714:	a0 e0       	ldi	r26, 0x00	; 0
    a716:	b0 e0       	ldi	r27, 0x00	; 0
    a718:	04 c0       	rjmp	.+8      	; 0xa722 <__divdi3+0x2c4>
    a71a:	88 e1       	ldi	r24, 0x18	; 24
    a71c:	90 e0       	ldi	r25, 0x00	; 0
    a71e:	a0 e0       	ldi	r26, 0x00	; 0
    a720:	b0 e0       	ldi	r27, 0x00	; 0
    a722:	b5 01       	movw	r22, r10
    a724:	a4 01       	movw	r20, r8
    a726:	08 2e       	mov	r0, r24
    a728:	04 c0       	rjmp	.+8      	; 0xa732 <__divdi3+0x2d4>
    a72a:	76 95       	lsr	r23
    a72c:	67 95       	ror	r22
    a72e:	57 95       	ror	r21
    a730:	47 95       	ror	r20
    a732:	0a 94       	dec	r0
    a734:	d2 f7       	brpl	.-12     	; 0xa72a <__divdi3+0x2cc>
    a736:	fa 01       	movw	r30, r20
    a738:	ea 5d       	subi	r30, 0xDA	; 218
    a73a:	ff 4d       	sbci	r31, 0xDF	; 223
    a73c:	20 81       	ld	r18, Z
    a73e:	40 e2       	ldi	r20, 0x20	; 32
    a740:	50 e0       	ldi	r21, 0x00	; 0
    a742:	60 e0       	ldi	r22, 0x00	; 0
    a744:	70 e0       	ldi	r23, 0x00	; 0
    a746:	48 1b       	sub	r20, r24
    a748:	59 0b       	sbc	r21, r25
    a74a:	6a 0b       	sbc	r22, r26
    a74c:	7b 0b       	sbc	r23, r27
    a74e:	42 1b       	sub	r20, r18
    a750:	51 09       	sbc	r21, r1
    a752:	61 09       	sbc	r22, r1
    a754:	71 09       	sbc	r23, r1
    a756:	41 15       	cp	r20, r1
    a758:	51 05       	cpc	r21, r1
    a75a:	61 05       	cpc	r22, r1
    a75c:	71 05       	cpc	r23, r1
    a75e:	a1 f1       	breq	.+104    	; 0xa7c8 <__divdi3+0x36a>
    a760:	04 2e       	mov	r0, r20
    a762:	04 c0       	rjmp	.+8      	; 0xa76c <__divdi3+0x30e>
    a764:	88 0c       	add	r8, r8
    a766:	99 1c       	adc	r9, r9
    a768:	aa 1c       	adc	r10, r10
    a76a:	bb 1c       	adc	r11, r11
    a76c:	0a 94       	dec	r0
    a76e:	d2 f7       	brpl	.-12     	; 0xa764 <__divdi3+0x306>
    a770:	97 01       	movw	r18, r14
    a772:	86 01       	movw	r16, r12
    a774:	04 2e       	mov	r0, r20
    a776:	04 c0       	rjmp	.+8      	; 0xa780 <__divdi3+0x322>
    a778:	00 0f       	add	r16, r16
    a77a:	11 1f       	adc	r17, r17
    a77c:	22 1f       	adc	r18, r18
    a77e:	33 1f       	adc	r19, r19
    a780:	0a 94       	dec	r0
    a782:	d2 f7       	brpl	.-12     	; 0xa778 <__divdi3+0x31a>
    a784:	80 e2       	ldi	r24, 0x20	; 32
    a786:	90 e0       	ldi	r25, 0x00	; 0
    a788:	84 1b       	sub	r24, r20
    a78a:	95 0b       	sbc	r25, r21
    a78c:	cd a8       	sts	0x8d, r28
    a78e:	de a8       	sts	0x8e, r29
    a790:	ef a8       	sts	0x8f, r30
    a792:	f8 ac       	sts	0xa8, r31
    a794:	04 c0       	rjmp	.+8      	; 0xa79e <__divdi3+0x340>
    a796:	f6 94       	lsr	r15
    a798:	e7 94       	ror	r14
    a79a:	d7 94       	ror	r13
    a79c:	c7 94       	ror	r12
    a79e:	8a 95       	dec	r24
    a7a0:	d2 f7       	brpl	.-12     	; 0xa796 <__divdi3+0x338>
    a7a2:	c0 2a       	or	r12, r16
    a7a4:	d1 2a       	or	r13, r17
    a7a6:	e2 2a       	or	r14, r18
    a7a8:	f3 2a       	or	r15, r19
    a7aa:	0d a9       	sts	0x4d, r16
    a7ac:	1e a9       	sts	0x4e, r17
    a7ae:	2f a9       	sts	0x4f, r18
    a7b0:	38 ad       	sts	0x68, r19
    a7b2:	04 c0       	rjmp	.+8      	; 0xa7bc <__divdi3+0x35e>
    a7b4:	00 0f       	add	r16, r16
    a7b6:	11 1f       	adc	r17, r17
    a7b8:	22 1f       	adc	r18, r18
    a7ba:	33 1f       	adc	r19, r19
    a7bc:	4a 95       	dec	r20
    a7be:	d2 f7       	brpl	.-12     	; 0xa7b4 <__divdi3+0x356>
    a7c0:	0d ab       	sts	0x5d, r16
    a7c2:	1e ab       	sts	0x5e, r17
    a7c4:	2f ab       	sts	0x5f, r18
    a7c6:	38 af       	sts	0x78, r19
    a7c8:	25 01       	movw	r4, r10
    a7ca:	66 24       	eor	r6, r6
    a7cc:	77 24       	eor	r7, r7
    a7ce:	95 01       	movw	r18, r10
    a7d0:	84 01       	movw	r16, r8
    a7d2:	20 70       	andi	r18, 0x00	; 0
    a7d4:	30 70       	andi	r19, 0x00	; 0
    a7d6:	09 ab       	sts	0x59, r16
    a7d8:	1a ab       	sts	0x5a, r17
    a7da:	2b ab       	sts	0x5b, r18
    a7dc:	3c ab       	sts	0x5c, r19
    a7de:	c7 01       	movw	r24, r14
    a7e0:	b6 01       	movw	r22, r12
    a7e2:	a3 01       	movw	r20, r6
    a7e4:	92 01       	movw	r18, r4
    a7e6:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    a7ea:	2d a7       	lds	r18, 0x7d
    a7ec:	3e a7       	lds	r19, 0x7e
    a7ee:	4f a7       	lds	r20, 0x7f
    a7f0:	58 ab       	sts	0x58, r21
    a7f2:	69 a7       	lds	r22, 0x79
    a7f4:	7a a7       	lds	r23, 0x7a
    a7f6:	8b a7       	lds	r24, 0x7b
    a7f8:	9c a7       	lds	r25, 0x7c
    a7fa:	c7 01       	movw	r24, r14
    a7fc:	b6 01       	movw	r22, r12
    a7fe:	a3 01       	movw	r20, r6
    a800:	92 01       	movw	r18, r4
    a802:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    a806:	ca 01       	movw	r24, r20
    a808:	b9 01       	movw	r22, r18
    a80a:	29 a9       	sts	0x49, r18
    a80c:	3a a9       	sts	0x4a, r19
    a80e:	4b a9       	sts	0x4b, r20
    a810:	5c a9       	sts	0x4c, r21
    a812:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a816:	ab 01       	movw	r20, r22
    a818:	bc 01       	movw	r22, r24
    a81a:	09 a5       	lds	r16, 0x69
    a81c:	1a a5       	lds	r17, 0x6a
    a81e:	2b a5       	lds	r18, 0x6b
    a820:	3c a5       	lds	r19, 0x6c
    a822:	78 01       	movw	r14, r16
    a824:	dd 24       	eor	r13, r13
    a826:	cc 24       	eor	r12, r12
    a828:	0d a9       	sts	0x4d, r16
    a82a:	1e a9       	sts	0x4e, r17
    a82c:	2f a9       	sts	0x4f, r18
    a82e:	38 ad       	sts	0x68, r19
    a830:	c9 01       	movw	r24, r18
    a832:	aa 27       	eor	r26, r26
    a834:	bb 27       	eor	r27, r27
    a836:	c8 2a       	or	r12, r24
    a838:	d9 2a       	or	r13, r25
    a83a:	ea 2a       	or	r14, r26
    a83c:	fb 2a       	or	r15, r27
    a83e:	0d a5       	lds	r16, 0x6d
    a840:	1e a5       	lds	r17, 0x6e
    a842:	2f a5       	lds	r18, 0x6f
    a844:	38 a9       	sts	0x48, r19
    a846:	c4 16       	cp	r12, r20
    a848:	d5 06       	cpc	r13, r21
    a84a:	e6 06       	cpc	r14, r22
    a84c:	f7 06       	cpc	r15, r23
    a84e:	38 f5       	brcc	.+78     	; 0xa89e <__divdi3+0x440>
    a850:	01 50       	subi	r16, 0x01	; 1
    a852:	10 40       	sbci	r17, 0x00	; 0
    a854:	20 40       	sbci	r18, 0x00	; 0
    a856:	30 40       	sbci	r19, 0x00	; 0
    a858:	09 a7       	lds	r16, 0x79
    a85a:	1a a7       	lds	r17, 0x7a
    a85c:	2b a7       	lds	r18, 0x7b
    a85e:	3c a7       	lds	r19, 0x7c
    a860:	c8 0c       	add	r12, r8
    a862:	d9 1c       	adc	r13, r9
    a864:	ea 1c       	adc	r14, r10
    a866:	fb 1c       	adc	r15, r11
    a868:	c8 14       	cp	r12, r8
    a86a:	d9 04       	cpc	r13, r9
    a86c:	ea 04       	cpc	r14, r10
    a86e:	fb 04       	cpc	r15, r11
    a870:	d0 f0       	brcs	.+52     	; 0xa8a6 <__divdi3+0x448>
    a872:	c4 16       	cp	r12, r20
    a874:	d5 06       	cpc	r13, r21
    a876:	e6 06       	cpc	r14, r22
    a878:	f7 06       	cpc	r15, r23
    a87a:	a8 f4       	brcc	.+42     	; 0xa8a6 <__divdi3+0x448>
    a87c:	0d a5       	lds	r16, 0x6d
    a87e:	1e a5       	lds	r17, 0x6e
    a880:	2f a5       	lds	r18, 0x6f
    a882:	38 a9       	sts	0x48, r19
    a884:	02 50       	subi	r16, 0x02	; 2
    a886:	10 40       	sbci	r17, 0x00	; 0
    a888:	20 40       	sbci	r18, 0x00	; 0
    a88a:	30 40       	sbci	r19, 0x00	; 0
    a88c:	09 a7       	lds	r16, 0x79
    a88e:	1a a7       	lds	r17, 0x7a
    a890:	2b a7       	lds	r18, 0x7b
    a892:	3c a7       	lds	r19, 0x7c
    a894:	c8 0c       	add	r12, r8
    a896:	d9 1c       	adc	r13, r9
    a898:	ea 1c       	adc	r14, r10
    a89a:	fb 1c       	adc	r15, r11
    a89c:	04 c0       	rjmp	.+8      	; 0xa8a6 <__divdi3+0x448>
    a89e:	09 a7       	lds	r16, 0x79
    a8a0:	1a a7       	lds	r17, 0x7a
    a8a2:	2b a7       	lds	r18, 0x7b
    a8a4:	3c a7       	lds	r19, 0x7c
    a8a6:	c4 1a       	sub	r12, r20
    a8a8:	d5 0a       	sbc	r13, r21
    a8aa:	e6 0a       	sbc	r14, r22
    a8ac:	f7 0a       	sbc	r15, r23
    a8ae:	c7 01       	movw	r24, r14
    a8b0:	b6 01       	movw	r22, r12
    a8b2:	a3 01       	movw	r20, r6
    a8b4:	92 01       	movw	r18, r4
    a8b6:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    a8ba:	2d a7       	lds	r18, 0x7d
    a8bc:	3e a7       	lds	r19, 0x7e
    a8be:	4f a7       	lds	r20, 0x7f
    a8c0:	58 ab       	sts	0x58, r21
    a8c2:	69 af       	sts	0x79, r22
    a8c4:	7a af       	sts	0x7a, r23
    a8c6:	8b af       	sts	0x7b, r24
    a8c8:	9c af       	sts	0x7c, r25
    a8ca:	c7 01       	movw	r24, r14
    a8cc:	b6 01       	movw	r22, r12
    a8ce:	a3 01       	movw	r20, r6
    a8d0:	92 01       	movw	r18, r4
    a8d2:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    a8d6:	ca 01       	movw	r24, r20
    a8d8:	b9 01       	movw	r22, r18
    a8da:	29 a9       	sts	0x49, r18
    a8dc:	3a a9       	sts	0x4a, r19
    a8de:	4b a9       	sts	0x4b, r20
    a8e0:	5c a9       	sts	0x4c, r21
    a8e2:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    a8e6:	6b 01       	movw	r12, r22
    a8e8:	7c 01       	movw	r14, r24
    a8ea:	49 ad       	sts	0x69, r20
    a8ec:	5a ad       	sts	0x6a, r21
    a8ee:	6b ad       	sts	0x6b, r22
    a8f0:	7c ad       	sts	0x6c, r23
    a8f2:	9a 01       	movw	r18, r20
    a8f4:	11 27       	eor	r17, r17
    a8f6:	00 27       	eor	r16, r16
    a8f8:	4d a9       	sts	0x4d, r20
    a8fa:	5e a9       	sts	0x4e, r21
    a8fc:	6f a9       	sts	0x4f, r22
    a8fe:	78 ad       	sts	0x68, r23
    a900:	60 70       	andi	r22, 0x00	; 0
    a902:	70 70       	andi	r23, 0x00	; 0
    a904:	04 2b       	or	r16, r20
    a906:	15 2b       	or	r17, r21
    a908:	26 2b       	or	r18, r22
    a90a:	37 2b       	or	r19, r23
    a90c:	8d a5       	lds	r24, 0x6d
    a90e:	9e a5       	lds	r25, 0x6e
    a910:	af a5       	lds	r26, 0x6f
    a912:	b8 a9       	sts	0x48, r27
    a914:	0c 15       	cp	r16, r12
    a916:	1d 05       	cpc	r17, r13
    a918:	2e 05       	cpc	r18, r14
    a91a:	3f 05       	cpc	r19, r15
    a91c:	c0 f4       	brcc	.+48     	; 0xa94e <__divdi3+0x4f0>
    a91e:	01 97       	sbiw	r24, 0x01	; 1
    a920:	a1 09       	sbc	r26, r1
    a922:	b1 09       	sbc	r27, r1
    a924:	08 0d       	add	r16, r8
    a926:	19 1d       	adc	r17, r9
    a928:	2a 1d       	adc	r18, r10
    a92a:	3b 1d       	adc	r19, r11
    a92c:	08 15       	cp	r16, r8
    a92e:	19 05       	cpc	r17, r9
    a930:	2a 05       	cpc	r18, r10
    a932:	3b 05       	cpc	r19, r11
    a934:	60 f0       	brcs	.+24     	; 0xa94e <__divdi3+0x4f0>
    a936:	0c 15       	cp	r16, r12
    a938:	1d 05       	cpc	r17, r13
    a93a:	2e 05       	cpc	r18, r14
    a93c:	3f 05       	cpc	r19, r15
    a93e:	38 f4       	brcc	.+14     	; 0xa94e <__divdi3+0x4f0>
    a940:	8d a5       	lds	r24, 0x6d
    a942:	9e a5       	lds	r25, 0x6e
    a944:	af a5       	lds	r26, 0x6f
    a946:	b8 a9       	sts	0x48, r27
    a948:	02 97       	sbiw	r24, 0x02	; 2
    a94a:	a1 09       	sbc	r26, r1
    a94c:	b1 09       	sbc	r27, r1
    a94e:	09 a5       	lds	r16, 0x69
    a950:	1a a5       	lds	r17, 0x6a
    a952:	2b a5       	lds	r18, 0x6b
    a954:	3c a5       	lds	r19, 0x6c
    a956:	78 01       	movw	r14, r16
    a958:	dd 24       	eor	r13, r13
    a95a:	cc 24       	eor	r12, r12
    a95c:	c8 2a       	or	r12, r24
    a95e:	d9 2a       	or	r13, r25
    a960:	ea 2a       	or	r14, r26
    a962:	fb 2a       	or	r15, r27
    a964:	b7 c4       	rjmp	.+2414   	; 0xb2d4 <__divdi3+0xe76>
    a966:	81 14       	cp	r8, r1
    a968:	91 04       	cpc	r9, r1
    a96a:	a1 04       	cpc	r10, r1
    a96c:	b1 04       	cpc	r11, r1
    a96e:	51 f4       	brne	.+20     	; 0xa984 <__divdi3+0x526>
    a970:	61 e0       	ldi	r22, 0x01	; 1
    a972:	70 e0       	ldi	r23, 0x00	; 0
    a974:	80 e0       	ldi	r24, 0x00	; 0
    a976:	90 e0       	ldi	r25, 0x00	; 0
    a978:	a5 01       	movw	r20, r10
    a97a:	94 01       	movw	r18, r8
    a97c:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    a980:	49 01       	movw	r8, r18
    a982:	5a 01       	movw	r10, r20
    a984:	10 e0       	ldi	r17, 0x00	; 0
    a986:	81 16       	cp	r8, r17
    a988:	10 e0       	ldi	r17, 0x00	; 0
    a98a:	91 06       	cpc	r9, r17
    a98c:	11 e0       	ldi	r17, 0x01	; 1
    a98e:	a1 06       	cpc	r10, r17
    a990:	10 e0       	ldi	r17, 0x00	; 0
    a992:	b1 06       	cpc	r11, r17
    a994:	58 f4       	brcc	.+22     	; 0xa9ac <__divdi3+0x54e>
    a996:	2f ef       	ldi	r18, 0xFF	; 255
    a998:	82 16       	cp	r8, r18
    a99a:	91 04       	cpc	r9, r1
    a99c:	a1 04       	cpc	r10, r1
    a99e:	b1 04       	cpc	r11, r1
    a9a0:	09 f0       	breq	.+2      	; 0xa9a4 <__divdi3+0x546>
    a9a2:	90 f4       	brcc	.+36     	; 0xa9c8 <__divdi3+0x56a>
    a9a4:	80 e0       	ldi	r24, 0x00	; 0
    a9a6:	90 e0       	ldi	r25, 0x00	; 0
    a9a8:	dc 01       	movw	r26, r24
    a9aa:	17 c0       	rjmp	.+46     	; 0xa9da <__divdi3+0x57c>
    a9ac:	30 e0       	ldi	r19, 0x00	; 0
    a9ae:	83 16       	cp	r8, r19
    a9b0:	30 e0       	ldi	r19, 0x00	; 0
    a9b2:	93 06       	cpc	r9, r19
    a9b4:	30 e0       	ldi	r19, 0x00	; 0
    a9b6:	a3 06       	cpc	r10, r19
    a9b8:	31 e0       	ldi	r19, 0x01	; 1
    a9ba:	b3 06       	cpc	r11, r19
    a9bc:	50 f4       	brcc	.+20     	; 0xa9d2 <__divdi3+0x574>
    a9be:	80 e1       	ldi	r24, 0x10	; 16
    a9c0:	90 e0       	ldi	r25, 0x00	; 0
    a9c2:	a0 e0       	ldi	r26, 0x00	; 0
    a9c4:	b0 e0       	ldi	r27, 0x00	; 0
    a9c6:	09 c0       	rjmp	.+18     	; 0xa9da <__divdi3+0x57c>
    a9c8:	88 e0       	ldi	r24, 0x08	; 8
    a9ca:	90 e0       	ldi	r25, 0x00	; 0
    a9cc:	a0 e0       	ldi	r26, 0x00	; 0
    a9ce:	b0 e0       	ldi	r27, 0x00	; 0
    a9d0:	04 c0       	rjmp	.+8      	; 0xa9da <__divdi3+0x57c>
    a9d2:	88 e1       	ldi	r24, 0x18	; 24
    a9d4:	90 e0       	ldi	r25, 0x00	; 0
    a9d6:	a0 e0       	ldi	r26, 0x00	; 0
    a9d8:	b0 e0       	ldi	r27, 0x00	; 0
    a9da:	b5 01       	movw	r22, r10
    a9dc:	a4 01       	movw	r20, r8
    a9de:	08 2e       	mov	r0, r24
    a9e0:	04 c0       	rjmp	.+8      	; 0xa9ea <__divdi3+0x58c>
    a9e2:	76 95       	lsr	r23
    a9e4:	67 95       	ror	r22
    a9e6:	57 95       	ror	r21
    a9e8:	47 95       	ror	r20
    a9ea:	0a 94       	dec	r0
    a9ec:	d2 f7       	brpl	.-12     	; 0xa9e2 <__divdi3+0x584>
    a9ee:	fa 01       	movw	r30, r20
    a9f0:	ea 5d       	subi	r30, 0xDA	; 218
    a9f2:	ff 4d       	sbci	r31, 0xDF	; 223
    a9f4:	20 81       	ld	r18, Z
    a9f6:	ac 01       	movw	r20, r24
    a9f8:	bd 01       	movw	r22, r26
    a9fa:	42 0f       	add	r20, r18
    a9fc:	51 1d       	adc	r21, r1
    a9fe:	61 1d       	adc	r22, r1
    aa00:	71 1d       	adc	r23, r1
    aa02:	80 e2       	ldi	r24, 0x20	; 32
    aa04:	90 e0       	ldi	r25, 0x00	; 0
    aa06:	a0 e0       	ldi	r26, 0x00	; 0
    aa08:	b0 e0       	ldi	r27, 0x00	; 0
    aa0a:	84 1b       	sub	r24, r20
    aa0c:	95 0b       	sbc	r25, r21
    aa0e:	a6 0b       	sbc	r26, r22
    aa10:	b7 0b       	sbc	r27, r23
    aa12:	51 f4       	brne	.+20     	; 0xaa28 <__divdi3+0x5ca>
    aa14:	c8 18       	sub	r12, r8
    aa16:	d9 08       	sbc	r13, r9
    aa18:	ea 08       	sbc	r14, r10
    aa1a:	fb 08       	sbc	r15, r11
    aa1c:	f1 e0       	ldi	r31, 0x01	; 1
    aa1e:	4f 2e       	mov	r4, r31
    aa20:	51 2c       	mov	r5, r1
    aa22:	61 2c       	mov	r6, r1
    aa24:	71 2c       	mov	r7, r1
    aa26:	28 c1       	rjmp	.+592    	; 0xac78 <__divdi3+0x81a>
    aa28:	08 2e       	mov	r0, r24
    aa2a:	04 c0       	rjmp	.+8      	; 0xaa34 <__divdi3+0x5d6>
    aa2c:	88 0c       	add	r8, r8
    aa2e:	99 1c       	adc	r9, r9
    aa30:	aa 1c       	adc	r10, r10
    aa32:	bb 1c       	adc	r11, r11
    aa34:	0a 94       	dec	r0
    aa36:	d2 f7       	brpl	.-12     	; 0xaa2c <__divdi3+0x5ce>
    aa38:	97 01       	movw	r18, r14
    aa3a:	86 01       	movw	r16, r12
    aa3c:	04 2e       	mov	r0, r20
    aa3e:	04 c0       	rjmp	.+8      	; 0xaa48 <__divdi3+0x5ea>
    aa40:	36 95       	lsr	r19
    aa42:	27 95       	ror	r18
    aa44:	17 95       	ror	r17
    aa46:	07 95       	ror	r16
    aa48:	0a 94       	dec	r0
    aa4a:	d2 f7       	brpl	.-12     	; 0xaa40 <__divdi3+0x5e2>
    aa4c:	09 ab       	sts	0x59, r16
    aa4e:	1a ab       	sts	0x5a, r17
    aa50:	2b ab       	sts	0x5b, r18
    aa52:	3c ab       	sts	0x5c, r19
    aa54:	97 01       	movw	r18, r14
    aa56:	86 01       	movw	r16, r12
    aa58:	08 2e       	mov	r0, r24
    aa5a:	04 c0       	rjmp	.+8      	; 0xaa64 <__divdi3+0x606>
    aa5c:	00 0f       	add	r16, r16
    aa5e:	11 1f       	adc	r17, r17
    aa60:	22 1f       	adc	r18, r18
    aa62:	33 1f       	adc	r19, r19
    aa64:	0a 94       	dec	r0
    aa66:	d2 f7       	brpl	.-12     	; 0xaa5c <__divdi3+0x5fe>
    aa68:	0d a7       	lds	r16, 0x7d
    aa6a:	1e a7       	lds	r17, 0x7e
    aa6c:	2f a7       	lds	r18, 0x7f
    aa6e:	38 ab       	sts	0x58, r19
    aa70:	ed a8       	sts	0x8d, r30
    aa72:	fe a8       	sts	0x8e, r31
    aa74:	0f a9       	sts	0x4f, r16
    aa76:	18 ad       	sts	0x68, r17
    aa78:	04 c0       	rjmp	.+8      	; 0xaa82 <__divdi3+0x624>
    aa7a:	16 95       	lsr	r17
    aa7c:	07 95       	ror	r16
    aa7e:	f7 94       	ror	r15
    aa80:	e7 94       	ror	r14
    aa82:	4a 95       	dec	r20
    aa84:	d2 f7       	brpl	.-12     	; 0xaa7a <__divdi3+0x61c>
    aa86:	b8 01       	movw	r22, r16
    aa88:	a7 01       	movw	r20, r14
    aa8a:	0d a5       	lds	r16, 0x6d
    aa8c:	1e a5       	lds	r17, 0x6e
    aa8e:	2f a5       	lds	r18, 0x6f
    aa90:	38 a9       	sts	0x48, r19
    aa92:	04 2b       	or	r16, r20
    aa94:	15 2b       	or	r17, r21
    aa96:	26 2b       	or	r18, r22
    aa98:	37 2b       	or	r19, r23
    aa9a:	0d a7       	lds	r16, 0x7d
    aa9c:	1e a7       	lds	r17, 0x7e
    aa9e:	2f a7       	lds	r18, 0x7f
    aaa0:	38 ab       	sts	0x58, r19
    aaa2:	ed a8       	sts	0x8d, r30
    aaa4:	fe a8       	sts	0x8e, r31
    aaa6:	0f a9       	sts	0x4f, r16
    aaa8:	18 ad       	sts	0x68, r17
    aaaa:	04 c0       	rjmp	.+8      	; 0xaab4 <__divdi3+0x656>
    aaac:	ee 0c       	add	r14, r14
    aaae:	ff 1c       	adc	r15, r15
    aab0:	00 1f       	adc	r16, r16
    aab2:	11 1f       	adc	r17, r17
    aab4:	8a 95       	dec	r24
    aab6:	d2 f7       	brpl	.-12     	; 0xaaac <__divdi3+0x64e>
    aab8:	ed aa       	sts	0x9d, r30
    aaba:	fe aa       	sts	0x9e, r31
    aabc:	0f ab       	sts	0x5f, r16
    aabe:	18 af       	sts	0x78, r17
    aac0:	25 01       	movw	r4, r10
    aac2:	66 24       	eor	r6, r6
    aac4:	77 24       	eor	r7, r7
    aac6:	95 01       	movw	r18, r10
    aac8:	84 01       	movw	r16, r8
    aaca:	20 70       	andi	r18, 0x00	; 0
    aacc:	30 70       	andi	r19, 0x00	; 0
    aace:	09 af       	sts	0x79, r16
    aad0:	1a af       	sts	0x7a, r17
    aad2:	2b af       	sts	0x7b, r18
    aad4:	3c af       	sts	0x7c, r19
    aad6:	69 a9       	sts	0x49, r22
    aad8:	7a a9       	sts	0x4a, r23
    aada:	8b a9       	sts	0x4b, r24
    aadc:	9c a9       	sts	0x4c, r25
    aade:	a3 01       	movw	r20, r6
    aae0:	92 01       	movw	r18, r4
    aae2:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    aae6:	29 a7       	lds	r18, 0x79
    aae8:	3a a7       	lds	r19, 0x7a
    aaea:	4b a7       	lds	r20, 0x7b
    aaec:	5c a7       	lds	r21, 0x7c
    aaee:	6b 01       	movw	r12, r22
    aaf0:	7c 01       	movw	r14, r24
    aaf2:	69 a9       	sts	0x49, r22
    aaf4:	7a a9       	sts	0x4a, r23
    aaf6:	8b a9       	sts	0x4b, r24
    aaf8:	9c a9       	sts	0x4c, r25
    aafa:	a3 01       	movw	r20, r6
    aafc:	92 01       	movw	r18, r4
    aafe:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    ab02:	ca 01       	movw	r24, r20
    ab04:	b9 01       	movw	r22, r18
    ab06:	29 ad       	sts	0x69, r18
    ab08:	3a ad       	sts	0x6a, r19
    ab0a:	4b ad       	sts	0x6b, r20
    ab0c:	5c ad       	sts	0x6c, r21
    ab0e:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    ab12:	ab 01       	movw	r20, r22
    ab14:	bc 01       	movw	r22, r24
    ab16:	76 01       	movw	r14, r12
    ab18:	dd 24       	eor	r13, r13
    ab1a:	cc 24       	eor	r12, r12
    ab1c:	0d a5       	lds	r16, 0x6d
    ab1e:	1e a5       	lds	r17, 0x6e
    ab20:	2f a5       	lds	r18, 0x6f
    ab22:	38 a9       	sts	0x48, r19
    ab24:	c9 01       	movw	r24, r18
    ab26:	aa 27       	eor	r26, r26
    ab28:	bb 27       	eor	r27, r27
    ab2a:	c8 2a       	or	r12, r24
    ab2c:	d9 2a       	or	r13, r25
    ab2e:	ea 2a       	or	r14, r26
    ab30:	fb 2a       	or	r15, r27
    ab32:	09 a5       	lds	r16, 0x69
    ab34:	1a a5       	lds	r17, 0x6a
    ab36:	2b a5       	lds	r18, 0x6b
    ab38:	3c a5       	lds	r19, 0x6c
    ab3a:	c4 16       	cp	r12, r20
    ab3c:	d5 06       	cpc	r13, r21
    ab3e:	e6 06       	cpc	r14, r22
    ab40:	f7 06       	cpc	r15, r23
    ab42:	38 f5       	brcc	.+78     	; 0xab92 <__divdi3+0x734>
    ab44:	01 50       	subi	r16, 0x01	; 1
    ab46:	10 40       	sbci	r17, 0x00	; 0
    ab48:	20 40       	sbci	r18, 0x00	; 0
    ab4a:	30 40       	sbci	r19, 0x00	; 0
    ab4c:	09 ab       	sts	0x59, r16
    ab4e:	1a ab       	sts	0x5a, r17
    ab50:	2b ab       	sts	0x5b, r18
    ab52:	3c ab       	sts	0x5c, r19
    ab54:	c8 0c       	add	r12, r8
    ab56:	d9 1c       	adc	r13, r9
    ab58:	ea 1c       	adc	r14, r10
    ab5a:	fb 1c       	adc	r15, r11
    ab5c:	c8 14       	cp	r12, r8
    ab5e:	d9 04       	cpc	r13, r9
    ab60:	ea 04       	cpc	r14, r10
    ab62:	fb 04       	cpc	r15, r11
    ab64:	d0 f0       	brcs	.+52     	; 0xab9a <__divdi3+0x73c>
    ab66:	c4 16       	cp	r12, r20
    ab68:	d5 06       	cpc	r13, r21
    ab6a:	e6 06       	cpc	r14, r22
    ab6c:	f7 06       	cpc	r15, r23
    ab6e:	a8 f4       	brcc	.+42     	; 0xab9a <__divdi3+0x73c>
    ab70:	09 a5       	lds	r16, 0x69
    ab72:	1a a5       	lds	r17, 0x6a
    ab74:	2b a5       	lds	r18, 0x6b
    ab76:	3c a5       	lds	r19, 0x6c
    ab78:	02 50       	subi	r16, 0x02	; 2
    ab7a:	10 40       	sbci	r17, 0x00	; 0
    ab7c:	20 40       	sbci	r18, 0x00	; 0
    ab7e:	30 40       	sbci	r19, 0x00	; 0
    ab80:	09 ab       	sts	0x59, r16
    ab82:	1a ab       	sts	0x5a, r17
    ab84:	2b ab       	sts	0x5b, r18
    ab86:	3c ab       	sts	0x5c, r19
    ab88:	c8 0c       	add	r12, r8
    ab8a:	d9 1c       	adc	r13, r9
    ab8c:	ea 1c       	adc	r14, r10
    ab8e:	fb 1c       	adc	r15, r11
    ab90:	04 c0       	rjmp	.+8      	; 0xab9a <__divdi3+0x73c>
    ab92:	09 ab       	sts	0x59, r16
    ab94:	1a ab       	sts	0x5a, r17
    ab96:	2b ab       	sts	0x5b, r18
    ab98:	3c ab       	sts	0x5c, r19
    ab9a:	c4 1a       	sub	r12, r20
    ab9c:	d5 0a       	sbc	r13, r21
    ab9e:	e6 0a       	sbc	r14, r22
    aba0:	f7 0a       	sbc	r15, r23
    aba2:	c7 01       	movw	r24, r14
    aba4:	b6 01       	movw	r22, r12
    aba6:	a3 01       	movw	r20, r6
    aba8:	92 01       	movw	r18, r4
    abaa:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    abae:	29 a7       	lds	r18, 0x79
    abb0:	3a a7       	lds	r19, 0x7a
    abb2:	4b a7       	lds	r20, 0x7b
    abb4:	5c a7       	lds	r21, 0x7c
    abb6:	21 96       	adiw	r28, 0x01	; 1
    abb8:	6c af       	sts	0x7c, r22
    abba:	7d af       	sts	0x7d, r23
    abbc:	8e af       	sts	0x7e, r24
    abbe:	9f af       	sts	0x7f, r25
    abc0:	21 97       	sbiw	r28, 0x01	; 1
    abc2:	c7 01       	movw	r24, r14
    abc4:	b6 01       	movw	r22, r12
    abc6:	a3 01       	movw	r20, r6
    abc8:	92 01       	movw	r18, r4
    abca:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    abce:	ca 01       	movw	r24, r20
    abd0:	b9 01       	movw	r22, r18
    abd2:	29 ad       	sts	0x69, r18
    abd4:	3a ad       	sts	0x6a, r19
    abd6:	4b ad       	sts	0x6b, r20
    abd8:	5c ad       	sts	0x6c, r21
    abda:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    abde:	8b 01       	movw	r16, r22
    abe0:	9c 01       	movw	r18, r24
    abe2:	21 96       	adiw	r28, 0x01	; 1
    abe4:	4c ad       	sts	0x6c, r20
    abe6:	5d ad       	sts	0x6d, r21
    abe8:	6e ad       	sts	0x6e, r22
    abea:	7f ad       	sts	0x6f, r23
    abec:	21 97       	sbiw	r28, 0x01	; 1
    abee:	da 01       	movw	r26, r20
    abf0:	99 27       	eor	r25, r25
    abf2:	88 27       	eor	r24, r24
    abf4:	4d a5       	lds	r20, 0x6d
    abf6:	5e a5       	lds	r21, 0x6e
    abf8:	6f a5       	lds	r22, 0x6f
    abfa:	78 a9       	sts	0x48, r23
    abfc:	60 70       	andi	r22, 0x00	; 0
    abfe:	70 70       	andi	r23, 0x00	; 0
    ac00:	84 2b       	or	r24, r20
    ac02:	95 2b       	or	r25, r21
    ac04:	a6 2b       	or	r26, r22
    ac06:	b7 2b       	or	r27, r23
    ac08:	49 a5       	lds	r20, 0x69
    ac0a:	5a a5       	lds	r21, 0x6a
    ac0c:	6b a5       	lds	r22, 0x6b
    ac0e:	7c a5       	lds	r23, 0x6c
    ac10:	80 17       	cp	r24, r16
    ac12:	91 07       	cpc	r25, r17
    ac14:	a2 07       	cpc	r26, r18
    ac16:	b3 07       	cpc	r27, r19
    ac18:	f0 f4       	brcc	.+60     	; 0xac56 <__divdi3+0x7f8>
    ac1a:	41 50       	subi	r20, 0x01	; 1
    ac1c:	50 40       	sbci	r21, 0x00	; 0
    ac1e:	60 40       	sbci	r22, 0x00	; 0
    ac20:	70 40       	sbci	r23, 0x00	; 0
    ac22:	88 0d       	add	r24, r8
    ac24:	99 1d       	adc	r25, r9
    ac26:	aa 1d       	adc	r26, r10
    ac28:	bb 1d       	adc	r27, r11
    ac2a:	88 15       	cp	r24, r8
    ac2c:	99 05       	cpc	r25, r9
    ac2e:	aa 05       	cpc	r26, r10
    ac30:	bb 05       	cpc	r27, r11
    ac32:	88 f0       	brcs	.+34     	; 0xac56 <__divdi3+0x7f8>
    ac34:	80 17       	cp	r24, r16
    ac36:	91 07       	cpc	r25, r17
    ac38:	a2 07       	cpc	r26, r18
    ac3a:	b3 07       	cpc	r27, r19
    ac3c:	60 f4       	brcc	.+24     	; 0xac56 <__divdi3+0x7f8>
    ac3e:	49 a5       	lds	r20, 0x69
    ac40:	5a a5       	lds	r21, 0x6a
    ac42:	6b a5       	lds	r22, 0x6b
    ac44:	7c a5       	lds	r23, 0x6c
    ac46:	42 50       	subi	r20, 0x02	; 2
    ac48:	50 40       	sbci	r21, 0x00	; 0
    ac4a:	60 40       	sbci	r22, 0x00	; 0
    ac4c:	70 40       	sbci	r23, 0x00	; 0
    ac4e:	88 0d       	add	r24, r8
    ac50:	99 1d       	adc	r25, r9
    ac52:	aa 1d       	adc	r26, r10
    ac54:	bb 1d       	adc	r27, r11
    ac56:	6c 01       	movw	r12, r24
    ac58:	7d 01       	movw	r14, r26
    ac5a:	c0 1a       	sub	r12, r16
    ac5c:	d1 0a       	sbc	r13, r17
    ac5e:	e2 0a       	sbc	r14, r18
    ac60:	f3 0a       	sbc	r15, r19
    ac62:	09 a9       	sts	0x49, r16
    ac64:	1a a9       	sts	0x4a, r17
    ac66:	2b a9       	sts	0x4b, r18
    ac68:	3c a9       	sts	0x4c, r19
    ac6a:	38 01       	movw	r6, r16
    ac6c:	55 24       	eor	r5, r5
    ac6e:	44 24       	eor	r4, r4
    ac70:	44 2a       	or	r4, r20
    ac72:	55 2a       	or	r5, r21
    ac74:	66 2a       	or	r6, r22
    ac76:	77 2a       	or	r7, r23
    ac78:	85 01       	movw	r16, r10
    ac7a:	22 27       	eor	r18, r18
    ac7c:	33 27       	eor	r19, r19
    ac7e:	0d a7       	lds	r16, 0x7d
    ac80:	1e a7       	lds	r17, 0x7e
    ac82:	2f a7       	lds	r18, 0x7f
    ac84:	38 ab       	sts	0x58, r19
    ac86:	95 01       	movw	r18, r10
    ac88:	84 01       	movw	r16, r8
    ac8a:	20 70       	andi	r18, 0x00	; 0
    ac8c:	30 70       	andi	r19, 0x00	; 0
    ac8e:	09 af       	sts	0x79, r16
    ac90:	1a af       	sts	0x7a, r17
    ac92:	2b af       	sts	0x7b, r18
    ac94:	3c af       	sts	0x7c, r19
    ac96:	c7 01       	movw	r24, r14
    ac98:	b6 01       	movw	r22, r12
    ac9a:	2d a5       	lds	r18, 0x6d
    ac9c:	3e a5       	lds	r19, 0x6e
    ac9e:	4f a5       	lds	r20, 0x6f
    aca0:	58 a9       	sts	0x48, r21
    aca2:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    aca6:	29 a7       	lds	r18, 0x79
    aca8:	3a a7       	lds	r19, 0x7a
    acaa:	4b a7       	lds	r20, 0x7b
    acac:	5c a7       	lds	r21, 0x7c
    acae:	69 ab       	sts	0x59, r22
    acb0:	7a ab       	sts	0x5a, r23
    acb2:	8b ab       	sts	0x5b, r24
    acb4:	9c ab       	sts	0x5c, r25
    acb6:	c7 01       	movw	r24, r14
    acb8:	b6 01       	movw	r22, r12
    acba:	2d a5       	lds	r18, 0x6d
    acbc:	3e a5       	lds	r19, 0x6e
    acbe:	4f a5       	lds	r20, 0x6f
    acc0:	58 a9       	sts	0x48, r21
    acc2:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    acc6:	ca 01       	movw	r24, r20
    acc8:	b9 01       	movw	r22, r18
    acca:	29 ad       	sts	0x69, r18
    accc:	3a ad       	sts	0x6a, r19
    acce:	4b ad       	sts	0x6b, r20
    acd0:	5c ad       	sts	0x6c, r21
    acd2:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    acd6:	ab 01       	movw	r20, r22
    acd8:	bc 01       	movw	r22, r24
    acda:	09 a9       	sts	0x49, r16
    acdc:	1a a9       	sts	0x4a, r17
    acde:	2b a9       	sts	0x4b, r18
    ace0:	3c a9       	sts	0x4c, r19
    ace2:	78 01       	movw	r14, r16
    ace4:	dd 24       	eor	r13, r13
    ace6:	cc 24       	eor	r12, r12
    ace8:	0d a9       	sts	0x4d, r16
    acea:	1e a9       	sts	0x4e, r17
    acec:	2f a9       	sts	0x4f, r18
    acee:	38 ad       	sts	0x68, r19
    acf0:	c9 01       	movw	r24, r18
    acf2:	aa 27       	eor	r26, r26
    acf4:	bb 27       	eor	r27, r27
    acf6:	c8 2a       	or	r12, r24
    acf8:	d9 2a       	or	r13, r25
    acfa:	ea 2a       	or	r14, r26
    acfc:	fb 2a       	or	r15, r27
    acfe:	09 a5       	lds	r16, 0x69
    ad00:	1a a5       	lds	r17, 0x6a
    ad02:	2b a5       	lds	r18, 0x6b
    ad04:	3c a5       	lds	r19, 0x6c
    ad06:	c4 16       	cp	r12, r20
    ad08:	d5 06       	cpc	r13, r21
    ad0a:	e6 06       	cpc	r14, r22
    ad0c:	f7 06       	cpc	r15, r23
    ad0e:	38 f5       	brcc	.+78     	; 0xad5e <__divdi3+0x900>
    ad10:	01 50       	subi	r16, 0x01	; 1
    ad12:	10 40       	sbci	r17, 0x00	; 0
    ad14:	20 40       	sbci	r18, 0x00	; 0
    ad16:	30 40       	sbci	r19, 0x00	; 0
    ad18:	09 ab       	sts	0x59, r16
    ad1a:	1a ab       	sts	0x5a, r17
    ad1c:	2b ab       	sts	0x5b, r18
    ad1e:	3c ab       	sts	0x5c, r19
    ad20:	c8 0c       	add	r12, r8
    ad22:	d9 1c       	adc	r13, r9
    ad24:	ea 1c       	adc	r14, r10
    ad26:	fb 1c       	adc	r15, r11
    ad28:	c8 14       	cp	r12, r8
    ad2a:	d9 04       	cpc	r13, r9
    ad2c:	ea 04       	cpc	r14, r10
    ad2e:	fb 04       	cpc	r15, r11
    ad30:	d0 f0       	brcs	.+52     	; 0xad66 <__divdi3+0x908>
    ad32:	c4 16       	cp	r12, r20
    ad34:	d5 06       	cpc	r13, r21
    ad36:	e6 06       	cpc	r14, r22
    ad38:	f7 06       	cpc	r15, r23
    ad3a:	a8 f4       	brcc	.+42     	; 0xad66 <__divdi3+0x908>
    ad3c:	09 a5       	lds	r16, 0x69
    ad3e:	1a a5       	lds	r17, 0x6a
    ad40:	2b a5       	lds	r18, 0x6b
    ad42:	3c a5       	lds	r19, 0x6c
    ad44:	02 50       	subi	r16, 0x02	; 2
    ad46:	10 40       	sbci	r17, 0x00	; 0
    ad48:	20 40       	sbci	r18, 0x00	; 0
    ad4a:	30 40       	sbci	r19, 0x00	; 0
    ad4c:	09 ab       	sts	0x59, r16
    ad4e:	1a ab       	sts	0x5a, r17
    ad50:	2b ab       	sts	0x5b, r18
    ad52:	3c ab       	sts	0x5c, r19
    ad54:	c8 0c       	add	r12, r8
    ad56:	d9 1c       	adc	r13, r9
    ad58:	ea 1c       	adc	r14, r10
    ad5a:	fb 1c       	adc	r15, r11
    ad5c:	04 c0       	rjmp	.+8      	; 0xad66 <__divdi3+0x908>
    ad5e:	09 ab       	sts	0x59, r16
    ad60:	1a ab       	sts	0x5a, r17
    ad62:	2b ab       	sts	0x5b, r18
    ad64:	3c ab       	sts	0x5c, r19
    ad66:	c4 1a       	sub	r12, r20
    ad68:	d5 0a       	sbc	r13, r21
    ad6a:	e6 0a       	sbc	r14, r22
    ad6c:	f7 0a       	sbc	r15, r23
    ad6e:	c7 01       	movw	r24, r14
    ad70:	b6 01       	movw	r22, r12
    ad72:	2d a5       	lds	r18, 0x6d
    ad74:	3e a5       	lds	r19, 0x6e
    ad76:	4f a5       	lds	r20, 0x6f
    ad78:	58 a9       	sts	0x48, r21
    ad7a:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    ad7e:	29 a7       	lds	r18, 0x79
    ad80:	3a a7       	lds	r19, 0x7a
    ad82:	4b a7       	lds	r20, 0x7b
    ad84:	5c a7       	lds	r21, 0x7c
    ad86:	21 96       	adiw	r28, 0x01	; 1
    ad88:	6c af       	sts	0x7c, r22
    ad8a:	7d af       	sts	0x7d, r23
    ad8c:	8e af       	sts	0x7e, r24
    ad8e:	9f af       	sts	0x7f, r25
    ad90:	21 97       	sbiw	r28, 0x01	; 1
    ad92:	c7 01       	movw	r24, r14
    ad94:	b6 01       	movw	r22, r12
    ad96:	2d a5       	lds	r18, 0x6d
    ad98:	3e a5       	lds	r19, 0x6e
    ad9a:	4f a5       	lds	r20, 0x6f
    ad9c:	58 a9       	sts	0x48, r21
    ad9e:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    ada2:	ca 01       	movw	r24, r20
    ada4:	b9 01       	movw	r22, r18
    ada6:	29 ad       	sts	0x69, r18
    ada8:	3a ad       	sts	0x6a, r19
    adaa:	4b ad       	sts	0x6b, r20
    adac:	5c ad       	sts	0x6c, r21
    adae:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    adb2:	8b 01       	movw	r16, r22
    adb4:	9c 01       	movw	r18, r24
    adb6:	21 96       	adiw	r28, 0x01	; 1
    adb8:	4c ad       	sts	0x6c, r20
    adba:	5d ad       	sts	0x6d, r21
    adbc:	6e ad       	sts	0x6e, r22
    adbe:	7f ad       	sts	0x6f, r23
    adc0:	21 97       	sbiw	r28, 0x01	; 1
    adc2:	da 01       	movw	r26, r20
    adc4:	99 27       	eor	r25, r25
    adc6:	88 27       	eor	r24, r24
    adc8:	4d a9       	sts	0x4d, r20
    adca:	5e a9       	sts	0x4e, r21
    adcc:	6f a9       	sts	0x4f, r22
    adce:	78 ad       	sts	0x68, r23
    add0:	60 70       	andi	r22, 0x00	; 0
    add2:	70 70       	andi	r23, 0x00	; 0
    add4:	84 2b       	or	r24, r20
    add6:	95 2b       	or	r25, r21
    add8:	a6 2b       	or	r26, r22
    adda:	b7 2b       	or	r27, r23
    addc:	49 a5       	lds	r20, 0x69
    adde:	5a a5       	lds	r21, 0x6a
    ade0:	6b a5       	lds	r22, 0x6b
    ade2:	7c a5       	lds	r23, 0x6c
    ade4:	80 17       	cp	r24, r16
    ade6:	91 07       	cpc	r25, r17
    ade8:	a2 07       	cpc	r26, r18
    adea:	b3 07       	cpc	r27, r19
    adec:	d0 f4       	brcc	.+52     	; 0xae22 <__divdi3+0x9c4>
    adee:	41 50       	subi	r20, 0x01	; 1
    adf0:	50 40       	sbci	r21, 0x00	; 0
    adf2:	60 40       	sbci	r22, 0x00	; 0
    adf4:	70 40       	sbci	r23, 0x00	; 0
    adf6:	88 0d       	add	r24, r8
    adf8:	99 1d       	adc	r25, r9
    adfa:	aa 1d       	adc	r26, r10
    adfc:	bb 1d       	adc	r27, r11
    adfe:	88 15       	cp	r24, r8
    ae00:	99 05       	cpc	r25, r9
    ae02:	aa 05       	cpc	r26, r10
    ae04:	bb 05       	cpc	r27, r11
    ae06:	68 f0       	brcs	.+26     	; 0xae22 <__divdi3+0x9c4>
    ae08:	80 17       	cp	r24, r16
    ae0a:	91 07       	cpc	r25, r17
    ae0c:	a2 07       	cpc	r26, r18
    ae0e:	b3 07       	cpc	r27, r19
    ae10:	40 f4       	brcc	.+16     	; 0xae22 <__divdi3+0x9c4>
    ae12:	49 a5       	lds	r20, 0x69
    ae14:	5a a5       	lds	r21, 0x6a
    ae16:	6b a5       	lds	r22, 0x6b
    ae18:	7c a5       	lds	r23, 0x6c
    ae1a:	42 50       	subi	r20, 0x02	; 2
    ae1c:	50 40       	sbci	r21, 0x00	; 0
    ae1e:	60 40       	sbci	r22, 0x00	; 0
    ae20:	70 40       	sbci	r23, 0x00	; 0
    ae22:	09 a9       	sts	0x49, r16
    ae24:	1a a9       	sts	0x4a, r17
    ae26:	2b a9       	sts	0x4b, r18
    ae28:	3c a9       	sts	0x4c, r19
    ae2a:	78 01       	movw	r14, r16
    ae2c:	dd 24       	eor	r13, r13
    ae2e:	cc 24       	eor	r12, r12
    ae30:	c4 2a       	or	r12, r20
    ae32:	d5 2a       	or	r13, r21
    ae34:	e6 2a       	or	r14, r22
    ae36:	f7 2a       	or	r15, r23
    ae38:	50 c2       	rjmp	.+1184   	; 0xb2da <__divdi3+0xe7c>
    ae3a:	c8 16       	cp	r12, r24
    ae3c:	d9 06       	cpc	r13, r25
    ae3e:	ea 06       	cpc	r14, r26
    ae40:	fb 06       	cpc	r15, r27
    ae42:	08 f4       	brcc	.+2      	; 0xae46 <__divdi3+0x9e8>
    ae44:	37 c2       	rjmp	.+1134   	; 0xb2b4 <__divdi3+0xe56>
    ae46:	80 30       	cpi	r24, 0x00	; 0
    ae48:	10 e0       	ldi	r17, 0x00	; 0
    ae4a:	91 07       	cpc	r25, r17
    ae4c:	11 e0       	ldi	r17, 0x01	; 1
    ae4e:	a1 07       	cpc	r26, r17
    ae50:	10 e0       	ldi	r17, 0x00	; 0
    ae52:	b1 07       	cpc	r27, r17
    ae54:	50 f4       	brcc	.+20     	; 0xae6a <__divdi3+0xa0c>
    ae56:	8f 3f       	cpi	r24, 0xFF	; 255
    ae58:	91 05       	cpc	r25, r1
    ae5a:	a1 05       	cpc	r26, r1
    ae5c:	b1 05       	cpc	r27, r1
    ae5e:	09 f0       	breq	.+2      	; 0xae62 <__divdi3+0xa04>
    ae60:	88 f4       	brcc	.+34     	; 0xae84 <__divdi3+0xa26>
    ae62:	00 e0       	ldi	r16, 0x00	; 0
    ae64:	10 e0       	ldi	r17, 0x00	; 0
    ae66:	98 01       	movw	r18, r16
    ae68:	16 c0       	rjmp	.+44     	; 0xae96 <__divdi3+0xa38>
    ae6a:	80 30       	cpi	r24, 0x00	; 0
    ae6c:	20 e0       	ldi	r18, 0x00	; 0
    ae6e:	92 07       	cpc	r25, r18
    ae70:	20 e0       	ldi	r18, 0x00	; 0
    ae72:	a2 07       	cpc	r26, r18
    ae74:	21 e0       	ldi	r18, 0x01	; 1
    ae76:	b2 07       	cpc	r27, r18
    ae78:	50 f4       	brcc	.+20     	; 0xae8e <__divdi3+0xa30>
    ae7a:	00 e1       	ldi	r16, 0x10	; 16
    ae7c:	10 e0       	ldi	r17, 0x00	; 0
    ae7e:	20 e0       	ldi	r18, 0x00	; 0
    ae80:	30 e0       	ldi	r19, 0x00	; 0
    ae82:	09 c0       	rjmp	.+18     	; 0xae96 <__divdi3+0xa38>
    ae84:	08 e0       	ldi	r16, 0x08	; 8
    ae86:	10 e0       	ldi	r17, 0x00	; 0
    ae88:	20 e0       	ldi	r18, 0x00	; 0
    ae8a:	30 e0       	ldi	r19, 0x00	; 0
    ae8c:	04 c0       	rjmp	.+8      	; 0xae96 <__divdi3+0xa38>
    ae8e:	08 e1       	ldi	r16, 0x18	; 24
    ae90:	10 e0       	ldi	r17, 0x00	; 0
    ae92:	20 e0       	ldi	r18, 0x00	; 0
    ae94:	30 e0       	ldi	r19, 0x00	; 0
    ae96:	ac 01       	movw	r20, r24
    ae98:	bd 01       	movw	r22, r26
    ae9a:	00 2e       	mov	r0, r16
    ae9c:	04 c0       	rjmp	.+8      	; 0xaea6 <__divdi3+0xa48>
    ae9e:	76 95       	lsr	r23
    aea0:	67 95       	ror	r22
    aea2:	57 95       	ror	r21
    aea4:	47 95       	ror	r20
    aea6:	0a 94       	dec	r0
    aea8:	d2 f7       	brpl	.-12     	; 0xae9e <__divdi3+0xa40>
    aeaa:	fa 01       	movw	r30, r20
    aeac:	ea 5d       	subi	r30, 0xDA	; 218
    aeae:	ff 4d       	sbci	r31, 0xDF	; 223
    aeb0:	40 81       	ld	r20, Z
    aeb2:	04 0f       	add	r16, r20
    aeb4:	11 1d       	adc	r17, r1
    aeb6:	21 1d       	adc	r18, r1
    aeb8:	31 1d       	adc	r19, r1
    aeba:	40 e2       	ldi	r20, 0x20	; 32
    aebc:	50 e0       	ldi	r21, 0x00	; 0
    aebe:	60 e0       	ldi	r22, 0x00	; 0
    aec0:	70 e0       	ldi	r23, 0x00	; 0
    aec2:	40 1b       	sub	r20, r16
    aec4:	51 0b       	sbc	r21, r17
    aec6:	62 0b       	sbc	r22, r18
    aec8:	73 0b       	sbc	r23, r19
    aeca:	a1 f4       	brne	.+40     	; 0xaef4 <__divdi3+0xa96>
    aecc:	8c 15       	cp	r24, r12
    aece:	9d 05       	cpc	r25, r13
    aed0:	ae 05       	cpc	r26, r14
    aed2:	bf 05       	cpc	r27, r15
    aed4:	08 f4       	brcc	.+2      	; 0xaed8 <__divdi3+0xa7a>
    aed6:	f5 c1       	rjmp	.+1002   	; 0xb2c2 <__divdi3+0xe64>
    aed8:	ed a8       	sts	0x8d, r30
    aeda:	fe a8       	sts	0x8e, r31
    aedc:	0f a9       	sts	0x4f, r16
    aede:	18 ad       	sts	0x68, r17
    aee0:	44 24       	eor	r4, r4
    aee2:	55 24       	eor	r5, r5
    aee4:	32 01       	movw	r6, r4
    aee6:	e8 14       	cp	r14, r8
    aee8:	f9 04       	cpc	r15, r9
    aeea:	0a 05       	cpc	r16, r10
    aeec:	1b 05       	cpc	r17, r11
    aeee:	08 f0       	brcs	.+2      	; 0xaef2 <__divdi3+0xa94>
    aef0:	eb c1       	rjmp	.+982    	; 0xb2c8 <__divdi3+0xe6a>
    aef2:	e3 c1       	rjmp	.+966    	; 0xb2ba <__divdi3+0xe5c>
    aef4:	34 2e       	mov	r3, r20
    aef6:	2c 01       	movw	r4, r24
    aef8:	3d 01       	movw	r6, r26
    aefa:	04 c0       	rjmp	.+8      	; 0xaf04 <__divdi3+0xaa6>
    aefc:	44 0c       	add	r4, r4
    aefe:	55 1c       	adc	r5, r5
    af00:	66 1c       	adc	r6, r6
    af02:	77 1c       	adc	r7, r7
    af04:	4a 95       	dec	r20
    af06:	d2 f7       	brpl	.-12     	; 0xaefc <__divdi3+0xa9e>
    af08:	d5 01       	movw	r26, r10
    af0a:	c4 01       	movw	r24, r8
    af0c:	00 2e       	mov	r0, r16
    af0e:	04 c0       	rjmp	.+8      	; 0xaf18 <__divdi3+0xaba>
    af10:	b6 95       	lsr	r27
    af12:	a7 95       	ror	r26
    af14:	97 95       	ror	r25
    af16:	87 95       	ror	r24
    af18:	0a 94       	dec	r0
    af1a:	d2 f7       	brpl	.-12     	; 0xaf10 <__divdi3+0xab2>
    af1c:	48 2a       	or	r4, r24
    af1e:	59 2a       	or	r5, r25
    af20:	6a 2a       	or	r6, r26
    af22:	7b 2a       	or	r7, r27
    af24:	a5 01       	movw	r20, r10
    af26:	94 01       	movw	r18, r8
    af28:	03 2c       	mov	r0, r3
    af2a:	04 c0       	rjmp	.+8      	; 0xaf34 <__divdi3+0xad6>
    af2c:	22 0f       	add	r18, r18
    af2e:	33 1f       	adc	r19, r19
    af30:	44 1f       	adc	r20, r20
    af32:	55 1f       	adc	r21, r21
    af34:	0a 94       	dec	r0
    af36:	d2 f7       	brpl	.-12     	; 0xaf2c <__divdi3+0xace>
    af38:	29 af       	sts	0x79, r18
    af3a:	3a af       	sts	0x7a, r19
    af3c:	4b af       	sts	0x7b, r20
    af3e:	5c af       	sts	0x7c, r21
    af40:	b7 01       	movw	r22, r14
    af42:	a6 01       	movw	r20, r12
    af44:	00 2e       	mov	r0, r16
    af46:	04 c0       	rjmp	.+8      	; 0xaf50 <__divdi3+0xaf2>
    af48:	76 95       	lsr	r23
    af4a:	67 95       	ror	r22
    af4c:	57 95       	ror	r21
    af4e:	47 95       	ror	r20
    af50:	0a 94       	dec	r0
    af52:	d2 f7       	brpl	.-12     	; 0xaf48 <__divdi3+0xaea>
    af54:	49 ab       	sts	0x59, r20
    af56:	5a ab       	sts	0x5a, r21
    af58:	6b ab       	sts	0x5b, r22
    af5a:	7c ab       	sts	0x5c, r23
    af5c:	c7 01       	movw	r24, r14
    af5e:	b6 01       	movw	r22, r12
    af60:	03 2c       	mov	r0, r3
    af62:	04 c0       	rjmp	.+8      	; 0xaf6c <__divdi3+0xb0e>
    af64:	66 0f       	add	r22, r22
    af66:	77 1f       	adc	r23, r23
    af68:	88 1f       	adc	r24, r24
    af6a:	99 1f       	adc	r25, r25
    af6c:	0a 94       	dec	r0
    af6e:	d2 f7       	brpl	.-12     	; 0xaf64 <__divdi3+0xb06>
    af70:	6d a7       	lds	r22, 0x7d
    af72:	7e a7       	lds	r23, 0x7e
    af74:	8f a7       	lds	r24, 0x7f
    af76:	98 ab       	sts	0x58, r25
    af78:	8d a9       	sts	0x4d, r24
    af7a:	9e a9       	sts	0x4e, r25
    af7c:	af a9       	sts	0x4f, r26
    af7e:	b8 ad       	sts	0x68, r27
    af80:	04 c0       	rjmp	.+8      	; 0xaf8a <__divdi3+0xb2c>
    af82:	b6 95       	lsr	r27
    af84:	a7 95       	ror	r26
    af86:	97 95       	ror	r25
    af88:	87 95       	ror	r24
    af8a:	0a 95       	dec	r16
    af8c:	d2 f7       	brpl	.-12     	; 0xaf82 <__divdi3+0xb24>
    af8e:	4d a5       	lds	r20, 0x6d
    af90:	5e a5       	lds	r21, 0x6e
    af92:	6f a5       	lds	r22, 0x6f
    af94:	78 a9       	sts	0x48, r23
    af96:	48 2b       	or	r20, r24
    af98:	59 2b       	or	r21, r25
    af9a:	6a 2b       	or	r22, r26
    af9c:	7b 2b       	or	r23, r27
    af9e:	4d a7       	lds	r20, 0x7d
    afa0:	5e a7       	lds	r21, 0x7e
    afa2:	6f a7       	lds	r22, 0x7f
    afa4:	78 ab       	sts	0x58, r23
    afa6:	43 01       	movw	r8, r6
    afa8:	aa 24       	eor	r10, r10
    afaa:	bb 24       	eor	r11, r11
    afac:	93 01       	movw	r18, r6
    afae:	82 01       	movw	r16, r4
    afb0:	20 70       	andi	r18, 0x00	; 0
    afb2:	30 70       	andi	r19, 0x00	; 0
    afb4:	21 96       	adiw	r28, 0x01	; 1
    afb6:	0c af       	sts	0x7c, r16
    afb8:	1d af       	sts	0x7d, r17
    afba:	2e af       	sts	0x7e, r18
    afbc:	3f af       	sts	0x7f, r19
    afbe:	21 97       	sbiw	r28, 0x01	; 1
    afc0:	69 a9       	sts	0x49, r22
    afc2:	7a a9       	sts	0x4a, r23
    afc4:	8b a9       	sts	0x4b, r24
    afc6:	9c a9       	sts	0x4c, r25
    afc8:	a5 01       	movw	r20, r10
    afca:	94 01       	movw	r18, r8
    afcc:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    afd0:	29 a7       	lds	r18, 0x79
    afd2:	3a a7       	lds	r19, 0x7a
    afd4:	4b a7       	lds	r20, 0x7b
    afd6:	5c a7       	lds	r21, 0x7c
    afd8:	6b 01       	movw	r12, r22
    afda:	7c 01       	movw	r14, r24
    afdc:	69 a9       	sts	0x49, r22
    afde:	7a a9       	sts	0x4a, r23
    afe0:	8b a9       	sts	0x4b, r24
    afe2:	9c a9       	sts	0x4c, r25
    afe4:	a5 01       	movw	r20, r10
    afe6:	94 01       	movw	r18, r8
    afe8:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    afec:	ca 01       	movw	r24, r20
    afee:	b9 01       	movw	r22, r18
    aff0:	21 96       	adiw	r28, 0x01	; 1
    aff2:	2c ad       	sts	0x6c, r18
    aff4:	3d ad       	sts	0x6d, r19
    aff6:	4e ad       	sts	0x6e, r20
    aff8:	5f ad       	sts	0x6f, r21
    affa:	21 97       	sbiw	r28, 0x01	; 1
    affc:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b000:	dc 01       	movw	r26, r24
    b002:	cb 01       	movw	r24, r22
    b004:	76 01       	movw	r14, r12
    b006:	dd 24       	eor	r13, r13
    b008:	cc 24       	eor	r12, r12
    b00a:	0d a5       	lds	r16, 0x6d
    b00c:	1e a5       	lds	r17, 0x6e
    b00e:	2f a5       	lds	r18, 0x6f
    b010:	38 a9       	sts	0x48, r19
    b012:	a9 01       	movw	r20, r18
    b014:	66 27       	eor	r22, r22
    b016:	77 27       	eor	r23, r23
    b018:	c4 2a       	or	r12, r20
    b01a:	d5 2a       	or	r13, r21
    b01c:	e6 2a       	or	r14, r22
    b01e:	f7 2a       	or	r15, r23
    b020:	09 a5       	lds	r16, 0x69
    b022:	1a a5       	lds	r17, 0x6a
    b024:	2b a5       	lds	r18, 0x6b
    b026:	3c a5       	lds	r19, 0x6c
    b028:	c8 16       	cp	r12, r24
    b02a:	d9 06       	cpc	r13, r25
    b02c:	ea 06       	cpc	r14, r26
    b02e:	fb 06       	cpc	r15, r27
    b030:	38 f5       	brcc	.+78     	; 0xb080 <__divdi3+0xc22>
    b032:	01 50       	subi	r16, 0x01	; 1
    b034:	10 40       	sbci	r17, 0x00	; 0
    b036:	20 40       	sbci	r18, 0x00	; 0
    b038:	30 40       	sbci	r19, 0x00	; 0
    b03a:	09 ab       	sts	0x59, r16
    b03c:	1a ab       	sts	0x5a, r17
    b03e:	2b ab       	sts	0x5b, r18
    b040:	3c ab       	sts	0x5c, r19
    b042:	c4 0c       	add	r12, r4
    b044:	d5 1c       	adc	r13, r5
    b046:	e6 1c       	adc	r14, r6
    b048:	f7 1c       	adc	r15, r7
    b04a:	c4 14       	cp	r12, r4
    b04c:	d5 04       	cpc	r13, r5
    b04e:	e6 04       	cpc	r14, r6
    b050:	f7 04       	cpc	r15, r7
    b052:	d0 f0       	brcs	.+52     	; 0xb088 <__divdi3+0xc2a>
    b054:	c8 16       	cp	r12, r24
    b056:	d9 06       	cpc	r13, r25
    b058:	ea 06       	cpc	r14, r26
    b05a:	fb 06       	cpc	r15, r27
    b05c:	a8 f4       	brcc	.+42     	; 0xb088 <__divdi3+0xc2a>
    b05e:	09 a5       	lds	r16, 0x69
    b060:	1a a5       	lds	r17, 0x6a
    b062:	2b a5       	lds	r18, 0x6b
    b064:	3c a5       	lds	r19, 0x6c
    b066:	02 50       	subi	r16, 0x02	; 2
    b068:	10 40       	sbci	r17, 0x00	; 0
    b06a:	20 40       	sbci	r18, 0x00	; 0
    b06c:	30 40       	sbci	r19, 0x00	; 0
    b06e:	09 ab       	sts	0x59, r16
    b070:	1a ab       	sts	0x5a, r17
    b072:	2b ab       	sts	0x5b, r18
    b074:	3c ab       	sts	0x5c, r19
    b076:	c4 0c       	add	r12, r4
    b078:	d5 1c       	adc	r13, r5
    b07a:	e6 1c       	adc	r14, r6
    b07c:	f7 1c       	adc	r15, r7
    b07e:	04 c0       	rjmp	.+8      	; 0xb088 <__divdi3+0xc2a>
    b080:	09 ab       	sts	0x59, r16
    b082:	1a ab       	sts	0x5a, r17
    b084:	2b ab       	sts	0x5b, r18
    b086:	3c ab       	sts	0x5c, r19
    b088:	c8 1a       	sub	r12, r24
    b08a:	d9 0a       	sbc	r13, r25
    b08c:	ea 0a       	sbc	r14, r26
    b08e:	fb 0a       	sbc	r15, r27
    b090:	c7 01       	movw	r24, r14
    b092:	b6 01       	movw	r22, r12
    b094:	a5 01       	movw	r20, r10
    b096:	94 01       	movw	r18, r8
    b098:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b09c:	29 a7       	lds	r18, 0x79
    b09e:	3a a7       	lds	r19, 0x7a
    b0a0:	4b a7       	lds	r20, 0x7b
    b0a2:	5c a7       	lds	r21, 0x7c
    b0a4:	29 96       	adiw	r28, 0x09	; 9
    b0a6:	6c af       	sts	0x7c, r22
    b0a8:	7d af       	sts	0x7d, r23
    b0aa:	8e af       	sts	0x7e, r24
    b0ac:	9f af       	sts	0x7f, r25
    b0ae:	29 97       	sbiw	r28, 0x09	; 9
    b0b0:	c7 01       	movw	r24, r14
    b0b2:	b6 01       	movw	r22, r12
    b0b4:	a5 01       	movw	r20, r10
    b0b6:	94 01       	movw	r18, r8
    b0b8:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b0bc:	ca 01       	movw	r24, r20
    b0be:	b9 01       	movw	r22, r18
    b0c0:	21 96       	adiw	r28, 0x01	; 1
    b0c2:	2c ad       	sts	0x6c, r18
    b0c4:	3d ad       	sts	0x6d, r19
    b0c6:	4e ad       	sts	0x6e, r20
    b0c8:	5f ad       	sts	0x6f, r21
    b0ca:	21 97       	sbiw	r28, 0x01	; 1
    b0cc:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b0d0:	4b 01       	movw	r8, r22
    b0d2:	5c 01       	movw	r10, r24
    b0d4:	29 96       	adiw	r28, 0x09	; 9
    b0d6:	4c ad       	sts	0x6c, r20
    b0d8:	5d ad       	sts	0x6d, r21
    b0da:	6e ad       	sts	0x6e, r22
    b0dc:	7f ad       	sts	0x6f, r23
    b0de:	29 97       	sbiw	r28, 0x09	; 9
    b0e0:	9a 01       	movw	r18, r20
    b0e2:	11 27       	eor	r17, r17
    b0e4:	00 27       	eor	r16, r16
    b0e6:	8d a5       	lds	r24, 0x6d
    b0e8:	9e a5       	lds	r25, 0x6e
    b0ea:	af a5       	lds	r26, 0x6f
    b0ec:	b8 a9       	sts	0x48, r27
    b0ee:	a0 70       	andi	r26, 0x00	; 0
    b0f0:	b0 70       	andi	r27, 0x00	; 0
    b0f2:	08 2b       	or	r16, r24
    b0f4:	19 2b       	or	r17, r25
    b0f6:	2a 2b       	or	r18, r26
    b0f8:	3b 2b       	or	r19, r27
    b0fa:	89 a5       	lds	r24, 0x69
    b0fc:	9a a5       	lds	r25, 0x6a
    b0fe:	ab a5       	lds	r26, 0x6b
    b100:	bc a5       	lds	r27, 0x6c
    b102:	08 15       	cp	r16, r8
    b104:	19 05       	cpc	r17, r9
    b106:	2a 05       	cpc	r18, r10
    b108:	3b 05       	cpc	r19, r11
    b10a:	e0 f4       	brcc	.+56     	; 0xb144 <__divdi3+0xce6>
    b10c:	01 97       	sbiw	r24, 0x01	; 1
    b10e:	a1 09       	sbc	r26, r1
    b110:	b1 09       	sbc	r27, r1
    b112:	04 0d       	add	r16, r4
    b114:	15 1d       	adc	r17, r5
    b116:	26 1d       	adc	r18, r6
    b118:	37 1d       	adc	r19, r7
    b11a:	04 15       	cp	r16, r4
    b11c:	15 05       	cpc	r17, r5
    b11e:	26 05       	cpc	r18, r6
    b120:	37 05       	cpc	r19, r7
    b122:	80 f0       	brcs	.+32     	; 0xb144 <__divdi3+0xce6>
    b124:	08 15       	cp	r16, r8
    b126:	19 05       	cpc	r17, r9
    b128:	2a 05       	cpc	r18, r10
    b12a:	3b 05       	cpc	r19, r11
    b12c:	58 f4       	brcc	.+22     	; 0xb144 <__divdi3+0xce6>
    b12e:	89 a5       	lds	r24, 0x69
    b130:	9a a5       	lds	r25, 0x6a
    b132:	ab a5       	lds	r26, 0x6b
    b134:	bc a5       	lds	r27, 0x6c
    b136:	02 97       	sbiw	r24, 0x02	; 2
    b138:	a1 09       	sbc	r26, r1
    b13a:	b1 09       	sbc	r27, r1
    b13c:	04 0d       	add	r16, r4
    b13e:	15 1d       	adc	r17, r5
    b140:	26 1d       	adc	r18, r6
    b142:	37 1d       	adc	r19, r7
    b144:	b9 01       	movw	r22, r18
    b146:	a8 01       	movw	r20, r16
    b148:	48 19       	sub	r20, r8
    b14a:	59 09       	sbc	r21, r9
    b14c:	6a 09       	sbc	r22, r10
    b14e:	7b 09       	sbc	r23, r11
    b150:	4d a7       	lds	r20, 0x7d
    b152:	5e a7       	lds	r21, 0x7e
    b154:	6f a7       	lds	r22, 0x7f
    b156:	78 ab       	sts	0x58, r23
    b158:	09 a9       	sts	0x49, r16
    b15a:	1a a9       	sts	0x4a, r17
    b15c:	2b a9       	sts	0x4b, r18
    b15e:	3c a9       	sts	0x4c, r19
    b160:	78 01       	movw	r14, r16
    b162:	dd 24       	eor	r13, r13
    b164:	cc 24       	eor	r12, r12
    b166:	c8 2a       	or	r12, r24
    b168:	d9 2a       	or	r13, r25
    b16a:	ea 2a       	or	r14, r26
    b16c:	fb 2a       	or	r15, r27
    b16e:	ff ef       	ldi	r31, 0xFF	; 255
    b170:	8f 2e       	mov	r8, r31
    b172:	ff ef       	ldi	r31, 0xFF	; 255
    b174:	9f 2e       	mov	r9, r31
    b176:	a1 2c       	mov	r10, r1
    b178:	b1 2c       	mov	r11, r1
    b17a:	8c 20       	and	r8, r12
    b17c:	9d 20       	and	r9, r13
    b17e:	ae 20       	and	r10, r14
    b180:	bf 20       	and	r11, r15
    b182:	87 01       	movw	r16, r14
    b184:	22 27       	eor	r18, r18
    b186:	33 27       	eor	r19, r19
    b188:	09 a7       	lds	r16, 0x79
    b18a:	1a a7       	lds	r17, 0x7a
    b18c:	2b a7       	lds	r18, 0x7b
    b18e:	3c a7       	lds	r19, 0x7c
    b190:	49 ac       	sts	0xa9, r20
    b192:	5a ac       	sts	0xaa, r21
    b194:	6b ac       	sts	0xab, r22
    b196:	7c ac       	sts	0xac, r23
    b198:	2f ef       	ldi	r18, 0xFF	; 255
    b19a:	3f ef       	ldi	r19, 0xFF	; 255
    b19c:	40 e0       	ldi	r20, 0x00	; 0
    b19e:	50 e0       	ldi	r21, 0x00	; 0
    b1a0:	42 22       	and	r4, r18
    b1a2:	53 22       	and	r5, r19
    b1a4:	64 22       	and	r6, r20
    b1a6:	75 22       	and	r7, r21
    b1a8:	29 ad       	sts	0x69, r18
    b1aa:	3a ad       	sts	0x6a, r19
    b1ac:	4b ad       	sts	0x6b, r20
    b1ae:	5c ad       	sts	0x6c, r21
    b1b0:	8a 01       	movw	r16, r20
    b1b2:	22 27       	eor	r18, r18
    b1b4:	33 27       	eor	r19, r19
    b1b6:	09 ab       	sts	0x59, r16
    b1b8:	1a ab       	sts	0x5a, r17
    b1ba:	2b ab       	sts	0x5b, r18
    b1bc:	3c ab       	sts	0x5c, r19
    b1be:	c5 01       	movw	r24, r10
    b1c0:	b4 01       	movw	r22, r8
    b1c2:	a3 01       	movw	r20, r6
    b1c4:	92 01       	movw	r18, r4
    b1c6:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b1ca:	69 af       	sts	0x79, r22
    b1cc:	7a af       	sts	0x7a, r23
    b1ce:	8b af       	sts	0x7b, r24
    b1d0:	9c af       	sts	0x7c, r25
    b1d2:	c5 01       	movw	r24, r10
    b1d4:	b4 01       	movw	r22, r8
    b1d6:	29 a9       	sts	0x49, r18
    b1d8:	3a a9       	sts	0x4a, r19
    b1da:	4b a9       	sts	0x4b, r20
    b1dc:	5c a9       	sts	0x4c, r21
    b1de:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b1e2:	4b 01       	movw	r8, r22
    b1e4:	5c 01       	movw	r10, r24
    b1e6:	69 a5       	lds	r22, 0x69
    b1e8:	7a a5       	lds	r23, 0x6a
    b1ea:	8b a5       	lds	r24, 0x6b
    b1ec:	9c a5       	lds	r25, 0x6c
    b1ee:	a3 01       	movw	r20, r6
    b1f0:	92 01       	movw	r18, r4
    b1f2:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b1f6:	2b 01       	movw	r4, r22
    b1f8:	3c 01       	movw	r6, r24
    b1fa:	69 a5       	lds	r22, 0x69
    b1fc:	7a a5       	lds	r23, 0x6a
    b1fe:	8b a5       	lds	r24, 0x6b
    b200:	9c a5       	lds	r25, 0x6c
    b202:	29 a9       	sts	0x49, r18
    b204:	3a a9       	sts	0x4a, r19
    b206:	4b a9       	sts	0x4b, r20
    b208:	5c a9       	sts	0x4c, r21
    b20a:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b20e:	ab 01       	movw	r20, r22
    b210:	bc 01       	movw	r22, r24
    b212:	84 0c       	add	r8, r4
    b214:	95 1c       	adc	r9, r5
    b216:	a6 1c       	adc	r10, r6
    b218:	b7 1c       	adc	r11, r7
    b21a:	09 ad       	sts	0x69, r16
    b21c:	1a ad       	sts	0x6a, r17
    b21e:	2b ad       	sts	0x6b, r18
    b220:	3c ad       	sts	0x6c, r19
    b222:	c9 01       	movw	r24, r18
    b224:	aa 27       	eor	r26, r26
    b226:	bb 27       	eor	r27, r27
    b228:	88 0e       	add	r8, r24
    b22a:	99 1e       	adc	r9, r25
    b22c:	aa 1e       	adc	r10, r26
    b22e:	bb 1e       	adc	r11, r27
    b230:	84 14       	cp	r8, r4
    b232:	95 04       	cpc	r9, r5
    b234:	a6 04       	cpc	r10, r6
    b236:	b7 04       	cpc	r11, r7
    b238:	20 f4       	brcc	.+8      	; 0xb242 <__divdi3+0xde4>
    b23a:	40 50       	subi	r20, 0x00	; 0
    b23c:	50 40       	sbci	r21, 0x00	; 0
    b23e:	6f 4f       	sbci	r22, 0xFF	; 255
    b240:	7f 4f       	sbci	r23, 0xFF	; 255
    b242:	c5 01       	movw	r24, r10
    b244:	aa 27       	eor	r26, r26
    b246:	bb 27       	eor	r27, r27
    b248:	84 0f       	add	r24, r20
    b24a:	95 1f       	adc	r25, r21
    b24c:	a6 1f       	adc	r26, r22
    b24e:	b7 1f       	adc	r27, r23
    b250:	0d a5       	lds	r16, 0x6d
    b252:	1e a5       	lds	r17, 0x6e
    b254:	2f a5       	lds	r18, 0x6f
    b256:	38 a9       	sts	0x48, r19
    b258:	08 17       	cp	r16, r24
    b25a:	19 07       	cpc	r17, r25
    b25c:	2a 07       	cpc	r18, r26
    b25e:	3b 07       	cpc	r19, r27
    b260:	18 f1       	brcs	.+70     	; 0xb2a8 <__divdi3+0xe4a>
    b262:	80 17       	cp	r24, r16
    b264:	91 07       	cpc	r25, r17
    b266:	a2 07       	cpc	r26, r18
    b268:	b3 07       	cpc	r27, r19
    b26a:	a1 f5       	brne	.+104    	; 0xb2d4 <__divdi3+0xe76>
    b26c:	54 01       	movw	r10, r8
    b26e:	99 24       	eor	r9, r9
    b270:	88 24       	eor	r8, r8
    b272:	89 ad       	sts	0x69, r24
    b274:	9a ad       	sts	0x6a, r25
    b276:	ab ad       	sts	0x6b, r26
    b278:	bc ad       	sts	0x6c, r27
    b27a:	a0 70       	andi	r26, 0x00	; 0
    b27c:	b0 70       	andi	r27, 0x00	; 0
    b27e:	88 0e       	add	r8, r24
    b280:	99 1e       	adc	r9, r25
    b282:	aa 1e       	adc	r10, r26
    b284:	bb 1e       	adc	r11, r27
    b286:	4d a9       	sts	0x4d, r20
    b288:	5e a9       	sts	0x4e, r21
    b28a:	6f a9       	sts	0x4f, r22
    b28c:	78 ad       	sts	0x68, r23
    b28e:	03 2c       	mov	r0, r3
    b290:	04 c0       	rjmp	.+8      	; 0xb29a <__divdi3+0xe3c>
    b292:	44 0f       	add	r20, r20
    b294:	55 1f       	adc	r21, r21
    b296:	66 1f       	adc	r22, r22
    b298:	77 1f       	adc	r23, r23
    b29a:	0a 94       	dec	r0
    b29c:	d2 f7       	brpl	.-12     	; 0xb292 <__divdi3+0xe34>
    b29e:	48 15       	cp	r20, r8
    b2a0:	59 05       	cpc	r21, r9
    b2a2:	6a 05       	cpc	r22, r10
    b2a4:	7b 05       	cpc	r23, r11
    b2a6:	b0 f4       	brcc	.+44     	; 0xb2d4 <__divdi3+0xe76>
    b2a8:	08 94       	sec
    b2aa:	c1 08       	sbc	r12, r1
    b2ac:	d1 08       	sbc	r13, r1
    b2ae:	e1 08       	sbc	r14, r1
    b2b0:	f1 08       	sbc	r15, r1
    b2b2:	10 c0       	rjmp	.+32     	; 0xb2d4 <__divdi3+0xe76>
    b2b4:	44 24       	eor	r4, r4
    b2b6:	55 24       	eor	r5, r5
    b2b8:	32 01       	movw	r6, r4
    b2ba:	cc 24       	eor	r12, r12
    b2bc:	dd 24       	eor	r13, r13
    b2be:	76 01       	movw	r14, r12
    b2c0:	0c c0       	rjmp	.+24     	; 0xb2da <__divdi3+0xe7c>
    b2c2:	44 24       	eor	r4, r4
    b2c4:	55 24       	eor	r5, r5
    b2c6:	32 01       	movw	r6, r4
    b2c8:	81 e0       	ldi	r24, 0x01	; 1
    b2ca:	c8 2e       	mov	r12, r24
    b2cc:	d1 2c       	mov	r13, r1
    b2ce:	e1 2c       	mov	r14, r1
    b2d0:	f1 2c       	mov	r15, r1
    b2d2:	03 c0       	rjmp	.+6      	; 0xb2da <__divdi3+0xe7c>
    b2d4:	44 24       	eor	r4, r4
    b2d6:	55 24       	eor	r5, r5
    b2d8:	32 01       	movw	r6, r4
    b2da:	fe 01       	movw	r30, r28
    b2dc:	31 96       	adiw	r30, 0x01	; 1
    b2de:	88 e0       	ldi	r24, 0x08	; 8
    b2e0:	df 01       	movw	r26, r30
    b2e2:	1d 92       	st	X+, r1
    b2e4:	8a 95       	dec	r24
    b2e6:	e9 f7       	brne	.-6      	; 0xb2e2 <__divdi3+0xe84>
    b2e8:	c9 82       	std	Y+1, r12	; 0x01
    b2ea:	da 82       	std	Y+2, r13	; 0x02
    b2ec:	eb 82       	std	Y+3, r14	; 0x03
    b2ee:	fc 82       	std	Y+4, r15	; 0x04
    b2f0:	4d 82       	std	Y+5, r4	; 0x05
    b2f2:	5e 82       	std	Y+6, r5	; 0x06
    b2f4:	6f 82       	std	Y+7, r6	; 0x07
    b2f6:	78 86       	std	Y+8, r7	; 0x08
    b2f8:	2c 2d       	mov	r18, r12
    b2fa:	3a 81       	ldd	r19, Y+2	; 0x02
    b2fc:	4b 81       	ldd	r20, Y+3	; 0x03
    b2fe:	5c 81       	ldd	r21, Y+4	; 0x04
    b300:	64 2d       	mov	r22, r4
    b302:	7e 81       	ldd	r23, Y+6	; 0x06
    b304:	8f 81       	ldd	r24, Y+7	; 0x07
    b306:	98 85       	ldd	r25, Y+8	; 0x08
    b308:	25 96       	adiw	r28, 0x05	; 5
    b30a:	ec ac       	sts	0xac, r30
    b30c:	fd ac       	sts	0xad, r31
    b30e:	0e ad       	sts	0x6e, r16
    b310:	1f ad       	sts	0x6f, r17
    b312:	25 97       	sbiw	r28, 0x05	; 5
    b314:	e1 14       	cp	r14, r1
    b316:	f1 04       	cpc	r15, r1
    b318:	01 05       	cpc	r16, r1
    b31a:	11 05       	cpc	r17, r1
    b31c:	09 f4       	brne	.+2      	; 0xb320 <__divdi3+0xec2>
    b31e:	56 c0       	rjmp	.+172    	; 0xb3cc <__divdi3+0xf6e>
    b320:	21 95       	neg	r18
    b322:	e1 e0       	ldi	r30, 0x01	; 1
    b324:	12 16       	cp	r1, r18
    b326:	08 f0       	brcs	.+2      	; 0xb32a <__divdi3+0xecc>
    b328:	e0 e0       	ldi	r30, 0x00	; 0
    b32a:	31 95       	neg	r19
    b32c:	f1 e0       	ldi	r31, 0x01	; 1
    b32e:	13 16       	cp	r1, r19
    b330:	08 f0       	brcs	.+2      	; 0xb334 <__divdi3+0xed6>
    b332:	f0 e0       	ldi	r31, 0x00	; 0
    b334:	03 2f       	mov	r16, r19
    b336:	0e 1b       	sub	r16, r30
    b338:	e1 e0       	ldi	r30, 0x01	; 1
    b33a:	30 17       	cp	r19, r16
    b33c:	08 f0       	brcs	.+2      	; 0xb340 <__divdi3+0xee2>
    b33e:	e0 e0       	ldi	r30, 0x00	; 0
    b340:	fe 2b       	or	r31, r30
    b342:	41 95       	neg	r20
    b344:	e1 e0       	ldi	r30, 0x01	; 1
    b346:	14 16       	cp	r1, r20
    b348:	08 f0       	brcs	.+2      	; 0xb34c <__divdi3+0xeee>
    b34a:	e0 e0       	ldi	r30, 0x00	; 0
    b34c:	14 2f       	mov	r17, r20
    b34e:	1f 1b       	sub	r17, r31
    b350:	31 e0       	ldi	r19, 0x01	; 1
    b352:	41 17       	cp	r20, r17
    b354:	08 f0       	brcs	.+2      	; 0xb358 <__divdi3+0xefa>
    b356:	30 e0       	ldi	r19, 0x00	; 0
    b358:	e3 2b       	or	r30, r19
    b35a:	51 95       	neg	r21
    b35c:	f1 e0       	ldi	r31, 0x01	; 1
    b35e:	15 16       	cp	r1, r21
    b360:	08 f0       	brcs	.+2      	; 0xb364 <__divdi3+0xf06>
    b362:	f0 e0       	ldi	r31, 0x00	; 0
    b364:	b5 2f       	mov	r27, r21
    b366:	be 1b       	sub	r27, r30
    b368:	31 e0       	ldi	r19, 0x01	; 1
    b36a:	5b 17       	cp	r21, r27
    b36c:	08 f0       	brcs	.+2      	; 0xb370 <__divdi3+0xf12>
    b36e:	30 e0       	ldi	r19, 0x00	; 0
    b370:	f3 2b       	or	r31, r19
    b372:	61 95       	neg	r22
    b374:	e1 e0       	ldi	r30, 0x01	; 1
    b376:	16 16       	cp	r1, r22
    b378:	08 f0       	brcs	.+2      	; 0xb37c <__divdi3+0xf1e>
    b37a:	e0 e0       	ldi	r30, 0x00	; 0
    b37c:	46 2e       	mov	r4, r22
    b37e:	4f 1a       	sub	r4, r31
    b380:	31 e0       	ldi	r19, 0x01	; 1
    b382:	64 15       	cp	r22, r4
    b384:	08 f0       	brcs	.+2      	; 0xb388 <__divdi3+0xf2a>
    b386:	30 e0       	ldi	r19, 0x00	; 0
    b388:	e3 2b       	or	r30, r19
    b38a:	71 95       	neg	r23
    b38c:	f1 e0       	ldi	r31, 0x01	; 1
    b38e:	17 16       	cp	r1, r23
    b390:	08 f0       	brcs	.+2      	; 0xb394 <__divdi3+0xf36>
    b392:	f0 e0       	ldi	r31, 0x00	; 0
    b394:	a7 2f       	mov	r26, r23
    b396:	ae 1b       	sub	r26, r30
    b398:	31 e0       	ldi	r19, 0x01	; 1
    b39a:	7a 17       	cp	r23, r26
    b39c:	08 f0       	brcs	.+2      	; 0xb3a0 <__divdi3+0xf42>
    b39e:	30 e0       	ldi	r19, 0x00	; 0
    b3a0:	f3 2b       	or	r31, r19
    b3a2:	81 95       	neg	r24
    b3a4:	e1 e0       	ldi	r30, 0x01	; 1
    b3a6:	18 16       	cp	r1, r24
    b3a8:	08 f0       	brcs	.+2      	; 0xb3ac <__divdi3+0xf4e>
    b3aa:	e0 e0       	ldi	r30, 0x00	; 0
    b3ac:	f8 2e       	mov	r15, r24
    b3ae:	ff 1a       	sub	r15, r31
    b3b0:	ff 2d       	mov	r31, r15
    b3b2:	31 e0       	ldi	r19, 0x01	; 1
    b3b4:	8f 15       	cp	r24, r15
    b3b6:	08 f0       	brcs	.+2      	; 0xb3ba <__divdi3+0xf5c>
    b3b8:	30 e0       	ldi	r19, 0x00	; 0
    b3ba:	e3 2b       	or	r30, r19
    b3bc:	91 95       	neg	r25
    b3be:	30 2f       	mov	r19, r16
    b3c0:	41 2f       	mov	r20, r17
    b3c2:	5b 2f       	mov	r21, r27
    b3c4:	64 2d       	mov	r22, r4
    b3c6:	7a 2f       	mov	r23, r26
    b3c8:	8f 2f       	mov	r24, r31
    b3ca:	9e 1b       	sub	r25, r30
    b3cc:	c8 5b       	subi	r28, 0xB8	; 184
    b3ce:	df 4f       	sbci	r29, 0xFF	; 255
    b3d0:	e1 e1       	ldi	r30, 0x11	; 17
    b3d2:	0c 94 41 62 	jmp	0xc482	; 0xc482 <__epilogue_restores__+0x2>

0000b3d6 <__udivdi3>:
    b3d6:	a4 e3       	ldi	r26, 0x34	; 52
    b3d8:	b0 e0       	ldi	r27, 0x00	; 0
    b3da:	e1 ef       	ldi	r30, 0xF1	; 241
    b3dc:	f9 e5       	ldi	r31, 0x59	; 89
    b3de:	0c 94 28 62 	jmp	0xc450	; 0xc450 <__prologue_saves__+0x2>
    b3e2:	29 8b       	std	Y+17, r18	; 0x11
    b3e4:	3a 8b       	std	Y+18, r19	; 0x12
    b3e6:	4b 8b       	std	Y+19, r20	; 0x13
    b3e8:	5c 8b       	std	Y+20, r21	; 0x14
    b3ea:	6d 8b       	std	Y+21, r22	; 0x15
    b3ec:	7e 8b       	std	Y+22, r23	; 0x16
    b3ee:	8f 8b       	std	Y+23, r24	; 0x17
    b3f0:	98 8f       	std	Y+24, r25	; 0x18
    b3f2:	a9 86       	std	Y+9, r10	; 0x09
    b3f4:	ba 86       	std	Y+10, r11	; 0x0a
    b3f6:	cb 86       	std	Y+11, r12	; 0x0b
    b3f8:	dc 86       	std	Y+12, r13	; 0x0c
    b3fa:	ed 86       	std	Y+13, r14	; 0x0d
    b3fc:	fe 86       	std	Y+14, r15	; 0x0e
    b3fe:	0f 87       	std	Y+15, r16	; 0x0f
    b400:	18 8b       	std	Y+16, r17	; 0x10
    b402:	89 84       	ldd	r8, Y+9	; 0x09
    b404:	9a 84       	ldd	r9, Y+10	; 0x0a
    b406:	ab 84       	ldd	r10, Y+11	; 0x0b
    b408:	bc 84       	ldd	r11, Y+12	; 0x0c
    b40a:	8d 85       	ldd	r24, Y+13	; 0x0d
    b40c:	9e 85       	ldd	r25, Y+14	; 0x0e
    b40e:	af 85       	ldd	r26, Y+15	; 0x0f
    b410:	b8 89       	ldd	r27, Y+16	; 0x10
    b412:	09 89       	ldd	r16, Y+17	; 0x11
    b414:	1a 89       	ldd	r17, Y+18	; 0x12
    b416:	2b 89       	ldd	r18, Y+19	; 0x13
    b418:	3c 89       	ldd	r19, Y+20	; 0x14
    b41a:	0d a3       	lds	r16, 0x5d
    b41c:	1e a3       	lds	r17, 0x5e
    b41e:	2f a3       	lds	r18, 0x5f
    b420:	38 a7       	lds	r19, 0x78
    b422:	cd 88       	ldd	r12, Y+21	; 0x15
    b424:	de 88       	ldd	r13, Y+22	; 0x16
    b426:	ef 88       	ldd	r14, Y+23	; 0x17
    b428:	f8 8c       	ldd	r15, Y+24	; 0x18
    b42a:	00 97       	sbiw	r24, 0x00	; 0
    b42c:	a1 05       	cpc	r26, r1
    b42e:	b1 05       	cpc	r27, r1
    b430:	09 f0       	breq	.+2      	; 0xb434 <__udivdi3+0x5e>
    b432:	b5 c3       	rjmp	.+1898   	; 0xbb9e <__udivdi3+0x7c8>
    b434:	c8 14       	cp	r12, r8
    b436:	d9 04       	cpc	r13, r9
    b438:	ea 04       	cpc	r14, r10
    b43a:	fb 04       	cpc	r15, r11
    b43c:	08 f0       	brcs	.+2      	; 0xb440 <__udivdi3+0x6a>
    b43e:	4d c1       	rjmp	.+666    	; 0xb6da <__udivdi3+0x304>
    b440:	10 e0       	ldi	r17, 0x00	; 0
    b442:	81 16       	cp	r8, r17
    b444:	10 e0       	ldi	r17, 0x00	; 0
    b446:	91 06       	cpc	r9, r17
    b448:	11 e0       	ldi	r17, 0x01	; 1
    b44a:	a1 06       	cpc	r10, r17
    b44c:	10 e0       	ldi	r17, 0x00	; 0
    b44e:	b1 06       	cpc	r11, r17
    b450:	58 f4       	brcc	.+22     	; 0xb468 <__udivdi3+0x92>
    b452:	2f ef       	ldi	r18, 0xFF	; 255
    b454:	82 16       	cp	r8, r18
    b456:	91 04       	cpc	r9, r1
    b458:	a1 04       	cpc	r10, r1
    b45a:	b1 04       	cpc	r11, r1
    b45c:	09 f0       	breq	.+2      	; 0xb460 <__udivdi3+0x8a>
    b45e:	90 f4       	brcc	.+36     	; 0xb484 <__udivdi3+0xae>
    b460:	80 e0       	ldi	r24, 0x00	; 0
    b462:	90 e0       	ldi	r25, 0x00	; 0
    b464:	dc 01       	movw	r26, r24
    b466:	17 c0       	rjmp	.+46     	; 0xb496 <__udivdi3+0xc0>
    b468:	30 e0       	ldi	r19, 0x00	; 0
    b46a:	83 16       	cp	r8, r19
    b46c:	30 e0       	ldi	r19, 0x00	; 0
    b46e:	93 06       	cpc	r9, r19
    b470:	30 e0       	ldi	r19, 0x00	; 0
    b472:	a3 06       	cpc	r10, r19
    b474:	31 e0       	ldi	r19, 0x01	; 1
    b476:	b3 06       	cpc	r11, r19
    b478:	50 f4       	brcc	.+20     	; 0xb48e <__udivdi3+0xb8>
    b47a:	80 e1       	ldi	r24, 0x10	; 16
    b47c:	90 e0       	ldi	r25, 0x00	; 0
    b47e:	a0 e0       	ldi	r26, 0x00	; 0
    b480:	b0 e0       	ldi	r27, 0x00	; 0
    b482:	09 c0       	rjmp	.+18     	; 0xb496 <__udivdi3+0xc0>
    b484:	88 e0       	ldi	r24, 0x08	; 8
    b486:	90 e0       	ldi	r25, 0x00	; 0
    b488:	a0 e0       	ldi	r26, 0x00	; 0
    b48a:	b0 e0       	ldi	r27, 0x00	; 0
    b48c:	04 c0       	rjmp	.+8      	; 0xb496 <__udivdi3+0xc0>
    b48e:	88 e1       	ldi	r24, 0x18	; 24
    b490:	90 e0       	ldi	r25, 0x00	; 0
    b492:	a0 e0       	ldi	r26, 0x00	; 0
    b494:	b0 e0       	ldi	r27, 0x00	; 0
    b496:	b5 01       	movw	r22, r10
    b498:	a4 01       	movw	r20, r8
    b49a:	08 2e       	mov	r0, r24
    b49c:	04 c0       	rjmp	.+8      	; 0xb4a6 <__udivdi3+0xd0>
    b49e:	76 95       	lsr	r23
    b4a0:	67 95       	ror	r22
    b4a2:	57 95       	ror	r21
    b4a4:	47 95       	ror	r20
    b4a6:	0a 94       	dec	r0
    b4a8:	d2 f7       	brpl	.-12     	; 0xb49e <__udivdi3+0xc8>
    b4aa:	fa 01       	movw	r30, r20
    b4ac:	ea 5d       	subi	r30, 0xDA	; 218
    b4ae:	ff 4d       	sbci	r31, 0xDF	; 223
    b4b0:	20 81       	ld	r18, Z
    b4b2:	40 e2       	ldi	r20, 0x20	; 32
    b4b4:	50 e0       	ldi	r21, 0x00	; 0
    b4b6:	60 e0       	ldi	r22, 0x00	; 0
    b4b8:	70 e0       	ldi	r23, 0x00	; 0
    b4ba:	48 1b       	sub	r20, r24
    b4bc:	59 0b       	sbc	r21, r25
    b4be:	6a 0b       	sbc	r22, r26
    b4c0:	7b 0b       	sbc	r23, r27
    b4c2:	42 1b       	sub	r20, r18
    b4c4:	51 09       	sbc	r21, r1
    b4c6:	61 09       	sbc	r22, r1
    b4c8:	71 09       	sbc	r23, r1
    b4ca:	41 15       	cp	r20, r1
    b4cc:	51 05       	cpc	r21, r1
    b4ce:	61 05       	cpc	r22, r1
    b4d0:	71 05       	cpc	r23, r1
    b4d2:	a1 f1       	breq	.+104    	; 0xb53c <__udivdi3+0x166>
    b4d4:	04 2e       	mov	r0, r20
    b4d6:	04 c0       	rjmp	.+8      	; 0xb4e0 <__udivdi3+0x10a>
    b4d8:	88 0c       	add	r8, r8
    b4da:	99 1c       	adc	r9, r9
    b4dc:	aa 1c       	adc	r10, r10
    b4de:	bb 1c       	adc	r11, r11
    b4e0:	0a 94       	dec	r0
    b4e2:	d2 f7       	brpl	.-12     	; 0xb4d8 <__udivdi3+0x102>
    b4e4:	97 01       	movw	r18, r14
    b4e6:	86 01       	movw	r16, r12
    b4e8:	04 2e       	mov	r0, r20
    b4ea:	04 c0       	rjmp	.+8      	; 0xb4f4 <__udivdi3+0x11e>
    b4ec:	00 0f       	add	r16, r16
    b4ee:	11 1f       	adc	r17, r17
    b4f0:	22 1f       	adc	r18, r18
    b4f2:	33 1f       	adc	r19, r19
    b4f4:	0a 94       	dec	r0
    b4f6:	d2 f7       	brpl	.-12     	; 0xb4ec <__udivdi3+0x116>
    b4f8:	80 e2       	ldi	r24, 0x20	; 32
    b4fa:	90 e0       	ldi	r25, 0x00	; 0
    b4fc:	84 1b       	sub	r24, r20
    b4fe:	95 0b       	sbc	r25, r21
    b500:	cd a0       	lds	r28, 0x8d
    b502:	de a0       	lds	r29, 0x8e
    b504:	ef a0       	lds	r30, 0x8f
    b506:	f8 a4       	lds	r31, 0xa8
    b508:	04 c0       	rjmp	.+8      	; 0xb512 <__udivdi3+0x13c>
    b50a:	f6 94       	lsr	r15
    b50c:	e7 94       	ror	r14
    b50e:	d7 94       	ror	r13
    b510:	c7 94       	ror	r12
    b512:	8a 95       	dec	r24
    b514:	d2 f7       	brpl	.-12     	; 0xb50a <__udivdi3+0x134>
    b516:	c0 2a       	or	r12, r16
    b518:	d1 2a       	or	r13, r17
    b51a:	e2 2a       	or	r14, r18
    b51c:	f3 2a       	or	r15, r19
    b51e:	0d a1       	lds	r16, 0x4d
    b520:	1e a1       	lds	r17, 0x4e
    b522:	2f a1       	lds	r18, 0x4f
    b524:	38 a5       	lds	r19, 0x68
    b526:	04 c0       	rjmp	.+8      	; 0xb530 <__udivdi3+0x15a>
    b528:	00 0f       	add	r16, r16
    b52a:	11 1f       	adc	r17, r17
    b52c:	22 1f       	adc	r18, r18
    b52e:	33 1f       	adc	r19, r19
    b530:	4a 95       	dec	r20
    b532:	d2 f7       	brpl	.-12     	; 0xb528 <__udivdi3+0x152>
    b534:	0d a3       	lds	r16, 0x5d
    b536:	1e a3       	lds	r17, 0x5e
    b538:	2f a3       	lds	r18, 0x5f
    b53a:	38 a7       	lds	r19, 0x78
    b53c:	25 01       	movw	r4, r10
    b53e:	66 24       	eor	r6, r6
    b540:	77 24       	eor	r7, r7
    b542:	95 01       	movw	r18, r10
    b544:	84 01       	movw	r16, r8
    b546:	20 70       	andi	r18, 0x00	; 0
    b548:	30 70       	andi	r19, 0x00	; 0
    b54a:	09 a3       	lds	r16, 0x59
    b54c:	1a a3       	lds	r17, 0x5a
    b54e:	2b a3       	lds	r18, 0x5b
    b550:	3c a3       	lds	r19, 0x5c
    b552:	c7 01       	movw	r24, r14
    b554:	b6 01       	movw	r22, r12
    b556:	a3 01       	movw	r20, r6
    b558:	92 01       	movw	r18, r4
    b55a:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b55e:	2d 8f       	std	Y+29, r18	; 0x1d
    b560:	3e 8f       	std	Y+30, r19	; 0x1e
    b562:	4f 8f       	std	Y+31, r20	; 0x1f
    b564:	58 a3       	lds	r21, 0x58
    b566:	69 8f       	std	Y+25, r22	; 0x19
    b568:	7a 8f       	std	Y+26, r23	; 0x1a
    b56a:	8b 8f       	std	Y+27, r24	; 0x1b
    b56c:	9c 8f       	std	Y+28, r25	; 0x1c
    b56e:	c7 01       	movw	r24, r14
    b570:	b6 01       	movw	r22, r12
    b572:	a3 01       	movw	r20, r6
    b574:	92 01       	movw	r18, r4
    b576:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b57a:	ca 01       	movw	r24, r20
    b57c:	b9 01       	movw	r22, r18
    b57e:	29 a1       	lds	r18, 0x49
    b580:	3a a1       	lds	r19, 0x4a
    b582:	4b a1       	lds	r20, 0x4b
    b584:	5c a1       	lds	r21, 0x4c
    b586:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b58a:	ab 01       	movw	r20, r22
    b58c:	bc 01       	movw	r22, r24
    b58e:	09 8d       	ldd	r16, Y+25	; 0x19
    b590:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b592:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b594:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b596:	78 01       	movw	r14, r16
    b598:	dd 24       	eor	r13, r13
    b59a:	cc 24       	eor	r12, r12
    b59c:	0d a1       	lds	r16, 0x4d
    b59e:	1e a1       	lds	r17, 0x4e
    b5a0:	2f a1       	lds	r18, 0x4f
    b5a2:	38 a5       	lds	r19, 0x68
    b5a4:	c9 01       	movw	r24, r18
    b5a6:	aa 27       	eor	r26, r26
    b5a8:	bb 27       	eor	r27, r27
    b5aa:	c8 2a       	or	r12, r24
    b5ac:	d9 2a       	or	r13, r25
    b5ae:	ea 2a       	or	r14, r26
    b5b0:	fb 2a       	or	r15, r27
    b5b2:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b5b4:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b5b6:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b5b8:	38 a1       	lds	r19, 0x48
    b5ba:	c4 16       	cp	r12, r20
    b5bc:	d5 06       	cpc	r13, r21
    b5be:	e6 06       	cpc	r14, r22
    b5c0:	f7 06       	cpc	r15, r23
    b5c2:	38 f5       	brcc	.+78     	; 0xb612 <__udivdi3+0x23c>
    b5c4:	01 50       	subi	r16, 0x01	; 1
    b5c6:	10 40       	sbci	r17, 0x00	; 0
    b5c8:	20 40       	sbci	r18, 0x00	; 0
    b5ca:	30 40       	sbci	r19, 0x00	; 0
    b5cc:	09 8f       	std	Y+25, r16	; 0x19
    b5ce:	1a 8f       	std	Y+26, r17	; 0x1a
    b5d0:	2b 8f       	std	Y+27, r18	; 0x1b
    b5d2:	3c 8f       	std	Y+28, r19	; 0x1c
    b5d4:	c8 0c       	add	r12, r8
    b5d6:	d9 1c       	adc	r13, r9
    b5d8:	ea 1c       	adc	r14, r10
    b5da:	fb 1c       	adc	r15, r11
    b5dc:	c8 14       	cp	r12, r8
    b5de:	d9 04       	cpc	r13, r9
    b5e0:	ea 04       	cpc	r14, r10
    b5e2:	fb 04       	cpc	r15, r11
    b5e4:	d0 f0       	brcs	.+52     	; 0xb61a <__udivdi3+0x244>
    b5e6:	c4 16       	cp	r12, r20
    b5e8:	d5 06       	cpc	r13, r21
    b5ea:	e6 06       	cpc	r14, r22
    b5ec:	f7 06       	cpc	r15, r23
    b5ee:	a8 f4       	brcc	.+42     	; 0xb61a <__udivdi3+0x244>
    b5f0:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b5f2:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b5f4:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b5f6:	38 a1       	lds	r19, 0x48
    b5f8:	02 50       	subi	r16, 0x02	; 2
    b5fa:	10 40       	sbci	r17, 0x00	; 0
    b5fc:	20 40       	sbci	r18, 0x00	; 0
    b5fe:	30 40       	sbci	r19, 0x00	; 0
    b600:	09 8f       	std	Y+25, r16	; 0x19
    b602:	1a 8f       	std	Y+26, r17	; 0x1a
    b604:	2b 8f       	std	Y+27, r18	; 0x1b
    b606:	3c 8f       	std	Y+28, r19	; 0x1c
    b608:	c8 0c       	add	r12, r8
    b60a:	d9 1c       	adc	r13, r9
    b60c:	ea 1c       	adc	r14, r10
    b60e:	fb 1c       	adc	r15, r11
    b610:	04 c0       	rjmp	.+8      	; 0xb61a <__udivdi3+0x244>
    b612:	09 8f       	std	Y+25, r16	; 0x19
    b614:	1a 8f       	std	Y+26, r17	; 0x1a
    b616:	2b 8f       	std	Y+27, r18	; 0x1b
    b618:	3c 8f       	std	Y+28, r19	; 0x1c
    b61a:	c4 1a       	sub	r12, r20
    b61c:	d5 0a       	sbc	r13, r21
    b61e:	e6 0a       	sbc	r14, r22
    b620:	f7 0a       	sbc	r15, r23
    b622:	c7 01       	movw	r24, r14
    b624:	b6 01       	movw	r22, r12
    b626:	a3 01       	movw	r20, r6
    b628:	92 01       	movw	r18, r4
    b62a:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b62e:	2d 8f       	std	Y+29, r18	; 0x1d
    b630:	3e 8f       	std	Y+30, r19	; 0x1e
    b632:	4f 8f       	std	Y+31, r20	; 0x1f
    b634:	58 a3       	lds	r21, 0x58
    b636:	69 a7       	lds	r22, 0x79
    b638:	7a a7       	lds	r23, 0x7a
    b63a:	8b a7       	lds	r24, 0x7b
    b63c:	9c a7       	lds	r25, 0x7c
    b63e:	c7 01       	movw	r24, r14
    b640:	b6 01       	movw	r22, r12
    b642:	a3 01       	movw	r20, r6
    b644:	92 01       	movw	r18, r4
    b646:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b64a:	ca 01       	movw	r24, r20
    b64c:	b9 01       	movw	r22, r18
    b64e:	29 a1       	lds	r18, 0x49
    b650:	3a a1       	lds	r19, 0x4a
    b652:	4b a1       	lds	r20, 0x4b
    b654:	5c a1       	lds	r21, 0x4c
    b656:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b65a:	6b 01       	movw	r12, r22
    b65c:	7c 01       	movw	r14, r24
    b65e:	49 a5       	lds	r20, 0x69
    b660:	5a a5       	lds	r21, 0x6a
    b662:	6b a5       	lds	r22, 0x6b
    b664:	7c a5       	lds	r23, 0x6c
    b666:	9a 01       	movw	r18, r20
    b668:	11 27       	eor	r17, r17
    b66a:	00 27       	eor	r16, r16
    b66c:	4d a1       	lds	r20, 0x4d
    b66e:	5e a1       	lds	r21, 0x4e
    b670:	6f a1       	lds	r22, 0x4f
    b672:	78 a5       	lds	r23, 0x68
    b674:	60 70       	andi	r22, 0x00	; 0
    b676:	70 70       	andi	r23, 0x00	; 0
    b678:	04 2b       	or	r16, r20
    b67a:	15 2b       	or	r17, r21
    b67c:	26 2b       	or	r18, r22
    b67e:	37 2b       	or	r19, r23
    b680:	8d 8d       	ldd	r24, Y+29	; 0x1d
    b682:	9e 8d       	ldd	r25, Y+30	; 0x1e
    b684:	af 8d       	ldd	r26, Y+31	; 0x1f
    b686:	b8 a1       	lds	r27, 0x48
    b688:	0c 15       	cp	r16, r12
    b68a:	1d 05       	cpc	r17, r13
    b68c:	2e 05       	cpc	r18, r14
    b68e:	3f 05       	cpc	r19, r15
    b690:	c0 f4       	brcc	.+48     	; 0xb6c2 <__udivdi3+0x2ec>
    b692:	01 97       	sbiw	r24, 0x01	; 1
    b694:	a1 09       	sbc	r26, r1
    b696:	b1 09       	sbc	r27, r1
    b698:	08 0d       	add	r16, r8
    b69a:	19 1d       	adc	r17, r9
    b69c:	2a 1d       	adc	r18, r10
    b69e:	3b 1d       	adc	r19, r11
    b6a0:	08 15       	cp	r16, r8
    b6a2:	19 05       	cpc	r17, r9
    b6a4:	2a 05       	cpc	r18, r10
    b6a6:	3b 05       	cpc	r19, r11
    b6a8:	60 f0       	brcs	.+24     	; 0xb6c2 <__udivdi3+0x2ec>
    b6aa:	0c 15       	cp	r16, r12
    b6ac:	1d 05       	cpc	r17, r13
    b6ae:	2e 05       	cpc	r18, r14
    b6b0:	3f 05       	cpc	r19, r15
    b6b2:	38 f4       	brcc	.+14     	; 0xb6c2 <__udivdi3+0x2ec>
    b6b4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    b6b6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    b6b8:	af 8d       	ldd	r26, Y+31	; 0x1f
    b6ba:	b8 a1       	lds	r27, 0x48
    b6bc:	02 97       	sbiw	r24, 0x02	; 2
    b6be:	a1 09       	sbc	r26, r1
    b6c0:	b1 09       	sbc	r27, r1
    b6c2:	09 8d       	ldd	r16, Y+25	; 0x19
    b6c4:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b6c6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b6c8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b6ca:	78 01       	movw	r14, r16
    b6cc:	dd 24       	eor	r13, r13
    b6ce:	cc 24       	eor	r12, r12
    b6d0:	c8 2a       	or	r12, r24
    b6d2:	d9 2a       	or	r13, r25
    b6d4:	ea 2a       	or	r14, r26
    b6d6:	fb 2a       	or	r15, r27
    b6d8:	a5 c4       	rjmp	.+2378   	; 0xc024 <__udivdi3+0xc4e>
    b6da:	81 14       	cp	r8, r1
    b6dc:	91 04       	cpc	r9, r1
    b6de:	a1 04       	cpc	r10, r1
    b6e0:	b1 04       	cpc	r11, r1
    b6e2:	51 f4       	brne	.+20     	; 0xb6f8 <__udivdi3+0x322>
    b6e4:	61 e0       	ldi	r22, 0x01	; 1
    b6e6:	70 e0       	ldi	r23, 0x00	; 0
    b6e8:	80 e0       	ldi	r24, 0x00	; 0
    b6ea:	90 e0       	ldi	r25, 0x00	; 0
    b6ec:	a5 01       	movw	r20, r10
    b6ee:	94 01       	movw	r18, r8
    b6f0:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b6f4:	49 01       	movw	r8, r18
    b6f6:	5a 01       	movw	r10, r20
    b6f8:	10 e0       	ldi	r17, 0x00	; 0
    b6fa:	81 16       	cp	r8, r17
    b6fc:	10 e0       	ldi	r17, 0x00	; 0
    b6fe:	91 06       	cpc	r9, r17
    b700:	11 e0       	ldi	r17, 0x01	; 1
    b702:	a1 06       	cpc	r10, r17
    b704:	10 e0       	ldi	r17, 0x00	; 0
    b706:	b1 06       	cpc	r11, r17
    b708:	58 f4       	brcc	.+22     	; 0xb720 <__udivdi3+0x34a>
    b70a:	2f ef       	ldi	r18, 0xFF	; 255
    b70c:	82 16       	cp	r8, r18
    b70e:	91 04       	cpc	r9, r1
    b710:	a1 04       	cpc	r10, r1
    b712:	b1 04       	cpc	r11, r1
    b714:	09 f0       	breq	.+2      	; 0xb718 <__udivdi3+0x342>
    b716:	90 f4       	brcc	.+36     	; 0xb73c <__udivdi3+0x366>
    b718:	80 e0       	ldi	r24, 0x00	; 0
    b71a:	90 e0       	ldi	r25, 0x00	; 0
    b71c:	dc 01       	movw	r26, r24
    b71e:	17 c0       	rjmp	.+46     	; 0xb74e <__udivdi3+0x378>
    b720:	30 e0       	ldi	r19, 0x00	; 0
    b722:	83 16       	cp	r8, r19
    b724:	30 e0       	ldi	r19, 0x00	; 0
    b726:	93 06       	cpc	r9, r19
    b728:	30 e0       	ldi	r19, 0x00	; 0
    b72a:	a3 06       	cpc	r10, r19
    b72c:	31 e0       	ldi	r19, 0x01	; 1
    b72e:	b3 06       	cpc	r11, r19
    b730:	50 f4       	brcc	.+20     	; 0xb746 <__udivdi3+0x370>
    b732:	80 e1       	ldi	r24, 0x10	; 16
    b734:	90 e0       	ldi	r25, 0x00	; 0
    b736:	a0 e0       	ldi	r26, 0x00	; 0
    b738:	b0 e0       	ldi	r27, 0x00	; 0
    b73a:	09 c0       	rjmp	.+18     	; 0xb74e <__udivdi3+0x378>
    b73c:	88 e0       	ldi	r24, 0x08	; 8
    b73e:	90 e0       	ldi	r25, 0x00	; 0
    b740:	a0 e0       	ldi	r26, 0x00	; 0
    b742:	b0 e0       	ldi	r27, 0x00	; 0
    b744:	04 c0       	rjmp	.+8      	; 0xb74e <__udivdi3+0x378>
    b746:	88 e1       	ldi	r24, 0x18	; 24
    b748:	90 e0       	ldi	r25, 0x00	; 0
    b74a:	a0 e0       	ldi	r26, 0x00	; 0
    b74c:	b0 e0       	ldi	r27, 0x00	; 0
    b74e:	b5 01       	movw	r22, r10
    b750:	a4 01       	movw	r20, r8
    b752:	08 2e       	mov	r0, r24
    b754:	04 c0       	rjmp	.+8      	; 0xb75e <__udivdi3+0x388>
    b756:	76 95       	lsr	r23
    b758:	67 95       	ror	r22
    b75a:	57 95       	ror	r21
    b75c:	47 95       	ror	r20
    b75e:	0a 94       	dec	r0
    b760:	d2 f7       	brpl	.-12     	; 0xb756 <__udivdi3+0x380>
    b762:	fa 01       	movw	r30, r20
    b764:	ea 5d       	subi	r30, 0xDA	; 218
    b766:	ff 4d       	sbci	r31, 0xDF	; 223
    b768:	20 81       	ld	r18, Z
    b76a:	ac 01       	movw	r20, r24
    b76c:	bd 01       	movw	r22, r26
    b76e:	42 0f       	add	r20, r18
    b770:	51 1d       	adc	r21, r1
    b772:	61 1d       	adc	r22, r1
    b774:	71 1d       	adc	r23, r1
    b776:	80 e2       	ldi	r24, 0x20	; 32
    b778:	90 e0       	ldi	r25, 0x00	; 0
    b77a:	a0 e0       	ldi	r26, 0x00	; 0
    b77c:	b0 e0       	ldi	r27, 0x00	; 0
    b77e:	84 1b       	sub	r24, r20
    b780:	95 0b       	sbc	r25, r21
    b782:	a6 0b       	sbc	r26, r22
    b784:	b7 0b       	sbc	r27, r23
    b786:	51 f4       	brne	.+20     	; 0xb79c <__udivdi3+0x3c6>
    b788:	c8 18       	sub	r12, r8
    b78a:	d9 08       	sbc	r13, r9
    b78c:	ea 08       	sbc	r14, r10
    b78e:	fb 08       	sbc	r15, r11
    b790:	f1 e0       	ldi	r31, 0x01	; 1
    b792:	4f 2e       	mov	r4, r31
    b794:	51 2c       	mov	r5, r1
    b796:	61 2c       	mov	r6, r1
    b798:	71 2c       	mov	r7, r1
    b79a:	24 c1       	rjmp	.+584    	; 0xb9e4 <__udivdi3+0x60e>
    b79c:	08 2e       	mov	r0, r24
    b79e:	04 c0       	rjmp	.+8      	; 0xb7a8 <__udivdi3+0x3d2>
    b7a0:	88 0c       	add	r8, r8
    b7a2:	99 1c       	adc	r9, r9
    b7a4:	aa 1c       	adc	r10, r10
    b7a6:	bb 1c       	adc	r11, r11
    b7a8:	0a 94       	dec	r0
    b7aa:	d2 f7       	brpl	.-12     	; 0xb7a0 <__udivdi3+0x3ca>
    b7ac:	97 01       	movw	r18, r14
    b7ae:	86 01       	movw	r16, r12
    b7b0:	04 2e       	mov	r0, r20
    b7b2:	04 c0       	rjmp	.+8      	; 0xb7bc <__udivdi3+0x3e6>
    b7b4:	36 95       	lsr	r19
    b7b6:	27 95       	ror	r18
    b7b8:	17 95       	ror	r17
    b7ba:	07 95       	ror	r16
    b7bc:	0a 94       	dec	r0
    b7be:	d2 f7       	brpl	.-12     	; 0xb7b4 <__udivdi3+0x3de>
    b7c0:	09 a3       	lds	r16, 0x59
    b7c2:	1a a3       	lds	r17, 0x5a
    b7c4:	2b a3       	lds	r18, 0x5b
    b7c6:	3c a3       	lds	r19, 0x5c
    b7c8:	97 01       	movw	r18, r14
    b7ca:	86 01       	movw	r16, r12
    b7cc:	08 2e       	mov	r0, r24
    b7ce:	04 c0       	rjmp	.+8      	; 0xb7d8 <__udivdi3+0x402>
    b7d0:	00 0f       	add	r16, r16
    b7d2:	11 1f       	adc	r17, r17
    b7d4:	22 1f       	adc	r18, r18
    b7d6:	33 1f       	adc	r19, r19
    b7d8:	0a 94       	dec	r0
    b7da:	d2 f7       	brpl	.-12     	; 0xb7d0 <__udivdi3+0x3fa>
    b7dc:	0d 8f       	std	Y+29, r16	; 0x1d
    b7de:	1e 8f       	std	Y+30, r17	; 0x1e
    b7e0:	2f 8f       	std	Y+31, r18	; 0x1f
    b7e2:	38 a3       	lds	r19, 0x58
    b7e4:	0d a1       	lds	r16, 0x4d
    b7e6:	1e a1       	lds	r17, 0x4e
    b7e8:	2f a1       	lds	r18, 0x4f
    b7ea:	38 a5       	lds	r19, 0x68
    b7ec:	04 c0       	rjmp	.+8      	; 0xb7f6 <__udivdi3+0x420>
    b7ee:	36 95       	lsr	r19
    b7f0:	27 95       	ror	r18
    b7f2:	17 95       	ror	r17
    b7f4:	07 95       	ror	r16
    b7f6:	4a 95       	dec	r20
    b7f8:	d2 f7       	brpl	.-12     	; 0xb7ee <__udivdi3+0x418>
    b7fa:	b9 01       	movw	r22, r18
    b7fc:	a8 01       	movw	r20, r16
    b7fe:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b800:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b802:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b804:	38 a1       	lds	r19, 0x48
    b806:	04 2b       	or	r16, r20
    b808:	15 2b       	or	r17, r21
    b80a:	26 2b       	or	r18, r22
    b80c:	37 2b       	or	r19, r23
    b80e:	0d 8f       	std	Y+29, r16	; 0x1d
    b810:	1e 8f       	std	Y+30, r17	; 0x1e
    b812:	2f 8f       	std	Y+31, r18	; 0x1f
    b814:	38 a3       	lds	r19, 0x58
    b816:	0d a1       	lds	r16, 0x4d
    b818:	1e a1       	lds	r17, 0x4e
    b81a:	2f a1       	lds	r18, 0x4f
    b81c:	38 a5       	lds	r19, 0x68
    b81e:	04 c0       	rjmp	.+8      	; 0xb828 <__udivdi3+0x452>
    b820:	00 0f       	add	r16, r16
    b822:	11 1f       	adc	r17, r17
    b824:	22 1f       	adc	r18, r18
    b826:	33 1f       	adc	r19, r19
    b828:	8a 95       	dec	r24
    b82a:	d2 f7       	brpl	.-12     	; 0xb820 <__udivdi3+0x44a>
    b82c:	0d a3       	lds	r16, 0x5d
    b82e:	1e a3       	lds	r17, 0x5e
    b830:	2f a3       	lds	r18, 0x5f
    b832:	38 a7       	lds	r19, 0x78
    b834:	25 01       	movw	r4, r10
    b836:	66 24       	eor	r6, r6
    b838:	77 24       	eor	r7, r7
    b83a:	95 01       	movw	r18, r10
    b83c:	84 01       	movw	r16, r8
    b83e:	20 70       	andi	r18, 0x00	; 0
    b840:	30 70       	andi	r19, 0x00	; 0
    b842:	09 a7       	lds	r16, 0x79
    b844:	1a a7       	lds	r17, 0x7a
    b846:	2b a7       	lds	r18, 0x7b
    b848:	3c a7       	lds	r19, 0x7c
    b84a:	69 a1       	lds	r22, 0x49
    b84c:	7a a1       	lds	r23, 0x4a
    b84e:	8b a1       	lds	r24, 0x4b
    b850:	9c a1       	lds	r25, 0x4c
    b852:	a3 01       	movw	r20, r6
    b854:	92 01       	movw	r18, r4
    b856:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b85a:	29 8f       	std	Y+25, r18	; 0x19
    b85c:	3a 8f       	std	Y+26, r19	; 0x1a
    b85e:	4b 8f       	std	Y+27, r20	; 0x1b
    b860:	5c 8f       	std	Y+28, r21	; 0x1c
    b862:	6b 01       	movw	r12, r22
    b864:	7c 01       	movw	r14, r24
    b866:	69 a1       	lds	r22, 0x49
    b868:	7a a1       	lds	r23, 0x4a
    b86a:	8b a1       	lds	r24, 0x4b
    b86c:	9c a1       	lds	r25, 0x4c
    b86e:	a3 01       	movw	r20, r6
    b870:	92 01       	movw	r18, r4
    b872:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b876:	ca 01       	movw	r24, r20
    b878:	b9 01       	movw	r22, r18
    b87a:	29 a5       	lds	r18, 0x69
    b87c:	3a a5       	lds	r19, 0x6a
    b87e:	4b a5       	lds	r20, 0x6b
    b880:	5c a5       	lds	r21, 0x6c
    b882:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b886:	ab 01       	movw	r20, r22
    b888:	bc 01       	movw	r22, r24
    b88a:	76 01       	movw	r14, r12
    b88c:	dd 24       	eor	r13, r13
    b88e:	cc 24       	eor	r12, r12
    b890:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b892:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b894:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b896:	38 a1       	lds	r19, 0x48
    b898:	c9 01       	movw	r24, r18
    b89a:	aa 27       	eor	r26, r26
    b89c:	bb 27       	eor	r27, r27
    b89e:	c8 2a       	or	r12, r24
    b8a0:	d9 2a       	or	r13, r25
    b8a2:	ea 2a       	or	r14, r26
    b8a4:	fb 2a       	or	r15, r27
    b8a6:	09 8d       	ldd	r16, Y+25	; 0x19
    b8a8:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b8aa:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b8ac:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b8ae:	c4 16       	cp	r12, r20
    b8b0:	d5 06       	cpc	r13, r21
    b8b2:	e6 06       	cpc	r14, r22
    b8b4:	f7 06       	cpc	r15, r23
    b8b6:	38 f5       	brcc	.+78     	; 0xb906 <__udivdi3+0x530>
    b8b8:	01 50       	subi	r16, 0x01	; 1
    b8ba:	10 40       	sbci	r17, 0x00	; 0
    b8bc:	20 40       	sbci	r18, 0x00	; 0
    b8be:	30 40       	sbci	r19, 0x00	; 0
    b8c0:	09 a3       	lds	r16, 0x59
    b8c2:	1a a3       	lds	r17, 0x5a
    b8c4:	2b a3       	lds	r18, 0x5b
    b8c6:	3c a3       	lds	r19, 0x5c
    b8c8:	c8 0c       	add	r12, r8
    b8ca:	d9 1c       	adc	r13, r9
    b8cc:	ea 1c       	adc	r14, r10
    b8ce:	fb 1c       	adc	r15, r11
    b8d0:	c8 14       	cp	r12, r8
    b8d2:	d9 04       	cpc	r13, r9
    b8d4:	ea 04       	cpc	r14, r10
    b8d6:	fb 04       	cpc	r15, r11
    b8d8:	d0 f0       	brcs	.+52     	; 0xb90e <__udivdi3+0x538>
    b8da:	c4 16       	cp	r12, r20
    b8dc:	d5 06       	cpc	r13, r21
    b8de:	e6 06       	cpc	r14, r22
    b8e0:	f7 06       	cpc	r15, r23
    b8e2:	a8 f4       	brcc	.+42     	; 0xb90e <__udivdi3+0x538>
    b8e4:	09 8d       	ldd	r16, Y+25	; 0x19
    b8e6:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b8e8:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b8ea:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b8ec:	02 50       	subi	r16, 0x02	; 2
    b8ee:	10 40       	sbci	r17, 0x00	; 0
    b8f0:	20 40       	sbci	r18, 0x00	; 0
    b8f2:	30 40       	sbci	r19, 0x00	; 0
    b8f4:	09 a3       	lds	r16, 0x59
    b8f6:	1a a3       	lds	r17, 0x5a
    b8f8:	2b a3       	lds	r18, 0x5b
    b8fa:	3c a3       	lds	r19, 0x5c
    b8fc:	c8 0c       	add	r12, r8
    b8fe:	d9 1c       	adc	r13, r9
    b900:	ea 1c       	adc	r14, r10
    b902:	fb 1c       	adc	r15, r11
    b904:	04 c0       	rjmp	.+8      	; 0xb90e <__udivdi3+0x538>
    b906:	09 a3       	lds	r16, 0x59
    b908:	1a a3       	lds	r17, 0x5a
    b90a:	2b a3       	lds	r18, 0x5b
    b90c:	3c a3       	lds	r19, 0x5c
    b90e:	c4 1a       	sub	r12, r20
    b910:	d5 0a       	sbc	r13, r21
    b912:	e6 0a       	sbc	r14, r22
    b914:	f7 0a       	sbc	r15, r23
    b916:	c7 01       	movw	r24, r14
    b918:	b6 01       	movw	r22, r12
    b91a:	a3 01       	movw	r20, r6
    b91c:	92 01       	movw	r18, r4
    b91e:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b922:	29 8f       	std	Y+25, r18	; 0x19
    b924:	3a 8f       	std	Y+26, r19	; 0x1a
    b926:	4b 8f       	std	Y+27, r20	; 0x1b
    b928:	5c 8f       	std	Y+28, r21	; 0x1c
    b92a:	6d a7       	lds	r22, 0x7d
    b92c:	7e a7       	lds	r23, 0x7e
    b92e:	8f a7       	lds	r24, 0x7f
    b930:	98 ab       	sts	0x58, r25
    b932:	c7 01       	movw	r24, r14
    b934:	b6 01       	movw	r22, r12
    b936:	a3 01       	movw	r20, r6
    b938:	92 01       	movw	r18, r4
    b93a:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    b93e:	ca 01       	movw	r24, r20
    b940:	b9 01       	movw	r22, r18
    b942:	29 a5       	lds	r18, 0x69
    b944:	3a a5       	lds	r19, 0x6a
    b946:	4b a5       	lds	r20, 0x6b
    b948:	5c a5       	lds	r21, 0x6c
    b94a:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    b94e:	8b 01       	movw	r16, r22
    b950:	9c 01       	movw	r18, r24
    b952:	4d a5       	lds	r20, 0x6d
    b954:	5e a5       	lds	r21, 0x6e
    b956:	6f a5       	lds	r22, 0x6f
    b958:	78 a9       	sts	0x48, r23
    b95a:	da 01       	movw	r26, r20
    b95c:	99 27       	eor	r25, r25
    b95e:	88 27       	eor	r24, r24
    b960:	4d 8d       	ldd	r20, Y+29	; 0x1d
    b962:	5e 8d       	ldd	r21, Y+30	; 0x1e
    b964:	6f 8d       	ldd	r22, Y+31	; 0x1f
    b966:	78 a1       	lds	r23, 0x48
    b968:	60 70       	andi	r22, 0x00	; 0
    b96a:	70 70       	andi	r23, 0x00	; 0
    b96c:	84 2b       	or	r24, r20
    b96e:	95 2b       	or	r25, r21
    b970:	a6 2b       	or	r26, r22
    b972:	b7 2b       	or	r27, r23
    b974:	49 8d       	ldd	r20, Y+25	; 0x19
    b976:	5a 8d       	ldd	r21, Y+26	; 0x1a
    b978:	6b 8d       	ldd	r22, Y+27	; 0x1b
    b97a:	7c 8d       	ldd	r23, Y+28	; 0x1c
    b97c:	80 17       	cp	r24, r16
    b97e:	91 07       	cpc	r25, r17
    b980:	a2 07       	cpc	r26, r18
    b982:	b3 07       	cpc	r27, r19
    b984:	f0 f4       	brcc	.+60     	; 0xb9c2 <__udivdi3+0x5ec>
    b986:	41 50       	subi	r20, 0x01	; 1
    b988:	50 40       	sbci	r21, 0x00	; 0
    b98a:	60 40       	sbci	r22, 0x00	; 0
    b98c:	70 40       	sbci	r23, 0x00	; 0
    b98e:	88 0d       	add	r24, r8
    b990:	99 1d       	adc	r25, r9
    b992:	aa 1d       	adc	r26, r10
    b994:	bb 1d       	adc	r27, r11
    b996:	88 15       	cp	r24, r8
    b998:	99 05       	cpc	r25, r9
    b99a:	aa 05       	cpc	r26, r10
    b99c:	bb 05       	cpc	r27, r11
    b99e:	88 f0       	brcs	.+34     	; 0xb9c2 <__udivdi3+0x5ec>
    b9a0:	80 17       	cp	r24, r16
    b9a2:	91 07       	cpc	r25, r17
    b9a4:	a2 07       	cpc	r26, r18
    b9a6:	b3 07       	cpc	r27, r19
    b9a8:	60 f4       	brcc	.+24     	; 0xb9c2 <__udivdi3+0x5ec>
    b9aa:	49 8d       	ldd	r20, Y+25	; 0x19
    b9ac:	5a 8d       	ldd	r21, Y+26	; 0x1a
    b9ae:	6b 8d       	ldd	r22, Y+27	; 0x1b
    b9b0:	7c 8d       	ldd	r23, Y+28	; 0x1c
    b9b2:	42 50       	subi	r20, 0x02	; 2
    b9b4:	50 40       	sbci	r21, 0x00	; 0
    b9b6:	60 40       	sbci	r22, 0x00	; 0
    b9b8:	70 40       	sbci	r23, 0x00	; 0
    b9ba:	88 0d       	add	r24, r8
    b9bc:	99 1d       	adc	r25, r9
    b9be:	aa 1d       	adc	r26, r10
    b9c0:	bb 1d       	adc	r27, r11
    b9c2:	6c 01       	movw	r12, r24
    b9c4:	7d 01       	movw	r14, r26
    b9c6:	c0 1a       	sub	r12, r16
    b9c8:	d1 0a       	sbc	r13, r17
    b9ca:	e2 0a       	sbc	r14, r18
    b9cc:	f3 0a       	sbc	r15, r19
    b9ce:	09 a1       	lds	r16, 0x49
    b9d0:	1a a1       	lds	r17, 0x4a
    b9d2:	2b a1       	lds	r18, 0x4b
    b9d4:	3c a1       	lds	r19, 0x4c
    b9d6:	38 01       	movw	r6, r16
    b9d8:	55 24       	eor	r5, r5
    b9da:	44 24       	eor	r4, r4
    b9dc:	44 2a       	or	r4, r20
    b9de:	55 2a       	or	r5, r21
    b9e0:	66 2a       	or	r6, r22
    b9e2:	77 2a       	or	r7, r23
    b9e4:	85 01       	movw	r16, r10
    b9e6:	22 27       	eor	r18, r18
    b9e8:	33 27       	eor	r19, r19
    b9ea:	0d 8f       	std	Y+29, r16	; 0x1d
    b9ec:	1e 8f       	std	Y+30, r17	; 0x1e
    b9ee:	2f 8f       	std	Y+31, r18	; 0x1f
    b9f0:	38 a3       	lds	r19, 0x58
    b9f2:	95 01       	movw	r18, r10
    b9f4:	84 01       	movw	r16, r8
    b9f6:	20 70       	andi	r18, 0x00	; 0
    b9f8:	30 70       	andi	r19, 0x00	; 0
    b9fa:	09 a7       	lds	r16, 0x79
    b9fc:	1a a7       	lds	r17, 0x7a
    b9fe:	2b a7       	lds	r18, 0x7b
    ba00:	3c a7       	lds	r19, 0x7c
    ba02:	c7 01       	movw	r24, r14
    ba04:	b6 01       	movw	r22, r12
    ba06:	2d 8d       	ldd	r18, Y+29	; 0x1d
    ba08:	3e 8d       	ldd	r19, Y+30	; 0x1e
    ba0a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    ba0c:	58 a1       	lds	r21, 0x48
    ba0e:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    ba12:	29 8f       	std	Y+25, r18	; 0x19
    ba14:	3a 8f       	std	Y+26, r19	; 0x1a
    ba16:	4b 8f       	std	Y+27, r20	; 0x1b
    ba18:	5c 8f       	std	Y+28, r21	; 0x1c
    ba1a:	69 a3       	lds	r22, 0x59
    ba1c:	7a a3       	lds	r23, 0x5a
    ba1e:	8b a3       	lds	r24, 0x5b
    ba20:	9c a3       	lds	r25, 0x5c
    ba22:	c7 01       	movw	r24, r14
    ba24:	b6 01       	movw	r22, r12
    ba26:	2d 8d       	ldd	r18, Y+29	; 0x1d
    ba28:	3e 8d       	ldd	r19, Y+30	; 0x1e
    ba2a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    ba2c:	58 a1       	lds	r21, 0x48
    ba2e:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    ba32:	ca 01       	movw	r24, r20
    ba34:	b9 01       	movw	r22, r18
    ba36:	29 a5       	lds	r18, 0x69
    ba38:	3a a5       	lds	r19, 0x6a
    ba3a:	4b a5       	lds	r20, 0x6b
    ba3c:	5c a5       	lds	r21, 0x6c
    ba3e:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    ba42:	ab 01       	movw	r20, r22
    ba44:	bc 01       	movw	r22, r24
    ba46:	09 a1       	lds	r16, 0x49
    ba48:	1a a1       	lds	r17, 0x4a
    ba4a:	2b a1       	lds	r18, 0x4b
    ba4c:	3c a1       	lds	r19, 0x4c
    ba4e:	78 01       	movw	r14, r16
    ba50:	dd 24       	eor	r13, r13
    ba52:	cc 24       	eor	r12, r12
    ba54:	0d a1       	lds	r16, 0x4d
    ba56:	1e a1       	lds	r17, 0x4e
    ba58:	2f a1       	lds	r18, 0x4f
    ba5a:	38 a5       	lds	r19, 0x68
    ba5c:	c9 01       	movw	r24, r18
    ba5e:	aa 27       	eor	r26, r26
    ba60:	bb 27       	eor	r27, r27
    ba62:	c8 2a       	or	r12, r24
    ba64:	d9 2a       	or	r13, r25
    ba66:	ea 2a       	or	r14, r26
    ba68:	fb 2a       	or	r15, r27
    ba6a:	09 8d       	ldd	r16, Y+25	; 0x19
    ba6c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    ba6e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    ba70:	3c 8d       	ldd	r19, Y+28	; 0x1c
    ba72:	c4 16       	cp	r12, r20
    ba74:	d5 06       	cpc	r13, r21
    ba76:	e6 06       	cpc	r14, r22
    ba78:	f7 06       	cpc	r15, r23
    ba7a:	38 f5       	brcc	.+78     	; 0xbaca <__udivdi3+0x6f4>
    ba7c:	01 50       	subi	r16, 0x01	; 1
    ba7e:	10 40       	sbci	r17, 0x00	; 0
    ba80:	20 40       	sbci	r18, 0x00	; 0
    ba82:	30 40       	sbci	r19, 0x00	; 0
    ba84:	09 a3       	lds	r16, 0x59
    ba86:	1a a3       	lds	r17, 0x5a
    ba88:	2b a3       	lds	r18, 0x5b
    ba8a:	3c a3       	lds	r19, 0x5c
    ba8c:	c8 0c       	add	r12, r8
    ba8e:	d9 1c       	adc	r13, r9
    ba90:	ea 1c       	adc	r14, r10
    ba92:	fb 1c       	adc	r15, r11
    ba94:	c8 14       	cp	r12, r8
    ba96:	d9 04       	cpc	r13, r9
    ba98:	ea 04       	cpc	r14, r10
    ba9a:	fb 04       	cpc	r15, r11
    ba9c:	d0 f0       	brcs	.+52     	; 0xbad2 <__udivdi3+0x6fc>
    ba9e:	c4 16       	cp	r12, r20
    baa0:	d5 06       	cpc	r13, r21
    baa2:	e6 06       	cpc	r14, r22
    baa4:	f7 06       	cpc	r15, r23
    baa6:	a8 f4       	brcc	.+42     	; 0xbad2 <__udivdi3+0x6fc>
    baa8:	09 8d       	ldd	r16, Y+25	; 0x19
    baaa:	1a 8d       	ldd	r17, Y+26	; 0x1a
    baac:	2b 8d       	ldd	r18, Y+27	; 0x1b
    baae:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bab0:	02 50       	subi	r16, 0x02	; 2
    bab2:	10 40       	sbci	r17, 0x00	; 0
    bab4:	20 40       	sbci	r18, 0x00	; 0
    bab6:	30 40       	sbci	r19, 0x00	; 0
    bab8:	09 a3       	lds	r16, 0x59
    baba:	1a a3       	lds	r17, 0x5a
    babc:	2b a3       	lds	r18, 0x5b
    babe:	3c a3       	lds	r19, 0x5c
    bac0:	c8 0c       	add	r12, r8
    bac2:	d9 1c       	adc	r13, r9
    bac4:	ea 1c       	adc	r14, r10
    bac6:	fb 1c       	adc	r15, r11
    bac8:	04 c0       	rjmp	.+8      	; 0xbad2 <__udivdi3+0x6fc>
    baca:	09 a3       	lds	r16, 0x59
    bacc:	1a a3       	lds	r17, 0x5a
    bace:	2b a3       	lds	r18, 0x5b
    bad0:	3c a3       	lds	r19, 0x5c
    bad2:	c4 1a       	sub	r12, r20
    bad4:	d5 0a       	sbc	r13, r21
    bad6:	e6 0a       	sbc	r14, r22
    bad8:	f7 0a       	sbc	r15, r23
    bada:	c7 01       	movw	r24, r14
    badc:	b6 01       	movw	r22, r12
    bade:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bae0:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bae2:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bae4:	58 a1       	lds	r21, 0x48
    bae6:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    baea:	29 8f       	std	Y+25, r18	; 0x19
    baec:	3a 8f       	std	Y+26, r19	; 0x1a
    baee:	4b 8f       	std	Y+27, r20	; 0x1b
    baf0:	5c 8f       	std	Y+28, r21	; 0x1c
    baf2:	6d a7       	lds	r22, 0x7d
    baf4:	7e a7       	lds	r23, 0x7e
    baf6:	8f a7       	lds	r24, 0x7f
    baf8:	98 ab       	sts	0x58, r25
    bafa:	c7 01       	movw	r24, r14
    bafc:	b6 01       	movw	r22, r12
    bafe:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bb00:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bb02:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bb04:	58 a1       	lds	r21, 0x48
    bb06:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    bb0a:	ca 01       	movw	r24, r20
    bb0c:	b9 01       	movw	r22, r18
    bb0e:	29 a5       	lds	r18, 0x69
    bb10:	3a a5       	lds	r19, 0x6a
    bb12:	4b a5       	lds	r20, 0x6b
    bb14:	5c a5       	lds	r21, 0x6c
    bb16:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    bb1a:	8b 01       	movw	r16, r22
    bb1c:	9c 01       	movw	r18, r24
    bb1e:	4d a5       	lds	r20, 0x6d
    bb20:	5e a5       	lds	r21, 0x6e
    bb22:	6f a5       	lds	r22, 0x6f
    bb24:	78 a9       	sts	0x48, r23
    bb26:	da 01       	movw	r26, r20
    bb28:	99 27       	eor	r25, r25
    bb2a:	88 27       	eor	r24, r24
    bb2c:	4d a1       	lds	r20, 0x4d
    bb2e:	5e a1       	lds	r21, 0x4e
    bb30:	6f a1       	lds	r22, 0x4f
    bb32:	78 a5       	lds	r23, 0x68
    bb34:	60 70       	andi	r22, 0x00	; 0
    bb36:	70 70       	andi	r23, 0x00	; 0
    bb38:	84 2b       	or	r24, r20
    bb3a:	95 2b       	or	r25, r21
    bb3c:	a6 2b       	or	r26, r22
    bb3e:	b7 2b       	or	r27, r23
    bb40:	49 8d       	ldd	r20, Y+25	; 0x19
    bb42:	5a 8d       	ldd	r21, Y+26	; 0x1a
    bb44:	6b 8d       	ldd	r22, Y+27	; 0x1b
    bb46:	7c 8d       	ldd	r23, Y+28	; 0x1c
    bb48:	80 17       	cp	r24, r16
    bb4a:	91 07       	cpc	r25, r17
    bb4c:	a2 07       	cpc	r26, r18
    bb4e:	b3 07       	cpc	r27, r19
    bb50:	d0 f4       	brcc	.+52     	; 0xbb86 <__udivdi3+0x7b0>
    bb52:	41 50       	subi	r20, 0x01	; 1
    bb54:	50 40       	sbci	r21, 0x00	; 0
    bb56:	60 40       	sbci	r22, 0x00	; 0
    bb58:	70 40       	sbci	r23, 0x00	; 0
    bb5a:	88 0d       	add	r24, r8
    bb5c:	99 1d       	adc	r25, r9
    bb5e:	aa 1d       	adc	r26, r10
    bb60:	bb 1d       	adc	r27, r11
    bb62:	88 15       	cp	r24, r8
    bb64:	99 05       	cpc	r25, r9
    bb66:	aa 05       	cpc	r26, r10
    bb68:	bb 05       	cpc	r27, r11
    bb6a:	68 f0       	brcs	.+26     	; 0xbb86 <__udivdi3+0x7b0>
    bb6c:	80 17       	cp	r24, r16
    bb6e:	91 07       	cpc	r25, r17
    bb70:	a2 07       	cpc	r26, r18
    bb72:	b3 07       	cpc	r27, r19
    bb74:	40 f4       	brcc	.+16     	; 0xbb86 <__udivdi3+0x7b0>
    bb76:	49 8d       	ldd	r20, Y+25	; 0x19
    bb78:	5a 8d       	ldd	r21, Y+26	; 0x1a
    bb7a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    bb7c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    bb7e:	42 50       	subi	r20, 0x02	; 2
    bb80:	50 40       	sbci	r21, 0x00	; 0
    bb82:	60 40       	sbci	r22, 0x00	; 0
    bb84:	70 40       	sbci	r23, 0x00	; 0
    bb86:	09 a1       	lds	r16, 0x49
    bb88:	1a a1       	lds	r17, 0x4a
    bb8a:	2b a1       	lds	r18, 0x4b
    bb8c:	3c a1       	lds	r19, 0x4c
    bb8e:	78 01       	movw	r14, r16
    bb90:	dd 24       	eor	r13, r13
    bb92:	cc 24       	eor	r12, r12
    bb94:	c4 2a       	or	r12, r20
    bb96:	d5 2a       	or	r13, r21
    bb98:	e6 2a       	or	r14, r22
    bb9a:	f7 2a       	or	r15, r23
    bb9c:	46 c2       	rjmp	.+1164   	; 0xc02a <__udivdi3+0xc54>
    bb9e:	c8 16       	cp	r12, r24
    bba0:	d9 06       	cpc	r13, r25
    bba2:	ea 06       	cpc	r14, r26
    bba4:	fb 06       	cpc	r15, r27
    bba6:	08 f4       	brcc	.+2      	; 0xbbaa <__udivdi3+0x7d4>
    bba8:	2d c2       	rjmp	.+1114   	; 0xc004 <__udivdi3+0xc2e>
    bbaa:	80 30       	cpi	r24, 0x00	; 0
    bbac:	10 e0       	ldi	r17, 0x00	; 0
    bbae:	91 07       	cpc	r25, r17
    bbb0:	11 e0       	ldi	r17, 0x01	; 1
    bbb2:	a1 07       	cpc	r26, r17
    bbb4:	10 e0       	ldi	r17, 0x00	; 0
    bbb6:	b1 07       	cpc	r27, r17
    bbb8:	50 f4       	brcc	.+20     	; 0xbbce <__udivdi3+0x7f8>
    bbba:	8f 3f       	cpi	r24, 0xFF	; 255
    bbbc:	91 05       	cpc	r25, r1
    bbbe:	a1 05       	cpc	r26, r1
    bbc0:	b1 05       	cpc	r27, r1
    bbc2:	09 f0       	breq	.+2      	; 0xbbc6 <__udivdi3+0x7f0>
    bbc4:	88 f4       	brcc	.+34     	; 0xbbe8 <__udivdi3+0x812>
    bbc6:	00 e0       	ldi	r16, 0x00	; 0
    bbc8:	10 e0       	ldi	r17, 0x00	; 0
    bbca:	98 01       	movw	r18, r16
    bbcc:	16 c0       	rjmp	.+44     	; 0xbbfa <__udivdi3+0x824>
    bbce:	80 30       	cpi	r24, 0x00	; 0
    bbd0:	20 e0       	ldi	r18, 0x00	; 0
    bbd2:	92 07       	cpc	r25, r18
    bbd4:	20 e0       	ldi	r18, 0x00	; 0
    bbd6:	a2 07       	cpc	r26, r18
    bbd8:	21 e0       	ldi	r18, 0x01	; 1
    bbda:	b2 07       	cpc	r27, r18
    bbdc:	50 f4       	brcc	.+20     	; 0xbbf2 <__udivdi3+0x81c>
    bbde:	00 e1       	ldi	r16, 0x10	; 16
    bbe0:	10 e0       	ldi	r17, 0x00	; 0
    bbe2:	20 e0       	ldi	r18, 0x00	; 0
    bbe4:	30 e0       	ldi	r19, 0x00	; 0
    bbe6:	09 c0       	rjmp	.+18     	; 0xbbfa <__udivdi3+0x824>
    bbe8:	08 e0       	ldi	r16, 0x08	; 8
    bbea:	10 e0       	ldi	r17, 0x00	; 0
    bbec:	20 e0       	ldi	r18, 0x00	; 0
    bbee:	30 e0       	ldi	r19, 0x00	; 0
    bbf0:	04 c0       	rjmp	.+8      	; 0xbbfa <__udivdi3+0x824>
    bbf2:	08 e1       	ldi	r16, 0x18	; 24
    bbf4:	10 e0       	ldi	r17, 0x00	; 0
    bbf6:	20 e0       	ldi	r18, 0x00	; 0
    bbf8:	30 e0       	ldi	r19, 0x00	; 0
    bbfa:	ac 01       	movw	r20, r24
    bbfc:	bd 01       	movw	r22, r26
    bbfe:	00 2e       	mov	r0, r16
    bc00:	04 c0       	rjmp	.+8      	; 0xbc0a <__udivdi3+0x834>
    bc02:	76 95       	lsr	r23
    bc04:	67 95       	ror	r22
    bc06:	57 95       	ror	r21
    bc08:	47 95       	ror	r20
    bc0a:	0a 94       	dec	r0
    bc0c:	d2 f7       	brpl	.-12     	; 0xbc02 <__udivdi3+0x82c>
    bc0e:	fa 01       	movw	r30, r20
    bc10:	ea 5d       	subi	r30, 0xDA	; 218
    bc12:	ff 4d       	sbci	r31, 0xDF	; 223
    bc14:	40 81       	ld	r20, Z
    bc16:	04 0f       	add	r16, r20
    bc18:	11 1d       	adc	r17, r1
    bc1a:	21 1d       	adc	r18, r1
    bc1c:	31 1d       	adc	r19, r1
    bc1e:	40 e2       	ldi	r20, 0x20	; 32
    bc20:	50 e0       	ldi	r21, 0x00	; 0
    bc22:	60 e0       	ldi	r22, 0x00	; 0
    bc24:	70 e0       	ldi	r23, 0x00	; 0
    bc26:	40 1b       	sub	r20, r16
    bc28:	51 0b       	sbc	r21, r17
    bc2a:	62 0b       	sbc	r22, r18
    bc2c:	73 0b       	sbc	r23, r19
    bc2e:	a1 f4       	brne	.+40     	; 0xbc58 <__udivdi3+0x882>
    bc30:	8c 15       	cp	r24, r12
    bc32:	9d 05       	cpc	r25, r13
    bc34:	ae 05       	cpc	r26, r14
    bc36:	bf 05       	cpc	r27, r15
    bc38:	08 f4       	brcc	.+2      	; 0xbc3c <__udivdi3+0x866>
    bc3a:	eb c1       	rjmp	.+982    	; 0xc012 <__udivdi3+0xc3c>
    bc3c:	0d a1       	lds	r16, 0x4d
    bc3e:	1e a1       	lds	r17, 0x4e
    bc40:	2f a1       	lds	r18, 0x4f
    bc42:	38 a5       	lds	r19, 0x68
    bc44:	44 24       	eor	r4, r4
    bc46:	55 24       	eor	r5, r5
    bc48:	32 01       	movw	r6, r4
    bc4a:	08 15       	cp	r16, r8
    bc4c:	19 05       	cpc	r17, r9
    bc4e:	2a 05       	cpc	r18, r10
    bc50:	3b 05       	cpc	r19, r11
    bc52:	08 f0       	brcs	.+2      	; 0xbc56 <__udivdi3+0x880>
    bc54:	e1 c1       	rjmp	.+962    	; 0xc018 <__udivdi3+0xc42>
    bc56:	d9 c1       	rjmp	.+946    	; 0xc00a <__udivdi3+0xc34>
    bc58:	34 2e       	mov	r3, r20
    bc5a:	2c 01       	movw	r4, r24
    bc5c:	3d 01       	movw	r6, r26
    bc5e:	04 c0       	rjmp	.+8      	; 0xbc68 <__udivdi3+0x892>
    bc60:	44 0c       	add	r4, r4
    bc62:	55 1c       	adc	r5, r5
    bc64:	66 1c       	adc	r6, r6
    bc66:	77 1c       	adc	r7, r7
    bc68:	4a 95       	dec	r20
    bc6a:	d2 f7       	brpl	.-12     	; 0xbc60 <__udivdi3+0x88a>
    bc6c:	d5 01       	movw	r26, r10
    bc6e:	c4 01       	movw	r24, r8
    bc70:	00 2e       	mov	r0, r16
    bc72:	04 c0       	rjmp	.+8      	; 0xbc7c <__udivdi3+0x8a6>
    bc74:	b6 95       	lsr	r27
    bc76:	a7 95       	ror	r26
    bc78:	97 95       	ror	r25
    bc7a:	87 95       	ror	r24
    bc7c:	0a 94       	dec	r0
    bc7e:	d2 f7       	brpl	.-12     	; 0xbc74 <__udivdi3+0x89e>
    bc80:	48 2a       	or	r4, r24
    bc82:	59 2a       	or	r5, r25
    bc84:	6a 2a       	or	r6, r26
    bc86:	7b 2a       	or	r7, r27
    bc88:	a5 01       	movw	r20, r10
    bc8a:	94 01       	movw	r18, r8
    bc8c:	03 2c       	mov	r0, r3
    bc8e:	04 c0       	rjmp	.+8      	; 0xbc98 <__udivdi3+0x8c2>
    bc90:	22 0f       	add	r18, r18
    bc92:	33 1f       	adc	r19, r19
    bc94:	44 1f       	adc	r20, r20
    bc96:	55 1f       	adc	r21, r21
    bc98:	0a 94       	dec	r0
    bc9a:	d2 f7       	brpl	.-12     	; 0xbc90 <__udivdi3+0x8ba>
    bc9c:	29 a7       	lds	r18, 0x79
    bc9e:	3a a7       	lds	r19, 0x7a
    bca0:	4b a7       	lds	r20, 0x7b
    bca2:	5c a7       	lds	r21, 0x7c
    bca4:	b7 01       	movw	r22, r14
    bca6:	a6 01       	movw	r20, r12
    bca8:	00 2e       	mov	r0, r16
    bcaa:	04 c0       	rjmp	.+8      	; 0xbcb4 <__udivdi3+0x8de>
    bcac:	76 95       	lsr	r23
    bcae:	67 95       	ror	r22
    bcb0:	57 95       	ror	r21
    bcb2:	47 95       	ror	r20
    bcb4:	0a 94       	dec	r0
    bcb6:	d2 f7       	brpl	.-12     	; 0xbcac <__udivdi3+0x8d6>
    bcb8:	49 a3       	lds	r20, 0x59
    bcba:	5a a3       	lds	r21, 0x5a
    bcbc:	6b a3       	lds	r22, 0x5b
    bcbe:	7c a3       	lds	r23, 0x5c
    bcc0:	c7 01       	movw	r24, r14
    bcc2:	b6 01       	movw	r22, r12
    bcc4:	03 2c       	mov	r0, r3
    bcc6:	04 c0       	rjmp	.+8      	; 0xbcd0 <__udivdi3+0x8fa>
    bcc8:	66 0f       	add	r22, r22
    bcca:	77 1f       	adc	r23, r23
    bccc:	88 1f       	adc	r24, r24
    bcce:	99 1f       	adc	r25, r25
    bcd0:	0a 94       	dec	r0
    bcd2:	d2 f7       	brpl	.-12     	; 0xbcc8 <__udivdi3+0x8f2>
    bcd4:	6d 8f       	std	Y+29, r22	; 0x1d
    bcd6:	7e 8f       	std	Y+30, r23	; 0x1e
    bcd8:	8f 8f       	std	Y+31, r24	; 0x1f
    bcda:	98 a3       	lds	r25, 0x58
    bcdc:	8d a1       	lds	r24, 0x4d
    bcde:	9e a1       	lds	r25, 0x4e
    bce0:	af a1       	lds	r26, 0x4f
    bce2:	b8 a5       	lds	r27, 0x68
    bce4:	04 c0       	rjmp	.+8      	; 0xbcee <__udivdi3+0x918>
    bce6:	b6 95       	lsr	r27
    bce8:	a7 95       	ror	r26
    bcea:	97 95       	ror	r25
    bcec:	87 95       	ror	r24
    bcee:	0a 95       	dec	r16
    bcf0:	d2 f7       	brpl	.-12     	; 0xbce6 <__udivdi3+0x910>
    bcf2:	4d 8d       	ldd	r20, Y+29	; 0x1d
    bcf4:	5e 8d       	ldd	r21, Y+30	; 0x1e
    bcf6:	6f 8d       	ldd	r22, Y+31	; 0x1f
    bcf8:	78 a1       	lds	r23, 0x48
    bcfa:	48 2b       	or	r20, r24
    bcfc:	59 2b       	or	r21, r25
    bcfe:	6a 2b       	or	r22, r26
    bd00:	7b 2b       	or	r23, r27
    bd02:	4d 8f       	std	Y+29, r20	; 0x1d
    bd04:	5e 8f       	std	Y+30, r21	; 0x1e
    bd06:	6f 8f       	std	Y+31, r22	; 0x1f
    bd08:	78 a3       	lds	r23, 0x58
    bd0a:	43 01       	movw	r8, r6
    bd0c:	aa 24       	eor	r10, r10
    bd0e:	bb 24       	eor	r11, r11
    bd10:	93 01       	movw	r18, r6
    bd12:	82 01       	movw	r16, r4
    bd14:	20 70       	andi	r18, 0x00	; 0
    bd16:	30 70       	andi	r19, 0x00	; 0
    bd18:	0d a7       	lds	r16, 0x7d
    bd1a:	1e a7       	lds	r17, 0x7e
    bd1c:	2f a7       	lds	r18, 0x7f
    bd1e:	38 ab       	sts	0x58, r19
    bd20:	69 a1       	lds	r22, 0x49
    bd22:	7a a1       	lds	r23, 0x4a
    bd24:	8b a1       	lds	r24, 0x4b
    bd26:	9c a1       	lds	r25, 0x4c
    bd28:	a5 01       	movw	r20, r10
    bd2a:	94 01       	movw	r18, r8
    bd2c:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    bd30:	29 8f       	std	Y+25, r18	; 0x19
    bd32:	3a 8f       	std	Y+26, r19	; 0x1a
    bd34:	4b 8f       	std	Y+27, r20	; 0x1b
    bd36:	5c 8f       	std	Y+28, r21	; 0x1c
    bd38:	6b 01       	movw	r12, r22
    bd3a:	7c 01       	movw	r14, r24
    bd3c:	69 a1       	lds	r22, 0x49
    bd3e:	7a a1       	lds	r23, 0x4a
    bd40:	8b a1       	lds	r24, 0x4b
    bd42:	9c a1       	lds	r25, 0x4c
    bd44:	a5 01       	movw	r20, r10
    bd46:	94 01       	movw	r18, r8
    bd48:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    bd4c:	ca 01       	movw	r24, r20
    bd4e:	b9 01       	movw	r22, r18
    bd50:	2d a5       	lds	r18, 0x6d
    bd52:	3e a5       	lds	r19, 0x6e
    bd54:	4f a5       	lds	r20, 0x6f
    bd56:	58 a9       	sts	0x48, r21
    bd58:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    bd5c:	dc 01       	movw	r26, r24
    bd5e:	cb 01       	movw	r24, r22
    bd60:	76 01       	movw	r14, r12
    bd62:	dd 24       	eor	r13, r13
    bd64:	cc 24       	eor	r12, r12
    bd66:	0d 8d       	ldd	r16, Y+29	; 0x1d
    bd68:	1e 8d       	ldd	r17, Y+30	; 0x1e
    bd6a:	2f 8d       	ldd	r18, Y+31	; 0x1f
    bd6c:	38 a1       	lds	r19, 0x48
    bd6e:	a9 01       	movw	r20, r18
    bd70:	66 27       	eor	r22, r22
    bd72:	77 27       	eor	r23, r23
    bd74:	c4 2a       	or	r12, r20
    bd76:	d5 2a       	or	r13, r21
    bd78:	e6 2a       	or	r14, r22
    bd7a:	f7 2a       	or	r15, r23
    bd7c:	09 8d       	ldd	r16, Y+25	; 0x19
    bd7e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bd80:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bd82:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bd84:	c8 16       	cp	r12, r24
    bd86:	d9 06       	cpc	r13, r25
    bd88:	ea 06       	cpc	r14, r26
    bd8a:	fb 06       	cpc	r15, r27
    bd8c:	38 f5       	brcc	.+78     	; 0xbddc <__udivdi3+0xa06>
    bd8e:	01 50       	subi	r16, 0x01	; 1
    bd90:	10 40       	sbci	r17, 0x00	; 0
    bd92:	20 40       	sbci	r18, 0x00	; 0
    bd94:	30 40       	sbci	r19, 0x00	; 0
    bd96:	09 a3       	lds	r16, 0x59
    bd98:	1a a3       	lds	r17, 0x5a
    bd9a:	2b a3       	lds	r18, 0x5b
    bd9c:	3c a3       	lds	r19, 0x5c
    bd9e:	c4 0c       	add	r12, r4
    bda0:	d5 1c       	adc	r13, r5
    bda2:	e6 1c       	adc	r14, r6
    bda4:	f7 1c       	adc	r15, r7
    bda6:	c4 14       	cp	r12, r4
    bda8:	d5 04       	cpc	r13, r5
    bdaa:	e6 04       	cpc	r14, r6
    bdac:	f7 04       	cpc	r15, r7
    bdae:	d0 f0       	brcs	.+52     	; 0xbde4 <__udivdi3+0xa0e>
    bdb0:	c8 16       	cp	r12, r24
    bdb2:	d9 06       	cpc	r13, r25
    bdb4:	ea 06       	cpc	r14, r26
    bdb6:	fb 06       	cpc	r15, r27
    bdb8:	a8 f4       	brcc	.+42     	; 0xbde4 <__udivdi3+0xa0e>
    bdba:	09 8d       	ldd	r16, Y+25	; 0x19
    bdbc:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bdbe:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bdc0:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bdc2:	02 50       	subi	r16, 0x02	; 2
    bdc4:	10 40       	sbci	r17, 0x00	; 0
    bdc6:	20 40       	sbci	r18, 0x00	; 0
    bdc8:	30 40       	sbci	r19, 0x00	; 0
    bdca:	09 a3       	lds	r16, 0x59
    bdcc:	1a a3       	lds	r17, 0x5a
    bdce:	2b a3       	lds	r18, 0x5b
    bdd0:	3c a3       	lds	r19, 0x5c
    bdd2:	c4 0c       	add	r12, r4
    bdd4:	d5 1c       	adc	r13, r5
    bdd6:	e6 1c       	adc	r14, r6
    bdd8:	f7 1c       	adc	r15, r7
    bdda:	04 c0       	rjmp	.+8      	; 0xbde4 <__udivdi3+0xa0e>
    bddc:	09 a3       	lds	r16, 0x59
    bdde:	1a a3       	lds	r17, 0x5a
    bde0:	2b a3       	lds	r18, 0x5b
    bde2:	3c a3       	lds	r19, 0x5c
    bde4:	c8 1a       	sub	r12, r24
    bde6:	d9 0a       	sbc	r13, r25
    bde8:	ea 0a       	sbc	r14, r26
    bdea:	fb 0a       	sbc	r15, r27
    bdec:	c7 01       	movw	r24, r14
    bdee:	b6 01       	movw	r22, r12
    bdf0:	a5 01       	movw	r20, r10
    bdf2:	94 01       	movw	r18, r8
    bdf4:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    bdf8:	29 8f       	std	Y+25, r18	; 0x19
    bdfa:	3a 8f       	std	Y+26, r19	; 0x1a
    bdfc:	4b 8f       	std	Y+27, r20	; 0x1b
    bdfe:	5c 8f       	std	Y+28, r21	; 0x1c
    be00:	69 ab       	sts	0x59, r22
    be02:	7a ab       	sts	0x5a, r23
    be04:	8b ab       	sts	0x5b, r24
    be06:	9c ab       	sts	0x5c, r25
    be08:	c7 01       	movw	r24, r14
    be0a:	b6 01       	movw	r22, r12
    be0c:	a5 01       	movw	r20, r10
    be0e:	94 01       	movw	r18, r8
    be10:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <__udivmodsi4>
    be14:	ca 01       	movw	r24, r20
    be16:	b9 01       	movw	r22, r18
    be18:	2d a5       	lds	r18, 0x6d
    be1a:	3e a5       	lds	r19, 0x6e
    be1c:	4f a5       	lds	r20, 0x6f
    be1e:	58 a9       	sts	0x48, r21
    be20:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    be24:	4b 01       	movw	r8, r22
    be26:	5c 01       	movw	r10, r24
    be28:	49 a9       	sts	0x49, r20
    be2a:	5a a9       	sts	0x4a, r21
    be2c:	6b a9       	sts	0x4b, r22
    be2e:	7c a9       	sts	0x4c, r23
    be30:	9a 01       	movw	r18, r20
    be32:	11 27       	eor	r17, r17
    be34:	00 27       	eor	r16, r16
    be36:	8d 8d       	ldd	r24, Y+29	; 0x1d
    be38:	9e 8d       	ldd	r25, Y+30	; 0x1e
    be3a:	af 8d       	ldd	r26, Y+31	; 0x1f
    be3c:	b8 a1       	lds	r27, 0x48
    be3e:	a0 70       	andi	r26, 0x00	; 0
    be40:	b0 70       	andi	r27, 0x00	; 0
    be42:	08 2b       	or	r16, r24
    be44:	19 2b       	or	r17, r25
    be46:	2a 2b       	or	r18, r26
    be48:	3b 2b       	or	r19, r27
    be4a:	89 8d       	ldd	r24, Y+25	; 0x19
    be4c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    be4e:	ab 8d       	ldd	r26, Y+27	; 0x1b
    be50:	bc 8d       	ldd	r27, Y+28	; 0x1c
    be52:	08 15       	cp	r16, r8
    be54:	19 05       	cpc	r17, r9
    be56:	2a 05       	cpc	r18, r10
    be58:	3b 05       	cpc	r19, r11
    be5a:	e0 f4       	brcc	.+56     	; 0xbe94 <__udivdi3+0xabe>
    be5c:	01 97       	sbiw	r24, 0x01	; 1
    be5e:	a1 09       	sbc	r26, r1
    be60:	b1 09       	sbc	r27, r1
    be62:	04 0d       	add	r16, r4
    be64:	15 1d       	adc	r17, r5
    be66:	26 1d       	adc	r18, r6
    be68:	37 1d       	adc	r19, r7
    be6a:	04 15       	cp	r16, r4
    be6c:	15 05       	cpc	r17, r5
    be6e:	26 05       	cpc	r18, r6
    be70:	37 05       	cpc	r19, r7
    be72:	80 f0       	brcs	.+32     	; 0xbe94 <__udivdi3+0xabe>
    be74:	08 15       	cp	r16, r8
    be76:	19 05       	cpc	r17, r9
    be78:	2a 05       	cpc	r18, r10
    be7a:	3b 05       	cpc	r19, r11
    be7c:	58 f4       	brcc	.+22     	; 0xbe94 <__udivdi3+0xabe>
    be7e:	89 8d       	ldd	r24, Y+25	; 0x19
    be80:	9a 8d       	ldd	r25, Y+26	; 0x1a
    be82:	ab 8d       	ldd	r26, Y+27	; 0x1b
    be84:	bc 8d       	ldd	r27, Y+28	; 0x1c
    be86:	02 97       	sbiw	r24, 0x02	; 2
    be88:	a1 09       	sbc	r26, r1
    be8a:	b1 09       	sbc	r27, r1
    be8c:	04 0d       	add	r16, r4
    be8e:	15 1d       	adc	r17, r5
    be90:	26 1d       	adc	r18, r6
    be92:	37 1d       	adc	r19, r7
    be94:	b9 01       	movw	r22, r18
    be96:	a8 01       	movw	r20, r16
    be98:	48 19       	sub	r20, r8
    be9a:	59 09       	sbc	r21, r9
    be9c:	6a 09       	sbc	r22, r10
    be9e:	7b 09       	sbc	r23, r11
    bea0:	4d 8f       	std	Y+29, r20	; 0x1d
    bea2:	5e 8f       	std	Y+30, r21	; 0x1e
    bea4:	6f 8f       	std	Y+31, r22	; 0x1f
    bea6:	78 a3       	lds	r23, 0x58
    bea8:	09 a1       	lds	r16, 0x49
    beaa:	1a a1       	lds	r17, 0x4a
    beac:	2b a1       	lds	r18, 0x4b
    beae:	3c a1       	lds	r19, 0x4c
    beb0:	78 01       	movw	r14, r16
    beb2:	dd 24       	eor	r13, r13
    beb4:	cc 24       	eor	r12, r12
    beb6:	c8 2a       	or	r12, r24
    beb8:	d9 2a       	or	r13, r25
    beba:	ea 2a       	or	r14, r26
    bebc:	fb 2a       	or	r15, r27
    bebe:	ff ef       	ldi	r31, 0xFF	; 255
    bec0:	8f 2e       	mov	r8, r31
    bec2:	ff ef       	ldi	r31, 0xFF	; 255
    bec4:	9f 2e       	mov	r9, r31
    bec6:	a1 2c       	mov	r10, r1
    bec8:	b1 2c       	mov	r11, r1
    beca:	8c 20       	and	r8, r12
    becc:	9d 20       	and	r9, r13
    bece:	ae 20       	and	r10, r14
    bed0:	bf 20       	and	r11, r15
    bed2:	87 01       	movw	r16, r14
    bed4:	22 27       	eor	r18, r18
    bed6:	33 27       	eor	r19, r19
    bed8:	09 8f       	std	Y+25, r16	; 0x19
    beda:	1a 8f       	std	Y+26, r17	; 0x1a
    bedc:	2b 8f       	std	Y+27, r18	; 0x1b
    bede:	3c 8f       	std	Y+28, r19	; 0x1c
    bee0:	49 a4       	lds	r20, 0xa9
    bee2:	5a a4       	lds	r21, 0xaa
    bee4:	6b a4       	lds	r22, 0xab
    bee6:	7c a4       	lds	r23, 0xac
    bee8:	2f ef       	ldi	r18, 0xFF	; 255
    beea:	3f ef       	ldi	r19, 0xFF	; 255
    beec:	40 e0       	ldi	r20, 0x00	; 0
    beee:	50 e0       	ldi	r21, 0x00	; 0
    bef0:	42 22       	and	r4, r18
    bef2:	53 22       	and	r5, r19
    bef4:	64 22       	and	r6, r20
    bef6:	75 22       	and	r7, r21
    bef8:	29 a5       	lds	r18, 0x69
    befa:	3a a5       	lds	r19, 0x6a
    befc:	4b a5       	lds	r20, 0x6b
    befe:	5c a5       	lds	r21, 0x6c
    bf00:	8a 01       	movw	r16, r20
    bf02:	22 27       	eor	r18, r18
    bf04:	33 27       	eor	r19, r19
    bf06:	09 a3       	lds	r16, 0x59
    bf08:	1a a3       	lds	r17, 0x5a
    bf0a:	2b a3       	lds	r18, 0x5b
    bf0c:	3c a3       	lds	r19, 0x5c
    bf0e:	c5 01       	movw	r24, r10
    bf10:	b4 01       	movw	r22, r8
    bf12:	a3 01       	movw	r20, r6
    bf14:	92 01       	movw	r18, r4
    bf16:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    bf1a:	69 a7       	lds	r22, 0x79
    bf1c:	7a a7       	lds	r23, 0x7a
    bf1e:	8b a7       	lds	r24, 0x7b
    bf20:	9c a7       	lds	r25, 0x7c
    bf22:	c5 01       	movw	r24, r10
    bf24:	b4 01       	movw	r22, r8
    bf26:	29 a1       	lds	r18, 0x49
    bf28:	3a a1       	lds	r19, 0x4a
    bf2a:	4b a1       	lds	r20, 0x4b
    bf2c:	5c a1       	lds	r21, 0x4c
    bf2e:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    bf32:	4b 01       	movw	r8, r22
    bf34:	5c 01       	movw	r10, r24
    bf36:	69 8d       	ldd	r22, Y+25	; 0x19
    bf38:	7a 8d       	ldd	r23, Y+26	; 0x1a
    bf3a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    bf3c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    bf3e:	a3 01       	movw	r20, r6
    bf40:	92 01       	movw	r18, r4
    bf42:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    bf46:	2b 01       	movw	r4, r22
    bf48:	3c 01       	movw	r6, r24
    bf4a:	69 8d       	ldd	r22, Y+25	; 0x19
    bf4c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    bf4e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    bf50:	9c 8d       	ldd	r25, Y+28	; 0x1c
    bf52:	29 a1       	lds	r18, 0x49
    bf54:	3a a1       	lds	r19, 0x4a
    bf56:	4b a1       	lds	r20, 0x4b
    bf58:	5c a1       	lds	r21, 0x4c
    bf5a:	0e 94 a4 61 	call	0xc348	; 0xc348 <__mulsi3>
    bf5e:	ab 01       	movw	r20, r22
    bf60:	bc 01       	movw	r22, r24
    bf62:	84 0c       	add	r8, r4
    bf64:	95 1c       	adc	r9, r5
    bf66:	a6 1c       	adc	r10, r6
    bf68:	b7 1c       	adc	r11, r7
    bf6a:	09 a5       	lds	r16, 0x69
    bf6c:	1a a5       	lds	r17, 0x6a
    bf6e:	2b a5       	lds	r18, 0x6b
    bf70:	3c a5       	lds	r19, 0x6c
    bf72:	c9 01       	movw	r24, r18
    bf74:	aa 27       	eor	r26, r26
    bf76:	bb 27       	eor	r27, r27
    bf78:	88 0e       	add	r8, r24
    bf7a:	99 1e       	adc	r9, r25
    bf7c:	aa 1e       	adc	r10, r26
    bf7e:	bb 1e       	adc	r11, r27
    bf80:	84 14       	cp	r8, r4
    bf82:	95 04       	cpc	r9, r5
    bf84:	a6 04       	cpc	r10, r6
    bf86:	b7 04       	cpc	r11, r7
    bf88:	20 f4       	brcc	.+8      	; 0xbf92 <__udivdi3+0xbbc>
    bf8a:	40 50       	subi	r20, 0x00	; 0
    bf8c:	50 40       	sbci	r21, 0x00	; 0
    bf8e:	6f 4f       	sbci	r22, 0xFF	; 255
    bf90:	7f 4f       	sbci	r23, 0xFF	; 255
    bf92:	c5 01       	movw	r24, r10
    bf94:	aa 27       	eor	r26, r26
    bf96:	bb 27       	eor	r27, r27
    bf98:	84 0f       	add	r24, r20
    bf9a:	95 1f       	adc	r25, r21
    bf9c:	a6 1f       	adc	r26, r22
    bf9e:	b7 1f       	adc	r27, r23
    bfa0:	0d 8d       	ldd	r16, Y+29	; 0x1d
    bfa2:	1e 8d       	ldd	r17, Y+30	; 0x1e
    bfa4:	2f 8d       	ldd	r18, Y+31	; 0x1f
    bfa6:	38 a1       	lds	r19, 0x48
    bfa8:	08 17       	cp	r16, r24
    bfaa:	19 07       	cpc	r17, r25
    bfac:	2a 07       	cpc	r18, r26
    bfae:	3b 07       	cpc	r19, r27
    bfb0:	18 f1       	brcs	.+70     	; 0xbff8 <__udivdi3+0xc22>
    bfb2:	80 17       	cp	r24, r16
    bfb4:	91 07       	cpc	r25, r17
    bfb6:	a2 07       	cpc	r26, r18
    bfb8:	b3 07       	cpc	r27, r19
    bfba:	a1 f5       	brne	.+104    	; 0xc024 <__udivdi3+0xc4e>
    bfbc:	54 01       	movw	r10, r8
    bfbe:	99 24       	eor	r9, r9
    bfc0:	88 24       	eor	r8, r8
    bfc2:	89 a5       	lds	r24, 0x69
    bfc4:	9a a5       	lds	r25, 0x6a
    bfc6:	ab a5       	lds	r26, 0x6b
    bfc8:	bc a5       	lds	r27, 0x6c
    bfca:	a0 70       	andi	r26, 0x00	; 0
    bfcc:	b0 70       	andi	r27, 0x00	; 0
    bfce:	88 0e       	add	r8, r24
    bfd0:	99 1e       	adc	r9, r25
    bfd2:	aa 1e       	adc	r10, r26
    bfd4:	bb 1e       	adc	r11, r27
    bfd6:	4d a1       	lds	r20, 0x4d
    bfd8:	5e a1       	lds	r21, 0x4e
    bfda:	6f a1       	lds	r22, 0x4f
    bfdc:	78 a5       	lds	r23, 0x68
    bfde:	03 2c       	mov	r0, r3
    bfe0:	04 c0       	rjmp	.+8      	; 0xbfea <__udivdi3+0xc14>
    bfe2:	44 0f       	add	r20, r20
    bfe4:	55 1f       	adc	r21, r21
    bfe6:	66 1f       	adc	r22, r22
    bfe8:	77 1f       	adc	r23, r23
    bfea:	0a 94       	dec	r0
    bfec:	d2 f7       	brpl	.-12     	; 0xbfe2 <__udivdi3+0xc0c>
    bfee:	48 15       	cp	r20, r8
    bff0:	59 05       	cpc	r21, r9
    bff2:	6a 05       	cpc	r22, r10
    bff4:	7b 05       	cpc	r23, r11
    bff6:	b0 f4       	brcc	.+44     	; 0xc024 <__udivdi3+0xc4e>
    bff8:	08 94       	sec
    bffa:	c1 08       	sbc	r12, r1
    bffc:	d1 08       	sbc	r13, r1
    bffe:	e1 08       	sbc	r14, r1
    c000:	f1 08       	sbc	r15, r1
    c002:	10 c0       	rjmp	.+32     	; 0xc024 <__udivdi3+0xc4e>
    c004:	44 24       	eor	r4, r4
    c006:	55 24       	eor	r5, r5
    c008:	32 01       	movw	r6, r4
    c00a:	cc 24       	eor	r12, r12
    c00c:	dd 24       	eor	r13, r13
    c00e:	76 01       	movw	r14, r12
    c010:	0c c0       	rjmp	.+24     	; 0xc02a <__udivdi3+0xc54>
    c012:	44 24       	eor	r4, r4
    c014:	55 24       	eor	r5, r5
    c016:	32 01       	movw	r6, r4
    c018:	81 e0       	ldi	r24, 0x01	; 1
    c01a:	c8 2e       	mov	r12, r24
    c01c:	d1 2c       	mov	r13, r1
    c01e:	e1 2c       	mov	r14, r1
    c020:	f1 2c       	mov	r15, r1
    c022:	03 c0       	rjmp	.+6      	; 0xc02a <__udivdi3+0xc54>
    c024:	44 24       	eor	r4, r4
    c026:	55 24       	eor	r5, r5
    c028:	32 01       	movw	r6, r4
    c02a:	fe 01       	movw	r30, r28
    c02c:	31 96       	adiw	r30, 0x01	; 1
    c02e:	88 e0       	ldi	r24, 0x08	; 8
    c030:	df 01       	movw	r26, r30
    c032:	1d 92       	st	X+, r1
    c034:	8a 95       	dec	r24
    c036:	e9 f7       	brne	.-6      	; 0xc032 <__udivdi3+0xc5c>
    c038:	c9 82       	std	Y+1, r12	; 0x01
    c03a:	da 82       	std	Y+2, r13	; 0x02
    c03c:	eb 82       	std	Y+3, r14	; 0x03
    c03e:	fc 82       	std	Y+4, r15	; 0x04
    c040:	4d 82       	std	Y+5, r4	; 0x05
    c042:	5e 82       	std	Y+6, r5	; 0x06
    c044:	6f 82       	std	Y+7, r6	; 0x07
    c046:	78 86       	std	Y+8, r7	; 0x08
    c048:	2c 2d       	mov	r18, r12
    c04a:	3a 81       	ldd	r19, Y+2	; 0x02
    c04c:	4b 81       	ldd	r20, Y+3	; 0x03
    c04e:	5c 81       	ldd	r21, Y+4	; 0x04
    c050:	64 2d       	mov	r22, r4
    c052:	7e 81       	ldd	r23, Y+6	; 0x06
    c054:	8f 81       	ldd	r24, Y+7	; 0x07
    c056:	98 85       	ldd	r25, Y+8	; 0x08
    c058:	e4 96       	adiw	r28, 0x34	; 52
    c05a:	e1 e1       	ldi	r30, 0x11	; 17
    c05c:	0c 94 41 62 	jmp	0xc482	; 0xc482 <__epilogue_restores__+0x2>

0000c060 <__cmpsf2>:
    c060:	97 d0       	rcall	.+302    	; 0xc190 <__fp_cmp>
    c062:	08 f4       	brcc	.+2      	; 0xc066 <__cmpsf2+0x6>
    c064:	81 e0       	ldi	r24, 0x01	; 1
    c066:	08 95       	ret

0000c068 <__divsf3>:
    c068:	0c d0       	rcall	.+24     	; 0xc082 <__divsf3x>
    c06a:	cd c0       	rjmp	.+410    	; 0xc206 <__fp_round>
    c06c:	c5 d0       	rcall	.+394    	; 0xc1f8 <__fp_pscB>
    c06e:	40 f0       	brcs	.+16     	; 0xc080 <__divsf3+0x18>
    c070:	bc d0       	rcall	.+376    	; 0xc1ea <__fp_pscA>
    c072:	30 f0       	brcs	.+12     	; 0xc080 <__divsf3+0x18>
    c074:	21 f4       	brne	.+8      	; 0xc07e <__divsf3+0x16>
    c076:	5f 3f       	cpi	r21, 0xFF	; 255
    c078:	19 f0       	breq	.+6      	; 0xc080 <__divsf3+0x18>
    c07a:	ae c0       	rjmp	.+348    	; 0xc1d8 <__fp_inf>
    c07c:	51 11       	cpse	r21, r1
    c07e:	f7 c0       	rjmp	.+494    	; 0xc26e <__fp_szero>
    c080:	b1 c0       	rjmp	.+354    	; 0xc1e4 <__fp_nan>

0000c082 <__divsf3x>:
    c082:	d2 d0       	rcall	.+420    	; 0xc228 <__fp_split3>
    c084:	98 f3       	brcs	.-26     	; 0xc06c <__divsf3+0x4>

0000c086 <__divsf3_pse>:
    c086:	99 23       	and	r25, r25
    c088:	c9 f3       	breq	.-14     	; 0xc07c <__divsf3+0x14>
    c08a:	55 23       	and	r21, r21
    c08c:	b1 f3       	breq	.-20     	; 0xc07a <__divsf3+0x12>
    c08e:	95 1b       	sub	r25, r21
    c090:	55 0b       	sbc	r21, r21
    c092:	bb 27       	eor	r27, r27
    c094:	aa 27       	eor	r26, r26
    c096:	62 17       	cp	r22, r18
    c098:	73 07       	cpc	r23, r19
    c09a:	84 07       	cpc	r24, r20
    c09c:	38 f0       	brcs	.+14     	; 0xc0ac <__divsf3_pse+0x26>
    c09e:	9f 5f       	subi	r25, 0xFF	; 255
    c0a0:	5f 4f       	sbci	r21, 0xFF	; 255
    c0a2:	22 0f       	add	r18, r18
    c0a4:	33 1f       	adc	r19, r19
    c0a6:	44 1f       	adc	r20, r20
    c0a8:	aa 1f       	adc	r26, r26
    c0aa:	a9 f3       	breq	.-22     	; 0xc096 <__divsf3_pse+0x10>
    c0ac:	33 d0       	rcall	.+102    	; 0xc114 <__divsf3_pse+0x8e>
    c0ae:	0e 2e       	mov	r0, r30
    c0b0:	3a f0       	brmi	.+14     	; 0xc0c0 <__divsf3_pse+0x3a>
    c0b2:	e0 e8       	ldi	r30, 0x80	; 128
    c0b4:	30 d0       	rcall	.+96     	; 0xc116 <__divsf3_pse+0x90>
    c0b6:	91 50       	subi	r25, 0x01	; 1
    c0b8:	50 40       	sbci	r21, 0x00	; 0
    c0ba:	e6 95       	lsr	r30
    c0bc:	00 1c       	adc	r0, r0
    c0be:	ca f7       	brpl	.-14     	; 0xc0b2 <__divsf3_pse+0x2c>
    c0c0:	29 d0       	rcall	.+82     	; 0xc114 <__divsf3_pse+0x8e>
    c0c2:	fe 2f       	mov	r31, r30
    c0c4:	27 d0       	rcall	.+78     	; 0xc114 <__divsf3_pse+0x8e>
    c0c6:	66 0f       	add	r22, r22
    c0c8:	77 1f       	adc	r23, r23
    c0ca:	88 1f       	adc	r24, r24
    c0cc:	bb 1f       	adc	r27, r27
    c0ce:	26 17       	cp	r18, r22
    c0d0:	37 07       	cpc	r19, r23
    c0d2:	48 07       	cpc	r20, r24
    c0d4:	ab 07       	cpc	r26, r27
    c0d6:	b0 e8       	ldi	r27, 0x80	; 128
    c0d8:	09 f0       	breq	.+2      	; 0xc0dc <__divsf3_pse+0x56>
    c0da:	bb 0b       	sbc	r27, r27
    c0dc:	80 2d       	mov	r24, r0
    c0de:	bf 01       	movw	r22, r30
    c0e0:	ff 27       	eor	r31, r31
    c0e2:	93 58       	subi	r25, 0x83	; 131
    c0e4:	5f 4f       	sbci	r21, 0xFF	; 255
    c0e6:	2a f0       	brmi	.+10     	; 0xc0f2 <__divsf3_pse+0x6c>
    c0e8:	9e 3f       	cpi	r25, 0xFE	; 254
    c0ea:	51 05       	cpc	r21, r1
    c0ec:	68 f0       	brcs	.+26     	; 0xc108 <__divsf3_pse+0x82>
    c0ee:	74 c0       	rjmp	.+232    	; 0xc1d8 <__fp_inf>
    c0f0:	be c0       	rjmp	.+380    	; 0xc26e <__fp_szero>
    c0f2:	5f 3f       	cpi	r21, 0xFF	; 255
    c0f4:	ec f3       	brlt	.-6      	; 0xc0f0 <__divsf3_pse+0x6a>
    c0f6:	98 3e       	cpi	r25, 0xE8	; 232
    c0f8:	dc f3       	brlt	.-10     	; 0xc0f0 <__divsf3_pse+0x6a>
    c0fa:	86 95       	lsr	r24
    c0fc:	77 95       	ror	r23
    c0fe:	67 95       	ror	r22
    c100:	b7 95       	ror	r27
    c102:	f7 95       	ror	r31
    c104:	9f 5f       	subi	r25, 0xFF	; 255
    c106:	c9 f7       	brne	.-14     	; 0xc0fa <__divsf3_pse+0x74>
    c108:	88 0f       	add	r24, r24
    c10a:	91 1d       	adc	r25, r1
    c10c:	96 95       	lsr	r25
    c10e:	87 95       	ror	r24
    c110:	97 f9       	bld	r25, 7
    c112:	08 95       	ret
    c114:	e1 e0       	ldi	r30, 0x01	; 1
    c116:	66 0f       	add	r22, r22
    c118:	77 1f       	adc	r23, r23
    c11a:	88 1f       	adc	r24, r24
    c11c:	bb 1f       	adc	r27, r27
    c11e:	62 17       	cp	r22, r18
    c120:	73 07       	cpc	r23, r19
    c122:	84 07       	cpc	r24, r20
    c124:	ba 07       	cpc	r27, r26
    c126:	20 f0       	brcs	.+8      	; 0xc130 <__divsf3_pse+0xaa>
    c128:	62 1b       	sub	r22, r18
    c12a:	73 0b       	sbc	r23, r19
    c12c:	84 0b       	sbc	r24, r20
    c12e:	ba 0b       	sbc	r27, r26
    c130:	ee 1f       	adc	r30, r30
    c132:	88 f7       	brcc	.-30     	; 0xc116 <__divsf3_pse+0x90>
    c134:	e0 95       	com	r30
    c136:	08 95       	ret

0000c138 <__fixunssfsi>:
    c138:	7f d0       	rcall	.+254    	; 0xc238 <__fp_splitA>
    c13a:	88 f0       	brcs	.+34     	; 0xc15e <__fixunssfsi+0x26>
    c13c:	9f 57       	subi	r25, 0x7F	; 127
    c13e:	90 f0       	brcs	.+36     	; 0xc164 <__fixunssfsi+0x2c>
    c140:	b9 2f       	mov	r27, r25
    c142:	99 27       	eor	r25, r25
    c144:	b7 51       	subi	r27, 0x17	; 23
    c146:	a0 f0       	brcs	.+40     	; 0xc170 <__fixunssfsi+0x38>
    c148:	d1 f0       	breq	.+52     	; 0xc17e <__fixunssfsi+0x46>
    c14a:	66 0f       	add	r22, r22
    c14c:	77 1f       	adc	r23, r23
    c14e:	88 1f       	adc	r24, r24
    c150:	99 1f       	adc	r25, r25
    c152:	1a f0       	brmi	.+6      	; 0xc15a <__fixunssfsi+0x22>
    c154:	ba 95       	dec	r27
    c156:	c9 f7       	brne	.-14     	; 0xc14a <__fixunssfsi+0x12>
    c158:	12 c0       	rjmp	.+36     	; 0xc17e <__fixunssfsi+0x46>
    c15a:	b1 30       	cpi	r27, 0x01	; 1
    c15c:	81 f0       	breq	.+32     	; 0xc17e <__fixunssfsi+0x46>
    c15e:	86 d0       	rcall	.+268    	; 0xc26c <__fp_zero>
    c160:	b1 e0       	ldi	r27, 0x01	; 1
    c162:	08 95       	ret
    c164:	83 c0       	rjmp	.+262    	; 0xc26c <__fp_zero>
    c166:	67 2f       	mov	r22, r23
    c168:	78 2f       	mov	r23, r24
    c16a:	88 27       	eor	r24, r24
    c16c:	b8 5f       	subi	r27, 0xF8	; 248
    c16e:	39 f0       	breq	.+14     	; 0xc17e <__fixunssfsi+0x46>
    c170:	b9 3f       	cpi	r27, 0xF9	; 249
    c172:	cc f3       	brlt	.-14     	; 0xc166 <__fixunssfsi+0x2e>
    c174:	86 95       	lsr	r24
    c176:	77 95       	ror	r23
    c178:	67 95       	ror	r22
    c17a:	b3 95       	inc	r27
    c17c:	d9 f7       	brne	.-10     	; 0xc174 <__fixunssfsi+0x3c>
    c17e:	3e f4       	brtc	.+14     	; 0xc18e <__fixunssfsi+0x56>
    c180:	90 95       	com	r25
    c182:	80 95       	com	r24
    c184:	70 95       	com	r23
    c186:	61 95       	neg	r22
    c188:	7f 4f       	sbci	r23, 0xFF	; 255
    c18a:	8f 4f       	sbci	r24, 0xFF	; 255
    c18c:	9f 4f       	sbci	r25, 0xFF	; 255
    c18e:	08 95       	ret

0000c190 <__fp_cmp>:
    c190:	99 0f       	add	r25, r25
    c192:	00 08       	sbc	r0, r0
    c194:	55 0f       	add	r21, r21
    c196:	aa 0b       	sbc	r26, r26
    c198:	e0 e8       	ldi	r30, 0x80	; 128
    c19a:	fe ef       	ldi	r31, 0xFE	; 254
    c19c:	16 16       	cp	r1, r22
    c19e:	17 06       	cpc	r1, r23
    c1a0:	e8 07       	cpc	r30, r24
    c1a2:	f9 07       	cpc	r31, r25
    c1a4:	c0 f0       	brcs	.+48     	; 0xc1d6 <__fp_cmp+0x46>
    c1a6:	12 16       	cp	r1, r18
    c1a8:	13 06       	cpc	r1, r19
    c1aa:	e4 07       	cpc	r30, r20
    c1ac:	f5 07       	cpc	r31, r21
    c1ae:	98 f0       	brcs	.+38     	; 0xc1d6 <__fp_cmp+0x46>
    c1b0:	62 1b       	sub	r22, r18
    c1b2:	73 0b       	sbc	r23, r19
    c1b4:	84 0b       	sbc	r24, r20
    c1b6:	95 0b       	sbc	r25, r21
    c1b8:	39 f4       	brne	.+14     	; 0xc1c8 <__fp_cmp+0x38>
    c1ba:	0a 26       	eor	r0, r26
    c1bc:	61 f0       	breq	.+24     	; 0xc1d6 <__fp_cmp+0x46>
    c1be:	23 2b       	or	r18, r19
    c1c0:	24 2b       	or	r18, r20
    c1c2:	25 2b       	or	r18, r21
    c1c4:	21 f4       	brne	.+8      	; 0xc1ce <__fp_cmp+0x3e>
    c1c6:	08 95       	ret
    c1c8:	0a 26       	eor	r0, r26
    c1ca:	09 f4       	brne	.+2      	; 0xc1ce <__fp_cmp+0x3e>
    c1cc:	a1 40       	sbci	r26, 0x01	; 1
    c1ce:	a6 95       	lsr	r26
    c1d0:	8f ef       	ldi	r24, 0xFF	; 255
    c1d2:	81 1d       	adc	r24, r1
    c1d4:	81 1d       	adc	r24, r1
    c1d6:	08 95       	ret

0000c1d8 <__fp_inf>:
    c1d8:	97 f9       	bld	r25, 7
    c1da:	9f 67       	ori	r25, 0x7F	; 127
    c1dc:	80 e8       	ldi	r24, 0x80	; 128
    c1de:	70 e0       	ldi	r23, 0x00	; 0
    c1e0:	60 e0       	ldi	r22, 0x00	; 0
    c1e2:	08 95       	ret

0000c1e4 <__fp_nan>:
    c1e4:	9f ef       	ldi	r25, 0xFF	; 255
    c1e6:	80 ec       	ldi	r24, 0xC0	; 192
    c1e8:	08 95       	ret

0000c1ea <__fp_pscA>:
    c1ea:	00 24       	eor	r0, r0
    c1ec:	0a 94       	dec	r0
    c1ee:	16 16       	cp	r1, r22
    c1f0:	17 06       	cpc	r1, r23
    c1f2:	18 06       	cpc	r1, r24
    c1f4:	09 06       	cpc	r0, r25
    c1f6:	08 95       	ret

0000c1f8 <__fp_pscB>:
    c1f8:	00 24       	eor	r0, r0
    c1fa:	0a 94       	dec	r0
    c1fc:	12 16       	cp	r1, r18
    c1fe:	13 06       	cpc	r1, r19
    c200:	14 06       	cpc	r1, r20
    c202:	05 06       	cpc	r0, r21
    c204:	08 95       	ret

0000c206 <__fp_round>:
    c206:	09 2e       	mov	r0, r25
    c208:	03 94       	inc	r0
    c20a:	00 0c       	add	r0, r0
    c20c:	11 f4       	brne	.+4      	; 0xc212 <__fp_round+0xc>
    c20e:	88 23       	and	r24, r24
    c210:	52 f0       	brmi	.+20     	; 0xc226 <__fp_round+0x20>
    c212:	bb 0f       	add	r27, r27
    c214:	40 f4       	brcc	.+16     	; 0xc226 <__fp_round+0x20>
    c216:	bf 2b       	or	r27, r31
    c218:	11 f4       	brne	.+4      	; 0xc21e <__fp_round+0x18>
    c21a:	60 ff       	sbrs	r22, 0
    c21c:	04 c0       	rjmp	.+8      	; 0xc226 <__fp_round+0x20>
    c21e:	6f 5f       	subi	r22, 0xFF	; 255
    c220:	7f 4f       	sbci	r23, 0xFF	; 255
    c222:	8f 4f       	sbci	r24, 0xFF	; 255
    c224:	9f 4f       	sbci	r25, 0xFF	; 255
    c226:	08 95       	ret

0000c228 <__fp_split3>:
    c228:	57 fd       	sbrc	r21, 7
    c22a:	90 58       	subi	r25, 0x80	; 128
    c22c:	44 0f       	add	r20, r20
    c22e:	55 1f       	adc	r21, r21
    c230:	59 f0       	breq	.+22     	; 0xc248 <__fp_splitA+0x10>
    c232:	5f 3f       	cpi	r21, 0xFF	; 255
    c234:	71 f0       	breq	.+28     	; 0xc252 <__fp_splitA+0x1a>
    c236:	47 95       	ror	r20

0000c238 <__fp_splitA>:
    c238:	88 0f       	add	r24, r24
    c23a:	97 fb       	bst	r25, 7
    c23c:	99 1f       	adc	r25, r25
    c23e:	61 f0       	breq	.+24     	; 0xc258 <__fp_splitA+0x20>
    c240:	9f 3f       	cpi	r25, 0xFF	; 255
    c242:	79 f0       	breq	.+30     	; 0xc262 <__fp_splitA+0x2a>
    c244:	87 95       	ror	r24
    c246:	08 95       	ret
    c248:	12 16       	cp	r1, r18
    c24a:	13 06       	cpc	r1, r19
    c24c:	14 06       	cpc	r1, r20
    c24e:	55 1f       	adc	r21, r21
    c250:	f2 cf       	rjmp	.-28     	; 0xc236 <__fp_split3+0xe>
    c252:	46 95       	lsr	r20
    c254:	f1 df       	rcall	.-30     	; 0xc238 <__fp_splitA>
    c256:	08 c0       	rjmp	.+16     	; 0xc268 <__fp_splitA+0x30>
    c258:	16 16       	cp	r1, r22
    c25a:	17 06       	cpc	r1, r23
    c25c:	18 06       	cpc	r1, r24
    c25e:	99 1f       	adc	r25, r25
    c260:	f1 cf       	rjmp	.-30     	; 0xc244 <__fp_splitA+0xc>
    c262:	86 95       	lsr	r24
    c264:	71 05       	cpc	r23, r1
    c266:	61 05       	cpc	r22, r1
    c268:	08 94       	sec
    c26a:	08 95       	ret

0000c26c <__fp_zero>:
    c26c:	e8 94       	clt

0000c26e <__fp_szero>:
    c26e:	bb 27       	eor	r27, r27
    c270:	66 27       	eor	r22, r22
    c272:	77 27       	eor	r23, r23
    c274:	cb 01       	movw	r24, r22
    c276:	97 f9       	bld	r25, 7
    c278:	08 95       	ret

0000c27a <__gesf2>:
    c27a:	8a df       	rcall	.-236    	; 0xc190 <__fp_cmp>
    c27c:	08 f4       	brcc	.+2      	; 0xc280 <__gesf2+0x6>
    c27e:	8f ef       	ldi	r24, 0xFF	; 255
    c280:	08 95       	ret

0000c282 <__mulsf3>:
    c282:	0b d0       	rcall	.+22     	; 0xc29a <__mulsf3x>
    c284:	c0 cf       	rjmp	.-128    	; 0xc206 <__fp_round>
    c286:	b1 df       	rcall	.-158    	; 0xc1ea <__fp_pscA>
    c288:	28 f0       	brcs	.+10     	; 0xc294 <__mulsf3+0x12>
    c28a:	b6 df       	rcall	.-148    	; 0xc1f8 <__fp_pscB>
    c28c:	18 f0       	brcs	.+6      	; 0xc294 <__mulsf3+0x12>
    c28e:	95 23       	and	r25, r21
    c290:	09 f0       	breq	.+2      	; 0xc294 <__mulsf3+0x12>
    c292:	a2 cf       	rjmp	.-188    	; 0xc1d8 <__fp_inf>
    c294:	a7 cf       	rjmp	.-178    	; 0xc1e4 <__fp_nan>
    c296:	11 24       	eor	r1, r1
    c298:	ea cf       	rjmp	.-44     	; 0xc26e <__fp_szero>

0000c29a <__mulsf3x>:
    c29a:	c6 df       	rcall	.-116    	; 0xc228 <__fp_split3>
    c29c:	a0 f3       	brcs	.-24     	; 0xc286 <__mulsf3+0x4>

0000c29e <__mulsf3_pse>:
    c29e:	95 9f       	mul	r25, r21
    c2a0:	d1 f3       	breq	.-12     	; 0xc296 <__mulsf3+0x14>
    c2a2:	95 0f       	add	r25, r21
    c2a4:	50 e0       	ldi	r21, 0x00	; 0
    c2a6:	55 1f       	adc	r21, r21
    c2a8:	62 9f       	mul	r22, r18
    c2aa:	f0 01       	movw	r30, r0
    c2ac:	72 9f       	mul	r23, r18
    c2ae:	bb 27       	eor	r27, r27
    c2b0:	f0 0d       	add	r31, r0
    c2b2:	b1 1d       	adc	r27, r1
    c2b4:	63 9f       	mul	r22, r19
    c2b6:	aa 27       	eor	r26, r26
    c2b8:	f0 0d       	add	r31, r0
    c2ba:	b1 1d       	adc	r27, r1
    c2bc:	aa 1f       	adc	r26, r26
    c2be:	64 9f       	mul	r22, r20
    c2c0:	66 27       	eor	r22, r22
    c2c2:	b0 0d       	add	r27, r0
    c2c4:	a1 1d       	adc	r26, r1
    c2c6:	66 1f       	adc	r22, r22
    c2c8:	82 9f       	mul	r24, r18
    c2ca:	22 27       	eor	r18, r18
    c2cc:	b0 0d       	add	r27, r0
    c2ce:	a1 1d       	adc	r26, r1
    c2d0:	62 1f       	adc	r22, r18
    c2d2:	73 9f       	mul	r23, r19
    c2d4:	b0 0d       	add	r27, r0
    c2d6:	a1 1d       	adc	r26, r1
    c2d8:	62 1f       	adc	r22, r18
    c2da:	83 9f       	mul	r24, r19
    c2dc:	a0 0d       	add	r26, r0
    c2de:	61 1d       	adc	r22, r1
    c2e0:	22 1f       	adc	r18, r18
    c2e2:	74 9f       	mul	r23, r20
    c2e4:	33 27       	eor	r19, r19
    c2e6:	a0 0d       	add	r26, r0
    c2e8:	61 1d       	adc	r22, r1
    c2ea:	23 1f       	adc	r18, r19
    c2ec:	84 9f       	mul	r24, r20
    c2ee:	60 0d       	add	r22, r0
    c2f0:	21 1d       	adc	r18, r1
    c2f2:	82 2f       	mov	r24, r18
    c2f4:	76 2f       	mov	r23, r22
    c2f6:	6a 2f       	mov	r22, r26
    c2f8:	11 24       	eor	r1, r1
    c2fa:	9f 57       	subi	r25, 0x7F	; 127
    c2fc:	50 40       	sbci	r21, 0x00	; 0
    c2fe:	8a f0       	brmi	.+34     	; 0xc322 <__mulsf3_pse+0x84>
    c300:	e1 f0       	breq	.+56     	; 0xc33a <__mulsf3_pse+0x9c>
    c302:	88 23       	and	r24, r24
    c304:	4a f0       	brmi	.+18     	; 0xc318 <__mulsf3_pse+0x7a>
    c306:	ee 0f       	add	r30, r30
    c308:	ff 1f       	adc	r31, r31
    c30a:	bb 1f       	adc	r27, r27
    c30c:	66 1f       	adc	r22, r22
    c30e:	77 1f       	adc	r23, r23
    c310:	88 1f       	adc	r24, r24
    c312:	91 50       	subi	r25, 0x01	; 1
    c314:	50 40       	sbci	r21, 0x00	; 0
    c316:	a9 f7       	brne	.-22     	; 0xc302 <__mulsf3_pse+0x64>
    c318:	9e 3f       	cpi	r25, 0xFE	; 254
    c31a:	51 05       	cpc	r21, r1
    c31c:	70 f0       	brcs	.+28     	; 0xc33a <__mulsf3_pse+0x9c>
    c31e:	5c cf       	rjmp	.-328    	; 0xc1d8 <__fp_inf>
    c320:	a6 cf       	rjmp	.-180    	; 0xc26e <__fp_szero>
    c322:	5f 3f       	cpi	r21, 0xFF	; 255
    c324:	ec f3       	brlt	.-6      	; 0xc320 <__mulsf3_pse+0x82>
    c326:	98 3e       	cpi	r25, 0xE8	; 232
    c328:	dc f3       	brlt	.-10     	; 0xc320 <__mulsf3_pse+0x82>
    c32a:	86 95       	lsr	r24
    c32c:	77 95       	ror	r23
    c32e:	67 95       	ror	r22
    c330:	b7 95       	ror	r27
    c332:	f7 95       	ror	r31
    c334:	e7 95       	ror	r30
    c336:	9f 5f       	subi	r25, 0xFF	; 255
    c338:	c1 f7       	brne	.-16     	; 0xc32a <__mulsf3_pse+0x8c>
    c33a:	fe 2b       	or	r31, r30
    c33c:	88 0f       	add	r24, r24
    c33e:	91 1d       	adc	r25, r1
    c340:	96 95       	lsr	r25
    c342:	87 95       	ror	r24
    c344:	97 f9       	bld	r25, 7
    c346:	08 95       	ret

0000c348 <__mulsi3>:
    c348:	62 9f       	mul	r22, r18
    c34a:	d0 01       	movw	r26, r0
    c34c:	73 9f       	mul	r23, r19
    c34e:	f0 01       	movw	r30, r0
    c350:	82 9f       	mul	r24, r18
    c352:	e0 0d       	add	r30, r0
    c354:	f1 1d       	adc	r31, r1
    c356:	64 9f       	mul	r22, r20
    c358:	e0 0d       	add	r30, r0
    c35a:	f1 1d       	adc	r31, r1
    c35c:	92 9f       	mul	r25, r18
    c35e:	f0 0d       	add	r31, r0
    c360:	83 9f       	mul	r24, r19
    c362:	f0 0d       	add	r31, r0
    c364:	74 9f       	mul	r23, r20
    c366:	f0 0d       	add	r31, r0
    c368:	65 9f       	mul	r22, r21
    c36a:	f0 0d       	add	r31, r0
    c36c:	99 27       	eor	r25, r25
    c36e:	72 9f       	mul	r23, r18
    c370:	b0 0d       	add	r27, r0
    c372:	e1 1d       	adc	r30, r1
    c374:	f9 1f       	adc	r31, r25
    c376:	63 9f       	mul	r22, r19
    c378:	b0 0d       	add	r27, r0
    c37a:	e1 1d       	adc	r30, r1
    c37c:	f9 1f       	adc	r31, r25
    c37e:	bd 01       	movw	r22, r26
    c380:	cf 01       	movw	r24, r30
    c382:	11 24       	eor	r1, r1
    c384:	08 95       	ret

0000c386 <__udivmodhi4>:
    c386:	aa 1b       	sub	r26, r26
    c388:	bb 1b       	sub	r27, r27
    c38a:	51 e1       	ldi	r21, 0x11	; 17
    c38c:	07 c0       	rjmp	.+14     	; 0xc39c <__udivmodhi4_ep>

0000c38e <__udivmodhi4_loop>:
    c38e:	aa 1f       	adc	r26, r26
    c390:	bb 1f       	adc	r27, r27
    c392:	a6 17       	cp	r26, r22
    c394:	b7 07       	cpc	r27, r23
    c396:	10 f0       	brcs	.+4      	; 0xc39c <__udivmodhi4_ep>
    c398:	a6 1b       	sub	r26, r22
    c39a:	b7 0b       	sbc	r27, r23

0000c39c <__udivmodhi4_ep>:
    c39c:	88 1f       	adc	r24, r24
    c39e:	99 1f       	adc	r25, r25
    c3a0:	5a 95       	dec	r21
    c3a2:	a9 f7       	brne	.-22     	; 0xc38e <__udivmodhi4_loop>
    c3a4:	80 95       	com	r24
    c3a6:	90 95       	com	r25
    c3a8:	bc 01       	movw	r22, r24
    c3aa:	cd 01       	movw	r24, r26
    c3ac:	08 95       	ret

0000c3ae <__divmodhi4>:
    c3ae:	97 fb       	bst	r25, 7
    c3b0:	09 2e       	mov	r0, r25
    c3b2:	07 26       	eor	r0, r23
    c3b4:	0a d0       	rcall	.+20     	; 0xc3ca <__divmodhi4_neg1>
    c3b6:	77 fd       	sbrc	r23, 7
    c3b8:	04 d0       	rcall	.+8      	; 0xc3c2 <__divmodhi4_neg2>
    c3ba:	e5 df       	rcall	.-54     	; 0xc386 <__udivmodhi4>
    c3bc:	06 d0       	rcall	.+12     	; 0xc3ca <__divmodhi4_neg1>
    c3be:	00 20       	and	r0, r0
    c3c0:	1a f4       	brpl	.+6      	; 0xc3c8 <__divmodhi4_exit>

0000c3c2 <__divmodhi4_neg2>:
    c3c2:	70 95       	com	r23
    c3c4:	61 95       	neg	r22
    c3c6:	7f 4f       	sbci	r23, 0xFF	; 255

0000c3c8 <__divmodhi4_exit>:
    c3c8:	08 95       	ret

0000c3ca <__divmodhi4_neg1>:
    c3ca:	f6 f7       	brtc	.-4      	; 0xc3c8 <__divmodhi4_exit>
    c3cc:	90 95       	com	r25
    c3ce:	81 95       	neg	r24
    c3d0:	9f 4f       	sbci	r25, 0xFF	; 255
    c3d2:	08 95       	ret

0000c3d4 <__udivmodsi4>:
    c3d4:	a1 e2       	ldi	r26, 0x21	; 33
    c3d6:	1a 2e       	mov	r1, r26
    c3d8:	aa 1b       	sub	r26, r26
    c3da:	bb 1b       	sub	r27, r27
    c3dc:	fd 01       	movw	r30, r26
    c3de:	0d c0       	rjmp	.+26     	; 0xc3fa <__udivmodsi4_ep>

0000c3e0 <__udivmodsi4_loop>:
    c3e0:	aa 1f       	adc	r26, r26
    c3e2:	bb 1f       	adc	r27, r27
    c3e4:	ee 1f       	adc	r30, r30
    c3e6:	ff 1f       	adc	r31, r31
    c3e8:	a2 17       	cp	r26, r18
    c3ea:	b3 07       	cpc	r27, r19
    c3ec:	e4 07       	cpc	r30, r20
    c3ee:	f5 07       	cpc	r31, r21
    c3f0:	20 f0       	brcs	.+8      	; 0xc3fa <__udivmodsi4_ep>
    c3f2:	a2 1b       	sub	r26, r18
    c3f4:	b3 0b       	sbc	r27, r19
    c3f6:	e4 0b       	sbc	r30, r20
    c3f8:	f5 0b       	sbc	r31, r21

0000c3fa <__udivmodsi4_ep>:
    c3fa:	66 1f       	adc	r22, r22
    c3fc:	77 1f       	adc	r23, r23
    c3fe:	88 1f       	adc	r24, r24
    c400:	99 1f       	adc	r25, r25
    c402:	1a 94       	dec	r1
    c404:	69 f7       	brne	.-38     	; 0xc3e0 <__udivmodsi4_loop>
    c406:	60 95       	com	r22
    c408:	70 95       	com	r23
    c40a:	80 95       	com	r24
    c40c:	90 95       	com	r25
    c40e:	9b 01       	movw	r18, r22
    c410:	ac 01       	movw	r20, r24
    c412:	bd 01       	movw	r22, r26
    c414:	cf 01       	movw	r24, r30
    c416:	08 95       	ret

0000c418 <__divmodsi4>:
    c418:	97 fb       	bst	r25, 7
    c41a:	09 2e       	mov	r0, r25
    c41c:	05 26       	eor	r0, r21
    c41e:	0e d0       	rcall	.+28     	; 0xc43c <__divmodsi4_neg1>
    c420:	57 fd       	sbrc	r21, 7
    c422:	04 d0       	rcall	.+8      	; 0xc42c <__divmodsi4_neg2>
    c424:	d7 df       	rcall	.-82     	; 0xc3d4 <__udivmodsi4>
    c426:	0a d0       	rcall	.+20     	; 0xc43c <__divmodsi4_neg1>
    c428:	00 1c       	adc	r0, r0
    c42a:	38 f4       	brcc	.+14     	; 0xc43a <__divmodsi4_exit>

0000c42c <__divmodsi4_neg2>:
    c42c:	50 95       	com	r21
    c42e:	40 95       	com	r20
    c430:	30 95       	com	r19
    c432:	21 95       	neg	r18
    c434:	3f 4f       	sbci	r19, 0xFF	; 255
    c436:	4f 4f       	sbci	r20, 0xFF	; 255
    c438:	5f 4f       	sbci	r21, 0xFF	; 255

0000c43a <__divmodsi4_exit>:
    c43a:	08 95       	ret

0000c43c <__divmodsi4_neg1>:
    c43c:	f6 f7       	brtc	.-4      	; 0xc43a <__divmodsi4_exit>
    c43e:	90 95       	com	r25
    c440:	80 95       	com	r24
    c442:	70 95       	com	r23
    c444:	61 95       	neg	r22
    c446:	7f 4f       	sbci	r23, 0xFF	; 255
    c448:	8f 4f       	sbci	r24, 0xFF	; 255
    c44a:	9f 4f       	sbci	r25, 0xFF	; 255
    c44c:	08 95       	ret

0000c44e <__prologue_saves__>:
    c44e:	2f 92       	push	r2
    c450:	3f 92       	push	r3
    c452:	4f 92       	push	r4
    c454:	5f 92       	push	r5
    c456:	6f 92       	push	r6
    c458:	7f 92       	push	r7
    c45a:	8f 92       	push	r8
    c45c:	9f 92       	push	r9
    c45e:	af 92       	push	r10
    c460:	bf 92       	push	r11
    c462:	cf 92       	push	r12
    c464:	df 92       	push	r13
    c466:	ef 92       	push	r14
    c468:	ff 92       	push	r15
    c46a:	0f 93       	push	r16
    c46c:	1f 93       	push	r17
    c46e:	cf 93       	push	r28
    c470:	df 93       	push	r29
    c472:	cd b7       	in	r28, 0x3d	; 61
    c474:	de b7       	in	r29, 0x3e	; 62
    c476:	ca 1b       	sub	r28, r26
    c478:	db 0b       	sbc	r29, r27
    c47a:	cd bf       	out	0x3d, r28	; 61
    c47c:	de bf       	out	0x3e, r29	; 62
    c47e:	19 94       	eijmp

0000c480 <__epilogue_restores__>:
    c480:	2a 88       	ldd	r2, Y+18	; 0x12
    c482:	39 88       	ldd	r3, Y+17	; 0x11
    c484:	48 88       	ldd	r4, Y+16	; 0x10
    c486:	5f 84       	ldd	r5, Y+15	; 0x0f
    c488:	6e 84       	ldd	r6, Y+14	; 0x0e
    c48a:	7d 84       	ldd	r7, Y+13	; 0x0d
    c48c:	8c 84       	ldd	r8, Y+12	; 0x0c
    c48e:	9b 84       	ldd	r9, Y+11	; 0x0b
    c490:	aa 84       	ldd	r10, Y+10	; 0x0a
    c492:	b9 84       	ldd	r11, Y+9	; 0x09
    c494:	c8 84       	ldd	r12, Y+8	; 0x08
    c496:	df 80       	ldd	r13, Y+7	; 0x07
    c498:	ee 80       	ldd	r14, Y+6	; 0x06
    c49a:	fd 80       	ldd	r15, Y+5	; 0x05
    c49c:	0c 81       	ldd	r16, Y+4	; 0x04
    c49e:	1b 81       	ldd	r17, Y+3	; 0x03
    c4a0:	aa 81       	ldd	r26, Y+2	; 0x02
    c4a2:	b9 81       	ldd	r27, Y+1	; 0x01
    c4a4:	ce 0f       	add	r28, r30
    c4a6:	d1 1d       	adc	r29, r1
    c4a8:	cd bf       	out	0x3d, r28	; 61
    c4aa:	de bf       	out	0x3e, r29	; 62
    c4ac:	ed 01       	movw	r28, r26
    c4ae:	08 95       	ret

0000c4b0 <strcpy_P>:
    c4b0:	fb 01       	movw	r30, r22
    c4b2:	dc 01       	movw	r26, r24
    c4b4:	05 90       	lpm	r0, Z+
    c4b6:	0d 92       	st	X+, r0
    c4b8:	00 20       	and	r0, r0
    c4ba:	e1 f7       	brne	.-8      	; 0xc4b4 <strcpy_P+0x4>
    c4bc:	08 95       	ret

0000c4be <memcpy>:
    c4be:	fb 01       	movw	r30, r22
    c4c0:	dc 01       	movw	r26, r24
    c4c2:	02 c0       	rjmp	.+4      	; 0xc4c8 <memcpy+0xa>
    c4c4:	01 90       	ld	r0, Z+
    c4c6:	0d 92       	st	X+, r0
    c4c8:	41 50       	subi	r20, 0x01	; 1
    c4ca:	50 40       	sbci	r21, 0x00	; 0
    c4cc:	d8 f7       	brcc	.-10     	; 0xc4c4 <memcpy+0x6>
    c4ce:	08 95       	ret

0000c4d0 <memmove>:
    c4d0:	68 17       	cp	r22, r24
    c4d2:	79 07       	cpc	r23, r25
    c4d4:	68 f4       	brcc	.+26     	; 0xc4f0 <memmove+0x20>
    c4d6:	fb 01       	movw	r30, r22
    c4d8:	dc 01       	movw	r26, r24
    c4da:	e4 0f       	add	r30, r20
    c4dc:	f5 1f       	adc	r31, r21
    c4de:	a4 0f       	add	r26, r20
    c4e0:	b5 1f       	adc	r27, r21
    c4e2:	02 c0       	rjmp	.+4      	; 0xc4e8 <memmove+0x18>
    c4e4:	02 90       	ld	r0, -Z
    c4e6:	0e 92       	st	-X, r0
    c4e8:	41 50       	subi	r20, 0x01	; 1
    c4ea:	50 40       	sbci	r21, 0x00	; 0
    c4ec:	d8 f7       	brcc	.-10     	; 0xc4e4 <memmove+0x14>
    c4ee:	08 95       	ret
    c4f0:	0c 94 5f 62 	jmp	0xc4be	; 0xc4be <memcpy>

0000c4f4 <strcat>:
    c4f4:	fb 01       	movw	r30, r22
    c4f6:	dc 01       	movw	r26, r24
    c4f8:	0d 90       	ld	r0, X+
    c4fa:	00 20       	and	r0, r0
    c4fc:	e9 f7       	brne	.-6      	; 0xc4f8 <strcat+0x4>
    c4fe:	11 97       	sbiw	r26, 0x01	; 1
    c500:	01 90       	ld	r0, Z+
    c502:	0d 92       	st	X+, r0
    c504:	00 20       	and	r0, r0
    c506:	e1 f7       	brne	.-8      	; 0xc500 <strcat+0xc>
    c508:	08 95       	ret

0000c50a <strncmp>:
    c50a:	fb 01       	movw	r30, r22
    c50c:	dc 01       	movw	r26, r24
    c50e:	41 50       	subi	r20, 0x01	; 1
    c510:	50 40       	sbci	r21, 0x00	; 0
    c512:	30 f0       	brcs	.+12     	; 0xc520 <strncmp+0x16>
    c514:	8d 91       	ld	r24, X+
    c516:	01 90       	ld	r0, Z+
    c518:	80 19       	sub	r24, r0
    c51a:	19 f4       	brne	.+6      	; 0xc522 <strncmp+0x18>
    c51c:	00 20       	and	r0, r0
    c51e:	b9 f7       	brne	.-18     	; 0xc50e <strncmp+0x4>
    c520:	88 1b       	sub	r24, r24
    c522:	99 0b       	sbc	r25, r25
    c524:	08 95       	ret

0000c526 <itoa>:
    c526:	fb 01       	movw	r30, r22
    c528:	9f 01       	movw	r18, r30
    c52a:	e8 94       	clt
    c52c:	42 30       	cpi	r20, 0x02	; 2
    c52e:	c4 f0       	brlt	.+48     	; 0xc560 <itoa+0x3a>
    c530:	45 32       	cpi	r20, 0x25	; 37
    c532:	b4 f4       	brge	.+44     	; 0xc560 <itoa+0x3a>
    c534:	4a 30       	cpi	r20, 0x0A	; 10
    c536:	29 f4       	brne	.+10     	; 0xc542 <itoa+0x1c>
    c538:	97 fb       	bst	r25, 7
    c53a:	1e f4       	brtc	.+6      	; 0xc542 <itoa+0x1c>
    c53c:	90 95       	com	r25
    c53e:	81 95       	neg	r24
    c540:	9f 4f       	sbci	r25, 0xFF	; 255
    c542:	64 2f       	mov	r22, r20
    c544:	77 27       	eor	r23, r23
    c546:	0e 94 c3 61 	call	0xc386	; 0xc386 <__udivmodhi4>
    c54a:	80 5d       	subi	r24, 0xD0	; 208
    c54c:	8a 33       	cpi	r24, 0x3A	; 58
    c54e:	0c f0       	brlt	.+2      	; 0xc552 <itoa+0x2c>
    c550:	89 5d       	subi	r24, 0xD9	; 217
    c552:	81 93       	st	Z+, r24
    c554:	cb 01       	movw	r24, r22
    c556:	00 97       	sbiw	r24, 0x00	; 0
    c558:	a1 f7       	brne	.-24     	; 0xc542 <itoa+0x1c>
    c55a:	16 f4       	brtc	.+4      	; 0xc560 <itoa+0x3a>
    c55c:	5d e2       	ldi	r21, 0x2D	; 45
    c55e:	51 93       	st	Z+, r21
    c560:	10 82       	st	Z, r1
    c562:	c9 01       	movw	r24, r18
    c564:	0c 94 dd 64 	jmp	0xc9ba	; 0xc9ba <strrev>

0000c568 <printf>:
    c568:	cf 93       	push	r28
    c56a:	df 93       	push	r29
    c56c:	cd b7       	in	r28, 0x3d	; 61
    c56e:	de b7       	in	r29, 0x3e	; 62
    c570:	fe 01       	movw	r30, r28
    c572:	36 96       	adiw	r30, 0x06	; 6
    c574:	61 91       	ld	r22, Z+
    c576:	71 91       	ld	r23, Z+
    c578:	80 91 27 53 	lds	r24, 0x5327
    c57c:	90 91 28 53 	lds	r25, 0x5328
    c580:	af 01       	movw	r20, r30
    c582:	0e 94 c6 62 	call	0xc58c	; 0xc58c <vfprintf>
    c586:	df 91       	pop	r29
    c588:	cf 91       	pop	r28
    c58a:	08 95       	ret

0000c58c <vfprintf>:
    c58c:	2f 92       	push	r2
    c58e:	3f 92       	push	r3
    c590:	4f 92       	push	r4
    c592:	5f 92       	push	r5
    c594:	6f 92       	push	r6
    c596:	7f 92       	push	r7
    c598:	8f 92       	push	r8
    c59a:	9f 92       	push	r9
    c59c:	af 92       	push	r10
    c59e:	bf 92       	push	r11
    c5a0:	cf 92       	push	r12
    c5a2:	df 92       	push	r13
    c5a4:	ef 92       	push	r14
    c5a6:	ff 92       	push	r15
    c5a8:	0f 93       	push	r16
    c5aa:	1f 93       	push	r17
    c5ac:	cf 93       	push	r28
    c5ae:	df 93       	push	r29
    c5b0:	cd b7       	in	r28, 0x3d	; 61
    c5b2:	de b7       	in	r29, 0x3e	; 62
    c5b4:	2d 97       	sbiw	r28, 0x0d	; 13
    c5b6:	cd bf       	out	0x3d, r28	; 61
    c5b8:	de bf       	out	0x3e, r29	; 62
    c5ba:	3c 01       	movw	r6, r24
    c5bc:	6c 87       	std	Y+12, r22	; 0x0c
    c5be:	7d 87       	std	Y+13, r23	; 0x0d
    c5c0:	5a 01       	movw	r10, r20
    c5c2:	fc 01       	movw	r30, r24
    c5c4:	16 82       	std	Z+6, r1	; 0x06
    c5c6:	17 82       	std	Z+7, r1	; 0x07
    c5c8:	83 81       	ldd	r24, Z+3	; 0x03
    c5ca:	81 ff       	sbrs	r24, 1
    c5cc:	c8 c1       	rjmp	.+912    	; 0xc95e <vfprintf+0x3d2>
    c5ce:	2e 01       	movw	r4, r28
    c5d0:	08 94       	sec
    c5d2:	41 1c       	adc	r4, r1
    c5d4:	51 1c       	adc	r5, r1
    c5d6:	f3 01       	movw	r30, r6
    c5d8:	93 81       	ldd	r25, Z+3	; 0x03
    c5da:	ec 85       	ldd	r30, Y+12	; 0x0c
    c5dc:	fd 85       	ldd	r31, Y+13	; 0x0d
    c5de:	93 fd       	sbrc	r25, 3
    c5e0:	85 91       	lpm	r24, Z+
    c5e2:	93 ff       	sbrs	r25, 3
    c5e4:	81 91       	ld	r24, Z+
    c5e6:	ec 87       	std	Y+12, r30	; 0x0c
    c5e8:	fd 87       	std	Y+13, r31	; 0x0d
    c5ea:	88 23       	and	r24, r24
    c5ec:	09 f4       	brne	.+2      	; 0xc5f0 <vfprintf+0x64>
    c5ee:	b3 c1       	rjmp	.+870    	; 0xc956 <vfprintf+0x3ca>
    c5f0:	85 32       	cpi	r24, 0x25	; 37
    c5f2:	41 f4       	brne	.+16     	; 0xc604 <vfprintf+0x78>
    c5f4:	93 fd       	sbrc	r25, 3
    c5f6:	85 91       	lpm	r24, Z+
    c5f8:	93 ff       	sbrs	r25, 3
    c5fa:	81 91       	ld	r24, Z+
    c5fc:	ec 87       	std	Y+12, r30	; 0x0c
    c5fe:	fd 87       	std	Y+13, r31	; 0x0d
    c600:	85 32       	cpi	r24, 0x25	; 37
    c602:	29 f4       	brne	.+10     	; 0xc60e <vfprintf+0x82>
    c604:	90 e0       	ldi	r25, 0x00	; 0
    c606:	b3 01       	movw	r22, r6
    c608:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c60c:	e4 cf       	rjmp	.-56     	; 0xc5d6 <vfprintf+0x4a>
    c60e:	ff 24       	eor	r15, r15
    c610:	ee 24       	eor	r14, r14
    c612:	10 e0       	ldi	r17, 0x00	; 0
    c614:	10 32       	cpi	r17, 0x20	; 32
    c616:	b0 f4       	brcc	.+44     	; 0xc644 <vfprintf+0xb8>
    c618:	8b 32       	cpi	r24, 0x2B	; 43
    c61a:	69 f0       	breq	.+26     	; 0xc636 <vfprintf+0xaa>
    c61c:	8c 32       	cpi	r24, 0x2C	; 44
    c61e:	28 f4       	brcc	.+10     	; 0xc62a <vfprintf+0x9e>
    c620:	80 32       	cpi	r24, 0x20	; 32
    c622:	51 f0       	breq	.+20     	; 0xc638 <vfprintf+0xac>
    c624:	83 32       	cpi	r24, 0x23	; 35
    c626:	71 f4       	brne	.+28     	; 0xc644 <vfprintf+0xb8>
    c628:	0b c0       	rjmp	.+22     	; 0xc640 <vfprintf+0xb4>
    c62a:	8d 32       	cpi	r24, 0x2D	; 45
    c62c:	39 f0       	breq	.+14     	; 0xc63c <vfprintf+0xb0>
    c62e:	80 33       	cpi	r24, 0x30	; 48
    c630:	49 f4       	brne	.+18     	; 0xc644 <vfprintf+0xb8>
    c632:	11 60       	ori	r17, 0x01	; 1
    c634:	2c c0       	rjmp	.+88     	; 0xc68e <vfprintf+0x102>
    c636:	12 60       	ori	r17, 0x02	; 2
    c638:	14 60       	ori	r17, 0x04	; 4
    c63a:	29 c0       	rjmp	.+82     	; 0xc68e <vfprintf+0x102>
    c63c:	18 60       	ori	r17, 0x08	; 8
    c63e:	27 c0       	rjmp	.+78     	; 0xc68e <vfprintf+0x102>
    c640:	10 61       	ori	r17, 0x10	; 16
    c642:	25 c0       	rjmp	.+74     	; 0xc68e <vfprintf+0x102>
    c644:	17 fd       	sbrc	r17, 7
    c646:	2e c0       	rjmp	.+92     	; 0xc6a4 <vfprintf+0x118>
    c648:	28 2f       	mov	r18, r24
    c64a:	20 53       	subi	r18, 0x30	; 48
    c64c:	2a 30       	cpi	r18, 0x0A	; 10
    c64e:	98 f4       	brcc	.+38     	; 0xc676 <vfprintf+0xea>
    c650:	16 ff       	sbrs	r17, 6
    c652:	08 c0       	rjmp	.+16     	; 0xc664 <vfprintf+0xd8>
    c654:	8f 2d       	mov	r24, r15
    c656:	88 0f       	add	r24, r24
    c658:	f8 2e       	mov	r15, r24
    c65a:	ff 0c       	add	r15, r15
    c65c:	ff 0c       	add	r15, r15
    c65e:	f8 0e       	add	r15, r24
    c660:	f2 0e       	add	r15, r18
    c662:	15 c0       	rjmp	.+42     	; 0xc68e <vfprintf+0x102>
    c664:	8e 2d       	mov	r24, r14
    c666:	88 0f       	add	r24, r24
    c668:	e8 2e       	mov	r14, r24
    c66a:	ee 0c       	add	r14, r14
    c66c:	ee 0c       	add	r14, r14
    c66e:	e8 0e       	add	r14, r24
    c670:	e2 0e       	add	r14, r18
    c672:	10 62       	ori	r17, 0x20	; 32
    c674:	0c c0       	rjmp	.+24     	; 0xc68e <vfprintf+0x102>
    c676:	8e 32       	cpi	r24, 0x2E	; 46
    c678:	21 f4       	brne	.+8      	; 0xc682 <vfprintf+0xf6>
    c67a:	16 fd       	sbrc	r17, 6
    c67c:	6c c1       	rjmp	.+728    	; 0xc956 <vfprintf+0x3ca>
    c67e:	10 64       	ori	r17, 0x40	; 64
    c680:	06 c0       	rjmp	.+12     	; 0xc68e <vfprintf+0x102>
    c682:	8c 36       	cpi	r24, 0x6C	; 108
    c684:	11 f4       	brne	.+4      	; 0xc68a <vfprintf+0xfe>
    c686:	10 68       	ori	r17, 0x80	; 128
    c688:	02 c0       	rjmp	.+4      	; 0xc68e <vfprintf+0x102>
    c68a:	88 36       	cpi	r24, 0x68	; 104
    c68c:	59 f4       	brne	.+22     	; 0xc6a4 <vfprintf+0x118>
    c68e:	ec 85       	ldd	r30, Y+12	; 0x0c
    c690:	fd 85       	ldd	r31, Y+13	; 0x0d
    c692:	93 fd       	sbrc	r25, 3
    c694:	85 91       	lpm	r24, Z+
    c696:	93 ff       	sbrs	r25, 3
    c698:	81 91       	ld	r24, Z+
    c69a:	ec 87       	std	Y+12, r30	; 0x0c
    c69c:	fd 87       	std	Y+13, r31	; 0x0d
    c69e:	88 23       	and	r24, r24
    c6a0:	09 f0       	breq	.+2      	; 0xc6a4 <vfprintf+0x118>
    c6a2:	b8 cf       	rjmp	.-144    	; 0xc614 <vfprintf+0x88>
    c6a4:	98 2f       	mov	r25, r24
    c6a6:	95 54       	subi	r25, 0x45	; 69
    c6a8:	93 30       	cpi	r25, 0x03	; 3
    c6aa:	18 f0       	brcs	.+6      	; 0xc6b2 <vfprintf+0x126>
    c6ac:	90 52       	subi	r25, 0x20	; 32
    c6ae:	93 30       	cpi	r25, 0x03	; 3
    c6b0:	38 f4       	brcc	.+14     	; 0xc6c0 <vfprintf+0x134>
    c6b2:	24 e0       	ldi	r18, 0x04	; 4
    c6b4:	30 e0       	ldi	r19, 0x00	; 0
    c6b6:	a2 0e       	add	r10, r18
    c6b8:	b3 1e       	adc	r11, r19
    c6ba:	3f e3       	ldi	r19, 0x3F	; 63
    c6bc:	39 83       	std	Y+1, r19	; 0x01
    c6be:	0f c0       	rjmp	.+30     	; 0xc6de <vfprintf+0x152>
    c6c0:	83 36       	cpi	r24, 0x63	; 99
    c6c2:	31 f0       	breq	.+12     	; 0xc6d0 <vfprintf+0x144>
    c6c4:	83 37       	cpi	r24, 0x73	; 115
    c6c6:	81 f0       	breq	.+32     	; 0xc6e8 <vfprintf+0x15c>
    c6c8:	83 35       	cpi	r24, 0x53	; 83
    c6ca:	09 f0       	breq	.+2      	; 0xc6ce <vfprintf+0x142>
    c6cc:	5a c0       	rjmp	.+180    	; 0xc782 <vfprintf+0x1f6>
    c6ce:	22 c0       	rjmp	.+68     	; 0xc714 <vfprintf+0x188>
    c6d0:	f5 01       	movw	r30, r10
    c6d2:	80 81       	ld	r24, Z
    c6d4:	89 83       	std	Y+1, r24	; 0x01
    c6d6:	22 e0       	ldi	r18, 0x02	; 2
    c6d8:	30 e0       	ldi	r19, 0x00	; 0
    c6da:	a2 0e       	add	r10, r18
    c6dc:	b3 1e       	adc	r11, r19
    c6de:	21 e0       	ldi	r18, 0x01	; 1
    c6e0:	c2 2e       	mov	r12, r18
    c6e2:	d1 2c       	mov	r13, r1
    c6e4:	42 01       	movw	r8, r4
    c6e6:	14 c0       	rjmp	.+40     	; 0xc710 <vfprintf+0x184>
    c6e8:	92 e0       	ldi	r25, 0x02	; 2
    c6ea:	29 2e       	mov	r2, r25
    c6ec:	31 2c       	mov	r3, r1
    c6ee:	2a 0c       	add	r2, r10
    c6f0:	3b 1c       	adc	r3, r11
    c6f2:	f5 01       	movw	r30, r10
    c6f4:	80 80       	ld	r8, Z
    c6f6:	91 80       	ldd	r9, Z+1	; 0x01
    c6f8:	16 ff       	sbrs	r17, 6
    c6fa:	03 c0       	rjmp	.+6      	; 0xc702 <vfprintf+0x176>
    c6fc:	6f 2d       	mov	r22, r15
    c6fe:	70 e0       	ldi	r23, 0x00	; 0
    c700:	02 c0       	rjmp	.+4      	; 0xc706 <vfprintf+0x17a>
    c702:	6f ef       	ldi	r22, 0xFF	; 255
    c704:	7f ef       	ldi	r23, 0xFF	; 255
    c706:	c4 01       	movw	r24, r8
    c708:	0e 94 d2 64 	call	0xc9a4	; 0xc9a4 <strnlen>
    c70c:	6c 01       	movw	r12, r24
    c70e:	51 01       	movw	r10, r2
    c710:	1f 77       	andi	r17, 0x7F	; 127
    c712:	15 c0       	rjmp	.+42     	; 0xc73e <vfprintf+0x1b2>
    c714:	82 e0       	ldi	r24, 0x02	; 2
    c716:	28 2e       	mov	r2, r24
    c718:	31 2c       	mov	r3, r1
    c71a:	2a 0c       	add	r2, r10
    c71c:	3b 1c       	adc	r3, r11
    c71e:	f5 01       	movw	r30, r10
    c720:	80 80       	ld	r8, Z
    c722:	91 80       	ldd	r9, Z+1	; 0x01
    c724:	16 ff       	sbrs	r17, 6
    c726:	03 c0       	rjmp	.+6      	; 0xc72e <vfprintf+0x1a2>
    c728:	6f 2d       	mov	r22, r15
    c72a:	70 e0       	ldi	r23, 0x00	; 0
    c72c:	02 c0       	rjmp	.+4      	; 0xc732 <vfprintf+0x1a6>
    c72e:	6f ef       	ldi	r22, 0xFF	; 255
    c730:	7f ef       	ldi	r23, 0xFF	; 255
    c732:	c4 01       	movw	r24, r8
    c734:	0e 94 c7 64 	call	0xc98e	; 0xc98e <strnlen_P>
    c738:	6c 01       	movw	r12, r24
    c73a:	10 68       	ori	r17, 0x80	; 128
    c73c:	51 01       	movw	r10, r2
    c73e:	13 fd       	sbrc	r17, 3
    c740:	1c c0       	rjmp	.+56     	; 0xc77a <vfprintf+0x1ee>
    c742:	06 c0       	rjmp	.+12     	; 0xc750 <vfprintf+0x1c4>
    c744:	80 e2       	ldi	r24, 0x20	; 32
    c746:	90 e0       	ldi	r25, 0x00	; 0
    c748:	b3 01       	movw	r22, r6
    c74a:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c74e:	ea 94       	dec	r14
    c750:	8e 2d       	mov	r24, r14
    c752:	90 e0       	ldi	r25, 0x00	; 0
    c754:	c8 16       	cp	r12, r24
    c756:	d9 06       	cpc	r13, r25
    c758:	a8 f3       	brcs	.-22     	; 0xc744 <vfprintf+0x1b8>
    c75a:	0f c0       	rjmp	.+30     	; 0xc77a <vfprintf+0x1ee>
    c75c:	f4 01       	movw	r30, r8
    c75e:	17 fd       	sbrc	r17, 7
    c760:	85 91       	lpm	r24, Z+
    c762:	17 ff       	sbrs	r17, 7
    c764:	81 91       	ld	r24, Z+
    c766:	4f 01       	movw	r8, r30
    c768:	90 e0       	ldi	r25, 0x00	; 0
    c76a:	b3 01       	movw	r22, r6
    c76c:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c770:	e1 10       	cpse	r14, r1
    c772:	ea 94       	dec	r14
    c774:	08 94       	sec
    c776:	c1 08       	sbc	r12, r1
    c778:	d1 08       	sbc	r13, r1
    c77a:	c1 14       	cp	r12, r1
    c77c:	d1 04       	cpc	r13, r1
    c77e:	71 f7       	brne	.-36     	; 0xc75c <vfprintf+0x1d0>
    c780:	e7 c0       	rjmp	.+462    	; 0xc950 <vfprintf+0x3c4>
    c782:	84 36       	cpi	r24, 0x64	; 100
    c784:	11 f0       	breq	.+4      	; 0xc78a <vfprintf+0x1fe>
    c786:	89 36       	cpi	r24, 0x69	; 105
    c788:	51 f5       	brne	.+84     	; 0xc7de <vfprintf+0x252>
    c78a:	f5 01       	movw	r30, r10
    c78c:	17 ff       	sbrs	r17, 7
    c78e:	07 c0       	rjmp	.+14     	; 0xc79e <vfprintf+0x212>
    c790:	80 81       	ld	r24, Z
    c792:	91 81       	ldd	r25, Z+1	; 0x01
    c794:	a2 81       	ldd	r26, Z+2	; 0x02
    c796:	b3 81       	ldd	r27, Z+3	; 0x03
    c798:	24 e0       	ldi	r18, 0x04	; 4
    c79a:	30 e0       	ldi	r19, 0x00	; 0
    c79c:	08 c0       	rjmp	.+16     	; 0xc7ae <vfprintf+0x222>
    c79e:	80 81       	ld	r24, Z
    c7a0:	91 81       	ldd	r25, Z+1	; 0x01
    c7a2:	aa 27       	eor	r26, r26
    c7a4:	97 fd       	sbrc	r25, 7
    c7a6:	a0 95       	com	r26
    c7a8:	ba 2f       	mov	r27, r26
    c7aa:	22 e0       	ldi	r18, 0x02	; 2
    c7ac:	30 e0       	ldi	r19, 0x00	; 0
    c7ae:	a2 0e       	add	r10, r18
    c7b0:	b3 1e       	adc	r11, r19
    c7b2:	01 2f       	mov	r16, r17
    c7b4:	0f 76       	andi	r16, 0x6F	; 111
    c7b6:	b7 ff       	sbrs	r27, 7
    c7b8:	08 c0       	rjmp	.+16     	; 0xc7ca <vfprintf+0x23e>
    c7ba:	b0 95       	com	r27
    c7bc:	a0 95       	com	r26
    c7be:	90 95       	com	r25
    c7c0:	81 95       	neg	r24
    c7c2:	9f 4f       	sbci	r25, 0xFF	; 255
    c7c4:	af 4f       	sbci	r26, 0xFF	; 255
    c7c6:	bf 4f       	sbci	r27, 0xFF	; 255
    c7c8:	00 68       	ori	r16, 0x80	; 128
    c7ca:	bc 01       	movw	r22, r24
    c7cc:	cd 01       	movw	r24, r26
    c7ce:	a2 01       	movw	r20, r4
    c7d0:	2a e0       	ldi	r18, 0x0A	; 10
    c7d2:	30 e0       	ldi	r19, 0x00	; 0
    c7d4:	0e 94 19 65 	call	0xca32	; 0xca32 <__ultoa_invert>
    c7d8:	d8 2e       	mov	r13, r24
    c7da:	d4 18       	sub	r13, r4
    c7dc:	3f c0       	rjmp	.+126    	; 0xc85c <vfprintf+0x2d0>
    c7de:	85 37       	cpi	r24, 0x75	; 117
    c7e0:	21 f4       	brne	.+8      	; 0xc7ea <vfprintf+0x25e>
    c7e2:	1f 7e       	andi	r17, 0xEF	; 239
    c7e4:	2a e0       	ldi	r18, 0x0A	; 10
    c7e6:	30 e0       	ldi	r19, 0x00	; 0
    c7e8:	20 c0       	rjmp	.+64     	; 0xc82a <vfprintf+0x29e>
    c7ea:	19 7f       	andi	r17, 0xF9	; 249
    c7ec:	8f 36       	cpi	r24, 0x6F	; 111
    c7ee:	a9 f0       	breq	.+42     	; 0xc81a <vfprintf+0x28e>
    c7f0:	80 37       	cpi	r24, 0x70	; 112
    c7f2:	20 f4       	brcc	.+8      	; 0xc7fc <vfprintf+0x270>
    c7f4:	88 35       	cpi	r24, 0x58	; 88
    c7f6:	09 f0       	breq	.+2      	; 0xc7fa <vfprintf+0x26e>
    c7f8:	ae c0       	rjmp	.+348    	; 0xc956 <vfprintf+0x3ca>
    c7fa:	0b c0       	rjmp	.+22     	; 0xc812 <vfprintf+0x286>
    c7fc:	80 37       	cpi	r24, 0x70	; 112
    c7fe:	21 f0       	breq	.+8      	; 0xc808 <vfprintf+0x27c>
    c800:	88 37       	cpi	r24, 0x78	; 120
    c802:	09 f0       	breq	.+2      	; 0xc806 <vfprintf+0x27a>
    c804:	a8 c0       	rjmp	.+336    	; 0xc956 <vfprintf+0x3ca>
    c806:	01 c0       	rjmp	.+2      	; 0xc80a <vfprintf+0x27e>
    c808:	10 61       	ori	r17, 0x10	; 16
    c80a:	14 ff       	sbrs	r17, 4
    c80c:	09 c0       	rjmp	.+18     	; 0xc820 <vfprintf+0x294>
    c80e:	14 60       	ori	r17, 0x04	; 4
    c810:	07 c0       	rjmp	.+14     	; 0xc820 <vfprintf+0x294>
    c812:	14 ff       	sbrs	r17, 4
    c814:	08 c0       	rjmp	.+16     	; 0xc826 <vfprintf+0x29a>
    c816:	16 60       	ori	r17, 0x06	; 6
    c818:	06 c0       	rjmp	.+12     	; 0xc826 <vfprintf+0x29a>
    c81a:	28 e0       	ldi	r18, 0x08	; 8
    c81c:	30 e0       	ldi	r19, 0x00	; 0
    c81e:	05 c0       	rjmp	.+10     	; 0xc82a <vfprintf+0x29e>
    c820:	20 e1       	ldi	r18, 0x10	; 16
    c822:	30 e0       	ldi	r19, 0x00	; 0
    c824:	02 c0       	rjmp	.+4      	; 0xc82a <vfprintf+0x29e>
    c826:	20 e1       	ldi	r18, 0x10	; 16
    c828:	32 e0       	ldi	r19, 0x02	; 2
    c82a:	f5 01       	movw	r30, r10
    c82c:	17 ff       	sbrs	r17, 7
    c82e:	07 c0       	rjmp	.+14     	; 0xc83e <vfprintf+0x2b2>
    c830:	60 81       	ld	r22, Z
    c832:	71 81       	ldd	r23, Z+1	; 0x01
    c834:	82 81       	ldd	r24, Z+2	; 0x02
    c836:	93 81       	ldd	r25, Z+3	; 0x03
    c838:	44 e0       	ldi	r20, 0x04	; 4
    c83a:	50 e0       	ldi	r21, 0x00	; 0
    c83c:	06 c0       	rjmp	.+12     	; 0xc84a <vfprintf+0x2be>
    c83e:	60 81       	ld	r22, Z
    c840:	71 81       	ldd	r23, Z+1	; 0x01
    c842:	80 e0       	ldi	r24, 0x00	; 0
    c844:	90 e0       	ldi	r25, 0x00	; 0
    c846:	42 e0       	ldi	r20, 0x02	; 2
    c848:	50 e0       	ldi	r21, 0x00	; 0
    c84a:	a4 0e       	add	r10, r20
    c84c:	b5 1e       	adc	r11, r21
    c84e:	a2 01       	movw	r20, r4
    c850:	0e 94 19 65 	call	0xca32	; 0xca32 <__ultoa_invert>
    c854:	d8 2e       	mov	r13, r24
    c856:	d4 18       	sub	r13, r4
    c858:	01 2f       	mov	r16, r17
    c85a:	0f 77       	andi	r16, 0x7F	; 127
    c85c:	06 ff       	sbrs	r16, 6
    c85e:	09 c0       	rjmp	.+18     	; 0xc872 <vfprintf+0x2e6>
    c860:	0e 7f       	andi	r16, 0xFE	; 254
    c862:	df 14       	cp	r13, r15
    c864:	30 f4       	brcc	.+12     	; 0xc872 <vfprintf+0x2e6>
    c866:	04 ff       	sbrs	r16, 4
    c868:	06 c0       	rjmp	.+12     	; 0xc876 <vfprintf+0x2ea>
    c86a:	02 fd       	sbrc	r16, 2
    c86c:	04 c0       	rjmp	.+8      	; 0xc876 <vfprintf+0x2ea>
    c86e:	0f 7e       	andi	r16, 0xEF	; 239
    c870:	02 c0       	rjmp	.+4      	; 0xc876 <vfprintf+0x2ea>
    c872:	1d 2d       	mov	r17, r13
    c874:	01 c0       	rjmp	.+2      	; 0xc878 <vfprintf+0x2ec>
    c876:	1f 2d       	mov	r17, r15
    c878:	80 2f       	mov	r24, r16
    c87a:	90 e0       	ldi	r25, 0x00	; 0
    c87c:	04 ff       	sbrs	r16, 4
    c87e:	0c c0       	rjmp	.+24     	; 0xc898 <vfprintf+0x30c>
    c880:	fe 01       	movw	r30, r28
    c882:	ed 0d       	add	r30, r13
    c884:	f1 1d       	adc	r31, r1
    c886:	20 81       	ld	r18, Z
    c888:	20 33       	cpi	r18, 0x30	; 48
    c88a:	11 f4       	brne	.+4      	; 0xc890 <vfprintf+0x304>
    c88c:	09 7e       	andi	r16, 0xE9	; 233
    c88e:	09 c0       	rjmp	.+18     	; 0xc8a2 <vfprintf+0x316>
    c890:	02 ff       	sbrs	r16, 2
    c892:	06 c0       	rjmp	.+12     	; 0xc8a0 <vfprintf+0x314>
    c894:	1e 5f       	subi	r17, 0xFE	; 254
    c896:	05 c0       	rjmp	.+10     	; 0xc8a2 <vfprintf+0x316>
    c898:	86 78       	andi	r24, 0x86	; 134
    c89a:	90 70       	andi	r25, 0x00	; 0
    c89c:	00 97       	sbiw	r24, 0x00	; 0
    c89e:	09 f0       	breq	.+2      	; 0xc8a2 <vfprintf+0x316>
    c8a0:	1f 5f       	subi	r17, 0xFF	; 255
    c8a2:	80 2e       	mov	r8, r16
    c8a4:	99 24       	eor	r9, r9
    c8a6:	03 fd       	sbrc	r16, 3
    c8a8:	12 c0       	rjmp	.+36     	; 0xc8ce <vfprintf+0x342>
    c8aa:	00 ff       	sbrs	r16, 0
    c8ac:	0d c0       	rjmp	.+26     	; 0xc8c8 <vfprintf+0x33c>
    c8ae:	fd 2c       	mov	r15, r13
    c8b0:	1e 15       	cp	r17, r14
    c8b2:	50 f4       	brcc	.+20     	; 0xc8c8 <vfprintf+0x33c>
    c8b4:	fe 0c       	add	r15, r14
    c8b6:	f1 1a       	sub	r15, r17
    c8b8:	1e 2d       	mov	r17, r14
    c8ba:	06 c0       	rjmp	.+12     	; 0xc8c8 <vfprintf+0x33c>
    c8bc:	80 e2       	ldi	r24, 0x20	; 32
    c8be:	90 e0       	ldi	r25, 0x00	; 0
    c8c0:	b3 01       	movw	r22, r6
    c8c2:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c8c6:	1f 5f       	subi	r17, 0xFF	; 255
    c8c8:	1e 15       	cp	r17, r14
    c8ca:	c0 f3       	brcs	.-16     	; 0xc8bc <vfprintf+0x330>
    c8cc:	04 c0       	rjmp	.+8      	; 0xc8d6 <vfprintf+0x34a>
    c8ce:	1e 15       	cp	r17, r14
    c8d0:	10 f4       	brcc	.+4      	; 0xc8d6 <vfprintf+0x34a>
    c8d2:	e1 1a       	sub	r14, r17
    c8d4:	01 c0       	rjmp	.+2      	; 0xc8d8 <vfprintf+0x34c>
    c8d6:	ee 24       	eor	r14, r14
    c8d8:	84 fe       	sbrs	r8, 4
    c8da:	0f c0       	rjmp	.+30     	; 0xc8fa <vfprintf+0x36e>
    c8dc:	80 e3       	ldi	r24, 0x30	; 48
    c8de:	90 e0       	ldi	r25, 0x00	; 0
    c8e0:	b3 01       	movw	r22, r6
    c8e2:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c8e6:	82 fe       	sbrs	r8, 2
    c8e8:	1f c0       	rjmp	.+62     	; 0xc928 <vfprintf+0x39c>
    c8ea:	81 fe       	sbrs	r8, 1
    c8ec:	03 c0       	rjmp	.+6      	; 0xc8f4 <vfprintf+0x368>
    c8ee:	88 e5       	ldi	r24, 0x58	; 88
    c8f0:	90 e0       	ldi	r25, 0x00	; 0
    c8f2:	10 c0       	rjmp	.+32     	; 0xc914 <vfprintf+0x388>
    c8f4:	88 e7       	ldi	r24, 0x78	; 120
    c8f6:	90 e0       	ldi	r25, 0x00	; 0
    c8f8:	0d c0       	rjmp	.+26     	; 0xc914 <vfprintf+0x388>
    c8fa:	c4 01       	movw	r24, r8
    c8fc:	86 78       	andi	r24, 0x86	; 134
    c8fe:	90 70       	andi	r25, 0x00	; 0
    c900:	00 97       	sbiw	r24, 0x00	; 0
    c902:	91 f0       	breq	.+36     	; 0xc928 <vfprintf+0x39c>
    c904:	81 fc       	sbrc	r8, 1
    c906:	02 c0       	rjmp	.+4      	; 0xc90c <vfprintf+0x380>
    c908:	80 e2       	ldi	r24, 0x20	; 32
    c90a:	01 c0       	rjmp	.+2      	; 0xc90e <vfprintf+0x382>
    c90c:	8b e2       	ldi	r24, 0x2B	; 43
    c90e:	07 fd       	sbrc	r16, 7
    c910:	8d e2       	ldi	r24, 0x2D	; 45
    c912:	90 e0       	ldi	r25, 0x00	; 0
    c914:	b3 01       	movw	r22, r6
    c916:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c91a:	06 c0       	rjmp	.+12     	; 0xc928 <vfprintf+0x39c>
    c91c:	80 e3       	ldi	r24, 0x30	; 48
    c91e:	90 e0       	ldi	r25, 0x00	; 0
    c920:	b3 01       	movw	r22, r6
    c922:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c926:	fa 94       	dec	r15
    c928:	df 14       	cp	r13, r15
    c92a:	c0 f3       	brcs	.-16     	; 0xc91c <vfprintf+0x390>
    c92c:	da 94       	dec	r13
    c92e:	f2 01       	movw	r30, r4
    c930:	ed 0d       	add	r30, r13
    c932:	f1 1d       	adc	r31, r1
    c934:	80 81       	ld	r24, Z
    c936:	90 e0       	ldi	r25, 0x00	; 0
    c938:	b3 01       	movw	r22, r6
    c93a:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c93e:	dd 20       	and	r13, r13
    c940:	a9 f7       	brne	.-22     	; 0xc92c <vfprintf+0x3a0>
    c942:	06 c0       	rjmp	.+12     	; 0xc950 <vfprintf+0x3c4>
    c944:	80 e2       	ldi	r24, 0x20	; 32
    c946:	90 e0       	ldi	r25, 0x00	; 0
    c948:	b3 01       	movw	r22, r6
    c94a:	0e 94 ed 64 	call	0xc9da	; 0xc9da <fputc>
    c94e:	ea 94       	dec	r14
    c950:	ee 20       	and	r14, r14
    c952:	c1 f7       	brne	.-16     	; 0xc944 <vfprintf+0x3b8>
    c954:	40 ce       	rjmp	.-896    	; 0xc5d6 <vfprintf+0x4a>
    c956:	f3 01       	movw	r30, r6
    c958:	86 81       	ldd	r24, Z+6	; 0x06
    c95a:	97 81       	ldd	r25, Z+7	; 0x07
    c95c:	02 c0       	rjmp	.+4      	; 0xc962 <vfprintf+0x3d6>
    c95e:	8f ef       	ldi	r24, 0xFF	; 255
    c960:	9f ef       	ldi	r25, 0xFF	; 255
    c962:	2d 96       	adiw	r28, 0x0d	; 13
    c964:	cd bf       	out	0x3d, r28	; 61
    c966:	de bf       	out	0x3e, r29	; 62
    c968:	df 91       	pop	r29
    c96a:	cf 91       	pop	r28
    c96c:	1f 91       	pop	r17
    c96e:	0f 91       	pop	r16
    c970:	ff 90       	pop	r15
    c972:	ef 90       	pop	r14
    c974:	df 90       	pop	r13
    c976:	cf 90       	pop	r12
    c978:	bf 90       	pop	r11
    c97a:	af 90       	pop	r10
    c97c:	9f 90       	pop	r9
    c97e:	8f 90       	pop	r8
    c980:	7f 90       	pop	r7
    c982:	6f 90       	pop	r6
    c984:	5f 90       	pop	r5
    c986:	4f 90       	pop	r4
    c988:	3f 90       	pop	r3
    c98a:	2f 90       	pop	r2
    c98c:	08 95       	ret

0000c98e <strnlen_P>:
    c98e:	fc 01       	movw	r30, r24
    c990:	05 90       	lpm	r0, Z+
    c992:	61 50       	subi	r22, 0x01	; 1
    c994:	70 40       	sbci	r23, 0x00	; 0
    c996:	01 10       	cpse	r0, r1
    c998:	d8 f7       	brcc	.-10     	; 0xc990 <strnlen_P+0x2>
    c99a:	80 95       	com	r24
    c99c:	90 95       	com	r25
    c99e:	8e 0f       	add	r24, r30
    c9a0:	9f 1f       	adc	r25, r31
    c9a2:	08 95       	ret

0000c9a4 <strnlen>:
    c9a4:	fc 01       	movw	r30, r24
    c9a6:	61 50       	subi	r22, 0x01	; 1
    c9a8:	70 40       	sbci	r23, 0x00	; 0
    c9aa:	01 90       	ld	r0, Z+
    c9ac:	01 10       	cpse	r0, r1
    c9ae:	d8 f7       	brcc	.-10     	; 0xc9a6 <strnlen+0x2>
    c9b0:	80 95       	com	r24
    c9b2:	90 95       	com	r25
    c9b4:	8e 0f       	add	r24, r30
    c9b6:	9f 1f       	adc	r25, r31
    c9b8:	08 95       	ret

0000c9ba <strrev>:
    c9ba:	dc 01       	movw	r26, r24
    c9bc:	fc 01       	movw	r30, r24
    c9be:	67 2f       	mov	r22, r23
    c9c0:	71 91       	ld	r23, Z+
    c9c2:	77 23       	and	r23, r23
    c9c4:	e1 f7       	brne	.-8      	; 0xc9be <strrev+0x4>
    c9c6:	32 97       	sbiw	r30, 0x02	; 2
    c9c8:	04 c0       	rjmp	.+8      	; 0xc9d2 <strrev+0x18>
    c9ca:	7c 91       	ld	r23, X
    c9cc:	6d 93       	st	X+, r22
    c9ce:	70 83       	st	Z, r23
    c9d0:	62 91       	ld	r22, -Z
    c9d2:	ae 17       	cp	r26, r30
    c9d4:	bf 07       	cpc	r27, r31
    c9d6:	c8 f3       	brcs	.-14     	; 0xc9ca <strrev+0x10>
    c9d8:	08 95       	ret

0000c9da <fputc>:
    c9da:	0f 93       	push	r16
    c9dc:	1f 93       	push	r17
    c9de:	cf 93       	push	r28
    c9e0:	df 93       	push	r29
    c9e2:	8c 01       	movw	r16, r24
    c9e4:	eb 01       	movw	r28, r22
    c9e6:	8b 81       	ldd	r24, Y+3	; 0x03
    c9e8:	81 ff       	sbrs	r24, 1
    c9ea:	1b c0       	rjmp	.+54     	; 0xca22 <fputc+0x48>
    c9ec:	82 ff       	sbrs	r24, 2
    c9ee:	0d c0       	rjmp	.+26     	; 0xca0a <fputc+0x30>
    c9f0:	2e 81       	ldd	r18, Y+6	; 0x06
    c9f2:	3f 81       	ldd	r19, Y+7	; 0x07
    c9f4:	8c 81       	ldd	r24, Y+4	; 0x04
    c9f6:	9d 81       	ldd	r25, Y+5	; 0x05
    c9f8:	28 17       	cp	r18, r24
    c9fa:	39 07       	cpc	r19, r25
    c9fc:	64 f4       	brge	.+24     	; 0xca16 <fputc+0x3c>
    c9fe:	e8 81       	ld	r30, Y
    ca00:	f9 81       	ldd	r31, Y+1	; 0x01
    ca02:	01 93       	st	Z+, r16
    ca04:	e8 83       	st	Y, r30
    ca06:	f9 83       	std	Y+1, r31	; 0x01
    ca08:	06 c0       	rjmp	.+12     	; 0xca16 <fputc+0x3c>
    ca0a:	e8 85       	ldd	r30, Y+8	; 0x08
    ca0c:	f9 85       	ldd	r31, Y+9	; 0x09
    ca0e:	80 2f       	mov	r24, r16
    ca10:	19 95       	eicall
    ca12:	00 97       	sbiw	r24, 0x00	; 0
    ca14:	31 f4       	brne	.+12     	; 0xca22 <fputc+0x48>
    ca16:	8e 81       	ldd	r24, Y+6	; 0x06
    ca18:	9f 81       	ldd	r25, Y+7	; 0x07
    ca1a:	01 96       	adiw	r24, 0x01	; 1
    ca1c:	8e 83       	std	Y+6, r24	; 0x06
    ca1e:	9f 83       	std	Y+7, r25	; 0x07
    ca20:	02 c0       	rjmp	.+4      	; 0xca26 <fputc+0x4c>
    ca22:	0f ef       	ldi	r16, 0xFF	; 255
    ca24:	1f ef       	ldi	r17, 0xFF	; 255
    ca26:	c8 01       	movw	r24, r16
    ca28:	df 91       	pop	r29
    ca2a:	cf 91       	pop	r28
    ca2c:	1f 91       	pop	r17
    ca2e:	0f 91       	pop	r16
    ca30:	08 95       	ret

0000ca32 <__ultoa_invert>:
    ca32:	fa 01       	movw	r30, r20
    ca34:	aa 27       	eor	r26, r26
    ca36:	28 30       	cpi	r18, 0x08	; 8
    ca38:	51 f1       	breq	.+84     	; 0xca8e <__ultoa_invert+0x5c>
    ca3a:	20 31       	cpi	r18, 0x10	; 16
    ca3c:	81 f1       	breq	.+96     	; 0xca9e <__ultoa_invert+0x6c>
    ca3e:	e8 94       	clt
    ca40:	6f 93       	push	r22
    ca42:	6e 7f       	andi	r22, 0xFE	; 254
    ca44:	6e 5f       	subi	r22, 0xFE	; 254
    ca46:	7f 4f       	sbci	r23, 0xFF	; 255
    ca48:	8f 4f       	sbci	r24, 0xFF	; 255
    ca4a:	9f 4f       	sbci	r25, 0xFF	; 255
    ca4c:	af 4f       	sbci	r26, 0xFF	; 255
    ca4e:	b1 e0       	ldi	r27, 0x01	; 1
    ca50:	3e d0       	rcall	.+124    	; 0xcace <__ultoa_invert+0x9c>
    ca52:	b4 e0       	ldi	r27, 0x04	; 4
    ca54:	3c d0       	rcall	.+120    	; 0xcace <__ultoa_invert+0x9c>
    ca56:	67 0f       	add	r22, r23
    ca58:	78 1f       	adc	r23, r24
    ca5a:	89 1f       	adc	r24, r25
    ca5c:	9a 1f       	adc	r25, r26
    ca5e:	a1 1d       	adc	r26, r1
    ca60:	68 0f       	add	r22, r24
    ca62:	79 1f       	adc	r23, r25
    ca64:	8a 1f       	adc	r24, r26
    ca66:	91 1d       	adc	r25, r1
    ca68:	a1 1d       	adc	r26, r1
    ca6a:	6a 0f       	add	r22, r26
    ca6c:	71 1d       	adc	r23, r1
    ca6e:	81 1d       	adc	r24, r1
    ca70:	91 1d       	adc	r25, r1
    ca72:	a1 1d       	adc	r26, r1
    ca74:	20 d0       	rcall	.+64     	; 0xcab6 <__ultoa_invert+0x84>
    ca76:	09 f4       	brne	.+2      	; 0xca7a <__ultoa_invert+0x48>
    ca78:	68 94       	set
    ca7a:	3f 91       	pop	r19
    ca7c:	2a e0       	ldi	r18, 0x0A	; 10
    ca7e:	26 9f       	mul	r18, r22
    ca80:	11 24       	eor	r1, r1
    ca82:	30 19       	sub	r19, r0
    ca84:	30 5d       	subi	r19, 0xD0	; 208
    ca86:	31 93       	st	Z+, r19
    ca88:	de f6       	brtc	.-74     	; 0xca40 <__ultoa_invert+0xe>
    ca8a:	cf 01       	movw	r24, r30
    ca8c:	08 95       	ret
    ca8e:	46 2f       	mov	r20, r22
    ca90:	47 70       	andi	r20, 0x07	; 7
    ca92:	40 5d       	subi	r20, 0xD0	; 208
    ca94:	41 93       	st	Z+, r20
    ca96:	b3 e0       	ldi	r27, 0x03	; 3
    ca98:	0f d0       	rcall	.+30     	; 0xcab8 <__ultoa_invert+0x86>
    ca9a:	c9 f7       	brne	.-14     	; 0xca8e <__ultoa_invert+0x5c>
    ca9c:	f6 cf       	rjmp	.-20     	; 0xca8a <__ultoa_invert+0x58>
    ca9e:	46 2f       	mov	r20, r22
    caa0:	4f 70       	andi	r20, 0x0F	; 15
    caa2:	40 5d       	subi	r20, 0xD0	; 208
    caa4:	4a 33       	cpi	r20, 0x3A	; 58
    caa6:	18 f0       	brcs	.+6      	; 0xcaae <__ultoa_invert+0x7c>
    caa8:	49 5d       	subi	r20, 0xD9	; 217
    caaa:	31 fd       	sbrc	r19, 1
    caac:	40 52       	subi	r20, 0x20	; 32
    caae:	41 93       	st	Z+, r20
    cab0:	02 d0       	rcall	.+4      	; 0xcab6 <__ultoa_invert+0x84>
    cab2:	a9 f7       	brne	.-22     	; 0xca9e <__ultoa_invert+0x6c>
    cab4:	ea cf       	rjmp	.-44     	; 0xca8a <__ultoa_invert+0x58>
    cab6:	b4 e0       	ldi	r27, 0x04	; 4
    cab8:	a6 95       	lsr	r26
    caba:	97 95       	ror	r25
    cabc:	87 95       	ror	r24
    cabe:	77 95       	ror	r23
    cac0:	67 95       	ror	r22
    cac2:	ba 95       	dec	r27
    cac4:	c9 f7       	brne	.-14     	; 0xcab8 <__ultoa_invert+0x86>
    cac6:	00 97       	sbiw	r24, 0x00	; 0
    cac8:	61 05       	cpc	r22, r1
    caca:	71 05       	cpc	r23, r1
    cacc:	08 95       	ret
    cace:	9b 01       	movw	r18, r22
    cad0:	ac 01       	movw	r20, r24
    cad2:	0a 2e       	mov	r0, r26
    cad4:	06 94       	lsr	r0
    cad6:	57 95       	ror	r21
    cad8:	47 95       	ror	r20
    cada:	37 95       	ror	r19
    cadc:	27 95       	ror	r18
    cade:	ba 95       	dec	r27
    cae0:	c9 f7       	brne	.-14     	; 0xcad4 <__ultoa_invert+0xa2>
    cae2:	62 0f       	add	r22, r18
    cae4:	73 1f       	adc	r23, r19
    cae6:	84 1f       	adc	r24, r20
    cae8:	95 1f       	adc	r25, r21
    caea:	a0 1d       	adc	r26, r0
    caec:	08 95       	ret

0000caee <_exit>:
    caee:	f8 94       	cli

0000caf0 <__stop_program>:
    caf0:	ff cf       	rjmp	.-2      	; 0xcaf0 <__stop_program>
