
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c896  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000130  00802000  0000c896  0000c92a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa5  00802130  00802130  0000ca5a  2**0
                  ALLOC
  3 .stab         00002f64  00000000  00000000  0000ca5c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b51  00000000  00000000  0000f9c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000400  00000000  00000000  00010518  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d2ae  00000000  00000000  00010918  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000220f  00000000  00000000  0001dbc6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005ad8  00000000  00000000  0001fdd5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001df0  00000000  00000000  000258b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004696  00000000  00000000  000276a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005506  00000000  00000000  0002bd36  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b174  00000000  00000000  0003123c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000100  00000000  00000000  0018c3b0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 4a 11 	jmp	0x2294	; 0x2294 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 5e 10 	jmp	0x20bc	; 0x20bc <__vector_16>
      44:	0c 94 8e 10 	jmp	0x211c	; 0x211c <__vector_17>
      48:	0c 94 be 10 	jmp	0x217c	; 0x217c <__vector_18>
      4c:	0c 94 ee 10 	jmp	0x21dc	; 0x21dc <__vector_19>
      50:	0c 94 3f 0c 	jmp	0x187e	; 0x187e <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 6f 41 	jmp	0x82de	; 0x82de <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 3b 31 	jmp	0x6276	; 0x6276 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 fc 15 	jmp	0x2bf8	; 0x2bf8 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 3a 15 	jmp	0x2a74	; 0x2a74 <__vector_79>
     140:	0c 94 6a 15 	jmp	0x2ad4	; 0x2ad4 <__vector_80>
     144:	0c 94 9a 15 	jmp	0x2b34	; 0x2b34 <__vector_81>
     148:	0c 94 ca 15 	jmp	0x2b94	; 0x2b94 <__vector_82>
     14c:	0c 94 5d 04 	jmp	0x8ba	; 0x8ba <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 15 0d 	jmp	0x1a2a	; 0x1a2a <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e6 e9       	ldi	r30, 0x96	; 150
     244:	f8 ec       	ldi	r31, 0xC8	; 200
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a0 33       	cpi	r26, 0x30	; 48
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a0 e3       	ldi	r26, 0x30	; 48
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a5 3d       	cpi	r26, 0xD5	; 213
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 9e 02 	call	0x53c	; 0x53c <main>
     26a:	0c 94 49 64 	jmp	0xc892	; 0xc892 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	ef 92       	push	r14
     274:	ff 92       	push	r15
     276:	0f 93       	push	r16
     278:	1f 93       	push	r17
     27a:	cf 93       	push	r28
     27c:	df 93       	push	r29
     27e:	00 d0       	rcall	.+0      	; 0x280 <StartSerial+0xe>
     280:	00 d0       	rcall	.+0      	; 0x282 <StartSerial+0x10>
     282:	cd b7       	in	r28, 0x3d	; 61
     284:	de b7       	in	r29, 0x3e	; 62
     286:	6b 83       	std	Y+3, r22	; 0x03
     288:	7c 83       	std	Y+4, r23	; 0x04
     28a:	8d 83       	std	Y+5, r24	; 0x05
     28c:	9e 83       	std	Y+6, r25	; 0x06
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     28e:	8b 81       	ldd	r24, Y+3	; 0x03
     290:	9c 81       	ldd	r25, Y+4	; 0x04
     292:	ad 81       	ldd	r26, Y+5	; 0x05
     294:	be 81       	ldd	r27, Y+6	; 0x06
     296:	88 35       	cpi	r24, 0x58	; 88
     298:	22 e0       	ldi	r18, 0x02	; 2
     29a:	92 07       	cpc	r25, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	a2 07       	cpc	r26, r18
     2a0:	20 e0       	ldi	r18, 0x00	; 0
     2a2:	b2 07       	cpc	r27, r18
     2a4:	60 f0       	brcs	.+24     	; 0x2be <StartSerial+0x4c>
     2a6:	8b 81       	ldd	r24, Y+3	; 0x03
     2a8:	9c 81       	ldd	r25, Y+4	; 0x04
     2aa:	ad 81       	ldd	r26, Y+5	; 0x05
     2ac:	be 81       	ldd	r27, Y+6	; 0x06
     2ae:	81 34       	cpi	r24, 0x41	; 65
     2b0:	e2 e4       	ldi	r30, 0x42	; 66
     2b2:	9e 07       	cpc	r25, r30
     2b4:	ef e0       	ldi	r30, 0x0F	; 15
     2b6:	ae 07       	cpc	r26, r30
     2b8:	e0 e0       	ldi	r30, 0x00	; 0
     2ba:	be 07       	cpc	r27, r30
     2bc:	10 f0       	brcs	.+4      	; 0x2c2 <StartSerial+0x50>
		//baud rate too fast or too slow
		return false;
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	af c0       	rjmp	.+350    	; 0x420 <StartSerial+0x1ae>
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2c2:	0e 94 29 35 	call	0x6a52	; 0x6a52 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2c6:	80 e4       	ldi	r24, 0x40	; 64
     2c8:	96 e0       	ldi	r25, 0x06	; 6
     2ca:	28 e0       	ldi	r18, 0x08	; 8
     2cc:	fc 01       	movw	r30, r24
     2ce:	21 83       	std	Z+1, r18	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2d0:	80 e4       	ldi	r24, 0x40	; 64
     2d2:	96 e0       	ldi	r25, 0x06	; 6
     2d4:	28 e0       	ldi	r18, 0x08	; 8
     2d6:	fc 01       	movw	r30, r24
     2d8:	25 83       	std	Z+5, r18	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2da:	80 e4       	ldi	r24, 0x40	; 64
     2dc:	96 e0       	ldi	r25, 0x06	; 6
     2de:	24 e0       	ldi	r18, 0x04	; 4
     2e0:	fc 01       	movw	r30, r24
     2e2:	22 83       	std	Z+2, r18	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2e4:	8b 81       	ldd	r24, Y+3	; 0x03
     2e6:	9c 81       	ldd	r25, Y+4	; 0x04
     2e8:	ad 81       	ldd	r26, Y+5	; 0x05
     2ea:	be 81       	ldd	r27, Y+6	; 0x06
     2ec:	88 0f       	add	r24, r24
     2ee:	99 1f       	adc	r25, r25
     2f0:	aa 1f       	adc	r26, r26
     2f2:	bb 1f       	adc	r27, r27
     2f4:	88 0f       	add	r24, r24
     2f6:	99 1f       	adc	r25, r25
     2f8:	aa 1f       	adc	r26, r26
     2fa:	bb 1f       	adc	r27, r27
     2fc:	88 0f       	add	r24, r24
     2fe:	99 1f       	adc	r25, r25
     300:	aa 1f       	adc	r26, r26
     302:	bb 1f       	adc	r27, r27
     304:	88 0f       	add	r24, r24
     306:	99 1f       	adc	r25, r25
     308:	aa 1f       	adc	r26, r26
     30a:	bb 1f       	adc	r27, r27
     30c:	bc 01       	movw	r22, r24
     30e:	cd 01       	movw	r24, r26
     310:	0e 94 34 5f 	call	0xbe68	; 0xbe68 <__floatunsisf>
     314:	9b 01       	movw	r18, r22
     316:	ac 01       	movw	r20, r24
     318:	60 e0       	ldi	r22, 0x00	; 0
     31a:	74 e2       	ldi	r23, 0x24	; 36
     31c:	84 ef       	ldi	r24, 0xF4	; 244
     31e:	9b e4       	ldi	r25, 0x4B	; 75
     320:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
     324:	dc 01       	movw	r26, r24
     326:	cb 01       	movw	r24, r22
     328:	bc 01       	movw	r22, r24
     32a:	cd 01       	movw	r24, r26
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	40 e8       	ldi	r20, 0x80	; 128
     332:	5f e3       	ldi	r21, 0x3F	; 63
     334:	0e 94 37 5e 	call	0xbc6e	; 0xbc6e <__subsf3>
     338:	dc 01       	movw	r26, r24
     33a:	cb 01       	movw	r24, r22
     33c:	bc 01       	movw	r22, r24
     33e:	cd 01       	movw	r24, r26
     340:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
     344:	dc 01       	movw	r26, r24
     346:	cb 01       	movw	r24, r22
     348:	89 83       	std	Y+1, r24	; 0x01
     34a:	9a 83       	std	Y+2, r25	; 0x02
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     34c:	8b 81       	ldd	r24, Y+3	; 0x03
     34e:	9c 81       	ldd	r25, Y+4	; 0x04
     350:	ad 81       	ldd	r26, Y+5	; 0x05
     352:	be 81       	ldd	r27, Y+6	; 0x06
     354:	88 0f       	add	r24, r24
     356:	99 1f       	adc	r25, r25
     358:	aa 1f       	adc	r26, r26
     35a:	bb 1f       	adc	r27, r27
     35c:	88 0f       	add	r24, r24
     35e:	99 1f       	adc	r25, r25
     360:	aa 1f       	adc	r26, r26
     362:	bb 1f       	adc	r27, r27
     364:	88 0f       	add	r24, r24
     366:	99 1f       	adc	r25, r25
     368:	aa 1f       	adc	r26, r26
     36a:	bb 1f       	adc	r27, r27
     36c:	88 0f       	add	r24, r24
     36e:	99 1f       	adc	r25, r25
     370:	aa 1f       	adc	r26, r26
     372:	bb 1f       	adc	r27, r27
     374:	bc 01       	movw	r22, r24
     376:	cd 01       	movw	r24, r26
     378:	0e 94 34 5f 	call	0xbe68	; 0xbe68 <__floatunsisf>
     37c:	9b 01       	movw	r18, r22
     37e:	ac 01       	movw	r20, r24
     380:	60 e0       	ldi	r22, 0x00	; 0
     382:	74 e2       	ldi	r23, 0x24	; 36
     384:	84 ef       	ldi	r24, 0xF4	; 244
     386:	9b e4       	ldi	r25, 0x4B	; 75
     388:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
     38c:	dc 01       	movw	r26, r24
     38e:	cb 01       	movw	r24, r22
     390:	bc 01       	movw	r22, r24
     392:	cd 01       	movw	r24, r26
     394:	20 e0       	ldi	r18, 0x00	; 0
     396:	30 e0       	ldi	r19, 0x00	; 0
     398:	40 e8       	ldi	r20, 0x80	; 128
     39a:	5f e3       	ldi	r21, 0x3F	; 63
     39c:	0e 94 37 5e 	call	0xbc6e	; 0xbc6e <__subsf3>
     3a0:	dc 01       	movw	r26, r24
     3a2:	cb 01       	movw	r24, r22
     3a4:	7c 01       	movw	r14, r24
     3a6:	8d 01       	movw	r16, r26
     3a8:	89 81       	ldd	r24, Y+1	; 0x01
     3aa:	9a 81       	ldd	r25, Y+2	; 0x02
     3ac:	cc 01       	movw	r24, r24
     3ae:	a0 e0       	ldi	r26, 0x00	; 0
     3b0:	b0 e0       	ldi	r27, 0x00	; 0
     3b2:	bc 01       	movw	r22, r24
     3b4:	cd 01       	movw	r24, r26
     3b6:	0e 94 34 5f 	call	0xbe68	; 0xbe68 <__floatunsisf>
     3ba:	9b 01       	movw	r18, r22
     3bc:	ac 01       	movw	r20, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	b7 01       	movw	r22, r14
     3c2:	0e 94 37 5e 	call	0xbc6e	; 0xbc6e <__subsf3>
     3c6:	dc 01       	movw	r26, r24
     3c8:	cb 01       	movw	r24, r22
     3ca:	11 e0       	ldi	r17, 0x01	; 1
     3cc:	bc 01       	movw	r22, r24
     3ce:	cd 01       	movw	r24, r26
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	40 e0       	ldi	r20, 0x00	; 0
     3d6:	5f e3       	ldi	r21, 0x3F	; 63
     3d8:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
     3dc:	88 23       	and	r24, r24
     3de:	0c f4       	brge	.+2      	; 0x3e2 <StartSerial+0x170>
     3e0:	10 e0       	ldi	r17, 0x00	; 0
     3e2:	11 23       	and	r17, r17
     3e4:	29 f0       	breq	.+10     	; 0x3f0 <StartSerial+0x17e>
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	9a 81       	ldd	r25, Y+2	; 0x02
     3ea:	01 96       	adiw	r24, 0x01	; 1
     3ec:	89 83       	std	Y+1, r24	; 0x01
     3ee:	9a 83       	std	Y+2, r25	; 0x02
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     3f0:	80 ea       	ldi	r24, 0xA0	; 160
     3f2:	98 e0       	ldi	r25, 0x08	; 8
     3f4:	29 81       	ldd	r18, Y+1	; 0x01
     3f6:	fc 01       	movw	r30, r24
     3f8:	26 83       	std	Z+6, r18	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     3fa:	80 ea       	ldi	r24, 0xA0	; 160
     3fc:	98 e0       	ldi	r25, 0x08	; 8
     3fe:	29 81       	ldd	r18, Y+1	; 0x01
     400:	3a 81       	ldd	r19, Y+2	; 0x02
     402:	23 2f       	mov	r18, r19
     404:	33 27       	eor	r19, r19
     406:	fc 01       	movw	r30, r24
     408:	27 83       	std	Z+7, r18	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     40a:	80 ea       	ldi	r24, 0xA0	; 160
     40c:	98 e0       	ldi	r25, 0x08	; 8
     40e:	23 e0       	ldi	r18, 0x03	; 3
     410:	fc 01       	movw	r30, r24
     412:	25 83       	std	Z+5, r18	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     414:	80 ea       	ldi	r24, 0xA0	; 160
     416:	98 e0       	ldi	r25, 0x08	; 8
     418:	28 e1       	ldi	r18, 0x18	; 24
     41a:	fc 01       	movw	r30, r24
     41c:	24 83       	std	Z+4, r18	; 0x04
	return true;
     41e:	81 e0       	ldi	r24, 0x01	; 1
}
     420:	26 96       	adiw	r28, 0x06	; 6
     422:	cd bf       	out	0x3d, r28	; 61
     424:	de bf       	out	0x3e, r29	; 62
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	0f 91       	pop	r16
     42e:	ff 90       	pop	r15
     430:	ef 90       	pop	r14
     432:	08 95       	ret

00000434 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	0f 92       	push	r0
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
     43e:	89 83       	std	Y+1, r24	; 0x01
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     440:	00 00       	nop
     442:	80 ea       	ldi	r24, 0xA0	; 160
     444:	98 e0       	ldi	r25, 0x08	; 8
     446:	fc 01       	movw	r30, r24
     448:	81 81       	ldd	r24, Z+1	; 0x01
     44a:	88 2f       	mov	r24, r24
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	80 72       	andi	r24, 0x20	; 32
     450:	90 70       	andi	r25, 0x00	; 0
     452:	00 97       	sbiw	r24, 0x00	; 0
     454:	b1 f3       	breq	.-20     	; 0x442 <SerialWriteByte+0xe>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     456:	80 ea       	ldi	r24, 0xA0	; 160
     458:	98 e0       	ldi	r25, 0x08	; 8
     45a:	29 81       	ldd	r18, Y+1	; 0x01
     45c:	fc 01       	movw	r30, r24
     45e:	20 83       	st	Z, r18
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     460:	0f 90       	pop	r0
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	08 95       	ret

00000468 <SerialReadByte>:

uint8_t SerialReadByte(){
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	0f 92       	push	r0
     46e:	cd b7       	in	r28, 0x3d	; 61
     470:	de b7       	in	r29, 0x3e	; 62
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     472:	00 00       	nop
     474:	80 ea       	ldi	r24, 0xA0	; 160
     476:	98 e0       	ldi	r25, 0x08	; 8
     478:	fc 01       	movw	r30, r24
     47a:	81 81       	ldd	r24, Z+1	; 0x01
     47c:	88 23       	and	r24, r24
     47e:	d4 f7       	brge	.-12     	; 0x474 <SerialReadByte+0xc>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     480:	80 ea       	ldi	r24, 0xA0	; 160
     482:	98 e0       	ldi	r25, 0x08	; 8
     484:	fc 01       	movw	r30, r24
     486:	80 81       	ld	r24, Z
     488:	89 83       	std	Y+1, r24	; 0x01
	return byte;	
     48a:	89 81       	ldd	r24, Y+1	; 0x01
}
     48c:	0f 90       	pop	r0
     48e:	df 91       	pop	r29
     490:	cf 91       	pop	r28
     492:	08 95       	ret

00000494 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     494:	cf 93       	push	r28
     496:	df 93       	push	r29
     498:	cd b7       	in	r28, 0x3d	; 61
     49a:	de b7       	in	r29, 0x3e	; 62
     49c:	2a 97       	sbiw	r28, 0x0a	; 10
     49e:	cd bf       	out	0x3d, r28	; 61
     4a0:	de bf       	out	0x3e, r29	; 62
     4a2:	8d 83       	std	Y+5, r24	; 0x05
     4a4:	9e 83       	std	Y+6, r25	; 0x06
     4a6:	4f 83       	std	Y+7, r20	; 0x07
     4a8:	58 87       	std	Y+8, r21	; 0x08
     4aa:	69 87       	std	Y+9, r22	; 0x09
     4ac:	7a 87       	std	Y+10, r23	; 0x0a
	uint32_t i;
	for(i=0;i<length;i++){
     4ae:	19 82       	std	Y+1, r1	; 0x01
     4b0:	1a 82       	std	Y+2, r1	; 0x02
     4b2:	1b 82       	std	Y+3, r1	; 0x03
     4b4:	1c 82       	std	Y+4, r1	; 0x04
     4b6:	15 c0       	rjmp	.+42     	; 0x4e2 <SerialWriteBuffer+0x4e>
		SerialWriteByte(buffer[i]);
     4b8:	89 81       	ldd	r24, Y+1	; 0x01
     4ba:	9a 81       	ldd	r25, Y+2	; 0x02
     4bc:	2d 81       	ldd	r18, Y+5	; 0x05
     4be:	3e 81       	ldd	r19, Y+6	; 0x06
     4c0:	82 0f       	add	r24, r18
     4c2:	93 1f       	adc	r25, r19
     4c4:	fc 01       	movw	r30, r24
     4c6:	80 81       	ld	r24, Z
     4c8:	0e 94 1a 02 	call	0x434	; 0x434 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     4cc:	89 81       	ldd	r24, Y+1	; 0x01
     4ce:	9a 81       	ldd	r25, Y+2	; 0x02
     4d0:	ab 81       	ldd	r26, Y+3	; 0x03
     4d2:	bc 81       	ldd	r27, Y+4	; 0x04
     4d4:	01 96       	adiw	r24, 0x01	; 1
     4d6:	a1 1d       	adc	r26, r1
     4d8:	b1 1d       	adc	r27, r1
     4da:	89 83       	std	Y+1, r24	; 0x01
     4dc:	9a 83       	std	Y+2, r25	; 0x02
     4de:	ab 83       	std	Y+3, r26	; 0x03
     4e0:	bc 83       	std	Y+4, r27	; 0x04
     4e2:	29 81       	ldd	r18, Y+1	; 0x01
     4e4:	3a 81       	ldd	r19, Y+2	; 0x02
     4e6:	4b 81       	ldd	r20, Y+3	; 0x03
     4e8:	5c 81       	ldd	r21, Y+4	; 0x04
     4ea:	8f 81       	ldd	r24, Y+7	; 0x07
     4ec:	98 85       	ldd	r25, Y+8	; 0x08
     4ee:	a9 85       	ldd	r26, Y+9	; 0x09
     4f0:	ba 85       	ldd	r27, Y+10	; 0x0a
     4f2:	28 17       	cp	r18, r24
     4f4:	39 07       	cpc	r19, r25
     4f6:	4a 07       	cpc	r20, r26
     4f8:	5b 07       	cpc	r21, r27
     4fa:	f0 f2       	brcs	.-68     	; 0x4b8 <SerialWriteBuffer+0x24>
		SerialWriteByte(buffer[i]);
	}
}
     4fc:	2a 96       	adiw	r28, 0x0a	; 10
     4fe:	cd bf       	out	0x3d, r28	; 61
     500:	de bf       	out	0x3e, r29	; 62
     502:	df 91       	pop	r29
     504:	cf 91       	pop	r28
     506:	08 95       	ret

00000508 <StopSerial>:

void StopSerial(){
     508:	cf 93       	push	r28
     50a:	df 93       	push	r29
     50c:	cd b7       	in	r28, 0x3d	; 61
     50e:	de b7       	in	r29, 0x3e	; 62
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     510:	80 ea       	ldi	r24, 0xA0	; 160
     512:	98 e0       	ldi	r25, 0x08	; 8
     514:	20 ea       	ldi	r18, 0xA0	; 160
     516:	38 e0       	ldi	r19, 0x08	; 8
     518:	f9 01       	movw	r30, r18
     51a:	24 81       	ldd	r18, Z+4	; 0x04
     51c:	27 7e       	andi	r18, 0xE7	; 231
     51e:	fc 01       	movw	r30, r24
     520:	24 83       	std	Z+4, r18	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     522:	80 e4       	ldi	r24, 0x40	; 64
     524:	96 e0       	ldi	r25, 0x06	; 6
     526:	28 e0       	ldi	r18, 0x08	; 8
     528:	fc 01       	movw	r30, r24
     52a:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     52c:	80 e4       	ldi	r24, 0x40	; 64
     52e:	96 e0       	ldi	r25, 0x06	; 6
     530:	28 e0       	ldi	r18, 0x08	; 8
     532:	fc 01       	movw	r30, r24
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	df 91       	pop	r29
     538:	cf 91       	pop	r28
     53a:	08 95       	ret

0000053c <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     53c:	0f 93       	push	r16
     53e:	1f 93       	push	r17
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	cd b7       	in	r28, 0x3d	; 61
     546:	de b7       	in	r29, 0x3e	; 62
     548:	a7 97       	sbiw	r28, 0x27	; 39
     54a:	cd bf       	out	0x3d, r28	; 61
     54c:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     54e:	19 82       	std	Y+1, r1	; 0x01
	uint8_t ack = 0;
     550:	1f 82       	std	Y+7, r1	; 0x07
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
     552:	80 ed       	ldi	r24, 0xD0	; 208
     554:	97 e0       	ldi	r25, 0x07	; 7
     556:	8a 83       	std	Y+2, r24	; 0x02
     558:	9b 83       	std	Y+3, r25	; 0x03
	volatile uint32_t samples = 0;
     55a:	19 86       	std	Y+9, r1	; 0x09
     55c:	1a 86       	std	Y+10, r1	; 0x0a
     55e:	1b 86       	std	Y+11, r1	; 0x0b
     560:	1c 86       	std	Y+12, r1	; 0x0c
	DataAvailable = 0;
     562:	10 92 cd 21 	sts	0x21CD, r1
	ADC_Sampling_Finished = 1;
     566:	81 e0       	ldi	r24, 0x01	; 1
     568:	80 93 c5 50 	sts	0x50C5, r24
	uint8_t RadioMessageBuffer[20];
	unsigned char ofile[] = {'o','u','t','p','u','t'};
     56c:	ce 01       	movw	r24, r28
     56e:	81 96       	adiw	r24, 0x21	; 33
     570:	20 e0       	ldi	r18, 0x00	; 0
     572:	30 e2       	ldi	r19, 0x20	; 32
     574:	46 e0       	ldi	r20, 0x06	; 6
     576:	f9 01       	movw	r30, r18
     578:	00 80       	ld	r0, Z
     57a:	2f 5f       	subi	r18, 0xFF	; 255
     57c:	3f 4f       	sbci	r19, 0xFF	; 255
     57e:	fc 01       	movw	r30, r24
     580:	00 82       	st	Z, r0
     582:	01 96       	adiw	r24, 0x01	; 1
     584:	41 50       	subi	r20, 0x01	; 1
     586:	44 23       	and	r20, r20
     588:	b1 f7       	brne	.-20     	; 0x576 <main+0x3a>
	set_32MHz();
     58a:	0e 94 29 35 	call	0x6a52	; 0x6a52 <set_32MHz>
	chb_init();
     58e:	0e 94 5d 22 	call	0x44ba	; 0x44ba <chb_init>
	chb_set_channel(1);
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	0e 94 06 29 	call	0x520c	; 0x520c <chb_set_channel>
	chb_set_short_addr(0x0001);
     598:	81 e0       	ldi	r24, 0x01	; 1
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	0e 94 02 2f 	call	0x5e04	; 0x5e04 <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     5a0:	0e 94 9e 22 	call	0x453c	; 0x453c <chb_get_pcb>
     5a4:	8c 83       	std	Y+4, r24	; 0x04
     5a6:	9d 83       	std	Y+5, r25	; 0x05
     5a8:	01 c0       	rjmp	.+2      	; 0x5ac <main+0x70>
// 			//get number of data points collected
// 			samples = ADC_Get_Num_Samples();
// 			if(samples > 0) chb_write(0x0000,FRAMReadBuffer,samples*4);
// 			DataAvailable = 0;
// 		}	
	}	
     5aa:	00 00       	nop
	chb_set_short_addr(0x0001);
	pcb_t* pcb = chb_get_pcb();
	//SD_init();
	//getBootSectorData();
	while(1){
		if(pcb->data_rcv){
     5ac:	8c 81       	ldd	r24, Y+4	; 0x04
     5ae:	9d 81       	ldd	r25, Y+5	; 0x05
     5b0:	fc 01       	movw	r30, r24
     5b2:	83 81       	ldd	r24, Z+3	; 0x03
     5b4:	88 23       	and	r24, r24
     5b6:	c9 f3       	breq	.-14     	; 0x5aa <main+0x6e>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     5b8:	ce 01       	movw	r24, r28
     5ba:	0d 96       	adiw	r24, 0x0d	; 13
     5bc:	0e 94 c9 23 	call	0x4792	; 0x4792 <chb_read>
     5c0:	8e 83       	std	Y+6, r24	; 0x06
			//length should be >1 for setting gain/freq commands: the value is likely sent in a separate message 
			//if(length == 1){
				switch ( RadioMessageBuffer[0])
     5c2:	8d 85       	ldd	r24, Y+13	; 0x0d
     5c4:	88 2f       	mov	r24, r24
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	82 35       	cpi	r24, 0x52	; 82
     5ca:	91 05       	cpc	r25, r1
     5cc:	a1 f0       	breq	.+40     	; 0x5f6 <main+0xba>
     5ce:	83 35       	cpi	r24, 0x53	; 83
     5d0:	91 05       	cpc	r25, r1
     5d2:	44 f4       	brge	.+16     	; 0x5e4 <main+0xa8>
     5d4:	86 34       	cpi	r24, 0x46	; 70
     5d6:	91 05       	cpc	r25, r1
     5d8:	09 f4       	brne	.+2      	; 0x5dc <main+0xa0>
     5da:	7c c0       	rjmp	.+248    	; 0x6d4 <main+0x198>
     5dc:	87 34       	cpi	r24, 0x47	; 71
     5de:	91 05       	cpc	r25, r1
     5e0:	39 f1       	breq	.+78     	; 0x630 <main+0xf4>
     5e2:	15 c1       	rjmp	.+554    	; 0x80e <main+0x2d2>
     5e4:	83 35       	cpi	r24, 0x53	; 83
     5e6:	91 05       	cpc	r25, r1
     5e8:	09 f4       	brne	.+2      	; 0x5ec <main+0xb0>
     5ea:	8b c0       	rjmp	.+278    	; 0x702 <main+0x1c6>
     5ec:	84 35       	cpi	r24, 0x54	; 84
     5ee:	91 05       	cpc	r25, r1
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <main+0xb8>
     5f2:	9a c0       	rjmp	.+308    	; 0x728 <main+0x1ec>
     5f4:	0c c1       	rjmp	.+536    	; 0x80e <main+0x2d2>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     5f6:	80 91 c5 50 	lds	r24, 0x50C5
     5fa:	88 23       	and	r24, r24
     5fc:	61 f0       	breq	.+24     	; 0x616 <main+0xda>
						CO_collectADC(ADC_CH_1_gc, gain, freq, 1000,(int32_t*)FRAMReadBuffer);
     5fe:	2a 81       	ldd	r18, Y+2	; 0x02
     600:	3b 81       	ldd	r19, Y+3	; 0x03
     602:	e7 ed       	ldi	r30, 0xD7	; 215
     604:	f3 e2       	ldi	r31, 0x23	; 35
     606:	80 e0       	ldi	r24, 0x00	; 0
     608:	69 81       	ldd	r22, Y+1	; 0x01
     60a:	a9 01       	movw	r20, r18
     60c:	28 ee       	ldi	r18, 0xE8	; 232
     60e:	33 e0       	ldi	r19, 0x03	; 3
     610:	8f 01       	movw	r16, r30
     612:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <CO_collectADC>
						//CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, FALSE, 1, 2, 3, 4, 1000,(int32_t*)FRAMReadBuffer);
					}
					//send acknowledgment
					chb_write(0x0000,&ack,1);						
     616:	9e 01       	movw	r18, r28
     618:	29 5f       	subi	r18, 0xF9	; 249
     61a:	3f 4f       	sbci	r19, 0xFF	; 255
     61c:	80 e0       	ldi	r24, 0x00	; 0
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	b9 01       	movw	r22, r18
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	40 e0       	ldi	r20, 0x00	; 0
     628:	50 e0       	ldi	r21, 0x00	; 0
     62a:	0e 94 22 23 	call	0x4644	; 0x4644 <chb_write>
					break;
     62e:	ef c0       	rjmp	.+478    	; 0x80e <main+0x2d2>
				case 'G':
					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
     630:	ce 01       	movw	r24, r28
     632:	0d 96       	adiw	r24, 0x0d	; 13
     634:	01 96       	adiw	r24, 0x01	; 1
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	a2 81       	ldd	r26, Z+2	; 0x02
     63e:	b3 81       	ldd	r27, Z+3	; 0x03
     640:	88 87       	std	Y+8, r24	; 0x08
					switch(RawGain){
     642:	88 85       	ldd	r24, Y+8	; 0x08
     644:	88 2f       	mov	r24, r24
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	88 30       	cpi	r24, 0x08	; 8
     64a:	91 05       	cpc	r25, r1
     64c:	31 f1       	breq	.+76     	; 0x69a <main+0x15e>
     64e:	89 30       	cpi	r24, 0x09	; 9
     650:	91 05       	cpc	r25, r1
     652:	54 f4       	brge	.+20     	; 0x668 <main+0x12c>
     654:	82 30       	cpi	r24, 0x02	; 2
     656:	91 05       	cpc	r25, r1
     658:	d1 f0       	breq	.+52     	; 0x68e <main+0x152>
     65a:	84 30       	cpi	r24, 0x04	; 4
     65c:	91 05       	cpc	r25, r1
     65e:	d1 f0       	breq	.+52     	; 0x694 <main+0x158>
     660:	81 30       	cpi	r24, 0x01	; 1
     662:	91 05       	cpc	r25, r1
     664:	91 f0       	breq	.+36     	; 0x68a <main+0x14e>
     666:	28 c0       	rjmp	.+80     	; 0x6b8 <main+0x17c>
     668:	80 32       	cpi	r24, 0x20	; 32
     66a:	91 05       	cpc	r25, r1
     66c:	e1 f0       	breq	.+56     	; 0x6a6 <main+0x16a>
     66e:	81 32       	cpi	r24, 0x21	; 33
     670:	91 05       	cpc	r25, r1
     672:	24 f4       	brge	.+8      	; 0x67c <main+0x140>
     674:	80 31       	cpi	r24, 0x10	; 16
     676:	91 05       	cpc	r25, r1
     678:	99 f0       	breq	.+38     	; 0x6a0 <main+0x164>
     67a:	1e c0       	rjmp	.+60     	; 0x6b8 <main+0x17c>
     67c:	80 34       	cpi	r24, 0x40	; 64
     67e:	91 05       	cpc	r25, r1
     680:	a9 f0       	breq	.+42     	; 0x6ac <main+0x170>
     682:	80 38       	cpi	r24, 0x80	; 128
     684:	91 05       	cpc	r25, r1
     686:	a9 f0       	breq	.+42     	; 0x6b2 <main+0x176>
     688:	17 c0       	rjmp	.+46     	; 0x6b8 <main+0x17c>
						case 1:
							gain = GAIN_1_gc;
     68a:	19 82       	std	Y+1, r1	; 0x01
							break;
     68c:	16 c0       	rjmp	.+44     	; 0x6ba <main+0x17e>
						case 2:
							gain = GAIN_2_gc;
     68e:	81 e0       	ldi	r24, 0x01	; 1
     690:	89 83       	std	Y+1, r24	; 0x01
							break;
     692:	13 c0       	rjmp	.+38     	; 0x6ba <main+0x17e>
						case 4:
							gain = GAIN_4_gc;
     694:	82 e0       	ldi	r24, 0x02	; 2
     696:	89 83       	std	Y+1, r24	; 0x01
							break;
     698:	10 c0       	rjmp	.+32     	; 0x6ba <main+0x17e>
						case 8:
							gain = GAIN_8_gc;
     69a:	83 e0       	ldi	r24, 0x03	; 3
     69c:	89 83       	std	Y+1, r24	; 0x01
							break;
     69e:	0d c0       	rjmp	.+26     	; 0x6ba <main+0x17e>
						case 16:
							gain = GAIN_16_gc;
     6a0:	84 e0       	ldi	r24, 0x04	; 4
     6a2:	89 83       	std	Y+1, r24	; 0x01
							break;
     6a4:	0a c0       	rjmp	.+20     	; 0x6ba <main+0x17e>
						case 32:
							gain = GAIN_32_gc;
     6a6:	85 e0       	ldi	r24, 0x05	; 5
     6a8:	89 83       	std	Y+1, r24	; 0x01
							break;
     6aa:	07 c0       	rjmp	.+14     	; 0x6ba <main+0x17e>
						case 64:
							gain = GAIN_64_gc;
     6ac:	86 e0       	ldi	r24, 0x06	; 6
     6ae:	89 83       	std	Y+1, r24	; 0x01
							break;
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <main+0x17e>
						case 128:
							gain = GAIN_128_gc;
     6b2:	87 e0       	ldi	r24, 0x07	; 7
     6b4:	89 83       	std	Y+1, r24	; 0x01
							break;
     6b6:	01 c0       	rjmp	.+2      	; 0x6ba <main+0x17e>
						default:
							//chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
							break;
     6b8:	00 00       	nop
					}
					//send acknowledgment
					chb_write(0x0000,&ack,1);					
     6ba:	9e 01       	movw	r18, r28
     6bc:	29 5f       	subi	r18, 0xF9	; 249
     6be:	3f 4f       	sbci	r19, 0xFF	; 255
     6c0:	80 e0       	ldi	r24, 0x00	; 0
     6c2:	90 e0       	ldi	r25, 0x00	; 0
     6c4:	b9 01       	movw	r22, r18
     6c6:	21 e0       	ldi	r18, 0x01	; 1
     6c8:	30 e0       	ldi	r19, 0x00	; 0
     6ca:	40 e0       	ldi	r20, 0x00	; 0
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	0e 94 22 23 	call	0x4644	; 0x4644 <chb_write>
					break;
     6d2:	9d c0       	rjmp	.+314    	; 0x80e <main+0x2d2>
				case 'F':

					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set sampling frequency to what is specified
					freq = (uint16_t)(*(int32_t*)(RadioMessageBuffer+1));
     6d4:	ce 01       	movw	r24, r28
     6d6:	0d 96       	adiw	r24, 0x0d	; 13
     6d8:	01 96       	adiw	r24, 0x01	; 1
     6da:	fc 01       	movw	r30, r24
     6dc:	80 81       	ld	r24, Z
     6de:	91 81       	ldd	r25, Z+1	; 0x01
     6e0:	a2 81       	ldd	r26, Z+2	; 0x02
     6e2:	b3 81       	ldd	r27, Z+3	; 0x03
     6e4:	8a 83       	std	Y+2, r24	; 0x02
     6e6:	9b 83       	std	Y+3, r25	; 0x03
					//send acknowledgment
					chb_write(0x0000,&ack,1);
     6e8:	9e 01       	movw	r18, r28
     6ea:	29 5f       	subi	r18, 0xF9	; 249
     6ec:	3f 4f       	sbci	r19, 0xFF	; 255
     6ee:	80 e0       	ldi	r24, 0x00	; 0
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	b9 01       	movw	r22, r18
     6f4:	21 e0       	ldi	r18, 0x01	; 1
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	40 e0       	ldi	r20, 0x00	; 0
     6fa:	50 e0       	ldi	r21, 0x00	; 0
     6fc:	0e 94 22 23 	call	0x4644	; 0x4644 <chb_write>
					break;
     700:	86 c0       	rjmp	.+268    	; 0x80e <main+0x2d2>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     702:	80 91 c5 50 	lds	r24, 0x50C5
     706:	88 23       	and	r24, r24
     708:	11 f4       	brne	.+4      	; 0x70e <main+0x1d2>
						ADC_Stop_Sampling();
     70a:	0e 94 9f 0c 	call	0x193e	; 0x193e <ADC_Stop_Sampling>
					}
					//otherwise, the ADC has finished sampling on its own and the data will be transmitted after this switch statement
					//send acknowledgment
					chb_write(0x0000,&ack,1);
     70e:	9e 01       	movw	r18, r28
     710:	29 5f       	subi	r18, 0xF9	; 249
     712:	3f 4f       	sbci	r19, 0xFF	; 255
     714:	80 e0       	ldi	r24, 0x00	; 0
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	b9 01       	movw	r22, r18
     71a:	21 e0       	ldi	r18, 0x01	; 1
     71c:	30 e0       	ldi	r19, 0x00	; 0
     71e:	40 e0       	ldi	r20, 0x00	; 0
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	0e 94 22 23 	call	0x4644	; 0x4644 <chb_write>
					break;
     726:	73 c0       	rjmp	.+230    	; 0x80e <main+0x2d2>
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     728:	80 91 c5 50 	lds	r24, 0x50C5
     72c:	88 23       	and	r24, r24
     72e:	09 f4       	brne	.+2      	; 0x732 <main+0x1f6>
     730:	6d c0       	rjmp	.+218    	; 0x80c <main+0x2d0>
     732:	80 91 cd 21 	lds	r24, 0x21CD
     736:	88 23       	and	r24, r24
     738:	09 f4       	brne	.+2      	; 0x73c <main+0x200>
     73a:	68 c0       	rjmp	.+208    	; 0x80c <main+0x2d0>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     73c:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <ADC_Get_Num_Samples>
     740:	cc 01       	movw	r24, r24
     742:	a0 e0       	ldi	r26, 0x00	; 0
     744:	b0 e0       	ldi	r27, 0x00	; 0
     746:	89 87       	std	Y+9, r24	; 0x09
     748:	9a 87       	std	Y+10, r25	; 0x0a
     74a:	ab 87       	std	Y+11, r26	; 0x0b
     74c:	bc 87       	std	Y+12, r27	; 0x0c
						if(samples > 0){	
     74e:	89 85       	ldd	r24, Y+9	; 0x09
     750:	9a 85       	ldd	r25, Y+10	; 0x0a
     752:	ab 85       	ldd	r26, Y+11	; 0x0b
     754:	bc 85       	ldd	r27, Y+12	; 0x0c
     756:	00 97       	sbiw	r24, 0x00	; 0
     758:	a1 05       	cpc	r26, r1
     75a:	b1 05       	cpc	r27, r1
     75c:	09 f4       	brne	.+2      	; 0x760 <main+0x224>
     75e:	54 c0       	rjmp	.+168    	; 0x808 <main+0x2cc>
							uint8_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     760:	89 85       	ldd	r24, Y+9	; 0x09
     762:	9a 85       	ldd	r25, Y+10	; 0x0a
     764:	ab 85       	ldd	r26, Y+11	; 0x0b
     766:	bc 85       	ldd	r27, Y+12	; 0x0c
     768:	88 0f       	add	r24, r24
     76a:	99 1f       	adc	r25, r25
     76c:	aa 1f       	adc	r26, r26
     76e:	bb 1f       	adc	r27, r27
     770:	88 0f       	add	r24, r24
     772:	99 1f       	adc	r25, r25
     774:	aa 1f       	adc	r26, r26
     776:	bb 1f       	adc	r27, r27
     778:	24 e6       	ldi	r18, 0x64	; 100
     77a:	30 e0       	ldi	r19, 0x00	; 0
     77c:	40 e0       	ldi	r20, 0x00	; 0
     77e:	50 e0       	ldi	r21, 0x00	; 0
     780:	bc 01       	movw	r22, r24
     782:	cd 01       	movw	r24, r26
     784:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
     788:	da 01       	movw	r26, r20
     78a:	c9 01       	movw	r24, r18
     78c:	8f a3       	lds	r24, 0x5f
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
     78e:	89 85       	ldd	r24, Y+9	; 0x09
     790:	9a 85       	ldd	r25, Y+10	; 0x0a
     792:	ab 85       	ldd	r26, Y+11	; 0x0b
     794:	bc 85       	ldd	r27, Y+12	; 0x0c
     796:	88 0f       	add	r24, r24
     798:	99 1f       	adc	r25, r25
     79a:	aa 1f       	adc	r26, r26
     79c:	bb 1f       	adc	r27, r27
     79e:	88 0f       	add	r24, r24
     7a0:	99 1f       	adc	r25, r25
     7a2:	aa 1f       	adc	r26, r26
     7a4:	bb 1f       	adc	r27, r27
     7a6:	24 e6       	ldi	r18, 0x64	; 100
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	40 e0       	ldi	r20, 0x00	; 0
     7ac:	50 e0       	ldi	r21, 0x00	; 0
     7ae:	bc 01       	movw	r22, r24
     7b0:	cd 01       	movw	r24, r26
     7b2:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
     7b6:	dc 01       	movw	r26, r24
     7b8:	cb 01       	movw	r24, r22
     7ba:	00 97       	sbiw	r24, 0x00	; 0
     7bc:	a1 05       	cpc	r26, r1
     7be:	b1 05       	cpc	r27, r1
     7c0:	19 f0       	breq	.+6      	; 0x7c8 <main+0x28c>
     7c2:	8f a1       	lds	r24, 0x4f
     7c4:	8f 5f       	subi	r24, 0xFF	; 255
     7c6:	8f a3       	lds	r24, 0x5f
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,1);  
     7c8:	9e 01       	movw	r18, r28
     7ca:	29 5d       	subi	r18, 0xD9	; 217
     7cc:	3f 4f       	sbci	r19, 0xFF	; 255
     7ce:	80 e0       	ldi	r24, 0x00	; 0
     7d0:	90 e0       	ldi	r25, 0x00	; 0
     7d2:	b9 01       	movw	r22, r18
     7d4:	21 e0       	ldi	r18, 0x01	; 1
     7d6:	30 e0       	ldi	r19, 0x00	; 0
     7d8:	40 e0       	ldi	r20, 0x00	; 0
     7da:	50 e0       	ldi	r21, 0x00	; 0
     7dc:	0e 94 22 23 	call	0x4644	; 0x4644 <chb_write>
							//send the data							
							chb_write(0x0000,FRAMReadBuffer,samples*4);	
     7e0:	89 85       	ldd	r24, Y+9	; 0x09
     7e2:	9a 85       	ldd	r25, Y+10	; 0x0a
     7e4:	ab 85       	ldd	r26, Y+11	; 0x0b
     7e6:	bc 85       	ldd	r27, Y+12	; 0x0c
     7e8:	9c 01       	movw	r18, r24
     7ea:	ad 01       	movw	r20, r26
     7ec:	22 0f       	add	r18, r18
     7ee:	33 1f       	adc	r19, r19
     7f0:	44 1f       	adc	r20, r20
     7f2:	55 1f       	adc	r21, r21
     7f4:	22 0f       	add	r18, r18
     7f6:	33 1f       	adc	r19, r19
     7f8:	44 1f       	adc	r20, r20
     7fa:	55 1f       	adc	r21, r21
     7fc:	67 ed       	ldi	r22, 0xD7	; 215
     7fe:	73 e2       	ldi	r23, 0x23	; 35
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	0e 94 22 23 	call	0x4644	; 0x4644 <chb_write>
							//write the data to SD card for good measure (make sure transmitted and collected data is the same)	
							//writeFile(ofile, FRAMReadBuffer, samples*4);			
						}							
						DataAvailable = 0;
     808:	10 92 cd 21 	sts	0x21CD, r1
					}
					break;
     80c:	00 00       	nop
// 			//get number of data points collected
// 			samples = ADC_Get_Num_Samples();
// 			if(samples > 0) chb_write(0x0000,FRAMReadBuffer,samples*4);
// 			DataAvailable = 0;
// 		}	
	}	
     80e:	cd ce       	rjmp	.-614    	; 0x5aa <main+0x6e>

00000810 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     810:	cf 93       	push	r28
     812:	df 93       	push	r29
     814:	0f 92       	push	r0
     816:	0f 92       	push	r0
     818:	cd b7       	in	r28, 0x3d	; 61
     81a:	de b7       	in	r29, 0x3e	; 62
     81c:	89 83       	std	Y+1, r24	; 0x01
     81e:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	80 93 c0 50 	sts	0x50C0, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     826:	83 e0       	ldi	r24, 0x03	; 3
     828:	80 93 56 40 	sts	0x4056, r24
	chb_init();
     82c:	0e 94 5d 22 	call	0x44ba	; 0x44ba <chb_init>
	chb_set_short_addr(moteID);
     830:	80 91 c0 50 	lds	r24, 0x50C0
     834:	88 2f       	mov	r24, r24
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	0e 94 02 2f 	call	0x5e04	; 0x5e04 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     83c:	80 e8       	ldi	r24, 0x80	; 128
     83e:	91 e0       	ldi	r25, 0x01	; 1
     840:	28 ec       	ldi	r18, 0xC8	; 200
     842:	fc 01       	movw	r30, r24
     844:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     846:	80 e4       	ldi	r24, 0x40	; 64
     848:	99 e0       	ldi	r25, 0x09	; 9
     84a:	29 e0       	ldi	r18, 0x09	; 9
     84c:	fc 01       	movw	r30, r24
     84e:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     850:	80 e4       	ldi	r24, 0x40	; 64
     852:	99 e0       	ldi	r25, 0x09	; 9
     854:	22 e0       	ldi	r18, 0x02	; 2
     856:	fc 01       	movw	r30, r24
     858:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     85a:	80 e4       	ldi	r24, 0x40	; 64
     85c:	99 e0       	ldi	r25, 0x09	; 9
     85e:	69 81       	ldd	r22, Y+1	; 0x01
     860:	7a 81       	ldd	r23, Y+2	; 0x02
     862:	44 ef       	ldi	r20, 0xF4	; 244
     864:	51 e0       	ldi	r21, 0x01	; 1
     866:	64 9f       	mul	r22, r20
     868:	90 01       	movw	r18, r0
     86a:	65 9f       	mul	r22, r21
     86c:	30 0d       	add	r19, r0
     86e:	74 9f       	mul	r23, r20
     870:	30 0d       	add	r19, r0
     872:	11 24       	eor	r1, r1
     874:	fc 01       	movw	r30, r24
     876:	26 a3       	lds	r18, 0x56
     878:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     87a:	80 e4       	ldi	r24, 0x40	; 64
     87c:	98 e0       	ldi	r25, 0x08	; 8
     87e:	20 e0       	ldi	r18, 0x00	; 0
     880:	3a ef       	ldi	r19, 0xFA	; 250
     882:	fc 01       	movw	r30, r24
     884:	26 a3       	lds	r18, 0x56
     886:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     888:	80 e4       	ldi	r24, 0x40	; 64
     88a:	98 e0       	ldi	r25, 0x08	; 8
     88c:	21 e0       	ldi	r18, 0x01	; 1
     88e:	fc 01       	movw	r30, r24
     890:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     892:	80 e4       	ldi	r24, 0x40	; 64
     894:	98 e0       	ldi	r25, 0x08	; 8
     896:	21 e0       	ldi	r18, 0x01	; 1
     898:	fc 01       	movw	r30, r24
     89a:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     89c:	80 ea       	ldi	r24, 0xA0	; 160
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	20 ea       	ldi	r18, 0xA0	; 160
     8a2:	30 e0       	ldi	r19, 0x00	; 0
     8a4:	f9 01       	movw	r30, r18
     8a6:	22 81       	ldd	r18, Z+2	; 0x02
     8a8:	27 60       	ori	r18, 0x07	; 7
     8aa:	fc 01       	movw	r30, r24
     8ac:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     8ae:	78 94       	sei
}
     8b0:	0f 90       	pop	r0
     8b2:	0f 90       	pop	r0
     8b4:	df 91       	pop	r29
     8b6:	cf 91       	pop	r28
     8b8:	08 95       	ret

000008ba <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     8ba:	78 94       	sei
     8bc:	1f 92       	push	r1
     8be:	0f 92       	push	r0
     8c0:	0f b6       	in	r0, 0x3f	; 63
     8c2:	0f 92       	push	r0
     8c4:	00 90 3b 00 	lds	r0, 0x003B
     8c8:	0f 92       	push	r0
     8ca:	11 24       	eor	r1, r1
     8cc:	2f 93       	push	r18
     8ce:	3f 93       	push	r19
     8d0:	4f 93       	push	r20
     8d2:	5f 93       	push	r21
     8d4:	6f 93       	push	r22
     8d6:	7f 93       	push	r23
     8d8:	8f 93       	push	r24
     8da:	9f 93       	push	r25
     8dc:	af 93       	push	r26
     8de:	bf 93       	push	r27
     8e0:	ef 93       	push	r30
     8e2:	ff 93       	push	r31
     8e4:	cf 93       	push	r28
     8e6:	df 93       	push	r29
     8e8:	cd b7       	in	r28, 0x3d	; 61
     8ea:	de b7       	in	r29, 0x3e	; 62
     8ec:	28 97       	sbiw	r28, 0x08	; 8
     8ee:	cd bf       	out	0x3d, r28	; 61
     8f0:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     8f2:	80 e4       	ldi	r24, 0x40	; 64
     8f4:	98 e0       	ldi	r25, 0x08	; 8
     8f6:	fc 01       	movw	r30, r24
     8f8:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     8fa:	80 e4       	ldi	r24, 0x40	; 64
     8fc:	99 e0       	ldi	r25, 0x09	; 9
     8fe:	fc 01       	movw	r30, r24
     900:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     902:	82 e0       	ldi	r24, 0x02	; 2
     904:	80 93 56 40 	sts	0x4056, r24
	char message[8];
	strcpy(message,"reset");
     908:	ce 01       	movw	r24, r28
     90a:	01 96       	adiw	r24, 0x01	; 1
     90c:	26 e0       	ldi	r18, 0x06	; 6
     90e:	30 e2       	ldi	r19, 0x20	; 32
     910:	46 e0       	ldi	r20, 0x06	; 6
     912:	f9 01       	movw	r30, r18
     914:	00 80       	ld	r0, Z
     916:	2f 5f       	subi	r18, 0xFF	; 255
     918:	3f 4f       	sbci	r19, 0xFF	; 255
     91a:	fc 01       	movw	r30, r24
     91c:	00 82       	st	Z, r0
     91e:	01 96       	adiw	r24, 0x01	; 1
     920:	41 50       	subi	r20, 0x01	; 1
     922:	44 23       	and	r20, r20
     924:	b1 f7       	brne	.-20     	; 0x912 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     926:	80 91 c0 50 	lds	r24, 0x50C0
     92a:	88 2f       	mov	r24, r24
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	27 ec       	ldi	r18, 0xC7	; 199
     930:	30 e5       	ldi	r19, 0x50	; 80
     932:	b9 01       	movw	r22, r18
     934:	4a e0       	ldi	r20, 0x0A	; 10
     936:	50 e0       	ldi	r21, 0x00	; 0
     938:	0e 94 33 61 	call	0xc266	; 0xc266 <itoa>
	strcat(message,buff);
     93c:	27 ec       	ldi	r18, 0xC7	; 199
     93e:	30 e5       	ldi	r19, 0x50	; 80
     940:	ce 01       	movw	r24, r28
     942:	01 96       	adiw	r24, 0x01	; 1
     944:	b9 01       	movw	r22, r18
     946:	0e 94 1a 61 	call	0xc234	; 0xc234 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     94a:	0e 94 fe 0c 	call	0x19fc	; 0x19fc <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     94e:	ce 01       	movw	r24, r28
     950:	01 96       	adiw	r24, 0x01	; 1
     952:	9c 01       	movw	r18, r24
     954:	f9 01       	movw	r30, r18
     956:	01 90       	ld	r0, Z+
     958:	00 20       	and	r0, r0
     95a:	e9 f7       	brne	.-6      	; 0x956 <__vector_83+0x9c>
     95c:	cf 01       	movw	r24, r30
     95e:	01 97       	sbiw	r24, 0x01	; 1
     960:	82 1b       	sub	r24, r18
     962:	93 0b       	sbc	r25, r19
     964:	9c 01       	movw	r18, r24
     966:	40 e0       	ldi	r20, 0x00	; 0
     968:	50 e0       	ldi	r21, 0x00	; 0
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	be 01       	movw	r22, r28
     970:	6f 5f       	subi	r22, 0xFF	; 255
     972:	7f 4f       	sbci	r23, 0xFF	; 255
     974:	0e 94 22 23 	call	0x4644	; 0x4644 <chb_write>
}	
     978:	28 96       	adiw	r28, 0x08	; 8
     97a:	cd bf       	out	0x3d, r28	; 61
     97c:	de bf       	out	0x3e, r29	; 62
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	ff 91       	pop	r31
     984:	ef 91       	pop	r30
     986:	bf 91       	pop	r27
     988:	af 91       	pop	r26
     98a:	9f 91       	pop	r25
     98c:	8f 91       	pop	r24
     98e:	7f 91       	pop	r23
     990:	6f 91       	pop	r22
     992:	5f 91       	pop	r21
     994:	4f 91       	pop	r20
     996:	3f 91       	pop	r19
     998:	2f 91       	pop	r18
     99a:	0f 90       	pop	r0
     99c:	00 92 3b 00 	sts	0x003B, r0
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	0f 90       	pop	r0
     9a6:	1f 90       	pop	r1
     9a8:	18 95       	reti

000009aa <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	cd b7       	in	r28, 0x3d	; 61
     9b0:	de b7       	in	r29, 0x3e	; 62
     9b2:	6b 97       	sbiw	r28, 0x1b	; 27
     9b4:	cd bf       	out	0x3d, r28	; 61
     9b6:	de bf       	out	0x3e, r29	; 62
     9b8:	8e 8b       	std	Y+22, r24	; 0x16
     9ba:	9f 8b       	std	Y+23, r25	; 0x17
     9bc:	68 8f       	std	Y+24, r22	; 0x18
     9be:	79 8f       	std	Y+25, r23	; 0x19
     9c0:	4a 8f       	std	Y+26, r20	; 0x1a
     9c2:	5b 8f       	std	Y+27, r21	; 0x1b
	
	uint32_t sum = 0;
     9c4:	19 82       	std	Y+1, r1	; 0x01
     9c6:	1a 82       	std	Y+2, r1	; 0x02
     9c8:	1b 82       	std	Y+3, r1	; 0x03
     9ca:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     9cc:	80 e0       	ldi	r24, 0x00	; 0
     9ce:	90 e1       	ldi	r25, 0x10	; 16
     9d0:	a0 e0       	ldi	r26, 0x00	; 0
     9d2:	b0 e0       	ldi	r27, 0x00	; 0
     9d4:	8d 83       	std	Y+5, r24	; 0x05
     9d6:	9e 83       	std	Y+6, r25	; 0x06
     9d8:	af 83       	std	Y+7, r26	; 0x07
     9da:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     9dc:	19 86       	std	Y+9, r1	; 0x09
     9de:	1a 86       	std	Y+10, r1	; 0x0a
     9e0:	1b 86       	std	Y+11, r1	; 0x0b
     9e2:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     9ea:	80 e0       	ldi	r24, 0x00	; 0
     9ec:	92 e0       	ldi	r25, 0x02	; 2
     9ee:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     9f2:	80 e0       	ldi	r24, 0x00	; 0
     9f4:	92 e0       	ldi	r25, 0x02	; 2
     9f6:	20 e0       	ldi	r18, 0x00	; 0
     9f8:	32 e0       	ldi	r19, 0x02	; 2
     9fa:	f9 01       	movw	r30, r18
     9fc:	21 81       	ldd	r18, Z+1	; 0x01
     9fe:	29 7e       	andi	r18, 0xE9	; 233
     a00:	fc 01       	movw	r30, r24
     a02:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     a04:	80 e0       	ldi	r24, 0x00	; 0
     a06:	92 e0       	ldi	r25, 0x02	; 2
     a08:	20 e0       	ldi	r18, 0x00	; 0
     a0a:	32 e0       	ldi	r19, 0x02	; 2
     a0c:	f9 01       	movw	r30, r18
     a0e:	24 81       	ldd	r18, Z+4	; 0x04
     a10:	28 7f       	andi	r18, 0xF8	; 248
     a12:	23 60       	ori	r18, 0x03	; 3
     a14:	fc 01       	movw	r30, r24
     a16:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     a18:	80 e0       	ldi	r24, 0x00	; 0
     a1a:	92 e0       	ldi	r25, 0x02	; 2
     a1c:	20 e0       	ldi	r18, 0x00	; 0
     a1e:	32 e0       	ldi	r19, 0x02	; 2
     a20:	f9 01       	movw	r30, r18
     a22:	22 81       	ldd	r18, Z+2	; 0x02
     a24:	2f 7c       	andi	r18, 0xCF	; 207
     a26:	fc 01       	movw	r30, r24
     a28:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     a2a:	80 e2       	ldi	r24, 0x20	; 32
     a2c:	92 e0       	ldi	r25, 0x02	; 2
     a2e:	20 e2       	ldi	r18, 0x20	; 32
     a30:	32 e0       	ldi	r19, 0x02	; 2
     a32:	f9 01       	movw	r30, r18
     a34:	20 81       	ld	r18, Z
     a36:	20 7e       	andi	r18, 0xE0	; 224
     a38:	21 60       	ori	r18, 0x01	; 1
     a3a:	fc 01       	movw	r30, r24
     a3c:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     a3e:	80 e2       	ldi	r24, 0x20	; 32
     a40:	92 e0       	ldi	r25, 0x02	; 2
     a42:	29 e0       	ldi	r18, 0x09	; 9
     a44:	fc 01       	movw	r30, r24
     a46:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     a48:	80 e0       	ldi	r24, 0x00	; 0
     a4a:	92 e0       	ldi	r25, 0x02	; 2
     a4c:	20 e0       	ldi	r18, 0x00	; 0
     a4e:	32 e0       	ldi	r19, 0x02	; 2
     a50:	f9 01       	movw	r30, r18
     a52:	20 81       	ld	r18, Z
     a54:	21 60       	ori	r18, 0x01	; 1
     a56:	fc 01       	movw	r30, r24
     a58:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	92 e0       	ldi	r25, 0x02	; 2
     a5e:	0e 94 72 20 	call	0x40e4	; 0x40e4 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	92 e0       	ldi	r25, 0x02	; 2
     a66:	60 e2       	ldi	r22, 0x20	; 32
     a68:	72 e0       	ldi	r23, 0x02	; 2
     a6a:	40 e0       	ldi	r20, 0x00	; 0
     a6c:	0e 94 69 21 	call	0x42d2	; 0x42d2 <ADC_Offset_Get_Unsigned>
     a70:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     a72:	80 e0       	ldi	r24, 0x00	; 0
     a74:	92 e0       	ldi	r25, 0x02	; 2
     a76:	20 e0       	ldi	r18, 0x00	; 0
     a78:	32 e0       	ldi	r19, 0x02	; 2
     a7a:	f9 01       	movw	r30, r18
     a7c:	20 81       	ld	r18, Z
     a7e:	2e 7f       	andi	r18, 0xFE	; 254
     a80:	fc 01       	movw	r30, r24
     a82:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     a84:	80 e2       	ldi	r24, 0x20	; 32
     a86:	92 e0       	ldi	r25, 0x02	; 2
     a88:	fc 01       	movw	r30, r24
     a8a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	20 e0       	ldi	r18, 0x00	; 0
     a92:	32 e0       	ldi	r19, 0x02	; 2
     a94:	f9 01       	movw	r30, r18
     a96:	23 81       	ldd	r18, Z+3	; 0x03
     a98:	2f 73       	andi	r18, 0x3F	; 63
     a9a:	fc 01       	movw	r30, r24
     a9c:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	92 e0       	ldi	r25, 0x02	; 2
     aa2:	20 e0       	ldi	r18, 0x00	; 0
     aa4:	32 e0       	ldi	r19, 0x02	; 2
     aa6:	f9 01       	movw	r30, r18
     aa8:	20 81       	ld	r18, Z
     aaa:	21 60       	ori	r18, 0x01	; 1
     aac:	fc 01       	movw	r30, r24
     aae:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     ab0:	80 e0       	ldi	r24, 0x00	; 0
     ab2:	92 e0       	ldi	r25, 0x02	; 2
     ab4:	0e 94 72 20 	call	0x40e4	; 0x40e4 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     ab8:	80 e0       	ldi	r24, 0x00	; 0
     aba:	92 e0       	ldi	r25, 0x02	; 2
     abc:	20 e0       	ldi	r18, 0x00	; 0
     abe:	32 e0       	ldi	r19, 0x02	; 2
     ac0:	f9 01       	movw	r30, r18
     ac2:	21 81       	ldd	r18, Z+1	; 0x01
     ac4:	28 60       	ori	r18, 0x08	; 8
     ac6:	fc 01       	movw	r30, r24
     ac8:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     aca:	1d 86       	std	Y+13, r1	; 0x0d
     acc:	1e 86       	std	Y+14, r1	; 0x0e
     ace:	56 c0       	rjmp	.+172    	; 0xb7c <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     ad0:	80 e2       	ldi	r24, 0x20	; 32
     ad2:	92 e0       	ldi	r25, 0x02	; 2
     ad4:	fc 01       	movw	r30, r24
     ad6:	83 81       	ldd	r24, Z+3	; 0x03
     ad8:	88 2f       	mov	r24, r24
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	81 70       	andi	r24, 0x01	; 1
     ade:	90 70       	andi	r25, 0x00	; 0
     ae0:	00 97       	sbiw	r24, 0x00	; 0
     ae2:	b1 f3       	breq	.-20     	; 0xad0 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     ae4:	2d 89       	ldd	r18, Y+21	; 0x15
     ae6:	80 e2       	ldi	r24, 0x20	; 32
     ae8:	92 e0       	ldi	r25, 0x02	; 2
     aea:	62 2f       	mov	r22, r18
     aec:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <ADC_ResultCh_GetWord_Signed>
     af0:	8f 87       	std	Y+15, r24	; 0x0f
     af2:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     af4:	8f 85       	ldd	r24, Y+15	; 0x0f
     af6:	98 89       	ldd	r25, Y+16	; 0x10
     af8:	cc 01       	movw	r24, r24
     afa:	a0 e0       	ldi	r26, 0x00	; 0
     afc:	b0 e0       	ldi	r27, 0x00	; 0
     afe:	29 81       	ldd	r18, Y+1	; 0x01
     b00:	3a 81       	ldd	r19, Y+2	; 0x02
     b02:	4b 81       	ldd	r20, Y+3	; 0x03
     b04:	5c 81       	ldd	r21, Y+4	; 0x04
     b06:	82 0f       	add	r24, r18
     b08:	93 1f       	adc	r25, r19
     b0a:	a4 1f       	adc	r26, r20
     b0c:	b5 1f       	adc	r27, r21
     b0e:	89 83       	std	Y+1, r24	; 0x01
     b10:	9a 83       	std	Y+2, r25	; 0x02
     b12:	ab 83       	std	Y+3, r26	; 0x03
     b14:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     b16:	8f 85       	ldd	r24, Y+15	; 0x0f
     b18:	98 89       	ldd	r25, Y+16	; 0x10
     b1a:	9c 01       	movw	r18, r24
     b1c:	40 e0       	ldi	r20, 0x00	; 0
     b1e:	50 e0       	ldi	r21, 0x00	; 0
     b20:	89 85       	ldd	r24, Y+9	; 0x09
     b22:	9a 85       	ldd	r25, Y+10	; 0x0a
     b24:	ab 85       	ldd	r26, Y+11	; 0x0b
     b26:	bc 85       	ldd	r27, Y+12	; 0x0c
     b28:	82 17       	cp	r24, r18
     b2a:	93 07       	cpc	r25, r19
     b2c:	a4 07       	cpc	r26, r20
     b2e:	b5 07       	cpc	r27, r21
     b30:	48 f4       	brcc	.+18     	; 0xb44 <CO_collectTemp+0x19a>
     b32:	8f 85       	ldd	r24, Y+15	; 0x0f
     b34:	98 89       	ldd	r25, Y+16	; 0x10
     b36:	cc 01       	movw	r24, r24
     b38:	a0 e0       	ldi	r26, 0x00	; 0
     b3a:	b0 e0       	ldi	r27, 0x00	; 0
     b3c:	89 87       	std	Y+9, r24	; 0x09
     b3e:	9a 87       	std	Y+10, r25	; 0x0a
     b40:	ab 87       	std	Y+11, r26	; 0x0b
     b42:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     b44:	8f 85       	ldd	r24, Y+15	; 0x0f
     b46:	98 89       	ldd	r25, Y+16	; 0x10
     b48:	9c 01       	movw	r18, r24
     b4a:	40 e0       	ldi	r20, 0x00	; 0
     b4c:	50 e0       	ldi	r21, 0x00	; 0
     b4e:	8d 81       	ldd	r24, Y+5	; 0x05
     b50:	9e 81       	ldd	r25, Y+6	; 0x06
     b52:	af 81       	ldd	r26, Y+7	; 0x07
     b54:	b8 85       	ldd	r27, Y+8	; 0x08
     b56:	28 17       	cp	r18, r24
     b58:	39 07       	cpc	r19, r25
     b5a:	4a 07       	cpc	r20, r26
     b5c:	5b 07       	cpc	r21, r27
     b5e:	48 f4       	brcc	.+18     	; 0xb72 <CO_collectTemp+0x1c8>
     b60:	8f 85       	ldd	r24, Y+15	; 0x0f
     b62:	98 89       	ldd	r25, Y+16	; 0x10
     b64:	cc 01       	movw	r24, r24
     b66:	a0 e0       	ldi	r26, 0x00	; 0
     b68:	b0 e0       	ldi	r27, 0x00	; 0
     b6a:	8d 83       	std	Y+5, r24	; 0x05
     b6c:	9e 83       	std	Y+6, r25	; 0x06
     b6e:	af 83       	std	Y+7, r26	; 0x07
     b70:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     b72:	8d 85       	ldd	r24, Y+13	; 0x0d
     b74:	9e 85       	ldd	r25, Y+14	; 0x0e
     b76:	01 96       	adiw	r24, 0x01	; 1
     b78:	8d 87       	std	Y+13, r24	; 0x0d
     b7a:	9e 87       	std	Y+14, r25	; 0x0e
     b7c:	8d 85       	ldd	r24, Y+13	; 0x0d
     b7e:	9e 85       	ldd	r25, Y+14	; 0x0e
     b80:	f4 e0       	ldi	r31, 0x04	; 4
     b82:	80 30       	cpi	r24, 0x00	; 0
     b84:	9f 07       	cpc	r25, r31
     b86:	08 f4       	brcc	.+2      	; 0xb8a <CO_collectTemp+0x1e0>
     b88:	a3 cf       	rjmp	.-186    	; 0xad0 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     b8a:	80 e0       	ldi	r24, 0x00	; 0
     b8c:	92 e0       	ldi	r25, 0x02	; 2
     b8e:	20 e0       	ldi	r18, 0x00	; 0
     b90:	32 e0       	ldi	r19, 0x02	; 2
     b92:	f9 01       	movw	r30, r18
     b94:	21 81       	ldd	r18, Z+1	; 0x01
     b96:	27 7f       	andi	r18, 0xF7	; 247
     b98:	fc 01       	movw	r30, r24
     b9a:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     b9c:	80 e0       	ldi	r24, 0x00	; 0
     b9e:	92 e0       	ldi	r25, 0x02	; 2
     ba0:	20 e0       	ldi	r18, 0x00	; 0
     ba2:	32 e0       	ldi	r19, 0x02	; 2
     ba4:	f9 01       	movw	r30, r18
     ba6:	20 81       	ld	r18, Z
     ba8:	22 60       	ori	r18, 0x02	; 2
     baa:	fc 01       	movw	r30, r24
     bac:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     bae:	80 e0       	ldi	r24, 0x00	; 0
     bb0:	92 e0       	ldi	r25, 0x02	; 2
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	32 e0       	ldi	r19, 0x02	; 2
     bb6:	f9 01       	movw	r30, r18
     bb8:	20 81       	ld	r18, Z
     bba:	2e 7f       	andi	r18, 0xFE	; 254
     bbc:	fc 01       	movw	r30, r24
     bbe:	20 83       	st	Z, r18

	ADCPower(FALSE);
     bc0:	80 e0       	ldi	r24, 0x00	; 0
     bc2:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>

	average = sum / NUM_SAMPLES;
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	9a 81       	ldd	r25, Y+2	; 0x02
     bca:	ab 81       	ldd	r26, Y+3	; 0x03
     bcc:	bc 81       	ldd	r27, Y+4	; 0x04
     bce:	07 2e       	mov	r0, r23
     bd0:	7a e0       	ldi	r23, 0x0A	; 10
     bd2:	b6 95       	lsr	r27
     bd4:	a7 95       	ror	r26
     bd6:	97 95       	ror	r25
     bd8:	87 95       	ror	r24
     bda:	7a 95       	dec	r23
     bdc:	d1 f7       	brne	.-12     	; 0xbd2 <CO_collectTemp+0x228>
     bde:	70 2d       	mov	r23, r0
     be0:	89 8b       	std	Y+17, r24	; 0x11
     be2:	9a 8b       	std	Y+18, r25	; 0x12
     be4:	ab 8b       	std	Y+19, r26	; 0x13
     be6:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     be8:	89 89       	ldd	r24, Y+17	; 0x11
     bea:	9a 89       	ldd	r25, Y+18	; 0x12
     bec:	ab 89       	ldd	r26, Y+19	; 0x13
     bee:	bc 89       	ldd	r27, Y+20	; 0x14
     bf0:	28 ee       	ldi	r18, 0xE8	; 232
     bf2:	33 e0       	ldi	r19, 0x03	; 3
     bf4:	40 e0       	ldi	r20, 0x00	; 0
     bf6:	50 e0       	ldi	r21, 0x00	; 0
     bf8:	bc 01       	movw	r22, r24
     bfa:	cd 01       	movw	r24, r26
     bfc:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
     c00:	dc 01       	movw	r26, r24
     c02:	cb 01       	movw	r24, r22
     c04:	2f ef       	ldi	r18, 0xFF	; 255
     c06:	3f e0       	ldi	r19, 0x0F	; 15
     c08:	40 e0       	ldi	r20, 0x00	; 0
     c0a:	50 e0       	ldi	r21, 0x00	; 0
     c0c:	bc 01       	movw	r22, r24
     c0e:	cd 01       	movw	r24, r26
     c10:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
     c14:	da 01       	movw	r26, r20
     c16:	c9 01       	movw	r24, r18
     c18:	9c 01       	movw	r18, r24
     c1a:	22 53       	subi	r18, 0x32	; 50
     c1c:	30 40       	sbci	r19, 0x00	; 0
     c1e:	8e 89       	ldd	r24, Y+22	; 0x16
     c20:	9f 89       	ldd	r25, Y+23	; 0x17
     c22:	fc 01       	movw	r30, r24
     c24:	20 83       	st	Z, r18
     c26:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     c28:	89 85       	ldd	r24, Y+9	; 0x09
     c2a:	9a 85       	ldd	r25, Y+10	; 0x0a
     c2c:	ab 85       	ldd	r26, Y+11	; 0x0b
     c2e:	bc 85       	ldd	r27, Y+12	; 0x0c
     c30:	28 ee       	ldi	r18, 0xE8	; 232
     c32:	33 e0       	ldi	r19, 0x03	; 3
     c34:	40 e0       	ldi	r20, 0x00	; 0
     c36:	50 e0       	ldi	r21, 0x00	; 0
     c38:	bc 01       	movw	r22, r24
     c3a:	cd 01       	movw	r24, r26
     c3c:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
     c40:	dc 01       	movw	r26, r24
     c42:	cb 01       	movw	r24, r22
     c44:	2f ef       	ldi	r18, 0xFF	; 255
     c46:	3f e0       	ldi	r19, 0x0F	; 15
     c48:	40 e0       	ldi	r20, 0x00	; 0
     c4a:	50 e0       	ldi	r21, 0x00	; 0
     c4c:	bc 01       	movw	r22, r24
     c4e:	cd 01       	movw	r24, r26
     c50:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
     c54:	da 01       	movw	r26, r20
     c56:	c9 01       	movw	r24, r18
     c58:	9c 01       	movw	r18, r24
     c5a:	22 53       	subi	r18, 0x32	; 50
     c5c:	30 40       	sbci	r19, 0x00	; 0
     c5e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c60:	9b 8d       	ldd	r25, Y+27	; 0x1b
     c62:	fc 01       	movw	r30, r24
     c64:	20 83       	st	Z, r18
     c66:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     c68:	8d 81       	ldd	r24, Y+5	; 0x05
     c6a:	9e 81       	ldd	r25, Y+6	; 0x06
     c6c:	af 81       	ldd	r26, Y+7	; 0x07
     c6e:	b8 85       	ldd	r27, Y+8	; 0x08
     c70:	28 ee       	ldi	r18, 0xE8	; 232
     c72:	33 e0       	ldi	r19, 0x03	; 3
     c74:	40 e0       	ldi	r20, 0x00	; 0
     c76:	50 e0       	ldi	r21, 0x00	; 0
     c78:	bc 01       	movw	r22, r24
     c7a:	cd 01       	movw	r24, r26
     c7c:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
     c80:	dc 01       	movw	r26, r24
     c82:	cb 01       	movw	r24, r22
     c84:	2f ef       	ldi	r18, 0xFF	; 255
     c86:	3f e0       	ldi	r19, 0x0F	; 15
     c88:	40 e0       	ldi	r20, 0x00	; 0
     c8a:	50 e0       	ldi	r21, 0x00	; 0
     c8c:	bc 01       	movw	r22, r24
     c8e:	cd 01       	movw	r24, r26
     c90:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
     c94:	da 01       	movw	r26, r20
     c96:	c9 01       	movw	r24, r18
     c98:	9c 01       	movw	r18, r24
     c9a:	22 53       	subi	r18, 0x32	; 50
     c9c:	30 40       	sbci	r19, 0x00	; 0
     c9e:	88 8d       	ldd	r24, Y+24	; 0x18
     ca0:	99 8d       	ldd	r25, Y+25	; 0x19
     ca2:	fc 01       	movw	r30, r24
     ca4:	20 83       	st	Z, r18
     ca6:	31 83       	std	Z+1, r19	; 0x01
}
     ca8:	6b 96       	adiw	r28, 0x1b	; 27
     caa:	cd bf       	out	0x3d, r28	; 61
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	df 91       	pop	r29
     cb0:	cf 91       	pop	r28
     cb2:	08 95       	ret

00000cb4 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
     cc0:	a9 97       	sbiw	r28, 0x29	; 41
     cc2:	cd bf       	out	0x3d, r28	; 61
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	8c a3       	lds	r24, 0x5c
     cc8:	9d a3       	lds	r25, 0x5d
     cca:	6e a3       	lds	r22, 0x5e
     ccc:	7f a3       	lds	r23, 0x5f
     cce:	48 a7       	lds	r20, 0x78
     cd0:	59 a7       	lds	r21, 0x79
	
	uint32_t sum = 0;
     cd2:	19 82       	std	Y+1, r1	; 0x01
     cd4:	1a 82       	std	Y+2, r1	; 0x02
     cd6:	1b 82       	std	Y+3, r1	; 0x03
     cd8:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     cda:	80 e0       	ldi	r24, 0x00	; 0
     cdc:	90 e1       	ldi	r25, 0x10	; 16
     cde:	a0 e0       	ldi	r26, 0x00	; 0
     ce0:	b0 e0       	ldi	r27, 0x00	; 0
     ce2:	8d 83       	std	Y+5, r24	; 0x05
     ce4:	9e 83       	std	Y+6, r25	; 0x06
     ce6:	af 83       	std	Y+7, r26	; 0x07
     ce8:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     cea:	19 86       	std	Y+9, r1	; 0x09
     cec:	1a 86       	std	Y+10, r1	; 0x0a
     cee:	1b 86       	std	Y+11, r1	; 0x0b
     cf0:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     cf8:	84 e0       	ldi	r24, 0x04	; 4
     cfa:	60 e0       	ldi	r22, 0x00	; 0
     cfc:	0e 94 42 36 	call	0x6c84	; 0x6c84 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     d00:	84 e0       	ldi	r24, 0x04	; 4
     d02:	60 e0       	ldi	r22, 0x00	; 0
     d04:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
     d08:	80 e0       	ldi	r24, 0x00	; 0
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	a8 ec       	ldi	r26, 0xC8	; 200
     d0e:	b2 e4       	ldi	r27, 0x42	; 66
     d10:	8d 8b       	std	Y+21, r24	; 0x15
     d12:	9e 8b       	std	Y+22, r25	; 0x16
     d14:	af 8b       	std	Y+23, r26	; 0x17
     d16:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     d18:	6d 89       	ldd	r22, Y+21	; 0x15
     d1a:	7e 89       	ldd	r23, Y+22	; 0x16
     d1c:	8f 89       	ldd	r24, Y+23	; 0x17
     d1e:	98 8d       	ldd	r25, Y+24	; 0x18
     d20:	20 e0       	ldi	r18, 0x00	; 0
     d22:	30 e0       	ldi	r19, 0x00	; 0
     d24:	4a ef       	ldi	r20, 0xFA	; 250
     d26:	55 e4       	ldi	r21, 0x45	; 69
     d28:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
     d2c:	dc 01       	movw	r26, r24
     d2e:	cb 01       	movw	r24, r22
     d30:	89 8f       	std	Y+25, r24	; 0x19
     d32:	9a 8f       	std	Y+26, r25	; 0x1a
     d34:	ab 8f       	std	Y+27, r26	; 0x1b
     d36:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     d38:	11 e0       	ldi	r17, 0x01	; 1
     d3a:	69 8d       	ldd	r22, Y+25	; 0x19
     d3c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     d3e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d40:	9c 8d       	ldd	r25, Y+28	; 0x1c
     d42:	20 e0       	ldi	r18, 0x00	; 0
     d44:	30 e0       	ldi	r19, 0x00	; 0
     d46:	40 e8       	ldi	r20, 0x80	; 128
     d48:	5f e3       	ldi	r21, 0x3F	; 63
     d4a:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
     d4e:	88 23       	and	r24, r24
     d50:	0c f0       	brlt	.+2      	; 0xd54 <CO_collectBatt+0xa0>
     d52:	10 e0       	ldi	r17, 0x00	; 0
     d54:	11 23       	and	r17, r17
     d56:	29 f0       	breq	.+10     	; 0xd62 <CO_collectBatt+0xae>
		__ticks = 1;
     d58:	81 e0       	ldi	r24, 0x01	; 1
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	8d 8f       	std	Y+29, r24	; 0x1d
     d5e:	9e 8f       	std	Y+30, r25	; 0x1e
     d60:	46 c0       	rjmp	.+140    	; 0xdee <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     d62:	11 e0       	ldi	r17, 0x01	; 1
     d64:	69 8d       	ldd	r22, Y+25	; 0x19
     d66:	7a 8d       	ldd	r23, Y+26	; 0x1a
     d68:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d6a:	9c 8d       	ldd	r25, Y+28	; 0x1c
     d6c:	20 e0       	ldi	r18, 0x00	; 0
     d6e:	3f ef       	ldi	r19, 0xFF	; 255
     d70:	4f e7       	ldi	r20, 0x7F	; 127
     d72:	57 e4       	ldi	r21, 0x47	; 71
     d74:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
     d78:	18 16       	cp	r1, r24
     d7a:	0c f0       	brlt	.+2      	; 0xd7e <CO_collectBatt+0xca>
     d7c:	10 e0       	ldi	r17, 0x00	; 0
     d7e:	11 23       	and	r17, r17
     d80:	61 f1       	breq	.+88     	; 0xdda <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d82:	6d 89       	ldd	r22, Y+21	; 0x15
     d84:	7e 89       	ldd	r23, Y+22	; 0x16
     d86:	8f 89       	ldd	r24, Y+23	; 0x17
     d88:	98 8d       	ldd	r25, Y+24	; 0x18
     d8a:	20 e0       	ldi	r18, 0x00	; 0
     d8c:	30 e0       	ldi	r19, 0x00	; 0
     d8e:	40 e2       	ldi	r20, 0x20	; 32
     d90:	51 e4       	ldi	r21, 0x41	; 65
     d92:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
     d96:	dc 01       	movw	r26, r24
     d98:	cb 01       	movw	r24, r22
     d9a:	bc 01       	movw	r22, r24
     d9c:	cd 01       	movw	r24, r26
     d9e:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
     da2:	dc 01       	movw	r26, r24
     da4:	cb 01       	movw	r24, r22
     da6:	8d 8f       	std	Y+29, r24	; 0x1d
     da8:	9e 8f       	std	Y+30, r25	; 0x1e
     daa:	12 c0       	rjmp	.+36     	; 0xdd0 <CO_collectBatt+0x11c>
     dac:	80 e2       	ldi	r24, 0x20	; 32
     dae:	93 e0       	ldi	r25, 0x03	; 3
     db0:	8f 8f       	std	Y+31, r24	; 0x1f
     db2:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     db4:	8f 8d       	ldd	r24, Y+31	; 0x1f
     db6:	98 a1       	lds	r25, 0x48
     db8:	8c 01       	movw	r16, r24
     dba:	c8 01       	movw	r24, r16
     dbc:	01 97       	sbiw	r24, 0x01	; 1
     dbe:	f1 f7       	brne	.-4      	; 0xdbc <CO_collectBatt+0x108>
     dc0:	8c 01       	movw	r16, r24
     dc2:	0f 8f       	std	Y+31, r16	; 0x1f
     dc4:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     dc6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     dc8:	9e 8d       	ldd	r25, Y+30	; 0x1e
     dca:	01 97       	sbiw	r24, 0x01	; 1
     dcc:	8d 8f       	std	Y+29, r24	; 0x1d
     dce:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     dd0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     dd2:	9e 8d       	ldd	r25, Y+30	; 0x1e
     dd4:	00 97       	sbiw	r24, 0x00	; 0
     dd6:	51 f7       	brne	.-44     	; 0xdac <CO_collectBatt+0xf8>
     dd8:	17 c0       	rjmp	.+46     	; 0xe08 <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     dda:	69 8d       	ldd	r22, Y+25	; 0x19
     ddc:	7a 8d       	ldd	r23, Y+26	; 0x1a
     dde:	8b 8d       	ldd	r24, Y+27	; 0x1b
     de0:	9c 8d       	ldd	r25, Y+28	; 0x1c
     de2:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
     de6:	dc 01       	movw	r26, r24
     de8:	cb 01       	movw	r24, r22
     dea:	8d 8f       	std	Y+29, r24	; 0x1d
     dec:	9e 8f       	std	Y+30, r25	; 0x1e
     dee:	8d 8d       	ldd	r24, Y+29	; 0x1d
     df0:	9e 8d       	ldd	r25, Y+30	; 0x1e
     df2:	89 a3       	lds	r24, 0x59
     df4:	9a a3       	lds	r25, 0x5a
     df6:	89 a1       	lds	r24, 0x49
     df8:	9a a1       	lds	r25, 0x4a
     dfa:	8c 01       	movw	r16, r24
     dfc:	f8 01       	movw	r30, r16
     dfe:	31 97       	sbiw	r30, 0x01	; 1
     e00:	f1 f7       	brne	.-4      	; 0xdfe <CO_collectBatt+0x14a>
     e02:	8f 01       	movw	r16, r30
     e04:	09 a3       	lds	r16, 0x59
     e06:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     e08:	80 e4       	ldi	r24, 0x40	; 64
     e0a:	92 e0       	ldi	r25, 0x02	; 2
     e0c:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     e10:	80 e4       	ldi	r24, 0x40	; 64
     e12:	92 e0       	ldi	r25, 0x02	; 2
     e14:	20 e4       	ldi	r18, 0x40	; 64
     e16:	32 e0       	ldi	r19, 0x02	; 2
     e18:	f9 01       	movw	r30, r18
     e1a:	21 81       	ldd	r18, Z+1	; 0x01
     e1c:	29 7e       	andi	r18, 0xE9	; 233
     e1e:	fc 01       	movw	r30, r24
     e20:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     e22:	80 e4       	ldi	r24, 0x40	; 64
     e24:	92 e0       	ldi	r25, 0x02	; 2
     e26:	20 e4       	ldi	r18, 0x40	; 64
     e28:	32 e0       	ldi	r19, 0x02	; 2
     e2a:	f9 01       	movw	r30, r18
     e2c:	24 81       	ldd	r18, Z+4	; 0x04
     e2e:	28 7f       	andi	r18, 0xF8	; 248
     e30:	23 60       	ori	r18, 0x03	; 3
     e32:	fc 01       	movw	r30, r24
     e34:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     e36:	80 e4       	ldi	r24, 0x40	; 64
     e38:	92 e0       	ldi	r25, 0x02	; 2
     e3a:	20 e4       	ldi	r18, 0x40	; 64
     e3c:	32 e0       	ldi	r19, 0x02	; 2
     e3e:	f9 01       	movw	r30, r18
     e40:	22 81       	ldd	r18, Z+2	; 0x02
     e42:	2f 7c       	andi	r18, 0xCF	; 207
     e44:	fc 01       	movw	r30, r24
     e46:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     e48:	80 e6       	ldi	r24, 0x60	; 96
     e4a:	92 e0       	ldi	r25, 0x02	; 2
     e4c:	20 e6       	ldi	r18, 0x60	; 96
     e4e:	32 e0       	ldi	r19, 0x02	; 2
     e50:	f9 01       	movw	r30, r18
     e52:	20 81       	ld	r18, Z
     e54:	20 7e       	andi	r18, 0xE0	; 224
     e56:	21 60       	ori	r18, 0x01	; 1
     e58:	fc 01       	movw	r30, r24
     e5a:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     e5c:	80 e6       	ldi	r24, 0x60	; 96
     e5e:	92 e0       	ldi	r25, 0x02	; 2
     e60:	29 e0       	ldi	r18, 0x09	; 9
     e62:	fc 01       	movw	r30, r24
     e64:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     e66:	80 e4       	ldi	r24, 0x40	; 64
     e68:	92 e0       	ldi	r25, 0x02	; 2
     e6a:	20 e4       	ldi	r18, 0x40	; 64
     e6c:	32 e0       	ldi	r19, 0x02	; 2
     e6e:	f9 01       	movw	r30, r18
     e70:	20 81       	ld	r18, Z
     e72:	21 60       	ori	r18, 0x01	; 1
     e74:	fc 01       	movw	r30, r24
     e76:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     e78:	80 e4       	ldi	r24, 0x40	; 64
     e7a:	92 e0       	ldi	r25, 0x02	; 2
     e7c:	0e 94 72 20 	call	0x40e4	; 0x40e4 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     e80:	80 e4       	ldi	r24, 0x40	; 64
     e82:	92 e0       	ldi	r25, 0x02	; 2
     e84:	60 e6       	ldi	r22, 0x60	; 96
     e86:	72 e0       	ldi	r23, 0x02	; 2
     e88:	40 e0       	ldi	r20, 0x00	; 0
     e8a:	0e 94 69 21 	call	0x42d2	; 0x42d2 <ADC_Offset_Get_Unsigned>
     e8e:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     e90:	80 e4       	ldi	r24, 0x40	; 64
     e92:	92 e0       	ldi	r25, 0x02	; 2
     e94:	20 e4       	ldi	r18, 0x40	; 64
     e96:	32 e0       	ldi	r19, 0x02	; 2
     e98:	f9 01       	movw	r30, r18
     e9a:	20 81       	ld	r18, Z
     e9c:	2e 7f       	andi	r18, 0xFE	; 254
     e9e:	fc 01       	movw	r30, r24
     ea0:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     ea2:	80 e6       	ldi	r24, 0x60	; 96
     ea4:	92 e0       	ldi	r25, 0x02	; 2
     ea6:	fc 01       	movw	r30, r24
     ea8:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     eaa:	80 e4       	ldi	r24, 0x40	; 64
     eac:	92 e0       	ldi	r25, 0x02	; 2
     eae:	20 e4       	ldi	r18, 0x40	; 64
     eb0:	32 e0       	ldi	r19, 0x02	; 2
     eb2:	f9 01       	movw	r30, r18
     eb4:	23 81       	ldd	r18, Z+3	; 0x03
     eb6:	2f 73       	andi	r18, 0x3F	; 63
     eb8:	fc 01       	movw	r30, r24
     eba:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     ebc:	80 e4       	ldi	r24, 0x40	; 64
     ebe:	92 e0       	ldi	r25, 0x02	; 2
     ec0:	20 e4       	ldi	r18, 0x40	; 64
     ec2:	32 e0       	ldi	r19, 0x02	; 2
     ec4:	f9 01       	movw	r30, r18
     ec6:	20 81       	ld	r18, Z
     ec8:	21 60       	ori	r18, 0x01	; 1
     eca:	fc 01       	movw	r30, r24
     ecc:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     ece:	80 e4       	ldi	r24, 0x40	; 64
     ed0:	92 e0       	ldi	r25, 0x02	; 2
     ed2:	0e 94 72 20 	call	0x40e4	; 0x40e4 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     ed6:	80 e4       	ldi	r24, 0x40	; 64
     ed8:	92 e0       	ldi	r25, 0x02	; 2
     eda:	20 e4       	ldi	r18, 0x40	; 64
     edc:	32 e0       	ldi	r19, 0x02	; 2
     ede:	f9 01       	movw	r30, r18
     ee0:	21 81       	ldd	r18, Z+1	; 0x01
     ee2:	28 60       	ori	r18, 0x08	; 8
     ee4:	fc 01       	movw	r30, r24
     ee6:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     ee8:	1d 86       	std	Y+13, r1	; 0x0d
     eea:	1e 86       	std	Y+14, r1	; 0x0e
     eec:	56 c0       	rjmp	.+172    	; 0xf9a <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     eee:	80 e6       	ldi	r24, 0x60	; 96
     ef0:	92 e0       	ldi	r25, 0x02	; 2
     ef2:	fc 01       	movw	r30, r24
     ef4:	83 81       	ldd	r24, Z+3	; 0x03
     ef6:	88 2f       	mov	r24, r24
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	81 70       	andi	r24, 0x01	; 1
     efc:	90 70       	andi	r25, 0x00	; 0
     efe:	00 97       	sbiw	r24, 0x00	; 0
     f00:	b1 f3       	breq	.-20     	; 0xeee <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     f02:	2b a1       	lds	r18, 0x4b
     f04:	80 e6       	ldi	r24, 0x60	; 96
     f06:	92 e0       	ldi	r25, 0x02	; 2
     f08:	62 2f       	mov	r22, r18
     f0a:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <ADC_ResultCh_GetWord_Signed>
     f0e:	8f 87       	std	Y+15, r24	; 0x0f
     f10:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     f12:	8f 85       	ldd	r24, Y+15	; 0x0f
     f14:	98 89       	ldd	r25, Y+16	; 0x10
     f16:	cc 01       	movw	r24, r24
     f18:	a0 e0       	ldi	r26, 0x00	; 0
     f1a:	b0 e0       	ldi	r27, 0x00	; 0
     f1c:	29 81       	ldd	r18, Y+1	; 0x01
     f1e:	3a 81       	ldd	r19, Y+2	; 0x02
     f20:	4b 81       	ldd	r20, Y+3	; 0x03
     f22:	5c 81       	ldd	r21, Y+4	; 0x04
     f24:	82 0f       	add	r24, r18
     f26:	93 1f       	adc	r25, r19
     f28:	a4 1f       	adc	r26, r20
     f2a:	b5 1f       	adc	r27, r21
     f2c:	89 83       	std	Y+1, r24	; 0x01
     f2e:	9a 83       	std	Y+2, r25	; 0x02
     f30:	ab 83       	std	Y+3, r26	; 0x03
     f32:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     f34:	8f 85       	ldd	r24, Y+15	; 0x0f
     f36:	98 89       	ldd	r25, Y+16	; 0x10
     f38:	9c 01       	movw	r18, r24
     f3a:	40 e0       	ldi	r20, 0x00	; 0
     f3c:	50 e0       	ldi	r21, 0x00	; 0
     f3e:	89 85       	ldd	r24, Y+9	; 0x09
     f40:	9a 85       	ldd	r25, Y+10	; 0x0a
     f42:	ab 85       	ldd	r26, Y+11	; 0x0b
     f44:	bc 85       	ldd	r27, Y+12	; 0x0c
     f46:	82 17       	cp	r24, r18
     f48:	93 07       	cpc	r25, r19
     f4a:	a4 07       	cpc	r26, r20
     f4c:	b5 07       	cpc	r27, r21
     f4e:	48 f4       	brcc	.+18     	; 0xf62 <CO_collectBatt+0x2ae>
     f50:	8f 85       	ldd	r24, Y+15	; 0x0f
     f52:	98 89       	ldd	r25, Y+16	; 0x10
     f54:	cc 01       	movw	r24, r24
     f56:	a0 e0       	ldi	r26, 0x00	; 0
     f58:	b0 e0       	ldi	r27, 0x00	; 0
     f5a:	89 87       	std	Y+9, r24	; 0x09
     f5c:	9a 87       	std	Y+10, r25	; 0x0a
     f5e:	ab 87       	std	Y+11, r26	; 0x0b
     f60:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     f62:	8f 85       	ldd	r24, Y+15	; 0x0f
     f64:	98 89       	ldd	r25, Y+16	; 0x10
     f66:	9c 01       	movw	r18, r24
     f68:	40 e0       	ldi	r20, 0x00	; 0
     f6a:	50 e0       	ldi	r21, 0x00	; 0
     f6c:	8d 81       	ldd	r24, Y+5	; 0x05
     f6e:	9e 81       	ldd	r25, Y+6	; 0x06
     f70:	af 81       	ldd	r26, Y+7	; 0x07
     f72:	b8 85       	ldd	r27, Y+8	; 0x08
     f74:	28 17       	cp	r18, r24
     f76:	39 07       	cpc	r19, r25
     f78:	4a 07       	cpc	r20, r26
     f7a:	5b 07       	cpc	r21, r27
     f7c:	48 f4       	brcc	.+18     	; 0xf90 <CO_collectBatt+0x2dc>
     f7e:	8f 85       	ldd	r24, Y+15	; 0x0f
     f80:	98 89       	ldd	r25, Y+16	; 0x10
     f82:	cc 01       	movw	r24, r24
     f84:	a0 e0       	ldi	r26, 0x00	; 0
     f86:	b0 e0       	ldi	r27, 0x00	; 0
     f88:	8d 83       	std	Y+5, r24	; 0x05
     f8a:	9e 83       	std	Y+6, r25	; 0x06
     f8c:	af 83       	std	Y+7, r26	; 0x07
     f8e:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     f90:	8d 85       	ldd	r24, Y+13	; 0x0d
     f92:	9e 85       	ldd	r25, Y+14	; 0x0e
     f94:	01 96       	adiw	r24, 0x01	; 1
     f96:	8d 87       	std	Y+13, r24	; 0x0d
     f98:	9e 87       	std	Y+14, r25	; 0x0e
     f9a:	8d 85       	ldd	r24, Y+13	; 0x0d
     f9c:	9e 85       	ldd	r25, Y+14	; 0x0e
     f9e:	f4 e0       	ldi	r31, 0x04	; 4
     fa0:	80 30       	cpi	r24, 0x00	; 0
     fa2:	9f 07       	cpc	r25, r31
     fa4:	08 f4       	brcc	.+2      	; 0xfa8 <CO_collectBatt+0x2f4>
     fa6:	a3 cf       	rjmp	.-186    	; 0xeee <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     fa8:	80 e4       	ldi	r24, 0x40	; 64
     faa:	92 e0       	ldi	r25, 0x02	; 2
     fac:	20 e4       	ldi	r18, 0x40	; 64
     fae:	32 e0       	ldi	r19, 0x02	; 2
     fb0:	f9 01       	movw	r30, r18
     fb2:	21 81       	ldd	r18, Z+1	; 0x01
     fb4:	27 7f       	andi	r18, 0xF7	; 247
     fb6:	fc 01       	movw	r30, r24
     fb8:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     fba:	80 e4       	ldi	r24, 0x40	; 64
     fbc:	92 e0       	ldi	r25, 0x02	; 2
     fbe:	20 e4       	ldi	r18, 0x40	; 64
     fc0:	32 e0       	ldi	r19, 0x02	; 2
     fc2:	f9 01       	movw	r30, r18
     fc4:	20 81       	ld	r18, Z
     fc6:	2e 7f       	andi	r18, 0xFE	; 254
     fc8:	fc 01       	movw	r30, r24
     fca:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     fcc:	89 81       	ldd	r24, Y+1	; 0x01
     fce:	9a 81       	ldd	r25, Y+2	; 0x02
     fd0:	ab 81       	ldd	r26, Y+3	; 0x03
     fd2:	bc 81       	ldd	r27, Y+4	; 0x04
     fd4:	07 2e       	mov	r0, r23
     fd6:	7a e0       	ldi	r23, 0x0A	; 10
     fd8:	b6 95       	lsr	r27
     fda:	a7 95       	ror	r26
     fdc:	97 95       	ror	r25
     fde:	87 95       	ror	r24
     fe0:	7a 95       	dec	r23
     fe2:	d1 f7       	brne	.-12     	; 0xfd8 <CO_collectBatt+0x324>
     fe4:	70 2d       	mov	r23, r0
     fe6:	89 8b       	std	Y+17, r24	; 0x11
     fe8:	9a 8b       	std	Y+18, r25	; 0x12
     fea:	ab 8b       	std	Y+19, r26	; 0x13
     fec:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     fee:	84 e0       	ldi	r24, 0x04	; 4
     ff0:	60 e0       	ldi	r22, 0x00	; 0
     ff2:	0e 94 a6 36 	call	0x6d4c	; 0x6d4c <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     ff6:	80 e0       	ldi	r24, 0x00	; 0
     ff8:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     ffc:	89 89       	ldd	r24, Y+17	; 0x11
     ffe:	9a 89       	ldd	r25, Y+18	; 0x12
    1000:	ab 89       	ldd	r26, Y+19	; 0x13
    1002:	bc 89       	ldd	r27, Y+20	; 0x14
    1004:	28 ee       	ldi	r18, 0xE8	; 232
    1006:	33 e0       	ldi	r19, 0x03	; 3
    1008:	40 e0       	ldi	r20, 0x00	; 0
    100a:	50 e0       	ldi	r21, 0x00	; 0
    100c:	bc 01       	movw	r22, r24
    100e:	cd 01       	movw	r24, r26
    1010:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    1014:	dc 01       	movw	r26, r24
    1016:	cb 01       	movw	r24, r22
    1018:	2f ef       	ldi	r18, 0xFF	; 255
    101a:	3f e0       	ldi	r19, 0x0F	; 15
    101c:	40 e0       	ldi	r20, 0x00	; 0
    101e:	50 e0       	ldi	r21, 0x00	; 0
    1020:	bc 01       	movw	r22, r24
    1022:	cd 01       	movw	r24, r26
    1024:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    1028:	da 01       	movw	r26, r20
    102a:	c9 01       	movw	r24, r18
    102c:	9c 01       	movw	r18, r24
    102e:	22 53       	subi	r18, 0x32	; 50
    1030:	30 40       	sbci	r19, 0x00	; 0
    1032:	8c a1       	lds	r24, 0x4c
    1034:	9d a1       	lds	r25, 0x4d
    1036:	fc 01       	movw	r30, r24
    1038:	20 83       	st	Z, r18
    103a:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
    103c:	89 85       	ldd	r24, Y+9	; 0x09
    103e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1040:	ab 85       	ldd	r26, Y+11	; 0x0b
    1042:	bc 85       	ldd	r27, Y+12	; 0x0c
    1044:	28 ee       	ldi	r18, 0xE8	; 232
    1046:	33 e0       	ldi	r19, 0x03	; 3
    1048:	40 e0       	ldi	r20, 0x00	; 0
    104a:	50 e0       	ldi	r21, 0x00	; 0
    104c:	bc 01       	movw	r22, r24
    104e:	cd 01       	movw	r24, r26
    1050:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    1054:	dc 01       	movw	r26, r24
    1056:	cb 01       	movw	r24, r22
    1058:	2f ef       	ldi	r18, 0xFF	; 255
    105a:	3f e0       	ldi	r19, 0x0F	; 15
    105c:	40 e0       	ldi	r20, 0x00	; 0
    105e:	50 e0       	ldi	r21, 0x00	; 0
    1060:	bc 01       	movw	r22, r24
    1062:	cd 01       	movw	r24, r26
    1064:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    1068:	da 01       	movw	r26, r20
    106a:	c9 01       	movw	r24, r18
    106c:	9c 01       	movw	r18, r24
    106e:	22 53       	subi	r18, 0x32	; 50
    1070:	30 40       	sbci	r19, 0x00	; 0
    1072:	88 a5       	lds	r24, 0x68
    1074:	99 a5       	lds	r25, 0x69
    1076:	fc 01       	movw	r30, r24
    1078:	20 83       	st	Z, r18
    107a:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    107c:	8d 81       	ldd	r24, Y+5	; 0x05
    107e:	9e 81       	ldd	r25, Y+6	; 0x06
    1080:	af 81       	ldd	r26, Y+7	; 0x07
    1082:	b8 85       	ldd	r27, Y+8	; 0x08
    1084:	28 ee       	ldi	r18, 0xE8	; 232
    1086:	33 e0       	ldi	r19, 0x03	; 3
    1088:	40 e0       	ldi	r20, 0x00	; 0
    108a:	50 e0       	ldi	r21, 0x00	; 0
    108c:	bc 01       	movw	r22, r24
    108e:	cd 01       	movw	r24, r26
    1090:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    1094:	dc 01       	movw	r26, r24
    1096:	cb 01       	movw	r24, r22
    1098:	2f ef       	ldi	r18, 0xFF	; 255
    109a:	3f e0       	ldi	r19, 0x0F	; 15
    109c:	40 e0       	ldi	r20, 0x00	; 0
    109e:	50 e0       	ldi	r21, 0x00	; 0
    10a0:	bc 01       	movw	r22, r24
    10a2:	cd 01       	movw	r24, r26
    10a4:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    10a8:	da 01       	movw	r26, r20
    10aa:	c9 01       	movw	r24, r18
    10ac:	9c 01       	movw	r18, r24
    10ae:	22 53       	subi	r18, 0x32	; 50
    10b0:	30 40       	sbci	r19, 0x00	; 0
    10b2:	8e a1       	lds	r24, 0x4e
    10b4:	9f a1       	lds	r25, 0x4f
    10b6:	fc 01       	movw	r30, r24
    10b8:	20 83       	st	Z, r18
    10ba:	31 83       	std	Z+1, r19	; 0x01
}
    10bc:	a9 96       	adiw	r28, 0x29	; 41
    10be:	cd bf       	out	0x3d, r28	; 61
    10c0:	de bf       	out	0x3e, r29	; 62
    10c2:	df 91       	pop	r29
    10c4:	cf 91       	pop	r28
    10c6:	1f 91       	pop	r17
    10c8:	0f 91       	pop	r16
    10ca:	08 95       	ret

000010cc <ADCPower>:

void ADCPower(uint8_t on) {
    10cc:	0f 93       	push	r16
    10ce:	1f 93       	push	r17
    10d0:	cf 93       	push	r28
    10d2:	df 93       	push	r29
    10d4:	cd b7       	in	r28, 0x3d	; 61
    10d6:	de b7       	in	r29, 0x3e	; 62
    10d8:	2f 97       	sbiw	r28, 0x0f	; 15
    10da:	cd bf       	out	0x3d, r28	; 61
    10dc:	de bf       	out	0x3e, r29	; 62
    10de:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
    10e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    10e2:	88 23       	and	r24, r24
    10e4:	09 f4       	brne	.+2      	; 0x10e8 <ADCPower+0x1c>
    10e6:	ce c0       	rjmp	.+412    	; 0x1284 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
    10e8:	80 e0       	ldi	r24, 0x00	; 0
    10ea:	96 e0       	ldi	r25, 0x06	; 6
    10ec:	2e ed       	ldi	r18, 0xDE	; 222
    10ee:	fc 01       	movw	r30, r24
    10f0:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
    10f2:	80 e2       	ldi	r24, 0x20	; 32
    10f4:	96 e0       	ldi	r25, 0x06	; 6
    10f6:	2e e0       	ldi	r18, 0x0E	; 14
    10f8:	fc 01       	movw	r30, r24
    10fa:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
    10fc:	80 e4       	ldi	r24, 0x40	; 64
    10fe:	96 e0       	ldi	r25, 0x06	; 6
    1100:	23 e0       	ldi	r18, 0x03	; 3
    1102:	fc 01       	movw	r30, r24
    1104:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
    1106:	80 e8       	ldi	r24, 0x80	; 128
    1108:	96 e0       	ldi	r25, 0x06	; 6
    110a:	20 e1       	ldi	r18, 0x10	; 16
    110c:	fc 01       	movw	r30, r24
    110e:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
    1110:	80 ea       	ldi	r24, 0xA0	; 160
    1112:	96 e0       	ldi	r25, 0x06	; 6
    1114:	2e e0       	ldi	r18, 0x0E	; 14
    1116:	fc 01       	movw	r30, r24
    1118:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
    111a:	80 e0       	ldi	r24, 0x00	; 0
    111c:	96 e0       	ldi	r25, 0x06	; 6
    111e:	2e e9       	ldi	r18, 0x9E	; 158
    1120:	fc 01       	movw	r30, r24
    1122:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
    1124:	80 e2       	ldi	r24, 0x20	; 32
    1126:	96 e0       	ldi	r25, 0x06	; 6
    1128:	28 e0       	ldi	r18, 0x08	; 8
    112a:	fc 01       	movw	r30, r24
    112c:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
    112e:	80 e4       	ldi	r24, 0x40	; 64
    1130:	96 e0       	ldi	r25, 0x06	; 6
    1132:	23 e0       	ldi	r18, 0x03	; 3
    1134:	fc 01       	movw	r30, r24
    1136:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
    1138:	80 e8       	ldi	r24, 0x80	; 128
    113a:	96 e0       	ldi	r25, 0x06	; 6
    113c:	20 e1       	ldi	r18, 0x10	; 16
    113e:	fc 01       	movw	r30, r24
    1140:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
    1142:	80 ea       	ldi	r24, 0xA0	; 160
    1144:	96 e0       	ldi	r25, 0x06	; 6
    1146:	2e e0       	ldi	r18, 0x0E	; 14
    1148:	fc 01       	movw	r30, r24
    114a:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
    114c:	10 92 79 50 	sts	0x5079, r1
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	a8 ec       	ldi	r26, 0xC8	; 200
    1156:	b2 e4       	ldi	r27, 0x42	; 66
    1158:	89 83       	std	Y+1, r24	; 0x01
    115a:	9a 83       	std	Y+2, r25	; 0x02
    115c:	ab 83       	std	Y+3, r26	; 0x03
    115e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    1160:	69 81       	ldd	r22, Y+1	; 0x01
    1162:	7a 81       	ldd	r23, Y+2	; 0x02
    1164:	8b 81       	ldd	r24, Y+3	; 0x03
    1166:	9c 81       	ldd	r25, Y+4	; 0x04
    1168:	20 e0       	ldi	r18, 0x00	; 0
    116a:	30 e0       	ldi	r19, 0x00	; 0
    116c:	4a ef       	ldi	r20, 0xFA	; 250
    116e:	55 e4       	ldi	r21, 0x45	; 69
    1170:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    1174:	dc 01       	movw	r26, r24
    1176:	cb 01       	movw	r24, r22
    1178:	8d 83       	std	Y+5, r24	; 0x05
    117a:	9e 83       	std	Y+6, r25	; 0x06
    117c:	af 83       	std	Y+7, r26	; 0x07
    117e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    1180:	11 e0       	ldi	r17, 0x01	; 1
    1182:	6d 81       	ldd	r22, Y+5	; 0x05
    1184:	7e 81       	ldd	r23, Y+6	; 0x06
    1186:	8f 81       	ldd	r24, Y+7	; 0x07
    1188:	98 85       	ldd	r25, Y+8	; 0x08
    118a:	20 e0       	ldi	r18, 0x00	; 0
    118c:	30 e0       	ldi	r19, 0x00	; 0
    118e:	40 e8       	ldi	r20, 0x80	; 128
    1190:	5f e3       	ldi	r21, 0x3F	; 63
    1192:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    1196:	88 23       	and	r24, r24
    1198:	0c f0       	brlt	.+2      	; 0x119c <ADCPower+0xd0>
    119a:	10 e0       	ldi	r17, 0x00	; 0
    119c:	11 23       	and	r17, r17
    119e:	29 f0       	breq	.+10     	; 0x11aa <ADCPower+0xde>
		__ticks = 1;
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	89 87       	std	Y+9, r24	; 0x09
    11a6:	9a 87       	std	Y+10, r25	; 0x0a
    11a8:	46 c0       	rjmp	.+140    	; 0x1236 <ADCPower+0x16a>
	else if (__tmp > 65535)
    11aa:	11 e0       	ldi	r17, 0x01	; 1
    11ac:	6d 81       	ldd	r22, Y+5	; 0x05
    11ae:	7e 81       	ldd	r23, Y+6	; 0x06
    11b0:	8f 81       	ldd	r24, Y+7	; 0x07
    11b2:	98 85       	ldd	r25, Y+8	; 0x08
    11b4:	20 e0       	ldi	r18, 0x00	; 0
    11b6:	3f ef       	ldi	r19, 0xFF	; 255
    11b8:	4f e7       	ldi	r20, 0x7F	; 127
    11ba:	57 e4       	ldi	r21, 0x47	; 71
    11bc:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    11c0:	18 16       	cp	r1, r24
    11c2:	0c f0       	brlt	.+2      	; 0x11c6 <ADCPower+0xfa>
    11c4:	10 e0       	ldi	r17, 0x00	; 0
    11c6:	11 23       	and	r17, r17
    11c8:	61 f1       	breq	.+88     	; 0x1222 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    11ca:	69 81       	ldd	r22, Y+1	; 0x01
    11cc:	7a 81       	ldd	r23, Y+2	; 0x02
    11ce:	8b 81       	ldd	r24, Y+3	; 0x03
    11d0:	9c 81       	ldd	r25, Y+4	; 0x04
    11d2:	20 e0       	ldi	r18, 0x00	; 0
    11d4:	30 e0       	ldi	r19, 0x00	; 0
    11d6:	40 e2       	ldi	r20, 0x20	; 32
    11d8:	51 e4       	ldi	r21, 0x41	; 65
    11da:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    11de:	dc 01       	movw	r26, r24
    11e0:	cb 01       	movw	r24, r22
    11e2:	bc 01       	movw	r22, r24
    11e4:	cd 01       	movw	r24, r26
    11e6:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    11ea:	dc 01       	movw	r26, r24
    11ec:	cb 01       	movw	r24, r22
    11ee:	89 87       	std	Y+9, r24	; 0x09
    11f0:	9a 87       	std	Y+10, r25	; 0x0a
    11f2:	12 c0       	rjmp	.+36     	; 0x1218 <ADCPower+0x14c>
    11f4:	80 e2       	ldi	r24, 0x20	; 32
    11f6:	93 e0       	ldi	r25, 0x03	; 3
    11f8:	8b 87       	std	Y+11, r24	; 0x0b
    11fa:	9c 87       	std	Y+12, r25	; 0x0c
    11fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    11fe:	9c 85       	ldd	r25, Y+12	; 0x0c
    1200:	8c 01       	movw	r16, r24
    1202:	c8 01       	movw	r24, r16
    1204:	01 97       	sbiw	r24, 0x01	; 1
    1206:	f1 f7       	brne	.-4      	; 0x1204 <ADCPower+0x138>
    1208:	8c 01       	movw	r16, r24
    120a:	0b 87       	std	Y+11, r16	; 0x0b
    120c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    120e:	89 85       	ldd	r24, Y+9	; 0x09
    1210:	9a 85       	ldd	r25, Y+10	; 0x0a
    1212:	01 97       	sbiw	r24, 0x01	; 1
    1214:	89 87       	std	Y+9, r24	; 0x09
    1216:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1218:	89 85       	ldd	r24, Y+9	; 0x09
    121a:	9a 85       	ldd	r25, Y+10	; 0x0a
    121c:	00 97       	sbiw	r24, 0x00	; 0
    121e:	51 f7       	brne	.-44     	; 0x11f4 <ADCPower+0x128>
    1220:	17 c0       	rjmp	.+46     	; 0x1250 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1222:	6d 81       	ldd	r22, Y+5	; 0x05
    1224:	7e 81       	ldd	r23, Y+6	; 0x06
    1226:	8f 81       	ldd	r24, Y+7	; 0x07
    1228:	98 85       	ldd	r25, Y+8	; 0x08
    122a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    122e:	dc 01       	movw	r26, r24
    1230:	cb 01       	movw	r24, r22
    1232:	89 87       	std	Y+9, r24	; 0x09
    1234:	9a 87       	std	Y+10, r25	; 0x0a
    1236:	89 85       	ldd	r24, Y+9	; 0x09
    1238:	9a 85       	ldd	r25, Y+10	; 0x0a
    123a:	8d 87       	std	Y+13, r24	; 0x0d
    123c:	9e 87       	std	Y+14, r25	; 0x0e
    123e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1240:	9e 85       	ldd	r25, Y+14	; 0x0e
    1242:	8c 01       	movw	r16, r24
    1244:	f8 01       	movw	r30, r16
    1246:	31 97       	sbiw	r30, 0x01	; 1
    1248:	f1 f7       	brne	.-4      	; 0x1246 <ADCPower+0x17a>
    124a:	8f 01       	movw	r16, r30
    124c:	0d 87       	std	Y+13, r16	; 0x0d
    124e:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
    1250:	80 e4       	ldi	r24, 0x40	; 64
    1252:	96 e0       	ldi	r25, 0x06	; 6
    1254:	20 e4       	ldi	r18, 0x40	; 64
    1256:	fc 01       	movw	r30, r24
    1258:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
    125a:	80 e0       	ldi	r24, 0x00	; 0
    125c:	80 93 7a 50 	sts	0x507A, r24
    1260:	80 93 c6 50 	sts	0x50C6, r24
    1264:	80 93 ce 23 	sts	0x23CE, r24
    1268:	80 93 72 50 	sts	0x5072, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
    126c:	8f ef       	ldi	r24, 0xFF	; 255
    126e:	61 e0       	ldi	r22, 0x01	; 1
    1270:	0e 94 42 36 	call	0x6c84	; 0x6c84 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
    1274:	8f ef       	ldi	r24, 0xFF	; 255
    1276:	61 e0       	ldi	r22, 0x01	; 1
    1278:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
    127c:	8f ef       	ldi	r24, 0xFF	; 255
    127e:	0e 94 bb 0a 	call	0x1576	; 0x1576 <set_filter>
    1282:	42 c0       	rjmp	.+132    	; 0x1308 <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
    1284:	80 e0       	ldi	r24, 0x00	; 0
    1286:	96 e0       	ldi	r25, 0x06	; 6
    1288:	2e ed       	ldi	r18, 0xDE	; 222
    128a:	fc 01       	movw	r30, r24
    128c:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
    128e:	80 e2       	ldi	r24, 0x20	; 32
    1290:	96 e0       	ldi	r25, 0x06	; 6
    1292:	2e e0       	ldi	r18, 0x0E	; 14
    1294:	fc 01       	movw	r30, r24
    1296:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
    1298:	80 e4       	ldi	r24, 0x40	; 64
    129a:	96 e0       	ldi	r25, 0x06	; 6
    129c:	23 e0       	ldi	r18, 0x03	; 3
    129e:	fc 01       	movw	r30, r24
    12a0:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
    12a2:	80 e8       	ldi	r24, 0x80	; 128
    12a4:	96 e0       	ldi	r25, 0x06	; 6
    12a6:	20 e1       	ldi	r18, 0x10	; 16
    12a8:	fc 01       	movw	r30, r24
    12aa:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
    12ac:	80 ea       	ldi	r24, 0xA0	; 160
    12ae:	96 e0       	ldi	r25, 0x06	; 6
    12b0:	2e e0       	ldi	r18, 0x0E	; 14
    12b2:	fc 01       	movw	r30, r24
    12b4:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	96 e0       	ldi	r25, 0x06	; 6
    12ba:	2e ed       	ldi	r18, 0xDE	; 222
    12bc:	fc 01       	movw	r30, r24
    12be:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
    12c0:	80 e2       	ldi	r24, 0x20	; 32
    12c2:	96 e0       	ldi	r25, 0x06	; 6
    12c4:	2e e0       	ldi	r18, 0x0E	; 14
    12c6:	fc 01       	movw	r30, r24
    12c8:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
    12ca:	80 e4       	ldi	r24, 0x40	; 64
    12cc:	96 e0       	ldi	r25, 0x06	; 6
    12ce:	23 e0       	ldi	r18, 0x03	; 3
    12d0:	fc 01       	movw	r30, r24
    12d2:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
    12d4:	80 e8       	ldi	r24, 0x80	; 128
    12d6:	96 e0       	ldi	r25, 0x06	; 6
    12d8:	20 e1       	ldi	r18, 0x10	; 16
    12da:	fc 01       	movw	r30, r24
    12dc:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
    12de:	80 ea       	ldi	r24, 0xA0	; 160
    12e0:	96 e0       	ldi	r25, 0x06	; 6
    12e2:	2e e0       	ldi	r18, 0x0E	; 14
    12e4:	fc 01       	movw	r30, r24
    12e6:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
    12e8:	80 e4       	ldi	r24, 0x40	; 64
    12ea:	96 e0       	ldi	r25, 0x06	; 6
    12ec:	20 e4       	ldi	r18, 0x40	; 64
    12ee:	fc 01       	movw	r30, r24
    12f0:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
    12f2:	80 e0       	ldi	r24, 0x00	; 0
    12f4:	80 93 7a 50 	sts	0x507A, r24
    12f8:	80 93 c6 50 	sts	0x50C6, r24
    12fc:	80 93 ce 23 	sts	0x23CE, r24
    1300:	80 93 72 50 	sts	0x5072, r24
		channelStatus = 0x00;
    1304:	10 92 79 50 	sts	0x5079, r1
		
	}
}
    1308:	2f 96       	adiw	r28, 0x0f	; 15
    130a:	cd bf       	out	0x3d, r28	; 61
    130c:	de bf       	out	0x3e, r29	; 62
    130e:	df 91       	pop	r29
    1310:	cf 91       	pop	r28
    1312:	1f 91       	pop	r17
    1314:	0f 91       	pop	r16
    1316:	08 95       	ret

00001318 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    1318:	0f 93       	push	r16
    131a:	1f 93       	push	r17
    131c:	cf 93       	push	r28
    131e:	df 93       	push	r29
    1320:	cd b7       	in	r28, 0x3d	; 61
    1322:	de b7       	in	r29, 0x3e	; 62
    1324:	6a 97       	sbiw	r28, 0x1a	; 26
    1326:	cd bf       	out	0x3d, r28	; 61
    1328:	de bf       	out	0x3e, r29	; 62
    132a:	89 8f       	std	Y+25, r24	; 0x19
    132c:	6a 8f       	std	Y+26, r22	; 0x1a
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    132e:	89 8d       	ldd	r24, Y+25	; 0x19
    1330:	28 2f       	mov	r18, r24
    1332:	30 e0       	ldi	r19, 0x00	; 0
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	02 c0       	rjmp	.+4      	; 0x133e <set_ampGain+0x26>
    133a:	88 0f       	add	r24, r24
    133c:	99 1f       	adc	r25, r25
    133e:	2a 95       	dec	r18
    1340:	e2 f7       	brpl	.-8      	; 0x133a <set_ampGain+0x22>
    1342:	61 e0       	ldi	r22, 0x01	; 1
    1344:	0e 94 71 37 	call	0x6ee2	; 0x6ee2 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    1348:	8a 8d       	ldd	r24, Y+26	; 0x1a
    134a:	88 2f       	mov	r24, r24
    134c:	90 e0       	ldi	r25, 0x00	; 0
    134e:	81 70       	andi	r24, 0x01	; 1
    1350:	90 70       	andi	r25, 0x00	; 0
    1352:	88 23       	and	r24, r24
    1354:	31 f0       	breq	.+12     	; 0x1362 <set_ampGain+0x4a>
    1356:	80 e0       	ldi	r24, 0x00	; 0
    1358:	96 e0       	ldi	r25, 0x06	; 6
    135a:	20 e4       	ldi	r18, 0x40	; 64
    135c:	fc 01       	movw	r30, r24
    135e:	25 83       	std	Z+5, r18	; 0x05
    1360:	05 c0       	rjmp	.+10     	; 0x136c <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
    1362:	80 e0       	ldi	r24, 0x00	; 0
    1364:	96 e0       	ldi	r25, 0x06	; 6
    1366:	20 e4       	ldi	r18, 0x40	; 64
    1368:	fc 01       	movw	r30, r24
    136a:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    136c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    136e:	88 2f       	mov	r24, r24
    1370:	90 e0       	ldi	r25, 0x00	; 0
    1372:	82 70       	andi	r24, 0x02	; 2
    1374:	90 70       	andi	r25, 0x00	; 0
    1376:	00 97       	sbiw	r24, 0x00	; 0
    1378:	31 f0       	breq	.+12     	; 0x1386 <set_ampGain+0x6e>
    137a:	80 e2       	ldi	r24, 0x20	; 32
    137c:	96 e0       	ldi	r25, 0x06	; 6
    137e:	22 e0       	ldi	r18, 0x02	; 2
    1380:	fc 01       	movw	r30, r24
    1382:	25 83       	std	Z+5, r18	; 0x05
    1384:	05 c0       	rjmp	.+10     	; 0x1390 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
    1386:	80 e2       	ldi	r24, 0x20	; 32
    1388:	96 e0       	ldi	r25, 0x06	; 6
    138a:	22 e0       	ldi	r18, 0x02	; 2
    138c:	fc 01       	movw	r30, r24
    138e:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    1390:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1392:	88 2f       	mov	r24, r24
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	84 70       	andi	r24, 0x04	; 4
    1398:	90 70       	andi	r25, 0x00	; 0
    139a:	00 97       	sbiw	r24, 0x00	; 0
    139c:	31 f0       	breq	.+12     	; 0x13aa <set_ampGain+0x92>
    139e:	80 e2       	ldi	r24, 0x20	; 32
    13a0:	96 e0       	ldi	r25, 0x06	; 6
    13a2:	24 e0       	ldi	r18, 0x04	; 4
    13a4:	fc 01       	movw	r30, r24
    13a6:	25 83       	std	Z+5, r18	; 0x05
    13a8:	05 c0       	rjmp	.+10     	; 0x13b4 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
    13aa:	80 e2       	ldi	r24, 0x20	; 32
    13ac:	96 e0       	ldi	r25, 0x06	; 6
    13ae:	24 e0       	ldi	r18, 0x04	; 4
    13b0:	fc 01       	movw	r30, r24
    13b2:	26 83       	std	Z+6, r18	; 0x06
    13b4:	80 e0       	ldi	r24, 0x00	; 0
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	a0 e8       	ldi	r26, 0x80	; 128
    13ba:	bf e3       	ldi	r27, 0x3F	; 63
    13bc:	89 83       	std	Y+1, r24	; 0x01
    13be:	9a 83       	std	Y+2, r25	; 0x02
    13c0:	ab 83       	std	Y+3, r26	; 0x03
    13c2:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    13c4:	69 81       	ldd	r22, Y+1	; 0x01
    13c6:	7a 81       	ldd	r23, Y+2	; 0x02
    13c8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ca:	9c 81       	ldd	r25, Y+4	; 0x04
    13cc:	2b ea       	ldi	r18, 0xAB	; 171
    13ce:	3a ea       	ldi	r19, 0xAA	; 170
    13d0:	4a e2       	ldi	r20, 0x2A	; 42
    13d2:	51 e4       	ldi	r21, 0x41	; 65
    13d4:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    13d8:	dc 01       	movw	r26, r24
    13da:	cb 01       	movw	r24, r22
    13dc:	8d 83       	std	Y+5, r24	; 0x05
    13de:	9e 83       	std	Y+6, r25	; 0x06
    13e0:	af 83       	std	Y+7, r26	; 0x07
    13e2:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    13e4:	11 e0       	ldi	r17, 0x01	; 1
    13e6:	6d 81       	ldd	r22, Y+5	; 0x05
    13e8:	7e 81       	ldd	r23, Y+6	; 0x06
    13ea:	8f 81       	ldd	r24, Y+7	; 0x07
    13ec:	98 85       	ldd	r25, Y+8	; 0x08
    13ee:	20 e0       	ldi	r18, 0x00	; 0
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	40 e8       	ldi	r20, 0x80	; 128
    13f4:	5f e3       	ldi	r21, 0x3F	; 63
    13f6:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    13fa:	88 23       	and	r24, r24
    13fc:	0c f0       	brlt	.+2      	; 0x1400 <set_ampGain+0xe8>
    13fe:	10 e0       	ldi	r17, 0x00	; 0
    1400:	11 23       	and	r17, r17
    1402:	19 f0       	breq	.+6      	; 0x140a <set_ampGain+0xf2>
		__ticks = 1;
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	89 87       	std	Y+9, r24	; 0x09
    1408:	a3 c0       	rjmp	.+326    	; 0x1550 <set_ampGain+0x238>
	else if (__tmp > 255)
    140a:	11 e0       	ldi	r17, 0x01	; 1
    140c:	6d 81       	ldd	r22, Y+5	; 0x05
    140e:	7e 81       	ldd	r23, Y+6	; 0x06
    1410:	8f 81       	ldd	r24, Y+7	; 0x07
    1412:	98 85       	ldd	r25, Y+8	; 0x08
    1414:	20 e0       	ldi	r18, 0x00	; 0
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	4f e7       	ldi	r20, 0x7F	; 127
    141a:	53 e4       	ldi	r21, 0x43	; 67
    141c:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    1420:	18 16       	cp	r1, r24
    1422:	0c f0       	brlt	.+2      	; 0x1426 <set_ampGain+0x10e>
    1424:	10 e0       	ldi	r17, 0x00	; 0
    1426:	11 23       	and	r17, r17
    1428:	09 f4       	brne	.+2      	; 0x142c <set_ampGain+0x114>
    142a:	89 c0       	rjmp	.+274    	; 0x153e <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
    142c:	69 81       	ldd	r22, Y+1	; 0x01
    142e:	7a 81       	ldd	r23, Y+2	; 0x02
    1430:	8b 81       	ldd	r24, Y+3	; 0x03
    1432:	9c 81       	ldd	r25, Y+4	; 0x04
    1434:	20 e0       	ldi	r18, 0x00	; 0
    1436:	30 e0       	ldi	r19, 0x00	; 0
    1438:	4a e7       	ldi	r20, 0x7A	; 122
    143a:	54 e4       	ldi	r21, 0x44	; 68
    143c:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    1440:	dc 01       	movw	r26, r24
    1442:	cb 01       	movw	r24, r22
    1444:	8a 87       	std	Y+10, r24	; 0x0a
    1446:	9b 87       	std	Y+11, r25	; 0x0b
    1448:	ac 87       	std	Y+12, r26	; 0x0c
    144a:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    144c:	6a 85       	ldd	r22, Y+10	; 0x0a
    144e:	7b 85       	ldd	r23, Y+11	; 0x0b
    1450:	8c 85       	ldd	r24, Y+12	; 0x0c
    1452:	9d 85       	ldd	r25, Y+13	; 0x0d
    1454:	20 e0       	ldi	r18, 0x00	; 0
    1456:	30 e0       	ldi	r19, 0x00	; 0
    1458:	4a ef       	ldi	r20, 0xFA	; 250
    145a:	55 e4       	ldi	r21, 0x45	; 69
    145c:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    1460:	dc 01       	movw	r26, r24
    1462:	cb 01       	movw	r24, r22
    1464:	8e 87       	std	Y+14, r24	; 0x0e
    1466:	9f 87       	std	Y+15, r25	; 0x0f
    1468:	a8 8b       	std	Y+16, r26	; 0x10
    146a:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    146c:	11 e0       	ldi	r17, 0x01	; 1
    146e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1470:	7f 85       	ldd	r23, Y+15	; 0x0f
    1472:	88 89       	ldd	r24, Y+16	; 0x10
    1474:	99 89       	ldd	r25, Y+17	; 0x11
    1476:	20 e0       	ldi	r18, 0x00	; 0
    1478:	30 e0       	ldi	r19, 0x00	; 0
    147a:	40 e8       	ldi	r20, 0x80	; 128
    147c:	5f e3       	ldi	r21, 0x3F	; 63
    147e:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    1482:	88 23       	and	r24, r24
    1484:	0c f0       	brlt	.+2      	; 0x1488 <set_ampGain+0x170>
    1486:	10 e0       	ldi	r17, 0x00	; 0
    1488:	11 23       	and	r17, r17
    148a:	29 f0       	breq	.+10     	; 0x1496 <set_ampGain+0x17e>
		__ticks = 1;
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	8a 8b       	std	Y+18, r24	; 0x12
    1492:	9b 8b       	std	Y+19, r25	; 0x13
    1494:	46 c0       	rjmp	.+140    	; 0x1522 <set_ampGain+0x20a>
	else if (__tmp > 65535)
    1496:	11 e0       	ldi	r17, 0x01	; 1
    1498:	6e 85       	ldd	r22, Y+14	; 0x0e
    149a:	7f 85       	ldd	r23, Y+15	; 0x0f
    149c:	88 89       	ldd	r24, Y+16	; 0x10
    149e:	99 89       	ldd	r25, Y+17	; 0x11
    14a0:	20 e0       	ldi	r18, 0x00	; 0
    14a2:	3f ef       	ldi	r19, 0xFF	; 255
    14a4:	4f e7       	ldi	r20, 0x7F	; 127
    14a6:	57 e4       	ldi	r21, 0x47	; 71
    14a8:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    14ac:	18 16       	cp	r1, r24
    14ae:	0c f0       	brlt	.+2      	; 0x14b2 <set_ampGain+0x19a>
    14b0:	10 e0       	ldi	r17, 0x00	; 0
    14b2:	11 23       	and	r17, r17
    14b4:	61 f1       	breq	.+88     	; 0x150e <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    14b6:	6a 85       	ldd	r22, Y+10	; 0x0a
    14b8:	7b 85       	ldd	r23, Y+11	; 0x0b
    14ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    14bc:	9d 85       	ldd	r25, Y+13	; 0x0d
    14be:	20 e0       	ldi	r18, 0x00	; 0
    14c0:	30 e0       	ldi	r19, 0x00	; 0
    14c2:	40 e2       	ldi	r20, 0x20	; 32
    14c4:	51 e4       	ldi	r21, 0x41	; 65
    14c6:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    14ca:	dc 01       	movw	r26, r24
    14cc:	cb 01       	movw	r24, r22
    14ce:	bc 01       	movw	r22, r24
    14d0:	cd 01       	movw	r24, r26
    14d2:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    14d6:	dc 01       	movw	r26, r24
    14d8:	cb 01       	movw	r24, r22
    14da:	8a 8b       	std	Y+18, r24	; 0x12
    14dc:	9b 8b       	std	Y+19, r25	; 0x13
    14de:	12 c0       	rjmp	.+36     	; 0x1504 <set_ampGain+0x1ec>
    14e0:	80 e2       	ldi	r24, 0x20	; 32
    14e2:	93 e0       	ldi	r25, 0x03	; 3
    14e4:	8c 8b       	std	Y+20, r24	; 0x14
    14e6:	9d 8b       	std	Y+21, r25	; 0x15
    14e8:	8c 89       	ldd	r24, Y+20	; 0x14
    14ea:	9d 89       	ldd	r25, Y+21	; 0x15
    14ec:	8c 01       	movw	r16, r24
    14ee:	c8 01       	movw	r24, r16
    14f0:	01 97       	sbiw	r24, 0x01	; 1
    14f2:	f1 f7       	brne	.-4      	; 0x14f0 <set_ampGain+0x1d8>
    14f4:	8c 01       	movw	r16, r24
    14f6:	0c 8b       	std	Y+20, r16	; 0x14
    14f8:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14fa:	8a 89       	ldd	r24, Y+18	; 0x12
    14fc:	9b 89       	ldd	r25, Y+19	; 0x13
    14fe:	01 97       	sbiw	r24, 0x01	; 1
    1500:	8a 8b       	std	Y+18, r24	; 0x12
    1502:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1504:	8a 89       	ldd	r24, Y+18	; 0x12
    1506:	9b 89       	ldd	r25, Y+19	; 0x13
    1508:	00 97       	sbiw	r24, 0x00	; 0
    150a:	51 f7       	brne	.-44     	; 0x14e0 <set_ampGain+0x1c8>
    150c:	28 c0       	rjmp	.+80     	; 0x155e <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    150e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1510:	7f 85       	ldd	r23, Y+15	; 0x0f
    1512:	88 89       	ldd	r24, Y+16	; 0x10
    1514:	99 89       	ldd	r25, Y+17	; 0x11
    1516:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    151a:	dc 01       	movw	r26, r24
    151c:	cb 01       	movw	r24, r22
    151e:	8a 8b       	std	Y+18, r24	; 0x12
    1520:	9b 8b       	std	Y+19, r25	; 0x13
    1522:	8a 89       	ldd	r24, Y+18	; 0x12
    1524:	9b 89       	ldd	r25, Y+19	; 0x13
    1526:	8e 8b       	std	Y+22, r24	; 0x16
    1528:	9f 8b       	std	Y+23, r25	; 0x17
    152a:	8e 89       	ldd	r24, Y+22	; 0x16
    152c:	9f 89       	ldd	r25, Y+23	; 0x17
    152e:	8c 01       	movw	r16, r24
    1530:	f8 01       	movw	r30, r16
    1532:	31 97       	sbiw	r30, 0x01	; 1
    1534:	f1 f7       	brne	.-4      	; 0x1532 <set_ampGain+0x21a>
    1536:	8f 01       	movw	r16, r30
    1538:	0e 8b       	std	Y+22, r16	; 0x16
    153a:	1f 8b       	std	Y+23, r17	; 0x17
    153c:	10 c0       	rjmp	.+32     	; 0x155e <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    153e:	6d 81       	ldd	r22, Y+5	; 0x05
    1540:	7e 81       	ldd	r23, Y+6	; 0x06
    1542:	8f 81       	ldd	r24, Y+7	; 0x07
    1544:	98 85       	ldd	r25, Y+8	; 0x08
    1546:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    154a:	dc 01       	movw	r26, r24
    154c:	cb 01       	movw	r24, r22
    154e:	89 87       	std	Y+9, r24	; 0x09
    1550:	89 85       	ldd	r24, Y+9	; 0x09
    1552:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1554:	88 8d       	ldd	r24, Y+24	; 0x18
    1556:	18 2f       	mov	r17, r24
    1558:	1a 95       	dec	r17
    155a:	f1 f7       	brne	.-4      	; 0x1558 <set_ampGain+0x240>
    155c:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    155e:	8f ef       	ldi	r24, 0xFF	; 255
    1560:	61 e0       	ldi	r22, 0x01	; 1
    1562:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    1566:	6a 96       	adiw	r28, 0x1a	; 26
    1568:	cd bf       	out	0x3d, r28	; 61
    156a:	de bf       	out	0x3e, r29	; 62
    156c:	df 91       	pop	r29
    156e:	cf 91       	pop	r28
    1570:	1f 91       	pop	r17
    1572:	0f 91       	pop	r16
    1574:	08 95       	ret

00001576 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    1576:	cf 93       	push	r28
    1578:	df 93       	push	r29
    157a:	00 d0       	rcall	.+0      	; 0x157c <set_filter+0x6>
    157c:	cd b7       	in	r28, 0x3d	; 61
    157e:	de b7       	in	r29, 0x3e	; 62
    1580:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    1582:	8b 81       	ldd	r24, Y+3	; 0x03
    1584:	83 70       	andi	r24, 0x03	; 3
    1586:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    1588:	8b 81       	ldd	r24, Y+3	; 0x03
    158a:	8c 70       	andi	r24, 0x0C	; 12
    158c:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    158e:	8b 81       	ldd	r24, Y+3	; 0x03
    1590:	88 2f       	mov	r24, r24
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	85 70       	andi	r24, 0x05	; 5
    1596:	90 70       	andi	r25, 0x00	; 0
    1598:	00 97       	sbiw	r24, 0x00	; 0
    159a:	51 f0       	breq	.+20     	; 0x15b0 <set_filter+0x3a>
    159c:	80 91 79 50 	lds	r24, 0x5079
    15a0:	98 2f       	mov	r25, r24
    15a2:	90 7f       	andi	r25, 0xF0	; 240
    15a4:	8b 81       	ldd	r24, Y+3	; 0x03
    15a6:	82 95       	swap	r24
    15a8:	8f 70       	andi	r24, 0x0F	; 15
    15aa:	89 2b       	or	r24, r25
    15ac:	80 93 79 50 	sts	0x5079, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    15b0:	8b 81       	ldd	r24, Y+3	; 0x03
    15b2:	88 2f       	mov	r24, r24
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	8a 70       	andi	r24, 0x0A	; 10
    15b8:	90 70       	andi	r25, 0x00	; 0
    15ba:	00 97       	sbiw	r24, 0x00	; 0
    15bc:	49 f0       	breq	.+18     	; 0x15d0 <set_filter+0x5a>
    15be:	8b 81       	ldd	r24, Y+3	; 0x03
    15c0:	98 2f       	mov	r25, r24
    15c2:	90 7f       	andi	r25, 0xF0	; 240
    15c4:	80 91 79 50 	lds	r24, 0x5079
    15c8:	8f 70       	andi	r24, 0x0F	; 15
    15ca:	89 2b       	or	r24, r25
    15cc:	80 93 79 50 	sts	0x5079, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    15d0:	84 e0       	ldi	r24, 0x04	; 4
    15d2:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    15d6:	80 91 79 50 	lds	r24, 0x5079
    15da:	80 93 5d 50 	sts	0x505D, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    15de:	89 81       	ldd	r24, Y+1	; 0x01
    15e0:	88 23       	and	r24, r24
    15e2:	19 f0       	breq	.+6      	; 0x15ea <set_filter+0x74>
    15e4:	81 e0       	ldi	r24, 0x01	; 1
    15e6:	0e 94 ae 3a 	call	0x755c	; 0x755c <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    15ea:	8a 81       	ldd	r24, Y+2	; 0x02
    15ec:	88 23       	and	r24, r24
    15ee:	19 f0       	breq	.+6      	; 0x15f6 <set_filter+0x80>
    15f0:	81 e0       	ldi	r24, 0x01	; 1
    15f2:	0e 94 c6 3a 	call	0x758c	; 0x758c <upperMuxCS>

	SPICS(TRUE);
    15f6:	81 e0       	ldi	r24, 0x01	; 1
    15f8:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    15fc:	80 ec       	ldi	r24, 0xC0	; 192
    15fe:	98 e0       	ldi	r25, 0x08	; 8
    1600:	2f ef       	ldi	r18, 0xFF	; 255
    1602:	fc 01       	movw	r30, r24
    1604:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1606:	00 00       	nop
    1608:	80 ec       	ldi	r24, 0xC0	; 192
    160a:	98 e0       	ldi	r25, 0x08	; 8
    160c:	fc 01       	movw	r30, r24
    160e:	82 81       	ldd	r24, Z+2	; 0x02
    1610:	88 23       	and	r24, r24
    1612:	d4 f7       	brge	.-12     	; 0x1608 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    1614:	80 ec       	ldi	r24, 0xC0	; 192
    1616:	98 e0       	ldi	r25, 0x08	; 8
    1618:	fc 01       	movw	r30, r24
    161a:	83 81       	ldd	r24, Z+3	; 0x03
    161c:	80 93 69 50 	sts	0x5069, r24

	nop();
    1620:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    1622:	80 ec       	ldi	r24, 0xC0	; 192
    1624:	98 e0       	ldi	r25, 0x08	; 8
    1626:	20 91 5d 50 	lds	r18, 0x505D
    162a:	fc 01       	movw	r30, r24
    162c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    162e:	00 00       	nop
    1630:	80 ec       	ldi	r24, 0xC0	; 192
    1632:	98 e0       	ldi	r25, 0x08	; 8
    1634:	fc 01       	movw	r30, r24
    1636:	82 81       	ldd	r24, Z+2	; 0x02
    1638:	88 23       	and	r24, r24
    163a:	d4 f7       	brge	.-12     	; 0x1630 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    163c:	80 ec       	ldi	r24, 0xC0	; 192
    163e:	98 e0       	ldi	r25, 0x08	; 8
    1640:	fc 01       	movw	r30, r24
    1642:	83 81       	ldd	r24, Z+3	; 0x03
    1644:	80 93 69 50 	sts	0x5069, r24
	SPICS(FALSE);
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    164e:	89 81       	ldd	r24, Y+1	; 0x01
    1650:	88 23       	and	r24, r24
    1652:	19 f0       	breq	.+6      	; 0x165a <set_filter+0xe4>
    1654:	80 e0       	ldi	r24, 0x00	; 0
    1656:	0e 94 ae 3a 	call	0x755c	; 0x755c <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    165a:	8a 81       	ldd	r24, Y+2	; 0x02
    165c:	88 23       	and	r24, r24
    165e:	19 f0       	breq	.+6      	; 0x1666 <set_filter+0xf0>
    1660:	80 e0       	ldi	r24, 0x00	; 0
    1662:	0e 94 c6 3a 	call	0x758c	; 0x758c <upperMuxCS>
	SPIDisable();
    1666:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
}
    166a:	23 96       	adiw	r28, 0x03	; 3
    166c:	cd bf       	out	0x3d, r28	; 61
    166e:	de bf       	out	0x3e, r29	; 62
    1670:	df 91       	pop	r29
    1672:	cf 91       	pop	r28
    1674:	08 95       	ret

00001676 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    1676:	cf 93       	push	r28
    1678:	df 93       	push	r29
    167a:	0f 92       	push	r0
    167c:	cd b7       	in	r28, 0x3d	; 61
    167e:	de b7       	in	r29, 0x3e	; 62
    1680:	89 83       	std	Y+1, r24	; 0x01
	
	if(on) {
    1682:	89 81       	ldd	r24, Y+1	; 0x01
    1684:	88 23       	and	r24, r24
    1686:	59 f0       	breq	.+22     	; 0x169e <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    1688:	80 e0       	ldi	r24, 0x00	; 0
    168a:	96 e0       	ldi	r25, 0x06	; 6
    168c:	20 e2       	ldi	r18, 0x20	; 32
    168e:	fc 01       	movw	r30, r24
    1690:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1692:	80 e0       	ldi	r24, 0x00	; 0
    1694:	96 e0       	ldi	r25, 0x06	; 6
    1696:	20 e2       	ldi	r18, 0x20	; 32
    1698:	fc 01       	movw	r30, r24
    169a:	25 83       	std	Z+5, r18	; 0x05
    169c:	0a c0       	rjmp	.+20     	; 0x16b2 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    169e:	80 e0       	ldi	r24, 0x00	; 0
    16a0:	96 e0       	ldi	r25, 0x06	; 6
    16a2:	20 e2       	ldi	r18, 0x20	; 32
    16a4:	fc 01       	movw	r30, r24
    16a6:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    16a8:	80 e0       	ldi	r24, 0x00	; 0
    16aa:	96 e0       	ldi	r25, 0x06	; 6
    16ac:	20 e2       	ldi	r18, 0x20	; 32
    16ae:	fc 01       	movw	r30, r24
    16b0:	22 83       	std	Z+2, r18	; 0x02
	}
}
    16b2:	0f 90       	pop	r0
    16b4:	df 91       	pop	r29
    16b6:	cf 91       	pop	r28
    16b8:	08 95       	ret

000016ba <CO_collectADC>:

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    16ba:	ef 92       	push	r14
    16bc:	ff 92       	push	r15
    16be:	0f 93       	push	r16
    16c0:	1f 93       	push	r17
    16c2:	cf 93       	push	r28
    16c4:	df 93       	push	r29
    16c6:	cd b7       	in	r28, 0x3d	; 61
    16c8:	de b7       	in	r29, 0x3e	; 62
    16ca:	28 97       	sbiw	r28, 0x08	; 8
    16cc:	cd bf       	out	0x3d, r28	; 61
    16ce:	de bf       	out	0x3e, r29	; 62
    16d0:	89 83       	std	Y+1, r24	; 0x01
    16d2:	6a 83       	std	Y+2, r22	; 0x02
    16d4:	4b 83       	std	Y+3, r20	; 0x03
    16d6:	5c 83       	std	Y+4, r21	; 0x04
    16d8:	2d 83       	std	Y+5, r18	; 0x05
    16da:	3e 83       	std	Y+6, r19	; 0x06
    16dc:	0f 83       	std	Y+7, r16	; 0x07
    16de:	18 87       	std	Y+8, r17	; 0x08
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    16e0:	2b 81       	ldd	r18, Y+3	; 0x03
    16e2:	3c 81       	ldd	r19, Y+4	; 0x04
    16e4:	ad 81       	ldd	r26, Y+5	; 0x05
    16e6:	be 81       	ldd	r27, Y+6	; 0x06
    16e8:	ef 81       	ldd	r30, Y+7	; 0x07
    16ea:	f8 85       	ldd	r31, Y+8	; 0x08
    16ec:	89 81       	ldd	r24, Y+1	; 0x01
    16ee:	61 ec       	ldi	r22, 0xC1	; 193
    16f0:	4a 81       	ldd	r20, Y+2	; 0x02
    16f2:	8d 01       	movw	r16, r26
    16f4:	7f 01       	movw	r14, r30
    16f6:	0e 94 87 0b 	call	0x170e	; 0x170e <CO_collectADC_ext>
}
    16fa:	28 96       	adiw	r28, 0x08	; 8
    16fc:	cd bf       	out	0x3d, r28	; 61
    16fe:	de bf       	out	0x3e, r29	; 62
    1700:	df 91       	pop	r29
    1702:	cf 91       	pop	r28
    1704:	1f 91       	pop	r17
    1706:	0f 91       	pop	r16
    1708:	ff 90       	pop	r15
    170a:	ef 90       	pop	r14
    170c:	08 95       	ret

0000170e <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    170e:	ef 92       	push	r14
    1710:	ff 92       	push	r15
    1712:	0f 93       	push	r16
    1714:	1f 93       	push	r17
    1716:	cf 93       	push	r28
    1718:	df 93       	push	r29
    171a:	cd b7       	in	r28, 0x3d	; 61
    171c:	de b7       	in	r29, 0x3e	; 62
    171e:	2b 97       	sbiw	r28, 0x0b	; 11
    1720:	cd bf       	out	0x3d, r28	; 61
    1722:	de bf       	out	0x3e, r29	; 62
    1724:	8b 83       	std	Y+3, r24	; 0x03
    1726:	6c 83       	std	Y+4, r22	; 0x04
    1728:	4d 83       	std	Y+5, r20	; 0x05
    172a:	2e 83       	std	Y+6, r18	; 0x06
    172c:	3f 83       	std	Y+7, r19	; 0x07
    172e:	08 87       	std	Y+8, r16	; 0x08
    1730:	19 87       	std	Y+9, r17	; 0x09
    1732:	ea 86       	std	Y+10, r14	; 0x0a
    1734:	fb 86       	std	Y+11, r15	; 0x0b
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif

	uint16_t period;
	ADC_BUFFER = DataArray;
    1736:	8a 85       	ldd	r24, Y+10	; 0x0a
    1738:	9b 85       	ldd	r25, Y+11	; 0x0b
    173a:	80 93 6a 50 	sts	0x506A, r24
    173e:	90 93 6b 50 	sts	0x506B, r25
	ADC_Sampling_Finished = 0;
    1742:	10 92 c5 50 	sts	0x50C5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1746:	81 e0       	ldi	r24, 0x01	; 1
    1748:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    174c:	8b 81       	ldd	r24, Y+3	; 0x03
    174e:	6d 81       	ldd	r22, Y+5	; 0x05
    1750:	0e 94 8c 09 	call	0x1318	; 0x1318 <set_ampGain>
	set_filter(filterConfig);
    1754:	8c 81       	ldd	r24, Y+4	; 0x04
    1756:	0e 94 bb 0a 	call	0x1576	; 0x1576 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    175a:	8b 81       	ldd	r24, Y+3	; 0x03
    175c:	85 30       	cpi	r24, 0x05	; 5
    175e:	31 f0       	breq	.+12     	; 0x176c <CO_collectADC_ext+0x5e>
    1760:	8b 81       	ldd	r24, Y+3	; 0x03
    1762:	86 30       	cpi	r24, 0x06	; 6
    1764:	19 f0       	breq	.+6      	; 0x176c <CO_collectADC_ext+0x5e>
    1766:	8b 81       	ldd	r24, Y+3	; 0x03
    1768:	87 30       	cpi	r24, 0x07	; 7
    176a:	19 f4       	brne	.+6      	; 0x1772 <CO_collectADC_ext+0x64>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	0e 94 3b 0b 	call	0x1676	; 0x1676 <enableADCMUX>
	setADCInput(channel);
    1778:	8b 81       	ldd	r24, Y+3	; 0x03
    177a:	0e 94 7a 1e 	call	0x3cf4	; 0x3cf4 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    177e:	84 e0       	ldi	r24, 0x04	; 4
    1780:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1784:	80 ec       	ldi	r24, 0xC0	; 192
    1786:	98 e0       	ldi	r25, 0x08	; 8
    1788:	24 e5       	ldi	r18, 0x54	; 84
    178a:	fc 01       	movw	r30, r24
    178c:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    178e:	80 ea       	ldi	r24, 0xA0	; 160
    1790:	96 e0       	ldi	r25, 0x06	; 6
    1792:	21 e0       	ldi	r18, 0x01	; 1
    1794:	fc 01       	movw	r30, r24
    1796:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1798:	80 ea       	ldi	r24, 0xA0	; 160
    179a:	96 e0       	ldi	r25, 0x06	; 6
    179c:	22 e0       	ldi	r18, 0x02	; 2
    179e:	fc 01       	movw	r30, r24
    17a0:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    17a2:	80 ea       	ldi	r24, 0xA0	; 160
    17a4:	96 e0       	ldi	r25, 0x06	; 6
    17a6:	21 e0       	ldi	r18, 0x01	; 1
    17a8:	fc 01       	movw	r30, r24
    17aa:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    17ac:	80 ea       	ldi	r24, 0xA0	; 160
    17ae:	96 e0       	ldi	r25, 0x06	; 6
    17b0:	22 e0       	ldi	r18, 0x02	; 2
    17b2:	fc 01       	movw	r30, r24
    17b4:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    17b6:	80 e8       	ldi	r24, 0x80	; 128
    17b8:	96 e0       	ldi	r25, 0x06	; 6
    17ba:	20 e2       	ldi	r18, 0x20	; 32
    17bc:	fc 01       	movw	r30, r24
    17be:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    17c0:	80 e4       	ldi	r24, 0x40	; 64
    17c2:	9a e0       	ldi	r25, 0x0A	; 10
    17c4:	23 e2       	ldi	r18, 0x23	; 35
    17c6:	fc 01       	movw	r30, r24
    17c8:	21 83       	std	Z+1, r18	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    17ca:	8e 81       	ldd	r24, Y+6	; 0x06
    17cc:	9f 81       	ldd	r25, Y+7	; 0x07
    17ce:	9c 01       	movw	r18, r24
    17d0:	40 e0       	ldi	r20, 0x00	; 0
    17d2:	50 e0       	ldi	r21, 0x00	; 0
    17d4:	80 e8       	ldi	r24, 0x80	; 128
    17d6:	94 e8       	ldi	r25, 0x84	; 132
    17d8:	ae e1       	ldi	r26, 0x1E	; 30
    17da:	b0 e0       	ldi	r27, 0x00	; 0
    17dc:	bc 01       	movw	r22, r24
    17de:	cd 01       	movw	r24, r26
    17e0:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    17e4:	da 01       	movw	r26, r20
    17e6:	c9 01       	movw	r24, r18
    17e8:	89 83       	std	Y+1, r24	; 0x01
    17ea:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    17ec:	80 e4       	ldi	r24, 0x40	; 64
    17ee:	9a e0       	ldi	r25, 0x0A	; 10
    17f0:	29 81       	ldd	r18, Y+1	; 0x01
    17f2:	3a 81       	ldd	r19, Y+2	; 0x02
    17f4:	fc 01       	movw	r30, r24
    17f6:	26 a3       	lds	r18, 0x56
    17f8:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    17fa:	80 e4       	ldi	r24, 0x40	; 64
    17fc:	9a e0       	ldi	r25, 0x0A	; 10
    17fe:	29 81       	ldd	r18, Y+1	; 0x01
    1800:	3a 81       	ldd	r19, Y+2	; 0x02
    1802:	36 95       	lsr	r19
    1804:	27 95       	ror	r18
    1806:	fc 01       	movw	r30, r24
    1808:	22 af       	sts	0x72, r18
    180a:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    180c:	80 e4       	ldi	r24, 0x40	; 64
    180e:	98 e0       	ldi	r25, 0x08	; 8
    1810:	28 85       	ldd	r18, Y+8	; 0x08
    1812:	39 85       	ldd	r19, Y+9	; 0x09
    1814:	fc 01       	movw	r30, r24
    1816:	26 a3       	lds	r18, 0x56
    1818:	37 a3       	lds	r19, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    181a:	80 e8       	ldi	r24, 0x80	; 128
    181c:	91 e0       	ldi	r25, 0x01	; 1
    181e:	28 e7       	ldi	r18, 0x78	; 120
    1820:	fc 01       	movw	r30, r24
    1822:	21 83       	std	Z+1, r18	; 0x01
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    1824:	80 e4       	ldi	r24, 0x40	; 64
    1826:	98 e0       	ldi	r25, 0x08	; 8
    1828:	21 e0       	ldi	r18, 0x01	; 1
    182a:	fc 01       	movw	r30, r24
    182c:	26 83       	std	Z+6, r18	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    182e:	80 e4       	ldi	r24, 0x40	; 64
    1830:	9a e0       	ldi	r25, 0x0A	; 10
    1832:	20 e4       	ldi	r18, 0x40	; 64
    1834:	3a e0       	ldi	r19, 0x0A	; 10
    1836:	f9 01       	movw	r30, r18
    1838:	20 81       	ld	r18, Z
    183a:	20 7f       	andi	r18, 0xF0	; 240
    183c:	21 60       	ori	r18, 0x01	; 1
    183e:	fc 01       	movw	r30, r24
    1840:	20 83       	st	Z, r18
	
	sampleCount = 0;
    1842:	10 92 6c 50 	sts	0x506C, r1
    1846:	10 92 6d 50 	sts	0x506D, r1
    184a:	10 92 6e 50 	sts	0x506E, r1
    184e:	10 92 6f 50 	sts	0x506F, r1
	discardCount = 0;
    1852:	10 92 55 40 	sts	0x4055, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    1856:	80 ea       	ldi	r24, 0xA0	; 160
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	20 ea       	ldi	r18, 0xA0	; 160
    185c:	30 e0       	ldi	r19, 0x00	; 0
    185e:	f9 01       	movw	r30, r18
    1860:	22 81       	ldd	r18, Z+2	; 0x02
    1862:	23 60       	ori	r18, 0x03	; 3
    1864:	fc 01       	movw	r30, r24
    1866:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1868:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    186a:	2b 96       	adiw	r28, 0x0b	; 11
    186c:	cd bf       	out	0x3d, r28	; 61
    186e:	de bf       	out	0x3e, r29	; 62
    1870:	df 91       	pop	r29
    1872:	cf 91       	pop	r28
    1874:	1f 91       	pop	r17
    1876:	0f 91       	pop	r16
    1878:	ff 90       	pop	r15
    187a:	ef 90       	pop	r14
    187c:	08 95       	ret

0000187e <__vector_20>:

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    187e:	1f 92       	push	r1
    1880:	0f 92       	push	r0
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	0f 92       	push	r0
    1886:	00 90 3b 00 	lds	r0, 0x003B
    188a:	0f 92       	push	r0
    188c:	11 24       	eor	r1, r1
    188e:	2f 93       	push	r18
    1890:	3f 93       	push	r19
    1892:	4f 93       	push	r20
    1894:	5f 93       	push	r21
    1896:	6f 93       	push	r22
    1898:	7f 93       	push	r23
    189a:	8f 93       	push	r24
    189c:	9f 93       	push	r25
    189e:	af 93       	push	r26
    18a0:	bf 93       	push	r27
    18a2:	ef 93       	push	r30
    18a4:	ff 93       	push	r31
    18a6:	cf 93       	push	r28
    18a8:	df 93       	push	r29
    18aa:	cd b7       	in	r28, 0x3d	; 61
    18ac:	de b7       	in	r29, 0x3e	; 62

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    18ae:	80 e4       	ldi	r24, 0x40	; 64
    18b0:	9a e0       	ldi	r25, 0x0A	; 10
    18b2:	20 e4       	ldi	r18, 0x40	; 64
    18b4:	3a e0       	ldi	r19, 0x0A	; 10
    18b6:	f9 01       	movw	r30, r18
    18b8:	20 81       	ld	r18, Z
    18ba:	20 7f       	andi	r18, 0xF0	; 240
    18bc:	fc 01       	movw	r30, r24
    18be:	20 83       	st	Z, r18
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    18c0:	80 e0       	ldi	r24, 0x00	; 0
    18c2:	98 e0       	ldi	r25, 0x08	; 8
    18c4:	20 e0       	ldi	r18, 0x00	; 0
    18c6:	38 e0       	ldi	r19, 0x08	; 8
    18c8:	f9 01       	movw	r30, r18
    18ca:	20 81       	ld	r18, Z
    18cc:	20 7f       	andi	r18, 0xF0	; 240
    18ce:	fc 01       	movw	r30, r24
    18d0:	20 83       	st	Z, r18
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	99 e0       	ldi	r25, 0x09	; 9
    18d6:	20 e0       	ldi	r18, 0x00	; 0
    18d8:	39 e0       	ldi	r19, 0x09	; 9
    18da:	f9 01       	movw	r30, r18
    18dc:	20 81       	ld	r18, Z
    18de:	20 7f       	andi	r18, 0xF0	; 240
    18e0:	fc 01       	movw	r30, r24
    18e2:	20 83       	st	Z, r18
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    18e4:	80 e4       	ldi	r24, 0x40	; 64
    18e6:	98 e0       	ldi	r25, 0x08	; 8
    18e8:	20 e4       	ldi	r18, 0x40	; 64
    18ea:	3a e0       	ldi	r19, 0x0A	; 10
    18ec:	f9 01       	movw	r30, r18
    18ee:	20 81       	ld	r18, Z
    18f0:	20 7f       	andi	r18, 0xF0	; 240
    18f2:	fc 01       	movw	r30, r24
    18f4:	20 83       	st	Z, r18

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    18f6:	80 e0       	ldi	r24, 0x00	; 0
    18f8:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    18fc:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	enableADCMUX(FALSE);
    1900:	80 e0       	ldi	r24, 0x00	; 0
    1902:	0e 94 3b 0b 	call	0x1676	; 0x1676 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    1906:	81 e0       	ldi	r24, 0x01	; 1
    1908:	80 93 c5 50 	sts	0x50C5, r24
	DataAvailable = 1;
    190c:	81 e0       	ldi	r24, 0x01	; 1
    190e:	80 93 cd 21 	sts	0x21CD, r24
}
    1912:	df 91       	pop	r29
    1914:	cf 91       	pop	r28
    1916:	ff 91       	pop	r31
    1918:	ef 91       	pop	r30
    191a:	bf 91       	pop	r27
    191c:	af 91       	pop	r26
    191e:	9f 91       	pop	r25
    1920:	8f 91       	pop	r24
    1922:	7f 91       	pop	r23
    1924:	6f 91       	pop	r22
    1926:	5f 91       	pop	r21
    1928:	4f 91       	pop	r20
    192a:	3f 91       	pop	r19
    192c:	2f 91       	pop	r18
    192e:	0f 90       	pop	r0
    1930:	00 92 3b 00 	sts	0x003B, r0
    1934:	0f 90       	pop	r0
    1936:	0f be       	out	0x3f, r0	; 63
    1938:	0f 90       	pop	r0
    193a:	1f 90       	pop	r1
    193c:	18 95       	reti

0000193e <ADC_Stop_Sampling>:
// sei();
// }

//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
    193e:	cf 93       	push	r28
    1940:	df 93       	push	r29
    1942:	cd b7       	in	r28, 0x3d	; 61
    1944:	de b7       	in	r29, 0x3e	; 62
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1946:	80 e4       	ldi	r24, 0x40	; 64
    1948:	9a e0       	ldi	r25, 0x0A	; 10
    194a:	20 e4       	ldi	r18, 0x40	; 64
    194c:	3a e0       	ldi	r19, 0x0A	; 10
    194e:	f9 01       	movw	r30, r18
    1950:	20 81       	ld	r18, Z
    1952:	20 7f       	andi	r18, 0xF0	; 240
    1954:	fc 01       	movw	r30, r24
    1956:	20 83       	st	Z, r18
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1958:	80 e0       	ldi	r24, 0x00	; 0
    195a:	98 e0       	ldi	r25, 0x08	; 8
    195c:	20 e0       	ldi	r18, 0x00	; 0
    195e:	38 e0       	ldi	r19, 0x08	; 8
    1960:	f9 01       	movw	r30, r18
    1962:	20 81       	ld	r18, Z
    1964:	20 7f       	andi	r18, 0xF0	; 240
    1966:	fc 01       	movw	r30, r24
    1968:	20 83       	st	Z, r18
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	99 e0       	ldi	r25, 0x09	; 9
    196e:	20 e0       	ldi	r18, 0x00	; 0
    1970:	39 e0       	ldi	r19, 0x09	; 9
    1972:	f9 01       	movw	r30, r18
    1974:	20 81       	ld	r18, Z
    1976:	20 7f       	andi	r18, 0xF0	; 240
    1978:	fc 01       	movw	r30, r24
    197a:	20 83       	st	Z, r18
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    197c:	80 e4       	ldi	r24, 0x40	; 64
    197e:	98 e0       	ldi	r25, 0x08	; 8
    1980:	20 e4       	ldi	r18, 0x40	; 64
    1982:	3a e0       	ldi	r19, 0x0A	; 10
    1984:	f9 01       	movw	r30, r18
    1986:	20 81       	ld	r18, Z
    1988:	20 7f       	andi	r18, 0xF0	; 240
    198a:	fc 01       	movw	r30, r24
    198c:	20 83       	st	Z, r18

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    198e:	80 e0       	ldi	r24, 0x00	; 0
    1990:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    1994:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	enableADCMUX(FALSE);
    1998:	80 e0       	ldi	r24, 0x00	; 0
    199a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	80 93 c5 50 	sts	0x50C5, r24
	DataAvailable = 1;
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	80 93 cd 21 	sts	0x21CD, r24
}
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	08 95       	ret

000019b0 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    19b0:	cf 93       	push	r28
    19b2:	df 93       	push	r29
    19b4:	0f 92       	push	r0
    19b6:	0f 92       	push	r0
    19b8:	cd b7       	in	r28, 0x3d	; 61
    19ba:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    19bc:	80 91 c5 50 	lds	r24, 0x50C5
    19c0:	88 23       	and	r24, r24
    19c2:	a9 f0       	breq	.+42     	; 0x19ee <ADC_Get_Num_Samples+0x3e>
		volatile uint16_t count;
		count = TCC1.CNT;
    19c4:	80 e4       	ldi	r24, 0x40	; 64
    19c6:	98 e0       	ldi	r25, 0x08	; 8
    19c8:	fc 01       	movw	r30, r24
    19ca:	80 a1       	lds	r24, 0x40
    19cc:	91 a1       	lds	r25, 0x41
    19ce:	89 83       	std	Y+1, r24	; 0x01
    19d0:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    19d2:	89 81       	ldd	r24, Y+1	; 0x01
    19d4:	9a 81       	ldd	r25, Y+2	; 0x02
    19d6:	00 97       	sbiw	r24, 0x00	; 0
    19d8:	39 f4       	brne	.+14     	; 0x19e8 <ADC_Get_Num_Samples+0x38>
    19da:	80 e4       	ldi	r24, 0x40	; 64
    19dc:	98 e0       	ldi	r25, 0x08	; 8
    19de:	fc 01       	movw	r30, r24
    19e0:	86 a1       	lds	r24, 0x46
    19e2:	97 a1       	lds	r25, 0x47
    19e4:	89 83       	std	Y+1, r24	; 0x01
    19e6:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    19e8:	89 81       	ldd	r24, Y+1	; 0x01
    19ea:	9a 81       	ldd	r25, Y+2	; 0x02
    19ec:	02 c0       	rjmp	.+4      	; 0x19f2 <ADC_Get_Num_Samples+0x42>
	}
	else return 0;		
    19ee:	80 e0       	ldi	r24, 0x00	; 0
    19f0:	90 e0       	ldi	r25, 0x00	; 0
}
    19f2:	0f 90       	pop	r0
    19f4:	0f 90       	pop	r0
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	08 95       	ret

000019fc <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
    19fc:	cf 93       	push	r28
    19fe:	df 93       	push	r29
    1a00:	cd b7       	in	r28, 0x3d	; 61
    1a02:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1a04:	80 ea       	ldi	r24, 0xA0	; 160
    1a06:	96 e0       	ldi	r25, 0x06	; 6
    1a08:	fc 01       	movw	r30, r24
    1a0a:	13 86       	std	Z+11, r1	; 0x0b
}
    1a0c:	df 91       	pop	r29
    1a0e:	cf 91       	pop	r28
    1a10:	08 95       	ret

00001a12 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    1a12:	cf 93       	push	r28
    1a14:	df 93       	push	r29
    1a16:	cd b7       	in	r28, 0x3d	; 61
    1a18:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1a1a:	80 ea       	ldi	r24, 0xA0	; 160
    1a1c:	96 e0       	ldi	r25, 0x06	; 6
    1a1e:	21 e0       	ldi	r18, 0x01	; 1
    1a20:	fc 01       	movw	r30, r24
    1a22:	23 87       	std	Z+11, r18	; 0x0b
}	
    1a24:	df 91       	pop	r29
    1a26:	cf 91       	pop	r28
    1a28:	08 95       	ret

00001a2a <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    1a2a:	1f 92       	push	r1
    1a2c:	0f 92       	push	r0
    1a2e:	0f b6       	in	r0, 0x3f	; 63
    1a30:	0f 92       	push	r0
    1a32:	00 90 3b 00 	lds	r0, 0x003B
    1a36:	0f 92       	push	r0
    1a38:	11 24       	eor	r1, r1
    1a3a:	2f 92       	push	r2
    1a3c:	3f 92       	push	r3
    1a3e:	4f 92       	push	r4
    1a40:	5f 92       	push	r5
    1a42:	6f 92       	push	r6
    1a44:	7f 92       	push	r7
    1a46:	8f 92       	push	r8
    1a48:	9f 92       	push	r9
    1a4a:	af 92       	push	r10
    1a4c:	bf 92       	push	r11
    1a4e:	cf 92       	push	r12
    1a50:	df 92       	push	r13
    1a52:	ef 92       	push	r14
    1a54:	ff 92       	push	r15
    1a56:	0f 93       	push	r16
    1a58:	1f 93       	push	r17
    1a5a:	2f 93       	push	r18
    1a5c:	3f 93       	push	r19
    1a5e:	4f 93       	push	r20
    1a60:	5f 93       	push	r21
    1a62:	6f 93       	push	r22
    1a64:	7f 93       	push	r23
    1a66:	8f 93       	push	r24
    1a68:	9f 93       	push	r25
    1a6a:	af 93       	push	r26
    1a6c:	bf 93       	push	r27
    1a6e:	ef 93       	push	r30
    1a70:	ff 93       	push	r31
    1a72:	cf 93       	push	r28
    1a74:	df 93       	push	r29
    1a76:	cd b7       	in	r28, 0x3d	; 61
    1a78:	de b7       	in	r29, 0x3e	; 62
    1a7a:	2f 97       	sbiw	r28, 0x0f	; 15
    1a7c:	cd bf       	out	0x3d, r28	; 61
    1a7e:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    1a80:	80 91 55 40 	lds	r24, 0x4055
    1a84:	88 23       	and	r24, r24
    1a86:	ac f0       	brlt	.+42     	; 0x1ab2 <__vector_104+0x88>
		discardCount++;
    1a88:	80 91 55 40 	lds	r24, 0x4055
    1a8c:	8f 5f       	subi	r24, 0xFF	; 255
    1a8e:	80 93 55 40 	sts	0x4055, r24
		if(discardCount == ADC_DISCARD){
    1a92:	80 91 55 40 	lds	r24, 0x4055
    1a96:	80 38       	cpi	r24, 0x80	; 128
    1a98:	09 f0       	breq	.+2      	; 0x1a9c <__vector_104+0x72>
    1a9a:	45 c1       	rjmp	.+650    	; 0x1d26 <__vector_104+0x2fc>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1a9c:	80 e4       	ldi	r24, 0x40	; 64
    1a9e:	98 e0       	ldi	r25, 0x08	; 8
    1aa0:	20 e4       	ldi	r18, 0x40	; 64
    1aa2:	38 e0       	ldi	r19, 0x08	; 8
    1aa4:	f9 01       	movw	r30, r18
    1aa6:	20 81       	ld	r18, Z
    1aa8:	20 7f       	andi	r18, 0xF0	; 240
    1aaa:	29 60       	ori	r18, 0x09	; 9
    1aac:	fc 01       	movw	r30, r24
    1aae:	20 83       	st	Z, r18
    1ab0:	3a c1       	rjmp	.+628    	; 0x1d26 <__vector_104+0x2fc>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1ab8:	80 ea       	ldi	r24, 0xA0	; 160
    1aba:	96 e0       	ldi	r25, 0x06	; 6
    1abc:	22 e0       	ldi	r18, 0x02	; 2
    1abe:	fc 01       	movw	r30, r24
    1ac0:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1ac2:	19 82       	std	Y+1, r1	; 0x01
    1ac4:	1a c0       	rjmp	.+52     	; 0x1afa <__vector_104+0xd0>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1ac6:	80 ec       	ldi	r24, 0xC0	; 192
    1ac8:	98 e0       	ldi	r25, 0x08	; 8
    1aca:	2a ea       	ldi	r18, 0xAA	; 170
    1acc:	fc 01       	movw	r30, r24
    1ace:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1ad0:	00 00       	nop
    1ad2:	80 ec       	ldi	r24, 0xC0	; 192
    1ad4:	98 e0       	ldi	r25, 0x08	; 8
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	82 81       	ldd	r24, Z+2	; 0x02
    1ada:	88 23       	and	r24, r24
    1adc:	d4 f7       	brge	.-12     	; 0x1ad2 <__vector_104+0xa8>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1ade:	89 81       	ldd	r24, Y+1	; 0x01
    1ae0:	88 2f       	mov	r24, r24
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
    1ae4:	20 ec       	ldi	r18, 0xC0	; 192
    1ae6:	38 e0       	ldi	r19, 0x08	; 8
    1ae8:	f9 01       	movw	r30, r18
    1aea:	23 81       	ldd	r18, Z+3	; 0x03
    1aec:	83 5a       	subi	r24, 0xA3	; 163
    1aee:	9f 4a       	sbci	r25, 0xAF	; 175
    1af0:	fc 01       	movw	r30, r24
    1af2:	20 83       	st	Z, r18
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	8f 5f       	subi	r24, 0xFF	; 255
    1af8:	89 83       	std	Y+1, r24	; 0x01
    1afa:	89 81       	ldd	r24, Y+1	; 0x01
    1afc:	83 30       	cpi	r24, 0x03	; 3
    1afe:	18 f3       	brcs	.-58     	; 0x1ac6 <__vector_104+0x9c>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1b00:	80 ea       	ldi	r24, 0xA0	; 160
    1b02:	96 e0       	ldi	r25, 0x06	; 6
    1b04:	22 e0       	ldi	r18, 0x02	; 2
    1b06:	fc 01       	movw	r30, r24
    1b08:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1b10:	80 91 5d 50 	lds	r24, 0x505D
    1b14:	88 23       	and	r24, r24
    1b16:	3c f4       	brge	.+14     	; 0x1b26 <__vector_104+0xfc>
    1b18:	ce 01       	movw	r24, r28
    1b1a:	02 96       	adiw	r24, 0x02	; 2
    1b1c:	03 96       	adiw	r24, 0x03	; 3
    1b1e:	2f ef       	ldi	r18, 0xFF	; 255
    1b20:	fc 01       	movw	r30, r24
    1b22:	20 83       	st	Z, r18
    1b24:	05 c0       	rjmp	.+10     	; 0x1b30 <__vector_104+0x106>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1b26:	ce 01       	movw	r24, r28
    1b28:	02 96       	adiw	r24, 0x02	; 2
    1b2a:	03 96       	adiw	r24, 0x03	; 3
    1b2c:	fc 01       	movw	r30, r24
    1b2e:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    1b30:	ce 01       	movw	r24, r28
    1b32:	02 96       	adiw	r24, 0x02	; 2
    1b34:	02 96       	adiw	r24, 0x02	; 2
    1b36:	20 91 5d 50 	lds	r18, 0x505D
    1b3a:	fc 01       	movw	r30, r24
    1b3c:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1b3e:	ce 01       	movw	r24, r28
    1b40:	02 96       	adiw	r24, 0x02	; 2
    1b42:	01 96       	adiw	r24, 0x01	; 1
    1b44:	20 91 5e 50 	lds	r18, 0x505E
    1b48:	fc 01       	movw	r30, r24
    1b4a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    1b4c:	ce 01       	movw	r24, r28
    1b4e:	02 96       	adiw	r24, 0x02	; 2
    1b50:	20 91 5f 50 	lds	r18, 0x505F
    1b54:	fc 01       	movw	r30, r24
    1b56:	20 83       	st	Z, r18
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1b58:	8a 81       	ldd	r24, Y+2	; 0x02
    1b5a:	9b 81       	ldd	r25, Y+3	; 0x03
    1b5c:	ac 81       	ldd	r26, Y+4	; 0x04
    1b5e:	bd 81       	ldd	r27, Y+5	; 0x05
    1b60:	5c 01       	movw	r10, r24
    1b62:	6d 01       	movw	r12, r26
    1b64:	bb 0f       	add	r27, r27
    1b66:	88 0b       	sbc	r24, r24
    1b68:	98 2f       	mov	r25, r24
    1b6a:	dc 01       	movw	r26, r24
    1b6c:	e8 2e       	mov	r14, r24
    1b6e:	f8 2e       	mov	r15, r24
    1b70:	08 2f       	mov	r16, r24
    1b72:	18 2f       	mov	r17, r24
    1b74:	ae 82       	std	Y+6, r10	; 0x06
    1b76:	bf 82       	std	Y+7, r11	; 0x07
    1b78:	c8 86       	std	Y+8, r12	; 0x08
    1b7a:	d9 86       	std	Y+9, r13	; 0x09
    1b7c:	ea 86       	std	Y+10, r14	; 0x0a
    1b7e:	fb 86       	std	Y+11, r15	; 0x0b
    1b80:	0c 87       	std	Y+12, r16	; 0x0c
    1b82:	1d 87       	std	Y+13, r17	; 0x0d
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1b84:	20 91 6a 50 	lds	r18, 0x506A
    1b88:	30 91 6b 50 	lds	r19, 0x506B
    1b8c:	80 91 6c 50 	lds	r24, 0x506C
    1b90:	90 91 6d 50 	lds	r25, 0x506D
    1b94:	a0 91 6e 50 	lds	r26, 0x506E
    1b98:	b0 91 6f 50 	lds	r27, 0x506F
    1b9c:	88 0f       	add	r24, r24
    1b9e:	99 1f       	adc	r25, r25
    1ba0:	88 0f       	add	r24, r24
    1ba2:	99 1f       	adc	r25, r25
    1ba4:	a9 01       	movw	r20, r18
    1ba6:	48 0f       	add	r20, r24
    1ba8:	59 1f       	adc	r21, r25
    1baa:	4e 87       	std	Y+14, r20	; 0x0e
    1bac:	5f 87       	std	Y+15, r21	; 0x0f
    1bae:	ae 80       	ldd	r10, Y+6	; 0x06
    1bb0:	bf 80       	ldd	r11, Y+7	; 0x07
    1bb2:	c8 84       	ldd	r12, Y+8	; 0x08
    1bb4:	d9 84       	ldd	r13, Y+9	; 0x09
    1bb6:	ea 84       	ldd	r14, Y+10	; 0x0a
    1bb8:	fb 84       	ldd	r15, Y+11	; 0x0b
    1bba:	0c 85       	ldd	r16, Y+12	; 0x0c
    1bbc:	1d 85       	ldd	r17, Y+13	; 0x0d
    1bbe:	2a 2d       	mov	r18, r10
    1bc0:	3b 2d       	mov	r19, r11
    1bc2:	4c 2d       	mov	r20, r12
    1bc4:	5d 2d       	mov	r21, r13
    1bc6:	6e 2d       	mov	r22, r14
    1bc8:	7f 2d       	mov	r23, r15
    1bca:	80 2f       	mov	r24, r16
    1bcc:	91 2f       	mov	r25, r17
    1bce:	0f 2e       	mov	r0, r31
    1bd0:	f0 ea       	ldi	r31, 0xA0	; 160
    1bd2:	af 2e       	mov	r10, r31
    1bd4:	f0 2d       	mov	r31, r0
    1bd6:	0f 2e       	mov	r0, r31
    1bd8:	f5 e2       	ldi	r31, 0x25	; 37
    1bda:	bf 2e       	mov	r11, r31
    1bdc:	f0 2d       	mov	r31, r0
    1bde:	0f 2e       	mov	r0, r31
    1be0:	f6 e2       	ldi	r31, 0x26	; 38
    1be2:	cf 2e       	mov	r12, r31
    1be4:	f0 2d       	mov	r31, r0
    1be6:	dd 24       	eor	r13, r13
    1be8:	ee 24       	eor	r14, r14
    1bea:	ff 24       	eor	r15, r15
    1bec:	00 e0       	ldi	r16, 0x00	; 0
    1bee:	10 e0       	ldi	r17, 0x00	; 0
    1bf0:	0e 94 cc 54 	call	0xa998	; 0xa998 <__muldi3>
    1bf4:	22 2e       	mov	r2, r18
    1bf6:	33 2e       	mov	r3, r19
    1bf8:	44 2e       	mov	r4, r20
    1bfa:	55 2e       	mov	r5, r21
    1bfc:	66 2e       	mov	r6, r22
    1bfe:	77 2e       	mov	r7, r23
    1c00:	88 2e       	mov	r8, r24
    1c02:	99 2e       	mov	r9, r25
    1c04:	a2 2c       	mov	r10, r2
    1c06:	b3 2c       	mov	r11, r3
    1c08:	c4 2c       	mov	r12, r4
    1c0a:	d5 2c       	mov	r13, r5
    1c0c:	e6 2c       	mov	r14, r6
    1c0e:	f7 2c       	mov	r15, r7
    1c10:	08 2d       	mov	r16, r8
    1c12:	19 2d       	mov	r17, r9
    1c14:	2a 2d       	mov	r18, r10
    1c16:	3b 2d       	mov	r19, r11
    1c18:	4c 2d       	mov	r20, r12
    1c1a:	5d 2d       	mov	r21, r13
    1c1c:	6e 2d       	mov	r22, r14
    1c1e:	7f 2d       	mov	r23, r15
    1c20:	80 2f       	mov	r24, r16
    1c22:	91 2f       	mov	r25, r17
    1c24:	aa 24       	eor	r10, r10
    1c26:	aa 94       	dec	r10
    1c28:	bb 24       	eor	r11, r11
    1c2a:	ba 94       	dec	r11
    1c2c:	0f 2e       	mov	r0, r31
    1c2e:	ff e7       	ldi	r31, 0x7F	; 127
    1c30:	cf 2e       	mov	r12, r31
    1c32:	f0 2d       	mov	r31, r0
    1c34:	dd 24       	eor	r13, r13
    1c36:	ee 24       	eor	r14, r14
    1c38:	ff 24       	eor	r15, r15
    1c3a:	00 e0       	ldi	r16, 0x00	; 0
    1c3c:	10 e0       	ldi	r17, 0x00	; 0
    1c3e:	0e 94 7b 56 	call	0xacf6	; 0xacf6 <__divdi3>
    1c42:	22 2e       	mov	r2, r18
    1c44:	33 2e       	mov	r3, r19
    1c46:	44 2e       	mov	r4, r20
    1c48:	55 2e       	mov	r5, r21
    1c4a:	66 2e       	mov	r6, r22
    1c4c:	77 2e       	mov	r7, r23
    1c4e:	88 2e       	mov	r8, r24
    1c50:	99 2e       	mov	r9, r25
    1c52:	a2 2c       	mov	r10, r2
    1c54:	b3 2c       	mov	r11, r3
    1c56:	c4 2c       	mov	r12, r4
    1c58:	d5 2c       	mov	r13, r5
    1c5a:	e6 2c       	mov	r14, r6
    1c5c:	f7 2c       	mov	r15, r7
    1c5e:	08 2d       	mov	r16, r8
    1c60:	19 2d       	mov	r17, r9
    1c62:	2a 2d       	mov	r18, r10
    1c64:	3b 2d       	mov	r19, r11
    1c66:	4c 2d       	mov	r20, r12
    1c68:	5d 2d       	mov	r21, r13
    1c6a:	6e 2d       	mov	r22, r14
    1c6c:	7f 2d       	mov	r23, r15
    1c6e:	80 2f       	mov	r24, r16
    1c70:	91 2f       	mov	r25, r17
    1c72:	01 e0       	ldi	r16, 0x01	; 1
    1c74:	0e 94 9f 55 	call	0xab3e	; 0xab3e <__ashldi3>
    1c78:	22 2e       	mov	r2, r18
    1c7a:	33 2e       	mov	r3, r19
    1c7c:	44 2e       	mov	r4, r20
    1c7e:	55 2e       	mov	r5, r21
    1c80:	66 2e       	mov	r6, r22
    1c82:	77 2e       	mov	r7, r23
    1c84:	88 2e       	mov	r8, r24
    1c86:	99 2e       	mov	r9, r25
    1c88:	a2 2c       	mov	r10, r2
    1c8a:	b3 2c       	mov	r11, r3
    1c8c:	c4 2c       	mov	r12, r4
    1c8e:	d5 2c       	mov	r13, r5
    1c90:	e6 2c       	mov	r14, r6
    1c92:	f7 2c       	mov	r15, r7
    1c94:	08 2d       	mov	r16, r8
    1c96:	19 2d       	mov	r17, r9
    1c98:	2a 2d       	mov	r18, r10
    1c9a:	3b 2d       	mov	r19, r11
    1c9c:	4c 2d       	mov	r20, r12
    1c9e:	5d 2d       	mov	r21, r13
    1ca0:	6e 2d       	mov	r22, r14
    1ca2:	7f 2d       	mov	r23, r15
    1ca4:	80 2f       	mov	r24, r16
    1ca6:	91 2f       	mov	r25, r17
    1ca8:	0f 2e       	mov	r0, r31
    1caa:	f3 e0       	ldi	r31, 0x03	; 3
    1cac:	af 2e       	mov	r10, r31
    1cae:	f0 2d       	mov	r31, r0
    1cb0:	bb 24       	eor	r11, r11
    1cb2:	cc 24       	eor	r12, r12
    1cb4:	dd 24       	eor	r13, r13
    1cb6:	ee 24       	eor	r14, r14
    1cb8:	ff 24       	eor	r15, r15
    1cba:	00 e0       	ldi	r16, 0x00	; 0
    1cbc:	10 e0       	ldi	r17, 0x00	; 0
    1cbe:	0e 94 7b 56 	call	0xacf6	; 0xacf6 <__divdi3>
    1cc2:	a2 2e       	mov	r10, r18
    1cc4:	b3 2e       	mov	r11, r19
    1cc6:	c4 2e       	mov	r12, r20
    1cc8:	d5 2e       	mov	r13, r21
    1cca:	e6 2e       	mov	r14, r22
    1ccc:	f7 2e       	mov	r15, r23
    1cce:	08 2f       	mov	r16, r24
    1cd0:	19 2f       	mov	r17, r25
    1cd2:	2a 2d       	mov	r18, r10
    1cd4:	3b 2d       	mov	r19, r11
    1cd6:	4c 2d       	mov	r20, r12
    1cd8:	5d 2d       	mov	r21, r13
    1cda:	6e 2d       	mov	r22, r14
    1cdc:	7f 2d       	mov	r23, r15
    1cde:	80 2f       	mov	r24, r16
    1ce0:	91 2f       	mov	r25, r17
    1ce2:	da 01       	movw	r26, r20
    1ce4:	c9 01       	movw	r24, r18
    1ce6:	b0 95       	com	r27
    1ce8:	a0 95       	com	r26
    1cea:	90 95       	com	r25
    1cec:	81 95       	neg	r24
    1cee:	9f 4f       	sbci	r25, 0xFF	; 255
    1cf0:	af 4f       	sbci	r26, 0xFF	; 255
    1cf2:	bf 4f       	sbci	r27, 0xFF	; 255
    1cf4:	ee 85       	ldd	r30, Y+14	; 0x0e
    1cf6:	ff 85       	ldd	r31, Y+15	; 0x0f
    1cf8:	80 83       	st	Z, r24
    1cfa:	91 83       	std	Z+1, r25	; 0x01
    1cfc:	a2 83       	std	Z+2, r26	; 0x02
    1cfe:	b3 83       	std	Z+3, r27	; 0x03
		sampleCount++;
    1d00:	80 91 6c 50 	lds	r24, 0x506C
    1d04:	90 91 6d 50 	lds	r25, 0x506D
    1d08:	a0 91 6e 50 	lds	r26, 0x506E
    1d0c:	b0 91 6f 50 	lds	r27, 0x506F
    1d10:	01 96       	adiw	r24, 0x01	; 1
    1d12:	a1 1d       	adc	r26, r1
    1d14:	b1 1d       	adc	r27, r1
    1d16:	80 93 6c 50 	sts	0x506C, r24
    1d1a:	90 93 6d 50 	sts	0x506D, r25
    1d1e:	a0 93 6e 50 	sts	0x506E, r26
    1d22:	b0 93 6f 50 	sts	0x506F, r27
	}
}
    1d26:	2f 96       	adiw	r28, 0x0f	; 15
    1d28:	cd bf       	out	0x3d, r28	; 61
    1d2a:	de bf       	out	0x3e, r29	; 62
    1d2c:	df 91       	pop	r29
    1d2e:	cf 91       	pop	r28
    1d30:	ff 91       	pop	r31
    1d32:	ef 91       	pop	r30
    1d34:	bf 91       	pop	r27
    1d36:	af 91       	pop	r26
    1d38:	9f 91       	pop	r25
    1d3a:	8f 91       	pop	r24
    1d3c:	7f 91       	pop	r23
    1d3e:	6f 91       	pop	r22
    1d40:	5f 91       	pop	r21
    1d42:	4f 91       	pop	r20
    1d44:	3f 91       	pop	r19
    1d46:	2f 91       	pop	r18
    1d48:	1f 91       	pop	r17
    1d4a:	0f 91       	pop	r16
    1d4c:	ff 90       	pop	r15
    1d4e:	ef 90       	pop	r14
    1d50:	df 90       	pop	r13
    1d52:	cf 90       	pop	r12
    1d54:	bf 90       	pop	r11
    1d56:	af 90       	pop	r10
    1d58:	9f 90       	pop	r9
    1d5a:	8f 90       	pop	r8
    1d5c:	7f 90       	pop	r7
    1d5e:	6f 90       	pop	r6
    1d60:	5f 90       	pop	r5
    1d62:	4f 90       	pop	r4
    1d64:	3f 90       	pop	r3
    1d66:	2f 90       	pop	r2
    1d68:	0f 90       	pop	r0
    1d6a:	00 92 3b 00 	sts	0x003B, r0
    1d6e:	0f 90       	pop	r0
    1d70:	0f be       	out	0x3f, r0	; 63
    1d72:	0f 90       	pop	r0
    1d74:	1f 90       	pop	r1
    1d76:	18 95       	reti

00001d78 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1d78:	cf 93       	push	r28
    1d7a:	df 93       	push	r29
    1d7c:	0f 92       	push	r0
    1d7e:	cd b7       	in	r28, 0x3d	; 61
    1d80:	de b7       	in	r29, 0x3e	; 62
    1d82:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1d84:	89 81       	ldd	r24, Y+1	; 0x01
    1d86:	88 23       	and	r24, r24
    1d88:	49 f0       	breq	.+18     	; 0x1d9c <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1d8a:	80 e2       	ldi	r24, 0x20	; 32
    1d8c:	60 e0       	ldi	r22, 0x00	; 0
    1d8e:	0e 94 42 36 	call	0x6c84	; 0x6c84 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1d92:	80 e2       	ldi	r24, 0x20	; 32
    1d94:	60 e0       	ldi	r22, 0x00	; 0
    1d96:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
    1d9a:	04 c0       	rjmp	.+8      	; 0x1da4 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1d9c:	80 e2       	ldi	r24, 0x20	; 32
    1d9e:	60 e0       	ldi	r22, 0x00	; 0
    1da0:	0e 94 a6 36 	call	0x6d4c	; 0x6d4c <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1da4:	0f 90       	pop	r0
    1da6:	df 91       	pop	r29
    1da8:	cf 91       	pop	r28
    1daa:	08 95       	ret

00001dac <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    1dac:	8f 92       	push	r8
    1dae:	9f 92       	push	r9
    1db0:	af 92       	push	r10
    1db2:	bf 92       	push	r11
    1db4:	cf 92       	push	r12
    1db6:	df 92       	push	r13
    1db8:	ef 92       	push	r14
    1dba:	ff 92       	push	r15
    1dbc:	0f 93       	push	r16
    1dbe:	1f 93       	push	r17
    1dc0:	cf 93       	push	r28
    1dc2:	df 93       	push	r29
    1dc4:	cd b7       	in	r28, 0x3d	; 61
    1dc6:	de b7       	in	r29, 0x3e	; 62
    1dc8:	62 97       	sbiw	r28, 0x12	; 18
    1dca:	cd bf       	out	0x3d, r28	; 61
    1dcc:	de bf       	out	0x3e, r29	; 62
    1dce:	89 83       	std	Y+1, r24	; 0x01
    1dd0:	9a 83       	std	Y+2, r25	; 0x02
    1dd2:	6b 83       	std	Y+3, r22	; 0x03
    1dd4:	7c 83       	std	Y+4, r23	; 0x04
    1dd6:	4d 83       	std	Y+5, r20	; 0x05
    1dd8:	2e 83       	std	Y+6, r18	; 0x06
    1dda:	0f 83       	std	Y+7, r16	; 0x07
    1ddc:	18 87       	std	Y+8, r17	; 0x08
    1dde:	e9 86       	std	Y+9, r14	; 0x09
    1de0:	fa 86       	std	Y+10, r15	; 0x0a
    1de2:	cb 86       	std	Y+11, r12	; 0x0b
    1de4:	dc 86       	std	Y+12, r13	; 0x0c
    1de6:	ad 86       	std	Y+13, r10	; 0x0d
    1de8:	be 86       	std	Y+14, r11	; 0x0e
    1dea:	8f 86       	std	Y+15, r8	; 0x0f
    1dec:	98 8a       	std	Y+16, r9	; 0x10
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    1dee:	00 d0       	rcall	.+0      	; 0x1df0 <CO_collectSeismic3Axises+0x44>
    1df0:	0f 92       	push	r0
    1df2:	8d b7       	in	r24, 0x3d	; 61
    1df4:	9e b7       	in	r25, 0x3e	; 62
    1df6:	01 96       	adiw	r24, 0x01	; 1
    1df8:	49 81       	ldd	r20, Y+1	; 0x01
    1dfa:	5a 81       	ldd	r21, Y+2	; 0x02
    1dfc:	2b 81       	ldd	r18, Y+3	; 0x03
    1dfe:	3c 81       	ldd	r19, Y+4	; 0x04
    1e00:	ef 80       	ldd	r14, Y+7	; 0x07
    1e02:	f8 84       	ldd	r15, Y+8	; 0x08
    1e04:	c9 84       	ldd	r12, Y+9	; 0x09
    1e06:	da 84       	ldd	r13, Y+10	; 0x0a
    1e08:	ab 85       	ldd	r26, Y+11	; 0x0b
    1e0a:	bc 85       	ldd	r27, Y+12	; 0x0c
    1e0c:	ed 85       	ldd	r30, Y+13	; 0x0d
    1e0e:	fe 85       	ldd	r31, Y+14	; 0x0e
    1e10:	e9 8b       	std	Y+17, r30	; 0x11
    1e12:	fa 8b       	std	Y+18, r31	; 0x12
    1e14:	6f 85       	ldd	r22, Y+15	; 0x0f
    1e16:	78 89       	ldd	r23, Y+16	; 0x10
    1e18:	fc 01       	movw	r30, r24
    1e1a:	60 83       	st	Z, r22
    1e1c:	71 83       	std	Z+1, r23	; 0x01
    1e1e:	6a a1       	lds	r22, 0x4a
    1e20:	7b a1       	lds	r23, 0x4b
    1e22:	fc 01       	movw	r30, r24
    1e24:	62 83       	std	Z+2, r22	; 0x02
    1e26:	73 83       	std	Z+3, r23	; 0x03
    1e28:	84 ec       	ldi	r24, 0xC4	; 196
    1e2a:	ba 01       	movw	r22, r20
    1e2c:	a9 01       	movw	r20, r18
    1e2e:	2d 81       	ldd	r18, Y+5	; 0x05
    1e30:	0e 81       	ldd	r16, Y+6	; 0x06
    1e32:	5d 01       	movw	r10, r26
    1e34:	89 88       	ldd	r8, Y+17	; 0x11
    1e36:	9a 88       	ldd	r9, Y+18	; 0x12
    1e38:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <CO_collectSeismic3Axises_ext>
    1e3c:	0f 90       	pop	r0
    1e3e:	0f 90       	pop	r0
    1e40:	0f 90       	pop	r0
    1e42:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    1e44:	62 96       	adiw	r28, 0x12	; 18
    1e46:	cd bf       	out	0x3d, r28	; 61
    1e48:	de bf       	out	0x3e, r29	; 62
    1e4a:	df 91       	pop	r29
    1e4c:	cf 91       	pop	r28
    1e4e:	1f 91       	pop	r17
    1e50:	0f 91       	pop	r16
    1e52:	ff 90       	pop	r15
    1e54:	ef 90       	pop	r14
    1e56:	df 90       	pop	r13
    1e58:	cf 90       	pop	r12
    1e5a:	bf 90       	pop	r11
    1e5c:	af 90       	pop	r10
    1e5e:	9f 90       	pop	r9
    1e60:	8f 90       	pop	r8
    1e62:	08 95       	ret

00001e64 <CO_collectSeismic3Axises_ext>:
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    1e64:	8f 92       	push	r8
    1e66:	9f 92       	push	r9
    1e68:	af 92       	push	r10
    1e6a:	bf 92       	push	r11
    1e6c:	cf 92       	push	r12
    1e6e:	df 92       	push	r13
    1e70:	ef 92       	push	r14
    1e72:	ff 92       	push	r15
    1e74:	0f 93       	push	r16
    1e76:	1f 93       	push	r17
    1e78:	cf 93       	push	r28
    1e7a:	df 93       	push	r29
    1e7c:	cd b7       	in	r28, 0x3d	; 61
    1e7e:	de b7       	in	r29, 0x3e	; 62
    1e80:	2f 97       	sbiw	r28, 0x0f	; 15
    1e82:	cd bf       	out	0x3d, r28	; 61
    1e84:	de bf       	out	0x3e, r29	; 62
    1e86:	89 83       	std	Y+1, r24	; 0x01
    1e88:	6a 83       	std	Y+2, r22	; 0x02
    1e8a:	7b 83       	std	Y+3, r23	; 0x03
    1e8c:	4c 83       	std	Y+4, r20	; 0x04
    1e8e:	5d 83       	std	Y+5, r21	; 0x05
    1e90:	2e 83       	std	Y+6, r18	; 0x06
    1e92:	0f 83       	std	Y+7, r16	; 0x07
    1e94:	e8 86       	std	Y+8, r14	; 0x08
    1e96:	f9 86       	std	Y+9, r15	; 0x09
    1e98:	ca 86       	std	Y+10, r12	; 0x0a
    1e9a:	db 86       	std	Y+11, r13	; 0x0b
    1e9c:	ac 86       	std	Y+12, r10	; 0x0c
    1e9e:	bd 86       	std	Y+13, r11	; 0x0d
    1ea0:	8e 86       	std	Y+14, r8	; 0x0e
    1ea2:	9f 86       	std	Y+15, r9	; 0x0f
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER = DataArray;
    1ea4:	89 a1       	lds	r24, 0x49
    1ea6:	9a a1       	lds	r25, 0x4a
    1ea8:	80 93 6a 50 	sts	0x506A, r24
    1eac:	90 93 6b 50 	sts	0x506B, r25
	ADC_Sampling_Finished = 0;
    1eb0:	10 92 c5 50 	sts	0x50C5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1eb4:	81 e0       	ldi	r24, 0x01	; 1
    1eb6:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1eba:	8a 81       	ldd	r24, Y+2	; 0x02
    1ebc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ebe:	fc 01       	movw	r30, r24
    1ec0:	90 81       	ld	r25, Z
    1ec2:	85 e0       	ldi	r24, 0x05	; 5
    1ec4:	69 2f       	mov	r22, r25
    1ec6:	0e 94 8c 09 	call	0x1318	; 0x1318 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1eca:	8a 81       	ldd	r24, Y+2	; 0x02
    1ecc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ece:	01 96       	adiw	r24, 0x01	; 1
    1ed0:	fc 01       	movw	r30, r24
    1ed2:	90 81       	ld	r25, Z
    1ed4:	86 e0       	ldi	r24, 0x06	; 6
    1ed6:	69 2f       	mov	r22, r25
    1ed8:	0e 94 8c 09 	call	0x1318	; 0x1318 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1edc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ede:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee0:	02 96       	adiw	r24, 0x02	; 2
    1ee2:	fc 01       	movw	r30, r24
    1ee4:	90 81       	ld	r25, Z
    1ee6:	87 e0       	ldi	r24, 0x07	; 7
    1ee8:	69 2f       	mov	r22, r25
    1eea:	0e 94 8c 09 	call	0x1318	; 0x1318 <set_ampGain>
	set_filter(filterConfig);
    1eee:	89 81       	ldd	r24, Y+1	; 0x01
    1ef0:	0e 94 bb 0a 	call	0x1576	; 0x1576 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1ef4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ef6:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1efa:	84 e0       	ldi	r24, 0x04	; 4
    1efc:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1f00:	80 ec       	ldi	r24, 0xC0	; 192
    1f02:	98 e0       	ldi	r25, 0x08	; 8
    1f04:	24 e5       	ldi	r18, 0x54	; 84
    1f06:	fc 01       	movw	r30, r24
    1f08:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1f0a:	81 e0       	ldi	r24, 0x01	; 1
    1f0c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1f10:	85 e0       	ldi	r24, 0x05	; 5
    1f12:	0e 94 7a 1e 	call	0x3cf4	; 0x3cf4 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1f16:	80 ea       	ldi	r24, 0xA0	; 160
    1f18:	96 e0       	ldi	r25, 0x06	; 6
    1f1a:	22 e0       	ldi	r18, 0x02	; 2
    1f1c:	fc 01       	movw	r30, r24
    1f1e:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1f20:	80 ea       	ldi	r24, 0xA0	; 160
    1f22:	96 e0       	ldi	r25, 0x06	; 6
    1f24:	21 e0       	ldi	r18, 0x01	; 1
    1f26:	fc 01       	movw	r30, r24
    1f28:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1f2a:	80 e8       	ldi	r24, 0x80	; 128
    1f2c:	91 e0       	ldi	r25, 0x01	; 1
    1f2e:	28 e7       	ldi	r18, 0x78	; 120
    1f30:	fc 01       	movw	r30, r24
    1f32:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1f34:	80 e0       	ldi	r24, 0x00	; 0
    1f36:	98 e0       	ldi	r25, 0x08	; 8
    1f38:	20 ef       	ldi	r18, 0xF0	; 240
    1f3a:	fc 01       	movw	r30, r24
    1f3c:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
    1f40:	98 e0       	ldi	r25, 0x08	; 8
    1f42:	28 85       	ldd	r18, Y+8	; 0x08
    1f44:	39 85       	ldd	r19, Y+9	; 0x09
    1f46:	fc 01       	movw	r30, r24
    1f48:	20 a7       	lds	r18, 0x70
    1f4a:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1f4c:	80 e0       	ldi	r24, 0x00	; 0
    1f4e:	98 e0       	ldi	r25, 0x08	; 8
    1f50:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f52:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f54:	fc 01       	movw	r30, r24
    1f56:	22 a7       	lds	r18, 0x72
    1f58:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1f5a:	80 e0       	ldi	r24, 0x00	; 0
    1f5c:	98 e0       	ldi	r25, 0x08	; 8
    1f5e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f60:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f62:	fc 01       	movw	r30, r24
    1f64:	24 a7       	lds	r18, 0x74
    1f66:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1f68:	80 e0       	ldi	r24, 0x00	; 0
    1f6a:	98 e0       	ldi	r25, 0x08	; 8
    1f6c:	2e 85       	ldd	r18, Y+14	; 0x0e
    1f6e:	3f 85       	ldd	r19, Y+15	; 0x0f
    1f70:	fc 01       	movw	r30, r24
    1f72:	26 a7       	lds	r18, 0x76
    1f74:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1f76:	80 e0       	ldi	r24, 0x00	; 0
    1f78:	98 e0       	ldi	r25, 0x08	; 8
    1f7a:	2e 81       	ldd	r18, Y+6	; 0x06
    1f7c:	22 2f       	mov	r18, r18
    1f7e:	30 e0       	ldi	r19, 0x00	; 0
    1f80:	21 50       	subi	r18, 0x01	; 1
    1f82:	30 40       	sbci	r19, 0x00	; 0
    1f84:	fc 01       	movw	r30, r24
    1f86:	26 a3       	lds	r18, 0x56
    1f88:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1f8a:	80 e0       	ldi	r24, 0x00	; 0
    1f8c:	98 e0       	ldi	r25, 0x08	; 8
    1f8e:	22 e0       	ldi	r18, 0x02	; 2
    1f90:	fc 01       	movw	r30, r24
    1f92:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1f94:	80 e0       	ldi	r24, 0x00	; 0
    1f96:	98 e0       	ldi	r25, 0x08	; 8
    1f98:	2f ef       	ldi	r18, 0xFF	; 255
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1f9e:	80 e0       	ldi	r24, 0x00	; 0
    1fa0:	98 e0       	ldi	r25, 0x08	; 8
    1fa2:	20 e0       	ldi	r18, 0x00	; 0
    1fa4:	38 e0       	ldi	r19, 0x08	; 8
    1fa6:	f9 01       	movw	r30, r18
    1fa8:	20 81       	ld	r18, Z
    1faa:	20 7f       	andi	r18, 0xF0	; 240
    1fac:	28 60       	ori	r18, 0x08	; 8
    1fae:	fc 01       	movw	r30, r24
    1fb0:	20 83       	st	Z, r18

	sampleCount = 0;
    1fb2:	10 92 6c 50 	sts	0x506C, r1
    1fb6:	10 92 6d 50 	sts	0x506D, r1
    1fba:	10 92 6e 50 	sts	0x506E, r1
    1fbe:	10 92 6f 50 	sts	0x506F, r1
	SPICount = 0;
    1fc2:	10 92 be 50 	sts	0x50BE, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1fc6:	80 e0       	ldi	r24, 0x00	; 0
    1fc8:	80 93 32 21 	sts	0x2132, r24
    1fcc:	80 93 31 21 	sts	0x2131, r24
    1fd0:	80 93 30 21 	sts	0x2130, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    1fd4:	80 ea       	ldi	r24, 0xA0	; 160
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	20 ea       	ldi	r18, 0xA0	; 160
    1fda:	30 e0       	ldi	r19, 0x00	; 0
    1fdc:	f9 01       	movw	r30, r18
    1fde:	22 81       	ldd	r18, Z+2	; 0x02
    1fe0:	27 60       	ori	r18, 0x07	; 7
    1fe2:	fc 01       	movw	r30, r24
    1fe4:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1fe6:	78 94       	sei

	SPICS(TRUE);
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1fee:	80 e8       	ldi	r24, 0x80	; 128
    1ff0:	96 e0       	ldi	r25, 0x06	; 6
    1ff2:	20 e2       	ldi	r18, 0x20	; 32
    1ff4:	fc 01       	movw	r30, r24
    1ff6:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1ff8:	80 e4       	ldi	r24, 0x40	; 64
    1ffa:	9a e0       	ldi	r25, 0x0A	; 10
    1ffc:	23 e2       	ldi	r18, 0x23	; 35
    1ffe:	fc 01       	movw	r30, r24
    2000:	21 83       	std	Z+1, r18	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2002:	00 e4       	ldi	r16, 0x40	; 64
    2004:	1a e0       	ldi	r17, 0x0A	; 10
    2006:	8c 81       	ldd	r24, Y+4	; 0x04
    2008:	9d 81       	ldd	r25, Y+5	; 0x05
    200a:	9c 01       	movw	r18, r24
    200c:	40 e0       	ldi	r20, 0x00	; 0
    200e:	50 e0       	ldi	r21, 0x00	; 0
    2010:	80 e8       	ldi	r24, 0x80	; 128
    2012:	94 e8       	ldi	r25, 0x84	; 132
    2014:	ae e1       	ldi	r26, 0x1E	; 30
    2016:	b0 e0       	ldi	r27, 0x00	; 0
    2018:	bc 01       	movw	r22, r24
    201a:	cd 01       	movw	r24, r26
    201c:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    2020:	da 01       	movw	r26, r20
    2022:	c9 01       	movw	r24, r18
    2024:	f8 01       	movw	r30, r16
    2026:	86 a3       	lds	r24, 0x56
    2028:	97 a3       	lds	r25, 0x57
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    202a:	00 e4       	ldi	r16, 0x40	; 64
    202c:	1a e0       	ldi	r17, 0x0A	; 10
    202e:	8c 81       	ldd	r24, Y+4	; 0x04
    2030:	9d 81       	ldd	r25, Y+5	; 0x05
    2032:	9c 01       	movw	r18, r24
    2034:	40 e0       	ldi	r20, 0x00	; 0
    2036:	50 e0       	ldi	r21, 0x00	; 0
    2038:	80 e4       	ldi	r24, 0x40	; 64
    203a:	92 e4       	ldi	r25, 0x42	; 66
    203c:	af e0       	ldi	r26, 0x0F	; 15
    203e:	b0 e0       	ldi	r27, 0x00	; 0
    2040:	bc 01       	movw	r22, r24
    2042:	cd 01       	movw	r24, r26
    2044:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    2048:	da 01       	movw	r26, r20
    204a:	c9 01       	movw	r24, r18
    204c:	f8 01       	movw	r30, r16
    204e:	82 af       	sts	0x72, r24
    2050:	93 af       	sts	0x73, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2052:	80 e4       	ldi	r24, 0x40	; 64
    2054:	98 e0       	ldi	r25, 0x08	; 8
    2056:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2058:	38 a1       	lds	r19, 0x48
    205a:	fc 01       	movw	r30, r24
    205c:	26 a3       	lds	r18, 0x56
    205e:	37 a3       	lds	r19, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2060:	80 e8       	ldi	r24, 0x80	; 128
    2062:	91 e0       	ldi	r25, 0x01	; 1
    2064:	20 ec       	ldi	r18, 0xC0	; 192
    2066:	fc 01       	movw	r30, r24
    2068:	21 83       	std	Z+1, r18	; 0x01
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    206a:	80 e4       	ldi	r24, 0x40	; 64
    206c:	98 e0       	ldi	r25, 0x08	; 8
    206e:	21 e0       	ldi	r18, 0x01	; 1
    2070:	fc 01       	movw	r30, r24
    2072:	26 83       	std	Z+6, r18	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2074:	80 e4       	ldi	r24, 0x40	; 64
    2076:	98 e0       	ldi	r25, 0x08	; 8
    2078:	20 e4       	ldi	r18, 0x40	; 64
    207a:	38 e0       	ldi	r19, 0x08	; 8
    207c:	f9 01       	movw	r30, r18
    207e:	20 81       	ld	r18, Z
    2080:	20 7f       	andi	r18, 0xF0	; 240
    2082:	29 60       	ori	r18, 0x09	; 9
    2084:	fc 01       	movw	r30, r24
    2086:	20 83       	st	Z, r18
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2088:	80 e4       	ldi	r24, 0x40	; 64
    208a:	9a e0       	ldi	r25, 0x0A	; 10
    208c:	20 e4       	ldi	r18, 0x40	; 64
    208e:	3a e0       	ldi	r19, 0x0A	; 10
    2090:	f9 01       	movw	r30, r18
    2092:	20 81       	ld	r18, Z
    2094:	20 7f       	andi	r18, 0xF0	; 240
    2096:	21 60       	ori	r18, 0x01	; 1
    2098:	fc 01       	movw	r30, r24
    209a:	20 83       	st	Z, r18
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    209c:	2f 96       	adiw	r28, 0x0f	; 15
    209e:	cd bf       	out	0x3d, r28	; 61
    20a0:	de bf       	out	0x3e, r29	; 62
    20a2:	df 91       	pop	r29
    20a4:	cf 91       	pop	r28
    20a6:	1f 91       	pop	r17
    20a8:	0f 91       	pop	r16
    20aa:	ff 90       	pop	r15
    20ac:	ef 90       	pop	r14
    20ae:	df 90       	pop	r13
    20b0:	cf 90       	pop	r12
    20b2:	bf 90       	pop	r11
    20b4:	af 90       	pop	r10
    20b6:	9f 90       	pop	r9
    20b8:	8f 90       	pop	r8
    20ba:	08 95       	ret

000020bc <__vector_16>:

//first averaging point
ISR(TCC0_CCA_vect) {
    20bc:	1f 92       	push	r1
    20be:	0f 92       	push	r0
    20c0:	0f b6       	in	r0, 0x3f	; 63
    20c2:	0f 92       	push	r0
    20c4:	00 90 3b 00 	lds	r0, 0x003B
    20c8:	0f 92       	push	r0
    20ca:	11 24       	eor	r1, r1
    20cc:	2f 93       	push	r18
    20ce:	3f 93       	push	r19
    20d0:	4f 93       	push	r20
    20d2:	5f 93       	push	r21
    20d4:	6f 93       	push	r22
    20d6:	7f 93       	push	r23
    20d8:	8f 93       	push	r24
    20da:	9f 93       	push	r25
    20dc:	af 93       	push	r26
    20de:	bf 93       	push	r27
    20e0:	ef 93       	push	r30
    20e2:	ff 93       	push	r31
    20e4:	cf 93       	push	r28
    20e6:	df 93       	push	r29
    20e8:	cd b7       	in	r28, 0x3d	; 61
    20ea:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    20ec:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
}
    20f0:	df 91       	pop	r29
    20f2:	cf 91       	pop	r28
    20f4:	ff 91       	pop	r31
    20f6:	ef 91       	pop	r30
    20f8:	bf 91       	pop	r27
    20fa:	af 91       	pop	r26
    20fc:	9f 91       	pop	r25
    20fe:	8f 91       	pop	r24
    2100:	7f 91       	pop	r23
    2102:	6f 91       	pop	r22
    2104:	5f 91       	pop	r21
    2106:	4f 91       	pop	r20
    2108:	3f 91       	pop	r19
    210a:	2f 91       	pop	r18
    210c:	0f 90       	pop	r0
    210e:	00 92 3b 00 	sts	0x003B, r0
    2112:	0f 90       	pop	r0
    2114:	0f be       	out	0x3f, r0	; 63
    2116:	0f 90       	pop	r0
    2118:	1f 90       	pop	r1
    211a:	18 95       	reti

0000211c <__vector_17>:

//second averaging point
ISR(TCC0_CCB_vect) {
    211c:	1f 92       	push	r1
    211e:	0f 92       	push	r0
    2120:	0f b6       	in	r0, 0x3f	; 63
    2122:	0f 92       	push	r0
    2124:	00 90 3b 00 	lds	r0, 0x003B
    2128:	0f 92       	push	r0
    212a:	11 24       	eor	r1, r1
    212c:	2f 93       	push	r18
    212e:	3f 93       	push	r19
    2130:	4f 93       	push	r20
    2132:	5f 93       	push	r21
    2134:	6f 93       	push	r22
    2136:	7f 93       	push	r23
    2138:	8f 93       	push	r24
    213a:	9f 93       	push	r25
    213c:	af 93       	push	r26
    213e:	bf 93       	push	r27
    2140:	ef 93       	push	r30
    2142:	ff 93       	push	r31
    2144:	cf 93       	push	r28
    2146:	df 93       	push	r29
    2148:	cd b7       	in	r28, 0x3d	; 61
    214a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    214c:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
}
    2150:	df 91       	pop	r29
    2152:	cf 91       	pop	r28
    2154:	ff 91       	pop	r31
    2156:	ef 91       	pop	r30
    2158:	bf 91       	pop	r27
    215a:	af 91       	pop	r26
    215c:	9f 91       	pop	r25
    215e:	8f 91       	pop	r24
    2160:	7f 91       	pop	r23
    2162:	6f 91       	pop	r22
    2164:	5f 91       	pop	r21
    2166:	4f 91       	pop	r20
    2168:	3f 91       	pop	r19
    216a:	2f 91       	pop	r18
    216c:	0f 90       	pop	r0
    216e:	00 92 3b 00 	sts	0x003B, r0
    2172:	0f 90       	pop	r0
    2174:	0f be       	out	0x3f, r0	; 63
    2176:	0f 90       	pop	r0
    2178:	1f 90       	pop	r1
    217a:	18 95       	reti

0000217c <__vector_18>:

//third averaging point
ISR(TCC0_CCC_vect) {
    217c:	1f 92       	push	r1
    217e:	0f 92       	push	r0
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	0f 92       	push	r0
    2184:	00 90 3b 00 	lds	r0, 0x003B
    2188:	0f 92       	push	r0
    218a:	11 24       	eor	r1, r1
    218c:	2f 93       	push	r18
    218e:	3f 93       	push	r19
    2190:	4f 93       	push	r20
    2192:	5f 93       	push	r21
    2194:	6f 93       	push	r22
    2196:	7f 93       	push	r23
    2198:	8f 93       	push	r24
    219a:	9f 93       	push	r25
    219c:	af 93       	push	r26
    219e:	bf 93       	push	r27
    21a0:	ef 93       	push	r30
    21a2:	ff 93       	push	r31
    21a4:	cf 93       	push	r28
    21a6:	df 93       	push	r29
    21a8:	cd b7       	in	r28, 0x3d	; 61
    21aa:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    21ac:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
}
    21b0:	df 91       	pop	r29
    21b2:	cf 91       	pop	r28
    21b4:	ff 91       	pop	r31
    21b6:	ef 91       	pop	r30
    21b8:	bf 91       	pop	r27
    21ba:	af 91       	pop	r26
    21bc:	9f 91       	pop	r25
    21be:	8f 91       	pop	r24
    21c0:	7f 91       	pop	r23
    21c2:	6f 91       	pop	r22
    21c4:	5f 91       	pop	r21
    21c6:	4f 91       	pop	r20
    21c8:	3f 91       	pop	r19
    21ca:	2f 91       	pop	r18
    21cc:	0f 90       	pop	r0
    21ce:	00 92 3b 00 	sts	0x003B, r0
    21d2:	0f 90       	pop	r0
    21d4:	0f be       	out	0x3f, r0	; 63
    21d6:	0f 90       	pop	r0
    21d8:	1f 90       	pop	r1
    21da:	18 95       	reti

000021dc <__vector_19>:

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    21dc:	1f 92       	push	r1
    21de:	0f 92       	push	r0
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	0f 92       	push	r0
    21e4:	00 90 3b 00 	lds	r0, 0x003B
    21e8:	0f 92       	push	r0
    21ea:	11 24       	eor	r1, r1
    21ec:	2f 93       	push	r18
    21ee:	3f 93       	push	r19
    21f0:	4f 93       	push	r20
    21f2:	5f 93       	push	r21
    21f4:	6f 93       	push	r22
    21f6:	7f 93       	push	r23
    21f8:	8f 93       	push	r24
    21fa:	9f 93       	push	r25
    21fc:	af 93       	push	r26
    21fe:	bf 93       	push	r27
    2200:	ef 93       	push	r30
    2202:	ff 93       	push	r31
    2204:	cf 93       	push	r28
    2206:	df 93       	push	r29
    2208:	cd b7       	in	r28, 0x3d	; 61
    220a:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    220c:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
	SPICount = 0;
    2210:	10 92 be 50 	sts	0x50BE, r1
	if(PORTB.OUT & PIN1_bm) {
    2214:	80 e2       	ldi	r24, 0x20	; 32
    2216:	96 e0       	ldi	r25, 0x06	; 6
    2218:	fc 01       	movw	r30, r24
    221a:	84 81       	ldd	r24, Z+4	; 0x04
    221c:	88 2f       	mov	r24, r24
    221e:	90 e0       	ldi	r25, 0x00	; 0
    2220:	82 70       	andi	r24, 0x02	; 2
    2222:	90 70       	andi	r25, 0x00	; 0
    2224:	00 97       	sbiw	r24, 0x00	; 0
    2226:	b1 f0       	breq	.+44     	; 0x2254 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2228:	80 e0       	ldi	r24, 0x00	; 0
    222a:	96 e0       	ldi	r25, 0x06	; 6
    222c:	fc 01       	movw	r30, r24
    222e:	84 81       	ldd	r24, Z+4	; 0x04
    2230:	88 2f       	mov	r24, r24
    2232:	90 e0       	ldi	r25, 0x00	; 0
    2234:	80 74       	andi	r24, 0x40	; 64
    2236:	90 70       	andi	r25, 0x00	; 0
    2238:	00 97       	sbiw	r24, 0x00	; 0
    223a:	31 f0       	breq	.+12     	; 0x2248 <__vector_19+0x6c>
    223c:	80 e2       	ldi	r24, 0x20	; 32
    223e:	96 e0       	ldi	r25, 0x06	; 6
    2240:	22 e0       	ldi	r18, 0x02	; 2
    2242:	fc 01       	movw	r30, r24
    2244:	27 83       	std	Z+7, r18	; 0x07
    2246:	10 c0       	rjmp	.+32     	; 0x2268 <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    2248:	80 e0       	ldi	r24, 0x00	; 0
    224a:	96 e0       	ldi	r25, 0x06	; 6
    224c:	20 e4       	ldi	r18, 0x40	; 64
    224e:	fc 01       	movw	r30, r24
    2250:	27 83       	std	Z+7, r18	; 0x07
    2252:	0a c0       	rjmp	.+20     	; 0x2268 <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2254:	80 e0       	ldi	r24, 0x00	; 0
    2256:	96 e0       	ldi	r25, 0x06	; 6
    2258:	20 e4       	ldi	r18, 0x40	; 64
    225a:	fc 01       	movw	r30, r24
    225c:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    225e:	80 e2       	ldi	r24, 0x20	; 32
    2260:	96 e0       	ldi	r25, 0x06	; 6
    2262:	22 e0       	ldi	r18, 0x02	; 2
    2264:	fc 01       	movw	r30, r24
    2266:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    2268:	df 91       	pop	r29
    226a:	cf 91       	pop	r28
    226c:	ff 91       	pop	r31
    226e:	ef 91       	pop	r30
    2270:	bf 91       	pop	r27
    2272:	af 91       	pop	r26
    2274:	9f 91       	pop	r25
    2276:	8f 91       	pop	r24
    2278:	7f 91       	pop	r23
    227a:	6f 91       	pop	r22
    227c:	5f 91       	pop	r21
    227e:	4f 91       	pop	r20
    2280:	3f 91       	pop	r19
    2282:	2f 91       	pop	r18
    2284:	0f 90       	pop	r0
    2286:	00 92 3b 00 	sts	0x003B, r0
    228a:	0f 90       	pop	r0
    228c:	0f be       	out	0x3f, r0	; 63
    228e:	0f 90       	pop	r0
    2290:	1f 90       	pop	r1
    2292:	18 95       	reti

00002294 <__vector_14>:

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    2294:	1f 92       	push	r1
    2296:	0f 92       	push	r0
    2298:	0f b6       	in	r0, 0x3f	; 63
    229a:	0f 92       	push	r0
    229c:	00 90 3b 00 	lds	r0, 0x003B
    22a0:	0f 92       	push	r0
    22a2:	11 24       	eor	r1, r1
    22a4:	2f 92       	push	r2
    22a6:	3f 92       	push	r3
    22a8:	4f 92       	push	r4
    22aa:	5f 92       	push	r5
    22ac:	6f 92       	push	r6
    22ae:	7f 92       	push	r7
    22b0:	8f 92       	push	r8
    22b2:	9f 92       	push	r9
    22b4:	af 92       	push	r10
    22b6:	bf 92       	push	r11
    22b8:	cf 92       	push	r12
    22ba:	df 92       	push	r13
    22bc:	ef 92       	push	r14
    22be:	ff 92       	push	r15
    22c0:	0f 93       	push	r16
    22c2:	1f 93       	push	r17
    22c4:	2f 93       	push	r18
    22c6:	3f 93       	push	r19
    22c8:	4f 93       	push	r20
    22ca:	5f 93       	push	r21
    22cc:	6f 93       	push	r22
    22ce:	7f 93       	push	r23
    22d0:	8f 93       	push	r24
    22d2:	9f 93       	push	r25
    22d4:	af 93       	push	r26
    22d6:	bf 93       	push	r27
    22d8:	ef 93       	push	r30
    22da:	ff 93       	push	r31
    22dc:	cf 93       	push	r28
    22de:	df 93       	push	r29
    22e0:	cd b7       	in	r28, 0x3d	; 61
    22e2:	de b7       	in	r29, 0x3e	; 62
    22e4:	2f 97       	sbiw	r28, 0x0f	; 15
    22e6:	cd bf       	out	0x3d, r28	; 61
    22e8:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    22ea:	1a 82       	std	Y+2, r1	; 0x02
    22ec:	1b 82       	std	Y+3, r1	; 0x03
    22ee:	1c 82       	std	Y+4, r1	; 0x04
    22f0:	1d 82       	std	Y+5, r1	; 0x05
    22f2:	1e 82       	std	Y+6, r1	; 0x06
    22f4:	1f 82       	std	Y+7, r1	; 0x07
    22f6:	18 86       	std	Y+8, r1	; 0x08
    22f8:	19 86       	std	Y+9, r1	; 0x09
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    22fa:	19 82       	std	Y+1, r1	; 0x01
    22fc:	bd c0       	rjmp	.+378    	; 0x2478 <__vector_14+0x1e4>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    22fe:	89 81       	ldd	r24, Y+1	; 0x01
    2300:	88 2f       	mov	r24, r24
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	83 5a       	subi	r24, 0xA3	; 163
    2306:	9f 4a       	sbci	r25, 0xAF	; 175
    2308:	fc 01       	movw	r30, r24
    230a:	80 81       	ld	r24, Z
    230c:	88 23       	and	r24, r24
    230e:	3c f4       	brge	.+14     	; 0x231e <__vector_14+0x8a>
    2310:	ce 01       	movw	r24, r28
    2312:	0a 96       	adiw	r24, 0x0a	; 10
    2314:	03 96       	adiw	r24, 0x03	; 3
    2316:	2f ef       	ldi	r18, 0xFF	; 255
    2318:	fc 01       	movw	r30, r24
    231a:	20 83       	st	Z, r18
    231c:	05 c0       	rjmp	.+10     	; 0x2328 <__vector_14+0x94>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    231e:	ce 01       	movw	r24, r28
    2320:	0a 96       	adiw	r24, 0x0a	; 10
    2322:	03 96       	adiw	r24, 0x03	; 3
    2324:	fc 01       	movw	r30, r24
    2326:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2328:	ce 01       	movw	r24, r28
    232a:	0a 96       	adiw	r24, 0x0a	; 10
    232c:	02 96       	adiw	r24, 0x02	; 2
    232e:	29 81       	ldd	r18, Y+1	; 0x01
    2330:	22 2f       	mov	r18, r18
    2332:	30 e0       	ldi	r19, 0x00	; 0
    2334:	23 5a       	subi	r18, 0xA3	; 163
    2336:	3f 4a       	sbci	r19, 0xAF	; 175
    2338:	f9 01       	movw	r30, r18
    233a:	20 81       	ld	r18, Z
    233c:	fc 01       	movw	r30, r24
    233e:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2340:	ce 01       	movw	r24, r28
    2342:	0a 96       	adiw	r24, 0x0a	; 10
    2344:	01 96       	adiw	r24, 0x01	; 1
    2346:	29 81       	ldd	r18, Y+1	; 0x01
    2348:	22 2f       	mov	r18, r18
    234a:	30 e0       	ldi	r19, 0x00	; 0
    234c:	2f 5f       	subi	r18, 0xFF	; 255
    234e:	3f 4f       	sbci	r19, 0xFF	; 255
    2350:	23 5a       	subi	r18, 0xA3	; 163
    2352:	3f 4a       	sbci	r19, 0xAF	; 175
    2354:	f9 01       	movw	r30, r18
    2356:	20 81       	ld	r18, Z
    2358:	fc 01       	movw	r30, r24
    235a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    235c:	ce 01       	movw	r24, r28
    235e:	0a 96       	adiw	r24, 0x0a	; 10
    2360:	29 81       	ldd	r18, Y+1	; 0x01
    2362:	22 2f       	mov	r18, r18
    2364:	30 e0       	ldi	r19, 0x00	; 0
    2366:	2e 5f       	subi	r18, 0xFE	; 254
    2368:	3f 4f       	sbci	r19, 0xFF	; 255
    236a:	23 5a       	subi	r18, 0xA3	; 163
    236c:	3f 4a       	sbci	r19, 0xAF	; 175
    236e:	f9 01       	movw	r30, r18
    2370:	20 81       	ld	r18, Z
    2372:	fc 01       	movw	r30, r24
    2374:	20 83       	st	Z, r18
		sum += currentSample;
    2376:	8a 85       	ldd	r24, Y+10	; 0x0a
    2378:	9b 85       	ldd	r25, Y+11	; 0x0b
    237a:	ac 85       	ldd	r26, Y+12	; 0x0c
    237c:	bd 85       	ldd	r27, Y+13	; 0x0d
    237e:	5c 01       	movw	r10, r24
    2380:	6d 01       	movw	r12, r26
    2382:	bb 0f       	add	r27, r27
    2384:	88 0b       	sbc	r24, r24
    2386:	98 2f       	mov	r25, r24
    2388:	dc 01       	movw	r26, r24
    238a:	e8 2e       	mov	r14, r24
    238c:	f8 2e       	mov	r15, r24
    238e:	08 2f       	mov	r16, r24
    2390:	18 2f       	mov	r17, r24
    2392:	2a 80       	ldd	r2, Y+2	; 0x02
    2394:	3b 80       	ldd	r3, Y+3	; 0x03
    2396:	4c 80       	ldd	r4, Y+4	; 0x04
    2398:	5d 80       	ldd	r5, Y+5	; 0x05
    239a:	6e 80       	ldd	r6, Y+6	; 0x06
    239c:	7f 80       	ldd	r7, Y+7	; 0x07
    239e:	88 84       	ldd	r8, Y+8	; 0x08
    23a0:	99 84       	ldd	r9, Y+9	; 0x09
    23a2:	2a 2d       	mov	r18, r10
    23a4:	22 0d       	add	r18, r2
    23a6:	e1 e0       	ldi	r30, 0x01	; 1
    23a8:	2a 15       	cp	r18, r10
    23aa:	08 f0       	brcs	.+2      	; 0x23ae <__vector_14+0x11a>
    23ac:	e0 e0       	ldi	r30, 0x00	; 0
    23ae:	3b 2d       	mov	r19, r11
    23b0:	33 0d       	add	r19, r3
    23b2:	f1 e0       	ldi	r31, 0x01	; 1
    23b4:	3b 15       	cp	r19, r11
    23b6:	08 f0       	brcs	.+2      	; 0x23ba <__vector_14+0x126>
    23b8:	f0 e0       	ldi	r31, 0x00	; 0
    23ba:	e3 0f       	add	r30, r19
    23bc:	a1 e0       	ldi	r26, 0x01	; 1
    23be:	e3 17       	cp	r30, r19
    23c0:	08 f0       	brcs	.+2      	; 0x23c4 <__vector_14+0x130>
    23c2:	a0 e0       	ldi	r26, 0x00	; 0
    23c4:	fa 2b       	or	r31, r26
    23c6:	3e 2f       	mov	r19, r30
    23c8:	4c 2d       	mov	r20, r12
    23ca:	44 0d       	add	r20, r4
    23cc:	e1 e0       	ldi	r30, 0x01	; 1
    23ce:	4c 15       	cp	r20, r12
    23d0:	08 f0       	brcs	.+2      	; 0x23d4 <__vector_14+0x140>
    23d2:	e0 e0       	ldi	r30, 0x00	; 0
    23d4:	f4 0f       	add	r31, r20
    23d6:	a1 e0       	ldi	r26, 0x01	; 1
    23d8:	f4 17       	cp	r31, r20
    23da:	08 f0       	brcs	.+2      	; 0x23de <__vector_14+0x14a>
    23dc:	a0 e0       	ldi	r26, 0x00	; 0
    23de:	ea 2b       	or	r30, r26
    23e0:	4f 2f       	mov	r20, r31
    23e2:	5d 2d       	mov	r21, r13
    23e4:	55 0d       	add	r21, r5
    23e6:	f1 e0       	ldi	r31, 0x01	; 1
    23e8:	5d 15       	cp	r21, r13
    23ea:	08 f0       	brcs	.+2      	; 0x23ee <__vector_14+0x15a>
    23ec:	f0 e0       	ldi	r31, 0x00	; 0
    23ee:	e5 0f       	add	r30, r21
    23f0:	a1 e0       	ldi	r26, 0x01	; 1
    23f2:	e5 17       	cp	r30, r21
    23f4:	08 f0       	brcs	.+2      	; 0x23f8 <__vector_14+0x164>
    23f6:	a0 e0       	ldi	r26, 0x00	; 0
    23f8:	fa 2b       	or	r31, r26
    23fa:	5e 2f       	mov	r21, r30
    23fc:	6e 2d       	mov	r22, r14
    23fe:	66 0d       	add	r22, r6
    2400:	e1 e0       	ldi	r30, 0x01	; 1
    2402:	6e 15       	cp	r22, r14
    2404:	08 f0       	brcs	.+2      	; 0x2408 <__vector_14+0x174>
    2406:	e0 e0       	ldi	r30, 0x00	; 0
    2408:	f6 0f       	add	r31, r22
    240a:	a1 e0       	ldi	r26, 0x01	; 1
    240c:	f6 17       	cp	r31, r22
    240e:	08 f0       	brcs	.+2      	; 0x2412 <__vector_14+0x17e>
    2410:	a0 e0       	ldi	r26, 0x00	; 0
    2412:	ea 2b       	or	r30, r26
    2414:	6f 2f       	mov	r22, r31
    2416:	7f 2d       	mov	r23, r15
    2418:	77 0d       	add	r23, r7
    241a:	f1 e0       	ldi	r31, 0x01	; 1
    241c:	7f 15       	cp	r23, r15
    241e:	08 f0       	brcs	.+2      	; 0x2422 <__vector_14+0x18e>
    2420:	f0 e0       	ldi	r31, 0x00	; 0
    2422:	e7 0f       	add	r30, r23
    2424:	a1 e0       	ldi	r26, 0x01	; 1
    2426:	e7 17       	cp	r30, r23
    2428:	08 f0       	brcs	.+2      	; 0x242c <__vector_14+0x198>
    242a:	a0 e0       	ldi	r26, 0x00	; 0
    242c:	fa 2b       	or	r31, r26
    242e:	7e 2f       	mov	r23, r30
    2430:	80 2f       	mov	r24, r16
    2432:	88 0d       	add	r24, r8
    2434:	e1 e0       	ldi	r30, 0x01	; 1
    2436:	80 17       	cp	r24, r16
    2438:	08 f0       	brcs	.+2      	; 0x243c <__vector_14+0x1a8>
    243a:	e0 e0       	ldi	r30, 0x00	; 0
    243c:	f8 0f       	add	r31, r24
    243e:	a1 e0       	ldi	r26, 0x01	; 1
    2440:	f8 17       	cp	r31, r24
    2442:	08 f0       	brcs	.+2      	; 0x2446 <__vector_14+0x1b2>
    2444:	a0 e0       	ldi	r26, 0x00	; 0
    2446:	ea 2b       	or	r30, r26
    2448:	8f 2f       	mov	r24, r31
    244a:	91 2f       	mov	r25, r17
    244c:	99 0d       	add	r25, r9
    244e:	e9 0f       	add	r30, r25
    2450:	9e 2f       	mov	r25, r30
    2452:	22 2e       	mov	r2, r18
    2454:	33 2e       	mov	r3, r19
    2456:	44 2e       	mov	r4, r20
    2458:	55 2e       	mov	r5, r21
    245a:	66 2e       	mov	r6, r22
    245c:	77 2e       	mov	r7, r23
    245e:	88 2e       	mov	r8, r24
    2460:	99 2e       	mov	r9, r25
    2462:	2a 82       	std	Y+2, r2	; 0x02
    2464:	3b 82       	std	Y+3, r3	; 0x03
    2466:	4c 82       	std	Y+4, r4	; 0x04
    2468:	5d 82       	std	Y+5, r5	; 0x05
    246a:	6e 82       	std	Y+6, r6	; 0x06
    246c:	7f 82       	std	Y+7, r7	; 0x07
    246e:	88 86       	std	Y+8, r8	; 0x08
    2470:	99 86       	std	Y+9, r9	; 0x09
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2472:	89 81       	ldd	r24, Y+1	; 0x01
    2474:	8d 5f       	subi	r24, 0xFD	; 253
    2476:	89 83       	std	Y+1, r24	; 0x01
    2478:	89 81       	ldd	r24, Y+1	; 0x01
    247a:	8c 30       	cpi	r24, 0x0C	; 12
    247c:	08 f4       	brcc	.+2      	; 0x2480 <__vector_14+0x1ec>
    247e:	3f cf       	rjmp	.-386    	; 0x22fe <__vector_14+0x6a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    2480:	2a 81       	ldd	r18, Y+2	; 0x02
    2482:	3b 81       	ldd	r19, Y+3	; 0x03
    2484:	4c 81       	ldd	r20, Y+4	; 0x04
    2486:	5d 81       	ldd	r21, Y+5	; 0x05
    2488:	6e 81       	ldd	r22, Y+6	; 0x06
    248a:	7f 81       	ldd	r23, Y+7	; 0x07
    248c:	88 85       	ldd	r24, Y+8	; 0x08
    248e:	99 85       	ldd	r25, Y+9	; 0x09
    2490:	a2 2e       	mov	r10, r18
    2492:	b3 2e       	mov	r11, r19
    2494:	c4 2e       	mov	r12, r20
    2496:	d5 2e       	mov	r13, r21
    2498:	e6 2e       	mov	r14, r22
    249a:	f7 2e       	mov	r15, r23
    249c:	08 2f       	mov	r16, r24
    249e:	19 2f       	mov	r17, r25
    24a0:	11 23       	and	r17, r17
    24a2:	0c f0       	brlt	.+2      	; 0x24a6 <__vector_14+0x212>
    24a4:	6b c0       	rjmp	.+214    	; 0x257c <__vector_14+0x2e8>
    24a6:	0f 2e       	mov	r0, r31
    24a8:	f3 e0       	ldi	r31, 0x03	; 3
    24aa:	2f 2e       	mov	r2, r31
    24ac:	f0 2d       	mov	r31, r0
    24ae:	33 24       	eor	r3, r3
    24b0:	44 24       	eor	r4, r4
    24b2:	55 24       	eor	r5, r5
    24b4:	66 24       	eor	r6, r6
    24b6:	77 24       	eor	r7, r7
    24b8:	88 24       	eor	r8, r8
    24ba:	99 24       	eor	r9, r9
    24bc:	2a 2d       	mov	r18, r10
    24be:	22 0d       	add	r18, r2
    24c0:	e1 e0       	ldi	r30, 0x01	; 1
    24c2:	2a 15       	cp	r18, r10
    24c4:	08 f0       	brcs	.+2      	; 0x24c8 <__vector_14+0x234>
    24c6:	e0 e0       	ldi	r30, 0x00	; 0
    24c8:	3b 2d       	mov	r19, r11
    24ca:	33 0d       	add	r19, r3
    24cc:	f1 e0       	ldi	r31, 0x01	; 1
    24ce:	3b 15       	cp	r19, r11
    24d0:	08 f0       	brcs	.+2      	; 0x24d4 <__vector_14+0x240>
    24d2:	f0 e0       	ldi	r31, 0x00	; 0
    24d4:	e3 0f       	add	r30, r19
    24d6:	a1 e0       	ldi	r26, 0x01	; 1
    24d8:	e3 17       	cp	r30, r19
    24da:	08 f0       	brcs	.+2      	; 0x24de <__vector_14+0x24a>
    24dc:	a0 e0       	ldi	r26, 0x00	; 0
    24de:	fa 2b       	or	r31, r26
    24e0:	3e 2f       	mov	r19, r30
    24e2:	4c 2d       	mov	r20, r12
    24e4:	44 0d       	add	r20, r4
    24e6:	e1 e0       	ldi	r30, 0x01	; 1
    24e8:	4c 15       	cp	r20, r12
    24ea:	08 f0       	brcs	.+2      	; 0x24ee <__vector_14+0x25a>
    24ec:	e0 e0       	ldi	r30, 0x00	; 0
    24ee:	f4 0f       	add	r31, r20
    24f0:	a1 e0       	ldi	r26, 0x01	; 1
    24f2:	f4 17       	cp	r31, r20
    24f4:	08 f0       	brcs	.+2      	; 0x24f8 <__vector_14+0x264>
    24f6:	a0 e0       	ldi	r26, 0x00	; 0
    24f8:	ea 2b       	or	r30, r26
    24fa:	4f 2f       	mov	r20, r31
    24fc:	5d 2d       	mov	r21, r13
    24fe:	55 0d       	add	r21, r5
    2500:	f1 e0       	ldi	r31, 0x01	; 1
    2502:	5d 15       	cp	r21, r13
    2504:	08 f0       	brcs	.+2      	; 0x2508 <__vector_14+0x274>
    2506:	f0 e0       	ldi	r31, 0x00	; 0
    2508:	e5 0f       	add	r30, r21
    250a:	a1 e0       	ldi	r26, 0x01	; 1
    250c:	e5 17       	cp	r30, r21
    250e:	08 f0       	brcs	.+2      	; 0x2512 <__vector_14+0x27e>
    2510:	a0 e0       	ldi	r26, 0x00	; 0
    2512:	fa 2b       	or	r31, r26
    2514:	5e 2f       	mov	r21, r30
    2516:	6e 2d       	mov	r22, r14
    2518:	66 0d       	add	r22, r6
    251a:	e1 e0       	ldi	r30, 0x01	; 1
    251c:	6e 15       	cp	r22, r14
    251e:	08 f0       	brcs	.+2      	; 0x2522 <__vector_14+0x28e>
    2520:	e0 e0       	ldi	r30, 0x00	; 0
    2522:	f6 0f       	add	r31, r22
    2524:	a1 e0       	ldi	r26, 0x01	; 1
    2526:	f6 17       	cp	r31, r22
    2528:	08 f0       	brcs	.+2      	; 0x252c <__vector_14+0x298>
    252a:	a0 e0       	ldi	r26, 0x00	; 0
    252c:	ea 2b       	or	r30, r26
    252e:	6f 2f       	mov	r22, r31
    2530:	7f 2d       	mov	r23, r15
    2532:	77 0d       	add	r23, r7
    2534:	f1 e0       	ldi	r31, 0x01	; 1
    2536:	7f 15       	cp	r23, r15
    2538:	08 f0       	brcs	.+2      	; 0x253c <__vector_14+0x2a8>
    253a:	f0 e0       	ldi	r31, 0x00	; 0
    253c:	e7 0f       	add	r30, r23
    253e:	a1 e0       	ldi	r26, 0x01	; 1
    2540:	e7 17       	cp	r30, r23
    2542:	08 f0       	brcs	.+2      	; 0x2546 <__vector_14+0x2b2>
    2544:	a0 e0       	ldi	r26, 0x00	; 0
    2546:	fa 2b       	or	r31, r26
    2548:	7e 2f       	mov	r23, r30
    254a:	80 2f       	mov	r24, r16
    254c:	88 0d       	add	r24, r8
    254e:	e1 e0       	ldi	r30, 0x01	; 1
    2550:	80 17       	cp	r24, r16
    2552:	08 f0       	brcs	.+2      	; 0x2556 <__vector_14+0x2c2>
    2554:	e0 e0       	ldi	r30, 0x00	; 0
    2556:	f8 0f       	add	r31, r24
    2558:	a1 e0       	ldi	r26, 0x01	; 1
    255a:	f8 17       	cp	r31, r24
    255c:	08 f0       	brcs	.+2      	; 0x2560 <__vector_14+0x2cc>
    255e:	a0 e0       	ldi	r26, 0x00	; 0
    2560:	ea 2b       	or	r30, r26
    2562:	8f 2f       	mov	r24, r31
    2564:	91 2f       	mov	r25, r17
    2566:	99 0d       	add	r25, r9
    2568:	e9 0f       	add	r30, r25
    256a:	9e 2f       	mov	r25, r30
    256c:	a2 2e       	mov	r10, r18
    256e:	b3 2e       	mov	r11, r19
    2570:	c4 2e       	mov	r12, r20
    2572:	d5 2e       	mov	r13, r21
    2574:	e6 2e       	mov	r14, r22
    2576:	f7 2e       	mov	r15, r23
    2578:	08 2f       	mov	r16, r24
    257a:	19 2f       	mov	r17, r25
    257c:	2a 2d       	mov	r18, r10
    257e:	3b 2d       	mov	r19, r11
    2580:	4c 2d       	mov	r20, r12
    2582:	5d 2d       	mov	r21, r13
    2584:	6e 2d       	mov	r22, r14
    2586:	7f 2d       	mov	r23, r15
    2588:	80 2f       	mov	r24, r16
    258a:	91 2f       	mov	r25, r17
    258c:	02 e0       	ldi	r16, 0x02	; 2
    258e:	0e 94 13 56 	call	0xac26	; 0xac26 <__ashrdi3>
    2592:	a2 2e       	mov	r10, r18
    2594:	b3 2e       	mov	r11, r19
    2596:	c4 2e       	mov	r12, r20
    2598:	d5 2e       	mov	r13, r21
    259a:	e6 2e       	mov	r14, r22
    259c:	f7 2e       	mov	r15, r23
    259e:	08 2f       	mov	r16, r24
    25a0:	19 2f       	mov	r17, r25
    25a2:	2a 2d       	mov	r18, r10
    25a4:	3b 2d       	mov	r19, r11
    25a6:	4c 2d       	mov	r20, r12
    25a8:	5d 2d       	mov	r21, r13
    25aa:	6e 2d       	mov	r22, r14
    25ac:	7f 2d       	mov	r23, r15
    25ae:	80 2f       	mov	r24, r16
    25b0:	91 2f       	mov	r25, r17
    25b2:	2a 83       	std	Y+2, r18	; 0x02
    25b4:	3b 83       	std	Y+3, r19	; 0x03
    25b6:	4c 83       	std	Y+4, r20	; 0x04
    25b8:	5d 83       	std	Y+5, r21	; 0x05
    25ba:	6e 83       	std	Y+6, r22	; 0x06
    25bc:	7f 83       	std	Y+7, r23	; 0x07
    25be:	88 87       	std	Y+8, r24	; 0x08
    25c0:	99 87       	std	Y+9, r25	; 0x09
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    25c2:	20 91 6a 50 	lds	r18, 0x506A
    25c6:	30 91 6b 50 	lds	r19, 0x506B
    25ca:	80 91 6c 50 	lds	r24, 0x506C
    25ce:	90 91 6d 50 	lds	r25, 0x506D
    25d2:	a0 91 6e 50 	lds	r26, 0x506E
    25d6:	b0 91 6f 50 	lds	r27, 0x506F
    25da:	88 0f       	add	r24, r24
    25dc:	99 1f       	adc	r25, r25
    25de:	88 0f       	add	r24, r24
    25e0:	99 1f       	adc	r25, r25
    25e2:	a9 01       	movw	r20, r18
    25e4:	48 0f       	add	r20, r24
    25e6:	59 1f       	adc	r21, r25
    25e8:	4e 87       	std	Y+14, r20	; 0x0e
    25ea:	5f 87       	std	Y+15, r21	; 0x0f
    25ec:	aa 80       	ldd	r10, Y+2	; 0x02
    25ee:	bb 80       	ldd	r11, Y+3	; 0x03
    25f0:	cc 80       	ldd	r12, Y+4	; 0x04
    25f2:	dd 80       	ldd	r13, Y+5	; 0x05
    25f4:	ee 80       	ldd	r14, Y+6	; 0x06
    25f6:	ff 80       	ldd	r15, Y+7	; 0x07
    25f8:	08 85       	ldd	r16, Y+8	; 0x08
    25fa:	19 85       	ldd	r17, Y+9	; 0x09
    25fc:	2a 2d       	mov	r18, r10
    25fe:	3b 2d       	mov	r19, r11
    2600:	4c 2d       	mov	r20, r12
    2602:	5d 2d       	mov	r21, r13
    2604:	6e 2d       	mov	r22, r14
    2606:	7f 2d       	mov	r23, r15
    2608:	80 2f       	mov	r24, r16
    260a:	91 2f       	mov	r25, r17
    260c:	0f 2e       	mov	r0, r31
    260e:	f0 ea       	ldi	r31, 0xA0	; 160
    2610:	af 2e       	mov	r10, r31
    2612:	f0 2d       	mov	r31, r0
    2614:	0f 2e       	mov	r0, r31
    2616:	f5 e2       	ldi	r31, 0x25	; 37
    2618:	bf 2e       	mov	r11, r31
    261a:	f0 2d       	mov	r31, r0
    261c:	0f 2e       	mov	r0, r31
    261e:	f6 e2       	ldi	r31, 0x26	; 38
    2620:	cf 2e       	mov	r12, r31
    2622:	f0 2d       	mov	r31, r0
    2624:	dd 24       	eor	r13, r13
    2626:	ee 24       	eor	r14, r14
    2628:	ff 24       	eor	r15, r15
    262a:	00 e0       	ldi	r16, 0x00	; 0
    262c:	10 e0       	ldi	r17, 0x00	; 0
    262e:	0e 94 cc 54 	call	0xa998	; 0xa998 <__muldi3>
    2632:	22 2e       	mov	r2, r18
    2634:	33 2e       	mov	r3, r19
    2636:	44 2e       	mov	r4, r20
    2638:	55 2e       	mov	r5, r21
    263a:	66 2e       	mov	r6, r22
    263c:	77 2e       	mov	r7, r23
    263e:	88 2e       	mov	r8, r24
    2640:	99 2e       	mov	r9, r25
    2642:	a2 2c       	mov	r10, r2
    2644:	b3 2c       	mov	r11, r3
    2646:	c4 2c       	mov	r12, r4
    2648:	d5 2c       	mov	r13, r5
    264a:	e6 2c       	mov	r14, r6
    264c:	f7 2c       	mov	r15, r7
    264e:	08 2d       	mov	r16, r8
    2650:	19 2d       	mov	r17, r9
    2652:	2a 2d       	mov	r18, r10
    2654:	3b 2d       	mov	r19, r11
    2656:	4c 2d       	mov	r20, r12
    2658:	5d 2d       	mov	r21, r13
    265a:	6e 2d       	mov	r22, r14
    265c:	7f 2d       	mov	r23, r15
    265e:	80 2f       	mov	r24, r16
    2660:	91 2f       	mov	r25, r17
    2662:	aa 24       	eor	r10, r10
    2664:	aa 94       	dec	r10
    2666:	bb 24       	eor	r11, r11
    2668:	ba 94       	dec	r11
    266a:	0f 2e       	mov	r0, r31
    266c:	ff e7       	ldi	r31, 0x7F	; 127
    266e:	cf 2e       	mov	r12, r31
    2670:	f0 2d       	mov	r31, r0
    2672:	dd 24       	eor	r13, r13
    2674:	ee 24       	eor	r14, r14
    2676:	ff 24       	eor	r15, r15
    2678:	00 e0       	ldi	r16, 0x00	; 0
    267a:	10 e0       	ldi	r17, 0x00	; 0
    267c:	0e 94 7b 56 	call	0xacf6	; 0xacf6 <__divdi3>
    2680:	22 2e       	mov	r2, r18
    2682:	33 2e       	mov	r3, r19
    2684:	44 2e       	mov	r4, r20
    2686:	55 2e       	mov	r5, r21
    2688:	66 2e       	mov	r6, r22
    268a:	77 2e       	mov	r7, r23
    268c:	88 2e       	mov	r8, r24
    268e:	99 2e       	mov	r9, r25
    2690:	a2 2c       	mov	r10, r2
    2692:	b3 2c       	mov	r11, r3
    2694:	c4 2c       	mov	r12, r4
    2696:	d5 2c       	mov	r13, r5
    2698:	e6 2c       	mov	r14, r6
    269a:	f7 2c       	mov	r15, r7
    269c:	08 2d       	mov	r16, r8
    269e:	19 2d       	mov	r17, r9
    26a0:	2a 2d       	mov	r18, r10
    26a2:	3b 2d       	mov	r19, r11
    26a4:	4c 2d       	mov	r20, r12
    26a6:	5d 2d       	mov	r21, r13
    26a8:	6e 2d       	mov	r22, r14
    26aa:	7f 2d       	mov	r23, r15
    26ac:	80 2f       	mov	r24, r16
    26ae:	91 2f       	mov	r25, r17
    26b0:	01 e0       	ldi	r16, 0x01	; 1
    26b2:	0e 94 9f 55 	call	0xab3e	; 0xab3e <__ashldi3>
    26b6:	22 2e       	mov	r2, r18
    26b8:	33 2e       	mov	r3, r19
    26ba:	44 2e       	mov	r4, r20
    26bc:	55 2e       	mov	r5, r21
    26be:	66 2e       	mov	r6, r22
    26c0:	77 2e       	mov	r7, r23
    26c2:	88 2e       	mov	r8, r24
    26c4:	99 2e       	mov	r9, r25
    26c6:	a2 2c       	mov	r10, r2
    26c8:	b3 2c       	mov	r11, r3
    26ca:	c4 2c       	mov	r12, r4
    26cc:	d5 2c       	mov	r13, r5
    26ce:	e6 2c       	mov	r14, r6
    26d0:	f7 2c       	mov	r15, r7
    26d2:	08 2d       	mov	r16, r8
    26d4:	19 2d       	mov	r17, r9
    26d6:	2a 2d       	mov	r18, r10
    26d8:	3b 2d       	mov	r19, r11
    26da:	4c 2d       	mov	r20, r12
    26dc:	5d 2d       	mov	r21, r13
    26de:	6e 2d       	mov	r22, r14
    26e0:	7f 2d       	mov	r23, r15
    26e2:	80 2f       	mov	r24, r16
    26e4:	91 2f       	mov	r25, r17
    26e6:	0f 2e       	mov	r0, r31
    26e8:	f3 e0       	ldi	r31, 0x03	; 3
    26ea:	af 2e       	mov	r10, r31
    26ec:	f0 2d       	mov	r31, r0
    26ee:	bb 24       	eor	r11, r11
    26f0:	cc 24       	eor	r12, r12
    26f2:	dd 24       	eor	r13, r13
    26f4:	ee 24       	eor	r14, r14
    26f6:	ff 24       	eor	r15, r15
    26f8:	00 e0       	ldi	r16, 0x00	; 0
    26fa:	10 e0       	ldi	r17, 0x00	; 0
    26fc:	0e 94 7b 56 	call	0xacf6	; 0xacf6 <__divdi3>
    2700:	a2 2e       	mov	r10, r18
    2702:	b3 2e       	mov	r11, r19
    2704:	c4 2e       	mov	r12, r20
    2706:	d5 2e       	mov	r13, r21
    2708:	e6 2e       	mov	r14, r22
    270a:	f7 2e       	mov	r15, r23
    270c:	08 2f       	mov	r16, r24
    270e:	19 2f       	mov	r17, r25
    2710:	2a 2d       	mov	r18, r10
    2712:	3b 2d       	mov	r19, r11
    2714:	4c 2d       	mov	r20, r12
    2716:	5d 2d       	mov	r21, r13
    2718:	6e 2d       	mov	r22, r14
    271a:	7f 2d       	mov	r23, r15
    271c:	80 2f       	mov	r24, r16
    271e:	91 2f       	mov	r25, r17
    2720:	da 01       	movw	r26, r20
    2722:	c9 01       	movw	r24, r18
    2724:	ee 85       	ldd	r30, Y+14	; 0x0e
    2726:	ff 85       	ldd	r31, Y+15	; 0x0f
    2728:	80 83       	st	Z, r24
    272a:	91 83       	std	Z+1, r25	; 0x01
    272c:	a2 83       	std	Z+2, r26	; 0x02
    272e:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    2730:	80 91 6c 50 	lds	r24, 0x506C
    2734:	90 91 6d 50 	lds	r25, 0x506D
    2738:	a0 91 6e 50 	lds	r26, 0x506E
    273c:	b0 91 6f 50 	lds	r27, 0x506F
    2740:	01 96       	adiw	r24, 0x01	; 1
    2742:	a1 1d       	adc	r26, r1
    2744:	b1 1d       	adc	r27, r1
    2746:	80 93 6c 50 	sts	0x506C, r24
    274a:	90 93 6d 50 	sts	0x506D, r25
    274e:	a0 93 6e 50 	sts	0x506E, r26
    2752:	b0 93 6f 50 	sts	0x506F, r27

}
    2756:	2f 96       	adiw	r28, 0x0f	; 15
    2758:	cd bf       	out	0x3d, r28	; 61
    275a:	de bf       	out	0x3e, r29	; 62
    275c:	df 91       	pop	r29
    275e:	cf 91       	pop	r28
    2760:	ff 91       	pop	r31
    2762:	ef 91       	pop	r30
    2764:	bf 91       	pop	r27
    2766:	af 91       	pop	r26
    2768:	9f 91       	pop	r25
    276a:	8f 91       	pop	r24
    276c:	7f 91       	pop	r23
    276e:	6f 91       	pop	r22
    2770:	5f 91       	pop	r21
    2772:	4f 91       	pop	r20
    2774:	3f 91       	pop	r19
    2776:	2f 91       	pop	r18
    2778:	1f 91       	pop	r17
    277a:	0f 91       	pop	r16
    277c:	ff 90       	pop	r15
    277e:	ef 90       	pop	r14
    2780:	df 90       	pop	r13
    2782:	cf 90       	pop	r12
    2784:	bf 90       	pop	r11
    2786:	af 90       	pop	r10
    2788:	9f 90       	pop	r9
    278a:	8f 90       	pop	r8
    278c:	7f 90       	pop	r7
    278e:	6f 90       	pop	r6
    2790:	5f 90       	pop	r5
    2792:	4f 90       	pop	r4
    2794:	3f 90       	pop	r3
    2796:	2f 90       	pop	r2
    2798:	0f 90       	pop	r0
    279a:	00 92 3b 00 	sts	0x003B, r0
    279e:	0f 90       	pop	r0
    27a0:	0f be       	out	0x3f, r0	; 63
    27a2:	0f 90       	pop	r0
    27a4:	1f 90       	pop	r1
    27a6:	18 95       	reti

000027a8 <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    27a8:	8f 92       	push	r8
    27aa:	9f 92       	push	r9
    27ac:	af 92       	push	r10
    27ae:	bf 92       	push	r11
    27b0:	cf 92       	push	r12
    27b2:	df 92       	push	r13
    27b4:	ef 92       	push	r14
    27b6:	ff 92       	push	r15
    27b8:	0f 93       	push	r16
    27ba:	cf 93       	push	r28
    27bc:	df 93       	push	r29
    27be:	cd b7       	in	r28, 0x3d	; 61
    27c0:	de b7       	in	r29, 0x3e	; 62
    27c2:	60 97       	sbiw	r28, 0x10	; 16
    27c4:	cd bf       	out	0x3d, r28	; 61
    27c6:	de bf       	out	0x3e, r29	; 62
    27c8:	89 83       	std	Y+1, r24	; 0x01
    27ca:	6a 83       	std	Y+2, r22	; 0x02
    27cc:	4b 83       	std	Y+3, r20	; 0x03
    27ce:	5c 83       	std	Y+4, r21	; 0x04
    27d0:	2d 83       	std	Y+5, r18	; 0x05
    27d2:	0e 83       	std	Y+6, r16	; 0x06
    27d4:	ef 82       	std	Y+7, r14	; 0x07
    27d6:	f8 86       	std	Y+8, r15	; 0x08
    27d8:	c9 86       	std	Y+9, r12	; 0x09
    27da:	da 86       	std	Y+10, r13	; 0x0a
    27dc:	ab 86       	std	Y+11, r10	; 0x0b
    27de:	bc 86       	std	Y+12, r11	; 0x0c
    27e0:	8d 86       	std	Y+13, r8	; 0x0d
    27e2:	9e 86       	std	Y+14, r9	; 0x0e
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    27e4:	00 d0       	rcall	.+0      	; 0x27e6 <CO_collectSeismic1Channel+0x3e>
    27e6:	00 d0       	rcall	.+0      	; 0x27e8 <CO_collectSeismic1Channel+0x40>
    27e8:	8d b7       	in	r24, 0x3d	; 61
    27ea:	9e b7       	in	r25, 0x3e	; 62
    27ec:	01 96       	adiw	r24, 0x01	; 1
    27ee:	2b 81       	ldd	r18, Y+3	; 0x03
    27f0:	3c 81       	ldd	r19, Y+4	; 0x04
    27f2:	cf 80       	ldd	r12, Y+7	; 0x07
    27f4:	d8 84       	ldd	r13, Y+8	; 0x08
    27f6:	a9 85       	ldd	r26, Y+9	; 0x09
    27f8:	ba 85       	ldd	r27, Y+10	; 0x0a
    27fa:	eb 85       	ldd	r30, Y+11	; 0x0b
    27fc:	fc 85       	ldd	r31, Y+12	; 0x0c
    27fe:	ef 87       	std	Y+15, r30	; 0x0f
    2800:	f8 8b       	std	Y+16, r31	; 0x10
    2802:	4d 85       	ldd	r20, Y+13	; 0x0d
    2804:	5e 85       	ldd	r21, Y+14	; 0x0e
    2806:	fc 01       	movw	r30, r24
    2808:	40 83       	st	Z, r20
    280a:	51 83       	std	Z+1, r21	; 0x01
    280c:	4f 8d       	ldd	r20, Y+31	; 0x1f
    280e:	58 a1       	lds	r21, 0x48
    2810:	fc 01       	movw	r30, r24
    2812:	42 83       	std	Z+2, r20	; 0x02
    2814:	53 83       	std	Z+3, r21	; 0x03
    2816:	49 a1       	lds	r20, 0x49
    2818:	5a a1       	lds	r21, 0x4a
    281a:	fc 01       	movw	r30, r24
    281c:	44 83       	std	Z+4, r20	; 0x04
    281e:	55 83       	std	Z+5, r21	; 0x05
    2820:	89 81       	ldd	r24, Y+1	; 0x01
    2822:	64 ec       	ldi	r22, 0xC4	; 196
    2824:	4a 81       	ldd	r20, Y+2	; 0x02
    2826:	0d 81       	ldd	r16, Y+5	; 0x05
    2828:	ee 80       	ldd	r14, Y+6	; 0x06
    282a:	5d 01       	movw	r10, r26
    282c:	8f 84       	ldd	r8, Y+15	; 0x0f
    282e:	98 88       	ldd	r9, Y+16	; 0x10
    2830:	0e 94 2f 14 	call	0x285e	; 0x285e <CO_collectSeismic1Channel_ext>
    2834:	4d b7       	in	r20, 0x3d	; 61
    2836:	5e b7       	in	r21, 0x3e	; 62
    2838:	4a 5f       	subi	r20, 0xFA	; 250
    283a:	5f 4f       	sbci	r21, 0xFF	; 255
    283c:	4d bf       	out	0x3d, r20	; 61
    283e:	5e bf       	out	0x3e, r21	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    2840:	60 96       	adiw	r28, 0x10	; 16
    2842:	cd bf       	out	0x3d, r28	; 61
    2844:	de bf       	out	0x3e, r29	; 62
    2846:	df 91       	pop	r29
    2848:	cf 91       	pop	r28
    284a:	0f 91       	pop	r16
    284c:	ff 90       	pop	r15
    284e:	ef 90       	pop	r14
    2850:	df 90       	pop	r13
    2852:	cf 90       	pop	r12
    2854:	bf 90       	pop	r11
    2856:	af 90       	pop	r10
    2858:	9f 90       	pop	r9
    285a:	8f 90       	pop	r8
    285c:	08 95       	ret

0000285e <CO_collectSeismic1Channel_ext>:

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    285e:	8f 92       	push	r8
    2860:	9f 92       	push	r9
    2862:	af 92       	push	r10
    2864:	bf 92       	push	r11
    2866:	cf 92       	push	r12
    2868:	df 92       	push	r13
    286a:	ef 92       	push	r14
    286c:	0f 93       	push	r16
    286e:	1f 93       	push	r17
    2870:	cf 93       	push	r28
    2872:	df 93       	push	r29
    2874:	cd b7       	in	r28, 0x3d	; 61
    2876:	de b7       	in	r29, 0x3e	; 62
    2878:	2d 97       	sbiw	r28, 0x0d	; 13
    287a:	cd bf       	out	0x3d, r28	; 61
    287c:	de bf       	out	0x3e, r29	; 62
    287e:	89 83       	std	Y+1, r24	; 0x01
    2880:	6a 83       	std	Y+2, r22	; 0x02
    2882:	4b 83       	std	Y+3, r20	; 0x03
    2884:	2c 83       	std	Y+4, r18	; 0x04
    2886:	3d 83       	std	Y+5, r19	; 0x05
    2888:	0e 83       	std	Y+6, r16	; 0x06
    288a:	ef 82       	std	Y+7, r14	; 0x07
    288c:	c8 86       	std	Y+8, r12	; 0x08
    288e:	d9 86       	std	Y+9, r13	; 0x09
    2890:	aa 86       	std	Y+10, r10	; 0x0a
    2892:	bb 86       	std	Y+11, r11	; 0x0b
    2894:	8c 86       	std	Y+12, r8	; 0x0c
    2896:	9d 86       	std	Y+13, r9	; 0x0d
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER=DataArray;
    2898:	88 a1       	lds	r24, 0x48
    289a:	99 a1       	lds	r25, 0x49
    289c:	80 93 6a 50 	sts	0x506A, r24
    28a0:	90 93 6b 50 	sts	0x506B, r25
	ADC_Sampling_Finished = 0;
    28a4:	10 92 c5 50 	sts	0x50C5, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    28a8:	81 e0       	ldi	r24, 0x01	; 1
    28aa:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    28ae:	89 81       	ldd	r24, Y+1	; 0x01
    28b0:	6b 81       	ldd	r22, Y+3	; 0x03
    28b2:	0e 94 8c 09 	call	0x1318	; 0x1318 <set_ampGain>
	set_filter(filterConfig);
    28b6:	8a 81       	ldd	r24, Y+2	; 0x02
    28b8:	0e 94 bb 0a 	call	0x1576	; 0x1576 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    28bc:	8f 81       	ldd	r24, Y+7	; 0x07
    28be:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    28c2:	84 e0       	ldi	r24, 0x04	; 4
    28c4:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    28c8:	80 ec       	ldi	r24, 0xC0	; 192
    28ca:	98 e0       	ldi	r25, 0x08	; 8
    28cc:	24 e5       	ldi	r18, 0x54	; 84
    28ce:	fc 01       	movw	r30, r24
    28d0:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    28d2:	81 e0       	ldi	r24, 0x01	; 1
    28d4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <enableADCMUX>
	setADCInput(channel);
    28d8:	89 81       	ldd	r24, Y+1	; 0x01
    28da:	0e 94 7a 1e 	call	0x3cf4	; 0x3cf4 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    28de:	80 ea       	ldi	r24, 0xA0	; 160
    28e0:	96 e0       	ldi	r25, 0x06	; 6
    28e2:	22 e0       	ldi	r18, 0x02	; 2
    28e4:	fc 01       	movw	r30, r24
    28e6:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    28e8:	80 ea       	ldi	r24, 0xA0	; 160
    28ea:	96 e0       	ldi	r25, 0x06	; 6
    28ec:	21 e0       	ldi	r18, 0x01	; 1
    28ee:	fc 01       	movw	r30, r24
    28f0:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    28f2:	80 e8       	ldi	r24, 0x80	; 128
    28f4:	91 e0       	ldi	r25, 0x01	; 1
    28f6:	28 e7       	ldi	r18, 0x78	; 120
    28f8:	fc 01       	movw	r30, r24
    28fa:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    28fc:	80 e0       	ldi	r24, 0x00	; 0
    28fe:	99 e0       	ldi	r25, 0x09	; 9
    2900:	20 ef       	ldi	r18, 0xF0	; 240
    2902:	fc 01       	movw	r30, r24
    2904:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    2906:	80 e0       	ldi	r24, 0x00	; 0
    2908:	99 e0       	ldi	r25, 0x09	; 9
    290a:	28 85       	ldd	r18, Y+8	; 0x08
    290c:	39 85       	ldd	r19, Y+9	; 0x09
    290e:	fc 01       	movw	r30, r24
    2910:	20 a7       	lds	r18, 0x70
    2912:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    2914:	80 e0       	ldi	r24, 0x00	; 0
    2916:	99 e0       	ldi	r25, 0x09	; 9
    2918:	2a 85       	ldd	r18, Y+10	; 0x0a
    291a:	3b 85       	ldd	r19, Y+11	; 0x0b
    291c:	fc 01       	movw	r30, r24
    291e:	22 a7       	lds	r18, 0x72
    2920:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    2922:	80 e0       	ldi	r24, 0x00	; 0
    2924:	99 e0       	ldi	r25, 0x09	; 9
    2926:	2c 85       	ldd	r18, Y+12	; 0x0c
    2928:	3d 85       	ldd	r19, Y+13	; 0x0d
    292a:	fc 01       	movw	r30, r24
    292c:	24 a7       	lds	r18, 0x74
    292e:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    2930:	80 e0       	ldi	r24, 0x00	; 0
    2932:	99 e0       	ldi	r25, 0x09	; 9
    2934:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2936:	3d 8d       	ldd	r19, Y+29	; 0x1d
    2938:	fc 01       	movw	r30, r24
    293a:	26 a7       	lds	r18, 0x76
    293c:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    293e:	80 e0       	ldi	r24, 0x00	; 0
    2940:	99 e0       	ldi	r25, 0x09	; 9
    2942:	2e 81       	ldd	r18, Y+6	; 0x06
    2944:	22 2f       	mov	r18, r18
    2946:	30 e0       	ldi	r19, 0x00	; 0
    2948:	21 50       	subi	r18, 0x01	; 1
    294a:	30 40       	sbci	r19, 0x00	; 0
    294c:	fc 01       	movw	r30, r24
    294e:	26 a3       	lds	r18, 0x56
    2950:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2952:	80 e0       	ldi	r24, 0x00	; 0
    2954:	99 e0       	ldi	r25, 0x09	; 9
    2956:	22 e0       	ldi	r18, 0x02	; 2
    2958:	fc 01       	movw	r30, r24
    295a:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    295c:	80 e0       	ldi	r24, 0x00	; 0
    295e:	99 e0       	ldi	r25, 0x09	; 9
    2960:	2f ef       	ldi	r18, 0xFF	; 255
    2962:	fc 01       	movw	r30, r24
    2964:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2966:	80 e0       	ldi	r24, 0x00	; 0
    2968:	99 e0       	ldi	r25, 0x09	; 9
    296a:	20 e0       	ldi	r18, 0x00	; 0
    296c:	39 e0       	ldi	r19, 0x09	; 9
    296e:	f9 01       	movw	r30, r18
    2970:	20 81       	ld	r18, Z
    2972:	20 7f       	andi	r18, 0xF0	; 240
    2974:	28 60       	ori	r18, 0x08	; 8
    2976:	fc 01       	movw	r30, r24
    2978:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    297a:	10 92 6c 50 	sts	0x506C, r1
    297e:	10 92 6d 50 	sts	0x506D, r1
    2982:	10 92 6e 50 	sts	0x506E, r1
    2986:	10 92 6f 50 	sts	0x506F, r1
	SPICount = 0;
    298a:	10 92 be 50 	sts	0x50BE, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    298e:	80 ea       	ldi	r24, 0xA0	; 160
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	20 ea       	ldi	r18, 0xA0	; 160
    2994:	30 e0       	ldi	r19, 0x00	; 0
    2996:	f9 01       	movw	r30, r18
    2998:	22 81       	ldd	r18, Z+2	; 0x02
    299a:	27 60       	ori	r18, 0x07	; 7
    299c:	fc 01       	movw	r30, r24
    299e:	22 83       	std	Z+2, r18	; 0x02
	sei();
    29a0:	78 94       	sei

	SPICS(TRUE);
    29a2:	81 e0       	ldi	r24, 0x01	; 1
    29a4:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    29a8:	80 e8       	ldi	r24, 0x80	; 128
    29aa:	96 e0       	ldi	r25, 0x06	; 6
    29ac:	20 e2       	ldi	r18, 0x20	; 32
    29ae:	fc 01       	movw	r30, r24
    29b0:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    29b2:	80 e4       	ldi	r24, 0x40	; 64
    29b4:	9a e0       	ldi	r25, 0x0A	; 10
    29b6:	23 e2       	ldi	r18, 0x23	; 35
    29b8:	fc 01       	movw	r30, r24
    29ba:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    29bc:	00 e4       	ldi	r16, 0x40	; 64
    29be:	1a e0       	ldi	r17, 0x0A	; 10
    29c0:	8c 81       	ldd	r24, Y+4	; 0x04
    29c2:	9d 81       	ldd	r25, Y+5	; 0x05
    29c4:	9c 01       	movw	r18, r24
    29c6:	40 e0       	ldi	r20, 0x00	; 0
    29c8:	50 e0       	ldi	r21, 0x00	; 0
    29ca:	80 e8       	ldi	r24, 0x80	; 128
    29cc:	94 e8       	ldi	r25, 0x84	; 132
    29ce:	ae e1       	ldi	r26, 0x1E	; 30
    29d0:	b0 e0       	ldi	r27, 0x00	; 0
    29d2:	bc 01       	movw	r22, r24
    29d4:	cd 01       	movw	r24, r26
    29d6:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    29da:	da 01       	movw	r26, r20
    29dc:	c9 01       	movw	r24, r18
    29de:	f8 01       	movw	r30, r16
    29e0:	86 a3       	lds	r24, 0x56
    29e2:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    29e4:	00 e4       	ldi	r16, 0x40	; 64
    29e6:	1a e0       	ldi	r17, 0x0A	; 10
    29e8:	8c 81       	ldd	r24, Y+4	; 0x04
    29ea:	9d 81       	ldd	r25, Y+5	; 0x05
    29ec:	9c 01       	movw	r18, r24
    29ee:	40 e0       	ldi	r20, 0x00	; 0
    29f0:	50 e0       	ldi	r21, 0x00	; 0
    29f2:	80 e4       	ldi	r24, 0x40	; 64
    29f4:	92 e4       	ldi	r25, 0x42	; 66
    29f6:	af e0       	ldi	r26, 0x0F	; 15
    29f8:	b0 e0       	ldi	r27, 0x00	; 0
    29fa:	bc 01       	movw	r22, r24
    29fc:	cd 01       	movw	r24, r26
    29fe:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    2a02:	da 01       	movw	r26, r20
    2a04:	c9 01       	movw	r24, r18
    2a06:	f8 01       	movw	r30, r16
    2a08:	82 af       	sts	0x72, r24
    2a0a:	93 af       	sts	0x73, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2a0c:	80 e4       	ldi	r24, 0x40	; 64
    2a0e:	98 e0       	ldi	r25, 0x08	; 8
    2a10:	2e 8d       	ldd	r18, Y+30	; 0x1e
    2a12:	3f 8d       	ldd	r19, Y+31	; 0x1f
    2a14:	fc 01       	movw	r30, r24
    2a16:	26 a3       	lds	r18, 0x56
    2a18:	37 a3       	lds	r19, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2a1a:	80 e8       	ldi	r24, 0x80	; 128
    2a1c:	91 e0       	ldi	r25, 0x01	; 1
    2a1e:	20 ed       	ldi	r18, 0xD0	; 208
    2a20:	fc 01       	movw	r30, r24
    2a22:	21 83       	std	Z+1, r18	; 0x01
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2a24:	80 e4       	ldi	r24, 0x40	; 64
    2a26:	98 e0       	ldi	r25, 0x08	; 8
    2a28:	21 e0       	ldi	r18, 0x01	; 1
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	26 83       	std	Z+6, r18	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2a2e:	80 e4       	ldi	r24, 0x40	; 64
    2a30:	98 e0       	ldi	r25, 0x08	; 8
    2a32:	20 e4       	ldi	r18, 0x40	; 64
    2a34:	38 e0       	ldi	r19, 0x08	; 8
    2a36:	f9 01       	movw	r30, r18
    2a38:	20 81       	ld	r18, Z
    2a3a:	20 7f       	andi	r18, 0xF0	; 240
    2a3c:	29 60       	ori	r18, 0x09	; 9
    2a3e:	fc 01       	movw	r30, r24
    2a40:	20 83       	st	Z, r18
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2a42:	80 e4       	ldi	r24, 0x40	; 64
    2a44:	9a e0       	ldi	r25, 0x0A	; 10
    2a46:	20 e4       	ldi	r18, 0x40	; 64
    2a48:	3a e0       	ldi	r19, 0x0A	; 10
    2a4a:	f9 01       	movw	r30, r18
    2a4c:	20 81       	ld	r18, Z
    2a4e:	20 7f       	andi	r18, 0xF0	; 240
    2a50:	21 60       	ori	r18, 0x01	; 1
    2a52:	fc 01       	movw	r30, r24
    2a54:	20 83       	st	Z, r18
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2a56:	2d 96       	adiw	r28, 0x0d	; 13
    2a58:	cd bf       	out	0x3d, r28	; 61
    2a5a:	de bf       	out	0x3e, r29	; 62
    2a5c:	df 91       	pop	r29
    2a5e:	cf 91       	pop	r28
    2a60:	1f 91       	pop	r17
    2a62:	0f 91       	pop	r16
    2a64:	ef 90       	pop	r14
    2a66:	df 90       	pop	r13
    2a68:	cf 90       	pop	r12
    2a6a:	bf 90       	pop	r11
    2a6c:	af 90       	pop	r10
    2a6e:	9f 90       	pop	r9
    2a70:	8f 90       	pop	r8
    2a72:	08 95       	ret

00002a74 <__vector_79>:

//first averaging point
ISR(TCD0_CCA_vect) {
    2a74:	1f 92       	push	r1
    2a76:	0f 92       	push	r0
    2a78:	0f b6       	in	r0, 0x3f	; 63
    2a7a:	0f 92       	push	r0
    2a7c:	00 90 3b 00 	lds	r0, 0x003B
    2a80:	0f 92       	push	r0
    2a82:	11 24       	eor	r1, r1
    2a84:	2f 93       	push	r18
    2a86:	3f 93       	push	r19
    2a88:	4f 93       	push	r20
    2a8a:	5f 93       	push	r21
    2a8c:	6f 93       	push	r22
    2a8e:	7f 93       	push	r23
    2a90:	8f 93       	push	r24
    2a92:	9f 93       	push	r25
    2a94:	af 93       	push	r26
    2a96:	bf 93       	push	r27
    2a98:	ef 93       	push	r30
    2a9a:	ff 93       	push	r31
    2a9c:	cf 93       	push	r28
    2a9e:	df 93       	push	r29
    2aa0:	cd b7       	in	r28, 0x3d	; 61
    2aa2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2aa4:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
}
    2aa8:	df 91       	pop	r29
    2aaa:	cf 91       	pop	r28
    2aac:	ff 91       	pop	r31
    2aae:	ef 91       	pop	r30
    2ab0:	bf 91       	pop	r27
    2ab2:	af 91       	pop	r26
    2ab4:	9f 91       	pop	r25
    2ab6:	8f 91       	pop	r24
    2ab8:	7f 91       	pop	r23
    2aba:	6f 91       	pop	r22
    2abc:	5f 91       	pop	r21
    2abe:	4f 91       	pop	r20
    2ac0:	3f 91       	pop	r19
    2ac2:	2f 91       	pop	r18
    2ac4:	0f 90       	pop	r0
    2ac6:	00 92 3b 00 	sts	0x003B, r0
    2aca:	0f 90       	pop	r0
    2acc:	0f be       	out	0x3f, r0	; 63
    2ace:	0f 90       	pop	r0
    2ad0:	1f 90       	pop	r1
    2ad2:	18 95       	reti

00002ad4 <__vector_80>:
//second averaging point
ISR(TCD0_CCB_vect) {
    2ad4:	1f 92       	push	r1
    2ad6:	0f 92       	push	r0
    2ad8:	0f b6       	in	r0, 0x3f	; 63
    2ada:	0f 92       	push	r0
    2adc:	00 90 3b 00 	lds	r0, 0x003B
    2ae0:	0f 92       	push	r0
    2ae2:	11 24       	eor	r1, r1
    2ae4:	2f 93       	push	r18
    2ae6:	3f 93       	push	r19
    2ae8:	4f 93       	push	r20
    2aea:	5f 93       	push	r21
    2aec:	6f 93       	push	r22
    2aee:	7f 93       	push	r23
    2af0:	8f 93       	push	r24
    2af2:	9f 93       	push	r25
    2af4:	af 93       	push	r26
    2af6:	bf 93       	push	r27
    2af8:	ef 93       	push	r30
    2afa:	ff 93       	push	r31
    2afc:	cf 93       	push	r28
    2afe:	df 93       	push	r29
    2b00:	cd b7       	in	r28, 0x3d	; 61
    2b02:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2b04:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
}
    2b08:	df 91       	pop	r29
    2b0a:	cf 91       	pop	r28
    2b0c:	ff 91       	pop	r31
    2b0e:	ef 91       	pop	r30
    2b10:	bf 91       	pop	r27
    2b12:	af 91       	pop	r26
    2b14:	9f 91       	pop	r25
    2b16:	8f 91       	pop	r24
    2b18:	7f 91       	pop	r23
    2b1a:	6f 91       	pop	r22
    2b1c:	5f 91       	pop	r21
    2b1e:	4f 91       	pop	r20
    2b20:	3f 91       	pop	r19
    2b22:	2f 91       	pop	r18
    2b24:	0f 90       	pop	r0
    2b26:	00 92 3b 00 	sts	0x003B, r0
    2b2a:	0f 90       	pop	r0
    2b2c:	0f be       	out	0x3f, r0	; 63
    2b2e:	0f 90       	pop	r0
    2b30:	1f 90       	pop	r1
    2b32:	18 95       	reti

00002b34 <__vector_81>:

//third averaging point
ISR(TCD0_CCC_vect) {
    2b34:	1f 92       	push	r1
    2b36:	0f 92       	push	r0
    2b38:	0f b6       	in	r0, 0x3f	; 63
    2b3a:	0f 92       	push	r0
    2b3c:	00 90 3b 00 	lds	r0, 0x003B
    2b40:	0f 92       	push	r0
    2b42:	11 24       	eor	r1, r1
    2b44:	2f 93       	push	r18
    2b46:	3f 93       	push	r19
    2b48:	4f 93       	push	r20
    2b4a:	5f 93       	push	r21
    2b4c:	6f 93       	push	r22
    2b4e:	7f 93       	push	r23
    2b50:	8f 93       	push	r24
    2b52:	9f 93       	push	r25
    2b54:	af 93       	push	r26
    2b56:	bf 93       	push	r27
    2b58:	ef 93       	push	r30
    2b5a:	ff 93       	push	r31
    2b5c:	cf 93       	push	r28
    2b5e:	df 93       	push	r29
    2b60:	cd b7       	in	r28, 0x3d	; 61
    2b62:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2b64:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
}
    2b68:	df 91       	pop	r29
    2b6a:	cf 91       	pop	r28
    2b6c:	ff 91       	pop	r31
    2b6e:	ef 91       	pop	r30
    2b70:	bf 91       	pop	r27
    2b72:	af 91       	pop	r26
    2b74:	9f 91       	pop	r25
    2b76:	8f 91       	pop	r24
    2b78:	7f 91       	pop	r23
    2b7a:	6f 91       	pop	r22
    2b7c:	5f 91       	pop	r21
    2b7e:	4f 91       	pop	r20
    2b80:	3f 91       	pop	r19
    2b82:	2f 91       	pop	r18
    2b84:	0f 90       	pop	r0
    2b86:	00 92 3b 00 	sts	0x003B, r0
    2b8a:	0f 90       	pop	r0
    2b8c:	0f be       	out	0x3f, r0	; 63
    2b8e:	0f 90       	pop	r0
    2b90:	1f 90       	pop	r1
    2b92:	18 95       	reti

00002b94 <__vector_82>:

//final averaging point
ISR(TCD0_CCD_vect) {
    2b94:	1f 92       	push	r1
    2b96:	0f 92       	push	r0
    2b98:	0f b6       	in	r0, 0x3f	; 63
    2b9a:	0f 92       	push	r0
    2b9c:	00 90 3b 00 	lds	r0, 0x003B
    2ba0:	0f 92       	push	r0
    2ba2:	11 24       	eor	r1, r1
    2ba4:	2f 93       	push	r18
    2ba6:	3f 93       	push	r19
    2ba8:	4f 93       	push	r20
    2baa:	5f 93       	push	r21
    2bac:	6f 93       	push	r22
    2bae:	7f 93       	push	r23
    2bb0:	8f 93       	push	r24
    2bb2:	9f 93       	push	r25
    2bb4:	af 93       	push	r26
    2bb6:	bf 93       	push	r27
    2bb8:	ef 93       	push	r30
    2bba:	ff 93       	push	r31
    2bbc:	cf 93       	push	r28
    2bbe:	df 93       	push	r29
    2bc0:	cd b7       	in	r28, 0x3d	; 61
    2bc2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2bc4:	0e 94 86 18 	call	0x310c	; 0x310c <sampleCurrentChannel>
	SPICount = 0;
    2bc8:	10 92 be 50 	sts	0x50BE, r1
}
    2bcc:	df 91       	pop	r29
    2bce:	cf 91       	pop	r28
    2bd0:	ff 91       	pop	r31
    2bd2:	ef 91       	pop	r30
    2bd4:	bf 91       	pop	r27
    2bd6:	af 91       	pop	r26
    2bd8:	9f 91       	pop	r25
    2bda:	8f 91       	pop	r24
    2bdc:	7f 91       	pop	r23
    2bde:	6f 91       	pop	r22
    2be0:	5f 91       	pop	r21
    2be2:	4f 91       	pop	r20
    2be4:	3f 91       	pop	r19
    2be6:	2f 91       	pop	r18
    2be8:	0f 90       	pop	r0
    2bea:	00 92 3b 00 	sts	0x003B, r0
    2bee:	0f 90       	pop	r0
    2bf0:	0f be       	out	0x3f, r0	; 63
    2bf2:	0f 90       	pop	r0
    2bf4:	1f 90       	pop	r1
    2bf6:	18 95       	reti

00002bf8 <__vector_77>:

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2bf8:	1f 92       	push	r1
    2bfa:	0f 92       	push	r0
    2bfc:	0f b6       	in	r0, 0x3f	; 63
    2bfe:	0f 92       	push	r0
    2c00:	00 90 3b 00 	lds	r0, 0x003B
    2c04:	0f 92       	push	r0
    2c06:	11 24       	eor	r1, r1
    2c08:	2f 92       	push	r2
    2c0a:	3f 92       	push	r3
    2c0c:	4f 92       	push	r4
    2c0e:	5f 92       	push	r5
    2c10:	6f 92       	push	r6
    2c12:	7f 92       	push	r7
    2c14:	8f 92       	push	r8
    2c16:	9f 92       	push	r9
    2c18:	af 92       	push	r10
    2c1a:	bf 92       	push	r11
    2c1c:	cf 92       	push	r12
    2c1e:	df 92       	push	r13
    2c20:	ef 92       	push	r14
    2c22:	ff 92       	push	r15
    2c24:	0f 93       	push	r16
    2c26:	1f 93       	push	r17
    2c28:	2f 93       	push	r18
    2c2a:	3f 93       	push	r19
    2c2c:	4f 93       	push	r20
    2c2e:	5f 93       	push	r21
    2c30:	6f 93       	push	r22
    2c32:	7f 93       	push	r23
    2c34:	8f 93       	push	r24
    2c36:	9f 93       	push	r25
    2c38:	af 93       	push	r26
    2c3a:	bf 93       	push	r27
    2c3c:	ef 93       	push	r30
    2c3e:	ff 93       	push	r31
    2c40:	cf 93       	push	r28
    2c42:	df 93       	push	r29
    2c44:	cd b7       	in	r28, 0x3d	; 61
    2c46:	de b7       	in	r29, 0x3e	; 62
    2c48:	2f 97       	sbiw	r28, 0x0f	; 15
    2c4a:	cd bf       	out	0x3d, r28	; 61
    2c4c:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    2c4e:	1a 82       	std	Y+2, r1	; 0x02
    2c50:	1b 82       	std	Y+3, r1	; 0x03
    2c52:	1c 82       	std	Y+4, r1	; 0x04
    2c54:	1d 82       	std	Y+5, r1	; 0x05
    2c56:	1e 82       	std	Y+6, r1	; 0x06
    2c58:	1f 82       	std	Y+7, r1	; 0x07
    2c5a:	18 86       	std	Y+8, r1	; 0x08
    2c5c:	19 86       	std	Y+9, r1	; 0x09
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2c5e:	19 82       	std	Y+1, r1	; 0x01
    2c60:	bd c0       	rjmp	.+378    	; 0x2ddc <__vector_77+0x1e4>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2c62:	89 81       	ldd	r24, Y+1	; 0x01
    2c64:	88 2f       	mov	r24, r24
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	83 5a       	subi	r24, 0xA3	; 163
    2c6a:	9f 4a       	sbci	r25, 0xAF	; 175
    2c6c:	fc 01       	movw	r30, r24
    2c6e:	80 81       	ld	r24, Z
    2c70:	88 23       	and	r24, r24
    2c72:	3c f4       	brge	.+14     	; 0x2c82 <__vector_77+0x8a>
    2c74:	ce 01       	movw	r24, r28
    2c76:	0a 96       	adiw	r24, 0x0a	; 10
    2c78:	03 96       	adiw	r24, 0x03	; 3
    2c7a:	2f ef       	ldi	r18, 0xFF	; 255
    2c7c:	fc 01       	movw	r30, r24
    2c7e:	20 83       	st	Z, r18
    2c80:	05 c0       	rjmp	.+10     	; 0x2c8c <__vector_77+0x94>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2c82:	ce 01       	movw	r24, r28
    2c84:	0a 96       	adiw	r24, 0x0a	; 10
    2c86:	03 96       	adiw	r24, 0x03	; 3
    2c88:	fc 01       	movw	r30, r24
    2c8a:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2c8c:	ce 01       	movw	r24, r28
    2c8e:	0a 96       	adiw	r24, 0x0a	; 10
    2c90:	02 96       	adiw	r24, 0x02	; 2
    2c92:	29 81       	ldd	r18, Y+1	; 0x01
    2c94:	22 2f       	mov	r18, r18
    2c96:	30 e0       	ldi	r19, 0x00	; 0
    2c98:	23 5a       	subi	r18, 0xA3	; 163
    2c9a:	3f 4a       	sbci	r19, 0xAF	; 175
    2c9c:	f9 01       	movw	r30, r18
    2c9e:	20 81       	ld	r18, Z
    2ca0:	fc 01       	movw	r30, r24
    2ca2:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2ca4:	ce 01       	movw	r24, r28
    2ca6:	0a 96       	adiw	r24, 0x0a	; 10
    2ca8:	01 96       	adiw	r24, 0x01	; 1
    2caa:	29 81       	ldd	r18, Y+1	; 0x01
    2cac:	22 2f       	mov	r18, r18
    2cae:	30 e0       	ldi	r19, 0x00	; 0
    2cb0:	2f 5f       	subi	r18, 0xFF	; 255
    2cb2:	3f 4f       	sbci	r19, 0xFF	; 255
    2cb4:	23 5a       	subi	r18, 0xA3	; 163
    2cb6:	3f 4a       	sbci	r19, 0xAF	; 175
    2cb8:	f9 01       	movw	r30, r18
    2cba:	20 81       	ld	r18, Z
    2cbc:	fc 01       	movw	r30, r24
    2cbe:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2cc0:	ce 01       	movw	r24, r28
    2cc2:	0a 96       	adiw	r24, 0x0a	; 10
    2cc4:	29 81       	ldd	r18, Y+1	; 0x01
    2cc6:	22 2f       	mov	r18, r18
    2cc8:	30 e0       	ldi	r19, 0x00	; 0
    2cca:	2e 5f       	subi	r18, 0xFE	; 254
    2ccc:	3f 4f       	sbci	r19, 0xFF	; 255
    2cce:	23 5a       	subi	r18, 0xA3	; 163
    2cd0:	3f 4a       	sbci	r19, 0xAF	; 175
    2cd2:	f9 01       	movw	r30, r18
    2cd4:	20 81       	ld	r18, Z
    2cd6:	fc 01       	movw	r30, r24
    2cd8:	20 83       	st	Z, r18
		sum += currentSample;
    2cda:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cdc:	9b 85       	ldd	r25, Y+11	; 0x0b
    2cde:	ac 85       	ldd	r26, Y+12	; 0x0c
    2ce0:	bd 85       	ldd	r27, Y+13	; 0x0d
    2ce2:	5c 01       	movw	r10, r24
    2ce4:	6d 01       	movw	r12, r26
    2ce6:	bb 0f       	add	r27, r27
    2ce8:	88 0b       	sbc	r24, r24
    2cea:	98 2f       	mov	r25, r24
    2cec:	dc 01       	movw	r26, r24
    2cee:	e8 2e       	mov	r14, r24
    2cf0:	f8 2e       	mov	r15, r24
    2cf2:	08 2f       	mov	r16, r24
    2cf4:	18 2f       	mov	r17, r24
    2cf6:	2a 80       	ldd	r2, Y+2	; 0x02
    2cf8:	3b 80       	ldd	r3, Y+3	; 0x03
    2cfa:	4c 80       	ldd	r4, Y+4	; 0x04
    2cfc:	5d 80       	ldd	r5, Y+5	; 0x05
    2cfe:	6e 80       	ldd	r6, Y+6	; 0x06
    2d00:	7f 80       	ldd	r7, Y+7	; 0x07
    2d02:	88 84       	ldd	r8, Y+8	; 0x08
    2d04:	99 84       	ldd	r9, Y+9	; 0x09
    2d06:	2a 2d       	mov	r18, r10
    2d08:	22 0d       	add	r18, r2
    2d0a:	e1 e0       	ldi	r30, 0x01	; 1
    2d0c:	2a 15       	cp	r18, r10
    2d0e:	08 f0       	brcs	.+2      	; 0x2d12 <__vector_77+0x11a>
    2d10:	e0 e0       	ldi	r30, 0x00	; 0
    2d12:	3b 2d       	mov	r19, r11
    2d14:	33 0d       	add	r19, r3
    2d16:	f1 e0       	ldi	r31, 0x01	; 1
    2d18:	3b 15       	cp	r19, r11
    2d1a:	08 f0       	brcs	.+2      	; 0x2d1e <__vector_77+0x126>
    2d1c:	f0 e0       	ldi	r31, 0x00	; 0
    2d1e:	e3 0f       	add	r30, r19
    2d20:	a1 e0       	ldi	r26, 0x01	; 1
    2d22:	e3 17       	cp	r30, r19
    2d24:	08 f0       	brcs	.+2      	; 0x2d28 <__vector_77+0x130>
    2d26:	a0 e0       	ldi	r26, 0x00	; 0
    2d28:	fa 2b       	or	r31, r26
    2d2a:	3e 2f       	mov	r19, r30
    2d2c:	4c 2d       	mov	r20, r12
    2d2e:	44 0d       	add	r20, r4
    2d30:	e1 e0       	ldi	r30, 0x01	; 1
    2d32:	4c 15       	cp	r20, r12
    2d34:	08 f0       	brcs	.+2      	; 0x2d38 <__vector_77+0x140>
    2d36:	e0 e0       	ldi	r30, 0x00	; 0
    2d38:	f4 0f       	add	r31, r20
    2d3a:	a1 e0       	ldi	r26, 0x01	; 1
    2d3c:	f4 17       	cp	r31, r20
    2d3e:	08 f0       	brcs	.+2      	; 0x2d42 <__vector_77+0x14a>
    2d40:	a0 e0       	ldi	r26, 0x00	; 0
    2d42:	ea 2b       	or	r30, r26
    2d44:	4f 2f       	mov	r20, r31
    2d46:	5d 2d       	mov	r21, r13
    2d48:	55 0d       	add	r21, r5
    2d4a:	f1 e0       	ldi	r31, 0x01	; 1
    2d4c:	5d 15       	cp	r21, r13
    2d4e:	08 f0       	brcs	.+2      	; 0x2d52 <__vector_77+0x15a>
    2d50:	f0 e0       	ldi	r31, 0x00	; 0
    2d52:	e5 0f       	add	r30, r21
    2d54:	a1 e0       	ldi	r26, 0x01	; 1
    2d56:	e5 17       	cp	r30, r21
    2d58:	08 f0       	brcs	.+2      	; 0x2d5c <__vector_77+0x164>
    2d5a:	a0 e0       	ldi	r26, 0x00	; 0
    2d5c:	fa 2b       	or	r31, r26
    2d5e:	5e 2f       	mov	r21, r30
    2d60:	6e 2d       	mov	r22, r14
    2d62:	66 0d       	add	r22, r6
    2d64:	e1 e0       	ldi	r30, 0x01	; 1
    2d66:	6e 15       	cp	r22, r14
    2d68:	08 f0       	brcs	.+2      	; 0x2d6c <__vector_77+0x174>
    2d6a:	e0 e0       	ldi	r30, 0x00	; 0
    2d6c:	f6 0f       	add	r31, r22
    2d6e:	a1 e0       	ldi	r26, 0x01	; 1
    2d70:	f6 17       	cp	r31, r22
    2d72:	08 f0       	brcs	.+2      	; 0x2d76 <__vector_77+0x17e>
    2d74:	a0 e0       	ldi	r26, 0x00	; 0
    2d76:	ea 2b       	or	r30, r26
    2d78:	6f 2f       	mov	r22, r31
    2d7a:	7f 2d       	mov	r23, r15
    2d7c:	77 0d       	add	r23, r7
    2d7e:	f1 e0       	ldi	r31, 0x01	; 1
    2d80:	7f 15       	cp	r23, r15
    2d82:	08 f0       	brcs	.+2      	; 0x2d86 <__vector_77+0x18e>
    2d84:	f0 e0       	ldi	r31, 0x00	; 0
    2d86:	e7 0f       	add	r30, r23
    2d88:	a1 e0       	ldi	r26, 0x01	; 1
    2d8a:	e7 17       	cp	r30, r23
    2d8c:	08 f0       	brcs	.+2      	; 0x2d90 <__vector_77+0x198>
    2d8e:	a0 e0       	ldi	r26, 0x00	; 0
    2d90:	fa 2b       	or	r31, r26
    2d92:	7e 2f       	mov	r23, r30
    2d94:	80 2f       	mov	r24, r16
    2d96:	88 0d       	add	r24, r8
    2d98:	e1 e0       	ldi	r30, 0x01	; 1
    2d9a:	80 17       	cp	r24, r16
    2d9c:	08 f0       	brcs	.+2      	; 0x2da0 <__vector_77+0x1a8>
    2d9e:	e0 e0       	ldi	r30, 0x00	; 0
    2da0:	f8 0f       	add	r31, r24
    2da2:	a1 e0       	ldi	r26, 0x01	; 1
    2da4:	f8 17       	cp	r31, r24
    2da6:	08 f0       	brcs	.+2      	; 0x2daa <__vector_77+0x1b2>
    2da8:	a0 e0       	ldi	r26, 0x00	; 0
    2daa:	ea 2b       	or	r30, r26
    2dac:	8f 2f       	mov	r24, r31
    2dae:	91 2f       	mov	r25, r17
    2db0:	99 0d       	add	r25, r9
    2db2:	e9 0f       	add	r30, r25
    2db4:	9e 2f       	mov	r25, r30
    2db6:	22 2e       	mov	r2, r18
    2db8:	33 2e       	mov	r3, r19
    2dba:	44 2e       	mov	r4, r20
    2dbc:	55 2e       	mov	r5, r21
    2dbe:	66 2e       	mov	r6, r22
    2dc0:	77 2e       	mov	r7, r23
    2dc2:	88 2e       	mov	r8, r24
    2dc4:	99 2e       	mov	r9, r25
    2dc6:	2a 82       	std	Y+2, r2	; 0x02
    2dc8:	3b 82       	std	Y+3, r3	; 0x03
    2dca:	4c 82       	std	Y+4, r4	; 0x04
    2dcc:	5d 82       	std	Y+5, r5	; 0x05
    2dce:	6e 82       	std	Y+6, r6	; 0x06
    2dd0:	7f 82       	std	Y+7, r7	; 0x07
    2dd2:	88 86       	std	Y+8, r8	; 0x08
    2dd4:	99 86       	std	Y+9, r9	; 0x09
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2dd6:	89 81       	ldd	r24, Y+1	; 0x01
    2dd8:	8d 5f       	subi	r24, 0xFD	; 253
    2dda:	89 83       	std	Y+1, r24	; 0x01
    2ddc:	89 81       	ldd	r24, Y+1	; 0x01
    2dde:	8c 30       	cpi	r24, 0x0C	; 12
    2de0:	08 f4       	brcc	.+2      	; 0x2de4 <__vector_77+0x1ec>
    2de2:	3f cf       	rjmp	.-386    	; 0x2c62 <__vector_77+0x6a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    2de4:	2a 81       	ldd	r18, Y+2	; 0x02
    2de6:	3b 81       	ldd	r19, Y+3	; 0x03
    2de8:	4c 81       	ldd	r20, Y+4	; 0x04
    2dea:	5d 81       	ldd	r21, Y+5	; 0x05
    2dec:	6e 81       	ldd	r22, Y+6	; 0x06
    2dee:	7f 81       	ldd	r23, Y+7	; 0x07
    2df0:	88 85       	ldd	r24, Y+8	; 0x08
    2df2:	99 85       	ldd	r25, Y+9	; 0x09
    2df4:	a2 2e       	mov	r10, r18
    2df6:	b3 2e       	mov	r11, r19
    2df8:	c4 2e       	mov	r12, r20
    2dfa:	d5 2e       	mov	r13, r21
    2dfc:	e6 2e       	mov	r14, r22
    2dfe:	f7 2e       	mov	r15, r23
    2e00:	08 2f       	mov	r16, r24
    2e02:	19 2f       	mov	r17, r25
    2e04:	11 23       	and	r17, r17
    2e06:	0c f0       	brlt	.+2      	; 0x2e0a <__vector_77+0x212>
    2e08:	6b c0       	rjmp	.+214    	; 0x2ee0 <__vector_77+0x2e8>
    2e0a:	0f 2e       	mov	r0, r31
    2e0c:	f3 e0       	ldi	r31, 0x03	; 3
    2e0e:	2f 2e       	mov	r2, r31
    2e10:	f0 2d       	mov	r31, r0
    2e12:	33 24       	eor	r3, r3
    2e14:	44 24       	eor	r4, r4
    2e16:	55 24       	eor	r5, r5
    2e18:	66 24       	eor	r6, r6
    2e1a:	77 24       	eor	r7, r7
    2e1c:	88 24       	eor	r8, r8
    2e1e:	99 24       	eor	r9, r9
    2e20:	2a 2d       	mov	r18, r10
    2e22:	22 0d       	add	r18, r2
    2e24:	e1 e0       	ldi	r30, 0x01	; 1
    2e26:	2a 15       	cp	r18, r10
    2e28:	08 f0       	brcs	.+2      	; 0x2e2c <__vector_77+0x234>
    2e2a:	e0 e0       	ldi	r30, 0x00	; 0
    2e2c:	3b 2d       	mov	r19, r11
    2e2e:	33 0d       	add	r19, r3
    2e30:	f1 e0       	ldi	r31, 0x01	; 1
    2e32:	3b 15       	cp	r19, r11
    2e34:	08 f0       	brcs	.+2      	; 0x2e38 <__vector_77+0x240>
    2e36:	f0 e0       	ldi	r31, 0x00	; 0
    2e38:	e3 0f       	add	r30, r19
    2e3a:	a1 e0       	ldi	r26, 0x01	; 1
    2e3c:	e3 17       	cp	r30, r19
    2e3e:	08 f0       	brcs	.+2      	; 0x2e42 <__vector_77+0x24a>
    2e40:	a0 e0       	ldi	r26, 0x00	; 0
    2e42:	fa 2b       	or	r31, r26
    2e44:	3e 2f       	mov	r19, r30
    2e46:	4c 2d       	mov	r20, r12
    2e48:	44 0d       	add	r20, r4
    2e4a:	e1 e0       	ldi	r30, 0x01	; 1
    2e4c:	4c 15       	cp	r20, r12
    2e4e:	08 f0       	brcs	.+2      	; 0x2e52 <__vector_77+0x25a>
    2e50:	e0 e0       	ldi	r30, 0x00	; 0
    2e52:	f4 0f       	add	r31, r20
    2e54:	a1 e0       	ldi	r26, 0x01	; 1
    2e56:	f4 17       	cp	r31, r20
    2e58:	08 f0       	brcs	.+2      	; 0x2e5c <__vector_77+0x264>
    2e5a:	a0 e0       	ldi	r26, 0x00	; 0
    2e5c:	ea 2b       	or	r30, r26
    2e5e:	4f 2f       	mov	r20, r31
    2e60:	5d 2d       	mov	r21, r13
    2e62:	55 0d       	add	r21, r5
    2e64:	f1 e0       	ldi	r31, 0x01	; 1
    2e66:	5d 15       	cp	r21, r13
    2e68:	08 f0       	brcs	.+2      	; 0x2e6c <__vector_77+0x274>
    2e6a:	f0 e0       	ldi	r31, 0x00	; 0
    2e6c:	e5 0f       	add	r30, r21
    2e6e:	a1 e0       	ldi	r26, 0x01	; 1
    2e70:	e5 17       	cp	r30, r21
    2e72:	08 f0       	brcs	.+2      	; 0x2e76 <__vector_77+0x27e>
    2e74:	a0 e0       	ldi	r26, 0x00	; 0
    2e76:	fa 2b       	or	r31, r26
    2e78:	5e 2f       	mov	r21, r30
    2e7a:	6e 2d       	mov	r22, r14
    2e7c:	66 0d       	add	r22, r6
    2e7e:	e1 e0       	ldi	r30, 0x01	; 1
    2e80:	6e 15       	cp	r22, r14
    2e82:	08 f0       	brcs	.+2      	; 0x2e86 <__vector_77+0x28e>
    2e84:	e0 e0       	ldi	r30, 0x00	; 0
    2e86:	f6 0f       	add	r31, r22
    2e88:	a1 e0       	ldi	r26, 0x01	; 1
    2e8a:	f6 17       	cp	r31, r22
    2e8c:	08 f0       	brcs	.+2      	; 0x2e90 <__vector_77+0x298>
    2e8e:	a0 e0       	ldi	r26, 0x00	; 0
    2e90:	ea 2b       	or	r30, r26
    2e92:	6f 2f       	mov	r22, r31
    2e94:	7f 2d       	mov	r23, r15
    2e96:	77 0d       	add	r23, r7
    2e98:	f1 e0       	ldi	r31, 0x01	; 1
    2e9a:	7f 15       	cp	r23, r15
    2e9c:	08 f0       	brcs	.+2      	; 0x2ea0 <__vector_77+0x2a8>
    2e9e:	f0 e0       	ldi	r31, 0x00	; 0
    2ea0:	e7 0f       	add	r30, r23
    2ea2:	a1 e0       	ldi	r26, 0x01	; 1
    2ea4:	e7 17       	cp	r30, r23
    2ea6:	08 f0       	brcs	.+2      	; 0x2eaa <__vector_77+0x2b2>
    2ea8:	a0 e0       	ldi	r26, 0x00	; 0
    2eaa:	fa 2b       	or	r31, r26
    2eac:	7e 2f       	mov	r23, r30
    2eae:	80 2f       	mov	r24, r16
    2eb0:	88 0d       	add	r24, r8
    2eb2:	e1 e0       	ldi	r30, 0x01	; 1
    2eb4:	80 17       	cp	r24, r16
    2eb6:	08 f0       	brcs	.+2      	; 0x2eba <__vector_77+0x2c2>
    2eb8:	e0 e0       	ldi	r30, 0x00	; 0
    2eba:	f8 0f       	add	r31, r24
    2ebc:	a1 e0       	ldi	r26, 0x01	; 1
    2ebe:	f8 17       	cp	r31, r24
    2ec0:	08 f0       	brcs	.+2      	; 0x2ec4 <__vector_77+0x2cc>
    2ec2:	a0 e0       	ldi	r26, 0x00	; 0
    2ec4:	ea 2b       	or	r30, r26
    2ec6:	8f 2f       	mov	r24, r31
    2ec8:	91 2f       	mov	r25, r17
    2eca:	99 0d       	add	r25, r9
    2ecc:	e9 0f       	add	r30, r25
    2ece:	9e 2f       	mov	r25, r30
    2ed0:	a2 2e       	mov	r10, r18
    2ed2:	b3 2e       	mov	r11, r19
    2ed4:	c4 2e       	mov	r12, r20
    2ed6:	d5 2e       	mov	r13, r21
    2ed8:	e6 2e       	mov	r14, r22
    2eda:	f7 2e       	mov	r15, r23
    2edc:	08 2f       	mov	r16, r24
    2ede:	19 2f       	mov	r17, r25
    2ee0:	2a 2d       	mov	r18, r10
    2ee2:	3b 2d       	mov	r19, r11
    2ee4:	4c 2d       	mov	r20, r12
    2ee6:	5d 2d       	mov	r21, r13
    2ee8:	6e 2d       	mov	r22, r14
    2eea:	7f 2d       	mov	r23, r15
    2eec:	80 2f       	mov	r24, r16
    2eee:	91 2f       	mov	r25, r17
    2ef0:	02 e0       	ldi	r16, 0x02	; 2
    2ef2:	0e 94 13 56 	call	0xac26	; 0xac26 <__ashrdi3>
    2ef6:	a2 2e       	mov	r10, r18
    2ef8:	b3 2e       	mov	r11, r19
    2efa:	c4 2e       	mov	r12, r20
    2efc:	d5 2e       	mov	r13, r21
    2efe:	e6 2e       	mov	r14, r22
    2f00:	f7 2e       	mov	r15, r23
    2f02:	08 2f       	mov	r16, r24
    2f04:	19 2f       	mov	r17, r25
    2f06:	2a 2d       	mov	r18, r10
    2f08:	3b 2d       	mov	r19, r11
    2f0a:	4c 2d       	mov	r20, r12
    2f0c:	5d 2d       	mov	r21, r13
    2f0e:	6e 2d       	mov	r22, r14
    2f10:	7f 2d       	mov	r23, r15
    2f12:	80 2f       	mov	r24, r16
    2f14:	91 2f       	mov	r25, r17
    2f16:	2a 83       	std	Y+2, r18	; 0x02
    2f18:	3b 83       	std	Y+3, r19	; 0x03
    2f1a:	4c 83       	std	Y+4, r20	; 0x04
    2f1c:	5d 83       	std	Y+5, r21	; 0x05
    2f1e:	6e 83       	std	Y+6, r22	; 0x06
    2f20:	7f 83       	std	Y+7, r23	; 0x07
    2f22:	88 87       	std	Y+8, r24	; 0x08
    2f24:	99 87       	std	Y+9, r25	; 0x09
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    2f26:	20 91 6a 50 	lds	r18, 0x506A
    2f2a:	30 91 6b 50 	lds	r19, 0x506B
    2f2e:	80 91 6c 50 	lds	r24, 0x506C
    2f32:	90 91 6d 50 	lds	r25, 0x506D
    2f36:	a0 91 6e 50 	lds	r26, 0x506E
    2f3a:	b0 91 6f 50 	lds	r27, 0x506F
    2f3e:	88 0f       	add	r24, r24
    2f40:	99 1f       	adc	r25, r25
    2f42:	88 0f       	add	r24, r24
    2f44:	99 1f       	adc	r25, r25
    2f46:	a9 01       	movw	r20, r18
    2f48:	48 0f       	add	r20, r24
    2f4a:	59 1f       	adc	r21, r25
    2f4c:	4e 87       	std	Y+14, r20	; 0x0e
    2f4e:	5f 87       	std	Y+15, r21	; 0x0f
    2f50:	aa 80       	ldd	r10, Y+2	; 0x02
    2f52:	bb 80       	ldd	r11, Y+3	; 0x03
    2f54:	cc 80       	ldd	r12, Y+4	; 0x04
    2f56:	dd 80       	ldd	r13, Y+5	; 0x05
    2f58:	ee 80       	ldd	r14, Y+6	; 0x06
    2f5a:	ff 80       	ldd	r15, Y+7	; 0x07
    2f5c:	08 85       	ldd	r16, Y+8	; 0x08
    2f5e:	19 85       	ldd	r17, Y+9	; 0x09
    2f60:	2a 2d       	mov	r18, r10
    2f62:	3b 2d       	mov	r19, r11
    2f64:	4c 2d       	mov	r20, r12
    2f66:	5d 2d       	mov	r21, r13
    2f68:	6e 2d       	mov	r22, r14
    2f6a:	7f 2d       	mov	r23, r15
    2f6c:	80 2f       	mov	r24, r16
    2f6e:	91 2f       	mov	r25, r17
    2f70:	0f 2e       	mov	r0, r31
    2f72:	f0 ea       	ldi	r31, 0xA0	; 160
    2f74:	af 2e       	mov	r10, r31
    2f76:	f0 2d       	mov	r31, r0
    2f78:	0f 2e       	mov	r0, r31
    2f7a:	f5 e2       	ldi	r31, 0x25	; 37
    2f7c:	bf 2e       	mov	r11, r31
    2f7e:	f0 2d       	mov	r31, r0
    2f80:	0f 2e       	mov	r0, r31
    2f82:	f6 e2       	ldi	r31, 0x26	; 38
    2f84:	cf 2e       	mov	r12, r31
    2f86:	f0 2d       	mov	r31, r0
    2f88:	dd 24       	eor	r13, r13
    2f8a:	ee 24       	eor	r14, r14
    2f8c:	ff 24       	eor	r15, r15
    2f8e:	00 e0       	ldi	r16, 0x00	; 0
    2f90:	10 e0       	ldi	r17, 0x00	; 0
    2f92:	0e 94 cc 54 	call	0xa998	; 0xa998 <__muldi3>
    2f96:	22 2e       	mov	r2, r18
    2f98:	33 2e       	mov	r3, r19
    2f9a:	44 2e       	mov	r4, r20
    2f9c:	55 2e       	mov	r5, r21
    2f9e:	66 2e       	mov	r6, r22
    2fa0:	77 2e       	mov	r7, r23
    2fa2:	88 2e       	mov	r8, r24
    2fa4:	99 2e       	mov	r9, r25
    2fa6:	a2 2c       	mov	r10, r2
    2fa8:	b3 2c       	mov	r11, r3
    2faa:	c4 2c       	mov	r12, r4
    2fac:	d5 2c       	mov	r13, r5
    2fae:	e6 2c       	mov	r14, r6
    2fb0:	f7 2c       	mov	r15, r7
    2fb2:	08 2d       	mov	r16, r8
    2fb4:	19 2d       	mov	r17, r9
    2fb6:	2a 2d       	mov	r18, r10
    2fb8:	3b 2d       	mov	r19, r11
    2fba:	4c 2d       	mov	r20, r12
    2fbc:	5d 2d       	mov	r21, r13
    2fbe:	6e 2d       	mov	r22, r14
    2fc0:	7f 2d       	mov	r23, r15
    2fc2:	80 2f       	mov	r24, r16
    2fc4:	91 2f       	mov	r25, r17
    2fc6:	aa 24       	eor	r10, r10
    2fc8:	aa 94       	dec	r10
    2fca:	bb 24       	eor	r11, r11
    2fcc:	ba 94       	dec	r11
    2fce:	0f 2e       	mov	r0, r31
    2fd0:	ff e7       	ldi	r31, 0x7F	; 127
    2fd2:	cf 2e       	mov	r12, r31
    2fd4:	f0 2d       	mov	r31, r0
    2fd6:	dd 24       	eor	r13, r13
    2fd8:	ee 24       	eor	r14, r14
    2fda:	ff 24       	eor	r15, r15
    2fdc:	00 e0       	ldi	r16, 0x00	; 0
    2fde:	10 e0       	ldi	r17, 0x00	; 0
    2fe0:	0e 94 7b 56 	call	0xacf6	; 0xacf6 <__divdi3>
    2fe4:	22 2e       	mov	r2, r18
    2fe6:	33 2e       	mov	r3, r19
    2fe8:	44 2e       	mov	r4, r20
    2fea:	55 2e       	mov	r5, r21
    2fec:	66 2e       	mov	r6, r22
    2fee:	77 2e       	mov	r7, r23
    2ff0:	88 2e       	mov	r8, r24
    2ff2:	99 2e       	mov	r9, r25
    2ff4:	a2 2c       	mov	r10, r2
    2ff6:	b3 2c       	mov	r11, r3
    2ff8:	c4 2c       	mov	r12, r4
    2ffa:	d5 2c       	mov	r13, r5
    2ffc:	e6 2c       	mov	r14, r6
    2ffe:	f7 2c       	mov	r15, r7
    3000:	08 2d       	mov	r16, r8
    3002:	19 2d       	mov	r17, r9
    3004:	2a 2d       	mov	r18, r10
    3006:	3b 2d       	mov	r19, r11
    3008:	4c 2d       	mov	r20, r12
    300a:	5d 2d       	mov	r21, r13
    300c:	6e 2d       	mov	r22, r14
    300e:	7f 2d       	mov	r23, r15
    3010:	80 2f       	mov	r24, r16
    3012:	91 2f       	mov	r25, r17
    3014:	01 e0       	ldi	r16, 0x01	; 1
    3016:	0e 94 9f 55 	call	0xab3e	; 0xab3e <__ashldi3>
    301a:	22 2e       	mov	r2, r18
    301c:	33 2e       	mov	r3, r19
    301e:	44 2e       	mov	r4, r20
    3020:	55 2e       	mov	r5, r21
    3022:	66 2e       	mov	r6, r22
    3024:	77 2e       	mov	r7, r23
    3026:	88 2e       	mov	r8, r24
    3028:	99 2e       	mov	r9, r25
    302a:	a2 2c       	mov	r10, r2
    302c:	b3 2c       	mov	r11, r3
    302e:	c4 2c       	mov	r12, r4
    3030:	d5 2c       	mov	r13, r5
    3032:	e6 2c       	mov	r14, r6
    3034:	f7 2c       	mov	r15, r7
    3036:	08 2d       	mov	r16, r8
    3038:	19 2d       	mov	r17, r9
    303a:	2a 2d       	mov	r18, r10
    303c:	3b 2d       	mov	r19, r11
    303e:	4c 2d       	mov	r20, r12
    3040:	5d 2d       	mov	r21, r13
    3042:	6e 2d       	mov	r22, r14
    3044:	7f 2d       	mov	r23, r15
    3046:	80 2f       	mov	r24, r16
    3048:	91 2f       	mov	r25, r17
    304a:	0f 2e       	mov	r0, r31
    304c:	f3 e0       	ldi	r31, 0x03	; 3
    304e:	af 2e       	mov	r10, r31
    3050:	f0 2d       	mov	r31, r0
    3052:	bb 24       	eor	r11, r11
    3054:	cc 24       	eor	r12, r12
    3056:	dd 24       	eor	r13, r13
    3058:	ee 24       	eor	r14, r14
    305a:	ff 24       	eor	r15, r15
    305c:	00 e0       	ldi	r16, 0x00	; 0
    305e:	10 e0       	ldi	r17, 0x00	; 0
    3060:	0e 94 7b 56 	call	0xacf6	; 0xacf6 <__divdi3>
    3064:	a2 2e       	mov	r10, r18
    3066:	b3 2e       	mov	r11, r19
    3068:	c4 2e       	mov	r12, r20
    306a:	d5 2e       	mov	r13, r21
    306c:	e6 2e       	mov	r14, r22
    306e:	f7 2e       	mov	r15, r23
    3070:	08 2f       	mov	r16, r24
    3072:	19 2f       	mov	r17, r25
    3074:	2a 2d       	mov	r18, r10
    3076:	3b 2d       	mov	r19, r11
    3078:	4c 2d       	mov	r20, r12
    307a:	5d 2d       	mov	r21, r13
    307c:	6e 2d       	mov	r22, r14
    307e:	7f 2d       	mov	r23, r15
    3080:	80 2f       	mov	r24, r16
    3082:	91 2f       	mov	r25, r17
    3084:	da 01       	movw	r26, r20
    3086:	c9 01       	movw	r24, r18
    3088:	ee 85       	ldd	r30, Y+14	; 0x0e
    308a:	ff 85       	ldd	r31, Y+15	; 0x0f
    308c:	80 83       	st	Z, r24
    308e:	91 83       	std	Z+1, r25	; 0x01
    3090:	a2 83       	std	Z+2, r26	; 0x02
    3092:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    3094:	80 91 6c 50 	lds	r24, 0x506C
    3098:	90 91 6d 50 	lds	r25, 0x506D
    309c:	a0 91 6e 50 	lds	r26, 0x506E
    30a0:	b0 91 6f 50 	lds	r27, 0x506F
    30a4:	01 96       	adiw	r24, 0x01	; 1
    30a6:	a1 1d       	adc	r26, r1
    30a8:	b1 1d       	adc	r27, r1
    30aa:	80 93 6c 50 	sts	0x506C, r24
    30ae:	90 93 6d 50 	sts	0x506D, r25
    30b2:	a0 93 6e 50 	sts	0x506E, r26
    30b6:	b0 93 6f 50 	sts	0x506F, r27
}
    30ba:	2f 96       	adiw	r28, 0x0f	; 15
    30bc:	cd bf       	out	0x3d, r28	; 61
    30be:	de bf       	out	0x3e, r29	; 62
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	ff 91       	pop	r31
    30c6:	ef 91       	pop	r30
    30c8:	bf 91       	pop	r27
    30ca:	af 91       	pop	r26
    30cc:	9f 91       	pop	r25
    30ce:	8f 91       	pop	r24
    30d0:	7f 91       	pop	r23
    30d2:	6f 91       	pop	r22
    30d4:	5f 91       	pop	r21
    30d6:	4f 91       	pop	r20
    30d8:	3f 91       	pop	r19
    30da:	2f 91       	pop	r18
    30dc:	1f 91       	pop	r17
    30de:	0f 91       	pop	r16
    30e0:	ff 90       	pop	r15
    30e2:	ef 90       	pop	r14
    30e4:	df 90       	pop	r13
    30e6:	cf 90       	pop	r12
    30e8:	bf 90       	pop	r11
    30ea:	af 90       	pop	r10
    30ec:	9f 90       	pop	r9
    30ee:	8f 90       	pop	r8
    30f0:	7f 90       	pop	r7
    30f2:	6f 90       	pop	r6
    30f4:	5f 90       	pop	r5
    30f6:	4f 90       	pop	r4
    30f8:	3f 90       	pop	r3
    30fa:	2f 90       	pop	r2
    30fc:	0f 90       	pop	r0
    30fe:	00 92 3b 00 	sts	0x003B, r0
    3102:	0f 90       	pop	r0
    3104:	0f be       	out	0x3f, r0	; 63
    3106:	0f 90       	pop	r0
    3108:	1f 90       	pop	r1
    310a:	18 95       	reti

0000310c <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
    310c:	cf 93       	push	r28
    310e:	df 93       	push	r29
    3110:	cd b7       	in	r28, 0x3d	; 61
    3112:	de b7       	in	r29, 0x3e	; 62
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    3114:	80 ea       	ldi	r24, 0xA0	; 160
    3116:	96 e0       	ldi	r25, 0x06	; 6
    3118:	22 e0       	ldi	r18, 0x02	; 2
    311a:	fc 01       	movw	r30, r24
    311c:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    311e:	80 ec       	ldi	r24, 0xC0	; 192
    3120:	98 e0       	ldi	r25, 0x08	; 8
    3122:	2a ea       	ldi	r18, 0xAA	; 170
    3124:	fc 01       	movw	r30, r24
    3126:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3128:	00 00       	nop
    312a:	80 ec       	ldi	r24, 0xC0	; 192
    312c:	98 e0       	ldi	r25, 0x08	; 8
    312e:	fc 01       	movw	r30, r24
    3130:	82 81       	ldd	r24, Z+2	; 0x02
    3132:	88 23       	and	r24, r24
    3134:	d4 f7       	brge	.-12     	; 0x312a <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    3136:	80 91 be 50 	lds	r24, 0x50BE
    313a:	88 2f       	mov	r24, r24
    313c:	90 e0       	ldi	r25, 0x00	; 0
    313e:	20 ec       	ldi	r18, 0xC0	; 192
    3140:	38 e0       	ldi	r19, 0x08	; 8
    3142:	f9 01       	movw	r30, r18
    3144:	23 81       	ldd	r18, Z+3	; 0x03
    3146:	83 5a       	subi	r24, 0xA3	; 163
    3148:	9f 4a       	sbci	r25, 0xAF	; 175
    314a:	fc 01       	movw	r30, r24
    314c:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    314e:	80 ec       	ldi	r24, 0xC0	; 192
    3150:	98 e0       	ldi	r25, 0x08	; 8
    3152:	2a ea       	ldi	r18, 0xAA	; 170
    3154:	fc 01       	movw	r30, r24
    3156:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3158:	00 00       	nop
    315a:	80 ec       	ldi	r24, 0xC0	; 192
    315c:	98 e0       	ldi	r25, 0x08	; 8
    315e:	fc 01       	movw	r30, r24
    3160:	82 81       	ldd	r24, Z+2	; 0x02
    3162:	88 23       	and	r24, r24
    3164:	d4 f7       	brge	.-12     	; 0x315a <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    3166:	80 91 be 50 	lds	r24, 0x50BE
    316a:	88 2f       	mov	r24, r24
    316c:	90 e0       	ldi	r25, 0x00	; 0
    316e:	01 96       	adiw	r24, 0x01	; 1
    3170:	20 ec       	ldi	r18, 0xC0	; 192
    3172:	38 e0       	ldi	r19, 0x08	; 8
    3174:	f9 01       	movw	r30, r18
    3176:	23 81       	ldd	r18, Z+3	; 0x03
    3178:	83 5a       	subi	r24, 0xA3	; 163
    317a:	9f 4a       	sbci	r25, 0xAF	; 175
    317c:	fc 01       	movw	r30, r24
    317e:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    3180:	80 ec       	ldi	r24, 0xC0	; 192
    3182:	98 e0       	ldi	r25, 0x08	; 8
    3184:	2a ea       	ldi	r18, 0xAA	; 170
    3186:	fc 01       	movw	r30, r24
    3188:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    318a:	00 00       	nop
    318c:	80 ec       	ldi	r24, 0xC0	; 192
    318e:	98 e0       	ldi	r25, 0x08	; 8
    3190:	fc 01       	movw	r30, r24
    3192:	82 81       	ldd	r24, Z+2	; 0x02
    3194:	88 23       	and	r24, r24
    3196:	d4 f7       	brge	.-12     	; 0x318c <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    3198:	80 91 be 50 	lds	r24, 0x50BE
    319c:	88 2f       	mov	r24, r24
    319e:	90 e0       	ldi	r25, 0x00	; 0
    31a0:	02 96       	adiw	r24, 0x02	; 2
    31a2:	20 ec       	ldi	r18, 0xC0	; 192
    31a4:	38 e0       	ldi	r19, 0x08	; 8
    31a6:	f9 01       	movw	r30, r18
    31a8:	23 81       	ldd	r18, Z+3	; 0x03
    31aa:	83 5a       	subi	r24, 0xA3	; 163
    31ac:	9f 4a       	sbci	r25, 0xAF	; 175
    31ae:	fc 01       	movw	r30, r24
    31b0:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    31b2:	80 ea       	ldi	r24, 0xA0	; 160
    31b4:	96 e0       	ldi	r25, 0x06	; 6
    31b6:	22 e0       	ldi	r18, 0x02	; 2
    31b8:	fc 01       	movw	r30, r24
    31ba:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    31bc:	80 91 be 50 	lds	r24, 0x50BE
    31c0:	8d 5f       	subi	r24, 0xFD	; 253
    31c2:	80 93 be 50 	sts	0x50BE, r24
}
    31c6:	df 91       	pop	r29
    31c8:	cf 91       	pop	r28
    31ca:	08 95       	ret

000031cc <writeSE2FRAM>:

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    31cc:	cf 93       	push	r28
    31ce:	df 93       	push	r29
    31d0:	cd b7       	in	r28, 0x3d	; 61
    31d2:	de b7       	in	r29, 0x3e	; 62
    31d4:	29 97       	sbiw	r28, 0x09	; 9
    31d6:	cd bf       	out	0x3d, r28	; 61
    31d8:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    31da:	1a 82       	std	Y+2, r1	; 0x02
    31dc:	1b 82       	std	Y+3, r1	; 0x03
    31de:	1c 82       	std	Y+4, r1	; 0x04
    31e0:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    31e2:	80 91 6c 50 	lds	r24, 0x506C
    31e6:	90 91 6d 50 	lds	r25, 0x506D
    31ea:	a0 91 6e 50 	lds	r26, 0x506E
    31ee:	b0 91 6f 50 	lds	r27, 0x506F
    31f2:	01 96       	adiw	r24, 0x01	; 1
    31f4:	a1 1d       	adc	r26, r1
    31f6:	b1 1d       	adc	r27, r1
    31f8:	80 93 6c 50 	sts	0x506C, r24
    31fc:	90 93 6d 50 	sts	0x506D, r25
    3200:	a0 93 6e 50 	sts	0x506E, r26
    3204:	b0 93 6f 50 	sts	0x506F, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3208:	80 ec       	ldi	r24, 0xC0	; 192
    320a:	98 e0       	ldi	r25, 0x08	; 8
    320c:	20 ed       	ldi	r18, 0xD0	; 208
    320e:	fc 01       	movw	r30, r24
    3210:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    3212:	19 82       	std	Y+1, r1	; 0x01
    3214:	4f c0       	rjmp	.+158    	; 0x32b4 <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    3216:	89 81       	ldd	r24, Y+1	; 0x01
    3218:	88 2f       	mov	r24, r24
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	83 5a       	subi	r24, 0xA3	; 163
    321e:	9f 4a       	sbci	r25, 0xAF	; 175
    3220:	fc 01       	movw	r30, r24
    3222:	80 81       	ld	r24, Z
    3224:	88 23       	and	r24, r24
    3226:	3c f4       	brge	.+14     	; 0x3236 <writeSE2FRAM+0x6a>
    3228:	ce 01       	movw	r24, r28
    322a:	06 96       	adiw	r24, 0x06	; 6
    322c:	03 96       	adiw	r24, 0x03	; 3
    322e:	2f ef       	ldi	r18, 0xFF	; 255
    3230:	fc 01       	movw	r30, r24
    3232:	20 83       	st	Z, r18
    3234:	05 c0       	rjmp	.+10     	; 0x3240 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    3236:	ce 01       	movw	r24, r28
    3238:	06 96       	adiw	r24, 0x06	; 6
    323a:	03 96       	adiw	r24, 0x03	; 3
    323c:	fc 01       	movw	r30, r24
    323e:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    3240:	ce 01       	movw	r24, r28
    3242:	06 96       	adiw	r24, 0x06	; 6
    3244:	02 96       	adiw	r24, 0x02	; 2
    3246:	29 81       	ldd	r18, Y+1	; 0x01
    3248:	22 2f       	mov	r18, r18
    324a:	30 e0       	ldi	r19, 0x00	; 0
    324c:	23 5a       	subi	r18, 0xA3	; 163
    324e:	3f 4a       	sbci	r19, 0xAF	; 175
    3250:	f9 01       	movw	r30, r18
    3252:	20 81       	ld	r18, Z
    3254:	fc 01       	movw	r30, r24
    3256:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    3258:	ce 01       	movw	r24, r28
    325a:	06 96       	adiw	r24, 0x06	; 6
    325c:	01 96       	adiw	r24, 0x01	; 1
    325e:	29 81       	ldd	r18, Y+1	; 0x01
    3260:	22 2f       	mov	r18, r18
    3262:	30 e0       	ldi	r19, 0x00	; 0
    3264:	2f 5f       	subi	r18, 0xFF	; 255
    3266:	3f 4f       	sbci	r19, 0xFF	; 255
    3268:	23 5a       	subi	r18, 0xA3	; 163
    326a:	3f 4a       	sbci	r19, 0xAF	; 175
    326c:	f9 01       	movw	r30, r18
    326e:	20 81       	ld	r18, Z
    3270:	fc 01       	movw	r30, r24
    3272:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    3274:	ce 01       	movw	r24, r28
    3276:	06 96       	adiw	r24, 0x06	; 6
    3278:	29 81       	ldd	r18, Y+1	; 0x01
    327a:	22 2f       	mov	r18, r18
    327c:	30 e0       	ldi	r19, 0x00	; 0
    327e:	2e 5f       	subi	r18, 0xFE	; 254
    3280:	3f 4f       	sbci	r19, 0xFF	; 255
    3282:	23 5a       	subi	r18, 0xA3	; 163
    3284:	3f 4a       	sbci	r19, 0xAF	; 175
    3286:	f9 01       	movw	r30, r18
    3288:	20 81       	ld	r18, Z
    328a:	fc 01       	movw	r30, r24
    328c:	20 83       	st	Z, r18
		sum += currentSample;
    328e:	2a 81       	ldd	r18, Y+2	; 0x02
    3290:	3b 81       	ldd	r19, Y+3	; 0x03
    3292:	4c 81       	ldd	r20, Y+4	; 0x04
    3294:	5d 81       	ldd	r21, Y+5	; 0x05
    3296:	8e 81       	ldd	r24, Y+6	; 0x06
    3298:	9f 81       	ldd	r25, Y+7	; 0x07
    329a:	a8 85       	ldd	r26, Y+8	; 0x08
    329c:	b9 85       	ldd	r27, Y+9	; 0x09
    329e:	82 0f       	add	r24, r18
    32a0:	93 1f       	adc	r25, r19
    32a2:	a4 1f       	adc	r26, r20
    32a4:	b5 1f       	adc	r27, r21
    32a6:	8a 83       	std	Y+2, r24	; 0x02
    32a8:	9b 83       	std	Y+3, r25	; 0x03
    32aa:	ac 83       	std	Y+4, r26	; 0x04
    32ac:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    32ae:	89 81       	ldd	r24, Y+1	; 0x01
    32b0:	8d 5f       	subi	r24, 0xFD	; 253
    32b2:	89 83       	std	Y+1, r24	; 0x01
    32b4:	89 81       	ldd	r24, Y+1	; 0x01
    32b6:	8c 30       	cpi	r24, 0x0C	; 12
    32b8:	08 f4       	brcc	.+2      	; 0x32bc <writeSE2FRAM+0xf0>
    32ba:	ad cf       	rjmp	.-166    	; 0x3216 <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    32bc:	8a 81       	ldd	r24, Y+2	; 0x02
    32be:	9b 81       	ldd	r25, Y+3	; 0x03
    32c0:	ac 81       	ldd	r26, Y+4	; 0x04
    32c2:	bd 81       	ldd	r27, Y+5	; 0x05
    32c4:	24 e0       	ldi	r18, 0x04	; 4
    32c6:	30 e0       	ldi	r19, 0x00	; 0
    32c8:	40 e0       	ldi	r20, 0x00	; 0
    32ca:	50 e0       	ldi	r21, 0x00	; 0
    32cc:	bc 01       	movw	r22, r24
    32ce:	cd 01       	movw	r24, r26
    32d0:	0e 94 b5 60 	call	0xc16a	; 0xc16a <__divmodsi4>
    32d4:	da 01       	movw	r26, r20
    32d6:	c9 01       	movw	r24, r18
    32d8:	8a 83       	std	Y+2, r24	; 0x02
    32da:	9b 83       	std	Y+3, r25	; 0x03
    32dc:	ac 83       	std	Y+4, r26	; 0x04
    32de:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    32e0:	ce 01       	movw	r24, r28
    32e2:	02 96       	adiw	r24, 0x02	; 2
    32e4:	fc 01       	movw	r30, r24
    32e6:	80 81       	ld	r24, Z
    32e8:	80 93 5f 50 	sts	0x505F, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    32ec:	ce 01       	movw	r24, r28
    32ee:	02 96       	adiw	r24, 0x02	; 2
    32f0:	fc 01       	movw	r30, r24
    32f2:	81 81       	ldd	r24, Z+1	; 0x01
    32f4:	80 93 5e 50 	sts	0x505E, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    32f8:	ce 01       	movw	r24, r28
    32fa:	02 96       	adiw	r24, 0x02	; 2
    32fc:	fc 01       	movw	r30, r24
    32fe:	82 81       	ldd	r24, Z+2	; 0x02
    3300:	80 93 5d 50 	sts	0x505D, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    3304:	80 e4       	ldi	r24, 0x40	; 64
    3306:	96 e0       	ldi	r25, 0x06	; 6
    3308:	20 e1       	ldi	r18, 0x10	; 16
    330a:	fc 01       	movw	r30, r24
    330c:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    330e:	80 e2       	ldi	r24, 0x20	; 32
    3310:	96 e0       	ldi	r25, 0x06	; 6
    3312:	28 e0       	ldi	r18, 0x08	; 8
    3314:	fc 01       	movw	r30, r24
    3316:	26 83       	std	Z+6, r18	; 0x06
	nop();
    3318:	00 00       	nop
	SPIC.DATA = FR_WREN;
    331a:	80 ec       	ldi	r24, 0xC0	; 192
    331c:	98 e0       	ldi	r25, 0x08	; 8
    331e:	26 e0       	ldi	r18, 0x06	; 6
    3320:	fc 01       	movw	r30, r24
    3322:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3324:	00 00       	nop
    3326:	80 ec       	ldi	r24, 0xC0	; 192
    3328:	98 e0       	ldi	r25, 0x08	; 8
    332a:	fc 01       	movw	r30, r24
    332c:	82 81       	ldd	r24, Z+2	; 0x02
    332e:	88 23       	and	r24, r24
    3330:	d4 f7       	brge	.-12     	; 0x3326 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    3332:	80 ec       	ldi	r24, 0xC0	; 192
    3334:	98 e0       	ldi	r25, 0x08	; 8
    3336:	fc 01       	movw	r30, r24
    3338:	83 81       	ldd	r24, Z+3	; 0x03
    333a:	80 93 69 50 	sts	0x5069, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    333e:	80 e2       	ldi	r24, 0x20	; 32
    3340:	96 e0       	ldi	r25, 0x06	; 6
    3342:	28 e0       	ldi	r18, 0x08	; 8
    3344:	fc 01       	movw	r30, r24
    3346:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    3348:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    334a:	80 e2       	ldi	r24, 0x20	; 32
    334c:	96 e0       	ldi	r25, 0x06	; 6
    334e:	28 e0       	ldi	r18, 0x08	; 8
    3350:	fc 01       	movw	r30, r24
    3352:	26 83       	std	Z+6, r18	; 0x06
	nop();
    3354:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    3356:	80 ec       	ldi	r24, 0xC0	; 192
    3358:	98 e0       	ldi	r25, 0x08	; 8
    335a:	22 e0       	ldi	r18, 0x02	; 2
    335c:	fc 01       	movw	r30, r24
    335e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3360:	00 00       	nop
    3362:	80 ec       	ldi	r24, 0xC0	; 192
    3364:	98 e0       	ldi	r25, 0x08	; 8
    3366:	fc 01       	movw	r30, r24
    3368:	82 81       	ldd	r24, Z+2	; 0x02
    336a:	88 23       	and	r24, r24
    336c:	d4 f7       	brge	.-12     	; 0x3362 <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    336e:	80 ec       	ldi	r24, 0xC0	; 192
    3370:	98 e0       	ldi	r25, 0x08	; 8
    3372:	fc 01       	movw	r30, r24
    3374:	83 81       	ldd	r24, Z+3	; 0x03
    3376:	80 93 69 50 	sts	0x5069, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    337a:	80 ec       	ldi	r24, 0xC0	; 192
    337c:	98 e0       	ldi	r25, 0x08	; 8
    337e:	20 91 50 40 	lds	r18, 0x4050
    3382:	fc 01       	movw	r30, r24
    3384:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3386:	00 00       	nop
    3388:	80 ec       	ldi	r24, 0xC0	; 192
    338a:	98 e0       	ldi	r25, 0x08	; 8
    338c:	fc 01       	movw	r30, r24
    338e:	82 81       	ldd	r24, Z+2	; 0x02
    3390:	88 23       	and	r24, r24
    3392:	d4 f7       	brge	.-12     	; 0x3388 <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    3394:	80 ec       	ldi	r24, 0xC0	; 192
    3396:	98 e0       	ldi	r25, 0x08	; 8
    3398:	fc 01       	movw	r30, r24
    339a:	83 81       	ldd	r24, Z+3	; 0x03
    339c:	80 93 69 50 	sts	0x5069, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    33a0:	80 ec       	ldi	r24, 0xC0	; 192
    33a2:	98 e0       	ldi	r25, 0x08	; 8
    33a4:	2f e4       	ldi	r18, 0x4F	; 79
    33a6:	30 e4       	ldi	r19, 0x40	; 64
    33a8:	f9 01       	movw	r30, r18
    33aa:	20 81       	ld	r18, Z
    33ac:	fc 01       	movw	r30, r24
    33ae:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    33b0:	00 00       	nop
    33b2:	80 ec       	ldi	r24, 0xC0	; 192
    33b4:	98 e0       	ldi	r25, 0x08	; 8
    33b6:	fc 01       	movw	r30, r24
    33b8:	82 81       	ldd	r24, Z+2	; 0x02
    33ba:	88 23       	and	r24, r24
    33bc:	d4 f7       	brge	.-12     	; 0x33b2 <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    33be:	80 ec       	ldi	r24, 0xC0	; 192
    33c0:	98 e0       	ldi	r25, 0x08	; 8
    33c2:	fc 01       	movw	r30, r24
    33c4:	83 81       	ldd	r24, Z+3	; 0x03
    33c6:	80 93 69 50 	sts	0x5069, r24
	SPIC.DATA = SPIBuffer[0];
    33ca:	80 ec       	ldi	r24, 0xC0	; 192
    33cc:	98 e0       	ldi	r25, 0x08	; 8
    33ce:	20 91 5d 50 	lds	r18, 0x505D
    33d2:	fc 01       	movw	r30, r24
    33d4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    33d6:	00 00       	nop
    33d8:	80 ec       	ldi	r24, 0xC0	; 192
    33da:	98 e0       	ldi	r25, 0x08	; 8
    33dc:	fc 01       	movw	r30, r24
    33de:	82 81       	ldd	r24, Z+2	; 0x02
    33e0:	88 23       	and	r24, r24
    33e2:	d4 f7       	brge	.-12     	; 0x33d8 <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    33e4:	80 ec       	ldi	r24, 0xC0	; 192
    33e6:	98 e0       	ldi	r25, 0x08	; 8
    33e8:	fc 01       	movw	r30, r24
    33ea:	83 81       	ldd	r24, Z+3	; 0x03
    33ec:	80 93 69 50 	sts	0x5069, r24
	SPIC.DATA = SPIBuffer[1];
    33f0:	80 ec       	ldi	r24, 0xC0	; 192
    33f2:	98 e0       	ldi	r25, 0x08	; 8
    33f4:	20 91 5e 50 	lds	r18, 0x505E
    33f8:	fc 01       	movw	r30, r24
    33fa:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    33fc:	00 00       	nop
    33fe:	80 ec       	ldi	r24, 0xC0	; 192
    3400:	98 e0       	ldi	r25, 0x08	; 8
    3402:	fc 01       	movw	r30, r24
    3404:	82 81       	ldd	r24, Z+2	; 0x02
    3406:	88 23       	and	r24, r24
    3408:	d4 f7       	brge	.-12     	; 0x33fe <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    340a:	80 ec       	ldi	r24, 0xC0	; 192
    340c:	98 e0       	ldi	r25, 0x08	; 8
    340e:	fc 01       	movw	r30, r24
    3410:	83 81       	ldd	r24, Z+3	; 0x03
    3412:	80 93 69 50 	sts	0x5069, r24
	SPIC.DATA = SPIBuffer[2];
    3416:	80 ec       	ldi	r24, 0xC0	; 192
    3418:	98 e0       	ldi	r25, 0x08	; 8
    341a:	20 91 5f 50 	lds	r18, 0x505F
    341e:	fc 01       	movw	r30, r24
    3420:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3422:	00 00       	nop
    3424:	80 ec       	ldi	r24, 0xC0	; 192
    3426:	98 e0       	ldi	r25, 0x08	; 8
    3428:	fc 01       	movw	r30, r24
    342a:	82 81       	ldd	r24, Z+2	; 0x02
    342c:	88 23       	and	r24, r24
    342e:	d4 f7       	brge	.-12     	; 0x3424 <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    3430:	80 ec       	ldi	r24, 0xC0	; 192
    3432:	98 e0       	ldi	r25, 0x08	; 8
    3434:	fc 01       	movw	r30, r24
    3436:	83 81       	ldd	r24, Z+3	; 0x03
    3438:	80 93 69 50 	sts	0x5069, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    343c:	80 e2       	ldi	r24, 0x20	; 32
    343e:	96 e0       	ldi	r25, 0x06	; 6
    3440:	28 e0       	ldi	r18, 0x08	; 8
    3442:	fc 01       	movw	r30, r24
    3444:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3446:	80 e4       	ldi	r24, 0x40	; 64
    3448:	96 e0       	ldi	r25, 0x06	; 6
    344a:	20 e1       	ldi	r18, 0x10	; 16
    344c:	fc 01       	movw	r30, r24
    344e:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    3450:	80 ec       	ldi	r24, 0xC0	; 192
    3452:	98 e0       	ldi	r25, 0x08	; 8
    3454:	24 e5       	ldi	r18, 0x54	; 84
    3456:	fc 01       	movw	r30, r24
    3458:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    345a:	80 e4       	ldi	r24, 0x40	; 64
    345c:	96 e0       	ldi	r25, 0x06	; 6
    345e:	20 e1       	ldi	r18, 0x10	; 16
    3460:	fc 01       	movw	r30, r24
    3462:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    3464:	80 91 4f 40 	lds	r24, 0x404F
    3468:	90 91 50 40 	lds	r25, 0x4050
    346c:	03 96       	adiw	r24, 0x03	; 3
    346e:	80 93 4f 40 	sts	0x404F, r24
    3472:	90 93 50 40 	sts	0x4050, r25
	checksumADC[0] += SPIBuffer[0];
    3476:	90 91 30 21 	lds	r25, 0x2130
    347a:	80 91 5d 50 	lds	r24, 0x505D
    347e:	89 0f       	add	r24, r25
    3480:	80 93 30 21 	sts	0x2130, r24
	checksumADC[1] += SPIBuffer[1];
    3484:	90 91 31 21 	lds	r25, 0x2131
    3488:	80 91 5e 50 	lds	r24, 0x505E
    348c:	89 0f       	add	r24, r25
    348e:	80 93 31 21 	sts	0x2131, r24
	checksumADC[2] += SPIBuffer[2];
    3492:	90 91 32 21 	lds	r25, 0x2132
    3496:	80 91 5f 50 	lds	r24, 0x505F
    349a:	89 0f       	add	r24, r25
    349c:	80 93 32 21 	sts	0x2132, r24
}
    34a0:	29 96       	adiw	r28, 0x09	; 9
    34a2:	cd bf       	out	0x3d, r28	; 61
    34a4:	de bf       	out	0x3e, r29	; 62
    34a6:	df 91       	pop	r29
    34a8:	cf 91       	pop	r28
    34aa:	08 95       	ret

000034ac <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    34ac:	2f 92       	push	r2
    34ae:	3f 92       	push	r3
    34b0:	4f 92       	push	r4
    34b2:	5f 92       	push	r5
    34b4:	6f 92       	push	r6
    34b6:	7f 92       	push	r7
    34b8:	8f 92       	push	r8
    34ba:	9f 92       	push	r9
    34bc:	af 92       	push	r10
    34be:	bf 92       	push	r11
    34c0:	cf 92       	push	r12
    34c2:	df 92       	push	r13
    34c4:	ef 92       	push	r14
    34c6:	ff 92       	push	r15
    34c8:	0f 93       	push	r16
    34ca:	1f 93       	push	r17
    34cc:	cf 93       	push	r28
    34ce:	df 93       	push	r29
    34d0:	00 d0       	rcall	.+0      	; 0x34d2 <calcChecksumFRAM+0x26>
    34d2:	0f 92       	push	r0
    34d4:	cd b7       	in	r28, 0x3d	; 61
    34d6:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    34d8:	aa 24       	eor	r10, r10
    34da:	bb 24       	eor	r11, r11
    34dc:	cc 24       	eor	r12, r12
    34de:	dd 24       	eor	r13, r13
    34e0:	ee 24       	eor	r14, r14
    34e2:	ff 24       	eor	r15, r15
    34e4:	00 e0       	ldi	r16, 0x00	; 0
    34e6:	10 e0       	ldi	r17, 0x00	; 0
    34e8:	a0 92 93 50 	sts	0x5093, r10
    34ec:	b0 92 94 50 	sts	0x5094, r11
    34f0:	c0 92 95 50 	sts	0x5095, r12
    34f4:	d0 92 96 50 	sts	0x5096, r13
    34f8:	e0 92 97 50 	sts	0x5097, r14
    34fc:	f0 92 98 50 	sts	0x5098, r15
    3500:	00 93 99 50 	sts	0x5099, r16
    3504:	10 93 9a 50 	sts	0x509A, r17
    3508:	2a 2d       	mov	r18, r10
    350a:	3b 2d       	mov	r19, r11
    350c:	4c 2d       	mov	r20, r12
    350e:	5d 2d       	mov	r21, r13
    3510:	6e 2d       	mov	r22, r14
    3512:	7f 2d       	mov	r23, r15
    3514:	80 2f       	mov	r24, r16
    3516:	91 2f       	mov	r25, r17
    3518:	20 93 8b 50 	sts	0x508B, r18
    351c:	30 93 8c 50 	sts	0x508C, r19
    3520:	40 93 8d 50 	sts	0x508D, r20
    3524:	50 93 8e 50 	sts	0x508E, r21
    3528:	60 93 8f 50 	sts	0x508F, r22
    352c:	70 93 90 50 	sts	0x5090, r23
    3530:	80 93 91 50 	sts	0x5091, r24
    3534:	90 93 92 50 	sts	0x5092, r25
    3538:	20 93 83 50 	sts	0x5083, r18
    353c:	30 93 84 50 	sts	0x5084, r19
    3540:	40 93 85 50 	sts	0x5085, r20
    3544:	50 93 86 50 	sts	0x5086, r21
    3548:	60 93 87 50 	sts	0x5087, r22
    354c:	70 93 88 50 	sts	0x5088, r23
    3550:	80 93 89 50 	sts	0x5089, r24
    3554:	90 93 8a 50 	sts	0x508A, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    3558:	80 e0       	ldi	r24, 0x00	; 0
    355a:	80 93 35 21 	sts	0x2135, r24
    355e:	80 93 34 21 	sts	0x2134, r24
    3562:	80 93 33 21 	sts	0x2133, r24
	FRAMAddress = FR_BASEADD;
    3566:	10 92 4f 40 	sts	0x404F, r1
    356a:	10 92 50 40 	sts	0x4050, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    356e:	19 82       	std	Y+1, r1	; 0x01
    3570:	1a 82       	std	Y+2, r1	; 0x02
    3572:	88 c2       	rjmp	.+1296   	; 0x3a84 <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    3574:	81 e7       	ldi	r24, 0x71	; 113
    3576:	9c e1       	ldi	r25, 0x1C	; 28
    3578:	0e 94 65 3b 	call	0x76ca	; 0x76ca <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    357c:	80 91 4f 40 	lds	r24, 0x404F
    3580:	90 91 50 40 	lds	r25, 0x4050
    3584:	8f 58       	subi	r24, 0x8F	; 143
    3586:	93 4e       	sbci	r25, 0xE3	; 227
    3588:	80 93 4f 40 	sts	0x404F, r24
    358c:	90 93 50 40 	sts	0x4050, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3590:	1b 82       	std	Y+3, r1	; 0x03
    3592:	1c 82       	std	Y+4, r1	; 0x04
    3594:	6b c2       	rjmp	.+1238   	; 0x3a6c <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    3596:	8b 81       	ldd	r24, Y+3	; 0x03
    3598:	9c 81       	ldd	r25, Y+4	; 0x04
    359a:	23 e0       	ldi	r18, 0x03	; 3
    359c:	30 e0       	ldi	r19, 0x00	; 0
    359e:	b9 01       	movw	r22, r18
    35a0:	0e 94 6c 60 	call	0xc0d8	; 0xc0d8 <__udivmodhi4>
    35a4:	9c 01       	movw	r18, r24
    35a6:	2d 5c       	subi	r18, 0xCD	; 205
    35a8:	3e 4d       	sbci	r19, 0xDE	; 222
    35aa:	f9 01       	movw	r30, r18
    35ac:	40 81       	ld	r20, Z
    35ae:	2b 81       	ldd	r18, Y+3	; 0x03
    35b0:	3c 81       	ldd	r19, Y+4	; 0x04
    35b2:	29 52       	subi	r18, 0x29	; 41
    35b4:	3c 4d       	sbci	r19, 0xDC	; 220
    35b6:	f9 01       	movw	r30, r18
    35b8:	20 81       	ld	r18, Z
    35ba:	24 0f       	add	r18, r20
    35bc:	8d 5c       	subi	r24, 0xCD	; 205
    35be:	9e 4d       	sbci	r25, 0xDE	; 222
    35c0:	fc 01       	movw	r30, r24
    35c2:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    35c4:	8b 81       	ldd	r24, Y+3	; 0x03
    35c6:	9c 81       	ldd	r25, Y+4	; 0x04
    35c8:	23 e0       	ldi	r18, 0x03	; 3
    35ca:	30 e0       	ldi	r19, 0x00	; 0
    35cc:	b9 01       	movw	r22, r18
    35ce:	0e 94 6c 60 	call	0xc0d8	; 0xc0d8 <__udivmodhi4>
    35d2:	00 97       	sbiw	r24, 0x00	; 0
    35d4:	09 f0       	breq	.+2      	; 0x35d8 <calcChecksumFRAM+0x12c>
    35d6:	44 c0       	rjmp	.+136    	; 0x3660 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    35d8:	8b 81       	ldd	r24, Y+3	; 0x03
    35da:	9c 81       	ldd	r25, Y+4	; 0x04
    35dc:	89 52       	subi	r24, 0x29	; 41
    35de:	9c 4d       	sbci	r25, 0xDC	; 220
    35e0:	fc 01       	movw	r30, r24
    35e2:	80 81       	ld	r24, Z
    35e4:	88 23       	and	r24, r24
    35e6:	d4 f4       	brge	.+52     	; 0x361c <calcChecksumFRAM+0x170>
    35e8:	80 91 5b 50 	lds	r24, 0x505B
    35ec:	90 91 5c 50 	lds	r25, 0x505C
    35f0:	fc 01       	movw	r30, r24
    35f2:	10 82       	st	Z, r1
    35f4:	fc 01       	movw	r30, r24
    35f6:	11 82       	std	Z+1, r1	; 0x01
    35f8:	fc 01       	movw	r30, r24
    35fa:	12 82       	std	Z+2, r1	; 0x02
    35fc:	2f ef       	ldi	r18, 0xFF	; 255
    35fe:	fc 01       	movw	r30, r24
    3600:	23 83       	std	Z+3, r18	; 0x03
    3602:	2f ef       	ldi	r18, 0xFF	; 255
    3604:	fc 01       	movw	r30, r24
    3606:	24 83       	std	Z+4, r18	; 0x04
    3608:	2f ef       	ldi	r18, 0xFF	; 255
    360a:	fc 01       	movw	r30, r24
    360c:	25 83       	std	Z+5, r18	; 0x05
    360e:	2f ef       	ldi	r18, 0xFF	; 255
    3610:	fc 01       	movw	r30, r24
    3612:	26 83       	std	Z+6, r18	; 0x06
    3614:	2f ef       	ldi	r18, 0xFF	; 255
    3616:	fc 01       	movw	r30, r24
    3618:	27 83       	std	Z+7, r18	; 0x07
    361a:	14 c0       	rjmp	.+40     	; 0x3644 <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    361c:	80 91 5b 50 	lds	r24, 0x505B
    3620:	90 91 5c 50 	lds	r25, 0x505C
    3624:	fc 01       	movw	r30, r24
    3626:	10 82       	st	Z, r1
    3628:	fc 01       	movw	r30, r24
    362a:	11 82       	std	Z+1, r1	; 0x01
    362c:	fc 01       	movw	r30, r24
    362e:	12 82       	std	Z+2, r1	; 0x02
    3630:	fc 01       	movw	r30, r24
    3632:	13 82       	std	Z+3, r1	; 0x03
    3634:	fc 01       	movw	r30, r24
    3636:	14 82       	std	Z+4, r1	; 0x04
    3638:	fc 01       	movw	r30, r24
    363a:	15 82       	std	Z+5, r1	; 0x05
    363c:	fc 01       	movw	r30, r24
    363e:	16 82       	std	Z+6, r1	; 0x06
    3640:	fc 01       	movw	r30, r24
    3642:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    3644:	80 91 5b 50 	lds	r24, 0x505B
    3648:	90 91 5c 50 	lds	r25, 0x505C
    364c:	02 96       	adiw	r24, 0x02	; 2
    364e:	2b 81       	ldd	r18, Y+3	; 0x03
    3650:	3c 81       	ldd	r19, Y+4	; 0x04
    3652:	29 52       	subi	r18, 0x29	; 41
    3654:	3c 4d       	sbci	r19, 0xDC	; 220
    3656:	f9 01       	movw	r30, r18
    3658:	20 81       	ld	r18, Z
    365a:	fc 01       	movw	r30, r24
    365c:	20 83       	st	Z, r18
    365e:	24 c0       	rjmp	.+72     	; 0x36a8 <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    3660:	8b 81       	ldd	r24, Y+3	; 0x03
    3662:	9c 81       	ldd	r25, Y+4	; 0x04
    3664:	23 e0       	ldi	r18, 0x03	; 3
    3666:	30 e0       	ldi	r19, 0x00	; 0
    3668:	b9 01       	movw	r22, r18
    366a:	0e 94 6c 60 	call	0xc0d8	; 0xc0d8 <__udivmodhi4>
    366e:	81 30       	cpi	r24, 0x01	; 1
    3670:	91 05       	cpc	r25, r1
    3672:	71 f4       	brne	.+28     	; 0x3690 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    3674:	80 91 5b 50 	lds	r24, 0x505B
    3678:	90 91 5c 50 	lds	r25, 0x505C
    367c:	01 96       	adiw	r24, 0x01	; 1
    367e:	2b 81       	ldd	r18, Y+3	; 0x03
    3680:	3c 81       	ldd	r19, Y+4	; 0x04
    3682:	29 52       	subi	r18, 0x29	; 41
    3684:	3c 4d       	sbci	r19, 0xDC	; 220
    3686:	f9 01       	movw	r30, r18
    3688:	20 81       	ld	r18, Z
    368a:	fc 01       	movw	r30, r24
    368c:	20 83       	st	Z, r18
    368e:	0c c0       	rjmp	.+24     	; 0x36a8 <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    3690:	80 91 5b 50 	lds	r24, 0x505B
    3694:	90 91 5c 50 	lds	r25, 0x505C
    3698:	2b 81       	ldd	r18, Y+3	; 0x03
    369a:	3c 81       	ldd	r19, Y+4	; 0x04
    369c:	29 52       	subi	r18, 0x29	; 41
    369e:	3c 4d       	sbci	r19, 0xDC	; 220
    36a0:	f9 01       	movw	r30, r18
    36a2:	20 81       	ld	r18, Z
    36a4:	fc 01       	movw	r30, r24
    36a6:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    36a8:	8b 81       	ldd	r24, Y+3	; 0x03
    36aa:	9c 81       	ldd	r25, Y+4	; 0x04
    36ac:	29 e0       	ldi	r18, 0x09	; 9
    36ae:	30 e0       	ldi	r19, 0x00	; 0
    36b0:	b9 01       	movw	r22, r18
    36b2:	0e 94 6c 60 	call	0xc0d8	; 0xc0d8 <__udivmodhi4>
    36b6:	82 30       	cpi	r24, 0x02	; 2
    36b8:	91 05       	cpc	r25, r1
    36ba:	09 f0       	breq	.+2      	; 0x36be <calcChecksumFRAM+0x212>
    36bc:	94 c0       	rjmp	.+296    	; 0x37e6 <calcChecksumFRAM+0x33a>
    36be:	a0 90 83 50 	lds	r10, 0x5083
    36c2:	b0 90 84 50 	lds	r11, 0x5084
    36c6:	c0 90 85 50 	lds	r12, 0x5085
    36ca:	d0 90 86 50 	lds	r13, 0x5086
    36ce:	e0 90 87 50 	lds	r14, 0x5087
    36d2:	f0 90 88 50 	lds	r15, 0x5088
    36d6:	00 91 89 50 	lds	r16, 0x5089
    36da:	10 91 8a 50 	lds	r17, 0x508A
    36de:	80 91 5b 50 	lds	r24, 0x505B
    36e2:	90 91 5c 50 	lds	r25, 0x505C
    36e6:	fc 01       	movw	r30, r24
    36e8:	20 80       	ld	r2, Z
    36ea:	fc 01       	movw	r30, r24
    36ec:	31 80       	ldd	r3, Z+1	; 0x01
    36ee:	fc 01       	movw	r30, r24
    36f0:	42 80       	ldd	r4, Z+2	; 0x02
    36f2:	fc 01       	movw	r30, r24
    36f4:	53 80       	ldd	r5, Z+3	; 0x03
    36f6:	fc 01       	movw	r30, r24
    36f8:	64 80       	ldd	r6, Z+4	; 0x04
    36fa:	fc 01       	movw	r30, r24
    36fc:	75 80       	ldd	r7, Z+5	; 0x05
    36fe:	fc 01       	movw	r30, r24
    3700:	86 80       	ldd	r8, Z+6	; 0x06
    3702:	fc 01       	movw	r30, r24
    3704:	97 80       	ldd	r9, Z+7	; 0x07
    3706:	2a 2d       	mov	r18, r10
    3708:	22 0d       	add	r18, r2
    370a:	e1 e0       	ldi	r30, 0x01	; 1
    370c:	2a 15       	cp	r18, r10
    370e:	08 f0       	brcs	.+2      	; 0x3712 <calcChecksumFRAM+0x266>
    3710:	e0 e0       	ldi	r30, 0x00	; 0
    3712:	3b 2d       	mov	r19, r11
    3714:	33 0d       	add	r19, r3
    3716:	f1 e0       	ldi	r31, 0x01	; 1
    3718:	3b 15       	cp	r19, r11
    371a:	08 f0       	brcs	.+2      	; 0x371e <calcChecksumFRAM+0x272>
    371c:	f0 e0       	ldi	r31, 0x00	; 0
    371e:	e3 0f       	add	r30, r19
    3720:	a1 e0       	ldi	r26, 0x01	; 1
    3722:	e3 17       	cp	r30, r19
    3724:	08 f0       	brcs	.+2      	; 0x3728 <calcChecksumFRAM+0x27c>
    3726:	a0 e0       	ldi	r26, 0x00	; 0
    3728:	fa 2b       	or	r31, r26
    372a:	3e 2f       	mov	r19, r30
    372c:	4c 2d       	mov	r20, r12
    372e:	44 0d       	add	r20, r4
    3730:	e1 e0       	ldi	r30, 0x01	; 1
    3732:	4c 15       	cp	r20, r12
    3734:	08 f0       	brcs	.+2      	; 0x3738 <calcChecksumFRAM+0x28c>
    3736:	e0 e0       	ldi	r30, 0x00	; 0
    3738:	f4 0f       	add	r31, r20
    373a:	a1 e0       	ldi	r26, 0x01	; 1
    373c:	f4 17       	cp	r31, r20
    373e:	08 f0       	brcs	.+2      	; 0x3742 <calcChecksumFRAM+0x296>
    3740:	a0 e0       	ldi	r26, 0x00	; 0
    3742:	ea 2b       	or	r30, r26
    3744:	4f 2f       	mov	r20, r31
    3746:	5d 2d       	mov	r21, r13
    3748:	55 0d       	add	r21, r5
    374a:	f1 e0       	ldi	r31, 0x01	; 1
    374c:	5d 15       	cp	r21, r13
    374e:	08 f0       	brcs	.+2      	; 0x3752 <calcChecksumFRAM+0x2a6>
    3750:	f0 e0       	ldi	r31, 0x00	; 0
    3752:	e5 0f       	add	r30, r21
    3754:	a1 e0       	ldi	r26, 0x01	; 1
    3756:	e5 17       	cp	r30, r21
    3758:	08 f0       	brcs	.+2      	; 0x375c <calcChecksumFRAM+0x2b0>
    375a:	a0 e0       	ldi	r26, 0x00	; 0
    375c:	fa 2b       	or	r31, r26
    375e:	5e 2f       	mov	r21, r30
    3760:	6e 2d       	mov	r22, r14
    3762:	66 0d       	add	r22, r6
    3764:	e1 e0       	ldi	r30, 0x01	; 1
    3766:	6e 15       	cp	r22, r14
    3768:	08 f0       	brcs	.+2      	; 0x376c <calcChecksumFRAM+0x2c0>
    376a:	e0 e0       	ldi	r30, 0x00	; 0
    376c:	f6 0f       	add	r31, r22
    376e:	a1 e0       	ldi	r26, 0x01	; 1
    3770:	f6 17       	cp	r31, r22
    3772:	08 f0       	brcs	.+2      	; 0x3776 <calcChecksumFRAM+0x2ca>
    3774:	a0 e0       	ldi	r26, 0x00	; 0
    3776:	ea 2b       	or	r30, r26
    3778:	6f 2f       	mov	r22, r31
    377a:	7f 2d       	mov	r23, r15
    377c:	77 0d       	add	r23, r7
    377e:	f1 e0       	ldi	r31, 0x01	; 1
    3780:	7f 15       	cp	r23, r15
    3782:	08 f0       	brcs	.+2      	; 0x3786 <calcChecksumFRAM+0x2da>
    3784:	f0 e0       	ldi	r31, 0x00	; 0
    3786:	e7 0f       	add	r30, r23
    3788:	a1 e0       	ldi	r26, 0x01	; 1
    378a:	e7 17       	cp	r30, r23
    378c:	08 f0       	brcs	.+2      	; 0x3790 <calcChecksumFRAM+0x2e4>
    378e:	a0 e0       	ldi	r26, 0x00	; 0
    3790:	fa 2b       	or	r31, r26
    3792:	7e 2f       	mov	r23, r30
    3794:	80 2f       	mov	r24, r16
    3796:	88 0d       	add	r24, r8
    3798:	e1 e0       	ldi	r30, 0x01	; 1
    379a:	80 17       	cp	r24, r16
    379c:	08 f0       	brcs	.+2      	; 0x37a0 <calcChecksumFRAM+0x2f4>
    379e:	e0 e0       	ldi	r30, 0x00	; 0
    37a0:	f8 0f       	add	r31, r24
    37a2:	a1 e0       	ldi	r26, 0x01	; 1
    37a4:	f8 17       	cp	r31, r24
    37a6:	08 f0       	brcs	.+2      	; 0x37aa <calcChecksumFRAM+0x2fe>
    37a8:	a0 e0       	ldi	r26, 0x00	; 0
    37aa:	ea 2b       	or	r30, r26
    37ac:	8f 2f       	mov	r24, r31
    37ae:	91 2f       	mov	r25, r17
    37b0:	99 0d       	add	r25, r9
    37b2:	e9 0f       	add	r30, r25
    37b4:	9e 2f       	mov	r25, r30
    37b6:	a2 2e       	mov	r10, r18
    37b8:	b3 2e       	mov	r11, r19
    37ba:	c4 2e       	mov	r12, r20
    37bc:	d5 2e       	mov	r13, r21
    37be:	e6 2e       	mov	r14, r22
    37c0:	f7 2e       	mov	r15, r23
    37c2:	08 2f       	mov	r16, r24
    37c4:	19 2f       	mov	r17, r25
    37c6:	a0 92 83 50 	sts	0x5083, r10
    37ca:	b0 92 84 50 	sts	0x5084, r11
    37ce:	c0 92 85 50 	sts	0x5085, r12
    37d2:	d0 92 86 50 	sts	0x5086, r13
    37d6:	e0 92 87 50 	sts	0x5087, r14
    37da:	f0 92 88 50 	sts	0x5088, r15
    37de:	00 93 89 50 	sts	0x5089, r16
    37e2:	10 93 8a 50 	sts	0x508A, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    37e6:	8b 81       	ldd	r24, Y+3	; 0x03
    37e8:	9c 81       	ldd	r25, Y+4	; 0x04
    37ea:	29 e0       	ldi	r18, 0x09	; 9
    37ec:	30 e0       	ldi	r19, 0x00	; 0
    37ee:	b9 01       	movw	r22, r18
    37f0:	0e 94 6c 60 	call	0xc0d8	; 0xc0d8 <__udivmodhi4>
    37f4:	85 30       	cpi	r24, 0x05	; 5
    37f6:	91 05       	cpc	r25, r1
    37f8:	09 f0       	breq	.+2      	; 0x37fc <calcChecksumFRAM+0x350>
    37fa:	94 c0       	rjmp	.+296    	; 0x3924 <calcChecksumFRAM+0x478>
    37fc:	a0 90 8b 50 	lds	r10, 0x508B
    3800:	b0 90 8c 50 	lds	r11, 0x508C
    3804:	c0 90 8d 50 	lds	r12, 0x508D
    3808:	d0 90 8e 50 	lds	r13, 0x508E
    380c:	e0 90 8f 50 	lds	r14, 0x508F
    3810:	f0 90 90 50 	lds	r15, 0x5090
    3814:	00 91 91 50 	lds	r16, 0x5091
    3818:	10 91 92 50 	lds	r17, 0x5092
    381c:	80 91 5b 50 	lds	r24, 0x505B
    3820:	90 91 5c 50 	lds	r25, 0x505C
    3824:	fc 01       	movw	r30, r24
    3826:	20 80       	ld	r2, Z
    3828:	fc 01       	movw	r30, r24
    382a:	31 80       	ldd	r3, Z+1	; 0x01
    382c:	fc 01       	movw	r30, r24
    382e:	42 80       	ldd	r4, Z+2	; 0x02
    3830:	fc 01       	movw	r30, r24
    3832:	53 80       	ldd	r5, Z+3	; 0x03
    3834:	fc 01       	movw	r30, r24
    3836:	64 80       	ldd	r6, Z+4	; 0x04
    3838:	fc 01       	movw	r30, r24
    383a:	75 80       	ldd	r7, Z+5	; 0x05
    383c:	fc 01       	movw	r30, r24
    383e:	86 80       	ldd	r8, Z+6	; 0x06
    3840:	fc 01       	movw	r30, r24
    3842:	97 80       	ldd	r9, Z+7	; 0x07
    3844:	2a 2d       	mov	r18, r10
    3846:	22 0d       	add	r18, r2
    3848:	e1 e0       	ldi	r30, 0x01	; 1
    384a:	2a 15       	cp	r18, r10
    384c:	08 f0       	brcs	.+2      	; 0x3850 <calcChecksumFRAM+0x3a4>
    384e:	e0 e0       	ldi	r30, 0x00	; 0
    3850:	3b 2d       	mov	r19, r11
    3852:	33 0d       	add	r19, r3
    3854:	f1 e0       	ldi	r31, 0x01	; 1
    3856:	3b 15       	cp	r19, r11
    3858:	08 f0       	brcs	.+2      	; 0x385c <calcChecksumFRAM+0x3b0>
    385a:	f0 e0       	ldi	r31, 0x00	; 0
    385c:	e3 0f       	add	r30, r19
    385e:	a1 e0       	ldi	r26, 0x01	; 1
    3860:	e3 17       	cp	r30, r19
    3862:	08 f0       	brcs	.+2      	; 0x3866 <calcChecksumFRAM+0x3ba>
    3864:	a0 e0       	ldi	r26, 0x00	; 0
    3866:	fa 2b       	or	r31, r26
    3868:	3e 2f       	mov	r19, r30
    386a:	4c 2d       	mov	r20, r12
    386c:	44 0d       	add	r20, r4
    386e:	e1 e0       	ldi	r30, 0x01	; 1
    3870:	4c 15       	cp	r20, r12
    3872:	08 f0       	brcs	.+2      	; 0x3876 <calcChecksumFRAM+0x3ca>
    3874:	e0 e0       	ldi	r30, 0x00	; 0
    3876:	f4 0f       	add	r31, r20
    3878:	a1 e0       	ldi	r26, 0x01	; 1
    387a:	f4 17       	cp	r31, r20
    387c:	08 f0       	brcs	.+2      	; 0x3880 <calcChecksumFRAM+0x3d4>
    387e:	a0 e0       	ldi	r26, 0x00	; 0
    3880:	ea 2b       	or	r30, r26
    3882:	4f 2f       	mov	r20, r31
    3884:	5d 2d       	mov	r21, r13
    3886:	55 0d       	add	r21, r5
    3888:	f1 e0       	ldi	r31, 0x01	; 1
    388a:	5d 15       	cp	r21, r13
    388c:	08 f0       	brcs	.+2      	; 0x3890 <calcChecksumFRAM+0x3e4>
    388e:	f0 e0       	ldi	r31, 0x00	; 0
    3890:	e5 0f       	add	r30, r21
    3892:	a1 e0       	ldi	r26, 0x01	; 1
    3894:	e5 17       	cp	r30, r21
    3896:	08 f0       	brcs	.+2      	; 0x389a <calcChecksumFRAM+0x3ee>
    3898:	a0 e0       	ldi	r26, 0x00	; 0
    389a:	fa 2b       	or	r31, r26
    389c:	5e 2f       	mov	r21, r30
    389e:	6e 2d       	mov	r22, r14
    38a0:	66 0d       	add	r22, r6
    38a2:	e1 e0       	ldi	r30, 0x01	; 1
    38a4:	6e 15       	cp	r22, r14
    38a6:	08 f0       	brcs	.+2      	; 0x38aa <calcChecksumFRAM+0x3fe>
    38a8:	e0 e0       	ldi	r30, 0x00	; 0
    38aa:	f6 0f       	add	r31, r22
    38ac:	a1 e0       	ldi	r26, 0x01	; 1
    38ae:	f6 17       	cp	r31, r22
    38b0:	08 f0       	brcs	.+2      	; 0x38b4 <calcChecksumFRAM+0x408>
    38b2:	a0 e0       	ldi	r26, 0x00	; 0
    38b4:	ea 2b       	or	r30, r26
    38b6:	6f 2f       	mov	r22, r31
    38b8:	7f 2d       	mov	r23, r15
    38ba:	77 0d       	add	r23, r7
    38bc:	f1 e0       	ldi	r31, 0x01	; 1
    38be:	7f 15       	cp	r23, r15
    38c0:	08 f0       	brcs	.+2      	; 0x38c4 <calcChecksumFRAM+0x418>
    38c2:	f0 e0       	ldi	r31, 0x00	; 0
    38c4:	e7 0f       	add	r30, r23
    38c6:	a1 e0       	ldi	r26, 0x01	; 1
    38c8:	e7 17       	cp	r30, r23
    38ca:	08 f0       	brcs	.+2      	; 0x38ce <calcChecksumFRAM+0x422>
    38cc:	a0 e0       	ldi	r26, 0x00	; 0
    38ce:	fa 2b       	or	r31, r26
    38d0:	7e 2f       	mov	r23, r30
    38d2:	80 2f       	mov	r24, r16
    38d4:	88 0d       	add	r24, r8
    38d6:	e1 e0       	ldi	r30, 0x01	; 1
    38d8:	80 17       	cp	r24, r16
    38da:	08 f0       	brcs	.+2      	; 0x38de <calcChecksumFRAM+0x432>
    38dc:	e0 e0       	ldi	r30, 0x00	; 0
    38de:	f8 0f       	add	r31, r24
    38e0:	a1 e0       	ldi	r26, 0x01	; 1
    38e2:	f8 17       	cp	r31, r24
    38e4:	08 f0       	brcs	.+2      	; 0x38e8 <calcChecksumFRAM+0x43c>
    38e6:	a0 e0       	ldi	r26, 0x00	; 0
    38e8:	ea 2b       	or	r30, r26
    38ea:	8f 2f       	mov	r24, r31
    38ec:	91 2f       	mov	r25, r17
    38ee:	99 0d       	add	r25, r9
    38f0:	e9 0f       	add	r30, r25
    38f2:	9e 2f       	mov	r25, r30
    38f4:	a2 2e       	mov	r10, r18
    38f6:	b3 2e       	mov	r11, r19
    38f8:	c4 2e       	mov	r12, r20
    38fa:	d5 2e       	mov	r13, r21
    38fc:	e6 2e       	mov	r14, r22
    38fe:	f7 2e       	mov	r15, r23
    3900:	08 2f       	mov	r16, r24
    3902:	19 2f       	mov	r17, r25
    3904:	a0 92 8b 50 	sts	0x508B, r10
    3908:	b0 92 8c 50 	sts	0x508C, r11
    390c:	c0 92 8d 50 	sts	0x508D, r12
    3910:	d0 92 8e 50 	sts	0x508E, r13
    3914:	e0 92 8f 50 	sts	0x508F, r14
    3918:	f0 92 90 50 	sts	0x5090, r15
    391c:	00 93 91 50 	sts	0x5091, r16
    3920:	10 93 92 50 	sts	0x5092, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    3924:	8b 81       	ldd	r24, Y+3	; 0x03
    3926:	9c 81       	ldd	r25, Y+4	; 0x04
    3928:	29 e0       	ldi	r18, 0x09	; 9
    392a:	30 e0       	ldi	r19, 0x00	; 0
    392c:	b9 01       	movw	r22, r18
    392e:	0e 94 6c 60 	call	0xc0d8	; 0xc0d8 <__udivmodhi4>
    3932:	88 30       	cpi	r24, 0x08	; 8
    3934:	91 05       	cpc	r25, r1
    3936:	09 f0       	breq	.+2      	; 0x393a <calcChecksumFRAM+0x48e>
    3938:	94 c0       	rjmp	.+296    	; 0x3a62 <calcChecksumFRAM+0x5b6>
    393a:	a0 90 93 50 	lds	r10, 0x5093
    393e:	b0 90 94 50 	lds	r11, 0x5094
    3942:	c0 90 95 50 	lds	r12, 0x5095
    3946:	d0 90 96 50 	lds	r13, 0x5096
    394a:	e0 90 97 50 	lds	r14, 0x5097
    394e:	f0 90 98 50 	lds	r15, 0x5098
    3952:	00 91 99 50 	lds	r16, 0x5099
    3956:	10 91 9a 50 	lds	r17, 0x509A
    395a:	80 91 5b 50 	lds	r24, 0x505B
    395e:	90 91 5c 50 	lds	r25, 0x505C
    3962:	fc 01       	movw	r30, r24
    3964:	20 80       	ld	r2, Z
    3966:	fc 01       	movw	r30, r24
    3968:	31 80       	ldd	r3, Z+1	; 0x01
    396a:	fc 01       	movw	r30, r24
    396c:	42 80       	ldd	r4, Z+2	; 0x02
    396e:	fc 01       	movw	r30, r24
    3970:	53 80       	ldd	r5, Z+3	; 0x03
    3972:	fc 01       	movw	r30, r24
    3974:	64 80       	ldd	r6, Z+4	; 0x04
    3976:	fc 01       	movw	r30, r24
    3978:	75 80       	ldd	r7, Z+5	; 0x05
    397a:	fc 01       	movw	r30, r24
    397c:	86 80       	ldd	r8, Z+6	; 0x06
    397e:	fc 01       	movw	r30, r24
    3980:	97 80       	ldd	r9, Z+7	; 0x07
    3982:	2a 2d       	mov	r18, r10
    3984:	22 0d       	add	r18, r2
    3986:	e1 e0       	ldi	r30, 0x01	; 1
    3988:	2a 15       	cp	r18, r10
    398a:	08 f0       	brcs	.+2      	; 0x398e <calcChecksumFRAM+0x4e2>
    398c:	e0 e0       	ldi	r30, 0x00	; 0
    398e:	3b 2d       	mov	r19, r11
    3990:	33 0d       	add	r19, r3
    3992:	f1 e0       	ldi	r31, 0x01	; 1
    3994:	3b 15       	cp	r19, r11
    3996:	08 f0       	brcs	.+2      	; 0x399a <calcChecksumFRAM+0x4ee>
    3998:	f0 e0       	ldi	r31, 0x00	; 0
    399a:	e3 0f       	add	r30, r19
    399c:	a1 e0       	ldi	r26, 0x01	; 1
    399e:	e3 17       	cp	r30, r19
    39a0:	08 f0       	brcs	.+2      	; 0x39a4 <calcChecksumFRAM+0x4f8>
    39a2:	a0 e0       	ldi	r26, 0x00	; 0
    39a4:	fa 2b       	or	r31, r26
    39a6:	3e 2f       	mov	r19, r30
    39a8:	4c 2d       	mov	r20, r12
    39aa:	44 0d       	add	r20, r4
    39ac:	e1 e0       	ldi	r30, 0x01	; 1
    39ae:	4c 15       	cp	r20, r12
    39b0:	08 f0       	brcs	.+2      	; 0x39b4 <calcChecksumFRAM+0x508>
    39b2:	e0 e0       	ldi	r30, 0x00	; 0
    39b4:	f4 0f       	add	r31, r20
    39b6:	a1 e0       	ldi	r26, 0x01	; 1
    39b8:	f4 17       	cp	r31, r20
    39ba:	08 f0       	brcs	.+2      	; 0x39be <calcChecksumFRAM+0x512>
    39bc:	a0 e0       	ldi	r26, 0x00	; 0
    39be:	ea 2b       	or	r30, r26
    39c0:	4f 2f       	mov	r20, r31
    39c2:	5d 2d       	mov	r21, r13
    39c4:	55 0d       	add	r21, r5
    39c6:	f1 e0       	ldi	r31, 0x01	; 1
    39c8:	5d 15       	cp	r21, r13
    39ca:	08 f0       	brcs	.+2      	; 0x39ce <calcChecksumFRAM+0x522>
    39cc:	f0 e0       	ldi	r31, 0x00	; 0
    39ce:	e5 0f       	add	r30, r21
    39d0:	a1 e0       	ldi	r26, 0x01	; 1
    39d2:	e5 17       	cp	r30, r21
    39d4:	08 f0       	brcs	.+2      	; 0x39d8 <calcChecksumFRAM+0x52c>
    39d6:	a0 e0       	ldi	r26, 0x00	; 0
    39d8:	fa 2b       	or	r31, r26
    39da:	5e 2f       	mov	r21, r30
    39dc:	6e 2d       	mov	r22, r14
    39de:	66 0d       	add	r22, r6
    39e0:	e1 e0       	ldi	r30, 0x01	; 1
    39e2:	6e 15       	cp	r22, r14
    39e4:	08 f0       	brcs	.+2      	; 0x39e8 <calcChecksumFRAM+0x53c>
    39e6:	e0 e0       	ldi	r30, 0x00	; 0
    39e8:	f6 0f       	add	r31, r22
    39ea:	a1 e0       	ldi	r26, 0x01	; 1
    39ec:	f6 17       	cp	r31, r22
    39ee:	08 f0       	brcs	.+2      	; 0x39f2 <calcChecksumFRAM+0x546>
    39f0:	a0 e0       	ldi	r26, 0x00	; 0
    39f2:	ea 2b       	or	r30, r26
    39f4:	6f 2f       	mov	r22, r31
    39f6:	7f 2d       	mov	r23, r15
    39f8:	77 0d       	add	r23, r7
    39fa:	f1 e0       	ldi	r31, 0x01	; 1
    39fc:	7f 15       	cp	r23, r15
    39fe:	08 f0       	brcs	.+2      	; 0x3a02 <calcChecksumFRAM+0x556>
    3a00:	f0 e0       	ldi	r31, 0x00	; 0
    3a02:	e7 0f       	add	r30, r23
    3a04:	a1 e0       	ldi	r26, 0x01	; 1
    3a06:	e7 17       	cp	r30, r23
    3a08:	08 f0       	brcs	.+2      	; 0x3a0c <calcChecksumFRAM+0x560>
    3a0a:	a0 e0       	ldi	r26, 0x00	; 0
    3a0c:	fa 2b       	or	r31, r26
    3a0e:	7e 2f       	mov	r23, r30
    3a10:	80 2f       	mov	r24, r16
    3a12:	88 0d       	add	r24, r8
    3a14:	e1 e0       	ldi	r30, 0x01	; 1
    3a16:	80 17       	cp	r24, r16
    3a18:	08 f0       	brcs	.+2      	; 0x3a1c <calcChecksumFRAM+0x570>
    3a1a:	e0 e0       	ldi	r30, 0x00	; 0
    3a1c:	f8 0f       	add	r31, r24
    3a1e:	a1 e0       	ldi	r26, 0x01	; 1
    3a20:	f8 17       	cp	r31, r24
    3a22:	08 f0       	brcs	.+2      	; 0x3a26 <calcChecksumFRAM+0x57a>
    3a24:	a0 e0       	ldi	r26, 0x00	; 0
    3a26:	ea 2b       	or	r30, r26
    3a28:	8f 2f       	mov	r24, r31
    3a2a:	91 2f       	mov	r25, r17
    3a2c:	99 0d       	add	r25, r9
    3a2e:	e9 0f       	add	r30, r25
    3a30:	9e 2f       	mov	r25, r30
    3a32:	a2 2e       	mov	r10, r18
    3a34:	b3 2e       	mov	r11, r19
    3a36:	c4 2e       	mov	r12, r20
    3a38:	d5 2e       	mov	r13, r21
    3a3a:	e6 2e       	mov	r14, r22
    3a3c:	f7 2e       	mov	r15, r23
    3a3e:	08 2f       	mov	r16, r24
    3a40:	19 2f       	mov	r17, r25
    3a42:	a0 92 93 50 	sts	0x5093, r10
    3a46:	b0 92 94 50 	sts	0x5094, r11
    3a4a:	c0 92 95 50 	sts	0x5095, r12
    3a4e:	d0 92 96 50 	sts	0x5096, r13
    3a52:	e0 92 97 50 	sts	0x5097, r14
    3a56:	f0 92 98 50 	sts	0x5098, r15
    3a5a:	00 93 99 50 	sts	0x5099, r16
    3a5e:	10 93 9a 50 	sts	0x509A, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3a62:	8b 81       	ldd	r24, Y+3	; 0x03
    3a64:	9c 81       	ldd	r25, Y+4	; 0x04
    3a66:	01 96       	adiw	r24, 0x01	; 1
    3a68:	8b 83       	std	Y+3, r24	; 0x03
    3a6a:	9c 83       	std	Y+4, r25	; 0x04
    3a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a70:	fc e1       	ldi	r31, 0x1C	; 28
    3a72:	81 37       	cpi	r24, 0x71	; 113
    3a74:	9f 07       	cpc	r25, r31
    3a76:	08 f4       	brcc	.+2      	; 0x3a7a <calcChecksumFRAM+0x5ce>
    3a78:	8e cd       	rjmp	.-1252   	; 0x3596 <calcChecksumFRAM+0xea>
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3a7a:	89 81       	ldd	r24, Y+1	; 0x01
    3a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a7e:	01 96       	adiw	r24, 0x01	; 1
    3a80:	89 83       	std	Y+1, r24	; 0x01
    3a82:	9a 83       	std	Y+2, r25	; 0x02
    3a84:	89 81       	ldd	r24, Y+1	; 0x01
    3a86:	9a 81       	ldd	r25, Y+2	; 0x02
    3a88:	89 30       	cpi	r24, 0x09	; 9
    3a8a:	91 05       	cpc	r25, r1
    3a8c:	08 f4       	brcc	.+2      	; 0x3a90 <calcChecksumFRAM+0x5e4>
    3a8e:	72 cd       	rjmp	.-1308   	; 0x3574 <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3a90:	24 96       	adiw	r28, 0x04	; 4
    3a92:	cd bf       	out	0x3d, r28	; 61
    3a94:	de bf       	out	0x3e, r29	; 62
    3a96:	df 91       	pop	r29
    3a98:	cf 91       	pop	r28
    3a9a:	1f 91       	pop	r17
    3a9c:	0f 91       	pop	r16
    3a9e:	ff 90       	pop	r15
    3aa0:	ef 90       	pop	r14
    3aa2:	df 90       	pop	r13
    3aa4:	cf 90       	pop	r12
    3aa6:	bf 90       	pop	r11
    3aa8:	af 90       	pop	r10
    3aaa:	9f 90       	pop	r9
    3aac:	8f 90       	pop	r8
    3aae:	7f 90       	pop	r7
    3ab0:	6f 90       	pop	r6
    3ab2:	5f 90       	pop	r5
    3ab4:	4f 90       	pop	r4
    3ab6:	3f 90       	pop	r3
    3ab8:	2f 90       	pop	r2
    3aba:	08 95       	ret

00003abc <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    3abc:	cf 93       	push	r28
    3abe:	df 93       	push	r29
    3ac0:	cd b7       	in	r28, 0x3d	; 61
    3ac2:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    3ac4:	10 92 4f 40 	sts	0x404F, r1
    3ac8:	10 92 50 40 	sts	0x4050, r1
	sampleCount = 0;
    3acc:	10 92 6c 50 	sts	0x506C, r1
    3ad0:	10 92 6d 50 	sts	0x506D, r1
    3ad4:	10 92 6e 50 	sts	0x506E, r1
    3ad8:	10 92 6f 50 	sts	0x506F, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3adc:	80 e0       	ldi	r24, 0x00	; 0
    3ade:	80 93 32 21 	sts	0x2132, r24
    3ae2:	80 93 31 21 	sts	0x2131, r24
    3ae6:	80 93 30 21 	sts	0x2130, r24
	
	ADCPower(TRUE);
    3aea:	81 e0       	ldi	r24, 0x01	; 1
    3aec:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    3af0:	84 e0       	ldi	r24, 0x04	; 4
    3af2:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3af6:	80 ec       	ldi	r24, 0xC0	; 192
    3af8:	98 e0       	ldi	r25, 0x08	; 8
    3afa:	20 ed       	ldi	r18, 0xD0	; 208
    3afc:	fc 01       	movw	r30, r24
    3afe:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    3b00:	8d e0       	ldi	r24, 0x0D	; 13
    3b02:	80 93 5d 50 	sts	0x505D, r24
	SPIBuffer[1] = 0xF3;
    3b06:	83 ef       	ldi	r24, 0xF3	; 243
    3b08:	80 93 5e 50 	sts	0x505E, r24
	SPIBuffer[2] = 0x57;
    3b0c:	87 e5       	ldi	r24, 0x57	; 87
    3b0e:	80 93 5f 50 	sts	0x505F, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3b12:	d7 c0       	rjmp	.+430    	; 0x3cc2 <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    3b14:	80 e4       	ldi	r24, 0x40	; 64
    3b16:	96 e0       	ldi	r25, 0x06	; 6
    3b18:	20 e1       	ldi	r18, 0x10	; 16
    3b1a:	fc 01       	movw	r30, r24
    3b1c:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3b1e:	80 e2       	ldi	r24, 0x20	; 32
    3b20:	96 e0       	ldi	r25, 0x06	; 6
    3b22:	28 e0       	ldi	r18, 0x08	; 8
    3b24:	fc 01       	movw	r30, r24
    3b26:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3b28:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3b2a:	80 ec       	ldi	r24, 0xC0	; 192
    3b2c:	98 e0       	ldi	r25, 0x08	; 8
    3b2e:	26 e0       	ldi	r18, 0x06	; 6
    3b30:	fc 01       	movw	r30, r24
    3b32:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3b34:	00 00       	nop
    3b36:	80 ec       	ldi	r24, 0xC0	; 192
    3b38:	98 e0       	ldi	r25, 0x08	; 8
    3b3a:	fc 01       	movw	r30, r24
    3b3c:	82 81       	ldd	r24, Z+2	; 0x02
    3b3e:	88 23       	and	r24, r24
    3b40:	d4 f7       	brge	.-12     	; 0x3b36 <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3b42:	80 ec       	ldi	r24, 0xC0	; 192
    3b44:	98 e0       	ldi	r25, 0x08	; 8
    3b46:	fc 01       	movw	r30, r24
    3b48:	83 81       	ldd	r24, Z+3	; 0x03
    3b4a:	80 93 69 50 	sts	0x5069, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3b4e:	80 e2       	ldi	r24, 0x20	; 32
    3b50:	96 e0       	ldi	r25, 0x06	; 6
    3b52:	28 e0       	ldi	r18, 0x08	; 8
    3b54:	fc 01       	movw	r30, r24
    3b56:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    3b58:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3b5a:	80 e2       	ldi	r24, 0x20	; 32
    3b5c:	96 e0       	ldi	r25, 0x06	; 6
    3b5e:	28 e0       	ldi	r18, 0x08	; 8
    3b60:	fc 01       	movw	r30, r24
    3b62:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3b64:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    3b66:	80 ec       	ldi	r24, 0xC0	; 192
    3b68:	98 e0       	ldi	r25, 0x08	; 8
    3b6a:	22 e0       	ldi	r18, 0x02	; 2
    3b6c:	fc 01       	movw	r30, r24
    3b6e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3b70:	00 00       	nop
    3b72:	80 ec       	ldi	r24, 0xC0	; 192
    3b74:	98 e0       	ldi	r25, 0x08	; 8
    3b76:	fc 01       	movw	r30, r24
    3b78:	82 81       	ldd	r24, Z+2	; 0x02
    3b7a:	88 23       	and	r24, r24
    3b7c:	d4 f7       	brge	.-12     	; 0x3b72 <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    3b7e:	80 ec       	ldi	r24, 0xC0	; 192
    3b80:	98 e0       	ldi	r25, 0x08	; 8
    3b82:	fc 01       	movw	r30, r24
    3b84:	83 81       	ldd	r24, Z+3	; 0x03
    3b86:	80 93 69 50 	sts	0x5069, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    3b8a:	80 ec       	ldi	r24, 0xC0	; 192
    3b8c:	98 e0       	ldi	r25, 0x08	; 8
    3b8e:	20 91 50 40 	lds	r18, 0x4050
    3b92:	fc 01       	movw	r30, r24
    3b94:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3b96:	00 00       	nop
    3b98:	80 ec       	ldi	r24, 0xC0	; 192
    3b9a:	98 e0       	ldi	r25, 0x08	; 8
    3b9c:	fc 01       	movw	r30, r24
    3b9e:	82 81       	ldd	r24, Z+2	; 0x02
    3ba0:	88 23       	and	r24, r24
    3ba2:	d4 f7       	brge	.-12     	; 0x3b98 <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    3ba4:	80 ec       	ldi	r24, 0xC0	; 192
    3ba6:	98 e0       	ldi	r25, 0x08	; 8
    3ba8:	fc 01       	movw	r30, r24
    3baa:	83 81       	ldd	r24, Z+3	; 0x03
    3bac:	80 93 69 50 	sts	0x5069, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    3bb0:	80 ec       	ldi	r24, 0xC0	; 192
    3bb2:	98 e0       	ldi	r25, 0x08	; 8
    3bb4:	2f e4       	ldi	r18, 0x4F	; 79
    3bb6:	30 e4       	ldi	r19, 0x40	; 64
    3bb8:	f9 01       	movw	r30, r18
    3bba:	20 81       	ld	r18, Z
    3bbc:	fc 01       	movw	r30, r24
    3bbe:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3bc0:	00 00       	nop
    3bc2:	80 ec       	ldi	r24, 0xC0	; 192
    3bc4:	98 e0       	ldi	r25, 0x08	; 8
    3bc6:	fc 01       	movw	r30, r24
    3bc8:	82 81       	ldd	r24, Z+2	; 0x02
    3bca:	88 23       	and	r24, r24
    3bcc:	d4 f7       	brge	.-12     	; 0x3bc2 <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3bce:	80 ec       	ldi	r24, 0xC0	; 192
    3bd0:	98 e0       	ldi	r25, 0x08	; 8
    3bd2:	fc 01       	movw	r30, r24
    3bd4:	83 81       	ldd	r24, Z+3	; 0x03
    3bd6:	80 93 69 50 	sts	0x5069, r24
		SPIC.DATA = SPIBuffer[0];
    3bda:	80 ec       	ldi	r24, 0xC0	; 192
    3bdc:	98 e0       	ldi	r25, 0x08	; 8
    3bde:	20 91 5d 50 	lds	r18, 0x505D
    3be2:	fc 01       	movw	r30, r24
    3be4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3be6:	00 00       	nop
    3be8:	80 ec       	ldi	r24, 0xC0	; 192
    3bea:	98 e0       	ldi	r25, 0x08	; 8
    3bec:	fc 01       	movw	r30, r24
    3bee:	82 81       	ldd	r24, Z+2	; 0x02
    3bf0:	88 23       	and	r24, r24
    3bf2:	d4 f7       	brge	.-12     	; 0x3be8 <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    3bf4:	80 ec       	ldi	r24, 0xC0	; 192
    3bf6:	98 e0       	ldi	r25, 0x08	; 8
    3bf8:	fc 01       	movw	r30, r24
    3bfa:	83 81       	ldd	r24, Z+3	; 0x03
    3bfc:	80 93 69 50 	sts	0x5069, r24
		SPIC.DATA = SPIBuffer[1];
    3c00:	80 ec       	ldi	r24, 0xC0	; 192
    3c02:	98 e0       	ldi	r25, 0x08	; 8
    3c04:	20 91 5e 50 	lds	r18, 0x505E
    3c08:	fc 01       	movw	r30, r24
    3c0a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3c0c:	00 00       	nop
    3c0e:	80 ec       	ldi	r24, 0xC0	; 192
    3c10:	98 e0       	ldi	r25, 0x08	; 8
    3c12:	fc 01       	movw	r30, r24
    3c14:	82 81       	ldd	r24, Z+2	; 0x02
    3c16:	88 23       	and	r24, r24
    3c18:	d4 f7       	brge	.-12     	; 0x3c0e <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    3c1a:	80 ec       	ldi	r24, 0xC0	; 192
    3c1c:	98 e0       	ldi	r25, 0x08	; 8
    3c1e:	fc 01       	movw	r30, r24
    3c20:	83 81       	ldd	r24, Z+3	; 0x03
    3c22:	80 93 69 50 	sts	0x5069, r24
		SPIC.DATA = SPIBuffer[2];
    3c26:	80 ec       	ldi	r24, 0xC0	; 192
    3c28:	98 e0       	ldi	r25, 0x08	; 8
    3c2a:	20 91 5f 50 	lds	r18, 0x505F
    3c2e:	fc 01       	movw	r30, r24
    3c30:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3c32:	00 00       	nop
    3c34:	80 ec       	ldi	r24, 0xC0	; 192
    3c36:	98 e0       	ldi	r25, 0x08	; 8
    3c38:	fc 01       	movw	r30, r24
    3c3a:	82 81       	ldd	r24, Z+2	; 0x02
    3c3c:	88 23       	and	r24, r24
    3c3e:	d4 f7       	brge	.-12     	; 0x3c34 <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    3c40:	80 ec       	ldi	r24, 0xC0	; 192
    3c42:	98 e0       	ldi	r25, 0x08	; 8
    3c44:	fc 01       	movw	r30, r24
    3c46:	83 81       	ldd	r24, Z+3	; 0x03
    3c48:	80 93 69 50 	sts	0x5069, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3c4c:	80 e2       	ldi	r24, 0x20	; 32
    3c4e:	96 e0       	ldi	r25, 0x06	; 6
    3c50:	28 e0       	ldi	r18, 0x08	; 8
    3c52:	fc 01       	movw	r30, r24
    3c54:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3c56:	80 e4       	ldi	r24, 0x40	; 64
    3c58:	96 e0       	ldi	r25, 0x06	; 6
    3c5a:	20 e1       	ldi	r18, 0x10	; 16
    3c5c:	fc 01       	movw	r30, r24
    3c5e:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    3c60:	80 91 4f 40 	lds	r24, 0x404F
    3c64:	90 91 50 40 	lds	r25, 0x4050
    3c68:	03 96       	adiw	r24, 0x03	; 3
    3c6a:	80 93 4f 40 	sts	0x404F, r24
    3c6e:	90 93 50 40 	sts	0x4050, r25
		checksumADC[0] += SPIBuffer[0];
    3c72:	90 91 30 21 	lds	r25, 0x2130
    3c76:	80 91 5d 50 	lds	r24, 0x505D
    3c7a:	89 0f       	add	r24, r25
    3c7c:	80 93 30 21 	sts	0x2130, r24
		checksumADC[1] += SPIBuffer[1];
    3c80:	90 91 31 21 	lds	r25, 0x2131
    3c84:	80 91 5e 50 	lds	r24, 0x505E
    3c88:	89 0f       	add	r24, r25
    3c8a:	80 93 31 21 	sts	0x2131, r24
		checksumADC[2] += SPIBuffer[2];
    3c8e:	90 91 32 21 	lds	r25, 0x2132
    3c92:	80 91 5f 50 	lds	r24, 0x505F
    3c96:	89 0f       	add	r24, r25
    3c98:	80 93 32 21 	sts	0x2132, r24
		
		sampleCount++;
    3c9c:	80 91 6c 50 	lds	r24, 0x506C
    3ca0:	90 91 6d 50 	lds	r25, 0x506D
    3ca4:	a0 91 6e 50 	lds	r26, 0x506E
    3ca8:	b0 91 6f 50 	lds	r27, 0x506F
    3cac:	01 96       	adiw	r24, 0x01	; 1
    3cae:	a1 1d       	adc	r26, r1
    3cb0:	b1 1d       	adc	r27, r1
    3cb2:	80 93 6c 50 	sts	0x506C, r24
    3cb6:	90 93 6d 50 	sts	0x506D, r25
    3cba:	a0 93 6e 50 	sts	0x506E, r26
    3cbe:	b0 93 6f 50 	sts	0x506F, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3cc2:	80 91 6c 50 	lds	r24, 0x506C
    3cc6:	90 91 6d 50 	lds	r25, 0x506D
    3cca:	a0 91 6e 50 	lds	r26, 0x506E
    3cce:	b0 91 6f 50 	lds	r27, 0x506F
    3cd2:	83 35       	cpi	r24, 0x53	; 83
    3cd4:	f5 e5       	ldi	r31, 0x55	; 85
    3cd6:	9f 07       	cpc	r25, r31
    3cd8:	f0 e0       	ldi	r31, 0x00	; 0
    3cda:	af 07       	cpc	r26, r31
    3cdc:	f0 e0       	ldi	r31, 0x00	; 0
    3cde:	bf 07       	cpc	r27, r31
    3ce0:	08 f4       	brcc	.+2      	; 0x3ce4 <FRAMWriteKnowns+0x228>
    3ce2:	18 cf       	rjmp	.-464    	; 0x3b14 <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    3ce4:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	ADCPower(FALSE);
    3ce8:	80 e0       	ldi	r24, 0x00	; 0
    3cea:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
}
    3cee:	df 91       	pop	r29
    3cf0:	cf 91       	pop	r28
    3cf2:	08 95       	ret

00003cf4 <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    3cf4:	cf 93       	push	r28
    3cf6:	df 93       	push	r29
    3cf8:	0f 92       	push	r0
    3cfa:	cd b7       	in	r28, 0x3d	; 61
    3cfc:	de b7       	in	r29, 0x3e	; 62
    3cfe:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    3d00:	89 81       	ldd	r24, Y+1	; 0x01
    3d02:	88 2f       	mov	r24, r24
    3d04:	90 e0       	ldi	r25, 0x00	; 0
    3d06:	81 70       	andi	r24, 0x01	; 1
    3d08:	90 70       	andi	r25, 0x00	; 0
    3d0a:	88 23       	and	r24, r24
    3d0c:	31 f0       	breq	.+12     	; 0x3d1a <setADCInput+0x26>
    3d0e:	80 e0       	ldi	r24, 0x00	; 0
    3d10:	96 e0       	ldi	r25, 0x06	; 6
    3d12:	20 e4       	ldi	r18, 0x40	; 64
    3d14:	fc 01       	movw	r30, r24
    3d16:	25 83       	std	Z+5, r18	; 0x05
    3d18:	05 c0       	rjmp	.+10     	; 0x3d24 <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    3d1a:	80 e0       	ldi	r24, 0x00	; 0
    3d1c:	96 e0       	ldi	r25, 0x06	; 6
    3d1e:	20 e4       	ldi	r18, 0x40	; 64
    3d20:	fc 01       	movw	r30, r24
    3d22:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    3d24:	89 81       	ldd	r24, Y+1	; 0x01
    3d26:	88 2f       	mov	r24, r24
    3d28:	90 e0       	ldi	r25, 0x00	; 0
    3d2a:	82 70       	andi	r24, 0x02	; 2
    3d2c:	90 70       	andi	r25, 0x00	; 0
    3d2e:	00 97       	sbiw	r24, 0x00	; 0
    3d30:	31 f0       	breq	.+12     	; 0x3d3e <setADCInput+0x4a>
    3d32:	80 e2       	ldi	r24, 0x20	; 32
    3d34:	96 e0       	ldi	r25, 0x06	; 6
    3d36:	22 e0       	ldi	r18, 0x02	; 2
    3d38:	fc 01       	movw	r30, r24
    3d3a:	25 83       	std	Z+5, r18	; 0x05
    3d3c:	05 c0       	rjmp	.+10     	; 0x3d48 <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3d3e:	80 e2       	ldi	r24, 0x20	; 32
    3d40:	96 e0       	ldi	r25, 0x06	; 6
    3d42:	22 e0       	ldi	r18, 0x02	; 2
    3d44:	fc 01       	movw	r30, r24
    3d46:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    3d48:	89 81       	ldd	r24, Y+1	; 0x01
    3d4a:	88 2f       	mov	r24, r24
    3d4c:	90 e0       	ldi	r25, 0x00	; 0
    3d4e:	84 70       	andi	r24, 0x04	; 4
    3d50:	90 70       	andi	r25, 0x00	; 0
    3d52:	00 97       	sbiw	r24, 0x00	; 0
    3d54:	31 f0       	breq	.+12     	; 0x3d62 <setADCInput+0x6e>
    3d56:	80 e2       	ldi	r24, 0x20	; 32
    3d58:	96 e0       	ldi	r25, 0x06	; 6
    3d5a:	24 e0       	ldi	r18, 0x04	; 4
    3d5c:	fc 01       	movw	r30, r24
    3d5e:	25 83       	std	Z+5, r18	; 0x05
    3d60:	05 c0       	rjmp	.+10     	; 0x3d6c <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    3d62:	80 e2       	ldi	r24, 0x20	; 32
    3d64:	96 e0       	ldi	r25, 0x06	; 6
    3d66:	24 e0       	ldi	r18, 0x04	; 4
    3d68:	fc 01       	movw	r30, r24
    3d6a:	26 83       	std	Z+6, r18	; 0x06

}
    3d6c:	0f 90       	pop	r0
    3d6e:	df 91       	pop	r29
    3d70:	cf 91       	pop	r28
    3d72:	08 95       	ret

00003d74 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    3d74:	cf 93       	push	r28
    3d76:	df 93       	push	r29
    3d78:	0f 92       	push	r0
    3d7a:	0f 92       	push	r0
    3d7c:	cd b7       	in	r28, 0x3d	; 61
    3d7e:	de b7       	in	r29, 0x3e	; 62
    3d80:	89 83       	std	Y+1, r24	; 0x01
    3d82:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    3d84:	89 81       	ldd	r24, Y+1	; 0x01
    3d86:	9a 81       	ldd	r25, Y+2	; 0x02
    3d88:	22 e0       	ldi	r18, 0x02	; 2
    3d8a:	80 30       	cpi	r24, 0x00	; 0
    3d8c:	92 07       	cpc	r25, r18
    3d8e:	89 f4       	brne	.+34     	; 0x3db2 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3d90:	80 e2       	ldi	r24, 0x20	; 32
    3d92:	0e 94 37 22 	call	0x446e	; 0x446e <SP_ReadCalibrationByte>
    3d96:	28 2f       	mov	r18, r24
    3d98:	89 81       	ldd	r24, Y+1	; 0x01
    3d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9c:	fc 01       	movw	r30, r24
    3d9e:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3da0:	81 e2       	ldi	r24, 0x21	; 33
    3da2:	0e 94 37 22 	call	0x446e	; 0x446e <SP_ReadCalibrationByte>
    3da6:	28 2f       	mov	r18, r24
    3da8:	89 81       	ldd	r24, Y+1	; 0x01
    3daa:	9a 81       	ldd	r25, Y+2	; 0x02
    3dac:	fc 01       	movw	r30, r24
    3dae:	25 87       	std	Z+13, r18	; 0x0d
    3db0:	10 c0       	rjmp	.+32     	; 0x3dd2 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3db2:	84 e2       	ldi	r24, 0x24	; 36
    3db4:	0e 94 37 22 	call	0x446e	; 0x446e <SP_ReadCalibrationByte>
    3db8:	28 2f       	mov	r18, r24
    3dba:	89 81       	ldd	r24, Y+1	; 0x01
    3dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3dbe:	fc 01       	movw	r30, r24
    3dc0:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3dc2:	85 e2       	ldi	r24, 0x25	; 37
    3dc4:	0e 94 37 22 	call	0x446e	; 0x446e <SP_ReadCalibrationByte>
    3dc8:	28 2f       	mov	r18, r24
    3dca:	89 81       	ldd	r24, Y+1	; 0x01
    3dcc:	9a 81       	ldd	r25, Y+2	; 0x02
    3dce:	fc 01       	movw	r30, r24
    3dd0:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3dd2:	0f 90       	pop	r0
    3dd4:	0f 90       	pop	r0
    3dd6:	df 91       	pop	r29
    3dd8:	cf 91       	pop	r28
    3dda:	08 95       	ret

00003ddc <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3ddc:	cf 93       	push	r28
    3dde:	df 93       	push	r29
    3de0:	cd b7       	in	r28, 0x3d	; 61
    3de2:	de b7       	in	r29, 0x3e	; 62
    3de4:	25 97       	sbiw	r28, 0x05	; 5
    3de6:	cd bf       	out	0x3d, r28	; 61
    3de8:	de bf       	out	0x3e, r29	; 62
    3dea:	8b 83       	std	Y+3, r24	; 0x03
    3dec:	9c 83       	std	Y+4, r25	; 0x04
    3dee:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3df0:	8b 81       	ldd	r24, Y+3	; 0x03
    3df2:	9c 81       	ldd	r25, Y+4	; 0x04
    3df4:	21 e0       	ldi	r18, 0x01	; 1
    3df6:	fc 01       	movw	r30, r24
    3df8:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    3dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    3dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    3dfe:	fc 01       	movw	r30, r24
    3e00:	24 81       	ldd	r18, Z+4	; 0x04
    3e02:	35 81       	ldd	r19, Z+5	; 0x05
    3e04:	8d 81       	ldd	r24, Y+5	; 0x05
    3e06:	88 2f       	mov	r24, r24
    3e08:	90 e0       	ldi	r25, 0x00	; 0
    3e0a:	a9 01       	movw	r20, r18
    3e0c:	48 1b       	sub	r20, r24
    3e0e:	59 0b       	sbc	r21, r25
    3e10:	ca 01       	movw	r24, r20
    3e12:	89 83       	std	Y+1, r24	; 0x01
    3e14:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3e16:	89 81       	ldd	r24, Y+1	; 0x01
    3e18:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e1a:	25 96       	adiw	r28, 0x05	; 5
    3e1c:	cd bf       	out	0x3d, r28	; 61
    3e1e:	de bf       	out	0x3e, r29	; 62
    3e20:	df 91       	pop	r29
    3e22:	cf 91       	pop	r28
    3e24:	08 95       	ret

00003e26 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    3e26:	cf 93       	push	r28
    3e28:	df 93       	push	r29
    3e2a:	cd b7       	in	r28, 0x3d	; 61
    3e2c:	de b7       	in	r29, 0x3e	; 62
    3e2e:	25 97       	sbiw	r28, 0x05	; 5
    3e30:	cd bf       	out	0x3d, r28	; 61
    3e32:	de bf       	out	0x3e, r29	; 62
    3e34:	8b 83       	std	Y+3, r24	; 0x03
    3e36:	9c 83       	std	Y+4, r25	; 0x04
    3e38:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e3c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e3e:	21 e0       	ldi	r18, 0x01	; 1
    3e40:	fc 01       	movw	r30, r24
    3e42:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3e44:	8b 81       	ldd	r24, Y+3	; 0x03
    3e46:	9c 81       	ldd	r25, Y+4	; 0x04
    3e48:	fc 01       	movw	r30, r24
    3e4a:	24 81       	ldd	r18, Z+4	; 0x04
    3e4c:	35 81       	ldd	r19, Z+5	; 0x05
    3e4e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e50:	99 27       	eor	r25, r25
    3e52:	87 fd       	sbrc	r24, 7
    3e54:	90 95       	com	r25
    3e56:	a9 01       	movw	r20, r18
    3e58:	48 1b       	sub	r20, r24
    3e5a:	59 0b       	sbc	r21, r25
    3e5c:	ca 01       	movw	r24, r20
    3e5e:	89 83       	std	Y+1, r24	; 0x01
    3e60:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3e62:	89 81       	ldd	r24, Y+1	; 0x01
    3e64:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e66:	25 96       	adiw	r28, 0x05	; 5
    3e68:	cd bf       	out	0x3d, r28	; 61
    3e6a:	de bf       	out	0x3e, r29	; 62
    3e6c:	df 91       	pop	r29
    3e6e:	cf 91       	pop	r28
    3e70:	08 95       	ret

00003e72 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3e72:	cf 93       	push	r28
    3e74:	df 93       	push	r29
    3e76:	0f 92       	push	r0
    3e78:	0f 92       	push	r0
    3e7a:	cd b7       	in	r28, 0x3d	; 61
    3e7c:	de b7       	in	r29, 0x3e	; 62
    3e7e:	89 83       	std	Y+1, r24	; 0x01
    3e80:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3e82:	89 81       	ldd	r24, Y+1	; 0x01
    3e84:	9a 81       	ldd	r25, Y+2	; 0x02
    3e86:	21 e0       	ldi	r18, 0x01	; 1
    3e88:	fc 01       	movw	r30, r24
    3e8a:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3e8c:	89 81       	ldd	r24, Y+1	; 0x01
    3e8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e90:	fc 01       	movw	r30, r24
    3e92:	84 81       	ldd	r24, Z+4	; 0x04
    3e94:	95 81       	ldd	r25, Z+5	; 0x05
}
    3e96:	0f 90       	pop	r0
    3e98:	0f 90       	pop	r0
    3e9a:	df 91       	pop	r29
    3e9c:	cf 91       	pop	r28
    3e9e:	08 95       	ret

00003ea0 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3ea0:	cf 93       	push	r28
    3ea2:	df 93       	push	r29
    3ea4:	0f 92       	push	r0
    3ea6:	0f 92       	push	r0
    3ea8:	cd b7       	in	r28, 0x3d	; 61
    3eaa:	de b7       	in	r29, 0x3e	; 62
    3eac:	89 83       	std	Y+1, r24	; 0x01
    3eae:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3eb0:	89 81       	ldd	r24, Y+1	; 0x01
    3eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb4:	21 e0       	ldi	r18, 0x01	; 1
    3eb6:	fc 01       	movw	r30, r24
    3eb8:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3eba:	89 81       	ldd	r24, Y+1	; 0x01
    3ebc:	9a 81       	ldd	r25, Y+2	; 0x02
    3ebe:	fc 01       	movw	r30, r24
    3ec0:	84 81       	ldd	r24, Z+4	; 0x04
}
    3ec2:	0f 90       	pop	r0
    3ec4:	0f 90       	pop	r0
    3ec6:	df 91       	pop	r29
    3ec8:	cf 91       	pop	r28
    3eca:	08 95       	ret

00003ecc <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3ecc:	cf 93       	push	r28
    3ece:	df 93       	push	r29
    3ed0:	0f 92       	push	r0
    3ed2:	0f 92       	push	r0
    3ed4:	cd b7       	in	r28, 0x3d	; 61
    3ed6:	de b7       	in	r29, 0x3e	; 62
    3ed8:	89 83       	std	Y+1, r24	; 0x01
    3eda:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3edc:	89 81       	ldd	r24, Y+1	; 0x01
    3ede:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee0:	21 e0       	ldi	r18, 0x01	; 1
    3ee2:	fc 01       	movw	r30, r24
    3ee4:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    3ee6:	89 81       	ldd	r24, Y+1	; 0x01
    3ee8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eea:	fc 01       	movw	r30, r24
    3eec:	85 81       	ldd	r24, Z+5	; 0x05
}
    3eee:	0f 90       	pop	r0
    3ef0:	0f 90       	pop	r0
    3ef2:	df 91       	pop	r29
    3ef4:	cf 91       	pop	r28
    3ef6:	08 95       	ret

00003ef8 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    3ef8:	0f 93       	push	r16
    3efa:	1f 93       	push	r17
    3efc:	cf 93       	push	r28
    3efe:	df 93       	push	r29
    3f00:	cd b7       	in	r28, 0x3d	; 61
    3f02:	de b7       	in	r29, 0x3e	; 62
    3f04:	6b 97       	sbiw	r28, 0x1b	; 27
    3f06:	cd bf       	out	0x3d, r28	; 61
    3f08:	de bf       	out	0x3e, r29	; 62
    3f0a:	8a 8f       	std	Y+26, r24	; 0x1a
    3f0c:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3f0e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3f10:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3f12:	fc 01       	movw	r30, r24
    3f14:	84 81       	ldd	r24, Z+4	; 0x04
    3f16:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    3f18:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3f1a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3f1c:	fc 01       	movw	r30, r24
    3f1e:	14 82       	std	Z+4, r1	; 0x04
    3f20:	80 e0       	ldi	r24, 0x00	; 0
    3f22:	90 e0       	ldi	r25, 0x00	; 0
    3f24:	a0 e8       	ldi	r26, 0x80	; 128
    3f26:	b2 e4       	ldi	r27, 0x42	; 66
    3f28:	8a 83       	std	Y+2, r24	; 0x02
    3f2a:	9b 83       	std	Y+3, r25	; 0x03
    3f2c:	ac 83       	std	Y+4, r26	; 0x04
    3f2e:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3f30:	6a 81       	ldd	r22, Y+2	; 0x02
    3f32:	7b 81       	ldd	r23, Y+3	; 0x03
    3f34:	8c 81       	ldd	r24, Y+4	; 0x04
    3f36:	9d 81       	ldd	r25, Y+5	; 0x05
    3f38:	2b ea       	ldi	r18, 0xAB	; 171
    3f3a:	3a ea       	ldi	r19, 0xAA	; 170
    3f3c:	4a e2       	ldi	r20, 0x2A	; 42
    3f3e:	5f e3       	ldi	r21, 0x3F	; 63
    3f40:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    3f44:	dc 01       	movw	r26, r24
    3f46:	cb 01       	movw	r24, r22
    3f48:	8e 83       	std	Y+6, r24	; 0x06
    3f4a:	9f 83       	std	Y+7, r25	; 0x07
    3f4c:	a8 87       	std	Y+8, r26	; 0x08
    3f4e:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3f50:	11 e0       	ldi	r17, 0x01	; 1
    3f52:	6e 81       	ldd	r22, Y+6	; 0x06
    3f54:	7f 81       	ldd	r23, Y+7	; 0x07
    3f56:	88 85       	ldd	r24, Y+8	; 0x08
    3f58:	99 85       	ldd	r25, Y+9	; 0x09
    3f5a:	20 e0       	ldi	r18, 0x00	; 0
    3f5c:	30 e0       	ldi	r19, 0x00	; 0
    3f5e:	40 e8       	ldi	r20, 0x80	; 128
    3f60:	5f e3       	ldi	r21, 0x3F	; 63
    3f62:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    3f66:	88 23       	and	r24, r24
    3f68:	0c f0       	brlt	.+2      	; 0x3f6c <ADC_Wait_8MHz+0x74>
    3f6a:	10 e0       	ldi	r17, 0x00	; 0
    3f6c:	11 23       	and	r17, r17
    3f6e:	19 f0       	breq	.+6      	; 0x3f76 <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3f70:	81 e0       	ldi	r24, 0x01	; 1
    3f72:	8a 87       	std	Y+10, r24	; 0x0a
    3f74:	a3 c0       	rjmp	.+326    	; 0x40bc <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    3f76:	11 e0       	ldi	r17, 0x01	; 1
    3f78:	6e 81       	ldd	r22, Y+6	; 0x06
    3f7a:	7f 81       	ldd	r23, Y+7	; 0x07
    3f7c:	88 85       	ldd	r24, Y+8	; 0x08
    3f7e:	99 85       	ldd	r25, Y+9	; 0x09
    3f80:	20 e0       	ldi	r18, 0x00	; 0
    3f82:	30 e0       	ldi	r19, 0x00	; 0
    3f84:	4f e7       	ldi	r20, 0x7F	; 127
    3f86:	53 e4       	ldi	r21, 0x43	; 67
    3f88:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    3f8c:	18 16       	cp	r1, r24
    3f8e:	0c f0       	brlt	.+2      	; 0x3f92 <ADC_Wait_8MHz+0x9a>
    3f90:	10 e0       	ldi	r17, 0x00	; 0
    3f92:	11 23       	and	r17, r17
    3f94:	09 f4       	brne	.+2      	; 0x3f98 <ADC_Wait_8MHz+0xa0>
    3f96:	89 c0       	rjmp	.+274    	; 0x40aa <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    3f98:	6a 81       	ldd	r22, Y+2	; 0x02
    3f9a:	7b 81       	ldd	r23, Y+3	; 0x03
    3f9c:	8c 81       	ldd	r24, Y+4	; 0x04
    3f9e:	9d 81       	ldd	r25, Y+5	; 0x05
    3fa0:	20 e0       	ldi	r18, 0x00	; 0
    3fa2:	30 e0       	ldi	r19, 0x00	; 0
    3fa4:	4a e7       	ldi	r20, 0x7A	; 122
    3fa6:	54 e4       	ldi	r21, 0x44	; 68
    3fa8:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    3fac:	dc 01       	movw	r26, r24
    3fae:	cb 01       	movw	r24, r22
    3fb0:	8b 87       	std	Y+11, r24	; 0x0b
    3fb2:	9c 87       	std	Y+12, r25	; 0x0c
    3fb4:	ad 87       	std	Y+13, r26	; 0x0d
    3fb6:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3fb8:	6b 85       	ldd	r22, Y+11	; 0x0b
    3fba:	7c 85       	ldd	r23, Y+12	; 0x0c
    3fbc:	8d 85       	ldd	r24, Y+13	; 0x0d
    3fbe:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fc0:	20 e0       	ldi	r18, 0x00	; 0
    3fc2:	30 e0       	ldi	r19, 0x00	; 0
    3fc4:	4a ef       	ldi	r20, 0xFA	; 250
    3fc6:	53 e4       	ldi	r21, 0x43	; 67
    3fc8:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    3fcc:	dc 01       	movw	r26, r24
    3fce:	cb 01       	movw	r24, r22
    3fd0:	8f 87       	std	Y+15, r24	; 0x0f
    3fd2:	98 8b       	std	Y+16, r25	; 0x10
    3fd4:	a9 8b       	std	Y+17, r26	; 0x11
    3fd6:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3fd8:	11 e0       	ldi	r17, 0x01	; 1
    3fda:	6f 85       	ldd	r22, Y+15	; 0x0f
    3fdc:	78 89       	ldd	r23, Y+16	; 0x10
    3fde:	89 89       	ldd	r24, Y+17	; 0x11
    3fe0:	9a 89       	ldd	r25, Y+18	; 0x12
    3fe2:	20 e0       	ldi	r18, 0x00	; 0
    3fe4:	30 e0       	ldi	r19, 0x00	; 0
    3fe6:	40 e8       	ldi	r20, 0x80	; 128
    3fe8:	5f e3       	ldi	r21, 0x3F	; 63
    3fea:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    3fee:	88 23       	and	r24, r24
    3ff0:	0c f0       	brlt	.+2      	; 0x3ff4 <ADC_Wait_8MHz+0xfc>
    3ff2:	10 e0       	ldi	r17, 0x00	; 0
    3ff4:	11 23       	and	r17, r17
    3ff6:	29 f0       	breq	.+10     	; 0x4002 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    3ff8:	81 e0       	ldi	r24, 0x01	; 1
    3ffa:	90 e0       	ldi	r25, 0x00	; 0
    3ffc:	8b 8b       	std	Y+19, r24	; 0x13
    3ffe:	9c 8b       	std	Y+20, r25	; 0x14
    4000:	46 c0       	rjmp	.+140    	; 0x408e <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    4002:	11 e0       	ldi	r17, 0x01	; 1
    4004:	6f 85       	ldd	r22, Y+15	; 0x0f
    4006:	78 89       	ldd	r23, Y+16	; 0x10
    4008:	89 89       	ldd	r24, Y+17	; 0x11
    400a:	9a 89       	ldd	r25, Y+18	; 0x12
    400c:	20 e0       	ldi	r18, 0x00	; 0
    400e:	3f ef       	ldi	r19, 0xFF	; 255
    4010:	4f e7       	ldi	r20, 0x7F	; 127
    4012:	57 e4       	ldi	r21, 0x47	; 71
    4014:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    4018:	18 16       	cp	r1, r24
    401a:	0c f0       	brlt	.+2      	; 0x401e <ADC_Wait_8MHz+0x126>
    401c:	10 e0       	ldi	r17, 0x00	; 0
    401e:	11 23       	and	r17, r17
    4020:	61 f1       	breq	.+88     	; 0x407a <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4022:	6b 85       	ldd	r22, Y+11	; 0x0b
    4024:	7c 85       	ldd	r23, Y+12	; 0x0c
    4026:	8d 85       	ldd	r24, Y+13	; 0x0d
    4028:	9e 85       	ldd	r25, Y+14	; 0x0e
    402a:	20 e0       	ldi	r18, 0x00	; 0
    402c:	30 e0       	ldi	r19, 0x00	; 0
    402e:	40 e2       	ldi	r20, 0x20	; 32
    4030:	51 e4       	ldi	r21, 0x41	; 65
    4032:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4036:	dc 01       	movw	r26, r24
    4038:	cb 01       	movw	r24, r22
    403a:	bc 01       	movw	r22, r24
    403c:	cd 01       	movw	r24, r26
    403e:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4042:	dc 01       	movw	r26, r24
    4044:	cb 01       	movw	r24, r22
    4046:	8b 8b       	std	Y+19, r24	; 0x13
    4048:	9c 8b       	std	Y+20, r25	; 0x14
    404a:	12 c0       	rjmp	.+36     	; 0x4070 <ADC_Wait_8MHz+0x178>
    404c:	82 e3       	ldi	r24, 0x32	; 50
    404e:	90 e0       	ldi	r25, 0x00	; 0
    4050:	8d 8b       	std	Y+21, r24	; 0x15
    4052:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4054:	8d 89       	ldd	r24, Y+21	; 0x15
    4056:	9e 89       	ldd	r25, Y+22	; 0x16
    4058:	8c 01       	movw	r16, r24
    405a:	c8 01       	movw	r24, r16
    405c:	01 97       	sbiw	r24, 0x01	; 1
    405e:	f1 f7       	brne	.-4      	; 0x405c <ADC_Wait_8MHz+0x164>
    4060:	8c 01       	movw	r16, r24
    4062:	0d 8b       	std	Y+21, r16	; 0x15
    4064:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4066:	8b 89       	ldd	r24, Y+19	; 0x13
    4068:	9c 89       	ldd	r25, Y+20	; 0x14
    406a:	01 97       	sbiw	r24, 0x01	; 1
    406c:	8b 8b       	std	Y+19, r24	; 0x13
    406e:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4070:	8b 89       	ldd	r24, Y+19	; 0x13
    4072:	9c 89       	ldd	r25, Y+20	; 0x14
    4074:	00 97       	sbiw	r24, 0x00	; 0
    4076:	51 f7       	brne	.-44     	; 0x404c <ADC_Wait_8MHz+0x154>
    4078:	28 c0       	rjmp	.+80     	; 0x40ca <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    407a:	6f 85       	ldd	r22, Y+15	; 0x0f
    407c:	78 89       	ldd	r23, Y+16	; 0x10
    407e:	89 89       	ldd	r24, Y+17	; 0x11
    4080:	9a 89       	ldd	r25, Y+18	; 0x12
    4082:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4086:	dc 01       	movw	r26, r24
    4088:	cb 01       	movw	r24, r22
    408a:	8b 8b       	std	Y+19, r24	; 0x13
    408c:	9c 8b       	std	Y+20, r25	; 0x14
    408e:	8b 89       	ldd	r24, Y+19	; 0x13
    4090:	9c 89       	ldd	r25, Y+20	; 0x14
    4092:	8f 8b       	std	Y+23, r24	; 0x17
    4094:	98 8f       	std	Y+24, r25	; 0x18
    4096:	8f 89       	ldd	r24, Y+23	; 0x17
    4098:	98 8d       	ldd	r25, Y+24	; 0x18
    409a:	8c 01       	movw	r16, r24
    409c:	f8 01       	movw	r30, r16
    409e:	31 97       	sbiw	r30, 0x01	; 1
    40a0:	f1 f7       	brne	.-4      	; 0x409e <ADC_Wait_8MHz+0x1a6>
    40a2:	8f 01       	movw	r16, r30
    40a4:	0f 8b       	std	Y+23, r16	; 0x17
    40a6:	18 8f       	std	Y+24, r17	; 0x18
    40a8:	10 c0       	rjmp	.+32     	; 0x40ca <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    40aa:	6e 81       	ldd	r22, Y+6	; 0x06
    40ac:	7f 81       	ldd	r23, Y+7	; 0x07
    40ae:	88 85       	ldd	r24, Y+8	; 0x08
    40b0:	99 85       	ldd	r25, Y+9	; 0x09
    40b2:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    40b6:	dc 01       	movw	r26, r24
    40b8:	cb 01       	movw	r24, r22
    40ba:	8a 87       	std	Y+10, r24	; 0x0a
    40bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    40be:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    40c0:	89 8d       	ldd	r24, Y+25	; 0x19
    40c2:	18 2f       	mov	r17, r24
    40c4:	1a 95       	dec	r17
    40c6:	f1 f7       	brne	.-4      	; 0x40c4 <ADC_Wait_8MHz+0x1cc>
    40c8:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    40ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    40cc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    40ce:	29 81       	ldd	r18, Y+1	; 0x01
    40d0:	fc 01       	movw	r30, r24
    40d2:	24 83       	std	Z+4, r18	; 0x04
}
    40d4:	6b 96       	adiw	r28, 0x1b	; 27
    40d6:	cd bf       	out	0x3d, r28	; 61
    40d8:	de bf       	out	0x3e, r29	; 62
    40da:	df 91       	pop	r29
    40dc:	cf 91       	pop	r28
    40de:	1f 91       	pop	r17
    40e0:	0f 91       	pop	r16
    40e2:	08 95       	ret

000040e4 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    40e4:	0f 93       	push	r16
    40e6:	1f 93       	push	r17
    40e8:	cf 93       	push	r28
    40ea:	df 93       	push	r29
    40ec:	cd b7       	in	r28, 0x3d	; 61
    40ee:	de b7       	in	r29, 0x3e	; 62
    40f0:	6b 97       	sbiw	r28, 0x1b	; 27
    40f2:	cd bf       	out	0x3d, r28	; 61
    40f4:	de bf       	out	0x3e, r29	; 62
    40f6:	8a 8f       	std	Y+26, r24	; 0x1a
    40f8:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    40fa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    40fc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    40fe:	fc 01       	movw	r30, r24
    4100:	84 81       	ldd	r24, Z+4	; 0x04
    4102:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    4104:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4106:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4108:	21 e0       	ldi	r18, 0x01	; 1
    410a:	fc 01       	movw	r30, r24
    410c:	24 83       	std	Z+4, r18	; 0x04
    410e:	80 e0       	ldi	r24, 0x00	; 0
    4110:	90 e0       	ldi	r25, 0x00	; 0
    4112:	a0 e0       	ldi	r26, 0x00	; 0
    4114:	b3 e4       	ldi	r27, 0x43	; 67
    4116:	8a 83       	std	Y+2, r24	; 0x02
    4118:	9b 83       	std	Y+3, r25	; 0x03
    411a:	ac 83       	std	Y+4, r26	; 0x04
    411c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    411e:	6a 81       	ldd	r22, Y+2	; 0x02
    4120:	7b 81       	ldd	r23, Y+3	; 0x03
    4122:	8c 81       	ldd	r24, Y+4	; 0x04
    4124:	9d 81       	ldd	r25, Y+5	; 0x05
    4126:	2b ea       	ldi	r18, 0xAB	; 171
    4128:	3a ea       	ldi	r19, 0xAA	; 170
    412a:	4a e2       	ldi	r20, 0x2A	; 42
    412c:	5f e3       	ldi	r21, 0x3F	; 63
    412e:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4132:	dc 01       	movw	r26, r24
    4134:	cb 01       	movw	r24, r22
    4136:	8e 83       	std	Y+6, r24	; 0x06
    4138:	9f 83       	std	Y+7, r25	; 0x07
    413a:	a8 87       	std	Y+8, r26	; 0x08
    413c:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    413e:	11 e0       	ldi	r17, 0x01	; 1
    4140:	6e 81       	ldd	r22, Y+6	; 0x06
    4142:	7f 81       	ldd	r23, Y+7	; 0x07
    4144:	88 85       	ldd	r24, Y+8	; 0x08
    4146:	99 85       	ldd	r25, Y+9	; 0x09
    4148:	20 e0       	ldi	r18, 0x00	; 0
    414a:	30 e0       	ldi	r19, 0x00	; 0
    414c:	40 e8       	ldi	r20, 0x80	; 128
    414e:	5f e3       	ldi	r21, 0x3F	; 63
    4150:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    4154:	88 23       	and	r24, r24
    4156:	0c f0       	brlt	.+2      	; 0x415a <ADC_Wait_32MHz+0x76>
    4158:	10 e0       	ldi	r17, 0x00	; 0
    415a:	11 23       	and	r17, r17
    415c:	19 f0       	breq	.+6      	; 0x4164 <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    415e:	81 e0       	ldi	r24, 0x01	; 1
    4160:	8a 87       	std	Y+10, r24	; 0x0a
    4162:	a3 c0       	rjmp	.+326    	; 0x42aa <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    4164:	11 e0       	ldi	r17, 0x01	; 1
    4166:	6e 81       	ldd	r22, Y+6	; 0x06
    4168:	7f 81       	ldd	r23, Y+7	; 0x07
    416a:	88 85       	ldd	r24, Y+8	; 0x08
    416c:	99 85       	ldd	r25, Y+9	; 0x09
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	4f e7       	ldi	r20, 0x7F	; 127
    4174:	53 e4       	ldi	r21, 0x43	; 67
    4176:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    417a:	18 16       	cp	r1, r24
    417c:	0c f0       	brlt	.+2      	; 0x4180 <ADC_Wait_32MHz+0x9c>
    417e:	10 e0       	ldi	r17, 0x00	; 0
    4180:	11 23       	and	r17, r17
    4182:	09 f4       	brne	.+2      	; 0x4186 <ADC_Wait_32MHz+0xa2>
    4184:	89 c0       	rjmp	.+274    	; 0x4298 <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    4186:	6a 81       	ldd	r22, Y+2	; 0x02
    4188:	7b 81       	ldd	r23, Y+3	; 0x03
    418a:	8c 81       	ldd	r24, Y+4	; 0x04
    418c:	9d 81       	ldd	r25, Y+5	; 0x05
    418e:	20 e0       	ldi	r18, 0x00	; 0
    4190:	30 e0       	ldi	r19, 0x00	; 0
    4192:	4a e7       	ldi	r20, 0x7A	; 122
    4194:	54 e4       	ldi	r21, 0x44	; 68
    4196:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    419a:	dc 01       	movw	r26, r24
    419c:	cb 01       	movw	r24, r22
    419e:	8b 87       	std	Y+11, r24	; 0x0b
    41a0:	9c 87       	std	Y+12, r25	; 0x0c
    41a2:	ad 87       	std	Y+13, r26	; 0x0d
    41a4:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    41a6:	6b 85       	ldd	r22, Y+11	; 0x0b
    41a8:	7c 85       	ldd	r23, Y+12	; 0x0c
    41aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    41ac:	9e 85       	ldd	r25, Y+14	; 0x0e
    41ae:	20 e0       	ldi	r18, 0x00	; 0
    41b0:	30 e0       	ldi	r19, 0x00	; 0
    41b2:	4a ef       	ldi	r20, 0xFA	; 250
    41b4:	53 e4       	ldi	r21, 0x43	; 67
    41b6:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    41ba:	dc 01       	movw	r26, r24
    41bc:	cb 01       	movw	r24, r22
    41be:	8f 87       	std	Y+15, r24	; 0x0f
    41c0:	98 8b       	std	Y+16, r25	; 0x10
    41c2:	a9 8b       	std	Y+17, r26	; 0x11
    41c4:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    41c6:	11 e0       	ldi	r17, 0x01	; 1
    41c8:	6f 85       	ldd	r22, Y+15	; 0x0f
    41ca:	78 89       	ldd	r23, Y+16	; 0x10
    41cc:	89 89       	ldd	r24, Y+17	; 0x11
    41ce:	9a 89       	ldd	r25, Y+18	; 0x12
    41d0:	20 e0       	ldi	r18, 0x00	; 0
    41d2:	30 e0       	ldi	r19, 0x00	; 0
    41d4:	40 e8       	ldi	r20, 0x80	; 128
    41d6:	5f e3       	ldi	r21, 0x3F	; 63
    41d8:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    41dc:	88 23       	and	r24, r24
    41de:	0c f0       	brlt	.+2      	; 0x41e2 <ADC_Wait_32MHz+0xfe>
    41e0:	10 e0       	ldi	r17, 0x00	; 0
    41e2:	11 23       	and	r17, r17
    41e4:	29 f0       	breq	.+10     	; 0x41f0 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    41e6:	81 e0       	ldi	r24, 0x01	; 1
    41e8:	90 e0       	ldi	r25, 0x00	; 0
    41ea:	8b 8b       	std	Y+19, r24	; 0x13
    41ec:	9c 8b       	std	Y+20, r25	; 0x14
    41ee:	46 c0       	rjmp	.+140    	; 0x427c <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    41f0:	11 e0       	ldi	r17, 0x01	; 1
    41f2:	6f 85       	ldd	r22, Y+15	; 0x0f
    41f4:	78 89       	ldd	r23, Y+16	; 0x10
    41f6:	89 89       	ldd	r24, Y+17	; 0x11
    41f8:	9a 89       	ldd	r25, Y+18	; 0x12
    41fa:	20 e0       	ldi	r18, 0x00	; 0
    41fc:	3f ef       	ldi	r19, 0xFF	; 255
    41fe:	4f e7       	ldi	r20, 0x7F	; 127
    4200:	57 e4       	ldi	r21, 0x47	; 71
    4202:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    4206:	18 16       	cp	r1, r24
    4208:	0c f0       	brlt	.+2      	; 0x420c <ADC_Wait_32MHz+0x128>
    420a:	10 e0       	ldi	r17, 0x00	; 0
    420c:	11 23       	and	r17, r17
    420e:	61 f1       	breq	.+88     	; 0x4268 <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4210:	6b 85       	ldd	r22, Y+11	; 0x0b
    4212:	7c 85       	ldd	r23, Y+12	; 0x0c
    4214:	8d 85       	ldd	r24, Y+13	; 0x0d
    4216:	9e 85       	ldd	r25, Y+14	; 0x0e
    4218:	20 e0       	ldi	r18, 0x00	; 0
    421a:	30 e0       	ldi	r19, 0x00	; 0
    421c:	40 e2       	ldi	r20, 0x20	; 32
    421e:	51 e4       	ldi	r21, 0x41	; 65
    4220:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4224:	dc 01       	movw	r26, r24
    4226:	cb 01       	movw	r24, r22
    4228:	bc 01       	movw	r22, r24
    422a:	cd 01       	movw	r24, r26
    422c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4230:	dc 01       	movw	r26, r24
    4232:	cb 01       	movw	r24, r22
    4234:	8b 8b       	std	Y+19, r24	; 0x13
    4236:	9c 8b       	std	Y+20, r25	; 0x14
    4238:	12 c0       	rjmp	.+36     	; 0x425e <ADC_Wait_32MHz+0x17a>
    423a:	82 e3       	ldi	r24, 0x32	; 50
    423c:	90 e0       	ldi	r25, 0x00	; 0
    423e:	8d 8b       	std	Y+21, r24	; 0x15
    4240:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4242:	8d 89       	ldd	r24, Y+21	; 0x15
    4244:	9e 89       	ldd	r25, Y+22	; 0x16
    4246:	8c 01       	movw	r16, r24
    4248:	c8 01       	movw	r24, r16
    424a:	01 97       	sbiw	r24, 0x01	; 1
    424c:	f1 f7       	brne	.-4      	; 0x424a <ADC_Wait_32MHz+0x166>
    424e:	8c 01       	movw	r16, r24
    4250:	0d 8b       	std	Y+21, r16	; 0x15
    4252:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4254:	8b 89       	ldd	r24, Y+19	; 0x13
    4256:	9c 89       	ldd	r25, Y+20	; 0x14
    4258:	01 97       	sbiw	r24, 0x01	; 1
    425a:	8b 8b       	std	Y+19, r24	; 0x13
    425c:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    425e:	8b 89       	ldd	r24, Y+19	; 0x13
    4260:	9c 89       	ldd	r25, Y+20	; 0x14
    4262:	00 97       	sbiw	r24, 0x00	; 0
    4264:	51 f7       	brne	.-44     	; 0x423a <ADC_Wait_32MHz+0x156>
    4266:	28 c0       	rjmp	.+80     	; 0x42b8 <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4268:	6f 85       	ldd	r22, Y+15	; 0x0f
    426a:	78 89       	ldd	r23, Y+16	; 0x10
    426c:	89 89       	ldd	r24, Y+17	; 0x11
    426e:	9a 89       	ldd	r25, Y+18	; 0x12
    4270:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4274:	dc 01       	movw	r26, r24
    4276:	cb 01       	movw	r24, r22
    4278:	8b 8b       	std	Y+19, r24	; 0x13
    427a:	9c 8b       	std	Y+20, r25	; 0x14
    427c:	8b 89       	ldd	r24, Y+19	; 0x13
    427e:	9c 89       	ldd	r25, Y+20	; 0x14
    4280:	8f 8b       	std	Y+23, r24	; 0x17
    4282:	98 8f       	std	Y+24, r25	; 0x18
    4284:	8f 89       	ldd	r24, Y+23	; 0x17
    4286:	98 8d       	ldd	r25, Y+24	; 0x18
    4288:	8c 01       	movw	r16, r24
    428a:	f8 01       	movw	r30, r16
    428c:	31 97       	sbiw	r30, 0x01	; 1
    428e:	f1 f7       	brne	.-4      	; 0x428c <ADC_Wait_32MHz+0x1a8>
    4290:	8f 01       	movw	r16, r30
    4292:	0f 8b       	std	Y+23, r16	; 0x17
    4294:	18 8f       	std	Y+24, r17	; 0x18
    4296:	10 c0       	rjmp	.+32     	; 0x42b8 <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4298:	6e 81       	ldd	r22, Y+6	; 0x06
    429a:	7f 81       	ldd	r23, Y+7	; 0x07
    429c:	88 85       	ldd	r24, Y+8	; 0x08
    429e:	99 85       	ldd	r25, Y+9	; 0x09
    42a0:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    42a4:	dc 01       	movw	r26, r24
    42a6:	cb 01       	movw	r24, r22
    42a8:	8a 87       	std	Y+10, r24	; 0x0a
    42aa:	8a 85       	ldd	r24, Y+10	; 0x0a
    42ac:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    42ae:	89 8d       	ldd	r24, Y+25	; 0x19
    42b0:	18 2f       	mov	r17, r24
    42b2:	1a 95       	dec	r17
    42b4:	f1 f7       	brne	.-4      	; 0x42b2 <ADC_Wait_32MHz+0x1ce>
    42b6:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    42b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    42ba:	9b 8d       	ldd	r25, Y+27	; 0x1b
    42bc:	29 81       	ldd	r18, Y+1	; 0x01
    42be:	fc 01       	movw	r30, r24
    42c0:	24 83       	std	Z+4, r18	; 0x04
}
    42c2:	6b 96       	adiw	r28, 0x1b	; 27
    42c4:	cd bf       	out	0x3d, r28	; 61
    42c6:	de bf       	out	0x3e, r29	; 62
    42c8:	df 91       	pop	r29
    42ca:	cf 91       	pop	r28
    42cc:	1f 91       	pop	r17
    42ce:	0f 91       	pop	r16
    42d0:	08 95       	ret

000042d2 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    42d2:	cf 93       	push	r28
    42d4:	df 93       	push	r29
    42d6:	cd b7       	in	r28, 0x3d	; 61
    42d8:	de b7       	in	r29, 0x3e	; 62
    42da:	2a 97       	sbiw	r28, 0x0a	; 10
    42dc:	cd bf       	out	0x3d, r28	; 61
    42de:	de bf       	out	0x3e, r29	; 62
    42e0:	8e 83       	std	Y+6, r24	; 0x06
    42e2:	9f 83       	std	Y+7, r25	; 0x07
    42e4:	68 87       	std	Y+8, r22	; 0x08
    42e6:	79 87       	std	Y+9, r23	; 0x09
    42e8:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    42ea:	8a 85       	ldd	r24, Y+10	; 0x0a
    42ec:	88 23       	and	r24, r24
    42ee:	a9 f1       	breq	.+106    	; 0x435a <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    42f0:	19 82       	std	Y+1, r1	; 0x01
    42f2:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    42f4:	1b 82       	std	Y+3, r1	; 0x03
    42f6:	1c 82       	std	Y+4, r1	; 0x04
    42f8:	24 c0       	rjmp	.+72     	; 0x4342 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    42fa:	88 85       	ldd	r24, Y+8	; 0x08
    42fc:	99 85       	ldd	r25, Y+9	; 0x09
    42fe:	fc 01       	movw	r30, r24
    4300:	80 81       	ld	r24, Z
    4302:	28 2f       	mov	r18, r24
    4304:	20 68       	ori	r18, 0x80	; 128
    4306:	88 85       	ldd	r24, Y+8	; 0x08
    4308:	99 85       	ldd	r25, Y+9	; 0x09
    430a:	fc 01       	movw	r30, r24
    430c:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    430e:	88 85       	ldd	r24, Y+8	; 0x08
    4310:	99 85       	ldd	r25, Y+9	; 0x09
    4312:	fc 01       	movw	r30, r24
    4314:	83 81       	ldd	r24, Z+3	; 0x03
    4316:	88 2f       	mov	r24, r24
    4318:	90 e0       	ldi	r25, 0x00	; 0
    431a:	81 70       	andi	r24, 0x01	; 1
    431c:	90 70       	andi	r25, 0x00	; 0
    431e:	00 97       	sbiw	r24, 0x00	; 0
    4320:	b1 f3       	breq	.-20     	; 0x430e <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    4322:	88 85       	ldd	r24, Y+8	; 0x08
    4324:	99 85       	ldd	r25, Y+9	; 0x09
    4326:	60 e0       	ldi	r22, 0x00	; 0
    4328:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <ADC_ResultCh_GetWord_Unsigned>
    432c:	29 81       	ldd	r18, Y+1	; 0x01
    432e:	3a 81       	ldd	r19, Y+2	; 0x02
    4330:	82 0f       	add	r24, r18
    4332:	93 1f       	adc	r25, r19
    4334:	89 83       	std	Y+1, r24	; 0x01
    4336:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    4338:	8b 81       	ldd	r24, Y+3	; 0x03
    433a:	9c 81       	ldd	r25, Y+4	; 0x04
    433c:	01 96       	adiw	r24, 0x01	; 1
    433e:	8b 83       	std	Y+3, r24	; 0x03
    4340:	9c 83       	std	Y+4, r25	; 0x04
    4342:	8b 81       	ldd	r24, Y+3	; 0x03
    4344:	9c 81       	ldd	r25, Y+4	; 0x04
    4346:	84 30       	cpi	r24, 0x04	; 4
    4348:	91 05       	cpc	r25, r1
    434a:	bc f2       	brlt	.-82     	; 0x42fa <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    434c:	89 81       	ldd	r24, Y+1	; 0x01
    434e:	9a 81       	ldd	r25, Y+2	; 0x02
    4350:	96 95       	lsr	r25
    4352:	87 95       	ror	r24
    4354:	96 95       	lsr	r25
    4356:	87 95       	ror	r24
    4358:	1b c0       	rjmp	.+54     	; 0x4390 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    435a:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    435c:	88 85       	ldd	r24, Y+8	; 0x08
    435e:	99 85       	ldd	r25, Y+9	; 0x09
    4360:	fc 01       	movw	r30, r24
    4362:	80 81       	ld	r24, Z
    4364:	28 2f       	mov	r18, r24
    4366:	20 68       	ori	r18, 0x80	; 128
    4368:	88 85       	ldd	r24, Y+8	; 0x08
    436a:	99 85       	ldd	r25, Y+9	; 0x09
    436c:	fc 01       	movw	r30, r24
    436e:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    4370:	88 85       	ldd	r24, Y+8	; 0x08
    4372:	99 85       	ldd	r25, Y+9	; 0x09
    4374:	fc 01       	movw	r30, r24
    4376:	83 81       	ldd	r24, Z+3	; 0x03
    4378:	88 2f       	mov	r24, r24
    437a:	90 e0       	ldi	r25, 0x00	; 0
    437c:	81 70       	andi	r24, 0x01	; 1
    437e:	90 70       	andi	r25, 0x00	; 0
    4380:	00 97       	sbiw	r24, 0x00	; 0
    4382:	b1 f3       	breq	.-20     	; 0x4370 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    4384:	88 85       	ldd	r24, Y+8	; 0x08
    4386:	99 85       	ldd	r25, Y+9	; 0x09
    4388:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <ADC_ResultCh_GetWord>
    438c:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    438e:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    4390:	2a 96       	adiw	r28, 0x0a	; 10
    4392:	cd bf       	out	0x3d, r28	; 61
    4394:	de bf       	out	0x3e, r29	; 62
    4396:	df 91       	pop	r29
    4398:	cf 91       	pop	r28
    439a:	08 95       	ret

0000439c <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    439c:	cf 93       	push	r28
    439e:	df 93       	push	r29
    43a0:	cd b7       	in	r28, 0x3d	; 61
    43a2:	de b7       	in	r29, 0x3e	; 62
    43a4:	2a 97       	sbiw	r28, 0x0a	; 10
    43a6:	cd bf       	out	0x3d, r28	; 61
    43a8:	de bf       	out	0x3e, r29	; 62
    43aa:	8e 83       	std	Y+6, r24	; 0x06
    43ac:	9f 83       	std	Y+7, r25	; 0x07
    43ae:	68 87       	std	Y+8, r22	; 0x08
    43b0:	79 87       	std	Y+9, r23	; 0x09
    43b2:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    43b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    43b6:	88 23       	and	r24, r24
    43b8:	c1 f1       	breq	.+112    	; 0x442a <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    43ba:	19 82       	std	Y+1, r1	; 0x01
    43bc:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    43be:	1b 82       	std	Y+3, r1	; 0x03
    43c0:	1c 82       	std	Y+4, r1	; 0x04
    43c2:	24 c0       	rjmp	.+72     	; 0x440c <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    43c4:	88 85       	ldd	r24, Y+8	; 0x08
    43c6:	99 85       	ldd	r25, Y+9	; 0x09
    43c8:	fc 01       	movw	r30, r24
    43ca:	80 81       	ld	r24, Z
    43cc:	28 2f       	mov	r18, r24
    43ce:	20 68       	ori	r18, 0x80	; 128
    43d0:	88 85       	ldd	r24, Y+8	; 0x08
    43d2:	99 85       	ldd	r25, Y+9	; 0x09
    43d4:	fc 01       	movw	r30, r24
    43d6:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    43d8:	88 85       	ldd	r24, Y+8	; 0x08
    43da:	99 85       	ldd	r25, Y+9	; 0x09
    43dc:	fc 01       	movw	r30, r24
    43de:	83 81       	ldd	r24, Z+3	; 0x03
    43e0:	88 2f       	mov	r24, r24
    43e2:	90 e0       	ldi	r25, 0x00	; 0
    43e4:	81 70       	andi	r24, 0x01	; 1
    43e6:	90 70       	andi	r25, 0x00	; 0
    43e8:	00 97       	sbiw	r24, 0x00	; 0
    43ea:	b1 f3       	breq	.-20     	; 0x43d8 <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    43ec:	88 85       	ldd	r24, Y+8	; 0x08
    43ee:	99 85       	ldd	r25, Y+9	; 0x09
    43f0:	60 e0       	ldi	r22, 0x00	; 0
    43f2:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <ADC_ResultCh_GetWord_Signed>
    43f6:	29 81       	ldd	r18, Y+1	; 0x01
    43f8:	3a 81       	ldd	r19, Y+2	; 0x02
    43fa:	82 0f       	add	r24, r18
    43fc:	93 1f       	adc	r25, r19
    43fe:	89 83       	std	Y+1, r24	; 0x01
    4400:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    4402:	8b 81       	ldd	r24, Y+3	; 0x03
    4404:	9c 81       	ldd	r25, Y+4	; 0x04
    4406:	01 96       	adiw	r24, 0x01	; 1
    4408:	8b 83       	std	Y+3, r24	; 0x03
    440a:	9c 83       	std	Y+4, r25	; 0x04
    440c:	8b 81       	ldd	r24, Y+3	; 0x03
    440e:	9c 81       	ldd	r25, Y+4	; 0x04
    4410:	84 30       	cpi	r24, 0x04	; 4
    4412:	91 05       	cpc	r25, r1
    4414:	bc f2       	brlt	.-82     	; 0x43c4 <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    4416:	89 81       	ldd	r24, Y+1	; 0x01
    4418:	9a 81       	ldd	r25, Y+2	; 0x02
    441a:	99 23       	and	r25, r25
    441c:	0c f4       	brge	.+2      	; 0x4420 <ADC_Offset_Get_Signed+0x84>
    441e:	03 96       	adiw	r24, 0x03	; 3
    4420:	95 95       	asr	r25
    4422:	87 95       	ror	r24
    4424:	95 95       	asr	r25
    4426:	87 95       	ror	r24
    4428:	1c c0       	rjmp	.+56     	; 0x4462 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    442a:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    442c:	88 85       	ldd	r24, Y+8	; 0x08
    442e:	99 85       	ldd	r25, Y+9	; 0x09
    4430:	fc 01       	movw	r30, r24
    4432:	80 81       	ld	r24, Z
    4434:	28 2f       	mov	r18, r24
    4436:	20 68       	ori	r18, 0x80	; 128
    4438:	88 85       	ldd	r24, Y+8	; 0x08
    443a:	99 85       	ldd	r25, Y+9	; 0x09
    443c:	fc 01       	movw	r30, r24
    443e:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    4440:	88 85       	ldd	r24, Y+8	; 0x08
    4442:	99 85       	ldd	r25, Y+9	; 0x09
    4444:	fc 01       	movw	r30, r24
    4446:	83 81       	ldd	r24, Z+3	; 0x03
    4448:	88 2f       	mov	r24, r24
    444a:	90 e0       	ldi	r25, 0x00	; 0
    444c:	81 70       	andi	r24, 0x01	; 1
    444e:	90 70       	andi	r25, 0x00	; 0
    4450:	00 97       	sbiw	r24, 0x00	; 0
    4452:	b1 f3       	breq	.-20     	; 0x4440 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    4454:	88 85       	ldd	r24, Y+8	; 0x08
    4456:	99 85       	ldd	r25, Y+9	; 0x09
    4458:	60 e0       	ldi	r22, 0x00	; 0
    445a:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <ADC_ResultCh_GetWord_Signed>
    445e:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    4460:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    4462:	2a 96       	adiw	r28, 0x0a	; 10
    4464:	cd bf       	out	0x3d, r28	; 61
    4466:	de bf       	out	0x3e, r29	; 62
    4468:	df 91       	pop	r29
    446a:	cf 91       	pop	r28
    446c:	08 95       	ret

0000446e <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    446e:	1f 93       	push	r17
    4470:	cf 93       	push	r28
    4472:	df 93       	push	r29
    4474:	cd b7       	in	r28, 0x3d	; 61
    4476:	de b7       	in	r29, 0x3e	; 62
    4478:	25 97       	sbiw	r28, 0x05	; 5
    447a:	cd bf       	out	0x3d, r28	; 61
    447c:	de bf       	out	0x3e, r29	; 62
    447e:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    4480:	8a ec       	ldi	r24, 0xCA	; 202
    4482:	91 e0       	ldi	r25, 0x01	; 1
    4484:	22 e0       	ldi	r18, 0x02	; 2
    4486:	fc 01       	movw	r30, r24
    4488:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    448a:	8d 81       	ldd	r24, Y+5	; 0x05
    448c:	88 2f       	mov	r24, r24
    448e:	90 e0       	ldi	r25, 0x00	; 0
    4490:	89 83       	std	Y+1, r24	; 0x01
    4492:	9a 83       	std	Y+2, r25	; 0x02
    4494:	89 81       	ldd	r24, Y+1	; 0x01
    4496:	9a 81       	ldd	r25, Y+2	; 0x02
    4498:	fc 01       	movw	r30, r24
    449a:	14 91       	lpm	r17, Z
    449c:	1b 83       	std	Y+3, r17	; 0x03
    449e:	8b 81       	ldd	r24, Y+3	; 0x03
    44a0:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    44a2:	8a ec       	ldi	r24, 0xCA	; 202
    44a4:	91 e0       	ldi	r25, 0x01	; 1
    44a6:	fc 01       	movw	r30, r24
    44a8:	10 82       	st	Z, r1

	return result;
    44aa:	8c 81       	ldd	r24, Y+4	; 0x04
}
    44ac:	25 96       	adiw	r28, 0x05	; 5
    44ae:	cd bf       	out	0x3d, r28	; 61
    44b0:	de bf       	out	0x3e, r29	; 62
    44b2:	df 91       	pop	r29
    44b4:	cf 91       	pop	r28
    44b6:	1f 91       	pop	r17
    44b8:	08 95       	ret

000044ba <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    44ba:	cf 93       	push	r28
    44bc:	df 93       	push	r29
    44be:	cd b7       	in	r28, 0x3d	; 61
    44c0:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    44c2:	24 e1       	ldi	r18, 0x14	; 20
    44c4:	86 e3       	ldi	r24, 0x36	; 54
    44c6:	91 e2       	ldi	r25, 0x21	; 33
    44c8:	fc 01       	movw	r30, r24
    44ca:	32 2f       	mov	r19, r18
    44cc:	11 92       	st	Z+, r1
    44ce:	3a 95       	dec	r19
    44d0:	e9 f7       	brne	.-6      	; 0x44cc <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    44d2:	0e 94 2e 2f 	call	0x5e5c	; 0x5e5c <chb_get_short_addr>
    44d6:	80 93 36 21 	sts	0x2136, r24
    44da:	90 93 37 21 	sts	0x2137, r25
    chb_drvr_init();
    44de:	0e 94 1e 31 	call	0x623c	; 0x623c <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    44e2:	df 91       	pop	r29
    44e4:	cf 91       	pop	r28
    44e6:	08 95       	ret

000044e8 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    44e8:	cf 93       	push	r28
    44ea:	df 93       	push	r29
    44ec:	cd b7       	in	r28, 0x3d	; 61
    44ee:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    44f0:	80 e8       	ldi	r24, 0x80	; 128
    44f2:	96 e0       	ldi	r25, 0x06	; 6
    44f4:	24 e0       	ldi	r18, 0x04	; 4
    44f6:	fc 01       	movw	r30, r24
    44f8:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    44fa:	80 e8       	ldi	r24, 0x80	; 128
    44fc:	96 e0       	ldi	r25, 0x06	; 6
    44fe:	24 e0       	ldi	r18, 0x04	; 4
    4500:	fc 01       	movw	r30, r24
    4502:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    4504:	80 e8       	ldi	r24, 0x80	; 128
    4506:	96 e0       	ldi	r25, 0x06	; 6
    4508:	22 e0       	ldi	r18, 0x02	; 2
    450a:	fc 01       	movw	r30, r24
    450c:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    450e:	80 e8       	ldi	r24, 0x80	; 128
    4510:	96 e0       	ldi	r25, 0x06	; 6
    4512:	24 e0       	ldi	r18, 0x04	; 4
    4514:	fc 01       	movw	r30, r24
    4516:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    4518:	80 e8       	ldi	r24, 0x80	; 128
    451a:	96 e0       	ldi	r25, 0x06	; 6
    451c:	23 e0       	ldi	r18, 0x03	; 3
    451e:	fc 01       	movw	r30, r24
    4520:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    4522:	80 ea       	ldi	r24, 0xA0	; 160
    4524:	90 e0       	ldi	r25, 0x00	; 0
    4526:	20 ea       	ldi	r18, 0xA0	; 160
    4528:	30 e0       	ldi	r19, 0x00	; 0
    452a:	f9 01       	movw	r30, r18
    452c:	22 81       	ldd	r18, Z+2	; 0x02
    452e:	24 60       	ori	r18, 0x04	; 4
    4530:	fc 01       	movw	r30, r24
    4532:	22 83       	std	Z+2, r18	; 0x02
	sei();
    4534:	78 94       	sei
}
    4536:	df 91       	pop	r29
    4538:	cf 91       	pop	r28
    453a:	08 95       	ret

0000453c <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    453c:	cf 93       	push	r28
    453e:	df 93       	push	r29
    4540:	cd b7       	in	r28, 0x3d	; 61
    4542:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    4544:	86 e3       	ldi	r24, 0x36	; 54
    4546:	91 e2       	ldi	r25, 0x21	; 33
}
    4548:	df 91       	pop	r29
    454a:	cf 91       	pop	r28
    454c:	08 95       	ret

0000454e <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    454e:	cf 93       	push	r28
    4550:	df 93       	push	r29
    4552:	cd b7       	in	r28, 0x3d	; 61
    4554:	de b7       	in	r29, 0x3e	; 62
    4556:	27 97       	sbiw	r28, 0x07	; 7
    4558:	cd bf       	out	0x3d, r28	; 61
    455a:	de bf       	out	0x3e, r29	; 62
    455c:	8b 83       	std	Y+3, r24	; 0x03
    455e:	9c 83       	std	Y+4, r25	; 0x04
    4560:	6d 83       	std	Y+5, r22	; 0x05
    4562:	7e 83       	std	Y+6, r23	; 0x06
    4564:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    4566:	8b 81       	ldd	r24, Y+3	; 0x03
    4568:	9c 81       	ldd	r25, Y+4	; 0x04
    456a:	89 83       	std	Y+1, r24	; 0x01
    456c:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    456e:	8f 81       	ldd	r24, Y+7	; 0x07
    4570:	28 2f       	mov	r18, r24
    4572:	25 5f       	subi	r18, 0xF5	; 245
    4574:	89 81       	ldd	r24, Y+1	; 0x01
    4576:	9a 81       	ldd	r25, Y+2	; 0x02
    4578:	fc 01       	movw	r30, r24
    457a:	20 83       	st	Z, r18
    457c:	89 81       	ldd	r24, Y+1	; 0x01
    457e:	9a 81       	ldd	r25, Y+2	; 0x02
    4580:	01 96       	adiw	r24, 0x01	; 1
    4582:	89 83       	std	Y+1, r24	; 0x01
    4584:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    4586:	8d 81       	ldd	r24, Y+5	; 0x05
    4588:	9e 81       	ldd	r25, Y+6	; 0x06
    458a:	ff ef       	ldi	r31, 0xFF	; 255
    458c:	8f 3f       	cpi	r24, 0xFF	; 255
    458e:	9f 07       	cpc	r25, r31
    4590:	11 f0       	breq	.+4      	; 0x4596 <chb_gen_hdr+0x48>
    4592:	21 e6       	ldi	r18, 0x61	; 97
    4594:	01 c0       	rjmp	.+2      	; 0x4598 <chb_gen_hdr+0x4a>
    4596:	21 e4       	ldi	r18, 0x41	; 65
    4598:	89 81       	ldd	r24, Y+1	; 0x01
    459a:	9a 81       	ldd	r25, Y+2	; 0x02
    459c:	fc 01       	movw	r30, r24
    459e:	20 83       	st	Z, r18
    45a0:	89 81       	ldd	r24, Y+1	; 0x01
    45a2:	9a 81       	ldd	r25, Y+2	; 0x02
    45a4:	01 96       	adiw	r24, 0x01	; 1
    45a6:	89 83       	std	Y+1, r24	; 0x01
    45a8:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    45aa:	89 81       	ldd	r24, Y+1	; 0x01
    45ac:	9a 81       	ldd	r25, Y+2	; 0x02
    45ae:	28 e9       	ldi	r18, 0x98	; 152
    45b0:	fc 01       	movw	r30, r24
    45b2:	20 83       	st	Z, r18
    45b4:	89 81       	ldd	r24, Y+1	; 0x01
    45b6:	9a 81       	ldd	r25, Y+2	; 0x02
    45b8:	01 96       	adiw	r24, 0x01	; 1
    45ba:	89 83       	std	Y+1, r24	; 0x01
    45bc:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    45be:	20 91 38 21 	lds	r18, 0x2138
    45c2:	89 81       	ldd	r24, Y+1	; 0x01
    45c4:	9a 81       	ldd	r25, Y+2	; 0x02
    45c6:	fc 01       	movw	r30, r24
    45c8:	20 83       	st	Z, r18
    45ca:	89 81       	ldd	r24, Y+1	; 0x01
    45cc:	9a 81       	ldd	r25, Y+2	; 0x02
    45ce:	01 96       	adiw	r24, 0x01	; 1
    45d0:	89 83       	std	Y+1, r24	; 0x01
    45d2:	9a 83       	std	Y+2, r25	; 0x02
    45d4:	82 2f       	mov	r24, r18
    45d6:	8f 5f       	subi	r24, 0xFF	; 255
    45d8:	80 93 38 21 	sts	0x2138, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    45dc:	89 81       	ldd	r24, Y+1	; 0x01
    45de:	9a 81       	ldd	r25, Y+2	; 0x02
    45e0:	24 e3       	ldi	r18, 0x34	; 52
    45e2:	32 e1       	ldi	r19, 0x12	; 18
    45e4:	fc 01       	movw	r30, r24
    45e6:	20 83       	st	Z, r18
    45e8:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    45ea:	89 81       	ldd	r24, Y+1	; 0x01
    45ec:	9a 81       	ldd	r25, Y+2	; 0x02
    45ee:	02 96       	adiw	r24, 0x02	; 2
    45f0:	89 83       	std	Y+1, r24	; 0x01
    45f2:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    45f4:	89 81       	ldd	r24, Y+1	; 0x01
    45f6:	9a 81       	ldd	r25, Y+2	; 0x02
    45f8:	2d 81       	ldd	r18, Y+5	; 0x05
    45fa:	3e 81       	ldd	r19, Y+6	; 0x06
    45fc:	fc 01       	movw	r30, r24
    45fe:	20 83       	st	Z, r18
    4600:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    4602:	89 81       	ldd	r24, Y+1	; 0x01
    4604:	9a 81       	ldd	r25, Y+2	; 0x02
    4606:	02 96       	adiw	r24, 0x02	; 2
    4608:	89 83       	std	Y+1, r24	; 0x01
    460a:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    460c:	20 91 36 21 	lds	r18, 0x2136
    4610:	30 91 37 21 	lds	r19, 0x2137
    4614:	89 81       	ldd	r24, Y+1	; 0x01
    4616:	9a 81       	ldd	r25, Y+2	; 0x02
    4618:	fc 01       	movw	r30, r24
    461a:	20 83       	st	Z, r18
    461c:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    461e:	89 81       	ldd	r24, Y+1	; 0x01
    4620:	9a 81       	ldd	r25, Y+2	; 0x02
    4622:	02 96       	adiw	r24, 0x02	; 2
    4624:	89 83       	std	Y+1, r24	; 0x01
    4626:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    4628:	29 81       	ldd	r18, Y+1	; 0x01
    462a:	3a 81       	ldd	r19, Y+2	; 0x02
    462c:	8b 81       	ldd	r24, Y+3	; 0x03
    462e:	9c 81       	ldd	r25, Y+4	; 0x04
    4630:	a9 01       	movw	r20, r18
    4632:	48 1b       	sub	r20, r24
    4634:	59 0b       	sbc	r21, r25
    4636:	ca 01       	movw	r24, r20
}
    4638:	27 96       	adiw	r28, 0x07	; 7
    463a:	cd bf       	out	0x3d, r28	; 61
    463c:	de bf       	out	0x3e, r29	; 62
    463e:	df 91       	pop	r29
    4640:	cf 91       	pop	r28
    4642:	08 95       	ret

00004644 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    4644:	ef 92       	push	r14
    4646:	ff 92       	push	r15
    4648:	0f 93       	push	r16
    464a:	1f 93       	push	r17
    464c:	cf 93       	push	r28
    464e:	df 93       	push	r29
    4650:	cd b7       	in	r28, 0x3d	; 61
    4652:	de b7       	in	r29, 0x3e	; 62
    4654:	68 97       	sbiw	r28, 0x18	; 24
    4656:	cd bf       	out	0x3d, r28	; 61
    4658:	de bf       	out	0x3e, r29	; 62
    465a:	89 8b       	std	Y+17, r24	; 0x11
    465c:	9a 8b       	std	Y+18, r25	; 0x12
    465e:	6b 8b       	std	Y+19, r22	; 0x13
    4660:	7c 8b       	std	Y+20, r23	; 0x14
    4662:	2d 8b       	std	Y+21, r18	; 0x15
    4664:	3e 8b       	std	Y+22, r19	; 0x16
    4666:	4f 8b       	std	Y+23, r20	; 0x17
    4668:	58 8f       	std	Y+24, r21	; 0x18
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    466a:	19 82       	std	Y+1, r1	; 0x01
    466c:	1a 82       	std	Y+2, r1	; 0x02
    466e:	1b 82       	std	Y+3, r1	; 0x03
    4670:	1c 82       	std	Y+4, r1	; 0x04
    while (len > 0)
    4672:	7b c0       	rjmp	.+246    	; 0x476a <chb_write+0x126>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    4674:	8d 89       	ldd	r24, Y+21	; 0x15
    4676:	9e 89       	ldd	r25, Y+22	; 0x16
    4678:	af 89       	ldd	r26, Y+23	; 0x17
    467a:	b8 8d       	ldd	r27, Y+24	; 0x18
    467c:	85 36       	cpi	r24, 0x65	; 101
    467e:	91 05       	cpc	r25, r1
    4680:	a1 05       	cpc	r26, r1
    4682:	b1 05       	cpc	r27, r1
    4684:	20 f0       	brcs	.+8      	; 0x468e <chb_write+0x4a>
    4686:	84 e6       	ldi	r24, 0x64	; 100
    4688:	90 e0       	ldi	r25, 0x00	; 0
    468a:	a0 e0       	ldi	r26, 0x00	; 0
    468c:	b0 e0       	ldi	r27, 0x00	; 0
    468e:	8d 83       	std	Y+5, r24	; 0x05

        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);
    4690:	ce 01       	movw	r24, r28
    4692:	07 96       	adiw	r24, 0x07	; 7
    4694:	29 89       	ldd	r18, Y+17	; 0x11
    4696:	3a 89       	ldd	r19, Y+18	; 0x12
    4698:	b9 01       	movw	r22, r18
    469a:	4d 81       	ldd	r20, Y+5	; 0x05
    469c:	0e 94 a7 22 	call	0x454e	; 0x454e <chb_gen_hdr>

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    46a0:	89 81       	ldd	r24, Y+1	; 0x01
    46a2:	9a 81       	ldd	r25, Y+2	; 0x02
    46a4:	2b 89       	ldd	r18, Y+19	; 0x13
    46a6:	3c 89       	ldd	r19, Y+20	; 0x14
    46a8:	28 0f       	add	r18, r24
    46aa:	39 1f       	adc	r19, r25
    46ac:	ce 01       	movw	r24, r28
    46ae:	07 96       	adiw	r24, 0x07	; 7
    46b0:	b9 01       	movw	r22, r18
    46b2:	4d 81       	ldd	r20, Y+5	; 0x05
    46b4:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <chb_tx>
    46b8:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    46ba:	8e 81       	ldd	r24, Y+6	; 0x06
    46bc:	88 2f       	mov	r24, r24
    46be:	90 e0       	ldi	r25, 0x00	; 0
    46c0:	83 30       	cpi	r24, 0x03	; 3
    46c2:	91 05       	cpc	r25, r1
    46c4:	09 f1       	breq	.+66     	; 0x4708 <chb_write+0xc4>
    46c6:	84 30       	cpi	r24, 0x04	; 4
    46c8:	91 05       	cpc	r25, r1
    46ca:	24 f4       	brge	.+8      	; 0x46d4 <chb_write+0x90>
    46cc:	81 30       	cpi	r24, 0x01	; 1
    46ce:	91 05       	cpc	r25, r1
    46d0:	39 f0       	breq	.+14     	; 0x46e0 <chb_write+0x9c>
    46d2:	24 c0       	rjmp	.+72     	; 0x471c <chb_write+0xd8>
    46d4:	85 30       	cpi	r24, 0x05	; 5
    46d6:	91 05       	cpc	r25, r1
    46d8:	69 f0       	breq	.+26     	; 0x46f4 <chb_write+0xb0>
    46da:	80 34       	cpi	r24, 0x40	; 64
    46dc:	91 05       	cpc	r25, r1
    46de:	f1 f4       	brne	.+60     	; 0x471c <chb_write+0xd8>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    46e0:	80 91 3d 21 	lds	r24, 0x213D
    46e4:	90 91 3e 21 	lds	r25, 0x213E
    46e8:	01 96       	adiw	r24, 0x01	; 1
    46ea:	80 93 3d 21 	sts	0x213D, r24
    46ee:	90 93 3e 21 	sts	0x213E, r25
                 break;
    46f2:	15 c0       	rjmp	.+42     	; 0x471e <chb_write+0xda>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    46f4:	80 91 3f 21 	lds	r24, 0x213F
    46f8:	90 91 40 21 	lds	r25, 0x2140
    46fc:	01 96       	adiw	r24, 0x01	; 1
    46fe:	80 93 3f 21 	sts	0x213F, r24
    4702:	90 93 40 21 	sts	0x2140, r25
				 //rtry++;
                 break;
    4706:	0b c0       	rjmp	.+22     	; 0x471e <chb_write+0xda>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    4708:	80 91 41 21 	lds	r24, 0x2141
    470c:	90 91 42 21 	lds	r25, 0x2142
    4710:	01 96       	adiw	r24, 0x01	; 1
    4712:	80 93 41 21 	sts	0x2141, r24
    4716:	90 93 42 21 	sts	0x2142, r25
				 //rtry++;
                 break;
    471a:	01 c0       	rjmp	.+2      	; 0x471e <chb_write+0xda>
 
             default:
                 break;
    471c:	00 00       	nop
             }
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    471e:	8d 81       	ldd	r24, Y+5	; 0x05
    4720:	88 2f       	mov	r24, r24
    4722:	90 e0       	ldi	r25, 0x00	; 0
    4724:	a0 e0       	ldi	r26, 0x00	; 0
    4726:	b0 e0       	ldi	r27, 0x00	; 0
    4728:	29 81       	ldd	r18, Y+1	; 0x01
    472a:	3a 81       	ldd	r19, Y+2	; 0x02
    472c:	4b 81       	ldd	r20, Y+3	; 0x03
    472e:	5c 81       	ldd	r21, Y+4	; 0x04
    4730:	82 0f       	add	r24, r18
    4732:	93 1f       	adc	r25, r19
    4734:	a4 1f       	adc	r26, r20
    4736:	b5 1f       	adc	r27, r21
    4738:	89 83       	std	Y+1, r24	; 0x01
    473a:	9a 83       	std	Y+2, r25	; 0x02
    473c:	ab 83       	std	Y+3, r26	; 0x03
    473e:	bc 83       	std	Y+4, r27	; 0x04
        len = len - frm_len;
    4740:	8d 81       	ldd	r24, Y+5	; 0x05
    4742:	88 2f       	mov	r24, r24
    4744:	90 e0       	ldi	r25, 0x00	; 0
    4746:	a0 e0       	ldi	r26, 0x00	; 0
    4748:	b0 e0       	ldi	r27, 0x00	; 0
    474a:	2d 89       	ldd	r18, Y+21	; 0x15
    474c:	3e 89       	ldd	r19, Y+22	; 0x16
    474e:	4f 89       	ldd	r20, Y+23	; 0x17
    4750:	58 8d       	ldd	r21, Y+24	; 0x18
    4752:	79 01       	movw	r14, r18
    4754:	8a 01       	movw	r16, r20
    4756:	e8 1a       	sub	r14, r24
    4758:	f9 0a       	sbc	r15, r25
    475a:	0a 0b       	sbc	r16, r26
    475c:	1b 0b       	sbc	r17, r27
    475e:	d8 01       	movw	r26, r16
    4760:	c7 01       	movw	r24, r14
    4762:	8d 8b       	std	Y+21, r24	; 0x15
    4764:	9e 8b       	std	Y+22, r25	; 0x16
    4766:	af 8b       	std	Y+23, r26	; 0x17
    4768:	b8 8f       	std	Y+24, r27	; 0x18
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    476a:	8d 89       	ldd	r24, Y+21	; 0x15
    476c:	9e 89       	ldd	r25, Y+22	; 0x16
    476e:	af 89       	ldd	r26, Y+23	; 0x17
    4770:	b8 8d       	ldd	r27, Y+24	; 0x18
    4772:	00 97       	sbiw	r24, 0x00	; 0
    4774:	a1 05       	cpc	r26, r1
    4776:	b1 05       	cpc	r27, r1
    4778:	09 f0       	breq	.+2      	; 0x477c <chb_write+0x138>
    477a:	7c cf       	rjmp	.-264    	; 0x4674 <chb_write+0x30>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(100);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    477c:	80 e0       	ldi	r24, 0x00	; 0
}
    477e:	68 96       	adiw	r28, 0x18	; 24
    4780:	cd bf       	out	0x3d, r28	; 61
    4782:	de bf       	out	0x3e, r29	; 62
    4784:	df 91       	pop	r29
    4786:	cf 91       	pop	r28
    4788:	1f 91       	pop	r17
    478a:	0f 91       	pop	r16
    478c:	ff 90       	pop	r15
    478e:	ef 90       	pop	r14
    4790:	08 95       	ret

00004792 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4792:	cf 93       	push	r28
    4794:	df 93       	push	r29
    4796:	cd b7       	in	r28, 0x3d	; 61
    4798:	de b7       	in	r29, 0x3e	; 62
    479a:	27 97       	sbiw	r28, 0x07	; 7
    479c:	cd bf       	out	0x3d, r28	; 61
    479e:	de bf       	out	0x3e, r29	; 62
    47a0:	8e 83       	std	Y+6, r24	; 0x06
    47a2:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    47a4:	8e 81       	ldd	r24, Y+6	; 0x06
    47a6:	9f 81       	ldd	r25, Y+7	; 0x07
    47a8:	05 96       	adiw	r24, 0x05	; 5
    47aa:	8a 83       	std	Y+2, r24	; 0x02
    47ac:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    47ae:	0e 94 96 24 	call	0x492c	; 0x492c <chb_buf_read>
    47b2:	8c 83       	std	Y+4, r24	; 0x04
    47b4:	8c 81       	ldd	r24, Y+4	; 0x04
    47b6:	88 23       	and	r24, r24
    47b8:	14 f4       	brge	.+4      	; 0x47be <chb_read+0x2c>
    {
        return 0;
    47ba:	80 e0       	ldi	r24, 0x00	; 0
    47bc:	80 c0       	rjmp	.+256    	; 0x48be <chb_read+0x12c>
    }
    *data_ptr++ = len;
    47be:	8a 81       	ldd	r24, Y+2	; 0x02
    47c0:	9b 81       	ldd	r25, Y+3	; 0x03
    47c2:	2c 81       	ldd	r18, Y+4	; 0x04
    47c4:	fc 01       	movw	r30, r24
    47c6:	20 83       	st	Z, r18
    47c8:	8a 81       	ldd	r24, Y+2	; 0x02
    47ca:	9b 81       	ldd	r25, Y+3	; 0x03
    47cc:	01 96       	adiw	r24, 0x01	; 1
    47ce:	8a 83       	std	Y+2, r24	; 0x02
    47d0:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    47d2:	19 82       	std	Y+1, r1	; 0x01
    47d4:	0f c0       	rjmp	.+30     	; 0x47f4 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    47d6:	0e 94 96 24 	call	0x492c	; 0x492c <chb_buf_read>
    47da:	28 2f       	mov	r18, r24
    47dc:	8a 81       	ldd	r24, Y+2	; 0x02
    47de:	9b 81       	ldd	r25, Y+3	; 0x03
    47e0:	fc 01       	movw	r30, r24
    47e2:	20 83       	st	Z, r18
    47e4:	8a 81       	ldd	r24, Y+2	; 0x02
    47e6:	9b 81       	ldd	r25, Y+3	; 0x03
    47e8:	01 96       	adiw	r24, 0x01	; 1
    47ea:	8a 83       	std	Y+2, r24	; 0x02
    47ec:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    47ee:	89 81       	ldd	r24, Y+1	; 0x01
    47f0:	8f 5f       	subi	r24, 0xFF	; 255
    47f2:	89 83       	std	Y+1, r24	; 0x01
    47f4:	99 81       	ldd	r25, Y+1	; 0x01
    47f6:	8c 81       	ldd	r24, Y+4	; 0x04
    47f8:	98 17       	cp	r25, r24
    47fa:	68 f3       	brcs	.-38     	; 0x47d6 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    47fc:	8e 81       	ldd	r24, Y+6	; 0x06
    47fe:	9f 81       	ldd	r25, Y+7	; 0x07
    4800:	08 96       	adiw	r24, 0x08	; 8
    4802:	8a 83       	std	Y+2, r24	; 0x02
    4804:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4806:	8a 81       	ldd	r24, Y+2	; 0x02
    4808:	9b 81       	ldd	r25, Y+3	; 0x03
    480a:	fc 01       	movw	r30, r24
    480c:	80 81       	ld	r24, Z
    480e:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    4810:	8e 81       	ldd	r24, Y+6	; 0x06
    4812:	9f 81       	ldd	r25, Y+7	; 0x07
    4814:	0b 96       	adiw	r24, 0x0b	; 11
    4816:	8a 83       	std	Y+2, r24	; 0x02
    4818:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    481a:	8a 81       	ldd	r24, Y+2	; 0x02
    481c:	9b 81       	ldd	r25, Y+3	; 0x03
    481e:	fc 01       	movw	r30, r24
    4820:	20 81       	ld	r18, Z
    4822:	31 81       	ldd	r19, Z+1	; 0x01
    4824:	8e 81       	ldd	r24, Y+6	; 0x06
    4826:	9f 81       	ldd	r25, Y+7	; 0x07
    4828:	fc 01       	movw	r30, r24
    482a:	23 83       	std	Z+3, r18	; 0x03
    482c:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    482e:	8a 81       	ldd	r24, Y+2	; 0x02
    4830:	9b 81       	ldd	r25, Y+3	; 0x03
    4832:	02 96       	adiw	r24, 0x02	; 2
    4834:	8a 83       	std	Y+2, r24	; 0x02
    4836:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    4838:	8a 81       	ldd	r24, Y+2	; 0x02
    483a:	9b 81       	ldd	r25, Y+3	; 0x03
    483c:	fc 01       	movw	r30, r24
    483e:	20 81       	ld	r18, Z
    4840:	31 81       	ldd	r19, Z+1	; 0x01
    4842:	8e 81       	ldd	r24, Y+6	; 0x06
    4844:	9f 81       	ldd	r25, Y+7	; 0x07
    4846:	fc 01       	movw	r30, r24
    4848:	21 83       	std	Z+1, r18	; 0x01
    484a:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    484c:	8a 81       	ldd	r24, Y+2	; 0x02
    484e:	9b 81       	ldd	r25, Y+3	; 0x03
    4850:	02 96       	adiw	r24, 0x02	; 2
    4852:	8a 83       	std	Y+2, r24	; 0x02
    4854:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    4856:	0e 94 ba 24 	call	0x4974	; 0x4974 <chb_buf_get_len>
    485a:	88 23       	and	r24, r24
    485c:	11 f4       	brne	.+4      	; 0x4862 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    485e:	10 92 39 21 	sts	0x2139, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    4862:	80 91 0c 20 	lds	r24, 0x200C
    4866:	9d 81       	ldd	r25, Y+5	; 0x05
    4868:	98 17       	cp	r25, r24
    486a:	71 f4       	brne	.+28     	; 0x4888 <chb_read+0xf6>
    486c:	8e 81       	ldd	r24, Y+6	; 0x06
    486e:	9f 81       	ldd	r25, Y+7	; 0x07
    4870:	fc 01       	movw	r30, r24
    4872:	21 81       	ldd	r18, Z+1	; 0x01
    4874:	32 81       	ldd	r19, Z+2	; 0x02
    4876:	80 91 0d 20 	lds	r24, 0x200D
    487a:	90 91 0e 20 	lds	r25, 0x200E
    487e:	28 17       	cp	r18, r24
    4880:	39 07       	cpc	r19, r25
    4882:	11 f4       	brne	.+4      	; 0x4888 <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    4884:	80 e0       	ldi	r24, 0x00	; 0
    4886:	1b c0       	rjmp	.+54     	; 0x48be <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    4888:	8d 81       	ldd	r24, Y+5	; 0x05
    488a:	80 93 0c 20 	sts	0x200C, r24
        prev_src_addr = rx->src_addr;
    488e:	8e 81       	ldd	r24, Y+6	; 0x06
    4890:	9f 81       	ldd	r25, Y+7	; 0x07
    4892:	fc 01       	movw	r30, r24
    4894:	81 81       	ldd	r24, Z+1	; 0x01
    4896:	92 81       	ldd	r25, Z+2	; 0x02
    4898:	80 93 0d 20 	sts	0x200D, r24
    489c:	90 93 0e 20 	sts	0x200E, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    48a0:	8c 81       	ldd	r24, Y+4	; 0x04
    48a2:	88 2f       	mov	r24, r24
    48a4:	90 e0       	ldi	r25, 0x00	; 0
    48a6:	09 97       	sbiw	r24, 0x09	; 9
    48a8:	9c 01       	movw	r18, r24
    48aa:	8e 81       	ldd	r24, Y+6	; 0x06
    48ac:	9f 81       	ldd	r25, Y+7	; 0x07
    48ae:	4a 81       	ldd	r20, Y+2	; 0x02
    48b0:	5b 81       	ldd	r21, Y+3	; 0x03
    48b2:	ba 01       	movw	r22, r20
    48b4:	a9 01       	movw	r20, r18
    48b6:	0e 94 08 61 	call	0xc210	; 0xc210 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    48ba:	8c 81       	ldd	r24, Y+4	; 0x04
    48bc:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    48be:	27 96       	adiw	r28, 0x07	; 7
    48c0:	cd bf       	out	0x3d, r28	; 61
    48c2:	de bf       	out	0x3e, r29	; 62
    48c4:	df 91       	pop	r29
    48c6:	cf 91       	pop	r28
    48c8:	08 95       	ret

000048ca <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    48ca:	cf 93       	push	r28
    48cc:	df 93       	push	r29
    48ce:	cd b7       	in	r28, 0x3d	; 61
    48d0:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    48d2:	10 92 ca 21 	sts	0x21CA, r1
    wr_ptr = 0;
    48d6:	10 92 cb 21 	sts	0x21CB, r1
    len = 0;
    48da:	10 92 cc 21 	sts	0x21CC, r1
}
    48de:	df 91       	pop	r29
    48e0:	cf 91       	pop	r28
    48e2:	08 95       	ret

000048e4 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    48e4:	cf 93       	push	r28
    48e6:	df 93       	push	r29
    48e8:	0f 92       	push	r0
    48ea:	cd b7       	in	r28, 0x3d	; 61
    48ec:	de b7       	in	r29, 0x3e	; 62
    48ee:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    48f0:	80 91 cb 21 	lds	r24, 0x21CB
    48f4:	88 2f       	mov	r24, r24
    48f6:	90 e0       	ldi	r25, 0x00	; 0
    48f8:	86 5b       	subi	r24, 0xB6	; 182
    48fa:	9e 4d       	sbci	r25, 0xDE	; 222
    48fc:	29 81       	ldd	r18, Y+1	; 0x01
    48fe:	fc 01       	movw	r30, r24
    4900:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4902:	80 91 cb 21 	lds	r24, 0x21CB
    4906:	88 2f       	mov	r24, r24
    4908:	90 e0       	ldi	r25, 0x00	; 0
    490a:	01 96       	adiw	r24, 0x01	; 1
    490c:	20 e8       	ldi	r18, 0x80	; 128
    490e:	30 e0       	ldi	r19, 0x00	; 0
    4910:	b9 01       	movw	r22, r18
    4912:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    4916:	80 93 cb 21 	sts	0x21CB, r24
    len++;
    491a:	80 91 cc 21 	lds	r24, 0x21CC
    491e:	8f 5f       	subi	r24, 0xFF	; 255
    4920:	80 93 cc 21 	sts	0x21CC, r24
}
    4924:	0f 90       	pop	r0
    4926:	df 91       	pop	r29
    4928:	cf 91       	pop	r28
    492a:	08 95       	ret

0000492c <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    492c:	cf 93       	push	r28
    492e:	df 93       	push	r29
    4930:	0f 92       	push	r0
    4932:	cd b7       	in	r28, 0x3d	; 61
    4934:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    4936:	80 91 ca 21 	lds	r24, 0x21CA
    493a:	88 2f       	mov	r24, r24
    493c:	90 e0       	ldi	r25, 0x00	; 0
    493e:	86 5b       	subi	r24, 0xB6	; 182
    4940:	9e 4d       	sbci	r25, 0xDE	; 222
    4942:	fc 01       	movw	r30, r24
    4944:	80 81       	ld	r24, Z
    4946:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    4948:	80 91 ca 21 	lds	r24, 0x21CA
    494c:	88 2f       	mov	r24, r24
    494e:	90 e0       	ldi	r25, 0x00	; 0
    4950:	01 96       	adiw	r24, 0x01	; 1
    4952:	20 e8       	ldi	r18, 0x80	; 128
    4954:	30 e0       	ldi	r19, 0x00	; 0
    4956:	b9 01       	movw	r22, r18
    4958:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    495c:	80 93 ca 21 	sts	0x21CA, r24
    len--;
    4960:	80 91 cc 21 	lds	r24, 0x21CC
    4964:	81 50       	subi	r24, 0x01	; 1
    4966:	80 93 cc 21 	sts	0x21CC, r24
    return data;
    496a:	89 81       	ldd	r24, Y+1	; 0x01
}
    496c:	0f 90       	pop	r0
    496e:	df 91       	pop	r29
    4970:	cf 91       	pop	r28
    4972:	08 95       	ret

00004974 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    4974:	cf 93       	push	r28
    4976:	df 93       	push	r29
    4978:	cd b7       	in	r28, 0x3d	; 61
    497a:	de b7       	in	r29, 0x3e	; 62
    return len;
    497c:	80 91 cc 21 	lds	r24, 0x21CC
}
    4980:	df 91       	pop	r29
    4982:	cf 91       	pop	r28
    4984:	08 95       	ret

00004986 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    4986:	cf 93       	push	r28
    4988:	df 93       	push	r29
    498a:	cd b7       	in	r28, 0x3d	; 61
    498c:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    498e:	81 e0       	ldi	r24, 0x01	; 1
    4990:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    4994:	8f 71       	andi	r24, 0x1F	; 31
}
    4996:	df 91       	pop	r29
    4998:	cf 91       	pop	r28
    499a:	08 95       	ret

0000499c <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    499c:	cf 93       	push	r28
    499e:	df 93       	push	r29
    49a0:	cd b7       	in	r28, 0x3d	; 61
    49a2:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    49a4:	82 e0       	ldi	r24, 0x02	; 2
    49a6:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    49aa:	82 95       	swap	r24
    49ac:	86 95       	lsr	r24
    49ae:	87 70       	andi	r24, 0x07	; 7
}
    49b0:	df 91       	pop	r29
    49b2:	cf 91       	pop	r28
    49b4:	08 95       	ret

000049b6 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    49b6:	0f 93       	push	r16
    49b8:	1f 93       	push	r17
    49ba:	cf 93       	push	r28
    49bc:	df 93       	push	r29
    49be:	cd b7       	in	r28, 0x3d	; 61
    49c0:	de b7       	in	r29, 0x3e	; 62
    49c2:	e0 97       	sbiw	r28, 0x30	; 48
    49c4:	cd bf       	out	0x3d, r28	; 61
    49c6:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    49c8:	84 e6       	ldi	r24, 0x64	; 100
    49ca:	96 e0       	ldi	r25, 0x06	; 6
    49cc:	24 e6       	ldi	r18, 0x64	; 100
    49ce:	36 e0       	ldi	r19, 0x06	; 6
    49d0:	f9 01       	movw	r30, r18
    49d2:	20 81       	ld	r18, Z
    49d4:	21 60       	ori	r18, 0x01	; 1
    49d6:	fc 01       	movw	r30, r24
    49d8:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    49da:	84 e6       	ldi	r24, 0x64	; 100
    49dc:	96 e0       	ldi	r25, 0x06	; 6
    49de:	24 e6       	ldi	r18, 0x64	; 100
    49e0:	36 e0       	ldi	r19, 0x06	; 6
    49e2:	f9 01       	movw	r30, r18
    49e4:	20 81       	ld	r18, Z
    49e6:	2d 7f       	andi	r18, 0xFD	; 253
    49e8:	fc 01       	movw	r30, r24
    49ea:	20 83       	st	Z, r18
    49ec:	80 e0       	ldi	r24, 0x00	; 0
    49ee:	90 e0       	ldi	r25, 0x00	; 0
    49f0:	ae eb       	ldi	r26, 0xBE	; 190
    49f2:	b3 e4       	ldi	r27, 0x43	; 67
    49f4:	89 83       	std	Y+1, r24	; 0x01
    49f6:	9a 83       	std	Y+2, r25	; 0x02
    49f8:	ab 83       	std	Y+3, r26	; 0x03
    49fa:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    49fc:	69 81       	ldd	r22, Y+1	; 0x01
    49fe:	7a 81       	ldd	r23, Y+2	; 0x02
    4a00:	8b 81       	ldd	r24, Y+3	; 0x03
    4a02:	9c 81       	ldd	r25, Y+4	; 0x04
    4a04:	2b ea       	ldi	r18, 0xAB	; 171
    4a06:	3a ea       	ldi	r19, 0xAA	; 170
    4a08:	4a e2       	ldi	r20, 0x2A	; 42
    4a0a:	51 e4       	ldi	r21, 0x41	; 65
    4a0c:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4a10:	dc 01       	movw	r26, r24
    4a12:	cb 01       	movw	r24, r22
    4a14:	8d 83       	std	Y+5, r24	; 0x05
    4a16:	9e 83       	std	Y+6, r25	; 0x06
    4a18:	af 83       	std	Y+7, r26	; 0x07
    4a1a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    4a1c:	11 e0       	ldi	r17, 0x01	; 1
    4a1e:	6d 81       	ldd	r22, Y+5	; 0x05
    4a20:	7e 81       	ldd	r23, Y+6	; 0x06
    4a22:	8f 81       	ldd	r24, Y+7	; 0x07
    4a24:	98 85       	ldd	r25, Y+8	; 0x08
    4a26:	20 e0       	ldi	r18, 0x00	; 0
    4a28:	30 e0       	ldi	r19, 0x00	; 0
    4a2a:	40 e8       	ldi	r20, 0x80	; 128
    4a2c:	5f e3       	ldi	r21, 0x3F	; 63
    4a2e:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    4a32:	88 23       	and	r24, r24
    4a34:	0c f0       	brlt	.+2      	; 0x4a38 <chb_reset+0x82>
    4a36:	10 e0       	ldi	r17, 0x00	; 0
    4a38:	11 23       	and	r17, r17
    4a3a:	19 f0       	breq	.+6      	; 0x4a42 <chb_reset+0x8c>
		__ticks = 1;
    4a3c:	81 e0       	ldi	r24, 0x01	; 1
    4a3e:	89 87       	std	Y+9, r24	; 0x09
    4a40:	a3 c0       	rjmp	.+326    	; 0x4b88 <chb_reset+0x1d2>
	else if (__tmp > 255)
    4a42:	11 e0       	ldi	r17, 0x01	; 1
    4a44:	6d 81       	ldd	r22, Y+5	; 0x05
    4a46:	7e 81       	ldd	r23, Y+6	; 0x06
    4a48:	8f 81       	ldd	r24, Y+7	; 0x07
    4a4a:	98 85       	ldd	r25, Y+8	; 0x08
    4a4c:	20 e0       	ldi	r18, 0x00	; 0
    4a4e:	30 e0       	ldi	r19, 0x00	; 0
    4a50:	4f e7       	ldi	r20, 0x7F	; 127
    4a52:	53 e4       	ldi	r21, 0x43	; 67
    4a54:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    4a58:	18 16       	cp	r1, r24
    4a5a:	0c f0       	brlt	.+2      	; 0x4a5e <chb_reset+0xa8>
    4a5c:	10 e0       	ldi	r17, 0x00	; 0
    4a5e:	11 23       	and	r17, r17
    4a60:	09 f4       	brne	.+2      	; 0x4a64 <chb_reset+0xae>
    4a62:	89 c0       	rjmp	.+274    	; 0x4b76 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    4a64:	69 81       	ldd	r22, Y+1	; 0x01
    4a66:	7a 81       	ldd	r23, Y+2	; 0x02
    4a68:	8b 81       	ldd	r24, Y+3	; 0x03
    4a6a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6c:	20 e0       	ldi	r18, 0x00	; 0
    4a6e:	30 e0       	ldi	r19, 0x00	; 0
    4a70:	4a e7       	ldi	r20, 0x7A	; 122
    4a72:	54 e4       	ldi	r21, 0x44	; 68
    4a74:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    4a78:	dc 01       	movw	r26, r24
    4a7a:	cb 01       	movw	r24, r22
    4a7c:	8a 87       	std	Y+10, r24	; 0x0a
    4a7e:	9b 87       	std	Y+11, r25	; 0x0b
    4a80:	ac 87       	std	Y+12, r26	; 0x0c
    4a82:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4a84:	6a 85       	ldd	r22, Y+10	; 0x0a
    4a86:	7b 85       	ldd	r23, Y+11	; 0x0b
    4a88:	8c 85       	ldd	r24, Y+12	; 0x0c
    4a8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4a8c:	20 e0       	ldi	r18, 0x00	; 0
    4a8e:	30 e0       	ldi	r19, 0x00	; 0
    4a90:	4a ef       	ldi	r20, 0xFA	; 250
    4a92:	55 e4       	ldi	r21, 0x45	; 69
    4a94:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4a98:	dc 01       	movw	r26, r24
    4a9a:	cb 01       	movw	r24, r22
    4a9c:	8e 87       	std	Y+14, r24	; 0x0e
    4a9e:	9f 87       	std	Y+15, r25	; 0x0f
    4aa0:	a8 8b       	std	Y+16, r26	; 0x10
    4aa2:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    4aa4:	11 e0       	ldi	r17, 0x01	; 1
    4aa6:	6e 85       	ldd	r22, Y+14	; 0x0e
    4aa8:	7f 85       	ldd	r23, Y+15	; 0x0f
    4aaa:	88 89       	ldd	r24, Y+16	; 0x10
    4aac:	99 89       	ldd	r25, Y+17	; 0x11
    4aae:	20 e0       	ldi	r18, 0x00	; 0
    4ab0:	30 e0       	ldi	r19, 0x00	; 0
    4ab2:	40 e8       	ldi	r20, 0x80	; 128
    4ab4:	5f e3       	ldi	r21, 0x3F	; 63
    4ab6:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    4aba:	88 23       	and	r24, r24
    4abc:	0c f0       	brlt	.+2      	; 0x4ac0 <chb_reset+0x10a>
    4abe:	10 e0       	ldi	r17, 0x00	; 0
    4ac0:	11 23       	and	r17, r17
    4ac2:	29 f0       	breq	.+10     	; 0x4ace <chb_reset+0x118>
		__ticks = 1;
    4ac4:	81 e0       	ldi	r24, 0x01	; 1
    4ac6:	90 e0       	ldi	r25, 0x00	; 0
    4ac8:	8a 8b       	std	Y+18, r24	; 0x12
    4aca:	9b 8b       	std	Y+19, r25	; 0x13
    4acc:	46 c0       	rjmp	.+140    	; 0x4b5a <chb_reset+0x1a4>
	else if (__tmp > 65535)
    4ace:	11 e0       	ldi	r17, 0x01	; 1
    4ad0:	6e 85       	ldd	r22, Y+14	; 0x0e
    4ad2:	7f 85       	ldd	r23, Y+15	; 0x0f
    4ad4:	88 89       	ldd	r24, Y+16	; 0x10
    4ad6:	99 89       	ldd	r25, Y+17	; 0x11
    4ad8:	20 e0       	ldi	r18, 0x00	; 0
    4ada:	3f ef       	ldi	r19, 0xFF	; 255
    4adc:	4f e7       	ldi	r20, 0x7F	; 127
    4ade:	57 e4       	ldi	r21, 0x47	; 71
    4ae0:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    4ae4:	18 16       	cp	r1, r24
    4ae6:	0c f0       	brlt	.+2      	; 0x4aea <chb_reset+0x134>
    4ae8:	10 e0       	ldi	r17, 0x00	; 0
    4aea:	11 23       	and	r17, r17
    4aec:	61 f1       	breq	.+88     	; 0x4b46 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4aee:	6a 85       	ldd	r22, Y+10	; 0x0a
    4af0:	7b 85       	ldd	r23, Y+11	; 0x0b
    4af2:	8c 85       	ldd	r24, Y+12	; 0x0c
    4af4:	9d 85       	ldd	r25, Y+13	; 0x0d
    4af6:	20 e0       	ldi	r18, 0x00	; 0
    4af8:	30 e0       	ldi	r19, 0x00	; 0
    4afa:	40 e2       	ldi	r20, 0x20	; 32
    4afc:	51 e4       	ldi	r21, 0x41	; 65
    4afe:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4b02:	dc 01       	movw	r26, r24
    4b04:	cb 01       	movw	r24, r22
    4b06:	bc 01       	movw	r22, r24
    4b08:	cd 01       	movw	r24, r26
    4b0a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4b0e:	dc 01       	movw	r26, r24
    4b10:	cb 01       	movw	r24, r22
    4b12:	8a 8b       	std	Y+18, r24	; 0x12
    4b14:	9b 8b       	std	Y+19, r25	; 0x13
    4b16:	12 c0       	rjmp	.+36     	; 0x4b3c <chb_reset+0x186>
    4b18:	80 e2       	ldi	r24, 0x20	; 32
    4b1a:	93 e0       	ldi	r25, 0x03	; 3
    4b1c:	8c 8b       	std	Y+20, r24	; 0x14
    4b1e:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4b20:	8c 89       	ldd	r24, Y+20	; 0x14
    4b22:	9d 89       	ldd	r25, Y+21	; 0x15
    4b24:	8c 01       	movw	r16, r24
    4b26:	c8 01       	movw	r24, r16
    4b28:	01 97       	sbiw	r24, 0x01	; 1
    4b2a:	f1 f7       	brne	.-4      	; 0x4b28 <chb_reset+0x172>
    4b2c:	8c 01       	movw	r16, r24
    4b2e:	0c 8b       	std	Y+20, r16	; 0x14
    4b30:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b32:	8a 89       	ldd	r24, Y+18	; 0x12
    4b34:	9b 89       	ldd	r25, Y+19	; 0x13
    4b36:	01 97       	sbiw	r24, 0x01	; 1
    4b38:	8a 8b       	std	Y+18, r24	; 0x12
    4b3a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b3c:	8a 89       	ldd	r24, Y+18	; 0x12
    4b3e:	9b 89       	ldd	r25, Y+19	; 0x13
    4b40:	00 97       	sbiw	r24, 0x00	; 0
    4b42:	51 f7       	brne	.-44     	; 0x4b18 <chb_reset+0x162>
    4b44:	28 c0       	rjmp	.+80     	; 0x4b96 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b46:	6e 85       	ldd	r22, Y+14	; 0x0e
    4b48:	7f 85       	ldd	r23, Y+15	; 0x0f
    4b4a:	88 89       	ldd	r24, Y+16	; 0x10
    4b4c:	99 89       	ldd	r25, Y+17	; 0x11
    4b4e:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4b52:	dc 01       	movw	r26, r24
    4b54:	cb 01       	movw	r24, r22
    4b56:	8a 8b       	std	Y+18, r24	; 0x12
    4b58:	9b 8b       	std	Y+19, r25	; 0x13
    4b5a:	8a 89       	ldd	r24, Y+18	; 0x12
    4b5c:	9b 89       	ldd	r25, Y+19	; 0x13
    4b5e:	8e 8b       	std	Y+22, r24	; 0x16
    4b60:	9f 8b       	std	Y+23, r25	; 0x17
    4b62:	8e 89       	ldd	r24, Y+22	; 0x16
    4b64:	9f 89       	ldd	r25, Y+23	; 0x17
    4b66:	8c 01       	movw	r16, r24
    4b68:	f8 01       	movw	r30, r16
    4b6a:	31 97       	sbiw	r30, 0x01	; 1
    4b6c:	f1 f7       	brne	.-4      	; 0x4b6a <chb_reset+0x1b4>
    4b6e:	8f 01       	movw	r16, r30
    4b70:	0e 8b       	std	Y+22, r16	; 0x16
    4b72:	1f 8b       	std	Y+23, r17	; 0x17
    4b74:	10 c0       	rjmp	.+32     	; 0x4b96 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4b76:	6d 81       	ldd	r22, Y+5	; 0x05
    4b78:	7e 81       	ldd	r23, Y+6	; 0x06
    4b7a:	8f 81       	ldd	r24, Y+7	; 0x07
    4b7c:	98 85       	ldd	r25, Y+8	; 0x08
    4b7e:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4b82:	dc 01       	movw	r26, r24
    4b84:	cb 01       	movw	r24, r22
    4b86:	89 87       	std	Y+9, r24	; 0x09
    4b88:	89 85       	ldd	r24, Y+9	; 0x09
    4b8a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4b8c:	88 8d       	ldd	r24, Y+24	; 0x18
    4b8e:	18 2f       	mov	r17, r24
    4b90:	1a 95       	dec	r17
    4b92:	f1 f7       	brne	.-4      	; 0x4b90 <chb_reset+0x1da>
    4b94:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    4b96:	84 e6       	ldi	r24, 0x64	; 100
    4b98:	96 e0       	ldi	r25, 0x06	; 6
    4b9a:	24 e6       	ldi	r18, 0x64	; 100
    4b9c:	36 e0       	ldi	r19, 0x06	; 6
    4b9e:	f9 01       	movw	r30, r18
    4ba0:	20 81       	ld	r18, Z
    4ba2:	2e 7f       	andi	r18, 0xFE	; 254
    4ba4:	fc 01       	movw	r30, r24
    4ba6:	20 83       	st	Z, r18
    4ba8:	80 e0       	ldi	r24, 0x00	; 0
    4baa:	90 e0       	ldi	r25, 0x00	; 0
    4bac:	a0 e8       	ldi	r26, 0x80	; 128
    4bae:	bf e3       	ldi	r27, 0x3F	; 63
    4bb0:	89 8f       	std	Y+25, r24	; 0x19
    4bb2:	9a 8f       	std	Y+26, r25	; 0x1a
    4bb4:	ab 8f       	std	Y+27, r26	; 0x1b
    4bb6:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4bb8:	69 8d       	ldd	r22, Y+25	; 0x19
    4bba:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4bbc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4bbe:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4bc0:	2b ea       	ldi	r18, 0xAB	; 171
    4bc2:	3a ea       	ldi	r19, 0xAA	; 170
    4bc4:	4a e2       	ldi	r20, 0x2A	; 42
    4bc6:	51 e4       	ldi	r21, 0x41	; 65
    4bc8:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4bcc:	dc 01       	movw	r26, r24
    4bce:	cb 01       	movw	r24, r22
    4bd0:	8d 8f       	std	Y+29, r24	; 0x1d
    4bd2:	9e 8f       	std	Y+30, r25	; 0x1e
    4bd4:	af 8f       	std	Y+31, r26	; 0x1f
    4bd6:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    4bd8:	11 e0       	ldi	r17, 0x01	; 1
    4bda:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4bdc:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4bde:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4be0:	98 a1       	lds	r25, 0x48
    4be2:	20 e0       	ldi	r18, 0x00	; 0
    4be4:	30 e0       	ldi	r19, 0x00	; 0
    4be6:	40 e8       	ldi	r20, 0x80	; 128
    4be8:	5f e3       	ldi	r21, 0x3F	; 63
    4bea:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    4bee:	88 23       	and	r24, r24
    4bf0:	0c f0       	brlt	.+2      	; 0x4bf4 <chb_reset+0x23e>
    4bf2:	10 e0       	ldi	r17, 0x00	; 0
    4bf4:	11 23       	and	r17, r17
    4bf6:	19 f0       	breq	.+6      	; 0x4bfe <chb_reset+0x248>
		__ticks = 1;
    4bf8:	81 e0       	ldi	r24, 0x01	; 1
    4bfa:	89 a3       	lds	r24, 0x59
    4bfc:	a3 c0       	rjmp	.+326    	; 0x4d44 <chb_reset+0x38e>
	else if (__tmp > 255)
    4bfe:	11 e0       	ldi	r17, 0x01	; 1
    4c00:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4c02:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4c04:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4c06:	98 a1       	lds	r25, 0x48
    4c08:	20 e0       	ldi	r18, 0x00	; 0
    4c0a:	30 e0       	ldi	r19, 0x00	; 0
    4c0c:	4f e7       	ldi	r20, 0x7F	; 127
    4c0e:	53 e4       	ldi	r21, 0x43	; 67
    4c10:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    4c14:	18 16       	cp	r1, r24
    4c16:	0c f0       	brlt	.+2      	; 0x4c1a <chb_reset+0x264>
    4c18:	10 e0       	ldi	r17, 0x00	; 0
    4c1a:	11 23       	and	r17, r17
    4c1c:	09 f4       	brne	.+2      	; 0x4c20 <chb_reset+0x26a>
    4c1e:	89 c0       	rjmp	.+274    	; 0x4d32 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    4c20:	69 8d       	ldd	r22, Y+25	; 0x19
    4c22:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4c24:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4c26:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4c28:	20 e0       	ldi	r18, 0x00	; 0
    4c2a:	30 e0       	ldi	r19, 0x00	; 0
    4c2c:	4a e7       	ldi	r20, 0x7A	; 122
    4c2e:	54 e4       	ldi	r21, 0x44	; 68
    4c30:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    4c34:	dc 01       	movw	r26, r24
    4c36:	cb 01       	movw	r24, r22
    4c38:	8a a3       	lds	r24, 0x5a
    4c3a:	9b a3       	lds	r25, 0x5b
    4c3c:	ac a3       	lds	r26, 0x5c
    4c3e:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4c40:	6a a1       	lds	r22, 0x4a
    4c42:	7b a1       	lds	r23, 0x4b
    4c44:	8c a1       	lds	r24, 0x4c
    4c46:	9d a1       	lds	r25, 0x4d
    4c48:	20 e0       	ldi	r18, 0x00	; 0
    4c4a:	30 e0       	ldi	r19, 0x00	; 0
    4c4c:	4a ef       	ldi	r20, 0xFA	; 250
    4c4e:	55 e4       	ldi	r21, 0x45	; 69
    4c50:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4c54:	dc 01       	movw	r26, r24
    4c56:	cb 01       	movw	r24, r22
    4c58:	8e a3       	lds	r24, 0x5e
    4c5a:	9f a3       	lds	r25, 0x5f
    4c5c:	a8 a7       	lds	r26, 0x78
    4c5e:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    4c60:	11 e0       	ldi	r17, 0x01	; 1
    4c62:	6e a1       	lds	r22, 0x4e
    4c64:	7f a1       	lds	r23, 0x4f
    4c66:	88 a5       	lds	r24, 0x68
    4c68:	99 a5       	lds	r25, 0x69
    4c6a:	20 e0       	ldi	r18, 0x00	; 0
    4c6c:	30 e0       	ldi	r19, 0x00	; 0
    4c6e:	40 e8       	ldi	r20, 0x80	; 128
    4c70:	5f e3       	ldi	r21, 0x3F	; 63
    4c72:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    4c76:	88 23       	and	r24, r24
    4c78:	0c f0       	brlt	.+2      	; 0x4c7c <chb_reset+0x2c6>
    4c7a:	10 e0       	ldi	r17, 0x00	; 0
    4c7c:	11 23       	and	r17, r17
    4c7e:	29 f0       	breq	.+10     	; 0x4c8a <chb_reset+0x2d4>
		__ticks = 1;
    4c80:	81 e0       	ldi	r24, 0x01	; 1
    4c82:	90 e0       	ldi	r25, 0x00	; 0
    4c84:	8a a7       	lds	r24, 0x7a
    4c86:	9b a7       	lds	r25, 0x7b
    4c88:	46 c0       	rjmp	.+140    	; 0x4d16 <chb_reset+0x360>
	else if (__tmp > 65535)
    4c8a:	11 e0       	ldi	r17, 0x01	; 1
    4c8c:	6e a1       	lds	r22, 0x4e
    4c8e:	7f a1       	lds	r23, 0x4f
    4c90:	88 a5       	lds	r24, 0x68
    4c92:	99 a5       	lds	r25, 0x69
    4c94:	20 e0       	ldi	r18, 0x00	; 0
    4c96:	3f ef       	ldi	r19, 0xFF	; 255
    4c98:	4f e7       	ldi	r20, 0x7F	; 127
    4c9a:	57 e4       	ldi	r21, 0x47	; 71
    4c9c:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    4ca0:	18 16       	cp	r1, r24
    4ca2:	0c f0       	brlt	.+2      	; 0x4ca6 <chb_reset+0x2f0>
    4ca4:	10 e0       	ldi	r17, 0x00	; 0
    4ca6:	11 23       	and	r17, r17
    4ca8:	61 f1       	breq	.+88     	; 0x4d02 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4caa:	6a a1       	lds	r22, 0x4a
    4cac:	7b a1       	lds	r23, 0x4b
    4cae:	8c a1       	lds	r24, 0x4c
    4cb0:	9d a1       	lds	r25, 0x4d
    4cb2:	20 e0       	ldi	r18, 0x00	; 0
    4cb4:	30 e0       	ldi	r19, 0x00	; 0
    4cb6:	40 e2       	ldi	r20, 0x20	; 32
    4cb8:	51 e4       	ldi	r21, 0x41	; 65
    4cba:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    4cbe:	dc 01       	movw	r26, r24
    4cc0:	cb 01       	movw	r24, r22
    4cc2:	bc 01       	movw	r22, r24
    4cc4:	cd 01       	movw	r24, r26
    4cc6:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4cca:	dc 01       	movw	r26, r24
    4ccc:	cb 01       	movw	r24, r22
    4cce:	8a a7       	lds	r24, 0x7a
    4cd0:	9b a7       	lds	r25, 0x7b
    4cd2:	12 c0       	rjmp	.+36     	; 0x4cf8 <chb_reset+0x342>
    4cd4:	80 e2       	ldi	r24, 0x20	; 32
    4cd6:	93 e0       	ldi	r25, 0x03	; 3
    4cd8:	8c a7       	lds	r24, 0x7c
    4cda:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4cdc:	8c a5       	lds	r24, 0x6c
    4cde:	9d a5       	lds	r25, 0x6d
    4ce0:	8c 01       	movw	r16, r24
    4ce2:	c8 01       	movw	r24, r16
    4ce4:	01 97       	sbiw	r24, 0x01	; 1
    4ce6:	f1 f7       	brne	.-4      	; 0x4ce4 <chb_reset+0x32e>
    4ce8:	8c 01       	movw	r16, r24
    4cea:	0c a7       	lds	r16, 0x7c
    4cec:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4cee:	8a a5       	lds	r24, 0x6a
    4cf0:	9b a5       	lds	r25, 0x6b
    4cf2:	01 97       	sbiw	r24, 0x01	; 1
    4cf4:	8a a7       	lds	r24, 0x7a
    4cf6:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4cf8:	8a a5       	lds	r24, 0x6a
    4cfa:	9b a5       	lds	r25, 0x6b
    4cfc:	00 97       	sbiw	r24, 0x00	; 0
    4cfe:	51 f7       	brne	.-44     	; 0x4cd4 <chb_reset+0x31e>
    4d00:	28 c0       	rjmp	.+80     	; 0x4d52 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4d02:	6e a1       	lds	r22, 0x4e
    4d04:	7f a1       	lds	r23, 0x4f
    4d06:	88 a5       	lds	r24, 0x68
    4d08:	99 a5       	lds	r25, 0x69
    4d0a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4d0e:	dc 01       	movw	r26, r24
    4d10:	cb 01       	movw	r24, r22
    4d12:	8a a7       	lds	r24, 0x7a
    4d14:	9b a7       	lds	r25, 0x7b
    4d16:	8a a5       	lds	r24, 0x6a
    4d18:	9b a5       	lds	r25, 0x6b
    4d1a:	8e a7       	lds	r24, 0x7e
    4d1c:	9f a7       	lds	r25, 0x7f
    4d1e:	8e a5       	lds	r24, 0x6e
    4d20:	9f a5       	lds	r25, 0x6f
    4d22:	8c 01       	movw	r16, r24
    4d24:	f8 01       	movw	r30, r16
    4d26:	31 97       	sbiw	r30, 0x01	; 1
    4d28:	f1 f7       	brne	.-4      	; 0x4d26 <chb_reset+0x370>
    4d2a:	8f 01       	movw	r16, r30
    4d2c:	0e a7       	lds	r16, 0x7e
    4d2e:	1f a7       	lds	r17, 0x7f
    4d30:	10 c0       	rjmp	.+32     	; 0x4d52 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4d32:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4d34:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4d36:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4d38:	98 a1       	lds	r25, 0x48
    4d3a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    4d3e:	dc 01       	movw	r26, r24
    4d40:	cb 01       	movw	r24, r22
    4d42:	89 a3       	lds	r24, 0x59
    4d44:	89 a1       	lds	r24, 0x49
    4d46:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4d48:	88 a9       	sts	0x48, r24
    4d4a:	18 2f       	mov	r17, r24
    4d4c:	1a 95       	dec	r17
    4d4e:	f1 f7       	brne	.-4      	; 0x4d4c <chb_reset+0x396>
    4d50:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4d52:	84 e6       	ldi	r24, 0x64	; 100
    4d54:	96 e0       	ldi	r25, 0x06	; 6
    4d56:	24 e6       	ldi	r18, 0x64	; 100
    4d58:	36 e0       	ldi	r19, 0x06	; 6
    4d5a:	f9 01       	movw	r30, r18
    4d5c:	20 81       	ld	r18, Z
    4d5e:	21 60       	ori	r18, 0x01	; 1
    4d60:	fc 01       	movw	r30, r24
    4d62:	20 83       	st	Z, r18
    4d64:	01 c0       	rjmp	.+2      	; 0x4d68 <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4d66:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    4d68:	8d e1       	ldi	r24, 0x1D	; 29
    4d6a:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    4d6e:	81 30       	cpi	r24, 0x01	; 1
    4d70:	d1 f7       	brne	.-12     	; 0x4d66 <chb_reset+0x3b0>
    4d72:	8c e1       	ldi	r24, 0x1C	; 28
    4d74:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    4d78:	87 30       	cpi	r24, 0x07	; 7
    4d7a:	a9 f7       	brne	.-22     	; 0x4d66 <chb_reset+0x3b0>
        {
            break;
    4d7c:	00 00       	nop
        }
    }
	

}
    4d7e:	e0 96       	adiw	r28, 0x30	; 48
    4d80:	cd bf       	out	0x3d, r28	; 61
    4d82:	de bf       	out	0x3e, r29	; 62
    4d84:	df 91       	pop	r29
    4d86:	cf 91       	pop	r28
    4d88:	1f 91       	pop	r17
    4d8a:	0f 91       	pop	r16
    4d8c:	08 95       	ret

00004d8e <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    4d8e:	cf 93       	push	r28
    4d90:	df 93       	push	r29
    4d92:	0f 92       	push	r0
    4d94:	0f 92       	push	r0
    4d96:	cd b7       	in	r28, 0x3d	; 61
    4d98:	de b7       	in	r29, 0x3e	; 62
    4d9a:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    4d9c:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    4d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    4da0:	80 68       	ori	r24, 0x80	; 128
    4da2:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4da4:	8f e3       	ldi	r24, 0x3F	; 63
    4da6:	90 e0       	ldi	r25, 0x00	; 0
    4da8:	fc 01       	movw	r30, r24
    4daa:	80 81       	ld	r24, Z
    4dac:	80 93 4e 40 	sts	0x404E, r24
    4db0:	f8 94       	cli
    RadioCS(TRUE);
    4db2:	81 e0       	ldi	r24, 0x01	; 1
    4db4:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4db8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dba:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    4dbe:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4dc0:	89 81       	ldd	r24, Y+1	; 0x01
    4dc2:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    4dc6:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4dc8:	80 e0       	ldi	r24, 0x00	; 0
    4dca:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>
    CHB_LEAVE_CRIT();
    4dce:	8f e3       	ldi	r24, 0x3F	; 63
    4dd0:	90 e0       	ldi	r25, 0x00	; 0
    4dd2:	20 91 4e 40 	lds	r18, 0x404E
    4dd6:	fc 01       	movw	r30, r24
    4dd8:	20 83       	st	Z, r18
    4dda:	78 94       	sei

    return val;
    4ddc:	89 81       	ldd	r24, Y+1	; 0x01
}
    4dde:	0f 90       	pop	r0
    4de0:	0f 90       	pop	r0
    4de2:	df 91       	pop	r29
    4de4:	cf 91       	pop	r28
    4de6:	08 95       	ret

00004de8 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4de8:	cf 93       	push	r28
    4dea:	df 93       	push	r29
    4dec:	00 d0       	rcall	.+0      	; 0x4dee <chb_reg_read16+0x6>
    4dee:	0f 92       	push	r0
    4df0:	cd b7       	in	r28, 0x3d	; 61
    4df2:	de b7       	in	r29, 0x3e	; 62
    4df4:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4df6:	1a 82       	std	Y+2, r1	; 0x02
    4df8:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    4dfa:	19 82       	std	Y+1, r1	; 0x01
    4dfc:	1d c0       	rjmp	.+58     	; 0x4e38 <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    4e00:	89 81       	ldd	r24, Y+1	; 0x01
    4e02:	89 0f       	add	r24, r25
    4e04:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    4e08:	88 2f       	mov	r24, r24
    4e0a:	90 e0       	ldi	r25, 0x00	; 0
    4e0c:	29 81       	ldd	r18, Y+1	; 0x01
    4e0e:	22 2f       	mov	r18, r18
    4e10:	30 e0       	ldi	r19, 0x00	; 0
    4e12:	22 0f       	add	r18, r18
    4e14:	33 1f       	adc	r19, r19
    4e16:	22 0f       	add	r18, r18
    4e18:	33 1f       	adc	r19, r19
    4e1a:	22 0f       	add	r18, r18
    4e1c:	33 1f       	adc	r19, r19
    4e1e:	02 2e       	mov	r0, r18
    4e20:	02 c0       	rjmp	.+4      	; 0x4e26 <chb_reg_read16+0x3e>
    4e22:	88 0f       	add	r24, r24
    4e24:	99 1f       	adc	r25, r25
    4e26:	0a 94       	dec	r0
    4e28:	e2 f7       	brpl	.-8      	; 0x4e22 <chb_reg_read16+0x3a>
    4e2a:	98 2f       	mov	r25, r24
    4e2c:	8c 81       	ldd	r24, Y+4	; 0x04
    4e2e:	89 2b       	or	r24, r25
    4e30:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4e32:	89 81       	ldd	r24, Y+1	; 0x01
    4e34:	8f 5f       	subi	r24, 0xFF	; 255
    4e36:	89 83       	std	Y+1, r24	; 0x01
    4e38:	89 81       	ldd	r24, Y+1	; 0x01
    4e3a:	82 30       	cpi	r24, 0x02	; 2
    4e3c:	00 f3       	brcs	.-64     	; 0x4dfe <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    4e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e40:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4e42:	24 96       	adiw	r28, 0x04	; 4
    4e44:	cd bf       	out	0x3d, r28	; 61
    4e46:	de bf       	out	0x3e, r29	; 62
    4e48:	df 91       	pop	r29
    4e4a:	cf 91       	pop	r28
    4e4c:	08 95       	ret

00004e4e <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    4e4e:	cf 93       	push	r28
    4e50:	df 93       	push	r29
    4e52:	0f 92       	push	r0
    4e54:	0f 92       	push	r0
    4e56:	cd b7       	in	r28, 0x3d	; 61
    4e58:	de b7       	in	r29, 0x3e	; 62
    4e5a:	89 83       	std	Y+1, r24	; 0x01
    4e5c:	6a 83       	std	Y+2, r22	; 0x02
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    4e5e:	89 81       	ldd	r24, Y+1	; 0x01
    4e60:	80 6c       	ori	r24, 0xC0	; 192
    4e62:	89 83       	std	Y+1, r24	; 0x01

    CHB_ENTER_CRIT();
    4e64:	8f e3       	ldi	r24, 0x3F	; 63
    4e66:	90 e0       	ldi	r25, 0x00	; 0
    4e68:	fc 01       	movw	r30, r24
    4e6a:	80 81       	ld	r24, Z
    4e6c:	80 93 4e 40 	sts	0x404E, r24
    4e70:	f8 94       	cli
    RadioCS(TRUE);
    4e72:	81 e0       	ldi	r24, 0x01	; 1
    4e74:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    4e78:	89 81       	ldd	r24, Y+1	; 0x01
    4e7a:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    4e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e80:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>

    RadioCS(FALSE);
    4e84:	80 e0       	ldi	r24, 0x00	; 0
    4e86:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>
    CHB_LEAVE_CRIT();
    4e8a:	8f e3       	ldi	r24, 0x3F	; 63
    4e8c:	90 e0       	ldi	r25, 0x00	; 0
    4e8e:	20 91 4e 40 	lds	r18, 0x404E
    4e92:	fc 01       	movw	r30, r24
    4e94:	20 83       	st	Z, r18
    4e96:	78 94       	sei
}
    4e98:	0f 90       	pop	r0
    4e9a:	0f 90       	pop	r0
    4e9c:	df 91       	pop	r29
    4e9e:	cf 91       	pop	r28
    4ea0:	08 95       	ret

00004ea2 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4ea2:	cf 93       	push	r28
    4ea4:	df 93       	push	r29
    4ea6:	00 d0       	rcall	.+0      	; 0x4ea8 <chb_reg_write16+0x6>
    4ea8:	0f 92       	push	r0
    4eaa:	cd b7       	in	r28, 0x3d	; 61
    4eac:	de b7       	in	r29, 0x3e	; 62
    4eae:	8a 83       	std	Y+2, r24	; 0x02
    4eb0:	6b 83       	std	Y+3, r22	; 0x03
    4eb2:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4eb4:	19 82       	std	Y+1, r1	; 0x01
    4eb6:	1d c0       	rjmp	.+58     	; 0x4ef2 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4eb8:	9a 81       	ldd	r25, Y+2	; 0x02
    4eba:	89 81       	ldd	r24, Y+1	; 0x01
    4ebc:	49 2f       	mov	r20, r25
    4ebe:	48 0f       	add	r20, r24
    4ec0:	89 81       	ldd	r24, Y+1	; 0x01
    4ec2:	88 2f       	mov	r24, r24
    4ec4:	90 e0       	ldi	r25, 0x00	; 0
    4ec6:	9c 01       	movw	r18, r24
    4ec8:	22 0f       	add	r18, r18
    4eca:	33 1f       	adc	r19, r19
    4ecc:	22 0f       	add	r18, r18
    4ece:	33 1f       	adc	r19, r19
    4ed0:	22 0f       	add	r18, r18
    4ed2:	33 1f       	adc	r19, r19
    4ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    4ed6:	9c 81       	ldd	r25, Y+4	; 0x04
    4ed8:	02 c0       	rjmp	.+4      	; 0x4ede <chb_reg_write16+0x3c>
    4eda:	96 95       	lsr	r25
    4edc:	87 95       	ror	r24
    4ede:	2a 95       	dec	r18
    4ee0:	e2 f7       	brpl	.-8      	; 0x4eda <chb_reg_write16+0x38>
    4ee2:	98 2f       	mov	r25, r24
    4ee4:	84 2f       	mov	r24, r20
    4ee6:	69 2f       	mov	r22, r25
    4ee8:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4eec:	89 81       	ldd	r24, Y+1	; 0x01
    4eee:	8f 5f       	subi	r24, 0xFF	; 255
    4ef0:	89 83       	std	Y+1, r24	; 0x01
    4ef2:	89 81       	ldd	r24, Y+1	; 0x01
    4ef4:	82 30       	cpi	r24, 0x02	; 2
    4ef6:	00 f3       	brcs	.-64     	; 0x4eb8 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4ef8:	24 96       	adiw	r28, 0x04	; 4
    4efa:	cd bf       	out	0x3d, r28	; 61
    4efc:	de bf       	out	0x3e, r29	; 62
    4efe:	df 91       	pop	r29
    4f00:	cf 91       	pop	r28
    4f02:	08 95       	ret

00004f04 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4f04:	cf 93       	push	r28
    4f06:	df 93       	push	r29
    4f08:	00 d0       	rcall	.+0      	; 0x4f0a <chb_reg_write64+0x6>
    4f0a:	0f 92       	push	r0
    4f0c:	cd b7       	in	r28, 0x3d	; 61
    4f0e:	de b7       	in	r29, 0x3e	; 62
    4f10:	8a 83       	std	Y+2, r24	; 0x02
    4f12:	6b 83       	std	Y+3, r22	; 0x03
    4f14:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4f16:	19 82       	std	Y+1, r1	; 0x01
    4f18:	14 c0       	rjmp	.+40     	; 0x4f42 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4f1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f1c:	89 81       	ldd	r24, Y+1	; 0x01
    4f1e:	49 2f       	mov	r20, r25
    4f20:	48 0f       	add	r20, r24
    4f22:	89 81       	ldd	r24, Y+1	; 0x01
    4f24:	88 2f       	mov	r24, r24
    4f26:	90 e0       	ldi	r25, 0x00	; 0
    4f28:	2b 81       	ldd	r18, Y+3	; 0x03
    4f2a:	3c 81       	ldd	r19, Y+4	; 0x04
    4f2c:	82 0f       	add	r24, r18
    4f2e:	93 1f       	adc	r25, r19
    4f30:	fc 01       	movw	r30, r24
    4f32:	90 81       	ld	r25, Z
    4f34:	84 2f       	mov	r24, r20
    4f36:	69 2f       	mov	r22, r25
    4f38:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4f3c:	89 81       	ldd	r24, Y+1	; 0x01
    4f3e:	8f 5f       	subi	r24, 0xFF	; 255
    4f40:	89 83       	std	Y+1, r24	; 0x01
    4f42:	89 81       	ldd	r24, Y+1	; 0x01
    4f44:	88 30       	cpi	r24, 0x08	; 8
    4f46:	48 f3       	brcs	.-46     	; 0x4f1a <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    4f48:	24 96       	adiw	r28, 0x04	; 4
    4f4a:	cd bf       	out	0x3d, r28	; 61
    4f4c:	de bf       	out	0x3e, r29	; 62
    4f4e:	df 91       	pop	r29
    4f50:	cf 91       	pop	r28
    4f52:	08 95       	ret

00004f54 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    4f54:	cf 93       	push	r28
    4f56:	df 93       	push	r29
    4f58:	00 d0       	rcall	.+0      	; 0x4f5a <chb_reg_read_mod_write+0x6>
    4f5a:	0f 92       	push	r0
    4f5c:	cd b7       	in	r28, 0x3d	; 61
    4f5e:	de b7       	in	r29, 0x3e	; 62
    4f60:	8a 83       	std	Y+2, r24	; 0x02
    4f62:	6b 83       	std	Y+3, r22	; 0x03
    4f64:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    4f66:	8a 81       	ldd	r24, Y+2	; 0x02
    4f68:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    4f6c:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4f6e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f70:	8c 81       	ldd	r24, Y+4	; 0x04
    4f72:	89 23       	and	r24, r25
    4f74:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4f76:	8c 81       	ldd	r24, Y+4	; 0x04
    4f78:	98 2f       	mov	r25, r24
    4f7a:	90 95       	com	r25
    4f7c:	89 81       	ldd	r24, Y+1	; 0x01
    4f7e:	89 23       	and	r24, r25
    4f80:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4f82:	99 81       	ldd	r25, Y+1	; 0x01
    4f84:	8b 81       	ldd	r24, Y+3	; 0x03
    4f86:	89 2b       	or	r24, r25
    4f88:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4f8a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f8c:	69 81       	ldd	r22, Y+1	; 0x01
    4f8e:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <chb_reg_write>
}
    4f92:	24 96       	adiw	r28, 0x04	; 4
    4f94:	cd bf       	out	0x3d, r28	; 61
    4f96:	de bf       	out	0x3e, r29	; 62
    4f98:	df 91       	pop	r29
    4f9a:	cf 91       	pop	r28
    4f9c:	08 95       	ret

00004f9e <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4f9e:	cf 93       	push	r28
    4fa0:	df 93       	push	r29
    4fa2:	cd b7       	in	r28, 0x3d	; 61
    4fa4:	de b7       	in	r29, 0x3e	; 62
    4fa6:	27 97       	sbiw	r28, 0x07	; 7
    4fa8:	cd bf       	out	0x3d, r28	; 61
    4faa:	de bf       	out	0x3e, r29	; 62
    4fac:	8a 83       	std	Y+2, r24	; 0x02
    4fae:	9b 83       	std	Y+3, r25	; 0x03
    4fb0:	6c 83       	std	Y+4, r22	; 0x04
    4fb2:	4d 83       	std	Y+5, r20	; 0x05
    4fb4:	5e 83       	std	Y+6, r21	; 0x06
    4fb6:	2f 83       	std	Y+7, r18	; 0x07
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4fb8:	8c 81       	ldd	r24, Y+4	; 0x04
    4fba:	28 2f       	mov	r18, r24
    4fbc:	30 e0       	ldi	r19, 0x00	; 0
    4fbe:	8f 81       	ldd	r24, Y+7	; 0x07
    4fc0:	88 2f       	mov	r24, r24
    4fc2:	90 e0       	ldi	r25, 0x00	; 0
    4fc4:	82 0f       	add	r24, r18
    4fc6:	93 1f       	adc	r25, r19
    4fc8:	80 38       	cpi	r24, 0x80	; 128
    4fca:	91 05       	cpc	r25, r1
    4fcc:	0c f0       	brlt	.+2      	; 0x4fd0 <chb_frame_write+0x32>
    4fce:	42 c0       	rjmp	.+132    	; 0x5054 <chb_frame_write+0xb6>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4fd0:	8f e3       	ldi	r24, 0x3F	; 63
    4fd2:	90 e0       	ldi	r25, 0x00	; 0
    4fd4:	fc 01       	movw	r30, r24
    4fd6:	80 81       	ld	r24, Z
    4fd8:	80 93 4e 40 	sts	0x404E, r24
    4fdc:	f8 94       	cli
    RadioCS(TRUE); 
    4fde:	81 e0       	ldi	r24, 0x01	; 1
    4fe0:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    4fe4:	80 e6       	ldi	r24, 0x60	; 96
    4fe6:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4fea:	19 82       	std	Y+1, r1	; 0x01
    4fec:	0f c0       	rjmp	.+30     	; 0x500c <chb_frame_write+0x6e>
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    4fee:	8a 81       	ldd	r24, Y+2	; 0x02
    4ff0:	9b 81       	ldd	r25, Y+3	; 0x03
    4ff2:	fc 01       	movw	r30, r24
    4ff4:	20 81       	ld	r18, Z
    4ff6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ff8:	9b 81       	ldd	r25, Y+3	; 0x03
    4ffa:	01 96       	adiw	r24, 0x01	; 1
    4ffc:	8a 83       	std	Y+2, r24	; 0x02
    4ffe:	9b 83       	std	Y+3, r25	; 0x03
    5000:	82 2f       	mov	r24, r18
    5002:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    5006:	89 81       	ldd	r24, Y+1	; 0x01
    5008:	8f 5f       	subi	r24, 0xFF	; 255
    500a:	89 83       	std	Y+1, r24	; 0x01
    500c:	99 81       	ldd	r25, Y+1	; 0x01
    500e:	8c 81       	ldd	r24, Y+4	; 0x04
    5010:	98 17       	cp	r25, r24
    5012:	68 f3       	brcs	.-38     	; 0x4fee <chb_frame_write+0x50>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    5014:	19 82       	std	Y+1, r1	; 0x01
    5016:	0f c0       	rjmp	.+30     	; 0x5036 <chb_frame_write+0x98>
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    5018:	8d 81       	ldd	r24, Y+5	; 0x05
    501a:	9e 81       	ldd	r25, Y+6	; 0x06
    501c:	fc 01       	movw	r30, r24
    501e:	20 81       	ld	r18, Z
    5020:	8d 81       	ldd	r24, Y+5	; 0x05
    5022:	9e 81       	ldd	r25, Y+6	; 0x06
    5024:	01 96       	adiw	r24, 0x01	; 1
    5026:	8d 83       	std	Y+5, r24	; 0x05
    5028:	9e 83       	std	Y+6, r25	; 0x06
    502a:	82 2f       	mov	r24, r18
    502c:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    5030:	89 81       	ldd	r24, Y+1	; 0x01
    5032:	8f 5f       	subi	r24, 0xFF	; 255
    5034:	89 83       	std	Y+1, r24	; 0x01
    5036:	99 81       	ldd	r25, Y+1	; 0x01
    5038:	8f 81       	ldd	r24, Y+7	; 0x07
    503a:	98 17       	cp	r25, r24
    503c:	68 f3       	brcs	.-38     	; 0x5018 <chb_frame_write+0x7a>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    503e:	80 e0       	ldi	r24, 0x00	; 0
    5040:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>
    CHB_LEAVE_CRIT();
    5044:	8f e3       	ldi	r24, 0x3F	; 63
    5046:	90 e0       	ldi	r25, 0x00	; 0
    5048:	20 91 4e 40 	lds	r18, 0x404E
    504c:	fc 01       	movw	r30, r24
    504e:	20 83       	st	Z, r18
    5050:	78 94       	sei
    5052:	01 c0       	rjmp	.+2      	; 0x5056 <chb_frame_write+0xb8>
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    5054:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    5056:	27 96       	adiw	r28, 0x07	; 7
    5058:	cd bf       	out	0x3d, r28	; 61
    505a:	de bf       	out	0x3e, r29	; 62
    505c:	df 91       	pop	r29
    505e:	cf 91       	pop	r28
    5060:	08 95       	ret

00005062 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    5062:	0f 93       	push	r16
    5064:	1f 93       	push	r17
    5066:	cf 93       	push	r28
    5068:	df 93       	push	r29
    506a:	cd b7       	in	r28, 0x3d	; 61
    506c:	de b7       	in	r29, 0x3e	; 62
    506e:	e7 97       	sbiw	r28, 0x37	; 55
    5070:	cd bf       	out	0x3d, r28	; 61
    5072:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    5074:	8f e3       	ldi	r24, 0x3F	; 63
    5076:	90 e0       	ldi	r25, 0x00	; 0
    5078:	fc 01       	movw	r30, r24
    507a:	80 81       	ld	r24, Z
    507c:	80 93 4e 40 	sts	0x404E, r24
    5080:	f8 94       	cli
    RadioCS(TRUE);
    5082:	81 e0       	ldi	r24, 0x01	; 1
    5084:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    5088:	80 e2       	ldi	r24, 0x20	; 32
    508a:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    len = SPID_write(0);
    508e:	80 e0       	ldi	r24, 0x00	; 0
    5090:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    5094:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    5096:	8a 81       	ldd	r24, Y+2	; 0x02
    5098:	83 30       	cpi	r24, 0x03	; 3
    509a:	08 f4       	brcc	.+2      	; 0x509e <chb_frame_read+0x3c>
    509c:	5c c0       	rjmp	.+184    	; 0x5156 <chb_frame_read+0xf4>
    509e:	8a 81       	ldd	r24, Y+2	; 0x02
    50a0:	88 23       	and	r24, r24
    50a2:	0c f4       	brge	.+2      	; 0x50a6 <chb_frame_read+0x44>
    50a4:	58 c0       	rjmp	.+176    	; 0x5156 <chb_frame_read+0xf4>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    50a6:	8a 81       	ldd	r24, Y+2	; 0x02
    50a8:	08 2f       	mov	r16, r24
    50aa:	10 e0       	ldi	r17, 0x00	; 0
    50ac:	0e 94 ba 24 	call	0x4974	; 0x4974 <chb_buf_get_len>
    50b0:	88 2f       	mov	r24, r24
    50b2:	90 e0       	ldi	r25, 0x00	; 0
    50b4:	20 e8       	ldi	r18, 0x80	; 128
    50b6:	30 e0       	ldi	r19, 0x00	; 0
    50b8:	a9 01       	movw	r20, r18
    50ba:	48 1b       	sub	r20, r24
    50bc:	59 0b       	sbc	r21, r25
    50be:	ca 01       	movw	r24, r20
    50c0:	08 17       	cp	r16, r24
    50c2:	19 07       	cpc	r17, r25
    50c4:	a4 f4       	brge	.+40     	; 0x50ee <chb_frame_read+0x8c>
        {
            chb_buf_write(len);
    50c6:	8a 81       	ldd	r24, Y+2	; 0x02
    50c8:	0e 94 72 24 	call	0x48e4	; 0x48e4 <chb_buf_write>
            
            for (i=0; i<len; i++)
    50cc:	19 82       	std	Y+1, r1	; 0x01
    50ce:	0a c0       	rjmp	.+20     	; 0x50e4 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    50d0:	80 e0       	ldi	r24, 0x00	; 0
    50d2:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    50d6:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    50d8:	8b 81       	ldd	r24, Y+3	; 0x03
    50da:	0e 94 72 24 	call	0x48e4	; 0x48e4 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    50de:	89 81       	ldd	r24, Y+1	; 0x01
    50e0:	8f 5f       	subi	r24, 0xFF	; 255
    50e2:	89 83       	std	Y+1, r24	; 0x01
    50e4:	99 81       	ldd	r25, Y+1	; 0x01
    50e6:	8a 81       	ldd	r24, Y+2	; 0x02
    50e8:	98 17       	cp	r25, r24
    50ea:	90 f3       	brcs	.-28     	; 0x50d0 <chb_frame_read+0x6e>
    50ec:	34 c0       	rjmp	.+104    	; 0x5156 <chb_frame_read+0xf4>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    50ee:	0e 94 9e 22 	call	0x453c	; 0x453c <chb_get_pcb>
    50f2:	8c 83       	std	Y+4, r24	; 0x04
    50f4:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    50f6:	19 82       	std	Y+1, r1	; 0x01
    50f8:	07 c0       	rjmp	.+14     	; 0x5108 <chb_frame_read+0xa6>
            {
                data = SPID_write(0);
    50fa:	80 e0       	ldi	r24, 0x00	; 0
    50fc:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    5100:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    5102:	89 81       	ldd	r24, Y+1	; 0x01
    5104:	8f 5f       	subi	r24, 0xFF	; 255
    5106:	89 83       	std	Y+1, r24	; 0x01
    5108:	99 81       	ldd	r25, Y+1	; 0x01
    510a:	8a 81       	ldd	r24, Y+2	; 0x02
    510c:	98 17       	cp	r25, r24
    510e:	a8 f3       	brcs	.-22     	; 0x50fa <chb_frame_read+0x98>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    5110:	8c 81       	ldd	r24, Y+4	; 0x04
    5112:	9d 81       	ldd	r25, Y+5	; 0x05
    5114:	fc 01       	movw	r30, r24
    5116:	85 85       	ldd	r24, Z+13	; 0x0d
    5118:	96 85       	ldd	r25, Z+14	; 0x0e
    511a:	9c 01       	movw	r18, r24
    511c:	2f 5f       	subi	r18, 0xFF	; 255
    511e:	3f 4f       	sbci	r19, 0xFF	; 255
    5120:	8c 81       	ldd	r24, Y+4	; 0x04
    5122:	9d 81       	ldd	r25, Y+5	; 0x05
    5124:	fc 01       	movw	r30, r24
    5126:	25 87       	std	Z+13, r18	; 0x0d
    5128:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    512a:	ce 01       	movw	r24, r28
    512c:	06 96       	adiw	r24, 0x06	; 6
    512e:	28 ee       	ldi	r18, 0xE8	; 232
    5130:	31 e0       	ldi	r19, 0x01	; 1
    5132:	b9 01       	movw	r22, r18
    5134:	0e 94 01 61 	call	0xc202	; 0xc202 <strcpy_P>
            printf(buf);
    5138:	0f 92       	push	r0
    513a:	0f 92       	push	r0
    513c:	8d b7       	in	r24, 0x3d	; 61
    513e:	9e b7       	in	r25, 0x3e	; 62
    5140:	01 96       	adiw	r24, 0x01	; 1
    5142:	9e 01       	movw	r18, r28
    5144:	2a 5f       	subi	r18, 0xFA	; 250
    5146:	3f 4f       	sbci	r19, 0xFF	; 255
    5148:	fc 01       	movw	r30, r24
    514a:	20 83       	st	Z, r18
    514c:	31 83       	std	Z+1, r19	; 0x01
    514e:	0e 94 54 61 	call	0xc2a8	; 0xc2a8 <printf>
    5152:	0f 90       	pop	r0
    5154:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    5156:	80 e0       	ldi	r24, 0x00	; 0
    5158:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>
    CHB_LEAVE_CRIT();
    515c:	8f e3       	ldi	r24, 0x3F	; 63
    515e:	90 e0       	ldi	r25, 0x00	; 0
    5160:	20 91 4e 40 	lds	r18, 0x404E
    5164:	fc 01       	movw	r30, r24
    5166:	20 83       	st	Z, r18
    5168:	78 94       	sei
}
    516a:	e7 96       	adiw	r28, 0x37	; 55
    516c:	cd bf       	out	0x3d, r28	; 61
    516e:	de bf       	out	0x3e, r29	; 62
    5170:	df 91       	pop	r29
    5172:	cf 91       	pop	r28
    5174:	1f 91       	pop	r17
    5176:	0f 91       	pop	r16
    5178:	08 95       	ret

0000517a <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    517a:	cf 93       	push	r28
    517c:	df 93       	push	r29
    517e:	0f 92       	push	r0
    5180:	cd b7       	in	r28, 0x3d	; 61
    5182:	de b7       	in	r29, 0x3e	; 62
    5184:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    5186:	89 81       	ldd	r24, Y+1	; 0x01
    5188:	88 2f       	mov	r24, r24
    518a:	90 e0       	ldi	r25, 0x00	; 0
    518c:	81 30       	cpi	r24, 0x01	; 1
    518e:	91 05       	cpc	r25, r1
    5190:	c1 f0       	breq	.+48     	; 0x51c2 <chb_set_mode+0x48>
    5192:	82 30       	cpi	r24, 0x02	; 2
    5194:	91 05       	cpc	r25, r1
    5196:	1c f4       	brge	.+6      	; 0x519e <chb_set_mode+0x24>
    5198:	00 97       	sbiw	r24, 0x00	; 0
    519a:	41 f0       	breq	.+16     	; 0x51ac <chb_set_mode+0x32>
    519c:	33 c0       	rjmp	.+102    	; 0x5204 <chb_set_mode+0x8a>
    519e:	82 30       	cpi	r24, 0x02	; 2
    51a0:	91 05       	cpc	r25, r1
    51a2:	d1 f0       	breq	.+52     	; 0x51d8 <chb_set_mode+0x5e>
    51a4:	83 30       	cpi	r24, 0x03	; 3
    51a6:	91 05       	cpc	r25, r1
    51a8:	11 f1       	breq	.+68     	; 0x51ee <chb_set_mode+0x74>
    51aa:	2c c0       	rjmp	.+88     	; 0x5204 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    51ac:	8c e0       	ldi	r24, 0x0C	; 12
    51ae:	68 e0       	ldi	r22, 0x08	; 8
    51b0:	4f e3       	ldi	r20, 0x3F	; 63
    51b2:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    51b6:	86 e1       	ldi	r24, 0x16	; 22
    51b8:	62 e0       	ldi	r22, 0x02	; 2
    51ba:	43 e0       	ldi	r20, 0x03	; 3
    51bc:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        break;
    51c0:	21 c0       	rjmp	.+66     	; 0x5204 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    51c2:	8c e0       	ldi	r24, 0x0C	; 12
    51c4:	6c e0       	ldi	r22, 0x0C	; 12
    51c6:	4f e3       	ldi	r20, 0x3F	; 63
    51c8:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    51cc:	86 e1       	ldi	r24, 0x16	; 22
    51ce:	62 e0       	ldi	r22, 0x02	; 2
    51d0:	43 e0       	ldi	r20, 0x03	; 3
    51d2:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        break;
    51d6:	16 c0       	rjmp	.+44     	; 0x5204 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    51d8:	8c e0       	ldi	r24, 0x0C	; 12
    51da:	6c e1       	ldi	r22, 0x1C	; 28
    51dc:	4f e3       	ldi	r20, 0x3F	; 63
    51de:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    51e2:	86 e1       	ldi	r24, 0x16	; 22
    51e4:	62 e0       	ldi	r22, 0x02	; 2
    51e6:	43 e0       	ldi	r20, 0x03	; 3
    51e8:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        break;
    51ec:	0b c0       	rjmp	.+22     	; 0x5204 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    51ee:	8c e0       	ldi	r24, 0x0C	; 12
    51f0:	60 e0       	ldi	r22, 0x00	; 0
    51f2:	4f e3       	ldi	r20, 0x3F	; 63
    51f4:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    51f8:	86 e1       	ldi	r24, 0x16	; 22
    51fa:	63 e0       	ldi	r22, 0x03	; 3
    51fc:	43 e0       	ldi	r20, 0x03	; 3
    51fe:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
        break;
    5202:	00 00       	nop
    }
}
    5204:	0f 90       	pop	r0
    5206:	df 91       	pop	r29
    5208:	cf 91       	pop	r28
    520a:	08 95       	ret

0000520c <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    520c:	0f 93       	push	r16
    520e:	1f 93       	push	r17
    5210:	cf 93       	push	r28
    5212:	df 93       	push	r29
    5214:	cd b7       	in	r28, 0x3d	; 61
    5216:	de b7       	in	r29, 0x3e	; 62
    5218:	6a 97       	sbiw	r28, 0x1a	; 26
    521a:	cd bf       	out	0x3d, r28	; 61
    521c:	de bf       	out	0x3e, r29	; 62
    521e:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    5220:	88 e0       	ldi	r24, 0x08	; 8
    5222:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5224:	4f e1       	ldi	r20, 0x1F	; 31
    5226:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    522a:	0e 94 c3 24 	call	0x4986	; 0x4986 <chb_get_state>
    522e:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    5230:	89 81       	ldd	r24, Y+1	; 0x01
    5232:	86 30       	cpi	r24, 0x06	; 6
    5234:	21 f0       	breq	.+8      	; 0x523e <chb_set_channel+0x32>
    5236:	89 81       	ldd	r24, Y+1	; 0x01
    5238:	89 30       	cpi	r24, 0x09	; 9
    523a:	09 f0       	breq	.+2      	; 0x523e <chb_set_channel+0x32>
    523c:	d5 c0       	rjmp	.+426    	; 0x53e8 <chb_set_channel+0x1dc>
    523e:	80 e0       	ldi	r24, 0x00	; 0
    5240:	90 e0       	ldi	r25, 0x00	; 0
    5242:	ac ed       	ldi	r26, 0xDC	; 220
    5244:	b2 e4       	ldi	r27, 0x42	; 66
    5246:	8a 83       	std	Y+2, r24	; 0x02
    5248:	9b 83       	std	Y+3, r25	; 0x03
    524a:	ac 83       	std	Y+4, r26	; 0x04
    524c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    524e:	6a 81       	ldd	r22, Y+2	; 0x02
    5250:	7b 81       	ldd	r23, Y+3	; 0x03
    5252:	8c 81       	ldd	r24, Y+4	; 0x04
    5254:	9d 81       	ldd	r25, Y+5	; 0x05
    5256:	2b ea       	ldi	r18, 0xAB	; 171
    5258:	3a ea       	ldi	r19, 0xAA	; 170
    525a:	4a e2       	ldi	r20, 0x2A	; 42
    525c:	51 e4       	ldi	r21, 0x41	; 65
    525e:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5262:	dc 01       	movw	r26, r24
    5264:	cb 01       	movw	r24, r22
    5266:	8e 83       	std	Y+6, r24	; 0x06
    5268:	9f 83       	std	Y+7, r25	; 0x07
    526a:	a8 87       	std	Y+8, r26	; 0x08
    526c:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    526e:	11 e0       	ldi	r17, 0x01	; 1
    5270:	6e 81       	ldd	r22, Y+6	; 0x06
    5272:	7f 81       	ldd	r23, Y+7	; 0x07
    5274:	88 85       	ldd	r24, Y+8	; 0x08
    5276:	99 85       	ldd	r25, Y+9	; 0x09
    5278:	20 e0       	ldi	r18, 0x00	; 0
    527a:	30 e0       	ldi	r19, 0x00	; 0
    527c:	40 e8       	ldi	r20, 0x80	; 128
    527e:	5f e3       	ldi	r21, 0x3F	; 63
    5280:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    5284:	88 23       	and	r24, r24
    5286:	0c f0       	brlt	.+2      	; 0x528a <chb_set_channel+0x7e>
    5288:	10 e0       	ldi	r17, 0x00	; 0
    528a:	11 23       	and	r17, r17
    528c:	19 f0       	breq	.+6      	; 0x5294 <chb_set_channel+0x88>
		__ticks = 1;
    528e:	81 e0       	ldi	r24, 0x01	; 1
    5290:	8a 87       	std	Y+10, r24	; 0x0a
    5292:	a3 c0       	rjmp	.+326    	; 0x53da <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    5294:	11 e0       	ldi	r17, 0x01	; 1
    5296:	6e 81       	ldd	r22, Y+6	; 0x06
    5298:	7f 81       	ldd	r23, Y+7	; 0x07
    529a:	88 85       	ldd	r24, Y+8	; 0x08
    529c:	99 85       	ldd	r25, Y+9	; 0x09
    529e:	20 e0       	ldi	r18, 0x00	; 0
    52a0:	30 e0       	ldi	r19, 0x00	; 0
    52a2:	4f e7       	ldi	r20, 0x7F	; 127
    52a4:	53 e4       	ldi	r21, 0x43	; 67
    52a6:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    52aa:	18 16       	cp	r1, r24
    52ac:	0c f0       	brlt	.+2      	; 0x52b0 <chb_set_channel+0xa4>
    52ae:	10 e0       	ldi	r17, 0x00	; 0
    52b0:	11 23       	and	r17, r17
    52b2:	09 f4       	brne	.+2      	; 0x52b6 <chb_set_channel+0xaa>
    52b4:	89 c0       	rjmp	.+274    	; 0x53c8 <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    52b6:	6a 81       	ldd	r22, Y+2	; 0x02
    52b8:	7b 81       	ldd	r23, Y+3	; 0x03
    52ba:	8c 81       	ldd	r24, Y+4	; 0x04
    52bc:	9d 81       	ldd	r25, Y+5	; 0x05
    52be:	20 e0       	ldi	r18, 0x00	; 0
    52c0:	30 e0       	ldi	r19, 0x00	; 0
    52c2:	4a e7       	ldi	r20, 0x7A	; 122
    52c4:	54 e4       	ldi	r21, 0x44	; 68
    52c6:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    52ca:	dc 01       	movw	r26, r24
    52cc:	cb 01       	movw	r24, r22
    52ce:	8b 87       	std	Y+11, r24	; 0x0b
    52d0:	9c 87       	std	Y+12, r25	; 0x0c
    52d2:	ad 87       	std	Y+13, r26	; 0x0d
    52d4:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    52d6:	6b 85       	ldd	r22, Y+11	; 0x0b
    52d8:	7c 85       	ldd	r23, Y+12	; 0x0c
    52da:	8d 85       	ldd	r24, Y+13	; 0x0d
    52dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    52de:	20 e0       	ldi	r18, 0x00	; 0
    52e0:	30 e0       	ldi	r19, 0x00	; 0
    52e2:	4a ef       	ldi	r20, 0xFA	; 250
    52e4:	55 e4       	ldi	r21, 0x45	; 69
    52e6:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    52ea:	dc 01       	movw	r26, r24
    52ec:	cb 01       	movw	r24, r22
    52ee:	8f 87       	std	Y+15, r24	; 0x0f
    52f0:	98 8b       	std	Y+16, r25	; 0x10
    52f2:	a9 8b       	std	Y+17, r26	; 0x11
    52f4:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    52f6:	11 e0       	ldi	r17, 0x01	; 1
    52f8:	6f 85       	ldd	r22, Y+15	; 0x0f
    52fa:	78 89       	ldd	r23, Y+16	; 0x10
    52fc:	89 89       	ldd	r24, Y+17	; 0x11
    52fe:	9a 89       	ldd	r25, Y+18	; 0x12
    5300:	20 e0       	ldi	r18, 0x00	; 0
    5302:	30 e0       	ldi	r19, 0x00	; 0
    5304:	40 e8       	ldi	r20, 0x80	; 128
    5306:	5f e3       	ldi	r21, 0x3F	; 63
    5308:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    530c:	88 23       	and	r24, r24
    530e:	0c f0       	brlt	.+2      	; 0x5312 <chb_set_channel+0x106>
    5310:	10 e0       	ldi	r17, 0x00	; 0
    5312:	11 23       	and	r17, r17
    5314:	29 f0       	breq	.+10     	; 0x5320 <chb_set_channel+0x114>
		__ticks = 1;
    5316:	81 e0       	ldi	r24, 0x01	; 1
    5318:	90 e0       	ldi	r25, 0x00	; 0
    531a:	8b 8b       	std	Y+19, r24	; 0x13
    531c:	9c 8b       	std	Y+20, r25	; 0x14
    531e:	46 c0       	rjmp	.+140    	; 0x53ac <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    5320:	11 e0       	ldi	r17, 0x01	; 1
    5322:	6f 85       	ldd	r22, Y+15	; 0x0f
    5324:	78 89       	ldd	r23, Y+16	; 0x10
    5326:	89 89       	ldd	r24, Y+17	; 0x11
    5328:	9a 89       	ldd	r25, Y+18	; 0x12
    532a:	20 e0       	ldi	r18, 0x00	; 0
    532c:	3f ef       	ldi	r19, 0xFF	; 255
    532e:	4f e7       	ldi	r20, 0x7F	; 127
    5330:	57 e4       	ldi	r21, 0x47	; 71
    5332:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    5336:	18 16       	cp	r1, r24
    5338:	0c f0       	brlt	.+2      	; 0x533c <chb_set_channel+0x130>
    533a:	10 e0       	ldi	r17, 0x00	; 0
    533c:	11 23       	and	r17, r17
    533e:	61 f1       	breq	.+88     	; 0x5398 <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5340:	6b 85       	ldd	r22, Y+11	; 0x0b
    5342:	7c 85       	ldd	r23, Y+12	; 0x0c
    5344:	8d 85       	ldd	r24, Y+13	; 0x0d
    5346:	9e 85       	ldd	r25, Y+14	; 0x0e
    5348:	20 e0       	ldi	r18, 0x00	; 0
    534a:	30 e0       	ldi	r19, 0x00	; 0
    534c:	40 e2       	ldi	r20, 0x20	; 32
    534e:	51 e4       	ldi	r21, 0x41	; 65
    5350:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5354:	dc 01       	movw	r26, r24
    5356:	cb 01       	movw	r24, r22
    5358:	bc 01       	movw	r22, r24
    535a:	cd 01       	movw	r24, r26
    535c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5360:	dc 01       	movw	r26, r24
    5362:	cb 01       	movw	r24, r22
    5364:	8b 8b       	std	Y+19, r24	; 0x13
    5366:	9c 8b       	std	Y+20, r25	; 0x14
    5368:	12 c0       	rjmp	.+36     	; 0x538e <chb_set_channel+0x182>
    536a:	80 e2       	ldi	r24, 0x20	; 32
    536c:	93 e0       	ldi	r25, 0x03	; 3
    536e:	8d 8b       	std	Y+21, r24	; 0x15
    5370:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5372:	8d 89       	ldd	r24, Y+21	; 0x15
    5374:	9e 89       	ldd	r25, Y+22	; 0x16
    5376:	8c 01       	movw	r16, r24
    5378:	c8 01       	movw	r24, r16
    537a:	01 97       	sbiw	r24, 0x01	; 1
    537c:	f1 f7       	brne	.-4      	; 0x537a <chb_set_channel+0x16e>
    537e:	8c 01       	movw	r16, r24
    5380:	0d 8b       	std	Y+21, r16	; 0x15
    5382:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5384:	8b 89       	ldd	r24, Y+19	; 0x13
    5386:	9c 89       	ldd	r25, Y+20	; 0x14
    5388:	01 97       	sbiw	r24, 0x01	; 1
    538a:	8b 8b       	std	Y+19, r24	; 0x13
    538c:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    538e:	8b 89       	ldd	r24, Y+19	; 0x13
    5390:	9c 89       	ldd	r25, Y+20	; 0x14
    5392:	00 97       	sbiw	r24, 0x00	; 0
    5394:	51 f7       	brne	.-44     	; 0x536a <chb_set_channel+0x15e>
    5396:	28 c0       	rjmp	.+80     	; 0x53e8 <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5398:	6f 85       	ldd	r22, Y+15	; 0x0f
    539a:	78 89       	ldd	r23, Y+16	; 0x10
    539c:	89 89       	ldd	r24, Y+17	; 0x11
    539e:	9a 89       	ldd	r25, Y+18	; 0x12
    53a0:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    53a4:	dc 01       	movw	r26, r24
    53a6:	cb 01       	movw	r24, r22
    53a8:	8b 8b       	std	Y+19, r24	; 0x13
    53aa:	9c 8b       	std	Y+20, r25	; 0x14
    53ac:	8b 89       	ldd	r24, Y+19	; 0x13
    53ae:	9c 89       	ldd	r25, Y+20	; 0x14
    53b0:	8f 8b       	std	Y+23, r24	; 0x17
    53b2:	98 8f       	std	Y+24, r25	; 0x18
    53b4:	8f 89       	ldd	r24, Y+23	; 0x17
    53b6:	98 8d       	ldd	r25, Y+24	; 0x18
    53b8:	8c 01       	movw	r16, r24
    53ba:	c8 01       	movw	r24, r16
    53bc:	01 97       	sbiw	r24, 0x01	; 1
    53be:	f1 f7       	brne	.-4      	; 0x53bc <chb_set_channel+0x1b0>
    53c0:	8c 01       	movw	r16, r24
    53c2:	0f 8b       	std	Y+23, r16	; 0x17
    53c4:	18 8f       	std	Y+24, r17	; 0x18
    53c6:	10 c0       	rjmp	.+32     	; 0x53e8 <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    53c8:	6e 81       	ldd	r22, Y+6	; 0x06
    53ca:	7f 81       	ldd	r23, Y+7	; 0x07
    53cc:	88 85       	ldd	r24, Y+8	; 0x08
    53ce:	99 85       	ldd	r25, Y+9	; 0x09
    53d0:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    53d4:	dc 01       	movw	r26, r24
    53d6:	cb 01       	movw	r24, r22
    53d8:	8a 87       	std	Y+10, r24	; 0x0a
    53da:	8a 85       	ldd	r24, Y+10	; 0x0a
    53dc:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    53de:	89 8d       	ldd	r24, Y+25	; 0x19
    53e0:	18 2f       	mov	r17, r24
    53e2:	1a 95       	dec	r17
    53e4:	f1 f7       	brne	.-4      	; 0x53e2 <chb_set_channel+0x1d6>
    53e6:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    53e8:	88 e0       	ldi	r24, 0x08	; 8
    53ea:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    53ee:	88 2f       	mov	r24, r24
    53f0:	90 e0       	ldi	r25, 0x00	; 0
    53f2:	9c 01       	movw	r18, r24
    53f4:	2f 71       	andi	r18, 0x1F	; 31
    53f6:	30 70       	andi	r19, 0x00	; 0
    53f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    53fa:	88 2f       	mov	r24, r24
    53fc:	90 e0       	ldi	r25, 0x00	; 0
    53fe:	28 17       	cp	r18, r24
    5400:	39 07       	cpc	r19, r25
    5402:	11 f4       	brne	.+4      	; 0x5408 <chb_set_channel+0x1fc>
    5404:	80 e4       	ldi	r24, 0x40	; 64
    5406:	01 c0       	rjmp	.+2      	; 0x540a <chb_set_channel+0x1fe>
    5408:	83 e4       	ldi	r24, 0x43	; 67
}
    540a:	6a 96       	adiw	r28, 0x1a	; 26
    540c:	cd bf       	out	0x3d, r28	; 61
    540e:	de bf       	out	0x3e, r29	; 62
    5410:	df 91       	pop	r29
    5412:	cf 91       	pop	r28
    5414:	1f 91       	pop	r17
    5416:	0f 91       	pop	r16
    5418:	08 95       	ret

0000541a <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    541a:	cf 93       	push	r28
    541c:	df 93       	push	r29
    541e:	0f 92       	push	r0
    5420:	cd b7       	in	r28, 0x3d	; 61
    5422:	de b7       	in	r29, 0x3e	; 62
    5424:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    5426:	85 e0       	ldi	r24, 0x05	; 5
    5428:	69 81       	ldd	r22, Y+1	; 0x01
    542a:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <chb_reg_write>
}
    542e:	0f 90       	pop	r0
    5430:	df 91       	pop	r29
    5432:	cf 91       	pop	r28
    5434:	08 95       	ret

00005436 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    5436:	0f 93       	push	r16
    5438:	1f 93       	push	r17
    543a:	cf 93       	push	r28
    543c:	df 93       	push	r29
    543e:	cd b7       	in	r28, 0x3d	; 61
    5440:	de b7       	in	r29, 0x3e	; 62
    5442:	c2 56       	subi	r28, 0x62	; 98
    5444:	d0 40       	sbci	r29, 0x00	; 0
    5446:	cd bf       	out	0x3d, r28	; 61
    5448:	de bf       	out	0x3e, r29	; 62
    544a:	9e 01       	movw	r18, r28
    544c:	2e 59       	subi	r18, 0x9E	; 158
    544e:	3f 4f       	sbci	r19, 0xFF	; 255
    5450:	f9 01       	movw	r30, r18
    5452:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    5454:	84 e6       	ldi	r24, 0x64	; 100
    5456:	96 e0       	ldi	r25, 0x06	; 6
    5458:	fc 01       	movw	r30, r24
    545a:	80 81       	ld	r24, Z
    545c:	88 2f       	mov	r24, r24
    545e:	90 e0       	ldi	r25, 0x00	; 0
    5460:	82 70       	andi	r24, 0x02	; 2
    5462:	90 70       	andi	r25, 0x00	; 0
    5464:	00 97       	sbiw	r24, 0x00	; 0
    5466:	11 f0       	breq	.+4      	; 0x546c <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    5468:	84 e4       	ldi	r24, 0x44	; 68
    546a:	91 c4       	rjmp	.+2338   	; 0x5d8e <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    546c:	0e 94 c3 24 	call	0x4986	; 0x4986 <chb_get_state>
    5470:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    5472:	89 81       	ldd	r24, Y+1	; 0x01
    5474:	82 31       	cpi	r24, 0x12	; 18
    5476:	49 f0       	breq	.+18     	; 0x548a <chb_set_state+0x54>
    5478:	89 81       	ldd	r24, Y+1	; 0x01
    547a:	81 31       	cpi	r24, 0x11	; 17
    547c:	31 f0       	breq	.+12     	; 0x548a <chb_set_state+0x54>
    547e:	89 81       	ldd	r24, Y+1	; 0x01
    5480:	81 30       	cpi	r24, 0x01	; 1
    5482:	19 f0       	breq	.+6      	; 0x548a <chb_set_state+0x54>
    5484:	89 81       	ldd	r24, Y+1	; 0x01
    5486:	82 30       	cpi	r24, 0x02	; 2
    5488:	39 f4       	brne	.+14     	; 0x5498 <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    548a:	00 00       	nop
    548c:	0e 94 c3 24 	call	0x4986	; 0x4986 <chb_get_state>
    5490:	98 2f       	mov	r25, r24
    5492:	89 81       	ldd	r24, Y+1	; 0x01
    5494:	98 17       	cp	r25, r24
    5496:	d1 f3       	breq	.-12     	; 0x548c <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    5498:	ce 01       	movw	r24, r28
    549a:	8e 59       	subi	r24, 0x9E	; 158
    549c:	9f 4f       	sbci	r25, 0xFF	; 255
    549e:	fc 01       	movw	r30, r24
    54a0:	80 81       	ld	r24, Z
    54a2:	88 2f       	mov	r24, r24
    54a4:	90 e0       	ldi	r25, 0x00	; 0
    54a6:	86 31       	cpi	r24, 0x16	; 22
    54a8:	91 05       	cpc	r25, r1
    54aa:	09 f4       	brne	.+2      	; 0x54ae <chb_set_state+0x78>
    54ac:	cd c1       	rjmp	.+922    	; 0x5848 <chb_set_state+0x412>
    54ae:	89 31       	cpi	r24, 0x19	; 25
    54b0:	91 05       	cpc	r25, r1
    54b2:	09 f4       	brne	.+2      	; 0x54b6 <chb_set_state+0x80>
    54b4:	e9 c0       	rjmp	.+466    	; 0x5688 <chb_set_state+0x252>
    54b6:	88 30       	cpi	r24, 0x08	; 8
    54b8:	91 05       	cpc	r25, r1
    54ba:	09 f0       	breq	.+2      	; 0x54be <chb_set_state+0x88>
    54bc:	f7 c2       	rjmp	.+1518   	; 0x5aac <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    54be:	84 e6       	ldi	r24, 0x64	; 100
    54c0:	96 e0       	ldi	r25, 0x06	; 6
    54c2:	24 e6       	ldi	r18, 0x64	; 100
    54c4:	36 e0       	ldi	r19, 0x06	; 6
    54c6:	f9 01       	movw	r30, r18
    54c8:	20 81       	ld	r18, Z
    54ca:	2d 7f       	andi	r18, 0xFD	; 253
    54cc:	fc 01       	movw	r30, r24
    54ce:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    54d0:	82 e0       	ldi	r24, 0x02	; 2
    54d2:	63 e0       	ldi	r22, 0x03	; 3
    54d4:	4f e1       	ldi	r20, 0x1F	; 31
    54d6:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
    54da:	80 e0       	ldi	r24, 0x00	; 0
    54dc:	90 e0       	ldi	r25, 0x00	; 0
    54de:	a0 e8       	ldi	r26, 0x80	; 128
    54e0:	bf e3       	ldi	r27, 0x3F	; 63
    54e2:	8a 83       	std	Y+2, r24	; 0x02
    54e4:	9b 83       	std	Y+3, r25	; 0x03
    54e6:	ac 83       	std	Y+4, r26	; 0x04
    54e8:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    54ea:	6a 81       	ldd	r22, Y+2	; 0x02
    54ec:	7b 81       	ldd	r23, Y+3	; 0x03
    54ee:	8c 81       	ldd	r24, Y+4	; 0x04
    54f0:	9d 81       	ldd	r25, Y+5	; 0x05
    54f2:	2b ea       	ldi	r18, 0xAB	; 171
    54f4:	3a ea       	ldi	r19, 0xAA	; 170
    54f6:	4a e2       	ldi	r20, 0x2A	; 42
    54f8:	51 e4       	ldi	r21, 0x41	; 65
    54fa:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    54fe:	dc 01       	movw	r26, r24
    5500:	cb 01       	movw	r24, r22
    5502:	8e 83       	std	Y+6, r24	; 0x06
    5504:	9f 83       	std	Y+7, r25	; 0x07
    5506:	a8 87       	std	Y+8, r26	; 0x08
    5508:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    550a:	11 e0       	ldi	r17, 0x01	; 1
    550c:	6e 81       	ldd	r22, Y+6	; 0x06
    550e:	7f 81       	ldd	r23, Y+7	; 0x07
    5510:	88 85       	ldd	r24, Y+8	; 0x08
    5512:	99 85       	ldd	r25, Y+9	; 0x09
    5514:	20 e0       	ldi	r18, 0x00	; 0
    5516:	30 e0       	ldi	r19, 0x00	; 0
    5518:	40 e8       	ldi	r20, 0x80	; 128
    551a:	5f e3       	ldi	r21, 0x3F	; 63
    551c:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    5520:	88 23       	and	r24, r24
    5522:	0c f0       	brlt	.+2      	; 0x5526 <chb_set_state+0xf0>
    5524:	10 e0       	ldi	r17, 0x00	; 0
    5526:	11 23       	and	r17, r17
    5528:	19 f0       	breq	.+6      	; 0x5530 <chb_set_state+0xfa>
		__ticks = 1;
    552a:	81 e0       	ldi	r24, 0x01	; 1
    552c:	8a 87       	std	Y+10, r24	; 0x0a
    552e:	a3 c0       	rjmp	.+326    	; 0x5676 <chb_set_state+0x240>
	else if (__tmp > 255)
    5530:	11 e0       	ldi	r17, 0x01	; 1
    5532:	6e 81       	ldd	r22, Y+6	; 0x06
    5534:	7f 81       	ldd	r23, Y+7	; 0x07
    5536:	88 85       	ldd	r24, Y+8	; 0x08
    5538:	99 85       	ldd	r25, Y+9	; 0x09
    553a:	20 e0       	ldi	r18, 0x00	; 0
    553c:	30 e0       	ldi	r19, 0x00	; 0
    553e:	4f e7       	ldi	r20, 0x7F	; 127
    5540:	53 e4       	ldi	r21, 0x43	; 67
    5542:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    5546:	18 16       	cp	r1, r24
    5548:	0c f0       	brlt	.+2      	; 0x554c <chb_set_state+0x116>
    554a:	10 e0       	ldi	r17, 0x00	; 0
    554c:	11 23       	and	r17, r17
    554e:	09 f4       	brne	.+2      	; 0x5552 <chb_set_state+0x11c>
    5550:	89 c0       	rjmp	.+274    	; 0x5664 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    5552:	6a 81       	ldd	r22, Y+2	; 0x02
    5554:	7b 81       	ldd	r23, Y+3	; 0x03
    5556:	8c 81       	ldd	r24, Y+4	; 0x04
    5558:	9d 81       	ldd	r25, Y+5	; 0x05
    555a:	20 e0       	ldi	r18, 0x00	; 0
    555c:	30 e0       	ldi	r19, 0x00	; 0
    555e:	4a e7       	ldi	r20, 0x7A	; 122
    5560:	54 e4       	ldi	r21, 0x44	; 68
    5562:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    5566:	dc 01       	movw	r26, r24
    5568:	cb 01       	movw	r24, r22
    556a:	8b 87       	std	Y+11, r24	; 0x0b
    556c:	9c 87       	std	Y+12, r25	; 0x0c
    556e:	ad 87       	std	Y+13, r26	; 0x0d
    5570:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5572:	6b 85       	ldd	r22, Y+11	; 0x0b
    5574:	7c 85       	ldd	r23, Y+12	; 0x0c
    5576:	8d 85       	ldd	r24, Y+13	; 0x0d
    5578:	9e 85       	ldd	r25, Y+14	; 0x0e
    557a:	20 e0       	ldi	r18, 0x00	; 0
    557c:	30 e0       	ldi	r19, 0x00	; 0
    557e:	4a ef       	ldi	r20, 0xFA	; 250
    5580:	55 e4       	ldi	r21, 0x45	; 69
    5582:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5586:	dc 01       	movw	r26, r24
    5588:	cb 01       	movw	r24, r22
    558a:	8f 87       	std	Y+15, r24	; 0x0f
    558c:	98 8b       	std	Y+16, r25	; 0x10
    558e:	a9 8b       	std	Y+17, r26	; 0x11
    5590:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    5592:	11 e0       	ldi	r17, 0x01	; 1
    5594:	6f 85       	ldd	r22, Y+15	; 0x0f
    5596:	78 89       	ldd	r23, Y+16	; 0x10
    5598:	89 89       	ldd	r24, Y+17	; 0x11
    559a:	9a 89       	ldd	r25, Y+18	; 0x12
    559c:	20 e0       	ldi	r18, 0x00	; 0
    559e:	30 e0       	ldi	r19, 0x00	; 0
    55a0:	40 e8       	ldi	r20, 0x80	; 128
    55a2:	5f e3       	ldi	r21, 0x3F	; 63
    55a4:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    55a8:	88 23       	and	r24, r24
    55aa:	0c f0       	brlt	.+2      	; 0x55ae <chb_set_state+0x178>
    55ac:	10 e0       	ldi	r17, 0x00	; 0
    55ae:	11 23       	and	r17, r17
    55b0:	29 f0       	breq	.+10     	; 0x55bc <chb_set_state+0x186>
		__ticks = 1;
    55b2:	81 e0       	ldi	r24, 0x01	; 1
    55b4:	90 e0       	ldi	r25, 0x00	; 0
    55b6:	8b 8b       	std	Y+19, r24	; 0x13
    55b8:	9c 8b       	std	Y+20, r25	; 0x14
    55ba:	46 c0       	rjmp	.+140    	; 0x5648 <chb_set_state+0x212>
	else if (__tmp > 65535)
    55bc:	11 e0       	ldi	r17, 0x01	; 1
    55be:	6f 85       	ldd	r22, Y+15	; 0x0f
    55c0:	78 89       	ldd	r23, Y+16	; 0x10
    55c2:	89 89       	ldd	r24, Y+17	; 0x11
    55c4:	9a 89       	ldd	r25, Y+18	; 0x12
    55c6:	20 e0       	ldi	r18, 0x00	; 0
    55c8:	3f ef       	ldi	r19, 0xFF	; 255
    55ca:	4f e7       	ldi	r20, 0x7F	; 127
    55cc:	57 e4       	ldi	r21, 0x47	; 71
    55ce:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    55d2:	18 16       	cp	r1, r24
    55d4:	0c f0       	brlt	.+2      	; 0x55d8 <chb_set_state+0x1a2>
    55d6:	10 e0       	ldi	r17, 0x00	; 0
    55d8:	11 23       	and	r17, r17
    55da:	61 f1       	breq	.+88     	; 0x5634 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    55dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    55de:	7c 85       	ldd	r23, Y+12	; 0x0c
    55e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    55e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    55e4:	20 e0       	ldi	r18, 0x00	; 0
    55e6:	30 e0       	ldi	r19, 0x00	; 0
    55e8:	40 e2       	ldi	r20, 0x20	; 32
    55ea:	51 e4       	ldi	r21, 0x41	; 65
    55ec:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    55f0:	dc 01       	movw	r26, r24
    55f2:	cb 01       	movw	r24, r22
    55f4:	bc 01       	movw	r22, r24
    55f6:	cd 01       	movw	r24, r26
    55f8:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    55fc:	dc 01       	movw	r26, r24
    55fe:	cb 01       	movw	r24, r22
    5600:	8b 8b       	std	Y+19, r24	; 0x13
    5602:	9c 8b       	std	Y+20, r25	; 0x14
    5604:	12 c0       	rjmp	.+36     	; 0x562a <chb_set_state+0x1f4>
    5606:	80 e2       	ldi	r24, 0x20	; 32
    5608:	93 e0       	ldi	r25, 0x03	; 3
    560a:	8d 8b       	std	Y+21, r24	; 0x15
    560c:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    560e:	8d 89       	ldd	r24, Y+21	; 0x15
    5610:	9e 89       	ldd	r25, Y+22	; 0x16
    5612:	8c 01       	movw	r16, r24
    5614:	c8 01       	movw	r24, r16
    5616:	01 97       	sbiw	r24, 0x01	; 1
    5618:	f1 f7       	brne	.-4      	; 0x5616 <chb_set_state+0x1e0>
    561a:	8c 01       	movw	r16, r24
    561c:	0d 8b       	std	Y+21, r16	; 0x15
    561e:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5620:	8b 89       	ldd	r24, Y+19	; 0x13
    5622:	9c 89       	ldd	r25, Y+20	; 0x14
    5624:	01 97       	sbiw	r24, 0x01	; 1
    5626:	8b 8b       	std	Y+19, r24	; 0x13
    5628:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    562a:	8b 89       	ldd	r24, Y+19	; 0x13
    562c:	9c 89       	ldd	r25, Y+20	; 0x14
    562e:	00 97       	sbiw	r24, 0x00	; 0
    5630:	51 f7       	brne	.-44     	; 0x5606 <chb_set_state+0x1d0>
    5632:	29 c0       	rjmp	.+82     	; 0x5686 <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5634:	6f 85       	ldd	r22, Y+15	; 0x0f
    5636:	78 89       	ldd	r23, Y+16	; 0x10
    5638:	89 89       	ldd	r24, Y+17	; 0x11
    563a:	9a 89       	ldd	r25, Y+18	; 0x12
    563c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5640:	dc 01       	movw	r26, r24
    5642:	cb 01       	movw	r24, r22
    5644:	8b 8b       	std	Y+19, r24	; 0x13
    5646:	9c 8b       	std	Y+20, r25	; 0x14
    5648:	8b 89       	ldd	r24, Y+19	; 0x13
    564a:	9c 89       	ldd	r25, Y+20	; 0x14
    564c:	8f 8b       	std	Y+23, r24	; 0x17
    564e:	98 8f       	std	Y+24, r25	; 0x18
    5650:	8f 89       	ldd	r24, Y+23	; 0x17
    5652:	98 8d       	ldd	r25, Y+24	; 0x18
    5654:	8c 01       	movw	r16, r24
    5656:	f8 01       	movw	r30, r16
    5658:	31 97       	sbiw	r30, 0x01	; 1
    565a:	f1 f7       	brne	.-4      	; 0x5658 <chb_set_state+0x222>
    565c:	8f 01       	movw	r16, r30
    565e:	0f 8b       	std	Y+23, r16	; 0x17
    5660:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    5662:	24 c2       	rjmp	.+1096   	; 0x5aac <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5664:	6e 81       	ldd	r22, Y+6	; 0x06
    5666:	7f 81       	ldd	r23, Y+7	; 0x07
    5668:	88 85       	ldd	r24, Y+8	; 0x08
    566a:	99 85       	ldd	r25, Y+9	; 0x09
    566c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5670:	dc 01       	movw	r26, r24
    5672:	cb 01       	movw	r24, r22
    5674:	8a 87       	std	Y+10, r24	; 0x0a
    5676:	8a 85       	ldd	r24, Y+10	; 0x0a
    5678:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    567a:	89 8d       	ldd	r24, Y+25	; 0x19
    567c:	18 2f       	mov	r17, r24
    567e:	1a 95       	dec	r17
    5680:	f1 f7       	brne	.-4      	; 0x567e <chb_set_state+0x248>
    5682:	19 8f       	std	Y+25, r17	; 0x19
    5684:	13 c2       	rjmp	.+1062   	; 0x5aac <chb_set_state+0x676>
    5686:	12 c2       	rjmp	.+1060   	; 0x5aac <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    5688:	89 81       	ldd	r24, Y+1	; 0x01
    568a:	86 31       	cpi	r24, 0x16	; 22
    568c:	09 f0       	breq	.+2      	; 0x5690 <chb_set_state+0x25a>
    568e:	0b c2       	rjmp	.+1046   	; 0x5aa6 <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5690:	82 e0       	ldi	r24, 0x02	; 2
    5692:	69 e0       	ldi	r22, 0x09	; 9
    5694:	4f e1       	ldi	r20, 0x1F	; 31
    5696:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
    569a:	80 e0       	ldi	r24, 0x00	; 0
    569c:	90 e0       	ldi	r25, 0x00	; 0
    569e:	a0 e8       	ldi	r26, 0x80	; 128
    56a0:	bf e3       	ldi	r27, 0x3F	; 63
    56a2:	8a 8f       	std	Y+26, r24	; 0x1a
    56a4:	9b 8f       	std	Y+27, r25	; 0x1b
    56a6:	ac 8f       	std	Y+28, r26	; 0x1c
    56a8:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    56aa:	6a 8d       	ldd	r22, Y+26	; 0x1a
    56ac:	7b 8d       	ldd	r23, Y+27	; 0x1b
    56ae:	8c 8d       	ldd	r24, Y+28	; 0x1c
    56b0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    56b2:	2b ea       	ldi	r18, 0xAB	; 171
    56b4:	3a ea       	ldi	r19, 0xAA	; 170
    56b6:	4a e2       	ldi	r20, 0x2A	; 42
    56b8:	51 e4       	ldi	r21, 0x41	; 65
    56ba:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    56be:	dc 01       	movw	r26, r24
    56c0:	cb 01       	movw	r24, r22
    56c2:	8e 8f       	std	Y+30, r24	; 0x1e
    56c4:	9f 8f       	std	Y+31, r25	; 0x1f
    56c6:	a8 a3       	lds	r26, 0x58
    56c8:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    56ca:	11 e0       	ldi	r17, 0x01	; 1
    56cc:	6e 8d       	ldd	r22, Y+30	; 0x1e
    56ce:	7f 8d       	ldd	r23, Y+31	; 0x1f
    56d0:	88 a1       	lds	r24, 0x48
    56d2:	99 a1       	lds	r25, 0x49
    56d4:	20 e0       	ldi	r18, 0x00	; 0
    56d6:	30 e0       	ldi	r19, 0x00	; 0
    56d8:	40 e8       	ldi	r20, 0x80	; 128
    56da:	5f e3       	ldi	r21, 0x3F	; 63
    56dc:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    56e0:	88 23       	and	r24, r24
    56e2:	0c f0       	brlt	.+2      	; 0x56e6 <chb_set_state+0x2b0>
    56e4:	10 e0       	ldi	r17, 0x00	; 0
    56e6:	11 23       	and	r17, r17
    56e8:	19 f0       	breq	.+6      	; 0x56f0 <chb_set_state+0x2ba>
		__ticks = 1;
    56ea:	81 e0       	ldi	r24, 0x01	; 1
    56ec:	8a a3       	lds	r24, 0x5a
    56ee:	a3 c0       	rjmp	.+326    	; 0x5836 <chb_set_state+0x400>
	else if (__tmp > 255)
    56f0:	11 e0       	ldi	r17, 0x01	; 1
    56f2:	6e 8d       	ldd	r22, Y+30	; 0x1e
    56f4:	7f 8d       	ldd	r23, Y+31	; 0x1f
    56f6:	88 a1       	lds	r24, 0x48
    56f8:	99 a1       	lds	r25, 0x49
    56fa:	20 e0       	ldi	r18, 0x00	; 0
    56fc:	30 e0       	ldi	r19, 0x00	; 0
    56fe:	4f e7       	ldi	r20, 0x7F	; 127
    5700:	53 e4       	ldi	r21, 0x43	; 67
    5702:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    5706:	18 16       	cp	r1, r24
    5708:	0c f0       	brlt	.+2      	; 0x570c <chb_set_state+0x2d6>
    570a:	10 e0       	ldi	r17, 0x00	; 0
    570c:	11 23       	and	r17, r17
    570e:	09 f4       	brne	.+2      	; 0x5712 <chb_set_state+0x2dc>
    5710:	89 c0       	rjmp	.+274    	; 0x5824 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    5712:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5714:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5716:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5718:	9d 8d       	ldd	r25, Y+29	; 0x1d
    571a:	20 e0       	ldi	r18, 0x00	; 0
    571c:	30 e0       	ldi	r19, 0x00	; 0
    571e:	4a e7       	ldi	r20, 0x7A	; 122
    5720:	54 e4       	ldi	r21, 0x44	; 68
    5722:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    5726:	dc 01       	movw	r26, r24
    5728:	cb 01       	movw	r24, r22
    572a:	8b a3       	lds	r24, 0x5b
    572c:	9c a3       	lds	r25, 0x5c
    572e:	ad a3       	lds	r26, 0x5d
    5730:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5732:	6b a1       	lds	r22, 0x4b
    5734:	7c a1       	lds	r23, 0x4c
    5736:	8d a1       	lds	r24, 0x4d
    5738:	9e a1       	lds	r25, 0x4e
    573a:	20 e0       	ldi	r18, 0x00	; 0
    573c:	30 e0       	ldi	r19, 0x00	; 0
    573e:	4a ef       	ldi	r20, 0xFA	; 250
    5740:	55 e4       	ldi	r21, 0x45	; 69
    5742:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5746:	dc 01       	movw	r26, r24
    5748:	cb 01       	movw	r24, r22
    574a:	8f a3       	lds	r24, 0x5f
    574c:	98 a7       	lds	r25, 0x78
    574e:	a9 a7       	lds	r26, 0x79
    5750:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    5752:	11 e0       	ldi	r17, 0x01	; 1
    5754:	6f a1       	lds	r22, 0x4f
    5756:	78 a5       	lds	r23, 0x68
    5758:	89 a5       	lds	r24, 0x69
    575a:	9a a5       	lds	r25, 0x6a
    575c:	20 e0       	ldi	r18, 0x00	; 0
    575e:	30 e0       	ldi	r19, 0x00	; 0
    5760:	40 e8       	ldi	r20, 0x80	; 128
    5762:	5f e3       	ldi	r21, 0x3F	; 63
    5764:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    5768:	88 23       	and	r24, r24
    576a:	0c f0       	brlt	.+2      	; 0x576e <chb_set_state+0x338>
    576c:	10 e0       	ldi	r17, 0x00	; 0
    576e:	11 23       	and	r17, r17
    5770:	29 f0       	breq	.+10     	; 0x577c <chb_set_state+0x346>
		__ticks = 1;
    5772:	81 e0       	ldi	r24, 0x01	; 1
    5774:	90 e0       	ldi	r25, 0x00	; 0
    5776:	8b a7       	lds	r24, 0x7b
    5778:	9c a7       	lds	r25, 0x7c
    577a:	46 c0       	rjmp	.+140    	; 0x5808 <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    577c:	11 e0       	ldi	r17, 0x01	; 1
    577e:	6f a1       	lds	r22, 0x4f
    5780:	78 a5       	lds	r23, 0x68
    5782:	89 a5       	lds	r24, 0x69
    5784:	9a a5       	lds	r25, 0x6a
    5786:	20 e0       	ldi	r18, 0x00	; 0
    5788:	3f ef       	ldi	r19, 0xFF	; 255
    578a:	4f e7       	ldi	r20, 0x7F	; 127
    578c:	57 e4       	ldi	r21, 0x47	; 71
    578e:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    5792:	18 16       	cp	r1, r24
    5794:	0c f0       	brlt	.+2      	; 0x5798 <chb_set_state+0x362>
    5796:	10 e0       	ldi	r17, 0x00	; 0
    5798:	11 23       	and	r17, r17
    579a:	61 f1       	breq	.+88     	; 0x57f4 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    579c:	6b a1       	lds	r22, 0x4b
    579e:	7c a1       	lds	r23, 0x4c
    57a0:	8d a1       	lds	r24, 0x4d
    57a2:	9e a1       	lds	r25, 0x4e
    57a4:	20 e0       	ldi	r18, 0x00	; 0
    57a6:	30 e0       	ldi	r19, 0x00	; 0
    57a8:	40 e2       	ldi	r20, 0x20	; 32
    57aa:	51 e4       	ldi	r21, 0x41	; 65
    57ac:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    57b0:	dc 01       	movw	r26, r24
    57b2:	cb 01       	movw	r24, r22
    57b4:	bc 01       	movw	r22, r24
    57b6:	cd 01       	movw	r24, r26
    57b8:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    57bc:	dc 01       	movw	r26, r24
    57be:	cb 01       	movw	r24, r22
    57c0:	8b a7       	lds	r24, 0x7b
    57c2:	9c a7       	lds	r25, 0x7c
    57c4:	12 c0       	rjmp	.+36     	; 0x57ea <chb_set_state+0x3b4>
    57c6:	80 e2       	ldi	r24, 0x20	; 32
    57c8:	93 e0       	ldi	r25, 0x03	; 3
    57ca:	8d a7       	lds	r24, 0x7d
    57cc:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    57ce:	8d a5       	lds	r24, 0x6d
    57d0:	9e a5       	lds	r25, 0x6e
    57d2:	8c 01       	movw	r16, r24
    57d4:	c8 01       	movw	r24, r16
    57d6:	01 97       	sbiw	r24, 0x01	; 1
    57d8:	f1 f7       	brne	.-4      	; 0x57d6 <chb_set_state+0x3a0>
    57da:	8c 01       	movw	r16, r24
    57dc:	0d a7       	lds	r16, 0x7d
    57de:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57e0:	8b a5       	lds	r24, 0x6b
    57e2:	9c a5       	lds	r25, 0x6c
    57e4:	01 97       	sbiw	r24, 0x01	; 1
    57e6:	8b a7       	lds	r24, 0x7b
    57e8:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57ea:	8b a5       	lds	r24, 0x6b
    57ec:	9c a5       	lds	r25, 0x6c
    57ee:	00 97       	sbiw	r24, 0x00	; 0
    57f0:	51 f7       	brne	.-44     	; 0x57c6 <chb_set_state+0x390>
    57f2:	29 c0       	rjmp	.+82     	; 0x5846 <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57f4:	6f a1       	lds	r22, 0x4f
    57f6:	78 a5       	lds	r23, 0x68
    57f8:	89 a5       	lds	r24, 0x69
    57fa:	9a a5       	lds	r25, 0x6a
    57fc:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5800:	dc 01       	movw	r26, r24
    5802:	cb 01       	movw	r24, r22
    5804:	8b a7       	lds	r24, 0x7b
    5806:	9c a7       	lds	r25, 0x7c
    5808:	8b a5       	lds	r24, 0x6b
    580a:	9c a5       	lds	r25, 0x6c
    580c:	8f a7       	lds	r24, 0x7f
    580e:	98 ab       	sts	0x58, r25
    5810:	8f a5       	lds	r24, 0x6f
    5812:	98 a9       	sts	0x48, r25
    5814:	8c 01       	movw	r16, r24
    5816:	f8 01       	movw	r30, r16
    5818:	31 97       	sbiw	r30, 0x01	; 1
    581a:	f1 f7       	brne	.-4      	; 0x5818 <chb_set_state+0x3e2>
    581c:	8f 01       	movw	r16, r30
    581e:	0f a7       	lds	r16, 0x7f
    5820:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5822:	41 c1       	rjmp	.+642    	; 0x5aa6 <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5824:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5826:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5828:	88 a1       	lds	r24, 0x48
    582a:	99 a1       	lds	r25, 0x49
    582c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5830:	dc 01       	movw	r26, r24
    5832:	cb 01       	movw	r24, r22
    5834:	8a a3       	lds	r24, 0x5a
    5836:	8a a1       	lds	r24, 0x4a
    5838:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    583a:	89 a9       	sts	0x49, r24
    583c:	18 2f       	mov	r17, r24
    583e:	1a 95       	dec	r17
    5840:	f1 f7       	brne	.-4      	; 0x583e <chb_set_state+0x408>
    5842:	19 ab       	sts	0x59, r17
    5844:	30 c1       	rjmp	.+608    	; 0x5aa6 <chb_set_state+0x670>
    5846:	2f c1       	rjmp	.+606    	; 0x5aa6 <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    5848:	89 81       	ldd	r24, Y+1	; 0x01
    584a:	89 31       	cpi	r24, 0x19	; 25
    584c:	09 f0       	breq	.+2      	; 0x5850 <chb_set_state+0x41a>
    584e:	2d c1       	rjmp	.+602    	; 0x5aaa <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5850:	82 e0       	ldi	r24, 0x02	; 2
    5852:	69 e0       	ldi	r22, 0x09	; 9
    5854:	4f e1       	ldi	r20, 0x1F	; 31
    5856:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
    585a:	80 e0       	ldi	r24, 0x00	; 0
    585c:	90 e0       	ldi	r25, 0x00	; 0
    585e:	a0 e8       	ldi	r26, 0x80	; 128
    5860:	bf e3       	ldi	r27, 0x3F	; 63
    5862:	8a ab       	sts	0x5a, r24
    5864:	9b ab       	sts	0x5b, r25
    5866:	ac ab       	sts	0x5c, r26
    5868:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    586a:	6a a9       	sts	0x4a, r22
    586c:	7b a9       	sts	0x4b, r23
    586e:	8c a9       	sts	0x4c, r24
    5870:	9d a9       	sts	0x4d, r25
    5872:	2b ea       	ldi	r18, 0xAB	; 171
    5874:	3a ea       	ldi	r19, 0xAA	; 170
    5876:	4a e2       	ldi	r20, 0x2A	; 42
    5878:	51 e4       	ldi	r21, 0x41	; 65
    587a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    587e:	dc 01       	movw	r26, r24
    5880:	cb 01       	movw	r24, r22
    5882:	8e ab       	sts	0x5e, r24
    5884:	9f ab       	sts	0x5f, r25
    5886:	a8 af       	sts	0x78, r26
    5888:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    588a:	11 e0       	ldi	r17, 0x01	; 1
    588c:	6e a9       	sts	0x4e, r22
    588e:	7f a9       	sts	0x4f, r23
    5890:	88 ad       	sts	0x68, r24
    5892:	99 ad       	sts	0x69, r25
    5894:	20 e0       	ldi	r18, 0x00	; 0
    5896:	30 e0       	ldi	r19, 0x00	; 0
    5898:	40 e8       	ldi	r20, 0x80	; 128
    589a:	5f e3       	ldi	r21, 0x3F	; 63
    589c:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    58a0:	88 23       	and	r24, r24
    58a2:	0c f0       	brlt	.+2      	; 0x58a6 <chb_set_state+0x470>
    58a4:	10 e0       	ldi	r17, 0x00	; 0
    58a6:	11 23       	and	r17, r17
    58a8:	19 f0       	breq	.+6      	; 0x58b0 <chb_set_state+0x47a>
		__ticks = 1;
    58aa:	81 e0       	ldi	r24, 0x01	; 1
    58ac:	8a af       	sts	0x7a, r24
    58ae:	e6 c0       	rjmp	.+460    	; 0x5a7c <chb_set_state+0x646>
	else if (__tmp > 255)
    58b0:	11 e0       	ldi	r17, 0x01	; 1
    58b2:	6e a9       	sts	0x4e, r22
    58b4:	7f a9       	sts	0x4f, r23
    58b6:	88 ad       	sts	0x68, r24
    58b8:	99 ad       	sts	0x69, r25
    58ba:	20 e0       	ldi	r18, 0x00	; 0
    58bc:	30 e0       	ldi	r19, 0x00	; 0
    58be:	4f e7       	ldi	r20, 0x7F	; 127
    58c0:	53 e4       	ldi	r21, 0x43	; 67
    58c2:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    58c6:	18 16       	cp	r1, r24
    58c8:	0c f0       	brlt	.+2      	; 0x58cc <chb_set_state+0x496>
    58ca:	10 e0       	ldi	r17, 0x00	; 0
    58cc:	11 23       	and	r17, r17
    58ce:	09 f4       	brne	.+2      	; 0x58d2 <chb_set_state+0x49c>
    58d0:	cc c0       	rjmp	.+408    	; 0x5a6a <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    58d2:	6a a9       	sts	0x4a, r22
    58d4:	7b a9       	sts	0x4b, r23
    58d6:	8c a9       	sts	0x4c, r24
    58d8:	9d a9       	sts	0x4d, r25
    58da:	20 e0       	ldi	r18, 0x00	; 0
    58dc:	30 e0       	ldi	r19, 0x00	; 0
    58de:	4a e7       	ldi	r20, 0x7A	; 122
    58e0:	54 e4       	ldi	r21, 0x44	; 68
    58e2:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    58e6:	dc 01       	movw	r26, r24
    58e8:	cb 01       	movw	r24, r22
    58ea:	8b af       	sts	0x7b, r24
    58ec:	9c af       	sts	0x7c, r25
    58ee:	ad af       	sts	0x7d, r26
    58f0:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    58f2:	8e 01       	movw	r16, r28
    58f4:	01 5c       	subi	r16, 0xC1	; 193
    58f6:	1f 4f       	sbci	r17, 0xFF	; 255
    58f8:	6b ad       	sts	0x6b, r22
    58fa:	7c ad       	sts	0x6c, r23
    58fc:	8d ad       	sts	0x6d, r24
    58fe:	9e ad       	sts	0x6e, r25
    5900:	20 e0       	ldi	r18, 0x00	; 0
    5902:	30 e0       	ldi	r19, 0x00	; 0
    5904:	4a ef       	ldi	r20, 0xFA	; 250
    5906:	55 e4       	ldi	r21, 0x45	; 69
    5908:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    590c:	dc 01       	movw	r26, r24
    590e:	cb 01       	movw	r24, r22
    5910:	f8 01       	movw	r30, r16
    5912:	80 83       	st	Z, r24
    5914:	91 83       	std	Z+1, r25	; 0x01
    5916:	a2 83       	std	Z+2, r26	; 0x02
    5918:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    591a:	ce 01       	movw	r24, r28
    591c:	cf 96       	adiw	r24, 0x3f	; 63
    591e:	11 e0       	ldi	r17, 0x01	; 1
    5920:	fc 01       	movw	r30, r24
    5922:	60 81       	ld	r22, Z
    5924:	71 81       	ldd	r23, Z+1	; 0x01
    5926:	82 81       	ldd	r24, Z+2	; 0x02
    5928:	93 81       	ldd	r25, Z+3	; 0x03
    592a:	20 e0       	ldi	r18, 0x00	; 0
    592c:	30 e0       	ldi	r19, 0x00	; 0
    592e:	40 e8       	ldi	r20, 0x80	; 128
    5930:	5f e3       	ldi	r21, 0x3F	; 63
    5932:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    5936:	88 23       	and	r24, r24
    5938:	0c f0       	brlt	.+2      	; 0x593c <chb_set_state+0x506>
    593a:	10 e0       	ldi	r17, 0x00	; 0
    593c:	11 23       	and	r17, r17
    593e:	49 f0       	breq	.+18     	; 0x5952 <chb_set_state+0x51c>
		__ticks = 1;
    5940:	ce 01       	movw	r24, r28
    5942:	8d 5b       	subi	r24, 0xBD	; 189
    5944:	9f 4f       	sbci	r25, 0xFF	; 255
    5946:	21 e0       	ldi	r18, 0x01	; 1
    5948:	30 e0       	ldi	r19, 0x00	; 0
    594a:	fc 01       	movw	r30, r24
    594c:	20 83       	st	Z, r18
    594e:	31 83       	std	Z+1, r19	; 0x01
    5950:	6e c0       	rjmp	.+220    	; 0x5a2e <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    5952:	ce 01       	movw	r24, r28
    5954:	cf 96       	adiw	r24, 0x3f	; 63
    5956:	11 e0       	ldi	r17, 0x01	; 1
    5958:	fc 01       	movw	r30, r24
    595a:	60 81       	ld	r22, Z
    595c:	71 81       	ldd	r23, Z+1	; 0x01
    595e:	82 81       	ldd	r24, Z+2	; 0x02
    5960:	93 81       	ldd	r25, Z+3	; 0x03
    5962:	20 e0       	ldi	r18, 0x00	; 0
    5964:	3f ef       	ldi	r19, 0xFF	; 255
    5966:	4f e7       	ldi	r20, 0x7F	; 127
    5968:	57 e4       	ldi	r21, 0x47	; 71
    596a:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    596e:	18 16       	cp	r1, r24
    5970:	0c f0       	brlt	.+2      	; 0x5974 <chb_set_state+0x53e>
    5972:	10 e0       	ldi	r17, 0x00	; 0
    5974:	11 23       	and	r17, r17
    5976:	09 f4       	brne	.+2      	; 0x597a <chb_set_state+0x544>
    5978:	49 c0       	rjmp	.+146    	; 0x5a0c <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    597a:	6b ad       	sts	0x6b, r22
    597c:	7c ad       	sts	0x6c, r23
    597e:	8d ad       	sts	0x6d, r24
    5980:	9e ad       	sts	0x6e, r25
    5982:	20 e0       	ldi	r18, 0x00	; 0
    5984:	30 e0       	ldi	r19, 0x00	; 0
    5986:	40 e2       	ldi	r20, 0x20	; 32
    5988:	51 e4       	ldi	r21, 0x41	; 65
    598a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    598e:	dc 01       	movw	r26, r24
    5990:	cb 01       	movw	r24, r22
    5992:	8e 01       	movw	r16, r28
    5994:	0d 5b       	subi	r16, 0xBD	; 189
    5996:	1f 4f       	sbci	r17, 0xFF	; 255
    5998:	bc 01       	movw	r22, r24
    599a:	cd 01       	movw	r24, r26
    599c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    59a0:	dc 01       	movw	r26, r24
    59a2:	cb 01       	movw	r24, r22
    59a4:	f8 01       	movw	r30, r16
    59a6:	80 83       	st	Z, r24
    59a8:	91 83       	std	Z+1, r25	; 0x01
    59aa:	27 c0       	rjmp	.+78     	; 0x59fa <chb_set_state+0x5c4>
    59ac:	ce 01       	movw	r24, r28
    59ae:	8b 5b       	subi	r24, 0xBB	; 187
    59b0:	9f 4f       	sbci	r25, 0xFF	; 255
    59b2:	20 e2       	ldi	r18, 0x20	; 32
    59b4:	33 e0       	ldi	r19, 0x03	; 3
    59b6:	fc 01       	movw	r30, r24
    59b8:	20 83       	st	Z, r18
    59ba:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    59bc:	ce 01       	movw	r24, r28
    59be:	8b 5b       	subi	r24, 0xBB	; 187
    59c0:	9f 4f       	sbci	r25, 0xFF	; 255
    59c2:	fc 01       	movw	r30, r24
    59c4:	80 81       	ld	r24, Z
    59c6:	91 81       	ldd	r25, Z+1	; 0x01
    59c8:	8c 01       	movw	r16, r24
    59ca:	c8 01       	movw	r24, r16
    59cc:	01 97       	sbiw	r24, 0x01	; 1
    59ce:	f1 f7       	brne	.-4      	; 0x59cc <chb_set_state+0x596>
    59d0:	8c 01       	movw	r16, r24
    59d2:	ce 01       	movw	r24, r28
    59d4:	8b 5b       	subi	r24, 0xBB	; 187
    59d6:	9f 4f       	sbci	r25, 0xFF	; 255
    59d8:	fc 01       	movw	r30, r24
    59da:	00 83       	st	Z, r16
    59dc:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    59de:	ce 01       	movw	r24, r28
    59e0:	8d 5b       	subi	r24, 0xBD	; 189
    59e2:	9f 4f       	sbci	r25, 0xFF	; 255
    59e4:	9e 01       	movw	r18, r28
    59e6:	2d 5b       	subi	r18, 0xBD	; 189
    59e8:	3f 4f       	sbci	r19, 0xFF	; 255
    59ea:	f9 01       	movw	r30, r18
    59ec:	20 81       	ld	r18, Z
    59ee:	31 81       	ldd	r19, Z+1	; 0x01
    59f0:	21 50       	subi	r18, 0x01	; 1
    59f2:	30 40       	sbci	r19, 0x00	; 0
    59f4:	fc 01       	movw	r30, r24
    59f6:	20 83       	st	Z, r18
    59f8:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    59fa:	ce 01       	movw	r24, r28
    59fc:	8d 5b       	subi	r24, 0xBD	; 189
    59fe:	9f 4f       	sbci	r25, 0xFF	; 255
    5a00:	fc 01       	movw	r30, r24
    5a02:	80 81       	ld	r24, Z
    5a04:	91 81       	ldd	r25, Z+1	; 0x01
    5a06:	00 97       	sbiw	r24, 0x00	; 0
    5a08:	89 f6       	brne	.-94     	; 0x59ac <chb_set_state+0x576>
    5a0a:	4c c0       	rjmp	.+152    	; 0x5aa4 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a0c:	8e 01       	movw	r16, r28
    5a0e:	0d 5b       	subi	r16, 0xBD	; 189
    5a10:	1f 4f       	sbci	r17, 0xFF	; 255
    5a12:	ce 01       	movw	r24, r28
    5a14:	cf 96       	adiw	r24, 0x3f	; 63
    5a16:	fc 01       	movw	r30, r24
    5a18:	60 81       	ld	r22, Z
    5a1a:	71 81       	ldd	r23, Z+1	; 0x01
    5a1c:	82 81       	ldd	r24, Z+2	; 0x02
    5a1e:	93 81       	ldd	r25, Z+3	; 0x03
    5a20:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5a24:	dc 01       	movw	r26, r24
    5a26:	cb 01       	movw	r24, r22
    5a28:	f8 01       	movw	r30, r16
    5a2a:	80 83       	st	Z, r24
    5a2c:	91 83       	std	Z+1, r25	; 0x01
    5a2e:	ce 01       	movw	r24, r28
    5a30:	89 5b       	subi	r24, 0xB9	; 185
    5a32:	9f 4f       	sbci	r25, 0xFF	; 255
    5a34:	9e 01       	movw	r18, r28
    5a36:	2d 5b       	subi	r18, 0xBD	; 189
    5a38:	3f 4f       	sbci	r19, 0xFF	; 255
    5a3a:	f9 01       	movw	r30, r18
    5a3c:	20 81       	ld	r18, Z
    5a3e:	31 81       	ldd	r19, Z+1	; 0x01
    5a40:	fc 01       	movw	r30, r24
    5a42:	20 83       	st	Z, r18
    5a44:	31 83       	std	Z+1, r19	; 0x01
    5a46:	ce 01       	movw	r24, r28
    5a48:	89 5b       	subi	r24, 0xB9	; 185
    5a4a:	9f 4f       	sbci	r25, 0xFF	; 255
    5a4c:	fc 01       	movw	r30, r24
    5a4e:	80 81       	ld	r24, Z
    5a50:	91 81       	ldd	r25, Z+1	; 0x01
    5a52:	8c 01       	movw	r16, r24
    5a54:	c8 01       	movw	r24, r16
    5a56:	01 97       	sbiw	r24, 0x01	; 1
    5a58:	f1 f7       	brne	.-4      	; 0x5a56 <chb_set_state+0x620>
    5a5a:	8c 01       	movw	r16, r24
    5a5c:	ce 01       	movw	r24, r28
    5a5e:	89 5b       	subi	r24, 0xB9	; 185
    5a60:	9f 4f       	sbci	r25, 0xFF	; 255
    5a62:	fc 01       	movw	r30, r24
    5a64:	00 83       	st	Z, r16
    5a66:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5a68:	20 c0       	rjmp	.+64     	; 0x5aaa <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5a6a:	6e a9       	sts	0x4e, r22
    5a6c:	7f a9       	sts	0x4f, r23
    5a6e:	88 ad       	sts	0x68, r24
    5a70:	99 ad       	sts	0x69, r25
    5a72:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5a76:	dc 01       	movw	r26, r24
    5a78:	cb 01       	movw	r24, r22
    5a7a:	8a af       	sts	0x7a, r24
    5a7c:	ce 01       	movw	r24, r28
    5a7e:	87 5b       	subi	r24, 0xB7	; 183
    5a80:	9f 4f       	sbci	r25, 0xFF	; 255
    5a82:	2a ad       	sts	0x6a, r18
    5a84:	fc 01       	movw	r30, r24
    5a86:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5a88:	ce 01       	movw	r24, r28
    5a8a:	87 5b       	subi	r24, 0xB7	; 183
    5a8c:	9f 4f       	sbci	r25, 0xFF	; 255
    5a8e:	fc 01       	movw	r30, r24
    5a90:	80 81       	ld	r24, Z
    5a92:	18 2f       	mov	r17, r24
    5a94:	1a 95       	dec	r17
    5a96:	f1 f7       	brne	.-4      	; 0x5a94 <chb_set_state+0x65e>
    5a98:	ce 01       	movw	r24, r28
    5a9a:	87 5b       	subi	r24, 0xB7	; 183
    5a9c:	9f 4f       	sbci	r25, 0xFF	; 255
    5a9e:	fc 01       	movw	r30, r24
    5aa0:	10 83       	st	Z, r17
    5aa2:	03 c0       	rjmp	.+6      	; 0x5aaa <chb_set_state+0x674>
    5aa4:	02 c0       	rjmp	.+4      	; 0x5aaa <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5aa6:	00 00       	nop
    5aa8:	01 c0       	rjmp	.+2      	; 0x5aac <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5aaa:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    5aac:	9e 01       	movw	r18, r28
    5aae:	2e 59       	subi	r18, 0x9E	; 158
    5ab0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ab2:	82 e0       	ldi	r24, 0x02	; 2
    5ab4:	f9 01       	movw	r30, r18
    5ab6:	60 81       	ld	r22, Z
    5ab8:	4f e1       	ldi	r20, 0x1F	; 31
    5aba:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
    5abe:	9e 01       	movw	r18, r28
    5ac0:	26 5b       	subi	r18, 0xB6	; 182
    5ac2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ac4:	80 e0       	ldi	r24, 0x00	; 0
    5ac6:	90 e0       	ldi	r25, 0x00	; 0
    5ac8:	ac ed       	ldi	r26, 0xDC	; 220
    5aca:	b2 e4       	ldi	r27, 0x42	; 66
    5acc:	f9 01       	movw	r30, r18
    5ace:	80 83       	st	Z, r24
    5ad0:	91 83       	std	Z+1, r25	; 0x01
    5ad2:	a2 83       	std	Z+2, r26	; 0x02
    5ad4:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5ad6:	8e 01       	movw	r16, r28
    5ad8:	02 5b       	subi	r16, 0xB2	; 178
    5ada:	1f 4f       	sbci	r17, 0xFF	; 255
    5adc:	ce 01       	movw	r24, r28
    5ade:	86 5b       	subi	r24, 0xB6	; 182
    5ae0:	9f 4f       	sbci	r25, 0xFF	; 255
    5ae2:	fc 01       	movw	r30, r24
    5ae4:	60 81       	ld	r22, Z
    5ae6:	71 81       	ldd	r23, Z+1	; 0x01
    5ae8:	82 81       	ldd	r24, Z+2	; 0x02
    5aea:	93 81       	ldd	r25, Z+3	; 0x03
    5aec:	2b ea       	ldi	r18, 0xAB	; 171
    5aee:	3a ea       	ldi	r19, 0xAA	; 170
    5af0:	4a e2       	ldi	r20, 0x2A	; 42
    5af2:	51 e4       	ldi	r21, 0x41	; 65
    5af4:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5af8:	dc 01       	movw	r26, r24
    5afa:	cb 01       	movw	r24, r22
    5afc:	f8 01       	movw	r30, r16
    5afe:	80 83       	st	Z, r24
    5b00:	91 83       	std	Z+1, r25	; 0x01
    5b02:	a2 83       	std	Z+2, r26	; 0x02
    5b04:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5b06:	ce 01       	movw	r24, r28
    5b08:	82 5b       	subi	r24, 0xB2	; 178
    5b0a:	9f 4f       	sbci	r25, 0xFF	; 255
    5b0c:	11 e0       	ldi	r17, 0x01	; 1
    5b0e:	fc 01       	movw	r30, r24
    5b10:	60 81       	ld	r22, Z
    5b12:	71 81       	ldd	r23, Z+1	; 0x01
    5b14:	82 81       	ldd	r24, Z+2	; 0x02
    5b16:	93 81       	ldd	r25, Z+3	; 0x03
    5b18:	20 e0       	ldi	r18, 0x00	; 0
    5b1a:	30 e0       	ldi	r19, 0x00	; 0
    5b1c:	40 e8       	ldi	r20, 0x80	; 128
    5b1e:	5f e3       	ldi	r21, 0x3F	; 63
    5b20:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    5b24:	88 23       	and	r24, r24
    5b26:	0c f0       	brlt	.+2      	; 0x5b2a <chb_set_state+0x6f4>
    5b28:	10 e0       	ldi	r17, 0x00	; 0
    5b2a:	11 23       	and	r17, r17
    5b2c:	39 f0       	breq	.+14     	; 0x5b3c <chb_set_state+0x706>
		__ticks = 1;
    5b2e:	ce 01       	movw	r24, r28
    5b30:	8e 5a       	subi	r24, 0xAE	; 174
    5b32:	9f 4f       	sbci	r25, 0xFF	; 255
    5b34:	21 e0       	ldi	r18, 0x01	; 1
    5b36:	fc 01       	movw	r30, r24
    5b38:	20 83       	st	Z, r18
    5b3a:	05 c1       	rjmp	.+522    	; 0x5d46 <chb_set_state+0x910>
	else if (__tmp > 255)
    5b3c:	ce 01       	movw	r24, r28
    5b3e:	82 5b       	subi	r24, 0xB2	; 178
    5b40:	9f 4f       	sbci	r25, 0xFF	; 255
    5b42:	11 e0       	ldi	r17, 0x01	; 1
    5b44:	fc 01       	movw	r30, r24
    5b46:	60 81       	ld	r22, Z
    5b48:	71 81       	ldd	r23, Z+1	; 0x01
    5b4a:	82 81       	ldd	r24, Z+2	; 0x02
    5b4c:	93 81       	ldd	r25, Z+3	; 0x03
    5b4e:	20 e0       	ldi	r18, 0x00	; 0
    5b50:	30 e0       	ldi	r19, 0x00	; 0
    5b52:	4f e7       	ldi	r20, 0x7F	; 127
    5b54:	53 e4       	ldi	r21, 0x43	; 67
    5b56:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    5b5a:	18 16       	cp	r1, r24
    5b5c:	0c f0       	brlt	.+2      	; 0x5b60 <chb_set_state+0x72a>
    5b5e:	10 e0       	ldi	r17, 0x00	; 0
    5b60:	11 23       	and	r17, r17
    5b62:	09 f4       	brne	.+2      	; 0x5b66 <chb_set_state+0x730>
    5b64:	df c0       	rjmp	.+446    	; 0x5d24 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    5b66:	ce 01       	movw	r24, r28
    5b68:	86 5b       	subi	r24, 0xB6	; 182
    5b6a:	9f 4f       	sbci	r25, 0xFF	; 255
    5b6c:	fc 01       	movw	r30, r24
    5b6e:	60 81       	ld	r22, Z
    5b70:	71 81       	ldd	r23, Z+1	; 0x01
    5b72:	82 81       	ldd	r24, Z+2	; 0x02
    5b74:	93 81       	ldd	r25, Z+3	; 0x03
    5b76:	20 e0       	ldi	r18, 0x00	; 0
    5b78:	30 e0       	ldi	r19, 0x00	; 0
    5b7a:	4a e7       	ldi	r20, 0x7A	; 122
    5b7c:	54 e4       	ldi	r21, 0x44	; 68
    5b7e:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    5b82:	dc 01       	movw	r26, r24
    5b84:	cb 01       	movw	r24, r22
    5b86:	9e 01       	movw	r18, r28
    5b88:	2d 5a       	subi	r18, 0xAD	; 173
    5b8a:	3f 4f       	sbci	r19, 0xFF	; 255
    5b8c:	f9 01       	movw	r30, r18
    5b8e:	80 83       	st	Z, r24
    5b90:	91 83       	std	Z+1, r25	; 0x01
    5b92:	a2 83       	std	Z+2, r26	; 0x02
    5b94:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5b96:	8e 01       	movw	r16, r28
    5b98:	09 5a       	subi	r16, 0xA9	; 169
    5b9a:	1f 4f       	sbci	r17, 0xFF	; 255
    5b9c:	ce 01       	movw	r24, r28
    5b9e:	8d 5a       	subi	r24, 0xAD	; 173
    5ba0:	9f 4f       	sbci	r25, 0xFF	; 255
    5ba2:	fc 01       	movw	r30, r24
    5ba4:	60 81       	ld	r22, Z
    5ba6:	71 81       	ldd	r23, Z+1	; 0x01
    5ba8:	82 81       	ldd	r24, Z+2	; 0x02
    5baa:	93 81       	ldd	r25, Z+3	; 0x03
    5bac:	20 e0       	ldi	r18, 0x00	; 0
    5bae:	30 e0       	ldi	r19, 0x00	; 0
    5bb0:	4a ef       	ldi	r20, 0xFA	; 250
    5bb2:	55 e4       	ldi	r21, 0x45	; 69
    5bb4:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5bb8:	dc 01       	movw	r26, r24
    5bba:	cb 01       	movw	r24, r22
    5bbc:	f8 01       	movw	r30, r16
    5bbe:	80 83       	st	Z, r24
    5bc0:	91 83       	std	Z+1, r25	; 0x01
    5bc2:	a2 83       	std	Z+2, r26	; 0x02
    5bc4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5bc6:	ce 01       	movw	r24, r28
    5bc8:	89 5a       	subi	r24, 0xA9	; 169
    5bca:	9f 4f       	sbci	r25, 0xFF	; 255
    5bcc:	11 e0       	ldi	r17, 0x01	; 1
    5bce:	fc 01       	movw	r30, r24
    5bd0:	60 81       	ld	r22, Z
    5bd2:	71 81       	ldd	r23, Z+1	; 0x01
    5bd4:	82 81       	ldd	r24, Z+2	; 0x02
    5bd6:	93 81       	ldd	r25, Z+3	; 0x03
    5bd8:	20 e0       	ldi	r18, 0x00	; 0
    5bda:	30 e0       	ldi	r19, 0x00	; 0
    5bdc:	40 e8       	ldi	r20, 0x80	; 128
    5bde:	5f e3       	ldi	r21, 0x3F	; 63
    5be0:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    5be4:	88 23       	and	r24, r24
    5be6:	0c f0       	brlt	.+2      	; 0x5bea <chb_set_state+0x7b4>
    5be8:	10 e0       	ldi	r17, 0x00	; 0
    5bea:	11 23       	and	r17, r17
    5bec:	49 f0       	breq	.+18     	; 0x5c00 <chb_set_state+0x7ca>
		__ticks = 1;
    5bee:	ce 01       	movw	r24, r28
    5bf0:	85 5a       	subi	r24, 0xA5	; 165
    5bf2:	9f 4f       	sbci	r25, 0xFF	; 255
    5bf4:	21 e0       	ldi	r18, 0x01	; 1
    5bf6:	30 e0       	ldi	r19, 0x00	; 0
    5bf8:	fc 01       	movw	r30, r24
    5bfa:	20 83       	st	Z, r18
    5bfc:	31 83       	std	Z+1, r19	; 0x01
    5bfe:	74 c0       	rjmp	.+232    	; 0x5ce8 <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    5c00:	ce 01       	movw	r24, r28
    5c02:	89 5a       	subi	r24, 0xA9	; 169
    5c04:	9f 4f       	sbci	r25, 0xFF	; 255
    5c06:	11 e0       	ldi	r17, 0x01	; 1
    5c08:	fc 01       	movw	r30, r24
    5c0a:	60 81       	ld	r22, Z
    5c0c:	71 81       	ldd	r23, Z+1	; 0x01
    5c0e:	82 81       	ldd	r24, Z+2	; 0x02
    5c10:	93 81       	ldd	r25, Z+3	; 0x03
    5c12:	20 e0       	ldi	r18, 0x00	; 0
    5c14:	3f ef       	ldi	r19, 0xFF	; 255
    5c16:	4f e7       	ldi	r20, 0x7F	; 127
    5c18:	57 e4       	ldi	r21, 0x47	; 71
    5c1a:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    5c1e:	18 16       	cp	r1, r24
    5c20:	0c f0       	brlt	.+2      	; 0x5c24 <chb_set_state+0x7ee>
    5c22:	10 e0       	ldi	r17, 0x00	; 0
    5c24:	11 23       	and	r17, r17
    5c26:	09 f4       	brne	.+2      	; 0x5c2a <chb_set_state+0x7f4>
    5c28:	4d c0       	rjmp	.+154    	; 0x5cc4 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5c2a:	ce 01       	movw	r24, r28
    5c2c:	8d 5a       	subi	r24, 0xAD	; 173
    5c2e:	9f 4f       	sbci	r25, 0xFF	; 255
    5c30:	fc 01       	movw	r30, r24
    5c32:	60 81       	ld	r22, Z
    5c34:	71 81       	ldd	r23, Z+1	; 0x01
    5c36:	82 81       	ldd	r24, Z+2	; 0x02
    5c38:	93 81       	ldd	r25, Z+3	; 0x03
    5c3a:	20 e0       	ldi	r18, 0x00	; 0
    5c3c:	30 e0       	ldi	r19, 0x00	; 0
    5c3e:	40 e2       	ldi	r20, 0x20	; 32
    5c40:	51 e4       	ldi	r21, 0x41	; 65
    5c42:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5c46:	dc 01       	movw	r26, r24
    5c48:	cb 01       	movw	r24, r22
    5c4a:	8e 01       	movw	r16, r28
    5c4c:	05 5a       	subi	r16, 0xA5	; 165
    5c4e:	1f 4f       	sbci	r17, 0xFF	; 255
    5c50:	bc 01       	movw	r22, r24
    5c52:	cd 01       	movw	r24, r26
    5c54:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5c58:	dc 01       	movw	r26, r24
    5c5a:	cb 01       	movw	r24, r22
    5c5c:	f8 01       	movw	r30, r16
    5c5e:	80 83       	st	Z, r24
    5c60:	91 83       	std	Z+1, r25	; 0x01
    5c62:	27 c0       	rjmp	.+78     	; 0x5cb2 <chb_set_state+0x87c>
    5c64:	ce 01       	movw	r24, r28
    5c66:	83 5a       	subi	r24, 0xA3	; 163
    5c68:	9f 4f       	sbci	r25, 0xFF	; 255
    5c6a:	20 e2       	ldi	r18, 0x20	; 32
    5c6c:	33 e0       	ldi	r19, 0x03	; 3
    5c6e:	fc 01       	movw	r30, r24
    5c70:	20 83       	st	Z, r18
    5c72:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5c74:	ce 01       	movw	r24, r28
    5c76:	83 5a       	subi	r24, 0xA3	; 163
    5c78:	9f 4f       	sbci	r25, 0xFF	; 255
    5c7a:	fc 01       	movw	r30, r24
    5c7c:	80 81       	ld	r24, Z
    5c7e:	91 81       	ldd	r25, Z+1	; 0x01
    5c80:	8c 01       	movw	r16, r24
    5c82:	c8 01       	movw	r24, r16
    5c84:	01 97       	sbiw	r24, 0x01	; 1
    5c86:	f1 f7       	brne	.-4      	; 0x5c84 <chb_set_state+0x84e>
    5c88:	8c 01       	movw	r16, r24
    5c8a:	ce 01       	movw	r24, r28
    5c8c:	83 5a       	subi	r24, 0xA3	; 163
    5c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    5c90:	fc 01       	movw	r30, r24
    5c92:	00 83       	st	Z, r16
    5c94:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5c96:	ce 01       	movw	r24, r28
    5c98:	85 5a       	subi	r24, 0xA5	; 165
    5c9a:	9f 4f       	sbci	r25, 0xFF	; 255
    5c9c:	9e 01       	movw	r18, r28
    5c9e:	25 5a       	subi	r18, 0xA5	; 165
    5ca0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ca2:	f9 01       	movw	r30, r18
    5ca4:	20 81       	ld	r18, Z
    5ca6:	31 81       	ldd	r19, Z+1	; 0x01
    5ca8:	21 50       	subi	r18, 0x01	; 1
    5caa:	30 40       	sbci	r19, 0x00	; 0
    5cac:	fc 01       	movw	r30, r24
    5cae:	20 83       	st	Z, r18
    5cb0:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5cb2:	ce 01       	movw	r24, r28
    5cb4:	85 5a       	subi	r24, 0xA5	; 165
    5cb6:	9f 4f       	sbci	r25, 0xFF	; 255
    5cb8:	fc 01       	movw	r30, r24
    5cba:	80 81       	ld	r24, Z
    5cbc:	91 81       	ldd	r25, Z+1	; 0x01
    5cbe:	00 97       	sbiw	r24, 0x00	; 0
    5cc0:	89 f6       	brne	.-94     	; 0x5c64 <chb_set_state+0x82e>
    5cc2:	58 c0       	rjmp	.+176    	; 0x5d74 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5cc4:	8e 01       	movw	r16, r28
    5cc6:	05 5a       	subi	r16, 0xA5	; 165
    5cc8:	1f 4f       	sbci	r17, 0xFF	; 255
    5cca:	ce 01       	movw	r24, r28
    5ccc:	89 5a       	subi	r24, 0xA9	; 169
    5cce:	9f 4f       	sbci	r25, 0xFF	; 255
    5cd0:	fc 01       	movw	r30, r24
    5cd2:	60 81       	ld	r22, Z
    5cd4:	71 81       	ldd	r23, Z+1	; 0x01
    5cd6:	82 81       	ldd	r24, Z+2	; 0x02
    5cd8:	93 81       	ldd	r25, Z+3	; 0x03
    5cda:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5cde:	dc 01       	movw	r26, r24
    5ce0:	cb 01       	movw	r24, r22
    5ce2:	f8 01       	movw	r30, r16
    5ce4:	80 83       	st	Z, r24
    5ce6:	91 83       	std	Z+1, r25	; 0x01
    5ce8:	ce 01       	movw	r24, r28
    5cea:	81 5a       	subi	r24, 0xA1	; 161
    5cec:	9f 4f       	sbci	r25, 0xFF	; 255
    5cee:	9e 01       	movw	r18, r28
    5cf0:	25 5a       	subi	r18, 0xA5	; 165
    5cf2:	3f 4f       	sbci	r19, 0xFF	; 255
    5cf4:	f9 01       	movw	r30, r18
    5cf6:	20 81       	ld	r18, Z
    5cf8:	31 81       	ldd	r19, Z+1	; 0x01
    5cfa:	fc 01       	movw	r30, r24
    5cfc:	20 83       	st	Z, r18
    5cfe:	31 83       	std	Z+1, r19	; 0x01
    5d00:	ce 01       	movw	r24, r28
    5d02:	81 5a       	subi	r24, 0xA1	; 161
    5d04:	9f 4f       	sbci	r25, 0xFF	; 255
    5d06:	fc 01       	movw	r30, r24
    5d08:	80 81       	ld	r24, Z
    5d0a:	91 81       	ldd	r25, Z+1	; 0x01
    5d0c:	8c 01       	movw	r16, r24
    5d0e:	c8 01       	movw	r24, r16
    5d10:	01 97       	sbiw	r24, 0x01	; 1
    5d12:	f1 f7       	brne	.-4      	; 0x5d10 <chb_set_state+0x8da>
    5d14:	8c 01       	movw	r16, r24
    5d16:	ce 01       	movw	r24, r28
    5d18:	81 5a       	subi	r24, 0xA1	; 161
    5d1a:	9f 4f       	sbci	r25, 0xFF	; 255
    5d1c:	fc 01       	movw	r30, r24
    5d1e:	00 83       	st	Z, r16
    5d20:	11 83       	std	Z+1, r17	; 0x01
    5d22:	28 c0       	rjmp	.+80     	; 0x5d74 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5d24:	8e 01       	movw	r16, r28
    5d26:	0e 5a       	subi	r16, 0xAE	; 174
    5d28:	1f 4f       	sbci	r17, 0xFF	; 255
    5d2a:	ce 01       	movw	r24, r28
    5d2c:	82 5b       	subi	r24, 0xB2	; 178
    5d2e:	9f 4f       	sbci	r25, 0xFF	; 255
    5d30:	fc 01       	movw	r30, r24
    5d32:	60 81       	ld	r22, Z
    5d34:	71 81       	ldd	r23, Z+1	; 0x01
    5d36:	82 81       	ldd	r24, Z+2	; 0x02
    5d38:	93 81       	ldd	r25, Z+3	; 0x03
    5d3a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    5d3e:	dc 01       	movw	r26, r24
    5d40:	cb 01       	movw	r24, r22
    5d42:	f8 01       	movw	r30, r16
    5d44:	80 83       	st	Z, r24
    5d46:	ce 01       	movw	r24, r28
    5d48:	8f 59       	subi	r24, 0x9F	; 159
    5d4a:	9f 4f       	sbci	r25, 0xFF	; 255
    5d4c:	9e 01       	movw	r18, r28
    5d4e:	2e 5a       	subi	r18, 0xAE	; 174
    5d50:	3f 4f       	sbci	r19, 0xFF	; 255
    5d52:	f9 01       	movw	r30, r18
    5d54:	20 81       	ld	r18, Z
    5d56:	fc 01       	movw	r30, r24
    5d58:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5d5a:	ce 01       	movw	r24, r28
    5d5c:	8f 59       	subi	r24, 0x9F	; 159
    5d5e:	9f 4f       	sbci	r25, 0xFF	; 255
    5d60:	fc 01       	movw	r30, r24
    5d62:	80 81       	ld	r24, Z
    5d64:	18 2f       	mov	r17, r24
    5d66:	1a 95       	dec	r17
    5d68:	f1 f7       	brne	.-4      	; 0x5d66 <chb_set_state+0x930>
    5d6a:	ce 01       	movw	r24, r28
    5d6c:	8f 59       	subi	r24, 0x9F	; 159
    5d6e:	9f 4f       	sbci	r25, 0xFF	; 255
    5d70:	fc 01       	movw	r30, r24
    5d72:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5d74:	0e 94 c3 24 	call	0x4986	; 0x4986 <chb_get_state>
    5d78:	28 2f       	mov	r18, r24
    5d7a:	ce 01       	movw	r24, r28
    5d7c:	8e 59       	subi	r24, 0x9E	; 158
    5d7e:	9f 4f       	sbci	r25, 0xFF	; 255
    5d80:	fc 01       	movw	r30, r24
    5d82:	80 81       	ld	r24, Z
    5d84:	28 17       	cp	r18, r24
    5d86:	11 f4       	brne	.+4      	; 0x5d8c <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5d88:	80 e4       	ldi	r24, 0x40	; 64
    5d8a:	01 c0       	rjmp	.+2      	; 0x5d8e <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    5d8c:	83 e4       	ldi	r24, 0x43	; 67
}
    5d8e:	ce 59       	subi	r28, 0x9E	; 158
    5d90:	df 4f       	sbci	r29, 0xFF	; 255
    5d92:	cd bf       	out	0x3d, r28	; 61
    5d94:	de bf       	out	0x3e, r29	; 62
    5d96:	df 91       	pop	r29
    5d98:	cf 91       	pop	r28
    5d9a:	1f 91       	pop	r17
    5d9c:	0f 91       	pop	r16
    5d9e:	08 95       	ret

00005da0 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5da0:	cf 93       	push	r28
    5da2:	df 93       	push	r29
    5da4:	0f 92       	push	r0
    5da6:	0f 92       	push	r0
    5da8:	cd b7       	in	r28, 0x3d	; 61
    5daa:	de b7       	in	r29, 0x3e	; 62
    5dac:	89 83       	std	Y+1, r24	; 0x01
    5dae:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5db0:	29 81       	ldd	r18, Y+1	; 0x01
    5db2:	3a 81       	ldd	r19, Y+2	; 0x02
    5db4:	80 e0       	ldi	r24, 0x00	; 0
    5db6:	90 e0       	ldi	r25, 0x00	; 0
    5db8:	b9 01       	movw	r22, r18
    5dba:	48 e0       	ldi	r20, 0x08	; 8
    5dbc:	50 e0       	ldi	r21, 0x00	; 0
    5dbe:	0e 94 e6 32 	call	0x65cc	; 0x65cc <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5dc2:	29 81       	ldd	r18, Y+1	; 0x01
    5dc4:	3a 81       	ldd	r19, Y+2	; 0x02
    5dc6:	84 e2       	ldi	r24, 0x24	; 36
    5dc8:	b9 01       	movw	r22, r18
    5dca:	0e 94 82 27 	call	0x4f04	; 0x4f04 <chb_reg_write64>
}
    5dce:	0f 90       	pop	r0
    5dd0:	0f 90       	pop	r0
    5dd2:	df 91       	pop	r29
    5dd4:	cf 91       	pop	r28
    5dd6:	08 95       	ret

00005dd8 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5dd8:	cf 93       	push	r28
    5dda:	df 93       	push	r29
    5ddc:	0f 92       	push	r0
    5dde:	0f 92       	push	r0
    5de0:	cd b7       	in	r28, 0x3d	; 61
    5de2:	de b7       	in	r29, 0x3e	; 62
    5de4:	89 83       	std	Y+1, r24	; 0x01
    5de6:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5de8:	29 81       	ldd	r18, Y+1	; 0x01
    5dea:	3a 81       	ldd	r19, Y+2	; 0x02
    5dec:	80 e0       	ldi	r24, 0x00	; 0
    5dee:	90 e0       	ldi	r25, 0x00	; 0
    5df0:	b9 01       	movw	r22, r18
    5df2:	48 e0       	ldi	r20, 0x08	; 8
    5df4:	50 e0       	ldi	r21, 0x00	; 0
    5df6:	0e 94 22 33 	call	0x6644	; 0x6644 <chb_eeprom_read>
}
    5dfa:	0f 90       	pop	r0
    5dfc:	0f 90       	pop	r0
    5dfe:	df 91       	pop	r29
    5e00:	cf 91       	pop	r28
    5e02:	08 95       	ret

00005e04 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5e04:	cf 93       	push	r28
    5e06:	df 93       	push	r29
    5e08:	00 d0       	rcall	.+0      	; 0x5e0a <chb_set_short_addr+0x6>
    5e0a:	00 d0       	rcall	.+0      	; 0x5e0c <chb_set_short_addr+0x8>
    5e0c:	cd b7       	in	r28, 0x3d	; 61
    5e0e:	de b7       	in	r29, 0x3e	; 62
    5e10:	8d 83       	std	Y+5, r24	; 0x05
    5e12:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5e14:	ce 01       	movw	r24, r28
    5e16:	05 96       	adiw	r24, 0x05	; 5
    5e18:	89 83       	std	Y+1, r24	; 0x01
    5e1a:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    5e1c:	0e 94 9e 22 	call	0x453c	; 0x453c <chb_get_pcb>
    5e20:	8b 83       	std	Y+3, r24	; 0x03
    5e22:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5e24:	29 81       	ldd	r18, Y+1	; 0x01
    5e26:	3a 81       	ldd	r19, Y+2	; 0x02
    5e28:	89 e0       	ldi	r24, 0x09	; 9
    5e2a:	90 e0       	ldi	r25, 0x00	; 0
    5e2c:	b9 01       	movw	r22, r18
    5e2e:	42 e0       	ldi	r20, 0x02	; 2
    5e30:	50 e0       	ldi	r21, 0x00	; 0
    5e32:	0e 94 e6 32 	call	0x65cc	; 0x65cc <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    5e36:	2d 81       	ldd	r18, Y+5	; 0x05
    5e38:	3e 81       	ldd	r19, Y+6	; 0x06
    5e3a:	80 e2       	ldi	r24, 0x20	; 32
    5e3c:	b9 01       	movw	r22, r18
    5e3e:	0e 94 51 27 	call	0x4ea2	; 0x4ea2 <chb_reg_write16>
    pcb->src_addr = addr;
    5e42:	2d 81       	ldd	r18, Y+5	; 0x05
    5e44:	3e 81       	ldd	r19, Y+6	; 0x06
    5e46:	8b 81       	ldd	r24, Y+3	; 0x03
    5e48:	9c 81       	ldd	r25, Y+4	; 0x04
    5e4a:	fc 01       	movw	r30, r24
    5e4c:	20 83       	st	Z, r18
    5e4e:	31 83       	std	Z+1, r19	; 0x01
}
    5e50:	26 96       	adiw	r28, 0x06	; 6
    5e52:	cd bf       	out	0x3d, r28	; 61
    5e54:	de bf       	out	0x3e, r29	; 62
    5e56:	df 91       	pop	r29
    5e58:	cf 91       	pop	r28
    5e5a:	08 95       	ret

00005e5c <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    5e5c:	cf 93       	push	r28
    5e5e:	df 93       	push	r29
    5e60:	0f 92       	push	r0
    5e62:	0f 92       	push	r0
    5e64:	cd b7       	in	r28, 0x3d	; 61
    5e66:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    5e68:	89 e0       	ldi	r24, 0x09	; 9
    5e6a:	90 e0       	ldi	r25, 0x00	; 0
    5e6c:	9e 01       	movw	r18, r28
    5e6e:	2f 5f       	subi	r18, 0xFF	; 255
    5e70:	3f 4f       	sbci	r19, 0xFF	; 255
    5e72:	b9 01       	movw	r22, r18
    5e74:	42 e0       	ldi	r20, 0x02	; 2
    5e76:	50 e0       	ldi	r21, 0x00	; 0
    5e78:	0e 94 22 33 	call	0x6644	; 0x6644 <chb_eeprom_read>
    return *(U16 *)addr;
    5e7c:	ce 01       	movw	r24, r28
    5e7e:	01 96       	adiw	r24, 0x01	; 1
    5e80:	fc 01       	movw	r30, r24
    5e82:	80 81       	ld	r24, Z
    5e84:	91 81       	ldd	r25, Z+1	; 0x01
}
    5e86:	0f 90       	pop	r0
    5e88:	0f 90       	pop	r0
    5e8a:	df 91       	pop	r29
    5e8c:	cf 91       	pop	r28
    5e8e:	08 95       	ret

00005e90 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5e90:	cf 93       	push	r28
    5e92:	df 93       	push	r29
    5e94:	cd b7       	in	r28, 0x3d	; 61
    5e96:	de b7       	in	r29, 0x3e	; 62
    5e98:	28 97       	sbiw	r28, 0x08	; 8
    5e9a:	cd bf       	out	0x3d, r28	; 61
    5e9c:	de bf       	out	0x3e, r29	; 62
    5e9e:	8c 83       	std	Y+4, r24	; 0x04
    5ea0:	9d 83       	std	Y+5, r25	; 0x05
    5ea2:	6e 83       	std	Y+6, r22	; 0x06
    5ea4:	7f 83       	std	Y+7, r23	; 0x07
    5ea6:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5ea8:	0e 94 c3 24 	call	0x4986	; 0x4986 <chb_get_state>
    5eac:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5eae:	0e 94 9e 22 	call	0x453c	; 0x453c <chb_get_pcb>
    5eb2:	8a 83       	std	Y+2, r24	; 0x02
    5eb4:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5eb6:	89 81       	ldd	r24, Y+1	; 0x01
    5eb8:	82 30       	cpi	r24, 0x02	; 2
    5eba:	19 f0       	breq	.+6      	; 0x5ec2 <chb_tx+0x32>
    5ebc:	89 81       	ldd	r24, Y+1	; 0x01
    5ebe:	82 31       	cpi	r24, 0x12	; 18
    5ec0:	11 f4       	brne	.+4      	; 0x5ec6 <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5ec2:	84 e4       	ldi	r24, 0x44	; 68
    5ec4:	23 c0       	rjmp	.+70     	; 0x5f0c <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5ec6:	88 e0       	ldi	r24, 0x08	; 8
    5ec8:	0e 94 1b 2a 	call	0x5436	; 0x5436 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    5ecc:	89 e1       	ldi	r24, 0x19	; 25
    5ece:	0e 94 1b 2a 	call	0x5436	; 0x5436 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    5ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    5ed6:	2e 81       	ldd	r18, Y+6	; 0x06
    5ed8:	3f 81       	ldd	r19, Y+7	; 0x07
    5eda:	6a e0       	ldi	r22, 0x0A	; 10
    5edc:	a9 01       	movw	r20, r18
    5ede:	28 85       	ldd	r18, Y+8	; 0x08
    5ee0:	0e 94 cf 27 	call	0x4f9e	; 0x4f9e <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5ee4:	82 e0       	ldi	r24, 0x02	; 2
    5ee6:	62 e0       	ldi	r22, 0x02	; 2
    5ee8:	4f e1       	ldi	r20, 0x1F	; 31
    5eea:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    5eee:	00 00       	nop
    5ef0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ef2:	9b 81       	ldd	r25, Y+3	; 0x03
    5ef4:	fc 01       	movw	r30, r24
    5ef6:	94 81       	ldd	r25, Z+4	; 0x04
    5ef8:	81 e0       	ldi	r24, 0x01	; 1
    5efa:	89 27       	eor	r24, r25
    5efc:	88 23       	and	r24, r24
    5efe:	c1 f7       	brne	.-16     	; 0x5ef0 <chb_tx+0x60>
    pcb->tx_end = false;
    5f00:	8a 81       	ldd	r24, Y+2	; 0x02
    5f02:	9b 81       	ldd	r25, Y+3	; 0x03
    5f04:	fc 01       	movw	r30, r24
    5f06:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5f08:	0e 94 ce 24 	call	0x499c	; 0x499c <chb_get_status>
}
    5f0c:	28 96       	adiw	r28, 0x08	; 8
    5f0e:	cd bf       	out	0x3d, r28	; 61
    5f10:	de bf       	out	0x3e, r29	; 62
    5f12:	df 91       	pop	r29
    5f14:	cf 91       	pop	r28
    5f16:	08 95       	ret

00005f18 <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5f18:	0f 93       	push	r16
    5f1a:	1f 93       	push	r17
    5f1c:	cf 93       	push	r28
    5f1e:	df 93       	push	r29
    5f20:	cd b7       	in	r28, 0x3d	; 61
    5f22:	de b7       	in	r29, 0x3e	; 62
    5f24:	69 97       	sbiw	r28, 0x19	; 25
    5f26:	cd bf       	out	0x3d, r28	; 61
    5f28:	de bf       	out	0x3e, r29	; 62
    5f2a:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    5f2c:	89 8d       	ldd	r24, Y+25	; 0x19
    5f2e:	88 23       	and	r24, r24
    5f30:	69 f0       	breq	.+26     	; 0x5f4c <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5f32:	88 e0       	ldi	r24, 0x08	; 8
    5f34:	0e 94 1b 2a 	call	0x5436	; 0x5436 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5f38:	84 e6       	ldi	r24, 0x64	; 100
    5f3a:	96 e0       	ldi	r25, 0x06	; 6
    5f3c:	24 e6       	ldi	r18, 0x64	; 100
    5f3e:	36 e0       	ldi	r19, 0x06	; 6
    5f40:	f9 01       	movw	r30, r18
    5f42:	20 81       	ld	r18, Z
    5f44:	22 60       	ori	r18, 0x02	; 2
    5f46:	fc 01       	movw	r30, r24
    5f48:	20 83       	st	Z, r18
    5f4a:	e1 c0       	rjmp	.+450    	; 0x610e <__stack+0x10f>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    5f4c:	84 e6       	ldi	r24, 0x64	; 100
    5f4e:	96 e0       	ldi	r25, 0x06	; 6
    5f50:	24 e6       	ldi	r18, 0x64	; 100
    5f52:	36 e0       	ldi	r19, 0x06	; 6
    5f54:	f9 01       	movw	r30, r18
    5f56:	20 81       	ld	r18, Z
    5f58:	2d 7f       	andi	r18, 0xFD	; 253
    5f5a:	fc 01       	movw	r30, r24
    5f5c:	20 83       	st	Z, r18
    5f5e:	80 e0       	ldi	r24, 0x00	; 0
    5f60:	90 e0       	ldi	r25, 0x00	; 0
    5f62:	a0 e7       	ldi	r26, 0x70	; 112
    5f64:	b3 e4       	ldi	r27, 0x43	; 67
    5f66:	89 83       	std	Y+1, r24	; 0x01
    5f68:	9a 83       	std	Y+2, r25	; 0x02
    5f6a:	ab 83       	std	Y+3, r26	; 0x03
    5f6c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5f6e:	69 81       	ldd	r22, Y+1	; 0x01
    5f70:	7a 81       	ldd	r23, Y+2	; 0x02
    5f72:	8b 81       	ldd	r24, Y+3	; 0x03
    5f74:	9c 81       	ldd	r25, Y+4	; 0x04
    5f76:	2b ea       	ldi	r18, 0xAB	; 171
    5f78:	3a ea       	ldi	r19, 0xAA	; 170
    5f7a:	4a e2       	ldi	r20, 0x2A	; 42
    5f7c:	51 e4       	ldi	r21, 0x41	; 65
    5f7e:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    5f82:	dc 01       	movw	r26, r24
    5f84:	cb 01       	movw	r24, r22
    5f86:	8d 83       	std	Y+5, r24	; 0x05
    5f88:	9e 83       	std	Y+6, r25	; 0x06
    5f8a:	af 83       	std	Y+7, r26	; 0x07
    5f8c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5f8e:	11 e0       	ldi	r17, 0x01	; 1
    5f90:	6d 81       	ldd	r22, Y+5	; 0x05
    5f92:	7e 81       	ldd	r23, Y+6	; 0x06
    5f94:	8f 81       	ldd	r24, Y+7	; 0x07
    5f96:	98 85       	ldd	r25, Y+8	; 0x08
    5f98:	20 e0       	ldi	r18, 0x00	; 0
    5f9a:	30 e0       	ldi	r19, 0x00	; 0
    5f9c:	40 e8       	ldi	r20, 0x80	; 128
    5f9e:	5f e3       	ldi	r21, 0x3F	; 63
    5fa0:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    5fa4:	88 23       	and	r24, r24
    5fa6:	0c f0       	brlt	.+2      	; 0x5faa <chb_sleep+0x92>
    5fa8:	10 e0       	ldi	r17, 0x00	; 0
    5faa:	11 23       	and	r17, r17
    5fac:	19 f0       	breq	.+6      	; 0x5fb4 <chb_sleep+0x9c>
		__ticks = 1;
    5fae:	81 e0       	ldi	r24, 0x01	; 1
    5fb0:	89 87       	std	Y+9, r24	; 0x09
    5fb2:	a3 c0       	rjmp	.+326    	; 0x60fa <__stack+0xfb>
	else if (__tmp > 255)
    5fb4:	11 e0       	ldi	r17, 0x01	; 1
    5fb6:	6d 81       	ldd	r22, Y+5	; 0x05
    5fb8:	7e 81       	ldd	r23, Y+6	; 0x06
    5fba:	8f 81       	ldd	r24, Y+7	; 0x07
    5fbc:	98 85       	ldd	r25, Y+8	; 0x08
    5fbe:	20 e0       	ldi	r18, 0x00	; 0
    5fc0:	30 e0       	ldi	r19, 0x00	; 0
    5fc2:	4f e7       	ldi	r20, 0x7F	; 127
    5fc4:	53 e4       	ldi	r21, 0x43	; 67
    5fc6:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    5fca:	18 16       	cp	r1, r24
    5fcc:	0c f0       	brlt	.+2      	; 0x5fd0 <chb_sleep+0xb8>
    5fce:	10 e0       	ldi	r17, 0x00	; 0
    5fd0:	11 23       	and	r17, r17
    5fd2:	09 f4       	brne	.+2      	; 0x5fd6 <chb_sleep+0xbe>
    5fd4:	89 c0       	rjmp	.+274    	; 0x60e8 <__stack+0xe9>
	{
		_delay_ms(__us / 1000.0);
    5fd6:	69 81       	ldd	r22, Y+1	; 0x01
    5fd8:	7a 81       	ldd	r23, Y+2	; 0x02
    5fda:	8b 81       	ldd	r24, Y+3	; 0x03
    5fdc:	9c 81       	ldd	r25, Y+4	; 0x04
    5fde:	20 e0       	ldi	r18, 0x00	; 0
    5fe0:	30 e0       	ldi	r19, 0x00	; 0
    5fe2:	4a e7       	ldi	r20, 0x7A	; 122
    5fe4:	54 e4       	ldi	r21, 0x44	; 68
    5fe6:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    5fea:	dc 01       	movw	r26, r24
    5fec:	cb 01       	movw	r24, r22
    5fee:	8a 87       	std	Y+10, r24	; 0x0a
    5ff0:	9b 87       	std	Y+11, r25	; 0x0b
    5ff2:	ac 87       	std	Y+12, r26	; 0x0c
    5ff4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5ff6:	6a 85       	ldd	r22, Y+10	; 0x0a
    5ff8:	7b 85       	ldd	r23, Y+11	; 0x0b
    5ffa:	8c 85       	ldd	r24, Y+12	; 0x0c
    5ffc:	9d 85       	ldd	r25, Y+13	; 0x0d
    5ffe:	20 e0       	ldi	r18, 0x00	; 0
    6000:	30 e0       	ldi	r19, 0x00	; 0
    6002:	4a ef       	ldi	r20, 0xFA	; 250
    6004:	55 e4       	ldi	r21, 0x45	; 69
    6006:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    600a:	dc 01       	movw	r26, r24
    600c:	cb 01       	movw	r24, r22
    600e:	8e 87       	std	Y+14, r24	; 0x0e
    6010:	9f 87       	std	Y+15, r25	; 0x0f
    6012:	a8 8b       	std	Y+16, r26	; 0x10
    6014:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    6016:	11 e0       	ldi	r17, 0x01	; 1
    6018:	6e 85       	ldd	r22, Y+14	; 0x0e
    601a:	7f 85       	ldd	r23, Y+15	; 0x0f
    601c:	88 89       	ldd	r24, Y+16	; 0x10
    601e:	99 89       	ldd	r25, Y+17	; 0x11
    6020:	20 e0       	ldi	r18, 0x00	; 0
    6022:	30 e0       	ldi	r19, 0x00	; 0
    6024:	40 e8       	ldi	r20, 0x80	; 128
    6026:	5f e3       	ldi	r21, 0x3F	; 63
    6028:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    602c:	88 23       	and	r24, r24
    602e:	0c f0       	brlt	.+2      	; 0x6032 <__stack+0x33>
    6030:	10 e0       	ldi	r17, 0x00	; 0
    6032:	11 23       	and	r17, r17
    6034:	29 f0       	breq	.+10     	; 0x6040 <__stack+0x41>
		__ticks = 1;
    6036:	81 e0       	ldi	r24, 0x01	; 1
    6038:	90 e0       	ldi	r25, 0x00	; 0
    603a:	8a 8b       	std	Y+18, r24	; 0x12
    603c:	9b 8b       	std	Y+19, r25	; 0x13
    603e:	46 c0       	rjmp	.+140    	; 0x60cc <__stack+0xcd>
	else if (__tmp > 65535)
    6040:	11 e0       	ldi	r17, 0x01	; 1
    6042:	6e 85       	ldd	r22, Y+14	; 0x0e
    6044:	7f 85       	ldd	r23, Y+15	; 0x0f
    6046:	88 89       	ldd	r24, Y+16	; 0x10
    6048:	99 89       	ldd	r25, Y+17	; 0x11
    604a:	20 e0       	ldi	r18, 0x00	; 0
    604c:	3f ef       	ldi	r19, 0xFF	; 255
    604e:	4f e7       	ldi	r20, 0x7F	; 127
    6050:	57 e4       	ldi	r21, 0x47	; 71
    6052:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    6056:	18 16       	cp	r1, r24
    6058:	0c f0       	brlt	.+2      	; 0x605c <__stack+0x5d>
    605a:	10 e0       	ldi	r17, 0x00	; 0
    605c:	11 23       	and	r17, r17
    605e:	61 f1       	breq	.+88     	; 0x60b8 <__stack+0xb9>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6060:	6a 85       	ldd	r22, Y+10	; 0x0a
    6062:	7b 85       	ldd	r23, Y+11	; 0x0b
    6064:	8c 85       	ldd	r24, Y+12	; 0x0c
    6066:	9d 85       	ldd	r25, Y+13	; 0x0d
    6068:	20 e0       	ldi	r18, 0x00	; 0
    606a:	30 e0       	ldi	r19, 0x00	; 0
    606c:	40 e2       	ldi	r20, 0x20	; 32
    606e:	51 e4       	ldi	r21, 0x41	; 65
    6070:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    6074:	dc 01       	movw	r26, r24
    6076:	cb 01       	movw	r24, r22
    6078:	bc 01       	movw	r22, r24
    607a:	cd 01       	movw	r24, r26
    607c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    6080:	dc 01       	movw	r26, r24
    6082:	cb 01       	movw	r24, r22
    6084:	8a 8b       	std	Y+18, r24	; 0x12
    6086:	9b 8b       	std	Y+19, r25	; 0x13
    6088:	12 c0       	rjmp	.+36     	; 0x60ae <__stack+0xaf>
    608a:	80 e2       	ldi	r24, 0x20	; 32
    608c:	93 e0       	ldi	r25, 0x03	; 3
    608e:	8c 8b       	std	Y+20, r24	; 0x14
    6090:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6092:	8c 89       	ldd	r24, Y+20	; 0x14
    6094:	9d 89       	ldd	r25, Y+21	; 0x15
    6096:	8c 01       	movw	r16, r24
    6098:	c8 01       	movw	r24, r16
    609a:	01 97       	sbiw	r24, 0x01	; 1
    609c:	f1 f7       	brne	.-4      	; 0x609a <__stack+0x9b>
    609e:	8c 01       	movw	r16, r24
    60a0:	0c 8b       	std	Y+20, r16	; 0x14
    60a2:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    60a4:	8a 89       	ldd	r24, Y+18	; 0x12
    60a6:	9b 89       	ldd	r25, Y+19	; 0x13
    60a8:	01 97       	sbiw	r24, 0x01	; 1
    60aa:	8a 8b       	std	Y+18, r24	; 0x12
    60ac:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    60ae:	8a 89       	ldd	r24, Y+18	; 0x12
    60b0:	9b 89       	ldd	r25, Y+19	; 0x13
    60b2:	00 97       	sbiw	r24, 0x00	; 0
    60b4:	51 f7       	brne	.-44     	; 0x608a <__stack+0x8b>
    60b6:	28 c0       	rjmp	.+80     	; 0x6108 <__stack+0x109>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    60b8:	6e 85       	ldd	r22, Y+14	; 0x0e
    60ba:	7f 85       	ldd	r23, Y+15	; 0x0f
    60bc:	88 89       	ldd	r24, Y+16	; 0x10
    60be:	99 89       	ldd	r25, Y+17	; 0x11
    60c0:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    60c4:	dc 01       	movw	r26, r24
    60c6:	cb 01       	movw	r24, r22
    60c8:	8a 8b       	std	Y+18, r24	; 0x12
    60ca:	9b 8b       	std	Y+19, r25	; 0x13
    60cc:	8a 89       	ldd	r24, Y+18	; 0x12
    60ce:	9b 89       	ldd	r25, Y+19	; 0x13
    60d0:	8e 8b       	std	Y+22, r24	; 0x16
    60d2:	9f 8b       	std	Y+23, r25	; 0x17
    60d4:	8e 89       	ldd	r24, Y+22	; 0x16
    60d6:	9f 89       	ldd	r25, Y+23	; 0x17
    60d8:	8c 01       	movw	r16, r24
    60da:	f8 01       	movw	r30, r16
    60dc:	31 97       	sbiw	r30, 0x01	; 1
    60de:	f1 f7       	brne	.-4      	; 0x60dc <__stack+0xdd>
    60e0:	8f 01       	movw	r16, r30
    60e2:	0e 8b       	std	Y+22, r16	; 0x16
    60e4:	1f 8b       	std	Y+23, r17	; 0x17
    60e6:	10 c0       	rjmp	.+32     	; 0x6108 <__stack+0x109>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    60e8:	6d 81       	ldd	r22, Y+5	; 0x05
    60ea:	7e 81       	ldd	r23, Y+6	; 0x06
    60ec:	8f 81       	ldd	r24, Y+7	; 0x07
    60ee:	98 85       	ldd	r25, Y+8	; 0x08
    60f0:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    60f4:	dc 01       	movw	r26, r24
    60f6:	cb 01       	movw	r24, r22
    60f8:	89 87       	std	Y+9, r24	; 0x09
    60fa:	89 85       	ldd	r24, Y+9	; 0x09
    60fc:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    60fe:	88 8d       	ldd	r24, Y+24	; 0x18
    6100:	18 2f       	mov	r17, r24
    6102:	1a 95       	dec	r17
    6104:	f1 f7       	brne	.-4      	; 0x6102 <__stack+0x103>
    6106:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    6108:	86 e1       	ldi	r24, 0x16	; 22
    610a:	0e 94 1b 2a 	call	0x5436	; 0x5436 <chb_set_state>
    }
}
    610e:	69 96       	adiw	r28, 0x19	; 25
    6110:	cd bf       	out	0x3d, r28	; 61
    6112:	de bf       	out	0x3e, r29	; 62
    6114:	df 91       	pop	r29
    6116:	cf 91       	pop	r28
    6118:	1f 91       	pop	r17
    611a:	0f 91       	pop	r16
    611c:	08 95       	ret

0000611e <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    611e:	cf 93       	push	r28
    6120:	df 93       	push	r29
    6122:	cd b7       	in	r28, 0x3d	; 61
    6124:	de b7       	in	r29, 0x3e	; 62
    6126:	ea 97       	sbiw	r28, 0x3a	; 58
    6128:	cd bf       	out	0x3d, r28	; 61
    612a:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    612c:	0e 94 db 24 	call	0x49b6	; 0x49b6 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    6130:	8e e0       	ldi	r24, 0x0E	; 14
    6132:	60 e0       	ldi	r22, 0x00	; 0
    6134:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    6138:	82 e0       	ldi	r24, 0x02	; 2
    613a:	63 e0       	ldi	r22, 0x03	; 3
    613c:	4f e1       	ldi	r20, 0x1F	; 31
    613e:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    6142:	00 00       	nop
    6144:	81 e0       	ldi	r24, 0x01	; 1
    6146:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    614a:	88 2f       	mov	r24, r24
    614c:	90 e0       	ldi	r25, 0x00	; 0
    614e:	8f 71       	andi	r24, 0x1F	; 31
    6150:	90 70       	andi	r25, 0x00	; 0
    6152:	88 30       	cpi	r24, 0x08	; 8
    6154:	91 05       	cpc	r25, r1
    6156:	b1 f7       	brne	.-20     	; 0x6144 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    6158:	8e e2       	ldi	r24, 0x2E	; 46
    615a:	60 e4       	ldi	r22, 0x40	; 64
    615c:	40 ec       	ldi	r20, 0xC0	; 192
    615e:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    6162:	8e e0       	ldi	r24, 0x0E	; 14
    6164:	6c e0       	ldi	r22, 0x0C	; 12
    6166:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    616a:	84 e0       	ldi	r24, 0x04	; 4
    616c:	60 e2       	ldi	r22, 0x20	; 32
    616e:	40 e2       	ldi	r20, 0x20	; 32
    6170:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    6174:	81 e0       	ldi	r24, 0x01	; 1
    6176:	0e 94 bd 28 	call	0x517a	; 0x517a <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    617a:	81 e0       	ldi	r24, 0x01	; 1
    617c:	0e 94 06 29 	call	0x520c	; 0x520c <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    6180:	86 e1       	ldi	r24, 0x16	; 22
    6182:	0e 94 1b 2a 	call	0x5436	; 0x5436 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    6186:	82 e2       	ldi	r24, 0x22	; 34
    6188:	64 e3       	ldi	r22, 0x34	; 52
    618a:	72 e1       	ldi	r23, 0x12	; 18
    618c:	0e 94 51 27 	call	0x4ea2	; 0x4ea2 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    6190:	0e 94 2e 2f 	call	0x5e5c	; 0x5e5c <chb_get_short_addr>
    6194:	9c 01       	movw	r18, r24
    6196:	80 e2       	ldi	r24, 0x20	; 32
    6198:	b9 01       	movw	r22, r18
    619a:	0e 94 51 27 	call	0x4ea2	; 0x4ea2 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    619e:	ce 01       	movw	r24, r28
    61a0:	01 96       	adiw	r24, 0x01	; 1
    61a2:	0e 94 ec 2e 	call	0x5dd8	; 0x5dd8 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    61a6:	84 e2       	ldi	r24, 0x24	; 36
    61a8:	9e 01       	movw	r18, r28
    61aa:	2f 5f       	subi	r18, 0xFF	; 255
    61ac:	3f 4f       	sbci	r19, 0xFF	; 255
    61ae:	b9 01       	movw	r22, r18
    61b0:	0e 94 82 27 	call	0x4f04	; 0x4f04 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    61b4:	82 e7       	ldi	r24, 0x72	; 114
    61b6:	96 e0       	ldi	r25, 0x06	; 6
    61b8:	22 e7       	ldi	r18, 0x72	; 114
    61ba:	36 e0       	ldi	r19, 0x06	; 6
    61bc:	f9 01       	movw	r30, r18
    61be:	20 81       	ld	r18, Z
    61c0:	21 60       	ori	r18, 0x01	; 1
    61c2:	fc 01       	movw	r30, r24
    61c4:	20 83       	st	Z, r18
    61c6:	89 e6       	ldi	r24, 0x69	; 105
    61c8:	96 e0       	ldi	r25, 0x06	; 6
    61ca:	29 e6       	ldi	r18, 0x69	; 105
    61cc:	36 e0       	ldi	r19, 0x06	; 6
    61ce:	f9 01       	movw	r30, r18
    61d0:	20 81       	ld	r18, Z
    61d2:	23 60       	ori	r18, 0x03	; 3
    61d4:	fc 01       	movw	r30, r24
    61d6:	20 83       	st	Z, r18
    61d8:	8a e6       	ldi	r24, 0x6A	; 106
    61da:	96 e0       	ldi	r25, 0x06	; 6
    61dc:	2a e6       	ldi	r18, 0x6A	; 106
    61de:	36 e0       	ldi	r19, 0x06	; 6
    61e0:	f9 01       	movw	r30, r18
    61e2:	20 81       	ld	r18, Z
    61e4:	24 60       	ori	r18, 0x04	; 4
    61e6:	fc 01       	movw	r30, r24
    61e8:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    61ea:	80 ea       	ldi	r24, 0xA0	; 160
    61ec:	90 e0       	ldi	r25, 0x00	; 0
    61ee:	20 ea       	ldi	r18, 0xA0	; 160
    61f0:	30 e0       	ldi	r19, 0x00	; 0
    61f2:	f9 01       	movw	r30, r18
    61f4:	22 81       	ldd	r18, Z+2	; 0x02
    61f6:	27 60       	ori	r18, 0x07	; 7
    61f8:	fc 01       	movw	r30, r24
    61fa:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    61fc:	0e 94 c3 24 	call	0x4986	; 0x4986 <chb_get_state>
    6200:	86 31       	cpi	r24, 0x16	; 22
    6202:	b1 f0       	breq	.+44     	; 0x6230 <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    6204:	ce 01       	movw	r24, r28
    6206:	09 96       	adiw	r24, 0x09	; 9
    6208:	2c e0       	ldi	r18, 0x0C	; 12
    620a:	32 e0       	ldi	r19, 0x02	; 2
    620c:	b9 01       	movw	r22, r18
    620e:	0e 94 01 61 	call	0xc202	; 0xc202 <strcpy_P>
        printf(buf);
    6212:	0f 92       	push	r0
    6214:	0f 92       	push	r0
    6216:	8d b7       	in	r24, 0x3d	; 61
    6218:	9e b7       	in	r25, 0x3e	; 62
    621a:	01 96       	adiw	r24, 0x01	; 1
    621c:	9e 01       	movw	r18, r28
    621e:	27 5f       	subi	r18, 0xF7	; 247
    6220:	3f 4f       	sbci	r19, 0xFF	; 255
    6222:	fc 01       	movw	r30, r24
    6224:	20 83       	st	Z, r18
    6226:	31 83       	std	Z+1, r19	; 0x01
    6228:	0e 94 54 61 	call	0xc2a8	; 0xc2a8 <printf>
    622c:	0f 90       	pop	r0
    622e:	0f 90       	pop	r0
    }
	//StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
}
    6230:	ea 96       	adiw	r28, 0x3a	; 58
    6232:	cd bf       	out	0x3d, r28	; 61
    6234:	de bf       	out	0x3e, r29	; 62
    6236:	df 91       	pop	r29
    6238:	cf 91       	pop	r28
    623a:	08 95       	ret

0000623c <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    623c:	cf 93       	push	r28
    623e:	df 93       	push	r29
    6240:	cd b7       	in	r28, 0x3d	; 61
    6242:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    6244:	0e 94 62 33 	call	0x66c4	; 0x66c4 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    6248:	80 e6       	ldi	r24, 0x60	; 96
    624a:	96 e0       	ldi	r25, 0x06	; 6
    624c:	20 e6       	ldi	r18, 0x60	; 96
    624e:	36 e0       	ldi	r19, 0x06	; 6
    6250:	f9 01       	movw	r30, r18
    6252:	20 81       	ld	r18, Z
    6254:	22 60       	ori	r18, 0x02	; 2
    6256:	fc 01       	movw	r30, r24
    6258:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    625a:	80 e6       	ldi	r24, 0x60	; 96
    625c:	96 e0       	ldi	r25, 0x06	; 6
    625e:	20 e6       	ldi	r18, 0x60	; 96
    6260:	36 e0       	ldi	r19, 0x06	; 6
    6262:	f9 01       	movw	r30, r18
    6264:	20 81       	ld	r18, Z
    6266:	21 60       	ori	r18, 0x01	; 1
    6268:	fc 01       	movw	r30, r24
    626a:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    626c:	0e 94 8f 30 	call	0x611e	; 0x611e <chb_radio_init>
}
    6270:	df 91       	pop	r29
    6272:	cf 91       	pop	r28
    6274:	08 95       	ret

00006276 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    6276:	1f 92       	push	r1
    6278:	0f 92       	push	r0
    627a:	0f b6       	in	r0, 0x3f	; 63
    627c:	0f 92       	push	r0
    627e:	00 90 3b 00 	lds	r0, 0x003B
    6282:	0f 92       	push	r0
    6284:	11 24       	eor	r1, r1
    6286:	2f 93       	push	r18
    6288:	3f 93       	push	r19
    628a:	4f 93       	push	r20
    628c:	5f 93       	push	r21
    628e:	6f 93       	push	r22
    6290:	7f 93       	push	r23
    6292:	8f 93       	push	r24
    6294:	9f 93       	push	r25
    6296:	af 93       	push	r26
    6298:	bf 93       	push	r27
    629a:	ef 93       	push	r30
    629c:	ff 93       	push	r31
    629e:	cf 93       	push	r28
    62a0:	df 93       	push	r29
    62a2:	00 d0       	rcall	.+0      	; 0x62a4 <__vector_64+0x2e>
    62a4:	0f 92       	push	r0
    62a6:	cd b7       	in	r28, 0x3d	; 61
    62a8:	de b7       	in	r29, 0x3e	; 62
    U8 state, intp_src = 0;
    62aa:	19 82       	std	Y+1, r1	; 0x01
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    62ac:	0e 94 9e 22 	call	0x453c	; 0x453c <chb_get_pcb>
    62b0:	8a 83       	std	Y+2, r24	; 0x02
    62b2:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    62b4:	8f e3       	ldi	r24, 0x3F	; 63
    62b6:	90 e0       	ldi	r25, 0x00	; 0
    62b8:	fc 01       	movw	r30, r24
    62ba:	80 81       	ld	r24, Z
    62bc:	80 93 4e 40 	sts	0x404E, r24
    62c0:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    62c2:	81 e0       	ldi	r24, 0x01	; 1
    62c4:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    62c8:	8f e8       	ldi	r24, 0x8F	; 143
    62ca:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    intp_src = SPID_write(0);
    62ce:	80 e0       	ldi	r24, 0x00	; 0
    62d0:	0e 94 8d 33 	call	0x671a	; 0x671a <SPID_write>
    62d4:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    62d6:	80 e0       	ldi	r24, 0x00	; 0
    62d8:	0e 94 30 32 	call	0x6460	; 0x6460 <RadioCS>

    while (intp_src)
    62dc:	9a c0       	rjmp	.+308    	; 0x6412 <__vector_64+0x19c>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    62de:	89 81       	ldd	r24, Y+1	; 0x01
    62e0:	88 2f       	mov	r24, r24
    62e2:	90 e0       	ldi	r25, 0x00	; 0
    62e4:	84 70       	andi	r24, 0x04	; 4
    62e6:	90 70       	andi	r25, 0x00	; 0
    62e8:	00 97       	sbiw	r24, 0x00	; 0
    62ea:	21 f0       	breq	.+8      	; 0x62f4 <__vector_64+0x7e>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    62ec:	89 81       	ldd	r24, Y+1	; 0x01
    62ee:	8b 7f       	andi	r24, 0xFB	; 251
    62f0:	89 83       	std	Y+1, r24	; 0x01
    62f2:	8f c0       	rjmp	.+286    	; 0x6412 <__vector_64+0x19c>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    62f4:	89 81       	ldd	r24, Y+1	; 0x01
    62f6:	88 2f       	mov	r24, r24
    62f8:	90 e0       	ldi	r25, 0x00	; 0
    62fa:	88 70       	andi	r24, 0x08	; 8
    62fc:	90 70       	andi	r25, 0x00	; 0
    62fe:	00 97       	sbiw	r24, 0x00	; 0
    6300:	09 f4       	brne	.+2      	; 0x6304 <__vector_64+0x8e>
    6302:	49 c0       	rjmp	.+146    	; 0x6396 <__vector_64+0x120>
        {
            state = chb_get_state();
    6304:	0e 94 c3 24 	call	0x4986	; 0x4986 <chb_get_state>
    6308:	8c 83       	std	Y+4, r24	; 0x04

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    630a:	8c 81       	ldd	r24, Y+4	; 0x04
    630c:	86 30       	cpi	r24, 0x06	; 6
    630e:	31 f0       	breq	.+12     	; 0x631c <__vector_64+0xa6>
    6310:	8c 81       	ldd	r24, Y+4	; 0x04
    6312:	86 31       	cpi	r24, 0x16	; 22
    6314:	19 f0       	breq	.+6      	; 0x631c <__vector_64+0xa6>
    6316:	8c 81       	ldd	r24, Y+4	; 0x04
    6318:	81 31       	cpi	r24, 0x11	; 17
    631a:	71 f5       	brne	.+92     	; 0x6378 <__vector_64+0x102>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				//chb_set_state(CHB_TRX_OFF);
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    631c:	87 e0       	ldi	r24, 0x07	; 7
    631e:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    6322:	28 2f       	mov	r18, r24
    6324:	8a 81       	ldd	r24, Y+2	; 0x02
    6326:	9b 81       	ldd	r25, Y+3	; 0x03
    6328:	fc 01       	movw	r30, r24
    632a:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    632c:	86 e0       	ldi	r24, 0x06	; 6
    632e:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
    6332:	28 2f       	mov	r18, r24
    6334:	22 1f       	adc	r18, r18
    6336:	22 27       	eor	r18, r18
    6338:	22 1f       	adc	r18, r18
    633a:	8a 81       	ldd	r24, Y+2	; 0x02
    633c:	9b 81       	ldd	r25, Y+3	; 0x03
    633e:	fc 01       	movw	r30, r24
    6340:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    6342:	8a 81       	ldd	r24, Y+2	; 0x02
    6344:	9b 81       	ldd	r25, Y+3	; 0x03
    6346:	fc 01       	movw	r30, r24
    6348:	83 89       	ldd	r24, Z+19	; 0x13
    634a:	88 23       	and	r24, r24
    634c:	d1 f0       	breq	.+52     	; 0x6382 <__vector_64+0x10c>
                    // get the data
                    chb_frame_read();
    634e:	0e 94 31 28 	call	0x5062	; 0x5062 <chb_frame_read>
                    pcb->rcvd_xfers++;
    6352:	8a 81       	ldd	r24, Y+2	; 0x02
    6354:	9b 81       	ldd	r25, Y+3	; 0x03
    6356:	fc 01       	movw	r30, r24
    6358:	85 81       	ldd	r24, Z+5	; 0x05
    635a:	96 81       	ldd	r25, Z+6	; 0x06
    635c:	9c 01       	movw	r18, r24
    635e:	2f 5f       	subi	r18, 0xFF	; 255
    6360:	3f 4f       	sbci	r19, 0xFF	; 255
    6362:	8a 81       	ldd	r24, Y+2	; 0x02
    6364:	9b 81       	ldd	r25, Y+3	; 0x03
    6366:	fc 01       	movw	r30, r24
    6368:	25 83       	std	Z+5, r18	; 0x05
    636a:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    636c:	8a 81       	ldd	r24, Y+2	; 0x02
    636e:	9b 81       	ldd	r25, Y+3	; 0x03
    6370:	21 e0       	ldi	r18, 0x01	; 1
    6372:	fc 01       	movw	r30, r24
    6374:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    6376:	05 c0       	rjmp	.+10     	; 0x6382 <__vector_64+0x10c>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    6378:	8a 81       	ldd	r24, Y+2	; 0x02
    637a:	9b 81       	ldd	r25, Y+3	; 0x03
    637c:	21 e0       	ldi	r18, 0x01	; 1
    637e:	fc 01       	movw	r30, r24
    6380:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    6382:	89 81       	ldd	r24, Y+1	; 0x01
    6384:	87 7f       	andi	r24, 0xF7	; 247
    6386:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    6388:	00 00       	nop
    638a:	86 e1       	ldi	r24, 0x16	; 22
    638c:	0e 94 1b 2a 	call	0x5436	; 0x5436 <chb_set_state>
    6390:	80 34       	cpi	r24, 0x40	; 64
    6392:	d9 f7       	brne	.-10     	; 0x638a <__vector_64+0x114>
    6394:	3e c0       	rjmp	.+124    	; 0x6412 <__vector_64+0x19c>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    6396:	89 81       	ldd	r24, Y+1	; 0x01
    6398:	88 2f       	mov	r24, r24
    639a:	90 e0       	ldi	r25, 0x00	; 0
    639c:	80 74       	andi	r24, 0x40	; 64
    639e:	90 70       	andi	r25, 0x00	; 0
    63a0:	00 97       	sbiw	r24, 0x00	; 0
    63a2:	89 f0       	breq	.+34     	; 0x63c6 <__vector_64+0x150>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    63a4:	89 81       	ldd	r24, Y+1	; 0x01
    63a6:	8f 7b       	andi	r24, 0xBF	; 191
    63a8:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    63aa:	8a 81       	ldd	r24, Y+2	; 0x02
    63ac:	9b 81       	ldd	r25, Y+3	; 0x03
    63ae:	fc 01       	movw	r30, r24
    63b0:	87 85       	ldd	r24, Z+15	; 0x0f
    63b2:	90 89       	ldd	r25, Z+16	; 0x10
    63b4:	9c 01       	movw	r18, r24
    63b6:	2f 5f       	subi	r18, 0xFF	; 255
    63b8:	3f 4f       	sbci	r19, 0xFF	; 255
    63ba:	8a 81       	ldd	r24, Y+2	; 0x02
    63bc:	9b 81       	ldd	r25, Y+3	; 0x03
    63be:	fc 01       	movw	r30, r24
    63c0:	27 87       	std	Z+15, r18	; 0x0f
    63c2:	30 8b       	std	Z+16, r19	; 0x10
    63c4:	26 c0       	rjmp	.+76     	; 0x6412 <__vector_64+0x19c>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    63c6:	89 81       	ldd	r24, Y+1	; 0x01
    63c8:	88 2f       	mov	r24, r24
    63ca:	90 e0       	ldi	r25, 0x00	; 0
    63cc:	82 70       	andi	r24, 0x02	; 2
    63ce:	90 70       	andi	r25, 0x00	; 0
    63d0:	00 97       	sbiw	r24, 0x00	; 0
    63d2:	21 f0       	breq	.+8      	; 0x63dc <__vector_64+0x166>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    63d4:	89 81       	ldd	r24, Y+1	; 0x01
    63d6:	8d 7f       	andi	r24, 0xFD	; 253
    63d8:	89 83       	std	Y+1, r24	; 0x01
    63da:	1b c0       	rjmp	.+54     	; 0x6412 <__vector_64+0x19c>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    63dc:	89 81       	ldd	r24, Y+1	; 0x01
    63de:	88 2f       	mov	r24, r24
    63e0:	90 e0       	ldi	r25, 0x00	; 0
    63e2:	81 70       	andi	r24, 0x01	; 1
    63e4:	90 70       	andi	r25, 0x00	; 0
    63e6:	88 23       	and	r24, r24
    63e8:	21 f0       	breq	.+8      	; 0x63f2 <__vector_64+0x17c>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    63ea:	89 81       	ldd	r24, Y+1	; 0x01
    63ec:	8e 7f       	andi	r24, 0xFE	; 254
    63ee:	89 83       	std	Y+1, r24	; 0x01
    63f0:	10 c0       	rjmp	.+32     	; 0x6412 <__vector_64+0x19c>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    63f2:	89 81       	ldd	r24, Y+1	; 0x01
    63f4:	88 23       	and	r24, r24
    63f6:	6c f4       	brge	.+26     	; 0x6412 <__vector_64+0x19c>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    63f8:	89 81       	ldd	r24, Y+1	; 0x01
    63fa:	8f 77       	andi	r24, 0x7F	; 127
    63fc:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    63fe:	8a 81       	ldd	r24, Y+2	; 0x02
    6400:	9b 81       	ldd	r25, Y+3	; 0x03
    6402:	fc 01       	movw	r30, r24
    6404:	81 89       	ldd	r24, Z+17	; 0x11
    6406:	28 2f       	mov	r18, r24
    6408:	2f 5f       	subi	r18, 0xFF	; 255
    640a:	8a 81       	ldd	r24, Y+2	; 0x02
    640c:	9b 81       	ldd	r25, Y+3	; 0x03
    640e:	fc 01       	movw	r30, r24
    6410:	21 8b       	std	Z+17, r18	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    6412:	89 81       	ldd	r24, Y+1	; 0x01
    6414:	88 23       	and	r24, r24
    6416:	09 f0       	breq	.+2      	; 0x641a <__vector_64+0x1a4>
    6418:	62 cf       	rjmp	.-316    	; 0x62de <__vector_64+0x68>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    641a:	8f e3       	ldi	r24, 0x3F	; 63
    641c:	90 e0       	ldi	r25, 0x00	; 0
    641e:	20 91 4e 40 	lds	r18, 0x404E
    6422:	fc 01       	movw	r30, r24
    6424:	20 83       	st	Z, r18
    6426:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    6428:	8f e0       	ldi	r24, 0x0F	; 15
    642a:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <chb_reg_read>
}
    642e:	24 96       	adiw	r28, 0x04	; 4
    6430:	cd bf       	out	0x3d, r28	; 61
    6432:	de bf       	out	0x3e, r29	; 62
    6434:	df 91       	pop	r29
    6436:	cf 91       	pop	r28
    6438:	ff 91       	pop	r31
    643a:	ef 91       	pop	r30
    643c:	bf 91       	pop	r27
    643e:	af 91       	pop	r26
    6440:	9f 91       	pop	r25
    6442:	8f 91       	pop	r24
    6444:	7f 91       	pop	r23
    6446:	6f 91       	pop	r22
    6448:	5f 91       	pop	r21
    644a:	4f 91       	pop	r20
    644c:	3f 91       	pop	r19
    644e:	2f 91       	pop	r18
    6450:	0f 90       	pop	r0
    6452:	00 92 3b 00 	sts	0x003B, r0
    6456:	0f 90       	pop	r0
    6458:	0f be       	out	0x3f, r0	; 63
    645a:	0f 90       	pop	r0
    645c:	1f 90       	pop	r1
    645e:	18 95       	reti

00006460 <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    6460:	cf 93       	push	r28
    6462:	df 93       	push	r29
    6464:	0f 92       	push	r0
    6466:	cd b7       	in	r28, 0x3d	; 61
    6468:	de b7       	in	r29, 0x3e	; 62
    646a:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    646c:	89 81       	ldd	r24, Y+1	; 0x01
    646e:	88 23       	and	r24, r24
    6470:	31 f0       	breq	.+12     	; 0x647e <RadioCS+0x1e>
    6472:	80 e6       	ldi	r24, 0x60	; 96
    6474:	96 e0       	ldi	r25, 0x06	; 6
    6476:	20 e1       	ldi	r18, 0x10	; 16
    6478:	fc 01       	movw	r30, r24
    647a:	26 83       	std	Z+6, r18	; 0x06
    647c:	05 c0       	rjmp	.+10     	; 0x6488 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    647e:	80 e6       	ldi	r24, 0x60	; 96
    6480:	96 e0       	ldi	r25, 0x06	; 6
    6482:	20 e1       	ldi	r18, 0x10	; 16
    6484:	fc 01       	movw	r30, r24
    6486:	25 83       	std	Z+5, r18	; 0x05
	}
    6488:	0f 90       	pop	r0
    648a:	df 91       	pop	r29
    648c:	cf 91       	pop	r28
    648e:	08 95       	ret

00006490 <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    6490:	cf 93       	push	r28
    6492:	df 93       	push	r29
    6494:	00 d0       	rcall	.+0      	; 0x6496 <chb_eep_write_byte+0x6>
    6496:	cd b7       	in	r28, 0x3d	; 61
    6498:	de b7       	in	r29, 0x3e	; 62
    649a:	89 83       	std	Y+1, r24	; 0x01
    649c:	9a 83       	std	Y+2, r25	; 0x02
    649e:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    64a0:	00 00       	nop
    64a2:	80 ec       	ldi	r24, 0xC0	; 192
    64a4:	91 e0       	ldi	r25, 0x01	; 1
    64a6:	fc 01       	movw	r30, r24
    64a8:	87 85       	ldd	r24, Z+15	; 0x0f
    64aa:	88 23       	and	r24, r24
    64ac:	d4 f3       	brlt	.-12     	; 0x64a2 <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    64ae:	80 ec       	ldi	r24, 0xC0	; 192
    64b0:	91 e0       	ldi	r25, 0x01	; 1
    64b2:	fc 01       	movw	r30, r24
    64b4:	87 85       	ldd	r24, Z+15	; 0x0f
    64b6:	88 2f       	mov	r24, r24
    64b8:	90 e0       	ldi	r25, 0x00	; 0
    64ba:	82 70       	andi	r24, 0x02	; 2
    64bc:	90 70       	andi	r25, 0x00	; 0
    64be:	00 97       	sbiw	r24, 0x00	; 0
    64c0:	99 f0       	breq	.+38     	; 0x64e8 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    64c2:	80 ec       	ldi	r24, 0xC0	; 192
    64c4:	91 e0       	ldi	r25, 0x01	; 1
    64c6:	26 e3       	ldi	r18, 0x36	; 54
    64c8:	fc 01       	movw	r30, r24
    64ca:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    64cc:	ef 93       	push	r30
    64ce:	ff 93       	push	r31
    64d0:	0f 93       	push	r16
    64d2:	2f 93       	push	r18
    64d4:	eb ec       	ldi	r30, 0xCB	; 203
    64d6:	f1 e0       	ldi	r31, 0x01	; 1
    64d8:	08 ed       	ldi	r16, 0xD8	; 216
    64da:	21 e0       	ldi	r18, 0x01	; 1
    64dc:	04 bf       	out	0x34, r16	; 52
    64de:	20 83       	st	Z, r18
    64e0:	2f 91       	pop	r18
    64e2:	0f 91       	pop	r16
    64e4:	ff 91       	pop	r31
    64e6:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    64e8:	80 ec       	ldi	r24, 0xC0	; 192
    64ea:	91 e0       	ldi	r25, 0x01	; 1
    64ec:	23 e3       	ldi	r18, 0x33	; 51
    64ee:	fc 01       	movw	r30, r24
    64f0:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    64f2:	80 ec       	ldi	r24, 0xC0	; 192
    64f4:	91 e0       	ldi	r25, 0x01	; 1
    64f6:	29 81       	ldd	r18, Y+1	; 0x01
    64f8:	fc 01       	movw	r30, r24
    64fa:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    64fc:	80 ec       	ldi	r24, 0xC0	; 192
    64fe:	91 e0       	ldi	r25, 0x01	; 1
    6500:	29 81       	ldd	r18, Y+1	; 0x01
    6502:	3a 81       	ldd	r19, Y+2	; 0x02
    6504:	23 2f       	mov	r18, r19
    6506:	33 27       	eor	r19, r19
    6508:	2f 71       	andi	r18, 0x1F	; 31
    650a:	fc 01       	movw	r30, r24
    650c:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    650e:	80 ec       	ldi	r24, 0xC0	; 192
    6510:	91 e0       	ldi	r25, 0x01	; 1
    6512:	fc 01       	movw	r30, r24
    6514:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    6516:	80 ec       	ldi	r24, 0xC0	; 192
    6518:	91 e0       	ldi	r25, 0x01	; 1
    651a:	2b 81       	ldd	r18, Y+3	; 0x03
    651c:	fc 01       	movw	r30, r24
    651e:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    6520:	80 ec       	ldi	r24, 0xC0	; 192
    6522:	91 e0       	ldi	r25, 0x01	; 1
    6524:	25 e3       	ldi	r18, 0x35	; 53
    6526:	fc 01       	movw	r30, r24
    6528:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    652a:	ef 93       	push	r30
    652c:	ff 93       	push	r31
    652e:	0f 93       	push	r16
    6530:	2f 93       	push	r18
    6532:	eb ec       	ldi	r30, 0xCB	; 203
    6534:	f1 e0       	ldi	r31, 0x01	; 1
    6536:	08 ed       	ldi	r16, 0xD8	; 216
    6538:	21 e0       	ldi	r18, 0x01	; 1
    653a:	04 bf       	out	0x34, r16	; 52
    653c:	20 83       	st	Z, r18
    653e:	2f 91       	pop	r18
    6540:	0f 91       	pop	r16
    6542:	ff 91       	pop	r31
    6544:	ef 91       	pop	r30
}
    6546:	23 96       	adiw	r28, 0x03	; 3
    6548:	cd bf       	out	0x3d, r28	; 61
    654a:	de bf       	out	0x3e, r29	; 62
    654c:	df 91       	pop	r29
    654e:	cf 91       	pop	r28
    6550:	08 95       	ret

00006552 <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    6552:	cf 93       	push	r28
    6554:	df 93       	push	r29
    6556:	0f 92       	push	r0
    6558:	0f 92       	push	r0
    655a:	cd b7       	in	r28, 0x3d	; 61
    655c:	de b7       	in	r29, 0x3e	; 62
    655e:	89 83       	std	Y+1, r24	; 0x01
    6560:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    6562:	00 00       	nop
    6564:	80 ec       	ldi	r24, 0xC0	; 192
    6566:	91 e0       	ldi	r25, 0x01	; 1
    6568:	fc 01       	movw	r30, r24
    656a:	87 85       	ldd	r24, Z+15	; 0x0f
    656c:	88 23       	and	r24, r24
    656e:	d4 f3       	brlt	.-12     	; 0x6564 <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    6570:	80 ec       	ldi	r24, 0xC0	; 192
    6572:	91 e0       	ldi	r25, 0x01	; 1
    6574:	29 81       	ldd	r18, Y+1	; 0x01
    6576:	fc 01       	movw	r30, r24
    6578:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    657a:	80 ec       	ldi	r24, 0xC0	; 192
    657c:	91 e0       	ldi	r25, 0x01	; 1
    657e:	29 81       	ldd	r18, Y+1	; 0x01
    6580:	3a 81       	ldd	r19, Y+2	; 0x02
    6582:	23 2f       	mov	r18, r19
    6584:	33 27       	eor	r19, r19
    6586:	2f 71       	andi	r18, 0x1F	; 31
    6588:	fc 01       	movw	r30, r24
    658a:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    658c:	80 ec       	ldi	r24, 0xC0	; 192
    658e:	91 e0       	ldi	r25, 0x01	; 1
    6590:	fc 01       	movw	r30, r24
    6592:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    6594:	80 ec       	ldi	r24, 0xC0	; 192
    6596:	91 e0       	ldi	r25, 0x01	; 1
    6598:	26 e0       	ldi	r18, 0x06	; 6
    659a:	fc 01       	movw	r30, r24
    659c:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    659e:	ef 93       	push	r30
    65a0:	ff 93       	push	r31
    65a2:	0f 93       	push	r16
    65a4:	2f 93       	push	r18
    65a6:	eb ec       	ldi	r30, 0xCB	; 203
    65a8:	f1 e0       	ldi	r31, 0x01	; 1
    65aa:	08 ed       	ldi	r16, 0xD8	; 216
    65ac:	21 e0       	ldi	r18, 0x01	; 1
    65ae:	04 bf       	out	0x34, r16	; 52
    65b0:	20 83       	st	Z, r18
    65b2:	2f 91       	pop	r18
    65b4:	0f 91       	pop	r16
    65b6:	ff 91       	pop	r31
    65b8:	ef 91       	pop	r30

    return NVM.DATA0;
    65ba:	80 ec       	ldi	r24, 0xC0	; 192
    65bc:	91 e0       	ldi	r25, 0x01	; 1
    65be:	fc 01       	movw	r30, r24
    65c0:	84 81       	ldd	r24, Z+4	; 0x04
}
    65c2:	0f 90       	pop	r0
    65c4:	0f 90       	pop	r0
    65c6:	df 91       	pop	r29
    65c8:	cf 91       	pop	r28
    65ca:	08 95       	ret

000065cc <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    65cc:	cf 93       	push	r28
    65ce:	df 93       	push	r29
    65d0:	cd b7       	in	r28, 0x3d	; 61
    65d2:	de b7       	in	r29, 0x3e	; 62
    65d4:	27 97       	sbiw	r28, 0x07	; 7
    65d6:	cd bf       	out	0x3d, r28	; 61
    65d8:	de bf       	out	0x3e, r29	; 62
    65da:	8a 83       	std	Y+2, r24	; 0x02
    65dc:	9b 83       	std	Y+3, r25	; 0x03
    65de:	6c 83       	std	Y+4, r22	; 0x04
    65e0:	7d 83       	std	Y+5, r23	; 0x05
    65e2:	4e 83       	std	Y+6, r20	; 0x06
    65e4:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    65e6:	80 ec       	ldi	r24, 0xC0	; 192
    65e8:	91 e0       	ldi	r25, 0x01	; 1
    65ea:	20 ec       	ldi	r18, 0xC0	; 192
    65ec:	31 e0       	ldi	r19, 0x01	; 1
    65ee:	f9 01       	movw	r30, r18
    65f0:	24 85       	ldd	r18, Z+12	; 0x0c
    65f2:	27 7f       	andi	r18, 0xF7	; 247
    65f4:	fc 01       	movw	r30, r24
    65f6:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    65f8:	19 82       	std	Y+1, r1	; 0x01
    65fa:	16 c0       	rjmp	.+44     	; 0x6628 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    65fc:	89 81       	ldd	r24, Y+1	; 0x01
    65fe:	28 2f       	mov	r18, r24
    6600:	30 e0       	ldi	r19, 0x00	; 0
    6602:	8a 81       	ldd	r24, Y+2	; 0x02
    6604:	9b 81       	ldd	r25, Y+3	; 0x03
    6606:	82 0f       	add	r24, r18
    6608:	93 1f       	adc	r25, r19
    660a:	29 81       	ldd	r18, Y+1	; 0x01
    660c:	22 2f       	mov	r18, r18
    660e:	30 e0       	ldi	r19, 0x00	; 0
    6610:	4c 81       	ldd	r20, Y+4	; 0x04
    6612:	5d 81       	ldd	r21, Y+5	; 0x05
    6614:	24 0f       	add	r18, r20
    6616:	35 1f       	adc	r19, r21
    6618:	f9 01       	movw	r30, r18
    661a:	20 81       	ld	r18, Z
    661c:	62 2f       	mov	r22, r18
    661e:	0e 94 48 32 	call	0x6490	; 0x6490 <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    6622:	89 81       	ldd	r24, Y+1	; 0x01
    6624:	8f 5f       	subi	r24, 0xFF	; 255
    6626:	89 83       	std	Y+1, r24	; 0x01
    6628:	89 81       	ldd	r24, Y+1	; 0x01
    662a:	28 2f       	mov	r18, r24
    662c:	30 e0       	ldi	r19, 0x00	; 0
    662e:	8e 81       	ldd	r24, Y+6	; 0x06
    6630:	9f 81       	ldd	r25, Y+7	; 0x07
    6632:	28 17       	cp	r18, r24
    6634:	39 07       	cpc	r19, r25
    6636:	10 f3       	brcs	.-60     	; 0x65fc <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    6638:	27 96       	adiw	r28, 0x07	; 7
    663a:	cd bf       	out	0x3d, r28	; 61
    663c:	de bf       	out	0x3e, r29	; 62
    663e:	df 91       	pop	r29
    6640:	cf 91       	pop	r28
    6642:	08 95       	ret

00006644 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    6644:	0f 93       	push	r16
    6646:	1f 93       	push	r17
    6648:	cf 93       	push	r28
    664a:	df 93       	push	r29
    664c:	cd b7       	in	r28, 0x3d	; 61
    664e:	de b7       	in	r29, 0x3e	; 62
    6650:	27 97       	sbiw	r28, 0x07	; 7
    6652:	cd bf       	out	0x3d, r28	; 61
    6654:	de bf       	out	0x3e, r29	; 62
    6656:	8a 83       	std	Y+2, r24	; 0x02
    6658:	9b 83       	std	Y+3, r25	; 0x03
    665a:	6c 83       	std	Y+4, r22	; 0x04
    665c:	7d 83       	std	Y+5, r23	; 0x05
    665e:	4e 83       	std	Y+6, r20	; 0x06
    6660:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    6662:	80 ec       	ldi	r24, 0xC0	; 192
    6664:	91 e0       	ldi	r25, 0x01	; 1
    6666:	20 ec       	ldi	r18, 0xC0	; 192
    6668:	31 e0       	ldi	r19, 0x01	; 1
    666a:	f9 01       	movw	r30, r18
    666c:	24 85       	ldd	r18, Z+12	; 0x0c
    666e:	27 7f       	andi	r18, 0xF7	; 247
    6670:	fc 01       	movw	r30, r24
    6672:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6674:	19 82       	std	Y+1, r1	; 0x01
    6676:	16 c0       	rjmp	.+44     	; 0x66a4 <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    6678:	89 81       	ldd	r24, Y+1	; 0x01
    667a:	88 2f       	mov	r24, r24
    667c:	90 e0       	ldi	r25, 0x00	; 0
    667e:	2c 81       	ldd	r18, Y+4	; 0x04
    6680:	3d 81       	ldd	r19, Y+5	; 0x05
    6682:	89 01       	movw	r16, r18
    6684:	08 0f       	add	r16, r24
    6686:	19 1f       	adc	r17, r25
    6688:	89 81       	ldd	r24, Y+1	; 0x01
    668a:	28 2f       	mov	r18, r24
    668c:	30 e0       	ldi	r19, 0x00	; 0
    668e:	8a 81       	ldd	r24, Y+2	; 0x02
    6690:	9b 81       	ldd	r25, Y+3	; 0x03
    6692:	82 0f       	add	r24, r18
    6694:	93 1f       	adc	r25, r19
    6696:	0e 94 a9 32 	call	0x6552	; 0x6552 <chb_eep_read_byte>
    669a:	f8 01       	movw	r30, r16
    669c:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    669e:	89 81       	ldd	r24, Y+1	; 0x01
    66a0:	8f 5f       	subi	r24, 0xFF	; 255
    66a2:	89 83       	std	Y+1, r24	; 0x01
    66a4:	89 81       	ldd	r24, Y+1	; 0x01
    66a6:	28 2f       	mov	r18, r24
    66a8:	30 e0       	ldi	r19, 0x00	; 0
    66aa:	8e 81       	ldd	r24, Y+6	; 0x06
    66ac:	9f 81       	ldd	r25, Y+7	; 0x07
    66ae:	28 17       	cp	r18, r24
    66b0:	39 07       	cpc	r19, r25
    66b2:	10 f3       	brcs	.-60     	; 0x6678 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    66b4:	27 96       	adiw	r28, 0x07	; 7
    66b6:	cd bf       	out	0x3d, r28	; 61
    66b8:	de bf       	out	0x3e, r29	; 62
    66ba:	df 91       	pop	r29
    66bc:	cf 91       	pop	r28
    66be:	1f 91       	pop	r17
    66c0:	0f 91       	pop	r16
    66c2:	08 95       	ret

000066c4 <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    66c4:	cf 93       	push	r28
    66c6:	df 93       	push	r29
    66c8:	cd b7       	in	r28, 0x3d	; 61
    66ca:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    66cc:	80 e6       	ldi	r24, 0x60	; 96
    66ce:	96 e0       	ldi	r25, 0x06	; 6
    66d0:	20 e6       	ldi	r18, 0x60	; 96
    66d2:	36 e0       	ldi	r19, 0x06	; 6
    66d4:	f9 01       	movw	r30, r18
    66d6:	20 81       	ld	r18, Z
    66d8:	20 6b       	ori	r18, 0xB0	; 176
    66da:	fc 01       	movw	r30, r24
    66dc:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    66de:	84 e6       	ldi	r24, 0x64	; 100
    66e0:	96 e0       	ldi	r25, 0x06	; 6
    66e2:	24 e6       	ldi	r18, 0x64	; 100
    66e4:	36 e0       	ldi	r19, 0x06	; 6
    66e6:	f9 01       	movw	r30, r18
    66e8:	20 81       	ld	r18, Z
    66ea:	20 61       	ori	r18, 0x10	; 16
    66ec:	fc 01       	movw	r30, r24
    66ee:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    66f0:	80 ec       	ldi	r24, 0xC0	; 192
    66f2:	99 e0       	ldi	r25, 0x09	; 9
    66f4:	20 ec       	ldi	r18, 0xC0	; 192
    66f6:	39 e0       	ldi	r19, 0x09	; 9
    66f8:	f9 01       	movw	r30, r18
    66fa:	20 81       	ld	r18, Z
    66fc:	21 65       	ori	r18, 0x51	; 81
    66fe:	fc 01       	movw	r30, r24
    6700:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    6702:	84 e6       	ldi	r24, 0x64	; 100
    6704:	96 e0       	ldi	r25, 0x06	; 6
    6706:	24 e6       	ldi	r18, 0x64	; 100
    6708:	36 e0       	ldi	r19, 0x06	; 6
    670a:	f9 01       	movw	r30, r18
    670c:	20 81       	ld	r18, Z
    670e:	20 61       	ori	r18, 0x10	; 16
    6710:	fc 01       	movw	r30, r24
    6712:	20 83       	st	Z, r18
}
    6714:	df 91       	pop	r29
    6716:	cf 91       	pop	r28
    6718:	08 95       	ret

0000671a <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    671a:	cf 93       	push	r28
    671c:	df 93       	push	r29
    671e:	0f 92       	push	r0
    6720:	0f 92       	push	r0
    6722:	cd b7       	in	r28, 0x3d	; 61
    6724:	de b7       	in	r29, 0x3e	; 62
    6726:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    6728:	80 ec       	ldi	r24, 0xC0	; 192
    672a:	99 e0       	ldi	r25, 0x09	; 9
    672c:	2a 81       	ldd	r18, Y+2	; 0x02
    672e:	fc 01       	movw	r30, r24
    6730:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    6732:	00 00       	nop
    6734:	80 ec       	ldi	r24, 0xC0	; 192
    6736:	99 e0       	ldi	r25, 0x09	; 9
    6738:	fc 01       	movw	r30, r24
    673a:	82 81       	ldd	r24, Z+2	; 0x02
    673c:	88 23       	and	r24, r24
    673e:	d4 f7       	brge	.-12     	; 0x6734 <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    6740:	80 ec       	ldi	r24, 0xC0	; 192
    6742:	99 e0       	ldi	r25, 0x09	; 9
    6744:	fc 01       	movw	r30, r24
    6746:	83 81       	ldd	r24, Z+3	; 0x03
    6748:	89 83       	std	Y+1, r24	; 0x01
	return data;
    674a:	89 81       	ldd	r24, Y+1	; 0x01
    674c:	0f 90       	pop	r0
    674e:	0f 90       	pop	r0
    6750:	df 91       	pop	r29
    6752:	cf 91       	pop	r28
    6754:	08 95       	ret

00006756 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    6756:	0f 93       	push	r16
    6758:	cf 93       	push	r28
    675a:	df 93       	push	r29
    675c:	00 d0       	rcall	.+0      	; 0x675e <CCPWrite+0x8>
    675e:	00 d0       	rcall	.+0      	; 0x6760 <CCPWrite+0xa>
    6760:	cd b7       	in	r28, 0x3d	; 61
    6762:	de b7       	in	r29, 0x3e	; 62
    6764:	8c 83       	std	Y+4, r24	; 0x04
    6766:	9d 83       	std	Y+5, r25	; 0x05
    6768:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    676a:	8f e3       	ldi	r24, 0x3F	; 63
    676c:	90 e0       	ldi	r25, 0x00	; 0
    676e:	fc 01       	movw	r30, r24
    6770:	80 81       	ld	r24, Z
    6772:	8b 83       	std	Y+3, r24	; 0x03
    6774:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    6776:	8c 81       	ldd	r24, Y+4	; 0x04
    6778:	9d 81       	ldd	r25, Y+5	; 0x05
    677a:	89 83       	std	Y+1, r24	; 0x01
    677c:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    677e:	8b e3       	ldi	r24, 0x3B	; 59
    6780:	90 e0       	ldi	r25, 0x00	; 0
    6782:	fc 01       	movw	r30, r24
    6784:	10 82       	st	Z, r1
#endif
	asm volatile(
    6786:	89 81       	ldd	r24, Y+1	; 0x01
    6788:	9a 81       	ldd	r25, Y+2	; 0x02
    678a:	2e 81       	ldd	r18, Y+6	; 0x06
    678c:	fc 01       	movw	r30, r24
    678e:	08 ed       	ldi	r16, 0xD8	; 216
    6790:	04 bf       	out	0x34, r16	; 52
    6792:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    6794:	8f e3       	ldi	r24, 0x3F	; 63
    6796:	90 e0       	ldi	r25, 0x00	; 0
    6798:	2b 81       	ldd	r18, Y+3	; 0x03
    679a:	fc 01       	movw	r30, r24
    679c:	20 83       	st	Z, r18
#endif
}
    679e:	26 96       	adiw	r28, 0x06	; 6
    67a0:	cd bf       	out	0x3d, r28	; 61
    67a2:	de bf       	out	0x3e, r29	; 62
    67a4:	df 91       	pop	r29
    67a6:	cf 91       	pop	r28
    67a8:	0f 91       	pop	r16
    67aa:	08 95       	ret

000067ac <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    67ac:	cf 93       	push	r28
    67ae:	df 93       	push	r29
    67b0:	00 d0       	rcall	.+0      	; 0x67b2 <CLKSYS_XOSC_Config+0x6>
    67b2:	cd b7       	in	r28, 0x3d	; 61
    67b4:	de b7       	in	r29, 0x3e	; 62
    67b6:	89 83       	std	Y+1, r24	; 0x01
    67b8:	6a 83       	std	Y+2, r22	; 0x02
    67ba:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    67bc:	80 e5       	ldi	r24, 0x50	; 80
    67be:	90 e0       	ldi	r25, 0x00	; 0
    67c0:	2a 81       	ldd	r18, Y+2	; 0x02
    67c2:	22 23       	and	r18, r18
    67c4:	11 f0       	breq	.+4      	; 0x67ca <CLKSYS_XOSC_Config+0x1e>
    67c6:	20 e2       	ldi	r18, 0x20	; 32
    67c8:	01 c0       	rjmp	.+2      	; 0x67cc <CLKSYS_XOSC_Config+0x20>
    67ca:	20 e0       	ldi	r18, 0x00	; 0
    67cc:	39 81       	ldd	r19, Y+1	; 0x01
    67ce:	32 2b       	or	r19, r18
    67d0:	2b 81       	ldd	r18, Y+3	; 0x03
    67d2:	23 2b       	or	r18, r19
    67d4:	fc 01       	movw	r30, r24
    67d6:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    67d8:	23 96       	adiw	r28, 0x03	; 3
    67da:	cd bf       	out	0x3d, r28	; 61
    67dc:	de bf       	out	0x3e, r29	; 62
    67de:	df 91       	pop	r29
    67e0:	cf 91       	pop	r28
    67e2:	08 95       	ret

000067e4 <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    67e4:	cf 93       	push	r28
    67e6:	df 93       	push	r29
    67e8:	0f 92       	push	r0
    67ea:	0f 92       	push	r0
    67ec:	cd b7       	in	r28, 0x3d	; 61
    67ee:	de b7       	in	r29, 0x3e	; 62
    67f0:	89 83       	std	Y+1, r24	; 0x01
    67f2:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    67f4:	8a 81       	ldd	r24, Y+2	; 0x02
    67f6:	8f 71       	andi	r24, 0x1F	; 31
    67f8:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    67fa:	80 e5       	ldi	r24, 0x50	; 80
    67fc:	90 e0       	ldi	r25, 0x00	; 0
    67fe:	39 81       	ldd	r19, Y+1	; 0x01
    6800:	2a 81       	ldd	r18, Y+2	; 0x02
    6802:	23 2b       	or	r18, r19
    6804:	fc 01       	movw	r30, r24
    6806:	25 83       	std	Z+5, r18	; 0x05
}
    6808:	0f 90       	pop	r0
    680a:	0f 90       	pop	r0
    680c:	df 91       	pop	r29
    680e:	cf 91       	pop	r28
    6810:	08 95       	ret

00006812 <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    6812:	cf 93       	push	r28
    6814:	df 93       	push	r29
    6816:	0f 92       	push	r0
    6818:	0f 92       	push	r0
    681a:	cd b7       	in	r28, 0x3d	; 61
    681c:	de b7       	in	r29, 0x3e	; 62
    681e:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    6820:	80 e5       	ldi	r24, 0x50	; 80
    6822:	90 e0       	ldi	r25, 0x00	; 0
    6824:	20 e5       	ldi	r18, 0x50	; 80
    6826:	30 e0       	ldi	r19, 0x00	; 0
    6828:	f9 01       	movw	r30, r18
    682a:	20 81       	ld	r18, Z
    682c:	32 2f       	mov	r19, r18
    682e:	2a 81       	ldd	r18, Y+2	; 0x02
    6830:	20 95       	com	r18
    6832:	23 23       	and	r18, r19
    6834:	fc 01       	movw	r30, r24
    6836:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    6838:	80 e5       	ldi	r24, 0x50	; 80
    683a:	90 e0       	ldi	r25, 0x00	; 0
    683c:	fc 01       	movw	r30, r24
    683e:	90 81       	ld	r25, Z
    6840:	8a 81       	ldd	r24, Y+2	; 0x02
    6842:	89 23       	and	r24, r25
    6844:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    6846:	89 81       	ldd	r24, Y+1	; 0x01
}
    6848:	0f 90       	pop	r0
    684a:	0f 90       	pop	r0
    684c:	df 91       	pop	r29
    684e:	cf 91       	pop	r28
    6850:	08 95       	ret

00006852 <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    6852:	cf 93       	push	r28
    6854:	df 93       	push	r29
    6856:	00 d0       	rcall	.+0      	; 0x6858 <CLKSYS_Prescalers_Config+0x6>
    6858:	cd b7       	in	r28, 0x3d	; 61
    685a:	de b7       	in	r29, 0x3e	; 62
    685c:	8a 83       	std	Y+2, r24	; 0x02
    685e:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    6860:	9a 81       	ldd	r25, Y+2	; 0x02
    6862:	8b 81       	ldd	r24, Y+3	; 0x03
    6864:	89 2b       	or	r24, r25
    6866:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    6868:	81 e4       	ldi	r24, 0x41	; 65
    686a:	90 e0       	ldi	r25, 0x00	; 0
    686c:	69 81       	ldd	r22, Y+1	; 0x01
    686e:	0e 94 ab 33 	call	0x6756	; 0x6756 <CCPWrite>
}
    6872:	23 96       	adiw	r28, 0x03	; 3
    6874:	cd bf       	out	0x3d, r28	; 61
    6876:	de bf       	out	0x3e, r29	; 62
    6878:	df 91       	pop	r29
    687a:	cf 91       	pop	r28
    687c:	08 95       	ret

0000687e <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    687e:	cf 93       	push	r28
    6880:	df 93       	push	r29
    6882:	0f 92       	push	r0
    6884:	0f 92       	push	r0
    6886:	cd b7       	in	r28, 0x3d	; 61
    6888:	de b7       	in	r29, 0x3e	; 62
    688a:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    688c:	80 e4       	ldi	r24, 0x40	; 64
    688e:	90 e0       	ldi	r25, 0x00	; 0
    6890:	fc 01       	movw	r30, r24
    6892:	80 81       	ld	r24, Z
    6894:	98 2f       	mov	r25, r24
    6896:	98 7f       	andi	r25, 0xF8	; 248
    6898:	8a 81       	ldd	r24, Y+2	; 0x02
    689a:	89 2b       	or	r24, r25
    689c:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    689e:	80 e4       	ldi	r24, 0x40	; 64
    68a0:	90 e0       	ldi	r25, 0x00	; 0
    68a2:	69 81       	ldd	r22, Y+1	; 0x01
    68a4:	0e 94 ab 33 	call	0x6756	; 0x6756 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    68a8:	80 e4       	ldi	r24, 0x40	; 64
    68aa:	90 e0       	ldi	r25, 0x00	; 0
    68ac:	fc 01       	movw	r30, r24
    68ae:	90 81       	ld	r25, Z
    68b0:	8a 81       	ldd	r24, Y+2	; 0x02
    68b2:	89 23       	and	r24, r25
    68b4:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    68b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    68b8:	0f 90       	pop	r0
    68ba:	0f 90       	pop	r0
    68bc:	df 91       	pop	r29
    68be:	cf 91       	pop	r28
    68c0:	08 95       	ret

000068c2 <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    68c2:	cf 93       	push	r28
    68c4:	df 93       	push	r29
    68c6:	0f 92       	push	r0
    68c8:	cd b7       	in	r28, 0x3d	; 61
    68ca:	de b7       	in	r29, 0x3e	; 62
    68cc:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    68ce:	80 e4       	ldi	r24, 0x40	; 64
    68d0:	90 e0       	ldi	r25, 0x00	; 0
    68d2:	20 e4       	ldi	r18, 0x40	; 64
    68d4:	30 e0       	ldi	r19, 0x00	; 0
    68d6:	f9 01       	movw	r30, r18
    68d8:	23 81       	ldd	r18, Z+3	; 0x03
    68da:	32 2f       	mov	r19, r18
    68dc:	31 7f       	andi	r19, 0xF1	; 241
    68de:	29 81       	ldd	r18, Y+1	; 0x01
    68e0:	23 2b       	or	r18, r19
    68e2:	21 60       	ori	r18, 0x01	; 1
    68e4:	fc 01       	movw	r30, r24
    68e6:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    68e8:	0f 90       	pop	r0
    68ea:	df 91       	pop	r29
    68ec:	cf 91       	pop	r28
    68ee:	08 95       	ret

000068f0 <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    68f0:	cf 93       	push	r28
    68f2:	df 93       	push	r29
    68f4:	0f 92       	push	r0
    68f6:	0f 92       	push	r0
    68f8:	cd b7       	in	r28, 0x3d	; 61
    68fa:	de b7       	in	r29, 0x3e	; 62
    68fc:	89 83       	std	Y+1, r24	; 0x01
    68fe:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    6900:	80 e5       	ldi	r24, 0x50	; 80
    6902:	90 e0       	ldi	r25, 0x00	; 0
    6904:	20 e5       	ldi	r18, 0x50	; 80
    6906:	30 e0       	ldi	r19, 0x00	; 0
    6908:	f9 01       	movw	r30, r18
    690a:	26 81       	ldd	r18, Z+6	; 0x06
    690c:	32 2f       	mov	r19, r18
    690e:	29 81       	ldd	r18, Y+1	; 0x01
    6910:	20 95       	com	r18
    6912:	32 23       	and	r19, r18
    6914:	2a 81       	ldd	r18, Y+2	; 0x02
    6916:	22 23       	and	r18, r18
    6918:	11 f0       	breq	.+4      	; 0x691e <CLKSYS_AutoCalibration_Enable+0x2e>
    691a:	29 81       	ldd	r18, Y+1	; 0x01
    691c:	01 c0       	rjmp	.+2      	; 0x6920 <CLKSYS_AutoCalibration_Enable+0x30>
    691e:	20 e0       	ldi	r18, 0x00	; 0
    6920:	23 2b       	or	r18, r19
    6922:	fc 01       	movw	r30, r24
    6924:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    6926:	89 81       	ldd	r24, Y+1	; 0x01
    6928:	81 30       	cpi	r24, 0x01	; 1
    692a:	51 f4       	brne	.+20     	; 0x6940 <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    692c:	88 e6       	ldi	r24, 0x68	; 104
    692e:	90 e0       	ldi	r25, 0x00	; 0
    6930:	28 e6       	ldi	r18, 0x68	; 104
    6932:	30 e0       	ldi	r19, 0x00	; 0
    6934:	f9 01       	movw	r30, r18
    6936:	20 81       	ld	r18, Z
    6938:	21 60       	ori	r18, 0x01	; 1
    693a:	fc 01       	movw	r30, r24
    693c:	20 83       	st	Z, r18
    693e:	0c c0       	rjmp	.+24     	; 0x6958 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    6940:	89 81       	ldd	r24, Y+1	; 0x01
    6942:	82 30       	cpi	r24, 0x02	; 2
    6944:	49 f4       	brne	.+18     	; 0x6958 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    6946:	80 e6       	ldi	r24, 0x60	; 96
    6948:	90 e0       	ldi	r25, 0x00	; 0
    694a:	20 e6       	ldi	r18, 0x60	; 96
    694c:	30 e0       	ldi	r19, 0x00	; 0
    694e:	f9 01       	movw	r30, r18
    6950:	20 81       	ld	r18, Z
    6952:	21 60       	ori	r18, 0x01	; 1
    6954:	fc 01       	movw	r30, r24
    6956:	20 83       	st	Z, r18
	}
}
    6958:	0f 90       	pop	r0
    695a:	0f 90       	pop	r0
    695c:	df 91       	pop	r29
    695e:	cf 91       	pop	r28
    6960:	08 95       	ret

00006962 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    6962:	cf 93       	push	r28
    6964:	df 93       	push	r29
    6966:	cd b7       	in	r28, 0x3d	; 61
    6968:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    696a:	83 e5       	ldi	r24, 0x53	; 83
    696c:	90 e0       	ldi	r25, 0x00	; 0
    696e:	63 e0       	ldi	r22, 0x03	; 3
    6970:	0e 94 ab 33 	call	0x6756	; 0x6756 <CCPWrite>
}
    6974:	df 91       	pop	r29
    6976:	cf 91       	pop	r28
    6978:	08 95       	ret

0000697a <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    697a:	cf 93       	push	r28
    697c:	df 93       	push	r29
    697e:	cd b7       	in	r28, 0x3d	; 61
    6980:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    6982:	82 e4       	ldi	r24, 0x42	; 66
    6984:	90 e0       	ldi	r25, 0x00	; 0
    6986:	61 e0       	ldi	r22, 0x01	; 1
    6988:	0e 94 ab 33 	call	0x6756	; 0x6756 <CCPWrite>
}
    698c:	df 91       	pop	r29
    698e:	cf 91       	pop	r28
    6990:	08 95       	ret

00006992 <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    6992:	cf 93       	push	r28
    6994:	df 93       	push	r29
    6996:	cd b7       	in	r28, 0x3d	; 61
    6998:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    699a:	80 ec       	ldi	r24, 0xC0	; 192
    699c:	60 e0       	ldi	r22, 0x00	; 0
    699e:	4b e0       	ldi	r20, 0x0B	; 11
    69a0:	0e 94 d6 33 	call	0x67ac	; 0x67ac <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    69a4:	80 e5       	ldi	r24, 0x50	; 80
    69a6:	90 e0       	ldi	r25, 0x00	; 0
    69a8:	20 e5       	ldi	r18, 0x50	; 80
    69aa:	30 e0       	ldi	r19, 0x00	; 0
    69ac:	f9 01       	movw	r30, r18
    69ae:	20 81       	ld	r18, Z
    69b0:	28 60       	ori	r18, 0x08	; 8
    69b2:	fc 01       	movw	r30, r24
    69b4:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    69b6:	80 e5       	ldi	r24, 0x50	; 80
    69b8:	90 e0       	ldi	r25, 0x00	; 0
    69ba:	fc 01       	movw	r30, r24
    69bc:	81 81       	ldd	r24, Z+1	; 0x01
    69be:	88 2f       	mov	r24, r24
    69c0:	90 e0       	ldi	r25, 0x00	; 0
    69c2:	88 70       	andi	r24, 0x08	; 8
    69c4:	90 70       	andi	r25, 0x00	; 0
    69c6:	00 97       	sbiw	r24, 0x00	; 0
    69c8:	b1 f3       	breq	.-20     	; 0x69b6 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    69ca:	80 ec       	ldi	r24, 0xC0	; 192
    69cc:	62 e0       	ldi	r22, 0x02	; 2
    69ce:	0e 94 f2 33 	call	0x67e4	; 0x67e4 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    69d2:	80 e5       	ldi	r24, 0x50	; 80
    69d4:	90 e0       	ldi	r25, 0x00	; 0
    69d6:	20 e5       	ldi	r18, 0x50	; 80
    69d8:	30 e0       	ldi	r19, 0x00	; 0
    69da:	f9 01       	movw	r30, r18
    69dc:	20 81       	ld	r18, Z
    69de:	20 61       	ori	r18, 0x10	; 16
    69e0:	fc 01       	movw	r30, r24
    69e2:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    69e4:	80 e5       	ldi	r24, 0x50	; 80
    69e6:	90 e0       	ldi	r25, 0x00	; 0
    69e8:	fc 01       	movw	r30, r24
    69ea:	81 81       	ldd	r24, Z+1	; 0x01
    69ec:	88 2f       	mov	r24, r24
    69ee:	90 e0       	ldi	r25, 0x00	; 0
    69f0:	80 71       	andi	r24, 0x10	; 16
    69f2:	90 70       	andi	r25, 0x00	; 0
    69f4:	00 97       	sbiw	r24, 0x00	; 0
    69f6:	b1 f3       	breq	.-20     	; 0x69e4 <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    69f8:	84 e0       	ldi	r24, 0x04	; 4
    69fa:	0e 94 3f 34 	call	0x687e	; 0x687e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    69fe:	81 e0       	ldi	r24, 0x01	; 1
    6a00:	0e 94 09 34 	call	0x6812	; 0x6812 <CLKSYS_Disable>
}
    6a04:	df 91       	pop	r29
    6a06:	cf 91       	pop	r28
    6a08:	08 95       	ret

00006a0a <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    6a0a:	cf 93       	push	r28
    6a0c:	df 93       	push	r29
    6a0e:	cd b7       	in	r28, 0x3d	; 61
    6a10:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6a12:	80 e5       	ldi	r24, 0x50	; 80
    6a14:	90 e0       	ldi	r25, 0x00	; 0
    6a16:	20 e5       	ldi	r18, 0x50	; 80
    6a18:	30 e0       	ldi	r19, 0x00	; 0
    6a1a:	f9 01       	movw	r30, r18
    6a1c:	20 81       	ld	r18, Z
    6a1e:	22 60       	ori	r18, 0x02	; 2
    6a20:	fc 01       	movw	r30, r24
    6a22:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    6a24:	80 e0       	ldi	r24, 0x00	; 0
    6a26:	61 e0       	ldi	r22, 0x01	; 1
    6a28:	0e 94 29 34 	call	0x6852	; 0x6852 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6a2c:	80 e5       	ldi	r24, 0x50	; 80
    6a2e:	90 e0       	ldi	r25, 0x00	; 0
    6a30:	fc 01       	movw	r30, r24
    6a32:	81 81       	ldd	r24, Z+1	; 0x01
    6a34:	88 2f       	mov	r24, r24
    6a36:	90 e0       	ldi	r25, 0x00	; 0
    6a38:	82 70       	andi	r24, 0x02	; 2
    6a3a:	90 70       	andi	r25, 0x00	; 0
    6a3c:	00 97       	sbiw	r24, 0x00	; 0
    6a3e:	b1 f3       	breq	.-20     	; 0x6a2c <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6a40:	81 e0       	ldi	r24, 0x01	; 1
    6a42:	0e 94 3f 34 	call	0x687e	; 0x687e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6a46:	81 e0       	ldi	r24, 0x01	; 1
    6a48:	0e 94 09 34 	call	0x6812	; 0x6812 <CLKSYS_Disable>
	
}
    6a4c:	df 91       	pop	r29
    6a4e:	cf 91       	pop	r28
    6a50:	08 95       	ret

00006a52 <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    6a52:	cf 93       	push	r28
    6a54:	df 93       	push	r29
    6a56:	cd b7       	in	r28, 0x3d	; 61
    6a58:	de b7       	in	r29, 0x3e	; 62
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6a5a:	80 e5       	ldi	r24, 0x50	; 80
    6a5c:	90 e0       	ldi	r25, 0x00	; 0
    6a5e:	20 e5       	ldi	r18, 0x50	; 80
    6a60:	30 e0       	ldi	r19, 0x00	; 0
    6a62:	f9 01       	movw	r30, r18
    6a64:	20 81       	ld	r18, Z
    6a66:	22 60       	ori	r18, 0x02	; 2
    6a68:	fc 01       	movw	r30, r24
    6a6a:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6a6c:	80 e0       	ldi	r24, 0x00	; 0
    6a6e:	60 e0       	ldi	r22, 0x00	; 0
    6a70:	0e 94 29 34 	call	0x6852	; 0x6852 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6a74:	80 e5       	ldi	r24, 0x50	; 80
    6a76:	90 e0       	ldi	r25, 0x00	; 0
    6a78:	fc 01       	movw	r30, r24
    6a7a:	81 81       	ldd	r24, Z+1	; 0x01
    6a7c:	88 2f       	mov	r24, r24
    6a7e:	90 e0       	ldi	r25, 0x00	; 0
    6a80:	82 70       	andi	r24, 0x02	; 2
    6a82:	90 70       	andi	r25, 0x00	; 0
    6a84:	00 97       	sbiw	r24, 0x00	; 0
    6a86:	b1 f3       	breq	.-20     	; 0x6a74 <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6a88:	81 e0       	ldi	r24, 0x01	; 1
    6a8a:	0e 94 3f 34 	call	0x687e	; 0x687e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6a8e:	81 e0       	ldi	r24, 0x01	; 1
    6a90:	0e 94 09 34 	call	0x6812	; 0x6812 <CLKSYS_Disable>
	
}
    6a94:	df 91       	pop	r29
    6a96:	cf 91       	pop	r28
    6a98:	08 95       	ret

00006a9a <portExCS>:


void portExCS(uint8_t write) {
    6a9a:	0f 93       	push	r16
    6a9c:	1f 93       	push	r17
    6a9e:	cf 93       	push	r28
    6aa0:	df 93       	push	r29
    6aa2:	cd b7       	in	r28, 0x3d	; 61
    6aa4:	de b7       	in	r29, 0x3e	; 62
    6aa6:	69 97       	sbiw	r28, 0x19	; 25
    6aa8:	cd bf       	out	0x3d, r28	; 61
    6aaa:	de bf       	out	0x3e, r29	; 62
    6aac:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6aae:	89 8d       	ldd	r24, Y+25	; 0x19
    6ab0:	88 23       	and	r24, r24
    6ab2:	31 f0       	breq	.+12     	; 0x6ac0 <portExCS+0x26>
    6ab4:	80 e0       	ldi	r24, 0x00	; 0
    6ab6:	96 e0       	ldi	r25, 0x06	; 6
    6ab8:	28 e0       	ldi	r18, 0x08	; 8
    6aba:	fc 01       	movw	r30, r24
    6abc:	26 83       	std	Z+6, r18	; 0x06
    6abe:	05 c0       	rjmp	.+10     	; 0x6aca <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    6ac0:	80 e0       	ldi	r24, 0x00	; 0
    6ac2:	96 e0       	ldi	r25, 0x06	; 6
    6ac4:	28 e0       	ldi	r18, 0x08	; 8
    6ac6:	fc 01       	movw	r30, r24
    6ac8:	25 83       	std	Z+5, r18	; 0x05
    6aca:	80 e0       	ldi	r24, 0x00	; 0
    6acc:	90 e0       	ldi	r25, 0x00	; 0
    6ace:	a0 e2       	ldi	r26, 0x20	; 32
    6ad0:	b1 e4       	ldi	r27, 0x41	; 65
    6ad2:	89 83       	std	Y+1, r24	; 0x01
    6ad4:	9a 83       	std	Y+2, r25	; 0x02
    6ad6:	ab 83       	std	Y+3, r26	; 0x03
    6ad8:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6ada:	69 81       	ldd	r22, Y+1	; 0x01
    6adc:	7a 81       	ldd	r23, Y+2	; 0x02
    6ade:	8b 81       	ldd	r24, Y+3	; 0x03
    6ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    6ae2:	2b ea       	ldi	r18, 0xAB	; 171
    6ae4:	3a ea       	ldi	r19, 0xAA	; 170
    6ae6:	4a e2       	ldi	r20, 0x2A	; 42
    6ae8:	51 e4       	ldi	r21, 0x41	; 65
    6aea:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    6aee:	dc 01       	movw	r26, r24
    6af0:	cb 01       	movw	r24, r22
    6af2:	8d 83       	std	Y+5, r24	; 0x05
    6af4:	9e 83       	std	Y+6, r25	; 0x06
    6af6:	af 83       	std	Y+7, r26	; 0x07
    6af8:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6afa:	11 e0       	ldi	r17, 0x01	; 1
    6afc:	6d 81       	ldd	r22, Y+5	; 0x05
    6afe:	7e 81       	ldd	r23, Y+6	; 0x06
    6b00:	8f 81       	ldd	r24, Y+7	; 0x07
    6b02:	98 85       	ldd	r25, Y+8	; 0x08
    6b04:	20 e0       	ldi	r18, 0x00	; 0
    6b06:	30 e0       	ldi	r19, 0x00	; 0
    6b08:	40 e8       	ldi	r20, 0x80	; 128
    6b0a:	5f e3       	ldi	r21, 0x3F	; 63
    6b0c:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    6b10:	88 23       	and	r24, r24
    6b12:	0c f0       	brlt	.+2      	; 0x6b16 <portExCS+0x7c>
    6b14:	10 e0       	ldi	r17, 0x00	; 0
    6b16:	11 23       	and	r17, r17
    6b18:	19 f0       	breq	.+6      	; 0x6b20 <portExCS+0x86>
		__ticks = 1;
    6b1a:	81 e0       	ldi	r24, 0x01	; 1
    6b1c:	89 87       	std	Y+9, r24	; 0x09
    6b1e:	a3 c0       	rjmp	.+326    	; 0x6c66 <portExCS+0x1cc>
	else if (__tmp > 255)
    6b20:	11 e0       	ldi	r17, 0x01	; 1
    6b22:	6d 81       	ldd	r22, Y+5	; 0x05
    6b24:	7e 81       	ldd	r23, Y+6	; 0x06
    6b26:	8f 81       	ldd	r24, Y+7	; 0x07
    6b28:	98 85       	ldd	r25, Y+8	; 0x08
    6b2a:	20 e0       	ldi	r18, 0x00	; 0
    6b2c:	30 e0       	ldi	r19, 0x00	; 0
    6b2e:	4f e7       	ldi	r20, 0x7F	; 127
    6b30:	53 e4       	ldi	r21, 0x43	; 67
    6b32:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    6b36:	18 16       	cp	r1, r24
    6b38:	0c f0       	brlt	.+2      	; 0x6b3c <portExCS+0xa2>
    6b3a:	10 e0       	ldi	r17, 0x00	; 0
    6b3c:	11 23       	and	r17, r17
    6b3e:	09 f4       	brne	.+2      	; 0x6b42 <portExCS+0xa8>
    6b40:	89 c0       	rjmp	.+274    	; 0x6c54 <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    6b42:	69 81       	ldd	r22, Y+1	; 0x01
    6b44:	7a 81       	ldd	r23, Y+2	; 0x02
    6b46:	8b 81       	ldd	r24, Y+3	; 0x03
    6b48:	9c 81       	ldd	r25, Y+4	; 0x04
    6b4a:	20 e0       	ldi	r18, 0x00	; 0
    6b4c:	30 e0       	ldi	r19, 0x00	; 0
    6b4e:	4a e7       	ldi	r20, 0x7A	; 122
    6b50:	54 e4       	ldi	r21, 0x44	; 68
    6b52:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    6b56:	dc 01       	movw	r26, r24
    6b58:	cb 01       	movw	r24, r22
    6b5a:	8a 87       	std	Y+10, r24	; 0x0a
    6b5c:	9b 87       	std	Y+11, r25	; 0x0b
    6b5e:	ac 87       	std	Y+12, r26	; 0x0c
    6b60:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6b62:	6a 85       	ldd	r22, Y+10	; 0x0a
    6b64:	7b 85       	ldd	r23, Y+11	; 0x0b
    6b66:	8c 85       	ldd	r24, Y+12	; 0x0c
    6b68:	9d 85       	ldd	r25, Y+13	; 0x0d
    6b6a:	20 e0       	ldi	r18, 0x00	; 0
    6b6c:	30 e0       	ldi	r19, 0x00	; 0
    6b6e:	4a ef       	ldi	r20, 0xFA	; 250
    6b70:	55 e4       	ldi	r21, 0x45	; 69
    6b72:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    6b76:	dc 01       	movw	r26, r24
    6b78:	cb 01       	movw	r24, r22
    6b7a:	8e 87       	std	Y+14, r24	; 0x0e
    6b7c:	9f 87       	std	Y+15, r25	; 0x0f
    6b7e:	a8 8b       	std	Y+16, r26	; 0x10
    6b80:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    6b82:	11 e0       	ldi	r17, 0x01	; 1
    6b84:	6e 85       	ldd	r22, Y+14	; 0x0e
    6b86:	7f 85       	ldd	r23, Y+15	; 0x0f
    6b88:	88 89       	ldd	r24, Y+16	; 0x10
    6b8a:	99 89       	ldd	r25, Y+17	; 0x11
    6b8c:	20 e0       	ldi	r18, 0x00	; 0
    6b8e:	30 e0       	ldi	r19, 0x00	; 0
    6b90:	40 e8       	ldi	r20, 0x80	; 128
    6b92:	5f e3       	ldi	r21, 0x3F	; 63
    6b94:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    6b98:	88 23       	and	r24, r24
    6b9a:	0c f0       	brlt	.+2      	; 0x6b9e <portExCS+0x104>
    6b9c:	10 e0       	ldi	r17, 0x00	; 0
    6b9e:	11 23       	and	r17, r17
    6ba0:	29 f0       	breq	.+10     	; 0x6bac <portExCS+0x112>
		__ticks = 1;
    6ba2:	81 e0       	ldi	r24, 0x01	; 1
    6ba4:	90 e0       	ldi	r25, 0x00	; 0
    6ba6:	8a 8b       	std	Y+18, r24	; 0x12
    6ba8:	9b 8b       	std	Y+19, r25	; 0x13
    6baa:	46 c0       	rjmp	.+140    	; 0x6c38 <portExCS+0x19e>
	else if (__tmp > 65535)
    6bac:	11 e0       	ldi	r17, 0x01	; 1
    6bae:	6e 85       	ldd	r22, Y+14	; 0x0e
    6bb0:	7f 85       	ldd	r23, Y+15	; 0x0f
    6bb2:	88 89       	ldd	r24, Y+16	; 0x10
    6bb4:	99 89       	ldd	r25, Y+17	; 0x11
    6bb6:	20 e0       	ldi	r18, 0x00	; 0
    6bb8:	3f ef       	ldi	r19, 0xFF	; 255
    6bba:	4f e7       	ldi	r20, 0x7F	; 127
    6bbc:	57 e4       	ldi	r21, 0x47	; 71
    6bbe:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    6bc2:	18 16       	cp	r1, r24
    6bc4:	0c f0       	brlt	.+2      	; 0x6bc8 <portExCS+0x12e>
    6bc6:	10 e0       	ldi	r17, 0x00	; 0
    6bc8:	11 23       	and	r17, r17
    6bca:	61 f1       	breq	.+88     	; 0x6c24 <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6bcc:	6a 85       	ldd	r22, Y+10	; 0x0a
    6bce:	7b 85       	ldd	r23, Y+11	; 0x0b
    6bd0:	8c 85       	ldd	r24, Y+12	; 0x0c
    6bd2:	9d 85       	ldd	r25, Y+13	; 0x0d
    6bd4:	20 e0       	ldi	r18, 0x00	; 0
    6bd6:	30 e0       	ldi	r19, 0x00	; 0
    6bd8:	40 e2       	ldi	r20, 0x20	; 32
    6bda:	51 e4       	ldi	r21, 0x41	; 65
    6bdc:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    6be0:	dc 01       	movw	r26, r24
    6be2:	cb 01       	movw	r24, r22
    6be4:	bc 01       	movw	r22, r24
    6be6:	cd 01       	movw	r24, r26
    6be8:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    6bec:	dc 01       	movw	r26, r24
    6bee:	cb 01       	movw	r24, r22
    6bf0:	8a 8b       	std	Y+18, r24	; 0x12
    6bf2:	9b 8b       	std	Y+19, r25	; 0x13
    6bf4:	12 c0       	rjmp	.+36     	; 0x6c1a <portExCS+0x180>
    6bf6:	80 e2       	ldi	r24, 0x20	; 32
    6bf8:	93 e0       	ldi	r25, 0x03	; 3
    6bfa:	8c 8b       	std	Y+20, r24	; 0x14
    6bfc:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6bfe:	8c 89       	ldd	r24, Y+20	; 0x14
    6c00:	9d 89       	ldd	r25, Y+21	; 0x15
    6c02:	8c 01       	movw	r16, r24
    6c04:	c8 01       	movw	r24, r16
    6c06:	01 97       	sbiw	r24, 0x01	; 1
    6c08:	f1 f7       	brne	.-4      	; 0x6c06 <portExCS+0x16c>
    6c0a:	8c 01       	movw	r16, r24
    6c0c:	0c 8b       	std	Y+20, r16	; 0x14
    6c0e:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6c10:	8a 89       	ldd	r24, Y+18	; 0x12
    6c12:	9b 89       	ldd	r25, Y+19	; 0x13
    6c14:	01 97       	sbiw	r24, 0x01	; 1
    6c16:	8a 8b       	std	Y+18, r24	; 0x12
    6c18:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6c1a:	8a 89       	ldd	r24, Y+18	; 0x12
    6c1c:	9b 89       	ldd	r25, Y+19	; 0x13
    6c1e:	00 97       	sbiw	r24, 0x00	; 0
    6c20:	51 f7       	brne	.-44     	; 0x6bf6 <portExCS+0x15c>
    6c22:	28 c0       	rjmp	.+80     	; 0x6c74 <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6c24:	6e 85       	ldd	r22, Y+14	; 0x0e
    6c26:	7f 85       	ldd	r23, Y+15	; 0x0f
    6c28:	88 89       	ldd	r24, Y+16	; 0x10
    6c2a:	99 89       	ldd	r25, Y+17	; 0x11
    6c2c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    6c30:	dc 01       	movw	r26, r24
    6c32:	cb 01       	movw	r24, r22
    6c34:	8a 8b       	std	Y+18, r24	; 0x12
    6c36:	9b 8b       	std	Y+19, r25	; 0x13
    6c38:	8a 89       	ldd	r24, Y+18	; 0x12
    6c3a:	9b 89       	ldd	r25, Y+19	; 0x13
    6c3c:	8e 8b       	std	Y+22, r24	; 0x16
    6c3e:	9f 8b       	std	Y+23, r25	; 0x17
    6c40:	8e 89       	ldd	r24, Y+22	; 0x16
    6c42:	9f 89       	ldd	r25, Y+23	; 0x17
    6c44:	8c 01       	movw	r16, r24
    6c46:	f8 01       	movw	r30, r16
    6c48:	31 97       	sbiw	r30, 0x01	; 1
    6c4a:	f1 f7       	brne	.-4      	; 0x6c48 <portExCS+0x1ae>
    6c4c:	8f 01       	movw	r16, r30
    6c4e:	0e 8b       	std	Y+22, r16	; 0x16
    6c50:	1f 8b       	std	Y+23, r17	; 0x17
    6c52:	10 c0       	rjmp	.+32     	; 0x6c74 <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6c54:	6d 81       	ldd	r22, Y+5	; 0x05
    6c56:	7e 81       	ldd	r23, Y+6	; 0x06
    6c58:	8f 81       	ldd	r24, Y+7	; 0x07
    6c5a:	98 85       	ldd	r25, Y+8	; 0x08
    6c5c:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    6c60:	dc 01       	movw	r26, r24
    6c62:	cb 01       	movw	r24, r22
    6c64:	89 87       	std	Y+9, r24	; 0x09
    6c66:	89 85       	ldd	r24, Y+9	; 0x09
    6c68:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6c6a:	88 8d       	ldd	r24, Y+24	; 0x18
    6c6c:	18 2f       	mov	r17, r24
    6c6e:	1a 95       	dec	r17
    6c70:	f1 f7       	brne	.-4      	; 0x6c6e <portExCS+0x1d4>
    6c72:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    6c74:	69 96       	adiw	r28, 0x19	; 25
    6c76:	cd bf       	out	0x3d, r28	; 61
    6c78:	de bf       	out	0x3e, r29	; 62
    6c7a:	df 91       	pop	r29
    6c7c:	cf 91       	pop	r28
    6c7e:	1f 91       	pop	r17
    6c80:	0f 91       	pop	r16
    6c82:	08 95       	ret

00006c84 <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    6c84:	cf 93       	push	r28
    6c86:	df 93       	push	r29
    6c88:	00 d0       	rcall	.+0      	; 0x6c8a <PortEx_DIRSET+0x6>
    6c8a:	cd b7       	in	r28, 0x3d	; 61
    6c8c:	de b7       	in	r29, 0x3e	; 62
    6c8e:	8a 83       	std	Y+2, r24	; 0x02
    6c90:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6c92:	80 e0       	ldi	r24, 0x00	; 0
    6c94:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    6c98:	81 e0       	ldi	r24, 0x01	; 1
    6c9a:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	portExCS(TRUE);
    6c9e:	81 e0       	ldi	r24, 0x01	; 1
    6ca0:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    6ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    6ca6:	88 23       	and	r24, r24
    6ca8:	39 f0       	breq	.+14     	; 0x6cb8 <PortEx_DIRSET+0x34>
    6caa:	90 91 72 50 	lds	r25, 0x5072
    6cae:	8a 81       	ldd	r24, Y+2	; 0x02
    6cb0:	89 2b       	or	r24, r25
    6cb2:	80 93 72 50 	sts	0x5072, r24
    6cb6:	06 c0       	rjmp	.+12     	; 0x6cc4 <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6cb8:	90 91 c6 50 	lds	r25, 0x50C6
    6cbc:	8a 81       	ldd	r24, Y+2	; 0x02
    6cbe:	89 2b       	or	r24, r25
    6cc0:	80 93 c6 50 	sts	0x50C6, r24
	
	SPIBuffer[0] = PS_WRITE;
    6cc4:	80 e4       	ldi	r24, 0x40	; 64
    6cc6:	80 93 5d 50 	sts	0x505D, r24
	if(bank) {
    6cca:	8b 81       	ldd	r24, Y+3	; 0x03
    6ccc:	88 23       	and	r24, r24
    6cce:	41 f0       	breq	.+16     	; 0x6ce0 <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    6cd0:	10 92 5e 50 	sts	0x505E, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6cd4:	80 91 72 50 	lds	r24, 0x5072
    6cd8:	80 95       	com	r24
    6cda:	80 93 5f 50 	sts	0x505F, r24
    6cde:	08 c0       	rjmp	.+16     	; 0x6cf0 <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6ce0:	81 e0       	ldi	r24, 0x01	; 1
    6ce2:	80 93 5e 50 	sts	0x505E, r24
		SPIBuffer[2] = ~bankB_DIR;
    6ce6:	80 91 c6 50 	lds	r24, 0x50C6
    6cea:	80 95       	com	r24
    6cec:	80 93 5f 50 	sts	0x505F, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6cf0:	19 82       	std	Y+1, r1	; 0x01
    6cf2:	1b c0       	rjmp	.+54     	; 0x6d2a <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    6cf4:	80 ec       	ldi	r24, 0xC0	; 192
    6cf6:	98 e0       	ldi	r25, 0x08	; 8
    6cf8:	29 81       	ldd	r18, Y+1	; 0x01
    6cfa:	22 2f       	mov	r18, r18
    6cfc:	30 e0       	ldi	r19, 0x00	; 0
    6cfe:	23 5a       	subi	r18, 0xA3	; 163
    6d00:	3f 4a       	sbci	r19, 0xAF	; 175
    6d02:	f9 01       	movw	r30, r18
    6d04:	20 81       	ld	r18, Z
    6d06:	fc 01       	movw	r30, r24
    6d08:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6d0a:	00 00       	nop
    6d0c:	80 ec       	ldi	r24, 0xC0	; 192
    6d0e:	98 e0       	ldi	r25, 0x08	; 8
    6d10:	fc 01       	movw	r30, r24
    6d12:	82 81       	ldd	r24, Z+2	; 0x02
    6d14:	88 23       	and	r24, r24
    6d16:	d4 f7       	brge	.-12     	; 0x6d0c <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6d18:	80 ec       	ldi	r24, 0xC0	; 192
    6d1a:	98 e0       	ldi	r25, 0x08	; 8
    6d1c:	fc 01       	movw	r30, r24
    6d1e:	83 81       	ldd	r24, Z+3	; 0x03
    6d20:	80 93 69 50 	sts	0x5069, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d24:	89 81       	ldd	r24, Y+1	; 0x01
    6d26:	8f 5f       	subi	r24, 0xFF	; 255
    6d28:	89 83       	std	Y+1, r24	; 0x01
    6d2a:	89 81       	ldd	r24, Y+1	; 0x01
    6d2c:	83 30       	cpi	r24, 0x03	; 3
    6d2e:	10 f3       	brcs	.-60     	; 0x6cf4 <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    6d30:	80 e0       	ldi	r24, 0x00	; 0
    6d32:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>
	SPICS(FALSE);
    6d36:	80 e0       	ldi	r24, 0x00	; 0
    6d38:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    6d3c:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>


}
    6d40:	23 96       	adiw	r28, 0x03	; 3
    6d42:	cd bf       	out	0x3d, r28	; 61
    6d44:	de bf       	out	0x3e, r29	; 62
    6d46:	df 91       	pop	r29
    6d48:	cf 91       	pop	r28
    6d4a:	08 95       	ret

00006d4c <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6d4c:	cf 93       	push	r28
    6d4e:	df 93       	push	r29
    6d50:	00 d0       	rcall	.+0      	; 0x6d52 <PortEx_DIRCLR+0x6>
    6d52:	cd b7       	in	r28, 0x3d	; 61
    6d54:	de b7       	in	r29, 0x3e	; 62
    6d56:	8a 83       	std	Y+2, r24	; 0x02
    6d58:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    6d5a:	80 e0       	ldi	r24, 0x00	; 0
    6d5c:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    6d60:	81 e0       	ldi	r24, 0x01	; 1
    6d62:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	portExCS(TRUE);
    6d66:	81 e0       	ldi	r24, 0x01	; 1
    6d68:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    6d6e:	88 23       	and	r24, r24
    6d70:	49 f0       	breq	.+18     	; 0x6d84 <PortEx_DIRCLR+0x38>
    6d72:	80 91 72 50 	lds	r24, 0x5072
    6d76:	98 2f       	mov	r25, r24
    6d78:	90 95       	com	r25
    6d7a:	8a 81       	ldd	r24, Y+2	; 0x02
    6d7c:	89 23       	and	r24, r25
    6d7e:	80 93 72 50 	sts	0x5072, r24
    6d82:	08 c0       	rjmp	.+16     	; 0x6d94 <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    6d84:	80 91 c6 50 	lds	r24, 0x50C6
    6d88:	98 2f       	mov	r25, r24
    6d8a:	90 95       	com	r25
    6d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    6d8e:	89 23       	and	r24, r25
    6d90:	80 93 c6 50 	sts	0x50C6, r24
	
	SPIBuffer[0] = PS_WRITE;
    6d94:	80 e4       	ldi	r24, 0x40	; 64
    6d96:	80 93 5d 50 	sts	0x505D, r24
	if(bank) {
    6d9a:	8b 81       	ldd	r24, Y+3	; 0x03
    6d9c:	88 23       	and	r24, r24
    6d9e:	41 f0       	breq	.+16     	; 0x6db0 <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    6da0:	10 92 5e 50 	sts	0x505E, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6da4:	80 91 72 50 	lds	r24, 0x5072
    6da8:	80 95       	com	r24
    6daa:	80 93 5f 50 	sts	0x505F, r24
    6dae:	08 c0       	rjmp	.+16     	; 0x6dc0 <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6db0:	81 e0       	ldi	r24, 0x01	; 1
    6db2:	80 93 5e 50 	sts	0x505E, r24
		SPIBuffer[2] = ~bankB_DIR;
    6db6:	80 91 c6 50 	lds	r24, 0x50C6
    6dba:	80 95       	com	r24
    6dbc:	80 93 5f 50 	sts	0x505F, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6dc0:	19 82       	std	Y+1, r1	; 0x01
    6dc2:	1b c0       	rjmp	.+54     	; 0x6dfa <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    6dc4:	80 ec       	ldi	r24, 0xC0	; 192
    6dc6:	98 e0       	ldi	r25, 0x08	; 8
    6dc8:	29 81       	ldd	r18, Y+1	; 0x01
    6dca:	22 2f       	mov	r18, r18
    6dcc:	30 e0       	ldi	r19, 0x00	; 0
    6dce:	23 5a       	subi	r18, 0xA3	; 163
    6dd0:	3f 4a       	sbci	r19, 0xAF	; 175
    6dd2:	f9 01       	movw	r30, r18
    6dd4:	20 81       	ld	r18, Z
    6dd6:	fc 01       	movw	r30, r24
    6dd8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6dda:	00 00       	nop
    6ddc:	80 ec       	ldi	r24, 0xC0	; 192
    6dde:	98 e0       	ldi	r25, 0x08	; 8
    6de0:	fc 01       	movw	r30, r24
    6de2:	82 81       	ldd	r24, Z+2	; 0x02
    6de4:	88 23       	and	r24, r24
    6de6:	d4 f7       	brge	.-12     	; 0x6ddc <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6de8:	80 ec       	ldi	r24, 0xC0	; 192
    6dea:	98 e0       	ldi	r25, 0x08	; 8
    6dec:	fc 01       	movw	r30, r24
    6dee:	83 81       	ldd	r24, Z+3	; 0x03
    6df0:	80 93 69 50 	sts	0x5069, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6df4:	89 81       	ldd	r24, Y+1	; 0x01
    6df6:	8f 5f       	subi	r24, 0xFF	; 255
    6df8:	89 83       	std	Y+1, r24	; 0x01
    6dfa:	89 81       	ldd	r24, Y+1	; 0x01
    6dfc:	83 30       	cpi	r24, 0x03	; 3
    6dfe:	10 f3       	brcs	.-60     	; 0x6dc4 <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6e00:	80 e0       	ldi	r24, 0x00	; 0
    6e02:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	portExCS(FALSE);
    6e06:	80 e0       	ldi	r24, 0x00	; 0
    6e08:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>
	SPIDisable();
    6e0c:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
}
    6e10:	23 96       	adiw	r28, 0x03	; 3
    6e12:	cd bf       	out	0x3d, r28	; 61
    6e14:	de bf       	out	0x3e, r29	; 62
    6e16:	df 91       	pop	r29
    6e18:	cf 91       	pop	r28
    6e1a:	08 95       	ret

00006e1c <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6e1c:	cf 93       	push	r28
    6e1e:	df 93       	push	r29
    6e20:	00 d0       	rcall	.+0      	; 0x6e22 <PortEx_OUTSET+0x6>
    6e22:	cd b7       	in	r28, 0x3d	; 61
    6e24:	de b7       	in	r29, 0x3e	; 62
    6e26:	8a 83       	std	Y+2, r24	; 0x02
    6e28:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    6e2a:	80 e0       	ldi	r24, 0x00	; 0
    6e2c:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    6e30:	81 e0       	ldi	r24, 0x01	; 1
    6e32:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	portExCS(TRUE);
    6e36:	81 e0       	ldi	r24, 0x01	; 1
    6e38:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    6e3e:	88 23       	and	r24, r24
    6e40:	39 f0       	breq	.+14     	; 0x6e50 <PortEx_OUTSET+0x34>
    6e42:	90 91 ce 23 	lds	r25, 0x23CE
    6e46:	8a 81       	ldd	r24, Y+2	; 0x02
    6e48:	89 2b       	or	r24, r25
    6e4a:	80 93 ce 23 	sts	0x23CE, r24
    6e4e:	06 c0       	rjmp	.+12     	; 0x6e5c <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6e50:	90 91 7a 50 	lds	r25, 0x507A
    6e54:	8a 81       	ldd	r24, Y+2	; 0x02
    6e56:	89 2b       	or	r24, r25
    6e58:	80 93 7a 50 	sts	0x507A, r24
	
	SPIBuffer[0] = PS_WRITE;
    6e5c:	80 e4       	ldi	r24, 0x40	; 64
    6e5e:	80 93 5d 50 	sts	0x505D, r24
	if(bank) {
    6e62:	8b 81       	ldd	r24, Y+3	; 0x03
    6e64:	88 23       	and	r24, r24
    6e66:	41 f0       	breq	.+16     	; 0x6e78 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6e68:	84 e1       	ldi	r24, 0x14	; 20
    6e6a:	80 93 5e 50 	sts	0x505E, r24
		SPIBuffer[2] = bankA_OUT;
    6e6e:	80 91 ce 23 	lds	r24, 0x23CE
    6e72:	80 93 5f 50 	sts	0x505F, r24
    6e76:	07 c0       	rjmp	.+14     	; 0x6e86 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6e78:	85 e1       	ldi	r24, 0x15	; 21
    6e7a:	80 93 5e 50 	sts	0x505E, r24
		SPIBuffer[2] = bankB_OUT; 
    6e7e:	80 91 7a 50 	lds	r24, 0x507A
    6e82:	80 93 5f 50 	sts	0x505F, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6e86:	19 82       	std	Y+1, r1	; 0x01
    6e88:	1b c0       	rjmp	.+54     	; 0x6ec0 <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6e8a:	80 ec       	ldi	r24, 0xC0	; 192
    6e8c:	98 e0       	ldi	r25, 0x08	; 8
    6e8e:	29 81       	ldd	r18, Y+1	; 0x01
    6e90:	22 2f       	mov	r18, r18
    6e92:	30 e0       	ldi	r19, 0x00	; 0
    6e94:	23 5a       	subi	r18, 0xA3	; 163
    6e96:	3f 4a       	sbci	r19, 0xAF	; 175
    6e98:	f9 01       	movw	r30, r18
    6e9a:	20 81       	ld	r18, Z
    6e9c:	fc 01       	movw	r30, r24
    6e9e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6ea0:	00 00       	nop
    6ea2:	80 ec       	ldi	r24, 0xC0	; 192
    6ea4:	98 e0       	ldi	r25, 0x08	; 8
    6ea6:	fc 01       	movw	r30, r24
    6ea8:	82 81       	ldd	r24, Z+2	; 0x02
    6eaa:	88 23       	and	r24, r24
    6eac:	d4 f7       	brge	.-12     	; 0x6ea2 <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6eae:	80 ec       	ldi	r24, 0xC0	; 192
    6eb0:	98 e0       	ldi	r25, 0x08	; 8
    6eb2:	fc 01       	movw	r30, r24
    6eb4:	83 81       	ldd	r24, Z+3	; 0x03
    6eb6:	80 93 69 50 	sts	0x5069, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6eba:	89 81       	ldd	r24, Y+1	; 0x01
    6ebc:	8f 5f       	subi	r24, 0xFF	; 255
    6ebe:	89 83       	std	Y+1, r24	; 0x01
    6ec0:	89 81       	ldd	r24, Y+1	; 0x01
    6ec2:	83 30       	cpi	r24, 0x03	; 3
    6ec4:	10 f3       	brcs	.-60     	; 0x6e8a <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6ec6:	80 e0       	ldi	r24, 0x00	; 0
    6ec8:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	portExCS(FALSE);
    6ecc:	80 e0       	ldi	r24, 0x00	; 0
    6ece:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>
	SPIDisable();
    6ed2:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
}
    6ed6:	23 96       	adiw	r28, 0x03	; 3
    6ed8:	cd bf       	out	0x3d, r28	; 61
    6eda:	de bf       	out	0x3e, r29	; 62
    6edc:	df 91       	pop	r29
    6ede:	cf 91       	pop	r28
    6ee0:	08 95       	ret

00006ee2 <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    6ee2:	cf 93       	push	r28
    6ee4:	df 93       	push	r29
    6ee6:	00 d0       	rcall	.+0      	; 0x6ee8 <PortEx_OUTCLR+0x6>
    6ee8:	cd b7       	in	r28, 0x3d	; 61
    6eea:	de b7       	in	r29, 0x3e	; 62
    6eec:	8a 83       	std	Y+2, r24	; 0x02
    6eee:	6b 83       	std	Y+3, r22	; 0x03
	
	SPIInit(PS_SPI_MODE);
    6ef0:	80 e0       	ldi	r24, 0x00	; 0
    6ef2:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    6ef6:	81 e0       	ldi	r24, 0x01	; 1
    6ef8:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	portExCS(TRUE);
    6efc:	81 e0       	ldi	r24, 0x01	; 1
    6efe:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    6f02:	8b 81       	ldd	r24, Y+3	; 0x03
    6f04:	88 23       	and	r24, r24
    6f06:	49 f0       	breq	.+18     	; 0x6f1a <PortEx_OUTCLR+0x38>
    6f08:	8a 81       	ldd	r24, Y+2	; 0x02
    6f0a:	98 2f       	mov	r25, r24
    6f0c:	90 95       	com	r25
    6f0e:	80 91 ce 23 	lds	r24, 0x23CE
    6f12:	89 23       	and	r24, r25
    6f14:	80 93 ce 23 	sts	0x23CE, r24
    6f18:	08 c0       	rjmp	.+16     	; 0x6f2a <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    6f1c:	98 2f       	mov	r25, r24
    6f1e:	90 95       	com	r25
    6f20:	80 91 7a 50 	lds	r24, 0x507A
    6f24:	89 23       	and	r24, r25
    6f26:	80 93 7a 50 	sts	0x507A, r24
	
	SPIBuffer[0] = PS_WRITE;
    6f2a:	80 e4       	ldi	r24, 0x40	; 64
    6f2c:	80 93 5d 50 	sts	0x505D, r24
	if(bank) {
    6f30:	8b 81       	ldd	r24, Y+3	; 0x03
    6f32:	88 23       	and	r24, r24
    6f34:	41 f0       	breq	.+16     	; 0x6f46 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6f36:	84 e1       	ldi	r24, 0x14	; 20
    6f38:	80 93 5e 50 	sts	0x505E, r24
		SPIBuffer[2] = bankA_OUT;
    6f3c:	80 91 ce 23 	lds	r24, 0x23CE
    6f40:	80 93 5f 50 	sts	0x505F, r24
    6f44:	07 c0       	rjmp	.+14     	; 0x6f54 <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6f46:	85 e1       	ldi	r24, 0x15	; 21
    6f48:	80 93 5e 50 	sts	0x505E, r24
		SPIBuffer[2] = bankB_OUT; 
    6f4c:	80 91 7a 50 	lds	r24, 0x507A
    6f50:	80 93 5f 50 	sts	0x505F, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6f54:	19 82       	std	Y+1, r1	; 0x01
    6f56:	1b c0       	rjmp	.+54     	; 0x6f8e <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6f58:	80 ec       	ldi	r24, 0xC0	; 192
    6f5a:	98 e0       	ldi	r25, 0x08	; 8
    6f5c:	29 81       	ldd	r18, Y+1	; 0x01
    6f5e:	22 2f       	mov	r18, r18
    6f60:	30 e0       	ldi	r19, 0x00	; 0
    6f62:	23 5a       	subi	r18, 0xA3	; 163
    6f64:	3f 4a       	sbci	r19, 0xAF	; 175
    6f66:	f9 01       	movw	r30, r18
    6f68:	20 81       	ld	r18, Z
    6f6a:	fc 01       	movw	r30, r24
    6f6c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6f6e:	00 00       	nop
    6f70:	80 ec       	ldi	r24, 0xC0	; 192
    6f72:	98 e0       	ldi	r25, 0x08	; 8
    6f74:	fc 01       	movw	r30, r24
    6f76:	82 81       	ldd	r24, Z+2	; 0x02
    6f78:	88 23       	and	r24, r24
    6f7a:	d4 f7       	brge	.-12     	; 0x6f70 <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6f7c:	80 ec       	ldi	r24, 0xC0	; 192
    6f7e:	98 e0       	ldi	r25, 0x08	; 8
    6f80:	fc 01       	movw	r30, r24
    6f82:	83 81       	ldd	r24, Z+3	; 0x03
    6f84:	80 93 69 50 	sts	0x5069, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6f88:	89 81       	ldd	r24, Y+1	; 0x01
    6f8a:	8f 5f       	subi	r24, 0xFF	; 255
    6f8c:	89 83       	std	Y+1, r24	; 0x01
    6f8e:	89 81       	ldd	r24, Y+1	; 0x01
    6f90:	83 30       	cpi	r24, 0x03	; 3
    6f92:	10 f3       	brcs	.-60     	; 0x6f58 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6f94:	80 e0       	ldi	r24, 0x00	; 0
    6f96:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	portExCS(FALSE);
    6f9a:	80 e0       	ldi	r24, 0x00	; 0
    6f9c:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <portExCS>
	SPIDisable();
    6fa0:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
}
    6fa4:	23 96       	adiw	r28, 0x03	; 3
    6fa6:	cd bf       	out	0x3d, r28	; 61
    6fa8:	de bf       	out	0x3e, r29	; 62
    6faa:	df 91       	pop	r29
    6fac:	cf 91       	pop	r28
    6fae:	08 95       	ret

00006fb0 <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6fb0:	0f 93       	push	r16
    6fb2:	1f 93       	push	r17
    6fb4:	cf 93       	push	r28
    6fb6:	df 93       	push	r29
    6fb8:	cd b7       	in	r28, 0x3d	; 61
    6fba:	de b7       	in	r29, 0x3e	; 62
    6fbc:	2f 97       	sbiw	r28, 0x0f	; 15
    6fbe:	cd bf       	out	0x3d, r28	; 61
    6fc0:	de bf       	out	0x3e, r29	; 62
    6fc2:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
    6fc4:	8f 85       	ldd	r24, Y+15	; 0x0f
    6fc6:	88 23       	and	r24, r24
    6fc8:	09 f4       	brne	.+2      	; 0x6fcc <Ext1Power+0x1c>
    6fca:	8b c0       	rjmp	.+278    	; 0x70e2 <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6fcc:	80 ea       	ldi	r24, 0xA0	; 160
    6fce:	96 e0       	ldi	r25, 0x06	; 6
    6fd0:	20 e2       	ldi	r18, 0x20	; 32
    6fd2:	fc 01       	movw	r30, r24
    6fd4:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6fd6:	80 ea       	ldi	r24, 0xA0	; 160
    6fd8:	96 e0       	ldi	r25, 0x06	; 6
    6fda:	20 e2       	ldi	r18, 0x20	; 32
    6fdc:	fc 01       	movw	r30, r24
    6fde:	25 83       	std	Z+5, r18	; 0x05
    6fe0:	80 e0       	ldi	r24, 0x00	; 0
    6fe2:	90 e0       	ldi	r25, 0x00	; 0
    6fe4:	a8 ec       	ldi	r26, 0xC8	; 200
    6fe6:	b2 e4       	ldi	r27, 0x42	; 66
    6fe8:	89 83       	std	Y+1, r24	; 0x01
    6fea:	9a 83       	std	Y+2, r25	; 0x02
    6fec:	ab 83       	std	Y+3, r26	; 0x03
    6fee:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6ff0:	69 81       	ldd	r22, Y+1	; 0x01
    6ff2:	7a 81       	ldd	r23, Y+2	; 0x02
    6ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    6ff6:	9c 81       	ldd	r25, Y+4	; 0x04
    6ff8:	20 e0       	ldi	r18, 0x00	; 0
    6ffa:	30 e0       	ldi	r19, 0x00	; 0
    6ffc:	4a ef       	ldi	r20, 0xFA	; 250
    6ffe:	55 e4       	ldi	r21, 0x45	; 69
    7000:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7004:	dc 01       	movw	r26, r24
    7006:	cb 01       	movw	r24, r22
    7008:	8d 83       	std	Y+5, r24	; 0x05
    700a:	9e 83       	std	Y+6, r25	; 0x06
    700c:	af 83       	std	Y+7, r26	; 0x07
    700e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7010:	11 e0       	ldi	r17, 0x01	; 1
    7012:	6d 81       	ldd	r22, Y+5	; 0x05
    7014:	7e 81       	ldd	r23, Y+6	; 0x06
    7016:	8f 81       	ldd	r24, Y+7	; 0x07
    7018:	98 85       	ldd	r25, Y+8	; 0x08
    701a:	20 e0       	ldi	r18, 0x00	; 0
    701c:	30 e0       	ldi	r19, 0x00	; 0
    701e:	40 e8       	ldi	r20, 0x80	; 128
    7020:	5f e3       	ldi	r21, 0x3F	; 63
    7022:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7026:	88 23       	and	r24, r24
    7028:	0c f0       	brlt	.+2      	; 0x702c <Ext1Power+0x7c>
    702a:	10 e0       	ldi	r17, 0x00	; 0
    702c:	11 23       	and	r17, r17
    702e:	29 f0       	breq	.+10     	; 0x703a <Ext1Power+0x8a>
		__ticks = 1;
    7030:	81 e0       	ldi	r24, 0x01	; 1
    7032:	90 e0       	ldi	r25, 0x00	; 0
    7034:	89 87       	std	Y+9, r24	; 0x09
    7036:	9a 87       	std	Y+10, r25	; 0x0a
    7038:	46 c0       	rjmp	.+140    	; 0x70c6 <Ext1Power+0x116>
	else if (__tmp > 65535)
    703a:	11 e0       	ldi	r17, 0x01	; 1
    703c:	6d 81       	ldd	r22, Y+5	; 0x05
    703e:	7e 81       	ldd	r23, Y+6	; 0x06
    7040:	8f 81       	ldd	r24, Y+7	; 0x07
    7042:	98 85       	ldd	r25, Y+8	; 0x08
    7044:	20 e0       	ldi	r18, 0x00	; 0
    7046:	3f ef       	ldi	r19, 0xFF	; 255
    7048:	4f e7       	ldi	r20, 0x7F	; 127
    704a:	57 e4       	ldi	r21, 0x47	; 71
    704c:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    7050:	18 16       	cp	r1, r24
    7052:	0c f0       	brlt	.+2      	; 0x7056 <Ext1Power+0xa6>
    7054:	10 e0       	ldi	r17, 0x00	; 0
    7056:	11 23       	and	r17, r17
    7058:	61 f1       	breq	.+88     	; 0x70b2 <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    705a:	69 81       	ldd	r22, Y+1	; 0x01
    705c:	7a 81       	ldd	r23, Y+2	; 0x02
    705e:	8b 81       	ldd	r24, Y+3	; 0x03
    7060:	9c 81       	ldd	r25, Y+4	; 0x04
    7062:	20 e0       	ldi	r18, 0x00	; 0
    7064:	30 e0       	ldi	r19, 0x00	; 0
    7066:	40 e2       	ldi	r20, 0x20	; 32
    7068:	51 e4       	ldi	r21, 0x41	; 65
    706a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    706e:	dc 01       	movw	r26, r24
    7070:	cb 01       	movw	r24, r22
    7072:	bc 01       	movw	r22, r24
    7074:	cd 01       	movw	r24, r26
    7076:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    707a:	dc 01       	movw	r26, r24
    707c:	cb 01       	movw	r24, r22
    707e:	89 87       	std	Y+9, r24	; 0x09
    7080:	9a 87       	std	Y+10, r25	; 0x0a
    7082:	12 c0       	rjmp	.+36     	; 0x70a8 <Ext1Power+0xf8>
    7084:	80 e2       	ldi	r24, 0x20	; 32
    7086:	93 e0       	ldi	r25, 0x03	; 3
    7088:	8b 87       	std	Y+11, r24	; 0x0b
    708a:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    708c:	8b 85       	ldd	r24, Y+11	; 0x0b
    708e:	9c 85       	ldd	r25, Y+12	; 0x0c
    7090:	8c 01       	movw	r16, r24
    7092:	c8 01       	movw	r24, r16
    7094:	01 97       	sbiw	r24, 0x01	; 1
    7096:	f1 f7       	brne	.-4      	; 0x7094 <Ext1Power+0xe4>
    7098:	8c 01       	movw	r16, r24
    709a:	0b 87       	std	Y+11, r16	; 0x0b
    709c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    709e:	89 85       	ldd	r24, Y+9	; 0x09
    70a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    70a2:	01 97       	sbiw	r24, 0x01	; 1
    70a4:	89 87       	std	Y+9, r24	; 0x09
    70a6:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    70a8:	89 85       	ldd	r24, Y+9	; 0x09
    70aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    70ac:	00 97       	sbiw	r24, 0x00	; 0
    70ae:	51 f7       	brne	.-44     	; 0x7084 <Ext1Power+0xd4>
    70b0:	22 c0       	rjmp	.+68     	; 0x70f6 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    70b2:	6d 81       	ldd	r22, Y+5	; 0x05
    70b4:	7e 81       	ldd	r23, Y+6	; 0x06
    70b6:	8f 81       	ldd	r24, Y+7	; 0x07
    70b8:	98 85       	ldd	r25, Y+8	; 0x08
    70ba:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    70be:	dc 01       	movw	r26, r24
    70c0:	cb 01       	movw	r24, r22
    70c2:	89 87       	std	Y+9, r24	; 0x09
    70c4:	9a 87       	std	Y+10, r25	; 0x0a
    70c6:	89 85       	ldd	r24, Y+9	; 0x09
    70c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    70ca:	8d 87       	std	Y+13, r24	; 0x0d
    70cc:	9e 87       	std	Y+14, r25	; 0x0e
    70ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    70d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    70d2:	8c 01       	movw	r16, r24
    70d4:	f8 01       	movw	r30, r16
    70d6:	31 97       	sbiw	r30, 0x01	; 1
    70d8:	f1 f7       	brne	.-4      	; 0x70d6 <Ext1Power+0x126>
    70da:	8f 01       	movw	r16, r30
    70dc:	0d 87       	std	Y+13, r16	; 0x0d
    70de:	1e 87       	std	Y+14, r17	; 0x0e
    70e0:	0a c0       	rjmp	.+20     	; 0x70f6 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    70e2:	80 ea       	ldi	r24, 0xA0	; 160
    70e4:	96 e0       	ldi	r25, 0x06	; 6
    70e6:	20 e2       	ldi	r18, 0x20	; 32
    70e8:	fc 01       	movw	r30, r24
    70ea:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    70ec:	80 ea       	ldi	r24, 0xA0	; 160
    70ee:	96 e0       	ldi	r25, 0x06	; 6
    70f0:	20 e2       	ldi	r18, 0x20	; 32
    70f2:	fc 01       	movw	r30, r24
    70f4:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    70f6:	2f 96       	adiw	r28, 0x0f	; 15
    70f8:	cd bf       	out	0x3d, r28	; 61
    70fa:	de bf       	out	0x3e, r29	; 62
    70fc:	df 91       	pop	r29
    70fe:	cf 91       	pop	r28
    7100:	1f 91       	pop	r17
    7102:	0f 91       	pop	r16
    7104:	08 95       	ret

00007106 <Ext2Power>:

void Ext2Power(uint8_t on) {
    7106:	0f 93       	push	r16
    7108:	1f 93       	push	r17
    710a:	cf 93       	push	r28
    710c:	df 93       	push	r29
    710e:	cd b7       	in	r28, 0x3d	; 61
    7110:	de b7       	in	r29, 0x3e	; 62
    7112:	2f 97       	sbiw	r28, 0x0f	; 15
    7114:	cd bf       	out	0x3d, r28	; 61
    7116:	de bf       	out	0x3e, r29	; 62
    7118:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
    711a:	8f 85       	ldd	r24, Y+15	; 0x0f
    711c:	88 23       	and	r24, r24
    711e:	09 f4       	brne	.+2      	; 0x7122 <Ext2Power+0x1c>
    7120:	8b c0       	rjmp	.+278    	; 0x7238 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    7122:	80 ea       	ldi	r24, 0xA0	; 160
    7124:	96 e0       	ldi	r25, 0x06	; 6
    7126:	20 e4       	ldi	r18, 0x40	; 64
    7128:	fc 01       	movw	r30, r24
    712a:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    712c:	80 ea       	ldi	r24, 0xA0	; 160
    712e:	96 e0       	ldi	r25, 0x06	; 6
    7130:	20 e4       	ldi	r18, 0x40	; 64
    7132:	fc 01       	movw	r30, r24
    7134:	25 83       	std	Z+5, r18	; 0x05
    7136:	80 e0       	ldi	r24, 0x00	; 0
    7138:	90 e0       	ldi	r25, 0x00	; 0
    713a:	a8 ec       	ldi	r26, 0xC8	; 200
    713c:	b2 e4       	ldi	r27, 0x42	; 66
    713e:	89 83       	std	Y+1, r24	; 0x01
    7140:	9a 83       	std	Y+2, r25	; 0x02
    7142:	ab 83       	std	Y+3, r26	; 0x03
    7144:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7146:	69 81       	ldd	r22, Y+1	; 0x01
    7148:	7a 81       	ldd	r23, Y+2	; 0x02
    714a:	8b 81       	ldd	r24, Y+3	; 0x03
    714c:	9c 81       	ldd	r25, Y+4	; 0x04
    714e:	20 e0       	ldi	r18, 0x00	; 0
    7150:	30 e0       	ldi	r19, 0x00	; 0
    7152:	4a ef       	ldi	r20, 0xFA	; 250
    7154:	55 e4       	ldi	r21, 0x45	; 69
    7156:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    715a:	dc 01       	movw	r26, r24
    715c:	cb 01       	movw	r24, r22
    715e:	8d 83       	std	Y+5, r24	; 0x05
    7160:	9e 83       	std	Y+6, r25	; 0x06
    7162:	af 83       	std	Y+7, r26	; 0x07
    7164:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7166:	11 e0       	ldi	r17, 0x01	; 1
    7168:	6d 81       	ldd	r22, Y+5	; 0x05
    716a:	7e 81       	ldd	r23, Y+6	; 0x06
    716c:	8f 81       	ldd	r24, Y+7	; 0x07
    716e:	98 85       	ldd	r25, Y+8	; 0x08
    7170:	20 e0       	ldi	r18, 0x00	; 0
    7172:	30 e0       	ldi	r19, 0x00	; 0
    7174:	40 e8       	ldi	r20, 0x80	; 128
    7176:	5f e3       	ldi	r21, 0x3F	; 63
    7178:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    717c:	88 23       	and	r24, r24
    717e:	0c f0       	brlt	.+2      	; 0x7182 <Ext2Power+0x7c>
    7180:	10 e0       	ldi	r17, 0x00	; 0
    7182:	11 23       	and	r17, r17
    7184:	29 f0       	breq	.+10     	; 0x7190 <Ext2Power+0x8a>
		__ticks = 1;
    7186:	81 e0       	ldi	r24, 0x01	; 1
    7188:	90 e0       	ldi	r25, 0x00	; 0
    718a:	89 87       	std	Y+9, r24	; 0x09
    718c:	9a 87       	std	Y+10, r25	; 0x0a
    718e:	46 c0       	rjmp	.+140    	; 0x721c <Ext2Power+0x116>
	else if (__tmp > 65535)
    7190:	11 e0       	ldi	r17, 0x01	; 1
    7192:	6d 81       	ldd	r22, Y+5	; 0x05
    7194:	7e 81       	ldd	r23, Y+6	; 0x06
    7196:	8f 81       	ldd	r24, Y+7	; 0x07
    7198:	98 85       	ldd	r25, Y+8	; 0x08
    719a:	20 e0       	ldi	r18, 0x00	; 0
    719c:	3f ef       	ldi	r19, 0xFF	; 255
    719e:	4f e7       	ldi	r20, 0x7F	; 127
    71a0:	57 e4       	ldi	r21, 0x47	; 71
    71a2:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    71a6:	18 16       	cp	r1, r24
    71a8:	0c f0       	brlt	.+2      	; 0x71ac <Ext2Power+0xa6>
    71aa:	10 e0       	ldi	r17, 0x00	; 0
    71ac:	11 23       	and	r17, r17
    71ae:	61 f1       	breq	.+88     	; 0x7208 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    71b0:	69 81       	ldd	r22, Y+1	; 0x01
    71b2:	7a 81       	ldd	r23, Y+2	; 0x02
    71b4:	8b 81       	ldd	r24, Y+3	; 0x03
    71b6:	9c 81       	ldd	r25, Y+4	; 0x04
    71b8:	20 e0       	ldi	r18, 0x00	; 0
    71ba:	30 e0       	ldi	r19, 0x00	; 0
    71bc:	40 e2       	ldi	r20, 0x20	; 32
    71be:	51 e4       	ldi	r21, 0x41	; 65
    71c0:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    71c4:	dc 01       	movw	r26, r24
    71c6:	cb 01       	movw	r24, r22
    71c8:	bc 01       	movw	r22, r24
    71ca:	cd 01       	movw	r24, r26
    71cc:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    71d0:	dc 01       	movw	r26, r24
    71d2:	cb 01       	movw	r24, r22
    71d4:	89 87       	std	Y+9, r24	; 0x09
    71d6:	9a 87       	std	Y+10, r25	; 0x0a
    71d8:	12 c0       	rjmp	.+36     	; 0x71fe <Ext2Power+0xf8>
    71da:	80 e2       	ldi	r24, 0x20	; 32
    71dc:	93 e0       	ldi	r25, 0x03	; 3
    71de:	8b 87       	std	Y+11, r24	; 0x0b
    71e0:	9c 87       	std	Y+12, r25	; 0x0c
    71e2:	8b 85       	ldd	r24, Y+11	; 0x0b
    71e4:	9c 85       	ldd	r25, Y+12	; 0x0c
    71e6:	8c 01       	movw	r16, r24
    71e8:	c8 01       	movw	r24, r16
    71ea:	01 97       	sbiw	r24, 0x01	; 1
    71ec:	f1 f7       	brne	.-4      	; 0x71ea <Ext2Power+0xe4>
    71ee:	8c 01       	movw	r16, r24
    71f0:	0b 87       	std	Y+11, r16	; 0x0b
    71f2:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    71f4:	89 85       	ldd	r24, Y+9	; 0x09
    71f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    71f8:	01 97       	sbiw	r24, 0x01	; 1
    71fa:	89 87       	std	Y+9, r24	; 0x09
    71fc:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    71fe:	89 85       	ldd	r24, Y+9	; 0x09
    7200:	9a 85       	ldd	r25, Y+10	; 0x0a
    7202:	00 97       	sbiw	r24, 0x00	; 0
    7204:	51 f7       	brne	.-44     	; 0x71da <Ext2Power+0xd4>
    7206:	22 c0       	rjmp	.+68     	; 0x724c <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7208:	6d 81       	ldd	r22, Y+5	; 0x05
    720a:	7e 81       	ldd	r23, Y+6	; 0x06
    720c:	8f 81       	ldd	r24, Y+7	; 0x07
    720e:	98 85       	ldd	r25, Y+8	; 0x08
    7210:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7214:	dc 01       	movw	r26, r24
    7216:	cb 01       	movw	r24, r22
    7218:	89 87       	std	Y+9, r24	; 0x09
    721a:	9a 87       	std	Y+10, r25	; 0x0a
    721c:	89 85       	ldd	r24, Y+9	; 0x09
    721e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7220:	8d 87       	std	Y+13, r24	; 0x0d
    7222:	9e 87       	std	Y+14, r25	; 0x0e
    7224:	8d 85       	ldd	r24, Y+13	; 0x0d
    7226:	9e 85       	ldd	r25, Y+14	; 0x0e
    7228:	8c 01       	movw	r16, r24
    722a:	f8 01       	movw	r30, r16
    722c:	31 97       	sbiw	r30, 0x01	; 1
    722e:	f1 f7       	brne	.-4      	; 0x722c <Ext2Power+0x126>
    7230:	8f 01       	movw	r16, r30
    7232:	0d 87       	std	Y+13, r16	; 0x0d
    7234:	1e 87       	std	Y+14, r17	; 0x0e
    7236:	0a c0       	rjmp	.+20     	; 0x724c <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    7238:	80 ea       	ldi	r24, 0xA0	; 160
    723a:	96 e0       	ldi	r25, 0x06	; 6
    723c:	20 e4       	ldi	r18, 0x40	; 64
    723e:	fc 01       	movw	r30, r24
    7240:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    7242:	80 ea       	ldi	r24, 0xA0	; 160
    7244:	96 e0       	ldi	r25, 0x06	; 6
    7246:	20 e4       	ldi	r18, 0x40	; 64
    7248:	fc 01       	movw	r30, r24
    724a:	22 83       	std	Z+2, r18	; 0x02
	}
}
    724c:	2f 96       	adiw	r28, 0x0f	; 15
    724e:	cd bf       	out	0x3d, r28	; 61
    7250:	de bf       	out	0x3e, r29	; 62
    7252:	df 91       	pop	r29
    7254:	cf 91       	pop	r28
    7256:	1f 91       	pop	r17
    7258:	0f 91       	pop	r16
    725a:	08 95       	ret

0000725c <HVPower>:

void HVPower(uint8_t on) {
    725c:	0f 93       	push	r16
    725e:	1f 93       	push	r17
    7260:	cf 93       	push	r28
    7262:	df 93       	push	r29
    7264:	cd b7       	in	r28, 0x3d	; 61
    7266:	de b7       	in	r29, 0x3e	; 62
    7268:	a7 97       	sbiw	r28, 0x27	; 39
    726a:	cd bf       	out	0x3d, r28	; 61
    726c:	de bf       	out	0x3e, r29	; 62
    726e:	8f a3       	lds	r24, 0x5f
	
	if (on) {
    7270:	8f a1       	lds	r24, 0x4f
    7272:	88 23       	and	r24, r24
    7274:	09 f4       	brne	.+2      	; 0x7278 <HVPower+0x1c>
    7276:	8b c0       	rjmp	.+278    	; 0x738e <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    7278:	80 ea       	ldi	r24, 0xA0	; 160
    727a:	96 e0       	ldi	r25, 0x06	; 6
    727c:	20 e8       	ldi	r18, 0x80	; 128
    727e:	fc 01       	movw	r30, r24
    7280:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    7282:	80 ea       	ldi	r24, 0xA0	; 160
    7284:	96 e0       	ldi	r25, 0x06	; 6
    7286:	20 e8       	ldi	r18, 0x80	; 128
    7288:	fc 01       	movw	r30, r24
    728a:	25 83       	std	Z+5, r18	; 0x05
    728c:	80 e0       	ldi	r24, 0x00	; 0
    728e:	90 e0       	ldi	r25, 0x00	; 0
    7290:	a8 ec       	ldi	r26, 0xC8	; 200
    7292:	b2 e4       	ldi	r27, 0x42	; 66
    7294:	89 83       	std	Y+1, r24	; 0x01
    7296:	9a 83       	std	Y+2, r25	; 0x02
    7298:	ab 83       	std	Y+3, r26	; 0x03
    729a:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    729c:	69 81       	ldd	r22, Y+1	; 0x01
    729e:	7a 81       	ldd	r23, Y+2	; 0x02
    72a0:	8b 81       	ldd	r24, Y+3	; 0x03
    72a2:	9c 81       	ldd	r25, Y+4	; 0x04
    72a4:	20 e0       	ldi	r18, 0x00	; 0
    72a6:	30 e0       	ldi	r19, 0x00	; 0
    72a8:	4a ef       	ldi	r20, 0xFA	; 250
    72aa:	55 e4       	ldi	r21, 0x45	; 69
    72ac:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    72b0:	dc 01       	movw	r26, r24
    72b2:	cb 01       	movw	r24, r22
    72b4:	8d 83       	std	Y+5, r24	; 0x05
    72b6:	9e 83       	std	Y+6, r25	; 0x06
    72b8:	af 83       	std	Y+7, r26	; 0x07
    72ba:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    72bc:	11 e0       	ldi	r17, 0x01	; 1
    72be:	6d 81       	ldd	r22, Y+5	; 0x05
    72c0:	7e 81       	ldd	r23, Y+6	; 0x06
    72c2:	8f 81       	ldd	r24, Y+7	; 0x07
    72c4:	98 85       	ldd	r25, Y+8	; 0x08
    72c6:	20 e0       	ldi	r18, 0x00	; 0
    72c8:	30 e0       	ldi	r19, 0x00	; 0
    72ca:	40 e8       	ldi	r20, 0x80	; 128
    72cc:	5f e3       	ldi	r21, 0x3F	; 63
    72ce:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    72d2:	88 23       	and	r24, r24
    72d4:	0c f0       	brlt	.+2      	; 0x72d8 <HVPower+0x7c>
    72d6:	10 e0       	ldi	r17, 0x00	; 0
    72d8:	11 23       	and	r17, r17
    72da:	29 f0       	breq	.+10     	; 0x72e6 <HVPower+0x8a>
		__ticks = 1;
    72dc:	81 e0       	ldi	r24, 0x01	; 1
    72de:	90 e0       	ldi	r25, 0x00	; 0
    72e0:	89 87       	std	Y+9, r24	; 0x09
    72e2:	9a 87       	std	Y+10, r25	; 0x0a
    72e4:	46 c0       	rjmp	.+140    	; 0x7372 <HVPower+0x116>
	else if (__tmp > 65535)
    72e6:	11 e0       	ldi	r17, 0x01	; 1
    72e8:	6d 81       	ldd	r22, Y+5	; 0x05
    72ea:	7e 81       	ldd	r23, Y+6	; 0x06
    72ec:	8f 81       	ldd	r24, Y+7	; 0x07
    72ee:	98 85       	ldd	r25, Y+8	; 0x08
    72f0:	20 e0       	ldi	r18, 0x00	; 0
    72f2:	3f ef       	ldi	r19, 0xFF	; 255
    72f4:	4f e7       	ldi	r20, 0x7F	; 127
    72f6:	57 e4       	ldi	r21, 0x47	; 71
    72f8:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    72fc:	18 16       	cp	r1, r24
    72fe:	0c f0       	brlt	.+2      	; 0x7302 <HVPower+0xa6>
    7300:	10 e0       	ldi	r17, 0x00	; 0
    7302:	11 23       	and	r17, r17
    7304:	61 f1       	breq	.+88     	; 0x735e <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7306:	69 81       	ldd	r22, Y+1	; 0x01
    7308:	7a 81       	ldd	r23, Y+2	; 0x02
    730a:	8b 81       	ldd	r24, Y+3	; 0x03
    730c:	9c 81       	ldd	r25, Y+4	; 0x04
    730e:	20 e0       	ldi	r18, 0x00	; 0
    7310:	30 e0       	ldi	r19, 0x00	; 0
    7312:	40 e2       	ldi	r20, 0x20	; 32
    7314:	51 e4       	ldi	r21, 0x41	; 65
    7316:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    731a:	dc 01       	movw	r26, r24
    731c:	cb 01       	movw	r24, r22
    731e:	bc 01       	movw	r22, r24
    7320:	cd 01       	movw	r24, r26
    7322:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7326:	dc 01       	movw	r26, r24
    7328:	cb 01       	movw	r24, r22
    732a:	89 87       	std	Y+9, r24	; 0x09
    732c:	9a 87       	std	Y+10, r25	; 0x0a
    732e:	12 c0       	rjmp	.+36     	; 0x7354 <HVPower+0xf8>
    7330:	80 e2       	ldi	r24, 0x20	; 32
    7332:	93 e0       	ldi	r25, 0x03	; 3
    7334:	8b 87       	std	Y+11, r24	; 0x0b
    7336:	9c 87       	std	Y+12, r25	; 0x0c
    7338:	8b 85       	ldd	r24, Y+11	; 0x0b
    733a:	9c 85       	ldd	r25, Y+12	; 0x0c
    733c:	8c 01       	movw	r16, r24
    733e:	c8 01       	movw	r24, r16
    7340:	01 97       	sbiw	r24, 0x01	; 1
    7342:	f1 f7       	brne	.-4      	; 0x7340 <HVPower+0xe4>
    7344:	8c 01       	movw	r16, r24
    7346:	0b 87       	std	Y+11, r16	; 0x0b
    7348:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    734a:	89 85       	ldd	r24, Y+9	; 0x09
    734c:	9a 85       	ldd	r25, Y+10	; 0x0a
    734e:	01 97       	sbiw	r24, 0x01	; 1
    7350:	89 87       	std	Y+9, r24	; 0x09
    7352:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7354:	89 85       	ldd	r24, Y+9	; 0x09
    7356:	9a 85       	ldd	r25, Y+10	; 0x0a
    7358:	00 97       	sbiw	r24, 0x00	; 0
    735a:	51 f7       	brne	.-44     	; 0x7330 <HVPower+0xd4>
    735c:	22 c0       	rjmp	.+68     	; 0x73a2 <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    735e:	6d 81       	ldd	r22, Y+5	; 0x05
    7360:	7e 81       	ldd	r23, Y+6	; 0x06
    7362:	8f 81       	ldd	r24, Y+7	; 0x07
    7364:	98 85       	ldd	r25, Y+8	; 0x08
    7366:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    736a:	dc 01       	movw	r26, r24
    736c:	cb 01       	movw	r24, r22
    736e:	89 87       	std	Y+9, r24	; 0x09
    7370:	9a 87       	std	Y+10, r25	; 0x0a
    7372:	89 85       	ldd	r24, Y+9	; 0x09
    7374:	9a 85       	ldd	r25, Y+10	; 0x0a
    7376:	8d 87       	std	Y+13, r24	; 0x0d
    7378:	9e 87       	std	Y+14, r25	; 0x0e
    737a:	8d 85       	ldd	r24, Y+13	; 0x0d
    737c:	9e 85       	ldd	r25, Y+14	; 0x0e
    737e:	8c 01       	movw	r16, r24
    7380:	f8 01       	movw	r30, r16
    7382:	31 97       	sbiw	r30, 0x01	; 1
    7384:	f1 f7       	brne	.-4      	; 0x7382 <HVPower+0x126>
    7386:	8f 01       	movw	r16, r30
    7388:	0d 87       	std	Y+13, r16	; 0x0d
    738a:	1e 87       	std	Y+14, r17	; 0x0e
    738c:	0a c0       	rjmp	.+20     	; 0x73a2 <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    738e:	80 ea       	ldi	r24, 0xA0	; 160
    7390:	96 e0       	ldi	r25, 0x06	; 6
    7392:	20 e8       	ldi	r18, 0x80	; 128
    7394:	fc 01       	movw	r30, r24
    7396:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    7398:	80 ea       	ldi	r24, 0xA0	; 160
    739a:	96 e0       	ldi	r25, 0x06	; 6
    739c:	20 e8       	ldi	r18, 0x80	; 128
    739e:	fc 01       	movw	r30, r24
    73a0:	22 83       	std	Z+2, r18	; 0x02
    73a2:	80 e0       	ldi	r24, 0x00	; 0
    73a4:	90 e0       	ldi	r25, 0x00	; 0
    73a6:	aa e7       	ldi	r26, 0x7A	; 122
    73a8:	b4 e4       	ldi	r27, 0x44	; 68
    73aa:	8f 87       	std	Y+15, r24	; 0x0f
    73ac:	98 8b       	std	Y+16, r25	; 0x10
    73ae:	a9 8b       	std	Y+17, r26	; 0x11
    73b0:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    73b2:	6f 85       	ldd	r22, Y+15	; 0x0f
    73b4:	78 89       	ldd	r23, Y+16	; 0x10
    73b6:	89 89       	ldd	r24, Y+17	; 0x11
    73b8:	9a 89       	ldd	r25, Y+18	; 0x12
    73ba:	2b ea       	ldi	r18, 0xAB	; 171
    73bc:	3a ea       	ldi	r19, 0xAA	; 170
    73be:	4a e2       	ldi	r20, 0x2A	; 42
    73c0:	51 e4       	ldi	r21, 0x41	; 65
    73c2:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    73c6:	dc 01       	movw	r26, r24
    73c8:	cb 01       	movw	r24, r22
    73ca:	8b 8b       	std	Y+19, r24	; 0x13
    73cc:	9c 8b       	std	Y+20, r25	; 0x14
    73ce:	ad 8b       	std	Y+21, r26	; 0x15
    73d0:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    73d2:	11 e0       	ldi	r17, 0x01	; 1
    73d4:	6b 89       	ldd	r22, Y+19	; 0x13
    73d6:	7c 89       	ldd	r23, Y+20	; 0x14
    73d8:	8d 89       	ldd	r24, Y+21	; 0x15
    73da:	9e 89       	ldd	r25, Y+22	; 0x16
    73dc:	20 e0       	ldi	r18, 0x00	; 0
    73de:	30 e0       	ldi	r19, 0x00	; 0
    73e0:	40 e8       	ldi	r20, 0x80	; 128
    73e2:	5f e3       	ldi	r21, 0x3F	; 63
    73e4:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    73e8:	88 23       	and	r24, r24
    73ea:	0c f0       	brlt	.+2      	; 0x73ee <HVPower+0x192>
    73ec:	10 e0       	ldi	r17, 0x00	; 0
    73ee:	11 23       	and	r17, r17
    73f0:	19 f0       	breq	.+6      	; 0x73f8 <HVPower+0x19c>
		__ticks = 1;
    73f2:	81 e0       	ldi	r24, 0x01	; 1
    73f4:	8f 8b       	std	Y+23, r24	; 0x17
    73f6:	a3 c0       	rjmp	.+326    	; 0x753e <HVPower+0x2e2>
	else if (__tmp > 255)
    73f8:	11 e0       	ldi	r17, 0x01	; 1
    73fa:	6b 89       	ldd	r22, Y+19	; 0x13
    73fc:	7c 89       	ldd	r23, Y+20	; 0x14
    73fe:	8d 89       	ldd	r24, Y+21	; 0x15
    7400:	9e 89       	ldd	r25, Y+22	; 0x16
    7402:	20 e0       	ldi	r18, 0x00	; 0
    7404:	30 e0       	ldi	r19, 0x00	; 0
    7406:	4f e7       	ldi	r20, 0x7F	; 127
    7408:	53 e4       	ldi	r21, 0x43	; 67
    740a:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    740e:	18 16       	cp	r1, r24
    7410:	0c f0       	brlt	.+2      	; 0x7414 <HVPower+0x1b8>
    7412:	10 e0       	ldi	r17, 0x00	; 0
    7414:	11 23       	and	r17, r17
    7416:	09 f4       	brne	.+2      	; 0x741a <HVPower+0x1be>
    7418:	89 c0       	rjmp	.+274    	; 0x752c <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    741a:	6f 85       	ldd	r22, Y+15	; 0x0f
    741c:	78 89       	ldd	r23, Y+16	; 0x10
    741e:	89 89       	ldd	r24, Y+17	; 0x11
    7420:	9a 89       	ldd	r25, Y+18	; 0x12
    7422:	20 e0       	ldi	r18, 0x00	; 0
    7424:	30 e0       	ldi	r19, 0x00	; 0
    7426:	4a e7       	ldi	r20, 0x7A	; 122
    7428:	54 e4       	ldi	r21, 0x44	; 68
    742a:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    742e:	dc 01       	movw	r26, r24
    7430:	cb 01       	movw	r24, r22
    7432:	88 8f       	std	Y+24, r24	; 0x18
    7434:	99 8f       	std	Y+25, r25	; 0x19
    7436:	aa 8f       	std	Y+26, r26	; 0x1a
    7438:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    743a:	68 8d       	ldd	r22, Y+24	; 0x18
    743c:	79 8d       	ldd	r23, Y+25	; 0x19
    743e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7440:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7442:	20 e0       	ldi	r18, 0x00	; 0
    7444:	30 e0       	ldi	r19, 0x00	; 0
    7446:	4a ef       	ldi	r20, 0xFA	; 250
    7448:	55 e4       	ldi	r21, 0x45	; 69
    744a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    744e:	dc 01       	movw	r26, r24
    7450:	cb 01       	movw	r24, r22
    7452:	8c 8f       	std	Y+28, r24	; 0x1c
    7454:	9d 8f       	std	Y+29, r25	; 0x1d
    7456:	ae 8f       	std	Y+30, r26	; 0x1e
    7458:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    745a:	11 e0       	ldi	r17, 0x01	; 1
    745c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    745e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7460:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7462:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7464:	20 e0       	ldi	r18, 0x00	; 0
    7466:	30 e0       	ldi	r19, 0x00	; 0
    7468:	40 e8       	ldi	r20, 0x80	; 128
    746a:	5f e3       	ldi	r21, 0x3F	; 63
    746c:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7470:	88 23       	and	r24, r24
    7472:	0c f0       	brlt	.+2      	; 0x7476 <HVPower+0x21a>
    7474:	10 e0       	ldi	r17, 0x00	; 0
    7476:	11 23       	and	r17, r17
    7478:	29 f0       	breq	.+10     	; 0x7484 <HVPower+0x228>
		__ticks = 1;
    747a:	81 e0       	ldi	r24, 0x01	; 1
    747c:	90 e0       	ldi	r25, 0x00	; 0
    747e:	88 a3       	lds	r24, 0x58
    7480:	99 a3       	lds	r25, 0x59
    7482:	46 c0       	rjmp	.+140    	; 0x7510 <HVPower+0x2b4>
	else if (__tmp > 65535)
    7484:	11 e0       	ldi	r17, 0x01	; 1
    7486:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7488:	7d 8d       	ldd	r23, Y+29	; 0x1d
    748a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    748c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    748e:	20 e0       	ldi	r18, 0x00	; 0
    7490:	3f ef       	ldi	r19, 0xFF	; 255
    7492:	4f e7       	ldi	r20, 0x7F	; 127
    7494:	57 e4       	ldi	r21, 0x47	; 71
    7496:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    749a:	18 16       	cp	r1, r24
    749c:	0c f0       	brlt	.+2      	; 0x74a0 <HVPower+0x244>
    749e:	10 e0       	ldi	r17, 0x00	; 0
    74a0:	11 23       	and	r17, r17
    74a2:	61 f1       	breq	.+88     	; 0x74fc <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    74a4:	68 8d       	ldd	r22, Y+24	; 0x18
    74a6:	79 8d       	ldd	r23, Y+25	; 0x19
    74a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    74aa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    74ac:	20 e0       	ldi	r18, 0x00	; 0
    74ae:	30 e0       	ldi	r19, 0x00	; 0
    74b0:	40 e2       	ldi	r20, 0x20	; 32
    74b2:	51 e4       	ldi	r21, 0x41	; 65
    74b4:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    74b8:	dc 01       	movw	r26, r24
    74ba:	cb 01       	movw	r24, r22
    74bc:	bc 01       	movw	r22, r24
    74be:	cd 01       	movw	r24, r26
    74c0:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    74c4:	dc 01       	movw	r26, r24
    74c6:	cb 01       	movw	r24, r22
    74c8:	88 a3       	lds	r24, 0x58
    74ca:	99 a3       	lds	r25, 0x59
    74cc:	12 c0       	rjmp	.+36     	; 0x74f2 <HVPower+0x296>
    74ce:	80 e2       	ldi	r24, 0x20	; 32
    74d0:	93 e0       	ldi	r25, 0x03	; 3
    74d2:	8a a3       	lds	r24, 0x5a
    74d4:	9b a3       	lds	r25, 0x5b
    74d6:	8a a1       	lds	r24, 0x4a
    74d8:	9b a1       	lds	r25, 0x4b
    74da:	8c 01       	movw	r16, r24
    74dc:	c8 01       	movw	r24, r16
    74de:	01 97       	sbiw	r24, 0x01	; 1
    74e0:	f1 f7       	brne	.-4      	; 0x74de <HVPower+0x282>
    74e2:	8c 01       	movw	r16, r24
    74e4:	0a a3       	lds	r16, 0x5a
    74e6:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    74e8:	88 a1       	lds	r24, 0x48
    74ea:	99 a1       	lds	r25, 0x49
    74ec:	01 97       	sbiw	r24, 0x01	; 1
    74ee:	88 a3       	lds	r24, 0x58
    74f0:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    74f2:	88 a1       	lds	r24, 0x48
    74f4:	99 a1       	lds	r25, 0x49
    74f6:	00 97       	sbiw	r24, 0x00	; 0
    74f8:	51 f7       	brne	.-44     	; 0x74ce <HVPower+0x272>
    74fa:	28 c0       	rjmp	.+80     	; 0x754c <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    74fc:	6c 8d       	ldd	r22, Y+28	; 0x1c
    74fe:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7500:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7502:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7504:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7508:	dc 01       	movw	r26, r24
    750a:	cb 01       	movw	r24, r22
    750c:	88 a3       	lds	r24, 0x58
    750e:	99 a3       	lds	r25, 0x59
    7510:	88 a1       	lds	r24, 0x48
    7512:	99 a1       	lds	r25, 0x49
    7514:	8c a3       	lds	r24, 0x5c
    7516:	9d a3       	lds	r25, 0x5d
    7518:	8c a1       	lds	r24, 0x4c
    751a:	9d a1       	lds	r25, 0x4d
    751c:	8c 01       	movw	r16, r24
    751e:	f8 01       	movw	r30, r16
    7520:	31 97       	sbiw	r30, 0x01	; 1
    7522:	f1 f7       	brne	.-4      	; 0x7520 <HVPower+0x2c4>
    7524:	8f 01       	movw	r16, r30
    7526:	0c a3       	lds	r16, 0x5c
    7528:	1d a3       	lds	r17, 0x5d
    752a:	10 c0       	rjmp	.+32     	; 0x754c <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    752c:	6b 89       	ldd	r22, Y+19	; 0x13
    752e:	7c 89       	ldd	r23, Y+20	; 0x14
    7530:	8d 89       	ldd	r24, Y+21	; 0x15
    7532:	9e 89       	ldd	r25, Y+22	; 0x16
    7534:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7538:	dc 01       	movw	r26, r24
    753a:	cb 01       	movw	r24, r22
    753c:	8f 8b       	std	Y+23, r24	; 0x17
    753e:	8f 89       	ldd	r24, Y+23	; 0x17
    7540:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7542:	8e a1       	lds	r24, 0x4e
    7544:	18 2f       	mov	r17, r24
    7546:	1a 95       	dec	r17
    7548:	f1 f7       	brne	.-4      	; 0x7546 <HVPower+0x2ea>
    754a:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    754c:	a7 96       	adiw	r28, 0x27	; 39
    754e:	cd bf       	out	0x3d, r28	; 61
    7550:	de bf       	out	0x3e, r29	; 62
    7552:	df 91       	pop	r29
    7554:	cf 91       	pop	r28
    7556:	1f 91       	pop	r17
    7558:	0f 91       	pop	r16
    755a:	08 95       	ret

0000755c <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    755c:	cf 93       	push	r28
    755e:	df 93       	push	r29
    7560:	0f 92       	push	r0
    7562:	cd b7       	in	r28, 0x3d	; 61
    7564:	de b7       	in	r29, 0x3e	; 62
    7566:	89 83       	std	Y+1, r24	; 0x01
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    7568:	89 81       	ldd	r24, Y+1	; 0x01
    756a:	88 23       	and	r24, r24
    756c:	31 f0       	breq	.+12     	; 0x757a <lowerMuxCS+0x1e>
    756e:	80 e8       	ldi	r24, 0x80	; 128
    7570:	96 e0       	ldi	r25, 0x06	; 6
    7572:	20 e1       	ldi	r18, 0x10	; 16
    7574:	fc 01       	movw	r30, r24
    7576:	26 83       	std	Z+6, r18	; 0x06
    7578:	05 c0       	rjmp	.+10     	; 0x7584 <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    757a:	80 e8       	ldi	r24, 0x80	; 128
    757c:	96 e0       	ldi	r25, 0x06	; 6
    757e:	20 e1       	ldi	r18, 0x10	; 16
    7580:	fc 01       	movw	r30, r24
    7582:	25 83       	std	Z+5, r18	; 0x05
}
    7584:	0f 90       	pop	r0
    7586:	df 91       	pop	r29
    7588:	cf 91       	pop	r28
    758a:	08 95       	ret

0000758c <upperMuxCS>:

void upperMuxCS(uint8_t write) {
    758c:	cf 93       	push	r28
    758e:	df 93       	push	r29
    7590:	0f 92       	push	r0
    7592:	cd b7       	in	r28, 0x3d	; 61
    7594:	de b7       	in	r29, 0x3e	; 62
    7596:	89 83       	std	Y+1, r24	; 0x01
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    7598:	89 81       	ldd	r24, Y+1	; 0x01
    759a:	88 23       	and	r24, r24
    759c:	31 f0       	breq	.+12     	; 0x75aa <upperMuxCS+0x1e>
    759e:	80 e4       	ldi	r24, 0x40	; 64
    75a0:	96 e0       	ldi	r25, 0x06	; 6
    75a2:	22 e0       	ldi	r18, 0x02	; 2
    75a4:	fc 01       	movw	r30, r24
    75a6:	26 83       	std	Z+6, r18	; 0x06
    75a8:	05 c0       	rjmp	.+10     	; 0x75b4 <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    75aa:	80 e4       	ldi	r24, 0x40	; 64
    75ac:	96 e0       	ldi	r25, 0x06	; 6
    75ae:	22 e0       	ldi	r18, 0x02	; 2
    75b0:	fc 01       	movw	r30, r24
    75b2:	25 83       	std	Z+5, r18	; 0x05
}
    75b4:	0f 90       	pop	r0
    75b6:	df 91       	pop	r29
    75b8:	cf 91       	pop	r28
    75ba:	08 95       	ret

000075bc <SPIInit>:

void SPIInit(uint8_t mode) {
    75bc:	cf 93       	push	r28
    75be:	df 93       	push	r29
    75c0:	0f 92       	push	r0
    75c2:	cd b7       	in	r28, 0x3d	; 61
    75c4:	de b7       	in	r29, 0x3e	; 62
    75c6:	89 83       	std	Y+1, r24	; 0x01
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    75c8:	80 e4       	ldi	r24, 0x40	; 64
    75ca:	96 e0       	ldi	r25, 0x06	; 6
    75cc:	20 e1       	ldi	r18, 0x10	; 16
    75ce:	fc 01       	movw	r30, r24
    75d0:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    75d2:	80 e4       	ldi	r24, 0x40	; 64
    75d4:	96 e0       	ldi	r25, 0x06	; 6
    75d6:	28 e3       	ldi	r18, 0x38	; 56
    75d8:	fc 01       	movw	r30, r24
    75da:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    75dc:	80 e4       	ldi	r24, 0x40	; 64
    75de:	96 e0       	ldi	r25, 0x06	; 6
    75e0:	20 e1       	ldi	r18, 0x10	; 16
    75e2:	fc 01       	movw	r30, r24
    75e4:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    75e6:	80 ec       	ldi	r24, 0xC0	; 192
    75e8:	98 e0       	ldi	r25, 0x08	; 8
    75ea:	29 81       	ldd	r18, Y+1	; 0x01
    75ec:	21 65       	ori	r18, 0x51	; 81
    75ee:	fc 01       	movw	r30, r24
    75f0:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    75f2:	80 ec       	ldi	r24, 0xC0	; 192
    75f4:	98 e0       	ldi	r25, 0x08	; 8
    75f6:	fc 01       	movw	r30, r24
    75f8:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    75fa:	80 e4       	ldi	r24, 0x40	; 64
    75fc:	96 e0       	ldi	r25, 0x06	; 6
    75fe:	20 ea       	ldi	r18, 0xA0	; 160
    7600:	fc 01       	movw	r30, r24
    7602:	21 83       	std	Z+1, r18	; 0x01

	
}
    7604:	0f 90       	pop	r0
    7606:	df 91       	pop	r29
    7608:	cf 91       	pop	r28
    760a:	08 95       	ret

0000760c <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    760c:	cf 93       	push	r28
    760e:	df 93       	push	r29
    7610:	0f 92       	push	r0
    7612:	0f 92       	push	r0
    7614:	cd b7       	in	r28, 0x3d	; 61
    7616:	de b7       	in	r29, 0x3e	; 62
    7618:	89 83       	std	Y+1, r24	; 0x01
    761a:	6a 83       	std	Y+2, r22	; 0x02
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    761c:	80 e4       	ldi	r24, 0x40	; 64
    761e:	96 e0       	ldi	r25, 0x06	; 6
    7620:	20 e1       	ldi	r18, 0x10	; 16
    7622:	fc 01       	movw	r30, r24
    7624:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    7626:	80 e4       	ldi	r24, 0x40	; 64
    7628:	96 e0       	ldi	r25, 0x06	; 6
    762a:	28 e3       	ldi	r18, 0x38	; 56
    762c:	fc 01       	movw	r30, r24
    762e:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    7630:	80 e4       	ldi	r24, 0x40	; 64
    7632:	96 e0       	ldi	r25, 0x06	; 6
    7634:	20 e1       	ldi	r18, 0x10	; 16
    7636:	fc 01       	movw	r30, r24
    7638:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    763a:	80 ec       	ldi	r24, 0xC0	; 192
    763c:	98 e0       	ldi	r25, 0x08	; 8
    763e:	3a 81       	ldd	r19, Y+2	; 0x02
    7640:	29 81       	ldd	r18, Y+1	; 0x01
    7642:	23 2b       	or	r18, r19
    7644:	20 65       	ori	r18, 0x50	; 80
    7646:	fc 01       	movw	r30, r24
    7648:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    764a:	80 ec       	ldi	r24, 0xC0	; 192
    764c:	98 e0       	ldi	r25, 0x08	; 8
    764e:	fc 01       	movw	r30, r24
    7650:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    7652:	80 e4       	ldi	r24, 0x40	; 64
    7654:	96 e0       	ldi	r25, 0x06	; 6
    7656:	20 ea       	ldi	r18, 0xA0	; 160
    7658:	fc 01       	movw	r30, r24
    765a:	21 83       	std	Z+1, r18	; 0x01
}
    765c:	0f 90       	pop	r0
    765e:	0f 90       	pop	r0
    7660:	df 91       	pop	r29
    7662:	cf 91       	pop	r28
    7664:	08 95       	ret

00007666 <SPICS>:

void SPICS(uint8_t enable) {
    7666:	cf 93       	push	r28
    7668:	df 93       	push	r29
    766a:	0f 92       	push	r0
    766c:	cd b7       	in	r28, 0x3d	; 61
    766e:	de b7       	in	r29, 0x3e	; 62
    7670:	89 83       	std	Y+1, r24	; 0x01
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    7672:	89 81       	ldd	r24, Y+1	; 0x01
    7674:	88 23       	and	r24, r24
    7676:	31 f0       	breq	.+12     	; 0x7684 <SPICS+0x1e>
    7678:	80 e4       	ldi	r24, 0x40	; 64
    767a:	96 e0       	ldi	r25, 0x06	; 6
    767c:	20 e1       	ldi	r18, 0x10	; 16
    767e:	fc 01       	movw	r30, r24
    7680:	26 83       	std	Z+6, r18	; 0x06
    7682:	05 c0       	rjmp	.+10     	; 0x768e <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    7684:	80 e4       	ldi	r24, 0x40	; 64
    7686:	96 e0       	ldi	r25, 0x06	; 6
    7688:	20 e1       	ldi	r18, 0x10	; 16
    768a:	fc 01       	movw	r30, r24
    768c:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    768e:	0f 90       	pop	r0
    7690:	df 91       	pop	r29
    7692:	cf 91       	pop	r28
    7694:	08 95       	ret

00007696 <SPIDisable>:

void SPIDisable() {
    7696:	cf 93       	push	r28
    7698:	df 93       	push	r29
    769a:	cd b7       	in	r28, 0x3d	; 61
    769c:	de b7       	in	r29, 0x3e	; 62
	
	PORTC.OUTSET = PIN4_bm;
    769e:	80 e4       	ldi	r24, 0x40	; 64
    76a0:	96 e0       	ldi	r25, 0x06	; 6
    76a2:	20 e1       	ldi	r18, 0x10	; 16
    76a4:	fc 01       	movw	r30, r24
    76a6:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    76a8:	80 ec       	ldi	r24, 0xC0	; 192
    76aa:	98 e0       	ldi	r25, 0x08	; 8
    76ac:	fc 01       	movw	r30, r24
    76ae:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    76b0:	80 e4       	ldi	r24, 0x40	; 64
    76b2:	96 e0       	ldi	r25, 0x06	; 6
    76b4:	20 e1       	ldi	r18, 0x10	; 16
    76b6:	fc 01       	movw	r30, r24
    76b8:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    76ba:	80 e4       	ldi	r24, 0x40	; 64
    76bc:	96 e0       	ldi	r25, 0x06	; 6
    76be:	20 eb       	ldi	r18, 0xB0	; 176
    76c0:	fc 01       	movw	r30, r24
    76c2:	22 83       	std	Z+2, r18	; 0x02

}
    76c4:	df 91       	pop	r29
    76c6:	cf 91       	pop	r28
    76c8:	08 95       	ret

000076ca <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    76ca:	cf 93       	push	r28
    76cc:	df 93       	push	r29
    76ce:	00 d0       	rcall	.+0      	; 0x76d0 <readFRAM+0x6>
    76d0:	0f 92       	push	r0
    76d2:	cd b7       	in	r28, 0x3d	; 61
    76d4:	de b7       	in	r29, 0x3e	; 62
    76d6:	8b 83       	std	Y+3, r24	; 0x03
    76d8:	9c 83       	std	Y+4, r25	; 0x04
	
	SPIInit(SPI_MODE_0_gc);
    76da:	80 e0       	ldi	r24, 0x00	; 0
    76dc:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    76e0:	80 ec       	ldi	r24, 0xC0	; 192
    76e2:	98 e0       	ldi	r25, 0x08	; 8
    76e4:	20 ed       	ldi	r18, 0xD0	; 208
    76e6:	fc 01       	movw	r30, r24
    76e8:	20 83       	st	Z, r18
	SPICS(TRUE);
    76ea:	81 e0       	ldi	r24, 0x01	; 1
    76ec:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    76f0:	80 e2       	ldi	r24, 0x20	; 32
    76f2:	96 e0       	ldi	r25, 0x06	; 6
    76f4:	28 e0       	ldi	r18, 0x08	; 8
    76f6:	fc 01       	movw	r30, r24
    76f8:	26 83       	std	Z+6, r18	; 0x06
	nop();
    76fa:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    76fc:	80 ec       	ldi	r24, 0xC0	; 192
    76fe:	98 e0       	ldi	r25, 0x08	; 8
    7700:	23 e0       	ldi	r18, 0x03	; 3
    7702:	fc 01       	movw	r30, r24
    7704:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7706:	00 00       	nop
    7708:	80 ec       	ldi	r24, 0xC0	; 192
    770a:	98 e0       	ldi	r25, 0x08	; 8
    770c:	fc 01       	movw	r30, r24
    770e:	82 81       	ldd	r24, Z+2	; 0x02
    7710:	88 23       	and	r24, r24
    7712:	d4 f7       	brge	.-12     	; 0x7708 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    7714:	80 ec       	ldi	r24, 0xC0	; 192
    7716:	98 e0       	ldi	r25, 0x08	; 8
    7718:	fc 01       	movw	r30, r24
    771a:	83 81       	ldd	r24, Z+3	; 0x03
    771c:	80 93 69 50 	sts	0x5069, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    7720:	80 ec       	ldi	r24, 0xC0	; 192
    7722:	98 e0       	ldi	r25, 0x08	; 8
    7724:	20 91 50 40 	lds	r18, 0x4050
    7728:	fc 01       	movw	r30, r24
    772a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    772c:	00 00       	nop
    772e:	80 ec       	ldi	r24, 0xC0	; 192
    7730:	98 e0       	ldi	r25, 0x08	; 8
    7732:	fc 01       	movw	r30, r24
    7734:	82 81       	ldd	r24, Z+2	; 0x02
    7736:	88 23       	and	r24, r24
    7738:	d4 f7       	brge	.-12     	; 0x772e <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    773a:	80 ec       	ldi	r24, 0xC0	; 192
    773c:	98 e0       	ldi	r25, 0x08	; 8
    773e:	fc 01       	movw	r30, r24
    7740:	83 81       	ldd	r24, Z+3	; 0x03
    7742:	80 93 69 50 	sts	0x5069, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    7746:	80 ec       	ldi	r24, 0xC0	; 192
    7748:	98 e0       	ldi	r25, 0x08	; 8
    774a:	2f e4       	ldi	r18, 0x4F	; 79
    774c:	30 e4       	ldi	r19, 0x40	; 64
    774e:	f9 01       	movw	r30, r18
    7750:	20 81       	ld	r18, Z
    7752:	fc 01       	movw	r30, r24
    7754:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7756:	00 00       	nop
    7758:	80 ec       	ldi	r24, 0xC0	; 192
    775a:	98 e0       	ldi	r25, 0x08	; 8
    775c:	fc 01       	movw	r30, r24
    775e:	82 81       	ldd	r24, Z+2	; 0x02
    7760:	88 23       	and	r24, r24
    7762:	d4 f7       	brge	.-12     	; 0x7758 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    7764:	80 ec       	ldi	r24, 0xC0	; 192
    7766:	98 e0       	ldi	r25, 0x08	; 8
    7768:	fc 01       	movw	r30, r24
    776a:	83 81       	ldd	r24, Z+3	; 0x03
    776c:	80 93 69 50 	sts	0x5069, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7770:	19 82       	std	Y+1, r1	; 0x01
    7772:	1a 82       	std	Y+2, r1	; 0x02
    7774:	1b c0       	rjmp	.+54     	; 0x77ac <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    7776:	80 ec       	ldi	r24, 0xC0	; 192
    7778:	98 e0       	ldi	r25, 0x08	; 8
    777a:	2a ea       	ldi	r18, 0xAA	; 170
    777c:	fc 01       	movw	r30, r24
    777e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    7780:	00 00       	nop
    7782:	80 ec       	ldi	r24, 0xC0	; 192
    7784:	98 e0       	ldi	r25, 0x08	; 8
    7786:	fc 01       	movw	r30, r24
    7788:	82 81       	ldd	r24, Z+2	; 0x02
    778a:	88 23       	and	r24, r24
    778c:	d4 f7       	brge	.-12     	; 0x7782 <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    778e:	80 ec       	ldi	r24, 0xC0	; 192
    7790:	98 e0       	ldi	r25, 0x08	; 8
    7792:	fc 01       	movw	r30, r24
    7794:	23 81       	ldd	r18, Z+3	; 0x03
    7796:	89 81       	ldd	r24, Y+1	; 0x01
    7798:	9a 81       	ldd	r25, Y+2	; 0x02
    779a:	89 52       	subi	r24, 0x29	; 41
    779c:	9c 4d       	sbci	r25, 0xDC	; 220
    779e:	fc 01       	movw	r30, r24
    77a0:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    77a2:	89 81       	ldd	r24, Y+1	; 0x01
    77a4:	9a 81       	ldd	r25, Y+2	; 0x02
    77a6:	01 96       	adiw	r24, 0x01	; 1
    77a8:	89 83       	std	Y+1, r24	; 0x01
    77aa:	9a 83       	std	Y+2, r25	; 0x02
    77ac:	29 81       	ldd	r18, Y+1	; 0x01
    77ae:	3a 81       	ldd	r19, Y+2	; 0x02
    77b0:	8b 81       	ldd	r24, Y+3	; 0x03
    77b2:	9c 81       	ldd	r25, Y+4	; 0x04
    77b4:	28 17       	cp	r18, r24
    77b6:	39 07       	cpc	r19, r25
    77b8:	f0 f2       	brcs	.-68     	; 0x7776 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    77ba:	80 e2       	ldi	r24, 0x20	; 32
    77bc:	96 e0       	ldi	r25, 0x06	; 6
    77be:	28 e0       	ldi	r18, 0x08	; 8
    77c0:	fc 01       	movw	r30, r24
    77c2:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    77c4:	80 e0       	ldi	r24, 0x00	; 0
    77c6:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    77ca:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>

}
    77ce:	24 96       	adiw	r28, 0x04	; 4
    77d0:	cd bf       	out	0x3d, r28	; 61
    77d2:	de bf       	out	0x3e, r29	; 62
    77d4:	df 91       	pop	r29
    77d6:	cf 91       	pop	r28
    77d8:	08 95       	ret

000077da <FRAMTest3Channel>:

//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
    77da:	0f 93       	push	r16
    77dc:	1f 93       	push	r17
    77de:	cf 93       	push	r28
    77e0:	df 93       	push	r29
    77e2:	cd b7       	in	r28, 0x3d	; 61
    77e4:	de b7       	in	r29, 0x3e	; 62
    77e6:	68 97       	sbiw	r28, 0x18	; 24
    77e8:	cd bf       	out	0x3d, r28	; 61
    77ea:	de bf       	out	0x3e, r29	; 62
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    77ec:	81 e0       	ldi	r24, 0x01	; 1
    77ee:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
    77f2:	80 e0       	ldi	r24, 0x00	; 0
    77f4:	90 e0       	ldi	r25, 0x00	; 0
    77f6:	aa e7       	ldi	r26, 0x7A	; 122
    77f8:	b3 e4       	ldi	r27, 0x43	; 67
    77fa:	89 83       	std	Y+1, r24	; 0x01
    77fc:	9a 83       	std	Y+2, r25	; 0x02
    77fe:	ab 83       	std	Y+3, r26	; 0x03
    7800:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7802:	69 81       	ldd	r22, Y+1	; 0x01
    7804:	7a 81       	ldd	r23, Y+2	; 0x02
    7806:	8b 81       	ldd	r24, Y+3	; 0x03
    7808:	9c 81       	ldd	r25, Y+4	; 0x04
    780a:	2b ea       	ldi	r18, 0xAB	; 171
    780c:	3a ea       	ldi	r19, 0xAA	; 170
    780e:	4a e2       	ldi	r20, 0x2A	; 42
    7810:	51 e4       	ldi	r21, 0x41	; 65
    7812:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7816:	dc 01       	movw	r26, r24
    7818:	cb 01       	movw	r24, r22
    781a:	8d 83       	std	Y+5, r24	; 0x05
    781c:	9e 83       	std	Y+6, r25	; 0x06
    781e:	af 83       	std	Y+7, r26	; 0x07
    7820:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7822:	11 e0       	ldi	r17, 0x01	; 1
    7824:	6d 81       	ldd	r22, Y+5	; 0x05
    7826:	7e 81       	ldd	r23, Y+6	; 0x06
    7828:	8f 81       	ldd	r24, Y+7	; 0x07
    782a:	98 85       	ldd	r25, Y+8	; 0x08
    782c:	20 e0       	ldi	r18, 0x00	; 0
    782e:	30 e0       	ldi	r19, 0x00	; 0
    7830:	40 e8       	ldi	r20, 0x80	; 128
    7832:	5f e3       	ldi	r21, 0x3F	; 63
    7834:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7838:	88 23       	and	r24, r24
    783a:	0c f0       	brlt	.+2      	; 0x783e <FRAMTest3Channel+0x64>
    783c:	10 e0       	ldi	r17, 0x00	; 0
    783e:	11 23       	and	r17, r17
    7840:	19 f0       	breq	.+6      	; 0x7848 <FRAMTest3Channel+0x6e>
		__ticks = 1;
    7842:	81 e0       	ldi	r24, 0x01	; 1
    7844:	89 87       	std	Y+9, r24	; 0x09
    7846:	a3 c0       	rjmp	.+326    	; 0x798e <FRAMTest3Channel+0x1b4>
	else if (__tmp > 255)
    7848:	11 e0       	ldi	r17, 0x01	; 1
    784a:	6d 81       	ldd	r22, Y+5	; 0x05
    784c:	7e 81       	ldd	r23, Y+6	; 0x06
    784e:	8f 81       	ldd	r24, Y+7	; 0x07
    7850:	98 85       	ldd	r25, Y+8	; 0x08
    7852:	20 e0       	ldi	r18, 0x00	; 0
    7854:	30 e0       	ldi	r19, 0x00	; 0
    7856:	4f e7       	ldi	r20, 0x7F	; 127
    7858:	53 e4       	ldi	r21, 0x43	; 67
    785a:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    785e:	18 16       	cp	r1, r24
    7860:	0c f0       	brlt	.+2      	; 0x7864 <FRAMTest3Channel+0x8a>
    7862:	10 e0       	ldi	r17, 0x00	; 0
    7864:	11 23       	and	r17, r17
    7866:	09 f4       	brne	.+2      	; 0x786a <FRAMTest3Channel+0x90>
    7868:	89 c0       	rjmp	.+274    	; 0x797c <FRAMTest3Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    786a:	69 81       	ldd	r22, Y+1	; 0x01
    786c:	7a 81       	ldd	r23, Y+2	; 0x02
    786e:	8b 81       	ldd	r24, Y+3	; 0x03
    7870:	9c 81       	ldd	r25, Y+4	; 0x04
    7872:	20 e0       	ldi	r18, 0x00	; 0
    7874:	30 e0       	ldi	r19, 0x00	; 0
    7876:	4a e7       	ldi	r20, 0x7A	; 122
    7878:	54 e4       	ldi	r21, 0x44	; 68
    787a:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    787e:	dc 01       	movw	r26, r24
    7880:	cb 01       	movw	r24, r22
    7882:	8a 87       	std	Y+10, r24	; 0x0a
    7884:	9b 87       	std	Y+11, r25	; 0x0b
    7886:	ac 87       	std	Y+12, r26	; 0x0c
    7888:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    788a:	6a 85       	ldd	r22, Y+10	; 0x0a
    788c:	7b 85       	ldd	r23, Y+11	; 0x0b
    788e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7890:	9d 85       	ldd	r25, Y+13	; 0x0d
    7892:	20 e0       	ldi	r18, 0x00	; 0
    7894:	30 e0       	ldi	r19, 0x00	; 0
    7896:	4a ef       	ldi	r20, 0xFA	; 250
    7898:	55 e4       	ldi	r21, 0x45	; 69
    789a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    789e:	dc 01       	movw	r26, r24
    78a0:	cb 01       	movw	r24, r22
    78a2:	8e 87       	std	Y+14, r24	; 0x0e
    78a4:	9f 87       	std	Y+15, r25	; 0x0f
    78a6:	a8 8b       	std	Y+16, r26	; 0x10
    78a8:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    78aa:	11 e0       	ldi	r17, 0x01	; 1
    78ac:	6e 85       	ldd	r22, Y+14	; 0x0e
    78ae:	7f 85       	ldd	r23, Y+15	; 0x0f
    78b0:	88 89       	ldd	r24, Y+16	; 0x10
    78b2:	99 89       	ldd	r25, Y+17	; 0x11
    78b4:	20 e0       	ldi	r18, 0x00	; 0
    78b6:	30 e0       	ldi	r19, 0x00	; 0
    78b8:	40 e8       	ldi	r20, 0x80	; 128
    78ba:	5f e3       	ldi	r21, 0x3F	; 63
    78bc:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    78c0:	88 23       	and	r24, r24
    78c2:	0c f0       	brlt	.+2      	; 0x78c6 <FRAMTest3Channel+0xec>
    78c4:	10 e0       	ldi	r17, 0x00	; 0
    78c6:	11 23       	and	r17, r17
    78c8:	29 f0       	breq	.+10     	; 0x78d4 <FRAMTest3Channel+0xfa>
		__ticks = 1;
    78ca:	81 e0       	ldi	r24, 0x01	; 1
    78cc:	90 e0       	ldi	r25, 0x00	; 0
    78ce:	8a 8b       	std	Y+18, r24	; 0x12
    78d0:	9b 8b       	std	Y+19, r25	; 0x13
    78d2:	46 c0       	rjmp	.+140    	; 0x7960 <FRAMTest3Channel+0x186>
	else if (__tmp > 65535)
    78d4:	11 e0       	ldi	r17, 0x01	; 1
    78d6:	6e 85       	ldd	r22, Y+14	; 0x0e
    78d8:	7f 85       	ldd	r23, Y+15	; 0x0f
    78da:	88 89       	ldd	r24, Y+16	; 0x10
    78dc:	99 89       	ldd	r25, Y+17	; 0x11
    78de:	20 e0       	ldi	r18, 0x00	; 0
    78e0:	3f ef       	ldi	r19, 0xFF	; 255
    78e2:	4f e7       	ldi	r20, 0x7F	; 127
    78e4:	57 e4       	ldi	r21, 0x47	; 71
    78e6:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    78ea:	18 16       	cp	r1, r24
    78ec:	0c f0       	brlt	.+2      	; 0x78f0 <FRAMTest3Channel+0x116>
    78ee:	10 e0       	ldi	r17, 0x00	; 0
    78f0:	11 23       	and	r17, r17
    78f2:	61 f1       	breq	.+88     	; 0x794c <FRAMTest3Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    78f4:	6a 85       	ldd	r22, Y+10	; 0x0a
    78f6:	7b 85       	ldd	r23, Y+11	; 0x0b
    78f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    78fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    78fc:	20 e0       	ldi	r18, 0x00	; 0
    78fe:	30 e0       	ldi	r19, 0x00	; 0
    7900:	40 e2       	ldi	r20, 0x20	; 32
    7902:	51 e4       	ldi	r21, 0x41	; 65
    7904:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7908:	dc 01       	movw	r26, r24
    790a:	cb 01       	movw	r24, r22
    790c:	bc 01       	movw	r22, r24
    790e:	cd 01       	movw	r24, r26
    7910:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7914:	dc 01       	movw	r26, r24
    7916:	cb 01       	movw	r24, r22
    7918:	8a 8b       	std	Y+18, r24	; 0x12
    791a:	9b 8b       	std	Y+19, r25	; 0x13
    791c:	12 c0       	rjmp	.+36     	; 0x7942 <FRAMTest3Channel+0x168>
    791e:	80 e2       	ldi	r24, 0x20	; 32
    7920:	93 e0       	ldi	r25, 0x03	; 3
    7922:	8c 8b       	std	Y+20, r24	; 0x14
    7924:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7926:	8c 89       	ldd	r24, Y+20	; 0x14
    7928:	9d 89       	ldd	r25, Y+21	; 0x15
    792a:	8c 01       	movw	r16, r24
    792c:	c8 01       	movw	r24, r16
    792e:	01 97       	sbiw	r24, 0x01	; 1
    7930:	f1 f7       	brne	.-4      	; 0x792e <FRAMTest3Channel+0x154>
    7932:	8c 01       	movw	r16, r24
    7934:	0c 8b       	std	Y+20, r16	; 0x14
    7936:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7938:	8a 89       	ldd	r24, Y+18	; 0x12
    793a:	9b 89       	ldd	r25, Y+19	; 0x13
    793c:	01 97       	sbiw	r24, 0x01	; 1
    793e:	8a 8b       	std	Y+18, r24	; 0x12
    7940:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7942:	8a 89       	ldd	r24, Y+18	; 0x12
    7944:	9b 89       	ldd	r25, Y+19	; 0x13
    7946:	00 97       	sbiw	r24, 0x00	; 0
    7948:	51 f7       	brne	.-44     	; 0x791e <FRAMTest3Channel+0x144>
    794a:	28 c0       	rjmp	.+80     	; 0x799c <FRAMTest3Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    794c:	6e 85       	ldd	r22, Y+14	; 0x0e
    794e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7950:	88 89       	ldd	r24, Y+16	; 0x10
    7952:	99 89       	ldd	r25, Y+17	; 0x11
    7954:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7958:	dc 01       	movw	r26, r24
    795a:	cb 01       	movw	r24, r22
    795c:	8a 8b       	std	Y+18, r24	; 0x12
    795e:	9b 8b       	std	Y+19, r25	; 0x13
    7960:	8a 89       	ldd	r24, Y+18	; 0x12
    7962:	9b 89       	ldd	r25, Y+19	; 0x13
    7964:	8e 8b       	std	Y+22, r24	; 0x16
    7966:	9f 8b       	std	Y+23, r25	; 0x17
    7968:	8e 89       	ldd	r24, Y+22	; 0x16
    796a:	9f 89       	ldd	r25, Y+23	; 0x17
    796c:	8c 01       	movw	r16, r24
    796e:	c8 01       	movw	r24, r16
    7970:	01 97       	sbiw	r24, 0x01	; 1
    7972:	f1 f7       	brne	.-4      	; 0x7970 <FRAMTest3Channel+0x196>
    7974:	8c 01       	movw	r16, r24
    7976:	0e 8b       	std	Y+22, r16	; 0x16
    7978:	1f 8b       	std	Y+23, r17	; 0x17
    797a:	10 c0       	rjmp	.+32     	; 0x799c <FRAMTest3Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    797c:	6d 81       	ldd	r22, Y+5	; 0x05
    797e:	7e 81       	ldd	r23, Y+6	; 0x06
    7980:	8f 81       	ldd	r24, Y+7	; 0x07
    7982:	98 85       	ldd	r25, Y+8	; 0x08
    7984:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7988:	dc 01       	movw	r26, r24
    798a:	cb 01       	movw	r24, r22
    798c:	89 87       	std	Y+9, r24	; 0x09
    798e:	89 85       	ldd	r24, Y+9	; 0x09
    7990:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7992:	88 8d       	ldd	r24, Y+24	; 0x18
    7994:	18 2f       	mov	r17, r24
    7996:	1a 95       	dec	r17
    7998:	f1 f7       	brne	.-4      	; 0x7996 <FRAMTest3Channel+0x1bc>
    799a:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    799c:	0e 94 56 1a 	call	0x34ac	; 0x34ac <calcChecksumFRAM>

	ADCPower(FALSE);
    79a0:	80 e0       	ldi	r24, 0x00	; 0
    79a2:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	
}
    79a6:	68 96       	adiw	r28, 0x18	; 24
    79a8:	cd bf       	out	0x3d, r28	; 61
    79aa:	de bf       	out	0x3e, r29	; 62
    79ac:	df 91       	pop	r29
    79ae:	cf 91       	pop	r28
    79b0:	1f 91       	pop	r17
    79b2:	0f 91       	pop	r16
    79b4:	08 95       	ret

000079b6 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {
    79b6:	0f 93       	push	r16
    79b8:	1f 93       	push	r17
    79ba:	cf 93       	push	r28
    79bc:	df 93       	push	r29
    79be:	cd b7       	in	r28, 0x3d	; 61
    79c0:	de b7       	in	r29, 0x3e	; 62
    79c2:	68 97       	sbiw	r28, 0x18	; 24
    79c4:	cd bf       	out	0x3d, r28	; 61
    79c6:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    79c8:	81 e0       	ldi	r24, 0x01	; 1
    79ca:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
    79ce:	80 e0       	ldi	r24, 0x00	; 0
    79d0:	90 e0       	ldi	r25, 0x00	; 0
    79d2:	aa e7       	ldi	r26, 0x7A	; 122
    79d4:	b3 e4       	ldi	r27, 0x43	; 67
    79d6:	89 83       	std	Y+1, r24	; 0x01
    79d8:	9a 83       	std	Y+2, r25	; 0x02
    79da:	ab 83       	std	Y+3, r26	; 0x03
    79dc:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    79de:	69 81       	ldd	r22, Y+1	; 0x01
    79e0:	7a 81       	ldd	r23, Y+2	; 0x02
    79e2:	8b 81       	ldd	r24, Y+3	; 0x03
    79e4:	9c 81       	ldd	r25, Y+4	; 0x04
    79e6:	2b ea       	ldi	r18, 0xAB	; 171
    79e8:	3a ea       	ldi	r19, 0xAA	; 170
    79ea:	4a e2       	ldi	r20, 0x2A	; 42
    79ec:	51 e4       	ldi	r21, 0x41	; 65
    79ee:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    79f2:	dc 01       	movw	r26, r24
    79f4:	cb 01       	movw	r24, r22
    79f6:	8d 83       	std	Y+5, r24	; 0x05
    79f8:	9e 83       	std	Y+6, r25	; 0x06
    79fa:	af 83       	std	Y+7, r26	; 0x07
    79fc:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    79fe:	11 e0       	ldi	r17, 0x01	; 1
    7a00:	6d 81       	ldd	r22, Y+5	; 0x05
    7a02:	7e 81       	ldd	r23, Y+6	; 0x06
    7a04:	8f 81       	ldd	r24, Y+7	; 0x07
    7a06:	98 85       	ldd	r25, Y+8	; 0x08
    7a08:	20 e0       	ldi	r18, 0x00	; 0
    7a0a:	30 e0       	ldi	r19, 0x00	; 0
    7a0c:	40 e8       	ldi	r20, 0x80	; 128
    7a0e:	5f e3       	ldi	r21, 0x3F	; 63
    7a10:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7a14:	88 23       	and	r24, r24
    7a16:	0c f0       	brlt	.+2      	; 0x7a1a <FRAMTest1Channel+0x64>
    7a18:	10 e0       	ldi	r17, 0x00	; 0
    7a1a:	11 23       	and	r17, r17
    7a1c:	19 f0       	breq	.+6      	; 0x7a24 <FRAMTest1Channel+0x6e>
		__ticks = 1;
    7a1e:	81 e0       	ldi	r24, 0x01	; 1
    7a20:	89 87       	std	Y+9, r24	; 0x09
    7a22:	a3 c0       	rjmp	.+326    	; 0x7b6a <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    7a24:	11 e0       	ldi	r17, 0x01	; 1
    7a26:	6d 81       	ldd	r22, Y+5	; 0x05
    7a28:	7e 81       	ldd	r23, Y+6	; 0x06
    7a2a:	8f 81       	ldd	r24, Y+7	; 0x07
    7a2c:	98 85       	ldd	r25, Y+8	; 0x08
    7a2e:	20 e0       	ldi	r18, 0x00	; 0
    7a30:	30 e0       	ldi	r19, 0x00	; 0
    7a32:	4f e7       	ldi	r20, 0x7F	; 127
    7a34:	53 e4       	ldi	r21, 0x43	; 67
    7a36:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    7a3a:	18 16       	cp	r1, r24
    7a3c:	0c f0       	brlt	.+2      	; 0x7a40 <FRAMTest1Channel+0x8a>
    7a3e:	10 e0       	ldi	r17, 0x00	; 0
    7a40:	11 23       	and	r17, r17
    7a42:	09 f4       	brne	.+2      	; 0x7a46 <FRAMTest1Channel+0x90>
    7a44:	89 c0       	rjmp	.+274    	; 0x7b58 <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    7a46:	69 81       	ldd	r22, Y+1	; 0x01
    7a48:	7a 81       	ldd	r23, Y+2	; 0x02
    7a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    7a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    7a4e:	20 e0       	ldi	r18, 0x00	; 0
    7a50:	30 e0       	ldi	r19, 0x00	; 0
    7a52:	4a e7       	ldi	r20, 0x7A	; 122
    7a54:	54 e4       	ldi	r21, 0x44	; 68
    7a56:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    7a5a:	dc 01       	movw	r26, r24
    7a5c:	cb 01       	movw	r24, r22
    7a5e:	8a 87       	std	Y+10, r24	; 0x0a
    7a60:	9b 87       	std	Y+11, r25	; 0x0b
    7a62:	ac 87       	std	Y+12, r26	; 0x0c
    7a64:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7a66:	6a 85       	ldd	r22, Y+10	; 0x0a
    7a68:	7b 85       	ldd	r23, Y+11	; 0x0b
    7a6a:	8c 85       	ldd	r24, Y+12	; 0x0c
    7a6c:	9d 85       	ldd	r25, Y+13	; 0x0d
    7a6e:	20 e0       	ldi	r18, 0x00	; 0
    7a70:	30 e0       	ldi	r19, 0x00	; 0
    7a72:	4a ef       	ldi	r20, 0xFA	; 250
    7a74:	55 e4       	ldi	r21, 0x45	; 69
    7a76:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7a7a:	dc 01       	movw	r26, r24
    7a7c:	cb 01       	movw	r24, r22
    7a7e:	8e 87       	std	Y+14, r24	; 0x0e
    7a80:	9f 87       	std	Y+15, r25	; 0x0f
    7a82:	a8 8b       	std	Y+16, r26	; 0x10
    7a84:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7a86:	11 e0       	ldi	r17, 0x01	; 1
    7a88:	6e 85       	ldd	r22, Y+14	; 0x0e
    7a8a:	7f 85       	ldd	r23, Y+15	; 0x0f
    7a8c:	88 89       	ldd	r24, Y+16	; 0x10
    7a8e:	99 89       	ldd	r25, Y+17	; 0x11
    7a90:	20 e0       	ldi	r18, 0x00	; 0
    7a92:	30 e0       	ldi	r19, 0x00	; 0
    7a94:	40 e8       	ldi	r20, 0x80	; 128
    7a96:	5f e3       	ldi	r21, 0x3F	; 63
    7a98:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7a9c:	88 23       	and	r24, r24
    7a9e:	0c f0       	brlt	.+2      	; 0x7aa2 <FRAMTest1Channel+0xec>
    7aa0:	10 e0       	ldi	r17, 0x00	; 0
    7aa2:	11 23       	and	r17, r17
    7aa4:	29 f0       	breq	.+10     	; 0x7ab0 <FRAMTest1Channel+0xfa>
		__ticks = 1;
    7aa6:	81 e0       	ldi	r24, 0x01	; 1
    7aa8:	90 e0       	ldi	r25, 0x00	; 0
    7aaa:	8a 8b       	std	Y+18, r24	; 0x12
    7aac:	9b 8b       	std	Y+19, r25	; 0x13
    7aae:	46 c0       	rjmp	.+140    	; 0x7b3c <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    7ab0:	11 e0       	ldi	r17, 0x01	; 1
    7ab2:	6e 85       	ldd	r22, Y+14	; 0x0e
    7ab4:	7f 85       	ldd	r23, Y+15	; 0x0f
    7ab6:	88 89       	ldd	r24, Y+16	; 0x10
    7ab8:	99 89       	ldd	r25, Y+17	; 0x11
    7aba:	20 e0       	ldi	r18, 0x00	; 0
    7abc:	3f ef       	ldi	r19, 0xFF	; 255
    7abe:	4f e7       	ldi	r20, 0x7F	; 127
    7ac0:	57 e4       	ldi	r21, 0x47	; 71
    7ac2:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    7ac6:	18 16       	cp	r1, r24
    7ac8:	0c f0       	brlt	.+2      	; 0x7acc <FRAMTest1Channel+0x116>
    7aca:	10 e0       	ldi	r17, 0x00	; 0
    7acc:	11 23       	and	r17, r17
    7ace:	61 f1       	breq	.+88     	; 0x7b28 <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7ad0:	6a 85       	ldd	r22, Y+10	; 0x0a
    7ad2:	7b 85       	ldd	r23, Y+11	; 0x0b
    7ad4:	8c 85       	ldd	r24, Y+12	; 0x0c
    7ad6:	9d 85       	ldd	r25, Y+13	; 0x0d
    7ad8:	20 e0       	ldi	r18, 0x00	; 0
    7ada:	30 e0       	ldi	r19, 0x00	; 0
    7adc:	40 e2       	ldi	r20, 0x20	; 32
    7ade:	51 e4       	ldi	r21, 0x41	; 65
    7ae0:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7ae4:	dc 01       	movw	r26, r24
    7ae6:	cb 01       	movw	r24, r22
    7ae8:	bc 01       	movw	r22, r24
    7aea:	cd 01       	movw	r24, r26
    7aec:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7af0:	dc 01       	movw	r26, r24
    7af2:	cb 01       	movw	r24, r22
    7af4:	8a 8b       	std	Y+18, r24	; 0x12
    7af6:	9b 8b       	std	Y+19, r25	; 0x13
    7af8:	12 c0       	rjmp	.+36     	; 0x7b1e <FRAMTest1Channel+0x168>
    7afa:	80 e2       	ldi	r24, 0x20	; 32
    7afc:	93 e0       	ldi	r25, 0x03	; 3
    7afe:	8c 8b       	std	Y+20, r24	; 0x14
    7b00:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b02:	8c 89       	ldd	r24, Y+20	; 0x14
    7b04:	9d 89       	ldd	r25, Y+21	; 0x15
    7b06:	8c 01       	movw	r16, r24
    7b08:	c8 01       	movw	r24, r16
    7b0a:	01 97       	sbiw	r24, 0x01	; 1
    7b0c:	f1 f7       	brne	.-4      	; 0x7b0a <FRAMTest1Channel+0x154>
    7b0e:	8c 01       	movw	r16, r24
    7b10:	0c 8b       	std	Y+20, r16	; 0x14
    7b12:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b14:	8a 89       	ldd	r24, Y+18	; 0x12
    7b16:	9b 89       	ldd	r25, Y+19	; 0x13
    7b18:	01 97       	sbiw	r24, 0x01	; 1
    7b1a:	8a 8b       	std	Y+18, r24	; 0x12
    7b1c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b1e:	8a 89       	ldd	r24, Y+18	; 0x12
    7b20:	9b 89       	ldd	r25, Y+19	; 0x13
    7b22:	00 97       	sbiw	r24, 0x00	; 0
    7b24:	51 f7       	brne	.-44     	; 0x7afa <FRAMTest1Channel+0x144>
    7b26:	28 c0       	rjmp	.+80     	; 0x7b78 <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b28:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b2a:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b2c:	88 89       	ldd	r24, Y+16	; 0x10
    7b2e:	99 89       	ldd	r25, Y+17	; 0x11
    7b30:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7b34:	dc 01       	movw	r26, r24
    7b36:	cb 01       	movw	r24, r22
    7b38:	8a 8b       	std	Y+18, r24	; 0x12
    7b3a:	9b 8b       	std	Y+19, r25	; 0x13
    7b3c:	8a 89       	ldd	r24, Y+18	; 0x12
    7b3e:	9b 89       	ldd	r25, Y+19	; 0x13
    7b40:	8e 8b       	std	Y+22, r24	; 0x16
    7b42:	9f 8b       	std	Y+23, r25	; 0x17
    7b44:	8e 89       	ldd	r24, Y+22	; 0x16
    7b46:	9f 89       	ldd	r25, Y+23	; 0x17
    7b48:	8c 01       	movw	r16, r24
    7b4a:	c8 01       	movw	r24, r16
    7b4c:	01 97       	sbiw	r24, 0x01	; 1
    7b4e:	f1 f7       	brne	.-4      	; 0x7b4c <FRAMTest1Channel+0x196>
    7b50:	8c 01       	movw	r16, r24
    7b52:	0e 8b       	std	Y+22, r16	; 0x16
    7b54:	1f 8b       	std	Y+23, r17	; 0x17
    7b56:	10 c0       	rjmp	.+32     	; 0x7b78 <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7b58:	6d 81       	ldd	r22, Y+5	; 0x05
    7b5a:	7e 81       	ldd	r23, Y+6	; 0x06
    7b5c:	8f 81       	ldd	r24, Y+7	; 0x07
    7b5e:	98 85       	ldd	r25, Y+8	; 0x08
    7b60:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7b64:	dc 01       	movw	r26, r24
    7b66:	cb 01       	movw	r24, r22
    7b68:	89 87       	std	Y+9, r24	; 0x09
    7b6a:	89 85       	ldd	r24, Y+9	; 0x09
    7b6c:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7b6e:	88 8d       	ldd	r24, Y+24	; 0x18
    7b70:	18 2f       	mov	r17, r24
    7b72:	1a 95       	dec	r17
    7b74:	f1 f7       	brne	.-4      	; 0x7b72 <FRAMTest1Channel+0x1bc>
    7b76:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7b78:	0e 94 56 1a 	call	0x34ac	; 0x34ac <calcChecksumFRAM>

	ADCPower(FALSE);
    7b7c:	80 e0       	ldi	r24, 0x00	; 0
    7b7e:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>

}
    7b82:	68 96       	adiw	r28, 0x18	; 24
    7b84:	cd bf       	out	0x3d, r28	; 61
    7b86:	de bf       	out	0x3e, r29	; 62
    7b88:	df 91       	pop	r29
    7b8a:	cf 91       	pop	r28
    7b8c:	1f 91       	pop	r17
    7b8e:	0f 91       	pop	r16
    7b90:	08 95       	ret

00007b92 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7b92:	0f 93       	push	r16
    7b94:	1f 93       	push	r17
    7b96:	cf 93       	push	r28
    7b98:	df 93       	push	r29
    7b9a:	cd b7       	in	r28, 0x3d	; 61
    7b9c:	de b7       	in	r29, 0x3e	; 62
    7b9e:	68 97       	sbiw	r28, 0x18	; 24
    7ba0:	cd bf       	out	0x3d, r28	; 61
    7ba2:	de bf       	out	0x3e, r29	; 62
	
	FRAMWriteKnowns();
    7ba4:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <FRAMWriteKnowns>
	ADCPower(TRUE);
    7ba8:	81 e0       	ldi	r24, 0x01	; 1
    7baa:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
    7bae:	80 e0       	ldi	r24, 0x00	; 0
    7bb0:	90 e0       	ldi	r25, 0x00	; 0
    7bb2:	aa e7       	ldi	r26, 0x7A	; 122
    7bb4:	b3 e4       	ldi	r27, 0x43	; 67
    7bb6:	89 83       	std	Y+1, r24	; 0x01
    7bb8:	9a 83       	std	Y+2, r25	; 0x02
    7bba:	ab 83       	std	Y+3, r26	; 0x03
    7bbc:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7bbe:	69 81       	ldd	r22, Y+1	; 0x01
    7bc0:	7a 81       	ldd	r23, Y+2	; 0x02
    7bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    7bc4:	9c 81       	ldd	r25, Y+4	; 0x04
    7bc6:	2b ea       	ldi	r18, 0xAB	; 171
    7bc8:	3a ea       	ldi	r19, 0xAA	; 170
    7bca:	4a e2       	ldi	r20, 0x2A	; 42
    7bcc:	51 e4       	ldi	r21, 0x41	; 65
    7bce:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7bd2:	dc 01       	movw	r26, r24
    7bd4:	cb 01       	movw	r24, r22
    7bd6:	8d 83       	std	Y+5, r24	; 0x05
    7bd8:	9e 83       	std	Y+6, r25	; 0x06
    7bda:	af 83       	std	Y+7, r26	; 0x07
    7bdc:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7bde:	11 e0       	ldi	r17, 0x01	; 1
    7be0:	6d 81       	ldd	r22, Y+5	; 0x05
    7be2:	7e 81       	ldd	r23, Y+6	; 0x06
    7be4:	8f 81       	ldd	r24, Y+7	; 0x07
    7be6:	98 85       	ldd	r25, Y+8	; 0x08
    7be8:	20 e0       	ldi	r18, 0x00	; 0
    7bea:	30 e0       	ldi	r19, 0x00	; 0
    7bec:	40 e8       	ldi	r20, 0x80	; 128
    7bee:	5f e3       	ldi	r21, 0x3F	; 63
    7bf0:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7bf4:	88 23       	and	r24, r24
    7bf6:	0c f0       	brlt	.+2      	; 0x7bfa <FRAMWriteKnownsCheck+0x68>
    7bf8:	10 e0       	ldi	r17, 0x00	; 0
    7bfa:	11 23       	and	r17, r17
    7bfc:	19 f0       	breq	.+6      	; 0x7c04 <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    7bfe:	81 e0       	ldi	r24, 0x01	; 1
    7c00:	89 87       	std	Y+9, r24	; 0x09
    7c02:	a3 c0       	rjmp	.+326    	; 0x7d4a <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7c04:	11 e0       	ldi	r17, 0x01	; 1
    7c06:	6d 81       	ldd	r22, Y+5	; 0x05
    7c08:	7e 81       	ldd	r23, Y+6	; 0x06
    7c0a:	8f 81       	ldd	r24, Y+7	; 0x07
    7c0c:	98 85       	ldd	r25, Y+8	; 0x08
    7c0e:	20 e0       	ldi	r18, 0x00	; 0
    7c10:	30 e0       	ldi	r19, 0x00	; 0
    7c12:	4f e7       	ldi	r20, 0x7F	; 127
    7c14:	53 e4       	ldi	r21, 0x43	; 67
    7c16:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    7c1a:	18 16       	cp	r1, r24
    7c1c:	0c f0       	brlt	.+2      	; 0x7c20 <FRAMWriteKnownsCheck+0x8e>
    7c1e:	10 e0       	ldi	r17, 0x00	; 0
    7c20:	11 23       	and	r17, r17
    7c22:	09 f4       	brne	.+2      	; 0x7c26 <FRAMWriteKnownsCheck+0x94>
    7c24:	89 c0       	rjmp	.+274    	; 0x7d38 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7c26:	69 81       	ldd	r22, Y+1	; 0x01
    7c28:	7a 81       	ldd	r23, Y+2	; 0x02
    7c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    7c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    7c2e:	20 e0       	ldi	r18, 0x00	; 0
    7c30:	30 e0       	ldi	r19, 0x00	; 0
    7c32:	4a e7       	ldi	r20, 0x7A	; 122
    7c34:	54 e4       	ldi	r21, 0x44	; 68
    7c36:	0e 94 a0 5e 	call	0xbd40	; 0xbd40 <__divsf3>
    7c3a:	dc 01       	movw	r26, r24
    7c3c:	cb 01       	movw	r24, r22
    7c3e:	8a 87       	std	Y+10, r24	; 0x0a
    7c40:	9b 87       	std	Y+11, r25	; 0x0b
    7c42:	ac 87       	std	Y+12, r26	; 0x0c
    7c44:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7c46:	6a 85       	ldd	r22, Y+10	; 0x0a
    7c48:	7b 85       	ldd	r23, Y+11	; 0x0b
    7c4a:	8c 85       	ldd	r24, Y+12	; 0x0c
    7c4c:	9d 85       	ldd	r25, Y+13	; 0x0d
    7c4e:	20 e0       	ldi	r18, 0x00	; 0
    7c50:	30 e0       	ldi	r19, 0x00	; 0
    7c52:	4a ef       	ldi	r20, 0xFA	; 250
    7c54:	55 e4       	ldi	r21, 0x45	; 69
    7c56:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7c5a:	dc 01       	movw	r26, r24
    7c5c:	cb 01       	movw	r24, r22
    7c5e:	8e 87       	std	Y+14, r24	; 0x0e
    7c60:	9f 87       	std	Y+15, r25	; 0x0f
    7c62:	a8 8b       	std	Y+16, r26	; 0x10
    7c64:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7c66:	11 e0       	ldi	r17, 0x01	; 1
    7c68:	6e 85       	ldd	r22, Y+14	; 0x0e
    7c6a:	7f 85       	ldd	r23, Y+15	; 0x0f
    7c6c:	88 89       	ldd	r24, Y+16	; 0x10
    7c6e:	99 89       	ldd	r25, Y+17	; 0x11
    7c70:	20 e0       	ldi	r18, 0x00	; 0
    7c72:	30 e0       	ldi	r19, 0x00	; 0
    7c74:	40 e8       	ldi	r20, 0x80	; 128
    7c76:	5f e3       	ldi	r21, 0x3F	; 63
    7c78:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7c7c:	88 23       	and	r24, r24
    7c7e:	0c f0       	brlt	.+2      	; 0x7c82 <FRAMWriteKnownsCheck+0xf0>
    7c80:	10 e0       	ldi	r17, 0x00	; 0
    7c82:	11 23       	and	r17, r17
    7c84:	29 f0       	breq	.+10     	; 0x7c90 <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    7c86:	81 e0       	ldi	r24, 0x01	; 1
    7c88:	90 e0       	ldi	r25, 0x00	; 0
    7c8a:	8a 8b       	std	Y+18, r24	; 0x12
    7c8c:	9b 8b       	std	Y+19, r25	; 0x13
    7c8e:	46 c0       	rjmp	.+140    	; 0x7d1c <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7c90:	11 e0       	ldi	r17, 0x01	; 1
    7c92:	6e 85       	ldd	r22, Y+14	; 0x0e
    7c94:	7f 85       	ldd	r23, Y+15	; 0x0f
    7c96:	88 89       	ldd	r24, Y+16	; 0x10
    7c98:	99 89       	ldd	r25, Y+17	; 0x11
    7c9a:	20 e0       	ldi	r18, 0x00	; 0
    7c9c:	3f ef       	ldi	r19, 0xFF	; 255
    7c9e:	4f e7       	ldi	r20, 0x7F	; 127
    7ca0:	57 e4       	ldi	r21, 0x47	; 71
    7ca2:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    7ca6:	18 16       	cp	r1, r24
    7ca8:	0c f0       	brlt	.+2      	; 0x7cac <FRAMWriteKnownsCheck+0x11a>
    7caa:	10 e0       	ldi	r17, 0x00	; 0
    7cac:	11 23       	and	r17, r17
    7cae:	61 f1       	breq	.+88     	; 0x7d08 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7cb0:	6a 85       	ldd	r22, Y+10	; 0x0a
    7cb2:	7b 85       	ldd	r23, Y+11	; 0x0b
    7cb4:	8c 85       	ldd	r24, Y+12	; 0x0c
    7cb6:	9d 85       	ldd	r25, Y+13	; 0x0d
    7cb8:	20 e0       	ldi	r18, 0x00	; 0
    7cba:	30 e0       	ldi	r19, 0x00	; 0
    7cbc:	40 e2       	ldi	r20, 0x20	; 32
    7cbe:	51 e4       	ldi	r21, 0x41	; 65
    7cc0:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7cc4:	dc 01       	movw	r26, r24
    7cc6:	cb 01       	movw	r24, r22
    7cc8:	bc 01       	movw	r22, r24
    7cca:	cd 01       	movw	r24, r26
    7ccc:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7cd0:	dc 01       	movw	r26, r24
    7cd2:	cb 01       	movw	r24, r22
    7cd4:	8a 8b       	std	Y+18, r24	; 0x12
    7cd6:	9b 8b       	std	Y+19, r25	; 0x13
    7cd8:	12 c0       	rjmp	.+36     	; 0x7cfe <FRAMWriteKnownsCheck+0x16c>
    7cda:	80 e2       	ldi	r24, 0x20	; 32
    7cdc:	93 e0       	ldi	r25, 0x03	; 3
    7cde:	8c 8b       	std	Y+20, r24	; 0x14
    7ce0:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7ce2:	8c 89       	ldd	r24, Y+20	; 0x14
    7ce4:	9d 89       	ldd	r25, Y+21	; 0x15
    7ce6:	8c 01       	movw	r16, r24
    7ce8:	c8 01       	movw	r24, r16
    7cea:	01 97       	sbiw	r24, 0x01	; 1
    7cec:	f1 f7       	brne	.-4      	; 0x7cea <FRAMWriteKnownsCheck+0x158>
    7cee:	8c 01       	movw	r16, r24
    7cf0:	0c 8b       	std	Y+20, r16	; 0x14
    7cf2:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7cf4:	8a 89       	ldd	r24, Y+18	; 0x12
    7cf6:	9b 89       	ldd	r25, Y+19	; 0x13
    7cf8:	01 97       	sbiw	r24, 0x01	; 1
    7cfa:	8a 8b       	std	Y+18, r24	; 0x12
    7cfc:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7cfe:	8a 89       	ldd	r24, Y+18	; 0x12
    7d00:	9b 89       	ldd	r25, Y+19	; 0x13
    7d02:	00 97       	sbiw	r24, 0x00	; 0
    7d04:	51 f7       	brne	.-44     	; 0x7cda <FRAMWriteKnownsCheck+0x148>
    7d06:	28 c0       	rjmp	.+80     	; 0x7d58 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7d08:	6e 85       	ldd	r22, Y+14	; 0x0e
    7d0a:	7f 85       	ldd	r23, Y+15	; 0x0f
    7d0c:	88 89       	ldd	r24, Y+16	; 0x10
    7d0e:	99 89       	ldd	r25, Y+17	; 0x11
    7d10:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7d14:	dc 01       	movw	r26, r24
    7d16:	cb 01       	movw	r24, r22
    7d18:	8a 8b       	std	Y+18, r24	; 0x12
    7d1a:	9b 8b       	std	Y+19, r25	; 0x13
    7d1c:	8a 89       	ldd	r24, Y+18	; 0x12
    7d1e:	9b 89       	ldd	r25, Y+19	; 0x13
    7d20:	8e 8b       	std	Y+22, r24	; 0x16
    7d22:	9f 8b       	std	Y+23, r25	; 0x17
    7d24:	8e 89       	ldd	r24, Y+22	; 0x16
    7d26:	9f 89       	ldd	r25, Y+23	; 0x17
    7d28:	8c 01       	movw	r16, r24
    7d2a:	c8 01       	movw	r24, r16
    7d2c:	01 97       	sbiw	r24, 0x01	; 1
    7d2e:	f1 f7       	brne	.-4      	; 0x7d2c <FRAMWriteKnownsCheck+0x19a>
    7d30:	8c 01       	movw	r16, r24
    7d32:	0e 8b       	std	Y+22, r16	; 0x16
    7d34:	1f 8b       	std	Y+23, r17	; 0x17
    7d36:	10 c0       	rjmp	.+32     	; 0x7d58 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7d38:	6d 81       	ldd	r22, Y+5	; 0x05
    7d3a:	7e 81       	ldd	r23, Y+6	; 0x06
    7d3c:	8f 81       	ldd	r24, Y+7	; 0x07
    7d3e:	98 85       	ldd	r25, Y+8	; 0x08
    7d40:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7d44:	dc 01       	movw	r26, r24
    7d46:	cb 01       	movw	r24, r22
    7d48:	89 87       	std	Y+9, r24	; 0x09
    7d4a:	89 85       	ldd	r24, Y+9	; 0x09
    7d4c:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7d4e:	88 8d       	ldd	r24, Y+24	; 0x18
    7d50:	18 2f       	mov	r17, r24
    7d52:	1a 95       	dec	r17
    7d54:	f1 f7       	brne	.-4      	; 0x7d52 <FRAMWriteKnownsCheck+0x1c0>
    7d56:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7d58:	0e 94 56 1a 	call	0x34ac	; 0x34ac <calcChecksumFRAM>

	ADCPower(FALSE);
    7d5c:	80 e0       	ldi	r24, 0x00	; 0
    7d5e:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>

}
    7d62:	68 96       	adiw	r28, 0x18	; 24
    7d64:	cd bf       	out	0x3d, r28	; 61
    7d66:	de bf       	out	0x3e, r29	; 62
    7d68:	df 91       	pop	r29
    7d6a:	cf 91       	pop	r28
    7d6c:	1f 91       	pop	r17
    7d6e:	0f 91       	pop	r16
    7d70:	08 95       	ret

00007d72 <checkMote>:

//random function for testing stuff	
void checkMote(){
    7d72:	0f 93       	push	r16
    7d74:	1f 93       	push	r17
    7d76:	cf 93       	push	r28
    7d78:	df 93       	push	r29
    7d7a:	cd b7       	in	r28, 0x3d	; 61
    7d7c:	de b7       	in	r29, 0x3e	; 62
    7d7e:	aa 97       	sbiw	r28, 0x2a	; 42
    7d80:	cd bf       	out	0x3d, r28	; 61
    7d82:	de bf       	out	0x3e, r29	; 62
	
	ADCPower(TRUE);
    7d84:	81 e0       	ldi	r24, 0x01	; 1
    7d86:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	Ext1Power(TRUE);
    7d8a:	81 e0       	ldi	r24, 0x01	; 1
    7d8c:	0e 94 d8 37 	call	0x6fb0	; 0x6fb0 <Ext1Power>
    7d90:	80 e0       	ldi	r24, 0x00	; 0
    7d92:	90 e0       	ldi	r25, 0x00	; 0
    7d94:	a8 ec       	ldi	r26, 0xC8	; 200
    7d96:	b2 e4       	ldi	r27, 0x42	; 66
    7d98:	89 83       	std	Y+1, r24	; 0x01
    7d9a:	9a 83       	std	Y+2, r25	; 0x02
    7d9c:	ab 83       	std	Y+3, r26	; 0x03
    7d9e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7da0:	69 81       	ldd	r22, Y+1	; 0x01
    7da2:	7a 81       	ldd	r23, Y+2	; 0x02
    7da4:	8b 81       	ldd	r24, Y+3	; 0x03
    7da6:	9c 81       	ldd	r25, Y+4	; 0x04
    7da8:	20 e0       	ldi	r18, 0x00	; 0
    7daa:	30 e0       	ldi	r19, 0x00	; 0
    7dac:	4a ef       	ldi	r20, 0xFA	; 250
    7dae:	55 e4       	ldi	r21, 0x45	; 69
    7db0:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7db4:	dc 01       	movw	r26, r24
    7db6:	cb 01       	movw	r24, r22
    7db8:	8d 83       	std	Y+5, r24	; 0x05
    7dba:	9e 83       	std	Y+6, r25	; 0x06
    7dbc:	af 83       	std	Y+7, r26	; 0x07
    7dbe:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7dc0:	11 e0       	ldi	r17, 0x01	; 1
    7dc2:	6d 81       	ldd	r22, Y+5	; 0x05
    7dc4:	7e 81       	ldd	r23, Y+6	; 0x06
    7dc6:	8f 81       	ldd	r24, Y+7	; 0x07
    7dc8:	98 85       	ldd	r25, Y+8	; 0x08
    7dca:	20 e0       	ldi	r18, 0x00	; 0
    7dcc:	30 e0       	ldi	r19, 0x00	; 0
    7dce:	40 e8       	ldi	r20, 0x80	; 128
    7dd0:	5f e3       	ldi	r21, 0x3F	; 63
    7dd2:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7dd6:	88 23       	and	r24, r24
    7dd8:	0c f0       	brlt	.+2      	; 0x7ddc <checkMote+0x6a>
    7dda:	10 e0       	ldi	r17, 0x00	; 0
    7ddc:	11 23       	and	r17, r17
    7dde:	29 f0       	breq	.+10     	; 0x7dea <checkMote+0x78>
		__ticks = 1;
    7de0:	81 e0       	ldi	r24, 0x01	; 1
    7de2:	90 e0       	ldi	r25, 0x00	; 0
    7de4:	89 87       	std	Y+9, r24	; 0x09
    7de6:	9a 87       	std	Y+10, r25	; 0x0a
    7de8:	46 c0       	rjmp	.+140    	; 0x7e76 <checkMote+0x104>
	else if (__tmp > 65535)
    7dea:	11 e0       	ldi	r17, 0x01	; 1
    7dec:	6d 81       	ldd	r22, Y+5	; 0x05
    7dee:	7e 81       	ldd	r23, Y+6	; 0x06
    7df0:	8f 81       	ldd	r24, Y+7	; 0x07
    7df2:	98 85       	ldd	r25, Y+8	; 0x08
    7df4:	20 e0       	ldi	r18, 0x00	; 0
    7df6:	3f ef       	ldi	r19, 0xFF	; 255
    7df8:	4f e7       	ldi	r20, 0x7F	; 127
    7dfa:	57 e4       	ldi	r21, 0x47	; 71
    7dfc:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    7e00:	18 16       	cp	r1, r24
    7e02:	0c f0       	brlt	.+2      	; 0x7e06 <checkMote+0x94>
    7e04:	10 e0       	ldi	r17, 0x00	; 0
    7e06:	11 23       	and	r17, r17
    7e08:	61 f1       	breq	.+88     	; 0x7e62 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7e0a:	69 81       	ldd	r22, Y+1	; 0x01
    7e0c:	7a 81       	ldd	r23, Y+2	; 0x02
    7e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    7e10:	9c 81       	ldd	r25, Y+4	; 0x04
    7e12:	20 e0       	ldi	r18, 0x00	; 0
    7e14:	30 e0       	ldi	r19, 0x00	; 0
    7e16:	40 e2       	ldi	r20, 0x20	; 32
    7e18:	51 e4       	ldi	r21, 0x41	; 65
    7e1a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7e1e:	dc 01       	movw	r26, r24
    7e20:	cb 01       	movw	r24, r22
    7e22:	bc 01       	movw	r22, r24
    7e24:	cd 01       	movw	r24, r26
    7e26:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7e2a:	dc 01       	movw	r26, r24
    7e2c:	cb 01       	movw	r24, r22
    7e2e:	89 87       	std	Y+9, r24	; 0x09
    7e30:	9a 87       	std	Y+10, r25	; 0x0a
    7e32:	12 c0       	rjmp	.+36     	; 0x7e58 <checkMote+0xe6>
    7e34:	80 e2       	ldi	r24, 0x20	; 32
    7e36:	93 e0       	ldi	r25, 0x03	; 3
    7e38:	8b 87       	std	Y+11, r24	; 0x0b
    7e3a:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7e3c:	8b 85       	ldd	r24, Y+11	; 0x0b
    7e3e:	9c 85       	ldd	r25, Y+12	; 0x0c
    7e40:	8c 01       	movw	r16, r24
    7e42:	c8 01       	movw	r24, r16
    7e44:	01 97       	sbiw	r24, 0x01	; 1
    7e46:	f1 f7       	brne	.-4      	; 0x7e44 <checkMote+0xd2>
    7e48:	8c 01       	movw	r16, r24
    7e4a:	0b 87       	std	Y+11, r16	; 0x0b
    7e4c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7e4e:	89 85       	ldd	r24, Y+9	; 0x09
    7e50:	9a 85       	ldd	r25, Y+10	; 0x0a
    7e52:	01 97       	sbiw	r24, 0x01	; 1
    7e54:	89 87       	std	Y+9, r24	; 0x09
    7e56:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7e58:	89 85       	ldd	r24, Y+9	; 0x09
    7e5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    7e5c:	00 97       	sbiw	r24, 0x00	; 0
    7e5e:	51 f7       	brne	.-44     	; 0x7e34 <checkMote+0xc2>
    7e60:	17 c0       	rjmp	.+46     	; 0x7e90 <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7e62:	6d 81       	ldd	r22, Y+5	; 0x05
    7e64:	7e 81       	ldd	r23, Y+6	; 0x06
    7e66:	8f 81       	ldd	r24, Y+7	; 0x07
    7e68:	98 85       	ldd	r25, Y+8	; 0x08
    7e6a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7e6e:	dc 01       	movw	r26, r24
    7e70:	cb 01       	movw	r24, r22
    7e72:	89 87       	std	Y+9, r24	; 0x09
    7e74:	9a 87       	std	Y+10, r25	; 0x0a
    7e76:	89 85       	ldd	r24, Y+9	; 0x09
    7e78:	9a 85       	ldd	r25, Y+10	; 0x0a
    7e7a:	8d 87       	std	Y+13, r24	; 0x0d
    7e7c:	9e 87       	std	Y+14, r25	; 0x0e
    7e7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7e80:	9e 85       	ldd	r25, Y+14	; 0x0e
    7e82:	8c 01       	movw	r16, r24
    7e84:	c8 01       	movw	r24, r16
    7e86:	01 97       	sbiw	r24, 0x01	; 1
    7e88:	f1 f7       	brne	.-4      	; 0x7e86 <checkMote+0x114>
    7e8a:	8c 01       	movw	r16, r24
    7e8c:	0d 87       	std	Y+13, r16	; 0x0d
    7e8e:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7e90:	88 e0       	ldi	r24, 0x08	; 8
    7e92:	60 e0       	ldi	r22, 0x00	; 0
    7e94:	0e 94 42 36 	call	0x6c84	; 0x6c84 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7e98:	88 e0       	ldi	r24, 0x08	; 8
    7e9a:	60 e0       	ldi	r22, 0x00	; 0
    7e9c:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
    7ea0:	80 e0       	ldi	r24, 0x00	; 0
    7ea2:	90 e4       	ldi	r25, 0x40	; 64
    7ea4:	ac e9       	ldi	r26, 0x9C	; 156
    7ea6:	b5 e4       	ldi	r27, 0x45	; 69
    7ea8:	8f 87       	std	Y+15, r24	; 0x0f
    7eaa:	98 8b       	std	Y+16, r25	; 0x10
    7eac:	a9 8b       	std	Y+17, r26	; 0x11
    7eae:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7eb0:	6f 85       	ldd	r22, Y+15	; 0x0f
    7eb2:	78 89       	ldd	r23, Y+16	; 0x10
    7eb4:	89 89       	ldd	r24, Y+17	; 0x11
    7eb6:	9a 89       	ldd	r25, Y+18	; 0x12
    7eb8:	20 e0       	ldi	r18, 0x00	; 0
    7eba:	30 e0       	ldi	r19, 0x00	; 0
    7ebc:	4a ef       	ldi	r20, 0xFA	; 250
    7ebe:	55 e4       	ldi	r21, 0x45	; 69
    7ec0:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7ec4:	dc 01       	movw	r26, r24
    7ec6:	cb 01       	movw	r24, r22
    7ec8:	8b 8b       	std	Y+19, r24	; 0x13
    7eca:	9c 8b       	std	Y+20, r25	; 0x14
    7ecc:	ad 8b       	std	Y+21, r26	; 0x15
    7ece:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7ed0:	11 e0       	ldi	r17, 0x01	; 1
    7ed2:	6b 89       	ldd	r22, Y+19	; 0x13
    7ed4:	7c 89       	ldd	r23, Y+20	; 0x14
    7ed6:	8d 89       	ldd	r24, Y+21	; 0x15
    7ed8:	9e 89       	ldd	r25, Y+22	; 0x16
    7eda:	20 e0       	ldi	r18, 0x00	; 0
    7edc:	30 e0       	ldi	r19, 0x00	; 0
    7ede:	40 e8       	ldi	r20, 0x80	; 128
    7ee0:	5f e3       	ldi	r21, 0x3F	; 63
    7ee2:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7ee6:	88 23       	and	r24, r24
    7ee8:	0c f0       	brlt	.+2      	; 0x7eec <checkMote+0x17a>
    7eea:	10 e0       	ldi	r17, 0x00	; 0
    7eec:	11 23       	and	r17, r17
    7eee:	29 f0       	breq	.+10     	; 0x7efa <checkMote+0x188>
		__ticks = 1;
    7ef0:	81 e0       	ldi	r24, 0x01	; 1
    7ef2:	90 e0       	ldi	r25, 0x00	; 0
    7ef4:	8f 8b       	std	Y+23, r24	; 0x17
    7ef6:	98 8f       	std	Y+24, r25	; 0x18
    7ef8:	46 c0       	rjmp	.+140    	; 0x7f86 <checkMote+0x214>
	else if (__tmp > 65535)
    7efa:	11 e0       	ldi	r17, 0x01	; 1
    7efc:	6b 89       	ldd	r22, Y+19	; 0x13
    7efe:	7c 89       	ldd	r23, Y+20	; 0x14
    7f00:	8d 89       	ldd	r24, Y+21	; 0x15
    7f02:	9e 89       	ldd	r25, Y+22	; 0x16
    7f04:	20 e0       	ldi	r18, 0x00	; 0
    7f06:	3f ef       	ldi	r19, 0xFF	; 255
    7f08:	4f e7       	ldi	r20, 0x7F	; 127
    7f0a:	57 e4       	ldi	r21, 0x47	; 71
    7f0c:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    7f10:	18 16       	cp	r1, r24
    7f12:	0c f0       	brlt	.+2      	; 0x7f16 <checkMote+0x1a4>
    7f14:	10 e0       	ldi	r17, 0x00	; 0
    7f16:	11 23       	and	r17, r17
    7f18:	61 f1       	breq	.+88     	; 0x7f72 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7f1a:	6f 85       	ldd	r22, Y+15	; 0x0f
    7f1c:	78 89       	ldd	r23, Y+16	; 0x10
    7f1e:	89 89       	ldd	r24, Y+17	; 0x11
    7f20:	9a 89       	ldd	r25, Y+18	; 0x12
    7f22:	20 e0       	ldi	r18, 0x00	; 0
    7f24:	30 e0       	ldi	r19, 0x00	; 0
    7f26:	40 e2       	ldi	r20, 0x20	; 32
    7f28:	51 e4       	ldi	r21, 0x41	; 65
    7f2a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7f2e:	dc 01       	movw	r26, r24
    7f30:	cb 01       	movw	r24, r22
    7f32:	bc 01       	movw	r22, r24
    7f34:	cd 01       	movw	r24, r26
    7f36:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7f3a:	dc 01       	movw	r26, r24
    7f3c:	cb 01       	movw	r24, r22
    7f3e:	8f 8b       	std	Y+23, r24	; 0x17
    7f40:	98 8f       	std	Y+24, r25	; 0x18
    7f42:	12 c0       	rjmp	.+36     	; 0x7f68 <checkMote+0x1f6>
    7f44:	80 e2       	ldi	r24, 0x20	; 32
    7f46:	93 e0       	ldi	r25, 0x03	; 3
    7f48:	89 8f       	std	Y+25, r24	; 0x19
    7f4a:	9a 8f       	std	Y+26, r25	; 0x1a
    7f4c:	89 8d       	ldd	r24, Y+25	; 0x19
    7f4e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7f50:	8c 01       	movw	r16, r24
    7f52:	c8 01       	movw	r24, r16
    7f54:	01 97       	sbiw	r24, 0x01	; 1
    7f56:	f1 f7       	brne	.-4      	; 0x7f54 <checkMote+0x1e2>
    7f58:	8c 01       	movw	r16, r24
    7f5a:	09 8f       	std	Y+25, r16	; 0x19
    7f5c:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7f5e:	8f 89       	ldd	r24, Y+23	; 0x17
    7f60:	98 8d       	ldd	r25, Y+24	; 0x18
    7f62:	01 97       	sbiw	r24, 0x01	; 1
    7f64:	8f 8b       	std	Y+23, r24	; 0x17
    7f66:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7f68:	8f 89       	ldd	r24, Y+23	; 0x17
    7f6a:	98 8d       	ldd	r25, Y+24	; 0x18
    7f6c:	00 97       	sbiw	r24, 0x00	; 0
    7f6e:	51 f7       	brne	.-44     	; 0x7f44 <checkMote+0x1d2>
    7f70:	17 c0       	rjmp	.+46     	; 0x7fa0 <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7f72:	6b 89       	ldd	r22, Y+19	; 0x13
    7f74:	7c 89       	ldd	r23, Y+20	; 0x14
    7f76:	8d 89       	ldd	r24, Y+21	; 0x15
    7f78:	9e 89       	ldd	r25, Y+22	; 0x16
    7f7a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    7f7e:	dc 01       	movw	r26, r24
    7f80:	cb 01       	movw	r24, r22
    7f82:	8f 8b       	std	Y+23, r24	; 0x17
    7f84:	98 8f       	std	Y+24, r25	; 0x18
    7f86:	8f 89       	ldd	r24, Y+23	; 0x17
    7f88:	98 8d       	ldd	r25, Y+24	; 0x18
    7f8a:	8b 8f       	std	Y+27, r24	; 0x1b
    7f8c:	9c 8f       	std	Y+28, r25	; 0x1c
    7f8e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7f90:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7f92:	8c 01       	movw	r16, r24
    7f94:	c8 01       	movw	r24, r16
    7f96:	01 97       	sbiw	r24, 0x01	; 1
    7f98:	f1 f7       	brne	.-4      	; 0x7f96 <checkMote+0x224>
    7f9a:	8c 01       	movw	r16, r24
    7f9c:	0b 8f       	std	Y+27, r16	; 0x1b
    7f9e:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7fa0:	88 e0       	ldi	r24, 0x08	; 8
    7fa2:	60 e0       	ldi	r22, 0x00	; 0
    7fa4:	0e 94 71 37 	call	0x6ee2	; 0x6ee2 <PortEx_OUTCLR>
    7fa8:	80 e0       	ldi	r24, 0x00	; 0
    7faa:	90 e4       	ldi	r25, 0x40	; 64
    7fac:	ac e9       	ldi	r26, 0x9C	; 156
    7fae:	b5 e4       	ldi	r27, 0x45	; 69
    7fb0:	8d 8f       	std	Y+29, r24	; 0x1d
    7fb2:	9e 8f       	std	Y+30, r25	; 0x1e
    7fb4:	af 8f       	std	Y+31, r26	; 0x1f
    7fb6:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7fb8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7fba:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7fbc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7fbe:	98 a1       	lds	r25, 0x48
    7fc0:	20 e0       	ldi	r18, 0x00	; 0
    7fc2:	30 e0       	ldi	r19, 0x00	; 0
    7fc4:	4a ef       	ldi	r20, 0xFA	; 250
    7fc6:	55 e4       	ldi	r21, 0x45	; 69
    7fc8:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    7fcc:	dc 01       	movw	r26, r24
    7fce:	cb 01       	movw	r24, r22
    7fd0:	89 a3       	lds	r24, 0x59
    7fd2:	9a a3       	lds	r25, 0x5a
    7fd4:	ab a3       	lds	r26, 0x5b
    7fd6:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7fd8:	11 e0       	ldi	r17, 0x01	; 1
    7fda:	69 a1       	lds	r22, 0x49
    7fdc:	7a a1       	lds	r23, 0x4a
    7fde:	8b a1       	lds	r24, 0x4b
    7fe0:	9c a1       	lds	r25, 0x4c
    7fe2:	20 e0       	ldi	r18, 0x00	; 0
    7fe4:	30 e0       	ldi	r19, 0x00	; 0
    7fe6:	40 e8       	ldi	r20, 0x80	; 128
    7fe8:	5f e3       	ldi	r21, 0x3F	; 63
    7fea:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    7fee:	88 23       	and	r24, r24
    7ff0:	0c f0       	brlt	.+2      	; 0x7ff4 <checkMote+0x282>
    7ff2:	10 e0       	ldi	r17, 0x00	; 0
    7ff4:	11 23       	and	r17, r17
    7ff6:	29 f0       	breq	.+10     	; 0x8002 <checkMote+0x290>
		__ticks = 1;
    7ff8:	81 e0       	ldi	r24, 0x01	; 1
    7ffa:	90 e0       	ldi	r25, 0x00	; 0
    7ffc:	8d a3       	lds	r24, 0x5d
    7ffe:	9e a3       	lds	r25, 0x5e
    8000:	46 c0       	rjmp	.+140    	; 0x808e <checkMote+0x31c>
	else if (__tmp > 65535)
    8002:	11 e0       	ldi	r17, 0x01	; 1
    8004:	69 a1       	lds	r22, 0x49
    8006:	7a a1       	lds	r23, 0x4a
    8008:	8b a1       	lds	r24, 0x4b
    800a:	9c a1       	lds	r25, 0x4c
    800c:	20 e0       	ldi	r18, 0x00	; 0
    800e:	3f ef       	ldi	r19, 0xFF	; 255
    8010:	4f e7       	ldi	r20, 0x7F	; 127
    8012:	57 e4       	ldi	r21, 0x47	; 71
    8014:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    8018:	18 16       	cp	r1, r24
    801a:	0c f0       	brlt	.+2      	; 0x801e <checkMote+0x2ac>
    801c:	10 e0       	ldi	r17, 0x00	; 0
    801e:	11 23       	and	r17, r17
    8020:	61 f1       	breq	.+88     	; 0x807a <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8022:	6d 8d       	ldd	r22, Y+29	; 0x1d
    8024:	7e 8d       	ldd	r23, Y+30	; 0x1e
    8026:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8028:	98 a1       	lds	r25, 0x48
    802a:	20 e0       	ldi	r18, 0x00	; 0
    802c:	30 e0       	ldi	r19, 0x00	; 0
    802e:	40 e2       	ldi	r20, 0x20	; 32
    8030:	51 e4       	ldi	r21, 0x41	; 65
    8032:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    8036:	dc 01       	movw	r26, r24
    8038:	cb 01       	movw	r24, r22
    803a:	bc 01       	movw	r22, r24
    803c:	cd 01       	movw	r24, r26
    803e:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    8042:	dc 01       	movw	r26, r24
    8044:	cb 01       	movw	r24, r22
    8046:	8d a3       	lds	r24, 0x5d
    8048:	9e a3       	lds	r25, 0x5e
    804a:	12 c0       	rjmp	.+36     	; 0x8070 <checkMote+0x2fe>
    804c:	80 e2       	ldi	r24, 0x20	; 32
    804e:	93 e0       	ldi	r25, 0x03	; 3
    8050:	8f a3       	lds	r24, 0x5f
    8052:	98 a7       	lds	r25, 0x78
    8054:	8f a1       	lds	r24, 0x4f
    8056:	98 a5       	lds	r25, 0x68
    8058:	8c 01       	movw	r16, r24
    805a:	c8 01       	movw	r24, r16
    805c:	01 97       	sbiw	r24, 0x01	; 1
    805e:	f1 f7       	brne	.-4      	; 0x805c <checkMote+0x2ea>
    8060:	8c 01       	movw	r16, r24
    8062:	0f a3       	lds	r16, 0x5f
    8064:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8066:	8d a1       	lds	r24, 0x4d
    8068:	9e a1       	lds	r25, 0x4e
    806a:	01 97       	sbiw	r24, 0x01	; 1
    806c:	8d a3       	lds	r24, 0x5d
    806e:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8070:	8d a1       	lds	r24, 0x4d
    8072:	9e a1       	lds	r25, 0x4e
    8074:	00 97       	sbiw	r24, 0x00	; 0
    8076:	51 f7       	brne	.-44     	; 0x804c <checkMote+0x2da>
    8078:	18 c0       	rjmp	.+48     	; 0x80aa <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    807a:	69 a1       	lds	r22, 0x49
    807c:	7a a1       	lds	r23, 0x4a
    807e:	8b a1       	lds	r24, 0x4b
    8080:	9c a1       	lds	r25, 0x4c
    8082:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    8086:	dc 01       	movw	r26, r24
    8088:	cb 01       	movw	r24, r22
    808a:	8d a3       	lds	r24, 0x5d
    808c:	9e a3       	lds	r25, 0x5e
    808e:	8d a1       	lds	r24, 0x4d
    8090:	9e a1       	lds	r25, 0x4e
    8092:	89 a7       	lds	r24, 0x79
    8094:	9a a7       	lds	r25, 0x7a
    8096:	89 a5       	lds	r24, 0x69
    8098:	9a a5       	lds	r25, 0x6a
    809a:	8c 01       	movw	r16, r24
    809c:	c8 01       	movw	r24, r16
    809e:	01 97       	sbiw	r24, 0x01	; 1
    80a0:	f1 f7       	brne	.-4      	; 0x809e <checkMote+0x32c>
    80a2:	8c 01       	movw	r16, r24
    80a4:	09 a7       	lds	r16, 0x79
    80a6:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    80a8:	f7 ce       	rjmp	.-530    	; 0x7e98 <checkMote+0x126>
    80aa:	f6 ce       	rjmp	.-532    	; 0x7e98 <checkMote+0x126>

000080ac <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    80ac:	cf 93       	push	r28
    80ae:	df 93       	push	r29
    80b0:	cd b7       	in	r28, 0x3d	; 61
    80b2:	de b7       	in	r29, 0x3e	; 62
    80b4:	28 97       	sbiw	r28, 0x08	; 8
    80b6:	cd bf       	out	0x3d, r28	; 61
    80b8:	de bf       	out	0x3e, r29	; 62
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    80ba:	19 82       	std	Y+1, r1	; 0x01
    80bc:	1a 82       	std	Y+2, r1	; 0x02
    80be:	0c c0       	rjmp	.+24     	; 0x80d8 <SD_write_and_read_knowns+0x2c>
    80c0:	29 81       	ldd	r18, Y+1	; 0x01
    80c2:	89 81       	ldd	r24, Y+1	; 0x01
    80c4:	9a 81       	ldd	r25, Y+2	; 0x02
    80c6:	89 52       	subi	r24, 0x29	; 41
    80c8:	9c 4d       	sbci	r25, 0xDC	; 220
    80ca:	fc 01       	movw	r30, r24
    80cc:	20 83       	st	Z, r18
    80ce:	89 81       	ldd	r24, Y+1	; 0x01
    80d0:	9a 81       	ldd	r25, Y+2	; 0x02
    80d2:	01 96       	adiw	r24, 0x01	; 1
    80d4:	89 83       	std	Y+1, r24	; 0x01
    80d6:	9a 83       	std	Y+2, r25	; 0x02
    80d8:	89 81       	ldd	r24, Y+1	; 0x01
    80da:	9a 81       	ldd	r25, Y+2	; 0x02
    80dc:	88 31       	cpi	r24, 0x18	; 24
    80de:	91 05       	cpc	r25, r1
    80e0:	7c f3       	brlt	.-34     	; 0x80c0 <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    80e2:	27 ed       	ldi	r18, 0xD7	; 215
    80e4:	33 e2       	ldi	r19, 0x23	; 35
    80e6:	64 e1       	ldi	r22, 0x14	; 20
    80e8:	70 e0       	ldi	r23, 0x00	; 0
    80ea:	80 e0       	ldi	r24, 0x00	; 0
    80ec:	90 e0       	ldi	r25, 0x00	; 0
    80ee:	a9 01       	movw	r20, r18
    80f0:	28 e1       	ldi	r18, 0x18	; 24
    80f2:	30 e0       	ldi	r19, 0x00	; 0
    80f4:	0e 94 5c 51 	call	0xa2b8	; 0xa2b8 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    80f8:	1b 82       	std	Y+3, r1	; 0x03
    80fa:	1c 82       	std	Y+4, r1	; 0x04
    80fc:	0b c0       	rjmp	.+22     	; 0x8114 <SD_write_and_read_knowns+0x68>
    80fe:	8b 81       	ldd	r24, Y+3	; 0x03
    8100:	9c 81       	ldd	r25, Y+4	; 0x04
    8102:	89 52       	subi	r24, 0x29	; 41
    8104:	9c 4d       	sbci	r25, 0xDC	; 220
    8106:	fc 01       	movw	r30, r24
    8108:	10 82       	st	Z, r1
    810a:	8b 81       	ldd	r24, Y+3	; 0x03
    810c:	9c 81       	ldd	r25, Y+4	; 0x04
    810e:	01 96       	adiw	r24, 0x01	; 1
    8110:	8b 83       	std	Y+3, r24	; 0x03
    8112:	9c 83       	std	Y+4, r25	; 0x04
    8114:	8b 81       	ldd	r24, Y+3	; 0x03
    8116:	9c 81       	ldd	r25, Y+4	; 0x04
    8118:	88 31       	cpi	r24, 0x18	; 24
    811a:	91 05       	cpc	r25, r1
    811c:	84 f3       	brlt	.-32     	; 0x80fe <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    811e:	27 ed       	ldi	r18, 0xD7	; 215
    8120:	33 e2       	ldi	r19, 0x23	; 35
    8122:	64 e1       	ldi	r22, 0x14	; 20
    8124:	70 e0       	ldi	r23, 0x00	; 0
    8126:	80 e0       	ldi	r24, 0x00	; 0
    8128:	90 e0       	ldi	r25, 0x00	; 0
    812a:	a9 01       	movw	r20, r18
    812c:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    8130:	1d 82       	std	Y+5, r1	; 0x05
    8132:	1e 82       	std	Y+6, r1	; 0x06
    8134:	13 c0       	rjmp	.+38     	; 0x815c <SD_write_and_read_knowns+0xb0>
    8136:	8d 81       	ldd	r24, Y+5	; 0x05
    8138:	9e 81       	ldd	r25, Y+6	; 0x06
    813a:	24 e6       	ldi	r18, 0x64	; 100
    813c:	30 e0       	ldi	r19, 0x00	; 0
    813e:	b9 01       	movw	r22, r18
    8140:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    8144:	28 2f       	mov	r18, r24
    8146:	8d 81       	ldd	r24, Y+5	; 0x05
    8148:	9e 81       	ldd	r25, Y+6	; 0x06
    814a:	89 52       	subi	r24, 0x29	; 41
    814c:	9c 4d       	sbci	r25, 0xDC	; 220
    814e:	fc 01       	movw	r30, r24
    8150:	20 83       	st	Z, r18
    8152:	8d 81       	ldd	r24, Y+5	; 0x05
    8154:	9e 81       	ldd	r25, Y+6	; 0x06
    8156:	01 96       	adiw	r24, 0x01	; 1
    8158:	8d 83       	std	Y+5, r24	; 0x05
    815a:	9e 83       	std	Y+6, r25	; 0x06
    815c:	8d 81       	ldd	r24, Y+5	; 0x05
    815e:	9e 81       	ldd	r25, Y+6	; 0x06
    8160:	f4 e0       	ldi	r31, 0x04	; 4
    8162:	82 3e       	cpi	r24, 0xE2	; 226
    8164:	9f 07       	cpc	r25, r31
    8166:	3c f3       	brlt	.-50     	; 0x8136 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    8168:	27 ed       	ldi	r18, 0xD7	; 215
    816a:	33 e2       	ldi	r19, 0x23	; 35
    816c:	60 e5       	ldi	r22, 0x50	; 80
    816e:	70 e0       	ldi	r23, 0x00	; 0
    8170:	80 e0       	ldi	r24, 0x00	; 0
    8172:	90 e0       	ldi	r25, 0x00	; 0
    8174:	a9 01       	movw	r20, r18
    8176:	22 ee       	ldi	r18, 0xE2	; 226
    8178:	34 e0       	ldi	r19, 0x04	; 4
    817a:	0e 94 a0 52 	call	0xa540	; 0xa540 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    817e:	1f 82       	std	Y+7, r1	; 0x07
    8180:	18 86       	std	Y+8, r1	; 0x08
    8182:	0b c0       	rjmp	.+22     	; 0x819a <SD_write_and_read_knowns+0xee>
    8184:	8f 81       	ldd	r24, Y+7	; 0x07
    8186:	98 85       	ldd	r25, Y+8	; 0x08
    8188:	89 52       	subi	r24, 0x29	; 41
    818a:	9c 4d       	sbci	r25, 0xDC	; 220
    818c:	fc 01       	movw	r30, r24
    818e:	10 82       	st	Z, r1
    8190:	8f 81       	ldd	r24, Y+7	; 0x07
    8192:	98 85       	ldd	r25, Y+8	; 0x08
    8194:	01 96       	adiw	r24, 0x01	; 1
    8196:	8f 83       	std	Y+7, r24	; 0x07
    8198:	98 87       	std	Y+8, r25	; 0x08
    819a:	8f 81       	ldd	r24, Y+7	; 0x07
    819c:	98 85       	ldd	r25, Y+8	; 0x08
    819e:	f4 e0       	ldi	r31, 0x04	; 4
    81a0:	82 3e       	cpi	r24, 0xE2	; 226
    81a2:	9f 07       	cpc	r25, r31
    81a4:	7c f3       	brlt	.-34     	; 0x8184 <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    81a6:	27 ed       	ldi	r18, 0xD7	; 215
    81a8:	33 e2       	ldi	r19, 0x23	; 35
    81aa:	60 e5       	ldi	r22, 0x50	; 80
    81ac:	70 e0       	ldi	r23, 0x00	; 0
    81ae:	80 e0       	ldi	r24, 0x00	; 0
    81b0:	90 e0       	ldi	r25, 0x00	; 0
    81b2:	a9 01       	movw	r20, r18
    81b4:	23 e0       	ldi	r18, 0x03	; 3
    81b6:	30 e0       	ldi	r19, 0x00	; 0
    81b8:	0e 94 fe 53 	call	0xa7fc	; 0xa7fc <SD_read_multiple_blocks>
}
    81bc:	28 96       	adiw	r28, 0x08	; 8
    81be:	cd bf       	out	0x3d, r28	; 61
    81c0:	de bf       	out	0x3e, r29	; 62
    81c2:	df 91       	pop	r29
    81c4:	cf 91       	pop	r28
    81c6:	08 95       	ret

000081c8 <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    81c8:	cf 93       	push	r28
    81ca:	df 93       	push	r29
    81cc:	00 d0       	rcall	.+0      	; 0x81ce <SD_write_and_read_knowns_FAT+0x6>
    81ce:	0f 92       	push	r0
    81d0:	cd b7       	in	r28, 0x3d	; 61
    81d2:	de b7       	in	r29, 0x3e	; 62
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    81d4:	19 82       	std	Y+1, r1	; 0x01
    81d6:	1a 82       	std	Y+2, r1	; 0x02
    81d8:	0c c0       	rjmp	.+24     	; 0x81f2 <SD_write_and_read_knowns_FAT+0x2a>
    81da:	29 81       	ldd	r18, Y+1	; 0x01
    81dc:	89 81       	ldd	r24, Y+1	; 0x01
    81de:	9a 81       	ldd	r25, Y+2	; 0x02
    81e0:	89 52       	subi	r24, 0x29	; 41
    81e2:	9c 4d       	sbci	r25, 0xDC	; 220
    81e4:	fc 01       	movw	r30, r24
    81e6:	20 83       	st	Z, r18
    81e8:	89 81       	ldd	r24, Y+1	; 0x01
    81ea:	9a 81       	ldd	r25, Y+2	; 0x02
    81ec:	01 96       	adiw	r24, 0x01	; 1
    81ee:	89 83       	std	Y+1, r24	; 0x01
    81f0:	9a 83       	std	Y+2, r25	; 0x02
    81f2:	89 81       	ldd	r24, Y+1	; 0x01
    81f4:	9a 81       	ldd	r25, Y+2	; 0x02
    81f6:	88 31       	cpi	r24, 0x18	; 24
    81f8:	91 05       	cpc	r25, r1
    81fa:	7c f3       	brlt	.-34     	; 0x81da <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    81fc:	8f e0       	ldi	r24, 0x0F	; 15
    81fe:	90 e2       	ldi	r25, 0x20	; 32
    8200:	27 ed       	ldi	r18, 0xD7	; 215
    8202:	33 e2       	ldi	r19, 0x23	; 35
    8204:	b9 01       	movw	r22, r18
    8206:	20 e0       	ldi	r18, 0x00	; 0
    8208:	32 e0       	ldi	r19, 0x02	; 2
    820a:	40 e0       	ldi	r20, 0x00	; 0
    820c:	50 e0       	ldi	r21, 0x00	; 0
    820e:	0e 94 51 49 	call	0x92a2	; 0x92a2 <writeFile>
    8212:	80 93 9b 50 	sts	0x509B, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    8216:	1b 82       	std	Y+3, r1	; 0x03
    8218:	1c 82       	std	Y+4, r1	; 0x04
    821a:	0b c0       	rjmp	.+22     	; 0x8232 <SD_write_and_read_knowns_FAT+0x6a>
    821c:	8b 81       	ldd	r24, Y+3	; 0x03
    821e:	9c 81       	ldd	r25, Y+4	; 0x04
    8220:	89 52       	subi	r24, 0x29	; 41
    8222:	9c 4d       	sbci	r25, 0xDC	; 220
    8224:	fc 01       	movw	r30, r24
    8226:	10 82       	st	Z, r1
    8228:	8b 81       	ldd	r24, Y+3	; 0x03
    822a:	9c 81       	ldd	r25, Y+4	; 0x04
    822c:	01 96       	adiw	r24, 0x01	; 1
    822e:	8b 83       	std	Y+3, r24	; 0x03
    8230:	9c 83       	std	Y+4, r25	; 0x04
    8232:	8b 81       	ldd	r24, Y+3	; 0x03
    8234:	9c 81       	ldd	r25, Y+4	; 0x04
    8236:	88 31       	cpi	r24, 0x18	; 24
    8238:	91 05       	cpc	r25, r1
    823a:	84 f3       	brlt	.-32     	; 0x821c <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    823c:	2f e0       	ldi	r18, 0x0F	; 15
    823e:	30 e2       	ldi	r19, 0x20	; 32
    8240:	80 e0       	ldi	r24, 0x00	; 0
    8242:	b9 01       	movw	r22, r18
    8244:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <readFile>
    8248:	80 93 9b 50 	sts	0x509B, r24
}
    824c:	24 96       	adiw	r28, 0x04	; 4
    824e:	cd bf       	out	0x3d, r28	; 61
    8250:	de bf       	out	0x3e, r29	; 62
    8252:	df 91       	pop	r29
    8254:	cf 91       	pop	r28
    8256:	08 95       	ret

00008258 <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    8258:	cf 93       	push	r28
    825a:	df 93       	push	r29
    825c:	cd b7       	in	r28, 0x3d	; 61
    825e:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    8260:	0e 94 5d 22 	call	0x44ba	; 0x44ba <chb_init>
	chb_set_short_addr(0x0002);
    8264:	82 e0       	ldi	r24, 0x02	; 2
    8266:	90 e0       	ldi	r25, 0x00	; 0
    8268:	0e 94 02 2f 	call	0x5e04	; 0x5e04 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    826c:	00 00       	nop
    826e:	fe cf       	rjmp	.-4      	; 0x826c <chibi_test_radio+0x14>

00008270 <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    8270:	cf 93       	push	r28
    8272:	df 93       	push	r29
    8274:	0f 92       	push	r0
    8276:	0f 92       	push	r0
    8278:	cd b7       	in	r28, 0x3d	; 61
    827a:	de b7       	in	r29, 0x3e	; 62
	
	SD_init();
    827c:	0e 94 b9 4e 	call	0x9d72	; 0x9d72 <SD_init>
	getBootSectorData();
    8280:	0e 94 cc 42 	call	0x8598	; 0x8598 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    8284:	19 82       	std	Y+1, r1	; 0x01
    8286:	1a 82       	std	Y+2, r1	; 0x02
    8288:	13 c0       	rjmp	.+38     	; 0x82b0 <TestCard+0x40>
    828a:	89 81       	ldd	r24, Y+1	; 0x01
    828c:	9a 81       	ldd	r25, Y+2	; 0x02
    828e:	29 e7       	ldi	r18, 0x79	; 121
    8290:	30 e0       	ldi	r19, 0x00	; 0
    8292:	b9 01       	movw	r22, r18
    8294:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    8298:	28 2f       	mov	r18, r24
    829a:	89 81       	ldd	r24, Y+1	; 0x01
    829c:	9a 81       	ldd	r25, Y+2	; 0x02
    829e:	89 52       	subi	r24, 0x29	; 41
    82a0:	9c 4d       	sbci	r25, 0xDC	; 220
    82a2:	fc 01       	movw	r30, r24
    82a4:	20 83       	st	Z, r18
    82a6:	89 81       	ldd	r24, Y+1	; 0x01
    82a8:	9a 81       	ldd	r25, Y+2	; 0x02
    82aa:	01 96       	adiw	r24, 0x01	; 1
    82ac:	89 83       	std	Y+1, r24	; 0x01
    82ae:	9a 83       	std	Y+2, r25	; 0x02
    82b0:	89 81       	ldd	r24, Y+1	; 0x01
    82b2:	9a 81       	ldd	r25, Y+2	; 0x02
    82b4:	f2 e0       	ldi	r31, 0x02	; 2
    82b6:	80 30       	cpi	r24, 0x00	; 0
    82b8:	9f 07       	cpc	r25, r31
    82ba:	3c f3       	brlt	.-50     	; 0x828a <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    82bc:	8f e0       	ldi	r24, 0x0F	; 15
    82be:	90 e2       	ldi	r25, 0x20	; 32
    82c0:	27 ed       	ldi	r18, 0xD7	; 215
    82c2:	33 e2       	ldi	r19, 0x23	; 35
    82c4:	b9 01       	movw	r22, r18
    82c6:	20 e0       	ldi	r18, 0x00	; 0
    82c8:	32 e0       	ldi	r19, 0x02	; 2
    82ca:	40 e0       	ldi	r20, 0x00	; 0
    82cc:	50 e0       	ldi	r21, 0x00	; 0
    82ce:	0e 94 51 49 	call	0x92a2	; 0x92a2 <writeFile>
	nop();
    82d2:	00 00       	nop
}
    82d4:	0f 90       	pop	r0
    82d6:	0f 90       	pop	r0
    82d8:	df 91       	pop	r29
    82da:	cf 91       	pop	r28
    82dc:	08 95       	ret

000082de <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    82de:	1f 92       	push	r1
    82e0:	0f 92       	push	r0
    82e2:	0f b6       	in	r0, 0x3f	; 63
    82e4:	0f 92       	push	r0
    82e6:	00 90 3b 00 	lds	r0, 0x003B
    82ea:	0f 92       	push	r0
    82ec:	11 24       	eor	r1, r1
    82ee:	2f 93       	push	r18
    82f0:	3f 93       	push	r19
    82f2:	4f 93       	push	r20
    82f4:	5f 93       	push	r21
    82f6:	6f 93       	push	r22
    82f8:	7f 93       	push	r23
    82fa:	8f 93       	push	r24
    82fc:	9f 93       	push	r25
    82fe:	af 93       	push	r26
    8300:	bf 93       	push	r27
    8302:	ef 93       	push	r30
    8304:	ff 93       	push	r31
    8306:	cf 93       	push	r28
    8308:	df 93       	push	r29
    830a:	00 d0       	rcall	.+0      	; 0x830c <__vector_43+0x2e>
    830c:	00 d0       	rcall	.+0      	; 0x830e <__vector_43+0x30>
    830e:	cd b7       	in	r28, 0x3d	; 61
    8310:	de b7       	in	r29, 0x3e	; 62
	
	chb_rx_data_t* msg = NULL;
    8312:	1d 82       	std	Y+5, r1	; 0x05
    8314:	1e 82       	std	Y+6, r1	; 0x06
	switch (RadioMonitorMode) {
    8316:	80 91 56 40 	lds	r24, 0x4056
    831a:	88 2f       	mov	r24, r24
    831c:	90 e0       	ldi	r25, 0x00	; 0
    831e:	81 30       	cpi	r24, 0x01	; 1
    8320:	91 05       	cpc	r25, r1
    8322:	29 f0       	breq	.+10     	; 0x832e <__vector_43+0x50>
    8324:	82 30       	cpi	r24, 0x02	; 2
    8326:	91 05       	cpc	r25, r1
    8328:	09 f4       	brne	.+2      	; 0x832c <__vector_43+0x4e>
    832a:	74 c0       	rjmp	.+232    	; 0x8414 <__vector_43+0x136>
    832c:	93 c0       	rjmp	.+294    	; 0x8454 <__vector_43+0x176>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    832e:	8d 81       	ldd	r24, Y+5	; 0x05
    8330:	9e 81       	ldd	r25, Y+6	; 0x06
    8332:	0e 94 c9 23 	call	0x4792	; 0x4792 <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    8336:	8d 81       	ldd	r24, Y+5	; 0x05
    8338:	9e 81       	ldd	r25, Y+6	; 0x06
    833a:	05 96       	adiw	r24, 0x05	; 5
    833c:	27 e1       	ldi	r18, 0x17	; 23
    833e:	30 e2       	ldi	r19, 0x20	; 32
    8340:	b9 01       	movw	r22, r18
    8342:	45 e0       	ldi	r20, 0x05	; 5
    8344:	50 e0       	ldi	r21, 0x00	; 0
    8346:	0e 94 25 61 	call	0xc24a	; 0xc24a <strncmp>
    834a:	00 97       	sbiw	r24, 0x00	; 0
    834c:	51 f4       	brne	.+20     	; 0x8362 <__vector_43+0x84>
				MotesReadyToSynch++;
    834e:	80 91 70 50 	lds	r24, 0x5070
    8352:	90 91 71 50 	lds	r25, 0x5071
    8356:	01 96       	adiw	r24, 0x01	; 1
    8358:	80 93 70 50 	sts	0x5070, r24
    835c:	90 93 71 50 	sts	0x5071, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    8360:	7b c0       	rjmp	.+246    	; 0x8458 <__vector_43+0x17a>
			if(!strncmp((const char*)(msg->data),"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    8362:	19 82       	std	Y+1, r1	; 0x01
    8364:	1a 82       	std	Y+2, r1	; 0x02
    8366:	1b 82       	std	Y+3, r1	; 0x03
    8368:	1c 82       	std	Y+4, r1	; 0x04
    836a:	1a c0       	rjmp	.+52     	; 0x83a0 <__vector_43+0xc2>
    836c:	2d 81       	ldd	r18, Y+5	; 0x05
    836e:	3e 81       	ldd	r19, Y+6	; 0x06
    8370:	89 81       	ldd	r24, Y+1	; 0x01
    8372:	9a 81       	ldd	r25, Y+2	; 0x02
    8374:	82 0f       	add	r24, r18
    8376:	93 1f       	adc	r25, r19
    8378:	05 96       	adiw	r24, 0x05	; 5
    837a:	fc 01       	movw	r30, r24
    837c:	20 81       	ld	r18, Z
    837e:	89 81       	ldd	r24, Y+1	; 0x01
    8380:	9a 81       	ldd	r25, Y+2	; 0x02
    8382:	89 52       	subi	r24, 0x29	; 41
    8384:	9c 4d       	sbci	r25, 0xDC	; 220
    8386:	fc 01       	movw	r30, r24
    8388:	20 83       	st	Z, r18
    838a:	89 81       	ldd	r24, Y+1	; 0x01
    838c:	9a 81       	ldd	r25, Y+2	; 0x02
    838e:	ab 81       	ldd	r26, Y+3	; 0x03
    8390:	bc 81       	ldd	r27, Y+4	; 0x04
    8392:	01 96       	adiw	r24, 0x01	; 1
    8394:	a1 1d       	adc	r26, r1
    8396:	b1 1d       	adc	r27, r1
    8398:	89 83       	std	Y+1, r24	; 0x01
    839a:	9a 83       	std	Y+2, r25	; 0x02
    839c:	ab 83       	std	Y+3, r26	; 0x03
    839e:	bc 83       	std	Y+4, r27	; 0x04
    83a0:	89 81       	ldd	r24, Y+1	; 0x01
    83a2:	9a 81       	ldd	r25, Y+2	; 0x02
    83a4:	ab 81       	ldd	r26, Y+3	; 0x03
    83a6:	bc 81       	ldd	r27, Y+4	; 0x04
    83a8:	80 38       	cpi	r24, 0x80	; 128
    83aa:	91 05       	cpc	r25, r1
    83ac:	a1 05       	cpc	r26, r1
    83ae:	b1 05       	cpc	r27, r1
    83b0:	e8 f2       	brcs	.-70     	; 0x836c <__vector_43+0x8e>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    83b2:	80 91 ba 50 	lds	r24, 0x50BA
    83b6:	90 91 bb 50 	lds	r25, 0x50BB
    83ba:	a0 91 bc 50 	lds	r26, 0x50BC
    83be:	b0 91 bd 50 	lds	r27, 0x50BD
    83c2:	80 58       	subi	r24, 0x80	; 128
    83c4:	9f 4f       	sbci	r25, 0xFF	; 255
    83c6:	af 4f       	sbci	r26, 0xFF	; 255
    83c8:	bf 4f       	sbci	r27, 0xFF	; 255
    83ca:	80 93 ba 50 	sts	0x50BA, r24
    83ce:	90 93 bb 50 	sts	0x50BB, r25
    83d2:	a0 93 bc 50 	sts	0x50BC, r26
    83d6:	b0 93 bd 50 	sts	0x50BD, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    83da:	80 91 ba 50 	lds	r24, 0x50BA
    83de:	90 91 bb 50 	lds	r25, 0x50BB
    83e2:	a0 91 bc 50 	lds	r26, 0x50BC
    83e6:	b0 91 bd 50 	lds	r27, 0x50BD
    83ea:	80 58       	subi	r24, 0x80	; 128
    83ec:	9f 4f       	sbci	r25, 0xFF	; 255
    83ee:	af 4f       	sbci	r26, 0xFF	; 255
    83f0:	bf 4f       	sbci	r27, 0xFF	; 255
    83f2:	81 37       	cpi	r24, 0x71	; 113
    83f4:	fc e1       	ldi	r31, 0x1C	; 28
    83f6:	9f 07       	cpc	r25, r31
    83f8:	f0 e0       	ldi	r31, 0x00	; 0
    83fa:	af 07       	cpc	r26, r31
    83fc:	f0 e0       	ldi	r31, 0x00	; 0
    83fe:	bf 07       	cpc	r27, r31
    8400:	58 f1       	brcs	.+86     	; 0x8458 <__vector_43+0x17a>
    8402:	10 92 ba 50 	sts	0x50BA, r1
    8406:	10 92 bb 50 	sts	0x50BB, r1
    840a:	10 92 bc 50 	sts	0x50BC, r1
    840e:	10 92 bd 50 	sts	0x50BD, r1
			}			
			break;
    8412:	22 c0       	rjmp	.+68     	; 0x8458 <__vector_43+0x17a>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    8414:	8d 81       	ldd	r24, Y+5	; 0x05
    8416:	9e 81       	ldd	r25, Y+6	; 0x06
    8418:	0e 94 c9 23 	call	0x4792	; 0x4792 <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    841c:	8d 81       	ldd	r24, Y+5	; 0x05
    841e:	9e 81       	ldd	r25, Y+6	; 0x06
    8420:	05 96       	adiw	r24, 0x05	; 5
    8422:	2d e1       	ldi	r18, 0x1D	; 29
    8424:	30 e2       	ldi	r19, 0x20	; 32
    8426:	b9 01       	movw	r22, r18
    8428:	4e e0       	ldi	r20, 0x0E	; 14
    842a:	50 e0       	ldi	r21, 0x00	; 0
    842c:	0e 94 25 61 	call	0xc24a	; 0xc24a <strncmp>
    8430:	00 97       	sbiw	r24, 0x00	; 0
    8432:	a1 f4       	brne	.+40     	; 0x845c <__vector_43+0x17e>
				RadioMonitorMode = SYNCHED;
    8434:	83 e0       	ldi	r24, 0x03	; 3
    8436:	80 93 56 40 	sts	0x4056, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    843a:	80 e4       	ldi	r24, 0x40	; 64
    843c:	99 e0       	ldi	r25, 0x09	; 9
    843e:	29 e0       	ldi	r18, 0x09	; 9
    8440:	fc 01       	movw	r30, r24
    8442:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    8444:	80 e4       	ldi	r24, 0x40	; 64
    8446:	98 e0       	ldi	r25, 0x08	; 8
    8448:	21 e0       	ldi	r18, 0x01	; 1
    844a:	fc 01       	movw	r30, r24
    844c:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    844e:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <ADC_Resume_Sampling>
			}
			break;
    8452:	04 c0       	rjmp	.+8      	; 0x845c <__vector_43+0x17e>
		default:
			break;
    8454:	00 00       	nop
    8456:	03 c0       	rjmp	.+6      	; 0x845e <__vector_43+0x180>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    8458:	00 00       	nop
    845a:	01 c0       	rjmp	.+2      	; 0x845e <__vector_43+0x180>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    845c:	00 00       	nop
		default:
			break;
	}
}
    845e:	26 96       	adiw	r28, 0x06	; 6
    8460:	cd bf       	out	0x3d, r28	; 61
    8462:	de bf       	out	0x3e, r29	; 62
    8464:	df 91       	pop	r29
    8466:	cf 91       	pop	r28
    8468:	ff 91       	pop	r31
    846a:	ef 91       	pop	r30
    846c:	bf 91       	pop	r27
    846e:	af 91       	pop	r26
    8470:	9f 91       	pop	r25
    8472:	8f 91       	pop	r24
    8474:	7f 91       	pop	r23
    8476:	6f 91       	pop	r22
    8478:	5f 91       	pop	r21
    847a:	4f 91       	pop	r20
    847c:	3f 91       	pop	r19
    847e:	2f 91       	pop	r18
    8480:	0f 90       	pop	r0
    8482:	00 92 3b 00 	sts	0x003B, r0
    8486:	0f 90       	pop	r0
    8488:	0f be       	out	0x3f, r0	; 63
    848a:	0f 90       	pop	r0
    848c:	1f 90       	pop	r1
    848e:	18 95       	reti

00008490 <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    8490:	cf 93       	push	r28
    8492:	df 93       	push	r29
    8494:	cd b7       	in	r28, 0x3d	; 61
    8496:	de b7       	in	r29, 0x3e	; 62
    8498:	a0 97       	sbiw	r28, 0x20	; 32
    849a:	cd bf       	out	0x3d, r28	; 61
    849c:	de bf       	out	0x3e, r29	; 62
    849e:	89 8f       	std	Y+25, r24	; 0x19
    84a0:	9a 8f       	std	Y+26, r25	; 0x1a
    84a2:	4b 8f       	std	Y+27, r20	; 0x1b
    84a4:	5c 8f       	std	Y+28, r21	; 0x1c
    84a6:	6d 8f       	std	Y+29, r22	; 0x1d
    84a8:	7e 8f       	std	Y+30, r23	; 0x1e
    84aa:	2f 8f       	std	Y+31, r18	; 0x1f
    84ac:	38 a3       	lds	r19, 0x58
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    84ae:	8f 8d       	ldd	r24, Y+31	; 0x1f
    84b0:	98 a1       	lds	r25, 0x48
    84b2:	fc 01       	movw	r30, r24
    84b4:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    84b6:	19 82       	std	Y+1, r1	; 0x01
    84b8:	1a 82       	std	Y+2, r1	; 0x02
    84ba:	1b 82       	std	Y+3, r1	; 0x03
    84bc:	1c 82       	std	Y+4, r1	; 0x04
    84be:	58 c0       	rjmp	.+176    	; 0x8570 <DeciToString+0xe0>
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    84c0:	89 81       	ldd	r24, Y+1	; 0x01
    84c2:	9a 81       	ldd	r25, Y+2	; 0x02
    84c4:	88 0f       	add	r24, r24
    84c6:	99 1f       	adc	r25, r25
    84c8:	88 0f       	add	r24, r24
    84ca:	99 1f       	adc	r25, r25
    84cc:	29 8d       	ldd	r18, Y+25	; 0x19
    84ce:	3a 8d       	ldd	r19, Y+26	; 0x1a
    84d0:	82 0f       	add	r24, r18
    84d2:	93 1f       	adc	r25, r19
    84d4:	fc 01       	movw	r30, r24
    84d6:	80 81       	ld	r24, Z
    84d8:	91 81       	ldd	r25, Z+1	; 0x01
    84da:	a2 81       	ldd	r26, Z+2	; 0x02
    84dc:	b3 81       	ldd	r27, Z+3	; 0x03
    84de:	2d b7       	in	r18, 0x3d	; 61
    84e0:	3e b7       	in	r19, 0x3e	; 62
    84e2:	28 50       	subi	r18, 0x08	; 8
    84e4:	30 40       	sbci	r19, 0x00	; 0
    84e6:	2d bf       	out	0x3d, r18	; 61
    84e8:	3e bf       	out	0x3e, r19	; 62
    84ea:	2d b7       	in	r18, 0x3d	; 61
    84ec:	3e b7       	in	r19, 0x3e	; 62
    84ee:	2f 5f       	subi	r18, 0xFF	; 255
    84f0:	3f 4f       	sbci	r19, 0xFF	; 255
    84f2:	ae 01       	movw	r20, r28
    84f4:	4b 5f       	subi	r20, 0xFB	; 251
    84f6:	5f 4f       	sbci	r21, 0xFF	; 255
    84f8:	f9 01       	movw	r30, r18
    84fa:	40 83       	st	Z, r20
    84fc:	51 83       	std	Z+1, r21	; 0x01
    84fe:	4c e2       	ldi	r20, 0x2C	; 44
    8500:	50 e2       	ldi	r21, 0x20	; 32
    8502:	f9 01       	movw	r30, r18
    8504:	42 83       	std	Z+2, r20	; 0x02
    8506:	53 83       	std	Z+3, r21	; 0x03
    8508:	f9 01       	movw	r30, r18
    850a:	84 83       	std	Z+4, r24	; 0x04
    850c:	95 83       	std	Z+5, r25	; 0x05
    850e:	a6 83       	std	Z+6, r26	; 0x06
    8510:	b7 83       	std	Z+7, r27	; 0x07
    8512:	0e 94 66 61 	call	0xc2cc	; 0xc2cc <sprintf>
    8516:	2d b7       	in	r18, 0x3d	; 61
    8518:	3e b7       	in	r19, 0x3e	; 62
    851a:	28 5f       	subi	r18, 0xF8	; 248
    851c:	3f 4f       	sbci	r19, 0xFF	; 255
    851e:	2d bf       	out	0x3d, r18	; 61
    8520:	3e bf       	out	0x3e, r19	; 62
		strcat(ReturnString,b);
    8522:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8524:	98 a1       	lds	r25, 0x48
    8526:	9e 01       	movw	r18, r28
    8528:	2b 5f       	subi	r18, 0xFB	; 251
    852a:	3f 4f       	sbci	r19, 0xFF	; 255
    852c:	b9 01       	movw	r22, r18
    852e:	0e 94 1a 61 	call	0xc234	; 0xc234 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    8532:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8534:	98 a1       	lds	r25, 0x48
    8536:	9c 01       	movw	r18, r24
    8538:	f9 01       	movw	r30, r18
    853a:	01 90       	ld	r0, Z+
    853c:	00 20       	and	r0, r0
    853e:	e9 f7       	brne	.-6      	; 0x853a <DeciToString+0xaa>
    8540:	cf 01       	movw	r24, r30
    8542:	01 97       	sbiw	r24, 0x01	; 1
    8544:	82 1b       	sub	r24, r18
    8546:	93 0b       	sbc	r25, r19
    8548:	2f 8d       	ldd	r18, Y+31	; 0x1f
    854a:	38 a1       	lds	r19, 0x48
    854c:	82 0f       	add	r24, r18
    854e:	93 1f       	adc	r25, r19
    8550:	2a e0       	ldi	r18, 0x0A	; 10
    8552:	30 e0       	ldi	r19, 0x00	; 0
    8554:	fc 01       	movw	r30, r24
    8556:	20 83       	st	Z, r18
    8558:	31 83       	std	Z+1, r19	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    855a:	89 81       	ldd	r24, Y+1	; 0x01
    855c:	9a 81       	ldd	r25, Y+2	; 0x02
    855e:	ab 81       	ldd	r26, Y+3	; 0x03
    8560:	bc 81       	ldd	r27, Y+4	; 0x04
    8562:	01 96       	adiw	r24, 0x01	; 1
    8564:	a1 1d       	adc	r26, r1
    8566:	b1 1d       	adc	r27, r1
    8568:	89 83       	std	Y+1, r24	; 0x01
    856a:	9a 83       	std	Y+2, r25	; 0x02
    856c:	ab 83       	std	Y+3, r26	; 0x03
    856e:	bc 83       	std	Y+4, r27	; 0x04
    8570:	29 81       	ldd	r18, Y+1	; 0x01
    8572:	3a 81       	ldd	r19, Y+2	; 0x02
    8574:	4b 81       	ldd	r20, Y+3	; 0x03
    8576:	5c 81       	ldd	r21, Y+4	; 0x04
    8578:	8b 8d       	ldd	r24, Y+27	; 0x1b
    857a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    857c:	ad 8d       	ldd	r26, Y+29	; 0x1d
    857e:	be 8d       	ldd	r27, Y+30	; 0x1e
    8580:	28 17       	cp	r18, r24
    8582:	39 07       	cpc	r19, r25
    8584:	4a 07       	cpc	r20, r26
    8586:	5b 07       	cpc	r21, r27
    8588:	08 f4       	brcc	.+2      	; 0x858c <DeciToString+0xfc>
    858a:	9a cf       	rjmp	.-204    	; 0x84c0 <DeciToString+0x30>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    858c:	a0 96       	adiw	r28, 0x20	; 32
    858e:	cd bf       	out	0x3d, r28	; 61
    8590:	de bf       	out	0x3e, r29	; 62
    8592:	df 91       	pop	r29
    8594:	cf 91       	pop	r28
    8596:	08 95       	ret

00008598 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    8598:	ef 92       	push	r14
    859a:	ff 92       	push	r15
    859c:	0f 93       	push	r16
    859e:	1f 93       	push	r17
    85a0:	cf 93       	push	r28
    85a2:	df 93       	push	r29
    85a4:	cd b7       	in	r28, 0x3d	; 61
    85a6:	de b7       	in	r29, 0x3e	; 62
    85a8:	2a 97       	sbiw	r28, 0x0a	; 10
    85aa:	cd bf       	out	0x3d, r28	; 61
    85ac:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    85ae:	10 92 75 50 	sts	0x5075, r1
    85b2:	10 92 76 50 	sts	0x5076, r1
    85b6:	10 92 77 50 	sts	0x5077, r1
    85ba:	10 92 78 50 	sts	0x5078, r1

SD_read_block(0,SDBuffer);
    85be:	2e ec       	ldi	r18, 0xCE	; 206
    85c0:	31 e2       	ldi	r19, 0x21	; 33
    85c2:	60 e0       	ldi	r22, 0x00	; 0
    85c4:	70 e0       	ldi	r23, 0x00	; 0
    85c6:	cb 01       	movw	r24, r22
    85c8:	a9 01       	movw	r20, r18
    85ca:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    85ce:	8e ec       	ldi	r24, 0xCE	; 206
    85d0:	91 e2       	ldi	r25, 0x21	; 33
    85d2:	89 83       	std	Y+1, r24	; 0x01
    85d4:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    85d6:	89 81       	ldd	r24, Y+1	; 0x01
    85d8:	9a 81       	ldd	r25, Y+2	; 0x02
    85da:	fc 01       	movw	r30, r24
    85dc:	80 81       	ld	r24, Z
    85de:	89 3e       	cpi	r24, 0xE9	; 233
    85e0:	09 f4       	brne	.+2      	; 0x85e4 <getBootSectorData+0x4c>
    85e2:	4d c0       	rjmp	.+154    	; 0x867e <getBootSectorData+0xe6>
    85e4:	89 81       	ldd	r24, Y+1	; 0x01
    85e6:	9a 81       	ldd	r25, Y+2	; 0x02
    85e8:	fc 01       	movw	r30, r24
    85ea:	80 81       	ld	r24, Z
    85ec:	8b 3e       	cpi	r24, 0xEB	; 235
    85ee:	09 f4       	brne	.+2      	; 0x85f2 <getBootSectorData+0x5a>
    85f0:	46 c0       	rjmp	.+140    	; 0x867e <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    85f2:	8e ec       	ldi	r24, 0xCE	; 206
    85f4:	91 e2       	ldi	r25, 0x21	; 33
    85f6:	8b 83       	std	Y+3, r24	; 0x03
    85f8:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    85fa:	8b 81       	ldd	r24, Y+3	; 0x03
    85fc:	9c 81       	ldd	r25, Y+4	; 0x04
    85fe:	82 50       	subi	r24, 0x02	; 2
    8600:	9e 4f       	sbci	r25, 0xFE	; 254
    8602:	fc 01       	movw	r30, r24
    8604:	80 81       	ld	r24, Z
    8606:	91 81       	ldd	r25, Z+1	; 0x01
    8608:	fa ea       	ldi	r31, 0xAA	; 170
    860a:	85 35       	cpi	r24, 0x55	; 85
    860c:	9f 07       	cpc	r25, r31
    860e:	11 f0       	breq	.+4      	; 0x8614 <getBootSectorData+0x7c>
    8610:	81 e0       	ldi	r24, 0x01	; 1
    8612:	01 c1       	rjmp	.+514    	; 0x8816 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    8614:	8b 81       	ldd	r24, Y+3	; 0x03
    8616:	9c 81       	ldd	r25, Y+4	; 0x04
    8618:	82 54       	subi	r24, 0x42	; 66
    861a:	9e 4f       	sbci	r25, 0xFE	; 254
    861c:	8d 83       	std	Y+5, r24	; 0x05
    861e:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    8620:	8d 81       	ldd	r24, Y+5	; 0x05
    8622:	9e 81       	ldd	r25, Y+6	; 0x06
    8624:	fc 01       	movw	r30, r24
    8626:	80 85       	ldd	r24, Z+8	; 0x08
    8628:	91 85       	ldd	r25, Z+9	; 0x09
    862a:	a2 85       	ldd	r26, Z+10	; 0x0a
    862c:	b3 85       	ldd	r27, Z+11	; 0x0b
    862e:	80 93 75 50 	sts	0x5075, r24
    8632:	90 93 76 50 	sts	0x5076, r25
    8636:	a0 93 77 50 	sts	0x5077, r26
    863a:	b0 93 78 50 	sts	0x5078, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    863e:	8d 81       	ldd	r24, Y+5	; 0x05
    8640:	9e 81       	ldd	r25, Y+6	; 0x06
    8642:	fc 01       	movw	r30, r24
    8644:	80 85       	ldd	r24, Z+8	; 0x08
    8646:	91 85       	ldd	r25, Z+9	; 0x09
    8648:	a2 85       	ldd	r26, Z+10	; 0x0a
    864a:	b3 85       	ldd	r27, Z+11	; 0x0b
    864c:	2e ec       	ldi	r18, 0xCE	; 206
    864e:	31 e2       	ldi	r19, 0x21	; 33
    8650:	bc 01       	movw	r22, r24
    8652:	cd 01       	movw	r24, r26
    8654:	a9 01       	movw	r20, r18
    8656:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    865a:	8e ec       	ldi	r24, 0xCE	; 206
    865c:	91 e2       	ldi	r25, 0x21	; 33
    865e:	89 83       	std	Y+1, r24	; 0x01
    8660:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    8662:	89 81       	ldd	r24, Y+1	; 0x01
    8664:	9a 81       	ldd	r25, Y+2	; 0x02
    8666:	fc 01       	movw	r30, r24
    8668:	80 81       	ld	r24, Z
    866a:	89 3e       	cpi	r24, 0xE9	; 233
    866c:	41 f0       	breq	.+16     	; 0x867e <getBootSectorData+0xe6>
    866e:	89 81       	ldd	r24, Y+1	; 0x01
    8670:	9a 81       	ldd	r25, Y+2	; 0x02
    8672:	fc 01       	movw	r30, r24
    8674:	80 81       	ld	r24, Z
    8676:	8b 3e       	cpi	r24, 0xEB	; 235
    8678:	11 f0       	breq	.+4      	; 0x867e <getBootSectorData+0xe6>
    867a:	81 e0       	ldi	r24, 0x01	; 1
    867c:	cc c0       	rjmp	.+408    	; 0x8816 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    867e:	89 81       	ldd	r24, Y+1	; 0x01
    8680:	9a 81       	ldd	r25, Y+2	; 0x02
    8682:	fc 01       	movw	r30, r24
    8684:	83 85       	ldd	r24, Z+11	; 0x0b
    8686:	94 85       	ldd	r25, Z+12	; 0x0c
    8688:	80 93 4c 40 	sts	0x404C, r24
    868c:	90 93 4d 40 	sts	0x404D, r25
sectorPerCluster = bpb->sectorPerCluster;
    8690:	89 81       	ldd	r24, Y+1	; 0x01
    8692:	9a 81       	ldd	r25, Y+2	; 0x02
    8694:	fc 01       	movw	r30, r24
    8696:	85 85       	ldd	r24, Z+13	; 0x0d
    8698:	88 2f       	mov	r24, r24
    869a:	90 e0       	ldi	r25, 0x00	; 0
    869c:	80 93 73 50 	sts	0x5073, r24
    86a0:	90 93 74 50 	sts	0x5074, r25
reservedSectorCount = bpb->reservedSectorCount;
    86a4:	89 81       	ldd	r24, Y+1	; 0x01
    86a6:	9a 81       	ldd	r25, Y+2	; 0x02
    86a8:	fc 01       	movw	r30, r24
    86aa:	86 85       	ldd	r24, Z+14	; 0x0e
    86ac:	97 85       	ldd	r25, Z+15	; 0x0f
    86ae:	80 93 7b 50 	sts	0x507B, r24
    86b2:	90 93 7c 50 	sts	0x507C, r25
rootCluster = bpb->rootCluster;
    86b6:	89 81       	ldd	r24, Y+1	; 0x01
    86b8:	9a 81       	ldd	r25, Y+2	; 0x02
    86ba:	fc 01       	movw	r30, r24
    86bc:	84 a5       	lds	r24, 0x64
    86be:	95 a5       	lds	r25, 0x65
    86c0:	a6 a5       	lds	r26, 0x66
    86c2:	b7 a5       	lds	r27, 0x67
    86c4:	80 93 57 40 	sts	0x4057, r24
    86c8:	90 93 58 40 	sts	0x4058, r25
    86cc:	a0 93 59 40 	sts	0x4059, r26
    86d0:	b0 93 5a 40 	sts	0x405A, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    86d4:	89 81       	ldd	r24, Y+1	; 0x01
    86d6:	9a 81       	ldd	r25, Y+2	; 0x02
    86d8:	fc 01       	movw	r30, r24
    86da:	24 8d       	ldd	r18, Z+28	; 0x1c
    86dc:	35 8d       	ldd	r19, Z+29	; 0x1d
    86de:	46 8d       	ldd	r20, Z+30	; 0x1e
    86e0:	57 8d       	ldd	r21, Z+31	; 0x1f
    86e2:	80 91 7b 50 	lds	r24, 0x507B
    86e6:	90 91 7c 50 	lds	r25, 0x507C
    86ea:	cc 01       	movw	r24, r24
    86ec:	a0 e0       	ldi	r26, 0x00	; 0
    86ee:	b0 e0       	ldi	r27, 0x00	; 0
    86f0:	79 01       	movw	r14, r18
    86f2:	8a 01       	movw	r16, r20
    86f4:	e8 0e       	add	r14, r24
    86f6:	f9 1e       	adc	r15, r25
    86f8:	0a 1f       	adc	r16, r26
    86fa:	1b 1f       	adc	r17, r27
    86fc:	89 81       	ldd	r24, Y+1	; 0x01
    86fe:	9a 81       	ldd	r25, Y+2	; 0x02
    8700:	fc 01       	movw	r30, r24
    8702:	80 89       	ldd	r24, Z+16	; 0x10
    8704:	88 2f       	mov	r24, r24
    8706:	90 e0       	ldi	r25, 0x00	; 0
    8708:	a0 e0       	ldi	r26, 0x00	; 0
    870a:	b0 e0       	ldi	r27, 0x00	; 0
    870c:	29 81       	ldd	r18, Y+1	; 0x01
    870e:	3a 81       	ldd	r19, Y+2	; 0x02
    8710:	f9 01       	movw	r30, r18
    8712:	24 a1       	lds	r18, 0x44
    8714:	35 a1       	lds	r19, 0x45
    8716:	46 a1       	lds	r20, 0x46
    8718:	57 a1       	lds	r21, 0x47
    871a:	bc 01       	movw	r22, r24
    871c:	cd 01       	movw	r24, r26
    871e:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    8722:	dc 01       	movw	r26, r24
    8724:	cb 01       	movw	r24, r22
    8726:	8e 0d       	add	r24, r14
    8728:	9f 1d       	adc	r25, r15
    872a:	a0 1f       	adc	r26, r16
    872c:	b1 1f       	adc	r27, r17
    872e:	80 93 d3 23 	sts	0x23D3, r24
    8732:	90 93 d4 23 	sts	0x23D4, r25
    8736:	a0 93 d5 23 	sts	0x23D5, r26
    873a:	b0 93 d6 23 	sts	0x23D6, r27

dataSectors = bpb->totalSectors_F32
    873e:	89 81       	ldd	r24, Y+1	; 0x01
    8740:	9a 81       	ldd	r25, Y+2	; 0x02
    8742:	fc 01       	movw	r30, r24
    8744:	20 a1       	lds	r18, 0x40
    8746:	31 a1       	lds	r19, 0x41
    8748:	42 a1       	lds	r20, 0x42
    874a:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    874c:	89 81       	ldd	r24, Y+1	; 0x01
    874e:	9a 81       	ldd	r25, Y+2	; 0x02
    8750:	fc 01       	movw	r30, r24
    8752:	86 85       	ldd	r24, Z+14	; 0x0e
    8754:	97 85       	ldd	r25, Z+15	; 0x0f
    8756:	cc 01       	movw	r24, r24
    8758:	a0 e0       	ldi	r26, 0x00	; 0
    875a:	b0 e0       	ldi	r27, 0x00	; 0
    875c:	79 01       	movw	r14, r18
    875e:	8a 01       	movw	r16, r20
    8760:	e8 1a       	sub	r14, r24
    8762:	f9 0a       	sbc	r15, r25
    8764:	0a 0b       	sbc	r16, r26
    8766:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    8768:	89 81       	ldd	r24, Y+1	; 0x01
    876a:	9a 81       	ldd	r25, Y+2	; 0x02
    876c:	fc 01       	movw	r30, r24
    876e:	80 89       	ldd	r24, Z+16	; 0x10
    8770:	88 2f       	mov	r24, r24
    8772:	90 e0       	ldi	r25, 0x00	; 0
    8774:	a0 e0       	ldi	r26, 0x00	; 0
    8776:	b0 e0       	ldi	r27, 0x00	; 0
    8778:	29 81       	ldd	r18, Y+1	; 0x01
    877a:	3a 81       	ldd	r19, Y+2	; 0x02
    877c:	f9 01       	movw	r30, r18
    877e:	24 a1       	lds	r18, 0x44
    8780:	35 a1       	lds	r19, 0x45
    8782:	46 a1       	lds	r20, 0x46
    8784:	57 a1       	lds	r21, 0x47
    8786:	bc 01       	movw	r22, r24
    8788:	cd 01       	movw	r24, r26
    878a:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    878e:	dc 01       	movw	r26, r24
    8790:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    8792:	a8 01       	movw	r20, r16
    8794:	97 01       	movw	r18, r14
    8796:	28 1b       	sub	r18, r24
    8798:	39 0b       	sbc	r19, r25
    879a:	4a 0b       	sbc	r20, r26
    879c:	5b 0b       	sbc	r21, r27
    879e:	da 01       	movw	r26, r20
    87a0:	c9 01       	movw	r24, r18
    87a2:	8f 83       	std	Y+7, r24	; 0x07
    87a4:	98 87       	std	Y+8, r25	; 0x08
    87a6:	a9 87       	std	Y+9, r26	; 0x09
    87a8:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    87aa:	80 91 73 50 	lds	r24, 0x5073
    87ae:	90 91 74 50 	lds	r25, 0x5074
    87b2:	9c 01       	movw	r18, r24
    87b4:	40 e0       	ldi	r20, 0x00	; 0
    87b6:	50 e0       	ldi	r21, 0x00	; 0
    87b8:	8f 81       	ldd	r24, Y+7	; 0x07
    87ba:	98 85       	ldd	r25, Y+8	; 0x08
    87bc:	a9 85       	ldd	r26, Y+9	; 0x09
    87be:	ba 85       	ldd	r27, Y+10	; 0x0a
    87c0:	bc 01       	movw	r22, r24
    87c2:	cd 01       	movw	r24, r26
    87c4:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    87c8:	da 01       	movw	r26, r20
    87ca:	c9 01       	movw	r24, r18
    87cc:	80 93 51 40 	sts	0x4051, r24
    87d0:	90 93 52 40 	sts	0x4052, r25
    87d4:	a0 93 53 40 	sts	0x4053, r26
    87d8:	b0 93 54 40 	sts	0x4054, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    87dc:	81 e0       	ldi	r24, 0x01	; 1
    87de:	60 e0       	ldi	r22, 0x00	; 0
    87e0:	20 e0       	ldi	r18, 0x00	; 0
    87e2:	30 e0       	ldi	r19, 0x00	; 0
    87e4:	a9 01       	movw	r20, r18
    87e6:	0e 94 f0 44 	call	0x89e0	; 0x89e0 <getSetFreeCluster>
    87ea:	9b 01       	movw	r18, r22
    87ec:	ac 01       	movw	r20, r24
    87ee:	80 91 51 40 	lds	r24, 0x4051
    87f2:	90 91 52 40 	lds	r25, 0x4052
    87f6:	a0 91 53 40 	lds	r26, 0x4053
    87fa:	b0 91 54 40 	lds	r27, 0x4054
    87fe:	82 17       	cp	r24, r18
    8800:	93 07       	cpc	r25, r19
    8802:	a4 07       	cpc	r26, r20
    8804:	b5 07       	cpc	r27, r21
    8806:	18 f4       	brcc	.+6      	; 0x880e <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    8808:	10 92 bf 50 	sts	0x50BF, r1
    880c:	03 c0       	rjmp	.+6      	; 0x8814 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    880e:	81 e0       	ldi	r24, 0x01	; 1
    8810:	80 93 bf 50 	sts	0x50BF, r24
return 0;
    8814:	80 e0       	ldi	r24, 0x00	; 0
}
    8816:	2a 96       	adiw	r28, 0x0a	; 10
    8818:	cd bf       	out	0x3d, r28	; 61
    881a:	de bf       	out	0x3e, r29	; 62
    881c:	df 91       	pop	r29
    881e:	cf 91       	pop	r28
    8820:	1f 91       	pop	r17
    8822:	0f 91       	pop	r16
    8824:	ff 90       	pop	r15
    8826:	ef 90       	pop	r14
    8828:	08 95       	ret

0000882a <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    882a:	cf 93       	push	r28
    882c:	df 93       	push	r29
    882e:	00 d0       	rcall	.+0      	; 0x8830 <getFirstSector+0x6>
    8830:	0f 92       	push	r0
    8832:	cd b7       	in	r28, 0x3d	; 61
    8834:	de b7       	in	r29, 0x3e	; 62
    8836:	69 83       	std	Y+1, r22	; 0x01
    8838:	7a 83       	std	Y+2, r23	; 0x02
    883a:	8b 83       	std	Y+3, r24	; 0x03
    883c:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    883e:	89 81       	ldd	r24, Y+1	; 0x01
    8840:	9a 81       	ldd	r25, Y+2	; 0x02
    8842:	ab 81       	ldd	r26, Y+3	; 0x03
    8844:	bc 81       	ldd	r27, Y+4	; 0x04
    8846:	02 97       	sbiw	r24, 0x02	; 2
    8848:	a1 09       	sbc	r26, r1
    884a:	b1 09       	sbc	r27, r1
    884c:	20 91 73 50 	lds	r18, 0x5073
    8850:	30 91 74 50 	lds	r19, 0x5074
    8854:	99 01       	movw	r18, r18
    8856:	40 e0       	ldi	r20, 0x00	; 0
    8858:	50 e0       	ldi	r21, 0x00	; 0
    885a:	bc 01       	movw	r22, r24
    885c:	cd 01       	movw	r24, r26
    885e:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    8862:	9b 01       	movw	r18, r22
    8864:	ac 01       	movw	r20, r24
    8866:	80 91 d3 23 	lds	r24, 0x23D3
    886a:	90 91 d4 23 	lds	r25, 0x23D4
    886e:	a0 91 d5 23 	lds	r26, 0x23D5
    8872:	b0 91 d6 23 	lds	r27, 0x23D6
    8876:	82 0f       	add	r24, r18
    8878:	93 1f       	adc	r25, r19
    887a:	a4 1f       	adc	r26, r20
    887c:	b5 1f       	adc	r27, r21
}
    887e:	bc 01       	movw	r22, r24
    8880:	cd 01       	movw	r24, r26
    8882:	24 96       	adiw	r28, 0x04	; 4
    8884:	cd bf       	out	0x3d, r28	; 61
    8886:	de bf       	out	0x3e, r29	; 62
    8888:	df 91       	pop	r29
    888a:	cf 91       	pop	r28
    888c:	08 95       	ret

0000888e <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    888e:	ef 92       	push	r14
    8890:	ff 92       	push	r15
    8892:	0f 93       	push	r16
    8894:	1f 93       	push	r17
    8896:	cf 93       	push	r28
    8898:	df 93       	push	r29
    889a:	cd b7       	in	r28, 0x3d	; 61
    889c:	de b7       	in	r29, 0x3e	; 62
    889e:	61 97       	sbiw	r28, 0x11	; 17
    88a0:	cd bf       	out	0x3d, r28	; 61
    88a2:	de bf       	out	0x3e, r29	; 62
    88a4:	69 87       	std	Y+9, r22	; 0x09
    88a6:	7a 87       	std	Y+10, r23	; 0x0a
    88a8:	8b 87       	std	Y+11, r24	; 0x0b
    88aa:	9c 87       	std	Y+12, r25	; 0x0c
    88ac:	4d 87       	std	Y+13, r20	; 0x0d
    88ae:	0e 87       	std	Y+14, r16	; 0x0e
    88b0:	1f 87       	std	Y+15, r17	; 0x0f
    88b2:	28 8b       	std	Y+16, r18	; 0x10
    88b4:	39 8b       	std	Y+17, r19	; 0x11
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    88b6:	80 91 7b 50 	lds	r24, 0x507B
    88ba:	90 91 7c 50 	lds	r25, 0x507C
    88be:	9c 01       	movw	r18, r24
    88c0:	40 e0       	ldi	r20, 0x00	; 0
    88c2:	50 e0       	ldi	r21, 0x00	; 0
    88c4:	80 91 75 50 	lds	r24, 0x5075
    88c8:	90 91 76 50 	lds	r25, 0x5076
    88cc:	a0 91 77 50 	lds	r26, 0x5077
    88d0:	b0 91 78 50 	lds	r27, 0x5078
    88d4:	79 01       	movw	r14, r18
    88d6:	8a 01       	movw	r16, r20
    88d8:	e8 0e       	add	r14, r24
    88da:	f9 1e       	adc	r15, r25
    88dc:	0a 1f       	adc	r16, r26
    88de:	1b 1f       	adc	r17, r27
    88e0:	89 85       	ldd	r24, Y+9	; 0x09
    88e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    88e4:	ab 85       	ldd	r26, Y+11	; 0x0b
    88e6:	bc 85       	ldd	r27, Y+12	; 0x0c
    88e8:	88 0f       	add	r24, r24
    88ea:	99 1f       	adc	r25, r25
    88ec:	aa 1f       	adc	r26, r26
    88ee:	bb 1f       	adc	r27, r27
    88f0:	88 0f       	add	r24, r24
    88f2:	99 1f       	adc	r25, r25
    88f4:	aa 1f       	adc	r26, r26
    88f6:	bb 1f       	adc	r27, r27
    88f8:	20 91 4c 40 	lds	r18, 0x404C
    88fc:	30 91 4d 40 	lds	r19, 0x404D
    8900:	99 01       	movw	r18, r18
    8902:	40 e0       	ldi	r20, 0x00	; 0
    8904:	50 e0       	ldi	r21, 0x00	; 0
    8906:	bc 01       	movw	r22, r24
    8908:	cd 01       	movw	r24, r26
    890a:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    890e:	da 01       	movw	r26, r20
    8910:	c9 01       	movw	r24, r18
    8912:	8e 0d       	add	r24, r14
    8914:	9f 1d       	adc	r25, r15
    8916:	a0 1f       	adc	r26, r16
    8918:	b1 1f       	adc	r27, r17
    891a:	89 83       	std	Y+1, r24	; 0x01
    891c:	9a 83       	std	Y+2, r25	; 0x02
    891e:	ab 83       	std	Y+3, r26	; 0x03
    8920:	bc 83       	std	Y+4, r27	; 0x04

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    8922:	89 85       	ldd	r24, Y+9	; 0x09
    8924:	9a 85       	ldd	r25, Y+10	; 0x0a
    8926:	ab 85       	ldd	r26, Y+11	; 0x0b
    8928:	bc 85       	ldd	r27, Y+12	; 0x0c
    892a:	88 0f       	add	r24, r24
    892c:	99 1f       	adc	r25, r25
    892e:	aa 1f       	adc	r26, r26
    8930:	bb 1f       	adc	r27, r27
    8932:	88 0f       	add	r24, r24
    8934:	99 1f       	adc	r25, r25
    8936:	aa 1f       	adc	r26, r26
    8938:	bb 1f       	adc	r27, r27
    893a:	20 91 4c 40 	lds	r18, 0x404C
    893e:	30 91 4d 40 	lds	r19, 0x404D
    8942:	99 01       	movw	r18, r18
    8944:	40 e0       	ldi	r20, 0x00	; 0
    8946:	50 e0       	ldi	r21, 0x00	; 0
    8948:	bc 01       	movw	r22, r24
    894a:	cd 01       	movw	r24, r26
    894c:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    8950:	dc 01       	movw	r26, r24
    8952:	cb 01       	movw	r24, r22
    8954:	8d 83       	std	Y+5, r24	; 0x05
    8956:	9e 83       	std	Y+6, r25	; 0x06

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    8958:	89 81       	ldd	r24, Y+1	; 0x01
    895a:	9a 81       	ldd	r25, Y+2	; 0x02
    895c:	ab 81       	ldd	r26, Y+3	; 0x03
    895e:	bc 81       	ldd	r27, Y+4	; 0x04
    8960:	2e ec       	ldi	r18, 0xCE	; 206
    8962:	31 e2       	ldi	r19, 0x21	; 33
    8964:	bc 01       	movw	r22, r24
    8966:	cd 01       	movw	r24, r26
    8968:	a9 01       	movw	r20, r18
    896a:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    896e:	8d 81       	ldd	r24, Y+5	; 0x05
    8970:	9e 81       	ldd	r25, Y+6	; 0x06
    8972:	82 53       	subi	r24, 0x32	; 50
    8974:	9e 4d       	sbci	r25, 0xDE	; 222
    8976:	8f 83       	std	Y+7, r24	; 0x07
    8978:	98 87       	std	Y+8, r25	; 0x08

if(get_set == GET)
    897a:	8d 85       	ldd	r24, Y+13	; 0x0d
    897c:	88 23       	and	r24, r24
    897e:	49 f4       	brne	.+18     	; 0x8992 <getSetNextCluster+0x104>
  return ((*FATEntryValue) & 0x0fffffff);
    8980:	8f 81       	ldd	r24, Y+7	; 0x07
    8982:	98 85       	ldd	r25, Y+8	; 0x08
    8984:	fc 01       	movw	r30, r24
    8986:	80 81       	ld	r24, Z
    8988:	91 81       	ldd	r25, Z+1	; 0x01
    898a:	a2 81       	ldd	r26, Z+2	; 0x02
    898c:	b3 81       	ldd	r27, Z+3	; 0x03
    898e:	bf 70       	andi	r27, 0x0F	; 15
    8990:	1b c0       	rjmp	.+54     	; 0x89c8 <getSetNextCluster+0x13a>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    8992:	2f 81       	ldd	r18, Y+7	; 0x07
    8994:	38 85       	ldd	r19, Y+8	; 0x08
    8996:	8e 85       	ldd	r24, Y+14	; 0x0e
    8998:	9f 85       	ldd	r25, Y+15	; 0x0f
    899a:	a8 89       	ldd	r26, Y+16	; 0x10
    899c:	b9 89       	ldd	r27, Y+17	; 0x11
    899e:	f9 01       	movw	r30, r18
    89a0:	80 83       	st	Z, r24
    89a2:	91 83       	std	Z+1, r25	; 0x01
    89a4:	a2 83       	std	Z+2, r26	; 0x02
    89a6:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    89a8:	89 81       	ldd	r24, Y+1	; 0x01
    89aa:	9a 81       	ldd	r25, Y+2	; 0x02
    89ac:	ab 81       	ldd	r26, Y+3	; 0x03
    89ae:	bc 81       	ldd	r27, Y+4	; 0x04
    89b0:	2e ec       	ldi	r18, 0xCE	; 206
    89b2:	31 e2       	ldi	r19, 0x21	; 33
    89b4:	bc 01       	movw	r22, r24
    89b6:	cd 01       	movw	r24, r26
    89b8:	a9 01       	movw	r20, r18
    89ba:	20 e0       	ldi	r18, 0x00	; 0
    89bc:	32 e0       	ldi	r19, 0x02	; 2
    89be:	0e 94 5c 51 	call	0xa2b8	; 0xa2b8 <SD_write_block>

return (0);
    89c2:	80 e0       	ldi	r24, 0x00	; 0
    89c4:	90 e0       	ldi	r25, 0x00	; 0
    89c6:	dc 01       	movw	r26, r24
}
    89c8:	bc 01       	movw	r22, r24
    89ca:	cd 01       	movw	r24, r26
    89cc:	61 96       	adiw	r28, 0x11	; 17
    89ce:	cd bf       	out	0x3d, r28	; 61
    89d0:	de bf       	out	0x3e, r29	; 62
    89d2:	df 91       	pop	r29
    89d4:	cf 91       	pop	r28
    89d6:	1f 91       	pop	r17
    89d8:	0f 91       	pop	r16
    89da:	ff 90       	pop	r15
    89dc:	ef 90       	pop	r14
    89de:	08 95       	ret

000089e0 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    89e0:	cf 93       	push	r28
    89e2:	df 93       	push	r29
    89e4:	cd b7       	in	r28, 0x3d	; 61
    89e6:	de b7       	in	r29, 0x3e	; 62
    89e8:	28 97       	sbiw	r28, 0x08	; 8
    89ea:	cd bf       	out	0x3d, r28	; 61
    89ec:	de bf       	out	0x3e, r29	; 62
    89ee:	8b 83       	std	Y+3, r24	; 0x03
    89f0:	6c 83       	std	Y+4, r22	; 0x04
    89f2:	2d 83       	std	Y+5, r18	; 0x05
    89f4:	3e 83       	std	Y+6, r19	; 0x06
    89f6:	4f 83       	std	Y+7, r20	; 0x07
    89f8:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    89fa:	8e ec       	ldi	r24, 0xCE	; 206
    89fc:	91 e2       	ldi	r25, 0x21	; 33
    89fe:	89 83       	std	Y+1, r24	; 0x01
    8a00:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    8a02:	80 91 75 50 	lds	r24, 0x5075
    8a06:	90 91 76 50 	lds	r25, 0x5076
    8a0a:	a0 91 77 50 	lds	r26, 0x5077
    8a0e:	b0 91 78 50 	lds	r27, 0x5078
    8a12:	01 96       	adiw	r24, 0x01	; 1
    8a14:	a1 1d       	adc	r26, r1
    8a16:	b1 1d       	adc	r27, r1
    8a18:	2e ec       	ldi	r18, 0xCE	; 206
    8a1a:	31 e2       	ldi	r19, 0x21	; 33
    8a1c:	bc 01       	movw	r22, r24
    8a1e:	cd 01       	movw	r24, r26
    8a20:	a9 01       	movw	r20, r18
    8a22:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    8a26:	89 81       	ldd	r24, Y+1	; 0x01
    8a28:	9a 81       	ldd	r25, Y+2	; 0x02
    8a2a:	fc 01       	movw	r30, r24
    8a2c:	80 81       	ld	r24, Z
    8a2e:	91 81       	ldd	r25, Z+1	; 0x01
    8a30:	a2 81       	ldd	r26, Z+2	; 0x02
    8a32:	b3 81       	ldd	r27, Z+3	; 0x03
    8a34:	82 35       	cpi	r24, 0x52	; 82
    8a36:	f2 e5       	ldi	r31, 0x52	; 82
    8a38:	9f 07       	cpc	r25, r31
    8a3a:	f1 e6       	ldi	r31, 0x61	; 97
    8a3c:	af 07       	cpc	r26, r31
    8a3e:	f1 e4       	ldi	r31, 0x41	; 65
    8a40:	bf 07       	cpc	r27, r31
    8a42:	11 f5       	brne	.+68     	; 0x8a88 <getSetFreeCluster+0xa8>
    8a44:	89 81       	ldd	r24, Y+1	; 0x01
    8a46:	9a 81       	ldd	r25, Y+2	; 0x02
    8a48:	8c 51       	subi	r24, 0x1C	; 28
    8a4a:	9e 4f       	sbci	r25, 0xFE	; 254
    8a4c:	fc 01       	movw	r30, r24
    8a4e:	80 81       	ld	r24, Z
    8a50:	91 81       	ldd	r25, Z+1	; 0x01
    8a52:	a2 81       	ldd	r26, Z+2	; 0x02
    8a54:	b3 81       	ldd	r27, Z+3	; 0x03
    8a56:	82 37       	cpi	r24, 0x72	; 114
    8a58:	f2 e7       	ldi	r31, 0x72	; 114
    8a5a:	9f 07       	cpc	r25, r31
    8a5c:	f1 e4       	ldi	r31, 0x41	; 65
    8a5e:	af 07       	cpc	r26, r31
    8a60:	f1 e6       	ldi	r31, 0x61	; 97
    8a62:	bf 07       	cpc	r27, r31
    8a64:	89 f4       	brne	.+34     	; 0x8a88 <getSetFreeCluster+0xa8>
    8a66:	89 81       	ldd	r24, Y+1	; 0x01
    8a68:	9a 81       	ldd	r25, Y+2	; 0x02
    8a6a:	84 50       	subi	r24, 0x04	; 4
    8a6c:	9e 4f       	sbci	r25, 0xFE	; 254
    8a6e:	fc 01       	movw	r30, r24
    8a70:	80 81       	ld	r24, Z
    8a72:	91 81       	ldd	r25, Z+1	; 0x01
    8a74:	a2 81       	ldd	r26, Z+2	; 0x02
    8a76:	b3 81       	ldd	r27, Z+3	; 0x03
    8a78:	80 30       	cpi	r24, 0x00	; 0
    8a7a:	f0 e0       	ldi	r31, 0x00	; 0
    8a7c:	9f 07       	cpc	r25, r31
    8a7e:	f5 e5       	ldi	r31, 0x55	; 85
    8a80:	af 07       	cpc	r26, r31
    8a82:	fa ea       	ldi	r31, 0xAA	; 170
    8a84:	bf 07       	cpc	r27, r31
    8a86:	21 f0       	breq	.+8      	; 0x8a90 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    8a88:	8f ef       	ldi	r24, 0xFF	; 255
    8a8a:	9f ef       	ldi	r25, 0xFF	; 255
    8a8c:	dc 01       	movw	r26, r24
    8a8e:	51 c0       	rjmp	.+162    	; 0x8b32 <getSetFreeCluster+0x152>

 if(get_set == GET)
    8a90:	8c 81       	ldd	r24, Y+4	; 0x04
    8a92:	88 23       	and	r24, r24
    8a94:	b9 f4       	brne	.+46     	; 0x8ac4 <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    8a96:	8b 81       	ldd	r24, Y+3	; 0x03
    8a98:	81 30       	cpi	r24, 0x01	; 1
    8a9a:	51 f4       	brne	.+20     	; 0x8ab0 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    8a9c:	89 81       	ldd	r24, Y+1	; 0x01
    8a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    8aa0:	88 51       	subi	r24, 0x18	; 24
    8aa2:	9e 4f       	sbci	r25, 0xFE	; 254
    8aa4:	fc 01       	movw	r30, r24
    8aa6:	80 81       	ld	r24, Z
    8aa8:	91 81       	ldd	r25, Z+1	; 0x01
    8aaa:	a2 81       	ldd	r26, Z+2	; 0x02
    8aac:	b3 81       	ldd	r27, Z+3	; 0x03
    8aae:	41 c0       	rjmp	.+130    	; 0x8b32 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    8ab0:	89 81       	ldd	r24, Y+1	; 0x01
    8ab2:	9a 81       	ldd	r25, Y+2	; 0x02
    8ab4:	84 51       	subi	r24, 0x14	; 20
    8ab6:	9e 4f       	sbci	r25, 0xFE	; 254
    8ab8:	fc 01       	movw	r30, r24
    8aba:	80 81       	ld	r24, Z
    8abc:	91 81       	ldd	r25, Z+1	; 0x01
    8abe:	a2 81       	ldd	r26, Z+2	; 0x02
    8ac0:	b3 81       	ldd	r27, Z+3	; 0x03
    8ac2:	37 c0       	rjmp	.+110    	; 0x8b32 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    8ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    8ac6:	81 30       	cpi	r24, 0x01	; 1
    8ac8:	79 f4       	brne	.+30     	; 0x8ae8 <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    8aca:	89 81       	ldd	r24, Y+1	; 0x01
    8acc:	9a 81       	ldd	r25, Y+2	; 0x02
    8ace:	9c 01       	movw	r18, r24
    8ad0:	28 51       	subi	r18, 0x18	; 24
    8ad2:	3e 4f       	sbci	r19, 0xFE	; 254
    8ad4:	8d 81       	ldd	r24, Y+5	; 0x05
    8ad6:	9e 81       	ldd	r25, Y+6	; 0x06
    8ad8:	af 81       	ldd	r26, Y+7	; 0x07
    8ada:	b8 85       	ldd	r27, Y+8	; 0x08
    8adc:	f9 01       	movw	r30, r18
    8ade:	80 83       	st	Z, r24
    8ae0:	91 83       	std	Z+1, r25	; 0x01
    8ae2:	a2 83       	std	Z+2, r26	; 0x02
    8ae4:	b3 83       	std	Z+3, r27	; 0x03
    8ae6:	0e c0       	rjmp	.+28     	; 0x8b04 <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    8ae8:	89 81       	ldd	r24, Y+1	; 0x01
    8aea:	9a 81       	ldd	r25, Y+2	; 0x02
    8aec:	9c 01       	movw	r18, r24
    8aee:	24 51       	subi	r18, 0x14	; 20
    8af0:	3e 4f       	sbci	r19, 0xFE	; 254
    8af2:	8d 81       	ldd	r24, Y+5	; 0x05
    8af4:	9e 81       	ldd	r25, Y+6	; 0x06
    8af6:	af 81       	ldd	r26, Y+7	; 0x07
    8af8:	b8 85       	ldd	r27, Y+8	; 0x08
    8afa:	f9 01       	movw	r30, r18
    8afc:	80 83       	st	Z, r24
    8afe:	91 83       	std	Z+1, r25	; 0x01
    8b00:	a2 83       	std	Z+2, r26	; 0x02
    8b02:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    8b04:	80 91 75 50 	lds	r24, 0x5075
    8b08:	90 91 76 50 	lds	r25, 0x5076
    8b0c:	a0 91 77 50 	lds	r26, 0x5077
    8b10:	b0 91 78 50 	lds	r27, 0x5078
    8b14:	01 96       	adiw	r24, 0x01	; 1
    8b16:	a1 1d       	adc	r26, r1
    8b18:	b1 1d       	adc	r27, r1
    8b1a:	2e ec       	ldi	r18, 0xCE	; 206
    8b1c:	31 e2       	ldi	r19, 0x21	; 33
    8b1e:	bc 01       	movw	r22, r24
    8b20:	cd 01       	movw	r24, r26
    8b22:	a9 01       	movw	r20, r18
    8b24:	20 e0       	ldi	r18, 0x00	; 0
    8b26:	32 e0       	ldi	r19, 0x02	; 2
    8b28:	0e 94 5c 51 	call	0xa2b8	; 0xa2b8 <SD_write_block>
 }
 return 0xffffffff;
    8b2c:	8f ef       	ldi	r24, 0xFF	; 255
    8b2e:	9f ef       	ldi	r25, 0xFF	; 255
    8b30:	dc 01       	movw	r26, r24
}
    8b32:	bc 01       	movw	r22, r24
    8b34:	cd 01       	movw	r24, r26
    8b36:	28 96       	adiw	r28, 0x08	; 8
    8b38:	cd bf       	out	0x3d, r28	; 61
    8b3a:	de bf       	out	0x3e, r29	; 62
    8b3c:	df 91       	pop	r29
    8b3e:	cf 91       	pop	r28
    8b40:	08 95       	ret

00008b42 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    8b42:	0f 93       	push	r16
    8b44:	1f 93       	push	r17
    8b46:	cf 93       	push	r28
    8b48:	df 93       	push	r29
    8b4a:	cd b7       	in	r28, 0x3d	; 61
    8b4c:	de b7       	in	r29, 0x3e	; 62
    8b4e:	6c 97       	sbiw	r28, 0x1c	; 28
    8b50:	cd bf       	out	0x3d, r28	; 61
    8b52:	de bf       	out	0x3e, r29	; 62
    8b54:	8a 8f       	std	Y+26, r24	; 0x1a
    8b56:	6b 8f       	std	Y+27, r22	; 0x1b
    8b58:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    8b5a:	80 91 57 40 	lds	r24, 0x4057
    8b5e:	90 91 58 40 	lds	r25, 0x4058
    8b62:	a0 91 59 40 	lds	r26, 0x4059
    8b66:	b0 91 5a 40 	lds	r27, 0x405A
    8b6a:	89 83       	std	Y+1, r24	; 0x01
    8b6c:	9a 83       	std	Y+2, r25	; 0x02
    8b6e:	ab 83       	std	Y+3, r26	; 0x03
    8b70:	bc 83       	std	Y+4, r27	; 0x04
    8b72:	01 c0       	rjmp	.+2      	; 0x8b76 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    8b74:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    8b76:	89 81       	ldd	r24, Y+1	; 0x01
    8b78:	9a 81       	ldd	r25, Y+2	; 0x02
    8b7a:	ab 81       	ldd	r26, Y+3	; 0x03
    8b7c:	bc 81       	ldd	r27, Y+4	; 0x04
    8b7e:	bc 01       	movw	r22, r24
    8b80:	cd 01       	movw	r24, r26
    8b82:	0e 94 15 44 	call	0x882a	; 0x882a <getFirstSector>
    8b86:	dc 01       	movw	r26, r24
    8b88:	cb 01       	movw	r24, r22
    8b8a:	88 8b       	std	Y+16, r24	; 0x10
    8b8c:	99 8b       	std	Y+17, r25	; 0x11
    8b8e:	aa 8b       	std	Y+18, r26	; 0x12
    8b90:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    8b92:	1d 82       	std	Y+5, r1	; 0x05
    8b94:	1e 82       	std	Y+6, r1	; 0x06
    8b96:	1f 82       	std	Y+7, r1	; 0x07
    8b98:	18 86       	std	Y+8, r1	; 0x08
    8b9a:	68 c1       	rjmp	.+720    	; 0x8e6c <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    8b9c:	28 89       	ldd	r18, Y+16	; 0x10
    8b9e:	39 89       	ldd	r19, Y+17	; 0x11
    8ba0:	4a 89       	ldd	r20, Y+18	; 0x12
    8ba2:	5b 89       	ldd	r21, Y+19	; 0x13
    8ba4:	8d 81       	ldd	r24, Y+5	; 0x05
    8ba6:	9e 81       	ldd	r25, Y+6	; 0x06
    8ba8:	af 81       	ldd	r26, Y+7	; 0x07
    8baa:	b8 85       	ldd	r27, Y+8	; 0x08
    8bac:	82 0f       	add	r24, r18
    8bae:	93 1f       	adc	r25, r19
    8bb0:	a4 1f       	adc	r26, r20
    8bb2:	b5 1f       	adc	r27, r21
    8bb4:	2e ec       	ldi	r18, 0xCE	; 206
    8bb6:	31 e2       	ldi	r19, 0x21	; 33
    8bb8:	bc 01       	movw	r22, r24
    8bba:	cd 01       	movw	r24, r26
    8bbc:	a9 01       	movw	r20, r18
    8bbe:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    8bc2:	1d 86       	std	Y+13, r1	; 0x0d
    8bc4:	1e 86       	std	Y+14, r1	; 0x0e
    8bc6:	3d c1       	rjmp	.+634    	; 0x8e42 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    8bc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    8bca:	9e 85       	ldd	r25, Y+14	; 0x0e
    8bcc:	82 53       	subi	r24, 0x32	; 50
    8bce:	9e 4d       	sbci	r25, 0xDE	; 222
    8bd0:	8c 8b       	std	Y+20, r24	; 0x14
    8bd2:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    8bd4:	8c 89       	ldd	r24, Y+20	; 0x14
    8bd6:	9d 89       	ldd	r25, Y+21	; 0x15
    8bd8:	fc 01       	movw	r30, r24
    8bda:	80 81       	ld	r24, Z
    8bdc:	88 23       	and	r24, r24
    8bde:	19 f4       	brne	.+6      	; 0x8be6 <findFiles+0xa4>
		{
		  return 0;   
    8be0:	80 e0       	ldi	r24, 0x00	; 0
    8be2:	90 e0       	ldi	r25, 0x00	; 0
    8be4:	80 c1       	rjmp	.+768    	; 0x8ee6 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    8be6:	8c 89       	ldd	r24, Y+20	; 0x14
    8be8:	9d 89       	ldd	r25, Y+21	; 0x15
    8bea:	fc 01       	movw	r30, r24
    8bec:	80 81       	ld	r24, Z
    8bee:	85 3e       	cpi	r24, 0xE5	; 229
    8bf0:	09 f4       	brne	.+2      	; 0x8bf4 <findFiles+0xb2>
    8bf2:	22 c1       	rjmp	.+580    	; 0x8e38 <findFiles+0x2f6>
    8bf4:	8c 89       	ldd	r24, Y+20	; 0x14
    8bf6:	9d 89       	ldd	r25, Y+21	; 0x15
    8bf8:	fc 01       	movw	r30, r24
    8bfa:	83 85       	ldd	r24, Z+11	; 0x0b
    8bfc:	8f 30       	cpi	r24, 0x0F	; 15
    8bfe:	09 f4       	brne	.+2      	; 0x8c02 <findFiles+0xc0>
    8c00:	1b c1       	rjmp	.+566    	; 0x8e38 <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    8c02:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8c04:	81 30       	cpi	r24, 0x01	; 1
    8c06:	21 f0       	breq	.+8      	; 0x8c10 <findFiles+0xce>
    8c08:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8c0a:	82 30       	cpi	r24, 0x02	; 2
    8c0c:	09 f0       	breq	.+2      	; 0x8c10 <findFiles+0xce>
    8c0e:	11 c1       	rjmp	.+546    	; 0x8e32 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8c10:	1f 86       	std	Y+15, r1	; 0x0f
    8c12:	17 c0       	rjmp	.+46     	; 0x8c42 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    8c14:	8f 85       	ldd	r24, Y+15	; 0x0f
    8c16:	88 2f       	mov	r24, r24
    8c18:	90 e0       	ldi	r25, 0x00	; 0
    8c1a:	2c 89       	ldd	r18, Y+20	; 0x14
    8c1c:	3d 89       	ldd	r19, Y+21	; 0x15
    8c1e:	82 0f       	add	r24, r18
    8c20:	93 1f       	adc	r25, r19
    8c22:	fc 01       	movw	r30, r24
    8c24:	40 81       	ld	r20, Z
    8c26:	8f 85       	ldd	r24, Y+15	; 0x0f
    8c28:	88 2f       	mov	r24, r24
    8c2a:	90 e0       	ldi	r25, 0x00	; 0
    8c2c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    8c2e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    8c30:	82 0f       	add	r24, r18
    8c32:	93 1f       	adc	r25, r19
    8c34:	fc 01       	movw	r30, r24
    8c36:	80 81       	ld	r24, Z
    8c38:	48 17       	cp	r20, r24
    8c3a:	39 f4       	brne	.+14     	; 0x8c4a <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    8c3c:	8f 85       	ldd	r24, Y+15	; 0x0f
    8c3e:	8f 5f       	subi	r24, 0xFF	; 255
    8c40:	8f 87       	std	Y+15, r24	; 0x0f
    8c42:	8f 85       	ldd	r24, Y+15	; 0x0f
    8c44:	8b 30       	cpi	r24, 0x0B	; 11
    8c46:	30 f3       	brcs	.-52     	; 0x8c14 <findFiles+0xd2>
    8c48:	01 c0       	rjmp	.+2      	; 0x8c4c <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    8c4a:	00 00       	nop
            if(j == 11)
    8c4c:	8f 85       	ldd	r24, Y+15	; 0x0f
    8c4e:	8b 30       	cpi	r24, 0x0B	; 11
    8c50:	09 f0       	breq	.+2      	; 0x8c54 <findFiles+0x112>
    8c52:	f2 c0       	rjmp	.+484    	; 0x8e38 <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    8c54:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8c56:	81 30       	cpi	r24, 0x01	; 1
    8c58:	09 f0       	breq	.+2      	; 0x8c5c <findFiles+0x11a>
    8c5a:	52 c0       	rjmp	.+164    	; 0x8d00 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    8c5c:	28 89       	ldd	r18, Y+16	; 0x10
    8c5e:	39 89       	ldd	r19, Y+17	; 0x11
    8c60:	4a 89       	ldd	r20, Y+18	; 0x12
    8c62:	5b 89       	ldd	r21, Y+19	; 0x13
    8c64:	8d 81       	ldd	r24, Y+5	; 0x05
    8c66:	9e 81       	ldd	r25, Y+6	; 0x06
    8c68:	af 81       	ldd	r26, Y+7	; 0x07
    8c6a:	b8 85       	ldd	r27, Y+8	; 0x08
    8c6c:	82 0f       	add	r24, r18
    8c6e:	93 1f       	adc	r25, r19
    8c70:	a4 1f       	adc	r26, r20
    8c72:	b5 1f       	adc	r27, r21
    8c74:	80 93 c1 50 	sts	0x50C1, r24
    8c78:	90 93 c2 50 	sts	0x50C2, r25
    8c7c:	a0 93 c3 50 	sts	0x50C3, r26
    8c80:	b0 93 c4 50 	sts	0x50C4, r27
				appendFileLocation = i;
    8c84:	8d 85       	ldd	r24, Y+13	; 0x0d
    8c86:	9e 85       	ldd	r25, Y+14	; 0x0e
    8c88:	cc 01       	movw	r24, r24
    8c8a:	a0 e0       	ldi	r26, 0x00	; 0
    8c8c:	b0 e0       	ldi	r27, 0x00	; 0
    8c8e:	80 93 cf 23 	sts	0x23CF, r24
    8c92:	90 93 d0 23 	sts	0x23D0, r25
    8c96:	a0 93 d1 23 	sts	0x23D1, r26
    8c9a:	b0 93 d2 23 	sts	0x23D2, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8c9e:	8c 89       	ldd	r24, Y+20	; 0x14
    8ca0:	9d 89       	ldd	r25, Y+21	; 0x15
    8ca2:	fc 01       	movw	r30, r24
    8ca4:	84 89       	ldd	r24, Z+20	; 0x14
    8ca6:	95 89       	ldd	r25, Z+21	; 0x15
    8ca8:	cc 01       	movw	r24, r24
    8caa:	a0 e0       	ldi	r26, 0x00	; 0
    8cac:	b0 e0       	ldi	r27, 0x00	; 0
    8cae:	ac 01       	movw	r20, r24
    8cb0:	33 27       	eor	r19, r19
    8cb2:	22 27       	eor	r18, r18
    8cb4:	8c 89       	ldd	r24, Y+20	; 0x14
    8cb6:	9d 89       	ldd	r25, Y+21	; 0x15
    8cb8:	fc 01       	movw	r30, r24
    8cba:	82 8d       	ldd	r24, Z+26	; 0x1a
    8cbc:	93 8d       	ldd	r25, Z+27	; 0x1b
    8cbe:	cc 01       	movw	r24, r24
    8cc0:	a0 e0       	ldi	r26, 0x00	; 0
    8cc2:	b0 e0       	ldi	r27, 0x00	; 0
    8cc4:	82 2b       	or	r24, r18
    8cc6:	93 2b       	or	r25, r19
    8cc8:	a4 2b       	or	r26, r20
    8cca:	b5 2b       	or	r27, r21
    8ccc:	80 93 7f 50 	sts	0x507F, r24
    8cd0:	90 93 80 50 	sts	0x5080, r25
    8cd4:	a0 93 81 50 	sts	0x5081, r26
    8cd8:	b0 93 82 50 	sts	0x5082, r27
				fileSize = dir->fileSize;
    8cdc:	8c 89       	ldd	r24, Y+20	; 0x14
    8cde:	9d 89       	ldd	r25, Y+21	; 0x15
    8ce0:	fc 01       	movw	r30, r24
    8ce2:	84 8d       	ldd	r24, Z+28	; 0x1c
    8ce4:	95 8d       	ldd	r25, Z+29	; 0x1d
    8ce6:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8ce8:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8cea:	80 93 48 40 	sts	0x4048, r24
    8cee:	90 93 49 40 	sts	0x4049, r25
    8cf2:	a0 93 4a 40 	sts	0x404A, r26
    8cf6:	b0 93 4b 40 	sts	0x404B, r27
			    return (dir);
    8cfa:	8c 89       	ldd	r24, Y+20	; 0x14
    8cfc:	9d 89       	ldd	r25, Y+21	; 0x15
    8cfe:	f3 c0       	rjmp	.+486    	; 0x8ee6 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8d00:	8c 89       	ldd	r24, Y+20	; 0x14
    8d02:	9d 89       	ldd	r25, Y+21	; 0x15
    8d04:	fc 01       	movw	r30, r24
    8d06:	84 89       	ldd	r24, Z+20	; 0x14
    8d08:	95 89       	ldd	r25, Z+21	; 0x15
    8d0a:	cc 01       	movw	r24, r24
    8d0c:	a0 e0       	ldi	r26, 0x00	; 0
    8d0e:	b0 e0       	ldi	r27, 0x00	; 0
    8d10:	ac 01       	movw	r20, r24
    8d12:	33 27       	eor	r19, r19
    8d14:	22 27       	eor	r18, r18
    8d16:	8c 89       	ldd	r24, Y+20	; 0x14
    8d18:	9d 89       	ldd	r25, Y+21	; 0x15
    8d1a:	fc 01       	movw	r30, r24
    8d1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    8d1e:	93 8d       	ldd	r25, Z+27	; 0x1b
    8d20:	cc 01       	movw	r24, r24
    8d22:	a0 e0       	ldi	r26, 0x00	; 0
    8d24:	b0 e0       	ldi	r27, 0x00	; 0
    8d26:	82 2b       	or	r24, r18
    8d28:	93 2b       	or	r25, r19
    8d2a:	a4 2b       	or	r26, r20
    8d2c:	b5 2b       	or	r27, r21
    8d2e:	89 87       	std	Y+9, r24	; 0x09
    8d30:	9a 87       	std	Y+10, r25	; 0x0a
    8d32:	ab 87       	std	Y+11, r26	; 0x0b
    8d34:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8d36:	8c 89       	ldd	r24, Y+20	; 0x14
    8d38:	9d 89       	ldd	r25, Y+21	; 0x15
    8d3a:	25 ee       	ldi	r18, 0xE5	; 229
    8d3c:	fc 01       	movw	r30, r24
    8d3e:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8d40:	28 89       	ldd	r18, Y+16	; 0x10
    8d42:	39 89       	ldd	r19, Y+17	; 0x11
    8d44:	4a 89       	ldd	r20, Y+18	; 0x12
    8d46:	5b 89       	ldd	r21, Y+19	; 0x13
    8d48:	8d 81       	ldd	r24, Y+5	; 0x05
    8d4a:	9e 81       	ldd	r25, Y+6	; 0x06
    8d4c:	af 81       	ldd	r26, Y+7	; 0x07
    8d4e:	b8 85       	ldd	r27, Y+8	; 0x08
    8d50:	82 0f       	add	r24, r18
    8d52:	93 1f       	adc	r25, r19
    8d54:	a4 1f       	adc	r26, r20
    8d56:	b5 1f       	adc	r27, r21
    8d58:	2e ec       	ldi	r18, 0xCE	; 206
    8d5a:	31 e2       	ldi	r19, 0x21	; 33
    8d5c:	bc 01       	movw	r22, r24
    8d5e:	cd 01       	movw	r24, r26
    8d60:	a9 01       	movw	r20, r18
    8d62:	20 e0       	ldi	r18, 0x00	; 0
    8d64:	32 e0       	ldi	r19, 0x02	; 2
    8d66:	0e 94 5c 51 	call	0xa2b8	; 0xa2b8 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8d6a:	8c 89       	ldd	r24, Y+20	; 0x14
    8d6c:	9d 89       	ldd	r25, Y+21	; 0x15
    8d6e:	fc 01       	movw	r30, r24
    8d70:	24 8d       	ldd	r18, Z+28	; 0x1c
    8d72:	35 8d       	ldd	r19, Z+29	; 0x1d
    8d74:	46 8d       	ldd	r20, Z+30	; 0x1e
    8d76:	57 8d       	ldd	r21, Z+31	; 0x1f
    8d78:	80 e0       	ldi	r24, 0x00	; 0
    8d7a:	ba 01       	movw	r22, r20
    8d7c:	a9 01       	movw	r20, r18
    8d7e:	0e 94 fd 4d 	call	0x9bfa	; 0x9bfa <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8d82:	82 e0       	ldi	r24, 0x02	; 2
    8d84:	60 e0       	ldi	r22, 0x00	; 0
    8d86:	20 e0       	ldi	r18, 0x00	; 0
    8d88:	30 e0       	ldi	r19, 0x00	; 0
    8d8a:	a9 01       	movw	r20, r18
    8d8c:	0e 94 f0 44 	call	0x89e0	; 0x89e0 <getSetFreeCluster>
    8d90:	dc 01       	movw	r26, r24
    8d92:	cb 01       	movw	r24, r22
    8d94:	89 83       	std	Y+1, r24	; 0x01
    8d96:	9a 83       	std	Y+2, r25	; 0x02
    8d98:	ab 83       	std	Y+3, r26	; 0x03
    8d9a:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8d9c:	29 85       	ldd	r18, Y+9	; 0x09
    8d9e:	3a 85       	ldd	r19, Y+10	; 0x0a
    8da0:	4b 85       	ldd	r20, Y+11	; 0x0b
    8da2:	5c 85       	ldd	r21, Y+12	; 0x0c
    8da4:	89 81       	ldd	r24, Y+1	; 0x01
    8da6:	9a 81       	ldd	r25, Y+2	; 0x02
    8da8:	ab 81       	ldd	r26, Y+3	; 0x03
    8daa:	bc 81       	ldd	r27, Y+4	; 0x04
    8dac:	28 17       	cp	r18, r24
    8dae:	39 07       	cpc	r19, r25
    8db0:	4a 07       	cpc	r20, r26
    8db2:	5b 07       	cpc	r21, r27
    8db4:	40 f4       	brcc	.+16     	; 0x8dc6 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    8db6:	29 85       	ldd	r18, Y+9	; 0x09
    8db8:	3a 85       	ldd	r19, Y+10	; 0x0a
    8dba:	4b 85       	ldd	r20, Y+11	; 0x0b
    8dbc:	5c 85       	ldd	r21, Y+12	; 0x0c
    8dbe:	82 e0       	ldi	r24, 0x02	; 2
    8dc0:	61 e0       	ldi	r22, 0x01	; 1
    8dc2:	0e 94 f0 44 	call	0x89e0	; 0x89e0 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    8dc6:	89 85       	ldd	r24, Y+9	; 0x09
    8dc8:	9a 85       	ldd	r25, Y+10	; 0x0a
    8dca:	ab 85       	ldd	r26, Y+11	; 0x0b
    8dcc:	bc 85       	ldd	r27, Y+12	; 0x0c
    8dce:	bc 01       	movw	r22, r24
    8dd0:	cd 01       	movw	r24, r26
    8dd2:	40 e0       	ldi	r20, 0x00	; 0
    8dd4:	00 e0       	ldi	r16, 0x00	; 0
    8dd6:	10 e0       	ldi	r17, 0x00	; 0
    8dd8:	98 01       	movw	r18, r16
    8dda:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
    8dde:	dc 01       	movw	r26, r24
    8de0:	cb 01       	movw	r24, r22
    8de2:	8e 8b       	std	Y+22, r24	; 0x16
    8de4:	9f 8b       	std	Y+23, r25	; 0x17
    8de6:	a8 8f       	std	Y+24, r26	; 0x18
    8de8:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8dea:	89 85       	ldd	r24, Y+9	; 0x09
    8dec:	9a 85       	ldd	r25, Y+10	; 0x0a
    8dee:	ab 85       	ldd	r26, Y+11	; 0x0b
    8df0:	bc 85       	ldd	r27, Y+12	; 0x0c
    8df2:	bc 01       	movw	r22, r24
    8df4:	cd 01       	movw	r24, r26
    8df6:	41 e0       	ldi	r20, 0x01	; 1
    8df8:	00 e0       	ldi	r16, 0x00	; 0
    8dfa:	10 e0       	ldi	r17, 0x00	; 0
    8dfc:	98 01       	movw	r18, r16
    8dfe:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8e02:	8e 89       	ldd	r24, Y+22	; 0x16
    8e04:	9f 89       	ldd	r25, Y+23	; 0x17
    8e06:	a8 8d       	ldd	r26, Y+24	; 0x18
    8e08:	b9 8d       	ldd	r27, Y+25	; 0x19
    8e0a:	87 3f       	cpi	r24, 0xF7	; 247
    8e0c:	ff ef       	ldi	r31, 0xFF	; 255
    8e0e:	9f 07       	cpc	r25, r31
    8e10:	ff ef       	ldi	r31, 0xFF	; 255
    8e12:	af 07       	cpc	r26, r31
    8e14:	ff e0       	ldi	r31, 0x0F	; 15
    8e16:	bf 07       	cpc	r27, r31
    8e18:	18 f0       	brcs	.+6      	; 0x8e20 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    8e1a:	80 e0       	ldi	r24, 0x00	; 0
    8e1c:	90 e0       	ldi	r25, 0x00	; 0
    8e1e:	63 c0       	rjmp	.+198    	; 0x8ee6 <findFiles+0x3a4>
					firstCluster = nextCluster;
    8e20:	8e 89       	ldd	r24, Y+22	; 0x16
    8e22:	9f 89       	ldd	r25, Y+23	; 0x17
    8e24:	a8 8d       	ldd	r26, Y+24	; 0x18
    8e26:	b9 8d       	ldd	r27, Y+25	; 0x19
    8e28:	89 87       	std	Y+9, r24	; 0x09
    8e2a:	9a 87       	std	Y+10, r25	; 0x0a
    8e2c:	ab 87       	std	Y+11, r26	; 0x0b
    8e2e:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8e30:	ca cf       	rjmp	.-108    	; 0x8dc6 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8e32:	80 e0       	ldi	r24, 0x00	; 0
    8e34:	90 e0       	ldi	r25, 0x00	; 0
    8e36:	57 c0       	rjmp	.+174    	; 0x8ee6 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8e38:	8d 85       	ldd	r24, Y+13	; 0x0d
    8e3a:	9e 85       	ldd	r25, Y+14	; 0x0e
    8e3c:	80 96       	adiw	r24, 0x20	; 32
    8e3e:	8d 87       	std	Y+13, r24	; 0x0d
    8e40:	9e 87       	std	Y+14, r25	; 0x0e
    8e42:	80 91 4c 40 	lds	r24, 0x404C
    8e46:	90 91 4d 40 	lds	r25, 0x404D
    8e4a:	2d 85       	ldd	r18, Y+13	; 0x0d
    8e4c:	3e 85       	ldd	r19, Y+14	; 0x0e
    8e4e:	28 17       	cp	r18, r24
    8e50:	39 07       	cpc	r19, r25
    8e52:	08 f4       	brcc	.+2      	; 0x8e56 <findFiles+0x314>
    8e54:	b9 ce       	rjmp	.-654    	; 0x8bc8 <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8e56:	8d 81       	ldd	r24, Y+5	; 0x05
    8e58:	9e 81       	ldd	r25, Y+6	; 0x06
    8e5a:	af 81       	ldd	r26, Y+7	; 0x07
    8e5c:	b8 85       	ldd	r27, Y+8	; 0x08
    8e5e:	01 96       	adiw	r24, 0x01	; 1
    8e60:	a1 1d       	adc	r26, r1
    8e62:	b1 1d       	adc	r27, r1
    8e64:	8d 83       	std	Y+5, r24	; 0x05
    8e66:	9e 83       	std	Y+6, r25	; 0x06
    8e68:	af 83       	std	Y+7, r26	; 0x07
    8e6a:	b8 87       	std	Y+8, r27	; 0x08
    8e6c:	80 91 73 50 	lds	r24, 0x5073
    8e70:	90 91 74 50 	lds	r25, 0x5074
    8e74:	9c 01       	movw	r18, r24
    8e76:	40 e0       	ldi	r20, 0x00	; 0
    8e78:	50 e0       	ldi	r21, 0x00	; 0
    8e7a:	8d 81       	ldd	r24, Y+5	; 0x05
    8e7c:	9e 81       	ldd	r25, Y+6	; 0x06
    8e7e:	af 81       	ldd	r26, Y+7	; 0x07
    8e80:	b8 85       	ldd	r27, Y+8	; 0x08
    8e82:	82 17       	cp	r24, r18
    8e84:	93 07       	cpc	r25, r19
    8e86:	a4 07       	cpc	r26, r20
    8e88:	b5 07       	cpc	r27, r21
    8e8a:	08 f4       	brcc	.+2      	; 0x8e8e <findFiles+0x34c>
    8e8c:	87 ce       	rjmp	.-754    	; 0x8b9c <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8e8e:	89 81       	ldd	r24, Y+1	; 0x01
    8e90:	9a 81       	ldd	r25, Y+2	; 0x02
    8e92:	ab 81       	ldd	r26, Y+3	; 0x03
    8e94:	bc 81       	ldd	r27, Y+4	; 0x04
    8e96:	bc 01       	movw	r22, r24
    8e98:	cd 01       	movw	r24, r26
    8e9a:	40 e0       	ldi	r20, 0x00	; 0
    8e9c:	00 e0       	ldi	r16, 0x00	; 0
    8e9e:	10 e0       	ldi	r17, 0x00	; 0
    8ea0:	98 01       	movw	r18, r16
    8ea2:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
    8ea6:	dc 01       	movw	r26, r24
    8ea8:	cb 01       	movw	r24, r22
    8eaa:	89 83       	std	Y+1, r24	; 0x01
    8eac:	9a 83       	std	Y+2, r25	; 0x02
    8eae:	ab 83       	std	Y+3, r26	; 0x03
    8eb0:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8eb2:	89 81       	ldd	r24, Y+1	; 0x01
    8eb4:	9a 81       	ldd	r25, Y+2	; 0x02
    8eb6:	ab 81       	ldd	r26, Y+3	; 0x03
    8eb8:	bc 81       	ldd	r27, Y+4	; 0x04
    8eba:	87 3f       	cpi	r24, 0xF7	; 247
    8ebc:	2f ef       	ldi	r18, 0xFF	; 255
    8ebe:	92 07       	cpc	r25, r18
    8ec0:	2f ef       	ldi	r18, 0xFF	; 255
    8ec2:	a2 07       	cpc	r26, r18
    8ec4:	2f e0       	ldi	r18, 0x0F	; 15
    8ec6:	b2 07       	cpc	r27, r18
    8ec8:	18 f0       	brcs	.+6      	; 0x8ed0 <findFiles+0x38e>
   	 return 0;
    8eca:	80 e0       	ldi	r24, 0x00	; 0
    8ecc:	90 e0       	ldi	r25, 0x00	; 0
    8ece:	0b c0       	rjmp	.+22     	; 0x8ee6 <findFiles+0x3a4>
   if(cluster == 0) 
    8ed0:	89 81       	ldd	r24, Y+1	; 0x01
    8ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    8ed4:	ab 81       	ldd	r26, Y+3	; 0x03
    8ed6:	bc 81       	ldd	r27, Y+4	; 0x04
    8ed8:	00 97       	sbiw	r24, 0x00	; 0
    8eda:	a1 05       	cpc	r26, r1
    8edc:	b1 05       	cpc	r27, r1
    8ede:	09 f0       	breq	.+2      	; 0x8ee2 <findFiles+0x3a0>
    8ee0:	49 ce       	rjmp	.-878    	; 0x8b74 <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8ee2:	80 e0       	ldi	r24, 0x00	; 0
    8ee4:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    8ee6:	6c 96       	adiw	r28, 0x1c	; 28
    8ee8:	cd bf       	out	0x3d, r28	; 61
    8eea:	de bf       	out	0x3e, r29	; 62
    8eec:	df 91       	pop	r29
    8eee:	cf 91       	pop	r28
    8ef0:	1f 91       	pop	r17
    8ef2:	0f 91       	pop	r16
    8ef4:	08 95       	ret

00008ef6 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    8ef6:	0f 93       	push	r16
    8ef8:	1f 93       	push	r17
    8efa:	cf 93       	push	r28
    8efc:	df 93       	push	r29
    8efe:	cd b7       	in	r28, 0x3d	; 61
    8f00:	de b7       	in	r29, 0x3e	; 62
    8f02:	2f 97       	sbiw	r28, 0x0f	; 15
    8f04:	cd bf       	out	0x3d, r28	; 61
    8f06:	de bf       	out	0x3e, r29	; 62
    8f08:	8d 87       	std	Y+13, r24	; 0x0d
    8f0a:	6e 87       	std	Y+14, r22	; 0x0e
    8f0c:	7f 87       	std	Y+15, r23	; 0x0f
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8f0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    8f10:	9f 85       	ldd	r25, Y+15	; 0x0f
    8f12:	0e 94 1b 48 	call	0x9036	; 0x9036 <convertFileName>
    8f16:	8e 83       	std	Y+6, r24	; 0x06
if(error) return 2;
    8f18:	8e 81       	ldd	r24, Y+6	; 0x06
    8f1a:	88 23       	and	r24, r24
    8f1c:	11 f0       	breq	.+4      	; 0x8f22 <readFile+0x2c>
    8f1e:	82 e0       	ldi	r24, 0x02	; 2
    8f20:	82 c0       	rjmp	.+260    	; 0x9026 <readFile+0x130>

dir = findFiles (GET_FILE, Filename); //get the file location
    8f22:	2b ea       	ldi	r18, 0xAB	; 171
    8f24:	30 e5       	ldi	r19, 0x50	; 80
    8f26:	81 e0       	ldi	r24, 0x01	; 1
    8f28:	b9 01       	movw	r22, r18
    8f2a:	0e 94 a1 45 	call	0x8b42	; 0x8b42 <findFiles>
    8f2e:	8f 83       	std	Y+7, r24	; 0x07
    8f30:	98 87       	std	Y+8, r25	; 0x08
if(dir == 0) 
    8f32:	8f 81       	ldd	r24, Y+7	; 0x07
    8f34:	98 85       	ldd	r25, Y+8	; 0x08
    8f36:	00 97       	sbiw	r24, 0x00	; 0
    8f38:	39 f4       	brne	.+14     	; 0x8f48 <readFile+0x52>
{
  if(flag == READ) return (1);
    8f3a:	8d 85       	ldd	r24, Y+13	; 0x0d
    8f3c:	88 23       	and	r24, r24
    8f3e:	11 f4       	brne	.+4      	; 0x8f44 <readFile+0x4e>
    8f40:	81 e0       	ldi	r24, 0x01	; 1
    8f42:	71 c0       	rjmp	.+226    	; 0x9026 <readFile+0x130>
  else return (0);
    8f44:	80 e0       	ldi	r24, 0x00	; 0
    8f46:	6f c0       	rjmp	.+222    	; 0x9026 <readFile+0x130>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8f48:	8d 85       	ldd	r24, Y+13	; 0x0d
    8f4a:	81 30       	cpi	r24, 0x01	; 1
    8f4c:	11 f4       	brne	.+4      	; 0x8f52 <readFile+0x5c>
    8f4e:	81 e0       	ldi	r24, 0x01	; 1
    8f50:	6a c0       	rjmp	.+212    	; 0x9026 <readFile+0x130>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8f52:	8f 81       	ldd	r24, Y+7	; 0x07
    8f54:	98 85       	ldd	r25, Y+8	; 0x08
    8f56:	fc 01       	movw	r30, r24
    8f58:	84 89       	ldd	r24, Z+20	; 0x14
    8f5a:	95 89       	ldd	r25, Z+21	; 0x15
    8f5c:	cc 01       	movw	r24, r24
    8f5e:	a0 e0       	ldi	r26, 0x00	; 0
    8f60:	b0 e0       	ldi	r27, 0x00	; 0
    8f62:	ac 01       	movw	r20, r24
    8f64:	33 27       	eor	r19, r19
    8f66:	22 27       	eor	r18, r18
    8f68:	8f 81       	ldd	r24, Y+7	; 0x07
    8f6a:	98 85       	ldd	r25, Y+8	; 0x08
    8f6c:	fc 01       	movw	r30, r24
    8f6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    8f70:	93 8d       	ldd	r25, Z+27	; 0x1b
    8f72:	cc 01       	movw	r24, r24
    8f74:	a0 e0       	ldi	r26, 0x00	; 0
    8f76:	b0 e0       	ldi	r27, 0x00	; 0
    8f78:	82 2b       	or	r24, r18
    8f7a:	93 2b       	or	r25, r19
    8f7c:	a4 2b       	or	r26, r20
    8f7e:	b5 2b       	or	r27, r21
    8f80:	89 83       	std	Y+1, r24	; 0x01
    8f82:	9a 83       	std	Y+2, r25	; 0x02
    8f84:	ab 83       	std	Y+3, r26	; 0x03
    8f86:	bc 83       	std	Y+4, r27	; 0x04
    8f88:	01 c0       	rjmp	.+2      	; 0x8f8c <readFile+0x96>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8f8a:	00 00       	nop
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8f8c:	89 81       	ldd	r24, Y+1	; 0x01
    8f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    8f90:	ab 81       	ldd	r26, Y+3	; 0x03
    8f92:	bc 81       	ldd	r27, Y+4	; 0x04
    8f94:	bc 01       	movw	r22, r24
    8f96:	cd 01       	movw	r24, r26
    8f98:	0e 94 15 44 	call	0x882a	; 0x882a <getFirstSector>
    8f9c:	dc 01       	movw	r26, r24
    8f9e:	cb 01       	movw	r24, r22
    8fa0:	89 87       	std	Y+9, r24	; 0x09
    8fa2:	9a 87       	std	Y+10, r25	; 0x0a
    8fa4:	ab 87       	std	Y+11, r26	; 0x0b
    8fa6:	bc 87       	std	Y+12, r27	; 0x0c

  for(j=0; j<sectorPerCluster; j++)
    8fa8:	1d 82       	std	Y+5, r1	; 0x05
    8faa:	17 c0       	rjmp	.+46     	; 0x8fda <readFile+0xe4>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8fac:	8d 81       	ldd	r24, Y+5	; 0x05
    8fae:	28 2f       	mov	r18, r24
    8fb0:	30 e0       	ldi	r19, 0x00	; 0
    8fb2:	40 e0       	ldi	r20, 0x00	; 0
    8fb4:	50 e0       	ldi	r21, 0x00	; 0
    8fb6:	89 85       	ldd	r24, Y+9	; 0x09
    8fb8:	9a 85       	ldd	r25, Y+10	; 0x0a
    8fba:	ab 85       	ldd	r26, Y+11	; 0x0b
    8fbc:	bc 85       	ldd	r27, Y+12	; 0x0c
    8fbe:	82 0f       	add	r24, r18
    8fc0:	93 1f       	adc	r25, r19
    8fc2:	a4 1f       	adc	r26, r20
    8fc4:	b5 1f       	adc	r27, r21
    8fc6:	27 ed       	ldi	r18, 0xD7	; 215
    8fc8:	33 e2       	ldi	r19, 0x23	; 35
    8fca:	bc 01       	movw	r22, r24
    8fcc:	cd 01       	movw	r24, r26
    8fce:	a9 01       	movw	r20, r18
    8fd0:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8fd4:	8d 81       	ldd	r24, Y+5	; 0x05
    8fd6:	8f 5f       	subi	r24, 0xFF	; 255
    8fd8:	8d 83       	std	Y+5, r24	; 0x05
    8fda:	8d 81       	ldd	r24, Y+5	; 0x05
    8fdc:	28 2f       	mov	r18, r24
    8fde:	30 e0       	ldi	r19, 0x00	; 0
    8fe0:	80 91 73 50 	lds	r24, 0x5073
    8fe4:	90 91 74 50 	lds	r25, 0x5074
    8fe8:	28 17       	cp	r18, r24
    8fea:	39 07       	cpc	r19, r25
    8fec:	f8 f2       	brcs	.-66     	; 0x8fac <readFile+0xb6>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8fee:	89 81       	ldd	r24, Y+1	; 0x01
    8ff0:	9a 81       	ldd	r25, Y+2	; 0x02
    8ff2:	ab 81       	ldd	r26, Y+3	; 0x03
    8ff4:	bc 81       	ldd	r27, Y+4	; 0x04
    8ff6:	bc 01       	movw	r22, r24
    8ff8:	cd 01       	movw	r24, r26
    8ffa:	40 e0       	ldi	r20, 0x00	; 0
    8ffc:	00 e0       	ldi	r16, 0x00	; 0
    8ffe:	10 e0       	ldi	r17, 0x00	; 0
    9000:	98 01       	movw	r18, r16
    9002:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
    9006:	dc 01       	movw	r26, r24
    9008:	cb 01       	movw	r24, r22
    900a:	89 83       	std	Y+1, r24	; 0x01
    900c:	9a 83       	std	Y+2, r25	; 0x02
    900e:	ab 83       	std	Y+3, r26	; 0x03
    9010:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    9012:	89 81       	ldd	r24, Y+1	; 0x01
    9014:	9a 81       	ldd	r25, Y+2	; 0x02
    9016:	ab 81       	ldd	r26, Y+3	; 0x03
    9018:	bc 81       	ldd	r27, Y+4	; 0x04
    901a:	00 97       	sbiw	r24, 0x00	; 0
    901c:	a1 05       	cpc	r26, r1
    901e:	b1 05       	cpc	r27, r1
    9020:	09 f0       	breq	.+2      	; 0x9024 <readFile+0x12e>
    9022:	b3 cf       	rjmp	.-154    	; 0x8f8a <readFile+0x94>
	  return 0;}
    9024:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    9026:	2f 96       	adiw	r28, 0x0f	; 15
    9028:	cd bf       	out	0x3d, r28	; 61
    902a:	de bf       	out	0x3e, r29	; 62
    902c:	df 91       	pop	r29
    902e:	cf 91       	pop	r28
    9030:	1f 91       	pop	r17
    9032:	0f 91       	pop	r16
    9034:	08 95       	ret

00009036 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    9036:	cf 93       	push	r28
    9038:	df 93       	push	r29
    903a:	cd b7       	in	r28, 0x3d	; 61
    903c:	de b7       	in	r29, 0x3e	; 62
    903e:	62 97       	sbiw	r28, 0x12	; 18
    9040:	cd bf       	out	0x3d, r28	; 61
    9042:	de bf       	out	0x3e, r29	; 62
    9044:	89 8b       	std	Y+17, r24	; 0x11
    9046:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    9048:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    904a:	89 89       	ldd	r24, Y+17	; 0x11
    904c:	9a 89       	ldd	r25, Y+18	; 0x12
    904e:	9c 01       	movw	r18, r24
    9050:	f9 01       	movw	r30, r18
    9052:	01 90       	ld	r0, Z+
    9054:	00 20       	and	r0, r0
    9056:	e9 f7       	brne	.-6      	; 0x9052 <convertFileName+0x1c>
    9058:	cf 01       	movw	r24, r30
    905a:	01 97       	sbiw	r24, 0x01	; 1
    905c:	82 1b       	sub	r24, r18
    905e:	93 0b       	sbc	r25, r19
    9060:	80 31       	cpi	r24, 0x10	; 16
    9062:	91 05       	cpc	r25, r1
    9064:	10 f0       	brcs	.+4      	; 0x906a <convertFileName+0x34>
    9066:	81 e0       	ldi	r24, 0x01	; 1
    9068:	16 c1       	rjmp	.+556    	; 0x9296 <convertFileName+0x260>
int i=0;
    906a:	1c 82       	std	Y+4, r1	; 0x04
    906c:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen((const char*)fileName); i++){
    906e:	13 c0       	rjmp	.+38     	; 0x9096 <convertFileName+0x60>
	Filename[i] = fileName[i];
    9070:	8c 81       	ldd	r24, Y+4	; 0x04
    9072:	9d 81       	ldd	r25, Y+5	; 0x05
    9074:	29 89       	ldd	r18, Y+17	; 0x11
    9076:	3a 89       	ldd	r19, Y+18	; 0x12
    9078:	82 0f       	add	r24, r18
    907a:	93 1f       	adc	r25, r19
    907c:	fc 01       	movw	r30, r24
    907e:	20 81       	ld	r18, Z
    9080:	8c 81       	ldd	r24, Y+4	; 0x04
    9082:	9d 81       	ldd	r25, Y+5	; 0x05
    9084:	85 55       	subi	r24, 0x55	; 85
    9086:	9f 4a       	sbci	r25, 0xAF	; 175
    9088:	fc 01       	movw	r30, r24
    908a:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    908c:	8c 81       	ldd	r24, Y+4	; 0x04
    908e:	9d 81       	ldd	r25, Y+5	; 0x05
    9090:	01 96       	adiw	r24, 0x01	; 1
    9092:	8c 83       	std	Y+4, r24	; 0x04
    9094:	9d 83       	std	Y+5, r25	; 0x05
    9096:	4c 81       	ldd	r20, Y+4	; 0x04
    9098:	5d 81       	ldd	r21, Y+5	; 0x05
    909a:	89 89       	ldd	r24, Y+17	; 0x11
    909c:	9a 89       	ldd	r25, Y+18	; 0x12
    909e:	9c 01       	movw	r18, r24
    90a0:	f9 01       	movw	r30, r18
    90a2:	01 90       	ld	r0, Z+
    90a4:	00 20       	and	r0, r0
    90a6:	e9 f7       	brne	.-6      	; 0x90a2 <convertFileName+0x6c>
    90a8:	cf 01       	movw	r24, r30
    90aa:	01 97       	sbiw	r24, 0x01	; 1
    90ac:	82 1b       	sub	r24, r18
    90ae:	93 0b       	sbc	r25, r19
    90b0:	48 17       	cp	r20, r24
    90b2:	59 07       	cpc	r21, r25
    90b4:	e8 f2       	brcs	.-70     	; 0x9070 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    90b6:	0c c0       	rjmp	.+24     	; 0x90d0 <convertFileName+0x9a>
    90b8:	8c 81       	ldd	r24, Y+4	; 0x04
    90ba:	9d 81       	ldd	r25, Y+5	; 0x05
    90bc:	85 55       	subi	r24, 0x55	; 85
    90be:	9f 4a       	sbci	r25, 0xAF	; 175
    90c0:	20 e2       	ldi	r18, 0x20	; 32
    90c2:	fc 01       	movw	r30, r24
    90c4:	20 83       	st	Z, r18
    90c6:	8c 81       	ldd	r24, Y+4	; 0x04
    90c8:	9d 81       	ldd	r25, Y+5	; 0x05
    90ca:	01 96       	adiw	r24, 0x01	; 1
    90cc:	8c 83       	std	Y+4, r24	; 0x04
    90ce:	9d 83       	std	Y+5, r25	; 0x05
    90d0:	8c 81       	ldd	r24, Y+4	; 0x04
    90d2:	9d 81       	ldd	r25, Y+5	; 0x05
    90d4:	8f 30       	cpi	r24, 0x0F	; 15
    90d6:	91 05       	cpc	r25, r1
    90d8:	7c f3       	brlt	.-34     	; 0x90b8 <convertFileName+0x82>


for(j=0; j<12; j++)
    90da:	1a 82       	std	Y+2, r1	; 0x02
    90dc:	0c c0       	rjmp	.+24     	; 0x90f6 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    90de:	8a 81       	ldd	r24, Y+2	; 0x02
    90e0:	88 2f       	mov	r24, r24
    90e2:	90 e0       	ldi	r25, 0x00	; 0
    90e4:	85 55       	subi	r24, 0x55	; 85
    90e6:	9f 4a       	sbci	r25, 0xAF	; 175
    90e8:	fc 01       	movw	r30, r24
    90ea:	80 81       	ld	r24, Z
    90ec:	8e 32       	cpi	r24, 0x2E	; 46
    90ee:	39 f0       	breq	.+14     	; 0x90fe <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    90f0:	8a 81       	ldd	r24, Y+2	; 0x02
    90f2:	8f 5f       	subi	r24, 0xFF	; 255
    90f4:	8a 83       	std	Y+2, r24	; 0x02
    90f6:	8a 81       	ldd	r24, Y+2	; 0x02
    90f8:	8c 30       	cpi	r24, 0x0C	; 12
    90fa:	88 f3       	brcs	.-30     	; 0x90de <convertFileName+0xa8>
    90fc:	01 c0       	rjmp	.+2      	; 0x9100 <convertFileName+0xca>
if(Filename[j] == '.') break;
    90fe:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    9100:	8a 81       	ldd	r24, Y+2	; 0x02
    9102:	89 30       	cpi	r24, 0x09	; 9
    9104:	28 f0       	brcs	.+10     	; 0x9110 <convertFileName+0xda>
    9106:	8a 81       	ldd	r24, Y+2	; 0x02
    9108:	8c 30       	cpi	r24, 0x0C	; 12
    910a:	10 f4       	brcc	.+4      	; 0x9110 <convertFileName+0xda>
	return 1;}
    910c:	81 e0       	ldi	r24, 0x01	; 1
    910e:	c3 c0       	rjmp	.+390    	; 0x9296 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    9110:	8a 81       	ldd	r24, Y+2	; 0x02
    9112:	8c 30       	cpi	r24, 0x0C	; 12
    9114:	11 f4       	brne	.+4      	; 0x911a <convertFileName+0xe4>
    9116:	81 e0       	ldi	r24, 0x01	; 1
    9118:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    911a:	1b 82       	std	Y+3, r1	; 0x03
    911c:	14 c0       	rjmp	.+40     	; 0x9146 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    911e:	8b 81       	ldd	r24, Y+3	; 0x03
    9120:	88 2f       	mov	r24, r24
    9122:	90 e0       	ldi	r25, 0x00	; 0
    9124:	2b 81       	ldd	r18, Y+3	; 0x03
    9126:	22 2f       	mov	r18, r18
    9128:	30 e0       	ldi	r19, 0x00	; 0
    912a:	25 55       	subi	r18, 0x55	; 85
    912c:	3f 4a       	sbci	r19, 0xAF	; 175
    912e:	f9 01       	movw	r30, r18
    9130:	40 81       	ld	r20, Z
    9132:	9e 01       	movw	r18, r28
    9134:	2a 5f       	subi	r18, 0xFA	; 250
    9136:	3f 4f       	sbci	r19, 0xFF	; 255
    9138:	82 0f       	add	r24, r18
    913a:	93 1f       	adc	r25, r19
    913c:	fc 01       	movw	r30, r24
    913e:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    9140:	8b 81       	ldd	r24, Y+3	; 0x03
    9142:	8f 5f       	subi	r24, 0xFF	; 255
    9144:	8b 83       	std	Y+3, r24	; 0x03
    9146:	9b 81       	ldd	r25, Y+3	; 0x03
    9148:	8a 81       	ldd	r24, Y+2	; 0x02
    914a:	98 17       	cp	r25, r24
    914c:	40 f3       	brcs	.-48     	; 0x911e <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    914e:	8a 81       	ldd	r24, Y+2	; 0x02
    9150:	8b 83       	std	Y+3, r24	; 0x03
    9152:	0e c0       	rjmp	.+28     	; 0x9170 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    9154:	8b 81       	ldd	r24, Y+3	; 0x03
    9156:	88 2f       	mov	r24, r24
    9158:	90 e0       	ldi	r25, 0x00	; 0
    915a:	9e 01       	movw	r18, r28
    915c:	2a 5f       	subi	r18, 0xFA	; 250
    915e:	3f 4f       	sbci	r19, 0xFF	; 255
    9160:	82 0f       	add	r24, r18
    9162:	93 1f       	adc	r25, r19
    9164:	20 e2       	ldi	r18, 0x20	; 32
    9166:	fc 01       	movw	r30, r24
    9168:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    916a:	8b 81       	ldd	r24, Y+3	; 0x03
    916c:	8f 5f       	subi	r24, 0xFF	; 255
    916e:	8b 83       	std	Y+3, r24	; 0x03
    9170:	8b 81       	ldd	r24, Y+3	; 0x03
    9172:	88 30       	cpi	r24, 0x08	; 8
    9174:	78 f3       	brcs	.-34     	; 0x9154 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    9176:	99 81       	ldd	r25, Y+1	; 0x01
    9178:	81 e0       	ldi	r24, 0x01	; 1
    917a:	89 27       	eor	r24, r25
    917c:	88 23       	and	r24, r24
    917e:	19 f0       	breq	.+6      	; 0x9186 <convertFileName+0x150>
    9180:	8a 81       	ldd	r24, Y+2	; 0x02
    9182:	8f 5f       	subi	r24, 0xFF	; 255
    9184:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    9186:	88 e0       	ldi	r24, 0x08	; 8
    9188:	8b 83       	std	Y+3, r24	; 0x03
    918a:	32 c0       	rjmp	.+100    	; 0x91f0 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    918c:	8a 81       	ldd	r24, Y+2	; 0x02
    918e:	88 2f       	mov	r24, r24
    9190:	90 e0       	ldi	r25, 0x00	; 0
    9192:	85 55       	subi	r24, 0x55	; 85
    9194:	9f 4a       	sbci	r25, 0xAF	; 175
    9196:	fc 01       	movw	r30, r24
    9198:	80 81       	ld	r24, Z
    919a:	88 23       	and	r24, r24
    919c:	19 f1       	breq	.+70     	; 0x91e4 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    919e:	8b 81       	ldd	r24, Y+3	; 0x03
    91a0:	88 2f       	mov	r24, r24
    91a2:	90 e0       	ldi	r25, 0x00	; 0
    91a4:	2a 81       	ldd	r18, Y+2	; 0x02
    91a6:	22 2f       	mov	r18, r18
    91a8:	30 e0       	ldi	r19, 0x00	; 0
    91aa:	25 55       	subi	r18, 0x55	; 85
    91ac:	3f 4a       	sbci	r19, 0xAF	; 175
    91ae:	f9 01       	movw	r30, r18
    91b0:	40 81       	ld	r20, Z
    91b2:	9e 01       	movw	r18, r28
    91b4:	2a 5f       	subi	r18, 0xFA	; 250
    91b6:	3f 4f       	sbci	r19, 0xFF	; 255
    91b8:	82 0f       	add	r24, r18
    91ba:	93 1f       	adc	r25, r19
    91bc:	fc 01       	movw	r30, r24
    91be:	40 83       	st	Z, r20
    91c0:	8a 81       	ldd	r24, Y+2	; 0x02
    91c2:	8f 5f       	subi	r24, 0xFF	; 255
    91c4:	8a 83       	std	Y+2, r24	; 0x02
    91c6:	11 c0       	rjmp	.+34     	; 0x91ea <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    91c8:	8b 81       	ldd	r24, Y+3	; 0x03
    91ca:	88 2f       	mov	r24, r24
    91cc:	90 e0       	ldi	r25, 0x00	; 0
    91ce:	9e 01       	movw	r18, r28
    91d0:	2a 5f       	subi	r18, 0xFA	; 250
    91d2:	3f 4f       	sbci	r19, 0xFF	; 255
    91d4:	82 0f       	add	r24, r18
    91d6:	93 1f       	adc	r25, r19
    91d8:	20 e2       	ldi	r18, 0x20	; 32
    91da:	fc 01       	movw	r30, r24
    91dc:	20 83       	st	Z, r18
    91de:	8b 81       	ldd	r24, Y+3	; 0x03
    91e0:	8f 5f       	subi	r24, 0xFF	; 255
    91e2:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    91e4:	8b 81       	ldd	r24, Y+3	; 0x03
    91e6:	8b 30       	cpi	r24, 0x0B	; 11
    91e8:	78 f3       	brcs	.-34     	; 0x91c8 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    91ea:	8b 81       	ldd	r24, Y+3	; 0x03
    91ec:	8f 5f       	subi	r24, 0xFF	; 255
    91ee:	8b 83       	std	Y+3, r24	; 0x03
    91f0:	8b 81       	ldd	r24, Y+3	; 0x03
    91f2:	8b 30       	cpi	r24, 0x0B	; 11
    91f4:	58 f2       	brcs	.-106    	; 0x918c <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    91f6:	1a 82       	std	Y+2, r1	; 0x02
    91f8:	31 c0       	rjmp	.+98     	; 0x925c <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    91fa:	8a 81       	ldd	r24, Y+2	; 0x02
    91fc:	88 2f       	mov	r24, r24
    91fe:	90 e0       	ldi	r25, 0x00	; 0
    9200:	9e 01       	movw	r18, r28
    9202:	2a 5f       	subi	r18, 0xFA	; 250
    9204:	3f 4f       	sbci	r19, 0xFF	; 255
    9206:	82 0f       	add	r24, r18
    9208:	93 1f       	adc	r25, r19
    920a:	fc 01       	movw	r30, r24
    920c:	80 81       	ld	r24, Z
    920e:	81 36       	cpi	r24, 0x61	; 97
    9210:	10 f1       	brcs	.+68     	; 0x9256 <convertFileName+0x220>
    9212:	8a 81       	ldd	r24, Y+2	; 0x02
    9214:	88 2f       	mov	r24, r24
    9216:	90 e0       	ldi	r25, 0x00	; 0
    9218:	9e 01       	movw	r18, r28
    921a:	2a 5f       	subi	r18, 0xFA	; 250
    921c:	3f 4f       	sbci	r19, 0xFF	; 255
    921e:	82 0f       	add	r24, r18
    9220:	93 1f       	adc	r25, r19
    9222:	fc 01       	movw	r30, r24
    9224:	80 81       	ld	r24, Z
    9226:	8b 37       	cpi	r24, 0x7B	; 123
    9228:	b0 f4       	brcc	.+44     	; 0x9256 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    922a:	8a 81       	ldd	r24, Y+2	; 0x02
    922c:	88 2f       	mov	r24, r24
    922e:	90 e0       	ldi	r25, 0x00	; 0
    9230:	2a 81       	ldd	r18, Y+2	; 0x02
    9232:	22 2f       	mov	r18, r18
    9234:	30 e0       	ldi	r19, 0x00	; 0
    9236:	ae 01       	movw	r20, r28
    9238:	4a 5f       	subi	r20, 0xFA	; 250
    923a:	5f 4f       	sbci	r21, 0xFF	; 255
    923c:	24 0f       	add	r18, r20
    923e:	35 1f       	adc	r19, r21
    9240:	f9 01       	movw	r30, r18
    9242:	20 81       	ld	r18, Z
    9244:	42 2f       	mov	r20, r18
    9246:	40 52       	subi	r20, 0x20	; 32
    9248:	9e 01       	movw	r18, r28
    924a:	2a 5f       	subi	r18, 0xFA	; 250
    924c:	3f 4f       	sbci	r19, 0xFF	; 255
    924e:	82 0f       	add	r24, r18
    9250:	93 1f       	adc	r25, r19
    9252:	fc 01       	movw	r30, r24
    9254:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    9256:	8a 81       	ldd	r24, Y+2	; 0x02
    9258:	8f 5f       	subi	r24, 0xFF	; 255
    925a:	8a 83       	std	Y+2, r24	; 0x02
    925c:	8a 81       	ldd	r24, Y+2	; 0x02
    925e:	8b 30       	cpi	r24, 0x0B	; 11
    9260:	60 f2       	brcs	.-104    	; 0x91fa <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    9262:	1a 82       	std	Y+2, r1	; 0x02
    9264:	14 c0       	rjmp	.+40     	; 0x928e <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    9266:	8a 81       	ldd	r24, Y+2	; 0x02
    9268:	88 2f       	mov	r24, r24
    926a:	90 e0       	ldi	r25, 0x00	; 0
    926c:	2a 81       	ldd	r18, Y+2	; 0x02
    926e:	22 2f       	mov	r18, r18
    9270:	30 e0       	ldi	r19, 0x00	; 0
    9272:	ae 01       	movw	r20, r28
    9274:	4a 5f       	subi	r20, 0xFA	; 250
    9276:	5f 4f       	sbci	r21, 0xFF	; 255
    9278:	24 0f       	add	r18, r20
    927a:	35 1f       	adc	r19, r21
    927c:	f9 01       	movw	r30, r18
    927e:	20 81       	ld	r18, Z
    9280:	85 55       	subi	r24, 0x55	; 85
    9282:	9f 4a       	sbci	r25, 0xAF	; 175
    9284:	fc 01       	movw	r30, r24
    9286:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    9288:	8a 81       	ldd	r24, Y+2	; 0x02
    928a:	8f 5f       	subi	r24, 0xFF	; 255
    928c:	8a 83       	std	Y+2, r24	; 0x02
    928e:	8a 81       	ldd	r24, Y+2	; 0x02
    9290:	8b 30       	cpi	r24, 0x0B	; 11
    9292:	48 f3       	brcs	.-46     	; 0x9266 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    9294:	80 e0       	ldi	r24, 0x00	; 0
}
    9296:	62 96       	adiw	r28, 0x12	; 18
    9298:	cd bf       	out	0x3d, r28	; 61
    929a:	de bf       	out	0x3e, r29	; 62
    929c:	df 91       	pop	r29
    929e:	cf 91       	pop	r28
    92a0:	08 95       	ret

000092a2 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    92a2:	ef 92       	push	r14
    92a4:	ff 92       	push	r15
    92a6:	0f 93       	push	r16
    92a8:	1f 93       	push	r17
    92aa:	cf 93       	push	r28
    92ac:	df 93       	push	r29
    92ae:	cd b7       	in	r28, 0x3d	; 61
    92b0:	de b7       	in	r29, 0x3e	; 62
    92b2:	e7 97       	sbiw	r28, 0x37	; 55
    92b4:	cd bf       	out	0x3d, r28	; 61
    92b6:	de bf       	out	0x3e, r29	; 62
    92b8:	88 ab       	sts	0x58, r24
    92ba:	99 ab       	sts	0x59, r25
    92bc:	6a ab       	sts	0x5a, r22
    92be:	7b ab       	sts	0x5b, r23
    92c0:	2c ab       	sts	0x5c, r18
    92c2:	3d ab       	sts	0x5d, r19
    92c4:	4e ab       	sts	0x5e, r20
    92c6:	5f ab       	sts	0x5f, r21
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    92c8:	1a 82       	std	Y+2, r1	; 0x02
    92ca:	1b 82       	std	Y+3, r1	; 0x03
    92cc:	1c 82       	std	Y+4, r1	; 0x04
    92ce:	1d 82       	std	Y+5, r1	; 0x05
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    92d0:	1e 82       	std	Y+6, r1	; 0x06
    92d2:	1f 82       	std	Y+7, r1	; 0x07
    92d4:	18 86       	std	Y+8, r1	; 0x08
    92d6:	19 86       	std	Y+9, r1	; 0x09
    92d8:	1a 86       	std	Y+10, r1	; 0x0a
    92da:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    92dc:	28 a9       	sts	0x48, r18
    92de:	39 a9       	sts	0x49, r19
    92e0:	81 e0       	ldi	r24, 0x01	; 1
    92e2:	b9 01       	movw	r22, r18
    92e4:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <readFile>
    92e8:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    92ea:	89 81       	ldd	r24, Y+1	; 0x01
    92ec:	81 30       	cpi	r24, 0x01	; 1
    92ee:	09 f0       	breq	.+2      	; 0x92f2 <writeFile+0x50>
    92f0:	84 c0       	rjmp	.+264    	; 0x93fa <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    92f2:	81 e0       	ldi	r24, 0x01	; 1
    92f4:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    92f6:	80 91 7f 50 	lds	r24, 0x507F
    92fa:	90 91 80 50 	lds	r25, 0x5080
    92fe:	a0 91 81 50 	lds	r26, 0x5081
    9302:	b0 91 82 50 	lds	r27, 0x5082
    9306:	8c 87       	std	Y+12, r24	; 0x0c
    9308:	9d 87       	std	Y+13, r25	; 0x0d
    930a:	ae 87       	std	Y+14, r26	; 0x0e
    930c:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    930e:	1c 8a       	std	Y+20, r1	; 0x14
    9310:	1d 8a       	std	Y+21, r1	; 0x15
    9312:	1e 8a       	std	Y+22, r1	; 0x16
    9314:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    9316:	8c 85       	ldd	r24, Y+12	; 0x0c
    9318:	9d 85       	ldd	r25, Y+13	; 0x0d
    931a:	ae 85       	ldd	r26, Y+14	; 0x0e
    931c:	bf 85       	ldd	r27, Y+15	; 0x0f
    931e:	bc 01       	movw	r22, r24
    9320:	cd 01       	movw	r24, r26
    9322:	40 e0       	ldi	r20, 0x00	; 0
    9324:	00 e0       	ldi	r16, 0x00	; 0
    9326:	10 e0       	ldi	r17, 0x00	; 0
    9328:	98 01       	movw	r18, r16
    932a:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
    932e:	dc 01       	movw	r26, r24
    9330:	cb 01       	movw	r24, r22
    9332:	8a a3       	lds	r24, 0x5a
    9334:	9b a3       	lds	r25, 0x5b
    9336:	ac a3       	lds	r26, 0x5c
    9338:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    933a:	8a a1       	lds	r24, 0x4a
    933c:	9b a1       	lds	r25, 0x4b
    933e:	ac a1       	lds	r26, 0x4c
    9340:	bd a1       	lds	r27, 0x4d
    9342:	8f 3f       	cpi	r24, 0xFF	; 255
    9344:	0f ef       	ldi	r16, 0xFF	; 255
    9346:	90 07       	cpc	r25, r16
    9348:	0f ef       	ldi	r16, 0xFF	; 255
    934a:	a0 07       	cpc	r26, r16
    934c:	0f ef       	ldi	r16, 0xFF	; 255
    934e:	b0 07       	cpc	r27, r16
    9350:	a1 f0       	breq	.+40     	; 0x937a <writeFile+0xd8>
	cluster = nextCluster;
    9352:	8a a1       	lds	r24, 0x4a
    9354:	9b a1       	lds	r25, 0x4b
    9356:	ac a1       	lds	r26, 0x4c
    9358:	bd a1       	lds	r27, 0x4d
    935a:	8c 87       	std	Y+12, r24	; 0x0c
    935c:	9d 87       	std	Y+13, r25	; 0x0d
    935e:	ae 87       	std	Y+14, r26	; 0x0e
    9360:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    9362:	8c 89       	ldd	r24, Y+20	; 0x14
    9364:	9d 89       	ldd	r25, Y+21	; 0x15
    9366:	ae 89       	ldd	r26, Y+22	; 0x16
    9368:	bf 89       	ldd	r27, Y+23	; 0x17
    936a:	01 96       	adiw	r24, 0x01	; 1
    936c:	a1 1d       	adc	r26, r1
    936e:	b1 1d       	adc	r27, r1
    9370:	8c 8b       	std	Y+20, r24	; 0x14
    9372:	9d 8b       	std	Y+21, r25	; 0x15
    9374:	ae 8b       	std	Y+22, r26	; 0x16
    9376:	bf 8b       	std	Y+23, r27	; 0x17
  }
    9378:	ce cf       	rjmp	.-100    	; 0x9316 <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    937a:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    937c:	e0 90 48 40 	lds	r14, 0x4048
    9380:	f0 90 49 40 	lds	r15, 0x4049
    9384:	00 91 4a 40 	lds	r16, 0x404A
    9388:	10 91 4b 40 	lds	r17, 0x404B
    938c:	80 91 73 50 	lds	r24, 0x5073
    9390:	90 91 74 50 	lds	r25, 0x5074
    9394:	cc 01       	movw	r24, r24
    9396:	a0 e0       	ldi	r26, 0x00	; 0
    9398:	b0 e0       	ldi	r27, 0x00	; 0
    939a:	2c 89       	ldd	r18, Y+20	; 0x14
    939c:	3d 89       	ldd	r19, Y+21	; 0x15
    939e:	4e 89       	ldd	r20, Y+22	; 0x16
    93a0:	5f 89       	ldd	r21, Y+23	; 0x17
    93a2:	bc 01       	movw	r22, r24
    93a4:	cd 01       	movw	r24, r26
    93a6:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    93aa:	dc 01       	movw	r26, r24
    93ac:	cb 01       	movw	r24, r22
    93ae:	20 91 4c 40 	lds	r18, 0x404C
    93b2:	30 91 4d 40 	lds	r19, 0x404D
    93b6:	99 01       	movw	r18, r18
    93b8:	40 e0       	ldi	r20, 0x00	; 0
    93ba:	50 e0       	ldi	r21, 0x00	; 0
    93bc:	bc 01       	movw	r22, r24
    93be:	cd 01       	movw	r24, r26
    93c0:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    93c4:	dc 01       	movw	r26, r24
    93c6:	cb 01       	movw	r24, r22
    93c8:	a8 01       	movw	r20, r16
    93ca:	97 01       	movw	r18, r14
    93cc:	28 1b       	sub	r18, r24
    93ce:	39 0b       	sbc	r19, r25
    93d0:	4a 0b       	sbc	r20, r26
    93d2:	5b 0b       	sbc	r21, r27
    93d4:	da 01       	movw	r26, r20
    93d6:	c9 01       	movw	r24, r18
    93d8:	20 91 4c 40 	lds	r18, 0x404C
    93dc:	30 91 4d 40 	lds	r19, 0x404D
    93e0:	99 01       	movw	r18, r18
    93e2:	40 e0       	ldi	r20, 0x00	; 0
    93e4:	50 e0       	ldi	r21, 0x00	; 0
    93e6:	bc 01       	movw	r22, r24
    93e8:	cd 01       	movw	r24, r26
    93ea:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    93ee:	da 01       	movw	r26, r20
    93f0:	c9 01       	movw	r24, r18
    93f2:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    93f4:	81 e0       	ldi	r24, 0x01	; 1
    93f6:	8b 83       	std	Y+3, r24	; 0x03
    93f8:	68 c0       	rjmp	.+208    	; 0x94ca <writeFile+0x228>
}
else if(j == 2) 
    93fa:	89 81       	ldd	r24, Y+1	; 0x01
    93fc:	82 30       	cpi	r24, 0x02	; 2
    93fe:	11 f4       	brne	.+4      	; 0x9404 <writeFile+0x162>
   return 1; //invalid file name
    9400:	81 e0       	ldi	r24, 0x01	; 1
    9402:	18 c3       	rjmp	.+1584   	; 0x9a34 <writeFile+0x792>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    9404:	82 e0       	ldi	r24, 0x02	; 2
    9406:	60 e0       	ldi	r22, 0x00	; 0
    9408:	20 e0       	ldi	r18, 0x00	; 0
    940a:	30 e0       	ldi	r19, 0x00	; 0
    940c:	a9 01       	movw	r20, r18
    940e:	0e 94 f0 44 	call	0x89e0	; 0x89e0 <getSetFreeCluster>
    9412:	dc 01       	movw	r26, r24
    9414:	cb 01       	movw	r24, r22
    9416:	8c 87       	std	Y+12, r24	; 0x0c
    9418:	9d 87       	std	Y+13, r25	; 0x0d
    941a:	ae 87       	std	Y+14, r26	; 0x0e
    941c:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    941e:	80 91 51 40 	lds	r24, 0x4051
    9422:	90 91 52 40 	lds	r25, 0x4052
    9426:	a0 91 53 40 	lds	r26, 0x4053
    942a:	b0 91 54 40 	lds	r27, 0x4054
    942e:	2c 85       	ldd	r18, Y+12	; 0x0c
    9430:	3d 85       	ldd	r19, Y+13	; 0x0d
    9432:	4e 85       	ldd	r20, Y+14	; 0x0e
    9434:	5f 85       	ldd	r21, Y+15	; 0x0f
    9436:	82 17       	cp	r24, r18
    9438:	93 07       	cpc	r25, r19
    943a:	a4 07       	cpc	r26, r20
    943c:	b5 07       	cpc	r27, r21
    943e:	60 f4       	brcc	.+24     	; 0x9458 <writeFile+0x1b6>
     cluster = rootCluster;
    9440:	80 91 57 40 	lds	r24, 0x4057
    9444:	90 91 58 40 	lds	r25, 0x4058
    9448:	a0 91 59 40 	lds	r26, 0x4059
    944c:	b0 91 5a 40 	lds	r27, 0x405A
    9450:	8c 87       	std	Y+12, r24	; 0x0c
    9452:	9d 87       	std	Y+13, r25	; 0x0d
    9454:	ae 87       	std	Y+14, r26	; 0x0e
    9456:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    9458:	8c 85       	ldd	r24, Y+12	; 0x0c
    945a:	9d 85       	ldd	r25, Y+13	; 0x0d
    945c:	ae 85       	ldd	r26, Y+14	; 0x0e
    945e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9460:	bc 01       	movw	r22, r24
    9462:	cd 01       	movw	r24, r26
    9464:	0e 94 24 4d 	call	0x9a48	; 0x9a48 <searchNextFreeCluster>
    9468:	dc 01       	movw	r26, r24
    946a:	cb 01       	movw	r24, r22
    946c:	8c 87       	std	Y+12, r24	; 0x0c
    946e:	9d 87       	std	Y+13, r25	; 0x0d
    9470:	ae 87       	std	Y+14, r26	; 0x0e
    9472:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    9474:	8c 85       	ldd	r24, Y+12	; 0x0c
    9476:	9d 85       	ldd	r25, Y+13	; 0x0d
    9478:	ae 85       	ldd	r26, Y+14	; 0x0e
    947a:	bf 85       	ldd	r27, Y+15	; 0x0f
    947c:	00 97       	sbiw	r24, 0x00	; 0
    947e:	a1 05       	cpc	r26, r1
    9480:	b1 05       	cpc	r27, r1
    9482:	11 f4       	brne	.+4      	; 0x9488 <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    9484:	82 e0       	ldi	r24, 0x02	; 2
    9486:	d6 c2       	rjmp	.+1452   	; 0x9a34 <writeFile+0x792>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    9488:	8c 85       	ldd	r24, Y+12	; 0x0c
    948a:	9d 85       	ldd	r25, Y+13	; 0x0d
    948c:	ae 85       	ldd	r26, Y+14	; 0x0e
    948e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9490:	bc 01       	movw	r22, r24
    9492:	cd 01       	movw	r24, r26
    9494:	41 e0       	ldi	r20, 0x01	; 1
    9496:	0f ef       	ldi	r16, 0xFF	; 255
    9498:	1f ef       	ldi	r17, 0xFF	; 255
    949a:	98 01       	movw	r18, r16
    949c:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    94a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    94a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    94a4:	ae 85       	ldd	r26, Y+14	; 0x0e
    94a6:	bf 85       	ldd	r27, Y+15	; 0x0f
    94a8:	cd 01       	movw	r24, r26
    94aa:	aa 27       	eor	r26, r26
    94ac:	bb 27       	eor	r27, r27
    94ae:	8e 83       	std	Y+6, r24	; 0x06
    94b0:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    94b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    94b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    94b6:	88 87       	std	Y+8, r24	; 0x08
    94b8:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    94ba:	10 92 48 40 	sts	0x4048, r1
    94be:	10 92 49 40 	sts	0x4049, r1
    94c2:	10 92 4a 40 	sts	0x404A, r1
    94c6:	10 92 4b 40 	sts	0x404B, r1
}

//start writing data here

if(start){
    94ca:	8b 81       	ldd	r24, Y+3	; 0x03
    94cc:	88 23       	and	r24, r24
    94ce:	11 f1       	breq	.+68     	; 0x9514 <writeFile+0x272>
  start = 0;
    94d0:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    94d2:	8c 85       	ldd	r24, Y+12	; 0x0c
    94d4:	9d 85       	ldd	r25, Y+13	; 0x0d
    94d6:	ae 85       	ldd	r26, Y+14	; 0x0e
    94d8:	bf 85       	ldd	r27, Y+15	; 0x0f
    94da:	bc 01       	movw	r22, r24
    94dc:	cd 01       	movw	r24, r26
    94de:	0e 94 15 44 	call	0x882a	; 0x882a <getFirstSector>
    94e2:	dc 01       	movw	r26, r24
    94e4:	cb 01       	movw	r24, r22
    94e6:	9c 01       	movw	r18, r24
    94e8:	8d 81       	ldd	r24, Y+5	; 0x05
    94ea:	88 2f       	mov	r24, r24
    94ec:	90 e0       	ldi	r25, 0x00	; 0
    94ee:	82 0f       	add	r24, r18
    94f0:	93 1f       	adc	r25, r19
    94f2:	8a 87       	std	Y+10, r24	; 0x0a
    94f4:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    94f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    94f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    94fa:	cc 01       	movw	r24, r24
    94fc:	a0 e0       	ldi	r26, 0x00	; 0
    94fe:	b0 e0       	ldi	r27, 0x00	; 0
    9500:	2e ec       	ldi	r18, 0xCE	; 206
    9502:	31 e2       	ldi	r19, 0x21	; 33
    9504:	bc 01       	movw	r22, r24
    9506:	cd 01       	movw	r24, r26
    9508:	a9 01       	movw	r20, r18
    950a:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
  j = sector;
    950e:	8d 81       	ldd	r24, Y+5	; 0x05
    9510:	89 83       	std	Y+1, r24	; 0x01
    9512:	0d c0       	rjmp	.+26     	; 0x952e <writeFile+0x28c>
}
else{
  startBlock = getFirstSector (cluster);
    9514:	8c 85       	ldd	r24, Y+12	; 0x0c
    9516:	9d 85       	ldd	r25, Y+13	; 0x0d
    9518:	ae 85       	ldd	r26, Y+14	; 0x0e
    951a:	bf 85       	ldd	r27, Y+15	; 0x0f
    951c:	bc 01       	movw	r22, r24
    951e:	cd 01       	movw	r24, r26
    9520:	0e 94 15 44 	call	0x882a	; 0x882a <getFirstSector>
    9524:	dc 01       	movw	r26, r24
    9526:	cb 01       	movw	r24, r22
    9528:	8a 87       	std	Y+10, r24	; 0x0a
    952a:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    952c:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    952e:	18 8e       	std	Y+24, r1	; 0x18
    9530:	19 8e       	std	Y+25, r1	; 0x19
    9532:	1a 8e       	std	Y+26, r1	; 0x1a
    9534:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    9536:	1c 8e       	std	Y+28, r1	; 0x1c
    9538:	1d 8e       	std	Y+29, r1	; 0x1d
    953a:	1e 8e       	std	Y+30, r1	; 0x1e
    953c:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    953e:	cc c0       	rjmp	.+408    	; 0x96d8 <writeFile+0x436>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    9540:	8c a9       	sts	0x4c, r24
    9542:	9d a9       	sts	0x4d, r25
    9544:	ae a9       	sts	0x4e, r26
    9546:	bf a9       	sts	0x4f, r27
    9548:	80 30       	cpi	r24, 0x00	; 0
    954a:	32 e0       	ldi	r19, 0x02	; 2
    954c:	93 07       	cpc	r25, r19
    954e:	30 e0       	ldi	r19, 0x00	; 0
    9550:	a3 07       	cpc	r26, r19
    9552:	30 e0       	ldi	r19, 0x00	; 0
    9554:	b3 07       	cpc	r27, r19
    9556:	08 f1       	brcs	.+66     	; 0x959a <writeFile+0x2f8>
		 writtenData += 512;
    9558:	88 8d       	ldd	r24, Y+24	; 0x18
    955a:	99 8d       	ldd	r25, Y+25	; 0x19
    955c:	aa 8d       	ldd	r26, Y+26	; 0x1a
    955e:	bb 8d       	ldd	r27, Y+27	; 0x1b
    9560:	80 50       	subi	r24, 0x00	; 0
    9562:	9e 4f       	sbci	r25, 0xFE	; 254
    9564:	af 4f       	sbci	r26, 0xFF	; 255
    9566:	bf 4f       	sbci	r27, 0xFF	; 255
    9568:	88 8f       	std	Y+24, r24	; 0x18
    956a:	99 8f       	std	Y+25, r25	; 0x19
    956c:	aa 8f       	std	Y+26, r26	; 0x1a
    956e:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    9570:	80 e0       	ldi	r24, 0x00	; 0
    9572:	92 e0       	ldi	r25, 0x02	; 2
    9574:	a0 e0       	ldi	r26, 0x00	; 0
    9576:	b0 e0       	ldi	r27, 0x00	; 0
    9578:	8c 8f       	std	Y+28, r24	; 0x1c
    957a:	9d 8f       	std	Y+29, r25	; 0x1d
    957c:	ae 8f       	std	Y+30, r26	; 0x1e
    957e:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    9580:	8c a9       	sts	0x4c, r24
    9582:	9d a9       	sts	0x4d, r25
    9584:	ae a9       	sts	0x4e, r26
    9586:	bf a9       	sts	0x4f, r27
    9588:	80 50       	subi	r24, 0x00	; 0
    958a:	92 40       	sbci	r25, 0x02	; 2
    958c:	a0 40       	sbci	r26, 0x00	; 0
    958e:	b0 40       	sbci	r27, 0x00	; 0
    9590:	8c ab       	sts	0x5c, r24
    9592:	9d ab       	sts	0x5d, r25
    9594:	ae ab       	sts	0x5e, r26
    9596:	bf ab       	sts	0x5f, r27
    9598:	1f c0       	rjmp	.+62     	; 0x95d8 <writeFile+0x336>
	}
	else{
		writtenData += lengthOfData;
    959a:	28 8d       	ldd	r18, Y+24	; 0x18
    959c:	39 8d       	ldd	r19, Y+25	; 0x19
    959e:	4a 8d       	ldd	r20, Y+26	; 0x1a
    95a0:	5b 8d       	ldd	r21, Y+27	; 0x1b
    95a2:	8c a9       	sts	0x4c, r24
    95a4:	9d a9       	sts	0x4d, r25
    95a6:	ae a9       	sts	0x4e, r26
    95a8:	bf a9       	sts	0x4f, r27
    95aa:	82 0f       	add	r24, r18
    95ac:	93 1f       	adc	r25, r19
    95ae:	a4 1f       	adc	r26, r20
    95b0:	b5 1f       	adc	r27, r21
    95b2:	88 8f       	std	Y+24, r24	; 0x18
    95b4:	99 8f       	std	Y+25, r25	; 0x19
    95b6:	aa 8f       	std	Y+26, r26	; 0x1a
    95b8:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    95ba:	8c a9       	sts	0x4c, r24
    95bc:	9d a9       	sts	0x4d, r25
    95be:	ae a9       	sts	0x4e, r26
    95c0:	bf a9       	sts	0x4f, r27
    95c2:	91 70       	andi	r25, 0x01	; 1
    95c4:	a0 70       	andi	r26, 0x00	; 0
    95c6:	b0 70       	andi	r27, 0x00	; 0
    95c8:	8c 8f       	std	Y+28, r24	; 0x1c
    95ca:	9d 8f       	std	Y+29, r25	; 0x1d
    95cc:	ae 8f       	std	Y+30, r26	; 0x1e
    95ce:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    95d0:	1c aa       	sts	0x9c, r17
    95d2:	1d aa       	sts	0x9d, r17
    95d4:	1e aa       	sts	0x9e, r17
    95d6:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    95d8:	80 91 48 40 	lds	r24, 0x4048
    95dc:	90 91 49 40 	lds	r25, 0x4049
    95e0:	a0 91 4a 40 	lds	r26, 0x404A
    95e4:	b0 91 4b 40 	lds	r27, 0x404B
    95e8:	80 50       	subi	r24, 0x00	; 0
    95ea:	9e 4f       	sbci	r25, 0xFE	; 254
    95ec:	af 4f       	sbci	r26, 0xFF	; 255
    95ee:	bf 4f       	sbci	r27, 0xFF	; 255
    95f0:	80 93 48 40 	sts	0x4048, r24
    95f4:	90 93 49 40 	sts	0x4049, r25
    95f8:	a0 93 4a 40 	sts	0x404A, r26
    95fc:	b0 93 4b 40 	sts	0x404B, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    9600:	8a 85       	ldd	r24, Y+10	; 0x0a
    9602:	9b 85       	ldd	r25, Y+11	; 0x0b
    9604:	cc 01       	movw	r24, r24
    9606:	a0 e0       	ldi	r26, 0x00	; 0
    9608:	b0 e0       	ldi	r27, 0x00	; 0
    960a:	48 8d       	ldd	r20, Y+24	; 0x18
    960c:	59 8d       	ldd	r21, Y+25	; 0x19
    960e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9610:	3d 8d       	ldd	r19, Y+29	; 0x1d
    9612:	ba 01       	movw	r22, r20
    9614:	62 1b       	sub	r22, r18
    9616:	73 0b       	sbc	r23, r19
    9618:	9b 01       	movw	r18, r22
    961a:	4a a9       	sts	0x4a, r20
    961c:	5b a9       	sts	0x4b, r21
    961e:	42 0f       	add	r20, r18
    9620:	53 1f       	adc	r21, r19
    9622:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9624:	3d 8d       	ldd	r19, Y+29	; 0x1d
    9626:	bc 01       	movw	r22, r24
    9628:	cd 01       	movw	r24, r26
    962a:	0e 94 5c 51 	call	0xa2b8	; 0xa2b8 <SD_write_block>
	j++;
    962e:	89 81       	ldd	r24, Y+1	; 0x01
    9630:	8f 5f       	subi	r24, 0xFF	; 255
    9632:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    9634:	89 81       	ldd	r24, Y+1	; 0x01
    9636:	28 2f       	mov	r18, r24
    9638:	30 e0       	ldi	r19, 0x00	; 0
    963a:	80 91 73 50 	lds	r24, 0x5073
    963e:	90 91 74 50 	lds	r25, 0x5074
    9642:	28 17       	cp	r18, r24
    9644:	39 07       	cpc	r19, r25
    9646:	d9 f5       	brne	.+118    	; 0x96be <writeFile+0x41c>
		j = 0; 
    9648:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    964a:	8c 85       	ldd	r24, Y+12	; 0x0c
    964c:	9d 85       	ldd	r25, Y+13	; 0x0d
    964e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9650:	bf 85       	ldd	r27, Y+15	; 0x0f
    9652:	88 8b       	std	Y+16, r24	; 0x10
    9654:	99 8b       	std	Y+17, r25	; 0x11
    9656:	aa 8b       	std	Y+18, r26	; 0x12
    9658:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    965a:	88 89       	ldd	r24, Y+16	; 0x10
    965c:	99 89       	ldd	r25, Y+17	; 0x11
    965e:	aa 89       	ldd	r26, Y+18	; 0x12
    9660:	bb 89       	ldd	r27, Y+19	; 0x13
    9662:	bc 01       	movw	r22, r24
    9664:	cd 01       	movw	r24, r26
    9666:	0e 94 24 4d 	call	0x9a48	; 0x9a48 <searchNextFreeCluster>
    966a:	dc 01       	movw	r26, r24
    966c:	cb 01       	movw	r24, r22
    966e:	8c 87       	std	Y+12, r24	; 0x0c
    9670:	9d 87       	std	Y+13, r25	; 0x0d
    9672:	ae 87       	std	Y+14, r26	; 0x0e
    9674:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    9676:	8c 85       	ldd	r24, Y+12	; 0x0c
    9678:	9d 85       	ldd	r25, Y+13	; 0x0d
    967a:	ae 85       	ldd	r26, Y+14	; 0x0e
    967c:	bf 85       	ldd	r27, Y+15	; 0x0f
    967e:	00 97       	sbiw	r24, 0x00	; 0
    9680:	a1 05       	cpc	r26, r1
    9682:	b1 05       	cpc	r27, r1
    9684:	11 f4       	brne	.+4      	; 0x968a <writeFile+0x3e8>
		  //No free cluster!
		  return 2;
    9686:	82 e0       	ldi	r24, 0x02	; 2
    9688:	d5 c1       	rjmp	.+938    	; 0x9a34 <writeFile+0x792>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    968a:	88 89       	ldd	r24, Y+16	; 0x10
    968c:	99 89       	ldd	r25, Y+17	; 0x11
    968e:	aa 89       	ldd	r26, Y+18	; 0x12
    9690:	bb 89       	ldd	r27, Y+19	; 0x13
    9692:	0c 85       	ldd	r16, Y+12	; 0x0c
    9694:	1d 85       	ldd	r17, Y+13	; 0x0d
    9696:	2e 85       	ldd	r18, Y+14	; 0x0e
    9698:	3f 85       	ldd	r19, Y+15	; 0x0f
    969a:	bc 01       	movw	r22, r24
    969c:	cd 01       	movw	r24, r26
    969e:	41 e0       	ldi	r20, 0x01	; 1
    96a0:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    96a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    96a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    96a8:	ae 85       	ldd	r26, Y+14	; 0x0e
    96aa:	bf 85       	ldd	r27, Y+15	; 0x0f
    96ac:	bc 01       	movw	r22, r24
    96ae:	cd 01       	movw	r24, r26
    96b0:	41 e0       	ldi	r20, 0x01	; 1
    96b2:	0f ef       	ldi	r16, 0xFF	; 255
    96b4:	1f ef       	ldi	r17, 0xFF	; 255
    96b6:	98 01       	movw	r18, r16
    96b8:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
    96bc:	05 c0       	rjmp	.+10     	; 0x96c8 <writeFile+0x426>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    96be:	8a 85       	ldd	r24, Y+10	; 0x0a
    96c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    96c2:	01 96       	adiw	r24, 0x01	; 1
    96c4:	8a 87       	std	Y+10, r24	; 0x0a
    96c6:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    96c8:	2c 85       	ldd	r18, Y+12	; 0x0c
    96ca:	3d 85       	ldd	r19, Y+13	; 0x0d
    96cc:	4e 85       	ldd	r20, Y+14	; 0x0e
    96ce:	5f 85       	ldd	r21, Y+15	; 0x0f
    96d0:	82 e0       	ldi	r24, 0x02	; 2
    96d2:	61 e0       	ldi	r22, 0x01	; 1
    96d4:	0e 94 f0 44 	call	0x89e0	; 0x89e0 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    96d8:	8c a9       	sts	0x4c, r24
    96da:	9d a9       	sts	0x4d, r25
    96dc:	ae a9       	sts	0x4e, r26
    96de:	bf a9       	sts	0x4f, r27
    96e0:	00 97       	sbiw	r24, 0x00	; 0
    96e2:	a1 05       	cpc	r26, r1
    96e4:	b1 05       	cpc	r27, r1
    96e6:	09 f0       	breq	.+2      	; 0x96ea <writeFile+0x448>
    96e8:	2b cf       	rjmp	.-426    	; 0x9540 <writeFile+0x29e>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    96ea:	8c 81       	ldd	r24, Y+4	; 0x04
    96ec:	88 23       	and	r24, r24
    96ee:	09 f4       	brne	.+2      	; 0x96f2 <writeFile+0x450>
    96f0:	66 c0       	rjmp	.+204    	; 0x97be <writeFile+0x51c>
{
  SD_read_block (appendFileSector,SDBuffer);    
    96f2:	80 91 c1 50 	lds	r24, 0x50C1
    96f6:	90 91 c2 50 	lds	r25, 0x50C2
    96fa:	a0 91 c3 50 	lds	r26, 0x50C3
    96fe:	b0 91 c4 50 	lds	r27, 0x50C4
    9702:	2e ec       	ldi	r18, 0xCE	; 206
    9704:	31 e2       	ldi	r19, 0x21	; 33
    9706:	bc 01       	movw	r22, r24
    9708:	cd 01       	movw	r24, r26
    970a:	a9 01       	movw	r20, r18
    970c:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    9710:	80 91 cf 23 	lds	r24, 0x23CF
    9714:	90 91 d0 23 	lds	r25, 0x23D0
    9718:	a0 91 d1 23 	lds	r26, 0x23D1
    971c:	b0 91 d2 23 	lds	r27, 0x23D2
    9720:	82 53       	subi	r24, 0x32	; 50
    9722:	9e 4d       	sbci	r25, 0xDE	; 222
    9724:	8e a3       	lds	r24, 0x5e
    9726:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    9728:	8e a1       	lds	r24, 0x4e
    972a:	9f a1       	lds	r25, 0x4f
    972c:	fc 01       	movw	r30, r24
    972e:	12 8a       	std	Z+18, r1	; 0x12
    9730:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    9732:	20 91 48 40 	lds	r18, 0x4048
    9736:	30 91 49 40 	lds	r19, 0x4049
    973a:	40 91 4a 40 	lds	r20, 0x404A
    973e:	50 91 4b 40 	lds	r21, 0x404B
    9742:	8e a1       	lds	r24, 0x4e
    9744:	9f a1       	lds	r25, 0x4f
    9746:	fc 01       	movw	r30, r24
    9748:	84 8d       	ldd	r24, Z+28	; 0x1c
    974a:	95 8d       	ldd	r25, Z+29	; 0x1d
    974c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    974e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    9750:	79 01       	movw	r14, r18
    9752:	8a 01       	movw	r16, r20
    9754:	e8 1a       	sub	r14, r24
    9756:	f9 0a       	sbc	r15, r25
    9758:	0a 0b       	sbc	r16, r26
    975a:	1b 0b       	sbc	r17, r27
    975c:	d8 01       	movw	r26, r16
    975e:	c7 01       	movw	r24, r14
    9760:	88 a7       	lds	r24, 0x78
    9762:	99 a7       	lds	r25, 0x79
    9764:	aa a7       	lds	r26, 0x7a
    9766:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    9768:	80 91 48 40 	lds	r24, 0x4048
    976c:	90 91 49 40 	lds	r25, 0x4049
    9770:	a0 91 4a 40 	lds	r26, 0x404A
    9774:	b0 91 4b 40 	lds	r27, 0x404B
    9778:	2e a1       	lds	r18, 0x4e
    977a:	3f a1       	lds	r19, 0x4f
    977c:	f9 01       	movw	r30, r18
    977e:	84 8f       	std	Z+28, r24	; 0x1c
    9780:	95 8f       	std	Z+29, r25	; 0x1d
    9782:	a6 8f       	std	Z+30, r26	; 0x1e
    9784:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    9786:	80 91 c1 50 	lds	r24, 0x50C1
    978a:	90 91 c2 50 	lds	r25, 0x50C2
    978e:	a0 91 c3 50 	lds	r26, 0x50C3
    9792:	b0 91 c4 50 	lds	r27, 0x50C4
    9796:	2e ec       	ldi	r18, 0xCE	; 206
    9798:	31 e2       	ldi	r19, 0x21	; 33
    979a:	bc 01       	movw	r22, r24
    979c:	cd 01       	movw	r24, r26
    979e:	a9 01       	movw	r20, r18
    97a0:	20 e0       	ldi	r18, 0x00	; 0
    97a2:	32 e0       	ldi	r19, 0x02	; 2
    97a4:	0e 94 5c 51 	call	0xa2b8	; 0xa2b8 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    97a8:	28 a5       	lds	r18, 0x68
    97aa:	39 a5       	lds	r19, 0x69
    97ac:	4a a5       	lds	r20, 0x6a
    97ae:	5b a5       	lds	r21, 0x6b
    97b0:	81 e0       	ldi	r24, 0x01	; 1
    97b2:	ba 01       	movw	r22, r20
    97b4:	a9 01       	movw	r20, r18
    97b6:	0e 94 fd 4d 	call	0x9bfa	; 0x9bfa <freeMemoryUpdate>

 //File appended!
  return 0;
    97ba:	80 e0       	ldi	r24, 0x00	; 0
    97bc:	3b c1       	rjmp	.+630    	; 0x9a34 <writeFile+0x792>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    97be:	80 91 57 40 	lds	r24, 0x4057
    97c2:	90 91 58 40 	lds	r25, 0x4058
    97c6:	a0 91 59 40 	lds	r26, 0x4059
    97ca:	b0 91 5a 40 	lds	r27, 0x405A
    97ce:	88 8b       	std	Y+16, r24	; 0x10
    97d0:	99 8b       	std	Y+17, r25	; 0x11
    97d2:	aa 8b       	std	Y+18, r26	; 0x12
    97d4:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    97d6:	88 89       	ldd	r24, Y+16	; 0x10
    97d8:	99 89       	ldd	r25, Y+17	; 0x11
    97da:	aa 89       	ldd	r26, Y+18	; 0x12
    97dc:	bb 89       	ldd	r27, Y+19	; 0x13
    97de:	bc 01       	movw	r22, r24
    97e0:	cd 01       	movw	r24, r26
    97e2:	0e 94 15 44 	call	0x882a	; 0x882a <getFirstSector>
    97e6:	dc 01       	movw	r26, r24
    97e8:	cb 01       	movw	r24, r22
    97ea:	8c a7       	lds	r24, 0x7c
    97ec:	9d a7       	lds	r25, 0x7d
    97ee:	ae a7       	lds	r26, 0x7e
    97f0:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    97f2:	1d 82       	std	Y+5, r1	; 0x05
    97f4:	ad c0       	rjmp	.+346    	; 0x9950 <writeFile+0x6ae>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    97f6:	8d 81       	ldd	r24, Y+5	; 0x05
    97f8:	28 2f       	mov	r18, r24
    97fa:	30 e0       	ldi	r19, 0x00	; 0
    97fc:	40 e0       	ldi	r20, 0x00	; 0
    97fe:	50 e0       	ldi	r21, 0x00	; 0
    9800:	8c a5       	lds	r24, 0x6c
    9802:	9d a5       	lds	r25, 0x6d
    9804:	ae a5       	lds	r26, 0x6e
    9806:	bf a5       	lds	r27, 0x6f
    9808:	82 0f       	add	r24, r18
    980a:	93 1f       	adc	r25, r19
    980c:	a4 1f       	adc	r26, r20
    980e:	b5 1f       	adc	r27, r21
    9810:	2e ec       	ldi	r18, 0xCE	; 206
    9812:	31 e2       	ldi	r19, 0x21	; 33
    9814:	bc 01       	movw	r22, r24
    9816:	cd 01       	movw	r24, r26
    9818:	a9 01       	movw	r20, r18
    981a:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    981e:	18 a2       	lds	r17, 0x98
    9820:	19 a2       	lds	r17, 0x99
    9822:	89 c0       	rjmp	.+274    	; 0x9936 <writeFile+0x694>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    9824:	88 a1       	lds	r24, 0x48
    9826:	99 a1       	lds	r25, 0x49
    9828:	82 53       	subi	r24, 0x32	; 50
    982a:	9e 4d       	sbci	r25, 0xDE	; 222
    982c:	8e a3       	lds	r24, 0x5e
    982e:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    9830:	8a 81       	ldd	r24, Y+2	; 0x02
    9832:	88 23       	and	r24, r24
    9834:	11 f0       	breq	.+4      	; 0x983a <writeFile+0x598>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    9836:	80 e0       	ldi	r24, 0x00	; 0
    9838:	fd c0       	rjmp	.+506    	; 0x9a34 <writeFile+0x792>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    983a:	8e a1       	lds	r24, 0x4e
    983c:	9f a1       	lds	r25, 0x4f
    983e:	fc 01       	movw	r30, r24
    9840:	80 81       	ld	r24, Z
    9842:	88 23       	and	r24, r24
    9844:	39 f0       	breq	.+14     	; 0x9854 <writeFile+0x5b2>
    9846:	8e a1       	lds	r24, 0x4e
    9848:	9f a1       	lds	r25, 0x4f
    984a:	fc 01       	movw	r30, r24
    984c:	80 81       	ld	r24, Z
    984e:	85 3e       	cpi	r24, 0xE5	; 229
    9850:	09 f0       	breq	.+2      	; 0x9854 <writeFile+0x5b2>
    9852:	6c c0       	rjmp	.+216    	; 0x992c <writeFile+0x68a>
		{
		  for(j=0; j<11; j++)
    9854:	19 82       	std	Y+1, r1	; 0x01
    9856:	13 c0       	rjmp	.+38     	; 0x987e <writeFile+0x5dc>
  			dir->name[j] = Filename[j];
    9858:	89 81       	ldd	r24, Y+1	; 0x01
    985a:	88 2f       	mov	r24, r24
    985c:	90 e0       	ldi	r25, 0x00	; 0
    985e:	29 81       	ldd	r18, Y+1	; 0x01
    9860:	22 2f       	mov	r18, r18
    9862:	30 e0       	ldi	r19, 0x00	; 0
    9864:	25 55       	subi	r18, 0x55	; 85
    9866:	3f 4a       	sbci	r19, 0xAF	; 175
    9868:	f9 01       	movw	r30, r18
    986a:	40 81       	ld	r20, Z
    986c:	2e a1       	lds	r18, 0x4e
    986e:	3f a1       	lds	r19, 0x4f
    9870:	82 0f       	add	r24, r18
    9872:	93 1f       	adc	r25, r19
    9874:	fc 01       	movw	r30, r24
    9876:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    9878:	89 81       	ldd	r24, Y+1	; 0x01
    987a:	8f 5f       	subi	r24, 0xFF	; 255
    987c:	89 83       	std	Y+1, r24	; 0x01
    987e:	89 81       	ldd	r24, Y+1	; 0x01
    9880:	8b 30       	cpi	r24, 0x0B	; 11
    9882:	50 f3       	brcs	.-44     	; 0x9858 <writeFile+0x5b6>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    9884:	8e a1       	lds	r24, 0x4e
    9886:	9f a1       	lds	r25, 0x4f
    9888:	20 e2       	ldi	r18, 0x20	; 32
    988a:	fc 01       	movw	r30, r24
    988c:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    988e:	8e a1       	lds	r24, 0x4e
    9890:	9f a1       	lds	r25, 0x4f
    9892:	fc 01       	movw	r30, r24
    9894:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    9896:	8e a1       	lds	r24, 0x4e
    9898:	9f a1       	lds	r25, 0x4f
    989a:	fc 01       	movw	r30, r24
    989c:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    989e:	8e a1       	lds	r24, 0x4e
    98a0:	9f a1       	lds	r25, 0x4f
    98a2:	fc 01       	movw	r30, r24
    98a4:	12 8a       	std	Z+18, r1	; 0x12
    98a6:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    98a8:	8e a1       	lds	r24, 0x4e
    98aa:	9f a1       	lds	r25, 0x4f
    98ac:	2e 81       	ldd	r18, Y+6	; 0x06
    98ae:	3f 81       	ldd	r19, Y+7	; 0x07
    98b0:	fc 01       	movw	r30, r24
    98b2:	24 8b       	std	Z+20, r18	; 0x14
    98b4:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    98b6:	8e a1       	lds	r24, 0x4e
    98b8:	9f a1       	lds	r25, 0x4f
    98ba:	28 85       	ldd	r18, Y+8	; 0x08
    98bc:	39 85       	ldd	r19, Y+9	; 0x09
    98be:	fc 01       	movw	r30, r24
    98c0:	22 8f       	std	Z+26, r18	; 0x1a
    98c2:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    98c4:	80 91 48 40 	lds	r24, 0x4048
    98c8:	90 91 49 40 	lds	r25, 0x4049
    98cc:	a0 91 4a 40 	lds	r26, 0x404A
    98d0:	b0 91 4b 40 	lds	r27, 0x404B
    98d4:	2e a1       	lds	r18, 0x4e
    98d6:	3f a1       	lds	r19, 0x4f
    98d8:	f9 01       	movw	r30, r18
    98da:	84 8f       	std	Z+28, r24	; 0x1c
    98dc:	95 8f       	std	Z+29, r25	; 0x1d
    98de:	a6 8f       	std	Z+30, r26	; 0x1e
    98e0:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    98e2:	8d 81       	ldd	r24, Y+5	; 0x05
    98e4:	28 2f       	mov	r18, r24
    98e6:	30 e0       	ldi	r19, 0x00	; 0
    98e8:	40 e0       	ldi	r20, 0x00	; 0
    98ea:	50 e0       	ldi	r21, 0x00	; 0
    98ec:	8c a5       	lds	r24, 0x6c
    98ee:	9d a5       	lds	r25, 0x6d
    98f0:	ae a5       	lds	r26, 0x6e
    98f2:	bf a5       	lds	r27, 0x6f
    98f4:	82 0f       	add	r24, r18
    98f6:	93 1f       	adc	r25, r19
    98f8:	a4 1f       	adc	r26, r20
    98fa:	b5 1f       	adc	r27, r21
    98fc:	2e ec       	ldi	r18, 0xCE	; 206
    98fe:	31 e2       	ldi	r19, 0x21	; 33
    9900:	bc 01       	movw	r22, r24
    9902:	cd 01       	movw	r24, r26
    9904:	a9 01       	movw	r20, r18
    9906:	20 e0       	ldi	r18, 0x00	; 0
    9908:	32 e0       	ldi	r19, 0x02	; 2
    990a:	0e 94 5c 51 	call	0xa2b8	; 0xa2b8 <SD_write_block>
		  fileCreatedFlag = 1;
    990e:	81 e0       	ldi	r24, 0x01	; 1
    9910:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    9912:	20 91 48 40 	lds	r18, 0x4048
    9916:	30 91 49 40 	lds	r19, 0x4049
    991a:	40 91 4a 40 	lds	r20, 0x404A
    991e:	50 91 4b 40 	lds	r21, 0x404B
    9922:	81 e0       	ldi	r24, 0x01	; 1
    9924:	ba 01       	movw	r22, r20
    9926:	a9 01       	movw	r20, r18
    9928:	0e 94 fd 4d 	call	0x9bfa	; 0x9bfa <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    992c:	88 a1       	lds	r24, 0x48
    992e:	99 a1       	lds	r25, 0x49
    9930:	80 96       	adiw	r24, 0x20	; 32
    9932:	88 a3       	lds	r24, 0x58
    9934:	99 a3       	lds	r25, 0x59
    9936:	28 a1       	lds	r18, 0x48
    9938:	39 a1       	lds	r19, 0x49
    993a:	80 91 4c 40 	lds	r24, 0x404C
    993e:	90 91 4d 40 	lds	r25, 0x404D
    9942:	28 17       	cp	r18, r24
    9944:	39 07       	cpc	r19, r25
    9946:	08 f4       	brcc	.+2      	; 0x994a <writeFile+0x6a8>
    9948:	6d cf       	rjmp	.-294    	; 0x9824 <writeFile+0x582>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    994a:	8d 81       	ldd	r24, Y+5	; 0x05
    994c:	8f 5f       	subi	r24, 0xFF	; 255
    994e:	8d 83       	std	Y+5, r24	; 0x05
    9950:	8d 81       	ldd	r24, Y+5	; 0x05
    9952:	28 2f       	mov	r18, r24
    9954:	30 e0       	ldi	r19, 0x00	; 0
    9956:	80 91 73 50 	lds	r24, 0x5073
    995a:	90 91 74 50 	lds	r25, 0x5074
    995e:	28 17       	cp	r18, r24
    9960:	39 07       	cpc	r19, r25
    9962:	08 f4       	brcc	.+2      	; 0x9966 <writeFile+0x6c4>
    9964:	48 cf       	rjmp	.-368    	; 0x97f6 <writeFile+0x554>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    9966:	88 89       	ldd	r24, Y+16	; 0x10
    9968:	99 89       	ldd	r25, Y+17	; 0x11
    996a:	aa 89       	ldd	r26, Y+18	; 0x12
    996c:	bb 89       	ldd	r27, Y+19	; 0x13
    996e:	bc 01       	movw	r22, r24
    9970:	cd 01       	movw	r24, r26
    9972:	40 e0       	ldi	r20, 0x00	; 0
    9974:	00 e0       	ldi	r16, 0x00	; 0
    9976:	10 e0       	ldi	r17, 0x00	; 0
    9978:	98 01       	movw	r18, r16
    997a:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
    997e:	dc 01       	movw	r26, r24
    9980:	cb 01       	movw	r24, r22
    9982:	8c 87       	std	Y+12, r24	; 0x0c
    9984:	9d 87       	std	Y+13, r25	; 0x0d
    9986:	ae 87       	std	Y+14, r26	; 0x0e
    9988:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    998a:	8c 85       	ldd	r24, Y+12	; 0x0c
    998c:	9d 85       	ldd	r25, Y+13	; 0x0d
    998e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9990:	bf 85       	ldd	r27, Y+15	; 0x0f
    9992:	87 3f       	cpi	r24, 0xF7	; 247
    9994:	ff ef       	ldi	r31, 0xFF	; 255
    9996:	9f 07       	cpc	r25, r31
    9998:	ff ef       	ldi	r31, 0xFF	; 255
    999a:	af 07       	cpc	r26, r31
    999c:	ff e0       	ldi	r31, 0x0F	; 15
    999e:	bf 07       	cpc	r27, r31
    99a0:	b0 f1       	brcs	.+108    	; 0x9a0e <writeFile+0x76c>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    99a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    99a4:	9d 85       	ldd	r25, Y+13	; 0x0d
    99a6:	ae 85       	ldd	r26, Y+14	; 0x0e
    99a8:	bf 85       	ldd	r27, Y+15	; 0x0f
    99aa:	8f 3f       	cpi	r24, 0xFF	; 255
    99ac:	0f ef       	ldi	r16, 0xFF	; 255
    99ae:	90 07       	cpc	r25, r16
    99b0:	0f ef       	ldi	r16, 0xFF	; 255
    99b2:	a0 07       	cpc	r26, r16
    99b4:	0f ef       	ldi	r16, 0xFF	; 255
    99b6:	b0 07       	cpc	r27, r16
    99b8:	41 f5       	brne	.+80     	; 0x9a0a <writeFile+0x768>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    99ba:	88 89       	ldd	r24, Y+16	; 0x10
    99bc:	99 89       	ldd	r25, Y+17	; 0x11
    99be:	aa 89       	ldd	r26, Y+18	; 0x12
    99c0:	bb 89       	ldd	r27, Y+19	; 0x13
    99c2:	bc 01       	movw	r22, r24
    99c4:	cd 01       	movw	r24, r26
    99c6:	0e 94 24 4d 	call	0x9a48	; 0x9a48 <searchNextFreeCluster>
    99ca:	dc 01       	movw	r26, r24
    99cc:	cb 01       	movw	r24, r22
    99ce:	8c 87       	std	Y+12, r24	; 0x0c
    99d0:	9d 87       	std	Y+13, r25	; 0x0d
    99d2:	ae 87       	std	Y+14, r26	; 0x0e
    99d4:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    99d6:	88 89       	ldd	r24, Y+16	; 0x10
    99d8:	99 89       	ldd	r25, Y+17	; 0x11
    99da:	aa 89       	ldd	r26, Y+18	; 0x12
    99dc:	bb 89       	ldd	r27, Y+19	; 0x13
    99de:	0c 85       	ldd	r16, Y+12	; 0x0c
    99e0:	1d 85       	ldd	r17, Y+13	; 0x0d
    99e2:	2e 85       	ldd	r18, Y+14	; 0x0e
    99e4:	3f 85       	ldd	r19, Y+15	; 0x0f
    99e6:	bc 01       	movw	r22, r24
    99e8:	cd 01       	movw	r24, r26
    99ea:	41 e0       	ldi	r20, 0x01	; 1
    99ec:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    99f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    99f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    99f4:	ae 85       	ldd	r26, Y+14	; 0x0e
    99f6:	bf 85       	ldd	r27, Y+15	; 0x0f
    99f8:	bc 01       	movw	r22, r24
    99fa:	cd 01       	movw	r24, r26
    99fc:	41 e0       	ldi	r20, 0x01	; 1
    99fe:	0f ef       	ldi	r16, 0xFF	; 255
    9a00:	1f ef       	ldi	r17, 0xFF	; 255
    9a02:	98 01       	movw	r18, r16
    9a04:	0e 94 47 44 	call	0x888e	; 0x888e <getSetNextCluster>
    9a08:	02 c0       	rjmp	.+4      	; 0x9a0e <writeFile+0x76c>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    9a0a:	83 e0       	ldi	r24, 0x03	; 3
    9a0c:	13 c0       	rjmp	.+38     	; 0x9a34 <writeFile+0x792>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    9a0e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a10:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a12:	ae 85       	ldd	r26, Y+14	; 0x0e
    9a14:	bf 85       	ldd	r27, Y+15	; 0x0f
    9a16:	00 97       	sbiw	r24, 0x00	; 0
    9a18:	a1 05       	cpc	r26, r1
    9a1a:	b1 05       	cpc	r27, r1
    9a1c:	11 f4       	brne	.+4      	; 0x9a22 <writeFile+0x780>
	   return 4;
    9a1e:	84 e0       	ldi	r24, 0x04	; 4
    9a20:	09 c0       	rjmp	.+18     	; 0x9a34 <writeFile+0x792>
	}
   
   prevCluster = cluster;
    9a22:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a24:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a26:	ae 85       	ldd	r26, Y+14	; 0x0e
    9a28:	bf 85       	ldd	r27, Y+15	; 0x0f
    9a2a:	88 8b       	std	Y+16, r24	; 0x10
    9a2c:	99 8b       	std	Y+17, r25	; 0x11
    9a2e:	aa 8b       	std	Y+18, r26	; 0x12
    9a30:	bb 8b       	std	Y+19, r27	; 0x13
 }
    9a32:	d1 ce       	rjmp	.-606    	; 0x97d6 <writeFile+0x534>
 
 return 0;
}
    9a34:	e7 96       	adiw	r28, 0x37	; 55
    9a36:	cd bf       	out	0x3d, r28	; 61
    9a38:	de bf       	out	0x3e, r29	; 62
    9a3a:	df 91       	pop	r29
    9a3c:	cf 91       	pop	r28
    9a3e:	1f 91       	pop	r17
    9a40:	0f 91       	pop	r16
    9a42:	ff 90       	pop	r15
    9a44:	ef 90       	pop	r14
    9a46:	08 95       	ret

00009a48 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    9a48:	ef 92       	push	r14
    9a4a:	ff 92       	push	r15
    9a4c:	0f 93       	push	r16
    9a4e:	1f 93       	push	r17
    9a50:	cf 93       	push	r28
    9a52:	df 93       	push	r29
    9a54:	cd b7       	in	r28, 0x3d	; 61
    9a56:	de b7       	in	r29, 0x3e	; 62
    9a58:	2f 97       	sbiw	r28, 0x0f	; 15
    9a5a:	cd bf       	out	0x3d, r28	; 61
    9a5c:	de bf       	out	0x3e, r29	; 62
    9a5e:	6c 87       	std	Y+12, r22	; 0x0c
    9a60:	7d 87       	std	Y+13, r23	; 0x0d
    9a62:	8e 87       	std	Y+14, r24	; 0x0e
    9a64:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    9a66:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a68:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a6a:	ae 85       	ldd	r26, Y+14	; 0x0e
    9a6c:	bf 85       	ldd	r27, Y+15	; 0x0f
    9a6e:	80 78       	andi	r24, 0x80	; 128
    9a70:	8c 87       	std	Y+12, r24	; 0x0c
    9a72:	9d 87       	std	Y+13, r25	; 0x0d
    9a74:	ae 87       	std	Y+14, r26	; 0x0e
    9a76:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9a78:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a7c:	ae 85       	ldd	r26, Y+14	; 0x0e
    9a7e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9a80:	89 83       	std	Y+1, r24	; 0x01
    9a82:	9a 83       	std	Y+2, r25	; 0x02
    9a84:	ab 83       	std	Y+3, r26	; 0x03
    9a86:	bc 83       	std	Y+4, r27	; 0x04
    9a88:	7a c0       	rjmp	.+244    	; 0x9b7e <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9a8a:	80 91 7b 50 	lds	r24, 0x507B
    9a8e:	90 91 7c 50 	lds	r25, 0x507C
    9a92:	9c 01       	movw	r18, r24
    9a94:	40 e0       	ldi	r20, 0x00	; 0
    9a96:	50 e0       	ldi	r21, 0x00	; 0
    9a98:	80 91 75 50 	lds	r24, 0x5075
    9a9c:	90 91 76 50 	lds	r25, 0x5076
    9aa0:	a0 91 77 50 	lds	r26, 0x5077
    9aa4:	b0 91 78 50 	lds	r27, 0x5078
    9aa8:	79 01       	movw	r14, r18
    9aaa:	8a 01       	movw	r16, r20
    9aac:	e8 0e       	add	r14, r24
    9aae:	f9 1e       	adc	r15, r25
    9ab0:	0a 1f       	adc	r16, r26
    9ab2:	1b 1f       	adc	r17, r27
    9ab4:	89 81       	ldd	r24, Y+1	; 0x01
    9ab6:	9a 81       	ldd	r25, Y+2	; 0x02
    9ab8:	ab 81       	ldd	r26, Y+3	; 0x03
    9aba:	bc 81       	ldd	r27, Y+4	; 0x04
    9abc:	88 0f       	add	r24, r24
    9abe:	99 1f       	adc	r25, r25
    9ac0:	aa 1f       	adc	r26, r26
    9ac2:	bb 1f       	adc	r27, r27
    9ac4:	88 0f       	add	r24, r24
    9ac6:	99 1f       	adc	r25, r25
    9ac8:	aa 1f       	adc	r26, r26
    9aca:	bb 1f       	adc	r27, r27
    9acc:	20 91 4c 40 	lds	r18, 0x404C
    9ad0:	30 91 4d 40 	lds	r19, 0x404D
    9ad4:	99 01       	movw	r18, r18
    9ad6:	40 e0       	ldi	r20, 0x00	; 0
    9ad8:	50 e0       	ldi	r21, 0x00	; 0
    9ada:	bc 01       	movw	r22, r24
    9adc:	cd 01       	movw	r24, r26
    9ade:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    9ae2:	da 01       	movw	r26, r20
    9ae4:	c9 01       	movw	r24, r18
    9ae6:	8e 0d       	add	r24, r14
    9ae8:	9f 1d       	adc	r25, r15
    9aea:	a0 1f       	adc	r26, r16
    9aec:	b1 1f       	adc	r27, r17
    9aee:	8e 83       	std	Y+6, r24	; 0x06
    9af0:	9f 83       	std	Y+7, r25	; 0x07
    9af2:	a8 87       	std	Y+8, r26	; 0x08
    9af4:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    9af6:	8e 81       	ldd	r24, Y+6	; 0x06
    9af8:	9f 81       	ldd	r25, Y+7	; 0x07
    9afa:	a8 85       	ldd	r26, Y+8	; 0x08
    9afc:	b9 85       	ldd	r27, Y+9	; 0x09
    9afe:	2e ec       	ldi	r18, 0xCE	; 206
    9b00:	31 e2       	ldi	r19, 0x21	; 33
    9b02:	bc 01       	movw	r22, r24
    9b04:	cd 01       	movw	r24, r26
    9b06:	a9 01       	movw	r20, r18
    9b08:	0e 94 2a 52 	call	0xa454	; 0xa454 <SD_read_block>
      for(i=0; i<128; i++)
    9b0c:	1d 82       	std	Y+5, r1	; 0x05
    9b0e:	28 c0       	rjmp	.+80     	; 0x9b60 <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    9b10:	8d 81       	ldd	r24, Y+5	; 0x05
    9b12:	88 2f       	mov	r24, r24
    9b14:	90 e0       	ldi	r25, 0x00	; 0
    9b16:	88 0f       	add	r24, r24
    9b18:	99 1f       	adc	r25, r25
    9b1a:	88 0f       	add	r24, r24
    9b1c:	99 1f       	adc	r25, r25
    9b1e:	82 53       	subi	r24, 0x32	; 50
    9b20:	9e 4d       	sbci	r25, 0xDE	; 222
    9b22:	8a 87       	std	Y+10, r24	; 0x0a
    9b24:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    9b26:	8a 85       	ldd	r24, Y+10	; 0x0a
    9b28:	9b 85       	ldd	r25, Y+11	; 0x0b
    9b2a:	fc 01       	movw	r30, r24
    9b2c:	80 81       	ld	r24, Z
    9b2e:	91 81       	ldd	r25, Z+1	; 0x01
    9b30:	a2 81       	ldd	r26, Z+2	; 0x02
    9b32:	b3 81       	ldd	r27, Z+3	; 0x03
    9b34:	bf 70       	andi	r27, 0x0F	; 15
    9b36:	00 97       	sbiw	r24, 0x00	; 0
    9b38:	a1 05       	cpc	r26, r1
    9b3a:	b1 05       	cpc	r27, r1
    9b3c:	71 f4       	brne	.+28     	; 0x9b5a <searchNextFreeCluster+0x112>
            return(cluster+i);
    9b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    9b40:	28 2f       	mov	r18, r24
    9b42:	30 e0       	ldi	r19, 0x00	; 0
    9b44:	40 e0       	ldi	r20, 0x00	; 0
    9b46:	50 e0       	ldi	r21, 0x00	; 0
    9b48:	89 81       	ldd	r24, Y+1	; 0x01
    9b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    9b4c:	ab 81       	ldd	r26, Y+3	; 0x03
    9b4e:	bc 81       	ldd	r27, Y+4	; 0x04
    9b50:	82 0f       	add	r24, r18
    9b52:	93 1f       	adc	r25, r19
    9b54:	a4 1f       	adc	r26, r20
    9b56:	b5 1f       	adc	r27, r21
    9b58:	27 c0       	rjmp	.+78     	; 0x9ba8 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    9b5a:	8d 81       	ldd	r24, Y+5	; 0x05
    9b5c:	8f 5f       	subi	r24, 0xFF	; 255
    9b5e:	8d 83       	std	Y+5, r24	; 0x05
    9b60:	8d 81       	ldd	r24, Y+5	; 0x05
    9b62:	88 23       	and	r24, r24
    9b64:	ac f6       	brge	.-86     	; 0x9b10 <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9b66:	89 81       	ldd	r24, Y+1	; 0x01
    9b68:	9a 81       	ldd	r25, Y+2	; 0x02
    9b6a:	ab 81       	ldd	r26, Y+3	; 0x03
    9b6c:	bc 81       	ldd	r27, Y+4	; 0x04
    9b6e:	80 58       	subi	r24, 0x80	; 128
    9b70:	9f 4f       	sbci	r25, 0xFF	; 255
    9b72:	af 4f       	sbci	r26, 0xFF	; 255
    9b74:	bf 4f       	sbci	r27, 0xFF	; 255
    9b76:	89 83       	std	Y+1, r24	; 0x01
    9b78:	9a 83       	std	Y+2, r25	; 0x02
    9b7a:	ab 83       	std	Y+3, r26	; 0x03
    9b7c:	bc 83       	std	Y+4, r27	; 0x04
    9b7e:	80 91 51 40 	lds	r24, 0x4051
    9b82:	90 91 52 40 	lds	r25, 0x4052
    9b86:	a0 91 53 40 	lds	r26, 0x4053
    9b8a:	b0 91 54 40 	lds	r27, 0x4054
    9b8e:	29 81       	ldd	r18, Y+1	; 0x01
    9b90:	3a 81       	ldd	r19, Y+2	; 0x02
    9b92:	4b 81       	ldd	r20, Y+3	; 0x03
    9b94:	5c 81       	ldd	r21, Y+4	; 0x04
    9b96:	28 17       	cp	r18, r24
    9b98:	39 07       	cpc	r19, r25
    9b9a:	4a 07       	cpc	r20, r26
    9b9c:	5b 07       	cpc	r21, r27
    9b9e:	08 f4       	brcc	.+2      	; 0x9ba2 <searchNextFreeCluster+0x15a>
    9ba0:	74 cf       	rjmp	.-280    	; 0x9a8a <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    9ba2:	80 e0       	ldi	r24, 0x00	; 0
    9ba4:	90 e0       	ldi	r25, 0x00	; 0
    9ba6:	dc 01       	movw	r26, r24
}
    9ba8:	bc 01       	movw	r22, r24
    9baa:	cd 01       	movw	r24, r26
    9bac:	2f 96       	adiw	r28, 0x0f	; 15
    9bae:	cd bf       	out	0x3d, r28	; 61
    9bb0:	de bf       	out	0x3e, r29	; 62
    9bb2:	df 91       	pop	r29
    9bb4:	cf 91       	pop	r28
    9bb6:	1f 91       	pop	r17
    9bb8:	0f 91       	pop	r16
    9bba:	ff 90       	pop	r15
    9bbc:	ef 90       	pop	r14
    9bbe:	08 95       	ret

00009bc0 <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    9bc0:	cf 93       	push	r28
    9bc2:	df 93       	push	r29
    9bc4:	00 d0       	rcall	.+0      	; 0x9bc6 <deleteFile+0x6>
    9bc6:	cd b7       	in	r28, 0x3d	; 61
    9bc8:	de b7       	in	r29, 0x3e	; 62
    9bca:	8a 83       	std	Y+2, r24	; 0x02
    9bcc:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9bce:	8a 81       	ldd	r24, Y+2	; 0x02
    9bd0:	9b 81       	ldd	r25, Y+3	; 0x03
    9bd2:	0e 94 1b 48 	call	0x9036	; 0x9036 <convertFileName>
    9bd6:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9bd8:	89 81       	ldd	r24, Y+1	; 0x01
    9bda:	88 23       	and	r24, r24
    9bdc:	39 f4       	brne	.+14     	; 0x9bec <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9bde:	2b ea       	ldi	r18, 0xAB	; 171
    9be0:	30 e5       	ldi	r19, 0x50	; 80
    9be2:	82 e0       	ldi	r24, 0x02	; 2
    9be4:	b9 01       	movw	r22, r18
    9be6:	0e 94 a1 45 	call	0x8b42	; 0x8b42 <findFiles>
    9bea:	01 c0       	rjmp	.+2      	; 0x9bee <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9bec:	00 00       	nop

  findFiles (DELETE, Filename);
}
    9bee:	23 96       	adiw	r28, 0x03	; 3
    9bf0:	cd bf       	out	0x3d, r28	; 61
    9bf2:	de bf       	out	0x3e, r29	; 62
    9bf4:	df 91       	pop	r29
    9bf6:	cf 91       	pop	r28
    9bf8:	08 95       	ret

00009bfa <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9bfa:	ef 92       	push	r14
    9bfc:	ff 92       	push	r15
    9bfe:	0f 93       	push	r16
    9c00:	1f 93       	push	r17
    9c02:	cf 93       	push	r28
    9c04:	df 93       	push	r29
    9c06:	cd b7       	in	r28, 0x3d	; 61
    9c08:	de b7       	in	r29, 0x3e	; 62
    9c0a:	29 97       	sbiw	r28, 0x09	; 9
    9c0c:	cd bf       	out	0x3d, r28	; 61
    9c0e:	de bf       	out	0x3e, r29	; 62
    9c10:	8d 83       	std	Y+5, r24	; 0x05
    9c12:	4e 83       	std	Y+6, r20	; 0x06
    9c14:	5f 83       	std	Y+7, r21	; 0x07
    9c16:	68 87       	std	Y+8, r22	; 0x08
    9c18:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    9c1a:	8e 81       	ldd	r24, Y+6	; 0x06
    9c1c:	9f 81       	ldd	r25, Y+7	; 0x07
    9c1e:	a8 85       	ldd	r26, Y+8	; 0x08
    9c20:	b9 85       	ldd	r27, Y+9	; 0x09
    9c22:	91 70       	andi	r25, 0x01	; 1
    9c24:	a0 70       	andi	r26, 0x00	; 0
    9c26:	b0 70       	andi	r27, 0x00	; 0
    9c28:	00 97       	sbiw	r24, 0x00	; 0
    9c2a:	a1 05       	cpc	r26, r1
    9c2c:	b1 05       	cpc	r27, r1
    9c2e:	91 f4       	brne	.+36     	; 0x9c54 <freeMemoryUpdate+0x5a>
    9c30:	8e 81       	ldd	r24, Y+6	; 0x06
    9c32:	9f 81       	ldd	r25, Y+7	; 0x07
    9c34:	a8 85       	ldd	r26, Y+8	; 0x08
    9c36:	b9 85       	ldd	r27, Y+9	; 0x09
    9c38:	07 2e       	mov	r0, r23
    9c3a:	79 e0       	ldi	r23, 0x09	; 9
    9c3c:	b6 95       	lsr	r27
    9c3e:	a7 95       	ror	r26
    9c40:	97 95       	ror	r25
    9c42:	87 95       	ror	r24
    9c44:	7a 95       	dec	r23
    9c46:	d1 f7       	brne	.-12     	; 0x9c3c <freeMemoryUpdate+0x42>
    9c48:	70 2d       	mov	r23, r0
    9c4a:	8e 83       	std	Y+6, r24	; 0x06
    9c4c:	9f 83       	std	Y+7, r25	; 0x07
    9c4e:	a8 87       	std	Y+8, r26	; 0x08
    9c50:	b9 87       	std	Y+9, r27	; 0x09
    9c52:	14 c0       	rjmp	.+40     	; 0x9c7c <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    9c54:	8e 81       	ldd	r24, Y+6	; 0x06
    9c56:	9f 81       	ldd	r25, Y+7	; 0x07
    9c58:	a8 85       	ldd	r26, Y+8	; 0x08
    9c5a:	b9 85       	ldd	r27, Y+9	; 0x09
    9c5c:	07 2e       	mov	r0, r23
    9c5e:	79 e0       	ldi	r23, 0x09	; 9
    9c60:	b6 95       	lsr	r27
    9c62:	a7 95       	ror	r26
    9c64:	97 95       	ror	r25
    9c66:	87 95       	ror	r24
    9c68:	7a 95       	dec	r23
    9c6a:	d1 f7       	brne	.-12     	; 0x9c60 <freeMemoryUpdate+0x66>
    9c6c:	70 2d       	mov	r23, r0
    9c6e:	01 96       	adiw	r24, 0x01	; 1
    9c70:	a1 1d       	adc	r26, r1
    9c72:	b1 1d       	adc	r27, r1
    9c74:	8e 83       	std	Y+6, r24	; 0x06
    9c76:	9f 83       	std	Y+7, r25	; 0x07
    9c78:	a8 87       	std	Y+8, r26	; 0x08
    9c7a:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9c7c:	8e 81       	ldd	r24, Y+6	; 0x06
    9c7e:	9f 81       	ldd	r25, Y+7	; 0x07
    9c80:	a8 85       	ldd	r26, Y+8	; 0x08
    9c82:	b9 85       	ldd	r27, Y+9	; 0x09
    9c84:	87 70       	andi	r24, 0x07	; 7
    9c86:	90 70       	andi	r25, 0x00	; 0
    9c88:	a0 70       	andi	r26, 0x00	; 0
    9c8a:	b0 70       	andi	r27, 0x00	; 0
    9c8c:	00 97       	sbiw	r24, 0x00	; 0
    9c8e:	a1 05       	cpc	r26, r1
    9c90:	b1 05       	cpc	r27, r1
    9c92:	89 f4       	brne	.+34     	; 0x9cb6 <freeMemoryUpdate+0xbc>
    9c94:	8e 81       	ldd	r24, Y+6	; 0x06
    9c96:	9f 81       	ldd	r25, Y+7	; 0x07
    9c98:	a8 85       	ldd	r26, Y+8	; 0x08
    9c9a:	b9 85       	ldd	r27, Y+9	; 0x09
    9c9c:	68 94       	set
    9c9e:	12 f8       	bld	r1, 2
    9ca0:	b6 95       	lsr	r27
    9ca2:	a7 95       	ror	r26
    9ca4:	97 95       	ror	r25
    9ca6:	87 95       	ror	r24
    9ca8:	16 94       	lsr	r1
    9caa:	d1 f7       	brne	.-12     	; 0x9ca0 <freeMemoryUpdate+0xa6>
    9cac:	8e 83       	std	Y+6, r24	; 0x06
    9cae:	9f 83       	std	Y+7, r25	; 0x07
    9cb0:	a8 87       	std	Y+8, r26	; 0x08
    9cb2:	b9 87       	std	Y+9, r27	; 0x09
    9cb4:	13 c0       	rjmp	.+38     	; 0x9cdc <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    9cb6:	8e 81       	ldd	r24, Y+6	; 0x06
    9cb8:	9f 81       	ldd	r25, Y+7	; 0x07
    9cba:	a8 85       	ldd	r26, Y+8	; 0x08
    9cbc:	b9 85       	ldd	r27, Y+9	; 0x09
    9cbe:	68 94       	set
    9cc0:	12 f8       	bld	r1, 2
    9cc2:	b6 95       	lsr	r27
    9cc4:	a7 95       	ror	r26
    9cc6:	97 95       	ror	r25
    9cc8:	87 95       	ror	r24
    9cca:	16 94       	lsr	r1
    9ccc:	d1 f7       	brne	.-12     	; 0x9cc2 <freeMemoryUpdate+0xc8>
    9cce:	01 96       	adiw	r24, 0x01	; 1
    9cd0:	a1 1d       	adc	r26, r1
    9cd2:	b1 1d       	adc	r27, r1
    9cd4:	8e 83       	std	Y+6, r24	; 0x06
    9cd6:	9f 83       	std	Y+7, r25	; 0x07
    9cd8:	a8 87       	std	Y+8, r26	; 0x08
    9cda:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9cdc:	80 91 bf 50 	lds	r24, 0x50BF
    9ce0:	88 23       	and	r24, r24
    9ce2:	e9 f1       	breq	.+122    	; 0x9d5e <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    9ce4:	81 e0       	ldi	r24, 0x01	; 1
    9ce6:	60 e0       	ldi	r22, 0x00	; 0
    9ce8:	20 e0       	ldi	r18, 0x00	; 0
    9cea:	30 e0       	ldi	r19, 0x00	; 0
    9cec:	a9 01       	movw	r20, r18
    9cee:	0e 94 f0 44 	call	0x89e0	; 0x89e0 <getSetFreeCluster>
    9cf2:	dc 01       	movw	r26, r24
    9cf4:	cb 01       	movw	r24, r22
    9cf6:	89 83       	std	Y+1, r24	; 0x01
    9cf8:	9a 83       	std	Y+2, r25	; 0x02
    9cfa:	ab 83       	std	Y+3, r26	; 0x03
    9cfc:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9cfe:	8d 81       	ldd	r24, Y+5	; 0x05
    9d00:	88 23       	and	r24, r24
    9d02:	89 f4       	brne	.+34     	; 0x9d26 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    9d04:	29 81       	ldd	r18, Y+1	; 0x01
    9d06:	3a 81       	ldd	r19, Y+2	; 0x02
    9d08:	4b 81       	ldd	r20, Y+3	; 0x03
    9d0a:	5c 81       	ldd	r21, Y+4	; 0x04
    9d0c:	8e 81       	ldd	r24, Y+6	; 0x06
    9d0e:	9f 81       	ldd	r25, Y+7	; 0x07
    9d10:	a8 85       	ldd	r26, Y+8	; 0x08
    9d12:	b9 85       	ldd	r27, Y+9	; 0x09
    9d14:	82 0f       	add	r24, r18
    9d16:	93 1f       	adc	r25, r19
    9d18:	a4 1f       	adc	r26, r20
    9d1a:	b5 1f       	adc	r27, r21
    9d1c:	89 83       	std	Y+1, r24	; 0x01
    9d1e:	9a 83       	std	Y+2, r25	; 0x02
    9d20:	ab 83       	std	Y+3, r26	; 0x03
    9d22:	bc 83       	std	Y+4, r27	; 0x04
    9d24:	14 c0       	rjmp	.+40     	; 0x9d4e <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    9d26:	29 81       	ldd	r18, Y+1	; 0x01
    9d28:	3a 81       	ldd	r19, Y+2	; 0x02
    9d2a:	4b 81       	ldd	r20, Y+3	; 0x03
    9d2c:	5c 81       	ldd	r21, Y+4	; 0x04
    9d2e:	8e 81       	ldd	r24, Y+6	; 0x06
    9d30:	9f 81       	ldd	r25, Y+7	; 0x07
    9d32:	a8 85       	ldd	r26, Y+8	; 0x08
    9d34:	b9 85       	ldd	r27, Y+9	; 0x09
    9d36:	79 01       	movw	r14, r18
    9d38:	8a 01       	movw	r16, r20
    9d3a:	e8 1a       	sub	r14, r24
    9d3c:	f9 0a       	sbc	r15, r25
    9d3e:	0a 0b       	sbc	r16, r26
    9d40:	1b 0b       	sbc	r17, r27
    9d42:	d8 01       	movw	r26, r16
    9d44:	c7 01       	movw	r24, r14
    9d46:	89 83       	std	Y+1, r24	; 0x01
    9d48:	9a 83       	std	Y+2, r25	; 0x02
    9d4a:	ab 83       	std	Y+3, r26	; 0x03
    9d4c:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9d4e:	29 81       	ldd	r18, Y+1	; 0x01
    9d50:	3a 81       	ldd	r19, Y+2	; 0x02
    9d52:	4b 81       	ldd	r20, Y+3	; 0x03
    9d54:	5c 81       	ldd	r21, Y+4	; 0x04
    9d56:	81 e0       	ldi	r24, 0x01	; 1
    9d58:	61 e0       	ldi	r22, 0x01	; 1
    9d5a:	0e 94 f0 44 	call	0x89e0	; 0x89e0 <getSetFreeCluster>
  }
}
    9d5e:	29 96       	adiw	r28, 0x09	; 9
    9d60:	cd bf       	out	0x3d, r28	; 61
    9d62:	de bf       	out	0x3e, r29	; 62
    9d64:	df 91       	pop	r29
    9d66:	cf 91       	pop	r28
    9d68:	1f 91       	pop	r17
    9d6a:	0f 91       	pop	r16
    9d6c:	ff 90       	pop	r15
    9d6e:	ef 90       	pop	r14
    9d70:	08 95       	ret

00009d72 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    9d72:	0f 93       	push	r16
    9d74:	1f 93       	push	r17
    9d76:	cf 93       	push	r28
    9d78:	df 93       	push	r29
    9d7a:	cd b7       	in	r28, 0x3d	; 61
    9d7c:	de b7       	in	r29, 0x3e	; 62
    9d7e:	a9 97       	sbiw	r28, 0x29	; 41
    9d80:	cd bf       	out	0x3d, r28	; 61
    9d82:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    9d84:	81 e0       	ldi	r24, 0x01	; 1
    9d86:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9d8a:	81 e0       	ldi	r24, 0x01	; 1
    9d8c:	0e 94 d8 37 	call	0x6fb0	; 0x6fb0 <Ext1Power>
    9d90:	80 e0       	ldi	r24, 0x00	; 0
    9d92:	90 e0       	ldi	r25, 0x00	; 0
    9d94:	a8 ec       	ldi	r26, 0xC8	; 200
    9d96:	b2 e4       	ldi	r27, 0x42	; 66
    9d98:	8e 87       	std	Y+14, r24	; 0x0e
    9d9a:	9f 87       	std	Y+15, r25	; 0x0f
    9d9c:	a8 8b       	std	Y+16, r26	; 0x10
    9d9e:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9da0:	6e 85       	ldd	r22, Y+14	; 0x0e
    9da2:	7f 85       	ldd	r23, Y+15	; 0x0f
    9da4:	88 89       	ldd	r24, Y+16	; 0x10
    9da6:	99 89       	ldd	r25, Y+17	; 0x11
    9da8:	20 e0       	ldi	r18, 0x00	; 0
    9daa:	30 e0       	ldi	r19, 0x00	; 0
    9dac:	4a ef       	ldi	r20, 0xFA	; 250
    9dae:	55 e4       	ldi	r21, 0x45	; 69
    9db0:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    9db4:	dc 01       	movw	r26, r24
    9db6:	cb 01       	movw	r24, r22
    9db8:	8a 8b       	std	Y+18, r24	; 0x12
    9dba:	9b 8b       	std	Y+19, r25	; 0x13
    9dbc:	ac 8b       	std	Y+20, r26	; 0x14
    9dbe:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9dc0:	11 e0       	ldi	r17, 0x01	; 1
    9dc2:	6a 89       	ldd	r22, Y+18	; 0x12
    9dc4:	7b 89       	ldd	r23, Y+19	; 0x13
    9dc6:	8c 89       	ldd	r24, Y+20	; 0x14
    9dc8:	9d 89       	ldd	r25, Y+21	; 0x15
    9dca:	20 e0       	ldi	r18, 0x00	; 0
    9dcc:	30 e0       	ldi	r19, 0x00	; 0
    9dce:	40 e8       	ldi	r20, 0x80	; 128
    9dd0:	5f e3       	ldi	r21, 0x3F	; 63
    9dd2:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    9dd6:	88 23       	and	r24, r24
    9dd8:	0c f0       	brlt	.+2      	; 0x9ddc <SD_init+0x6a>
    9dda:	10 e0       	ldi	r17, 0x00	; 0
    9ddc:	11 23       	and	r17, r17
    9dde:	29 f0       	breq	.+10     	; 0x9dea <SD_init+0x78>
		__ticks = 1;
    9de0:	81 e0       	ldi	r24, 0x01	; 1
    9de2:	90 e0       	ldi	r25, 0x00	; 0
    9de4:	8e 8b       	std	Y+22, r24	; 0x16
    9de6:	9f 8b       	std	Y+23, r25	; 0x17
    9de8:	46 c0       	rjmp	.+140    	; 0x9e76 <SD_init+0x104>
	else if (__tmp > 65535)
    9dea:	11 e0       	ldi	r17, 0x01	; 1
    9dec:	6a 89       	ldd	r22, Y+18	; 0x12
    9dee:	7b 89       	ldd	r23, Y+19	; 0x13
    9df0:	8c 89       	ldd	r24, Y+20	; 0x14
    9df2:	9d 89       	ldd	r25, Y+21	; 0x15
    9df4:	20 e0       	ldi	r18, 0x00	; 0
    9df6:	3f ef       	ldi	r19, 0xFF	; 255
    9df8:	4f e7       	ldi	r20, 0x7F	; 127
    9dfa:	57 e4       	ldi	r21, 0x47	; 71
    9dfc:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    9e00:	18 16       	cp	r1, r24
    9e02:	0c f0       	brlt	.+2      	; 0x9e06 <SD_init+0x94>
    9e04:	10 e0       	ldi	r17, 0x00	; 0
    9e06:	11 23       	and	r17, r17
    9e08:	61 f1       	breq	.+88     	; 0x9e62 <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9e0a:	6e 85       	ldd	r22, Y+14	; 0x0e
    9e0c:	7f 85       	ldd	r23, Y+15	; 0x0f
    9e0e:	88 89       	ldd	r24, Y+16	; 0x10
    9e10:	99 89       	ldd	r25, Y+17	; 0x11
    9e12:	20 e0       	ldi	r18, 0x00	; 0
    9e14:	30 e0       	ldi	r19, 0x00	; 0
    9e16:	40 e2       	ldi	r20, 0x20	; 32
    9e18:	51 e4       	ldi	r21, 0x41	; 65
    9e1a:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    9e1e:	dc 01       	movw	r26, r24
    9e20:	cb 01       	movw	r24, r22
    9e22:	bc 01       	movw	r22, r24
    9e24:	cd 01       	movw	r24, r26
    9e26:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    9e2a:	dc 01       	movw	r26, r24
    9e2c:	cb 01       	movw	r24, r22
    9e2e:	8e 8b       	std	Y+22, r24	; 0x16
    9e30:	9f 8b       	std	Y+23, r25	; 0x17
    9e32:	12 c0       	rjmp	.+36     	; 0x9e58 <SD_init+0xe6>
    9e34:	80 e2       	ldi	r24, 0x20	; 32
    9e36:	93 e0       	ldi	r25, 0x03	; 3
    9e38:	88 8f       	std	Y+24, r24	; 0x18
    9e3a:	99 8f       	std	Y+25, r25	; 0x19
    9e3c:	88 8d       	ldd	r24, Y+24	; 0x18
    9e3e:	99 8d       	ldd	r25, Y+25	; 0x19
    9e40:	8c 01       	movw	r16, r24
    9e42:	c8 01       	movw	r24, r16
    9e44:	01 97       	sbiw	r24, 0x01	; 1
    9e46:	f1 f7       	brne	.-4      	; 0x9e44 <SD_init+0xd2>
    9e48:	8c 01       	movw	r16, r24
    9e4a:	08 8f       	std	Y+24, r16	; 0x18
    9e4c:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9e4e:	8e 89       	ldd	r24, Y+22	; 0x16
    9e50:	9f 89       	ldd	r25, Y+23	; 0x17
    9e52:	01 97       	sbiw	r24, 0x01	; 1
    9e54:	8e 8b       	std	Y+22, r24	; 0x16
    9e56:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9e58:	8e 89       	ldd	r24, Y+22	; 0x16
    9e5a:	9f 89       	ldd	r25, Y+23	; 0x17
    9e5c:	00 97       	sbiw	r24, 0x00	; 0
    9e5e:	51 f7       	brne	.-44     	; 0x9e34 <SD_init+0xc2>
    9e60:	17 c0       	rjmp	.+46     	; 0x9e90 <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9e62:	6a 89       	ldd	r22, Y+18	; 0x12
    9e64:	7b 89       	ldd	r23, Y+19	; 0x13
    9e66:	8c 89       	ldd	r24, Y+20	; 0x14
    9e68:	9d 89       	ldd	r25, Y+21	; 0x15
    9e6a:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    9e6e:	dc 01       	movw	r26, r24
    9e70:	cb 01       	movw	r24, r22
    9e72:	8e 8b       	std	Y+22, r24	; 0x16
    9e74:	9f 8b       	std	Y+23, r25	; 0x17
    9e76:	8e 89       	ldd	r24, Y+22	; 0x16
    9e78:	9f 89       	ldd	r25, Y+23	; 0x17
    9e7a:	8a 8f       	std	Y+26, r24	; 0x1a
    9e7c:	9b 8f       	std	Y+27, r25	; 0x1b
    9e7e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9e80:	9b 8d       	ldd	r25, Y+27	; 0x1b
    9e82:	8c 01       	movw	r16, r24
    9e84:	f8 01       	movw	r30, r16
    9e86:	31 97       	sbiw	r30, 0x01	; 1
    9e88:	f1 f7       	brne	.-4      	; 0x9e86 <SD_init+0x114>
    9e8a:	8f 01       	movw	r16, r30
    9e8c:	0a 8f       	std	Y+26, r16	; 0x1a
    9e8e:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9e90:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    9e92:	88 e0       	ldi	r24, 0x08	; 8
    9e94:	60 e0       	ldi	r22, 0x00	; 0
    9e96:	0e 94 42 36 	call	0x6c84	; 0x6c84 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9e9a:	88 e0       	ldi	r24, 0x08	; 8
    9e9c:	60 e0       	ldi	r22, 0x00	; 0
    9e9e:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9ea2:	80 e0       	ldi	r24, 0x00	; 0
    9ea4:	63 e0       	ldi	r22, 0x03	; 3
    9ea6:	0e 94 06 3b 	call	0x760c	; 0x760c <SPIInit2>
	SPICS(TRUE);
    9eaa:	81 e0       	ldi	r24, 0x01	; 1
    9eac:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9eb0:	1a 82       	std	Y+2, r1	; 0x02
    9eb2:	1b 82       	std	Y+3, r1	; 0x03
    9eb4:	17 c0       	rjmp	.+46     	; 0x9ee4 <SD_init+0x172>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9eb6:	80 ec       	ldi	r24, 0xC0	; 192
    9eb8:	98 e0       	ldi	r25, 0x08	; 8
    9eba:	2f ef       	ldi	r18, 0xFF	; 255
    9ebc:	fc 01       	movw	r30, r24
    9ebe:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9ec0:	00 00       	nop
    9ec2:	80 ec       	ldi	r24, 0xC0	; 192
    9ec4:	98 e0       	ldi	r25, 0x08	; 8
    9ec6:	fc 01       	movw	r30, r24
    9ec8:	82 81       	ldd	r24, Z+2	; 0x02
    9eca:	88 23       	and	r24, r24
    9ecc:	d4 f7       	brge	.-12     	; 0x9ec2 <SD_init+0x150>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    9ece:	80 ec       	ldi	r24, 0xC0	; 192
    9ed0:	98 e0       	ldi	r25, 0x08	; 8
    9ed2:	fc 01       	movw	r30, r24
    9ed4:	83 81       	ldd	r24, Z+3	; 0x03
    9ed6:	80 93 aa 50 	sts	0x50AA, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9eda:	8a 81       	ldd	r24, Y+2	; 0x02
    9edc:	9b 81       	ldd	r25, Y+3	; 0x03
    9ede:	01 96       	adiw	r24, 0x01	; 1
    9ee0:	8a 83       	std	Y+2, r24	; 0x02
    9ee2:	9b 83       	std	Y+3, r25	; 0x03
    9ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    9ee6:	9b 81       	ldd	r25, Y+3	; 0x03
    9ee8:	8a 30       	cpi	r24, 0x0A	; 10
    9eea:	91 05       	cpc	r25, r1
    9eec:	24 f3       	brlt	.-56     	; 0x9eb6 <SD_init+0x144>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    9eee:	80 e0       	ldi	r24, 0x00	; 0
    9ef0:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    9ef4:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9ef8:	88 e0       	ldi	r24, 0x08	; 8
    9efa:	60 e0       	ldi	r22, 0x00	; 0
    9efc:	0e 94 71 37 	call	0x6ee2	; 0x6ee2 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9f00:	80 e0       	ldi	r24, 0x00	; 0
    9f02:	63 e0       	ldi	r22, 0x03	; 3
    9f04:	0e 94 06 3b 	call	0x760c	; 0x760c <SPIInit2>
	SPICS(TRUE);
    9f08:	81 e0       	ldi	r24, 0x01	; 1
    9f0a:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9f0e:	1c 82       	std	Y+4, r1	; 0x04
    9f10:	1d 82       	std	Y+5, r1	; 0x05
    9f12:	0d c0       	rjmp	.+26     	; 0x9f2e <SD_init+0x1bc>
		if (i >= 10) {												//try command 10 times before timing out
    9f14:	8c 81       	ldd	r24, Y+4	; 0x04
    9f16:	9d 81       	ldd	r25, Y+5	; 0x05
    9f18:	8a 30       	cpi	r24, 0x0A	; 10
    9f1a:	91 05       	cpc	r25, r1
    9f1c:	1c f0       	brlt	.+6      	; 0x9f24 <SD_init+0x1b2>
			//there was no response to the first command
			errorCode = 1;
    9f1e:	81 e0       	ldi	r24, 0x01	; 1
    9f20:	89 83       	std	Y+1, r24	; 0x01
			break;
    9f22:	10 c0       	rjmp	.+32     	; 0x9f44 <SD_init+0x1d2>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9f24:	8c 81       	ldd	r24, Y+4	; 0x04
    9f26:	9d 81       	ldd	r25, Y+5	; 0x05
    9f28:	01 96       	adiw	r24, 0x01	; 1
    9f2a:	8c 83       	std	Y+4, r24	; 0x04
    9f2c:	9d 83       	std	Y+5, r25	; 0x05
    9f2e:	80 e0       	ldi	r24, 0x00	; 0
    9f30:	40 e0       	ldi	r20, 0x00	; 0
    9f32:	50 e0       	ldi	r21, 0x00	; 0
    9f34:	ba 01       	movw	r22, r20
    9f36:	25 e9       	ldi	r18, 0x95	; 149
    9f38:	08 e0       	ldi	r16, 0x08	; 8
    9f3a:	10 e0       	ldi	r17, 0x00	; 0
    9f3c:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
    9f40:	81 30       	cpi	r24, 0x01	; 1
    9f42:	41 f7       	brne	.-48     	; 0x9f14 <SD_init+0x1a2>
    9f44:	80 e0       	ldi	r24, 0x00	; 0
    9f46:	90 e0       	ldi	r25, 0x00	; 0
    9f48:	a8 ec       	ldi	r26, 0xC8	; 200
    9f4a:	b2 e4       	ldi	r27, 0x42	; 66
    9f4c:	8c 8f       	std	Y+28, r24	; 0x1c
    9f4e:	9d 8f       	std	Y+29, r25	; 0x1d
    9f50:	ae 8f       	std	Y+30, r26	; 0x1e
    9f52:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9f54:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9f56:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9f58:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9f5a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9f5c:	20 e0       	ldi	r18, 0x00	; 0
    9f5e:	30 e0       	ldi	r19, 0x00	; 0
    9f60:	4a ef       	ldi	r20, 0xFA	; 250
    9f62:	55 e4       	ldi	r21, 0x45	; 69
    9f64:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    9f68:	dc 01       	movw	r26, r24
    9f6a:	cb 01       	movw	r24, r22
    9f6c:	88 a3       	lds	r24, 0x58
    9f6e:	99 a3       	lds	r25, 0x59
    9f70:	aa a3       	lds	r26, 0x5a
    9f72:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    9f74:	11 e0       	ldi	r17, 0x01	; 1
    9f76:	68 a1       	lds	r22, 0x48
    9f78:	79 a1       	lds	r23, 0x49
    9f7a:	8a a1       	lds	r24, 0x4a
    9f7c:	9b a1       	lds	r25, 0x4b
    9f7e:	20 e0       	ldi	r18, 0x00	; 0
    9f80:	30 e0       	ldi	r19, 0x00	; 0
    9f82:	40 e8       	ldi	r20, 0x80	; 128
    9f84:	5f e3       	ldi	r21, 0x3F	; 63
    9f86:	0e 94 9c 5e 	call	0xbd38	; 0xbd38 <__cmpsf2>
    9f8a:	88 23       	and	r24, r24
    9f8c:	0c f0       	brlt	.+2      	; 0x9f90 <SD_init+0x21e>
    9f8e:	10 e0       	ldi	r17, 0x00	; 0
    9f90:	11 23       	and	r17, r17
    9f92:	29 f0       	breq	.+10     	; 0x9f9e <SD_init+0x22c>
		__ticks = 1;
    9f94:	81 e0       	ldi	r24, 0x01	; 1
    9f96:	90 e0       	ldi	r25, 0x00	; 0
    9f98:	8c a3       	lds	r24, 0x5c
    9f9a:	9d a3       	lds	r25, 0x5d
    9f9c:	46 c0       	rjmp	.+140    	; 0xa02a <SD_init+0x2b8>
	else if (__tmp > 65535)
    9f9e:	11 e0       	ldi	r17, 0x01	; 1
    9fa0:	68 a1       	lds	r22, 0x48
    9fa2:	79 a1       	lds	r23, 0x49
    9fa4:	8a a1       	lds	r24, 0x4a
    9fa6:	9b a1       	lds	r25, 0x4b
    9fa8:	20 e0       	ldi	r18, 0x00	; 0
    9faa:	3f ef       	ldi	r19, 0xFF	; 255
    9fac:	4f e7       	ldi	r20, 0x7F	; 127
    9fae:	57 e4       	ldi	r21, 0x47	; 71
    9fb0:	0e 94 e6 5f 	call	0xbfcc	; 0xbfcc <__gesf2>
    9fb4:	18 16       	cp	r1, r24
    9fb6:	0c f0       	brlt	.+2      	; 0x9fba <SD_init+0x248>
    9fb8:	10 e0       	ldi	r17, 0x00	; 0
    9fba:	11 23       	and	r17, r17
    9fbc:	61 f1       	breq	.+88     	; 0xa016 <SD_init+0x2a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9fbe:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9fc0:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9fc2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9fc4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9fc6:	20 e0       	ldi	r18, 0x00	; 0
    9fc8:	30 e0       	ldi	r19, 0x00	; 0
    9fca:	40 e2       	ldi	r20, 0x20	; 32
    9fcc:	51 e4       	ldi	r21, 0x41	; 65
    9fce:	0e 94 ea 5f 	call	0xbfd4	; 0xbfd4 <__mulsf3>
    9fd2:	dc 01       	movw	r26, r24
    9fd4:	cb 01       	movw	r24, r22
    9fd6:	bc 01       	movw	r22, r24
    9fd8:	cd 01       	movw	r24, r26
    9fda:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    9fde:	dc 01       	movw	r26, r24
    9fe0:	cb 01       	movw	r24, r22
    9fe2:	8c a3       	lds	r24, 0x5c
    9fe4:	9d a3       	lds	r25, 0x5d
    9fe6:	12 c0       	rjmp	.+36     	; 0xa00c <SD_init+0x29a>
    9fe8:	80 e2       	ldi	r24, 0x20	; 32
    9fea:	93 e0       	ldi	r25, 0x03	; 3
    9fec:	8e a3       	lds	r24, 0x5e
    9fee:	9f a3       	lds	r25, 0x5f
    9ff0:	8e a1       	lds	r24, 0x4e
    9ff2:	9f a1       	lds	r25, 0x4f
    9ff4:	8c 01       	movw	r16, r24
    9ff6:	c8 01       	movw	r24, r16
    9ff8:	01 97       	sbiw	r24, 0x01	; 1
    9ffa:	f1 f7       	brne	.-4      	; 0x9ff8 <SD_init+0x286>
    9ffc:	8c 01       	movw	r16, r24
    9ffe:	0e a3       	lds	r16, 0x5e
    a000:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    a002:	8c a1       	lds	r24, 0x4c
    a004:	9d a1       	lds	r25, 0x4d
    a006:	01 97       	sbiw	r24, 0x01	; 1
    a008:	8c a3       	lds	r24, 0x5c
    a00a:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    a00c:	8c a1       	lds	r24, 0x4c
    a00e:	9d a1       	lds	r25, 0x4d
    a010:	00 97       	sbiw	r24, 0x00	; 0
    a012:	51 f7       	brne	.-44     	; 0x9fe8 <SD_init+0x276>
    a014:	17 c0       	rjmp	.+46     	; 0xa044 <SD_init+0x2d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    a016:	68 a1       	lds	r22, 0x48
    a018:	79 a1       	lds	r23, 0x49
    a01a:	8a a1       	lds	r24, 0x4a
    a01c:	9b a1       	lds	r25, 0x4b
    a01e:	0e 94 08 5f 	call	0xbe10	; 0xbe10 <__fixunssfsi>
    a022:	dc 01       	movw	r26, r24
    a024:	cb 01       	movw	r24, r22
    a026:	8c a3       	lds	r24, 0x5c
    a028:	9d a3       	lds	r25, 0x5d
    a02a:	8c a1       	lds	r24, 0x4c
    a02c:	9d a1       	lds	r25, 0x4d
    a02e:	88 a7       	lds	r24, 0x78
    a030:	99 a7       	lds	r25, 0x79
    a032:	88 a5       	lds	r24, 0x68
    a034:	99 a5       	lds	r25, 0x69
    a036:	8c 01       	movw	r16, r24
    a038:	f8 01       	movw	r30, r16
    a03a:	31 97       	sbiw	r30, 0x01	; 1
    a03c:	f1 f7       	brne	.-4      	; 0xa03a <SD_init+0x2c8>
    a03e:	8f 01       	movw	r16, r30
    a040:	08 a7       	lds	r16, 0x78
    a042:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    a044:	1e 82       	std	Y+6, r1	; 0x06
    a046:	1f 82       	std	Y+7, r1	; 0x07
    a048:	0d c0       	rjmp	.+26     	; 0xa064 <SD_init+0x2f2>
		if (i >= 10) {
    a04a:	8e 81       	ldd	r24, Y+6	; 0x06
    a04c:	9f 81       	ldd	r25, Y+7	; 0x07
    a04e:	8a 30       	cpi	r24, 0x0A	; 10
    a050:	91 05       	cpc	r25, r1
    a052:	1c f0       	brlt	.+6      	; 0xa05a <SD_init+0x2e8>
			//there was no response to the command
			errorCode = 1;
    a054:	81 e0       	ldi	r24, 0x01	; 1
    a056:	89 83       	std	Y+1, r24	; 0x01
			break;
    a058:	11 c0       	rjmp	.+34     	; 0xa07c <SD_init+0x30a>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    a05a:	8e 81       	ldd	r24, Y+6	; 0x06
    a05c:	9f 81       	ldd	r25, Y+7	; 0x07
    a05e:	01 96       	adiw	r24, 0x01	; 1
    a060:	8e 83       	std	Y+6, r24	; 0x06
    a062:	9f 83       	std	Y+7, r25	; 0x07
    a064:	88 e0       	ldi	r24, 0x08	; 8
    a066:	4a ea       	ldi	r20, 0xAA	; 170
    a068:	51 e0       	ldi	r21, 0x01	; 1
    a06a:	60 e0       	ldi	r22, 0x00	; 0
    a06c:	70 e0       	ldi	r23, 0x00	; 0
    a06e:	27 e8       	ldi	r18, 0x87	; 135
    a070:	08 e0       	ldi	r16, 0x08	; 8
    a072:	10 e0       	ldi	r17, 0x00	; 0
    a074:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
    a078:	81 30       	cpi	r24, 0x01	; 1
    a07a:	39 f7       	brne	.-50     	; 0xa04a <SD_init+0x2d8>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    a07c:	18 86       	std	Y+8, r1	; 0x08
    a07e:	19 86       	std	Y+9, r1	; 0x09
    a080:	13 c0       	rjmp	.+38     	; 0xa0a8 <SD_init+0x336>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    a082:	88 85       	ldd	r24, Y+8	; 0x08
    a084:	99 85       	ldd	r25, Y+9	; 0x09
    a086:	8c 01       	movw	r16, r24
    a088:	0e 5f       	subi	r16, 0xFE	; 254
    a08a:	1f 4f       	sbci	r17, 0xFF	; 255
    a08c:	8f ef       	ldi	r24, 0xFF	; 255
    a08e:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a092:	28 2f       	mov	r18, r24
    a094:	c8 01       	movw	r24, r16
    a096:	82 56       	subi	r24, 0x62	; 98
    a098:	9f 4a       	sbci	r25, 0xAF	; 175
    a09a:	fc 01       	movw	r30, r24
    a09c:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    a09e:	88 85       	ldd	r24, Y+8	; 0x08
    a0a0:	99 85       	ldd	r25, Y+9	; 0x09
    a0a2:	01 96       	adiw	r24, 0x01	; 1
    a0a4:	88 87       	std	Y+8, r24	; 0x08
    a0a6:	99 87       	std	Y+9, r25	; 0x09
    a0a8:	88 85       	ldd	r24, Y+8	; 0x08
    a0aa:	99 85       	ldd	r25, Y+9	; 0x09
    a0ac:	84 30       	cpi	r24, 0x04	; 4
    a0ae:	91 05       	cpc	r25, r1
    a0b0:	44 f3       	brlt	.-48     	; 0xa082 <SD_init+0x310>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    a0b2:	80 91 a2 50 	lds	r24, 0x50A2
    a0b6:	81 30       	cpi	r24, 0x01	; 1
    a0b8:	21 f4       	brne	.+8      	; 0xa0c2 <SD_init+0x350>
    a0ba:	80 91 a3 50 	lds	r24, 0x50A3
    a0be:	8a 3a       	cpi	r24, 0xAA	; 170
    a0c0:	11 f0       	breq	.+4      	; 0xa0c6 <SD_init+0x354>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    a0c2:	81 e0       	ldi	r24, 0x01	; 1
    a0c4:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    a0c6:	87 e3       	ldi	r24, 0x37	; 55
    a0c8:	40 e0       	ldi	r20, 0x00	; 0
    a0ca:	50 e0       	ldi	r21, 0x00	; 0
    a0cc:	ba 01       	movw	r22, r20
    a0ce:	2f ef       	ldi	r18, 0xFF	; 255
    a0d0:	08 e0       	ldi	r16, 0x08	; 8
    a0d2:	10 e0       	ldi	r17, 0x00	; 0
    a0d4:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    a0d8:	81 e0       	ldi	r24, 0x01	; 1
    a0da:	40 e0       	ldi	r20, 0x00	; 0
    a0dc:	50 e0       	ldi	r21, 0x00	; 0
    a0de:	60 e0       	ldi	r22, 0x00	; 0
    a0e0:	70 e4       	ldi	r23, 0x40	; 64
    a0e2:	2f ef       	ldi	r18, 0xFF	; 255
    a0e4:	08 e0       	ldi	r16, 0x08	; 8
    a0e6:	10 e0       	ldi	r17, 0x00	; 0
    a0e8:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
	} while(Buffer[1]!= 0x00);
    a0ec:	80 91 9f 50 	lds	r24, 0x509F
    a0f0:	88 23       	and	r24, r24
    a0f2:	49 f7       	brne	.-46     	; 0xa0c6 <SD_init+0x354>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    a0f4:	1a 86       	std	Y+10, r1	; 0x0a
    a0f6:	1b 86       	std	Y+11, r1	; 0x0b
    a0f8:	0d c0       	rjmp	.+26     	; 0xa114 <SD_init+0x3a2>
		if (i >= 10) {
    a0fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    a0fc:	9b 85       	ldd	r25, Y+11	; 0x0b
    a0fe:	8a 30       	cpi	r24, 0x0A	; 10
    a100:	91 05       	cpc	r25, r1
    a102:	1c f0       	brlt	.+6      	; 0xa10a <SD_init+0x398>
			//there was no response to the command
			errorCode = 1;
    a104:	81 e0       	ldi	r24, 0x01	; 1
    a106:	89 83       	std	Y+1, r24	; 0x01
			break;
    a108:	10 c0       	rjmp	.+32     	; 0xa12a <SD_init+0x3b8>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    a10a:	8a 85       	ldd	r24, Y+10	; 0x0a
    a10c:	9b 85       	ldd	r25, Y+11	; 0x0b
    a10e:	01 96       	adiw	r24, 0x01	; 1
    a110:	8a 87       	std	Y+10, r24	; 0x0a
    a112:	9b 87       	std	Y+11, r25	; 0x0b
    a114:	8a e3       	ldi	r24, 0x3A	; 58
    a116:	40 e0       	ldi	r20, 0x00	; 0
    a118:	50 e0       	ldi	r21, 0x00	; 0
    a11a:	ba 01       	movw	r22, r20
    a11c:	2f ef       	ldi	r18, 0xFF	; 255
    a11e:	08 e0       	ldi	r16, 0x08	; 8
    a120:	10 e0       	ldi	r17, 0x00	; 0
    a122:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
    a126:	88 23       	and	r24, r24
    a128:	41 f7       	brne	.-48     	; 0xa0fa <SD_init+0x388>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    a12a:	1c 86       	std	Y+12, r1	; 0x0c
    a12c:	1d 86       	std	Y+13, r1	; 0x0d
    a12e:	0f c0       	rjmp	.+30     	; 0xa14e <SD_init+0x3dc>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    a130:	8f ef       	ldi	r24, 0xFF	; 255
    a132:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a136:	28 2f       	mov	r18, r24
    a138:	8c 85       	ldd	r24, Y+12	; 0x0c
    a13a:	9d 85       	ldd	r25, Y+13	; 0x0d
    a13c:	82 56       	subi	r24, 0x62	; 98
    a13e:	9f 4a       	sbci	r25, 0xAF	; 175
    a140:	fc 01       	movw	r30, r24
    a142:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    a144:	8c 85       	ldd	r24, Y+12	; 0x0c
    a146:	9d 85       	ldd	r25, Y+13	; 0x0d
    a148:	01 96       	adiw	r24, 0x01	; 1
    a14a:	8c 87       	std	Y+12, r24	; 0x0c
    a14c:	9d 87       	std	Y+13, r25	; 0x0d
    a14e:	8c 85       	ldd	r24, Y+12	; 0x0c
    a150:	9d 85       	ldd	r25, Y+13	; 0x0d
    a152:	84 30       	cpi	r24, 0x04	; 4
    a154:	91 05       	cpc	r25, r1
    a156:	64 f3       	brlt	.-40     	; 0xa130 <SD_init+0x3be>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    a158:	80 91 9e 50 	lds	r24, 0x509E
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    a15c:	80 e0       	ldi	r24, 0x00	; 0
    a15e:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    a162:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a166:	88 e0       	ldi	r24, 0x08	; 8
    a168:	60 e0       	ldi	r22, 0x00	; 0
    a16a:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
	return errorCode;	
    a16e:	89 81       	ldd	r24, Y+1	; 0x01
}	
    a170:	a9 96       	adiw	r28, 0x29	; 41
    a172:	cd bf       	out	0x3d, r28	; 61
    a174:	de bf       	out	0x3e, r29	; 62
    a176:	df 91       	pop	r29
    a178:	cf 91       	pop	r28
    a17a:	1f 91       	pop	r17
    a17c:	0f 91       	pop	r16
    a17e:	08 95       	ret

0000a180 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    a180:	cf 93       	push	r28
    a182:	df 93       	push	r29
    a184:	0f 92       	push	r0
    a186:	0f 92       	push	r0
    a188:	cd b7       	in	r28, 0x3d	; 61
    a18a:	de b7       	in	r29, 0x3e	; 62
    a18c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    a18e:	80 ec       	ldi	r24, 0xC0	; 192
    a190:	98 e0       	ldi	r25, 0x08	; 8
    a192:	2a 81       	ldd	r18, Y+2	; 0x02
    a194:	fc 01       	movw	r30, r24
    a196:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    a198:	00 00       	nop
    a19a:	80 ec       	ldi	r24, 0xC0	; 192
    a19c:	98 e0       	ldi	r25, 0x08	; 8
    a19e:	fc 01       	movw	r30, r24
    a1a0:	82 81       	ldd	r24, Z+2	; 0x02
    a1a2:	88 23       	and	r24, r24
    a1a4:	d4 f7       	brge	.-12     	; 0xa19a <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    a1a6:	80 ec       	ldi	r24, 0xC0	; 192
    a1a8:	98 e0       	ldi	r25, 0x08	; 8
    a1aa:	fc 01       	movw	r30, r24
    a1ac:	83 81       	ldd	r24, Z+3	; 0x03
    a1ae:	89 83       	std	Y+1, r24	; 0x01
	return data;
    a1b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    a1b2:	0f 90       	pop	r0
    a1b4:	0f 90       	pop	r0
    a1b6:	df 91       	pop	r29
    a1b8:	cf 91       	pop	r28
    a1ba:	08 95       	ret

0000a1bc <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    a1bc:	0f 93       	push	r16
    a1be:	1f 93       	push	r17
    a1c0:	cf 93       	push	r28
    a1c2:	df 93       	push	r29
    a1c4:	cd b7       	in	r28, 0x3d	; 61
    a1c6:	de b7       	in	r29, 0x3e	; 62
    a1c8:	2a 97       	sbiw	r28, 0x0a	; 10
    a1ca:	cd bf       	out	0x3d, r28	; 61
    a1cc:	de bf       	out	0x3e, r29	; 62
    a1ce:	8b 83       	std	Y+3, r24	; 0x03
    a1d0:	4c 83       	std	Y+4, r20	; 0x04
    a1d2:	5d 83       	std	Y+5, r21	; 0x05
    a1d4:	6e 83       	std	Y+6, r22	; 0x06
    a1d6:	7f 83       	std	Y+7, r23	; 0x07
    a1d8:	28 87       	std	Y+8, r18	; 0x08
    a1da:	09 87       	std	Y+9, r16	; 0x09
    a1dc:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    a1de:	8b 81       	ldd	r24, Y+3	; 0x03
    a1e0:	80 64       	ori	r24, 0x40	; 64
    a1e2:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    a1e6:	8c 81       	ldd	r24, Y+4	; 0x04
    a1e8:	9d 81       	ldd	r25, Y+5	; 0x05
    a1ea:	ae 81       	ldd	r26, Y+6	; 0x06
    a1ec:	bf 81       	ldd	r27, Y+7	; 0x07
    a1ee:	8b 2f       	mov	r24, r27
    a1f0:	99 27       	eor	r25, r25
    a1f2:	aa 27       	eor	r26, r26
    a1f4:	bb 27       	eor	r27, r27
    a1f6:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    a1fa:	8c 81       	ldd	r24, Y+4	; 0x04
    a1fc:	9d 81       	ldd	r25, Y+5	; 0x05
    a1fe:	ae 81       	ldd	r26, Y+6	; 0x06
    a200:	bf 81       	ldd	r27, Y+7	; 0x07
    a202:	cd 01       	movw	r24, r26
    a204:	aa 27       	eor	r26, r26
    a206:	bb 27       	eor	r27, r27
    a208:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    a20c:	8c 81       	ldd	r24, Y+4	; 0x04
    a20e:	9d 81       	ldd	r25, Y+5	; 0x05
    a210:	ae 81       	ldd	r26, Y+6	; 0x06
    a212:	bf 81       	ldd	r27, Y+7	; 0x07
    a214:	89 2f       	mov	r24, r25
    a216:	9a 2f       	mov	r25, r26
    a218:	ab 2f       	mov	r26, r27
    a21a:	bb 27       	eor	r27, r27
    a21c:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    a220:	8c 81       	ldd	r24, Y+4	; 0x04
    a222:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
	SPI_write(crc);
    a226:	88 85       	ldd	r24, Y+8	; 0x08
    a228:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
	
	for(int i=0; i<read; i++){
    a22c:	19 82       	std	Y+1, r1	; 0x01
    a22e:	1a 82       	std	Y+2, r1	; 0x02
    a230:	33 c0       	rjmp	.+102    	; 0xa298 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    a232:	89 81       	ldd	r24, Y+1	; 0x01
    a234:	9a 81       	ldd	r25, Y+2	; 0x02
    a236:	2d e0       	ldi	r18, 0x0D	; 13
    a238:	30 e0       	ldi	r19, 0x00	; 0
    a23a:	b9 01       	movw	r22, r18
    a23c:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a240:	8c 01       	movw	r16, r24
    a242:	8f ef       	ldi	r24, 0xFF	; 255
    a244:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a248:	28 2f       	mov	r18, r24
    a24a:	c8 01       	movw	r24, r16
    a24c:	82 56       	subi	r24, 0x62	; 98
    a24e:	9f 4a       	sbci	r25, 0xAF	; 175
    a250:	fc 01       	movw	r30, r24
    a252:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    a254:	89 81       	ldd	r24, Y+1	; 0x01
    a256:	9a 81       	ldd	r25, Y+2	; 0x02
    a258:	2d e0       	ldi	r18, 0x0D	; 13
    a25a:	30 e0       	ldi	r19, 0x00	; 0
    a25c:	b9 01       	movw	r22, r18
    a25e:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a262:	82 56       	subi	r24, 0x62	; 98
    a264:	9f 4a       	sbci	r25, 0xAF	; 175
    a266:	fc 01       	movw	r30, r24
    a268:	80 81       	ld	r24, Z
    a26a:	8f 3f       	cpi	r24, 0xFF	; 255
    a26c:	81 f0       	breq	.+32     	; 0xa28e <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    a26e:	89 81       	ldd	r24, Y+1	; 0x01
    a270:	9a 81       	ldd	r25, Y+2	; 0x02
    a272:	2d e0       	ldi	r18, 0x0D	; 13
    a274:	30 e0       	ldi	r19, 0x00	; 0
    a276:	b9 01       	movw	r22, r18
    a278:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a27c:	82 56       	subi	r24, 0x62	; 98
    a27e:	9f 4a       	sbci	r25, 0xAF	; 175
    a280:	fc 01       	movw	r30, r24
    a282:	80 81       	ld	r24, Z
    a284:	80 93 9f 50 	sts	0x509F, r24
			return Buffer[1];
    a288:	80 91 9f 50 	lds	r24, 0x509F
    a28c:	0d c0       	rjmp	.+26     	; 0xa2a8 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    a28e:	89 81       	ldd	r24, Y+1	; 0x01
    a290:	9a 81       	ldd	r25, Y+2	; 0x02
    a292:	01 96       	adiw	r24, 0x01	; 1
    a294:	89 83       	std	Y+1, r24	; 0x01
    a296:	9a 83       	std	Y+2, r25	; 0x02
    a298:	29 81       	ldd	r18, Y+1	; 0x01
    a29a:	3a 81       	ldd	r19, Y+2	; 0x02
    a29c:	89 85       	ldd	r24, Y+9	; 0x09
    a29e:	9a 85       	ldd	r25, Y+10	; 0x0a
    a2a0:	28 17       	cp	r18, r24
    a2a2:	39 07       	cpc	r19, r25
    a2a4:	34 f2       	brlt	.-116    	; 0xa232 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    a2a6:	8f ef       	ldi	r24, 0xFF	; 255
}
    a2a8:	2a 96       	adiw	r28, 0x0a	; 10
    a2aa:	cd bf       	out	0x3d, r28	; 61
    a2ac:	de bf       	out	0x3e, r29	; 62
    a2ae:	df 91       	pop	r29
    a2b0:	cf 91       	pop	r28
    a2b2:	1f 91       	pop	r17
    a2b4:	0f 91       	pop	r16
    a2b6:	08 95       	ret

0000a2b8 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    a2b8:	0f 93       	push	r16
    a2ba:	1f 93       	push	r17
    a2bc:	cf 93       	push	r28
    a2be:	df 93       	push	r29
    a2c0:	cd b7       	in	r28, 0x3d	; 61
    a2c2:	de b7       	in	r29, 0x3e	; 62
    a2c4:	62 97       	sbiw	r28, 0x12	; 18
    a2c6:	cd bf       	out	0x3d, r28	; 61
    a2c8:	de bf       	out	0x3e, r29	; 62
    a2ca:	6b 87       	std	Y+11, r22	; 0x0b
    a2cc:	7c 87       	std	Y+12, r23	; 0x0c
    a2ce:	8d 87       	std	Y+13, r24	; 0x0d
    a2d0:	9e 87       	std	Y+14, r25	; 0x0e
    a2d2:	4f 87       	std	Y+15, r20	; 0x0f
    a2d4:	58 8b       	std	Y+16, r21	; 0x10
    a2d6:	29 8b       	std	Y+17, r18	; 0x11
    a2d8:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a2da:	88 e0       	ldi	r24, 0x08	; 8
    a2dc:	60 e0       	ldi	r22, 0x00	; 0
    a2de:	0e 94 71 37 	call	0x6ee2	; 0x6ee2 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a2e2:	80 e0       	ldi	r24, 0x00	; 0
    a2e4:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    a2e8:	81 e0       	ldi	r24, 0x01	; 1
    a2ea:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    a2ee:	20 e0       	ldi	r18, 0x00	; 0
    a2f0:	32 e0       	ldi	r19, 0x02	; 2
    a2f2:	89 89       	ldd	r24, Y+17	; 0x11
    a2f4:	9a 89       	ldd	r25, Y+18	; 0x12
    a2f6:	a9 01       	movw	r20, r18
    a2f8:	48 1b       	sub	r20, r24
    a2fa:	59 0b       	sbc	r21, r25
    a2fc:	ca 01       	movw	r24, r20
    a2fe:	89 83       	std	Y+1, r24	; 0x01
    a300:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a302:	89 81       	ldd	r24, Y+1	; 0x01
    a304:	9a 81       	ldd	r25, Y+2	; 0x02
    a306:	52 e0       	ldi	r21, 0x02	; 2
    a308:	80 30       	cpi	r24, 0x00	; 0
    a30a:	95 07       	cpc	r25, r21
    a30c:	11 f4       	brne	.+4      	; 0xa312 <SD_write_block+0x5a>
    a30e:	19 82       	std	Y+1, r1	; 0x01
    a310:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a312:	1b 82       	std	Y+3, r1	; 0x03
    a314:	1c 82       	std	Y+4, r1	; 0x04
    a316:	0b c0       	rjmp	.+22     	; 0xa32e <SD_write_block+0x76>
	if (i >= 10) {
    a318:	8b 81       	ldd	r24, Y+3	; 0x03
    a31a:	9c 81       	ldd	r25, Y+4	; 0x04
    a31c:	8a 30       	cpi	r24, 0x0A	; 10
    a31e:	91 05       	cpc	r25, r1
    a320:	0c f0       	brlt	.+2      	; 0xa324 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    a322:	ff cf       	rjmp	.-2      	; 0xa322 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a324:	8b 81       	ldd	r24, Y+3	; 0x03
    a326:	9c 81       	ldd	r25, Y+4	; 0x04
    a328:	01 96       	adiw	r24, 0x01	; 1
    a32a:	8b 83       	std	Y+3, r24	; 0x03
    a32c:	9c 83       	std	Y+4, r25	; 0x04
    a32e:	2b 85       	ldd	r18, Y+11	; 0x0b
    a330:	3c 85       	ldd	r19, Y+12	; 0x0c
    a332:	4d 85       	ldd	r20, Y+13	; 0x0d
    a334:	5e 85       	ldd	r21, Y+14	; 0x0e
    a336:	88 e1       	ldi	r24, 0x18	; 24
    a338:	ba 01       	movw	r22, r20
    a33a:	a9 01       	movw	r20, r18
    a33c:	2f ef       	ldi	r18, 0xFF	; 255
    a33e:	08 e0       	ldi	r16, 0x08	; 8
    a340:	10 e0       	ldi	r17, 0x00	; 0
    a342:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
    a346:	88 23       	and	r24, r24
    a348:	39 f7       	brne	.-50     	; 0xa318 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    a34a:	8f ef       	ldi	r24, 0xFF	; 255
    a34c:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a350:	80 93 9e 50 	sts	0x509E, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    a354:	8e ef       	ldi	r24, 0xFE	; 254
    a356:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a35a:	1d 82       	std	Y+5, r1	; 0x05
    a35c:	1e 82       	std	Y+6, r1	; 0x06
    a35e:	1d c0       	rjmp	.+58     	; 0xa39a <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    a360:	8d 81       	ldd	r24, Y+5	; 0x05
    a362:	9e 81       	ldd	r25, Y+6	; 0x06
    a364:	2d e0       	ldi	r18, 0x0D	; 13
    a366:	30 e0       	ldi	r19, 0x00	; 0
    a368:	b9 01       	movw	r22, r18
    a36a:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a36e:	8c 01       	movw	r16, r24
    a370:	8d 81       	ldd	r24, Y+5	; 0x05
    a372:	9e 81       	ldd	r25, Y+6	; 0x06
    a374:	2f 85       	ldd	r18, Y+15	; 0x0f
    a376:	38 89       	ldd	r19, Y+16	; 0x10
    a378:	82 0f       	add	r24, r18
    a37a:	93 1f       	adc	r25, r19
    a37c:	fc 01       	movw	r30, r24
    a37e:	80 81       	ld	r24, Z
    a380:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a384:	28 2f       	mov	r18, r24
    a386:	c8 01       	movw	r24, r16
    a388:	82 56       	subi	r24, 0x62	; 98
    a38a:	9f 4a       	sbci	r25, 0xAF	; 175
    a38c:	fc 01       	movw	r30, r24
    a38e:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a390:	8d 81       	ldd	r24, Y+5	; 0x05
    a392:	9e 81       	ldd	r25, Y+6	; 0x06
    a394:	01 96       	adiw	r24, 0x01	; 1
    a396:	8d 83       	std	Y+5, r24	; 0x05
    a398:	9e 83       	std	Y+6, r25	; 0x06
    a39a:	2d 81       	ldd	r18, Y+5	; 0x05
    a39c:	3e 81       	ldd	r19, Y+6	; 0x06
    a39e:	89 89       	ldd	r24, Y+17	; 0x11
    a3a0:	9a 89       	ldd	r25, Y+18	; 0x12
    a3a2:	28 17       	cp	r18, r24
    a3a4:	39 07       	cpc	r19, r25
    a3a6:	e4 f2       	brlt	.-72     	; 0xa360 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a3a8:	1f 82       	std	Y+7, r1	; 0x07
    a3aa:	18 86       	std	Y+8, r1	; 0x08
    a3ac:	16 c0       	rjmp	.+44     	; 0xa3da <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    a3ae:	8f 81       	ldd	r24, Y+7	; 0x07
    a3b0:	98 85       	ldd	r25, Y+8	; 0x08
    a3b2:	2d e0       	ldi	r18, 0x0D	; 13
    a3b4:	30 e0       	ldi	r19, 0x00	; 0
    a3b6:	b9 01       	movw	r22, r18
    a3b8:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a3bc:	8c 01       	movw	r16, r24
    a3be:	80 e0       	ldi	r24, 0x00	; 0
    a3c0:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a3c4:	28 2f       	mov	r18, r24
    a3c6:	c8 01       	movw	r24, r16
    a3c8:	82 56       	subi	r24, 0x62	; 98
    a3ca:	9f 4a       	sbci	r25, 0xAF	; 175
    a3cc:	fc 01       	movw	r30, r24
    a3ce:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a3d0:	8f 81       	ldd	r24, Y+7	; 0x07
    a3d2:	98 85       	ldd	r25, Y+8	; 0x08
    a3d4:	01 96       	adiw	r24, 0x01	; 1
    a3d6:	8f 83       	std	Y+7, r24	; 0x07
    a3d8:	98 87       	std	Y+8, r25	; 0x08
    a3da:	2f 81       	ldd	r18, Y+7	; 0x07
    a3dc:	38 85       	ldd	r19, Y+8	; 0x08
    a3de:	89 81       	ldd	r24, Y+1	; 0x01
    a3e0:	9a 81       	ldd	r25, Y+2	; 0x02
    a3e2:	28 17       	cp	r18, r24
    a3e4:	39 07       	cpc	r19, r25
    a3e6:	1c f3       	brlt	.-58     	; 0xa3ae <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    a3e8:	8f ef       	ldi	r24, 0xFF	; 255
    a3ea:	80 93 9e 50 	sts	0x509E, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a3ee:	19 86       	std	Y+9, r1	; 0x09
    a3f0:	1a 86       	std	Y+10, r1	; 0x0a
    a3f2:	0a c0       	rjmp	.+20     	; 0xa408 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    a3f4:	8f ef       	ldi	r24, 0xFF	; 255
    a3f6:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a3fa:	80 93 9e 50 	sts	0x509E, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a3fe:	89 85       	ldd	r24, Y+9	; 0x09
    a400:	9a 85       	ldd	r25, Y+10	; 0x0a
    a402:	01 96       	adiw	r24, 0x01	; 1
    a404:	89 87       	std	Y+9, r24	; 0x09
    a406:	9a 87       	std	Y+10, r25	; 0x0a
    a408:	89 85       	ldd	r24, Y+9	; 0x09
    a40a:	9a 85       	ldd	r25, Y+10	; 0x0a
    a40c:	82 30       	cpi	r24, 0x02	; 2
    a40e:	91 05       	cpc	r25, r1
    a410:	8c f3       	brlt	.-30     	; 0xa3f4 <SD_write_block+0x13c>
    a412:	80 91 9e 50 	lds	r24, 0x509E
    a416:	8f 3f       	cpi	r24, 0xFF	; 255
    a418:	69 f3       	breq	.-38     	; 0xa3f4 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    a41a:	80 91 9e 50 	lds	r24, 0x509E
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    a41e:	05 c0       	rjmp	.+10     	; 0xa42a <SD_write_block+0x172>
    a420:	8f ef       	ldi	r24, 0xFF	; 255
    a422:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a426:	80 93 9e 50 	sts	0x509E, r24
    a42a:	80 91 9e 50 	lds	r24, 0x509E
    a42e:	8f 3f       	cpi	r24, 0xFF	; 255
    a430:	b9 f7       	brne	.-18     	; 0xa420 <SD_write_block+0x168>
	SPICS(FALSE);
    a432:	80 e0       	ldi	r24, 0x00	; 0
    a434:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    a438:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    a43c:	88 e0       	ldi	r24, 0x08	; 8
    a43e:	60 e0       	ldi	r22, 0x00	; 0
    a440:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
}
    a444:	62 96       	adiw	r28, 0x12	; 18
    a446:	cd bf       	out	0x3d, r28	; 61
    a448:	de bf       	out	0x3e, r29	; 62
    a44a:	df 91       	pop	r29
    a44c:	cf 91       	pop	r28
    a44e:	1f 91       	pop	r17
    a450:	0f 91       	pop	r16
    a452:	08 95       	ret

0000a454 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    a454:	0f 93       	push	r16
    a456:	1f 93       	push	r17
    a458:	cf 93       	push	r28
    a45a:	df 93       	push	r29
    a45c:	cd b7       	in	r28, 0x3d	; 61
    a45e:	de b7       	in	r29, 0x3e	; 62
    a460:	2a 97       	sbiw	r28, 0x0a	; 10
    a462:	cd bf       	out	0x3d, r28	; 61
    a464:	de bf       	out	0x3e, r29	; 62
    a466:	6d 83       	std	Y+5, r22	; 0x05
    a468:	7e 83       	std	Y+6, r23	; 0x06
    a46a:	8f 83       	std	Y+7, r24	; 0x07
    a46c:	98 87       	std	Y+8, r25	; 0x08
    a46e:	49 87       	std	Y+9, r20	; 0x09
    a470:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a472:	88 e0       	ldi	r24, 0x08	; 8
    a474:	60 e0       	ldi	r22, 0x00	; 0
    a476:	0e 94 71 37 	call	0x6ee2	; 0x6ee2 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a47a:	80 e0       	ldi	r24, 0x00	; 0
    a47c:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    a480:	81 e0       	ldi	r24, 0x01	; 1
    a482:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a486:	19 82       	std	Y+1, r1	; 0x01
    a488:	1a 82       	std	Y+2, r1	; 0x02
    a48a:	0b c0       	rjmp	.+22     	; 0xa4a2 <SD_read_block+0x4e>
		if (i >= 10) {
    a48c:	89 81       	ldd	r24, Y+1	; 0x01
    a48e:	9a 81       	ldd	r25, Y+2	; 0x02
    a490:	8a 30       	cpi	r24, 0x0A	; 10
    a492:	91 05       	cpc	r25, r1
    a494:	0c f0       	brlt	.+2      	; 0xa498 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    a496:	ff cf       	rjmp	.-2      	; 0xa496 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a498:	89 81       	ldd	r24, Y+1	; 0x01
    a49a:	9a 81       	ldd	r25, Y+2	; 0x02
    a49c:	01 96       	adiw	r24, 0x01	; 1
    a49e:	89 83       	std	Y+1, r24	; 0x01
    a4a0:	9a 83       	std	Y+2, r25	; 0x02
    a4a2:	2d 81       	ldd	r18, Y+5	; 0x05
    a4a4:	3e 81       	ldd	r19, Y+6	; 0x06
    a4a6:	4f 81       	ldd	r20, Y+7	; 0x07
    a4a8:	58 85       	ldd	r21, Y+8	; 0x08
    a4aa:	81 e1       	ldi	r24, 0x11	; 17
    a4ac:	ba 01       	movw	r22, r20
    a4ae:	a9 01       	movw	r20, r18
    a4b0:	2f ef       	ldi	r18, 0xFF	; 255
    a4b2:	08 e0       	ldi	r16, 0x08	; 8
    a4b4:	10 e0       	ldi	r17, 0x00	; 0
    a4b6:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
    a4ba:	88 23       	and	r24, r24
    a4bc:	39 f7       	brne	.-50     	; 0xa48c <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a4be:	05 c0       	rjmp	.+10     	; 0xa4ca <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    a4c0:	8f ef       	ldi	r24, 0xFF	; 255
    a4c2:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a4c6:	80 93 9e 50 	sts	0x509E, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a4ca:	80 91 9e 50 	lds	r24, 0x509E
    a4ce:	8e 3f       	cpi	r24, 0xFE	; 254
    a4d0:	b9 f7       	brne	.-18     	; 0xa4c0 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a4d2:	1b 82       	std	Y+3, r1	; 0x03
    a4d4:	1c 82       	std	Y+4, r1	; 0x04
    a4d6:	11 c0       	rjmp	.+34     	; 0xa4fa <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a4d8:	8b 81       	ldd	r24, Y+3	; 0x03
    a4da:	9c 81       	ldd	r25, Y+4	; 0x04
    a4dc:	29 85       	ldd	r18, Y+9	; 0x09
    a4de:	3a 85       	ldd	r19, Y+10	; 0x0a
    a4e0:	89 01       	movw	r16, r18
    a4e2:	08 0f       	add	r16, r24
    a4e4:	19 1f       	adc	r17, r25
    a4e6:	8f ef       	ldi	r24, 0xFF	; 255
    a4e8:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a4ec:	f8 01       	movw	r30, r16
    a4ee:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a4f0:	8b 81       	ldd	r24, Y+3	; 0x03
    a4f2:	9c 81       	ldd	r25, Y+4	; 0x04
    a4f4:	01 96       	adiw	r24, 0x01	; 1
    a4f6:	8b 83       	std	Y+3, r24	; 0x03
    a4f8:	9c 83       	std	Y+4, r25	; 0x04
    a4fa:	8b 81       	ldd	r24, Y+3	; 0x03
    a4fc:	9c 81       	ldd	r25, Y+4	; 0x04
    a4fe:	f2 e0       	ldi	r31, 0x02	; 2
    a500:	80 30       	cpi	r24, 0x00	; 0
    a502:	9f 07       	cpc	r25, r31
    a504:	4c f3       	brlt	.-46     	; 0xa4d8 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    a506:	10 92 aa 50 	sts	0x50AA, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a50a:	05 c0       	rjmp	.+10     	; 0xa516 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    a50c:	8f ef       	ldi	r24, 0xFF	; 255
    a50e:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a512:	80 93 aa 50 	sts	0x50AA, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a516:	80 91 aa 50 	lds	r24, 0x50AA
    a51a:	8f 3f       	cpi	r24, 0xFF	; 255
    a51c:	b9 f7       	brne	.-18     	; 0xa50c <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    a51e:	80 e0       	ldi	r24, 0x00	; 0
    a520:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    a524:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a528:	88 e0       	ldi	r24, 0x08	; 8
    a52a:	60 e0       	ldi	r22, 0x00	; 0
    a52c:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
}
    a530:	2a 96       	adiw	r28, 0x0a	; 10
    a532:	cd bf       	out	0x3d, r28	; 61
    a534:	de bf       	out	0x3e, r29	; 62
    a536:	df 91       	pop	r29
    a538:	cf 91       	pop	r28
    a53a:	1f 91       	pop	r17
    a53c:	0f 91       	pop	r16
    a53e:	08 95       	ret

0000a540 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    a540:	0f 93       	push	r16
    a542:	1f 93       	push	r17
    a544:	cf 93       	push	r28
    a546:	df 93       	push	r29
    a548:	cd b7       	in	r28, 0x3d	; 61
    a54a:	de b7       	in	r29, 0x3e	; 62
    a54c:	6a 97       	sbiw	r28, 0x1a	; 26
    a54e:	cd bf       	out	0x3d, r28	; 61
    a550:	de bf       	out	0x3e, r29	; 62
    a552:	6b 8b       	std	Y+19, r22	; 0x13
    a554:	7c 8b       	std	Y+20, r23	; 0x14
    a556:	8d 8b       	std	Y+21, r24	; 0x15
    a558:	9e 8b       	std	Y+22, r25	; 0x16
    a55a:	4f 8b       	std	Y+23, r20	; 0x17
    a55c:	58 8f       	std	Y+24, r21	; 0x18
    a55e:	29 8f       	std	Y+25, r18	; 0x19
    a560:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a562:	88 e0       	ldi	r24, 0x08	; 8
    a564:	60 e0       	ldi	r22, 0x00	; 0
    a566:	0e 94 71 37 	call	0x6ee2	; 0x6ee2 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a56a:	80 e0       	ldi	r24, 0x00	; 0
    a56c:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    a570:	81 e0       	ldi	r24, 0x01	; 1
    a572:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    a576:	89 8d       	ldd	r24, Y+25	; 0x19
    a578:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a57a:	99 23       	and	r25, r25
    a57c:	14 f4       	brge	.+4      	; 0xa582 <SD_write_multiple_blocks+0x42>
    a57e:	81 50       	subi	r24, 0x01	; 1
    a580:	9e 4f       	sbci	r25, 0xFE	; 254
    a582:	89 2f       	mov	r24, r25
    a584:	99 0f       	add	r25, r25
    a586:	99 0b       	sbc	r25, r25
    a588:	85 95       	asr	r24
    a58a:	89 83       	std	Y+1, r24	; 0x01
    a58c:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    a58e:	89 8d       	ldd	r24, Y+25	; 0x19
    a590:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a592:	20 e0       	ldi	r18, 0x00	; 0
    a594:	32 e0       	ldi	r19, 0x02	; 2
    a596:	b9 01       	movw	r22, r18
    a598:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a59c:	20 e0       	ldi	r18, 0x00	; 0
    a59e:	32 e0       	ldi	r19, 0x02	; 2
    a5a0:	a9 01       	movw	r20, r18
    a5a2:	48 1b       	sub	r20, r24
    a5a4:	59 0b       	sbc	r21, r25
    a5a6:	ca 01       	movw	r24, r20
    a5a8:	8b 83       	std	Y+3, r24	; 0x03
    a5aa:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a5ac:	8b 81       	ldd	r24, Y+3	; 0x03
    a5ae:	9c 81       	ldd	r25, Y+4	; 0x04
    a5b0:	52 e0       	ldi	r21, 0x02	; 2
    a5b2:	80 30       	cpi	r24, 0x00	; 0
    a5b4:	95 07       	cpc	r25, r21
    a5b6:	19 f4       	brne	.+6      	; 0xa5be <SD_write_multiple_blocks+0x7e>
    a5b8:	1b 82       	std	Y+3, r1	; 0x03
    a5ba:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a5bc:	05 c0       	rjmp	.+10     	; 0xa5c8 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    a5be:	89 81       	ldd	r24, Y+1	; 0x01
    a5c0:	9a 81       	ldd	r25, Y+2	; 0x02
    a5c2:	01 96       	adiw	r24, 0x01	; 1
    a5c4:	89 83       	std	Y+1, r24	; 0x01
    a5c6:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a5c8:	00 00       	nop
    a5ca:	2b 89       	ldd	r18, Y+19	; 0x13
    a5cc:	3c 89       	ldd	r19, Y+20	; 0x14
    a5ce:	4d 89       	ldd	r20, Y+21	; 0x15
    a5d0:	5e 89       	ldd	r21, Y+22	; 0x16
    a5d2:	89 e1       	ldi	r24, 0x19	; 25
    a5d4:	ba 01       	movw	r22, r20
    a5d6:	a9 01       	movw	r20, r18
    a5d8:	2f ef       	ldi	r18, 0xFF	; 255
    a5da:	08 e0       	ldi	r16, 0x08	; 8
    a5dc:	10 e0       	ldi	r17, 0x00	; 0
    a5de:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
    a5e2:	88 23       	and	r24, r24
    a5e4:	91 f7       	brne	.-28     	; 0xa5ca <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    a5e6:	1d 82       	std	Y+5, r1	; 0x05
    a5e8:	1e 82       	std	Y+6, r1	; 0x06
    a5ea:	ba c0       	rjmp	.+372    	; 0xa760 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    a5ec:	8f ef       	ldi	r24, 0xFF	; 255
    a5ee:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a5f2:	80 93 9f 50 	sts	0x509F, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    a5f6:	8c ef       	ldi	r24, 0xFC	; 252
    a5f8:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a5fc:	80 93 9f 50 	sts	0x509F, r24
		if(j == (numSectors-1)){
    a600:	89 81       	ldd	r24, Y+1	; 0x01
    a602:	9a 81       	ldd	r25, Y+2	; 0x02
    a604:	9c 01       	movw	r18, r24
    a606:	21 50       	subi	r18, 0x01	; 1
    a608:	30 40       	sbci	r19, 0x00	; 0
    a60a:	8d 81       	ldd	r24, Y+5	; 0x05
    a60c:	9e 81       	ldd	r25, Y+6	; 0x06
    a60e:	28 17       	cp	r18, r24
    a610:	39 07       	cpc	r19, r25
    a612:	09 f0       	breq	.+2      	; 0xa616 <SD_write_multiple_blocks+0xd6>
    a614:	54 c0       	rjmp	.+168    	; 0xa6be <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a616:	1f 82       	std	Y+7, r1	; 0x07
    a618:	18 86       	std	Y+8, r1	; 0x08
    a61a:	25 c0       	rjmp	.+74     	; 0xa666 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a61c:	8f 81       	ldd	r24, Y+7	; 0x07
    a61e:	98 85       	ldd	r25, Y+8	; 0x08
    a620:	2c e0       	ldi	r18, 0x0C	; 12
    a622:	30 e0       	ldi	r19, 0x00	; 0
    a624:	b9 01       	movw	r22, r18
    a626:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a62a:	8c 01       	movw	r16, r24
    a62c:	8d 81       	ldd	r24, Y+5	; 0x05
    a62e:	9e 81       	ldd	r25, Y+6	; 0x06
    a630:	9c 01       	movw	r18, r24
    a632:	32 2f       	mov	r19, r18
    a634:	22 27       	eor	r18, r18
    a636:	33 0f       	add	r19, r19
    a638:	8f 81       	ldd	r24, Y+7	; 0x07
    a63a:	98 85       	ldd	r25, Y+8	; 0x08
    a63c:	82 0f       	add	r24, r18
    a63e:	93 1f       	adc	r25, r19
    a640:	2f 89       	ldd	r18, Y+23	; 0x17
    a642:	38 8d       	ldd	r19, Y+24	; 0x18
    a644:	82 0f       	add	r24, r18
    a646:	93 1f       	adc	r25, r19
    a648:	fc 01       	movw	r30, r24
    a64a:	80 81       	ld	r24, Z
    a64c:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a650:	28 2f       	mov	r18, r24
    a652:	c8 01       	movw	r24, r16
    a654:	82 56       	subi	r24, 0x62	; 98
    a656:	9f 4a       	sbci	r25, 0xAF	; 175
    a658:	fc 01       	movw	r30, r24
    a65a:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a65c:	8f 81       	ldd	r24, Y+7	; 0x07
    a65e:	98 85       	ldd	r25, Y+8	; 0x08
    a660:	01 96       	adiw	r24, 0x01	; 1
    a662:	8f 83       	std	Y+7, r24	; 0x07
    a664:	98 87       	std	Y+8, r25	; 0x08
    a666:	20 e0       	ldi	r18, 0x00	; 0
    a668:	32 e0       	ldi	r19, 0x02	; 2
    a66a:	8b 81       	ldd	r24, Y+3	; 0x03
    a66c:	9c 81       	ldd	r25, Y+4	; 0x04
    a66e:	28 1b       	sub	r18, r24
    a670:	39 0b       	sbc	r19, r25
    a672:	8f 81       	ldd	r24, Y+7	; 0x07
    a674:	98 85       	ldd	r25, Y+8	; 0x08
    a676:	82 17       	cp	r24, r18
    a678:	93 07       	cpc	r25, r19
    a67a:	84 f2       	brlt	.-96     	; 0xa61c <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a67c:	19 86       	std	Y+9, r1	; 0x09
    a67e:	1a 86       	std	Y+10, r1	; 0x0a
    a680:	16 c0       	rjmp	.+44     	; 0xa6ae <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a682:	89 85       	ldd	r24, Y+9	; 0x09
    a684:	9a 85       	ldd	r25, Y+10	; 0x0a
    a686:	2c e0       	ldi	r18, 0x0C	; 12
    a688:	30 e0       	ldi	r19, 0x00	; 0
    a68a:	b9 01       	movw	r22, r18
    a68c:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a690:	8c 01       	movw	r16, r24
    a692:	80 e0       	ldi	r24, 0x00	; 0
    a694:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a698:	28 2f       	mov	r18, r24
    a69a:	c8 01       	movw	r24, r16
    a69c:	82 56       	subi	r24, 0x62	; 98
    a69e:	9f 4a       	sbci	r25, 0xAF	; 175
    a6a0:	fc 01       	movw	r30, r24
    a6a2:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a6a4:	89 85       	ldd	r24, Y+9	; 0x09
    a6a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    a6a8:	01 96       	adiw	r24, 0x01	; 1
    a6aa:	89 87       	std	Y+9, r24	; 0x09
    a6ac:	9a 87       	std	Y+10, r25	; 0x0a
    a6ae:	29 85       	ldd	r18, Y+9	; 0x09
    a6b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    a6b2:	8b 81       	ldd	r24, Y+3	; 0x03
    a6b4:	9c 81       	ldd	r25, Y+4	; 0x04
    a6b6:	28 17       	cp	r18, r24
    a6b8:	39 07       	cpc	r19, r25
    a6ba:	1c f3       	brlt	.-58     	; 0xa682 <SD_write_multiple_blocks+0x142>
    a6bc:	2e c0       	rjmp	.+92     	; 0xa71a <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a6be:	1b 86       	std	Y+11, r1	; 0x0b
    a6c0:	1c 86       	std	Y+12, r1	; 0x0c
    a6c2:	25 c0       	rjmp	.+74     	; 0xa70e <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a6c4:	8b 85       	ldd	r24, Y+11	; 0x0b
    a6c6:	9c 85       	ldd	r25, Y+12	; 0x0c
    a6c8:	2c e0       	ldi	r18, 0x0C	; 12
    a6ca:	30 e0       	ldi	r19, 0x00	; 0
    a6cc:	b9 01       	movw	r22, r18
    a6ce:	0e 94 80 60 	call	0xc100	; 0xc100 <__divmodhi4>
    a6d2:	8c 01       	movw	r16, r24
    a6d4:	8d 81       	ldd	r24, Y+5	; 0x05
    a6d6:	9e 81       	ldd	r25, Y+6	; 0x06
    a6d8:	9c 01       	movw	r18, r24
    a6da:	32 2f       	mov	r19, r18
    a6dc:	22 27       	eor	r18, r18
    a6de:	33 0f       	add	r19, r19
    a6e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    a6e2:	9c 85       	ldd	r25, Y+12	; 0x0c
    a6e4:	82 0f       	add	r24, r18
    a6e6:	93 1f       	adc	r25, r19
    a6e8:	2f 89       	ldd	r18, Y+23	; 0x17
    a6ea:	38 8d       	ldd	r19, Y+24	; 0x18
    a6ec:	82 0f       	add	r24, r18
    a6ee:	93 1f       	adc	r25, r19
    a6f0:	fc 01       	movw	r30, r24
    a6f2:	80 81       	ld	r24, Z
    a6f4:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a6f8:	28 2f       	mov	r18, r24
    a6fa:	c8 01       	movw	r24, r16
    a6fc:	82 56       	subi	r24, 0x62	; 98
    a6fe:	9f 4a       	sbci	r25, 0xAF	; 175
    a700:	fc 01       	movw	r30, r24
    a702:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a704:	8b 85       	ldd	r24, Y+11	; 0x0b
    a706:	9c 85       	ldd	r25, Y+12	; 0x0c
    a708:	01 96       	adiw	r24, 0x01	; 1
    a70a:	8b 87       	std	Y+11, r24	; 0x0b
    a70c:	9c 87       	std	Y+12, r25	; 0x0c
    a70e:	8b 85       	ldd	r24, Y+11	; 0x0b
    a710:	9c 85       	ldd	r25, Y+12	; 0x0c
    a712:	f2 e0       	ldi	r31, 0x02	; 2
    a714:	80 30       	cpi	r24, 0x00	; 0
    a716:	9f 07       	cpc	r25, r31
    a718:	ac f2       	brlt	.-86     	; 0xa6c4 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a71a:	1d 86       	std	Y+13, r1	; 0x0d
    a71c:	1e 86       	std	Y+14, r1	; 0x0e
    a71e:	0a c0       	rjmp	.+20     	; 0xa734 <SD_write_multiple_blocks+0x1f4>
    a720:	8f ef       	ldi	r24, 0xFF	; 255
    a722:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a726:	80 93 9f 50 	sts	0x509F, r24
    a72a:	8d 85       	ldd	r24, Y+13	; 0x0d
    a72c:	9e 85       	ldd	r25, Y+14	; 0x0e
    a72e:	01 96       	adiw	r24, 0x01	; 1
    a730:	8d 87       	std	Y+13, r24	; 0x0d
    a732:	9e 87       	std	Y+14, r25	; 0x0e
    a734:	8d 85       	ldd	r24, Y+13	; 0x0d
    a736:	9e 85       	ldd	r25, Y+14	; 0x0e
    a738:	82 30       	cpi	r24, 0x02	; 2
    a73a:	91 05       	cpc	r25, r1
    a73c:	8c f3       	brlt	.-30     	; 0xa720 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a73e:	10 92 9f 50 	sts	0x509F, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a742:	05 c0       	rjmp	.+10     	; 0xa74e <SD_write_multiple_blocks+0x20e>
    a744:	8f ef       	ldi	r24, 0xFF	; 255
    a746:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a74a:	80 93 9f 50 	sts	0x509F, r24
    a74e:	80 91 9f 50 	lds	r24, 0x509F
    a752:	8f 3f       	cpi	r24, 0xFF	; 255
    a754:	b9 f7       	brne	.-18     	; 0xa744 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a756:	8d 81       	ldd	r24, Y+5	; 0x05
    a758:	9e 81       	ldd	r25, Y+6	; 0x06
    a75a:	01 96       	adiw	r24, 0x01	; 1
    a75c:	8d 83       	std	Y+5, r24	; 0x05
    a75e:	9e 83       	std	Y+6, r25	; 0x06
    a760:	2d 81       	ldd	r18, Y+5	; 0x05
    a762:	3e 81       	ldd	r19, Y+6	; 0x06
    a764:	89 81       	ldd	r24, Y+1	; 0x01
    a766:	9a 81       	ldd	r25, Y+2	; 0x02
    a768:	28 17       	cp	r18, r24
    a76a:	39 07       	cpc	r19, r25
    a76c:	0c f4       	brge	.+2      	; 0xa770 <SD_write_multiple_blocks+0x230>
    a76e:	3e cf       	rjmp	.-388    	; 0xa5ec <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a770:	1f 86       	std	Y+15, r1	; 0x0f
    a772:	18 8a       	std	Y+16, r1	; 0x10
    a774:	0a c0       	rjmp	.+20     	; 0xa78a <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a776:	8f ef       	ldi	r24, 0xFF	; 255
    a778:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a77c:	80 93 9f 50 	sts	0x509F, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a780:	8f 85       	ldd	r24, Y+15	; 0x0f
    a782:	98 89       	ldd	r25, Y+16	; 0x10
    a784:	01 96       	adiw	r24, 0x01	; 1
    a786:	8f 87       	std	Y+15, r24	; 0x0f
    a788:	98 8b       	std	Y+16, r25	; 0x10
    a78a:	8f 85       	ldd	r24, Y+15	; 0x0f
    a78c:	98 89       	ldd	r25, Y+16	; 0x10
    a78e:	84 30       	cpi	r24, 0x04	; 4
    a790:	91 05       	cpc	r25, r1
    a792:	8c f3       	brlt	.-30     	; 0xa776 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a794:	8d ef       	ldi	r24, 0xFD	; 253
    a796:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a79a:	80 93 9f 50 	sts	0x509F, r24
	for(int i=0;i<4;i++){
    a79e:	19 8a       	std	Y+17, r1	; 0x11
    a7a0:	1a 8a       	std	Y+18, r1	; 0x12
    a7a2:	0a c0       	rjmp	.+20     	; 0xa7b8 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a7a4:	8f ef       	ldi	r24, 0xFF	; 255
    a7a6:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a7aa:	80 93 9f 50 	sts	0x509F, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a7ae:	89 89       	ldd	r24, Y+17	; 0x11
    a7b0:	9a 89       	ldd	r25, Y+18	; 0x12
    a7b2:	01 96       	adiw	r24, 0x01	; 1
    a7b4:	89 8b       	std	Y+17, r24	; 0x11
    a7b6:	9a 8b       	std	Y+18, r25	; 0x12
    a7b8:	89 89       	ldd	r24, Y+17	; 0x11
    a7ba:	9a 89       	ldd	r25, Y+18	; 0x12
    a7bc:	84 30       	cpi	r24, 0x04	; 4
    a7be:	91 05       	cpc	r25, r1
    a7c0:	8c f3       	brlt	.-30     	; 0xa7a4 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a7c2:	10 92 9f 50 	sts	0x509F, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a7c6:	05 c0       	rjmp	.+10     	; 0xa7d2 <SD_write_multiple_blocks+0x292>
    a7c8:	8f ef       	ldi	r24, 0xFF	; 255
    a7ca:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a7ce:	80 93 9f 50 	sts	0x509F, r24
    a7d2:	80 91 9f 50 	lds	r24, 0x509F
    a7d6:	8f 3f       	cpi	r24, 0xFF	; 255
    a7d8:	b9 f7       	brne	.-18     	; 0xa7c8 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a7da:	80 e0       	ldi	r24, 0x00	; 0
    a7dc:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    a7e0:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a7e4:	88 e0       	ldi	r24, 0x08	; 8
    a7e6:	60 e0       	ldi	r22, 0x00	; 0
    a7e8:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
}
    a7ec:	6a 96       	adiw	r28, 0x1a	; 26
    a7ee:	cd bf       	out	0x3d, r28	; 61
    a7f0:	de bf       	out	0x3e, r29	; 62
    a7f2:	df 91       	pop	r29
    a7f4:	cf 91       	pop	r28
    a7f6:	1f 91       	pop	r17
    a7f8:	0f 91       	pop	r16
    a7fa:	08 95       	ret

0000a7fc <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a7fc:	0f 93       	push	r16
    a7fe:	1f 93       	push	r17
    a800:	cf 93       	push	r28
    a802:	df 93       	push	r29
    a804:	cd b7       	in	r28, 0x3d	; 61
    a806:	de b7       	in	r29, 0x3e	; 62
    a808:	2e 97       	sbiw	r28, 0x0e	; 14
    a80a:	cd bf       	out	0x3d, r28	; 61
    a80c:	de bf       	out	0x3e, r29	; 62
    a80e:	6f 83       	std	Y+7, r22	; 0x07
    a810:	78 87       	std	Y+8, r23	; 0x08
    a812:	89 87       	std	Y+9, r24	; 0x09
    a814:	9a 87       	std	Y+10, r25	; 0x0a
    a816:	4b 87       	std	Y+11, r20	; 0x0b
    a818:	5c 87       	std	Y+12, r21	; 0x0c
    a81a:	2d 87       	std	Y+13, r18	; 0x0d
    a81c:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a81e:	88 e0       	ldi	r24, 0x08	; 8
    a820:	60 e0       	ldi	r22, 0x00	; 0
    a822:	0e 94 71 37 	call	0x6ee2	; 0x6ee2 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a826:	80 e0       	ldi	r24, 0x00	; 0
    a828:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    a82c:	81 e0       	ldi	r24, 0x01	; 1
    a82e:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a832:	00 00       	nop
    a834:	2f 81       	ldd	r18, Y+7	; 0x07
    a836:	38 85       	ldd	r19, Y+8	; 0x08
    a838:	49 85       	ldd	r20, Y+9	; 0x09
    a83a:	5a 85       	ldd	r21, Y+10	; 0x0a
    a83c:	82 e1       	ldi	r24, 0x12	; 18
    a83e:	ba 01       	movw	r22, r20
    a840:	a9 01       	movw	r20, r18
    a842:	2f ef       	ldi	r18, 0xFF	; 255
    a844:	08 e0       	ldi	r16, 0x08	; 8
    a846:	10 e0       	ldi	r17, 0x00	; 0
    a848:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
    a84c:	88 23       	and	r24, r24
    a84e:	91 f7       	brne	.-28     	; 0xa834 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a850:	19 82       	std	Y+1, r1	; 0x01
    a852:	1a 82       	std	Y+2, r1	; 0x02
    a854:	4b c0       	rjmp	.+150    	; 0xa8ec <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a856:	8f ef       	ldi	r24, 0xFF	; 255
    a858:	80 93 9f 50 	sts	0x509F, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a85c:	05 c0       	rjmp	.+10     	; 0xa868 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a85e:	8f ef       	ldi	r24, 0xFF	; 255
    a860:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a864:	80 93 9f 50 	sts	0x509F, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a868:	80 91 9f 50 	lds	r24, 0x509F
    a86c:	8e 3f       	cpi	r24, 0xFE	; 254
    a86e:	b9 f7       	brne	.-18     	; 0xa85e <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a870:	1b 82       	std	Y+3, r1	; 0x03
    a872:	1c 82       	std	Y+4, r1	; 0x04
    a874:	19 c0       	rjmp	.+50     	; 0xa8a8 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a876:	89 81       	ldd	r24, Y+1	; 0x01
    a878:	9a 81       	ldd	r25, Y+2	; 0x02
    a87a:	9c 01       	movw	r18, r24
    a87c:	32 2f       	mov	r19, r18
    a87e:	22 27       	eor	r18, r18
    a880:	33 0f       	add	r19, r19
    a882:	8b 81       	ldd	r24, Y+3	; 0x03
    a884:	9c 81       	ldd	r25, Y+4	; 0x04
    a886:	82 0f       	add	r24, r18
    a888:	93 1f       	adc	r25, r19
    a88a:	2b 85       	ldd	r18, Y+11	; 0x0b
    a88c:	3c 85       	ldd	r19, Y+12	; 0x0c
    a88e:	89 01       	movw	r16, r18
    a890:	08 0f       	add	r16, r24
    a892:	19 1f       	adc	r17, r25
    a894:	8f ef       	ldi	r24, 0xFF	; 255
    a896:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a89a:	f8 01       	movw	r30, r16
    a89c:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a89e:	8b 81       	ldd	r24, Y+3	; 0x03
    a8a0:	9c 81       	ldd	r25, Y+4	; 0x04
    a8a2:	01 96       	adiw	r24, 0x01	; 1
    a8a4:	8b 83       	std	Y+3, r24	; 0x03
    a8a6:	9c 83       	std	Y+4, r25	; 0x04
    a8a8:	8b 81       	ldd	r24, Y+3	; 0x03
    a8aa:	9c 81       	ldd	r25, Y+4	; 0x04
    a8ac:	f2 e0       	ldi	r31, 0x02	; 2
    a8ae:	80 30       	cpi	r24, 0x00	; 0
    a8b0:	9f 07       	cpc	r25, r31
    a8b2:	0c f3       	brlt	.-62     	; 0xa876 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a8b4:	1d 82       	std	Y+5, r1	; 0x05
    a8b6:	1e 82       	std	Y+6, r1	; 0x06
    a8b8:	0f c0       	rjmp	.+30     	; 0xa8d8 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a8ba:	8f ef       	ldi	r24, 0xFF	; 255
    a8bc:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a8c0:	28 2f       	mov	r18, r24
    a8c2:	8d 81       	ldd	r24, Y+5	; 0x05
    a8c4:	9e 81       	ldd	r25, Y+6	; 0x06
    a8c6:	82 56       	subi	r24, 0x62	; 98
    a8c8:	9f 4a       	sbci	r25, 0xAF	; 175
    a8ca:	fc 01       	movw	r30, r24
    a8cc:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a8ce:	8d 81       	ldd	r24, Y+5	; 0x05
    a8d0:	9e 81       	ldd	r25, Y+6	; 0x06
    a8d2:	01 96       	adiw	r24, 0x01	; 1
    a8d4:	8d 83       	std	Y+5, r24	; 0x05
    a8d6:	9e 83       	std	Y+6, r25	; 0x06
    a8d8:	8d 81       	ldd	r24, Y+5	; 0x05
    a8da:	9e 81       	ldd	r25, Y+6	; 0x06
    a8dc:	82 30       	cpi	r24, 0x02	; 2
    a8de:	91 05       	cpc	r25, r1
    a8e0:	64 f3       	brlt	.-40     	; 0xa8ba <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a8e2:	89 81       	ldd	r24, Y+1	; 0x01
    a8e4:	9a 81       	ldd	r25, Y+2	; 0x02
    a8e6:	01 96       	adiw	r24, 0x01	; 1
    a8e8:	89 83       	std	Y+1, r24	; 0x01
    a8ea:	9a 83       	std	Y+2, r25	; 0x02
    a8ec:	29 81       	ldd	r18, Y+1	; 0x01
    a8ee:	3a 81       	ldd	r19, Y+2	; 0x02
    a8f0:	8d 85       	ldd	r24, Y+13	; 0x0d
    a8f2:	9e 85       	ldd	r25, Y+14	; 0x0e
    a8f4:	28 17       	cp	r18, r24
    a8f6:	39 07       	cpc	r19, r25
    a8f8:	0c f4       	brge	.+2      	; 0xa8fc <SD_read_multiple_blocks+0x100>
    a8fa:	ad cf       	rjmp	.-166    	; 0xa856 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a8fc:	8c e0       	ldi	r24, 0x0C	; 12
    a8fe:	40 e0       	ldi	r20, 0x00	; 0
    a900:	50 e0       	ldi	r21, 0x00	; 0
    a902:	ba 01       	movw	r22, r20
    a904:	2f ef       	ldi	r18, 0xFF	; 255
    a906:	08 e0       	ldi	r16, 0x08	; 8
    a908:	10 e0       	ldi	r17, 0x00	; 0
    a90a:	0e 94 de 50 	call	0xa1bc	; 0xa1bc <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a90e:	8f ef       	ldi	r24, 0xFF	; 255
    a910:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a914:	80 93 9e 50 	sts	0x509E, r24
	Buffer[1] = FILLER_BYTE;
    a918:	10 92 9f 50 	sts	0x509F, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a91c:	05 c0       	rjmp	.+10     	; 0xa928 <SD_read_multiple_blocks+0x12c>
    a91e:	8f ef       	ldi	r24, 0xFF	; 255
    a920:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
    a924:	80 93 9f 50 	sts	0x509F, r24
    a928:	80 91 9f 50 	lds	r24, 0x509F
    a92c:	8f 3f       	cpi	r24, 0xFF	; 255
    a92e:	b9 f7       	brne	.-18     	; 0xa91e <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a930:	80 e0       	ldi	r24, 0x00	; 0
    a932:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    a936:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a93a:	88 e0       	ldi	r24, 0x08	; 8
    a93c:	60 e0       	ldi	r22, 0x00	; 0
    a93e:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
}
    a942:	2e 96       	adiw	r28, 0x0e	; 14
    a944:	cd bf       	out	0x3d, r28	; 61
    a946:	de bf       	out	0x3e, r29	; 62
    a948:	df 91       	pop	r29
    a94a:	cf 91       	pop	r28
    a94c:	1f 91       	pop	r17
    a94e:	0f 91       	pop	r16
    a950:	08 95       	ret

0000a952 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a952:	cf 93       	push	r28
    a954:	df 93       	push	r29
    a956:	cd b7       	in	r28, 0x3d	; 61
    a958:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a95a:	88 e0       	ldi	r24, 0x08	; 8
    a95c:	60 e0       	ldi	r22, 0x00	; 0
    a95e:	0e 94 42 36 	call	0x6c84	; 0x6c84 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a962:	88 e0       	ldi	r24, 0x08	; 8
    a964:	60 e0       	ldi	r22, 0x00	; 0
    a966:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a96a:	80 e0       	ldi	r24, 0x00	; 0
    a96c:	0e 94 de 3a 	call	0x75bc	; 0x75bc <SPIInit>
	SPICS(TRUE);
    a970:	81 e0       	ldi	r24, 0x01	; 1
    a972:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a976:	8f ef       	ldi	r24, 0xFF	; 255
    a978:	0e 94 c0 50 	call	0xa180	; 0xa180 <SPI_write>
	SPICS(FALSE);	//stop spi
    a97c:	80 e0       	ldi	r24, 0x00	; 0
    a97e:	0e 94 33 3b 	call	0x7666	; 0x7666 <SPICS>
	SPIDisable();
    a982:	0e 94 4b 3b 	call	0x7696	; 0x7696 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a986:	80 e0       	ldi	r24, 0x00	; 0
    a988:	0e 94 66 08 	call	0x10cc	; 0x10cc <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a98c:	80 e0       	ldi	r24, 0x00	; 0
    a98e:	0e 94 d8 37 	call	0x6fb0	; 0x6fb0 <Ext1Power>
}
    a992:	df 91       	pop	r29
    a994:	cf 91       	pop	r28
    a996:	08 95       	ret

0000a998 <__muldi3>:
    a998:	a0 e3       	ldi	r26, 0x30	; 48
    a99a:	b0 e0       	ldi	r27, 0x00	; 0
    a99c:	e2 ed       	ldi	r30, 0xD2	; 210
    a99e:	f4 e5       	ldi	r31, 0x54	; 84
    a9a0:	0c 94 d2 60 	jmp	0xc1a4	; 0xc1a4 <__prologue_saves__+0x4>
    a9a4:	29 8f       	std	Y+25, r18	; 0x19
    a9a6:	3a 8f       	std	Y+26, r19	; 0x1a
    a9a8:	4b 8f       	std	Y+27, r20	; 0x1b
    a9aa:	5c 8f       	std	Y+28, r21	; 0x1c
    a9ac:	6d 8f       	std	Y+29, r22	; 0x1d
    a9ae:	7e 8f       	std	Y+30, r23	; 0x1e
    a9b0:	8f 8f       	std	Y+31, r24	; 0x1f
    a9b2:	98 a3       	lds	r25, 0x58
    a9b4:	a9 8a       	std	Y+17, r10	; 0x11
    a9b6:	ba 8a       	std	Y+18, r11	; 0x12
    a9b8:	cb 8a       	std	Y+19, r12	; 0x13
    a9ba:	dc 8a       	std	Y+20, r13	; 0x14
    a9bc:	ed 8a       	std	Y+21, r14	; 0x15
    a9be:	fe 8a       	std	Y+22, r15	; 0x16
    a9c0:	0f 8b       	std	Y+23, r16	; 0x17
    a9c2:	18 8f       	std	Y+24, r17	; 0x18
    a9c4:	09 8d       	ldd	r16, Y+25	; 0x19
    a9c6:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a9c8:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a9ca:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a9cc:	09 a3       	lds	r16, 0x59
    a9ce:	1a a3       	lds	r17, 0x5a
    a9d0:	2b a3       	lds	r18, 0x5b
    a9d2:	3c a3       	lds	r19, 0x5c
    a9d4:	68 01       	movw	r12, r16
    a9d6:	79 01       	movw	r14, r18
    a9d8:	8f ef       	ldi	r24, 0xFF	; 255
    a9da:	9f ef       	ldi	r25, 0xFF	; 255
    a9dc:	a0 e0       	ldi	r26, 0x00	; 0
    a9de:	b0 e0       	ldi	r27, 0x00	; 0
    a9e0:	c8 22       	and	r12, r24
    a9e2:	d9 22       	and	r13, r25
    a9e4:	ea 22       	and	r14, r26
    a9e6:	fb 22       	and	r15, r27
    a9e8:	89 01       	movw	r16, r18
    a9ea:	22 27       	eor	r18, r18
    a9ec:	33 27       	eor	r19, r19
    a9ee:	09 a7       	lds	r16, 0x79
    a9f0:	1a a7       	lds	r17, 0x7a
    a9f2:	2b a7       	lds	r18, 0x7b
    a9f4:	3c a7       	lds	r19, 0x7c
    a9f6:	09 89       	ldd	r16, Y+17	; 0x11
    a9f8:	1a 89       	ldd	r17, Y+18	; 0x12
    a9fa:	2b 89       	ldd	r18, Y+19	; 0x13
    a9fc:	3c 89       	ldd	r19, Y+20	; 0x14
    a9fe:	0d a3       	lds	r16, 0x5d
    aa00:	1e a3       	lds	r17, 0x5e
    aa02:	2f a3       	lds	r18, 0x5f
    aa04:	38 a7       	lds	r19, 0x78
    aa06:	48 01       	movw	r8, r16
    aa08:	59 01       	movw	r10, r18
    aa0a:	88 22       	and	r8, r24
    aa0c:	99 22       	and	r9, r25
    aa0e:	aa 22       	and	r10, r26
    aa10:	bb 22       	and	r11, r27
    aa12:	29 01       	movw	r4, r18
    aa14:	66 24       	eor	r6, r6
    aa16:	77 24       	eor	r7, r7
    aa18:	c5 01       	movw	r24, r10
    aa1a:	b4 01       	movw	r22, r8
    aa1c:	a7 01       	movw	r20, r14
    aa1e:	96 01       	movw	r18, r12
    aa20:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    aa24:	6d a7       	lds	r22, 0x7d
    aa26:	7e a7       	lds	r23, 0x7e
    aa28:	8f a7       	lds	r24, 0x7f
    aa2a:	98 ab       	sts	0x58, r25
    aa2c:	c3 01       	movw	r24, r6
    aa2e:	b2 01       	movw	r22, r4
    aa30:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    aa34:	6b 01       	movw	r12, r22
    aa36:	7c 01       	movw	r14, r24
    aa38:	c5 01       	movw	r24, r10
    aa3a:	b4 01       	movw	r22, r8
    aa3c:	29 a5       	lds	r18, 0x69
    aa3e:	3a a5       	lds	r19, 0x6a
    aa40:	4b a5       	lds	r20, 0x6b
    aa42:	5c a5       	lds	r21, 0x6c
    aa44:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    aa48:	4b 01       	movw	r8, r22
    aa4a:	5c 01       	movw	r10, r24
    aa4c:	c3 01       	movw	r24, r6
    aa4e:	b2 01       	movw	r22, r4
    aa50:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    aa54:	ab 01       	movw	r20, r22
    aa56:	bc 01       	movw	r22, r24
    aa58:	c8 0c       	add	r12, r8
    aa5a:	d9 1c       	adc	r13, r9
    aa5c:	ea 1c       	adc	r14, r10
    aa5e:	fb 1c       	adc	r15, r11
    aa60:	0d a5       	lds	r16, 0x6d
    aa62:	1e a5       	lds	r17, 0x6e
    aa64:	2f a5       	lds	r18, 0x6f
    aa66:	38 a9       	sts	0x48, r19
    aa68:	c9 01       	movw	r24, r18
    aa6a:	aa 27       	eor	r26, r26
    aa6c:	bb 27       	eor	r27, r27
    aa6e:	c8 0e       	add	r12, r24
    aa70:	d9 1e       	adc	r13, r25
    aa72:	ea 1e       	adc	r14, r26
    aa74:	fb 1e       	adc	r15, r27
    aa76:	c8 14       	cp	r12, r8
    aa78:	d9 04       	cpc	r13, r9
    aa7a:	ea 04       	cpc	r14, r10
    aa7c:	fb 04       	cpc	r15, r11
    aa7e:	20 f4       	brcc	.+8      	; 0xaa88 <__muldi3+0xf0>
    aa80:	40 50       	subi	r20, 0x00	; 0
    aa82:	50 40       	sbci	r21, 0x00	; 0
    aa84:	6f 4f       	sbci	r22, 0xFF	; 255
    aa86:	7f 4f       	sbci	r23, 0xFF	; 255
    aa88:	c7 01       	movw	r24, r14
    aa8a:	aa 27       	eor	r26, r26
    aa8c:	bb 27       	eor	r27, r27
    aa8e:	84 0f       	add	r24, r20
    aa90:	95 1f       	adc	r25, r21
    aa92:	a6 1f       	adc	r26, r22
    aa94:	b7 1f       	adc	r27, r23
    aa96:	8d 83       	std	Y+5, r24	; 0x05
    aa98:	9e 83       	std	Y+6, r25	; 0x06
    aa9a:	af 83       	std	Y+7, r26	; 0x07
    aa9c:	b8 87       	std	Y+8, r27	; 0x08
    aa9e:	76 01       	movw	r14, r12
    aaa0:	dd 24       	eor	r13, r13
    aaa2:	cc 24       	eor	r12, r12
    aaa4:	4d a5       	lds	r20, 0x6d
    aaa6:	5e a5       	lds	r21, 0x6e
    aaa8:	6f a5       	lds	r22, 0x6f
    aaaa:	78 a9       	sts	0x48, r23
    aaac:	60 70       	andi	r22, 0x00	; 0
    aaae:	70 70       	andi	r23, 0x00	; 0
    aab0:	c4 0e       	add	r12, r20
    aab2:	d5 1e       	adc	r13, r21
    aab4:	e6 1e       	adc	r14, r22
    aab6:	f7 1e       	adc	r15, r23
    aab8:	c9 82       	std	Y+1, r12	; 0x01
    aaba:	da 82       	std	Y+2, r13	; 0x02
    aabc:	eb 82       	std	Y+3, r14	; 0x03
    aabe:	fc 82       	std	Y+4, r15	; 0x04
    aac0:	1c 2d       	mov	r17, r12
    aac2:	0a 81       	ldd	r16, Y+2	; 0x02
    aac4:	8b 80       	ldd	r8, Y+3	; 0x03
    aac6:	4c 80       	ldd	r4, Y+4	; 0x04
    aac8:	8d 87       	std	Y+13, r24	; 0x0d
    aaca:	8e 81       	ldd	r24, Y+6	; 0x06
    aacc:	8e 87       	std	Y+14, r24	; 0x0e
    aace:	8f 81       	ldd	r24, Y+7	; 0x07
    aad0:	8f 87       	std	Y+15, r24	; 0x0f
    aad2:	88 85       	ldd	r24, Y+8	; 0x08
    aad4:	88 8b       	std	Y+16, r24	; 0x10
    aad6:	2d 89       	ldd	r18, Y+21	; 0x15
    aad8:	3e 89       	ldd	r19, Y+22	; 0x16
    aada:	4f 89       	ldd	r20, Y+23	; 0x17
    aadc:	58 8d       	ldd	r21, Y+24	; 0x18
    aade:	69 a1       	lds	r22, 0x49
    aae0:	7a a1       	lds	r23, 0x4a
    aae2:	8b a1       	lds	r24, 0x4b
    aae4:	9c a1       	lds	r25, 0x4c
    aae6:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    aaea:	6b 01       	movw	r12, r22
    aaec:	7c 01       	movw	r14, r24
    aaee:	2d 8d       	ldd	r18, Y+29	; 0x1d
    aaf0:	3e 8d       	ldd	r19, Y+30	; 0x1e
    aaf2:	4f 8d       	ldd	r20, Y+31	; 0x1f
    aaf4:	58 a1       	lds	r21, 0x48
    aaf6:	6d a1       	lds	r22, 0x4d
    aaf8:	7e a1       	lds	r23, 0x4e
    aafa:	8f a1       	lds	r24, 0x4f
    aafc:	98 a5       	lds	r25, 0x68
    aafe:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    ab02:	dc 01       	movw	r26, r24
    ab04:	cb 01       	movw	r24, r22
    ab06:	c8 0e       	add	r12, r24
    ab08:	d9 1e       	adc	r13, r25
    ab0a:	ea 1e       	adc	r14, r26
    ab0c:	fb 1e       	adc	r15, r27
    ab0e:	8d 85       	ldd	r24, Y+13	; 0x0d
    ab10:	9e 85       	ldd	r25, Y+14	; 0x0e
    ab12:	af 85       	ldd	r26, Y+15	; 0x0f
    ab14:	b8 89       	ldd	r27, Y+16	; 0x10
    ab16:	8c 0d       	add	r24, r12
    ab18:	9d 1d       	adc	r25, r13
    ab1a:	ae 1d       	adc	r26, r14
    ab1c:	bf 1d       	adc	r27, r15
    ab1e:	8d 87       	std	Y+13, r24	; 0x0d
    ab20:	9e 87       	std	Y+14, r25	; 0x0e
    ab22:	af 87       	std	Y+15, r26	; 0x0f
    ab24:	b8 8b       	std	Y+16, r27	; 0x10
    ab26:	68 2f       	mov	r22, r24
    ab28:	7e 85       	ldd	r23, Y+14	; 0x0e
    ab2a:	21 2f       	mov	r18, r17
    ab2c:	30 2f       	mov	r19, r16
    ab2e:	48 2d       	mov	r20, r8
    ab30:	54 2d       	mov	r21, r4
    ab32:	8f 85       	ldd	r24, Y+15	; 0x0f
    ab34:	98 89       	ldd	r25, Y+16	; 0x10
    ab36:	e0 96       	adiw	r28, 0x30	; 48
    ab38:	e0 e1       	ldi	r30, 0x10	; 16
    ab3a:	0c 94 eb 60 	jmp	0xc1d6	; 0xc1d6 <__epilogue_restores__+0x4>

0000ab3e <__ashldi3>:
    ab3e:	cf 92       	push	r12
    ab40:	df 92       	push	r13
    ab42:	ef 92       	push	r14
    ab44:	ff 92       	push	r15
    ab46:	0f 93       	push	r16
    ab48:	cf 93       	push	r28
    ab4a:	df 93       	push	r29
    ab4c:	cd b7       	in	r28, 0x3d	; 61
    ab4e:	de b7       	in	r29, 0x3e	; 62
    ab50:	60 97       	sbiw	r28, 0x10	; 16
    ab52:	cd bf       	out	0x3d, r28	; 61
    ab54:	de bf       	out	0x3e, r29	; 62
    ab56:	00 23       	and	r16, r16
    ab58:	09 f4       	brne	.+2      	; 0xab5c <__ashldi3+0x1e>
    ab5a:	5a c0       	rjmp	.+180    	; 0xac10 <__ashldi3+0xd2>
    ab5c:	29 87       	std	Y+9, r18	; 0x09
    ab5e:	3a 87       	std	Y+10, r19	; 0x0a
    ab60:	4b 87       	std	Y+11, r20	; 0x0b
    ab62:	5c 87       	std	Y+12, r21	; 0x0c
    ab64:	6d 87       	std	Y+13, r22	; 0x0d
    ab66:	7e 87       	std	Y+14, r23	; 0x0e
    ab68:	8f 87       	std	Y+15, r24	; 0x0f
    ab6a:	98 8b       	std	Y+16, r25	; 0x10
    ab6c:	80 e2       	ldi	r24, 0x20	; 32
    ab6e:	80 1b       	sub	r24, r16
    ab70:	49 85       	ldd	r20, Y+9	; 0x09
    ab72:	5a 85       	ldd	r21, Y+10	; 0x0a
    ab74:	6b 85       	ldd	r22, Y+11	; 0x0b
    ab76:	7c 85       	ldd	r23, Y+12	; 0x0c
    ab78:	18 16       	cp	r1, r24
    ab7a:	b4 f0       	brlt	.+44     	; 0xaba8 <__ashldi3+0x6a>
    ab7c:	19 82       	std	Y+1, r1	; 0x01
    ab7e:	1a 82       	std	Y+2, r1	; 0x02
    ab80:	1b 82       	std	Y+3, r1	; 0x03
    ab82:	1c 82       	std	Y+4, r1	; 0x04
    ab84:	99 27       	eor	r25, r25
    ab86:	87 fd       	sbrc	r24, 7
    ab88:	90 95       	com	r25
    ab8a:	90 95       	com	r25
    ab8c:	81 95       	neg	r24
    ab8e:	9f 4f       	sbci	r25, 0xFF	; 255
    ab90:	04 c0       	rjmp	.+8      	; 0xab9a <__ashldi3+0x5c>
    ab92:	44 0f       	add	r20, r20
    ab94:	55 1f       	adc	r21, r21
    ab96:	66 1f       	adc	r22, r22
    ab98:	77 1f       	adc	r23, r23
    ab9a:	8a 95       	dec	r24
    ab9c:	d2 f7       	brpl	.-12     	; 0xab92 <__ashldi3+0x54>
    ab9e:	4d 83       	std	Y+5, r20	; 0x05
    aba0:	5e 83       	std	Y+6, r21	; 0x06
    aba2:	6f 83       	std	Y+7, r22	; 0x07
    aba4:	78 87       	std	Y+8, r23	; 0x08
    aba6:	2c c0       	rjmp	.+88     	; 0xac00 <__ashldi3+0xc2>
    aba8:	6a 01       	movw	r12, r20
    abaa:	7b 01       	movw	r14, r22
    abac:	00 2e       	mov	r0, r16
    abae:	04 c0       	rjmp	.+8      	; 0xabb8 <__ashldi3+0x7a>
    abb0:	cc 0c       	add	r12, r12
    abb2:	dd 1c       	adc	r13, r13
    abb4:	ee 1c       	adc	r14, r14
    abb6:	ff 1c       	adc	r15, r15
    abb8:	0a 94       	dec	r0
    abba:	d2 f7       	brpl	.-12     	; 0xabb0 <__ashldi3+0x72>
    abbc:	c9 82       	std	Y+1, r12	; 0x01
    abbe:	da 82       	std	Y+2, r13	; 0x02
    abc0:	eb 82       	std	Y+3, r14	; 0x03
    abc2:	fc 82       	std	Y+4, r15	; 0x04
    abc4:	6a 01       	movw	r12, r20
    abc6:	7b 01       	movw	r14, r22
    abc8:	04 c0       	rjmp	.+8      	; 0xabd2 <__ashldi3+0x94>
    abca:	f6 94       	lsr	r15
    abcc:	e7 94       	ror	r14
    abce:	d7 94       	ror	r13
    abd0:	c7 94       	ror	r12
    abd2:	8a 95       	dec	r24
    abd4:	d2 f7       	brpl	.-12     	; 0xabca <__ashldi3+0x8c>
    abd6:	d7 01       	movw	r26, r14
    abd8:	c6 01       	movw	r24, r12
    abda:	4d 85       	ldd	r20, Y+13	; 0x0d
    abdc:	5e 85       	ldd	r21, Y+14	; 0x0e
    abde:	6f 85       	ldd	r22, Y+15	; 0x0f
    abe0:	78 89       	ldd	r23, Y+16	; 0x10
    abe2:	04 c0       	rjmp	.+8      	; 0xabec <__ashldi3+0xae>
    abe4:	44 0f       	add	r20, r20
    abe6:	55 1f       	adc	r21, r21
    abe8:	66 1f       	adc	r22, r22
    abea:	77 1f       	adc	r23, r23
    abec:	0a 95       	dec	r16
    abee:	d2 f7       	brpl	.-12     	; 0xabe4 <__ashldi3+0xa6>
    abf0:	84 2b       	or	r24, r20
    abf2:	95 2b       	or	r25, r21
    abf4:	a6 2b       	or	r26, r22
    abf6:	b7 2b       	or	r27, r23
    abf8:	8d 83       	std	Y+5, r24	; 0x05
    abfa:	9e 83       	std	Y+6, r25	; 0x06
    abfc:	af 83       	std	Y+7, r26	; 0x07
    abfe:	b8 87       	std	Y+8, r27	; 0x08
    ac00:	29 81       	ldd	r18, Y+1	; 0x01
    ac02:	3a 81       	ldd	r19, Y+2	; 0x02
    ac04:	4b 81       	ldd	r20, Y+3	; 0x03
    ac06:	5c 81       	ldd	r21, Y+4	; 0x04
    ac08:	6d 81       	ldd	r22, Y+5	; 0x05
    ac0a:	7e 81       	ldd	r23, Y+6	; 0x06
    ac0c:	8f 81       	ldd	r24, Y+7	; 0x07
    ac0e:	98 85       	ldd	r25, Y+8	; 0x08
    ac10:	60 96       	adiw	r28, 0x10	; 16
    ac12:	cd bf       	out	0x3d, r28	; 61
    ac14:	de bf       	out	0x3e, r29	; 62
    ac16:	df 91       	pop	r29
    ac18:	cf 91       	pop	r28
    ac1a:	0f 91       	pop	r16
    ac1c:	ff 90       	pop	r15
    ac1e:	ef 90       	pop	r14
    ac20:	df 90       	pop	r13
    ac22:	cf 90       	pop	r12
    ac24:	08 95       	ret

0000ac26 <__ashrdi3>:
    ac26:	0f 93       	push	r16
    ac28:	cf 93       	push	r28
    ac2a:	df 93       	push	r29
    ac2c:	cd b7       	in	r28, 0x3d	; 61
    ac2e:	de b7       	in	r29, 0x3e	; 62
    ac30:	60 97       	sbiw	r28, 0x10	; 16
    ac32:	cd bf       	out	0x3d, r28	; 61
    ac34:	de bf       	out	0x3e, r29	; 62
    ac36:	00 23       	and	r16, r16
    ac38:	09 f4       	brne	.+2      	; 0xac3c <__ashrdi3+0x16>
    ac3a:	56 c0       	rjmp	.+172    	; 0xace8 <__ashrdi3+0xc2>
    ac3c:	29 87       	std	Y+9, r18	; 0x09
    ac3e:	3a 87       	std	Y+10, r19	; 0x0a
    ac40:	4b 87       	std	Y+11, r20	; 0x0b
    ac42:	5c 87       	std	Y+12, r21	; 0x0c
    ac44:	6d 87       	std	Y+13, r22	; 0x0d
    ac46:	7e 87       	std	Y+14, r23	; 0x0e
    ac48:	8f 87       	std	Y+15, r24	; 0x0f
    ac4a:	98 8b       	std	Y+16, r25	; 0x10
    ac4c:	20 e2       	ldi	r18, 0x20	; 32
    ac4e:	20 1b       	sub	r18, r16
    ac50:	8d 85       	ldd	r24, Y+13	; 0x0d
    ac52:	9e 85       	ldd	r25, Y+14	; 0x0e
    ac54:	af 85       	ldd	r26, Y+15	; 0x0f
    ac56:	b8 89       	ldd	r27, Y+16	; 0x10
    ac58:	ac 01       	movw	r20, r24
    ac5a:	bd 01       	movw	r22, r26
    ac5c:	12 16       	cp	r1, r18
    ac5e:	b4 f0       	brlt	.+44     	; 0xac8c <__ashrdi3+0x66>
    ac60:	77 0f       	add	r23, r23
    ac62:	44 0b       	sbc	r20, r20
    ac64:	54 2f       	mov	r21, r20
    ac66:	ba 01       	movw	r22, r20
    ac68:	4d 83       	std	Y+5, r20	; 0x05
    ac6a:	5e 83       	std	Y+6, r21	; 0x06
    ac6c:	6f 83       	std	Y+7, r22	; 0x07
    ac6e:	78 87       	std	Y+8, r23	; 0x08
    ac70:	33 27       	eor	r19, r19
    ac72:	27 fd       	sbrc	r18, 7
    ac74:	30 95       	com	r19
    ac76:	30 95       	com	r19
    ac78:	21 95       	neg	r18
    ac7a:	3f 4f       	sbci	r19, 0xFF	; 255
    ac7c:	04 c0       	rjmp	.+8      	; 0xac86 <__ashrdi3+0x60>
    ac7e:	b5 95       	asr	r27
    ac80:	a7 95       	ror	r26
    ac82:	97 95       	ror	r25
    ac84:	87 95       	ror	r24
    ac86:	2a 95       	dec	r18
    ac88:	d2 f7       	brpl	.-12     	; 0xac7e <__ashrdi3+0x58>
    ac8a:	22 c0       	rjmp	.+68     	; 0xacd0 <__ashrdi3+0xaa>
    ac8c:	00 2e       	mov	r0, r16
    ac8e:	04 c0       	rjmp	.+8      	; 0xac98 <__ashrdi3+0x72>
    ac90:	75 95       	asr	r23
    ac92:	67 95       	ror	r22
    ac94:	57 95       	ror	r21
    ac96:	47 95       	ror	r20
    ac98:	0a 94       	dec	r0
    ac9a:	d2 f7       	brpl	.-12     	; 0xac90 <__ashrdi3+0x6a>
    ac9c:	4d 83       	std	Y+5, r20	; 0x05
    ac9e:	5e 83       	std	Y+6, r21	; 0x06
    aca0:	6f 83       	std	Y+7, r22	; 0x07
    aca2:	78 87       	std	Y+8, r23	; 0x08
    aca4:	04 c0       	rjmp	.+8      	; 0xacae <__ashrdi3+0x88>
    aca6:	88 0f       	add	r24, r24
    aca8:	99 1f       	adc	r25, r25
    acaa:	aa 1f       	adc	r26, r26
    acac:	bb 1f       	adc	r27, r27
    acae:	2a 95       	dec	r18
    acb0:	d2 f7       	brpl	.-12     	; 0xaca6 <__ashrdi3+0x80>
    acb2:	49 85       	ldd	r20, Y+9	; 0x09
    acb4:	5a 85       	ldd	r21, Y+10	; 0x0a
    acb6:	6b 85       	ldd	r22, Y+11	; 0x0b
    acb8:	7c 85       	ldd	r23, Y+12	; 0x0c
    acba:	04 c0       	rjmp	.+8      	; 0xacc4 <__ashrdi3+0x9e>
    acbc:	76 95       	lsr	r23
    acbe:	67 95       	ror	r22
    acc0:	57 95       	ror	r21
    acc2:	47 95       	ror	r20
    acc4:	0a 95       	dec	r16
    acc6:	d2 f7       	brpl	.-12     	; 0xacbc <__ashrdi3+0x96>
    acc8:	84 2b       	or	r24, r20
    acca:	95 2b       	or	r25, r21
    accc:	a6 2b       	or	r26, r22
    acce:	b7 2b       	or	r27, r23
    acd0:	89 83       	std	Y+1, r24	; 0x01
    acd2:	9a 83       	std	Y+2, r25	; 0x02
    acd4:	ab 83       	std	Y+3, r26	; 0x03
    acd6:	bc 83       	std	Y+4, r27	; 0x04
    acd8:	29 81       	ldd	r18, Y+1	; 0x01
    acda:	3a 81       	ldd	r19, Y+2	; 0x02
    acdc:	4b 81       	ldd	r20, Y+3	; 0x03
    acde:	5c 81       	ldd	r21, Y+4	; 0x04
    ace0:	6d 81       	ldd	r22, Y+5	; 0x05
    ace2:	7e 81       	ldd	r23, Y+6	; 0x06
    ace4:	8f 81       	ldd	r24, Y+7	; 0x07
    ace6:	98 85       	ldd	r25, Y+8	; 0x08
    ace8:	60 96       	adiw	r28, 0x10	; 16
    acea:	cd bf       	out	0x3d, r28	; 61
    acec:	de bf       	out	0x3e, r29	; 62
    acee:	df 91       	pop	r29
    acf0:	cf 91       	pop	r28
    acf2:	0f 91       	pop	r16
    acf4:	08 95       	ret

0000acf6 <__divdi3>:
    acf6:	a8 e4       	ldi	r26, 0x48	; 72
    acf8:	b0 e0       	ldi	r27, 0x00	; 0
    acfa:	e1 e8       	ldi	r30, 0x81	; 129
    acfc:	f6 e5       	ldi	r31, 0x56	; 86
    acfe:	0c 94 d1 60 	jmp	0xc1a2	; 0xc1a2 <__prologue_saves__+0x2>
    ad02:	f5 01       	movw	r30, r10
    ad04:	29 a3       	lds	r18, 0x59
    ad06:	3a a3       	lds	r19, 0x5a
    ad08:	4b a3       	lds	r20, 0x5b
    ad0a:	5c a3       	lds	r21, 0x5c
    ad0c:	6d a3       	lds	r22, 0x5d
    ad0e:	7e a3       	lds	r23, 0x5e
    ad10:	8f a3       	lds	r24, 0x5f
    ad12:	98 a7       	lds	r25, 0x78
    ad14:	a9 8e       	std	Y+25, r10	; 0x19
    ad16:	fa 8f       	std	Y+26, r31	; 0x1a
    ad18:	cb 8e       	std	Y+27, r12	; 0x1b
    ad1a:	dc 8e       	std	Y+28, r13	; 0x1c
    ad1c:	ed 8e       	std	Y+29, r14	; 0x1d
    ad1e:	fe 8e       	std	Y+30, r15	; 0x1e
    ad20:	0f 8f       	std	Y+31, r16	; 0x1f
    ad22:	18 a3       	lds	r17, 0x58
    ad24:	8d a0       	lds	r24, 0x8d
    ad26:	9e a0       	lds	r25, 0x8e
    ad28:	af a0       	lds	r26, 0x8f
    ad2a:	b8 a4       	lds	r27, 0xa8
    ad2c:	b7 fe       	sbrs	r11, 7
    ad2e:	67 c0       	rjmp	.+206    	; 0xadfe <__divdi3+0x108>
    ad30:	21 95       	neg	r18
    ad32:	b1 e0       	ldi	r27, 0x01	; 1
    ad34:	12 16       	cp	r1, r18
    ad36:	08 f0       	brcs	.+2      	; 0xad3a <__divdi3+0x44>
    ad38:	b0 e0       	ldi	r27, 0x00	; 0
    ad3a:	31 95       	neg	r19
    ad3c:	a1 e0       	ldi	r26, 0x01	; 1
    ad3e:	13 16       	cp	r1, r19
    ad40:	08 f0       	brcs	.+2      	; 0xad44 <__divdi3+0x4e>
    ad42:	a0 e0       	ldi	r26, 0x00	; 0
    ad44:	b3 2e       	mov	r11, r19
    ad46:	bb 1a       	sub	r11, r27
    ad48:	bb 2d       	mov	r27, r11
    ad4a:	88 24       	eor	r8, r8
    ad4c:	83 94       	inc	r8
    ad4e:	3b 15       	cp	r19, r11
    ad50:	08 f0       	brcs	.+2      	; 0xad54 <__divdi3+0x5e>
    ad52:	88 24       	eor	r8, r8
    ad54:	a8 29       	or	r26, r8
    ad56:	41 95       	neg	r20
    ad58:	31 e0       	ldi	r19, 0x01	; 1
    ad5a:	14 16       	cp	r1, r20
    ad5c:	08 f0       	brcs	.+2      	; 0xad60 <__divdi3+0x6a>
    ad5e:	30 e0       	ldi	r19, 0x00	; 0
    ad60:	b4 2e       	mov	r11, r20
    ad62:	ba 1a       	sub	r11, r26
    ad64:	ab 2d       	mov	r26, r11
    ad66:	88 24       	eor	r8, r8
    ad68:	83 94       	inc	r8
    ad6a:	4b 15       	cp	r20, r11
    ad6c:	08 f0       	brcs	.+2      	; 0xad70 <__divdi3+0x7a>
    ad6e:	88 24       	eor	r8, r8
    ad70:	38 29       	or	r19, r8
    ad72:	51 95       	neg	r21
    ad74:	41 e0       	ldi	r20, 0x01	; 1
    ad76:	15 16       	cp	r1, r21
    ad78:	08 f0       	brcs	.+2      	; 0xad7c <__divdi3+0x86>
    ad7a:	40 e0       	ldi	r20, 0x00	; 0
    ad7c:	45 2e       	mov	r4, r21
    ad7e:	43 1a       	sub	r4, r19
    ad80:	31 e0       	ldi	r19, 0x01	; 1
    ad82:	54 15       	cp	r21, r4
    ad84:	08 f0       	brcs	.+2      	; 0xad88 <__divdi3+0x92>
    ad86:	30 e0       	ldi	r19, 0x00	; 0
    ad88:	43 2b       	or	r20, r19
    ad8a:	61 95       	neg	r22
    ad8c:	31 e0       	ldi	r19, 0x01	; 1
    ad8e:	16 16       	cp	r1, r22
    ad90:	08 f0       	brcs	.+2      	; 0xad94 <__divdi3+0x9e>
    ad92:	30 e0       	ldi	r19, 0x00	; 0
    ad94:	86 2e       	mov	r8, r22
    ad96:	84 1a       	sub	r8, r20
    ad98:	41 e0       	ldi	r20, 0x01	; 1
    ad9a:	68 15       	cp	r22, r8
    ad9c:	08 f0       	brcs	.+2      	; 0xada0 <__divdi3+0xaa>
    ad9e:	40 e0       	ldi	r20, 0x00	; 0
    ada0:	34 2b       	or	r19, r20
    ada2:	71 95       	neg	r23
    ada4:	41 e0       	ldi	r20, 0x01	; 1
    ada6:	17 16       	cp	r1, r23
    ada8:	08 f0       	brcs	.+2      	; 0xadac <__divdi3+0xb6>
    adaa:	40 e0       	ldi	r20, 0x00	; 0
    adac:	57 2f       	mov	r21, r23
    adae:	53 1b       	sub	r21, r19
    adb0:	31 e0       	ldi	r19, 0x01	; 1
    adb2:	75 17       	cp	r23, r21
    adb4:	08 f0       	brcs	.+2      	; 0xadb8 <__divdi3+0xc2>
    adb6:	30 e0       	ldi	r19, 0x00	; 0
    adb8:	43 2b       	or	r20, r19
    adba:	81 95       	neg	r24
    adbc:	31 e0       	ldi	r19, 0x01	; 1
    adbe:	18 16       	cp	r1, r24
    adc0:	08 f0       	brcs	.+2      	; 0xadc4 <__divdi3+0xce>
    adc2:	30 e0       	ldi	r19, 0x00	; 0
    adc4:	68 2f       	mov	r22, r24
    adc6:	64 1b       	sub	r22, r20
    adc8:	46 2f       	mov	r20, r22
    adca:	61 e0       	ldi	r22, 0x01	; 1
    adcc:	84 17       	cp	r24, r20
    adce:	08 f0       	brcs	.+2      	; 0xadd2 <__divdi3+0xdc>
    add0:	60 e0       	ldi	r22, 0x00	; 0
    add2:	36 2b       	or	r19, r22
    add4:	91 95       	neg	r25
    add6:	93 1b       	sub	r25, r19
    add8:	29 a3       	lds	r18, 0x59
    adda:	ba a3       	lds	r27, 0x5a
    addc:	ab a3       	lds	r26, 0x5b
    adde:	4c a2       	lds	r20, 0x9c
    ade0:	8d a2       	lds	r24, 0x9d
    ade2:	5e a3       	lds	r21, 0x5e
    ade4:	4f a3       	lds	r20, 0x5f
    ade6:	98 a7       	lds	r25, 0x78
    ade8:	8f ef       	ldi	r24, 0xFF	; 255
    adea:	9f ef       	ldi	r25, 0xFF	; 255
    adec:	af ef       	ldi	r26, 0xFF	; 255
    adee:	bf ef       	ldi	r27, 0xFF	; 255
    adf0:	25 96       	adiw	r28, 0x05	; 5
    adf2:	8c af       	sts	0x7c, r24
    adf4:	9d af       	sts	0x7d, r25
    adf6:	ae af       	sts	0x7e, r26
    adf8:	bf af       	sts	0x7f, r27
    adfa:	25 97       	sbiw	r28, 0x05	; 5
    adfc:	06 c0       	rjmp	.+12     	; 0xae0a <__divdi3+0x114>
    adfe:	25 96       	adiw	r28, 0x05	; 5
    ae00:	1c ae       	sts	0xbc, r17
    ae02:	1d ae       	sts	0xbd, r17
    ae04:	1e ae       	sts	0xbe, r17
    ae06:	1f ae       	sts	0xbf, r17
    ae08:	25 97       	sbiw	r28, 0x05	; 5
    ae0a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    ae0c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    ae0e:	af 8d       	ldd	r26, Y+31	; 0x1f
    ae10:	b8 a1       	lds	r27, 0x48
    ae12:	b7 ff       	sbrs	r27, 7
    ae14:	68 c0       	rjmp	.+208    	; 0xaee6 <__divdi3+0x1f0>
    ae16:	25 96       	adiw	r28, 0x05	; 5
    ae18:	2c ad       	sts	0x6c, r18
    ae1a:	3d ad       	sts	0x6d, r19
    ae1c:	4e ad       	sts	0x6e, r20
    ae1e:	5f ad       	sts	0x6f, r21
    ae20:	25 97       	sbiw	r28, 0x05	; 5
    ae22:	20 95       	com	r18
    ae24:	30 95       	com	r19
    ae26:	40 95       	com	r20
    ae28:	50 95       	com	r21
    ae2a:	25 96       	adiw	r28, 0x05	; 5
    ae2c:	2c af       	sts	0x7c, r18
    ae2e:	3d af       	sts	0x7d, r19
    ae30:	4e af       	sts	0x7e, r20
    ae32:	5f af       	sts	0x7f, r21
    ae34:	25 97       	sbiw	r28, 0x05	; 5
    ae36:	e1 95       	neg	r30
    ae38:	81 e0       	ldi	r24, 0x01	; 1
    ae3a:	1e 16       	cp	r1, r30
    ae3c:	08 f0       	brcs	.+2      	; 0xae40 <__divdi3+0x14a>
    ae3e:	80 e0       	ldi	r24, 0x00	; 0
    ae40:	f1 95       	neg	r31
    ae42:	91 e0       	ldi	r25, 0x01	; 1
    ae44:	1f 16       	cp	r1, r31
    ae46:	08 f0       	brcs	.+2      	; 0xae4a <__divdi3+0x154>
    ae48:	90 e0       	ldi	r25, 0x00	; 0
    ae4a:	4f 2f       	mov	r20, r31
    ae4c:	48 1b       	sub	r20, r24
    ae4e:	81 e0       	ldi	r24, 0x01	; 1
    ae50:	f4 17       	cp	r31, r20
    ae52:	08 f0       	brcs	.+2      	; 0xae56 <__divdi3+0x160>
    ae54:	80 e0       	ldi	r24, 0x00	; 0
    ae56:	98 2b       	or	r25, r24
    ae58:	c1 94       	neg	r12
    ae5a:	81 e0       	ldi	r24, 0x01	; 1
    ae5c:	1c 14       	cp	r1, r12
    ae5e:	08 f0       	brcs	.+2      	; 0xae62 <__divdi3+0x16c>
    ae60:	80 e0       	ldi	r24, 0x00	; 0
    ae62:	6c 2d       	mov	r22, r12
    ae64:	69 1b       	sub	r22, r25
    ae66:	91 e0       	ldi	r25, 0x01	; 1
    ae68:	c6 16       	cp	r12, r22
    ae6a:	08 f0       	brcs	.+2      	; 0xae6e <__divdi3+0x178>
    ae6c:	90 e0       	ldi	r25, 0x00	; 0
    ae6e:	89 2b       	or	r24, r25
    ae70:	d1 94       	neg	r13
    ae72:	91 e0       	ldi	r25, 0x01	; 1
    ae74:	1d 14       	cp	r1, r13
    ae76:	08 f0       	brcs	.+2      	; 0xae7a <__divdi3+0x184>
    ae78:	90 e0       	ldi	r25, 0x00	; 0
    ae7a:	5d 2d       	mov	r21, r13
    ae7c:	58 1b       	sub	r21, r24
    ae7e:	81 e0       	ldi	r24, 0x01	; 1
    ae80:	d5 16       	cp	r13, r21
    ae82:	08 f0       	brcs	.+2      	; 0xae86 <__divdi3+0x190>
    ae84:	80 e0       	ldi	r24, 0x00	; 0
    ae86:	98 2b       	or	r25, r24
    ae88:	e1 94       	neg	r14
    ae8a:	81 e0       	ldi	r24, 0x01	; 1
    ae8c:	1e 14       	cp	r1, r14
    ae8e:	08 f0       	brcs	.+2      	; 0xae92 <__divdi3+0x19c>
    ae90:	80 e0       	ldi	r24, 0x00	; 0
    ae92:	3e 2d       	mov	r19, r14
    ae94:	39 1b       	sub	r19, r25
    ae96:	91 e0       	ldi	r25, 0x01	; 1
    ae98:	e3 16       	cp	r14, r19
    ae9a:	08 f0       	brcs	.+2      	; 0xae9e <__divdi3+0x1a8>
    ae9c:	90 e0       	ldi	r25, 0x00	; 0
    ae9e:	89 2b       	or	r24, r25
    aea0:	f1 94       	neg	r15
    aea2:	91 e0       	ldi	r25, 0x01	; 1
    aea4:	1f 14       	cp	r1, r15
    aea6:	08 f0       	brcs	.+2      	; 0xaeaa <__divdi3+0x1b4>
    aea8:	90 e0       	ldi	r25, 0x00	; 0
    aeaa:	2f 2d       	mov	r18, r15
    aeac:	28 1b       	sub	r18, r24
    aeae:	81 e0       	ldi	r24, 0x01	; 1
    aeb0:	f2 16       	cp	r15, r18
    aeb2:	08 f0       	brcs	.+2      	; 0xaeb6 <__divdi3+0x1c0>
    aeb4:	80 e0       	ldi	r24, 0x00	; 0
    aeb6:	98 2b       	or	r25, r24
    aeb8:	01 95       	neg	r16
    aeba:	81 e0       	ldi	r24, 0x01	; 1
    aebc:	10 16       	cp	r1, r16
    aebe:	08 f0       	brcs	.+2      	; 0xaec2 <__divdi3+0x1cc>
    aec0:	80 e0       	ldi	r24, 0x00	; 0
    aec2:	70 2f       	mov	r23, r16
    aec4:	79 1b       	sub	r23, r25
    aec6:	97 2f       	mov	r25, r23
    aec8:	71 e0       	ldi	r23, 0x01	; 1
    aeca:	09 17       	cp	r16, r25
    aecc:	08 f0       	brcs	.+2      	; 0xaed0 <__divdi3+0x1da>
    aece:	70 e0       	ldi	r23, 0x00	; 0
    aed0:	87 2b       	or	r24, r23
    aed2:	11 95       	neg	r17
    aed4:	18 1b       	sub	r17, r24
    aed6:	e9 8f       	std	Y+25, r30	; 0x19
    aed8:	4a 8f       	std	Y+26, r20	; 0x1a
    aeda:	6b 8f       	std	Y+27, r22	; 0x1b
    aedc:	5c 8f       	std	Y+28, r21	; 0x1c
    aede:	3d 8f       	std	Y+29, r19	; 0x1d
    aee0:	2e 8f       	std	Y+30, r18	; 0x1e
    aee2:	9f 8f       	std	Y+31, r25	; 0x1f
    aee4:	18 a3       	lds	r17, 0x58
    aee6:	79 8d       	ldd	r23, Y+25	; 0x19
    aee8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    aeea:	5b 8d       	ldd	r21, Y+27	; 0x1b
    aeec:	4c 8d       	ldd	r20, Y+28	; 0x1c
    aeee:	3d 8d       	ldd	r19, Y+29	; 0x1d
    aef0:	2e 8d       	ldd	r18, Y+30	; 0x1e
    aef2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    aef4:	88 a1       	lds	r24, 0x48
    aef6:	e9 a1       	lds	r30, 0x49
    aef8:	e9 8b       	std	Y+17, r30	; 0x11
    aefa:	ea a1       	lds	r30, 0x4a
    aefc:	ea 8b       	std	Y+18, r30	; 0x12
    aefe:	eb a1       	lds	r30, 0x4b
    af00:	eb 8b       	std	Y+19, r30	; 0x13
    af02:	ec a1       	lds	r30, 0x4c
    af04:	ec 8b       	std	Y+20, r30	; 0x14
    af06:	ed a1       	lds	r30, 0x4d
    af08:	ed 8b       	std	Y+21, r30	; 0x15
    af0a:	ee a1       	lds	r30, 0x4e
    af0c:	ee 8b       	std	Y+22, r30	; 0x16
    af0e:	ef a1       	lds	r30, 0x4f
    af10:	ef 8b       	std	Y+23, r30	; 0x17
    af12:	e8 a5       	lds	r30, 0x68
    af14:	e8 8f       	std	Y+24, r30	; 0x18
    af16:	79 87       	std	Y+9, r23	; 0x09
    af18:	6a 87       	std	Y+10, r22	; 0x0a
    af1a:	5b 87       	std	Y+11, r21	; 0x0b
    af1c:	4c 87       	std	Y+12, r20	; 0x0c
    af1e:	3d 87       	std	Y+13, r19	; 0x0d
    af20:	2e 87       	std	Y+14, r18	; 0x0e
    af22:	9f 87       	std	Y+15, r25	; 0x0f
    af24:	88 8b       	std	Y+16, r24	; 0x10
    af26:	89 84       	ldd	r8, Y+9	; 0x09
    af28:	9a 84       	ldd	r9, Y+10	; 0x0a
    af2a:	ab 84       	ldd	r10, Y+11	; 0x0b
    af2c:	bc 84       	ldd	r11, Y+12	; 0x0c
    af2e:	8d 85       	ldd	r24, Y+13	; 0x0d
    af30:	9e 85       	ldd	r25, Y+14	; 0x0e
    af32:	af 85       	ldd	r26, Y+15	; 0x0f
    af34:	b8 89       	ldd	r27, Y+16	; 0x10
    af36:	e9 88       	ldd	r14, Y+17	; 0x11
    af38:	fa 88       	ldd	r15, Y+18	; 0x12
    af3a:	0b 89       	ldd	r16, Y+19	; 0x13
    af3c:	1c 89       	ldd	r17, Y+20	; 0x14
    af3e:	ed aa       	sts	0x9d, r30
    af40:	fe aa       	sts	0x9e, r31
    af42:	0f ab       	sts	0x5f, r16
    af44:	18 af       	sts	0x78, r17
    af46:	cd 88       	ldd	r12, Y+21	; 0x15
    af48:	de 88       	ldd	r13, Y+22	; 0x16
    af4a:	ef 88       	ldd	r14, Y+23	; 0x17
    af4c:	f8 8c       	ldd	r15, Y+24	; 0x18
    af4e:	00 97       	sbiw	r24, 0x00	; 0
    af50:	a1 05       	cpc	r26, r1
    af52:	b1 05       	cpc	r27, r1
    af54:	09 f0       	breq	.+2      	; 0xaf58 <__divdi3+0x262>
    af56:	bd c3       	rjmp	.+1914   	; 0xb6d2 <__divdi3+0x9dc>
    af58:	c8 14       	cp	r12, r8
    af5a:	d9 04       	cpc	r13, r9
    af5c:	ea 04       	cpc	r14, r10
    af5e:	fb 04       	cpc	r15, r11
    af60:	08 f0       	brcs	.+2      	; 0xaf64 <__divdi3+0x26e>
    af62:	4d c1       	rjmp	.+666    	; 0xb1fe <__divdi3+0x508>
    af64:	00 e0       	ldi	r16, 0x00	; 0
    af66:	80 16       	cp	r8, r16
    af68:	00 e0       	ldi	r16, 0x00	; 0
    af6a:	90 06       	cpc	r9, r16
    af6c:	01 e0       	ldi	r16, 0x01	; 1
    af6e:	a0 06       	cpc	r10, r16
    af70:	00 e0       	ldi	r16, 0x00	; 0
    af72:	b0 06       	cpc	r11, r16
    af74:	58 f4       	brcc	.+22     	; 0xaf8c <__divdi3+0x296>
    af76:	1f ef       	ldi	r17, 0xFF	; 255
    af78:	81 16       	cp	r8, r17
    af7a:	91 04       	cpc	r9, r1
    af7c:	a1 04       	cpc	r10, r1
    af7e:	b1 04       	cpc	r11, r1
    af80:	09 f0       	breq	.+2      	; 0xaf84 <__divdi3+0x28e>
    af82:	90 f4       	brcc	.+36     	; 0xafa8 <__divdi3+0x2b2>
    af84:	80 e0       	ldi	r24, 0x00	; 0
    af86:	90 e0       	ldi	r25, 0x00	; 0
    af88:	dc 01       	movw	r26, r24
    af8a:	17 c0       	rjmp	.+46     	; 0xafba <__divdi3+0x2c4>
    af8c:	20 e0       	ldi	r18, 0x00	; 0
    af8e:	82 16       	cp	r8, r18
    af90:	20 e0       	ldi	r18, 0x00	; 0
    af92:	92 06       	cpc	r9, r18
    af94:	20 e0       	ldi	r18, 0x00	; 0
    af96:	a2 06       	cpc	r10, r18
    af98:	21 e0       	ldi	r18, 0x01	; 1
    af9a:	b2 06       	cpc	r11, r18
    af9c:	50 f4       	brcc	.+20     	; 0xafb2 <__divdi3+0x2bc>
    af9e:	80 e1       	ldi	r24, 0x10	; 16
    afa0:	90 e0       	ldi	r25, 0x00	; 0
    afa2:	a0 e0       	ldi	r26, 0x00	; 0
    afa4:	b0 e0       	ldi	r27, 0x00	; 0
    afa6:	09 c0       	rjmp	.+18     	; 0xafba <__divdi3+0x2c4>
    afa8:	88 e0       	ldi	r24, 0x08	; 8
    afaa:	90 e0       	ldi	r25, 0x00	; 0
    afac:	a0 e0       	ldi	r26, 0x00	; 0
    afae:	b0 e0       	ldi	r27, 0x00	; 0
    afb0:	04 c0       	rjmp	.+8      	; 0xafba <__divdi3+0x2c4>
    afb2:	88 e1       	ldi	r24, 0x18	; 24
    afb4:	90 e0       	ldi	r25, 0x00	; 0
    afb6:	a0 e0       	ldi	r26, 0x00	; 0
    afb8:	b0 e0       	ldi	r27, 0x00	; 0
    afba:	b5 01       	movw	r22, r10
    afbc:	a4 01       	movw	r20, r8
    afbe:	08 2e       	mov	r0, r24
    afc0:	04 c0       	rjmp	.+8      	; 0xafca <__divdi3+0x2d4>
    afc2:	76 95       	lsr	r23
    afc4:	67 95       	ror	r22
    afc6:	57 95       	ror	r21
    afc8:	47 95       	ror	r20
    afca:	0a 94       	dec	r0
    afcc:	d2 f7       	brpl	.-12     	; 0xafc2 <__divdi3+0x2cc>
    afce:	fa 01       	movw	r30, r20
    afd0:	e0 5d       	subi	r30, 0xD0	; 208
    afd2:	ff 4d       	sbci	r31, 0xDF	; 223
    afd4:	20 81       	ld	r18, Z
    afd6:	40 e2       	ldi	r20, 0x20	; 32
    afd8:	50 e0       	ldi	r21, 0x00	; 0
    afda:	60 e0       	ldi	r22, 0x00	; 0
    afdc:	70 e0       	ldi	r23, 0x00	; 0
    afde:	48 1b       	sub	r20, r24
    afe0:	59 0b       	sbc	r21, r25
    afe2:	6a 0b       	sbc	r22, r26
    afe4:	7b 0b       	sbc	r23, r27
    afe6:	42 1b       	sub	r20, r18
    afe8:	51 09       	sbc	r21, r1
    afea:	61 09       	sbc	r22, r1
    afec:	71 09       	sbc	r23, r1
    afee:	41 15       	cp	r20, r1
    aff0:	51 05       	cpc	r21, r1
    aff2:	61 05       	cpc	r22, r1
    aff4:	71 05       	cpc	r23, r1
    aff6:	a1 f1       	breq	.+104    	; 0xb060 <__divdi3+0x36a>
    aff8:	04 2e       	mov	r0, r20
    affa:	04 c0       	rjmp	.+8      	; 0xb004 <__divdi3+0x30e>
    affc:	88 0c       	add	r8, r8
    affe:	99 1c       	adc	r9, r9
    b000:	aa 1c       	adc	r10, r10
    b002:	bb 1c       	adc	r11, r11
    b004:	0a 94       	dec	r0
    b006:	d2 f7       	brpl	.-12     	; 0xaffc <__divdi3+0x306>
    b008:	97 01       	movw	r18, r14
    b00a:	86 01       	movw	r16, r12
    b00c:	04 2e       	mov	r0, r20
    b00e:	04 c0       	rjmp	.+8      	; 0xb018 <__divdi3+0x322>
    b010:	00 0f       	add	r16, r16
    b012:	11 1f       	adc	r17, r17
    b014:	22 1f       	adc	r18, r18
    b016:	33 1f       	adc	r19, r19
    b018:	0a 94       	dec	r0
    b01a:	d2 f7       	brpl	.-12     	; 0xb010 <__divdi3+0x31a>
    b01c:	80 e2       	ldi	r24, 0x20	; 32
    b01e:	90 e0       	ldi	r25, 0x00	; 0
    b020:	84 1b       	sub	r24, r20
    b022:	95 0b       	sbc	r25, r21
    b024:	cd a8       	sts	0x8d, r28
    b026:	de a8       	sts	0x8e, r29
    b028:	ef a8       	sts	0x8f, r30
    b02a:	f8 ac       	sts	0xa8, r31
    b02c:	04 c0       	rjmp	.+8      	; 0xb036 <__divdi3+0x340>
    b02e:	f6 94       	lsr	r15
    b030:	e7 94       	ror	r14
    b032:	d7 94       	ror	r13
    b034:	c7 94       	ror	r12
    b036:	8a 95       	dec	r24
    b038:	d2 f7       	brpl	.-12     	; 0xb02e <__divdi3+0x338>
    b03a:	c0 2a       	or	r12, r16
    b03c:	d1 2a       	or	r13, r17
    b03e:	e2 2a       	or	r14, r18
    b040:	f3 2a       	or	r15, r19
    b042:	0d a9       	sts	0x4d, r16
    b044:	1e a9       	sts	0x4e, r17
    b046:	2f a9       	sts	0x4f, r18
    b048:	38 ad       	sts	0x68, r19
    b04a:	04 c0       	rjmp	.+8      	; 0xb054 <__divdi3+0x35e>
    b04c:	00 0f       	add	r16, r16
    b04e:	11 1f       	adc	r17, r17
    b050:	22 1f       	adc	r18, r18
    b052:	33 1f       	adc	r19, r19
    b054:	4a 95       	dec	r20
    b056:	d2 f7       	brpl	.-12     	; 0xb04c <__divdi3+0x356>
    b058:	0d ab       	sts	0x5d, r16
    b05a:	1e ab       	sts	0x5e, r17
    b05c:	2f ab       	sts	0x5f, r18
    b05e:	38 af       	sts	0x78, r19
    b060:	25 01       	movw	r4, r10
    b062:	66 24       	eor	r6, r6
    b064:	77 24       	eor	r7, r7
    b066:	95 01       	movw	r18, r10
    b068:	84 01       	movw	r16, r8
    b06a:	20 70       	andi	r18, 0x00	; 0
    b06c:	30 70       	andi	r19, 0x00	; 0
    b06e:	09 ab       	sts	0x59, r16
    b070:	1a ab       	sts	0x5a, r17
    b072:	2b ab       	sts	0x5b, r18
    b074:	3c ab       	sts	0x5c, r19
    b076:	c7 01       	movw	r24, r14
    b078:	b6 01       	movw	r22, r12
    b07a:	a3 01       	movw	r20, r6
    b07c:	92 01       	movw	r18, r4
    b07e:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b082:	2d a7       	lds	r18, 0x7d
    b084:	3e a7       	lds	r19, 0x7e
    b086:	4f a7       	lds	r20, 0x7f
    b088:	58 ab       	sts	0x58, r21
    b08a:	69 a7       	lds	r22, 0x79
    b08c:	7a a7       	lds	r23, 0x7a
    b08e:	8b a7       	lds	r24, 0x7b
    b090:	9c a7       	lds	r25, 0x7c
    b092:	c7 01       	movw	r24, r14
    b094:	b6 01       	movw	r22, r12
    b096:	a3 01       	movw	r20, r6
    b098:	92 01       	movw	r18, r4
    b09a:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b09e:	ca 01       	movw	r24, r20
    b0a0:	b9 01       	movw	r22, r18
    b0a2:	29 a9       	sts	0x49, r18
    b0a4:	3a a9       	sts	0x4a, r19
    b0a6:	4b a9       	sts	0x4b, r20
    b0a8:	5c a9       	sts	0x4c, r21
    b0aa:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b0ae:	ab 01       	movw	r20, r22
    b0b0:	bc 01       	movw	r22, r24
    b0b2:	09 a5       	lds	r16, 0x69
    b0b4:	1a a5       	lds	r17, 0x6a
    b0b6:	2b a5       	lds	r18, 0x6b
    b0b8:	3c a5       	lds	r19, 0x6c
    b0ba:	78 01       	movw	r14, r16
    b0bc:	dd 24       	eor	r13, r13
    b0be:	cc 24       	eor	r12, r12
    b0c0:	0d a9       	sts	0x4d, r16
    b0c2:	1e a9       	sts	0x4e, r17
    b0c4:	2f a9       	sts	0x4f, r18
    b0c6:	38 ad       	sts	0x68, r19
    b0c8:	c9 01       	movw	r24, r18
    b0ca:	aa 27       	eor	r26, r26
    b0cc:	bb 27       	eor	r27, r27
    b0ce:	c8 2a       	or	r12, r24
    b0d0:	d9 2a       	or	r13, r25
    b0d2:	ea 2a       	or	r14, r26
    b0d4:	fb 2a       	or	r15, r27
    b0d6:	0d a5       	lds	r16, 0x6d
    b0d8:	1e a5       	lds	r17, 0x6e
    b0da:	2f a5       	lds	r18, 0x6f
    b0dc:	38 a9       	sts	0x48, r19
    b0de:	c4 16       	cp	r12, r20
    b0e0:	d5 06       	cpc	r13, r21
    b0e2:	e6 06       	cpc	r14, r22
    b0e4:	f7 06       	cpc	r15, r23
    b0e6:	38 f5       	brcc	.+78     	; 0xb136 <__divdi3+0x440>
    b0e8:	01 50       	subi	r16, 0x01	; 1
    b0ea:	10 40       	sbci	r17, 0x00	; 0
    b0ec:	20 40       	sbci	r18, 0x00	; 0
    b0ee:	30 40       	sbci	r19, 0x00	; 0
    b0f0:	09 a7       	lds	r16, 0x79
    b0f2:	1a a7       	lds	r17, 0x7a
    b0f4:	2b a7       	lds	r18, 0x7b
    b0f6:	3c a7       	lds	r19, 0x7c
    b0f8:	c8 0c       	add	r12, r8
    b0fa:	d9 1c       	adc	r13, r9
    b0fc:	ea 1c       	adc	r14, r10
    b0fe:	fb 1c       	adc	r15, r11
    b100:	c8 14       	cp	r12, r8
    b102:	d9 04       	cpc	r13, r9
    b104:	ea 04       	cpc	r14, r10
    b106:	fb 04       	cpc	r15, r11
    b108:	d0 f0       	brcs	.+52     	; 0xb13e <__divdi3+0x448>
    b10a:	c4 16       	cp	r12, r20
    b10c:	d5 06       	cpc	r13, r21
    b10e:	e6 06       	cpc	r14, r22
    b110:	f7 06       	cpc	r15, r23
    b112:	a8 f4       	brcc	.+42     	; 0xb13e <__divdi3+0x448>
    b114:	0d a5       	lds	r16, 0x6d
    b116:	1e a5       	lds	r17, 0x6e
    b118:	2f a5       	lds	r18, 0x6f
    b11a:	38 a9       	sts	0x48, r19
    b11c:	02 50       	subi	r16, 0x02	; 2
    b11e:	10 40       	sbci	r17, 0x00	; 0
    b120:	20 40       	sbci	r18, 0x00	; 0
    b122:	30 40       	sbci	r19, 0x00	; 0
    b124:	09 a7       	lds	r16, 0x79
    b126:	1a a7       	lds	r17, 0x7a
    b128:	2b a7       	lds	r18, 0x7b
    b12a:	3c a7       	lds	r19, 0x7c
    b12c:	c8 0c       	add	r12, r8
    b12e:	d9 1c       	adc	r13, r9
    b130:	ea 1c       	adc	r14, r10
    b132:	fb 1c       	adc	r15, r11
    b134:	04 c0       	rjmp	.+8      	; 0xb13e <__divdi3+0x448>
    b136:	09 a7       	lds	r16, 0x79
    b138:	1a a7       	lds	r17, 0x7a
    b13a:	2b a7       	lds	r18, 0x7b
    b13c:	3c a7       	lds	r19, 0x7c
    b13e:	c4 1a       	sub	r12, r20
    b140:	d5 0a       	sbc	r13, r21
    b142:	e6 0a       	sbc	r14, r22
    b144:	f7 0a       	sbc	r15, r23
    b146:	c7 01       	movw	r24, r14
    b148:	b6 01       	movw	r22, r12
    b14a:	a3 01       	movw	r20, r6
    b14c:	92 01       	movw	r18, r4
    b14e:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b152:	2d a7       	lds	r18, 0x7d
    b154:	3e a7       	lds	r19, 0x7e
    b156:	4f a7       	lds	r20, 0x7f
    b158:	58 ab       	sts	0x58, r21
    b15a:	69 af       	sts	0x79, r22
    b15c:	7a af       	sts	0x7a, r23
    b15e:	8b af       	sts	0x7b, r24
    b160:	9c af       	sts	0x7c, r25
    b162:	c7 01       	movw	r24, r14
    b164:	b6 01       	movw	r22, r12
    b166:	a3 01       	movw	r20, r6
    b168:	92 01       	movw	r18, r4
    b16a:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b16e:	ca 01       	movw	r24, r20
    b170:	b9 01       	movw	r22, r18
    b172:	29 a9       	sts	0x49, r18
    b174:	3a a9       	sts	0x4a, r19
    b176:	4b a9       	sts	0x4b, r20
    b178:	5c a9       	sts	0x4c, r21
    b17a:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b17e:	6b 01       	movw	r12, r22
    b180:	7c 01       	movw	r14, r24
    b182:	49 ad       	sts	0x69, r20
    b184:	5a ad       	sts	0x6a, r21
    b186:	6b ad       	sts	0x6b, r22
    b188:	7c ad       	sts	0x6c, r23
    b18a:	9a 01       	movw	r18, r20
    b18c:	11 27       	eor	r17, r17
    b18e:	00 27       	eor	r16, r16
    b190:	4d a9       	sts	0x4d, r20
    b192:	5e a9       	sts	0x4e, r21
    b194:	6f a9       	sts	0x4f, r22
    b196:	78 ad       	sts	0x68, r23
    b198:	60 70       	andi	r22, 0x00	; 0
    b19a:	70 70       	andi	r23, 0x00	; 0
    b19c:	04 2b       	or	r16, r20
    b19e:	15 2b       	or	r17, r21
    b1a0:	26 2b       	or	r18, r22
    b1a2:	37 2b       	or	r19, r23
    b1a4:	8d a5       	lds	r24, 0x6d
    b1a6:	9e a5       	lds	r25, 0x6e
    b1a8:	af a5       	lds	r26, 0x6f
    b1aa:	b8 a9       	sts	0x48, r27
    b1ac:	0c 15       	cp	r16, r12
    b1ae:	1d 05       	cpc	r17, r13
    b1b0:	2e 05       	cpc	r18, r14
    b1b2:	3f 05       	cpc	r19, r15
    b1b4:	c0 f4       	brcc	.+48     	; 0xb1e6 <__divdi3+0x4f0>
    b1b6:	01 97       	sbiw	r24, 0x01	; 1
    b1b8:	a1 09       	sbc	r26, r1
    b1ba:	b1 09       	sbc	r27, r1
    b1bc:	08 0d       	add	r16, r8
    b1be:	19 1d       	adc	r17, r9
    b1c0:	2a 1d       	adc	r18, r10
    b1c2:	3b 1d       	adc	r19, r11
    b1c4:	08 15       	cp	r16, r8
    b1c6:	19 05       	cpc	r17, r9
    b1c8:	2a 05       	cpc	r18, r10
    b1ca:	3b 05       	cpc	r19, r11
    b1cc:	60 f0       	brcs	.+24     	; 0xb1e6 <__divdi3+0x4f0>
    b1ce:	0c 15       	cp	r16, r12
    b1d0:	1d 05       	cpc	r17, r13
    b1d2:	2e 05       	cpc	r18, r14
    b1d4:	3f 05       	cpc	r19, r15
    b1d6:	38 f4       	brcc	.+14     	; 0xb1e6 <__divdi3+0x4f0>
    b1d8:	8d a5       	lds	r24, 0x6d
    b1da:	9e a5       	lds	r25, 0x6e
    b1dc:	af a5       	lds	r26, 0x6f
    b1de:	b8 a9       	sts	0x48, r27
    b1e0:	02 97       	sbiw	r24, 0x02	; 2
    b1e2:	a1 09       	sbc	r26, r1
    b1e4:	b1 09       	sbc	r27, r1
    b1e6:	09 a5       	lds	r16, 0x69
    b1e8:	1a a5       	lds	r17, 0x6a
    b1ea:	2b a5       	lds	r18, 0x6b
    b1ec:	3c a5       	lds	r19, 0x6c
    b1ee:	78 01       	movw	r14, r16
    b1f0:	dd 24       	eor	r13, r13
    b1f2:	cc 24       	eor	r12, r12
    b1f4:	c8 2a       	or	r12, r24
    b1f6:	d9 2a       	or	r13, r25
    b1f8:	ea 2a       	or	r14, r26
    b1fa:	fb 2a       	or	r15, r27
    b1fc:	b7 c4       	rjmp	.+2414   	; 0xbb6c <__divdi3+0xe76>
    b1fe:	81 14       	cp	r8, r1
    b200:	91 04       	cpc	r9, r1
    b202:	a1 04       	cpc	r10, r1
    b204:	b1 04       	cpc	r11, r1
    b206:	51 f4       	brne	.+20     	; 0xb21c <__divdi3+0x526>
    b208:	61 e0       	ldi	r22, 0x01	; 1
    b20a:	70 e0       	ldi	r23, 0x00	; 0
    b20c:	80 e0       	ldi	r24, 0x00	; 0
    b20e:	90 e0       	ldi	r25, 0x00	; 0
    b210:	a5 01       	movw	r20, r10
    b212:	94 01       	movw	r18, r8
    b214:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b218:	49 01       	movw	r8, r18
    b21a:	5a 01       	movw	r10, r20
    b21c:	10 e0       	ldi	r17, 0x00	; 0
    b21e:	81 16       	cp	r8, r17
    b220:	10 e0       	ldi	r17, 0x00	; 0
    b222:	91 06       	cpc	r9, r17
    b224:	11 e0       	ldi	r17, 0x01	; 1
    b226:	a1 06       	cpc	r10, r17
    b228:	10 e0       	ldi	r17, 0x00	; 0
    b22a:	b1 06       	cpc	r11, r17
    b22c:	58 f4       	brcc	.+22     	; 0xb244 <__divdi3+0x54e>
    b22e:	2f ef       	ldi	r18, 0xFF	; 255
    b230:	82 16       	cp	r8, r18
    b232:	91 04       	cpc	r9, r1
    b234:	a1 04       	cpc	r10, r1
    b236:	b1 04       	cpc	r11, r1
    b238:	09 f0       	breq	.+2      	; 0xb23c <__divdi3+0x546>
    b23a:	90 f4       	brcc	.+36     	; 0xb260 <__divdi3+0x56a>
    b23c:	80 e0       	ldi	r24, 0x00	; 0
    b23e:	90 e0       	ldi	r25, 0x00	; 0
    b240:	dc 01       	movw	r26, r24
    b242:	17 c0       	rjmp	.+46     	; 0xb272 <__divdi3+0x57c>
    b244:	30 e0       	ldi	r19, 0x00	; 0
    b246:	83 16       	cp	r8, r19
    b248:	30 e0       	ldi	r19, 0x00	; 0
    b24a:	93 06       	cpc	r9, r19
    b24c:	30 e0       	ldi	r19, 0x00	; 0
    b24e:	a3 06       	cpc	r10, r19
    b250:	31 e0       	ldi	r19, 0x01	; 1
    b252:	b3 06       	cpc	r11, r19
    b254:	50 f4       	brcc	.+20     	; 0xb26a <__divdi3+0x574>
    b256:	80 e1       	ldi	r24, 0x10	; 16
    b258:	90 e0       	ldi	r25, 0x00	; 0
    b25a:	a0 e0       	ldi	r26, 0x00	; 0
    b25c:	b0 e0       	ldi	r27, 0x00	; 0
    b25e:	09 c0       	rjmp	.+18     	; 0xb272 <__divdi3+0x57c>
    b260:	88 e0       	ldi	r24, 0x08	; 8
    b262:	90 e0       	ldi	r25, 0x00	; 0
    b264:	a0 e0       	ldi	r26, 0x00	; 0
    b266:	b0 e0       	ldi	r27, 0x00	; 0
    b268:	04 c0       	rjmp	.+8      	; 0xb272 <__divdi3+0x57c>
    b26a:	88 e1       	ldi	r24, 0x18	; 24
    b26c:	90 e0       	ldi	r25, 0x00	; 0
    b26e:	a0 e0       	ldi	r26, 0x00	; 0
    b270:	b0 e0       	ldi	r27, 0x00	; 0
    b272:	b5 01       	movw	r22, r10
    b274:	a4 01       	movw	r20, r8
    b276:	08 2e       	mov	r0, r24
    b278:	04 c0       	rjmp	.+8      	; 0xb282 <__divdi3+0x58c>
    b27a:	76 95       	lsr	r23
    b27c:	67 95       	ror	r22
    b27e:	57 95       	ror	r21
    b280:	47 95       	ror	r20
    b282:	0a 94       	dec	r0
    b284:	d2 f7       	brpl	.-12     	; 0xb27a <__divdi3+0x584>
    b286:	fa 01       	movw	r30, r20
    b288:	e0 5d       	subi	r30, 0xD0	; 208
    b28a:	ff 4d       	sbci	r31, 0xDF	; 223
    b28c:	20 81       	ld	r18, Z
    b28e:	ac 01       	movw	r20, r24
    b290:	bd 01       	movw	r22, r26
    b292:	42 0f       	add	r20, r18
    b294:	51 1d       	adc	r21, r1
    b296:	61 1d       	adc	r22, r1
    b298:	71 1d       	adc	r23, r1
    b29a:	80 e2       	ldi	r24, 0x20	; 32
    b29c:	90 e0       	ldi	r25, 0x00	; 0
    b29e:	a0 e0       	ldi	r26, 0x00	; 0
    b2a0:	b0 e0       	ldi	r27, 0x00	; 0
    b2a2:	84 1b       	sub	r24, r20
    b2a4:	95 0b       	sbc	r25, r21
    b2a6:	a6 0b       	sbc	r26, r22
    b2a8:	b7 0b       	sbc	r27, r23
    b2aa:	51 f4       	brne	.+20     	; 0xb2c0 <__divdi3+0x5ca>
    b2ac:	c8 18       	sub	r12, r8
    b2ae:	d9 08       	sbc	r13, r9
    b2b0:	ea 08       	sbc	r14, r10
    b2b2:	fb 08       	sbc	r15, r11
    b2b4:	f1 e0       	ldi	r31, 0x01	; 1
    b2b6:	4f 2e       	mov	r4, r31
    b2b8:	51 2c       	mov	r5, r1
    b2ba:	61 2c       	mov	r6, r1
    b2bc:	71 2c       	mov	r7, r1
    b2be:	28 c1       	rjmp	.+592    	; 0xb510 <__divdi3+0x81a>
    b2c0:	08 2e       	mov	r0, r24
    b2c2:	04 c0       	rjmp	.+8      	; 0xb2cc <__divdi3+0x5d6>
    b2c4:	88 0c       	add	r8, r8
    b2c6:	99 1c       	adc	r9, r9
    b2c8:	aa 1c       	adc	r10, r10
    b2ca:	bb 1c       	adc	r11, r11
    b2cc:	0a 94       	dec	r0
    b2ce:	d2 f7       	brpl	.-12     	; 0xb2c4 <__divdi3+0x5ce>
    b2d0:	97 01       	movw	r18, r14
    b2d2:	86 01       	movw	r16, r12
    b2d4:	04 2e       	mov	r0, r20
    b2d6:	04 c0       	rjmp	.+8      	; 0xb2e0 <__divdi3+0x5ea>
    b2d8:	36 95       	lsr	r19
    b2da:	27 95       	ror	r18
    b2dc:	17 95       	ror	r17
    b2de:	07 95       	ror	r16
    b2e0:	0a 94       	dec	r0
    b2e2:	d2 f7       	brpl	.-12     	; 0xb2d8 <__divdi3+0x5e2>
    b2e4:	09 ab       	sts	0x59, r16
    b2e6:	1a ab       	sts	0x5a, r17
    b2e8:	2b ab       	sts	0x5b, r18
    b2ea:	3c ab       	sts	0x5c, r19
    b2ec:	97 01       	movw	r18, r14
    b2ee:	86 01       	movw	r16, r12
    b2f0:	08 2e       	mov	r0, r24
    b2f2:	04 c0       	rjmp	.+8      	; 0xb2fc <__divdi3+0x606>
    b2f4:	00 0f       	add	r16, r16
    b2f6:	11 1f       	adc	r17, r17
    b2f8:	22 1f       	adc	r18, r18
    b2fa:	33 1f       	adc	r19, r19
    b2fc:	0a 94       	dec	r0
    b2fe:	d2 f7       	brpl	.-12     	; 0xb2f4 <__divdi3+0x5fe>
    b300:	0d a7       	lds	r16, 0x7d
    b302:	1e a7       	lds	r17, 0x7e
    b304:	2f a7       	lds	r18, 0x7f
    b306:	38 ab       	sts	0x58, r19
    b308:	ed a8       	sts	0x8d, r30
    b30a:	fe a8       	sts	0x8e, r31
    b30c:	0f a9       	sts	0x4f, r16
    b30e:	18 ad       	sts	0x68, r17
    b310:	04 c0       	rjmp	.+8      	; 0xb31a <__divdi3+0x624>
    b312:	16 95       	lsr	r17
    b314:	07 95       	ror	r16
    b316:	f7 94       	ror	r15
    b318:	e7 94       	ror	r14
    b31a:	4a 95       	dec	r20
    b31c:	d2 f7       	brpl	.-12     	; 0xb312 <__divdi3+0x61c>
    b31e:	b8 01       	movw	r22, r16
    b320:	a7 01       	movw	r20, r14
    b322:	0d a5       	lds	r16, 0x6d
    b324:	1e a5       	lds	r17, 0x6e
    b326:	2f a5       	lds	r18, 0x6f
    b328:	38 a9       	sts	0x48, r19
    b32a:	04 2b       	or	r16, r20
    b32c:	15 2b       	or	r17, r21
    b32e:	26 2b       	or	r18, r22
    b330:	37 2b       	or	r19, r23
    b332:	0d a7       	lds	r16, 0x7d
    b334:	1e a7       	lds	r17, 0x7e
    b336:	2f a7       	lds	r18, 0x7f
    b338:	38 ab       	sts	0x58, r19
    b33a:	ed a8       	sts	0x8d, r30
    b33c:	fe a8       	sts	0x8e, r31
    b33e:	0f a9       	sts	0x4f, r16
    b340:	18 ad       	sts	0x68, r17
    b342:	04 c0       	rjmp	.+8      	; 0xb34c <__divdi3+0x656>
    b344:	ee 0c       	add	r14, r14
    b346:	ff 1c       	adc	r15, r15
    b348:	00 1f       	adc	r16, r16
    b34a:	11 1f       	adc	r17, r17
    b34c:	8a 95       	dec	r24
    b34e:	d2 f7       	brpl	.-12     	; 0xb344 <__divdi3+0x64e>
    b350:	ed aa       	sts	0x9d, r30
    b352:	fe aa       	sts	0x9e, r31
    b354:	0f ab       	sts	0x5f, r16
    b356:	18 af       	sts	0x78, r17
    b358:	25 01       	movw	r4, r10
    b35a:	66 24       	eor	r6, r6
    b35c:	77 24       	eor	r7, r7
    b35e:	95 01       	movw	r18, r10
    b360:	84 01       	movw	r16, r8
    b362:	20 70       	andi	r18, 0x00	; 0
    b364:	30 70       	andi	r19, 0x00	; 0
    b366:	09 af       	sts	0x79, r16
    b368:	1a af       	sts	0x7a, r17
    b36a:	2b af       	sts	0x7b, r18
    b36c:	3c af       	sts	0x7c, r19
    b36e:	69 a9       	sts	0x49, r22
    b370:	7a a9       	sts	0x4a, r23
    b372:	8b a9       	sts	0x4b, r24
    b374:	9c a9       	sts	0x4c, r25
    b376:	a3 01       	movw	r20, r6
    b378:	92 01       	movw	r18, r4
    b37a:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b37e:	29 a7       	lds	r18, 0x79
    b380:	3a a7       	lds	r19, 0x7a
    b382:	4b a7       	lds	r20, 0x7b
    b384:	5c a7       	lds	r21, 0x7c
    b386:	6b 01       	movw	r12, r22
    b388:	7c 01       	movw	r14, r24
    b38a:	69 a9       	sts	0x49, r22
    b38c:	7a a9       	sts	0x4a, r23
    b38e:	8b a9       	sts	0x4b, r24
    b390:	9c a9       	sts	0x4c, r25
    b392:	a3 01       	movw	r20, r6
    b394:	92 01       	movw	r18, r4
    b396:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b39a:	ca 01       	movw	r24, r20
    b39c:	b9 01       	movw	r22, r18
    b39e:	29 ad       	sts	0x69, r18
    b3a0:	3a ad       	sts	0x6a, r19
    b3a2:	4b ad       	sts	0x6b, r20
    b3a4:	5c ad       	sts	0x6c, r21
    b3a6:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b3aa:	ab 01       	movw	r20, r22
    b3ac:	bc 01       	movw	r22, r24
    b3ae:	76 01       	movw	r14, r12
    b3b0:	dd 24       	eor	r13, r13
    b3b2:	cc 24       	eor	r12, r12
    b3b4:	0d a5       	lds	r16, 0x6d
    b3b6:	1e a5       	lds	r17, 0x6e
    b3b8:	2f a5       	lds	r18, 0x6f
    b3ba:	38 a9       	sts	0x48, r19
    b3bc:	c9 01       	movw	r24, r18
    b3be:	aa 27       	eor	r26, r26
    b3c0:	bb 27       	eor	r27, r27
    b3c2:	c8 2a       	or	r12, r24
    b3c4:	d9 2a       	or	r13, r25
    b3c6:	ea 2a       	or	r14, r26
    b3c8:	fb 2a       	or	r15, r27
    b3ca:	09 a5       	lds	r16, 0x69
    b3cc:	1a a5       	lds	r17, 0x6a
    b3ce:	2b a5       	lds	r18, 0x6b
    b3d0:	3c a5       	lds	r19, 0x6c
    b3d2:	c4 16       	cp	r12, r20
    b3d4:	d5 06       	cpc	r13, r21
    b3d6:	e6 06       	cpc	r14, r22
    b3d8:	f7 06       	cpc	r15, r23
    b3da:	38 f5       	brcc	.+78     	; 0xb42a <__divdi3+0x734>
    b3dc:	01 50       	subi	r16, 0x01	; 1
    b3de:	10 40       	sbci	r17, 0x00	; 0
    b3e0:	20 40       	sbci	r18, 0x00	; 0
    b3e2:	30 40       	sbci	r19, 0x00	; 0
    b3e4:	09 ab       	sts	0x59, r16
    b3e6:	1a ab       	sts	0x5a, r17
    b3e8:	2b ab       	sts	0x5b, r18
    b3ea:	3c ab       	sts	0x5c, r19
    b3ec:	c8 0c       	add	r12, r8
    b3ee:	d9 1c       	adc	r13, r9
    b3f0:	ea 1c       	adc	r14, r10
    b3f2:	fb 1c       	adc	r15, r11
    b3f4:	c8 14       	cp	r12, r8
    b3f6:	d9 04       	cpc	r13, r9
    b3f8:	ea 04       	cpc	r14, r10
    b3fa:	fb 04       	cpc	r15, r11
    b3fc:	d0 f0       	brcs	.+52     	; 0xb432 <__divdi3+0x73c>
    b3fe:	c4 16       	cp	r12, r20
    b400:	d5 06       	cpc	r13, r21
    b402:	e6 06       	cpc	r14, r22
    b404:	f7 06       	cpc	r15, r23
    b406:	a8 f4       	brcc	.+42     	; 0xb432 <__divdi3+0x73c>
    b408:	09 a5       	lds	r16, 0x69
    b40a:	1a a5       	lds	r17, 0x6a
    b40c:	2b a5       	lds	r18, 0x6b
    b40e:	3c a5       	lds	r19, 0x6c
    b410:	02 50       	subi	r16, 0x02	; 2
    b412:	10 40       	sbci	r17, 0x00	; 0
    b414:	20 40       	sbci	r18, 0x00	; 0
    b416:	30 40       	sbci	r19, 0x00	; 0
    b418:	09 ab       	sts	0x59, r16
    b41a:	1a ab       	sts	0x5a, r17
    b41c:	2b ab       	sts	0x5b, r18
    b41e:	3c ab       	sts	0x5c, r19
    b420:	c8 0c       	add	r12, r8
    b422:	d9 1c       	adc	r13, r9
    b424:	ea 1c       	adc	r14, r10
    b426:	fb 1c       	adc	r15, r11
    b428:	04 c0       	rjmp	.+8      	; 0xb432 <__divdi3+0x73c>
    b42a:	09 ab       	sts	0x59, r16
    b42c:	1a ab       	sts	0x5a, r17
    b42e:	2b ab       	sts	0x5b, r18
    b430:	3c ab       	sts	0x5c, r19
    b432:	c4 1a       	sub	r12, r20
    b434:	d5 0a       	sbc	r13, r21
    b436:	e6 0a       	sbc	r14, r22
    b438:	f7 0a       	sbc	r15, r23
    b43a:	c7 01       	movw	r24, r14
    b43c:	b6 01       	movw	r22, r12
    b43e:	a3 01       	movw	r20, r6
    b440:	92 01       	movw	r18, r4
    b442:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b446:	29 a7       	lds	r18, 0x79
    b448:	3a a7       	lds	r19, 0x7a
    b44a:	4b a7       	lds	r20, 0x7b
    b44c:	5c a7       	lds	r21, 0x7c
    b44e:	21 96       	adiw	r28, 0x01	; 1
    b450:	6c af       	sts	0x7c, r22
    b452:	7d af       	sts	0x7d, r23
    b454:	8e af       	sts	0x7e, r24
    b456:	9f af       	sts	0x7f, r25
    b458:	21 97       	sbiw	r28, 0x01	; 1
    b45a:	c7 01       	movw	r24, r14
    b45c:	b6 01       	movw	r22, r12
    b45e:	a3 01       	movw	r20, r6
    b460:	92 01       	movw	r18, r4
    b462:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b466:	ca 01       	movw	r24, r20
    b468:	b9 01       	movw	r22, r18
    b46a:	29 ad       	sts	0x69, r18
    b46c:	3a ad       	sts	0x6a, r19
    b46e:	4b ad       	sts	0x6b, r20
    b470:	5c ad       	sts	0x6c, r21
    b472:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b476:	8b 01       	movw	r16, r22
    b478:	9c 01       	movw	r18, r24
    b47a:	21 96       	adiw	r28, 0x01	; 1
    b47c:	4c ad       	sts	0x6c, r20
    b47e:	5d ad       	sts	0x6d, r21
    b480:	6e ad       	sts	0x6e, r22
    b482:	7f ad       	sts	0x6f, r23
    b484:	21 97       	sbiw	r28, 0x01	; 1
    b486:	da 01       	movw	r26, r20
    b488:	99 27       	eor	r25, r25
    b48a:	88 27       	eor	r24, r24
    b48c:	4d a5       	lds	r20, 0x6d
    b48e:	5e a5       	lds	r21, 0x6e
    b490:	6f a5       	lds	r22, 0x6f
    b492:	78 a9       	sts	0x48, r23
    b494:	60 70       	andi	r22, 0x00	; 0
    b496:	70 70       	andi	r23, 0x00	; 0
    b498:	84 2b       	or	r24, r20
    b49a:	95 2b       	or	r25, r21
    b49c:	a6 2b       	or	r26, r22
    b49e:	b7 2b       	or	r27, r23
    b4a0:	49 a5       	lds	r20, 0x69
    b4a2:	5a a5       	lds	r21, 0x6a
    b4a4:	6b a5       	lds	r22, 0x6b
    b4a6:	7c a5       	lds	r23, 0x6c
    b4a8:	80 17       	cp	r24, r16
    b4aa:	91 07       	cpc	r25, r17
    b4ac:	a2 07       	cpc	r26, r18
    b4ae:	b3 07       	cpc	r27, r19
    b4b0:	f0 f4       	brcc	.+60     	; 0xb4ee <__divdi3+0x7f8>
    b4b2:	41 50       	subi	r20, 0x01	; 1
    b4b4:	50 40       	sbci	r21, 0x00	; 0
    b4b6:	60 40       	sbci	r22, 0x00	; 0
    b4b8:	70 40       	sbci	r23, 0x00	; 0
    b4ba:	88 0d       	add	r24, r8
    b4bc:	99 1d       	adc	r25, r9
    b4be:	aa 1d       	adc	r26, r10
    b4c0:	bb 1d       	adc	r27, r11
    b4c2:	88 15       	cp	r24, r8
    b4c4:	99 05       	cpc	r25, r9
    b4c6:	aa 05       	cpc	r26, r10
    b4c8:	bb 05       	cpc	r27, r11
    b4ca:	88 f0       	brcs	.+34     	; 0xb4ee <__divdi3+0x7f8>
    b4cc:	80 17       	cp	r24, r16
    b4ce:	91 07       	cpc	r25, r17
    b4d0:	a2 07       	cpc	r26, r18
    b4d2:	b3 07       	cpc	r27, r19
    b4d4:	60 f4       	brcc	.+24     	; 0xb4ee <__divdi3+0x7f8>
    b4d6:	49 a5       	lds	r20, 0x69
    b4d8:	5a a5       	lds	r21, 0x6a
    b4da:	6b a5       	lds	r22, 0x6b
    b4dc:	7c a5       	lds	r23, 0x6c
    b4de:	42 50       	subi	r20, 0x02	; 2
    b4e0:	50 40       	sbci	r21, 0x00	; 0
    b4e2:	60 40       	sbci	r22, 0x00	; 0
    b4e4:	70 40       	sbci	r23, 0x00	; 0
    b4e6:	88 0d       	add	r24, r8
    b4e8:	99 1d       	adc	r25, r9
    b4ea:	aa 1d       	adc	r26, r10
    b4ec:	bb 1d       	adc	r27, r11
    b4ee:	6c 01       	movw	r12, r24
    b4f0:	7d 01       	movw	r14, r26
    b4f2:	c0 1a       	sub	r12, r16
    b4f4:	d1 0a       	sbc	r13, r17
    b4f6:	e2 0a       	sbc	r14, r18
    b4f8:	f3 0a       	sbc	r15, r19
    b4fa:	09 a9       	sts	0x49, r16
    b4fc:	1a a9       	sts	0x4a, r17
    b4fe:	2b a9       	sts	0x4b, r18
    b500:	3c a9       	sts	0x4c, r19
    b502:	38 01       	movw	r6, r16
    b504:	55 24       	eor	r5, r5
    b506:	44 24       	eor	r4, r4
    b508:	44 2a       	or	r4, r20
    b50a:	55 2a       	or	r5, r21
    b50c:	66 2a       	or	r6, r22
    b50e:	77 2a       	or	r7, r23
    b510:	85 01       	movw	r16, r10
    b512:	22 27       	eor	r18, r18
    b514:	33 27       	eor	r19, r19
    b516:	0d a7       	lds	r16, 0x7d
    b518:	1e a7       	lds	r17, 0x7e
    b51a:	2f a7       	lds	r18, 0x7f
    b51c:	38 ab       	sts	0x58, r19
    b51e:	95 01       	movw	r18, r10
    b520:	84 01       	movw	r16, r8
    b522:	20 70       	andi	r18, 0x00	; 0
    b524:	30 70       	andi	r19, 0x00	; 0
    b526:	09 af       	sts	0x79, r16
    b528:	1a af       	sts	0x7a, r17
    b52a:	2b af       	sts	0x7b, r18
    b52c:	3c af       	sts	0x7c, r19
    b52e:	c7 01       	movw	r24, r14
    b530:	b6 01       	movw	r22, r12
    b532:	2d a5       	lds	r18, 0x6d
    b534:	3e a5       	lds	r19, 0x6e
    b536:	4f a5       	lds	r20, 0x6f
    b538:	58 a9       	sts	0x48, r21
    b53a:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b53e:	29 a7       	lds	r18, 0x79
    b540:	3a a7       	lds	r19, 0x7a
    b542:	4b a7       	lds	r20, 0x7b
    b544:	5c a7       	lds	r21, 0x7c
    b546:	69 ab       	sts	0x59, r22
    b548:	7a ab       	sts	0x5a, r23
    b54a:	8b ab       	sts	0x5b, r24
    b54c:	9c ab       	sts	0x5c, r25
    b54e:	c7 01       	movw	r24, r14
    b550:	b6 01       	movw	r22, r12
    b552:	2d a5       	lds	r18, 0x6d
    b554:	3e a5       	lds	r19, 0x6e
    b556:	4f a5       	lds	r20, 0x6f
    b558:	58 a9       	sts	0x48, r21
    b55a:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b55e:	ca 01       	movw	r24, r20
    b560:	b9 01       	movw	r22, r18
    b562:	29 ad       	sts	0x69, r18
    b564:	3a ad       	sts	0x6a, r19
    b566:	4b ad       	sts	0x6b, r20
    b568:	5c ad       	sts	0x6c, r21
    b56a:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b56e:	ab 01       	movw	r20, r22
    b570:	bc 01       	movw	r22, r24
    b572:	09 a9       	sts	0x49, r16
    b574:	1a a9       	sts	0x4a, r17
    b576:	2b a9       	sts	0x4b, r18
    b578:	3c a9       	sts	0x4c, r19
    b57a:	78 01       	movw	r14, r16
    b57c:	dd 24       	eor	r13, r13
    b57e:	cc 24       	eor	r12, r12
    b580:	0d a9       	sts	0x4d, r16
    b582:	1e a9       	sts	0x4e, r17
    b584:	2f a9       	sts	0x4f, r18
    b586:	38 ad       	sts	0x68, r19
    b588:	c9 01       	movw	r24, r18
    b58a:	aa 27       	eor	r26, r26
    b58c:	bb 27       	eor	r27, r27
    b58e:	c8 2a       	or	r12, r24
    b590:	d9 2a       	or	r13, r25
    b592:	ea 2a       	or	r14, r26
    b594:	fb 2a       	or	r15, r27
    b596:	09 a5       	lds	r16, 0x69
    b598:	1a a5       	lds	r17, 0x6a
    b59a:	2b a5       	lds	r18, 0x6b
    b59c:	3c a5       	lds	r19, 0x6c
    b59e:	c4 16       	cp	r12, r20
    b5a0:	d5 06       	cpc	r13, r21
    b5a2:	e6 06       	cpc	r14, r22
    b5a4:	f7 06       	cpc	r15, r23
    b5a6:	38 f5       	brcc	.+78     	; 0xb5f6 <__divdi3+0x900>
    b5a8:	01 50       	subi	r16, 0x01	; 1
    b5aa:	10 40       	sbci	r17, 0x00	; 0
    b5ac:	20 40       	sbci	r18, 0x00	; 0
    b5ae:	30 40       	sbci	r19, 0x00	; 0
    b5b0:	09 ab       	sts	0x59, r16
    b5b2:	1a ab       	sts	0x5a, r17
    b5b4:	2b ab       	sts	0x5b, r18
    b5b6:	3c ab       	sts	0x5c, r19
    b5b8:	c8 0c       	add	r12, r8
    b5ba:	d9 1c       	adc	r13, r9
    b5bc:	ea 1c       	adc	r14, r10
    b5be:	fb 1c       	adc	r15, r11
    b5c0:	c8 14       	cp	r12, r8
    b5c2:	d9 04       	cpc	r13, r9
    b5c4:	ea 04       	cpc	r14, r10
    b5c6:	fb 04       	cpc	r15, r11
    b5c8:	d0 f0       	brcs	.+52     	; 0xb5fe <__divdi3+0x908>
    b5ca:	c4 16       	cp	r12, r20
    b5cc:	d5 06       	cpc	r13, r21
    b5ce:	e6 06       	cpc	r14, r22
    b5d0:	f7 06       	cpc	r15, r23
    b5d2:	a8 f4       	brcc	.+42     	; 0xb5fe <__divdi3+0x908>
    b5d4:	09 a5       	lds	r16, 0x69
    b5d6:	1a a5       	lds	r17, 0x6a
    b5d8:	2b a5       	lds	r18, 0x6b
    b5da:	3c a5       	lds	r19, 0x6c
    b5dc:	02 50       	subi	r16, 0x02	; 2
    b5de:	10 40       	sbci	r17, 0x00	; 0
    b5e0:	20 40       	sbci	r18, 0x00	; 0
    b5e2:	30 40       	sbci	r19, 0x00	; 0
    b5e4:	09 ab       	sts	0x59, r16
    b5e6:	1a ab       	sts	0x5a, r17
    b5e8:	2b ab       	sts	0x5b, r18
    b5ea:	3c ab       	sts	0x5c, r19
    b5ec:	c8 0c       	add	r12, r8
    b5ee:	d9 1c       	adc	r13, r9
    b5f0:	ea 1c       	adc	r14, r10
    b5f2:	fb 1c       	adc	r15, r11
    b5f4:	04 c0       	rjmp	.+8      	; 0xb5fe <__divdi3+0x908>
    b5f6:	09 ab       	sts	0x59, r16
    b5f8:	1a ab       	sts	0x5a, r17
    b5fa:	2b ab       	sts	0x5b, r18
    b5fc:	3c ab       	sts	0x5c, r19
    b5fe:	c4 1a       	sub	r12, r20
    b600:	d5 0a       	sbc	r13, r21
    b602:	e6 0a       	sbc	r14, r22
    b604:	f7 0a       	sbc	r15, r23
    b606:	c7 01       	movw	r24, r14
    b608:	b6 01       	movw	r22, r12
    b60a:	2d a5       	lds	r18, 0x6d
    b60c:	3e a5       	lds	r19, 0x6e
    b60e:	4f a5       	lds	r20, 0x6f
    b610:	58 a9       	sts	0x48, r21
    b612:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b616:	29 a7       	lds	r18, 0x79
    b618:	3a a7       	lds	r19, 0x7a
    b61a:	4b a7       	lds	r20, 0x7b
    b61c:	5c a7       	lds	r21, 0x7c
    b61e:	21 96       	adiw	r28, 0x01	; 1
    b620:	6c af       	sts	0x7c, r22
    b622:	7d af       	sts	0x7d, r23
    b624:	8e af       	sts	0x7e, r24
    b626:	9f af       	sts	0x7f, r25
    b628:	21 97       	sbiw	r28, 0x01	; 1
    b62a:	c7 01       	movw	r24, r14
    b62c:	b6 01       	movw	r22, r12
    b62e:	2d a5       	lds	r18, 0x6d
    b630:	3e a5       	lds	r19, 0x6e
    b632:	4f a5       	lds	r20, 0x6f
    b634:	58 a9       	sts	0x48, r21
    b636:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b63a:	ca 01       	movw	r24, r20
    b63c:	b9 01       	movw	r22, r18
    b63e:	29 ad       	sts	0x69, r18
    b640:	3a ad       	sts	0x6a, r19
    b642:	4b ad       	sts	0x6b, r20
    b644:	5c ad       	sts	0x6c, r21
    b646:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b64a:	8b 01       	movw	r16, r22
    b64c:	9c 01       	movw	r18, r24
    b64e:	21 96       	adiw	r28, 0x01	; 1
    b650:	4c ad       	sts	0x6c, r20
    b652:	5d ad       	sts	0x6d, r21
    b654:	6e ad       	sts	0x6e, r22
    b656:	7f ad       	sts	0x6f, r23
    b658:	21 97       	sbiw	r28, 0x01	; 1
    b65a:	da 01       	movw	r26, r20
    b65c:	99 27       	eor	r25, r25
    b65e:	88 27       	eor	r24, r24
    b660:	4d a9       	sts	0x4d, r20
    b662:	5e a9       	sts	0x4e, r21
    b664:	6f a9       	sts	0x4f, r22
    b666:	78 ad       	sts	0x68, r23
    b668:	60 70       	andi	r22, 0x00	; 0
    b66a:	70 70       	andi	r23, 0x00	; 0
    b66c:	84 2b       	or	r24, r20
    b66e:	95 2b       	or	r25, r21
    b670:	a6 2b       	or	r26, r22
    b672:	b7 2b       	or	r27, r23
    b674:	49 a5       	lds	r20, 0x69
    b676:	5a a5       	lds	r21, 0x6a
    b678:	6b a5       	lds	r22, 0x6b
    b67a:	7c a5       	lds	r23, 0x6c
    b67c:	80 17       	cp	r24, r16
    b67e:	91 07       	cpc	r25, r17
    b680:	a2 07       	cpc	r26, r18
    b682:	b3 07       	cpc	r27, r19
    b684:	d0 f4       	brcc	.+52     	; 0xb6ba <__divdi3+0x9c4>
    b686:	41 50       	subi	r20, 0x01	; 1
    b688:	50 40       	sbci	r21, 0x00	; 0
    b68a:	60 40       	sbci	r22, 0x00	; 0
    b68c:	70 40       	sbci	r23, 0x00	; 0
    b68e:	88 0d       	add	r24, r8
    b690:	99 1d       	adc	r25, r9
    b692:	aa 1d       	adc	r26, r10
    b694:	bb 1d       	adc	r27, r11
    b696:	88 15       	cp	r24, r8
    b698:	99 05       	cpc	r25, r9
    b69a:	aa 05       	cpc	r26, r10
    b69c:	bb 05       	cpc	r27, r11
    b69e:	68 f0       	brcs	.+26     	; 0xb6ba <__divdi3+0x9c4>
    b6a0:	80 17       	cp	r24, r16
    b6a2:	91 07       	cpc	r25, r17
    b6a4:	a2 07       	cpc	r26, r18
    b6a6:	b3 07       	cpc	r27, r19
    b6a8:	40 f4       	brcc	.+16     	; 0xb6ba <__divdi3+0x9c4>
    b6aa:	49 a5       	lds	r20, 0x69
    b6ac:	5a a5       	lds	r21, 0x6a
    b6ae:	6b a5       	lds	r22, 0x6b
    b6b0:	7c a5       	lds	r23, 0x6c
    b6b2:	42 50       	subi	r20, 0x02	; 2
    b6b4:	50 40       	sbci	r21, 0x00	; 0
    b6b6:	60 40       	sbci	r22, 0x00	; 0
    b6b8:	70 40       	sbci	r23, 0x00	; 0
    b6ba:	09 a9       	sts	0x49, r16
    b6bc:	1a a9       	sts	0x4a, r17
    b6be:	2b a9       	sts	0x4b, r18
    b6c0:	3c a9       	sts	0x4c, r19
    b6c2:	78 01       	movw	r14, r16
    b6c4:	dd 24       	eor	r13, r13
    b6c6:	cc 24       	eor	r12, r12
    b6c8:	c4 2a       	or	r12, r20
    b6ca:	d5 2a       	or	r13, r21
    b6cc:	e6 2a       	or	r14, r22
    b6ce:	f7 2a       	or	r15, r23
    b6d0:	50 c2       	rjmp	.+1184   	; 0xbb72 <__divdi3+0xe7c>
    b6d2:	c8 16       	cp	r12, r24
    b6d4:	d9 06       	cpc	r13, r25
    b6d6:	ea 06       	cpc	r14, r26
    b6d8:	fb 06       	cpc	r15, r27
    b6da:	08 f4       	brcc	.+2      	; 0xb6de <__divdi3+0x9e8>
    b6dc:	37 c2       	rjmp	.+1134   	; 0xbb4c <__divdi3+0xe56>
    b6de:	80 30       	cpi	r24, 0x00	; 0
    b6e0:	10 e0       	ldi	r17, 0x00	; 0
    b6e2:	91 07       	cpc	r25, r17
    b6e4:	11 e0       	ldi	r17, 0x01	; 1
    b6e6:	a1 07       	cpc	r26, r17
    b6e8:	10 e0       	ldi	r17, 0x00	; 0
    b6ea:	b1 07       	cpc	r27, r17
    b6ec:	50 f4       	brcc	.+20     	; 0xb702 <__divdi3+0xa0c>
    b6ee:	8f 3f       	cpi	r24, 0xFF	; 255
    b6f0:	91 05       	cpc	r25, r1
    b6f2:	a1 05       	cpc	r26, r1
    b6f4:	b1 05       	cpc	r27, r1
    b6f6:	09 f0       	breq	.+2      	; 0xb6fa <__divdi3+0xa04>
    b6f8:	88 f4       	brcc	.+34     	; 0xb71c <__divdi3+0xa26>
    b6fa:	00 e0       	ldi	r16, 0x00	; 0
    b6fc:	10 e0       	ldi	r17, 0x00	; 0
    b6fe:	98 01       	movw	r18, r16
    b700:	16 c0       	rjmp	.+44     	; 0xb72e <__divdi3+0xa38>
    b702:	80 30       	cpi	r24, 0x00	; 0
    b704:	20 e0       	ldi	r18, 0x00	; 0
    b706:	92 07       	cpc	r25, r18
    b708:	20 e0       	ldi	r18, 0x00	; 0
    b70a:	a2 07       	cpc	r26, r18
    b70c:	21 e0       	ldi	r18, 0x01	; 1
    b70e:	b2 07       	cpc	r27, r18
    b710:	50 f4       	brcc	.+20     	; 0xb726 <__divdi3+0xa30>
    b712:	00 e1       	ldi	r16, 0x10	; 16
    b714:	10 e0       	ldi	r17, 0x00	; 0
    b716:	20 e0       	ldi	r18, 0x00	; 0
    b718:	30 e0       	ldi	r19, 0x00	; 0
    b71a:	09 c0       	rjmp	.+18     	; 0xb72e <__divdi3+0xa38>
    b71c:	08 e0       	ldi	r16, 0x08	; 8
    b71e:	10 e0       	ldi	r17, 0x00	; 0
    b720:	20 e0       	ldi	r18, 0x00	; 0
    b722:	30 e0       	ldi	r19, 0x00	; 0
    b724:	04 c0       	rjmp	.+8      	; 0xb72e <__divdi3+0xa38>
    b726:	08 e1       	ldi	r16, 0x18	; 24
    b728:	10 e0       	ldi	r17, 0x00	; 0
    b72a:	20 e0       	ldi	r18, 0x00	; 0
    b72c:	30 e0       	ldi	r19, 0x00	; 0
    b72e:	ac 01       	movw	r20, r24
    b730:	bd 01       	movw	r22, r26
    b732:	00 2e       	mov	r0, r16
    b734:	04 c0       	rjmp	.+8      	; 0xb73e <__divdi3+0xa48>
    b736:	76 95       	lsr	r23
    b738:	67 95       	ror	r22
    b73a:	57 95       	ror	r21
    b73c:	47 95       	ror	r20
    b73e:	0a 94       	dec	r0
    b740:	d2 f7       	brpl	.-12     	; 0xb736 <__divdi3+0xa40>
    b742:	fa 01       	movw	r30, r20
    b744:	e0 5d       	subi	r30, 0xD0	; 208
    b746:	ff 4d       	sbci	r31, 0xDF	; 223
    b748:	40 81       	ld	r20, Z
    b74a:	04 0f       	add	r16, r20
    b74c:	11 1d       	adc	r17, r1
    b74e:	21 1d       	adc	r18, r1
    b750:	31 1d       	adc	r19, r1
    b752:	40 e2       	ldi	r20, 0x20	; 32
    b754:	50 e0       	ldi	r21, 0x00	; 0
    b756:	60 e0       	ldi	r22, 0x00	; 0
    b758:	70 e0       	ldi	r23, 0x00	; 0
    b75a:	40 1b       	sub	r20, r16
    b75c:	51 0b       	sbc	r21, r17
    b75e:	62 0b       	sbc	r22, r18
    b760:	73 0b       	sbc	r23, r19
    b762:	a1 f4       	brne	.+40     	; 0xb78c <__divdi3+0xa96>
    b764:	8c 15       	cp	r24, r12
    b766:	9d 05       	cpc	r25, r13
    b768:	ae 05       	cpc	r26, r14
    b76a:	bf 05       	cpc	r27, r15
    b76c:	08 f4       	brcc	.+2      	; 0xb770 <__divdi3+0xa7a>
    b76e:	f5 c1       	rjmp	.+1002   	; 0xbb5a <__divdi3+0xe64>
    b770:	ed a8       	sts	0x8d, r30
    b772:	fe a8       	sts	0x8e, r31
    b774:	0f a9       	sts	0x4f, r16
    b776:	18 ad       	sts	0x68, r17
    b778:	44 24       	eor	r4, r4
    b77a:	55 24       	eor	r5, r5
    b77c:	32 01       	movw	r6, r4
    b77e:	e8 14       	cp	r14, r8
    b780:	f9 04       	cpc	r15, r9
    b782:	0a 05       	cpc	r16, r10
    b784:	1b 05       	cpc	r17, r11
    b786:	08 f0       	brcs	.+2      	; 0xb78a <__divdi3+0xa94>
    b788:	eb c1       	rjmp	.+982    	; 0xbb60 <__divdi3+0xe6a>
    b78a:	e3 c1       	rjmp	.+966    	; 0xbb52 <__divdi3+0xe5c>
    b78c:	34 2e       	mov	r3, r20
    b78e:	2c 01       	movw	r4, r24
    b790:	3d 01       	movw	r6, r26
    b792:	04 c0       	rjmp	.+8      	; 0xb79c <__divdi3+0xaa6>
    b794:	44 0c       	add	r4, r4
    b796:	55 1c       	adc	r5, r5
    b798:	66 1c       	adc	r6, r6
    b79a:	77 1c       	adc	r7, r7
    b79c:	4a 95       	dec	r20
    b79e:	d2 f7       	brpl	.-12     	; 0xb794 <__divdi3+0xa9e>
    b7a0:	d5 01       	movw	r26, r10
    b7a2:	c4 01       	movw	r24, r8
    b7a4:	00 2e       	mov	r0, r16
    b7a6:	04 c0       	rjmp	.+8      	; 0xb7b0 <__divdi3+0xaba>
    b7a8:	b6 95       	lsr	r27
    b7aa:	a7 95       	ror	r26
    b7ac:	97 95       	ror	r25
    b7ae:	87 95       	ror	r24
    b7b0:	0a 94       	dec	r0
    b7b2:	d2 f7       	brpl	.-12     	; 0xb7a8 <__divdi3+0xab2>
    b7b4:	48 2a       	or	r4, r24
    b7b6:	59 2a       	or	r5, r25
    b7b8:	6a 2a       	or	r6, r26
    b7ba:	7b 2a       	or	r7, r27
    b7bc:	a5 01       	movw	r20, r10
    b7be:	94 01       	movw	r18, r8
    b7c0:	03 2c       	mov	r0, r3
    b7c2:	04 c0       	rjmp	.+8      	; 0xb7cc <__divdi3+0xad6>
    b7c4:	22 0f       	add	r18, r18
    b7c6:	33 1f       	adc	r19, r19
    b7c8:	44 1f       	adc	r20, r20
    b7ca:	55 1f       	adc	r21, r21
    b7cc:	0a 94       	dec	r0
    b7ce:	d2 f7       	brpl	.-12     	; 0xb7c4 <__divdi3+0xace>
    b7d0:	29 af       	sts	0x79, r18
    b7d2:	3a af       	sts	0x7a, r19
    b7d4:	4b af       	sts	0x7b, r20
    b7d6:	5c af       	sts	0x7c, r21
    b7d8:	b7 01       	movw	r22, r14
    b7da:	a6 01       	movw	r20, r12
    b7dc:	00 2e       	mov	r0, r16
    b7de:	04 c0       	rjmp	.+8      	; 0xb7e8 <__divdi3+0xaf2>
    b7e0:	76 95       	lsr	r23
    b7e2:	67 95       	ror	r22
    b7e4:	57 95       	ror	r21
    b7e6:	47 95       	ror	r20
    b7e8:	0a 94       	dec	r0
    b7ea:	d2 f7       	brpl	.-12     	; 0xb7e0 <__divdi3+0xaea>
    b7ec:	49 ab       	sts	0x59, r20
    b7ee:	5a ab       	sts	0x5a, r21
    b7f0:	6b ab       	sts	0x5b, r22
    b7f2:	7c ab       	sts	0x5c, r23
    b7f4:	c7 01       	movw	r24, r14
    b7f6:	b6 01       	movw	r22, r12
    b7f8:	03 2c       	mov	r0, r3
    b7fa:	04 c0       	rjmp	.+8      	; 0xb804 <__divdi3+0xb0e>
    b7fc:	66 0f       	add	r22, r22
    b7fe:	77 1f       	adc	r23, r23
    b800:	88 1f       	adc	r24, r24
    b802:	99 1f       	adc	r25, r25
    b804:	0a 94       	dec	r0
    b806:	d2 f7       	brpl	.-12     	; 0xb7fc <__divdi3+0xb06>
    b808:	6d a7       	lds	r22, 0x7d
    b80a:	7e a7       	lds	r23, 0x7e
    b80c:	8f a7       	lds	r24, 0x7f
    b80e:	98 ab       	sts	0x58, r25
    b810:	8d a9       	sts	0x4d, r24
    b812:	9e a9       	sts	0x4e, r25
    b814:	af a9       	sts	0x4f, r26
    b816:	b8 ad       	sts	0x68, r27
    b818:	04 c0       	rjmp	.+8      	; 0xb822 <__divdi3+0xb2c>
    b81a:	b6 95       	lsr	r27
    b81c:	a7 95       	ror	r26
    b81e:	97 95       	ror	r25
    b820:	87 95       	ror	r24
    b822:	0a 95       	dec	r16
    b824:	d2 f7       	brpl	.-12     	; 0xb81a <__divdi3+0xb24>
    b826:	4d a5       	lds	r20, 0x6d
    b828:	5e a5       	lds	r21, 0x6e
    b82a:	6f a5       	lds	r22, 0x6f
    b82c:	78 a9       	sts	0x48, r23
    b82e:	48 2b       	or	r20, r24
    b830:	59 2b       	or	r21, r25
    b832:	6a 2b       	or	r22, r26
    b834:	7b 2b       	or	r23, r27
    b836:	4d a7       	lds	r20, 0x7d
    b838:	5e a7       	lds	r21, 0x7e
    b83a:	6f a7       	lds	r22, 0x7f
    b83c:	78 ab       	sts	0x58, r23
    b83e:	43 01       	movw	r8, r6
    b840:	aa 24       	eor	r10, r10
    b842:	bb 24       	eor	r11, r11
    b844:	93 01       	movw	r18, r6
    b846:	82 01       	movw	r16, r4
    b848:	20 70       	andi	r18, 0x00	; 0
    b84a:	30 70       	andi	r19, 0x00	; 0
    b84c:	21 96       	adiw	r28, 0x01	; 1
    b84e:	0c af       	sts	0x7c, r16
    b850:	1d af       	sts	0x7d, r17
    b852:	2e af       	sts	0x7e, r18
    b854:	3f af       	sts	0x7f, r19
    b856:	21 97       	sbiw	r28, 0x01	; 1
    b858:	69 a9       	sts	0x49, r22
    b85a:	7a a9       	sts	0x4a, r23
    b85c:	8b a9       	sts	0x4b, r24
    b85e:	9c a9       	sts	0x4c, r25
    b860:	a5 01       	movw	r20, r10
    b862:	94 01       	movw	r18, r8
    b864:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b868:	29 a7       	lds	r18, 0x79
    b86a:	3a a7       	lds	r19, 0x7a
    b86c:	4b a7       	lds	r20, 0x7b
    b86e:	5c a7       	lds	r21, 0x7c
    b870:	6b 01       	movw	r12, r22
    b872:	7c 01       	movw	r14, r24
    b874:	69 a9       	sts	0x49, r22
    b876:	7a a9       	sts	0x4a, r23
    b878:	8b a9       	sts	0x4b, r24
    b87a:	9c a9       	sts	0x4c, r25
    b87c:	a5 01       	movw	r20, r10
    b87e:	94 01       	movw	r18, r8
    b880:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b884:	ca 01       	movw	r24, r20
    b886:	b9 01       	movw	r22, r18
    b888:	21 96       	adiw	r28, 0x01	; 1
    b88a:	2c ad       	sts	0x6c, r18
    b88c:	3d ad       	sts	0x6d, r19
    b88e:	4e ad       	sts	0x6e, r20
    b890:	5f ad       	sts	0x6f, r21
    b892:	21 97       	sbiw	r28, 0x01	; 1
    b894:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b898:	dc 01       	movw	r26, r24
    b89a:	cb 01       	movw	r24, r22
    b89c:	76 01       	movw	r14, r12
    b89e:	dd 24       	eor	r13, r13
    b8a0:	cc 24       	eor	r12, r12
    b8a2:	0d a5       	lds	r16, 0x6d
    b8a4:	1e a5       	lds	r17, 0x6e
    b8a6:	2f a5       	lds	r18, 0x6f
    b8a8:	38 a9       	sts	0x48, r19
    b8aa:	a9 01       	movw	r20, r18
    b8ac:	66 27       	eor	r22, r22
    b8ae:	77 27       	eor	r23, r23
    b8b0:	c4 2a       	or	r12, r20
    b8b2:	d5 2a       	or	r13, r21
    b8b4:	e6 2a       	or	r14, r22
    b8b6:	f7 2a       	or	r15, r23
    b8b8:	09 a5       	lds	r16, 0x69
    b8ba:	1a a5       	lds	r17, 0x6a
    b8bc:	2b a5       	lds	r18, 0x6b
    b8be:	3c a5       	lds	r19, 0x6c
    b8c0:	c8 16       	cp	r12, r24
    b8c2:	d9 06       	cpc	r13, r25
    b8c4:	ea 06       	cpc	r14, r26
    b8c6:	fb 06       	cpc	r15, r27
    b8c8:	38 f5       	brcc	.+78     	; 0xb918 <__divdi3+0xc22>
    b8ca:	01 50       	subi	r16, 0x01	; 1
    b8cc:	10 40       	sbci	r17, 0x00	; 0
    b8ce:	20 40       	sbci	r18, 0x00	; 0
    b8d0:	30 40       	sbci	r19, 0x00	; 0
    b8d2:	09 ab       	sts	0x59, r16
    b8d4:	1a ab       	sts	0x5a, r17
    b8d6:	2b ab       	sts	0x5b, r18
    b8d8:	3c ab       	sts	0x5c, r19
    b8da:	c4 0c       	add	r12, r4
    b8dc:	d5 1c       	adc	r13, r5
    b8de:	e6 1c       	adc	r14, r6
    b8e0:	f7 1c       	adc	r15, r7
    b8e2:	c4 14       	cp	r12, r4
    b8e4:	d5 04       	cpc	r13, r5
    b8e6:	e6 04       	cpc	r14, r6
    b8e8:	f7 04       	cpc	r15, r7
    b8ea:	d0 f0       	brcs	.+52     	; 0xb920 <__divdi3+0xc2a>
    b8ec:	c8 16       	cp	r12, r24
    b8ee:	d9 06       	cpc	r13, r25
    b8f0:	ea 06       	cpc	r14, r26
    b8f2:	fb 06       	cpc	r15, r27
    b8f4:	a8 f4       	brcc	.+42     	; 0xb920 <__divdi3+0xc2a>
    b8f6:	09 a5       	lds	r16, 0x69
    b8f8:	1a a5       	lds	r17, 0x6a
    b8fa:	2b a5       	lds	r18, 0x6b
    b8fc:	3c a5       	lds	r19, 0x6c
    b8fe:	02 50       	subi	r16, 0x02	; 2
    b900:	10 40       	sbci	r17, 0x00	; 0
    b902:	20 40       	sbci	r18, 0x00	; 0
    b904:	30 40       	sbci	r19, 0x00	; 0
    b906:	09 ab       	sts	0x59, r16
    b908:	1a ab       	sts	0x5a, r17
    b90a:	2b ab       	sts	0x5b, r18
    b90c:	3c ab       	sts	0x5c, r19
    b90e:	c4 0c       	add	r12, r4
    b910:	d5 1c       	adc	r13, r5
    b912:	e6 1c       	adc	r14, r6
    b914:	f7 1c       	adc	r15, r7
    b916:	04 c0       	rjmp	.+8      	; 0xb920 <__divdi3+0xc2a>
    b918:	09 ab       	sts	0x59, r16
    b91a:	1a ab       	sts	0x5a, r17
    b91c:	2b ab       	sts	0x5b, r18
    b91e:	3c ab       	sts	0x5c, r19
    b920:	c8 1a       	sub	r12, r24
    b922:	d9 0a       	sbc	r13, r25
    b924:	ea 0a       	sbc	r14, r26
    b926:	fb 0a       	sbc	r15, r27
    b928:	c7 01       	movw	r24, r14
    b92a:	b6 01       	movw	r22, r12
    b92c:	a5 01       	movw	r20, r10
    b92e:	94 01       	movw	r18, r8
    b930:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b934:	29 a7       	lds	r18, 0x79
    b936:	3a a7       	lds	r19, 0x7a
    b938:	4b a7       	lds	r20, 0x7b
    b93a:	5c a7       	lds	r21, 0x7c
    b93c:	29 96       	adiw	r28, 0x09	; 9
    b93e:	6c af       	sts	0x7c, r22
    b940:	7d af       	sts	0x7d, r23
    b942:	8e af       	sts	0x7e, r24
    b944:	9f af       	sts	0x7f, r25
    b946:	29 97       	sbiw	r28, 0x09	; 9
    b948:	c7 01       	movw	r24, r14
    b94a:	b6 01       	movw	r22, r12
    b94c:	a5 01       	movw	r20, r10
    b94e:	94 01       	movw	r18, r8
    b950:	0e 94 93 60 	call	0xc126	; 0xc126 <__udivmodsi4>
    b954:	ca 01       	movw	r24, r20
    b956:	b9 01       	movw	r22, r18
    b958:	21 96       	adiw	r28, 0x01	; 1
    b95a:	2c ad       	sts	0x6c, r18
    b95c:	3d ad       	sts	0x6d, r19
    b95e:	4e ad       	sts	0x6e, r20
    b960:	5f ad       	sts	0x6f, r21
    b962:	21 97       	sbiw	r28, 0x01	; 1
    b964:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    b968:	4b 01       	movw	r8, r22
    b96a:	5c 01       	movw	r10, r24
    b96c:	29 96       	adiw	r28, 0x09	; 9
    b96e:	4c ad       	sts	0x6c, r20
    b970:	5d ad       	sts	0x6d, r21
    b972:	6e ad       	sts	0x6e, r22
    b974:	7f ad       	sts	0x6f, r23
    b976:	29 97       	sbiw	r28, 0x09	; 9
    b978:	9a 01       	movw	r18, r20
    b97a:	11 27       	eor	r17, r17
    b97c:	00 27       	eor	r16, r16
    b97e:	8d a5       	lds	r24, 0x6d
    b980:	9e a5       	lds	r25, 0x6e
    b982:	af a5       	lds	r26, 0x6f
    b984:	b8 a9       	sts	0x48, r27
    b986:	a0 70       	andi	r26, 0x00	; 0
    b988:	b0 70       	andi	r27, 0x00	; 0
    b98a:	08 2b       	or	r16, r24
    b98c:	19 2b       	or	r17, r25
    b98e:	2a 2b       	or	r18, r26
    b990:	3b 2b       	or	r19, r27
    b992:	89 a5       	lds	r24, 0x69
    b994:	9a a5       	lds	r25, 0x6a
    b996:	ab a5       	lds	r26, 0x6b
    b998:	bc a5       	lds	r27, 0x6c
    b99a:	08 15       	cp	r16, r8
    b99c:	19 05       	cpc	r17, r9
    b99e:	2a 05       	cpc	r18, r10
    b9a0:	3b 05       	cpc	r19, r11
    b9a2:	e0 f4       	brcc	.+56     	; 0xb9dc <__divdi3+0xce6>
    b9a4:	01 97       	sbiw	r24, 0x01	; 1
    b9a6:	a1 09       	sbc	r26, r1
    b9a8:	b1 09       	sbc	r27, r1
    b9aa:	04 0d       	add	r16, r4
    b9ac:	15 1d       	adc	r17, r5
    b9ae:	26 1d       	adc	r18, r6
    b9b0:	37 1d       	adc	r19, r7
    b9b2:	04 15       	cp	r16, r4
    b9b4:	15 05       	cpc	r17, r5
    b9b6:	26 05       	cpc	r18, r6
    b9b8:	37 05       	cpc	r19, r7
    b9ba:	80 f0       	brcs	.+32     	; 0xb9dc <__divdi3+0xce6>
    b9bc:	08 15       	cp	r16, r8
    b9be:	19 05       	cpc	r17, r9
    b9c0:	2a 05       	cpc	r18, r10
    b9c2:	3b 05       	cpc	r19, r11
    b9c4:	58 f4       	brcc	.+22     	; 0xb9dc <__divdi3+0xce6>
    b9c6:	89 a5       	lds	r24, 0x69
    b9c8:	9a a5       	lds	r25, 0x6a
    b9ca:	ab a5       	lds	r26, 0x6b
    b9cc:	bc a5       	lds	r27, 0x6c
    b9ce:	02 97       	sbiw	r24, 0x02	; 2
    b9d0:	a1 09       	sbc	r26, r1
    b9d2:	b1 09       	sbc	r27, r1
    b9d4:	04 0d       	add	r16, r4
    b9d6:	15 1d       	adc	r17, r5
    b9d8:	26 1d       	adc	r18, r6
    b9da:	37 1d       	adc	r19, r7
    b9dc:	b9 01       	movw	r22, r18
    b9de:	a8 01       	movw	r20, r16
    b9e0:	48 19       	sub	r20, r8
    b9e2:	59 09       	sbc	r21, r9
    b9e4:	6a 09       	sbc	r22, r10
    b9e6:	7b 09       	sbc	r23, r11
    b9e8:	4d a7       	lds	r20, 0x7d
    b9ea:	5e a7       	lds	r21, 0x7e
    b9ec:	6f a7       	lds	r22, 0x7f
    b9ee:	78 ab       	sts	0x58, r23
    b9f0:	09 a9       	sts	0x49, r16
    b9f2:	1a a9       	sts	0x4a, r17
    b9f4:	2b a9       	sts	0x4b, r18
    b9f6:	3c a9       	sts	0x4c, r19
    b9f8:	78 01       	movw	r14, r16
    b9fa:	dd 24       	eor	r13, r13
    b9fc:	cc 24       	eor	r12, r12
    b9fe:	c8 2a       	or	r12, r24
    ba00:	d9 2a       	or	r13, r25
    ba02:	ea 2a       	or	r14, r26
    ba04:	fb 2a       	or	r15, r27
    ba06:	ff ef       	ldi	r31, 0xFF	; 255
    ba08:	8f 2e       	mov	r8, r31
    ba0a:	ff ef       	ldi	r31, 0xFF	; 255
    ba0c:	9f 2e       	mov	r9, r31
    ba0e:	a1 2c       	mov	r10, r1
    ba10:	b1 2c       	mov	r11, r1
    ba12:	8c 20       	and	r8, r12
    ba14:	9d 20       	and	r9, r13
    ba16:	ae 20       	and	r10, r14
    ba18:	bf 20       	and	r11, r15
    ba1a:	87 01       	movw	r16, r14
    ba1c:	22 27       	eor	r18, r18
    ba1e:	33 27       	eor	r19, r19
    ba20:	09 a7       	lds	r16, 0x79
    ba22:	1a a7       	lds	r17, 0x7a
    ba24:	2b a7       	lds	r18, 0x7b
    ba26:	3c a7       	lds	r19, 0x7c
    ba28:	49 ac       	sts	0xa9, r20
    ba2a:	5a ac       	sts	0xaa, r21
    ba2c:	6b ac       	sts	0xab, r22
    ba2e:	7c ac       	sts	0xac, r23
    ba30:	2f ef       	ldi	r18, 0xFF	; 255
    ba32:	3f ef       	ldi	r19, 0xFF	; 255
    ba34:	40 e0       	ldi	r20, 0x00	; 0
    ba36:	50 e0       	ldi	r21, 0x00	; 0
    ba38:	42 22       	and	r4, r18
    ba3a:	53 22       	and	r5, r19
    ba3c:	64 22       	and	r6, r20
    ba3e:	75 22       	and	r7, r21
    ba40:	29 ad       	sts	0x69, r18
    ba42:	3a ad       	sts	0x6a, r19
    ba44:	4b ad       	sts	0x6b, r20
    ba46:	5c ad       	sts	0x6c, r21
    ba48:	8a 01       	movw	r16, r20
    ba4a:	22 27       	eor	r18, r18
    ba4c:	33 27       	eor	r19, r19
    ba4e:	09 ab       	sts	0x59, r16
    ba50:	1a ab       	sts	0x5a, r17
    ba52:	2b ab       	sts	0x5b, r18
    ba54:	3c ab       	sts	0x5c, r19
    ba56:	c5 01       	movw	r24, r10
    ba58:	b4 01       	movw	r22, r8
    ba5a:	a3 01       	movw	r20, r6
    ba5c:	92 01       	movw	r18, r4
    ba5e:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    ba62:	69 af       	sts	0x79, r22
    ba64:	7a af       	sts	0x7a, r23
    ba66:	8b af       	sts	0x7b, r24
    ba68:	9c af       	sts	0x7c, r25
    ba6a:	c5 01       	movw	r24, r10
    ba6c:	b4 01       	movw	r22, r8
    ba6e:	29 a9       	sts	0x49, r18
    ba70:	3a a9       	sts	0x4a, r19
    ba72:	4b a9       	sts	0x4b, r20
    ba74:	5c a9       	sts	0x4c, r21
    ba76:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    ba7a:	4b 01       	movw	r8, r22
    ba7c:	5c 01       	movw	r10, r24
    ba7e:	69 a5       	lds	r22, 0x69
    ba80:	7a a5       	lds	r23, 0x6a
    ba82:	8b a5       	lds	r24, 0x6b
    ba84:	9c a5       	lds	r25, 0x6c
    ba86:	a3 01       	movw	r20, r6
    ba88:	92 01       	movw	r18, r4
    ba8a:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    ba8e:	2b 01       	movw	r4, r22
    ba90:	3c 01       	movw	r6, r24
    ba92:	69 a5       	lds	r22, 0x69
    ba94:	7a a5       	lds	r23, 0x6a
    ba96:	8b a5       	lds	r24, 0x6b
    ba98:	9c a5       	lds	r25, 0x6c
    ba9a:	29 a9       	sts	0x49, r18
    ba9c:	3a a9       	sts	0x4a, r19
    ba9e:	4b a9       	sts	0x4b, r20
    baa0:	5c a9       	sts	0x4c, r21
    baa2:	0e 94 4d 60 	call	0xc09a	; 0xc09a <__mulsi3>
    baa6:	ab 01       	movw	r20, r22
    baa8:	bc 01       	movw	r22, r24
    baaa:	84 0c       	add	r8, r4
    baac:	95 1c       	adc	r9, r5
    baae:	a6 1c       	adc	r10, r6
    bab0:	b7 1c       	adc	r11, r7
    bab2:	09 ad       	sts	0x69, r16
    bab4:	1a ad       	sts	0x6a, r17
    bab6:	2b ad       	sts	0x6b, r18
    bab8:	3c ad       	sts	0x6c, r19
    baba:	c9 01       	movw	r24, r18
    babc:	aa 27       	eor	r26, r26
    babe:	bb 27       	eor	r27, r27
    bac0:	88 0e       	add	r8, r24
    bac2:	99 1e       	adc	r9, r25
    bac4:	aa 1e       	adc	r10, r26
    bac6:	bb 1e       	adc	r11, r27
    bac8:	84 14       	cp	r8, r4
    baca:	95 04       	cpc	r9, r5
    bacc:	a6 04       	cpc	r10, r6
    bace:	b7 04       	cpc	r11, r7
    bad0:	20 f4       	brcc	.+8      	; 0xbada <__divdi3+0xde4>
    bad2:	40 50       	subi	r20, 0x00	; 0
    bad4:	50 40       	sbci	r21, 0x00	; 0
    bad6:	6f 4f       	sbci	r22, 0xFF	; 255
    bad8:	7f 4f       	sbci	r23, 0xFF	; 255
    bada:	c5 01       	movw	r24, r10
    badc:	aa 27       	eor	r26, r26
    bade:	bb 27       	eor	r27, r27
    bae0:	84 0f       	add	r24, r20
    bae2:	95 1f       	adc	r25, r21
    bae4:	a6 1f       	adc	r26, r22
    bae6:	b7 1f       	adc	r27, r23
    bae8:	0d a5       	lds	r16, 0x6d
    baea:	1e a5       	lds	r17, 0x6e
    baec:	2f a5       	lds	r18, 0x6f
    baee:	38 a9       	sts	0x48, r19
    baf0:	08 17       	cp	r16, r24
    baf2:	19 07       	cpc	r17, r25
    baf4:	2a 07       	cpc	r18, r26
    baf6:	3b 07       	cpc	r19, r27
    baf8:	18 f1       	brcs	.+70     	; 0xbb40 <__divdi3+0xe4a>
    bafa:	80 17       	cp	r24, r16
    bafc:	91 07       	cpc	r25, r17
    bafe:	a2 07       	cpc	r26, r18
    bb00:	b3 07       	cpc	r27, r19
    bb02:	a1 f5       	brne	.+104    	; 0xbb6c <__divdi3+0xe76>
    bb04:	54 01       	movw	r10, r8
    bb06:	99 24       	eor	r9, r9
    bb08:	88 24       	eor	r8, r8
    bb0a:	89 ad       	sts	0x69, r24
    bb0c:	9a ad       	sts	0x6a, r25
    bb0e:	ab ad       	sts	0x6b, r26
    bb10:	bc ad       	sts	0x6c, r27
    bb12:	a0 70       	andi	r26, 0x00	; 0
    bb14:	b0 70       	andi	r27, 0x00	; 0
    bb16:	88 0e       	add	r8, r24
    bb18:	99 1e       	adc	r9, r25
    bb1a:	aa 1e       	adc	r10, r26
    bb1c:	bb 1e       	adc	r11, r27
    bb1e:	4d a9       	sts	0x4d, r20
    bb20:	5e a9       	sts	0x4e, r21
    bb22:	6f a9       	sts	0x4f, r22
    bb24:	78 ad       	sts	0x68, r23
    bb26:	03 2c       	mov	r0, r3
    bb28:	04 c0       	rjmp	.+8      	; 0xbb32 <__divdi3+0xe3c>
    bb2a:	44 0f       	add	r20, r20
    bb2c:	55 1f       	adc	r21, r21
    bb2e:	66 1f       	adc	r22, r22
    bb30:	77 1f       	adc	r23, r23
    bb32:	0a 94       	dec	r0
    bb34:	d2 f7       	brpl	.-12     	; 0xbb2a <__divdi3+0xe34>
    bb36:	48 15       	cp	r20, r8
    bb38:	59 05       	cpc	r21, r9
    bb3a:	6a 05       	cpc	r22, r10
    bb3c:	7b 05       	cpc	r23, r11
    bb3e:	b0 f4       	brcc	.+44     	; 0xbb6c <__divdi3+0xe76>
    bb40:	08 94       	sec
    bb42:	c1 08       	sbc	r12, r1
    bb44:	d1 08       	sbc	r13, r1
    bb46:	e1 08       	sbc	r14, r1
    bb48:	f1 08       	sbc	r15, r1
    bb4a:	10 c0       	rjmp	.+32     	; 0xbb6c <__divdi3+0xe76>
    bb4c:	44 24       	eor	r4, r4
    bb4e:	55 24       	eor	r5, r5
    bb50:	32 01       	movw	r6, r4
    bb52:	cc 24       	eor	r12, r12
    bb54:	dd 24       	eor	r13, r13
    bb56:	76 01       	movw	r14, r12
    bb58:	0c c0       	rjmp	.+24     	; 0xbb72 <__divdi3+0xe7c>
    bb5a:	44 24       	eor	r4, r4
    bb5c:	55 24       	eor	r5, r5
    bb5e:	32 01       	movw	r6, r4
    bb60:	81 e0       	ldi	r24, 0x01	; 1
    bb62:	c8 2e       	mov	r12, r24
    bb64:	d1 2c       	mov	r13, r1
    bb66:	e1 2c       	mov	r14, r1
    bb68:	f1 2c       	mov	r15, r1
    bb6a:	03 c0       	rjmp	.+6      	; 0xbb72 <__divdi3+0xe7c>
    bb6c:	44 24       	eor	r4, r4
    bb6e:	55 24       	eor	r5, r5
    bb70:	32 01       	movw	r6, r4
    bb72:	fe 01       	movw	r30, r28
    bb74:	31 96       	adiw	r30, 0x01	; 1
    bb76:	88 e0       	ldi	r24, 0x08	; 8
    bb78:	df 01       	movw	r26, r30
    bb7a:	1d 92       	st	X+, r1
    bb7c:	8a 95       	dec	r24
    bb7e:	e9 f7       	brne	.-6      	; 0xbb7a <__divdi3+0xe84>
    bb80:	c9 82       	std	Y+1, r12	; 0x01
    bb82:	da 82       	std	Y+2, r13	; 0x02
    bb84:	eb 82       	std	Y+3, r14	; 0x03
    bb86:	fc 82       	std	Y+4, r15	; 0x04
    bb88:	4d 82       	std	Y+5, r4	; 0x05
    bb8a:	5e 82       	std	Y+6, r5	; 0x06
    bb8c:	6f 82       	std	Y+7, r6	; 0x07
    bb8e:	78 86       	std	Y+8, r7	; 0x08
    bb90:	2c 2d       	mov	r18, r12
    bb92:	3a 81       	ldd	r19, Y+2	; 0x02
    bb94:	4b 81       	ldd	r20, Y+3	; 0x03
    bb96:	5c 81       	ldd	r21, Y+4	; 0x04
    bb98:	64 2d       	mov	r22, r4
    bb9a:	7e 81       	ldd	r23, Y+6	; 0x06
    bb9c:	8f 81       	ldd	r24, Y+7	; 0x07
    bb9e:	98 85       	ldd	r25, Y+8	; 0x08
    bba0:	25 96       	adiw	r28, 0x05	; 5
    bba2:	ec ac       	sts	0xac, r30
    bba4:	fd ac       	sts	0xad, r31
    bba6:	0e ad       	sts	0x6e, r16
    bba8:	1f ad       	sts	0x6f, r17
    bbaa:	25 97       	sbiw	r28, 0x05	; 5
    bbac:	e1 14       	cp	r14, r1
    bbae:	f1 04       	cpc	r15, r1
    bbb0:	01 05       	cpc	r16, r1
    bbb2:	11 05       	cpc	r17, r1
    bbb4:	09 f4       	brne	.+2      	; 0xbbb8 <__divdi3+0xec2>
    bbb6:	56 c0       	rjmp	.+172    	; 0xbc64 <__divdi3+0xf6e>
    bbb8:	21 95       	neg	r18
    bbba:	e1 e0       	ldi	r30, 0x01	; 1
    bbbc:	12 16       	cp	r1, r18
    bbbe:	08 f0       	brcs	.+2      	; 0xbbc2 <__divdi3+0xecc>
    bbc0:	e0 e0       	ldi	r30, 0x00	; 0
    bbc2:	31 95       	neg	r19
    bbc4:	f1 e0       	ldi	r31, 0x01	; 1
    bbc6:	13 16       	cp	r1, r19
    bbc8:	08 f0       	brcs	.+2      	; 0xbbcc <__divdi3+0xed6>
    bbca:	f0 e0       	ldi	r31, 0x00	; 0
    bbcc:	03 2f       	mov	r16, r19
    bbce:	0e 1b       	sub	r16, r30
    bbd0:	e1 e0       	ldi	r30, 0x01	; 1
    bbd2:	30 17       	cp	r19, r16
    bbd4:	08 f0       	brcs	.+2      	; 0xbbd8 <__divdi3+0xee2>
    bbd6:	e0 e0       	ldi	r30, 0x00	; 0
    bbd8:	fe 2b       	or	r31, r30
    bbda:	41 95       	neg	r20
    bbdc:	e1 e0       	ldi	r30, 0x01	; 1
    bbde:	14 16       	cp	r1, r20
    bbe0:	08 f0       	brcs	.+2      	; 0xbbe4 <__divdi3+0xeee>
    bbe2:	e0 e0       	ldi	r30, 0x00	; 0
    bbe4:	14 2f       	mov	r17, r20
    bbe6:	1f 1b       	sub	r17, r31
    bbe8:	31 e0       	ldi	r19, 0x01	; 1
    bbea:	41 17       	cp	r20, r17
    bbec:	08 f0       	brcs	.+2      	; 0xbbf0 <__divdi3+0xefa>
    bbee:	30 e0       	ldi	r19, 0x00	; 0
    bbf0:	e3 2b       	or	r30, r19
    bbf2:	51 95       	neg	r21
    bbf4:	f1 e0       	ldi	r31, 0x01	; 1
    bbf6:	15 16       	cp	r1, r21
    bbf8:	08 f0       	brcs	.+2      	; 0xbbfc <__divdi3+0xf06>
    bbfa:	f0 e0       	ldi	r31, 0x00	; 0
    bbfc:	b5 2f       	mov	r27, r21
    bbfe:	be 1b       	sub	r27, r30
    bc00:	31 e0       	ldi	r19, 0x01	; 1
    bc02:	5b 17       	cp	r21, r27
    bc04:	08 f0       	brcs	.+2      	; 0xbc08 <__divdi3+0xf12>
    bc06:	30 e0       	ldi	r19, 0x00	; 0
    bc08:	f3 2b       	or	r31, r19
    bc0a:	61 95       	neg	r22
    bc0c:	e1 e0       	ldi	r30, 0x01	; 1
    bc0e:	16 16       	cp	r1, r22
    bc10:	08 f0       	brcs	.+2      	; 0xbc14 <__divdi3+0xf1e>
    bc12:	e0 e0       	ldi	r30, 0x00	; 0
    bc14:	46 2e       	mov	r4, r22
    bc16:	4f 1a       	sub	r4, r31
    bc18:	31 e0       	ldi	r19, 0x01	; 1
    bc1a:	64 15       	cp	r22, r4
    bc1c:	08 f0       	brcs	.+2      	; 0xbc20 <__divdi3+0xf2a>
    bc1e:	30 e0       	ldi	r19, 0x00	; 0
    bc20:	e3 2b       	or	r30, r19
    bc22:	71 95       	neg	r23
    bc24:	f1 e0       	ldi	r31, 0x01	; 1
    bc26:	17 16       	cp	r1, r23
    bc28:	08 f0       	brcs	.+2      	; 0xbc2c <__divdi3+0xf36>
    bc2a:	f0 e0       	ldi	r31, 0x00	; 0
    bc2c:	a7 2f       	mov	r26, r23
    bc2e:	ae 1b       	sub	r26, r30
    bc30:	31 e0       	ldi	r19, 0x01	; 1
    bc32:	7a 17       	cp	r23, r26
    bc34:	08 f0       	brcs	.+2      	; 0xbc38 <__divdi3+0xf42>
    bc36:	30 e0       	ldi	r19, 0x00	; 0
    bc38:	f3 2b       	or	r31, r19
    bc3a:	81 95       	neg	r24
    bc3c:	e1 e0       	ldi	r30, 0x01	; 1
    bc3e:	18 16       	cp	r1, r24
    bc40:	08 f0       	brcs	.+2      	; 0xbc44 <__divdi3+0xf4e>
    bc42:	e0 e0       	ldi	r30, 0x00	; 0
    bc44:	f8 2e       	mov	r15, r24
    bc46:	ff 1a       	sub	r15, r31
    bc48:	ff 2d       	mov	r31, r15
    bc4a:	31 e0       	ldi	r19, 0x01	; 1
    bc4c:	8f 15       	cp	r24, r15
    bc4e:	08 f0       	brcs	.+2      	; 0xbc52 <__divdi3+0xf5c>
    bc50:	30 e0       	ldi	r19, 0x00	; 0
    bc52:	e3 2b       	or	r30, r19
    bc54:	91 95       	neg	r25
    bc56:	30 2f       	mov	r19, r16
    bc58:	41 2f       	mov	r20, r17
    bc5a:	5b 2f       	mov	r21, r27
    bc5c:	64 2d       	mov	r22, r4
    bc5e:	7a 2f       	mov	r23, r26
    bc60:	8f 2f       	mov	r24, r31
    bc62:	9e 1b       	sub	r25, r30
    bc64:	c8 5b       	subi	r28, 0xB8	; 184
    bc66:	df 4f       	sbci	r29, 0xFF	; 255
    bc68:	e1 e1       	ldi	r30, 0x11	; 17
    bc6a:	0c 94 ea 60 	jmp	0xc1d4	; 0xc1d4 <__epilogue_restores__+0x2>

0000bc6e <__subsf3>:
    bc6e:	50 58       	subi	r21, 0x80	; 128

0000bc70 <__addsf3>:
    bc70:	bb 27       	eor	r27, r27
    bc72:	aa 27       	eor	r26, r26
    bc74:	0e d0       	rcall	.+28     	; 0xbc92 <__addsf3x>
    bc76:	70 c1       	rjmp	.+736    	; 0xbf58 <__fp_round>
    bc78:	61 d1       	rcall	.+706    	; 0xbf3c <__fp_pscA>
    bc7a:	30 f0       	brcs	.+12     	; 0xbc88 <__addsf3+0x18>
    bc7c:	66 d1       	rcall	.+716    	; 0xbf4a <__fp_pscB>
    bc7e:	20 f0       	brcs	.+8      	; 0xbc88 <__addsf3+0x18>
    bc80:	31 f4       	brne	.+12     	; 0xbc8e <__addsf3+0x1e>
    bc82:	9f 3f       	cpi	r25, 0xFF	; 255
    bc84:	11 f4       	brne	.+4      	; 0xbc8a <__addsf3+0x1a>
    bc86:	1e f4       	brtc	.+6      	; 0xbc8e <__addsf3+0x1e>
    bc88:	56 c1       	rjmp	.+684    	; 0xbf36 <__fp_nan>
    bc8a:	0e f4       	brtc	.+2      	; 0xbc8e <__addsf3+0x1e>
    bc8c:	e0 95       	com	r30
    bc8e:	e7 fb       	bst	r30, 7
    bc90:	4c c1       	rjmp	.+664    	; 0xbf2a <__fp_inf>

0000bc92 <__addsf3x>:
    bc92:	e9 2f       	mov	r30, r25
    bc94:	72 d1       	rcall	.+740    	; 0xbf7a <__fp_split3>
    bc96:	80 f3       	brcs	.-32     	; 0xbc78 <__addsf3+0x8>
    bc98:	ba 17       	cp	r27, r26
    bc9a:	62 07       	cpc	r22, r18
    bc9c:	73 07       	cpc	r23, r19
    bc9e:	84 07       	cpc	r24, r20
    bca0:	95 07       	cpc	r25, r21
    bca2:	18 f0       	brcs	.+6      	; 0xbcaa <__addsf3x+0x18>
    bca4:	71 f4       	brne	.+28     	; 0xbcc2 <__addsf3x+0x30>
    bca6:	9e f5       	brtc	.+102    	; 0xbd0e <__addsf3x+0x7c>
    bca8:	8a c1       	rjmp	.+788    	; 0xbfbe <__fp_zero>
    bcaa:	0e f4       	brtc	.+2      	; 0xbcae <__addsf3x+0x1c>
    bcac:	e0 95       	com	r30
    bcae:	0b 2e       	mov	r0, r27
    bcb0:	ba 2f       	mov	r27, r26
    bcb2:	a0 2d       	mov	r26, r0
    bcb4:	0b 01       	movw	r0, r22
    bcb6:	b9 01       	movw	r22, r18
    bcb8:	90 01       	movw	r18, r0
    bcba:	0c 01       	movw	r0, r24
    bcbc:	ca 01       	movw	r24, r20
    bcbe:	a0 01       	movw	r20, r0
    bcc0:	11 24       	eor	r1, r1
    bcc2:	ff 27       	eor	r31, r31
    bcc4:	59 1b       	sub	r21, r25
    bcc6:	99 f0       	breq	.+38     	; 0xbcee <__addsf3x+0x5c>
    bcc8:	59 3f       	cpi	r21, 0xF9	; 249
    bcca:	50 f4       	brcc	.+20     	; 0xbce0 <__addsf3x+0x4e>
    bccc:	50 3e       	cpi	r21, 0xE0	; 224
    bcce:	68 f1       	brcs	.+90     	; 0xbd2a <__addsf3x+0x98>
    bcd0:	1a 16       	cp	r1, r26
    bcd2:	f0 40       	sbci	r31, 0x00	; 0
    bcd4:	a2 2f       	mov	r26, r18
    bcd6:	23 2f       	mov	r18, r19
    bcd8:	34 2f       	mov	r19, r20
    bcda:	44 27       	eor	r20, r20
    bcdc:	58 5f       	subi	r21, 0xF8	; 248
    bcde:	f3 cf       	rjmp	.-26     	; 0xbcc6 <__addsf3x+0x34>
    bce0:	46 95       	lsr	r20
    bce2:	37 95       	ror	r19
    bce4:	27 95       	ror	r18
    bce6:	a7 95       	ror	r26
    bce8:	f0 40       	sbci	r31, 0x00	; 0
    bcea:	53 95       	inc	r21
    bcec:	c9 f7       	brne	.-14     	; 0xbce0 <__addsf3x+0x4e>
    bcee:	7e f4       	brtc	.+30     	; 0xbd0e <__addsf3x+0x7c>
    bcf0:	1f 16       	cp	r1, r31
    bcf2:	ba 0b       	sbc	r27, r26
    bcf4:	62 0b       	sbc	r22, r18
    bcf6:	73 0b       	sbc	r23, r19
    bcf8:	84 0b       	sbc	r24, r20
    bcfa:	ba f0       	brmi	.+46     	; 0xbd2a <__addsf3x+0x98>
    bcfc:	91 50       	subi	r25, 0x01	; 1
    bcfe:	a1 f0       	breq	.+40     	; 0xbd28 <__addsf3x+0x96>
    bd00:	ff 0f       	add	r31, r31
    bd02:	bb 1f       	adc	r27, r27
    bd04:	66 1f       	adc	r22, r22
    bd06:	77 1f       	adc	r23, r23
    bd08:	88 1f       	adc	r24, r24
    bd0a:	c2 f7       	brpl	.-16     	; 0xbcfc <__addsf3x+0x6a>
    bd0c:	0e c0       	rjmp	.+28     	; 0xbd2a <__addsf3x+0x98>
    bd0e:	ba 0f       	add	r27, r26
    bd10:	62 1f       	adc	r22, r18
    bd12:	73 1f       	adc	r23, r19
    bd14:	84 1f       	adc	r24, r20
    bd16:	48 f4       	brcc	.+18     	; 0xbd2a <__addsf3x+0x98>
    bd18:	87 95       	ror	r24
    bd1a:	77 95       	ror	r23
    bd1c:	67 95       	ror	r22
    bd1e:	b7 95       	ror	r27
    bd20:	f7 95       	ror	r31
    bd22:	9e 3f       	cpi	r25, 0xFE	; 254
    bd24:	08 f0       	brcs	.+2      	; 0xbd28 <__addsf3x+0x96>
    bd26:	b3 cf       	rjmp	.-154    	; 0xbc8e <__addsf3+0x1e>
    bd28:	93 95       	inc	r25
    bd2a:	88 0f       	add	r24, r24
    bd2c:	08 f0       	brcs	.+2      	; 0xbd30 <__addsf3x+0x9e>
    bd2e:	99 27       	eor	r25, r25
    bd30:	ee 0f       	add	r30, r30
    bd32:	97 95       	ror	r25
    bd34:	87 95       	ror	r24
    bd36:	08 95       	ret

0000bd38 <__cmpsf2>:
    bd38:	d4 d0       	rcall	.+424    	; 0xbee2 <__fp_cmp>
    bd3a:	08 f4       	brcc	.+2      	; 0xbd3e <__cmpsf2+0x6>
    bd3c:	81 e0       	ldi	r24, 0x01	; 1
    bd3e:	08 95       	ret

0000bd40 <__divsf3>:
    bd40:	0c d0       	rcall	.+24     	; 0xbd5a <__divsf3x>
    bd42:	0a c1       	rjmp	.+532    	; 0xbf58 <__fp_round>
    bd44:	02 d1       	rcall	.+516    	; 0xbf4a <__fp_pscB>
    bd46:	40 f0       	brcs	.+16     	; 0xbd58 <__divsf3+0x18>
    bd48:	f9 d0       	rcall	.+498    	; 0xbf3c <__fp_pscA>
    bd4a:	30 f0       	brcs	.+12     	; 0xbd58 <__divsf3+0x18>
    bd4c:	21 f4       	brne	.+8      	; 0xbd56 <__divsf3+0x16>
    bd4e:	5f 3f       	cpi	r21, 0xFF	; 255
    bd50:	19 f0       	breq	.+6      	; 0xbd58 <__divsf3+0x18>
    bd52:	eb c0       	rjmp	.+470    	; 0xbf2a <__fp_inf>
    bd54:	51 11       	cpse	r21, r1
    bd56:	34 c1       	rjmp	.+616    	; 0xbfc0 <__fp_szero>
    bd58:	ee c0       	rjmp	.+476    	; 0xbf36 <__fp_nan>

0000bd5a <__divsf3x>:
    bd5a:	0f d1       	rcall	.+542    	; 0xbf7a <__fp_split3>
    bd5c:	98 f3       	brcs	.-26     	; 0xbd44 <__divsf3+0x4>

0000bd5e <__divsf3_pse>:
    bd5e:	99 23       	and	r25, r25
    bd60:	c9 f3       	breq	.-14     	; 0xbd54 <__divsf3+0x14>
    bd62:	55 23       	and	r21, r21
    bd64:	b1 f3       	breq	.-20     	; 0xbd52 <__divsf3+0x12>
    bd66:	95 1b       	sub	r25, r21
    bd68:	55 0b       	sbc	r21, r21
    bd6a:	bb 27       	eor	r27, r27
    bd6c:	aa 27       	eor	r26, r26
    bd6e:	62 17       	cp	r22, r18
    bd70:	73 07       	cpc	r23, r19
    bd72:	84 07       	cpc	r24, r20
    bd74:	38 f0       	brcs	.+14     	; 0xbd84 <__divsf3_pse+0x26>
    bd76:	9f 5f       	subi	r25, 0xFF	; 255
    bd78:	5f 4f       	sbci	r21, 0xFF	; 255
    bd7a:	22 0f       	add	r18, r18
    bd7c:	33 1f       	adc	r19, r19
    bd7e:	44 1f       	adc	r20, r20
    bd80:	aa 1f       	adc	r26, r26
    bd82:	a9 f3       	breq	.-22     	; 0xbd6e <__divsf3_pse+0x10>
    bd84:	33 d0       	rcall	.+102    	; 0xbdec <__divsf3_pse+0x8e>
    bd86:	0e 2e       	mov	r0, r30
    bd88:	3a f0       	brmi	.+14     	; 0xbd98 <__divsf3_pse+0x3a>
    bd8a:	e0 e8       	ldi	r30, 0x80	; 128
    bd8c:	30 d0       	rcall	.+96     	; 0xbdee <__divsf3_pse+0x90>
    bd8e:	91 50       	subi	r25, 0x01	; 1
    bd90:	50 40       	sbci	r21, 0x00	; 0
    bd92:	e6 95       	lsr	r30
    bd94:	00 1c       	adc	r0, r0
    bd96:	ca f7       	brpl	.-14     	; 0xbd8a <__divsf3_pse+0x2c>
    bd98:	29 d0       	rcall	.+82     	; 0xbdec <__divsf3_pse+0x8e>
    bd9a:	fe 2f       	mov	r31, r30
    bd9c:	27 d0       	rcall	.+78     	; 0xbdec <__divsf3_pse+0x8e>
    bd9e:	66 0f       	add	r22, r22
    bda0:	77 1f       	adc	r23, r23
    bda2:	88 1f       	adc	r24, r24
    bda4:	bb 1f       	adc	r27, r27
    bda6:	26 17       	cp	r18, r22
    bda8:	37 07       	cpc	r19, r23
    bdaa:	48 07       	cpc	r20, r24
    bdac:	ab 07       	cpc	r26, r27
    bdae:	b0 e8       	ldi	r27, 0x80	; 128
    bdb0:	09 f0       	breq	.+2      	; 0xbdb4 <__divsf3_pse+0x56>
    bdb2:	bb 0b       	sbc	r27, r27
    bdb4:	80 2d       	mov	r24, r0
    bdb6:	bf 01       	movw	r22, r30
    bdb8:	ff 27       	eor	r31, r31
    bdba:	93 58       	subi	r25, 0x83	; 131
    bdbc:	5f 4f       	sbci	r21, 0xFF	; 255
    bdbe:	2a f0       	brmi	.+10     	; 0xbdca <__divsf3_pse+0x6c>
    bdc0:	9e 3f       	cpi	r25, 0xFE	; 254
    bdc2:	51 05       	cpc	r21, r1
    bdc4:	68 f0       	brcs	.+26     	; 0xbde0 <__divsf3_pse+0x82>
    bdc6:	b1 c0       	rjmp	.+354    	; 0xbf2a <__fp_inf>
    bdc8:	fb c0       	rjmp	.+502    	; 0xbfc0 <__fp_szero>
    bdca:	5f 3f       	cpi	r21, 0xFF	; 255
    bdcc:	ec f3       	brlt	.-6      	; 0xbdc8 <__divsf3_pse+0x6a>
    bdce:	98 3e       	cpi	r25, 0xE8	; 232
    bdd0:	dc f3       	brlt	.-10     	; 0xbdc8 <__divsf3_pse+0x6a>
    bdd2:	86 95       	lsr	r24
    bdd4:	77 95       	ror	r23
    bdd6:	67 95       	ror	r22
    bdd8:	b7 95       	ror	r27
    bdda:	f7 95       	ror	r31
    bddc:	9f 5f       	subi	r25, 0xFF	; 255
    bdde:	c9 f7       	brne	.-14     	; 0xbdd2 <__divsf3_pse+0x74>
    bde0:	88 0f       	add	r24, r24
    bde2:	91 1d       	adc	r25, r1
    bde4:	96 95       	lsr	r25
    bde6:	87 95       	ror	r24
    bde8:	97 f9       	bld	r25, 7
    bdea:	08 95       	ret
    bdec:	e1 e0       	ldi	r30, 0x01	; 1
    bdee:	66 0f       	add	r22, r22
    bdf0:	77 1f       	adc	r23, r23
    bdf2:	88 1f       	adc	r24, r24
    bdf4:	bb 1f       	adc	r27, r27
    bdf6:	62 17       	cp	r22, r18
    bdf8:	73 07       	cpc	r23, r19
    bdfa:	84 07       	cpc	r24, r20
    bdfc:	ba 07       	cpc	r27, r26
    bdfe:	20 f0       	brcs	.+8      	; 0xbe08 <__divsf3_pse+0xaa>
    be00:	62 1b       	sub	r22, r18
    be02:	73 0b       	sbc	r23, r19
    be04:	84 0b       	sbc	r24, r20
    be06:	ba 0b       	sbc	r27, r26
    be08:	ee 1f       	adc	r30, r30
    be0a:	88 f7       	brcc	.-30     	; 0xbdee <__divsf3_pse+0x90>
    be0c:	e0 95       	com	r30
    be0e:	08 95       	ret

0000be10 <__fixunssfsi>:
    be10:	bc d0       	rcall	.+376    	; 0xbf8a <__fp_splitA>
    be12:	88 f0       	brcs	.+34     	; 0xbe36 <__fixunssfsi+0x26>
    be14:	9f 57       	subi	r25, 0x7F	; 127
    be16:	90 f0       	brcs	.+36     	; 0xbe3c <__fixunssfsi+0x2c>
    be18:	b9 2f       	mov	r27, r25
    be1a:	99 27       	eor	r25, r25
    be1c:	b7 51       	subi	r27, 0x17	; 23
    be1e:	a0 f0       	brcs	.+40     	; 0xbe48 <__fixunssfsi+0x38>
    be20:	d1 f0       	breq	.+52     	; 0xbe56 <__fixunssfsi+0x46>
    be22:	66 0f       	add	r22, r22
    be24:	77 1f       	adc	r23, r23
    be26:	88 1f       	adc	r24, r24
    be28:	99 1f       	adc	r25, r25
    be2a:	1a f0       	brmi	.+6      	; 0xbe32 <__fixunssfsi+0x22>
    be2c:	ba 95       	dec	r27
    be2e:	c9 f7       	brne	.-14     	; 0xbe22 <__fixunssfsi+0x12>
    be30:	12 c0       	rjmp	.+36     	; 0xbe56 <__fixunssfsi+0x46>
    be32:	b1 30       	cpi	r27, 0x01	; 1
    be34:	81 f0       	breq	.+32     	; 0xbe56 <__fixunssfsi+0x46>
    be36:	c3 d0       	rcall	.+390    	; 0xbfbe <__fp_zero>
    be38:	b1 e0       	ldi	r27, 0x01	; 1
    be3a:	08 95       	ret
    be3c:	c0 c0       	rjmp	.+384    	; 0xbfbe <__fp_zero>
    be3e:	67 2f       	mov	r22, r23
    be40:	78 2f       	mov	r23, r24
    be42:	88 27       	eor	r24, r24
    be44:	b8 5f       	subi	r27, 0xF8	; 248
    be46:	39 f0       	breq	.+14     	; 0xbe56 <__fixunssfsi+0x46>
    be48:	b9 3f       	cpi	r27, 0xF9	; 249
    be4a:	cc f3       	brlt	.-14     	; 0xbe3e <__fixunssfsi+0x2e>
    be4c:	86 95       	lsr	r24
    be4e:	77 95       	ror	r23
    be50:	67 95       	ror	r22
    be52:	b3 95       	inc	r27
    be54:	d9 f7       	brne	.-10     	; 0xbe4c <__fixunssfsi+0x3c>
    be56:	3e f4       	brtc	.+14     	; 0xbe66 <__fixunssfsi+0x56>
    be58:	90 95       	com	r25
    be5a:	80 95       	com	r24
    be5c:	70 95       	com	r23
    be5e:	61 95       	neg	r22
    be60:	7f 4f       	sbci	r23, 0xFF	; 255
    be62:	8f 4f       	sbci	r24, 0xFF	; 255
    be64:	9f 4f       	sbci	r25, 0xFF	; 255
    be66:	08 95       	ret

0000be68 <__floatunsisf>:
    be68:	e8 94       	clt
    be6a:	09 c0       	rjmp	.+18     	; 0xbe7e <__floatsisf+0x12>

0000be6c <__floatsisf>:
    be6c:	97 fb       	bst	r25, 7
    be6e:	3e f4       	brtc	.+14     	; 0xbe7e <__floatsisf+0x12>
    be70:	90 95       	com	r25
    be72:	80 95       	com	r24
    be74:	70 95       	com	r23
    be76:	61 95       	neg	r22
    be78:	7f 4f       	sbci	r23, 0xFF	; 255
    be7a:	8f 4f       	sbci	r24, 0xFF	; 255
    be7c:	9f 4f       	sbci	r25, 0xFF	; 255
    be7e:	99 23       	and	r25, r25
    be80:	a9 f0       	breq	.+42     	; 0xbeac <__floatsisf+0x40>
    be82:	f9 2f       	mov	r31, r25
    be84:	96 e9       	ldi	r25, 0x96	; 150
    be86:	bb 27       	eor	r27, r27
    be88:	93 95       	inc	r25
    be8a:	f6 95       	lsr	r31
    be8c:	87 95       	ror	r24
    be8e:	77 95       	ror	r23
    be90:	67 95       	ror	r22
    be92:	b7 95       	ror	r27
    be94:	f1 11       	cpse	r31, r1
    be96:	f8 cf       	rjmp	.-16     	; 0xbe88 <__floatsisf+0x1c>
    be98:	fa f4       	brpl	.+62     	; 0xbed8 <__floatsisf+0x6c>
    be9a:	bb 0f       	add	r27, r27
    be9c:	11 f4       	brne	.+4      	; 0xbea2 <__floatsisf+0x36>
    be9e:	60 ff       	sbrs	r22, 0
    bea0:	1b c0       	rjmp	.+54     	; 0xbed8 <__floatsisf+0x6c>
    bea2:	6f 5f       	subi	r22, 0xFF	; 255
    bea4:	7f 4f       	sbci	r23, 0xFF	; 255
    bea6:	8f 4f       	sbci	r24, 0xFF	; 255
    bea8:	9f 4f       	sbci	r25, 0xFF	; 255
    beaa:	16 c0       	rjmp	.+44     	; 0xbed8 <__floatsisf+0x6c>
    beac:	88 23       	and	r24, r24
    beae:	11 f0       	breq	.+4      	; 0xbeb4 <__floatsisf+0x48>
    beb0:	96 e9       	ldi	r25, 0x96	; 150
    beb2:	11 c0       	rjmp	.+34     	; 0xbed6 <__floatsisf+0x6a>
    beb4:	77 23       	and	r23, r23
    beb6:	21 f0       	breq	.+8      	; 0xbec0 <__floatsisf+0x54>
    beb8:	9e e8       	ldi	r25, 0x8E	; 142
    beba:	87 2f       	mov	r24, r23
    bebc:	76 2f       	mov	r23, r22
    bebe:	05 c0       	rjmp	.+10     	; 0xbeca <__floatsisf+0x5e>
    bec0:	66 23       	and	r22, r22
    bec2:	71 f0       	breq	.+28     	; 0xbee0 <__floatsisf+0x74>
    bec4:	96 e8       	ldi	r25, 0x86	; 134
    bec6:	86 2f       	mov	r24, r22
    bec8:	70 e0       	ldi	r23, 0x00	; 0
    beca:	60 e0       	ldi	r22, 0x00	; 0
    becc:	2a f0       	brmi	.+10     	; 0xbed8 <__floatsisf+0x6c>
    bece:	9a 95       	dec	r25
    bed0:	66 0f       	add	r22, r22
    bed2:	77 1f       	adc	r23, r23
    bed4:	88 1f       	adc	r24, r24
    bed6:	da f7       	brpl	.-10     	; 0xbece <__floatsisf+0x62>
    bed8:	88 0f       	add	r24, r24
    beda:	96 95       	lsr	r25
    bedc:	87 95       	ror	r24
    bede:	97 f9       	bld	r25, 7
    bee0:	08 95       	ret

0000bee2 <__fp_cmp>:
    bee2:	99 0f       	add	r25, r25
    bee4:	00 08       	sbc	r0, r0
    bee6:	55 0f       	add	r21, r21
    bee8:	aa 0b       	sbc	r26, r26
    beea:	e0 e8       	ldi	r30, 0x80	; 128
    beec:	fe ef       	ldi	r31, 0xFE	; 254
    beee:	16 16       	cp	r1, r22
    bef0:	17 06       	cpc	r1, r23
    bef2:	e8 07       	cpc	r30, r24
    bef4:	f9 07       	cpc	r31, r25
    bef6:	c0 f0       	brcs	.+48     	; 0xbf28 <__fp_cmp+0x46>
    bef8:	12 16       	cp	r1, r18
    befa:	13 06       	cpc	r1, r19
    befc:	e4 07       	cpc	r30, r20
    befe:	f5 07       	cpc	r31, r21
    bf00:	98 f0       	brcs	.+38     	; 0xbf28 <__fp_cmp+0x46>
    bf02:	62 1b       	sub	r22, r18
    bf04:	73 0b       	sbc	r23, r19
    bf06:	84 0b       	sbc	r24, r20
    bf08:	95 0b       	sbc	r25, r21
    bf0a:	39 f4       	brne	.+14     	; 0xbf1a <__fp_cmp+0x38>
    bf0c:	0a 26       	eor	r0, r26
    bf0e:	61 f0       	breq	.+24     	; 0xbf28 <__fp_cmp+0x46>
    bf10:	23 2b       	or	r18, r19
    bf12:	24 2b       	or	r18, r20
    bf14:	25 2b       	or	r18, r21
    bf16:	21 f4       	brne	.+8      	; 0xbf20 <__fp_cmp+0x3e>
    bf18:	08 95       	ret
    bf1a:	0a 26       	eor	r0, r26
    bf1c:	09 f4       	brne	.+2      	; 0xbf20 <__fp_cmp+0x3e>
    bf1e:	a1 40       	sbci	r26, 0x01	; 1
    bf20:	a6 95       	lsr	r26
    bf22:	8f ef       	ldi	r24, 0xFF	; 255
    bf24:	81 1d       	adc	r24, r1
    bf26:	81 1d       	adc	r24, r1
    bf28:	08 95       	ret

0000bf2a <__fp_inf>:
    bf2a:	97 f9       	bld	r25, 7
    bf2c:	9f 67       	ori	r25, 0x7F	; 127
    bf2e:	80 e8       	ldi	r24, 0x80	; 128
    bf30:	70 e0       	ldi	r23, 0x00	; 0
    bf32:	60 e0       	ldi	r22, 0x00	; 0
    bf34:	08 95       	ret

0000bf36 <__fp_nan>:
    bf36:	9f ef       	ldi	r25, 0xFF	; 255
    bf38:	80 ec       	ldi	r24, 0xC0	; 192
    bf3a:	08 95       	ret

0000bf3c <__fp_pscA>:
    bf3c:	00 24       	eor	r0, r0
    bf3e:	0a 94       	dec	r0
    bf40:	16 16       	cp	r1, r22
    bf42:	17 06       	cpc	r1, r23
    bf44:	18 06       	cpc	r1, r24
    bf46:	09 06       	cpc	r0, r25
    bf48:	08 95       	ret

0000bf4a <__fp_pscB>:
    bf4a:	00 24       	eor	r0, r0
    bf4c:	0a 94       	dec	r0
    bf4e:	12 16       	cp	r1, r18
    bf50:	13 06       	cpc	r1, r19
    bf52:	14 06       	cpc	r1, r20
    bf54:	05 06       	cpc	r0, r21
    bf56:	08 95       	ret

0000bf58 <__fp_round>:
    bf58:	09 2e       	mov	r0, r25
    bf5a:	03 94       	inc	r0
    bf5c:	00 0c       	add	r0, r0
    bf5e:	11 f4       	brne	.+4      	; 0xbf64 <__fp_round+0xc>
    bf60:	88 23       	and	r24, r24
    bf62:	52 f0       	brmi	.+20     	; 0xbf78 <__fp_round+0x20>
    bf64:	bb 0f       	add	r27, r27
    bf66:	40 f4       	brcc	.+16     	; 0xbf78 <__fp_round+0x20>
    bf68:	bf 2b       	or	r27, r31
    bf6a:	11 f4       	brne	.+4      	; 0xbf70 <__fp_round+0x18>
    bf6c:	60 ff       	sbrs	r22, 0
    bf6e:	04 c0       	rjmp	.+8      	; 0xbf78 <__fp_round+0x20>
    bf70:	6f 5f       	subi	r22, 0xFF	; 255
    bf72:	7f 4f       	sbci	r23, 0xFF	; 255
    bf74:	8f 4f       	sbci	r24, 0xFF	; 255
    bf76:	9f 4f       	sbci	r25, 0xFF	; 255
    bf78:	08 95       	ret

0000bf7a <__fp_split3>:
    bf7a:	57 fd       	sbrc	r21, 7
    bf7c:	90 58       	subi	r25, 0x80	; 128
    bf7e:	44 0f       	add	r20, r20
    bf80:	55 1f       	adc	r21, r21
    bf82:	59 f0       	breq	.+22     	; 0xbf9a <__fp_splitA+0x10>
    bf84:	5f 3f       	cpi	r21, 0xFF	; 255
    bf86:	71 f0       	breq	.+28     	; 0xbfa4 <__fp_splitA+0x1a>
    bf88:	47 95       	ror	r20

0000bf8a <__fp_splitA>:
    bf8a:	88 0f       	add	r24, r24
    bf8c:	97 fb       	bst	r25, 7
    bf8e:	99 1f       	adc	r25, r25
    bf90:	61 f0       	breq	.+24     	; 0xbfaa <__fp_splitA+0x20>
    bf92:	9f 3f       	cpi	r25, 0xFF	; 255
    bf94:	79 f0       	breq	.+30     	; 0xbfb4 <__fp_splitA+0x2a>
    bf96:	87 95       	ror	r24
    bf98:	08 95       	ret
    bf9a:	12 16       	cp	r1, r18
    bf9c:	13 06       	cpc	r1, r19
    bf9e:	14 06       	cpc	r1, r20
    bfa0:	55 1f       	adc	r21, r21
    bfa2:	f2 cf       	rjmp	.-28     	; 0xbf88 <__fp_split3+0xe>
    bfa4:	46 95       	lsr	r20
    bfa6:	f1 df       	rcall	.-30     	; 0xbf8a <__fp_splitA>
    bfa8:	08 c0       	rjmp	.+16     	; 0xbfba <__fp_splitA+0x30>
    bfaa:	16 16       	cp	r1, r22
    bfac:	17 06       	cpc	r1, r23
    bfae:	18 06       	cpc	r1, r24
    bfb0:	99 1f       	adc	r25, r25
    bfb2:	f1 cf       	rjmp	.-30     	; 0xbf96 <__fp_splitA+0xc>
    bfb4:	86 95       	lsr	r24
    bfb6:	71 05       	cpc	r23, r1
    bfb8:	61 05       	cpc	r22, r1
    bfba:	08 94       	sec
    bfbc:	08 95       	ret

0000bfbe <__fp_zero>:
    bfbe:	e8 94       	clt

0000bfc0 <__fp_szero>:
    bfc0:	bb 27       	eor	r27, r27
    bfc2:	66 27       	eor	r22, r22
    bfc4:	77 27       	eor	r23, r23
    bfc6:	cb 01       	movw	r24, r22
    bfc8:	97 f9       	bld	r25, 7
    bfca:	08 95       	ret

0000bfcc <__gesf2>:
    bfcc:	8a df       	rcall	.-236    	; 0xbee2 <__fp_cmp>
    bfce:	08 f4       	brcc	.+2      	; 0xbfd2 <__gesf2+0x6>
    bfd0:	8f ef       	ldi	r24, 0xFF	; 255
    bfd2:	08 95       	ret

0000bfd4 <__mulsf3>:
    bfd4:	0b d0       	rcall	.+22     	; 0xbfec <__mulsf3x>
    bfd6:	c0 cf       	rjmp	.-128    	; 0xbf58 <__fp_round>
    bfd8:	b1 df       	rcall	.-158    	; 0xbf3c <__fp_pscA>
    bfda:	28 f0       	brcs	.+10     	; 0xbfe6 <__mulsf3+0x12>
    bfdc:	b6 df       	rcall	.-148    	; 0xbf4a <__fp_pscB>
    bfde:	18 f0       	brcs	.+6      	; 0xbfe6 <__mulsf3+0x12>
    bfe0:	95 23       	and	r25, r21
    bfe2:	09 f0       	breq	.+2      	; 0xbfe6 <__mulsf3+0x12>
    bfe4:	a2 cf       	rjmp	.-188    	; 0xbf2a <__fp_inf>
    bfe6:	a7 cf       	rjmp	.-178    	; 0xbf36 <__fp_nan>
    bfe8:	11 24       	eor	r1, r1
    bfea:	ea cf       	rjmp	.-44     	; 0xbfc0 <__fp_szero>

0000bfec <__mulsf3x>:
    bfec:	c6 df       	rcall	.-116    	; 0xbf7a <__fp_split3>
    bfee:	a0 f3       	brcs	.-24     	; 0xbfd8 <__mulsf3+0x4>

0000bff0 <__mulsf3_pse>:
    bff0:	95 9f       	mul	r25, r21
    bff2:	d1 f3       	breq	.-12     	; 0xbfe8 <__mulsf3+0x14>
    bff4:	95 0f       	add	r25, r21
    bff6:	50 e0       	ldi	r21, 0x00	; 0
    bff8:	55 1f       	adc	r21, r21
    bffa:	62 9f       	mul	r22, r18
    bffc:	f0 01       	movw	r30, r0
    bffe:	72 9f       	mul	r23, r18
    c000:	bb 27       	eor	r27, r27
    c002:	f0 0d       	add	r31, r0
    c004:	b1 1d       	adc	r27, r1
    c006:	63 9f       	mul	r22, r19
    c008:	aa 27       	eor	r26, r26
    c00a:	f0 0d       	add	r31, r0
    c00c:	b1 1d       	adc	r27, r1
    c00e:	aa 1f       	adc	r26, r26
    c010:	64 9f       	mul	r22, r20
    c012:	66 27       	eor	r22, r22
    c014:	b0 0d       	add	r27, r0
    c016:	a1 1d       	adc	r26, r1
    c018:	66 1f       	adc	r22, r22
    c01a:	82 9f       	mul	r24, r18
    c01c:	22 27       	eor	r18, r18
    c01e:	b0 0d       	add	r27, r0
    c020:	a1 1d       	adc	r26, r1
    c022:	62 1f       	adc	r22, r18
    c024:	73 9f       	mul	r23, r19
    c026:	b0 0d       	add	r27, r0
    c028:	a1 1d       	adc	r26, r1
    c02a:	62 1f       	adc	r22, r18
    c02c:	83 9f       	mul	r24, r19
    c02e:	a0 0d       	add	r26, r0
    c030:	61 1d       	adc	r22, r1
    c032:	22 1f       	adc	r18, r18
    c034:	74 9f       	mul	r23, r20
    c036:	33 27       	eor	r19, r19
    c038:	a0 0d       	add	r26, r0
    c03a:	61 1d       	adc	r22, r1
    c03c:	23 1f       	adc	r18, r19
    c03e:	84 9f       	mul	r24, r20
    c040:	60 0d       	add	r22, r0
    c042:	21 1d       	adc	r18, r1
    c044:	82 2f       	mov	r24, r18
    c046:	76 2f       	mov	r23, r22
    c048:	6a 2f       	mov	r22, r26
    c04a:	11 24       	eor	r1, r1
    c04c:	9f 57       	subi	r25, 0x7F	; 127
    c04e:	50 40       	sbci	r21, 0x00	; 0
    c050:	8a f0       	brmi	.+34     	; 0xc074 <__mulsf3_pse+0x84>
    c052:	e1 f0       	breq	.+56     	; 0xc08c <__mulsf3_pse+0x9c>
    c054:	88 23       	and	r24, r24
    c056:	4a f0       	brmi	.+18     	; 0xc06a <__mulsf3_pse+0x7a>
    c058:	ee 0f       	add	r30, r30
    c05a:	ff 1f       	adc	r31, r31
    c05c:	bb 1f       	adc	r27, r27
    c05e:	66 1f       	adc	r22, r22
    c060:	77 1f       	adc	r23, r23
    c062:	88 1f       	adc	r24, r24
    c064:	91 50       	subi	r25, 0x01	; 1
    c066:	50 40       	sbci	r21, 0x00	; 0
    c068:	a9 f7       	brne	.-22     	; 0xc054 <__mulsf3_pse+0x64>
    c06a:	9e 3f       	cpi	r25, 0xFE	; 254
    c06c:	51 05       	cpc	r21, r1
    c06e:	70 f0       	brcs	.+28     	; 0xc08c <__mulsf3_pse+0x9c>
    c070:	5c cf       	rjmp	.-328    	; 0xbf2a <__fp_inf>
    c072:	a6 cf       	rjmp	.-180    	; 0xbfc0 <__fp_szero>
    c074:	5f 3f       	cpi	r21, 0xFF	; 255
    c076:	ec f3       	brlt	.-6      	; 0xc072 <__mulsf3_pse+0x82>
    c078:	98 3e       	cpi	r25, 0xE8	; 232
    c07a:	dc f3       	brlt	.-10     	; 0xc072 <__mulsf3_pse+0x82>
    c07c:	86 95       	lsr	r24
    c07e:	77 95       	ror	r23
    c080:	67 95       	ror	r22
    c082:	b7 95       	ror	r27
    c084:	f7 95       	ror	r31
    c086:	e7 95       	ror	r30
    c088:	9f 5f       	subi	r25, 0xFF	; 255
    c08a:	c1 f7       	brne	.-16     	; 0xc07c <__mulsf3_pse+0x8c>
    c08c:	fe 2b       	or	r31, r30
    c08e:	88 0f       	add	r24, r24
    c090:	91 1d       	adc	r25, r1
    c092:	96 95       	lsr	r25
    c094:	87 95       	ror	r24
    c096:	97 f9       	bld	r25, 7
    c098:	08 95       	ret

0000c09a <__mulsi3>:
    c09a:	62 9f       	mul	r22, r18
    c09c:	d0 01       	movw	r26, r0
    c09e:	73 9f       	mul	r23, r19
    c0a0:	f0 01       	movw	r30, r0
    c0a2:	82 9f       	mul	r24, r18
    c0a4:	e0 0d       	add	r30, r0
    c0a6:	f1 1d       	adc	r31, r1
    c0a8:	64 9f       	mul	r22, r20
    c0aa:	e0 0d       	add	r30, r0
    c0ac:	f1 1d       	adc	r31, r1
    c0ae:	92 9f       	mul	r25, r18
    c0b0:	f0 0d       	add	r31, r0
    c0b2:	83 9f       	mul	r24, r19
    c0b4:	f0 0d       	add	r31, r0
    c0b6:	74 9f       	mul	r23, r20
    c0b8:	f0 0d       	add	r31, r0
    c0ba:	65 9f       	mul	r22, r21
    c0bc:	f0 0d       	add	r31, r0
    c0be:	99 27       	eor	r25, r25
    c0c0:	72 9f       	mul	r23, r18
    c0c2:	b0 0d       	add	r27, r0
    c0c4:	e1 1d       	adc	r30, r1
    c0c6:	f9 1f       	adc	r31, r25
    c0c8:	63 9f       	mul	r22, r19
    c0ca:	b0 0d       	add	r27, r0
    c0cc:	e1 1d       	adc	r30, r1
    c0ce:	f9 1f       	adc	r31, r25
    c0d0:	bd 01       	movw	r22, r26
    c0d2:	cf 01       	movw	r24, r30
    c0d4:	11 24       	eor	r1, r1
    c0d6:	08 95       	ret

0000c0d8 <__udivmodhi4>:
    c0d8:	aa 1b       	sub	r26, r26
    c0da:	bb 1b       	sub	r27, r27
    c0dc:	51 e1       	ldi	r21, 0x11	; 17
    c0de:	07 c0       	rjmp	.+14     	; 0xc0ee <__udivmodhi4_ep>

0000c0e0 <__udivmodhi4_loop>:
    c0e0:	aa 1f       	adc	r26, r26
    c0e2:	bb 1f       	adc	r27, r27
    c0e4:	a6 17       	cp	r26, r22
    c0e6:	b7 07       	cpc	r27, r23
    c0e8:	10 f0       	brcs	.+4      	; 0xc0ee <__udivmodhi4_ep>
    c0ea:	a6 1b       	sub	r26, r22
    c0ec:	b7 0b       	sbc	r27, r23

0000c0ee <__udivmodhi4_ep>:
    c0ee:	88 1f       	adc	r24, r24
    c0f0:	99 1f       	adc	r25, r25
    c0f2:	5a 95       	dec	r21
    c0f4:	a9 f7       	brne	.-22     	; 0xc0e0 <__udivmodhi4_loop>
    c0f6:	80 95       	com	r24
    c0f8:	90 95       	com	r25
    c0fa:	bc 01       	movw	r22, r24
    c0fc:	cd 01       	movw	r24, r26
    c0fe:	08 95       	ret

0000c100 <__divmodhi4>:
    c100:	97 fb       	bst	r25, 7
    c102:	09 2e       	mov	r0, r25
    c104:	07 26       	eor	r0, r23
    c106:	0a d0       	rcall	.+20     	; 0xc11c <__divmodhi4_neg1>
    c108:	77 fd       	sbrc	r23, 7
    c10a:	04 d0       	rcall	.+8      	; 0xc114 <__divmodhi4_neg2>
    c10c:	e5 df       	rcall	.-54     	; 0xc0d8 <__udivmodhi4>
    c10e:	06 d0       	rcall	.+12     	; 0xc11c <__divmodhi4_neg1>
    c110:	00 20       	and	r0, r0
    c112:	1a f4       	brpl	.+6      	; 0xc11a <__divmodhi4_exit>

0000c114 <__divmodhi4_neg2>:
    c114:	70 95       	com	r23
    c116:	61 95       	neg	r22
    c118:	7f 4f       	sbci	r23, 0xFF	; 255

0000c11a <__divmodhi4_exit>:
    c11a:	08 95       	ret

0000c11c <__divmodhi4_neg1>:
    c11c:	f6 f7       	brtc	.-4      	; 0xc11a <__divmodhi4_exit>
    c11e:	90 95       	com	r25
    c120:	81 95       	neg	r24
    c122:	9f 4f       	sbci	r25, 0xFF	; 255
    c124:	08 95       	ret

0000c126 <__udivmodsi4>:
    c126:	a1 e2       	ldi	r26, 0x21	; 33
    c128:	1a 2e       	mov	r1, r26
    c12a:	aa 1b       	sub	r26, r26
    c12c:	bb 1b       	sub	r27, r27
    c12e:	fd 01       	movw	r30, r26
    c130:	0d c0       	rjmp	.+26     	; 0xc14c <__udivmodsi4_ep>

0000c132 <__udivmodsi4_loop>:
    c132:	aa 1f       	adc	r26, r26
    c134:	bb 1f       	adc	r27, r27
    c136:	ee 1f       	adc	r30, r30
    c138:	ff 1f       	adc	r31, r31
    c13a:	a2 17       	cp	r26, r18
    c13c:	b3 07       	cpc	r27, r19
    c13e:	e4 07       	cpc	r30, r20
    c140:	f5 07       	cpc	r31, r21
    c142:	20 f0       	brcs	.+8      	; 0xc14c <__udivmodsi4_ep>
    c144:	a2 1b       	sub	r26, r18
    c146:	b3 0b       	sbc	r27, r19
    c148:	e4 0b       	sbc	r30, r20
    c14a:	f5 0b       	sbc	r31, r21

0000c14c <__udivmodsi4_ep>:
    c14c:	66 1f       	adc	r22, r22
    c14e:	77 1f       	adc	r23, r23
    c150:	88 1f       	adc	r24, r24
    c152:	99 1f       	adc	r25, r25
    c154:	1a 94       	dec	r1
    c156:	69 f7       	brne	.-38     	; 0xc132 <__udivmodsi4_loop>
    c158:	60 95       	com	r22
    c15a:	70 95       	com	r23
    c15c:	80 95       	com	r24
    c15e:	90 95       	com	r25
    c160:	9b 01       	movw	r18, r22
    c162:	ac 01       	movw	r20, r24
    c164:	bd 01       	movw	r22, r26
    c166:	cf 01       	movw	r24, r30
    c168:	08 95       	ret

0000c16a <__divmodsi4>:
    c16a:	97 fb       	bst	r25, 7
    c16c:	09 2e       	mov	r0, r25
    c16e:	05 26       	eor	r0, r21
    c170:	0e d0       	rcall	.+28     	; 0xc18e <__divmodsi4_neg1>
    c172:	57 fd       	sbrc	r21, 7
    c174:	04 d0       	rcall	.+8      	; 0xc17e <__divmodsi4_neg2>
    c176:	d7 df       	rcall	.-82     	; 0xc126 <__udivmodsi4>
    c178:	0a d0       	rcall	.+20     	; 0xc18e <__divmodsi4_neg1>
    c17a:	00 1c       	adc	r0, r0
    c17c:	38 f4       	brcc	.+14     	; 0xc18c <__divmodsi4_exit>

0000c17e <__divmodsi4_neg2>:
    c17e:	50 95       	com	r21
    c180:	40 95       	com	r20
    c182:	30 95       	com	r19
    c184:	21 95       	neg	r18
    c186:	3f 4f       	sbci	r19, 0xFF	; 255
    c188:	4f 4f       	sbci	r20, 0xFF	; 255
    c18a:	5f 4f       	sbci	r21, 0xFF	; 255

0000c18c <__divmodsi4_exit>:
    c18c:	08 95       	ret

0000c18e <__divmodsi4_neg1>:
    c18e:	f6 f7       	brtc	.-4      	; 0xc18c <__divmodsi4_exit>
    c190:	90 95       	com	r25
    c192:	80 95       	com	r24
    c194:	70 95       	com	r23
    c196:	61 95       	neg	r22
    c198:	7f 4f       	sbci	r23, 0xFF	; 255
    c19a:	8f 4f       	sbci	r24, 0xFF	; 255
    c19c:	9f 4f       	sbci	r25, 0xFF	; 255
    c19e:	08 95       	ret

0000c1a0 <__prologue_saves__>:
    c1a0:	2f 92       	push	r2
    c1a2:	3f 92       	push	r3
    c1a4:	4f 92       	push	r4
    c1a6:	5f 92       	push	r5
    c1a8:	6f 92       	push	r6
    c1aa:	7f 92       	push	r7
    c1ac:	8f 92       	push	r8
    c1ae:	9f 92       	push	r9
    c1b0:	af 92       	push	r10
    c1b2:	bf 92       	push	r11
    c1b4:	cf 92       	push	r12
    c1b6:	df 92       	push	r13
    c1b8:	ef 92       	push	r14
    c1ba:	ff 92       	push	r15
    c1bc:	0f 93       	push	r16
    c1be:	1f 93       	push	r17
    c1c0:	cf 93       	push	r28
    c1c2:	df 93       	push	r29
    c1c4:	cd b7       	in	r28, 0x3d	; 61
    c1c6:	de b7       	in	r29, 0x3e	; 62
    c1c8:	ca 1b       	sub	r28, r26
    c1ca:	db 0b       	sbc	r29, r27
    c1cc:	cd bf       	out	0x3d, r28	; 61
    c1ce:	de bf       	out	0x3e, r29	; 62
    c1d0:	19 94       	eijmp

0000c1d2 <__epilogue_restores__>:
    c1d2:	2a 88       	ldd	r2, Y+18	; 0x12
    c1d4:	39 88       	ldd	r3, Y+17	; 0x11
    c1d6:	48 88       	ldd	r4, Y+16	; 0x10
    c1d8:	5f 84       	ldd	r5, Y+15	; 0x0f
    c1da:	6e 84       	ldd	r6, Y+14	; 0x0e
    c1dc:	7d 84       	ldd	r7, Y+13	; 0x0d
    c1de:	8c 84       	ldd	r8, Y+12	; 0x0c
    c1e0:	9b 84       	ldd	r9, Y+11	; 0x0b
    c1e2:	aa 84       	ldd	r10, Y+10	; 0x0a
    c1e4:	b9 84       	ldd	r11, Y+9	; 0x09
    c1e6:	c8 84       	ldd	r12, Y+8	; 0x08
    c1e8:	df 80       	ldd	r13, Y+7	; 0x07
    c1ea:	ee 80       	ldd	r14, Y+6	; 0x06
    c1ec:	fd 80       	ldd	r15, Y+5	; 0x05
    c1ee:	0c 81       	ldd	r16, Y+4	; 0x04
    c1f0:	1b 81       	ldd	r17, Y+3	; 0x03
    c1f2:	aa 81       	ldd	r26, Y+2	; 0x02
    c1f4:	b9 81       	ldd	r27, Y+1	; 0x01
    c1f6:	ce 0f       	add	r28, r30
    c1f8:	d1 1d       	adc	r29, r1
    c1fa:	cd bf       	out	0x3d, r28	; 61
    c1fc:	de bf       	out	0x3e, r29	; 62
    c1fe:	ed 01       	movw	r28, r26
    c200:	08 95       	ret

0000c202 <strcpy_P>:
    c202:	fb 01       	movw	r30, r22
    c204:	dc 01       	movw	r26, r24
    c206:	05 90       	lpm	r0, Z+
    c208:	0d 92       	st	X+, r0
    c20a:	00 20       	and	r0, r0
    c20c:	e1 f7       	brne	.-8      	; 0xc206 <strcpy_P+0x4>
    c20e:	08 95       	ret

0000c210 <memmove>:
    c210:	68 17       	cp	r22, r24
    c212:	79 07       	cpc	r23, r25
    c214:	68 f4       	brcc	.+26     	; 0xc230 <memmove+0x20>
    c216:	fb 01       	movw	r30, r22
    c218:	dc 01       	movw	r26, r24
    c21a:	e4 0f       	add	r30, r20
    c21c:	f5 1f       	adc	r31, r21
    c21e:	a4 0f       	add	r26, r20
    c220:	b5 1f       	adc	r27, r21
    c222:	02 c0       	rjmp	.+4      	; 0xc228 <memmove+0x18>
    c224:	02 90       	ld	r0, -Z
    c226:	0e 92       	st	-X, r0
    c228:	41 50       	subi	r20, 0x01	; 1
    c22a:	50 40       	sbci	r21, 0x00	; 0
    c22c:	d8 f7       	brcc	.-10     	; 0xc224 <memmove+0x14>
    c22e:	08 95       	ret
    c230:	0c 94 9b 63 	jmp	0xc736	; 0xc736 <memcpy>

0000c234 <strcat>:
    c234:	fb 01       	movw	r30, r22
    c236:	dc 01       	movw	r26, r24
    c238:	0d 90       	ld	r0, X+
    c23a:	00 20       	and	r0, r0
    c23c:	e9 f7       	brne	.-6      	; 0xc238 <strcat+0x4>
    c23e:	11 97       	sbiw	r26, 0x01	; 1
    c240:	01 90       	ld	r0, Z+
    c242:	0d 92       	st	X+, r0
    c244:	00 20       	and	r0, r0
    c246:	e1 f7       	brne	.-8      	; 0xc240 <strcat+0xc>
    c248:	08 95       	ret

0000c24a <strncmp>:
    c24a:	fb 01       	movw	r30, r22
    c24c:	dc 01       	movw	r26, r24
    c24e:	41 50       	subi	r20, 0x01	; 1
    c250:	50 40       	sbci	r21, 0x00	; 0
    c252:	30 f0       	brcs	.+12     	; 0xc260 <strncmp+0x16>
    c254:	8d 91       	ld	r24, X+
    c256:	01 90       	ld	r0, Z+
    c258:	80 19       	sub	r24, r0
    c25a:	19 f4       	brne	.+6      	; 0xc262 <strncmp+0x18>
    c25c:	00 20       	and	r0, r0
    c25e:	b9 f7       	brne	.-18     	; 0xc24e <strncmp+0x4>
    c260:	88 1b       	sub	r24, r24
    c262:	99 0b       	sbc	r25, r25
    c264:	08 95       	ret

0000c266 <itoa>:
    c266:	fb 01       	movw	r30, r22
    c268:	9f 01       	movw	r18, r30
    c26a:	e8 94       	clt
    c26c:	42 30       	cpi	r20, 0x02	; 2
    c26e:	c4 f0       	brlt	.+48     	; 0xc2a0 <itoa+0x3a>
    c270:	45 32       	cpi	r20, 0x25	; 37
    c272:	b4 f4       	brge	.+44     	; 0xc2a0 <itoa+0x3a>
    c274:	4a 30       	cpi	r20, 0x0A	; 10
    c276:	29 f4       	brne	.+10     	; 0xc282 <itoa+0x1c>
    c278:	97 fb       	bst	r25, 7
    c27a:	1e f4       	brtc	.+6      	; 0xc282 <itoa+0x1c>
    c27c:	90 95       	com	r25
    c27e:	81 95       	neg	r24
    c280:	9f 4f       	sbci	r25, 0xFF	; 255
    c282:	64 2f       	mov	r22, r20
    c284:	77 27       	eor	r23, r23
    c286:	0e 94 6c 60 	call	0xc0d8	; 0xc0d8 <__udivmodhi4>
    c28a:	80 5d       	subi	r24, 0xD0	; 208
    c28c:	8a 33       	cpi	r24, 0x3A	; 58
    c28e:	0c f0       	brlt	.+2      	; 0xc292 <itoa+0x2c>
    c290:	89 5d       	subi	r24, 0xD9	; 217
    c292:	81 93       	st	Z+, r24
    c294:	cb 01       	movw	r24, r22
    c296:	00 97       	sbiw	r24, 0x00	; 0
    c298:	a1 f7       	brne	.-24     	; 0xc282 <itoa+0x1c>
    c29a:	16 f4       	brtc	.+4      	; 0xc2a0 <itoa+0x3a>
    c29c:	5d e2       	ldi	r21, 0x2D	; 45
    c29e:	51 93       	st	Z+, r21
    c2a0:	10 82       	st	Z, r1
    c2a2:	c9 01       	movw	r24, r18
    c2a4:	0c 94 af 63 	jmp	0xc75e	; 0xc75e <strrev>

0000c2a8 <printf>:
    c2a8:	cf 93       	push	r28
    c2aa:	df 93       	push	r29
    c2ac:	cd b7       	in	r28, 0x3d	; 61
    c2ae:	de b7       	in	r29, 0x3e	; 62
    c2b0:	fe 01       	movw	r30, r28
    c2b2:	36 96       	adiw	r30, 0x06	; 6
    c2b4:	61 91       	ld	r22, Z+
    c2b6:	71 91       	ld	r23, Z+
    c2b8:	80 91 d1 50 	lds	r24, 0x50D1
    c2bc:	90 91 d2 50 	lds	r25, 0x50D2
    c2c0:	af 01       	movw	r20, r30
    c2c2:	0e 94 8f 61 	call	0xc31e	; 0xc31e <vfprintf>
    c2c6:	df 91       	pop	r29
    c2c8:	cf 91       	pop	r28
    c2ca:	08 95       	ret

0000c2cc <sprintf>:
    c2cc:	0f 93       	push	r16
    c2ce:	1f 93       	push	r17
    c2d0:	cf 93       	push	r28
    c2d2:	df 93       	push	r29
    c2d4:	cd b7       	in	r28, 0x3d	; 61
    c2d6:	de b7       	in	r29, 0x3e	; 62
    c2d8:	2e 97       	sbiw	r28, 0x0e	; 14
    c2da:	cd bf       	out	0x3d, r28	; 61
    c2dc:	de bf       	out	0x3e, r29	; 62
    c2de:	0e 89       	ldd	r16, Y+22	; 0x16
    c2e0:	1f 89       	ldd	r17, Y+23	; 0x17
    c2e2:	86 e0       	ldi	r24, 0x06	; 6
    c2e4:	8c 83       	std	Y+4, r24	; 0x04
    c2e6:	09 83       	std	Y+1, r16	; 0x01
    c2e8:	1a 83       	std	Y+2, r17	; 0x02
    c2ea:	8f ef       	ldi	r24, 0xFF	; 255
    c2ec:	9f e7       	ldi	r25, 0x7F	; 127
    c2ee:	8d 83       	std	Y+5, r24	; 0x05
    c2f0:	9e 83       	std	Y+6, r25	; 0x06
    c2f2:	ae 01       	movw	r20, r28
    c2f4:	46 5e       	subi	r20, 0xE6	; 230
    c2f6:	5f 4f       	sbci	r21, 0xFF	; 255
    c2f8:	ce 01       	movw	r24, r28
    c2fa:	01 96       	adiw	r24, 0x01	; 1
    c2fc:	68 8d       	ldd	r22, Y+24	; 0x18
    c2fe:	79 8d       	ldd	r23, Y+25	; 0x19
    c300:	0e 94 8f 61 	call	0xc31e	; 0xc31e <vfprintf>
    c304:	ef 81       	ldd	r30, Y+7	; 0x07
    c306:	f8 85       	ldd	r31, Y+8	; 0x08
    c308:	e0 0f       	add	r30, r16
    c30a:	f1 1f       	adc	r31, r17
    c30c:	10 82       	st	Z, r1
    c30e:	2e 96       	adiw	r28, 0x0e	; 14
    c310:	cd bf       	out	0x3d, r28	; 61
    c312:	de bf       	out	0x3e, r29	; 62
    c314:	df 91       	pop	r29
    c316:	cf 91       	pop	r28
    c318:	1f 91       	pop	r17
    c31a:	0f 91       	pop	r16
    c31c:	08 95       	ret

0000c31e <vfprintf>:
    c31e:	2f 92       	push	r2
    c320:	3f 92       	push	r3
    c322:	4f 92       	push	r4
    c324:	5f 92       	push	r5
    c326:	6f 92       	push	r6
    c328:	7f 92       	push	r7
    c32a:	8f 92       	push	r8
    c32c:	9f 92       	push	r9
    c32e:	af 92       	push	r10
    c330:	bf 92       	push	r11
    c332:	cf 92       	push	r12
    c334:	df 92       	push	r13
    c336:	ef 92       	push	r14
    c338:	ff 92       	push	r15
    c33a:	0f 93       	push	r16
    c33c:	1f 93       	push	r17
    c33e:	cf 93       	push	r28
    c340:	df 93       	push	r29
    c342:	cd b7       	in	r28, 0x3d	; 61
    c344:	de b7       	in	r29, 0x3e	; 62
    c346:	2d 97       	sbiw	r28, 0x0d	; 13
    c348:	cd bf       	out	0x3d, r28	; 61
    c34a:	de bf       	out	0x3e, r29	; 62
    c34c:	3c 01       	movw	r6, r24
    c34e:	6c 87       	std	Y+12, r22	; 0x0c
    c350:	7d 87       	std	Y+13, r23	; 0x0d
    c352:	5a 01       	movw	r10, r20
    c354:	fc 01       	movw	r30, r24
    c356:	16 82       	std	Z+6, r1	; 0x06
    c358:	17 82       	std	Z+7, r1	; 0x07
    c35a:	83 81       	ldd	r24, Z+3	; 0x03
    c35c:	81 ff       	sbrs	r24, 1
    c35e:	c8 c1       	rjmp	.+912    	; 0xc6f0 <vfprintf+0x3d2>
    c360:	2e 01       	movw	r4, r28
    c362:	08 94       	sec
    c364:	41 1c       	adc	r4, r1
    c366:	51 1c       	adc	r5, r1
    c368:	f3 01       	movw	r30, r6
    c36a:	93 81       	ldd	r25, Z+3	; 0x03
    c36c:	ec 85       	ldd	r30, Y+12	; 0x0c
    c36e:	fd 85       	ldd	r31, Y+13	; 0x0d
    c370:	93 fd       	sbrc	r25, 3
    c372:	85 91       	lpm	r24, Z+
    c374:	93 ff       	sbrs	r25, 3
    c376:	81 91       	ld	r24, Z+
    c378:	ec 87       	std	Y+12, r30	; 0x0c
    c37a:	fd 87       	std	Y+13, r31	; 0x0d
    c37c:	88 23       	and	r24, r24
    c37e:	09 f4       	brne	.+2      	; 0xc382 <vfprintf+0x64>
    c380:	b3 c1       	rjmp	.+870    	; 0xc6e8 <vfprintf+0x3ca>
    c382:	85 32       	cpi	r24, 0x25	; 37
    c384:	41 f4       	brne	.+16     	; 0xc396 <vfprintf+0x78>
    c386:	93 fd       	sbrc	r25, 3
    c388:	85 91       	lpm	r24, Z+
    c38a:	93 ff       	sbrs	r25, 3
    c38c:	81 91       	ld	r24, Z+
    c38e:	ec 87       	std	Y+12, r30	; 0x0c
    c390:	fd 87       	std	Y+13, r31	; 0x0d
    c392:	85 32       	cpi	r24, 0x25	; 37
    c394:	29 f4       	brne	.+10     	; 0xc3a0 <vfprintf+0x82>
    c396:	90 e0       	ldi	r25, 0x00	; 0
    c398:	b3 01       	movw	r22, r6
    c39a:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c39e:	e4 cf       	rjmp	.-56     	; 0xc368 <vfprintf+0x4a>
    c3a0:	ff 24       	eor	r15, r15
    c3a2:	ee 24       	eor	r14, r14
    c3a4:	10 e0       	ldi	r17, 0x00	; 0
    c3a6:	10 32       	cpi	r17, 0x20	; 32
    c3a8:	b0 f4       	brcc	.+44     	; 0xc3d6 <vfprintf+0xb8>
    c3aa:	8b 32       	cpi	r24, 0x2B	; 43
    c3ac:	69 f0       	breq	.+26     	; 0xc3c8 <vfprintf+0xaa>
    c3ae:	8c 32       	cpi	r24, 0x2C	; 44
    c3b0:	28 f4       	brcc	.+10     	; 0xc3bc <vfprintf+0x9e>
    c3b2:	80 32       	cpi	r24, 0x20	; 32
    c3b4:	51 f0       	breq	.+20     	; 0xc3ca <vfprintf+0xac>
    c3b6:	83 32       	cpi	r24, 0x23	; 35
    c3b8:	71 f4       	brne	.+28     	; 0xc3d6 <vfprintf+0xb8>
    c3ba:	0b c0       	rjmp	.+22     	; 0xc3d2 <vfprintf+0xb4>
    c3bc:	8d 32       	cpi	r24, 0x2D	; 45
    c3be:	39 f0       	breq	.+14     	; 0xc3ce <vfprintf+0xb0>
    c3c0:	80 33       	cpi	r24, 0x30	; 48
    c3c2:	49 f4       	brne	.+18     	; 0xc3d6 <vfprintf+0xb8>
    c3c4:	11 60       	ori	r17, 0x01	; 1
    c3c6:	2c c0       	rjmp	.+88     	; 0xc420 <vfprintf+0x102>
    c3c8:	12 60       	ori	r17, 0x02	; 2
    c3ca:	14 60       	ori	r17, 0x04	; 4
    c3cc:	29 c0       	rjmp	.+82     	; 0xc420 <vfprintf+0x102>
    c3ce:	18 60       	ori	r17, 0x08	; 8
    c3d0:	27 c0       	rjmp	.+78     	; 0xc420 <vfprintf+0x102>
    c3d2:	10 61       	ori	r17, 0x10	; 16
    c3d4:	25 c0       	rjmp	.+74     	; 0xc420 <vfprintf+0x102>
    c3d6:	17 fd       	sbrc	r17, 7
    c3d8:	2e c0       	rjmp	.+92     	; 0xc436 <vfprintf+0x118>
    c3da:	28 2f       	mov	r18, r24
    c3dc:	20 53       	subi	r18, 0x30	; 48
    c3de:	2a 30       	cpi	r18, 0x0A	; 10
    c3e0:	98 f4       	brcc	.+38     	; 0xc408 <vfprintf+0xea>
    c3e2:	16 ff       	sbrs	r17, 6
    c3e4:	08 c0       	rjmp	.+16     	; 0xc3f6 <vfprintf+0xd8>
    c3e6:	8f 2d       	mov	r24, r15
    c3e8:	88 0f       	add	r24, r24
    c3ea:	f8 2e       	mov	r15, r24
    c3ec:	ff 0c       	add	r15, r15
    c3ee:	ff 0c       	add	r15, r15
    c3f0:	f8 0e       	add	r15, r24
    c3f2:	f2 0e       	add	r15, r18
    c3f4:	15 c0       	rjmp	.+42     	; 0xc420 <vfprintf+0x102>
    c3f6:	8e 2d       	mov	r24, r14
    c3f8:	88 0f       	add	r24, r24
    c3fa:	e8 2e       	mov	r14, r24
    c3fc:	ee 0c       	add	r14, r14
    c3fe:	ee 0c       	add	r14, r14
    c400:	e8 0e       	add	r14, r24
    c402:	e2 0e       	add	r14, r18
    c404:	10 62       	ori	r17, 0x20	; 32
    c406:	0c c0       	rjmp	.+24     	; 0xc420 <vfprintf+0x102>
    c408:	8e 32       	cpi	r24, 0x2E	; 46
    c40a:	21 f4       	brne	.+8      	; 0xc414 <vfprintf+0xf6>
    c40c:	16 fd       	sbrc	r17, 6
    c40e:	6c c1       	rjmp	.+728    	; 0xc6e8 <vfprintf+0x3ca>
    c410:	10 64       	ori	r17, 0x40	; 64
    c412:	06 c0       	rjmp	.+12     	; 0xc420 <vfprintf+0x102>
    c414:	8c 36       	cpi	r24, 0x6C	; 108
    c416:	11 f4       	brne	.+4      	; 0xc41c <vfprintf+0xfe>
    c418:	10 68       	ori	r17, 0x80	; 128
    c41a:	02 c0       	rjmp	.+4      	; 0xc420 <vfprintf+0x102>
    c41c:	88 36       	cpi	r24, 0x68	; 104
    c41e:	59 f4       	brne	.+22     	; 0xc436 <vfprintf+0x118>
    c420:	ec 85       	ldd	r30, Y+12	; 0x0c
    c422:	fd 85       	ldd	r31, Y+13	; 0x0d
    c424:	93 fd       	sbrc	r25, 3
    c426:	85 91       	lpm	r24, Z+
    c428:	93 ff       	sbrs	r25, 3
    c42a:	81 91       	ld	r24, Z+
    c42c:	ec 87       	std	Y+12, r30	; 0x0c
    c42e:	fd 87       	std	Y+13, r31	; 0x0d
    c430:	88 23       	and	r24, r24
    c432:	09 f0       	breq	.+2      	; 0xc436 <vfprintf+0x118>
    c434:	b8 cf       	rjmp	.-144    	; 0xc3a6 <vfprintf+0x88>
    c436:	98 2f       	mov	r25, r24
    c438:	95 54       	subi	r25, 0x45	; 69
    c43a:	93 30       	cpi	r25, 0x03	; 3
    c43c:	18 f0       	brcs	.+6      	; 0xc444 <vfprintf+0x126>
    c43e:	90 52       	subi	r25, 0x20	; 32
    c440:	93 30       	cpi	r25, 0x03	; 3
    c442:	38 f4       	brcc	.+14     	; 0xc452 <vfprintf+0x134>
    c444:	24 e0       	ldi	r18, 0x04	; 4
    c446:	30 e0       	ldi	r19, 0x00	; 0
    c448:	a2 0e       	add	r10, r18
    c44a:	b3 1e       	adc	r11, r19
    c44c:	3f e3       	ldi	r19, 0x3F	; 63
    c44e:	39 83       	std	Y+1, r19	; 0x01
    c450:	0f c0       	rjmp	.+30     	; 0xc470 <vfprintf+0x152>
    c452:	83 36       	cpi	r24, 0x63	; 99
    c454:	31 f0       	breq	.+12     	; 0xc462 <vfprintf+0x144>
    c456:	83 37       	cpi	r24, 0x73	; 115
    c458:	81 f0       	breq	.+32     	; 0xc47a <vfprintf+0x15c>
    c45a:	83 35       	cpi	r24, 0x53	; 83
    c45c:	09 f0       	breq	.+2      	; 0xc460 <vfprintf+0x142>
    c45e:	5a c0       	rjmp	.+180    	; 0xc514 <vfprintf+0x1f6>
    c460:	22 c0       	rjmp	.+68     	; 0xc4a6 <vfprintf+0x188>
    c462:	f5 01       	movw	r30, r10
    c464:	80 81       	ld	r24, Z
    c466:	89 83       	std	Y+1, r24	; 0x01
    c468:	22 e0       	ldi	r18, 0x02	; 2
    c46a:	30 e0       	ldi	r19, 0x00	; 0
    c46c:	a2 0e       	add	r10, r18
    c46e:	b3 1e       	adc	r11, r19
    c470:	21 e0       	ldi	r18, 0x01	; 1
    c472:	c2 2e       	mov	r12, r18
    c474:	d1 2c       	mov	r13, r1
    c476:	42 01       	movw	r8, r4
    c478:	14 c0       	rjmp	.+40     	; 0xc4a2 <vfprintf+0x184>
    c47a:	92 e0       	ldi	r25, 0x02	; 2
    c47c:	29 2e       	mov	r2, r25
    c47e:	31 2c       	mov	r3, r1
    c480:	2a 0c       	add	r2, r10
    c482:	3b 1c       	adc	r3, r11
    c484:	f5 01       	movw	r30, r10
    c486:	80 80       	ld	r8, Z
    c488:	91 80       	ldd	r9, Z+1	; 0x01
    c48a:	16 ff       	sbrs	r17, 6
    c48c:	03 c0       	rjmp	.+6      	; 0xc494 <vfprintf+0x176>
    c48e:	6f 2d       	mov	r22, r15
    c490:	70 e0       	ldi	r23, 0x00	; 0
    c492:	02 c0       	rjmp	.+4      	; 0xc498 <vfprintf+0x17a>
    c494:	6f ef       	ldi	r22, 0xFF	; 255
    c496:	7f ef       	ldi	r23, 0xFF	; 255
    c498:	c4 01       	movw	r24, r8
    c49a:	0e 94 a4 63 	call	0xc748	; 0xc748 <strnlen>
    c49e:	6c 01       	movw	r12, r24
    c4a0:	51 01       	movw	r10, r2
    c4a2:	1f 77       	andi	r17, 0x7F	; 127
    c4a4:	15 c0       	rjmp	.+42     	; 0xc4d0 <vfprintf+0x1b2>
    c4a6:	82 e0       	ldi	r24, 0x02	; 2
    c4a8:	28 2e       	mov	r2, r24
    c4aa:	31 2c       	mov	r3, r1
    c4ac:	2a 0c       	add	r2, r10
    c4ae:	3b 1c       	adc	r3, r11
    c4b0:	f5 01       	movw	r30, r10
    c4b2:	80 80       	ld	r8, Z
    c4b4:	91 80       	ldd	r9, Z+1	; 0x01
    c4b6:	16 ff       	sbrs	r17, 6
    c4b8:	03 c0       	rjmp	.+6      	; 0xc4c0 <vfprintf+0x1a2>
    c4ba:	6f 2d       	mov	r22, r15
    c4bc:	70 e0       	ldi	r23, 0x00	; 0
    c4be:	02 c0       	rjmp	.+4      	; 0xc4c4 <vfprintf+0x1a6>
    c4c0:	6f ef       	ldi	r22, 0xFF	; 255
    c4c2:	7f ef       	ldi	r23, 0xFF	; 255
    c4c4:	c4 01       	movw	r24, r8
    c4c6:	0e 94 90 63 	call	0xc720	; 0xc720 <strnlen_P>
    c4ca:	6c 01       	movw	r12, r24
    c4cc:	10 68       	ori	r17, 0x80	; 128
    c4ce:	51 01       	movw	r10, r2
    c4d0:	13 fd       	sbrc	r17, 3
    c4d2:	1c c0       	rjmp	.+56     	; 0xc50c <vfprintf+0x1ee>
    c4d4:	06 c0       	rjmp	.+12     	; 0xc4e2 <vfprintf+0x1c4>
    c4d6:	80 e2       	ldi	r24, 0x20	; 32
    c4d8:	90 e0       	ldi	r25, 0x00	; 0
    c4da:	b3 01       	movw	r22, r6
    c4dc:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c4e0:	ea 94       	dec	r14
    c4e2:	8e 2d       	mov	r24, r14
    c4e4:	90 e0       	ldi	r25, 0x00	; 0
    c4e6:	c8 16       	cp	r12, r24
    c4e8:	d9 06       	cpc	r13, r25
    c4ea:	a8 f3       	brcs	.-22     	; 0xc4d6 <vfprintf+0x1b8>
    c4ec:	0f c0       	rjmp	.+30     	; 0xc50c <vfprintf+0x1ee>
    c4ee:	f4 01       	movw	r30, r8
    c4f0:	17 fd       	sbrc	r17, 7
    c4f2:	85 91       	lpm	r24, Z+
    c4f4:	17 ff       	sbrs	r17, 7
    c4f6:	81 91       	ld	r24, Z+
    c4f8:	4f 01       	movw	r8, r30
    c4fa:	90 e0       	ldi	r25, 0x00	; 0
    c4fc:	b3 01       	movw	r22, r6
    c4fe:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c502:	e1 10       	cpse	r14, r1
    c504:	ea 94       	dec	r14
    c506:	08 94       	sec
    c508:	c1 08       	sbc	r12, r1
    c50a:	d1 08       	sbc	r13, r1
    c50c:	c1 14       	cp	r12, r1
    c50e:	d1 04       	cpc	r13, r1
    c510:	71 f7       	brne	.-36     	; 0xc4ee <vfprintf+0x1d0>
    c512:	e7 c0       	rjmp	.+462    	; 0xc6e2 <vfprintf+0x3c4>
    c514:	84 36       	cpi	r24, 0x64	; 100
    c516:	11 f0       	breq	.+4      	; 0xc51c <vfprintf+0x1fe>
    c518:	89 36       	cpi	r24, 0x69	; 105
    c51a:	51 f5       	brne	.+84     	; 0xc570 <vfprintf+0x252>
    c51c:	f5 01       	movw	r30, r10
    c51e:	17 ff       	sbrs	r17, 7
    c520:	07 c0       	rjmp	.+14     	; 0xc530 <vfprintf+0x212>
    c522:	80 81       	ld	r24, Z
    c524:	91 81       	ldd	r25, Z+1	; 0x01
    c526:	a2 81       	ldd	r26, Z+2	; 0x02
    c528:	b3 81       	ldd	r27, Z+3	; 0x03
    c52a:	24 e0       	ldi	r18, 0x04	; 4
    c52c:	30 e0       	ldi	r19, 0x00	; 0
    c52e:	08 c0       	rjmp	.+16     	; 0xc540 <vfprintf+0x222>
    c530:	80 81       	ld	r24, Z
    c532:	91 81       	ldd	r25, Z+1	; 0x01
    c534:	aa 27       	eor	r26, r26
    c536:	97 fd       	sbrc	r25, 7
    c538:	a0 95       	com	r26
    c53a:	ba 2f       	mov	r27, r26
    c53c:	22 e0       	ldi	r18, 0x02	; 2
    c53e:	30 e0       	ldi	r19, 0x00	; 0
    c540:	a2 0e       	add	r10, r18
    c542:	b3 1e       	adc	r11, r19
    c544:	01 2f       	mov	r16, r17
    c546:	0f 76       	andi	r16, 0x6F	; 111
    c548:	b7 ff       	sbrs	r27, 7
    c54a:	08 c0       	rjmp	.+16     	; 0xc55c <vfprintf+0x23e>
    c54c:	b0 95       	com	r27
    c54e:	a0 95       	com	r26
    c550:	90 95       	com	r25
    c552:	81 95       	neg	r24
    c554:	9f 4f       	sbci	r25, 0xFF	; 255
    c556:	af 4f       	sbci	r26, 0xFF	; 255
    c558:	bf 4f       	sbci	r27, 0xFF	; 255
    c55a:	00 68       	ori	r16, 0x80	; 128
    c55c:	bc 01       	movw	r22, r24
    c55e:	cd 01       	movw	r24, r26
    c560:	a2 01       	movw	r20, r4
    c562:	2a e0       	ldi	r18, 0x0A	; 10
    c564:	30 e0       	ldi	r19, 0x00	; 0
    c566:	0e 94 eb 63 	call	0xc7d6	; 0xc7d6 <__ultoa_invert>
    c56a:	d8 2e       	mov	r13, r24
    c56c:	d4 18       	sub	r13, r4
    c56e:	3f c0       	rjmp	.+126    	; 0xc5ee <vfprintf+0x2d0>
    c570:	85 37       	cpi	r24, 0x75	; 117
    c572:	21 f4       	brne	.+8      	; 0xc57c <vfprintf+0x25e>
    c574:	1f 7e       	andi	r17, 0xEF	; 239
    c576:	2a e0       	ldi	r18, 0x0A	; 10
    c578:	30 e0       	ldi	r19, 0x00	; 0
    c57a:	20 c0       	rjmp	.+64     	; 0xc5bc <vfprintf+0x29e>
    c57c:	19 7f       	andi	r17, 0xF9	; 249
    c57e:	8f 36       	cpi	r24, 0x6F	; 111
    c580:	a9 f0       	breq	.+42     	; 0xc5ac <vfprintf+0x28e>
    c582:	80 37       	cpi	r24, 0x70	; 112
    c584:	20 f4       	brcc	.+8      	; 0xc58e <vfprintf+0x270>
    c586:	88 35       	cpi	r24, 0x58	; 88
    c588:	09 f0       	breq	.+2      	; 0xc58c <vfprintf+0x26e>
    c58a:	ae c0       	rjmp	.+348    	; 0xc6e8 <vfprintf+0x3ca>
    c58c:	0b c0       	rjmp	.+22     	; 0xc5a4 <vfprintf+0x286>
    c58e:	80 37       	cpi	r24, 0x70	; 112
    c590:	21 f0       	breq	.+8      	; 0xc59a <vfprintf+0x27c>
    c592:	88 37       	cpi	r24, 0x78	; 120
    c594:	09 f0       	breq	.+2      	; 0xc598 <vfprintf+0x27a>
    c596:	a8 c0       	rjmp	.+336    	; 0xc6e8 <vfprintf+0x3ca>
    c598:	01 c0       	rjmp	.+2      	; 0xc59c <vfprintf+0x27e>
    c59a:	10 61       	ori	r17, 0x10	; 16
    c59c:	14 ff       	sbrs	r17, 4
    c59e:	09 c0       	rjmp	.+18     	; 0xc5b2 <vfprintf+0x294>
    c5a0:	14 60       	ori	r17, 0x04	; 4
    c5a2:	07 c0       	rjmp	.+14     	; 0xc5b2 <vfprintf+0x294>
    c5a4:	14 ff       	sbrs	r17, 4
    c5a6:	08 c0       	rjmp	.+16     	; 0xc5b8 <vfprintf+0x29a>
    c5a8:	16 60       	ori	r17, 0x06	; 6
    c5aa:	06 c0       	rjmp	.+12     	; 0xc5b8 <vfprintf+0x29a>
    c5ac:	28 e0       	ldi	r18, 0x08	; 8
    c5ae:	30 e0       	ldi	r19, 0x00	; 0
    c5b0:	05 c0       	rjmp	.+10     	; 0xc5bc <vfprintf+0x29e>
    c5b2:	20 e1       	ldi	r18, 0x10	; 16
    c5b4:	30 e0       	ldi	r19, 0x00	; 0
    c5b6:	02 c0       	rjmp	.+4      	; 0xc5bc <vfprintf+0x29e>
    c5b8:	20 e1       	ldi	r18, 0x10	; 16
    c5ba:	32 e0       	ldi	r19, 0x02	; 2
    c5bc:	f5 01       	movw	r30, r10
    c5be:	17 ff       	sbrs	r17, 7
    c5c0:	07 c0       	rjmp	.+14     	; 0xc5d0 <vfprintf+0x2b2>
    c5c2:	60 81       	ld	r22, Z
    c5c4:	71 81       	ldd	r23, Z+1	; 0x01
    c5c6:	82 81       	ldd	r24, Z+2	; 0x02
    c5c8:	93 81       	ldd	r25, Z+3	; 0x03
    c5ca:	44 e0       	ldi	r20, 0x04	; 4
    c5cc:	50 e0       	ldi	r21, 0x00	; 0
    c5ce:	06 c0       	rjmp	.+12     	; 0xc5dc <vfprintf+0x2be>
    c5d0:	60 81       	ld	r22, Z
    c5d2:	71 81       	ldd	r23, Z+1	; 0x01
    c5d4:	80 e0       	ldi	r24, 0x00	; 0
    c5d6:	90 e0       	ldi	r25, 0x00	; 0
    c5d8:	42 e0       	ldi	r20, 0x02	; 2
    c5da:	50 e0       	ldi	r21, 0x00	; 0
    c5dc:	a4 0e       	add	r10, r20
    c5de:	b5 1e       	adc	r11, r21
    c5e0:	a2 01       	movw	r20, r4
    c5e2:	0e 94 eb 63 	call	0xc7d6	; 0xc7d6 <__ultoa_invert>
    c5e6:	d8 2e       	mov	r13, r24
    c5e8:	d4 18       	sub	r13, r4
    c5ea:	01 2f       	mov	r16, r17
    c5ec:	0f 77       	andi	r16, 0x7F	; 127
    c5ee:	06 ff       	sbrs	r16, 6
    c5f0:	09 c0       	rjmp	.+18     	; 0xc604 <vfprintf+0x2e6>
    c5f2:	0e 7f       	andi	r16, 0xFE	; 254
    c5f4:	df 14       	cp	r13, r15
    c5f6:	30 f4       	brcc	.+12     	; 0xc604 <vfprintf+0x2e6>
    c5f8:	04 ff       	sbrs	r16, 4
    c5fa:	06 c0       	rjmp	.+12     	; 0xc608 <vfprintf+0x2ea>
    c5fc:	02 fd       	sbrc	r16, 2
    c5fe:	04 c0       	rjmp	.+8      	; 0xc608 <vfprintf+0x2ea>
    c600:	0f 7e       	andi	r16, 0xEF	; 239
    c602:	02 c0       	rjmp	.+4      	; 0xc608 <vfprintf+0x2ea>
    c604:	1d 2d       	mov	r17, r13
    c606:	01 c0       	rjmp	.+2      	; 0xc60a <vfprintf+0x2ec>
    c608:	1f 2d       	mov	r17, r15
    c60a:	80 2f       	mov	r24, r16
    c60c:	90 e0       	ldi	r25, 0x00	; 0
    c60e:	04 ff       	sbrs	r16, 4
    c610:	0c c0       	rjmp	.+24     	; 0xc62a <vfprintf+0x30c>
    c612:	fe 01       	movw	r30, r28
    c614:	ed 0d       	add	r30, r13
    c616:	f1 1d       	adc	r31, r1
    c618:	20 81       	ld	r18, Z
    c61a:	20 33       	cpi	r18, 0x30	; 48
    c61c:	11 f4       	brne	.+4      	; 0xc622 <vfprintf+0x304>
    c61e:	09 7e       	andi	r16, 0xE9	; 233
    c620:	09 c0       	rjmp	.+18     	; 0xc634 <vfprintf+0x316>
    c622:	02 ff       	sbrs	r16, 2
    c624:	06 c0       	rjmp	.+12     	; 0xc632 <vfprintf+0x314>
    c626:	1e 5f       	subi	r17, 0xFE	; 254
    c628:	05 c0       	rjmp	.+10     	; 0xc634 <vfprintf+0x316>
    c62a:	86 78       	andi	r24, 0x86	; 134
    c62c:	90 70       	andi	r25, 0x00	; 0
    c62e:	00 97       	sbiw	r24, 0x00	; 0
    c630:	09 f0       	breq	.+2      	; 0xc634 <vfprintf+0x316>
    c632:	1f 5f       	subi	r17, 0xFF	; 255
    c634:	80 2e       	mov	r8, r16
    c636:	99 24       	eor	r9, r9
    c638:	03 fd       	sbrc	r16, 3
    c63a:	12 c0       	rjmp	.+36     	; 0xc660 <vfprintf+0x342>
    c63c:	00 ff       	sbrs	r16, 0
    c63e:	0d c0       	rjmp	.+26     	; 0xc65a <vfprintf+0x33c>
    c640:	fd 2c       	mov	r15, r13
    c642:	1e 15       	cp	r17, r14
    c644:	50 f4       	brcc	.+20     	; 0xc65a <vfprintf+0x33c>
    c646:	fe 0c       	add	r15, r14
    c648:	f1 1a       	sub	r15, r17
    c64a:	1e 2d       	mov	r17, r14
    c64c:	06 c0       	rjmp	.+12     	; 0xc65a <vfprintf+0x33c>
    c64e:	80 e2       	ldi	r24, 0x20	; 32
    c650:	90 e0       	ldi	r25, 0x00	; 0
    c652:	b3 01       	movw	r22, r6
    c654:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c658:	1f 5f       	subi	r17, 0xFF	; 255
    c65a:	1e 15       	cp	r17, r14
    c65c:	c0 f3       	brcs	.-16     	; 0xc64e <vfprintf+0x330>
    c65e:	04 c0       	rjmp	.+8      	; 0xc668 <vfprintf+0x34a>
    c660:	1e 15       	cp	r17, r14
    c662:	10 f4       	brcc	.+4      	; 0xc668 <vfprintf+0x34a>
    c664:	e1 1a       	sub	r14, r17
    c666:	01 c0       	rjmp	.+2      	; 0xc66a <vfprintf+0x34c>
    c668:	ee 24       	eor	r14, r14
    c66a:	84 fe       	sbrs	r8, 4
    c66c:	0f c0       	rjmp	.+30     	; 0xc68c <vfprintf+0x36e>
    c66e:	80 e3       	ldi	r24, 0x30	; 48
    c670:	90 e0       	ldi	r25, 0x00	; 0
    c672:	b3 01       	movw	r22, r6
    c674:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c678:	82 fe       	sbrs	r8, 2
    c67a:	1f c0       	rjmp	.+62     	; 0xc6ba <vfprintf+0x39c>
    c67c:	81 fe       	sbrs	r8, 1
    c67e:	03 c0       	rjmp	.+6      	; 0xc686 <vfprintf+0x368>
    c680:	88 e5       	ldi	r24, 0x58	; 88
    c682:	90 e0       	ldi	r25, 0x00	; 0
    c684:	10 c0       	rjmp	.+32     	; 0xc6a6 <vfprintf+0x388>
    c686:	88 e7       	ldi	r24, 0x78	; 120
    c688:	90 e0       	ldi	r25, 0x00	; 0
    c68a:	0d c0       	rjmp	.+26     	; 0xc6a6 <vfprintf+0x388>
    c68c:	c4 01       	movw	r24, r8
    c68e:	86 78       	andi	r24, 0x86	; 134
    c690:	90 70       	andi	r25, 0x00	; 0
    c692:	00 97       	sbiw	r24, 0x00	; 0
    c694:	91 f0       	breq	.+36     	; 0xc6ba <vfprintf+0x39c>
    c696:	81 fc       	sbrc	r8, 1
    c698:	02 c0       	rjmp	.+4      	; 0xc69e <vfprintf+0x380>
    c69a:	80 e2       	ldi	r24, 0x20	; 32
    c69c:	01 c0       	rjmp	.+2      	; 0xc6a0 <vfprintf+0x382>
    c69e:	8b e2       	ldi	r24, 0x2B	; 43
    c6a0:	07 fd       	sbrc	r16, 7
    c6a2:	8d e2       	ldi	r24, 0x2D	; 45
    c6a4:	90 e0       	ldi	r25, 0x00	; 0
    c6a6:	b3 01       	movw	r22, r6
    c6a8:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c6ac:	06 c0       	rjmp	.+12     	; 0xc6ba <vfprintf+0x39c>
    c6ae:	80 e3       	ldi	r24, 0x30	; 48
    c6b0:	90 e0       	ldi	r25, 0x00	; 0
    c6b2:	b3 01       	movw	r22, r6
    c6b4:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c6b8:	fa 94       	dec	r15
    c6ba:	df 14       	cp	r13, r15
    c6bc:	c0 f3       	brcs	.-16     	; 0xc6ae <vfprintf+0x390>
    c6be:	da 94       	dec	r13
    c6c0:	f2 01       	movw	r30, r4
    c6c2:	ed 0d       	add	r30, r13
    c6c4:	f1 1d       	adc	r31, r1
    c6c6:	80 81       	ld	r24, Z
    c6c8:	90 e0       	ldi	r25, 0x00	; 0
    c6ca:	b3 01       	movw	r22, r6
    c6cc:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c6d0:	dd 20       	and	r13, r13
    c6d2:	a9 f7       	brne	.-22     	; 0xc6be <vfprintf+0x3a0>
    c6d4:	06 c0       	rjmp	.+12     	; 0xc6e2 <vfprintf+0x3c4>
    c6d6:	80 e2       	ldi	r24, 0x20	; 32
    c6d8:	90 e0       	ldi	r25, 0x00	; 0
    c6da:	b3 01       	movw	r22, r6
    c6dc:	0e 94 bf 63 	call	0xc77e	; 0xc77e <fputc>
    c6e0:	ea 94       	dec	r14
    c6e2:	ee 20       	and	r14, r14
    c6e4:	c1 f7       	brne	.-16     	; 0xc6d6 <vfprintf+0x3b8>
    c6e6:	40 ce       	rjmp	.-896    	; 0xc368 <vfprintf+0x4a>
    c6e8:	f3 01       	movw	r30, r6
    c6ea:	86 81       	ldd	r24, Z+6	; 0x06
    c6ec:	97 81       	ldd	r25, Z+7	; 0x07
    c6ee:	02 c0       	rjmp	.+4      	; 0xc6f4 <vfprintf+0x3d6>
    c6f0:	8f ef       	ldi	r24, 0xFF	; 255
    c6f2:	9f ef       	ldi	r25, 0xFF	; 255
    c6f4:	2d 96       	adiw	r28, 0x0d	; 13
    c6f6:	cd bf       	out	0x3d, r28	; 61
    c6f8:	de bf       	out	0x3e, r29	; 62
    c6fa:	df 91       	pop	r29
    c6fc:	cf 91       	pop	r28
    c6fe:	1f 91       	pop	r17
    c700:	0f 91       	pop	r16
    c702:	ff 90       	pop	r15
    c704:	ef 90       	pop	r14
    c706:	df 90       	pop	r13
    c708:	cf 90       	pop	r12
    c70a:	bf 90       	pop	r11
    c70c:	af 90       	pop	r10
    c70e:	9f 90       	pop	r9
    c710:	8f 90       	pop	r8
    c712:	7f 90       	pop	r7
    c714:	6f 90       	pop	r6
    c716:	5f 90       	pop	r5
    c718:	4f 90       	pop	r4
    c71a:	3f 90       	pop	r3
    c71c:	2f 90       	pop	r2
    c71e:	08 95       	ret

0000c720 <strnlen_P>:
    c720:	fc 01       	movw	r30, r24
    c722:	05 90       	lpm	r0, Z+
    c724:	61 50       	subi	r22, 0x01	; 1
    c726:	70 40       	sbci	r23, 0x00	; 0
    c728:	01 10       	cpse	r0, r1
    c72a:	d8 f7       	brcc	.-10     	; 0xc722 <strnlen_P+0x2>
    c72c:	80 95       	com	r24
    c72e:	90 95       	com	r25
    c730:	8e 0f       	add	r24, r30
    c732:	9f 1f       	adc	r25, r31
    c734:	08 95       	ret

0000c736 <memcpy>:
    c736:	fb 01       	movw	r30, r22
    c738:	dc 01       	movw	r26, r24
    c73a:	02 c0       	rjmp	.+4      	; 0xc740 <memcpy+0xa>
    c73c:	01 90       	ld	r0, Z+
    c73e:	0d 92       	st	X+, r0
    c740:	41 50       	subi	r20, 0x01	; 1
    c742:	50 40       	sbci	r21, 0x00	; 0
    c744:	d8 f7       	brcc	.-10     	; 0xc73c <memcpy+0x6>
    c746:	08 95       	ret

0000c748 <strnlen>:
    c748:	fc 01       	movw	r30, r24
    c74a:	61 50       	subi	r22, 0x01	; 1
    c74c:	70 40       	sbci	r23, 0x00	; 0
    c74e:	01 90       	ld	r0, Z+
    c750:	01 10       	cpse	r0, r1
    c752:	d8 f7       	brcc	.-10     	; 0xc74a <strnlen+0x2>
    c754:	80 95       	com	r24
    c756:	90 95       	com	r25
    c758:	8e 0f       	add	r24, r30
    c75a:	9f 1f       	adc	r25, r31
    c75c:	08 95       	ret

0000c75e <strrev>:
    c75e:	dc 01       	movw	r26, r24
    c760:	fc 01       	movw	r30, r24
    c762:	67 2f       	mov	r22, r23
    c764:	71 91       	ld	r23, Z+
    c766:	77 23       	and	r23, r23
    c768:	e1 f7       	brne	.-8      	; 0xc762 <strrev+0x4>
    c76a:	32 97       	sbiw	r30, 0x02	; 2
    c76c:	04 c0       	rjmp	.+8      	; 0xc776 <strrev+0x18>
    c76e:	7c 91       	ld	r23, X
    c770:	6d 93       	st	X+, r22
    c772:	70 83       	st	Z, r23
    c774:	62 91       	ld	r22, -Z
    c776:	ae 17       	cp	r26, r30
    c778:	bf 07       	cpc	r27, r31
    c77a:	c8 f3       	brcs	.-14     	; 0xc76e <strrev+0x10>
    c77c:	08 95       	ret

0000c77e <fputc>:
    c77e:	0f 93       	push	r16
    c780:	1f 93       	push	r17
    c782:	cf 93       	push	r28
    c784:	df 93       	push	r29
    c786:	8c 01       	movw	r16, r24
    c788:	eb 01       	movw	r28, r22
    c78a:	8b 81       	ldd	r24, Y+3	; 0x03
    c78c:	81 ff       	sbrs	r24, 1
    c78e:	1b c0       	rjmp	.+54     	; 0xc7c6 <fputc+0x48>
    c790:	82 ff       	sbrs	r24, 2
    c792:	0d c0       	rjmp	.+26     	; 0xc7ae <fputc+0x30>
    c794:	2e 81       	ldd	r18, Y+6	; 0x06
    c796:	3f 81       	ldd	r19, Y+7	; 0x07
    c798:	8c 81       	ldd	r24, Y+4	; 0x04
    c79a:	9d 81       	ldd	r25, Y+5	; 0x05
    c79c:	28 17       	cp	r18, r24
    c79e:	39 07       	cpc	r19, r25
    c7a0:	64 f4       	brge	.+24     	; 0xc7ba <fputc+0x3c>
    c7a2:	e8 81       	ld	r30, Y
    c7a4:	f9 81       	ldd	r31, Y+1	; 0x01
    c7a6:	01 93       	st	Z+, r16
    c7a8:	e8 83       	st	Y, r30
    c7aa:	f9 83       	std	Y+1, r31	; 0x01
    c7ac:	06 c0       	rjmp	.+12     	; 0xc7ba <fputc+0x3c>
    c7ae:	e8 85       	ldd	r30, Y+8	; 0x08
    c7b0:	f9 85       	ldd	r31, Y+9	; 0x09
    c7b2:	80 2f       	mov	r24, r16
    c7b4:	19 95       	eicall
    c7b6:	00 97       	sbiw	r24, 0x00	; 0
    c7b8:	31 f4       	brne	.+12     	; 0xc7c6 <fputc+0x48>
    c7ba:	8e 81       	ldd	r24, Y+6	; 0x06
    c7bc:	9f 81       	ldd	r25, Y+7	; 0x07
    c7be:	01 96       	adiw	r24, 0x01	; 1
    c7c0:	8e 83       	std	Y+6, r24	; 0x06
    c7c2:	9f 83       	std	Y+7, r25	; 0x07
    c7c4:	02 c0       	rjmp	.+4      	; 0xc7ca <fputc+0x4c>
    c7c6:	0f ef       	ldi	r16, 0xFF	; 255
    c7c8:	1f ef       	ldi	r17, 0xFF	; 255
    c7ca:	c8 01       	movw	r24, r16
    c7cc:	df 91       	pop	r29
    c7ce:	cf 91       	pop	r28
    c7d0:	1f 91       	pop	r17
    c7d2:	0f 91       	pop	r16
    c7d4:	08 95       	ret

0000c7d6 <__ultoa_invert>:
    c7d6:	fa 01       	movw	r30, r20
    c7d8:	aa 27       	eor	r26, r26
    c7da:	28 30       	cpi	r18, 0x08	; 8
    c7dc:	51 f1       	breq	.+84     	; 0xc832 <__ultoa_invert+0x5c>
    c7de:	20 31       	cpi	r18, 0x10	; 16
    c7e0:	81 f1       	breq	.+96     	; 0xc842 <__ultoa_invert+0x6c>
    c7e2:	e8 94       	clt
    c7e4:	6f 93       	push	r22
    c7e6:	6e 7f       	andi	r22, 0xFE	; 254
    c7e8:	6e 5f       	subi	r22, 0xFE	; 254
    c7ea:	7f 4f       	sbci	r23, 0xFF	; 255
    c7ec:	8f 4f       	sbci	r24, 0xFF	; 255
    c7ee:	9f 4f       	sbci	r25, 0xFF	; 255
    c7f0:	af 4f       	sbci	r26, 0xFF	; 255
    c7f2:	b1 e0       	ldi	r27, 0x01	; 1
    c7f4:	3e d0       	rcall	.+124    	; 0xc872 <__ultoa_invert+0x9c>
    c7f6:	b4 e0       	ldi	r27, 0x04	; 4
    c7f8:	3c d0       	rcall	.+120    	; 0xc872 <__ultoa_invert+0x9c>
    c7fa:	67 0f       	add	r22, r23
    c7fc:	78 1f       	adc	r23, r24
    c7fe:	89 1f       	adc	r24, r25
    c800:	9a 1f       	adc	r25, r26
    c802:	a1 1d       	adc	r26, r1
    c804:	68 0f       	add	r22, r24
    c806:	79 1f       	adc	r23, r25
    c808:	8a 1f       	adc	r24, r26
    c80a:	91 1d       	adc	r25, r1
    c80c:	a1 1d       	adc	r26, r1
    c80e:	6a 0f       	add	r22, r26
    c810:	71 1d       	adc	r23, r1
    c812:	81 1d       	adc	r24, r1
    c814:	91 1d       	adc	r25, r1
    c816:	a1 1d       	adc	r26, r1
    c818:	20 d0       	rcall	.+64     	; 0xc85a <__ultoa_invert+0x84>
    c81a:	09 f4       	brne	.+2      	; 0xc81e <__ultoa_invert+0x48>
    c81c:	68 94       	set
    c81e:	3f 91       	pop	r19
    c820:	2a e0       	ldi	r18, 0x0A	; 10
    c822:	26 9f       	mul	r18, r22
    c824:	11 24       	eor	r1, r1
    c826:	30 19       	sub	r19, r0
    c828:	30 5d       	subi	r19, 0xD0	; 208
    c82a:	31 93       	st	Z+, r19
    c82c:	de f6       	brtc	.-74     	; 0xc7e4 <__ultoa_invert+0xe>
    c82e:	cf 01       	movw	r24, r30
    c830:	08 95       	ret
    c832:	46 2f       	mov	r20, r22
    c834:	47 70       	andi	r20, 0x07	; 7
    c836:	40 5d       	subi	r20, 0xD0	; 208
    c838:	41 93       	st	Z+, r20
    c83a:	b3 e0       	ldi	r27, 0x03	; 3
    c83c:	0f d0       	rcall	.+30     	; 0xc85c <__ultoa_invert+0x86>
    c83e:	c9 f7       	brne	.-14     	; 0xc832 <__ultoa_invert+0x5c>
    c840:	f6 cf       	rjmp	.-20     	; 0xc82e <__ultoa_invert+0x58>
    c842:	46 2f       	mov	r20, r22
    c844:	4f 70       	andi	r20, 0x0F	; 15
    c846:	40 5d       	subi	r20, 0xD0	; 208
    c848:	4a 33       	cpi	r20, 0x3A	; 58
    c84a:	18 f0       	brcs	.+6      	; 0xc852 <__ultoa_invert+0x7c>
    c84c:	49 5d       	subi	r20, 0xD9	; 217
    c84e:	31 fd       	sbrc	r19, 1
    c850:	40 52       	subi	r20, 0x20	; 32
    c852:	41 93       	st	Z+, r20
    c854:	02 d0       	rcall	.+4      	; 0xc85a <__ultoa_invert+0x84>
    c856:	a9 f7       	brne	.-22     	; 0xc842 <__ultoa_invert+0x6c>
    c858:	ea cf       	rjmp	.-44     	; 0xc82e <__ultoa_invert+0x58>
    c85a:	b4 e0       	ldi	r27, 0x04	; 4
    c85c:	a6 95       	lsr	r26
    c85e:	97 95       	ror	r25
    c860:	87 95       	ror	r24
    c862:	77 95       	ror	r23
    c864:	67 95       	ror	r22
    c866:	ba 95       	dec	r27
    c868:	c9 f7       	brne	.-14     	; 0xc85c <__ultoa_invert+0x86>
    c86a:	00 97       	sbiw	r24, 0x00	; 0
    c86c:	61 05       	cpc	r22, r1
    c86e:	71 05       	cpc	r23, r1
    c870:	08 95       	ret
    c872:	9b 01       	movw	r18, r22
    c874:	ac 01       	movw	r20, r24
    c876:	0a 2e       	mov	r0, r26
    c878:	06 94       	lsr	r0
    c87a:	57 95       	ror	r21
    c87c:	47 95       	ror	r20
    c87e:	37 95       	ror	r19
    c880:	27 95       	ror	r18
    c882:	ba 95       	dec	r27
    c884:	c9 f7       	brne	.-14     	; 0xc878 <__ultoa_invert+0xa2>
    c886:	62 0f       	add	r22, r18
    c888:	73 1f       	adc	r23, r19
    c88a:	84 1f       	adc	r24, r20
    c88c:	95 1f       	adc	r25, r21
    c88e:	a0 1d       	adc	r26, r0
    c890:	08 95       	ret

0000c892 <_exit>:
    c892:	f8 94       	cli

0000c894 <__stop_program>:
    c894:	ff cf       	rjmp	.-2      	; 0xc894 <__stop_program>
