
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007a98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  00007a98  00007b2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fae  0080210e  0080210e  00007c3a  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  00007c3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a534  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000af00  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c203  00000000  00000000  0000b320  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000270c  00000000  00000000  00017523  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000058e8  00000000  00000000  00019c2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bd0  00000000  00000000  0001f518  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004693  00000000  00000000  000210e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000828b  00000000  00000000  0002577b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fd97  00000000  00000000  0002da06  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001c0  00000000  00000000  001ad79d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 7e 0e 	jmp	0x1cfc	; 0x1cfc <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 b6 13 	jmp	0x276c	; 0x276c <__vector_16>
      44:	0c 94 8e 13 	jmp	0x271c	; 0x271c <__vector_17>
      48:	0c 94 66 13 	jmp	0x26cc	; 0x26cc <__vector_18>
      4c:	0c 94 20 13 	jmp	0x2640	; 0x2640 <__vector_19>
      50:	0c 94 9b 0c 	jmp	0x1936	; 0x1936 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 59 09 	jmp	0x12b2	; 0x12b2 <__vector_47>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 91 1e 	jmp	0x3d22	; 0x3d22 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 5d 10 	jmp	0x20ba	; 0x20ba <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 f8 12 	jmp	0x25f0	; 0x25f0 <__vector_79>
     140:	0c 94 d0 12 	jmp	0x25a0	; 0x25a0 <__vector_80>
     144:	0c 94 a8 12 	jmp	0x2550	; 0x2550 <__vector_81>
     148:	0c 94 7e 12 	jmp	0x24fc	; 0x24fc <__vector_82>
     14c:	0c 94 a0 09 	jmp	0x1340	; 0x1340 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 2d 0d 	jmp	0x1a5a	; 0x1a5a <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e8 e9       	ldi	r30, 0x98	; 152
     244:	fa e7       	ldi	r31, 0x7A	; 122
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ac 3b       	cpi	r26, 0xBC	; 188
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 db 06 	call	0xdb6	; 0xdb6 <main>
     26a:	0c 94 4a 3d 	jmp	0x7a94	; 0x7a94 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 31 3e 	sts	0x3E31, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 31 3e 	sts	0x3E31, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 23 3e 	lds	r24, 0x3E23
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 22 3e 	lds	r24, 0x3E22
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 31 3e 	sts	0x3E31, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	21 e3       	ldi	r18, 0x31	; 49
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 22 3e 	lds	r24, 0x3E22
     376:	90 91 23 3e 	lds	r25, 0x3E23
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 22 3e 	sts	0x3E22, r16
     382:	10 93 23 3e 	sts	0x3E23, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 31 3e 	sts	0x3E31, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	e1 eb       	ldi	r30, 0xB1	; 177
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 a6 38 	call	0x714c	; 0x714c <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 12 38 	call	0x7024	; 0x7024 <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 ad 37 	call	0x6f5a	; 0x6f5a <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 7a 38 	call	0x70f4	; 0x70f4 <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 a6 38 	call	0x714c	; 0x714c <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 ad 37 	call	0x6f5a	; 0x6f5a <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 34 39 	call	0x7268	; 0x7268 <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     608:	10 92 37 3e 	sts	0x3E37, r1
}
     60c:	08 95       	ret

0000060e <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     60e:	80 ec       	ldi	r24, 0xC0	; 192
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	4b e0       	ldi	r20, 0x0B	; 11
     614:	0e 94 4a 20 	call	0x4094	; 0x4094 <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     618:	e0 e5       	ldi	r30, 0x50	; 80
     61a:	f0 e0       	ldi	r31, 0x00	; 0
     61c:	80 81       	ld	r24, Z
     61e:	88 60       	ori	r24, 0x08	; 8
     620:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     622:	81 81       	ldd	r24, Z+1	; 0x01
     624:	83 ff       	sbrs	r24, 3
     626:	fd cf       	rjmp	.-6      	; 0x622 <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     628:	80 ec       	ldi	r24, 0xC0	; 192
     62a:	62 e0       	ldi	r22, 0x02	; 2
     62c:	0e 94 55 20 	call	0x40aa	; 0x40aa <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     630:	e0 e5       	ldi	r30, 0x50	; 80
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	80 61       	ori	r24, 0x10	; 16
     638:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	84 ff       	sbrs	r24, 4
     63e:	fd cf       	rjmp	.-6      	; 0x63a <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     640:	84 e0       	ldi	r24, 0x04	; 4
     642:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     646:	81 e0       	ldi	r24, 0x01	; 1
     648:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <CLKSYS_Disable>
}
     64c:	08 95       	ret

0000064e <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     64e:	e0 e5       	ldi	r30, 0x50	; 80
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	82 60       	ori	r24, 0x02	; 2
     656:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     658:	80 e0       	ldi	r24, 0x00	; 0
     65a:	61 e0       	ldi	r22, 0x01	; 1
     65c:	0e 94 65 20 	call	0x40ca	; 0x40ca <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     660:	e0 e5       	ldi	r30, 0x50	; 80
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	81 81       	ldd	r24, Z+1	; 0x01
     666:	81 ff       	sbrs	r24, 1
     668:	fd cf       	rjmp	.-6      	; 0x664 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <CLKSYS_Disable>
	
}
     676:	08 95       	ret

00000678 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     678:	e0 e5       	ldi	r30, 0x50	; 80
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	80 81       	ld	r24, Z
     67e:	82 60       	ori	r24, 0x02	; 2
     680:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     682:	80 e0       	ldi	r24, 0x00	; 0
     684:	60 e0       	ldi	r22, 0x00	; 0
     686:	0e 94 65 20 	call	0x40ca	; 0x40ca <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     68a:	e0 e5       	ldi	r30, 0x50	; 80
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	81 81       	ldd	r24, Z+1	; 0x01
     690:	81 ff       	sbrs	r24, 1
     692:	fd cf       	rjmp	.-6      	; 0x68e <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     694:	81 e0       	ldi	r24, 0x01	; 1
     696:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <CLKSYS_Disable>
	
}
     6a0:	08 95       	ret

000006a2 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     6a2:	88 23       	and	r24, r24
     6a4:	29 f0       	breq	.+10     	; 0x6b0 <portExCS+0xe>
     6a6:	88 e0       	ldi	r24, 0x08	; 8
     6a8:	e0 e0       	ldi	r30, 0x00	; 0
     6aa:	f6 e0       	ldi	r31, 0x06	; 6
     6ac:	86 83       	std	Z+6, r24	; 0x06
     6ae:	04 c0       	rjmp	.+8      	; 0x6b8 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     6b0:	88 e0       	ldi	r24, 0x08	; 8
     6b2:	e0 e0       	ldi	r30, 0x00	; 0
     6b4:	f6 e0       	ldi	r31, 0x06	; 6
     6b6:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6b8:	8a e6       	ldi	r24, 0x6A	; 106
     6ba:	8a 95       	dec	r24
     6bc:	f1 f7       	brne	.-4      	; 0x6ba <portExCS+0x18>
     6be:	00 c0       	rjmp	.+0      	; 0x6c0 <portExCS+0x1e>
	}
	_delay_us(10);
}
     6c0:	08 95       	ret

000006c2 <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     6c2:	88 23       	and	r24, r24
     6c4:	79 f0       	breq	.+30     	; 0x6e4 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     6c6:	e0 ea       	ldi	r30, 0xA0	; 160
     6c8:	f6 e0       	ldi	r31, 0x06	; 6
     6ca:	80 e2       	ldi	r24, 0x20	; 32
     6cc:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     6ce:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	93 ec       	ldi	r25, 0xC3	; 195
     6d4:	a9 e0       	ldi	r26, 0x09	; 9
     6d6:	81 50       	subi	r24, 0x01	; 1
     6d8:	90 40       	sbci	r25, 0x00	; 0
     6da:	a0 40       	sbci	r26, 0x00	; 0
     6dc:	e1 f7       	brne	.-8      	; 0x6d6 <Ext1Power+0x14>
     6de:	00 c0       	rjmp	.+0      	; 0x6e0 <Ext1Power+0x1e>
     6e0:	00 00       	nop
     6e2:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     6e4:	e0 ea       	ldi	r30, 0xA0	; 160
     6e6:	f6 e0       	ldi	r31, 0x06	; 6
     6e8:	80 e2       	ldi	r24, 0x20	; 32
     6ea:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     6ec:	82 83       	std	Z+2, r24	; 0x02
     6ee:	08 95       	ret

000006f0 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     6f0:	88 23       	and	r24, r24
     6f2:	79 f0       	breq	.+30     	; 0x712 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     6f4:	e0 ea       	ldi	r30, 0xA0	; 160
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	80 e4       	ldi	r24, 0x40	; 64
     6fa:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     6fc:	85 83       	std	Z+5, r24	; 0x05
     6fe:	8f ef       	ldi	r24, 0xFF	; 255
     700:	93 ec       	ldi	r25, 0xC3	; 195
     702:	a9 e0       	ldi	r26, 0x09	; 9
     704:	81 50       	subi	r24, 0x01	; 1
     706:	90 40       	sbci	r25, 0x00	; 0
     708:	a0 40       	sbci	r26, 0x00	; 0
     70a:	e1 f7       	brne	.-8      	; 0x704 <Ext2Power+0x14>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <Ext2Power+0x1e>
     70e:	00 00       	nop
     710:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     712:	e0 ea       	ldi	r30, 0xA0	; 160
     714:	f6 e0       	ldi	r31, 0x06	; 6
     716:	80 e4       	ldi	r24, 0x40	; 64
     718:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     71a:	82 83       	std	Z+2, r24	; 0x02
     71c:	08 95       	ret

0000071e <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     71e:	88 23       	and	r24, r24
     720:	79 f0       	breq	.+30     	; 0x740 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     722:	e0 ea       	ldi	r30, 0xA0	; 160
     724:	f6 e0       	ldi	r31, 0x06	; 6
     726:	80 e8       	ldi	r24, 0x80	; 128
     728:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     72a:	85 83       	std	Z+5, r24	; 0x05
     72c:	8f ef       	ldi	r24, 0xFF	; 255
     72e:	93 ec       	ldi	r25, 0xC3	; 195
     730:	a9 e0       	ldi	r26, 0x09	; 9
     732:	81 50       	subi	r24, 0x01	; 1
     734:	90 40       	sbci	r25, 0x00	; 0
     736:	a0 40       	sbci	r26, 0x00	; 0
     738:	e1 f7       	brne	.-8      	; 0x732 <HVPower+0x14>
     73a:	00 c0       	rjmp	.+0      	; 0x73c <HVPower+0x1e>
     73c:	00 00       	nop
     73e:	05 c0       	rjmp	.+10     	; 0x74a <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f6 e0       	ldi	r31, 0x06	; 6
     744:	80 e8       	ldi	r24, 0x80	; 128
     746:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     748:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     74a:	af e3       	ldi	r26, 0x3F	; 63
     74c:	bf e1       	ldi	r27, 0x1F	; 31
     74e:	11 97       	sbiw	r26, 0x01	; 1
     750:	f1 f7       	brne	.-4      	; 0x74e <HVPower+0x30>
     752:	00 c0       	rjmp	.+0      	; 0x754 <HVPower+0x36>
     754:	00 00       	nop
	}
	_delay_us(1000);
}
     756:	08 95       	ret

00000758 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     758:	88 23       	and	r24, r24
     75a:	29 f0       	breq	.+10     	; 0x766 <lowerMuxCS+0xe>
     75c:	80 e1       	ldi	r24, 0x10	; 16
     75e:	e0 e8       	ldi	r30, 0x80	; 128
     760:	f6 e0       	ldi	r31, 0x06	; 6
     762:	86 83       	std	Z+6, r24	; 0x06
     764:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     766:	80 e1       	ldi	r24, 0x10	; 16
     768:	e0 e8       	ldi	r30, 0x80	; 128
     76a:	f6 e0       	ldi	r31, 0x06	; 6
     76c:	85 83       	std	Z+5, r24	; 0x05
     76e:	08 95       	ret

00000770 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     770:	88 23       	and	r24, r24
     772:	29 f0       	breq	.+10     	; 0x77e <upperMuxCS+0xe>
     774:	82 e0       	ldi	r24, 0x02	; 2
     776:	e0 e4       	ldi	r30, 0x40	; 64
     778:	f6 e0       	ldi	r31, 0x06	; 6
     77a:	86 83       	std	Z+6, r24	; 0x06
     77c:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     77e:	82 e0       	ldi	r24, 0x02	; 2
     780:	e0 e4       	ldi	r30, 0x40	; 64
     782:	f6 e0       	ldi	r31, 0x06	; 6
     784:	85 83       	std	Z+5, r24	; 0x05
     786:	08 95       	ret

00000788 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     788:	e0 e4       	ldi	r30, 0x40	; 64
     78a:	f6 e0       	ldi	r31, 0x06	; 6
     78c:	90 e1       	ldi	r25, 0x10	; 16
     78e:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     790:	28 e3       	ldi	r18, 0x38	; 56
     792:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     794:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     796:	81 65       	ori	r24, 0x51	; 81
     798:	a0 ec       	ldi	r26, 0xC0	; 192
     79a:	b8 e0       	ldi	r27, 0x08	; 8
     79c:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     79e:	11 96       	adiw	r26, 0x01	; 1
     7a0:	1c 92       	st	X, r1
     7a2:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7a4:	80 ea       	ldi	r24, 0xA0	; 160
     7a6:	81 83       	std	Z+1, r24	; 0x01

	
}
     7a8:	08 95       	ret

000007aa <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     7aa:	e0 e4       	ldi	r30, 0x40	; 64
     7ac:	f6 e0       	ldi	r31, 0x06	; 6
     7ae:	90 e1       	ldi	r25, 0x10	; 16
     7b0:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     7b2:	28 e3       	ldi	r18, 0x38	; 56
     7b4:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     7b6:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     7b8:	80 65       	ori	r24, 0x50	; 80
     7ba:	68 2b       	or	r22, r24
     7bc:	a0 ec       	ldi	r26, 0xC0	; 192
     7be:	b8 e0       	ldi	r27, 0x08	; 8
     7c0:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     7c2:	11 96       	adiw	r26, 0x01	; 1
     7c4:	1c 92       	st	X, r1
     7c6:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7c8:	80 ea       	ldi	r24, 0xA0	; 160
     7ca:	81 83       	std	Z+1, r24	; 0x01
}
     7cc:	08 95       	ret

000007ce <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     7ce:	88 23       	and	r24, r24
     7d0:	29 f0       	breq	.+10     	; 0x7dc <SPICS+0xe>
     7d2:	80 e1       	ldi	r24, 0x10	; 16
     7d4:	e0 e4       	ldi	r30, 0x40	; 64
     7d6:	f6 e0       	ldi	r31, 0x06	; 6
     7d8:	86 83       	std	Z+6, r24	; 0x06
     7da:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     7dc:	80 e1       	ldi	r24, 0x10	; 16
     7de:	e0 e4       	ldi	r30, 0x40	; 64
     7e0:	f6 e0       	ldi	r31, 0x06	; 6
     7e2:	85 83       	std	Z+5, r24	; 0x05
     7e4:	08 95       	ret

000007e6 <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     7e6:	e0 e4       	ldi	r30, 0x40	; 64
     7e8:	f6 e0       	ldi	r31, 0x06	; 6
     7ea:	80 e1       	ldi	r24, 0x10	; 16
     7ec:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     7ee:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     7f2:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     7f4:	80 eb       	ldi	r24, 0xB0	; 176
     7f6:	82 83       	std	Z+2, r24	; 0x02

}
     7f8:	08 95       	ret

000007fa <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     7fe:	c8 2f       	mov	r28, r24
     800:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     802:	d8 2f       	mov	r29, r24
     804:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	a9 01       	movw	r20, r18
     80c:	45 70       	andi	r20, 0x05	; 5
     80e:	50 70       	andi	r21, 0x00	; 0
     810:	41 15       	cp	r20, r1
     812:	51 05       	cpc	r21, r1
     814:	49 f0       	breq	.+18     	; 0x828 <set_filter+0x2e>
     816:	90 91 35 3e 	lds	r25, 0x3E35
     81a:	48 2f       	mov	r20, r24
     81c:	42 95       	swap	r20
     81e:	4f 70       	andi	r20, 0x0F	; 15
     820:	90 7f       	andi	r25, 0xF0	; 240
     822:	94 2b       	or	r25, r20
     824:	90 93 35 3e 	sts	0x3E35, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     828:	2a 70       	andi	r18, 0x0A	; 10
     82a:	30 70       	andi	r19, 0x00	; 0
     82c:	21 15       	cp	r18, r1
     82e:	31 05       	cpc	r19, r1
     830:	39 f0       	breq	.+14     	; 0x840 <set_filter+0x46>
     832:	90 91 35 3e 	lds	r25, 0x3E35
     836:	80 7f       	andi	r24, 0xF0	; 240
     838:	9f 70       	andi	r25, 0x0F	; 15
     83a:	89 2b       	or	r24, r25
     83c:	80 93 35 3e 	sts	0x3E35, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     840:	84 e0       	ldi	r24, 0x04	; 4
     842:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     846:	80 91 35 3e 	lds	r24, 0x3E35
     84a:	80 93 25 3e 	sts	0x3E25, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     84e:	cc 23       	and	r28, r28
     850:	19 f0       	breq	.+6      	; 0x858 <set_filter+0x5e>
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     858:	dd 23       	and	r29, r29
     85a:	19 f0       	breq	.+6      	; 0x862 <set_filter+0x68>
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>

	SPICS(TRUE);
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     868:	8f ef       	ldi	r24, 0xFF	; 255
     86a:	e0 ec       	ldi	r30, 0xC0	; 192
     86c:	f8 e0       	ldi	r31, 0x08	; 8
     86e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     870:	82 81       	ldd	r24, Z+2	; 0x02
     872:	88 23       	and	r24, r24
     874:	ec f7       	brge	.-6      	; 0x870 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     876:	e0 ec       	ldi	r30, 0xC0	; 192
     878:	f8 e0       	ldi	r31, 0x08	; 8
     87a:	83 81       	ldd	r24, Z+3	; 0x03
     87c:	80 93 31 3e 	sts	0x3E31, r24

	nop();
     880:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     882:	a1 e3       	ldi	r26, 0x31	; 49
     884:	be e3       	ldi	r27, 0x3E	; 62
     886:	1c 97       	sbiw	r26, 0x0c	; 12
     888:	8c 91       	ld	r24, X
     88a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     88c:	82 81       	ldd	r24, Z+2	; 0x02
     88e:	88 23       	and	r24, r24
     890:	ec f7       	brge	.-6      	; 0x88c <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     892:	e0 ec       	ldi	r30, 0xC0	; 192
     894:	f8 e0       	ldi	r31, 0x08	; 8
     896:	83 81       	ldd	r24, Z+3	; 0x03
     898:	80 93 31 3e 	sts	0x3E31, r24
	SPICS(FALSE);
     89c:	80 e0       	ldi	r24, 0x00	; 0
     89e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     8a2:	cc 23       	and	r28, r28
     8a4:	19 f0       	breq	.+6      	; 0x8ac <set_filter+0xb2>
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     8ac:	dd 23       	and	r29, r29
     8ae:	19 f0       	breq	.+6      	; 0x8b6 <set_filter+0xbc>
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>
	SPIDisable();
     8b6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	08 95       	ret

000008c0 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     8c0:	cf 93       	push	r28
     8c2:	df 93       	push	r29
     8c4:	c8 2f       	mov	r28, r24
     8c6:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     8da:	dd 23       	and	r29, r29
     8dc:	89 f0       	breq	.+34     	; 0x900 <PortEx_OUTCLR+0x40>
     8de:	80 91 b0 21 	lds	r24, 0x21B0
     8e2:	c0 95       	com	r28
     8e4:	c8 23       	and	r28, r24
     8e6:	c0 93 b0 21 	sts	0x21B0, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     8ea:	80 e4       	ldi	r24, 0x40	; 64
     8ec:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     8f0:	84 e1       	ldi	r24, 0x14	; 20
     8f2:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankA_OUT;
     8f6:	80 91 b0 21 	lds	r24, 0x21B0
     8fa:	80 93 27 3e 	sts	0x3E27, r24
     8fe:	10 c0       	rjmp	.+32     	; 0x920 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     900:	80 91 36 3e 	lds	r24, 0x3E36
     904:	c0 95       	com	r28
     906:	c8 23       	and	r28, r24
     908:	c0 93 36 3e 	sts	0x3E36, r28
	
	SPIBuffer[0] = PS_WRITE;
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     912:	85 e1       	ldi	r24, 0x15	; 21
     914:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankB_OUT; 
     918:	80 91 36 3e 	lds	r24, 0x3E36
     91c:	80 93 27 3e 	sts	0x3E27, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     920:	80 e0       	ldi	r24, 0x00	; 0
     922:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     924:	25 e2       	ldi	r18, 0x25	; 37
     926:	3e e3       	ldi	r19, 0x3E	; 62
     928:	a0 ec       	ldi	r26, 0xC0	; 192
     92a:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     92c:	c1 e3       	ldi	r28, 0x31	; 49
     92e:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     930:	f9 01       	movw	r30, r18
     932:	e8 0f       	add	r30, r24
     934:	f9 1f       	adc	r31, r25
     936:	40 81       	ld	r20, Z
     938:	13 96       	adiw	r26, 0x03	; 3
     93a:	4c 93       	st	X, r20
     93c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     93e:	12 96       	adiw	r26, 0x02	; 2
     940:	4c 91       	ld	r20, X
     942:	12 97       	sbiw	r26, 0x02	; 2
     944:	44 23       	and	r20, r20
     946:	dc f7       	brge	.-10     	; 0x93e <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     948:	13 96       	adiw	r26, 0x03	; 3
     94a:	4c 91       	ld	r20, X
     94c:	13 97       	sbiw	r26, 0x03	; 3
     94e:	48 83       	st	Y, r20
     950:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     952:	83 30       	cpi	r24, 0x03	; 3
     954:	91 05       	cpc	r25, r1
     956:	61 f7       	brne	.-40     	; 0x930 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     964:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
     96c:	08 95       	ret

0000096e <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	c8 2f       	mov	r28, r24
     974:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     988:	dd 23       	and	r29, r29
     98a:	81 f0       	breq	.+32     	; 0x9ac <PortEx_OUTSET+0x3e>
     98c:	80 91 b0 21 	lds	r24, 0x21B0
     990:	c8 2b       	or	r28, r24
     992:	c0 93 b0 21 	sts	0x21B0, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     996:	80 e4       	ldi	r24, 0x40	; 64
     998:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     99c:	84 e1       	ldi	r24, 0x14	; 20
     99e:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankA_OUT;
     9a2:	80 91 b0 21 	lds	r24, 0x21B0
     9a6:	80 93 27 3e 	sts	0x3E27, r24
     9aa:	0f c0       	rjmp	.+30     	; 0x9ca <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     9ac:	80 91 36 3e 	lds	r24, 0x3E36
     9b0:	c8 2b       	or	r28, r24
     9b2:	c0 93 36 3e 	sts	0x3E36, r28
	
	SPIBuffer[0] = PS_WRITE;
     9b6:	80 e4       	ldi	r24, 0x40	; 64
     9b8:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     9bc:	85 e1       	ldi	r24, 0x15	; 21
     9be:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankB_OUT; 
     9c2:	80 91 36 3e 	lds	r24, 0x3E36
     9c6:	80 93 27 3e 	sts	0x3E27, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9ce:	25 e2       	ldi	r18, 0x25	; 37
     9d0:	3e e3       	ldi	r19, 0x3E	; 62
     9d2:	a0 ec       	ldi	r26, 0xC0	; 192
     9d4:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     9d6:	c1 e3       	ldi	r28, 0x31	; 49
     9d8:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9da:	f9 01       	movw	r30, r18
     9dc:	e8 0f       	add	r30, r24
     9de:	f9 1f       	adc	r31, r25
     9e0:	40 81       	ld	r20, Z
     9e2:	13 96       	adiw	r26, 0x03	; 3
     9e4:	4c 93       	st	X, r20
     9e6:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     9e8:	12 96       	adiw	r26, 0x02	; 2
     9ea:	4c 91       	ld	r20, X
     9ec:	12 97       	sbiw	r26, 0x02	; 2
     9ee:	44 23       	and	r20, r20
     9f0:	dc f7       	brge	.-10     	; 0x9e8 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     9f2:	13 96       	adiw	r26, 0x03	; 3
     9f4:	4c 91       	ld	r20, X
     9f6:	13 97       	sbiw	r26, 0x03	; 3
     9f8:	48 83       	st	Y, r20
     9fa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     9fc:	83 30       	cpi	r24, 0x03	; 3
     9fe:	91 05       	cpc	r25, r1
     a00:	61 f7       	brne	.-40     	; 0x9da <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     a02:	80 e0       	ldi	r24, 0x00	; 0
     a04:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     a0e:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     a12:	df 91       	pop	r29
     a14:	cf 91       	pop	r28
     a16:	08 95       	ret

00000a18 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	c8 2f       	mov	r28, r24
     a1e:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     a2c:	81 e0       	ldi	r24, 0x01	; 1
     a2e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     a32:	dd 23       	and	r29, r29
     a34:	89 f0       	breq	.+34     	; 0xa58 <PortEx_DIRCLR+0x40>
     a36:	80 91 34 3e 	lds	r24, 0x3E34
     a3a:	80 95       	com	r24
     a3c:	c8 23       	and	r28, r24
     a3e:	c0 93 34 3e 	sts	0x3E34, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     a42:	80 e4       	ldi	r24, 0x40	; 64
     a44:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     a48:	10 92 26 3e 	sts	0x3E26, r1
		SPIBuffer[2] = ~bankA_DIR; 
     a4c:	80 91 34 3e 	lds	r24, 0x3E34
     a50:	80 95       	com	r24
     a52:	80 93 27 3e 	sts	0x3E27, r24
     a56:	11 c0       	rjmp	.+34     	; 0xa7a <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     a58:	80 91 4b 3e 	lds	r24, 0x3E4B
     a5c:	80 95       	com	r24
     a5e:	c8 23       	and	r28, r24
     a60:	c0 93 4b 3e 	sts	0x3E4B, r28
	
	SPIBuffer[0] = PS_WRITE;
     a64:	80 e4       	ldi	r24, 0x40	; 64
     a66:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = ~bankB_DIR;
     a70:	80 91 4b 3e 	lds	r24, 0x3E4B
     a74:	80 95       	com	r24
     a76:	80 93 27 3e 	sts	0x3E27, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a7e:	25 e2       	ldi	r18, 0x25	; 37
     a80:	3e e3       	ldi	r19, 0x3E	; 62
     a82:	a0 ec       	ldi	r26, 0xC0	; 192
     a84:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     a86:	c1 e3       	ldi	r28, 0x31	; 49
     a88:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a8a:	f9 01       	movw	r30, r18
     a8c:	e8 0f       	add	r30, r24
     a8e:	f9 1f       	adc	r31, r25
     a90:	40 81       	ld	r20, Z
     a92:	13 96       	adiw	r26, 0x03	; 3
     a94:	4c 93       	st	X, r20
     a96:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     a98:	12 96       	adiw	r26, 0x02	; 2
     a9a:	4c 91       	ld	r20, X
     a9c:	12 97       	sbiw	r26, 0x02	; 2
     a9e:	44 23       	and	r20, r20
     aa0:	dc f7       	brge	.-10     	; 0xa98 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     aa2:	13 96       	adiw	r26, 0x03	; 3
     aa4:	4c 91       	ld	r20, X
     aa6:	13 97       	sbiw	r26, 0x03	; 3
     aa8:	48 83       	st	Y, r20
     aaa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     aac:	83 30       	cpi	r24, 0x03	; 3
     aae:	91 05       	cpc	r25, r1
     ab0:	61 f7       	brne	.-40     	; 0xa8a <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     ab8:	80 e0       	ldi	r24, 0x00	; 0
     aba:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     abe:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	08 95       	ret

00000ac8 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	c8 2f       	mov	r28, r24
     ace:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     ad0:	80 e0       	ldi	r24, 0x00	; 0
     ad2:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     ae2:	dd 23       	and	r29, r29
     ae4:	81 f0       	breq	.+32     	; 0xb06 <PortEx_DIRSET+0x3e>
     ae6:	80 91 34 3e 	lds	r24, 0x3E34
     aea:	c8 2b       	or	r28, r24
     aec:	c0 93 34 3e 	sts	0x3E34, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     af0:	80 e4       	ldi	r24, 0x40	; 64
     af2:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     af6:	10 92 26 3e 	sts	0x3E26, r1
		SPIBuffer[2] = ~bankA_DIR; 
     afa:	80 91 34 3e 	lds	r24, 0x3E34
     afe:	80 95       	com	r24
     b00:	80 93 27 3e 	sts	0x3E27, r24
     b04:	10 c0       	rjmp	.+32     	; 0xb26 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     b06:	80 91 4b 3e 	lds	r24, 0x3E4B
     b0a:	c8 2b       	or	r28, r24
     b0c:	c0 93 4b 3e 	sts	0x3E4B, r28
	
	SPIBuffer[0] = PS_WRITE;
     b10:	80 e4       	ldi	r24, 0x40	; 64
     b12:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     b16:	81 e0       	ldi	r24, 0x01	; 1
     b18:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = ~bankB_DIR;
     b1c:	80 91 4b 3e 	lds	r24, 0x3E4B
     b20:	80 95       	com	r24
     b22:	80 93 27 3e 	sts	0x3E27, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     b26:	80 e0       	ldi	r24, 0x00	; 0
     b28:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b2a:	25 e2       	ldi	r18, 0x25	; 37
     b2c:	3e e3       	ldi	r19, 0x3E	; 62
     b2e:	a0 ec       	ldi	r26, 0xC0	; 192
     b30:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b32:	c1 e3       	ldi	r28, 0x31	; 49
     b34:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b36:	f9 01       	movw	r30, r18
     b38:	e8 0f       	add	r30, r24
     b3a:	f9 1f       	adc	r31, r25
     b3c:	40 81       	ld	r20, Z
     b3e:	13 96       	adiw	r26, 0x03	; 3
     b40:	4c 93       	st	X, r20
     b42:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     b44:	12 96       	adiw	r26, 0x02	; 2
     b46:	4c 91       	ld	r20, X
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	44 23       	and	r20, r20
     b4c:	dc f7       	brge	.-10     	; 0xb44 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b4e:	13 96       	adiw	r26, 0x03	; 3
     b50:	4c 91       	ld	r20, X
     b52:	13 97       	sbiw	r26, 0x03	; 3
     b54:	48 83       	st	Y, r20
     b56:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     b58:	83 30       	cpi	r24, 0x03	; 3
     b5a:	91 05       	cpc	r25, r1
     b5c:	61 f7       	brne	.-40     	; 0xb36 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPICS(FALSE);
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
     b6a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>


}
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	08 95       	ret

00000b74 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     b74:	0f 93       	push	r16
     b76:	1f 93       	push	r17
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     b7c:	88 23       	and	r24, r24
     b7e:	09 f4       	brne	.+2      	; 0xb82 <ADCPower+0xe>
     b80:	4e c0       	rjmp	.+156    	; 0xc1e <ADCPower+0xaa>
     b82:	80 91 37 3e 	lds	r24, 0x3E37
     b86:	88 23       	and	r24, r24
     b88:	09 f0       	breq	.+2      	; 0xb8c <ADCPower+0x18>
     b8a:	81 c0       	rjmp	.+258    	; 0xc8e <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     b8c:	00 e0       	ldi	r16, 0x00	; 0
     b8e:	16 e0       	ldi	r17, 0x06	; 6
     b90:	8e ed       	ldi	r24, 0xDE	; 222
     b92:	d8 01       	movw	r26, r16
     b94:	11 96       	adiw	r26, 0x01	; 1
     b96:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b98:	c0 e2       	ldi	r28, 0x20	; 32
     b9a:	d6 e0       	ldi	r29, 0x06	; 6
     b9c:	4e e0       	ldi	r20, 0x0E	; 14
     b9e:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     ba0:	e0 e4       	ldi	r30, 0x40	; 64
     ba2:	f6 e0       	ldi	r31, 0x06	; 6
     ba4:	63 e0       	ldi	r22, 0x03	; 3
     ba6:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     ba8:	80 e8       	ldi	r24, 0x80	; 128
     baa:	96 e0       	ldi	r25, 0x06	; 6
     bac:	50 e1       	ldi	r21, 0x10	; 16
     bae:	dc 01       	movw	r26, r24
     bb0:	11 96       	adiw	r26, 0x01	; 1
     bb2:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     bb4:	20 ea       	ldi	r18, 0xA0	; 160
     bb6:	36 e0       	ldi	r19, 0x06	; 6
     bb8:	d9 01       	movw	r26, r18
     bba:	11 96       	adiw	r26, 0x01	; 1
     bbc:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     bbe:	7e e9       	ldi	r23, 0x9E	; 158
     bc0:	d8 01       	movw	r26, r16
     bc2:	15 96       	adiw	r26, 0x05	; 5
     bc4:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     bc6:	78 e0       	ldi	r23, 0x08	; 8
     bc8:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     bca:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     bcc:	ec 01       	movw	r28, r24
     bce:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     bd0:	d9 01       	movw	r26, r18
     bd2:	15 96       	adiw	r26, 0x05	; 5
     bd4:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     bd6:	10 92 35 3e 	sts	0x3E35, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     bda:	8f ef       	ldi	r24, 0xFF	; 255
     bdc:	93 ec       	ldi	r25, 0xC3	; 195
     bde:	a9 e0       	ldi	r26, 0x09	; 9
     be0:	81 50       	subi	r24, 0x01	; 1
     be2:	90 40       	sbci	r25, 0x00	; 0
     be4:	a0 40       	sbci	r26, 0x00	; 0
     be6:	e1 f7       	brne	.-8      	; 0xbe0 <ADCPower+0x6c>
     be8:	00 c0       	rjmp	.+0      	; 0xbea <ADCPower+0x76>
     bea:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     bec:	80 e4       	ldi	r24, 0x40	; 64
     bee:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     bf0:	10 92 36 3e 	sts	0x3E36, r1
     bf4:	10 92 4b 3e 	sts	0x3E4B, r1
     bf8:	10 92 b0 21 	sts	0x21B0, r1
     bfc:	10 92 34 3e 	sts	0x3E34, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     c00:	8f ef       	ldi	r24, 0xFF	; 255
     c02:	61 e0       	ldi	r22, 0x01	; 1
     c04:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	61 e0       	ldi	r22, 0x01	; 1
     c0c:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
		ADC_POWER_ON = TRUE;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	80 93 37 3e 	sts	0x3E37, r24
     c1c:	38 c0       	rjmp	.+112    	; 0xc8e <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     c1e:	80 91 37 3e 	lds	r24, 0x3E37
     c22:	88 23       	and	r24, r24
     c24:	a1 f1       	breq	.+104    	; 0xc8e <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     c26:	00 e0       	ldi	r16, 0x00	; 0
     c28:	16 e0       	ldi	r17, 0x06	; 6
     c2a:	7e ed       	ldi	r23, 0xDE	; 222
     c2c:	d8 01       	movw	r26, r16
     c2e:	16 96       	adiw	r26, 0x06	; 6
     c30:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c32:	a0 e2       	ldi	r26, 0x20	; 32
     c34:	b6 e0       	ldi	r27, 0x06	; 6
     c36:	4e e0       	ldi	r20, 0x0E	; 14
     c38:	16 96       	adiw	r26, 0x06	; 6
     c3a:	4c 93       	st	X, r20
     c3c:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c3e:	20 e4       	ldi	r18, 0x40	; 64
     c40:	36 e0       	ldi	r19, 0x06	; 6
     c42:	63 e0       	ldi	r22, 0x03	; 3
     c44:	e9 01       	movw	r28, r18
     c46:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     c48:	c0 e8       	ldi	r28, 0x80	; 128
     c4a:	d6 e0       	ldi	r29, 0x06	; 6
     c4c:	50 e1       	ldi	r21, 0x10	; 16
     c4e:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c50:	80 ea       	ldi	r24, 0xA0	; 160
     c52:	96 e0       	ldi	r25, 0x06	; 6
     c54:	fc 01       	movw	r30, r24
     c56:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     c58:	f8 01       	movw	r30, r16
     c5a:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     c5c:	12 96       	adiw	r26, 0x02	; 2
     c5e:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     c60:	d9 01       	movw	r26, r18
     c62:	12 96       	adiw	r26, 0x02	; 2
     c64:	6c 93       	st	X, r22
     c66:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     c68:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     c6a:	ec 01       	movw	r28, r24
     c6c:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     c6e:	80 e4       	ldi	r24, 0x40	; 64
     c70:	12 96       	adiw	r26, 0x02	; 2
     c72:	8c 93       	st	X, r24
     c74:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     c76:	10 92 36 3e 	sts	0x3E36, r1
     c7a:	10 92 4b 3e 	sts	0x3E4B, r1
     c7e:	10 92 b0 21 	sts	0x21B0, r1
     c82:	10 92 34 3e 	sts	0x3E34, r1
		channelStatus = 0x00;
     c86:	10 92 35 3e 	sts	0x3E35, r1
		ADC_POWER_ON = FALSE;
     c8a:	10 92 37 3e 	sts	0x3E37, r1
	}
}
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	08 95       	ret

00000c98 <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     c98:	2f 92       	push	r2
     c9a:	3f 92       	push	r3
     c9c:	4f 92       	push	r4
     c9e:	5f 92       	push	r5
     ca0:	6f 92       	push	r6
     ca2:	7f 92       	push	r7
     ca4:	8f 92       	push	r8
     ca6:	9f 92       	push	r9
     ca8:	af 92       	push	r10
     caa:	bf 92       	push	r11
     cac:	cf 92       	push	r12
     cae:	df 92       	push	r13
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
     cc0:	64 97       	sbiw	r28, 0x14	; 20
     cc2:	cd bf       	out	0x3d, r28	; 61
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	2a 01       	movw	r4, r20
     cc8:	3b 01       	movw	r6, r22
     cca:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     ccc:	f9 01       	movw	r30, r18
     cce:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     cd0:	41 15       	cp	r20, r1
     cd2:	51 05       	cpc	r21, r1
     cd4:	61 05       	cpc	r22, r1
     cd6:	71 05       	cpc	r23, r1
     cd8:	09 f4       	brne	.+2      	; 0xcdc <DeciToString+0x44>
     cda:	4d c0       	rjmp	.+154    	; 0xd76 <DeciToString+0xde>
     cdc:	88 2e       	mov	r8, r24
     cde:	99 2e       	mov	r9, r25
     ce0:	cc 24       	eor	r12, r12
     ce2:	dd 24       	eor	r13, r13
     ce4:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     ce6:	5e 01       	movw	r10, r28
     ce8:	08 94       	sec
     cea:	a1 1c       	adc	r10, r1
     cec:	b1 1c       	adc	r11, r1
     cee:	0f 2e       	mov	r0, r31
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	2f 2e       	mov	r2, r31
     cf4:	f0 e2       	ldi	r31, 0x20	; 32
     cf6:	3f 2e       	mov	r3, r31
     cf8:	f0 2d       	mov	r31, r0
     cfa:	f4 01       	movw	r30, r8
     cfc:	81 91       	ld	r24, Z+
     cfe:	91 91       	ld	r25, Z+
     d00:	a1 91       	ld	r26, Z+
     d02:	b1 91       	ld	r27, Z+
     d04:	4f 01       	movw	r8, r30
     d06:	2d b7       	in	r18, 0x3d	; 61
     d08:	3e b7       	in	r19, 0x3e	; 62
     d0a:	28 50       	subi	r18, 0x08	; 8
     d0c:	30 40       	sbci	r19, 0x00	; 0
     d0e:	2d bf       	out	0x3d, r18	; 61
     d10:	3e bf       	out	0x3e, r19	; 62
     d12:	2f 5f       	subi	r18, 0xFF	; 255
     d14:	3f 4f       	sbci	r19, 0xFF	; 255
     d16:	ed b7       	in	r30, 0x3d	; 61
     d18:	fe b7       	in	r31, 0x3e	; 62
     d1a:	a1 82       	std	Z+1, r10	; 0x01
     d1c:	b2 82       	std	Z+2, r11	; 0x02
     d1e:	f9 01       	movw	r30, r18
     d20:	22 82       	std	Z+2, r2	; 0x02
     d22:	33 82       	std	Z+3, r3	; 0x03
     d24:	84 83       	std	Z+4, r24	; 0x04
     d26:	95 83       	std	Z+5, r25	; 0x05
     d28:	a6 83       	std	Z+6, r26	; 0x06
     d2a:	b7 83       	std	Z+7, r27	; 0x07
     d2c:	0e 94 67 3a 	call	0x74ce	; 0x74ce <sprintf>
		strcat(ReturnString,b);
     d30:	2d b7       	in	r18, 0x3d	; 61
     d32:	3e b7       	in	r19, 0x3e	; 62
     d34:	28 5f       	subi	r18, 0xF8	; 248
     d36:	3f 4f       	sbci	r19, 0xFF	; 255
     d38:	2d bf       	out	0x3d, r18	; 61
     d3a:	3e bf       	out	0x3e, r19	; 62
     d3c:	c8 01       	movw	r24, r16
     d3e:	b5 01       	movw	r22, r10
     d40:	0e 94 29 3a 	call	0x7452	; 0x7452 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     d44:	a0 2f       	mov	r26, r16
     d46:	b1 2f       	mov	r27, r17
     d48:	fd 01       	movw	r30, r26
     d4a:	01 90       	ld	r0, Z+
     d4c:	00 20       	and	r0, r0
     d4e:	e9 f7       	brne	.-6      	; 0xd4a <DeciToString+0xb2>
     d50:	31 97       	sbiw	r30, 0x01	; 1
     d52:	ea 1b       	sub	r30, r26
     d54:	fb 0b       	sbc	r31, r27
     d56:	e0 0f       	add	r30, r16
     d58:	f1 1f       	adc	r31, r17
     d5a:	8a e0       	ldi	r24, 0x0A	; 10
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	80 83       	st	Z, r24
     d60:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     d62:	08 94       	sec
     d64:	c1 1c       	adc	r12, r1
     d66:	d1 1c       	adc	r13, r1
     d68:	e1 1c       	adc	r14, r1
     d6a:	f1 1c       	adc	r15, r1
     d6c:	c4 14       	cp	r12, r4
     d6e:	d5 04       	cpc	r13, r5
     d70:	e6 04       	cpc	r14, r6
     d72:	f7 04       	cpc	r15, r7
     d74:	11 f6       	brne	.-124    	; 0xcfa <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     d76:	64 96       	adiw	r28, 0x14	; 20
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ff 90       	pop	r15
     d86:	ef 90       	pop	r14
     d88:	df 90       	pop	r13
     d8a:	cf 90       	pop	r12
     d8c:	bf 90       	pop	r11
     d8e:	af 90       	pop	r10
     d90:	9f 90       	pop	r9
     d92:	8f 90       	pop	r8
     d94:	7f 90       	pop	r7
     d96:	6f 90       	pop	r6
     d98:	5f 90       	pop	r5
     d9a:	4f 90       	pop	r4
     d9c:	3f 90       	pop	r3
     d9e:	2f 90       	pop	r2
     da0:	08 95       	ret

00000da2 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     da2:	e0 ec       	ldi	r30, 0xC0	; 192
     da4:	f8 e0       	ldi	r31, 0x08	; 8
     da6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     da8:	82 81       	ldd	r24, Z+2	; 0x02
     daa:	88 23       	and	r24, r24
     dac:	ec f7       	brge	.-6      	; 0xda8 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     dae:	e0 ec       	ldi	r30, 0xC0	; 192
     db0:	f8 e0       	ldi	r31, 0x08	; 8
     db2:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     db4:	08 95       	ret

00000db6 <main>:

#include "E-000001-000009_firmware_rev_1_0.h"

volatile uint8_t TimedOut = 0;

int main(){
     db6:	cf 93       	push	r28
     db8:	df 93       	push	r29
     dba:	cd b7       	in	r28, 0x3d	; 61
     dbc:	de b7       	in	r29, 0x3e	; 62
     dbe:	6d 97       	sbiw	r28, 0x1d	; 29
     dc0:	cd bf       	out	0x3d, r28	; 61
     dc2:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
     dc4:	19 82       	std	Y+1, r1	; 0x01
     dc6:	1a 82       	std	Y+2, r1	; 0x02
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
	volatile uint32_t samples = 0;
     dc8:	1c 82       	std	Y+4, r1	; 0x04
     dca:	1d 82       	std	Y+5, r1	; 0x05
     dcc:	1e 82       	std	Y+6, r1	; 0x06
     dce:	1f 82       	std	Y+7, r1	; 0x07
	DataAvailable = 0;
     dd0:	10 92 4c 3e 	sts	0x3E4C, r1
	ADC_Sampling_Finished = 1;
     dd4:	11 e0       	ldi	r17, 0x01	; 1
     dd6:	10 93 ab 50 	sts	0x50AB, r17
	uint8_t RadioMessageBuffer[20];
	unsigned char ofile[] = {'o','u','t','p','u','t'};
	set_32MHz();
     dda:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	chb_init();
     dde:	0e 94 31 1a 	call	0x3462	; 0x3462 <chb_init>
	chb_set_channel(1);
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <chb_set_channel>
	chb_set_short_addr(0x0003);
     de8:	83 e0       	ldi	r24, 0x03	; 3
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <chb_set_short_addr>
	chb_set_pwr(0);
     df0:	80 e0       	ldi	r24, 0x00	; 0
     df2:	0e 94 31 1c 	call	0x3862	; 0x3862 <chb_set_pwr>
	pcb_t* pcb = chb_get_pcb();
     df6:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <chb_get_pcb>
     dfa:	3c 01       	movw	r6, r24
	//SD_init();
	//getBootSectorData();
	
	//setup timeout timer
	//approx 2 seconds to wait (using largest prescaler of 1024)
	TCE0.PER = 4000;
     dfc:	e0 e0       	ldi	r30, 0x00	; 0
     dfe:	fa e0       	ldi	r31, 0x0A	; 10
     e00:	80 ea       	ldi	r24, 0xA0	; 160
     e02:	9f e0       	ldi	r25, 0x0F	; 15
     e04:	86 a3       	lds	r24, 0x56
     e06:	97 a3       	lds	r25, 0x57
	TCE0.CTRLFSET = 0x08;
     e08:	88 e0       	ldi	r24, 0x08	; 8
     e0a:	81 87       	std	Z+9, r24	; 0x09
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
     e0c:	16 83       	std	Z+6, r17	; 0x06
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
     e0e:	e0 ea       	ldi	r30, 0xA0	; 160
     e10:	f0 e0       	ldi	r31, 0x00	; 0
     e12:	82 81       	ldd	r24, Z+2	; 0x02
     e14:	81 60       	ori	r24, 0x01	; 1
     e16:	82 83       	std	Z+2, r24	; 0x02
	sei();
     e18:	78 94       	sei
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
     e1a:	0f 2e       	mov	r0, r31
     e1c:	f0 ed       	ldi	r31, 0xD0	; 208
     e1e:	2f 2e       	mov	r2, r31
     e20:	f7 e0       	ldi	r31, 0x07	; 7
     e22:	3f 2e       	mov	r3, r31
     e24:	f0 2d       	mov	r31, r0
volatile uint8_t TimedOut = 0;

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     e26:	44 24       	eor	r4, r4
									while(chb_write(0x0000,FRAMReadBuffer,100) != CHB_SUCCESS);
									i += 100;
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
									while(chb_write(0x0000,FRAMReadBuffer,samples*4 - i) != CHB_SUCCESS);
     e28:	81 eb       	ldi	r24, 0xB1	; 177
     e2a:	91 e2       	ldi	r25, 0x21	; 33
     e2c:	18 2f       	mov	r17, r24
     e2e:	59 2e       	mov	r5, r25
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
	sei();

	while(1){
		if(pcb->data_rcv){
     e30:	d3 01       	movw	r26, r6
     e32:	17 96       	adiw	r26, 0x07	; 7
     e34:	8c 91       	ld	r24, X
     e36:	17 97       	sbiw	r26, 0x07	; 7
     e38:	88 23       	and	r24, r24
     e3a:	d1 f3       	breq	.-12     	; 0xe30 <main+0x7a>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     e3c:	ce 01       	movw	r24, r28
     e3e:	08 96       	adiw	r24, 0x08	; 8
     e40:	0e 94 03 1b 	call	0x3606	; 0x3606 <chb_read>
			//length should be >1 for setting gain/freq commands: the value is likely sent in a separate message
			//process received message if it is from the base station (node id 0)
			if(pcb->sender_addr == 0x0000){
     e44:	f3 01       	movw	r30, r6
     e46:	82 81       	ldd	r24, Z+2	; 0x02
     e48:	93 81       	ldd	r25, Z+3	; 0x03
     e4a:	00 97       	sbiw	r24, 0x00	; 0
     e4c:	89 f7       	brne	.-30     	; 0xe30 <main+0x7a>
				switch ( RadioMessageBuffer[0]){
     e4e:	88 85       	ldd	r24, Y+8	; 0x08
     e50:	82 35       	cpi	r24, 0x52	; 82
     e52:	71 f0       	breq	.+28     	; 0xe70 <main+0xba>
     e54:	83 35       	cpi	r24, 0x53	; 83
     e56:	30 f4       	brcc	.+12     	; 0xe64 <main+0xae>
     e58:	86 34       	cpi	r24, 0x46	; 70
     e5a:	09 f4       	brne	.+2      	; 0xe5e <main+0xa8>
     e5c:	a7 c0       	rjmp	.+334    	; 0xfac <main+0x1f6>
     e5e:	87 34       	cpi	r24, 0x47	; 71
     e60:	39 f7       	brne	.-50     	; 0xe30 <main+0x7a>
     e62:	54 c0       	rjmp	.+168    	; 0xf0c <main+0x156>
     e64:	83 35       	cpi	r24, 0x53	; 83
     e66:	09 f4       	brne	.+2      	; 0xe6a <main+0xb4>
     e68:	b7 c0       	rjmp	.+366    	; 0xfd8 <main+0x222>
     e6a:	84 35       	cpi	r24, 0x54	; 84
     e6c:	09 f7       	brne	.-62     	; 0xe30 <main+0x7a>
     e6e:	d0 c0       	rjmp	.+416    	; 0x1010 <main+0x25a>
					
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     e70:	80 91 ab 50 	lds	r24, 0x50AB
     e74:	88 23       	and	r24, r24
     e76:	b1 f1       	breq	.+108    	; 0xee4 <main+0x12e>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, 10000, (int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, FALSE, 1, 2, 3, 4, 10000,(int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
     e78:	8d b7       	in	r24, 0x3d	; 61
     e7a:	9e b7       	in	r25, 0x3e	; 62
     e7c:	07 97       	sbiw	r24, 0x07	; 7
     e7e:	8d bf       	out	0x3d, r24	; 61
     e80:	9e bf       	out	0x3e, r25	; 62
     e82:	ed b7       	in	r30, 0x3d	; 61
     e84:	fe b7       	in	r31, 0x3e	; 62
     e86:	31 96       	adiw	r30, 0x01	; 1
     e88:	80 e1       	ldi	r24, 0x10	; 16
     e8a:	97 e2       	ldi	r25, 0x27	; 39
     e8c:	ad b7       	in	r26, 0x3d	; 61
     e8e:	be b7       	in	r27, 0x3e	; 62
     e90:	11 96       	adiw	r26, 0x01	; 1
     e92:	8d 93       	st	X+, r24
     e94:	9c 93       	st	X, r25
     e96:	12 97       	sbiw	r26, 0x02	; 2
     e98:	a1 eb       	ldi	r26, 0xB1	; 177
     e9a:	b1 e2       	ldi	r27, 0x21	; 33
     e9c:	a2 83       	std	Z+2, r26	; 0x02
     e9e:	b3 83       	std	Z+3, r27	; 0x03
     ea0:	8c e1       	ldi	r24, 0x1C	; 28
     ea2:	97 e0       	ldi	r25, 0x07	; 7
     ea4:	84 83       	std	Z+4, r24	; 0x04
     ea6:	95 83       	std	Z+5, r25	; 0x05
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	86 83       	std	Z+6, r24	; 0x06
     eac:	87 e0       	ldi	r24, 0x07	; 7
     eae:	64 2d       	mov	r22, r4
     eb0:	a1 01       	movw	r20, r2
     eb2:	26 e0       	ldi	r18, 0x06	; 6
     eb4:	00 e0       	ldi	r16, 0x00	; 0
     eb6:	ee 24       	eor	r14, r14
     eb8:	ff 24       	eor	r15, r15
     eba:	e3 94       	inc	r14
     ebc:	cc 24       	eor	r12, r12
     ebe:	dd 24       	eor	r13, r13
     ec0:	68 94       	set
     ec2:	c1 f8       	bld	r12, 1
     ec4:	0f 2e       	mov	r0, r31
     ec6:	f3 e0       	ldi	r31, 0x03	; 3
     ec8:	af 2e       	mov	r10, r31
     eca:	bb 24       	eor	r11, r11
     ecc:	f0 2d       	mov	r31, r0
     ece:	88 24       	eor	r8, r8
     ed0:	99 24       	eor	r9, r9
     ed2:	68 94       	set
     ed4:	82 f8       	bld	r8, 2
     ed6:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <CO_collectSeismic1Channel>
     eda:	ad b7       	in	r26, 0x3d	; 61
     edc:	be b7       	in	r27, 0x3e	; 62
     ede:	17 96       	adiw	r26, 0x07	; 7
     ee0:	ad bf       	out	0x3d, r26	; 61
     ee2:	be bf       	out	0x3e, r27	; 62
					}
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
     ee4:	f3 01       	movw	r30, r6
     ee6:	84 81       	ldd	r24, Z+4	; 0x04
     ee8:	95 81       	ldd	r25, Z+5	; 0x05
     eea:	ff ef       	ldi	r31, 0xFF	; 255
     eec:	8f 3f       	cpi	r24, 0xFF	; 255
     eee:	9f 07       	cpc	r25, r31
     ef0:	09 f4       	brne	.+2      	; 0xef4 <main+0x13e>
     ef2:	9e cf       	rjmp	.-196    	; 0xe30 <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
     ef4:	80 e0       	ldi	r24, 0x00	; 0
     ef6:	90 e0       	ldi	r25, 0x00	; 0
     ef8:	be 01       	movw	r22, r28
     efa:	6f 5f       	subi	r22, 0xFF	; 255
     efc:	7f 4f       	sbci	r23, 0xFF	; 255
     efe:	22 e0       	ldi	r18, 0x02	; 2
     f00:	30 e0       	ldi	r19, 0x00	; 0
     f02:	40 e0       	ldi	r20, 0x00	; 0
     f04:	50 e0       	ldi	r21, 0x00	; 0
     f06:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
     f0a:	92 cf       	rjmp	.-220    	; 0xe30 <main+0x7a>
					
				case 'G':
					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
     f0c:	89 85       	ldd	r24, Y+9	; 0x09
     f0e:	8b 83       	std	Y+3, r24	; 0x03
					switch(RawGain){
     f10:	8b 81       	ldd	r24, Y+3	; 0x03
     f12:	88 30       	cpi	r24, 0x08	; 8
     f14:	e1 f0       	breq	.+56     	; 0xf4e <main+0x198>
     f16:	89 30       	cpi	r24, 0x09	; 9
     f18:	38 f4       	brcc	.+14     	; 0xf28 <main+0x172>
     f1a:	82 30       	cpi	r24, 0x02	; 2
     f1c:	89 f0       	breq	.+34     	; 0xf40 <main+0x18a>
     f1e:	84 30       	cpi	r24, 0x04	; 4
     f20:	91 f0       	breq	.+36     	; 0xf46 <main+0x190>
     f22:	81 30       	cpi	r24, 0x01	; 1
     f24:	69 f5       	brne	.+90     	; 0xf80 <main+0x1ca>
     f26:	2b c0       	rjmp	.+86     	; 0xf7e <main+0x1c8>
     f28:	80 32       	cpi	r24, 0x20	; 32
     f2a:	d1 f0       	breq	.+52     	; 0xf60 <main+0x1aa>
     f2c:	81 32       	cpi	r24, 0x21	; 33
     f2e:	18 f4       	brcc	.+6      	; 0xf36 <main+0x180>
     f30:	80 31       	cpi	r24, 0x10	; 16
     f32:	31 f5       	brne	.+76     	; 0xf80 <main+0x1ca>
     f34:	11 c0       	rjmp	.+34     	; 0xf58 <main+0x1a2>
     f36:	80 34       	cpi	r24, 0x40	; 64
     f38:	c1 f0       	breq	.+48     	; 0xf6a <main+0x1b4>
     f3a:	80 38       	cpi	r24, 0x80	; 128
     f3c:	09 f5       	brne	.+66     	; 0xf80 <main+0x1ca>
     f3e:	1a c0       	rjmp	.+52     	; 0xf74 <main+0x1be>
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     f40:	44 24       	eor	r4, r4
     f42:	43 94       	inc	r4
							break;
     f44:	1d c0       	rjmp	.+58     	; 0xf80 <main+0x1ca>
						case 4:
							gain = GAIN_4_gc;
     f46:	44 24       	eor	r4, r4
     f48:	68 94       	set
     f4a:	41 f8       	bld	r4, 1
							break;
     f4c:	19 c0       	rjmp	.+50     	; 0xf80 <main+0x1ca>
						case 8:
							gain = GAIN_8_gc;
     f4e:	0f 2e       	mov	r0, r31
     f50:	f3 e0       	ldi	r31, 0x03	; 3
     f52:	4f 2e       	mov	r4, r31
     f54:	f0 2d       	mov	r31, r0
							break;
     f56:	14 c0       	rjmp	.+40     	; 0xf80 <main+0x1ca>
						case 16:
							gain = GAIN_16_gc;
     f58:	44 24       	eor	r4, r4
     f5a:	68 94       	set
     f5c:	42 f8       	bld	r4, 2
							break;
     f5e:	10 c0       	rjmp	.+32     	; 0xf80 <main+0x1ca>
						case 32:
							gain = GAIN_32_gc;
     f60:	0f 2e       	mov	r0, r31
     f62:	f5 e0       	ldi	r31, 0x05	; 5
     f64:	4f 2e       	mov	r4, r31
     f66:	f0 2d       	mov	r31, r0
							break;
     f68:	0b c0       	rjmp	.+22     	; 0xf80 <main+0x1ca>
						case 64:
							gain = GAIN_64_gc;
     f6a:	0f 2e       	mov	r0, r31
     f6c:	f6 e0       	ldi	r31, 0x06	; 6
     f6e:	4f 2e       	mov	r4, r31
     f70:	f0 2d       	mov	r31, r0
							break;
     f72:	06 c0       	rjmp	.+12     	; 0xf80 <main+0x1ca>
						case 128:
							gain = GAIN_128_gc;
     f74:	0f 2e       	mov	r0, r31
     f76:	f7 e0       	ldi	r31, 0x07	; 7
     f78:	4f 2e       	mov	r4, r31
     f7a:	f0 2d       	mov	r31, r0
							break;
     f7c:	01 c0       	rjmp	.+2      	; 0xf80 <main+0x1ca>
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
					switch(RawGain){
						case 1:
							gain = GAIN_1_gc;
     f7e:	44 24       	eor	r4, r4
						default:
							//chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
							break;
					}
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
     f80:	d3 01       	movw	r26, r6
     f82:	14 96       	adiw	r26, 0x04	; 4
     f84:	8d 91       	ld	r24, X+
     f86:	9c 91       	ld	r25, X
     f88:	15 97       	sbiw	r26, 0x05	; 5
     f8a:	bf ef       	ldi	r27, 0xFF	; 255
     f8c:	8f 3f       	cpi	r24, 0xFF	; 255
     f8e:	9b 07       	cpc	r25, r27
     f90:	09 f4       	brne	.+2      	; 0xf94 <main+0x1de>
     f92:	4e cf       	rjmp	.-356    	; 0xe30 <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
     f94:	80 e0       	ldi	r24, 0x00	; 0
     f96:	90 e0       	ldi	r25, 0x00	; 0
     f98:	be 01       	movw	r22, r28
     f9a:	6f 5f       	subi	r22, 0xFF	; 255
     f9c:	7f 4f       	sbci	r23, 0xFF	; 255
     f9e:	22 e0       	ldi	r18, 0x02	; 2
     fa0:	30 e0       	ldi	r19, 0x00	; 0
     fa2:	40 e0       	ldi	r20, 0x00	; 0
     fa4:	50 e0       	ldi	r21, 0x00	; 0
     fa6:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
     faa:	42 cf       	rjmp	.-380    	; 0xe30 <main+0x7a>
				case 'F':

					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set sampling frequency to what is specified
					freq = (uint16_t)(*(int32_t*)(RadioMessageBuffer+1));
     fac:	29 84       	ldd	r2, Y+9	; 0x09
     fae:	3a 84       	ldd	r3, Y+10	; 0x0a
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
     fb0:	f3 01       	movw	r30, r6
     fb2:	84 81       	ldd	r24, Z+4	; 0x04
     fb4:	95 81       	ldd	r25, Z+5	; 0x05
     fb6:	ff ef       	ldi	r31, 0xFF	; 255
     fb8:	8f 3f       	cpi	r24, 0xFF	; 255
     fba:	9f 07       	cpc	r25, r31
     fbc:	09 f4       	brne	.+2      	; 0xfc0 <main+0x20a>
     fbe:	38 cf       	rjmp	.-400    	; 0xe30 <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
     fc0:	80 e0       	ldi	r24, 0x00	; 0
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	be 01       	movw	r22, r28
     fc6:	6f 5f       	subi	r22, 0xFF	; 255
     fc8:	7f 4f       	sbci	r23, 0xFF	; 255
     fca:	22 e0       	ldi	r18, 0x02	; 2
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	40 e0       	ldi	r20, 0x00	; 0
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
     fd6:	2c cf       	rjmp	.-424    	; 0xe30 <main+0x7a>
					}
					break;
					
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     fd8:	80 91 ab 50 	lds	r24, 0x50AB
     fdc:	88 23       	and	r24, r24
     fde:	11 f4       	brne	.+4      	; 0xfe4 <main+0x22e>
						ADC_Stop_Sampling();
     fe0:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <ADC_Stop_Sampling>
					}
					//otherwise, the ADC has finished sampling on its own and the data is ready to be transmitted
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
     fe4:	d3 01       	movw	r26, r6
     fe6:	14 96       	adiw	r26, 0x04	; 4
     fe8:	8d 91       	ld	r24, X+
     fea:	9c 91       	ld	r25, X
     fec:	15 97       	sbiw	r26, 0x05	; 5
     fee:	bf ef       	ldi	r27, 0xFF	; 255
     ff0:	8f 3f       	cpi	r24, 0xFF	; 255
     ff2:	9b 07       	cpc	r25, r27
     ff4:	09 f4       	brne	.+2      	; 0xff8 <main+0x242>
     ff6:	1c cf       	rjmp	.-456    	; 0xe30 <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
     ff8:	80 e0       	ldi	r24, 0x00	; 0
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	be 01       	movw	r22, r28
     ffe:	6f 5f       	subi	r22, 0xFF	; 255
    1000:	7f 4f       	sbci	r23, 0xFF	; 255
    1002:	22 e0       	ldi	r18, 0x02	; 2
    1004:	30 e0       	ldi	r19, 0x00	; 0
    1006:	40 e0       	ldi	r20, 0x00	; 0
    1008:	50 e0       	ldi	r21, 0x00	; 0
    100a:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
    100e:	10 cf       	rjmp	.-480    	; 0xe30 <main+0x7a>
					}
					break;
					
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable && pcb->destination_addr != 0xFFFF){
    1010:	80 91 ab 50 	lds	r24, 0x50AB
    1014:	88 23       	and	r24, r24
    1016:	09 f4       	brne	.+2      	; 0x101a <main+0x264>
    1018:	0b cf       	rjmp	.-490    	; 0xe30 <main+0x7a>
    101a:	80 91 4c 3e 	lds	r24, 0x3E4C
    101e:	88 23       	and	r24, r24
    1020:	09 f4       	brne	.+2      	; 0x1024 <main+0x26e>
    1022:	06 cf       	rjmp	.-500    	; 0xe30 <main+0x7a>
    1024:	f3 01       	movw	r30, r6
    1026:	84 81       	ldd	r24, Z+4	; 0x04
    1028:	95 81       	ldd	r25, Z+5	; 0x05
    102a:	ff ef       	ldi	r31, 0xFF	; 255
    102c:	8f 3f       	cpi	r24, 0xFF	; 255
    102e:	9f 07       	cpc	r25, r31
    1030:	09 f4       	brne	.+2      	; 0x1034 <main+0x27e>
    1032:	fe ce       	rjmp	.-516    	; 0xe30 <main+0x7a>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
    1034:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <ADC_Get_Num_Samples>
    1038:	a0 e0       	ldi	r26, 0x00	; 0
    103a:	b0 e0       	ldi	r27, 0x00	; 0
    103c:	8c 83       	std	Y+4, r24	; 0x04
    103e:	9d 83       	std	Y+5, r25	; 0x05
    1040:	ae 83       	std	Y+6, r26	; 0x06
    1042:	bf 83       	std	Y+7, r27	; 0x07
						if(samples > 0){	
    1044:	8c 81       	ldd	r24, Y+4	; 0x04
    1046:	9d 81       	ldd	r25, Y+5	; 0x05
    1048:	ae 81       	ldd	r26, Y+6	; 0x06
    104a:	bf 81       	ldd	r27, Y+7	; 0x07
    104c:	00 97       	sbiw	r24, 0x00	; 0
    104e:	a1 05       	cpc	r26, r1
    1050:	b1 05       	cpc	r27, r1
    1052:	09 f4       	brne	.+2      	; 0x1056 <main+0x2a0>
    1054:	21 c1       	rjmp	.+578    	; 0x1298 <main+0x4e2>
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
    1056:	8c 81       	ldd	r24, Y+4	; 0x04
    1058:	9d 81       	ldd	r25, Y+5	; 0x05
    105a:	ae 81       	ldd	r26, Y+6	; 0x06
    105c:	bf 81       	ldd	r27, Y+7	; 0x07
    105e:	bc 01       	movw	r22, r24
    1060:	cd 01       	movw	r24, r26
    1062:	66 0f       	add	r22, r22
    1064:	77 1f       	adc	r23, r23
    1066:	88 1f       	adc	r24, r24
    1068:	99 1f       	adc	r25, r25
    106a:	66 0f       	add	r22, r22
    106c:	77 1f       	adc	r23, r23
    106e:	88 1f       	adc	r24, r24
    1070:	99 1f       	adc	r25, r25
    1072:	0f 2e       	mov	r0, r31
    1074:	f4 e6       	ldi	r31, 0x64	; 100
    1076:	cf 2e       	mov	r12, r31
    1078:	f0 e0       	ldi	r31, 0x00	; 0
    107a:	df 2e       	mov	r13, r31
    107c:	f0 e0       	ldi	r31, 0x00	; 0
    107e:	ef 2e       	mov	r14, r31
    1080:	f0 e0       	ldi	r31, 0x00	; 0
    1082:	ff 2e       	mov	r15, r31
    1084:	f0 2d       	mov	r31, r0
    1086:	a7 01       	movw	r20, r14
    1088:	96 01       	movw	r18, r12
    108a:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    108e:	59 01       	movw	r10, r18
    1090:	2c 8f       	std	Y+28, r18	; 0x1c
    1092:	3d 8f       	std	Y+29, r19	; 0x1d
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
    1094:	8c 81       	ldd	r24, Y+4	; 0x04
    1096:	9d 81       	ldd	r25, Y+5	; 0x05
    1098:	ae 81       	ldd	r26, Y+6	; 0x06
    109a:	bf 81       	ldd	r27, Y+7	; 0x07
    109c:	bc 01       	movw	r22, r24
    109e:	cd 01       	movw	r24, r26
    10a0:	66 0f       	add	r22, r22
    10a2:	77 1f       	adc	r23, r23
    10a4:	88 1f       	adc	r24, r24
    10a6:	99 1f       	adc	r25, r25
    10a8:	66 0f       	add	r22, r22
    10aa:	77 1f       	adc	r23, r23
    10ac:	88 1f       	adc	r24, r24
    10ae:	99 1f       	adc	r25, r25
    10b0:	a7 01       	movw	r20, r14
    10b2:	96 01       	movw	r18, r12
    10b4:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    10b8:	dc 01       	movw	r26, r24
    10ba:	cb 01       	movw	r24, r22
    10bc:	00 97       	sbiw	r24, 0x00	; 0
    10be:	a1 05       	cpc	r26, r1
    10c0:	b1 05       	cpc	r27, r1
    10c2:	21 f0       	breq	.+8      	; 0x10cc <main+0x316>
    10c4:	c5 01       	movw	r24, r10
    10c6:	01 96       	adiw	r24, 0x01	; 1
    10c8:	8c 8f       	std	Y+28, r24	; 0x1c
    10ca:	9d 8f       	std	Y+29, r25	; 0x1d
							//start timeout timer
							TCE0.CTRLA = 0x07;
    10cc:	87 e0       	ldi	r24, 0x07	; 7
    10ce:	a0 e0       	ldi	r26, 0x00	; 0
    10d0:	ba e0       	ldi	r27, 0x0A	; 10
    10d2:	8c 93       	st	X, r24
							TimedOut = 0;
    10d4:	10 92 0e 21 	sts	0x210E, r1
							//send the number of messages the base station should expect after this message
							while(chb_write(0x0000,(uint8_t*)(&NumMessages),2) != CHB_SUCCESS){
    10d8:	04 c0       	rjmp	.+8      	; 0x10e2 <main+0x32c>
								if(TimedOut) break;
    10da:	80 91 0e 21 	lds	r24, 0x210E
    10de:	88 23       	and	r24, r24
    10e0:	69 f4       	brne	.+26     	; 0x10fc <main+0x346>
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
							//start timeout timer
							TCE0.CTRLA = 0x07;
							TimedOut = 0;
							//send the number of messages the base station should expect after this message
							while(chb_write(0x0000,(uint8_t*)(&NumMessages),2) != CHB_SUCCESS){
    10e2:	80 e0       	ldi	r24, 0x00	; 0
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	be 01       	movw	r22, r28
    10e8:	64 5e       	subi	r22, 0xE4	; 228
    10ea:	7f 4f       	sbci	r23, 0xFF	; 255
    10ec:	22 e0       	ldi	r18, 0x02	; 2
    10ee:	30 e0       	ldi	r19, 0x00	; 0
    10f0:	40 e0       	ldi	r20, 0x00	; 0
    10f2:	50 e0       	ldi	r21, 0x00	; 0
    10f4:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
    10f8:	88 23       	and	r24, r24
    10fa:	79 f7       	brne	.-34     	; 0x10da <main+0x324>
								if(TimedOut) break;
							}
							if(TimedOut){
    10fc:	80 91 0e 21 	lds	r24, 0x210E
    1100:	88 23       	and	r24, r24
    1102:	31 f0       	breq	.+12     	; 0x1110 <main+0x35a>
								//stop timeout counter and go back to waiting for command
								TimedOut = 0;
    1104:	10 92 0e 21 	sts	0x210E, r1
								TCE0.CTRLA = 0;
    1108:	e0 e0       	ldi	r30, 0x00	; 0
    110a:	fa e0       	ldi	r31, 0x0A	; 10
    110c:	10 82       	st	Z, r1
								break;
    110e:	90 ce       	rjmp	.-736    	; 0xe30 <main+0x7a>
							}
							//reset timeout timer
							TimedOut = 0;
    1110:	10 92 0e 21 	sts	0x210E, r1
							TCE0.CTRLFSET = 0x08;  
    1114:	f8 e0       	ldi	r31, 0x08	; 8
    1116:	f0 93 09 0a 	sts	0x0A09, r31
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    111a:	8c 81       	ldd	r24, Y+4	; 0x04
    111c:	9d 81       	ldd	r25, Y+5	; 0x05
    111e:	ae 81       	ldd	r26, Y+6	; 0x06
    1120:	bf 81       	ldd	r27, Y+7	; 0x07
    1122:	88 0f       	add	r24, r24
    1124:	99 1f       	adc	r25, r25
    1126:	aa 1f       	adc	r26, r26
    1128:	bb 1f       	adc	r27, r27
    112a:	88 0f       	add	r24, r24
    112c:	99 1f       	adc	r25, r25
    112e:	aa 1f       	adc	r26, r26
    1130:	bb 1f       	adc	r27, r27
    1132:	00 97       	sbiw	r24, 0x00	; 0
    1134:	a1 05       	cpc	r26, r1
    1136:	b1 05       	cpc	r27, r1
    1138:	09 f4       	brne	.+2      	; 0x113c <main+0x386>
    113a:	ae c0       	rjmp	.+348    	; 0x1298 <main+0x4e2>
    113c:	cc 24       	eor	r12, r12
    113e:	dd 24       	eor	r13, r13
    1140:	76 01       	movw	r14, r12
    1142:	aa 24       	eor	r10, r10
    1144:	bb 24       	eor	r11, r11
								if(samples*4 - i >= 100){
    1146:	8c 81       	ldd	r24, Y+4	; 0x04
    1148:	9d 81       	ldd	r25, Y+5	; 0x05
    114a:	ae 81       	ldd	r26, Y+6	; 0x06
    114c:	bf 81       	ldd	r27, Y+7	; 0x07
    114e:	88 0f       	add	r24, r24
    1150:	99 1f       	adc	r25, r25
    1152:	aa 1f       	adc	r26, r26
    1154:	bb 1f       	adc	r27, r27
    1156:	88 0f       	add	r24, r24
    1158:	99 1f       	adc	r25, r25
    115a:	aa 1f       	adc	r26, r26
    115c:	bb 1f       	adc	r27, r27
    115e:	8c 19       	sub	r24, r12
    1160:	9d 09       	sbc	r25, r13
    1162:	ae 09       	sbc	r26, r14
    1164:	bf 09       	sbc	r27, r15
    1166:	84 36       	cpi	r24, 0x64	; 100
    1168:	91 05       	cpc	r25, r1
    116a:	a1 05       	cpc	r26, r1
    116c:	b1 05       	cpc	r27, r1
    116e:	28 f1       	brcs	.+74     	; 0x11ba <main+0x404>
									readFRAM(100,(FRAMAddress-(samples*4))+i);						
    1170:	60 91 22 3e 	lds	r22, 0x3E22
    1174:	70 91 23 3e 	lds	r23, 0x3E23
    1178:	8c 81       	ldd	r24, Y+4	; 0x04
    117a:	9d 81       	ldd	r25, Y+5	; 0x05
    117c:	ae 81       	ldd	r26, Y+6	; 0x06
    117e:	bf 81       	ldd	r27, Y+7	; 0x07
    1180:	88 0f       	add	r24, r24
    1182:	99 1f       	adc	r25, r25
    1184:	88 0f       	add	r24, r24
    1186:	99 1f       	adc	r25, r25
    1188:	68 1b       	sub	r22, r24
    118a:	79 0b       	sbc	r23, r25
    118c:	6a 0d       	add	r22, r10
    118e:	7b 1d       	adc	r23, r11
    1190:	84 e6       	ldi	r24, 0x64	; 100
    1192:	90 e0       	ldi	r25, 0x00	; 0
    1194:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									while(chb_write(0x0000,FRAMReadBuffer,100) != CHB_SUCCESS);
    1198:	80 e0       	ldi	r24, 0x00	; 0
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	61 2f       	mov	r22, r17
    119e:	75 2d       	mov	r23, r5
    11a0:	24 e6       	ldi	r18, 0x64	; 100
    11a2:	30 e0       	ldi	r19, 0x00	; 0
    11a4:	40 e0       	ldi	r20, 0x00	; 0
    11a6:	50 e0       	ldi	r21, 0x00	; 0
    11a8:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
    11ac:	88 23       	and	r24, r24
    11ae:	a1 f7       	brne	.-24     	; 0x1198 <main+0x3e2>
									i += 100;
    11b0:	84 e6       	ldi	r24, 0x64	; 100
    11b2:	90 e0       	ldi	r25, 0x00	; 0
    11b4:	a8 0e       	add	r10, r24
    11b6:	b9 1e       	adc	r11, r25
    11b8:	43 c0       	rjmp	.+134    	; 0x1240 <main+0x48a>
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
    11ba:	8c 81       	ldd	r24, Y+4	; 0x04
    11bc:	9d 81       	ldd	r25, Y+5	; 0x05
    11be:	ae 81       	ldd	r26, Y+6	; 0x06
    11c0:	bf 81       	ldd	r27, Y+7	; 0x07
    11c2:	e0 91 22 3e 	lds	r30, 0x3E22
    11c6:	f0 91 23 3e 	lds	r31, 0x3E23
    11ca:	4c 81       	ldd	r20, Y+4	; 0x04
    11cc:	5d 81       	ldd	r21, Y+5	; 0x05
    11ce:	6e 81       	ldd	r22, Y+6	; 0x06
    11d0:	7f 81       	ldd	r23, Y+7	; 0x07
    11d2:	9c 01       	movw	r18, r24
    11d4:	22 0f       	add	r18, r18
    11d6:	33 1f       	adc	r19, r19
    11d8:	22 0f       	add	r18, r18
    11da:	33 1f       	adc	r19, r19
    11dc:	ca 01       	movw	r24, r20
    11de:	88 0f       	add	r24, r24
    11e0:	99 1f       	adc	r25, r25
    11e2:	88 0f       	add	r24, r24
    11e4:	99 1f       	adc	r25, r25
    11e6:	bf 01       	movw	r22, r30
    11e8:	68 1b       	sub	r22, r24
    11ea:	79 0b       	sbc	r23, r25
    11ec:	6a 0d       	add	r22, r10
    11ee:	7b 1d       	adc	r23, r11
    11f0:	c9 01       	movw	r24, r18
    11f2:	8a 19       	sub	r24, r10
    11f4:	9b 09       	sbc	r25, r11
    11f6:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									while(chb_write(0x0000,FRAMReadBuffer,samples*4 - i) != CHB_SUCCESS);
    11fa:	8c 81       	ldd	r24, Y+4	; 0x04
    11fc:	9d 81       	ldd	r25, Y+5	; 0x05
    11fe:	ae 81       	ldd	r26, Y+6	; 0x06
    1200:	bf 81       	ldd	r27, Y+7	; 0x07
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	aa 1f       	adc	r26, r26
    1208:	bb 1f       	adc	r27, r27
    120a:	88 0f       	add	r24, r24
    120c:	99 1f       	adc	r25, r25
    120e:	aa 1f       	adc	r26, r26
    1210:	bb 1f       	adc	r27, r27
    1212:	9c 01       	movw	r18, r24
    1214:	ad 01       	movw	r20, r26
    1216:	2c 19       	sub	r18, r12
    1218:	3d 09       	sbc	r19, r13
    121a:	4e 09       	sbc	r20, r14
    121c:	5f 09       	sbc	r21, r15
    121e:	80 e0       	ldi	r24, 0x00	; 0
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	61 2f       	mov	r22, r17
    1224:	75 2d       	mov	r23, r5
    1226:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
    122a:	88 23       	and	r24, r24
    122c:	31 f7       	brne	.-52     	; 0x11fa <main+0x444>
									i += samples*4 - i;
    122e:	8c 81       	ldd	r24, Y+4	; 0x04
    1230:	9d 81       	ldd	r25, Y+5	; 0x05
    1232:	ae 81       	ldd	r26, Y+6	; 0x06
    1234:	bf 81       	ldd	r27, Y+7	; 0x07
    1236:	5c 01       	movw	r10, r24
    1238:	aa 0c       	add	r10, r10
    123a:	bb 1c       	adc	r11, r11
    123c:	aa 0c       	add	r10, r10
    123e:	bb 1c       	adc	r11, r11
								}
								//reset timeout timer
								TimedOut = 0;
    1240:	10 92 0e 21 	sts	0x210E, r1
								TCE0.CTRLFSET = 0x08;
    1244:	98 e0       	ldi	r25, 0x08	; 8
    1246:	90 93 09 0a 	sts	0x0A09, r25
    124a:	f3 01       	movw	r30, r6
								while(!pcb->data_rcv){
    124c:	04 c0       	rjmp	.+8      	; 0x1256 <main+0x4a0>
									//break if timed out waiting for response
									if(TimedOut) break;
    124e:	80 91 0e 21 	lds	r24, 0x210E
    1252:	88 23       	and	r24, r24
    1254:	19 f4       	brne	.+6      	; 0x125c <main+0x4a6>
									i += samples*4 - i;
								}
								//reset timeout timer
								TimedOut = 0;
								TCE0.CTRLFSET = 0x08;
								while(!pcb->data_rcv){
    1256:	87 81       	ldd	r24, Z+7	; 0x07
    1258:	88 23       	and	r24, r24
    125a:	c9 f3       	breq	.-14     	; 0x124e <main+0x498>
    125c:	3f 01       	movw	r6, r30
									//break if timed out waiting for response
									if(TimedOut) break;
								}
								if(TimedOut) break;		
    125e:	80 91 0e 21 	lds	r24, 0x210E
    1262:	88 23       	and	r24, r24
    1264:	c9 f4       	brne	.+50     	; 0x1298 <main+0x4e2>
								length = chb_read((chb_rx_data_t*)RadioMessageBuffer);							
    1266:	ce 01       	movw	r24, r28
    1268:	08 96       	adiw	r24, 0x08	; 8
    126a:	0e 94 03 1b 	call	0x3606	; 0x3606 <chb_read>
							}
							//reset timeout timer
							TimedOut = 0;
							TCE0.CTRLFSET = 0x08;  
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    126e:	65 01       	movw	r12, r10
    1270:	ee 24       	eor	r14, r14
    1272:	ff 24       	eor	r15, r15
    1274:	8c 81       	ldd	r24, Y+4	; 0x04
    1276:	9d 81       	ldd	r25, Y+5	; 0x05
    1278:	ae 81       	ldd	r26, Y+6	; 0x06
    127a:	bf 81       	ldd	r27, Y+7	; 0x07
    127c:	88 0f       	add	r24, r24
    127e:	99 1f       	adc	r25, r25
    1280:	aa 1f       	adc	r26, r26
    1282:	bb 1f       	adc	r27, r27
    1284:	88 0f       	add	r24, r24
    1286:	99 1f       	adc	r25, r25
    1288:	aa 1f       	adc	r26, r26
    128a:	bb 1f       	adc	r27, r27
    128c:	c8 16       	cp	r12, r24
    128e:	d9 06       	cpc	r13, r25
    1290:	ea 06       	cpc	r14, r26
    1292:	fb 06       	cpc	r15, r27
    1294:	08 f4       	brcc	.+2      	; 0x1298 <main+0x4e2>
    1296:	57 cf       	rjmp	.-338    	; 0x1146 <main+0x390>
							}
							//chb_write(0x0000,FRAMReadBuffer,samples*4);								
							//write the data to SD card for good measure (make sure transmitted and collected data is the same)	
							//writeFile(ofile, FRAMReadBuffer, samples*4);			
						}
						if(TimedOut){
    1298:	80 91 0e 21 	lds	r24, 0x210E
    129c:	88 23       	and	r24, r24
    129e:	31 f0       	breq	.+12     	; 0x12ac <main+0x4f6>
							//stop timeout counter and go back to waiting for command
							TimedOut = 0;
    12a0:	10 92 0e 21 	sts	0x210E, r1
							TCE0.CTRLA = 0; 
    12a4:	a0 e0       	ldi	r26, 0x00	; 0
    12a6:	ba e0       	ldi	r27, 0x0A	; 10
    12a8:	1c 92       	st	X, r1
							break;
    12aa:	c2 cd       	rjmp	.-1148   	; 0xe30 <main+0x7a>
						}														
						DataAvailable = 0;
    12ac:	10 92 4c 3e 	sts	0x3E4C, r1
    12b0:	bf cd       	rjmp	.-1154   	; 0xe30 <main+0x7a>

000012b2 <__vector_47>:
			}					
		}		
	}	
}

ISR(TCE0_OVF_vect){
    12b2:	1f 92       	push	r1
    12b4:	0f 92       	push	r0
    12b6:	0f b6       	in	r0, 0x3f	; 63
    12b8:	0f 92       	push	r0
    12ba:	11 24       	eor	r1, r1
    12bc:	8f 93       	push	r24
	TimedOut = 1;
    12be:	81 e0       	ldi	r24, 0x01	; 1
    12c0:	80 93 0e 21 	sts	0x210E, r24
    12c4:	8f 91       	pop	r24
    12c6:	0f 90       	pop	r0
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	0f 90       	pop	r0
    12cc:	1f 90       	pop	r1
    12ce:	18 95       	reti

000012d0 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
    12d0:	0f 93       	push	r16
    12d2:	1f 93       	push	r17
    12d4:	cf 93       	push	r28
    12d6:	8c 01       	movw	r16, r24
	moteID = 1;
    12d8:	c1 e0       	ldi	r28, 0x01	; 1
    12da:	c0 93 4a 3e 	sts	0x3E4A, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
    12de:	83 e0       	ldi	r24, 0x03	; 3
    12e0:	80 93 24 3e 	sts	0x3E24, r24
	chb_init();
    12e4:	0e 94 31 1a 	call	0x3462	; 0x3462 <chb_init>
	chb_set_short_addr(moteID);
    12e8:	80 91 4a 3e 	lds	r24, 0x3E4A
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
    12f2:	88 ec       	ldi	r24, 0xC8	; 200
    12f4:	e0 e8       	ldi	r30, 0x80	; 128
    12f6:	f1 e0       	ldi	r31, 0x01	; 1
    12f8:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
    12fa:	e0 e4       	ldi	r30, 0x40	; 64
    12fc:	f9 e0       	ldi	r31, 0x09	; 9
    12fe:	89 e0       	ldi	r24, 0x09	; 9
    1300:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
    1302:	82 e0       	ldi	r24, 0x02	; 2
    1304:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
    1306:	24 ef       	ldi	r18, 0xF4	; 244
    1308:	31 e0       	ldi	r19, 0x01	; 1
    130a:	02 9f       	mul	r16, r18
    130c:	c0 01       	movw	r24, r0
    130e:	03 9f       	mul	r16, r19
    1310:	90 0d       	add	r25, r0
    1312:	12 9f       	mul	r17, r18
    1314:	90 0d       	add	r25, r0
    1316:	11 24       	eor	r1, r1
    1318:	86 a3       	lds	r24, 0x56
    131a:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
    131c:	e0 e4       	ldi	r30, 0x40	; 64
    131e:	f8 e0       	ldi	r31, 0x08	; 8
    1320:	80 e0       	ldi	r24, 0x00	; 0
    1322:	9a ef       	ldi	r25, 0xFA	; 250
    1324:	86 a3       	lds	r24, 0x56
    1326:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
    1328:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
    132a:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
    132c:	e0 ea       	ldi	r30, 0xA0	; 160
    132e:	f0 e0       	ldi	r31, 0x00	; 0
    1330:	82 81       	ldd	r24, Z+2	; 0x02
    1332:	87 60       	ori	r24, 0x07	; 7
    1334:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
    1336:	78 94       	sei
}
    1338:	cf 91       	pop	r28
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	08 95       	ret

00001340 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
    1340:	78 94       	sei
    1342:	1f 92       	push	r1
    1344:	0f 92       	push	r0
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	0f 92       	push	r0
    134a:	0b b6       	in	r0, 0x3b	; 59
    134c:	0f 92       	push	r0
    134e:	11 24       	eor	r1, r1
    1350:	ef 92       	push	r14
    1352:	ff 92       	push	r15
    1354:	0f 93       	push	r16
    1356:	1f 93       	push	r17
    1358:	2f 93       	push	r18
    135a:	3f 93       	push	r19
    135c:	4f 93       	push	r20
    135e:	5f 93       	push	r21
    1360:	6f 93       	push	r22
    1362:	7f 93       	push	r23
    1364:	8f 93       	push	r24
    1366:	9f 93       	push	r25
    1368:	af 93       	push	r26
    136a:	bf 93       	push	r27
    136c:	ef 93       	push	r30
    136e:	ff 93       	push	r31
    1370:	cf 93       	push	r28
    1372:	df 93       	push	r29
    1374:	cd b7       	in	r28, 0x3d	; 61
    1376:	de b7       	in	r29, 0x3e	; 62
    1378:	28 97       	sbiw	r28, 0x08	; 8
    137a:	cd bf       	out	0x3d, r28	; 61
    137c:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    137e:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    1382:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    1386:	82 e0       	ldi	r24, 0x02	; 2
    1388:	80 93 24 3e 	sts	0x3E24, r24
	char message[8];
	strcpy(message,"reset");
    138c:	de 01       	movw	r26, r28
    138e:	11 96       	adiw	r26, 0x01	; 1
    1390:	e4 e0       	ldi	r30, 0x04	; 4
    1392:	f0 e2       	ldi	r31, 0x20	; 32
    1394:	86 e0       	ldi	r24, 0x06	; 6
    1396:	01 90       	ld	r0, Z+
    1398:	0d 92       	st	X+, r0
    139a:	81 50       	subi	r24, 0x01	; 1
    139c:	e1 f7       	brne	.-8      	; 0x1396 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    139e:	0e ea       	ldi	r16, 0xAE	; 174
    13a0:	10 e5       	ldi	r17, 0x50	; 80
    13a2:	80 91 4a 3e 	lds	r24, 0x3E4A
    13a6:	90 e0       	ldi	r25, 0x00	; 0
    13a8:	b8 01       	movw	r22, r16
    13aa:	4a e0       	ldi	r20, 0x0A	; 10
    13ac:	50 e0       	ldi	r21, 0x00	; 0
    13ae:	0e 94 34 3a 	call	0x7468	; 0x7468 <itoa>
	strcat(message,buff);
    13b2:	7e 01       	movw	r14, r28
    13b4:	08 94       	sec
    13b6:	e1 1c       	adc	r14, r1
    13b8:	f1 1c       	adc	r15, r1
    13ba:	c7 01       	movw	r24, r14
    13bc:	b8 01       	movw	r22, r16
    13be:	0e 94 29 3a 	call	0x7452	; 0x7452 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    13c2:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    13c6:	f7 01       	movw	r30, r14
    13c8:	01 90       	ld	r0, Z+
    13ca:	00 20       	and	r0, r0
    13cc:	e9 f7       	brne	.-6      	; 0x13c8 <__vector_83+0x88>
    13ce:	31 97       	sbiw	r30, 0x01	; 1
    13d0:	ee 19       	sub	r30, r14
    13d2:	ff 09       	sbc	r31, r15
    13d4:	9f 01       	movw	r18, r30
    13d6:	40 e0       	ldi	r20, 0x00	; 0
    13d8:	50 e0       	ldi	r21, 0x00	; 0
    13da:	80 e0       	ldi	r24, 0x00	; 0
    13dc:	90 e0       	ldi	r25, 0x00	; 0
    13de:	b7 01       	movw	r22, r14
    13e0:	0e 94 55 1a 	call	0x34aa	; 0x34aa <chb_write>
}	
    13e4:	28 96       	adiw	r28, 0x08	; 8
    13e6:	cd bf       	out	0x3d, r28	; 61
    13e8:	de bf       	out	0x3e, r29	; 62
    13ea:	df 91       	pop	r29
    13ec:	cf 91       	pop	r28
    13ee:	ff 91       	pop	r31
    13f0:	ef 91       	pop	r30
    13f2:	bf 91       	pop	r27
    13f4:	af 91       	pop	r26
    13f6:	9f 91       	pop	r25
    13f8:	8f 91       	pop	r24
    13fa:	7f 91       	pop	r23
    13fc:	6f 91       	pop	r22
    13fe:	5f 91       	pop	r21
    1400:	4f 91       	pop	r20
    1402:	3f 91       	pop	r19
    1404:	2f 91       	pop	r18
    1406:	1f 91       	pop	r17
    1408:	0f 91       	pop	r16
    140a:	ff 90       	pop	r15
    140c:	ef 90       	pop	r14
    140e:	0f 90       	pop	r0
    1410:	0b be       	out	0x3b, r0	; 59
    1412:	0f 90       	pop	r0
    1414:	0f be       	out	0x3f, r0	; 63
    1416:	0f 90       	pop	r0
    1418:	1f 90       	pop	r1
    141a:	18 95       	reti

0000141c <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    141c:	4f 92       	push	r4
    141e:	5f 92       	push	r5
    1420:	6f 92       	push	r6
    1422:	7f 92       	push	r7
    1424:	8f 92       	push	r8
    1426:	9f 92       	push	r9
    1428:	af 92       	push	r10
    142a:	bf 92       	push	r11
    142c:	ef 92       	push	r14
    142e:	ff 92       	push	r15
    1430:	0f 93       	push	r16
    1432:	1f 93       	push	r17
    1434:	cf 93       	push	r28
    1436:	df 93       	push	r29
    1438:	cd b7       	in	r28, 0x3d	; 61
    143a:	de b7       	in	r29, 0x3e	; 62
    143c:	2b 97       	sbiw	r28, 0x0b	; 11
    143e:	cd bf       	out	0x3d, r28	; 61
    1440:	de bf       	out	0x3e, r29	; 62
    1442:	8e 83       	std	Y+6, r24	; 0x06
    1444:	9f 83       	std	Y+7, r25	; 0x07
    1446:	68 87       	std	Y+8, r22	; 0x08
    1448:	79 87       	std	Y+9, r23	; 0x09
    144a:	4a 87       	std	Y+10, r20	; 0x0a
    144c:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    144e:	81 e0       	ldi	r24, 0x01	; 1
    1450:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    1454:	80 e0       	ldi	r24, 0x00	; 0
    1456:	92 e0       	ldi	r25, 0x02	; 2
    1458:	0e 94 14 1a 	call	0x3428	; 0x3428 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    145c:	00 e0       	ldi	r16, 0x00	; 0
    145e:	12 e0       	ldi	r17, 0x02	; 2
    1460:	d8 01       	movw	r26, r16
    1462:	11 96       	adiw	r26, 0x01	; 1
    1464:	8c 91       	ld	r24, X
    1466:	11 97       	sbiw	r26, 0x01	; 1
    1468:	89 7e       	andi	r24, 0xE9	; 233
    146a:	11 96       	adiw	r26, 0x01	; 1
    146c:	8c 93       	st	X, r24
    146e:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    1470:	14 96       	adiw	r26, 0x04	; 4
    1472:	8c 91       	ld	r24, X
    1474:	14 97       	sbiw	r26, 0x04	; 4
    1476:	88 7f       	andi	r24, 0xF8	; 248
    1478:	83 60       	ori	r24, 0x03	; 3
    147a:	14 96       	adiw	r26, 0x04	; 4
    147c:	8c 93       	st	X, r24
    147e:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    1480:	12 96       	adiw	r26, 0x02	; 2
    1482:	8c 91       	ld	r24, X
    1484:	12 97       	sbiw	r26, 0x02	; 2
    1486:	8f 7c       	andi	r24, 0xCF	; 207
    1488:	12 96       	adiw	r26, 0x02	; 2
    148a:	8c 93       	st	X, r24
    148c:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    148e:	0f 2e       	mov	r0, r31
    1490:	f0 e2       	ldi	r31, 0x20	; 32
    1492:	ef 2e       	mov	r14, r31
    1494:	f2 e0       	ldi	r31, 0x02	; 2
    1496:	ff 2e       	mov	r15, r31
    1498:	f0 2d       	mov	r31, r0
    149a:	f7 01       	movw	r30, r14
    149c:	80 81       	ld	r24, Z
    149e:	80 7e       	andi	r24, 0xE0	; 224
    14a0:	81 60       	ori	r24, 0x01	; 1
    14a2:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    14a4:	89 e0       	ldi	r24, 0x09	; 9
    14a6:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    14a8:	8c 91       	ld	r24, X
    14aa:	81 60       	ori	r24, 0x01	; 1
    14ac:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    14ae:	80 e0       	ldi	r24, 0x00	; 0
    14b0:	92 e0       	ldi	r25, 0x02	; 2
    14b2:	0e 94 99 19 	call	0x3332	; 0x3332 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    14b6:	80 e0       	ldi	r24, 0x00	; 0
    14b8:	92 e0       	ldi	r25, 0x02	; 2
    14ba:	60 e2       	ldi	r22, 0x20	; 32
    14bc:	72 e0       	ldi	r23, 0x02	; 2
    14be:	40 e0       	ldi	r20, 0x00	; 0
    14c0:	0e 94 a3 19 	call	0x3346	; 0x3346 <ADC_Offset_Get_Unsigned>
    14c4:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    14c6:	d8 01       	movw	r26, r16
    14c8:	8c 91       	ld	r24, X
    14ca:	8e 7f       	andi	r24, 0xFE	; 254
    14cc:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    14ce:	f7 01       	movw	r30, r14
    14d0:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    14d2:	13 96       	adiw	r26, 0x03	; 3
    14d4:	8c 91       	ld	r24, X
    14d6:	13 97       	sbiw	r26, 0x03	; 3
    14d8:	8f 73       	andi	r24, 0x3F	; 63
    14da:	13 96       	adiw	r26, 0x03	; 3
    14dc:	8c 93       	st	X, r24
    14de:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    14e0:	8c 91       	ld	r24, X
    14e2:	81 60       	ori	r24, 0x01	; 1
    14e4:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    14e6:	80 e0       	ldi	r24, 0x00	; 0
    14e8:	92 e0       	ldi	r25, 0x02	; 2
    14ea:	0e 94 99 19 	call	0x3332	; 0x3332 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    14ee:	d8 01       	movw	r26, r16
    14f0:	11 96       	adiw	r26, 0x01	; 1
    14f2:	8c 91       	ld	r24, X
    14f4:	11 97       	sbiw	r26, 0x01	; 1
    14f6:	88 60       	ori	r24, 0x08	; 8
    14f8:	11 96       	adiw	r26, 0x01	; 1
    14fa:	8c 93       	st	X, r24
    14fc:	ee 24       	eor	r14, r14
    14fe:	ff 24       	eor	r15, r15
    1500:	68 94       	set
    1502:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    1504:	44 24       	eor	r4, r4
    1506:	55 24       	eor	r5, r5
    1508:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    150a:	20 e0       	ldi	r18, 0x00	; 0
    150c:	30 e1       	ldi	r19, 0x10	; 16
    150e:	40 e0       	ldi	r20, 0x00	; 0
    1510:	50 e0       	ldi	r21, 0x00	; 0
    1512:	2a 83       	std	Y+2, r18	; 0x02
    1514:	3b 83       	std	Y+3, r19	; 0x03
    1516:	4c 83       	std	Y+4, r20	; 0x04
    1518:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    151a:	88 24       	eor	r8, r8
    151c:	99 24       	eor	r9, r9
    151e:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    1520:	00 e2       	ldi	r16, 0x20	; 32
    1522:	12 e0       	ldi	r17, 0x02	; 2
    1524:	d8 01       	movw	r26, r16
    1526:	13 96       	adiw	r26, 0x03	; 3
    1528:	8c 91       	ld	r24, X
    152a:	13 97       	sbiw	r26, 0x03	; 3
    152c:	80 ff       	sbrs	r24, 0
    152e:	fa cf       	rjmp	.-12     	; 0x1524 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    1530:	69 81       	ldd	r22, Y+1	; 0x01
    1532:	c8 01       	movw	r24, r16
    1534:	0e 94 75 19 	call	0x32ea	; 0x32ea <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    1538:	a0 e0       	ldi	r26, 0x00	; 0
    153a:	b0 e0       	ldi	r27, 0x00	; 0
    153c:	88 0e       	add	r8, r24
    153e:	99 1e       	adc	r9, r25
    1540:	aa 1e       	adc	r10, r26
    1542:	bb 1e       	adc	r11, r27
    1544:	48 16       	cp	r4, r24
    1546:	59 06       	cpc	r5, r25
    1548:	6a 06       	cpc	r6, r26
    154a:	7b 06       	cpc	r7, r27
    154c:	10 f4       	brcc	.+4      	; 0x1552 <CO_collectTemp+0x136>
    154e:	2c 01       	movw	r4, r24
    1550:	3d 01       	movw	r6, r26
    1552:	2a 81       	ldd	r18, Y+2	; 0x02
    1554:	3b 81       	ldd	r19, Y+3	; 0x03
    1556:	4c 81       	ldd	r20, Y+4	; 0x04
    1558:	5d 81       	ldd	r21, Y+5	; 0x05
    155a:	82 17       	cp	r24, r18
    155c:	93 07       	cpc	r25, r19
    155e:	a4 07       	cpc	r26, r20
    1560:	b5 07       	cpc	r27, r21
    1562:	20 f4       	brcc	.+8      	; 0x156c <CO_collectTemp+0x150>
    1564:	8a 83       	std	Y+2, r24	; 0x02
    1566:	9b 83       	std	Y+3, r25	; 0x03
    1568:	ac 83       	std	Y+4, r26	; 0x04
    156a:	bd 83       	std	Y+5, r27	; 0x05
    156c:	08 94       	sec
    156e:	e1 08       	sbc	r14, r1
    1570:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1572:	e1 14       	cp	r14, r1
    1574:	f1 04       	cpc	r15, r1
    1576:	b1 f6       	brne	.-84     	; 0x1524 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    1578:	e0 e0       	ldi	r30, 0x00	; 0
    157a:	f2 e0       	ldi	r31, 0x02	; 2
    157c:	81 81       	ldd	r24, Z+1	; 0x01
    157e:	87 7f       	andi	r24, 0xF7	; 247
    1580:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    1582:	80 81       	ld	r24, Z
    1584:	82 60       	ori	r24, 0x02	; 2
    1586:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    1588:	80 81       	ld	r24, Z
    158a:	8e 7f       	andi	r24, 0xFE	; 254
    158c:	80 83       	st	Z, r24

	ADCPower(FALSE);
    158e:	80 e0       	ldi	r24, 0x00	; 0
    1590:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	average = sum / NUM_SAMPLES;
    1594:	c5 01       	movw	r24, r10
    1596:	b4 01       	movw	r22, r8
    1598:	05 2e       	mov	r0, r21
    159a:	5a e0       	ldi	r21, 0x0A	; 10
    159c:	96 95       	lsr	r25
    159e:	87 95       	ror	r24
    15a0:	77 95       	ror	r23
    15a2:	67 95       	ror	r22
    15a4:	5a 95       	dec	r21
    15a6:	d1 f7       	brne	.-12     	; 0x159c <CO_collectTemp+0x180>
    15a8:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    15aa:	28 ee       	ldi	r18, 0xE8	; 232
    15ac:	33 e0       	ldi	r19, 0x03	; 3
    15ae:	40 e0       	ldi	r20, 0x00	; 0
    15b0:	50 e0       	ldi	r21, 0x00	; 0
    15b2:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    15b6:	0f 2e       	mov	r0, r31
    15b8:	ff ef       	ldi	r31, 0xFF	; 255
    15ba:	8f 2e       	mov	r8, r31
    15bc:	ff e0       	ldi	r31, 0x0F	; 15
    15be:	9f 2e       	mov	r9, r31
    15c0:	f0 e0       	ldi	r31, 0x00	; 0
    15c2:	af 2e       	mov	r10, r31
    15c4:	f0 e0       	ldi	r31, 0x00	; 0
    15c6:	bf 2e       	mov	r11, r31
    15c8:	f0 2d       	mov	r31, r0
    15ca:	a5 01       	movw	r20, r10
    15cc:	94 01       	movw	r18, r8
    15ce:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    15d2:	c9 01       	movw	r24, r18
    15d4:	c2 97       	sbiw	r24, 0x32	; 50
    15d6:	ae 81       	ldd	r26, Y+6	; 0x06
    15d8:	bf 81       	ldd	r27, Y+7	; 0x07
    15da:	8d 93       	st	X+, r24
    15dc:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    15de:	c3 01       	movw	r24, r6
    15e0:	b2 01       	movw	r22, r4
    15e2:	28 ee       	ldi	r18, 0xE8	; 232
    15e4:	33 e0       	ldi	r19, 0x03	; 3
    15e6:	40 e0       	ldi	r20, 0x00	; 0
    15e8:	50 e0       	ldi	r21, 0x00	; 0
    15ea:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    15ee:	a5 01       	movw	r20, r10
    15f0:	94 01       	movw	r18, r8
    15f2:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    15f6:	c9 01       	movw	r24, r18
    15f8:	c2 97       	sbiw	r24, 0x32	; 50
    15fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    15fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    15fe:	80 83       	st	Z, r24
    1600:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    1602:	6a 81       	ldd	r22, Y+2	; 0x02
    1604:	7b 81       	ldd	r23, Y+3	; 0x03
    1606:	8c 81       	ldd	r24, Y+4	; 0x04
    1608:	9d 81       	ldd	r25, Y+5	; 0x05
    160a:	28 ee       	ldi	r18, 0xE8	; 232
    160c:	33 e0       	ldi	r19, 0x03	; 3
    160e:	40 e0       	ldi	r20, 0x00	; 0
    1610:	50 e0       	ldi	r21, 0x00	; 0
    1612:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    1616:	a5 01       	movw	r20, r10
    1618:	94 01       	movw	r18, r8
    161a:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    161e:	22 53       	subi	r18, 0x32	; 50
    1620:	30 40       	sbci	r19, 0x00	; 0
    1622:	a8 85       	ldd	r26, Y+8	; 0x08
    1624:	b9 85       	ldd	r27, Y+9	; 0x09
    1626:	2d 93       	st	X+, r18
    1628:	3c 93       	st	X, r19
    162a:	11 97       	sbiw	r26, 0x01	; 1
}
    162c:	2b 96       	adiw	r28, 0x0b	; 11
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	de bf       	out	0x3e, r29	; 62
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	1f 91       	pop	r17
    1638:	0f 91       	pop	r16
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	bf 90       	pop	r11
    1640:	af 90       	pop	r10
    1642:	9f 90       	pop	r9
    1644:	8f 90       	pop	r8
    1646:	7f 90       	pop	r7
    1648:	6f 90       	pop	r6
    164a:	5f 90       	pop	r5
    164c:	4f 90       	pop	r4
    164e:	08 95       	ret

00001650 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    1650:	4f 92       	push	r4
    1652:	5f 92       	push	r5
    1654:	6f 92       	push	r6
    1656:	7f 92       	push	r7
    1658:	8f 92       	push	r8
    165a:	9f 92       	push	r9
    165c:	af 92       	push	r10
    165e:	bf 92       	push	r11
    1660:	ef 92       	push	r14
    1662:	ff 92       	push	r15
    1664:	0f 93       	push	r16
    1666:	1f 93       	push	r17
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	cd b7       	in	r28, 0x3d	; 61
    166e:	de b7       	in	r29, 0x3e	; 62
    1670:	2b 97       	sbiw	r28, 0x0b	; 11
    1672:	cd bf       	out	0x3d, r28	; 61
    1674:	de bf       	out	0x3e, r29	; 62
    1676:	8e 83       	std	Y+6, r24	; 0x06
    1678:	9f 83       	std	Y+7, r25	; 0x07
    167a:	68 87       	std	Y+8, r22	; 0x08
    167c:	79 87       	std	Y+9, r23	; 0x09
    167e:	4a 87       	std	Y+10, r20	; 0x0a
    1680:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    1688:	84 e0       	ldi	r24, 0x04	; 4
    168a:	60 e0       	ldi	r22, 0x00	; 0
    168c:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    1690:	84 e0       	ldi	r24, 0x04	; 4
    1692:	60 e0       	ldi	r22, 0x00	; 0
    1694:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    1698:	2f ef       	ldi	r18, 0xFF	; 255
    169a:	33 ec       	ldi	r19, 0xC3	; 195
    169c:	49 e0       	ldi	r20, 0x09	; 9
    169e:	21 50       	subi	r18, 0x01	; 1
    16a0:	30 40       	sbci	r19, 0x00	; 0
    16a2:	40 40       	sbci	r20, 0x00	; 0
    16a4:	e1 f7       	brne	.-8      	; 0x169e <CO_collectBatt+0x4e>
    16a6:	00 c0       	rjmp	.+0      	; 0x16a8 <CO_collectBatt+0x58>
    16a8:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    16aa:	80 e4       	ldi	r24, 0x40	; 64
    16ac:	92 e0       	ldi	r25, 0x02	; 2
    16ae:	0e 94 14 1a 	call	0x3428	; 0x3428 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    16b2:	00 e4       	ldi	r16, 0x40	; 64
    16b4:	12 e0       	ldi	r17, 0x02	; 2
    16b6:	d8 01       	movw	r26, r16
    16b8:	11 96       	adiw	r26, 0x01	; 1
    16ba:	8c 91       	ld	r24, X
    16bc:	11 97       	sbiw	r26, 0x01	; 1
    16be:	89 7e       	andi	r24, 0xE9	; 233
    16c0:	11 96       	adiw	r26, 0x01	; 1
    16c2:	8c 93       	st	X, r24
    16c4:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    16c6:	14 96       	adiw	r26, 0x04	; 4
    16c8:	8c 91       	ld	r24, X
    16ca:	14 97       	sbiw	r26, 0x04	; 4
    16cc:	88 7f       	andi	r24, 0xF8	; 248
    16ce:	83 60       	ori	r24, 0x03	; 3
    16d0:	14 96       	adiw	r26, 0x04	; 4
    16d2:	8c 93       	st	X, r24
    16d4:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    16d6:	12 96       	adiw	r26, 0x02	; 2
    16d8:	8c 91       	ld	r24, X
    16da:	12 97       	sbiw	r26, 0x02	; 2
    16dc:	8f 7c       	andi	r24, 0xCF	; 207
    16de:	12 96       	adiw	r26, 0x02	; 2
    16e0:	8c 93       	st	X, r24
    16e2:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    16e4:	0f 2e       	mov	r0, r31
    16e6:	f0 e6       	ldi	r31, 0x60	; 96
    16e8:	ef 2e       	mov	r14, r31
    16ea:	f2 e0       	ldi	r31, 0x02	; 2
    16ec:	ff 2e       	mov	r15, r31
    16ee:	f0 2d       	mov	r31, r0
    16f0:	f7 01       	movw	r30, r14
    16f2:	80 81       	ld	r24, Z
    16f4:	80 7e       	andi	r24, 0xE0	; 224
    16f6:	81 60       	ori	r24, 0x01	; 1
    16f8:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    16fa:	89 e0       	ldi	r24, 0x09	; 9
    16fc:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    16fe:	8c 91       	ld	r24, X
    1700:	81 60       	ori	r24, 0x01	; 1
    1702:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    1704:	80 e4       	ldi	r24, 0x40	; 64
    1706:	92 e0       	ldi	r25, 0x02	; 2
    1708:	0e 94 99 19 	call	0x3332	; 0x3332 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    170c:	80 e4       	ldi	r24, 0x40	; 64
    170e:	92 e0       	ldi	r25, 0x02	; 2
    1710:	60 e6       	ldi	r22, 0x60	; 96
    1712:	72 e0       	ldi	r23, 0x02	; 2
    1714:	40 e0       	ldi	r20, 0x00	; 0
    1716:	0e 94 a3 19 	call	0x3346	; 0x3346 <ADC_Offset_Get_Unsigned>
    171a:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    171c:	d8 01       	movw	r26, r16
    171e:	8c 91       	ld	r24, X
    1720:	8e 7f       	andi	r24, 0xFE	; 254
    1722:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1724:	f7 01       	movw	r30, r14
    1726:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    1728:	13 96       	adiw	r26, 0x03	; 3
    172a:	8c 91       	ld	r24, X
    172c:	13 97       	sbiw	r26, 0x03	; 3
    172e:	8f 73       	andi	r24, 0x3F	; 63
    1730:	13 96       	adiw	r26, 0x03	; 3
    1732:	8c 93       	st	X, r24
    1734:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    1736:	8c 91       	ld	r24, X
    1738:	81 60       	ori	r24, 0x01	; 1
    173a:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    173c:	80 e4       	ldi	r24, 0x40	; 64
    173e:	92 e0       	ldi	r25, 0x02	; 2
    1740:	0e 94 99 19 	call	0x3332	; 0x3332 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    1744:	d8 01       	movw	r26, r16
    1746:	11 96       	adiw	r26, 0x01	; 1
    1748:	8c 91       	ld	r24, X
    174a:	11 97       	sbiw	r26, 0x01	; 1
    174c:	88 60       	ori	r24, 0x08	; 8
    174e:	11 96       	adiw	r26, 0x01	; 1
    1750:	8c 93       	st	X, r24
    1752:	ee 24       	eor	r14, r14
    1754:	ff 24       	eor	r15, r15
    1756:	68 94       	set
    1758:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    175a:	44 24       	eor	r4, r4
    175c:	55 24       	eor	r5, r5
    175e:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    1760:	20 e0       	ldi	r18, 0x00	; 0
    1762:	30 e1       	ldi	r19, 0x10	; 16
    1764:	40 e0       	ldi	r20, 0x00	; 0
    1766:	50 e0       	ldi	r21, 0x00	; 0
    1768:	2a 83       	std	Y+2, r18	; 0x02
    176a:	3b 83       	std	Y+3, r19	; 0x03
    176c:	4c 83       	std	Y+4, r20	; 0x04
    176e:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    1770:	88 24       	eor	r8, r8
    1772:	99 24       	eor	r9, r9
    1774:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    1776:	00 e6       	ldi	r16, 0x60	; 96
    1778:	12 e0       	ldi	r17, 0x02	; 2
    177a:	d8 01       	movw	r26, r16
    177c:	13 96       	adiw	r26, 0x03	; 3
    177e:	8c 91       	ld	r24, X
    1780:	13 97       	sbiw	r26, 0x03	; 3
    1782:	80 ff       	sbrs	r24, 0
    1784:	fa cf       	rjmp	.-12     	; 0x177a <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    1786:	69 81       	ldd	r22, Y+1	; 0x01
    1788:	c8 01       	movw	r24, r16
    178a:	0e 94 75 19 	call	0x32ea	; 0x32ea <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    178e:	a0 e0       	ldi	r26, 0x00	; 0
    1790:	b0 e0       	ldi	r27, 0x00	; 0
    1792:	88 0e       	add	r8, r24
    1794:	99 1e       	adc	r9, r25
    1796:	aa 1e       	adc	r10, r26
    1798:	bb 1e       	adc	r11, r27
    179a:	48 16       	cp	r4, r24
    179c:	59 06       	cpc	r5, r25
    179e:	6a 06       	cpc	r6, r26
    17a0:	7b 06       	cpc	r7, r27
    17a2:	10 f4       	brcc	.+4      	; 0x17a8 <CO_collectBatt+0x158>
    17a4:	2c 01       	movw	r4, r24
    17a6:	3d 01       	movw	r6, r26
    17a8:	2a 81       	ldd	r18, Y+2	; 0x02
    17aa:	3b 81       	ldd	r19, Y+3	; 0x03
    17ac:	4c 81       	ldd	r20, Y+4	; 0x04
    17ae:	5d 81       	ldd	r21, Y+5	; 0x05
    17b0:	82 17       	cp	r24, r18
    17b2:	93 07       	cpc	r25, r19
    17b4:	a4 07       	cpc	r26, r20
    17b6:	b5 07       	cpc	r27, r21
    17b8:	20 f4       	brcc	.+8      	; 0x17c2 <CO_collectBatt+0x172>
    17ba:	8a 83       	std	Y+2, r24	; 0x02
    17bc:	9b 83       	std	Y+3, r25	; 0x03
    17be:	ac 83       	std	Y+4, r26	; 0x04
    17c0:	bd 83       	std	Y+5, r27	; 0x05
    17c2:	08 94       	sec
    17c4:	e1 08       	sbc	r14, r1
    17c6:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    17c8:	e1 14       	cp	r14, r1
    17ca:	f1 04       	cpc	r15, r1
    17cc:	b1 f6       	brne	.-84     	; 0x177a <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    17ce:	e0 e4       	ldi	r30, 0x40	; 64
    17d0:	f2 e0       	ldi	r31, 0x02	; 2
    17d2:	81 81       	ldd	r24, Z+1	; 0x01
    17d4:	87 7f       	andi	r24, 0xF7	; 247
    17d6:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    17d8:	80 81       	ld	r24, Z
    17da:	8e 7f       	andi	r24, 0xFE	; 254
    17dc:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    17de:	84 e0       	ldi	r24, 0x04	; 4
    17e0:	60 e0       	ldi	r22, 0x00	; 0
    17e2:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    17e6:	80 e0       	ldi	r24, 0x00	; 0
    17e8:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    17ec:	c5 01       	movw	r24, r10
    17ee:	b4 01       	movw	r22, r8
    17f0:	05 2e       	mov	r0, r21
    17f2:	5a e0       	ldi	r21, 0x0A	; 10
    17f4:	96 95       	lsr	r25
    17f6:	87 95       	ror	r24
    17f8:	77 95       	ror	r23
    17fa:	67 95       	ror	r22
    17fc:	5a 95       	dec	r21
    17fe:	d1 f7       	brne	.-12     	; 0x17f4 <CO_collectBatt+0x1a4>
    1800:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1802:	28 ee       	ldi	r18, 0xE8	; 232
    1804:	33 e0       	ldi	r19, 0x03	; 3
    1806:	40 e0       	ldi	r20, 0x00	; 0
    1808:	50 e0       	ldi	r21, 0x00	; 0
    180a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    180e:	0f 2e       	mov	r0, r31
    1810:	ff ef       	ldi	r31, 0xFF	; 255
    1812:	8f 2e       	mov	r8, r31
    1814:	ff e0       	ldi	r31, 0x0F	; 15
    1816:	9f 2e       	mov	r9, r31
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	af 2e       	mov	r10, r31
    181c:	f0 e0       	ldi	r31, 0x00	; 0
    181e:	bf 2e       	mov	r11, r31
    1820:	f0 2d       	mov	r31, r0
    1822:	a5 01       	movw	r20, r10
    1824:	94 01       	movw	r18, r8
    1826:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    182a:	c9 01       	movw	r24, r18
    182c:	c2 97       	sbiw	r24, 0x32	; 50
    182e:	ae 81       	ldd	r26, Y+6	; 0x06
    1830:	bf 81       	ldd	r27, Y+7	; 0x07
    1832:	8d 93       	st	X+, r24
    1834:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1836:	c3 01       	movw	r24, r6
    1838:	b2 01       	movw	r22, r4
    183a:	28 ee       	ldi	r18, 0xE8	; 232
    183c:	33 e0       	ldi	r19, 0x03	; 3
    183e:	40 e0       	ldi	r20, 0x00	; 0
    1840:	50 e0       	ldi	r21, 0x00	; 0
    1842:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    1846:	a5 01       	movw	r20, r10
    1848:	94 01       	movw	r18, r8
    184a:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    184e:	c9 01       	movw	r24, r18
    1850:	c2 97       	sbiw	r24, 0x32	; 50
    1852:	ea 85       	ldd	r30, Y+10	; 0x0a
    1854:	fb 85       	ldd	r31, Y+11	; 0x0b
    1856:	80 83       	st	Z, r24
    1858:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    185a:	6a 81       	ldd	r22, Y+2	; 0x02
    185c:	7b 81       	ldd	r23, Y+3	; 0x03
    185e:	8c 81       	ldd	r24, Y+4	; 0x04
    1860:	9d 81       	ldd	r25, Y+5	; 0x05
    1862:	28 ee       	ldi	r18, 0xE8	; 232
    1864:	33 e0       	ldi	r19, 0x03	; 3
    1866:	40 e0       	ldi	r20, 0x00	; 0
    1868:	50 e0       	ldi	r21, 0x00	; 0
    186a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    186e:	a5 01       	movw	r20, r10
    1870:	94 01       	movw	r18, r8
    1872:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    1876:	22 53       	subi	r18, 0x32	; 50
    1878:	30 40       	sbci	r19, 0x00	; 0
    187a:	a8 85       	ldd	r26, Y+8	; 0x08
    187c:	b9 85       	ldd	r27, Y+9	; 0x09
    187e:	2d 93       	st	X+, r18
    1880:	3c 93       	st	X, r19
    1882:	11 97       	sbiw	r26, 0x01	; 1
}
    1884:	2b 96       	adiw	r28, 0x0b	; 11
    1886:	cd bf       	out	0x3d, r28	; 61
    1888:	de bf       	out	0x3e, r29	; 62
    188a:	df 91       	pop	r29
    188c:	cf 91       	pop	r28
    188e:	1f 91       	pop	r17
    1890:	0f 91       	pop	r16
    1892:	ff 90       	pop	r15
    1894:	ef 90       	pop	r14
    1896:	bf 90       	pop	r11
    1898:	af 90       	pop	r10
    189a:	9f 90       	pop	r9
    189c:	8f 90       	pop	r8
    189e:	7f 90       	pop	r7
    18a0:	6f 90       	pop	r6
    18a2:	5f 90       	pop	r5
    18a4:	4f 90       	pop	r4
    18a6:	08 95       	ret

000018a8 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    18a8:	cf 93       	push	r28
    18aa:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    18ac:	21 e0       	ldi	r18, 0x01	; 1
    18ae:	30 e0       	ldi	r19, 0x00	; 0
    18b0:	a9 01       	movw	r20, r18
    18b2:	02 c0       	rjmp	.+4      	; 0x18b8 <set_ampGain+0x10>
    18b4:	44 0f       	add	r20, r20
    18b6:	55 1f       	adc	r21, r21
    18b8:	8a 95       	dec	r24
    18ba:	e2 f7       	brpl	.-8      	; 0x18b4 <set_ampGain+0xc>
    18bc:	ca 01       	movw	r24, r20
    18be:	61 e0       	ldi	r22, 0x01	; 1
    18c0:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    18c4:	c0 ff       	sbrs	r28, 0
    18c6:	05 c0       	rjmp	.+10     	; 0x18d2 <set_ampGain+0x2a>
    18c8:	80 e4       	ldi	r24, 0x40	; 64
    18ca:	e0 e0       	ldi	r30, 0x00	; 0
    18cc:	f6 e0       	ldi	r31, 0x06	; 6
    18ce:	85 83       	std	Z+5, r24	; 0x05
    18d0:	04 c0       	rjmp	.+8      	; 0x18da <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    18d2:	80 e4       	ldi	r24, 0x40	; 64
    18d4:	e0 e0       	ldi	r30, 0x00	; 0
    18d6:	f6 e0       	ldi	r31, 0x06	; 6
    18d8:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    18da:	c1 ff       	sbrs	r28, 1
    18dc:	05 c0       	rjmp	.+10     	; 0x18e8 <set_ampGain+0x40>
    18de:	82 e0       	ldi	r24, 0x02	; 2
    18e0:	e0 e2       	ldi	r30, 0x20	; 32
    18e2:	f6 e0       	ldi	r31, 0x06	; 6
    18e4:	85 83       	std	Z+5, r24	; 0x05
    18e6:	04 c0       	rjmp	.+8      	; 0x18f0 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    18e8:	82 e0       	ldi	r24, 0x02	; 2
    18ea:	e0 e2       	ldi	r30, 0x20	; 32
    18ec:	f6 e0       	ldi	r31, 0x06	; 6
    18ee:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    18f0:	c2 ff       	sbrs	r28, 2
    18f2:	05 c0       	rjmp	.+10     	; 0x18fe <set_ampGain+0x56>
    18f4:	84 e0       	ldi	r24, 0x04	; 4
    18f6:	e0 e2       	ldi	r30, 0x20	; 32
    18f8:	f6 e0       	ldi	r31, 0x06	; 6
    18fa:	85 83       	std	Z+5, r24	; 0x05
    18fc:	04 c0       	rjmp	.+8      	; 0x1906 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    18fe:	84 e0       	ldi	r24, 0x04	; 4
    1900:	e0 e2       	ldi	r30, 0x20	; 32
    1902:	f6 e0       	ldi	r31, 0x06	; 6
    1904:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1906:	5a e0       	ldi	r21, 0x0A	; 10
    1908:	5a 95       	dec	r21
    190a:	f1 f7       	brne	.-4      	; 0x1908 <set_ampGain+0x60>
    190c:	00 c0       	rjmp	.+0      	; 0x190e <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    190e:	8f ef       	ldi	r24, 0xFF	; 255
    1910:	61 e0       	ldi	r22, 0x01	; 1
    1912:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    1916:	cf 91       	pop	r28
    1918:	08 95       	ret

0000191a <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    191a:	88 23       	and	r24, r24
    191c:	31 f0       	breq	.+12     	; 0x192a <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    191e:	e0 e0       	ldi	r30, 0x00	; 0
    1920:	f6 e0       	ldi	r31, 0x06	; 6
    1922:	80 e2       	ldi	r24, 0x20	; 32
    1924:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1926:	85 83       	std	Z+5, r24	; 0x05
    1928:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    192a:	e0 e0       	ldi	r30, 0x00	; 0
    192c:	f6 e0       	ldi	r31, 0x06	; 6
    192e:	80 e2       	ldi	r24, 0x20	; 32
    1930:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    1932:	82 83       	std	Z+2, r24	; 0x02
    1934:	08 95       	ret

00001936 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    1936:	1f 92       	push	r1
    1938:	0f 92       	push	r0
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	0f 92       	push	r0
    193e:	0b b6       	in	r0, 0x3b	; 59
    1940:	0f 92       	push	r0
    1942:	11 24       	eor	r1, r1
    1944:	2f 93       	push	r18
    1946:	3f 93       	push	r19
    1948:	4f 93       	push	r20
    194a:	5f 93       	push	r21
    194c:	6f 93       	push	r22
    194e:	7f 93       	push	r23
    1950:	8f 93       	push	r24
    1952:	9f 93       	push	r25
    1954:	af 93       	push	r26
    1956:	bf 93       	push	r27
    1958:	ef 93       	push	r30
    195a:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    195c:	e0 e4       	ldi	r30, 0x40	; 64
    195e:	fa e0       	ldi	r31, 0x0A	; 10
    1960:	80 81       	ld	r24, Z
    1962:	80 7f       	andi	r24, 0xF0	; 240
    1964:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1966:	a0 e0       	ldi	r26, 0x00	; 0
    1968:	b8 e0       	ldi	r27, 0x08	; 8
    196a:	8c 91       	ld	r24, X
    196c:	80 7f       	andi	r24, 0xF0	; 240
    196e:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1970:	a0 e0       	ldi	r26, 0x00	; 0
    1972:	b9 e0       	ldi	r27, 0x09	; 9
    1974:	8c 91       	ld	r24, X
    1976:	80 7f       	andi	r24, 0xF0	; 240
    1978:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    197a:	80 81       	ld	r24, Z
    197c:	80 7f       	andi	r24, 0xF0	; 240
    197e:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    1988:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    198c:	80 e0       	ldi	r24, 0x00	; 0
    198e:	0e 94 8d 0c 	call	0x191a	; 0x191a <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    1992:	81 e0       	ldi	r24, 0x01	; 1
    1994:	80 93 ab 50 	sts	0x50AB, r24
	DataAvailable = 1;
    1998:	80 93 4c 3e 	sts	0x3E4C, r24
}
    199c:	ff 91       	pop	r31
    199e:	ef 91       	pop	r30
    19a0:	bf 91       	pop	r27
    19a2:	af 91       	pop	r26
    19a4:	9f 91       	pop	r25
    19a6:	8f 91       	pop	r24
    19a8:	7f 91       	pop	r23
    19aa:	6f 91       	pop	r22
    19ac:	5f 91       	pop	r21
    19ae:	4f 91       	pop	r20
    19b0:	3f 91       	pop	r19
    19b2:	2f 91       	pop	r18
    19b4:	0f 90       	pop	r0
    19b6:	0b be       	out	0x3b, r0	; 59
    19b8:	0f 90       	pop	r0
    19ba:	0f be       	out	0x3f, r0	; 63
    19bc:	0f 90       	pop	r0
    19be:	1f 90       	pop	r1
    19c0:	18 95       	reti

000019c2 <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19c2:	e0 e4       	ldi	r30, 0x40	; 64
    19c4:	fa e0       	ldi	r31, 0x0A	; 10
    19c6:	80 81       	ld	r24, Z
    19c8:	80 7f       	andi	r24, 0xF0	; 240
    19ca:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19cc:	a0 e0       	ldi	r26, 0x00	; 0
    19ce:	b8 e0       	ldi	r27, 0x08	; 8
    19d0:	8c 91       	ld	r24, X
    19d2:	80 7f       	andi	r24, 0xF0	; 240
    19d4:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19d6:	a0 e0       	ldi	r26, 0x00	; 0
    19d8:	b9 e0       	ldi	r27, 0x09	; 9
    19da:	8c 91       	ld	r24, X
    19dc:	80 7f       	andi	r24, 0xF0	; 240
    19de:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19e0:	80 81       	ld	r24, Z
    19e2:	80 7f       	andi	r24, 0xF0	; 240
    19e4:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    19e8:	80 e0       	ldi	r24, 0x00	; 0
    19ea:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    19ee:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    19f2:	80 e0       	ldi	r24, 0x00	; 0
    19f4:	0e 94 8d 0c 	call	0x191a	; 0x191a <enableADCMUX>
	ADC_Sampling_Finished = 1;
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	80 93 ab 50 	sts	0x50AB, r24
	DataAvailable = 1;
    19fe:	80 93 4c 3e 	sts	0x3E4C, r24
}
    1a02:	08 95       	ret

00001a04 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    1a04:	cf 93       	push	r28
    1a06:	df 93       	push	r29
    1a08:	0f 92       	push	r0
    1a0a:	0f 92       	push	r0
    1a0c:	cd b7       	in	r28, 0x3d	; 61
    1a0e:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    1a10:	80 91 ab 50 	lds	r24, 0x50AB
    1a14:	88 23       	and	r24, r24
    1a16:	89 f0       	breq	.+34     	; 0x1a3a <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    1a18:	e0 e4       	ldi	r30, 0x40	; 64
    1a1a:	f8 e0       	ldi	r31, 0x08	; 8
    1a1c:	80 a1       	lds	r24, 0x40
    1a1e:	91 a1       	lds	r25, 0x41
    1a20:	89 83       	std	Y+1, r24	; 0x01
    1a22:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    1a24:	89 81       	ldd	r24, Y+1	; 0x01
    1a26:	9a 81       	ldd	r25, Y+2	; 0x02
    1a28:	00 97       	sbiw	r24, 0x00	; 0
    1a2a:	21 f4       	brne	.+8      	; 0x1a34 <ADC_Get_Num_Samples+0x30>
    1a2c:	86 a1       	lds	r24, 0x46
    1a2e:	97 a1       	lds	r25, 0x47
    1a30:	89 83       	std	Y+1, r24	; 0x01
    1a32:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    1a34:	89 81       	ldd	r24, Y+1	; 0x01
    1a36:	9a 81       	ldd	r25, Y+2	; 0x02
    1a38:	02 c0       	rjmp	.+4      	; 0x1a3e <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    1a3a:	80 e0       	ldi	r24, 0x00	; 0
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
}
    1a3e:	0f 90       	pop	r0
    1a40:	0f 90       	pop	r0
    1a42:	df 91       	pop	r29
    1a44:	cf 91       	pop	r28
    1a46:	08 95       	ret

00001a48 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1a48:	e0 ea       	ldi	r30, 0xA0	; 160
    1a4a:	f6 e0       	ldi	r31, 0x06	; 6
    1a4c:	13 86       	std	Z+11, r1	; 0x0b
}
    1a4e:	08 95       	ret

00001a50 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	e0 ea       	ldi	r30, 0xA0	; 160
    1a54:	f6 e0       	ldi	r31, 0x06	; 6
    1a56:	83 87       	std	Z+11, r24	; 0x0b
}	
    1a58:	08 95       	ret

00001a5a <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    1a5a:	1f 92       	push	r1
    1a5c:	0f 92       	push	r0
    1a5e:	0f b6       	in	r0, 0x3f	; 63
    1a60:	0f 92       	push	r0
    1a62:	0b b6       	in	r0, 0x3b	; 59
    1a64:	0f 92       	push	r0
    1a66:	11 24       	eor	r1, r1
    1a68:	6f 92       	push	r6
    1a6a:	7f 92       	push	r7
    1a6c:	8f 92       	push	r8
    1a6e:	9f 92       	push	r9
    1a70:	af 92       	push	r10
    1a72:	bf 92       	push	r11
    1a74:	cf 92       	push	r12
    1a76:	df 92       	push	r13
    1a78:	ef 92       	push	r14
    1a7a:	ff 92       	push	r15
    1a7c:	0f 93       	push	r16
    1a7e:	1f 93       	push	r17
    1a80:	2f 93       	push	r18
    1a82:	3f 93       	push	r19
    1a84:	4f 93       	push	r20
    1a86:	5f 93       	push	r21
    1a88:	6f 93       	push	r22
    1a8a:	7f 93       	push	r23
    1a8c:	8f 93       	push	r24
    1a8e:	9f 93       	push	r25
    1a90:	af 93       	push	r26
    1a92:	bf 93       	push	r27
    1a94:	ef 93       	push	r30
    1a96:	ff 93       	push	r31
    1a98:	cf 93       	push	r28
    1a9a:	df 93       	push	r29
    1a9c:	cd b7       	in	r28, 0x3d	; 61
    1a9e:	de b7       	in	r29, 0x3e	; 62
    1aa0:	2c 97       	sbiw	r28, 0x0c	; 12
    1aa2:	cd bf       	out	0x3d, r28	; 61
    1aa4:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    1aa6:	80 91 61 40 	lds	r24, 0x4061
    1aaa:	88 23       	and	r24, r24
    1aac:	8c f0       	brlt	.+34     	; 0x1ad0 <__vector_104+0x76>
		discardCount++;
    1aae:	80 91 61 40 	lds	r24, 0x4061
    1ab2:	8f 5f       	subi	r24, 0xFF	; 255
    1ab4:	80 93 61 40 	sts	0x4061, r24
		if(discardCount == ADC_DISCARD){
    1ab8:	80 91 61 40 	lds	r24, 0x4061
    1abc:	80 38       	cpi	r24, 0x80	; 128
    1abe:	09 f0       	breq	.+2      	; 0x1ac2 <__vector_104+0x68>
    1ac0:	e9 c0       	rjmp	.+466    	; 0x1c94 <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1ac2:	e0 e4       	ldi	r30, 0x40	; 64
    1ac4:	f8 e0       	ldi	r31, 0x08	; 8
    1ac6:	80 81       	ld	r24, Z
    1ac8:	80 7f       	andi	r24, 0xF0	; 240
    1aca:	89 60       	ori	r24, 0x09	; 9
    1acc:	80 83       	st	Z, r24
    1ace:	e2 c0       	rjmp	.+452    	; 0x1c94 <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1ad0:	81 e0       	ldi	r24, 0x01	; 1
    1ad2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1ad6:	82 e0       	ldi	r24, 0x02	; 2
    1ad8:	e0 ea       	ldi	r30, 0xA0	; 160
    1ada:	f6 e0       	ldi	r31, 0x06	; 6
    1adc:	86 83       	std	Z+6, r24	; 0x06
    1ade:	80 e0       	ldi	r24, 0x00	; 0
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1ae2:	e0 ec       	ldi	r30, 0xC0	; 192
    1ae4:	f8 e0       	ldi	r31, 0x08	; 8
    1ae6:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1ae8:	25 e2       	ldi	r18, 0x25	; 37
    1aea:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1aec:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1aee:	42 81       	ldd	r20, Z+2	; 0x02
    1af0:	44 23       	and	r20, r20
    1af2:	ec f7       	brge	.-6      	; 0x1aee <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1af4:	43 81       	ldd	r20, Z+3	; 0x03
    1af6:	d9 01       	movw	r26, r18
    1af8:	a8 0f       	add	r26, r24
    1afa:	b9 1f       	adc	r27, r25
    1afc:	4c 93       	st	X, r20
    1afe:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1b00:	83 30       	cpi	r24, 0x03	; 3
    1b02:	91 05       	cpc	r25, r1
    1b04:	99 f7       	brne	.-26     	; 0x1aec <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1b06:	82 e0       	ldi	r24, 0x02	; 2
    1b08:	e0 ea       	ldi	r30, 0xA0	; 160
    1b0a:	f6 e0       	ldi	r31, 0x06	; 6
    1b0c:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1b0e:	80 e0       	ldi	r24, 0x00	; 0
    1b10:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1b14:	80 91 25 3e 	lds	r24, 0x3E25
    1b18:	88 23       	and	r24, r24
    1b1a:	1c f4       	brge	.+6      	; 0x1b22 <__vector_104+0xc8>
    1b1c:	8f ef       	ldi	r24, 0xFF	; 255
    1b1e:	8c 83       	std	Y+4, r24	; 0x04
    1b20:	01 c0       	rjmp	.+2      	; 0x1b24 <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1b22:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    1b24:	80 91 25 3e 	lds	r24, 0x3E25
    1b28:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1b2a:	80 91 26 3e 	lds	r24, 0x3E26
    1b2e:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    1b30:	80 91 27 3e 	lds	r24, 0x3E27
    1b34:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1b36:	89 81       	ldd	r24, Y+1	; 0x01
    1b38:	9a 81       	ldd	r25, Y+2	; 0x02
    1b3a:	ab 81       	ldd	r26, Y+3	; 0x03
    1b3c:	bc 81       	ldd	r27, Y+4	; 0x04
    1b3e:	ac 01       	movw	r20, r24
    1b40:	bd 01       	movw	r22, r26
    1b42:	77 0f       	add	r23, r23
    1b44:	44 0b       	sbc	r20, r20
    1b46:	54 2f       	mov	r21, r20
    1b48:	ba 01       	movw	r22, r20
    1b4a:	8d 83       	std	Y+5, r24	; 0x05
    1b4c:	9e 83       	std	Y+6, r25	; 0x06
    1b4e:	af 83       	std	Y+7, r26	; 0x07
    1b50:	b8 87       	std	Y+8, r27	; 0x08
    1b52:	49 87       	std	Y+9, r20	; 0x09
    1b54:	4a 87       	std	Y+10, r20	; 0x0a
    1b56:	4b 87       	std	Y+11, r20	; 0x0b
    1b58:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1b5a:	60 91 6a 50 	lds	r22, 0x506A
    1b5e:	70 91 6b 50 	lds	r23, 0x506B
    1b62:	80 91 6c 50 	lds	r24, 0x506C
    1b66:	90 91 6d 50 	lds	r25, 0x506D
    1b6a:	8d 80       	ldd	r8, Y+5	; 0x05
    1b6c:	1e 81       	ldd	r17, Y+6	; 0x06
    1b6e:	0f 81       	ldd	r16, Y+7	; 0x07
    1b70:	f8 84       	ldd	r15, Y+8	; 0x08
    1b72:	e9 84       	ldd	r14, Y+9	; 0x09
    1b74:	da 84       	ldd	r13, Y+10	; 0x0a
    1b76:	cb 84       	ldd	r12, Y+11	; 0x0b
    1b78:	bc 84       	ldd	r11, Y+12	; 0x0c
    1b7a:	20 91 ac 50 	lds	r18, 0x50AC
    1b7e:	30 91 ad 50 	lds	r19, 0x50AD
    1b82:	40 e0       	ldi	r20, 0x00	; 0
    1b84:	50 e0       	ldi	r21, 0x00	; 0
    1b86:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    1b8a:	66 0f       	add	r22, r22
    1b8c:	77 1f       	adc	r23, r23
    1b8e:	66 0f       	add	r22, r22
    1b90:	77 1f       	adc	r23, r23
    1b92:	80 91 68 50 	lds	r24, 0x5068
    1b96:	90 91 69 50 	lds	r25, 0x5069
    1b9a:	3c 01       	movw	r6, r24
    1b9c:	66 0e       	add	r6, r22
    1b9e:	77 1e       	adc	r7, r23
    1ba0:	28 2d       	mov	r18, r8
    1ba2:	31 2f       	mov	r19, r17
    1ba4:	40 2f       	mov	r20, r16
    1ba6:	5f 2d       	mov	r21, r15
    1ba8:	6e 2d       	mov	r22, r14
    1baa:	7d 2d       	mov	r23, r13
    1bac:	8c 2d       	mov	r24, r12
    1bae:	9b 2d       	mov	r25, r11
    1bb0:	0f 2e       	mov	r0, r31
    1bb2:	f0 ea       	ldi	r31, 0xA0	; 160
    1bb4:	af 2e       	mov	r10, r31
    1bb6:	f0 2d       	mov	r31, r0
    1bb8:	0f 2e       	mov	r0, r31
    1bba:	f5 e2       	ldi	r31, 0x25	; 37
    1bbc:	bf 2e       	mov	r11, r31
    1bbe:	f0 2d       	mov	r31, r0
    1bc0:	0f 2e       	mov	r0, r31
    1bc2:	f6 e2       	ldi	r31, 0x26	; 38
    1bc4:	cf 2e       	mov	r12, r31
    1bc6:	f0 2d       	mov	r31, r0
    1bc8:	dd 24       	eor	r13, r13
    1bca:	ee 24       	eor	r14, r14
    1bcc:	ff 24       	eor	r15, r15
    1bce:	00 e0       	ldi	r16, 0x00	; 0
    1bd0:	10 e0       	ldi	r17, 0x00	; 0
    1bd2:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__muldi3>
    1bd6:	aa 24       	eor	r10, r10
    1bd8:	aa 94       	dec	r10
    1bda:	bb 24       	eor	r11, r11
    1bdc:	ba 94       	dec	r11
    1bde:	0f 2e       	mov	r0, r31
    1be0:	ff e7       	ldi	r31, 0x7F	; 127
    1be2:	cf 2e       	mov	r12, r31
    1be4:	f0 2d       	mov	r31, r0
    1be6:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <__divdi3>
    1bea:	01 e0       	ldi	r16, 0x01	; 1
    1bec:	0e 94 15 2f 	call	0x5e2a	; 0x5e2a <__ashldi3>
    1bf0:	0f 2e       	mov	r0, r31
    1bf2:	f3 e0       	ldi	r31, 0x03	; 3
    1bf4:	af 2e       	mov	r10, r31
    1bf6:	f0 2d       	mov	r31, r0
    1bf8:	bb 24       	eor	r11, r11
    1bfa:	cc 24       	eor	r12, r12
    1bfc:	00 e0       	ldi	r16, 0x00	; 0
    1bfe:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <__divdi3>
    1c02:	82 2e       	mov	r8, r18
    1c04:	93 2e       	mov	r9, r19
    1c06:	a4 2e       	mov	r10, r20
    1c08:	b5 2e       	mov	r11, r21
    1c0a:	b0 94       	com	r11
    1c0c:	a0 94       	com	r10
    1c0e:	90 94       	com	r9
    1c10:	80 94       	com	r8
    1c12:	81 1c       	adc	r8, r1
    1c14:	91 1c       	adc	r9, r1
    1c16:	a1 1c       	adc	r10, r1
    1c18:	b1 1c       	adc	r11, r1
    1c1a:	f3 01       	movw	r30, r6
    1c1c:	80 82       	st	Z, r8
    1c1e:	91 82       	std	Z+1, r9	; 0x01
    1c20:	a2 82       	std	Z+2, r10	; 0x02
    1c22:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    1c24:	80 91 4d 40 	lds	r24, 0x404D
    1c28:	88 23       	and	r24, r24
    1c2a:	09 f1       	breq	.+66     	; 0x1c6e <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1c2c:	60 91 6a 50 	lds	r22, 0x506A
    1c30:	70 91 6b 50 	lds	r23, 0x506B
    1c34:	80 91 6c 50 	lds	r24, 0x506C
    1c38:	90 91 6d 50 	lds	r25, 0x506D
    1c3c:	20 91 ac 50 	lds	r18, 0x50AC
    1c40:	30 91 ad 50 	lds	r19, 0x50AD
    1c44:	40 e0       	ldi	r20, 0x00	; 0
    1c46:	50 e0       	ldi	r21, 0x00	; 0
    1c48:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    1c4c:	dc 01       	movw	r26, r24
    1c4e:	cb 01       	movw	r24, r22
    1c50:	9c 01       	movw	r18, r24
    1c52:	22 0f       	add	r18, r18
    1c54:	33 1f       	adc	r19, r19
    1c56:	22 0f       	add	r18, r18
    1c58:	33 1f       	adc	r19, r19
    1c5a:	80 91 68 50 	lds	r24, 0x5068
    1c5e:	90 91 69 50 	lds	r25, 0x5069
    1c62:	82 0f       	add	r24, r18
    1c64:	93 1f       	adc	r25, r19
    1c66:	64 e0       	ldi	r22, 0x04	; 4
    1c68:	70 e0       	ldi	r23, 0x00	; 0
    1c6a:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    1c6e:	80 91 6a 50 	lds	r24, 0x506A
    1c72:	90 91 6b 50 	lds	r25, 0x506B
    1c76:	a0 91 6c 50 	lds	r26, 0x506C
    1c7a:	b0 91 6d 50 	lds	r27, 0x506D
    1c7e:	01 96       	adiw	r24, 0x01	; 1
    1c80:	a1 1d       	adc	r26, r1
    1c82:	b1 1d       	adc	r27, r1
    1c84:	80 93 6a 50 	sts	0x506A, r24
    1c88:	90 93 6b 50 	sts	0x506B, r25
    1c8c:	a0 93 6c 50 	sts	0x506C, r26
    1c90:	b0 93 6d 50 	sts	0x506D, r27
	}
}
    1c94:	2c 96       	adiw	r28, 0x0c	; 12
    1c96:	cd bf       	out	0x3d, r28	; 61
    1c98:	de bf       	out	0x3e, r29	; 62
    1c9a:	df 91       	pop	r29
    1c9c:	cf 91       	pop	r28
    1c9e:	ff 91       	pop	r31
    1ca0:	ef 91       	pop	r30
    1ca2:	bf 91       	pop	r27
    1ca4:	af 91       	pop	r26
    1ca6:	9f 91       	pop	r25
    1ca8:	8f 91       	pop	r24
    1caa:	7f 91       	pop	r23
    1cac:	6f 91       	pop	r22
    1cae:	5f 91       	pop	r21
    1cb0:	4f 91       	pop	r20
    1cb2:	3f 91       	pop	r19
    1cb4:	2f 91       	pop	r18
    1cb6:	1f 91       	pop	r17
    1cb8:	0f 91       	pop	r16
    1cba:	ff 90       	pop	r15
    1cbc:	ef 90       	pop	r14
    1cbe:	df 90       	pop	r13
    1cc0:	cf 90       	pop	r12
    1cc2:	bf 90       	pop	r11
    1cc4:	af 90       	pop	r10
    1cc6:	9f 90       	pop	r9
    1cc8:	8f 90       	pop	r8
    1cca:	7f 90       	pop	r7
    1ccc:	6f 90       	pop	r6
    1cce:	0f 90       	pop	r0
    1cd0:	0b be       	out	0x3b, r0	; 59
    1cd2:	0f 90       	pop	r0
    1cd4:	0f be       	out	0x3f, r0	; 63
    1cd6:	0f 90       	pop	r0
    1cd8:	1f 90       	pop	r1
    1cda:	18 95       	reti

00001cdc <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1cdc:	88 23       	and	r24, r24
    1cde:	49 f0       	breq	.+18     	; 0x1cf2 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1ce0:	80 e2       	ldi	r24, 0x20	; 32
    1ce2:	60 e0       	ldi	r22, 0x00	; 0
    1ce4:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1ce8:	80 e2       	ldi	r24, 0x20	; 32
    1cea:	60 e0       	ldi	r22, 0x00	; 0
    1cec:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    1cf0:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1cf2:	80 e2       	ldi	r24, 0x20	; 32
    1cf4:	60 e0       	ldi	r22, 0x00	; 0
    1cf6:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
    1cfa:	08 95       	ret

00001cfc <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1cfc:	1f 92       	push	r1
    1cfe:	0f 92       	push	r0
    1d00:	0f b6       	in	r0, 0x3f	; 63
    1d02:	0f 92       	push	r0
    1d04:	0b b6       	in	r0, 0x3b	; 59
    1d06:	0f 92       	push	r0
    1d08:	11 24       	eor	r1, r1
    1d0a:	6f 92       	push	r6
    1d0c:	7f 92       	push	r7
    1d0e:	8f 92       	push	r8
    1d10:	9f 92       	push	r9
    1d12:	af 92       	push	r10
    1d14:	bf 92       	push	r11
    1d16:	cf 92       	push	r12
    1d18:	df 92       	push	r13
    1d1a:	ef 92       	push	r14
    1d1c:	ff 92       	push	r15
    1d1e:	0f 93       	push	r16
    1d20:	1f 93       	push	r17
    1d22:	2f 93       	push	r18
    1d24:	3f 93       	push	r19
    1d26:	4f 93       	push	r20
    1d28:	5f 93       	push	r21
    1d2a:	6f 93       	push	r22
    1d2c:	7f 93       	push	r23
    1d2e:	8f 93       	push	r24
    1d30:	9f 93       	push	r25
    1d32:	af 93       	push	r26
    1d34:	bf 93       	push	r27
    1d36:	ef 93       	push	r30
    1d38:	ff 93       	push	r31
    1d3a:	cf 93       	push	r28
    1d3c:	df 93       	push	r29
    1d3e:	cd b7       	in	r28, 0x3d	; 61
    1d40:	de b7       	in	r29, 0x3e	; 62
    1d42:	2c 97       	sbiw	r28, 0x0c	; 12
    1d44:	cd bf       	out	0x3d, r28	; 61
    1d46:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1d48:	19 82       	std	Y+1, r1	; 0x01
    1d4a:	1a 82       	std	Y+2, r1	; 0x02
    1d4c:	1b 82       	std	Y+3, r1	; 0x03
    1d4e:	1c 82       	std	Y+4, r1	; 0x04
    1d50:	1d 82       	std	Y+5, r1	; 0x05
    1d52:	1e 82       	std	Y+6, r1	; 0x06
    1d54:	1f 82       	std	Y+7, r1	; 0x07
    1d56:	18 86       	std	Y+8, r1	; 0x08
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1d5c:	25 e2       	ldi	r18, 0x25	; 37
    1d5e:	3e e3       	ldi	r19, 0x3E	; 62
    1d60:	88 24       	eor	r8, r8
    1d62:	8a 94       	dec	r8
    1d64:	ac 01       	movw	r20, r24
    1d66:	f9 01       	movw	r30, r18
    1d68:	e8 0f       	add	r30, r24
    1d6a:	f9 1f       	adc	r31, r25
    1d6c:	60 81       	ld	r22, Z
    1d6e:	66 23       	and	r22, r22
    1d70:	14 f4       	brge	.+4      	; 0x1d76 <__vector_14+0x7a>
    1d72:	8c 86       	std	Y+12, r8	; 0x0c
    1d74:	01 c0       	rjmp	.+2      	; 0x1d78 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1d76:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1d78:	42 0f       	add	r20, r18
    1d7a:	53 1f       	adc	r21, r19
    1d7c:	fa 01       	movw	r30, r20
    1d7e:	40 81       	ld	r20, Z
    1d80:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1d82:	fc 01       	movw	r30, r24
    1d84:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1d86:	e2 0f       	add	r30, r18
    1d88:	f3 1f       	adc	r31, r19
    1d8a:	40 81       	ld	r20, Z
    1d8c:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1d8e:	fc 01       	movw	r30, r24
    1d90:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1d92:	e2 0f       	add	r30, r18
    1d94:	f3 1f       	adc	r31, r19
    1d96:	40 81       	ld	r20, Z
    1d98:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1d9a:	49 85       	ldd	r20, Y+9	; 0x09
    1d9c:	5a 85       	ldd	r21, Y+10	; 0x0a
    1d9e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1da0:	7c 85       	ldd	r23, Y+12	; 0x0c
    1da2:	a9 80       	ldd	r10, Y+1	; 0x01
    1da4:	ba 80       	ldd	r11, Y+2	; 0x02
    1da6:	cb 80       	ldd	r12, Y+3	; 0x03
    1da8:	dc 80       	ldd	r13, Y+4	; 0x04
    1daa:	ed 80       	ldd	r14, Y+5	; 0x05
    1dac:	fe 80       	ldd	r15, Y+6	; 0x06
    1dae:	0f 81       	ldd	r16, Y+7	; 0x07
    1db0:	18 85       	ldd	r17, Y+8	; 0x08
    1db2:	b4 2f       	mov	r27, r20
    1db4:	a5 2f       	mov	r26, r21
    1db6:	f6 2f       	mov	r31, r22
    1db8:	e7 2f       	mov	r30, r23
    1dba:	77 0f       	add	r23, r23
    1dbc:	44 0b       	sbc	r20, r20
    1dbe:	54 2f       	mov	r21, r20
    1dc0:	ba 01       	movw	r22, r20
    1dc2:	64 2e       	mov	r6, r20
    1dc4:	74 2e       	mov	r7, r20
    1dc6:	94 2e       	mov	r9, r20
    1dc8:	ab 0e       	add	r10, r27
    1dca:	61 e0       	ldi	r22, 0x01	; 1
    1dcc:	ab 16       	cp	r10, r27
    1dce:	08 f0       	brcs	.+2      	; 0x1dd2 <__vector_14+0xd6>
    1dd0:	60 e0       	ldi	r22, 0x00	; 0
    1dd2:	ba 0e       	add	r11, r26
    1dd4:	51 e0       	ldi	r21, 0x01	; 1
    1dd6:	ba 16       	cp	r11, r26
    1dd8:	08 f0       	brcs	.+2      	; 0x1ddc <__vector_14+0xe0>
    1dda:	50 e0       	ldi	r21, 0x00	; 0
    1ddc:	a6 2f       	mov	r26, r22
    1dde:	ab 0d       	add	r26, r11
    1de0:	61 e0       	ldi	r22, 0x01	; 1
    1de2:	ab 15       	cp	r26, r11
    1de4:	08 f0       	brcs	.+2      	; 0x1de8 <__vector_14+0xec>
    1de6:	60 e0       	ldi	r22, 0x00	; 0
    1de8:	56 2b       	or	r21, r22
    1dea:	cf 0e       	add	r12, r31
    1dec:	61 e0       	ldi	r22, 0x01	; 1
    1dee:	cf 16       	cp	r12, r31
    1df0:	08 f0       	brcs	.+2      	; 0x1df4 <__vector_14+0xf8>
    1df2:	60 e0       	ldi	r22, 0x00	; 0
    1df4:	f5 2f       	mov	r31, r21
    1df6:	fc 0d       	add	r31, r12
    1df8:	51 e0       	ldi	r21, 0x01	; 1
    1dfa:	fc 15       	cp	r31, r12
    1dfc:	08 f0       	brcs	.+2      	; 0x1e00 <__vector_14+0x104>
    1dfe:	50 e0       	ldi	r21, 0x00	; 0
    1e00:	65 2b       	or	r22, r21
    1e02:	de 0e       	add	r13, r30
    1e04:	51 e0       	ldi	r21, 0x01	; 1
    1e06:	de 16       	cp	r13, r30
    1e08:	08 f0       	brcs	.+2      	; 0x1e0c <__vector_14+0x110>
    1e0a:	50 e0       	ldi	r21, 0x00	; 0
    1e0c:	e6 2f       	mov	r30, r22
    1e0e:	ed 0d       	add	r30, r13
    1e10:	61 e0       	ldi	r22, 0x01	; 1
    1e12:	ed 15       	cp	r30, r13
    1e14:	08 f0       	brcs	.+2      	; 0x1e18 <__vector_14+0x11c>
    1e16:	60 e0       	ldi	r22, 0x00	; 0
    1e18:	56 2b       	or	r21, r22
    1e1a:	e6 0c       	add	r14, r6
    1e1c:	71 e0       	ldi	r23, 0x01	; 1
    1e1e:	e6 14       	cp	r14, r6
    1e20:	08 f0       	brcs	.+2      	; 0x1e24 <__vector_14+0x128>
    1e22:	70 e0       	ldi	r23, 0x00	; 0
    1e24:	b5 2f       	mov	r27, r21
    1e26:	be 0d       	add	r27, r14
    1e28:	51 e0       	ldi	r21, 0x01	; 1
    1e2a:	be 15       	cp	r27, r14
    1e2c:	08 f0       	brcs	.+2      	; 0x1e30 <__vector_14+0x134>
    1e2e:	50 e0       	ldi	r21, 0x00	; 0
    1e30:	75 2b       	or	r23, r21
    1e32:	f7 0c       	add	r15, r7
    1e34:	61 e0       	ldi	r22, 0x01	; 1
    1e36:	f7 14       	cp	r15, r7
    1e38:	08 f0       	brcs	.+2      	; 0x1e3c <__vector_14+0x140>
    1e3a:	60 e0       	ldi	r22, 0x00	; 0
    1e3c:	7f 0d       	add	r23, r15
    1e3e:	51 e0       	ldi	r21, 0x01	; 1
    1e40:	7f 15       	cp	r23, r15
    1e42:	08 f0       	brcs	.+2      	; 0x1e46 <__vector_14+0x14a>
    1e44:	50 e0       	ldi	r21, 0x00	; 0
    1e46:	65 2b       	or	r22, r21
    1e48:	09 0d       	add	r16, r9
    1e4a:	51 e0       	ldi	r21, 0x01	; 1
    1e4c:	09 15       	cp	r16, r9
    1e4e:	08 f0       	brcs	.+2      	; 0x1e52 <__vector_14+0x156>
    1e50:	50 e0       	ldi	r21, 0x00	; 0
    1e52:	60 0f       	add	r22, r16
    1e54:	ff 24       	eor	r15, r15
    1e56:	f3 94       	inc	r15
    1e58:	60 17       	cp	r22, r16
    1e5a:	08 f0       	brcs	.+2      	; 0x1e5e <__vector_14+0x162>
    1e5c:	ff 24       	eor	r15, r15
    1e5e:	5f 29       	or	r21, r15
    1e60:	41 0f       	add	r20, r17
    1e62:	54 0f       	add	r21, r20
    1e64:	a9 82       	std	Y+1, r10	; 0x01
    1e66:	aa 83       	std	Y+2, r26	; 0x02
    1e68:	fb 83       	std	Y+3, r31	; 0x03
    1e6a:	ec 83       	std	Y+4, r30	; 0x04
    1e6c:	bd 83       	std	Y+5, r27	; 0x05
    1e6e:	7e 83       	std	Y+6, r23	; 0x06
    1e70:	6f 83       	std	Y+7, r22	; 0x07
    1e72:	58 87       	std	Y+8, r21	; 0x08
    1e74:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1e76:	8c 30       	cpi	r24, 0x0C	; 12
    1e78:	91 05       	cpc	r25, r1
    1e7a:	09 f0       	breq	.+2      	; 0x1e7e <__vector_14+0x182>
    1e7c:	73 cf       	rjmp	.-282    	; 0x1d64 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1e7e:	e9 80       	ldd	r14, Y+1	; 0x01
    1e80:	fa 80       	ldd	r15, Y+2	; 0x02
    1e82:	0b 81       	ldd	r16, Y+3	; 0x03
    1e84:	1c 81       	ldd	r17, Y+4	; 0x04
    1e86:	bd 81       	ldd	r27, Y+5	; 0x05
    1e88:	ae 81       	ldd	r26, Y+6	; 0x06
    1e8a:	ff 81       	ldd	r31, Y+7	; 0x07
    1e8c:	e8 85       	ldd	r30, Y+8	; 0x08
    1e8e:	2e 2d       	mov	r18, r14
    1e90:	3f 2d       	mov	r19, r15
    1e92:	40 2f       	mov	r20, r16
    1e94:	51 2f       	mov	r21, r17
    1e96:	6b 2f       	mov	r22, r27
    1e98:	7a 2f       	mov	r23, r26
    1e9a:	8f 2f       	mov	r24, r31
    1e9c:	9e 2f       	mov	r25, r30
    1e9e:	ee 23       	and	r30, r30
    1ea0:	0c f0       	brlt	.+2      	; 0x1ea4 <__vector_14+0x1a8>
    1ea2:	4a c0       	rjmp	.+148    	; 0x1f38 <__vector_14+0x23c>
    1ea4:	93 e0       	ldi	r25, 0x03	; 3
    1ea6:	e9 0e       	add	r14, r25
    1ea8:	91 e0       	ldi	r25, 0x01	; 1
    1eaa:	e2 16       	cp	r14, r18
    1eac:	08 f0       	brcs	.+2      	; 0x1eb0 <__vector_14+0x1b4>
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	21 e0       	ldi	r18, 0x01	; 1
    1eb2:	f3 16       	cp	r15, r19
    1eb4:	08 f0       	brcs	.+2      	; 0x1eb8 <__vector_14+0x1bc>
    1eb6:	20 e0       	ldi	r18, 0x00	; 0
    1eb8:	39 2f       	mov	r19, r25
    1eba:	3f 0d       	add	r19, r15
    1ebc:	91 e0       	ldi	r25, 0x01	; 1
    1ebe:	3f 15       	cp	r19, r15
    1ec0:	08 f0       	brcs	.+2      	; 0x1ec4 <__vector_14+0x1c8>
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	29 2b       	or	r18, r25
    1ec6:	91 e0       	ldi	r25, 0x01	; 1
    1ec8:	04 17       	cp	r16, r20
    1eca:	08 f0       	brcs	.+2      	; 0x1ece <__vector_14+0x1d2>
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	42 2f       	mov	r20, r18
    1ed0:	40 0f       	add	r20, r16
    1ed2:	21 e0       	ldi	r18, 0x01	; 1
    1ed4:	40 17       	cp	r20, r16
    1ed6:	08 f0       	brcs	.+2      	; 0x1eda <__vector_14+0x1de>
    1ed8:	20 e0       	ldi	r18, 0x00	; 0
    1eda:	92 2b       	or	r25, r18
    1edc:	21 e0       	ldi	r18, 0x01	; 1
    1ede:	15 17       	cp	r17, r21
    1ee0:	08 f0       	brcs	.+2      	; 0x1ee4 <__vector_14+0x1e8>
    1ee2:	20 e0       	ldi	r18, 0x00	; 0
    1ee4:	59 2f       	mov	r21, r25
    1ee6:	51 0f       	add	r21, r17
    1ee8:	91 e0       	ldi	r25, 0x01	; 1
    1eea:	51 17       	cp	r21, r17
    1eec:	08 f0       	brcs	.+2      	; 0x1ef0 <__vector_14+0x1f4>
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	29 2b       	or	r18, r25
    1ef2:	91 e0       	ldi	r25, 0x01	; 1
    1ef4:	b6 17       	cp	r27, r22
    1ef6:	08 f0       	brcs	.+2      	; 0x1efa <__vector_14+0x1fe>
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	62 2f       	mov	r22, r18
    1efc:	6b 0f       	add	r22, r27
    1efe:	21 e0       	ldi	r18, 0x01	; 1
    1f00:	6b 17       	cp	r22, r27
    1f02:	08 f0       	brcs	.+2      	; 0x1f06 <__vector_14+0x20a>
    1f04:	20 e0       	ldi	r18, 0x00	; 0
    1f06:	92 2b       	or	r25, r18
    1f08:	21 e0       	ldi	r18, 0x01	; 1
    1f0a:	a7 17       	cp	r26, r23
    1f0c:	08 f0       	brcs	.+2      	; 0x1f10 <__vector_14+0x214>
    1f0e:	20 e0       	ldi	r18, 0x00	; 0
    1f10:	79 2f       	mov	r23, r25
    1f12:	7a 0f       	add	r23, r26
    1f14:	91 e0       	ldi	r25, 0x01	; 1
    1f16:	7a 17       	cp	r23, r26
    1f18:	08 f0       	brcs	.+2      	; 0x1f1c <__vector_14+0x220>
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	29 2b       	or	r18, r25
    1f1e:	91 e0       	ldi	r25, 0x01	; 1
    1f20:	f8 17       	cp	r31, r24
    1f22:	08 f0       	brcs	.+2      	; 0x1f26 <__vector_14+0x22a>
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	82 2f       	mov	r24, r18
    1f28:	8f 0f       	add	r24, r31
    1f2a:	21 e0       	ldi	r18, 0x01	; 1
    1f2c:	8f 17       	cp	r24, r31
    1f2e:	08 f0       	brcs	.+2      	; 0x1f32 <__vector_14+0x236>
    1f30:	20 e0       	ldi	r18, 0x00	; 0
    1f32:	92 2b       	or	r25, r18
    1f34:	2e 2d       	mov	r18, r14
    1f36:	9e 0f       	add	r25, r30
    1f38:	02 e0       	ldi	r16, 0x02	; 2
    1f3a:	0e 94 89 2f 	call	0x5f12	; 0x5f12 <__ashrdi3>
    1f3e:	29 83       	std	Y+1, r18	; 0x01
    1f40:	3a 83       	std	Y+2, r19	; 0x02
    1f42:	4b 83       	std	Y+3, r20	; 0x03
    1f44:	5c 83       	std	Y+4, r21	; 0x04
    1f46:	6d 83       	std	Y+5, r22	; 0x05
    1f48:	7e 83       	std	Y+6, r23	; 0x06
    1f4a:	8f 83       	std	Y+7, r24	; 0x07
    1f4c:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1f4e:	60 91 6a 50 	lds	r22, 0x506A
    1f52:	70 91 6b 50 	lds	r23, 0x506B
    1f56:	80 91 6c 50 	lds	r24, 0x506C
    1f5a:	90 91 6d 50 	lds	r25, 0x506D
    1f5e:	19 81       	ldd	r17, Y+1	; 0x01
    1f60:	0a 81       	ldd	r16, Y+2	; 0x02
    1f62:	fb 80       	ldd	r15, Y+3	; 0x03
    1f64:	ec 80       	ldd	r14, Y+4	; 0x04
    1f66:	dd 80       	ldd	r13, Y+5	; 0x05
    1f68:	ce 80       	ldd	r12, Y+6	; 0x06
    1f6a:	bf 80       	ldd	r11, Y+7	; 0x07
    1f6c:	a8 84       	ldd	r10, Y+8	; 0x08
    1f6e:	20 91 ac 50 	lds	r18, 0x50AC
    1f72:	30 91 ad 50 	lds	r19, 0x50AD
    1f76:	40 e0       	ldi	r20, 0x00	; 0
    1f78:	50 e0       	ldi	r21, 0x00	; 0
    1f7a:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    1f7e:	dc 01       	movw	r26, r24
    1f80:	cb 01       	movw	r24, r22
    1f82:	88 0f       	add	r24, r24
    1f84:	99 1f       	adc	r25, r25
    1f86:	88 0f       	add	r24, r24
    1f88:	99 1f       	adc	r25, r25
    1f8a:	80 90 68 50 	lds	r8, 0x5068
    1f8e:	90 90 69 50 	lds	r9, 0x5069
    1f92:	88 0e       	add	r8, r24
    1f94:	99 1e       	adc	r9, r25
    1f96:	21 2f       	mov	r18, r17
    1f98:	30 2f       	mov	r19, r16
    1f9a:	4f 2d       	mov	r20, r15
    1f9c:	5e 2d       	mov	r21, r14
    1f9e:	6d 2d       	mov	r22, r13
    1fa0:	7c 2d       	mov	r23, r12
    1fa2:	8b 2d       	mov	r24, r11
    1fa4:	9a 2d       	mov	r25, r10
    1fa6:	0f 2e       	mov	r0, r31
    1fa8:	f0 ea       	ldi	r31, 0xA0	; 160
    1faa:	af 2e       	mov	r10, r31
    1fac:	f0 2d       	mov	r31, r0
    1fae:	0f 2e       	mov	r0, r31
    1fb0:	f5 e2       	ldi	r31, 0x25	; 37
    1fb2:	bf 2e       	mov	r11, r31
    1fb4:	f0 2d       	mov	r31, r0
    1fb6:	0f 2e       	mov	r0, r31
    1fb8:	f6 e2       	ldi	r31, 0x26	; 38
    1fba:	cf 2e       	mov	r12, r31
    1fbc:	f0 2d       	mov	r31, r0
    1fbe:	dd 24       	eor	r13, r13
    1fc0:	ee 24       	eor	r14, r14
    1fc2:	ff 24       	eor	r15, r15
    1fc4:	00 e0       	ldi	r16, 0x00	; 0
    1fc6:	10 e0       	ldi	r17, 0x00	; 0
    1fc8:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__muldi3>
    1fcc:	aa 24       	eor	r10, r10
    1fce:	aa 94       	dec	r10
    1fd0:	bb 24       	eor	r11, r11
    1fd2:	ba 94       	dec	r11
    1fd4:	0f 2e       	mov	r0, r31
    1fd6:	ff e7       	ldi	r31, 0x7F	; 127
    1fd8:	cf 2e       	mov	r12, r31
    1fda:	f0 2d       	mov	r31, r0
    1fdc:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <__divdi3>
    1fe0:	01 e0       	ldi	r16, 0x01	; 1
    1fe2:	0e 94 15 2f 	call	0x5e2a	; 0x5e2a <__ashldi3>
    1fe6:	0f 2e       	mov	r0, r31
    1fe8:	f3 e0       	ldi	r31, 0x03	; 3
    1fea:	af 2e       	mov	r10, r31
    1fec:	f0 2d       	mov	r31, r0
    1fee:	bb 24       	eor	r11, r11
    1ff0:	cc 24       	eor	r12, r12
    1ff2:	00 e0       	ldi	r16, 0x00	; 0
    1ff4:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <__divdi3>
    1ff8:	f4 01       	movw	r30, r8
    1ffa:	20 83       	st	Z, r18
    1ffc:	31 83       	std	Z+1, r19	; 0x01
    1ffe:	42 83       	std	Z+2, r20	; 0x02
    2000:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    2002:	80 91 4d 40 	lds	r24, 0x404D
    2006:	88 23       	and	r24, r24
    2008:	09 f1       	breq	.+66     	; 0x204c <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    200a:	60 91 6a 50 	lds	r22, 0x506A
    200e:	70 91 6b 50 	lds	r23, 0x506B
    2012:	80 91 6c 50 	lds	r24, 0x506C
    2016:	90 91 6d 50 	lds	r25, 0x506D
    201a:	20 91 ac 50 	lds	r18, 0x50AC
    201e:	30 91 ad 50 	lds	r19, 0x50AD
    2022:	40 e0       	ldi	r20, 0x00	; 0
    2024:	50 e0       	ldi	r21, 0x00	; 0
    2026:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    202a:	dc 01       	movw	r26, r24
    202c:	cb 01       	movw	r24, r22
    202e:	9c 01       	movw	r18, r24
    2030:	22 0f       	add	r18, r18
    2032:	33 1f       	adc	r19, r19
    2034:	22 0f       	add	r18, r18
    2036:	33 1f       	adc	r19, r19
    2038:	80 91 68 50 	lds	r24, 0x5068
    203c:	90 91 69 50 	lds	r25, 0x5069
    2040:	82 0f       	add	r24, r18
    2042:	93 1f       	adc	r25, r19
    2044:	64 e0       	ldi	r22, 0x04	; 4
    2046:	70 e0       	ldi	r23, 0x00	; 0
    2048:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    204c:	80 91 6a 50 	lds	r24, 0x506A
    2050:	90 91 6b 50 	lds	r25, 0x506B
    2054:	a0 91 6c 50 	lds	r26, 0x506C
    2058:	b0 91 6d 50 	lds	r27, 0x506D
    205c:	01 96       	adiw	r24, 0x01	; 1
    205e:	a1 1d       	adc	r26, r1
    2060:	b1 1d       	adc	r27, r1
    2062:	80 93 6a 50 	sts	0x506A, r24
    2066:	90 93 6b 50 	sts	0x506B, r25
    206a:	a0 93 6c 50 	sts	0x506C, r26
    206e:	b0 93 6d 50 	sts	0x506D, r27

}
    2072:	2c 96       	adiw	r28, 0x0c	; 12
    2074:	cd bf       	out	0x3d, r28	; 61
    2076:	de bf       	out	0x3e, r29	; 62
    2078:	df 91       	pop	r29
    207a:	cf 91       	pop	r28
    207c:	ff 91       	pop	r31
    207e:	ef 91       	pop	r30
    2080:	bf 91       	pop	r27
    2082:	af 91       	pop	r26
    2084:	9f 91       	pop	r25
    2086:	8f 91       	pop	r24
    2088:	7f 91       	pop	r23
    208a:	6f 91       	pop	r22
    208c:	5f 91       	pop	r21
    208e:	4f 91       	pop	r20
    2090:	3f 91       	pop	r19
    2092:	2f 91       	pop	r18
    2094:	1f 91       	pop	r17
    2096:	0f 91       	pop	r16
    2098:	ff 90       	pop	r15
    209a:	ef 90       	pop	r14
    209c:	df 90       	pop	r13
    209e:	cf 90       	pop	r12
    20a0:	bf 90       	pop	r11
    20a2:	af 90       	pop	r10
    20a4:	9f 90       	pop	r9
    20a6:	8f 90       	pop	r8
    20a8:	7f 90       	pop	r7
    20aa:	6f 90       	pop	r6
    20ac:	0f 90       	pop	r0
    20ae:	0b be       	out	0x3b, r0	; 59
    20b0:	0f 90       	pop	r0
    20b2:	0f be       	out	0x3f, r0	; 63
    20b4:	0f 90       	pop	r0
    20b6:	1f 90       	pop	r1
    20b8:	18 95       	reti

000020ba <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    20ba:	1f 92       	push	r1
    20bc:	0f 92       	push	r0
    20be:	0f b6       	in	r0, 0x3f	; 63
    20c0:	0f 92       	push	r0
    20c2:	0b b6       	in	r0, 0x3b	; 59
    20c4:	0f 92       	push	r0
    20c6:	11 24       	eor	r1, r1
    20c8:	6f 92       	push	r6
    20ca:	7f 92       	push	r7
    20cc:	8f 92       	push	r8
    20ce:	9f 92       	push	r9
    20d0:	af 92       	push	r10
    20d2:	bf 92       	push	r11
    20d4:	cf 92       	push	r12
    20d6:	df 92       	push	r13
    20d8:	ef 92       	push	r14
    20da:	ff 92       	push	r15
    20dc:	0f 93       	push	r16
    20de:	1f 93       	push	r17
    20e0:	2f 93       	push	r18
    20e2:	3f 93       	push	r19
    20e4:	4f 93       	push	r20
    20e6:	5f 93       	push	r21
    20e8:	6f 93       	push	r22
    20ea:	7f 93       	push	r23
    20ec:	8f 93       	push	r24
    20ee:	9f 93       	push	r25
    20f0:	af 93       	push	r26
    20f2:	bf 93       	push	r27
    20f4:	ef 93       	push	r30
    20f6:	ff 93       	push	r31
    20f8:	cf 93       	push	r28
    20fa:	df 93       	push	r29
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	2c 97       	sbiw	r28, 0x0c	; 12
    2102:	cd bf       	out	0x3d, r28	; 61
    2104:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    2106:	19 82       	std	Y+1, r1	; 0x01
    2108:	1a 82       	std	Y+2, r1	; 0x02
    210a:	1b 82       	std	Y+3, r1	; 0x03
    210c:	1c 82       	std	Y+4, r1	; 0x04
    210e:	1d 82       	std	Y+5, r1	; 0x05
    2110:	1e 82       	std	Y+6, r1	; 0x06
    2112:	1f 82       	std	Y+7, r1	; 0x07
    2114:	18 86       	std	Y+8, r1	; 0x08
    2116:	80 e0       	ldi	r24, 0x00	; 0
    2118:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    211a:	25 e2       	ldi	r18, 0x25	; 37
    211c:	3e e3       	ldi	r19, 0x3E	; 62
    211e:	88 24       	eor	r8, r8
    2120:	8a 94       	dec	r8
    2122:	ac 01       	movw	r20, r24
    2124:	f9 01       	movw	r30, r18
    2126:	e8 0f       	add	r30, r24
    2128:	f9 1f       	adc	r31, r25
    212a:	60 81       	ld	r22, Z
    212c:	66 23       	and	r22, r22
    212e:	14 f4       	brge	.+4      	; 0x2134 <__vector_77+0x7a>
    2130:	8c 86       	std	Y+12, r8	; 0x0c
    2132:	01 c0       	rjmp	.+2      	; 0x2136 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2134:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2136:	42 0f       	add	r20, r18
    2138:	53 1f       	adc	r21, r19
    213a:	fa 01       	movw	r30, r20
    213c:	40 81       	ld	r20, Z
    213e:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2140:	fc 01       	movw	r30, r24
    2142:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2144:	e2 0f       	add	r30, r18
    2146:	f3 1f       	adc	r31, r19
    2148:	40 81       	ld	r20, Z
    214a:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    214c:	fc 01       	movw	r30, r24
    214e:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2150:	e2 0f       	add	r30, r18
    2152:	f3 1f       	adc	r31, r19
    2154:	40 81       	ld	r20, Z
    2156:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    2158:	49 85       	ldd	r20, Y+9	; 0x09
    215a:	5a 85       	ldd	r21, Y+10	; 0x0a
    215c:	6b 85       	ldd	r22, Y+11	; 0x0b
    215e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2160:	a9 80       	ldd	r10, Y+1	; 0x01
    2162:	ba 80       	ldd	r11, Y+2	; 0x02
    2164:	cb 80       	ldd	r12, Y+3	; 0x03
    2166:	dc 80       	ldd	r13, Y+4	; 0x04
    2168:	ed 80       	ldd	r14, Y+5	; 0x05
    216a:	fe 80       	ldd	r15, Y+6	; 0x06
    216c:	0f 81       	ldd	r16, Y+7	; 0x07
    216e:	18 85       	ldd	r17, Y+8	; 0x08
    2170:	b4 2f       	mov	r27, r20
    2172:	a5 2f       	mov	r26, r21
    2174:	f6 2f       	mov	r31, r22
    2176:	e7 2f       	mov	r30, r23
    2178:	77 0f       	add	r23, r23
    217a:	44 0b       	sbc	r20, r20
    217c:	54 2f       	mov	r21, r20
    217e:	ba 01       	movw	r22, r20
    2180:	64 2e       	mov	r6, r20
    2182:	74 2e       	mov	r7, r20
    2184:	94 2e       	mov	r9, r20
    2186:	ab 0e       	add	r10, r27
    2188:	61 e0       	ldi	r22, 0x01	; 1
    218a:	ab 16       	cp	r10, r27
    218c:	08 f0       	brcs	.+2      	; 0x2190 <__vector_77+0xd6>
    218e:	60 e0       	ldi	r22, 0x00	; 0
    2190:	ba 0e       	add	r11, r26
    2192:	51 e0       	ldi	r21, 0x01	; 1
    2194:	ba 16       	cp	r11, r26
    2196:	08 f0       	brcs	.+2      	; 0x219a <__vector_77+0xe0>
    2198:	50 e0       	ldi	r21, 0x00	; 0
    219a:	a6 2f       	mov	r26, r22
    219c:	ab 0d       	add	r26, r11
    219e:	61 e0       	ldi	r22, 0x01	; 1
    21a0:	ab 15       	cp	r26, r11
    21a2:	08 f0       	brcs	.+2      	; 0x21a6 <__vector_77+0xec>
    21a4:	60 e0       	ldi	r22, 0x00	; 0
    21a6:	56 2b       	or	r21, r22
    21a8:	cf 0e       	add	r12, r31
    21aa:	61 e0       	ldi	r22, 0x01	; 1
    21ac:	cf 16       	cp	r12, r31
    21ae:	08 f0       	brcs	.+2      	; 0x21b2 <__vector_77+0xf8>
    21b0:	60 e0       	ldi	r22, 0x00	; 0
    21b2:	f5 2f       	mov	r31, r21
    21b4:	fc 0d       	add	r31, r12
    21b6:	51 e0       	ldi	r21, 0x01	; 1
    21b8:	fc 15       	cp	r31, r12
    21ba:	08 f0       	brcs	.+2      	; 0x21be <__vector_77+0x104>
    21bc:	50 e0       	ldi	r21, 0x00	; 0
    21be:	65 2b       	or	r22, r21
    21c0:	de 0e       	add	r13, r30
    21c2:	51 e0       	ldi	r21, 0x01	; 1
    21c4:	de 16       	cp	r13, r30
    21c6:	08 f0       	brcs	.+2      	; 0x21ca <__vector_77+0x110>
    21c8:	50 e0       	ldi	r21, 0x00	; 0
    21ca:	e6 2f       	mov	r30, r22
    21cc:	ed 0d       	add	r30, r13
    21ce:	61 e0       	ldi	r22, 0x01	; 1
    21d0:	ed 15       	cp	r30, r13
    21d2:	08 f0       	brcs	.+2      	; 0x21d6 <__vector_77+0x11c>
    21d4:	60 e0       	ldi	r22, 0x00	; 0
    21d6:	56 2b       	or	r21, r22
    21d8:	e6 0c       	add	r14, r6
    21da:	71 e0       	ldi	r23, 0x01	; 1
    21dc:	e6 14       	cp	r14, r6
    21de:	08 f0       	brcs	.+2      	; 0x21e2 <__vector_77+0x128>
    21e0:	70 e0       	ldi	r23, 0x00	; 0
    21e2:	b5 2f       	mov	r27, r21
    21e4:	be 0d       	add	r27, r14
    21e6:	51 e0       	ldi	r21, 0x01	; 1
    21e8:	be 15       	cp	r27, r14
    21ea:	08 f0       	brcs	.+2      	; 0x21ee <__vector_77+0x134>
    21ec:	50 e0       	ldi	r21, 0x00	; 0
    21ee:	75 2b       	or	r23, r21
    21f0:	f7 0c       	add	r15, r7
    21f2:	61 e0       	ldi	r22, 0x01	; 1
    21f4:	f7 14       	cp	r15, r7
    21f6:	08 f0       	brcs	.+2      	; 0x21fa <__vector_77+0x140>
    21f8:	60 e0       	ldi	r22, 0x00	; 0
    21fa:	7f 0d       	add	r23, r15
    21fc:	51 e0       	ldi	r21, 0x01	; 1
    21fe:	7f 15       	cp	r23, r15
    2200:	08 f0       	brcs	.+2      	; 0x2204 <__vector_77+0x14a>
    2202:	50 e0       	ldi	r21, 0x00	; 0
    2204:	65 2b       	or	r22, r21
    2206:	09 0d       	add	r16, r9
    2208:	51 e0       	ldi	r21, 0x01	; 1
    220a:	09 15       	cp	r16, r9
    220c:	08 f0       	brcs	.+2      	; 0x2210 <__vector_77+0x156>
    220e:	50 e0       	ldi	r21, 0x00	; 0
    2210:	60 0f       	add	r22, r16
    2212:	ff 24       	eor	r15, r15
    2214:	f3 94       	inc	r15
    2216:	60 17       	cp	r22, r16
    2218:	08 f0       	brcs	.+2      	; 0x221c <__vector_77+0x162>
    221a:	ff 24       	eor	r15, r15
    221c:	5f 29       	or	r21, r15
    221e:	41 0f       	add	r20, r17
    2220:	54 0f       	add	r21, r20
    2222:	a9 82       	std	Y+1, r10	; 0x01
    2224:	aa 83       	std	Y+2, r26	; 0x02
    2226:	fb 83       	std	Y+3, r31	; 0x03
    2228:	ec 83       	std	Y+4, r30	; 0x04
    222a:	bd 83       	std	Y+5, r27	; 0x05
    222c:	7e 83       	std	Y+6, r23	; 0x06
    222e:	6f 83       	std	Y+7, r22	; 0x07
    2230:	58 87       	std	Y+8, r21	; 0x08
    2232:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2234:	8c 30       	cpi	r24, 0x0C	; 12
    2236:	91 05       	cpc	r25, r1
    2238:	09 f0       	breq	.+2      	; 0x223c <__vector_77+0x182>
    223a:	73 cf       	rjmp	.-282    	; 0x2122 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    223c:	e9 80       	ldd	r14, Y+1	; 0x01
    223e:	fa 80       	ldd	r15, Y+2	; 0x02
    2240:	0b 81       	ldd	r16, Y+3	; 0x03
    2242:	1c 81       	ldd	r17, Y+4	; 0x04
    2244:	bd 81       	ldd	r27, Y+5	; 0x05
    2246:	ae 81       	ldd	r26, Y+6	; 0x06
    2248:	ff 81       	ldd	r31, Y+7	; 0x07
    224a:	e8 85       	ldd	r30, Y+8	; 0x08
    224c:	2e 2d       	mov	r18, r14
    224e:	3f 2d       	mov	r19, r15
    2250:	40 2f       	mov	r20, r16
    2252:	51 2f       	mov	r21, r17
    2254:	6b 2f       	mov	r22, r27
    2256:	7a 2f       	mov	r23, r26
    2258:	8f 2f       	mov	r24, r31
    225a:	9e 2f       	mov	r25, r30
    225c:	ee 23       	and	r30, r30
    225e:	0c f0       	brlt	.+2      	; 0x2262 <__vector_77+0x1a8>
    2260:	4a c0       	rjmp	.+148    	; 0x22f6 <__vector_77+0x23c>
    2262:	93 e0       	ldi	r25, 0x03	; 3
    2264:	e9 0e       	add	r14, r25
    2266:	91 e0       	ldi	r25, 0x01	; 1
    2268:	e2 16       	cp	r14, r18
    226a:	08 f0       	brcs	.+2      	; 0x226e <__vector_77+0x1b4>
    226c:	90 e0       	ldi	r25, 0x00	; 0
    226e:	21 e0       	ldi	r18, 0x01	; 1
    2270:	f3 16       	cp	r15, r19
    2272:	08 f0       	brcs	.+2      	; 0x2276 <__vector_77+0x1bc>
    2274:	20 e0       	ldi	r18, 0x00	; 0
    2276:	39 2f       	mov	r19, r25
    2278:	3f 0d       	add	r19, r15
    227a:	91 e0       	ldi	r25, 0x01	; 1
    227c:	3f 15       	cp	r19, r15
    227e:	08 f0       	brcs	.+2      	; 0x2282 <__vector_77+0x1c8>
    2280:	90 e0       	ldi	r25, 0x00	; 0
    2282:	29 2b       	or	r18, r25
    2284:	91 e0       	ldi	r25, 0x01	; 1
    2286:	04 17       	cp	r16, r20
    2288:	08 f0       	brcs	.+2      	; 0x228c <__vector_77+0x1d2>
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	42 2f       	mov	r20, r18
    228e:	40 0f       	add	r20, r16
    2290:	21 e0       	ldi	r18, 0x01	; 1
    2292:	40 17       	cp	r20, r16
    2294:	08 f0       	brcs	.+2      	; 0x2298 <__vector_77+0x1de>
    2296:	20 e0       	ldi	r18, 0x00	; 0
    2298:	92 2b       	or	r25, r18
    229a:	21 e0       	ldi	r18, 0x01	; 1
    229c:	15 17       	cp	r17, r21
    229e:	08 f0       	brcs	.+2      	; 0x22a2 <__vector_77+0x1e8>
    22a0:	20 e0       	ldi	r18, 0x00	; 0
    22a2:	59 2f       	mov	r21, r25
    22a4:	51 0f       	add	r21, r17
    22a6:	91 e0       	ldi	r25, 0x01	; 1
    22a8:	51 17       	cp	r21, r17
    22aa:	08 f0       	brcs	.+2      	; 0x22ae <__vector_77+0x1f4>
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	29 2b       	or	r18, r25
    22b0:	91 e0       	ldi	r25, 0x01	; 1
    22b2:	b6 17       	cp	r27, r22
    22b4:	08 f0       	brcs	.+2      	; 0x22b8 <__vector_77+0x1fe>
    22b6:	90 e0       	ldi	r25, 0x00	; 0
    22b8:	62 2f       	mov	r22, r18
    22ba:	6b 0f       	add	r22, r27
    22bc:	21 e0       	ldi	r18, 0x01	; 1
    22be:	6b 17       	cp	r22, r27
    22c0:	08 f0       	brcs	.+2      	; 0x22c4 <__vector_77+0x20a>
    22c2:	20 e0       	ldi	r18, 0x00	; 0
    22c4:	92 2b       	or	r25, r18
    22c6:	21 e0       	ldi	r18, 0x01	; 1
    22c8:	a7 17       	cp	r26, r23
    22ca:	08 f0       	brcs	.+2      	; 0x22ce <__vector_77+0x214>
    22cc:	20 e0       	ldi	r18, 0x00	; 0
    22ce:	79 2f       	mov	r23, r25
    22d0:	7a 0f       	add	r23, r26
    22d2:	91 e0       	ldi	r25, 0x01	; 1
    22d4:	7a 17       	cp	r23, r26
    22d6:	08 f0       	brcs	.+2      	; 0x22da <__vector_77+0x220>
    22d8:	90 e0       	ldi	r25, 0x00	; 0
    22da:	29 2b       	or	r18, r25
    22dc:	91 e0       	ldi	r25, 0x01	; 1
    22de:	f8 17       	cp	r31, r24
    22e0:	08 f0       	brcs	.+2      	; 0x22e4 <__vector_77+0x22a>
    22e2:	90 e0       	ldi	r25, 0x00	; 0
    22e4:	82 2f       	mov	r24, r18
    22e6:	8f 0f       	add	r24, r31
    22e8:	21 e0       	ldi	r18, 0x01	; 1
    22ea:	8f 17       	cp	r24, r31
    22ec:	08 f0       	brcs	.+2      	; 0x22f0 <__vector_77+0x236>
    22ee:	20 e0       	ldi	r18, 0x00	; 0
    22f0:	92 2b       	or	r25, r18
    22f2:	2e 2d       	mov	r18, r14
    22f4:	9e 0f       	add	r25, r30
    22f6:	02 e0       	ldi	r16, 0x02	; 2
    22f8:	0e 94 89 2f 	call	0x5f12	; 0x5f12 <__ashrdi3>
    22fc:	29 83       	std	Y+1, r18	; 0x01
    22fe:	3a 83       	std	Y+2, r19	; 0x02
    2300:	4b 83       	std	Y+3, r20	; 0x03
    2302:	5c 83       	std	Y+4, r21	; 0x04
    2304:	6d 83       	std	Y+5, r22	; 0x05
    2306:	7e 83       	std	Y+6, r23	; 0x06
    2308:	8f 83       	std	Y+7, r24	; 0x07
    230a:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    230c:	60 91 6a 50 	lds	r22, 0x506A
    2310:	70 91 6b 50 	lds	r23, 0x506B
    2314:	80 91 6c 50 	lds	r24, 0x506C
    2318:	90 91 6d 50 	lds	r25, 0x506D
    231c:	19 81       	ldd	r17, Y+1	; 0x01
    231e:	0a 81       	ldd	r16, Y+2	; 0x02
    2320:	fb 80       	ldd	r15, Y+3	; 0x03
    2322:	ec 80       	ldd	r14, Y+4	; 0x04
    2324:	dd 80       	ldd	r13, Y+5	; 0x05
    2326:	ce 80       	ldd	r12, Y+6	; 0x06
    2328:	bf 80       	ldd	r11, Y+7	; 0x07
    232a:	a8 84       	ldd	r10, Y+8	; 0x08
    232c:	20 91 ac 50 	lds	r18, 0x50AC
    2330:	30 91 ad 50 	lds	r19, 0x50AD
    2334:	40 e0       	ldi	r20, 0x00	; 0
    2336:	50 e0       	ldi	r21, 0x00	; 0
    2338:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    233c:	dc 01       	movw	r26, r24
    233e:	cb 01       	movw	r24, r22
    2340:	88 0f       	add	r24, r24
    2342:	99 1f       	adc	r25, r25
    2344:	88 0f       	add	r24, r24
    2346:	99 1f       	adc	r25, r25
    2348:	80 90 68 50 	lds	r8, 0x5068
    234c:	90 90 69 50 	lds	r9, 0x5069
    2350:	88 0e       	add	r8, r24
    2352:	99 1e       	adc	r9, r25
    2354:	21 2f       	mov	r18, r17
    2356:	30 2f       	mov	r19, r16
    2358:	4f 2d       	mov	r20, r15
    235a:	5e 2d       	mov	r21, r14
    235c:	6d 2d       	mov	r22, r13
    235e:	7c 2d       	mov	r23, r12
    2360:	8b 2d       	mov	r24, r11
    2362:	9a 2d       	mov	r25, r10
    2364:	0f 2e       	mov	r0, r31
    2366:	f0 ea       	ldi	r31, 0xA0	; 160
    2368:	af 2e       	mov	r10, r31
    236a:	f0 2d       	mov	r31, r0
    236c:	0f 2e       	mov	r0, r31
    236e:	f5 e2       	ldi	r31, 0x25	; 37
    2370:	bf 2e       	mov	r11, r31
    2372:	f0 2d       	mov	r31, r0
    2374:	0f 2e       	mov	r0, r31
    2376:	f6 e2       	ldi	r31, 0x26	; 38
    2378:	cf 2e       	mov	r12, r31
    237a:	f0 2d       	mov	r31, r0
    237c:	dd 24       	eor	r13, r13
    237e:	ee 24       	eor	r14, r14
    2380:	ff 24       	eor	r15, r15
    2382:	00 e0       	ldi	r16, 0x00	; 0
    2384:	10 e0       	ldi	r17, 0x00	; 0
    2386:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <__muldi3>
    238a:	aa 24       	eor	r10, r10
    238c:	aa 94       	dec	r10
    238e:	bb 24       	eor	r11, r11
    2390:	ba 94       	dec	r11
    2392:	0f 2e       	mov	r0, r31
    2394:	ff e7       	ldi	r31, 0x7F	; 127
    2396:	cf 2e       	mov	r12, r31
    2398:	f0 2d       	mov	r31, r0
    239a:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <__divdi3>
    239e:	01 e0       	ldi	r16, 0x01	; 1
    23a0:	0e 94 15 2f 	call	0x5e2a	; 0x5e2a <__ashldi3>
    23a4:	0f 2e       	mov	r0, r31
    23a6:	f3 e0       	ldi	r31, 0x03	; 3
    23a8:	af 2e       	mov	r10, r31
    23aa:	f0 2d       	mov	r31, r0
    23ac:	bb 24       	eor	r11, r11
    23ae:	cc 24       	eor	r12, r12
    23b0:	00 e0       	ldi	r16, 0x00	; 0
    23b2:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <__divdi3>
    23b6:	f4 01       	movw	r30, r8
    23b8:	20 83       	st	Z, r18
    23ba:	31 83       	std	Z+1, r19	; 0x01
    23bc:	42 83       	std	Z+2, r20	; 0x02
    23be:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    23c0:	80 91 4d 40 	lds	r24, 0x404D
    23c4:	88 23       	and	r24, r24
    23c6:	09 f1       	breq	.+66     	; 0x240a <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    23c8:	60 91 6a 50 	lds	r22, 0x506A
    23cc:	70 91 6b 50 	lds	r23, 0x506B
    23d0:	80 91 6c 50 	lds	r24, 0x506C
    23d4:	90 91 6d 50 	lds	r25, 0x506D
    23d8:	20 91 ac 50 	lds	r18, 0x50AC
    23dc:	30 91 ad 50 	lds	r19, 0x50AD
    23e0:	40 e0       	ldi	r20, 0x00	; 0
    23e2:	50 e0       	ldi	r21, 0x00	; 0
    23e4:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    23e8:	dc 01       	movw	r26, r24
    23ea:	cb 01       	movw	r24, r22
    23ec:	9c 01       	movw	r18, r24
    23ee:	22 0f       	add	r18, r18
    23f0:	33 1f       	adc	r19, r19
    23f2:	22 0f       	add	r18, r18
    23f4:	33 1f       	adc	r19, r19
    23f6:	80 91 68 50 	lds	r24, 0x5068
    23fa:	90 91 69 50 	lds	r25, 0x5069
    23fe:	82 0f       	add	r24, r18
    2400:	93 1f       	adc	r25, r19
    2402:	64 e0       	ldi	r22, 0x04	; 4
    2404:	70 e0       	ldi	r23, 0x00	; 0
    2406:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    240a:	80 91 6a 50 	lds	r24, 0x506A
    240e:	90 91 6b 50 	lds	r25, 0x506B
    2412:	a0 91 6c 50 	lds	r26, 0x506C
    2416:	b0 91 6d 50 	lds	r27, 0x506D
    241a:	01 96       	adiw	r24, 0x01	; 1
    241c:	a1 1d       	adc	r26, r1
    241e:	b1 1d       	adc	r27, r1
    2420:	80 93 6a 50 	sts	0x506A, r24
    2424:	90 93 6b 50 	sts	0x506B, r25
    2428:	a0 93 6c 50 	sts	0x506C, r26
    242c:	b0 93 6d 50 	sts	0x506D, r27
}
    2430:	2c 96       	adiw	r28, 0x0c	; 12
    2432:	cd bf       	out	0x3d, r28	; 61
    2434:	de bf       	out	0x3e, r29	; 62
    2436:	df 91       	pop	r29
    2438:	cf 91       	pop	r28
    243a:	ff 91       	pop	r31
    243c:	ef 91       	pop	r30
    243e:	bf 91       	pop	r27
    2440:	af 91       	pop	r26
    2442:	9f 91       	pop	r25
    2444:	8f 91       	pop	r24
    2446:	7f 91       	pop	r23
    2448:	6f 91       	pop	r22
    244a:	5f 91       	pop	r21
    244c:	4f 91       	pop	r20
    244e:	3f 91       	pop	r19
    2450:	2f 91       	pop	r18
    2452:	1f 91       	pop	r17
    2454:	0f 91       	pop	r16
    2456:	ff 90       	pop	r15
    2458:	ef 90       	pop	r14
    245a:	df 90       	pop	r13
    245c:	cf 90       	pop	r12
    245e:	bf 90       	pop	r11
    2460:	af 90       	pop	r10
    2462:	9f 90       	pop	r9
    2464:	8f 90       	pop	r8
    2466:	7f 90       	pop	r7
    2468:	6f 90       	pop	r6
    246a:	0f 90       	pop	r0
    246c:	0b be       	out	0x3b, r0	; 59
    246e:	0f 90       	pop	r0
    2470:	0f be       	out	0x3f, r0	; 63
    2472:	0f 90       	pop	r0
    2474:	1f 90       	pop	r1
    2476:	18 95       	reti

00002478 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	SPICS(TRUE);
    2478:	81 e0       	ldi	r24, 0x01	; 1
    247a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    247e:	82 e0       	ldi	r24, 0x02	; 2
    2480:	e0 ea       	ldi	r30, 0xA0	; 160
    2482:	f6 e0       	ldi	r31, 0x06	; 6
    2484:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2486:	8a ea       	ldi	r24, 0xAA	; 170
    2488:	e0 ec       	ldi	r30, 0xC0	; 192
    248a:	f8 e0       	ldi	r31, 0x08	; 8
    248c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    248e:	82 81       	ldd	r24, Z+2	; 0x02
    2490:	88 23       	and	r24, r24
    2492:	ec f7       	brge	.-6      	; 0x248e <sampleCurrentChannel+0x16>
	SPIBuffer[SPICount] = SPIC.DATA;
    2494:	90 91 a5 50 	lds	r25, 0x50A5
    2498:	e0 ec       	ldi	r30, 0xC0	; 192
    249a:	f8 e0       	ldi	r31, 0x08	; 8
    249c:	83 81       	ldd	r24, Z+3	; 0x03
    249e:	a5 e2       	ldi	r26, 0x25	; 37
    24a0:	be e3       	ldi	r27, 0x3E	; 62
    24a2:	a9 0f       	add	r26, r25
    24a4:	b1 1d       	adc	r27, r1
    24a6:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    24a8:	8a ea       	ldi	r24, 0xAA	; 170
    24aa:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    24ac:	82 81       	ldd	r24, Z+2	; 0x02
    24ae:	88 23       	and	r24, r24
    24b0:	ec f7       	brge	.-6      	; 0x24ac <sampleCurrentChannel+0x34>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    24b2:	a0 91 a5 50 	lds	r26, 0x50A5
    24b6:	b0 e0       	ldi	r27, 0x00	; 0
    24b8:	e0 ec       	ldi	r30, 0xC0	; 192
    24ba:	f8 e0       	ldi	r31, 0x08	; 8
    24bc:	83 81       	ldd	r24, Z+3	; 0x03
    24be:	aa 5d       	subi	r26, 0xDA	; 218
    24c0:	b1 4c       	sbci	r27, 0xC1	; 193
    24c2:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    24c4:	8a ea       	ldi	r24, 0xAA	; 170
    24c6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    24c8:	82 81       	ldd	r24, Z+2	; 0x02
    24ca:	88 23       	and	r24, r24
    24cc:	ec f7       	brge	.-6      	; 0x24c8 <sampleCurrentChannel+0x50>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    24ce:	e0 91 a5 50 	lds	r30, 0x50A5
    24d2:	f0 e0       	ldi	r31, 0x00	; 0
    24d4:	a0 ec       	ldi	r26, 0xC0	; 192
    24d6:	b8 e0       	ldi	r27, 0x08	; 8
    24d8:	13 96       	adiw	r26, 0x03	; 3
    24da:	8c 91       	ld	r24, X
    24dc:	e9 5d       	subi	r30, 0xD9	; 217
    24de:	f1 4c       	sbci	r31, 0xC1	; 193
    24e0:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    24e2:	82 e0       	ldi	r24, 0x02	; 2
    24e4:	e0 ea       	ldi	r30, 0xA0	; 160
    24e6:	f6 e0       	ldi	r31, 0x06	; 6
    24e8:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    24ea:	80 91 a5 50 	lds	r24, 0x50A5
    24ee:	8d 5f       	subi	r24, 0xFD	; 253
    24f0:	80 93 a5 50 	sts	0x50A5, r24
	SPICS(FALSE);
    24f4:	80 e0       	ldi	r24, 0x00	; 0
    24f6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
}
    24fa:	08 95       	ret

000024fc <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    24fc:	1f 92       	push	r1
    24fe:	0f 92       	push	r0
    2500:	0f b6       	in	r0, 0x3f	; 63
    2502:	0f 92       	push	r0
    2504:	0b b6       	in	r0, 0x3b	; 59
    2506:	0f 92       	push	r0
    2508:	11 24       	eor	r1, r1
    250a:	2f 93       	push	r18
    250c:	3f 93       	push	r19
    250e:	4f 93       	push	r20
    2510:	5f 93       	push	r21
    2512:	6f 93       	push	r22
    2514:	7f 93       	push	r23
    2516:	8f 93       	push	r24
    2518:	9f 93       	push	r25
    251a:	af 93       	push	r26
    251c:	bf 93       	push	r27
    251e:	ef 93       	push	r30
    2520:	ff 93       	push	r31
	sampleCurrentChannel();
    2522:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
	SPICount = 0;
    2526:	10 92 a5 50 	sts	0x50A5, r1
}
    252a:	ff 91       	pop	r31
    252c:	ef 91       	pop	r30
    252e:	bf 91       	pop	r27
    2530:	af 91       	pop	r26
    2532:	9f 91       	pop	r25
    2534:	8f 91       	pop	r24
    2536:	7f 91       	pop	r23
    2538:	6f 91       	pop	r22
    253a:	5f 91       	pop	r21
    253c:	4f 91       	pop	r20
    253e:	3f 91       	pop	r19
    2540:	2f 91       	pop	r18
    2542:	0f 90       	pop	r0
    2544:	0b be       	out	0x3b, r0	; 59
    2546:	0f 90       	pop	r0
    2548:	0f be       	out	0x3f, r0	; 63
    254a:	0f 90       	pop	r0
    254c:	1f 90       	pop	r1
    254e:	18 95       	reti

00002550 <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    2550:	1f 92       	push	r1
    2552:	0f 92       	push	r0
    2554:	0f b6       	in	r0, 0x3f	; 63
    2556:	0f 92       	push	r0
    2558:	0b b6       	in	r0, 0x3b	; 59
    255a:	0f 92       	push	r0
    255c:	11 24       	eor	r1, r1
    255e:	2f 93       	push	r18
    2560:	3f 93       	push	r19
    2562:	4f 93       	push	r20
    2564:	5f 93       	push	r21
    2566:	6f 93       	push	r22
    2568:	7f 93       	push	r23
    256a:	8f 93       	push	r24
    256c:	9f 93       	push	r25
    256e:	af 93       	push	r26
    2570:	bf 93       	push	r27
    2572:	ef 93       	push	r30
    2574:	ff 93       	push	r31
	sampleCurrentChannel();
    2576:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
}
    257a:	ff 91       	pop	r31
    257c:	ef 91       	pop	r30
    257e:	bf 91       	pop	r27
    2580:	af 91       	pop	r26
    2582:	9f 91       	pop	r25
    2584:	8f 91       	pop	r24
    2586:	7f 91       	pop	r23
    2588:	6f 91       	pop	r22
    258a:	5f 91       	pop	r21
    258c:	4f 91       	pop	r20
    258e:	3f 91       	pop	r19
    2590:	2f 91       	pop	r18
    2592:	0f 90       	pop	r0
    2594:	0b be       	out	0x3b, r0	; 59
    2596:	0f 90       	pop	r0
    2598:	0f be       	out	0x3f, r0	; 63
    259a:	0f 90       	pop	r0
    259c:	1f 90       	pop	r1
    259e:	18 95       	reti

000025a0 <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    25a0:	1f 92       	push	r1
    25a2:	0f 92       	push	r0
    25a4:	0f b6       	in	r0, 0x3f	; 63
    25a6:	0f 92       	push	r0
    25a8:	0b b6       	in	r0, 0x3b	; 59
    25aa:	0f 92       	push	r0
    25ac:	11 24       	eor	r1, r1
    25ae:	2f 93       	push	r18
    25b0:	3f 93       	push	r19
    25b2:	4f 93       	push	r20
    25b4:	5f 93       	push	r21
    25b6:	6f 93       	push	r22
    25b8:	7f 93       	push	r23
    25ba:	8f 93       	push	r24
    25bc:	9f 93       	push	r25
    25be:	af 93       	push	r26
    25c0:	bf 93       	push	r27
    25c2:	ef 93       	push	r30
    25c4:	ff 93       	push	r31
	sampleCurrentChannel();
    25c6:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
}
    25ca:	ff 91       	pop	r31
    25cc:	ef 91       	pop	r30
    25ce:	bf 91       	pop	r27
    25d0:	af 91       	pop	r26
    25d2:	9f 91       	pop	r25
    25d4:	8f 91       	pop	r24
    25d6:	7f 91       	pop	r23
    25d8:	6f 91       	pop	r22
    25da:	5f 91       	pop	r21
    25dc:	4f 91       	pop	r20
    25de:	3f 91       	pop	r19
    25e0:	2f 91       	pop	r18
    25e2:	0f 90       	pop	r0
    25e4:	0b be       	out	0x3b, r0	; 59
    25e6:	0f 90       	pop	r0
    25e8:	0f be       	out	0x3f, r0	; 63
    25ea:	0f 90       	pop	r0
    25ec:	1f 90       	pop	r1
    25ee:	18 95       	reti

000025f0 <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    25f0:	1f 92       	push	r1
    25f2:	0f 92       	push	r0
    25f4:	0f b6       	in	r0, 0x3f	; 63
    25f6:	0f 92       	push	r0
    25f8:	0b b6       	in	r0, 0x3b	; 59
    25fa:	0f 92       	push	r0
    25fc:	11 24       	eor	r1, r1
    25fe:	2f 93       	push	r18
    2600:	3f 93       	push	r19
    2602:	4f 93       	push	r20
    2604:	5f 93       	push	r21
    2606:	6f 93       	push	r22
    2608:	7f 93       	push	r23
    260a:	8f 93       	push	r24
    260c:	9f 93       	push	r25
    260e:	af 93       	push	r26
    2610:	bf 93       	push	r27
    2612:	ef 93       	push	r30
    2614:	ff 93       	push	r31
	sampleCurrentChannel();
    2616:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
}
    261a:	ff 91       	pop	r31
    261c:	ef 91       	pop	r30
    261e:	bf 91       	pop	r27
    2620:	af 91       	pop	r26
    2622:	9f 91       	pop	r25
    2624:	8f 91       	pop	r24
    2626:	7f 91       	pop	r23
    2628:	6f 91       	pop	r22
    262a:	5f 91       	pop	r21
    262c:	4f 91       	pop	r20
    262e:	3f 91       	pop	r19
    2630:	2f 91       	pop	r18
    2632:	0f 90       	pop	r0
    2634:	0b be       	out	0x3b, r0	; 59
    2636:	0f 90       	pop	r0
    2638:	0f be       	out	0x3f, r0	; 63
    263a:	0f 90       	pop	r0
    263c:	1f 90       	pop	r1
    263e:	18 95       	reti

00002640 <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    2640:	1f 92       	push	r1
    2642:	0f 92       	push	r0
    2644:	0f b6       	in	r0, 0x3f	; 63
    2646:	0f 92       	push	r0
    2648:	0b b6       	in	r0, 0x3b	; 59
    264a:	0f 92       	push	r0
    264c:	11 24       	eor	r1, r1
    264e:	2f 93       	push	r18
    2650:	3f 93       	push	r19
    2652:	4f 93       	push	r20
    2654:	5f 93       	push	r21
    2656:	6f 93       	push	r22
    2658:	7f 93       	push	r23
    265a:	8f 93       	push	r24
    265c:	9f 93       	push	r25
    265e:	af 93       	push	r26
    2660:	bf 93       	push	r27
    2662:	ef 93       	push	r30
    2664:	ff 93       	push	r31
	sampleCurrentChannel();
    2666:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
	SPICount = 0;
    266a:	10 92 a5 50 	sts	0x50A5, r1
	if(PORTB.OUT & PIN1_bm) {
    266e:	e0 e2       	ldi	r30, 0x20	; 32
    2670:	f6 e0       	ldi	r31, 0x06	; 6
    2672:	84 81       	ldd	r24, Z+4	; 0x04
    2674:	81 ff       	sbrs	r24, 1
    2676:	0f c0       	rjmp	.+30     	; 0x2696 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2678:	e0 e0       	ldi	r30, 0x00	; 0
    267a:	f6 e0       	ldi	r31, 0x06	; 6
    267c:	84 81       	ldd	r24, Z+4	; 0x04
    267e:	86 ff       	sbrs	r24, 6
    2680:	05 c0       	rjmp	.+10     	; 0x268c <__vector_19+0x4c>
    2682:	82 e0       	ldi	r24, 0x02	; 2
    2684:	e0 e2       	ldi	r30, 0x20	; 32
    2686:	f6 e0       	ldi	r31, 0x06	; 6
    2688:	87 83       	std	Z+7, r24	; 0x07
    268a:	0d c0       	rjmp	.+26     	; 0x26a6 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    268c:	80 e4       	ldi	r24, 0x40	; 64
    268e:	e0 e0       	ldi	r30, 0x00	; 0
    2690:	f6 e0       	ldi	r31, 0x06	; 6
    2692:	87 83       	std	Z+7, r24	; 0x07
    2694:	08 c0       	rjmp	.+16     	; 0x26a6 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2696:	80 e4       	ldi	r24, 0x40	; 64
    2698:	e0 e0       	ldi	r30, 0x00	; 0
    269a:	f6 e0       	ldi	r31, 0x06	; 6
    269c:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    269e:	82 e0       	ldi	r24, 0x02	; 2
    26a0:	e0 e2       	ldi	r30, 0x20	; 32
    26a2:	f6 e0       	ldi	r31, 0x06	; 6
    26a4:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    26a6:	ff 91       	pop	r31
    26a8:	ef 91       	pop	r30
    26aa:	bf 91       	pop	r27
    26ac:	af 91       	pop	r26
    26ae:	9f 91       	pop	r25
    26b0:	8f 91       	pop	r24
    26b2:	7f 91       	pop	r23
    26b4:	6f 91       	pop	r22
    26b6:	5f 91       	pop	r21
    26b8:	4f 91       	pop	r20
    26ba:	3f 91       	pop	r19
    26bc:	2f 91       	pop	r18
    26be:	0f 90       	pop	r0
    26c0:	0b be       	out	0x3b, r0	; 59
    26c2:	0f 90       	pop	r0
    26c4:	0f be       	out	0x3f, r0	; 63
    26c6:	0f 90       	pop	r0
    26c8:	1f 90       	pop	r1
    26ca:	18 95       	reti

000026cc <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    26cc:	1f 92       	push	r1
    26ce:	0f 92       	push	r0
    26d0:	0f b6       	in	r0, 0x3f	; 63
    26d2:	0f 92       	push	r0
    26d4:	0b b6       	in	r0, 0x3b	; 59
    26d6:	0f 92       	push	r0
    26d8:	11 24       	eor	r1, r1
    26da:	2f 93       	push	r18
    26dc:	3f 93       	push	r19
    26de:	4f 93       	push	r20
    26e0:	5f 93       	push	r21
    26e2:	6f 93       	push	r22
    26e4:	7f 93       	push	r23
    26e6:	8f 93       	push	r24
    26e8:	9f 93       	push	r25
    26ea:	af 93       	push	r26
    26ec:	bf 93       	push	r27
    26ee:	ef 93       	push	r30
    26f0:	ff 93       	push	r31
	sampleCurrentChannel();
    26f2:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
}
    26f6:	ff 91       	pop	r31
    26f8:	ef 91       	pop	r30
    26fa:	bf 91       	pop	r27
    26fc:	af 91       	pop	r26
    26fe:	9f 91       	pop	r25
    2700:	8f 91       	pop	r24
    2702:	7f 91       	pop	r23
    2704:	6f 91       	pop	r22
    2706:	5f 91       	pop	r21
    2708:	4f 91       	pop	r20
    270a:	3f 91       	pop	r19
    270c:	2f 91       	pop	r18
    270e:	0f 90       	pop	r0
    2710:	0b be       	out	0x3b, r0	; 59
    2712:	0f 90       	pop	r0
    2714:	0f be       	out	0x3f, r0	; 63
    2716:	0f 90       	pop	r0
    2718:	1f 90       	pop	r1
    271a:	18 95       	reti

0000271c <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    271c:	1f 92       	push	r1
    271e:	0f 92       	push	r0
    2720:	0f b6       	in	r0, 0x3f	; 63
    2722:	0f 92       	push	r0
    2724:	0b b6       	in	r0, 0x3b	; 59
    2726:	0f 92       	push	r0
    2728:	11 24       	eor	r1, r1
    272a:	2f 93       	push	r18
    272c:	3f 93       	push	r19
    272e:	4f 93       	push	r20
    2730:	5f 93       	push	r21
    2732:	6f 93       	push	r22
    2734:	7f 93       	push	r23
    2736:	8f 93       	push	r24
    2738:	9f 93       	push	r25
    273a:	af 93       	push	r26
    273c:	bf 93       	push	r27
    273e:	ef 93       	push	r30
    2740:	ff 93       	push	r31
	sampleCurrentChannel();
    2742:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
}
    2746:	ff 91       	pop	r31
    2748:	ef 91       	pop	r30
    274a:	bf 91       	pop	r27
    274c:	af 91       	pop	r26
    274e:	9f 91       	pop	r25
    2750:	8f 91       	pop	r24
    2752:	7f 91       	pop	r23
    2754:	6f 91       	pop	r22
    2756:	5f 91       	pop	r21
    2758:	4f 91       	pop	r20
    275a:	3f 91       	pop	r19
    275c:	2f 91       	pop	r18
    275e:	0f 90       	pop	r0
    2760:	0b be       	out	0x3b, r0	; 59
    2762:	0f 90       	pop	r0
    2764:	0f be       	out	0x3f, r0	; 63
    2766:	0f 90       	pop	r0
    2768:	1f 90       	pop	r1
    276a:	18 95       	reti

0000276c <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    276c:	1f 92       	push	r1
    276e:	0f 92       	push	r0
    2770:	0f b6       	in	r0, 0x3f	; 63
    2772:	0f 92       	push	r0
    2774:	0b b6       	in	r0, 0x3b	; 59
    2776:	0f 92       	push	r0
    2778:	11 24       	eor	r1, r1
    277a:	2f 93       	push	r18
    277c:	3f 93       	push	r19
    277e:	4f 93       	push	r20
    2780:	5f 93       	push	r21
    2782:	6f 93       	push	r22
    2784:	7f 93       	push	r23
    2786:	8f 93       	push	r24
    2788:	9f 93       	push	r25
    278a:	af 93       	push	r26
    278c:	bf 93       	push	r27
    278e:	ef 93       	push	r30
    2790:	ff 93       	push	r31
	sampleCurrentChannel();
    2792:	0e 94 3c 12 	call	0x2478	; 0x2478 <sampleCurrentChannel>
}
    2796:	ff 91       	pop	r31
    2798:	ef 91       	pop	r30
    279a:	bf 91       	pop	r27
    279c:	af 91       	pop	r26
    279e:	9f 91       	pop	r25
    27a0:	8f 91       	pop	r24
    27a2:	7f 91       	pop	r23
    27a4:	6f 91       	pop	r22
    27a6:	5f 91       	pop	r21
    27a8:	4f 91       	pop	r20
    27aa:	3f 91       	pop	r19
    27ac:	2f 91       	pop	r18
    27ae:	0f 90       	pop	r0
    27b0:	0b be       	out	0x3b, r0	; 59
    27b2:	0f 90       	pop	r0
    27b4:	0f be       	out	0x3f, r0	; 63
    27b6:	0f 90       	pop	r0
    27b8:	1f 90       	pop	r1
    27ba:	18 95       	reti

000027bc <writeSE2FRAM>:
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    27bc:	ff 92       	push	r15
    27be:	0f 93       	push	r16
    27c0:	1f 93       	push	r17
    27c2:	cf 93       	push	r28
    27c4:	df 93       	push	r29
    27c6:	cd b7       	in	r28, 0x3d	; 61
    27c8:	de b7       	in	r29, 0x3e	; 62
    27ca:	28 97       	sbiw	r28, 0x08	; 8
    27cc:	cd bf       	out	0x3d, r28	; 61
    27ce:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    27d0:	19 82       	std	Y+1, r1	; 0x01
    27d2:	1a 82       	std	Y+2, r1	; 0x02
    27d4:	1b 82       	std	Y+3, r1	; 0x03
    27d6:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    27d8:	80 91 6a 50 	lds	r24, 0x506A
    27dc:	90 91 6b 50 	lds	r25, 0x506B
    27e0:	a0 91 6c 50 	lds	r26, 0x506C
    27e4:	b0 91 6d 50 	lds	r27, 0x506D
    27e8:	01 96       	adiw	r24, 0x01	; 1
    27ea:	a1 1d       	adc	r26, r1
    27ec:	b1 1d       	adc	r27, r1
    27ee:	80 93 6a 50 	sts	0x506A, r24
    27f2:	90 93 6b 50 	sts	0x506B, r25
    27f6:	a0 93 6c 50 	sts	0x506C, r26
    27fa:	b0 93 6d 50 	sts	0x506D, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    27fe:	80 ed       	ldi	r24, 0xD0	; 208
    2800:	80 93 c0 08 	sts	0x08C0, r24
    2804:	20 e0       	ldi	r18, 0x00	; 0
    2806:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2808:	05 e2       	ldi	r16, 0x25	; 37
    280a:	1e e3       	ldi	r17, 0x3E	; 62
    280c:	ff 24       	eor	r15, r15
    280e:	fa 94       	dec	r15
    2810:	c9 01       	movw	r24, r18
    2812:	f8 01       	movw	r30, r16
    2814:	e2 0f       	add	r30, r18
    2816:	f3 1f       	adc	r31, r19
    2818:	40 81       	ld	r20, Z
    281a:	44 23       	and	r20, r20
    281c:	14 f4       	brge	.+4      	; 0x2822 <writeSE2FRAM+0x66>
    281e:	f8 86       	std	Y+8, r15	; 0x08
    2820:	01 c0       	rjmp	.+2      	; 0x2824 <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2822:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2824:	80 0f       	add	r24, r16
    2826:	91 1f       	adc	r25, r17
    2828:	fc 01       	movw	r30, r24
    282a:	80 81       	ld	r24, Z
    282c:	8f 83       	std	Y+7, r24	; 0x07
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    282e:	f9 01       	movw	r30, r18
    2830:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2832:	e0 0f       	add	r30, r16
    2834:	f1 1f       	adc	r31, r17
    2836:	80 81       	ld	r24, Z
    2838:	8e 83       	std	Y+6, r24	; 0x06
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    283a:	f9 01       	movw	r30, r18
    283c:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    283e:	e0 0f       	add	r30, r16
    2840:	f1 1f       	adc	r31, r17
    2842:	80 81       	ld	r24, Z
    2844:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    2846:	49 81       	ldd	r20, Y+1	; 0x01
    2848:	5a 81       	ldd	r21, Y+2	; 0x02
    284a:	6b 81       	ldd	r22, Y+3	; 0x03
    284c:	7c 81       	ldd	r23, Y+4	; 0x04
    284e:	8d 81       	ldd	r24, Y+5	; 0x05
    2850:	9e 81       	ldd	r25, Y+6	; 0x06
    2852:	af 81       	ldd	r26, Y+7	; 0x07
    2854:	b8 85       	ldd	r27, Y+8	; 0x08
    2856:	84 0f       	add	r24, r20
    2858:	95 1f       	adc	r25, r21
    285a:	a6 1f       	adc	r26, r22
    285c:	b7 1f       	adc	r27, r23
    285e:	89 83       	std	Y+1, r24	; 0x01
    2860:	9a 83       	std	Y+2, r25	; 0x02
    2862:	ab 83       	std	Y+3, r26	; 0x03
    2864:	bc 83       	std	Y+4, r27	; 0x04
    2866:	2d 5f       	subi	r18, 0xFD	; 253
    2868:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    286a:	2c 30       	cpi	r18, 0x0C	; 12
    286c:	31 05       	cpc	r19, r1
    286e:	81 f6       	brne	.-96     	; 0x2810 <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2870:	69 81       	ldd	r22, Y+1	; 0x01
    2872:	7a 81       	ldd	r23, Y+2	; 0x02
    2874:	8b 81       	ldd	r24, Y+3	; 0x03
    2876:	9c 81       	ldd	r25, Y+4	; 0x04
    2878:	24 e0       	ldi	r18, 0x04	; 4
    287a:	30 e0       	ldi	r19, 0x00	; 0
    287c:	40 e0       	ldi	r20, 0x00	; 0
    287e:	50 e0       	ldi	r21, 0x00	; 0
    2880:	0e 94 b0 39 	call	0x7360	; 0x7360 <__divmodsi4>
    2884:	29 83       	std	Y+1, r18	; 0x01
    2886:	3a 83       	std	Y+2, r19	; 0x02
    2888:	4b 83       	std	Y+3, r20	; 0x03
    288a:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    288c:	29 81       	ldd	r18, Y+1	; 0x01
    288e:	87 e2       	ldi	r24, 0x27	; 39
    2890:	9e e3       	ldi	r25, 0x3E	; 62
    2892:	20 93 27 3e 	sts	0x3E27, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2896:	2a 81       	ldd	r18, Y+2	; 0x02
    2898:	fc 01       	movw	r30, r24
    289a:	31 97       	sbiw	r30, 0x01	; 1
    289c:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    289e:	2b 81       	ldd	r18, Y+3	; 0x03
    28a0:	02 97       	sbiw	r24, 0x02	; 2
    28a2:	fc 01       	movw	r30, r24
    28a4:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    28a6:	80 e1       	ldi	r24, 0x10	; 16
    28a8:	e0 e4       	ldi	r30, 0x40	; 64
    28aa:	f6 e0       	ldi	r31, 0x06	; 6
    28ac:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    28ae:	88 e0       	ldi	r24, 0x08	; 8
    28b0:	e0 e2       	ldi	r30, 0x20	; 32
    28b2:	f6 e0       	ldi	r31, 0x06	; 6
    28b4:	86 83       	std	Z+6, r24	; 0x06
	nop();
    28b6:	00 00       	nop
	SPIC.DATA = FR_WREN;
    28b8:	86 e0       	ldi	r24, 0x06	; 6
    28ba:	e0 ec       	ldi	r30, 0xC0	; 192
    28bc:	f8 e0       	ldi	r31, 0x08	; 8
    28be:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28c0:	82 81       	ldd	r24, Z+2	; 0x02
    28c2:	88 23       	and	r24, r24
    28c4:	ec f7       	brge	.-6      	; 0x28c0 <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    28c6:	e0 ec       	ldi	r30, 0xC0	; 192
    28c8:	f8 e0       	ldi	r31, 0x08	; 8
    28ca:	83 81       	ldd	r24, Z+3	; 0x03
    28cc:	80 93 31 3e 	sts	0x3E31, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    28d0:	a0 e2       	ldi	r26, 0x20	; 32
    28d2:	b6 e0       	ldi	r27, 0x06	; 6
    28d4:	88 e0       	ldi	r24, 0x08	; 8
    28d6:	15 96       	adiw	r26, 0x05	; 5
    28d8:	8c 93       	st	X, r24
    28da:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    28dc:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    28de:	16 96       	adiw	r26, 0x06	; 6
    28e0:	8c 93       	st	X, r24
    28e2:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    28e4:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    28e6:	82 e0       	ldi	r24, 0x02	; 2
    28e8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28ea:	82 81       	ldd	r24, Z+2	; 0x02
    28ec:	88 23       	and	r24, r24
    28ee:	ec f7       	brge	.-6      	; 0x28ea <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    28f0:	e0 ec       	ldi	r30, 0xC0	; 192
    28f2:	f8 e0       	ldi	r31, 0x08	; 8
    28f4:	83 81       	ldd	r24, Z+3	; 0x03
    28f6:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    28fa:	80 91 23 3e 	lds	r24, 0x3E23
    28fe:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2900:	82 81       	ldd	r24, Z+2	; 0x02
    2902:	88 23       	and	r24, r24
    2904:	ec f7       	brge	.-6      	; 0x2900 <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    2906:	e0 ec       	ldi	r30, 0xC0	; 192
    2908:	f8 e0       	ldi	r31, 0x08	; 8
    290a:	83 81       	ldd	r24, Z+3	; 0x03
    290c:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2910:	80 91 22 3e 	lds	r24, 0x3E22
    2914:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2916:	82 81       	ldd	r24, Z+2	; 0x02
    2918:	88 23       	and	r24, r24
    291a:	ec f7       	brge	.-6      	; 0x2916 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    291c:	e0 ec       	ldi	r30, 0xC0	; 192
    291e:	f8 e0       	ldi	r31, 0x08	; 8
    2920:	83 81       	ldd	r24, Z+3	; 0x03
    2922:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[0];
    2926:	80 91 25 3e 	lds	r24, 0x3E25
    292a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    292c:	82 81       	ldd	r24, Z+2	; 0x02
    292e:	88 23       	and	r24, r24
    2930:	ec f7       	brge	.-6      	; 0x292c <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    2932:	e0 ec       	ldi	r30, 0xC0	; 192
    2934:	f8 e0       	ldi	r31, 0x08	; 8
    2936:	83 81       	ldd	r24, Z+3	; 0x03
    2938:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[1];
    293c:	80 91 26 3e 	lds	r24, 0x3E26
    2940:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2942:	82 81       	ldd	r24, Z+2	; 0x02
    2944:	88 23       	and	r24, r24
    2946:	ec f7       	brge	.-6      	; 0x2942 <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    2948:	e0 ec       	ldi	r30, 0xC0	; 192
    294a:	f8 e0       	ldi	r31, 0x08	; 8
    294c:	83 81       	ldd	r24, Z+3	; 0x03
    294e:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[2];
    2952:	80 91 27 3e 	lds	r24, 0x3E27
    2956:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2958:	82 81       	ldd	r24, Z+2	; 0x02
    295a:	88 23       	and	r24, r24
    295c:	ec f7       	brge	.-6      	; 0x2958 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    295e:	a0 ec       	ldi	r26, 0xC0	; 192
    2960:	b8 e0       	ldi	r27, 0x08	; 8
    2962:	13 96       	adiw	r26, 0x03	; 3
    2964:	8c 91       	ld	r24, X
    2966:	13 97       	sbiw	r26, 0x03	; 3
    2968:	80 93 31 3e 	sts	0x3E31, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    296c:	88 e0       	ldi	r24, 0x08	; 8
    296e:	e0 e2       	ldi	r30, 0x20	; 32
    2970:	f6 e0       	ldi	r31, 0x06	; 6
    2972:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2974:	e0 e4       	ldi	r30, 0x40	; 64
    2976:	f6 e0       	ldi	r31, 0x06	; 6
    2978:	80 e1       	ldi	r24, 0x10	; 16
    297a:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    297c:	94 e5       	ldi	r25, 0x54	; 84
    297e:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2980:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    2982:	80 91 22 3e 	lds	r24, 0x3E22
    2986:	90 91 23 3e 	lds	r25, 0x3E23
    298a:	03 96       	adiw	r24, 0x03	; 3
    298c:	80 93 22 3e 	sts	0x3E22, r24
    2990:	90 93 23 3e 	sts	0x3E23, r25
	checksumADC[0] += SPIBuffer[0];
    2994:	80 91 12 21 	lds	r24, 0x2112
    2998:	e5 e2       	ldi	r30, 0x25	; 37
    299a:	fe e3       	ldi	r31, 0x3E	; 62
    299c:	90 81       	ld	r25, Z
    299e:	89 0f       	add	r24, r25
    29a0:	80 93 12 21 	sts	0x2112, r24
	checksumADC[1] += SPIBuffer[1];
    29a4:	80 91 13 21 	lds	r24, 0x2113
    29a8:	91 81       	ldd	r25, Z+1	; 0x01
    29aa:	89 0f       	add	r24, r25
    29ac:	80 93 13 21 	sts	0x2113, r24
	checksumADC[2] += SPIBuffer[2];
    29b0:	80 91 14 21 	lds	r24, 0x2114
    29b4:	92 81       	ldd	r25, Z+2	; 0x02
    29b6:	89 0f       	add	r24, r25
    29b8:	80 93 14 21 	sts	0x2114, r24
}
    29bc:	28 96       	adiw	r28, 0x08	; 8
    29be:	cd bf       	out	0x3d, r28	; 61
    29c0:	de bf       	out	0x3e, r29	; 62
    29c2:	df 91       	pop	r29
    29c4:	cf 91       	pop	r28
    29c6:	1f 91       	pop	r17
    29c8:	0f 91       	pop	r16
    29ca:	ff 90       	pop	r15
    29cc:	08 95       	ret

000029ce <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    29ce:	2f 92       	push	r2
    29d0:	3f 92       	push	r3
    29d2:	4f 92       	push	r4
    29d4:	5f 92       	push	r5
    29d6:	6f 92       	push	r6
    29d8:	7f 92       	push	r7
    29da:	8f 92       	push	r8
    29dc:	9f 92       	push	r9
    29de:	af 92       	push	r10
    29e0:	bf 92       	push	r11
    29e2:	cf 92       	push	r12
    29e4:	df 92       	push	r13
    29e6:	ef 92       	push	r14
    29e8:	ff 92       	push	r15
    29ea:	0f 93       	push	r16
    29ec:	1f 93       	push	r17
    29ee:	cf 93       	push	r28
    29f0:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    29f2:	10 92 22 3e 	sts	0x3E22, r1
    29f6:	10 92 23 3e 	sts	0x3E23, r1
	sampleCount = 0;
    29fa:	10 92 6a 50 	sts	0x506A, r1
    29fe:	10 92 6b 50 	sts	0x506B, r1
    2a02:	10 92 6c 50 	sts	0x506C, r1
    2a06:	10 92 6d 50 	sts	0x506D, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2a0a:	84 e1       	ldi	r24, 0x14	; 20
    2a0c:	91 e2       	ldi	r25, 0x21	; 33
    2a0e:	10 92 14 21 	sts	0x2114, r1
    2a12:	fc 01       	movw	r30, r24
    2a14:	31 97       	sbiw	r30, 0x01	; 1
    2a16:	10 82       	st	Z, r1
    2a18:	02 97       	sbiw	r24, 0x02	; 2
    2a1a:	dc 01       	movw	r26, r24
    2a1c:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    2a1e:	81 e0       	ldi	r24, 0x01	; 1
    2a20:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    2a24:	84 e0       	ldi	r24, 0x04	; 4
    2a26:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2a2a:	80 ed       	ldi	r24, 0xD0	; 208
    2a2c:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    2a30:	8d e0       	ldi	r24, 0x0D	; 13
    2a32:	80 93 25 3e 	sts	0x3E25, r24
	SPIBuffer[1] = 0xF3;
    2a36:	83 ef       	ldi	r24, 0xF3	; 243
    2a38:	80 93 26 3e 	sts	0x3E26, r24
	SPIBuffer[2] = 0x57;
    2a3c:	87 e5       	ldi	r24, 0x57	; 87
    2a3e:	80 93 27 3e 	sts	0x3E27, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2a42:	80 91 6a 50 	lds	r24, 0x506A
    2a46:	90 91 6b 50 	lds	r25, 0x506B
    2a4a:	a0 91 6c 50 	lds	r26, 0x506C
    2a4e:	b0 91 6d 50 	lds	r27, 0x506D
    2a52:	83 35       	cpi	r24, 0x53	; 83
    2a54:	e5 e5       	ldi	r30, 0x55	; 85
    2a56:	9e 07       	cpc	r25, r30
    2a58:	e0 e0       	ldi	r30, 0x00	; 0
    2a5a:	ae 07       	cpc	r26, r30
    2a5c:	e0 e0       	ldi	r30, 0x00	; 0
    2a5e:	be 07       	cpc	r27, r30
    2a60:	08 f0       	brcs	.+2      	; 0x2a64 <FRAMWriteKnowns+0x96>
    2a62:	cc c0       	rjmp	.+408    	; 0x2bfc <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2a64:	0f 2e       	mov	r0, r31
    2a66:	f0 e4       	ldi	r31, 0x40	; 64
    2a68:	ef 2e       	mov	r14, r31
    2a6a:	f6 e0       	ldi	r31, 0x06	; 6
    2a6c:	ff 2e       	mov	r15, r31
    2a6e:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a70:	40 e2       	ldi	r20, 0x20	; 32
    2a72:	56 e0       	ldi	r21, 0x06	; 6
    2a74:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2a76:	e0 ec       	ldi	r30, 0xC0	; 192
    2a78:	f8 e0       	ldi	r31, 0x08	; 8
    2a7a:	0f 2e       	mov	r0, r31
    2a7c:	f6 e0       	ldi	r31, 0x06	; 6
    2a7e:	7f 2e       	mov	r7, r31
    2a80:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    2a82:	c1 e3       	ldi	r28, 0x31	; 49
    2a84:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2a86:	66 24       	eor	r6, r6
    2a88:	68 94       	set
    2a8a:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2a8c:	0f 2e       	mov	r0, r31
    2a8e:	f2 e2       	ldi	r31, 0x22	; 34
    2a90:	cf 2e       	mov	r12, r31
    2a92:	fe e3       	ldi	r31, 0x3E	; 62
    2a94:	df 2e       	mov	r13, r31
    2a96:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2a98:	8e 01       	movw	r16, r28
    2a9a:	0c 50       	subi	r16, 0x0C	; 12
    2a9c:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2a9e:	0f 2e       	mov	r0, r31
    2aa0:	f5 ef       	ldi	r31, 0xF5	; 245
    2aa2:	4f 2e       	mov	r4, r31
    2aa4:	ff ef       	ldi	r31, 0xFF	; 255
    2aa6:	5f 2e       	mov	r5, r31
    2aa8:	f0 2d       	mov	r31, r0
    2aaa:	4c 0e       	add	r4, r28
    2aac:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2aae:	0f 2e       	mov	r0, r31
    2ab0:	f6 ef       	ldi	r31, 0xF6	; 246
    2ab2:	2f 2e       	mov	r2, r31
    2ab4:	ff ef       	ldi	r31, 0xFF	; 255
    2ab6:	3f 2e       	mov	r3, r31
    2ab8:	f0 2d       	mov	r31, r0
    2aba:	2c 0e       	add	r2, r28
    2abc:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2abe:	62 e1       	ldi	r22, 0x12	; 18
    2ac0:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    2ac2:	5b 01       	movw	r10, r22
    2ac4:	08 94       	sec
    2ac6:	a1 1c       	adc	r10, r1
    2ac8:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2aca:	88 24       	eor	r8, r8
    2acc:	99 24       	eor	r9, r9
    2ace:	68 94       	set
    2ad0:	81 f8       	bld	r8, 1
    2ad2:	86 0e       	add	r8, r22
    2ad4:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2ad6:	30 e1       	ldi	r19, 0x10	; 16
    2ad8:	d7 01       	movw	r26, r14
    2ada:	16 96       	adiw	r26, 0x06	; 6
    2adc:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2ade:	da 01       	movw	r26, r20
    2ae0:	16 96       	adiw	r26, 0x06	; 6
    2ae2:	2c 93       	st	X, r18
    2ae4:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2ae6:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2ae8:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2aea:	82 81       	ldd	r24, Z+2	; 0x02
    2aec:	88 23       	and	r24, r24
    2aee:	ec f7       	brge	.-6      	; 0x2aea <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    2af0:	83 81       	ldd	r24, Z+3	; 0x03
    2af2:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    2af4:	da 01       	movw	r26, r20
    2af6:	15 96       	adiw	r26, 0x05	; 5
    2af8:	2c 93       	st	X, r18
    2afa:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2afc:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2afe:	16 96       	adiw	r26, 0x06	; 6
    2b00:	2c 93       	st	X, r18
    2b02:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2b04:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2b06:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b08:	82 81       	ldd	r24, Z+2	; 0x02
    2b0a:	88 23       	and	r24, r24
    2b0c:	ec f7       	brge	.-6      	; 0x2b08 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    2b0e:	83 81       	ldd	r24, Z+3	; 0x03
    2b10:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2b12:	d6 01       	movw	r26, r12
    2b14:	11 96       	adiw	r26, 0x01	; 1
    2b16:	8c 91       	ld	r24, X
    2b18:	11 97       	sbiw	r26, 0x01	; 1
    2b1a:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b1c:	82 81       	ldd	r24, Z+2	; 0x02
    2b1e:	88 23       	and	r24, r24
    2b20:	ec f7       	brge	.-6      	; 0x2b1c <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    2b22:	83 81       	ldd	r24, Z+3	; 0x03
    2b24:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2b26:	d6 01       	movw	r26, r12
    2b28:	8c 91       	ld	r24, X
    2b2a:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b2c:	82 81       	ldd	r24, Z+2	; 0x02
    2b2e:	88 23       	and	r24, r24
    2b30:	ec f7       	brge	.-6      	; 0x2b2c <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    2b32:	83 81       	ldd	r24, Z+3	; 0x03
    2b34:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2b36:	d8 01       	movw	r26, r16
    2b38:	8c 91       	ld	r24, X
    2b3a:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b3c:	82 81       	ldd	r24, Z+2	; 0x02
    2b3e:	88 23       	and	r24, r24
    2b40:	ec f7       	brge	.-6      	; 0x2b3c <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    2b42:	83 81       	ldd	r24, Z+3	; 0x03
    2b44:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2b46:	d2 01       	movw	r26, r4
    2b48:	8c 91       	ld	r24, X
    2b4a:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b4c:	82 81       	ldd	r24, Z+2	; 0x02
    2b4e:	88 23       	and	r24, r24
    2b50:	ec f7       	brge	.-6      	; 0x2b4c <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    2b52:	83 81       	ldd	r24, Z+3	; 0x03
    2b54:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    2b56:	d1 01       	movw	r26, r2
    2b58:	8c 91       	ld	r24, X
    2b5a:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b5c:	82 81       	ldd	r24, Z+2	; 0x02
    2b5e:	88 23       	and	r24, r24
    2b60:	ec f7       	brge	.-6      	; 0x2b5c <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    2b62:	83 81       	ldd	r24, Z+3	; 0x03
    2b64:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2b66:	da 01       	movw	r26, r20
    2b68:	15 96       	adiw	r26, 0x05	; 5
    2b6a:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2b6c:	30 e1       	ldi	r19, 0x10	; 16
    2b6e:	d7 01       	movw	r26, r14
    2b70:	15 96       	adiw	r26, 0x05	; 5
    2b72:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    2b74:	80 91 22 3e 	lds	r24, 0x3E22
    2b78:	90 91 23 3e 	lds	r25, 0x3E23
    2b7c:	03 96       	adiw	r24, 0x03	; 3
    2b7e:	80 93 22 3e 	sts	0x3E22, r24
    2b82:	90 93 23 3e 	sts	0x3E23, r25
		checksumADC[0] += SPIBuffer[0];
    2b86:	db 01       	movw	r26, r22
    2b88:	8c 91       	ld	r24, X
    2b8a:	d8 01       	movw	r26, r16
    2b8c:	9c 91       	ld	r25, X
    2b8e:	89 0f       	add	r24, r25
    2b90:	db 01       	movw	r26, r22
    2b92:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2b94:	d5 01       	movw	r26, r10
    2b96:	8c 91       	ld	r24, X
    2b98:	a6 e2       	ldi	r26, 0x26	; 38
    2b9a:	be e3       	ldi	r27, 0x3E	; 62
    2b9c:	9c 91       	ld	r25, X
    2b9e:	89 0f       	add	r24, r25
    2ba0:	d5 01       	movw	r26, r10
    2ba2:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2ba4:	d4 01       	movw	r26, r8
    2ba6:	8c 91       	ld	r24, X
    2ba8:	a7 e2       	ldi	r26, 0x27	; 39
    2baa:	be e3       	ldi	r27, 0x3E	; 62
    2bac:	9c 91       	ld	r25, X
    2bae:	89 0f       	add	r24, r25
    2bb0:	d4 01       	movw	r26, r8
    2bb2:	8c 93       	st	X, r24
		
		sampleCount++;
    2bb4:	80 91 6a 50 	lds	r24, 0x506A
    2bb8:	90 91 6b 50 	lds	r25, 0x506B
    2bbc:	a0 91 6c 50 	lds	r26, 0x506C
    2bc0:	b0 91 6d 50 	lds	r27, 0x506D
    2bc4:	01 96       	adiw	r24, 0x01	; 1
    2bc6:	a1 1d       	adc	r26, r1
    2bc8:	b1 1d       	adc	r27, r1
    2bca:	80 93 6a 50 	sts	0x506A, r24
    2bce:	90 93 6b 50 	sts	0x506B, r25
    2bd2:	a0 93 6c 50 	sts	0x506C, r26
    2bd6:	b0 93 6d 50 	sts	0x506D, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2bda:	80 91 6a 50 	lds	r24, 0x506A
    2bde:	90 91 6b 50 	lds	r25, 0x506B
    2be2:	a0 91 6c 50 	lds	r26, 0x506C
    2be6:	b0 91 6d 50 	lds	r27, 0x506D
    2bea:	83 35       	cpi	r24, 0x53	; 83
    2bec:	35 e5       	ldi	r19, 0x55	; 85
    2bee:	93 07       	cpc	r25, r19
    2bf0:	30 e0       	ldi	r19, 0x00	; 0
    2bf2:	a3 07       	cpc	r26, r19
    2bf4:	30 e0       	ldi	r19, 0x00	; 0
    2bf6:	b3 07       	cpc	r27, r19
    2bf8:	08 f4       	brcc	.+2      	; 0x2bfc <FRAMWriteKnowns+0x22e>
    2bfa:	6d cf       	rjmp	.-294    	; 0x2ad6 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2bfc:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	ADCPower(FALSE);
    2c00:	80 e0       	ldi	r24, 0x00	; 0
    2c02:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
}
    2c06:	df 91       	pop	r29
    2c08:	cf 91       	pop	r28
    2c0a:	1f 91       	pop	r17
    2c0c:	0f 91       	pop	r16
    2c0e:	ff 90       	pop	r15
    2c10:	ef 90       	pop	r14
    2c12:	df 90       	pop	r13
    2c14:	cf 90       	pop	r12
    2c16:	bf 90       	pop	r11
    2c18:	af 90       	pop	r10
    2c1a:	9f 90       	pop	r9
    2c1c:	8f 90       	pop	r8
    2c1e:	7f 90       	pop	r7
    2c20:	6f 90       	pop	r6
    2c22:	5f 90       	pop	r5
    2c24:	4f 90       	pop	r4
    2c26:	3f 90       	pop	r3
    2c28:	2f 90       	pop	r2
    2c2a:	08 95       	ret

00002c2c <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2c2c:	80 ff       	sbrs	r24, 0
    2c2e:	05 c0       	rjmp	.+10     	; 0x2c3a <setADCInput+0xe>
    2c30:	20 e4       	ldi	r18, 0x40	; 64
    2c32:	e0 e0       	ldi	r30, 0x00	; 0
    2c34:	f6 e0       	ldi	r31, 0x06	; 6
    2c36:	25 83       	std	Z+5, r18	; 0x05
    2c38:	04 c0       	rjmp	.+8      	; 0x2c42 <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2c3a:	20 e4       	ldi	r18, 0x40	; 64
    2c3c:	e0 e0       	ldi	r30, 0x00	; 0
    2c3e:	f6 e0       	ldi	r31, 0x06	; 6
    2c40:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2c42:	81 ff       	sbrs	r24, 1
    2c44:	05 c0       	rjmp	.+10     	; 0x2c50 <setADCInput+0x24>
    2c46:	22 e0       	ldi	r18, 0x02	; 2
    2c48:	e0 e2       	ldi	r30, 0x20	; 32
    2c4a:	f6 e0       	ldi	r31, 0x06	; 6
    2c4c:	25 83       	std	Z+5, r18	; 0x05
    2c4e:	04 c0       	rjmp	.+8      	; 0x2c58 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2c50:	22 e0       	ldi	r18, 0x02	; 2
    2c52:	e0 e2       	ldi	r30, 0x20	; 32
    2c54:	f6 e0       	ldi	r31, 0x06	; 6
    2c56:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2c58:	82 ff       	sbrs	r24, 2
    2c5a:	05 c0       	rjmp	.+10     	; 0x2c66 <setADCInput+0x3a>
    2c5c:	84 e0       	ldi	r24, 0x04	; 4
    2c5e:	e0 e2       	ldi	r30, 0x20	; 32
    2c60:	f6 e0       	ldi	r31, 0x06	; 6
    2c62:	85 83       	std	Z+5, r24	; 0x05
    2c64:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2c66:	84 e0       	ldi	r24, 0x04	; 4
    2c68:	e0 e2       	ldi	r30, 0x20	; 32
    2c6a:	f6 e0       	ldi	r31, 0x06	; 6
    2c6c:	86 83       	std	Z+6, r24	; 0x06
    2c6e:	08 95       	ret

00002c70 <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2c70:	2f 92       	push	r2
    2c72:	3f 92       	push	r3
    2c74:	4f 92       	push	r4
    2c76:	5f 92       	push	r5
    2c78:	7f 92       	push	r7
    2c7a:	8f 92       	push	r8
    2c7c:	9f 92       	push	r9
    2c7e:	af 92       	push	r10
    2c80:	bf 92       	push	r11
    2c82:	cf 92       	push	r12
    2c84:	df 92       	push	r13
    2c86:	ef 92       	push	r14
    2c88:	ff 92       	push	r15
    2c8a:	0f 93       	push	r16
    2c8c:	1f 93       	push	r17
    2c8e:	cf 93       	push	r28
    2c90:	df 93       	push	r29
    2c92:	cd b7       	in	r28, 0x3d	; 61
    2c94:	de b7       	in	r29, 0x3e	; 62
    2c96:	18 2f       	mov	r17, r24
    2c98:	76 2e       	mov	r7, r22
    2c9a:	f4 2e       	mov	r15, r20
    2c9c:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    2c9e:	89 8d       	ldd	r24, Y+25	; 0x19
    2ca0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2ca2:	80 93 68 50 	sts	0x5068, r24
    2ca6:	90 93 69 50 	sts	0x5069, r25
	ADC_Sampling_Finished = 0;
    2caa:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    2cae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2cb0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2cb2:	80 93 ac 50 	sts	0x50AC, r24
    2cb6:	90 93 ad 50 	sts	0x50AD, r25
	if(use_FRAM){
    2cba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2cbc:	88 23       	and	r24, r24
    2cbe:	21 f0       	breq	.+8      	; 0x2cc8 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    2cc0:	81 e0       	ldi	r24, 0x01	; 1
    2cc2:	80 93 4d 40 	sts	0x404D, r24
    2cc6:	02 c0       	rjmp	.+4      	; 0x2ccc <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2cc8:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2ccc:	81 e0       	ldi	r24, 0x01	; 1
    2cce:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2cd2:	81 2f       	mov	r24, r17
    2cd4:	6f 2d       	mov	r22, r15
    2cd6:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <set_ampGain>
	set_filter(filterConfig);
    2cda:	87 2d       	mov	r24, r7
    2cdc:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2ce0:	8e 2d       	mov	r24, r14
    2ce2:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2ce6:	84 e0       	ldi	r24, 0x04	; 4
    2ce8:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2cec:	84 e5       	ldi	r24, 0x54	; 84
    2cee:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2cf2:	81 e0       	ldi	r24, 0x01	; 1
    2cf4:	0e 94 8d 0c 	call	0x191a	; 0x191a <enableADCMUX>
	setADCInput(channel);
    2cf8:	81 2f       	mov	r24, r17
    2cfa:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2cfe:	e0 ea       	ldi	r30, 0xA0	; 160
    2d00:	f6 e0       	ldi	r31, 0x06	; 6
    2d02:	22 e0       	ldi	r18, 0x02	; 2
    2d04:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2d06:	77 24       	eor	r7, r7
    2d08:	73 94       	inc	r7
    2d0a:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2d0c:	0f 2e       	mov	r0, r31
    2d0e:	f0 e8       	ldi	r31, 0x80	; 128
    2d10:	4f 2e       	mov	r4, r31
    2d12:	f1 e0       	ldi	r31, 0x01	; 1
    2d14:	5f 2e       	mov	r5, r31
    2d16:	f0 2d       	mov	r31, r0
    2d18:	88 e7       	ldi	r24, 0x78	; 120
    2d1a:	d2 01       	movw	r26, r4
    2d1c:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2d1e:	e0 e0       	ldi	r30, 0x00	; 0
    2d20:	f9 e0       	ldi	r31, 0x09	; 9
    2d22:	80 ef       	ldi	r24, 0xF0	; 240
    2d24:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2d26:	c0 a6       	lds	r28, 0xb0
    2d28:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2d2a:	a2 a6       	lds	r26, 0xb2
    2d2c:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2d2e:	84 a6       	lds	r24, 0xb4
    2d30:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2d32:	8d 89       	ldd	r24, Y+21	; 0x15
    2d34:	9e 89       	ldd	r25, Y+22	; 0x16
    2d36:	86 a7       	lds	r24, 0x76
    2d38:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2d3a:	80 2f       	mov	r24, r16
    2d3c:	90 e0       	ldi	r25, 0x00	; 0
    2d3e:	01 97       	sbiw	r24, 0x01	; 1
    2d40:	86 a3       	lds	r24, 0x56
    2d42:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2d44:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2d46:	8f ef       	ldi	r24, 0xFF	; 255
    2d48:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2d4a:	80 81       	ld	r24, Z
    2d4c:	80 7f       	andi	r24, 0xF0	; 240
    2d4e:	88 60       	ori	r24, 0x08	; 8
    2d50:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2d52:	10 92 6a 50 	sts	0x506A, r1
    2d56:	10 92 6b 50 	sts	0x506B, r1
    2d5a:	10 92 6c 50 	sts	0x506C, r1
    2d5e:	10 92 6d 50 	sts	0x506D, r1
	SPICount = 0;
    2d62:	10 92 a5 50 	sts	0x50A5, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2d66:	80 e2       	ldi	r24, 0x20	; 32
    2d68:	e0 e8       	ldi	r30, 0x80	; 128
    2d6a:	f6 e0       	ldi	r31, 0x06	; 6
    2d6c:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2d6e:	00 e4       	ldi	r16, 0x40	; 64
    2d70:	1a e0       	ldi	r17, 0x0A	; 10
    2d72:	83 e2       	ldi	r24, 0x23	; 35
    2d74:	f8 01       	movw	r30, r16
    2d76:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2d78:	61 01       	movw	r12, r2
    2d7a:	ee 24       	eor	r14, r14
    2d7c:	ff 24       	eor	r15, r15
    2d7e:	60 e8       	ldi	r22, 0x80	; 128
    2d80:	74 e8       	ldi	r23, 0x84	; 132
    2d82:	8e e1       	ldi	r24, 0x1E	; 30
    2d84:	90 e0       	ldi	r25, 0x00	; 0
    2d86:	a7 01       	movw	r20, r14
    2d88:	96 01       	movw	r18, r12
    2d8a:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    2d8e:	d8 01       	movw	r26, r16
    2d90:	96 96       	adiw	r26, 0x26	; 38
    2d92:	2d 93       	st	X+, r18
    2d94:	3c 93       	st	X, r19
    2d96:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2d98:	60 e4       	ldi	r22, 0x40	; 64
    2d9a:	72 e4       	ldi	r23, 0x42	; 66
    2d9c:	8f e0       	ldi	r24, 0x0F	; 15
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	a7 01       	movw	r20, r14
    2da2:	96 01       	movw	r18, r12
    2da4:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    2da8:	f8 01       	movw	r30, r16
    2daa:	22 af       	sts	0x72, r18
    2dac:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2dae:	e0 e4       	ldi	r30, 0x40	; 64
    2db0:	f8 e0       	ldi	r31, 0x08	; 8
    2db2:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2db4:	8c e0       	ldi	r24, 0x0C	; 12
    2db6:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2db8:	8f 89       	ldd	r24, Y+23	; 0x17
    2dba:	98 8d       	ldd	r25, Y+24	; 0x18
    2dbc:	86 a3       	lds	r24, 0x56
    2dbe:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2dc0:	80 ed       	ldi	r24, 0xD0	; 208
    2dc2:	d2 01       	movw	r26, r4
    2dc4:	11 96       	adiw	r26, 0x01	; 1
    2dc6:	8c 93       	st	X, r24
    2dc8:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2dca:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2dcc:	80 81       	ld	r24, Z
    2dce:	80 7f       	andi	r24, 0xF0	; 240
    2dd0:	89 60       	ori	r24, 0x09	; 9
    2dd2:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2dd4:	f8 01       	movw	r30, r16
    2dd6:	80 81       	ld	r24, Z
    2dd8:	80 7f       	andi	r24, 0xF0	; 240
    2dda:	81 60       	ori	r24, 0x01	; 1
    2ddc:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2dde:	e0 ea       	ldi	r30, 0xA0	; 160
    2de0:	f0 e0       	ldi	r31, 0x00	; 0
    2de2:	82 81       	ldd	r24, Z+2	; 0x02
    2de4:	87 60       	ori	r24, 0x07	; 7
    2de6:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2de8:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2dea:	df 91       	pop	r29
    2dec:	cf 91       	pop	r28
    2dee:	1f 91       	pop	r17
    2df0:	0f 91       	pop	r16
    2df2:	ff 90       	pop	r15
    2df4:	ef 90       	pop	r14
    2df6:	df 90       	pop	r13
    2df8:	cf 90       	pop	r12
    2dfa:	bf 90       	pop	r11
    2dfc:	af 90       	pop	r10
    2dfe:	9f 90       	pop	r9
    2e00:	8f 90       	pop	r8
    2e02:	7f 90       	pop	r7
    2e04:	5f 90       	pop	r5
    2e06:	4f 90       	pop	r4
    2e08:	3f 90       	pop	r3
    2e0a:	2f 90       	pop	r2
    2e0c:	08 95       	ret

00002e0e <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2e0e:	2f 92       	push	r2
    2e10:	3f 92       	push	r3
    2e12:	4f 92       	push	r4
    2e14:	5f 92       	push	r5
    2e16:	6f 92       	push	r6
    2e18:	7f 92       	push	r7
    2e1a:	8f 92       	push	r8
    2e1c:	9f 92       	push	r9
    2e1e:	af 92       	push	r10
    2e20:	bf 92       	push	r11
    2e22:	cf 92       	push	r12
    2e24:	df 92       	push	r13
    2e26:	ef 92       	push	r14
    2e28:	ff 92       	push	r15
    2e2a:	0f 93       	push	r16
    2e2c:	cf 93       	push	r28
    2e2e:	df 93       	push	r29
    2e30:	0f 92       	push	r0
    2e32:	0f 92       	push	r0
    2e34:	cd b7       	in	r28, 0x3d	; 61
    2e36:	de b7       	in	r29, 0x3e	; 62
    2e38:	96 2f       	mov	r25, r22
    2e3a:	49 83       	std	Y+1, r20	; 0x01
    2e3c:	5a 83       	std	Y+2, r21	; 0x02
    2e3e:	52 2f       	mov	r21, r18
    2e40:	70 2f       	mov	r23, r16
    2e42:	37 01       	movw	r6, r14
    2e44:	26 01       	movw	r4, r12
    2e46:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2e48:	2d b7       	in	r18, 0x3d	; 61
    2e4a:	3e b7       	in	r19, 0x3e	; 62
    2e4c:	29 50       	subi	r18, 0x09	; 9
    2e4e:	30 40       	sbci	r19, 0x00	; 0
    2e50:	2d bf       	out	0x3d, r18	; 61
    2e52:	3e bf       	out	0x3e, r19	; 62
    2e54:	ed b7       	in	r30, 0x3d	; 61
    2e56:	fe b7       	in	r31, 0x3e	; 62
    2e58:	31 96       	adiw	r30, 0x01	; 1
    2e5a:	ad b7       	in	r26, 0x3d	; 61
    2e5c:	be b7       	in	r27, 0x3e	; 62
    2e5e:	11 96       	adiw	r26, 0x01	; 1
    2e60:	8d 92       	st	X+, r8
    2e62:	9c 92       	st	X, r9
    2e64:	12 97       	sbiw	r26, 0x02	; 2
    2e66:	2f 89       	ldd	r18, Y+23	; 0x17
    2e68:	38 8d       	ldd	r19, Y+24	; 0x18
    2e6a:	22 83       	std	Z+2, r18	; 0x02
    2e6c:	33 83       	std	Z+3, r19	; 0x03
    2e6e:	29 8d       	ldd	r18, Y+25	; 0x19
    2e70:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2e72:	24 83       	std	Z+4, r18	; 0x04
    2e74:	35 83       	std	Z+5, r19	; 0x05
    2e76:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2e78:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2e7a:	26 83       	std	Z+6, r18	; 0x06
    2e7c:	37 83       	std	Z+7, r19	; 0x07
    2e7e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2e80:	20 87       	std	Z+8, r18	; 0x08
    2e82:	64 ec       	ldi	r22, 0xC4	; 196
    2e84:	49 2f       	mov	r20, r25
    2e86:	29 81       	ldd	r18, Y+1	; 0x01
    2e88:	3a 81       	ldd	r19, Y+2	; 0x02
    2e8a:	05 2f       	mov	r16, r21
    2e8c:	e7 2e       	mov	r14, r23
    2e8e:	63 01       	movw	r12, r6
    2e90:	52 01       	movw	r10, r4
    2e92:	41 01       	movw	r8, r2
    2e94:	0e 94 38 16 	call	0x2c70	; 0x2c70 <CO_collectSeismic1Channel_ext>
    2e98:	2d b7       	in	r18, 0x3d	; 61
    2e9a:	3e b7       	in	r19, 0x3e	; 62
    2e9c:	27 5f       	subi	r18, 0xF7	; 247
    2e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    2ea0:	2d bf       	out	0x3d, r18	; 61
    2ea2:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2ea4:	0f 90       	pop	r0
    2ea6:	0f 90       	pop	r0
    2ea8:	df 91       	pop	r29
    2eaa:	cf 91       	pop	r28
    2eac:	0f 91       	pop	r16
    2eae:	ff 90       	pop	r15
    2eb0:	ef 90       	pop	r14
    2eb2:	df 90       	pop	r13
    2eb4:	cf 90       	pop	r12
    2eb6:	bf 90       	pop	r11
    2eb8:	af 90       	pop	r10
    2eba:	9f 90       	pop	r9
    2ebc:	8f 90       	pop	r8
    2ebe:	7f 90       	pop	r7
    2ec0:	6f 90       	pop	r6
    2ec2:	5f 90       	pop	r5
    2ec4:	4f 90       	pop	r4
    2ec6:	3f 90       	pop	r3
    2ec8:	2f 90       	pop	r2
    2eca:	08 95       	ret

00002ecc <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2ecc:	2f 92       	push	r2
    2ece:	3f 92       	push	r3
    2ed0:	5f 92       	push	r5
    2ed2:	6f 92       	push	r6
    2ed4:	7f 92       	push	r7
    2ed6:	8f 92       	push	r8
    2ed8:	9f 92       	push	r9
    2eda:	af 92       	push	r10
    2edc:	bf 92       	push	r11
    2ede:	cf 92       	push	r12
    2ee0:	df 92       	push	r13
    2ee2:	ef 92       	push	r14
    2ee4:	ff 92       	push	r15
    2ee6:	0f 93       	push	r16
    2ee8:	1f 93       	push	r17
    2eea:	cf 93       	push	r28
    2eec:	df 93       	push	r29
    2eee:	0f 92       	push	r0
    2ef0:	0f 92       	push	r0
    2ef2:	cd b7       	in	r28, 0x3d	; 61
    2ef4:	de b7       	in	r29, 0x3e	; 62
    2ef6:	18 2f       	mov	r17, r24
    2ef8:	3b 01       	movw	r6, r22
    2efa:	49 83       	std	Y+1, r20	; 0x01
    2efc:	5a 83       	std	Y+2, r21	; 0x02
    2efe:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2f00:	89 8d       	ldd	r24, Y+25	; 0x19
    2f02:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f04:	80 93 68 50 	sts	0x5068, r24
    2f08:	90 93 69 50 	sts	0x5069, r25
	ADC_Sampling_Finished = 0;
    2f0c:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    2f10:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2f12:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2f14:	80 93 ac 50 	sts	0x50AC, r24
    2f18:	90 93 ad 50 	sts	0x50AD, r25
	if(use_FRAM){
    2f1c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2f1e:	88 23       	and	r24, r24
    2f20:	21 f0       	breq	.+8      	; 0x2f2a <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2f22:	81 e0       	ldi	r24, 0x01	; 1
    2f24:	80 93 4d 40 	sts	0x404D, r24
    2f28:	02 c0       	rjmp	.+4      	; 0x2f2e <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2f2a:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2f2e:	81 e0       	ldi	r24, 0x01	; 1
    2f30:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2f34:	85 e0       	ldi	r24, 0x05	; 5
    2f36:	d3 01       	movw	r26, r6
    2f38:	6c 91       	ld	r22, X
    2f3a:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2f3e:	86 e0       	ldi	r24, 0x06	; 6
    2f40:	f3 01       	movw	r30, r6
    2f42:	61 81       	ldd	r22, Z+1	; 0x01
    2f44:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2f48:	87 e0       	ldi	r24, 0x07	; 7
    2f4a:	d3 01       	movw	r26, r6
    2f4c:	12 96       	adiw	r26, 0x02	; 2
    2f4e:	6c 91       	ld	r22, X
    2f50:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <set_ampGain>
	set_filter(filterConfig);
    2f54:	81 2f       	mov	r24, r17
    2f56:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2f5a:	80 2f       	mov	r24, r16
    2f5c:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2f60:	84 e0       	ldi	r24, 0x04	; 4
    2f62:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2f66:	84 e5       	ldi	r24, 0x54	; 84
    2f68:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2f6c:	81 e0       	ldi	r24, 0x01	; 1
    2f6e:	0e 94 8d 0c 	call	0x191a	; 0x191a <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2f72:	85 e0       	ldi	r24, 0x05	; 5
    2f74:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2f78:	e0 ea       	ldi	r30, 0xA0	; 160
    2f7a:	f6 e0       	ldi	r31, 0x06	; 6
    2f7c:	22 e0       	ldi	r18, 0x02	; 2
    2f7e:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2f80:	66 24       	eor	r6, r6
    2f82:	63 94       	inc	r6
    2f84:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2f86:	0f 2e       	mov	r0, r31
    2f88:	f0 e8       	ldi	r31, 0x80	; 128
    2f8a:	2f 2e       	mov	r2, r31
    2f8c:	f1 e0       	ldi	r31, 0x01	; 1
    2f8e:	3f 2e       	mov	r3, r31
    2f90:	f0 2d       	mov	r31, r0
    2f92:	88 e7       	ldi	r24, 0x78	; 120
    2f94:	f1 01       	movw	r30, r2
    2f96:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2f98:	e0 e0       	ldi	r30, 0x00	; 0
    2f9a:	f8 e0       	ldi	r31, 0x08	; 8
    2f9c:	80 ef       	ldi	r24, 0xF0	; 240
    2f9e:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2fa0:	e0 a6       	lds	r30, 0xb0
    2fa2:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2fa4:	c2 a6       	lds	r28, 0xb2
    2fa6:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2fa8:	a4 a6       	lds	r26, 0xb4
    2faa:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2fac:	86 a6       	lds	r24, 0xb6
    2fae:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2fb0:	85 2d       	mov	r24, r5
    2fb2:	90 e0       	ldi	r25, 0x00	; 0
    2fb4:	01 97       	sbiw	r24, 0x01	; 1
    2fb6:	86 a3       	lds	r24, 0x56
    2fb8:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2fba:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2fbc:	8f ef       	ldi	r24, 0xFF	; 255
    2fbe:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2fc0:	80 81       	ld	r24, Z
    2fc2:	80 7f       	andi	r24, 0xF0	; 240
    2fc4:	88 60       	ori	r24, 0x08	; 8
    2fc6:	80 83       	st	Z, r24

	sampleCount = 0;
    2fc8:	10 92 6a 50 	sts	0x506A, r1
    2fcc:	10 92 6b 50 	sts	0x506B, r1
    2fd0:	10 92 6c 50 	sts	0x506C, r1
    2fd4:	10 92 6d 50 	sts	0x506D, r1
	SPICount = 0;
    2fd8:	10 92 a5 50 	sts	0x50A5, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2fdc:	84 e1       	ldi	r24, 0x14	; 20
    2fde:	91 e2       	ldi	r25, 0x21	; 33
    2fe0:	10 92 14 21 	sts	0x2114, r1
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	31 97       	sbiw	r30, 0x01	; 1
    2fe8:	10 82       	st	Z, r1
    2fea:	02 97       	sbiw	r24, 0x02	; 2
    2fec:	dc 01       	movw	r26, r24
    2fee:	1c 92       	st	X, r1

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2ff0:	80 e2       	ldi	r24, 0x20	; 32
    2ff2:	e0 e8       	ldi	r30, 0x80	; 128
    2ff4:	f6 e0       	ldi	r31, 0x06	; 6
    2ff6:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2ff8:	00 e4       	ldi	r16, 0x40	; 64
    2ffa:	1a e0       	ldi	r17, 0x0A	; 10
    2ffc:	83 e2       	ldi	r24, 0x23	; 35
    2ffe:	f8 01       	movw	r30, r16
    3000:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    3002:	89 81       	ldd	r24, Y+1	; 0x01
    3004:	9a 81       	ldd	r25, Y+2	; 0x02
    3006:	6c 01       	movw	r12, r24
    3008:	ee 24       	eor	r14, r14
    300a:	ff 24       	eor	r15, r15
    300c:	60 e8       	ldi	r22, 0x80	; 128
    300e:	74 e8       	ldi	r23, 0x84	; 132
    3010:	8e e1       	ldi	r24, 0x1E	; 30
    3012:	90 e0       	ldi	r25, 0x00	; 0
    3014:	a7 01       	movw	r20, r14
    3016:	96 01       	movw	r18, r12
    3018:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    301c:	d8 01       	movw	r26, r16
    301e:	96 96       	adiw	r26, 0x26	; 38
    3020:	2d 93       	st	X+, r18
    3022:	3c 93       	st	X, r19
    3024:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    3026:	60 e4       	ldi	r22, 0x40	; 64
    3028:	72 e4       	ldi	r23, 0x42	; 66
    302a:	8f e0       	ldi	r24, 0x0F	; 15
    302c:	90 e0       	ldi	r25, 0x00	; 0
    302e:	a7 01       	movw	r20, r14
    3030:	96 01       	movw	r18, r12
    3032:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    3036:	f8 01       	movw	r30, r16
    3038:	22 af       	sts	0x72, r18
    303a:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    303c:	e0 e4       	ldi	r30, 0x40	; 64
    303e:	f8 e0       	ldi	r31, 0x08	; 8
    3040:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    3042:	8c e0       	ldi	r24, 0x0C	; 12
    3044:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    3046:	8f 89       	ldd	r24, Y+23	; 0x17
    3048:	98 8d       	ldd	r25, Y+24	; 0x18
    304a:	86 a3       	lds	r24, 0x56
    304c:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    304e:	80 ec       	ldi	r24, 0xC0	; 192
    3050:	d1 01       	movw	r26, r2
    3052:	11 96       	adiw	r26, 0x01	; 1
    3054:	8c 93       	st	X, r24
    3056:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    3058:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    305a:	80 81       	ld	r24, Z
    305c:	80 7f       	andi	r24, 0xF0	; 240
    305e:	89 60       	ori	r24, 0x09	; 9
    3060:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    3062:	f8 01       	movw	r30, r16
    3064:	80 81       	ld	r24, Z
    3066:	80 7f       	andi	r24, 0xF0	; 240
    3068:	81 60       	ori	r24, 0x01	; 1
    306a:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    306c:	e0 ea       	ldi	r30, 0xA0	; 160
    306e:	f0 e0       	ldi	r31, 0x00	; 0
    3070:	82 81       	ldd	r24, Z+2	; 0x02
    3072:	87 60       	ori	r24, 0x07	; 7
    3074:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3076:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    3078:	0f 90       	pop	r0
    307a:	0f 90       	pop	r0
    307c:	df 91       	pop	r29
    307e:	cf 91       	pop	r28
    3080:	1f 91       	pop	r17
    3082:	0f 91       	pop	r16
    3084:	ff 90       	pop	r15
    3086:	ef 90       	pop	r14
    3088:	df 90       	pop	r13
    308a:	cf 90       	pop	r12
    308c:	bf 90       	pop	r11
    308e:	af 90       	pop	r10
    3090:	9f 90       	pop	r9
    3092:	8f 90       	pop	r8
    3094:	7f 90       	pop	r7
    3096:	6f 90       	pop	r6
    3098:	5f 90       	pop	r5
    309a:	3f 90       	pop	r3
    309c:	2f 90       	pop	r2
    309e:	08 95       	ret

000030a0 <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    30a0:	2f 92       	push	r2
    30a2:	3f 92       	push	r3
    30a4:	4f 92       	push	r4
    30a6:	5f 92       	push	r5
    30a8:	6f 92       	push	r6
    30aa:	7f 92       	push	r7
    30ac:	8f 92       	push	r8
    30ae:	9f 92       	push	r9
    30b0:	af 92       	push	r10
    30b2:	bf 92       	push	r11
    30b4:	cf 92       	push	r12
    30b6:	df 92       	push	r13
    30b8:	ef 92       	push	r14
    30ba:	ff 92       	push	r15
    30bc:	0f 93       	push	r16
    30be:	1f 93       	push	r17
    30c0:	cf 93       	push	r28
    30c2:	df 93       	push	r29
    30c4:	00 d0       	rcall	.+0      	; 0x30c6 <CO_collectSeismic3Axises+0x26>
    30c6:	0f 92       	push	r0
    30c8:	cd b7       	in	r28, 0x3d	; 61
    30ca:	de b7       	in	r29, 0x3e	; 62
    30cc:	dc 01       	movw	r26, r24
    30ce:	3b 01       	movw	r6, r22
    30d0:	94 2f       	mov	r25, r20
    30d2:	32 2f       	mov	r19, r18
    30d4:	28 01       	movw	r4, r16
    30d6:	17 01       	movw	r2, r14
    30d8:	c9 82       	std	Y+1, r12	; 0x01
    30da:	da 82       	std	Y+2, r13	; 0x02
    30dc:	ab 82       	std	Y+3, r10	; 0x03
    30de:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    30e0:	4d b7       	in	r20, 0x3d	; 61
    30e2:	5e b7       	in	r21, 0x3e	; 62
    30e4:	47 50       	subi	r20, 0x07	; 7
    30e6:	50 40       	sbci	r21, 0x00	; 0
    30e8:	4d bf       	out	0x3d, r20	; 61
    30ea:	5e bf       	out	0x3e, r21	; 62
    30ec:	6d b7       	in	r22, 0x3d	; 61
    30ee:	7e b7       	in	r23, 0x3e	; 62
    30f0:	6f 5f       	subi	r22, 0xFF	; 255
    30f2:	7f 4f       	sbci	r23, 0xFF	; 255
    30f4:	ed b7       	in	r30, 0x3d	; 61
    30f6:	fe b7       	in	r31, 0x3e	; 62
    30f8:	81 82       	std	Z+1, r8	; 0x01
    30fa:	92 82       	std	Z+2, r9	; 0x02
    30fc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    30fe:	5b 8d       	ldd	r21, Y+27	; 0x1b
    3100:	fb 01       	movw	r30, r22
    3102:	42 83       	std	Z+2, r20	; 0x02
    3104:	53 83       	std	Z+3, r21	; 0x03
    3106:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3108:	5d 8d       	ldd	r21, Y+29	; 0x1d
    310a:	44 83       	std	Z+4, r20	; 0x04
    310c:	55 83       	std	Z+5, r21	; 0x05
    310e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3110:	86 83       	std	Z+6, r24	; 0x06
    3112:	84 ec       	ldi	r24, 0xC4	; 196
    3114:	bd 01       	movw	r22, r26
    3116:	a3 01       	movw	r20, r6
    3118:	29 2f       	mov	r18, r25
    311a:	03 2f       	mov	r16, r19
    311c:	72 01       	movw	r14, r4
    311e:	61 01       	movw	r12, r2
    3120:	a9 80       	ldd	r10, Y+1	; 0x01
    3122:	ba 80       	ldd	r11, Y+2	; 0x02
    3124:	8b 80       	ldd	r8, Y+3	; 0x03
    3126:	9c 80       	ldd	r9, Y+4	; 0x04
    3128:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <CO_collectSeismic3Axises_ext>
    312c:	4d b7       	in	r20, 0x3d	; 61
    312e:	5e b7       	in	r21, 0x3e	; 62
    3130:	49 5f       	subi	r20, 0xF9	; 249
    3132:	5f 4f       	sbci	r21, 0xFF	; 255
    3134:	4d bf       	out	0x3d, r20	; 61
    3136:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    3138:	24 96       	adiw	r28, 0x04	; 4
    313a:	cd bf       	out	0x3d, r28	; 61
    313c:	de bf       	out	0x3e, r29	; 62
    313e:	df 91       	pop	r29
    3140:	cf 91       	pop	r28
    3142:	1f 91       	pop	r17
    3144:	0f 91       	pop	r16
    3146:	ff 90       	pop	r15
    3148:	ef 90       	pop	r14
    314a:	df 90       	pop	r13
    314c:	cf 90       	pop	r12
    314e:	bf 90       	pop	r11
    3150:	af 90       	pop	r10
    3152:	9f 90       	pop	r9
    3154:	8f 90       	pop	r8
    3156:	7f 90       	pop	r7
    3158:	6f 90       	pop	r6
    315a:	5f 90       	pop	r5
    315c:	4f 90       	pop	r4
    315e:	3f 90       	pop	r3
    3160:	2f 90       	pop	r2
    3162:	08 95       	ret

00003164 <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    3164:	6f 92       	push	r6
    3166:	7f 92       	push	r7
    3168:	8f 92       	push	r8
    316a:	9f 92       	push	r9
    316c:	af 92       	push	r10
    316e:	bf 92       	push	r11
    3170:	cf 92       	push	r12
    3172:	df 92       	push	r13
    3174:	ef 92       	push	r14
    3176:	ff 92       	push	r15
    3178:	0f 93       	push	r16
    317a:	1f 93       	push	r17
    317c:	cf 93       	push	r28
    317e:	df 93       	push	r29
    3180:	c8 2f       	mov	r28, r24
    3182:	b6 2e       	mov	r11, r22
    3184:	d4 2f       	mov	r29, r20
    3186:	49 01       	movw	r8, r18
    3188:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    318a:	e0 92 68 50 	sts	0x5068, r14
    318e:	f0 92 69 50 	sts	0x5069, r15
	ADC_Sampling_Finished = 0;
    3192:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    3196:	c0 92 ac 50 	sts	0x50AC, r12
    319a:	d0 92 ad 50 	sts	0x50AD, r13
	if(use_FRAM){
    319e:	aa 20       	and	r10, r10
    31a0:	21 f0       	breq	.+8      	; 0x31aa <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    31a2:	81 e0       	ldi	r24, 0x01	; 1
    31a4:	80 93 4d 40 	sts	0x404D, r24
    31a8:	02 c0       	rjmp	.+4      	; 0x31ae <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    31aa:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    31ae:	81 e0       	ldi	r24, 0x01	; 1
    31b0:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    31b4:	8c 2f       	mov	r24, r28
    31b6:	6d 2f       	mov	r22, r29
    31b8:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <set_ampGain>
	set_filter(filterConfig);
    31bc:	8b 2d       	mov	r24, r11
    31be:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    31c2:	8c 2f       	mov	r24, r28
    31c4:	85 50       	subi	r24, 0x05	; 5
    31c6:	83 30       	cpi	r24, 0x03	; 3
    31c8:	18 f4       	brcc	.+6      	; 0x31d0 <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    31ca:	81 e0       	ldi	r24, 0x01	; 1
    31cc:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    31d0:	81 e0       	ldi	r24, 0x01	; 1
    31d2:	0e 94 8d 0c 	call	0x191a	; 0x191a <enableADCMUX>
	setADCInput(channel);
    31d6:	8c 2f       	mov	r24, r28
    31d8:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    31dc:	84 e0       	ldi	r24, 0x04	; 4
    31de:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    31e2:	84 e5       	ldi	r24, 0x54	; 84
    31e4:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    31e8:	e0 ea       	ldi	r30, 0xA0	; 160
    31ea:	f6 e0       	ldi	r31, 0x06	; 6
    31ec:	ee 24       	eor	r14, r14
    31ee:	e3 94       	inc	r14
    31f0:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    31f2:	82 e0       	ldi	r24, 0x02	; 2
    31f4:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    31f6:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    31f8:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    31fa:	80 e2       	ldi	r24, 0x20	; 32
    31fc:	e0 e8       	ldi	r30, 0x80	; 128
    31fe:	f6 e0       	ldi	r31, 0x06	; 6
    3200:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    3202:	c0 e4       	ldi	r28, 0x40	; 64
    3204:	da e0       	ldi	r29, 0x0A	; 10
    3206:	83 e2       	ldi	r24, 0x23	; 35
    3208:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    320a:	94 01       	movw	r18, r8
    320c:	40 e0       	ldi	r20, 0x00	; 0
    320e:	50 e0       	ldi	r21, 0x00	; 0
    3210:	60 e8       	ldi	r22, 0x80	; 128
    3212:	74 e8       	ldi	r23, 0x84	; 132
    3214:	8e e1       	ldi	r24, 0x1E	; 30
    3216:	90 e0       	ldi	r25, 0x00	; 0
    3218:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    321c:	89 01       	movw	r16, r18
    321e:	9a 01       	movw	r18, r20
    3220:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    3222:	0e a3       	lds	r16, 0x5e
    3224:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    3226:	96 95       	lsr	r25
    3228:	87 95       	ror	r24
    322a:	8a af       	sts	0x7a, r24
    322c:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//reset count to zero
	TCC1.CTRLA = 0x00;
    322e:	e0 e4       	ldi	r30, 0x40	; 64
    3230:	f8 e0       	ldi	r31, 0x08	; 8
    3232:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    3234:	8c e0       	ldi	r24, 0x0C	; 12
    3236:	81 87       	std	Z+9, r24	; 0x09
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    3238:	66 a2       	lds	r22, 0x96
    323a:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    323c:	88 e7       	ldi	r24, 0x78	; 120
    323e:	a0 e8       	ldi	r26, 0x80	; 128
    3240:	b1 e0       	ldi	r27, 0x01	; 1
    3242:	11 96       	adiw	r26, 0x01	; 1
    3244:	8c 93       	st	X, r24
    3246:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    3248:	e6 82       	std	Z+6, r14	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    324a:	88 81       	ld	r24, Y
    324c:	80 7f       	andi	r24, 0xF0	; 240
    324e:	81 60       	ori	r24, 0x01	; 1
    3250:	88 83       	st	Y, r24
	
	sampleCount = 0;
    3252:	10 92 6a 50 	sts	0x506A, r1
    3256:	10 92 6b 50 	sts	0x506B, r1
    325a:	10 92 6c 50 	sts	0x506C, r1
    325e:	10 92 6d 50 	sts	0x506D, r1
	discardCount = 0;
    3262:	10 92 61 40 	sts	0x4061, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    3266:	e0 ea       	ldi	r30, 0xA0	; 160
    3268:	f0 e0       	ldi	r31, 0x00	; 0
    326a:	82 81       	ldd	r24, Z+2	; 0x02
    326c:	83 60       	ori	r24, 0x03	; 3
    326e:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3270:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    3272:	df 91       	pop	r29
    3274:	cf 91       	pop	r28
    3276:	1f 91       	pop	r17
    3278:	0f 91       	pop	r16
    327a:	ff 90       	pop	r15
    327c:	ef 90       	pop	r14
    327e:	df 90       	pop	r13
    3280:	cf 90       	pop	r12
    3282:	bf 90       	pop	r11
    3284:	af 90       	pop	r10
    3286:	9f 90       	pop	r9
    3288:	8f 90       	pop	r8
    328a:	7f 90       	pop	r7
    328c:	6f 90       	pop	r6
    328e:	08 95       	ret

00003290 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    3290:	8f 92       	push	r8
    3292:	9f 92       	push	r9
    3294:	af 92       	push	r10
    3296:	cf 92       	push	r12
    3298:	df 92       	push	r13
    329a:	ef 92       	push	r14
    329c:	ff 92       	push	r15
    329e:	0f 93       	push	r16
    32a0:	1f 93       	push	r17
    32a2:	cf 93       	push	r28
    32a4:	df 93       	push	r29
    32a6:	96 2f       	mov	r25, r22
    32a8:	fa 01       	movw	r30, r20
    32aa:	d9 01       	movw	r26, r18
    32ac:	e8 01       	movw	r28, r16
    32ae:	47 01       	movw	r8, r14
    32b0:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    32b2:	61 ec       	ldi	r22, 0xC1	; 193
    32b4:	49 2f       	mov	r20, r25
    32b6:	9f 01       	movw	r18, r30
    32b8:	8d 01       	movw	r16, r26
    32ba:	7e 01       	movw	r14, r28
    32bc:	64 01       	movw	r12, r8
    32be:	0e 94 b2 18 	call	0x3164	; 0x3164 <CO_collectADC_ext>
}
    32c2:	df 91       	pop	r29
    32c4:	cf 91       	pop	r28
    32c6:	1f 91       	pop	r17
    32c8:	0f 91       	pop	r16
    32ca:	ff 90       	pop	r15
    32cc:	ef 90       	pop	r14
    32ce:	df 90       	pop	r13
    32d0:	cf 90       	pop	r12
    32d2:	af 90       	pop	r10
    32d4:	9f 90       	pop	r9
    32d6:	8f 90       	pop	r8
    32d8:	08 95       	ret

000032da <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    32da:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    32dc:	81 e0       	ldi	r24, 0x01	; 1
    32de:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    32e0:	84 81       	ldd	r24, Z+4	; 0x04
    32e2:	95 81       	ldd	r25, Z+5	; 0x05
    32e4:	86 1b       	sub	r24, r22
    32e6:	91 09       	sbc	r25, r1

	return answer;
}
    32e8:	08 95       	ret

000032ea <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    32ea:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    32ec:	81 e0       	ldi	r24, 0x01	; 1
    32ee:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    32f0:	84 81       	ldd	r24, Z+4	; 0x04
    32f2:	95 81       	ldd	r25, Z+5	; 0x05
    32f4:	77 27       	eor	r23, r23
    32f6:	67 fd       	sbrc	r22, 7
    32f8:	70 95       	com	r23
    32fa:	86 1b       	sub	r24, r22
    32fc:	97 0b       	sbc	r25, r23

	return answer;
}
    32fe:	08 95       	ret

00003300 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3300:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3302:	81 e0       	ldi	r24, 0x01	; 1
    3304:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3306:	84 81       	ldd	r24, Z+4	; 0x04
    3308:	95 81       	ldd	r25, Z+5	; 0x05
}
    330a:	08 95       	ret

0000330c <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    330c:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    330e:	81 e0       	ldi	r24, 0x01	; 1
    3310:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3312:	84 81       	ldd	r24, Z+4	; 0x04
}
    3314:	08 95       	ret

00003316 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3316:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3318:	81 e0       	ldi	r24, 0x01	; 1
    331a:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    331c:	85 81       	ldd	r24, Z+5	; 0x05
}
    331e:	08 95       	ret

00003320 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    3320:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3322:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    3324:	14 82       	std	Z+4, r1	; 0x04
    3326:	9a e2       	ldi	r25, 0x2A	; 42
    3328:	9a 95       	dec	r25
    332a:	f1 f7       	brne	.-4      	; 0x3328 <ADC_Wait_8MHz+0x8>
    332c:	00 c0       	rjmp	.+0      	; 0x332e <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    332e:	84 83       	std	Z+4, r24	; 0x04
}
    3330:	08 95       	ret

00003332 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    3332:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3334:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3336:	91 e0       	ldi	r25, 0x01	; 1
    3338:	94 83       	std	Z+4, r25	; 0x04
    333a:	95 e5       	ldi	r25, 0x55	; 85
    333c:	9a 95       	dec	r25
    333e:	f1 f7       	brne	.-4      	; 0x333c <ADC_Wait_32MHz+0xa>
    3340:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3342:	84 83       	std	Z+4, r24	; 0x04
}
    3344:	08 95       	ret

00003346 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3346:	ef 92       	push	r14
    3348:	ff 92       	push	r15
    334a:	0f 93       	push	r16
    334c:	1f 93       	push	r17
    334e:	cf 93       	push	r28
    3350:	df 93       	push	r29
    3352:	eb 01       	movw	r28, r22
    if (oversampling)
    3354:	44 23       	and	r20, r20
    3356:	c9 f0       	breq	.+50     	; 0x338a <ADC_Offset_Get_Unsigned+0x44>
    3358:	04 e0       	ldi	r16, 0x04	; 4
    335a:	10 e0       	ldi	r17, 0x00	; 0
    335c:	ee 24       	eor	r14, r14
    335e:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3360:	88 81       	ld	r24, Y
    3362:	80 68       	ori	r24, 0x80	; 128
    3364:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3366:	8b 81       	ldd	r24, Y+3	; 0x03
    3368:	80 ff       	sbrs	r24, 0
    336a:	fd cf       	rjmp	.-6      	; 0x3366 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    336c:	ce 01       	movw	r24, r28
    336e:	60 e0       	ldi	r22, 0x00	; 0
    3370:	0e 94 6d 19 	call	0x32da	; 0x32da <ADC_ResultCh_GetWord_Unsigned>
    3374:	e8 0e       	add	r14, r24
    3376:	f9 1e       	adc	r15, r25
    3378:	01 50       	subi	r16, 0x01	; 1
    337a:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    337c:	89 f7       	brne	.-30     	; 0x3360 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    337e:	c7 01       	movw	r24, r14
    3380:	96 95       	lsr	r25
    3382:	87 95       	ror	r24
    3384:	96 95       	lsr	r25
    3386:	87 95       	ror	r24
    3388:	09 c0       	rjmp	.+18     	; 0x339c <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    338a:	88 81       	ld	r24, Y
    338c:	80 68       	ori	r24, 0x80	; 128
    338e:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3390:	8b 81       	ldd	r24, Y+3	; 0x03
    3392:	80 ff       	sbrs	r24, 0
    3394:	fd cf       	rjmp	.-6      	; 0x3390 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3396:	ce 01       	movw	r24, r28
    3398:	0e 94 80 19 	call	0x3300	; 0x3300 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	1f 91       	pop	r17
    33a2:	0f 91       	pop	r16
    33a4:	ff 90       	pop	r15
    33a6:	ef 90       	pop	r14
    33a8:	08 95       	ret

000033aa <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    33aa:	ef 92       	push	r14
    33ac:	ff 92       	push	r15
    33ae:	0f 93       	push	r16
    33b0:	1f 93       	push	r17
    33b2:	cf 93       	push	r28
    33b4:	df 93       	push	r29
    33b6:	eb 01       	movw	r28, r22
    if (oversampling)
    33b8:	44 23       	and	r20, r20
    33ba:	e1 f0       	breq	.+56     	; 0x33f4 <ADC_Offset_Get_Signed+0x4a>
    33bc:	04 e0       	ldi	r16, 0x04	; 4
    33be:	10 e0       	ldi	r17, 0x00	; 0
    33c0:	ee 24       	eor	r14, r14
    33c2:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    33c4:	88 81       	ld	r24, Y
    33c6:	80 68       	ori	r24, 0x80	; 128
    33c8:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    33ca:	8b 81       	ldd	r24, Y+3	; 0x03
    33cc:	80 ff       	sbrs	r24, 0
    33ce:	fd cf       	rjmp	.-6      	; 0x33ca <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    33d0:	ce 01       	movw	r24, r28
    33d2:	60 e0       	ldi	r22, 0x00	; 0
    33d4:	0e 94 75 19 	call	0x32ea	; 0x32ea <ADC_ResultCh_GetWord_Signed>
    33d8:	e8 0e       	add	r14, r24
    33da:	f9 1e       	adc	r15, r25
    33dc:	01 50       	subi	r16, 0x01	; 1
    33de:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    33e0:	89 f7       	brne	.-30     	; 0x33c4 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    33e2:	c7 01       	movw	r24, r14
    33e4:	99 23       	and	r25, r25
    33e6:	0c f4       	brge	.+2      	; 0x33ea <ADC_Offset_Get_Signed+0x40>
    33e8:	03 96       	adiw	r24, 0x03	; 3
    33ea:	95 95       	asr	r25
    33ec:	87 95       	ror	r24
    33ee:	95 95       	asr	r25
    33f0:	87 95       	ror	r24
    33f2:	0a c0       	rjmp	.+20     	; 0x3408 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    33f4:	88 81       	ld	r24, Y
    33f6:	80 68       	ori	r24, 0x80	; 128
    33f8:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    33fa:	8b 81       	ldd	r24, Y+3	; 0x03
    33fc:	80 ff       	sbrs	r24, 0
    33fe:	fd cf       	rjmp	.-6      	; 0x33fa <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3400:	ce 01       	movw	r24, r28
    3402:	60 e0       	ldi	r22, 0x00	; 0
    3404:	0e 94 75 19 	call	0x32ea	; 0x32ea <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    3408:	df 91       	pop	r29
    340a:	cf 91       	pop	r28
    340c:	1f 91       	pop	r17
    340e:	0f 91       	pop	r16
    3410:	ff 90       	pop	r15
    3412:	ef 90       	pop	r14
    3414:	08 95       	ret

00003416 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3416:	aa ec       	ldi	r26, 0xCA	; 202
    3418:	b1 e0       	ldi	r27, 0x01	; 1
    341a:	92 e0       	ldi	r25, 0x02	; 2
    341c:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    341e:	e8 2f       	mov	r30, r24
    3420:	f0 e0       	ldi	r31, 0x00	; 0
    3422:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3424:	1c 92       	st	X, r1

	return result;
}
    3426:	08 95       	ret

00003428 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    3428:	cf 93       	push	r28
    342a:	df 93       	push	r29
    342c:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    342e:	82 e0       	ldi	r24, 0x02	; 2
    3430:	c0 30       	cpi	r28, 0x00	; 0
    3432:	d8 07       	cpc	r29, r24
    3434:	59 f4       	brne	.+22     	; 0x344c <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3436:	80 e2       	ldi	r24, 0x20	; 32
    3438:	0e 94 0b 1a 	call	0x3416	; 0x3416 <SP_ReadCalibrationByte>
    343c:	c0 e0       	ldi	r28, 0x00	; 0
    343e:	d2 e0       	ldi	r29, 0x02	; 2
    3440:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3442:	81 e2       	ldi	r24, 0x21	; 33
    3444:	0e 94 0b 1a 	call	0x3416	; 0x3416 <SP_ReadCalibrationByte>
    3448:	8d 87       	std	Y+13, r24	; 0x0d
    344a:	08 c0       	rjmp	.+16     	; 0x345c <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    344c:	84 e2       	ldi	r24, 0x24	; 36
    344e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <SP_ReadCalibrationByte>
    3452:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3454:	85 e2       	ldi	r24, 0x25	; 37
    3456:	0e 94 0b 1a 	call	0x3416	; 0x3416 <SP_ReadCalibrationByte>
    345a:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    345c:	df 91       	pop	r29
    345e:	cf 91       	pop	r28
    3460:	08 95       	ret

00003462 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    3462:	88 e1       	ldi	r24, 0x18	; 24
    3464:	e5 e1       	ldi	r30, 0x15	; 21
    3466:	f1 e2       	ldi	r31, 0x21	; 33
    3468:	df 01       	movw	r26, r30
    346a:	1d 92       	st	X+, r1
    346c:	8a 95       	dec	r24
    346e:	e9 f7       	brne	.-6      	; 0x346a <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    3470:	0e 94 a8 1b 	call	0x3750	; 0x3750 <chb_get_short_addr>
    3474:	80 93 15 21 	sts	0x2115, r24
    3478:	90 93 16 21 	sts	0x2116, r25
    chb_drvr_init();
    347c:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    3480:	08 95       	ret

00003482 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    3482:	e0 e8       	ldi	r30, 0x80	; 128
    3484:	f6 e0       	ldi	r31, 0x06	; 6
    3486:	84 e0       	ldi	r24, 0x04	; 4
    3488:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    348a:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    348c:	92 e0       	ldi	r25, 0x02	; 2
    348e:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3490:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3492:	83 e0       	ldi	r24, 0x03	; 3
    3494:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3496:	e0 ea       	ldi	r30, 0xA0	; 160
    3498:	f0 e0       	ldi	r31, 0x00	; 0
    349a:	82 81       	ldd	r24, Z+2	; 0x02
    349c:	84 60       	ori	r24, 0x04	; 4
    349e:	82 83       	std	Z+2, r24	; 0x02
	sei();
    34a0:	78 94       	sei
}
    34a2:	08 95       	ret

000034a4 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    34a4:	85 e1       	ldi	r24, 0x15	; 21
    34a6:	91 e2       	ldi	r25, 0x21	; 33
    34a8:	08 95       	ret

000034aa <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    34aa:	2f 92       	push	r2
    34ac:	3f 92       	push	r3
    34ae:	4f 92       	push	r4
    34b0:	5f 92       	push	r5
    34b2:	6f 92       	push	r6
    34b4:	7f 92       	push	r7
    34b6:	8f 92       	push	r8
    34b8:	9f 92       	push	r9
    34ba:	af 92       	push	r10
    34bc:	bf 92       	push	r11
    34be:	cf 92       	push	r12
    34c0:	df 92       	push	r13
    34c2:	ef 92       	push	r14
    34c4:	ff 92       	push	r15
    34c6:	0f 93       	push	r16
    34c8:	1f 93       	push	r17
    34ca:	cf 93       	push	r28
    34cc:	df 93       	push	r29
    34ce:	cd b7       	in	r28, 0x3d	; 61
    34d0:	de b7       	in	r29, 0x3e	; 62
    34d2:	2a 97       	sbiw	r28, 0x0a	; 10
    34d4:	cd bf       	out	0x3d, r28	; 61
    34d6:	de bf       	out	0x3e, r29	; 62
    34d8:	2c 01       	movw	r4, r24
    34da:	1b 01       	movw	r2, r22
    34dc:	69 01       	movw	r12, r18
    34de:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    34e0:	21 15       	cp	r18, r1
    34e2:	31 05       	cpc	r19, r1
    34e4:	41 05       	cpc	r20, r1
    34e6:	51 05       	cpc	r21, r1
    34e8:	09 f4       	brne	.+2      	; 0x34ec <chb_write+0x42>
    34ea:	76 c0       	rjmp	.+236    	; 0x35d8 <chb_write+0x12e>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    34ec:	88 24       	eor	r8, r8
    34ee:	99 24       	eor	r9, r9
    34f0:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    34f2:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    34f4:	0f 2e       	mov	r0, r31
    34f6:	fb e1       	ldi	r31, 0x1B	; 27
    34f8:	6f 2e       	mov	r6, r31
    34fa:	f1 e2       	ldi	r31, 0x21	; 33
    34fc:	7f 2e       	mov	r7, r31
    34fe:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3500:	1c 2d       	mov	r17, r12
    3502:	85 e6       	ldi	r24, 0x65	; 101
    3504:	c8 16       	cp	r12, r24
    3506:	d1 04       	cpc	r13, r1
    3508:	e1 04       	cpc	r14, r1
    350a:	f1 04       	cpc	r15, r1
    350c:	08 f0       	brcs	.+2      	; 0x3510 <chb_write+0x66>
    350e:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3510:	81 2f       	mov	r24, r17
    3512:	85 5f       	subi	r24, 0xF5	; 245
    3514:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3516:	9f ef       	ldi	r25, 0xFF	; 255
    3518:	49 16       	cp	r4, r25
    351a:	9f ef       	ldi	r25, 0xFF	; 255
    351c:	59 06       	cpc	r5, r25
    351e:	11 f0       	breq	.+4      	; 0x3524 <chb_write+0x7a>
    3520:	81 e6       	ldi	r24, 0x61	; 97
    3522:	01 c0       	rjmp	.+2      	; 0x3526 <chb_write+0x7c>
    3524:	81 e4       	ldi	r24, 0x41	; 65
    3526:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3528:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    352a:	f3 01       	movw	r30, r6
    352c:	80 81       	ld	r24, Z
    352e:	8c 83       	std	Y+4, r24	; 0x04
    3530:	8f 5f       	subi	r24, 0xFF	; 255
    3532:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3534:	84 e3       	ldi	r24, 0x34	; 52
    3536:	92 e1       	ldi	r25, 0x12	; 18
    3538:	8d 83       	std	Y+5, r24	; 0x05
    353a:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    353c:	4f 82       	std	Y+7, r4	; 0x07
    353e:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    3540:	e5 e1       	ldi	r30, 0x15	; 21
    3542:	f1 e2       	ldi	r31, 0x21	; 33
    3544:	80 81       	ld	r24, Z
    3546:	91 81       	ldd	r25, Z+1	; 0x01
    3548:	89 87       	std	Y+9, r24	; 0x09
    354a:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    354c:	b1 01       	movw	r22, r2
    354e:	68 0d       	add	r22, r8
    3550:	79 1d       	adc	r23, r9
    3552:	ce 01       	movw	r24, r28
    3554:	01 96       	adiw	r24, 0x01	; 1
    3556:	41 2f       	mov	r20, r17
    3558:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <chb_tx>
		if (status != CHB_SUCCESS){
    355c:	88 23       	and	r24, r24
    355e:	69 f1       	breq	.+90     	; 0x35ba <chb_write+0x110>
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3560:	28 2f       	mov	r18, r24
		if (status != CHB_SUCCESS){
             switch (status)
    3562:	83 30       	cpi	r24, 0x03	; 3
    3564:	f9 f0       	breq	.+62     	; 0x35a4 <chb_write+0xfa>
    3566:	84 30       	cpi	r24, 0x04	; 4
    3568:	18 f4       	brcc	.+6      	; 0x3570 <chb_write+0xc6>
    356a:	81 30       	cpi	r24, 0x01	; 1
    356c:	b1 f5       	brne	.+108    	; 0x35da <chb_write+0x130>
    356e:	04 c0       	rjmp	.+8      	; 0x3578 <chb_write+0xce>
    3570:	85 30       	cpi	r24, 0x05	; 5
    3572:	69 f0       	breq	.+26     	; 0x358e <chb_write+0xe4>
    3574:	80 34       	cpi	r24, 0x40	; 64
    3576:	89 f5       	brne	.+98     	; 0x35da <chb_write+0x130>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3578:	20 91 20 21 	lds	r18, 0x2120
    357c:	30 91 21 21 	lds	r19, 0x2121
    3580:	2f 5f       	subi	r18, 0xFF	; 255
    3582:	3f 4f       	sbci	r19, 0xFF	; 255
    3584:	20 93 20 21 	sts	0x2120, r18
    3588:	30 93 21 21 	sts	0x2121, r19
                 break;
    358c:	26 c0       	rjmp	.+76     	; 0x35da <chb_write+0x130>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    358e:	80 91 22 21 	lds	r24, 0x2122
    3592:	90 91 23 21 	lds	r25, 0x2123
    3596:	01 96       	adiw	r24, 0x01	; 1
    3598:	80 93 22 21 	sts	0x2122, r24
    359c:	90 93 23 21 	sts	0x2123, r25
                 break;
 
             default:
                 break;
             }
			 return status;
    35a0:	82 2f       	mov	r24, r18
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
				 //rtry++;
                 break;
    35a2:	1b c0       	rjmp	.+54     	; 0x35da <chb_write+0x130>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    35a4:	20 91 24 21 	lds	r18, 0x2124
    35a8:	30 91 25 21 	lds	r19, 0x2125
    35ac:	2f 5f       	subi	r18, 0xFF	; 255
    35ae:	3f 4f       	sbci	r19, 0xFF	; 255
    35b0:	20 93 24 21 	sts	0x2124, r18
    35b4:	30 93 25 21 	sts	0x2125, r19
				 //rtry++;
                 break;
    35b8:	10 c0       	rjmp	.+32     	; 0x35da <chb_write+0x130>
		}			 
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    35ba:	41 2f       	mov	r20, r17
    35bc:	50 e0       	ldi	r21, 0x00	; 0
    35be:	60 e0       	ldi	r22, 0x00	; 0
    35c0:	70 e0       	ldi	r23, 0x00	; 0
    35c2:	84 0e       	add	r8, r20
    35c4:	95 1e       	adc	r9, r21
    35c6:	a6 1e       	adc	r10, r22
    35c8:	b7 1e       	adc	r11, r23
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    35ca:	c4 1a       	sub	r12, r20
    35cc:	d5 0a       	sbc	r13, r21
    35ce:	e6 0a       	sbc	r14, r22
    35d0:	f7 0a       	sbc	r15, r23
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    35d2:	09 f0       	breq	.+2      	; 0x35d6 <chb_write+0x12c>
    35d4:	95 cf       	rjmp	.-214    	; 0x3500 <chb_write+0x56>
    35d6:	01 c0       	rjmp	.+2      	; 0x35da <chb_write+0x130>
        // adjust len and restart
		frm_offset += frm_len;
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
	return CHB_SUCCESS;
    35d8:	80 e0       	ldi	r24, 0x00	; 0
}
    35da:	2a 96       	adiw	r28, 0x0a	; 10
    35dc:	cd bf       	out	0x3d, r28	; 61
    35de:	de bf       	out	0x3e, r29	; 62
    35e0:	df 91       	pop	r29
    35e2:	cf 91       	pop	r28
    35e4:	1f 91       	pop	r17
    35e6:	0f 91       	pop	r16
    35e8:	ff 90       	pop	r15
    35ea:	ef 90       	pop	r14
    35ec:	df 90       	pop	r13
    35ee:	cf 90       	pop	r12
    35f0:	bf 90       	pop	r11
    35f2:	af 90       	pop	r10
    35f4:	9f 90       	pop	r9
    35f6:	8f 90       	pop	r8
    35f8:	7f 90       	pop	r7
    35fa:	6f 90       	pop	r6
    35fc:	5f 90       	pop	r5
    35fe:	4f 90       	pop	r4
    3600:	3f 90       	pop	r3
    3602:	2f 90       	pop	r2
    3604:	08 95       	ret

00003606 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3606:	df 92       	push	r13
    3608:	ef 92       	push	r14
    360a:	ff 92       	push	r15
    360c:	0f 93       	push	r16
    360e:	1f 93       	push	r17
    3610:	cf 93       	push	r28
    3612:	df 93       	push	r29
    3614:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    3616:	0e 94 86 1b 	call	0x370c	; 0x370c <chb_buf_read>
    361a:	d8 2e       	mov	r13, r24
    361c:	88 23       	and	r24, r24
    361e:	0c f4       	brge	.+2      	; 0x3622 <chb_read+0x1c>
    3620:	4e c0       	rjmp	.+156    	; 0x36be <chb_read+0xb8>
    {
        return 0;
    }
    *data_ptr++ = len;
    3622:	f7 01       	movw	r30, r14
    3624:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    3626:	88 23       	and	r24, r24
    3628:	71 f0       	breq	.+28     	; 0x3646 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    362a:	e7 01       	movw	r28, r14
    362c:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    362e:	87 01       	movw	r16, r14
    3630:	09 5f       	subi	r16, 0xF9	; 249
    3632:	1f 4f       	sbci	r17, 0xFF	; 255
    3634:	81 50       	subi	r24, 0x01	; 1
    3636:	08 0f       	add	r16, r24
    3638:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    363a:	0e 94 86 1b 	call	0x370c	; 0x370c <chb_buf_read>
    363e:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    3640:	c0 17       	cp	r28, r16
    3642:	d1 07       	cpc	r29, r17
    3644:	d1 f7       	brne	.-12     	; 0x363a <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    3646:	f7 01       	movw	r30, r14
    3648:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    364a:	83 85       	ldd	r24, Z+11	; 0x0b
    364c:	94 85       	ldd	r25, Z+12	; 0x0c
    364e:	83 83       	std	Z+3, r24	; 0x03
    3650:	94 83       	std	Z+4, r25	; 0x04
	pcb.destination_addr = rx->dest_addr;
    3652:	80 93 19 21 	sts	0x2119, r24
    3656:	90 93 1a 21 	sts	0x211A, r25
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    365a:	85 85       	ldd	r24, Z+13	; 0x0d
    365c:	96 85       	ldd	r25, Z+14	; 0x0e
    365e:	81 83       	std	Z+1, r24	; 0x01
    3660:	92 83       	std	Z+2, r25	; 0x02
	pcb.sender_addr = rx->src_addr;
    3662:	80 93 17 21 	sts	0x2117, r24
    3666:	90 93 18 21 	sts	0x2118, r25
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    366a:	0e 94 9d 1b 	call	0x373a	; 0x373a <chb_buf_get_len>
    366e:	88 23       	and	r24, r24
    3670:	11 f4       	brne	.+4      	; 0x3676 <chb_read+0x70>
    {
        pcb.data_rcv = false;
    3672:	10 92 1c 21 	sts	0x211C, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    3676:	80 91 0a 20 	lds	r24, 0x200A
    367a:	c8 17       	cp	r28, r24
    367c:	51 f4       	brne	.+20     	; 0x3692 <chb_read+0x8c>
    367e:	f7 01       	movw	r30, r14
    3680:	21 81       	ldd	r18, Z+1	; 0x01
    3682:	32 81       	ldd	r19, Z+2	; 0x02
    3684:	80 91 0b 20 	lds	r24, 0x200B
    3688:	90 91 0c 20 	lds	r25, 0x200C
    368c:	28 17       	cp	r18, r24
    368e:	39 07       	cpc	r19, r25
    3690:	c1 f0       	breq	.+48     	; 0x36c2 <chb_read+0xbc>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    3692:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    3696:	f7 01       	movw	r30, r14
    3698:	81 81       	ldd	r24, Z+1	; 0x01
    369a:	92 81       	ldd	r25, Z+2	; 0x02
    369c:	80 93 0b 20 	sts	0x200B, r24
    36a0:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    36a4:	b7 01       	movw	r22, r14
    36a6:	61 5f       	subi	r22, 0xF1	; 241
    36a8:	7f 4f       	sbci	r23, 0xFF	; 255
    36aa:	4d 2d       	mov	r20, r13
    36ac:	50 e0       	ldi	r21, 0x00	; 0
    36ae:	49 50       	subi	r20, 0x09	; 9
    36b0:	50 40       	sbci	r21, 0x00	; 0
    36b2:	c7 01       	movw	r24, r14
    36b4:	0e 94 17 3a 	call	0x742e	; 0x742e <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    36b8:	8d 2d       	mov	r24, r13
    36ba:	8b 50       	subi	r24, 0x0B	; 11
    36bc:	03 c0       	rjmp	.+6      	; 0x36c4 <chb_read+0xbe>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    36be:	80 e0       	ldi	r24, 0x00	; 0
    36c0:	01 c0       	rjmp	.+2      	; 0x36c4 <chb_read+0xbe>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    36c2:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    36c4:	df 91       	pop	r29
    36c6:	cf 91       	pop	r28
    36c8:	1f 91       	pop	r17
    36ca:	0f 91       	pop	r16
    36cc:	ff 90       	pop	r15
    36ce:	ef 90       	pop	r14
    36d0:	df 90       	pop	r13
    36d2:	08 95       	ret

000036d4 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    36d4:	10 92 2d 21 	sts	0x212D, r1
    wr_ptr = 0;
    36d8:	10 92 2e 21 	sts	0x212E, r1
    len = 0;
    36dc:	10 92 2f 21 	sts	0x212F, r1
}
    36e0:	08 95       	ret

000036e2 <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    36e2:	20 91 2e 21 	lds	r18, 0x212E
    36e6:	30 e0       	ldi	r19, 0x00	; 0
    36e8:	f9 01       	movw	r30, r18
    36ea:	e0 5d       	subi	r30, 0xD0	; 208
    36ec:	fe 4d       	sbci	r31, 0xDE	; 222
    36ee:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    36f0:	c9 01       	movw	r24, r18
    36f2:	01 96       	adiw	r24, 0x01	; 1
    36f4:	60 e8       	ldi	r22, 0x80	; 128
    36f6:	70 e0       	ldi	r23, 0x00	; 0
    36f8:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    36fc:	80 93 2e 21 	sts	0x212E, r24
    len++;
    3700:	80 91 2f 21 	lds	r24, 0x212F
    3704:	8f 5f       	subi	r24, 0xFF	; 255
    3706:	80 93 2f 21 	sts	0x212F, r24
}
    370a:	08 95       	ret

0000370c <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    370c:	20 91 2d 21 	lds	r18, 0x212D
    3710:	30 e0       	ldi	r19, 0x00	; 0
    3712:	f9 01       	movw	r30, r18
    3714:	e0 5d       	subi	r30, 0xD0	; 208
    3716:	fe 4d       	sbci	r31, 0xDE	; 222
    3718:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    371a:	2f 5f       	subi	r18, 0xFF	; 255
    371c:	3f 4f       	sbci	r19, 0xFF	; 255
    371e:	c9 01       	movw	r24, r18
    3720:	60 e8       	ldi	r22, 0x80	; 128
    3722:	70 e0       	ldi	r23, 0x00	; 0
    3724:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    3728:	80 93 2d 21 	sts	0x212D, r24
    len--;
    372c:	80 91 2f 21 	lds	r24, 0x212F
    3730:	81 50       	subi	r24, 0x01	; 1
    3732:	80 93 2f 21 	sts	0x212F, r24
    return data;
}
    3736:	84 2f       	mov	r24, r20
    3738:	08 95       	ret

0000373a <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    373a:	80 91 2f 21 	lds	r24, 0x212F
    373e:	08 95       	ret

00003740 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    3740:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    3742:	80 e0       	ldi	r24, 0x00	; 0
    3744:	90 e0       	ldi	r25, 0x00	; 0
    3746:	48 e0       	ldi	r20, 0x08	; 8
    3748:	50 e0       	ldi	r21, 0x00	; 0
    374a:	0e 94 e0 1f 	call	0x3fc0	; 0x3fc0 <chb_eeprom_read>
}
    374e:	08 95       	ret

00003750 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    3750:	cf 93       	push	r28
    3752:	df 93       	push	r29
    3754:	0f 92       	push	r0
    3756:	0f 92       	push	r0
    3758:	cd b7       	in	r28, 0x3d	; 61
    375a:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    375c:	89 e0       	ldi	r24, 0x09	; 9
    375e:	90 e0       	ldi	r25, 0x00	; 0
    3760:	be 01       	movw	r22, r28
    3762:	6f 5f       	subi	r22, 0xFF	; 255
    3764:	7f 4f       	sbci	r23, 0xFF	; 255
    3766:	42 e0       	ldi	r20, 0x02	; 2
    3768:	50 e0       	ldi	r21, 0x00	; 0
    376a:	0e 94 e0 1f 	call	0x3fc0	; 0x3fc0 <chb_eeprom_read>
    return *(U16 *)addr;
}
    376e:	89 81       	ldd	r24, Y+1	; 0x01
    3770:	9a 81       	ldd	r25, Y+2	; 0x02
    3772:	0f 90       	pop	r0
    3774:	0f 90       	pop	r0
    3776:	df 91       	pop	r29
    3778:	cf 91       	pop	r28
    377a:	08 95       	ret

0000377c <RadioCS>:
    CHB_LEAVE_CRIT();
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    377c:	88 23       	and	r24, r24
    377e:	29 f0       	breq	.+10     	; 0x378a <RadioCS+0xe>
    3780:	80 e1       	ldi	r24, 0x10	; 16
    3782:	e0 e6       	ldi	r30, 0x60	; 96
    3784:	f6 e0       	ldi	r31, 0x06	; 6
    3786:	86 83       	std	Z+6, r24	; 0x06
    3788:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    378a:	80 e1       	ldi	r24, 0x10	; 16
    378c:	e0 e6       	ldi	r30, 0x60	; 96
    378e:	f6 e0       	ldi	r31, 0x06	; 6
    3790:	85 83       	std	Z+5, r24	; 0x05
    3792:	08 95       	ret

00003794 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    3794:	df 92       	push	r13
    3796:	ef 92       	push	r14
    3798:	ff 92       	push	r15
    379a:	0f 93       	push	r16
    379c:	1f 93       	push	r17
    379e:	cf 93       	push	r28
    37a0:	df 93       	push	r29
    37a2:	8c 01       	movw	r16, r24
    37a4:	c6 2f       	mov	r28, r22
    37a6:	7a 01       	movw	r14, r20
    37a8:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    37aa:	82 2f       	mov	r24, r18
    37ac:	90 e0       	ldi	r25, 0x00	; 0
    37ae:	86 0f       	add	r24, r22
    37b0:	91 1d       	adc	r25, r1
    37b2:	80 38       	cpi	r24, 0x80	; 128
    37b4:	91 05       	cpc	r25, r1
    37b6:	8c f5       	brge	.+98     	; 0x381a <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    37b8:	8f b7       	in	r24, 0x3f	; 63
    37ba:	80 93 5c 40 	sts	0x405C, r24
    37be:	f8 94       	cli
    RadioCS(TRUE); 
    37c0:	81 e0       	ldi	r24, 0x01	; 1
    37c2:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    37c6:	80 e6       	ldi	r24, 0x60	; 96
    37c8:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    37cc:	cc 23       	and	r28, r28
    37ce:	79 f0       	breq	.+30     	; 0x37ee <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    37d0:	c8 01       	movw	r24, r16
    37d2:	01 96       	adiw	r24, 0x01	; 1
    37d4:	c1 50       	subi	r28, 0x01	; 1
    37d6:	9c 01       	movw	r18, r24
    37d8:	2c 0f       	add	r18, r28
    37da:	31 1d       	adc	r19, r1
    37dc:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    37de:	f8 01       	movw	r30, r16
    37e0:	81 91       	ld	r24, Z+
    37e2:	8f 01       	movw	r16, r30
    37e4:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    37e8:	0c 17       	cp	r16, r28
    37ea:	1d 07       	cpc	r17, r29
    37ec:	c1 f7       	brne	.-16     	; 0x37de <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    37ee:	dd 20       	and	r13, r13
    37f0:	69 f0       	breq	.+26     	; 0x380c <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    37f2:	e7 01       	movw	r28, r14
    37f4:	21 96       	adiw	r28, 0x01	; 1
    37f6:	da 94       	dec	r13
    37f8:	cd 0d       	add	r28, r13
    37fa:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    37fc:	f7 01       	movw	r30, r14
    37fe:	81 91       	ld	r24, Z+
    3800:	7f 01       	movw	r14, r30
    3802:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3806:	ec 16       	cp	r14, r28
    3808:	fd 06       	cpc	r15, r29
    380a:	c1 f7       	brne	.-16     	; 0x37fc <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    380c:	80 e0       	ldi	r24, 0x00	; 0
    380e:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>
    CHB_LEAVE_CRIT();
    3812:	80 91 5c 40 	lds	r24, 0x405C
    3816:	8f bf       	out	0x3f, r24	; 63
    3818:	78 94       	sei
}
    381a:	df 91       	pop	r29
    381c:	cf 91       	pop	r28
    381e:	1f 91       	pop	r17
    3820:	0f 91       	pop	r16
    3822:	ff 90       	pop	r15
    3824:	ef 90       	pop	r14
    3826:	df 90       	pop	r13
    3828:	08 95       	ret

0000382a <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    382a:	cf 93       	push	r28
    382c:	df 93       	push	r29
    382e:	d8 2f       	mov	r29, r24
    3830:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    3832:	8f b7       	in	r24, 0x3f	; 63
    3834:	80 93 5c 40 	sts	0x405C, r24
    3838:	f8 94       	cli
    RadioCS(TRUE);
    383a:	81 e0       	ldi	r24, 0x01	; 1
    383c:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    3840:	8d 2f       	mov	r24, r29
    3842:	80 6c       	ori	r24, 0xC0	; 192
    3844:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    3848:	8c 2f       	mov	r24, r28
    384a:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>

    RadioCS(FALSE);
    384e:	80 e0       	ldi	r24, 0x00	; 0
    3850:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>
    CHB_LEAVE_CRIT();
    3854:	80 91 5c 40 	lds	r24, 0x405C
    3858:	8f bf       	out	0x3f, r24	; 63
    385a:	78 94       	sei
}
    385c:	df 91       	pop	r29
    385e:	cf 91       	pop	r28
    3860:	08 95       	ret

00003862 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    3862:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    3864:	85 e0       	ldi	r24, 0x05	; 5
    3866:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>
}
    386a:	08 95       	ret

0000386c <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    386c:	0f 93       	push	r16
    386e:	1f 93       	push	r17
    3870:	cf 93       	push	r28
    3872:	df 93       	push	r29
    3874:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    3876:	c6 2f       	mov	r28, r22
    3878:	d7 2f       	mov	r29, r23
    387a:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    387c:	69 91       	ld	r22, Y+
    387e:	81 2f       	mov	r24, r17
    3880:	80 0f       	add	r24, r16
    3882:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    3886:	1f 5f       	subi	r17, 0xFF	; 255
    3888:	18 30       	cpi	r17, 0x08	; 8
    388a:	c1 f7       	brne	.-16     	; 0x387c <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    388c:	df 91       	pop	r29
    388e:	cf 91       	pop	r28
    3890:	1f 91       	pop	r17
    3892:	0f 91       	pop	r16
    3894:	08 95       	ret

00003896 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3896:	cf 93       	push	r28
    3898:	df 93       	push	r29
    389a:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    389c:	80 e0       	ldi	r24, 0x00	; 0
    389e:	90 e0       	ldi	r25, 0x00	; 0
    38a0:	be 01       	movw	r22, r28
    38a2:	48 e0       	ldi	r20, 0x08	; 8
    38a4:	50 e0       	ldi	r21, 0x00	; 0
    38a6:	0e 94 7d 1f 	call	0x3efa	; 0x3efa <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    38aa:	84 e2       	ldi	r24, 0x24	; 36
    38ac:	be 01       	movw	r22, r28
    38ae:	0e 94 36 1c 	call	0x386c	; 0x386c <chb_reg_write64>
}
    38b2:	df 91       	pop	r29
    38b4:	cf 91       	pop	r28
    38b6:	08 95       	ret

000038b8 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    38b8:	cf 93       	push	r28
    38ba:	df 93       	push	r29
    38bc:	c8 2f       	mov	r28, r24
    38be:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    38c0:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>
    38c4:	8c 2f       	mov	r24, r28
    38c6:	8f 5f       	subi	r24, 0xFF	; 255
    38c8:	6d 2f       	mov	r22, r29
    38ca:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>
    }
}
    38ce:	df 91       	pop	r29
    38d0:	cf 91       	pop	r28
    38d2:	08 95       	ret

000038d4 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    38d4:	0f 93       	push	r16
    38d6:	1f 93       	push	r17
    38d8:	cf 93       	push	r28
    38da:	df 93       	push	r29
    38dc:	0f 92       	push	r0
    38de:	0f 92       	push	r0
    38e0:	cd b7       	in	r28, 0x3d	; 61
    38e2:	de b7       	in	r29, 0x3e	; 62
    38e4:	89 83       	std	Y+1, r24	; 0x01
    38e6:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    38e8:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <chb_get_pcb>
    38ec:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    38ee:	89 e0       	ldi	r24, 0x09	; 9
    38f0:	90 e0       	ldi	r25, 0x00	; 0
    38f2:	be 01       	movw	r22, r28
    38f4:	6f 5f       	subi	r22, 0xFF	; 255
    38f6:	7f 4f       	sbci	r23, 0xFF	; 255
    38f8:	42 e0       	ldi	r20, 0x02	; 2
    38fa:	50 e0       	ldi	r21, 0x00	; 0
    38fc:	0e 94 7d 1f 	call	0x3efa	; 0x3efa <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    3900:	69 81       	ldd	r22, Y+1	; 0x01
    3902:	7a 81       	ldd	r23, Y+2	; 0x02
    3904:	80 e2       	ldi	r24, 0x20	; 32
    3906:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <chb_reg_write16>
    pcb->src_addr = addr;
    390a:	89 81       	ldd	r24, Y+1	; 0x01
    390c:	9a 81       	ldd	r25, Y+2	; 0x02
    390e:	f8 01       	movw	r30, r16
    3910:	80 83       	st	Z, r24
    3912:	91 83       	std	Z+1, r25	; 0x01
}
    3914:	0f 90       	pop	r0
    3916:	0f 90       	pop	r0
    3918:	df 91       	pop	r29
    391a:	cf 91       	pop	r28
    391c:	1f 91       	pop	r17
    391e:	0f 91       	pop	r16
    3920:	08 95       	ret

00003922 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    3922:	cf 93       	push	r28
    3924:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3926:	8f b7       	in	r24, 0x3f	; 63
    3928:	80 93 5c 40 	sts	0x405C, r24
    392c:	f8 94       	cli
    RadioCS(TRUE);
    392e:	81 e0       	ldi	r24, 0x01	; 1
    3930:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    3934:	8c 2f       	mov	r24, r28
    3936:	80 68       	ori	r24, 0x80	; 128
    3938:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    val = SPID_write(val);
    393c:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    3940:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    3942:	80 e0       	ldi	r24, 0x00	; 0
    3944:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>
    CHB_LEAVE_CRIT();
    3948:	80 91 5c 40 	lds	r24, 0x405C
    394c:	8f bf       	out	0x3f, r24	; 63
    394e:	78 94       	sei

    return val;
}
    3950:	8c 2f       	mov	r24, r28
    3952:	cf 91       	pop	r28
    3954:	08 95       	ret

00003956 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    3956:	81 e0       	ldi	r24, 0x01	; 1
    3958:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
}
    395c:	8f 71       	andi	r24, 0x1F	; 31
    395e:	08 95       	ret

00003960 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    3960:	1f 93       	push	r17
    3962:	cf 93       	push	r28
    3964:	df 93       	push	r29
    3966:	c8 2f       	mov	r28, r24
    3968:	16 2f       	mov	r17, r22
    396a:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    396c:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    3970:	6d 2f       	mov	r22, r29
    3972:	60 95       	com	r22
    3974:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    3976:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3978:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    397a:	8c 2f       	mov	r24, r28
    397c:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>
}
    3980:	df 91       	pop	r29
    3982:	cf 91       	pop	r28
    3984:	1f 91       	pop	r17
    3986:	08 95       	ret

00003988 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3988:	cf 93       	push	r28
    398a:	df 93       	push	r29
    398c:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    398e:	80 91 64 06 	lds	r24, 0x0664
    3992:	81 fd       	sbrc	r24, 1
    3994:	53 c0       	rjmp	.+166    	; 0x3a3c <chb_set_state+0xb4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3996:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>
    399a:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    399c:	81 51       	subi	r24, 0x11	; 17
    399e:	82 30       	cpi	r24, 0x02	; 2
    39a0:	20 f0       	brcs	.+8      	; 0x39aa <chb_set_state+0x22>
    39a2:	c1 30       	cpi	r28, 0x01	; 1
    39a4:	11 f0       	breq	.+4      	; 0x39aa <chb_set_state+0x22>
    39a6:	c2 30       	cpi	r28, 0x02	; 2
    39a8:	21 f4       	brne	.+8      	; 0x39b2 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    39aa:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>
    39ae:	8c 17       	cp	r24, r28
    39b0:	e1 f3       	breq	.-8      	; 0x39aa <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    39b2:	d6 31       	cpi	r29, 0x16	; 22
    39b4:	f9 f0       	breq	.+62     	; 0x39f4 <chb_set_state+0x6c>
    39b6:	d9 31       	cpi	r29, 0x19	; 25
    39b8:	89 f0       	breq	.+34     	; 0x39dc <chb_set_state+0x54>
    39ba:	d8 30       	cpi	r29, 0x08	; 8
    39bc:	39 f5       	brne	.+78     	; 0x3a0c <chb_set_state+0x84>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    39be:	e4 e6       	ldi	r30, 0x64	; 100
    39c0:	f6 e0       	ldi	r31, 0x06	; 6
    39c2:	80 81       	ld	r24, Z
    39c4:	8d 7f       	andi	r24, 0xFD	; 253
    39c6:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    39c8:	82 e0       	ldi	r24, 0x02	; 2
    39ca:	63 e0       	ldi	r22, 0x03	; 3
    39cc:	4f e1       	ldi	r20, 0x1F	; 31
    39ce:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
    39d2:	8a e0       	ldi	r24, 0x0A	; 10
    39d4:	8a 95       	dec	r24
    39d6:	f1 f7       	brne	.-4      	; 0x39d4 <chb_set_state+0x4c>
    39d8:	00 c0       	rjmp	.+0      	; 0x39da <chb_set_state+0x52>
    39da:	18 c0       	rjmp	.+48     	; 0x3a0c <chb_set_state+0x84>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    39dc:	c6 31       	cpi	r28, 0x16	; 22
    39de:	b1 f4       	brne	.+44     	; 0x3a0c <chb_set_state+0x84>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    39e0:	82 e0       	ldi	r24, 0x02	; 2
    39e2:	69 e0       	ldi	r22, 0x09	; 9
    39e4:	4f e1       	ldi	r20, 0x1F	; 31
    39e6:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
    39ea:	9a e0       	ldi	r25, 0x0A	; 10
    39ec:	9a 95       	dec	r25
    39ee:	f1 f7       	brne	.-4      	; 0x39ec <chb_set_state+0x64>
    39f0:	00 c0       	rjmp	.+0      	; 0x39f2 <chb_set_state+0x6a>
    39f2:	2a c0       	rjmp	.+84     	; 0x3a48 <chb_set_state+0xc0>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    39f4:	c9 31       	cpi	r28, 0x19	; 25
    39f6:	51 f4       	brne	.+20     	; 0x3a0c <chb_set_state+0x84>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    39f8:	82 e0       	ldi	r24, 0x02	; 2
    39fa:	69 e0       	ldi	r22, 0x09	; 9
    39fc:	4f e1       	ldi	r20, 0x1F	; 31
    39fe:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
    3a02:	8a e0       	ldi	r24, 0x0A	; 10
    3a04:	8a 95       	dec	r24
    3a06:	f1 f7       	brne	.-4      	; 0x3a04 <chb_set_state+0x7c>
    3a08:	00 c0       	rjmp	.+0      	; 0x3a0a <chb_set_state+0x82>
    3a0a:	1e c0       	rjmp	.+60     	; 0x3a48 <chb_set_state+0xc0>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3a0c:	82 e0       	ldi	r24, 0x02	; 2
    3a0e:	6d 2f       	mov	r22, r29
    3a10:	4f e1       	ldi	r20, 0x1F	; 31
    3a12:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
	if(curr_state == CHB_TRX_OFF){
    3a16:	c8 30       	cpi	r28, 0x08	; 8
    3a18:	39 f4       	brne	.+14     	; 0x3a28 <chb_set_state+0xa0>
    3a1a:	8f e6       	ldi	r24, 0x6F	; 111
    3a1c:	93 e0       	ldi	r25, 0x03	; 3
    3a1e:	01 97       	sbiw	r24, 0x01	; 1
    3a20:	f1 f7       	brne	.-4      	; 0x3a1e <chb_set_state+0x96>
    3a22:	00 c0       	rjmp	.+0      	; 0x3a24 <chb_set_state+0x9c>
    3a24:	00 00       	nop
    3a26:	04 c0       	rjmp	.+8      	; 0x3a30 <chb_set_state+0xa8>
    3a28:	9a e0       	ldi	r25, 0x0A	; 10
    3a2a:	9a 95       	dec	r25
    3a2c:	f1 f7       	brne	.-4      	; 0x3a2a <chb_set_state+0xa2>
    3a2e:	00 c0       	rjmp	.+0      	; 0x3a30 <chb_set_state+0xa8>
	}
	else{
		_delay_us(TIME_RX_ON_PLL_ON);
	}				

    if (chb_get_state() == state)
    3a30:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>
    3a34:	8d 17       	cp	r24, r29
    3a36:	21 f4       	brne	.+8      	; 0x3a40 <chb_set_state+0xb8>
    {
        return RADIO_SUCCESS;
    3a38:	80 e4       	ldi	r24, 0x40	; 64
    3a3a:	03 c0       	rjmp	.+6      	; 0x3a42 <chb_set_state+0xba>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    3a3c:	84 e4       	ldi	r24, 0x44	; 68
    3a3e:	01 c0       	rjmp	.+2      	; 0x3a42 <chb_set_state+0xba>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    3a40:	83 e4       	ldi	r24, 0x43	; 67
}
    3a42:	df 91       	pop	r29
    3a44:	cf 91       	pop	r28
    3a46:	08 95       	ret
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3a48:	82 e0       	ldi	r24, 0x02	; 2
    3a4a:	6d 2f       	mov	r22, r29
    3a4c:	4f e1       	ldi	r20, 0x1F	; 31
    3a4e:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
    3a52:	ea cf       	rjmp	.-44     	; 0x3a28 <chb_set_state+0xa0>

00003a54 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    3a54:	88 23       	and	r24, r24
    3a56:	49 f0       	breq	.+18     	; 0x3a6a <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    3a58:	88 e0       	ldi	r24, 0x08	; 8
    3a5a:	0e 94 c4 1c 	call	0x3988	; 0x3988 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    3a5e:	e4 e6       	ldi	r30, 0x64	; 100
    3a60:	f6 e0       	ldi	r31, 0x06	; 6
    3a62:	80 81       	ld	r24, Z
    3a64:	82 60       	ori	r24, 0x02	; 2
    3a66:	80 83       	st	Z, r24
    3a68:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    3a6a:	e4 e6       	ldi	r30, 0x64	; 100
    3a6c:	f6 e0       	ldi	r31, 0x06	; 6
    3a6e:	80 81       	ld	r24, Z
    3a70:	8d 7f       	andi	r24, 0xFD	; 253
    3a72:	80 83       	st	Z, r24
    3a74:	8f e7       	ldi	r24, 0x7F	; 127
    3a76:	97 e0       	ldi	r25, 0x07	; 7
    3a78:	01 97       	sbiw	r24, 0x01	; 1
    3a7a:	f1 f7       	brne	.-4      	; 0x3a78 <chb_sleep+0x24>
    3a7c:	00 c0       	rjmp	.+0      	; 0x3a7e <chb_sleep+0x2a>
    3a7e:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    3a80:	86 e1       	ldi	r24, 0x16	; 22
    3a82:	0e 94 c4 1c 	call	0x3988	; 0x3988 <chb_set_state>
    3a86:	08 95       	ret

00003a88 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    3a88:	cf 92       	push	r12
    3a8a:	df 92       	push	r13
    3a8c:	ef 92       	push	r14
    3a8e:	ff 92       	push	r15
    3a90:	0f 93       	push	r16
    3a92:	1f 93       	push	r17
    3a94:	cf 93       	push	r28
    3a96:	df 93       	push	r29
    3a98:	7c 01       	movw	r14, r24
    3a9a:	6b 01       	movw	r12, r22
    3a9c:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    3a9e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>
    3aa2:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3aa4:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <chb_get_pcb>
    3aa8:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3aaa:	12 30       	cpi	r17, 0x02	; 2
    3aac:	e1 f0       	breq	.+56     	; 0x3ae6 <chb_tx+0x5e>
    3aae:	12 31       	cpi	r17, 0x12	; 18
    3ab0:	e1 f0       	breq	.+56     	; 0x3aea <chb_tx+0x62>
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    //chb_set_state(CHB_TRX_OFF);
    chb_set_state(CHB_TX_ARET_ON);
    3ab2:	89 e1       	ldi	r24, 0x19	; 25
    3ab4:	0e 94 c4 1c 	call	0x3988	; 0x3988 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    3ab8:	c7 01       	movw	r24, r14
    3aba:	6a e0       	ldi	r22, 0x0A	; 10
    3abc:	a6 01       	movw	r20, r12
    3abe:	20 2f       	mov	r18, r16
    3ac0:	0e 94 ca 1b 	call	0x3794	; 0x3794 <chb_frame_write>

    //Do frame transmission. 
	pcb->tx_end = false;
    3ac4:	18 86       	std	Y+8, r1	; 0x08
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3ac6:	82 e0       	ldi	r24, 0x02	; 2
    3ac8:	62 e0       	ldi	r22, 0x02	; 2
    3aca:	4f e1       	ldi	r20, 0x1F	; 31
    3acc:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3ad0:	88 85       	ldd	r24, Y+8	; 0x08
    3ad2:	88 23       	and	r24, r24
    3ad4:	e9 f3       	breq	.-6      	; 0x3ad0 <chb_tx+0x48>
    pcb->tx_end = false;
    3ad6:	18 86       	std	Y+8, r1	; 0x08

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3ad8:	82 e0       	ldi	r24, 0x02	; 2
    3ada:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3ade:	82 95       	swap	r24
    3ae0:	86 95       	lsr	r24
    3ae2:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3ae4:	03 c0       	rjmp	.+6      	; 0x3aec <chb_tx+0x64>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3ae6:	84 e4       	ldi	r24, 0x44	; 68
    3ae8:	01 c0       	rjmp	.+2      	; 0x3aec <chb_tx+0x64>
    3aea:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3aec:	df 91       	pop	r29
    3aee:	cf 91       	pop	r28
    3af0:	1f 91       	pop	r17
    3af2:	0f 91       	pop	r16
    3af4:	ff 90       	pop	r15
    3af6:	ef 90       	pop	r14
    3af8:	df 90       	pop	r13
    3afa:	cf 90       	pop	r12
    3afc:	08 95       	ret

00003afe <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3afe:	81 30       	cpi	r24, 0x01	; 1
    3b00:	91 f0       	breq	.+36     	; 0x3b26 <chb_set_mode+0x28>
    3b02:	81 30       	cpi	r24, 0x01	; 1
    3b04:	28 f0       	brcs	.+10     	; 0x3b10 <chb_set_mode+0x12>
    3b06:	82 30       	cpi	r24, 0x02	; 2
    3b08:	c9 f0       	breq	.+50     	; 0x3b3c <chb_set_mode+0x3e>
    3b0a:	83 30       	cpi	r24, 0x03	; 3
    3b0c:	61 f5       	brne	.+88     	; 0x3b66 <chb_set_mode+0x68>
    3b0e:	21 c0       	rjmp	.+66     	; 0x3b52 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3b10:	8c e0       	ldi	r24, 0x0C	; 12
    3b12:	68 e0       	ldi	r22, 0x08	; 8
    3b14:	4f e3       	ldi	r20, 0x3F	; 63
    3b16:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3b1a:	86 e1       	ldi	r24, 0x16	; 22
    3b1c:	62 e0       	ldi	r22, 0x02	; 2
    3b1e:	43 e0       	ldi	r20, 0x03	; 3
    3b20:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
        break;
    3b24:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    3b26:	8c e0       	ldi	r24, 0x0C	; 12
    3b28:	6c e0       	ldi	r22, 0x0C	; 12
    3b2a:	4f e3       	ldi	r20, 0x3F	; 63
    3b2c:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3b30:	86 e1       	ldi	r24, 0x16	; 22
    3b32:	62 e0       	ldi	r22, 0x02	; 2
    3b34:	43 e0       	ldi	r20, 0x03	; 3
    3b36:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
        break;
    3b3a:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3b3c:	8c e0       	ldi	r24, 0x0C	; 12
    3b3e:	6c e1       	ldi	r22, 0x1C	; 28
    3b40:	4f e3       	ldi	r20, 0x3F	; 63
    3b42:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3b46:	86 e1       	ldi	r24, 0x16	; 22
    3b48:	62 e0       	ldi	r22, 0x02	; 2
    3b4a:	43 e0       	ldi	r20, 0x03	; 3
    3b4c:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
        break;
    3b50:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    3b52:	8c e0       	ldi	r24, 0x0C	; 12
    3b54:	60 e0       	ldi	r22, 0x00	; 0
    3b56:	4f e3       	ldi	r20, 0x3F	; 63
    3b58:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    3b5c:	86 e1       	ldi	r24, 0x16	; 22
    3b5e:	63 e0       	ldi	r22, 0x03	; 3
    3b60:	43 e0       	ldi	r20, 0x03	; 3
    3b62:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
    3b66:	08 95       	ret

00003b68 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    3b68:	cf 93       	push	r28
    3b6a:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    3b6c:	88 e0       	ldi	r24, 0x08	; 8
    3b6e:	6c 2f       	mov	r22, r28
    3b70:	4f e1       	ldi	r20, 0x1F	; 31
    3b72:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    3b76:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    3b7a:	86 30       	cpi	r24, 0x06	; 6
    3b7c:	11 f0       	breq	.+4      	; 0x3b82 <chb_set_channel+0x1a>
    3b7e:	89 30       	cpi	r24, 0x09	; 9
    3b80:	31 f4       	brne	.+12     	; 0x3b8e <chb_set_channel+0x26>
    3b82:	8f e6       	ldi	r24, 0x6F	; 111
    3b84:	93 e0       	ldi	r25, 0x03	; 3
    3b86:	01 97       	sbiw	r24, 0x01	; 1
    3b88:	f1 f7       	brne	.-4      	; 0x3b86 <chb_set_channel+0x1e>
    3b8a:	00 c0       	rjmp	.+0      	; 0x3b8c <chb_set_channel+0x24>
    3b8c:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3b8e:	88 e0       	ldi	r24, 0x08	; 8
    3b90:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	8f 71       	andi	r24, 0x1F	; 31
    3b98:	90 70       	andi	r25, 0x00	; 0
    3b9a:	6c 2f       	mov	r22, r28
    3b9c:	70 e0       	ldi	r23, 0x00	; 0
    3b9e:	86 17       	cp	r24, r22
    3ba0:	97 07       	cpc	r25, r23
    3ba2:	11 f4       	brne	.+4      	; 0x3ba8 <chb_set_channel+0x40>
    3ba4:	80 e4       	ldi	r24, 0x40	; 64
    3ba6:	01 c0       	rjmp	.+2      	; 0x3baa <chb_set_channel+0x42>
    3ba8:	83 e4       	ldi	r24, 0x43	; 67
}
    3baa:	cf 91       	pop	r28
    3bac:	08 95       	ret

00003bae <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3bae:	cf 93       	push	r28
    3bb0:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3bb2:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3bb6:	8c 2b       	or	r24, r28
    3bb8:	8f 5f       	subi	r24, 0xFF	; 255
    3bba:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    }
    return val;
}
    3bbe:	80 e0       	ldi	r24, 0x00	; 0
    3bc0:	90 e0       	ldi	r25, 0x00	; 0
    3bc2:	cf 91       	pop	r28
    3bc4:	08 95       	ret

00003bc6 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3bc6:	e4 e6       	ldi	r30, 0x64	; 100
    3bc8:	f6 e0       	ldi	r31, 0x06	; 6
    3bca:	80 81       	ld	r24, Z
    3bcc:	81 60       	ori	r24, 0x01	; 1
    3bce:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3bd0:	80 81       	ld	r24, Z
    3bd2:	8d 7f       	andi	r24, 0xFD	; 253
    3bd4:	80 83       	st	Z, r24
    3bd6:	8f ed       	ldi	r24, 0xDF	; 223
    3bd8:	9b e0       	ldi	r25, 0x0B	; 11
    3bda:	01 97       	sbiw	r24, 0x01	; 1
    3bdc:	f1 f7       	brne	.-4      	; 0x3bda <chb_reset+0x14>
    3bde:	00 c0       	rjmp	.+0      	; 0x3be0 <chb_reset+0x1a>
    3be0:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3be2:	80 81       	ld	r24, Z
    3be4:	8e 7f       	andi	r24, 0xFE	; 254
    3be6:	80 83       	st	Z, r24
    3be8:	9a e0       	ldi	r25, 0x0A	; 10
    3bea:	9a 95       	dec	r25
    3bec:	f1 f7       	brne	.-4      	; 0x3bea <chb_reset+0x24>
    3bee:	00 c0       	rjmp	.+0      	; 0x3bf0 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3bf0:	80 81       	ld	r24, Z
    3bf2:	81 60       	ori	r24, 0x01	; 1
    3bf4:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3bf6:	8d e1       	ldi	r24, 0x1D	; 29
    3bf8:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3bfc:	81 30       	cpi	r24, 0x01	; 1
    3bfe:	d9 f7       	brne	.-10     	; 0x3bf6 <chb_reset+0x30>
    3c00:	8c e1       	ldi	r24, 0x1C	; 28
    3c02:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3c06:	87 30       	cpi	r24, 0x07	; 7
    3c08:	b1 f7       	brne	.-20     	; 0x3bf6 <chb_reset+0x30>
            break;
        }
    }
	

}
    3c0a:	08 95       	ret

00003c0c <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3c0c:	0f 93       	push	r16
    3c0e:	1f 93       	push	r17
    3c10:	cf 93       	push	r28
    3c12:	df 93       	push	r29
    3c14:	cd b7       	in	r28, 0x3d	; 61
    3c16:	de b7       	in	r29, 0x3e	; 62
    3c18:	ea 97       	sbiw	r28, 0x3a	; 58
    3c1a:	cd bf       	out	0x3d, r28	; 61
    3c1c:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3c1e:	0e 94 18 20 	call	0x4030	; 0x4030 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3c22:	e0 e6       	ldi	r30, 0x60	; 96
    3c24:	f6 e0       	ldi	r31, 0x06	; 6
    3c26:	80 81       	ld	r24, Z
    3c28:	82 60       	ori	r24, 0x02	; 2
    3c2a:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3c2c:	80 81       	ld	r24, Z
    3c2e:	81 60       	ori	r24, 0x01	; 1
    3c30:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    3c32:	0e 94 e3 1d 	call	0x3bc6	; 0x3bc6 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    3c36:	8e e0       	ldi	r24, 0x0E	; 14
    3c38:	60 e0       	ldi	r22, 0x00	; 0
    3c3a:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3c3e:	82 e0       	ldi	r24, 0x02	; 2
    3c40:	63 e0       	ldi	r22, 0x03	; 3
    3c42:	4f e1       	ldi	r20, 0x1F	; 31
    3c44:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    3c48:	81 e0       	ldi	r24, 0x01	; 1
    3c4a:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3c4e:	8f 71       	andi	r24, 0x1F	; 31
    3c50:	88 30       	cpi	r24, 0x08	; 8
    3c52:	d1 f7       	brne	.-12     	; 0x3c48 <chb_drvr_init+0x3c>

    // set radio cfg parameters
    // **note** uncomment if these will be set to something other than default
    chb_reg_read_mod_write(XAH_CTRL_0, CHB_MAX_FRAME_RETRIES << CHB_MAX_FRAME_RETRIES_POS, 0xF << CHB_MAX_FRAME_RETRIES_POS);
    3c54:	8c e2       	ldi	r24, 0x2C	; 44
    3c56:	60 e3       	ldi	r22, 0x30	; 48
    3c58:	40 ef       	ldi	r20, 0xF0	; 240
    3c5a:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
    //chb_reg_read_mod_write(XAH_CTRL_0, CHB_MAX_CSMA_RETRIES << CHB_MAX_CSMA_RETIRES_POS, 0x7 << CHB_MAX_CSMA_RETIRES_POS);
    //chb_reg_read_mod_write(CSMA_SEED_1, CHB_CSMA_SEED1 << CHB_CSMA_SEED1_POS, 0x7 << CHB_CSMA_SEED1_POS);
    chb_reg_write(CSMA_SEED_0, CHB_CSMA_SEED0);     
    3c5e:	8d e2       	ldi	r24, 0x2D	; 45
    3c60:	60 e0       	ldi	r22, 0x00	; 0
    3c62:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    3c66:	8e e2       	ldi	r24, 0x2E	; 46
    3c68:	60 e4       	ldi	r22, 0x40	; 64
    3c6a:	40 ec       	ldi	r20, 0xC0	; 192
    3c6c:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3c70:	8e e0       	ldi	r24, 0x0E	; 14
    3c72:	6c e0       	ldi	r22, 0x0C	; 12
    3c74:	0e 94 15 1c 	call	0x382a	; 0x382a <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    3c78:	84 e0       	ldi	r24, 0x04	; 4
    3c7a:	60 e2       	ldi	r22, 0x20	; 32
    3c7c:	40 e2       	ldi	r20, 0x20	; 32
    3c7e:	0e 94 b0 1c 	call	0x3960	; 0x3960 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3c82:	81 e0       	ldi	r24, 0x01	; 1
    3c84:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    3c88:	81 e0       	ldi	r24, 0x01	; 1
    3c8a:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3c8e:	86 e1       	ldi	r24, 0x16	; 22
    3c90:	0e 94 c4 1c 	call	0x3988	; 0x3988 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3c94:	82 e2       	ldi	r24, 0x22	; 34
    3c96:	64 e3       	ldi	r22, 0x34	; 52
    3c98:	72 e1       	ldi	r23, 0x12	; 18
    3c9a:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3c9e:	0e 94 a8 1b 	call	0x3750	; 0x3750 <chb_get_short_addr>
    3ca2:	bc 01       	movw	r22, r24
    3ca4:	80 e2       	ldi	r24, 0x20	; 32
    3ca6:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3caa:	ce 01       	movw	r24, r28
    3cac:	01 96       	adiw	r24, 0x01	; 1
    3cae:	0e 94 a0 1b 	call	0x3740	; 0x3740 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3cb2:	84 e2       	ldi	r24, 0x24	; 36
    3cb4:	be 01       	movw	r22, r28
    3cb6:	6f 5f       	subi	r22, 0xFF	; 255
    3cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    3cba:	0e 94 36 1c 	call	0x386c	; 0x386c <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3cbe:	e2 e7       	ldi	r30, 0x72	; 114
    3cc0:	f6 e0       	ldi	r31, 0x06	; 6
    3cc2:	80 81       	ld	r24, Z
    3cc4:	81 60       	ori	r24, 0x01	; 1
    3cc6:	80 83       	st	Z, r24
    3cc8:	e9 e6       	ldi	r30, 0x69	; 105
    3cca:	f6 e0       	ldi	r31, 0x06	; 6
    3ccc:	80 81       	ld	r24, Z
    3cce:	83 60       	ori	r24, 0x03	; 3
    3cd0:	80 83       	st	Z, r24
    3cd2:	ea e6       	ldi	r30, 0x6A	; 106
    3cd4:	f6 e0       	ldi	r31, 0x06	; 6
    3cd6:	80 81       	ld	r24, Z
    3cd8:	84 60       	ori	r24, 0x04	; 4
    3cda:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3cdc:	e0 ea       	ldi	r30, 0xA0	; 160
    3cde:	f0 e0       	ldi	r31, 0x00	; 0
    3ce0:	82 81       	ldd	r24, Z+2	; 0x02
    3ce2:	87 60       	ori	r24, 0x07	; 7
    3ce4:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3ce6:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>
    3cea:	86 31       	cpi	r24, 0x16	; 22
    3cec:	91 f0       	breq	.+36     	; 0x3d12 <chb_drvr_init+0x106>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3cee:	8e 01       	movw	r16, r28
    3cf0:	07 5f       	subi	r16, 0xF7	; 247
    3cf2:	1f 4f       	sbci	r17, 0xFF	; 255
    3cf4:	c8 01       	movw	r24, r16
    3cf6:	68 ee       	ldi	r22, 0xE8	; 232
    3cf8:	71 e0       	ldi	r23, 0x01	; 1
    3cfa:	0e 94 10 3a 	call	0x7420	; 0x7420 <strcpy_P>
        printf(buf);
    3cfe:	0f 92       	push	r0
    3d00:	0f 92       	push	r0
    3d02:	ed b7       	in	r30, 0x3d	; 61
    3d04:	fe b7       	in	r31, 0x3e	; 62
    3d06:	01 83       	std	Z+1, r16	; 0x01
    3d08:	12 83       	std	Z+2, r17	; 0x02
    3d0a:	0e 94 55 3a 	call	0x74aa	; 0x74aa <printf>
    3d0e:	0f 90       	pop	r0
    3d10:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3d12:	ea 96       	adiw	r28, 0x3a	; 58
    3d14:	cd bf       	out	0x3d, r28	; 61
    3d16:	de bf       	out	0x3e, r29	; 62
    3d18:	df 91       	pop	r29
    3d1a:	cf 91       	pop	r28
    3d1c:	1f 91       	pop	r17
    3d1e:	0f 91       	pop	r16
    3d20:	08 95       	ret

00003d22 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3d22:	1f 92       	push	r1
    3d24:	0f 92       	push	r0
    3d26:	0f b6       	in	r0, 0x3f	; 63
    3d28:	0f 92       	push	r0
    3d2a:	0b b6       	in	r0, 0x3b	; 59
    3d2c:	0f 92       	push	r0
    3d2e:	11 24       	eor	r1, r1
    3d30:	af 92       	push	r10
    3d32:	bf 92       	push	r11
    3d34:	cf 92       	push	r12
    3d36:	df 92       	push	r13
    3d38:	ef 92       	push	r14
    3d3a:	ff 92       	push	r15
    3d3c:	0f 93       	push	r16
    3d3e:	1f 93       	push	r17
    3d40:	2f 93       	push	r18
    3d42:	3f 93       	push	r19
    3d44:	4f 93       	push	r20
    3d46:	5f 93       	push	r21
    3d48:	6f 93       	push	r22
    3d4a:	7f 93       	push	r23
    3d4c:	8f 93       	push	r24
    3d4e:	9f 93       	push	r25
    3d50:	af 93       	push	r26
    3d52:	bf 93       	push	r27
    3d54:	cf 93       	push	r28
    3d56:	df 93       	push	r29
    3d58:	ef 93       	push	r30
    3d5a:	ff 93       	push	r31
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3d5c:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <chb_get_pcb>
    3d60:	8c 01       	movw	r16, r24

    CHB_ENTER_CRIT();
    3d62:	8f b7       	in	r24, 0x3f	; 63
    3d64:	80 93 5c 40 	sts	0x405C, r24
    3d68:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3d6a:	81 e0       	ldi	r24, 0x01	; 1
    3d6c:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3d70:	8f e8       	ldi	r24, 0x8F	; 143
    3d72:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    intp_src = SPID_write(0);
    3d76:	80 e0       	ldi	r24, 0x00	; 0
    3d78:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    3d7c:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    3d7e:	80 e0       	ldi	r24, 0x00	; 0
    3d80:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>

    while (intp_src)
    3d84:	cc 23       	and	r28, r28
    3d86:	09 f4       	brne	.+2      	; 0x3d8a <__vector_64+0x68>
    3d88:	97 c0       	rjmp	.+302    	; 0x3eb8 <__vector_64+0x196>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            //else{
                pcb->tx_end = true;
    3d8a:	ff 24       	eor	r15, r15
    3d8c:	f3 94       	inc	r15

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3d8e:	cc 24       	eor	r12, r12
    3d90:	dd 24       	eor	r13, r13
    3d92:	68 94       	set
    3d94:	c7 f8       	bld	r12, 7
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3d96:	c2 ff       	sbrs	r28, 2
    3d98:	02 c0       	rjmp	.+4      	; 0x3d9e <__vector_64+0x7c>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3d9a:	cb 7f       	andi	r28, 0xFB	; 251
    3d9c:	8a c0       	rjmp	.+276    	; 0x3eb2 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3d9e:	c3 ff       	sbrs	r28, 3
    3da0:	6f c0       	rjmp	.+222    	; 0x3e80 <__vector_64+0x15e>
        {
            state = chb_get_state();
    3da2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3da6:	86 30       	cpi	r24, 0x06	; 6
    3da8:	29 f0       	breq	.+10     	; 0x3db4 <__vector_64+0x92>
    3daa:	86 31       	cpi	r24, 0x16	; 22
    3dac:	19 f0       	breq	.+6      	; 0x3db4 <__vector_64+0x92>
    3dae:	81 31       	cpi	r24, 0x11	; 17
    3db0:	09 f0       	breq	.+2      	; 0x3db4 <__vector_64+0x92>
    3db2:	5a c0       	rjmp	.+180    	; 0x3e68 <__vector_64+0x146>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3db4:	87 e0       	ldi	r24, 0x07	; 7
    3db6:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3dba:	f8 01       	movw	r30, r16
    3dbc:	86 8b       	std	Z+22, r24	; 0x16

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3dbe:	86 e0       	ldi	r24, 0x06	; 6
    3dc0:	0e 94 91 1c 	call	0x3922	; 0x3922 <chb_reg_read>
    3dc4:	88 1f       	adc	r24, r24
    3dc6:	88 27       	eor	r24, r24
    3dc8:	88 1f       	adc	r24, r24
    3dca:	f8 01       	movw	r30, r16
    3dcc:	87 8b       	std	Z+23, r24	; 0x17

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3dce:	88 23       	and	r24, r24
    3dd0:	09 f4       	brne	.+2      	; 0x3dd4 <__vector_64+0xb2>
    3dd2:	4a c0       	rjmp	.+148    	; 0x3e68 <__vector_64+0x146>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3dd4:	8f b7       	in	r24, 0x3f	; 63
    3dd6:	80 93 5c 40 	sts	0x405C, r24
    3dda:	f8 94       	cli
    RadioCS(TRUE);
    3ddc:	8f 2d       	mov	r24, r15
    3dde:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3de2:	80 e2       	ldi	r24, 0x20	; 32
    3de4:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    len = SPID_write(0);
    3de8:	80 e0       	ldi	r24, 0x00	; 0
    3dea:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
    3dee:	e8 2e       	mov	r14, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3df0:	83 50       	subi	r24, 0x03	; 3
    3df2:	8d 37       	cpi	r24, 0x7D	; 125
    3df4:	58 f5       	brcc	.+86     	; 0x3e4c <__vector_64+0x12a>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3df6:	0e 94 9d 1b 	call	0x373a	; 0x373a <chb_buf_get_len>
    3dfa:	2e 2d       	mov	r18, r14
    3dfc:	30 e0       	ldi	r19, 0x00	; 0
    3dfe:	a6 01       	movw	r20, r12
    3e00:	48 1b       	sub	r20, r24
    3e02:	51 09       	sbc	r21, r1
    3e04:	24 17       	cp	r18, r20
    3e06:	35 07       	cpc	r19, r21
    3e08:	7c f4       	brge	.+30     	; 0x3e28 <__vector_64+0x106>
        {
            chb_buf_write(len);
    3e0a:	8e 2d       	mov	r24, r14
    3e0c:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <chb_buf_write>
            
            for (i=0; i<len; i++)
    3e10:	ee 20       	and	r14, r14
    3e12:	e1 f0       	breq	.+56     	; 0x3e4c <__vector_64+0x12a>
    3e14:	d0 e0       	ldi	r29, 0x00	; 0
            {
                data = SPID_write(0);
    3e16:	80 e0       	ldi	r24, 0x00	; 0
    3e18:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
                chb_buf_write(data);
    3e1c:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3e20:	df 5f       	subi	r29, 0xFF	; 255
    3e22:	de 15       	cp	r29, r14
    3e24:	c1 f7       	brne	.-16     	; 0x3e16 <__vector_64+0xf4>
    3e26:	12 c0       	rjmp	.+36     	; 0x3e4c <__vector_64+0x12a>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3e28:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <chb_get_pcb>
    3e2c:	5c 01       	movw	r10, r24
            //char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3e2e:	ee 20       	and	r14, r14
    3e30:	39 f0       	breq	.+14     	; 0x3e40 <__vector_64+0x11e>
    3e32:	d0 e0       	ldi	r29, 0x00	; 0
            {
                data = SPID_write(0);
    3e34:	80 e0       	ldi	r24, 0x00	; 0
    3e36:	0e 94 2b 20 	call	0x4056	; 0x4056 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            //char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3e3a:	df 5f       	subi	r29, 0xFF	; 255
    3e3c:	de 15       	cp	r29, r14
    3e3e:	d1 f7       	brne	.-12     	; 0x3e34 <__vector_64+0x112>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3e40:	f5 01       	movw	r30, r10
    3e42:	81 89       	ldd	r24, Z+17	; 0x11
    3e44:	92 89       	ldd	r25, Z+18	; 0x12
    3e46:	01 96       	adiw	r24, 0x01	; 1
    3e48:	81 8b       	std	Z+17, r24	; 0x11
    3e4a:	92 8b       	std	Z+18, r25	; 0x12
            //strcpy_P(buf, chb_err_overflow);
            //printf(buf);
        }
    }

    RadioCS(FALSE);
    3e4c:	80 e0       	ldi	r24, 0x00	; 0
    3e4e:	0e 94 be 1b 	call	0x377c	; 0x377c <RadioCS>
    CHB_LEAVE_CRIT();
    3e52:	80 91 5c 40 	lds	r24, 0x405C
    3e56:	8f bf       	out	0x3f, r24	; 63
    3e58:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3e5a:	f8 01       	movw	r30, r16
    3e5c:	81 85       	ldd	r24, Z+9	; 0x09
    3e5e:	92 85       	ldd	r25, Z+10	; 0x0a
    3e60:	01 96       	adiw	r24, 0x01	; 1
    3e62:	81 87       	std	Z+9, r24	; 0x09
    3e64:	92 87       	std	Z+10, r25	; 0x0a
                    pcb->data_rcv = true;
    3e66:	f7 82       	std	Z+7, r15	; 0x07
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            //else{
                pcb->tx_end = true;
    3e68:	f8 01       	movw	r30, r16
    3e6a:	f0 86       	std	Z+8, r15	; 0x08
            //}
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3e6c:	c7 7f       	andi	r28, 0xF7	; 247
			//go to receive state
            while (chb_get_state() != RX_STATE){
    3e6e:	03 c0       	rjmp	.+6      	; 0x3e76 <__vector_64+0x154>
	            chb_set_state(RX_STATE);
    3e70:	86 e1       	ldi	r24, 0x16	; 22
    3e72:	0e 94 c4 1c 	call	0x3988	; 0x3988 <chb_set_state>
            //else{
                pcb->tx_end = true;
            //}
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
			//go to receive state
            while (chb_get_state() != RX_STATE){
    3e76:	0e 94 ab 1c 	call	0x3956	; 0x3956 <chb_get_state>
    3e7a:	86 31       	cpi	r24, 0x16	; 22
    3e7c:	c9 f7       	brne	.-14     	; 0x3e70 <__vector_64+0x14e>
    3e7e:	19 c0       	rjmp	.+50     	; 0x3eb2 <__vector_64+0x190>
	            chb_set_state(RX_STATE);
            }
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3e80:	c6 ff       	sbrs	r28, 6
    3e82:	08 c0       	rjmp	.+16     	; 0x3e94 <__vector_64+0x172>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3e84:	cf 7b       	andi	r28, 0xBF	; 191
            pcb->underrun++;
    3e86:	f8 01       	movw	r30, r16
    3e88:	83 89       	ldd	r24, Z+19	; 0x13
    3e8a:	94 89       	ldd	r25, Z+20	; 0x14
    3e8c:	01 96       	adiw	r24, 0x01	; 1
    3e8e:	83 8b       	std	Z+19, r24	; 0x13
    3e90:	94 8b       	std	Z+20, r25	; 0x14
    3e92:	0f c0       	rjmp	.+30     	; 0x3eb2 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3e94:	c1 ff       	sbrs	r28, 1
    3e96:	02 c0       	rjmp	.+4      	; 0x3e9c <__vector_64+0x17a>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3e98:	cd 7f       	andi	r28, 0xFD	; 253
    3e9a:	0b c0       	rjmp	.+22     	; 0x3eb2 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3e9c:	c0 ff       	sbrs	r28, 0
    3e9e:	02 c0       	rjmp	.+4      	; 0x3ea4 <__vector_64+0x182>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3ea0:	ce 7f       	andi	r28, 0xFE	; 254
    3ea2:	07 c0       	rjmp	.+14     	; 0x3eb2 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3ea4:	cc 23       	and	r28, r28
    3ea6:	2c f4       	brge	.+10     	; 0x3eb2 <__vector_64+0x190>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3ea8:	cf 77       	andi	r28, 0x7F	; 127
            pcb->battlow++;
    3eaa:	f8 01       	movw	r30, r16
    3eac:	85 89       	ldd	r24, Z+21	; 0x15
    3eae:	8f 5f       	subi	r24, 0xFF	; 255
    3eb0:	85 8b       	std	Z+21, r24	; 0x15
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3eb2:	cc 23       	and	r28, r28
    3eb4:	09 f0       	breq	.+2      	; 0x3eb8 <__vector_64+0x196>
    3eb6:	6f cf       	rjmp	.-290    	; 0x3d96 <__vector_64+0x74>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3eb8:	80 91 5c 40 	lds	r24, 0x405C
    3ebc:	8f bf       	out	0x3f, r24	; 63
    3ebe:	78 94       	sei
}
    3ec0:	ff 91       	pop	r31
    3ec2:	ef 91       	pop	r30
    3ec4:	df 91       	pop	r29
    3ec6:	cf 91       	pop	r28
    3ec8:	bf 91       	pop	r27
    3eca:	af 91       	pop	r26
    3ecc:	9f 91       	pop	r25
    3ece:	8f 91       	pop	r24
    3ed0:	7f 91       	pop	r23
    3ed2:	6f 91       	pop	r22
    3ed4:	5f 91       	pop	r21
    3ed6:	4f 91       	pop	r20
    3ed8:	3f 91       	pop	r19
    3eda:	2f 91       	pop	r18
    3edc:	1f 91       	pop	r17
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	df 90       	pop	r13
    3ee6:	cf 90       	pop	r12
    3ee8:	bf 90       	pop	r11
    3eea:	af 90       	pop	r10
    3eec:	0f 90       	pop	r0
    3eee:	0b be       	out	0x3b, r0	; 59
    3ef0:	0f 90       	pop	r0
    3ef2:	0f be       	out	0x3f, r0	; 63
    3ef4:	0f 90       	pop	r0
    3ef6:	1f 90       	pop	r1
    3ef8:	18 95       	reti

00003efa <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3efa:	0f 93       	push	r16
    3efc:	1f 93       	push	r17
    3efe:	cf 93       	push	r28
    3f00:	df 93       	push	r29
    3f02:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3f04:	e0 ec       	ldi	r30, 0xC0	; 192
    3f06:	f1 e0       	ldi	r31, 0x01	; 1
    3f08:	84 85       	ldd	r24, Z+12	; 0x0c
    3f0a:	87 7f       	andi	r24, 0xF7	; 247
    3f0c:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3f0e:	41 15       	cp	r20, r1
    3f10:	51 05       	cpc	r21, r1
    3f12:	09 f4       	brne	.+2      	; 0x3f16 <chb_eeprom_write+0x1c>
    3f14:	50 c0       	rjmp	.+160    	; 0x3fb6 <chb_eeprom_write+0xbc>
    3f16:	e0 e0       	ldi	r30, 0x00	; 0
    3f18:	f0 e0       	ldi	r31, 0x00	; 0
    3f1a:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3f1c:	a0 ec       	ldi	r26, 0xC0	; 192
    3f1e:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3f20:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3f22:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3f24:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3f26:	cf 01       	movw	r24, r30
    3f28:	80 0f       	add	r24, r16
    3f2a:	91 1f       	adc	r25, r17
    3f2c:	e6 0f       	add	r30, r22
    3f2e:	f7 1f       	adc	r31, r23
    3f30:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3f32:	1f 96       	adiw	r26, 0x0f	; 15
    3f34:	ec 91       	ld	r30, X
    3f36:	1f 97       	sbiw	r26, 0x0f	; 15
    3f38:	ee 23       	and	r30, r30
    3f3a:	dc f3       	brlt	.-10     	; 0x3f32 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3f3c:	1f 96       	adiw	r26, 0x0f	; 15
    3f3e:	ec 91       	ld	r30, X
    3f40:	1f 97       	sbiw	r26, 0x0f	; 15
    3f42:	e1 ff       	sbrs	r30, 1
    3f44:	11 c0       	rjmp	.+34     	; 0x3f68 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3f46:	1a 96       	adiw	r26, 0x0a	; 10
    3f48:	dc 93       	st	X, r29
    3f4a:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3f4c:	ef 93       	push	r30
    3f4e:	ff 93       	push	r31
    3f50:	0f 93       	push	r16
    3f52:	2f 93       	push	r18
    3f54:	eb ec       	ldi	r30, 0xCB	; 203
    3f56:	f1 e0       	ldi	r31, 0x01	; 1
    3f58:	08 ed       	ldi	r16, 0xD8	; 216
    3f5a:	21 e0       	ldi	r18, 0x01	; 1
    3f5c:	04 bf       	out	0x34, r16	; 52
    3f5e:	20 83       	st	Z, r18
    3f60:	2f 91       	pop	r18
    3f62:	0f 91       	pop	r16
    3f64:	ff 91       	pop	r31
    3f66:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3f68:	1a 96       	adiw	r26, 0x0a	; 10
    3f6a:	cc 93       	st	X, r28
    3f6c:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3f6e:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3f70:	89 2f       	mov	r24, r25
    3f72:	8f 71       	andi	r24, 0x1F	; 31
    3f74:	11 96       	adiw	r26, 0x01	; 1
    3f76:	8c 93       	st	X, r24
    3f78:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3f7a:	12 96       	adiw	r26, 0x02	; 2
    3f7c:	1c 92       	st	X, r1
    3f7e:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3f80:	14 96       	adiw	r26, 0x04	; 4
    3f82:	fc 93       	st	X, r31
    3f84:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3f86:	1a 96       	adiw	r26, 0x0a	; 10
    3f88:	3c 93       	st	X, r19
    3f8a:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3f8c:	ef 93       	push	r30
    3f8e:	ff 93       	push	r31
    3f90:	0f 93       	push	r16
    3f92:	2f 93       	push	r18
    3f94:	eb ec       	ldi	r30, 0xCB	; 203
    3f96:	f1 e0       	ldi	r31, 0x01	; 1
    3f98:	08 ed       	ldi	r16, 0xD8	; 216
    3f9a:	21 e0       	ldi	r18, 0x01	; 1
    3f9c:	04 bf       	out	0x34, r16	; 52
    3f9e:	20 83       	st	Z, r18
    3fa0:	2f 91       	pop	r18
    3fa2:	0f 91       	pop	r16
    3fa4:	ff 91       	pop	r31
    3fa6:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3fa8:	2f 5f       	subi	r18, 0xFF	; 255
    3faa:	e2 2f       	mov	r30, r18
    3fac:	f0 e0       	ldi	r31, 0x00	; 0
    3fae:	e4 17       	cp	r30, r20
    3fb0:	f5 07       	cpc	r31, r21
    3fb2:	08 f4       	brcc	.+2      	; 0x3fb6 <chb_eeprom_write+0xbc>
    3fb4:	b8 cf       	rjmp	.-144    	; 0x3f26 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3fb6:	df 91       	pop	r29
    3fb8:	cf 91       	pop	r28
    3fba:	1f 91       	pop	r17
    3fbc:	0f 91       	pop	r16
    3fbe:	08 95       	ret

00003fc0 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3fc0:	1f 93       	push	r17
    3fc2:	cf 93       	push	r28
    3fc4:	df 93       	push	r29
    3fc6:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3fc8:	e0 ec       	ldi	r30, 0xC0	; 192
    3fca:	f1 e0       	ldi	r31, 0x01	; 1
    3fcc:	84 85       	ldd	r24, Z+12	; 0x0c
    3fce:	87 7f       	andi	r24, 0xF7	; 247
    3fd0:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3fd2:	41 15       	cp	r20, r1
    3fd4:	51 05       	cpc	r21, r1
    3fd6:	41 f1       	breq	.+80     	; 0x4028 <chb_eeprom_read+0x68>
    3fd8:	80 e0       	ldi	r24, 0x00	; 0
    3fda:	90 e0       	ldi	r25, 0x00	; 0
    3fdc:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3fde:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3fe0:	db 01       	movw	r26, r22
    3fe2:	a8 0f       	add	r26, r24
    3fe4:	b9 1f       	adc	r27, r25
    3fe6:	82 0f       	add	r24, r18
    3fe8:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3fea:	17 85       	ldd	r17, Z+15	; 0x0f
    3fec:	11 23       	and	r17, r17
    3fee:	ec f3       	brlt	.-6      	; 0x3fea <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3ff0:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3ff2:	89 2f       	mov	r24, r25
    3ff4:	8f 71       	andi	r24, 0x1F	; 31
    3ff6:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3ff8:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3ffa:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3ffc:	ef 93       	push	r30
    3ffe:	ff 93       	push	r31
    4000:	0f 93       	push	r16
    4002:	2f 93       	push	r18
    4004:	eb ec       	ldi	r30, 0xCB	; 203
    4006:	f1 e0       	ldi	r31, 0x01	; 1
    4008:	08 ed       	ldi	r16, 0xD8	; 216
    400a:	21 e0       	ldi	r18, 0x01	; 1
    400c:	04 bf       	out	0x34, r16	; 52
    400e:	20 83       	st	Z, r18
    4010:	2f 91       	pop	r18
    4012:	0f 91       	pop	r16
    4014:	ff 91       	pop	r31
    4016:	ef 91       	pop	r30

    return NVM.DATA0;
    4018:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    401a:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    401c:	cf 5f       	subi	r28, 0xFF	; 255
    401e:	8c 2f       	mov	r24, r28
    4020:	90 e0       	ldi	r25, 0x00	; 0
    4022:	84 17       	cp	r24, r20
    4024:	95 07       	cpc	r25, r21
    4026:	e0 f2       	brcs	.-72     	; 0x3fe0 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    4028:	df 91       	pop	r29
    402a:	cf 91       	pop	r28
    402c:	1f 91       	pop	r17
    402e:	08 95       	ret

00004030 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    4030:	e0 e6       	ldi	r30, 0x60	; 96
    4032:	f6 e0       	ldi	r31, 0x06	; 6
    4034:	80 81       	ld	r24, Z
    4036:	80 6b       	ori	r24, 0xB0	; 176
    4038:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    403a:	e4 e6       	ldi	r30, 0x64	; 100
    403c:	f6 e0       	ldi	r31, 0x06	; 6
    403e:	80 81       	ld	r24, Z
    4040:	80 61       	ori	r24, 0x10	; 16
    4042:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    4044:	a0 ec       	ldi	r26, 0xC0	; 192
    4046:	b9 e0       	ldi	r27, 0x09	; 9
    4048:	8c 91       	ld	r24, X
    404a:	81 65       	ori	r24, 0x51	; 81
    404c:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    404e:	80 81       	ld	r24, Z
    4050:	80 61       	ori	r24, 0x10	; 16
    4052:	80 83       	st	Z, r24
}
    4054:	08 95       	ret

00004056 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    4056:	e0 ec       	ldi	r30, 0xC0	; 192
    4058:	f9 e0       	ldi	r31, 0x09	; 9
    405a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    405c:	82 81       	ldd	r24, Z+2	; 0x02
    405e:	88 23       	and	r24, r24
    4060:	ec f7       	brge	.-6      	; 0x405c <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    4062:	e0 ec       	ldi	r30, 0xC0	; 192
    4064:	f9 e0       	ldi	r31, 0x09	; 9
    4066:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    4068:	08 95       	ret

0000406a <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    406a:	0f 93       	push	r16
    406c:	cf 93       	push	r28
    406e:	df 93       	push	r29
    4070:	0f 92       	push	r0
    4072:	cd b7       	in	r28, 0x3d	; 61
    4074:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    4076:	2f b7       	in	r18, 0x3f	; 63
    4078:	29 83       	std	Y+1, r18	; 0x01
    407a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    407c:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    407e:	fc 01       	movw	r30, r24
    4080:	08 ed       	ldi	r16, 0xD8	; 216
    4082:	04 bf       	out	0x34, r16	; 52
    4084:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    4086:	89 81       	ldd	r24, Y+1	; 0x01
    4088:	8f bf       	out	0x3f, r24	; 63
#endif
}
    408a:	0f 90       	pop	r0
    408c:	df 91       	pop	r29
    408e:	cf 91       	pop	r28
    4090:	0f 91       	pop	r16
    4092:	08 95       	ret

00004094 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    4094:	66 23       	and	r22, r22
    4096:	11 f0       	breq	.+4      	; 0x409c <CLKSYS_XOSC_Config+0x8>
    4098:	90 e2       	ldi	r25, 0x20	; 32
    409a:	01 c0       	rjmp	.+2      	; 0x409e <CLKSYS_XOSC_Config+0xa>
    409c:	90 e0       	ldi	r25, 0x00	; 0
    409e:	84 2b       	or	r24, r20
    40a0:	89 2b       	or	r24, r25
    40a2:	e0 e5       	ldi	r30, 0x50	; 80
    40a4:	f0 e0       	ldi	r31, 0x00	; 0
    40a6:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    40a8:	08 95       	ret

000040aa <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    40aa:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    40ac:	86 2b       	or	r24, r22
    40ae:	e0 e5       	ldi	r30, 0x50	; 80
    40b0:	f0 e0       	ldi	r31, 0x00	; 0
    40b2:	85 83       	std	Z+5, r24	; 0x05
}
    40b4:	08 95       	ret

000040b6 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    40b6:	e0 e5       	ldi	r30, 0x50	; 80
    40b8:	f0 e0       	ldi	r31, 0x00	; 0
    40ba:	90 81       	ld	r25, Z
    40bc:	28 2f       	mov	r18, r24
    40be:	20 95       	com	r18
    40c0:	92 23       	and	r25, r18
    40c2:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    40c4:	90 81       	ld	r25, Z
	return clkEnabled;
}
    40c6:	89 23       	and	r24, r25
    40c8:	08 95       	ret

000040ca <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    40ca:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    40cc:	81 e4       	ldi	r24, 0x41	; 65
    40ce:	90 e0       	ldi	r25, 0x00	; 0
    40d0:	0e 94 35 20 	call	0x406a	; 0x406a <CCPWrite>
}
    40d4:	08 95       	ret

000040d6 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    40d6:	1f 93       	push	r17
    40d8:	cf 93       	push	r28
    40da:	df 93       	push	r29
    40dc:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    40de:	c0 e4       	ldi	r28, 0x40	; 64
    40e0:	d0 e0       	ldi	r29, 0x00	; 0
    40e2:	68 81       	ld	r22, Y
    40e4:	68 7f       	andi	r22, 0xF8	; 248
    40e6:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    40e8:	80 e4       	ldi	r24, 0x40	; 64
    40ea:	90 e0       	ldi	r25, 0x00	; 0
    40ec:	0e 94 35 20 	call	0x406a	; 0x406a <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    40f0:	88 81       	ld	r24, Y
	return clkCtrl;
}
    40f2:	81 23       	and	r24, r17
    40f4:	df 91       	pop	r29
    40f6:	cf 91       	pop	r28
    40f8:	1f 91       	pop	r17
    40fa:	08 95       	ret

000040fc <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    40fc:	e0 e4       	ldi	r30, 0x40	; 64
    40fe:	f0 e0       	ldi	r31, 0x00	; 0
    4100:	93 81       	ldd	r25, Z+3	; 0x03
    4102:	91 7f       	andi	r25, 0xF1	; 241
    4104:	91 60       	ori	r25, 0x01	; 1
    4106:	89 2b       	or	r24, r25
    4108:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    410a:	08 95       	ret

0000410c <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    410c:	e0 e5       	ldi	r30, 0x50	; 80
    410e:	f0 e0       	ldi	r31, 0x00	; 0
    4110:	26 81       	ldd	r18, Z+6	; 0x06
    4112:	98 2f       	mov	r25, r24
    4114:	38 2f       	mov	r19, r24
    4116:	30 95       	com	r19
    4118:	23 23       	and	r18, r19
    411a:	66 23       	and	r22, r22
    411c:	09 f4       	brne	.+2      	; 0x4120 <CLKSYS_AutoCalibration_Enable+0x14>
    411e:	90 e0       	ldi	r25, 0x00	; 0
    4120:	92 2b       	or	r25, r18
    4122:	e0 e5       	ldi	r30, 0x50	; 80
    4124:	f0 e0       	ldi	r31, 0x00	; 0
    4126:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    4128:	81 30       	cpi	r24, 0x01	; 1
    412a:	31 f4       	brne	.+12     	; 0x4138 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    412c:	e8 e6       	ldi	r30, 0x68	; 104
    412e:	f0 e0       	ldi	r31, 0x00	; 0
    4130:	80 81       	ld	r24, Z
    4132:	81 60       	ori	r24, 0x01	; 1
    4134:	80 83       	st	Z, r24
    4136:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    4138:	82 30       	cpi	r24, 0x02	; 2
    413a:	29 f4       	brne	.+10     	; 0x4146 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    413c:	e0 e6       	ldi	r30, 0x60	; 96
    413e:	f0 e0       	ldi	r31, 0x00	; 0
    4140:	80 81       	ld	r24, Z
    4142:	81 60       	ori	r24, 0x01	; 1
    4144:	80 83       	st	Z, r24
    4146:	08 95       	ret

00004148 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    4148:	83 e5       	ldi	r24, 0x53	; 83
    414a:	90 e0       	ldi	r25, 0x00	; 0
    414c:	63 e0       	ldi	r22, 0x03	; 3
    414e:	0e 94 35 20 	call	0x406a	; 0x406a <CCPWrite>
}
    4152:	08 95       	ret

00004154 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    4154:	82 e4       	ldi	r24, 0x42	; 66
    4156:	90 e0       	ldi	r25, 0x00	; 0
    4158:	61 e0       	ldi	r22, 0x01	; 1
    415a:	0e 94 35 20 	call	0x406a	; 0x406a <CCPWrite>
}
    415e:	08 95       	ret

00004160 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    4160:	cf 92       	push	r12
    4162:	df 92       	push	r13
    4164:	ef 92       	push	r14
    4166:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    4168:	20 91 6e 50 	lds	r18, 0x506E
    416c:	30 91 6f 50 	lds	r19, 0x506F
    4170:	c0 90 52 40 	lds	r12, 0x4052
    4174:	d0 90 53 40 	lds	r13, 0x4053
    4178:	e0 90 54 40 	lds	r14, 0x4054
    417c:	f0 90 55 40 	lds	r15, 0x4055
    4180:	62 50       	subi	r22, 0x02	; 2
    4182:	70 40       	sbci	r23, 0x00	; 0
    4184:	80 40       	sbci	r24, 0x00	; 0
    4186:	90 40       	sbci	r25, 0x00	; 0
    4188:	40 e0       	ldi	r20, 0x00	; 0
    418a:	50 e0       	ldi	r21, 0x00	; 0
    418c:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    4190:	dc 01       	movw	r26, r24
    4192:	cb 01       	movw	r24, r22
    4194:	c8 0e       	add	r12, r24
    4196:	d9 1e       	adc	r13, r25
    4198:	ea 1e       	adc	r14, r26
    419a:	fb 1e       	adc	r15, r27
}
    419c:	6c 2d       	mov	r22, r12
    419e:	7d 2d       	mov	r23, r13
    41a0:	8e 2d       	mov	r24, r14
    41a2:	9f 2d       	mov	r25, r15
    41a4:	ff 90       	pop	r15
    41a6:	ef 90       	pop	r14
    41a8:	df 90       	pop	r13
    41aa:	cf 90       	pop	r12
    41ac:	08 95       	ret

000041ae <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    41ae:	3f 92       	push	r3
    41b0:	4f 92       	push	r4
    41b2:	5f 92       	push	r5
    41b4:	6f 92       	push	r6
    41b6:	7f 92       	push	r7
    41b8:	8f 92       	push	r8
    41ba:	9f 92       	push	r9
    41bc:	af 92       	push	r10
    41be:	bf 92       	push	r11
    41c0:	cf 92       	push	r12
    41c2:	df 92       	push	r13
    41c4:	ef 92       	push	r14
    41c6:	ff 92       	push	r15
    41c8:	0f 93       	push	r16
    41ca:	1f 93       	push	r17
    41cc:	cf 93       	push	r28
    41ce:	df 93       	push	r29
    41d0:	00 d0       	rcall	.+0      	; 0x41d2 <getSetNextCluster+0x24>
    41d2:	0f 92       	push	r0
    41d4:	cd b7       	in	r28, 0x3d	; 61
    41d6:	de b7       	in	r29, 0x3e	; 62
    41d8:	dc 01       	movw	r26, r24
    41da:	cb 01       	movw	r24, r22
    41dc:	34 2e       	mov	r3, r20
    41de:	09 83       	std	Y+1, r16	; 0x01
    41e0:	1a 83       	std	Y+2, r17	; 0x02
    41e2:	2b 83       	std	Y+3, r18	; 0x03
    41e4:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    41e6:	80 90 74 50 	lds	r8, 0x5074
    41ea:	90 90 75 50 	lds	r9, 0x5075
    41ee:	2c 01       	movw	r4, r24
    41f0:	3d 01       	movw	r6, r26
    41f2:	44 0c       	add	r4, r4
    41f4:	55 1c       	adc	r5, r5
    41f6:	66 1c       	adc	r6, r6
    41f8:	77 1c       	adc	r7, r7
    41fa:	44 0c       	add	r4, r4
    41fc:	55 1c       	adc	r5, r5
    41fe:	66 1c       	adc	r6, r6
    4200:	77 1c       	adc	r7, r7
    4202:	20 91 5a 40 	lds	r18, 0x405A
    4206:	30 91 5b 40 	lds	r19, 0x405B
    420a:	aa 24       	eor	r10, r10
    420c:	bb 24       	eor	r11, r11
    420e:	80 91 70 50 	lds	r24, 0x5070
    4212:	90 91 71 50 	lds	r25, 0x5071
    4216:	a0 91 72 50 	lds	r26, 0x5072
    421a:	b0 91 73 50 	lds	r27, 0x5073
    421e:	88 0e       	add	r8, r24
    4220:	99 1e       	adc	r9, r25
    4222:	aa 1e       	adc	r10, r26
    4224:	bb 1e       	adc	r11, r27
    4226:	40 e0       	ldi	r20, 0x00	; 0
    4228:	50 e0       	ldi	r21, 0x00	; 0
    422a:	c3 01       	movw	r24, r6
    422c:	b2 01       	movw	r22, r4
    422e:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    4232:	69 01       	movw	r12, r18
    4234:	7a 01       	movw	r14, r20
    4236:	c8 0c       	add	r12, r8
    4238:	d9 1c       	adc	r13, r9
    423a:	ea 1c       	adc	r14, r10
    423c:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    423e:	00 91 5a 40 	lds	r16, 0x405A
    4242:	10 91 5b 40 	lds	r17, 0x405B

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    4246:	c7 01       	movw	r24, r14
    4248:	b6 01       	movw	r22, r12
    424a:	4d e4       	ldi	r20, 0x4D	; 77
    424c:	5e e3       	ldi	r21, 0x3E	; 62
    424e:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    4252:	98 01       	movw	r18, r16
    4254:	40 e0       	ldi	r20, 0x00	; 0
    4256:	50 e0       	ldi	r21, 0x00	; 0
    4258:	c3 01       	movw	r24, r6
    425a:	b2 01       	movw	r22, r4
    425c:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    4260:	63 5b       	subi	r22, 0xB3	; 179
    4262:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    4264:	33 20       	and	r3, r3
    4266:	41 f4       	brne	.+16     	; 0x4278 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    4268:	db 01       	movw	r26, r22
    426a:	0d 91       	ld	r16, X+
    426c:	1d 91       	ld	r17, X+
    426e:	2d 91       	ld	r18, X+
    4270:	3c 91       	ld	r19, X
    4272:	13 97       	sbiw	r26, 0x03	; 3
    4274:	3f 70       	andi	r19, 0x0F	; 15
    4276:	14 c0       	rjmp	.+40     	; 0x42a0 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4278:	89 81       	ldd	r24, Y+1	; 0x01
    427a:	9a 81       	ldd	r25, Y+2	; 0x02
    427c:	ab 81       	ldd	r26, Y+3	; 0x03
    427e:	bc 81       	ldd	r27, Y+4	; 0x04
    4280:	fb 01       	movw	r30, r22
    4282:	80 83       	st	Z, r24
    4284:	91 83       	std	Z+1, r25	; 0x01
    4286:	a2 83       	std	Z+2, r26	; 0x02
    4288:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    428a:	c7 01       	movw	r24, r14
    428c:	b6 01       	movw	r22, r12
    428e:	4d e4       	ldi	r20, 0x4D	; 77
    4290:	5e e3       	ldi	r21, 0x3E	; 62
    4292:	20 e0       	ldi	r18, 0x00	; 0
    4294:	32 e0       	ldi	r19, 0x02	; 2
    4296:	0e 94 01 2b 	call	0x5602	; 0x5602 <SD_write_block>

return (0);
    429a:	00 e0       	ldi	r16, 0x00	; 0
    429c:	10 e0       	ldi	r17, 0x00	; 0
    429e:	98 01       	movw	r18, r16
}
    42a0:	60 2f       	mov	r22, r16
    42a2:	71 2f       	mov	r23, r17
    42a4:	82 2f       	mov	r24, r18
    42a6:	93 2f       	mov	r25, r19
    42a8:	24 96       	adiw	r28, 0x04	; 4
    42aa:	cd bf       	out	0x3d, r28	; 61
    42ac:	de bf       	out	0x3e, r29	; 62
    42ae:	df 91       	pop	r29
    42b0:	cf 91       	pop	r28
    42b2:	1f 91       	pop	r17
    42b4:	0f 91       	pop	r16
    42b6:	ff 90       	pop	r15
    42b8:	ef 90       	pop	r14
    42ba:	df 90       	pop	r13
    42bc:	cf 90       	pop	r12
    42be:	bf 90       	pop	r11
    42c0:	af 90       	pop	r10
    42c2:	9f 90       	pop	r9
    42c4:	8f 90       	pop	r8
    42c6:	7f 90       	pop	r7
    42c8:	6f 90       	pop	r6
    42ca:	5f 90       	pop	r5
    42cc:	4f 90       	pop	r4
    42ce:	3f 90       	pop	r3
    42d0:	08 95       	ret

000042d2 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    42d2:	cf 92       	push	r12
    42d4:	df 92       	push	r13
    42d6:	ef 92       	push	r14
    42d8:	ff 92       	push	r15
    42da:	0f 93       	push	r16
    42dc:	1f 93       	push	r17
    42de:	cf 93       	push	r28
    42e0:	c8 2f       	mov	r28, r24
    42e2:	06 2f       	mov	r16, r22
    42e4:	69 01       	movw	r12, r18
    42e6:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    42e8:	80 91 70 50 	lds	r24, 0x5070
    42ec:	90 91 71 50 	lds	r25, 0x5071
    42f0:	a0 91 72 50 	lds	r26, 0x5072
    42f4:	b0 91 73 50 	lds	r27, 0x5073
    42f8:	bc 01       	movw	r22, r24
    42fa:	cd 01       	movw	r24, r26
    42fc:	6f 5f       	subi	r22, 0xFF	; 255
    42fe:	7f 4f       	sbci	r23, 0xFF	; 255
    4300:	8f 4f       	sbci	r24, 0xFF	; 255
    4302:	9f 4f       	sbci	r25, 0xFF	; 255
    4304:	4d e4       	ldi	r20, 0x4D	; 77
    4306:	5e e3       	ldi	r21, 0x3E	; 62
    4308:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    430c:	80 91 4d 3e 	lds	r24, 0x3E4D
    4310:	90 91 4e 3e 	lds	r25, 0x3E4E
    4314:	a0 91 4f 3e 	lds	r26, 0x3E4F
    4318:	b0 91 50 3e 	lds	r27, 0x3E50
    431c:	82 35       	cpi	r24, 0x52	; 82
    431e:	22 e5       	ldi	r18, 0x52	; 82
    4320:	92 07       	cpc	r25, r18
    4322:	21 e6       	ldi	r18, 0x61	; 97
    4324:	a2 07       	cpc	r26, r18
    4326:	21 e4       	ldi	r18, 0x41	; 65
    4328:	b2 07       	cpc	r27, r18
    432a:	09 f0       	breq	.+2      	; 0x432e <getSetFreeCluster+0x5c>
    432c:	63 c0       	rjmp	.+198    	; 0x43f4 <getSetFreeCluster+0x122>
    432e:	80 91 31 40 	lds	r24, 0x4031
    4332:	90 91 32 40 	lds	r25, 0x4032
    4336:	a0 91 33 40 	lds	r26, 0x4033
    433a:	b0 91 34 40 	lds	r27, 0x4034
    433e:	82 37       	cpi	r24, 0x72	; 114
    4340:	22 e7       	ldi	r18, 0x72	; 114
    4342:	92 07       	cpc	r25, r18
    4344:	21 e4       	ldi	r18, 0x41	; 65
    4346:	a2 07       	cpc	r26, r18
    4348:	21 e6       	ldi	r18, 0x61	; 97
    434a:	b2 07       	cpc	r27, r18
    434c:	09 f0       	breq	.+2      	; 0x4350 <getSetFreeCluster+0x7e>
    434e:	56 c0       	rjmp	.+172    	; 0x43fc <getSetFreeCluster+0x12a>
    4350:	80 91 49 40 	lds	r24, 0x4049
    4354:	90 91 4a 40 	lds	r25, 0x404A
    4358:	a0 91 4b 40 	lds	r26, 0x404B
    435c:	b0 91 4c 40 	lds	r27, 0x404C
    4360:	80 30       	cpi	r24, 0x00	; 0
    4362:	20 e0       	ldi	r18, 0x00	; 0
    4364:	92 07       	cpc	r25, r18
    4366:	25 e5       	ldi	r18, 0x55	; 85
    4368:	a2 07       	cpc	r26, r18
    436a:	2a ea       	ldi	r18, 0xAA	; 170
    436c:	b2 07       	cpc	r27, r18
    436e:	09 f0       	breq	.+2      	; 0x4372 <getSetFreeCluster+0xa0>
    4370:	49 c0       	rjmp	.+146    	; 0x4404 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4372:	00 23       	and	r16, r16
    4374:	a1 f4       	brne	.+40     	; 0x439e <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4376:	c1 30       	cpi	r28, 0x01	; 1
    4378:	49 f4       	brne	.+18     	; 0x438c <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    437a:	00 91 35 40 	lds	r16, 0x4035
    437e:	10 91 36 40 	lds	r17, 0x4036
    4382:	20 91 37 40 	lds	r18, 0x4037
    4386:	30 91 38 40 	lds	r19, 0x4038
    438a:	3f c0       	rjmp	.+126    	; 0x440a <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    438c:	00 91 39 40 	lds	r16, 0x4039
    4390:	10 91 3a 40 	lds	r17, 0x403A
    4394:	20 91 3b 40 	lds	r18, 0x403B
    4398:	30 91 3c 40 	lds	r19, 0x403C
    439c:	36 c0       	rjmp	.+108    	; 0x440a <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    439e:	c1 30       	cpi	r28, 0x01	; 1
    43a0:	49 f4       	brne	.+18     	; 0x43b4 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    43a2:	c0 92 35 40 	sts	0x4035, r12
    43a6:	d0 92 36 40 	sts	0x4036, r13
    43aa:	e0 92 37 40 	sts	0x4037, r14
    43ae:	f0 92 38 40 	sts	0x4038, r15
    43b2:	08 c0       	rjmp	.+16     	; 0x43c4 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    43b4:	c0 92 39 40 	sts	0x4039, r12
    43b8:	d0 92 3a 40 	sts	0x403A, r13
    43bc:	e0 92 3b 40 	sts	0x403B, r14
    43c0:	f0 92 3c 40 	sts	0x403C, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    43c4:	80 91 70 50 	lds	r24, 0x5070
    43c8:	90 91 71 50 	lds	r25, 0x5071
    43cc:	a0 91 72 50 	lds	r26, 0x5072
    43d0:	b0 91 73 50 	lds	r27, 0x5073
    43d4:	bc 01       	movw	r22, r24
    43d6:	cd 01       	movw	r24, r26
    43d8:	6f 5f       	subi	r22, 0xFF	; 255
    43da:	7f 4f       	sbci	r23, 0xFF	; 255
    43dc:	8f 4f       	sbci	r24, 0xFF	; 255
    43de:	9f 4f       	sbci	r25, 0xFF	; 255
    43e0:	4d e4       	ldi	r20, 0x4D	; 77
    43e2:	5e e3       	ldi	r21, 0x3E	; 62
    43e4:	20 e0       	ldi	r18, 0x00	; 0
    43e6:	32 e0       	ldi	r19, 0x02	; 2
    43e8:	0e 94 01 2b 	call	0x5602	; 0x5602 <SD_write_block>
 }
 return 0xffffffff;
    43ec:	0f ef       	ldi	r16, 0xFF	; 255
    43ee:	1f ef       	ldi	r17, 0xFF	; 255
    43f0:	98 01       	movw	r18, r16
    43f2:	0b c0       	rjmp	.+22     	; 0x440a <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    43f4:	0f ef       	ldi	r16, 0xFF	; 255
    43f6:	1f ef       	ldi	r17, 0xFF	; 255
    43f8:	98 01       	movw	r18, r16
    43fa:	07 c0       	rjmp	.+14     	; 0x440a <getSetFreeCluster+0x138>
    43fc:	0f ef       	ldi	r16, 0xFF	; 255
    43fe:	1f ef       	ldi	r17, 0xFF	; 255
    4400:	98 01       	movw	r18, r16
    4402:	03 c0       	rjmp	.+6      	; 0x440a <getSetFreeCluster+0x138>
    4404:	0f ef       	ldi	r16, 0xFF	; 255
    4406:	1f ef       	ldi	r17, 0xFF	; 255
    4408:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    440a:	60 2f       	mov	r22, r16
    440c:	71 2f       	mov	r23, r17
    440e:	82 2f       	mov	r24, r18
    4410:	93 2f       	mov	r25, r19
    4412:	cf 91       	pop	r28
    4414:	1f 91       	pop	r17
    4416:	0f 91       	pop	r16
    4418:	ff 90       	pop	r15
    441a:	ef 90       	pop	r14
    441c:	df 90       	pop	r13
    441e:	cf 90       	pop	r12
    4420:	08 95       	ret

00004422 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    4422:	ef 92       	push	r14
    4424:	ff 92       	push	r15
    4426:	0f 93       	push	r16
    4428:	1f 93       	push	r17
    442a:	cf 93       	push	r28
    442c:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    442e:	10 92 70 50 	sts	0x5070, r1
    4432:	10 92 71 50 	sts	0x5071, r1
    4436:	10 92 72 50 	sts	0x5072, r1
    443a:	10 92 73 50 	sts	0x5073, r1

SD_read_block(0,SDBuffer);
    443e:	60 e0       	ldi	r22, 0x00	; 0
    4440:	70 e0       	ldi	r23, 0x00	; 0
    4442:	cb 01       	movw	r24, r22
    4444:	4d e4       	ldi	r20, 0x4D	; 77
    4446:	5e e3       	ldi	r21, 0x3E	; 62
    4448:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    444c:	80 91 4d 3e 	lds	r24, 0x3E4D
    4450:	89 3e       	cpi	r24, 0xE9	; 233
    4452:	31 f1       	breq	.+76     	; 0x44a0 <getBootSectorData+0x7e>
    4454:	8b 3e       	cpi	r24, 0xEB	; 235
    4456:	21 f1       	breq	.+72     	; 0x44a0 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4458:	80 91 4b 40 	lds	r24, 0x404B
    445c:	90 91 4c 40 	lds	r25, 0x404C
    4460:	2a ea       	ldi	r18, 0xAA	; 170
    4462:	85 35       	cpi	r24, 0x55	; 85
    4464:	92 07       	cpc	r25, r18
    4466:	09 f0       	breq	.+2      	; 0x446a <getBootSectorData+0x48>
    4468:	b7 c0       	rjmp	.+366    	; 0x45d8 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    446a:	60 91 13 40 	lds	r22, 0x4013
    446e:	70 91 14 40 	lds	r23, 0x4014
    4472:	80 91 15 40 	lds	r24, 0x4015
    4476:	90 91 16 40 	lds	r25, 0x4016
    447a:	60 93 70 50 	sts	0x5070, r22
    447e:	70 93 71 50 	sts	0x5071, r23
    4482:	80 93 72 50 	sts	0x5072, r24
    4486:	90 93 73 50 	sts	0x5073, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    448a:	4d e4       	ldi	r20, 0x4D	; 77
    448c:	5e e3       	ldi	r21, 0x3E	; 62
    448e:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4492:	80 91 4d 3e 	lds	r24, 0x3E4D
    4496:	89 3e       	cpi	r24, 0xE9	; 233
    4498:	19 f0       	breq	.+6      	; 0x44a0 <getBootSectorData+0x7e>
    449a:	8b 3e       	cpi	r24, 0xEB	; 235
    449c:	09 f0       	breq	.+2      	; 0x44a0 <getBootSectorData+0x7e>
    449e:	9e c0       	rjmp	.+316    	; 0x45dc <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    44a0:	80 91 58 3e 	lds	r24, 0x3E58
    44a4:	90 91 59 3e 	lds	r25, 0x3E59
    44a8:	80 93 5a 40 	sts	0x405A, r24
    44ac:	90 93 5b 40 	sts	0x405B, r25
sectorPerCluster = bpb->sectorPerCluster;
    44b0:	80 91 5a 3e 	lds	r24, 0x3E5A
    44b4:	90 e0       	ldi	r25, 0x00	; 0
    44b6:	80 93 6e 50 	sts	0x506E, r24
    44ba:	90 93 6f 50 	sts	0x506F, r25
reservedSectorCount = bpb->reservedSectorCount;
    44be:	e0 90 5b 3e 	lds	r14, 0x3E5B
    44c2:	f0 90 5c 3e 	lds	r15, 0x3E5C
    44c6:	e0 92 74 50 	sts	0x5074, r14
    44ca:	f0 92 75 50 	sts	0x5075, r15
rootCluster = bpb->rootCluster;
    44ce:	80 91 79 3e 	lds	r24, 0x3E79
    44d2:	90 91 7a 3e 	lds	r25, 0x3E7A
    44d6:	a0 91 7b 3e 	lds	r26, 0x3E7B
    44da:	b0 91 7c 3e 	lds	r27, 0x3E7C
    44de:	80 93 62 40 	sts	0x4062, r24
    44e2:	90 93 63 40 	sts	0x4063, r25
    44e6:	a0 93 64 40 	sts	0x4064, r26
    44ea:	b0 93 65 40 	sts	0x4065, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    44ee:	c0 91 74 50 	lds	r28, 0x5074
    44f2:	d0 91 75 50 	lds	r29, 0x5075
    44f6:	60 91 5d 3e 	lds	r22, 0x3E5D
    44fa:	70 e0       	ldi	r23, 0x00	; 0
    44fc:	80 e0       	ldi	r24, 0x00	; 0
    44fe:	90 e0       	ldi	r25, 0x00	; 0
    4500:	20 91 71 3e 	lds	r18, 0x3E71
    4504:	30 91 72 3e 	lds	r19, 0x3E72
    4508:	40 91 73 3e 	lds	r20, 0x3E73
    450c:	50 91 74 3e 	lds	r21, 0x3E74
    4510:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    4514:	8b 01       	movw	r16, r22
    4516:	9c 01       	movw	r18, r24
    4518:	ae 01       	movw	r20, r28
    451a:	60 e0       	ldi	r22, 0x00	; 0
    451c:	70 e0       	ldi	r23, 0x00	; 0
    451e:	80 91 69 3e 	lds	r24, 0x3E69
    4522:	90 91 6a 3e 	lds	r25, 0x3E6A
    4526:	a0 91 6b 3e 	lds	r26, 0x3E6B
    452a:	b0 91 6c 3e 	lds	r27, 0x3E6C
    452e:	84 0f       	add	r24, r20
    4530:	95 1f       	adc	r25, r21
    4532:	a6 1f       	adc	r26, r22
    4534:	b7 1f       	adc	r27, r23
    4536:	80 0f       	add	r24, r16
    4538:	91 1f       	adc	r25, r17
    453a:	a2 1f       	adc	r26, r18
    453c:	b3 1f       	adc	r27, r19
    453e:	80 93 52 40 	sts	0x4052, r24
    4542:	90 93 53 40 	sts	0x4053, r25
    4546:	a0 93 54 40 	sts	0x4054, r26
    454a:	b0 93 55 40 	sts	0x4055, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    454e:	e0 91 6e 50 	lds	r30, 0x506E
    4552:	f0 91 6f 50 	lds	r31, 0x506F
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4556:	c7 01       	movw	r24, r14
    4558:	a0 e0       	ldi	r26, 0x00	; 0
    455a:	b0 e0       	ldi	r27, 0x00	; 0
    455c:	40 91 6d 3e 	lds	r20, 0x3E6D
    4560:	50 91 6e 3e 	lds	r21, 0x3E6E
    4564:	60 91 6f 3e 	lds	r22, 0x3E6F
    4568:	70 91 70 3e 	lds	r23, 0x3E70
    456c:	48 1b       	sub	r20, r24
    456e:	59 0b       	sbc	r21, r25
    4570:	6a 0b       	sbc	r22, r26
    4572:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4574:	cb 01       	movw	r24, r22
    4576:	ba 01       	movw	r22, r20
    4578:	60 1b       	sub	r22, r16
    457a:	71 0b       	sbc	r23, r17
    457c:	82 0b       	sbc	r24, r18
    457e:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4580:	9f 01       	movw	r18, r30
    4582:	40 e0       	ldi	r20, 0x00	; 0
    4584:	50 e0       	ldi	r21, 0x00	; 0
    4586:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    458a:	20 93 5d 40 	sts	0x405D, r18
    458e:	30 93 5e 40 	sts	0x405E, r19
    4592:	40 93 5f 40 	sts	0x405F, r20
    4596:	50 93 60 40 	sts	0x4060, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    459a:	81 e0       	ldi	r24, 0x01	; 1
    459c:	60 e0       	ldi	r22, 0x00	; 0
    459e:	20 e0       	ldi	r18, 0x00	; 0
    45a0:	30 e0       	ldi	r19, 0x00	; 0
    45a2:	a9 01       	movw	r20, r18
    45a4:	0e 94 69 21 	call	0x42d2	; 0x42d2 <getSetFreeCluster>
    45a8:	ab 01       	movw	r20, r22
    45aa:	bc 01       	movw	r22, r24
    45ac:	80 91 5d 40 	lds	r24, 0x405D
    45b0:	90 91 5e 40 	lds	r25, 0x405E
    45b4:	a0 91 5f 40 	lds	r26, 0x405F
    45b8:	b0 91 60 40 	lds	r27, 0x4060
    45bc:	84 17       	cp	r24, r20
    45be:	95 07       	cpc	r25, r21
    45c0:	a6 07       	cpc	r26, r22
    45c2:	b7 07       	cpc	r27, r23
    45c4:	20 f4       	brcc	.+8      	; 0x45ce <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    45c6:	10 92 a6 50 	sts	0x50A6, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    45ca:	80 e0       	ldi	r24, 0x00	; 0
    45cc:	08 c0       	rjmp	.+16     	; 0x45de <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    45ce:	81 e0       	ldi	r24, 0x01	; 1
    45d0:	80 93 a6 50 	sts	0x50A6, r24
return 0;
    45d4:	80 e0       	ldi	r24, 0x00	; 0
    45d6:	03 c0       	rjmp	.+6      	; 0x45de <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    45d8:	81 e0       	ldi	r24, 0x01	; 1
    45da:	01 c0       	rjmp	.+2      	; 0x45de <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    45dc:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    45de:	df 91       	pop	r29
    45e0:	cf 91       	pop	r28
    45e2:	1f 91       	pop	r17
    45e4:	0f 91       	pop	r16
    45e6:	ff 90       	pop	r15
    45e8:	ef 90       	pop	r14
    45ea:	08 95       	ret

000045ec <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    45ec:	0f 93       	push	r16
    45ee:	1f 93       	push	r17
    45f0:	cf 93       	push	r28
    45f2:	df 93       	push	r29
    45f4:	cd b7       	in	r28, 0x3d	; 61
    45f6:	de b7       	in	r29, 0x3e	; 62
    45f8:	2b 97       	sbiw	r28, 0x0b	; 11
    45fa:	cd bf       	out	0x3d, r28	; 61
    45fc:	de bf       	out	0x3e, r29	; 62
    45fe:	78 2f       	mov	r23, r24
    4600:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4602:	e8 2f       	mov	r30, r24
    4604:	f9 2f       	mov	r31, r25
    4606:	df 01       	movw	r26, r30
    4608:	0d 90       	ld	r0, X+
    460a:	00 20       	and	r0, r0
    460c:	e9 f7       	brne	.-6      	; 0x4608 <convertFileName+0x1c>
    460e:	11 97       	sbiw	r26, 0x01	; 1
    4610:	ae 1b       	sub	r26, r30
    4612:	bf 0b       	sbc	r27, r31
    4614:	a0 31       	cpi	r26, 0x10	; 16
    4616:	b1 05       	cpc	r27, r1
    4618:	08 f0       	brcs	.+2      	; 0x461c <convertFileName+0x30>
    461a:	9c c0       	rjmp	.+312    	; 0x4754 <convertFileName+0x168>
    461c:	28 2f       	mov	r18, r24
    461e:	39 2f       	mov	r19, r25
    4620:	06 e9       	ldi	r16, 0x96	; 150
    4622:	10 e5       	ldi	r17, 0x50	; 80
    4624:	a8 01       	movw	r20, r16
    4626:	80 e0       	ldi	r24, 0x00	; 0
    4628:	90 e0       	ldi	r25, 0x00	; 0
    462a:	07 c0       	rjmp	.+14     	; 0x463a <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    462c:	d9 01       	movw	r26, r18
    462e:	ed 91       	ld	r30, X+
    4630:	9d 01       	movw	r18, r26
    4632:	da 01       	movw	r26, r20
    4634:	ed 93       	st	X+, r30
    4636:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    4638:	01 96       	adiw	r24, 0x01	; 1
    463a:	a7 2f       	mov	r26, r23
    463c:	b6 2f       	mov	r27, r22
    463e:	fd 01       	movw	r30, r26
    4640:	01 90       	ld	r0, Z+
    4642:	00 20       	and	r0, r0
    4644:	e9 f7       	brne	.-6      	; 0x4640 <convertFileName+0x54>
    4646:	31 97       	sbiw	r30, 0x01	; 1
    4648:	ea 1b       	sub	r30, r26
    464a:	fb 0b       	sbc	r31, r27
    464c:	8e 17       	cp	r24, r30
    464e:	9f 07       	cpc	r25, r31
    4650:	68 f3       	brcs	.-38     	; 0x462c <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4652:	8f 30       	cpi	r24, 0x0F	; 15
    4654:	91 05       	cpc	r25, r1
    4656:	54 f4       	brge	.+20     	; 0x466c <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4658:	fc 01       	movw	r30, r24
    465a:	ea 56       	subi	r30, 0x6A	; 106
    465c:	ff 4a       	sbci	r31, 0xAF	; 175
    465e:	85 ea       	ldi	r24, 0xA5	; 165
    4660:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    4662:	20 e2       	ldi	r18, 0x20	; 32
    4664:	21 93       	st	Z+, r18
    4666:	e8 17       	cp	r30, r24
    4668:	f9 07       	cpc	r31, r25
    466a:	e1 f7       	brne	.-8      	; 0x4664 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    466c:	80 91 96 50 	lds	r24, 0x5096
    4670:	8e 32       	cpi	r24, 0x2E	; 46
    4672:	91 f0       	breq	.+36     	; 0x4698 <convertFileName+0xac>
    4674:	e7 e9       	ldi	r30, 0x97	; 151
    4676:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4678:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    467a:	81 91       	ld	r24, Z+
    467c:	8e 32       	cpi	r24, 0x2E	; 46
    467e:	21 f0       	breq	.+8      	; 0x4688 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4680:	2f 5f       	subi	r18, 0xFF	; 255
    4682:	2c 30       	cpi	r18, 0x0C	; 12
    4684:	d1 f7       	brne	.-12     	; 0x467a <convertFileName+0x8e>
    4686:	05 c0       	rjmp	.+10     	; 0x4692 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    4688:	82 2f       	mov	r24, r18
    468a:	89 50       	subi	r24, 0x09	; 9
    468c:	83 30       	cpi	r24, 0x03	; 3
    468e:	08 f4       	brcc	.+2      	; 0x4692 <convertFileName+0xa6>
    4690:	63 c0       	rjmp	.+198    	; 0x4758 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4692:	22 23       	and	r18, r18
    4694:	29 f4       	brne	.+10     	; 0x46a0 <convertFileName+0xb4>
    4696:	01 c0       	rjmp	.+2      	; 0x469a <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4698:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    469a:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    469c:	90 e2       	ldi	r25, 0x20	; 32
    469e:	10 c0       	rjmp	.+32     	; 0x46c0 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    46a0:	de 01       	movw	r26, r28
    46a2:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    46a4:	82 2f       	mov	r24, r18
    46a6:	81 50       	subi	r24, 0x01	; 1
    46a8:	90 e0       	ldi	r25, 0x00	; 0
    46aa:	89 56       	subi	r24, 0x69	; 105
    46ac:	9f 4a       	sbci	r25, 0xAF	; 175
    46ae:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    46b0:	31 91       	ld	r19, Z+
    46b2:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    46b4:	e8 17       	cp	r30, r24
    46b6:	f9 07       	cpc	r31, r25
    46b8:	d9 f7       	brne	.-10     	; 0x46b0 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    46ba:	28 30       	cpi	r18, 0x08	; 8
    46bc:	70 f3       	brcs	.-36     	; 0x469a <convertFileName+0xae>
    46be:	0a c0       	rjmp	.+20     	; 0x46d4 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    46c0:	e1 e0       	ldi	r30, 0x01	; 1
    46c2:	f0 e0       	ldi	r31, 0x00	; 0
    46c4:	ec 0f       	add	r30, r28
    46c6:	fd 1f       	adc	r31, r29
    46c8:	e8 0f       	add	r30, r24
    46ca:	f1 1d       	adc	r31, r1
    46cc:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    46ce:	8f 5f       	subi	r24, 0xFF	; 255
    46d0:	88 30       	cpi	r24, 0x08	; 8
    46d2:	b0 f3       	brcs	.-20     	; 0x46c0 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    46d4:	2c 30       	cpi	r18, 0x0C	; 12
    46d6:	09 f0       	breq	.+2      	; 0x46da <convertFileName+0xee>
    46d8:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    46da:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    46dc:	86 e9       	ldi	r24, 0x96	; 150
    46de:	90 e5       	ldi	r25, 0x50	; 80
    46e0:	fc 01       	movw	r30, r24
    46e2:	e2 0f       	add	r30, r18
    46e4:	f1 1d       	adc	r31, r1
    46e6:	40 81       	ld	r20, Z
    46e8:	44 23       	and	r20, r20
    46ea:	19 f4       	brne	.+6      	; 0x46f2 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    46ec:	3b 30       	cpi	r19, 0x0B	; 11
    46ee:	50 f0       	brcs	.+20     	; 0x4704 <convertFileName+0x118>
    46f0:	15 c0       	rjmp	.+42     	; 0x471c <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    46f2:	e1 e0       	ldi	r30, 0x01	; 1
    46f4:	f0 e0       	ldi	r31, 0x00	; 0
    46f6:	ec 0f       	add	r30, r28
    46f8:	fd 1f       	adc	r31, r29
    46fa:	e3 0f       	add	r30, r19
    46fc:	f1 1d       	adc	r31, r1
    46fe:	40 83       	st	Z, r20
    4700:	2f 5f       	subi	r18, 0xFF	; 255
    4702:	0c c0       	rjmp	.+24     	; 0x471c <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4704:	80 e2       	ldi	r24, 0x20	; 32
    4706:	e1 e0       	ldi	r30, 0x01	; 1
    4708:	f0 e0       	ldi	r31, 0x00	; 0
    470a:	ec 0f       	add	r30, r28
    470c:	fd 1f       	adc	r31, r29
    470e:	e3 0f       	add	r30, r19
    4710:	f1 1d       	adc	r31, r1
    4712:	80 83       	st	Z, r24
    4714:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4716:	3b 30       	cpi	r19, 0x0B	; 11
    4718:	b1 f7       	brne	.-20     	; 0x4706 <convertFileName+0x11a>
    471a:	03 c0       	rjmp	.+6      	; 0x4722 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    471c:	3f 5f       	subi	r19, 0xFF	; 255
    471e:	3b 30       	cpi	r19, 0x0B	; 11
    4720:	f8 f2       	brcs	.-66     	; 0x46e0 <convertFileName+0xf4>
    4722:	de 01       	movw	r26, r28
    4724:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4726:	ce 01       	movw	r24, r28
    4728:	0c 96       	adiw	r24, 0x0c	; 12
    472a:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    472c:	20 81       	ld	r18, Z
    472e:	32 2f       	mov	r19, r18
    4730:	31 56       	subi	r19, 0x61	; 97
    4732:	3a 31       	cpi	r19, 0x1A	; 26
    4734:	10 f4       	brcc	.+4      	; 0x473a <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    4736:	20 52       	subi	r18, 0x20	; 32
    4738:	20 83       	st	Z, r18
    473a:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    473c:	e8 17       	cp	r30, r24
    473e:	f9 07       	cpc	r31, r25
    4740:	a9 f7       	brne	.-22     	; 0x472c <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    4742:	2d 91       	ld	r18, X+
    4744:	f8 01       	movw	r30, r16
    4746:	21 93       	st	Z+, r18
    4748:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    474a:	a8 17       	cp	r26, r24
    474c:	b9 07       	cpc	r27, r25
    474e:	c9 f7       	brne	.-14     	; 0x4742 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    4750:	80 e0       	ldi	r24, 0x00	; 0
    4752:	03 c0       	rjmp	.+6      	; 0x475a <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4754:	81 e0       	ldi	r24, 0x01	; 1
    4756:	01 c0       	rjmp	.+2      	; 0x475a <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4758:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    475a:	2b 96       	adiw	r28, 0x0b	; 11
    475c:	cd bf       	out	0x3d, r28	; 61
    475e:	de bf       	out	0x3e, r29	; 62
    4760:	df 91       	pop	r29
    4762:	cf 91       	pop	r28
    4764:	1f 91       	pop	r17
    4766:	0f 91       	pop	r16
    4768:	08 95       	ret

0000476a <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    476a:	4f 92       	push	r4
    476c:	5f 92       	push	r5
    476e:	6f 92       	push	r6
    4770:	7f 92       	push	r7
    4772:	8f 92       	push	r8
    4774:	9f 92       	push	r9
    4776:	af 92       	push	r10
    4778:	bf 92       	push	r11
    477a:	cf 92       	push	r12
    477c:	df 92       	push	r13
    477e:	ef 92       	push	r14
    4780:	ff 92       	push	r15
    4782:	cf 93       	push	r28
    4784:	df 93       	push	r29
    4786:	2b 01       	movw	r4, r22
    4788:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    478a:	20 e8       	ldi	r18, 0x80	; 128
    478c:	3f ef       	ldi	r19, 0xFF	; 255
    478e:	4f ef       	ldi	r20, 0xFF	; 255
    4790:	5f ef       	ldi	r21, 0xFF	; 255
    4792:	42 22       	and	r4, r18
    4794:	53 22       	and	r5, r19
    4796:	64 22       	and	r6, r20
    4798:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    479a:	80 91 5d 40 	lds	r24, 0x405D
    479e:	90 91 5e 40 	lds	r25, 0x405E
    47a2:	a0 91 5f 40 	lds	r26, 0x405F
    47a6:	b0 91 60 40 	lds	r27, 0x4060
    47aa:	48 16       	cp	r4, r24
    47ac:	59 06       	cpc	r5, r25
    47ae:	6a 06       	cpc	r6, r26
    47b0:	7b 06       	cpc	r7, r27
    47b2:	08 f0       	brcs	.+2      	; 0x47b6 <searchNextFreeCluster+0x4c>
    47b4:	77 c0       	rjmp	.+238    	; 0x48a4 <searchNextFreeCluster+0x13a>
    47b6:	53 01       	movw	r10, r6
    47b8:	42 01       	movw	r8, r4
    47ba:	88 0c       	add	r8, r8
    47bc:	99 1c       	adc	r9, r9
    47be:	aa 1c       	adc	r10, r10
    47c0:	bb 1c       	adc	r11, r11
    47c2:	88 0c       	add	r8, r8
    47c4:	99 1c       	adc	r9, r9
    47c6:	aa 1c       	adc	r10, r10
    47c8:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    47ca:	cd e4       	ldi	r28, 0x4D	; 77
    47cc:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    47ce:	c0 90 74 50 	lds	r12, 0x5074
    47d2:	d0 90 75 50 	lds	r13, 0x5075
    47d6:	20 91 5a 40 	lds	r18, 0x405A
    47da:	30 91 5b 40 	lds	r19, 0x405B
    47de:	ee 24       	eor	r14, r14
    47e0:	ff 24       	eor	r15, r15
    47e2:	80 91 70 50 	lds	r24, 0x5070
    47e6:	90 91 71 50 	lds	r25, 0x5071
    47ea:	a0 91 72 50 	lds	r26, 0x5072
    47ee:	b0 91 73 50 	lds	r27, 0x5073
    47f2:	c8 0e       	add	r12, r24
    47f4:	d9 1e       	adc	r13, r25
    47f6:	ea 1e       	adc	r14, r26
    47f8:	fb 1e       	adc	r15, r27
    47fa:	40 e0       	ldi	r20, 0x00	; 0
    47fc:	50 e0       	ldi	r21, 0x00	; 0
    47fe:	c5 01       	movw	r24, r10
    4800:	b4 01       	movw	r22, r8
    4802:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    4806:	c7 01       	movw	r24, r14
    4808:	b6 01       	movw	r22, r12
    480a:	62 0f       	add	r22, r18
    480c:	73 1f       	adc	r23, r19
    480e:	84 1f       	adc	r24, r20
    4810:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    4812:	ae 01       	movw	r20, r28
    4814:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    4818:	88 81       	ld	r24, Y
    481a:	99 81       	ldd	r25, Y+1	; 0x01
    481c:	aa 81       	ldd	r26, Y+2	; 0x02
    481e:	bb 81       	ldd	r27, Y+3	; 0x03
    4820:	bf 70       	andi	r27, 0x0F	; 15
    4822:	00 97       	sbiw	r24, 0x00	; 0
    4824:	a1 05       	cpc	r26, r1
    4826:	b1 05       	cpc	r27, r1
    4828:	99 f0       	breq	.+38     	; 0x4850 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    482a:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    482c:	e2 2f       	mov	r30, r18
    482e:	f0 e0       	ldi	r31, 0x00	; 0
    4830:	ee 0f       	add	r30, r30
    4832:	ff 1f       	adc	r31, r31
    4834:	ee 0f       	add	r30, r30
    4836:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    4838:	e3 5b       	subi	r30, 0xB3	; 179
    483a:	f1 4c       	sbci	r31, 0xC1	; 193
    483c:	80 81       	ld	r24, Z
    483e:	91 81       	ldd	r25, Z+1	; 0x01
    4840:	a2 81       	ldd	r26, Z+2	; 0x02
    4842:	b3 81       	ldd	r27, Z+3	; 0x03
    4844:	bf 70       	andi	r27, 0x0F	; 15
    4846:	00 97       	sbiw	r24, 0x00	; 0
    4848:	a1 05       	cpc	r26, r1
    484a:	b1 05       	cpc	r27, r1
    484c:	39 f4       	brne	.+14     	; 0x485c <searchNextFreeCluster+0xf2>
    484e:	01 c0       	rjmp	.+2      	; 0x4852 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4850:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4852:	42 0e       	add	r4, r18
    4854:	51 1c       	adc	r5, r1
    4856:	61 1c       	adc	r6, r1
    4858:	71 1c       	adc	r7, r1
    485a:	27 c0       	rjmp	.+78     	; 0x48aa <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    485c:	2f 5f       	subi	r18, 0xFF	; 255
    485e:	32 f7       	brpl	.-52     	; 0x482c <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4860:	80 e8       	ldi	r24, 0x80	; 128
    4862:	90 e0       	ldi	r25, 0x00	; 0
    4864:	a0 e0       	ldi	r26, 0x00	; 0
    4866:	b0 e0       	ldi	r27, 0x00	; 0
    4868:	48 0e       	add	r4, r24
    486a:	59 1e       	adc	r5, r25
    486c:	6a 1e       	adc	r6, r26
    486e:	7b 1e       	adc	r7, r27
    4870:	80 91 5d 40 	lds	r24, 0x405D
    4874:	90 91 5e 40 	lds	r25, 0x405E
    4878:	a0 91 5f 40 	lds	r26, 0x405F
    487c:	b0 91 60 40 	lds	r27, 0x4060
    4880:	20 e0       	ldi	r18, 0x00	; 0
    4882:	32 e0       	ldi	r19, 0x02	; 2
    4884:	40 e0       	ldi	r20, 0x00	; 0
    4886:	50 e0       	ldi	r21, 0x00	; 0
    4888:	82 0e       	add	r8, r18
    488a:	93 1e       	adc	r9, r19
    488c:	a4 1e       	adc	r10, r20
    488e:	b5 1e       	adc	r11, r21
    4890:	48 16       	cp	r4, r24
    4892:	59 06       	cpc	r5, r25
    4894:	6a 06       	cpc	r6, r26
    4896:	7b 06       	cpc	r7, r27
    4898:	08 f4       	brcc	.+2      	; 0x489c <searchNextFreeCluster+0x132>
    489a:	99 cf       	rjmp	.-206    	; 0x47ce <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    489c:	44 24       	eor	r4, r4
    489e:	55 24       	eor	r5, r5
    48a0:	32 01       	movw	r6, r4
    48a2:	03 c0       	rjmp	.+6      	; 0x48aa <searchNextFreeCluster+0x140>
    48a4:	44 24       	eor	r4, r4
    48a6:	55 24       	eor	r5, r5
    48a8:	32 01       	movw	r6, r4
}
    48aa:	64 2d       	mov	r22, r4
    48ac:	75 2d       	mov	r23, r5
    48ae:	86 2d       	mov	r24, r6
    48b0:	97 2d       	mov	r25, r7
    48b2:	df 91       	pop	r29
    48b4:	cf 91       	pop	r28
    48b6:	ff 90       	pop	r15
    48b8:	ef 90       	pop	r14
    48ba:	df 90       	pop	r13
    48bc:	cf 90       	pop	r12
    48be:	bf 90       	pop	r11
    48c0:	af 90       	pop	r10
    48c2:	9f 90       	pop	r9
    48c4:	8f 90       	pop	r8
    48c6:	7f 90       	pop	r7
    48c8:	6f 90       	pop	r6
    48ca:	5f 90       	pop	r5
    48cc:	4f 90       	pop	r4
    48ce:	08 95       	ret

000048d0 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    48d0:	cf 92       	push	r12
    48d2:	df 92       	push	r13
    48d4:	ef 92       	push	r14
    48d6:	ff 92       	push	r15
    48d8:	cf 93       	push	r28
    48da:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    48dc:	db 01       	movw	r26, r22
    48de:	ca 01       	movw	r24, r20
    48e0:	91 70       	andi	r25, 0x01	; 1
    48e2:	a0 70       	andi	r26, 0x00	; 0
    48e4:	b0 70       	andi	r27, 0x00	; 0
    48e6:	00 97       	sbiw	r24, 0x00	; 0
    48e8:	a1 05       	cpc	r26, r1
    48ea:	b1 05       	cpc	r27, r1
    48ec:	51 f4       	brne	.+20     	; 0x4902 <freeMemoryUpdate+0x32>
    48ee:	03 2e       	mov	r0, r19
    48f0:	39 e0       	ldi	r19, 0x09	; 9
    48f2:	76 95       	lsr	r23
    48f4:	67 95       	ror	r22
    48f6:	57 95       	ror	r21
    48f8:	47 95       	ror	r20
    48fa:	3a 95       	dec	r19
    48fc:	d1 f7       	brne	.-12     	; 0x48f2 <freeMemoryUpdate+0x22>
    48fe:	30 2d       	mov	r19, r0
    4900:	0d c0       	rjmp	.+26     	; 0x491c <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4902:	03 2e       	mov	r0, r19
    4904:	39 e0       	ldi	r19, 0x09	; 9
    4906:	76 95       	lsr	r23
    4908:	67 95       	ror	r22
    490a:	57 95       	ror	r21
    490c:	47 95       	ror	r20
    490e:	3a 95       	dec	r19
    4910:	d1 f7       	brne	.-12     	; 0x4906 <freeMemoryUpdate+0x36>
    4912:	30 2d       	mov	r19, r0
    4914:	4f 5f       	subi	r20, 0xFF	; 255
    4916:	5f 4f       	sbci	r21, 0xFF	; 255
    4918:	6f 4f       	sbci	r22, 0xFF	; 255
    491a:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    491c:	db 01       	movw	r26, r22
    491e:	ca 01       	movw	r24, r20
    4920:	87 70       	andi	r24, 0x07	; 7
    4922:	90 70       	andi	r25, 0x00	; 0
    4924:	a0 70       	andi	r26, 0x00	; 0
    4926:	b0 70       	andi	r27, 0x00	; 0
    4928:	00 97       	sbiw	r24, 0x00	; 0
    492a:	a1 05       	cpc	r26, r1
    492c:	b1 05       	cpc	r27, r1
    492e:	59 f4       	brne	.+22     	; 0x4946 <freeMemoryUpdate+0x76>
    4930:	6a 01       	movw	r12, r20
    4932:	7b 01       	movw	r14, r22
    4934:	68 94       	set
    4936:	12 f8       	bld	r1, 2
    4938:	f6 94       	lsr	r15
    493a:	e7 94       	ror	r14
    493c:	d7 94       	ror	r13
    493e:	c7 94       	ror	r12
    4940:	16 94       	lsr	r1
    4942:	d1 f7       	brne	.-12     	; 0x4938 <freeMemoryUpdate+0x68>
    4944:	0f c0       	rjmp	.+30     	; 0x4964 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    4946:	6a 01       	movw	r12, r20
    4948:	7b 01       	movw	r14, r22
    494a:	68 94       	set
    494c:	12 f8       	bld	r1, 2
    494e:	f6 94       	lsr	r15
    4950:	e7 94       	ror	r14
    4952:	d7 94       	ror	r13
    4954:	c7 94       	ror	r12
    4956:	16 94       	lsr	r1
    4958:	d1 f7       	brne	.-12     	; 0x494e <freeMemoryUpdate+0x7e>
    495a:	08 94       	sec
    495c:	c1 1c       	adc	r12, r1
    495e:	d1 1c       	adc	r13, r1
    4960:	e1 1c       	adc	r14, r1
    4962:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4964:	80 91 a6 50 	lds	r24, 0x50A6
    4968:	88 23       	and	r24, r24
    496a:	d1 f0       	breq	.+52     	; 0x49a0 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    496c:	81 e0       	ldi	r24, 0x01	; 1
    496e:	60 e0       	ldi	r22, 0x00	; 0
    4970:	20 e0       	ldi	r18, 0x00	; 0
    4972:	30 e0       	ldi	r19, 0x00	; 0
    4974:	a9 01       	movw	r20, r18
    4976:	0e 94 69 21 	call	0x42d2	; 0x42d2 <getSetFreeCluster>
	if(flag == ADD)
    497a:	cc 23       	and	r28, r28
    497c:	39 f4       	brne	.+14     	; 0x498c <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    497e:	9b 01       	movw	r18, r22
    4980:	ac 01       	movw	r20, r24
    4982:	2c 0d       	add	r18, r12
    4984:	3d 1d       	adc	r19, r13
    4986:	4e 1d       	adc	r20, r14
    4988:	5f 1d       	adc	r21, r15
    498a:	06 c0       	rjmp	.+12     	; 0x4998 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    498c:	9b 01       	movw	r18, r22
    498e:	ac 01       	movw	r20, r24
    4990:	2c 19       	sub	r18, r12
    4992:	3d 09       	sbc	r19, r13
    4994:	4e 09       	sbc	r20, r14
    4996:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4998:	81 e0       	ldi	r24, 0x01	; 1
    499a:	61 e0       	ldi	r22, 0x01	; 1
    499c:	0e 94 69 21 	call	0x42d2	; 0x42d2 <getSetFreeCluster>
  }
}
    49a0:	cf 91       	pop	r28
    49a2:	ff 90       	pop	r15
    49a4:	ef 90       	pop	r14
    49a6:	df 90       	pop	r13
    49a8:	cf 90       	pop	r12
    49aa:	08 95       	ret

000049ac <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    49ac:	2f 92       	push	r2
    49ae:	3f 92       	push	r3
    49b0:	4f 92       	push	r4
    49b2:	5f 92       	push	r5
    49b4:	6f 92       	push	r6
    49b6:	7f 92       	push	r7
    49b8:	8f 92       	push	r8
    49ba:	9f 92       	push	r9
    49bc:	af 92       	push	r10
    49be:	bf 92       	push	r11
    49c0:	cf 92       	push	r12
    49c2:	df 92       	push	r13
    49c4:	ef 92       	push	r14
    49c6:	ff 92       	push	r15
    49c8:	0f 93       	push	r16
    49ca:	1f 93       	push	r17
    49cc:	cf 93       	push	r28
    49ce:	df 93       	push	r29
    49d0:	cd b7       	in	r28, 0x3d	; 61
    49d2:	de b7       	in	r29, 0x3e	; 62
    49d4:	2c 97       	sbiw	r28, 0x0c	; 12
    49d6:	cd bf       	out	0x3d, r28	; 61
    49d8:	de bf       	out	0x3e, r29	; 62
    49da:	88 2e       	mov	r8, r24
    49dc:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    49de:	80 91 62 40 	lds	r24, 0x4062
    49e2:	90 91 63 40 	lds	r25, 0x4063
    49e6:	a0 91 64 40 	lds	r26, 0x4064
    49ea:	b0 91 65 40 	lds	r27, 0x4065
    49ee:	89 87       	std	Y+9, r24	; 0x09
    49f0:	9a 87       	std	Y+10, r25	; 0x0a
    49f2:	ab 87       	std	Y+11, r26	; 0x0b
    49f4:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    49f6:	0f 2e       	mov	r0, r31
    49f8:	fd e4       	ldi	r31, 0x4D	; 77
    49fa:	2f 2e       	mov	r2, r31
    49fc:	fe e3       	ldi	r31, 0x3E	; 62
    49fe:	3f 2e       	mov	r3, r31
    4a00:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4a02:	c8 2c       	mov	r12, r8
    4a04:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4a06:	d2 2c       	mov	r13, r2
    4a08:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4a0a:	5b 01       	movw	r10, r22
    4a0c:	08 94       	sec
    4a0e:	a1 1c       	adc	r10, r1
    4a10:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4a12:	69 85       	ldd	r22, Y+9	; 0x09
    4a14:	7a 85       	ldd	r23, Y+10	; 0x0a
    4a16:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a18:	9c 85       	ldd	r25, Y+12	; 0x0c
    4a1a:	0e 94 b0 20 	call	0x4160	; 0x4160 <getFirstSector>
    4a1e:	6d 83       	std	Y+5, r22	; 0x05
    4a20:	7e 83       	std	Y+6, r23	; 0x06
    4a22:	8f 83       	std	Y+7, r24	; 0x07
    4a24:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4a26:	80 91 6e 50 	lds	r24, 0x506E
    4a2a:	90 91 6f 50 	lds	r25, 0x506F
    4a2e:	00 97       	sbiw	r24, 0x00	; 0
    4a30:	09 f4       	brne	.+2      	; 0x4a34 <findFiles+0x88>
    4a32:	13 c1       	rjmp	.+550    	; 0x4c5a <findFiles+0x2ae>
    4a34:	44 24       	eor	r4, r4
    4a36:	55 24       	eor	r5, r5
    4a38:	32 01       	movw	r6, r4
    4a3a:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4a3c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a3e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a40:	af 81       	ldd	r26, Y+7	; 0x07
    4a42:	b8 85       	ldd	r27, Y+8	; 0x08
    4a44:	84 0d       	add	r24, r4
    4a46:	95 1d       	adc	r25, r5
    4a48:	a6 1d       	adc	r26, r6
    4a4a:	b7 1d       	adc	r27, r7
    4a4c:	89 83       	std	Y+1, r24	; 0x01
    4a4e:	9a 83       	std	Y+2, r25	; 0x02
    4a50:	ab 83       	std	Y+3, r26	; 0x03
    4a52:	bc 83       	std	Y+4, r27	; 0x04
    4a54:	bc 01       	movw	r22, r24
    4a56:	cd 01       	movw	r24, r26
    4a58:	4d 2d       	mov	r20, r13
    4a5a:	59 2d       	mov	r21, r9
    4a5c:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4a60:	80 91 5a 40 	lds	r24, 0x405A
    4a64:	90 91 5b 40 	lds	r25, 0x405B
    4a68:	00 97       	sbiw	r24, 0x00	; 0
    4a6a:	09 f4       	brne	.+2      	; 0x4a6e <findFiles+0xc2>
    4a6c:	e4 c0       	rjmp	.+456    	; 0x4c36 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4a6e:	d1 01       	movw	r26, r2
    4a70:	8c 91       	ld	r24, X
    4a72:	88 23       	and	r24, r24
    4a74:	09 f4       	brne	.+2      	; 0x4a78 <findFiles+0xcc>
    4a76:	10 c1       	rjmp	.+544    	; 0x4c98 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4a78:	4d 2d       	mov	r20, r13
    4a7a:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4a7c:	20 e0       	ldi	r18, 0x00	; 0
    4a7e:	30 e0       	ldi	r19, 0x00	; 0
    4a80:	08 c0       	rjmp	.+16     	; 0x4a92 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4a82:	a9 01       	movw	r20, r18
    4a84:	43 5b       	subi	r20, 0xB3	; 179
    4a86:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4a88:	fa 01       	movw	r30, r20
    4a8a:	80 81       	ld	r24, Z
    4a8c:	88 23       	and	r24, r24
    4a8e:	09 f4       	brne	.+2      	; 0x4a92 <findFiles+0xe6>
    4a90:	06 c1       	rjmp	.+524    	; 0x4c9e <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4a92:	85 3e       	cpi	r24, 0xE5	; 229
    4a94:	09 f4       	brne	.+2      	; 0x4a98 <findFiles+0xec>
    4a96:	c5 c0       	rjmp	.+394    	; 0x4c22 <findFiles+0x276>
    4a98:	da 01       	movw	r26, r20
    4a9a:	1b 96       	adiw	r26, 0x0b	; 11
    4a9c:	8c 91       	ld	r24, X
    4a9e:	1b 97       	sbiw	r26, 0x0b	; 11
    4aa0:	8f 30       	cpi	r24, 0x0F	; 15
    4aa2:	09 f4       	brne	.+2      	; 0x4aa6 <findFiles+0xfa>
    4aa4:	be c0       	rjmp	.+380    	; 0x4c22 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4aa6:	12 30       	cpi	r17, 0x02	; 2
    4aa8:	08 f0       	brcs	.+2      	; 0x4aac <findFiles+0x100>
    4aaa:	fc c0       	rjmp	.+504    	; 0x4ca4 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4aac:	9c 91       	ld	r25, X
    4aae:	f7 01       	movw	r30, r14
    4ab0:	80 81       	ld	r24, Z
    4ab2:	98 17       	cp	r25, r24
    4ab4:	09 f0       	breq	.+2      	; 0x4ab8 <findFiles+0x10c>
    4ab6:	b5 c0       	rjmp	.+362    	; 0x4c22 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4ab8:	fa 01       	movw	r30, r20
    4aba:	31 96       	adiw	r30, 0x01	; 1
    4abc:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4abe:	81 e0       	ldi	r24, 0x01	; 1
    4ac0:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4ac2:	41 91       	ld	r20, Z+
    4ac4:	9d 91       	ld	r25, X+
    4ac6:	49 17       	cp	r20, r25
    4ac8:	31 f4       	brne	.+12     	; 0x4ad6 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4aca:	8f 5f       	subi	r24, 0xFF	; 255
    4acc:	8b 30       	cpi	r24, 0x0B	; 11
    4ace:	c9 f7       	brne	.-14     	; 0x4ac2 <findFiles+0x116>
    4ad0:	8b 01       	movw	r16, r22
    4ad2:	6b 01       	movw	r12, r22
    4ad4:	05 c0       	rjmp	.+10     	; 0x4ae0 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4ad6:	8b 30       	cpi	r24, 0x0B	; 11
    4ad8:	09 f0       	breq	.+2      	; 0x4adc <findFiles+0x130>
    4ada:	a3 c0       	rjmp	.+326    	; 0x4c22 <findFiles+0x276>
    4adc:	8b 01       	movw	r16, r22
    4ade:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4ae0:	f1 e0       	ldi	r31, 0x01	; 1
    4ae2:	8f 16       	cp	r8, r31
    4ae4:	09 f0       	breq	.+2      	; 0x4ae8 <findFiles+0x13c>
    4ae6:	41 c0       	rjmp	.+130    	; 0x4b6a <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4ae8:	89 81       	ldd	r24, Y+1	; 0x01
    4aea:	9a 81       	ldd	r25, Y+2	; 0x02
    4aec:	ab 81       	ldd	r26, Y+3	; 0x03
    4aee:	bc 81       	ldd	r27, Y+4	; 0x04
    4af0:	80 93 a7 50 	sts	0x50A7, r24
    4af4:	90 93 a8 50 	sts	0x50A8, r25
    4af8:	a0 93 a9 50 	sts	0x50A9, r26
    4afc:	b0 93 aa 50 	sts	0x50AA, r27
				appendFileLocation = i;
    4b00:	c9 01       	movw	r24, r18
    4b02:	a0 e0       	ldi	r26, 0x00	; 0
    4b04:	b0 e0       	ldi	r27, 0x00	; 0
    4b06:	80 93 4e 40 	sts	0x404E, r24
    4b0a:	90 93 4f 40 	sts	0x404F, r25
    4b0e:	a0 93 50 40 	sts	0x4050, r26
    4b12:	b0 93 51 40 	sts	0x4051, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4b16:	d6 01       	movw	r26, r12
    4b18:	54 96       	adiw	r26, 0x14	; 20
    4b1a:	4d 91       	ld	r20, X+
    4b1c:	5c 91       	ld	r21, X
    4b1e:	55 97       	sbiw	r26, 0x15	; 21
    4b20:	60 e0       	ldi	r22, 0x00	; 0
    4b22:	70 e0       	ldi	r23, 0x00	; 0
    4b24:	ba 01       	movw	r22, r20
    4b26:	55 27       	eor	r21, r21
    4b28:	44 27       	eor	r20, r20
    4b2a:	5a 96       	adiw	r26, 0x1a	; 26
    4b2c:	8d 91       	ld	r24, X+
    4b2e:	9c 91       	ld	r25, X
    4b30:	5b 97       	sbiw	r26, 0x1b	; 27
    4b32:	a0 e0       	ldi	r26, 0x00	; 0
    4b34:	b0 e0       	ldi	r27, 0x00	; 0
    4b36:	84 2b       	or	r24, r20
    4b38:	95 2b       	or	r25, r21
    4b3a:	a6 2b       	or	r26, r22
    4b3c:	b7 2b       	or	r27, r23
    4b3e:	80 93 78 50 	sts	0x5078, r24
    4b42:	90 93 79 50 	sts	0x5079, r25
    4b46:	a0 93 7a 50 	sts	0x507A, r26
    4b4a:	b0 93 7b 50 	sts	0x507B, r27
				fileSize = dir->fileSize;
    4b4e:	f6 01       	movw	r30, r12
    4b50:	84 8d       	ldd	r24, Z+28	; 0x1c
    4b52:	95 8d       	ldd	r25, Z+29	; 0x1d
    4b54:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4b56:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4b58:	80 93 56 40 	sts	0x4056, r24
    4b5c:	90 93 57 40 	sts	0x4057, r25
    4b60:	a0 93 58 40 	sts	0x4058, r26
    4b64:	b0 93 59 40 	sts	0x4059, r27
			    return (dir);
    4b68:	a5 c0       	rjmp	.+330    	; 0x4cb4 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4b6a:	d6 01       	movw	r26, r12
    4b6c:	54 96       	adiw	r26, 0x14	; 20
    4b6e:	8d 91       	ld	r24, X+
    4b70:	9c 91       	ld	r25, X
    4b72:	55 97       	sbiw	r26, 0x15	; 21
    4b74:	a0 e0       	ldi	r26, 0x00	; 0
    4b76:	b0 e0       	ldi	r27, 0x00	; 0
    4b78:	3c 01       	movw	r6, r24
    4b7a:	55 24       	eor	r5, r5
    4b7c:	44 24       	eor	r4, r4
    4b7e:	f6 01       	movw	r30, r12
    4b80:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b82:	93 8d       	ldd	r25, Z+27	; 0x1b
    4b84:	a0 e0       	ldi	r26, 0x00	; 0
    4b86:	b0 e0       	ldi	r27, 0x00	; 0
    4b88:	48 2a       	or	r4, r24
    4b8a:	59 2a       	or	r5, r25
    4b8c:	6a 2a       	or	r6, r26
    4b8e:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4b90:	85 ee       	ldi	r24, 0xE5	; 229
    4b92:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4b94:	69 81       	ldd	r22, Y+1	; 0x01
    4b96:	7a 81       	ldd	r23, Y+2	; 0x02
    4b98:	8b 81       	ldd	r24, Y+3	; 0x03
    4b9a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b9c:	4d e4       	ldi	r20, 0x4D	; 77
    4b9e:	5e e3       	ldi	r21, 0x3E	; 62
    4ba0:	20 e0       	ldi	r18, 0x00	; 0
    4ba2:	32 e0       	ldi	r19, 0x02	; 2
    4ba4:	0e 94 01 2b 	call	0x5602	; 0x5602 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4ba8:	d6 01       	movw	r26, r12
    4baa:	5c 96       	adiw	r26, 0x1c	; 28
    4bac:	4d 91       	ld	r20, X+
    4bae:	5d 91       	ld	r21, X+
    4bb0:	6d 91       	ld	r22, X+
    4bb2:	7c 91       	ld	r23, X
    4bb4:	5f 97       	sbiw	r26, 0x1f	; 31
    4bb6:	80 e0       	ldi	r24, 0x00	; 0
    4bb8:	0e 94 68 24 	call	0x48d0	; 0x48d0 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4bbc:	82 e0       	ldi	r24, 0x02	; 2
    4bbe:	60 e0       	ldi	r22, 0x00	; 0
    4bc0:	20 e0       	ldi	r18, 0x00	; 0
    4bc2:	30 e0       	ldi	r19, 0x00	; 0
    4bc4:	a9 01       	movw	r20, r18
    4bc6:	0e 94 69 21 	call	0x42d2	; 0x42d2 <getSetFreeCluster>
    4bca:	dc 01       	movw	r26, r24
    4bcc:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4bce:	48 16       	cp	r4, r24
    4bd0:	59 06       	cpc	r5, r25
    4bd2:	6a 06       	cpc	r6, r26
    4bd4:	7b 06       	cpc	r7, r27
    4bd6:	30 f4       	brcc	.+12     	; 0x4be4 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4bd8:	82 e0       	ldi	r24, 0x02	; 2
    4bda:	61 e0       	ldi	r22, 0x01	; 1
    4bdc:	a3 01       	movw	r20, r6
    4bde:	92 01       	movw	r18, r4
    4be0:	0e 94 69 21 	call	0x42d2	; 0x42d2 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4be4:	c3 01       	movw	r24, r6
    4be6:	b2 01       	movw	r22, r4
    4be8:	40 e0       	ldi	r20, 0x00	; 0
    4bea:	00 e0       	ldi	r16, 0x00	; 0
    4bec:	10 e0       	ldi	r17, 0x00	; 0
    4bee:	98 01       	movw	r18, r16
    4bf0:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
    4bf4:	6b 01       	movw	r12, r22
    4bf6:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4bf8:	c3 01       	movw	r24, r6
    4bfa:	b2 01       	movw	r22, r4
    4bfc:	41 e0       	ldi	r20, 0x01	; 1
    4bfe:	00 e0       	ldi	r16, 0x00	; 0
    4c00:	10 e0       	ldi	r17, 0x00	; 0
    4c02:	98 01       	movw	r18, r16
    4c04:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4c08:	b7 ef       	ldi	r27, 0xF7	; 247
    4c0a:	cb 16       	cp	r12, r27
    4c0c:	bf ef       	ldi	r27, 0xFF	; 255
    4c0e:	db 06       	cpc	r13, r27
    4c10:	bf ef       	ldi	r27, 0xFF	; 255
    4c12:	eb 06       	cpc	r14, r27
    4c14:	bf e0       	ldi	r27, 0x0F	; 15
    4c16:	fb 06       	cpc	r15, r27
    4c18:	08 f0       	brcs	.+2      	; 0x4c1c <findFiles+0x270>
    4c1a:	47 c0       	rjmp	.+142    	; 0x4caa <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4c1c:	26 01       	movw	r4, r12
    4c1e:	37 01       	movw	r6, r14
    4c20:	e1 cf       	rjmp	.-62     	; 0x4be4 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4c22:	20 5e       	subi	r18, 0xE0	; 224
    4c24:	3f 4f       	sbci	r19, 0xFF	; 255
    4c26:	80 91 5a 40 	lds	r24, 0x405A
    4c2a:	90 91 5b 40 	lds	r25, 0x405B
    4c2e:	28 17       	cp	r18, r24
    4c30:	39 07       	cpc	r19, r25
    4c32:	08 f4       	brcc	.+2      	; 0x4c36 <findFiles+0x28a>
    4c34:	26 cf       	rjmp	.-436    	; 0x4a82 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4c36:	08 94       	sec
    4c38:	41 1c       	adc	r4, r1
    4c3a:	51 1c       	adc	r5, r1
    4c3c:	61 1c       	adc	r6, r1
    4c3e:	71 1c       	adc	r7, r1
    4c40:	80 91 6e 50 	lds	r24, 0x506E
    4c44:	90 91 6f 50 	lds	r25, 0x506F
    4c48:	a0 e0       	ldi	r26, 0x00	; 0
    4c4a:	b0 e0       	ldi	r27, 0x00	; 0
    4c4c:	48 16       	cp	r4, r24
    4c4e:	59 06       	cpc	r5, r25
    4c50:	6a 06       	cpc	r6, r26
    4c52:	7b 06       	cpc	r7, r27
    4c54:	08 f4       	brcc	.+2      	; 0x4c58 <findFiles+0x2ac>
    4c56:	f2 ce       	rjmp	.-540    	; 0x4a3c <findFiles+0x90>
    4c58:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4c5a:	69 85       	ldd	r22, Y+9	; 0x09
    4c5c:	7a 85       	ldd	r23, Y+10	; 0x0a
    4c5e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c60:	9c 85       	ldd	r25, Y+12	; 0x0c
    4c62:	40 e0       	ldi	r20, 0x00	; 0
    4c64:	00 e0       	ldi	r16, 0x00	; 0
    4c66:	10 e0       	ldi	r17, 0x00	; 0
    4c68:	98 01       	movw	r18, r16
    4c6a:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
    4c6e:	69 87       	std	Y+9, r22	; 0x09
    4c70:	7a 87       	std	Y+10, r23	; 0x0a
    4c72:	8b 87       	std	Y+11, r24	; 0x0b
    4c74:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4c76:	67 3f       	cpi	r22, 0xF7	; 247
    4c78:	ef ef       	ldi	r30, 0xFF	; 255
    4c7a:	7e 07       	cpc	r23, r30
    4c7c:	ef ef       	ldi	r30, 0xFF	; 255
    4c7e:	8e 07       	cpc	r24, r30
    4c80:	ef e0       	ldi	r30, 0x0F	; 15
    4c82:	9e 07       	cpc	r25, r30
    4c84:	a8 f4       	brcc	.+42     	; 0x4cb0 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4c86:	61 15       	cp	r22, r1
    4c88:	71 05       	cpc	r23, r1
    4c8a:	81 05       	cpc	r24, r1
    4c8c:	91 05       	cpc	r25, r1
    4c8e:	09 f0       	breq	.+2      	; 0x4c92 <findFiles+0x2e6>
    4c90:	c0 ce       	rjmp	.-640    	; 0x4a12 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4c92:	00 e0       	ldi	r16, 0x00	; 0
    4c94:	10 e0       	ldi	r17, 0x00	; 0
    4c96:	0e c0       	rjmp	.+28     	; 0x4cb4 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4c98:	00 e0       	ldi	r16, 0x00	; 0
    4c9a:	10 e0       	ldi	r17, 0x00	; 0
    4c9c:	0b c0       	rjmp	.+22     	; 0x4cb4 <findFiles+0x308>
    4c9e:	00 e0       	ldi	r16, 0x00	; 0
    4ca0:	10 e0       	ldi	r17, 0x00	; 0
    4ca2:	08 c0       	rjmp	.+16     	; 0x4cb4 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4ca4:	00 e0       	ldi	r16, 0x00	; 0
    4ca6:	10 e0       	ldi	r17, 0x00	; 0
    4ca8:	05 c0       	rjmp	.+10     	; 0x4cb4 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4caa:	00 e0       	ldi	r16, 0x00	; 0
    4cac:	10 e0       	ldi	r17, 0x00	; 0
    4cae:	02 c0       	rjmp	.+4      	; 0x4cb4 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4cb0:	00 e0       	ldi	r16, 0x00	; 0
    4cb2:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4cb4:	80 2f       	mov	r24, r16
    4cb6:	91 2f       	mov	r25, r17
    4cb8:	2c 96       	adiw	r28, 0x0c	; 12
    4cba:	cd bf       	out	0x3d, r28	; 61
    4cbc:	de bf       	out	0x3e, r29	; 62
    4cbe:	df 91       	pop	r29
    4cc0:	cf 91       	pop	r28
    4cc2:	1f 91       	pop	r17
    4cc4:	0f 91       	pop	r16
    4cc6:	ff 90       	pop	r15
    4cc8:	ef 90       	pop	r14
    4cca:	df 90       	pop	r13
    4ccc:	cf 90       	pop	r12
    4cce:	bf 90       	pop	r11
    4cd0:	af 90       	pop	r10
    4cd2:	9f 90       	pop	r9
    4cd4:	8f 90       	pop	r8
    4cd6:	7f 90       	pop	r7
    4cd8:	6f 90       	pop	r6
    4cda:	5f 90       	pop	r5
    4cdc:	4f 90       	pop	r4
    4cde:	3f 90       	pop	r3
    4ce0:	2f 90       	pop	r2
    4ce2:	08 95       	ret

00004ce4 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4ce4:	0e 94 f6 22 	call	0x45ec	; 0x45ec <convertFileName>
  if(error) return;
    4ce8:	88 23       	and	r24, r24
    4cea:	29 f4       	brne	.+10     	; 0x4cf6 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4cec:	82 e0       	ldi	r24, 0x02	; 2
    4cee:	66 e9       	ldi	r22, 0x96	; 150
    4cf0:	70 e5       	ldi	r23, 0x50	; 80
    4cf2:	0e 94 d6 24 	call	0x49ac	; 0x49ac <findFiles>
    4cf6:	08 95       	ret

00004cf8 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4cf8:	4f 92       	push	r4
    4cfa:	5f 92       	push	r5
    4cfc:	6f 92       	push	r6
    4cfe:	7f 92       	push	r7
    4d00:	af 92       	push	r10
    4d02:	bf 92       	push	r11
    4d04:	cf 92       	push	r12
    4d06:	df 92       	push	r13
    4d08:	ef 92       	push	r14
    4d0a:	ff 92       	push	r15
    4d0c:	0f 93       	push	r16
    4d0e:	1f 93       	push	r17
    4d10:	cf 93       	push	r28
    4d12:	c8 2f       	mov	r28, r24
    4d14:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4d16:	0e 94 f6 22 	call	0x45ec	; 0x45ec <convertFileName>
if(error) return 2;
    4d1a:	88 23       	and	r24, r24
    4d1c:	09 f0       	breq	.+2      	; 0x4d20 <readFile+0x28>
    4d1e:	57 c0       	rjmp	.+174    	; 0x4dce <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4d20:	81 e0       	ldi	r24, 0x01	; 1
    4d22:	66 e9       	ldi	r22, 0x96	; 150
    4d24:	70 e5       	ldi	r23, 0x50	; 80
    4d26:	0e 94 d6 24 	call	0x49ac	; 0x49ac <findFiles>
    4d2a:	fc 01       	movw	r30, r24
if(dir == 0) 
    4d2c:	00 97       	sbiw	r24, 0x00	; 0
    4d2e:	31 f4       	brne	.+12     	; 0x4d3c <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4d30:	81 e0       	ldi	r24, 0x01	; 1
    4d32:	cc 23       	and	r28, r28
    4d34:	09 f4       	brne	.+2      	; 0x4d38 <readFile+0x40>
    4d36:	4e c0       	rjmp	.+156    	; 0x4dd4 <readFile+0xdc>
    4d38:	80 e0       	ldi	r24, 0x00	; 0
    4d3a:	4c c0       	rjmp	.+152    	; 0x4dd4 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4d3c:	c1 30       	cpi	r28, 0x01	; 1
    4d3e:	09 f4       	brne	.+2      	; 0x4d42 <readFile+0x4a>
    4d40:	48 c0       	rjmp	.+144    	; 0x4dd2 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4d42:	44 88       	ldd	r4, Z+20	; 0x14
    4d44:	55 88       	ldd	r5, Z+21	; 0x15
    4d46:	66 24       	eor	r6, r6
    4d48:	77 24       	eor	r7, r7
    4d4a:	32 01       	movw	r6, r4
    4d4c:	55 24       	eor	r5, r5
    4d4e:	44 24       	eor	r4, r4
    4d50:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d52:	93 8d       	ldd	r25, Z+27	; 0x1b
    4d54:	a0 e0       	ldi	r26, 0x00	; 0
    4d56:	b0 e0       	ldi	r27, 0x00	; 0
    4d58:	48 2a       	or	r4, r24
    4d5a:	59 2a       	or	r5, r25
    4d5c:	6a 2a       	or	r6, r26
    4d5e:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4d60:	0f 2e       	mov	r0, r31
    4d62:	f1 eb       	ldi	r31, 0xB1	; 177
    4d64:	af 2e       	mov	r10, r31
    4d66:	f1 e2       	ldi	r31, 0x21	; 33
    4d68:	bf 2e       	mov	r11, r31
    4d6a:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4d6c:	c3 01       	movw	r24, r6
    4d6e:	b2 01       	movw	r22, r4
    4d70:	0e 94 b0 20 	call	0x4160	; 0x4160 <getFirstSector>
    4d74:	6b 01       	movw	r12, r22
    4d76:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4d78:	80 91 6e 50 	lds	r24, 0x506E
    4d7c:	90 91 6f 50 	lds	r25, 0x506F
    4d80:	00 97       	sbiw	r24, 0x00	; 0
    4d82:	a1 f0       	breq	.+40     	; 0x4dac <readFile+0xb4>
    4d84:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4d86:	c7 01       	movw	r24, r14
    4d88:	b6 01       	movw	r22, r12
    4d8a:	6c 0f       	add	r22, r28
    4d8c:	71 1d       	adc	r23, r1
    4d8e:	81 1d       	adc	r24, r1
    4d90:	91 1d       	adc	r25, r1
    4d92:	a5 01       	movw	r20, r10
    4d94:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4d98:	cf 5f       	subi	r28, 0xFF	; 255
    4d9a:	80 91 6e 50 	lds	r24, 0x506E
    4d9e:	90 91 6f 50 	lds	r25, 0x506F
    4da2:	2c 2f       	mov	r18, r28
    4da4:	30 e0       	ldi	r19, 0x00	; 0
    4da6:	28 17       	cp	r18, r24
    4da8:	39 07       	cpc	r19, r25
    4daa:	68 f3       	brcs	.-38     	; 0x4d86 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4dac:	c3 01       	movw	r24, r6
    4dae:	b2 01       	movw	r22, r4
    4db0:	40 e0       	ldi	r20, 0x00	; 0
    4db2:	00 e0       	ldi	r16, 0x00	; 0
    4db4:	10 e0       	ldi	r17, 0x00	; 0
    4db6:	98 01       	movw	r18, r16
    4db8:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
    4dbc:	2b 01       	movw	r4, r22
    4dbe:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4dc0:	61 15       	cp	r22, r1
    4dc2:	71 05       	cpc	r23, r1
    4dc4:	81 05       	cpc	r24, r1
    4dc6:	91 05       	cpc	r25, r1
    4dc8:	89 f6       	brne	.-94     	; 0x4d6c <readFile+0x74>
	  return 0;}
    4dca:	80 e0       	ldi	r24, 0x00	; 0
    4dcc:	03 c0       	rjmp	.+6      	; 0x4dd4 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4dce:	82 e0       	ldi	r24, 0x02	; 2
    4dd0:	01 c0       	rjmp	.+2      	; 0x4dd4 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4dd2:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4dd4:	cf 91       	pop	r28
    4dd6:	1f 91       	pop	r17
    4dd8:	0f 91       	pop	r16
    4dda:	ff 90       	pop	r15
    4ddc:	ef 90       	pop	r14
    4dde:	df 90       	pop	r13
    4de0:	cf 90       	pop	r12
    4de2:	bf 90       	pop	r11
    4de4:	af 90       	pop	r10
    4de6:	7f 90       	pop	r7
    4de8:	6f 90       	pop	r6
    4dea:	5f 90       	pop	r5
    4dec:	4f 90       	pop	r4
    4dee:	08 95       	ret

00004df0 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4df0:	2f 92       	push	r2
    4df2:	3f 92       	push	r3
    4df4:	4f 92       	push	r4
    4df6:	5f 92       	push	r5
    4df8:	6f 92       	push	r6
    4dfa:	7f 92       	push	r7
    4dfc:	8f 92       	push	r8
    4dfe:	9f 92       	push	r9
    4e00:	af 92       	push	r10
    4e02:	bf 92       	push	r11
    4e04:	cf 92       	push	r12
    4e06:	df 92       	push	r13
    4e08:	ef 92       	push	r14
    4e0a:	ff 92       	push	r15
    4e0c:	0f 93       	push	r16
    4e0e:	1f 93       	push	r17
    4e10:	cf 93       	push	r28
    4e12:	df 93       	push	r29
    4e14:	cd b7       	in	r28, 0x3d	; 61
    4e16:	de b7       	in	r29, 0x3e	; 62
    4e18:	60 97       	sbiw	r28, 0x10	; 16
    4e1a:	cd bf       	out	0x3d, r28	; 61
    4e1c:	de bf       	out	0x3e, r29	; 62
    4e1e:	fc 01       	movw	r30, r24
    4e20:	6d 83       	std	Y+5, r22	; 0x05
    4e22:	7e 83       	std	Y+6, r23	; 0x06
    4e24:	49 01       	movw	r8, r18
    4e26:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4e28:	81 e0       	ldi	r24, 0x01	; 1
    4e2a:	bf 01       	movw	r22, r30
    4e2c:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <readFile>

if(j == 1) 
    4e30:	81 30       	cpi	r24, 0x01	; 1
    4e32:	09 f0       	breq	.+2      	; 0x4e36 <writeFile+0x46>
    4e34:	7b c0       	rjmp	.+246    	; 0x4f2c <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4e36:	00 91 78 50 	lds	r16, 0x5078
    4e3a:	10 91 79 50 	lds	r17, 0x5079
    4e3e:	20 91 7a 50 	lds	r18, 0x507A
    4e42:	30 91 7b 50 	lds	r19, 0x507B
    4e46:	09 83       	std	Y+1, r16	; 0x01
    4e48:	1a 83       	std	Y+2, r17	; 0x02
    4e4a:	2b 83       	std	Y+3, r18	; 0x03
    4e4c:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4e4e:	cc 24       	eor	r12, r12
    4e50:	dd 24       	eor	r13, r13
    4e52:	76 01       	movw	r14, r12
    4e54:	24 01       	movw	r4, r8
    4e56:	35 01       	movw	r6, r10
    4e58:	48 01       	movw	r8, r16
    4e5a:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4e5c:	c5 01       	movw	r24, r10
    4e5e:	b4 01       	movw	r22, r8
    4e60:	40 e0       	ldi	r20, 0x00	; 0
    4e62:	00 e0       	ldi	r16, 0x00	; 0
    4e64:	10 e0       	ldi	r17, 0x00	; 0
    4e66:	98 01       	movw	r18, r16
    4e68:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
    4e6c:	dc 01       	movw	r26, r24
    4e6e:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4e70:	8f 3f       	cpi	r24, 0xFF	; 255
    4e72:	1f ef       	ldi	r17, 0xFF	; 255
    4e74:	91 07       	cpc	r25, r17
    4e76:	1f ef       	ldi	r17, 0xFF	; 255
    4e78:	a1 07       	cpc	r26, r17
    4e7a:	1f ef       	ldi	r17, 0xFF	; 255
    4e7c:	b1 07       	cpc	r27, r17
    4e7e:	41 f0       	breq	.+16     	; 0x4e90 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4e80:	08 94       	sec
    4e82:	c1 1c       	adc	r12, r1
    4e84:	d1 1c       	adc	r13, r1
    4e86:	e1 1c       	adc	r14, r1
    4e88:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4e8a:	4c 01       	movw	r8, r24
    4e8c:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4e8e:	e6 cf       	rjmp	.-52     	; 0x4e5c <writeFile+0x6c>
    4e90:	89 82       	std	Y+1, r8	; 0x01
    4e92:	9a 82       	std	Y+2, r9	; 0x02
    4e94:	ab 82       	std	Y+3, r10	; 0x03
    4e96:	bc 82       	std	Y+4, r11	; 0x04
    4e98:	53 01       	movw	r10, r6
    4e9a:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4e9c:	20 91 6e 50 	lds	r18, 0x506E
    4ea0:	30 91 6f 50 	lds	r19, 0x506F
    4ea4:	80 91 5a 40 	lds	r24, 0x405A
    4ea8:	90 91 5b 40 	lds	r25, 0x405B
    4eac:	60 90 5a 40 	lds	r6, 0x405A
    4eb0:	70 90 5b 40 	lds	r7, 0x405B
    4eb4:	bc 01       	movw	r22, r24
    4eb6:	80 e0       	ldi	r24, 0x00	; 0
    4eb8:	90 e0       	ldi	r25, 0x00	; 0
    4eba:	40 e0       	ldi	r20, 0x00	; 0
    4ebc:	50 e0       	ldi	r21, 0x00	; 0
    4ebe:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    4ec2:	a7 01       	movw	r20, r14
    4ec4:	96 01       	movw	r18, r12
    4ec6:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    4eca:	dc 01       	movw	r26, r24
    4ecc:	cb 01       	movw	r24, r22
    4ece:	40 91 56 40 	lds	r20, 0x4056
    4ed2:	50 91 57 40 	lds	r21, 0x4057
    4ed6:	60 91 58 40 	lds	r22, 0x4058
    4eda:	70 91 59 40 	lds	r23, 0x4059
    4ede:	8a 01       	movw	r16, r20
    4ee0:	9b 01       	movw	r18, r22
    4ee2:	08 1b       	sub	r16, r24
    4ee4:	19 0b       	sbc	r17, r25
    4ee6:	2a 0b       	sbc	r18, r26
    4ee8:	3b 0b       	sbc	r19, r27
    4eea:	c9 01       	movw	r24, r18
    4eec:	b8 01       	movw	r22, r16
    4eee:	93 01       	movw	r18, r6
    4ef0:	40 e0       	ldi	r20, 0x00	; 0
    4ef2:	50 e0       	ldi	r21, 0x00	; 0
    4ef4:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    4ef8:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4efa:	69 81       	ldd	r22, Y+1	; 0x01
    4efc:	7a 81       	ldd	r23, Y+2	; 0x02
    4efe:	8b 81       	ldd	r24, Y+3	; 0x03
    4f00:	9c 81       	ldd	r25, Y+4	; 0x04
    4f02:	0e 94 b0 20 	call	0x4160	; 0x4160 <getFirstSector>
    4f06:	dc 01       	movw	r26, r24
    4f08:	cb 01       	movw	r24, r22
    4f0a:	20 2e       	mov	r2, r16
    4f0c:	33 24       	eor	r3, r3
    4f0e:	28 0e       	add	r2, r24
    4f10:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4f12:	b1 01       	movw	r22, r2
    4f14:	80 e0       	ldi	r24, 0x00	; 0
    4f16:	90 e0       	ldi	r25, 0x00	; 0
    4f18:	4d e4       	ldi	r20, 0x4D	; 77
    4f1a:	5e e3       	ldi	r21, 0x3E	; 62
    4f1c:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4f20:	1f 86       	std	Y+15, r1	; 0x0f
    4f22:	18 8a       	std	Y+16, r1	; 0x10
    4f24:	19 86       	std	Y+9, r1	; 0x09
    4f26:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4f28:	11 e0       	ldi	r17, 0x01	; 1
    4f2a:	4c c0       	rjmp	.+152    	; 0x4fc4 <writeFile+0x1d4>
}
else if(j == 2) 
    4f2c:	82 30       	cpi	r24, 0x02	; 2
    4f2e:	09 f4       	brne	.+2      	; 0x4f32 <writeFile+0x142>
    4f30:	0c c2       	rjmp	.+1048   	; 0x534a <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4f32:	82 e0       	ldi	r24, 0x02	; 2
    4f34:	60 e0       	ldi	r22, 0x00	; 0
    4f36:	20 e0       	ldi	r18, 0x00	; 0
    4f38:	30 e0       	ldi	r19, 0x00	; 0
    4f3a:	a9 01       	movw	r20, r18
    4f3c:	0e 94 69 21 	call	0x42d2	; 0x42d2 <getSetFreeCluster>
  if(cluster > totalClusters)
    4f40:	00 91 5d 40 	lds	r16, 0x405D
    4f44:	10 91 5e 40 	lds	r17, 0x405E
    4f48:	20 91 5f 40 	lds	r18, 0x405F
    4f4c:	30 91 60 40 	lds	r19, 0x4060
    4f50:	06 17       	cp	r16, r22
    4f52:	17 07       	cpc	r17, r23
    4f54:	28 07       	cpc	r18, r24
    4f56:	39 07       	cpc	r19, r25
    4f58:	40 f4       	brcc	.+16     	; 0x4f6a <writeFile+0x17a>
     cluster = rootCluster;
    4f5a:	60 91 62 40 	lds	r22, 0x4062
    4f5e:	70 91 63 40 	lds	r23, 0x4063
    4f62:	80 91 64 40 	lds	r24, 0x4064
    4f66:	90 91 65 40 	lds	r25, 0x4065

  cluster = searchNextFreeCluster(cluster);
    4f6a:	0e 94 b5 23 	call	0x476a	; 0x476a <searchNextFreeCluster>
    4f6e:	69 83       	std	Y+1, r22	; 0x01
    4f70:	7a 83       	std	Y+2, r23	; 0x02
    4f72:	8b 83       	std	Y+3, r24	; 0x03
    4f74:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4f76:	61 15       	cp	r22, r1
    4f78:	71 05       	cpc	r23, r1
    4f7a:	81 05       	cpc	r24, r1
    4f7c:	91 05       	cpc	r25, r1
    4f7e:	09 f4       	brne	.+2      	; 0x4f82 <writeFile+0x192>
    4f80:	e6 c1       	rjmp	.+972    	; 0x534e <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4f82:	41 e0       	ldi	r20, 0x01	; 1
    4f84:	0f ef       	ldi	r16, 0xFF	; 255
    4f86:	1f ef       	ldi	r17, 0xFF	; 255
    4f88:	98 01       	movw	r18, r16
    4f8a:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4f8e:	2b 81       	ldd	r18, Y+3	; 0x03
    4f90:	3c 81       	ldd	r19, Y+4	; 0x04
    4f92:	29 87       	std	Y+9, r18	; 0x09
    4f94:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4f96:	89 81       	ldd	r24, Y+1	; 0x01
    4f98:	9a 81       	ldd	r25, Y+2	; 0x02
    4f9a:	8f 87       	std	Y+15, r24	; 0x0f
    4f9c:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4f9e:	10 92 56 40 	sts	0x4056, r1
    4fa2:	10 92 57 40 	sts	0x4057, r1
    4fa6:	10 92 58 40 	sts	0x4058, r1
    4faa:	10 92 59 40 	sts	0x4059, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4fae:	69 81       	ldd	r22, Y+1	; 0x01
    4fb0:	7a 81       	ldd	r23, Y+2	; 0x02
    4fb2:	8b 81       	ldd	r24, Y+3	; 0x03
    4fb4:	9c 81       	ldd	r25, Y+4	; 0x04
    4fb6:	0e 94 b0 20 	call	0x4160	; 0x4160 <getFirstSector>
    4fba:	dc 01       	movw	r26, r24
    4fbc:	cb 01       	movw	r24, r22
    4fbe:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4fc0:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4fc2:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4fc4:	81 14       	cp	r8, r1
    4fc6:	91 04       	cpc	r9, r1
    4fc8:	a1 04       	cpc	r10, r1
    4fca:	b1 04       	cpc	r11, r1
    4fcc:	09 f4       	brne	.+2      	; 0x4fd0 <writeFile+0x1e0>
    4fce:	8d c0       	rjmp	.+282    	; 0x50ea <writeFile+0x2fa>
    4fd0:	44 24       	eor	r4, r4
    4fd2:	55 24       	eor	r5, r5
    4fd4:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4fd6:	c0 2e       	mov	r12, r16
    4fd8:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4fda:	90 e0       	ldi	r25, 0x00	; 0
    4fdc:	89 16       	cp	r8, r25
    4fde:	92 e0       	ldi	r25, 0x02	; 2
    4fe0:	99 06       	cpc	r9, r25
    4fe2:	90 e0       	ldi	r25, 0x00	; 0
    4fe4:	a9 06       	cpc	r10, r25
    4fe6:	90 e0       	ldi	r25, 0x00	; 0
    4fe8:	b9 06       	cpc	r11, r25
    4fea:	88 f0       	brcs	.+34     	; 0x500e <writeFile+0x21e>
		 writtenData += 512;
    4fec:	00 e0       	ldi	r16, 0x00	; 0
    4fee:	12 e0       	ldi	r17, 0x02	; 2
    4ff0:	20 e0       	ldi	r18, 0x00	; 0
    4ff2:	30 e0       	ldi	r19, 0x00	; 0
    4ff4:	40 0e       	add	r4, r16
    4ff6:	51 1e       	adc	r5, r17
    4ff8:	62 1e       	adc	r6, r18
    4ffa:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4ffc:	80 e0       	ldi	r24, 0x00	; 0
    4ffe:	9e ef       	ldi	r25, 0xFE	; 254
    5000:	af ef       	ldi	r26, 0xFF	; 255
    5002:	bf ef       	ldi	r27, 0xFF	; 255
    5004:	88 0e       	add	r8, r24
    5006:	99 1e       	adc	r9, r25
    5008:	aa 1e       	adc	r10, r26
    500a:	bb 1e       	adc	r11, r27
    500c:	0c c0       	rjmp	.+24     	; 0x5026 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    500e:	48 0c       	add	r4, r8
    5010:	59 1c       	adc	r5, r9
    5012:	6a 1c       	adc	r6, r10
    5014:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    5016:	95 01       	movw	r18, r10
    5018:	84 01       	movw	r16, r8
    501a:	11 70       	andi	r17, 0x01	; 1
    501c:	20 70       	andi	r18, 0x00	; 0
    501e:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    5020:	88 24       	eor	r8, r8
    5022:	99 24       	eor	r9, r9
    5024:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    5026:	80 91 56 40 	lds	r24, 0x4056
    502a:	90 91 57 40 	lds	r25, 0x4057
    502e:	a0 91 58 40 	lds	r26, 0x4058
    5032:	b0 91 59 40 	lds	r27, 0x4059
    5036:	80 50       	subi	r24, 0x00	; 0
    5038:	9e 4f       	sbci	r25, 0xFE	; 254
    503a:	af 4f       	sbci	r26, 0xFF	; 255
    503c:	bf 4f       	sbci	r27, 0xFF	; 255
    503e:	80 93 56 40 	sts	0x4056, r24
    5042:	90 93 57 40 	sts	0x4057, r25
    5046:	a0 93 58 40 	sts	0x4058, r26
    504a:	b0 93 59 40 	sts	0x4059, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    504e:	b1 01       	movw	r22, r2
    5050:	80 e0       	ldi	r24, 0x00	; 0
    5052:	90 e0       	ldi	r25, 0x00	; 0
    5054:	a2 01       	movw	r20, r4
    5056:	40 1b       	sub	r20, r16
    5058:	51 0b       	sbc	r21, r17
    505a:	ad 81       	ldd	r26, Y+5	; 0x05
    505c:	be 81       	ldd	r27, Y+6	; 0x06
    505e:	4a 0f       	add	r20, r26
    5060:	5b 1f       	adc	r21, r27
    5062:	98 01       	movw	r18, r16
    5064:	0e 94 01 2b 	call	0x5602	; 0x5602 <SD_write_block>
	j++;
    5068:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    506a:	20 91 6e 50 	lds	r18, 0x506E
    506e:	30 91 6f 50 	lds	r19, 0x506F
    5072:	8c 2d       	mov	r24, r12
    5074:	90 e0       	ldi	r25, 0x00	; 0
    5076:	82 17       	cp	r24, r18
    5078:	93 07       	cpc	r25, r19
    507a:	29 f5       	brne	.+74     	; 0x50c6 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    507c:	69 81       	ldd	r22, Y+1	; 0x01
    507e:	7a 81       	ldd	r23, Y+2	; 0x02
    5080:	8b 81       	ldd	r24, Y+3	; 0x03
    5082:	9c 81       	ldd	r25, Y+4	; 0x04
    5084:	0e 94 b5 23 	call	0x476a	; 0x476a <searchNextFreeCluster>
    5088:	6b 01       	movw	r12, r22
    508a:	7c 01       	movw	r14, r24
		if(cluster == 0){
    508c:	61 15       	cp	r22, r1
    508e:	71 05       	cpc	r23, r1
    5090:	81 05       	cpc	r24, r1
    5092:	91 05       	cpc	r25, r1
    5094:	09 f4       	brne	.+2      	; 0x5098 <writeFile+0x2a8>
    5096:	5d c1       	rjmp	.+698    	; 0x5352 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    5098:	69 81       	ldd	r22, Y+1	; 0x01
    509a:	7a 81       	ldd	r23, Y+2	; 0x02
    509c:	8b 81       	ldd	r24, Y+3	; 0x03
    509e:	9c 81       	ldd	r25, Y+4	; 0x04
    50a0:	41 e0       	ldi	r20, 0x01	; 1
    50a2:	97 01       	movw	r18, r14
    50a4:	86 01       	movw	r16, r12
    50a6:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    50aa:	c7 01       	movw	r24, r14
    50ac:	b6 01       	movw	r22, r12
    50ae:	41 e0       	ldi	r20, 0x01	; 1
    50b0:	0f ef       	ldi	r16, 0xFF	; 255
    50b2:	1f ef       	ldi	r17, 0xFF	; 255
    50b4:	98 01       	movw	r18, r16
    50b6:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    50ba:	c9 82       	std	Y+1, r12	; 0x01
    50bc:	da 82       	std	Y+2, r13	; 0x02
    50be:	eb 82       	std	Y+3, r14	; 0x03
    50c0:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    50c2:	cc 24       	eor	r12, r12
    50c4:	03 c0       	rjmp	.+6      	; 0x50cc <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    50c6:	08 94       	sec
    50c8:	21 1c       	adc	r2, r1
    50ca:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    50cc:	82 e0       	ldi	r24, 0x02	; 2
    50ce:	61 e0       	ldi	r22, 0x01	; 1
    50d0:	29 81       	ldd	r18, Y+1	; 0x01
    50d2:	3a 81       	ldd	r19, Y+2	; 0x02
    50d4:	4b 81       	ldd	r20, Y+3	; 0x03
    50d6:	5c 81       	ldd	r21, Y+4	; 0x04
    50d8:	0e 94 69 21 	call	0x42d2	; 0x42d2 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    50dc:	81 14       	cp	r8, r1
    50de:	91 04       	cpc	r9, r1
    50e0:	a1 04       	cpc	r10, r1
    50e2:	b1 04       	cpc	r11, r1
    50e4:	09 f0       	breq	.+2      	; 0x50e8 <writeFile+0x2f8>
    50e6:	79 cf       	rjmp	.-270    	; 0x4fda <writeFile+0x1ea>
    50e8:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    50ea:	11 23       	and	r17, r17
    50ec:	09 f4       	brne	.+2      	; 0x50f0 <writeFile+0x300>
    50ee:	3f c0       	rjmp	.+126    	; 0x516e <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    50f0:	60 91 a7 50 	lds	r22, 0x50A7
    50f4:	70 91 a8 50 	lds	r23, 0x50A8
    50f8:	80 91 a9 50 	lds	r24, 0x50A9
    50fc:	90 91 aa 50 	lds	r25, 0x50AA
    5100:	0d e4       	ldi	r16, 0x4D	; 77
    5102:	1e e3       	ldi	r17, 0x3E	; 62
    5104:	a8 01       	movw	r20, r16
    5106:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    510a:	e0 91 4e 40 	lds	r30, 0x404E
    510e:	f0 91 4f 40 	lds	r31, 0x404F
    5112:	e0 0f       	add	r30, r16
    5114:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    5116:	12 8a       	std	Z+18, r1	; 0x12
    5118:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    511a:	80 91 56 40 	lds	r24, 0x4056
    511e:	90 91 57 40 	lds	r25, 0x4057
    5122:	a0 91 58 40 	lds	r26, 0x4058
    5126:	b0 91 59 40 	lds	r27, 0x4059
    512a:	44 8d       	ldd	r20, Z+28	; 0x1c
    512c:	55 8d       	ldd	r21, Z+29	; 0x1d
    512e:	66 8d       	ldd	r22, Z+30	; 0x1e
    5130:	77 8d       	ldd	r23, Z+31	; 0x1f
    5132:	6c 01       	movw	r12, r24
    5134:	7d 01       	movw	r14, r26
    5136:	c4 1a       	sub	r12, r20
    5138:	d5 0a       	sbc	r13, r21
    513a:	e6 0a       	sbc	r14, r22
    513c:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    513e:	84 8f       	std	Z+28, r24	; 0x1c
    5140:	95 8f       	std	Z+29, r25	; 0x1d
    5142:	a6 8f       	std	Z+30, r26	; 0x1e
    5144:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    5146:	60 91 a7 50 	lds	r22, 0x50A7
    514a:	70 91 a8 50 	lds	r23, 0x50A8
    514e:	80 91 a9 50 	lds	r24, 0x50A9
    5152:	90 91 aa 50 	lds	r25, 0x50AA
    5156:	a8 01       	movw	r20, r16
    5158:	20 e0       	ldi	r18, 0x00	; 0
    515a:	32 e0       	ldi	r19, 0x02	; 2
    515c:	0e 94 01 2b 	call	0x5602	; 0x5602 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    5160:	81 e0       	ldi	r24, 0x01	; 1
    5162:	b7 01       	movw	r22, r14
    5164:	a6 01       	movw	r20, r12
    5166:	0e 94 68 24 	call	0x48d0	; 0x48d0 <freeMemoryUpdate>

 //File appended!
  return 0;
    516a:	80 e0       	ldi	r24, 0x00	; 0
    516c:	f9 c0       	rjmp	.+498    	; 0x5360 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    516e:	00 91 62 40 	lds	r16, 0x4062
    5172:	10 91 63 40 	lds	r17, 0x4063
    5176:	20 91 64 40 	lds	r18, 0x4064
    517a:	30 91 65 40 	lds	r19, 0x4065
    517e:	0b 87       	std	Y+11, r16	; 0x0b
    5180:	1c 87       	std	Y+12, r17	; 0x0c
    5182:	2d 87       	std	Y+13, r18	; 0x0d
    5184:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    5186:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5188:	86 e9       	ldi	r24, 0x96	; 150
    518a:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    518c:	0f 2e       	mov	r0, r31
    518e:	fb e0       	ldi	r31, 0x0B	; 11
    5190:	af 2e       	mov	r10, r31
    5192:	bb 24       	eor	r11, r11
    5194:	f0 2d       	mov	r31, r0
    5196:	a8 0e       	add	r10, r24
    5198:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    519a:	88 24       	eor	r8, r8
    519c:	68 94       	set
    519e:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    51a0:	0f 2e       	mov	r0, r31
    51a2:	fd e4       	ldi	r31, 0x4D	; 77
    51a4:	4f 2e       	mov	r4, r31
    51a6:	fe e3       	ldi	r31, 0x3E	; 62
    51a8:	5f 2e       	mov	r5, r31
    51aa:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    51ac:	28 2e       	mov	r2, r24
    51ae:	99 2e       	mov	r9, r25
    51b0:	37 2c       	mov	r3, r7
    51b2:	6f 84       	ldd	r6, Y+15	; 0x0f
    51b4:	78 88       	ldd	r7, Y+16	; 0x10
    51b6:	04 c0       	rjmp	.+8      	; 0x51c0 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    51b8:	cb 86       	std	Y+11, r12	; 0x0b
    51ba:	dc 86       	std	Y+12, r13	; 0x0c
    51bc:	ed 86       	std	Y+13, r14	; 0x0d
    51be:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    51c0:	6b 85       	ldd	r22, Y+11	; 0x0b
    51c2:	7c 85       	ldd	r23, Y+12	; 0x0c
    51c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    51c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    51c8:	0e 94 b0 20 	call	0x4160	; 0x4160 <getFirstSector>
    51cc:	6d 83       	std	Y+5, r22	; 0x05
    51ce:	7e 83       	std	Y+6, r23	; 0x06
    51d0:	8f 83       	std	Y+7, r24	; 0x07
    51d2:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    51d4:	80 91 6e 50 	lds	r24, 0x506E
    51d8:	90 91 6f 50 	lds	r25, 0x506F
    51dc:	00 97       	sbiw	r24, 0x00	; 0
    51de:	09 f4       	brne	.+2      	; 0x51e2 <writeFile+0x3f2>
    51e0:	77 c0       	rjmp	.+238    	; 0x52d0 <writeFile+0x4e0>
    51e2:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    51e4:	cd 80       	ldd	r12, Y+5	; 0x05
    51e6:	de 80       	ldd	r13, Y+6	; 0x06
    51e8:	ef 80       	ldd	r14, Y+7	; 0x07
    51ea:	f8 84       	ldd	r15, Y+8	; 0x08
    51ec:	19 81       	ldd	r17, Y+1	; 0x01
    51ee:	c1 0e       	add	r12, r17
    51f0:	d1 1c       	adc	r13, r1
    51f2:	e1 1c       	adc	r14, r1
    51f4:	f1 1c       	adc	r15, r1
    51f6:	c7 01       	movw	r24, r14
    51f8:	b6 01       	movw	r22, r12
    51fa:	a2 01       	movw	r20, r4
    51fc:	0e 94 b6 2b 	call	0x576c	; 0x576c <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    5200:	80 91 5a 40 	lds	r24, 0x405A
    5204:	90 91 5b 40 	lds	r25, 0x405B
    5208:	00 97       	sbiw	r24, 0x00	; 0
    520a:	09 f4       	brne	.+2      	; 0x520e <writeFile+0x41e>
    520c:	54 c0       	rjmp	.+168    	; 0x52b6 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    520e:	33 20       	and	r3, r3
    5210:	09 f0       	breq	.+2      	; 0x5214 <writeFile+0x424>
    5212:	a1 c0       	rjmp	.+322    	; 0x5356 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    5214:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5216:	00 e0       	ldi	r16, 0x00	; 0
    5218:	10 e0       	ldi	r17, 0x00	; 0
    521a:	06 c0       	rjmp	.+12     	; 0x5228 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    521c:	a8 01       	movw	r20, r16
    521e:	43 5b       	subi	r20, 0xB3	; 179
    5220:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    5222:	22 23       	and	r18, r18
    5224:	09 f0       	breq	.+2      	; 0x5228 <writeFile+0x438>
    5226:	99 c0       	rjmp	.+306    	; 0x535a <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5228:	da 01       	movw	r26, r20
    522a:	8c 91       	ld	r24, X
    522c:	88 23       	and	r24, r24
    522e:	21 f4       	brne	.+8      	; 0x5238 <writeFile+0x448>
    5230:	e2 2d       	mov	r30, r2
    5232:	f9 2d       	mov	r31, r9
    5234:	da 01       	movw	r26, r20
    5236:	04 c0       	rjmp	.+8      	; 0x5240 <writeFile+0x450>
    5238:	85 3e       	cpi	r24, 0xE5	; 229
    523a:	d1 f3       	breq	.-12     	; 0x5230 <writeFile+0x440>
    523c:	23 2d       	mov	r18, r3
    523e:	30 c0       	rjmp	.+96     	; 0x52a0 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    5240:	81 91       	ld	r24, Z+
    5242:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    5244:	ea 15       	cp	r30, r10
    5246:	fb 05       	cpc	r31, r11
    5248:	d9 f7       	brne	.-10     	; 0x5240 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    524a:	fa 01       	movw	r30, r20
    524c:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    524e:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    5250:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    5252:	12 8a       	std	Z+18, r1	; 0x12
    5254:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    5256:	29 85       	ldd	r18, Y+9	; 0x09
    5258:	3a 85       	ldd	r19, Y+10	; 0x0a
    525a:	24 8b       	std	Z+20, r18	; 0x14
    525c:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    525e:	62 8e       	std	Z+26, r6	; 0x1a
    5260:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    5262:	80 91 56 40 	lds	r24, 0x4056
    5266:	90 91 57 40 	lds	r25, 0x4057
    526a:	a0 91 58 40 	lds	r26, 0x4058
    526e:	b0 91 59 40 	lds	r27, 0x4059
    5272:	84 8f       	std	Z+28, r24	; 0x1c
    5274:	95 8f       	std	Z+29, r25	; 0x1d
    5276:	a6 8f       	std	Z+30, r26	; 0x1e
    5278:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    527a:	c7 01       	movw	r24, r14
    527c:	b6 01       	movw	r22, r12
    527e:	a2 01       	movw	r20, r4
    5280:	20 e0       	ldi	r18, 0x00	; 0
    5282:	32 e0       	ldi	r19, 0x02	; 2
    5284:	0e 94 01 2b 	call	0x5602	; 0x5602 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    5288:	40 91 56 40 	lds	r20, 0x4056
    528c:	50 91 57 40 	lds	r21, 0x4057
    5290:	60 91 58 40 	lds	r22, 0x4058
    5294:	70 91 59 40 	lds	r23, 0x4059
    5298:	81 e0       	ldi	r24, 0x01	; 1
    529a:	0e 94 68 24 	call	0x48d0	; 0x48d0 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    529e:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    52a0:	00 5e       	subi	r16, 0xE0	; 224
    52a2:	1f 4f       	sbci	r17, 0xFF	; 255
    52a4:	80 91 5a 40 	lds	r24, 0x405A
    52a8:	90 91 5b 40 	lds	r25, 0x405B
    52ac:	08 17       	cp	r16, r24
    52ae:	19 07       	cpc	r17, r25
    52b0:	08 f4       	brcc	.+2      	; 0x52b4 <writeFile+0x4c4>
    52b2:	b4 cf       	rjmp	.-152    	; 0x521c <writeFile+0x42c>
    52b4:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    52b6:	09 81       	ldd	r16, Y+1	; 0x01
    52b8:	0f 5f       	subi	r16, 0xFF	; 255
    52ba:	09 83       	std	Y+1, r16	; 0x01
    52bc:	20 91 6e 50 	lds	r18, 0x506E
    52c0:	30 91 6f 50 	lds	r19, 0x506F
    52c4:	80 2f       	mov	r24, r16
    52c6:	90 e0       	ldi	r25, 0x00	; 0
    52c8:	82 17       	cp	r24, r18
    52ca:	93 07       	cpc	r25, r19
    52cc:	08 f4       	brcc	.+2      	; 0x52d0 <writeFile+0x4e0>
    52ce:	8a cf       	rjmp	.-236    	; 0x51e4 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    52d0:	6b 85       	ldd	r22, Y+11	; 0x0b
    52d2:	7c 85       	ldd	r23, Y+12	; 0x0c
    52d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    52d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    52d8:	40 e0       	ldi	r20, 0x00	; 0
    52da:	00 e0       	ldi	r16, 0x00	; 0
    52dc:	10 e0       	ldi	r17, 0x00	; 0
    52de:	98 01       	movw	r18, r16
    52e0:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
    52e4:	6b 01       	movw	r12, r22
    52e6:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    52e8:	67 3f       	cpi	r22, 0xF7	; 247
    52ea:	1f ef       	ldi	r17, 0xFF	; 255
    52ec:	71 07       	cpc	r23, r17
    52ee:	1f ef       	ldi	r17, 0xFF	; 255
    52f0:	81 07       	cpc	r24, r17
    52f2:	1f e0       	ldi	r17, 0x0F	; 15
    52f4:	91 07       	cpc	r25, r17
    52f6:	08 f1       	brcs	.+66     	; 0x533a <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    52f8:	6f 3f       	cpi	r22, 0xFF	; 255
    52fa:	2f ef       	ldi	r18, 0xFF	; 255
    52fc:	72 07       	cpc	r23, r18
    52fe:	2f ef       	ldi	r18, 0xFF	; 255
    5300:	82 07       	cpc	r24, r18
    5302:	2f ef       	ldi	r18, 0xFF	; 255
    5304:	92 07       	cpc	r25, r18
    5306:	59 f5       	brne	.+86     	; 0x535e <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    5308:	6b 85       	ldd	r22, Y+11	; 0x0b
    530a:	7c 85       	ldd	r23, Y+12	; 0x0c
    530c:	8d 85       	ldd	r24, Y+13	; 0x0d
    530e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5310:	0e 94 b5 23 	call	0x476a	; 0x476a <searchNextFreeCluster>
    5314:	6b 01       	movw	r12, r22
    5316:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    5318:	6b 85       	ldd	r22, Y+11	; 0x0b
    531a:	7c 85       	ldd	r23, Y+12	; 0x0c
    531c:	8d 85       	ldd	r24, Y+13	; 0x0d
    531e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5320:	41 e0       	ldi	r20, 0x01	; 1
    5322:	97 01       	movw	r18, r14
    5324:	86 01       	movw	r16, r12
    5326:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    532a:	c7 01       	movw	r24, r14
    532c:	b6 01       	movw	r22, r12
    532e:	41 e0       	ldi	r20, 0x01	; 1
    5330:	0f ef       	ldi	r16, 0xFF	; 255
    5332:	1f ef       	ldi	r17, 0xFF	; 255
    5334:	98 01       	movw	r18, r16
    5336:	0e 94 d7 20 	call	0x41ae	; 0x41ae <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    533a:	c1 14       	cp	r12, r1
    533c:	d1 04       	cpc	r13, r1
    533e:	e1 04       	cpc	r14, r1
    5340:	f1 04       	cpc	r15, r1
    5342:	09 f0       	breq	.+2      	; 0x5346 <writeFile+0x556>
    5344:	39 cf       	rjmp	.-398    	; 0x51b8 <writeFile+0x3c8>
	   return 4;
    5346:	84 e0       	ldi	r24, 0x04	; 4
    5348:	0b c0       	rjmp	.+22     	; 0x5360 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    534a:	81 e0       	ldi	r24, 0x01	; 1
    534c:	09 c0       	rjmp	.+18     	; 0x5360 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    534e:	82 e0       	ldi	r24, 0x02	; 2
    5350:	07 c0       	rjmp	.+14     	; 0x5360 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    5352:	82 e0       	ldi	r24, 0x02	; 2
    5354:	05 c0       	rjmp	.+10     	; 0x5360 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    5356:	80 e0       	ldi	r24, 0x00	; 0
    5358:	03 c0       	rjmp	.+6      	; 0x5360 <writeFile+0x570>
    535a:	80 e0       	ldi	r24, 0x00	; 0
    535c:	01 c0       	rjmp	.+2      	; 0x5360 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    535e:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    5360:	60 96       	adiw	r28, 0x10	; 16
    5362:	cd bf       	out	0x3d, r28	; 61
    5364:	de bf       	out	0x3e, r29	; 62
    5366:	df 91       	pop	r29
    5368:	cf 91       	pop	r28
    536a:	1f 91       	pop	r17
    536c:	0f 91       	pop	r16
    536e:	ff 90       	pop	r15
    5370:	ef 90       	pop	r14
    5372:	df 90       	pop	r13
    5374:	cf 90       	pop	r12
    5376:	bf 90       	pop	r11
    5378:	af 90       	pop	r10
    537a:	9f 90       	pop	r9
    537c:	8f 90       	pop	r8
    537e:	7f 90       	pop	r7
    5380:	6f 90       	pop	r6
    5382:	5f 90       	pop	r5
    5384:	4f 90       	pop	r4
    5386:	3f 90       	pop	r3
    5388:	2f 90       	pop	r2
    538a:	08 95       	ret

0000538c <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    538c:	8f 92       	push	r8
    538e:	9f 92       	push	r9
    5390:	af 92       	push	r10
    5392:	bf 92       	push	r11
    5394:	cf 92       	push	r12
    5396:	df 92       	push	r13
    5398:	ef 92       	push	r14
    539a:	ff 92       	push	r15
    539c:	0f 93       	push	r16
    539e:	1f 93       	push	r17
    53a0:	cf 93       	push	r28
    53a2:	df 93       	push	r29
    53a4:	84 2e       	mov	r8, r20
    53a6:	a5 2e       	mov	r10, r21
    53a8:	c6 2e       	mov	r12, r22
    53aa:	c7 2f       	mov	r28, r23
    53ac:	d2 2f       	mov	r29, r18
    53ae:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    53b0:	80 64       	ori	r24, 0x40	; 64
    53b2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    53b6:	8c 2f       	mov	r24, r28
    53b8:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    53bc:	8c 2d       	mov	r24, r12
    53be:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    53c2:	8a 2d       	mov	r24, r10
    53c4:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    53c8:	88 2d       	mov	r24, r8
    53ca:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(crc);
    53ce:	8d 2f       	mov	r24, r29
    53d0:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	
	for(int i=0; i<read; i++){
    53d4:	10 16       	cp	r1, r16
    53d6:	11 06       	cpc	r1, r17
    53d8:	64 f5       	brge	.+88     	; 0x5432 <SD_command+0xa6>
    53da:	00 e0       	ldi	r16, 0x00	; 0
    53dc:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    53de:	0f 2e       	mov	r0, r31
    53e0:	fd e0       	ldi	r31, 0x0D	; 13
    53e2:	cf 2e       	mov	r12, r31
    53e4:	dd 24       	eor	r13, r13
    53e6:	f0 2d       	mov	r31, r0
    53e8:	0f 2e       	mov	r0, r31
    53ea:	f9 e3       	ldi	r31, 0x39	; 57
    53ec:	af 2e       	mov	r10, r31
    53ee:	fe e3       	ldi	r31, 0x3E	; 62
    53f0:	bf 2e       	mov	r11, r31
    53f2:	f0 2d       	mov	r31, r0
    53f4:	c8 01       	movw	r24, r16
    53f6:	b6 01       	movw	r22, r12
    53f8:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    53fc:	ec 01       	movw	r28, r24
    53fe:	8f ef       	ldi	r24, 0xFF	; 255
    5400:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5404:	f5 01       	movw	r30, r10
    5406:	ec 0f       	add	r30, r28
    5408:	fd 1f       	adc	r31, r29
    540a:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    540c:	80 81       	ld	r24, Z
    540e:	8f 3f       	cpi	r24, 0xFF	; 255
    5410:	49 f0       	breq	.+18     	; 0x5424 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    5412:	fe 01       	movw	r30, r28
    5414:	e7 5c       	subi	r30, 0xC7	; 199
    5416:	f1 4c       	sbci	r31, 0xC1	; 193
    5418:	80 81       	ld	r24, Z
    541a:	80 93 3a 3e 	sts	0x3E3A, r24
			return Buffer[1];
    541e:	80 91 3a 3e 	lds	r24, 0x3E3A
    5422:	08 c0       	rjmp	.+16     	; 0x5434 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    5424:	0f 5f       	subi	r16, 0xFF	; 255
    5426:	1f 4f       	sbci	r17, 0xFF	; 255
    5428:	0e 15       	cp	r16, r14
    542a:	1f 05       	cpc	r17, r15
    542c:	19 f7       	brne	.-58     	; 0x53f4 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    542e:	8f ef       	ldi	r24, 0xFF	; 255
    5430:	01 c0       	rjmp	.+2      	; 0x5434 <SD_command+0xa8>
    5432:	8f ef       	ldi	r24, 0xFF	; 255
}
    5434:	df 91       	pop	r29
    5436:	cf 91       	pop	r28
    5438:	1f 91       	pop	r17
    543a:	0f 91       	pop	r16
    543c:	ff 90       	pop	r15
    543e:	ef 90       	pop	r14
    5440:	df 90       	pop	r13
    5442:	cf 90       	pop	r12
    5444:	bf 90       	pop	r11
    5446:	af 90       	pop	r10
    5448:	9f 90       	pop	r9
    544a:	8f 90       	pop	r8
    544c:	08 95       	ret

0000544e <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    544e:	ff 92       	push	r15
    5450:	0f 93       	push	r16
    5452:	1f 93       	push	r17
    5454:	cf 93       	push	r28
    5456:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    5458:	81 e0       	ldi	r24, 0x01	; 1
    545a:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    545e:	81 e0       	ldi	r24, 0x01	; 1
    5460:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5464:	8f ef       	ldi	r24, 0xFF	; 255
    5466:	93 ec       	ldi	r25, 0xC3	; 195
    5468:	a9 e0       	ldi	r26, 0x09	; 9
    546a:	81 50       	subi	r24, 0x01	; 1
    546c:	90 40       	sbci	r25, 0x00	; 0
    546e:	a0 40       	sbci	r26, 0x00	; 0
    5470:	e1 f7       	brne	.-8      	; 0x546a <SD_init+0x1c>
    5472:	00 c0       	rjmp	.+0      	; 0x5474 <SD_init+0x26>
    5474:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    5476:	88 e0       	ldi	r24, 0x08	; 8
    5478:	60 e0       	ldi	r22, 0x00	; 0
    547a:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    547e:	88 e0       	ldi	r24, 0x08	; 8
    5480:	60 e0       	ldi	r22, 0x00	; 0
    5482:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5486:	80 e0       	ldi	r24, 0x00	; 0
    5488:	63 e0       	ldi	r22, 0x03	; 3
    548a:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    548e:	81 e0       	ldi	r24, 0x01	; 1
    5490:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
    5494:	8a e0       	ldi	r24, 0x0A	; 10
    5496:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5498:	e0 ec       	ldi	r30, 0xC0	; 192
    549a:	f8 e0       	ldi	r31, 0x08	; 8
    549c:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    549e:	a5 e4       	ldi	r26, 0x45	; 69
    54a0:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    54a2:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    54a4:	22 81       	ldd	r18, Z+2	; 0x02
    54a6:	22 23       	and	r18, r18
    54a8:	ec f7       	brge	.-6      	; 0x54a4 <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    54aa:	23 81       	ldd	r18, Z+3	; 0x03
    54ac:	2c 93       	st	X, r18
    54ae:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    54b0:	c1 f7       	brne	.-16     	; 0x54a2 <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    54b2:	80 e0       	ldi	r24, 0x00	; 0
    54b4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    54b8:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    54bc:	88 e0       	ldi	r24, 0x08	; 8
    54be:	60 e0       	ldi	r22, 0x00	; 0
    54c0:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    54c4:	80 e0       	ldi	r24, 0x00	; 0
    54c6:	63 e0       	ldi	r22, 0x03	; 3
    54c8:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    54cc:	81 e0       	ldi	r24, 0x01	; 1
    54ce:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    54d2:	cb e0       	ldi	r28, 0x0B	; 11
    54d4:	d0 e0       	ldi	r29, 0x00	; 0
    54d6:	02 c0       	rjmp	.+4      	; 0x54dc <SD_init+0x8e>
    54d8:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    54da:	69 f0       	breq	.+26     	; 0x54f6 <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    54dc:	80 e0       	ldi	r24, 0x00	; 0
    54de:	40 e0       	ldi	r20, 0x00	; 0
    54e0:	50 e0       	ldi	r21, 0x00	; 0
    54e2:	ba 01       	movw	r22, r20
    54e4:	25 e9       	ldi	r18, 0x95	; 149
    54e6:	08 e0       	ldi	r16, 0x08	; 8
    54e8:	10 e0       	ldi	r17, 0x00	; 0
    54ea:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
    54ee:	81 30       	cpi	r24, 0x01	; 1
    54f0:	99 f7       	brne	.-26     	; 0x54d8 <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    54f2:	ff 24       	eor	r15, r15
    54f4:	02 c0       	rjmp	.+4      	; 0x54fa <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    54f6:	ff 24       	eor	r15, r15
    54f8:	f3 94       	inc	r15
    54fa:	8f ef       	ldi	r24, 0xFF	; 255
    54fc:	93 ec       	ldi	r25, 0xC3	; 195
    54fe:	a9 e0       	ldi	r26, 0x09	; 9
    5500:	81 50       	subi	r24, 0x01	; 1
    5502:	90 40       	sbci	r25, 0x00	; 0
    5504:	a0 40       	sbci	r26, 0x00	; 0
    5506:	e1 f7       	brne	.-8      	; 0x5500 <SD_init+0xb2>
    5508:	00 c0       	rjmp	.+0      	; 0x550a <SD_init+0xbc>
    550a:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    550c:	cb e0       	ldi	r28, 0x0B	; 11
    550e:	d0 e0       	ldi	r29, 0x00	; 0
    5510:	02 c0       	rjmp	.+4      	; 0x5516 <SD_init+0xc8>
    5512:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5514:	69 f0       	breq	.+26     	; 0x5530 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    5516:	88 e0       	ldi	r24, 0x08	; 8
    5518:	4a ea       	ldi	r20, 0xAA	; 170
    551a:	51 e0       	ldi	r21, 0x01	; 1
    551c:	60 e0       	ldi	r22, 0x00	; 0
    551e:	70 e0       	ldi	r23, 0x00	; 0
    5520:	27 e8       	ldi	r18, 0x87	; 135
    5522:	08 e0       	ldi	r16, 0x08	; 8
    5524:	10 e0       	ldi	r17, 0x00	; 0
    5526:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
    552a:	81 30       	cpi	r24, 0x01	; 1
    552c:	91 f7       	brne	.-28     	; 0x5512 <SD_init+0xc4>
    552e:	02 c0       	rjmp	.+4      	; 0x5534 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5530:	ff 24       	eor	r15, r15
    5532:	f3 94       	inc	r15
    5534:	c2 e0       	ldi	r28, 0x02	; 2
    5536:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    5538:	09 e3       	ldi	r16, 0x39	; 57
    553a:	1e e3       	ldi	r17, 0x3E	; 62
    553c:	8f ef       	ldi	r24, 0xFF	; 255
    553e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5542:	f8 01       	movw	r30, r16
    5544:	ec 0f       	add	r30, r28
    5546:	fd 1f       	adc	r31, r29
    5548:	80 83       	st	Z, r24
    554a:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    554c:	c6 30       	cpi	r28, 0x06	; 6
    554e:	d1 05       	cpc	r29, r1
    5550:	a9 f7       	brne	.-22     	; 0x553c <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    5552:	80 91 3d 3e 	lds	r24, 0x3E3D
    5556:	81 30       	cpi	r24, 0x01	; 1
    5558:	29 f4       	brne	.+10     	; 0x5564 <SD_init+0x116>
    555a:	80 91 3e 3e 	lds	r24, 0x3E3E
    555e:	8a 3a       	cpi	r24, 0xAA	; 170
    5560:	21 f4       	brne	.+8      	; 0x556a <SD_init+0x11c>
    5562:	05 c0       	rjmp	.+10     	; 0x556e <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    5564:	ff 24       	eor	r15, r15
    5566:	f3 94       	inc	r15
    5568:	02 c0       	rjmp	.+4      	; 0x556e <SD_init+0x120>
    556a:	ff 24       	eor	r15, r15
    556c:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    556e:	ca e3       	ldi	r28, 0x3A	; 58
    5570:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    5572:	87 e3       	ldi	r24, 0x37	; 55
    5574:	40 e0       	ldi	r20, 0x00	; 0
    5576:	50 e0       	ldi	r21, 0x00	; 0
    5578:	ba 01       	movw	r22, r20
    557a:	2f ef       	ldi	r18, 0xFF	; 255
    557c:	08 e0       	ldi	r16, 0x08	; 8
    557e:	10 e0       	ldi	r17, 0x00	; 0
    5580:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    5584:	81 e0       	ldi	r24, 0x01	; 1
    5586:	40 e0       	ldi	r20, 0x00	; 0
    5588:	50 e0       	ldi	r21, 0x00	; 0
    558a:	60 e0       	ldi	r22, 0x00	; 0
    558c:	70 e4       	ldi	r23, 0x40	; 64
    558e:	2f ef       	ldi	r18, 0xFF	; 255
    5590:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
	} while(Buffer[1]!= 0x00);	
    5594:	88 81       	ld	r24, Y
    5596:	88 23       	and	r24, r24
    5598:	61 f7       	brne	.-40     	; 0x5572 <SD_init+0x124>
    559a:	cb e0       	ldi	r28, 0x0B	; 11
    559c:	d0 e0       	ldi	r29, 0x00	; 0
    559e:	02 c0       	rjmp	.+4      	; 0x55a4 <SD_init+0x156>
    55a0:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    55a2:	61 f0       	breq	.+24     	; 0x55bc <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    55a4:	8a e3       	ldi	r24, 0x3A	; 58
    55a6:	40 e0       	ldi	r20, 0x00	; 0
    55a8:	50 e0       	ldi	r21, 0x00	; 0
    55aa:	ba 01       	movw	r22, r20
    55ac:	2f ef       	ldi	r18, 0xFF	; 255
    55ae:	08 e0       	ldi	r16, 0x08	; 8
    55b0:	10 e0       	ldi	r17, 0x00	; 0
    55b2:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
    55b6:	88 23       	and	r24, r24
    55b8:	99 f7       	brne	.-26     	; 0x55a0 <SD_init+0x152>
    55ba:	02 c0       	rjmp	.+4      	; 0x55c0 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    55bc:	ff 24       	eor	r15, r15
    55be:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    55c0:	c0 e0       	ldi	r28, 0x00	; 0
    55c2:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    55c4:	09 e3       	ldi	r16, 0x39	; 57
    55c6:	1e e3       	ldi	r17, 0x3E	; 62
    55c8:	8f ef       	ldi	r24, 0xFF	; 255
    55ca:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    55ce:	f8 01       	movw	r30, r16
    55d0:	ec 0f       	add	r30, r28
    55d2:	fd 1f       	adc	r31, r29
    55d4:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    55d6:	21 96       	adiw	r28, 0x01	; 1
    55d8:	c4 30       	cpi	r28, 0x04	; 4
    55da:	d1 05       	cpc	r29, r1
    55dc:	a9 f7       	brne	.-22     	; 0x55c8 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    55de:	80 91 39 3e 	lds	r24, 0x3E39
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    55e2:	80 e0       	ldi	r24, 0x00	; 0
    55e4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    55e8:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    55ec:	88 e0       	ldi	r24, 0x08	; 8
    55ee:	60 e0       	ldi	r22, 0x00	; 0
    55f0:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	return errorCode;					
}
    55f4:	8f 2d       	mov	r24, r15
    55f6:	df 91       	pop	r29
    55f8:	cf 91       	pop	r28
    55fa:	1f 91       	pop	r17
    55fc:	0f 91       	pop	r16
    55fe:	ff 90       	pop	r15
    5600:	08 95       	ret

00005602 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    5602:	6f 92       	push	r6
    5604:	7f 92       	push	r7
    5606:	8f 92       	push	r8
    5608:	9f 92       	push	r9
    560a:	af 92       	push	r10
    560c:	bf 92       	push	r11
    560e:	cf 92       	push	r12
    5610:	df 92       	push	r13
    5612:	ef 92       	push	r14
    5614:	ff 92       	push	r15
    5616:	0f 93       	push	r16
    5618:	1f 93       	push	r17
    561a:	cf 93       	push	r28
    561c:	df 93       	push	r29
    561e:	4b 01       	movw	r8, r22
    5620:	5c 01       	movw	r10, r24
    5622:	74 2e       	mov	r7, r20
    5624:	65 2e       	mov	r6, r21
    5626:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5628:	88 e0       	ldi	r24, 0x08	; 8
    562a:	60 e0       	ldi	r22, 0x00	; 0
    562c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5630:	80 e0       	ldi	r24, 0x00	; 0
    5632:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5636:	81 e0       	ldi	r24, 0x01	; 1
    5638:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    563c:	80 e0       	ldi	r24, 0x00	; 0
    563e:	92 e0       	ldi	r25, 0x02	; 2
    5640:	7c 01       	movw	r14, r24
    5642:	ec 18       	sub	r14, r12
    5644:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5646:	80 e0       	ldi	r24, 0x00	; 0
    5648:	e8 16       	cp	r14, r24
    564a:	82 e0       	ldi	r24, 0x02	; 2
    564c:	f8 06       	cpc	r15, r24
    564e:	11 f4       	brne	.+4      	; 0x5654 <SD_write_block+0x52>
    5650:	ee 24       	eor	r14, r14
    5652:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5654:	cb e0       	ldi	r28, 0x0B	; 11
    5656:	d0 e0       	ldi	r29, 0x00	; 0
    5658:	03 c0       	rjmp	.+6      	; 0x5660 <SD_write_block+0x5e>
    565a:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    565c:	09 f4       	brne	.+2      	; 0x5660 <SD_write_block+0x5e>
    565e:	ff cf       	rjmp	.-2      	; 0x565e <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    5660:	88 e1       	ldi	r24, 0x18	; 24
    5662:	b5 01       	movw	r22, r10
    5664:	a4 01       	movw	r20, r8
    5666:	2f ef       	ldi	r18, 0xFF	; 255
    5668:	08 e0       	ldi	r16, 0x08	; 8
    566a:	10 e0       	ldi	r17, 0x00	; 0
    566c:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
    5670:	88 23       	and	r24, r24
    5672:	99 f7       	brne	.-26     	; 0x565a <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    5674:	8f ef       	ldi	r24, 0xFF	; 255
    5676:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    567a:	80 93 39 3e 	sts	0x3E39, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    567e:	8e ef       	ldi	r24, 0xFE	; 254
    5680:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5684:	1c 14       	cp	r1, r12
    5686:	1d 04       	cpc	r1, r13
    5688:	bc f4       	brge	.+46     	; 0x56b8 <SD_write_block+0xb6>
    568a:	87 2c       	mov	r8, r7
    568c:	96 2c       	mov	r9, r6
    568e:	00 e0       	ldi	r16, 0x00	; 0
    5690:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    5692:	c8 01       	movw	r24, r16
    5694:	6d e0       	ldi	r22, 0x0D	; 13
    5696:	70 e0       	ldi	r23, 0x00	; 0
    5698:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    569c:	ec 01       	movw	r28, r24
    569e:	f4 01       	movw	r30, r8
    56a0:	81 91       	ld	r24, Z+
    56a2:	4f 01       	movw	r8, r30
    56a4:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    56a8:	c7 5c       	subi	r28, 0xC7	; 199
    56aa:	d1 4c       	sbci	r29, 0xC1	; 193
    56ac:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    56ae:	0f 5f       	subi	r16, 0xFF	; 255
    56b0:	1f 4f       	sbci	r17, 0xFF	; 255
    56b2:	0c 15       	cp	r16, r12
    56b4:	1d 05       	cpc	r17, r13
    56b6:	69 f7       	brne	.-38     	; 0x5692 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    56b8:	1e 14       	cp	r1, r14
    56ba:	1f 04       	cpc	r1, r15
    56bc:	ec f4       	brge	.+58     	; 0x56f8 <SD_write_block+0xf6>
    56be:	00 e0       	ldi	r16, 0x00	; 0
    56c0:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    56c2:	0f 2e       	mov	r0, r31
    56c4:	fd e0       	ldi	r31, 0x0D	; 13
    56c6:	cf 2e       	mov	r12, r31
    56c8:	dd 24       	eor	r13, r13
    56ca:	f0 2d       	mov	r31, r0
    56cc:	0f 2e       	mov	r0, r31
    56ce:	f9 e3       	ldi	r31, 0x39	; 57
    56d0:	8f 2e       	mov	r8, r31
    56d2:	fe e3       	ldi	r31, 0x3E	; 62
    56d4:	9f 2e       	mov	r9, r31
    56d6:	f0 2d       	mov	r31, r0
    56d8:	c8 01       	movw	r24, r16
    56da:	b6 01       	movw	r22, r12
    56dc:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    56e0:	ec 01       	movw	r28, r24
    56e2:	80 e0       	ldi	r24, 0x00	; 0
    56e4:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    56e8:	c8 0d       	add	r28, r8
    56ea:	d9 1d       	adc	r29, r9
    56ec:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    56ee:	0f 5f       	subi	r16, 0xFF	; 255
    56f0:	1f 4f       	sbci	r17, 0xFF	; 255
    56f2:	0e 15       	cp	r16, r14
    56f4:	1f 05       	cpc	r17, r15
    56f6:	81 f7       	brne	.-32     	; 0x56d8 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    56f8:	8f ef       	ldi	r24, 0xFF	; 255
    56fa:	80 93 39 3e 	sts	0x3E39, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    56fe:	c0 e0       	ldi	r28, 0x00	; 0
    5700:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    5702:	09 e3       	ldi	r16, 0x39	; 57
    5704:	1e e3       	ldi	r17, 0x3E	; 62
    5706:	8f ef       	ldi	r24, 0xFF	; 255
    5708:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    570c:	f8 01       	movw	r30, r16
    570e:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5710:	21 96       	adiw	r28, 0x01	; 1
    5712:	c2 30       	cpi	r28, 0x02	; 2
    5714:	d1 05       	cpc	r29, r1
    5716:	bc f3       	brlt	.-18     	; 0x5706 <SD_write_block+0x104>
    5718:	80 81       	ld	r24, Z
    571a:	8f 3f       	cpi	r24, 0xFF	; 255
    571c:	a1 f3       	breq	.-24     	; 0x5706 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    571e:	80 91 39 3e 	lds	r24, 0x3E39
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    5722:	80 91 39 3e 	lds	r24, 0x3E39
    5726:	8f 3f       	cpi	r24, 0xFF	; 255
    5728:	49 f0       	breq	.+18     	; 0x573c <SD_write_block+0x13a>
    572a:	c9 e3       	ldi	r28, 0x39	; 57
    572c:	de e3       	ldi	r29, 0x3E	; 62
    572e:	8f ef       	ldi	r24, 0xFF	; 255
    5730:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5734:	88 83       	st	Y, r24
    5736:	88 81       	ld	r24, Y
    5738:	8f 3f       	cpi	r24, 0xFF	; 255
    573a:	c9 f7       	brne	.-14     	; 0x572e <SD_write_block+0x12c>
	SPICS(FALSE);
    573c:	80 e0       	ldi	r24, 0x00	; 0
    573e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5742:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    5746:	88 e0       	ldi	r24, 0x08	; 8
    5748:	60 e0       	ldi	r22, 0x00	; 0
    574a:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    574e:	df 91       	pop	r29
    5750:	cf 91       	pop	r28
    5752:	1f 91       	pop	r17
    5754:	0f 91       	pop	r16
    5756:	ff 90       	pop	r15
    5758:	ef 90       	pop	r14
    575a:	df 90       	pop	r13
    575c:	cf 90       	pop	r12
    575e:	bf 90       	pop	r11
    5760:	af 90       	pop	r10
    5762:	9f 90       	pop	r9
    5764:	8f 90       	pop	r8
    5766:	7f 90       	pop	r7
    5768:	6f 90       	pop	r6
    576a:	08 95       	ret

0000576c <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    576c:	af 92       	push	r10
    576e:	bf 92       	push	r11
    5770:	cf 92       	push	r12
    5772:	df 92       	push	r13
    5774:	ef 92       	push	r14
    5776:	ff 92       	push	r15
    5778:	0f 93       	push	r16
    577a:	1f 93       	push	r17
    577c:	cf 93       	push	r28
    577e:	df 93       	push	r29
    5780:	6b 01       	movw	r12, r22
    5782:	7c 01       	movw	r14, r24
    5784:	b4 2e       	mov	r11, r20
    5786:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5788:	88 e0       	ldi	r24, 0x08	; 8
    578a:	60 e0       	ldi	r22, 0x00	; 0
    578c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5790:	80 e0       	ldi	r24, 0x00	; 0
    5792:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5796:	81 e0       	ldi	r24, 0x01	; 1
    5798:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    579c:	cb e0       	ldi	r28, 0x0B	; 11
    579e:	d0 e0       	ldi	r29, 0x00	; 0
    57a0:	03 c0       	rjmp	.+6      	; 0x57a8 <SD_read_block+0x3c>
    57a2:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    57a4:	09 f4       	brne	.+2      	; 0x57a8 <SD_read_block+0x3c>
    57a6:	ff cf       	rjmp	.-2      	; 0x57a6 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    57a8:	81 e1       	ldi	r24, 0x11	; 17
    57aa:	b7 01       	movw	r22, r14
    57ac:	a6 01       	movw	r20, r12
    57ae:	2f ef       	ldi	r18, 0xFF	; 255
    57b0:	08 e0       	ldi	r16, 0x08	; 8
    57b2:	10 e0       	ldi	r17, 0x00	; 0
    57b4:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
    57b8:	88 23       	and	r24, r24
    57ba:	99 f7       	brne	.-26     	; 0x57a2 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    57bc:	80 91 39 3e 	lds	r24, 0x3E39
    57c0:	8e 3f       	cpi	r24, 0xFE	; 254
    57c2:	49 f0       	breq	.+18     	; 0x57d6 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    57c4:	c9 e3       	ldi	r28, 0x39	; 57
    57c6:	de e3       	ldi	r29, 0x3E	; 62
    57c8:	8f ef       	ldi	r24, 0xFF	; 255
    57ca:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    57ce:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    57d0:	88 81       	ld	r24, Y
    57d2:	8e 3f       	cpi	r24, 0xFE	; 254
    57d4:	c9 f7       	brne	.-14     	; 0x57c8 <SD_read_block+0x5c>
    57d6:	0b 2d       	mov	r16, r11
    57d8:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    57da:	c0 e0       	ldi	r28, 0x00	; 0
    57dc:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    57de:	8f ef       	ldi	r24, 0xFF	; 255
    57e0:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    57e4:	f8 01       	movw	r30, r16
    57e6:	81 93       	st	Z+, r24
    57e8:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    57ea:	21 96       	adiw	r28, 0x01	; 1
    57ec:	f2 e0       	ldi	r31, 0x02	; 2
    57ee:	c0 30       	cpi	r28, 0x00	; 0
    57f0:	df 07       	cpc	r29, r31
    57f2:	a9 f7       	brne	.-22     	; 0x57de <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    57f4:	10 92 45 3e 	sts	0x3E45, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    57f8:	80 91 45 3e 	lds	r24, 0x3E45
    57fc:	8f 3f       	cpi	r24, 0xFF	; 255
    57fe:	49 f0       	breq	.+18     	; 0x5812 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5800:	c5 e4       	ldi	r28, 0x45	; 69
    5802:	de e3       	ldi	r29, 0x3E	; 62
    5804:	8f ef       	ldi	r24, 0xFF	; 255
    5806:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    580a:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    580c:	88 81       	ld	r24, Y
    580e:	8f 3f       	cpi	r24, 0xFF	; 255
    5810:	c9 f7       	brne	.-14     	; 0x5804 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    5812:	80 e0       	ldi	r24, 0x00	; 0
    5814:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5818:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    581c:	88 e0       	ldi	r24, 0x08	; 8
    581e:	60 e0       	ldi	r22, 0x00	; 0
    5820:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5824:	df 91       	pop	r29
    5826:	cf 91       	pop	r28
    5828:	1f 91       	pop	r17
    582a:	0f 91       	pop	r16
    582c:	ff 90       	pop	r15
    582e:	ef 90       	pop	r14
    5830:	df 90       	pop	r13
    5832:	cf 90       	pop	r12
    5834:	bf 90       	pop	r11
    5836:	af 90       	pop	r10
    5838:	08 95       	ret

0000583a <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    583a:	2f 92       	push	r2
    583c:	3f 92       	push	r3
    583e:	4f 92       	push	r4
    5840:	5f 92       	push	r5
    5842:	6f 92       	push	r6
    5844:	7f 92       	push	r7
    5846:	8f 92       	push	r8
    5848:	9f 92       	push	r9
    584a:	af 92       	push	r10
    584c:	bf 92       	push	r11
    584e:	cf 92       	push	r12
    5850:	df 92       	push	r13
    5852:	ef 92       	push	r14
    5854:	ff 92       	push	r15
    5856:	0f 93       	push	r16
    5858:	1f 93       	push	r17
    585a:	cf 93       	push	r28
    585c:	df 93       	push	r29
    585e:	cd b7       	in	r28, 0x3d	; 61
    5860:	de b7       	in	r29, 0x3e	; 62
    5862:	2a 97       	sbiw	r28, 0x0a	; 10
    5864:	cd bf       	out	0x3d, r28	; 61
    5866:	de bf       	out	0x3e, r29	; 62
    5868:	6b 01       	movw	r12, r22
    586a:	7c 01       	movw	r14, r24
    586c:	4f 83       	std	Y+7, r20	; 0x07
    586e:	58 87       	std	Y+8, r21	; 0x08
    5870:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5872:	88 e0       	ldi	r24, 0x08	; 8
    5874:	60 e0       	ldi	r22, 0x00	; 0
    5876:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    587a:	80 e0       	ldi	r24, 0x00	; 0
    587c:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5880:	81 e0       	ldi	r24, 0x01	; 1
    5882:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5886:	c8 01       	movw	r24, r16
    5888:	11 23       	and	r17, r17
    588a:	14 f4       	brge	.+4      	; 0x5890 <SD_write_multiple_blocks+0x56>
    588c:	81 50       	subi	r24, 0x01	; 1
    588e:	9e 4f       	sbci	r25, 0xFE	; 254
    5890:	9c 01       	movw	r18, r24
    5892:	23 2f       	mov	r18, r19
    5894:	33 0f       	add	r19, r19
    5896:	33 0b       	sbc	r19, r19
    5898:	25 95       	asr	r18
    589a:	2b 83       	std	Y+3, r18	; 0x03
    589c:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    589e:	20 e0       	ldi	r18, 0x00	; 0
    58a0:	32 e0       	ldi	r19, 0x02	; 2
    58a2:	c8 01       	movw	r24, r16
    58a4:	b9 01       	movw	r22, r18
    58a6:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    58aa:	29 01       	movw	r4, r18
    58ac:	48 1a       	sub	r4, r24
    58ae:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    58b0:	30 e0       	ldi	r19, 0x00	; 0
    58b2:	43 16       	cp	r4, r19
    58b4:	32 e0       	ldi	r19, 0x02	; 2
    58b6:	53 06       	cpc	r5, r19
    58b8:	31 f0       	breq	.+12     	; 0x58c6 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    58ba:	8b 81       	ldd	r24, Y+3	; 0x03
    58bc:	9c 81       	ldd	r25, Y+4	; 0x04
    58be:	01 96       	adiw	r24, 0x01	; 1
    58c0:	8b 83       	std	Y+3, r24	; 0x03
    58c2:	9c 83       	std	Y+4, r25	; 0x04
    58c4:	02 c0       	rjmp	.+4      	; 0x58ca <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    58c6:	44 24       	eor	r4, r4
    58c8:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    58ca:	89 e1       	ldi	r24, 0x19	; 25
    58cc:	b7 01       	movw	r22, r14
    58ce:	a6 01       	movw	r20, r12
    58d0:	2f ef       	ldi	r18, 0xFF	; 255
    58d2:	08 e0       	ldi	r16, 0x08	; 8
    58d4:	10 e0       	ldi	r17, 0x00	; 0
    58d6:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
    58da:	88 23       	and	r24, r24
    58dc:	b1 f7       	brne	.-20     	; 0x58ca <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    58de:	eb 81       	ldd	r30, Y+3	; 0x03
    58e0:	fc 81       	ldd	r31, Y+4	; 0x04
    58e2:	1e 16       	cp	r1, r30
    58e4:	1f 06       	cpc	r1, r31
    58e6:	0c f0       	brlt	.+2      	; 0x58ea <SD_write_multiple_blocks+0xb0>
    58e8:	ac c0       	rjmp	.+344    	; 0x5a42 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    58ea:	31 97       	sbiw	r30, 0x01	; 1
    58ec:	ed 83       	std	Y+5, r30	; 0x05
    58ee:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    58f0:	9f 01       	movw	r18, r30
    58f2:	32 2f       	mov	r19, r18
    58f4:	22 27       	eor	r18, r18
    58f6:	33 0f       	add	r19, r19
    58f8:	8f 81       	ldd	r24, Y+7	; 0x07
    58fa:	98 85       	ldd	r25, Y+8	; 0x08
    58fc:	89 83       	std	Y+1, r24	; 0x01
    58fe:	9a 83       	std	Y+2, r25	; 0x02
    5900:	66 24       	eor	r6, r6
    5902:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5904:	0f 2e       	mov	r0, r31
    5906:	fa e3       	ldi	r31, 0x3A	; 58
    5908:	8f 2e       	mov	r8, r31
    590a:	fe e3       	ldi	r31, 0x3E	; 62
    590c:	9f 2e       	mov	r9, r31
    590e:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5910:	0f 2e       	mov	r0, r31
    5912:	fc e0       	ldi	r31, 0x0C	; 12
    5914:	cf 2e       	mov	r12, r31
    5916:	dd 24       	eor	r13, r13
    5918:	f0 2d       	mov	r31, r0
    591a:	0f 2e       	mov	r0, r31
    591c:	f9 e3       	ldi	r31, 0x39	; 57
    591e:	af 2e       	mov	r10, r31
    5920:	fe e3       	ldi	r31, 0x3E	; 62
    5922:	bf 2e       	mov	r11, r31
    5924:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5926:	80 e0       	ldi	r24, 0x00	; 0
    5928:	92 e0       	ldi	r25, 0x02	; 2
    592a:	1c 01       	movw	r2, r24
    592c:	24 18       	sub	r2, r4
    592e:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5930:	ef 81       	ldd	r30, Y+7	; 0x07
    5932:	f8 85       	ldd	r31, Y+8	; 0x08
    5934:	e2 0f       	add	r30, r18
    5936:	f3 1f       	adc	r31, r19
    5938:	ef 83       	std	Y+7, r30	; 0x07
    593a:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    593c:	8f ef       	ldi	r24, 0xFF	; 255
    593e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5942:	f4 01       	movw	r30, r8
    5944:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    5946:	8c ef       	ldi	r24, 0xFC	; 252
    5948:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    594c:	f4 01       	movw	r30, r8
    594e:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    5950:	2d 81       	ldd	r18, Y+5	; 0x05
    5952:	3e 81       	ldd	r19, Y+6	; 0x06
    5954:	26 15       	cp	r18, r6
    5956:	37 05       	cpc	r19, r7
    5958:	09 f0       	breq	.+2      	; 0x595c <SD_write_multiple_blocks+0x122>
    595a:	41 c0       	rjmp	.+130    	; 0x59de <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    595c:	12 14       	cp	r1, r2
    595e:	13 04       	cpc	r1, r3
    5960:	cc f4       	brge	.+50     	; 0x5994 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5962:	ef 80       	ldd	r14, Y+7	; 0x07
    5964:	f8 84       	ldd	r15, Y+8	; 0x08
    5966:	00 e0       	ldi	r16, 0x00	; 0
    5968:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    596a:	c8 01       	movw	r24, r16
    596c:	b6 01       	movw	r22, r12
    596e:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    5972:	89 87       	std	Y+9, r24	; 0x09
    5974:	9a 87       	std	Y+10, r25	; 0x0a
    5976:	f7 01       	movw	r30, r14
    5978:	81 91       	ld	r24, Z+
    597a:	7f 01       	movw	r14, r30
    597c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5980:	e9 85       	ldd	r30, Y+9	; 0x09
    5982:	fa 85       	ldd	r31, Y+10	; 0x0a
    5984:	ea 0d       	add	r30, r10
    5986:	fb 1d       	adc	r31, r11
    5988:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    598a:	0f 5f       	subi	r16, 0xFF	; 255
    598c:	1f 4f       	sbci	r17, 0xFF	; 255
    598e:	02 15       	cp	r16, r2
    5990:	13 05       	cpc	r17, r3
    5992:	59 f7       	brne	.-42     	; 0x596a <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5994:	14 14       	cp	r1, r4
    5996:	15 04       	cpc	r1, r5
    5998:	9c f4       	brge	.+38     	; 0x59c0 <SD_write_multiple_blocks+0x186>
    599a:	00 e0       	ldi	r16, 0x00	; 0
    599c:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    599e:	c8 01       	movw	r24, r16
    59a0:	b6 01       	movw	r22, r12
    59a2:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    59a6:	7c 01       	movw	r14, r24
    59a8:	80 e0       	ldi	r24, 0x00	; 0
    59aa:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59ae:	f5 01       	movw	r30, r10
    59b0:	ee 0d       	add	r30, r14
    59b2:	ff 1d       	adc	r31, r15
    59b4:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    59b6:	0f 5f       	subi	r16, 0xFF	; 255
    59b8:	1f 4f       	sbci	r17, 0xFF	; 255
    59ba:	04 15       	cp	r16, r4
    59bc:	15 05       	cpc	r17, r5
    59be:	79 f7       	brne	.-34     	; 0x599e <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    59c0:	8f ef       	ldi	r24, 0xFF	; 255
    59c2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59c6:	f4 01       	movw	r30, r8
    59c8:	80 83       	st	Z, r24
    59ca:	8f ef       	ldi	r24, 0xFF	; 255
    59cc:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59d0:	f4 01       	movw	r30, r8
    59d2:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    59d4:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    59d6:	80 81       	ld	r24, Z
    59d8:	8f 3f       	cpi	r24, 0xFF	; 255
    59da:	e1 f4       	brne	.+56     	; 0x5a14 <SD_write_multiple_blocks+0x1da>
    59dc:	23 c0       	rjmp	.+70     	; 0x5a24 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    59de:	e9 80       	ldd	r14, Y+1	; 0x01
    59e0:	fa 80       	ldd	r15, Y+2	; 0x02
    59e2:	00 e0       	ldi	r16, 0x00	; 0
    59e4:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    59e6:	c8 01       	movw	r24, r16
    59e8:	b6 01       	movw	r22, r12
    59ea:	0e 94 7b 39 	call	0x72f6	; 0x72f6 <__divmodhi4>
    59ee:	89 87       	std	Y+9, r24	; 0x09
    59f0:	9a 87       	std	Y+10, r25	; 0x0a
    59f2:	f7 01       	movw	r30, r14
    59f4:	81 91       	ld	r24, Z+
    59f6:	7f 01       	movw	r14, r30
    59f8:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59fc:	e9 85       	ldd	r30, Y+9	; 0x09
    59fe:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a00:	ea 0d       	add	r30, r10
    5a02:	fb 1d       	adc	r31, r11
    5a04:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5a06:	0f 5f       	subi	r16, 0xFF	; 255
    5a08:	1f 4f       	sbci	r17, 0xFF	; 255
    5a0a:	f2 e0       	ldi	r31, 0x02	; 2
    5a0c:	00 30       	cpi	r16, 0x00	; 0
    5a0e:	1f 07       	cpc	r17, r31
    5a10:	51 f7       	brne	.-44     	; 0x59e6 <SD_write_multiple_blocks+0x1ac>
    5a12:	d6 cf       	rjmp	.-84     	; 0x59c0 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5a14:	8f ef       	ldi	r24, 0xFF	; 255
    5a16:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a1a:	f4 01       	movw	r30, r8
    5a1c:	80 83       	st	Z, r24
    5a1e:	80 81       	ld	r24, Z
    5a20:	8f 3f       	cpi	r24, 0xFF	; 255
    5a22:	c1 f7       	brne	.-16     	; 0x5a14 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    5a24:	08 94       	sec
    5a26:	61 1c       	adc	r6, r1
    5a28:	71 1c       	adc	r7, r1
    5a2a:	29 81       	ldd	r18, Y+1	; 0x01
    5a2c:	3a 81       	ldd	r19, Y+2	; 0x02
    5a2e:	20 50       	subi	r18, 0x00	; 0
    5a30:	3e 4f       	sbci	r19, 0xFE	; 254
    5a32:	29 83       	std	Y+1, r18	; 0x01
    5a34:	3a 83       	std	Y+2, r19	; 0x02
    5a36:	8b 81       	ldd	r24, Y+3	; 0x03
    5a38:	9c 81       	ldd	r25, Y+4	; 0x04
    5a3a:	68 16       	cp	r6, r24
    5a3c:	79 06       	cpc	r7, r25
    5a3e:	09 f0       	breq	.+2      	; 0x5a42 <SD_write_multiple_blocks+0x208>
    5a40:	7d cf       	rjmp	.-262    	; 0x593c <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5a42:	ee 24       	eor	r14, r14
    5a44:	ff 24       	eor	r15, r15
    5a46:	68 94       	set
    5a48:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5a4a:	0a e3       	ldi	r16, 0x3A	; 58
    5a4c:	1e e3       	ldi	r17, 0x3E	; 62
    5a4e:	8f ef       	ldi	r24, 0xFF	; 255
    5a50:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a54:	f8 01       	movw	r30, r16
    5a56:	80 83       	st	Z, r24
    5a58:	08 94       	sec
    5a5a:	e1 08       	sbc	r14, r1
    5a5c:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5a5e:	e1 14       	cp	r14, r1
    5a60:	f1 04       	cpc	r15, r1
    5a62:	a9 f7       	brne	.-22     	; 0x5a4e <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5a64:	8d ef       	ldi	r24, 0xFD	; 253
    5a66:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a6a:	80 93 3a 3e 	sts	0x3E3A, r24
    5a6e:	ee 24       	eor	r14, r14
    5a70:	ff 24       	eor	r15, r15
    5a72:	68 94       	set
    5a74:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5a76:	0a e3       	ldi	r16, 0x3A	; 58
    5a78:	1e e3       	ldi	r17, 0x3E	; 62
    5a7a:	8f ef       	ldi	r24, 0xFF	; 255
    5a7c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a80:	f8 01       	movw	r30, r16
    5a82:	80 83       	st	Z, r24
    5a84:	08 94       	sec
    5a86:	e1 08       	sbc	r14, r1
    5a88:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5a8a:	e1 14       	cp	r14, r1
    5a8c:	f1 04       	cpc	r15, r1
    5a8e:	a9 f7       	brne	.-22     	; 0x5a7a <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5a90:	10 92 3a 3e 	sts	0x3E3A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5a94:	80 91 3a 3e 	lds	r24, 0x3E3A
    5a98:	8f 3f       	cpi	r24, 0xFF	; 255
    5a9a:	51 f0       	breq	.+20     	; 0x5ab0 <SD_write_multiple_blocks+0x276>
    5a9c:	0a e3       	ldi	r16, 0x3A	; 58
    5a9e:	1e e3       	ldi	r17, 0x3E	; 62
    5aa0:	8f ef       	ldi	r24, 0xFF	; 255
    5aa2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5aa6:	f8 01       	movw	r30, r16
    5aa8:	80 83       	st	Z, r24
    5aaa:	80 81       	ld	r24, Z
    5aac:	8f 3f       	cpi	r24, 0xFF	; 255
    5aae:	c1 f7       	brne	.-16     	; 0x5aa0 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5ab0:	80 e0       	ldi	r24, 0x00	; 0
    5ab2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5ab6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5aba:	88 e0       	ldi	r24, 0x08	; 8
    5abc:	60 e0       	ldi	r22, 0x00	; 0
    5abe:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5ac2:	2a 96       	adiw	r28, 0x0a	; 10
    5ac4:	cd bf       	out	0x3d, r28	; 61
    5ac6:	de bf       	out	0x3e, r29	; 62
    5ac8:	df 91       	pop	r29
    5aca:	cf 91       	pop	r28
    5acc:	1f 91       	pop	r17
    5ace:	0f 91       	pop	r16
    5ad0:	ff 90       	pop	r15
    5ad2:	ef 90       	pop	r14
    5ad4:	df 90       	pop	r13
    5ad6:	cf 90       	pop	r12
    5ad8:	bf 90       	pop	r11
    5ada:	af 90       	pop	r10
    5adc:	9f 90       	pop	r9
    5ade:	8f 90       	pop	r8
    5ae0:	7f 90       	pop	r7
    5ae2:	6f 90       	pop	r6
    5ae4:	5f 90       	pop	r5
    5ae6:	4f 90       	pop	r4
    5ae8:	3f 90       	pop	r3
    5aea:	2f 90       	pop	r2
    5aec:	08 95       	ret

00005aee <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5aee:	2f 92       	push	r2
    5af0:	3f 92       	push	r3
    5af2:	4f 92       	push	r4
    5af4:	5f 92       	push	r5
    5af6:	6f 92       	push	r6
    5af8:	7f 92       	push	r7
    5afa:	8f 92       	push	r8
    5afc:	9f 92       	push	r9
    5afe:	af 92       	push	r10
    5b00:	bf 92       	push	r11
    5b02:	cf 92       	push	r12
    5b04:	df 92       	push	r13
    5b06:	ef 92       	push	r14
    5b08:	ff 92       	push	r15
    5b0a:	0f 93       	push	r16
    5b0c:	1f 93       	push	r17
    5b0e:	cf 93       	push	r28
    5b10:	df 93       	push	r29
    5b12:	6b 01       	movw	r12, r22
    5b14:	7c 01       	movw	r14, r24
    5b16:	c4 2f       	mov	r28, r20
    5b18:	85 2e       	mov	r8, r21
    5b1a:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5b1c:	88 e0       	ldi	r24, 0x08	; 8
    5b1e:	60 e0       	ldi	r22, 0x00	; 0
    5b20:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5b24:	80 e0       	ldi	r24, 0x00	; 0
    5b26:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5b2a:	81 e0       	ldi	r24, 0x01	; 1
    5b2c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5b30:	82 e1       	ldi	r24, 0x12	; 18
    5b32:	b7 01       	movw	r22, r14
    5b34:	a6 01       	movw	r20, r12
    5b36:	2f ef       	ldi	r18, 0xFF	; 255
    5b38:	08 e0       	ldi	r16, 0x08	; 8
    5b3a:	10 e0       	ldi	r17, 0x00	; 0
    5b3c:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
    5b40:	88 23       	and	r24, r24
    5b42:	b1 f7       	brne	.-20     	; 0x5b30 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5b44:	16 14       	cp	r1, r6
    5b46:	17 04       	cpc	r1, r7
    5b48:	0c f0       	brlt	.+2      	; 0x5b4c <SD_read_multiple_blocks+0x5e>
    5b4a:	46 c0       	rjmp	.+140    	; 0x5bd8 <SD_read_multiple_blocks+0xea>
    5b4c:	ac 2e       	mov	r10, r28
    5b4e:	b8 2c       	mov	r11, r8
    5b50:	88 24       	eor	r8, r8
    5b52:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5b54:	0f 2e       	mov	r0, r31
    5b56:	fa e3       	ldi	r31, 0x3A	; 58
    5b58:	cf 2e       	mov	r12, r31
    5b5a:	fe e3       	ldi	r31, 0x3E	; 62
    5b5c:	df 2e       	mov	r13, r31
    5b5e:	f0 2d       	mov	r31, r0
    5b60:	ff 24       	eor	r15, r15
    5b62:	fa 94       	dec	r15
    5b64:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5b66:	0f 2e       	mov	r0, r31
    5b68:	f9 e3       	ldi	r31, 0x39	; 57
    5b6a:	4f 2e       	mov	r4, r31
    5b6c:	fe e3       	ldi	r31, 0x3E	; 62
    5b6e:	5f 2e       	mov	r5, r31
    5b70:	f0 2d       	mov	r31, r0
    5b72:	12 01       	movw	r2, r4
    5b74:	08 94       	sec
    5b76:	21 1c       	adc	r2, r1
    5b78:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5b7a:	f6 01       	movw	r30, r12
    5b7c:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5b7e:	80 81       	ld	r24, Z
    5b80:	8e 3f       	cpi	r24, 0xFE	; 254
    5b82:	41 f0       	breq	.+16     	; 0x5b94 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5b84:	8f 2d       	mov	r24, r15
    5b86:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b8a:	f6 01       	movw	r30, r12
    5b8c:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5b8e:	80 81       	ld	r24, Z
    5b90:	8e 3f       	cpi	r24, 0xFE	; 254
    5b92:	c1 f7       	brne	.-16     	; 0x5b84 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5b94:	85 01       	movw	r16, r10
    5b96:	c0 e0       	ldi	r28, 0x00	; 0
    5b98:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5b9a:	8f 2d       	mov	r24, r15
    5b9c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5ba0:	f8 01       	movw	r30, r16
    5ba2:	81 93       	st	Z+, r24
    5ba4:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5ba6:	21 96       	adiw	r28, 0x01	; 1
    5ba8:	f2 e0       	ldi	r31, 0x02	; 2
    5baa:	c0 30       	cpi	r28, 0x00	; 0
    5bac:	df 07       	cpc	r29, r31
    5bae:	a9 f7       	brne	.-22     	; 0x5b9a <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5bb0:	8f 2d       	mov	r24, r15
    5bb2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5bb6:	f2 01       	movw	r30, r4
    5bb8:	80 83       	st	Z, r24
    5bba:	8f 2d       	mov	r24, r15
    5bbc:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5bc0:	f1 01       	movw	r30, r2
    5bc2:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5bc4:	08 94       	sec
    5bc6:	81 1c       	adc	r8, r1
    5bc8:	91 1c       	adc	r9, r1
    5bca:	80 e0       	ldi	r24, 0x00	; 0
    5bcc:	92 e0       	ldi	r25, 0x02	; 2
    5bce:	a8 0e       	add	r10, r24
    5bd0:	b9 1e       	adc	r11, r25
    5bd2:	86 14       	cp	r8, r6
    5bd4:	97 04       	cpc	r9, r7
    5bd6:	89 f6       	brne	.-94     	; 0x5b7a <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5bd8:	8c e0       	ldi	r24, 0x0C	; 12
    5bda:	40 e0       	ldi	r20, 0x00	; 0
    5bdc:	50 e0       	ldi	r21, 0x00	; 0
    5bde:	ba 01       	movw	r22, r20
    5be0:	2f ef       	ldi	r18, 0xFF	; 255
    5be2:	08 e0       	ldi	r16, 0x08	; 8
    5be4:	10 e0       	ldi	r17, 0x00	; 0
    5be6:	0e 94 c6 29 	call	0x538c	; 0x538c <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5bea:	8f ef       	ldi	r24, 0xFF	; 255
    5bec:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5bf0:	80 93 39 3e 	sts	0x3E39, r24
	Buffer[1] = FILLER_BYTE;
    5bf4:	10 92 3a 3e 	sts	0x3E3A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5bf8:	80 91 3a 3e 	lds	r24, 0x3E3A
    5bfc:	8f 3f       	cpi	r24, 0xFF	; 255
    5bfe:	49 f0       	breq	.+18     	; 0x5c12 <SD_read_multiple_blocks+0x124>
    5c00:	ca e3       	ldi	r28, 0x3A	; 58
    5c02:	de e3       	ldi	r29, 0x3E	; 62
    5c04:	8f ef       	ldi	r24, 0xFF	; 255
    5c06:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5c0a:	88 83       	st	Y, r24
    5c0c:	88 81       	ld	r24, Y
    5c0e:	8f 3f       	cpi	r24, 0xFF	; 255
    5c10:	c9 f7       	brne	.-14     	; 0x5c04 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5c12:	80 e0       	ldi	r24, 0x00	; 0
    5c14:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5c18:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5c1c:	88 e0       	ldi	r24, 0x08	; 8
    5c1e:	60 e0       	ldi	r22, 0x00	; 0
    5c20:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5c24:	df 91       	pop	r29
    5c26:	cf 91       	pop	r28
    5c28:	1f 91       	pop	r17
    5c2a:	0f 91       	pop	r16
    5c2c:	ff 90       	pop	r15
    5c2e:	ef 90       	pop	r14
    5c30:	df 90       	pop	r13
    5c32:	cf 90       	pop	r12
    5c34:	bf 90       	pop	r11
    5c36:	af 90       	pop	r10
    5c38:	9f 90       	pop	r9
    5c3a:	8f 90       	pop	r8
    5c3c:	7f 90       	pop	r7
    5c3e:	6f 90       	pop	r6
    5c40:	5f 90       	pop	r5
    5c42:	4f 90       	pop	r4
    5c44:	3f 90       	pop	r3
    5c46:	2f 90       	pop	r2
    5c48:	08 95       	ret

00005c4a <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5c4a:	88 e0       	ldi	r24, 0x08	; 8
    5c4c:	60 e0       	ldi	r22, 0x00	; 0
    5c4e:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5c52:	88 e0       	ldi	r24, 0x08	; 8
    5c54:	60 e0       	ldi	r22, 0x00	; 0
    5c56:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5c5a:	80 e0       	ldi	r24, 0x00	; 0
    5c5c:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5c60:	81 e0       	ldi	r24, 0x01	; 1
    5c62:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5c66:	8f ef       	ldi	r24, 0xFF	; 255
    5c68:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPICS(FALSE);	//stop spi
    5c6c:	80 e0       	ldi	r24, 0x00	; 0
    5c6e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5c72:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5c76:	80 e0       	ldi	r24, 0x00	; 0
    5c78:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5c7c:	80 e0       	ldi	r24, 0x00	; 0
    5c7e:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
}
    5c82:	08 95       	ret

00005c84 <__muldi3>:
    5c84:	a0 e3       	ldi	r26, 0x30	; 48
    5c86:	b0 e0       	ldi	r27, 0x00	; 0
    5c88:	e8 e4       	ldi	r30, 0x48	; 72
    5c8a:	fe e2       	ldi	r31, 0x2E	; 46
    5c8c:	0c 94 e1 39 	jmp	0x73c2	; 0x73c2 <__prologue_saves__+0x4>
    5c90:	29 8f       	std	Y+25, r18	; 0x19
    5c92:	3a 8f       	std	Y+26, r19	; 0x1a
    5c94:	4b 8f       	std	Y+27, r20	; 0x1b
    5c96:	5c 8f       	std	Y+28, r21	; 0x1c
    5c98:	6d 8f       	std	Y+29, r22	; 0x1d
    5c9a:	7e 8f       	std	Y+30, r23	; 0x1e
    5c9c:	8f 8f       	std	Y+31, r24	; 0x1f
    5c9e:	98 a3       	lds	r25, 0x58
    5ca0:	a9 8a       	std	Y+17, r10	; 0x11
    5ca2:	ba 8a       	std	Y+18, r11	; 0x12
    5ca4:	cb 8a       	std	Y+19, r12	; 0x13
    5ca6:	dc 8a       	std	Y+20, r13	; 0x14
    5ca8:	ed 8a       	std	Y+21, r14	; 0x15
    5caa:	fe 8a       	std	Y+22, r15	; 0x16
    5cac:	0f 8b       	std	Y+23, r16	; 0x17
    5cae:	18 8f       	std	Y+24, r17	; 0x18
    5cb0:	09 8d       	ldd	r16, Y+25	; 0x19
    5cb2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5cb4:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5cb6:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5cb8:	09 a3       	lds	r16, 0x59
    5cba:	1a a3       	lds	r17, 0x5a
    5cbc:	2b a3       	lds	r18, 0x5b
    5cbe:	3c a3       	lds	r19, 0x5c
    5cc0:	68 01       	movw	r12, r16
    5cc2:	79 01       	movw	r14, r18
    5cc4:	8f ef       	ldi	r24, 0xFF	; 255
    5cc6:	9f ef       	ldi	r25, 0xFF	; 255
    5cc8:	a0 e0       	ldi	r26, 0x00	; 0
    5cca:	b0 e0       	ldi	r27, 0x00	; 0
    5ccc:	c8 22       	and	r12, r24
    5cce:	d9 22       	and	r13, r25
    5cd0:	ea 22       	and	r14, r26
    5cd2:	fb 22       	and	r15, r27
    5cd4:	89 01       	movw	r16, r18
    5cd6:	22 27       	eor	r18, r18
    5cd8:	33 27       	eor	r19, r19
    5cda:	09 a7       	lds	r16, 0x79
    5cdc:	1a a7       	lds	r17, 0x7a
    5cde:	2b a7       	lds	r18, 0x7b
    5ce0:	3c a7       	lds	r19, 0x7c
    5ce2:	09 89       	ldd	r16, Y+17	; 0x11
    5ce4:	1a 89       	ldd	r17, Y+18	; 0x12
    5ce6:	2b 89       	ldd	r18, Y+19	; 0x13
    5ce8:	3c 89       	ldd	r19, Y+20	; 0x14
    5cea:	0d a3       	lds	r16, 0x5d
    5cec:	1e a3       	lds	r17, 0x5e
    5cee:	2f a3       	lds	r18, 0x5f
    5cf0:	38 a7       	lds	r19, 0x78
    5cf2:	48 01       	movw	r8, r16
    5cf4:	59 01       	movw	r10, r18
    5cf6:	88 22       	and	r8, r24
    5cf8:	99 22       	and	r9, r25
    5cfa:	aa 22       	and	r10, r26
    5cfc:	bb 22       	and	r11, r27
    5cfe:	29 01       	movw	r4, r18
    5d00:	66 24       	eor	r6, r6
    5d02:	77 24       	eor	r7, r7
    5d04:	c5 01       	movw	r24, r10
    5d06:	b4 01       	movw	r22, r8
    5d08:	a7 01       	movw	r20, r14
    5d0a:	96 01       	movw	r18, r12
    5d0c:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    5d10:	6d a7       	lds	r22, 0x7d
    5d12:	7e a7       	lds	r23, 0x7e
    5d14:	8f a7       	lds	r24, 0x7f
    5d16:	98 ab       	sts	0x58, r25
    5d18:	c3 01       	movw	r24, r6
    5d1a:	b2 01       	movw	r22, r4
    5d1c:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    5d20:	6b 01       	movw	r12, r22
    5d22:	7c 01       	movw	r14, r24
    5d24:	c5 01       	movw	r24, r10
    5d26:	b4 01       	movw	r22, r8
    5d28:	29 a5       	lds	r18, 0x69
    5d2a:	3a a5       	lds	r19, 0x6a
    5d2c:	4b a5       	lds	r20, 0x6b
    5d2e:	5c a5       	lds	r21, 0x6c
    5d30:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    5d34:	4b 01       	movw	r8, r22
    5d36:	5c 01       	movw	r10, r24
    5d38:	c3 01       	movw	r24, r6
    5d3a:	b2 01       	movw	r22, r4
    5d3c:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    5d40:	ab 01       	movw	r20, r22
    5d42:	bc 01       	movw	r22, r24
    5d44:	c8 0c       	add	r12, r8
    5d46:	d9 1c       	adc	r13, r9
    5d48:	ea 1c       	adc	r14, r10
    5d4a:	fb 1c       	adc	r15, r11
    5d4c:	0d a5       	lds	r16, 0x6d
    5d4e:	1e a5       	lds	r17, 0x6e
    5d50:	2f a5       	lds	r18, 0x6f
    5d52:	38 a9       	sts	0x48, r19
    5d54:	c9 01       	movw	r24, r18
    5d56:	aa 27       	eor	r26, r26
    5d58:	bb 27       	eor	r27, r27
    5d5a:	c8 0e       	add	r12, r24
    5d5c:	d9 1e       	adc	r13, r25
    5d5e:	ea 1e       	adc	r14, r26
    5d60:	fb 1e       	adc	r15, r27
    5d62:	c8 14       	cp	r12, r8
    5d64:	d9 04       	cpc	r13, r9
    5d66:	ea 04       	cpc	r14, r10
    5d68:	fb 04       	cpc	r15, r11
    5d6a:	20 f4       	brcc	.+8      	; 0x5d74 <__muldi3+0xf0>
    5d6c:	40 50       	subi	r20, 0x00	; 0
    5d6e:	50 40       	sbci	r21, 0x00	; 0
    5d70:	6f 4f       	sbci	r22, 0xFF	; 255
    5d72:	7f 4f       	sbci	r23, 0xFF	; 255
    5d74:	c7 01       	movw	r24, r14
    5d76:	aa 27       	eor	r26, r26
    5d78:	bb 27       	eor	r27, r27
    5d7a:	84 0f       	add	r24, r20
    5d7c:	95 1f       	adc	r25, r21
    5d7e:	a6 1f       	adc	r26, r22
    5d80:	b7 1f       	adc	r27, r23
    5d82:	8d 83       	std	Y+5, r24	; 0x05
    5d84:	9e 83       	std	Y+6, r25	; 0x06
    5d86:	af 83       	std	Y+7, r26	; 0x07
    5d88:	b8 87       	std	Y+8, r27	; 0x08
    5d8a:	76 01       	movw	r14, r12
    5d8c:	dd 24       	eor	r13, r13
    5d8e:	cc 24       	eor	r12, r12
    5d90:	4d a5       	lds	r20, 0x6d
    5d92:	5e a5       	lds	r21, 0x6e
    5d94:	6f a5       	lds	r22, 0x6f
    5d96:	78 a9       	sts	0x48, r23
    5d98:	60 70       	andi	r22, 0x00	; 0
    5d9a:	70 70       	andi	r23, 0x00	; 0
    5d9c:	c4 0e       	add	r12, r20
    5d9e:	d5 1e       	adc	r13, r21
    5da0:	e6 1e       	adc	r14, r22
    5da2:	f7 1e       	adc	r15, r23
    5da4:	c9 82       	std	Y+1, r12	; 0x01
    5da6:	da 82       	std	Y+2, r13	; 0x02
    5da8:	eb 82       	std	Y+3, r14	; 0x03
    5daa:	fc 82       	std	Y+4, r15	; 0x04
    5dac:	1c 2d       	mov	r17, r12
    5dae:	0a 81       	ldd	r16, Y+2	; 0x02
    5db0:	8b 80       	ldd	r8, Y+3	; 0x03
    5db2:	4c 80       	ldd	r4, Y+4	; 0x04
    5db4:	8d 87       	std	Y+13, r24	; 0x0d
    5db6:	8e 81       	ldd	r24, Y+6	; 0x06
    5db8:	8e 87       	std	Y+14, r24	; 0x0e
    5dba:	8f 81       	ldd	r24, Y+7	; 0x07
    5dbc:	8f 87       	std	Y+15, r24	; 0x0f
    5dbe:	88 85       	ldd	r24, Y+8	; 0x08
    5dc0:	88 8b       	std	Y+16, r24	; 0x10
    5dc2:	2d 89       	ldd	r18, Y+21	; 0x15
    5dc4:	3e 89       	ldd	r19, Y+22	; 0x16
    5dc6:	4f 89       	ldd	r20, Y+23	; 0x17
    5dc8:	58 8d       	ldd	r21, Y+24	; 0x18
    5dca:	69 a1       	lds	r22, 0x49
    5dcc:	7a a1       	lds	r23, 0x4a
    5dce:	8b a1       	lds	r24, 0x4b
    5dd0:	9c a1       	lds	r25, 0x4c
    5dd2:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    5dd6:	6b 01       	movw	r12, r22
    5dd8:	7c 01       	movw	r14, r24
    5dda:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5ddc:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5dde:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5de0:	58 a1       	lds	r21, 0x48
    5de2:	6d a1       	lds	r22, 0x4d
    5de4:	7e a1       	lds	r23, 0x4e
    5de6:	8f a1       	lds	r24, 0x4f
    5de8:	98 a5       	lds	r25, 0x68
    5dea:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    5dee:	dc 01       	movw	r26, r24
    5df0:	cb 01       	movw	r24, r22
    5df2:	c8 0e       	add	r12, r24
    5df4:	d9 1e       	adc	r13, r25
    5df6:	ea 1e       	adc	r14, r26
    5df8:	fb 1e       	adc	r15, r27
    5dfa:	8d 85       	ldd	r24, Y+13	; 0x0d
    5dfc:	9e 85       	ldd	r25, Y+14	; 0x0e
    5dfe:	af 85       	ldd	r26, Y+15	; 0x0f
    5e00:	b8 89       	ldd	r27, Y+16	; 0x10
    5e02:	8c 0d       	add	r24, r12
    5e04:	9d 1d       	adc	r25, r13
    5e06:	ae 1d       	adc	r26, r14
    5e08:	bf 1d       	adc	r27, r15
    5e0a:	8d 87       	std	Y+13, r24	; 0x0d
    5e0c:	9e 87       	std	Y+14, r25	; 0x0e
    5e0e:	af 87       	std	Y+15, r26	; 0x0f
    5e10:	b8 8b       	std	Y+16, r27	; 0x10
    5e12:	68 2f       	mov	r22, r24
    5e14:	7e 85       	ldd	r23, Y+14	; 0x0e
    5e16:	21 2f       	mov	r18, r17
    5e18:	30 2f       	mov	r19, r16
    5e1a:	48 2d       	mov	r20, r8
    5e1c:	54 2d       	mov	r21, r4
    5e1e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5e20:	98 89       	ldd	r25, Y+16	; 0x10
    5e22:	e0 96       	adiw	r28, 0x30	; 48
    5e24:	e0 e1       	ldi	r30, 0x10	; 16
    5e26:	0c 94 fa 39 	jmp	0x73f4	; 0x73f4 <__epilogue_restores__+0x4>

00005e2a <__ashldi3>:
    5e2a:	cf 92       	push	r12
    5e2c:	df 92       	push	r13
    5e2e:	ef 92       	push	r14
    5e30:	ff 92       	push	r15
    5e32:	0f 93       	push	r16
    5e34:	cf 93       	push	r28
    5e36:	df 93       	push	r29
    5e38:	cd b7       	in	r28, 0x3d	; 61
    5e3a:	de b7       	in	r29, 0x3e	; 62
    5e3c:	60 97       	sbiw	r28, 0x10	; 16
    5e3e:	cd bf       	out	0x3d, r28	; 61
    5e40:	de bf       	out	0x3e, r29	; 62
    5e42:	00 23       	and	r16, r16
    5e44:	09 f4       	brne	.+2      	; 0x5e48 <__ashldi3+0x1e>
    5e46:	5a c0       	rjmp	.+180    	; 0x5efc <__ashldi3+0xd2>
    5e48:	29 87       	std	Y+9, r18	; 0x09
    5e4a:	3a 87       	std	Y+10, r19	; 0x0a
    5e4c:	4b 87       	std	Y+11, r20	; 0x0b
    5e4e:	5c 87       	std	Y+12, r21	; 0x0c
    5e50:	6d 87       	std	Y+13, r22	; 0x0d
    5e52:	7e 87       	std	Y+14, r23	; 0x0e
    5e54:	8f 87       	std	Y+15, r24	; 0x0f
    5e56:	98 8b       	std	Y+16, r25	; 0x10
    5e58:	80 e2       	ldi	r24, 0x20	; 32
    5e5a:	80 1b       	sub	r24, r16
    5e5c:	49 85       	ldd	r20, Y+9	; 0x09
    5e5e:	5a 85       	ldd	r21, Y+10	; 0x0a
    5e60:	6b 85       	ldd	r22, Y+11	; 0x0b
    5e62:	7c 85       	ldd	r23, Y+12	; 0x0c
    5e64:	18 16       	cp	r1, r24
    5e66:	b4 f0       	brlt	.+44     	; 0x5e94 <__ashldi3+0x6a>
    5e68:	19 82       	std	Y+1, r1	; 0x01
    5e6a:	1a 82       	std	Y+2, r1	; 0x02
    5e6c:	1b 82       	std	Y+3, r1	; 0x03
    5e6e:	1c 82       	std	Y+4, r1	; 0x04
    5e70:	99 27       	eor	r25, r25
    5e72:	87 fd       	sbrc	r24, 7
    5e74:	90 95       	com	r25
    5e76:	90 95       	com	r25
    5e78:	81 95       	neg	r24
    5e7a:	9f 4f       	sbci	r25, 0xFF	; 255
    5e7c:	04 c0       	rjmp	.+8      	; 0x5e86 <__ashldi3+0x5c>
    5e7e:	44 0f       	add	r20, r20
    5e80:	55 1f       	adc	r21, r21
    5e82:	66 1f       	adc	r22, r22
    5e84:	77 1f       	adc	r23, r23
    5e86:	8a 95       	dec	r24
    5e88:	d2 f7       	brpl	.-12     	; 0x5e7e <__ashldi3+0x54>
    5e8a:	4d 83       	std	Y+5, r20	; 0x05
    5e8c:	5e 83       	std	Y+6, r21	; 0x06
    5e8e:	6f 83       	std	Y+7, r22	; 0x07
    5e90:	78 87       	std	Y+8, r23	; 0x08
    5e92:	2c c0       	rjmp	.+88     	; 0x5eec <__ashldi3+0xc2>
    5e94:	6a 01       	movw	r12, r20
    5e96:	7b 01       	movw	r14, r22
    5e98:	00 2e       	mov	r0, r16
    5e9a:	04 c0       	rjmp	.+8      	; 0x5ea4 <__ashldi3+0x7a>
    5e9c:	cc 0c       	add	r12, r12
    5e9e:	dd 1c       	adc	r13, r13
    5ea0:	ee 1c       	adc	r14, r14
    5ea2:	ff 1c       	adc	r15, r15
    5ea4:	0a 94       	dec	r0
    5ea6:	d2 f7       	brpl	.-12     	; 0x5e9c <__ashldi3+0x72>
    5ea8:	c9 82       	std	Y+1, r12	; 0x01
    5eaa:	da 82       	std	Y+2, r13	; 0x02
    5eac:	eb 82       	std	Y+3, r14	; 0x03
    5eae:	fc 82       	std	Y+4, r15	; 0x04
    5eb0:	6a 01       	movw	r12, r20
    5eb2:	7b 01       	movw	r14, r22
    5eb4:	04 c0       	rjmp	.+8      	; 0x5ebe <__ashldi3+0x94>
    5eb6:	f6 94       	lsr	r15
    5eb8:	e7 94       	ror	r14
    5eba:	d7 94       	ror	r13
    5ebc:	c7 94       	ror	r12
    5ebe:	8a 95       	dec	r24
    5ec0:	d2 f7       	brpl	.-12     	; 0x5eb6 <__ashldi3+0x8c>
    5ec2:	d7 01       	movw	r26, r14
    5ec4:	c6 01       	movw	r24, r12
    5ec6:	4d 85       	ldd	r20, Y+13	; 0x0d
    5ec8:	5e 85       	ldd	r21, Y+14	; 0x0e
    5eca:	6f 85       	ldd	r22, Y+15	; 0x0f
    5ecc:	78 89       	ldd	r23, Y+16	; 0x10
    5ece:	04 c0       	rjmp	.+8      	; 0x5ed8 <__ashldi3+0xae>
    5ed0:	44 0f       	add	r20, r20
    5ed2:	55 1f       	adc	r21, r21
    5ed4:	66 1f       	adc	r22, r22
    5ed6:	77 1f       	adc	r23, r23
    5ed8:	0a 95       	dec	r16
    5eda:	d2 f7       	brpl	.-12     	; 0x5ed0 <__ashldi3+0xa6>
    5edc:	84 2b       	or	r24, r20
    5ede:	95 2b       	or	r25, r21
    5ee0:	a6 2b       	or	r26, r22
    5ee2:	b7 2b       	or	r27, r23
    5ee4:	8d 83       	std	Y+5, r24	; 0x05
    5ee6:	9e 83       	std	Y+6, r25	; 0x06
    5ee8:	af 83       	std	Y+7, r26	; 0x07
    5eea:	b8 87       	std	Y+8, r27	; 0x08
    5eec:	29 81       	ldd	r18, Y+1	; 0x01
    5eee:	3a 81       	ldd	r19, Y+2	; 0x02
    5ef0:	4b 81       	ldd	r20, Y+3	; 0x03
    5ef2:	5c 81       	ldd	r21, Y+4	; 0x04
    5ef4:	6d 81       	ldd	r22, Y+5	; 0x05
    5ef6:	7e 81       	ldd	r23, Y+6	; 0x06
    5ef8:	8f 81       	ldd	r24, Y+7	; 0x07
    5efa:	98 85       	ldd	r25, Y+8	; 0x08
    5efc:	60 96       	adiw	r28, 0x10	; 16
    5efe:	cd bf       	out	0x3d, r28	; 61
    5f00:	de bf       	out	0x3e, r29	; 62
    5f02:	df 91       	pop	r29
    5f04:	cf 91       	pop	r28
    5f06:	0f 91       	pop	r16
    5f08:	ff 90       	pop	r15
    5f0a:	ef 90       	pop	r14
    5f0c:	df 90       	pop	r13
    5f0e:	cf 90       	pop	r12
    5f10:	08 95       	ret

00005f12 <__ashrdi3>:
    5f12:	0f 93       	push	r16
    5f14:	cf 93       	push	r28
    5f16:	df 93       	push	r29
    5f18:	cd b7       	in	r28, 0x3d	; 61
    5f1a:	de b7       	in	r29, 0x3e	; 62
    5f1c:	60 97       	sbiw	r28, 0x10	; 16
    5f1e:	cd bf       	out	0x3d, r28	; 61
    5f20:	de bf       	out	0x3e, r29	; 62
    5f22:	00 23       	and	r16, r16
    5f24:	09 f4       	brne	.+2      	; 0x5f28 <__ashrdi3+0x16>
    5f26:	56 c0       	rjmp	.+172    	; 0x5fd4 <__ashrdi3+0xc2>
    5f28:	29 87       	std	Y+9, r18	; 0x09
    5f2a:	3a 87       	std	Y+10, r19	; 0x0a
    5f2c:	4b 87       	std	Y+11, r20	; 0x0b
    5f2e:	5c 87       	std	Y+12, r21	; 0x0c
    5f30:	6d 87       	std	Y+13, r22	; 0x0d
    5f32:	7e 87       	std	Y+14, r23	; 0x0e
    5f34:	8f 87       	std	Y+15, r24	; 0x0f
    5f36:	98 8b       	std	Y+16, r25	; 0x10
    5f38:	20 e2       	ldi	r18, 0x20	; 32
    5f3a:	20 1b       	sub	r18, r16
    5f3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f40:	af 85       	ldd	r26, Y+15	; 0x0f
    5f42:	b8 89       	ldd	r27, Y+16	; 0x10
    5f44:	ac 01       	movw	r20, r24
    5f46:	bd 01       	movw	r22, r26
    5f48:	12 16       	cp	r1, r18
    5f4a:	b4 f0       	brlt	.+44     	; 0x5f78 <__ashrdi3+0x66>
    5f4c:	77 0f       	add	r23, r23
    5f4e:	44 0b       	sbc	r20, r20
    5f50:	54 2f       	mov	r21, r20
    5f52:	ba 01       	movw	r22, r20
    5f54:	4d 83       	std	Y+5, r20	; 0x05
    5f56:	5e 83       	std	Y+6, r21	; 0x06
    5f58:	6f 83       	std	Y+7, r22	; 0x07
    5f5a:	78 87       	std	Y+8, r23	; 0x08
    5f5c:	33 27       	eor	r19, r19
    5f5e:	27 fd       	sbrc	r18, 7
    5f60:	30 95       	com	r19
    5f62:	30 95       	com	r19
    5f64:	21 95       	neg	r18
    5f66:	3f 4f       	sbci	r19, 0xFF	; 255
    5f68:	04 c0       	rjmp	.+8      	; 0x5f72 <__ashrdi3+0x60>
    5f6a:	b5 95       	asr	r27
    5f6c:	a7 95       	ror	r26
    5f6e:	97 95       	ror	r25
    5f70:	87 95       	ror	r24
    5f72:	2a 95       	dec	r18
    5f74:	d2 f7       	brpl	.-12     	; 0x5f6a <__ashrdi3+0x58>
    5f76:	22 c0       	rjmp	.+68     	; 0x5fbc <__ashrdi3+0xaa>
    5f78:	00 2e       	mov	r0, r16
    5f7a:	04 c0       	rjmp	.+8      	; 0x5f84 <__ashrdi3+0x72>
    5f7c:	75 95       	asr	r23
    5f7e:	67 95       	ror	r22
    5f80:	57 95       	ror	r21
    5f82:	47 95       	ror	r20
    5f84:	0a 94       	dec	r0
    5f86:	d2 f7       	brpl	.-12     	; 0x5f7c <__ashrdi3+0x6a>
    5f88:	4d 83       	std	Y+5, r20	; 0x05
    5f8a:	5e 83       	std	Y+6, r21	; 0x06
    5f8c:	6f 83       	std	Y+7, r22	; 0x07
    5f8e:	78 87       	std	Y+8, r23	; 0x08
    5f90:	04 c0       	rjmp	.+8      	; 0x5f9a <__ashrdi3+0x88>
    5f92:	88 0f       	add	r24, r24
    5f94:	99 1f       	adc	r25, r25
    5f96:	aa 1f       	adc	r26, r26
    5f98:	bb 1f       	adc	r27, r27
    5f9a:	2a 95       	dec	r18
    5f9c:	d2 f7       	brpl	.-12     	; 0x5f92 <__ashrdi3+0x80>
    5f9e:	49 85       	ldd	r20, Y+9	; 0x09
    5fa0:	5a 85       	ldd	r21, Y+10	; 0x0a
    5fa2:	6b 85       	ldd	r22, Y+11	; 0x0b
    5fa4:	7c 85       	ldd	r23, Y+12	; 0x0c
    5fa6:	04 c0       	rjmp	.+8      	; 0x5fb0 <__ashrdi3+0x9e>
    5fa8:	76 95       	lsr	r23
    5faa:	67 95       	ror	r22
    5fac:	57 95       	ror	r21
    5fae:	47 95       	ror	r20
    5fb0:	0a 95       	dec	r16
    5fb2:	d2 f7       	brpl	.-12     	; 0x5fa8 <__ashrdi3+0x96>
    5fb4:	84 2b       	or	r24, r20
    5fb6:	95 2b       	or	r25, r21
    5fb8:	a6 2b       	or	r26, r22
    5fba:	b7 2b       	or	r27, r23
    5fbc:	89 83       	std	Y+1, r24	; 0x01
    5fbe:	9a 83       	std	Y+2, r25	; 0x02
    5fc0:	ab 83       	std	Y+3, r26	; 0x03
    5fc2:	bc 83       	std	Y+4, r27	; 0x04
    5fc4:	29 81       	ldd	r18, Y+1	; 0x01
    5fc6:	3a 81       	ldd	r19, Y+2	; 0x02
    5fc8:	4b 81       	ldd	r20, Y+3	; 0x03
    5fca:	5c 81       	ldd	r21, Y+4	; 0x04
    5fcc:	6d 81       	ldd	r22, Y+5	; 0x05
    5fce:	7e 81       	ldd	r23, Y+6	; 0x06
    5fd0:	8f 81       	ldd	r24, Y+7	; 0x07
    5fd2:	98 85       	ldd	r25, Y+8	; 0x08
    5fd4:	60 96       	adiw	r28, 0x10	; 16
    5fd6:	cd bf       	out	0x3d, r28	; 61
    5fd8:	de bf       	out	0x3e, r29	; 62
    5fda:	df 91       	pop	r29
    5fdc:	cf 91       	pop	r28
    5fde:	0f 91       	pop	r16
    5fe0:	08 95       	ret

00005fe2 <__divdi3>:
    5fe2:	a8 e4       	ldi	r26, 0x48	; 72
    5fe4:	b0 e0       	ldi	r27, 0x00	; 0
    5fe6:	e7 ef       	ldi	r30, 0xF7	; 247
    5fe8:	ff e2       	ldi	r31, 0x2F	; 47
    5fea:	0c 94 e0 39 	jmp	0x73c0	; 0x73c0 <__prologue_saves__+0x2>
    5fee:	f5 01       	movw	r30, r10
    5ff0:	29 a3       	lds	r18, 0x59
    5ff2:	3a a3       	lds	r19, 0x5a
    5ff4:	4b a3       	lds	r20, 0x5b
    5ff6:	5c a3       	lds	r21, 0x5c
    5ff8:	6d a3       	lds	r22, 0x5d
    5ffa:	7e a3       	lds	r23, 0x5e
    5ffc:	8f a3       	lds	r24, 0x5f
    5ffe:	98 a7       	lds	r25, 0x78
    6000:	a9 8e       	std	Y+25, r10	; 0x19
    6002:	fa 8f       	std	Y+26, r31	; 0x1a
    6004:	cb 8e       	std	Y+27, r12	; 0x1b
    6006:	dc 8e       	std	Y+28, r13	; 0x1c
    6008:	ed 8e       	std	Y+29, r14	; 0x1d
    600a:	fe 8e       	std	Y+30, r15	; 0x1e
    600c:	0f 8f       	std	Y+31, r16	; 0x1f
    600e:	18 a3       	lds	r17, 0x58
    6010:	8d a0       	lds	r24, 0x8d
    6012:	9e a0       	lds	r25, 0x8e
    6014:	af a0       	lds	r26, 0x8f
    6016:	b8 a4       	lds	r27, 0xa8
    6018:	b7 fe       	sbrs	r11, 7
    601a:	67 c0       	rjmp	.+206    	; 0x60ea <__stack+0xeb>
    601c:	21 95       	neg	r18
    601e:	b1 e0       	ldi	r27, 0x01	; 1
    6020:	12 16       	cp	r1, r18
    6022:	08 f0       	brcs	.+2      	; 0x6026 <__stack+0x27>
    6024:	b0 e0       	ldi	r27, 0x00	; 0
    6026:	31 95       	neg	r19
    6028:	a1 e0       	ldi	r26, 0x01	; 1
    602a:	13 16       	cp	r1, r19
    602c:	08 f0       	brcs	.+2      	; 0x6030 <__stack+0x31>
    602e:	a0 e0       	ldi	r26, 0x00	; 0
    6030:	b3 2e       	mov	r11, r19
    6032:	bb 1a       	sub	r11, r27
    6034:	bb 2d       	mov	r27, r11
    6036:	88 24       	eor	r8, r8
    6038:	83 94       	inc	r8
    603a:	3b 15       	cp	r19, r11
    603c:	08 f0       	brcs	.+2      	; 0x6040 <__stack+0x41>
    603e:	88 24       	eor	r8, r8
    6040:	a8 29       	or	r26, r8
    6042:	41 95       	neg	r20
    6044:	31 e0       	ldi	r19, 0x01	; 1
    6046:	14 16       	cp	r1, r20
    6048:	08 f0       	brcs	.+2      	; 0x604c <__stack+0x4d>
    604a:	30 e0       	ldi	r19, 0x00	; 0
    604c:	b4 2e       	mov	r11, r20
    604e:	ba 1a       	sub	r11, r26
    6050:	ab 2d       	mov	r26, r11
    6052:	88 24       	eor	r8, r8
    6054:	83 94       	inc	r8
    6056:	4b 15       	cp	r20, r11
    6058:	08 f0       	brcs	.+2      	; 0x605c <__stack+0x5d>
    605a:	88 24       	eor	r8, r8
    605c:	38 29       	or	r19, r8
    605e:	51 95       	neg	r21
    6060:	41 e0       	ldi	r20, 0x01	; 1
    6062:	15 16       	cp	r1, r21
    6064:	08 f0       	brcs	.+2      	; 0x6068 <__stack+0x69>
    6066:	40 e0       	ldi	r20, 0x00	; 0
    6068:	45 2e       	mov	r4, r21
    606a:	43 1a       	sub	r4, r19
    606c:	31 e0       	ldi	r19, 0x01	; 1
    606e:	54 15       	cp	r21, r4
    6070:	08 f0       	brcs	.+2      	; 0x6074 <__stack+0x75>
    6072:	30 e0       	ldi	r19, 0x00	; 0
    6074:	43 2b       	or	r20, r19
    6076:	61 95       	neg	r22
    6078:	31 e0       	ldi	r19, 0x01	; 1
    607a:	16 16       	cp	r1, r22
    607c:	08 f0       	brcs	.+2      	; 0x6080 <__stack+0x81>
    607e:	30 e0       	ldi	r19, 0x00	; 0
    6080:	86 2e       	mov	r8, r22
    6082:	84 1a       	sub	r8, r20
    6084:	41 e0       	ldi	r20, 0x01	; 1
    6086:	68 15       	cp	r22, r8
    6088:	08 f0       	brcs	.+2      	; 0x608c <__stack+0x8d>
    608a:	40 e0       	ldi	r20, 0x00	; 0
    608c:	34 2b       	or	r19, r20
    608e:	71 95       	neg	r23
    6090:	41 e0       	ldi	r20, 0x01	; 1
    6092:	17 16       	cp	r1, r23
    6094:	08 f0       	brcs	.+2      	; 0x6098 <__stack+0x99>
    6096:	40 e0       	ldi	r20, 0x00	; 0
    6098:	57 2f       	mov	r21, r23
    609a:	53 1b       	sub	r21, r19
    609c:	31 e0       	ldi	r19, 0x01	; 1
    609e:	75 17       	cp	r23, r21
    60a0:	08 f0       	brcs	.+2      	; 0x60a4 <__stack+0xa5>
    60a2:	30 e0       	ldi	r19, 0x00	; 0
    60a4:	43 2b       	or	r20, r19
    60a6:	81 95       	neg	r24
    60a8:	31 e0       	ldi	r19, 0x01	; 1
    60aa:	18 16       	cp	r1, r24
    60ac:	08 f0       	brcs	.+2      	; 0x60b0 <__stack+0xb1>
    60ae:	30 e0       	ldi	r19, 0x00	; 0
    60b0:	68 2f       	mov	r22, r24
    60b2:	64 1b       	sub	r22, r20
    60b4:	46 2f       	mov	r20, r22
    60b6:	61 e0       	ldi	r22, 0x01	; 1
    60b8:	84 17       	cp	r24, r20
    60ba:	08 f0       	brcs	.+2      	; 0x60be <__stack+0xbf>
    60bc:	60 e0       	ldi	r22, 0x00	; 0
    60be:	36 2b       	or	r19, r22
    60c0:	91 95       	neg	r25
    60c2:	93 1b       	sub	r25, r19
    60c4:	29 a3       	lds	r18, 0x59
    60c6:	ba a3       	lds	r27, 0x5a
    60c8:	ab a3       	lds	r26, 0x5b
    60ca:	4c a2       	lds	r20, 0x9c
    60cc:	8d a2       	lds	r24, 0x9d
    60ce:	5e a3       	lds	r21, 0x5e
    60d0:	4f a3       	lds	r20, 0x5f
    60d2:	98 a7       	lds	r25, 0x78
    60d4:	8f ef       	ldi	r24, 0xFF	; 255
    60d6:	9f ef       	ldi	r25, 0xFF	; 255
    60d8:	af ef       	ldi	r26, 0xFF	; 255
    60da:	bf ef       	ldi	r27, 0xFF	; 255
    60dc:	25 96       	adiw	r28, 0x05	; 5
    60de:	8c af       	sts	0x7c, r24
    60e0:	9d af       	sts	0x7d, r25
    60e2:	ae af       	sts	0x7e, r26
    60e4:	bf af       	sts	0x7f, r27
    60e6:	25 97       	sbiw	r28, 0x05	; 5
    60e8:	06 c0       	rjmp	.+12     	; 0x60f6 <__stack+0xf7>
    60ea:	25 96       	adiw	r28, 0x05	; 5
    60ec:	1c ae       	sts	0xbc, r17
    60ee:	1d ae       	sts	0xbd, r17
    60f0:	1e ae       	sts	0xbe, r17
    60f2:	1f ae       	sts	0xbf, r17
    60f4:	25 97       	sbiw	r28, 0x05	; 5
    60f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    60f8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    60fa:	af 8d       	ldd	r26, Y+31	; 0x1f
    60fc:	b8 a1       	lds	r27, 0x48
    60fe:	b7 ff       	sbrs	r27, 7
    6100:	68 c0       	rjmp	.+208    	; 0x61d2 <__stack+0x1d3>
    6102:	25 96       	adiw	r28, 0x05	; 5
    6104:	2c ad       	sts	0x6c, r18
    6106:	3d ad       	sts	0x6d, r19
    6108:	4e ad       	sts	0x6e, r20
    610a:	5f ad       	sts	0x6f, r21
    610c:	25 97       	sbiw	r28, 0x05	; 5
    610e:	20 95       	com	r18
    6110:	30 95       	com	r19
    6112:	40 95       	com	r20
    6114:	50 95       	com	r21
    6116:	25 96       	adiw	r28, 0x05	; 5
    6118:	2c af       	sts	0x7c, r18
    611a:	3d af       	sts	0x7d, r19
    611c:	4e af       	sts	0x7e, r20
    611e:	5f af       	sts	0x7f, r21
    6120:	25 97       	sbiw	r28, 0x05	; 5
    6122:	e1 95       	neg	r30
    6124:	81 e0       	ldi	r24, 0x01	; 1
    6126:	1e 16       	cp	r1, r30
    6128:	08 f0       	brcs	.+2      	; 0x612c <__stack+0x12d>
    612a:	80 e0       	ldi	r24, 0x00	; 0
    612c:	f1 95       	neg	r31
    612e:	91 e0       	ldi	r25, 0x01	; 1
    6130:	1f 16       	cp	r1, r31
    6132:	08 f0       	brcs	.+2      	; 0x6136 <__stack+0x137>
    6134:	90 e0       	ldi	r25, 0x00	; 0
    6136:	4f 2f       	mov	r20, r31
    6138:	48 1b       	sub	r20, r24
    613a:	81 e0       	ldi	r24, 0x01	; 1
    613c:	f4 17       	cp	r31, r20
    613e:	08 f0       	brcs	.+2      	; 0x6142 <__stack+0x143>
    6140:	80 e0       	ldi	r24, 0x00	; 0
    6142:	98 2b       	or	r25, r24
    6144:	c1 94       	neg	r12
    6146:	81 e0       	ldi	r24, 0x01	; 1
    6148:	1c 14       	cp	r1, r12
    614a:	08 f0       	brcs	.+2      	; 0x614e <__stack+0x14f>
    614c:	80 e0       	ldi	r24, 0x00	; 0
    614e:	6c 2d       	mov	r22, r12
    6150:	69 1b       	sub	r22, r25
    6152:	91 e0       	ldi	r25, 0x01	; 1
    6154:	c6 16       	cp	r12, r22
    6156:	08 f0       	brcs	.+2      	; 0x615a <__stack+0x15b>
    6158:	90 e0       	ldi	r25, 0x00	; 0
    615a:	89 2b       	or	r24, r25
    615c:	d1 94       	neg	r13
    615e:	91 e0       	ldi	r25, 0x01	; 1
    6160:	1d 14       	cp	r1, r13
    6162:	08 f0       	brcs	.+2      	; 0x6166 <__stack+0x167>
    6164:	90 e0       	ldi	r25, 0x00	; 0
    6166:	5d 2d       	mov	r21, r13
    6168:	58 1b       	sub	r21, r24
    616a:	81 e0       	ldi	r24, 0x01	; 1
    616c:	d5 16       	cp	r13, r21
    616e:	08 f0       	brcs	.+2      	; 0x6172 <__stack+0x173>
    6170:	80 e0       	ldi	r24, 0x00	; 0
    6172:	98 2b       	or	r25, r24
    6174:	e1 94       	neg	r14
    6176:	81 e0       	ldi	r24, 0x01	; 1
    6178:	1e 14       	cp	r1, r14
    617a:	08 f0       	brcs	.+2      	; 0x617e <__stack+0x17f>
    617c:	80 e0       	ldi	r24, 0x00	; 0
    617e:	3e 2d       	mov	r19, r14
    6180:	39 1b       	sub	r19, r25
    6182:	91 e0       	ldi	r25, 0x01	; 1
    6184:	e3 16       	cp	r14, r19
    6186:	08 f0       	brcs	.+2      	; 0x618a <__stack+0x18b>
    6188:	90 e0       	ldi	r25, 0x00	; 0
    618a:	89 2b       	or	r24, r25
    618c:	f1 94       	neg	r15
    618e:	91 e0       	ldi	r25, 0x01	; 1
    6190:	1f 14       	cp	r1, r15
    6192:	08 f0       	brcs	.+2      	; 0x6196 <__stack+0x197>
    6194:	90 e0       	ldi	r25, 0x00	; 0
    6196:	2f 2d       	mov	r18, r15
    6198:	28 1b       	sub	r18, r24
    619a:	81 e0       	ldi	r24, 0x01	; 1
    619c:	f2 16       	cp	r15, r18
    619e:	08 f0       	brcs	.+2      	; 0x61a2 <__stack+0x1a3>
    61a0:	80 e0       	ldi	r24, 0x00	; 0
    61a2:	98 2b       	or	r25, r24
    61a4:	01 95       	neg	r16
    61a6:	81 e0       	ldi	r24, 0x01	; 1
    61a8:	10 16       	cp	r1, r16
    61aa:	08 f0       	brcs	.+2      	; 0x61ae <__stack+0x1af>
    61ac:	80 e0       	ldi	r24, 0x00	; 0
    61ae:	70 2f       	mov	r23, r16
    61b0:	79 1b       	sub	r23, r25
    61b2:	97 2f       	mov	r25, r23
    61b4:	71 e0       	ldi	r23, 0x01	; 1
    61b6:	09 17       	cp	r16, r25
    61b8:	08 f0       	brcs	.+2      	; 0x61bc <__stack+0x1bd>
    61ba:	70 e0       	ldi	r23, 0x00	; 0
    61bc:	87 2b       	or	r24, r23
    61be:	11 95       	neg	r17
    61c0:	18 1b       	sub	r17, r24
    61c2:	e9 8f       	std	Y+25, r30	; 0x19
    61c4:	4a 8f       	std	Y+26, r20	; 0x1a
    61c6:	6b 8f       	std	Y+27, r22	; 0x1b
    61c8:	5c 8f       	std	Y+28, r21	; 0x1c
    61ca:	3d 8f       	std	Y+29, r19	; 0x1d
    61cc:	2e 8f       	std	Y+30, r18	; 0x1e
    61ce:	9f 8f       	std	Y+31, r25	; 0x1f
    61d0:	18 a3       	lds	r17, 0x58
    61d2:	79 8d       	ldd	r23, Y+25	; 0x19
    61d4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    61d6:	5b 8d       	ldd	r21, Y+27	; 0x1b
    61d8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    61da:	3d 8d       	ldd	r19, Y+29	; 0x1d
    61dc:	2e 8d       	ldd	r18, Y+30	; 0x1e
    61de:	9f 8d       	ldd	r25, Y+31	; 0x1f
    61e0:	88 a1       	lds	r24, 0x48
    61e2:	e9 a1       	lds	r30, 0x49
    61e4:	e9 8b       	std	Y+17, r30	; 0x11
    61e6:	ea a1       	lds	r30, 0x4a
    61e8:	ea 8b       	std	Y+18, r30	; 0x12
    61ea:	eb a1       	lds	r30, 0x4b
    61ec:	eb 8b       	std	Y+19, r30	; 0x13
    61ee:	ec a1       	lds	r30, 0x4c
    61f0:	ec 8b       	std	Y+20, r30	; 0x14
    61f2:	ed a1       	lds	r30, 0x4d
    61f4:	ed 8b       	std	Y+21, r30	; 0x15
    61f6:	ee a1       	lds	r30, 0x4e
    61f8:	ee 8b       	std	Y+22, r30	; 0x16
    61fa:	ef a1       	lds	r30, 0x4f
    61fc:	ef 8b       	std	Y+23, r30	; 0x17
    61fe:	e8 a5       	lds	r30, 0x68
    6200:	e8 8f       	std	Y+24, r30	; 0x18
    6202:	79 87       	std	Y+9, r23	; 0x09
    6204:	6a 87       	std	Y+10, r22	; 0x0a
    6206:	5b 87       	std	Y+11, r21	; 0x0b
    6208:	4c 87       	std	Y+12, r20	; 0x0c
    620a:	3d 87       	std	Y+13, r19	; 0x0d
    620c:	2e 87       	std	Y+14, r18	; 0x0e
    620e:	9f 87       	std	Y+15, r25	; 0x0f
    6210:	88 8b       	std	Y+16, r24	; 0x10
    6212:	89 84       	ldd	r8, Y+9	; 0x09
    6214:	9a 84       	ldd	r9, Y+10	; 0x0a
    6216:	ab 84       	ldd	r10, Y+11	; 0x0b
    6218:	bc 84       	ldd	r11, Y+12	; 0x0c
    621a:	8d 85       	ldd	r24, Y+13	; 0x0d
    621c:	9e 85       	ldd	r25, Y+14	; 0x0e
    621e:	af 85       	ldd	r26, Y+15	; 0x0f
    6220:	b8 89       	ldd	r27, Y+16	; 0x10
    6222:	e9 88       	ldd	r14, Y+17	; 0x11
    6224:	fa 88       	ldd	r15, Y+18	; 0x12
    6226:	0b 89       	ldd	r16, Y+19	; 0x13
    6228:	1c 89       	ldd	r17, Y+20	; 0x14
    622a:	ed aa       	sts	0x9d, r30
    622c:	fe aa       	sts	0x9e, r31
    622e:	0f ab       	sts	0x5f, r16
    6230:	18 af       	sts	0x78, r17
    6232:	cd 88       	ldd	r12, Y+21	; 0x15
    6234:	de 88       	ldd	r13, Y+22	; 0x16
    6236:	ef 88       	ldd	r14, Y+23	; 0x17
    6238:	f8 8c       	ldd	r15, Y+24	; 0x18
    623a:	00 97       	sbiw	r24, 0x00	; 0
    623c:	a1 05       	cpc	r26, r1
    623e:	b1 05       	cpc	r27, r1
    6240:	09 f0       	breq	.+2      	; 0x6244 <__stack+0x245>
    6242:	bd c3       	rjmp	.+1914   	; 0x69be <__stack+0x9bf>
    6244:	c8 14       	cp	r12, r8
    6246:	d9 04       	cpc	r13, r9
    6248:	ea 04       	cpc	r14, r10
    624a:	fb 04       	cpc	r15, r11
    624c:	08 f0       	brcs	.+2      	; 0x6250 <__stack+0x251>
    624e:	4d c1       	rjmp	.+666    	; 0x64ea <__stack+0x4eb>
    6250:	00 e0       	ldi	r16, 0x00	; 0
    6252:	80 16       	cp	r8, r16
    6254:	00 e0       	ldi	r16, 0x00	; 0
    6256:	90 06       	cpc	r9, r16
    6258:	01 e0       	ldi	r16, 0x01	; 1
    625a:	a0 06       	cpc	r10, r16
    625c:	00 e0       	ldi	r16, 0x00	; 0
    625e:	b0 06       	cpc	r11, r16
    6260:	58 f4       	brcc	.+22     	; 0x6278 <__stack+0x279>
    6262:	1f ef       	ldi	r17, 0xFF	; 255
    6264:	81 16       	cp	r8, r17
    6266:	91 04       	cpc	r9, r1
    6268:	a1 04       	cpc	r10, r1
    626a:	b1 04       	cpc	r11, r1
    626c:	09 f0       	breq	.+2      	; 0x6270 <__stack+0x271>
    626e:	90 f4       	brcc	.+36     	; 0x6294 <__stack+0x295>
    6270:	80 e0       	ldi	r24, 0x00	; 0
    6272:	90 e0       	ldi	r25, 0x00	; 0
    6274:	dc 01       	movw	r26, r24
    6276:	17 c0       	rjmp	.+46     	; 0x62a6 <__stack+0x2a7>
    6278:	20 e0       	ldi	r18, 0x00	; 0
    627a:	82 16       	cp	r8, r18
    627c:	20 e0       	ldi	r18, 0x00	; 0
    627e:	92 06       	cpc	r9, r18
    6280:	20 e0       	ldi	r18, 0x00	; 0
    6282:	a2 06       	cpc	r10, r18
    6284:	21 e0       	ldi	r18, 0x01	; 1
    6286:	b2 06       	cpc	r11, r18
    6288:	50 f4       	brcc	.+20     	; 0x629e <__stack+0x29f>
    628a:	80 e1       	ldi	r24, 0x10	; 16
    628c:	90 e0       	ldi	r25, 0x00	; 0
    628e:	a0 e0       	ldi	r26, 0x00	; 0
    6290:	b0 e0       	ldi	r27, 0x00	; 0
    6292:	09 c0       	rjmp	.+18     	; 0x62a6 <__stack+0x2a7>
    6294:	88 e0       	ldi	r24, 0x08	; 8
    6296:	90 e0       	ldi	r25, 0x00	; 0
    6298:	a0 e0       	ldi	r26, 0x00	; 0
    629a:	b0 e0       	ldi	r27, 0x00	; 0
    629c:	04 c0       	rjmp	.+8      	; 0x62a6 <__stack+0x2a7>
    629e:	88 e1       	ldi	r24, 0x18	; 24
    62a0:	90 e0       	ldi	r25, 0x00	; 0
    62a2:	a0 e0       	ldi	r26, 0x00	; 0
    62a4:	b0 e0       	ldi	r27, 0x00	; 0
    62a6:	b5 01       	movw	r22, r10
    62a8:	a4 01       	movw	r20, r8
    62aa:	08 2e       	mov	r0, r24
    62ac:	04 c0       	rjmp	.+8      	; 0x62b6 <__stack+0x2b7>
    62ae:	76 95       	lsr	r23
    62b0:	67 95       	ror	r22
    62b2:	57 95       	ror	r21
    62b4:	47 95       	ror	r20
    62b6:	0a 94       	dec	r0
    62b8:	d2 f7       	brpl	.-12     	; 0x62ae <__stack+0x2af>
    62ba:	fa 01       	movw	r30, r20
    62bc:	e3 5f       	subi	r30, 0xF3	; 243
    62be:	ff 4d       	sbci	r31, 0xDF	; 223
    62c0:	20 81       	ld	r18, Z
    62c2:	40 e2       	ldi	r20, 0x20	; 32
    62c4:	50 e0       	ldi	r21, 0x00	; 0
    62c6:	60 e0       	ldi	r22, 0x00	; 0
    62c8:	70 e0       	ldi	r23, 0x00	; 0
    62ca:	48 1b       	sub	r20, r24
    62cc:	59 0b       	sbc	r21, r25
    62ce:	6a 0b       	sbc	r22, r26
    62d0:	7b 0b       	sbc	r23, r27
    62d2:	42 1b       	sub	r20, r18
    62d4:	51 09       	sbc	r21, r1
    62d6:	61 09       	sbc	r22, r1
    62d8:	71 09       	sbc	r23, r1
    62da:	41 15       	cp	r20, r1
    62dc:	51 05       	cpc	r21, r1
    62de:	61 05       	cpc	r22, r1
    62e0:	71 05       	cpc	r23, r1
    62e2:	a1 f1       	breq	.+104    	; 0x634c <__stack+0x34d>
    62e4:	04 2e       	mov	r0, r20
    62e6:	04 c0       	rjmp	.+8      	; 0x62f0 <__stack+0x2f1>
    62e8:	88 0c       	add	r8, r8
    62ea:	99 1c       	adc	r9, r9
    62ec:	aa 1c       	adc	r10, r10
    62ee:	bb 1c       	adc	r11, r11
    62f0:	0a 94       	dec	r0
    62f2:	d2 f7       	brpl	.-12     	; 0x62e8 <__stack+0x2e9>
    62f4:	97 01       	movw	r18, r14
    62f6:	86 01       	movw	r16, r12
    62f8:	04 2e       	mov	r0, r20
    62fa:	04 c0       	rjmp	.+8      	; 0x6304 <__stack+0x305>
    62fc:	00 0f       	add	r16, r16
    62fe:	11 1f       	adc	r17, r17
    6300:	22 1f       	adc	r18, r18
    6302:	33 1f       	adc	r19, r19
    6304:	0a 94       	dec	r0
    6306:	d2 f7       	brpl	.-12     	; 0x62fc <__stack+0x2fd>
    6308:	80 e2       	ldi	r24, 0x20	; 32
    630a:	90 e0       	ldi	r25, 0x00	; 0
    630c:	84 1b       	sub	r24, r20
    630e:	95 0b       	sbc	r25, r21
    6310:	cd a8       	sts	0x8d, r28
    6312:	de a8       	sts	0x8e, r29
    6314:	ef a8       	sts	0x8f, r30
    6316:	f8 ac       	sts	0xa8, r31
    6318:	04 c0       	rjmp	.+8      	; 0x6322 <__stack+0x323>
    631a:	f6 94       	lsr	r15
    631c:	e7 94       	ror	r14
    631e:	d7 94       	ror	r13
    6320:	c7 94       	ror	r12
    6322:	8a 95       	dec	r24
    6324:	d2 f7       	brpl	.-12     	; 0x631a <__stack+0x31b>
    6326:	c0 2a       	or	r12, r16
    6328:	d1 2a       	or	r13, r17
    632a:	e2 2a       	or	r14, r18
    632c:	f3 2a       	or	r15, r19
    632e:	0d a9       	sts	0x4d, r16
    6330:	1e a9       	sts	0x4e, r17
    6332:	2f a9       	sts	0x4f, r18
    6334:	38 ad       	sts	0x68, r19
    6336:	04 c0       	rjmp	.+8      	; 0x6340 <__stack+0x341>
    6338:	00 0f       	add	r16, r16
    633a:	11 1f       	adc	r17, r17
    633c:	22 1f       	adc	r18, r18
    633e:	33 1f       	adc	r19, r19
    6340:	4a 95       	dec	r20
    6342:	d2 f7       	brpl	.-12     	; 0x6338 <__stack+0x339>
    6344:	0d ab       	sts	0x5d, r16
    6346:	1e ab       	sts	0x5e, r17
    6348:	2f ab       	sts	0x5f, r18
    634a:	38 af       	sts	0x78, r19
    634c:	25 01       	movw	r4, r10
    634e:	66 24       	eor	r6, r6
    6350:	77 24       	eor	r7, r7
    6352:	95 01       	movw	r18, r10
    6354:	84 01       	movw	r16, r8
    6356:	20 70       	andi	r18, 0x00	; 0
    6358:	30 70       	andi	r19, 0x00	; 0
    635a:	09 ab       	sts	0x59, r16
    635c:	1a ab       	sts	0x5a, r17
    635e:	2b ab       	sts	0x5b, r18
    6360:	3c ab       	sts	0x5c, r19
    6362:	c7 01       	movw	r24, r14
    6364:	b6 01       	movw	r22, r12
    6366:	a3 01       	movw	r20, r6
    6368:	92 01       	movw	r18, r4
    636a:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    636e:	2d a7       	lds	r18, 0x7d
    6370:	3e a7       	lds	r19, 0x7e
    6372:	4f a7       	lds	r20, 0x7f
    6374:	58 ab       	sts	0x58, r21
    6376:	69 a7       	lds	r22, 0x79
    6378:	7a a7       	lds	r23, 0x7a
    637a:	8b a7       	lds	r24, 0x7b
    637c:	9c a7       	lds	r25, 0x7c
    637e:	c7 01       	movw	r24, r14
    6380:	b6 01       	movw	r22, r12
    6382:	a3 01       	movw	r20, r6
    6384:	92 01       	movw	r18, r4
    6386:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    638a:	ca 01       	movw	r24, r20
    638c:	b9 01       	movw	r22, r18
    638e:	29 a9       	sts	0x49, r18
    6390:	3a a9       	sts	0x4a, r19
    6392:	4b a9       	sts	0x4b, r20
    6394:	5c a9       	sts	0x4c, r21
    6396:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    639a:	ab 01       	movw	r20, r22
    639c:	bc 01       	movw	r22, r24
    639e:	09 a5       	lds	r16, 0x69
    63a0:	1a a5       	lds	r17, 0x6a
    63a2:	2b a5       	lds	r18, 0x6b
    63a4:	3c a5       	lds	r19, 0x6c
    63a6:	78 01       	movw	r14, r16
    63a8:	dd 24       	eor	r13, r13
    63aa:	cc 24       	eor	r12, r12
    63ac:	0d a9       	sts	0x4d, r16
    63ae:	1e a9       	sts	0x4e, r17
    63b0:	2f a9       	sts	0x4f, r18
    63b2:	38 ad       	sts	0x68, r19
    63b4:	c9 01       	movw	r24, r18
    63b6:	aa 27       	eor	r26, r26
    63b8:	bb 27       	eor	r27, r27
    63ba:	c8 2a       	or	r12, r24
    63bc:	d9 2a       	or	r13, r25
    63be:	ea 2a       	or	r14, r26
    63c0:	fb 2a       	or	r15, r27
    63c2:	0d a5       	lds	r16, 0x6d
    63c4:	1e a5       	lds	r17, 0x6e
    63c6:	2f a5       	lds	r18, 0x6f
    63c8:	38 a9       	sts	0x48, r19
    63ca:	c4 16       	cp	r12, r20
    63cc:	d5 06       	cpc	r13, r21
    63ce:	e6 06       	cpc	r14, r22
    63d0:	f7 06       	cpc	r15, r23
    63d2:	38 f5       	brcc	.+78     	; 0x6422 <__stack+0x423>
    63d4:	01 50       	subi	r16, 0x01	; 1
    63d6:	10 40       	sbci	r17, 0x00	; 0
    63d8:	20 40       	sbci	r18, 0x00	; 0
    63da:	30 40       	sbci	r19, 0x00	; 0
    63dc:	09 a7       	lds	r16, 0x79
    63de:	1a a7       	lds	r17, 0x7a
    63e0:	2b a7       	lds	r18, 0x7b
    63e2:	3c a7       	lds	r19, 0x7c
    63e4:	c8 0c       	add	r12, r8
    63e6:	d9 1c       	adc	r13, r9
    63e8:	ea 1c       	adc	r14, r10
    63ea:	fb 1c       	adc	r15, r11
    63ec:	c8 14       	cp	r12, r8
    63ee:	d9 04       	cpc	r13, r9
    63f0:	ea 04       	cpc	r14, r10
    63f2:	fb 04       	cpc	r15, r11
    63f4:	d0 f0       	brcs	.+52     	; 0x642a <__stack+0x42b>
    63f6:	c4 16       	cp	r12, r20
    63f8:	d5 06       	cpc	r13, r21
    63fa:	e6 06       	cpc	r14, r22
    63fc:	f7 06       	cpc	r15, r23
    63fe:	a8 f4       	brcc	.+42     	; 0x642a <__stack+0x42b>
    6400:	0d a5       	lds	r16, 0x6d
    6402:	1e a5       	lds	r17, 0x6e
    6404:	2f a5       	lds	r18, 0x6f
    6406:	38 a9       	sts	0x48, r19
    6408:	02 50       	subi	r16, 0x02	; 2
    640a:	10 40       	sbci	r17, 0x00	; 0
    640c:	20 40       	sbci	r18, 0x00	; 0
    640e:	30 40       	sbci	r19, 0x00	; 0
    6410:	09 a7       	lds	r16, 0x79
    6412:	1a a7       	lds	r17, 0x7a
    6414:	2b a7       	lds	r18, 0x7b
    6416:	3c a7       	lds	r19, 0x7c
    6418:	c8 0c       	add	r12, r8
    641a:	d9 1c       	adc	r13, r9
    641c:	ea 1c       	adc	r14, r10
    641e:	fb 1c       	adc	r15, r11
    6420:	04 c0       	rjmp	.+8      	; 0x642a <__stack+0x42b>
    6422:	09 a7       	lds	r16, 0x79
    6424:	1a a7       	lds	r17, 0x7a
    6426:	2b a7       	lds	r18, 0x7b
    6428:	3c a7       	lds	r19, 0x7c
    642a:	c4 1a       	sub	r12, r20
    642c:	d5 0a       	sbc	r13, r21
    642e:	e6 0a       	sbc	r14, r22
    6430:	f7 0a       	sbc	r15, r23
    6432:	c7 01       	movw	r24, r14
    6434:	b6 01       	movw	r22, r12
    6436:	a3 01       	movw	r20, r6
    6438:	92 01       	movw	r18, r4
    643a:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    643e:	2d a7       	lds	r18, 0x7d
    6440:	3e a7       	lds	r19, 0x7e
    6442:	4f a7       	lds	r20, 0x7f
    6444:	58 ab       	sts	0x58, r21
    6446:	69 af       	sts	0x79, r22
    6448:	7a af       	sts	0x7a, r23
    644a:	8b af       	sts	0x7b, r24
    644c:	9c af       	sts	0x7c, r25
    644e:	c7 01       	movw	r24, r14
    6450:	b6 01       	movw	r22, r12
    6452:	a3 01       	movw	r20, r6
    6454:	92 01       	movw	r18, r4
    6456:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    645a:	ca 01       	movw	r24, r20
    645c:	b9 01       	movw	r22, r18
    645e:	29 a9       	sts	0x49, r18
    6460:	3a a9       	sts	0x4a, r19
    6462:	4b a9       	sts	0x4b, r20
    6464:	5c a9       	sts	0x4c, r21
    6466:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    646a:	6b 01       	movw	r12, r22
    646c:	7c 01       	movw	r14, r24
    646e:	49 ad       	sts	0x69, r20
    6470:	5a ad       	sts	0x6a, r21
    6472:	6b ad       	sts	0x6b, r22
    6474:	7c ad       	sts	0x6c, r23
    6476:	9a 01       	movw	r18, r20
    6478:	11 27       	eor	r17, r17
    647a:	00 27       	eor	r16, r16
    647c:	4d a9       	sts	0x4d, r20
    647e:	5e a9       	sts	0x4e, r21
    6480:	6f a9       	sts	0x4f, r22
    6482:	78 ad       	sts	0x68, r23
    6484:	60 70       	andi	r22, 0x00	; 0
    6486:	70 70       	andi	r23, 0x00	; 0
    6488:	04 2b       	or	r16, r20
    648a:	15 2b       	or	r17, r21
    648c:	26 2b       	or	r18, r22
    648e:	37 2b       	or	r19, r23
    6490:	8d a5       	lds	r24, 0x6d
    6492:	9e a5       	lds	r25, 0x6e
    6494:	af a5       	lds	r26, 0x6f
    6496:	b8 a9       	sts	0x48, r27
    6498:	0c 15       	cp	r16, r12
    649a:	1d 05       	cpc	r17, r13
    649c:	2e 05       	cpc	r18, r14
    649e:	3f 05       	cpc	r19, r15
    64a0:	c0 f4       	brcc	.+48     	; 0x64d2 <__stack+0x4d3>
    64a2:	01 97       	sbiw	r24, 0x01	; 1
    64a4:	a1 09       	sbc	r26, r1
    64a6:	b1 09       	sbc	r27, r1
    64a8:	08 0d       	add	r16, r8
    64aa:	19 1d       	adc	r17, r9
    64ac:	2a 1d       	adc	r18, r10
    64ae:	3b 1d       	adc	r19, r11
    64b0:	08 15       	cp	r16, r8
    64b2:	19 05       	cpc	r17, r9
    64b4:	2a 05       	cpc	r18, r10
    64b6:	3b 05       	cpc	r19, r11
    64b8:	60 f0       	brcs	.+24     	; 0x64d2 <__stack+0x4d3>
    64ba:	0c 15       	cp	r16, r12
    64bc:	1d 05       	cpc	r17, r13
    64be:	2e 05       	cpc	r18, r14
    64c0:	3f 05       	cpc	r19, r15
    64c2:	38 f4       	brcc	.+14     	; 0x64d2 <__stack+0x4d3>
    64c4:	8d a5       	lds	r24, 0x6d
    64c6:	9e a5       	lds	r25, 0x6e
    64c8:	af a5       	lds	r26, 0x6f
    64ca:	b8 a9       	sts	0x48, r27
    64cc:	02 97       	sbiw	r24, 0x02	; 2
    64ce:	a1 09       	sbc	r26, r1
    64d0:	b1 09       	sbc	r27, r1
    64d2:	09 a5       	lds	r16, 0x69
    64d4:	1a a5       	lds	r17, 0x6a
    64d6:	2b a5       	lds	r18, 0x6b
    64d8:	3c a5       	lds	r19, 0x6c
    64da:	78 01       	movw	r14, r16
    64dc:	dd 24       	eor	r13, r13
    64de:	cc 24       	eor	r12, r12
    64e0:	c8 2a       	or	r12, r24
    64e2:	d9 2a       	or	r13, r25
    64e4:	ea 2a       	or	r14, r26
    64e6:	fb 2a       	or	r15, r27
    64e8:	b7 c4       	rjmp	.+2414   	; 0x6e58 <__stack+0xe59>
    64ea:	81 14       	cp	r8, r1
    64ec:	91 04       	cpc	r9, r1
    64ee:	a1 04       	cpc	r10, r1
    64f0:	b1 04       	cpc	r11, r1
    64f2:	51 f4       	brne	.+20     	; 0x6508 <__stack+0x509>
    64f4:	61 e0       	ldi	r22, 0x01	; 1
    64f6:	70 e0       	ldi	r23, 0x00	; 0
    64f8:	80 e0       	ldi	r24, 0x00	; 0
    64fa:	90 e0       	ldi	r25, 0x00	; 0
    64fc:	a5 01       	movw	r20, r10
    64fe:	94 01       	movw	r18, r8
    6500:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6504:	49 01       	movw	r8, r18
    6506:	5a 01       	movw	r10, r20
    6508:	10 e0       	ldi	r17, 0x00	; 0
    650a:	81 16       	cp	r8, r17
    650c:	10 e0       	ldi	r17, 0x00	; 0
    650e:	91 06       	cpc	r9, r17
    6510:	11 e0       	ldi	r17, 0x01	; 1
    6512:	a1 06       	cpc	r10, r17
    6514:	10 e0       	ldi	r17, 0x00	; 0
    6516:	b1 06       	cpc	r11, r17
    6518:	58 f4       	brcc	.+22     	; 0x6530 <__stack+0x531>
    651a:	2f ef       	ldi	r18, 0xFF	; 255
    651c:	82 16       	cp	r8, r18
    651e:	91 04       	cpc	r9, r1
    6520:	a1 04       	cpc	r10, r1
    6522:	b1 04       	cpc	r11, r1
    6524:	09 f0       	breq	.+2      	; 0x6528 <__stack+0x529>
    6526:	90 f4       	brcc	.+36     	; 0x654c <__stack+0x54d>
    6528:	80 e0       	ldi	r24, 0x00	; 0
    652a:	90 e0       	ldi	r25, 0x00	; 0
    652c:	dc 01       	movw	r26, r24
    652e:	17 c0       	rjmp	.+46     	; 0x655e <__stack+0x55f>
    6530:	30 e0       	ldi	r19, 0x00	; 0
    6532:	83 16       	cp	r8, r19
    6534:	30 e0       	ldi	r19, 0x00	; 0
    6536:	93 06       	cpc	r9, r19
    6538:	30 e0       	ldi	r19, 0x00	; 0
    653a:	a3 06       	cpc	r10, r19
    653c:	31 e0       	ldi	r19, 0x01	; 1
    653e:	b3 06       	cpc	r11, r19
    6540:	50 f4       	brcc	.+20     	; 0x6556 <__stack+0x557>
    6542:	80 e1       	ldi	r24, 0x10	; 16
    6544:	90 e0       	ldi	r25, 0x00	; 0
    6546:	a0 e0       	ldi	r26, 0x00	; 0
    6548:	b0 e0       	ldi	r27, 0x00	; 0
    654a:	09 c0       	rjmp	.+18     	; 0x655e <__stack+0x55f>
    654c:	88 e0       	ldi	r24, 0x08	; 8
    654e:	90 e0       	ldi	r25, 0x00	; 0
    6550:	a0 e0       	ldi	r26, 0x00	; 0
    6552:	b0 e0       	ldi	r27, 0x00	; 0
    6554:	04 c0       	rjmp	.+8      	; 0x655e <__stack+0x55f>
    6556:	88 e1       	ldi	r24, 0x18	; 24
    6558:	90 e0       	ldi	r25, 0x00	; 0
    655a:	a0 e0       	ldi	r26, 0x00	; 0
    655c:	b0 e0       	ldi	r27, 0x00	; 0
    655e:	b5 01       	movw	r22, r10
    6560:	a4 01       	movw	r20, r8
    6562:	08 2e       	mov	r0, r24
    6564:	04 c0       	rjmp	.+8      	; 0x656e <__stack+0x56f>
    6566:	76 95       	lsr	r23
    6568:	67 95       	ror	r22
    656a:	57 95       	ror	r21
    656c:	47 95       	ror	r20
    656e:	0a 94       	dec	r0
    6570:	d2 f7       	brpl	.-12     	; 0x6566 <__stack+0x567>
    6572:	fa 01       	movw	r30, r20
    6574:	e3 5f       	subi	r30, 0xF3	; 243
    6576:	ff 4d       	sbci	r31, 0xDF	; 223
    6578:	20 81       	ld	r18, Z
    657a:	ac 01       	movw	r20, r24
    657c:	bd 01       	movw	r22, r26
    657e:	42 0f       	add	r20, r18
    6580:	51 1d       	adc	r21, r1
    6582:	61 1d       	adc	r22, r1
    6584:	71 1d       	adc	r23, r1
    6586:	80 e2       	ldi	r24, 0x20	; 32
    6588:	90 e0       	ldi	r25, 0x00	; 0
    658a:	a0 e0       	ldi	r26, 0x00	; 0
    658c:	b0 e0       	ldi	r27, 0x00	; 0
    658e:	84 1b       	sub	r24, r20
    6590:	95 0b       	sbc	r25, r21
    6592:	a6 0b       	sbc	r26, r22
    6594:	b7 0b       	sbc	r27, r23
    6596:	51 f4       	brne	.+20     	; 0x65ac <__stack+0x5ad>
    6598:	c8 18       	sub	r12, r8
    659a:	d9 08       	sbc	r13, r9
    659c:	ea 08       	sbc	r14, r10
    659e:	fb 08       	sbc	r15, r11
    65a0:	f1 e0       	ldi	r31, 0x01	; 1
    65a2:	4f 2e       	mov	r4, r31
    65a4:	51 2c       	mov	r5, r1
    65a6:	61 2c       	mov	r6, r1
    65a8:	71 2c       	mov	r7, r1
    65aa:	28 c1       	rjmp	.+592    	; 0x67fc <__stack+0x7fd>
    65ac:	08 2e       	mov	r0, r24
    65ae:	04 c0       	rjmp	.+8      	; 0x65b8 <__stack+0x5b9>
    65b0:	88 0c       	add	r8, r8
    65b2:	99 1c       	adc	r9, r9
    65b4:	aa 1c       	adc	r10, r10
    65b6:	bb 1c       	adc	r11, r11
    65b8:	0a 94       	dec	r0
    65ba:	d2 f7       	brpl	.-12     	; 0x65b0 <__stack+0x5b1>
    65bc:	97 01       	movw	r18, r14
    65be:	86 01       	movw	r16, r12
    65c0:	04 2e       	mov	r0, r20
    65c2:	04 c0       	rjmp	.+8      	; 0x65cc <__stack+0x5cd>
    65c4:	36 95       	lsr	r19
    65c6:	27 95       	ror	r18
    65c8:	17 95       	ror	r17
    65ca:	07 95       	ror	r16
    65cc:	0a 94       	dec	r0
    65ce:	d2 f7       	brpl	.-12     	; 0x65c4 <__stack+0x5c5>
    65d0:	09 ab       	sts	0x59, r16
    65d2:	1a ab       	sts	0x5a, r17
    65d4:	2b ab       	sts	0x5b, r18
    65d6:	3c ab       	sts	0x5c, r19
    65d8:	97 01       	movw	r18, r14
    65da:	86 01       	movw	r16, r12
    65dc:	08 2e       	mov	r0, r24
    65de:	04 c0       	rjmp	.+8      	; 0x65e8 <__stack+0x5e9>
    65e0:	00 0f       	add	r16, r16
    65e2:	11 1f       	adc	r17, r17
    65e4:	22 1f       	adc	r18, r18
    65e6:	33 1f       	adc	r19, r19
    65e8:	0a 94       	dec	r0
    65ea:	d2 f7       	brpl	.-12     	; 0x65e0 <__stack+0x5e1>
    65ec:	0d a7       	lds	r16, 0x7d
    65ee:	1e a7       	lds	r17, 0x7e
    65f0:	2f a7       	lds	r18, 0x7f
    65f2:	38 ab       	sts	0x58, r19
    65f4:	ed a8       	sts	0x8d, r30
    65f6:	fe a8       	sts	0x8e, r31
    65f8:	0f a9       	sts	0x4f, r16
    65fa:	18 ad       	sts	0x68, r17
    65fc:	04 c0       	rjmp	.+8      	; 0x6606 <__stack+0x607>
    65fe:	16 95       	lsr	r17
    6600:	07 95       	ror	r16
    6602:	f7 94       	ror	r15
    6604:	e7 94       	ror	r14
    6606:	4a 95       	dec	r20
    6608:	d2 f7       	brpl	.-12     	; 0x65fe <__stack+0x5ff>
    660a:	b8 01       	movw	r22, r16
    660c:	a7 01       	movw	r20, r14
    660e:	0d a5       	lds	r16, 0x6d
    6610:	1e a5       	lds	r17, 0x6e
    6612:	2f a5       	lds	r18, 0x6f
    6614:	38 a9       	sts	0x48, r19
    6616:	04 2b       	or	r16, r20
    6618:	15 2b       	or	r17, r21
    661a:	26 2b       	or	r18, r22
    661c:	37 2b       	or	r19, r23
    661e:	0d a7       	lds	r16, 0x7d
    6620:	1e a7       	lds	r17, 0x7e
    6622:	2f a7       	lds	r18, 0x7f
    6624:	38 ab       	sts	0x58, r19
    6626:	ed a8       	sts	0x8d, r30
    6628:	fe a8       	sts	0x8e, r31
    662a:	0f a9       	sts	0x4f, r16
    662c:	18 ad       	sts	0x68, r17
    662e:	04 c0       	rjmp	.+8      	; 0x6638 <__stack+0x639>
    6630:	ee 0c       	add	r14, r14
    6632:	ff 1c       	adc	r15, r15
    6634:	00 1f       	adc	r16, r16
    6636:	11 1f       	adc	r17, r17
    6638:	8a 95       	dec	r24
    663a:	d2 f7       	brpl	.-12     	; 0x6630 <__stack+0x631>
    663c:	ed aa       	sts	0x9d, r30
    663e:	fe aa       	sts	0x9e, r31
    6640:	0f ab       	sts	0x5f, r16
    6642:	18 af       	sts	0x78, r17
    6644:	25 01       	movw	r4, r10
    6646:	66 24       	eor	r6, r6
    6648:	77 24       	eor	r7, r7
    664a:	95 01       	movw	r18, r10
    664c:	84 01       	movw	r16, r8
    664e:	20 70       	andi	r18, 0x00	; 0
    6650:	30 70       	andi	r19, 0x00	; 0
    6652:	09 af       	sts	0x79, r16
    6654:	1a af       	sts	0x7a, r17
    6656:	2b af       	sts	0x7b, r18
    6658:	3c af       	sts	0x7c, r19
    665a:	69 a9       	sts	0x49, r22
    665c:	7a a9       	sts	0x4a, r23
    665e:	8b a9       	sts	0x4b, r24
    6660:	9c a9       	sts	0x4c, r25
    6662:	a3 01       	movw	r20, r6
    6664:	92 01       	movw	r18, r4
    6666:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    666a:	29 a7       	lds	r18, 0x79
    666c:	3a a7       	lds	r19, 0x7a
    666e:	4b a7       	lds	r20, 0x7b
    6670:	5c a7       	lds	r21, 0x7c
    6672:	6b 01       	movw	r12, r22
    6674:	7c 01       	movw	r14, r24
    6676:	69 a9       	sts	0x49, r22
    6678:	7a a9       	sts	0x4a, r23
    667a:	8b a9       	sts	0x4b, r24
    667c:	9c a9       	sts	0x4c, r25
    667e:	a3 01       	movw	r20, r6
    6680:	92 01       	movw	r18, r4
    6682:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6686:	ca 01       	movw	r24, r20
    6688:	b9 01       	movw	r22, r18
    668a:	29 ad       	sts	0x69, r18
    668c:	3a ad       	sts	0x6a, r19
    668e:	4b ad       	sts	0x6b, r20
    6690:	5c ad       	sts	0x6c, r21
    6692:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6696:	ab 01       	movw	r20, r22
    6698:	bc 01       	movw	r22, r24
    669a:	76 01       	movw	r14, r12
    669c:	dd 24       	eor	r13, r13
    669e:	cc 24       	eor	r12, r12
    66a0:	0d a5       	lds	r16, 0x6d
    66a2:	1e a5       	lds	r17, 0x6e
    66a4:	2f a5       	lds	r18, 0x6f
    66a6:	38 a9       	sts	0x48, r19
    66a8:	c9 01       	movw	r24, r18
    66aa:	aa 27       	eor	r26, r26
    66ac:	bb 27       	eor	r27, r27
    66ae:	c8 2a       	or	r12, r24
    66b0:	d9 2a       	or	r13, r25
    66b2:	ea 2a       	or	r14, r26
    66b4:	fb 2a       	or	r15, r27
    66b6:	09 a5       	lds	r16, 0x69
    66b8:	1a a5       	lds	r17, 0x6a
    66ba:	2b a5       	lds	r18, 0x6b
    66bc:	3c a5       	lds	r19, 0x6c
    66be:	c4 16       	cp	r12, r20
    66c0:	d5 06       	cpc	r13, r21
    66c2:	e6 06       	cpc	r14, r22
    66c4:	f7 06       	cpc	r15, r23
    66c6:	38 f5       	brcc	.+78     	; 0x6716 <__stack+0x717>
    66c8:	01 50       	subi	r16, 0x01	; 1
    66ca:	10 40       	sbci	r17, 0x00	; 0
    66cc:	20 40       	sbci	r18, 0x00	; 0
    66ce:	30 40       	sbci	r19, 0x00	; 0
    66d0:	09 ab       	sts	0x59, r16
    66d2:	1a ab       	sts	0x5a, r17
    66d4:	2b ab       	sts	0x5b, r18
    66d6:	3c ab       	sts	0x5c, r19
    66d8:	c8 0c       	add	r12, r8
    66da:	d9 1c       	adc	r13, r9
    66dc:	ea 1c       	adc	r14, r10
    66de:	fb 1c       	adc	r15, r11
    66e0:	c8 14       	cp	r12, r8
    66e2:	d9 04       	cpc	r13, r9
    66e4:	ea 04       	cpc	r14, r10
    66e6:	fb 04       	cpc	r15, r11
    66e8:	d0 f0       	brcs	.+52     	; 0x671e <__stack+0x71f>
    66ea:	c4 16       	cp	r12, r20
    66ec:	d5 06       	cpc	r13, r21
    66ee:	e6 06       	cpc	r14, r22
    66f0:	f7 06       	cpc	r15, r23
    66f2:	a8 f4       	brcc	.+42     	; 0x671e <__stack+0x71f>
    66f4:	09 a5       	lds	r16, 0x69
    66f6:	1a a5       	lds	r17, 0x6a
    66f8:	2b a5       	lds	r18, 0x6b
    66fa:	3c a5       	lds	r19, 0x6c
    66fc:	02 50       	subi	r16, 0x02	; 2
    66fe:	10 40       	sbci	r17, 0x00	; 0
    6700:	20 40       	sbci	r18, 0x00	; 0
    6702:	30 40       	sbci	r19, 0x00	; 0
    6704:	09 ab       	sts	0x59, r16
    6706:	1a ab       	sts	0x5a, r17
    6708:	2b ab       	sts	0x5b, r18
    670a:	3c ab       	sts	0x5c, r19
    670c:	c8 0c       	add	r12, r8
    670e:	d9 1c       	adc	r13, r9
    6710:	ea 1c       	adc	r14, r10
    6712:	fb 1c       	adc	r15, r11
    6714:	04 c0       	rjmp	.+8      	; 0x671e <__stack+0x71f>
    6716:	09 ab       	sts	0x59, r16
    6718:	1a ab       	sts	0x5a, r17
    671a:	2b ab       	sts	0x5b, r18
    671c:	3c ab       	sts	0x5c, r19
    671e:	c4 1a       	sub	r12, r20
    6720:	d5 0a       	sbc	r13, r21
    6722:	e6 0a       	sbc	r14, r22
    6724:	f7 0a       	sbc	r15, r23
    6726:	c7 01       	movw	r24, r14
    6728:	b6 01       	movw	r22, r12
    672a:	a3 01       	movw	r20, r6
    672c:	92 01       	movw	r18, r4
    672e:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6732:	29 a7       	lds	r18, 0x79
    6734:	3a a7       	lds	r19, 0x7a
    6736:	4b a7       	lds	r20, 0x7b
    6738:	5c a7       	lds	r21, 0x7c
    673a:	21 96       	adiw	r28, 0x01	; 1
    673c:	6c af       	sts	0x7c, r22
    673e:	7d af       	sts	0x7d, r23
    6740:	8e af       	sts	0x7e, r24
    6742:	9f af       	sts	0x7f, r25
    6744:	21 97       	sbiw	r28, 0x01	; 1
    6746:	c7 01       	movw	r24, r14
    6748:	b6 01       	movw	r22, r12
    674a:	a3 01       	movw	r20, r6
    674c:	92 01       	movw	r18, r4
    674e:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6752:	ca 01       	movw	r24, r20
    6754:	b9 01       	movw	r22, r18
    6756:	29 ad       	sts	0x69, r18
    6758:	3a ad       	sts	0x6a, r19
    675a:	4b ad       	sts	0x6b, r20
    675c:	5c ad       	sts	0x6c, r21
    675e:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6762:	8b 01       	movw	r16, r22
    6764:	9c 01       	movw	r18, r24
    6766:	21 96       	adiw	r28, 0x01	; 1
    6768:	4c ad       	sts	0x6c, r20
    676a:	5d ad       	sts	0x6d, r21
    676c:	6e ad       	sts	0x6e, r22
    676e:	7f ad       	sts	0x6f, r23
    6770:	21 97       	sbiw	r28, 0x01	; 1
    6772:	da 01       	movw	r26, r20
    6774:	99 27       	eor	r25, r25
    6776:	88 27       	eor	r24, r24
    6778:	4d a5       	lds	r20, 0x6d
    677a:	5e a5       	lds	r21, 0x6e
    677c:	6f a5       	lds	r22, 0x6f
    677e:	78 a9       	sts	0x48, r23
    6780:	60 70       	andi	r22, 0x00	; 0
    6782:	70 70       	andi	r23, 0x00	; 0
    6784:	84 2b       	or	r24, r20
    6786:	95 2b       	or	r25, r21
    6788:	a6 2b       	or	r26, r22
    678a:	b7 2b       	or	r27, r23
    678c:	49 a5       	lds	r20, 0x69
    678e:	5a a5       	lds	r21, 0x6a
    6790:	6b a5       	lds	r22, 0x6b
    6792:	7c a5       	lds	r23, 0x6c
    6794:	80 17       	cp	r24, r16
    6796:	91 07       	cpc	r25, r17
    6798:	a2 07       	cpc	r26, r18
    679a:	b3 07       	cpc	r27, r19
    679c:	f0 f4       	brcc	.+60     	; 0x67da <__stack+0x7db>
    679e:	41 50       	subi	r20, 0x01	; 1
    67a0:	50 40       	sbci	r21, 0x00	; 0
    67a2:	60 40       	sbci	r22, 0x00	; 0
    67a4:	70 40       	sbci	r23, 0x00	; 0
    67a6:	88 0d       	add	r24, r8
    67a8:	99 1d       	adc	r25, r9
    67aa:	aa 1d       	adc	r26, r10
    67ac:	bb 1d       	adc	r27, r11
    67ae:	88 15       	cp	r24, r8
    67b0:	99 05       	cpc	r25, r9
    67b2:	aa 05       	cpc	r26, r10
    67b4:	bb 05       	cpc	r27, r11
    67b6:	88 f0       	brcs	.+34     	; 0x67da <__stack+0x7db>
    67b8:	80 17       	cp	r24, r16
    67ba:	91 07       	cpc	r25, r17
    67bc:	a2 07       	cpc	r26, r18
    67be:	b3 07       	cpc	r27, r19
    67c0:	60 f4       	brcc	.+24     	; 0x67da <__stack+0x7db>
    67c2:	49 a5       	lds	r20, 0x69
    67c4:	5a a5       	lds	r21, 0x6a
    67c6:	6b a5       	lds	r22, 0x6b
    67c8:	7c a5       	lds	r23, 0x6c
    67ca:	42 50       	subi	r20, 0x02	; 2
    67cc:	50 40       	sbci	r21, 0x00	; 0
    67ce:	60 40       	sbci	r22, 0x00	; 0
    67d0:	70 40       	sbci	r23, 0x00	; 0
    67d2:	88 0d       	add	r24, r8
    67d4:	99 1d       	adc	r25, r9
    67d6:	aa 1d       	adc	r26, r10
    67d8:	bb 1d       	adc	r27, r11
    67da:	6c 01       	movw	r12, r24
    67dc:	7d 01       	movw	r14, r26
    67de:	c0 1a       	sub	r12, r16
    67e0:	d1 0a       	sbc	r13, r17
    67e2:	e2 0a       	sbc	r14, r18
    67e4:	f3 0a       	sbc	r15, r19
    67e6:	09 a9       	sts	0x49, r16
    67e8:	1a a9       	sts	0x4a, r17
    67ea:	2b a9       	sts	0x4b, r18
    67ec:	3c a9       	sts	0x4c, r19
    67ee:	38 01       	movw	r6, r16
    67f0:	55 24       	eor	r5, r5
    67f2:	44 24       	eor	r4, r4
    67f4:	44 2a       	or	r4, r20
    67f6:	55 2a       	or	r5, r21
    67f8:	66 2a       	or	r6, r22
    67fa:	77 2a       	or	r7, r23
    67fc:	85 01       	movw	r16, r10
    67fe:	22 27       	eor	r18, r18
    6800:	33 27       	eor	r19, r19
    6802:	0d a7       	lds	r16, 0x7d
    6804:	1e a7       	lds	r17, 0x7e
    6806:	2f a7       	lds	r18, 0x7f
    6808:	38 ab       	sts	0x58, r19
    680a:	95 01       	movw	r18, r10
    680c:	84 01       	movw	r16, r8
    680e:	20 70       	andi	r18, 0x00	; 0
    6810:	30 70       	andi	r19, 0x00	; 0
    6812:	09 af       	sts	0x79, r16
    6814:	1a af       	sts	0x7a, r17
    6816:	2b af       	sts	0x7b, r18
    6818:	3c af       	sts	0x7c, r19
    681a:	c7 01       	movw	r24, r14
    681c:	b6 01       	movw	r22, r12
    681e:	2d a5       	lds	r18, 0x6d
    6820:	3e a5       	lds	r19, 0x6e
    6822:	4f a5       	lds	r20, 0x6f
    6824:	58 a9       	sts	0x48, r21
    6826:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    682a:	29 a7       	lds	r18, 0x79
    682c:	3a a7       	lds	r19, 0x7a
    682e:	4b a7       	lds	r20, 0x7b
    6830:	5c a7       	lds	r21, 0x7c
    6832:	69 ab       	sts	0x59, r22
    6834:	7a ab       	sts	0x5a, r23
    6836:	8b ab       	sts	0x5b, r24
    6838:	9c ab       	sts	0x5c, r25
    683a:	c7 01       	movw	r24, r14
    683c:	b6 01       	movw	r22, r12
    683e:	2d a5       	lds	r18, 0x6d
    6840:	3e a5       	lds	r19, 0x6e
    6842:	4f a5       	lds	r20, 0x6f
    6844:	58 a9       	sts	0x48, r21
    6846:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    684a:	ca 01       	movw	r24, r20
    684c:	b9 01       	movw	r22, r18
    684e:	29 ad       	sts	0x69, r18
    6850:	3a ad       	sts	0x6a, r19
    6852:	4b ad       	sts	0x6b, r20
    6854:	5c ad       	sts	0x6c, r21
    6856:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    685a:	ab 01       	movw	r20, r22
    685c:	bc 01       	movw	r22, r24
    685e:	09 a9       	sts	0x49, r16
    6860:	1a a9       	sts	0x4a, r17
    6862:	2b a9       	sts	0x4b, r18
    6864:	3c a9       	sts	0x4c, r19
    6866:	78 01       	movw	r14, r16
    6868:	dd 24       	eor	r13, r13
    686a:	cc 24       	eor	r12, r12
    686c:	0d a9       	sts	0x4d, r16
    686e:	1e a9       	sts	0x4e, r17
    6870:	2f a9       	sts	0x4f, r18
    6872:	38 ad       	sts	0x68, r19
    6874:	c9 01       	movw	r24, r18
    6876:	aa 27       	eor	r26, r26
    6878:	bb 27       	eor	r27, r27
    687a:	c8 2a       	or	r12, r24
    687c:	d9 2a       	or	r13, r25
    687e:	ea 2a       	or	r14, r26
    6880:	fb 2a       	or	r15, r27
    6882:	09 a5       	lds	r16, 0x69
    6884:	1a a5       	lds	r17, 0x6a
    6886:	2b a5       	lds	r18, 0x6b
    6888:	3c a5       	lds	r19, 0x6c
    688a:	c4 16       	cp	r12, r20
    688c:	d5 06       	cpc	r13, r21
    688e:	e6 06       	cpc	r14, r22
    6890:	f7 06       	cpc	r15, r23
    6892:	38 f5       	brcc	.+78     	; 0x68e2 <__stack+0x8e3>
    6894:	01 50       	subi	r16, 0x01	; 1
    6896:	10 40       	sbci	r17, 0x00	; 0
    6898:	20 40       	sbci	r18, 0x00	; 0
    689a:	30 40       	sbci	r19, 0x00	; 0
    689c:	09 ab       	sts	0x59, r16
    689e:	1a ab       	sts	0x5a, r17
    68a0:	2b ab       	sts	0x5b, r18
    68a2:	3c ab       	sts	0x5c, r19
    68a4:	c8 0c       	add	r12, r8
    68a6:	d9 1c       	adc	r13, r9
    68a8:	ea 1c       	adc	r14, r10
    68aa:	fb 1c       	adc	r15, r11
    68ac:	c8 14       	cp	r12, r8
    68ae:	d9 04       	cpc	r13, r9
    68b0:	ea 04       	cpc	r14, r10
    68b2:	fb 04       	cpc	r15, r11
    68b4:	d0 f0       	brcs	.+52     	; 0x68ea <__stack+0x8eb>
    68b6:	c4 16       	cp	r12, r20
    68b8:	d5 06       	cpc	r13, r21
    68ba:	e6 06       	cpc	r14, r22
    68bc:	f7 06       	cpc	r15, r23
    68be:	a8 f4       	brcc	.+42     	; 0x68ea <__stack+0x8eb>
    68c0:	09 a5       	lds	r16, 0x69
    68c2:	1a a5       	lds	r17, 0x6a
    68c4:	2b a5       	lds	r18, 0x6b
    68c6:	3c a5       	lds	r19, 0x6c
    68c8:	02 50       	subi	r16, 0x02	; 2
    68ca:	10 40       	sbci	r17, 0x00	; 0
    68cc:	20 40       	sbci	r18, 0x00	; 0
    68ce:	30 40       	sbci	r19, 0x00	; 0
    68d0:	09 ab       	sts	0x59, r16
    68d2:	1a ab       	sts	0x5a, r17
    68d4:	2b ab       	sts	0x5b, r18
    68d6:	3c ab       	sts	0x5c, r19
    68d8:	c8 0c       	add	r12, r8
    68da:	d9 1c       	adc	r13, r9
    68dc:	ea 1c       	adc	r14, r10
    68de:	fb 1c       	adc	r15, r11
    68e0:	04 c0       	rjmp	.+8      	; 0x68ea <__stack+0x8eb>
    68e2:	09 ab       	sts	0x59, r16
    68e4:	1a ab       	sts	0x5a, r17
    68e6:	2b ab       	sts	0x5b, r18
    68e8:	3c ab       	sts	0x5c, r19
    68ea:	c4 1a       	sub	r12, r20
    68ec:	d5 0a       	sbc	r13, r21
    68ee:	e6 0a       	sbc	r14, r22
    68f0:	f7 0a       	sbc	r15, r23
    68f2:	c7 01       	movw	r24, r14
    68f4:	b6 01       	movw	r22, r12
    68f6:	2d a5       	lds	r18, 0x6d
    68f8:	3e a5       	lds	r19, 0x6e
    68fa:	4f a5       	lds	r20, 0x6f
    68fc:	58 a9       	sts	0x48, r21
    68fe:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6902:	29 a7       	lds	r18, 0x79
    6904:	3a a7       	lds	r19, 0x7a
    6906:	4b a7       	lds	r20, 0x7b
    6908:	5c a7       	lds	r21, 0x7c
    690a:	21 96       	adiw	r28, 0x01	; 1
    690c:	6c af       	sts	0x7c, r22
    690e:	7d af       	sts	0x7d, r23
    6910:	8e af       	sts	0x7e, r24
    6912:	9f af       	sts	0x7f, r25
    6914:	21 97       	sbiw	r28, 0x01	; 1
    6916:	c7 01       	movw	r24, r14
    6918:	b6 01       	movw	r22, r12
    691a:	2d a5       	lds	r18, 0x6d
    691c:	3e a5       	lds	r19, 0x6e
    691e:	4f a5       	lds	r20, 0x6f
    6920:	58 a9       	sts	0x48, r21
    6922:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6926:	ca 01       	movw	r24, r20
    6928:	b9 01       	movw	r22, r18
    692a:	29 ad       	sts	0x69, r18
    692c:	3a ad       	sts	0x6a, r19
    692e:	4b ad       	sts	0x6b, r20
    6930:	5c ad       	sts	0x6c, r21
    6932:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6936:	8b 01       	movw	r16, r22
    6938:	9c 01       	movw	r18, r24
    693a:	21 96       	adiw	r28, 0x01	; 1
    693c:	4c ad       	sts	0x6c, r20
    693e:	5d ad       	sts	0x6d, r21
    6940:	6e ad       	sts	0x6e, r22
    6942:	7f ad       	sts	0x6f, r23
    6944:	21 97       	sbiw	r28, 0x01	; 1
    6946:	da 01       	movw	r26, r20
    6948:	99 27       	eor	r25, r25
    694a:	88 27       	eor	r24, r24
    694c:	4d a9       	sts	0x4d, r20
    694e:	5e a9       	sts	0x4e, r21
    6950:	6f a9       	sts	0x4f, r22
    6952:	78 ad       	sts	0x68, r23
    6954:	60 70       	andi	r22, 0x00	; 0
    6956:	70 70       	andi	r23, 0x00	; 0
    6958:	84 2b       	or	r24, r20
    695a:	95 2b       	or	r25, r21
    695c:	a6 2b       	or	r26, r22
    695e:	b7 2b       	or	r27, r23
    6960:	49 a5       	lds	r20, 0x69
    6962:	5a a5       	lds	r21, 0x6a
    6964:	6b a5       	lds	r22, 0x6b
    6966:	7c a5       	lds	r23, 0x6c
    6968:	80 17       	cp	r24, r16
    696a:	91 07       	cpc	r25, r17
    696c:	a2 07       	cpc	r26, r18
    696e:	b3 07       	cpc	r27, r19
    6970:	d0 f4       	brcc	.+52     	; 0x69a6 <__stack+0x9a7>
    6972:	41 50       	subi	r20, 0x01	; 1
    6974:	50 40       	sbci	r21, 0x00	; 0
    6976:	60 40       	sbci	r22, 0x00	; 0
    6978:	70 40       	sbci	r23, 0x00	; 0
    697a:	88 0d       	add	r24, r8
    697c:	99 1d       	adc	r25, r9
    697e:	aa 1d       	adc	r26, r10
    6980:	bb 1d       	adc	r27, r11
    6982:	88 15       	cp	r24, r8
    6984:	99 05       	cpc	r25, r9
    6986:	aa 05       	cpc	r26, r10
    6988:	bb 05       	cpc	r27, r11
    698a:	68 f0       	brcs	.+26     	; 0x69a6 <__stack+0x9a7>
    698c:	80 17       	cp	r24, r16
    698e:	91 07       	cpc	r25, r17
    6990:	a2 07       	cpc	r26, r18
    6992:	b3 07       	cpc	r27, r19
    6994:	40 f4       	brcc	.+16     	; 0x69a6 <__stack+0x9a7>
    6996:	49 a5       	lds	r20, 0x69
    6998:	5a a5       	lds	r21, 0x6a
    699a:	6b a5       	lds	r22, 0x6b
    699c:	7c a5       	lds	r23, 0x6c
    699e:	42 50       	subi	r20, 0x02	; 2
    69a0:	50 40       	sbci	r21, 0x00	; 0
    69a2:	60 40       	sbci	r22, 0x00	; 0
    69a4:	70 40       	sbci	r23, 0x00	; 0
    69a6:	09 a9       	sts	0x49, r16
    69a8:	1a a9       	sts	0x4a, r17
    69aa:	2b a9       	sts	0x4b, r18
    69ac:	3c a9       	sts	0x4c, r19
    69ae:	78 01       	movw	r14, r16
    69b0:	dd 24       	eor	r13, r13
    69b2:	cc 24       	eor	r12, r12
    69b4:	c4 2a       	or	r12, r20
    69b6:	d5 2a       	or	r13, r21
    69b8:	e6 2a       	or	r14, r22
    69ba:	f7 2a       	or	r15, r23
    69bc:	50 c2       	rjmp	.+1184   	; 0x6e5e <__stack+0xe5f>
    69be:	c8 16       	cp	r12, r24
    69c0:	d9 06       	cpc	r13, r25
    69c2:	ea 06       	cpc	r14, r26
    69c4:	fb 06       	cpc	r15, r27
    69c6:	08 f4       	brcc	.+2      	; 0x69ca <__stack+0x9cb>
    69c8:	37 c2       	rjmp	.+1134   	; 0x6e38 <__stack+0xe39>
    69ca:	80 30       	cpi	r24, 0x00	; 0
    69cc:	10 e0       	ldi	r17, 0x00	; 0
    69ce:	91 07       	cpc	r25, r17
    69d0:	11 e0       	ldi	r17, 0x01	; 1
    69d2:	a1 07       	cpc	r26, r17
    69d4:	10 e0       	ldi	r17, 0x00	; 0
    69d6:	b1 07       	cpc	r27, r17
    69d8:	50 f4       	brcc	.+20     	; 0x69ee <__stack+0x9ef>
    69da:	8f 3f       	cpi	r24, 0xFF	; 255
    69dc:	91 05       	cpc	r25, r1
    69de:	a1 05       	cpc	r26, r1
    69e0:	b1 05       	cpc	r27, r1
    69e2:	09 f0       	breq	.+2      	; 0x69e6 <__stack+0x9e7>
    69e4:	88 f4       	brcc	.+34     	; 0x6a08 <__stack+0xa09>
    69e6:	00 e0       	ldi	r16, 0x00	; 0
    69e8:	10 e0       	ldi	r17, 0x00	; 0
    69ea:	98 01       	movw	r18, r16
    69ec:	16 c0       	rjmp	.+44     	; 0x6a1a <__stack+0xa1b>
    69ee:	80 30       	cpi	r24, 0x00	; 0
    69f0:	20 e0       	ldi	r18, 0x00	; 0
    69f2:	92 07       	cpc	r25, r18
    69f4:	20 e0       	ldi	r18, 0x00	; 0
    69f6:	a2 07       	cpc	r26, r18
    69f8:	21 e0       	ldi	r18, 0x01	; 1
    69fa:	b2 07       	cpc	r27, r18
    69fc:	50 f4       	brcc	.+20     	; 0x6a12 <__stack+0xa13>
    69fe:	00 e1       	ldi	r16, 0x10	; 16
    6a00:	10 e0       	ldi	r17, 0x00	; 0
    6a02:	20 e0       	ldi	r18, 0x00	; 0
    6a04:	30 e0       	ldi	r19, 0x00	; 0
    6a06:	09 c0       	rjmp	.+18     	; 0x6a1a <__stack+0xa1b>
    6a08:	08 e0       	ldi	r16, 0x08	; 8
    6a0a:	10 e0       	ldi	r17, 0x00	; 0
    6a0c:	20 e0       	ldi	r18, 0x00	; 0
    6a0e:	30 e0       	ldi	r19, 0x00	; 0
    6a10:	04 c0       	rjmp	.+8      	; 0x6a1a <__stack+0xa1b>
    6a12:	08 e1       	ldi	r16, 0x18	; 24
    6a14:	10 e0       	ldi	r17, 0x00	; 0
    6a16:	20 e0       	ldi	r18, 0x00	; 0
    6a18:	30 e0       	ldi	r19, 0x00	; 0
    6a1a:	ac 01       	movw	r20, r24
    6a1c:	bd 01       	movw	r22, r26
    6a1e:	00 2e       	mov	r0, r16
    6a20:	04 c0       	rjmp	.+8      	; 0x6a2a <__stack+0xa2b>
    6a22:	76 95       	lsr	r23
    6a24:	67 95       	ror	r22
    6a26:	57 95       	ror	r21
    6a28:	47 95       	ror	r20
    6a2a:	0a 94       	dec	r0
    6a2c:	d2 f7       	brpl	.-12     	; 0x6a22 <__stack+0xa23>
    6a2e:	fa 01       	movw	r30, r20
    6a30:	e3 5f       	subi	r30, 0xF3	; 243
    6a32:	ff 4d       	sbci	r31, 0xDF	; 223
    6a34:	40 81       	ld	r20, Z
    6a36:	04 0f       	add	r16, r20
    6a38:	11 1d       	adc	r17, r1
    6a3a:	21 1d       	adc	r18, r1
    6a3c:	31 1d       	adc	r19, r1
    6a3e:	40 e2       	ldi	r20, 0x20	; 32
    6a40:	50 e0       	ldi	r21, 0x00	; 0
    6a42:	60 e0       	ldi	r22, 0x00	; 0
    6a44:	70 e0       	ldi	r23, 0x00	; 0
    6a46:	40 1b       	sub	r20, r16
    6a48:	51 0b       	sbc	r21, r17
    6a4a:	62 0b       	sbc	r22, r18
    6a4c:	73 0b       	sbc	r23, r19
    6a4e:	a1 f4       	brne	.+40     	; 0x6a78 <__stack+0xa79>
    6a50:	8c 15       	cp	r24, r12
    6a52:	9d 05       	cpc	r25, r13
    6a54:	ae 05       	cpc	r26, r14
    6a56:	bf 05       	cpc	r27, r15
    6a58:	08 f4       	brcc	.+2      	; 0x6a5c <__stack+0xa5d>
    6a5a:	f5 c1       	rjmp	.+1002   	; 0x6e46 <__stack+0xe47>
    6a5c:	ed a8       	sts	0x8d, r30
    6a5e:	fe a8       	sts	0x8e, r31
    6a60:	0f a9       	sts	0x4f, r16
    6a62:	18 ad       	sts	0x68, r17
    6a64:	44 24       	eor	r4, r4
    6a66:	55 24       	eor	r5, r5
    6a68:	32 01       	movw	r6, r4
    6a6a:	e8 14       	cp	r14, r8
    6a6c:	f9 04       	cpc	r15, r9
    6a6e:	0a 05       	cpc	r16, r10
    6a70:	1b 05       	cpc	r17, r11
    6a72:	08 f0       	brcs	.+2      	; 0x6a76 <__stack+0xa77>
    6a74:	eb c1       	rjmp	.+982    	; 0x6e4c <__stack+0xe4d>
    6a76:	e3 c1       	rjmp	.+966    	; 0x6e3e <__stack+0xe3f>
    6a78:	34 2e       	mov	r3, r20
    6a7a:	2c 01       	movw	r4, r24
    6a7c:	3d 01       	movw	r6, r26
    6a7e:	04 c0       	rjmp	.+8      	; 0x6a88 <__stack+0xa89>
    6a80:	44 0c       	add	r4, r4
    6a82:	55 1c       	adc	r5, r5
    6a84:	66 1c       	adc	r6, r6
    6a86:	77 1c       	adc	r7, r7
    6a88:	4a 95       	dec	r20
    6a8a:	d2 f7       	brpl	.-12     	; 0x6a80 <__stack+0xa81>
    6a8c:	d5 01       	movw	r26, r10
    6a8e:	c4 01       	movw	r24, r8
    6a90:	00 2e       	mov	r0, r16
    6a92:	04 c0       	rjmp	.+8      	; 0x6a9c <__stack+0xa9d>
    6a94:	b6 95       	lsr	r27
    6a96:	a7 95       	ror	r26
    6a98:	97 95       	ror	r25
    6a9a:	87 95       	ror	r24
    6a9c:	0a 94       	dec	r0
    6a9e:	d2 f7       	brpl	.-12     	; 0x6a94 <__stack+0xa95>
    6aa0:	48 2a       	or	r4, r24
    6aa2:	59 2a       	or	r5, r25
    6aa4:	6a 2a       	or	r6, r26
    6aa6:	7b 2a       	or	r7, r27
    6aa8:	a5 01       	movw	r20, r10
    6aaa:	94 01       	movw	r18, r8
    6aac:	03 2c       	mov	r0, r3
    6aae:	04 c0       	rjmp	.+8      	; 0x6ab8 <__stack+0xab9>
    6ab0:	22 0f       	add	r18, r18
    6ab2:	33 1f       	adc	r19, r19
    6ab4:	44 1f       	adc	r20, r20
    6ab6:	55 1f       	adc	r21, r21
    6ab8:	0a 94       	dec	r0
    6aba:	d2 f7       	brpl	.-12     	; 0x6ab0 <__stack+0xab1>
    6abc:	29 af       	sts	0x79, r18
    6abe:	3a af       	sts	0x7a, r19
    6ac0:	4b af       	sts	0x7b, r20
    6ac2:	5c af       	sts	0x7c, r21
    6ac4:	b7 01       	movw	r22, r14
    6ac6:	a6 01       	movw	r20, r12
    6ac8:	00 2e       	mov	r0, r16
    6aca:	04 c0       	rjmp	.+8      	; 0x6ad4 <__stack+0xad5>
    6acc:	76 95       	lsr	r23
    6ace:	67 95       	ror	r22
    6ad0:	57 95       	ror	r21
    6ad2:	47 95       	ror	r20
    6ad4:	0a 94       	dec	r0
    6ad6:	d2 f7       	brpl	.-12     	; 0x6acc <__stack+0xacd>
    6ad8:	49 ab       	sts	0x59, r20
    6ada:	5a ab       	sts	0x5a, r21
    6adc:	6b ab       	sts	0x5b, r22
    6ade:	7c ab       	sts	0x5c, r23
    6ae0:	c7 01       	movw	r24, r14
    6ae2:	b6 01       	movw	r22, r12
    6ae4:	03 2c       	mov	r0, r3
    6ae6:	04 c0       	rjmp	.+8      	; 0x6af0 <__stack+0xaf1>
    6ae8:	66 0f       	add	r22, r22
    6aea:	77 1f       	adc	r23, r23
    6aec:	88 1f       	adc	r24, r24
    6aee:	99 1f       	adc	r25, r25
    6af0:	0a 94       	dec	r0
    6af2:	d2 f7       	brpl	.-12     	; 0x6ae8 <__stack+0xae9>
    6af4:	6d a7       	lds	r22, 0x7d
    6af6:	7e a7       	lds	r23, 0x7e
    6af8:	8f a7       	lds	r24, 0x7f
    6afa:	98 ab       	sts	0x58, r25
    6afc:	8d a9       	sts	0x4d, r24
    6afe:	9e a9       	sts	0x4e, r25
    6b00:	af a9       	sts	0x4f, r26
    6b02:	b8 ad       	sts	0x68, r27
    6b04:	04 c0       	rjmp	.+8      	; 0x6b0e <__stack+0xb0f>
    6b06:	b6 95       	lsr	r27
    6b08:	a7 95       	ror	r26
    6b0a:	97 95       	ror	r25
    6b0c:	87 95       	ror	r24
    6b0e:	0a 95       	dec	r16
    6b10:	d2 f7       	brpl	.-12     	; 0x6b06 <__stack+0xb07>
    6b12:	4d a5       	lds	r20, 0x6d
    6b14:	5e a5       	lds	r21, 0x6e
    6b16:	6f a5       	lds	r22, 0x6f
    6b18:	78 a9       	sts	0x48, r23
    6b1a:	48 2b       	or	r20, r24
    6b1c:	59 2b       	or	r21, r25
    6b1e:	6a 2b       	or	r22, r26
    6b20:	7b 2b       	or	r23, r27
    6b22:	4d a7       	lds	r20, 0x7d
    6b24:	5e a7       	lds	r21, 0x7e
    6b26:	6f a7       	lds	r22, 0x7f
    6b28:	78 ab       	sts	0x58, r23
    6b2a:	43 01       	movw	r8, r6
    6b2c:	aa 24       	eor	r10, r10
    6b2e:	bb 24       	eor	r11, r11
    6b30:	93 01       	movw	r18, r6
    6b32:	82 01       	movw	r16, r4
    6b34:	20 70       	andi	r18, 0x00	; 0
    6b36:	30 70       	andi	r19, 0x00	; 0
    6b38:	21 96       	adiw	r28, 0x01	; 1
    6b3a:	0c af       	sts	0x7c, r16
    6b3c:	1d af       	sts	0x7d, r17
    6b3e:	2e af       	sts	0x7e, r18
    6b40:	3f af       	sts	0x7f, r19
    6b42:	21 97       	sbiw	r28, 0x01	; 1
    6b44:	69 a9       	sts	0x49, r22
    6b46:	7a a9       	sts	0x4a, r23
    6b48:	8b a9       	sts	0x4b, r24
    6b4a:	9c a9       	sts	0x4c, r25
    6b4c:	a5 01       	movw	r20, r10
    6b4e:	94 01       	movw	r18, r8
    6b50:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6b54:	29 a7       	lds	r18, 0x79
    6b56:	3a a7       	lds	r19, 0x7a
    6b58:	4b a7       	lds	r20, 0x7b
    6b5a:	5c a7       	lds	r21, 0x7c
    6b5c:	6b 01       	movw	r12, r22
    6b5e:	7c 01       	movw	r14, r24
    6b60:	69 a9       	sts	0x49, r22
    6b62:	7a a9       	sts	0x4a, r23
    6b64:	8b a9       	sts	0x4b, r24
    6b66:	9c a9       	sts	0x4c, r25
    6b68:	a5 01       	movw	r20, r10
    6b6a:	94 01       	movw	r18, r8
    6b6c:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6b70:	ca 01       	movw	r24, r20
    6b72:	b9 01       	movw	r22, r18
    6b74:	21 96       	adiw	r28, 0x01	; 1
    6b76:	2c ad       	sts	0x6c, r18
    6b78:	3d ad       	sts	0x6d, r19
    6b7a:	4e ad       	sts	0x6e, r20
    6b7c:	5f ad       	sts	0x6f, r21
    6b7e:	21 97       	sbiw	r28, 0x01	; 1
    6b80:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6b84:	dc 01       	movw	r26, r24
    6b86:	cb 01       	movw	r24, r22
    6b88:	76 01       	movw	r14, r12
    6b8a:	dd 24       	eor	r13, r13
    6b8c:	cc 24       	eor	r12, r12
    6b8e:	0d a5       	lds	r16, 0x6d
    6b90:	1e a5       	lds	r17, 0x6e
    6b92:	2f a5       	lds	r18, 0x6f
    6b94:	38 a9       	sts	0x48, r19
    6b96:	a9 01       	movw	r20, r18
    6b98:	66 27       	eor	r22, r22
    6b9a:	77 27       	eor	r23, r23
    6b9c:	c4 2a       	or	r12, r20
    6b9e:	d5 2a       	or	r13, r21
    6ba0:	e6 2a       	or	r14, r22
    6ba2:	f7 2a       	or	r15, r23
    6ba4:	09 a5       	lds	r16, 0x69
    6ba6:	1a a5       	lds	r17, 0x6a
    6ba8:	2b a5       	lds	r18, 0x6b
    6baa:	3c a5       	lds	r19, 0x6c
    6bac:	c8 16       	cp	r12, r24
    6bae:	d9 06       	cpc	r13, r25
    6bb0:	ea 06       	cpc	r14, r26
    6bb2:	fb 06       	cpc	r15, r27
    6bb4:	38 f5       	brcc	.+78     	; 0x6c04 <__stack+0xc05>
    6bb6:	01 50       	subi	r16, 0x01	; 1
    6bb8:	10 40       	sbci	r17, 0x00	; 0
    6bba:	20 40       	sbci	r18, 0x00	; 0
    6bbc:	30 40       	sbci	r19, 0x00	; 0
    6bbe:	09 ab       	sts	0x59, r16
    6bc0:	1a ab       	sts	0x5a, r17
    6bc2:	2b ab       	sts	0x5b, r18
    6bc4:	3c ab       	sts	0x5c, r19
    6bc6:	c4 0c       	add	r12, r4
    6bc8:	d5 1c       	adc	r13, r5
    6bca:	e6 1c       	adc	r14, r6
    6bcc:	f7 1c       	adc	r15, r7
    6bce:	c4 14       	cp	r12, r4
    6bd0:	d5 04       	cpc	r13, r5
    6bd2:	e6 04       	cpc	r14, r6
    6bd4:	f7 04       	cpc	r15, r7
    6bd6:	d0 f0       	brcs	.+52     	; 0x6c0c <__stack+0xc0d>
    6bd8:	c8 16       	cp	r12, r24
    6bda:	d9 06       	cpc	r13, r25
    6bdc:	ea 06       	cpc	r14, r26
    6bde:	fb 06       	cpc	r15, r27
    6be0:	a8 f4       	brcc	.+42     	; 0x6c0c <__stack+0xc0d>
    6be2:	09 a5       	lds	r16, 0x69
    6be4:	1a a5       	lds	r17, 0x6a
    6be6:	2b a5       	lds	r18, 0x6b
    6be8:	3c a5       	lds	r19, 0x6c
    6bea:	02 50       	subi	r16, 0x02	; 2
    6bec:	10 40       	sbci	r17, 0x00	; 0
    6bee:	20 40       	sbci	r18, 0x00	; 0
    6bf0:	30 40       	sbci	r19, 0x00	; 0
    6bf2:	09 ab       	sts	0x59, r16
    6bf4:	1a ab       	sts	0x5a, r17
    6bf6:	2b ab       	sts	0x5b, r18
    6bf8:	3c ab       	sts	0x5c, r19
    6bfa:	c4 0c       	add	r12, r4
    6bfc:	d5 1c       	adc	r13, r5
    6bfe:	e6 1c       	adc	r14, r6
    6c00:	f7 1c       	adc	r15, r7
    6c02:	04 c0       	rjmp	.+8      	; 0x6c0c <__stack+0xc0d>
    6c04:	09 ab       	sts	0x59, r16
    6c06:	1a ab       	sts	0x5a, r17
    6c08:	2b ab       	sts	0x5b, r18
    6c0a:	3c ab       	sts	0x5c, r19
    6c0c:	c8 1a       	sub	r12, r24
    6c0e:	d9 0a       	sbc	r13, r25
    6c10:	ea 0a       	sbc	r14, r26
    6c12:	fb 0a       	sbc	r15, r27
    6c14:	c7 01       	movw	r24, r14
    6c16:	b6 01       	movw	r22, r12
    6c18:	a5 01       	movw	r20, r10
    6c1a:	94 01       	movw	r18, r8
    6c1c:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6c20:	29 a7       	lds	r18, 0x79
    6c22:	3a a7       	lds	r19, 0x7a
    6c24:	4b a7       	lds	r20, 0x7b
    6c26:	5c a7       	lds	r21, 0x7c
    6c28:	29 96       	adiw	r28, 0x09	; 9
    6c2a:	6c af       	sts	0x7c, r22
    6c2c:	7d af       	sts	0x7d, r23
    6c2e:	8e af       	sts	0x7e, r24
    6c30:	9f af       	sts	0x7f, r25
    6c32:	29 97       	sbiw	r28, 0x09	; 9
    6c34:	c7 01       	movw	r24, r14
    6c36:	b6 01       	movw	r22, r12
    6c38:	a5 01       	movw	r20, r10
    6c3a:	94 01       	movw	r18, r8
    6c3c:	0e 94 8e 39 	call	0x731c	; 0x731c <__udivmodsi4>
    6c40:	ca 01       	movw	r24, r20
    6c42:	b9 01       	movw	r22, r18
    6c44:	21 96       	adiw	r28, 0x01	; 1
    6c46:	2c ad       	sts	0x6c, r18
    6c48:	3d ad       	sts	0x6d, r19
    6c4a:	4e ad       	sts	0x6e, r20
    6c4c:	5f ad       	sts	0x6f, r21
    6c4e:	21 97       	sbiw	r28, 0x01	; 1
    6c50:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6c54:	4b 01       	movw	r8, r22
    6c56:	5c 01       	movw	r10, r24
    6c58:	29 96       	adiw	r28, 0x09	; 9
    6c5a:	4c ad       	sts	0x6c, r20
    6c5c:	5d ad       	sts	0x6d, r21
    6c5e:	6e ad       	sts	0x6e, r22
    6c60:	7f ad       	sts	0x6f, r23
    6c62:	29 97       	sbiw	r28, 0x09	; 9
    6c64:	9a 01       	movw	r18, r20
    6c66:	11 27       	eor	r17, r17
    6c68:	00 27       	eor	r16, r16
    6c6a:	8d a5       	lds	r24, 0x6d
    6c6c:	9e a5       	lds	r25, 0x6e
    6c6e:	af a5       	lds	r26, 0x6f
    6c70:	b8 a9       	sts	0x48, r27
    6c72:	a0 70       	andi	r26, 0x00	; 0
    6c74:	b0 70       	andi	r27, 0x00	; 0
    6c76:	08 2b       	or	r16, r24
    6c78:	19 2b       	or	r17, r25
    6c7a:	2a 2b       	or	r18, r26
    6c7c:	3b 2b       	or	r19, r27
    6c7e:	89 a5       	lds	r24, 0x69
    6c80:	9a a5       	lds	r25, 0x6a
    6c82:	ab a5       	lds	r26, 0x6b
    6c84:	bc a5       	lds	r27, 0x6c
    6c86:	08 15       	cp	r16, r8
    6c88:	19 05       	cpc	r17, r9
    6c8a:	2a 05       	cpc	r18, r10
    6c8c:	3b 05       	cpc	r19, r11
    6c8e:	e0 f4       	brcc	.+56     	; 0x6cc8 <__stack+0xcc9>
    6c90:	01 97       	sbiw	r24, 0x01	; 1
    6c92:	a1 09       	sbc	r26, r1
    6c94:	b1 09       	sbc	r27, r1
    6c96:	04 0d       	add	r16, r4
    6c98:	15 1d       	adc	r17, r5
    6c9a:	26 1d       	adc	r18, r6
    6c9c:	37 1d       	adc	r19, r7
    6c9e:	04 15       	cp	r16, r4
    6ca0:	15 05       	cpc	r17, r5
    6ca2:	26 05       	cpc	r18, r6
    6ca4:	37 05       	cpc	r19, r7
    6ca6:	80 f0       	brcs	.+32     	; 0x6cc8 <__stack+0xcc9>
    6ca8:	08 15       	cp	r16, r8
    6caa:	19 05       	cpc	r17, r9
    6cac:	2a 05       	cpc	r18, r10
    6cae:	3b 05       	cpc	r19, r11
    6cb0:	58 f4       	brcc	.+22     	; 0x6cc8 <__stack+0xcc9>
    6cb2:	89 a5       	lds	r24, 0x69
    6cb4:	9a a5       	lds	r25, 0x6a
    6cb6:	ab a5       	lds	r26, 0x6b
    6cb8:	bc a5       	lds	r27, 0x6c
    6cba:	02 97       	sbiw	r24, 0x02	; 2
    6cbc:	a1 09       	sbc	r26, r1
    6cbe:	b1 09       	sbc	r27, r1
    6cc0:	04 0d       	add	r16, r4
    6cc2:	15 1d       	adc	r17, r5
    6cc4:	26 1d       	adc	r18, r6
    6cc6:	37 1d       	adc	r19, r7
    6cc8:	b9 01       	movw	r22, r18
    6cca:	a8 01       	movw	r20, r16
    6ccc:	48 19       	sub	r20, r8
    6cce:	59 09       	sbc	r21, r9
    6cd0:	6a 09       	sbc	r22, r10
    6cd2:	7b 09       	sbc	r23, r11
    6cd4:	4d a7       	lds	r20, 0x7d
    6cd6:	5e a7       	lds	r21, 0x7e
    6cd8:	6f a7       	lds	r22, 0x7f
    6cda:	78 ab       	sts	0x58, r23
    6cdc:	09 a9       	sts	0x49, r16
    6cde:	1a a9       	sts	0x4a, r17
    6ce0:	2b a9       	sts	0x4b, r18
    6ce2:	3c a9       	sts	0x4c, r19
    6ce4:	78 01       	movw	r14, r16
    6ce6:	dd 24       	eor	r13, r13
    6ce8:	cc 24       	eor	r12, r12
    6cea:	c8 2a       	or	r12, r24
    6cec:	d9 2a       	or	r13, r25
    6cee:	ea 2a       	or	r14, r26
    6cf0:	fb 2a       	or	r15, r27
    6cf2:	ff ef       	ldi	r31, 0xFF	; 255
    6cf4:	8f 2e       	mov	r8, r31
    6cf6:	ff ef       	ldi	r31, 0xFF	; 255
    6cf8:	9f 2e       	mov	r9, r31
    6cfa:	a1 2c       	mov	r10, r1
    6cfc:	b1 2c       	mov	r11, r1
    6cfe:	8c 20       	and	r8, r12
    6d00:	9d 20       	and	r9, r13
    6d02:	ae 20       	and	r10, r14
    6d04:	bf 20       	and	r11, r15
    6d06:	87 01       	movw	r16, r14
    6d08:	22 27       	eor	r18, r18
    6d0a:	33 27       	eor	r19, r19
    6d0c:	09 a7       	lds	r16, 0x79
    6d0e:	1a a7       	lds	r17, 0x7a
    6d10:	2b a7       	lds	r18, 0x7b
    6d12:	3c a7       	lds	r19, 0x7c
    6d14:	49 ac       	sts	0xa9, r20
    6d16:	5a ac       	sts	0xaa, r21
    6d18:	6b ac       	sts	0xab, r22
    6d1a:	7c ac       	sts	0xac, r23
    6d1c:	2f ef       	ldi	r18, 0xFF	; 255
    6d1e:	3f ef       	ldi	r19, 0xFF	; 255
    6d20:	40 e0       	ldi	r20, 0x00	; 0
    6d22:	50 e0       	ldi	r21, 0x00	; 0
    6d24:	42 22       	and	r4, r18
    6d26:	53 22       	and	r5, r19
    6d28:	64 22       	and	r6, r20
    6d2a:	75 22       	and	r7, r21
    6d2c:	29 ad       	sts	0x69, r18
    6d2e:	3a ad       	sts	0x6a, r19
    6d30:	4b ad       	sts	0x6b, r20
    6d32:	5c ad       	sts	0x6c, r21
    6d34:	8a 01       	movw	r16, r20
    6d36:	22 27       	eor	r18, r18
    6d38:	33 27       	eor	r19, r19
    6d3a:	09 ab       	sts	0x59, r16
    6d3c:	1a ab       	sts	0x5a, r17
    6d3e:	2b ab       	sts	0x5b, r18
    6d40:	3c ab       	sts	0x5c, r19
    6d42:	c5 01       	movw	r24, r10
    6d44:	b4 01       	movw	r22, r8
    6d46:	a3 01       	movw	r20, r6
    6d48:	92 01       	movw	r18, r4
    6d4a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6d4e:	69 af       	sts	0x79, r22
    6d50:	7a af       	sts	0x7a, r23
    6d52:	8b af       	sts	0x7b, r24
    6d54:	9c af       	sts	0x7c, r25
    6d56:	c5 01       	movw	r24, r10
    6d58:	b4 01       	movw	r22, r8
    6d5a:	29 a9       	sts	0x49, r18
    6d5c:	3a a9       	sts	0x4a, r19
    6d5e:	4b a9       	sts	0x4b, r20
    6d60:	5c a9       	sts	0x4c, r21
    6d62:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6d66:	4b 01       	movw	r8, r22
    6d68:	5c 01       	movw	r10, r24
    6d6a:	69 a5       	lds	r22, 0x69
    6d6c:	7a a5       	lds	r23, 0x6a
    6d6e:	8b a5       	lds	r24, 0x6b
    6d70:	9c a5       	lds	r25, 0x6c
    6d72:	a3 01       	movw	r20, r6
    6d74:	92 01       	movw	r18, r4
    6d76:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6d7a:	2b 01       	movw	r4, r22
    6d7c:	3c 01       	movw	r6, r24
    6d7e:	69 a5       	lds	r22, 0x69
    6d80:	7a a5       	lds	r23, 0x6a
    6d82:	8b a5       	lds	r24, 0x6b
    6d84:	9c a5       	lds	r25, 0x6c
    6d86:	29 a9       	sts	0x49, r18
    6d88:	3a a9       	sts	0x4a, r19
    6d8a:	4b a9       	sts	0x4b, r20
    6d8c:	5c a9       	sts	0x4c, r21
    6d8e:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__mulsi3>
    6d92:	ab 01       	movw	r20, r22
    6d94:	bc 01       	movw	r22, r24
    6d96:	84 0c       	add	r8, r4
    6d98:	95 1c       	adc	r9, r5
    6d9a:	a6 1c       	adc	r10, r6
    6d9c:	b7 1c       	adc	r11, r7
    6d9e:	09 ad       	sts	0x69, r16
    6da0:	1a ad       	sts	0x6a, r17
    6da2:	2b ad       	sts	0x6b, r18
    6da4:	3c ad       	sts	0x6c, r19
    6da6:	c9 01       	movw	r24, r18
    6da8:	aa 27       	eor	r26, r26
    6daa:	bb 27       	eor	r27, r27
    6dac:	88 0e       	add	r8, r24
    6dae:	99 1e       	adc	r9, r25
    6db0:	aa 1e       	adc	r10, r26
    6db2:	bb 1e       	adc	r11, r27
    6db4:	84 14       	cp	r8, r4
    6db6:	95 04       	cpc	r9, r5
    6db8:	a6 04       	cpc	r10, r6
    6dba:	b7 04       	cpc	r11, r7
    6dbc:	20 f4       	brcc	.+8      	; 0x6dc6 <__stack+0xdc7>
    6dbe:	40 50       	subi	r20, 0x00	; 0
    6dc0:	50 40       	sbci	r21, 0x00	; 0
    6dc2:	6f 4f       	sbci	r22, 0xFF	; 255
    6dc4:	7f 4f       	sbci	r23, 0xFF	; 255
    6dc6:	c5 01       	movw	r24, r10
    6dc8:	aa 27       	eor	r26, r26
    6dca:	bb 27       	eor	r27, r27
    6dcc:	84 0f       	add	r24, r20
    6dce:	95 1f       	adc	r25, r21
    6dd0:	a6 1f       	adc	r26, r22
    6dd2:	b7 1f       	adc	r27, r23
    6dd4:	0d a5       	lds	r16, 0x6d
    6dd6:	1e a5       	lds	r17, 0x6e
    6dd8:	2f a5       	lds	r18, 0x6f
    6dda:	38 a9       	sts	0x48, r19
    6ddc:	08 17       	cp	r16, r24
    6dde:	19 07       	cpc	r17, r25
    6de0:	2a 07       	cpc	r18, r26
    6de2:	3b 07       	cpc	r19, r27
    6de4:	18 f1       	brcs	.+70     	; 0x6e2c <__stack+0xe2d>
    6de6:	80 17       	cp	r24, r16
    6de8:	91 07       	cpc	r25, r17
    6dea:	a2 07       	cpc	r26, r18
    6dec:	b3 07       	cpc	r27, r19
    6dee:	a1 f5       	brne	.+104    	; 0x6e58 <__stack+0xe59>
    6df0:	54 01       	movw	r10, r8
    6df2:	99 24       	eor	r9, r9
    6df4:	88 24       	eor	r8, r8
    6df6:	89 ad       	sts	0x69, r24
    6df8:	9a ad       	sts	0x6a, r25
    6dfa:	ab ad       	sts	0x6b, r26
    6dfc:	bc ad       	sts	0x6c, r27
    6dfe:	a0 70       	andi	r26, 0x00	; 0
    6e00:	b0 70       	andi	r27, 0x00	; 0
    6e02:	88 0e       	add	r8, r24
    6e04:	99 1e       	adc	r9, r25
    6e06:	aa 1e       	adc	r10, r26
    6e08:	bb 1e       	adc	r11, r27
    6e0a:	4d a9       	sts	0x4d, r20
    6e0c:	5e a9       	sts	0x4e, r21
    6e0e:	6f a9       	sts	0x4f, r22
    6e10:	78 ad       	sts	0x68, r23
    6e12:	03 2c       	mov	r0, r3
    6e14:	04 c0       	rjmp	.+8      	; 0x6e1e <__stack+0xe1f>
    6e16:	44 0f       	add	r20, r20
    6e18:	55 1f       	adc	r21, r21
    6e1a:	66 1f       	adc	r22, r22
    6e1c:	77 1f       	adc	r23, r23
    6e1e:	0a 94       	dec	r0
    6e20:	d2 f7       	brpl	.-12     	; 0x6e16 <__stack+0xe17>
    6e22:	48 15       	cp	r20, r8
    6e24:	59 05       	cpc	r21, r9
    6e26:	6a 05       	cpc	r22, r10
    6e28:	7b 05       	cpc	r23, r11
    6e2a:	b0 f4       	brcc	.+44     	; 0x6e58 <__stack+0xe59>
    6e2c:	08 94       	sec
    6e2e:	c1 08       	sbc	r12, r1
    6e30:	d1 08       	sbc	r13, r1
    6e32:	e1 08       	sbc	r14, r1
    6e34:	f1 08       	sbc	r15, r1
    6e36:	10 c0       	rjmp	.+32     	; 0x6e58 <__stack+0xe59>
    6e38:	44 24       	eor	r4, r4
    6e3a:	55 24       	eor	r5, r5
    6e3c:	32 01       	movw	r6, r4
    6e3e:	cc 24       	eor	r12, r12
    6e40:	dd 24       	eor	r13, r13
    6e42:	76 01       	movw	r14, r12
    6e44:	0c c0       	rjmp	.+24     	; 0x6e5e <__stack+0xe5f>
    6e46:	44 24       	eor	r4, r4
    6e48:	55 24       	eor	r5, r5
    6e4a:	32 01       	movw	r6, r4
    6e4c:	81 e0       	ldi	r24, 0x01	; 1
    6e4e:	c8 2e       	mov	r12, r24
    6e50:	d1 2c       	mov	r13, r1
    6e52:	e1 2c       	mov	r14, r1
    6e54:	f1 2c       	mov	r15, r1
    6e56:	03 c0       	rjmp	.+6      	; 0x6e5e <__stack+0xe5f>
    6e58:	44 24       	eor	r4, r4
    6e5a:	55 24       	eor	r5, r5
    6e5c:	32 01       	movw	r6, r4
    6e5e:	fe 01       	movw	r30, r28
    6e60:	31 96       	adiw	r30, 0x01	; 1
    6e62:	88 e0       	ldi	r24, 0x08	; 8
    6e64:	df 01       	movw	r26, r30
    6e66:	1d 92       	st	X+, r1
    6e68:	8a 95       	dec	r24
    6e6a:	e9 f7       	brne	.-6      	; 0x6e66 <__stack+0xe67>
    6e6c:	c9 82       	std	Y+1, r12	; 0x01
    6e6e:	da 82       	std	Y+2, r13	; 0x02
    6e70:	eb 82       	std	Y+3, r14	; 0x03
    6e72:	fc 82       	std	Y+4, r15	; 0x04
    6e74:	4d 82       	std	Y+5, r4	; 0x05
    6e76:	5e 82       	std	Y+6, r5	; 0x06
    6e78:	6f 82       	std	Y+7, r6	; 0x07
    6e7a:	78 86       	std	Y+8, r7	; 0x08
    6e7c:	2c 2d       	mov	r18, r12
    6e7e:	3a 81       	ldd	r19, Y+2	; 0x02
    6e80:	4b 81       	ldd	r20, Y+3	; 0x03
    6e82:	5c 81       	ldd	r21, Y+4	; 0x04
    6e84:	64 2d       	mov	r22, r4
    6e86:	7e 81       	ldd	r23, Y+6	; 0x06
    6e88:	8f 81       	ldd	r24, Y+7	; 0x07
    6e8a:	98 85       	ldd	r25, Y+8	; 0x08
    6e8c:	25 96       	adiw	r28, 0x05	; 5
    6e8e:	ec ac       	sts	0xac, r30
    6e90:	fd ac       	sts	0xad, r31
    6e92:	0e ad       	sts	0x6e, r16
    6e94:	1f ad       	sts	0x6f, r17
    6e96:	25 97       	sbiw	r28, 0x05	; 5
    6e98:	e1 14       	cp	r14, r1
    6e9a:	f1 04       	cpc	r15, r1
    6e9c:	01 05       	cpc	r16, r1
    6e9e:	11 05       	cpc	r17, r1
    6ea0:	09 f4       	brne	.+2      	; 0x6ea4 <__stack+0xea5>
    6ea2:	56 c0       	rjmp	.+172    	; 0x6f50 <__stack+0xf51>
    6ea4:	21 95       	neg	r18
    6ea6:	e1 e0       	ldi	r30, 0x01	; 1
    6ea8:	12 16       	cp	r1, r18
    6eaa:	08 f0       	brcs	.+2      	; 0x6eae <__stack+0xeaf>
    6eac:	e0 e0       	ldi	r30, 0x00	; 0
    6eae:	31 95       	neg	r19
    6eb0:	f1 e0       	ldi	r31, 0x01	; 1
    6eb2:	13 16       	cp	r1, r19
    6eb4:	08 f0       	brcs	.+2      	; 0x6eb8 <__stack+0xeb9>
    6eb6:	f0 e0       	ldi	r31, 0x00	; 0
    6eb8:	03 2f       	mov	r16, r19
    6eba:	0e 1b       	sub	r16, r30
    6ebc:	e1 e0       	ldi	r30, 0x01	; 1
    6ebe:	30 17       	cp	r19, r16
    6ec0:	08 f0       	brcs	.+2      	; 0x6ec4 <__stack+0xec5>
    6ec2:	e0 e0       	ldi	r30, 0x00	; 0
    6ec4:	fe 2b       	or	r31, r30
    6ec6:	41 95       	neg	r20
    6ec8:	e1 e0       	ldi	r30, 0x01	; 1
    6eca:	14 16       	cp	r1, r20
    6ecc:	08 f0       	brcs	.+2      	; 0x6ed0 <__stack+0xed1>
    6ece:	e0 e0       	ldi	r30, 0x00	; 0
    6ed0:	14 2f       	mov	r17, r20
    6ed2:	1f 1b       	sub	r17, r31
    6ed4:	31 e0       	ldi	r19, 0x01	; 1
    6ed6:	41 17       	cp	r20, r17
    6ed8:	08 f0       	brcs	.+2      	; 0x6edc <__stack+0xedd>
    6eda:	30 e0       	ldi	r19, 0x00	; 0
    6edc:	e3 2b       	or	r30, r19
    6ede:	51 95       	neg	r21
    6ee0:	f1 e0       	ldi	r31, 0x01	; 1
    6ee2:	15 16       	cp	r1, r21
    6ee4:	08 f0       	brcs	.+2      	; 0x6ee8 <__stack+0xee9>
    6ee6:	f0 e0       	ldi	r31, 0x00	; 0
    6ee8:	b5 2f       	mov	r27, r21
    6eea:	be 1b       	sub	r27, r30
    6eec:	31 e0       	ldi	r19, 0x01	; 1
    6eee:	5b 17       	cp	r21, r27
    6ef0:	08 f0       	brcs	.+2      	; 0x6ef4 <__stack+0xef5>
    6ef2:	30 e0       	ldi	r19, 0x00	; 0
    6ef4:	f3 2b       	or	r31, r19
    6ef6:	61 95       	neg	r22
    6ef8:	e1 e0       	ldi	r30, 0x01	; 1
    6efa:	16 16       	cp	r1, r22
    6efc:	08 f0       	brcs	.+2      	; 0x6f00 <__stack+0xf01>
    6efe:	e0 e0       	ldi	r30, 0x00	; 0
    6f00:	46 2e       	mov	r4, r22
    6f02:	4f 1a       	sub	r4, r31
    6f04:	31 e0       	ldi	r19, 0x01	; 1
    6f06:	64 15       	cp	r22, r4
    6f08:	08 f0       	brcs	.+2      	; 0x6f0c <__stack+0xf0d>
    6f0a:	30 e0       	ldi	r19, 0x00	; 0
    6f0c:	e3 2b       	or	r30, r19
    6f0e:	71 95       	neg	r23
    6f10:	f1 e0       	ldi	r31, 0x01	; 1
    6f12:	17 16       	cp	r1, r23
    6f14:	08 f0       	brcs	.+2      	; 0x6f18 <__stack+0xf19>
    6f16:	f0 e0       	ldi	r31, 0x00	; 0
    6f18:	a7 2f       	mov	r26, r23
    6f1a:	ae 1b       	sub	r26, r30
    6f1c:	31 e0       	ldi	r19, 0x01	; 1
    6f1e:	7a 17       	cp	r23, r26
    6f20:	08 f0       	brcs	.+2      	; 0x6f24 <__stack+0xf25>
    6f22:	30 e0       	ldi	r19, 0x00	; 0
    6f24:	f3 2b       	or	r31, r19
    6f26:	81 95       	neg	r24
    6f28:	e1 e0       	ldi	r30, 0x01	; 1
    6f2a:	18 16       	cp	r1, r24
    6f2c:	08 f0       	brcs	.+2      	; 0x6f30 <__stack+0xf31>
    6f2e:	e0 e0       	ldi	r30, 0x00	; 0
    6f30:	f8 2e       	mov	r15, r24
    6f32:	ff 1a       	sub	r15, r31
    6f34:	ff 2d       	mov	r31, r15
    6f36:	31 e0       	ldi	r19, 0x01	; 1
    6f38:	8f 15       	cp	r24, r15
    6f3a:	08 f0       	brcs	.+2      	; 0x6f3e <__stack+0xf3f>
    6f3c:	30 e0       	ldi	r19, 0x00	; 0
    6f3e:	e3 2b       	or	r30, r19
    6f40:	91 95       	neg	r25
    6f42:	30 2f       	mov	r19, r16
    6f44:	41 2f       	mov	r20, r17
    6f46:	5b 2f       	mov	r21, r27
    6f48:	64 2d       	mov	r22, r4
    6f4a:	7a 2f       	mov	r23, r26
    6f4c:	8f 2f       	mov	r24, r31
    6f4e:	9e 1b       	sub	r25, r30
    6f50:	c8 5b       	subi	r28, 0xB8	; 184
    6f52:	df 4f       	sbci	r29, 0xFF	; 255
    6f54:	e1 e1       	ldi	r30, 0x11	; 17
    6f56:	0c 94 f9 39 	jmp	0x73f2	; 0x73f2 <__epilogue_restores__+0x2>

00006f5a <__subsf3>:
    6f5a:	50 58       	subi	r21, 0x80	; 128

00006f5c <__addsf3>:
    6f5c:	bb 27       	eor	r27, r27
    6f5e:	aa 27       	eor	r26, r26
    6f60:	0e d0       	rcall	.+28     	; 0x6f7e <__addsf3x>
    6f62:	48 c1       	rjmp	.+656    	; 0x71f4 <__fp_round>
    6f64:	39 d1       	rcall	.+626    	; 0x71d8 <__fp_pscA>
    6f66:	30 f0       	brcs	.+12     	; 0x6f74 <__addsf3+0x18>
    6f68:	3e d1       	rcall	.+636    	; 0x71e6 <__fp_pscB>
    6f6a:	20 f0       	brcs	.+8      	; 0x6f74 <__addsf3+0x18>
    6f6c:	31 f4       	brne	.+12     	; 0x6f7a <__addsf3+0x1e>
    6f6e:	9f 3f       	cpi	r25, 0xFF	; 255
    6f70:	11 f4       	brne	.+4      	; 0x6f76 <__addsf3+0x1a>
    6f72:	1e f4       	brtc	.+6      	; 0x6f7a <__addsf3+0x1e>
    6f74:	2e c1       	rjmp	.+604    	; 0x71d2 <__fp_nan>
    6f76:	0e f4       	brtc	.+2      	; 0x6f7a <__addsf3+0x1e>
    6f78:	e0 95       	com	r30
    6f7a:	e7 fb       	bst	r30, 7
    6f7c:	24 c1       	rjmp	.+584    	; 0x71c6 <__fp_inf>

00006f7e <__addsf3x>:
    6f7e:	e9 2f       	mov	r30, r25
    6f80:	4a d1       	rcall	.+660    	; 0x7216 <__fp_split3>
    6f82:	80 f3       	brcs	.-32     	; 0x6f64 <__addsf3+0x8>
    6f84:	ba 17       	cp	r27, r26
    6f86:	62 07       	cpc	r22, r18
    6f88:	73 07       	cpc	r23, r19
    6f8a:	84 07       	cpc	r24, r20
    6f8c:	95 07       	cpc	r25, r21
    6f8e:	18 f0       	brcs	.+6      	; 0x6f96 <__addsf3x+0x18>
    6f90:	71 f4       	brne	.+28     	; 0x6fae <__addsf3x+0x30>
    6f92:	9e f5       	brtc	.+102    	; 0x6ffa <__addsf3x+0x7c>
    6f94:	62 c1       	rjmp	.+708    	; 0x725a <__fp_zero>
    6f96:	0e f4       	brtc	.+2      	; 0x6f9a <__addsf3x+0x1c>
    6f98:	e0 95       	com	r30
    6f9a:	0b 2e       	mov	r0, r27
    6f9c:	ba 2f       	mov	r27, r26
    6f9e:	a0 2d       	mov	r26, r0
    6fa0:	0b 01       	movw	r0, r22
    6fa2:	b9 01       	movw	r22, r18
    6fa4:	90 01       	movw	r18, r0
    6fa6:	0c 01       	movw	r0, r24
    6fa8:	ca 01       	movw	r24, r20
    6faa:	a0 01       	movw	r20, r0
    6fac:	11 24       	eor	r1, r1
    6fae:	ff 27       	eor	r31, r31
    6fb0:	59 1b       	sub	r21, r25
    6fb2:	99 f0       	breq	.+38     	; 0x6fda <__addsf3x+0x5c>
    6fb4:	59 3f       	cpi	r21, 0xF9	; 249
    6fb6:	50 f4       	brcc	.+20     	; 0x6fcc <__addsf3x+0x4e>
    6fb8:	50 3e       	cpi	r21, 0xE0	; 224
    6fba:	68 f1       	brcs	.+90     	; 0x7016 <__addsf3x+0x98>
    6fbc:	1a 16       	cp	r1, r26
    6fbe:	f0 40       	sbci	r31, 0x00	; 0
    6fc0:	a2 2f       	mov	r26, r18
    6fc2:	23 2f       	mov	r18, r19
    6fc4:	34 2f       	mov	r19, r20
    6fc6:	44 27       	eor	r20, r20
    6fc8:	58 5f       	subi	r21, 0xF8	; 248
    6fca:	f3 cf       	rjmp	.-26     	; 0x6fb2 <__addsf3x+0x34>
    6fcc:	46 95       	lsr	r20
    6fce:	37 95       	ror	r19
    6fd0:	27 95       	ror	r18
    6fd2:	a7 95       	ror	r26
    6fd4:	f0 40       	sbci	r31, 0x00	; 0
    6fd6:	53 95       	inc	r21
    6fd8:	c9 f7       	brne	.-14     	; 0x6fcc <__addsf3x+0x4e>
    6fda:	7e f4       	brtc	.+30     	; 0x6ffa <__addsf3x+0x7c>
    6fdc:	1f 16       	cp	r1, r31
    6fde:	ba 0b       	sbc	r27, r26
    6fe0:	62 0b       	sbc	r22, r18
    6fe2:	73 0b       	sbc	r23, r19
    6fe4:	84 0b       	sbc	r24, r20
    6fe6:	ba f0       	brmi	.+46     	; 0x7016 <__addsf3x+0x98>
    6fe8:	91 50       	subi	r25, 0x01	; 1
    6fea:	a1 f0       	breq	.+40     	; 0x7014 <__addsf3x+0x96>
    6fec:	ff 0f       	add	r31, r31
    6fee:	bb 1f       	adc	r27, r27
    6ff0:	66 1f       	adc	r22, r22
    6ff2:	77 1f       	adc	r23, r23
    6ff4:	88 1f       	adc	r24, r24
    6ff6:	c2 f7       	brpl	.-16     	; 0x6fe8 <__addsf3x+0x6a>
    6ff8:	0e c0       	rjmp	.+28     	; 0x7016 <__addsf3x+0x98>
    6ffa:	ba 0f       	add	r27, r26
    6ffc:	62 1f       	adc	r22, r18
    6ffe:	73 1f       	adc	r23, r19
    7000:	84 1f       	adc	r24, r20
    7002:	48 f4       	brcc	.+18     	; 0x7016 <__addsf3x+0x98>
    7004:	87 95       	ror	r24
    7006:	77 95       	ror	r23
    7008:	67 95       	ror	r22
    700a:	b7 95       	ror	r27
    700c:	f7 95       	ror	r31
    700e:	9e 3f       	cpi	r25, 0xFE	; 254
    7010:	08 f0       	brcs	.+2      	; 0x7014 <__addsf3x+0x96>
    7012:	b3 cf       	rjmp	.-154    	; 0x6f7a <__addsf3+0x1e>
    7014:	93 95       	inc	r25
    7016:	88 0f       	add	r24, r24
    7018:	08 f0       	brcs	.+2      	; 0x701c <__addsf3x+0x9e>
    701a:	99 27       	eor	r25, r25
    701c:	ee 0f       	add	r30, r30
    701e:	97 95       	ror	r25
    7020:	87 95       	ror	r24
    7022:	08 95       	ret

00007024 <__divsf3>:
    7024:	0c d0       	rcall	.+24     	; 0x703e <__divsf3x>
    7026:	e6 c0       	rjmp	.+460    	; 0x71f4 <__fp_round>
    7028:	de d0       	rcall	.+444    	; 0x71e6 <__fp_pscB>
    702a:	40 f0       	brcs	.+16     	; 0x703c <__divsf3+0x18>
    702c:	d5 d0       	rcall	.+426    	; 0x71d8 <__fp_pscA>
    702e:	30 f0       	brcs	.+12     	; 0x703c <__divsf3+0x18>
    7030:	21 f4       	brne	.+8      	; 0x703a <__divsf3+0x16>
    7032:	5f 3f       	cpi	r21, 0xFF	; 255
    7034:	19 f0       	breq	.+6      	; 0x703c <__divsf3+0x18>
    7036:	c7 c0       	rjmp	.+398    	; 0x71c6 <__fp_inf>
    7038:	51 11       	cpse	r21, r1
    703a:	10 c1       	rjmp	.+544    	; 0x725c <__fp_szero>
    703c:	ca c0       	rjmp	.+404    	; 0x71d2 <__fp_nan>

0000703e <__divsf3x>:
    703e:	eb d0       	rcall	.+470    	; 0x7216 <__fp_split3>
    7040:	98 f3       	brcs	.-26     	; 0x7028 <__divsf3+0x4>

00007042 <__divsf3_pse>:
    7042:	99 23       	and	r25, r25
    7044:	c9 f3       	breq	.-14     	; 0x7038 <__divsf3+0x14>
    7046:	55 23       	and	r21, r21
    7048:	b1 f3       	breq	.-20     	; 0x7036 <__divsf3+0x12>
    704a:	95 1b       	sub	r25, r21
    704c:	55 0b       	sbc	r21, r21
    704e:	bb 27       	eor	r27, r27
    7050:	aa 27       	eor	r26, r26
    7052:	62 17       	cp	r22, r18
    7054:	73 07       	cpc	r23, r19
    7056:	84 07       	cpc	r24, r20
    7058:	38 f0       	brcs	.+14     	; 0x7068 <__divsf3_pse+0x26>
    705a:	9f 5f       	subi	r25, 0xFF	; 255
    705c:	5f 4f       	sbci	r21, 0xFF	; 255
    705e:	22 0f       	add	r18, r18
    7060:	33 1f       	adc	r19, r19
    7062:	44 1f       	adc	r20, r20
    7064:	aa 1f       	adc	r26, r26
    7066:	a9 f3       	breq	.-22     	; 0x7052 <__divsf3_pse+0x10>
    7068:	33 d0       	rcall	.+102    	; 0x70d0 <__divsf3_pse+0x8e>
    706a:	0e 2e       	mov	r0, r30
    706c:	3a f0       	brmi	.+14     	; 0x707c <__divsf3_pse+0x3a>
    706e:	e0 e8       	ldi	r30, 0x80	; 128
    7070:	30 d0       	rcall	.+96     	; 0x70d2 <__divsf3_pse+0x90>
    7072:	91 50       	subi	r25, 0x01	; 1
    7074:	50 40       	sbci	r21, 0x00	; 0
    7076:	e6 95       	lsr	r30
    7078:	00 1c       	adc	r0, r0
    707a:	ca f7       	brpl	.-14     	; 0x706e <__divsf3_pse+0x2c>
    707c:	29 d0       	rcall	.+82     	; 0x70d0 <__divsf3_pse+0x8e>
    707e:	fe 2f       	mov	r31, r30
    7080:	27 d0       	rcall	.+78     	; 0x70d0 <__divsf3_pse+0x8e>
    7082:	66 0f       	add	r22, r22
    7084:	77 1f       	adc	r23, r23
    7086:	88 1f       	adc	r24, r24
    7088:	bb 1f       	adc	r27, r27
    708a:	26 17       	cp	r18, r22
    708c:	37 07       	cpc	r19, r23
    708e:	48 07       	cpc	r20, r24
    7090:	ab 07       	cpc	r26, r27
    7092:	b0 e8       	ldi	r27, 0x80	; 128
    7094:	09 f0       	breq	.+2      	; 0x7098 <__divsf3_pse+0x56>
    7096:	bb 0b       	sbc	r27, r27
    7098:	80 2d       	mov	r24, r0
    709a:	bf 01       	movw	r22, r30
    709c:	ff 27       	eor	r31, r31
    709e:	93 58       	subi	r25, 0x83	; 131
    70a0:	5f 4f       	sbci	r21, 0xFF	; 255
    70a2:	2a f0       	brmi	.+10     	; 0x70ae <__divsf3_pse+0x6c>
    70a4:	9e 3f       	cpi	r25, 0xFE	; 254
    70a6:	51 05       	cpc	r21, r1
    70a8:	68 f0       	brcs	.+26     	; 0x70c4 <__divsf3_pse+0x82>
    70aa:	8d c0       	rjmp	.+282    	; 0x71c6 <__fp_inf>
    70ac:	d7 c0       	rjmp	.+430    	; 0x725c <__fp_szero>
    70ae:	5f 3f       	cpi	r21, 0xFF	; 255
    70b0:	ec f3       	brlt	.-6      	; 0x70ac <__divsf3_pse+0x6a>
    70b2:	98 3e       	cpi	r25, 0xE8	; 232
    70b4:	dc f3       	brlt	.-10     	; 0x70ac <__divsf3_pse+0x6a>
    70b6:	86 95       	lsr	r24
    70b8:	77 95       	ror	r23
    70ba:	67 95       	ror	r22
    70bc:	b7 95       	ror	r27
    70be:	f7 95       	ror	r31
    70c0:	9f 5f       	subi	r25, 0xFF	; 255
    70c2:	c9 f7       	brne	.-14     	; 0x70b6 <__divsf3_pse+0x74>
    70c4:	88 0f       	add	r24, r24
    70c6:	91 1d       	adc	r25, r1
    70c8:	96 95       	lsr	r25
    70ca:	87 95       	ror	r24
    70cc:	97 f9       	bld	r25, 7
    70ce:	08 95       	ret
    70d0:	e1 e0       	ldi	r30, 0x01	; 1
    70d2:	66 0f       	add	r22, r22
    70d4:	77 1f       	adc	r23, r23
    70d6:	88 1f       	adc	r24, r24
    70d8:	bb 1f       	adc	r27, r27
    70da:	62 17       	cp	r22, r18
    70dc:	73 07       	cpc	r23, r19
    70de:	84 07       	cpc	r24, r20
    70e0:	ba 07       	cpc	r27, r26
    70e2:	20 f0       	brcs	.+8      	; 0x70ec <__divsf3_pse+0xaa>
    70e4:	62 1b       	sub	r22, r18
    70e6:	73 0b       	sbc	r23, r19
    70e8:	84 0b       	sbc	r24, r20
    70ea:	ba 0b       	sbc	r27, r26
    70ec:	ee 1f       	adc	r30, r30
    70ee:	88 f7       	brcc	.-30     	; 0x70d2 <__divsf3_pse+0x90>
    70f0:	e0 95       	com	r30
    70f2:	08 95       	ret

000070f4 <__fixunssfsi>:
    70f4:	98 d0       	rcall	.+304    	; 0x7226 <__fp_splitA>
    70f6:	88 f0       	brcs	.+34     	; 0x711a <__fixunssfsi+0x26>
    70f8:	9f 57       	subi	r25, 0x7F	; 127
    70fa:	90 f0       	brcs	.+36     	; 0x7120 <__fixunssfsi+0x2c>
    70fc:	b9 2f       	mov	r27, r25
    70fe:	99 27       	eor	r25, r25
    7100:	b7 51       	subi	r27, 0x17	; 23
    7102:	a0 f0       	brcs	.+40     	; 0x712c <__fixunssfsi+0x38>
    7104:	d1 f0       	breq	.+52     	; 0x713a <__fixunssfsi+0x46>
    7106:	66 0f       	add	r22, r22
    7108:	77 1f       	adc	r23, r23
    710a:	88 1f       	adc	r24, r24
    710c:	99 1f       	adc	r25, r25
    710e:	1a f0       	brmi	.+6      	; 0x7116 <__fixunssfsi+0x22>
    7110:	ba 95       	dec	r27
    7112:	c9 f7       	brne	.-14     	; 0x7106 <__fixunssfsi+0x12>
    7114:	12 c0       	rjmp	.+36     	; 0x713a <__fixunssfsi+0x46>
    7116:	b1 30       	cpi	r27, 0x01	; 1
    7118:	81 f0       	breq	.+32     	; 0x713a <__fixunssfsi+0x46>
    711a:	9f d0       	rcall	.+318    	; 0x725a <__fp_zero>
    711c:	b1 e0       	ldi	r27, 0x01	; 1
    711e:	08 95       	ret
    7120:	9c c0       	rjmp	.+312    	; 0x725a <__fp_zero>
    7122:	67 2f       	mov	r22, r23
    7124:	78 2f       	mov	r23, r24
    7126:	88 27       	eor	r24, r24
    7128:	b8 5f       	subi	r27, 0xF8	; 248
    712a:	39 f0       	breq	.+14     	; 0x713a <__fixunssfsi+0x46>
    712c:	b9 3f       	cpi	r27, 0xF9	; 249
    712e:	cc f3       	brlt	.-14     	; 0x7122 <__fixunssfsi+0x2e>
    7130:	86 95       	lsr	r24
    7132:	77 95       	ror	r23
    7134:	67 95       	ror	r22
    7136:	b3 95       	inc	r27
    7138:	d9 f7       	brne	.-10     	; 0x7130 <__fixunssfsi+0x3c>
    713a:	3e f4       	brtc	.+14     	; 0x714a <__fixunssfsi+0x56>
    713c:	90 95       	com	r25
    713e:	80 95       	com	r24
    7140:	70 95       	com	r23
    7142:	61 95       	neg	r22
    7144:	7f 4f       	sbci	r23, 0xFF	; 255
    7146:	8f 4f       	sbci	r24, 0xFF	; 255
    7148:	9f 4f       	sbci	r25, 0xFF	; 255
    714a:	08 95       	ret

0000714c <__floatunsisf>:
    714c:	e8 94       	clt
    714e:	09 c0       	rjmp	.+18     	; 0x7162 <__floatsisf+0x12>

00007150 <__floatsisf>:
    7150:	97 fb       	bst	r25, 7
    7152:	3e f4       	brtc	.+14     	; 0x7162 <__floatsisf+0x12>
    7154:	90 95       	com	r25
    7156:	80 95       	com	r24
    7158:	70 95       	com	r23
    715a:	61 95       	neg	r22
    715c:	7f 4f       	sbci	r23, 0xFF	; 255
    715e:	8f 4f       	sbci	r24, 0xFF	; 255
    7160:	9f 4f       	sbci	r25, 0xFF	; 255
    7162:	99 23       	and	r25, r25
    7164:	a9 f0       	breq	.+42     	; 0x7190 <__floatsisf+0x40>
    7166:	f9 2f       	mov	r31, r25
    7168:	96 e9       	ldi	r25, 0x96	; 150
    716a:	bb 27       	eor	r27, r27
    716c:	93 95       	inc	r25
    716e:	f6 95       	lsr	r31
    7170:	87 95       	ror	r24
    7172:	77 95       	ror	r23
    7174:	67 95       	ror	r22
    7176:	b7 95       	ror	r27
    7178:	f1 11       	cpse	r31, r1
    717a:	f8 cf       	rjmp	.-16     	; 0x716c <__floatsisf+0x1c>
    717c:	fa f4       	brpl	.+62     	; 0x71bc <__floatsisf+0x6c>
    717e:	bb 0f       	add	r27, r27
    7180:	11 f4       	brne	.+4      	; 0x7186 <__floatsisf+0x36>
    7182:	60 ff       	sbrs	r22, 0
    7184:	1b c0       	rjmp	.+54     	; 0x71bc <__floatsisf+0x6c>
    7186:	6f 5f       	subi	r22, 0xFF	; 255
    7188:	7f 4f       	sbci	r23, 0xFF	; 255
    718a:	8f 4f       	sbci	r24, 0xFF	; 255
    718c:	9f 4f       	sbci	r25, 0xFF	; 255
    718e:	16 c0       	rjmp	.+44     	; 0x71bc <__floatsisf+0x6c>
    7190:	88 23       	and	r24, r24
    7192:	11 f0       	breq	.+4      	; 0x7198 <__floatsisf+0x48>
    7194:	96 e9       	ldi	r25, 0x96	; 150
    7196:	11 c0       	rjmp	.+34     	; 0x71ba <__floatsisf+0x6a>
    7198:	77 23       	and	r23, r23
    719a:	21 f0       	breq	.+8      	; 0x71a4 <__floatsisf+0x54>
    719c:	9e e8       	ldi	r25, 0x8E	; 142
    719e:	87 2f       	mov	r24, r23
    71a0:	76 2f       	mov	r23, r22
    71a2:	05 c0       	rjmp	.+10     	; 0x71ae <__floatsisf+0x5e>
    71a4:	66 23       	and	r22, r22
    71a6:	71 f0       	breq	.+28     	; 0x71c4 <__floatsisf+0x74>
    71a8:	96 e8       	ldi	r25, 0x86	; 134
    71aa:	86 2f       	mov	r24, r22
    71ac:	70 e0       	ldi	r23, 0x00	; 0
    71ae:	60 e0       	ldi	r22, 0x00	; 0
    71b0:	2a f0       	brmi	.+10     	; 0x71bc <__floatsisf+0x6c>
    71b2:	9a 95       	dec	r25
    71b4:	66 0f       	add	r22, r22
    71b6:	77 1f       	adc	r23, r23
    71b8:	88 1f       	adc	r24, r24
    71ba:	da f7       	brpl	.-10     	; 0x71b2 <__floatsisf+0x62>
    71bc:	88 0f       	add	r24, r24
    71be:	96 95       	lsr	r25
    71c0:	87 95       	ror	r24
    71c2:	97 f9       	bld	r25, 7
    71c4:	08 95       	ret

000071c6 <__fp_inf>:
    71c6:	97 f9       	bld	r25, 7
    71c8:	9f 67       	ori	r25, 0x7F	; 127
    71ca:	80 e8       	ldi	r24, 0x80	; 128
    71cc:	70 e0       	ldi	r23, 0x00	; 0
    71ce:	60 e0       	ldi	r22, 0x00	; 0
    71d0:	08 95       	ret

000071d2 <__fp_nan>:
    71d2:	9f ef       	ldi	r25, 0xFF	; 255
    71d4:	80 ec       	ldi	r24, 0xC0	; 192
    71d6:	08 95       	ret

000071d8 <__fp_pscA>:
    71d8:	00 24       	eor	r0, r0
    71da:	0a 94       	dec	r0
    71dc:	16 16       	cp	r1, r22
    71de:	17 06       	cpc	r1, r23
    71e0:	18 06       	cpc	r1, r24
    71e2:	09 06       	cpc	r0, r25
    71e4:	08 95       	ret

000071e6 <__fp_pscB>:
    71e6:	00 24       	eor	r0, r0
    71e8:	0a 94       	dec	r0
    71ea:	12 16       	cp	r1, r18
    71ec:	13 06       	cpc	r1, r19
    71ee:	14 06       	cpc	r1, r20
    71f0:	05 06       	cpc	r0, r21
    71f2:	08 95       	ret

000071f4 <__fp_round>:
    71f4:	09 2e       	mov	r0, r25
    71f6:	03 94       	inc	r0
    71f8:	00 0c       	add	r0, r0
    71fa:	11 f4       	brne	.+4      	; 0x7200 <__fp_round+0xc>
    71fc:	88 23       	and	r24, r24
    71fe:	52 f0       	brmi	.+20     	; 0x7214 <__fp_round+0x20>
    7200:	bb 0f       	add	r27, r27
    7202:	40 f4       	brcc	.+16     	; 0x7214 <__fp_round+0x20>
    7204:	bf 2b       	or	r27, r31
    7206:	11 f4       	brne	.+4      	; 0x720c <__fp_round+0x18>
    7208:	60 ff       	sbrs	r22, 0
    720a:	04 c0       	rjmp	.+8      	; 0x7214 <__fp_round+0x20>
    720c:	6f 5f       	subi	r22, 0xFF	; 255
    720e:	7f 4f       	sbci	r23, 0xFF	; 255
    7210:	8f 4f       	sbci	r24, 0xFF	; 255
    7212:	9f 4f       	sbci	r25, 0xFF	; 255
    7214:	08 95       	ret

00007216 <__fp_split3>:
    7216:	57 fd       	sbrc	r21, 7
    7218:	90 58       	subi	r25, 0x80	; 128
    721a:	44 0f       	add	r20, r20
    721c:	55 1f       	adc	r21, r21
    721e:	59 f0       	breq	.+22     	; 0x7236 <__fp_splitA+0x10>
    7220:	5f 3f       	cpi	r21, 0xFF	; 255
    7222:	71 f0       	breq	.+28     	; 0x7240 <__fp_splitA+0x1a>
    7224:	47 95       	ror	r20

00007226 <__fp_splitA>:
    7226:	88 0f       	add	r24, r24
    7228:	97 fb       	bst	r25, 7
    722a:	99 1f       	adc	r25, r25
    722c:	61 f0       	breq	.+24     	; 0x7246 <__fp_splitA+0x20>
    722e:	9f 3f       	cpi	r25, 0xFF	; 255
    7230:	79 f0       	breq	.+30     	; 0x7250 <__fp_splitA+0x2a>
    7232:	87 95       	ror	r24
    7234:	08 95       	ret
    7236:	12 16       	cp	r1, r18
    7238:	13 06       	cpc	r1, r19
    723a:	14 06       	cpc	r1, r20
    723c:	55 1f       	adc	r21, r21
    723e:	f2 cf       	rjmp	.-28     	; 0x7224 <__fp_split3+0xe>
    7240:	46 95       	lsr	r20
    7242:	f1 df       	rcall	.-30     	; 0x7226 <__fp_splitA>
    7244:	08 c0       	rjmp	.+16     	; 0x7256 <__fp_splitA+0x30>
    7246:	16 16       	cp	r1, r22
    7248:	17 06       	cpc	r1, r23
    724a:	18 06       	cpc	r1, r24
    724c:	99 1f       	adc	r25, r25
    724e:	f1 cf       	rjmp	.-30     	; 0x7232 <__fp_splitA+0xc>
    7250:	86 95       	lsr	r24
    7252:	71 05       	cpc	r23, r1
    7254:	61 05       	cpc	r22, r1
    7256:	08 94       	sec
    7258:	08 95       	ret

0000725a <__fp_zero>:
    725a:	e8 94       	clt

0000725c <__fp_szero>:
    725c:	bb 27       	eor	r27, r27
    725e:	66 27       	eor	r22, r22
    7260:	77 27       	eor	r23, r23
    7262:	cb 01       	movw	r24, r22
    7264:	97 f9       	bld	r25, 7
    7266:	08 95       	ret

00007268 <__gesf2>:
    7268:	03 d0       	rcall	.+6      	; 0x7270 <__fp_cmp>
    726a:	08 f4       	brcc	.+2      	; 0x726e <__gesf2+0x6>
    726c:	8f ef       	ldi	r24, 0xFF	; 255
    726e:	08 95       	ret

00007270 <__fp_cmp>:
    7270:	99 0f       	add	r25, r25
    7272:	00 08       	sbc	r0, r0
    7274:	55 0f       	add	r21, r21
    7276:	aa 0b       	sbc	r26, r26
    7278:	e0 e8       	ldi	r30, 0x80	; 128
    727a:	fe ef       	ldi	r31, 0xFE	; 254
    727c:	16 16       	cp	r1, r22
    727e:	17 06       	cpc	r1, r23
    7280:	e8 07       	cpc	r30, r24
    7282:	f9 07       	cpc	r31, r25
    7284:	c0 f0       	brcs	.+48     	; 0x72b6 <__fp_cmp+0x46>
    7286:	12 16       	cp	r1, r18
    7288:	13 06       	cpc	r1, r19
    728a:	e4 07       	cpc	r30, r20
    728c:	f5 07       	cpc	r31, r21
    728e:	98 f0       	brcs	.+38     	; 0x72b6 <__fp_cmp+0x46>
    7290:	62 1b       	sub	r22, r18
    7292:	73 0b       	sbc	r23, r19
    7294:	84 0b       	sbc	r24, r20
    7296:	95 0b       	sbc	r25, r21
    7298:	39 f4       	brne	.+14     	; 0x72a8 <__fp_cmp+0x38>
    729a:	0a 26       	eor	r0, r26
    729c:	61 f0       	breq	.+24     	; 0x72b6 <__fp_cmp+0x46>
    729e:	23 2b       	or	r18, r19
    72a0:	24 2b       	or	r18, r20
    72a2:	25 2b       	or	r18, r21
    72a4:	21 f4       	brne	.+8      	; 0x72ae <__fp_cmp+0x3e>
    72a6:	08 95       	ret
    72a8:	0a 26       	eor	r0, r26
    72aa:	09 f4       	brne	.+2      	; 0x72ae <__fp_cmp+0x3e>
    72ac:	a1 40       	sbci	r26, 0x01	; 1
    72ae:	a6 95       	lsr	r26
    72b0:	8f ef       	ldi	r24, 0xFF	; 255
    72b2:	81 1d       	adc	r24, r1
    72b4:	81 1d       	adc	r24, r1
    72b6:	08 95       	ret

000072b8 <__mulsi3>:
    72b8:	62 9f       	mul	r22, r18
    72ba:	d0 01       	movw	r26, r0
    72bc:	73 9f       	mul	r23, r19
    72be:	f0 01       	movw	r30, r0
    72c0:	82 9f       	mul	r24, r18
    72c2:	e0 0d       	add	r30, r0
    72c4:	f1 1d       	adc	r31, r1
    72c6:	64 9f       	mul	r22, r20
    72c8:	e0 0d       	add	r30, r0
    72ca:	f1 1d       	adc	r31, r1
    72cc:	92 9f       	mul	r25, r18
    72ce:	f0 0d       	add	r31, r0
    72d0:	83 9f       	mul	r24, r19
    72d2:	f0 0d       	add	r31, r0
    72d4:	74 9f       	mul	r23, r20
    72d6:	f0 0d       	add	r31, r0
    72d8:	65 9f       	mul	r22, r21
    72da:	f0 0d       	add	r31, r0
    72dc:	99 27       	eor	r25, r25
    72de:	72 9f       	mul	r23, r18
    72e0:	b0 0d       	add	r27, r0
    72e2:	e1 1d       	adc	r30, r1
    72e4:	f9 1f       	adc	r31, r25
    72e6:	63 9f       	mul	r22, r19
    72e8:	b0 0d       	add	r27, r0
    72ea:	e1 1d       	adc	r30, r1
    72ec:	f9 1f       	adc	r31, r25
    72ee:	bd 01       	movw	r22, r26
    72f0:	cf 01       	movw	r24, r30
    72f2:	11 24       	eor	r1, r1
    72f4:	08 95       	ret

000072f6 <__divmodhi4>:
    72f6:	97 fb       	bst	r25, 7
    72f8:	09 2e       	mov	r0, r25
    72fa:	07 26       	eor	r0, r23
    72fc:	0a d0       	rcall	.+20     	; 0x7312 <__divmodhi4_neg1>
    72fe:	77 fd       	sbrc	r23, 7
    7300:	04 d0       	rcall	.+8      	; 0x730a <__divmodhi4_neg2>
    7302:	49 d0       	rcall	.+146    	; 0x7396 <__udivmodhi4>
    7304:	06 d0       	rcall	.+12     	; 0x7312 <__divmodhi4_neg1>
    7306:	00 20       	and	r0, r0
    7308:	1a f4       	brpl	.+6      	; 0x7310 <__divmodhi4_exit>

0000730a <__divmodhi4_neg2>:
    730a:	70 95       	com	r23
    730c:	61 95       	neg	r22
    730e:	7f 4f       	sbci	r23, 0xFF	; 255

00007310 <__divmodhi4_exit>:
    7310:	08 95       	ret

00007312 <__divmodhi4_neg1>:
    7312:	f6 f7       	brtc	.-4      	; 0x7310 <__divmodhi4_exit>
    7314:	90 95       	com	r25
    7316:	81 95       	neg	r24
    7318:	9f 4f       	sbci	r25, 0xFF	; 255
    731a:	08 95       	ret

0000731c <__udivmodsi4>:
    731c:	a1 e2       	ldi	r26, 0x21	; 33
    731e:	1a 2e       	mov	r1, r26
    7320:	aa 1b       	sub	r26, r26
    7322:	bb 1b       	sub	r27, r27
    7324:	fd 01       	movw	r30, r26
    7326:	0d c0       	rjmp	.+26     	; 0x7342 <__udivmodsi4_ep>

00007328 <__udivmodsi4_loop>:
    7328:	aa 1f       	adc	r26, r26
    732a:	bb 1f       	adc	r27, r27
    732c:	ee 1f       	adc	r30, r30
    732e:	ff 1f       	adc	r31, r31
    7330:	a2 17       	cp	r26, r18
    7332:	b3 07       	cpc	r27, r19
    7334:	e4 07       	cpc	r30, r20
    7336:	f5 07       	cpc	r31, r21
    7338:	20 f0       	brcs	.+8      	; 0x7342 <__udivmodsi4_ep>
    733a:	a2 1b       	sub	r26, r18
    733c:	b3 0b       	sbc	r27, r19
    733e:	e4 0b       	sbc	r30, r20
    7340:	f5 0b       	sbc	r31, r21

00007342 <__udivmodsi4_ep>:
    7342:	66 1f       	adc	r22, r22
    7344:	77 1f       	adc	r23, r23
    7346:	88 1f       	adc	r24, r24
    7348:	99 1f       	adc	r25, r25
    734a:	1a 94       	dec	r1
    734c:	69 f7       	brne	.-38     	; 0x7328 <__udivmodsi4_loop>
    734e:	60 95       	com	r22
    7350:	70 95       	com	r23
    7352:	80 95       	com	r24
    7354:	90 95       	com	r25
    7356:	9b 01       	movw	r18, r22
    7358:	ac 01       	movw	r20, r24
    735a:	bd 01       	movw	r22, r26
    735c:	cf 01       	movw	r24, r30
    735e:	08 95       	ret

00007360 <__divmodsi4>:
    7360:	97 fb       	bst	r25, 7
    7362:	09 2e       	mov	r0, r25
    7364:	05 26       	eor	r0, r21
    7366:	0e d0       	rcall	.+28     	; 0x7384 <__divmodsi4_neg1>
    7368:	57 fd       	sbrc	r21, 7
    736a:	04 d0       	rcall	.+8      	; 0x7374 <__divmodsi4_neg2>
    736c:	d7 df       	rcall	.-82     	; 0x731c <__udivmodsi4>
    736e:	0a d0       	rcall	.+20     	; 0x7384 <__divmodsi4_neg1>
    7370:	00 1c       	adc	r0, r0
    7372:	38 f4       	brcc	.+14     	; 0x7382 <__divmodsi4_exit>

00007374 <__divmodsi4_neg2>:
    7374:	50 95       	com	r21
    7376:	40 95       	com	r20
    7378:	30 95       	com	r19
    737a:	21 95       	neg	r18
    737c:	3f 4f       	sbci	r19, 0xFF	; 255
    737e:	4f 4f       	sbci	r20, 0xFF	; 255
    7380:	5f 4f       	sbci	r21, 0xFF	; 255

00007382 <__divmodsi4_exit>:
    7382:	08 95       	ret

00007384 <__divmodsi4_neg1>:
    7384:	f6 f7       	brtc	.-4      	; 0x7382 <__divmodsi4_exit>
    7386:	90 95       	com	r25
    7388:	80 95       	com	r24
    738a:	70 95       	com	r23
    738c:	61 95       	neg	r22
    738e:	7f 4f       	sbci	r23, 0xFF	; 255
    7390:	8f 4f       	sbci	r24, 0xFF	; 255
    7392:	9f 4f       	sbci	r25, 0xFF	; 255
    7394:	08 95       	ret

00007396 <__udivmodhi4>:
    7396:	aa 1b       	sub	r26, r26
    7398:	bb 1b       	sub	r27, r27
    739a:	51 e1       	ldi	r21, 0x11	; 17
    739c:	07 c0       	rjmp	.+14     	; 0x73ac <__udivmodhi4_ep>

0000739e <__udivmodhi4_loop>:
    739e:	aa 1f       	adc	r26, r26
    73a0:	bb 1f       	adc	r27, r27
    73a2:	a6 17       	cp	r26, r22
    73a4:	b7 07       	cpc	r27, r23
    73a6:	10 f0       	brcs	.+4      	; 0x73ac <__udivmodhi4_ep>
    73a8:	a6 1b       	sub	r26, r22
    73aa:	b7 0b       	sbc	r27, r23

000073ac <__udivmodhi4_ep>:
    73ac:	88 1f       	adc	r24, r24
    73ae:	99 1f       	adc	r25, r25
    73b0:	5a 95       	dec	r21
    73b2:	a9 f7       	brne	.-22     	; 0x739e <__udivmodhi4_loop>
    73b4:	80 95       	com	r24
    73b6:	90 95       	com	r25
    73b8:	bc 01       	movw	r22, r24
    73ba:	cd 01       	movw	r24, r26
    73bc:	08 95       	ret

000073be <__prologue_saves__>:
    73be:	2f 92       	push	r2
    73c0:	3f 92       	push	r3
    73c2:	4f 92       	push	r4
    73c4:	5f 92       	push	r5
    73c6:	6f 92       	push	r6
    73c8:	7f 92       	push	r7
    73ca:	8f 92       	push	r8
    73cc:	9f 92       	push	r9
    73ce:	af 92       	push	r10
    73d0:	bf 92       	push	r11
    73d2:	cf 92       	push	r12
    73d4:	df 92       	push	r13
    73d6:	ef 92       	push	r14
    73d8:	ff 92       	push	r15
    73da:	0f 93       	push	r16
    73dc:	1f 93       	push	r17
    73de:	cf 93       	push	r28
    73e0:	df 93       	push	r29
    73e2:	cd b7       	in	r28, 0x3d	; 61
    73e4:	de b7       	in	r29, 0x3e	; 62
    73e6:	ca 1b       	sub	r28, r26
    73e8:	db 0b       	sbc	r29, r27
    73ea:	cd bf       	out	0x3d, r28	; 61
    73ec:	de bf       	out	0x3e, r29	; 62
    73ee:	19 94       	eijmp

000073f0 <__epilogue_restores__>:
    73f0:	2a 88       	ldd	r2, Y+18	; 0x12
    73f2:	39 88       	ldd	r3, Y+17	; 0x11
    73f4:	48 88       	ldd	r4, Y+16	; 0x10
    73f6:	5f 84       	ldd	r5, Y+15	; 0x0f
    73f8:	6e 84       	ldd	r6, Y+14	; 0x0e
    73fa:	7d 84       	ldd	r7, Y+13	; 0x0d
    73fc:	8c 84       	ldd	r8, Y+12	; 0x0c
    73fe:	9b 84       	ldd	r9, Y+11	; 0x0b
    7400:	aa 84       	ldd	r10, Y+10	; 0x0a
    7402:	b9 84       	ldd	r11, Y+9	; 0x09
    7404:	c8 84       	ldd	r12, Y+8	; 0x08
    7406:	df 80       	ldd	r13, Y+7	; 0x07
    7408:	ee 80       	ldd	r14, Y+6	; 0x06
    740a:	fd 80       	ldd	r15, Y+5	; 0x05
    740c:	0c 81       	ldd	r16, Y+4	; 0x04
    740e:	1b 81       	ldd	r17, Y+3	; 0x03
    7410:	aa 81       	ldd	r26, Y+2	; 0x02
    7412:	b9 81       	ldd	r27, Y+1	; 0x01
    7414:	ce 0f       	add	r28, r30
    7416:	d1 1d       	adc	r29, r1
    7418:	cd bf       	out	0x3d, r28	; 61
    741a:	de bf       	out	0x3e, r29	; 62
    741c:	ed 01       	movw	r28, r26
    741e:	08 95       	ret

00007420 <strcpy_P>:
    7420:	fb 01       	movw	r30, r22
    7422:	dc 01       	movw	r26, r24
    7424:	05 90       	lpm	r0, Z+
    7426:	0d 92       	st	X+, r0
    7428:	00 20       	and	r0, r0
    742a:	e1 f7       	brne	.-8      	; 0x7424 <strcpy_P+0x4>
    742c:	08 95       	ret

0000742e <memmove>:
    742e:	68 17       	cp	r22, r24
    7430:	79 07       	cpc	r23, r25
    7432:	68 f4       	brcc	.+26     	; 0x744e <memmove+0x20>
    7434:	fb 01       	movw	r30, r22
    7436:	dc 01       	movw	r26, r24
    7438:	e4 0f       	add	r30, r20
    743a:	f5 1f       	adc	r31, r21
    743c:	a4 0f       	add	r26, r20
    743e:	b5 1f       	adc	r27, r21
    7440:	02 c0       	rjmp	.+4      	; 0x7446 <memmove+0x18>
    7442:	02 90       	ld	r0, -Z
    7444:	0e 92       	st	-X, r0
    7446:	41 50       	subi	r20, 0x01	; 1
    7448:	50 40       	sbci	r21, 0x00	; 0
    744a:	d8 f7       	brcc	.-10     	; 0x7442 <memmove+0x14>
    744c:	08 95       	ret
    744e:	0c 94 9c 3c 	jmp	0x7938	; 0x7938 <memcpy>

00007452 <strcat>:
    7452:	fb 01       	movw	r30, r22
    7454:	dc 01       	movw	r26, r24
    7456:	0d 90       	ld	r0, X+
    7458:	00 20       	and	r0, r0
    745a:	e9 f7       	brne	.-6      	; 0x7456 <strcat+0x4>
    745c:	11 97       	sbiw	r26, 0x01	; 1
    745e:	01 90       	ld	r0, Z+
    7460:	0d 92       	st	X+, r0
    7462:	00 20       	and	r0, r0
    7464:	e1 f7       	brne	.-8      	; 0x745e <strcat+0xc>
    7466:	08 95       	ret

00007468 <itoa>:
    7468:	fb 01       	movw	r30, r22
    746a:	9f 01       	movw	r18, r30
    746c:	e8 94       	clt
    746e:	42 30       	cpi	r20, 0x02	; 2
    7470:	c4 f0       	brlt	.+48     	; 0x74a2 <itoa+0x3a>
    7472:	45 32       	cpi	r20, 0x25	; 37
    7474:	b4 f4       	brge	.+44     	; 0x74a2 <itoa+0x3a>
    7476:	4a 30       	cpi	r20, 0x0A	; 10
    7478:	29 f4       	brne	.+10     	; 0x7484 <itoa+0x1c>
    747a:	97 fb       	bst	r25, 7
    747c:	1e f4       	brtc	.+6      	; 0x7484 <itoa+0x1c>
    747e:	90 95       	com	r25
    7480:	81 95       	neg	r24
    7482:	9f 4f       	sbci	r25, 0xFF	; 255
    7484:	64 2f       	mov	r22, r20
    7486:	77 27       	eor	r23, r23
    7488:	0e 94 cb 39 	call	0x7396	; 0x7396 <__udivmodhi4>
    748c:	80 5d       	subi	r24, 0xD0	; 208
    748e:	8a 33       	cpi	r24, 0x3A	; 58
    7490:	0c f0       	brlt	.+2      	; 0x7494 <itoa+0x2c>
    7492:	89 5d       	subi	r24, 0xD9	; 217
    7494:	81 93       	st	Z+, r24
    7496:	cb 01       	movw	r24, r22
    7498:	00 97       	sbiw	r24, 0x00	; 0
    749a:	a1 f7       	brne	.-24     	; 0x7484 <itoa+0x1c>
    749c:	16 f4       	brtc	.+4      	; 0x74a2 <itoa+0x3a>
    749e:	5d e2       	ldi	r21, 0x2D	; 45
    74a0:	51 93       	st	Z+, r21
    74a2:	10 82       	st	Z, r1
    74a4:	c9 01       	movw	r24, r18
    74a6:	0c 94 b0 3c 	jmp	0x7960	; 0x7960 <strrev>

000074aa <printf>:
    74aa:	cf 93       	push	r28
    74ac:	df 93       	push	r29
    74ae:	cd b7       	in	r28, 0x3d	; 61
    74b0:	de b7       	in	r29, 0x3e	; 62
    74b2:	fe 01       	movw	r30, r28
    74b4:	36 96       	adiw	r30, 0x06	; 6
    74b6:	61 91       	ld	r22, Z+
    74b8:	71 91       	ld	r23, Z+
    74ba:	80 91 b8 50 	lds	r24, 0x50B8
    74be:	90 91 b9 50 	lds	r25, 0x50B9
    74c2:	af 01       	movw	r20, r30
    74c4:	0e 94 90 3a 	call	0x7520	; 0x7520 <vfprintf>
    74c8:	df 91       	pop	r29
    74ca:	cf 91       	pop	r28
    74cc:	08 95       	ret

000074ce <sprintf>:
    74ce:	0f 93       	push	r16
    74d0:	1f 93       	push	r17
    74d2:	cf 93       	push	r28
    74d4:	df 93       	push	r29
    74d6:	cd b7       	in	r28, 0x3d	; 61
    74d8:	de b7       	in	r29, 0x3e	; 62
    74da:	2e 97       	sbiw	r28, 0x0e	; 14
    74dc:	cd bf       	out	0x3d, r28	; 61
    74de:	de bf       	out	0x3e, r29	; 62
    74e0:	0e 89       	ldd	r16, Y+22	; 0x16
    74e2:	1f 89       	ldd	r17, Y+23	; 0x17
    74e4:	86 e0       	ldi	r24, 0x06	; 6
    74e6:	8c 83       	std	Y+4, r24	; 0x04
    74e8:	09 83       	std	Y+1, r16	; 0x01
    74ea:	1a 83       	std	Y+2, r17	; 0x02
    74ec:	8f ef       	ldi	r24, 0xFF	; 255
    74ee:	9f e7       	ldi	r25, 0x7F	; 127
    74f0:	8d 83       	std	Y+5, r24	; 0x05
    74f2:	9e 83       	std	Y+6, r25	; 0x06
    74f4:	ae 01       	movw	r20, r28
    74f6:	46 5e       	subi	r20, 0xE6	; 230
    74f8:	5f 4f       	sbci	r21, 0xFF	; 255
    74fa:	ce 01       	movw	r24, r28
    74fc:	01 96       	adiw	r24, 0x01	; 1
    74fe:	68 8d       	ldd	r22, Y+24	; 0x18
    7500:	79 8d       	ldd	r23, Y+25	; 0x19
    7502:	0e 94 90 3a 	call	0x7520	; 0x7520 <vfprintf>
    7506:	ef 81       	ldd	r30, Y+7	; 0x07
    7508:	f8 85       	ldd	r31, Y+8	; 0x08
    750a:	e0 0f       	add	r30, r16
    750c:	f1 1f       	adc	r31, r17
    750e:	10 82       	st	Z, r1
    7510:	2e 96       	adiw	r28, 0x0e	; 14
    7512:	cd bf       	out	0x3d, r28	; 61
    7514:	de bf       	out	0x3e, r29	; 62
    7516:	df 91       	pop	r29
    7518:	cf 91       	pop	r28
    751a:	1f 91       	pop	r17
    751c:	0f 91       	pop	r16
    751e:	08 95       	ret

00007520 <vfprintf>:
    7520:	2f 92       	push	r2
    7522:	3f 92       	push	r3
    7524:	4f 92       	push	r4
    7526:	5f 92       	push	r5
    7528:	6f 92       	push	r6
    752a:	7f 92       	push	r7
    752c:	8f 92       	push	r8
    752e:	9f 92       	push	r9
    7530:	af 92       	push	r10
    7532:	bf 92       	push	r11
    7534:	cf 92       	push	r12
    7536:	df 92       	push	r13
    7538:	ef 92       	push	r14
    753a:	ff 92       	push	r15
    753c:	0f 93       	push	r16
    753e:	1f 93       	push	r17
    7540:	cf 93       	push	r28
    7542:	df 93       	push	r29
    7544:	cd b7       	in	r28, 0x3d	; 61
    7546:	de b7       	in	r29, 0x3e	; 62
    7548:	2d 97       	sbiw	r28, 0x0d	; 13
    754a:	cd bf       	out	0x3d, r28	; 61
    754c:	de bf       	out	0x3e, r29	; 62
    754e:	3c 01       	movw	r6, r24
    7550:	6c 87       	std	Y+12, r22	; 0x0c
    7552:	7d 87       	std	Y+13, r23	; 0x0d
    7554:	5a 01       	movw	r10, r20
    7556:	fc 01       	movw	r30, r24
    7558:	16 82       	std	Z+6, r1	; 0x06
    755a:	17 82       	std	Z+7, r1	; 0x07
    755c:	83 81       	ldd	r24, Z+3	; 0x03
    755e:	81 ff       	sbrs	r24, 1
    7560:	c8 c1       	rjmp	.+912    	; 0x78f2 <vfprintf+0x3d2>
    7562:	2e 01       	movw	r4, r28
    7564:	08 94       	sec
    7566:	41 1c       	adc	r4, r1
    7568:	51 1c       	adc	r5, r1
    756a:	f3 01       	movw	r30, r6
    756c:	93 81       	ldd	r25, Z+3	; 0x03
    756e:	ec 85       	ldd	r30, Y+12	; 0x0c
    7570:	fd 85       	ldd	r31, Y+13	; 0x0d
    7572:	93 fd       	sbrc	r25, 3
    7574:	85 91       	lpm	r24, Z+
    7576:	93 ff       	sbrs	r25, 3
    7578:	81 91       	ld	r24, Z+
    757a:	ec 87       	std	Y+12, r30	; 0x0c
    757c:	fd 87       	std	Y+13, r31	; 0x0d
    757e:	88 23       	and	r24, r24
    7580:	09 f4       	brne	.+2      	; 0x7584 <vfprintf+0x64>
    7582:	b3 c1       	rjmp	.+870    	; 0x78ea <vfprintf+0x3ca>
    7584:	85 32       	cpi	r24, 0x25	; 37
    7586:	41 f4       	brne	.+16     	; 0x7598 <vfprintf+0x78>
    7588:	93 fd       	sbrc	r25, 3
    758a:	85 91       	lpm	r24, Z+
    758c:	93 ff       	sbrs	r25, 3
    758e:	81 91       	ld	r24, Z+
    7590:	ec 87       	std	Y+12, r30	; 0x0c
    7592:	fd 87       	std	Y+13, r31	; 0x0d
    7594:	85 32       	cpi	r24, 0x25	; 37
    7596:	29 f4       	brne	.+10     	; 0x75a2 <vfprintf+0x82>
    7598:	90 e0       	ldi	r25, 0x00	; 0
    759a:	b3 01       	movw	r22, r6
    759c:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    75a0:	e4 cf       	rjmp	.-56     	; 0x756a <vfprintf+0x4a>
    75a2:	ff 24       	eor	r15, r15
    75a4:	ee 24       	eor	r14, r14
    75a6:	10 e0       	ldi	r17, 0x00	; 0
    75a8:	10 32       	cpi	r17, 0x20	; 32
    75aa:	b0 f4       	brcc	.+44     	; 0x75d8 <vfprintf+0xb8>
    75ac:	8b 32       	cpi	r24, 0x2B	; 43
    75ae:	69 f0       	breq	.+26     	; 0x75ca <vfprintf+0xaa>
    75b0:	8c 32       	cpi	r24, 0x2C	; 44
    75b2:	28 f4       	brcc	.+10     	; 0x75be <vfprintf+0x9e>
    75b4:	80 32       	cpi	r24, 0x20	; 32
    75b6:	51 f0       	breq	.+20     	; 0x75cc <vfprintf+0xac>
    75b8:	83 32       	cpi	r24, 0x23	; 35
    75ba:	71 f4       	brne	.+28     	; 0x75d8 <vfprintf+0xb8>
    75bc:	0b c0       	rjmp	.+22     	; 0x75d4 <vfprintf+0xb4>
    75be:	8d 32       	cpi	r24, 0x2D	; 45
    75c0:	39 f0       	breq	.+14     	; 0x75d0 <vfprintf+0xb0>
    75c2:	80 33       	cpi	r24, 0x30	; 48
    75c4:	49 f4       	brne	.+18     	; 0x75d8 <vfprintf+0xb8>
    75c6:	11 60       	ori	r17, 0x01	; 1
    75c8:	2c c0       	rjmp	.+88     	; 0x7622 <vfprintf+0x102>
    75ca:	12 60       	ori	r17, 0x02	; 2
    75cc:	14 60       	ori	r17, 0x04	; 4
    75ce:	29 c0       	rjmp	.+82     	; 0x7622 <vfprintf+0x102>
    75d0:	18 60       	ori	r17, 0x08	; 8
    75d2:	27 c0       	rjmp	.+78     	; 0x7622 <vfprintf+0x102>
    75d4:	10 61       	ori	r17, 0x10	; 16
    75d6:	25 c0       	rjmp	.+74     	; 0x7622 <vfprintf+0x102>
    75d8:	17 fd       	sbrc	r17, 7
    75da:	2e c0       	rjmp	.+92     	; 0x7638 <vfprintf+0x118>
    75dc:	28 2f       	mov	r18, r24
    75de:	20 53       	subi	r18, 0x30	; 48
    75e0:	2a 30       	cpi	r18, 0x0A	; 10
    75e2:	98 f4       	brcc	.+38     	; 0x760a <vfprintf+0xea>
    75e4:	16 ff       	sbrs	r17, 6
    75e6:	08 c0       	rjmp	.+16     	; 0x75f8 <vfprintf+0xd8>
    75e8:	8f 2d       	mov	r24, r15
    75ea:	88 0f       	add	r24, r24
    75ec:	f8 2e       	mov	r15, r24
    75ee:	ff 0c       	add	r15, r15
    75f0:	ff 0c       	add	r15, r15
    75f2:	f8 0e       	add	r15, r24
    75f4:	f2 0e       	add	r15, r18
    75f6:	15 c0       	rjmp	.+42     	; 0x7622 <vfprintf+0x102>
    75f8:	8e 2d       	mov	r24, r14
    75fa:	88 0f       	add	r24, r24
    75fc:	e8 2e       	mov	r14, r24
    75fe:	ee 0c       	add	r14, r14
    7600:	ee 0c       	add	r14, r14
    7602:	e8 0e       	add	r14, r24
    7604:	e2 0e       	add	r14, r18
    7606:	10 62       	ori	r17, 0x20	; 32
    7608:	0c c0       	rjmp	.+24     	; 0x7622 <vfprintf+0x102>
    760a:	8e 32       	cpi	r24, 0x2E	; 46
    760c:	21 f4       	brne	.+8      	; 0x7616 <vfprintf+0xf6>
    760e:	16 fd       	sbrc	r17, 6
    7610:	6c c1       	rjmp	.+728    	; 0x78ea <vfprintf+0x3ca>
    7612:	10 64       	ori	r17, 0x40	; 64
    7614:	06 c0       	rjmp	.+12     	; 0x7622 <vfprintf+0x102>
    7616:	8c 36       	cpi	r24, 0x6C	; 108
    7618:	11 f4       	brne	.+4      	; 0x761e <vfprintf+0xfe>
    761a:	10 68       	ori	r17, 0x80	; 128
    761c:	02 c0       	rjmp	.+4      	; 0x7622 <vfprintf+0x102>
    761e:	88 36       	cpi	r24, 0x68	; 104
    7620:	59 f4       	brne	.+22     	; 0x7638 <vfprintf+0x118>
    7622:	ec 85       	ldd	r30, Y+12	; 0x0c
    7624:	fd 85       	ldd	r31, Y+13	; 0x0d
    7626:	93 fd       	sbrc	r25, 3
    7628:	85 91       	lpm	r24, Z+
    762a:	93 ff       	sbrs	r25, 3
    762c:	81 91       	ld	r24, Z+
    762e:	ec 87       	std	Y+12, r30	; 0x0c
    7630:	fd 87       	std	Y+13, r31	; 0x0d
    7632:	88 23       	and	r24, r24
    7634:	09 f0       	breq	.+2      	; 0x7638 <vfprintf+0x118>
    7636:	b8 cf       	rjmp	.-144    	; 0x75a8 <vfprintf+0x88>
    7638:	98 2f       	mov	r25, r24
    763a:	95 54       	subi	r25, 0x45	; 69
    763c:	93 30       	cpi	r25, 0x03	; 3
    763e:	18 f0       	brcs	.+6      	; 0x7646 <vfprintf+0x126>
    7640:	90 52       	subi	r25, 0x20	; 32
    7642:	93 30       	cpi	r25, 0x03	; 3
    7644:	38 f4       	brcc	.+14     	; 0x7654 <vfprintf+0x134>
    7646:	24 e0       	ldi	r18, 0x04	; 4
    7648:	30 e0       	ldi	r19, 0x00	; 0
    764a:	a2 0e       	add	r10, r18
    764c:	b3 1e       	adc	r11, r19
    764e:	3f e3       	ldi	r19, 0x3F	; 63
    7650:	39 83       	std	Y+1, r19	; 0x01
    7652:	0f c0       	rjmp	.+30     	; 0x7672 <vfprintf+0x152>
    7654:	83 36       	cpi	r24, 0x63	; 99
    7656:	31 f0       	breq	.+12     	; 0x7664 <vfprintf+0x144>
    7658:	83 37       	cpi	r24, 0x73	; 115
    765a:	81 f0       	breq	.+32     	; 0x767c <vfprintf+0x15c>
    765c:	83 35       	cpi	r24, 0x53	; 83
    765e:	09 f0       	breq	.+2      	; 0x7662 <vfprintf+0x142>
    7660:	5a c0       	rjmp	.+180    	; 0x7716 <vfprintf+0x1f6>
    7662:	22 c0       	rjmp	.+68     	; 0x76a8 <vfprintf+0x188>
    7664:	f5 01       	movw	r30, r10
    7666:	80 81       	ld	r24, Z
    7668:	89 83       	std	Y+1, r24	; 0x01
    766a:	22 e0       	ldi	r18, 0x02	; 2
    766c:	30 e0       	ldi	r19, 0x00	; 0
    766e:	a2 0e       	add	r10, r18
    7670:	b3 1e       	adc	r11, r19
    7672:	21 e0       	ldi	r18, 0x01	; 1
    7674:	c2 2e       	mov	r12, r18
    7676:	d1 2c       	mov	r13, r1
    7678:	42 01       	movw	r8, r4
    767a:	14 c0       	rjmp	.+40     	; 0x76a4 <vfprintf+0x184>
    767c:	92 e0       	ldi	r25, 0x02	; 2
    767e:	29 2e       	mov	r2, r25
    7680:	31 2c       	mov	r3, r1
    7682:	2a 0c       	add	r2, r10
    7684:	3b 1c       	adc	r3, r11
    7686:	f5 01       	movw	r30, r10
    7688:	80 80       	ld	r8, Z
    768a:	91 80       	ldd	r9, Z+1	; 0x01
    768c:	16 ff       	sbrs	r17, 6
    768e:	03 c0       	rjmp	.+6      	; 0x7696 <vfprintf+0x176>
    7690:	6f 2d       	mov	r22, r15
    7692:	70 e0       	ldi	r23, 0x00	; 0
    7694:	02 c0       	rjmp	.+4      	; 0x769a <vfprintf+0x17a>
    7696:	6f ef       	ldi	r22, 0xFF	; 255
    7698:	7f ef       	ldi	r23, 0xFF	; 255
    769a:	c4 01       	movw	r24, r8
    769c:	0e 94 a5 3c 	call	0x794a	; 0x794a <strnlen>
    76a0:	6c 01       	movw	r12, r24
    76a2:	51 01       	movw	r10, r2
    76a4:	1f 77       	andi	r17, 0x7F	; 127
    76a6:	15 c0       	rjmp	.+42     	; 0x76d2 <vfprintf+0x1b2>
    76a8:	82 e0       	ldi	r24, 0x02	; 2
    76aa:	28 2e       	mov	r2, r24
    76ac:	31 2c       	mov	r3, r1
    76ae:	2a 0c       	add	r2, r10
    76b0:	3b 1c       	adc	r3, r11
    76b2:	f5 01       	movw	r30, r10
    76b4:	80 80       	ld	r8, Z
    76b6:	91 80       	ldd	r9, Z+1	; 0x01
    76b8:	16 ff       	sbrs	r17, 6
    76ba:	03 c0       	rjmp	.+6      	; 0x76c2 <vfprintf+0x1a2>
    76bc:	6f 2d       	mov	r22, r15
    76be:	70 e0       	ldi	r23, 0x00	; 0
    76c0:	02 c0       	rjmp	.+4      	; 0x76c6 <vfprintf+0x1a6>
    76c2:	6f ef       	ldi	r22, 0xFF	; 255
    76c4:	7f ef       	ldi	r23, 0xFF	; 255
    76c6:	c4 01       	movw	r24, r8
    76c8:	0e 94 91 3c 	call	0x7922	; 0x7922 <strnlen_P>
    76cc:	6c 01       	movw	r12, r24
    76ce:	10 68       	ori	r17, 0x80	; 128
    76d0:	51 01       	movw	r10, r2
    76d2:	13 fd       	sbrc	r17, 3
    76d4:	1c c0       	rjmp	.+56     	; 0x770e <vfprintf+0x1ee>
    76d6:	06 c0       	rjmp	.+12     	; 0x76e4 <vfprintf+0x1c4>
    76d8:	80 e2       	ldi	r24, 0x20	; 32
    76da:	90 e0       	ldi	r25, 0x00	; 0
    76dc:	b3 01       	movw	r22, r6
    76de:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    76e2:	ea 94       	dec	r14
    76e4:	8e 2d       	mov	r24, r14
    76e6:	90 e0       	ldi	r25, 0x00	; 0
    76e8:	c8 16       	cp	r12, r24
    76ea:	d9 06       	cpc	r13, r25
    76ec:	a8 f3       	brcs	.-22     	; 0x76d8 <vfprintf+0x1b8>
    76ee:	0f c0       	rjmp	.+30     	; 0x770e <vfprintf+0x1ee>
    76f0:	f4 01       	movw	r30, r8
    76f2:	17 fd       	sbrc	r17, 7
    76f4:	85 91       	lpm	r24, Z+
    76f6:	17 ff       	sbrs	r17, 7
    76f8:	81 91       	ld	r24, Z+
    76fa:	4f 01       	movw	r8, r30
    76fc:	90 e0       	ldi	r25, 0x00	; 0
    76fe:	b3 01       	movw	r22, r6
    7700:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    7704:	e1 10       	cpse	r14, r1
    7706:	ea 94       	dec	r14
    7708:	08 94       	sec
    770a:	c1 08       	sbc	r12, r1
    770c:	d1 08       	sbc	r13, r1
    770e:	c1 14       	cp	r12, r1
    7710:	d1 04       	cpc	r13, r1
    7712:	71 f7       	brne	.-36     	; 0x76f0 <vfprintf+0x1d0>
    7714:	e7 c0       	rjmp	.+462    	; 0x78e4 <vfprintf+0x3c4>
    7716:	84 36       	cpi	r24, 0x64	; 100
    7718:	11 f0       	breq	.+4      	; 0x771e <vfprintf+0x1fe>
    771a:	89 36       	cpi	r24, 0x69	; 105
    771c:	51 f5       	brne	.+84     	; 0x7772 <vfprintf+0x252>
    771e:	f5 01       	movw	r30, r10
    7720:	17 ff       	sbrs	r17, 7
    7722:	07 c0       	rjmp	.+14     	; 0x7732 <vfprintf+0x212>
    7724:	80 81       	ld	r24, Z
    7726:	91 81       	ldd	r25, Z+1	; 0x01
    7728:	a2 81       	ldd	r26, Z+2	; 0x02
    772a:	b3 81       	ldd	r27, Z+3	; 0x03
    772c:	24 e0       	ldi	r18, 0x04	; 4
    772e:	30 e0       	ldi	r19, 0x00	; 0
    7730:	08 c0       	rjmp	.+16     	; 0x7742 <vfprintf+0x222>
    7732:	80 81       	ld	r24, Z
    7734:	91 81       	ldd	r25, Z+1	; 0x01
    7736:	aa 27       	eor	r26, r26
    7738:	97 fd       	sbrc	r25, 7
    773a:	a0 95       	com	r26
    773c:	ba 2f       	mov	r27, r26
    773e:	22 e0       	ldi	r18, 0x02	; 2
    7740:	30 e0       	ldi	r19, 0x00	; 0
    7742:	a2 0e       	add	r10, r18
    7744:	b3 1e       	adc	r11, r19
    7746:	01 2f       	mov	r16, r17
    7748:	0f 76       	andi	r16, 0x6F	; 111
    774a:	b7 ff       	sbrs	r27, 7
    774c:	08 c0       	rjmp	.+16     	; 0x775e <vfprintf+0x23e>
    774e:	b0 95       	com	r27
    7750:	a0 95       	com	r26
    7752:	90 95       	com	r25
    7754:	81 95       	neg	r24
    7756:	9f 4f       	sbci	r25, 0xFF	; 255
    7758:	af 4f       	sbci	r26, 0xFF	; 255
    775a:	bf 4f       	sbci	r27, 0xFF	; 255
    775c:	00 68       	ori	r16, 0x80	; 128
    775e:	bc 01       	movw	r22, r24
    7760:	cd 01       	movw	r24, r26
    7762:	a2 01       	movw	r20, r4
    7764:	2a e0       	ldi	r18, 0x0A	; 10
    7766:	30 e0       	ldi	r19, 0x00	; 0
    7768:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <__ultoa_invert>
    776c:	d8 2e       	mov	r13, r24
    776e:	d4 18       	sub	r13, r4
    7770:	3f c0       	rjmp	.+126    	; 0x77f0 <vfprintf+0x2d0>
    7772:	85 37       	cpi	r24, 0x75	; 117
    7774:	21 f4       	brne	.+8      	; 0x777e <vfprintf+0x25e>
    7776:	1f 7e       	andi	r17, 0xEF	; 239
    7778:	2a e0       	ldi	r18, 0x0A	; 10
    777a:	30 e0       	ldi	r19, 0x00	; 0
    777c:	20 c0       	rjmp	.+64     	; 0x77be <vfprintf+0x29e>
    777e:	19 7f       	andi	r17, 0xF9	; 249
    7780:	8f 36       	cpi	r24, 0x6F	; 111
    7782:	a9 f0       	breq	.+42     	; 0x77ae <vfprintf+0x28e>
    7784:	80 37       	cpi	r24, 0x70	; 112
    7786:	20 f4       	brcc	.+8      	; 0x7790 <vfprintf+0x270>
    7788:	88 35       	cpi	r24, 0x58	; 88
    778a:	09 f0       	breq	.+2      	; 0x778e <vfprintf+0x26e>
    778c:	ae c0       	rjmp	.+348    	; 0x78ea <vfprintf+0x3ca>
    778e:	0b c0       	rjmp	.+22     	; 0x77a6 <vfprintf+0x286>
    7790:	80 37       	cpi	r24, 0x70	; 112
    7792:	21 f0       	breq	.+8      	; 0x779c <vfprintf+0x27c>
    7794:	88 37       	cpi	r24, 0x78	; 120
    7796:	09 f0       	breq	.+2      	; 0x779a <vfprintf+0x27a>
    7798:	a8 c0       	rjmp	.+336    	; 0x78ea <vfprintf+0x3ca>
    779a:	01 c0       	rjmp	.+2      	; 0x779e <vfprintf+0x27e>
    779c:	10 61       	ori	r17, 0x10	; 16
    779e:	14 ff       	sbrs	r17, 4
    77a0:	09 c0       	rjmp	.+18     	; 0x77b4 <vfprintf+0x294>
    77a2:	14 60       	ori	r17, 0x04	; 4
    77a4:	07 c0       	rjmp	.+14     	; 0x77b4 <vfprintf+0x294>
    77a6:	14 ff       	sbrs	r17, 4
    77a8:	08 c0       	rjmp	.+16     	; 0x77ba <vfprintf+0x29a>
    77aa:	16 60       	ori	r17, 0x06	; 6
    77ac:	06 c0       	rjmp	.+12     	; 0x77ba <vfprintf+0x29a>
    77ae:	28 e0       	ldi	r18, 0x08	; 8
    77b0:	30 e0       	ldi	r19, 0x00	; 0
    77b2:	05 c0       	rjmp	.+10     	; 0x77be <vfprintf+0x29e>
    77b4:	20 e1       	ldi	r18, 0x10	; 16
    77b6:	30 e0       	ldi	r19, 0x00	; 0
    77b8:	02 c0       	rjmp	.+4      	; 0x77be <vfprintf+0x29e>
    77ba:	20 e1       	ldi	r18, 0x10	; 16
    77bc:	32 e0       	ldi	r19, 0x02	; 2
    77be:	f5 01       	movw	r30, r10
    77c0:	17 ff       	sbrs	r17, 7
    77c2:	07 c0       	rjmp	.+14     	; 0x77d2 <vfprintf+0x2b2>
    77c4:	60 81       	ld	r22, Z
    77c6:	71 81       	ldd	r23, Z+1	; 0x01
    77c8:	82 81       	ldd	r24, Z+2	; 0x02
    77ca:	93 81       	ldd	r25, Z+3	; 0x03
    77cc:	44 e0       	ldi	r20, 0x04	; 4
    77ce:	50 e0       	ldi	r21, 0x00	; 0
    77d0:	06 c0       	rjmp	.+12     	; 0x77de <vfprintf+0x2be>
    77d2:	60 81       	ld	r22, Z
    77d4:	71 81       	ldd	r23, Z+1	; 0x01
    77d6:	80 e0       	ldi	r24, 0x00	; 0
    77d8:	90 e0       	ldi	r25, 0x00	; 0
    77da:	42 e0       	ldi	r20, 0x02	; 2
    77dc:	50 e0       	ldi	r21, 0x00	; 0
    77de:	a4 0e       	add	r10, r20
    77e0:	b5 1e       	adc	r11, r21
    77e2:	a2 01       	movw	r20, r4
    77e4:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <__ultoa_invert>
    77e8:	d8 2e       	mov	r13, r24
    77ea:	d4 18       	sub	r13, r4
    77ec:	01 2f       	mov	r16, r17
    77ee:	0f 77       	andi	r16, 0x7F	; 127
    77f0:	06 ff       	sbrs	r16, 6
    77f2:	09 c0       	rjmp	.+18     	; 0x7806 <vfprintf+0x2e6>
    77f4:	0e 7f       	andi	r16, 0xFE	; 254
    77f6:	df 14       	cp	r13, r15
    77f8:	30 f4       	brcc	.+12     	; 0x7806 <vfprintf+0x2e6>
    77fa:	04 ff       	sbrs	r16, 4
    77fc:	06 c0       	rjmp	.+12     	; 0x780a <vfprintf+0x2ea>
    77fe:	02 fd       	sbrc	r16, 2
    7800:	04 c0       	rjmp	.+8      	; 0x780a <vfprintf+0x2ea>
    7802:	0f 7e       	andi	r16, 0xEF	; 239
    7804:	02 c0       	rjmp	.+4      	; 0x780a <vfprintf+0x2ea>
    7806:	1d 2d       	mov	r17, r13
    7808:	01 c0       	rjmp	.+2      	; 0x780c <vfprintf+0x2ec>
    780a:	1f 2d       	mov	r17, r15
    780c:	80 2f       	mov	r24, r16
    780e:	90 e0       	ldi	r25, 0x00	; 0
    7810:	04 ff       	sbrs	r16, 4
    7812:	0c c0       	rjmp	.+24     	; 0x782c <vfprintf+0x30c>
    7814:	fe 01       	movw	r30, r28
    7816:	ed 0d       	add	r30, r13
    7818:	f1 1d       	adc	r31, r1
    781a:	20 81       	ld	r18, Z
    781c:	20 33       	cpi	r18, 0x30	; 48
    781e:	11 f4       	brne	.+4      	; 0x7824 <vfprintf+0x304>
    7820:	09 7e       	andi	r16, 0xE9	; 233
    7822:	09 c0       	rjmp	.+18     	; 0x7836 <vfprintf+0x316>
    7824:	02 ff       	sbrs	r16, 2
    7826:	06 c0       	rjmp	.+12     	; 0x7834 <vfprintf+0x314>
    7828:	1e 5f       	subi	r17, 0xFE	; 254
    782a:	05 c0       	rjmp	.+10     	; 0x7836 <vfprintf+0x316>
    782c:	86 78       	andi	r24, 0x86	; 134
    782e:	90 70       	andi	r25, 0x00	; 0
    7830:	00 97       	sbiw	r24, 0x00	; 0
    7832:	09 f0       	breq	.+2      	; 0x7836 <vfprintf+0x316>
    7834:	1f 5f       	subi	r17, 0xFF	; 255
    7836:	80 2e       	mov	r8, r16
    7838:	99 24       	eor	r9, r9
    783a:	03 fd       	sbrc	r16, 3
    783c:	12 c0       	rjmp	.+36     	; 0x7862 <vfprintf+0x342>
    783e:	00 ff       	sbrs	r16, 0
    7840:	0d c0       	rjmp	.+26     	; 0x785c <vfprintf+0x33c>
    7842:	fd 2c       	mov	r15, r13
    7844:	1e 15       	cp	r17, r14
    7846:	50 f4       	brcc	.+20     	; 0x785c <vfprintf+0x33c>
    7848:	fe 0c       	add	r15, r14
    784a:	f1 1a       	sub	r15, r17
    784c:	1e 2d       	mov	r17, r14
    784e:	06 c0       	rjmp	.+12     	; 0x785c <vfprintf+0x33c>
    7850:	80 e2       	ldi	r24, 0x20	; 32
    7852:	90 e0       	ldi	r25, 0x00	; 0
    7854:	b3 01       	movw	r22, r6
    7856:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    785a:	1f 5f       	subi	r17, 0xFF	; 255
    785c:	1e 15       	cp	r17, r14
    785e:	c0 f3       	brcs	.-16     	; 0x7850 <vfprintf+0x330>
    7860:	04 c0       	rjmp	.+8      	; 0x786a <vfprintf+0x34a>
    7862:	1e 15       	cp	r17, r14
    7864:	10 f4       	brcc	.+4      	; 0x786a <vfprintf+0x34a>
    7866:	e1 1a       	sub	r14, r17
    7868:	01 c0       	rjmp	.+2      	; 0x786c <vfprintf+0x34c>
    786a:	ee 24       	eor	r14, r14
    786c:	84 fe       	sbrs	r8, 4
    786e:	0f c0       	rjmp	.+30     	; 0x788e <vfprintf+0x36e>
    7870:	80 e3       	ldi	r24, 0x30	; 48
    7872:	90 e0       	ldi	r25, 0x00	; 0
    7874:	b3 01       	movw	r22, r6
    7876:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    787a:	82 fe       	sbrs	r8, 2
    787c:	1f c0       	rjmp	.+62     	; 0x78bc <vfprintf+0x39c>
    787e:	81 fe       	sbrs	r8, 1
    7880:	03 c0       	rjmp	.+6      	; 0x7888 <vfprintf+0x368>
    7882:	88 e5       	ldi	r24, 0x58	; 88
    7884:	90 e0       	ldi	r25, 0x00	; 0
    7886:	10 c0       	rjmp	.+32     	; 0x78a8 <vfprintf+0x388>
    7888:	88 e7       	ldi	r24, 0x78	; 120
    788a:	90 e0       	ldi	r25, 0x00	; 0
    788c:	0d c0       	rjmp	.+26     	; 0x78a8 <vfprintf+0x388>
    788e:	c4 01       	movw	r24, r8
    7890:	86 78       	andi	r24, 0x86	; 134
    7892:	90 70       	andi	r25, 0x00	; 0
    7894:	00 97       	sbiw	r24, 0x00	; 0
    7896:	91 f0       	breq	.+36     	; 0x78bc <vfprintf+0x39c>
    7898:	81 fc       	sbrc	r8, 1
    789a:	02 c0       	rjmp	.+4      	; 0x78a0 <vfprintf+0x380>
    789c:	80 e2       	ldi	r24, 0x20	; 32
    789e:	01 c0       	rjmp	.+2      	; 0x78a2 <vfprintf+0x382>
    78a0:	8b e2       	ldi	r24, 0x2B	; 43
    78a2:	07 fd       	sbrc	r16, 7
    78a4:	8d e2       	ldi	r24, 0x2D	; 45
    78a6:	90 e0       	ldi	r25, 0x00	; 0
    78a8:	b3 01       	movw	r22, r6
    78aa:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    78ae:	06 c0       	rjmp	.+12     	; 0x78bc <vfprintf+0x39c>
    78b0:	80 e3       	ldi	r24, 0x30	; 48
    78b2:	90 e0       	ldi	r25, 0x00	; 0
    78b4:	b3 01       	movw	r22, r6
    78b6:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    78ba:	fa 94       	dec	r15
    78bc:	df 14       	cp	r13, r15
    78be:	c0 f3       	brcs	.-16     	; 0x78b0 <vfprintf+0x390>
    78c0:	da 94       	dec	r13
    78c2:	f2 01       	movw	r30, r4
    78c4:	ed 0d       	add	r30, r13
    78c6:	f1 1d       	adc	r31, r1
    78c8:	80 81       	ld	r24, Z
    78ca:	90 e0       	ldi	r25, 0x00	; 0
    78cc:	b3 01       	movw	r22, r6
    78ce:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    78d2:	dd 20       	and	r13, r13
    78d4:	a9 f7       	brne	.-22     	; 0x78c0 <vfprintf+0x3a0>
    78d6:	06 c0       	rjmp	.+12     	; 0x78e4 <vfprintf+0x3c4>
    78d8:	80 e2       	ldi	r24, 0x20	; 32
    78da:	90 e0       	ldi	r25, 0x00	; 0
    78dc:	b3 01       	movw	r22, r6
    78de:	0e 94 c0 3c 	call	0x7980	; 0x7980 <fputc>
    78e2:	ea 94       	dec	r14
    78e4:	ee 20       	and	r14, r14
    78e6:	c1 f7       	brne	.-16     	; 0x78d8 <vfprintf+0x3b8>
    78e8:	40 ce       	rjmp	.-896    	; 0x756a <vfprintf+0x4a>
    78ea:	f3 01       	movw	r30, r6
    78ec:	86 81       	ldd	r24, Z+6	; 0x06
    78ee:	97 81       	ldd	r25, Z+7	; 0x07
    78f0:	02 c0       	rjmp	.+4      	; 0x78f6 <vfprintf+0x3d6>
    78f2:	8f ef       	ldi	r24, 0xFF	; 255
    78f4:	9f ef       	ldi	r25, 0xFF	; 255
    78f6:	2d 96       	adiw	r28, 0x0d	; 13
    78f8:	cd bf       	out	0x3d, r28	; 61
    78fa:	de bf       	out	0x3e, r29	; 62
    78fc:	df 91       	pop	r29
    78fe:	cf 91       	pop	r28
    7900:	1f 91       	pop	r17
    7902:	0f 91       	pop	r16
    7904:	ff 90       	pop	r15
    7906:	ef 90       	pop	r14
    7908:	df 90       	pop	r13
    790a:	cf 90       	pop	r12
    790c:	bf 90       	pop	r11
    790e:	af 90       	pop	r10
    7910:	9f 90       	pop	r9
    7912:	8f 90       	pop	r8
    7914:	7f 90       	pop	r7
    7916:	6f 90       	pop	r6
    7918:	5f 90       	pop	r5
    791a:	4f 90       	pop	r4
    791c:	3f 90       	pop	r3
    791e:	2f 90       	pop	r2
    7920:	08 95       	ret

00007922 <strnlen_P>:
    7922:	fc 01       	movw	r30, r24
    7924:	05 90       	lpm	r0, Z+
    7926:	61 50       	subi	r22, 0x01	; 1
    7928:	70 40       	sbci	r23, 0x00	; 0
    792a:	01 10       	cpse	r0, r1
    792c:	d8 f7       	brcc	.-10     	; 0x7924 <strnlen_P+0x2>
    792e:	80 95       	com	r24
    7930:	90 95       	com	r25
    7932:	8e 0f       	add	r24, r30
    7934:	9f 1f       	adc	r25, r31
    7936:	08 95       	ret

00007938 <memcpy>:
    7938:	fb 01       	movw	r30, r22
    793a:	dc 01       	movw	r26, r24
    793c:	02 c0       	rjmp	.+4      	; 0x7942 <memcpy+0xa>
    793e:	01 90       	ld	r0, Z+
    7940:	0d 92       	st	X+, r0
    7942:	41 50       	subi	r20, 0x01	; 1
    7944:	50 40       	sbci	r21, 0x00	; 0
    7946:	d8 f7       	brcc	.-10     	; 0x793e <memcpy+0x6>
    7948:	08 95       	ret

0000794a <strnlen>:
    794a:	fc 01       	movw	r30, r24
    794c:	61 50       	subi	r22, 0x01	; 1
    794e:	70 40       	sbci	r23, 0x00	; 0
    7950:	01 90       	ld	r0, Z+
    7952:	01 10       	cpse	r0, r1
    7954:	d8 f7       	brcc	.-10     	; 0x794c <strnlen+0x2>
    7956:	80 95       	com	r24
    7958:	90 95       	com	r25
    795a:	8e 0f       	add	r24, r30
    795c:	9f 1f       	adc	r25, r31
    795e:	08 95       	ret

00007960 <strrev>:
    7960:	dc 01       	movw	r26, r24
    7962:	fc 01       	movw	r30, r24
    7964:	67 2f       	mov	r22, r23
    7966:	71 91       	ld	r23, Z+
    7968:	77 23       	and	r23, r23
    796a:	e1 f7       	brne	.-8      	; 0x7964 <strrev+0x4>
    796c:	32 97       	sbiw	r30, 0x02	; 2
    796e:	04 c0       	rjmp	.+8      	; 0x7978 <strrev+0x18>
    7970:	7c 91       	ld	r23, X
    7972:	6d 93       	st	X+, r22
    7974:	70 83       	st	Z, r23
    7976:	62 91       	ld	r22, -Z
    7978:	ae 17       	cp	r26, r30
    797a:	bf 07       	cpc	r27, r31
    797c:	c8 f3       	brcs	.-14     	; 0x7970 <strrev+0x10>
    797e:	08 95       	ret

00007980 <fputc>:
    7980:	0f 93       	push	r16
    7982:	1f 93       	push	r17
    7984:	cf 93       	push	r28
    7986:	df 93       	push	r29
    7988:	8c 01       	movw	r16, r24
    798a:	eb 01       	movw	r28, r22
    798c:	8b 81       	ldd	r24, Y+3	; 0x03
    798e:	81 ff       	sbrs	r24, 1
    7990:	1b c0       	rjmp	.+54     	; 0x79c8 <fputc+0x48>
    7992:	82 ff       	sbrs	r24, 2
    7994:	0d c0       	rjmp	.+26     	; 0x79b0 <fputc+0x30>
    7996:	2e 81       	ldd	r18, Y+6	; 0x06
    7998:	3f 81       	ldd	r19, Y+7	; 0x07
    799a:	8c 81       	ldd	r24, Y+4	; 0x04
    799c:	9d 81       	ldd	r25, Y+5	; 0x05
    799e:	28 17       	cp	r18, r24
    79a0:	39 07       	cpc	r19, r25
    79a2:	64 f4       	brge	.+24     	; 0x79bc <fputc+0x3c>
    79a4:	e8 81       	ld	r30, Y
    79a6:	f9 81       	ldd	r31, Y+1	; 0x01
    79a8:	01 93       	st	Z+, r16
    79aa:	e8 83       	st	Y, r30
    79ac:	f9 83       	std	Y+1, r31	; 0x01
    79ae:	06 c0       	rjmp	.+12     	; 0x79bc <fputc+0x3c>
    79b0:	e8 85       	ldd	r30, Y+8	; 0x08
    79b2:	f9 85       	ldd	r31, Y+9	; 0x09
    79b4:	80 2f       	mov	r24, r16
    79b6:	19 95       	eicall
    79b8:	00 97       	sbiw	r24, 0x00	; 0
    79ba:	31 f4       	brne	.+12     	; 0x79c8 <fputc+0x48>
    79bc:	8e 81       	ldd	r24, Y+6	; 0x06
    79be:	9f 81       	ldd	r25, Y+7	; 0x07
    79c0:	01 96       	adiw	r24, 0x01	; 1
    79c2:	8e 83       	std	Y+6, r24	; 0x06
    79c4:	9f 83       	std	Y+7, r25	; 0x07
    79c6:	02 c0       	rjmp	.+4      	; 0x79cc <fputc+0x4c>
    79c8:	0f ef       	ldi	r16, 0xFF	; 255
    79ca:	1f ef       	ldi	r17, 0xFF	; 255
    79cc:	c8 01       	movw	r24, r16
    79ce:	df 91       	pop	r29
    79d0:	cf 91       	pop	r28
    79d2:	1f 91       	pop	r17
    79d4:	0f 91       	pop	r16
    79d6:	08 95       	ret

000079d8 <__ultoa_invert>:
    79d8:	fa 01       	movw	r30, r20
    79da:	aa 27       	eor	r26, r26
    79dc:	28 30       	cpi	r18, 0x08	; 8
    79de:	51 f1       	breq	.+84     	; 0x7a34 <__ultoa_invert+0x5c>
    79e0:	20 31       	cpi	r18, 0x10	; 16
    79e2:	81 f1       	breq	.+96     	; 0x7a44 <__ultoa_invert+0x6c>
    79e4:	e8 94       	clt
    79e6:	6f 93       	push	r22
    79e8:	6e 7f       	andi	r22, 0xFE	; 254
    79ea:	6e 5f       	subi	r22, 0xFE	; 254
    79ec:	7f 4f       	sbci	r23, 0xFF	; 255
    79ee:	8f 4f       	sbci	r24, 0xFF	; 255
    79f0:	9f 4f       	sbci	r25, 0xFF	; 255
    79f2:	af 4f       	sbci	r26, 0xFF	; 255
    79f4:	b1 e0       	ldi	r27, 0x01	; 1
    79f6:	3e d0       	rcall	.+124    	; 0x7a74 <__ultoa_invert+0x9c>
    79f8:	b4 e0       	ldi	r27, 0x04	; 4
    79fa:	3c d0       	rcall	.+120    	; 0x7a74 <__ultoa_invert+0x9c>
    79fc:	67 0f       	add	r22, r23
    79fe:	78 1f       	adc	r23, r24
    7a00:	89 1f       	adc	r24, r25
    7a02:	9a 1f       	adc	r25, r26
    7a04:	a1 1d       	adc	r26, r1
    7a06:	68 0f       	add	r22, r24
    7a08:	79 1f       	adc	r23, r25
    7a0a:	8a 1f       	adc	r24, r26
    7a0c:	91 1d       	adc	r25, r1
    7a0e:	a1 1d       	adc	r26, r1
    7a10:	6a 0f       	add	r22, r26
    7a12:	71 1d       	adc	r23, r1
    7a14:	81 1d       	adc	r24, r1
    7a16:	91 1d       	adc	r25, r1
    7a18:	a1 1d       	adc	r26, r1
    7a1a:	20 d0       	rcall	.+64     	; 0x7a5c <__ultoa_invert+0x84>
    7a1c:	09 f4       	brne	.+2      	; 0x7a20 <__ultoa_invert+0x48>
    7a1e:	68 94       	set
    7a20:	3f 91       	pop	r19
    7a22:	2a e0       	ldi	r18, 0x0A	; 10
    7a24:	26 9f       	mul	r18, r22
    7a26:	11 24       	eor	r1, r1
    7a28:	30 19       	sub	r19, r0
    7a2a:	30 5d       	subi	r19, 0xD0	; 208
    7a2c:	31 93       	st	Z+, r19
    7a2e:	de f6       	brtc	.-74     	; 0x79e6 <__ultoa_invert+0xe>
    7a30:	cf 01       	movw	r24, r30
    7a32:	08 95       	ret
    7a34:	46 2f       	mov	r20, r22
    7a36:	47 70       	andi	r20, 0x07	; 7
    7a38:	40 5d       	subi	r20, 0xD0	; 208
    7a3a:	41 93       	st	Z+, r20
    7a3c:	b3 e0       	ldi	r27, 0x03	; 3
    7a3e:	0f d0       	rcall	.+30     	; 0x7a5e <__ultoa_invert+0x86>
    7a40:	c9 f7       	brne	.-14     	; 0x7a34 <__ultoa_invert+0x5c>
    7a42:	f6 cf       	rjmp	.-20     	; 0x7a30 <__ultoa_invert+0x58>
    7a44:	46 2f       	mov	r20, r22
    7a46:	4f 70       	andi	r20, 0x0F	; 15
    7a48:	40 5d       	subi	r20, 0xD0	; 208
    7a4a:	4a 33       	cpi	r20, 0x3A	; 58
    7a4c:	18 f0       	brcs	.+6      	; 0x7a54 <__ultoa_invert+0x7c>
    7a4e:	49 5d       	subi	r20, 0xD9	; 217
    7a50:	31 fd       	sbrc	r19, 1
    7a52:	40 52       	subi	r20, 0x20	; 32
    7a54:	41 93       	st	Z+, r20
    7a56:	02 d0       	rcall	.+4      	; 0x7a5c <__ultoa_invert+0x84>
    7a58:	a9 f7       	brne	.-22     	; 0x7a44 <__ultoa_invert+0x6c>
    7a5a:	ea cf       	rjmp	.-44     	; 0x7a30 <__ultoa_invert+0x58>
    7a5c:	b4 e0       	ldi	r27, 0x04	; 4
    7a5e:	a6 95       	lsr	r26
    7a60:	97 95       	ror	r25
    7a62:	87 95       	ror	r24
    7a64:	77 95       	ror	r23
    7a66:	67 95       	ror	r22
    7a68:	ba 95       	dec	r27
    7a6a:	c9 f7       	brne	.-14     	; 0x7a5e <__ultoa_invert+0x86>
    7a6c:	00 97       	sbiw	r24, 0x00	; 0
    7a6e:	61 05       	cpc	r22, r1
    7a70:	71 05       	cpc	r23, r1
    7a72:	08 95       	ret
    7a74:	9b 01       	movw	r18, r22
    7a76:	ac 01       	movw	r20, r24
    7a78:	0a 2e       	mov	r0, r26
    7a7a:	06 94       	lsr	r0
    7a7c:	57 95       	ror	r21
    7a7e:	47 95       	ror	r20
    7a80:	37 95       	ror	r19
    7a82:	27 95       	ror	r18
    7a84:	ba 95       	dec	r27
    7a86:	c9 f7       	brne	.-14     	; 0x7a7a <__ultoa_invert+0xa2>
    7a88:	62 0f       	add	r22, r18
    7a8a:	73 1f       	adc	r23, r19
    7a8c:	84 1f       	adc	r24, r20
    7a8e:	95 1f       	adc	r25, r21
    7a90:	a0 1d       	adc	r26, r0
    7a92:	08 95       	ret

00007a94 <_exit>:
    7a94:	f8 94       	cli

00007a96 <__stop_program>:
    7a96:	ff cf       	rjmp	.-2      	; 0x7a96 <__stop_program>
