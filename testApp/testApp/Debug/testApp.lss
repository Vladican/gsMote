
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c48e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000013a  00802000  0000c48e  0000c522  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa7  0080213a  0080213a  0000c65c  2**0
                  ALLOC
  3 .stab         00002718  00000000  00000000  0000c65c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2a  00000000  00000000  0000ed74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  0000f7a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c49f  00000000  00000000  0000fb60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000213e  00000000  00000000  0001bfff  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e1e  00000000  00000000  0001e13d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c00  00000000  00000000  00021f5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004558  00000000  00000000  00023b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005127  00000000  00000000  000280b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000120  00000000  00000000  0002d1db  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 4c 14 	jmp	0x2898	; 0x2898 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 60 13 	jmp	0x26c0	; 0x26c0 <__vector_16>
      44:	0c 94 90 13 	jmp	0x2720	; 0x2720 <__vector_17>
      48:	0c 94 c0 13 	jmp	0x2780	; 0x2780 <__vector_18>
      4c:	0c 94 f0 13 	jmp	0x27e0	; 0x27e0 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 a4 40 	jmp	0x8148	; 0x8148 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 09 30 	jmp	0x6012	; 0x6012 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 51 16 	jmp	0x2ca2	; 0x2ca2 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 8f 15 	jmp	0x2b1e	; 0x2b1e <__vector_79>
     140:	0c 94 bf 15 	jmp	0x2b7e	; 0x2b7e <__vector_80>
     144:	0c 94 ef 15 	jmp	0x2bde	; 0x2bde <__vector_81>
     148:	0c 94 1f 16 	jmp	0x2c3e	; 0x2c3e <__vector_82>
     14c:	0c 94 e0 01 	jmp	0x3c0	; 0x3c0 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 6b 10 	jmp	0x20d6	; 0x20d6 <__vector_104>
     1a4:	0c 94 94 0e 	jmp	0x1d28	; 0x1d28 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ee e8       	ldi	r30, 0x8E	; 142
     244:	f4 ec       	ldi	r31, 0xC4	; 196
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	aa 33       	cpi	r26, 0x3A	; 58
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	aa e3       	ldi	r26, 0x3A	; 58
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a1 3e       	cpi	r26, 0xE1	; 225
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 39 01 	call	0x272	; 0x272 <main>
     26a:	0c 94 45 62 	jmp	0xc48a	; 0xc48a <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <main>:
 * Created: 1/29/2013 2:50:50 PM
 *  Author: Vlad
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	0f 92       	push	r0
     278:	0f 92       	push	r0
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
	moteID = 0;
     27e:	10 92 cd 50 	sts	0x50CD, r1
	chb_init();
     282:	0e 94 38 20 	call	0x4070	; 0x4070 <chb_init>
	chb_set_short_addr(moteID);
     286:	80 91 cd 50 	lds	r24, 0x50CD
     28a:	88 2f       	mov	r24, r24
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <chb_set_short_addr>
	SD_init();
     292:	0e 94 7c 4d 	call	0x9af8	; 0x9af8 <SD_init>
	getBootSectorData();
     296:	0e 94 7c 41 	call	0x82f8	; 0x82f8 <getBootSectorData>
	RadioMonitorMode = DATA_GATHERING;
     29a:	81 e0       	ldi	r24, 0x01	; 1
     29c:	80 93 5f 40 	sts	0x405F, r24
	uint16_t MotesInSystem = 1;
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	90 e0       	ldi	r25, 0x00	; 0
     2a4:	89 83       	std	Y+1, r24	; 0x01
     2a6:	9a 83       	std	Y+2, r25	; 0x02
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     2a8:	28 c0       	rjmp	.+80     	; 0x2fa <main+0x88>
			//store samples in SD card as they come in
			if(StartOfFreeSpace >= 512){
     2aa:	80 91 c7 50 	lds	r24, 0x50C7
     2ae:	90 91 c8 50 	lds	r25, 0x50C8
     2b2:	a0 91 c9 50 	lds	r26, 0x50C9
     2b6:	b0 91 ca 50 	lds	r27, 0x50CA
     2ba:	80 30       	cpi	r24, 0x00	; 0
     2bc:	22 e0       	ldi	r18, 0x02	; 2
     2be:	92 07       	cpc	r25, r18
     2c0:	20 e0       	ldi	r18, 0x00	; 0
     2c2:	a2 07       	cpc	r26, r18
     2c4:	20 e0       	ldi	r18, 0x00	; 0
     2c6:	b2 07       	cpc	r27, r18
     2c8:	c0 f0       	brcs	.+48     	; 0x2fa <main+0x88>
				cli();
     2ca:	f8 94       	cli
				//atomically write the data that accumulated in the FRAM buffer to the SD card
				writeFile("DATA",FRAMReadBuffer,StartOfFreeSpace);						
     2cc:	20 91 c7 50 	lds	r18, 0x50C7
     2d0:	30 91 c8 50 	lds	r19, 0x50C8
     2d4:	40 91 c9 50 	lds	r20, 0x50C9
     2d8:	50 91 ca 50 	lds	r21, 0x50CA
     2dc:	80 e0       	ldi	r24, 0x00	; 0
     2de:	90 e2       	ldi	r25, 0x20	; 32
     2e0:	60 ee       	ldi	r22, 0xE0	; 224
     2e2:	73 e2       	ldi	r23, 0x23	; 35
     2e4:	0e 94 11 48 	call	0x9022	; 0x9022 <writeFile>
				StartOfFreeSpace = 0;					
     2e8:	10 92 c7 50 	sts	0x50C7, r1
     2ec:	10 92 c8 50 	sts	0x50C8, r1
     2f0:	10 92 c9 50 	sts	0x50C9, r1
     2f4:	10 92 ca 50 	sts	0x50CA, r1
				sei();
     2f8:	78 94       	sei
	SD_init();
	getBootSectorData();
	RadioMonitorMode = DATA_GATHERING;
	uint16_t MotesInSystem = 1;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     2fa:	20 91 75 50 	lds	r18, 0x5075
     2fe:	30 91 76 50 	lds	r19, 0x5076
     302:	89 81       	ldd	r24, Y+1	; 0x01
     304:	9a 81       	ldd	r25, Y+2	; 0x02
     306:	28 17       	cp	r18, r24
     308:	39 07       	cpc	r19, r25
     30a:	78 f2       	brcs	.-98     	; 0x2aa <main+0x38>
				StartOfFreeSpace = 0;					
				sei();
			}				
		}
		//send synch message
		MotesReadyToSynch = 0;	//reset unsynched motes number
     30c:	10 92 75 50 	sts	0x5075, r1
     310:	10 92 76 50 	sts	0x5076, r1
		chb_write(0xFFFF,"start sampling",strlen("start sampling"));
     314:	25 e0       	ldi	r18, 0x05	; 5
     316:	30 e2       	ldi	r19, 0x20	; 32
     318:	8f ef       	ldi	r24, 0xFF	; 255
     31a:	9f ef       	ldi	r25, 0xFF	; 255
     31c:	b9 01       	movw	r22, r18
     31e:	2e e0       	ldi	r18, 0x0E	; 14
     320:	30 e0       	ldi	r19, 0x00	; 0
     322:	40 e0       	ldi	r20, 0x00	; 0
     324:	50 e0       	ldi	r21, 0x00	; 0
     326:	0e 94 ff 20 	call	0x41fe	; 0x41fe <chb_write>
	}	
     32a:	00 00       	nop
	SD_init();
	getBootSectorData();
	RadioMonitorMode = DATA_GATHERING;
	uint16_t MotesInSystem = 1;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     32c:	e6 cf       	rjmp	.-52     	; 0x2fa <main+0x88>

0000032e <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     32e:	cf 93       	push	r28
     330:	df 93       	push	r29
     332:	0f 92       	push	r0
     334:	0f 92       	push	r0
     336:	cd b7       	in	r28, 0x3d	; 61
     338:	de b7       	in	r29, 0x3e	; 62
     33a:	89 83       	std	Y+1, r24	; 0x01
     33c:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	80 93 cd 50 	sts	0x50CD, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     344:	83 e0       	ldi	r24, 0x03	; 3
     346:	80 93 5f 40 	sts	0x405F, r24
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     34a:	80 e8       	ldi	r24, 0x80	; 128
     34c:	91 e0       	ldi	r25, 0x01	; 1
     34e:	28 ec       	ldi	r18, 0xC8	; 200
     350:	fc 01       	movw	r30, r24
     352:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     354:	80 e4       	ldi	r24, 0x40	; 64
     356:	99 e0       	ldi	r25, 0x09	; 9
     358:	29 e0       	ldi	r18, 0x09	; 9
     35a:	fc 01       	movw	r30, r24
     35c:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x03;	//enable timer overflow interrupt as high priority interrupt
     35e:	80 e4       	ldi	r24, 0x40	; 64
     360:	99 e0       	ldi	r25, 0x09	; 9
     362:	23 e0       	ldi	r18, 0x03	; 3
     364:	fc 01       	movw	r30, r24
     366:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     368:	80 e4       	ldi	r24, 0x40	; 64
     36a:	99 e0       	ldi	r25, 0x09	; 9
     36c:	69 81       	ldd	r22, Y+1	; 0x01
     36e:	7a 81       	ldd	r23, Y+2	; 0x02
     370:	44 ef       	ldi	r20, 0xF4	; 244
     372:	51 e0       	ldi	r21, 0x01	; 1
     374:	64 9f       	mul	r22, r20
     376:	90 01       	movw	r18, r0
     378:	65 9f       	mul	r22, r21
     37a:	30 0d       	add	r19, r0
     37c:	74 9f       	mul	r23, r20
     37e:	30 0d       	add	r19, r0
     380:	11 24       	eor	r1, r1
     382:	fc 01       	movw	r30, r24
     384:	26 a3       	lds	r18, 0x56
     386:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     388:	80 e4       	ldi	r24, 0x40	; 64
     38a:	98 e0       	ldi	r25, 0x08	; 8
     38c:	20 e0       	ldi	r18, 0x00	; 0
     38e:	3a ef       	ldi	r19, 0xFA	; 250
     390:	fc 01       	movw	r30, r24
     392:	26 a3       	lds	r18, 0x56
     394:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x02;  //enable timer overflow interrupt as medium priority interrupt
     396:	80 e4       	ldi	r24, 0x40	; 64
     398:	98 e0       	ldi	r25, 0x08	; 8
     39a:	22 e0       	ldi	r18, 0x02	; 2
     39c:	fc 01       	movw	r30, r24
     39e:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     3a0:	80 e4       	ldi	r24, 0x40	; 64
     3a2:	98 e0       	ldi	r25, 0x08	; 8
     3a4:	21 e0       	ldi	r18, 0x01	; 1
     3a6:	fc 01       	movw	r30, r24
     3a8:	20 83       	st	Z, r18
	PMIC.CTRL = ENABLE_ALL_INTERRUPT_LEVELS;
     3aa:	80 ea       	ldi	r24, 0xA0	; 160
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	27 e0       	ldi	r18, 0x07	; 7
     3b0:	fc 01       	movw	r30, r24
     3b2:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     3b4:	78 94       	sei
}
     3b6:	0f 90       	pop	r0
     3b8:	0f 90       	pop	r0
     3ba:	df 91       	pop	r29
     3bc:	cf 91       	pop	r28
     3be:	08 95       	ret

000003c0 <__vector_83>:

ISR(TCD1_OVF_vect) {
     3c0:	1f 92       	push	r1
     3c2:	0f 92       	push	r0
     3c4:	0f b6       	in	r0, 0x3f	; 63
     3c6:	0f 92       	push	r0
     3c8:	00 90 3b 00 	lds	r0, 0x003B
     3cc:	0f 92       	push	r0
     3ce:	11 24       	eor	r1, r1
     3d0:	2f 93       	push	r18
     3d2:	3f 93       	push	r19
     3d4:	4f 93       	push	r20
     3d6:	5f 93       	push	r21
     3d8:	6f 93       	push	r22
     3da:	7f 93       	push	r23
     3dc:	8f 93       	push	r24
     3de:	9f 93       	push	r25
     3e0:	af 93       	push	r26
     3e2:	bf 93       	push	r27
     3e4:	ef 93       	push	r30
     3e6:	ff 93       	push	r31
     3e8:	cf 93       	push	r28
     3ea:	df 93       	push	r29
     3ec:	cd b7       	in	r28, 0x3d	; 61
     3ee:	de b7       	in	r29, 0x3e	; 62
     3f0:	28 97       	sbiw	r28, 0x08	; 8
     3f2:	cd bf       	out	0x3d, r28	; 61
     3f4:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     3f6:	80 e4       	ldi	r24, 0x40	; 64
     3f8:	98 e0       	ldi	r25, 0x08	; 8
     3fa:	fc 01       	movw	r30, r24
     3fc:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     3fe:	80 e4       	ldi	r24, 0x40	; 64
     400:	99 e0       	ldi	r25, 0x09	; 9
     402:	fc 01       	movw	r30, r24
     404:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
     406:	80 e4       	ldi	r24, 0x40	; 64
     408:	98 e0       	ldi	r25, 0x08	; 8
     40a:	2c e0       	ldi	r18, 0x0C	; 12
     40c:	fc 01       	movw	r30, r24
     40e:	21 87       	std	Z+9, r18	; 0x09
	TCD1.CTRLFSET = 0x0C;
     410:	80 e4       	ldi	r24, 0x40	; 64
     412:	99 e0       	ldi	r25, 0x09	; 9
     414:	2c e0       	ldi	r18, 0x0C	; 12
     416:	fc 01       	movw	r30, r24
     418:	21 87       	std	Z+9, r18	; 0x09
	chb_init();
     41a:	0e 94 38 20 	call	0x4070	; 0x4070 <chb_init>
	chb_set_short_addr(moteID);
     41e:	80 91 cd 50 	lds	r24, 0x50CD
     422:	88 2f       	mov	r24, r24
     424:	90 e0       	ldi	r25, 0x00	; 0
     426:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <chb_set_short_addr>
	unsigned char message[8];
	strcpy(message,"reset");
     42a:	ce 01       	movw	r24, r28
     42c:	01 96       	adiw	r24, 0x01	; 1
     42e:	24 e1       	ldi	r18, 0x14	; 20
     430:	30 e2       	ldi	r19, 0x20	; 32
     432:	46 e0       	ldi	r20, 0x06	; 6
     434:	f9 01       	movw	r30, r18
     436:	00 80       	ld	r0, Z
     438:	2f 5f       	subi	r18, 0xFF	; 255
     43a:	3f 4f       	sbci	r19, 0xFF	; 255
     43c:	fc 01       	movw	r30, r24
     43e:	00 82       	st	Z, r0
     440:	01 96       	adiw	r24, 0x01	; 1
     442:	41 50       	subi	r20, 0x01	; 1
     444:	44 23       	and	r20, r20
     446:	b1 f7       	brne	.-20     	; 0x434 <__vector_83+0x74>
	itoa((int)(moteID),buff,10);
     448:	80 91 cd 50 	lds	r24, 0x50CD
     44c:	88 2f       	mov	r24, r24
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	23 ed       	ldi	r18, 0xD3	; 211
     452:	30 e5       	ldi	r19, 0x50	; 80
     454:	b9 01       	movw	r22, r18
     456:	4a e0       	ldi	r20, 0x0A	; 10
     458:	50 e0       	ldi	r21, 0x00	; 0
     45a:	0e 94 61 5f 	call	0xbec2	; 0xbec2 <itoa>
	strcat(message,buff);
     45e:	23 ed       	ldi	r18, 0xD3	; 211
     460:	30 e5       	ldi	r19, 0x50	; 80
     462:	ce 01       	movw	r24, r28
     464:	01 96       	adiw	r24, 0x01	; 1
     466:	b9 01       	movw	r22, r18
     468:	0e 94 48 5f 	call	0xbe90	; 0xbe90 <strcat>
	//insert code here to send and wait for synch message
	//perhaps just disable ADC or ADC interrupts while waiting for reply instead of having the whole mote hang
	RadioMonitorMode = TIME_SYNCH;
     46c:	82 e0       	ldi	r24, 0x02	; 2
     46e:	80 93 5f 40 	sts	0x405F, r24
	ADC_Pause_Sampling();	//pause the ADC while synching
     472:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     476:	ce 01       	movw	r24, r28
     478:	01 96       	adiw	r24, 0x01	; 1
     47a:	9c 01       	movw	r18, r24
     47c:	f9 01       	movw	r30, r18
     47e:	01 90       	ld	r0, Z+
     480:	00 20       	and	r0, r0
     482:	e9 f7       	brne	.-6      	; 0x47e <__vector_83+0xbe>
     484:	cf 01       	movw	r24, r30
     486:	01 97       	sbiw	r24, 0x01	; 1
     488:	82 1b       	sub	r24, r18
     48a:	93 0b       	sbc	r25, r19
     48c:	9c 01       	movw	r18, r24
     48e:	40 e0       	ldi	r20, 0x00	; 0
     490:	50 e0       	ldi	r21, 0x00	; 0
     492:	80 e0       	ldi	r24, 0x00	; 0
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	be 01       	movw	r22, r28
     498:	6f 5f       	subi	r22, 0xFF	; 255
     49a:	7f 4f       	sbci	r23, 0xFF	; 255
     49c:	0e 94 ff 20 	call	0x41fe	; 0x41fe <chb_write>
}	
     4a0:	28 96       	adiw	r28, 0x08	; 8
     4a2:	cd bf       	out	0x3d, r28	; 61
     4a4:	de bf       	out	0x3e, r29	; 62
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	ff 91       	pop	r31
     4ac:	ef 91       	pop	r30
     4ae:	bf 91       	pop	r27
     4b0:	af 91       	pop	r26
     4b2:	9f 91       	pop	r25
     4b4:	8f 91       	pop	r24
     4b6:	7f 91       	pop	r23
     4b8:	6f 91       	pop	r22
     4ba:	5f 91       	pop	r21
     4bc:	4f 91       	pop	r20
     4be:	3f 91       	pop	r19
     4c0:	2f 91       	pop	r18
     4c2:	0f 90       	pop	r0
     4c4:	00 92 3b 00 	sts	0x003B, r0
     4c8:	0f 90       	pop	r0
     4ca:	0f be       	out	0x3f, r0	; 63
     4cc:	0f 90       	pop	r0
     4ce:	1f 90       	pop	r1
     4d0:	18 95       	reti

000004d2 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     4d2:	cf 93       	push	r28
     4d4:	df 93       	push	r29
     4d6:	cd b7       	in	r28, 0x3d	; 61
     4d8:	de b7       	in	r29, 0x3e	; 62
     4da:	6b 97       	sbiw	r28, 0x1b	; 27
     4dc:	cd bf       	out	0x3d, r28	; 61
     4de:	de bf       	out	0x3e, r29	; 62
     4e0:	8e 8b       	std	Y+22, r24	; 0x16
     4e2:	9f 8b       	std	Y+23, r25	; 0x17
     4e4:	68 8f       	std	Y+24, r22	; 0x18
     4e6:	79 8f       	std	Y+25, r23	; 0x19
     4e8:	4a 8f       	std	Y+26, r20	; 0x1a
     4ea:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     4ec:	19 82       	std	Y+1, r1	; 0x01
     4ee:	1a 82       	std	Y+2, r1	; 0x02
     4f0:	1b 82       	std	Y+3, r1	; 0x03
     4f2:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     4f4:	80 e0       	ldi	r24, 0x00	; 0
     4f6:	90 e1       	ldi	r25, 0x10	; 16
     4f8:	a0 e0       	ldi	r26, 0x00	; 0
     4fa:	b0 e0       	ldi	r27, 0x00	; 0
     4fc:	8d 83       	std	Y+5, r24	; 0x05
     4fe:	9e 83       	std	Y+6, r25	; 0x06
     500:	af 83       	std	Y+7, r26	; 0x07
     502:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     504:	19 86       	std	Y+9, r1	; 0x09
     506:	1a 86       	std	Y+10, r1	; 0x0a
     508:	1b 86       	std	Y+11, r1	; 0x0b
     50a:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     50c:	81 e0       	ldi	r24, 0x01	; 1
     50e:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     512:	80 e0       	ldi	r24, 0x00	; 0
     514:	92 e0       	ldi	r25, 0x02	; 2
     516:	0e 94 95 1c 	call	0x392a	; 0x392a <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     51a:	80 e0       	ldi	r24, 0x00	; 0
     51c:	92 e0       	ldi	r25, 0x02	; 2
     51e:	20 e0       	ldi	r18, 0x00	; 0
     520:	32 e0       	ldi	r19, 0x02	; 2
     522:	f9 01       	movw	r30, r18
     524:	21 81       	ldd	r18, Z+1	; 0x01
     526:	29 7e       	andi	r18, 0xE9	; 233
     528:	fc 01       	movw	r30, r24
     52a:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	92 e0       	ldi	r25, 0x02	; 2
     530:	20 e0       	ldi	r18, 0x00	; 0
     532:	32 e0       	ldi	r19, 0x02	; 2
     534:	f9 01       	movw	r30, r18
     536:	24 81       	ldd	r18, Z+4	; 0x04
     538:	28 7f       	andi	r18, 0xF8	; 248
     53a:	23 60       	ori	r18, 0x03	; 3
     53c:	fc 01       	movw	r30, r24
     53e:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     540:	80 e0       	ldi	r24, 0x00	; 0
     542:	92 e0       	ldi	r25, 0x02	; 2
     544:	20 e0       	ldi	r18, 0x00	; 0
     546:	32 e0       	ldi	r19, 0x02	; 2
     548:	f9 01       	movw	r30, r18
     54a:	22 81       	ldd	r18, Z+2	; 0x02
     54c:	2f 7c       	andi	r18, 0xCF	; 207
     54e:	fc 01       	movw	r30, r24
     550:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     552:	80 e2       	ldi	r24, 0x20	; 32
     554:	92 e0       	ldi	r25, 0x02	; 2
     556:	20 e2       	ldi	r18, 0x20	; 32
     558:	32 e0       	ldi	r19, 0x02	; 2
     55a:	f9 01       	movw	r30, r18
     55c:	20 81       	ld	r18, Z
     55e:	20 7e       	andi	r18, 0xE0	; 224
     560:	21 60       	ori	r18, 0x01	; 1
     562:	fc 01       	movw	r30, r24
     564:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     566:	80 e2       	ldi	r24, 0x20	; 32
     568:	92 e0       	ldi	r25, 0x02	; 2
     56a:	29 e0       	ldi	r18, 0x09	; 9
     56c:	fc 01       	movw	r30, r24
     56e:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     570:	80 e0       	ldi	r24, 0x00	; 0
     572:	92 e0       	ldi	r25, 0x02	; 2
     574:	20 e0       	ldi	r18, 0x00	; 0
     576:	32 e0       	ldi	r19, 0x02	; 2
     578:	f9 01       	movw	r30, r18
     57a:	20 81       	ld	r18, Z
     57c:	21 60       	ori	r18, 0x01	; 1
     57e:	fc 01       	movw	r30, r24
     580:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     582:	80 e0       	ldi	r24, 0x00	; 0
     584:	92 e0       	ldi	r25, 0x02	; 2
     586:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     58a:	80 e0       	ldi	r24, 0x00	; 0
     58c:	92 e0       	ldi	r25, 0x02	; 2
     58e:	60 e2       	ldi	r22, 0x20	; 32
     590:	72 e0       	ldi	r23, 0x02	; 2
     592:	40 e0       	ldi	r20, 0x00	; 0
     594:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <ADC_Offset_Get_Unsigned>
     598:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     59a:	80 e0       	ldi	r24, 0x00	; 0
     59c:	92 e0       	ldi	r25, 0x02	; 2
     59e:	20 e0       	ldi	r18, 0x00	; 0
     5a0:	32 e0       	ldi	r19, 0x02	; 2
     5a2:	f9 01       	movw	r30, r18
     5a4:	20 81       	ld	r18, Z
     5a6:	2e 7f       	andi	r18, 0xFE	; 254
     5a8:	fc 01       	movw	r30, r24
     5aa:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     5ac:	80 e2       	ldi	r24, 0x20	; 32
     5ae:	92 e0       	ldi	r25, 0x02	; 2
     5b0:	fc 01       	movw	r30, r24
     5b2:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	92 e0       	ldi	r25, 0x02	; 2
     5b8:	20 e0       	ldi	r18, 0x00	; 0
     5ba:	32 e0       	ldi	r19, 0x02	; 2
     5bc:	f9 01       	movw	r30, r18
     5be:	23 81       	ldd	r18, Z+3	; 0x03
     5c0:	2f 73       	andi	r18, 0x3F	; 63
     5c2:	fc 01       	movw	r30, r24
     5c4:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     5c6:	80 e0       	ldi	r24, 0x00	; 0
     5c8:	92 e0       	ldi	r25, 0x02	; 2
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	32 e0       	ldi	r19, 0x02	; 2
     5ce:	f9 01       	movw	r30, r18
     5d0:	20 81       	ld	r18, Z
     5d2:	21 60       	ori	r18, 0x01	; 1
     5d4:	fc 01       	movw	r30, r24
     5d6:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	92 e0       	ldi	r25, 0x02	; 2
     5dc:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     5e0:	80 e0       	ldi	r24, 0x00	; 0
     5e2:	92 e0       	ldi	r25, 0x02	; 2
     5e4:	20 e0       	ldi	r18, 0x00	; 0
     5e6:	32 e0       	ldi	r19, 0x02	; 2
     5e8:	f9 01       	movw	r30, r18
     5ea:	21 81       	ldd	r18, Z+1	; 0x01
     5ec:	28 60       	ori	r18, 0x08	; 8
     5ee:	fc 01       	movw	r30, r24
     5f0:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     5f2:	1d 86       	std	Y+13, r1	; 0x0d
     5f4:	1e 86       	std	Y+14, r1	; 0x0e
     5f6:	56 c0       	rjmp	.+172    	; 0x6a4 <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     5f8:	80 e2       	ldi	r24, 0x20	; 32
     5fa:	92 e0       	ldi	r25, 0x02	; 2
     5fc:	fc 01       	movw	r30, r24
     5fe:	83 81       	ldd	r24, Z+3	; 0x03
     600:	88 2f       	mov	r24, r24
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	81 70       	andi	r24, 0x01	; 1
     606:	90 70       	andi	r25, 0x00	; 0
     608:	00 97       	sbiw	r24, 0x00	; 0
     60a:	b1 f3       	breq	.-20     	; 0x5f8 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     60c:	2d 89       	ldd	r18, Y+21	; 0x15
     60e:	80 e2       	ldi	r24, 0x20	; 32
     610:	92 e0       	ldi	r25, 0x02	; 2
     612:	62 2f       	mov	r22, r18
     614:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <ADC_ResultCh_GetWord_Signed>
     618:	8f 87       	std	Y+15, r24	; 0x0f
     61a:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     61c:	8f 85       	ldd	r24, Y+15	; 0x0f
     61e:	98 89       	ldd	r25, Y+16	; 0x10
     620:	cc 01       	movw	r24, r24
     622:	a0 e0       	ldi	r26, 0x00	; 0
     624:	b0 e0       	ldi	r27, 0x00	; 0
     626:	29 81       	ldd	r18, Y+1	; 0x01
     628:	3a 81       	ldd	r19, Y+2	; 0x02
     62a:	4b 81       	ldd	r20, Y+3	; 0x03
     62c:	5c 81       	ldd	r21, Y+4	; 0x04
     62e:	82 0f       	add	r24, r18
     630:	93 1f       	adc	r25, r19
     632:	a4 1f       	adc	r26, r20
     634:	b5 1f       	adc	r27, r21
     636:	89 83       	std	Y+1, r24	; 0x01
     638:	9a 83       	std	Y+2, r25	; 0x02
     63a:	ab 83       	std	Y+3, r26	; 0x03
     63c:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     63e:	8f 85       	ldd	r24, Y+15	; 0x0f
     640:	98 89       	ldd	r25, Y+16	; 0x10
     642:	9c 01       	movw	r18, r24
     644:	40 e0       	ldi	r20, 0x00	; 0
     646:	50 e0       	ldi	r21, 0x00	; 0
     648:	89 85       	ldd	r24, Y+9	; 0x09
     64a:	9a 85       	ldd	r25, Y+10	; 0x0a
     64c:	ab 85       	ldd	r26, Y+11	; 0x0b
     64e:	bc 85       	ldd	r27, Y+12	; 0x0c
     650:	82 17       	cp	r24, r18
     652:	93 07       	cpc	r25, r19
     654:	a4 07       	cpc	r26, r20
     656:	b5 07       	cpc	r27, r21
     658:	48 f4       	brcc	.+18     	; 0x66c <CO_collectTemp+0x19a>
     65a:	8f 85       	ldd	r24, Y+15	; 0x0f
     65c:	98 89       	ldd	r25, Y+16	; 0x10
     65e:	cc 01       	movw	r24, r24
     660:	a0 e0       	ldi	r26, 0x00	; 0
     662:	b0 e0       	ldi	r27, 0x00	; 0
     664:	89 87       	std	Y+9, r24	; 0x09
     666:	9a 87       	std	Y+10, r25	; 0x0a
     668:	ab 87       	std	Y+11, r26	; 0x0b
     66a:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     66c:	8f 85       	ldd	r24, Y+15	; 0x0f
     66e:	98 89       	ldd	r25, Y+16	; 0x10
     670:	9c 01       	movw	r18, r24
     672:	40 e0       	ldi	r20, 0x00	; 0
     674:	50 e0       	ldi	r21, 0x00	; 0
     676:	8d 81       	ldd	r24, Y+5	; 0x05
     678:	9e 81       	ldd	r25, Y+6	; 0x06
     67a:	af 81       	ldd	r26, Y+7	; 0x07
     67c:	b8 85       	ldd	r27, Y+8	; 0x08
     67e:	28 17       	cp	r18, r24
     680:	39 07       	cpc	r19, r25
     682:	4a 07       	cpc	r20, r26
     684:	5b 07       	cpc	r21, r27
     686:	48 f4       	brcc	.+18     	; 0x69a <CO_collectTemp+0x1c8>
     688:	8f 85       	ldd	r24, Y+15	; 0x0f
     68a:	98 89       	ldd	r25, Y+16	; 0x10
     68c:	cc 01       	movw	r24, r24
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8d 83       	std	Y+5, r24	; 0x05
     694:	9e 83       	std	Y+6, r25	; 0x06
     696:	af 83       	std	Y+7, r26	; 0x07
     698:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     69a:	8d 85       	ldd	r24, Y+13	; 0x0d
     69c:	9e 85       	ldd	r25, Y+14	; 0x0e
     69e:	01 96       	adiw	r24, 0x01	; 1
     6a0:	8d 87       	std	Y+13, r24	; 0x0d
     6a2:	9e 87       	std	Y+14, r25	; 0x0e
     6a4:	8d 85       	ldd	r24, Y+13	; 0x0d
     6a6:	9e 85       	ldd	r25, Y+14	; 0x0e
     6a8:	f4 e0       	ldi	r31, 0x04	; 4
     6aa:	80 30       	cpi	r24, 0x00	; 0
     6ac:	9f 07       	cpc	r25, r31
     6ae:	08 f4       	brcc	.+2      	; 0x6b2 <CO_collectTemp+0x1e0>
     6b0:	a3 cf       	rjmp	.-186    	; 0x5f8 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     6b2:	80 e0       	ldi	r24, 0x00	; 0
     6b4:	92 e0       	ldi	r25, 0x02	; 2
     6b6:	20 e0       	ldi	r18, 0x00	; 0
     6b8:	32 e0       	ldi	r19, 0x02	; 2
     6ba:	f9 01       	movw	r30, r18
     6bc:	21 81       	ldd	r18, Z+1	; 0x01
     6be:	27 7f       	andi	r18, 0xF7	; 247
     6c0:	fc 01       	movw	r30, r24
     6c2:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     6c4:	80 e0       	ldi	r24, 0x00	; 0
     6c6:	92 e0       	ldi	r25, 0x02	; 2
     6c8:	20 e0       	ldi	r18, 0x00	; 0
     6ca:	32 e0       	ldi	r19, 0x02	; 2
     6cc:	f9 01       	movw	r30, r18
     6ce:	20 81       	ld	r18, Z
     6d0:	22 60       	ori	r18, 0x02	; 2
     6d2:	fc 01       	movw	r30, r24
     6d4:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     6d6:	80 e0       	ldi	r24, 0x00	; 0
     6d8:	92 e0       	ldi	r25, 0x02	; 2
     6da:	20 e0       	ldi	r18, 0x00	; 0
     6dc:	32 e0       	ldi	r19, 0x02	; 2
     6de:	f9 01       	movw	r30, r18
     6e0:	20 81       	ld	r18, Z
     6e2:	2e 7f       	andi	r18, 0xFE	; 254
     6e4:	fc 01       	movw	r30, r24
     6e6:	20 83       	st	Z, r18

	ADCPower(FALSE);
     6e8:	80 e0       	ldi	r24, 0x00	; 0
     6ea:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>

	average = sum / NUM_SAMPLES;
     6ee:	89 81       	ldd	r24, Y+1	; 0x01
     6f0:	9a 81       	ldd	r25, Y+2	; 0x02
     6f2:	ab 81       	ldd	r26, Y+3	; 0x03
     6f4:	bc 81       	ldd	r27, Y+4	; 0x04
     6f6:	07 2e       	mov	r0, r23
     6f8:	7a e0       	ldi	r23, 0x0A	; 10
     6fa:	b6 95       	lsr	r27
     6fc:	a7 95       	ror	r26
     6fe:	97 95       	ror	r25
     700:	87 95       	ror	r24
     702:	7a 95       	dec	r23
     704:	d1 f7       	brne	.-12     	; 0x6fa <CO_collectTemp+0x228>
     706:	70 2d       	mov	r23, r0
     708:	89 8b       	std	Y+17, r24	; 0x11
     70a:	9a 8b       	std	Y+18, r25	; 0x12
     70c:	ab 8b       	std	Y+19, r26	; 0x13
     70e:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     710:	89 89       	ldd	r24, Y+17	; 0x11
     712:	9a 89       	ldd	r25, Y+18	; 0x12
     714:	ab 89       	ldd	r26, Y+19	; 0x13
     716:	bc 89       	ldd	r27, Y+20	; 0x14
     718:	28 ee       	ldi	r18, 0xE8	; 232
     71a:	33 e0       	ldi	r19, 0x03	; 3
     71c:	40 e0       	ldi	r20, 0x00	; 0
     71e:	50 e0       	ldi	r21, 0x00	; 0
     720:	bc 01       	movw	r22, r24
     722:	cd 01       	movw	r24, r26
     724:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
     728:	dc 01       	movw	r26, r24
     72a:	cb 01       	movw	r24, r22
     72c:	2f ef       	ldi	r18, 0xFF	; 255
     72e:	3f e0       	ldi	r19, 0x0F	; 15
     730:	40 e0       	ldi	r20, 0x00	; 0
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	bc 01       	movw	r22, r24
     736:	cd 01       	movw	r24, r26
     738:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
     73c:	da 01       	movw	r26, r20
     73e:	c9 01       	movw	r24, r18
     740:	9c 01       	movw	r18, r24
     742:	22 53       	subi	r18, 0x32	; 50
     744:	30 40       	sbci	r19, 0x00	; 0
     746:	8e 89       	ldd	r24, Y+22	; 0x16
     748:	9f 89       	ldd	r25, Y+23	; 0x17
     74a:	fc 01       	movw	r30, r24
     74c:	20 83       	st	Z, r18
     74e:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     750:	89 85       	ldd	r24, Y+9	; 0x09
     752:	9a 85       	ldd	r25, Y+10	; 0x0a
     754:	ab 85       	ldd	r26, Y+11	; 0x0b
     756:	bc 85       	ldd	r27, Y+12	; 0x0c
     758:	28 ee       	ldi	r18, 0xE8	; 232
     75a:	33 e0       	ldi	r19, 0x03	; 3
     75c:	40 e0       	ldi	r20, 0x00	; 0
     75e:	50 e0       	ldi	r21, 0x00	; 0
     760:	bc 01       	movw	r22, r24
     762:	cd 01       	movw	r24, r26
     764:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
     768:	dc 01       	movw	r26, r24
     76a:	cb 01       	movw	r24, r22
     76c:	2f ef       	ldi	r18, 0xFF	; 255
     76e:	3f e0       	ldi	r19, 0x0F	; 15
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	bc 01       	movw	r22, r24
     776:	cd 01       	movw	r24, r26
     778:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
     77c:	da 01       	movw	r26, r20
     77e:	c9 01       	movw	r24, r18
     780:	9c 01       	movw	r18, r24
     782:	22 53       	subi	r18, 0x32	; 50
     784:	30 40       	sbci	r19, 0x00	; 0
     786:	8a 8d       	ldd	r24, Y+26	; 0x1a
     788:	9b 8d       	ldd	r25, Y+27	; 0x1b
     78a:	fc 01       	movw	r30, r24
     78c:	20 83       	st	Z, r18
     78e:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     790:	8d 81       	ldd	r24, Y+5	; 0x05
     792:	9e 81       	ldd	r25, Y+6	; 0x06
     794:	af 81       	ldd	r26, Y+7	; 0x07
     796:	b8 85       	ldd	r27, Y+8	; 0x08
     798:	28 ee       	ldi	r18, 0xE8	; 232
     79a:	33 e0       	ldi	r19, 0x03	; 3
     79c:	40 e0       	ldi	r20, 0x00	; 0
     79e:	50 e0       	ldi	r21, 0x00	; 0
     7a0:	bc 01       	movw	r22, r24
     7a2:	cd 01       	movw	r24, r26
     7a4:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
     7a8:	dc 01       	movw	r26, r24
     7aa:	cb 01       	movw	r24, r22
     7ac:	2f ef       	ldi	r18, 0xFF	; 255
     7ae:	3f e0       	ldi	r19, 0x0F	; 15
     7b0:	40 e0       	ldi	r20, 0x00	; 0
     7b2:	50 e0       	ldi	r21, 0x00	; 0
     7b4:	bc 01       	movw	r22, r24
     7b6:	cd 01       	movw	r24, r26
     7b8:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
     7bc:	da 01       	movw	r26, r20
     7be:	c9 01       	movw	r24, r18
     7c0:	9c 01       	movw	r18, r24
     7c2:	22 53       	subi	r18, 0x32	; 50
     7c4:	30 40       	sbci	r19, 0x00	; 0
     7c6:	88 8d       	ldd	r24, Y+24	; 0x18
     7c8:	99 8d       	ldd	r25, Y+25	; 0x19
     7ca:	fc 01       	movw	r30, r24
     7cc:	20 83       	st	Z, r18
     7ce:	31 83       	std	Z+1, r19	; 0x01
}
     7d0:	6b 96       	adiw	r28, 0x1b	; 27
     7d2:	cd bf       	out	0x3d, r28	; 61
     7d4:	de bf       	out	0x3e, r29	; 62
     7d6:	df 91       	pop	r29
     7d8:	cf 91       	pop	r28
     7da:	08 95       	ret

000007dc <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	cd b7       	in	r28, 0x3d	; 61
     7e6:	de b7       	in	r29, 0x3e	; 62
     7e8:	a9 97       	sbiw	r28, 0x29	; 41
     7ea:	cd bf       	out	0x3d, r28	; 61
     7ec:	de bf       	out	0x3e, r29	; 62
     7ee:	8c a3       	lds	r24, 0x5c
     7f0:	9d a3       	lds	r25, 0x5d
     7f2:	6e a3       	lds	r22, 0x5e
     7f4:	7f a3       	lds	r23, 0x5f
     7f6:	48 a7       	lds	r20, 0x78
     7f8:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     7fa:	19 82       	std	Y+1, r1	; 0x01
     7fc:	1a 82       	std	Y+2, r1	; 0x02
     7fe:	1b 82       	std	Y+3, r1	; 0x03
     800:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     802:	80 e0       	ldi	r24, 0x00	; 0
     804:	90 e1       	ldi	r25, 0x10	; 16
     806:	a0 e0       	ldi	r26, 0x00	; 0
     808:	b0 e0       	ldi	r27, 0x00	; 0
     80a:	8d 83       	std	Y+5, r24	; 0x05
     80c:	9e 83       	std	Y+6, r25	; 0x06
     80e:	af 83       	std	Y+7, r26	; 0x07
     810:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     812:	19 86       	std	Y+9, r1	; 0x09
     814:	1a 86       	std	Y+10, r1	; 0x0a
     816:	1b 86       	std	Y+11, r1	; 0x0b
     818:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     820:	84 e0       	ldi	r24, 0x04	; 4
     822:	60 e0       	ldi	r22, 0x00	; 0
     824:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     828:	84 e0       	ldi	r24, 0x04	; 4
     82a:	60 e0       	ldi	r22, 0x00	; 0
     82c:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
     830:	80 e0       	ldi	r24, 0x00	; 0
     832:	90 e0       	ldi	r25, 0x00	; 0
     834:	a8 ec       	ldi	r26, 0xC8	; 200
     836:	b2 e4       	ldi	r27, 0x42	; 66
     838:	8d 8b       	std	Y+21, r24	; 0x15
     83a:	9e 8b       	std	Y+22, r25	; 0x16
     83c:	af 8b       	std	Y+23, r26	; 0x17
     83e:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     840:	6d 89       	ldd	r22, Y+21	; 0x15
     842:	7e 89       	ldd	r23, Y+22	; 0x16
     844:	8f 89       	ldd	r24, Y+23	; 0x17
     846:	98 8d       	ldd	r25, Y+24	; 0x18
     848:	20 e0       	ldi	r18, 0x00	; 0
     84a:	30 e0       	ldi	r19, 0x00	; 0
     84c:	4a ef       	ldi	r20, 0xFA	; 250
     84e:	55 e4       	ldi	r21, 0x45	; 69
     850:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
     854:	dc 01       	movw	r26, r24
     856:	cb 01       	movw	r24, r22
     858:	89 8f       	std	Y+25, r24	; 0x19
     85a:	9a 8f       	std	Y+26, r25	; 0x1a
     85c:	ab 8f       	std	Y+27, r26	; 0x1b
     85e:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     860:	11 e0       	ldi	r17, 0x01	; 1
     862:	69 8d       	ldd	r22, Y+25	; 0x19
     864:	7a 8d       	ldd	r23, Y+26	; 0x1a
     866:	8b 8d       	ldd	r24, Y+27	; 0x1b
     868:	9c 8d       	ldd	r25, Y+28	; 0x1c
     86a:	20 e0       	ldi	r18, 0x00	; 0
     86c:	30 e0       	ldi	r19, 0x00	; 0
     86e:	40 e8       	ldi	r20, 0x80	; 128
     870:	5f e3       	ldi	r21, 0x3F	; 63
     872:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
     876:	88 23       	and	r24, r24
     878:	0c f0       	brlt	.+2      	; 0x87c <CO_collectBatt+0xa0>
     87a:	10 e0       	ldi	r17, 0x00	; 0
     87c:	11 23       	and	r17, r17
     87e:	29 f0       	breq	.+10     	; 0x88a <CO_collectBatt+0xae>
		__ticks = 1;
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	8d 8f       	std	Y+29, r24	; 0x1d
     886:	9e 8f       	std	Y+30, r25	; 0x1e
     888:	46 c0       	rjmp	.+140    	; 0x916 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     88a:	11 e0       	ldi	r17, 0x01	; 1
     88c:	69 8d       	ldd	r22, Y+25	; 0x19
     88e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     890:	8b 8d       	ldd	r24, Y+27	; 0x1b
     892:	9c 8d       	ldd	r25, Y+28	; 0x1c
     894:	20 e0       	ldi	r18, 0x00	; 0
     896:	3f ef       	ldi	r19, 0xFF	; 255
     898:	4f e7       	ldi	r20, 0x7F	; 127
     89a:	57 e4       	ldi	r21, 0x47	; 71
     89c:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
     8a0:	18 16       	cp	r1, r24
     8a2:	0c f0       	brlt	.+2      	; 0x8a6 <CO_collectBatt+0xca>
     8a4:	10 e0       	ldi	r17, 0x00	; 0
     8a6:	11 23       	and	r17, r17
     8a8:	61 f1       	breq	.+88     	; 0x902 <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     8aa:	6d 89       	ldd	r22, Y+21	; 0x15
     8ac:	7e 89       	ldd	r23, Y+22	; 0x16
     8ae:	8f 89       	ldd	r24, Y+23	; 0x17
     8b0:	98 8d       	ldd	r25, Y+24	; 0x18
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	30 e0       	ldi	r19, 0x00	; 0
     8b6:	40 e2       	ldi	r20, 0x20	; 32
     8b8:	51 e4       	ldi	r21, 0x41	; 65
     8ba:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
     8be:	dc 01       	movw	r26, r24
     8c0:	cb 01       	movw	r24, r22
     8c2:	bc 01       	movw	r22, r24
     8c4:	cd 01       	movw	r24, r26
     8c6:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
     8ca:	dc 01       	movw	r26, r24
     8cc:	cb 01       	movw	r24, r22
     8ce:	8d 8f       	std	Y+29, r24	; 0x1d
     8d0:	9e 8f       	std	Y+30, r25	; 0x1e
     8d2:	12 c0       	rjmp	.+36     	; 0x8f8 <CO_collectBatt+0x11c>
     8d4:	80 e2       	ldi	r24, 0x20	; 32
     8d6:	93 e0       	ldi	r25, 0x03	; 3
     8d8:	8f 8f       	std	Y+31, r24	; 0x1f
     8da:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8dc:	8f 8d       	ldd	r24, Y+31	; 0x1f
     8de:	98 a1       	lds	r25, 0x48
     8e0:	8c 01       	movw	r16, r24
     8e2:	c8 01       	movw	r24, r16
     8e4:	01 97       	sbiw	r24, 0x01	; 1
     8e6:	f1 f7       	brne	.-4      	; 0x8e4 <CO_collectBatt+0x108>
     8e8:	8c 01       	movw	r16, r24
     8ea:	0f 8f       	std	Y+31, r16	; 0x1f
     8ec:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8ee:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8f0:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8f2:	01 97       	sbiw	r24, 0x01	; 1
     8f4:	8d 8f       	std	Y+29, r24	; 0x1d
     8f6:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8f8:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8fa:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8fc:	00 97       	sbiw	r24, 0x00	; 0
     8fe:	51 f7       	brne	.-44     	; 0x8d4 <CO_collectBatt+0xf8>
     900:	17 c0       	rjmp	.+46     	; 0x930 <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     902:	69 8d       	ldd	r22, Y+25	; 0x19
     904:	7a 8d       	ldd	r23, Y+26	; 0x1a
     906:	8b 8d       	ldd	r24, Y+27	; 0x1b
     908:	9c 8d       	ldd	r25, Y+28	; 0x1c
     90a:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
     90e:	dc 01       	movw	r26, r24
     910:	cb 01       	movw	r24, r22
     912:	8d 8f       	std	Y+29, r24	; 0x1d
     914:	9e 8f       	std	Y+30, r25	; 0x1e
     916:	8d 8d       	ldd	r24, Y+29	; 0x1d
     918:	9e 8d       	ldd	r25, Y+30	; 0x1e
     91a:	89 a3       	lds	r24, 0x59
     91c:	9a a3       	lds	r25, 0x5a
     91e:	89 a1       	lds	r24, 0x49
     920:	9a a1       	lds	r25, 0x4a
     922:	8c 01       	movw	r16, r24
     924:	f8 01       	movw	r30, r16
     926:	31 97       	sbiw	r30, 0x01	; 1
     928:	f1 f7       	brne	.-4      	; 0x926 <CO_collectBatt+0x14a>
     92a:	8f 01       	movw	r16, r30
     92c:	09 a3       	lds	r16, 0x59
     92e:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     930:	80 e4       	ldi	r24, 0x40	; 64
     932:	92 e0       	ldi	r25, 0x02	; 2
     934:	0e 94 95 1c 	call	0x392a	; 0x392a <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     938:	80 e4       	ldi	r24, 0x40	; 64
     93a:	92 e0       	ldi	r25, 0x02	; 2
     93c:	20 e4       	ldi	r18, 0x40	; 64
     93e:	32 e0       	ldi	r19, 0x02	; 2
     940:	f9 01       	movw	r30, r18
     942:	21 81       	ldd	r18, Z+1	; 0x01
     944:	29 7e       	andi	r18, 0xE9	; 233
     946:	fc 01       	movw	r30, r24
     948:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     94a:	80 e4       	ldi	r24, 0x40	; 64
     94c:	92 e0       	ldi	r25, 0x02	; 2
     94e:	20 e4       	ldi	r18, 0x40	; 64
     950:	32 e0       	ldi	r19, 0x02	; 2
     952:	f9 01       	movw	r30, r18
     954:	24 81       	ldd	r18, Z+4	; 0x04
     956:	28 7f       	andi	r18, 0xF8	; 248
     958:	23 60       	ori	r18, 0x03	; 3
     95a:	fc 01       	movw	r30, r24
     95c:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     95e:	80 e4       	ldi	r24, 0x40	; 64
     960:	92 e0       	ldi	r25, 0x02	; 2
     962:	20 e4       	ldi	r18, 0x40	; 64
     964:	32 e0       	ldi	r19, 0x02	; 2
     966:	f9 01       	movw	r30, r18
     968:	22 81       	ldd	r18, Z+2	; 0x02
     96a:	2f 7c       	andi	r18, 0xCF	; 207
     96c:	fc 01       	movw	r30, r24
     96e:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     970:	80 e6       	ldi	r24, 0x60	; 96
     972:	92 e0       	ldi	r25, 0x02	; 2
     974:	20 e6       	ldi	r18, 0x60	; 96
     976:	32 e0       	ldi	r19, 0x02	; 2
     978:	f9 01       	movw	r30, r18
     97a:	20 81       	ld	r18, Z
     97c:	20 7e       	andi	r18, 0xE0	; 224
     97e:	21 60       	ori	r18, 0x01	; 1
     980:	fc 01       	movw	r30, r24
     982:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     984:	80 e6       	ldi	r24, 0x60	; 96
     986:	92 e0       	ldi	r25, 0x02	; 2
     988:	29 e0       	ldi	r18, 0x09	; 9
     98a:	fc 01       	movw	r30, r24
     98c:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     98e:	80 e4       	ldi	r24, 0x40	; 64
     990:	92 e0       	ldi	r25, 0x02	; 2
     992:	20 e4       	ldi	r18, 0x40	; 64
     994:	32 e0       	ldi	r19, 0x02	; 2
     996:	f9 01       	movw	r30, r18
     998:	20 81       	ld	r18, Z
     99a:	21 60       	ori	r18, 0x01	; 1
     99c:	fc 01       	movw	r30, r24
     99e:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     9a0:	80 e4       	ldi	r24, 0x40	; 64
     9a2:	92 e0       	ldi	r25, 0x02	; 2
     9a4:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     9a8:	80 e4       	ldi	r24, 0x40	; 64
     9aa:	92 e0       	ldi	r25, 0x02	; 2
     9ac:	60 e6       	ldi	r22, 0x60	; 96
     9ae:	72 e0       	ldi	r23, 0x02	; 2
     9b0:	40 e0       	ldi	r20, 0x00	; 0
     9b2:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <ADC_Offset_Get_Unsigned>
     9b6:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     9b8:	80 e4       	ldi	r24, 0x40	; 64
     9ba:	92 e0       	ldi	r25, 0x02	; 2
     9bc:	20 e4       	ldi	r18, 0x40	; 64
     9be:	32 e0       	ldi	r19, 0x02	; 2
     9c0:	f9 01       	movw	r30, r18
     9c2:	20 81       	ld	r18, Z
     9c4:	2e 7f       	andi	r18, 0xFE	; 254
     9c6:	fc 01       	movw	r30, r24
     9c8:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     9ca:	80 e6       	ldi	r24, 0x60	; 96
     9cc:	92 e0       	ldi	r25, 0x02	; 2
     9ce:	fc 01       	movw	r30, r24
     9d0:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     9d2:	80 e4       	ldi	r24, 0x40	; 64
     9d4:	92 e0       	ldi	r25, 0x02	; 2
     9d6:	20 e4       	ldi	r18, 0x40	; 64
     9d8:	32 e0       	ldi	r19, 0x02	; 2
     9da:	f9 01       	movw	r30, r18
     9dc:	23 81       	ldd	r18, Z+3	; 0x03
     9de:	2f 73       	andi	r18, 0x3F	; 63
     9e0:	fc 01       	movw	r30, r24
     9e2:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     9e4:	80 e4       	ldi	r24, 0x40	; 64
     9e6:	92 e0       	ldi	r25, 0x02	; 2
     9e8:	20 e4       	ldi	r18, 0x40	; 64
     9ea:	32 e0       	ldi	r19, 0x02	; 2
     9ec:	f9 01       	movw	r30, r18
     9ee:	20 81       	ld	r18, Z
     9f0:	21 60       	ori	r18, 0x01	; 1
     9f2:	fc 01       	movw	r30, r24
     9f4:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     9f6:	80 e4       	ldi	r24, 0x40	; 64
     9f8:	92 e0       	ldi	r25, 0x02	; 2
     9fa:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     9fe:	80 e4       	ldi	r24, 0x40	; 64
     a00:	92 e0       	ldi	r25, 0x02	; 2
     a02:	20 e4       	ldi	r18, 0x40	; 64
     a04:	32 e0       	ldi	r19, 0x02	; 2
     a06:	f9 01       	movw	r30, r18
     a08:	21 81       	ldd	r18, Z+1	; 0x01
     a0a:	28 60       	ori	r18, 0x08	; 8
     a0c:	fc 01       	movw	r30, r24
     a0e:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a10:	1d 86       	std	Y+13, r1	; 0x0d
     a12:	1e 86       	std	Y+14, r1	; 0x0e
     a14:	56 c0       	rjmp	.+172    	; 0xac2 <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     a16:	80 e6       	ldi	r24, 0x60	; 96
     a18:	92 e0       	ldi	r25, 0x02	; 2
     a1a:	fc 01       	movw	r30, r24
     a1c:	83 81       	ldd	r24, Z+3	; 0x03
     a1e:	88 2f       	mov	r24, r24
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	81 70       	andi	r24, 0x01	; 1
     a24:	90 70       	andi	r25, 0x00	; 0
     a26:	00 97       	sbiw	r24, 0x00	; 0
     a28:	b1 f3       	breq	.-20     	; 0xa16 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a2a:	2b a1       	lds	r18, 0x4b
     a2c:	80 e6       	ldi	r24, 0x60	; 96
     a2e:	92 e0       	ldi	r25, 0x02	; 2
     a30:	62 2f       	mov	r22, r18
     a32:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <ADC_ResultCh_GetWord_Signed>
     a36:	8f 87       	std	Y+15, r24	; 0x0f
     a38:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     a3a:	8f 85       	ldd	r24, Y+15	; 0x0f
     a3c:	98 89       	ldd	r25, Y+16	; 0x10
     a3e:	cc 01       	movw	r24, r24
     a40:	a0 e0       	ldi	r26, 0x00	; 0
     a42:	b0 e0       	ldi	r27, 0x00	; 0
     a44:	29 81       	ldd	r18, Y+1	; 0x01
     a46:	3a 81       	ldd	r19, Y+2	; 0x02
     a48:	4b 81       	ldd	r20, Y+3	; 0x03
     a4a:	5c 81       	ldd	r21, Y+4	; 0x04
     a4c:	82 0f       	add	r24, r18
     a4e:	93 1f       	adc	r25, r19
     a50:	a4 1f       	adc	r26, r20
     a52:	b5 1f       	adc	r27, r21
     a54:	89 83       	std	Y+1, r24	; 0x01
     a56:	9a 83       	std	Y+2, r25	; 0x02
     a58:	ab 83       	std	Y+3, r26	; 0x03
     a5a:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     a5c:	8f 85       	ldd	r24, Y+15	; 0x0f
     a5e:	98 89       	ldd	r25, Y+16	; 0x10
     a60:	9c 01       	movw	r18, r24
     a62:	40 e0       	ldi	r20, 0x00	; 0
     a64:	50 e0       	ldi	r21, 0x00	; 0
     a66:	89 85       	ldd	r24, Y+9	; 0x09
     a68:	9a 85       	ldd	r25, Y+10	; 0x0a
     a6a:	ab 85       	ldd	r26, Y+11	; 0x0b
     a6c:	bc 85       	ldd	r27, Y+12	; 0x0c
     a6e:	82 17       	cp	r24, r18
     a70:	93 07       	cpc	r25, r19
     a72:	a4 07       	cpc	r26, r20
     a74:	b5 07       	cpc	r27, r21
     a76:	48 f4       	brcc	.+18     	; 0xa8a <CO_collectBatt+0x2ae>
     a78:	8f 85       	ldd	r24, Y+15	; 0x0f
     a7a:	98 89       	ldd	r25, Y+16	; 0x10
     a7c:	cc 01       	movw	r24, r24
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	89 87       	std	Y+9, r24	; 0x09
     a84:	9a 87       	std	Y+10, r25	; 0x0a
     a86:	ab 87       	std	Y+11, r26	; 0x0b
     a88:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     a8a:	8f 85       	ldd	r24, Y+15	; 0x0f
     a8c:	98 89       	ldd	r25, Y+16	; 0x10
     a8e:	9c 01       	movw	r18, r24
     a90:	40 e0       	ldi	r20, 0x00	; 0
     a92:	50 e0       	ldi	r21, 0x00	; 0
     a94:	8d 81       	ldd	r24, Y+5	; 0x05
     a96:	9e 81       	ldd	r25, Y+6	; 0x06
     a98:	af 81       	ldd	r26, Y+7	; 0x07
     a9a:	b8 85       	ldd	r27, Y+8	; 0x08
     a9c:	28 17       	cp	r18, r24
     a9e:	39 07       	cpc	r19, r25
     aa0:	4a 07       	cpc	r20, r26
     aa2:	5b 07       	cpc	r21, r27
     aa4:	48 f4       	brcc	.+18     	; 0xab8 <CO_collectBatt+0x2dc>
     aa6:	8f 85       	ldd	r24, Y+15	; 0x0f
     aa8:	98 89       	ldd	r25, Y+16	; 0x10
     aaa:	cc 01       	movw	r24, r24
     aac:	a0 e0       	ldi	r26, 0x00	; 0
     aae:	b0 e0       	ldi	r27, 0x00	; 0
     ab0:	8d 83       	std	Y+5, r24	; 0x05
     ab2:	9e 83       	std	Y+6, r25	; 0x06
     ab4:	af 83       	std	Y+7, r26	; 0x07
     ab6:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     ab8:	8d 85       	ldd	r24, Y+13	; 0x0d
     aba:	9e 85       	ldd	r25, Y+14	; 0x0e
     abc:	01 96       	adiw	r24, 0x01	; 1
     abe:	8d 87       	std	Y+13, r24	; 0x0d
     ac0:	9e 87       	std	Y+14, r25	; 0x0e
     ac2:	8d 85       	ldd	r24, Y+13	; 0x0d
     ac4:	9e 85       	ldd	r25, Y+14	; 0x0e
     ac6:	f4 e0       	ldi	r31, 0x04	; 4
     ac8:	80 30       	cpi	r24, 0x00	; 0
     aca:	9f 07       	cpc	r25, r31
     acc:	08 f4       	brcc	.+2      	; 0xad0 <CO_collectBatt+0x2f4>
     ace:	a3 cf       	rjmp	.-186    	; 0xa16 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     ad0:	80 e4       	ldi	r24, 0x40	; 64
     ad2:	92 e0       	ldi	r25, 0x02	; 2
     ad4:	20 e4       	ldi	r18, 0x40	; 64
     ad6:	32 e0       	ldi	r19, 0x02	; 2
     ad8:	f9 01       	movw	r30, r18
     ada:	21 81       	ldd	r18, Z+1	; 0x01
     adc:	27 7f       	andi	r18, 0xF7	; 247
     ade:	fc 01       	movw	r30, r24
     ae0:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     ae2:	80 e4       	ldi	r24, 0x40	; 64
     ae4:	92 e0       	ldi	r25, 0x02	; 2
     ae6:	20 e4       	ldi	r18, 0x40	; 64
     ae8:	32 e0       	ldi	r19, 0x02	; 2
     aea:	f9 01       	movw	r30, r18
     aec:	20 81       	ld	r18, Z
     aee:	2e 7f       	andi	r18, 0xFE	; 254
     af0:	fc 01       	movw	r30, r24
     af2:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     af4:	89 81       	ldd	r24, Y+1	; 0x01
     af6:	9a 81       	ldd	r25, Y+2	; 0x02
     af8:	ab 81       	ldd	r26, Y+3	; 0x03
     afa:	bc 81       	ldd	r27, Y+4	; 0x04
     afc:	07 2e       	mov	r0, r23
     afe:	7a e0       	ldi	r23, 0x0A	; 10
     b00:	b6 95       	lsr	r27
     b02:	a7 95       	ror	r26
     b04:	97 95       	ror	r25
     b06:	87 95       	ror	r24
     b08:	7a 95       	dec	r23
     b0a:	d1 f7       	brne	.-12     	; 0xb00 <CO_collectBatt+0x324>
     b0c:	70 2d       	mov	r23, r0
     b0e:	89 8b       	std	Y+17, r24	; 0x11
     b10:	9a 8b       	std	Y+18, r25	; 0x12
     b12:	ab 8b       	std	Y+19, r26	; 0x13
     b14:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     b16:	84 e0       	ldi	r24, 0x04	; 4
     b18:	60 e0       	ldi	r22, 0x00	; 0
     b1a:	0e 94 79 35 	call	0x6af2	; 0x6af2 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     b1e:	80 e0       	ldi	r24, 0x00	; 0
     b20:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b24:	89 89       	ldd	r24, Y+17	; 0x11
     b26:	9a 89       	ldd	r25, Y+18	; 0x12
     b28:	ab 89       	ldd	r26, Y+19	; 0x13
     b2a:	bc 89       	ldd	r27, Y+20	; 0x14
     b2c:	28 ee       	ldi	r18, 0xE8	; 232
     b2e:	33 e0       	ldi	r19, 0x03	; 3
     b30:	40 e0       	ldi	r20, 0x00	; 0
     b32:	50 e0       	ldi	r21, 0x00	; 0
     b34:	bc 01       	movw	r22, r24
     b36:	cd 01       	movw	r24, r26
     b38:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
     b3c:	dc 01       	movw	r26, r24
     b3e:	cb 01       	movw	r24, r22
     b40:	2f ef       	ldi	r18, 0xFF	; 255
     b42:	3f e0       	ldi	r19, 0x0F	; 15
     b44:	40 e0       	ldi	r20, 0x00	; 0
     b46:	50 e0       	ldi	r21, 0x00	; 0
     b48:	bc 01       	movw	r22, r24
     b4a:	cd 01       	movw	r24, r26
     b4c:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
     b50:	da 01       	movw	r26, r20
     b52:	c9 01       	movw	r24, r18
     b54:	9c 01       	movw	r18, r24
     b56:	22 53       	subi	r18, 0x32	; 50
     b58:	30 40       	sbci	r19, 0x00	; 0
     b5a:	8c a1       	lds	r24, 0x4c
     b5c:	9d a1       	lds	r25, 0x4d
     b5e:	fc 01       	movw	r30, r24
     b60:	20 83       	st	Z, r18
     b62:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     b64:	89 85       	ldd	r24, Y+9	; 0x09
     b66:	9a 85       	ldd	r25, Y+10	; 0x0a
     b68:	ab 85       	ldd	r26, Y+11	; 0x0b
     b6a:	bc 85       	ldd	r27, Y+12	; 0x0c
     b6c:	28 ee       	ldi	r18, 0xE8	; 232
     b6e:	33 e0       	ldi	r19, 0x03	; 3
     b70:	40 e0       	ldi	r20, 0x00	; 0
     b72:	50 e0       	ldi	r21, 0x00	; 0
     b74:	bc 01       	movw	r22, r24
     b76:	cd 01       	movw	r24, r26
     b78:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
     b7c:	dc 01       	movw	r26, r24
     b7e:	cb 01       	movw	r24, r22
     b80:	2f ef       	ldi	r18, 0xFF	; 255
     b82:	3f e0       	ldi	r19, 0x0F	; 15
     b84:	40 e0       	ldi	r20, 0x00	; 0
     b86:	50 e0       	ldi	r21, 0x00	; 0
     b88:	bc 01       	movw	r22, r24
     b8a:	cd 01       	movw	r24, r26
     b8c:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
     b90:	da 01       	movw	r26, r20
     b92:	c9 01       	movw	r24, r18
     b94:	9c 01       	movw	r18, r24
     b96:	22 53       	subi	r18, 0x32	; 50
     b98:	30 40       	sbci	r19, 0x00	; 0
     b9a:	88 a5       	lds	r24, 0x68
     b9c:	99 a5       	lds	r25, 0x69
     b9e:	fc 01       	movw	r30, r24
     ba0:	20 83       	st	Z, r18
     ba2:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     ba4:	8d 81       	ldd	r24, Y+5	; 0x05
     ba6:	9e 81       	ldd	r25, Y+6	; 0x06
     ba8:	af 81       	ldd	r26, Y+7	; 0x07
     baa:	b8 85       	ldd	r27, Y+8	; 0x08
     bac:	28 ee       	ldi	r18, 0xE8	; 232
     bae:	33 e0       	ldi	r19, 0x03	; 3
     bb0:	40 e0       	ldi	r20, 0x00	; 0
     bb2:	50 e0       	ldi	r21, 0x00	; 0
     bb4:	bc 01       	movw	r22, r24
     bb6:	cd 01       	movw	r24, r26
     bb8:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
     bbc:	dc 01       	movw	r26, r24
     bbe:	cb 01       	movw	r24, r22
     bc0:	2f ef       	ldi	r18, 0xFF	; 255
     bc2:	3f e0       	ldi	r19, 0x0F	; 15
     bc4:	40 e0       	ldi	r20, 0x00	; 0
     bc6:	50 e0       	ldi	r21, 0x00	; 0
     bc8:	bc 01       	movw	r22, r24
     bca:	cd 01       	movw	r24, r26
     bcc:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
     bd0:	da 01       	movw	r26, r20
     bd2:	c9 01       	movw	r24, r18
     bd4:	9c 01       	movw	r18, r24
     bd6:	22 53       	subi	r18, 0x32	; 50
     bd8:	30 40       	sbci	r19, 0x00	; 0
     bda:	8e a1       	lds	r24, 0x4e
     bdc:	9f a1       	lds	r25, 0x4f
     bde:	fc 01       	movw	r30, r24
     be0:	20 83       	st	Z, r18
     be2:	31 83       	std	Z+1, r19	; 0x01
}
     be4:	a9 96       	adiw	r28, 0x29	; 41
     be6:	cd bf       	out	0x3d, r28	; 61
     be8:	de bf       	out	0x3e, r29	; 62
     bea:	df 91       	pop	r29
     bec:	cf 91       	pop	r28
     bee:	1f 91       	pop	r17
     bf0:	0f 91       	pop	r16
     bf2:	08 95       	ret

00000bf4 <ADCPower>:

void ADCPower(uint8_t on) {
     bf4:	0f 93       	push	r16
     bf6:	1f 93       	push	r17
     bf8:	cf 93       	push	r28
     bfa:	df 93       	push	r29
     bfc:	cd b7       	in	r28, 0x3d	; 61
     bfe:	de b7       	in	r29, 0x3e	; 62
     c00:	2f 97       	sbiw	r28, 0x0f	; 15
     c02:	cd bf       	out	0x3d, r28	; 61
     c04:	de bf       	out	0x3e, r29	; 62
     c06:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     c08:	8f 85       	ldd	r24, Y+15	; 0x0f
     c0a:	88 23       	and	r24, r24
     c0c:	09 f4       	brne	.+2      	; 0xc10 <ADCPower+0x1c>
     c0e:	ce c0       	rjmp	.+412    	; 0xdac <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     c10:	80 e0       	ldi	r24, 0x00	; 0
     c12:	96 e0       	ldi	r25, 0x06	; 6
     c14:	2e ed       	ldi	r18, 0xDE	; 222
     c16:	fc 01       	movw	r30, r24
     c18:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c1a:	80 e2       	ldi	r24, 0x20	; 32
     c1c:	96 e0       	ldi	r25, 0x06	; 6
     c1e:	2e e0       	ldi	r18, 0x0E	; 14
     c20:	fc 01       	movw	r30, r24
     c22:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     c24:	80 e4       	ldi	r24, 0x40	; 64
     c26:	96 e0       	ldi	r25, 0x06	; 6
     c28:	23 e0       	ldi	r18, 0x03	; 3
     c2a:	fc 01       	movw	r30, r24
     c2c:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     c2e:	80 e8       	ldi	r24, 0x80	; 128
     c30:	96 e0       	ldi	r25, 0x06	; 6
     c32:	20 e1       	ldi	r18, 0x10	; 16
     c34:	fc 01       	movw	r30, r24
     c36:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     c38:	80 ea       	ldi	r24, 0xA0	; 160
     c3a:	96 e0       	ldi	r25, 0x06	; 6
     c3c:	2e e0       	ldi	r18, 0x0E	; 14
     c3e:	fc 01       	movw	r30, r24
     c40:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     c42:	80 e0       	ldi	r24, 0x00	; 0
     c44:	96 e0       	ldi	r25, 0x06	; 6
     c46:	2e e9       	ldi	r18, 0x9E	; 158
     c48:	fc 01       	movw	r30, r24
     c4a:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     c4c:	80 e2       	ldi	r24, 0x20	; 32
     c4e:	96 e0       	ldi	r25, 0x06	; 6
     c50:	28 e0       	ldi	r18, 0x08	; 8
     c52:	fc 01       	movw	r30, r24
     c54:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c56:	80 e4       	ldi	r24, 0x40	; 64
     c58:	96 e0       	ldi	r25, 0x06	; 6
     c5a:	23 e0       	ldi	r18, 0x03	; 3
     c5c:	fc 01       	movw	r30, r24
     c5e:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     c60:	80 e8       	ldi	r24, 0x80	; 128
     c62:	96 e0       	ldi	r25, 0x06	; 6
     c64:	20 e1       	ldi	r18, 0x10	; 16
     c66:	fc 01       	movw	r30, r24
     c68:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c6a:	80 ea       	ldi	r24, 0xA0	; 160
     c6c:	96 e0       	ldi	r25, 0x06	; 6
     c6e:	2e e0       	ldi	r18, 0x0E	; 14
     c70:	fc 01       	movw	r30, r24
     c72:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     c74:	10 92 7e 50 	sts	0x507E, r1
     c78:	80 e0       	ldi	r24, 0x00	; 0
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	a8 ec       	ldi	r26, 0xC8	; 200
     c7e:	b2 e4       	ldi	r27, 0x42	; 66
     c80:	89 83       	std	Y+1, r24	; 0x01
     c82:	9a 83       	std	Y+2, r25	; 0x02
     c84:	ab 83       	std	Y+3, r26	; 0x03
     c86:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     c88:	69 81       	ldd	r22, Y+1	; 0x01
     c8a:	7a 81       	ldd	r23, Y+2	; 0x02
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	20 e0       	ldi	r18, 0x00	; 0
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	4a ef       	ldi	r20, 0xFA	; 250
     c96:	55 e4       	ldi	r21, 0x45	; 69
     c98:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
     c9c:	dc 01       	movw	r26, r24
     c9e:	cb 01       	movw	r24, r22
     ca0:	8d 83       	std	Y+5, r24	; 0x05
     ca2:	9e 83       	std	Y+6, r25	; 0x06
     ca4:	af 83       	std	Y+7, r26	; 0x07
     ca6:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     ca8:	11 e0       	ldi	r17, 0x01	; 1
     caa:	6d 81       	ldd	r22, Y+5	; 0x05
     cac:	7e 81       	ldd	r23, Y+6	; 0x06
     cae:	8f 81       	ldd	r24, Y+7	; 0x07
     cb0:	98 85       	ldd	r25, Y+8	; 0x08
     cb2:	20 e0       	ldi	r18, 0x00	; 0
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	40 e8       	ldi	r20, 0x80	; 128
     cb8:	5f e3       	ldi	r21, 0x3F	; 63
     cba:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
     cbe:	88 23       	and	r24, r24
     cc0:	0c f0       	brlt	.+2      	; 0xcc4 <ADCPower+0xd0>
     cc2:	10 e0       	ldi	r17, 0x00	; 0
     cc4:	11 23       	and	r17, r17
     cc6:	29 f0       	breq	.+10     	; 0xcd2 <ADCPower+0xde>
		__ticks = 1;
     cc8:	81 e0       	ldi	r24, 0x01	; 1
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	89 87       	std	Y+9, r24	; 0x09
     cce:	9a 87       	std	Y+10, r25	; 0x0a
     cd0:	46 c0       	rjmp	.+140    	; 0xd5e <ADCPower+0x16a>
	else if (__tmp > 65535)
     cd2:	11 e0       	ldi	r17, 0x01	; 1
     cd4:	6d 81       	ldd	r22, Y+5	; 0x05
     cd6:	7e 81       	ldd	r23, Y+6	; 0x06
     cd8:	8f 81       	ldd	r24, Y+7	; 0x07
     cda:	98 85       	ldd	r25, Y+8	; 0x08
     cdc:	20 e0       	ldi	r18, 0x00	; 0
     cde:	3f ef       	ldi	r19, 0xFF	; 255
     ce0:	4f e7       	ldi	r20, 0x7F	; 127
     ce2:	57 e4       	ldi	r21, 0x47	; 71
     ce4:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
     ce8:	18 16       	cp	r1, r24
     cea:	0c f0       	brlt	.+2      	; 0xcee <ADCPower+0xfa>
     cec:	10 e0       	ldi	r17, 0x00	; 0
     cee:	11 23       	and	r17, r17
     cf0:	61 f1       	breq	.+88     	; 0xd4a <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     cf2:	69 81       	ldd	r22, Y+1	; 0x01
     cf4:	7a 81       	ldd	r23, Y+2	; 0x02
     cf6:	8b 81       	ldd	r24, Y+3	; 0x03
     cf8:	9c 81       	ldd	r25, Y+4	; 0x04
     cfa:	20 e0       	ldi	r18, 0x00	; 0
     cfc:	30 e0       	ldi	r19, 0x00	; 0
     cfe:	40 e2       	ldi	r20, 0x20	; 32
     d00:	51 e4       	ldi	r21, 0x41	; 65
     d02:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
     d06:	dc 01       	movw	r26, r24
     d08:	cb 01       	movw	r24, r22
     d0a:	bc 01       	movw	r22, r24
     d0c:	cd 01       	movw	r24, r26
     d0e:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
     d12:	dc 01       	movw	r26, r24
     d14:	cb 01       	movw	r24, r22
     d16:	89 87       	std	Y+9, r24	; 0x09
     d18:	9a 87       	std	Y+10, r25	; 0x0a
     d1a:	12 c0       	rjmp	.+36     	; 0xd40 <ADCPower+0x14c>
     d1c:	80 e2       	ldi	r24, 0x20	; 32
     d1e:	93 e0       	ldi	r25, 0x03	; 3
     d20:	8b 87       	std	Y+11, r24	; 0x0b
     d22:	9c 87       	std	Y+12, r25	; 0x0c
     d24:	8b 85       	ldd	r24, Y+11	; 0x0b
     d26:	9c 85       	ldd	r25, Y+12	; 0x0c
     d28:	8c 01       	movw	r16, r24
     d2a:	c8 01       	movw	r24, r16
     d2c:	01 97       	sbiw	r24, 0x01	; 1
     d2e:	f1 f7       	brne	.-4      	; 0xd2c <ADCPower+0x138>
     d30:	8c 01       	movw	r16, r24
     d32:	0b 87       	std	Y+11, r16	; 0x0b
     d34:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d36:	89 85       	ldd	r24, Y+9	; 0x09
     d38:	9a 85       	ldd	r25, Y+10	; 0x0a
     d3a:	01 97       	sbiw	r24, 0x01	; 1
     d3c:	89 87       	std	Y+9, r24	; 0x09
     d3e:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d40:	89 85       	ldd	r24, Y+9	; 0x09
     d42:	9a 85       	ldd	r25, Y+10	; 0x0a
     d44:	00 97       	sbiw	r24, 0x00	; 0
     d46:	51 f7       	brne	.-44     	; 0xd1c <ADCPower+0x128>
     d48:	17 c0       	rjmp	.+46     	; 0xd78 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d4a:	6d 81       	ldd	r22, Y+5	; 0x05
     d4c:	7e 81       	ldd	r23, Y+6	; 0x06
     d4e:	8f 81       	ldd	r24, Y+7	; 0x07
     d50:	98 85       	ldd	r25, Y+8	; 0x08
     d52:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
     d56:	dc 01       	movw	r26, r24
     d58:	cb 01       	movw	r24, r22
     d5a:	89 87       	std	Y+9, r24	; 0x09
     d5c:	9a 87       	std	Y+10, r25	; 0x0a
     d5e:	89 85       	ldd	r24, Y+9	; 0x09
     d60:	9a 85       	ldd	r25, Y+10	; 0x0a
     d62:	8d 87       	std	Y+13, r24	; 0x0d
     d64:	9e 87       	std	Y+14, r25	; 0x0e
     d66:	8d 85       	ldd	r24, Y+13	; 0x0d
     d68:	9e 85       	ldd	r25, Y+14	; 0x0e
     d6a:	8c 01       	movw	r16, r24
     d6c:	f8 01       	movw	r30, r16
     d6e:	31 97       	sbiw	r30, 0x01	; 1
     d70:	f1 f7       	brne	.-4      	; 0xd6e <ADCPower+0x17a>
     d72:	8f 01       	movw	r16, r30
     d74:	0d 87       	std	Y+13, r16	; 0x0d
     d76:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     d78:	80 e4       	ldi	r24, 0x40	; 64
     d7a:	96 e0       	ldi	r25, 0x06	; 6
     d7c:	20 e4       	ldi	r18, 0x40	; 64
     d7e:	fc 01       	movw	r30, r24
     d80:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     d82:	80 e0       	ldi	r24, 0x00	; 0
     d84:	80 93 7f 50 	sts	0x507F, r24
     d88:	80 93 d2 50 	sts	0x50D2, r24
     d8c:	80 93 d7 23 	sts	0x23D7, r24
     d90:	80 93 77 50 	sts	0x5077, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     d94:	8f ef       	ldi	r24, 0xFF	; 255
     d96:	61 e0       	ldi	r22, 0x01	; 1
     d98:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     d9c:	8f ef       	ldi	r24, 0xFF	; 255
     d9e:	61 e0       	ldi	r22, 0x01	; 1
     da0:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     da4:	8f ef       	ldi	r24, 0xFF	; 255
     da6:	0e 94 4f 08 	call	0x109e	; 0x109e <set_filter>
     daa:	42 c0       	rjmp	.+132    	; 0xe30 <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	96 e0       	ldi	r25, 0x06	; 6
     db0:	2e ed       	ldi	r18, 0xDE	; 222
     db2:	fc 01       	movw	r30, r24
     db4:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     db6:	80 e2       	ldi	r24, 0x20	; 32
     db8:	96 e0       	ldi	r25, 0x06	; 6
     dba:	2e e0       	ldi	r18, 0x0E	; 14
     dbc:	fc 01       	movw	r30, r24
     dbe:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     dc0:	80 e4       	ldi	r24, 0x40	; 64
     dc2:	96 e0       	ldi	r25, 0x06	; 6
     dc4:	23 e0       	ldi	r18, 0x03	; 3
     dc6:	fc 01       	movw	r30, r24
     dc8:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     dca:	80 e8       	ldi	r24, 0x80	; 128
     dcc:	96 e0       	ldi	r25, 0x06	; 6
     dce:	20 e1       	ldi	r18, 0x10	; 16
     dd0:	fc 01       	movw	r30, r24
     dd2:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     dd4:	80 ea       	ldi	r24, 0xA0	; 160
     dd6:	96 e0       	ldi	r25, 0x06	; 6
     dd8:	2e e0       	ldi	r18, 0x0E	; 14
     dda:	fc 01       	movw	r30, r24
     ddc:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     dde:	80 e0       	ldi	r24, 0x00	; 0
     de0:	96 e0       	ldi	r25, 0x06	; 6
     de2:	2e ed       	ldi	r18, 0xDE	; 222
     de4:	fc 01       	movw	r30, r24
     de6:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     de8:	80 e2       	ldi	r24, 0x20	; 32
     dea:	96 e0       	ldi	r25, 0x06	; 6
     dec:	2e e0       	ldi	r18, 0x0E	; 14
     dee:	fc 01       	movw	r30, r24
     df0:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     df2:	80 e4       	ldi	r24, 0x40	; 64
     df4:	96 e0       	ldi	r25, 0x06	; 6
     df6:	23 e0       	ldi	r18, 0x03	; 3
     df8:	fc 01       	movw	r30, r24
     dfa:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     dfc:	80 e8       	ldi	r24, 0x80	; 128
     dfe:	96 e0       	ldi	r25, 0x06	; 6
     e00:	20 e1       	ldi	r18, 0x10	; 16
     e02:	fc 01       	movw	r30, r24
     e04:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     e06:	80 ea       	ldi	r24, 0xA0	; 160
     e08:	96 e0       	ldi	r25, 0x06	; 6
     e0a:	2e e0       	ldi	r18, 0x0E	; 14
     e0c:	fc 01       	movw	r30, r24
     e0e:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     e10:	80 e4       	ldi	r24, 0x40	; 64
     e12:	96 e0       	ldi	r25, 0x06	; 6
     e14:	20 e4       	ldi	r18, 0x40	; 64
     e16:	fc 01       	movw	r30, r24
     e18:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     e1a:	80 e0       	ldi	r24, 0x00	; 0
     e1c:	80 93 7f 50 	sts	0x507F, r24
     e20:	80 93 d2 50 	sts	0x50D2, r24
     e24:	80 93 d7 23 	sts	0x23D7, r24
     e28:	80 93 77 50 	sts	0x5077, r24
		channelStatus = 0x00;
     e2c:	10 92 7e 50 	sts	0x507E, r1
		
	}
}
     e30:	2f 96       	adiw	r28, 0x0f	; 15
     e32:	cd bf       	out	0x3d, r28	; 61
     e34:	de bf       	out	0x3e, r29	; 62
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	08 95       	ret

00000e40 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     e40:	0f 93       	push	r16
     e42:	1f 93       	push	r17
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	cd b7       	in	r28, 0x3d	; 61
     e4a:	de b7       	in	r29, 0x3e	; 62
     e4c:	6a 97       	sbiw	r28, 0x1a	; 26
     e4e:	cd bf       	out	0x3d, r28	; 61
     e50:	de bf       	out	0x3e, r29	; 62
     e52:	89 8f       	std	Y+25, r24	; 0x19
     e54:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     e56:	89 8d       	ldd	r24, Y+25	; 0x19
     e58:	28 2f       	mov	r18, r24
     e5a:	30 e0       	ldi	r19, 0x00	; 0
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	02 c0       	rjmp	.+4      	; 0xe66 <set_ampGain+0x26>
     e62:	88 0f       	add	r24, r24
     e64:	99 1f       	adc	r25, r25
     e66:	2a 95       	dec	r18
     e68:	e2 f7       	brpl	.-8      	; 0xe62 <set_ampGain+0x22>
     e6a:	61 e0       	ldi	r22, 0x01	; 1
     e6c:	0e 94 44 36 	call	0x6c88	; 0x6c88 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     e70:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e72:	88 2f       	mov	r24, r24
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	81 70       	andi	r24, 0x01	; 1
     e78:	90 70       	andi	r25, 0x00	; 0
     e7a:	88 23       	and	r24, r24
     e7c:	31 f0       	breq	.+12     	; 0xe8a <set_ampGain+0x4a>
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	96 e0       	ldi	r25, 0x06	; 6
     e82:	20 e4       	ldi	r18, 0x40	; 64
     e84:	fc 01       	movw	r30, r24
     e86:	25 83       	std	Z+5, r18	; 0x05
     e88:	05 c0       	rjmp	.+10     	; 0xe94 <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	96 e0       	ldi	r25, 0x06	; 6
     e8e:	20 e4       	ldi	r18, 0x40	; 64
     e90:	fc 01       	movw	r30, r24
     e92:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     e94:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e96:	88 2f       	mov	r24, r24
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	82 70       	andi	r24, 0x02	; 2
     e9c:	90 70       	andi	r25, 0x00	; 0
     e9e:	00 97       	sbiw	r24, 0x00	; 0
     ea0:	31 f0       	breq	.+12     	; 0xeae <set_ampGain+0x6e>
     ea2:	80 e2       	ldi	r24, 0x20	; 32
     ea4:	96 e0       	ldi	r25, 0x06	; 6
     ea6:	22 e0       	ldi	r18, 0x02	; 2
     ea8:	fc 01       	movw	r30, r24
     eaa:	25 83       	std	Z+5, r18	; 0x05
     eac:	05 c0       	rjmp	.+10     	; 0xeb8 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     eae:	80 e2       	ldi	r24, 0x20	; 32
     eb0:	96 e0       	ldi	r25, 0x06	; 6
     eb2:	22 e0       	ldi	r18, 0x02	; 2
     eb4:	fc 01       	movw	r30, r24
     eb6:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     eb8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     eba:	88 2f       	mov	r24, r24
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	84 70       	andi	r24, 0x04	; 4
     ec0:	90 70       	andi	r25, 0x00	; 0
     ec2:	00 97       	sbiw	r24, 0x00	; 0
     ec4:	31 f0       	breq	.+12     	; 0xed2 <set_ampGain+0x92>
     ec6:	80 e2       	ldi	r24, 0x20	; 32
     ec8:	96 e0       	ldi	r25, 0x06	; 6
     eca:	24 e0       	ldi	r18, 0x04	; 4
     ecc:	fc 01       	movw	r30, r24
     ece:	25 83       	std	Z+5, r18	; 0x05
     ed0:	05 c0       	rjmp	.+10     	; 0xedc <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     ed2:	80 e2       	ldi	r24, 0x20	; 32
     ed4:	96 e0       	ldi	r25, 0x06	; 6
     ed6:	24 e0       	ldi	r18, 0x04	; 4
     ed8:	fc 01       	movw	r30, r24
     eda:	26 83       	std	Z+6, r18	; 0x06
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	a0 e8       	ldi	r26, 0x80	; 128
     ee2:	bf e3       	ldi	r27, 0x3F	; 63
     ee4:	89 83       	std	Y+1, r24	; 0x01
     ee6:	9a 83       	std	Y+2, r25	; 0x02
     ee8:	ab 83       	std	Y+3, r26	; 0x03
     eea:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     eec:	69 81       	ldd	r22, Y+1	; 0x01
     eee:	7a 81       	ldd	r23, Y+2	; 0x02
     ef0:	8b 81       	ldd	r24, Y+3	; 0x03
     ef2:	9c 81       	ldd	r25, Y+4	; 0x04
     ef4:	2b ea       	ldi	r18, 0xAB	; 171
     ef6:	3a ea       	ldi	r19, 0xAA	; 170
     ef8:	4a e2       	ldi	r20, 0x2A	; 42
     efa:	51 e4       	ldi	r21, 0x41	; 65
     efc:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
     f00:	dc 01       	movw	r26, r24
     f02:	cb 01       	movw	r24, r22
     f04:	8d 83       	std	Y+5, r24	; 0x05
     f06:	9e 83       	std	Y+6, r25	; 0x06
     f08:	af 83       	std	Y+7, r26	; 0x07
     f0a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     f0c:	11 e0       	ldi	r17, 0x01	; 1
     f0e:	6d 81       	ldd	r22, Y+5	; 0x05
     f10:	7e 81       	ldd	r23, Y+6	; 0x06
     f12:	8f 81       	ldd	r24, Y+7	; 0x07
     f14:	98 85       	ldd	r25, Y+8	; 0x08
     f16:	20 e0       	ldi	r18, 0x00	; 0
     f18:	30 e0       	ldi	r19, 0x00	; 0
     f1a:	40 e8       	ldi	r20, 0x80	; 128
     f1c:	5f e3       	ldi	r21, 0x3F	; 63
     f1e:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
     f22:	88 23       	and	r24, r24
     f24:	0c f0       	brlt	.+2      	; 0xf28 <set_ampGain+0xe8>
     f26:	10 e0       	ldi	r17, 0x00	; 0
     f28:	11 23       	and	r17, r17
     f2a:	19 f0       	breq	.+6      	; 0xf32 <set_ampGain+0xf2>
		__ticks = 1;
     f2c:	81 e0       	ldi	r24, 0x01	; 1
     f2e:	89 87       	std	Y+9, r24	; 0x09
     f30:	a3 c0       	rjmp	.+326    	; 0x1078 <set_ampGain+0x238>
	else if (__tmp > 255)
     f32:	11 e0       	ldi	r17, 0x01	; 1
     f34:	6d 81       	ldd	r22, Y+5	; 0x05
     f36:	7e 81       	ldd	r23, Y+6	; 0x06
     f38:	8f 81       	ldd	r24, Y+7	; 0x07
     f3a:	98 85       	ldd	r25, Y+8	; 0x08
     f3c:	20 e0       	ldi	r18, 0x00	; 0
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	4f e7       	ldi	r20, 0x7F	; 127
     f42:	53 e4       	ldi	r21, 0x43	; 67
     f44:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
     f48:	18 16       	cp	r1, r24
     f4a:	0c f0       	brlt	.+2      	; 0xf4e <set_ampGain+0x10e>
     f4c:	10 e0       	ldi	r17, 0x00	; 0
     f4e:	11 23       	and	r17, r17
     f50:	09 f4       	brne	.+2      	; 0xf54 <set_ampGain+0x114>
     f52:	89 c0       	rjmp	.+274    	; 0x1066 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     f54:	69 81       	ldd	r22, Y+1	; 0x01
     f56:	7a 81       	ldd	r23, Y+2	; 0x02
     f58:	8b 81       	ldd	r24, Y+3	; 0x03
     f5a:	9c 81       	ldd	r25, Y+4	; 0x04
     f5c:	20 e0       	ldi	r18, 0x00	; 0
     f5e:	30 e0       	ldi	r19, 0x00	; 0
     f60:	4a e7       	ldi	r20, 0x7A	; 122
     f62:	54 e4       	ldi	r21, 0x44	; 68
     f64:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
     f68:	dc 01       	movw	r26, r24
     f6a:	cb 01       	movw	r24, r22
     f6c:	8a 87       	std	Y+10, r24	; 0x0a
     f6e:	9b 87       	std	Y+11, r25	; 0x0b
     f70:	ac 87       	std	Y+12, r26	; 0x0c
     f72:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     f74:	6a 85       	ldd	r22, Y+10	; 0x0a
     f76:	7b 85       	ldd	r23, Y+11	; 0x0b
     f78:	8c 85       	ldd	r24, Y+12	; 0x0c
     f7a:	9d 85       	ldd	r25, Y+13	; 0x0d
     f7c:	20 e0       	ldi	r18, 0x00	; 0
     f7e:	30 e0       	ldi	r19, 0x00	; 0
     f80:	4a ef       	ldi	r20, 0xFA	; 250
     f82:	55 e4       	ldi	r21, 0x45	; 69
     f84:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
     f88:	dc 01       	movw	r26, r24
     f8a:	cb 01       	movw	r24, r22
     f8c:	8e 87       	std	Y+14, r24	; 0x0e
     f8e:	9f 87       	std	Y+15, r25	; 0x0f
     f90:	a8 8b       	std	Y+16, r26	; 0x10
     f92:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     f94:	11 e0       	ldi	r17, 0x01	; 1
     f96:	6e 85       	ldd	r22, Y+14	; 0x0e
     f98:	7f 85       	ldd	r23, Y+15	; 0x0f
     f9a:	88 89       	ldd	r24, Y+16	; 0x10
     f9c:	99 89       	ldd	r25, Y+17	; 0x11
     f9e:	20 e0       	ldi	r18, 0x00	; 0
     fa0:	30 e0       	ldi	r19, 0x00	; 0
     fa2:	40 e8       	ldi	r20, 0x80	; 128
     fa4:	5f e3       	ldi	r21, 0x3F	; 63
     fa6:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
     faa:	88 23       	and	r24, r24
     fac:	0c f0       	brlt	.+2      	; 0xfb0 <set_ampGain+0x170>
     fae:	10 e0       	ldi	r17, 0x00	; 0
     fb0:	11 23       	and	r17, r17
     fb2:	29 f0       	breq	.+10     	; 0xfbe <set_ampGain+0x17e>
		__ticks = 1;
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	8a 8b       	std	Y+18, r24	; 0x12
     fba:	9b 8b       	std	Y+19, r25	; 0x13
     fbc:	46 c0       	rjmp	.+140    	; 0x104a <set_ampGain+0x20a>
	else if (__tmp > 65535)
     fbe:	11 e0       	ldi	r17, 0x01	; 1
     fc0:	6e 85       	ldd	r22, Y+14	; 0x0e
     fc2:	7f 85       	ldd	r23, Y+15	; 0x0f
     fc4:	88 89       	ldd	r24, Y+16	; 0x10
     fc6:	99 89       	ldd	r25, Y+17	; 0x11
     fc8:	20 e0       	ldi	r18, 0x00	; 0
     fca:	3f ef       	ldi	r19, 0xFF	; 255
     fcc:	4f e7       	ldi	r20, 0x7F	; 127
     fce:	57 e4       	ldi	r21, 0x47	; 71
     fd0:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
     fd4:	18 16       	cp	r1, r24
     fd6:	0c f0       	brlt	.+2      	; 0xfda <set_ampGain+0x19a>
     fd8:	10 e0       	ldi	r17, 0x00	; 0
     fda:	11 23       	and	r17, r17
     fdc:	61 f1       	breq	.+88     	; 0x1036 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     fde:	6a 85       	ldd	r22, Y+10	; 0x0a
     fe0:	7b 85       	ldd	r23, Y+11	; 0x0b
     fe2:	8c 85       	ldd	r24, Y+12	; 0x0c
     fe4:	9d 85       	ldd	r25, Y+13	; 0x0d
     fe6:	20 e0       	ldi	r18, 0x00	; 0
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	40 e2       	ldi	r20, 0x20	; 32
     fec:	51 e4       	ldi	r21, 0x41	; 65
     fee:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
     ff2:	dc 01       	movw	r26, r24
     ff4:	cb 01       	movw	r24, r22
     ff6:	bc 01       	movw	r22, r24
     ff8:	cd 01       	movw	r24, r26
     ffa:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
     ffe:	dc 01       	movw	r26, r24
    1000:	cb 01       	movw	r24, r22
    1002:	8a 8b       	std	Y+18, r24	; 0x12
    1004:	9b 8b       	std	Y+19, r25	; 0x13
    1006:	12 c0       	rjmp	.+36     	; 0x102c <set_ampGain+0x1ec>
    1008:	80 e2       	ldi	r24, 0x20	; 32
    100a:	93 e0       	ldi	r25, 0x03	; 3
    100c:	8c 8b       	std	Y+20, r24	; 0x14
    100e:	9d 8b       	std	Y+21, r25	; 0x15
    1010:	8c 89       	ldd	r24, Y+20	; 0x14
    1012:	9d 89       	ldd	r25, Y+21	; 0x15
    1014:	8c 01       	movw	r16, r24
    1016:	c8 01       	movw	r24, r16
    1018:	01 97       	sbiw	r24, 0x01	; 1
    101a:	f1 f7       	brne	.-4      	; 0x1018 <set_ampGain+0x1d8>
    101c:	8c 01       	movw	r16, r24
    101e:	0c 8b       	std	Y+20, r16	; 0x14
    1020:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1022:	8a 89       	ldd	r24, Y+18	; 0x12
    1024:	9b 89       	ldd	r25, Y+19	; 0x13
    1026:	01 97       	sbiw	r24, 0x01	; 1
    1028:	8a 8b       	std	Y+18, r24	; 0x12
    102a:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    102c:	8a 89       	ldd	r24, Y+18	; 0x12
    102e:	9b 89       	ldd	r25, Y+19	; 0x13
    1030:	00 97       	sbiw	r24, 0x00	; 0
    1032:	51 f7       	brne	.-44     	; 0x1008 <set_ampGain+0x1c8>
    1034:	28 c0       	rjmp	.+80     	; 0x1086 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1036:	6e 85       	ldd	r22, Y+14	; 0x0e
    1038:	7f 85       	ldd	r23, Y+15	; 0x0f
    103a:	88 89       	ldd	r24, Y+16	; 0x10
    103c:	99 89       	ldd	r25, Y+17	; 0x11
    103e:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    1042:	dc 01       	movw	r26, r24
    1044:	cb 01       	movw	r24, r22
    1046:	8a 8b       	std	Y+18, r24	; 0x12
    1048:	9b 8b       	std	Y+19, r25	; 0x13
    104a:	8a 89       	ldd	r24, Y+18	; 0x12
    104c:	9b 89       	ldd	r25, Y+19	; 0x13
    104e:	8e 8b       	std	Y+22, r24	; 0x16
    1050:	9f 8b       	std	Y+23, r25	; 0x17
    1052:	8e 89       	ldd	r24, Y+22	; 0x16
    1054:	9f 89       	ldd	r25, Y+23	; 0x17
    1056:	8c 01       	movw	r16, r24
    1058:	f8 01       	movw	r30, r16
    105a:	31 97       	sbiw	r30, 0x01	; 1
    105c:	f1 f7       	brne	.-4      	; 0x105a <set_ampGain+0x21a>
    105e:	8f 01       	movw	r16, r30
    1060:	0e 8b       	std	Y+22, r16	; 0x16
    1062:	1f 8b       	std	Y+23, r17	; 0x17
    1064:	10 c0       	rjmp	.+32     	; 0x1086 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1066:	6d 81       	ldd	r22, Y+5	; 0x05
    1068:	7e 81       	ldd	r23, Y+6	; 0x06
    106a:	8f 81       	ldd	r24, Y+7	; 0x07
    106c:	98 85       	ldd	r25, Y+8	; 0x08
    106e:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    1072:	dc 01       	movw	r26, r24
    1074:	cb 01       	movw	r24, r22
    1076:	89 87       	std	Y+9, r24	; 0x09
    1078:	89 85       	ldd	r24, Y+9	; 0x09
    107a:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    107c:	88 8d       	ldd	r24, Y+24	; 0x18
    107e:	18 2f       	mov	r17, r24
    1080:	1a 95       	dec	r17
    1082:	f1 f7       	brne	.-4      	; 0x1080 <set_ampGain+0x240>
    1084:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    1086:	8f ef       	ldi	r24, 0xFF	; 255
    1088:	61 e0       	ldi	r22, 0x01	; 1
    108a:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    108e:	6a 96       	adiw	r28, 0x1a	; 26
    1090:	cd bf       	out	0x3d, r28	; 61
    1092:	de bf       	out	0x3e, r29	; 62
    1094:	df 91       	pop	r29
    1096:	cf 91       	pop	r28
    1098:	1f 91       	pop	r17
    109a:	0f 91       	pop	r16
    109c:	08 95       	ret

0000109e <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	00 d0       	rcall	.+0      	; 0x10a4 <set_filter+0x6>
    10a4:	cd b7       	in	r28, 0x3d	; 61
    10a6:	de b7       	in	r29, 0x3e	; 62
    10a8:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    10aa:	8b 81       	ldd	r24, Y+3	; 0x03
    10ac:	83 70       	andi	r24, 0x03	; 3
    10ae:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    10b0:	8b 81       	ldd	r24, Y+3	; 0x03
    10b2:	8c 70       	andi	r24, 0x0C	; 12
    10b4:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    10b6:	8b 81       	ldd	r24, Y+3	; 0x03
    10b8:	88 2f       	mov	r24, r24
    10ba:	90 e0       	ldi	r25, 0x00	; 0
    10bc:	85 70       	andi	r24, 0x05	; 5
    10be:	90 70       	andi	r25, 0x00	; 0
    10c0:	00 97       	sbiw	r24, 0x00	; 0
    10c2:	51 f0       	breq	.+20     	; 0x10d8 <set_filter+0x3a>
    10c4:	80 91 7e 50 	lds	r24, 0x507E
    10c8:	98 2f       	mov	r25, r24
    10ca:	90 7f       	andi	r25, 0xF0	; 240
    10cc:	8b 81       	ldd	r24, Y+3	; 0x03
    10ce:	82 95       	swap	r24
    10d0:	8f 70       	andi	r24, 0x0F	; 15
    10d2:	89 2b       	or	r24, r25
    10d4:	80 93 7e 50 	sts	0x507E, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    10d8:	8b 81       	ldd	r24, Y+3	; 0x03
    10da:	88 2f       	mov	r24, r24
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	8a 70       	andi	r24, 0x0A	; 10
    10e0:	90 70       	andi	r25, 0x00	; 0
    10e2:	00 97       	sbiw	r24, 0x00	; 0
    10e4:	49 f0       	breq	.+18     	; 0x10f8 <set_filter+0x5a>
    10e6:	8b 81       	ldd	r24, Y+3	; 0x03
    10e8:	98 2f       	mov	r25, r24
    10ea:	90 7f       	andi	r25, 0xF0	; 240
    10ec:	80 91 7e 50 	lds	r24, 0x507E
    10f0:	8f 70       	andi	r24, 0x0F	; 15
    10f2:	89 2b       	or	r24, r25
    10f4:	80 93 7e 50 	sts	0x507E, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    10f8:	84 e0       	ldi	r24, 0x04	; 4
    10fa:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    10fe:	80 91 7e 50 	lds	r24, 0x507E
    1102:	80 93 66 50 	sts	0x5066, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	88 23       	and	r24, r24
    110a:	19 f0       	breq	.+6      	; 0x1112 <set_filter+0x74>
    110c:	81 e0       	ldi	r24, 0x01	; 1
    110e:	0e 94 81 39 	call	0x7302	; 0x7302 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    1112:	8a 81       	ldd	r24, Y+2	; 0x02
    1114:	88 23       	and	r24, r24
    1116:	19 f0       	breq	.+6      	; 0x111e <set_filter+0x80>
    1118:	81 e0       	ldi	r24, 0x01	; 1
    111a:	0e 94 99 39 	call	0x7332	; 0x7332 <upperMuxCS>

	SPICS(TRUE);
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    1124:	80 ec       	ldi	r24, 0xC0	; 192
    1126:	98 e0       	ldi	r25, 0x08	; 8
    1128:	2f ef       	ldi	r18, 0xFF	; 255
    112a:	fc 01       	movw	r30, r24
    112c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    112e:	00 00       	nop
    1130:	80 ec       	ldi	r24, 0xC0	; 192
    1132:	98 e0       	ldi	r25, 0x08	; 8
    1134:	fc 01       	movw	r30, r24
    1136:	82 81       	ldd	r24, Z+2	; 0x02
    1138:	88 23       	and	r24, r24
    113a:	d4 f7       	brge	.-12     	; 0x1130 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    113c:	80 ec       	ldi	r24, 0xC0	; 192
    113e:	98 e0       	ldi	r25, 0x08	; 8
    1140:	fc 01       	movw	r30, r24
    1142:	83 81       	ldd	r24, Z+3	; 0x03
    1144:	80 93 72 50 	sts	0x5072, r24

	nop();
    1148:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    114a:	80 ec       	ldi	r24, 0xC0	; 192
    114c:	98 e0       	ldi	r25, 0x08	; 8
    114e:	20 91 66 50 	lds	r18, 0x5066
    1152:	fc 01       	movw	r30, r24
    1154:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1156:	00 00       	nop
    1158:	80 ec       	ldi	r24, 0xC0	; 192
    115a:	98 e0       	ldi	r25, 0x08	; 8
    115c:	fc 01       	movw	r30, r24
    115e:	82 81       	ldd	r24, Z+2	; 0x02
    1160:	88 23       	and	r24, r24
    1162:	d4 f7       	brge	.-12     	; 0x1158 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    1164:	80 ec       	ldi	r24, 0xC0	; 192
    1166:	98 e0       	ldi	r25, 0x08	; 8
    1168:	fc 01       	movw	r30, r24
    116a:	83 81       	ldd	r24, Z+3	; 0x03
    116c:	80 93 72 50 	sts	0x5072, r24
	SPICS(FALSE);
    1170:	80 e0       	ldi	r24, 0x00	; 0
    1172:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    1176:	89 81       	ldd	r24, Y+1	; 0x01
    1178:	88 23       	and	r24, r24
    117a:	19 f0       	breq	.+6      	; 0x1182 <set_filter+0xe4>
    117c:	80 e0       	ldi	r24, 0x00	; 0
    117e:	0e 94 81 39 	call	0x7302	; 0x7302 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    1182:	8a 81       	ldd	r24, Y+2	; 0x02
    1184:	88 23       	and	r24, r24
    1186:	19 f0       	breq	.+6      	; 0x118e <set_filter+0xf0>
    1188:	80 e0       	ldi	r24, 0x00	; 0
    118a:	0e 94 99 39 	call	0x7332	; 0x7332 <upperMuxCS>
	SPIDisable();
    118e:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
}
    1192:	23 96       	adiw	r28, 0x03	; 3
    1194:	cd bf       	out	0x3d, r28	; 61
    1196:	de bf       	out	0x3e, r29	; 62
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	08 95       	ret

0000119e <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    119e:	cf 93       	push	r28
    11a0:	df 93       	push	r29
    11a2:	0f 92       	push	r0
    11a4:	cd b7       	in	r28, 0x3d	; 61
    11a6:	de b7       	in	r29, 0x3e	; 62
    11a8:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    11aa:	89 81       	ldd	r24, Y+1	; 0x01
    11ac:	88 23       	and	r24, r24
    11ae:	59 f0       	breq	.+22     	; 0x11c6 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    11b0:	80 e0       	ldi	r24, 0x00	; 0
    11b2:	96 e0       	ldi	r25, 0x06	; 6
    11b4:	20 e2       	ldi	r18, 0x20	; 32
    11b6:	fc 01       	movw	r30, r24
    11b8:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    11ba:	80 e0       	ldi	r24, 0x00	; 0
    11bc:	96 e0       	ldi	r25, 0x06	; 6
    11be:	20 e2       	ldi	r18, 0x20	; 32
    11c0:	fc 01       	movw	r30, r24
    11c2:	25 83       	std	Z+5, r18	; 0x05
    11c4:	0a c0       	rjmp	.+20     	; 0x11da <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    11c6:	80 e0       	ldi	r24, 0x00	; 0
    11c8:	96 e0       	ldi	r25, 0x06	; 6
    11ca:	20 e2       	ldi	r18, 0x20	; 32
    11cc:	fc 01       	movw	r30, r24
    11ce:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    11d0:	80 e0       	ldi	r24, 0x00	; 0
    11d2:	96 e0       	ldi	r25, 0x06	; 6
    11d4:	20 e2       	ldi	r18, 0x20	; 32
    11d6:	fc 01       	movw	r30, r24
    11d8:	22 83       	std	Z+2, r18	; 0x02
	}
}
    11da:	0f 90       	pop	r0
    11dc:	df 91       	pop	r29
    11de:	cf 91       	pop	r28
    11e0:	08 95       	ret

000011e2 <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {
    11e2:	2f 92       	push	r2
    11e4:	3f 92       	push	r3
    11e6:	4f 92       	push	r4
    11e8:	5f 92       	push	r5
    11ea:	6f 92       	push	r6
    11ec:	7f 92       	push	r7
    11ee:	8f 92       	push	r8
    11f0:	9f 92       	push	r9
    11f2:	af 92       	push	r10
    11f4:	bf 92       	push	r11
    11f6:	cf 92       	push	r12
    11f8:	df 92       	push	r13
    11fa:	ef 92       	push	r14
    11fc:	ff 92       	push	r15
    11fe:	0f 93       	push	r16
    1200:	1f 93       	push	r17
    1202:	cf 93       	push	r28
    1204:	df 93       	push	r29
    1206:	cd b7       	in	r28, 0x3d	; 61
    1208:	de b7       	in	r29, 0x3e	; 62
    120a:	ec 97       	sbiw	r28, 0x3c	; 60
    120c:	cd bf       	out	0x3d, r28	; 61
    120e:	de bf       	out	0x3e, r29	; 62
    1210:	8b a3       	lds	r24, 0x5b
    1212:	6c a3       	lds	r22, 0x5c
    1214:	4d a3       	lds	r20, 0x5d
    1216:	5e a3       	lds	r21, 0x5e
    1218:	2f a3       	lds	r18, 0x5f
    121a:	38 a7       	lds	r19, 0x78
    121c:	09 a7       	lds	r16, 0x79
    121e:	1a a7       	lds	r17, 0x7a
    1220:	eb a6       	lds	r30, 0xbb
    1222:	cc a6       	lds	r28, 0xbc

	int64_t sum = 0;
    1224:	19 82       	std	Y+1, r1	; 0x01
    1226:	1a 82       	std	Y+2, r1	; 0x02
    1228:	1b 82       	std	Y+3, r1	; 0x03
    122a:	1c 82       	std	Y+4, r1	; 0x04
    122c:	1d 82       	std	Y+5, r1	; 0x05
    122e:	1e 82       	std	Y+6, r1	; 0x06
    1230:	1f 82       	std	Y+7, r1	; 0x07
    1232:	18 86       	std	Y+8, r1	; 0x08
	int64_t average;
	int64_t min = ADC_MAX;
    1234:	8f ef       	ldi	r24, 0xFF	; 255
    1236:	89 87       	std	Y+9, r24	; 0x09
    1238:	8f ef       	ldi	r24, 0xFF	; 255
    123a:	8a 87       	std	Y+10, r24	; 0x0a
    123c:	8f e7       	ldi	r24, 0x7F	; 127
    123e:	8b 87       	std	Y+11, r24	; 0x0b
    1240:	1c 86       	std	Y+12, r1	; 0x0c
    1242:	1d 86       	std	Y+13, r1	; 0x0d
    1244:	1e 86       	std	Y+14, r1	; 0x0e
    1246:	1f 86       	std	Y+15, r1	; 0x0f
    1248:	18 8a       	std	Y+16, r1	; 0x10
	int64_t max = -ADC_MAX;
    124a:	81 e0       	ldi	r24, 0x01	; 1
    124c:	89 8b       	std	Y+17, r24	; 0x11
    124e:	1a 8a       	std	Y+18, r1	; 0x12
    1250:	80 e8       	ldi	r24, 0x80	; 128
    1252:	8b 8b       	std	Y+19, r24	; 0x13
    1254:	8f ef       	ldi	r24, 0xFF	; 255
    1256:	8c 8b       	std	Y+20, r24	; 0x14
    1258:	8f ef       	ldi	r24, 0xFF	; 255
    125a:	8d 8b       	std	Y+21, r24	; 0x15
    125c:	8f ef       	ldi	r24, 0xFF	; 255
    125e:	8e 8b       	std	Y+22, r24	; 0x16
    1260:	8f ef       	ldi	r24, 0xFF	; 255
    1262:	8f 8b       	std	Y+23, r24	; 0x17
    1264:	8f ef       	ldi	r24, 0xFF	; 255
    1266:	88 8f       	std	Y+24, r24	; 0x18
	uint16_t period;
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1268:	81 e0       	ldi	r24, 0x01	; 1
    126a:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    126e:	8b a1       	lds	r24, 0x4b
    1270:	6b a5       	lds	r22, 0x6b
    1272:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_filter(filterConfig);
    1276:	8c a1       	lds	r24, 0x4c
    1278:	0e 94 4f 08 	call	0x109e	; 0x109e <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    127c:	8b a1       	lds	r24, 0x4b
    127e:	85 30       	cpi	r24, 0x05	; 5
    1280:	31 f0       	breq	.+12     	; 0x128e <CO_collectADC+0xac>
    1282:	8b a1       	lds	r24, 0x4b
    1284:	86 30       	cpi	r24, 0x06	; 6
    1286:	19 f0       	breq	.+6      	; 0x128e <CO_collectADC+0xac>
    1288:	8b a1       	lds	r24, 0x4b
    128a:	87 30       	cpi	r24, 0x07	; 7
    128c:	19 f4       	brne	.+6      	; 0x1294 <CO_collectADC+0xb2>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    128e:	81 e0       	ldi	r24, 0x01	; 1
    1290:	0e 94 29 11 	call	0x2252	; 0x2252 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
	setADCInput(channel);
    129a:	8b a1       	lds	r24, 0x4b
    129c:	0e 94 55 1c 	call	0x38aa	; 0x38aa <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    12a0:	84 e0       	ldi	r24, 0x04	; 4
    12a2:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    12a6:	80 ec       	ldi	r24, 0xC0	; 192
    12a8:	98 e0       	ldi	r25, 0x08	; 8
    12aa:	24 e5       	ldi	r18, 0x54	; 84
    12ac:	fc 01       	movw	r30, r24
    12ae:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    12b0:	80 ea       	ldi	r24, 0xA0	; 160
    12b2:	96 e0       	ldi	r25, 0x06	; 6
    12b4:	21 e0       	ldi	r18, 0x01	; 1
    12b6:	fc 01       	movw	r30, r24
    12b8:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    12ba:	80 ea       	ldi	r24, 0xA0	; 160
    12bc:	96 e0       	ldi	r25, 0x06	; 6
    12be:	22 e0       	ldi	r18, 0x02	; 2
    12c0:	fc 01       	movw	r30, r24
    12c2:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    12c4:	80 ea       	ldi	r24, 0xA0	; 160
    12c6:	96 e0       	ldi	r25, 0x06	; 6
    12c8:	21 e0       	ldi	r18, 0x01	; 1
    12ca:	fc 01       	movw	r30, r24
    12cc:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    12ce:	80 ea       	ldi	r24, 0xA0	; 160
    12d0:	96 e0       	ldi	r25, 0x06	; 6
    12d2:	21 e0       	ldi	r18, 0x01	; 1
    12d4:	fc 01       	movw	r30, r24
    12d6:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    12d8:	80 e8       	ldi	r24, 0x80	; 128
    12da:	96 e0       	ldi	r25, 0x06	; 6
    12dc:	20 e2       	ldi	r18, 0x20	; 32
    12de:	fc 01       	movw	r30, r24
    12e0:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    12e2:	80 e4       	ldi	r24, 0x40	; 64
    12e4:	9a e0       	ldi	r25, 0x0A	; 10
    12e6:	23 e2       	ldi	r18, 0x23	; 35
    12e8:	fc 01       	movw	r30, r24
    12ea:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    12ec:	8c a5       	lds	r24, 0x6c
    12ee:	88 2f       	mov	r24, r24
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	25 e1       	ldi	r18, 0x15	; 21
    12f4:	30 e0       	ldi	r19, 0x00	; 0
    12f6:	28 1b       	sub	r18, r24
    12f8:	39 0b       	sbc	r19, r25
    12fa:	81 e0       	ldi	r24, 0x01	; 1
    12fc:	90 e0       	ldi	r25, 0x00	; 0
    12fe:	02 c0       	rjmp	.+4      	; 0x1304 <CO_collectADC+0x122>
    1300:	88 0f       	add	r24, r24
    1302:	99 1f       	adc	r25, r25
    1304:	2a 95       	dec	r18
    1306:	e2 f7       	brpl	.-8      	; 0x1300 <CO_collectADC+0x11e>
    1308:	01 97       	sbiw	r24, 0x01	; 1
    130a:	89 8f       	std	Y+25, r24	; 0x19
    130c:	9a 8f       	std	Y+26, r25	; 0x1a
	TCE1.PER = period;
    130e:	80 e4       	ldi	r24, 0x40	; 64
    1310:	9a e0       	ldi	r25, 0x0A	; 10
    1312:	29 8d       	ldd	r18, Y+25	; 0x19
    1314:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1316:	fc 01       	movw	r30, r24
    1318:	26 a3       	lds	r18, 0x56
    131a:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    131c:	80 e4       	ldi	r24, 0x40	; 64
    131e:	9a e0       	ldi	r25, 0x0A	; 10
    1320:	29 8d       	ldd	r18, Y+25	; 0x19
    1322:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1324:	36 95       	lsr	r19
    1326:	27 95       	ror	r18
    1328:	fc 01       	movw	r30, r24
    132a:	22 af       	sts	0x72, r18
    132c:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    132e:	80 e4       	ldi	r24, 0x40	; 64
    1330:	9a e0       	ldi	r25, 0x0A	; 10
    1332:	20 e4       	ldi	r18, 0x40	; 64
    1334:	3a e0       	ldi	r19, 0x0A	; 10
    1336:	f9 01       	movw	r30, r18
    1338:	20 81       	ld	r18, Z
    133a:	20 7f       	andi	r18, 0xF0	; 240
    133c:	21 60       	ori	r18, 0x01	; 1
    133e:	fc 01       	movw	r30, r24
    1340:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1342:	80 ea       	ldi	r24, 0xA0	; 160
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	20 ea       	ldi	r18, 0xA0	; 160
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	f9 01       	movw	r30, r18
    134c:	22 81       	ldd	r18, Z+2	; 0x02
    134e:	21 60       	ori	r18, 0x01	; 1
    1350:	fc 01       	movw	r30, r24
    1352:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1354:	78 94       	sei

	sampleCount = 0;
    1356:	10 92 73 50 	sts	0x5073, r1
    135a:	10 92 74 50 	sts	0x5074, r1
	discardCount = 0;
    135e:	10 92 5e 40 	sts	0x405E, r1
	
	// wait for ADC to collect samples
	while(sampleCount < NUM_SAMPLES);
    1362:	00 00       	nop
    1364:	80 91 73 50 	lds	r24, 0x5073
    1368:	90 91 74 50 	lds	r25, 0x5074
    136c:	f4 e0       	ldi	r31, 0x04	; 4
    136e:	80 30       	cpi	r24, 0x00	; 0
    1370:	9f 07       	cpc	r25, r31
    1372:	c0 f3       	brcs	.-16     	; 0x1364 <CO_collectADC+0x182>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1374:	80 e4       	ldi	r24, 0x40	; 64
    1376:	9a e0       	ldi	r25, 0x0A	; 10
    1378:	20 e4       	ldi	r18, 0x40	; 64
    137a:	3a e0       	ldi	r19, 0x0A	; 10
    137c:	f9 01       	movw	r30, r18
    137e:	20 81       	ld	r18, Z
    1380:	20 7f       	andi	r18, 0xF0	; 240
    1382:	fc 01       	movw	r30, r24
    1384:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    1386:	80 ea       	ldi	r24, 0xA0	; 160
    1388:	90 e0       	ldi	r25, 0x00	; 0
    138a:	20 ea       	ldi	r18, 0xA0	; 160
    138c:	30 e0       	ldi	r19, 0x00	; 0
    138e:	f9 01       	movw	r30, r18
    1390:	22 81       	ldd	r18, Z+2	; 0x02
    1392:	2e 7f       	andi	r18, 0xFE	; 254
    1394:	fc 01       	movw	r30, r24
    1396:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1398:	f8 94       	cli

	SPIDisable();	
    139a:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	enableADCMUX(FALSE);
    139e:	80 e0       	ldi	r24, 0x00	; 0
    13a0:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
	ADCPower(FALSE);
    13a4:	80 e0       	ldi	r24, 0x00	; 0
    13a6:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    13aa:	10 92 73 50 	sts	0x5073, r1
    13ae:	10 92 74 50 	sts	0x5074, r1
    13b2:	69 c1       	rjmp	.+722    	; 0x1686 <CO_collectADC+0x4a4>
		sum += data24Bit[sampleCount];
    13b4:	80 91 73 50 	lds	r24, 0x5073
    13b8:	90 91 74 50 	lds	r25, 0x5074
    13bc:	88 0f       	add	r24, r24
    13be:	99 1f       	adc	r25, r25
    13c0:	88 0f       	add	r24, r24
    13c2:	99 1f       	adc	r25, r25
    13c4:	8c 59       	subi	r24, 0x9C	; 156
    13c6:	9f 4b       	sbci	r25, 0xBF	; 191
    13c8:	fc 01       	movw	r30, r24
    13ca:	80 81       	ld	r24, Z
    13cc:	91 81       	ldd	r25, Z+1	; 0x01
    13ce:	a2 81       	ldd	r26, Z+2	; 0x02
    13d0:	b3 81       	ldd	r27, Z+3	; 0x03
    13d2:	8d a7       	lds	r24, 0x7d
    13d4:	9e a7       	lds	r25, 0x7e
    13d6:	af a7       	lds	r26, 0x7f
    13d8:	b8 ab       	sts	0x58, r27
    13da:	bb 0f       	add	r27, r27
    13dc:	88 0b       	sbc	r24, r24
    13de:	98 2f       	mov	r25, r24
    13e0:	dc 01       	movw	r26, r24
    13e2:	89 ab       	sts	0x59, r24
    13e4:	8a ab       	sts	0x5a, r24
    13e6:	8b ab       	sts	0x5b, r24
    13e8:	8c ab       	sts	0x5c, r24
    13ea:	a9 80       	ldd	r10, Y+1	; 0x01
    13ec:	ba 80       	ldd	r11, Y+2	; 0x02
    13ee:	cb 80       	ldd	r12, Y+3	; 0x03
    13f0:	dc 80       	ldd	r13, Y+4	; 0x04
    13f2:	ed 80       	ldd	r14, Y+5	; 0x05
    13f4:	fe 80       	ldd	r15, Y+6	; 0x06
    13f6:	0f 81       	ldd	r16, Y+7	; 0x07
    13f8:	18 85       	ldd	r17, Y+8	; 0x08
    13fa:	2d a5       	lds	r18, 0x6d
    13fc:	2a 0d       	add	r18, r10
    13fe:	e1 e0       	ldi	r30, 0x01	; 1
    1400:	2a 15       	cp	r18, r10
    1402:	08 f0       	brcs	.+2      	; 0x1406 <CO_collectADC+0x224>
    1404:	e0 e0       	ldi	r30, 0x00	; 0
    1406:	3e a5       	lds	r19, 0x6e
    1408:	3b 0d       	add	r19, r11
    140a:	a1 e0       	ldi	r26, 0x01	; 1
    140c:	3b 15       	cp	r19, r11
    140e:	08 f0       	brcs	.+2      	; 0x1412 <CO_collectADC+0x230>
    1410:	a0 e0       	ldi	r26, 0x00	; 0
    1412:	fe 2f       	mov	r31, r30
    1414:	f3 0f       	add	r31, r19
    1416:	e1 e0       	ldi	r30, 0x01	; 1
    1418:	f3 17       	cp	r31, r19
    141a:	08 f0       	brcs	.+2      	; 0x141e <CO_collectADC+0x23c>
    141c:	e0 e0       	ldi	r30, 0x00	; 0
    141e:	ae 2b       	or	r26, r30
    1420:	3f 2f       	mov	r19, r31
    1422:	4f a5       	lds	r20, 0x6f
    1424:	4c 0d       	add	r20, r12
    1426:	b1 e0       	ldi	r27, 0x01	; 1
    1428:	4c 15       	cp	r20, r12
    142a:	08 f0       	brcs	.+2      	; 0x142e <CO_collectADC+0x24c>
    142c:	b0 e0       	ldi	r27, 0x00	; 0
    142e:	fa 2f       	mov	r31, r26
    1430:	f4 0f       	add	r31, r20
    1432:	e1 e0       	ldi	r30, 0x01	; 1
    1434:	f4 17       	cp	r31, r20
    1436:	08 f0       	brcs	.+2      	; 0x143a <CO_collectADC+0x258>
    1438:	e0 e0       	ldi	r30, 0x00	; 0
    143a:	be 2b       	or	r27, r30
    143c:	4f 2f       	mov	r20, r31
    143e:	58 a9       	sts	0x48, r21
    1440:	5d 0d       	add	r21, r13
    1442:	a1 e0       	ldi	r26, 0x01	; 1
    1444:	5d 15       	cp	r21, r13
    1446:	08 f0       	brcs	.+2      	; 0x144a <CO_collectADC+0x268>
    1448:	a0 e0       	ldi	r26, 0x00	; 0
    144a:	fb 2f       	mov	r31, r27
    144c:	f5 0f       	add	r31, r21
    144e:	e1 e0       	ldi	r30, 0x01	; 1
    1450:	f5 17       	cp	r31, r21
    1452:	08 f0       	brcs	.+2      	; 0x1456 <CO_collectADC+0x274>
    1454:	e0 e0       	ldi	r30, 0x00	; 0
    1456:	ae 2b       	or	r26, r30
    1458:	5f 2f       	mov	r21, r31
    145a:	69 a9       	sts	0x49, r22
    145c:	6e 0d       	add	r22, r14
    145e:	b1 e0       	ldi	r27, 0x01	; 1
    1460:	6e 15       	cp	r22, r14
    1462:	08 f0       	brcs	.+2      	; 0x1466 <CO_collectADC+0x284>
    1464:	b0 e0       	ldi	r27, 0x00	; 0
    1466:	fa 2f       	mov	r31, r26
    1468:	f6 0f       	add	r31, r22
    146a:	e1 e0       	ldi	r30, 0x01	; 1
    146c:	f6 17       	cp	r31, r22
    146e:	08 f0       	brcs	.+2      	; 0x1472 <CO_collectADC+0x290>
    1470:	e0 e0       	ldi	r30, 0x00	; 0
    1472:	be 2b       	or	r27, r30
    1474:	6f 2f       	mov	r22, r31
    1476:	7a a9       	sts	0x4a, r23
    1478:	7f 0d       	add	r23, r15
    147a:	a1 e0       	ldi	r26, 0x01	; 1
    147c:	7f 15       	cp	r23, r15
    147e:	08 f0       	brcs	.+2      	; 0x1482 <CO_collectADC+0x2a0>
    1480:	a0 e0       	ldi	r26, 0x00	; 0
    1482:	fb 2f       	mov	r31, r27
    1484:	f7 0f       	add	r31, r23
    1486:	e1 e0       	ldi	r30, 0x01	; 1
    1488:	f7 17       	cp	r31, r23
    148a:	08 f0       	brcs	.+2      	; 0x148e <CO_collectADC+0x2ac>
    148c:	e0 e0       	ldi	r30, 0x00	; 0
    148e:	ae 2b       	or	r26, r30
    1490:	7f 2f       	mov	r23, r31
    1492:	8b a9       	sts	0x4b, r24
    1494:	80 0f       	add	r24, r16
    1496:	f1 e0       	ldi	r31, 0x01	; 1
    1498:	80 17       	cp	r24, r16
    149a:	08 f0       	brcs	.+2      	; 0x149e <CO_collectADC+0x2bc>
    149c:	f0 e0       	ldi	r31, 0x00	; 0
    149e:	a8 0f       	add	r26, r24
    14a0:	e1 e0       	ldi	r30, 0x01	; 1
    14a2:	a8 17       	cp	r26, r24
    14a4:	08 f0       	brcs	.+2      	; 0x14a8 <CO_collectADC+0x2c6>
    14a6:	e0 e0       	ldi	r30, 0x00	; 0
    14a8:	fe 2b       	or	r31, r30
    14aa:	8a 2f       	mov	r24, r26
    14ac:	9c a9       	sts	0x4c, r25
    14ae:	91 0f       	add	r25, r17
    14b0:	ef 2f       	mov	r30, r31
    14b2:	e9 0f       	add	r30, r25
    14b4:	9e 2f       	mov	r25, r30
    14b6:	29 83       	std	Y+1, r18	; 0x01
    14b8:	3a 83       	std	Y+2, r19	; 0x02
    14ba:	4b 83       	std	Y+3, r20	; 0x03
    14bc:	5c 83       	std	Y+4, r21	; 0x04
    14be:	6d 83       	std	Y+5, r22	; 0x05
    14c0:	7e 83       	std	Y+6, r23	; 0x06
    14c2:	8f 83       	std	Y+7, r24	; 0x07
    14c4:	98 87       	std	Y+8, r25	; 0x08
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
    14c6:	80 91 73 50 	lds	r24, 0x5073
    14ca:	90 91 74 50 	lds	r25, 0x5074
    14ce:	88 0f       	add	r24, r24
    14d0:	99 1f       	adc	r25, r25
    14d2:	88 0f       	add	r24, r24
    14d4:	99 1f       	adc	r25, r25
    14d6:	8c 59       	subi	r24, 0x9C	; 156
    14d8:	9f 4b       	sbci	r25, 0xBF	; 191
    14da:	fc 01       	movw	r30, r24
    14dc:	80 81       	ld	r24, Z
    14de:	91 81       	ldd	r25, Z+1	; 0x01
    14e0:	a2 81       	ldd	r26, Z+2	; 0x02
    14e2:	b3 81       	ldd	r27, Z+3	; 0x03
    14e4:	1c 01       	movw	r2, r24
    14e6:	2d 01       	movw	r4, r26
    14e8:	bb 0f       	add	r27, r27
    14ea:	88 0b       	sbc	r24, r24
    14ec:	98 2f       	mov	r25, r24
    14ee:	dc 01       	movw	r26, r24
    14f0:	68 2e       	mov	r6, r24
    14f2:	78 2e       	mov	r7, r24
    14f4:	88 2e       	mov	r8, r24
    14f6:	98 2e       	mov	r9, r24
    14f8:	88 8d       	ldd	r24, Y+24	; 0x18
    14fa:	89 15       	cp	r24, r9
    14fc:	5c f1       	brlt	.+86     	; 0x1554 <CO_collectADC+0x372>
    14fe:	88 8d       	ldd	r24, Y+24	; 0x18
    1500:	89 15       	cp	r24, r9
    1502:	09 f0       	breq	.+2      	; 0x1506 <CO_collectADC+0x324>
    1504:	42 c0       	rjmp	.+132    	; 0x158a <CO_collectADC+0x3a8>
    1506:	8f 89       	ldd	r24, Y+23	; 0x17
    1508:	88 15       	cp	r24, r8
    150a:	20 f1       	brcs	.+72     	; 0x1554 <CO_collectADC+0x372>
    150c:	8f 89       	ldd	r24, Y+23	; 0x17
    150e:	88 15       	cp	r24, r8
    1510:	e1 f5       	brne	.+120    	; 0x158a <CO_collectADC+0x3a8>
    1512:	8e 89       	ldd	r24, Y+22	; 0x16
    1514:	87 15       	cp	r24, r7
    1516:	f0 f0       	brcs	.+60     	; 0x1554 <CO_collectADC+0x372>
    1518:	8e 89       	ldd	r24, Y+22	; 0x16
    151a:	87 15       	cp	r24, r7
    151c:	b1 f5       	brne	.+108    	; 0x158a <CO_collectADC+0x3a8>
    151e:	8d 89       	ldd	r24, Y+21	; 0x15
    1520:	86 15       	cp	r24, r6
    1522:	c0 f0       	brcs	.+48     	; 0x1554 <CO_collectADC+0x372>
    1524:	8d 89       	ldd	r24, Y+21	; 0x15
    1526:	86 15       	cp	r24, r6
    1528:	81 f5       	brne	.+96     	; 0x158a <CO_collectADC+0x3a8>
    152a:	8c 89       	ldd	r24, Y+20	; 0x14
    152c:	85 15       	cp	r24, r5
    152e:	90 f0       	brcs	.+36     	; 0x1554 <CO_collectADC+0x372>
    1530:	8c 89       	ldd	r24, Y+20	; 0x14
    1532:	85 15       	cp	r24, r5
    1534:	51 f5       	brne	.+84     	; 0x158a <CO_collectADC+0x3a8>
    1536:	8b 89       	ldd	r24, Y+19	; 0x13
    1538:	84 15       	cp	r24, r4
    153a:	60 f0       	brcs	.+24     	; 0x1554 <CO_collectADC+0x372>
    153c:	8b 89       	ldd	r24, Y+19	; 0x13
    153e:	84 15       	cp	r24, r4
    1540:	21 f5       	brne	.+72     	; 0x158a <CO_collectADC+0x3a8>
    1542:	8a 89       	ldd	r24, Y+18	; 0x12
    1544:	83 15       	cp	r24, r3
    1546:	30 f0       	brcs	.+12     	; 0x1554 <CO_collectADC+0x372>
    1548:	8a 89       	ldd	r24, Y+18	; 0x12
    154a:	83 15       	cp	r24, r3
    154c:	f1 f4       	brne	.+60     	; 0x158a <CO_collectADC+0x3a8>
    154e:	89 89       	ldd	r24, Y+17	; 0x11
    1550:	82 15       	cp	r24, r2
    1552:	d8 f4       	brcc	.+54     	; 0x158a <CO_collectADC+0x3a8>
    1554:	80 91 73 50 	lds	r24, 0x5073
    1558:	90 91 74 50 	lds	r25, 0x5074
    155c:	88 0f       	add	r24, r24
    155e:	99 1f       	adc	r25, r25
    1560:	88 0f       	add	r24, r24
    1562:	99 1f       	adc	r25, r25
    1564:	8c 59       	subi	r24, 0x9C	; 156
    1566:	9f 4b       	sbci	r25, 0xBF	; 191
    1568:	fc 01       	movw	r30, r24
    156a:	80 81       	ld	r24, Z
    156c:	91 81       	ldd	r25, Z+1	; 0x01
    156e:	a2 81       	ldd	r26, Z+2	; 0x02
    1570:	b3 81       	ldd	r27, Z+3	; 0x03
    1572:	89 8b       	std	Y+17, r24	; 0x11
    1574:	9a 8b       	std	Y+18, r25	; 0x12
    1576:	ab 8b       	std	Y+19, r26	; 0x13
    1578:	bc 8b       	std	Y+20, r27	; 0x14
    157a:	bb 0f       	add	r27, r27
    157c:	88 0b       	sbc	r24, r24
    157e:	98 2f       	mov	r25, r24
    1580:	dc 01       	movw	r26, r24
    1582:	8d 8b       	std	Y+21, r24	; 0x15
    1584:	8e 8b       	std	Y+22, r24	; 0x16
    1586:	8f 8b       	std	Y+23, r24	; 0x17
    1588:	88 8f       	std	Y+24, r24	; 0x18
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
    158a:	80 91 73 50 	lds	r24, 0x5073
    158e:	90 91 74 50 	lds	r25, 0x5074
    1592:	88 0f       	add	r24, r24
    1594:	99 1f       	adc	r25, r25
    1596:	88 0f       	add	r24, r24
    1598:	99 1f       	adc	r25, r25
    159a:	8c 59       	subi	r24, 0x9C	; 156
    159c:	9f 4b       	sbci	r25, 0xBF	; 191
    159e:	fc 01       	movw	r30, r24
    15a0:	80 81       	ld	r24, Z
    15a2:	91 81       	ldd	r25, Z+1	; 0x01
    15a4:	a2 81       	ldd	r26, Z+2	; 0x02
    15a6:	b3 81       	ldd	r27, Z+3	; 0x03
    15a8:	8d ab       	sts	0x5d, r24
    15aa:	9e ab       	sts	0x5e, r25
    15ac:	af ab       	sts	0x5f, r26
    15ae:	b8 af       	sts	0x78, r27
    15b0:	bb 0f       	add	r27, r27
    15b2:	88 0b       	sbc	r24, r24
    15b4:	98 2f       	mov	r25, r24
    15b6:	dc 01       	movw	r26, r24
    15b8:	89 af       	sts	0x79, r24
    15ba:	8a af       	sts	0x7a, r24
    15bc:	8b af       	sts	0x7b, r24
    15be:	8c af       	sts	0x7c, r24
    15c0:	88 89       	ldd	r24, Y+16	; 0x10
    15c2:	fc ad       	sts	0x6c, r31
    15c4:	f8 17       	cp	r31, r24
    15c6:	dc f1       	brlt	.+118    	; 0x163e <CO_collectADC+0x45c>
    15c8:	88 89       	ldd	r24, Y+16	; 0x10
    15ca:	2c ad       	sts	0x6c, r18
    15cc:	82 17       	cp	r24, r18
    15ce:	09 f0       	breq	.+2      	; 0x15d2 <CO_collectADC+0x3f0>
    15d0:	51 c0       	rjmp	.+162    	; 0x1674 <CO_collectADC+0x492>
    15d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    15d4:	9b ad       	sts	0x6b, r25
    15d6:	98 17       	cp	r25, r24
    15d8:	90 f1       	brcs	.+100    	; 0x163e <CO_collectADC+0x45c>
    15da:	8f 85       	ldd	r24, Y+15	; 0x0f
    15dc:	eb ad       	sts	0x6b, r30
    15de:	8e 17       	cp	r24, r30
    15e0:	09 f0       	breq	.+2      	; 0x15e4 <CO_collectADC+0x402>
    15e2:	48 c0       	rjmp	.+144    	; 0x1674 <CO_collectADC+0x492>
    15e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    15e6:	fa ad       	sts	0x6a, r31
    15e8:	f8 17       	cp	r31, r24
    15ea:	48 f1       	brcs	.+82     	; 0x163e <CO_collectADC+0x45c>
    15ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    15ee:	2a ad       	sts	0x6a, r18
    15f0:	82 17       	cp	r24, r18
    15f2:	09 f0       	breq	.+2      	; 0x15f6 <CO_collectADC+0x414>
    15f4:	3f c0       	rjmp	.+126    	; 0x1674 <CO_collectADC+0x492>
    15f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    15f8:	99 ad       	sts	0x69, r25
    15fa:	98 17       	cp	r25, r24
    15fc:	00 f1       	brcs	.+64     	; 0x163e <CO_collectADC+0x45c>
    15fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1600:	e9 ad       	sts	0x69, r30
    1602:	8e 17       	cp	r24, r30
    1604:	b9 f5       	brne	.+110    	; 0x1674 <CO_collectADC+0x492>
    1606:	8c 85       	ldd	r24, Y+12	; 0x0c
    1608:	f8 ad       	sts	0x68, r31
    160a:	f8 17       	cp	r31, r24
    160c:	c0 f0       	brcs	.+48     	; 0x163e <CO_collectADC+0x45c>
    160e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1610:	28 ad       	sts	0x68, r18
    1612:	82 17       	cp	r24, r18
    1614:	79 f5       	brne	.+94     	; 0x1674 <CO_collectADC+0x492>
    1616:	8b 85       	ldd	r24, Y+11	; 0x0b
    1618:	9f a9       	sts	0x4f, r25
    161a:	98 17       	cp	r25, r24
    161c:	80 f0       	brcs	.+32     	; 0x163e <CO_collectADC+0x45c>
    161e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1620:	ef a9       	sts	0x4f, r30
    1622:	8e 17       	cp	r24, r30
    1624:	39 f5       	brne	.+78     	; 0x1674 <CO_collectADC+0x492>
    1626:	8a 85       	ldd	r24, Y+10	; 0x0a
    1628:	fe a9       	sts	0x4e, r31
    162a:	f8 17       	cp	r31, r24
    162c:	40 f0       	brcs	.+16     	; 0x163e <CO_collectADC+0x45c>
    162e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1630:	2e a9       	sts	0x4e, r18
    1632:	82 17       	cp	r24, r18
    1634:	f9 f4       	brne	.+62     	; 0x1674 <CO_collectADC+0x492>
    1636:	89 85       	ldd	r24, Y+9	; 0x09
    1638:	9d a9       	sts	0x4d, r25
    163a:	98 17       	cp	r25, r24
    163c:	d8 f4       	brcc	.+54     	; 0x1674 <CO_collectADC+0x492>
    163e:	80 91 73 50 	lds	r24, 0x5073
    1642:	90 91 74 50 	lds	r25, 0x5074
    1646:	88 0f       	add	r24, r24
    1648:	99 1f       	adc	r25, r25
    164a:	88 0f       	add	r24, r24
    164c:	99 1f       	adc	r25, r25
    164e:	8c 59       	subi	r24, 0x9C	; 156
    1650:	9f 4b       	sbci	r25, 0xBF	; 191
    1652:	fc 01       	movw	r30, r24
    1654:	80 81       	ld	r24, Z
    1656:	91 81       	ldd	r25, Z+1	; 0x01
    1658:	a2 81       	ldd	r26, Z+2	; 0x02
    165a:	b3 81       	ldd	r27, Z+3	; 0x03
    165c:	89 87       	std	Y+9, r24	; 0x09
    165e:	9a 87       	std	Y+10, r25	; 0x0a
    1660:	ab 87       	std	Y+11, r26	; 0x0b
    1662:	bc 87       	std	Y+12, r27	; 0x0c
    1664:	bb 0f       	add	r27, r27
    1666:	88 0b       	sbc	r24, r24
    1668:	98 2f       	mov	r25, r24
    166a:	dc 01       	movw	r26, r24
    166c:	8d 87       	std	Y+13, r24	; 0x0d
    166e:	8e 87       	std	Y+14, r24	; 0x0e
    1670:	8f 87       	std	Y+15, r24	; 0x0f
    1672:	88 8b       	std	Y+16, r24	; 0x10
	SPIDisable();	
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    1674:	80 91 73 50 	lds	r24, 0x5073
    1678:	90 91 74 50 	lds	r25, 0x5074
    167c:	01 96       	adiw	r24, 0x01	; 1
    167e:	80 93 73 50 	sts	0x5073, r24
    1682:	90 93 74 50 	sts	0x5074, r25
    1686:	80 91 73 50 	lds	r24, 0x5073
    168a:	90 91 74 50 	lds	r25, 0x5074
    168e:	f4 e0       	ldi	r31, 0x04	; 4
    1690:	80 30       	cpi	r24, 0x00	; 0
    1692:	9f 07       	cpc	r25, r31
    1694:	08 f4       	brcc	.+2      	; 0x1698 <CO_collectADC+0x4b6>
    1696:	8e ce       	rjmp	.-740    	; 0x13b4 <CO_collectADC+0x1d2>
		sum += data24Bit[sampleCount];
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
	}
	average = sum / NUM_SAMPLES;
    1698:	29 81       	ldd	r18, Y+1	; 0x01
    169a:	3a 81       	ldd	r19, Y+2	; 0x02
    169c:	4b 81       	ldd	r20, Y+3	; 0x03
    169e:	5c 81       	ldd	r21, Y+4	; 0x04
    16a0:	6d 81       	ldd	r22, Y+5	; 0x05
    16a2:	7e 81       	ldd	r23, Y+6	; 0x06
    16a4:	8f 81       	ldd	r24, Y+7	; 0x07
    16a6:	98 85       	ldd	r25, Y+8	; 0x08
    16a8:	a2 2e       	mov	r10, r18
    16aa:	b3 2e       	mov	r11, r19
    16ac:	c4 2e       	mov	r12, r20
    16ae:	d5 2e       	mov	r13, r21
    16b0:	e6 2e       	mov	r14, r22
    16b2:	f7 2e       	mov	r15, r23
    16b4:	08 2f       	mov	r16, r24
    16b6:	19 2f       	mov	r17, r25
    16b8:	11 23       	and	r17, r17
    16ba:	0c f0       	brlt	.+2      	; 0x16be <CO_collectADC+0x4dc>
    16bc:	6c c0       	rjmp	.+216    	; 0x1796 <CO_collectADC+0x5b4>
    16be:	22 24       	eor	r2, r2
    16c0:	2a 94       	dec	r2
    16c2:	0f 2e       	mov	r0, r31
    16c4:	f3 e0       	ldi	r31, 0x03	; 3
    16c6:	3f 2e       	mov	r3, r31
    16c8:	f0 2d       	mov	r31, r0
    16ca:	44 24       	eor	r4, r4
    16cc:	55 24       	eor	r5, r5
    16ce:	66 24       	eor	r6, r6
    16d0:	77 24       	eor	r7, r7
    16d2:	88 24       	eor	r8, r8
    16d4:	99 24       	eor	r9, r9
    16d6:	2a 2d       	mov	r18, r10
    16d8:	22 0d       	add	r18, r2
    16da:	e1 e0       	ldi	r30, 0x01	; 1
    16dc:	2a 15       	cp	r18, r10
    16de:	08 f0       	brcs	.+2      	; 0x16e2 <CO_collectADC+0x500>
    16e0:	e0 e0       	ldi	r30, 0x00	; 0
    16e2:	3b 2d       	mov	r19, r11
    16e4:	33 0d       	add	r19, r3
    16e6:	f1 e0       	ldi	r31, 0x01	; 1
    16e8:	3b 15       	cp	r19, r11
    16ea:	08 f0       	brcs	.+2      	; 0x16ee <CO_collectADC+0x50c>
    16ec:	f0 e0       	ldi	r31, 0x00	; 0
    16ee:	e3 0f       	add	r30, r19
    16f0:	a1 e0       	ldi	r26, 0x01	; 1
    16f2:	e3 17       	cp	r30, r19
    16f4:	08 f0       	brcs	.+2      	; 0x16f8 <CO_collectADC+0x516>
    16f6:	a0 e0       	ldi	r26, 0x00	; 0
    16f8:	fa 2b       	or	r31, r26
    16fa:	3e 2f       	mov	r19, r30
    16fc:	4c 2d       	mov	r20, r12
    16fe:	44 0d       	add	r20, r4
    1700:	e1 e0       	ldi	r30, 0x01	; 1
    1702:	4c 15       	cp	r20, r12
    1704:	08 f0       	brcs	.+2      	; 0x1708 <CO_collectADC+0x526>
    1706:	e0 e0       	ldi	r30, 0x00	; 0
    1708:	f4 0f       	add	r31, r20
    170a:	a1 e0       	ldi	r26, 0x01	; 1
    170c:	f4 17       	cp	r31, r20
    170e:	08 f0       	brcs	.+2      	; 0x1712 <CO_collectADC+0x530>
    1710:	a0 e0       	ldi	r26, 0x00	; 0
    1712:	ea 2b       	or	r30, r26
    1714:	4f 2f       	mov	r20, r31
    1716:	5d 2d       	mov	r21, r13
    1718:	55 0d       	add	r21, r5
    171a:	f1 e0       	ldi	r31, 0x01	; 1
    171c:	5d 15       	cp	r21, r13
    171e:	08 f0       	brcs	.+2      	; 0x1722 <CO_collectADC+0x540>
    1720:	f0 e0       	ldi	r31, 0x00	; 0
    1722:	e5 0f       	add	r30, r21
    1724:	a1 e0       	ldi	r26, 0x01	; 1
    1726:	e5 17       	cp	r30, r21
    1728:	08 f0       	brcs	.+2      	; 0x172c <CO_collectADC+0x54a>
    172a:	a0 e0       	ldi	r26, 0x00	; 0
    172c:	fa 2b       	or	r31, r26
    172e:	5e 2f       	mov	r21, r30
    1730:	6e 2d       	mov	r22, r14
    1732:	66 0d       	add	r22, r6
    1734:	e1 e0       	ldi	r30, 0x01	; 1
    1736:	6e 15       	cp	r22, r14
    1738:	08 f0       	brcs	.+2      	; 0x173c <CO_collectADC+0x55a>
    173a:	e0 e0       	ldi	r30, 0x00	; 0
    173c:	f6 0f       	add	r31, r22
    173e:	a1 e0       	ldi	r26, 0x01	; 1
    1740:	f6 17       	cp	r31, r22
    1742:	08 f0       	brcs	.+2      	; 0x1746 <CO_collectADC+0x564>
    1744:	a0 e0       	ldi	r26, 0x00	; 0
    1746:	ea 2b       	or	r30, r26
    1748:	6f 2f       	mov	r22, r31
    174a:	7f 2d       	mov	r23, r15
    174c:	77 0d       	add	r23, r7
    174e:	f1 e0       	ldi	r31, 0x01	; 1
    1750:	7f 15       	cp	r23, r15
    1752:	08 f0       	brcs	.+2      	; 0x1756 <CO_collectADC+0x574>
    1754:	f0 e0       	ldi	r31, 0x00	; 0
    1756:	e7 0f       	add	r30, r23
    1758:	a1 e0       	ldi	r26, 0x01	; 1
    175a:	e7 17       	cp	r30, r23
    175c:	08 f0       	brcs	.+2      	; 0x1760 <CO_collectADC+0x57e>
    175e:	a0 e0       	ldi	r26, 0x00	; 0
    1760:	fa 2b       	or	r31, r26
    1762:	7e 2f       	mov	r23, r30
    1764:	80 2f       	mov	r24, r16
    1766:	88 0d       	add	r24, r8
    1768:	e1 e0       	ldi	r30, 0x01	; 1
    176a:	80 17       	cp	r24, r16
    176c:	08 f0       	brcs	.+2      	; 0x1770 <CO_collectADC+0x58e>
    176e:	e0 e0       	ldi	r30, 0x00	; 0
    1770:	f8 0f       	add	r31, r24
    1772:	a1 e0       	ldi	r26, 0x01	; 1
    1774:	f8 17       	cp	r31, r24
    1776:	08 f0       	brcs	.+2      	; 0x177a <CO_collectADC+0x598>
    1778:	a0 e0       	ldi	r26, 0x00	; 0
    177a:	ea 2b       	or	r30, r26
    177c:	8f 2f       	mov	r24, r31
    177e:	91 2f       	mov	r25, r17
    1780:	99 0d       	add	r25, r9
    1782:	e9 0f       	add	r30, r25
    1784:	9e 2f       	mov	r25, r30
    1786:	a2 2e       	mov	r10, r18
    1788:	b3 2e       	mov	r11, r19
    178a:	c4 2e       	mov	r12, r20
    178c:	d5 2e       	mov	r13, r21
    178e:	e6 2e       	mov	r14, r22
    1790:	f7 2e       	mov	r15, r23
    1792:	08 2f       	mov	r16, r24
    1794:	19 2f       	mov	r17, r25
    1796:	2a 2d       	mov	r18, r10
    1798:	3b 2d       	mov	r19, r11
    179a:	4c 2d       	mov	r20, r12
    179c:	5d 2d       	mov	r21, r13
    179e:	6e 2d       	mov	r22, r14
    17a0:	7f 2d       	mov	r23, r15
    17a2:	80 2f       	mov	r24, r16
    17a4:	91 2f       	mov	r25, r17
    17a6:	0a e0       	ldi	r16, 0x0A	; 10
    17a8:	0e 94 da 54 	call	0xa9b4	; 0xa9b4 <__ashrdi3>
    17ac:	a2 2e       	mov	r10, r18
    17ae:	b3 2e       	mov	r11, r19
    17b0:	c4 2e       	mov	r12, r20
    17b2:	d5 2e       	mov	r13, r21
    17b4:	e6 2e       	mov	r14, r22
    17b6:	f7 2e       	mov	r15, r23
    17b8:	08 2f       	mov	r16, r24
    17ba:	19 2f       	mov	r17, r25
    17bc:	ab 8e       	std	Y+27, r10	; 0x1b
    17be:	bc 8e       	std	Y+28, r11	; 0x1c
    17c0:	cd 8e       	std	Y+29, r12	; 0x1d
    17c2:	de 8e       	std	Y+30, r13	; 0x1e
    17c4:	ef 8e       	std	Y+31, r14	; 0x1f
    17c6:	f8 a2       	lds	r31, 0x98
    17c8:	09 a3       	lds	r16, 0x59
    17ca:	1a a3       	lds	r17, 0x5a

	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    17cc:	2b 8d       	ldd	r18, Y+27	; 0x1b
    17ce:	3c 8d       	ldd	r19, Y+28	; 0x1c
    17d0:	4d 8d       	ldd	r20, Y+29	; 0x1d
    17d2:	5e 8d       	ldd	r21, Y+30	; 0x1e
    17d4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17d6:	78 a1       	lds	r23, 0x48
    17d8:	89 a1       	lds	r24, 0x49
    17da:	9a a1       	lds	r25, 0x4a
    17dc:	0f 2e       	mov	r0, r31
    17de:	f0 ea       	ldi	r31, 0xA0	; 160
    17e0:	af 2e       	mov	r10, r31
    17e2:	f0 2d       	mov	r31, r0
    17e4:	0f 2e       	mov	r0, r31
    17e6:	f5 e2       	ldi	r31, 0x25	; 37
    17e8:	bf 2e       	mov	r11, r31
    17ea:	f0 2d       	mov	r31, r0
    17ec:	0f 2e       	mov	r0, r31
    17ee:	f6 e2       	ldi	r31, 0x26	; 38
    17f0:	cf 2e       	mov	r12, r31
    17f2:	f0 2d       	mov	r31, r0
    17f4:	dd 24       	eor	r13, r13
    17f6:	ee 24       	eor	r14, r14
    17f8:	ff 24       	eor	r15, r15
    17fa:	00 e0       	ldi	r16, 0x00	; 0
    17fc:	10 e0       	ldi	r17, 0x00	; 0
    17fe:	0e 94 93 53 	call	0xa726	; 0xa726 <__muldi3>
    1802:	22 2e       	mov	r2, r18
    1804:	33 2e       	mov	r3, r19
    1806:	44 2e       	mov	r4, r20
    1808:	55 2e       	mov	r5, r21
    180a:	66 2e       	mov	r6, r22
    180c:	77 2e       	mov	r7, r23
    180e:	88 2e       	mov	r8, r24
    1810:	99 2e       	mov	r9, r25
    1812:	a2 2c       	mov	r10, r2
    1814:	b3 2c       	mov	r11, r3
    1816:	c4 2c       	mov	r12, r4
    1818:	d5 2c       	mov	r13, r5
    181a:	e6 2c       	mov	r14, r6
    181c:	f7 2c       	mov	r15, r7
    181e:	08 2d       	mov	r16, r8
    1820:	19 2d       	mov	r17, r9
    1822:	2a 2d       	mov	r18, r10
    1824:	3b 2d       	mov	r19, r11
    1826:	4c 2d       	mov	r20, r12
    1828:	5d 2d       	mov	r21, r13
    182a:	6e 2d       	mov	r22, r14
    182c:	7f 2d       	mov	r23, r15
    182e:	80 2f       	mov	r24, r16
    1830:	91 2f       	mov	r25, r17
    1832:	aa 24       	eor	r10, r10
    1834:	aa 94       	dec	r10
    1836:	bb 24       	eor	r11, r11
    1838:	ba 94       	dec	r11
    183a:	0f 2e       	mov	r0, r31
    183c:	ff e7       	ldi	r31, 0x7F	; 127
    183e:	cf 2e       	mov	r12, r31
    1840:	f0 2d       	mov	r31, r0
    1842:	dd 24       	eor	r13, r13
    1844:	ee 24       	eor	r14, r14
    1846:	ff 24       	eor	r15, r15
    1848:	00 e0       	ldi	r16, 0x00	; 0
    184a:	10 e0       	ldi	r17, 0x00	; 0
    184c:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    1850:	22 2e       	mov	r2, r18
    1852:	33 2e       	mov	r3, r19
    1854:	44 2e       	mov	r4, r20
    1856:	55 2e       	mov	r5, r21
    1858:	66 2e       	mov	r6, r22
    185a:	77 2e       	mov	r7, r23
    185c:	88 2e       	mov	r8, r24
    185e:	99 2e       	mov	r9, r25
    1860:	a2 2c       	mov	r10, r2
    1862:	b3 2c       	mov	r11, r3
    1864:	c4 2c       	mov	r12, r4
    1866:	d5 2c       	mov	r13, r5
    1868:	e6 2c       	mov	r14, r6
    186a:	f7 2c       	mov	r15, r7
    186c:	08 2d       	mov	r16, r8
    186e:	19 2d       	mov	r17, r9
    1870:	2a 2d       	mov	r18, r10
    1872:	3b 2d       	mov	r19, r11
    1874:	4c 2d       	mov	r20, r12
    1876:	5d 2d       	mov	r21, r13
    1878:	6e 2d       	mov	r22, r14
    187a:	7f 2d       	mov	r23, r15
    187c:	80 2f       	mov	r24, r16
    187e:	91 2f       	mov	r25, r17
    1880:	01 e0       	ldi	r16, 0x01	; 1
    1882:	0e 94 66 54 	call	0xa8cc	; 0xa8cc <__ashldi3>
    1886:	22 2e       	mov	r2, r18
    1888:	33 2e       	mov	r3, r19
    188a:	44 2e       	mov	r4, r20
    188c:	55 2e       	mov	r5, r21
    188e:	66 2e       	mov	r6, r22
    1890:	77 2e       	mov	r7, r23
    1892:	88 2e       	mov	r8, r24
    1894:	99 2e       	mov	r9, r25
    1896:	a2 2c       	mov	r10, r2
    1898:	b3 2c       	mov	r11, r3
    189a:	c4 2c       	mov	r12, r4
    189c:	d5 2c       	mov	r13, r5
    189e:	e6 2c       	mov	r14, r6
    18a0:	f7 2c       	mov	r15, r7
    18a2:	08 2d       	mov	r16, r8
    18a4:	19 2d       	mov	r17, r9
    18a6:	2a 2d       	mov	r18, r10
    18a8:	3b 2d       	mov	r19, r11
    18aa:	4c 2d       	mov	r20, r12
    18ac:	5d 2d       	mov	r21, r13
    18ae:	6e 2d       	mov	r22, r14
    18b0:	7f 2d       	mov	r23, r15
    18b2:	80 2f       	mov	r24, r16
    18b4:	91 2f       	mov	r25, r17
    18b6:	0f 2e       	mov	r0, r31
    18b8:	f3 e0       	ldi	r31, 0x03	; 3
    18ba:	af 2e       	mov	r10, r31
    18bc:	f0 2d       	mov	r31, r0
    18be:	bb 24       	eor	r11, r11
    18c0:	cc 24       	eor	r12, r12
    18c2:	dd 24       	eor	r13, r13
    18c4:	ee 24       	eor	r14, r14
    18c6:	ff 24       	eor	r15, r15
    18c8:	00 e0       	ldi	r16, 0x00	; 0
    18ca:	10 e0       	ldi	r17, 0x00	; 0
    18cc:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    18d0:	a2 2e       	mov	r10, r18
    18d2:	b3 2e       	mov	r11, r19
    18d4:	c4 2e       	mov	r12, r20
    18d6:	d5 2e       	mov	r13, r21
    18d8:	e6 2e       	mov	r14, r22
    18da:	f7 2e       	mov	r15, r23
    18dc:	08 2f       	mov	r16, r24
    18de:	19 2f       	mov	r17, r25
    18e0:	2a 2d       	mov	r18, r10
    18e2:	3b 2d       	mov	r19, r11
    18e4:	4c 2d       	mov	r20, r12
    18e6:	5d 2d       	mov	r21, r13
    18e8:	6e 2d       	mov	r22, r14
    18ea:	7f 2d       	mov	r23, r15
    18ec:	80 2f       	mov	r24, r16
    18ee:	91 2f       	mov	r25, r17
    18f0:	da 01       	movw	r26, r20
    18f2:	c9 01       	movw	r24, r18
    18f4:	b0 95       	com	r27
    18f6:	a0 95       	com	r26
    18f8:	90 95       	com	r25
    18fa:	81 95       	neg	r24
    18fc:	9f 4f       	sbci	r25, 0xFF	; 255
    18fe:	af 4f       	sbci	r26, 0xFF	; 255
    1900:	bf 4f       	sbci	r27, 0xFF	; 255
    1902:	2d a1       	lds	r18, 0x4d
    1904:	3e a1       	lds	r19, 0x4e
    1906:	f9 01       	movw	r30, r18
    1908:	80 83       	st	Z, r24
    190a:	91 83       	std	Z+1, r25	; 0x01
    190c:	a2 83       	std	Z+2, r26	; 0x02
    190e:	b3 83       	std	Z+3, r27	; 0x03
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1910:	29 89       	ldd	r18, Y+17	; 0x11
    1912:	3a 89       	ldd	r19, Y+18	; 0x12
    1914:	4b 89       	ldd	r20, Y+19	; 0x13
    1916:	5c 89       	ldd	r21, Y+20	; 0x14
    1918:	6d 89       	ldd	r22, Y+21	; 0x15
    191a:	7e 89       	ldd	r23, Y+22	; 0x16
    191c:	8f 89       	ldd	r24, Y+23	; 0x17
    191e:	98 8d       	ldd	r25, Y+24	; 0x18
    1920:	0f 2e       	mov	r0, r31
    1922:	f0 ea       	ldi	r31, 0xA0	; 160
    1924:	af 2e       	mov	r10, r31
    1926:	f0 2d       	mov	r31, r0
    1928:	0f 2e       	mov	r0, r31
    192a:	f5 e2       	ldi	r31, 0x25	; 37
    192c:	bf 2e       	mov	r11, r31
    192e:	f0 2d       	mov	r31, r0
    1930:	0f 2e       	mov	r0, r31
    1932:	f6 e2       	ldi	r31, 0x26	; 38
    1934:	cf 2e       	mov	r12, r31
    1936:	f0 2d       	mov	r31, r0
    1938:	dd 24       	eor	r13, r13
    193a:	ee 24       	eor	r14, r14
    193c:	ff 24       	eor	r15, r15
    193e:	00 e0       	ldi	r16, 0x00	; 0
    1940:	10 e0       	ldi	r17, 0x00	; 0
    1942:	0e 94 93 53 	call	0xa726	; 0xa726 <__muldi3>
    1946:	22 2e       	mov	r2, r18
    1948:	33 2e       	mov	r3, r19
    194a:	44 2e       	mov	r4, r20
    194c:	55 2e       	mov	r5, r21
    194e:	66 2e       	mov	r6, r22
    1950:	77 2e       	mov	r7, r23
    1952:	88 2e       	mov	r8, r24
    1954:	99 2e       	mov	r9, r25
    1956:	a2 2c       	mov	r10, r2
    1958:	b3 2c       	mov	r11, r3
    195a:	c4 2c       	mov	r12, r4
    195c:	d5 2c       	mov	r13, r5
    195e:	e6 2c       	mov	r14, r6
    1960:	f7 2c       	mov	r15, r7
    1962:	08 2d       	mov	r16, r8
    1964:	19 2d       	mov	r17, r9
    1966:	2a 2d       	mov	r18, r10
    1968:	3b 2d       	mov	r19, r11
    196a:	4c 2d       	mov	r20, r12
    196c:	5d 2d       	mov	r21, r13
    196e:	6e 2d       	mov	r22, r14
    1970:	7f 2d       	mov	r23, r15
    1972:	80 2f       	mov	r24, r16
    1974:	91 2f       	mov	r25, r17
    1976:	aa 24       	eor	r10, r10
    1978:	aa 94       	dec	r10
    197a:	bb 24       	eor	r11, r11
    197c:	ba 94       	dec	r11
    197e:	0f 2e       	mov	r0, r31
    1980:	ff e7       	ldi	r31, 0x7F	; 127
    1982:	cf 2e       	mov	r12, r31
    1984:	f0 2d       	mov	r31, r0
    1986:	dd 24       	eor	r13, r13
    1988:	ee 24       	eor	r14, r14
    198a:	ff 24       	eor	r15, r15
    198c:	00 e0       	ldi	r16, 0x00	; 0
    198e:	10 e0       	ldi	r17, 0x00	; 0
    1990:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    1994:	22 2e       	mov	r2, r18
    1996:	33 2e       	mov	r3, r19
    1998:	44 2e       	mov	r4, r20
    199a:	55 2e       	mov	r5, r21
    199c:	66 2e       	mov	r6, r22
    199e:	77 2e       	mov	r7, r23
    19a0:	88 2e       	mov	r8, r24
    19a2:	99 2e       	mov	r9, r25
    19a4:	a2 2c       	mov	r10, r2
    19a6:	b3 2c       	mov	r11, r3
    19a8:	c4 2c       	mov	r12, r4
    19aa:	d5 2c       	mov	r13, r5
    19ac:	e6 2c       	mov	r14, r6
    19ae:	f7 2c       	mov	r15, r7
    19b0:	08 2d       	mov	r16, r8
    19b2:	19 2d       	mov	r17, r9
    19b4:	2a 2d       	mov	r18, r10
    19b6:	3b 2d       	mov	r19, r11
    19b8:	4c 2d       	mov	r20, r12
    19ba:	5d 2d       	mov	r21, r13
    19bc:	6e 2d       	mov	r22, r14
    19be:	7f 2d       	mov	r23, r15
    19c0:	80 2f       	mov	r24, r16
    19c2:	91 2f       	mov	r25, r17
    19c4:	01 e0       	ldi	r16, 0x01	; 1
    19c6:	0e 94 66 54 	call	0xa8cc	; 0xa8cc <__ashldi3>
    19ca:	22 2e       	mov	r2, r18
    19cc:	33 2e       	mov	r3, r19
    19ce:	44 2e       	mov	r4, r20
    19d0:	55 2e       	mov	r5, r21
    19d2:	66 2e       	mov	r6, r22
    19d4:	77 2e       	mov	r7, r23
    19d6:	88 2e       	mov	r8, r24
    19d8:	99 2e       	mov	r9, r25
    19da:	a2 2c       	mov	r10, r2
    19dc:	b3 2c       	mov	r11, r3
    19de:	c4 2c       	mov	r12, r4
    19e0:	d5 2c       	mov	r13, r5
    19e2:	e6 2c       	mov	r14, r6
    19e4:	f7 2c       	mov	r15, r7
    19e6:	08 2d       	mov	r16, r8
    19e8:	19 2d       	mov	r17, r9
    19ea:	2a 2d       	mov	r18, r10
    19ec:	3b 2d       	mov	r19, r11
    19ee:	4c 2d       	mov	r20, r12
    19f0:	5d 2d       	mov	r21, r13
    19f2:	6e 2d       	mov	r22, r14
    19f4:	7f 2d       	mov	r23, r15
    19f6:	80 2f       	mov	r24, r16
    19f8:	91 2f       	mov	r25, r17
    19fa:	0f 2e       	mov	r0, r31
    19fc:	f3 e0       	ldi	r31, 0x03	; 3
    19fe:	af 2e       	mov	r10, r31
    1a00:	f0 2d       	mov	r31, r0
    1a02:	bb 24       	eor	r11, r11
    1a04:	cc 24       	eor	r12, r12
    1a06:	dd 24       	eor	r13, r13
    1a08:	ee 24       	eor	r14, r14
    1a0a:	ff 24       	eor	r15, r15
    1a0c:	00 e0       	ldi	r16, 0x00	; 0
    1a0e:	10 e0       	ldi	r17, 0x00	; 0
    1a10:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    1a14:	a2 2e       	mov	r10, r18
    1a16:	b3 2e       	mov	r11, r19
    1a18:	c4 2e       	mov	r12, r20
    1a1a:	d5 2e       	mov	r13, r21
    1a1c:	e6 2e       	mov	r14, r22
    1a1e:	f7 2e       	mov	r15, r23
    1a20:	08 2f       	mov	r16, r24
    1a22:	19 2f       	mov	r17, r25
    1a24:	2a 2d       	mov	r18, r10
    1a26:	3b 2d       	mov	r19, r11
    1a28:	4c 2d       	mov	r20, r12
    1a2a:	5d 2d       	mov	r21, r13
    1a2c:	6e 2d       	mov	r22, r14
    1a2e:	7f 2d       	mov	r23, r15
    1a30:	80 2f       	mov	r24, r16
    1a32:	91 2f       	mov	r25, r17
    1a34:	da 01       	movw	r26, r20
    1a36:	c9 01       	movw	r24, r18
    1a38:	b0 95       	com	r27
    1a3a:	a0 95       	com	r26
    1a3c:	90 95       	com	r25
    1a3e:	81 95       	neg	r24
    1a40:	9f 4f       	sbci	r25, 0xFF	; 255
    1a42:	af 4f       	sbci	r26, 0xFF	; 255
    1a44:	bf 4f       	sbci	r27, 0xFF	; 255
    1a46:	29 a5       	lds	r18, 0x69
    1a48:	3a a5       	lds	r19, 0x6a
    1a4a:	f9 01       	movw	r30, r18
    1a4c:	80 83       	st	Z, r24
    1a4e:	91 83       	std	Z+1, r25	; 0x01
    1a50:	a2 83       	std	Z+2, r26	; 0x02
    1a52:	b3 83       	std	Z+3, r27	; 0x03
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a54:	29 85       	ldd	r18, Y+9	; 0x09
    1a56:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a58:	4b 85       	ldd	r20, Y+11	; 0x0b
    1a5a:	5c 85       	ldd	r21, Y+12	; 0x0c
    1a5c:	6d 85       	ldd	r22, Y+13	; 0x0d
    1a5e:	7e 85       	ldd	r23, Y+14	; 0x0e
    1a60:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a62:	98 89       	ldd	r25, Y+16	; 0x10
    1a64:	0f 2e       	mov	r0, r31
    1a66:	f0 ea       	ldi	r31, 0xA0	; 160
    1a68:	af 2e       	mov	r10, r31
    1a6a:	f0 2d       	mov	r31, r0
    1a6c:	0f 2e       	mov	r0, r31
    1a6e:	f5 e2       	ldi	r31, 0x25	; 37
    1a70:	bf 2e       	mov	r11, r31
    1a72:	f0 2d       	mov	r31, r0
    1a74:	0f 2e       	mov	r0, r31
    1a76:	f6 e2       	ldi	r31, 0x26	; 38
    1a78:	cf 2e       	mov	r12, r31
    1a7a:	f0 2d       	mov	r31, r0
    1a7c:	dd 24       	eor	r13, r13
    1a7e:	ee 24       	eor	r14, r14
    1a80:	ff 24       	eor	r15, r15
    1a82:	00 e0       	ldi	r16, 0x00	; 0
    1a84:	10 e0       	ldi	r17, 0x00	; 0
    1a86:	0e 94 93 53 	call	0xa726	; 0xa726 <__muldi3>
    1a8a:	22 2e       	mov	r2, r18
    1a8c:	33 2e       	mov	r3, r19
    1a8e:	44 2e       	mov	r4, r20
    1a90:	55 2e       	mov	r5, r21
    1a92:	66 2e       	mov	r6, r22
    1a94:	77 2e       	mov	r7, r23
    1a96:	88 2e       	mov	r8, r24
    1a98:	99 2e       	mov	r9, r25
    1a9a:	a2 2c       	mov	r10, r2
    1a9c:	b3 2c       	mov	r11, r3
    1a9e:	c4 2c       	mov	r12, r4
    1aa0:	d5 2c       	mov	r13, r5
    1aa2:	e6 2c       	mov	r14, r6
    1aa4:	f7 2c       	mov	r15, r7
    1aa6:	08 2d       	mov	r16, r8
    1aa8:	19 2d       	mov	r17, r9
    1aaa:	2a 2d       	mov	r18, r10
    1aac:	3b 2d       	mov	r19, r11
    1aae:	4c 2d       	mov	r20, r12
    1ab0:	5d 2d       	mov	r21, r13
    1ab2:	6e 2d       	mov	r22, r14
    1ab4:	7f 2d       	mov	r23, r15
    1ab6:	80 2f       	mov	r24, r16
    1ab8:	91 2f       	mov	r25, r17
    1aba:	aa 24       	eor	r10, r10
    1abc:	aa 94       	dec	r10
    1abe:	bb 24       	eor	r11, r11
    1ac0:	ba 94       	dec	r11
    1ac2:	0f 2e       	mov	r0, r31
    1ac4:	ff e7       	ldi	r31, 0x7F	; 127
    1ac6:	cf 2e       	mov	r12, r31
    1ac8:	f0 2d       	mov	r31, r0
    1aca:	dd 24       	eor	r13, r13
    1acc:	ee 24       	eor	r14, r14
    1ace:	ff 24       	eor	r15, r15
    1ad0:	00 e0       	ldi	r16, 0x00	; 0
    1ad2:	10 e0       	ldi	r17, 0x00	; 0
    1ad4:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    1ad8:	22 2e       	mov	r2, r18
    1ada:	33 2e       	mov	r3, r19
    1adc:	44 2e       	mov	r4, r20
    1ade:	55 2e       	mov	r5, r21
    1ae0:	66 2e       	mov	r6, r22
    1ae2:	77 2e       	mov	r7, r23
    1ae4:	88 2e       	mov	r8, r24
    1ae6:	99 2e       	mov	r9, r25
    1ae8:	a2 2c       	mov	r10, r2
    1aea:	b3 2c       	mov	r11, r3
    1aec:	c4 2c       	mov	r12, r4
    1aee:	d5 2c       	mov	r13, r5
    1af0:	e6 2c       	mov	r14, r6
    1af2:	f7 2c       	mov	r15, r7
    1af4:	08 2d       	mov	r16, r8
    1af6:	19 2d       	mov	r17, r9
    1af8:	2a 2d       	mov	r18, r10
    1afa:	3b 2d       	mov	r19, r11
    1afc:	4c 2d       	mov	r20, r12
    1afe:	5d 2d       	mov	r21, r13
    1b00:	6e 2d       	mov	r22, r14
    1b02:	7f 2d       	mov	r23, r15
    1b04:	80 2f       	mov	r24, r16
    1b06:	91 2f       	mov	r25, r17
    1b08:	01 e0       	ldi	r16, 0x01	; 1
    1b0a:	0e 94 66 54 	call	0xa8cc	; 0xa8cc <__ashldi3>
    1b0e:	22 2e       	mov	r2, r18
    1b10:	33 2e       	mov	r3, r19
    1b12:	44 2e       	mov	r4, r20
    1b14:	55 2e       	mov	r5, r21
    1b16:	66 2e       	mov	r6, r22
    1b18:	77 2e       	mov	r7, r23
    1b1a:	88 2e       	mov	r8, r24
    1b1c:	99 2e       	mov	r9, r25
    1b1e:	a2 2c       	mov	r10, r2
    1b20:	b3 2c       	mov	r11, r3
    1b22:	c4 2c       	mov	r12, r4
    1b24:	d5 2c       	mov	r13, r5
    1b26:	e6 2c       	mov	r14, r6
    1b28:	f7 2c       	mov	r15, r7
    1b2a:	08 2d       	mov	r16, r8
    1b2c:	19 2d       	mov	r17, r9
    1b2e:	2a 2d       	mov	r18, r10
    1b30:	3b 2d       	mov	r19, r11
    1b32:	4c 2d       	mov	r20, r12
    1b34:	5d 2d       	mov	r21, r13
    1b36:	6e 2d       	mov	r22, r14
    1b38:	7f 2d       	mov	r23, r15
    1b3a:	80 2f       	mov	r24, r16
    1b3c:	91 2f       	mov	r25, r17
    1b3e:	0f 2e       	mov	r0, r31
    1b40:	f3 e0       	ldi	r31, 0x03	; 3
    1b42:	af 2e       	mov	r10, r31
    1b44:	f0 2d       	mov	r31, r0
    1b46:	bb 24       	eor	r11, r11
    1b48:	cc 24       	eor	r12, r12
    1b4a:	dd 24       	eor	r13, r13
    1b4c:	ee 24       	eor	r14, r14
    1b4e:	ff 24       	eor	r15, r15
    1b50:	00 e0       	ldi	r16, 0x00	; 0
    1b52:	10 e0       	ldi	r17, 0x00	; 0
    1b54:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    1b58:	a2 2e       	mov	r10, r18
    1b5a:	b3 2e       	mov	r11, r19
    1b5c:	c4 2e       	mov	r12, r20
    1b5e:	d5 2e       	mov	r13, r21
    1b60:	e6 2e       	mov	r14, r22
    1b62:	f7 2e       	mov	r15, r23
    1b64:	08 2f       	mov	r16, r24
    1b66:	19 2f       	mov	r17, r25
    1b68:	2a 2d       	mov	r18, r10
    1b6a:	3b 2d       	mov	r19, r11
    1b6c:	4c 2d       	mov	r20, r12
    1b6e:	5d 2d       	mov	r21, r13
    1b70:	6e 2d       	mov	r22, r14
    1b72:	7f 2d       	mov	r23, r15
    1b74:	80 2f       	mov	r24, r16
    1b76:	91 2f       	mov	r25, r17
    1b78:	da 01       	movw	r26, r20
    1b7a:	c9 01       	movw	r24, r18
    1b7c:	b0 95       	com	r27
    1b7e:	a0 95       	com	r26
    1b80:	90 95       	com	r25
    1b82:	81 95       	neg	r24
    1b84:	9f 4f       	sbci	r25, 0xFF	; 255
    1b86:	af 4f       	sbci	r26, 0xFF	; 255
    1b88:	bf 4f       	sbci	r27, 0xFF	; 255
    1b8a:	2f a1       	lds	r18, 0x4f
    1b8c:	38 a5       	lds	r19, 0x68
    1b8e:	f9 01       	movw	r30, r18
    1b90:	80 83       	st	Z, r24
    1b92:	91 83       	std	Z+1, r25	; 0x01
    1b94:	a2 83       	std	Z+2, r26	; 0x02
    1b96:	b3 83       	std	Z+3, r27	; 0x03

}
    1b98:	ec 96       	adiw	r28, 0x3c	; 60
    1b9a:	cd bf       	out	0x3d, r28	; 61
    1b9c:	de bf       	out	0x3e, r29	; 62
    1b9e:	df 91       	pop	r29
    1ba0:	cf 91       	pop	r28
    1ba2:	1f 91       	pop	r17
    1ba4:	0f 91       	pop	r16
    1ba6:	ff 90       	pop	r15
    1ba8:	ef 90       	pop	r14
    1baa:	df 90       	pop	r13
    1bac:	cf 90       	pop	r12
    1bae:	bf 90       	pop	r11
    1bb0:	af 90       	pop	r10
    1bb2:	9f 90       	pop	r9
    1bb4:	8f 90       	pop	r8
    1bb6:	7f 90       	pop	r7
    1bb8:	6f 90       	pop	r6
    1bba:	5f 90       	pop	r5
    1bbc:	4f 90       	pop	r4
    1bbe:	3f 90       	pop	r3
    1bc0:	2f 90       	pop	r2
    1bc2:	08 95       	ret

00001bc4 <CO_collectADC_cont>:

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1bc4:	cf 93       	push	r28
    1bc6:	df 93       	push	r29
    1bc8:	00 d0       	rcall	.+0      	; 0x1bca <CO_collectADC_cont+0x6>
    1bca:	00 d0       	rcall	.+0      	; 0x1bcc <CO_collectADC_cont+0x8>
    1bcc:	cd b7       	in	r28, 0x3d	; 61
    1bce:	de b7       	in	r29, 0x3e	; 62
    1bd0:	8b 83       	std	Y+3, r24	; 0x03
    1bd2:	6c 83       	std	Y+4, r22	; 0x04
    1bd4:	4d 83       	std	Y+5, r20	; 0x05
    1bd6:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1bd8:	81 e0       	ldi	r24, 0x01	; 1
    1bda:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
//get data to write files to SD card
getBootSectorData();
    1bde:	0e 94 7c 41 	call	0x82f8	; 0x82f8 <getBootSectorData>
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1be2:	8b 81       	ldd	r24, Y+3	; 0x03
    1be4:	6d 81       	ldd	r22, Y+5	; 0x05
    1be6:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
set_filter(filterConfig);
    1bea:	8c 81       	ldd	r24, Y+4	; 0x04
    1bec:	0e 94 4f 08 	call	0x109e	; 0x109e <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf2:	85 30       	cpi	r24, 0x05	; 5
    1bf4:	31 f0       	breq	.+12     	; 0x1c02 <CO_collectADC_cont+0x3e>
    1bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf8:	86 30       	cpi	r24, 0x06	; 6
    1bfa:	19 f0       	breq	.+6      	; 0x1c02 <CO_collectADC_cont+0x3e>
    1bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfe:	87 30       	cpi	r24, 0x07	; 7
    1c00:	19 f4       	brne	.+6      	; 0x1c08 <CO_collectADC_cont+0x44>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1c02:	81 e0       	ldi	r24, 0x01	; 1
    1c04:	0e 94 29 11 	call	0x2252	; 0x2252 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1c08:	81 e0       	ldi	r24, 0x01	; 1
    1c0a:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
setADCInput(channel);
    1c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c10:	0e 94 55 1c 	call	0x38aa	; 0x38aa <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1c14:	84 e0       	ldi	r24, 0x04	; 4
    1c16:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1c1a:	80 ec       	ldi	r24, 0xC0	; 192
    1c1c:	98 e0       	ldi	r25, 0x08	; 8
    1c1e:	24 e5       	ldi	r18, 0x54	; 84
    1c20:	fc 01       	movw	r30, r24
    1c22:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1c24:	80 ea       	ldi	r24, 0xA0	; 160
    1c26:	96 e0       	ldi	r25, 0x06	; 6
    1c28:	21 e0       	ldi	r18, 0x01	; 1
    1c2a:	fc 01       	movw	r30, r24
    1c2c:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1c2e:	80 ea       	ldi	r24, 0xA0	; 160
    1c30:	96 e0       	ldi	r25, 0x06	; 6
    1c32:	22 e0       	ldi	r18, 0x02	; 2
    1c34:	fc 01       	movw	r30, r24
    1c36:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    1c38:	80 ea       	ldi	r24, 0xA0	; 160
    1c3a:	96 e0       	ldi	r25, 0x06	; 6
    1c3c:	21 e0       	ldi	r18, 0x01	; 1
    1c3e:	fc 01       	movw	r30, r24
    1c40:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_LO_gc;
    1c42:	80 ea       	ldi	r24, 0xA0	; 160
    1c44:	96 e0       	ldi	r25, 0x06	; 6
    1c46:	24 e0       	ldi	r18, 0x04	; 4
    1c48:	fc 01       	movw	r30, r24
    1c4a:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    1c4c:	80 e8       	ldi	r24, 0x80	; 128
    1c4e:	96 e0       	ldi	r25, 0x06	; 6
    1c50:	20 e2       	ldi	r18, 0x20	; 32
    1c52:	fc 01       	movw	r30, r24
    1c54:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1c56:	80 e4       	ldi	r24, 0x40	; 64
    1c58:	9a e0       	ldi	r25, 0x0A	; 10
    1c5a:	23 e2       	ldi	r18, 0x23	; 35
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1c60:	8e 81       	ldd	r24, Y+6	; 0x06
    1c62:	88 2f       	mov	r24, r24
    1c64:	90 e0       	ldi	r25, 0x00	; 0
    1c66:	25 e1       	ldi	r18, 0x15	; 21
    1c68:	30 e0       	ldi	r19, 0x00	; 0
    1c6a:	28 1b       	sub	r18, r24
    1c6c:	39 0b       	sbc	r19, r25
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	02 c0       	rjmp	.+4      	; 0x1c78 <CO_collectADC_cont+0xb4>
    1c74:	88 0f       	add	r24, r24
    1c76:	99 1f       	adc	r25, r25
    1c78:	2a 95       	dec	r18
    1c7a:	e2 f7       	brpl	.-8      	; 0x1c74 <CO_collectADC_cont+0xb0>
    1c7c:	01 97       	sbiw	r24, 0x01	; 1
    1c7e:	89 83       	std	Y+1, r24	; 0x01
    1c80:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1c82:	80 e4       	ldi	r24, 0x40	; 64
    1c84:	9a e0       	ldi	r25, 0x0A	; 10
    1c86:	29 81       	ldd	r18, Y+1	; 0x01
    1c88:	3a 81       	ldd	r19, Y+2	; 0x02
    1c8a:	fc 01       	movw	r30, r24
    1c8c:	26 a3       	lds	r18, 0x56
    1c8e:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1c90:	80 e4       	ldi	r24, 0x40	; 64
    1c92:	9a e0       	ldi	r25, 0x0A	; 10
    1c94:	29 81       	ldd	r18, Y+1	; 0x01
    1c96:	3a 81       	ldd	r19, Y+2	; 0x02
    1c98:	36 95       	lsr	r19
    1c9a:	27 95       	ror	r18
    1c9c:	fc 01       	movw	r30, r24
    1c9e:	22 af       	sts	0x72, r18
    1ca0:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1ca2:	80 e4       	ldi	r24, 0x40	; 64
    1ca4:	9a e0       	ldi	r25, 0x0A	; 10
    1ca6:	20 e4       	ldi	r18, 0x40	; 64
    1ca8:	3a e0       	ldi	r19, 0x0A	; 10
    1caa:	f9 01       	movw	r30, r18
    1cac:	20 81       	ld	r18, Z
    1cae:	20 7f       	andi	r18, 0xF0	; 240
    1cb0:	21 60       	ori	r18, 0x01	; 1
    1cb2:	fc 01       	movw	r30, r24
    1cb4:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1cb6:	80 ea       	ldi	r24, 0xA0	; 160
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	20 ea       	ldi	r18, 0xA0	; 160
    1cbc:	30 e0       	ldi	r19, 0x00	; 0
    1cbe:	f9 01       	movw	r30, r18
    1cc0:	22 81       	ldd	r18, Z+2	; 0x02
    1cc2:	21 60       	ori	r18, 0x01	; 1
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
chb_init();
    1cc8:	0e 94 38 20 	call	0x4070	; 0x4070 <chb_init>
chb_set_short_addr(moteID);
    1ccc:	80 91 cd 50 	lds	r24, 0x50CD
    1cd0:	88 2f       	mov	r24, r24
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <chb_set_short_addr>
sei();
    1cd8:	78 94       	sei

sampleCount = 0;
    1cda:	10 92 73 50 	sts	0x5073, r1
    1cde:	10 92 74 50 	sts	0x5074, r1
TotalSampleCount = 0;
    1ce2:	10 92 a1 50 	sts	0x50A1, r1
    1ce6:	10 92 a2 50 	sts	0x50A2, r1
discardCount = 0;
    1cea:	10 92 5e 40 	sts	0x405E, r1
}
    1cee:	26 96       	adiw	r28, 0x06	; 6
    1cf0:	cd bf       	out	0x3d, r28	; 61
    1cf2:	de bf       	out	0x3e, r29	; 62
    1cf4:	df 91       	pop	r29
    1cf6:	cf 91       	pop	r28
    1cf8:	08 95       	ret

00001cfa <ADC_Pause_Sampling>:


void ADC_Pause_Sampling(){
    1cfa:	cf 93       	push	r28
    1cfc:	df 93       	push	r29
    1cfe:	cd b7       	in	r28, 0x3d	; 61
    1d00:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1d02:	80 ea       	ldi	r24, 0xA0	; 160
    1d04:	96 e0       	ldi	r25, 0x06	; 6
    1d06:	fc 01       	movw	r30, r24
    1d08:	13 86       	std	Z+11, r1	; 0x0b
}
    1d0a:	df 91       	pop	r29
    1d0c:	cf 91       	pop	r28
    1d0e:	08 95       	ret

00001d10 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    1d10:	cf 93       	push	r28
    1d12:	df 93       	push	r29
    1d14:	cd b7       	in	r28, 0x3d	; 61
    1d16:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1d18:	80 ea       	ldi	r24, 0xA0	; 160
    1d1a:	96 e0       	ldi	r25, 0x06	; 6
    1d1c:	21 e0       	ldi	r18, 0x01	; 1
    1d1e:	fc 01       	movw	r30, r24
    1d20:	23 87       	std	Z+11, r18	; 0x0b
}	
    1d22:	df 91       	pop	r29
    1d24:	cf 91       	pop	r28
    1d26:	08 95       	ret

00001d28 <__vector_105>:
ISR(PORTF_INT1_vect) {
    1d28:	1f 92       	push	r1
    1d2a:	0f 92       	push	r0
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	0f 92       	push	r0
    1d30:	00 90 3b 00 	lds	r0, 0x003B
    1d34:	0f 92       	push	r0
    1d36:	11 24       	eor	r1, r1
    1d38:	2f 92       	push	r2
    1d3a:	3f 92       	push	r3
    1d3c:	4f 92       	push	r4
    1d3e:	5f 92       	push	r5
    1d40:	6f 92       	push	r6
    1d42:	7f 92       	push	r7
    1d44:	8f 92       	push	r8
    1d46:	9f 92       	push	r9
    1d48:	af 92       	push	r10
    1d4a:	bf 92       	push	r11
    1d4c:	cf 92       	push	r12
    1d4e:	df 92       	push	r13
    1d50:	ef 92       	push	r14
    1d52:	ff 92       	push	r15
    1d54:	0f 93       	push	r16
    1d56:	1f 93       	push	r17
    1d58:	2f 93       	push	r18
    1d5a:	3f 93       	push	r19
    1d5c:	4f 93       	push	r20
    1d5e:	5f 93       	push	r21
    1d60:	6f 93       	push	r22
    1d62:	7f 93       	push	r23
    1d64:	8f 93       	push	r24
    1d66:	9f 93       	push	r25
    1d68:	af 93       	push	r26
    1d6a:	bf 93       	push	r27
    1d6c:	ef 93       	push	r30
    1d6e:	ff 93       	push	r31
    1d70:	cf 93       	push	r28
    1d72:	df 93       	push	r29
    1d74:	00 d0       	rcall	.+0      	; 0x1d76 <__vector_105+0x4e>
    1d76:	cd b7       	in	r28, 0x3d	; 61
    1d78:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1d7a:	80 91 5e 40 	lds	r24, 0x405E
    1d7e:	88 23       	and	r24, r24
    1d80:	34 f0       	brlt	.+12     	; 0x1d8e <__vector_105+0x66>
		discardCount++;
    1d82:	80 91 5e 40 	lds	r24, 0x405E
    1d86:	8f 5f       	subi	r24, 0xFF	; 255
    1d88:	80 93 5e 40 	sts	0x405E, r24
    1d8c:	7b c1       	rjmp	.+758    	; 0x2084 <__vector_105+0x35c>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1d8e:	84 e0       	ldi	r24, 0x04	; 4
    1d90:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1d94:	80 ec       	ldi	r24, 0xC0	; 192
    1d96:	98 e0       	ldi	r25, 0x08	; 8
    1d98:	24 e5       	ldi	r18, 0x54	; 84
    1d9a:	fc 01       	movw	r30, r24
    1d9c:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
    1da0:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1da4:	80 ea       	ldi	r24, 0xA0	; 160
    1da6:	96 e0       	ldi	r25, 0x06	; 6
    1da8:	22 e0       	ldi	r18, 0x02	; 2
    1daa:	fc 01       	movw	r30, r24
    1dac:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1dae:	19 82       	std	Y+1, r1	; 0x01
    1db0:	1a c0       	rjmp	.+52     	; 0x1de6 <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1db2:	80 ec       	ldi	r24, 0xC0	; 192
    1db4:	98 e0       	ldi	r25, 0x08	; 8
    1db6:	2a ea       	ldi	r18, 0xAA	; 170
    1db8:	fc 01       	movw	r30, r24
    1dba:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1dbc:	00 00       	nop
    1dbe:	80 ec       	ldi	r24, 0xC0	; 192
    1dc0:	98 e0       	ldi	r25, 0x08	; 8
    1dc2:	fc 01       	movw	r30, r24
    1dc4:	82 81       	ldd	r24, Z+2	; 0x02
    1dc6:	88 23       	and	r24, r24
    1dc8:	d4 f7       	brge	.-12     	; 0x1dbe <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1dca:	89 81       	ldd	r24, Y+1	; 0x01
    1dcc:	88 2f       	mov	r24, r24
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	20 ec       	ldi	r18, 0xC0	; 192
    1dd2:	38 e0       	ldi	r19, 0x08	; 8
    1dd4:	f9 01       	movw	r30, r18
    1dd6:	23 81       	ldd	r18, Z+3	; 0x03
    1dd8:	8a 59       	subi	r24, 0x9A	; 154
    1dda:	9f 4a       	sbci	r25, 0xAF	; 175
    1ddc:	fc 01       	movw	r30, r24
    1dde:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1de0:	89 81       	ldd	r24, Y+1	; 0x01
    1de2:	8f 5f       	subi	r24, 0xFF	; 255
    1de4:	89 83       	std	Y+1, r24	; 0x01
    1de6:	89 81       	ldd	r24, Y+1	; 0x01
    1de8:	83 30       	cpi	r24, 0x03	; 3
    1dea:	18 f3       	brcs	.-58     	; 0x1db2 <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1dec:	80 ea       	ldi	r24, 0xA0	; 160
    1dee:	96 e0       	ldi	r25, 0x06	; 6
    1df0:	22 e0       	ldi	r18, 0x02	; 2
    1df2:	fc 01       	movw	r30, r24
    1df4:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1df6:	80 e0       	ldi	r24, 0x00	; 0
    1df8:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1dfc:	80 91 66 50 	lds	r24, 0x5066
    1e00:	88 23       	and	r24, r24
    1e02:	34 f4       	brge	.+12     	; 0x1e10 <__vector_105+0xe8>
    1e04:	87 e6       	ldi	r24, 0x67	; 103
    1e06:	90 e4       	ldi	r25, 0x40	; 64
    1e08:	2f ef       	ldi	r18, 0xFF	; 255
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	20 83       	st	Z, r18
    1e0e:	04 c0       	rjmp	.+8      	; 0x1e18 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    1e10:	87 e6       	ldi	r24, 0x67	; 103
    1e12:	90 e4       	ldi	r25, 0x40	; 64
    1e14:	fc 01       	movw	r30, r24
    1e16:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1e18:	86 e6       	ldi	r24, 0x66	; 102
    1e1a:	90 e4       	ldi	r25, 0x40	; 64
    1e1c:	20 91 66 50 	lds	r18, 0x5066
    1e20:	fc 01       	movw	r30, r24
    1e22:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1e24:	85 e6       	ldi	r24, 0x65	; 101
    1e26:	90 e4       	ldi	r25, 0x40	; 64
    1e28:	20 91 67 50 	lds	r18, 0x5067
    1e2c:	fc 01       	movw	r30, r24
    1e2e:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    1e30:	84 e6       	ldi	r24, 0x64	; 100
    1e32:	90 e4       	ldi	r25, 0x40	; 64
    1e34:	20 91 68 50 	lds	r18, 0x5068
    1e38:	fc 01       	movw	r30, r24
    1e3a:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    1e3c:	80 91 64 40 	lds	r24, 0x4064
    1e40:	90 91 65 40 	lds	r25, 0x4065
    1e44:	a0 91 66 40 	lds	r26, 0x4066
    1e48:	b0 91 67 40 	lds	r27, 0x4067
    1e4c:	5c 01       	movw	r10, r24
    1e4e:	6d 01       	movw	r12, r26
    1e50:	bb 0f       	add	r27, r27
    1e52:	88 0b       	sbc	r24, r24
    1e54:	98 2f       	mov	r25, r24
    1e56:	dc 01       	movw	r26, r24
    1e58:	e8 2e       	mov	r14, r24
    1e5a:	f8 2e       	mov	r15, r24
    1e5c:	08 2f       	mov	r16, r24
    1e5e:	18 2f       	mov	r17, r24
    1e60:	a0 92 a3 50 	sts	0x50A3, r10
    1e64:	b0 92 a4 50 	sts	0x50A4, r11
    1e68:	c0 92 a5 50 	sts	0x50A5, r12
    1e6c:	d0 92 a6 50 	sts	0x50A6, r13
    1e70:	e0 92 a7 50 	sts	0x50A7, r14
    1e74:	f0 92 a8 50 	sts	0x50A8, r15
    1e78:	00 93 a9 50 	sts	0x50A9, r16
    1e7c:	10 93 aa 50 	sts	0x50AA, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1e80:	80 91 73 50 	lds	r24, 0x5073
    1e84:	90 91 74 50 	lds	r25, 0x5074
    1e88:	88 0f       	add	r24, r24
    1e8a:	99 1f       	adc	r25, r25
    1e8c:	88 0f       	add	r24, r24
    1e8e:	99 1f       	adc	r25, r25
    1e90:	9c 01       	movw	r18, r24
    1e92:	20 52       	subi	r18, 0x20	; 32
    1e94:	3c 4d       	sbci	r19, 0xDC	; 220
    1e96:	2a 83       	std	Y+2, r18	; 0x02
    1e98:	3b 83       	std	Y+3, r19	; 0x03
    1e9a:	a0 90 a3 50 	lds	r10, 0x50A3
    1e9e:	b0 90 a4 50 	lds	r11, 0x50A4
    1ea2:	c0 90 a5 50 	lds	r12, 0x50A5
    1ea6:	d0 90 a6 50 	lds	r13, 0x50A6
    1eaa:	e0 90 a7 50 	lds	r14, 0x50A7
    1eae:	f0 90 a8 50 	lds	r15, 0x50A8
    1eb2:	00 91 a9 50 	lds	r16, 0x50A9
    1eb6:	10 91 aa 50 	lds	r17, 0x50AA
    1eba:	2a 2d       	mov	r18, r10
    1ebc:	3b 2d       	mov	r19, r11
    1ebe:	4c 2d       	mov	r20, r12
    1ec0:	5d 2d       	mov	r21, r13
    1ec2:	6e 2d       	mov	r22, r14
    1ec4:	7f 2d       	mov	r23, r15
    1ec6:	80 2f       	mov	r24, r16
    1ec8:	91 2f       	mov	r25, r17
    1eca:	0f 2e       	mov	r0, r31
    1ecc:	f0 ea       	ldi	r31, 0xA0	; 160
    1ece:	af 2e       	mov	r10, r31
    1ed0:	f0 2d       	mov	r31, r0
    1ed2:	0f 2e       	mov	r0, r31
    1ed4:	f5 e2       	ldi	r31, 0x25	; 37
    1ed6:	bf 2e       	mov	r11, r31
    1ed8:	f0 2d       	mov	r31, r0
    1eda:	0f 2e       	mov	r0, r31
    1edc:	f6 e2       	ldi	r31, 0x26	; 38
    1ede:	cf 2e       	mov	r12, r31
    1ee0:	f0 2d       	mov	r31, r0
    1ee2:	dd 24       	eor	r13, r13
    1ee4:	ee 24       	eor	r14, r14
    1ee6:	ff 24       	eor	r15, r15
    1ee8:	00 e0       	ldi	r16, 0x00	; 0
    1eea:	10 e0       	ldi	r17, 0x00	; 0
    1eec:	0e 94 93 53 	call	0xa726	; 0xa726 <__muldi3>
    1ef0:	22 2e       	mov	r2, r18
    1ef2:	33 2e       	mov	r3, r19
    1ef4:	44 2e       	mov	r4, r20
    1ef6:	55 2e       	mov	r5, r21
    1ef8:	66 2e       	mov	r6, r22
    1efa:	77 2e       	mov	r7, r23
    1efc:	88 2e       	mov	r8, r24
    1efe:	99 2e       	mov	r9, r25
    1f00:	a2 2c       	mov	r10, r2
    1f02:	b3 2c       	mov	r11, r3
    1f04:	c4 2c       	mov	r12, r4
    1f06:	d5 2c       	mov	r13, r5
    1f08:	e6 2c       	mov	r14, r6
    1f0a:	f7 2c       	mov	r15, r7
    1f0c:	08 2d       	mov	r16, r8
    1f0e:	19 2d       	mov	r17, r9
    1f10:	2a 2d       	mov	r18, r10
    1f12:	3b 2d       	mov	r19, r11
    1f14:	4c 2d       	mov	r20, r12
    1f16:	5d 2d       	mov	r21, r13
    1f18:	6e 2d       	mov	r22, r14
    1f1a:	7f 2d       	mov	r23, r15
    1f1c:	80 2f       	mov	r24, r16
    1f1e:	91 2f       	mov	r25, r17
    1f20:	aa 24       	eor	r10, r10
    1f22:	aa 94       	dec	r10
    1f24:	bb 24       	eor	r11, r11
    1f26:	ba 94       	dec	r11
    1f28:	0f 2e       	mov	r0, r31
    1f2a:	ff e7       	ldi	r31, 0x7F	; 127
    1f2c:	cf 2e       	mov	r12, r31
    1f2e:	f0 2d       	mov	r31, r0
    1f30:	dd 24       	eor	r13, r13
    1f32:	ee 24       	eor	r14, r14
    1f34:	ff 24       	eor	r15, r15
    1f36:	00 e0       	ldi	r16, 0x00	; 0
    1f38:	10 e0       	ldi	r17, 0x00	; 0
    1f3a:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    1f3e:	22 2e       	mov	r2, r18
    1f40:	33 2e       	mov	r3, r19
    1f42:	44 2e       	mov	r4, r20
    1f44:	55 2e       	mov	r5, r21
    1f46:	66 2e       	mov	r6, r22
    1f48:	77 2e       	mov	r7, r23
    1f4a:	88 2e       	mov	r8, r24
    1f4c:	99 2e       	mov	r9, r25
    1f4e:	a2 2c       	mov	r10, r2
    1f50:	b3 2c       	mov	r11, r3
    1f52:	c4 2c       	mov	r12, r4
    1f54:	d5 2c       	mov	r13, r5
    1f56:	e6 2c       	mov	r14, r6
    1f58:	f7 2c       	mov	r15, r7
    1f5a:	08 2d       	mov	r16, r8
    1f5c:	19 2d       	mov	r17, r9
    1f5e:	2a 2d       	mov	r18, r10
    1f60:	3b 2d       	mov	r19, r11
    1f62:	4c 2d       	mov	r20, r12
    1f64:	5d 2d       	mov	r21, r13
    1f66:	6e 2d       	mov	r22, r14
    1f68:	7f 2d       	mov	r23, r15
    1f6a:	80 2f       	mov	r24, r16
    1f6c:	91 2f       	mov	r25, r17
    1f6e:	01 e0       	ldi	r16, 0x01	; 1
    1f70:	0e 94 66 54 	call	0xa8cc	; 0xa8cc <__ashldi3>
    1f74:	22 2e       	mov	r2, r18
    1f76:	33 2e       	mov	r3, r19
    1f78:	44 2e       	mov	r4, r20
    1f7a:	55 2e       	mov	r5, r21
    1f7c:	66 2e       	mov	r6, r22
    1f7e:	77 2e       	mov	r7, r23
    1f80:	88 2e       	mov	r8, r24
    1f82:	99 2e       	mov	r9, r25
    1f84:	a2 2c       	mov	r10, r2
    1f86:	b3 2c       	mov	r11, r3
    1f88:	c4 2c       	mov	r12, r4
    1f8a:	d5 2c       	mov	r13, r5
    1f8c:	e6 2c       	mov	r14, r6
    1f8e:	f7 2c       	mov	r15, r7
    1f90:	08 2d       	mov	r16, r8
    1f92:	19 2d       	mov	r17, r9
    1f94:	2a 2d       	mov	r18, r10
    1f96:	3b 2d       	mov	r19, r11
    1f98:	4c 2d       	mov	r20, r12
    1f9a:	5d 2d       	mov	r21, r13
    1f9c:	6e 2d       	mov	r22, r14
    1f9e:	7f 2d       	mov	r23, r15
    1fa0:	80 2f       	mov	r24, r16
    1fa2:	91 2f       	mov	r25, r17
    1fa4:	0f 2e       	mov	r0, r31
    1fa6:	f3 e0       	ldi	r31, 0x03	; 3
    1fa8:	af 2e       	mov	r10, r31
    1faa:	f0 2d       	mov	r31, r0
    1fac:	bb 24       	eor	r11, r11
    1fae:	cc 24       	eor	r12, r12
    1fb0:	dd 24       	eor	r13, r13
    1fb2:	ee 24       	eor	r14, r14
    1fb4:	ff 24       	eor	r15, r15
    1fb6:	00 e0       	ldi	r16, 0x00	; 0
    1fb8:	10 e0       	ldi	r17, 0x00	; 0
    1fba:	0e 94 42 55 	call	0xaa84	; 0xaa84 <__divdi3>
    1fbe:	a2 2e       	mov	r10, r18
    1fc0:	b3 2e       	mov	r11, r19
    1fc2:	c4 2e       	mov	r12, r20
    1fc4:	d5 2e       	mov	r13, r21
    1fc6:	e6 2e       	mov	r14, r22
    1fc8:	f7 2e       	mov	r15, r23
    1fca:	08 2f       	mov	r16, r24
    1fcc:	19 2f       	mov	r17, r25
    1fce:	2a 2d       	mov	r18, r10
    1fd0:	3b 2d       	mov	r19, r11
    1fd2:	4c 2d       	mov	r20, r12
    1fd4:	5d 2d       	mov	r21, r13
    1fd6:	6e 2d       	mov	r22, r14
    1fd8:	7f 2d       	mov	r23, r15
    1fda:	80 2f       	mov	r24, r16
    1fdc:	91 2f       	mov	r25, r17
    1fde:	da 01       	movw	r26, r20
    1fe0:	c9 01       	movw	r24, r18
    1fe2:	b0 95       	com	r27
    1fe4:	a0 95       	com	r26
    1fe6:	90 95       	com	r25
    1fe8:	81 95       	neg	r24
    1fea:	9f 4f       	sbci	r25, 0xFF	; 255
    1fec:	af 4f       	sbci	r26, 0xFF	; 255
    1fee:	bf 4f       	sbci	r27, 0xFF	; 255
    1ff0:	ea 81       	ldd	r30, Y+2	; 0x02
    1ff2:	fb 81       	ldd	r31, Y+3	; 0x03
    1ff4:	80 83       	st	Z, r24
    1ff6:	91 83       	std	Z+1, r25	; 0x01
    1ff8:	a2 83       	std	Z+2, r26	; 0x02
    1ffa:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    1ffc:	80 91 73 50 	lds	r24, 0x5073
    2000:	90 91 74 50 	lds	r25, 0x5074
    2004:	01 96       	adiw	r24, 0x01	; 1
    2006:	80 93 73 50 	sts	0x5073, r24
    200a:	90 93 74 50 	sts	0x5074, r25
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    200e:	80 91 73 50 	lds	r24, 0x5073
    2012:	90 91 74 50 	lds	r25, 0x5074
    2016:	8e 31       	cpi	r24, 0x1E	; 30
    2018:	91 05       	cpc	r25, r1
    201a:	a0 f1       	brcs	.+104    	; 0x2084 <__vector_105+0x35c>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    201c:	10 92 73 50 	sts	0x5073, r1
    2020:	10 92 74 50 	sts	0x5074, r1
		TotalSampleCount++;
    2024:	80 91 a1 50 	lds	r24, 0x50A1
    2028:	90 91 a2 50 	lds	r25, 0x50A2
    202c:	01 96       	adiw	r24, 0x01	; 1
    202e:	80 93 a1 50 	sts	0x50A1, r24
    2032:	90 93 a2 50 	sts	0x50A2, r25
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove(FRAMReadBuffer+1,FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    2036:	80 91 73 50 	lds	r24, 0x5073
    203a:	90 91 74 50 	lds	r25, 0x5074
    203e:	9c 01       	movw	r18, r24
    2040:	22 0f       	add	r18, r18
    2042:	33 1f       	adc	r19, r19
    2044:	22 0f       	add	r18, r18
    2046:	33 1f       	adc	r19, r19
    2048:	81 ee       	ldi	r24, 0xE1	; 225
    204a:	93 e2       	ldi	r25, 0x23	; 35
    204c:	40 ee       	ldi	r20, 0xE0	; 224
    204e:	53 e2       	ldi	r21, 0x23	; 35
    2050:	ba 01       	movw	r22, r20
    2052:	a9 01       	movw	r20, r18
    2054:	0e 94 2d 5f 	call	0xbe5a	; 0xbe5a <memcpy>
		FRAMReadBuffer[0] = moteID;
    2058:	80 91 cd 50 	lds	r24, 0x50CD
    205c:	80 93 e0 23 	sts	0x23E0, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+1);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    2060:	80 91 73 50 	lds	r24, 0x5073
    2064:	90 91 74 50 	lds	r25, 0x5074
    2068:	88 0f       	add	r24, r24
    206a:	99 1f       	adc	r25, r25
    206c:	88 0f       	add	r24, r24
    206e:	99 1f       	adc	r25, r25
    2070:	01 96       	adiw	r24, 0x01	; 1
    2072:	9c 01       	movw	r18, r24
    2074:	40 e0       	ldi	r20, 0x00	; 0
    2076:	50 e0       	ldi	r21, 0x00	; 0
    2078:	60 ee       	ldi	r22, 0xE0	; 224
    207a:	73 e2       	ldi	r23, 0x23	; 35
    207c:	80 e0       	ldi	r24, 0x00	; 0
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	0e 94 ff 20 	call	0x41fe	; 0x41fe <chb_write>
	}	
	}	
}
    2084:	23 96       	adiw	r28, 0x03	; 3
    2086:	cd bf       	out	0x3d, r28	; 61
    2088:	de bf       	out	0x3e, r29	; 62
    208a:	df 91       	pop	r29
    208c:	cf 91       	pop	r28
    208e:	ff 91       	pop	r31
    2090:	ef 91       	pop	r30
    2092:	bf 91       	pop	r27
    2094:	af 91       	pop	r26
    2096:	9f 91       	pop	r25
    2098:	8f 91       	pop	r24
    209a:	7f 91       	pop	r23
    209c:	6f 91       	pop	r22
    209e:	5f 91       	pop	r21
    20a0:	4f 91       	pop	r20
    20a2:	3f 91       	pop	r19
    20a4:	2f 91       	pop	r18
    20a6:	1f 91       	pop	r17
    20a8:	0f 91       	pop	r16
    20aa:	ff 90       	pop	r15
    20ac:	ef 90       	pop	r14
    20ae:	df 90       	pop	r13
    20b0:	cf 90       	pop	r12
    20b2:	bf 90       	pop	r11
    20b4:	af 90       	pop	r10
    20b6:	9f 90       	pop	r9
    20b8:	8f 90       	pop	r8
    20ba:	7f 90       	pop	r7
    20bc:	6f 90       	pop	r6
    20be:	5f 90       	pop	r5
    20c0:	4f 90       	pop	r4
    20c2:	3f 90       	pop	r3
    20c4:	2f 90       	pop	r2
    20c6:	0f 90       	pop	r0
    20c8:	00 92 3b 00 	sts	0x003B, r0
    20cc:	0f 90       	pop	r0
    20ce:	0f be       	out	0x3f, r0	; 63
    20d0:	0f 90       	pop	r0
    20d2:	1f 90       	pop	r1
    20d4:	18 95       	reti

000020d6 <__vector_104>:

ISR(PORTF_INT0_vect) {
    20d6:	1f 92       	push	r1
    20d8:	0f 92       	push	r0
    20da:	0f b6       	in	r0, 0x3f	; 63
    20dc:	0f 92       	push	r0
    20de:	00 90 3b 00 	lds	r0, 0x003B
    20e2:	0f 92       	push	r0
    20e4:	11 24       	eor	r1, r1
    20e6:	2f 93       	push	r18
    20e8:	3f 93       	push	r19
    20ea:	4f 93       	push	r20
    20ec:	5f 93       	push	r21
    20ee:	6f 93       	push	r22
    20f0:	7f 93       	push	r23
    20f2:	8f 93       	push	r24
    20f4:	9f 93       	push	r25
    20f6:	af 93       	push	r26
    20f8:	bf 93       	push	r27
    20fa:	ef 93       	push	r30
    20fc:	ff 93       	push	r31
    20fe:	cf 93       	push	r28
    2100:	df 93       	push	r29
    2102:	0f 92       	push	r0
    2104:	cd b7       	in	r28, 0x3d	; 61
    2106:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    2108:	80 91 5e 40 	lds	r24, 0x405E
    210c:	88 23       	and	r24, r24
    210e:	34 f0       	brlt	.+12     	; 0x211c <__vector_104+0x46>
		discardCount++;
    2110:	80 91 5e 40 	lds	r24, 0x405E
    2114:	8f 5f       	subi	r24, 0xFF	; 255
    2116:	80 93 5e 40 	sts	0x405E, r24
    211a:	84 c0       	rjmp	.+264    	; 0x2224 <__vector_104+0x14e>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2122:	80 ea       	ldi	r24, 0xA0	; 160
    2124:	96 e0       	ldi	r25, 0x06	; 6
    2126:	22 e0       	ldi	r18, 0x02	; 2
    2128:	fc 01       	movw	r30, r24
    212a:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    212c:	19 82       	std	Y+1, r1	; 0x01
    212e:	1a c0       	rjmp	.+52     	; 0x2164 <__vector_104+0x8e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2130:	80 ec       	ldi	r24, 0xC0	; 192
    2132:	98 e0       	ldi	r25, 0x08	; 8
    2134:	2a ea       	ldi	r18, 0xAA	; 170
    2136:	fc 01       	movw	r30, r24
    2138:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    213a:	00 00       	nop
    213c:	80 ec       	ldi	r24, 0xC0	; 192
    213e:	98 e0       	ldi	r25, 0x08	; 8
    2140:	fc 01       	movw	r30, r24
    2142:	82 81       	ldd	r24, Z+2	; 0x02
    2144:	88 23       	and	r24, r24
    2146:	d4 f7       	brge	.-12     	; 0x213c <__vector_104+0x66>
			SPIBuffer[bufIndex] = SPIC.DATA;
    2148:	89 81       	ldd	r24, Y+1	; 0x01
    214a:	88 2f       	mov	r24, r24
    214c:	90 e0       	ldi	r25, 0x00	; 0
    214e:	20 ec       	ldi	r18, 0xC0	; 192
    2150:	38 e0       	ldi	r19, 0x08	; 8
    2152:	f9 01       	movw	r30, r18
    2154:	23 81       	ldd	r18, Z+3	; 0x03
    2156:	8a 59       	subi	r24, 0x9A	; 154
    2158:	9f 4a       	sbci	r25, 0xAF	; 175
    215a:	fc 01       	movw	r30, r24
    215c:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    215e:	89 81       	ldd	r24, Y+1	; 0x01
    2160:	8f 5f       	subi	r24, 0xFF	; 255
    2162:	89 83       	std	Y+1, r24	; 0x01
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	83 30       	cpi	r24, 0x03	; 3
    2168:	18 f3       	brcs	.-58     	; 0x2130 <__vector_104+0x5a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    216a:	80 ea       	ldi	r24, 0xA0	; 160
    216c:	96 e0       	ldi	r25, 0x06	; 6
    216e:	22 e0       	ldi	r18, 0x02	; 2
    2170:	fc 01       	movw	r30, r24
    2172:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    2174:	80 e0       	ldi	r24, 0x00	; 0
    2176:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    217a:	80 91 66 50 	lds	r24, 0x5066
    217e:	88 23       	and	r24, r24
    2180:	7c f4       	brge	.+30     	; 0x21a0 <__vector_104+0xca>
    2182:	80 91 73 50 	lds	r24, 0x5073
    2186:	90 91 74 50 	lds	r25, 0x5074
    218a:	88 0f       	add	r24, r24
    218c:	99 1f       	adc	r25, r25
    218e:	88 0f       	add	r24, r24
    2190:	99 1f       	adc	r25, r25
    2192:	03 96       	adiw	r24, 0x03	; 3
    2194:	8c 59       	subi	r24, 0x9C	; 156
    2196:	9f 4b       	sbci	r25, 0xBF	; 191
    2198:	2f ef       	ldi	r18, 0xFF	; 255
    219a:	fc 01       	movw	r30, r24
    219c:	20 83       	st	Z, r18
    219e:	0d c0       	rjmp	.+26     	; 0x21ba <__vector_104+0xe4>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    21a0:	80 91 73 50 	lds	r24, 0x5073
    21a4:	90 91 74 50 	lds	r25, 0x5074
    21a8:	88 0f       	add	r24, r24
    21aa:	99 1f       	adc	r25, r25
    21ac:	88 0f       	add	r24, r24
    21ae:	99 1f       	adc	r25, r25
    21b0:	03 96       	adiw	r24, 0x03	; 3
    21b2:	8c 59       	subi	r24, 0x9C	; 156
    21b4:	9f 4b       	sbci	r25, 0xBF	; 191
    21b6:	fc 01       	movw	r30, r24
    21b8:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    21ba:	80 91 73 50 	lds	r24, 0x5073
    21be:	90 91 74 50 	lds	r25, 0x5074
    21c2:	88 0f       	add	r24, r24
    21c4:	99 1f       	adc	r25, r25
    21c6:	88 0f       	add	r24, r24
    21c8:	99 1f       	adc	r25, r25
    21ca:	02 96       	adiw	r24, 0x02	; 2
    21cc:	8c 59       	subi	r24, 0x9C	; 156
    21ce:	9f 4b       	sbci	r25, 0xBF	; 191
    21d0:	20 91 66 50 	lds	r18, 0x5066
    21d4:	fc 01       	movw	r30, r24
    21d6:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    21d8:	80 91 73 50 	lds	r24, 0x5073
    21dc:	90 91 74 50 	lds	r25, 0x5074
    21e0:	88 0f       	add	r24, r24
    21e2:	99 1f       	adc	r25, r25
    21e4:	88 0f       	add	r24, r24
    21e6:	99 1f       	adc	r25, r25
    21e8:	01 96       	adiw	r24, 0x01	; 1
    21ea:	8c 59       	subi	r24, 0x9C	; 156
    21ec:	9f 4b       	sbci	r25, 0xBF	; 191
    21ee:	20 91 67 50 	lds	r18, 0x5067
    21f2:	fc 01       	movw	r30, r24
    21f4:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    21f6:	80 91 73 50 	lds	r24, 0x5073
    21fa:	90 91 74 50 	lds	r25, 0x5074
    21fe:	88 0f       	add	r24, r24
    2200:	99 1f       	adc	r25, r25
    2202:	88 0f       	add	r24, r24
    2204:	99 1f       	adc	r25, r25
    2206:	8c 59       	subi	r24, 0x9C	; 156
    2208:	9f 4b       	sbci	r25, 0xBF	; 191
    220a:	20 91 68 50 	lds	r18, 0x5068
    220e:	fc 01       	movw	r30, r24
    2210:	20 83       	st	Z, r18

		sampleCount++;
    2212:	80 91 73 50 	lds	r24, 0x5073
    2216:	90 91 74 50 	lds	r25, 0x5074
    221a:	01 96       	adiw	r24, 0x01	; 1
    221c:	80 93 73 50 	sts	0x5073, r24
    2220:	90 93 74 50 	sts	0x5074, r25
	}
}
    2224:	0f 90       	pop	r0
    2226:	df 91       	pop	r29
    2228:	cf 91       	pop	r28
    222a:	ff 91       	pop	r31
    222c:	ef 91       	pop	r30
    222e:	bf 91       	pop	r27
    2230:	af 91       	pop	r26
    2232:	9f 91       	pop	r25
    2234:	8f 91       	pop	r24
    2236:	7f 91       	pop	r23
    2238:	6f 91       	pop	r22
    223a:	5f 91       	pop	r21
    223c:	4f 91       	pop	r20
    223e:	3f 91       	pop	r19
    2240:	2f 91       	pop	r18
    2242:	0f 90       	pop	r0
    2244:	00 92 3b 00 	sts	0x003B, r0
    2248:	0f 90       	pop	r0
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	0f 90       	pop	r0
    224e:	1f 90       	pop	r1
    2250:	18 95       	reti

00002252 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    2252:	cf 93       	push	r28
    2254:	df 93       	push	r29
    2256:	0f 92       	push	r0
    2258:	cd b7       	in	r28, 0x3d	; 61
    225a:	de b7       	in	r29, 0x3e	; 62
    225c:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    225e:	89 81       	ldd	r24, Y+1	; 0x01
    2260:	88 23       	and	r24, r24
    2262:	49 f0       	breq	.+18     	; 0x2276 <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    2264:	80 e2       	ldi	r24, 0x20	; 32
    2266:	60 e0       	ldi	r22, 0x00	; 0
    2268:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    226c:	80 e2       	ldi	r24, 0x20	; 32
    226e:	60 e0       	ldi	r22, 0x00	; 0
    2270:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
    2274:	04 c0       	rjmp	.+8      	; 0x227e <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    2276:	80 e2       	ldi	r24, 0x20	; 32
    2278:	60 e0       	ldi	r22, 0x00	; 0
    227a:	0e 94 79 35 	call	0x6af2	; 0x6af2 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    227e:	0f 90       	pop	r0
    2280:	df 91       	pop	r29
    2282:	cf 91       	pop	r28
    2284:	08 95       	ret

00002286 <CO_collectSeismic3Channel>:

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    2286:	8f 92       	push	r8
    2288:	9f 92       	push	r9
    228a:	af 92       	push	r10
    228c:	bf 92       	push	r11
    228e:	cf 92       	push	r12
    2290:	df 92       	push	r13
    2292:	ef 92       	push	r14
    2294:	ff 92       	push	r15
    2296:	0f 93       	push	r16
    2298:	cf 93       	push	r28
    229a:	df 93       	push	r29
    229c:	cd b7       	in	r28, 0x3d	; 61
    229e:	de b7       	in	r29, 0x3e	; 62
    22a0:	2e 97       	sbiw	r28, 0x0e	; 14
    22a2:	cd bf       	out	0x3d, r28	; 61
    22a4:	de bf       	out	0x3e, r29	; 62
    22a6:	89 83       	std	Y+1, r24	; 0x01
    22a8:	6a 83       	std	Y+2, r22	; 0x02
    22aa:	7b 83       	std	Y+3, r23	; 0x03
    22ac:	4c 83       	std	Y+4, r20	; 0x04
    22ae:	2d 83       	std	Y+5, r18	; 0x05
    22b0:	0e 83       	std	Y+6, r16	; 0x06
    22b2:	ef 82       	std	Y+7, r14	; 0x07
    22b4:	f8 86       	std	Y+8, r15	; 0x08
    22b6:	c9 86       	std	Y+9, r12	; 0x09
    22b8:	da 86       	std	Y+10, r13	; 0x0a
    22ba:	ab 86       	std	Y+11, r10	; 0x0b
    22bc:	bc 86       	std	Y+12, r11	; 0x0c
    22be:	8d 86       	std	Y+13, r8	; 0x0d
    22c0:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    22c8:	8a 81       	ldd	r24, Y+2	; 0x02
    22ca:	9b 81       	ldd	r25, Y+3	; 0x03
    22cc:	fc 01       	movw	r30, r24
    22ce:	90 81       	ld	r25, Z
    22d0:	85 e0       	ldi	r24, 0x05	; 5
    22d2:	69 2f       	mov	r22, r25
    22d4:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    22d8:	8a 81       	ldd	r24, Y+2	; 0x02
    22da:	9b 81       	ldd	r25, Y+3	; 0x03
    22dc:	01 96       	adiw	r24, 0x01	; 1
    22de:	fc 01       	movw	r30, r24
    22e0:	90 81       	ld	r25, Z
    22e2:	86 e0       	ldi	r24, 0x06	; 6
    22e4:	69 2f       	mov	r22, r25
    22e6:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    22ea:	8a 81       	ldd	r24, Y+2	; 0x02
    22ec:	9b 81       	ldd	r25, Y+3	; 0x03
    22ee:	02 96       	adiw	r24, 0x02	; 2
    22f0:	fc 01       	movw	r30, r24
    22f2:	90 81       	ld	r25, Z
    22f4:	87 e0       	ldi	r24, 0x07	; 7
    22f6:	69 2f       	mov	r22, r25
    22f8:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_filter(filterConfig);
    22fc:	89 81       	ldd	r24, Y+1	; 0x01
    22fe:	0e 94 4f 08 	call	0x109e	; 0x109e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2302:	8e 81       	ldd	r24, Y+6	; 0x06
    2304:	0e 94 29 11 	call	0x2252	; 0x2252 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2308:	84 e0       	ldi	r24, 0x04	; 4
    230a:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    230e:	80 ec       	ldi	r24, 0xC0	; 192
    2310:	98 e0       	ldi	r25, 0x08	; 8
    2312:	24 e5       	ldi	r18, 0x54	; 84
    2314:	fc 01       	movw	r30, r24
    2316:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2318:	81 e0       	ldi	r24, 0x01	; 1
    231a:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    231e:	85 e0       	ldi	r24, 0x05	; 5
    2320:	0e 94 55 1c 	call	0x38aa	; 0x38aa <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2324:	80 ea       	ldi	r24, 0xA0	; 160
    2326:	96 e0       	ldi	r25, 0x06	; 6
    2328:	22 e0       	ldi	r18, 0x02	; 2
    232a:	fc 01       	movw	r30, r24
    232c:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    232e:	80 ea       	ldi	r24, 0xA0	; 160
    2330:	96 e0       	ldi	r25, 0x06	; 6
    2332:	21 e0       	ldi	r18, 0x01	; 1
    2334:	fc 01       	movw	r30, r24
    2336:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2338:	80 e8       	ldi	r24, 0x80	; 128
    233a:	91 e0       	ldi	r25, 0x01	; 1
    233c:	28 e7       	ldi	r18, 0x78	; 120
    233e:	fc 01       	movw	r30, r24
    2340:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2342:	80 e0       	ldi	r24, 0x00	; 0
    2344:	98 e0       	ldi	r25, 0x08	; 8
    2346:	20 ef       	ldi	r18, 0xF0	; 240
    2348:	fc 01       	movw	r30, r24
    234a:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    234c:	80 e0       	ldi	r24, 0x00	; 0
    234e:	98 e0       	ldi	r25, 0x08	; 8
    2350:	2f 81       	ldd	r18, Y+7	; 0x07
    2352:	38 85       	ldd	r19, Y+8	; 0x08
    2354:	fc 01       	movw	r30, r24
    2356:	20 a7       	lds	r18, 0x70
    2358:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    235a:	80 e0       	ldi	r24, 0x00	; 0
    235c:	98 e0       	ldi	r25, 0x08	; 8
    235e:	29 85       	ldd	r18, Y+9	; 0x09
    2360:	3a 85       	ldd	r19, Y+10	; 0x0a
    2362:	fc 01       	movw	r30, r24
    2364:	22 a7       	lds	r18, 0x72
    2366:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    2368:	80 e0       	ldi	r24, 0x00	; 0
    236a:	98 e0       	ldi	r25, 0x08	; 8
    236c:	2b 85       	ldd	r18, Y+11	; 0x0b
    236e:	3c 85       	ldd	r19, Y+12	; 0x0c
    2370:	fc 01       	movw	r30, r24
    2372:	24 a7       	lds	r18, 0x74
    2374:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    2376:	80 e0       	ldi	r24, 0x00	; 0
    2378:	98 e0       	ldi	r25, 0x08	; 8
    237a:	2d 85       	ldd	r18, Y+13	; 0x0d
    237c:	3e 85       	ldd	r19, Y+14	; 0x0e
    237e:	fc 01       	movw	r30, r24
    2380:	26 a7       	lds	r18, 0x76
    2382:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    2384:	80 e0       	ldi	r24, 0x00	; 0
    2386:	98 e0       	ldi	r25, 0x08	; 8
    2388:	2d 81       	ldd	r18, Y+5	; 0x05
    238a:	22 2f       	mov	r18, r18
    238c:	30 e0       	ldi	r19, 0x00	; 0
    238e:	21 50       	subi	r18, 0x01	; 1
    2390:	30 40       	sbci	r19, 0x00	; 0
    2392:	fc 01       	movw	r30, r24
    2394:	26 a3       	lds	r18, 0x56
    2396:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	98 e0       	ldi	r25, 0x08	; 8
    239c:	22 e0       	ldi	r18, 0x02	; 2
    239e:	fc 01       	movw	r30, r24
    23a0:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    23a2:	80 e0       	ldi	r24, 0x00	; 0
    23a4:	98 e0       	ldi	r25, 0x08	; 8
    23a6:	2f ef       	ldi	r18, 0xFF	; 255
    23a8:	fc 01       	movw	r30, r24
    23aa:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    23ac:	80 e0       	ldi	r24, 0x00	; 0
    23ae:	98 e0       	ldi	r25, 0x08	; 8
    23b0:	20 e0       	ldi	r18, 0x00	; 0
    23b2:	38 e0       	ldi	r19, 0x08	; 8
    23b4:	f9 01       	movw	r30, r18
    23b6:	20 81       	ld	r18, Z
    23b8:	20 7f       	andi	r18, 0xF0	; 240
    23ba:	28 60       	ori	r18, 0x08	; 8
    23bc:	fc 01       	movw	r30, r24
    23be:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    23c0:	10 92 58 40 	sts	0x4058, r1
    23c4:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    23c8:	10 92 73 50 	sts	0x5073, r1
    23cc:	10 92 74 50 	sts	0x5074, r1
	SPICount = 0;
    23d0:	10 92 cb 50 	sts	0x50CB, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    23d4:	80 e0       	ldi	r24, 0x00	; 0
    23d6:	80 93 3c 21 	sts	0x213C, r24
    23da:	80 93 3b 21 	sts	0x213B, r24
    23de:	80 93 3a 21 	sts	0x213A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    23e2:	80 ea       	ldi	r24, 0xA0	; 160
    23e4:	90 e0       	ldi	r25, 0x00	; 0
    23e6:	20 ea       	ldi	r18, 0xA0	; 160
    23e8:	30 e0       	ldi	r19, 0x00	; 0
    23ea:	f9 01       	movw	r30, r18
    23ec:	22 81       	ldd	r18, Z+2	; 0x02
    23ee:	26 60       	ori	r18, 0x06	; 6
    23f0:	fc 01       	movw	r30, r24
    23f2:	22 83       	std	Z+2, r18	; 0x02
	sei();
    23f4:	78 94       	sei

	SPICS(TRUE);
    23f6:	81 e0       	ldi	r24, 0x01	; 1
    23f8:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    23fc:	80 e8       	ldi	r24, 0x80	; 128
    23fe:	96 e0       	ldi	r25, 0x06	; 6
    2400:	20 e2       	ldi	r18, 0x20	; 32
    2402:	fc 01       	movw	r30, r24
    2404:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2406:	80 e4       	ldi	r24, 0x40	; 64
    2408:	9a e0       	ldi	r25, 0x0A	; 10
    240a:	23 e2       	ldi	r18, 0x23	; 35
    240c:	fc 01       	movw	r30, r24
    240e:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2410:	80 e4       	ldi	r24, 0x40	; 64
    2412:	9a e0       	ldi	r25, 0x0A	; 10
    2414:	2c 81       	ldd	r18, Y+4	; 0x04
    2416:	42 2f       	mov	r20, r18
    2418:	50 e0       	ldi	r21, 0x00	; 0
    241a:	20 e2       	ldi	r18, 0x20	; 32
    241c:	30 e0       	ldi	r19, 0x00	; 0
    241e:	02 c0       	rjmp	.+4      	; 0x2424 <CO_collectSeismic3Channel+0x19e>
    2420:	22 0f       	add	r18, r18
    2422:	33 1f       	adc	r19, r19
    2424:	4a 95       	dec	r20
    2426:	e2 f7       	brpl	.-8      	; 0x2420 <CO_collectSeismic3Channel+0x19a>
    2428:	fc 01       	movw	r30, r24
    242a:	26 a3       	lds	r18, 0x56
    242c:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    242e:	80 e4       	ldi	r24, 0x40	; 64
    2430:	9a e0       	ldi	r25, 0x0A	; 10
    2432:	2c 81       	ldd	r18, Y+4	; 0x04
    2434:	42 2f       	mov	r20, r18
    2436:	50 e0       	ldi	r21, 0x00	; 0
    2438:	20 e1       	ldi	r18, 0x10	; 16
    243a:	30 e0       	ldi	r19, 0x00	; 0
    243c:	04 2e       	mov	r0, r20
    243e:	02 c0       	rjmp	.+4      	; 0x2444 <CO_collectSeismic3Channel+0x1be>
    2440:	22 0f       	add	r18, r18
    2442:	33 1f       	adc	r19, r19
    2444:	0a 94       	dec	r0
    2446:	e2 f7       	brpl	.-8      	; 0x2440 <CO_collectSeismic3Channel+0x1ba>
    2448:	fc 01       	movw	r30, r24
    244a:	22 af       	sts	0x72, r18
    244c:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    244e:	80 e4       	ldi	r24, 0x40	; 64
    2450:	9a e0       	ldi	r25, 0x0A	; 10
    2452:	20 e4       	ldi	r18, 0x40	; 64
    2454:	3a e0       	ldi	r19, 0x0A	; 10
    2456:	f9 01       	movw	r30, r18
    2458:	20 81       	ld	r18, Z
    245a:	20 7f       	andi	r18, 0xF0	; 240
    245c:	21 60       	ori	r18, 0x01	; 1
    245e:	fc 01       	movw	r30, r24
    2460:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2462:	00 00       	nop
    2464:	80 91 73 50 	lds	r24, 0x5073
    2468:	90 91 74 50 	lds	r25, 0x5074
    246c:	f5 e5       	ldi	r31, 0x55	; 85
    246e:	83 35       	cpi	r24, 0x53	; 83
    2470:	9f 07       	cpc	r25, r31
    2472:	c0 f3       	brcs	.-16     	; 0x2464 <CO_collectSeismic3Channel+0x1de>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	98 e0       	ldi	r25, 0x08	; 8
    2478:	20 e0       	ldi	r18, 0x00	; 0
    247a:	38 e0       	ldi	r19, 0x08	; 8
    247c:	f9 01       	movw	r30, r18
    247e:	20 81       	ld	r18, Z
    2480:	20 7f       	andi	r18, 0xF0	; 240
    2482:	fc 01       	movw	r30, r24
    2484:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2486:	80 e4       	ldi	r24, 0x40	; 64
    2488:	9a e0       	ldi	r25, 0x0A	; 10
    248a:	20 e4       	ldi	r18, 0x40	; 64
    248c:	3a e0       	ldi	r19, 0x0A	; 10
    248e:	f9 01       	movw	r30, r18
    2490:	20 81       	ld	r18, Z
    2492:	20 7f       	andi	r18, 0xF0	; 240
    2494:	fc 01       	movw	r30, r24
    2496:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2498:	80 ea       	ldi	r24, 0xA0	; 160
    249a:	90 e0       	ldi	r25, 0x00	; 0
    249c:	20 ea       	ldi	r18, 0xA0	; 160
    249e:	30 e0       	ldi	r19, 0x00	; 0
    24a0:	f9 01       	movw	r30, r18
    24a2:	22 81       	ldd	r18, Z+2	; 0x02
    24a4:	29 7f       	andi	r18, 0xF9	; 249
    24a6:	fc 01       	movw	r30, r24
    24a8:	22 83       	std	Z+2, r18	; 0x02
	cli();
    24aa:	f8 94       	cli

	SPICS(FALSE);
    24ac:	80 e0       	ldi	r24, 0x00	; 0
    24ae:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    24b2:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	enableADCMUX(FALSE);
    24b6:	80 e0       	ldi	r24, 0x00	; 0
    24b8:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
	ADCPower(FALSE);
    24bc:	80 e0       	ldi	r24, 0x00	; 0
    24be:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	
}
    24c2:	2e 96       	adiw	r28, 0x0e	; 14
    24c4:	cd bf       	out	0x3d, r28	; 61
    24c6:	de bf       	out	0x3e, r29	; 62
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	0f 91       	pop	r16
    24ce:	ff 90       	pop	r15
    24d0:	ef 90       	pop	r14
    24d2:	df 90       	pop	r13
    24d4:	cf 90       	pop	r12
    24d6:	bf 90       	pop	r11
    24d8:	af 90       	pop	r10
    24da:	9f 90       	pop	r9
    24dc:	8f 90       	pop	r8
    24de:	08 95       	ret

000024e0 <CO_collectSeismic3Channel_continuous>:

void CO_collectSeismic3Channel_continuous(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    24e0:	8f 92       	push	r8
    24e2:	9f 92       	push	r9
    24e4:	af 92       	push	r10
    24e6:	bf 92       	push	r11
    24e8:	cf 92       	push	r12
    24ea:	df 92       	push	r13
    24ec:	ef 92       	push	r14
    24ee:	ff 92       	push	r15
    24f0:	0f 93       	push	r16
    24f2:	cf 93       	push	r28
    24f4:	df 93       	push	r29
    24f6:	cd b7       	in	r28, 0x3d	; 61
    24f8:	de b7       	in	r29, 0x3e	; 62
    24fa:	2e 97       	sbiw	r28, 0x0e	; 14
    24fc:	cd bf       	out	0x3d, r28	; 61
    24fe:	de bf       	out	0x3e, r29	; 62
    2500:	89 83       	std	Y+1, r24	; 0x01
    2502:	6a 83       	std	Y+2, r22	; 0x02
    2504:	7b 83       	std	Y+3, r23	; 0x03
    2506:	4c 83       	std	Y+4, r20	; 0x04
    2508:	2d 83       	std	Y+5, r18	; 0x05
    250a:	0e 83       	std	Y+6, r16	; 0x06
    250c:	ef 82       	std	Y+7, r14	; 0x07
    250e:	f8 86       	std	Y+8, r15	; 0x08
    2510:	c9 86       	std	Y+9, r12	; 0x09
    2512:	da 86       	std	Y+10, r13	; 0x0a
    2514:	ab 86       	std	Y+11, r10	; 0x0b
    2516:	bc 86       	std	Y+12, r11	; 0x0c
    2518:	8d 86       	std	Y+13, r8	; 0x0d
    251a:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    251c:	81 e0       	ldi	r24, 0x01	; 1
    251e:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2522:	8a 81       	ldd	r24, Y+2	; 0x02
    2524:	9b 81       	ldd	r25, Y+3	; 0x03
    2526:	fc 01       	movw	r30, r24
    2528:	90 81       	ld	r25, Z
    252a:	85 e0       	ldi	r24, 0x05	; 5
    252c:	69 2f       	mov	r22, r25
    252e:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2532:	8a 81       	ldd	r24, Y+2	; 0x02
    2534:	9b 81       	ldd	r25, Y+3	; 0x03
    2536:	01 96       	adiw	r24, 0x01	; 1
    2538:	fc 01       	movw	r30, r24
    253a:	90 81       	ld	r25, Z
    253c:	86 e0       	ldi	r24, 0x06	; 6
    253e:	69 2f       	mov	r22, r25
    2540:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2544:	8a 81       	ldd	r24, Y+2	; 0x02
    2546:	9b 81       	ldd	r25, Y+3	; 0x03
    2548:	02 96       	adiw	r24, 0x02	; 2
    254a:	fc 01       	movw	r30, r24
    254c:	90 81       	ld	r25, Z
    254e:	87 e0       	ldi	r24, 0x07	; 7
    2550:	69 2f       	mov	r22, r25
    2552:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_filter(filterConfig);
    2556:	89 81       	ldd	r24, Y+1	; 0x01
    2558:	0e 94 4f 08 	call	0x109e	; 0x109e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    255c:	8e 81       	ldd	r24, Y+6	; 0x06
    255e:	0e 94 29 11 	call	0x2252	; 0x2252 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2562:	84 e0       	ldi	r24, 0x04	; 4
    2564:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2568:	80 ec       	ldi	r24, 0xC0	; 192
    256a:	98 e0       	ldi	r25, 0x08	; 8
    256c:	24 e5       	ldi	r18, 0x54	; 84
    256e:	fc 01       	movw	r30, r24
    2570:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2572:	81 e0       	ldi	r24, 0x01	; 1
    2574:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2578:	85 e0       	ldi	r24, 0x05	; 5
    257a:	0e 94 55 1c 	call	0x38aa	; 0x38aa <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    257e:	80 ea       	ldi	r24, 0xA0	; 160
    2580:	96 e0       	ldi	r25, 0x06	; 6
    2582:	22 e0       	ldi	r18, 0x02	; 2
    2584:	fc 01       	movw	r30, r24
    2586:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2588:	80 ea       	ldi	r24, 0xA0	; 160
    258a:	96 e0       	ldi	r25, 0x06	; 6
    258c:	21 e0       	ldi	r18, 0x01	; 1
    258e:	fc 01       	movw	r30, r24
    2590:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2592:	80 e8       	ldi	r24, 0x80	; 128
    2594:	91 e0       	ldi	r25, 0x01	; 1
    2596:	28 e7       	ldi	r18, 0x78	; 120
    2598:	fc 01       	movw	r30, r24
    259a:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    259c:	80 e0       	ldi	r24, 0x00	; 0
    259e:	98 e0       	ldi	r25, 0x08	; 8
    25a0:	20 ef       	ldi	r18, 0xF0	; 240
    25a2:	fc 01       	movw	r30, r24
    25a4:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    25a6:	80 e0       	ldi	r24, 0x00	; 0
    25a8:	98 e0       	ldi	r25, 0x08	; 8
    25aa:	2f 81       	ldd	r18, Y+7	; 0x07
    25ac:	38 85       	ldd	r19, Y+8	; 0x08
    25ae:	fc 01       	movw	r30, r24
    25b0:	20 a7       	lds	r18, 0x70
    25b2:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    25b4:	80 e0       	ldi	r24, 0x00	; 0
    25b6:	98 e0       	ldi	r25, 0x08	; 8
    25b8:	29 85       	ldd	r18, Y+9	; 0x09
    25ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    25bc:	fc 01       	movw	r30, r24
    25be:	22 a7       	lds	r18, 0x72
    25c0:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    25c2:	80 e0       	ldi	r24, 0x00	; 0
    25c4:	98 e0       	ldi	r25, 0x08	; 8
    25c6:	2b 85       	ldd	r18, Y+11	; 0x0b
    25c8:	3c 85       	ldd	r19, Y+12	; 0x0c
    25ca:	fc 01       	movw	r30, r24
    25cc:	24 a7       	lds	r18, 0x74
    25ce:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    25d0:	80 e0       	ldi	r24, 0x00	; 0
    25d2:	98 e0       	ldi	r25, 0x08	; 8
    25d4:	2d 85       	ldd	r18, Y+13	; 0x0d
    25d6:	3e 85       	ldd	r19, Y+14	; 0x0e
    25d8:	fc 01       	movw	r30, r24
    25da:	26 a7       	lds	r18, 0x76
    25dc:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    25de:	80 e0       	ldi	r24, 0x00	; 0
    25e0:	98 e0       	ldi	r25, 0x08	; 8
    25e2:	2d 81       	ldd	r18, Y+5	; 0x05
    25e4:	22 2f       	mov	r18, r18
    25e6:	30 e0       	ldi	r19, 0x00	; 0
    25e8:	21 50       	subi	r18, 0x01	; 1
    25ea:	30 40       	sbci	r19, 0x00	; 0
    25ec:	fc 01       	movw	r30, r24
    25ee:	26 a3       	lds	r18, 0x56
    25f0:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    25f2:	80 e0       	ldi	r24, 0x00	; 0
    25f4:	98 e0       	ldi	r25, 0x08	; 8
    25f6:	22 e0       	ldi	r18, 0x02	; 2
    25f8:	fc 01       	movw	r30, r24
    25fa:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    25fc:	80 e0       	ldi	r24, 0x00	; 0
    25fe:	98 e0       	ldi	r25, 0x08	; 8
    2600:	2f ef       	ldi	r18, 0xFF	; 255
    2602:	fc 01       	movw	r30, r24
    2604:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2606:	80 e0       	ldi	r24, 0x00	; 0
    2608:	98 e0       	ldi	r25, 0x08	; 8
    260a:	20 e0       	ldi	r18, 0x00	; 0
    260c:	38 e0       	ldi	r19, 0x08	; 8
    260e:	f9 01       	movw	r30, r18
    2610:	20 81       	ld	r18, Z
    2612:	20 7f       	andi	r18, 0xF0	; 240
    2614:	28 60       	ori	r18, 0x08	; 8
    2616:	fc 01       	movw	r30, r24
    2618:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    261a:	10 92 58 40 	sts	0x4058, r1
    261e:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    2622:	10 92 73 50 	sts	0x5073, r1
    2626:	10 92 74 50 	sts	0x5074, r1
	SPICount = 0;
    262a:	10 92 cb 50 	sts	0x50CB, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    262e:	80 e0       	ldi	r24, 0x00	; 0
    2630:	80 93 3c 21 	sts	0x213C, r24
    2634:	80 93 3b 21 	sts	0x213B, r24
    2638:	80 93 3a 21 	sts	0x213A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    263c:	80 ea       	ldi	r24, 0xA0	; 160
    263e:	90 e0       	ldi	r25, 0x00	; 0
    2640:	20 ea       	ldi	r18, 0xA0	; 160
    2642:	30 e0       	ldi	r19, 0x00	; 0
    2644:	f9 01       	movw	r30, r18
    2646:	22 81       	ldd	r18, Z+2	; 0x02
    2648:	26 60       	ori	r18, 0x06	; 6
    264a:	fc 01       	movw	r30, r24
    264c:	22 83       	std	Z+2, r18	; 0x02
	sei();
    264e:	78 94       	sei

	SPICS(TRUE);
    2650:	81 e0       	ldi	r24, 0x01	; 1
    2652:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2656:	80 e8       	ldi	r24, 0x80	; 128
    2658:	96 e0       	ldi	r25, 0x06	; 6
    265a:	20 e2       	ldi	r18, 0x20	; 32
    265c:	fc 01       	movw	r30, r24
    265e:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2660:	80 e4       	ldi	r24, 0x40	; 64
    2662:	9a e0       	ldi	r25, 0x0A	; 10
    2664:	23 e2       	ldi	r18, 0x23	; 35
    2666:	fc 01       	movw	r30, r24
    2668:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    266a:	80 e4       	ldi	r24, 0x40	; 64
    266c:	9a e0       	ldi	r25, 0x0A	; 10
    266e:	2c 81       	ldd	r18, Y+4	; 0x04
    2670:	42 2f       	mov	r20, r18
    2672:	50 e0       	ldi	r21, 0x00	; 0
    2674:	20 e2       	ldi	r18, 0x20	; 32
    2676:	30 e0       	ldi	r19, 0x00	; 0
    2678:	02 c0       	rjmp	.+4      	; 0x267e <CO_collectSeismic3Channel_continuous+0x19e>
    267a:	22 0f       	add	r18, r18
    267c:	33 1f       	adc	r19, r19
    267e:	4a 95       	dec	r20
    2680:	e2 f7       	brpl	.-8      	; 0x267a <CO_collectSeismic3Channel_continuous+0x19a>
    2682:	fc 01       	movw	r30, r24
    2684:	26 a3       	lds	r18, 0x56
    2686:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2688:	80 e4       	ldi	r24, 0x40	; 64
    268a:	9a e0       	ldi	r25, 0x0A	; 10
    268c:	2c 81       	ldd	r18, Y+4	; 0x04
    268e:	42 2f       	mov	r20, r18
    2690:	50 e0       	ldi	r21, 0x00	; 0
    2692:	20 e1       	ldi	r18, 0x10	; 16
    2694:	30 e0       	ldi	r19, 0x00	; 0
    2696:	04 2e       	mov	r0, r20
    2698:	02 c0       	rjmp	.+4      	; 0x269e <CO_collectSeismic3Channel_continuous+0x1be>
    269a:	22 0f       	add	r18, r18
    269c:	33 1f       	adc	r19, r19
    269e:	0a 94       	dec	r0
    26a0:	e2 f7       	brpl	.-8      	; 0x269a <CO_collectSeismic3Channel_continuous+0x1ba>
    26a2:	fc 01       	movw	r30, r24
    26a4:	22 af       	sts	0x72, r18
    26a6:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    26a8:	80 e4       	ldi	r24, 0x40	; 64
    26aa:	9a e0       	ldi	r25, 0x0A	; 10
    26ac:	20 e4       	ldi	r18, 0x40	; 64
    26ae:	3a e0       	ldi	r19, 0x0A	; 10
    26b0:	f9 01       	movw	r30, r18
    26b2:	20 81       	ld	r18, Z
    26b4:	20 7f       	andi	r18, 0xF0	; 240
    26b6:	21 60       	ori	r18, 0x01	; 1
    26b8:	fc 01       	movw	r30, r24
    26ba:	20 83       	st	Z, r18
	
	// collect samples from ADC continuously
	while(1){
		nop();
    26bc:	00 00       	nop
	}
    26be:	fe cf       	rjmp	.-4      	; 0x26bc <CO_collectSeismic3Channel_continuous+0x1dc>

000026c0 <__vector_16>:
}


ISR(TCC0_CCA_vect) {
    26c0:	1f 92       	push	r1
    26c2:	0f 92       	push	r0
    26c4:	0f b6       	in	r0, 0x3f	; 63
    26c6:	0f 92       	push	r0
    26c8:	00 90 3b 00 	lds	r0, 0x003B
    26cc:	0f 92       	push	r0
    26ce:	11 24       	eor	r1, r1
    26d0:	2f 93       	push	r18
    26d2:	3f 93       	push	r19
    26d4:	4f 93       	push	r20
    26d6:	5f 93       	push	r21
    26d8:	6f 93       	push	r22
    26da:	7f 93       	push	r23
    26dc:	8f 93       	push	r24
    26de:	9f 93       	push	r25
    26e0:	af 93       	push	r26
    26e2:	bf 93       	push	r27
    26e4:	ef 93       	push	r30
    26e6:	ff 93       	push	r31
    26e8:	cf 93       	push	r28
    26ea:	df 93       	push	r29
    26ec:	cd b7       	in	r28, 0x3d	; 61
    26ee:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    26f0:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
}
    26f4:	df 91       	pop	r29
    26f6:	cf 91       	pop	r28
    26f8:	ff 91       	pop	r31
    26fa:	ef 91       	pop	r30
    26fc:	bf 91       	pop	r27
    26fe:	af 91       	pop	r26
    2700:	9f 91       	pop	r25
    2702:	8f 91       	pop	r24
    2704:	7f 91       	pop	r23
    2706:	6f 91       	pop	r22
    2708:	5f 91       	pop	r21
    270a:	4f 91       	pop	r20
    270c:	3f 91       	pop	r19
    270e:	2f 91       	pop	r18
    2710:	0f 90       	pop	r0
    2712:	00 92 3b 00 	sts	0x003B, r0
    2716:	0f 90       	pop	r0
    2718:	0f be       	out	0x3f, r0	; 63
    271a:	0f 90       	pop	r0
    271c:	1f 90       	pop	r1
    271e:	18 95       	reti

00002720 <__vector_17>:

ISR(TCC0_CCB_vect) {
    2720:	1f 92       	push	r1
    2722:	0f 92       	push	r0
    2724:	0f b6       	in	r0, 0x3f	; 63
    2726:	0f 92       	push	r0
    2728:	00 90 3b 00 	lds	r0, 0x003B
    272c:	0f 92       	push	r0
    272e:	11 24       	eor	r1, r1
    2730:	2f 93       	push	r18
    2732:	3f 93       	push	r19
    2734:	4f 93       	push	r20
    2736:	5f 93       	push	r21
    2738:	6f 93       	push	r22
    273a:	7f 93       	push	r23
    273c:	8f 93       	push	r24
    273e:	9f 93       	push	r25
    2740:	af 93       	push	r26
    2742:	bf 93       	push	r27
    2744:	ef 93       	push	r30
    2746:	ff 93       	push	r31
    2748:	cf 93       	push	r28
    274a:	df 93       	push	r29
    274c:	cd b7       	in	r28, 0x3d	; 61
    274e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2750:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
}
    2754:	df 91       	pop	r29
    2756:	cf 91       	pop	r28
    2758:	ff 91       	pop	r31
    275a:	ef 91       	pop	r30
    275c:	bf 91       	pop	r27
    275e:	af 91       	pop	r26
    2760:	9f 91       	pop	r25
    2762:	8f 91       	pop	r24
    2764:	7f 91       	pop	r23
    2766:	6f 91       	pop	r22
    2768:	5f 91       	pop	r21
    276a:	4f 91       	pop	r20
    276c:	3f 91       	pop	r19
    276e:	2f 91       	pop	r18
    2770:	0f 90       	pop	r0
    2772:	00 92 3b 00 	sts	0x003B, r0
    2776:	0f 90       	pop	r0
    2778:	0f be       	out	0x3f, r0	; 63
    277a:	0f 90       	pop	r0
    277c:	1f 90       	pop	r1
    277e:	18 95       	reti

00002780 <__vector_18>:

ISR(TCC0_CCC_vect) {
    2780:	1f 92       	push	r1
    2782:	0f 92       	push	r0
    2784:	0f b6       	in	r0, 0x3f	; 63
    2786:	0f 92       	push	r0
    2788:	00 90 3b 00 	lds	r0, 0x003B
    278c:	0f 92       	push	r0
    278e:	11 24       	eor	r1, r1
    2790:	2f 93       	push	r18
    2792:	3f 93       	push	r19
    2794:	4f 93       	push	r20
    2796:	5f 93       	push	r21
    2798:	6f 93       	push	r22
    279a:	7f 93       	push	r23
    279c:	8f 93       	push	r24
    279e:	9f 93       	push	r25
    27a0:	af 93       	push	r26
    27a2:	bf 93       	push	r27
    27a4:	ef 93       	push	r30
    27a6:	ff 93       	push	r31
    27a8:	cf 93       	push	r28
    27aa:	df 93       	push	r29
    27ac:	cd b7       	in	r28, 0x3d	; 61
    27ae:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    27b0:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
}
    27b4:	df 91       	pop	r29
    27b6:	cf 91       	pop	r28
    27b8:	ff 91       	pop	r31
    27ba:	ef 91       	pop	r30
    27bc:	bf 91       	pop	r27
    27be:	af 91       	pop	r26
    27c0:	9f 91       	pop	r25
    27c2:	8f 91       	pop	r24
    27c4:	7f 91       	pop	r23
    27c6:	6f 91       	pop	r22
    27c8:	5f 91       	pop	r21
    27ca:	4f 91       	pop	r20
    27cc:	3f 91       	pop	r19
    27ce:	2f 91       	pop	r18
    27d0:	0f 90       	pop	r0
    27d2:	00 92 3b 00 	sts	0x003B, r0
    27d6:	0f 90       	pop	r0
    27d8:	0f be       	out	0x3f, r0	; 63
    27da:	0f 90       	pop	r0
    27dc:	1f 90       	pop	r1
    27de:	18 95       	reti

000027e0 <__vector_19>:

ISR(TCC0_CCD_vect) {
    27e0:	1f 92       	push	r1
    27e2:	0f 92       	push	r0
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	0f 92       	push	r0
    27e8:	00 90 3b 00 	lds	r0, 0x003B
    27ec:	0f 92       	push	r0
    27ee:	11 24       	eor	r1, r1
    27f0:	2f 93       	push	r18
    27f2:	3f 93       	push	r19
    27f4:	4f 93       	push	r20
    27f6:	5f 93       	push	r21
    27f8:	6f 93       	push	r22
    27fa:	7f 93       	push	r23
    27fc:	8f 93       	push	r24
    27fe:	9f 93       	push	r25
    2800:	af 93       	push	r26
    2802:	bf 93       	push	r27
    2804:	ef 93       	push	r30
    2806:	ff 93       	push	r31
    2808:	cf 93       	push	r28
    280a:	df 93       	push	r29
    280c:	cd b7       	in	r28, 0x3d	; 61
    280e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2810:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
	SPICount = 0;
    2814:	10 92 cb 50 	sts	0x50CB, r1
	if(PORTB.OUT & PIN1_bm) {
    2818:	80 e2       	ldi	r24, 0x20	; 32
    281a:	96 e0       	ldi	r25, 0x06	; 6
    281c:	fc 01       	movw	r30, r24
    281e:	84 81       	ldd	r24, Z+4	; 0x04
    2820:	88 2f       	mov	r24, r24
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	82 70       	andi	r24, 0x02	; 2
    2826:	90 70       	andi	r25, 0x00	; 0
    2828:	00 97       	sbiw	r24, 0x00	; 0
    282a:	b1 f0       	breq	.+44     	; 0x2858 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    282c:	80 e0       	ldi	r24, 0x00	; 0
    282e:	96 e0       	ldi	r25, 0x06	; 6
    2830:	fc 01       	movw	r30, r24
    2832:	84 81       	ldd	r24, Z+4	; 0x04
    2834:	88 2f       	mov	r24, r24
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	80 74       	andi	r24, 0x40	; 64
    283a:	90 70       	andi	r25, 0x00	; 0
    283c:	00 97       	sbiw	r24, 0x00	; 0
    283e:	31 f0       	breq	.+12     	; 0x284c <__vector_19+0x6c>
    2840:	80 e2       	ldi	r24, 0x20	; 32
    2842:	96 e0       	ldi	r25, 0x06	; 6
    2844:	22 e0       	ldi	r18, 0x02	; 2
    2846:	fc 01       	movw	r30, r24
    2848:	27 83       	std	Z+7, r18	; 0x07
    284a:	10 c0       	rjmp	.+32     	; 0x286c <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    284c:	80 e0       	ldi	r24, 0x00	; 0
    284e:	96 e0       	ldi	r25, 0x06	; 6
    2850:	20 e4       	ldi	r18, 0x40	; 64
    2852:	fc 01       	movw	r30, r24
    2854:	27 83       	std	Z+7, r18	; 0x07
    2856:	0a c0       	rjmp	.+20     	; 0x286c <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2858:	80 e0       	ldi	r24, 0x00	; 0
    285a:	96 e0       	ldi	r25, 0x06	; 6
    285c:	20 e4       	ldi	r18, 0x40	; 64
    285e:	fc 01       	movw	r30, r24
    2860:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2862:	80 e2       	ldi	r24, 0x20	; 32
    2864:	96 e0       	ldi	r25, 0x06	; 6
    2866:	22 e0       	ldi	r18, 0x02	; 2
    2868:	fc 01       	movw	r30, r24
    286a:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    286c:	df 91       	pop	r29
    286e:	cf 91       	pop	r28
    2870:	ff 91       	pop	r31
    2872:	ef 91       	pop	r30
    2874:	bf 91       	pop	r27
    2876:	af 91       	pop	r26
    2878:	9f 91       	pop	r25
    287a:	8f 91       	pop	r24
    287c:	7f 91       	pop	r23
    287e:	6f 91       	pop	r22
    2880:	5f 91       	pop	r21
    2882:	4f 91       	pop	r20
    2884:	3f 91       	pop	r19
    2886:	2f 91       	pop	r18
    2888:	0f 90       	pop	r0
    288a:	00 92 3b 00 	sts	0x003B, r0
    288e:	0f 90       	pop	r0
    2890:	0f be       	out	0x3f, r0	; 63
    2892:	0f 90       	pop	r0
    2894:	1f 90       	pop	r1
    2896:	18 95       	reti

00002898 <__vector_14>:

ISR(TCC0_OVF_vect) {
    2898:	1f 92       	push	r1
    289a:	0f 92       	push	r0
    289c:	0f b6       	in	r0, 0x3f	; 63
    289e:	0f 92       	push	r0
    28a0:	00 90 3b 00 	lds	r0, 0x003B
    28a4:	0f 92       	push	r0
    28a6:	11 24       	eor	r1, r1
    28a8:	2f 93       	push	r18
    28aa:	3f 93       	push	r19
    28ac:	4f 93       	push	r20
    28ae:	5f 93       	push	r21
    28b0:	6f 93       	push	r22
    28b2:	7f 93       	push	r23
    28b4:	8f 93       	push	r24
    28b6:	9f 93       	push	r25
    28b8:	af 93       	push	r26
    28ba:	bf 93       	push	r27
    28bc:	ef 93       	push	r30
    28be:	ff 93       	push	r31
    28c0:	cf 93       	push	r28
    28c2:	df 93       	push	r29
    28c4:	cd b7       	in	r28, 0x3d	; 61
    28c6:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    28c8:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <writeSE2FRAM>
}
    28cc:	df 91       	pop	r29
    28ce:	cf 91       	pop	r28
    28d0:	ff 91       	pop	r31
    28d2:	ef 91       	pop	r30
    28d4:	bf 91       	pop	r27
    28d6:	af 91       	pop	r26
    28d8:	9f 91       	pop	r25
    28da:	8f 91       	pop	r24
    28dc:	7f 91       	pop	r23
    28de:	6f 91       	pop	r22
    28e0:	5f 91       	pop	r21
    28e2:	4f 91       	pop	r20
    28e4:	3f 91       	pop	r19
    28e6:	2f 91       	pop	r18
    28e8:	0f 90       	pop	r0
    28ea:	00 92 3b 00 	sts	0x003B, r0
    28ee:	0f 90       	pop	r0
    28f0:	0f be       	out	0x3f, r0	; 63
    28f2:	0f 90       	pop	r0
    28f4:	1f 90       	pop	r1
    28f6:	18 95       	reti

000028f8 <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD) {
    28f8:	8f 92       	push	r8
    28fa:	9f 92       	push	r9
    28fc:	af 92       	push	r10
    28fe:	bf 92       	push	r11
    2900:	cf 92       	push	r12
    2902:	df 92       	push	r13
    2904:	ef 92       	push	r14
    2906:	0f 93       	push	r16
    2908:	cf 93       	push	r28
    290a:	df 93       	push	r29
    290c:	cd b7       	in	r28, 0x3d	; 61
    290e:	de b7       	in	r29, 0x3e	; 62
    2910:	2c 97       	sbiw	r28, 0x0c	; 12
    2912:	cd bf       	out	0x3d, r28	; 61
    2914:	de bf       	out	0x3e, r29	; 62
    2916:	89 83       	std	Y+1, r24	; 0x01
    2918:	6a 83       	std	Y+2, r22	; 0x02
    291a:	4b 83       	std	Y+3, r20	; 0x03
    291c:	2c 83       	std	Y+4, r18	; 0x04
    291e:	0d 83       	std	Y+5, r16	; 0x05
    2920:	ee 82       	std	Y+6, r14	; 0x06
    2922:	cf 82       	std	Y+7, r12	; 0x07
    2924:	d8 86       	std	Y+8, r13	; 0x08
    2926:	a9 86       	std	Y+9, r10	; 0x09
    2928:	ba 86       	std	Y+10, r11	; 0x0a
    292a:	8b 86       	std	Y+11, r8	; 0x0b
    292c:	9c 86       	std	Y+12, r9	; 0x0c
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    292e:	81 e0       	ldi	r24, 0x01	; 1
    2930:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2934:	89 81       	ldd	r24, Y+1	; 0x01
    2936:	6b 81       	ldd	r22, Y+3	; 0x03
    2938:	0e 94 20 07 	call	0xe40	; 0xe40 <set_ampGain>
	set_filter(filterConfig);
    293c:	8a 81       	ldd	r24, Y+2	; 0x02
    293e:	0e 94 4f 08 	call	0x109e	; 0x109e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2942:	8e 81       	ldd	r24, Y+6	; 0x06
    2944:	0e 94 29 11 	call	0x2252	; 0x2252 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2948:	84 e0       	ldi	r24, 0x04	; 4
    294a:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    294e:	80 ec       	ldi	r24, 0xC0	; 192
    2950:	98 e0       	ldi	r25, 0x08	; 8
    2952:	24 e5       	ldi	r18, 0x54	; 84
    2954:	fc 01       	movw	r30, r24
    2956:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2958:	81 e0       	ldi	r24, 0x01	; 1
    295a:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
	setADCInput(channel);
    295e:	89 81       	ldd	r24, Y+1	; 0x01
    2960:	0e 94 55 1c 	call	0x38aa	; 0x38aa <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2964:	80 ea       	ldi	r24, 0xA0	; 160
    2966:	96 e0       	ldi	r25, 0x06	; 6
    2968:	22 e0       	ldi	r18, 0x02	; 2
    296a:	fc 01       	movw	r30, r24
    296c:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    296e:	80 ea       	ldi	r24, 0xA0	; 160
    2970:	96 e0       	ldi	r25, 0x06	; 6
    2972:	21 e0       	ldi	r18, 0x01	; 1
    2974:	fc 01       	movw	r30, r24
    2976:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2978:	80 e8       	ldi	r24, 0x80	; 128
    297a:	91 e0       	ldi	r25, 0x01	; 1
    297c:	28 e7       	ldi	r18, 0x78	; 120
    297e:	fc 01       	movw	r30, r24
    2980:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2982:	80 e0       	ldi	r24, 0x00	; 0
    2984:	99 e0       	ldi	r25, 0x09	; 9
    2986:	20 ef       	ldi	r18, 0xF0	; 240
    2988:	fc 01       	movw	r30, r24
    298a:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    298c:	80 e0       	ldi	r24, 0x00	; 0
    298e:	99 e0       	ldi	r25, 0x09	; 9
    2990:	2f 81       	ldd	r18, Y+7	; 0x07
    2992:	38 85       	ldd	r19, Y+8	; 0x08
    2994:	fc 01       	movw	r30, r24
    2996:	20 a7       	lds	r18, 0x70
    2998:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    299a:	80 e0       	ldi	r24, 0x00	; 0
    299c:	99 e0       	ldi	r25, 0x09	; 9
    299e:	29 85       	ldd	r18, Y+9	; 0x09
    29a0:	3a 85       	ldd	r19, Y+10	; 0x0a
    29a2:	fc 01       	movw	r30, r24
    29a4:	22 a7       	lds	r18, 0x72
    29a6:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    29a8:	80 e0       	ldi	r24, 0x00	; 0
    29aa:	99 e0       	ldi	r25, 0x09	; 9
    29ac:	2b 85       	ldd	r18, Y+11	; 0x0b
    29ae:	3c 85       	ldd	r19, Y+12	; 0x0c
    29b0:	fc 01       	movw	r30, r24
    29b2:	24 a7       	lds	r18, 0x74
    29b4:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    29b6:	80 e0       	ldi	r24, 0x00	; 0
    29b8:	99 e0       	ldi	r25, 0x09	; 9
    29ba:	2a 8d       	ldd	r18, Y+26	; 0x1a
    29bc:	3b 8d       	ldd	r19, Y+27	; 0x1b
    29be:	fc 01       	movw	r30, r24
    29c0:	26 a7       	lds	r18, 0x76
    29c2:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    29c4:	80 e0       	ldi	r24, 0x00	; 0
    29c6:	99 e0       	ldi	r25, 0x09	; 9
    29c8:	2d 81       	ldd	r18, Y+5	; 0x05
    29ca:	22 2f       	mov	r18, r18
    29cc:	30 e0       	ldi	r19, 0x00	; 0
    29ce:	21 50       	subi	r18, 0x01	; 1
    29d0:	30 40       	sbci	r19, 0x00	; 0
    29d2:	fc 01       	movw	r30, r24
    29d4:	26 a3       	lds	r18, 0x56
    29d6:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    29d8:	80 e0       	ldi	r24, 0x00	; 0
    29da:	99 e0       	ldi	r25, 0x09	; 9
    29dc:	22 e0       	ldi	r18, 0x02	; 2
    29de:	fc 01       	movw	r30, r24
    29e0:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    29e2:	80 e0       	ldi	r24, 0x00	; 0
    29e4:	99 e0       	ldi	r25, 0x09	; 9
    29e6:	2f ef       	ldi	r18, 0xFF	; 255
    29e8:	fc 01       	movw	r30, r24
    29ea:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    29ec:	80 e0       	ldi	r24, 0x00	; 0
    29ee:	99 e0       	ldi	r25, 0x09	; 9
    29f0:	20 e0       	ldi	r18, 0x00	; 0
    29f2:	39 e0       	ldi	r19, 0x09	; 9
    29f4:	f9 01       	movw	r30, r18
    29f6:	20 81       	ld	r18, Z
    29f8:	20 7f       	andi	r18, 0xF0	; 240
    29fa:	28 60       	ori	r18, 0x08	; 8
    29fc:	fc 01       	movw	r30, r24
    29fe:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    2a00:	10 92 58 40 	sts	0x4058, r1
    2a04:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    2a08:	10 92 73 50 	sts	0x5073, r1
    2a0c:	10 92 74 50 	sts	0x5074, r1
	SPICount = 0;
    2a10:	10 92 cb 50 	sts	0x50CB, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2a14:	80 e0       	ldi	r24, 0x00	; 0
    2a16:	80 93 3c 21 	sts	0x213C, r24
    2a1a:	80 93 3b 21 	sts	0x213B, r24
    2a1e:	80 93 3a 21 	sts	0x213A, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2a22:	80 ea       	ldi	r24, 0xA0	; 160
    2a24:	90 e0       	ldi	r25, 0x00	; 0
    2a26:	20 ea       	ldi	r18, 0xA0	; 160
    2a28:	30 e0       	ldi	r19, 0x00	; 0
    2a2a:	f9 01       	movw	r30, r18
    2a2c:	22 81       	ldd	r18, Z+2	; 0x02
    2a2e:	26 60       	ori	r18, 0x06	; 6
    2a30:	fc 01       	movw	r30, r24
    2a32:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2a34:	78 94       	sei

	SPICS(TRUE);
    2a36:	81 e0       	ldi	r24, 0x01	; 1
    2a38:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2a3c:	80 e8       	ldi	r24, 0x80	; 128
    2a3e:	96 e0       	ldi	r25, 0x06	; 6
    2a40:	20 e2       	ldi	r18, 0x20	; 32
    2a42:	fc 01       	movw	r30, r24
    2a44:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a46:	80 e4       	ldi	r24, 0x40	; 64
    2a48:	9a e0       	ldi	r25, 0x0A	; 10
    2a4a:	23 e2       	ldi	r18, 0x23	; 35
    2a4c:	fc 01       	movw	r30, r24
    2a4e:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2a50:	80 e4       	ldi	r24, 0x40	; 64
    2a52:	9a e0       	ldi	r25, 0x0A	; 10
    2a54:	2c 81       	ldd	r18, Y+4	; 0x04
    2a56:	42 2f       	mov	r20, r18
    2a58:	50 e0       	ldi	r21, 0x00	; 0
    2a5a:	20 e2       	ldi	r18, 0x20	; 32
    2a5c:	30 e0       	ldi	r19, 0x00	; 0
    2a5e:	02 c0       	rjmp	.+4      	; 0x2a64 <CO_collectSeismic1Channel+0x16c>
    2a60:	22 0f       	add	r18, r18
    2a62:	33 1f       	adc	r19, r19
    2a64:	4a 95       	dec	r20
    2a66:	e2 f7       	brpl	.-8      	; 0x2a60 <CO_collectSeismic1Channel+0x168>
    2a68:	fc 01       	movw	r30, r24
    2a6a:	26 a3       	lds	r18, 0x56
    2a6c:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2a6e:	80 e4       	ldi	r24, 0x40	; 64
    2a70:	9a e0       	ldi	r25, 0x0A	; 10
    2a72:	2c 81       	ldd	r18, Y+4	; 0x04
    2a74:	42 2f       	mov	r20, r18
    2a76:	50 e0       	ldi	r21, 0x00	; 0
    2a78:	20 e1       	ldi	r18, 0x10	; 16
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	04 2e       	mov	r0, r20
    2a7e:	02 c0       	rjmp	.+4      	; 0x2a84 <CO_collectSeismic1Channel+0x18c>
    2a80:	22 0f       	add	r18, r18
    2a82:	33 1f       	adc	r19, r19
    2a84:	0a 94       	dec	r0
    2a86:	e2 f7       	brpl	.-8      	; 0x2a80 <CO_collectSeismic1Channel+0x188>
    2a88:	fc 01       	movw	r30, r24
    2a8a:	22 af       	sts	0x72, r18
    2a8c:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2a8e:	80 e4       	ldi	r24, 0x40	; 64
    2a90:	9a e0       	ldi	r25, 0x0A	; 10
    2a92:	20 e4       	ldi	r18, 0x40	; 64
    2a94:	3a e0       	ldi	r19, 0x0A	; 10
    2a96:	f9 01       	movw	r30, r18
    2a98:	20 81       	ld	r18, Z
    2a9a:	20 7f       	andi	r18, 0xF0	; 240
    2a9c:	21 60       	ori	r18, 0x01	; 1
    2a9e:	fc 01       	movw	r30, r24
    2aa0:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2aa2:	00 00       	nop
    2aa4:	80 91 73 50 	lds	r24, 0x5073
    2aa8:	90 91 74 50 	lds	r25, 0x5074
    2aac:	f5 e5       	ldi	r31, 0x55	; 85
    2aae:	83 35       	cpi	r24, 0x53	; 83
    2ab0:	9f 07       	cpc	r25, r31
    2ab2:	c0 f3       	brcs	.-16     	; 0x2aa4 <CO_collectSeismic1Channel+0x1ac>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2ab4:	80 e0       	ldi	r24, 0x00	; 0
    2ab6:	99 e0       	ldi	r25, 0x09	; 9
    2ab8:	20 e0       	ldi	r18, 0x00	; 0
    2aba:	39 e0       	ldi	r19, 0x09	; 9
    2abc:	f9 01       	movw	r30, r18
    2abe:	20 81       	ld	r18, Z
    2ac0:	20 7f       	andi	r18, 0xF0	; 240
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2ac6:	80 e4       	ldi	r24, 0x40	; 64
    2ac8:	9a e0       	ldi	r25, 0x0A	; 10
    2aca:	20 e4       	ldi	r18, 0x40	; 64
    2acc:	3a e0       	ldi	r19, 0x0A	; 10
    2ace:	f9 01       	movw	r30, r18
    2ad0:	20 81       	ld	r18, Z
    2ad2:	20 7f       	andi	r18, 0xF0	; 240
    2ad4:	fc 01       	movw	r30, r24
    2ad6:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2ad8:	80 ea       	ldi	r24, 0xA0	; 160
    2ada:	90 e0       	ldi	r25, 0x00	; 0
    2adc:	20 ea       	ldi	r18, 0xA0	; 160
    2ade:	30 e0       	ldi	r19, 0x00	; 0
    2ae0:	f9 01       	movw	r30, r18
    2ae2:	22 81       	ldd	r18, Z+2	; 0x02
    2ae4:	29 7f       	andi	r18, 0xF9	; 249
    2ae6:	fc 01       	movw	r30, r24
    2ae8:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2aea:	f8 94       	cli

	SPICS(FALSE);
    2aec:	80 e0       	ldi	r24, 0x00	; 0
    2aee:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    2af2:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	enableADCMUX(FALSE);
    2af6:	80 e0       	ldi	r24, 0x00	; 0
    2af8:	0e 94 cf 08 	call	0x119e	; 0x119e <enableADCMUX>
	ADCPower(FALSE);
    2afc:	80 e0       	ldi	r24, 0x00	; 0
    2afe:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	
}
    2b02:	2c 96       	adiw	r28, 0x0c	; 12
    2b04:	cd bf       	out	0x3d, r28	; 61
    2b06:	de bf       	out	0x3e, r29	; 62
    2b08:	df 91       	pop	r29
    2b0a:	cf 91       	pop	r28
    2b0c:	0f 91       	pop	r16
    2b0e:	ef 90       	pop	r14
    2b10:	df 90       	pop	r13
    2b12:	cf 90       	pop	r12
    2b14:	bf 90       	pop	r11
    2b16:	af 90       	pop	r10
    2b18:	9f 90       	pop	r9
    2b1a:	8f 90       	pop	r8
    2b1c:	08 95       	ret

00002b1e <__vector_79>:

ISR(TCD0_CCA_vect) {
    2b1e:	1f 92       	push	r1
    2b20:	0f 92       	push	r0
    2b22:	0f b6       	in	r0, 0x3f	; 63
    2b24:	0f 92       	push	r0
    2b26:	00 90 3b 00 	lds	r0, 0x003B
    2b2a:	0f 92       	push	r0
    2b2c:	11 24       	eor	r1, r1
    2b2e:	2f 93       	push	r18
    2b30:	3f 93       	push	r19
    2b32:	4f 93       	push	r20
    2b34:	5f 93       	push	r21
    2b36:	6f 93       	push	r22
    2b38:	7f 93       	push	r23
    2b3a:	8f 93       	push	r24
    2b3c:	9f 93       	push	r25
    2b3e:	af 93       	push	r26
    2b40:	bf 93       	push	r27
    2b42:	ef 93       	push	r30
    2b44:	ff 93       	push	r31
    2b46:	cf 93       	push	r28
    2b48:	df 93       	push	r29
    2b4a:	cd b7       	in	r28, 0x3d	; 61
    2b4c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2b4e:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
}
    2b52:	df 91       	pop	r29
    2b54:	cf 91       	pop	r28
    2b56:	ff 91       	pop	r31
    2b58:	ef 91       	pop	r30
    2b5a:	bf 91       	pop	r27
    2b5c:	af 91       	pop	r26
    2b5e:	9f 91       	pop	r25
    2b60:	8f 91       	pop	r24
    2b62:	7f 91       	pop	r23
    2b64:	6f 91       	pop	r22
    2b66:	5f 91       	pop	r21
    2b68:	4f 91       	pop	r20
    2b6a:	3f 91       	pop	r19
    2b6c:	2f 91       	pop	r18
    2b6e:	0f 90       	pop	r0
    2b70:	00 92 3b 00 	sts	0x003B, r0
    2b74:	0f 90       	pop	r0
    2b76:	0f be       	out	0x3f, r0	; 63
    2b78:	0f 90       	pop	r0
    2b7a:	1f 90       	pop	r1
    2b7c:	18 95       	reti

00002b7e <__vector_80>:

ISR(TCD0_CCB_vect) {
    2b7e:	1f 92       	push	r1
    2b80:	0f 92       	push	r0
    2b82:	0f b6       	in	r0, 0x3f	; 63
    2b84:	0f 92       	push	r0
    2b86:	00 90 3b 00 	lds	r0, 0x003B
    2b8a:	0f 92       	push	r0
    2b8c:	11 24       	eor	r1, r1
    2b8e:	2f 93       	push	r18
    2b90:	3f 93       	push	r19
    2b92:	4f 93       	push	r20
    2b94:	5f 93       	push	r21
    2b96:	6f 93       	push	r22
    2b98:	7f 93       	push	r23
    2b9a:	8f 93       	push	r24
    2b9c:	9f 93       	push	r25
    2b9e:	af 93       	push	r26
    2ba0:	bf 93       	push	r27
    2ba2:	ef 93       	push	r30
    2ba4:	ff 93       	push	r31
    2ba6:	cf 93       	push	r28
    2ba8:	df 93       	push	r29
    2baa:	cd b7       	in	r28, 0x3d	; 61
    2bac:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2bae:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
}
    2bb2:	df 91       	pop	r29
    2bb4:	cf 91       	pop	r28
    2bb6:	ff 91       	pop	r31
    2bb8:	ef 91       	pop	r30
    2bba:	bf 91       	pop	r27
    2bbc:	af 91       	pop	r26
    2bbe:	9f 91       	pop	r25
    2bc0:	8f 91       	pop	r24
    2bc2:	7f 91       	pop	r23
    2bc4:	6f 91       	pop	r22
    2bc6:	5f 91       	pop	r21
    2bc8:	4f 91       	pop	r20
    2bca:	3f 91       	pop	r19
    2bcc:	2f 91       	pop	r18
    2bce:	0f 90       	pop	r0
    2bd0:	00 92 3b 00 	sts	0x003B, r0
    2bd4:	0f 90       	pop	r0
    2bd6:	0f be       	out	0x3f, r0	; 63
    2bd8:	0f 90       	pop	r0
    2bda:	1f 90       	pop	r1
    2bdc:	18 95       	reti

00002bde <__vector_81>:

ISR(TCD0_CCC_vect) {
    2bde:	1f 92       	push	r1
    2be0:	0f 92       	push	r0
    2be2:	0f b6       	in	r0, 0x3f	; 63
    2be4:	0f 92       	push	r0
    2be6:	00 90 3b 00 	lds	r0, 0x003B
    2bea:	0f 92       	push	r0
    2bec:	11 24       	eor	r1, r1
    2bee:	2f 93       	push	r18
    2bf0:	3f 93       	push	r19
    2bf2:	4f 93       	push	r20
    2bf4:	5f 93       	push	r21
    2bf6:	6f 93       	push	r22
    2bf8:	7f 93       	push	r23
    2bfa:	8f 93       	push	r24
    2bfc:	9f 93       	push	r25
    2bfe:	af 93       	push	r26
    2c00:	bf 93       	push	r27
    2c02:	ef 93       	push	r30
    2c04:	ff 93       	push	r31
    2c06:	cf 93       	push	r28
    2c08:	df 93       	push	r29
    2c0a:	cd b7       	in	r28, 0x3d	; 61
    2c0c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2c0e:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
}
    2c12:	df 91       	pop	r29
    2c14:	cf 91       	pop	r28
    2c16:	ff 91       	pop	r31
    2c18:	ef 91       	pop	r30
    2c1a:	bf 91       	pop	r27
    2c1c:	af 91       	pop	r26
    2c1e:	9f 91       	pop	r25
    2c20:	8f 91       	pop	r24
    2c22:	7f 91       	pop	r23
    2c24:	6f 91       	pop	r22
    2c26:	5f 91       	pop	r21
    2c28:	4f 91       	pop	r20
    2c2a:	3f 91       	pop	r19
    2c2c:	2f 91       	pop	r18
    2c2e:	0f 90       	pop	r0
    2c30:	00 92 3b 00 	sts	0x003B, r0
    2c34:	0f 90       	pop	r0
    2c36:	0f be       	out	0x3f, r0	; 63
    2c38:	0f 90       	pop	r0
    2c3a:	1f 90       	pop	r1
    2c3c:	18 95       	reti

00002c3e <__vector_82>:

ISR(TCD0_CCD_vect) {
    2c3e:	1f 92       	push	r1
    2c40:	0f 92       	push	r0
    2c42:	0f b6       	in	r0, 0x3f	; 63
    2c44:	0f 92       	push	r0
    2c46:	00 90 3b 00 	lds	r0, 0x003B
    2c4a:	0f 92       	push	r0
    2c4c:	11 24       	eor	r1, r1
    2c4e:	2f 93       	push	r18
    2c50:	3f 93       	push	r19
    2c52:	4f 93       	push	r20
    2c54:	5f 93       	push	r21
    2c56:	6f 93       	push	r22
    2c58:	7f 93       	push	r23
    2c5a:	8f 93       	push	r24
    2c5c:	9f 93       	push	r25
    2c5e:	af 93       	push	r26
    2c60:	bf 93       	push	r27
    2c62:	ef 93       	push	r30
    2c64:	ff 93       	push	r31
    2c66:	cf 93       	push	r28
    2c68:	df 93       	push	r29
    2c6a:	cd b7       	in	r28, 0x3d	; 61
    2c6c:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2c6e:	0e 94 81 16 	call	0x2d02	; 0x2d02 <sampleCurrentChannel>
	SPICount = 0;
    2c72:	10 92 cb 50 	sts	0x50CB, r1
}
    2c76:	df 91       	pop	r29
    2c78:	cf 91       	pop	r28
    2c7a:	ff 91       	pop	r31
    2c7c:	ef 91       	pop	r30
    2c7e:	bf 91       	pop	r27
    2c80:	af 91       	pop	r26
    2c82:	9f 91       	pop	r25
    2c84:	8f 91       	pop	r24
    2c86:	7f 91       	pop	r23
    2c88:	6f 91       	pop	r22
    2c8a:	5f 91       	pop	r21
    2c8c:	4f 91       	pop	r20
    2c8e:	3f 91       	pop	r19
    2c90:	2f 91       	pop	r18
    2c92:	0f 90       	pop	r0
    2c94:	00 92 3b 00 	sts	0x003B, r0
    2c98:	0f 90       	pop	r0
    2c9a:	0f be       	out	0x3f, r0	; 63
    2c9c:	0f 90       	pop	r0
    2c9e:	1f 90       	pop	r1
    2ca0:	18 95       	reti

00002ca2 <__vector_77>:

ISR(TCD0_OVF_vect) {
    2ca2:	1f 92       	push	r1
    2ca4:	0f 92       	push	r0
    2ca6:	0f b6       	in	r0, 0x3f	; 63
    2ca8:	0f 92       	push	r0
    2caa:	00 90 3b 00 	lds	r0, 0x003B
    2cae:	0f 92       	push	r0
    2cb0:	11 24       	eor	r1, r1
    2cb2:	2f 93       	push	r18
    2cb4:	3f 93       	push	r19
    2cb6:	4f 93       	push	r20
    2cb8:	5f 93       	push	r21
    2cba:	6f 93       	push	r22
    2cbc:	7f 93       	push	r23
    2cbe:	8f 93       	push	r24
    2cc0:	9f 93       	push	r25
    2cc2:	af 93       	push	r26
    2cc4:	bf 93       	push	r27
    2cc6:	ef 93       	push	r30
    2cc8:	ff 93       	push	r31
    2cca:	cf 93       	push	r28
    2ccc:	df 93       	push	r29
    2cce:	cd b7       	in	r28, 0x3d	; 61
    2cd0:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    2cd2:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <writeSE2FRAM>
}
    2cd6:	df 91       	pop	r29
    2cd8:	cf 91       	pop	r28
    2cda:	ff 91       	pop	r31
    2cdc:	ef 91       	pop	r30
    2cde:	bf 91       	pop	r27
    2ce0:	af 91       	pop	r26
    2ce2:	9f 91       	pop	r25
    2ce4:	8f 91       	pop	r24
    2ce6:	7f 91       	pop	r23
    2ce8:	6f 91       	pop	r22
    2cea:	5f 91       	pop	r21
    2cec:	4f 91       	pop	r20
    2cee:	3f 91       	pop	r19
    2cf0:	2f 91       	pop	r18
    2cf2:	0f 90       	pop	r0
    2cf4:	00 92 3b 00 	sts	0x003B, r0
    2cf8:	0f 90       	pop	r0
    2cfa:	0f be       	out	0x3f, r0	; 63
    2cfc:	0f 90       	pop	r0
    2cfe:	1f 90       	pop	r1
    2d00:	18 95       	reti

00002d02 <sampleCurrentChannel>:

void sampleCurrentChannel() {
    2d02:	cf 93       	push	r28
    2d04:	df 93       	push	r29
    2d06:	cd b7       	in	r28, 0x3d	; 61
    2d08:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2d0a:	80 ea       	ldi	r24, 0xA0	; 160
    2d0c:	96 e0       	ldi	r25, 0x06	; 6
    2d0e:	22 e0       	ldi	r18, 0x02	; 2
    2d10:	fc 01       	movw	r30, r24
    2d12:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d14:	80 ec       	ldi	r24, 0xC0	; 192
    2d16:	98 e0       	ldi	r25, 0x08	; 8
    2d18:	2a ea       	ldi	r18, 0xAA	; 170
    2d1a:	fc 01       	movw	r30, r24
    2d1c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d1e:	00 00       	nop
    2d20:	80 ec       	ldi	r24, 0xC0	; 192
    2d22:	98 e0       	ldi	r25, 0x08	; 8
    2d24:	fc 01       	movw	r30, r24
    2d26:	82 81       	ldd	r24, Z+2	; 0x02
    2d28:	88 23       	and	r24, r24
    2d2a:	d4 f7       	brge	.-12     	; 0x2d20 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    2d2c:	80 91 cb 50 	lds	r24, 0x50CB
    2d30:	88 2f       	mov	r24, r24
    2d32:	90 e0       	ldi	r25, 0x00	; 0
    2d34:	20 ec       	ldi	r18, 0xC0	; 192
    2d36:	38 e0       	ldi	r19, 0x08	; 8
    2d38:	f9 01       	movw	r30, r18
    2d3a:	23 81       	ldd	r18, Z+3	; 0x03
    2d3c:	8a 59       	subi	r24, 0x9A	; 154
    2d3e:	9f 4a       	sbci	r25, 0xAF	; 175
    2d40:	fc 01       	movw	r30, r24
    2d42:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d44:	80 ec       	ldi	r24, 0xC0	; 192
    2d46:	98 e0       	ldi	r25, 0x08	; 8
    2d48:	2a ea       	ldi	r18, 0xAA	; 170
    2d4a:	fc 01       	movw	r30, r24
    2d4c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d4e:	00 00       	nop
    2d50:	80 ec       	ldi	r24, 0xC0	; 192
    2d52:	98 e0       	ldi	r25, 0x08	; 8
    2d54:	fc 01       	movw	r30, r24
    2d56:	82 81       	ldd	r24, Z+2	; 0x02
    2d58:	88 23       	and	r24, r24
    2d5a:	d4 f7       	brge	.-12     	; 0x2d50 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2d5c:	80 91 cb 50 	lds	r24, 0x50CB
    2d60:	88 2f       	mov	r24, r24
    2d62:	90 e0       	ldi	r25, 0x00	; 0
    2d64:	01 96       	adiw	r24, 0x01	; 1
    2d66:	20 ec       	ldi	r18, 0xC0	; 192
    2d68:	38 e0       	ldi	r19, 0x08	; 8
    2d6a:	f9 01       	movw	r30, r18
    2d6c:	23 81       	ldd	r18, Z+3	; 0x03
    2d6e:	8a 59       	subi	r24, 0x9A	; 154
    2d70:	9f 4a       	sbci	r25, 0xAF	; 175
    2d72:	fc 01       	movw	r30, r24
    2d74:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d76:	80 ec       	ldi	r24, 0xC0	; 192
    2d78:	98 e0       	ldi	r25, 0x08	; 8
    2d7a:	2a ea       	ldi	r18, 0xAA	; 170
    2d7c:	fc 01       	movw	r30, r24
    2d7e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d80:	00 00       	nop
    2d82:	80 ec       	ldi	r24, 0xC0	; 192
    2d84:	98 e0       	ldi	r25, 0x08	; 8
    2d86:	fc 01       	movw	r30, r24
    2d88:	82 81       	ldd	r24, Z+2	; 0x02
    2d8a:	88 23       	and	r24, r24
    2d8c:	d4 f7       	brge	.-12     	; 0x2d82 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2d8e:	80 91 cb 50 	lds	r24, 0x50CB
    2d92:	88 2f       	mov	r24, r24
    2d94:	90 e0       	ldi	r25, 0x00	; 0
    2d96:	02 96       	adiw	r24, 0x02	; 2
    2d98:	20 ec       	ldi	r18, 0xC0	; 192
    2d9a:	38 e0       	ldi	r19, 0x08	; 8
    2d9c:	f9 01       	movw	r30, r18
    2d9e:	23 81       	ldd	r18, Z+3	; 0x03
    2da0:	8a 59       	subi	r24, 0x9A	; 154
    2da2:	9f 4a       	sbci	r25, 0xAF	; 175
    2da4:	fc 01       	movw	r30, r24
    2da6:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2da8:	80 ea       	ldi	r24, 0xA0	; 160
    2daa:	96 e0       	ldi	r25, 0x06	; 6
    2dac:	22 e0       	ldi	r18, 0x02	; 2
    2dae:	fc 01       	movw	r30, r24
    2db0:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2db2:	80 91 cb 50 	lds	r24, 0x50CB
    2db6:	8d 5f       	subi	r24, 0xFD	; 253
    2db8:	80 93 cb 50 	sts	0x50CB, r24
}
    2dbc:	df 91       	pop	r29
    2dbe:	cf 91       	pop	r28
    2dc0:	08 95       	ret

00002dc2 <writeSE2FRAM>:

void writeSE2FRAM() {
    2dc2:	cf 93       	push	r28
    2dc4:	df 93       	push	r29
    2dc6:	cd b7       	in	r28, 0x3d	; 61
    2dc8:	de b7       	in	r29, 0x3e	; 62
    2dca:	29 97       	sbiw	r28, 0x09	; 9
    2dcc:	cd bf       	out	0x3d, r28	; 61
    2dce:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2dd0:	1a 82       	std	Y+2, r1	; 0x02
    2dd2:	1b 82       	std	Y+3, r1	; 0x03
    2dd4:	1c 82       	std	Y+4, r1	; 0x04
    2dd6:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2dd8:	80 91 73 50 	lds	r24, 0x5073
    2ddc:	90 91 74 50 	lds	r25, 0x5074
    2de0:	01 96       	adiw	r24, 0x01	; 1
    2de2:	80 93 73 50 	sts	0x5073, r24
    2de6:	90 93 74 50 	sts	0x5074, r25
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2dea:	80 ec       	ldi	r24, 0xC0	; 192
    2dec:	98 e0       	ldi	r25, 0x08	; 8
    2dee:	20 ed       	ldi	r18, 0xD0	; 208
    2df0:	fc 01       	movw	r30, r24
    2df2:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2df4:	19 82       	std	Y+1, r1	; 0x01
    2df6:	4f c0       	rjmp	.+158    	; 0x2e96 <writeSE2FRAM+0xd4>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2df8:	89 81       	ldd	r24, Y+1	; 0x01
    2dfa:	88 2f       	mov	r24, r24
    2dfc:	90 e0       	ldi	r25, 0x00	; 0
    2dfe:	8a 59       	subi	r24, 0x9A	; 154
    2e00:	9f 4a       	sbci	r25, 0xAF	; 175
    2e02:	fc 01       	movw	r30, r24
    2e04:	80 81       	ld	r24, Z
    2e06:	88 23       	and	r24, r24
    2e08:	3c f4       	brge	.+14     	; 0x2e18 <writeSE2FRAM+0x56>
    2e0a:	ce 01       	movw	r24, r28
    2e0c:	06 96       	adiw	r24, 0x06	; 6
    2e0e:	03 96       	adiw	r24, 0x03	; 3
    2e10:	2f ef       	ldi	r18, 0xFF	; 255
    2e12:	fc 01       	movw	r30, r24
    2e14:	20 83       	st	Z, r18
    2e16:	05 c0       	rjmp	.+10     	; 0x2e22 <writeSE2FRAM+0x60>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2e18:	ce 01       	movw	r24, r28
    2e1a:	06 96       	adiw	r24, 0x06	; 6
    2e1c:	03 96       	adiw	r24, 0x03	; 3
    2e1e:	fc 01       	movw	r30, r24
    2e20:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2e22:	ce 01       	movw	r24, r28
    2e24:	06 96       	adiw	r24, 0x06	; 6
    2e26:	02 96       	adiw	r24, 0x02	; 2
    2e28:	29 81       	ldd	r18, Y+1	; 0x01
    2e2a:	22 2f       	mov	r18, r18
    2e2c:	30 e0       	ldi	r19, 0x00	; 0
    2e2e:	2a 59       	subi	r18, 0x9A	; 154
    2e30:	3f 4a       	sbci	r19, 0xAF	; 175
    2e32:	f9 01       	movw	r30, r18
    2e34:	20 81       	ld	r18, Z
    2e36:	fc 01       	movw	r30, r24
    2e38:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2e3a:	ce 01       	movw	r24, r28
    2e3c:	06 96       	adiw	r24, 0x06	; 6
    2e3e:	01 96       	adiw	r24, 0x01	; 1
    2e40:	29 81       	ldd	r18, Y+1	; 0x01
    2e42:	22 2f       	mov	r18, r18
    2e44:	30 e0       	ldi	r19, 0x00	; 0
    2e46:	2f 5f       	subi	r18, 0xFF	; 255
    2e48:	3f 4f       	sbci	r19, 0xFF	; 255
    2e4a:	2a 59       	subi	r18, 0x9A	; 154
    2e4c:	3f 4a       	sbci	r19, 0xAF	; 175
    2e4e:	f9 01       	movw	r30, r18
    2e50:	20 81       	ld	r18, Z
    2e52:	fc 01       	movw	r30, r24
    2e54:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2e56:	ce 01       	movw	r24, r28
    2e58:	06 96       	adiw	r24, 0x06	; 6
    2e5a:	29 81       	ldd	r18, Y+1	; 0x01
    2e5c:	22 2f       	mov	r18, r18
    2e5e:	30 e0       	ldi	r19, 0x00	; 0
    2e60:	2e 5f       	subi	r18, 0xFE	; 254
    2e62:	3f 4f       	sbci	r19, 0xFF	; 255
    2e64:	2a 59       	subi	r18, 0x9A	; 154
    2e66:	3f 4a       	sbci	r19, 0xAF	; 175
    2e68:	f9 01       	movw	r30, r18
    2e6a:	20 81       	ld	r18, Z
    2e6c:	fc 01       	movw	r30, r24
    2e6e:	20 83       	st	Z, r18
		sum += currentSample;
    2e70:	2a 81       	ldd	r18, Y+2	; 0x02
    2e72:	3b 81       	ldd	r19, Y+3	; 0x03
    2e74:	4c 81       	ldd	r20, Y+4	; 0x04
    2e76:	5d 81       	ldd	r21, Y+5	; 0x05
    2e78:	8e 81       	ldd	r24, Y+6	; 0x06
    2e7a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e7c:	a8 85       	ldd	r26, Y+8	; 0x08
    2e7e:	b9 85       	ldd	r27, Y+9	; 0x09
    2e80:	82 0f       	add	r24, r18
    2e82:	93 1f       	adc	r25, r19
    2e84:	a4 1f       	adc	r26, r20
    2e86:	b5 1f       	adc	r27, r21
    2e88:	8a 83       	std	Y+2, r24	; 0x02
    2e8a:	9b 83       	std	Y+3, r25	; 0x03
    2e8c:	ac 83       	std	Y+4, r26	; 0x04
    2e8e:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2e90:	89 81       	ldd	r24, Y+1	; 0x01
    2e92:	8d 5f       	subi	r24, 0xFD	; 253
    2e94:	89 83       	std	Y+1, r24	; 0x01
    2e96:	89 81       	ldd	r24, Y+1	; 0x01
    2e98:	8c 30       	cpi	r24, 0x0C	; 12
    2e9a:	08 f4       	brcc	.+2      	; 0x2e9e <writeSE2FRAM+0xdc>
    2e9c:	ad cf       	rjmp	.-166    	; 0x2df8 <writeSE2FRAM+0x36>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea2:	ac 81       	ldd	r26, Y+4	; 0x04
    2ea4:	bd 81       	ldd	r27, Y+5	; 0x05
    2ea6:	24 e0       	ldi	r18, 0x04	; 4
    2ea8:	30 e0       	ldi	r19, 0x00	; 0
    2eaa:	40 e0       	ldi	r20, 0x00	; 0
    2eac:	50 e0       	ldi	r21, 0x00	; 0
    2eae:	bc 01       	movw	r22, r24
    2eb0:	cd 01       	movw	r24, r26
    2eb2:	0e 94 da 5e 	call	0xbdb4	; 0xbdb4 <__divmodsi4>
    2eb6:	da 01       	movw	r26, r20
    2eb8:	c9 01       	movw	r24, r18
    2eba:	8a 83       	std	Y+2, r24	; 0x02
    2ebc:	9b 83       	std	Y+3, r25	; 0x03
    2ebe:	ac 83       	std	Y+4, r26	; 0x04
    2ec0:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2ec2:	ce 01       	movw	r24, r28
    2ec4:	02 96       	adiw	r24, 0x02	; 2
    2ec6:	fc 01       	movw	r30, r24
    2ec8:	80 81       	ld	r24, Z
    2eca:	80 93 68 50 	sts	0x5068, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2ece:	ce 01       	movw	r24, r28
    2ed0:	02 96       	adiw	r24, 0x02	; 2
    2ed2:	fc 01       	movw	r30, r24
    2ed4:	81 81       	ldd	r24, Z+1	; 0x01
    2ed6:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2eda:	ce 01       	movw	r24, r28
    2edc:	02 96       	adiw	r24, 0x02	; 2
    2ede:	fc 01       	movw	r30, r24
    2ee0:	82 81       	ldd	r24, Z+2	; 0x02
    2ee2:	80 93 66 50 	sts	0x5066, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2ee6:	80 e4       	ldi	r24, 0x40	; 64
    2ee8:	96 e0       	ldi	r25, 0x06	; 6
    2eea:	20 e1       	ldi	r18, 0x10	; 16
    2eec:	fc 01       	movw	r30, r24
    2eee:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2ef0:	80 e2       	ldi	r24, 0x20	; 32
    2ef2:	96 e0       	ldi	r25, 0x06	; 6
    2ef4:	28 e0       	ldi	r18, 0x08	; 8
    2ef6:	fc 01       	movw	r30, r24
    2ef8:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2efa:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2efc:	80 ec       	ldi	r24, 0xC0	; 192
    2efe:	98 e0       	ldi	r25, 0x08	; 8
    2f00:	26 e0       	ldi	r18, 0x06	; 6
    2f02:	fc 01       	movw	r30, r24
    2f04:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f06:	00 00       	nop
    2f08:	80 ec       	ldi	r24, 0xC0	; 192
    2f0a:	98 e0       	ldi	r25, 0x08	; 8
    2f0c:	fc 01       	movw	r30, r24
    2f0e:	82 81       	ldd	r24, Z+2	; 0x02
    2f10:	88 23       	and	r24, r24
    2f12:	d4 f7       	brge	.-12     	; 0x2f08 <writeSE2FRAM+0x146>
	SPIBuffer[12] = SPIC.DATA;
    2f14:	80 ec       	ldi	r24, 0xC0	; 192
    2f16:	98 e0       	ldi	r25, 0x08	; 8
    2f18:	fc 01       	movw	r30, r24
    2f1a:	83 81       	ldd	r24, Z+3	; 0x03
    2f1c:	80 93 72 50 	sts	0x5072, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2f20:	80 e2       	ldi	r24, 0x20	; 32
    2f22:	96 e0       	ldi	r25, 0x06	; 6
    2f24:	28 e0       	ldi	r18, 0x08	; 8
    2f26:	fc 01       	movw	r30, r24
    2f28:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2f2a:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2f2c:	80 e2       	ldi	r24, 0x20	; 32
    2f2e:	96 e0       	ldi	r25, 0x06	; 6
    2f30:	28 e0       	ldi	r18, 0x08	; 8
    2f32:	fc 01       	movw	r30, r24
    2f34:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2f36:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2f38:	80 ec       	ldi	r24, 0xC0	; 192
    2f3a:	98 e0       	ldi	r25, 0x08	; 8
    2f3c:	22 e0       	ldi	r18, 0x02	; 2
    2f3e:	fc 01       	movw	r30, r24
    2f40:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f42:	00 00       	nop
    2f44:	80 ec       	ldi	r24, 0xC0	; 192
    2f46:	98 e0       	ldi	r25, 0x08	; 8
    2f48:	fc 01       	movw	r30, r24
    2f4a:	82 81       	ldd	r24, Z+2	; 0x02
    2f4c:	88 23       	and	r24, r24
    2f4e:	d4 f7       	brge	.-12     	; 0x2f44 <writeSE2FRAM+0x182>
	SPIBuffer[12] = SPIC.DATA;
    2f50:	80 ec       	ldi	r24, 0xC0	; 192
    2f52:	98 e0       	ldi	r25, 0x08	; 8
    2f54:	fc 01       	movw	r30, r24
    2f56:	83 81       	ldd	r24, Z+3	; 0x03
    2f58:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2f5c:	80 ec       	ldi	r24, 0xC0	; 192
    2f5e:	98 e0       	ldi	r25, 0x08	; 8
    2f60:	20 91 59 40 	lds	r18, 0x4059
    2f64:	fc 01       	movw	r30, r24
    2f66:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f68:	00 00       	nop
    2f6a:	80 ec       	ldi	r24, 0xC0	; 192
    2f6c:	98 e0       	ldi	r25, 0x08	; 8
    2f6e:	fc 01       	movw	r30, r24
    2f70:	82 81       	ldd	r24, Z+2	; 0x02
    2f72:	88 23       	and	r24, r24
    2f74:	d4 f7       	brge	.-12     	; 0x2f6a <writeSE2FRAM+0x1a8>
	SPIBuffer[12] = SPIC.DATA;
    2f76:	80 ec       	ldi	r24, 0xC0	; 192
    2f78:	98 e0       	ldi	r25, 0x08	; 8
    2f7a:	fc 01       	movw	r30, r24
    2f7c:	83 81       	ldd	r24, Z+3	; 0x03
    2f7e:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2f82:	80 ec       	ldi	r24, 0xC0	; 192
    2f84:	98 e0       	ldi	r25, 0x08	; 8
    2f86:	28 e5       	ldi	r18, 0x58	; 88
    2f88:	30 e4       	ldi	r19, 0x40	; 64
    2f8a:	f9 01       	movw	r30, r18
    2f8c:	20 81       	ld	r18, Z
    2f8e:	fc 01       	movw	r30, r24
    2f90:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f92:	00 00       	nop
    2f94:	80 ec       	ldi	r24, 0xC0	; 192
    2f96:	98 e0       	ldi	r25, 0x08	; 8
    2f98:	fc 01       	movw	r30, r24
    2f9a:	82 81       	ldd	r24, Z+2	; 0x02
    2f9c:	88 23       	and	r24, r24
    2f9e:	d4 f7       	brge	.-12     	; 0x2f94 <writeSE2FRAM+0x1d2>
	SPIBuffer[12] = SPIC.DATA;
    2fa0:	80 ec       	ldi	r24, 0xC0	; 192
    2fa2:	98 e0       	ldi	r25, 0x08	; 8
    2fa4:	fc 01       	movw	r30, r24
    2fa6:	83 81       	ldd	r24, Z+3	; 0x03
    2fa8:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[0];
    2fac:	80 ec       	ldi	r24, 0xC0	; 192
    2fae:	98 e0       	ldi	r25, 0x08	; 8
    2fb0:	20 91 66 50 	lds	r18, 0x5066
    2fb4:	fc 01       	movw	r30, r24
    2fb6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fb8:	00 00       	nop
    2fba:	80 ec       	ldi	r24, 0xC0	; 192
    2fbc:	98 e0       	ldi	r25, 0x08	; 8
    2fbe:	fc 01       	movw	r30, r24
    2fc0:	82 81       	ldd	r24, Z+2	; 0x02
    2fc2:	88 23       	and	r24, r24
    2fc4:	d4 f7       	brge	.-12     	; 0x2fba <writeSE2FRAM+0x1f8>
	SPIBuffer[12] = SPIC.DATA;
    2fc6:	80 ec       	ldi	r24, 0xC0	; 192
    2fc8:	98 e0       	ldi	r25, 0x08	; 8
    2fca:	fc 01       	movw	r30, r24
    2fcc:	83 81       	ldd	r24, Z+3	; 0x03
    2fce:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[1];
    2fd2:	80 ec       	ldi	r24, 0xC0	; 192
    2fd4:	98 e0       	ldi	r25, 0x08	; 8
    2fd6:	20 91 67 50 	lds	r18, 0x5067
    2fda:	fc 01       	movw	r30, r24
    2fdc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fde:	00 00       	nop
    2fe0:	80 ec       	ldi	r24, 0xC0	; 192
    2fe2:	98 e0       	ldi	r25, 0x08	; 8
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	82 81       	ldd	r24, Z+2	; 0x02
    2fe8:	88 23       	and	r24, r24
    2fea:	d4 f7       	brge	.-12     	; 0x2fe0 <writeSE2FRAM+0x21e>
	SPIBuffer[12] = SPIC.DATA;
    2fec:	80 ec       	ldi	r24, 0xC0	; 192
    2fee:	98 e0       	ldi	r25, 0x08	; 8
    2ff0:	fc 01       	movw	r30, r24
    2ff2:	83 81       	ldd	r24, Z+3	; 0x03
    2ff4:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[2];
    2ff8:	80 ec       	ldi	r24, 0xC0	; 192
    2ffa:	98 e0       	ldi	r25, 0x08	; 8
    2ffc:	20 91 68 50 	lds	r18, 0x5068
    3000:	fc 01       	movw	r30, r24
    3002:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3004:	00 00       	nop
    3006:	80 ec       	ldi	r24, 0xC0	; 192
    3008:	98 e0       	ldi	r25, 0x08	; 8
    300a:	fc 01       	movw	r30, r24
    300c:	82 81       	ldd	r24, Z+2	; 0x02
    300e:	88 23       	and	r24, r24
    3010:	d4 f7       	brge	.-12     	; 0x3006 <writeSE2FRAM+0x244>
	SPIBuffer[12] = SPIC.DATA;
    3012:	80 ec       	ldi	r24, 0xC0	; 192
    3014:	98 e0       	ldi	r25, 0x08	; 8
    3016:	fc 01       	movw	r30, r24
    3018:	83 81       	ldd	r24, Z+3	; 0x03
    301a:	80 93 72 50 	sts	0x5072, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    301e:	80 e2       	ldi	r24, 0x20	; 32
    3020:	96 e0       	ldi	r25, 0x06	; 6
    3022:	28 e0       	ldi	r18, 0x08	; 8
    3024:	fc 01       	movw	r30, r24
    3026:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3028:	80 e4       	ldi	r24, 0x40	; 64
    302a:	96 e0       	ldi	r25, 0x06	; 6
    302c:	20 e1       	ldi	r18, 0x10	; 16
    302e:	fc 01       	movw	r30, r24
    3030:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    3032:	80 ec       	ldi	r24, 0xC0	; 192
    3034:	98 e0       	ldi	r25, 0x08	; 8
    3036:	24 e5       	ldi	r18, 0x54	; 84
    3038:	fc 01       	movw	r30, r24
    303a:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    303c:	80 e4       	ldi	r24, 0x40	; 64
    303e:	96 e0       	ldi	r25, 0x06	; 6
    3040:	20 e1       	ldi	r18, 0x10	; 16
    3042:	fc 01       	movw	r30, r24
    3044:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    3046:	80 91 58 40 	lds	r24, 0x4058
    304a:	90 91 59 40 	lds	r25, 0x4059
    304e:	03 96       	adiw	r24, 0x03	; 3
    3050:	80 93 58 40 	sts	0x4058, r24
    3054:	90 93 59 40 	sts	0x4059, r25
	checksumADC[0] += SPIBuffer[0];
    3058:	90 91 3a 21 	lds	r25, 0x213A
    305c:	80 91 66 50 	lds	r24, 0x5066
    3060:	89 0f       	add	r24, r25
    3062:	80 93 3a 21 	sts	0x213A, r24
	checksumADC[1] += SPIBuffer[1];
    3066:	90 91 3b 21 	lds	r25, 0x213B
    306a:	80 91 67 50 	lds	r24, 0x5067
    306e:	89 0f       	add	r24, r25
    3070:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[2] += SPIBuffer[2];
    3074:	90 91 3c 21 	lds	r25, 0x213C
    3078:	80 91 68 50 	lds	r24, 0x5068
    307c:	89 0f       	add	r24, r25
    307e:	80 93 3c 21 	sts	0x213C, r24
}
    3082:	29 96       	adiw	r28, 0x09	; 9
    3084:	cd bf       	out	0x3d, r28	; 61
    3086:	de bf       	out	0x3e, r29	; 62
    3088:	df 91       	pop	r29
    308a:	cf 91       	pop	r28
    308c:	08 95       	ret

0000308e <calcChecksumFRAM>:


void calcChecksumFRAM() {
    308e:	2f 92       	push	r2
    3090:	3f 92       	push	r3
    3092:	4f 92       	push	r4
    3094:	5f 92       	push	r5
    3096:	6f 92       	push	r6
    3098:	7f 92       	push	r7
    309a:	8f 92       	push	r8
    309c:	9f 92       	push	r9
    309e:	af 92       	push	r10
    30a0:	bf 92       	push	r11
    30a2:	cf 92       	push	r12
    30a4:	df 92       	push	r13
    30a6:	ef 92       	push	r14
    30a8:	ff 92       	push	r15
    30aa:	0f 93       	push	r16
    30ac:	1f 93       	push	r17
    30ae:	cf 93       	push	r28
    30b0:	df 93       	push	r29
    30b2:	00 d0       	rcall	.+0      	; 0x30b4 <calcChecksumFRAM+0x26>
    30b4:	0f 92       	push	r0
    30b6:	cd b7       	in	r28, 0x3d	; 61
    30b8:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    30ba:	aa 24       	eor	r10, r10
    30bc:	bb 24       	eor	r11, r11
    30be:	cc 24       	eor	r12, r12
    30c0:	dd 24       	eor	r13, r13
    30c2:	ee 24       	eor	r14, r14
    30c4:	ff 24       	eor	r15, r15
    30c6:	00 e0       	ldi	r16, 0x00	; 0
    30c8:	10 e0       	ldi	r17, 0x00	; 0
    30ca:	a0 92 98 50 	sts	0x5098, r10
    30ce:	b0 92 99 50 	sts	0x5099, r11
    30d2:	c0 92 9a 50 	sts	0x509A, r12
    30d6:	d0 92 9b 50 	sts	0x509B, r13
    30da:	e0 92 9c 50 	sts	0x509C, r14
    30de:	f0 92 9d 50 	sts	0x509D, r15
    30e2:	00 93 9e 50 	sts	0x509E, r16
    30e6:	10 93 9f 50 	sts	0x509F, r17
    30ea:	2a 2d       	mov	r18, r10
    30ec:	3b 2d       	mov	r19, r11
    30ee:	4c 2d       	mov	r20, r12
    30f0:	5d 2d       	mov	r21, r13
    30f2:	6e 2d       	mov	r22, r14
    30f4:	7f 2d       	mov	r23, r15
    30f6:	80 2f       	mov	r24, r16
    30f8:	91 2f       	mov	r25, r17
    30fa:	20 93 90 50 	sts	0x5090, r18
    30fe:	30 93 91 50 	sts	0x5091, r19
    3102:	40 93 92 50 	sts	0x5092, r20
    3106:	50 93 93 50 	sts	0x5093, r21
    310a:	60 93 94 50 	sts	0x5094, r22
    310e:	70 93 95 50 	sts	0x5095, r23
    3112:	80 93 96 50 	sts	0x5096, r24
    3116:	90 93 97 50 	sts	0x5097, r25
    311a:	20 93 88 50 	sts	0x5088, r18
    311e:	30 93 89 50 	sts	0x5089, r19
    3122:	40 93 8a 50 	sts	0x508A, r20
    3126:	50 93 8b 50 	sts	0x508B, r21
    312a:	60 93 8c 50 	sts	0x508C, r22
    312e:	70 93 8d 50 	sts	0x508D, r23
    3132:	80 93 8e 50 	sts	0x508E, r24
    3136:	90 93 8f 50 	sts	0x508F, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    313a:	80 e0       	ldi	r24, 0x00	; 0
    313c:	80 93 3f 21 	sts	0x213F, r24
    3140:	80 93 3e 21 	sts	0x213E, r24
    3144:	80 93 3d 21 	sts	0x213D, r24
	FRAMAddress = FR_BASEADD;
    3148:	10 92 58 40 	sts	0x4058, r1
    314c:	10 92 59 40 	sts	0x4059, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3150:	19 82       	std	Y+1, r1	; 0x01
    3152:	1a 82       	std	Y+2, r1	; 0x02
    3154:	88 c2       	rjmp	.+1296   	; 0x3666 <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    3156:	81 e7       	ldi	r24, 0x71	; 113
    3158:	9c e1       	ldi	r25, 0x1C	; 28
    315a:	0e 94 38 3a 	call	0x7470	; 0x7470 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    315e:	80 91 58 40 	lds	r24, 0x4058
    3162:	90 91 59 40 	lds	r25, 0x4059
    3166:	8f 58       	subi	r24, 0x8F	; 143
    3168:	93 4e       	sbci	r25, 0xE3	; 227
    316a:	80 93 58 40 	sts	0x4058, r24
    316e:	90 93 59 40 	sts	0x4059, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3172:	1b 82       	std	Y+3, r1	; 0x03
    3174:	1c 82       	std	Y+4, r1	; 0x04
    3176:	6b c2       	rjmp	.+1238   	; 0x364e <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    3178:	8b 81       	ldd	r24, Y+3	; 0x03
    317a:	9c 81       	ldd	r25, Y+4	; 0x04
    317c:	23 e0       	ldi	r18, 0x03	; 3
    317e:	30 e0       	ldi	r19, 0x00	; 0
    3180:	b9 01       	movw	r22, r18
    3182:	0e 94 91 5e 	call	0xbd22	; 0xbd22 <__udivmodhi4>
    3186:	9c 01       	movw	r18, r24
    3188:	23 5c       	subi	r18, 0xC3	; 195
    318a:	3e 4d       	sbci	r19, 0xDE	; 222
    318c:	f9 01       	movw	r30, r18
    318e:	40 81       	ld	r20, Z
    3190:	2b 81       	ldd	r18, Y+3	; 0x03
    3192:	3c 81       	ldd	r19, Y+4	; 0x04
    3194:	20 52       	subi	r18, 0x20	; 32
    3196:	3c 4d       	sbci	r19, 0xDC	; 220
    3198:	f9 01       	movw	r30, r18
    319a:	20 81       	ld	r18, Z
    319c:	24 0f       	add	r18, r20
    319e:	83 5c       	subi	r24, 0xC3	; 195
    31a0:	9e 4d       	sbci	r25, 0xDE	; 222
    31a2:	fc 01       	movw	r30, r24
    31a4:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    31a6:	8b 81       	ldd	r24, Y+3	; 0x03
    31a8:	9c 81       	ldd	r25, Y+4	; 0x04
    31aa:	23 e0       	ldi	r18, 0x03	; 3
    31ac:	30 e0       	ldi	r19, 0x00	; 0
    31ae:	b9 01       	movw	r22, r18
    31b0:	0e 94 91 5e 	call	0xbd22	; 0xbd22 <__udivmodhi4>
    31b4:	00 97       	sbiw	r24, 0x00	; 0
    31b6:	09 f0       	breq	.+2      	; 0x31ba <calcChecksumFRAM+0x12c>
    31b8:	44 c0       	rjmp	.+136    	; 0x3242 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    31ba:	8b 81       	ldd	r24, Y+3	; 0x03
    31bc:	9c 81       	ldd	r25, Y+4	; 0x04
    31be:	80 52       	subi	r24, 0x20	; 32
    31c0:	9c 4d       	sbci	r25, 0xDC	; 220
    31c2:	fc 01       	movw	r30, r24
    31c4:	80 81       	ld	r24, Z
    31c6:	88 23       	and	r24, r24
    31c8:	d4 f4       	brge	.+52     	; 0x31fe <calcChecksumFRAM+0x170>
    31ca:	80 91 64 50 	lds	r24, 0x5064
    31ce:	90 91 65 50 	lds	r25, 0x5065
    31d2:	fc 01       	movw	r30, r24
    31d4:	10 82       	st	Z, r1
    31d6:	fc 01       	movw	r30, r24
    31d8:	11 82       	std	Z+1, r1	; 0x01
    31da:	fc 01       	movw	r30, r24
    31dc:	12 82       	std	Z+2, r1	; 0x02
    31de:	2f ef       	ldi	r18, 0xFF	; 255
    31e0:	fc 01       	movw	r30, r24
    31e2:	23 83       	std	Z+3, r18	; 0x03
    31e4:	2f ef       	ldi	r18, 0xFF	; 255
    31e6:	fc 01       	movw	r30, r24
    31e8:	24 83       	std	Z+4, r18	; 0x04
    31ea:	2f ef       	ldi	r18, 0xFF	; 255
    31ec:	fc 01       	movw	r30, r24
    31ee:	25 83       	std	Z+5, r18	; 0x05
    31f0:	2f ef       	ldi	r18, 0xFF	; 255
    31f2:	fc 01       	movw	r30, r24
    31f4:	26 83       	std	Z+6, r18	; 0x06
    31f6:	2f ef       	ldi	r18, 0xFF	; 255
    31f8:	fc 01       	movw	r30, r24
    31fa:	27 83       	std	Z+7, r18	; 0x07
    31fc:	14 c0       	rjmp	.+40     	; 0x3226 <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    31fe:	80 91 64 50 	lds	r24, 0x5064
    3202:	90 91 65 50 	lds	r25, 0x5065
    3206:	fc 01       	movw	r30, r24
    3208:	10 82       	st	Z, r1
    320a:	fc 01       	movw	r30, r24
    320c:	11 82       	std	Z+1, r1	; 0x01
    320e:	fc 01       	movw	r30, r24
    3210:	12 82       	std	Z+2, r1	; 0x02
    3212:	fc 01       	movw	r30, r24
    3214:	13 82       	std	Z+3, r1	; 0x03
    3216:	fc 01       	movw	r30, r24
    3218:	14 82       	std	Z+4, r1	; 0x04
    321a:	fc 01       	movw	r30, r24
    321c:	15 82       	std	Z+5, r1	; 0x05
    321e:	fc 01       	movw	r30, r24
    3220:	16 82       	std	Z+6, r1	; 0x06
    3222:	fc 01       	movw	r30, r24
    3224:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    3226:	80 91 64 50 	lds	r24, 0x5064
    322a:	90 91 65 50 	lds	r25, 0x5065
    322e:	02 96       	adiw	r24, 0x02	; 2
    3230:	2b 81       	ldd	r18, Y+3	; 0x03
    3232:	3c 81       	ldd	r19, Y+4	; 0x04
    3234:	20 52       	subi	r18, 0x20	; 32
    3236:	3c 4d       	sbci	r19, 0xDC	; 220
    3238:	f9 01       	movw	r30, r18
    323a:	20 81       	ld	r18, Z
    323c:	fc 01       	movw	r30, r24
    323e:	20 83       	st	Z, r18
    3240:	24 c0       	rjmp	.+72     	; 0x328a <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    3242:	8b 81       	ldd	r24, Y+3	; 0x03
    3244:	9c 81       	ldd	r25, Y+4	; 0x04
    3246:	23 e0       	ldi	r18, 0x03	; 3
    3248:	30 e0       	ldi	r19, 0x00	; 0
    324a:	b9 01       	movw	r22, r18
    324c:	0e 94 91 5e 	call	0xbd22	; 0xbd22 <__udivmodhi4>
    3250:	81 30       	cpi	r24, 0x01	; 1
    3252:	91 05       	cpc	r25, r1
    3254:	71 f4       	brne	.+28     	; 0x3272 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    3256:	80 91 64 50 	lds	r24, 0x5064
    325a:	90 91 65 50 	lds	r25, 0x5065
    325e:	01 96       	adiw	r24, 0x01	; 1
    3260:	2b 81       	ldd	r18, Y+3	; 0x03
    3262:	3c 81       	ldd	r19, Y+4	; 0x04
    3264:	20 52       	subi	r18, 0x20	; 32
    3266:	3c 4d       	sbci	r19, 0xDC	; 220
    3268:	f9 01       	movw	r30, r18
    326a:	20 81       	ld	r18, Z
    326c:	fc 01       	movw	r30, r24
    326e:	20 83       	st	Z, r18
    3270:	0c c0       	rjmp	.+24     	; 0x328a <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    3272:	80 91 64 50 	lds	r24, 0x5064
    3276:	90 91 65 50 	lds	r25, 0x5065
    327a:	2b 81       	ldd	r18, Y+3	; 0x03
    327c:	3c 81       	ldd	r19, Y+4	; 0x04
    327e:	20 52       	subi	r18, 0x20	; 32
    3280:	3c 4d       	sbci	r19, 0xDC	; 220
    3282:	f9 01       	movw	r30, r18
    3284:	20 81       	ld	r18, Z
    3286:	fc 01       	movw	r30, r24
    3288:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    328a:	8b 81       	ldd	r24, Y+3	; 0x03
    328c:	9c 81       	ldd	r25, Y+4	; 0x04
    328e:	29 e0       	ldi	r18, 0x09	; 9
    3290:	30 e0       	ldi	r19, 0x00	; 0
    3292:	b9 01       	movw	r22, r18
    3294:	0e 94 91 5e 	call	0xbd22	; 0xbd22 <__udivmodhi4>
    3298:	82 30       	cpi	r24, 0x02	; 2
    329a:	91 05       	cpc	r25, r1
    329c:	09 f0       	breq	.+2      	; 0x32a0 <calcChecksumFRAM+0x212>
    329e:	94 c0       	rjmp	.+296    	; 0x33c8 <calcChecksumFRAM+0x33a>
    32a0:	a0 90 88 50 	lds	r10, 0x5088
    32a4:	b0 90 89 50 	lds	r11, 0x5089
    32a8:	c0 90 8a 50 	lds	r12, 0x508A
    32ac:	d0 90 8b 50 	lds	r13, 0x508B
    32b0:	e0 90 8c 50 	lds	r14, 0x508C
    32b4:	f0 90 8d 50 	lds	r15, 0x508D
    32b8:	00 91 8e 50 	lds	r16, 0x508E
    32bc:	10 91 8f 50 	lds	r17, 0x508F
    32c0:	80 91 64 50 	lds	r24, 0x5064
    32c4:	90 91 65 50 	lds	r25, 0x5065
    32c8:	fc 01       	movw	r30, r24
    32ca:	20 80       	ld	r2, Z
    32cc:	fc 01       	movw	r30, r24
    32ce:	31 80       	ldd	r3, Z+1	; 0x01
    32d0:	fc 01       	movw	r30, r24
    32d2:	42 80       	ldd	r4, Z+2	; 0x02
    32d4:	fc 01       	movw	r30, r24
    32d6:	53 80       	ldd	r5, Z+3	; 0x03
    32d8:	fc 01       	movw	r30, r24
    32da:	64 80       	ldd	r6, Z+4	; 0x04
    32dc:	fc 01       	movw	r30, r24
    32de:	75 80       	ldd	r7, Z+5	; 0x05
    32e0:	fc 01       	movw	r30, r24
    32e2:	86 80       	ldd	r8, Z+6	; 0x06
    32e4:	fc 01       	movw	r30, r24
    32e6:	97 80       	ldd	r9, Z+7	; 0x07
    32e8:	2a 2d       	mov	r18, r10
    32ea:	22 0d       	add	r18, r2
    32ec:	e1 e0       	ldi	r30, 0x01	; 1
    32ee:	2a 15       	cp	r18, r10
    32f0:	08 f0       	brcs	.+2      	; 0x32f4 <calcChecksumFRAM+0x266>
    32f2:	e0 e0       	ldi	r30, 0x00	; 0
    32f4:	3b 2d       	mov	r19, r11
    32f6:	33 0d       	add	r19, r3
    32f8:	f1 e0       	ldi	r31, 0x01	; 1
    32fa:	3b 15       	cp	r19, r11
    32fc:	08 f0       	brcs	.+2      	; 0x3300 <calcChecksumFRAM+0x272>
    32fe:	f0 e0       	ldi	r31, 0x00	; 0
    3300:	e3 0f       	add	r30, r19
    3302:	a1 e0       	ldi	r26, 0x01	; 1
    3304:	e3 17       	cp	r30, r19
    3306:	08 f0       	brcs	.+2      	; 0x330a <calcChecksumFRAM+0x27c>
    3308:	a0 e0       	ldi	r26, 0x00	; 0
    330a:	fa 2b       	or	r31, r26
    330c:	3e 2f       	mov	r19, r30
    330e:	4c 2d       	mov	r20, r12
    3310:	44 0d       	add	r20, r4
    3312:	e1 e0       	ldi	r30, 0x01	; 1
    3314:	4c 15       	cp	r20, r12
    3316:	08 f0       	brcs	.+2      	; 0x331a <calcChecksumFRAM+0x28c>
    3318:	e0 e0       	ldi	r30, 0x00	; 0
    331a:	f4 0f       	add	r31, r20
    331c:	a1 e0       	ldi	r26, 0x01	; 1
    331e:	f4 17       	cp	r31, r20
    3320:	08 f0       	brcs	.+2      	; 0x3324 <calcChecksumFRAM+0x296>
    3322:	a0 e0       	ldi	r26, 0x00	; 0
    3324:	ea 2b       	or	r30, r26
    3326:	4f 2f       	mov	r20, r31
    3328:	5d 2d       	mov	r21, r13
    332a:	55 0d       	add	r21, r5
    332c:	f1 e0       	ldi	r31, 0x01	; 1
    332e:	5d 15       	cp	r21, r13
    3330:	08 f0       	brcs	.+2      	; 0x3334 <calcChecksumFRAM+0x2a6>
    3332:	f0 e0       	ldi	r31, 0x00	; 0
    3334:	e5 0f       	add	r30, r21
    3336:	a1 e0       	ldi	r26, 0x01	; 1
    3338:	e5 17       	cp	r30, r21
    333a:	08 f0       	brcs	.+2      	; 0x333e <calcChecksumFRAM+0x2b0>
    333c:	a0 e0       	ldi	r26, 0x00	; 0
    333e:	fa 2b       	or	r31, r26
    3340:	5e 2f       	mov	r21, r30
    3342:	6e 2d       	mov	r22, r14
    3344:	66 0d       	add	r22, r6
    3346:	e1 e0       	ldi	r30, 0x01	; 1
    3348:	6e 15       	cp	r22, r14
    334a:	08 f0       	brcs	.+2      	; 0x334e <calcChecksumFRAM+0x2c0>
    334c:	e0 e0       	ldi	r30, 0x00	; 0
    334e:	f6 0f       	add	r31, r22
    3350:	a1 e0       	ldi	r26, 0x01	; 1
    3352:	f6 17       	cp	r31, r22
    3354:	08 f0       	brcs	.+2      	; 0x3358 <calcChecksumFRAM+0x2ca>
    3356:	a0 e0       	ldi	r26, 0x00	; 0
    3358:	ea 2b       	or	r30, r26
    335a:	6f 2f       	mov	r22, r31
    335c:	7f 2d       	mov	r23, r15
    335e:	77 0d       	add	r23, r7
    3360:	f1 e0       	ldi	r31, 0x01	; 1
    3362:	7f 15       	cp	r23, r15
    3364:	08 f0       	brcs	.+2      	; 0x3368 <calcChecksumFRAM+0x2da>
    3366:	f0 e0       	ldi	r31, 0x00	; 0
    3368:	e7 0f       	add	r30, r23
    336a:	a1 e0       	ldi	r26, 0x01	; 1
    336c:	e7 17       	cp	r30, r23
    336e:	08 f0       	brcs	.+2      	; 0x3372 <calcChecksumFRAM+0x2e4>
    3370:	a0 e0       	ldi	r26, 0x00	; 0
    3372:	fa 2b       	or	r31, r26
    3374:	7e 2f       	mov	r23, r30
    3376:	80 2f       	mov	r24, r16
    3378:	88 0d       	add	r24, r8
    337a:	e1 e0       	ldi	r30, 0x01	; 1
    337c:	80 17       	cp	r24, r16
    337e:	08 f0       	brcs	.+2      	; 0x3382 <calcChecksumFRAM+0x2f4>
    3380:	e0 e0       	ldi	r30, 0x00	; 0
    3382:	f8 0f       	add	r31, r24
    3384:	a1 e0       	ldi	r26, 0x01	; 1
    3386:	f8 17       	cp	r31, r24
    3388:	08 f0       	brcs	.+2      	; 0x338c <calcChecksumFRAM+0x2fe>
    338a:	a0 e0       	ldi	r26, 0x00	; 0
    338c:	ea 2b       	or	r30, r26
    338e:	8f 2f       	mov	r24, r31
    3390:	91 2f       	mov	r25, r17
    3392:	99 0d       	add	r25, r9
    3394:	e9 0f       	add	r30, r25
    3396:	9e 2f       	mov	r25, r30
    3398:	a2 2e       	mov	r10, r18
    339a:	b3 2e       	mov	r11, r19
    339c:	c4 2e       	mov	r12, r20
    339e:	d5 2e       	mov	r13, r21
    33a0:	e6 2e       	mov	r14, r22
    33a2:	f7 2e       	mov	r15, r23
    33a4:	08 2f       	mov	r16, r24
    33a6:	19 2f       	mov	r17, r25
    33a8:	a0 92 88 50 	sts	0x5088, r10
    33ac:	b0 92 89 50 	sts	0x5089, r11
    33b0:	c0 92 8a 50 	sts	0x508A, r12
    33b4:	d0 92 8b 50 	sts	0x508B, r13
    33b8:	e0 92 8c 50 	sts	0x508C, r14
    33bc:	f0 92 8d 50 	sts	0x508D, r15
    33c0:	00 93 8e 50 	sts	0x508E, r16
    33c4:	10 93 8f 50 	sts	0x508F, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    33c8:	8b 81       	ldd	r24, Y+3	; 0x03
    33ca:	9c 81       	ldd	r25, Y+4	; 0x04
    33cc:	29 e0       	ldi	r18, 0x09	; 9
    33ce:	30 e0       	ldi	r19, 0x00	; 0
    33d0:	b9 01       	movw	r22, r18
    33d2:	0e 94 91 5e 	call	0xbd22	; 0xbd22 <__udivmodhi4>
    33d6:	85 30       	cpi	r24, 0x05	; 5
    33d8:	91 05       	cpc	r25, r1
    33da:	09 f0       	breq	.+2      	; 0x33de <calcChecksumFRAM+0x350>
    33dc:	94 c0       	rjmp	.+296    	; 0x3506 <calcChecksumFRAM+0x478>
    33de:	a0 90 90 50 	lds	r10, 0x5090
    33e2:	b0 90 91 50 	lds	r11, 0x5091
    33e6:	c0 90 92 50 	lds	r12, 0x5092
    33ea:	d0 90 93 50 	lds	r13, 0x5093
    33ee:	e0 90 94 50 	lds	r14, 0x5094
    33f2:	f0 90 95 50 	lds	r15, 0x5095
    33f6:	00 91 96 50 	lds	r16, 0x5096
    33fa:	10 91 97 50 	lds	r17, 0x5097
    33fe:	80 91 64 50 	lds	r24, 0x5064
    3402:	90 91 65 50 	lds	r25, 0x5065
    3406:	fc 01       	movw	r30, r24
    3408:	20 80       	ld	r2, Z
    340a:	fc 01       	movw	r30, r24
    340c:	31 80       	ldd	r3, Z+1	; 0x01
    340e:	fc 01       	movw	r30, r24
    3410:	42 80       	ldd	r4, Z+2	; 0x02
    3412:	fc 01       	movw	r30, r24
    3414:	53 80       	ldd	r5, Z+3	; 0x03
    3416:	fc 01       	movw	r30, r24
    3418:	64 80       	ldd	r6, Z+4	; 0x04
    341a:	fc 01       	movw	r30, r24
    341c:	75 80       	ldd	r7, Z+5	; 0x05
    341e:	fc 01       	movw	r30, r24
    3420:	86 80       	ldd	r8, Z+6	; 0x06
    3422:	fc 01       	movw	r30, r24
    3424:	97 80       	ldd	r9, Z+7	; 0x07
    3426:	2a 2d       	mov	r18, r10
    3428:	22 0d       	add	r18, r2
    342a:	e1 e0       	ldi	r30, 0x01	; 1
    342c:	2a 15       	cp	r18, r10
    342e:	08 f0       	brcs	.+2      	; 0x3432 <calcChecksumFRAM+0x3a4>
    3430:	e0 e0       	ldi	r30, 0x00	; 0
    3432:	3b 2d       	mov	r19, r11
    3434:	33 0d       	add	r19, r3
    3436:	f1 e0       	ldi	r31, 0x01	; 1
    3438:	3b 15       	cp	r19, r11
    343a:	08 f0       	brcs	.+2      	; 0x343e <calcChecksumFRAM+0x3b0>
    343c:	f0 e0       	ldi	r31, 0x00	; 0
    343e:	e3 0f       	add	r30, r19
    3440:	a1 e0       	ldi	r26, 0x01	; 1
    3442:	e3 17       	cp	r30, r19
    3444:	08 f0       	brcs	.+2      	; 0x3448 <calcChecksumFRAM+0x3ba>
    3446:	a0 e0       	ldi	r26, 0x00	; 0
    3448:	fa 2b       	or	r31, r26
    344a:	3e 2f       	mov	r19, r30
    344c:	4c 2d       	mov	r20, r12
    344e:	44 0d       	add	r20, r4
    3450:	e1 e0       	ldi	r30, 0x01	; 1
    3452:	4c 15       	cp	r20, r12
    3454:	08 f0       	brcs	.+2      	; 0x3458 <calcChecksumFRAM+0x3ca>
    3456:	e0 e0       	ldi	r30, 0x00	; 0
    3458:	f4 0f       	add	r31, r20
    345a:	a1 e0       	ldi	r26, 0x01	; 1
    345c:	f4 17       	cp	r31, r20
    345e:	08 f0       	brcs	.+2      	; 0x3462 <calcChecksumFRAM+0x3d4>
    3460:	a0 e0       	ldi	r26, 0x00	; 0
    3462:	ea 2b       	or	r30, r26
    3464:	4f 2f       	mov	r20, r31
    3466:	5d 2d       	mov	r21, r13
    3468:	55 0d       	add	r21, r5
    346a:	f1 e0       	ldi	r31, 0x01	; 1
    346c:	5d 15       	cp	r21, r13
    346e:	08 f0       	brcs	.+2      	; 0x3472 <calcChecksumFRAM+0x3e4>
    3470:	f0 e0       	ldi	r31, 0x00	; 0
    3472:	e5 0f       	add	r30, r21
    3474:	a1 e0       	ldi	r26, 0x01	; 1
    3476:	e5 17       	cp	r30, r21
    3478:	08 f0       	brcs	.+2      	; 0x347c <calcChecksumFRAM+0x3ee>
    347a:	a0 e0       	ldi	r26, 0x00	; 0
    347c:	fa 2b       	or	r31, r26
    347e:	5e 2f       	mov	r21, r30
    3480:	6e 2d       	mov	r22, r14
    3482:	66 0d       	add	r22, r6
    3484:	e1 e0       	ldi	r30, 0x01	; 1
    3486:	6e 15       	cp	r22, r14
    3488:	08 f0       	brcs	.+2      	; 0x348c <calcChecksumFRAM+0x3fe>
    348a:	e0 e0       	ldi	r30, 0x00	; 0
    348c:	f6 0f       	add	r31, r22
    348e:	a1 e0       	ldi	r26, 0x01	; 1
    3490:	f6 17       	cp	r31, r22
    3492:	08 f0       	brcs	.+2      	; 0x3496 <calcChecksumFRAM+0x408>
    3494:	a0 e0       	ldi	r26, 0x00	; 0
    3496:	ea 2b       	or	r30, r26
    3498:	6f 2f       	mov	r22, r31
    349a:	7f 2d       	mov	r23, r15
    349c:	77 0d       	add	r23, r7
    349e:	f1 e0       	ldi	r31, 0x01	; 1
    34a0:	7f 15       	cp	r23, r15
    34a2:	08 f0       	brcs	.+2      	; 0x34a6 <calcChecksumFRAM+0x418>
    34a4:	f0 e0       	ldi	r31, 0x00	; 0
    34a6:	e7 0f       	add	r30, r23
    34a8:	a1 e0       	ldi	r26, 0x01	; 1
    34aa:	e7 17       	cp	r30, r23
    34ac:	08 f0       	brcs	.+2      	; 0x34b0 <calcChecksumFRAM+0x422>
    34ae:	a0 e0       	ldi	r26, 0x00	; 0
    34b0:	fa 2b       	or	r31, r26
    34b2:	7e 2f       	mov	r23, r30
    34b4:	80 2f       	mov	r24, r16
    34b6:	88 0d       	add	r24, r8
    34b8:	e1 e0       	ldi	r30, 0x01	; 1
    34ba:	80 17       	cp	r24, r16
    34bc:	08 f0       	brcs	.+2      	; 0x34c0 <calcChecksumFRAM+0x432>
    34be:	e0 e0       	ldi	r30, 0x00	; 0
    34c0:	f8 0f       	add	r31, r24
    34c2:	a1 e0       	ldi	r26, 0x01	; 1
    34c4:	f8 17       	cp	r31, r24
    34c6:	08 f0       	brcs	.+2      	; 0x34ca <calcChecksumFRAM+0x43c>
    34c8:	a0 e0       	ldi	r26, 0x00	; 0
    34ca:	ea 2b       	or	r30, r26
    34cc:	8f 2f       	mov	r24, r31
    34ce:	91 2f       	mov	r25, r17
    34d0:	99 0d       	add	r25, r9
    34d2:	e9 0f       	add	r30, r25
    34d4:	9e 2f       	mov	r25, r30
    34d6:	a2 2e       	mov	r10, r18
    34d8:	b3 2e       	mov	r11, r19
    34da:	c4 2e       	mov	r12, r20
    34dc:	d5 2e       	mov	r13, r21
    34de:	e6 2e       	mov	r14, r22
    34e0:	f7 2e       	mov	r15, r23
    34e2:	08 2f       	mov	r16, r24
    34e4:	19 2f       	mov	r17, r25
    34e6:	a0 92 90 50 	sts	0x5090, r10
    34ea:	b0 92 91 50 	sts	0x5091, r11
    34ee:	c0 92 92 50 	sts	0x5092, r12
    34f2:	d0 92 93 50 	sts	0x5093, r13
    34f6:	e0 92 94 50 	sts	0x5094, r14
    34fa:	f0 92 95 50 	sts	0x5095, r15
    34fe:	00 93 96 50 	sts	0x5096, r16
    3502:	10 93 97 50 	sts	0x5097, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    3506:	8b 81       	ldd	r24, Y+3	; 0x03
    3508:	9c 81       	ldd	r25, Y+4	; 0x04
    350a:	29 e0       	ldi	r18, 0x09	; 9
    350c:	30 e0       	ldi	r19, 0x00	; 0
    350e:	b9 01       	movw	r22, r18
    3510:	0e 94 91 5e 	call	0xbd22	; 0xbd22 <__udivmodhi4>
    3514:	88 30       	cpi	r24, 0x08	; 8
    3516:	91 05       	cpc	r25, r1
    3518:	09 f0       	breq	.+2      	; 0x351c <calcChecksumFRAM+0x48e>
    351a:	94 c0       	rjmp	.+296    	; 0x3644 <calcChecksumFRAM+0x5b6>
    351c:	a0 90 98 50 	lds	r10, 0x5098
    3520:	b0 90 99 50 	lds	r11, 0x5099
    3524:	c0 90 9a 50 	lds	r12, 0x509A
    3528:	d0 90 9b 50 	lds	r13, 0x509B
    352c:	e0 90 9c 50 	lds	r14, 0x509C
    3530:	f0 90 9d 50 	lds	r15, 0x509D
    3534:	00 91 9e 50 	lds	r16, 0x509E
    3538:	10 91 9f 50 	lds	r17, 0x509F
    353c:	80 91 64 50 	lds	r24, 0x5064
    3540:	90 91 65 50 	lds	r25, 0x5065
    3544:	fc 01       	movw	r30, r24
    3546:	20 80       	ld	r2, Z
    3548:	fc 01       	movw	r30, r24
    354a:	31 80       	ldd	r3, Z+1	; 0x01
    354c:	fc 01       	movw	r30, r24
    354e:	42 80       	ldd	r4, Z+2	; 0x02
    3550:	fc 01       	movw	r30, r24
    3552:	53 80       	ldd	r5, Z+3	; 0x03
    3554:	fc 01       	movw	r30, r24
    3556:	64 80       	ldd	r6, Z+4	; 0x04
    3558:	fc 01       	movw	r30, r24
    355a:	75 80       	ldd	r7, Z+5	; 0x05
    355c:	fc 01       	movw	r30, r24
    355e:	86 80       	ldd	r8, Z+6	; 0x06
    3560:	fc 01       	movw	r30, r24
    3562:	97 80       	ldd	r9, Z+7	; 0x07
    3564:	2a 2d       	mov	r18, r10
    3566:	22 0d       	add	r18, r2
    3568:	e1 e0       	ldi	r30, 0x01	; 1
    356a:	2a 15       	cp	r18, r10
    356c:	08 f0       	brcs	.+2      	; 0x3570 <calcChecksumFRAM+0x4e2>
    356e:	e0 e0       	ldi	r30, 0x00	; 0
    3570:	3b 2d       	mov	r19, r11
    3572:	33 0d       	add	r19, r3
    3574:	f1 e0       	ldi	r31, 0x01	; 1
    3576:	3b 15       	cp	r19, r11
    3578:	08 f0       	brcs	.+2      	; 0x357c <calcChecksumFRAM+0x4ee>
    357a:	f0 e0       	ldi	r31, 0x00	; 0
    357c:	e3 0f       	add	r30, r19
    357e:	a1 e0       	ldi	r26, 0x01	; 1
    3580:	e3 17       	cp	r30, r19
    3582:	08 f0       	brcs	.+2      	; 0x3586 <calcChecksumFRAM+0x4f8>
    3584:	a0 e0       	ldi	r26, 0x00	; 0
    3586:	fa 2b       	or	r31, r26
    3588:	3e 2f       	mov	r19, r30
    358a:	4c 2d       	mov	r20, r12
    358c:	44 0d       	add	r20, r4
    358e:	e1 e0       	ldi	r30, 0x01	; 1
    3590:	4c 15       	cp	r20, r12
    3592:	08 f0       	brcs	.+2      	; 0x3596 <calcChecksumFRAM+0x508>
    3594:	e0 e0       	ldi	r30, 0x00	; 0
    3596:	f4 0f       	add	r31, r20
    3598:	a1 e0       	ldi	r26, 0x01	; 1
    359a:	f4 17       	cp	r31, r20
    359c:	08 f0       	brcs	.+2      	; 0x35a0 <calcChecksumFRAM+0x512>
    359e:	a0 e0       	ldi	r26, 0x00	; 0
    35a0:	ea 2b       	or	r30, r26
    35a2:	4f 2f       	mov	r20, r31
    35a4:	5d 2d       	mov	r21, r13
    35a6:	55 0d       	add	r21, r5
    35a8:	f1 e0       	ldi	r31, 0x01	; 1
    35aa:	5d 15       	cp	r21, r13
    35ac:	08 f0       	brcs	.+2      	; 0x35b0 <calcChecksumFRAM+0x522>
    35ae:	f0 e0       	ldi	r31, 0x00	; 0
    35b0:	e5 0f       	add	r30, r21
    35b2:	a1 e0       	ldi	r26, 0x01	; 1
    35b4:	e5 17       	cp	r30, r21
    35b6:	08 f0       	brcs	.+2      	; 0x35ba <calcChecksumFRAM+0x52c>
    35b8:	a0 e0       	ldi	r26, 0x00	; 0
    35ba:	fa 2b       	or	r31, r26
    35bc:	5e 2f       	mov	r21, r30
    35be:	6e 2d       	mov	r22, r14
    35c0:	66 0d       	add	r22, r6
    35c2:	e1 e0       	ldi	r30, 0x01	; 1
    35c4:	6e 15       	cp	r22, r14
    35c6:	08 f0       	brcs	.+2      	; 0x35ca <calcChecksumFRAM+0x53c>
    35c8:	e0 e0       	ldi	r30, 0x00	; 0
    35ca:	f6 0f       	add	r31, r22
    35cc:	a1 e0       	ldi	r26, 0x01	; 1
    35ce:	f6 17       	cp	r31, r22
    35d0:	08 f0       	brcs	.+2      	; 0x35d4 <calcChecksumFRAM+0x546>
    35d2:	a0 e0       	ldi	r26, 0x00	; 0
    35d4:	ea 2b       	or	r30, r26
    35d6:	6f 2f       	mov	r22, r31
    35d8:	7f 2d       	mov	r23, r15
    35da:	77 0d       	add	r23, r7
    35dc:	f1 e0       	ldi	r31, 0x01	; 1
    35de:	7f 15       	cp	r23, r15
    35e0:	08 f0       	brcs	.+2      	; 0x35e4 <calcChecksumFRAM+0x556>
    35e2:	f0 e0       	ldi	r31, 0x00	; 0
    35e4:	e7 0f       	add	r30, r23
    35e6:	a1 e0       	ldi	r26, 0x01	; 1
    35e8:	e7 17       	cp	r30, r23
    35ea:	08 f0       	brcs	.+2      	; 0x35ee <calcChecksumFRAM+0x560>
    35ec:	a0 e0       	ldi	r26, 0x00	; 0
    35ee:	fa 2b       	or	r31, r26
    35f0:	7e 2f       	mov	r23, r30
    35f2:	80 2f       	mov	r24, r16
    35f4:	88 0d       	add	r24, r8
    35f6:	e1 e0       	ldi	r30, 0x01	; 1
    35f8:	80 17       	cp	r24, r16
    35fa:	08 f0       	brcs	.+2      	; 0x35fe <calcChecksumFRAM+0x570>
    35fc:	e0 e0       	ldi	r30, 0x00	; 0
    35fe:	f8 0f       	add	r31, r24
    3600:	a1 e0       	ldi	r26, 0x01	; 1
    3602:	f8 17       	cp	r31, r24
    3604:	08 f0       	brcs	.+2      	; 0x3608 <calcChecksumFRAM+0x57a>
    3606:	a0 e0       	ldi	r26, 0x00	; 0
    3608:	ea 2b       	or	r30, r26
    360a:	8f 2f       	mov	r24, r31
    360c:	91 2f       	mov	r25, r17
    360e:	99 0d       	add	r25, r9
    3610:	e9 0f       	add	r30, r25
    3612:	9e 2f       	mov	r25, r30
    3614:	a2 2e       	mov	r10, r18
    3616:	b3 2e       	mov	r11, r19
    3618:	c4 2e       	mov	r12, r20
    361a:	d5 2e       	mov	r13, r21
    361c:	e6 2e       	mov	r14, r22
    361e:	f7 2e       	mov	r15, r23
    3620:	08 2f       	mov	r16, r24
    3622:	19 2f       	mov	r17, r25
    3624:	a0 92 98 50 	sts	0x5098, r10
    3628:	b0 92 99 50 	sts	0x5099, r11
    362c:	c0 92 9a 50 	sts	0x509A, r12
    3630:	d0 92 9b 50 	sts	0x509B, r13
    3634:	e0 92 9c 50 	sts	0x509C, r14
    3638:	f0 92 9d 50 	sts	0x509D, r15
    363c:	00 93 9e 50 	sts	0x509E, r16
    3640:	10 93 9f 50 	sts	0x509F, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3644:	8b 81       	ldd	r24, Y+3	; 0x03
    3646:	9c 81       	ldd	r25, Y+4	; 0x04
    3648:	01 96       	adiw	r24, 0x01	; 1
    364a:	8b 83       	std	Y+3, r24	; 0x03
    364c:	9c 83       	std	Y+4, r25	; 0x04
    364e:	8b 81       	ldd	r24, Y+3	; 0x03
    3650:	9c 81       	ldd	r25, Y+4	; 0x04
    3652:	fc e1       	ldi	r31, 0x1C	; 28
    3654:	81 37       	cpi	r24, 0x71	; 113
    3656:	9f 07       	cpc	r25, r31
    3658:	08 f4       	brcc	.+2      	; 0x365c <calcChecksumFRAM+0x5ce>
    365a:	8e cd       	rjmp	.-1252   	; 0x3178 <calcChecksumFRAM+0xea>

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    365c:	89 81       	ldd	r24, Y+1	; 0x01
    365e:	9a 81       	ldd	r25, Y+2	; 0x02
    3660:	01 96       	adiw	r24, 0x01	; 1
    3662:	89 83       	std	Y+1, r24	; 0x01
    3664:	9a 83       	std	Y+2, r25	; 0x02
    3666:	89 81       	ldd	r24, Y+1	; 0x01
    3668:	9a 81       	ldd	r25, Y+2	; 0x02
    366a:	89 30       	cpi	r24, 0x09	; 9
    366c:	91 05       	cpc	r25, r1
    366e:	08 f4       	brcc	.+2      	; 0x3672 <calcChecksumFRAM+0x5e4>
    3670:	72 cd       	rjmp	.-1308   	; 0x3156 <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3672:	24 96       	adiw	r28, 0x04	; 4
    3674:	cd bf       	out	0x3d, r28	; 61
    3676:	de bf       	out	0x3e, r29	; 62
    3678:	df 91       	pop	r29
    367a:	cf 91       	pop	r28
    367c:	1f 91       	pop	r17
    367e:	0f 91       	pop	r16
    3680:	ff 90       	pop	r15
    3682:	ef 90       	pop	r14
    3684:	df 90       	pop	r13
    3686:	cf 90       	pop	r12
    3688:	bf 90       	pop	r11
    368a:	af 90       	pop	r10
    368c:	9f 90       	pop	r9
    368e:	8f 90       	pop	r8
    3690:	7f 90       	pop	r7
    3692:	6f 90       	pop	r6
    3694:	5f 90       	pop	r5
    3696:	4f 90       	pop	r4
    3698:	3f 90       	pop	r3
    369a:	2f 90       	pop	r2
    369c:	08 95       	ret

0000369e <FRAMWriteKnowns>:


void FRAMWriteKnowns() {
    369e:	cf 93       	push	r28
    36a0:	df 93       	push	r29
    36a2:	cd b7       	in	r28, 0x3d	; 61
    36a4:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    36a6:	10 92 58 40 	sts	0x4058, r1
    36aa:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    36ae:	10 92 73 50 	sts	0x5073, r1
    36b2:	10 92 74 50 	sts	0x5074, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    36b6:	80 e0       	ldi	r24, 0x00	; 0
    36b8:	80 93 3c 21 	sts	0x213C, r24
    36bc:	80 93 3b 21 	sts	0x213B, r24
    36c0:	80 93 3a 21 	sts	0x213A, r24
	
	ADCPower(TRUE);
    36c4:	81 e0       	ldi	r24, 0x01	; 1
    36c6:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    36ca:	84 e0       	ldi	r24, 0x04	; 4
    36cc:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    36d0:	80 ec       	ldi	r24, 0xC0	; 192
    36d2:	98 e0       	ldi	r25, 0x08	; 8
    36d4:	20 ed       	ldi	r18, 0xD0	; 208
    36d6:	fc 01       	movw	r30, r24
    36d8:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    36da:	8d e0       	ldi	r24, 0x0D	; 13
    36dc:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[1] = 0xF3;
    36e0:	83 ef       	ldi	r24, 0xF3	; 243
    36e2:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[2] = 0x57;
    36e6:	87 e5       	ldi	r24, 0x57	; 87
    36e8:	80 93 68 50 	sts	0x5068, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    36ec:	cd c0       	rjmp	.+410    	; 0x3888 <FRAMWriteKnowns+0x1ea>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    36ee:	80 e4       	ldi	r24, 0x40	; 64
    36f0:	96 e0       	ldi	r25, 0x06	; 6
    36f2:	20 e1       	ldi	r18, 0x10	; 16
    36f4:	fc 01       	movw	r30, r24
    36f6:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    36f8:	80 e2       	ldi	r24, 0x20	; 32
    36fa:	96 e0       	ldi	r25, 0x06	; 6
    36fc:	28 e0       	ldi	r18, 0x08	; 8
    36fe:	fc 01       	movw	r30, r24
    3700:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3702:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3704:	80 ec       	ldi	r24, 0xC0	; 192
    3706:	98 e0       	ldi	r25, 0x08	; 8
    3708:	26 e0       	ldi	r18, 0x06	; 6
    370a:	fc 01       	movw	r30, r24
    370c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    370e:	00 00       	nop
    3710:	80 ec       	ldi	r24, 0xC0	; 192
    3712:	98 e0       	ldi	r25, 0x08	; 8
    3714:	fc 01       	movw	r30, r24
    3716:	82 81       	ldd	r24, Z+2	; 0x02
    3718:	88 23       	and	r24, r24
    371a:	d4 f7       	brge	.-12     	; 0x3710 <FRAMWriteKnowns+0x72>
		SPIBuffer[12] = SPIC.DATA;
    371c:	80 ec       	ldi	r24, 0xC0	; 192
    371e:	98 e0       	ldi	r25, 0x08	; 8
    3720:	fc 01       	movw	r30, r24
    3722:	83 81       	ldd	r24, Z+3	; 0x03
    3724:	80 93 72 50 	sts	0x5072, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3728:	80 e2       	ldi	r24, 0x20	; 32
    372a:	96 e0       	ldi	r25, 0x06	; 6
    372c:	28 e0       	ldi	r18, 0x08	; 8
    372e:	fc 01       	movw	r30, r24
    3730:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    3732:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3734:	80 e2       	ldi	r24, 0x20	; 32
    3736:	96 e0       	ldi	r25, 0x06	; 6
    3738:	28 e0       	ldi	r18, 0x08	; 8
    373a:	fc 01       	movw	r30, r24
    373c:	26 83       	std	Z+6, r18	; 0x06
		nop();
    373e:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    3740:	80 ec       	ldi	r24, 0xC0	; 192
    3742:	98 e0       	ldi	r25, 0x08	; 8
    3744:	22 e0       	ldi	r18, 0x02	; 2
    3746:	fc 01       	movw	r30, r24
    3748:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    374a:	00 00       	nop
    374c:	80 ec       	ldi	r24, 0xC0	; 192
    374e:	98 e0       	ldi	r25, 0x08	; 8
    3750:	fc 01       	movw	r30, r24
    3752:	82 81       	ldd	r24, Z+2	; 0x02
    3754:	88 23       	and	r24, r24
    3756:	d4 f7       	brge	.-12     	; 0x374c <FRAMWriteKnowns+0xae>
		SPIBuffer[12] = SPIC.DATA;
    3758:	80 ec       	ldi	r24, 0xC0	; 192
    375a:	98 e0       	ldi	r25, 0x08	; 8
    375c:	fc 01       	movw	r30, r24
    375e:	83 81       	ldd	r24, Z+3	; 0x03
    3760:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    3764:	80 ec       	ldi	r24, 0xC0	; 192
    3766:	98 e0       	ldi	r25, 0x08	; 8
    3768:	20 91 59 40 	lds	r18, 0x4059
    376c:	fc 01       	movw	r30, r24
    376e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3770:	00 00       	nop
    3772:	80 ec       	ldi	r24, 0xC0	; 192
    3774:	98 e0       	ldi	r25, 0x08	; 8
    3776:	fc 01       	movw	r30, r24
    3778:	82 81       	ldd	r24, Z+2	; 0x02
    377a:	88 23       	and	r24, r24
    377c:	d4 f7       	brge	.-12     	; 0x3772 <FRAMWriteKnowns+0xd4>
		SPIBuffer[12] = SPIC.DATA;
    377e:	80 ec       	ldi	r24, 0xC0	; 192
    3780:	98 e0       	ldi	r25, 0x08	; 8
    3782:	fc 01       	movw	r30, r24
    3784:	83 81       	ldd	r24, Z+3	; 0x03
    3786:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    378a:	80 ec       	ldi	r24, 0xC0	; 192
    378c:	98 e0       	ldi	r25, 0x08	; 8
    378e:	28 e5       	ldi	r18, 0x58	; 88
    3790:	30 e4       	ldi	r19, 0x40	; 64
    3792:	f9 01       	movw	r30, r18
    3794:	20 81       	ld	r18, Z
    3796:	fc 01       	movw	r30, r24
    3798:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    379a:	00 00       	nop
    379c:	80 ec       	ldi	r24, 0xC0	; 192
    379e:	98 e0       	ldi	r25, 0x08	; 8
    37a0:	fc 01       	movw	r30, r24
    37a2:	82 81       	ldd	r24, Z+2	; 0x02
    37a4:	88 23       	and	r24, r24
    37a6:	d4 f7       	brge	.-12     	; 0x379c <FRAMWriteKnowns+0xfe>
		SPIBuffer[12] = SPIC.DATA;
    37a8:	80 ec       	ldi	r24, 0xC0	; 192
    37aa:	98 e0       	ldi	r25, 0x08	; 8
    37ac:	fc 01       	movw	r30, r24
    37ae:	83 81       	ldd	r24, Z+3	; 0x03
    37b0:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[0];
    37b4:	80 ec       	ldi	r24, 0xC0	; 192
    37b6:	98 e0       	ldi	r25, 0x08	; 8
    37b8:	20 91 66 50 	lds	r18, 0x5066
    37bc:	fc 01       	movw	r30, r24
    37be:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37c0:	00 00       	nop
    37c2:	80 ec       	ldi	r24, 0xC0	; 192
    37c4:	98 e0       	ldi	r25, 0x08	; 8
    37c6:	fc 01       	movw	r30, r24
    37c8:	82 81       	ldd	r24, Z+2	; 0x02
    37ca:	88 23       	and	r24, r24
    37cc:	d4 f7       	brge	.-12     	; 0x37c2 <FRAMWriteKnowns+0x124>
		SPIBuffer[12] = SPIC.DATA;
    37ce:	80 ec       	ldi	r24, 0xC0	; 192
    37d0:	98 e0       	ldi	r25, 0x08	; 8
    37d2:	fc 01       	movw	r30, r24
    37d4:	83 81       	ldd	r24, Z+3	; 0x03
    37d6:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[1];
    37da:	80 ec       	ldi	r24, 0xC0	; 192
    37dc:	98 e0       	ldi	r25, 0x08	; 8
    37de:	20 91 67 50 	lds	r18, 0x5067
    37e2:	fc 01       	movw	r30, r24
    37e4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37e6:	00 00       	nop
    37e8:	80 ec       	ldi	r24, 0xC0	; 192
    37ea:	98 e0       	ldi	r25, 0x08	; 8
    37ec:	fc 01       	movw	r30, r24
    37ee:	82 81       	ldd	r24, Z+2	; 0x02
    37f0:	88 23       	and	r24, r24
    37f2:	d4 f7       	brge	.-12     	; 0x37e8 <FRAMWriteKnowns+0x14a>
		SPIBuffer[12] = SPIC.DATA;
    37f4:	80 ec       	ldi	r24, 0xC0	; 192
    37f6:	98 e0       	ldi	r25, 0x08	; 8
    37f8:	fc 01       	movw	r30, r24
    37fa:	83 81       	ldd	r24, Z+3	; 0x03
    37fc:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[2];
    3800:	80 ec       	ldi	r24, 0xC0	; 192
    3802:	98 e0       	ldi	r25, 0x08	; 8
    3804:	20 91 68 50 	lds	r18, 0x5068
    3808:	fc 01       	movw	r30, r24
    380a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    380c:	00 00       	nop
    380e:	80 ec       	ldi	r24, 0xC0	; 192
    3810:	98 e0       	ldi	r25, 0x08	; 8
    3812:	fc 01       	movw	r30, r24
    3814:	82 81       	ldd	r24, Z+2	; 0x02
    3816:	88 23       	and	r24, r24
    3818:	d4 f7       	brge	.-12     	; 0x380e <FRAMWriteKnowns+0x170>
		SPIBuffer[12] = SPIC.DATA;
    381a:	80 ec       	ldi	r24, 0xC0	; 192
    381c:	98 e0       	ldi	r25, 0x08	; 8
    381e:	fc 01       	movw	r30, r24
    3820:	83 81       	ldd	r24, Z+3	; 0x03
    3822:	80 93 72 50 	sts	0x5072, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3826:	80 e2       	ldi	r24, 0x20	; 32
    3828:	96 e0       	ldi	r25, 0x06	; 6
    382a:	28 e0       	ldi	r18, 0x08	; 8
    382c:	fc 01       	movw	r30, r24
    382e:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3830:	80 e4       	ldi	r24, 0x40	; 64
    3832:	96 e0       	ldi	r25, 0x06	; 6
    3834:	20 e1       	ldi	r18, 0x10	; 16
    3836:	fc 01       	movw	r30, r24
    3838:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    383a:	80 91 58 40 	lds	r24, 0x4058
    383e:	90 91 59 40 	lds	r25, 0x4059
    3842:	03 96       	adiw	r24, 0x03	; 3
    3844:	80 93 58 40 	sts	0x4058, r24
    3848:	90 93 59 40 	sts	0x4059, r25
		checksumADC[0] += SPIBuffer[0];
    384c:	90 91 3a 21 	lds	r25, 0x213A
    3850:	80 91 66 50 	lds	r24, 0x5066
    3854:	89 0f       	add	r24, r25
    3856:	80 93 3a 21 	sts	0x213A, r24
		checksumADC[1] += SPIBuffer[1];
    385a:	90 91 3b 21 	lds	r25, 0x213B
    385e:	80 91 67 50 	lds	r24, 0x5067
    3862:	89 0f       	add	r24, r25
    3864:	80 93 3b 21 	sts	0x213B, r24
		checksumADC[2] += SPIBuffer[2];
    3868:	90 91 3c 21 	lds	r25, 0x213C
    386c:	80 91 68 50 	lds	r24, 0x5068
    3870:	89 0f       	add	r24, r25
    3872:	80 93 3c 21 	sts	0x213C, r24
		
		sampleCount++;
    3876:	80 91 73 50 	lds	r24, 0x5073
    387a:	90 91 74 50 	lds	r25, 0x5074
    387e:	01 96       	adiw	r24, 0x01	; 1
    3880:	80 93 73 50 	sts	0x5073, r24
    3884:	90 93 74 50 	sts	0x5074, r25
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3888:	80 91 73 50 	lds	r24, 0x5073
    388c:	90 91 74 50 	lds	r25, 0x5074
    3890:	f5 e5       	ldi	r31, 0x55	; 85
    3892:	83 35       	cpi	r24, 0x53	; 83
    3894:	9f 07       	cpc	r25, r31
    3896:	08 f4       	brcc	.+2      	; 0x389a <FRAMWriteKnowns+0x1fc>
    3898:	2a cf       	rjmp	.-428    	; 0x36ee <FRAMWriteKnowns+0x50>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    389a:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	ADCPower(FALSE);
    389e:	80 e0       	ldi	r24, 0x00	; 0
    38a0:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
}
    38a4:	df 91       	pop	r29
    38a6:	cf 91       	pop	r28
    38a8:	08 95       	ret

000038aa <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    38aa:	cf 93       	push	r28
    38ac:	df 93       	push	r29
    38ae:	0f 92       	push	r0
    38b0:	cd b7       	in	r28, 0x3d	; 61
    38b2:	de b7       	in	r29, 0x3e	; 62
    38b4:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    38b6:	89 81       	ldd	r24, Y+1	; 0x01
    38b8:	88 2f       	mov	r24, r24
    38ba:	90 e0       	ldi	r25, 0x00	; 0
    38bc:	81 70       	andi	r24, 0x01	; 1
    38be:	90 70       	andi	r25, 0x00	; 0
    38c0:	88 23       	and	r24, r24
    38c2:	31 f0       	breq	.+12     	; 0x38d0 <setADCInput+0x26>
    38c4:	80 e0       	ldi	r24, 0x00	; 0
    38c6:	96 e0       	ldi	r25, 0x06	; 6
    38c8:	20 e4       	ldi	r18, 0x40	; 64
    38ca:	fc 01       	movw	r30, r24
    38cc:	25 83       	std	Z+5, r18	; 0x05
    38ce:	05 c0       	rjmp	.+10     	; 0x38da <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    38d0:	80 e0       	ldi	r24, 0x00	; 0
    38d2:	96 e0       	ldi	r25, 0x06	; 6
    38d4:	20 e4       	ldi	r18, 0x40	; 64
    38d6:	fc 01       	movw	r30, r24
    38d8:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    38da:	89 81       	ldd	r24, Y+1	; 0x01
    38dc:	88 2f       	mov	r24, r24
    38de:	90 e0       	ldi	r25, 0x00	; 0
    38e0:	82 70       	andi	r24, 0x02	; 2
    38e2:	90 70       	andi	r25, 0x00	; 0
    38e4:	00 97       	sbiw	r24, 0x00	; 0
    38e6:	31 f0       	breq	.+12     	; 0x38f4 <setADCInput+0x4a>
    38e8:	80 e2       	ldi	r24, 0x20	; 32
    38ea:	96 e0       	ldi	r25, 0x06	; 6
    38ec:	22 e0       	ldi	r18, 0x02	; 2
    38ee:	fc 01       	movw	r30, r24
    38f0:	25 83       	std	Z+5, r18	; 0x05
    38f2:	05 c0       	rjmp	.+10     	; 0x38fe <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    38f4:	80 e2       	ldi	r24, 0x20	; 32
    38f6:	96 e0       	ldi	r25, 0x06	; 6
    38f8:	22 e0       	ldi	r18, 0x02	; 2
    38fa:	fc 01       	movw	r30, r24
    38fc:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    38fe:	89 81       	ldd	r24, Y+1	; 0x01
    3900:	88 2f       	mov	r24, r24
    3902:	90 e0       	ldi	r25, 0x00	; 0
    3904:	84 70       	andi	r24, 0x04	; 4
    3906:	90 70       	andi	r25, 0x00	; 0
    3908:	00 97       	sbiw	r24, 0x00	; 0
    390a:	31 f0       	breq	.+12     	; 0x3918 <setADCInput+0x6e>
    390c:	80 e2       	ldi	r24, 0x20	; 32
    390e:	96 e0       	ldi	r25, 0x06	; 6
    3910:	24 e0       	ldi	r18, 0x04	; 4
    3912:	fc 01       	movw	r30, r24
    3914:	25 83       	std	Z+5, r18	; 0x05
    3916:	05 c0       	rjmp	.+10     	; 0x3922 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    3918:	80 e2       	ldi	r24, 0x20	; 32
    391a:	96 e0       	ldi	r25, 0x06	; 6
    391c:	24 e0       	ldi	r18, 0x04	; 4
    391e:	fc 01       	movw	r30, r24
    3920:	26 83       	std	Z+6, r18	; 0x06

}
    3922:	0f 90       	pop	r0
    3924:	df 91       	pop	r29
    3926:	cf 91       	pop	r28
    3928:	08 95       	ret

0000392a <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    392a:	cf 93       	push	r28
    392c:	df 93       	push	r29
    392e:	0f 92       	push	r0
    3930:	0f 92       	push	r0
    3932:	cd b7       	in	r28, 0x3d	; 61
    3934:	de b7       	in	r29, 0x3e	; 62
    3936:	89 83       	std	Y+1, r24	; 0x01
    3938:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    393a:	89 81       	ldd	r24, Y+1	; 0x01
    393c:	9a 81       	ldd	r25, Y+2	; 0x02
    393e:	22 e0       	ldi	r18, 0x02	; 2
    3940:	80 30       	cpi	r24, 0x00	; 0
    3942:	92 07       	cpc	r25, r18
    3944:	89 f4       	brne	.+34     	; 0x3968 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3946:	80 e2       	ldi	r24, 0x20	; 32
    3948:	0e 94 12 20 	call	0x4024	; 0x4024 <SP_ReadCalibrationByte>
    394c:	28 2f       	mov	r18, r24
    394e:	89 81       	ldd	r24, Y+1	; 0x01
    3950:	9a 81       	ldd	r25, Y+2	; 0x02
    3952:	fc 01       	movw	r30, r24
    3954:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3956:	81 e2       	ldi	r24, 0x21	; 33
    3958:	0e 94 12 20 	call	0x4024	; 0x4024 <SP_ReadCalibrationByte>
    395c:	28 2f       	mov	r18, r24
    395e:	89 81       	ldd	r24, Y+1	; 0x01
    3960:	9a 81       	ldd	r25, Y+2	; 0x02
    3962:	fc 01       	movw	r30, r24
    3964:	25 87       	std	Z+13, r18	; 0x0d
    3966:	10 c0       	rjmp	.+32     	; 0x3988 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3968:	84 e2       	ldi	r24, 0x24	; 36
    396a:	0e 94 12 20 	call	0x4024	; 0x4024 <SP_ReadCalibrationByte>
    396e:	28 2f       	mov	r18, r24
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	9a 81       	ldd	r25, Y+2	; 0x02
    3974:	fc 01       	movw	r30, r24
    3976:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3978:	85 e2       	ldi	r24, 0x25	; 37
    397a:	0e 94 12 20 	call	0x4024	; 0x4024 <SP_ReadCalibrationByte>
    397e:	28 2f       	mov	r18, r24
    3980:	89 81       	ldd	r24, Y+1	; 0x01
    3982:	9a 81       	ldd	r25, Y+2	; 0x02
    3984:	fc 01       	movw	r30, r24
    3986:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3988:	0f 90       	pop	r0
    398a:	0f 90       	pop	r0
    398c:	df 91       	pop	r29
    398e:	cf 91       	pop	r28
    3990:	08 95       	ret

00003992 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3992:	cf 93       	push	r28
    3994:	df 93       	push	r29
    3996:	cd b7       	in	r28, 0x3d	; 61
    3998:	de b7       	in	r29, 0x3e	; 62
    399a:	25 97       	sbiw	r28, 0x05	; 5
    399c:	cd bf       	out	0x3d, r28	; 61
    399e:	de bf       	out	0x3e, r29	; 62
    39a0:	8b 83       	std	Y+3, r24	; 0x03
    39a2:	9c 83       	std	Y+4, r25	; 0x04
    39a4:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    39a6:	8b 81       	ldd	r24, Y+3	; 0x03
    39a8:	9c 81       	ldd	r25, Y+4	; 0x04
    39aa:	21 e0       	ldi	r18, 0x01	; 1
    39ac:	fc 01       	movw	r30, r24
    39ae:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    39b0:	8b 81       	ldd	r24, Y+3	; 0x03
    39b2:	9c 81       	ldd	r25, Y+4	; 0x04
    39b4:	fc 01       	movw	r30, r24
    39b6:	24 81       	ldd	r18, Z+4	; 0x04
    39b8:	35 81       	ldd	r19, Z+5	; 0x05
    39ba:	8d 81       	ldd	r24, Y+5	; 0x05
    39bc:	88 2f       	mov	r24, r24
    39be:	90 e0       	ldi	r25, 0x00	; 0
    39c0:	a9 01       	movw	r20, r18
    39c2:	48 1b       	sub	r20, r24
    39c4:	59 0b       	sbc	r21, r25
    39c6:	ca 01       	movw	r24, r20
    39c8:	89 83       	std	Y+1, r24	; 0x01
    39ca:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    39cc:	89 81       	ldd	r24, Y+1	; 0x01
    39ce:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39d0:	25 96       	adiw	r28, 0x05	; 5
    39d2:	cd bf       	out	0x3d, r28	; 61
    39d4:	de bf       	out	0x3e, r29	; 62
    39d6:	df 91       	pop	r29
    39d8:	cf 91       	pop	r28
    39da:	08 95       	ret

000039dc <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    39dc:	cf 93       	push	r28
    39de:	df 93       	push	r29
    39e0:	cd b7       	in	r28, 0x3d	; 61
    39e2:	de b7       	in	r29, 0x3e	; 62
    39e4:	25 97       	sbiw	r28, 0x05	; 5
    39e6:	cd bf       	out	0x3d, r28	; 61
    39e8:	de bf       	out	0x3e, r29	; 62
    39ea:	8b 83       	std	Y+3, r24	; 0x03
    39ec:	9c 83       	std	Y+4, r25	; 0x04
    39ee:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    39f0:	8b 81       	ldd	r24, Y+3	; 0x03
    39f2:	9c 81       	ldd	r25, Y+4	; 0x04
    39f4:	21 e0       	ldi	r18, 0x01	; 1
    39f6:	fc 01       	movw	r30, r24
    39f8:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    39fa:	8b 81       	ldd	r24, Y+3	; 0x03
    39fc:	9c 81       	ldd	r25, Y+4	; 0x04
    39fe:	fc 01       	movw	r30, r24
    3a00:	24 81       	ldd	r18, Z+4	; 0x04
    3a02:	35 81       	ldd	r19, Z+5	; 0x05
    3a04:	8d 81       	ldd	r24, Y+5	; 0x05
    3a06:	99 27       	eor	r25, r25
    3a08:	87 fd       	sbrc	r24, 7
    3a0a:	90 95       	com	r25
    3a0c:	a9 01       	movw	r20, r18
    3a0e:	48 1b       	sub	r20, r24
    3a10:	59 0b       	sbc	r21, r25
    3a12:	ca 01       	movw	r24, r20
    3a14:	89 83       	std	Y+1, r24	; 0x01
    3a16:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3a18:	89 81       	ldd	r24, Y+1	; 0x01
    3a1a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a1c:	25 96       	adiw	r28, 0x05	; 5
    3a1e:	cd bf       	out	0x3d, r28	; 61
    3a20:	de bf       	out	0x3e, r29	; 62
    3a22:	df 91       	pop	r29
    3a24:	cf 91       	pop	r28
    3a26:	08 95       	ret

00003a28 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3a28:	cf 93       	push	r28
    3a2a:	df 93       	push	r29
    3a2c:	0f 92       	push	r0
    3a2e:	0f 92       	push	r0
    3a30:	cd b7       	in	r28, 0x3d	; 61
    3a32:	de b7       	in	r29, 0x3e	; 62
    3a34:	89 83       	std	Y+1, r24	; 0x01
    3a36:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a38:	89 81       	ldd	r24, Y+1	; 0x01
    3a3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a3c:	21 e0       	ldi	r18, 0x01	; 1
    3a3e:	fc 01       	movw	r30, r24
    3a40:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3a42:	89 81       	ldd	r24, Y+1	; 0x01
    3a44:	9a 81       	ldd	r25, Y+2	; 0x02
    3a46:	fc 01       	movw	r30, r24
    3a48:	84 81       	ldd	r24, Z+4	; 0x04
    3a4a:	95 81       	ldd	r25, Z+5	; 0x05
}
    3a4c:	0f 90       	pop	r0
    3a4e:	0f 90       	pop	r0
    3a50:	df 91       	pop	r29
    3a52:	cf 91       	pop	r28
    3a54:	08 95       	ret

00003a56 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3a56:	cf 93       	push	r28
    3a58:	df 93       	push	r29
    3a5a:	0f 92       	push	r0
    3a5c:	0f 92       	push	r0
    3a5e:	cd b7       	in	r28, 0x3d	; 61
    3a60:	de b7       	in	r29, 0x3e	; 62
    3a62:	89 83       	std	Y+1, r24	; 0x01
    3a64:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a66:	89 81       	ldd	r24, Y+1	; 0x01
    3a68:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6a:	21 e0       	ldi	r18, 0x01	; 1
    3a6c:	fc 01       	movw	r30, r24
    3a6e:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3a70:	89 81       	ldd	r24, Y+1	; 0x01
    3a72:	9a 81       	ldd	r25, Y+2	; 0x02
    3a74:	fc 01       	movw	r30, r24
    3a76:	84 81       	ldd	r24, Z+4	; 0x04
}
    3a78:	0f 90       	pop	r0
    3a7a:	0f 90       	pop	r0
    3a7c:	df 91       	pop	r29
    3a7e:	cf 91       	pop	r28
    3a80:	08 95       	ret

00003a82 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3a82:	cf 93       	push	r28
    3a84:	df 93       	push	r29
    3a86:	0f 92       	push	r0
    3a88:	0f 92       	push	r0
    3a8a:	cd b7       	in	r28, 0x3d	; 61
    3a8c:	de b7       	in	r29, 0x3e	; 62
    3a8e:	89 83       	std	Y+1, r24	; 0x01
    3a90:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a92:	89 81       	ldd	r24, Y+1	; 0x01
    3a94:	9a 81       	ldd	r25, Y+2	; 0x02
    3a96:	21 e0       	ldi	r18, 0x01	; 1
    3a98:	fc 01       	movw	r30, r24
    3a9a:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    3a9c:	89 81       	ldd	r24, Y+1	; 0x01
    3a9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa0:	fc 01       	movw	r30, r24
    3aa2:	85 81       	ldd	r24, Z+5	; 0x05
}
    3aa4:	0f 90       	pop	r0
    3aa6:	0f 90       	pop	r0
    3aa8:	df 91       	pop	r29
    3aaa:	cf 91       	pop	r28
    3aac:	08 95       	ret

00003aae <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    3aae:	0f 93       	push	r16
    3ab0:	1f 93       	push	r17
    3ab2:	cf 93       	push	r28
    3ab4:	df 93       	push	r29
    3ab6:	cd b7       	in	r28, 0x3d	; 61
    3ab8:	de b7       	in	r29, 0x3e	; 62
    3aba:	6b 97       	sbiw	r28, 0x1b	; 27
    3abc:	cd bf       	out	0x3d, r28	; 61
    3abe:	de bf       	out	0x3e, r29	; 62
    3ac0:	8a 8f       	std	Y+26, r24	; 0x1a
    3ac2:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3ac4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ac6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ac8:	fc 01       	movw	r30, r24
    3aca:	84 81       	ldd	r24, Z+4	; 0x04
    3acc:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    3ace:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ad0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ad2:	fc 01       	movw	r30, r24
    3ad4:	14 82       	std	Z+4, r1	; 0x04
    3ad6:	80 e0       	ldi	r24, 0x00	; 0
    3ad8:	90 e0       	ldi	r25, 0x00	; 0
    3ada:	a0 e8       	ldi	r26, 0x80	; 128
    3adc:	b2 e4       	ldi	r27, 0x42	; 66
    3ade:	8a 83       	std	Y+2, r24	; 0x02
    3ae0:	9b 83       	std	Y+3, r25	; 0x03
    3ae2:	ac 83       	std	Y+4, r26	; 0x04
    3ae4:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3ae6:	6a 81       	ldd	r22, Y+2	; 0x02
    3ae8:	7b 81       	ldd	r23, Y+3	; 0x03
    3aea:	8c 81       	ldd	r24, Y+4	; 0x04
    3aec:	9d 81       	ldd	r25, Y+5	; 0x05
    3aee:	2b ea       	ldi	r18, 0xAB	; 171
    3af0:	3a ea       	ldi	r19, 0xAA	; 170
    3af2:	4a e2       	ldi	r20, 0x2A	; 42
    3af4:	5f e3       	ldi	r21, 0x3F	; 63
    3af6:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    3afa:	dc 01       	movw	r26, r24
    3afc:	cb 01       	movw	r24, r22
    3afe:	8e 83       	std	Y+6, r24	; 0x06
    3b00:	9f 83       	std	Y+7, r25	; 0x07
    3b02:	a8 87       	std	Y+8, r26	; 0x08
    3b04:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3b06:	11 e0       	ldi	r17, 0x01	; 1
    3b08:	6e 81       	ldd	r22, Y+6	; 0x06
    3b0a:	7f 81       	ldd	r23, Y+7	; 0x07
    3b0c:	88 85       	ldd	r24, Y+8	; 0x08
    3b0e:	99 85       	ldd	r25, Y+9	; 0x09
    3b10:	20 e0       	ldi	r18, 0x00	; 0
    3b12:	30 e0       	ldi	r19, 0x00	; 0
    3b14:	40 e8       	ldi	r20, 0x80	; 128
    3b16:	5f e3       	ldi	r21, 0x3F	; 63
    3b18:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    3b1c:	88 23       	and	r24, r24
    3b1e:	0c f0       	brlt	.+2      	; 0x3b22 <ADC_Wait_8MHz+0x74>
    3b20:	10 e0       	ldi	r17, 0x00	; 0
    3b22:	11 23       	and	r17, r17
    3b24:	19 f0       	breq	.+6      	; 0x3b2c <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3b26:	81 e0       	ldi	r24, 0x01	; 1
    3b28:	8a 87       	std	Y+10, r24	; 0x0a
    3b2a:	a3 c0       	rjmp	.+326    	; 0x3c72 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    3b2c:	11 e0       	ldi	r17, 0x01	; 1
    3b2e:	6e 81       	ldd	r22, Y+6	; 0x06
    3b30:	7f 81       	ldd	r23, Y+7	; 0x07
    3b32:	88 85       	ldd	r24, Y+8	; 0x08
    3b34:	99 85       	ldd	r25, Y+9	; 0x09
    3b36:	20 e0       	ldi	r18, 0x00	; 0
    3b38:	30 e0       	ldi	r19, 0x00	; 0
    3b3a:	4f e7       	ldi	r20, 0x7F	; 127
    3b3c:	53 e4       	ldi	r21, 0x43	; 67
    3b3e:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    3b42:	18 16       	cp	r1, r24
    3b44:	0c f0       	brlt	.+2      	; 0x3b48 <ADC_Wait_8MHz+0x9a>
    3b46:	10 e0       	ldi	r17, 0x00	; 0
    3b48:	11 23       	and	r17, r17
    3b4a:	09 f4       	brne	.+2      	; 0x3b4e <ADC_Wait_8MHz+0xa0>
    3b4c:	89 c0       	rjmp	.+274    	; 0x3c60 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    3b4e:	6a 81       	ldd	r22, Y+2	; 0x02
    3b50:	7b 81       	ldd	r23, Y+3	; 0x03
    3b52:	8c 81       	ldd	r24, Y+4	; 0x04
    3b54:	9d 81       	ldd	r25, Y+5	; 0x05
    3b56:	20 e0       	ldi	r18, 0x00	; 0
    3b58:	30 e0       	ldi	r19, 0x00	; 0
    3b5a:	4a e7       	ldi	r20, 0x7A	; 122
    3b5c:	54 e4       	ldi	r21, 0x44	; 68
    3b5e:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    3b62:	dc 01       	movw	r26, r24
    3b64:	cb 01       	movw	r24, r22
    3b66:	8b 87       	std	Y+11, r24	; 0x0b
    3b68:	9c 87       	std	Y+12, r25	; 0x0c
    3b6a:	ad 87       	std	Y+13, r26	; 0x0d
    3b6c:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3b6e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b70:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b72:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b74:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b76:	20 e0       	ldi	r18, 0x00	; 0
    3b78:	30 e0       	ldi	r19, 0x00	; 0
    3b7a:	4a ef       	ldi	r20, 0xFA	; 250
    3b7c:	53 e4       	ldi	r21, 0x43	; 67
    3b7e:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    3b82:	dc 01       	movw	r26, r24
    3b84:	cb 01       	movw	r24, r22
    3b86:	8f 87       	std	Y+15, r24	; 0x0f
    3b88:	98 8b       	std	Y+16, r25	; 0x10
    3b8a:	a9 8b       	std	Y+17, r26	; 0x11
    3b8c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3b8e:	11 e0       	ldi	r17, 0x01	; 1
    3b90:	6f 85       	ldd	r22, Y+15	; 0x0f
    3b92:	78 89       	ldd	r23, Y+16	; 0x10
    3b94:	89 89       	ldd	r24, Y+17	; 0x11
    3b96:	9a 89       	ldd	r25, Y+18	; 0x12
    3b98:	20 e0       	ldi	r18, 0x00	; 0
    3b9a:	30 e0       	ldi	r19, 0x00	; 0
    3b9c:	40 e8       	ldi	r20, 0x80	; 128
    3b9e:	5f e3       	ldi	r21, 0x3F	; 63
    3ba0:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    3ba4:	88 23       	and	r24, r24
    3ba6:	0c f0       	brlt	.+2      	; 0x3baa <ADC_Wait_8MHz+0xfc>
    3ba8:	10 e0       	ldi	r17, 0x00	; 0
    3baa:	11 23       	and	r17, r17
    3bac:	29 f0       	breq	.+10     	; 0x3bb8 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    3bae:	81 e0       	ldi	r24, 0x01	; 1
    3bb0:	90 e0       	ldi	r25, 0x00	; 0
    3bb2:	8b 8b       	std	Y+19, r24	; 0x13
    3bb4:	9c 8b       	std	Y+20, r25	; 0x14
    3bb6:	46 c0       	rjmp	.+140    	; 0x3c44 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3bb8:	11 e0       	ldi	r17, 0x01	; 1
    3bba:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bbc:	78 89       	ldd	r23, Y+16	; 0x10
    3bbe:	89 89       	ldd	r24, Y+17	; 0x11
    3bc0:	9a 89       	ldd	r25, Y+18	; 0x12
    3bc2:	20 e0       	ldi	r18, 0x00	; 0
    3bc4:	3f ef       	ldi	r19, 0xFF	; 255
    3bc6:	4f e7       	ldi	r20, 0x7F	; 127
    3bc8:	57 e4       	ldi	r21, 0x47	; 71
    3bca:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    3bce:	18 16       	cp	r1, r24
    3bd0:	0c f0       	brlt	.+2      	; 0x3bd4 <ADC_Wait_8MHz+0x126>
    3bd2:	10 e0       	ldi	r17, 0x00	; 0
    3bd4:	11 23       	and	r17, r17
    3bd6:	61 f1       	breq	.+88     	; 0x3c30 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3bd8:	6b 85       	ldd	r22, Y+11	; 0x0b
    3bda:	7c 85       	ldd	r23, Y+12	; 0x0c
    3bdc:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bde:	9e 85       	ldd	r25, Y+14	; 0x0e
    3be0:	20 e0       	ldi	r18, 0x00	; 0
    3be2:	30 e0       	ldi	r19, 0x00	; 0
    3be4:	40 e2       	ldi	r20, 0x20	; 32
    3be6:	51 e4       	ldi	r21, 0x41	; 65
    3be8:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    3bec:	dc 01       	movw	r26, r24
    3bee:	cb 01       	movw	r24, r22
    3bf0:	bc 01       	movw	r22, r24
    3bf2:	cd 01       	movw	r24, r26
    3bf4:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    3bf8:	dc 01       	movw	r26, r24
    3bfa:	cb 01       	movw	r24, r22
    3bfc:	8b 8b       	std	Y+19, r24	; 0x13
    3bfe:	9c 8b       	std	Y+20, r25	; 0x14
    3c00:	12 c0       	rjmp	.+36     	; 0x3c26 <ADC_Wait_8MHz+0x178>
    3c02:	82 e3       	ldi	r24, 0x32	; 50
    3c04:	90 e0       	ldi	r25, 0x00	; 0
    3c06:	8d 8b       	std	Y+21, r24	; 0x15
    3c08:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3c0a:	8d 89       	ldd	r24, Y+21	; 0x15
    3c0c:	9e 89       	ldd	r25, Y+22	; 0x16
    3c0e:	8c 01       	movw	r16, r24
    3c10:	c8 01       	movw	r24, r16
    3c12:	01 97       	sbiw	r24, 0x01	; 1
    3c14:	f1 f7       	brne	.-4      	; 0x3c12 <ADC_Wait_8MHz+0x164>
    3c16:	8c 01       	movw	r16, r24
    3c18:	0d 8b       	std	Y+21, r16	; 0x15
    3c1a:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3c1c:	8b 89       	ldd	r24, Y+19	; 0x13
    3c1e:	9c 89       	ldd	r25, Y+20	; 0x14
    3c20:	01 97       	sbiw	r24, 0x01	; 1
    3c22:	8b 8b       	std	Y+19, r24	; 0x13
    3c24:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c26:	8b 89       	ldd	r24, Y+19	; 0x13
    3c28:	9c 89       	ldd	r25, Y+20	; 0x14
    3c2a:	00 97       	sbiw	r24, 0x00	; 0
    3c2c:	51 f7       	brne	.-44     	; 0x3c02 <ADC_Wait_8MHz+0x154>
    3c2e:	28 c0       	rjmp	.+80     	; 0x3c80 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c30:	6f 85       	ldd	r22, Y+15	; 0x0f
    3c32:	78 89       	ldd	r23, Y+16	; 0x10
    3c34:	89 89       	ldd	r24, Y+17	; 0x11
    3c36:	9a 89       	ldd	r25, Y+18	; 0x12
    3c38:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    3c3c:	dc 01       	movw	r26, r24
    3c3e:	cb 01       	movw	r24, r22
    3c40:	8b 8b       	std	Y+19, r24	; 0x13
    3c42:	9c 8b       	std	Y+20, r25	; 0x14
    3c44:	8b 89       	ldd	r24, Y+19	; 0x13
    3c46:	9c 89       	ldd	r25, Y+20	; 0x14
    3c48:	8f 8b       	std	Y+23, r24	; 0x17
    3c4a:	98 8f       	std	Y+24, r25	; 0x18
    3c4c:	8f 89       	ldd	r24, Y+23	; 0x17
    3c4e:	98 8d       	ldd	r25, Y+24	; 0x18
    3c50:	8c 01       	movw	r16, r24
    3c52:	f8 01       	movw	r30, r16
    3c54:	31 97       	sbiw	r30, 0x01	; 1
    3c56:	f1 f7       	brne	.-4      	; 0x3c54 <ADC_Wait_8MHz+0x1a6>
    3c58:	8f 01       	movw	r16, r30
    3c5a:	0f 8b       	std	Y+23, r16	; 0x17
    3c5c:	18 8f       	std	Y+24, r17	; 0x18
    3c5e:	10 c0       	rjmp	.+32     	; 0x3c80 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3c60:	6e 81       	ldd	r22, Y+6	; 0x06
    3c62:	7f 81       	ldd	r23, Y+7	; 0x07
    3c64:	88 85       	ldd	r24, Y+8	; 0x08
    3c66:	99 85       	ldd	r25, Y+9	; 0x09
    3c68:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    3c6c:	dc 01       	movw	r26, r24
    3c6e:	cb 01       	movw	r24, r22
    3c70:	8a 87       	std	Y+10, r24	; 0x0a
    3c72:	8a 85       	ldd	r24, Y+10	; 0x0a
    3c74:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3c76:	89 8d       	ldd	r24, Y+25	; 0x19
    3c78:	18 2f       	mov	r17, r24
    3c7a:	1a 95       	dec	r17
    3c7c:	f1 f7       	brne	.-4      	; 0x3c7a <ADC_Wait_8MHz+0x1cc>
    3c7e:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3c80:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3c82:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3c84:	29 81       	ldd	r18, Y+1	; 0x01
    3c86:	fc 01       	movw	r30, r24
    3c88:	24 83       	std	Z+4, r18	; 0x04
}
    3c8a:	6b 96       	adiw	r28, 0x1b	; 27
    3c8c:	cd bf       	out	0x3d, r28	; 61
    3c8e:	de bf       	out	0x3e, r29	; 62
    3c90:	df 91       	pop	r29
    3c92:	cf 91       	pop	r28
    3c94:	1f 91       	pop	r17
    3c96:	0f 91       	pop	r16
    3c98:	08 95       	ret

00003c9a <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    3c9a:	0f 93       	push	r16
    3c9c:	1f 93       	push	r17
    3c9e:	cf 93       	push	r28
    3ca0:	df 93       	push	r29
    3ca2:	cd b7       	in	r28, 0x3d	; 61
    3ca4:	de b7       	in	r29, 0x3e	; 62
    3ca6:	6b 97       	sbiw	r28, 0x1b	; 27
    3ca8:	cd bf       	out	0x3d, r28	; 61
    3caa:	de bf       	out	0x3e, r29	; 62
    3cac:	8a 8f       	std	Y+26, r24	; 0x1a
    3cae:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3cb0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cb2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cb4:	fc 01       	movw	r30, r24
    3cb6:	84 81       	ldd	r24, Z+4	; 0x04
    3cb8:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3cba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cbc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cbe:	21 e0       	ldi	r18, 0x01	; 1
    3cc0:	fc 01       	movw	r30, r24
    3cc2:	24 83       	std	Z+4, r18	; 0x04
    3cc4:	80 e0       	ldi	r24, 0x00	; 0
    3cc6:	90 e0       	ldi	r25, 0x00	; 0
    3cc8:	a0 e0       	ldi	r26, 0x00	; 0
    3cca:	b3 e4       	ldi	r27, 0x43	; 67
    3ccc:	8a 83       	std	Y+2, r24	; 0x02
    3cce:	9b 83       	std	Y+3, r25	; 0x03
    3cd0:	ac 83       	std	Y+4, r26	; 0x04
    3cd2:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3cd4:	6a 81       	ldd	r22, Y+2	; 0x02
    3cd6:	7b 81       	ldd	r23, Y+3	; 0x03
    3cd8:	8c 81       	ldd	r24, Y+4	; 0x04
    3cda:	9d 81       	ldd	r25, Y+5	; 0x05
    3cdc:	2b ea       	ldi	r18, 0xAB	; 171
    3cde:	3a ea       	ldi	r19, 0xAA	; 170
    3ce0:	4a e2       	ldi	r20, 0x2A	; 42
    3ce2:	5f e3       	ldi	r21, 0x3F	; 63
    3ce4:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    3ce8:	dc 01       	movw	r26, r24
    3cea:	cb 01       	movw	r24, r22
    3cec:	8e 83       	std	Y+6, r24	; 0x06
    3cee:	9f 83       	std	Y+7, r25	; 0x07
    3cf0:	a8 87       	std	Y+8, r26	; 0x08
    3cf2:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3cf4:	11 e0       	ldi	r17, 0x01	; 1
    3cf6:	6e 81       	ldd	r22, Y+6	; 0x06
    3cf8:	7f 81       	ldd	r23, Y+7	; 0x07
    3cfa:	88 85       	ldd	r24, Y+8	; 0x08
    3cfc:	99 85       	ldd	r25, Y+9	; 0x09
    3cfe:	20 e0       	ldi	r18, 0x00	; 0
    3d00:	30 e0       	ldi	r19, 0x00	; 0
    3d02:	40 e8       	ldi	r20, 0x80	; 128
    3d04:	5f e3       	ldi	r21, 0x3F	; 63
    3d06:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    3d0a:	88 23       	and	r24, r24
    3d0c:	0c f0       	brlt	.+2      	; 0x3d10 <ADC_Wait_32MHz+0x76>
    3d0e:	10 e0       	ldi	r17, 0x00	; 0
    3d10:	11 23       	and	r17, r17
    3d12:	19 f0       	breq	.+6      	; 0x3d1a <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3d14:	81 e0       	ldi	r24, 0x01	; 1
    3d16:	8a 87       	std	Y+10, r24	; 0x0a
    3d18:	a3 c0       	rjmp	.+326    	; 0x3e60 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3d1a:	11 e0       	ldi	r17, 0x01	; 1
    3d1c:	6e 81       	ldd	r22, Y+6	; 0x06
    3d1e:	7f 81       	ldd	r23, Y+7	; 0x07
    3d20:	88 85       	ldd	r24, Y+8	; 0x08
    3d22:	99 85       	ldd	r25, Y+9	; 0x09
    3d24:	20 e0       	ldi	r18, 0x00	; 0
    3d26:	30 e0       	ldi	r19, 0x00	; 0
    3d28:	4f e7       	ldi	r20, 0x7F	; 127
    3d2a:	53 e4       	ldi	r21, 0x43	; 67
    3d2c:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    3d30:	18 16       	cp	r1, r24
    3d32:	0c f0       	brlt	.+2      	; 0x3d36 <ADC_Wait_32MHz+0x9c>
    3d34:	10 e0       	ldi	r17, 0x00	; 0
    3d36:	11 23       	and	r17, r17
    3d38:	09 f4       	brne	.+2      	; 0x3d3c <ADC_Wait_32MHz+0xa2>
    3d3a:	89 c0       	rjmp	.+274    	; 0x3e4e <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3d3c:	6a 81       	ldd	r22, Y+2	; 0x02
    3d3e:	7b 81       	ldd	r23, Y+3	; 0x03
    3d40:	8c 81       	ldd	r24, Y+4	; 0x04
    3d42:	9d 81       	ldd	r25, Y+5	; 0x05
    3d44:	20 e0       	ldi	r18, 0x00	; 0
    3d46:	30 e0       	ldi	r19, 0x00	; 0
    3d48:	4a e7       	ldi	r20, 0x7A	; 122
    3d4a:	54 e4       	ldi	r21, 0x44	; 68
    3d4c:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    3d50:	dc 01       	movw	r26, r24
    3d52:	cb 01       	movw	r24, r22
    3d54:	8b 87       	std	Y+11, r24	; 0x0b
    3d56:	9c 87       	std	Y+12, r25	; 0x0c
    3d58:	ad 87       	std	Y+13, r26	; 0x0d
    3d5a:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3d5c:	6b 85       	ldd	r22, Y+11	; 0x0b
    3d5e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3d60:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d62:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d64:	20 e0       	ldi	r18, 0x00	; 0
    3d66:	30 e0       	ldi	r19, 0x00	; 0
    3d68:	4a ef       	ldi	r20, 0xFA	; 250
    3d6a:	53 e4       	ldi	r21, 0x43	; 67
    3d6c:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    3d70:	dc 01       	movw	r26, r24
    3d72:	cb 01       	movw	r24, r22
    3d74:	8f 87       	std	Y+15, r24	; 0x0f
    3d76:	98 8b       	std	Y+16, r25	; 0x10
    3d78:	a9 8b       	std	Y+17, r26	; 0x11
    3d7a:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3d7c:	11 e0       	ldi	r17, 0x01	; 1
    3d7e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3d80:	78 89       	ldd	r23, Y+16	; 0x10
    3d82:	89 89       	ldd	r24, Y+17	; 0x11
    3d84:	9a 89       	ldd	r25, Y+18	; 0x12
    3d86:	20 e0       	ldi	r18, 0x00	; 0
    3d88:	30 e0       	ldi	r19, 0x00	; 0
    3d8a:	40 e8       	ldi	r20, 0x80	; 128
    3d8c:	5f e3       	ldi	r21, 0x3F	; 63
    3d8e:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    3d92:	88 23       	and	r24, r24
    3d94:	0c f0       	brlt	.+2      	; 0x3d98 <ADC_Wait_32MHz+0xfe>
    3d96:	10 e0       	ldi	r17, 0x00	; 0
    3d98:	11 23       	and	r17, r17
    3d9a:	29 f0       	breq	.+10     	; 0x3da6 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    3d9c:	81 e0       	ldi	r24, 0x01	; 1
    3d9e:	90 e0       	ldi	r25, 0x00	; 0
    3da0:	8b 8b       	std	Y+19, r24	; 0x13
    3da2:	9c 8b       	std	Y+20, r25	; 0x14
    3da4:	46 c0       	rjmp	.+140    	; 0x3e32 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3da6:	11 e0       	ldi	r17, 0x01	; 1
    3da8:	6f 85       	ldd	r22, Y+15	; 0x0f
    3daa:	78 89       	ldd	r23, Y+16	; 0x10
    3dac:	89 89       	ldd	r24, Y+17	; 0x11
    3dae:	9a 89       	ldd	r25, Y+18	; 0x12
    3db0:	20 e0       	ldi	r18, 0x00	; 0
    3db2:	3f ef       	ldi	r19, 0xFF	; 255
    3db4:	4f e7       	ldi	r20, 0x7F	; 127
    3db6:	57 e4       	ldi	r21, 0x47	; 71
    3db8:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    3dbc:	18 16       	cp	r1, r24
    3dbe:	0c f0       	brlt	.+2      	; 0x3dc2 <ADC_Wait_32MHz+0x128>
    3dc0:	10 e0       	ldi	r17, 0x00	; 0
    3dc2:	11 23       	and	r17, r17
    3dc4:	61 f1       	breq	.+88     	; 0x3e1e <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3dc6:	6b 85       	ldd	r22, Y+11	; 0x0b
    3dc8:	7c 85       	ldd	r23, Y+12	; 0x0c
    3dca:	8d 85       	ldd	r24, Y+13	; 0x0d
    3dcc:	9e 85       	ldd	r25, Y+14	; 0x0e
    3dce:	20 e0       	ldi	r18, 0x00	; 0
    3dd0:	30 e0       	ldi	r19, 0x00	; 0
    3dd2:	40 e2       	ldi	r20, 0x20	; 32
    3dd4:	51 e4       	ldi	r21, 0x41	; 65
    3dd6:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    3dda:	dc 01       	movw	r26, r24
    3ddc:	cb 01       	movw	r24, r22
    3dde:	bc 01       	movw	r22, r24
    3de0:	cd 01       	movw	r24, r26
    3de2:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    3de6:	dc 01       	movw	r26, r24
    3de8:	cb 01       	movw	r24, r22
    3dea:	8b 8b       	std	Y+19, r24	; 0x13
    3dec:	9c 8b       	std	Y+20, r25	; 0x14
    3dee:	12 c0       	rjmp	.+36     	; 0x3e14 <ADC_Wait_32MHz+0x17a>
    3df0:	82 e3       	ldi	r24, 0x32	; 50
    3df2:	90 e0       	ldi	r25, 0x00	; 0
    3df4:	8d 8b       	std	Y+21, r24	; 0x15
    3df6:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3df8:	8d 89       	ldd	r24, Y+21	; 0x15
    3dfa:	9e 89       	ldd	r25, Y+22	; 0x16
    3dfc:	8c 01       	movw	r16, r24
    3dfe:	c8 01       	movw	r24, r16
    3e00:	01 97       	sbiw	r24, 0x01	; 1
    3e02:	f1 f7       	brne	.-4      	; 0x3e00 <ADC_Wait_32MHz+0x166>
    3e04:	8c 01       	movw	r16, r24
    3e06:	0d 8b       	std	Y+21, r16	; 0x15
    3e08:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e0a:	8b 89       	ldd	r24, Y+19	; 0x13
    3e0c:	9c 89       	ldd	r25, Y+20	; 0x14
    3e0e:	01 97       	sbiw	r24, 0x01	; 1
    3e10:	8b 8b       	std	Y+19, r24	; 0x13
    3e12:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e14:	8b 89       	ldd	r24, Y+19	; 0x13
    3e16:	9c 89       	ldd	r25, Y+20	; 0x14
    3e18:	00 97       	sbiw	r24, 0x00	; 0
    3e1a:	51 f7       	brne	.-44     	; 0x3df0 <ADC_Wait_32MHz+0x156>
    3e1c:	28 c0       	rjmp	.+80     	; 0x3e6e <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e1e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e20:	78 89       	ldd	r23, Y+16	; 0x10
    3e22:	89 89       	ldd	r24, Y+17	; 0x11
    3e24:	9a 89       	ldd	r25, Y+18	; 0x12
    3e26:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    3e2a:	dc 01       	movw	r26, r24
    3e2c:	cb 01       	movw	r24, r22
    3e2e:	8b 8b       	std	Y+19, r24	; 0x13
    3e30:	9c 8b       	std	Y+20, r25	; 0x14
    3e32:	8b 89       	ldd	r24, Y+19	; 0x13
    3e34:	9c 89       	ldd	r25, Y+20	; 0x14
    3e36:	8f 8b       	std	Y+23, r24	; 0x17
    3e38:	98 8f       	std	Y+24, r25	; 0x18
    3e3a:	8f 89       	ldd	r24, Y+23	; 0x17
    3e3c:	98 8d       	ldd	r25, Y+24	; 0x18
    3e3e:	8c 01       	movw	r16, r24
    3e40:	f8 01       	movw	r30, r16
    3e42:	31 97       	sbiw	r30, 0x01	; 1
    3e44:	f1 f7       	brne	.-4      	; 0x3e42 <ADC_Wait_32MHz+0x1a8>
    3e46:	8f 01       	movw	r16, r30
    3e48:	0f 8b       	std	Y+23, r16	; 0x17
    3e4a:	18 8f       	std	Y+24, r17	; 0x18
    3e4c:	10 c0       	rjmp	.+32     	; 0x3e6e <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3e4e:	6e 81       	ldd	r22, Y+6	; 0x06
    3e50:	7f 81       	ldd	r23, Y+7	; 0x07
    3e52:	88 85       	ldd	r24, Y+8	; 0x08
    3e54:	99 85       	ldd	r25, Y+9	; 0x09
    3e56:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    3e5a:	dc 01       	movw	r26, r24
    3e5c:	cb 01       	movw	r24, r22
    3e5e:	8a 87       	std	Y+10, r24	; 0x0a
    3e60:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e62:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3e64:	89 8d       	ldd	r24, Y+25	; 0x19
    3e66:	18 2f       	mov	r17, r24
    3e68:	1a 95       	dec	r17
    3e6a:	f1 f7       	brne	.-4      	; 0x3e68 <ADC_Wait_32MHz+0x1ce>
    3e6c:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3e6e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3e70:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3e72:	29 81       	ldd	r18, Y+1	; 0x01
    3e74:	fc 01       	movw	r30, r24
    3e76:	24 83       	std	Z+4, r18	; 0x04
}
    3e78:	6b 96       	adiw	r28, 0x1b	; 27
    3e7a:	cd bf       	out	0x3d, r28	; 61
    3e7c:	de bf       	out	0x3e, r29	; 62
    3e7e:	df 91       	pop	r29
    3e80:	cf 91       	pop	r28
    3e82:	1f 91       	pop	r17
    3e84:	0f 91       	pop	r16
    3e86:	08 95       	ret

00003e88 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3e88:	cf 93       	push	r28
    3e8a:	df 93       	push	r29
    3e8c:	cd b7       	in	r28, 0x3d	; 61
    3e8e:	de b7       	in	r29, 0x3e	; 62
    3e90:	2a 97       	sbiw	r28, 0x0a	; 10
    3e92:	cd bf       	out	0x3d, r28	; 61
    3e94:	de bf       	out	0x3e, r29	; 62
    3e96:	8e 83       	std	Y+6, r24	; 0x06
    3e98:	9f 83       	std	Y+7, r25	; 0x07
    3e9a:	68 87       	std	Y+8, r22	; 0x08
    3e9c:	79 87       	std	Y+9, r23	; 0x09
    3e9e:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3ea0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ea2:	88 23       	and	r24, r24
    3ea4:	a9 f1       	breq	.+106    	; 0x3f10 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3ea6:	19 82       	std	Y+1, r1	; 0x01
    3ea8:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3eaa:	1b 82       	std	Y+3, r1	; 0x03
    3eac:	1c 82       	std	Y+4, r1	; 0x04
    3eae:	24 c0       	rjmp	.+72     	; 0x3ef8 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3eb0:	88 85       	ldd	r24, Y+8	; 0x08
    3eb2:	99 85       	ldd	r25, Y+9	; 0x09
    3eb4:	fc 01       	movw	r30, r24
    3eb6:	80 81       	ld	r24, Z
    3eb8:	28 2f       	mov	r18, r24
    3eba:	20 68       	ori	r18, 0x80	; 128
    3ebc:	88 85       	ldd	r24, Y+8	; 0x08
    3ebe:	99 85       	ldd	r25, Y+9	; 0x09
    3ec0:	fc 01       	movw	r30, r24
    3ec2:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3ec4:	88 85       	ldd	r24, Y+8	; 0x08
    3ec6:	99 85       	ldd	r25, Y+9	; 0x09
    3ec8:	fc 01       	movw	r30, r24
    3eca:	83 81       	ldd	r24, Z+3	; 0x03
    3ecc:	88 2f       	mov	r24, r24
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	81 70       	andi	r24, 0x01	; 1
    3ed2:	90 70       	andi	r25, 0x00	; 0
    3ed4:	00 97       	sbiw	r24, 0x00	; 0
    3ed6:	b1 f3       	breq	.-20     	; 0x3ec4 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3ed8:	88 85       	ldd	r24, Y+8	; 0x08
    3eda:	99 85       	ldd	r25, Y+9	; 0x09
    3edc:	60 e0       	ldi	r22, 0x00	; 0
    3ede:	0e 94 c9 1c 	call	0x3992	; 0x3992 <ADC_ResultCh_GetWord_Unsigned>
    3ee2:	29 81       	ldd	r18, Y+1	; 0x01
    3ee4:	3a 81       	ldd	r19, Y+2	; 0x02
    3ee6:	82 0f       	add	r24, r18
    3ee8:	93 1f       	adc	r25, r19
    3eea:	89 83       	std	Y+1, r24	; 0x01
    3eec:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3eee:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef2:	01 96       	adiw	r24, 0x01	; 1
    3ef4:	8b 83       	std	Y+3, r24	; 0x03
    3ef6:	9c 83       	std	Y+4, r25	; 0x04
    3ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    3efa:	9c 81       	ldd	r25, Y+4	; 0x04
    3efc:	84 30       	cpi	r24, 0x04	; 4
    3efe:	91 05       	cpc	r25, r1
    3f00:	bc f2       	brlt	.-82     	; 0x3eb0 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3f02:	89 81       	ldd	r24, Y+1	; 0x01
    3f04:	9a 81       	ldd	r25, Y+2	; 0x02
    3f06:	96 95       	lsr	r25
    3f08:	87 95       	ror	r24
    3f0a:	96 95       	lsr	r25
    3f0c:	87 95       	ror	r24
    3f0e:	1b c0       	rjmp	.+54     	; 0x3f46 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3f10:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3f12:	88 85       	ldd	r24, Y+8	; 0x08
    3f14:	99 85       	ldd	r25, Y+9	; 0x09
    3f16:	fc 01       	movw	r30, r24
    3f18:	80 81       	ld	r24, Z
    3f1a:	28 2f       	mov	r18, r24
    3f1c:	20 68       	ori	r18, 0x80	; 128
    3f1e:	88 85       	ldd	r24, Y+8	; 0x08
    3f20:	99 85       	ldd	r25, Y+9	; 0x09
    3f22:	fc 01       	movw	r30, r24
    3f24:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3f26:	88 85       	ldd	r24, Y+8	; 0x08
    3f28:	99 85       	ldd	r25, Y+9	; 0x09
    3f2a:	fc 01       	movw	r30, r24
    3f2c:	83 81       	ldd	r24, Z+3	; 0x03
    3f2e:	88 2f       	mov	r24, r24
    3f30:	90 e0       	ldi	r25, 0x00	; 0
    3f32:	81 70       	andi	r24, 0x01	; 1
    3f34:	90 70       	andi	r25, 0x00	; 0
    3f36:	00 97       	sbiw	r24, 0x00	; 0
    3f38:	b1 f3       	breq	.-20     	; 0x3f26 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3f3a:	88 85       	ldd	r24, Y+8	; 0x08
    3f3c:	99 85       	ldd	r25, Y+9	; 0x09
    3f3e:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <ADC_ResultCh_GetWord>
    3f42:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3f44:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3f46:	2a 96       	adiw	r28, 0x0a	; 10
    3f48:	cd bf       	out	0x3d, r28	; 61
    3f4a:	de bf       	out	0x3e, r29	; 62
    3f4c:	df 91       	pop	r29
    3f4e:	cf 91       	pop	r28
    3f50:	08 95       	ret

00003f52 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3f52:	cf 93       	push	r28
    3f54:	df 93       	push	r29
    3f56:	cd b7       	in	r28, 0x3d	; 61
    3f58:	de b7       	in	r29, 0x3e	; 62
    3f5a:	2a 97       	sbiw	r28, 0x0a	; 10
    3f5c:	cd bf       	out	0x3d, r28	; 61
    3f5e:	de bf       	out	0x3e, r29	; 62
    3f60:	8e 83       	std	Y+6, r24	; 0x06
    3f62:	9f 83       	std	Y+7, r25	; 0x07
    3f64:	68 87       	std	Y+8, r22	; 0x08
    3f66:	79 87       	std	Y+9, r23	; 0x09
    3f68:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3f6a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f6c:	88 23       	and	r24, r24
    3f6e:	c1 f1       	breq	.+112    	; 0x3fe0 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3f70:	19 82       	std	Y+1, r1	; 0x01
    3f72:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3f74:	1b 82       	std	Y+3, r1	; 0x03
    3f76:	1c 82       	std	Y+4, r1	; 0x04
    3f78:	24 c0       	rjmp	.+72     	; 0x3fc2 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3f7a:	88 85       	ldd	r24, Y+8	; 0x08
    3f7c:	99 85       	ldd	r25, Y+9	; 0x09
    3f7e:	fc 01       	movw	r30, r24
    3f80:	80 81       	ld	r24, Z
    3f82:	28 2f       	mov	r18, r24
    3f84:	20 68       	ori	r18, 0x80	; 128
    3f86:	88 85       	ldd	r24, Y+8	; 0x08
    3f88:	99 85       	ldd	r25, Y+9	; 0x09
    3f8a:	fc 01       	movw	r30, r24
    3f8c:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3f8e:	88 85       	ldd	r24, Y+8	; 0x08
    3f90:	99 85       	ldd	r25, Y+9	; 0x09
    3f92:	fc 01       	movw	r30, r24
    3f94:	83 81       	ldd	r24, Z+3	; 0x03
    3f96:	88 2f       	mov	r24, r24
    3f98:	90 e0       	ldi	r25, 0x00	; 0
    3f9a:	81 70       	andi	r24, 0x01	; 1
    3f9c:	90 70       	andi	r25, 0x00	; 0
    3f9e:	00 97       	sbiw	r24, 0x00	; 0
    3fa0:	b1 f3       	breq	.-20     	; 0x3f8e <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3fa2:	88 85       	ldd	r24, Y+8	; 0x08
    3fa4:	99 85       	ldd	r25, Y+9	; 0x09
    3fa6:	60 e0       	ldi	r22, 0x00	; 0
    3fa8:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <ADC_ResultCh_GetWord_Signed>
    3fac:	29 81       	ldd	r18, Y+1	; 0x01
    3fae:	3a 81       	ldd	r19, Y+2	; 0x02
    3fb0:	82 0f       	add	r24, r18
    3fb2:	93 1f       	adc	r25, r19
    3fb4:	89 83       	std	Y+1, r24	; 0x01
    3fb6:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fba:	9c 81       	ldd	r25, Y+4	; 0x04
    3fbc:	01 96       	adiw	r24, 0x01	; 1
    3fbe:	8b 83       	std	Y+3, r24	; 0x03
    3fc0:	9c 83       	std	Y+4, r25	; 0x04
    3fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    3fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    3fc6:	84 30       	cpi	r24, 0x04	; 4
    3fc8:	91 05       	cpc	r25, r1
    3fca:	bc f2       	brlt	.-82     	; 0x3f7a <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3fcc:	89 81       	ldd	r24, Y+1	; 0x01
    3fce:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd0:	99 23       	and	r25, r25
    3fd2:	0c f4       	brge	.+2      	; 0x3fd6 <ADC_Offset_Get_Signed+0x84>
    3fd4:	03 96       	adiw	r24, 0x03	; 3
    3fd6:	95 95       	asr	r25
    3fd8:	87 95       	ror	r24
    3fda:	95 95       	asr	r25
    3fdc:	87 95       	ror	r24
    3fde:	1c c0       	rjmp	.+56     	; 0x4018 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3fe0:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3fe2:	88 85       	ldd	r24, Y+8	; 0x08
    3fe4:	99 85       	ldd	r25, Y+9	; 0x09
    3fe6:	fc 01       	movw	r30, r24
    3fe8:	80 81       	ld	r24, Z
    3fea:	28 2f       	mov	r18, r24
    3fec:	20 68       	ori	r18, 0x80	; 128
    3fee:	88 85       	ldd	r24, Y+8	; 0x08
    3ff0:	99 85       	ldd	r25, Y+9	; 0x09
    3ff2:	fc 01       	movw	r30, r24
    3ff4:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3ff6:	88 85       	ldd	r24, Y+8	; 0x08
    3ff8:	99 85       	ldd	r25, Y+9	; 0x09
    3ffa:	fc 01       	movw	r30, r24
    3ffc:	83 81       	ldd	r24, Z+3	; 0x03
    3ffe:	88 2f       	mov	r24, r24
    4000:	90 e0       	ldi	r25, 0x00	; 0
    4002:	81 70       	andi	r24, 0x01	; 1
    4004:	90 70       	andi	r25, 0x00	; 0
    4006:	00 97       	sbiw	r24, 0x00	; 0
    4008:	b1 f3       	breq	.-20     	; 0x3ff6 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    400a:	88 85       	ldd	r24, Y+8	; 0x08
    400c:	99 85       	ldd	r25, Y+9	; 0x09
    400e:	60 e0       	ldi	r22, 0x00	; 0
    4010:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <ADC_ResultCh_GetWord_Signed>
    4014:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    4016:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    4018:	2a 96       	adiw	r28, 0x0a	; 10
    401a:	cd bf       	out	0x3d, r28	; 61
    401c:	de bf       	out	0x3e, r29	; 62
    401e:	df 91       	pop	r29
    4020:	cf 91       	pop	r28
    4022:	08 95       	ret

00004024 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    4024:	1f 93       	push	r17
    4026:	cf 93       	push	r28
    4028:	df 93       	push	r29
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
    402e:	25 97       	sbiw	r28, 0x05	; 5
    4030:	cd bf       	out	0x3d, r28	; 61
    4032:	de bf       	out	0x3e, r29	; 62
    4034:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    4036:	8a ec       	ldi	r24, 0xCA	; 202
    4038:	91 e0       	ldi	r25, 0x01	; 1
    403a:	22 e0       	ldi	r18, 0x02	; 2
    403c:	fc 01       	movw	r30, r24
    403e:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    4040:	8d 81       	ldd	r24, Y+5	; 0x05
    4042:	88 2f       	mov	r24, r24
    4044:	90 e0       	ldi	r25, 0x00	; 0
    4046:	89 83       	std	Y+1, r24	; 0x01
    4048:	9a 83       	std	Y+2, r25	; 0x02
    404a:	89 81       	ldd	r24, Y+1	; 0x01
    404c:	9a 81       	ldd	r25, Y+2	; 0x02
    404e:	fc 01       	movw	r30, r24
    4050:	14 91       	lpm	r17, Z
    4052:	1b 83       	std	Y+3, r17	; 0x03
    4054:	8b 81       	ldd	r24, Y+3	; 0x03
    4056:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    4058:	8a ec       	ldi	r24, 0xCA	; 202
    405a:	91 e0       	ldi	r25, 0x01	; 1
    405c:	fc 01       	movw	r30, r24
    405e:	10 82       	st	Z, r1

	return result;
    4060:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4062:	25 96       	adiw	r28, 0x05	; 5
    4064:	cd bf       	out	0x3d, r28	; 61
    4066:	de bf       	out	0x3e, r29	; 62
    4068:	df 91       	pop	r29
    406a:	cf 91       	pop	r28
    406c:	1f 91       	pop	r17
    406e:	08 95       	ret

00004070 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    4070:	cf 93       	push	r28
    4072:	df 93       	push	r29
    4074:	cd b7       	in	r28, 0x3d	; 61
    4076:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    4078:	24 e1       	ldi	r18, 0x14	; 20
    407a:	80 e4       	ldi	r24, 0x40	; 64
    407c:	91 e2       	ldi	r25, 0x21	; 33
    407e:	fc 01       	movw	r30, r24
    4080:	32 2f       	mov	r19, r18
    4082:	11 92       	st	Z+, r1
    4084:	3a 95       	dec	r19
    4086:	e9 f7       	brne	.-6      	; 0x4082 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    4088:	0e 94 f8 2d 	call	0x5bf0	; 0x5bf0 <chb_get_short_addr>
    408c:	80 93 40 21 	sts	0x2140, r24
    4090:	90 93 41 21 	sts	0x2141, r25
    chb_drvr_init();
    4094:	0e 94 ec 2f 	call	0x5fd8	; 0x5fd8 <chb_drvr_init>
	radio_msg_received_int_enable();
    4098:	0e 94 51 20 	call	0x40a2	; 0x40a2 <radio_msg_received_int_enable>
}
    409c:	df 91       	pop	r29
    409e:	cf 91       	pop	r28
    40a0:	08 95       	ret

000040a2 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    40a2:	cf 93       	push	r28
    40a4:	df 93       	push	r29
    40a6:	cd b7       	in	r28, 0x3d	; 61
    40a8:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    40aa:	80 e8       	ldi	r24, 0x80	; 128
    40ac:	96 e0       	ldi	r25, 0x06	; 6
    40ae:	24 e0       	ldi	r18, 0x04	; 4
    40b0:	fc 01       	movw	r30, r24
    40b2:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    40b4:	80 e8       	ldi	r24, 0x80	; 128
    40b6:	96 e0       	ldi	r25, 0x06	; 6
    40b8:	24 e0       	ldi	r18, 0x04	; 4
    40ba:	fc 01       	movw	r30, r24
    40bc:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    40be:	80 e8       	ldi	r24, 0x80	; 128
    40c0:	96 e0       	ldi	r25, 0x06	; 6
    40c2:	22 e0       	ldi	r18, 0x02	; 2
    40c4:	fc 01       	movw	r30, r24
    40c6:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    40c8:	80 e8       	ldi	r24, 0x80	; 128
    40ca:	96 e0       	ldi	r25, 0x06	; 6
    40cc:	24 e0       	ldi	r18, 0x04	; 4
    40ce:	fc 01       	movw	r30, r24
    40d0:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_LO_gc;
    40d2:	80 e8       	ldi	r24, 0x80	; 128
    40d4:	96 e0       	ldi	r25, 0x06	; 6
    40d6:	21 e0       	ldi	r18, 0x01	; 1
    40d8:	fc 01       	movw	r30, r24
    40da:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    40dc:	80 ea       	ldi	r24, 0xA0	; 160
    40de:	90 e0       	ldi	r25, 0x00	; 0
    40e0:	20 ea       	ldi	r18, 0xA0	; 160
    40e2:	30 e0       	ldi	r19, 0x00	; 0
    40e4:	f9 01       	movw	r30, r18
    40e6:	22 81       	ldd	r18, Z+2	; 0x02
    40e8:	21 60       	ori	r18, 0x01	; 1
    40ea:	fc 01       	movw	r30, r24
    40ec:	22 83       	std	Z+2, r18	; 0x02
	sei();
    40ee:	78 94       	sei
}
    40f0:	df 91       	pop	r29
    40f2:	cf 91       	pop	r28
    40f4:	08 95       	ret

000040f6 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    40f6:	cf 93       	push	r28
    40f8:	df 93       	push	r29
    40fa:	cd b7       	in	r28, 0x3d	; 61
    40fc:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    40fe:	80 e4       	ldi	r24, 0x40	; 64
    4100:	91 e2       	ldi	r25, 0x21	; 33
}
    4102:	df 91       	pop	r29
    4104:	cf 91       	pop	r28
    4106:	08 95       	ret

00004108 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    4108:	cf 93       	push	r28
    410a:	df 93       	push	r29
    410c:	cd b7       	in	r28, 0x3d	; 61
    410e:	de b7       	in	r29, 0x3e	; 62
    4110:	27 97       	sbiw	r28, 0x07	; 7
    4112:	cd bf       	out	0x3d, r28	; 61
    4114:	de bf       	out	0x3e, r29	; 62
    4116:	8b 83       	std	Y+3, r24	; 0x03
    4118:	9c 83       	std	Y+4, r25	; 0x04
    411a:	6d 83       	std	Y+5, r22	; 0x05
    411c:	7e 83       	std	Y+6, r23	; 0x06
    411e:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    4120:	8b 81       	ldd	r24, Y+3	; 0x03
    4122:	9c 81       	ldd	r25, Y+4	; 0x04
    4124:	89 83       	std	Y+1, r24	; 0x01
    4126:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    4128:	8f 81       	ldd	r24, Y+7	; 0x07
    412a:	28 2f       	mov	r18, r24
    412c:	25 5f       	subi	r18, 0xF5	; 245
    412e:	89 81       	ldd	r24, Y+1	; 0x01
    4130:	9a 81       	ldd	r25, Y+2	; 0x02
    4132:	fc 01       	movw	r30, r24
    4134:	20 83       	st	Z, r18
    4136:	89 81       	ldd	r24, Y+1	; 0x01
    4138:	9a 81       	ldd	r25, Y+2	; 0x02
    413a:	01 96       	adiw	r24, 0x01	; 1
    413c:	89 83       	std	Y+1, r24	; 0x01
    413e:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    4140:	8d 81       	ldd	r24, Y+5	; 0x05
    4142:	9e 81       	ldd	r25, Y+6	; 0x06
    4144:	ff ef       	ldi	r31, 0xFF	; 255
    4146:	8f 3f       	cpi	r24, 0xFF	; 255
    4148:	9f 07       	cpc	r25, r31
    414a:	11 f0       	breq	.+4      	; 0x4150 <chb_gen_hdr+0x48>
    414c:	21 e6       	ldi	r18, 0x61	; 97
    414e:	01 c0       	rjmp	.+2      	; 0x4152 <chb_gen_hdr+0x4a>
    4150:	21 e4       	ldi	r18, 0x41	; 65
    4152:	89 81       	ldd	r24, Y+1	; 0x01
    4154:	9a 81       	ldd	r25, Y+2	; 0x02
    4156:	fc 01       	movw	r30, r24
    4158:	20 83       	st	Z, r18
    415a:	89 81       	ldd	r24, Y+1	; 0x01
    415c:	9a 81       	ldd	r25, Y+2	; 0x02
    415e:	01 96       	adiw	r24, 0x01	; 1
    4160:	89 83       	std	Y+1, r24	; 0x01
    4162:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    4164:	89 81       	ldd	r24, Y+1	; 0x01
    4166:	9a 81       	ldd	r25, Y+2	; 0x02
    4168:	28 e9       	ldi	r18, 0x98	; 152
    416a:	fc 01       	movw	r30, r24
    416c:	20 83       	st	Z, r18
    416e:	89 81       	ldd	r24, Y+1	; 0x01
    4170:	9a 81       	ldd	r25, Y+2	; 0x02
    4172:	01 96       	adiw	r24, 0x01	; 1
    4174:	89 83       	std	Y+1, r24	; 0x01
    4176:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    4178:	20 91 42 21 	lds	r18, 0x2142
    417c:	89 81       	ldd	r24, Y+1	; 0x01
    417e:	9a 81       	ldd	r25, Y+2	; 0x02
    4180:	fc 01       	movw	r30, r24
    4182:	20 83       	st	Z, r18
    4184:	89 81       	ldd	r24, Y+1	; 0x01
    4186:	9a 81       	ldd	r25, Y+2	; 0x02
    4188:	01 96       	adiw	r24, 0x01	; 1
    418a:	89 83       	std	Y+1, r24	; 0x01
    418c:	9a 83       	std	Y+2, r25	; 0x02
    418e:	82 2f       	mov	r24, r18
    4190:	8f 5f       	subi	r24, 0xFF	; 255
    4192:	80 93 42 21 	sts	0x2142, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    4196:	89 81       	ldd	r24, Y+1	; 0x01
    4198:	9a 81       	ldd	r25, Y+2	; 0x02
    419a:	24 e3       	ldi	r18, 0x34	; 52
    419c:	32 e1       	ldi	r19, 0x12	; 18
    419e:	fc 01       	movw	r30, r24
    41a0:	20 83       	st	Z, r18
    41a2:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41a4:	89 81       	ldd	r24, Y+1	; 0x01
    41a6:	9a 81       	ldd	r25, Y+2	; 0x02
    41a8:	02 96       	adiw	r24, 0x02	; 2
    41aa:	89 83       	std	Y+1, r24	; 0x01
    41ac:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    41ae:	89 81       	ldd	r24, Y+1	; 0x01
    41b0:	9a 81       	ldd	r25, Y+2	; 0x02
    41b2:	2d 81       	ldd	r18, Y+5	; 0x05
    41b4:	3e 81       	ldd	r19, Y+6	; 0x06
    41b6:	fc 01       	movw	r30, r24
    41b8:	20 83       	st	Z, r18
    41ba:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41bc:	89 81       	ldd	r24, Y+1	; 0x01
    41be:	9a 81       	ldd	r25, Y+2	; 0x02
    41c0:	02 96       	adiw	r24, 0x02	; 2
    41c2:	89 83       	std	Y+1, r24	; 0x01
    41c4:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    41c6:	20 91 40 21 	lds	r18, 0x2140
    41ca:	30 91 41 21 	lds	r19, 0x2141
    41ce:	89 81       	ldd	r24, Y+1	; 0x01
    41d0:	9a 81       	ldd	r25, Y+2	; 0x02
    41d2:	fc 01       	movw	r30, r24
    41d4:	20 83       	st	Z, r18
    41d6:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41d8:	89 81       	ldd	r24, Y+1	; 0x01
    41da:	9a 81       	ldd	r25, Y+2	; 0x02
    41dc:	02 96       	adiw	r24, 0x02	; 2
    41de:	89 83       	std	Y+1, r24	; 0x01
    41e0:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    41e2:	29 81       	ldd	r18, Y+1	; 0x01
    41e4:	3a 81       	ldd	r19, Y+2	; 0x02
    41e6:	8b 81       	ldd	r24, Y+3	; 0x03
    41e8:	9c 81       	ldd	r25, Y+4	; 0x04
    41ea:	a9 01       	movw	r20, r18
    41ec:	48 1b       	sub	r20, r24
    41ee:	59 0b       	sbc	r21, r25
    41f0:	ca 01       	movw	r24, r20
}
    41f2:	27 96       	adiw	r28, 0x07	; 7
    41f4:	cd bf       	out	0x3d, r28	; 61
    41f6:	de bf       	out	0x3e, r29	; 62
    41f8:	df 91       	pop	r29
    41fa:	cf 91       	pop	r28
    41fc:	08 95       	ret

000041fe <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    41fe:	ef 92       	push	r14
    4200:	ff 92       	push	r15
    4202:	0f 93       	push	r16
    4204:	1f 93       	push	r17
    4206:	cf 93       	push	r28
    4208:	df 93       	push	r29
    420a:	cd b7       	in	r28, 0x3d	; 61
    420c:	de b7       	in	r29, 0x3e	; 62
    420e:	e0 97       	sbiw	r28, 0x30	; 48
    4210:	cd bf       	out	0x3d, r28	; 61
    4212:	de bf       	out	0x3e, r29	; 62
    4214:	89 a7       	lds	r24, 0x79
    4216:	9a a7       	lds	r25, 0x7a
    4218:	6b a7       	lds	r22, 0x7b
    421a:	7c a7       	lds	r23, 0x7c
    421c:	2d a7       	lds	r18, 0x7d
    421e:	3e a7       	lds	r19, 0x7e
    4220:	4f a7       	lds	r20, 0x7f
    4222:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    4224:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    4226:	5c c1       	rjmp	.+696    	; 0x44e0 <chb_write+0x2e2>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    4228:	8d a5       	lds	r24, 0x6d
    422a:	9e a5       	lds	r25, 0x6e
    422c:	af a5       	lds	r26, 0x6f
    422e:	b8 a9       	sts	0x48, r27
    4230:	85 36       	cpi	r24, 0x65	; 101
    4232:	91 05       	cpc	r25, r1
    4234:	a1 05       	cpc	r26, r1
    4236:	b1 05       	cpc	r27, r1
    4238:	20 f0       	brcs	.+8      	; 0x4242 <chb_write+0x44>
    423a:	84 e6       	ldi	r24, 0x64	; 100
    423c:	90 e0       	ldi	r25, 0x00	; 0
    423e:	a0 e0       	ldi	r26, 0x00	; 0
    4240:	b0 e0       	ldi	r27, 0x00	; 0
    4242:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    4244:	ce 01       	movw	r24, r28
    4246:	4f 96       	adiw	r24, 0x1f	; 31
    4248:	29 a5       	lds	r18, 0x69
    424a:	3a a5       	lds	r19, 0x6a
    424c:	b9 01       	movw	r22, r18
    424e:	4c 81       	ldd	r20, Y+4	; 0x04
    4250:	0e 94 84 20 	call	0x4108	; 0x4108 <chb_gen_hdr>
    4254:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    4256:	1a 82       	std	Y+2, r1	; 0x02
    4258:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    425a:	89 81       	ldd	r24, Y+1	; 0x01
    425c:	88 2f       	mov	r24, r24
    425e:	90 e0       	ldi	r25, 0x00	; 0
    4260:	2b a5       	lds	r18, 0x6b
    4262:	3c a5       	lds	r19, 0x6c
    4264:	28 0f       	add	r18, r24
    4266:	39 1f       	adc	r19, r25
    4268:	ce 01       	movw	r24, r28
    426a:	4f 96       	adiw	r24, 0x1f	; 31
    426c:	b9 01       	movw	r22, r18
    426e:	4c 81       	ldd	r20, Y+4	; 0x04
    4270:	0e 94 12 2e 	call	0x5c24	; 0x5c24 <chb_tx>
    4274:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    4276:	8e 81       	ldd	r24, Y+6	; 0x06
    4278:	88 2f       	mov	r24, r24
    427a:	90 e0       	ldi	r25, 0x00	; 0
    427c:	83 30       	cpi	r24, 0x03	; 3
    427e:	91 05       	cpc	r25, r1
    4280:	09 f1       	breq	.+66     	; 0x42c4 <chb_write+0xc6>
    4282:	84 30       	cpi	r24, 0x04	; 4
    4284:	91 05       	cpc	r25, r1
    4286:	24 f4       	brge	.+8      	; 0x4290 <chb_write+0x92>
    4288:	81 30       	cpi	r24, 0x01	; 1
    428a:	91 05       	cpc	r25, r1
    428c:	39 f0       	breq	.+14     	; 0x429c <chb_write+0x9e>
    428e:	24 c0       	rjmp	.+72     	; 0x42d8 <chb_write+0xda>
    4290:	85 30       	cpi	r24, 0x05	; 5
    4292:	91 05       	cpc	r25, r1
    4294:	69 f0       	breq	.+26     	; 0x42b0 <chb_write+0xb2>
    4296:	80 34       	cpi	r24, 0x40	; 64
    4298:	91 05       	cpc	r25, r1
    429a:	f1 f4       	brne	.+60     	; 0x42d8 <chb_write+0xda>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    429c:	80 91 47 21 	lds	r24, 0x2147
    42a0:	90 91 48 21 	lds	r25, 0x2148
    42a4:	01 96       	adiw	r24, 0x01	; 1
    42a6:	80 93 47 21 	sts	0x2147, r24
    42aa:	90 93 48 21 	sts	0x2148, r25
                 break;
    42ae:	15 c0       	rjmp	.+42     	; 0x42da <chb_write+0xdc>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    42b0:	80 91 49 21 	lds	r24, 0x2149
    42b4:	90 91 4a 21 	lds	r25, 0x214A
    42b8:	01 96       	adiw	r24, 0x01	; 1
    42ba:	80 93 49 21 	sts	0x2149, r24
    42be:	90 93 4a 21 	sts	0x214A, r25
                 break;
    42c2:	0b c0       	rjmp	.+22     	; 0x42da <chb_write+0xdc>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    42c4:	80 91 4b 21 	lds	r24, 0x214B
    42c8:	90 91 4c 21 	lds	r25, 0x214C
    42cc:	01 96       	adiw	r24, 0x01	; 1
    42ce:	80 93 4b 21 	sts	0x214B, r24
    42d2:	90 93 4c 21 	sts	0x214C, r25
                 break;
    42d6:	01 c0       	rjmp	.+2      	; 0x42da <chb_write+0xdc>
 
             default:
                 break;
    42d8:	00 00       	nop
             }
			if(rtry>=0) _delay_us(100);		//if not successfully sent the first time, wait some time and try again
    42da:	8a 81       	ldd	r24, Y+2	; 0x02
    42dc:	9b 81       	ldd	r25, Y+3	; 0x03
    42de:	99 23       	and	r25, r25
    42e0:	0c f4       	brge	.+2      	; 0x42e4 <chb_write+0xe6>
    42e2:	d5 c0       	rjmp	.+426    	; 0x448e <chb_write+0x290>
    42e4:	80 e0       	ldi	r24, 0x00	; 0
    42e6:	90 e0       	ldi	r25, 0x00	; 0
    42e8:	a8 ec       	ldi	r26, 0xC8	; 200
    42ea:	b2 e4       	ldi	r27, 0x42	; 66
    42ec:	8f 83       	std	Y+7, r24	; 0x07
    42ee:	98 87       	std	Y+8, r25	; 0x08
    42f0:	a9 87       	std	Y+9, r26	; 0x09
    42f2:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    42f4:	6f 81       	ldd	r22, Y+7	; 0x07
    42f6:	78 85       	ldd	r23, Y+8	; 0x08
    42f8:	89 85       	ldd	r24, Y+9	; 0x09
    42fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    42fc:	2b ea       	ldi	r18, 0xAB	; 171
    42fe:	3a ea       	ldi	r19, 0xAA	; 170
    4300:	4a ea       	ldi	r20, 0xAA	; 170
    4302:	5e e3       	ldi	r21, 0x3E	; 62
    4304:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    4308:	dc 01       	movw	r26, r24
    430a:	cb 01       	movw	r24, r22
    430c:	8b 87       	std	Y+11, r24	; 0x0b
    430e:	9c 87       	std	Y+12, r25	; 0x0c
    4310:	ad 87       	std	Y+13, r26	; 0x0d
    4312:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    4314:	11 e0       	ldi	r17, 0x01	; 1
    4316:	6b 85       	ldd	r22, Y+11	; 0x0b
    4318:	7c 85       	ldd	r23, Y+12	; 0x0c
    431a:	8d 85       	ldd	r24, Y+13	; 0x0d
    431c:	9e 85       	ldd	r25, Y+14	; 0x0e
    431e:	20 e0       	ldi	r18, 0x00	; 0
    4320:	30 e0       	ldi	r19, 0x00	; 0
    4322:	40 e8       	ldi	r20, 0x80	; 128
    4324:	5f e3       	ldi	r21, 0x3F	; 63
    4326:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    432a:	88 23       	and	r24, r24
    432c:	0c f0       	brlt	.+2      	; 0x4330 <chb_write+0x132>
    432e:	10 e0       	ldi	r17, 0x00	; 0
    4330:	11 23       	and	r17, r17
    4332:	19 f0       	breq	.+6      	; 0x433a <chb_write+0x13c>
		__ticks = 1;
    4334:	81 e0       	ldi	r24, 0x01	; 1
    4336:	8f 87       	std	Y+15, r24	; 0x0f
    4338:	a3 c0       	rjmp	.+326    	; 0x4480 <chb_write+0x282>
	else if (__tmp > 255)
    433a:	11 e0       	ldi	r17, 0x01	; 1
    433c:	6b 85       	ldd	r22, Y+11	; 0x0b
    433e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4340:	8d 85       	ldd	r24, Y+13	; 0x0d
    4342:	9e 85       	ldd	r25, Y+14	; 0x0e
    4344:	20 e0       	ldi	r18, 0x00	; 0
    4346:	30 e0       	ldi	r19, 0x00	; 0
    4348:	4f e7       	ldi	r20, 0x7F	; 127
    434a:	53 e4       	ldi	r21, 0x43	; 67
    434c:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    4350:	18 16       	cp	r1, r24
    4352:	0c f0       	brlt	.+2      	; 0x4356 <chb_write+0x158>
    4354:	10 e0       	ldi	r17, 0x00	; 0
    4356:	11 23       	and	r17, r17
    4358:	09 f4       	brne	.+2      	; 0x435c <chb_write+0x15e>
    435a:	89 c0       	rjmp	.+274    	; 0x446e <chb_write+0x270>
	{
		_delay_ms(__us / 1000.0);
    435c:	6f 81       	ldd	r22, Y+7	; 0x07
    435e:	78 85       	ldd	r23, Y+8	; 0x08
    4360:	89 85       	ldd	r24, Y+9	; 0x09
    4362:	9a 85       	ldd	r25, Y+10	; 0x0a
    4364:	20 e0       	ldi	r18, 0x00	; 0
    4366:	30 e0       	ldi	r19, 0x00	; 0
    4368:	4a e7       	ldi	r20, 0x7A	; 122
    436a:	54 e4       	ldi	r21, 0x44	; 68
    436c:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    4370:	dc 01       	movw	r26, r24
    4372:	cb 01       	movw	r24, r22
    4374:	88 8b       	std	Y+16, r24	; 0x10
    4376:	99 8b       	std	Y+17, r25	; 0x11
    4378:	aa 8b       	std	Y+18, r26	; 0x12
    437a:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    437c:	68 89       	ldd	r22, Y+16	; 0x10
    437e:	79 89       	ldd	r23, Y+17	; 0x11
    4380:	8a 89       	ldd	r24, Y+18	; 0x12
    4382:	9b 89       	ldd	r25, Y+19	; 0x13
    4384:	20 e0       	ldi	r18, 0x00	; 0
    4386:	30 e0       	ldi	r19, 0x00	; 0
    4388:	4a e7       	ldi	r20, 0x7A	; 122
    438a:	53 e4       	ldi	r21, 0x43	; 67
    438c:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    4390:	dc 01       	movw	r26, r24
    4392:	cb 01       	movw	r24, r22
    4394:	8c 8b       	std	Y+20, r24	; 0x14
    4396:	9d 8b       	std	Y+21, r25	; 0x15
    4398:	ae 8b       	std	Y+22, r26	; 0x16
    439a:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    439c:	11 e0       	ldi	r17, 0x01	; 1
    439e:	6c 89       	ldd	r22, Y+20	; 0x14
    43a0:	7d 89       	ldd	r23, Y+21	; 0x15
    43a2:	8e 89       	ldd	r24, Y+22	; 0x16
    43a4:	9f 89       	ldd	r25, Y+23	; 0x17
    43a6:	20 e0       	ldi	r18, 0x00	; 0
    43a8:	30 e0       	ldi	r19, 0x00	; 0
    43aa:	40 e8       	ldi	r20, 0x80	; 128
    43ac:	5f e3       	ldi	r21, 0x3F	; 63
    43ae:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    43b2:	88 23       	and	r24, r24
    43b4:	0c f0       	brlt	.+2      	; 0x43b8 <chb_write+0x1ba>
    43b6:	10 e0       	ldi	r17, 0x00	; 0
    43b8:	11 23       	and	r17, r17
    43ba:	29 f0       	breq	.+10     	; 0x43c6 <chb_write+0x1c8>
		__ticks = 1;
    43bc:	81 e0       	ldi	r24, 0x01	; 1
    43be:	90 e0       	ldi	r25, 0x00	; 0
    43c0:	88 8f       	std	Y+24, r24	; 0x18
    43c2:	99 8f       	std	Y+25, r25	; 0x19
    43c4:	46 c0       	rjmp	.+140    	; 0x4452 <chb_write+0x254>
	else if (__tmp > 65535)
    43c6:	11 e0       	ldi	r17, 0x01	; 1
    43c8:	6c 89       	ldd	r22, Y+20	; 0x14
    43ca:	7d 89       	ldd	r23, Y+21	; 0x15
    43cc:	8e 89       	ldd	r24, Y+22	; 0x16
    43ce:	9f 89       	ldd	r25, Y+23	; 0x17
    43d0:	20 e0       	ldi	r18, 0x00	; 0
    43d2:	3f ef       	ldi	r19, 0xFF	; 255
    43d4:	4f e7       	ldi	r20, 0x7F	; 127
    43d6:	57 e4       	ldi	r21, 0x47	; 71
    43d8:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    43dc:	18 16       	cp	r1, r24
    43de:	0c f0       	brlt	.+2      	; 0x43e2 <chb_write+0x1e4>
    43e0:	10 e0       	ldi	r17, 0x00	; 0
    43e2:	11 23       	and	r17, r17
    43e4:	61 f1       	breq	.+88     	; 0x443e <chb_write+0x240>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    43e6:	68 89       	ldd	r22, Y+16	; 0x10
    43e8:	79 89       	ldd	r23, Y+17	; 0x11
    43ea:	8a 89       	ldd	r24, Y+18	; 0x12
    43ec:	9b 89       	ldd	r25, Y+19	; 0x13
    43ee:	20 e0       	ldi	r18, 0x00	; 0
    43f0:	30 e0       	ldi	r19, 0x00	; 0
    43f2:	40 e2       	ldi	r20, 0x20	; 32
    43f4:	51 e4       	ldi	r21, 0x41	; 65
    43f6:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    43fa:	dc 01       	movw	r26, r24
    43fc:	cb 01       	movw	r24, r22
    43fe:	bc 01       	movw	r22, r24
    4400:	cd 01       	movw	r24, r26
    4402:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    4406:	dc 01       	movw	r26, r24
    4408:	cb 01       	movw	r24, r22
    440a:	88 8f       	std	Y+24, r24	; 0x18
    440c:	99 8f       	std	Y+25, r25	; 0x19
    440e:	12 c0       	rjmp	.+36     	; 0x4434 <chb_write+0x236>
    4410:	89 e1       	ldi	r24, 0x19	; 25
    4412:	90 e0       	ldi	r25, 0x00	; 0
    4414:	8a 8f       	std	Y+26, r24	; 0x1a
    4416:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4418:	8a 8d       	ldd	r24, Y+26	; 0x1a
    441a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    441c:	8c 01       	movw	r16, r24
    441e:	c8 01       	movw	r24, r16
    4420:	01 97       	sbiw	r24, 0x01	; 1
    4422:	f1 f7       	brne	.-4      	; 0x4420 <chb_write+0x222>
    4424:	8c 01       	movw	r16, r24
    4426:	0a 8f       	std	Y+26, r16	; 0x1a
    4428:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    442a:	88 8d       	ldd	r24, Y+24	; 0x18
    442c:	99 8d       	ldd	r25, Y+25	; 0x19
    442e:	01 97       	sbiw	r24, 0x01	; 1
    4430:	88 8f       	std	Y+24, r24	; 0x18
    4432:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4434:	88 8d       	ldd	r24, Y+24	; 0x18
    4436:	99 8d       	ldd	r25, Y+25	; 0x19
    4438:	00 97       	sbiw	r24, 0x00	; 0
    443a:	51 f7       	brne	.-44     	; 0x4410 <chb_write+0x212>
    443c:	28 c0       	rjmp	.+80     	; 0x448e <chb_write+0x290>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    443e:	6c 89       	ldd	r22, Y+20	; 0x14
    4440:	7d 89       	ldd	r23, Y+21	; 0x15
    4442:	8e 89       	ldd	r24, Y+22	; 0x16
    4444:	9f 89       	ldd	r25, Y+23	; 0x17
    4446:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    444a:	dc 01       	movw	r26, r24
    444c:	cb 01       	movw	r24, r22
    444e:	88 8f       	std	Y+24, r24	; 0x18
    4450:	99 8f       	std	Y+25, r25	; 0x19
    4452:	88 8d       	ldd	r24, Y+24	; 0x18
    4454:	99 8d       	ldd	r25, Y+25	; 0x19
    4456:	8c 8f       	std	Y+28, r24	; 0x1c
    4458:	9d 8f       	std	Y+29, r25	; 0x1d
    445a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    445c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    445e:	8c 01       	movw	r16, r24
    4460:	c8 01       	movw	r24, r16
    4462:	01 97       	sbiw	r24, 0x01	; 1
    4464:	f1 f7       	brne	.-4      	; 0x4462 <chb_write+0x264>
    4466:	8c 01       	movw	r16, r24
    4468:	0c 8f       	std	Y+28, r16	; 0x1c
    446a:	1d 8f       	std	Y+29, r17	; 0x1d
    446c:	10 c0       	rjmp	.+32     	; 0x448e <chb_write+0x290>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    446e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4470:	7c 85       	ldd	r23, Y+12	; 0x0c
    4472:	8d 85       	ldd	r24, Y+13	; 0x0d
    4474:	9e 85       	ldd	r25, Y+14	; 0x0e
    4476:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    447a:	dc 01       	movw	r26, r24
    447c:	cb 01       	movw	r24, r22
    447e:	8f 87       	std	Y+15, r24	; 0x0f
    4480:	8f 85       	ldd	r24, Y+15	; 0x0f
    4482:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4484:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4486:	18 2f       	mov	r17, r24
    4488:	1a 95       	dec	r17
    448a:	f1 f7       	brne	.-4      	; 0x4488 <chb_write+0x28a>
    448c:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message
    448e:	8a 81       	ldd	r24, Y+2	; 0x02
    4490:	9b 81       	ldd	r25, Y+3	; 0x03
    4492:	84 31       	cpi	r24, 0x14	; 20
    4494:	91 05       	cpc	r25, r1
    4496:	11 f4       	brne	.+4      	; 0x449c <chb_write+0x29e>
    4498:	8e 81       	ldd	r24, Y+6	; 0x06
    449a:	2c c0       	rjmp	.+88     	; 0x44f4 <chb_write+0x2f6>
			rtry++;	
    449c:	8a 81       	ldd	r24, Y+2	; 0x02
    449e:	9b 81       	ldd	r25, Y+3	; 0x03
    44a0:	01 96       	adiw	r24, 0x01	; 1
    44a2:	8a 83       	std	Y+2, r24	; 0x02
    44a4:	9b 83       	std	Y+3, r25	; 0x03
		} while(status != CHB_SUCCESS);			
    44a6:	8e 81       	ldd	r24, Y+6	; 0x06
    44a8:	88 23       	and	r24, r24
    44aa:	09 f0       	breq	.+2      	; 0x44ae <chb_write+0x2b0>
    44ac:	d6 ce       	rjmp	.-596    	; 0x425a <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    44ae:	99 81       	ldd	r25, Y+1	; 0x01
    44b0:	8c 81       	ldd	r24, Y+4	; 0x04
    44b2:	89 0f       	add	r24, r25
    44b4:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    44b6:	8c 81       	ldd	r24, Y+4	; 0x04
    44b8:	88 2f       	mov	r24, r24
    44ba:	90 e0       	ldi	r25, 0x00	; 0
    44bc:	a0 e0       	ldi	r26, 0x00	; 0
    44be:	b0 e0       	ldi	r27, 0x00	; 0
    44c0:	2d a5       	lds	r18, 0x6d
    44c2:	3e a5       	lds	r19, 0x6e
    44c4:	4f a5       	lds	r20, 0x6f
    44c6:	58 a9       	sts	0x48, r21
    44c8:	79 01       	movw	r14, r18
    44ca:	8a 01       	movw	r16, r20
    44cc:	e8 1a       	sub	r14, r24
    44ce:	f9 0a       	sbc	r15, r25
    44d0:	0a 0b       	sbc	r16, r26
    44d2:	1b 0b       	sbc	r17, r27
    44d4:	d8 01       	movw	r26, r16
    44d6:	c7 01       	movw	r24, r14
    44d8:	8d a7       	lds	r24, 0x7d
    44da:	9e a7       	lds	r25, 0x7e
    44dc:	af a7       	lds	r26, 0x7f
    44de:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    44e0:	8d a5       	lds	r24, 0x6d
    44e2:	9e a5       	lds	r25, 0x6e
    44e4:	af a5       	lds	r26, 0x6f
    44e6:	b8 a9       	sts	0x48, r27
    44e8:	00 97       	sbiw	r24, 0x00	; 0
    44ea:	a1 05       	cpc	r26, r1
    44ec:	b1 05       	cpc	r27, r1
    44ee:	09 f0       	breq	.+2      	; 0x44f2 <chb_write+0x2f4>
    44f0:	9b ce       	rjmp	.-714    	; 0x4228 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    44f2:	80 e0       	ldi	r24, 0x00	; 0
}
    44f4:	e0 96       	adiw	r28, 0x30	; 48
    44f6:	cd bf       	out	0x3d, r28	; 61
    44f8:	de bf       	out	0x3e, r29	; 62
    44fa:	df 91       	pop	r29
    44fc:	cf 91       	pop	r28
    44fe:	1f 91       	pop	r17
    4500:	0f 91       	pop	r16
    4502:	ff 90       	pop	r15
    4504:	ef 90       	pop	r14
    4506:	08 95       	ret

00004508 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4508:	cf 93       	push	r28
    450a:	df 93       	push	r29
    450c:	cd b7       	in	r28, 0x3d	; 61
    450e:	de b7       	in	r29, 0x3e	; 62
    4510:	27 97       	sbiw	r28, 0x07	; 7
    4512:	cd bf       	out	0x3d, r28	; 61
    4514:	de bf       	out	0x3e, r29	; 62
    4516:	8e 83       	std	Y+6, r24	; 0x06
    4518:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    451a:	8e 81       	ldd	r24, Y+6	; 0x06
    451c:	9f 81       	ldd	r25, Y+7	; 0x07
    451e:	05 96       	adiw	r24, 0x05	; 5
    4520:	8a 83       	std	Y+2, r24	; 0x02
    4522:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    4524:	0e 94 51 23 	call	0x46a2	; 0x46a2 <chb_buf_read>
    4528:	8c 83       	std	Y+4, r24	; 0x04
    452a:	8c 81       	ldd	r24, Y+4	; 0x04
    452c:	88 23       	and	r24, r24
    452e:	14 f4       	brge	.+4      	; 0x4534 <chb_read+0x2c>
    {
        return 0;
    4530:	80 e0       	ldi	r24, 0x00	; 0
    4532:	80 c0       	rjmp	.+256    	; 0x4634 <chb_read+0x12c>
    }
    *data_ptr++ = len;
    4534:	8a 81       	ldd	r24, Y+2	; 0x02
    4536:	9b 81       	ldd	r25, Y+3	; 0x03
    4538:	2c 81       	ldd	r18, Y+4	; 0x04
    453a:	fc 01       	movw	r30, r24
    453c:	20 83       	st	Z, r18
    453e:	8a 81       	ldd	r24, Y+2	; 0x02
    4540:	9b 81       	ldd	r25, Y+3	; 0x03
    4542:	01 96       	adiw	r24, 0x01	; 1
    4544:	8a 83       	std	Y+2, r24	; 0x02
    4546:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4548:	19 82       	std	Y+1, r1	; 0x01
    454a:	0f c0       	rjmp	.+30     	; 0x456a <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    454c:	0e 94 51 23 	call	0x46a2	; 0x46a2 <chb_buf_read>
    4550:	28 2f       	mov	r18, r24
    4552:	8a 81       	ldd	r24, Y+2	; 0x02
    4554:	9b 81       	ldd	r25, Y+3	; 0x03
    4556:	fc 01       	movw	r30, r24
    4558:	20 83       	st	Z, r18
    455a:	8a 81       	ldd	r24, Y+2	; 0x02
    455c:	9b 81       	ldd	r25, Y+3	; 0x03
    455e:	01 96       	adiw	r24, 0x01	; 1
    4560:	8a 83       	std	Y+2, r24	; 0x02
    4562:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4564:	89 81       	ldd	r24, Y+1	; 0x01
    4566:	8f 5f       	subi	r24, 0xFF	; 255
    4568:	89 83       	std	Y+1, r24	; 0x01
    456a:	99 81       	ldd	r25, Y+1	; 0x01
    456c:	8c 81       	ldd	r24, Y+4	; 0x04
    456e:	98 17       	cp	r25, r24
    4570:	68 f3       	brcs	.-38     	; 0x454c <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    4572:	8e 81       	ldd	r24, Y+6	; 0x06
    4574:	9f 81       	ldd	r25, Y+7	; 0x07
    4576:	08 96       	adiw	r24, 0x08	; 8
    4578:	8a 83       	std	Y+2, r24	; 0x02
    457a:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    457c:	8a 81       	ldd	r24, Y+2	; 0x02
    457e:	9b 81       	ldd	r25, Y+3	; 0x03
    4580:	fc 01       	movw	r30, r24
    4582:	80 81       	ld	r24, Z
    4584:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    4586:	8e 81       	ldd	r24, Y+6	; 0x06
    4588:	9f 81       	ldd	r25, Y+7	; 0x07
    458a:	0b 96       	adiw	r24, 0x0b	; 11
    458c:	8a 83       	std	Y+2, r24	; 0x02
    458e:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    4590:	8a 81       	ldd	r24, Y+2	; 0x02
    4592:	9b 81       	ldd	r25, Y+3	; 0x03
    4594:	fc 01       	movw	r30, r24
    4596:	20 81       	ld	r18, Z
    4598:	31 81       	ldd	r19, Z+1	; 0x01
    459a:	8e 81       	ldd	r24, Y+6	; 0x06
    459c:	9f 81       	ldd	r25, Y+7	; 0x07
    459e:	fc 01       	movw	r30, r24
    45a0:	23 83       	std	Z+3, r18	; 0x03
    45a2:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    45a4:	8a 81       	ldd	r24, Y+2	; 0x02
    45a6:	9b 81       	ldd	r25, Y+3	; 0x03
    45a8:	02 96       	adiw	r24, 0x02	; 2
    45aa:	8a 83       	std	Y+2, r24	; 0x02
    45ac:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    45ae:	8a 81       	ldd	r24, Y+2	; 0x02
    45b0:	9b 81       	ldd	r25, Y+3	; 0x03
    45b2:	fc 01       	movw	r30, r24
    45b4:	20 81       	ld	r18, Z
    45b6:	31 81       	ldd	r19, Z+1	; 0x01
    45b8:	8e 81       	ldd	r24, Y+6	; 0x06
    45ba:	9f 81       	ldd	r25, Y+7	; 0x07
    45bc:	fc 01       	movw	r30, r24
    45be:	21 83       	std	Z+1, r18	; 0x01
    45c0:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    45c2:	8a 81       	ldd	r24, Y+2	; 0x02
    45c4:	9b 81       	ldd	r25, Y+3	; 0x03
    45c6:	02 96       	adiw	r24, 0x02	; 2
    45c8:	8a 83       	std	Y+2, r24	; 0x02
    45ca:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    45cc:	0e 94 75 23 	call	0x46ea	; 0x46ea <chb_buf_get_len>
    45d0:	88 23       	and	r24, r24
    45d2:	11 f4       	brne	.+4      	; 0x45d8 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    45d4:	10 92 43 21 	sts	0x2143, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    45d8:	80 91 1a 20 	lds	r24, 0x201A
    45dc:	9d 81       	ldd	r25, Y+5	; 0x05
    45de:	98 17       	cp	r25, r24
    45e0:	71 f4       	brne	.+28     	; 0x45fe <chb_read+0xf6>
    45e2:	8e 81       	ldd	r24, Y+6	; 0x06
    45e4:	9f 81       	ldd	r25, Y+7	; 0x07
    45e6:	fc 01       	movw	r30, r24
    45e8:	21 81       	ldd	r18, Z+1	; 0x01
    45ea:	32 81       	ldd	r19, Z+2	; 0x02
    45ec:	80 91 1b 20 	lds	r24, 0x201B
    45f0:	90 91 1c 20 	lds	r25, 0x201C
    45f4:	28 17       	cp	r18, r24
    45f6:	39 07       	cpc	r19, r25
    45f8:	11 f4       	brne	.+4      	; 0x45fe <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    45fa:	80 e0       	ldi	r24, 0x00	; 0
    45fc:	1b c0       	rjmp	.+54     	; 0x4634 <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    45fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4600:	80 93 1a 20 	sts	0x201A, r24
        prev_src_addr = rx->src_addr;
    4604:	8e 81       	ldd	r24, Y+6	; 0x06
    4606:	9f 81       	ldd	r25, Y+7	; 0x07
    4608:	fc 01       	movw	r30, r24
    460a:	81 81       	ldd	r24, Z+1	; 0x01
    460c:	92 81       	ldd	r25, Z+2	; 0x02
    460e:	80 93 1b 20 	sts	0x201B, r24
    4612:	90 93 1c 20 	sts	0x201C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    4616:	8c 81       	ldd	r24, Y+4	; 0x04
    4618:	88 2f       	mov	r24, r24
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	09 97       	sbiw	r24, 0x09	; 9
    461e:	9c 01       	movw	r18, r24
    4620:	8e 81       	ldd	r24, Y+6	; 0x06
    4622:	9f 81       	ldd	r25, Y+7	; 0x07
    4624:	4a 81       	ldd	r20, Y+2	; 0x02
    4626:	5b 81       	ldd	r21, Y+3	; 0x03
    4628:	ba 01       	movw	r22, r20
    462a:	a9 01       	movw	r20, r18
    462c:	0e 94 36 5f 	call	0xbe6c	; 0xbe6c <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    4630:	8c 81       	ldd	r24, Y+4	; 0x04
    4632:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    4634:	27 96       	adiw	r28, 0x07	; 7
    4636:	cd bf       	out	0x3d, r28	; 61
    4638:	de bf       	out	0x3e, r29	; 62
    463a:	df 91       	pop	r29
    463c:	cf 91       	pop	r28
    463e:	08 95       	ret

00004640 <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    4640:	cf 93       	push	r28
    4642:	df 93       	push	r29
    4644:	cd b7       	in	r28, 0x3d	; 61
    4646:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4648:	10 92 d4 21 	sts	0x21D4, r1
    wr_ptr = 0;
    464c:	10 92 d5 21 	sts	0x21D5, r1
    len = 0;
    4650:	10 92 d6 21 	sts	0x21D6, r1
}
    4654:	df 91       	pop	r29
    4656:	cf 91       	pop	r28
    4658:	08 95       	ret

0000465a <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    465a:	cf 93       	push	r28
    465c:	df 93       	push	r29
    465e:	0f 92       	push	r0
    4660:	cd b7       	in	r28, 0x3d	; 61
    4662:	de b7       	in	r29, 0x3e	; 62
    4664:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4666:	80 91 d5 21 	lds	r24, 0x21D5
    466a:	88 2f       	mov	r24, r24
    466c:	90 e0       	ldi	r25, 0x00	; 0
    466e:	8c 5a       	subi	r24, 0xAC	; 172
    4670:	9e 4d       	sbci	r25, 0xDE	; 222
    4672:	29 81       	ldd	r18, Y+1	; 0x01
    4674:	fc 01       	movw	r30, r24
    4676:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4678:	80 91 d5 21 	lds	r24, 0x21D5
    467c:	88 2f       	mov	r24, r24
    467e:	90 e0       	ldi	r25, 0x00	; 0
    4680:	01 96       	adiw	r24, 0x01	; 1
    4682:	20 e8       	ldi	r18, 0x80	; 128
    4684:	30 e0       	ldi	r19, 0x00	; 0
    4686:	b9 01       	movw	r22, r18
    4688:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    468c:	80 93 d5 21 	sts	0x21D5, r24
    len++;
    4690:	80 91 d6 21 	lds	r24, 0x21D6
    4694:	8f 5f       	subi	r24, 0xFF	; 255
    4696:	80 93 d6 21 	sts	0x21D6, r24
}
    469a:	0f 90       	pop	r0
    469c:	df 91       	pop	r29
    469e:	cf 91       	pop	r28
    46a0:	08 95       	ret

000046a2 <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    46a2:	cf 93       	push	r28
    46a4:	df 93       	push	r29
    46a6:	0f 92       	push	r0
    46a8:	cd b7       	in	r28, 0x3d	; 61
    46aa:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    46ac:	80 91 d4 21 	lds	r24, 0x21D4
    46b0:	88 2f       	mov	r24, r24
    46b2:	90 e0       	ldi	r25, 0x00	; 0
    46b4:	8c 5a       	subi	r24, 0xAC	; 172
    46b6:	9e 4d       	sbci	r25, 0xDE	; 222
    46b8:	fc 01       	movw	r30, r24
    46ba:	80 81       	ld	r24, Z
    46bc:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    46be:	80 91 d4 21 	lds	r24, 0x21D4
    46c2:	88 2f       	mov	r24, r24
    46c4:	90 e0       	ldi	r25, 0x00	; 0
    46c6:	01 96       	adiw	r24, 0x01	; 1
    46c8:	20 e8       	ldi	r18, 0x80	; 128
    46ca:	30 e0       	ldi	r19, 0x00	; 0
    46cc:	b9 01       	movw	r22, r18
    46ce:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    46d2:	80 93 d4 21 	sts	0x21D4, r24
    len--;
    46d6:	80 91 d6 21 	lds	r24, 0x21D6
    46da:	81 50       	subi	r24, 0x01	; 1
    46dc:	80 93 d6 21 	sts	0x21D6, r24
    return data;
    46e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    46e2:	0f 90       	pop	r0
    46e4:	df 91       	pop	r29
    46e6:	cf 91       	pop	r28
    46e8:	08 95       	ret

000046ea <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    46ea:	cf 93       	push	r28
    46ec:	df 93       	push	r29
    46ee:	cd b7       	in	r28, 0x3d	; 61
    46f0:	de b7       	in	r29, 0x3e	; 62
    return len;
    46f2:	80 91 d6 21 	lds	r24, 0x21D6
}
    46f6:	df 91       	pop	r29
    46f8:	cf 91       	pop	r28
    46fa:	08 95       	ret

000046fc <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    46fc:	cf 93       	push	r28
    46fe:	df 93       	push	r29
    4700:	cd b7       	in	r28, 0x3d	; 61
    4702:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    4704:	81 e0       	ldi	r24, 0x01	; 1
    4706:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    470a:	8f 71       	andi	r24, 0x1F	; 31
}
    470c:	df 91       	pop	r29
    470e:	cf 91       	pop	r28
    4710:	08 95       	ret

00004712 <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    4712:	cf 93       	push	r28
    4714:	df 93       	push	r29
    4716:	cd b7       	in	r28, 0x3d	; 61
    4718:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    471a:	82 e0       	ldi	r24, 0x02	; 2
    471c:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    4720:	82 95       	swap	r24
    4722:	86 95       	lsr	r24
    4724:	87 70       	andi	r24, 0x07	; 7
}
    4726:	df 91       	pop	r29
    4728:	cf 91       	pop	r28
    472a:	08 95       	ret

0000472c <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    472c:	0f 93       	push	r16
    472e:	1f 93       	push	r17
    4730:	cf 93       	push	r28
    4732:	df 93       	push	r29
    4734:	cd b7       	in	r28, 0x3d	; 61
    4736:	de b7       	in	r29, 0x3e	; 62
    4738:	e0 97       	sbiw	r28, 0x30	; 48
    473a:	cd bf       	out	0x3d, r28	; 61
    473c:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    473e:	84 e6       	ldi	r24, 0x64	; 100
    4740:	96 e0       	ldi	r25, 0x06	; 6
    4742:	24 e6       	ldi	r18, 0x64	; 100
    4744:	36 e0       	ldi	r19, 0x06	; 6
    4746:	f9 01       	movw	r30, r18
    4748:	20 81       	ld	r18, Z
    474a:	21 60       	ori	r18, 0x01	; 1
    474c:	fc 01       	movw	r30, r24
    474e:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    4750:	84 e6       	ldi	r24, 0x64	; 100
    4752:	96 e0       	ldi	r25, 0x06	; 6
    4754:	24 e6       	ldi	r18, 0x64	; 100
    4756:	36 e0       	ldi	r19, 0x06	; 6
    4758:	f9 01       	movw	r30, r18
    475a:	20 81       	ld	r18, Z
    475c:	2d 7f       	andi	r18, 0xFD	; 253
    475e:	fc 01       	movw	r30, r24
    4760:	20 83       	st	Z, r18
    4762:	80 e0       	ldi	r24, 0x00	; 0
    4764:	90 e0       	ldi	r25, 0x00	; 0
    4766:	ae eb       	ldi	r26, 0xBE	; 190
    4768:	b3 e4       	ldi	r27, 0x43	; 67
    476a:	89 83       	std	Y+1, r24	; 0x01
    476c:	9a 83       	std	Y+2, r25	; 0x02
    476e:	ab 83       	std	Y+3, r26	; 0x03
    4770:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4772:	69 81       	ldd	r22, Y+1	; 0x01
    4774:	7a 81       	ldd	r23, Y+2	; 0x02
    4776:	8b 81       	ldd	r24, Y+3	; 0x03
    4778:	9c 81       	ldd	r25, Y+4	; 0x04
    477a:	2b ea       	ldi	r18, 0xAB	; 171
    477c:	3a ea       	ldi	r19, 0xAA	; 170
    477e:	4a ea       	ldi	r20, 0xAA	; 170
    4780:	5e e3       	ldi	r21, 0x3E	; 62
    4782:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    4786:	dc 01       	movw	r26, r24
    4788:	cb 01       	movw	r24, r22
    478a:	8d 83       	std	Y+5, r24	; 0x05
    478c:	9e 83       	std	Y+6, r25	; 0x06
    478e:	af 83       	std	Y+7, r26	; 0x07
    4790:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    4792:	11 e0       	ldi	r17, 0x01	; 1
    4794:	6d 81       	ldd	r22, Y+5	; 0x05
    4796:	7e 81       	ldd	r23, Y+6	; 0x06
    4798:	8f 81       	ldd	r24, Y+7	; 0x07
    479a:	98 85       	ldd	r25, Y+8	; 0x08
    479c:	20 e0       	ldi	r18, 0x00	; 0
    479e:	30 e0       	ldi	r19, 0x00	; 0
    47a0:	40 e8       	ldi	r20, 0x80	; 128
    47a2:	5f e3       	ldi	r21, 0x3F	; 63
    47a4:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    47a8:	88 23       	and	r24, r24
    47aa:	0c f0       	brlt	.+2      	; 0x47ae <chb_reset+0x82>
    47ac:	10 e0       	ldi	r17, 0x00	; 0
    47ae:	11 23       	and	r17, r17
    47b0:	19 f0       	breq	.+6      	; 0x47b8 <chb_reset+0x8c>
		__ticks = 1;
    47b2:	81 e0       	ldi	r24, 0x01	; 1
    47b4:	89 87       	std	Y+9, r24	; 0x09
    47b6:	a3 c0       	rjmp	.+326    	; 0x48fe <chb_reset+0x1d2>
	else if (__tmp > 255)
    47b8:	11 e0       	ldi	r17, 0x01	; 1
    47ba:	6d 81       	ldd	r22, Y+5	; 0x05
    47bc:	7e 81       	ldd	r23, Y+6	; 0x06
    47be:	8f 81       	ldd	r24, Y+7	; 0x07
    47c0:	98 85       	ldd	r25, Y+8	; 0x08
    47c2:	20 e0       	ldi	r18, 0x00	; 0
    47c4:	30 e0       	ldi	r19, 0x00	; 0
    47c6:	4f e7       	ldi	r20, 0x7F	; 127
    47c8:	53 e4       	ldi	r21, 0x43	; 67
    47ca:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    47ce:	18 16       	cp	r1, r24
    47d0:	0c f0       	brlt	.+2      	; 0x47d4 <chb_reset+0xa8>
    47d2:	10 e0       	ldi	r17, 0x00	; 0
    47d4:	11 23       	and	r17, r17
    47d6:	09 f4       	brne	.+2      	; 0x47da <chb_reset+0xae>
    47d8:	89 c0       	rjmp	.+274    	; 0x48ec <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    47da:	69 81       	ldd	r22, Y+1	; 0x01
    47dc:	7a 81       	ldd	r23, Y+2	; 0x02
    47de:	8b 81       	ldd	r24, Y+3	; 0x03
    47e0:	9c 81       	ldd	r25, Y+4	; 0x04
    47e2:	20 e0       	ldi	r18, 0x00	; 0
    47e4:	30 e0       	ldi	r19, 0x00	; 0
    47e6:	4a e7       	ldi	r20, 0x7A	; 122
    47e8:	54 e4       	ldi	r21, 0x44	; 68
    47ea:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    47ee:	dc 01       	movw	r26, r24
    47f0:	cb 01       	movw	r24, r22
    47f2:	8a 87       	std	Y+10, r24	; 0x0a
    47f4:	9b 87       	std	Y+11, r25	; 0x0b
    47f6:	ac 87       	std	Y+12, r26	; 0x0c
    47f8:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    47fa:	6a 85       	ldd	r22, Y+10	; 0x0a
    47fc:	7b 85       	ldd	r23, Y+11	; 0x0b
    47fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    4800:	9d 85       	ldd	r25, Y+13	; 0x0d
    4802:	20 e0       	ldi	r18, 0x00	; 0
    4804:	30 e0       	ldi	r19, 0x00	; 0
    4806:	4a e7       	ldi	r20, 0x7A	; 122
    4808:	53 e4       	ldi	r21, 0x43	; 67
    480a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    480e:	dc 01       	movw	r26, r24
    4810:	cb 01       	movw	r24, r22
    4812:	8e 87       	std	Y+14, r24	; 0x0e
    4814:	9f 87       	std	Y+15, r25	; 0x0f
    4816:	a8 8b       	std	Y+16, r26	; 0x10
    4818:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    481a:	11 e0       	ldi	r17, 0x01	; 1
    481c:	6e 85       	ldd	r22, Y+14	; 0x0e
    481e:	7f 85       	ldd	r23, Y+15	; 0x0f
    4820:	88 89       	ldd	r24, Y+16	; 0x10
    4822:	99 89       	ldd	r25, Y+17	; 0x11
    4824:	20 e0       	ldi	r18, 0x00	; 0
    4826:	30 e0       	ldi	r19, 0x00	; 0
    4828:	40 e8       	ldi	r20, 0x80	; 128
    482a:	5f e3       	ldi	r21, 0x3F	; 63
    482c:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    4830:	88 23       	and	r24, r24
    4832:	0c f0       	brlt	.+2      	; 0x4836 <chb_reset+0x10a>
    4834:	10 e0       	ldi	r17, 0x00	; 0
    4836:	11 23       	and	r17, r17
    4838:	29 f0       	breq	.+10     	; 0x4844 <chb_reset+0x118>
		__ticks = 1;
    483a:	81 e0       	ldi	r24, 0x01	; 1
    483c:	90 e0       	ldi	r25, 0x00	; 0
    483e:	8a 8b       	std	Y+18, r24	; 0x12
    4840:	9b 8b       	std	Y+19, r25	; 0x13
    4842:	46 c0       	rjmp	.+140    	; 0x48d0 <chb_reset+0x1a4>
	else if (__tmp > 65535)
    4844:	11 e0       	ldi	r17, 0x01	; 1
    4846:	6e 85       	ldd	r22, Y+14	; 0x0e
    4848:	7f 85       	ldd	r23, Y+15	; 0x0f
    484a:	88 89       	ldd	r24, Y+16	; 0x10
    484c:	99 89       	ldd	r25, Y+17	; 0x11
    484e:	20 e0       	ldi	r18, 0x00	; 0
    4850:	3f ef       	ldi	r19, 0xFF	; 255
    4852:	4f e7       	ldi	r20, 0x7F	; 127
    4854:	57 e4       	ldi	r21, 0x47	; 71
    4856:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    485a:	18 16       	cp	r1, r24
    485c:	0c f0       	brlt	.+2      	; 0x4860 <chb_reset+0x134>
    485e:	10 e0       	ldi	r17, 0x00	; 0
    4860:	11 23       	and	r17, r17
    4862:	61 f1       	breq	.+88     	; 0x48bc <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4864:	6a 85       	ldd	r22, Y+10	; 0x0a
    4866:	7b 85       	ldd	r23, Y+11	; 0x0b
    4868:	8c 85       	ldd	r24, Y+12	; 0x0c
    486a:	9d 85       	ldd	r25, Y+13	; 0x0d
    486c:	20 e0       	ldi	r18, 0x00	; 0
    486e:	30 e0       	ldi	r19, 0x00	; 0
    4870:	40 e2       	ldi	r20, 0x20	; 32
    4872:	51 e4       	ldi	r21, 0x41	; 65
    4874:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    4878:	dc 01       	movw	r26, r24
    487a:	cb 01       	movw	r24, r22
    487c:	bc 01       	movw	r22, r24
    487e:	cd 01       	movw	r24, r26
    4880:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    4884:	dc 01       	movw	r26, r24
    4886:	cb 01       	movw	r24, r22
    4888:	8a 8b       	std	Y+18, r24	; 0x12
    488a:	9b 8b       	std	Y+19, r25	; 0x13
    488c:	12 c0       	rjmp	.+36     	; 0x48b2 <chb_reset+0x186>
    488e:	89 e1       	ldi	r24, 0x19	; 25
    4890:	90 e0       	ldi	r25, 0x00	; 0
    4892:	8c 8b       	std	Y+20, r24	; 0x14
    4894:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4896:	8c 89       	ldd	r24, Y+20	; 0x14
    4898:	9d 89       	ldd	r25, Y+21	; 0x15
    489a:	8c 01       	movw	r16, r24
    489c:	c8 01       	movw	r24, r16
    489e:	01 97       	sbiw	r24, 0x01	; 1
    48a0:	f1 f7       	brne	.-4      	; 0x489e <chb_reset+0x172>
    48a2:	8c 01       	movw	r16, r24
    48a4:	0c 8b       	std	Y+20, r16	; 0x14
    48a6:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    48a8:	8a 89       	ldd	r24, Y+18	; 0x12
    48aa:	9b 89       	ldd	r25, Y+19	; 0x13
    48ac:	01 97       	sbiw	r24, 0x01	; 1
    48ae:	8a 8b       	std	Y+18, r24	; 0x12
    48b0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    48b2:	8a 89       	ldd	r24, Y+18	; 0x12
    48b4:	9b 89       	ldd	r25, Y+19	; 0x13
    48b6:	00 97       	sbiw	r24, 0x00	; 0
    48b8:	51 f7       	brne	.-44     	; 0x488e <chb_reset+0x162>
    48ba:	28 c0       	rjmp	.+80     	; 0x490c <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    48bc:	6e 85       	ldd	r22, Y+14	; 0x0e
    48be:	7f 85       	ldd	r23, Y+15	; 0x0f
    48c0:	88 89       	ldd	r24, Y+16	; 0x10
    48c2:	99 89       	ldd	r25, Y+17	; 0x11
    48c4:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    48c8:	dc 01       	movw	r26, r24
    48ca:	cb 01       	movw	r24, r22
    48cc:	8a 8b       	std	Y+18, r24	; 0x12
    48ce:	9b 8b       	std	Y+19, r25	; 0x13
    48d0:	8a 89       	ldd	r24, Y+18	; 0x12
    48d2:	9b 89       	ldd	r25, Y+19	; 0x13
    48d4:	8e 8b       	std	Y+22, r24	; 0x16
    48d6:	9f 8b       	std	Y+23, r25	; 0x17
    48d8:	8e 89       	ldd	r24, Y+22	; 0x16
    48da:	9f 89       	ldd	r25, Y+23	; 0x17
    48dc:	8c 01       	movw	r16, r24
    48de:	f8 01       	movw	r30, r16
    48e0:	31 97       	sbiw	r30, 0x01	; 1
    48e2:	f1 f7       	brne	.-4      	; 0x48e0 <chb_reset+0x1b4>
    48e4:	8f 01       	movw	r16, r30
    48e6:	0e 8b       	std	Y+22, r16	; 0x16
    48e8:	1f 8b       	std	Y+23, r17	; 0x17
    48ea:	10 c0       	rjmp	.+32     	; 0x490c <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    48ec:	6d 81       	ldd	r22, Y+5	; 0x05
    48ee:	7e 81       	ldd	r23, Y+6	; 0x06
    48f0:	8f 81       	ldd	r24, Y+7	; 0x07
    48f2:	98 85       	ldd	r25, Y+8	; 0x08
    48f4:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    48f8:	dc 01       	movw	r26, r24
    48fa:	cb 01       	movw	r24, r22
    48fc:	89 87       	std	Y+9, r24	; 0x09
    48fe:	89 85       	ldd	r24, Y+9	; 0x09
    4900:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4902:	88 8d       	ldd	r24, Y+24	; 0x18
    4904:	18 2f       	mov	r17, r24
    4906:	1a 95       	dec	r17
    4908:	f1 f7       	brne	.-4      	; 0x4906 <chb_reset+0x1da>
    490a:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    490c:	84 e6       	ldi	r24, 0x64	; 100
    490e:	96 e0       	ldi	r25, 0x06	; 6
    4910:	24 e6       	ldi	r18, 0x64	; 100
    4912:	36 e0       	ldi	r19, 0x06	; 6
    4914:	f9 01       	movw	r30, r18
    4916:	20 81       	ld	r18, Z
    4918:	2e 7f       	andi	r18, 0xFE	; 254
    491a:	fc 01       	movw	r30, r24
    491c:	20 83       	st	Z, r18
    491e:	80 e0       	ldi	r24, 0x00	; 0
    4920:	90 e0       	ldi	r25, 0x00	; 0
    4922:	a0 e8       	ldi	r26, 0x80	; 128
    4924:	bf e3       	ldi	r27, 0x3F	; 63
    4926:	89 8f       	std	Y+25, r24	; 0x19
    4928:	9a 8f       	std	Y+26, r25	; 0x1a
    492a:	ab 8f       	std	Y+27, r26	; 0x1b
    492c:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    492e:	69 8d       	ldd	r22, Y+25	; 0x19
    4930:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4932:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4934:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4936:	2b ea       	ldi	r18, 0xAB	; 171
    4938:	3a ea       	ldi	r19, 0xAA	; 170
    493a:	4a ea       	ldi	r20, 0xAA	; 170
    493c:	5e e3       	ldi	r21, 0x3E	; 62
    493e:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    4942:	dc 01       	movw	r26, r24
    4944:	cb 01       	movw	r24, r22
    4946:	8d 8f       	std	Y+29, r24	; 0x1d
    4948:	9e 8f       	std	Y+30, r25	; 0x1e
    494a:	af 8f       	std	Y+31, r26	; 0x1f
    494c:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    494e:	11 e0       	ldi	r17, 0x01	; 1
    4950:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4952:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4954:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4956:	98 a1       	lds	r25, 0x48
    4958:	20 e0       	ldi	r18, 0x00	; 0
    495a:	30 e0       	ldi	r19, 0x00	; 0
    495c:	40 e8       	ldi	r20, 0x80	; 128
    495e:	5f e3       	ldi	r21, 0x3F	; 63
    4960:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    4964:	88 23       	and	r24, r24
    4966:	0c f0       	brlt	.+2      	; 0x496a <chb_reset+0x23e>
    4968:	10 e0       	ldi	r17, 0x00	; 0
    496a:	11 23       	and	r17, r17
    496c:	19 f0       	breq	.+6      	; 0x4974 <chb_reset+0x248>
		__ticks = 1;
    496e:	81 e0       	ldi	r24, 0x01	; 1
    4970:	89 a3       	lds	r24, 0x59
    4972:	a3 c0       	rjmp	.+326    	; 0x4aba <chb_reset+0x38e>
	else if (__tmp > 255)
    4974:	11 e0       	ldi	r17, 0x01	; 1
    4976:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4978:	7e 8d       	ldd	r23, Y+30	; 0x1e
    497a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    497c:	98 a1       	lds	r25, 0x48
    497e:	20 e0       	ldi	r18, 0x00	; 0
    4980:	30 e0       	ldi	r19, 0x00	; 0
    4982:	4f e7       	ldi	r20, 0x7F	; 127
    4984:	53 e4       	ldi	r21, 0x43	; 67
    4986:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    498a:	18 16       	cp	r1, r24
    498c:	0c f0       	brlt	.+2      	; 0x4990 <chb_reset+0x264>
    498e:	10 e0       	ldi	r17, 0x00	; 0
    4990:	11 23       	and	r17, r17
    4992:	09 f4       	brne	.+2      	; 0x4996 <chb_reset+0x26a>
    4994:	89 c0       	rjmp	.+274    	; 0x4aa8 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    4996:	69 8d       	ldd	r22, Y+25	; 0x19
    4998:	7a 8d       	ldd	r23, Y+26	; 0x1a
    499a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    499c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    499e:	20 e0       	ldi	r18, 0x00	; 0
    49a0:	30 e0       	ldi	r19, 0x00	; 0
    49a2:	4a e7       	ldi	r20, 0x7A	; 122
    49a4:	54 e4       	ldi	r21, 0x44	; 68
    49a6:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    49aa:	dc 01       	movw	r26, r24
    49ac:	cb 01       	movw	r24, r22
    49ae:	8a a3       	lds	r24, 0x5a
    49b0:	9b a3       	lds	r25, 0x5b
    49b2:	ac a3       	lds	r26, 0x5c
    49b4:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    49b6:	6a a1       	lds	r22, 0x4a
    49b8:	7b a1       	lds	r23, 0x4b
    49ba:	8c a1       	lds	r24, 0x4c
    49bc:	9d a1       	lds	r25, 0x4d
    49be:	20 e0       	ldi	r18, 0x00	; 0
    49c0:	30 e0       	ldi	r19, 0x00	; 0
    49c2:	4a e7       	ldi	r20, 0x7A	; 122
    49c4:	53 e4       	ldi	r21, 0x43	; 67
    49c6:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    49ca:	dc 01       	movw	r26, r24
    49cc:	cb 01       	movw	r24, r22
    49ce:	8e a3       	lds	r24, 0x5e
    49d0:	9f a3       	lds	r25, 0x5f
    49d2:	a8 a7       	lds	r26, 0x78
    49d4:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    49d6:	11 e0       	ldi	r17, 0x01	; 1
    49d8:	6e a1       	lds	r22, 0x4e
    49da:	7f a1       	lds	r23, 0x4f
    49dc:	88 a5       	lds	r24, 0x68
    49de:	99 a5       	lds	r25, 0x69
    49e0:	20 e0       	ldi	r18, 0x00	; 0
    49e2:	30 e0       	ldi	r19, 0x00	; 0
    49e4:	40 e8       	ldi	r20, 0x80	; 128
    49e6:	5f e3       	ldi	r21, 0x3F	; 63
    49e8:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    49ec:	88 23       	and	r24, r24
    49ee:	0c f0       	brlt	.+2      	; 0x49f2 <chb_reset+0x2c6>
    49f0:	10 e0       	ldi	r17, 0x00	; 0
    49f2:	11 23       	and	r17, r17
    49f4:	29 f0       	breq	.+10     	; 0x4a00 <chb_reset+0x2d4>
		__ticks = 1;
    49f6:	81 e0       	ldi	r24, 0x01	; 1
    49f8:	90 e0       	ldi	r25, 0x00	; 0
    49fa:	8a a7       	lds	r24, 0x7a
    49fc:	9b a7       	lds	r25, 0x7b
    49fe:	46 c0       	rjmp	.+140    	; 0x4a8c <chb_reset+0x360>
	else if (__tmp > 65535)
    4a00:	11 e0       	ldi	r17, 0x01	; 1
    4a02:	6e a1       	lds	r22, 0x4e
    4a04:	7f a1       	lds	r23, 0x4f
    4a06:	88 a5       	lds	r24, 0x68
    4a08:	99 a5       	lds	r25, 0x69
    4a0a:	20 e0       	ldi	r18, 0x00	; 0
    4a0c:	3f ef       	ldi	r19, 0xFF	; 255
    4a0e:	4f e7       	ldi	r20, 0x7F	; 127
    4a10:	57 e4       	ldi	r21, 0x47	; 71
    4a12:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    4a16:	18 16       	cp	r1, r24
    4a18:	0c f0       	brlt	.+2      	; 0x4a1c <chb_reset+0x2f0>
    4a1a:	10 e0       	ldi	r17, 0x00	; 0
    4a1c:	11 23       	and	r17, r17
    4a1e:	61 f1       	breq	.+88     	; 0x4a78 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a20:	6a a1       	lds	r22, 0x4a
    4a22:	7b a1       	lds	r23, 0x4b
    4a24:	8c a1       	lds	r24, 0x4c
    4a26:	9d a1       	lds	r25, 0x4d
    4a28:	20 e0       	ldi	r18, 0x00	; 0
    4a2a:	30 e0       	ldi	r19, 0x00	; 0
    4a2c:	40 e2       	ldi	r20, 0x20	; 32
    4a2e:	51 e4       	ldi	r21, 0x41	; 65
    4a30:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    4a34:	dc 01       	movw	r26, r24
    4a36:	cb 01       	movw	r24, r22
    4a38:	bc 01       	movw	r22, r24
    4a3a:	cd 01       	movw	r24, r26
    4a3c:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    4a40:	dc 01       	movw	r26, r24
    4a42:	cb 01       	movw	r24, r22
    4a44:	8a a7       	lds	r24, 0x7a
    4a46:	9b a7       	lds	r25, 0x7b
    4a48:	12 c0       	rjmp	.+36     	; 0x4a6e <chb_reset+0x342>
    4a4a:	89 e1       	ldi	r24, 0x19	; 25
    4a4c:	90 e0       	ldi	r25, 0x00	; 0
    4a4e:	8c a7       	lds	r24, 0x7c
    4a50:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4a52:	8c a5       	lds	r24, 0x6c
    4a54:	9d a5       	lds	r25, 0x6d
    4a56:	8c 01       	movw	r16, r24
    4a58:	c8 01       	movw	r24, r16
    4a5a:	01 97       	sbiw	r24, 0x01	; 1
    4a5c:	f1 f7       	brne	.-4      	; 0x4a5a <chb_reset+0x32e>
    4a5e:	8c 01       	movw	r16, r24
    4a60:	0c a7       	lds	r16, 0x7c
    4a62:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a64:	8a a5       	lds	r24, 0x6a
    4a66:	9b a5       	lds	r25, 0x6b
    4a68:	01 97       	sbiw	r24, 0x01	; 1
    4a6a:	8a a7       	lds	r24, 0x7a
    4a6c:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a6e:	8a a5       	lds	r24, 0x6a
    4a70:	9b a5       	lds	r25, 0x6b
    4a72:	00 97       	sbiw	r24, 0x00	; 0
    4a74:	51 f7       	brne	.-44     	; 0x4a4a <chb_reset+0x31e>
    4a76:	28 c0       	rjmp	.+80     	; 0x4ac8 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a78:	6e a1       	lds	r22, 0x4e
    4a7a:	7f a1       	lds	r23, 0x4f
    4a7c:	88 a5       	lds	r24, 0x68
    4a7e:	99 a5       	lds	r25, 0x69
    4a80:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    4a84:	dc 01       	movw	r26, r24
    4a86:	cb 01       	movw	r24, r22
    4a88:	8a a7       	lds	r24, 0x7a
    4a8a:	9b a7       	lds	r25, 0x7b
    4a8c:	8a a5       	lds	r24, 0x6a
    4a8e:	9b a5       	lds	r25, 0x6b
    4a90:	8e a7       	lds	r24, 0x7e
    4a92:	9f a7       	lds	r25, 0x7f
    4a94:	8e a5       	lds	r24, 0x6e
    4a96:	9f a5       	lds	r25, 0x6f
    4a98:	8c 01       	movw	r16, r24
    4a9a:	f8 01       	movw	r30, r16
    4a9c:	31 97       	sbiw	r30, 0x01	; 1
    4a9e:	f1 f7       	brne	.-4      	; 0x4a9c <chb_reset+0x370>
    4aa0:	8f 01       	movw	r16, r30
    4aa2:	0e a7       	lds	r16, 0x7e
    4aa4:	1f a7       	lds	r17, 0x7f
    4aa6:	10 c0       	rjmp	.+32     	; 0x4ac8 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4aa8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4aaa:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4aac:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4aae:	98 a1       	lds	r25, 0x48
    4ab0:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    4ab4:	dc 01       	movw	r26, r24
    4ab6:	cb 01       	movw	r24, r22
    4ab8:	89 a3       	lds	r24, 0x59
    4aba:	89 a1       	lds	r24, 0x49
    4abc:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4abe:	88 a9       	sts	0x48, r24
    4ac0:	18 2f       	mov	r17, r24
    4ac2:	1a 95       	dec	r17
    4ac4:	f1 f7       	brne	.-4      	; 0x4ac2 <chb_reset+0x396>
    4ac6:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4ac8:	84 e6       	ldi	r24, 0x64	; 100
    4aca:	96 e0       	ldi	r25, 0x06	; 6
    4acc:	24 e6       	ldi	r18, 0x64	; 100
    4ace:	36 e0       	ldi	r19, 0x06	; 6
    4ad0:	f9 01       	movw	r30, r18
    4ad2:	20 81       	ld	r18, Z
    4ad4:	21 60       	ori	r18, 0x01	; 1
    4ad6:	fc 01       	movw	r30, r24
    4ad8:	20 83       	st	Z, r18
    4ada:	01 c0       	rjmp	.+2      	; 0x4ade <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4adc:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    4ade:	8d e1       	ldi	r24, 0x1D	; 29
    4ae0:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    4ae4:	81 30       	cpi	r24, 0x01	; 1
    4ae6:	d1 f7       	brne	.-12     	; 0x4adc <chb_reset+0x3b0>
    4ae8:	8c e1       	ldi	r24, 0x1C	; 28
    4aea:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    4aee:	87 30       	cpi	r24, 0x07	; 7
    4af0:	a9 f7       	brne	.-22     	; 0x4adc <chb_reset+0x3b0>
        {
            break;
    4af2:	00 00       	nop
        }
    }
	

}
    4af4:	e0 96       	adiw	r28, 0x30	; 48
    4af6:	cd bf       	out	0x3d, r28	; 61
    4af8:	de bf       	out	0x3e, r29	; 62
    4afa:	df 91       	pop	r29
    4afc:	cf 91       	pop	r28
    4afe:	1f 91       	pop	r17
    4b00:	0f 91       	pop	r16
    4b02:	08 95       	ret

00004b04 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    4b04:	cf 93       	push	r28
    4b06:	df 93       	push	r29
    4b08:	0f 92       	push	r0
    4b0a:	0f 92       	push	r0
    4b0c:	cd b7       	in	r28, 0x3d	; 61
    4b0e:	de b7       	in	r29, 0x3e	; 62
    4b10:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    4b12:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    4b14:	8a 81       	ldd	r24, Y+2	; 0x02
    4b16:	80 68       	ori	r24, 0x80	; 128
    4b18:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4b1a:	8f e3       	ldi	r24, 0x3F	; 63
    4b1c:	90 e0       	ldi	r25, 0x00	; 0
    4b1e:	fc 01       	movw	r30, r24
    4b20:	80 81       	ld	r24, Z
    4b22:	80 93 57 40 	sts	0x4057, r24
    4b26:	f8 94       	cli
    RadioCS(TRUE);
    4b28:	81 e0       	ldi	r24, 0x01	; 1
    4b2a:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4b2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b30:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4b34:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4b36:	89 81       	ldd	r24, Y+1	; 0x01
    4b38:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4b3c:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4b3e:	80 e0       	ldi	r24, 0x00	; 0
    4b40:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>
    CHB_LEAVE_CRIT();
    4b44:	8f e3       	ldi	r24, 0x3F	; 63
    4b46:	90 e0       	ldi	r25, 0x00	; 0
    4b48:	20 91 57 40 	lds	r18, 0x4057
    4b4c:	fc 01       	movw	r30, r24
    4b4e:	20 83       	st	Z, r18
    4b50:	78 94       	sei

    return val;
    4b52:	89 81       	ldd	r24, Y+1	; 0x01
}
    4b54:	0f 90       	pop	r0
    4b56:	0f 90       	pop	r0
    4b58:	df 91       	pop	r29
    4b5a:	cf 91       	pop	r28
    4b5c:	08 95       	ret

00004b5e <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4b5e:	cf 93       	push	r28
    4b60:	df 93       	push	r29
    4b62:	00 d0       	rcall	.+0      	; 0x4b64 <chb_reg_read16+0x6>
    4b64:	0f 92       	push	r0
    4b66:	cd b7       	in	r28, 0x3d	; 61
    4b68:	de b7       	in	r29, 0x3e	; 62
    4b6a:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4b6c:	1a 82       	std	Y+2, r1	; 0x02
    4b6e:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    4b70:	19 82       	std	Y+1, r1	; 0x01
    4b72:	1d c0       	rjmp	.+58     	; 0x4bae <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4b74:	9c 81       	ldd	r25, Y+4	; 0x04
    4b76:	89 81       	ldd	r24, Y+1	; 0x01
    4b78:	89 0f       	add	r24, r25
    4b7a:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    4b7e:	88 2f       	mov	r24, r24
    4b80:	90 e0       	ldi	r25, 0x00	; 0
    4b82:	29 81       	ldd	r18, Y+1	; 0x01
    4b84:	22 2f       	mov	r18, r18
    4b86:	30 e0       	ldi	r19, 0x00	; 0
    4b88:	22 0f       	add	r18, r18
    4b8a:	33 1f       	adc	r19, r19
    4b8c:	22 0f       	add	r18, r18
    4b8e:	33 1f       	adc	r19, r19
    4b90:	22 0f       	add	r18, r18
    4b92:	33 1f       	adc	r19, r19
    4b94:	02 2e       	mov	r0, r18
    4b96:	02 c0       	rjmp	.+4      	; 0x4b9c <chb_reg_read16+0x3e>
    4b98:	88 0f       	add	r24, r24
    4b9a:	99 1f       	adc	r25, r25
    4b9c:	0a 94       	dec	r0
    4b9e:	e2 f7       	brpl	.-8      	; 0x4b98 <chb_reg_read16+0x3a>
    4ba0:	98 2f       	mov	r25, r24
    4ba2:	8c 81       	ldd	r24, Y+4	; 0x04
    4ba4:	89 2b       	or	r24, r25
    4ba6:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4ba8:	89 81       	ldd	r24, Y+1	; 0x01
    4baa:	8f 5f       	subi	r24, 0xFF	; 255
    4bac:	89 83       	std	Y+1, r24	; 0x01
    4bae:	89 81       	ldd	r24, Y+1	; 0x01
    4bb0:	82 30       	cpi	r24, 0x02	; 2
    4bb2:	00 f3       	brcs	.-64     	; 0x4b74 <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    4bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    4bb6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4bb8:	24 96       	adiw	r28, 0x04	; 4
    4bba:	cd bf       	out	0x3d, r28	; 61
    4bbc:	de bf       	out	0x3e, r29	; 62
    4bbe:	df 91       	pop	r29
    4bc0:	cf 91       	pop	r28
    4bc2:	08 95       	ret

00004bc4 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    4bc4:	cf 93       	push	r28
    4bc6:	df 93       	push	r29
    4bc8:	00 d0       	rcall	.+0      	; 0x4bca <chb_reg_write+0x6>
    4bca:	cd b7       	in	r28, 0x3d	; 61
    4bcc:	de b7       	in	r29, 0x3e	; 62
    4bce:	8a 83       	std	Y+2, r24	; 0x02
    4bd0:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    4bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    4bd4:	80 6c       	ori	r24, 0xC0	; 192
    4bd6:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4bd8:	8f e3       	ldi	r24, 0x3F	; 63
    4bda:	90 e0       	ldi	r25, 0x00	; 0
    4bdc:	fc 01       	movw	r30, r24
    4bde:	80 81       	ld	r24, Z
    4be0:	80 93 57 40 	sts	0x4057, r24
    4be4:	f8 94       	cli
    RadioCS(TRUE);
    4be6:	81 e0       	ldi	r24, 0x01	; 1
    4be8:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    4bec:	8a 81       	ldd	r24, Y+2	; 0x02
    4bee:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4bf2:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    4bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bf6:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4bfa:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4bfc:	80 e0       	ldi	r24, 0x00	; 0
    4bfe:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>
    CHB_LEAVE_CRIT();
    4c02:	8f e3       	ldi	r24, 0x3F	; 63
    4c04:	90 e0       	ldi	r25, 0x00	; 0
    4c06:	20 91 57 40 	lds	r18, 0x4057
    4c0a:	fc 01       	movw	r30, r24
    4c0c:	20 83       	st	Z, r18
    4c0e:	78 94       	sei
}
    4c10:	23 96       	adiw	r28, 0x03	; 3
    4c12:	cd bf       	out	0x3d, r28	; 61
    4c14:	de bf       	out	0x3e, r29	; 62
    4c16:	df 91       	pop	r29
    4c18:	cf 91       	pop	r28
    4c1a:	08 95       	ret

00004c1c <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4c1c:	cf 93       	push	r28
    4c1e:	df 93       	push	r29
    4c20:	00 d0       	rcall	.+0      	; 0x4c22 <chb_reg_write16+0x6>
    4c22:	0f 92       	push	r0
    4c24:	cd b7       	in	r28, 0x3d	; 61
    4c26:	de b7       	in	r29, 0x3e	; 62
    4c28:	8a 83       	std	Y+2, r24	; 0x02
    4c2a:	6b 83       	std	Y+3, r22	; 0x03
    4c2c:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4c2e:	19 82       	std	Y+1, r1	; 0x01
    4c30:	1d c0       	rjmp	.+58     	; 0x4c6c <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4c32:	9a 81       	ldd	r25, Y+2	; 0x02
    4c34:	89 81       	ldd	r24, Y+1	; 0x01
    4c36:	49 2f       	mov	r20, r25
    4c38:	48 0f       	add	r20, r24
    4c3a:	89 81       	ldd	r24, Y+1	; 0x01
    4c3c:	88 2f       	mov	r24, r24
    4c3e:	90 e0       	ldi	r25, 0x00	; 0
    4c40:	9c 01       	movw	r18, r24
    4c42:	22 0f       	add	r18, r18
    4c44:	33 1f       	adc	r19, r19
    4c46:	22 0f       	add	r18, r18
    4c48:	33 1f       	adc	r19, r19
    4c4a:	22 0f       	add	r18, r18
    4c4c:	33 1f       	adc	r19, r19
    4c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c50:	9c 81       	ldd	r25, Y+4	; 0x04
    4c52:	02 c0       	rjmp	.+4      	; 0x4c58 <chb_reg_write16+0x3c>
    4c54:	96 95       	lsr	r25
    4c56:	87 95       	ror	r24
    4c58:	2a 95       	dec	r18
    4c5a:	e2 f7       	brpl	.-8      	; 0x4c54 <chb_reg_write16+0x38>
    4c5c:	98 2f       	mov	r25, r24
    4c5e:	84 2f       	mov	r24, r20
    4c60:	69 2f       	mov	r22, r25
    4c62:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4c66:	89 81       	ldd	r24, Y+1	; 0x01
    4c68:	8f 5f       	subi	r24, 0xFF	; 255
    4c6a:	89 83       	std	Y+1, r24	; 0x01
    4c6c:	89 81       	ldd	r24, Y+1	; 0x01
    4c6e:	82 30       	cpi	r24, 0x02	; 2
    4c70:	00 f3       	brcs	.-64     	; 0x4c32 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4c72:	24 96       	adiw	r28, 0x04	; 4
    4c74:	cd bf       	out	0x3d, r28	; 61
    4c76:	de bf       	out	0x3e, r29	; 62
    4c78:	df 91       	pop	r29
    4c7a:	cf 91       	pop	r28
    4c7c:	08 95       	ret

00004c7e <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4c7e:	cf 93       	push	r28
    4c80:	df 93       	push	r29
    4c82:	00 d0       	rcall	.+0      	; 0x4c84 <chb_reg_write64+0x6>
    4c84:	0f 92       	push	r0
    4c86:	cd b7       	in	r28, 0x3d	; 61
    4c88:	de b7       	in	r29, 0x3e	; 62
    4c8a:	8a 83       	std	Y+2, r24	; 0x02
    4c8c:	6b 83       	std	Y+3, r22	; 0x03
    4c8e:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4c90:	19 82       	std	Y+1, r1	; 0x01
    4c92:	14 c0       	rjmp	.+40     	; 0x4cbc <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4c94:	9a 81       	ldd	r25, Y+2	; 0x02
    4c96:	89 81       	ldd	r24, Y+1	; 0x01
    4c98:	49 2f       	mov	r20, r25
    4c9a:	48 0f       	add	r20, r24
    4c9c:	89 81       	ldd	r24, Y+1	; 0x01
    4c9e:	88 2f       	mov	r24, r24
    4ca0:	90 e0       	ldi	r25, 0x00	; 0
    4ca2:	2b 81       	ldd	r18, Y+3	; 0x03
    4ca4:	3c 81       	ldd	r19, Y+4	; 0x04
    4ca6:	82 0f       	add	r24, r18
    4ca8:	93 1f       	adc	r25, r19
    4caa:	fc 01       	movw	r30, r24
    4cac:	90 81       	ld	r25, Z
    4cae:	84 2f       	mov	r24, r20
    4cb0:	69 2f       	mov	r22, r25
    4cb2:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4cb6:	89 81       	ldd	r24, Y+1	; 0x01
    4cb8:	8f 5f       	subi	r24, 0xFF	; 255
    4cba:	89 83       	std	Y+1, r24	; 0x01
    4cbc:	89 81       	ldd	r24, Y+1	; 0x01
    4cbe:	88 30       	cpi	r24, 0x08	; 8
    4cc0:	48 f3       	brcs	.-46     	; 0x4c94 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    4cc2:	24 96       	adiw	r28, 0x04	; 4
    4cc4:	cd bf       	out	0x3d, r28	; 61
    4cc6:	de bf       	out	0x3e, r29	; 62
    4cc8:	df 91       	pop	r29
    4cca:	cf 91       	pop	r28
    4ccc:	08 95       	ret

00004cce <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    4cce:	cf 93       	push	r28
    4cd0:	df 93       	push	r29
    4cd2:	00 d0       	rcall	.+0      	; 0x4cd4 <chb_reg_read_mod_write+0x6>
    4cd4:	0f 92       	push	r0
    4cd6:	cd b7       	in	r28, 0x3d	; 61
    4cd8:	de b7       	in	r29, 0x3e	; 62
    4cda:	8a 83       	std	Y+2, r24	; 0x02
    4cdc:	6b 83       	std	Y+3, r22	; 0x03
    4cde:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    4ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ce2:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    4ce6:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4ce8:	9b 81       	ldd	r25, Y+3	; 0x03
    4cea:	8c 81       	ldd	r24, Y+4	; 0x04
    4cec:	89 23       	and	r24, r25
    4cee:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4cf0:	8c 81       	ldd	r24, Y+4	; 0x04
    4cf2:	98 2f       	mov	r25, r24
    4cf4:	90 95       	com	r25
    4cf6:	89 81       	ldd	r24, Y+1	; 0x01
    4cf8:	89 23       	and	r24, r25
    4cfa:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4cfc:	99 81       	ldd	r25, Y+1	; 0x01
    4cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    4d00:	89 2b       	or	r24, r25
    4d02:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4d04:	8a 81       	ldd	r24, Y+2	; 0x02
    4d06:	69 81       	ldd	r22, Y+1	; 0x01
    4d08:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <chb_reg_write>
}
    4d0c:	24 96       	adiw	r28, 0x04	; 4
    4d0e:	cd bf       	out	0x3d, r28	; 61
    4d10:	de bf       	out	0x3e, r29	; 62
    4d12:	df 91       	pop	r29
    4d14:	cf 91       	pop	r28
    4d16:	08 95       	ret

00004d18 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4d18:	cf 93       	push	r28
    4d1a:	df 93       	push	r29
    4d1c:	cd b7       	in	r28, 0x3d	; 61
    4d1e:	de b7       	in	r29, 0x3e	; 62
    4d20:	28 97       	sbiw	r28, 0x08	; 8
    4d22:	cd bf       	out	0x3d, r28	; 61
    4d24:	de bf       	out	0x3e, r29	; 62
    4d26:	8b 83       	std	Y+3, r24	; 0x03
    4d28:	9c 83       	std	Y+4, r25	; 0x04
    4d2a:	6d 83       	std	Y+5, r22	; 0x05
    4d2c:	4e 83       	std	Y+6, r20	; 0x06
    4d2e:	5f 83       	std	Y+7, r21	; 0x07
    4d30:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4d32:	8d 81       	ldd	r24, Y+5	; 0x05
    4d34:	28 2f       	mov	r18, r24
    4d36:	30 e0       	ldi	r19, 0x00	; 0
    4d38:	88 85       	ldd	r24, Y+8	; 0x08
    4d3a:	88 2f       	mov	r24, r24
    4d3c:	90 e0       	ldi	r25, 0x00	; 0
    4d3e:	82 0f       	add	r24, r18
    4d40:	93 1f       	adc	r25, r19
    4d42:	80 38       	cpi	r24, 0x80	; 128
    4d44:	91 05       	cpc	r25, r1
    4d46:	0c f0       	brlt	.+2      	; 0x4d4a <chb_frame_write+0x32>
    4d48:	45 c0       	rjmp	.+138    	; 0x4dd4 <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4d4a:	8f e3       	ldi	r24, 0x3F	; 63
    4d4c:	90 e0       	ldi	r25, 0x00	; 0
    4d4e:	fc 01       	movw	r30, r24
    4d50:	80 81       	ld	r24, Z
    4d52:	80 93 57 40 	sts	0x4057, r24
    4d56:	f8 94       	cli
    RadioCS(TRUE); 
    4d58:	81 e0       	ldi	r24, 0x01	; 1
    4d5a:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    4d5e:	80 e6       	ldi	r24, 0x60	; 96
    4d60:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4d64:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4d66:	19 82       	std	Y+1, r1	; 0x01
    4d68:	10 c0       	rjmp	.+32     	; 0x4d8a <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    4d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4d6e:	fc 01       	movw	r30, r24
    4d70:	20 81       	ld	r18, Z
    4d72:	8b 81       	ldd	r24, Y+3	; 0x03
    4d74:	9c 81       	ldd	r25, Y+4	; 0x04
    4d76:	01 96       	adiw	r24, 0x01	; 1
    4d78:	8b 83       	std	Y+3, r24	; 0x03
    4d7a:	9c 83       	std	Y+4, r25	; 0x04
    4d7c:	82 2f       	mov	r24, r18
    4d7e:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4d82:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4d84:	89 81       	ldd	r24, Y+1	; 0x01
    4d86:	8f 5f       	subi	r24, 0xFF	; 255
    4d88:	89 83       	std	Y+1, r24	; 0x01
    4d8a:	99 81       	ldd	r25, Y+1	; 0x01
    4d8c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d8e:	98 17       	cp	r25, r24
    4d90:	60 f3       	brcs	.-40     	; 0x4d6a <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4d92:	19 82       	std	Y+1, r1	; 0x01
    4d94:	10 c0       	rjmp	.+32     	; 0x4db6 <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4d96:	8e 81       	ldd	r24, Y+6	; 0x06
    4d98:	9f 81       	ldd	r25, Y+7	; 0x07
    4d9a:	fc 01       	movw	r30, r24
    4d9c:	20 81       	ld	r18, Z
    4d9e:	8e 81       	ldd	r24, Y+6	; 0x06
    4da0:	9f 81       	ldd	r25, Y+7	; 0x07
    4da2:	01 96       	adiw	r24, 0x01	; 1
    4da4:	8e 83       	std	Y+6, r24	; 0x06
    4da6:	9f 83       	std	Y+7, r25	; 0x07
    4da8:	82 2f       	mov	r24, r18
    4daa:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4dae:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4db0:	89 81       	ldd	r24, Y+1	; 0x01
    4db2:	8f 5f       	subi	r24, 0xFF	; 255
    4db4:	89 83       	std	Y+1, r24	; 0x01
    4db6:	99 81       	ldd	r25, Y+1	; 0x01
    4db8:	88 85       	ldd	r24, Y+8	; 0x08
    4dba:	98 17       	cp	r25, r24
    4dbc:	60 f3       	brcs	.-40     	; 0x4d96 <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    4dbe:	80 e0       	ldi	r24, 0x00	; 0
    4dc0:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>
    CHB_LEAVE_CRIT();
    4dc4:	8f e3       	ldi	r24, 0x3F	; 63
    4dc6:	90 e0       	ldi	r25, 0x00	; 0
    4dc8:	20 91 57 40 	lds	r18, 0x4057
    4dcc:	fc 01       	movw	r30, r24
    4dce:	20 83       	st	Z, r18
    4dd0:	78 94       	sei
    4dd2:	01 c0       	rjmp	.+2      	; 0x4dd6 <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4dd4:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4dd6:	28 96       	adiw	r28, 0x08	; 8
    4dd8:	cd bf       	out	0x3d, r28	; 61
    4dda:	de bf       	out	0x3e, r29	; 62
    4ddc:	df 91       	pop	r29
    4dde:	cf 91       	pop	r28
    4de0:	08 95       	ret

00004de2 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    4de2:	0f 93       	push	r16
    4de4:	1f 93       	push	r17
    4de6:	cf 93       	push	r28
    4de8:	df 93       	push	r29
    4dea:	cd b7       	in	r28, 0x3d	; 61
    4dec:	de b7       	in	r29, 0x3e	; 62
    4dee:	e7 97       	sbiw	r28, 0x37	; 55
    4df0:	cd bf       	out	0x3d, r28	; 61
    4df2:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4df4:	8f e3       	ldi	r24, 0x3F	; 63
    4df6:	90 e0       	ldi	r25, 0x00	; 0
    4df8:	fc 01       	movw	r30, r24
    4dfa:	80 81       	ld	r24, Z
    4dfc:	80 93 57 40 	sts	0x4057, r24
    4e00:	f8 94       	cli
    RadioCS(TRUE);
    4e02:	81 e0       	ldi	r24, 0x01	; 1
    4e04:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4e08:	80 e2       	ldi	r24, 0x20	; 32
    4e0a:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    len = SPID_write(0);
    4e0e:	80 e0       	ldi	r24, 0x00	; 0
    4e10:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4e14:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4e16:	8a 81       	ldd	r24, Y+2	; 0x02
    4e18:	83 30       	cpi	r24, 0x03	; 3
    4e1a:	08 f4       	brcc	.+2      	; 0x4e1e <chb_frame_read+0x3c>
    4e1c:	66 c0       	rjmp	.+204    	; 0x4eea <chb_frame_read+0x108>
    4e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e20:	88 23       	and	r24, r24
    4e22:	0c f4       	brge	.+2      	; 0x4e26 <chb_frame_read+0x44>
    4e24:	62 c0       	rjmp	.+196    	; 0x4eea <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4e26:	8a 81       	ldd	r24, Y+2	; 0x02
    4e28:	08 2f       	mov	r16, r24
    4e2a:	10 e0       	ldi	r17, 0x00	; 0
    4e2c:	0e 94 75 23 	call	0x46ea	; 0x46ea <chb_buf_get_len>
    4e30:	88 2f       	mov	r24, r24
    4e32:	90 e0       	ldi	r25, 0x00	; 0
    4e34:	20 e8       	ldi	r18, 0x80	; 128
    4e36:	30 e0       	ldi	r19, 0x00	; 0
    4e38:	a9 01       	movw	r20, r18
    4e3a:	48 1b       	sub	r20, r24
    4e3c:	59 0b       	sbc	r21, r25
    4e3e:	ca 01       	movw	r24, r20
    4e40:	08 17       	cp	r16, r24
    4e42:	19 07       	cpc	r17, r25
    4e44:	f4 f4       	brge	.+60     	; 0x4e82 <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4e46:	8a 81       	ldd	r24, Y+2	; 0x02
    4e48:	0e 94 2d 23 	call	0x465a	; 0x465a <chb_buf_write>
            
            for (i=0; i<len; i++)
    4e4c:	19 82       	std	Y+1, r1	; 0x01
    4e4e:	0a c0       	rjmp	.+20     	; 0x4e64 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4e50:	80 e0       	ldi	r24, 0x00	; 0
    4e52:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4e56:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4e58:	8b 81       	ldd	r24, Y+3	; 0x03
    4e5a:	0e 94 2d 23 	call	0x465a	; 0x465a <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4e5e:	89 81       	ldd	r24, Y+1	; 0x01
    4e60:	8f 5f       	subi	r24, 0xFF	; 255
    4e62:	89 83       	std	Y+1, r24	; 0x01
    4e64:	99 81       	ldd	r25, Y+1	; 0x01
    4e66:	8a 81       	ldd	r24, Y+2	; 0x02
    4e68:	98 17       	cp	r25, r24
    4e6a:	90 f3       	brcs	.-28     	; 0x4e50 <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4e6c:	80 e8       	ldi	r24, 0x80	; 128
    4e6e:	96 e0       	ldi	r25, 0x06	; 6
    4e70:	24 e0       	ldi	r18, 0x04	; 4
    4e72:	fc 01       	movw	r30, r24
    4e74:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4e76:	80 e8       	ldi	r24, 0x80	; 128
    4e78:	96 e0       	ldi	r25, 0x06	; 6
    4e7a:	24 e0       	ldi	r18, 0x04	; 4
    4e7c:	fc 01       	movw	r30, r24
    4e7e:	26 83       	std	Z+6, r18	; 0x06
    4e80:	34 c0       	rjmp	.+104    	; 0x4eea <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4e82:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <chb_get_pcb>
    4e86:	8c 83       	std	Y+4, r24	; 0x04
    4e88:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4e8a:	19 82       	std	Y+1, r1	; 0x01
    4e8c:	07 c0       	rjmp	.+14     	; 0x4e9c <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    4e8e:	80 e0       	ldi	r24, 0x00	; 0
    4e90:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    4e94:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4e96:	89 81       	ldd	r24, Y+1	; 0x01
    4e98:	8f 5f       	subi	r24, 0xFF	; 255
    4e9a:	89 83       	std	Y+1, r24	; 0x01
    4e9c:	99 81       	ldd	r25, Y+1	; 0x01
    4e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea0:	98 17       	cp	r25, r24
    4ea2:	a8 f3       	brcs	.-22     	; 0x4e8e <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4ea4:	8c 81       	ldd	r24, Y+4	; 0x04
    4ea6:	9d 81       	ldd	r25, Y+5	; 0x05
    4ea8:	fc 01       	movw	r30, r24
    4eaa:	85 85       	ldd	r24, Z+13	; 0x0d
    4eac:	96 85       	ldd	r25, Z+14	; 0x0e
    4eae:	9c 01       	movw	r18, r24
    4eb0:	2f 5f       	subi	r18, 0xFF	; 255
    4eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    4eb4:	8c 81       	ldd	r24, Y+4	; 0x04
    4eb6:	9d 81       	ldd	r25, Y+5	; 0x05
    4eb8:	fc 01       	movw	r30, r24
    4eba:	25 87       	std	Z+13, r18	; 0x0d
    4ebc:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4ebe:	ce 01       	movw	r24, r28
    4ec0:	06 96       	adiw	r24, 0x06	; 6
    4ec2:	28 ee       	ldi	r18, 0xE8	; 232
    4ec4:	31 e0       	ldi	r19, 0x01	; 1
    4ec6:	b9 01       	movw	r22, r18
    4ec8:	0e 94 26 5f 	call	0xbe4c	; 0xbe4c <strcpy_P>
            printf(buf);
    4ecc:	0f 92       	push	r0
    4ece:	0f 92       	push	r0
    4ed0:	8d b7       	in	r24, 0x3d	; 61
    4ed2:	9e b7       	in	r25, 0x3e	; 62
    4ed4:	01 96       	adiw	r24, 0x01	; 1
    4ed6:	9e 01       	movw	r18, r28
    4ed8:	2a 5f       	subi	r18, 0xFA	; 250
    4eda:	3f 4f       	sbci	r19, 0xFF	; 255
    4edc:	fc 01       	movw	r30, r24
    4ede:	20 83       	st	Z, r18
    4ee0:	31 83       	std	Z+1, r19	; 0x01
    4ee2:	0e 94 82 5f 	call	0xbf04	; 0xbf04 <printf>
    4ee6:	0f 90       	pop	r0
    4ee8:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4eea:	80 e0       	ldi	r24, 0x00	; 0
    4eec:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>
    CHB_LEAVE_CRIT();
    4ef0:	8f e3       	ldi	r24, 0x3F	; 63
    4ef2:	90 e0       	ldi	r25, 0x00	; 0
    4ef4:	20 91 57 40 	lds	r18, 0x4057
    4ef8:	fc 01       	movw	r30, r24
    4efa:	20 83       	st	Z, r18
    4efc:	78 94       	sei
}
    4efe:	e7 96       	adiw	r28, 0x37	; 55
    4f00:	cd bf       	out	0x3d, r28	; 61
    4f02:	de bf       	out	0x3e, r29	; 62
    4f04:	df 91       	pop	r29
    4f06:	cf 91       	pop	r28
    4f08:	1f 91       	pop	r17
    4f0a:	0f 91       	pop	r16
    4f0c:	08 95       	ret

00004f0e <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4f0e:	cf 93       	push	r28
    4f10:	df 93       	push	r29
    4f12:	0f 92       	push	r0
    4f14:	cd b7       	in	r28, 0x3d	; 61
    4f16:	de b7       	in	r29, 0x3e	; 62
    4f18:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4f1a:	89 81       	ldd	r24, Y+1	; 0x01
    4f1c:	88 2f       	mov	r24, r24
    4f1e:	90 e0       	ldi	r25, 0x00	; 0
    4f20:	81 30       	cpi	r24, 0x01	; 1
    4f22:	91 05       	cpc	r25, r1
    4f24:	c1 f0       	breq	.+48     	; 0x4f56 <chb_set_mode+0x48>
    4f26:	82 30       	cpi	r24, 0x02	; 2
    4f28:	91 05       	cpc	r25, r1
    4f2a:	1c f4       	brge	.+6      	; 0x4f32 <chb_set_mode+0x24>
    4f2c:	00 97       	sbiw	r24, 0x00	; 0
    4f2e:	41 f0       	breq	.+16     	; 0x4f40 <chb_set_mode+0x32>
    4f30:	33 c0       	rjmp	.+102    	; 0x4f98 <chb_set_mode+0x8a>
    4f32:	82 30       	cpi	r24, 0x02	; 2
    4f34:	91 05       	cpc	r25, r1
    4f36:	d1 f0       	breq	.+52     	; 0x4f6c <chb_set_mode+0x5e>
    4f38:	83 30       	cpi	r24, 0x03	; 3
    4f3a:	91 05       	cpc	r25, r1
    4f3c:	11 f1       	breq	.+68     	; 0x4f82 <chb_set_mode+0x74>
    4f3e:	2c c0       	rjmp	.+88     	; 0x4f98 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4f40:	8c e0       	ldi	r24, 0x0C	; 12
    4f42:	68 e0       	ldi	r22, 0x08	; 8
    4f44:	4f e3       	ldi	r20, 0x3F	; 63
    4f46:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f4a:	86 e1       	ldi	r24, 0x16	; 22
    4f4c:	62 e0       	ldi	r22, 0x02	; 2
    4f4e:	43 e0       	ldi	r20, 0x03	; 3
    4f50:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        break;
    4f54:	21 c0       	rjmp	.+66     	; 0x4f98 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4f56:	8c e0       	ldi	r24, 0x0C	; 12
    4f58:	6c e0       	ldi	r22, 0x0C	; 12
    4f5a:	4f e3       	ldi	r20, 0x3F	; 63
    4f5c:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f60:	86 e1       	ldi	r24, 0x16	; 22
    4f62:	62 e0       	ldi	r22, 0x02	; 2
    4f64:	43 e0       	ldi	r20, 0x03	; 3
    4f66:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        break;
    4f6a:	16 c0       	rjmp	.+44     	; 0x4f98 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4f6c:	8c e0       	ldi	r24, 0x0C	; 12
    4f6e:	6c e1       	ldi	r22, 0x1C	; 28
    4f70:	4f e3       	ldi	r20, 0x3F	; 63
    4f72:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f76:	86 e1       	ldi	r24, 0x16	; 22
    4f78:	62 e0       	ldi	r22, 0x02	; 2
    4f7a:	43 e0       	ldi	r20, 0x03	; 3
    4f7c:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        break;
    4f80:	0b c0       	rjmp	.+22     	; 0x4f98 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4f82:	8c e0       	ldi	r24, 0x0C	; 12
    4f84:	60 e0       	ldi	r22, 0x00	; 0
    4f86:	4f e3       	ldi	r20, 0x3F	; 63
    4f88:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4f8c:	86 e1       	ldi	r24, 0x16	; 22
    4f8e:	63 e0       	ldi	r22, 0x03	; 3
    4f90:	43 e0       	ldi	r20, 0x03	; 3
    4f92:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
        break;
    4f96:	00 00       	nop
    }
}
    4f98:	0f 90       	pop	r0
    4f9a:	df 91       	pop	r29
    4f9c:	cf 91       	pop	r28
    4f9e:	08 95       	ret

00004fa0 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4fa0:	0f 93       	push	r16
    4fa2:	1f 93       	push	r17
    4fa4:	cf 93       	push	r28
    4fa6:	df 93       	push	r29
    4fa8:	cd b7       	in	r28, 0x3d	; 61
    4faa:	de b7       	in	r29, 0x3e	; 62
    4fac:	6a 97       	sbiw	r28, 0x1a	; 26
    4fae:	cd bf       	out	0x3d, r28	; 61
    4fb0:	de bf       	out	0x3e, r29	; 62
    4fb2:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4fb4:	88 e0       	ldi	r24, 0x08	; 8
    4fb6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4fb8:	4f e1       	ldi	r20, 0x1F	; 31
    4fba:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4fbe:	0e 94 7e 23 	call	0x46fc	; 0x46fc <chb_get_state>
    4fc2:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4fc4:	89 81       	ldd	r24, Y+1	; 0x01
    4fc6:	86 30       	cpi	r24, 0x06	; 6
    4fc8:	21 f0       	breq	.+8      	; 0x4fd2 <chb_set_channel+0x32>
    4fca:	89 81       	ldd	r24, Y+1	; 0x01
    4fcc:	89 30       	cpi	r24, 0x09	; 9
    4fce:	09 f0       	breq	.+2      	; 0x4fd2 <chb_set_channel+0x32>
    4fd0:	d5 c0       	rjmp	.+426    	; 0x517c <chb_set_channel+0x1dc>
    4fd2:	80 e0       	ldi	r24, 0x00	; 0
    4fd4:	90 e0       	ldi	r25, 0x00	; 0
    4fd6:	ac ed       	ldi	r26, 0xDC	; 220
    4fd8:	b2 e4       	ldi	r27, 0x42	; 66
    4fda:	8a 83       	std	Y+2, r24	; 0x02
    4fdc:	9b 83       	std	Y+3, r25	; 0x03
    4fde:	ac 83       	std	Y+4, r26	; 0x04
    4fe0:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4fe2:	6a 81       	ldd	r22, Y+2	; 0x02
    4fe4:	7b 81       	ldd	r23, Y+3	; 0x03
    4fe6:	8c 81       	ldd	r24, Y+4	; 0x04
    4fe8:	9d 81       	ldd	r25, Y+5	; 0x05
    4fea:	2b ea       	ldi	r18, 0xAB	; 171
    4fec:	3a ea       	ldi	r19, 0xAA	; 170
    4fee:	4a ea       	ldi	r20, 0xAA	; 170
    4ff0:	5e e3       	ldi	r21, 0x3E	; 62
    4ff2:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    4ff6:	dc 01       	movw	r26, r24
    4ff8:	cb 01       	movw	r24, r22
    4ffa:	8e 83       	std	Y+6, r24	; 0x06
    4ffc:	9f 83       	std	Y+7, r25	; 0x07
    4ffe:	a8 87       	std	Y+8, r26	; 0x08
    5000:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    5002:	11 e0       	ldi	r17, 0x01	; 1
    5004:	6e 81       	ldd	r22, Y+6	; 0x06
    5006:	7f 81       	ldd	r23, Y+7	; 0x07
    5008:	88 85       	ldd	r24, Y+8	; 0x08
    500a:	99 85       	ldd	r25, Y+9	; 0x09
    500c:	20 e0       	ldi	r18, 0x00	; 0
    500e:	30 e0       	ldi	r19, 0x00	; 0
    5010:	40 e8       	ldi	r20, 0x80	; 128
    5012:	5f e3       	ldi	r21, 0x3F	; 63
    5014:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    5018:	88 23       	and	r24, r24
    501a:	0c f0       	brlt	.+2      	; 0x501e <chb_set_channel+0x7e>
    501c:	10 e0       	ldi	r17, 0x00	; 0
    501e:	11 23       	and	r17, r17
    5020:	19 f0       	breq	.+6      	; 0x5028 <chb_set_channel+0x88>
		__ticks = 1;
    5022:	81 e0       	ldi	r24, 0x01	; 1
    5024:	8a 87       	std	Y+10, r24	; 0x0a
    5026:	a3 c0       	rjmp	.+326    	; 0x516e <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    5028:	11 e0       	ldi	r17, 0x01	; 1
    502a:	6e 81       	ldd	r22, Y+6	; 0x06
    502c:	7f 81       	ldd	r23, Y+7	; 0x07
    502e:	88 85       	ldd	r24, Y+8	; 0x08
    5030:	99 85       	ldd	r25, Y+9	; 0x09
    5032:	20 e0       	ldi	r18, 0x00	; 0
    5034:	30 e0       	ldi	r19, 0x00	; 0
    5036:	4f e7       	ldi	r20, 0x7F	; 127
    5038:	53 e4       	ldi	r21, 0x43	; 67
    503a:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    503e:	18 16       	cp	r1, r24
    5040:	0c f0       	brlt	.+2      	; 0x5044 <chb_set_channel+0xa4>
    5042:	10 e0       	ldi	r17, 0x00	; 0
    5044:	11 23       	and	r17, r17
    5046:	09 f4       	brne	.+2      	; 0x504a <chb_set_channel+0xaa>
    5048:	89 c0       	rjmp	.+274    	; 0x515c <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    504a:	6a 81       	ldd	r22, Y+2	; 0x02
    504c:	7b 81       	ldd	r23, Y+3	; 0x03
    504e:	8c 81       	ldd	r24, Y+4	; 0x04
    5050:	9d 81       	ldd	r25, Y+5	; 0x05
    5052:	20 e0       	ldi	r18, 0x00	; 0
    5054:	30 e0       	ldi	r19, 0x00	; 0
    5056:	4a e7       	ldi	r20, 0x7A	; 122
    5058:	54 e4       	ldi	r21, 0x44	; 68
    505a:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    505e:	dc 01       	movw	r26, r24
    5060:	cb 01       	movw	r24, r22
    5062:	8b 87       	std	Y+11, r24	; 0x0b
    5064:	9c 87       	std	Y+12, r25	; 0x0c
    5066:	ad 87       	std	Y+13, r26	; 0x0d
    5068:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    506a:	6b 85       	ldd	r22, Y+11	; 0x0b
    506c:	7c 85       	ldd	r23, Y+12	; 0x0c
    506e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5070:	9e 85       	ldd	r25, Y+14	; 0x0e
    5072:	20 e0       	ldi	r18, 0x00	; 0
    5074:	30 e0       	ldi	r19, 0x00	; 0
    5076:	4a e7       	ldi	r20, 0x7A	; 122
    5078:	53 e4       	ldi	r21, 0x43	; 67
    507a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    507e:	dc 01       	movw	r26, r24
    5080:	cb 01       	movw	r24, r22
    5082:	8f 87       	std	Y+15, r24	; 0x0f
    5084:	98 8b       	std	Y+16, r25	; 0x10
    5086:	a9 8b       	std	Y+17, r26	; 0x11
    5088:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    508a:	11 e0       	ldi	r17, 0x01	; 1
    508c:	6f 85       	ldd	r22, Y+15	; 0x0f
    508e:	78 89       	ldd	r23, Y+16	; 0x10
    5090:	89 89       	ldd	r24, Y+17	; 0x11
    5092:	9a 89       	ldd	r25, Y+18	; 0x12
    5094:	20 e0       	ldi	r18, 0x00	; 0
    5096:	30 e0       	ldi	r19, 0x00	; 0
    5098:	40 e8       	ldi	r20, 0x80	; 128
    509a:	5f e3       	ldi	r21, 0x3F	; 63
    509c:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    50a0:	88 23       	and	r24, r24
    50a2:	0c f0       	brlt	.+2      	; 0x50a6 <chb_set_channel+0x106>
    50a4:	10 e0       	ldi	r17, 0x00	; 0
    50a6:	11 23       	and	r17, r17
    50a8:	29 f0       	breq	.+10     	; 0x50b4 <chb_set_channel+0x114>
		__ticks = 1;
    50aa:	81 e0       	ldi	r24, 0x01	; 1
    50ac:	90 e0       	ldi	r25, 0x00	; 0
    50ae:	8b 8b       	std	Y+19, r24	; 0x13
    50b0:	9c 8b       	std	Y+20, r25	; 0x14
    50b2:	46 c0       	rjmp	.+140    	; 0x5140 <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    50b4:	11 e0       	ldi	r17, 0x01	; 1
    50b6:	6f 85       	ldd	r22, Y+15	; 0x0f
    50b8:	78 89       	ldd	r23, Y+16	; 0x10
    50ba:	89 89       	ldd	r24, Y+17	; 0x11
    50bc:	9a 89       	ldd	r25, Y+18	; 0x12
    50be:	20 e0       	ldi	r18, 0x00	; 0
    50c0:	3f ef       	ldi	r19, 0xFF	; 255
    50c2:	4f e7       	ldi	r20, 0x7F	; 127
    50c4:	57 e4       	ldi	r21, 0x47	; 71
    50c6:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    50ca:	18 16       	cp	r1, r24
    50cc:	0c f0       	brlt	.+2      	; 0x50d0 <chb_set_channel+0x130>
    50ce:	10 e0       	ldi	r17, 0x00	; 0
    50d0:	11 23       	and	r17, r17
    50d2:	61 f1       	breq	.+88     	; 0x512c <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    50d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    50d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    50d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    50da:	9e 85       	ldd	r25, Y+14	; 0x0e
    50dc:	20 e0       	ldi	r18, 0x00	; 0
    50de:	30 e0       	ldi	r19, 0x00	; 0
    50e0:	40 e2       	ldi	r20, 0x20	; 32
    50e2:	51 e4       	ldi	r21, 0x41	; 65
    50e4:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    50e8:	dc 01       	movw	r26, r24
    50ea:	cb 01       	movw	r24, r22
    50ec:	bc 01       	movw	r22, r24
    50ee:	cd 01       	movw	r24, r26
    50f0:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    50f4:	dc 01       	movw	r26, r24
    50f6:	cb 01       	movw	r24, r22
    50f8:	8b 8b       	std	Y+19, r24	; 0x13
    50fa:	9c 8b       	std	Y+20, r25	; 0x14
    50fc:	12 c0       	rjmp	.+36     	; 0x5122 <chb_set_channel+0x182>
    50fe:	89 e1       	ldi	r24, 0x19	; 25
    5100:	90 e0       	ldi	r25, 0x00	; 0
    5102:	8d 8b       	std	Y+21, r24	; 0x15
    5104:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5106:	8d 89       	ldd	r24, Y+21	; 0x15
    5108:	9e 89       	ldd	r25, Y+22	; 0x16
    510a:	8c 01       	movw	r16, r24
    510c:	c8 01       	movw	r24, r16
    510e:	01 97       	sbiw	r24, 0x01	; 1
    5110:	f1 f7       	brne	.-4      	; 0x510e <chb_set_channel+0x16e>
    5112:	8c 01       	movw	r16, r24
    5114:	0d 8b       	std	Y+21, r16	; 0x15
    5116:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5118:	8b 89       	ldd	r24, Y+19	; 0x13
    511a:	9c 89       	ldd	r25, Y+20	; 0x14
    511c:	01 97       	sbiw	r24, 0x01	; 1
    511e:	8b 8b       	std	Y+19, r24	; 0x13
    5120:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5122:	8b 89       	ldd	r24, Y+19	; 0x13
    5124:	9c 89       	ldd	r25, Y+20	; 0x14
    5126:	00 97       	sbiw	r24, 0x00	; 0
    5128:	51 f7       	brne	.-44     	; 0x50fe <chb_set_channel+0x15e>
    512a:	28 c0       	rjmp	.+80     	; 0x517c <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    512c:	6f 85       	ldd	r22, Y+15	; 0x0f
    512e:	78 89       	ldd	r23, Y+16	; 0x10
    5130:	89 89       	ldd	r24, Y+17	; 0x11
    5132:	9a 89       	ldd	r25, Y+18	; 0x12
    5134:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5138:	dc 01       	movw	r26, r24
    513a:	cb 01       	movw	r24, r22
    513c:	8b 8b       	std	Y+19, r24	; 0x13
    513e:	9c 8b       	std	Y+20, r25	; 0x14
    5140:	8b 89       	ldd	r24, Y+19	; 0x13
    5142:	9c 89       	ldd	r25, Y+20	; 0x14
    5144:	8f 8b       	std	Y+23, r24	; 0x17
    5146:	98 8f       	std	Y+24, r25	; 0x18
    5148:	8f 89       	ldd	r24, Y+23	; 0x17
    514a:	98 8d       	ldd	r25, Y+24	; 0x18
    514c:	8c 01       	movw	r16, r24
    514e:	c8 01       	movw	r24, r16
    5150:	01 97       	sbiw	r24, 0x01	; 1
    5152:	f1 f7       	brne	.-4      	; 0x5150 <chb_set_channel+0x1b0>
    5154:	8c 01       	movw	r16, r24
    5156:	0f 8b       	std	Y+23, r16	; 0x17
    5158:	18 8f       	std	Y+24, r17	; 0x18
    515a:	10 c0       	rjmp	.+32     	; 0x517c <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    515c:	6e 81       	ldd	r22, Y+6	; 0x06
    515e:	7f 81       	ldd	r23, Y+7	; 0x07
    5160:	88 85       	ldd	r24, Y+8	; 0x08
    5162:	99 85       	ldd	r25, Y+9	; 0x09
    5164:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5168:	dc 01       	movw	r26, r24
    516a:	cb 01       	movw	r24, r22
    516c:	8a 87       	std	Y+10, r24	; 0x0a
    516e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5170:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5172:	89 8d       	ldd	r24, Y+25	; 0x19
    5174:	18 2f       	mov	r17, r24
    5176:	1a 95       	dec	r17
    5178:	f1 f7       	brne	.-4      	; 0x5176 <chb_set_channel+0x1d6>
    517a:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    517c:	88 e0       	ldi	r24, 0x08	; 8
    517e:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    5182:	88 2f       	mov	r24, r24
    5184:	90 e0       	ldi	r25, 0x00	; 0
    5186:	9c 01       	movw	r18, r24
    5188:	2f 71       	andi	r18, 0x1F	; 31
    518a:	30 70       	andi	r19, 0x00	; 0
    518c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    518e:	88 2f       	mov	r24, r24
    5190:	90 e0       	ldi	r25, 0x00	; 0
    5192:	28 17       	cp	r18, r24
    5194:	39 07       	cpc	r19, r25
    5196:	11 f4       	brne	.+4      	; 0x519c <chb_set_channel+0x1fc>
    5198:	80 e4       	ldi	r24, 0x40	; 64
    519a:	01 c0       	rjmp	.+2      	; 0x519e <chb_set_channel+0x1fe>
    519c:	83 e4       	ldi	r24, 0x43	; 67
}
    519e:	6a 96       	adiw	r28, 0x1a	; 26
    51a0:	cd bf       	out	0x3d, r28	; 61
    51a2:	de bf       	out	0x3e, r29	; 62
    51a4:	df 91       	pop	r29
    51a6:	cf 91       	pop	r28
    51a8:	1f 91       	pop	r17
    51aa:	0f 91       	pop	r16
    51ac:	08 95       	ret

000051ae <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    51ae:	cf 93       	push	r28
    51b0:	df 93       	push	r29
    51b2:	0f 92       	push	r0
    51b4:	cd b7       	in	r28, 0x3d	; 61
    51b6:	de b7       	in	r29, 0x3e	; 62
    51b8:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    51ba:	85 e0       	ldi	r24, 0x05	; 5
    51bc:	69 81       	ldd	r22, Y+1	; 0x01
    51be:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <chb_reg_write>
}
    51c2:	0f 90       	pop	r0
    51c4:	df 91       	pop	r29
    51c6:	cf 91       	pop	r28
    51c8:	08 95       	ret

000051ca <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    51ca:	0f 93       	push	r16
    51cc:	1f 93       	push	r17
    51ce:	cf 93       	push	r28
    51d0:	df 93       	push	r29
    51d2:	cd b7       	in	r28, 0x3d	; 61
    51d4:	de b7       	in	r29, 0x3e	; 62
    51d6:	c2 56       	subi	r28, 0x62	; 98
    51d8:	d0 40       	sbci	r29, 0x00	; 0
    51da:	cd bf       	out	0x3d, r28	; 61
    51dc:	de bf       	out	0x3e, r29	; 62
    51de:	9e 01       	movw	r18, r28
    51e0:	2e 59       	subi	r18, 0x9E	; 158
    51e2:	3f 4f       	sbci	r19, 0xFF	; 255
    51e4:	f9 01       	movw	r30, r18
    51e6:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    51e8:	84 e6       	ldi	r24, 0x64	; 100
    51ea:	96 e0       	ldi	r25, 0x06	; 6
    51ec:	fc 01       	movw	r30, r24
    51ee:	80 81       	ld	r24, Z
    51f0:	88 2f       	mov	r24, r24
    51f2:	90 e0       	ldi	r25, 0x00	; 0
    51f4:	82 70       	andi	r24, 0x02	; 2
    51f6:	90 70       	andi	r25, 0x00	; 0
    51f8:	00 97       	sbiw	r24, 0x00	; 0
    51fa:	11 f0       	breq	.+4      	; 0x5200 <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    51fc:	84 e4       	ldi	r24, 0x44	; 68
    51fe:	91 c4       	rjmp	.+2338   	; 0x5b22 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    5200:	0e 94 7e 23 	call	0x46fc	; 0x46fc <chb_get_state>
    5204:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    5206:	89 81       	ldd	r24, Y+1	; 0x01
    5208:	82 31       	cpi	r24, 0x12	; 18
    520a:	49 f0       	breq	.+18     	; 0x521e <chb_set_state+0x54>
    520c:	89 81       	ldd	r24, Y+1	; 0x01
    520e:	81 31       	cpi	r24, 0x11	; 17
    5210:	31 f0       	breq	.+12     	; 0x521e <chb_set_state+0x54>
    5212:	89 81       	ldd	r24, Y+1	; 0x01
    5214:	81 30       	cpi	r24, 0x01	; 1
    5216:	19 f0       	breq	.+6      	; 0x521e <chb_set_state+0x54>
    5218:	89 81       	ldd	r24, Y+1	; 0x01
    521a:	82 30       	cpi	r24, 0x02	; 2
    521c:	39 f4       	brne	.+14     	; 0x522c <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    521e:	00 00       	nop
    5220:	0e 94 7e 23 	call	0x46fc	; 0x46fc <chb_get_state>
    5224:	98 2f       	mov	r25, r24
    5226:	89 81       	ldd	r24, Y+1	; 0x01
    5228:	98 17       	cp	r25, r24
    522a:	d1 f3       	breq	.-12     	; 0x5220 <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    522c:	ce 01       	movw	r24, r28
    522e:	8e 59       	subi	r24, 0x9E	; 158
    5230:	9f 4f       	sbci	r25, 0xFF	; 255
    5232:	fc 01       	movw	r30, r24
    5234:	80 81       	ld	r24, Z
    5236:	88 2f       	mov	r24, r24
    5238:	90 e0       	ldi	r25, 0x00	; 0
    523a:	86 31       	cpi	r24, 0x16	; 22
    523c:	91 05       	cpc	r25, r1
    523e:	09 f4       	brne	.+2      	; 0x5242 <chb_set_state+0x78>
    5240:	cd c1       	rjmp	.+922    	; 0x55dc <chb_set_state+0x412>
    5242:	89 31       	cpi	r24, 0x19	; 25
    5244:	91 05       	cpc	r25, r1
    5246:	09 f4       	brne	.+2      	; 0x524a <chb_set_state+0x80>
    5248:	e9 c0       	rjmp	.+466    	; 0x541c <chb_set_state+0x252>
    524a:	88 30       	cpi	r24, 0x08	; 8
    524c:	91 05       	cpc	r25, r1
    524e:	09 f0       	breq	.+2      	; 0x5252 <chb_set_state+0x88>
    5250:	f7 c2       	rjmp	.+1518   	; 0x5840 <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    5252:	84 e6       	ldi	r24, 0x64	; 100
    5254:	96 e0       	ldi	r25, 0x06	; 6
    5256:	24 e6       	ldi	r18, 0x64	; 100
    5258:	36 e0       	ldi	r19, 0x06	; 6
    525a:	f9 01       	movw	r30, r18
    525c:	20 81       	ld	r18, Z
    525e:	2d 7f       	andi	r18, 0xFD	; 253
    5260:	fc 01       	movw	r30, r24
    5262:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    5264:	82 e0       	ldi	r24, 0x02	; 2
    5266:	63 e0       	ldi	r22, 0x03	; 3
    5268:	4f e1       	ldi	r20, 0x1F	; 31
    526a:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
    526e:	80 e0       	ldi	r24, 0x00	; 0
    5270:	90 e0       	ldi	r25, 0x00	; 0
    5272:	a0 e8       	ldi	r26, 0x80	; 128
    5274:	bf e3       	ldi	r27, 0x3F	; 63
    5276:	8a 83       	std	Y+2, r24	; 0x02
    5278:	9b 83       	std	Y+3, r25	; 0x03
    527a:	ac 83       	std	Y+4, r26	; 0x04
    527c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    527e:	6a 81       	ldd	r22, Y+2	; 0x02
    5280:	7b 81       	ldd	r23, Y+3	; 0x03
    5282:	8c 81       	ldd	r24, Y+4	; 0x04
    5284:	9d 81       	ldd	r25, Y+5	; 0x05
    5286:	2b ea       	ldi	r18, 0xAB	; 171
    5288:	3a ea       	ldi	r19, 0xAA	; 170
    528a:	4a ea       	ldi	r20, 0xAA	; 170
    528c:	5e e3       	ldi	r21, 0x3E	; 62
    528e:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5292:	dc 01       	movw	r26, r24
    5294:	cb 01       	movw	r24, r22
    5296:	8e 83       	std	Y+6, r24	; 0x06
    5298:	9f 83       	std	Y+7, r25	; 0x07
    529a:	a8 87       	std	Y+8, r26	; 0x08
    529c:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    529e:	11 e0       	ldi	r17, 0x01	; 1
    52a0:	6e 81       	ldd	r22, Y+6	; 0x06
    52a2:	7f 81       	ldd	r23, Y+7	; 0x07
    52a4:	88 85       	ldd	r24, Y+8	; 0x08
    52a6:	99 85       	ldd	r25, Y+9	; 0x09
    52a8:	20 e0       	ldi	r18, 0x00	; 0
    52aa:	30 e0       	ldi	r19, 0x00	; 0
    52ac:	40 e8       	ldi	r20, 0x80	; 128
    52ae:	5f e3       	ldi	r21, 0x3F	; 63
    52b0:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    52b4:	88 23       	and	r24, r24
    52b6:	0c f0       	brlt	.+2      	; 0x52ba <chb_set_state+0xf0>
    52b8:	10 e0       	ldi	r17, 0x00	; 0
    52ba:	11 23       	and	r17, r17
    52bc:	19 f0       	breq	.+6      	; 0x52c4 <chb_set_state+0xfa>
		__ticks = 1;
    52be:	81 e0       	ldi	r24, 0x01	; 1
    52c0:	8a 87       	std	Y+10, r24	; 0x0a
    52c2:	a3 c0       	rjmp	.+326    	; 0x540a <chb_set_state+0x240>
	else if (__tmp > 255)
    52c4:	11 e0       	ldi	r17, 0x01	; 1
    52c6:	6e 81       	ldd	r22, Y+6	; 0x06
    52c8:	7f 81       	ldd	r23, Y+7	; 0x07
    52ca:	88 85       	ldd	r24, Y+8	; 0x08
    52cc:	99 85       	ldd	r25, Y+9	; 0x09
    52ce:	20 e0       	ldi	r18, 0x00	; 0
    52d0:	30 e0       	ldi	r19, 0x00	; 0
    52d2:	4f e7       	ldi	r20, 0x7F	; 127
    52d4:	53 e4       	ldi	r21, 0x43	; 67
    52d6:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    52da:	18 16       	cp	r1, r24
    52dc:	0c f0       	brlt	.+2      	; 0x52e0 <chb_set_state+0x116>
    52de:	10 e0       	ldi	r17, 0x00	; 0
    52e0:	11 23       	and	r17, r17
    52e2:	09 f4       	brne	.+2      	; 0x52e6 <chb_set_state+0x11c>
    52e4:	89 c0       	rjmp	.+274    	; 0x53f8 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    52e6:	6a 81       	ldd	r22, Y+2	; 0x02
    52e8:	7b 81       	ldd	r23, Y+3	; 0x03
    52ea:	8c 81       	ldd	r24, Y+4	; 0x04
    52ec:	9d 81       	ldd	r25, Y+5	; 0x05
    52ee:	20 e0       	ldi	r18, 0x00	; 0
    52f0:	30 e0       	ldi	r19, 0x00	; 0
    52f2:	4a e7       	ldi	r20, 0x7A	; 122
    52f4:	54 e4       	ldi	r21, 0x44	; 68
    52f6:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    52fa:	dc 01       	movw	r26, r24
    52fc:	cb 01       	movw	r24, r22
    52fe:	8b 87       	std	Y+11, r24	; 0x0b
    5300:	9c 87       	std	Y+12, r25	; 0x0c
    5302:	ad 87       	std	Y+13, r26	; 0x0d
    5304:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5306:	6b 85       	ldd	r22, Y+11	; 0x0b
    5308:	7c 85       	ldd	r23, Y+12	; 0x0c
    530a:	8d 85       	ldd	r24, Y+13	; 0x0d
    530c:	9e 85       	ldd	r25, Y+14	; 0x0e
    530e:	20 e0       	ldi	r18, 0x00	; 0
    5310:	30 e0       	ldi	r19, 0x00	; 0
    5312:	4a e7       	ldi	r20, 0x7A	; 122
    5314:	53 e4       	ldi	r21, 0x43	; 67
    5316:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    531a:	dc 01       	movw	r26, r24
    531c:	cb 01       	movw	r24, r22
    531e:	8f 87       	std	Y+15, r24	; 0x0f
    5320:	98 8b       	std	Y+16, r25	; 0x10
    5322:	a9 8b       	std	Y+17, r26	; 0x11
    5324:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    5326:	11 e0       	ldi	r17, 0x01	; 1
    5328:	6f 85       	ldd	r22, Y+15	; 0x0f
    532a:	78 89       	ldd	r23, Y+16	; 0x10
    532c:	89 89       	ldd	r24, Y+17	; 0x11
    532e:	9a 89       	ldd	r25, Y+18	; 0x12
    5330:	20 e0       	ldi	r18, 0x00	; 0
    5332:	30 e0       	ldi	r19, 0x00	; 0
    5334:	40 e8       	ldi	r20, 0x80	; 128
    5336:	5f e3       	ldi	r21, 0x3F	; 63
    5338:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    533c:	88 23       	and	r24, r24
    533e:	0c f0       	brlt	.+2      	; 0x5342 <chb_set_state+0x178>
    5340:	10 e0       	ldi	r17, 0x00	; 0
    5342:	11 23       	and	r17, r17
    5344:	29 f0       	breq	.+10     	; 0x5350 <chb_set_state+0x186>
		__ticks = 1;
    5346:	81 e0       	ldi	r24, 0x01	; 1
    5348:	90 e0       	ldi	r25, 0x00	; 0
    534a:	8b 8b       	std	Y+19, r24	; 0x13
    534c:	9c 8b       	std	Y+20, r25	; 0x14
    534e:	46 c0       	rjmp	.+140    	; 0x53dc <chb_set_state+0x212>
	else if (__tmp > 65535)
    5350:	11 e0       	ldi	r17, 0x01	; 1
    5352:	6f 85       	ldd	r22, Y+15	; 0x0f
    5354:	78 89       	ldd	r23, Y+16	; 0x10
    5356:	89 89       	ldd	r24, Y+17	; 0x11
    5358:	9a 89       	ldd	r25, Y+18	; 0x12
    535a:	20 e0       	ldi	r18, 0x00	; 0
    535c:	3f ef       	ldi	r19, 0xFF	; 255
    535e:	4f e7       	ldi	r20, 0x7F	; 127
    5360:	57 e4       	ldi	r21, 0x47	; 71
    5362:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    5366:	18 16       	cp	r1, r24
    5368:	0c f0       	brlt	.+2      	; 0x536c <chb_set_state+0x1a2>
    536a:	10 e0       	ldi	r17, 0x00	; 0
    536c:	11 23       	and	r17, r17
    536e:	61 f1       	breq	.+88     	; 0x53c8 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5370:	6b 85       	ldd	r22, Y+11	; 0x0b
    5372:	7c 85       	ldd	r23, Y+12	; 0x0c
    5374:	8d 85       	ldd	r24, Y+13	; 0x0d
    5376:	9e 85       	ldd	r25, Y+14	; 0x0e
    5378:	20 e0       	ldi	r18, 0x00	; 0
    537a:	30 e0       	ldi	r19, 0x00	; 0
    537c:	40 e2       	ldi	r20, 0x20	; 32
    537e:	51 e4       	ldi	r21, 0x41	; 65
    5380:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5384:	dc 01       	movw	r26, r24
    5386:	cb 01       	movw	r24, r22
    5388:	bc 01       	movw	r22, r24
    538a:	cd 01       	movw	r24, r26
    538c:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5390:	dc 01       	movw	r26, r24
    5392:	cb 01       	movw	r24, r22
    5394:	8b 8b       	std	Y+19, r24	; 0x13
    5396:	9c 8b       	std	Y+20, r25	; 0x14
    5398:	12 c0       	rjmp	.+36     	; 0x53be <chb_set_state+0x1f4>
    539a:	89 e1       	ldi	r24, 0x19	; 25
    539c:	90 e0       	ldi	r25, 0x00	; 0
    539e:	8d 8b       	std	Y+21, r24	; 0x15
    53a0:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    53a2:	8d 89       	ldd	r24, Y+21	; 0x15
    53a4:	9e 89       	ldd	r25, Y+22	; 0x16
    53a6:	8c 01       	movw	r16, r24
    53a8:	c8 01       	movw	r24, r16
    53aa:	01 97       	sbiw	r24, 0x01	; 1
    53ac:	f1 f7       	brne	.-4      	; 0x53aa <chb_set_state+0x1e0>
    53ae:	8c 01       	movw	r16, r24
    53b0:	0d 8b       	std	Y+21, r16	; 0x15
    53b2:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53b4:	8b 89       	ldd	r24, Y+19	; 0x13
    53b6:	9c 89       	ldd	r25, Y+20	; 0x14
    53b8:	01 97       	sbiw	r24, 0x01	; 1
    53ba:	8b 8b       	std	Y+19, r24	; 0x13
    53bc:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53be:	8b 89       	ldd	r24, Y+19	; 0x13
    53c0:	9c 89       	ldd	r25, Y+20	; 0x14
    53c2:	00 97       	sbiw	r24, 0x00	; 0
    53c4:	51 f7       	brne	.-44     	; 0x539a <chb_set_state+0x1d0>
    53c6:	29 c0       	rjmp	.+82     	; 0x541a <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53c8:	6f 85       	ldd	r22, Y+15	; 0x0f
    53ca:	78 89       	ldd	r23, Y+16	; 0x10
    53cc:	89 89       	ldd	r24, Y+17	; 0x11
    53ce:	9a 89       	ldd	r25, Y+18	; 0x12
    53d0:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    53d4:	dc 01       	movw	r26, r24
    53d6:	cb 01       	movw	r24, r22
    53d8:	8b 8b       	std	Y+19, r24	; 0x13
    53da:	9c 8b       	std	Y+20, r25	; 0x14
    53dc:	8b 89       	ldd	r24, Y+19	; 0x13
    53de:	9c 89       	ldd	r25, Y+20	; 0x14
    53e0:	8f 8b       	std	Y+23, r24	; 0x17
    53e2:	98 8f       	std	Y+24, r25	; 0x18
    53e4:	8f 89       	ldd	r24, Y+23	; 0x17
    53e6:	98 8d       	ldd	r25, Y+24	; 0x18
    53e8:	8c 01       	movw	r16, r24
    53ea:	f8 01       	movw	r30, r16
    53ec:	31 97       	sbiw	r30, 0x01	; 1
    53ee:	f1 f7       	brne	.-4      	; 0x53ec <chb_set_state+0x222>
    53f0:	8f 01       	movw	r16, r30
    53f2:	0f 8b       	std	Y+23, r16	; 0x17
    53f4:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    53f6:	24 c2       	rjmp	.+1096   	; 0x5840 <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    53f8:	6e 81       	ldd	r22, Y+6	; 0x06
    53fa:	7f 81       	ldd	r23, Y+7	; 0x07
    53fc:	88 85       	ldd	r24, Y+8	; 0x08
    53fe:	99 85       	ldd	r25, Y+9	; 0x09
    5400:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5404:	dc 01       	movw	r26, r24
    5406:	cb 01       	movw	r24, r22
    5408:	8a 87       	std	Y+10, r24	; 0x0a
    540a:	8a 85       	ldd	r24, Y+10	; 0x0a
    540c:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    540e:	89 8d       	ldd	r24, Y+25	; 0x19
    5410:	18 2f       	mov	r17, r24
    5412:	1a 95       	dec	r17
    5414:	f1 f7       	brne	.-4      	; 0x5412 <chb_set_state+0x248>
    5416:	19 8f       	std	Y+25, r17	; 0x19
    5418:	13 c2       	rjmp	.+1062   	; 0x5840 <chb_set_state+0x676>
    541a:	12 c2       	rjmp	.+1060   	; 0x5840 <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    541c:	89 81       	ldd	r24, Y+1	; 0x01
    541e:	86 31       	cpi	r24, 0x16	; 22
    5420:	09 f0       	breq	.+2      	; 0x5424 <chb_set_state+0x25a>
    5422:	0b c2       	rjmp	.+1046   	; 0x583a <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5424:	82 e0       	ldi	r24, 0x02	; 2
    5426:	69 e0       	ldi	r22, 0x09	; 9
    5428:	4f e1       	ldi	r20, 0x1F	; 31
    542a:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
    542e:	80 e0       	ldi	r24, 0x00	; 0
    5430:	90 e0       	ldi	r25, 0x00	; 0
    5432:	a0 e8       	ldi	r26, 0x80	; 128
    5434:	bf e3       	ldi	r27, 0x3F	; 63
    5436:	8a 8f       	std	Y+26, r24	; 0x1a
    5438:	9b 8f       	std	Y+27, r25	; 0x1b
    543a:	ac 8f       	std	Y+28, r26	; 0x1c
    543c:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    543e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5440:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5442:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5444:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5446:	2b ea       	ldi	r18, 0xAB	; 171
    5448:	3a ea       	ldi	r19, 0xAA	; 170
    544a:	4a ea       	ldi	r20, 0xAA	; 170
    544c:	5e e3       	ldi	r21, 0x3E	; 62
    544e:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5452:	dc 01       	movw	r26, r24
    5454:	cb 01       	movw	r24, r22
    5456:	8e 8f       	std	Y+30, r24	; 0x1e
    5458:	9f 8f       	std	Y+31, r25	; 0x1f
    545a:	a8 a3       	lds	r26, 0x58
    545c:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    545e:	11 e0       	ldi	r17, 0x01	; 1
    5460:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5462:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5464:	88 a1       	lds	r24, 0x48
    5466:	99 a1       	lds	r25, 0x49
    5468:	20 e0       	ldi	r18, 0x00	; 0
    546a:	30 e0       	ldi	r19, 0x00	; 0
    546c:	40 e8       	ldi	r20, 0x80	; 128
    546e:	5f e3       	ldi	r21, 0x3F	; 63
    5470:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    5474:	88 23       	and	r24, r24
    5476:	0c f0       	brlt	.+2      	; 0x547a <chb_set_state+0x2b0>
    5478:	10 e0       	ldi	r17, 0x00	; 0
    547a:	11 23       	and	r17, r17
    547c:	19 f0       	breq	.+6      	; 0x5484 <chb_set_state+0x2ba>
		__ticks = 1;
    547e:	81 e0       	ldi	r24, 0x01	; 1
    5480:	8a a3       	lds	r24, 0x5a
    5482:	a3 c0       	rjmp	.+326    	; 0x55ca <chb_set_state+0x400>
	else if (__tmp > 255)
    5484:	11 e0       	ldi	r17, 0x01	; 1
    5486:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5488:	7f 8d       	ldd	r23, Y+31	; 0x1f
    548a:	88 a1       	lds	r24, 0x48
    548c:	99 a1       	lds	r25, 0x49
    548e:	20 e0       	ldi	r18, 0x00	; 0
    5490:	30 e0       	ldi	r19, 0x00	; 0
    5492:	4f e7       	ldi	r20, 0x7F	; 127
    5494:	53 e4       	ldi	r21, 0x43	; 67
    5496:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    549a:	18 16       	cp	r1, r24
    549c:	0c f0       	brlt	.+2      	; 0x54a0 <chb_set_state+0x2d6>
    549e:	10 e0       	ldi	r17, 0x00	; 0
    54a0:	11 23       	and	r17, r17
    54a2:	09 f4       	brne	.+2      	; 0x54a6 <chb_set_state+0x2dc>
    54a4:	89 c0       	rjmp	.+274    	; 0x55b8 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    54a6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    54a8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    54aa:	8c 8d       	ldd	r24, Y+28	; 0x1c
    54ac:	9d 8d       	ldd	r25, Y+29	; 0x1d
    54ae:	20 e0       	ldi	r18, 0x00	; 0
    54b0:	30 e0       	ldi	r19, 0x00	; 0
    54b2:	4a e7       	ldi	r20, 0x7A	; 122
    54b4:	54 e4       	ldi	r21, 0x44	; 68
    54b6:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    54ba:	dc 01       	movw	r26, r24
    54bc:	cb 01       	movw	r24, r22
    54be:	8b a3       	lds	r24, 0x5b
    54c0:	9c a3       	lds	r25, 0x5c
    54c2:	ad a3       	lds	r26, 0x5d
    54c4:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    54c6:	6b a1       	lds	r22, 0x4b
    54c8:	7c a1       	lds	r23, 0x4c
    54ca:	8d a1       	lds	r24, 0x4d
    54cc:	9e a1       	lds	r25, 0x4e
    54ce:	20 e0       	ldi	r18, 0x00	; 0
    54d0:	30 e0       	ldi	r19, 0x00	; 0
    54d2:	4a e7       	ldi	r20, 0x7A	; 122
    54d4:	53 e4       	ldi	r21, 0x43	; 67
    54d6:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    54da:	dc 01       	movw	r26, r24
    54dc:	cb 01       	movw	r24, r22
    54de:	8f a3       	lds	r24, 0x5f
    54e0:	98 a7       	lds	r25, 0x78
    54e2:	a9 a7       	lds	r26, 0x79
    54e4:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    54e6:	11 e0       	ldi	r17, 0x01	; 1
    54e8:	6f a1       	lds	r22, 0x4f
    54ea:	78 a5       	lds	r23, 0x68
    54ec:	89 a5       	lds	r24, 0x69
    54ee:	9a a5       	lds	r25, 0x6a
    54f0:	20 e0       	ldi	r18, 0x00	; 0
    54f2:	30 e0       	ldi	r19, 0x00	; 0
    54f4:	40 e8       	ldi	r20, 0x80	; 128
    54f6:	5f e3       	ldi	r21, 0x3F	; 63
    54f8:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    54fc:	88 23       	and	r24, r24
    54fe:	0c f0       	brlt	.+2      	; 0x5502 <chb_set_state+0x338>
    5500:	10 e0       	ldi	r17, 0x00	; 0
    5502:	11 23       	and	r17, r17
    5504:	29 f0       	breq	.+10     	; 0x5510 <chb_set_state+0x346>
		__ticks = 1;
    5506:	81 e0       	ldi	r24, 0x01	; 1
    5508:	90 e0       	ldi	r25, 0x00	; 0
    550a:	8b a7       	lds	r24, 0x7b
    550c:	9c a7       	lds	r25, 0x7c
    550e:	46 c0       	rjmp	.+140    	; 0x559c <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    5510:	11 e0       	ldi	r17, 0x01	; 1
    5512:	6f a1       	lds	r22, 0x4f
    5514:	78 a5       	lds	r23, 0x68
    5516:	89 a5       	lds	r24, 0x69
    5518:	9a a5       	lds	r25, 0x6a
    551a:	20 e0       	ldi	r18, 0x00	; 0
    551c:	3f ef       	ldi	r19, 0xFF	; 255
    551e:	4f e7       	ldi	r20, 0x7F	; 127
    5520:	57 e4       	ldi	r21, 0x47	; 71
    5522:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    5526:	18 16       	cp	r1, r24
    5528:	0c f0       	brlt	.+2      	; 0x552c <chb_set_state+0x362>
    552a:	10 e0       	ldi	r17, 0x00	; 0
    552c:	11 23       	and	r17, r17
    552e:	61 f1       	breq	.+88     	; 0x5588 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5530:	6b a1       	lds	r22, 0x4b
    5532:	7c a1       	lds	r23, 0x4c
    5534:	8d a1       	lds	r24, 0x4d
    5536:	9e a1       	lds	r25, 0x4e
    5538:	20 e0       	ldi	r18, 0x00	; 0
    553a:	30 e0       	ldi	r19, 0x00	; 0
    553c:	40 e2       	ldi	r20, 0x20	; 32
    553e:	51 e4       	ldi	r21, 0x41	; 65
    5540:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5544:	dc 01       	movw	r26, r24
    5546:	cb 01       	movw	r24, r22
    5548:	bc 01       	movw	r22, r24
    554a:	cd 01       	movw	r24, r26
    554c:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5550:	dc 01       	movw	r26, r24
    5552:	cb 01       	movw	r24, r22
    5554:	8b a7       	lds	r24, 0x7b
    5556:	9c a7       	lds	r25, 0x7c
    5558:	12 c0       	rjmp	.+36     	; 0x557e <chb_set_state+0x3b4>
    555a:	89 e1       	ldi	r24, 0x19	; 25
    555c:	90 e0       	ldi	r25, 0x00	; 0
    555e:	8d a7       	lds	r24, 0x7d
    5560:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5562:	8d a5       	lds	r24, 0x6d
    5564:	9e a5       	lds	r25, 0x6e
    5566:	8c 01       	movw	r16, r24
    5568:	c8 01       	movw	r24, r16
    556a:	01 97       	sbiw	r24, 0x01	; 1
    556c:	f1 f7       	brne	.-4      	; 0x556a <chb_set_state+0x3a0>
    556e:	8c 01       	movw	r16, r24
    5570:	0d a7       	lds	r16, 0x7d
    5572:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5574:	8b a5       	lds	r24, 0x6b
    5576:	9c a5       	lds	r25, 0x6c
    5578:	01 97       	sbiw	r24, 0x01	; 1
    557a:	8b a7       	lds	r24, 0x7b
    557c:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    557e:	8b a5       	lds	r24, 0x6b
    5580:	9c a5       	lds	r25, 0x6c
    5582:	00 97       	sbiw	r24, 0x00	; 0
    5584:	51 f7       	brne	.-44     	; 0x555a <chb_set_state+0x390>
    5586:	29 c0       	rjmp	.+82     	; 0x55da <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5588:	6f a1       	lds	r22, 0x4f
    558a:	78 a5       	lds	r23, 0x68
    558c:	89 a5       	lds	r24, 0x69
    558e:	9a a5       	lds	r25, 0x6a
    5590:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5594:	dc 01       	movw	r26, r24
    5596:	cb 01       	movw	r24, r22
    5598:	8b a7       	lds	r24, 0x7b
    559a:	9c a7       	lds	r25, 0x7c
    559c:	8b a5       	lds	r24, 0x6b
    559e:	9c a5       	lds	r25, 0x6c
    55a0:	8f a7       	lds	r24, 0x7f
    55a2:	98 ab       	sts	0x58, r25
    55a4:	8f a5       	lds	r24, 0x6f
    55a6:	98 a9       	sts	0x48, r25
    55a8:	8c 01       	movw	r16, r24
    55aa:	f8 01       	movw	r30, r16
    55ac:	31 97       	sbiw	r30, 0x01	; 1
    55ae:	f1 f7       	brne	.-4      	; 0x55ac <chb_set_state+0x3e2>
    55b0:	8f 01       	movw	r16, r30
    55b2:	0f a7       	lds	r16, 0x7f
    55b4:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    55b6:	41 c1       	rjmp	.+642    	; 0x583a <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    55b8:	6e 8d       	ldd	r22, Y+30	; 0x1e
    55ba:	7f 8d       	ldd	r23, Y+31	; 0x1f
    55bc:	88 a1       	lds	r24, 0x48
    55be:	99 a1       	lds	r25, 0x49
    55c0:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    55c4:	dc 01       	movw	r26, r24
    55c6:	cb 01       	movw	r24, r22
    55c8:	8a a3       	lds	r24, 0x5a
    55ca:	8a a1       	lds	r24, 0x4a
    55cc:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55ce:	89 a9       	sts	0x49, r24
    55d0:	18 2f       	mov	r17, r24
    55d2:	1a 95       	dec	r17
    55d4:	f1 f7       	brne	.-4      	; 0x55d2 <chb_set_state+0x408>
    55d6:	19 ab       	sts	0x59, r17
    55d8:	30 c1       	rjmp	.+608    	; 0x583a <chb_set_state+0x670>
    55da:	2f c1       	rjmp	.+606    	; 0x583a <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    55dc:	89 81       	ldd	r24, Y+1	; 0x01
    55de:	89 31       	cpi	r24, 0x19	; 25
    55e0:	09 f0       	breq	.+2      	; 0x55e4 <chb_set_state+0x41a>
    55e2:	2d c1       	rjmp	.+602    	; 0x583e <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    55e4:	82 e0       	ldi	r24, 0x02	; 2
    55e6:	69 e0       	ldi	r22, 0x09	; 9
    55e8:	4f e1       	ldi	r20, 0x1F	; 31
    55ea:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
    55ee:	80 e0       	ldi	r24, 0x00	; 0
    55f0:	90 e0       	ldi	r25, 0x00	; 0
    55f2:	a0 e8       	ldi	r26, 0x80	; 128
    55f4:	bf e3       	ldi	r27, 0x3F	; 63
    55f6:	8a ab       	sts	0x5a, r24
    55f8:	9b ab       	sts	0x5b, r25
    55fa:	ac ab       	sts	0x5c, r26
    55fc:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    55fe:	6a a9       	sts	0x4a, r22
    5600:	7b a9       	sts	0x4b, r23
    5602:	8c a9       	sts	0x4c, r24
    5604:	9d a9       	sts	0x4d, r25
    5606:	2b ea       	ldi	r18, 0xAB	; 171
    5608:	3a ea       	ldi	r19, 0xAA	; 170
    560a:	4a ea       	ldi	r20, 0xAA	; 170
    560c:	5e e3       	ldi	r21, 0x3E	; 62
    560e:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5612:	dc 01       	movw	r26, r24
    5614:	cb 01       	movw	r24, r22
    5616:	8e ab       	sts	0x5e, r24
    5618:	9f ab       	sts	0x5f, r25
    561a:	a8 af       	sts	0x78, r26
    561c:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    561e:	11 e0       	ldi	r17, 0x01	; 1
    5620:	6e a9       	sts	0x4e, r22
    5622:	7f a9       	sts	0x4f, r23
    5624:	88 ad       	sts	0x68, r24
    5626:	99 ad       	sts	0x69, r25
    5628:	20 e0       	ldi	r18, 0x00	; 0
    562a:	30 e0       	ldi	r19, 0x00	; 0
    562c:	40 e8       	ldi	r20, 0x80	; 128
    562e:	5f e3       	ldi	r21, 0x3F	; 63
    5630:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    5634:	88 23       	and	r24, r24
    5636:	0c f0       	brlt	.+2      	; 0x563a <chb_set_state+0x470>
    5638:	10 e0       	ldi	r17, 0x00	; 0
    563a:	11 23       	and	r17, r17
    563c:	19 f0       	breq	.+6      	; 0x5644 <chb_set_state+0x47a>
		__ticks = 1;
    563e:	81 e0       	ldi	r24, 0x01	; 1
    5640:	8a af       	sts	0x7a, r24
    5642:	e6 c0       	rjmp	.+460    	; 0x5810 <chb_set_state+0x646>
	else if (__tmp > 255)
    5644:	11 e0       	ldi	r17, 0x01	; 1
    5646:	6e a9       	sts	0x4e, r22
    5648:	7f a9       	sts	0x4f, r23
    564a:	88 ad       	sts	0x68, r24
    564c:	99 ad       	sts	0x69, r25
    564e:	20 e0       	ldi	r18, 0x00	; 0
    5650:	30 e0       	ldi	r19, 0x00	; 0
    5652:	4f e7       	ldi	r20, 0x7F	; 127
    5654:	53 e4       	ldi	r21, 0x43	; 67
    5656:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    565a:	18 16       	cp	r1, r24
    565c:	0c f0       	brlt	.+2      	; 0x5660 <chb_set_state+0x496>
    565e:	10 e0       	ldi	r17, 0x00	; 0
    5660:	11 23       	and	r17, r17
    5662:	09 f4       	brne	.+2      	; 0x5666 <chb_set_state+0x49c>
    5664:	cc c0       	rjmp	.+408    	; 0x57fe <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5666:	6a a9       	sts	0x4a, r22
    5668:	7b a9       	sts	0x4b, r23
    566a:	8c a9       	sts	0x4c, r24
    566c:	9d a9       	sts	0x4d, r25
    566e:	20 e0       	ldi	r18, 0x00	; 0
    5670:	30 e0       	ldi	r19, 0x00	; 0
    5672:	4a e7       	ldi	r20, 0x7A	; 122
    5674:	54 e4       	ldi	r21, 0x44	; 68
    5676:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    567a:	dc 01       	movw	r26, r24
    567c:	cb 01       	movw	r24, r22
    567e:	8b af       	sts	0x7b, r24
    5680:	9c af       	sts	0x7c, r25
    5682:	ad af       	sts	0x7d, r26
    5684:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5686:	8e 01       	movw	r16, r28
    5688:	01 5c       	subi	r16, 0xC1	; 193
    568a:	1f 4f       	sbci	r17, 0xFF	; 255
    568c:	6b ad       	sts	0x6b, r22
    568e:	7c ad       	sts	0x6c, r23
    5690:	8d ad       	sts	0x6d, r24
    5692:	9e ad       	sts	0x6e, r25
    5694:	20 e0       	ldi	r18, 0x00	; 0
    5696:	30 e0       	ldi	r19, 0x00	; 0
    5698:	4a e7       	ldi	r20, 0x7A	; 122
    569a:	53 e4       	ldi	r21, 0x43	; 67
    569c:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    56a0:	dc 01       	movw	r26, r24
    56a2:	cb 01       	movw	r24, r22
    56a4:	f8 01       	movw	r30, r16
    56a6:	80 83       	st	Z, r24
    56a8:	91 83       	std	Z+1, r25	; 0x01
    56aa:	a2 83       	std	Z+2, r26	; 0x02
    56ac:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    56ae:	ce 01       	movw	r24, r28
    56b0:	cf 96       	adiw	r24, 0x3f	; 63
    56b2:	11 e0       	ldi	r17, 0x01	; 1
    56b4:	fc 01       	movw	r30, r24
    56b6:	60 81       	ld	r22, Z
    56b8:	71 81       	ldd	r23, Z+1	; 0x01
    56ba:	82 81       	ldd	r24, Z+2	; 0x02
    56bc:	93 81       	ldd	r25, Z+3	; 0x03
    56be:	20 e0       	ldi	r18, 0x00	; 0
    56c0:	30 e0       	ldi	r19, 0x00	; 0
    56c2:	40 e8       	ldi	r20, 0x80	; 128
    56c4:	5f e3       	ldi	r21, 0x3F	; 63
    56c6:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    56ca:	88 23       	and	r24, r24
    56cc:	0c f0       	brlt	.+2      	; 0x56d0 <chb_set_state+0x506>
    56ce:	10 e0       	ldi	r17, 0x00	; 0
    56d0:	11 23       	and	r17, r17
    56d2:	49 f0       	breq	.+18     	; 0x56e6 <chb_set_state+0x51c>
		__ticks = 1;
    56d4:	ce 01       	movw	r24, r28
    56d6:	8d 5b       	subi	r24, 0xBD	; 189
    56d8:	9f 4f       	sbci	r25, 0xFF	; 255
    56da:	21 e0       	ldi	r18, 0x01	; 1
    56dc:	30 e0       	ldi	r19, 0x00	; 0
    56de:	fc 01       	movw	r30, r24
    56e0:	20 83       	st	Z, r18
    56e2:	31 83       	std	Z+1, r19	; 0x01
    56e4:	6e c0       	rjmp	.+220    	; 0x57c2 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    56e6:	ce 01       	movw	r24, r28
    56e8:	cf 96       	adiw	r24, 0x3f	; 63
    56ea:	11 e0       	ldi	r17, 0x01	; 1
    56ec:	fc 01       	movw	r30, r24
    56ee:	60 81       	ld	r22, Z
    56f0:	71 81       	ldd	r23, Z+1	; 0x01
    56f2:	82 81       	ldd	r24, Z+2	; 0x02
    56f4:	93 81       	ldd	r25, Z+3	; 0x03
    56f6:	20 e0       	ldi	r18, 0x00	; 0
    56f8:	3f ef       	ldi	r19, 0xFF	; 255
    56fa:	4f e7       	ldi	r20, 0x7F	; 127
    56fc:	57 e4       	ldi	r21, 0x47	; 71
    56fe:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    5702:	18 16       	cp	r1, r24
    5704:	0c f0       	brlt	.+2      	; 0x5708 <chb_set_state+0x53e>
    5706:	10 e0       	ldi	r17, 0x00	; 0
    5708:	11 23       	and	r17, r17
    570a:	09 f4       	brne	.+2      	; 0x570e <chb_set_state+0x544>
    570c:	49 c0       	rjmp	.+146    	; 0x57a0 <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    570e:	6b ad       	sts	0x6b, r22
    5710:	7c ad       	sts	0x6c, r23
    5712:	8d ad       	sts	0x6d, r24
    5714:	9e ad       	sts	0x6e, r25
    5716:	20 e0       	ldi	r18, 0x00	; 0
    5718:	30 e0       	ldi	r19, 0x00	; 0
    571a:	40 e2       	ldi	r20, 0x20	; 32
    571c:	51 e4       	ldi	r21, 0x41	; 65
    571e:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5722:	dc 01       	movw	r26, r24
    5724:	cb 01       	movw	r24, r22
    5726:	8e 01       	movw	r16, r28
    5728:	0d 5b       	subi	r16, 0xBD	; 189
    572a:	1f 4f       	sbci	r17, 0xFF	; 255
    572c:	bc 01       	movw	r22, r24
    572e:	cd 01       	movw	r24, r26
    5730:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5734:	dc 01       	movw	r26, r24
    5736:	cb 01       	movw	r24, r22
    5738:	f8 01       	movw	r30, r16
    573a:	80 83       	st	Z, r24
    573c:	91 83       	std	Z+1, r25	; 0x01
    573e:	27 c0       	rjmp	.+78     	; 0x578e <chb_set_state+0x5c4>
    5740:	ce 01       	movw	r24, r28
    5742:	8b 5b       	subi	r24, 0xBB	; 187
    5744:	9f 4f       	sbci	r25, 0xFF	; 255
    5746:	29 e1       	ldi	r18, 0x19	; 25
    5748:	30 e0       	ldi	r19, 0x00	; 0
    574a:	fc 01       	movw	r30, r24
    574c:	20 83       	st	Z, r18
    574e:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5750:	ce 01       	movw	r24, r28
    5752:	8b 5b       	subi	r24, 0xBB	; 187
    5754:	9f 4f       	sbci	r25, 0xFF	; 255
    5756:	fc 01       	movw	r30, r24
    5758:	80 81       	ld	r24, Z
    575a:	91 81       	ldd	r25, Z+1	; 0x01
    575c:	8c 01       	movw	r16, r24
    575e:	c8 01       	movw	r24, r16
    5760:	01 97       	sbiw	r24, 0x01	; 1
    5762:	f1 f7       	brne	.-4      	; 0x5760 <chb_set_state+0x596>
    5764:	8c 01       	movw	r16, r24
    5766:	ce 01       	movw	r24, r28
    5768:	8b 5b       	subi	r24, 0xBB	; 187
    576a:	9f 4f       	sbci	r25, 0xFF	; 255
    576c:	fc 01       	movw	r30, r24
    576e:	00 83       	st	Z, r16
    5770:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5772:	ce 01       	movw	r24, r28
    5774:	8d 5b       	subi	r24, 0xBD	; 189
    5776:	9f 4f       	sbci	r25, 0xFF	; 255
    5778:	9e 01       	movw	r18, r28
    577a:	2d 5b       	subi	r18, 0xBD	; 189
    577c:	3f 4f       	sbci	r19, 0xFF	; 255
    577e:	f9 01       	movw	r30, r18
    5780:	20 81       	ld	r18, Z
    5782:	31 81       	ldd	r19, Z+1	; 0x01
    5784:	21 50       	subi	r18, 0x01	; 1
    5786:	30 40       	sbci	r19, 0x00	; 0
    5788:	fc 01       	movw	r30, r24
    578a:	20 83       	st	Z, r18
    578c:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    578e:	ce 01       	movw	r24, r28
    5790:	8d 5b       	subi	r24, 0xBD	; 189
    5792:	9f 4f       	sbci	r25, 0xFF	; 255
    5794:	fc 01       	movw	r30, r24
    5796:	80 81       	ld	r24, Z
    5798:	91 81       	ldd	r25, Z+1	; 0x01
    579a:	00 97       	sbiw	r24, 0x00	; 0
    579c:	89 f6       	brne	.-94     	; 0x5740 <chb_set_state+0x576>
    579e:	4c c0       	rjmp	.+152    	; 0x5838 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57a0:	8e 01       	movw	r16, r28
    57a2:	0d 5b       	subi	r16, 0xBD	; 189
    57a4:	1f 4f       	sbci	r17, 0xFF	; 255
    57a6:	ce 01       	movw	r24, r28
    57a8:	cf 96       	adiw	r24, 0x3f	; 63
    57aa:	fc 01       	movw	r30, r24
    57ac:	60 81       	ld	r22, Z
    57ae:	71 81       	ldd	r23, Z+1	; 0x01
    57b0:	82 81       	ldd	r24, Z+2	; 0x02
    57b2:	93 81       	ldd	r25, Z+3	; 0x03
    57b4:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    57b8:	dc 01       	movw	r26, r24
    57ba:	cb 01       	movw	r24, r22
    57bc:	f8 01       	movw	r30, r16
    57be:	80 83       	st	Z, r24
    57c0:	91 83       	std	Z+1, r25	; 0x01
    57c2:	ce 01       	movw	r24, r28
    57c4:	89 5b       	subi	r24, 0xB9	; 185
    57c6:	9f 4f       	sbci	r25, 0xFF	; 255
    57c8:	9e 01       	movw	r18, r28
    57ca:	2d 5b       	subi	r18, 0xBD	; 189
    57cc:	3f 4f       	sbci	r19, 0xFF	; 255
    57ce:	f9 01       	movw	r30, r18
    57d0:	20 81       	ld	r18, Z
    57d2:	31 81       	ldd	r19, Z+1	; 0x01
    57d4:	fc 01       	movw	r30, r24
    57d6:	20 83       	st	Z, r18
    57d8:	31 83       	std	Z+1, r19	; 0x01
    57da:	ce 01       	movw	r24, r28
    57dc:	89 5b       	subi	r24, 0xB9	; 185
    57de:	9f 4f       	sbci	r25, 0xFF	; 255
    57e0:	fc 01       	movw	r30, r24
    57e2:	80 81       	ld	r24, Z
    57e4:	91 81       	ldd	r25, Z+1	; 0x01
    57e6:	8c 01       	movw	r16, r24
    57e8:	c8 01       	movw	r24, r16
    57ea:	01 97       	sbiw	r24, 0x01	; 1
    57ec:	f1 f7       	brne	.-4      	; 0x57ea <chb_set_state+0x620>
    57ee:	8c 01       	movw	r16, r24
    57f0:	ce 01       	movw	r24, r28
    57f2:	89 5b       	subi	r24, 0xB9	; 185
    57f4:	9f 4f       	sbci	r25, 0xFF	; 255
    57f6:	fc 01       	movw	r30, r24
    57f8:	00 83       	st	Z, r16
    57fa:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    57fc:	20 c0       	rjmp	.+64     	; 0x583e <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    57fe:	6e a9       	sts	0x4e, r22
    5800:	7f a9       	sts	0x4f, r23
    5802:	88 ad       	sts	0x68, r24
    5804:	99 ad       	sts	0x69, r25
    5806:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    580a:	dc 01       	movw	r26, r24
    580c:	cb 01       	movw	r24, r22
    580e:	8a af       	sts	0x7a, r24
    5810:	ce 01       	movw	r24, r28
    5812:	87 5b       	subi	r24, 0xB7	; 183
    5814:	9f 4f       	sbci	r25, 0xFF	; 255
    5816:	2a ad       	sts	0x6a, r18
    5818:	fc 01       	movw	r30, r24
    581a:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    581c:	ce 01       	movw	r24, r28
    581e:	87 5b       	subi	r24, 0xB7	; 183
    5820:	9f 4f       	sbci	r25, 0xFF	; 255
    5822:	fc 01       	movw	r30, r24
    5824:	80 81       	ld	r24, Z
    5826:	18 2f       	mov	r17, r24
    5828:	1a 95       	dec	r17
    582a:	f1 f7       	brne	.-4      	; 0x5828 <chb_set_state+0x65e>
    582c:	ce 01       	movw	r24, r28
    582e:	87 5b       	subi	r24, 0xB7	; 183
    5830:	9f 4f       	sbci	r25, 0xFF	; 255
    5832:	fc 01       	movw	r30, r24
    5834:	10 83       	st	Z, r17
    5836:	03 c0       	rjmp	.+6      	; 0x583e <chb_set_state+0x674>
    5838:	02 c0       	rjmp	.+4      	; 0x583e <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    583a:	00 00       	nop
    583c:	01 c0       	rjmp	.+2      	; 0x5840 <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    583e:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    5840:	9e 01       	movw	r18, r28
    5842:	2e 59       	subi	r18, 0x9E	; 158
    5844:	3f 4f       	sbci	r19, 0xFF	; 255
    5846:	82 e0       	ldi	r24, 0x02	; 2
    5848:	f9 01       	movw	r30, r18
    584a:	60 81       	ld	r22, Z
    584c:	4f e1       	ldi	r20, 0x1F	; 31
    584e:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
    5852:	9e 01       	movw	r18, r28
    5854:	26 5b       	subi	r18, 0xB6	; 182
    5856:	3f 4f       	sbci	r19, 0xFF	; 255
    5858:	80 e0       	ldi	r24, 0x00	; 0
    585a:	90 e0       	ldi	r25, 0x00	; 0
    585c:	ac ed       	ldi	r26, 0xDC	; 220
    585e:	b2 e4       	ldi	r27, 0x42	; 66
    5860:	f9 01       	movw	r30, r18
    5862:	80 83       	st	Z, r24
    5864:	91 83       	std	Z+1, r25	; 0x01
    5866:	a2 83       	std	Z+2, r26	; 0x02
    5868:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    586a:	8e 01       	movw	r16, r28
    586c:	02 5b       	subi	r16, 0xB2	; 178
    586e:	1f 4f       	sbci	r17, 0xFF	; 255
    5870:	ce 01       	movw	r24, r28
    5872:	86 5b       	subi	r24, 0xB6	; 182
    5874:	9f 4f       	sbci	r25, 0xFF	; 255
    5876:	fc 01       	movw	r30, r24
    5878:	60 81       	ld	r22, Z
    587a:	71 81       	ldd	r23, Z+1	; 0x01
    587c:	82 81       	ldd	r24, Z+2	; 0x02
    587e:	93 81       	ldd	r25, Z+3	; 0x03
    5880:	2b ea       	ldi	r18, 0xAB	; 171
    5882:	3a ea       	ldi	r19, 0xAA	; 170
    5884:	4a ea       	ldi	r20, 0xAA	; 170
    5886:	5e e3       	ldi	r21, 0x3E	; 62
    5888:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    588c:	dc 01       	movw	r26, r24
    588e:	cb 01       	movw	r24, r22
    5890:	f8 01       	movw	r30, r16
    5892:	80 83       	st	Z, r24
    5894:	91 83       	std	Z+1, r25	; 0x01
    5896:	a2 83       	std	Z+2, r26	; 0x02
    5898:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    589a:	ce 01       	movw	r24, r28
    589c:	82 5b       	subi	r24, 0xB2	; 178
    589e:	9f 4f       	sbci	r25, 0xFF	; 255
    58a0:	11 e0       	ldi	r17, 0x01	; 1
    58a2:	fc 01       	movw	r30, r24
    58a4:	60 81       	ld	r22, Z
    58a6:	71 81       	ldd	r23, Z+1	; 0x01
    58a8:	82 81       	ldd	r24, Z+2	; 0x02
    58aa:	93 81       	ldd	r25, Z+3	; 0x03
    58ac:	20 e0       	ldi	r18, 0x00	; 0
    58ae:	30 e0       	ldi	r19, 0x00	; 0
    58b0:	40 e8       	ldi	r20, 0x80	; 128
    58b2:	5f e3       	ldi	r21, 0x3F	; 63
    58b4:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    58b8:	88 23       	and	r24, r24
    58ba:	0c f0       	brlt	.+2      	; 0x58be <chb_set_state+0x6f4>
    58bc:	10 e0       	ldi	r17, 0x00	; 0
    58be:	11 23       	and	r17, r17
    58c0:	39 f0       	breq	.+14     	; 0x58d0 <chb_set_state+0x706>
		__ticks = 1;
    58c2:	ce 01       	movw	r24, r28
    58c4:	8e 5a       	subi	r24, 0xAE	; 174
    58c6:	9f 4f       	sbci	r25, 0xFF	; 255
    58c8:	21 e0       	ldi	r18, 0x01	; 1
    58ca:	fc 01       	movw	r30, r24
    58cc:	20 83       	st	Z, r18
    58ce:	05 c1       	rjmp	.+522    	; 0x5ada <chb_set_state+0x910>
	else if (__tmp > 255)
    58d0:	ce 01       	movw	r24, r28
    58d2:	82 5b       	subi	r24, 0xB2	; 178
    58d4:	9f 4f       	sbci	r25, 0xFF	; 255
    58d6:	11 e0       	ldi	r17, 0x01	; 1
    58d8:	fc 01       	movw	r30, r24
    58da:	60 81       	ld	r22, Z
    58dc:	71 81       	ldd	r23, Z+1	; 0x01
    58de:	82 81       	ldd	r24, Z+2	; 0x02
    58e0:	93 81       	ldd	r25, Z+3	; 0x03
    58e2:	20 e0       	ldi	r18, 0x00	; 0
    58e4:	30 e0       	ldi	r19, 0x00	; 0
    58e6:	4f e7       	ldi	r20, 0x7F	; 127
    58e8:	53 e4       	ldi	r21, 0x43	; 67
    58ea:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    58ee:	18 16       	cp	r1, r24
    58f0:	0c f0       	brlt	.+2      	; 0x58f4 <chb_set_state+0x72a>
    58f2:	10 e0       	ldi	r17, 0x00	; 0
    58f4:	11 23       	and	r17, r17
    58f6:	09 f4       	brne	.+2      	; 0x58fa <chb_set_state+0x730>
    58f8:	df c0       	rjmp	.+446    	; 0x5ab8 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    58fa:	ce 01       	movw	r24, r28
    58fc:	86 5b       	subi	r24, 0xB6	; 182
    58fe:	9f 4f       	sbci	r25, 0xFF	; 255
    5900:	fc 01       	movw	r30, r24
    5902:	60 81       	ld	r22, Z
    5904:	71 81       	ldd	r23, Z+1	; 0x01
    5906:	82 81       	ldd	r24, Z+2	; 0x02
    5908:	93 81       	ldd	r25, Z+3	; 0x03
    590a:	20 e0       	ldi	r18, 0x00	; 0
    590c:	30 e0       	ldi	r19, 0x00	; 0
    590e:	4a e7       	ldi	r20, 0x7A	; 122
    5910:	54 e4       	ldi	r21, 0x44	; 68
    5912:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    5916:	dc 01       	movw	r26, r24
    5918:	cb 01       	movw	r24, r22
    591a:	9e 01       	movw	r18, r28
    591c:	2d 5a       	subi	r18, 0xAD	; 173
    591e:	3f 4f       	sbci	r19, 0xFF	; 255
    5920:	f9 01       	movw	r30, r18
    5922:	80 83       	st	Z, r24
    5924:	91 83       	std	Z+1, r25	; 0x01
    5926:	a2 83       	std	Z+2, r26	; 0x02
    5928:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    592a:	8e 01       	movw	r16, r28
    592c:	09 5a       	subi	r16, 0xA9	; 169
    592e:	1f 4f       	sbci	r17, 0xFF	; 255
    5930:	ce 01       	movw	r24, r28
    5932:	8d 5a       	subi	r24, 0xAD	; 173
    5934:	9f 4f       	sbci	r25, 0xFF	; 255
    5936:	fc 01       	movw	r30, r24
    5938:	60 81       	ld	r22, Z
    593a:	71 81       	ldd	r23, Z+1	; 0x01
    593c:	82 81       	ldd	r24, Z+2	; 0x02
    593e:	93 81       	ldd	r25, Z+3	; 0x03
    5940:	20 e0       	ldi	r18, 0x00	; 0
    5942:	30 e0       	ldi	r19, 0x00	; 0
    5944:	4a e7       	ldi	r20, 0x7A	; 122
    5946:	53 e4       	ldi	r21, 0x43	; 67
    5948:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    594c:	dc 01       	movw	r26, r24
    594e:	cb 01       	movw	r24, r22
    5950:	f8 01       	movw	r30, r16
    5952:	80 83       	st	Z, r24
    5954:	91 83       	std	Z+1, r25	; 0x01
    5956:	a2 83       	std	Z+2, r26	; 0x02
    5958:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    595a:	ce 01       	movw	r24, r28
    595c:	89 5a       	subi	r24, 0xA9	; 169
    595e:	9f 4f       	sbci	r25, 0xFF	; 255
    5960:	11 e0       	ldi	r17, 0x01	; 1
    5962:	fc 01       	movw	r30, r24
    5964:	60 81       	ld	r22, Z
    5966:	71 81       	ldd	r23, Z+1	; 0x01
    5968:	82 81       	ldd	r24, Z+2	; 0x02
    596a:	93 81       	ldd	r25, Z+3	; 0x03
    596c:	20 e0       	ldi	r18, 0x00	; 0
    596e:	30 e0       	ldi	r19, 0x00	; 0
    5970:	40 e8       	ldi	r20, 0x80	; 128
    5972:	5f e3       	ldi	r21, 0x3F	; 63
    5974:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    5978:	88 23       	and	r24, r24
    597a:	0c f0       	brlt	.+2      	; 0x597e <chb_set_state+0x7b4>
    597c:	10 e0       	ldi	r17, 0x00	; 0
    597e:	11 23       	and	r17, r17
    5980:	49 f0       	breq	.+18     	; 0x5994 <chb_set_state+0x7ca>
		__ticks = 1;
    5982:	ce 01       	movw	r24, r28
    5984:	85 5a       	subi	r24, 0xA5	; 165
    5986:	9f 4f       	sbci	r25, 0xFF	; 255
    5988:	21 e0       	ldi	r18, 0x01	; 1
    598a:	30 e0       	ldi	r19, 0x00	; 0
    598c:	fc 01       	movw	r30, r24
    598e:	20 83       	st	Z, r18
    5990:	31 83       	std	Z+1, r19	; 0x01
    5992:	74 c0       	rjmp	.+232    	; 0x5a7c <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    5994:	ce 01       	movw	r24, r28
    5996:	89 5a       	subi	r24, 0xA9	; 169
    5998:	9f 4f       	sbci	r25, 0xFF	; 255
    599a:	11 e0       	ldi	r17, 0x01	; 1
    599c:	fc 01       	movw	r30, r24
    599e:	60 81       	ld	r22, Z
    59a0:	71 81       	ldd	r23, Z+1	; 0x01
    59a2:	82 81       	ldd	r24, Z+2	; 0x02
    59a4:	93 81       	ldd	r25, Z+3	; 0x03
    59a6:	20 e0       	ldi	r18, 0x00	; 0
    59a8:	3f ef       	ldi	r19, 0xFF	; 255
    59aa:	4f e7       	ldi	r20, 0x7F	; 127
    59ac:	57 e4       	ldi	r21, 0x47	; 71
    59ae:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    59b2:	18 16       	cp	r1, r24
    59b4:	0c f0       	brlt	.+2      	; 0x59b8 <chb_set_state+0x7ee>
    59b6:	10 e0       	ldi	r17, 0x00	; 0
    59b8:	11 23       	and	r17, r17
    59ba:	09 f4       	brne	.+2      	; 0x59be <chb_set_state+0x7f4>
    59bc:	4d c0       	rjmp	.+154    	; 0x5a58 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    59be:	ce 01       	movw	r24, r28
    59c0:	8d 5a       	subi	r24, 0xAD	; 173
    59c2:	9f 4f       	sbci	r25, 0xFF	; 255
    59c4:	fc 01       	movw	r30, r24
    59c6:	60 81       	ld	r22, Z
    59c8:	71 81       	ldd	r23, Z+1	; 0x01
    59ca:	82 81       	ldd	r24, Z+2	; 0x02
    59cc:	93 81       	ldd	r25, Z+3	; 0x03
    59ce:	20 e0       	ldi	r18, 0x00	; 0
    59d0:	30 e0       	ldi	r19, 0x00	; 0
    59d2:	40 e2       	ldi	r20, 0x20	; 32
    59d4:	51 e4       	ldi	r21, 0x41	; 65
    59d6:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    59da:	dc 01       	movw	r26, r24
    59dc:	cb 01       	movw	r24, r22
    59de:	8e 01       	movw	r16, r28
    59e0:	05 5a       	subi	r16, 0xA5	; 165
    59e2:	1f 4f       	sbci	r17, 0xFF	; 255
    59e4:	bc 01       	movw	r22, r24
    59e6:	cd 01       	movw	r24, r26
    59e8:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    59ec:	dc 01       	movw	r26, r24
    59ee:	cb 01       	movw	r24, r22
    59f0:	f8 01       	movw	r30, r16
    59f2:	80 83       	st	Z, r24
    59f4:	91 83       	std	Z+1, r25	; 0x01
    59f6:	27 c0       	rjmp	.+78     	; 0x5a46 <chb_set_state+0x87c>
    59f8:	ce 01       	movw	r24, r28
    59fa:	83 5a       	subi	r24, 0xA3	; 163
    59fc:	9f 4f       	sbci	r25, 0xFF	; 255
    59fe:	29 e1       	ldi	r18, 0x19	; 25
    5a00:	30 e0       	ldi	r19, 0x00	; 0
    5a02:	fc 01       	movw	r30, r24
    5a04:	20 83       	st	Z, r18
    5a06:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5a08:	ce 01       	movw	r24, r28
    5a0a:	83 5a       	subi	r24, 0xA3	; 163
    5a0c:	9f 4f       	sbci	r25, 0xFF	; 255
    5a0e:	fc 01       	movw	r30, r24
    5a10:	80 81       	ld	r24, Z
    5a12:	91 81       	ldd	r25, Z+1	; 0x01
    5a14:	8c 01       	movw	r16, r24
    5a16:	c8 01       	movw	r24, r16
    5a18:	01 97       	sbiw	r24, 0x01	; 1
    5a1a:	f1 f7       	brne	.-4      	; 0x5a18 <chb_set_state+0x84e>
    5a1c:	8c 01       	movw	r16, r24
    5a1e:	ce 01       	movw	r24, r28
    5a20:	83 5a       	subi	r24, 0xA3	; 163
    5a22:	9f 4f       	sbci	r25, 0xFF	; 255
    5a24:	fc 01       	movw	r30, r24
    5a26:	00 83       	st	Z, r16
    5a28:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a2a:	ce 01       	movw	r24, r28
    5a2c:	85 5a       	subi	r24, 0xA5	; 165
    5a2e:	9f 4f       	sbci	r25, 0xFF	; 255
    5a30:	9e 01       	movw	r18, r28
    5a32:	25 5a       	subi	r18, 0xA5	; 165
    5a34:	3f 4f       	sbci	r19, 0xFF	; 255
    5a36:	f9 01       	movw	r30, r18
    5a38:	20 81       	ld	r18, Z
    5a3a:	31 81       	ldd	r19, Z+1	; 0x01
    5a3c:	21 50       	subi	r18, 0x01	; 1
    5a3e:	30 40       	sbci	r19, 0x00	; 0
    5a40:	fc 01       	movw	r30, r24
    5a42:	20 83       	st	Z, r18
    5a44:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a46:	ce 01       	movw	r24, r28
    5a48:	85 5a       	subi	r24, 0xA5	; 165
    5a4a:	9f 4f       	sbci	r25, 0xFF	; 255
    5a4c:	fc 01       	movw	r30, r24
    5a4e:	80 81       	ld	r24, Z
    5a50:	91 81       	ldd	r25, Z+1	; 0x01
    5a52:	00 97       	sbiw	r24, 0x00	; 0
    5a54:	89 f6       	brne	.-94     	; 0x59f8 <chb_set_state+0x82e>
    5a56:	58 c0       	rjmp	.+176    	; 0x5b08 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a58:	8e 01       	movw	r16, r28
    5a5a:	05 5a       	subi	r16, 0xA5	; 165
    5a5c:	1f 4f       	sbci	r17, 0xFF	; 255
    5a5e:	ce 01       	movw	r24, r28
    5a60:	89 5a       	subi	r24, 0xA9	; 169
    5a62:	9f 4f       	sbci	r25, 0xFF	; 255
    5a64:	fc 01       	movw	r30, r24
    5a66:	60 81       	ld	r22, Z
    5a68:	71 81       	ldd	r23, Z+1	; 0x01
    5a6a:	82 81       	ldd	r24, Z+2	; 0x02
    5a6c:	93 81       	ldd	r25, Z+3	; 0x03
    5a6e:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5a72:	dc 01       	movw	r26, r24
    5a74:	cb 01       	movw	r24, r22
    5a76:	f8 01       	movw	r30, r16
    5a78:	80 83       	st	Z, r24
    5a7a:	91 83       	std	Z+1, r25	; 0x01
    5a7c:	ce 01       	movw	r24, r28
    5a7e:	81 5a       	subi	r24, 0xA1	; 161
    5a80:	9f 4f       	sbci	r25, 0xFF	; 255
    5a82:	9e 01       	movw	r18, r28
    5a84:	25 5a       	subi	r18, 0xA5	; 165
    5a86:	3f 4f       	sbci	r19, 0xFF	; 255
    5a88:	f9 01       	movw	r30, r18
    5a8a:	20 81       	ld	r18, Z
    5a8c:	31 81       	ldd	r19, Z+1	; 0x01
    5a8e:	fc 01       	movw	r30, r24
    5a90:	20 83       	st	Z, r18
    5a92:	31 83       	std	Z+1, r19	; 0x01
    5a94:	ce 01       	movw	r24, r28
    5a96:	81 5a       	subi	r24, 0xA1	; 161
    5a98:	9f 4f       	sbci	r25, 0xFF	; 255
    5a9a:	fc 01       	movw	r30, r24
    5a9c:	80 81       	ld	r24, Z
    5a9e:	91 81       	ldd	r25, Z+1	; 0x01
    5aa0:	8c 01       	movw	r16, r24
    5aa2:	c8 01       	movw	r24, r16
    5aa4:	01 97       	sbiw	r24, 0x01	; 1
    5aa6:	f1 f7       	brne	.-4      	; 0x5aa4 <chb_set_state+0x8da>
    5aa8:	8c 01       	movw	r16, r24
    5aaa:	ce 01       	movw	r24, r28
    5aac:	81 5a       	subi	r24, 0xA1	; 161
    5aae:	9f 4f       	sbci	r25, 0xFF	; 255
    5ab0:	fc 01       	movw	r30, r24
    5ab2:	00 83       	st	Z, r16
    5ab4:	11 83       	std	Z+1, r17	; 0x01
    5ab6:	28 c0       	rjmp	.+80     	; 0x5b08 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5ab8:	8e 01       	movw	r16, r28
    5aba:	0e 5a       	subi	r16, 0xAE	; 174
    5abc:	1f 4f       	sbci	r17, 0xFF	; 255
    5abe:	ce 01       	movw	r24, r28
    5ac0:	82 5b       	subi	r24, 0xB2	; 178
    5ac2:	9f 4f       	sbci	r25, 0xFF	; 255
    5ac4:	fc 01       	movw	r30, r24
    5ac6:	60 81       	ld	r22, Z
    5ac8:	71 81       	ldd	r23, Z+1	; 0x01
    5aca:	82 81       	ldd	r24, Z+2	; 0x02
    5acc:	93 81       	ldd	r25, Z+3	; 0x03
    5ace:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5ad2:	dc 01       	movw	r26, r24
    5ad4:	cb 01       	movw	r24, r22
    5ad6:	f8 01       	movw	r30, r16
    5ad8:	80 83       	st	Z, r24
    5ada:	ce 01       	movw	r24, r28
    5adc:	8f 59       	subi	r24, 0x9F	; 159
    5ade:	9f 4f       	sbci	r25, 0xFF	; 255
    5ae0:	9e 01       	movw	r18, r28
    5ae2:	2e 5a       	subi	r18, 0xAE	; 174
    5ae4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ae6:	f9 01       	movw	r30, r18
    5ae8:	20 81       	ld	r18, Z
    5aea:	fc 01       	movw	r30, r24
    5aec:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5aee:	ce 01       	movw	r24, r28
    5af0:	8f 59       	subi	r24, 0x9F	; 159
    5af2:	9f 4f       	sbci	r25, 0xFF	; 255
    5af4:	fc 01       	movw	r30, r24
    5af6:	80 81       	ld	r24, Z
    5af8:	18 2f       	mov	r17, r24
    5afa:	1a 95       	dec	r17
    5afc:	f1 f7       	brne	.-4      	; 0x5afa <chb_set_state+0x930>
    5afe:	ce 01       	movw	r24, r28
    5b00:	8f 59       	subi	r24, 0x9F	; 159
    5b02:	9f 4f       	sbci	r25, 0xFF	; 255
    5b04:	fc 01       	movw	r30, r24
    5b06:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5b08:	0e 94 7e 23 	call	0x46fc	; 0x46fc <chb_get_state>
    5b0c:	28 2f       	mov	r18, r24
    5b0e:	ce 01       	movw	r24, r28
    5b10:	8e 59       	subi	r24, 0x9E	; 158
    5b12:	9f 4f       	sbci	r25, 0xFF	; 255
    5b14:	fc 01       	movw	r30, r24
    5b16:	80 81       	ld	r24, Z
    5b18:	28 17       	cp	r18, r24
    5b1a:	11 f4       	brne	.+4      	; 0x5b20 <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5b1c:	80 e4       	ldi	r24, 0x40	; 64
    5b1e:	01 c0       	rjmp	.+2      	; 0x5b22 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    5b20:	83 e4       	ldi	r24, 0x43	; 67
}
    5b22:	ce 59       	subi	r28, 0x9E	; 158
    5b24:	df 4f       	sbci	r29, 0xFF	; 255
    5b26:	cd bf       	out	0x3d, r28	; 61
    5b28:	de bf       	out	0x3e, r29	; 62
    5b2a:	df 91       	pop	r29
    5b2c:	cf 91       	pop	r28
    5b2e:	1f 91       	pop	r17
    5b30:	0f 91       	pop	r16
    5b32:	08 95       	ret

00005b34 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5b34:	cf 93       	push	r28
    5b36:	df 93       	push	r29
    5b38:	0f 92       	push	r0
    5b3a:	0f 92       	push	r0
    5b3c:	cd b7       	in	r28, 0x3d	; 61
    5b3e:	de b7       	in	r29, 0x3e	; 62
    5b40:	89 83       	std	Y+1, r24	; 0x01
    5b42:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5b44:	29 81       	ldd	r18, Y+1	; 0x01
    5b46:	3a 81       	ldd	r19, Y+2	; 0x02
    5b48:	80 e0       	ldi	r24, 0x00	; 0
    5b4a:	90 e0       	ldi	r25, 0x00	; 0
    5b4c:	b9 01       	movw	r22, r18
    5b4e:	48 e0       	ldi	r20, 0x08	; 8
    5b50:	50 e0       	ldi	r21, 0x00	; 0
    5b52:	0e 94 b9 31 	call	0x6372	; 0x6372 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5b56:	29 81       	ldd	r18, Y+1	; 0x01
    5b58:	3a 81       	ldd	r19, Y+2	; 0x02
    5b5a:	84 e2       	ldi	r24, 0x24	; 36
    5b5c:	b9 01       	movw	r22, r18
    5b5e:	0e 94 3f 26 	call	0x4c7e	; 0x4c7e <chb_reg_write64>
}
    5b62:	0f 90       	pop	r0
    5b64:	0f 90       	pop	r0
    5b66:	df 91       	pop	r29
    5b68:	cf 91       	pop	r28
    5b6a:	08 95       	ret

00005b6c <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5b6c:	cf 93       	push	r28
    5b6e:	df 93       	push	r29
    5b70:	0f 92       	push	r0
    5b72:	0f 92       	push	r0
    5b74:	cd b7       	in	r28, 0x3d	; 61
    5b76:	de b7       	in	r29, 0x3e	; 62
    5b78:	89 83       	std	Y+1, r24	; 0x01
    5b7a:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5b7c:	29 81       	ldd	r18, Y+1	; 0x01
    5b7e:	3a 81       	ldd	r19, Y+2	; 0x02
    5b80:	80 e0       	ldi	r24, 0x00	; 0
    5b82:	90 e0       	ldi	r25, 0x00	; 0
    5b84:	b9 01       	movw	r22, r18
    5b86:	48 e0       	ldi	r20, 0x08	; 8
    5b88:	50 e0       	ldi	r21, 0x00	; 0
    5b8a:	0e 94 f5 31 	call	0x63ea	; 0x63ea <chb_eeprom_read>
}
    5b8e:	0f 90       	pop	r0
    5b90:	0f 90       	pop	r0
    5b92:	df 91       	pop	r29
    5b94:	cf 91       	pop	r28
    5b96:	08 95       	ret

00005b98 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5b98:	cf 93       	push	r28
    5b9a:	df 93       	push	r29
    5b9c:	00 d0       	rcall	.+0      	; 0x5b9e <chb_set_short_addr+0x6>
    5b9e:	00 d0       	rcall	.+0      	; 0x5ba0 <chb_set_short_addr+0x8>
    5ba0:	cd b7       	in	r28, 0x3d	; 61
    5ba2:	de b7       	in	r29, 0x3e	; 62
    5ba4:	8d 83       	std	Y+5, r24	; 0x05
    5ba6:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5ba8:	ce 01       	movw	r24, r28
    5baa:	05 96       	adiw	r24, 0x05	; 5
    5bac:	89 83       	std	Y+1, r24	; 0x01
    5bae:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    5bb0:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <chb_get_pcb>
    5bb4:	8b 83       	std	Y+3, r24	; 0x03
    5bb6:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5bb8:	29 81       	ldd	r18, Y+1	; 0x01
    5bba:	3a 81       	ldd	r19, Y+2	; 0x02
    5bbc:	89 e0       	ldi	r24, 0x09	; 9
    5bbe:	90 e0       	ldi	r25, 0x00	; 0
    5bc0:	b9 01       	movw	r22, r18
    5bc2:	42 e0       	ldi	r20, 0x02	; 2
    5bc4:	50 e0       	ldi	r21, 0x00	; 0
    5bc6:	0e 94 b9 31 	call	0x6372	; 0x6372 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    5bca:	2d 81       	ldd	r18, Y+5	; 0x05
    5bcc:	3e 81       	ldd	r19, Y+6	; 0x06
    5bce:	80 e2       	ldi	r24, 0x20	; 32
    5bd0:	b9 01       	movw	r22, r18
    5bd2:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <chb_reg_write16>
    pcb->src_addr = addr;
    5bd6:	2d 81       	ldd	r18, Y+5	; 0x05
    5bd8:	3e 81       	ldd	r19, Y+6	; 0x06
    5bda:	8b 81       	ldd	r24, Y+3	; 0x03
    5bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    5bde:	fc 01       	movw	r30, r24
    5be0:	20 83       	st	Z, r18
    5be2:	31 83       	std	Z+1, r19	; 0x01
}
    5be4:	26 96       	adiw	r28, 0x06	; 6
    5be6:	cd bf       	out	0x3d, r28	; 61
    5be8:	de bf       	out	0x3e, r29	; 62
    5bea:	df 91       	pop	r29
    5bec:	cf 91       	pop	r28
    5bee:	08 95       	ret

00005bf0 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    5bf0:	cf 93       	push	r28
    5bf2:	df 93       	push	r29
    5bf4:	0f 92       	push	r0
    5bf6:	0f 92       	push	r0
    5bf8:	cd b7       	in	r28, 0x3d	; 61
    5bfa:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    5bfc:	89 e0       	ldi	r24, 0x09	; 9
    5bfe:	90 e0       	ldi	r25, 0x00	; 0
    5c00:	9e 01       	movw	r18, r28
    5c02:	2f 5f       	subi	r18, 0xFF	; 255
    5c04:	3f 4f       	sbci	r19, 0xFF	; 255
    5c06:	b9 01       	movw	r22, r18
    5c08:	42 e0       	ldi	r20, 0x02	; 2
    5c0a:	50 e0       	ldi	r21, 0x00	; 0
    5c0c:	0e 94 f5 31 	call	0x63ea	; 0x63ea <chb_eeprom_read>
    return *(U16 *)addr;
    5c10:	ce 01       	movw	r24, r28
    5c12:	01 96       	adiw	r24, 0x01	; 1
    5c14:	fc 01       	movw	r30, r24
    5c16:	80 81       	ld	r24, Z
    5c18:	91 81       	ldd	r25, Z+1	; 0x01
}
    5c1a:	0f 90       	pop	r0
    5c1c:	0f 90       	pop	r0
    5c1e:	df 91       	pop	r29
    5c20:	cf 91       	pop	r28
    5c22:	08 95       	ret

00005c24 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5c24:	cf 93       	push	r28
    5c26:	df 93       	push	r29
    5c28:	cd b7       	in	r28, 0x3d	; 61
    5c2a:	de b7       	in	r29, 0x3e	; 62
    5c2c:	28 97       	sbiw	r28, 0x08	; 8
    5c2e:	cd bf       	out	0x3d, r28	; 61
    5c30:	de bf       	out	0x3e, r29	; 62
    5c32:	8c 83       	std	Y+4, r24	; 0x04
    5c34:	9d 83       	std	Y+5, r25	; 0x05
    5c36:	6e 83       	std	Y+6, r22	; 0x06
    5c38:	7f 83       	std	Y+7, r23	; 0x07
    5c3a:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5c3c:	0e 94 7e 23 	call	0x46fc	; 0x46fc <chb_get_state>
    5c40:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5c42:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <chb_get_pcb>
    5c46:	8a 83       	std	Y+2, r24	; 0x02
    5c48:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5c4a:	89 81       	ldd	r24, Y+1	; 0x01
    5c4c:	82 30       	cpi	r24, 0x02	; 2
    5c4e:	19 f0       	breq	.+6      	; 0x5c56 <chb_tx+0x32>
    5c50:	89 81       	ldd	r24, Y+1	; 0x01
    5c52:	82 31       	cpi	r24, 0x12	; 18
    5c54:	11 f4       	brne	.+4      	; 0x5c5a <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5c56:	84 e4       	ldi	r24, 0x44	; 68
    5c58:	23 c0       	rjmp	.+70     	; 0x5ca0 <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5c5a:	88 e0       	ldi	r24, 0x08	; 8
    5c5c:	0e 94 e5 28 	call	0x51ca	; 0x51ca <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    5c60:	89 e1       	ldi	r24, 0x19	; 25
    5c62:	0e 94 e5 28 	call	0x51ca	; 0x51ca <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5c66:	8c 81       	ldd	r24, Y+4	; 0x04
    5c68:	9d 81       	ldd	r25, Y+5	; 0x05
    5c6a:	2e 81       	ldd	r18, Y+6	; 0x06
    5c6c:	3f 81       	ldd	r19, Y+7	; 0x07
    5c6e:	6a e0       	ldi	r22, 0x0A	; 10
    5c70:	a9 01       	movw	r20, r18
    5c72:	28 85       	ldd	r18, Y+8	; 0x08
    5c74:	0e 94 8c 26 	call	0x4d18	; 0x4d18 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5c78:	82 e0       	ldi	r24, 0x02	; 2
    5c7a:	62 e0       	ldi	r22, 0x02	; 2
    5c7c:	4f e1       	ldi	r20, 0x1F	; 31
    5c7e:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>

    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
    5c82:	00 00       	nop
    5c84:	8a 81       	ldd	r24, Y+2	; 0x02
    5c86:	9b 81       	ldd	r25, Y+3	; 0x03
    5c88:	fc 01       	movw	r30, r24
    5c8a:	94 81       	ldd	r25, Z+4	; 0x04
    5c8c:	81 e0       	ldi	r24, 0x01	; 1
    5c8e:	89 27       	eor	r24, r25
    5c90:	88 23       	and	r24, r24
    5c92:	c1 f7       	brne	.-16     	; 0x5c84 <chb_tx+0x60>
    pcb->tx_end = false;
    5c94:	8a 81       	ldd	r24, Y+2	; 0x02
    5c96:	9b 81       	ldd	r25, Y+3	; 0x03
    5c98:	fc 01       	movw	r30, r24
    5c9a:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5c9c:	0e 94 89 23 	call	0x4712	; 0x4712 <chb_get_status>
}
    5ca0:	28 96       	adiw	r28, 0x08	; 8
    5ca2:	cd bf       	out	0x3d, r28	; 61
    5ca4:	de bf       	out	0x3e, r29	; 62
    5ca6:	df 91       	pop	r29
    5ca8:	cf 91       	pop	r28
    5caa:	08 95       	ret

00005cac <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5cac:	0f 93       	push	r16
    5cae:	1f 93       	push	r17
    5cb0:	cf 93       	push	r28
    5cb2:	df 93       	push	r29
    5cb4:	cd b7       	in	r28, 0x3d	; 61
    5cb6:	de b7       	in	r29, 0x3e	; 62
    5cb8:	69 97       	sbiw	r28, 0x19	; 25
    5cba:	cd bf       	out	0x3d, r28	; 61
    5cbc:	de bf       	out	0x3e, r29	; 62
    5cbe:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    5cc0:	89 8d       	ldd	r24, Y+25	; 0x19
    5cc2:	88 23       	and	r24, r24
    5cc4:	69 f0       	breq	.+26     	; 0x5ce0 <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5cc6:	88 e0       	ldi	r24, 0x08	; 8
    5cc8:	0e 94 e5 28 	call	0x51ca	; 0x51ca <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5ccc:	84 e6       	ldi	r24, 0x64	; 100
    5cce:	96 e0       	ldi	r25, 0x06	; 6
    5cd0:	24 e6       	ldi	r18, 0x64	; 100
    5cd2:	36 e0       	ldi	r19, 0x06	; 6
    5cd4:	f9 01       	movw	r30, r18
    5cd6:	20 81       	ld	r18, Z
    5cd8:	22 60       	ori	r18, 0x02	; 2
    5cda:	fc 01       	movw	r30, r24
    5cdc:	20 83       	st	Z, r18
    5cde:	e1 c0       	rjmp	.+450    	; 0x5ea2 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    5ce0:	84 e6       	ldi	r24, 0x64	; 100
    5ce2:	96 e0       	ldi	r25, 0x06	; 6
    5ce4:	24 e6       	ldi	r18, 0x64	; 100
    5ce6:	36 e0       	ldi	r19, 0x06	; 6
    5ce8:	f9 01       	movw	r30, r18
    5cea:	20 81       	ld	r18, Z
    5cec:	2d 7f       	andi	r18, 0xFD	; 253
    5cee:	fc 01       	movw	r30, r24
    5cf0:	20 83       	st	Z, r18
    5cf2:	80 e0       	ldi	r24, 0x00	; 0
    5cf4:	90 e0       	ldi	r25, 0x00	; 0
    5cf6:	a0 e7       	ldi	r26, 0x70	; 112
    5cf8:	b3 e4       	ldi	r27, 0x43	; 67
    5cfa:	89 83       	std	Y+1, r24	; 0x01
    5cfc:	9a 83       	std	Y+2, r25	; 0x02
    5cfe:	ab 83       	std	Y+3, r26	; 0x03
    5d00:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5d02:	69 81       	ldd	r22, Y+1	; 0x01
    5d04:	7a 81       	ldd	r23, Y+2	; 0x02
    5d06:	8b 81       	ldd	r24, Y+3	; 0x03
    5d08:	9c 81       	ldd	r25, Y+4	; 0x04
    5d0a:	2b ea       	ldi	r18, 0xAB	; 171
    5d0c:	3a ea       	ldi	r19, 0xAA	; 170
    5d0e:	4a ea       	ldi	r20, 0xAA	; 170
    5d10:	5e e3       	ldi	r21, 0x3E	; 62
    5d12:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5d16:	dc 01       	movw	r26, r24
    5d18:	cb 01       	movw	r24, r22
    5d1a:	8d 83       	std	Y+5, r24	; 0x05
    5d1c:	9e 83       	std	Y+6, r25	; 0x06
    5d1e:	af 83       	std	Y+7, r26	; 0x07
    5d20:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5d22:	11 e0       	ldi	r17, 0x01	; 1
    5d24:	6d 81       	ldd	r22, Y+5	; 0x05
    5d26:	7e 81       	ldd	r23, Y+6	; 0x06
    5d28:	8f 81       	ldd	r24, Y+7	; 0x07
    5d2a:	98 85       	ldd	r25, Y+8	; 0x08
    5d2c:	20 e0       	ldi	r18, 0x00	; 0
    5d2e:	30 e0       	ldi	r19, 0x00	; 0
    5d30:	40 e8       	ldi	r20, 0x80	; 128
    5d32:	5f e3       	ldi	r21, 0x3F	; 63
    5d34:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    5d38:	88 23       	and	r24, r24
    5d3a:	0c f0       	brlt	.+2      	; 0x5d3e <chb_sleep+0x92>
    5d3c:	10 e0       	ldi	r17, 0x00	; 0
    5d3e:	11 23       	and	r17, r17
    5d40:	19 f0       	breq	.+6      	; 0x5d48 <chb_sleep+0x9c>
		__ticks = 1;
    5d42:	81 e0       	ldi	r24, 0x01	; 1
    5d44:	89 87       	std	Y+9, r24	; 0x09
    5d46:	a3 c0       	rjmp	.+326    	; 0x5e8e <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5d48:	11 e0       	ldi	r17, 0x01	; 1
    5d4a:	6d 81       	ldd	r22, Y+5	; 0x05
    5d4c:	7e 81       	ldd	r23, Y+6	; 0x06
    5d4e:	8f 81       	ldd	r24, Y+7	; 0x07
    5d50:	98 85       	ldd	r25, Y+8	; 0x08
    5d52:	20 e0       	ldi	r18, 0x00	; 0
    5d54:	30 e0       	ldi	r19, 0x00	; 0
    5d56:	4f e7       	ldi	r20, 0x7F	; 127
    5d58:	53 e4       	ldi	r21, 0x43	; 67
    5d5a:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    5d5e:	18 16       	cp	r1, r24
    5d60:	0c f0       	brlt	.+2      	; 0x5d64 <chb_sleep+0xb8>
    5d62:	10 e0       	ldi	r17, 0x00	; 0
    5d64:	11 23       	and	r17, r17
    5d66:	09 f4       	brne	.+2      	; 0x5d6a <chb_sleep+0xbe>
    5d68:	89 c0       	rjmp	.+274    	; 0x5e7c <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5d6a:	69 81       	ldd	r22, Y+1	; 0x01
    5d6c:	7a 81       	ldd	r23, Y+2	; 0x02
    5d6e:	8b 81       	ldd	r24, Y+3	; 0x03
    5d70:	9c 81       	ldd	r25, Y+4	; 0x04
    5d72:	20 e0       	ldi	r18, 0x00	; 0
    5d74:	30 e0       	ldi	r19, 0x00	; 0
    5d76:	4a e7       	ldi	r20, 0x7A	; 122
    5d78:	54 e4       	ldi	r21, 0x44	; 68
    5d7a:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    5d7e:	dc 01       	movw	r26, r24
    5d80:	cb 01       	movw	r24, r22
    5d82:	8a 87       	std	Y+10, r24	; 0x0a
    5d84:	9b 87       	std	Y+11, r25	; 0x0b
    5d86:	ac 87       	std	Y+12, r26	; 0x0c
    5d88:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5d8a:	6a 85       	ldd	r22, Y+10	; 0x0a
    5d8c:	7b 85       	ldd	r23, Y+11	; 0x0b
    5d8e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d90:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d92:	20 e0       	ldi	r18, 0x00	; 0
    5d94:	30 e0       	ldi	r19, 0x00	; 0
    5d96:	4a e7       	ldi	r20, 0x7A	; 122
    5d98:	53 e4       	ldi	r21, 0x43	; 67
    5d9a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5d9e:	dc 01       	movw	r26, r24
    5da0:	cb 01       	movw	r24, r22
    5da2:	8e 87       	std	Y+14, r24	; 0x0e
    5da4:	9f 87       	std	Y+15, r25	; 0x0f
    5da6:	a8 8b       	std	Y+16, r26	; 0x10
    5da8:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5daa:	11 e0       	ldi	r17, 0x01	; 1
    5dac:	6e 85       	ldd	r22, Y+14	; 0x0e
    5dae:	7f 85       	ldd	r23, Y+15	; 0x0f
    5db0:	88 89       	ldd	r24, Y+16	; 0x10
    5db2:	99 89       	ldd	r25, Y+17	; 0x11
    5db4:	20 e0       	ldi	r18, 0x00	; 0
    5db6:	30 e0       	ldi	r19, 0x00	; 0
    5db8:	40 e8       	ldi	r20, 0x80	; 128
    5dba:	5f e3       	ldi	r21, 0x3F	; 63
    5dbc:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    5dc0:	88 23       	and	r24, r24
    5dc2:	0c f0       	brlt	.+2      	; 0x5dc6 <chb_sleep+0x11a>
    5dc4:	10 e0       	ldi	r17, 0x00	; 0
    5dc6:	11 23       	and	r17, r17
    5dc8:	29 f0       	breq	.+10     	; 0x5dd4 <chb_sleep+0x128>
		__ticks = 1;
    5dca:	81 e0       	ldi	r24, 0x01	; 1
    5dcc:	90 e0       	ldi	r25, 0x00	; 0
    5dce:	8a 8b       	std	Y+18, r24	; 0x12
    5dd0:	9b 8b       	std	Y+19, r25	; 0x13
    5dd2:	46 c0       	rjmp	.+140    	; 0x5e60 <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5dd4:	11 e0       	ldi	r17, 0x01	; 1
    5dd6:	6e 85       	ldd	r22, Y+14	; 0x0e
    5dd8:	7f 85       	ldd	r23, Y+15	; 0x0f
    5dda:	88 89       	ldd	r24, Y+16	; 0x10
    5ddc:	99 89       	ldd	r25, Y+17	; 0x11
    5dde:	20 e0       	ldi	r18, 0x00	; 0
    5de0:	3f ef       	ldi	r19, 0xFF	; 255
    5de2:	4f e7       	ldi	r20, 0x7F	; 127
    5de4:	57 e4       	ldi	r21, 0x47	; 71
    5de6:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    5dea:	18 16       	cp	r1, r24
    5dec:	0c f0       	brlt	.+2      	; 0x5df0 <chb_sleep+0x144>
    5dee:	10 e0       	ldi	r17, 0x00	; 0
    5df0:	11 23       	and	r17, r17
    5df2:	61 f1       	breq	.+88     	; 0x5e4c <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5df4:	6a 85       	ldd	r22, Y+10	; 0x0a
    5df6:	7b 85       	ldd	r23, Y+11	; 0x0b
    5df8:	8c 85       	ldd	r24, Y+12	; 0x0c
    5dfa:	9d 85       	ldd	r25, Y+13	; 0x0d
    5dfc:	20 e0       	ldi	r18, 0x00	; 0
    5dfe:	30 e0       	ldi	r19, 0x00	; 0
    5e00:	40 e2       	ldi	r20, 0x20	; 32
    5e02:	51 e4       	ldi	r21, 0x41	; 65
    5e04:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    5e08:	dc 01       	movw	r26, r24
    5e0a:	cb 01       	movw	r24, r22
    5e0c:	bc 01       	movw	r22, r24
    5e0e:	cd 01       	movw	r24, r26
    5e10:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5e14:	dc 01       	movw	r26, r24
    5e16:	cb 01       	movw	r24, r22
    5e18:	8a 8b       	std	Y+18, r24	; 0x12
    5e1a:	9b 8b       	std	Y+19, r25	; 0x13
    5e1c:	12 c0       	rjmp	.+36     	; 0x5e42 <chb_sleep+0x196>
    5e1e:	89 e1       	ldi	r24, 0x19	; 25
    5e20:	90 e0       	ldi	r25, 0x00	; 0
    5e22:	8c 8b       	std	Y+20, r24	; 0x14
    5e24:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5e26:	8c 89       	ldd	r24, Y+20	; 0x14
    5e28:	9d 89       	ldd	r25, Y+21	; 0x15
    5e2a:	8c 01       	movw	r16, r24
    5e2c:	c8 01       	movw	r24, r16
    5e2e:	01 97       	sbiw	r24, 0x01	; 1
    5e30:	f1 f7       	brne	.-4      	; 0x5e2e <chb_sleep+0x182>
    5e32:	8c 01       	movw	r16, r24
    5e34:	0c 8b       	std	Y+20, r16	; 0x14
    5e36:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5e38:	8a 89       	ldd	r24, Y+18	; 0x12
    5e3a:	9b 89       	ldd	r25, Y+19	; 0x13
    5e3c:	01 97       	sbiw	r24, 0x01	; 1
    5e3e:	8a 8b       	std	Y+18, r24	; 0x12
    5e40:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5e42:	8a 89       	ldd	r24, Y+18	; 0x12
    5e44:	9b 89       	ldd	r25, Y+19	; 0x13
    5e46:	00 97       	sbiw	r24, 0x00	; 0
    5e48:	51 f7       	brne	.-44     	; 0x5e1e <chb_sleep+0x172>
    5e4a:	28 c0       	rjmp	.+80     	; 0x5e9c <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5e4c:	6e 85       	ldd	r22, Y+14	; 0x0e
    5e4e:	7f 85       	ldd	r23, Y+15	; 0x0f
    5e50:	88 89       	ldd	r24, Y+16	; 0x10
    5e52:	99 89       	ldd	r25, Y+17	; 0x11
    5e54:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5e58:	dc 01       	movw	r26, r24
    5e5a:	cb 01       	movw	r24, r22
    5e5c:	8a 8b       	std	Y+18, r24	; 0x12
    5e5e:	9b 8b       	std	Y+19, r25	; 0x13
    5e60:	8a 89       	ldd	r24, Y+18	; 0x12
    5e62:	9b 89       	ldd	r25, Y+19	; 0x13
    5e64:	8e 8b       	std	Y+22, r24	; 0x16
    5e66:	9f 8b       	std	Y+23, r25	; 0x17
    5e68:	8e 89       	ldd	r24, Y+22	; 0x16
    5e6a:	9f 89       	ldd	r25, Y+23	; 0x17
    5e6c:	8c 01       	movw	r16, r24
    5e6e:	f8 01       	movw	r30, r16
    5e70:	31 97       	sbiw	r30, 0x01	; 1
    5e72:	f1 f7       	brne	.-4      	; 0x5e70 <chb_sleep+0x1c4>
    5e74:	8f 01       	movw	r16, r30
    5e76:	0e 8b       	std	Y+22, r16	; 0x16
    5e78:	1f 8b       	std	Y+23, r17	; 0x17
    5e7a:	10 c0       	rjmp	.+32     	; 0x5e9c <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5e7c:	6d 81       	ldd	r22, Y+5	; 0x05
    5e7e:	7e 81       	ldd	r23, Y+6	; 0x06
    5e80:	8f 81       	ldd	r24, Y+7	; 0x07
    5e82:	98 85       	ldd	r25, Y+8	; 0x08
    5e84:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    5e88:	dc 01       	movw	r26, r24
    5e8a:	cb 01       	movw	r24, r22
    5e8c:	89 87       	std	Y+9, r24	; 0x09
    5e8e:	89 85       	ldd	r24, Y+9	; 0x09
    5e90:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5e92:	88 8d       	ldd	r24, Y+24	; 0x18
    5e94:	18 2f       	mov	r17, r24
    5e96:	1a 95       	dec	r17
    5e98:	f1 f7       	brne	.-4      	; 0x5e96 <chb_sleep+0x1ea>
    5e9a:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5e9c:	86 e1       	ldi	r24, 0x16	; 22
    5e9e:	0e 94 e5 28 	call	0x51ca	; 0x51ca <chb_set_state>
    }
}
    5ea2:	69 96       	adiw	r28, 0x19	; 25
    5ea4:	cd bf       	out	0x3d, r28	; 61
    5ea6:	de bf       	out	0x3e, r29	; 62
    5ea8:	df 91       	pop	r29
    5eaa:	cf 91       	pop	r28
    5eac:	1f 91       	pop	r17
    5eae:	0f 91       	pop	r16
    5eb0:	08 95       	ret

00005eb2 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5eb2:	cf 93       	push	r28
    5eb4:	df 93       	push	r29
    5eb6:	cd b7       	in	r28, 0x3d	; 61
    5eb8:	de b7       	in	r29, 0x3e	; 62
    5eba:	ea 97       	sbiw	r28, 0x3a	; 58
    5ebc:	cd bf       	out	0x3d, r28	; 61
    5ebe:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5ec0:	0e 94 96 23 	call	0x472c	; 0x472c <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5ec4:	8e e0       	ldi	r24, 0x0E	; 14
    5ec6:	60 e0       	ldi	r22, 0x00	; 0
    5ec8:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5ecc:	82 e0       	ldi	r24, 0x02	; 2
    5ece:	63 e0       	ldi	r22, 0x03	; 3
    5ed0:	4f e1       	ldi	r20, 0x1F	; 31
    5ed2:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5ed6:	00 00       	nop
    5ed8:	81 e0       	ldi	r24, 0x01	; 1
    5eda:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    5ede:	88 2f       	mov	r24, r24
    5ee0:	90 e0       	ldi	r25, 0x00	; 0
    5ee2:	8f 71       	andi	r24, 0x1F	; 31
    5ee4:	90 70       	andi	r25, 0x00	; 0
    5ee6:	88 30       	cpi	r24, 0x08	; 8
    5ee8:	91 05       	cpc	r25, r1
    5eea:	b1 f7       	brne	.-20     	; 0x5ed8 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5eec:	8e e2       	ldi	r24, 0x2E	; 46
    5eee:	60 e4       	ldi	r22, 0x40	; 64
    5ef0:	40 ec       	ldi	r20, 0xC0	; 192
    5ef2:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5ef6:	8e e0       	ldi	r24, 0x0E	; 14
    5ef8:	6c e0       	ldi	r22, 0x0C	; 12
    5efa:	0e 94 e2 25 	call	0x4bc4	; 0x4bc4 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5efe:	84 e0       	ldi	r24, 0x04	; 4
    5f00:	60 e2       	ldi	r22, 0x20	; 32
    5f02:	40 e2       	ldi	r20, 0x20	; 32
    5f04:	0e 94 67 26 	call	0x4cce	; 0x4cce <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5f08:	81 e0       	ldi	r24, 0x01	; 1
    5f0a:	0e 94 87 27 	call	0x4f0e	; 0x4f0e <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5f0e:	81 e0       	ldi	r24, 0x01	; 1
    5f10:	0e 94 d0 27 	call	0x4fa0	; 0x4fa0 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5f14:	86 e1       	ldi	r24, 0x16	; 22
    5f16:	0e 94 e5 28 	call	0x51ca	; 0x51ca <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5f1a:	82 e2       	ldi	r24, 0x22	; 34
    5f1c:	64 e3       	ldi	r22, 0x34	; 52
    5f1e:	72 e1       	ldi	r23, 0x12	; 18
    5f20:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5f24:	0e 94 f8 2d 	call	0x5bf0	; 0x5bf0 <chb_get_short_addr>
    5f28:	9c 01       	movw	r18, r24
    5f2a:	80 e2       	ldi	r24, 0x20	; 32
    5f2c:	b9 01       	movw	r22, r18
    5f2e:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5f32:	ce 01       	movw	r24, r28
    5f34:	01 96       	adiw	r24, 0x01	; 1
    5f36:	0e 94 b6 2d 	call	0x5b6c	; 0x5b6c <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5f3a:	84 e2       	ldi	r24, 0x24	; 36
    5f3c:	9e 01       	movw	r18, r28
    5f3e:	2f 5f       	subi	r18, 0xFF	; 255
    5f40:	3f 4f       	sbci	r19, 0xFF	; 255
    5f42:	b9 01       	movw	r22, r18
    5f44:	0e 94 3f 26 	call	0x4c7e	; 0x4c7e <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5f48:	82 e7       	ldi	r24, 0x72	; 114
    5f4a:	96 e0       	ldi	r25, 0x06	; 6
    5f4c:	22 e7       	ldi	r18, 0x72	; 114
    5f4e:	36 e0       	ldi	r19, 0x06	; 6
    5f50:	f9 01       	movw	r30, r18
    5f52:	20 81       	ld	r18, Z
    5f54:	21 60       	ori	r18, 0x01	; 1
    5f56:	fc 01       	movw	r30, r24
    5f58:	20 83       	st	Z, r18
    5f5a:	89 e6       	ldi	r24, 0x69	; 105
    5f5c:	96 e0       	ldi	r25, 0x06	; 6
    5f5e:	29 e6       	ldi	r18, 0x69	; 105
    5f60:	36 e0       	ldi	r19, 0x06	; 6
    5f62:	f9 01       	movw	r30, r18
    5f64:	20 81       	ld	r18, Z
    5f66:	22 60       	ori	r18, 0x02	; 2
    5f68:	fc 01       	movw	r30, r24
    5f6a:	20 83       	st	Z, r18
    5f6c:	8a e6       	ldi	r24, 0x6A	; 106
    5f6e:	96 e0       	ldi	r25, 0x06	; 6
    5f70:	2a e6       	ldi	r18, 0x6A	; 106
    5f72:	36 e0       	ldi	r19, 0x06	; 6
    5f74:	f9 01       	movw	r30, r18
    5f76:	20 81       	ld	r18, Z
    5f78:	24 60       	ori	r18, 0x04	; 4
    5f7a:	fc 01       	movw	r30, r24
    5f7c:	20 83       	st	Z, r18
	PMIC.CTRL = 0x07;	//enable interrupts on MCU
    5f7e:	80 ea       	ldi	r24, 0xA0	; 160
    5f80:	90 e0       	ldi	r25, 0x00	; 0
    5f82:	27 e0       	ldi	r18, 0x07	; 7
    5f84:	fc 01       	movw	r30, r24
    5f86:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5f88:	0e 94 7e 23 	call	0x46fc	; 0x46fc <chb_get_state>
    5f8c:	86 31       	cpi	r24, 0x16	; 22
    5f8e:	b1 f0       	breq	.+44     	; 0x5fbc <chb_radio_init+0x10a>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5f90:	ce 01       	movw	r24, r28
    5f92:	09 96       	adiw	r24, 0x09	; 9
    5f94:	2c e0       	ldi	r18, 0x0C	; 12
    5f96:	32 e0       	ldi	r19, 0x02	; 2
    5f98:	b9 01       	movw	r22, r18
    5f9a:	0e 94 26 5f 	call	0xbe4c	; 0xbe4c <strcpy_P>
        printf(buf);
    5f9e:	0f 92       	push	r0
    5fa0:	0f 92       	push	r0
    5fa2:	8d b7       	in	r24, 0x3d	; 61
    5fa4:	9e b7       	in	r25, 0x3e	; 62
    5fa6:	01 96       	adiw	r24, 0x01	; 1
    5fa8:	9e 01       	movw	r18, r28
    5faa:	27 5f       	subi	r18, 0xF7	; 247
    5fac:	3f 4f       	sbci	r19, 0xFF	; 255
    5fae:	fc 01       	movw	r30, r24
    5fb0:	20 83       	st	Z, r18
    5fb2:	31 83       	std	Z+1, r19	; 0x01
    5fb4:	0e 94 82 5f 	call	0xbf04	; 0xbf04 <printf>
    5fb8:	0f 90       	pop	r0
    5fba:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5fbc:	10 92 c7 50 	sts	0x50C7, r1
    5fc0:	10 92 c8 50 	sts	0x50C8, r1
    5fc4:	10 92 c9 50 	sts	0x50C9, r1
    5fc8:	10 92 ca 50 	sts	0x50CA, r1
}
    5fcc:	ea 96       	adiw	r28, 0x3a	; 58
    5fce:	cd bf       	out	0x3d, r28	; 61
    5fd0:	de bf       	out	0x3e, r29	; 62
    5fd2:	df 91       	pop	r29
    5fd4:	cf 91       	pop	r28
    5fd6:	08 95       	ret

00005fd8 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5fd8:	cf 93       	push	r28
    5fda:	df 93       	push	r29
    5fdc:	cd b7       	in	r28, 0x3d	; 61
    5fde:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5fe0:	0e 94 35 32 	call	0x646a	; 0x646a <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5fe4:	80 e6       	ldi	r24, 0x60	; 96
    5fe6:	96 e0       	ldi	r25, 0x06	; 6
    5fe8:	20 e6       	ldi	r18, 0x60	; 96
    5fea:	36 e0       	ldi	r19, 0x06	; 6
    5fec:	f9 01       	movw	r30, r18
    5fee:	20 81       	ld	r18, Z
    5ff0:	22 60       	ori	r18, 0x02	; 2
    5ff2:	fc 01       	movw	r30, r24
    5ff4:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5ff6:	80 e6       	ldi	r24, 0x60	; 96
    5ff8:	96 e0       	ldi	r25, 0x06	; 6
    5ffa:	20 e6       	ldi	r18, 0x60	; 96
    5ffc:	36 e0       	ldi	r19, 0x06	; 6
    5ffe:	f9 01       	movw	r30, r18
    6000:	20 81       	ld	r18, Z
    6002:	21 60       	ori	r18, 0x01	; 1
    6004:	fc 01       	movw	r30, r24
    6006:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    6008:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <chb_radio_init>
}
    600c:	df 91       	pop	r29
    600e:	cf 91       	pop	r28
    6010:	08 95       	ret

00006012 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    6012:	1f 92       	push	r1
    6014:	0f 92       	push	r0
    6016:	0f b6       	in	r0, 0x3f	; 63
    6018:	0f 92       	push	r0
    601a:	00 90 3b 00 	lds	r0, 0x003B
    601e:	0f 92       	push	r0
    6020:	11 24       	eor	r1, r1
    6022:	2f 93       	push	r18
    6024:	3f 93       	push	r19
    6026:	4f 93       	push	r20
    6028:	5f 93       	push	r21
    602a:	6f 93       	push	r22
    602c:	7f 93       	push	r23
    602e:	8f 93       	push	r24
    6030:	9f 93       	push	r25
    6032:	af 93       	push	r26
    6034:	bf 93       	push	r27
    6036:	ef 93       	push	r30
    6038:	ff 93       	push	r31
    603a:	cf 93       	push	r28
    603c:	df 93       	push	r29
    603e:	cd b7       	in	r28, 0x3d	; 61
    6040:	de b7       	in	r29, 0x3e	; 62
    6042:	25 97       	sbiw	r28, 0x05	; 5
    6044:	cd bf       	out	0x3d, r28	; 61
    6046:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    6048:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    604a:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <chb_get_pcb>
    604e:	8a 83       	std	Y+2, r24	; 0x02
    6050:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    6052:	8f e3       	ldi	r24, 0x3F	; 63
    6054:	90 e0       	ldi	r25, 0x00	; 0
    6056:	fc 01       	movw	r30, r24
    6058:	80 81       	ld	r24, Z
    605a:	80 93 57 40 	sts	0x4057, r24
    605e:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    6060:	81 e0       	ldi	r24, 0x01	; 1
    6062:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    6066:	8f e8       	ldi	r24, 0x8F	; 143
    6068:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    606c:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    606e:	80 e0       	ldi	r24, 0x00	; 0
    6070:	0e 94 60 32 	call	0x64c0	; 0x64c0 <SPID_write>
    6074:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    6076:	80 e0       	ldi	r24, 0x00	; 0
    6078:	0e 94 03 31 	call	0x6206	; 0x6206 <RadioCS>

    while (intp_src)
    607c:	9d c0       	rjmp	.+314    	; 0x61b8 <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    607e:	89 81       	ldd	r24, Y+1	; 0x01
    6080:	88 2f       	mov	r24, r24
    6082:	90 e0       	ldi	r25, 0x00	; 0
    6084:	84 70       	andi	r24, 0x04	; 4
    6086:	90 70       	andi	r25, 0x00	; 0
    6088:	00 97       	sbiw	r24, 0x00	; 0
    608a:	21 f0       	breq	.+8      	; 0x6094 <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    608c:	89 81       	ldd	r24, Y+1	; 0x01
    608e:	8b 7f       	andi	r24, 0xFB	; 251
    6090:	89 83       	std	Y+1, r24	; 0x01
    6092:	92 c0       	rjmp	.+292    	; 0x61b8 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    6094:	89 81       	ldd	r24, Y+1	; 0x01
    6096:	88 2f       	mov	r24, r24
    6098:	90 e0       	ldi	r25, 0x00	; 0
    609a:	88 70       	andi	r24, 0x08	; 8
    609c:	90 70       	andi	r25, 0x00	; 0
    609e:	00 97       	sbiw	r24, 0x00	; 0
    60a0:	09 f4       	brne	.+2      	; 0x60a4 <__vector_64+0x92>
    60a2:	4c c0       	rjmp	.+152    	; 0x613c <__vector_64+0x12a>
        {
            state = chb_get_state();
    60a4:	0e 94 7e 23 	call	0x46fc	; 0x46fc <chb_get_state>
    60a8:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    60aa:	8d 81       	ldd	r24, Y+5	; 0x05
    60ac:	86 30       	cpi	r24, 0x06	; 6
    60ae:	31 f0       	breq	.+12     	; 0x60bc <__vector_64+0xaa>
    60b0:	8d 81       	ldd	r24, Y+5	; 0x05
    60b2:	86 31       	cpi	r24, 0x16	; 22
    60b4:	19 f0       	breq	.+6      	; 0x60bc <__vector_64+0xaa>
    60b6:	8d 81       	ldd	r24, Y+5	; 0x05
    60b8:	81 31       	cpi	r24, 0x11	; 17
    60ba:	89 f5       	brne	.+98     	; 0x611e <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    60bc:	88 e0       	ldi	r24, 0x08	; 8
    60be:	0e 94 e5 28 	call	0x51ca	; 0x51ca <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    60c2:	87 e0       	ldi	r24, 0x07	; 7
    60c4:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    60c8:	28 2f       	mov	r18, r24
    60ca:	8a 81       	ldd	r24, Y+2	; 0x02
    60cc:	9b 81       	ldd	r25, Y+3	; 0x03
    60ce:	fc 01       	movw	r30, r24
    60d0:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    60d2:	86 e0       	ldi	r24, 0x06	; 6
    60d4:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
    60d8:	28 2f       	mov	r18, r24
    60da:	22 1f       	adc	r18, r18
    60dc:	22 27       	eor	r18, r18
    60de:	22 1f       	adc	r18, r18
    60e0:	8a 81       	ldd	r24, Y+2	; 0x02
    60e2:	9b 81       	ldd	r25, Y+3	; 0x03
    60e4:	fc 01       	movw	r30, r24
    60e6:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    60e8:	8a 81       	ldd	r24, Y+2	; 0x02
    60ea:	9b 81       	ldd	r25, Y+3	; 0x03
    60ec:	fc 01       	movw	r30, r24
    60ee:	83 89       	ldd	r24, Z+19	; 0x13
    60f0:	88 23       	and	r24, r24
    60f2:	d1 f0       	breq	.+52     	; 0x6128 <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    60f4:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <chb_frame_read>
                    pcb->rcvd_xfers++;
    60f8:	8a 81       	ldd	r24, Y+2	; 0x02
    60fa:	9b 81       	ldd	r25, Y+3	; 0x03
    60fc:	fc 01       	movw	r30, r24
    60fe:	85 81       	ldd	r24, Z+5	; 0x05
    6100:	96 81       	ldd	r25, Z+6	; 0x06
    6102:	9c 01       	movw	r18, r24
    6104:	2f 5f       	subi	r18, 0xFF	; 255
    6106:	3f 4f       	sbci	r19, 0xFF	; 255
    6108:	8a 81       	ldd	r24, Y+2	; 0x02
    610a:	9b 81       	ldd	r25, Y+3	; 0x03
    610c:	fc 01       	movw	r30, r24
    610e:	25 83       	std	Z+5, r18	; 0x05
    6110:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    6112:	8a 81       	ldd	r24, Y+2	; 0x02
    6114:	9b 81       	ldd	r25, Y+3	; 0x03
    6116:	21 e0       	ldi	r18, 0x01	; 1
    6118:	fc 01       	movw	r30, r24
    611a:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    611c:	05 c0       	rjmp	.+10     	; 0x6128 <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    611e:	8a 81       	ldd	r24, Y+2	; 0x02
    6120:	9b 81       	ldd	r25, Y+3	; 0x03
    6122:	21 e0       	ldi	r18, 0x01	; 1
    6124:	fc 01       	movw	r30, r24
    6126:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    6128:	89 81       	ldd	r24, Y+1	; 0x01
    612a:	87 7f       	andi	r24, 0xF7	; 247
    612c:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    612e:	00 00       	nop
    6130:	86 e1       	ldi	r24, 0x16	; 22
    6132:	0e 94 e5 28 	call	0x51ca	; 0x51ca <chb_set_state>
    6136:	80 34       	cpi	r24, 0x40	; 64
    6138:	d9 f7       	brne	.-10     	; 0x6130 <__vector_64+0x11e>
    613a:	3e c0       	rjmp	.+124    	; 0x61b8 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    613c:	89 81       	ldd	r24, Y+1	; 0x01
    613e:	88 2f       	mov	r24, r24
    6140:	90 e0       	ldi	r25, 0x00	; 0
    6142:	80 74       	andi	r24, 0x40	; 64
    6144:	90 70       	andi	r25, 0x00	; 0
    6146:	00 97       	sbiw	r24, 0x00	; 0
    6148:	89 f0       	breq	.+34     	; 0x616c <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    614a:	89 81       	ldd	r24, Y+1	; 0x01
    614c:	8f 7b       	andi	r24, 0xBF	; 191
    614e:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    6150:	8a 81       	ldd	r24, Y+2	; 0x02
    6152:	9b 81       	ldd	r25, Y+3	; 0x03
    6154:	fc 01       	movw	r30, r24
    6156:	87 85       	ldd	r24, Z+15	; 0x0f
    6158:	90 89       	ldd	r25, Z+16	; 0x10
    615a:	9c 01       	movw	r18, r24
    615c:	2f 5f       	subi	r18, 0xFF	; 255
    615e:	3f 4f       	sbci	r19, 0xFF	; 255
    6160:	8a 81       	ldd	r24, Y+2	; 0x02
    6162:	9b 81       	ldd	r25, Y+3	; 0x03
    6164:	fc 01       	movw	r30, r24
    6166:	27 87       	std	Z+15, r18	; 0x0f
    6168:	30 8b       	std	Z+16, r19	; 0x10
    616a:	26 c0       	rjmp	.+76     	; 0x61b8 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    616c:	89 81       	ldd	r24, Y+1	; 0x01
    616e:	88 2f       	mov	r24, r24
    6170:	90 e0       	ldi	r25, 0x00	; 0
    6172:	82 70       	andi	r24, 0x02	; 2
    6174:	90 70       	andi	r25, 0x00	; 0
    6176:	00 97       	sbiw	r24, 0x00	; 0
    6178:	21 f0       	breq	.+8      	; 0x6182 <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    617a:	89 81       	ldd	r24, Y+1	; 0x01
    617c:	8d 7f       	andi	r24, 0xFD	; 253
    617e:	89 83       	std	Y+1, r24	; 0x01
    6180:	1b c0       	rjmp	.+54     	; 0x61b8 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    6182:	89 81       	ldd	r24, Y+1	; 0x01
    6184:	88 2f       	mov	r24, r24
    6186:	90 e0       	ldi	r25, 0x00	; 0
    6188:	81 70       	andi	r24, 0x01	; 1
    618a:	90 70       	andi	r25, 0x00	; 0
    618c:	88 23       	and	r24, r24
    618e:	21 f0       	breq	.+8      	; 0x6198 <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    6190:	89 81       	ldd	r24, Y+1	; 0x01
    6192:	8e 7f       	andi	r24, 0xFE	; 254
    6194:	89 83       	std	Y+1, r24	; 0x01
    6196:	10 c0       	rjmp	.+32     	; 0x61b8 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    6198:	89 81       	ldd	r24, Y+1	; 0x01
    619a:	88 23       	and	r24, r24
    619c:	6c f4       	brge	.+26     	; 0x61b8 <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    619e:	89 81       	ldd	r24, Y+1	; 0x01
    61a0:	8f 77       	andi	r24, 0x7F	; 127
    61a2:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    61a4:	8a 81       	ldd	r24, Y+2	; 0x02
    61a6:	9b 81       	ldd	r25, Y+3	; 0x03
    61a8:	fc 01       	movw	r30, r24
    61aa:	81 89       	ldd	r24, Z+17	; 0x11
    61ac:	28 2f       	mov	r18, r24
    61ae:	2f 5f       	subi	r18, 0xFF	; 255
    61b0:	8a 81       	ldd	r24, Y+2	; 0x02
    61b2:	9b 81       	ldd	r25, Y+3	; 0x03
    61b4:	fc 01       	movw	r30, r24
    61b6:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    61b8:	89 81       	ldd	r24, Y+1	; 0x01
    61ba:	88 23       	and	r24, r24
    61bc:	09 f0       	breq	.+2      	; 0x61c0 <__vector_64+0x1ae>
    61be:	5f cf       	rjmp	.-322    	; 0x607e <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    61c0:	8f e3       	ldi	r24, 0x3F	; 63
    61c2:	90 e0       	ldi	r25, 0x00	; 0
    61c4:	20 91 57 40 	lds	r18, 0x4057
    61c8:	fc 01       	movw	r30, r24
    61ca:	20 83       	st	Z, r18
    61cc:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    61ce:	8f e0       	ldi	r24, 0x0F	; 15
    61d0:	0e 94 82 25 	call	0x4b04	; 0x4b04 <chb_reg_read>
}
    61d4:	25 96       	adiw	r28, 0x05	; 5
    61d6:	cd bf       	out	0x3d, r28	; 61
    61d8:	de bf       	out	0x3e, r29	; 62
    61da:	df 91       	pop	r29
    61dc:	cf 91       	pop	r28
    61de:	ff 91       	pop	r31
    61e0:	ef 91       	pop	r30
    61e2:	bf 91       	pop	r27
    61e4:	af 91       	pop	r26
    61e6:	9f 91       	pop	r25
    61e8:	8f 91       	pop	r24
    61ea:	7f 91       	pop	r23
    61ec:	6f 91       	pop	r22
    61ee:	5f 91       	pop	r21
    61f0:	4f 91       	pop	r20
    61f2:	3f 91       	pop	r19
    61f4:	2f 91       	pop	r18
    61f6:	0f 90       	pop	r0
    61f8:	00 92 3b 00 	sts	0x003B, r0
    61fc:	0f 90       	pop	r0
    61fe:	0f be       	out	0x3f, r0	; 63
    6200:	0f 90       	pop	r0
    6202:	1f 90       	pop	r1
    6204:	18 95       	reti

00006206 <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    6206:	cf 93       	push	r28
    6208:	df 93       	push	r29
    620a:	0f 92       	push	r0
    620c:	cd b7       	in	r28, 0x3d	; 61
    620e:	de b7       	in	r29, 0x3e	; 62
    6210:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    6212:	89 81       	ldd	r24, Y+1	; 0x01
    6214:	88 23       	and	r24, r24
    6216:	31 f0       	breq	.+12     	; 0x6224 <RadioCS+0x1e>
    6218:	80 e6       	ldi	r24, 0x60	; 96
    621a:	96 e0       	ldi	r25, 0x06	; 6
    621c:	20 e1       	ldi	r18, 0x10	; 16
    621e:	fc 01       	movw	r30, r24
    6220:	26 83       	std	Z+6, r18	; 0x06
    6222:	05 c0       	rjmp	.+10     	; 0x622e <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    6224:	80 e6       	ldi	r24, 0x60	; 96
    6226:	96 e0       	ldi	r25, 0x06	; 6
    6228:	20 e1       	ldi	r18, 0x10	; 16
    622a:	fc 01       	movw	r30, r24
    622c:	25 83       	std	Z+5, r18	; 0x05
	}
    622e:	0f 90       	pop	r0
    6230:	df 91       	pop	r29
    6232:	cf 91       	pop	r28
    6234:	08 95       	ret

00006236 <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    6236:	cf 93       	push	r28
    6238:	df 93       	push	r29
    623a:	00 d0       	rcall	.+0      	; 0x623c <chb_eep_write_byte+0x6>
    623c:	cd b7       	in	r28, 0x3d	; 61
    623e:	de b7       	in	r29, 0x3e	; 62
    6240:	89 83       	std	Y+1, r24	; 0x01
    6242:	9a 83       	std	Y+2, r25	; 0x02
    6244:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    6246:	00 00       	nop
    6248:	80 ec       	ldi	r24, 0xC0	; 192
    624a:	91 e0       	ldi	r25, 0x01	; 1
    624c:	fc 01       	movw	r30, r24
    624e:	87 85       	ldd	r24, Z+15	; 0x0f
    6250:	88 23       	and	r24, r24
    6252:	d4 f3       	brlt	.-12     	; 0x6248 <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    6254:	80 ec       	ldi	r24, 0xC0	; 192
    6256:	91 e0       	ldi	r25, 0x01	; 1
    6258:	fc 01       	movw	r30, r24
    625a:	87 85       	ldd	r24, Z+15	; 0x0f
    625c:	88 2f       	mov	r24, r24
    625e:	90 e0       	ldi	r25, 0x00	; 0
    6260:	82 70       	andi	r24, 0x02	; 2
    6262:	90 70       	andi	r25, 0x00	; 0
    6264:	00 97       	sbiw	r24, 0x00	; 0
    6266:	99 f0       	breq	.+38     	; 0x628e <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    6268:	80 ec       	ldi	r24, 0xC0	; 192
    626a:	91 e0       	ldi	r25, 0x01	; 1
    626c:	26 e3       	ldi	r18, 0x36	; 54
    626e:	fc 01       	movw	r30, r24
    6270:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    6272:	ef 93       	push	r30
    6274:	ff 93       	push	r31
    6276:	0f 93       	push	r16
    6278:	2f 93       	push	r18
    627a:	eb ec       	ldi	r30, 0xCB	; 203
    627c:	f1 e0       	ldi	r31, 0x01	; 1
    627e:	08 ed       	ldi	r16, 0xD8	; 216
    6280:	21 e0       	ldi	r18, 0x01	; 1
    6282:	04 bf       	out	0x34, r16	; 52
    6284:	20 83       	st	Z, r18
    6286:	2f 91       	pop	r18
    6288:	0f 91       	pop	r16
    628a:	ff 91       	pop	r31
    628c:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    628e:	80 ec       	ldi	r24, 0xC0	; 192
    6290:	91 e0       	ldi	r25, 0x01	; 1
    6292:	23 e3       	ldi	r18, 0x33	; 51
    6294:	fc 01       	movw	r30, r24
    6296:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    6298:	80 ec       	ldi	r24, 0xC0	; 192
    629a:	91 e0       	ldi	r25, 0x01	; 1
    629c:	29 81       	ldd	r18, Y+1	; 0x01
    629e:	fc 01       	movw	r30, r24
    62a0:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    62a2:	80 ec       	ldi	r24, 0xC0	; 192
    62a4:	91 e0       	ldi	r25, 0x01	; 1
    62a6:	29 81       	ldd	r18, Y+1	; 0x01
    62a8:	3a 81       	ldd	r19, Y+2	; 0x02
    62aa:	23 2f       	mov	r18, r19
    62ac:	33 27       	eor	r19, r19
    62ae:	2f 71       	andi	r18, 0x1F	; 31
    62b0:	fc 01       	movw	r30, r24
    62b2:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    62b4:	80 ec       	ldi	r24, 0xC0	; 192
    62b6:	91 e0       	ldi	r25, 0x01	; 1
    62b8:	fc 01       	movw	r30, r24
    62ba:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    62bc:	80 ec       	ldi	r24, 0xC0	; 192
    62be:	91 e0       	ldi	r25, 0x01	; 1
    62c0:	2b 81       	ldd	r18, Y+3	; 0x03
    62c2:	fc 01       	movw	r30, r24
    62c4:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    62c6:	80 ec       	ldi	r24, 0xC0	; 192
    62c8:	91 e0       	ldi	r25, 0x01	; 1
    62ca:	25 e3       	ldi	r18, 0x35	; 53
    62cc:	fc 01       	movw	r30, r24
    62ce:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    62d0:	ef 93       	push	r30
    62d2:	ff 93       	push	r31
    62d4:	0f 93       	push	r16
    62d6:	2f 93       	push	r18
    62d8:	eb ec       	ldi	r30, 0xCB	; 203
    62da:	f1 e0       	ldi	r31, 0x01	; 1
    62dc:	08 ed       	ldi	r16, 0xD8	; 216
    62de:	21 e0       	ldi	r18, 0x01	; 1
    62e0:	04 bf       	out	0x34, r16	; 52
    62e2:	20 83       	st	Z, r18
    62e4:	2f 91       	pop	r18
    62e6:	0f 91       	pop	r16
    62e8:	ff 91       	pop	r31
    62ea:	ef 91       	pop	r30
}
    62ec:	23 96       	adiw	r28, 0x03	; 3
    62ee:	cd bf       	out	0x3d, r28	; 61
    62f0:	de bf       	out	0x3e, r29	; 62
    62f2:	df 91       	pop	r29
    62f4:	cf 91       	pop	r28
    62f6:	08 95       	ret

000062f8 <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    62f8:	cf 93       	push	r28
    62fa:	df 93       	push	r29
    62fc:	0f 92       	push	r0
    62fe:	0f 92       	push	r0
    6300:	cd b7       	in	r28, 0x3d	; 61
    6302:	de b7       	in	r29, 0x3e	; 62
    6304:	89 83       	std	Y+1, r24	; 0x01
    6306:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    6308:	00 00       	nop
    630a:	80 ec       	ldi	r24, 0xC0	; 192
    630c:	91 e0       	ldi	r25, 0x01	; 1
    630e:	fc 01       	movw	r30, r24
    6310:	87 85       	ldd	r24, Z+15	; 0x0f
    6312:	88 23       	and	r24, r24
    6314:	d4 f3       	brlt	.-12     	; 0x630a <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    6316:	80 ec       	ldi	r24, 0xC0	; 192
    6318:	91 e0       	ldi	r25, 0x01	; 1
    631a:	29 81       	ldd	r18, Y+1	; 0x01
    631c:	fc 01       	movw	r30, r24
    631e:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    6320:	80 ec       	ldi	r24, 0xC0	; 192
    6322:	91 e0       	ldi	r25, 0x01	; 1
    6324:	29 81       	ldd	r18, Y+1	; 0x01
    6326:	3a 81       	ldd	r19, Y+2	; 0x02
    6328:	23 2f       	mov	r18, r19
    632a:	33 27       	eor	r19, r19
    632c:	2f 71       	andi	r18, 0x1F	; 31
    632e:	fc 01       	movw	r30, r24
    6330:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    6332:	80 ec       	ldi	r24, 0xC0	; 192
    6334:	91 e0       	ldi	r25, 0x01	; 1
    6336:	fc 01       	movw	r30, r24
    6338:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    633a:	80 ec       	ldi	r24, 0xC0	; 192
    633c:	91 e0       	ldi	r25, 0x01	; 1
    633e:	26 e0       	ldi	r18, 0x06	; 6
    6340:	fc 01       	movw	r30, r24
    6342:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    6344:	ef 93       	push	r30
    6346:	ff 93       	push	r31
    6348:	0f 93       	push	r16
    634a:	2f 93       	push	r18
    634c:	eb ec       	ldi	r30, 0xCB	; 203
    634e:	f1 e0       	ldi	r31, 0x01	; 1
    6350:	08 ed       	ldi	r16, 0xD8	; 216
    6352:	21 e0       	ldi	r18, 0x01	; 1
    6354:	04 bf       	out	0x34, r16	; 52
    6356:	20 83       	st	Z, r18
    6358:	2f 91       	pop	r18
    635a:	0f 91       	pop	r16
    635c:	ff 91       	pop	r31
    635e:	ef 91       	pop	r30

    return NVM.DATA0;
    6360:	80 ec       	ldi	r24, 0xC0	; 192
    6362:	91 e0       	ldi	r25, 0x01	; 1
    6364:	fc 01       	movw	r30, r24
    6366:	84 81       	ldd	r24, Z+4	; 0x04
}
    6368:	0f 90       	pop	r0
    636a:	0f 90       	pop	r0
    636c:	df 91       	pop	r29
    636e:	cf 91       	pop	r28
    6370:	08 95       	ret

00006372 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    6372:	cf 93       	push	r28
    6374:	df 93       	push	r29
    6376:	cd b7       	in	r28, 0x3d	; 61
    6378:	de b7       	in	r29, 0x3e	; 62
    637a:	27 97       	sbiw	r28, 0x07	; 7
    637c:	cd bf       	out	0x3d, r28	; 61
    637e:	de bf       	out	0x3e, r29	; 62
    6380:	8a 83       	std	Y+2, r24	; 0x02
    6382:	9b 83       	std	Y+3, r25	; 0x03
    6384:	6c 83       	std	Y+4, r22	; 0x04
    6386:	7d 83       	std	Y+5, r23	; 0x05
    6388:	4e 83       	std	Y+6, r20	; 0x06
    638a:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    638c:	80 ec       	ldi	r24, 0xC0	; 192
    638e:	91 e0       	ldi	r25, 0x01	; 1
    6390:	20 ec       	ldi	r18, 0xC0	; 192
    6392:	31 e0       	ldi	r19, 0x01	; 1
    6394:	f9 01       	movw	r30, r18
    6396:	24 85       	ldd	r18, Z+12	; 0x0c
    6398:	27 7f       	andi	r18, 0xF7	; 247
    639a:	fc 01       	movw	r30, r24
    639c:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    639e:	19 82       	std	Y+1, r1	; 0x01
    63a0:	16 c0       	rjmp	.+44     	; 0x63ce <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    63a2:	89 81       	ldd	r24, Y+1	; 0x01
    63a4:	28 2f       	mov	r18, r24
    63a6:	30 e0       	ldi	r19, 0x00	; 0
    63a8:	8a 81       	ldd	r24, Y+2	; 0x02
    63aa:	9b 81       	ldd	r25, Y+3	; 0x03
    63ac:	82 0f       	add	r24, r18
    63ae:	93 1f       	adc	r25, r19
    63b0:	29 81       	ldd	r18, Y+1	; 0x01
    63b2:	22 2f       	mov	r18, r18
    63b4:	30 e0       	ldi	r19, 0x00	; 0
    63b6:	4c 81       	ldd	r20, Y+4	; 0x04
    63b8:	5d 81       	ldd	r21, Y+5	; 0x05
    63ba:	24 0f       	add	r18, r20
    63bc:	35 1f       	adc	r19, r21
    63be:	f9 01       	movw	r30, r18
    63c0:	20 81       	ld	r18, Z
    63c2:	62 2f       	mov	r22, r18
    63c4:	0e 94 1b 31 	call	0x6236	; 0x6236 <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    63c8:	89 81       	ldd	r24, Y+1	; 0x01
    63ca:	8f 5f       	subi	r24, 0xFF	; 255
    63cc:	89 83       	std	Y+1, r24	; 0x01
    63ce:	89 81       	ldd	r24, Y+1	; 0x01
    63d0:	28 2f       	mov	r18, r24
    63d2:	30 e0       	ldi	r19, 0x00	; 0
    63d4:	8e 81       	ldd	r24, Y+6	; 0x06
    63d6:	9f 81       	ldd	r25, Y+7	; 0x07
    63d8:	28 17       	cp	r18, r24
    63da:	39 07       	cpc	r19, r25
    63dc:	10 f3       	brcs	.-60     	; 0x63a2 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    63de:	27 96       	adiw	r28, 0x07	; 7
    63e0:	cd bf       	out	0x3d, r28	; 61
    63e2:	de bf       	out	0x3e, r29	; 62
    63e4:	df 91       	pop	r29
    63e6:	cf 91       	pop	r28
    63e8:	08 95       	ret

000063ea <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    63ea:	0f 93       	push	r16
    63ec:	1f 93       	push	r17
    63ee:	cf 93       	push	r28
    63f0:	df 93       	push	r29
    63f2:	cd b7       	in	r28, 0x3d	; 61
    63f4:	de b7       	in	r29, 0x3e	; 62
    63f6:	27 97       	sbiw	r28, 0x07	; 7
    63f8:	cd bf       	out	0x3d, r28	; 61
    63fa:	de bf       	out	0x3e, r29	; 62
    63fc:	8a 83       	std	Y+2, r24	; 0x02
    63fe:	9b 83       	std	Y+3, r25	; 0x03
    6400:	6c 83       	std	Y+4, r22	; 0x04
    6402:	7d 83       	std	Y+5, r23	; 0x05
    6404:	4e 83       	std	Y+6, r20	; 0x06
    6406:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    6408:	80 ec       	ldi	r24, 0xC0	; 192
    640a:	91 e0       	ldi	r25, 0x01	; 1
    640c:	20 ec       	ldi	r18, 0xC0	; 192
    640e:	31 e0       	ldi	r19, 0x01	; 1
    6410:	f9 01       	movw	r30, r18
    6412:	24 85       	ldd	r18, Z+12	; 0x0c
    6414:	27 7f       	andi	r18, 0xF7	; 247
    6416:	fc 01       	movw	r30, r24
    6418:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    641a:	19 82       	std	Y+1, r1	; 0x01
    641c:	16 c0       	rjmp	.+44     	; 0x644a <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    641e:	89 81       	ldd	r24, Y+1	; 0x01
    6420:	88 2f       	mov	r24, r24
    6422:	90 e0       	ldi	r25, 0x00	; 0
    6424:	2c 81       	ldd	r18, Y+4	; 0x04
    6426:	3d 81       	ldd	r19, Y+5	; 0x05
    6428:	89 01       	movw	r16, r18
    642a:	08 0f       	add	r16, r24
    642c:	19 1f       	adc	r17, r25
    642e:	89 81       	ldd	r24, Y+1	; 0x01
    6430:	28 2f       	mov	r18, r24
    6432:	30 e0       	ldi	r19, 0x00	; 0
    6434:	8a 81       	ldd	r24, Y+2	; 0x02
    6436:	9b 81       	ldd	r25, Y+3	; 0x03
    6438:	82 0f       	add	r24, r18
    643a:	93 1f       	adc	r25, r19
    643c:	0e 94 7c 31 	call	0x62f8	; 0x62f8 <chb_eep_read_byte>
    6440:	f8 01       	movw	r30, r16
    6442:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6444:	89 81       	ldd	r24, Y+1	; 0x01
    6446:	8f 5f       	subi	r24, 0xFF	; 255
    6448:	89 83       	std	Y+1, r24	; 0x01
    644a:	89 81       	ldd	r24, Y+1	; 0x01
    644c:	28 2f       	mov	r18, r24
    644e:	30 e0       	ldi	r19, 0x00	; 0
    6450:	8e 81       	ldd	r24, Y+6	; 0x06
    6452:	9f 81       	ldd	r25, Y+7	; 0x07
    6454:	28 17       	cp	r18, r24
    6456:	39 07       	cpc	r19, r25
    6458:	10 f3       	brcs	.-60     	; 0x641e <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    645a:	27 96       	adiw	r28, 0x07	; 7
    645c:	cd bf       	out	0x3d, r28	; 61
    645e:	de bf       	out	0x3e, r29	; 62
    6460:	df 91       	pop	r29
    6462:	cf 91       	pop	r28
    6464:	1f 91       	pop	r17
    6466:	0f 91       	pop	r16
    6468:	08 95       	ret

0000646a <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    646a:	cf 93       	push	r28
    646c:	df 93       	push	r29
    646e:	cd b7       	in	r28, 0x3d	; 61
    6470:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    6472:	80 e6       	ldi	r24, 0x60	; 96
    6474:	96 e0       	ldi	r25, 0x06	; 6
    6476:	20 e6       	ldi	r18, 0x60	; 96
    6478:	36 e0       	ldi	r19, 0x06	; 6
    647a:	f9 01       	movw	r30, r18
    647c:	20 81       	ld	r18, Z
    647e:	20 6b       	ori	r18, 0xB0	; 176
    6480:	fc 01       	movw	r30, r24
    6482:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    6484:	84 e6       	ldi	r24, 0x64	; 100
    6486:	96 e0       	ldi	r25, 0x06	; 6
    6488:	24 e6       	ldi	r18, 0x64	; 100
    648a:	36 e0       	ldi	r19, 0x06	; 6
    648c:	f9 01       	movw	r30, r18
    648e:	20 81       	ld	r18, Z
    6490:	20 61       	ori	r18, 0x10	; 16
    6492:	fc 01       	movw	r30, r24
    6494:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    6496:	80 ec       	ldi	r24, 0xC0	; 192
    6498:	99 e0       	ldi	r25, 0x09	; 9
    649a:	20 ec       	ldi	r18, 0xC0	; 192
    649c:	39 e0       	ldi	r19, 0x09	; 9
    649e:	f9 01       	movw	r30, r18
    64a0:	20 81       	ld	r18, Z
    64a2:	21 65       	ori	r18, 0x51	; 81
    64a4:	fc 01       	movw	r30, r24
    64a6:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    64a8:	84 e6       	ldi	r24, 0x64	; 100
    64aa:	96 e0       	ldi	r25, 0x06	; 6
    64ac:	24 e6       	ldi	r18, 0x64	; 100
    64ae:	36 e0       	ldi	r19, 0x06	; 6
    64b0:	f9 01       	movw	r30, r18
    64b2:	20 81       	ld	r18, Z
    64b4:	20 61       	ori	r18, 0x10	; 16
    64b6:	fc 01       	movw	r30, r24
    64b8:	20 83       	st	Z, r18
}
    64ba:	df 91       	pop	r29
    64bc:	cf 91       	pop	r28
    64be:	08 95       	ret

000064c0 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    64c0:	cf 93       	push	r28
    64c2:	df 93       	push	r29
    64c4:	0f 92       	push	r0
    64c6:	0f 92       	push	r0
    64c8:	cd b7       	in	r28, 0x3d	; 61
    64ca:	de b7       	in	r29, 0x3e	; 62
    64cc:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    64ce:	80 ec       	ldi	r24, 0xC0	; 192
    64d0:	99 e0       	ldi	r25, 0x09	; 9
    64d2:	2a 81       	ldd	r18, Y+2	; 0x02
    64d4:	fc 01       	movw	r30, r24
    64d6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    64d8:	00 00       	nop
    64da:	80 ec       	ldi	r24, 0xC0	; 192
    64dc:	99 e0       	ldi	r25, 0x09	; 9
    64de:	fc 01       	movw	r30, r24
    64e0:	82 81       	ldd	r24, Z+2	; 0x02
    64e2:	88 23       	and	r24, r24
    64e4:	d4 f7       	brge	.-12     	; 0x64da <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    64e6:	80 ec       	ldi	r24, 0xC0	; 192
    64e8:	99 e0       	ldi	r25, 0x09	; 9
    64ea:	fc 01       	movw	r30, r24
    64ec:	83 81       	ldd	r24, Z+3	; 0x03
    64ee:	89 83       	std	Y+1, r24	; 0x01
	return data;
    64f0:	89 81       	ldd	r24, Y+1	; 0x01
    64f2:	0f 90       	pop	r0
    64f4:	0f 90       	pop	r0
    64f6:	df 91       	pop	r29
    64f8:	cf 91       	pop	r28
    64fa:	08 95       	ret

000064fc <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    64fc:	0f 93       	push	r16
    64fe:	cf 93       	push	r28
    6500:	df 93       	push	r29
    6502:	00 d0       	rcall	.+0      	; 0x6504 <CCPWrite+0x8>
    6504:	00 d0       	rcall	.+0      	; 0x6506 <CCPWrite+0xa>
    6506:	cd b7       	in	r28, 0x3d	; 61
    6508:	de b7       	in	r29, 0x3e	; 62
    650a:	8c 83       	std	Y+4, r24	; 0x04
    650c:	9d 83       	std	Y+5, r25	; 0x05
    650e:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    6510:	8f e3       	ldi	r24, 0x3F	; 63
    6512:	90 e0       	ldi	r25, 0x00	; 0
    6514:	fc 01       	movw	r30, r24
    6516:	80 81       	ld	r24, Z
    6518:	8b 83       	std	Y+3, r24	; 0x03
    651a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    651c:	8c 81       	ldd	r24, Y+4	; 0x04
    651e:	9d 81       	ldd	r25, Y+5	; 0x05
    6520:	89 83       	std	Y+1, r24	; 0x01
    6522:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    6524:	8b e3       	ldi	r24, 0x3B	; 59
    6526:	90 e0       	ldi	r25, 0x00	; 0
    6528:	fc 01       	movw	r30, r24
    652a:	10 82       	st	Z, r1
#endif
	asm volatile(
    652c:	89 81       	ldd	r24, Y+1	; 0x01
    652e:	9a 81       	ldd	r25, Y+2	; 0x02
    6530:	2e 81       	ldd	r18, Y+6	; 0x06
    6532:	fc 01       	movw	r30, r24
    6534:	08 ed       	ldi	r16, 0xD8	; 216
    6536:	04 bf       	out	0x34, r16	; 52
    6538:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    653a:	8f e3       	ldi	r24, 0x3F	; 63
    653c:	90 e0       	ldi	r25, 0x00	; 0
    653e:	2b 81       	ldd	r18, Y+3	; 0x03
    6540:	fc 01       	movw	r30, r24
    6542:	20 83       	st	Z, r18
#endif
}
    6544:	26 96       	adiw	r28, 0x06	; 6
    6546:	cd bf       	out	0x3d, r28	; 61
    6548:	de bf       	out	0x3e, r29	; 62
    654a:	df 91       	pop	r29
    654c:	cf 91       	pop	r28
    654e:	0f 91       	pop	r16
    6550:	08 95       	ret

00006552 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6552:	cf 93       	push	r28
    6554:	df 93       	push	r29
    6556:	00 d0       	rcall	.+0      	; 0x6558 <CLKSYS_XOSC_Config+0x6>
    6558:	cd b7       	in	r28, 0x3d	; 61
    655a:	de b7       	in	r29, 0x3e	; 62
    655c:	89 83       	std	Y+1, r24	; 0x01
    655e:	6a 83       	std	Y+2, r22	; 0x02
    6560:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6562:	80 e5       	ldi	r24, 0x50	; 80
    6564:	90 e0       	ldi	r25, 0x00	; 0
    6566:	2a 81       	ldd	r18, Y+2	; 0x02
    6568:	22 23       	and	r18, r18
    656a:	11 f0       	breq	.+4      	; 0x6570 <CLKSYS_XOSC_Config+0x1e>
    656c:	20 e2       	ldi	r18, 0x20	; 32
    656e:	01 c0       	rjmp	.+2      	; 0x6572 <CLKSYS_XOSC_Config+0x20>
    6570:	20 e0       	ldi	r18, 0x00	; 0
    6572:	39 81       	ldd	r19, Y+1	; 0x01
    6574:	32 2b       	or	r19, r18
    6576:	2b 81       	ldd	r18, Y+3	; 0x03
    6578:	23 2b       	or	r18, r19
    657a:	fc 01       	movw	r30, r24
    657c:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    657e:	23 96       	adiw	r28, 0x03	; 3
    6580:	cd bf       	out	0x3d, r28	; 61
    6582:	de bf       	out	0x3e, r29	; 62
    6584:	df 91       	pop	r29
    6586:	cf 91       	pop	r28
    6588:	08 95       	ret

0000658a <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    658a:	cf 93       	push	r28
    658c:	df 93       	push	r29
    658e:	0f 92       	push	r0
    6590:	0f 92       	push	r0
    6592:	cd b7       	in	r28, 0x3d	; 61
    6594:	de b7       	in	r29, 0x3e	; 62
    6596:	89 83       	std	Y+1, r24	; 0x01
    6598:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    659a:	8a 81       	ldd	r24, Y+2	; 0x02
    659c:	8f 71       	andi	r24, 0x1F	; 31
    659e:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    65a0:	80 e5       	ldi	r24, 0x50	; 80
    65a2:	90 e0       	ldi	r25, 0x00	; 0
    65a4:	39 81       	ldd	r19, Y+1	; 0x01
    65a6:	2a 81       	ldd	r18, Y+2	; 0x02
    65a8:	23 2b       	or	r18, r19
    65aa:	fc 01       	movw	r30, r24
    65ac:	25 83       	std	Z+5, r18	; 0x05
}
    65ae:	0f 90       	pop	r0
    65b0:	0f 90       	pop	r0
    65b2:	df 91       	pop	r29
    65b4:	cf 91       	pop	r28
    65b6:	08 95       	ret

000065b8 <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    65b8:	cf 93       	push	r28
    65ba:	df 93       	push	r29
    65bc:	0f 92       	push	r0
    65be:	0f 92       	push	r0
    65c0:	cd b7       	in	r28, 0x3d	; 61
    65c2:	de b7       	in	r29, 0x3e	; 62
    65c4:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    65c6:	80 e5       	ldi	r24, 0x50	; 80
    65c8:	90 e0       	ldi	r25, 0x00	; 0
    65ca:	20 e5       	ldi	r18, 0x50	; 80
    65cc:	30 e0       	ldi	r19, 0x00	; 0
    65ce:	f9 01       	movw	r30, r18
    65d0:	20 81       	ld	r18, Z
    65d2:	32 2f       	mov	r19, r18
    65d4:	2a 81       	ldd	r18, Y+2	; 0x02
    65d6:	20 95       	com	r18
    65d8:	23 23       	and	r18, r19
    65da:	fc 01       	movw	r30, r24
    65dc:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    65de:	80 e5       	ldi	r24, 0x50	; 80
    65e0:	90 e0       	ldi	r25, 0x00	; 0
    65e2:	fc 01       	movw	r30, r24
    65e4:	90 81       	ld	r25, Z
    65e6:	8a 81       	ldd	r24, Y+2	; 0x02
    65e8:	89 23       	and	r24, r25
    65ea:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    65ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    65ee:	0f 90       	pop	r0
    65f0:	0f 90       	pop	r0
    65f2:	df 91       	pop	r29
    65f4:	cf 91       	pop	r28
    65f6:	08 95       	ret

000065f8 <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    65f8:	cf 93       	push	r28
    65fa:	df 93       	push	r29
    65fc:	00 d0       	rcall	.+0      	; 0x65fe <CLKSYS_Prescalers_Config+0x6>
    65fe:	cd b7       	in	r28, 0x3d	; 61
    6600:	de b7       	in	r29, 0x3e	; 62
    6602:	8a 83       	std	Y+2, r24	; 0x02
    6604:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    6606:	9a 81       	ldd	r25, Y+2	; 0x02
    6608:	8b 81       	ldd	r24, Y+3	; 0x03
    660a:	89 2b       	or	r24, r25
    660c:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    660e:	81 e4       	ldi	r24, 0x41	; 65
    6610:	90 e0       	ldi	r25, 0x00	; 0
    6612:	69 81       	ldd	r22, Y+1	; 0x01
    6614:	0e 94 7e 32 	call	0x64fc	; 0x64fc <CCPWrite>
}
    6618:	23 96       	adiw	r28, 0x03	; 3
    661a:	cd bf       	out	0x3d, r28	; 61
    661c:	de bf       	out	0x3e, r29	; 62
    661e:	df 91       	pop	r29
    6620:	cf 91       	pop	r28
    6622:	08 95       	ret

00006624 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6624:	cf 93       	push	r28
    6626:	df 93       	push	r29
    6628:	0f 92       	push	r0
    662a:	0f 92       	push	r0
    662c:	cd b7       	in	r28, 0x3d	; 61
    662e:	de b7       	in	r29, 0x3e	; 62
    6630:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    6632:	80 e4       	ldi	r24, 0x40	; 64
    6634:	90 e0       	ldi	r25, 0x00	; 0
    6636:	fc 01       	movw	r30, r24
    6638:	80 81       	ld	r24, Z
    663a:	98 2f       	mov	r25, r24
    663c:	98 7f       	andi	r25, 0xF8	; 248
    663e:	8a 81       	ldd	r24, Y+2	; 0x02
    6640:	89 2b       	or	r24, r25
    6642:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    6644:	80 e4       	ldi	r24, 0x40	; 64
    6646:	90 e0       	ldi	r25, 0x00	; 0
    6648:	69 81       	ldd	r22, Y+1	; 0x01
    664a:	0e 94 7e 32 	call	0x64fc	; 0x64fc <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    664e:	80 e4       	ldi	r24, 0x40	; 64
    6650:	90 e0       	ldi	r25, 0x00	; 0
    6652:	fc 01       	movw	r30, r24
    6654:	90 81       	ld	r25, Z
    6656:	8a 81       	ldd	r24, Y+2	; 0x02
    6658:	89 23       	and	r24, r25
    665a:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    665c:	89 81       	ldd	r24, Y+1	; 0x01
}
    665e:	0f 90       	pop	r0
    6660:	0f 90       	pop	r0
    6662:	df 91       	pop	r29
    6664:	cf 91       	pop	r28
    6666:	08 95       	ret

00006668 <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    6668:	cf 93       	push	r28
    666a:	df 93       	push	r29
    666c:	0f 92       	push	r0
    666e:	cd b7       	in	r28, 0x3d	; 61
    6670:	de b7       	in	r29, 0x3e	; 62
    6672:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6674:	80 e4       	ldi	r24, 0x40	; 64
    6676:	90 e0       	ldi	r25, 0x00	; 0
    6678:	20 e4       	ldi	r18, 0x40	; 64
    667a:	30 e0       	ldi	r19, 0x00	; 0
    667c:	f9 01       	movw	r30, r18
    667e:	23 81       	ldd	r18, Z+3	; 0x03
    6680:	32 2f       	mov	r19, r18
    6682:	31 7f       	andi	r19, 0xF1	; 241
    6684:	29 81       	ldd	r18, Y+1	; 0x01
    6686:	23 2b       	or	r18, r19
    6688:	21 60       	ori	r18, 0x01	; 1
    668a:	fc 01       	movw	r30, r24
    668c:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    668e:	0f 90       	pop	r0
    6690:	df 91       	pop	r29
    6692:	cf 91       	pop	r28
    6694:	08 95       	ret

00006696 <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    6696:	cf 93       	push	r28
    6698:	df 93       	push	r29
    669a:	0f 92       	push	r0
    669c:	0f 92       	push	r0
    669e:	cd b7       	in	r28, 0x3d	; 61
    66a0:	de b7       	in	r29, 0x3e	; 62
    66a2:	89 83       	std	Y+1, r24	; 0x01
    66a4:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    66a6:	80 e5       	ldi	r24, 0x50	; 80
    66a8:	90 e0       	ldi	r25, 0x00	; 0
    66aa:	20 e5       	ldi	r18, 0x50	; 80
    66ac:	30 e0       	ldi	r19, 0x00	; 0
    66ae:	f9 01       	movw	r30, r18
    66b0:	26 81       	ldd	r18, Z+6	; 0x06
    66b2:	32 2f       	mov	r19, r18
    66b4:	29 81       	ldd	r18, Y+1	; 0x01
    66b6:	20 95       	com	r18
    66b8:	32 23       	and	r19, r18
    66ba:	2a 81       	ldd	r18, Y+2	; 0x02
    66bc:	22 23       	and	r18, r18
    66be:	11 f0       	breq	.+4      	; 0x66c4 <CLKSYS_AutoCalibration_Enable+0x2e>
    66c0:	29 81       	ldd	r18, Y+1	; 0x01
    66c2:	01 c0       	rjmp	.+2      	; 0x66c6 <CLKSYS_AutoCalibration_Enable+0x30>
    66c4:	20 e0       	ldi	r18, 0x00	; 0
    66c6:	23 2b       	or	r18, r19
    66c8:	fc 01       	movw	r30, r24
    66ca:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    66cc:	89 81       	ldd	r24, Y+1	; 0x01
    66ce:	81 30       	cpi	r24, 0x01	; 1
    66d0:	51 f4       	brne	.+20     	; 0x66e6 <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    66d2:	88 e6       	ldi	r24, 0x68	; 104
    66d4:	90 e0       	ldi	r25, 0x00	; 0
    66d6:	28 e6       	ldi	r18, 0x68	; 104
    66d8:	30 e0       	ldi	r19, 0x00	; 0
    66da:	f9 01       	movw	r30, r18
    66dc:	20 81       	ld	r18, Z
    66de:	21 60       	ori	r18, 0x01	; 1
    66e0:	fc 01       	movw	r30, r24
    66e2:	20 83       	st	Z, r18
    66e4:	0c c0       	rjmp	.+24     	; 0x66fe <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    66e6:	89 81       	ldd	r24, Y+1	; 0x01
    66e8:	82 30       	cpi	r24, 0x02	; 2
    66ea:	49 f4       	brne	.+18     	; 0x66fe <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    66ec:	80 e6       	ldi	r24, 0x60	; 96
    66ee:	90 e0       	ldi	r25, 0x00	; 0
    66f0:	20 e6       	ldi	r18, 0x60	; 96
    66f2:	30 e0       	ldi	r19, 0x00	; 0
    66f4:	f9 01       	movw	r30, r18
    66f6:	20 81       	ld	r18, Z
    66f8:	21 60       	ori	r18, 0x01	; 1
    66fa:	fc 01       	movw	r30, r24
    66fc:	20 83       	st	Z, r18
	}
}
    66fe:	0f 90       	pop	r0
    6700:	0f 90       	pop	r0
    6702:	df 91       	pop	r29
    6704:	cf 91       	pop	r28
    6706:	08 95       	ret

00006708 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    6708:	cf 93       	push	r28
    670a:	df 93       	push	r29
    670c:	cd b7       	in	r28, 0x3d	; 61
    670e:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    6710:	83 e5       	ldi	r24, 0x53	; 83
    6712:	90 e0       	ldi	r25, 0x00	; 0
    6714:	63 e0       	ldi	r22, 0x03	; 3
    6716:	0e 94 7e 32 	call	0x64fc	; 0x64fc <CCPWrite>
}
    671a:	df 91       	pop	r29
    671c:	cf 91       	pop	r28
    671e:	08 95       	ret

00006720 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    6720:	cf 93       	push	r28
    6722:	df 93       	push	r29
    6724:	cd b7       	in	r28, 0x3d	; 61
    6726:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    6728:	82 e4       	ldi	r24, 0x42	; 66
    672a:	90 e0       	ldi	r25, 0x00	; 0
    672c:	61 e0       	ldi	r22, 0x01	; 1
    672e:	0e 94 7e 32 	call	0x64fc	; 0x64fc <CCPWrite>
}
    6732:	df 91       	pop	r29
    6734:	cf 91       	pop	r28
    6736:	08 95       	ret

00006738 <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    6738:	cf 93       	push	r28
    673a:	df 93       	push	r29
    673c:	cd b7       	in	r28, 0x3d	; 61
    673e:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6740:	80 ec       	ldi	r24, 0xC0	; 192
    6742:	60 e0       	ldi	r22, 0x00	; 0
    6744:	4b e0       	ldi	r20, 0x0B	; 11
    6746:	0e 94 a9 32 	call	0x6552	; 0x6552 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    674a:	80 e5       	ldi	r24, 0x50	; 80
    674c:	90 e0       	ldi	r25, 0x00	; 0
    674e:	20 e5       	ldi	r18, 0x50	; 80
    6750:	30 e0       	ldi	r19, 0x00	; 0
    6752:	f9 01       	movw	r30, r18
    6754:	20 81       	ld	r18, Z
    6756:	28 60       	ori	r18, 0x08	; 8
    6758:	fc 01       	movw	r30, r24
    675a:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    675c:	80 e5       	ldi	r24, 0x50	; 80
    675e:	90 e0       	ldi	r25, 0x00	; 0
    6760:	fc 01       	movw	r30, r24
    6762:	81 81       	ldd	r24, Z+1	; 0x01
    6764:	88 2f       	mov	r24, r24
    6766:	90 e0       	ldi	r25, 0x00	; 0
    6768:	88 70       	andi	r24, 0x08	; 8
    676a:	90 70       	andi	r25, 0x00	; 0
    676c:	00 97       	sbiw	r24, 0x00	; 0
    676e:	b1 f3       	breq	.-20     	; 0x675c <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6770:	80 ec       	ldi	r24, 0xC0	; 192
    6772:	62 e0       	ldi	r22, 0x02	; 2
    6774:	0e 94 c5 32 	call	0x658a	; 0x658a <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    6778:	80 e5       	ldi	r24, 0x50	; 80
    677a:	90 e0       	ldi	r25, 0x00	; 0
    677c:	20 e5       	ldi	r18, 0x50	; 80
    677e:	30 e0       	ldi	r19, 0x00	; 0
    6780:	f9 01       	movw	r30, r18
    6782:	20 81       	ld	r18, Z
    6784:	20 61       	ori	r18, 0x10	; 16
    6786:	fc 01       	movw	r30, r24
    6788:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    678a:	80 e5       	ldi	r24, 0x50	; 80
    678c:	90 e0       	ldi	r25, 0x00	; 0
    678e:	fc 01       	movw	r30, r24
    6790:	81 81       	ldd	r24, Z+1	; 0x01
    6792:	88 2f       	mov	r24, r24
    6794:	90 e0       	ldi	r25, 0x00	; 0
    6796:	80 71       	andi	r24, 0x10	; 16
    6798:	90 70       	andi	r25, 0x00	; 0
    679a:	00 97       	sbiw	r24, 0x00	; 0
    679c:	b1 f3       	breq	.-20     	; 0x678a <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    679e:	84 e0       	ldi	r24, 0x04	; 4
    67a0:	0e 94 12 33 	call	0x6624	; 0x6624 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    67a4:	81 e0       	ldi	r24, 0x01	; 1
    67a6:	0e 94 dc 32 	call	0x65b8	; 0x65b8 <CLKSYS_Disable>
}
    67aa:	df 91       	pop	r29
    67ac:	cf 91       	pop	r28
    67ae:	08 95       	ret

000067b0 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    67b0:	cf 93       	push	r28
    67b2:	df 93       	push	r29
    67b4:	cd b7       	in	r28, 0x3d	; 61
    67b6:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    67b8:	80 e5       	ldi	r24, 0x50	; 80
    67ba:	90 e0       	ldi	r25, 0x00	; 0
    67bc:	20 e5       	ldi	r18, 0x50	; 80
    67be:	30 e0       	ldi	r19, 0x00	; 0
    67c0:	f9 01       	movw	r30, r18
    67c2:	20 81       	ld	r18, Z
    67c4:	22 60       	ori	r18, 0x02	; 2
    67c6:	fc 01       	movw	r30, r24
    67c8:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    67ca:	80 e0       	ldi	r24, 0x00	; 0
    67cc:	61 e0       	ldi	r22, 0x01	; 1
    67ce:	0e 94 fc 32 	call	0x65f8	; 0x65f8 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    67d2:	80 e5       	ldi	r24, 0x50	; 80
    67d4:	90 e0       	ldi	r25, 0x00	; 0
    67d6:	fc 01       	movw	r30, r24
    67d8:	81 81       	ldd	r24, Z+1	; 0x01
    67da:	88 2f       	mov	r24, r24
    67dc:	90 e0       	ldi	r25, 0x00	; 0
    67de:	82 70       	andi	r24, 0x02	; 2
    67e0:	90 70       	andi	r25, 0x00	; 0
    67e2:	00 97       	sbiw	r24, 0x00	; 0
    67e4:	b1 f3       	breq	.-20     	; 0x67d2 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    67e6:	81 e0       	ldi	r24, 0x01	; 1
    67e8:	0e 94 12 33 	call	0x6624	; 0x6624 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    67ec:	81 e0       	ldi	r24, 0x01	; 1
    67ee:	0e 94 dc 32 	call	0x65b8	; 0x65b8 <CLKSYS_Disable>
	
}
    67f2:	df 91       	pop	r29
    67f4:	cf 91       	pop	r28
    67f6:	08 95       	ret

000067f8 <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    67f8:	cf 93       	push	r28
    67fa:	df 93       	push	r29
    67fc:	cd b7       	in	r28, 0x3d	; 61
    67fe:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6800:	80 e5       	ldi	r24, 0x50	; 80
    6802:	90 e0       	ldi	r25, 0x00	; 0
    6804:	20 e5       	ldi	r18, 0x50	; 80
    6806:	30 e0       	ldi	r19, 0x00	; 0
    6808:	f9 01       	movw	r30, r18
    680a:	20 81       	ld	r18, Z
    680c:	22 60       	ori	r18, 0x02	; 2
    680e:	fc 01       	movw	r30, r24
    6810:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6812:	80 e0       	ldi	r24, 0x00	; 0
    6814:	60 e0       	ldi	r22, 0x00	; 0
    6816:	0e 94 fc 32 	call	0x65f8	; 0x65f8 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    681a:	80 e5       	ldi	r24, 0x50	; 80
    681c:	90 e0       	ldi	r25, 0x00	; 0
    681e:	fc 01       	movw	r30, r24
    6820:	81 81       	ldd	r24, Z+1	; 0x01
    6822:	88 2f       	mov	r24, r24
    6824:	90 e0       	ldi	r25, 0x00	; 0
    6826:	82 70       	andi	r24, 0x02	; 2
    6828:	90 70       	andi	r25, 0x00	; 0
    682a:	00 97       	sbiw	r24, 0x00	; 0
    682c:	b1 f3       	breq	.-20     	; 0x681a <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    682e:	81 e0       	ldi	r24, 0x01	; 1
    6830:	0e 94 12 33 	call	0x6624	; 0x6624 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6834:	81 e0       	ldi	r24, 0x01	; 1
    6836:	0e 94 dc 32 	call	0x65b8	; 0x65b8 <CLKSYS_Disable>
	
}
    683a:	df 91       	pop	r29
    683c:	cf 91       	pop	r28
    683e:	08 95       	ret

00006840 <portExCS>:


void portExCS(uint8_t write) {
    6840:	0f 93       	push	r16
    6842:	1f 93       	push	r17
    6844:	cf 93       	push	r28
    6846:	df 93       	push	r29
    6848:	cd b7       	in	r28, 0x3d	; 61
    684a:	de b7       	in	r29, 0x3e	; 62
    684c:	69 97       	sbiw	r28, 0x19	; 25
    684e:	cd bf       	out	0x3d, r28	; 61
    6850:	de bf       	out	0x3e, r29	; 62
    6852:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6854:	89 8d       	ldd	r24, Y+25	; 0x19
    6856:	88 23       	and	r24, r24
    6858:	31 f0       	breq	.+12     	; 0x6866 <portExCS+0x26>
    685a:	80 e0       	ldi	r24, 0x00	; 0
    685c:	96 e0       	ldi	r25, 0x06	; 6
    685e:	28 e0       	ldi	r18, 0x08	; 8
    6860:	fc 01       	movw	r30, r24
    6862:	26 83       	std	Z+6, r18	; 0x06
    6864:	05 c0       	rjmp	.+10     	; 0x6870 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    6866:	80 e0       	ldi	r24, 0x00	; 0
    6868:	96 e0       	ldi	r25, 0x06	; 6
    686a:	28 e0       	ldi	r18, 0x08	; 8
    686c:	fc 01       	movw	r30, r24
    686e:	25 83       	std	Z+5, r18	; 0x05
    6870:	80 e0       	ldi	r24, 0x00	; 0
    6872:	90 e0       	ldi	r25, 0x00	; 0
    6874:	a0 e2       	ldi	r26, 0x20	; 32
    6876:	b1 e4       	ldi	r27, 0x41	; 65
    6878:	89 83       	std	Y+1, r24	; 0x01
    687a:	9a 83       	std	Y+2, r25	; 0x02
    687c:	ab 83       	std	Y+3, r26	; 0x03
    687e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6880:	69 81       	ldd	r22, Y+1	; 0x01
    6882:	7a 81       	ldd	r23, Y+2	; 0x02
    6884:	8b 81       	ldd	r24, Y+3	; 0x03
    6886:	9c 81       	ldd	r25, Y+4	; 0x04
    6888:	2b ea       	ldi	r18, 0xAB	; 171
    688a:	3a ea       	ldi	r19, 0xAA	; 170
    688c:	4a e2       	ldi	r20, 0x2A	; 42
    688e:	51 e4       	ldi	r21, 0x41	; 65
    6890:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    6894:	dc 01       	movw	r26, r24
    6896:	cb 01       	movw	r24, r22
    6898:	8d 83       	std	Y+5, r24	; 0x05
    689a:	9e 83       	std	Y+6, r25	; 0x06
    689c:	af 83       	std	Y+7, r26	; 0x07
    689e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    68a0:	11 e0       	ldi	r17, 0x01	; 1
    68a2:	6d 81       	ldd	r22, Y+5	; 0x05
    68a4:	7e 81       	ldd	r23, Y+6	; 0x06
    68a6:	8f 81       	ldd	r24, Y+7	; 0x07
    68a8:	98 85       	ldd	r25, Y+8	; 0x08
    68aa:	20 e0       	ldi	r18, 0x00	; 0
    68ac:	30 e0       	ldi	r19, 0x00	; 0
    68ae:	40 e8       	ldi	r20, 0x80	; 128
    68b0:	5f e3       	ldi	r21, 0x3F	; 63
    68b2:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    68b6:	88 23       	and	r24, r24
    68b8:	0c f0       	brlt	.+2      	; 0x68bc <portExCS+0x7c>
    68ba:	10 e0       	ldi	r17, 0x00	; 0
    68bc:	11 23       	and	r17, r17
    68be:	19 f0       	breq	.+6      	; 0x68c6 <portExCS+0x86>
		__ticks = 1;
    68c0:	81 e0       	ldi	r24, 0x01	; 1
    68c2:	89 87       	std	Y+9, r24	; 0x09
    68c4:	a3 c0       	rjmp	.+326    	; 0x6a0c <portExCS+0x1cc>
	else if (__tmp > 255)
    68c6:	11 e0       	ldi	r17, 0x01	; 1
    68c8:	6d 81       	ldd	r22, Y+5	; 0x05
    68ca:	7e 81       	ldd	r23, Y+6	; 0x06
    68cc:	8f 81       	ldd	r24, Y+7	; 0x07
    68ce:	98 85       	ldd	r25, Y+8	; 0x08
    68d0:	20 e0       	ldi	r18, 0x00	; 0
    68d2:	30 e0       	ldi	r19, 0x00	; 0
    68d4:	4f e7       	ldi	r20, 0x7F	; 127
    68d6:	53 e4       	ldi	r21, 0x43	; 67
    68d8:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    68dc:	18 16       	cp	r1, r24
    68de:	0c f0       	brlt	.+2      	; 0x68e2 <portExCS+0xa2>
    68e0:	10 e0       	ldi	r17, 0x00	; 0
    68e2:	11 23       	and	r17, r17
    68e4:	09 f4       	brne	.+2      	; 0x68e8 <portExCS+0xa8>
    68e6:	89 c0       	rjmp	.+274    	; 0x69fa <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    68e8:	69 81       	ldd	r22, Y+1	; 0x01
    68ea:	7a 81       	ldd	r23, Y+2	; 0x02
    68ec:	8b 81       	ldd	r24, Y+3	; 0x03
    68ee:	9c 81       	ldd	r25, Y+4	; 0x04
    68f0:	20 e0       	ldi	r18, 0x00	; 0
    68f2:	30 e0       	ldi	r19, 0x00	; 0
    68f4:	4a e7       	ldi	r20, 0x7A	; 122
    68f6:	54 e4       	ldi	r21, 0x44	; 68
    68f8:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    68fc:	dc 01       	movw	r26, r24
    68fe:	cb 01       	movw	r24, r22
    6900:	8a 87       	std	Y+10, r24	; 0x0a
    6902:	9b 87       	std	Y+11, r25	; 0x0b
    6904:	ac 87       	std	Y+12, r26	; 0x0c
    6906:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6908:	6a 85       	ldd	r22, Y+10	; 0x0a
    690a:	7b 85       	ldd	r23, Y+11	; 0x0b
    690c:	8c 85       	ldd	r24, Y+12	; 0x0c
    690e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6910:	20 e0       	ldi	r18, 0x00	; 0
    6912:	30 e0       	ldi	r19, 0x00	; 0
    6914:	4a ef       	ldi	r20, 0xFA	; 250
    6916:	55 e4       	ldi	r21, 0x45	; 69
    6918:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    691c:	dc 01       	movw	r26, r24
    691e:	cb 01       	movw	r24, r22
    6920:	8e 87       	std	Y+14, r24	; 0x0e
    6922:	9f 87       	std	Y+15, r25	; 0x0f
    6924:	a8 8b       	std	Y+16, r26	; 0x10
    6926:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    6928:	11 e0       	ldi	r17, 0x01	; 1
    692a:	6e 85       	ldd	r22, Y+14	; 0x0e
    692c:	7f 85       	ldd	r23, Y+15	; 0x0f
    692e:	88 89       	ldd	r24, Y+16	; 0x10
    6930:	99 89       	ldd	r25, Y+17	; 0x11
    6932:	20 e0       	ldi	r18, 0x00	; 0
    6934:	30 e0       	ldi	r19, 0x00	; 0
    6936:	40 e8       	ldi	r20, 0x80	; 128
    6938:	5f e3       	ldi	r21, 0x3F	; 63
    693a:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    693e:	88 23       	and	r24, r24
    6940:	0c f0       	brlt	.+2      	; 0x6944 <portExCS+0x104>
    6942:	10 e0       	ldi	r17, 0x00	; 0
    6944:	11 23       	and	r17, r17
    6946:	29 f0       	breq	.+10     	; 0x6952 <portExCS+0x112>
		__ticks = 1;
    6948:	81 e0       	ldi	r24, 0x01	; 1
    694a:	90 e0       	ldi	r25, 0x00	; 0
    694c:	8a 8b       	std	Y+18, r24	; 0x12
    694e:	9b 8b       	std	Y+19, r25	; 0x13
    6950:	46 c0       	rjmp	.+140    	; 0x69de <portExCS+0x19e>
	else if (__tmp > 65535)
    6952:	11 e0       	ldi	r17, 0x01	; 1
    6954:	6e 85       	ldd	r22, Y+14	; 0x0e
    6956:	7f 85       	ldd	r23, Y+15	; 0x0f
    6958:	88 89       	ldd	r24, Y+16	; 0x10
    695a:	99 89       	ldd	r25, Y+17	; 0x11
    695c:	20 e0       	ldi	r18, 0x00	; 0
    695e:	3f ef       	ldi	r19, 0xFF	; 255
    6960:	4f e7       	ldi	r20, 0x7F	; 127
    6962:	57 e4       	ldi	r21, 0x47	; 71
    6964:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    6968:	18 16       	cp	r1, r24
    696a:	0c f0       	brlt	.+2      	; 0x696e <portExCS+0x12e>
    696c:	10 e0       	ldi	r17, 0x00	; 0
    696e:	11 23       	and	r17, r17
    6970:	61 f1       	breq	.+88     	; 0x69ca <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6972:	6a 85       	ldd	r22, Y+10	; 0x0a
    6974:	7b 85       	ldd	r23, Y+11	; 0x0b
    6976:	8c 85       	ldd	r24, Y+12	; 0x0c
    6978:	9d 85       	ldd	r25, Y+13	; 0x0d
    697a:	20 e0       	ldi	r18, 0x00	; 0
    697c:	30 e0       	ldi	r19, 0x00	; 0
    697e:	40 e2       	ldi	r20, 0x20	; 32
    6980:	51 e4       	ldi	r21, 0x41	; 65
    6982:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    6986:	dc 01       	movw	r26, r24
    6988:	cb 01       	movw	r24, r22
    698a:	bc 01       	movw	r22, r24
    698c:	cd 01       	movw	r24, r26
    698e:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    6992:	dc 01       	movw	r26, r24
    6994:	cb 01       	movw	r24, r22
    6996:	8a 8b       	std	Y+18, r24	; 0x12
    6998:	9b 8b       	std	Y+19, r25	; 0x13
    699a:	12 c0       	rjmp	.+36     	; 0x69c0 <portExCS+0x180>
    699c:	80 e2       	ldi	r24, 0x20	; 32
    699e:	93 e0       	ldi	r25, 0x03	; 3
    69a0:	8c 8b       	std	Y+20, r24	; 0x14
    69a2:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    69a4:	8c 89       	ldd	r24, Y+20	; 0x14
    69a6:	9d 89       	ldd	r25, Y+21	; 0x15
    69a8:	8c 01       	movw	r16, r24
    69aa:	c8 01       	movw	r24, r16
    69ac:	01 97       	sbiw	r24, 0x01	; 1
    69ae:	f1 f7       	brne	.-4      	; 0x69ac <portExCS+0x16c>
    69b0:	8c 01       	movw	r16, r24
    69b2:	0c 8b       	std	Y+20, r16	; 0x14
    69b4:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    69b6:	8a 89       	ldd	r24, Y+18	; 0x12
    69b8:	9b 89       	ldd	r25, Y+19	; 0x13
    69ba:	01 97       	sbiw	r24, 0x01	; 1
    69bc:	8a 8b       	std	Y+18, r24	; 0x12
    69be:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    69c0:	8a 89       	ldd	r24, Y+18	; 0x12
    69c2:	9b 89       	ldd	r25, Y+19	; 0x13
    69c4:	00 97       	sbiw	r24, 0x00	; 0
    69c6:	51 f7       	brne	.-44     	; 0x699c <portExCS+0x15c>
    69c8:	28 c0       	rjmp	.+80     	; 0x6a1a <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    69ca:	6e 85       	ldd	r22, Y+14	; 0x0e
    69cc:	7f 85       	ldd	r23, Y+15	; 0x0f
    69ce:	88 89       	ldd	r24, Y+16	; 0x10
    69d0:	99 89       	ldd	r25, Y+17	; 0x11
    69d2:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    69d6:	dc 01       	movw	r26, r24
    69d8:	cb 01       	movw	r24, r22
    69da:	8a 8b       	std	Y+18, r24	; 0x12
    69dc:	9b 8b       	std	Y+19, r25	; 0x13
    69de:	8a 89       	ldd	r24, Y+18	; 0x12
    69e0:	9b 89       	ldd	r25, Y+19	; 0x13
    69e2:	8e 8b       	std	Y+22, r24	; 0x16
    69e4:	9f 8b       	std	Y+23, r25	; 0x17
    69e6:	8e 89       	ldd	r24, Y+22	; 0x16
    69e8:	9f 89       	ldd	r25, Y+23	; 0x17
    69ea:	8c 01       	movw	r16, r24
    69ec:	f8 01       	movw	r30, r16
    69ee:	31 97       	sbiw	r30, 0x01	; 1
    69f0:	f1 f7       	brne	.-4      	; 0x69ee <portExCS+0x1ae>
    69f2:	8f 01       	movw	r16, r30
    69f4:	0e 8b       	std	Y+22, r16	; 0x16
    69f6:	1f 8b       	std	Y+23, r17	; 0x17
    69f8:	10 c0       	rjmp	.+32     	; 0x6a1a <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    69fa:	6d 81       	ldd	r22, Y+5	; 0x05
    69fc:	7e 81       	ldd	r23, Y+6	; 0x06
    69fe:	8f 81       	ldd	r24, Y+7	; 0x07
    6a00:	98 85       	ldd	r25, Y+8	; 0x08
    6a02:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    6a06:	dc 01       	movw	r26, r24
    6a08:	cb 01       	movw	r24, r22
    6a0a:	89 87       	std	Y+9, r24	; 0x09
    6a0c:	89 85       	ldd	r24, Y+9	; 0x09
    6a0e:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6a10:	88 8d       	ldd	r24, Y+24	; 0x18
    6a12:	18 2f       	mov	r17, r24
    6a14:	1a 95       	dec	r17
    6a16:	f1 f7       	brne	.-4      	; 0x6a14 <portExCS+0x1d4>
    6a18:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    6a1a:	69 96       	adiw	r28, 0x19	; 25
    6a1c:	cd bf       	out	0x3d, r28	; 61
    6a1e:	de bf       	out	0x3e, r29	; 62
    6a20:	df 91       	pop	r29
    6a22:	cf 91       	pop	r28
    6a24:	1f 91       	pop	r17
    6a26:	0f 91       	pop	r16
    6a28:	08 95       	ret

00006a2a <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    6a2a:	cf 93       	push	r28
    6a2c:	df 93       	push	r29
    6a2e:	00 d0       	rcall	.+0      	; 0x6a30 <PortEx_DIRSET+0x6>
    6a30:	cd b7       	in	r28, 0x3d	; 61
    6a32:	de b7       	in	r29, 0x3e	; 62
    6a34:	8a 83       	std	Y+2, r24	; 0x02
    6a36:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6a38:	80 e0       	ldi	r24, 0x00	; 0
    6a3a:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    6a3e:	81 e0       	ldi	r24, 0x01	; 1
    6a40:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	portExCS(TRUE);
    6a44:	81 e0       	ldi	r24, 0x01	; 1
    6a46:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    6a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a4c:	88 23       	and	r24, r24
    6a4e:	39 f0       	breq	.+14     	; 0x6a5e <PortEx_DIRSET+0x34>
    6a50:	90 91 77 50 	lds	r25, 0x5077
    6a54:	8a 81       	ldd	r24, Y+2	; 0x02
    6a56:	89 2b       	or	r24, r25
    6a58:	80 93 77 50 	sts	0x5077, r24
    6a5c:	06 c0       	rjmp	.+12     	; 0x6a6a <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6a5e:	90 91 d2 50 	lds	r25, 0x50D2
    6a62:	8a 81       	ldd	r24, Y+2	; 0x02
    6a64:	89 2b       	or	r24, r25
    6a66:	80 93 d2 50 	sts	0x50D2, r24
	
	SPIBuffer[0] = PS_WRITE;
    6a6a:	80 e4       	ldi	r24, 0x40	; 64
    6a6c:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6a70:	8b 81       	ldd	r24, Y+3	; 0x03
    6a72:	88 23       	and	r24, r24
    6a74:	41 f0       	breq	.+16     	; 0x6a86 <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    6a76:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6a7a:	80 91 77 50 	lds	r24, 0x5077
    6a7e:	80 95       	com	r24
    6a80:	80 93 68 50 	sts	0x5068, r24
    6a84:	08 c0       	rjmp	.+16     	; 0x6a96 <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6a86:	81 e0       	ldi	r24, 0x01	; 1
    6a88:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    6a8c:	80 91 d2 50 	lds	r24, 0x50D2
    6a90:	80 95       	com	r24
    6a92:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6a96:	19 82       	std	Y+1, r1	; 0x01
    6a98:	1b c0       	rjmp	.+54     	; 0x6ad0 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    6a9a:	80 ec       	ldi	r24, 0xC0	; 192
    6a9c:	98 e0       	ldi	r25, 0x08	; 8
    6a9e:	29 81       	ldd	r18, Y+1	; 0x01
    6aa0:	22 2f       	mov	r18, r18
    6aa2:	30 e0       	ldi	r19, 0x00	; 0
    6aa4:	2a 59       	subi	r18, 0x9A	; 154
    6aa6:	3f 4a       	sbci	r19, 0xAF	; 175
    6aa8:	f9 01       	movw	r30, r18
    6aaa:	20 81       	ld	r18, Z
    6aac:	fc 01       	movw	r30, r24
    6aae:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6ab0:	00 00       	nop
    6ab2:	80 ec       	ldi	r24, 0xC0	; 192
    6ab4:	98 e0       	ldi	r25, 0x08	; 8
    6ab6:	fc 01       	movw	r30, r24
    6ab8:	82 81       	ldd	r24, Z+2	; 0x02
    6aba:	88 23       	and	r24, r24
    6abc:	d4 f7       	brge	.-12     	; 0x6ab2 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6abe:	80 ec       	ldi	r24, 0xC0	; 192
    6ac0:	98 e0       	ldi	r25, 0x08	; 8
    6ac2:	fc 01       	movw	r30, r24
    6ac4:	83 81       	ldd	r24, Z+3	; 0x03
    6ac6:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6aca:	89 81       	ldd	r24, Y+1	; 0x01
    6acc:	8f 5f       	subi	r24, 0xFF	; 255
    6ace:	89 83       	std	Y+1, r24	; 0x01
    6ad0:	89 81       	ldd	r24, Y+1	; 0x01
    6ad2:	83 30       	cpi	r24, 0x03	; 3
    6ad4:	10 f3       	brcs	.-60     	; 0x6a9a <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    6ad6:	80 e0       	ldi	r24, 0x00	; 0
    6ad8:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>
	SPICS(FALSE);
    6adc:	80 e0       	ldi	r24, 0x00	; 0
    6ade:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    6ae2:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>


}
    6ae6:	23 96       	adiw	r28, 0x03	; 3
    6ae8:	cd bf       	out	0x3d, r28	; 61
    6aea:	de bf       	out	0x3e, r29	; 62
    6aec:	df 91       	pop	r29
    6aee:	cf 91       	pop	r28
    6af0:	08 95       	ret

00006af2 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6af2:	cf 93       	push	r28
    6af4:	df 93       	push	r29
    6af6:	00 d0       	rcall	.+0      	; 0x6af8 <PortEx_DIRCLR+0x6>
    6af8:	cd b7       	in	r28, 0x3d	; 61
    6afa:	de b7       	in	r29, 0x3e	; 62
    6afc:	8a 83       	std	Y+2, r24	; 0x02
    6afe:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6b00:	80 e0       	ldi	r24, 0x00	; 0
    6b02:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    6b06:	81 e0       	ldi	r24, 0x01	; 1
    6b08:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	portExCS(TRUE);
    6b0c:	81 e0       	ldi	r24, 0x01	; 1
    6b0e:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6b12:	8b 81       	ldd	r24, Y+3	; 0x03
    6b14:	88 23       	and	r24, r24
    6b16:	49 f0       	breq	.+18     	; 0x6b2a <PortEx_DIRCLR+0x38>
    6b18:	80 91 77 50 	lds	r24, 0x5077
    6b1c:	98 2f       	mov	r25, r24
    6b1e:	90 95       	com	r25
    6b20:	8a 81       	ldd	r24, Y+2	; 0x02
    6b22:	89 23       	and	r24, r25
    6b24:	80 93 77 50 	sts	0x5077, r24
    6b28:	08 c0       	rjmp	.+16     	; 0x6b3a <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    6b2a:	80 91 d2 50 	lds	r24, 0x50D2
    6b2e:	98 2f       	mov	r25, r24
    6b30:	90 95       	com	r25
    6b32:	8a 81       	ldd	r24, Y+2	; 0x02
    6b34:	89 23       	and	r24, r25
    6b36:	80 93 d2 50 	sts	0x50D2, r24
	
	SPIBuffer[0] = PS_WRITE;
    6b3a:	80 e4       	ldi	r24, 0x40	; 64
    6b3c:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6b40:	8b 81       	ldd	r24, Y+3	; 0x03
    6b42:	88 23       	and	r24, r24
    6b44:	41 f0       	breq	.+16     	; 0x6b56 <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    6b46:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6b4a:	80 91 77 50 	lds	r24, 0x5077
    6b4e:	80 95       	com	r24
    6b50:	80 93 68 50 	sts	0x5068, r24
    6b54:	08 c0       	rjmp	.+16     	; 0x6b66 <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6b56:	81 e0       	ldi	r24, 0x01	; 1
    6b58:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    6b5c:	80 91 d2 50 	lds	r24, 0x50D2
    6b60:	80 95       	com	r24
    6b62:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6b66:	19 82       	std	Y+1, r1	; 0x01
    6b68:	1b c0       	rjmp	.+54     	; 0x6ba0 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    6b6a:	80 ec       	ldi	r24, 0xC0	; 192
    6b6c:	98 e0       	ldi	r25, 0x08	; 8
    6b6e:	29 81       	ldd	r18, Y+1	; 0x01
    6b70:	22 2f       	mov	r18, r18
    6b72:	30 e0       	ldi	r19, 0x00	; 0
    6b74:	2a 59       	subi	r18, 0x9A	; 154
    6b76:	3f 4a       	sbci	r19, 0xAF	; 175
    6b78:	f9 01       	movw	r30, r18
    6b7a:	20 81       	ld	r18, Z
    6b7c:	fc 01       	movw	r30, r24
    6b7e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6b80:	00 00       	nop
    6b82:	80 ec       	ldi	r24, 0xC0	; 192
    6b84:	98 e0       	ldi	r25, 0x08	; 8
    6b86:	fc 01       	movw	r30, r24
    6b88:	82 81       	ldd	r24, Z+2	; 0x02
    6b8a:	88 23       	and	r24, r24
    6b8c:	d4 f7       	brge	.-12     	; 0x6b82 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6b8e:	80 ec       	ldi	r24, 0xC0	; 192
    6b90:	98 e0       	ldi	r25, 0x08	; 8
    6b92:	fc 01       	movw	r30, r24
    6b94:	83 81       	ldd	r24, Z+3	; 0x03
    6b96:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6b9a:	89 81       	ldd	r24, Y+1	; 0x01
    6b9c:	8f 5f       	subi	r24, 0xFF	; 255
    6b9e:	89 83       	std	Y+1, r24	; 0x01
    6ba0:	89 81       	ldd	r24, Y+1	; 0x01
    6ba2:	83 30       	cpi	r24, 0x03	; 3
    6ba4:	10 f3       	brcs	.-60     	; 0x6b6a <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6ba6:	80 e0       	ldi	r24, 0x00	; 0
    6ba8:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	portExCS(FALSE);
    6bac:	80 e0       	ldi	r24, 0x00	; 0
    6bae:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>
	SPIDisable();
    6bb2:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
}
    6bb6:	23 96       	adiw	r28, 0x03	; 3
    6bb8:	cd bf       	out	0x3d, r28	; 61
    6bba:	de bf       	out	0x3e, r29	; 62
    6bbc:	df 91       	pop	r29
    6bbe:	cf 91       	pop	r28
    6bc0:	08 95       	ret

00006bc2 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6bc2:	cf 93       	push	r28
    6bc4:	df 93       	push	r29
    6bc6:	00 d0       	rcall	.+0      	; 0x6bc8 <PortEx_OUTSET+0x6>
    6bc8:	cd b7       	in	r28, 0x3d	; 61
    6bca:	de b7       	in	r29, 0x3e	; 62
    6bcc:	8a 83       	std	Y+2, r24	; 0x02
    6bce:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6bd0:	80 e0       	ldi	r24, 0x00	; 0
    6bd2:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    6bd6:	81 e0       	ldi	r24, 0x01	; 1
    6bd8:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	portExCS(TRUE);
    6bdc:	81 e0       	ldi	r24, 0x01	; 1
    6bde:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6be2:	8b 81       	ldd	r24, Y+3	; 0x03
    6be4:	88 23       	and	r24, r24
    6be6:	39 f0       	breq	.+14     	; 0x6bf6 <PortEx_OUTSET+0x34>
    6be8:	90 91 d7 23 	lds	r25, 0x23D7
    6bec:	8a 81       	ldd	r24, Y+2	; 0x02
    6bee:	89 2b       	or	r24, r25
    6bf0:	80 93 d7 23 	sts	0x23D7, r24
    6bf4:	06 c0       	rjmp	.+12     	; 0x6c02 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6bf6:	90 91 7f 50 	lds	r25, 0x507F
    6bfa:	8a 81       	ldd	r24, Y+2	; 0x02
    6bfc:	89 2b       	or	r24, r25
    6bfe:	80 93 7f 50 	sts	0x507F, r24
	
	SPIBuffer[0] = PS_WRITE;
    6c02:	80 e4       	ldi	r24, 0x40	; 64
    6c04:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6c08:	8b 81       	ldd	r24, Y+3	; 0x03
    6c0a:	88 23       	and	r24, r24
    6c0c:	41 f0       	breq	.+16     	; 0x6c1e <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6c0e:	84 e1       	ldi	r24, 0x14	; 20
    6c10:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    6c14:	80 91 d7 23 	lds	r24, 0x23D7
    6c18:	80 93 68 50 	sts	0x5068, r24
    6c1c:	07 c0       	rjmp	.+14     	; 0x6c2c <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6c1e:	85 e1       	ldi	r24, 0x15	; 21
    6c20:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    6c24:	80 91 7f 50 	lds	r24, 0x507F
    6c28:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6c2c:	19 82       	std	Y+1, r1	; 0x01
    6c2e:	1b c0       	rjmp	.+54     	; 0x6c66 <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6c30:	80 ec       	ldi	r24, 0xC0	; 192
    6c32:	98 e0       	ldi	r25, 0x08	; 8
    6c34:	29 81       	ldd	r18, Y+1	; 0x01
    6c36:	22 2f       	mov	r18, r18
    6c38:	30 e0       	ldi	r19, 0x00	; 0
    6c3a:	2a 59       	subi	r18, 0x9A	; 154
    6c3c:	3f 4a       	sbci	r19, 0xAF	; 175
    6c3e:	f9 01       	movw	r30, r18
    6c40:	20 81       	ld	r18, Z
    6c42:	fc 01       	movw	r30, r24
    6c44:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6c46:	00 00       	nop
    6c48:	80 ec       	ldi	r24, 0xC0	; 192
    6c4a:	98 e0       	ldi	r25, 0x08	; 8
    6c4c:	fc 01       	movw	r30, r24
    6c4e:	82 81       	ldd	r24, Z+2	; 0x02
    6c50:	88 23       	and	r24, r24
    6c52:	d4 f7       	brge	.-12     	; 0x6c48 <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6c54:	80 ec       	ldi	r24, 0xC0	; 192
    6c56:	98 e0       	ldi	r25, 0x08	; 8
    6c58:	fc 01       	movw	r30, r24
    6c5a:	83 81       	ldd	r24, Z+3	; 0x03
    6c5c:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6c60:	89 81       	ldd	r24, Y+1	; 0x01
    6c62:	8f 5f       	subi	r24, 0xFF	; 255
    6c64:	89 83       	std	Y+1, r24	; 0x01
    6c66:	89 81       	ldd	r24, Y+1	; 0x01
    6c68:	83 30       	cpi	r24, 0x03	; 3
    6c6a:	10 f3       	brcs	.-60     	; 0x6c30 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6c6c:	80 e0       	ldi	r24, 0x00	; 0
    6c6e:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	portExCS(FALSE);
    6c72:	80 e0       	ldi	r24, 0x00	; 0
    6c74:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>
	SPIDisable();
    6c78:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
}
    6c7c:	23 96       	adiw	r28, 0x03	; 3
    6c7e:	cd bf       	out	0x3d, r28	; 61
    6c80:	de bf       	out	0x3e, r29	; 62
    6c82:	df 91       	pop	r29
    6c84:	cf 91       	pop	r28
    6c86:	08 95       	ret

00006c88 <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    6c88:	cf 93       	push	r28
    6c8a:	df 93       	push	r29
    6c8c:	00 d0       	rcall	.+0      	; 0x6c8e <PortEx_OUTCLR+0x6>
    6c8e:	cd b7       	in	r28, 0x3d	; 61
    6c90:	de b7       	in	r29, 0x3e	; 62
    6c92:	8a 83       	std	Y+2, r24	; 0x02
    6c94:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6c96:	80 e0       	ldi	r24, 0x00	; 0
    6c98:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    6c9c:	81 e0       	ldi	r24, 0x01	; 1
    6c9e:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	portExCS(TRUE);
    6ca2:	81 e0       	ldi	r24, 0x01	; 1
    6ca4:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    6ca8:	8b 81       	ldd	r24, Y+3	; 0x03
    6caa:	88 23       	and	r24, r24
    6cac:	49 f0       	breq	.+18     	; 0x6cc0 <PortEx_OUTCLR+0x38>
    6cae:	8a 81       	ldd	r24, Y+2	; 0x02
    6cb0:	98 2f       	mov	r25, r24
    6cb2:	90 95       	com	r25
    6cb4:	80 91 d7 23 	lds	r24, 0x23D7
    6cb8:	89 23       	and	r24, r25
    6cba:	80 93 d7 23 	sts	0x23D7, r24
    6cbe:	08 c0       	rjmp	.+16     	; 0x6cd0 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    6cc2:	98 2f       	mov	r25, r24
    6cc4:	90 95       	com	r25
    6cc6:	80 91 7f 50 	lds	r24, 0x507F
    6cca:	89 23       	and	r24, r25
    6ccc:	80 93 7f 50 	sts	0x507F, r24
	
	SPIBuffer[0] = PS_WRITE;
    6cd0:	80 e4       	ldi	r24, 0x40	; 64
    6cd2:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    6cd8:	88 23       	and	r24, r24
    6cda:	41 f0       	breq	.+16     	; 0x6cec <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6cdc:	84 e1       	ldi	r24, 0x14	; 20
    6cde:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    6ce2:	80 91 d7 23 	lds	r24, 0x23D7
    6ce6:	80 93 68 50 	sts	0x5068, r24
    6cea:	07 c0       	rjmp	.+14     	; 0x6cfa <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6cec:	85 e1       	ldi	r24, 0x15	; 21
    6cee:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    6cf2:	80 91 7f 50 	lds	r24, 0x507F
    6cf6:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6cfa:	19 82       	std	Y+1, r1	; 0x01
    6cfc:	1b c0       	rjmp	.+54     	; 0x6d34 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6cfe:	80 ec       	ldi	r24, 0xC0	; 192
    6d00:	98 e0       	ldi	r25, 0x08	; 8
    6d02:	29 81       	ldd	r18, Y+1	; 0x01
    6d04:	22 2f       	mov	r18, r18
    6d06:	30 e0       	ldi	r19, 0x00	; 0
    6d08:	2a 59       	subi	r18, 0x9A	; 154
    6d0a:	3f 4a       	sbci	r19, 0xAF	; 175
    6d0c:	f9 01       	movw	r30, r18
    6d0e:	20 81       	ld	r18, Z
    6d10:	fc 01       	movw	r30, r24
    6d12:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6d14:	00 00       	nop
    6d16:	80 ec       	ldi	r24, 0xC0	; 192
    6d18:	98 e0       	ldi	r25, 0x08	; 8
    6d1a:	fc 01       	movw	r30, r24
    6d1c:	82 81       	ldd	r24, Z+2	; 0x02
    6d1e:	88 23       	and	r24, r24
    6d20:	d4 f7       	brge	.-12     	; 0x6d16 <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6d22:	80 ec       	ldi	r24, 0xC0	; 192
    6d24:	98 e0       	ldi	r25, 0x08	; 8
    6d26:	fc 01       	movw	r30, r24
    6d28:	83 81       	ldd	r24, Z+3	; 0x03
    6d2a:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d2e:	89 81       	ldd	r24, Y+1	; 0x01
    6d30:	8f 5f       	subi	r24, 0xFF	; 255
    6d32:	89 83       	std	Y+1, r24	; 0x01
    6d34:	89 81       	ldd	r24, Y+1	; 0x01
    6d36:	83 30       	cpi	r24, 0x03	; 3
    6d38:	10 f3       	brcs	.-60     	; 0x6cfe <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6d3a:	80 e0       	ldi	r24, 0x00	; 0
    6d3c:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	portExCS(FALSE);
    6d40:	80 e0       	ldi	r24, 0x00	; 0
    6d42:	0e 94 20 34 	call	0x6840	; 0x6840 <portExCS>
	SPIDisable();
    6d46:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
}
    6d4a:	23 96       	adiw	r28, 0x03	; 3
    6d4c:	cd bf       	out	0x3d, r28	; 61
    6d4e:	de bf       	out	0x3e, r29	; 62
    6d50:	df 91       	pop	r29
    6d52:	cf 91       	pop	r28
    6d54:	08 95       	ret

00006d56 <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6d56:	0f 93       	push	r16
    6d58:	1f 93       	push	r17
    6d5a:	cf 93       	push	r28
    6d5c:	df 93       	push	r29
    6d5e:	cd b7       	in	r28, 0x3d	; 61
    6d60:	de b7       	in	r29, 0x3e	; 62
    6d62:	2f 97       	sbiw	r28, 0x0f	; 15
    6d64:	cd bf       	out	0x3d, r28	; 61
    6d66:	de bf       	out	0x3e, r29	; 62
    6d68:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6d6a:	8f 85       	ldd	r24, Y+15	; 0x0f
    6d6c:	88 23       	and	r24, r24
    6d6e:	09 f4       	brne	.+2      	; 0x6d72 <Ext1Power+0x1c>
    6d70:	8b c0       	rjmp	.+278    	; 0x6e88 <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6d72:	80 ea       	ldi	r24, 0xA0	; 160
    6d74:	96 e0       	ldi	r25, 0x06	; 6
    6d76:	20 e2       	ldi	r18, 0x20	; 32
    6d78:	fc 01       	movw	r30, r24
    6d7a:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6d7c:	80 ea       	ldi	r24, 0xA0	; 160
    6d7e:	96 e0       	ldi	r25, 0x06	; 6
    6d80:	20 e2       	ldi	r18, 0x20	; 32
    6d82:	fc 01       	movw	r30, r24
    6d84:	25 83       	std	Z+5, r18	; 0x05
    6d86:	80 e0       	ldi	r24, 0x00	; 0
    6d88:	90 e0       	ldi	r25, 0x00	; 0
    6d8a:	a8 ec       	ldi	r26, 0xC8	; 200
    6d8c:	b2 e4       	ldi	r27, 0x42	; 66
    6d8e:	89 83       	std	Y+1, r24	; 0x01
    6d90:	9a 83       	std	Y+2, r25	; 0x02
    6d92:	ab 83       	std	Y+3, r26	; 0x03
    6d94:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6d96:	69 81       	ldd	r22, Y+1	; 0x01
    6d98:	7a 81       	ldd	r23, Y+2	; 0x02
    6d9a:	8b 81       	ldd	r24, Y+3	; 0x03
    6d9c:	9c 81       	ldd	r25, Y+4	; 0x04
    6d9e:	20 e0       	ldi	r18, 0x00	; 0
    6da0:	30 e0       	ldi	r19, 0x00	; 0
    6da2:	4a ef       	ldi	r20, 0xFA	; 250
    6da4:	55 e4       	ldi	r21, 0x45	; 69
    6da6:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    6daa:	dc 01       	movw	r26, r24
    6dac:	cb 01       	movw	r24, r22
    6dae:	8d 83       	std	Y+5, r24	; 0x05
    6db0:	9e 83       	std	Y+6, r25	; 0x06
    6db2:	af 83       	std	Y+7, r26	; 0x07
    6db4:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6db6:	11 e0       	ldi	r17, 0x01	; 1
    6db8:	6d 81       	ldd	r22, Y+5	; 0x05
    6dba:	7e 81       	ldd	r23, Y+6	; 0x06
    6dbc:	8f 81       	ldd	r24, Y+7	; 0x07
    6dbe:	98 85       	ldd	r25, Y+8	; 0x08
    6dc0:	20 e0       	ldi	r18, 0x00	; 0
    6dc2:	30 e0       	ldi	r19, 0x00	; 0
    6dc4:	40 e8       	ldi	r20, 0x80	; 128
    6dc6:	5f e3       	ldi	r21, 0x3F	; 63
    6dc8:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    6dcc:	88 23       	and	r24, r24
    6dce:	0c f0       	brlt	.+2      	; 0x6dd2 <Ext1Power+0x7c>
    6dd0:	10 e0       	ldi	r17, 0x00	; 0
    6dd2:	11 23       	and	r17, r17
    6dd4:	29 f0       	breq	.+10     	; 0x6de0 <Ext1Power+0x8a>
		__ticks = 1;
    6dd6:	81 e0       	ldi	r24, 0x01	; 1
    6dd8:	90 e0       	ldi	r25, 0x00	; 0
    6dda:	89 87       	std	Y+9, r24	; 0x09
    6ddc:	9a 87       	std	Y+10, r25	; 0x0a
    6dde:	46 c0       	rjmp	.+140    	; 0x6e6c <Ext1Power+0x116>
	else if (__tmp > 65535)
    6de0:	11 e0       	ldi	r17, 0x01	; 1
    6de2:	6d 81       	ldd	r22, Y+5	; 0x05
    6de4:	7e 81       	ldd	r23, Y+6	; 0x06
    6de6:	8f 81       	ldd	r24, Y+7	; 0x07
    6de8:	98 85       	ldd	r25, Y+8	; 0x08
    6dea:	20 e0       	ldi	r18, 0x00	; 0
    6dec:	3f ef       	ldi	r19, 0xFF	; 255
    6dee:	4f e7       	ldi	r20, 0x7F	; 127
    6df0:	57 e4       	ldi	r21, 0x47	; 71
    6df2:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    6df6:	18 16       	cp	r1, r24
    6df8:	0c f0       	brlt	.+2      	; 0x6dfc <Ext1Power+0xa6>
    6dfa:	10 e0       	ldi	r17, 0x00	; 0
    6dfc:	11 23       	and	r17, r17
    6dfe:	61 f1       	breq	.+88     	; 0x6e58 <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e00:	69 81       	ldd	r22, Y+1	; 0x01
    6e02:	7a 81       	ldd	r23, Y+2	; 0x02
    6e04:	8b 81       	ldd	r24, Y+3	; 0x03
    6e06:	9c 81       	ldd	r25, Y+4	; 0x04
    6e08:	20 e0       	ldi	r18, 0x00	; 0
    6e0a:	30 e0       	ldi	r19, 0x00	; 0
    6e0c:	40 e2       	ldi	r20, 0x20	; 32
    6e0e:	51 e4       	ldi	r21, 0x41	; 65
    6e10:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    6e14:	dc 01       	movw	r26, r24
    6e16:	cb 01       	movw	r24, r22
    6e18:	bc 01       	movw	r22, r24
    6e1a:	cd 01       	movw	r24, r26
    6e1c:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    6e20:	dc 01       	movw	r26, r24
    6e22:	cb 01       	movw	r24, r22
    6e24:	89 87       	std	Y+9, r24	; 0x09
    6e26:	9a 87       	std	Y+10, r25	; 0x0a
    6e28:	12 c0       	rjmp	.+36     	; 0x6e4e <Ext1Power+0xf8>
    6e2a:	80 e2       	ldi	r24, 0x20	; 32
    6e2c:	93 e0       	ldi	r25, 0x03	; 3
    6e2e:	8b 87       	std	Y+11, r24	; 0x0b
    6e30:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6e32:	8b 85       	ldd	r24, Y+11	; 0x0b
    6e34:	9c 85       	ldd	r25, Y+12	; 0x0c
    6e36:	8c 01       	movw	r16, r24
    6e38:	c8 01       	movw	r24, r16
    6e3a:	01 97       	sbiw	r24, 0x01	; 1
    6e3c:	f1 f7       	brne	.-4      	; 0x6e3a <Ext1Power+0xe4>
    6e3e:	8c 01       	movw	r16, r24
    6e40:	0b 87       	std	Y+11, r16	; 0x0b
    6e42:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e44:	89 85       	ldd	r24, Y+9	; 0x09
    6e46:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e48:	01 97       	sbiw	r24, 0x01	; 1
    6e4a:	89 87       	std	Y+9, r24	; 0x09
    6e4c:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e4e:	89 85       	ldd	r24, Y+9	; 0x09
    6e50:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e52:	00 97       	sbiw	r24, 0x00	; 0
    6e54:	51 f7       	brne	.-44     	; 0x6e2a <Ext1Power+0xd4>
    6e56:	22 c0       	rjmp	.+68     	; 0x6e9c <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e58:	6d 81       	ldd	r22, Y+5	; 0x05
    6e5a:	7e 81       	ldd	r23, Y+6	; 0x06
    6e5c:	8f 81       	ldd	r24, Y+7	; 0x07
    6e5e:	98 85       	ldd	r25, Y+8	; 0x08
    6e60:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    6e64:	dc 01       	movw	r26, r24
    6e66:	cb 01       	movw	r24, r22
    6e68:	89 87       	std	Y+9, r24	; 0x09
    6e6a:	9a 87       	std	Y+10, r25	; 0x0a
    6e6c:	89 85       	ldd	r24, Y+9	; 0x09
    6e6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e70:	8d 87       	std	Y+13, r24	; 0x0d
    6e72:	9e 87       	std	Y+14, r25	; 0x0e
    6e74:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e76:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e78:	8c 01       	movw	r16, r24
    6e7a:	f8 01       	movw	r30, r16
    6e7c:	31 97       	sbiw	r30, 0x01	; 1
    6e7e:	f1 f7       	brne	.-4      	; 0x6e7c <Ext1Power+0x126>
    6e80:	8f 01       	movw	r16, r30
    6e82:	0d 87       	std	Y+13, r16	; 0x0d
    6e84:	1e 87       	std	Y+14, r17	; 0x0e
    6e86:	0a c0       	rjmp	.+20     	; 0x6e9c <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6e88:	80 ea       	ldi	r24, 0xA0	; 160
    6e8a:	96 e0       	ldi	r25, 0x06	; 6
    6e8c:	20 e2       	ldi	r18, 0x20	; 32
    6e8e:	fc 01       	movw	r30, r24
    6e90:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6e92:	80 ea       	ldi	r24, 0xA0	; 160
    6e94:	96 e0       	ldi	r25, 0x06	; 6
    6e96:	20 e2       	ldi	r18, 0x20	; 32
    6e98:	fc 01       	movw	r30, r24
    6e9a:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6e9c:	2f 96       	adiw	r28, 0x0f	; 15
    6e9e:	cd bf       	out	0x3d, r28	; 61
    6ea0:	de bf       	out	0x3e, r29	; 62
    6ea2:	df 91       	pop	r29
    6ea4:	cf 91       	pop	r28
    6ea6:	1f 91       	pop	r17
    6ea8:	0f 91       	pop	r16
    6eaa:	08 95       	ret

00006eac <Ext2Power>:

void Ext2Power(uint8_t on) {
    6eac:	0f 93       	push	r16
    6eae:	1f 93       	push	r17
    6eb0:	cf 93       	push	r28
    6eb2:	df 93       	push	r29
    6eb4:	cd b7       	in	r28, 0x3d	; 61
    6eb6:	de b7       	in	r29, 0x3e	; 62
    6eb8:	2f 97       	sbiw	r28, 0x0f	; 15
    6eba:	cd bf       	out	0x3d, r28	; 61
    6ebc:	de bf       	out	0x3e, r29	; 62
    6ebe:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6ec0:	8f 85       	ldd	r24, Y+15	; 0x0f
    6ec2:	88 23       	and	r24, r24
    6ec4:	09 f4       	brne	.+2      	; 0x6ec8 <Ext2Power+0x1c>
    6ec6:	8b c0       	rjmp	.+278    	; 0x6fde <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6ec8:	80 ea       	ldi	r24, 0xA0	; 160
    6eca:	96 e0       	ldi	r25, 0x06	; 6
    6ecc:	20 e4       	ldi	r18, 0x40	; 64
    6ece:	fc 01       	movw	r30, r24
    6ed0:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6ed2:	80 ea       	ldi	r24, 0xA0	; 160
    6ed4:	96 e0       	ldi	r25, 0x06	; 6
    6ed6:	20 e4       	ldi	r18, 0x40	; 64
    6ed8:	fc 01       	movw	r30, r24
    6eda:	25 83       	std	Z+5, r18	; 0x05
    6edc:	80 e0       	ldi	r24, 0x00	; 0
    6ede:	90 e0       	ldi	r25, 0x00	; 0
    6ee0:	a8 ec       	ldi	r26, 0xC8	; 200
    6ee2:	b2 e4       	ldi	r27, 0x42	; 66
    6ee4:	89 83       	std	Y+1, r24	; 0x01
    6ee6:	9a 83       	std	Y+2, r25	; 0x02
    6ee8:	ab 83       	std	Y+3, r26	; 0x03
    6eea:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6eec:	69 81       	ldd	r22, Y+1	; 0x01
    6eee:	7a 81       	ldd	r23, Y+2	; 0x02
    6ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ef2:	9c 81       	ldd	r25, Y+4	; 0x04
    6ef4:	20 e0       	ldi	r18, 0x00	; 0
    6ef6:	30 e0       	ldi	r19, 0x00	; 0
    6ef8:	4a ef       	ldi	r20, 0xFA	; 250
    6efa:	55 e4       	ldi	r21, 0x45	; 69
    6efc:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    6f00:	dc 01       	movw	r26, r24
    6f02:	cb 01       	movw	r24, r22
    6f04:	8d 83       	std	Y+5, r24	; 0x05
    6f06:	9e 83       	std	Y+6, r25	; 0x06
    6f08:	af 83       	std	Y+7, r26	; 0x07
    6f0a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6f0c:	11 e0       	ldi	r17, 0x01	; 1
    6f0e:	6d 81       	ldd	r22, Y+5	; 0x05
    6f10:	7e 81       	ldd	r23, Y+6	; 0x06
    6f12:	8f 81       	ldd	r24, Y+7	; 0x07
    6f14:	98 85       	ldd	r25, Y+8	; 0x08
    6f16:	20 e0       	ldi	r18, 0x00	; 0
    6f18:	30 e0       	ldi	r19, 0x00	; 0
    6f1a:	40 e8       	ldi	r20, 0x80	; 128
    6f1c:	5f e3       	ldi	r21, 0x3F	; 63
    6f1e:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    6f22:	88 23       	and	r24, r24
    6f24:	0c f0       	brlt	.+2      	; 0x6f28 <Ext2Power+0x7c>
    6f26:	10 e0       	ldi	r17, 0x00	; 0
    6f28:	11 23       	and	r17, r17
    6f2a:	29 f0       	breq	.+10     	; 0x6f36 <Ext2Power+0x8a>
		__ticks = 1;
    6f2c:	81 e0       	ldi	r24, 0x01	; 1
    6f2e:	90 e0       	ldi	r25, 0x00	; 0
    6f30:	89 87       	std	Y+9, r24	; 0x09
    6f32:	9a 87       	std	Y+10, r25	; 0x0a
    6f34:	46 c0       	rjmp	.+140    	; 0x6fc2 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6f36:	11 e0       	ldi	r17, 0x01	; 1
    6f38:	6d 81       	ldd	r22, Y+5	; 0x05
    6f3a:	7e 81       	ldd	r23, Y+6	; 0x06
    6f3c:	8f 81       	ldd	r24, Y+7	; 0x07
    6f3e:	98 85       	ldd	r25, Y+8	; 0x08
    6f40:	20 e0       	ldi	r18, 0x00	; 0
    6f42:	3f ef       	ldi	r19, 0xFF	; 255
    6f44:	4f e7       	ldi	r20, 0x7F	; 127
    6f46:	57 e4       	ldi	r21, 0x47	; 71
    6f48:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    6f4c:	18 16       	cp	r1, r24
    6f4e:	0c f0       	brlt	.+2      	; 0x6f52 <Ext2Power+0xa6>
    6f50:	10 e0       	ldi	r17, 0x00	; 0
    6f52:	11 23       	and	r17, r17
    6f54:	61 f1       	breq	.+88     	; 0x6fae <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6f56:	69 81       	ldd	r22, Y+1	; 0x01
    6f58:	7a 81       	ldd	r23, Y+2	; 0x02
    6f5a:	8b 81       	ldd	r24, Y+3	; 0x03
    6f5c:	9c 81       	ldd	r25, Y+4	; 0x04
    6f5e:	20 e0       	ldi	r18, 0x00	; 0
    6f60:	30 e0       	ldi	r19, 0x00	; 0
    6f62:	40 e2       	ldi	r20, 0x20	; 32
    6f64:	51 e4       	ldi	r21, 0x41	; 65
    6f66:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    6f6a:	dc 01       	movw	r26, r24
    6f6c:	cb 01       	movw	r24, r22
    6f6e:	bc 01       	movw	r22, r24
    6f70:	cd 01       	movw	r24, r26
    6f72:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    6f76:	dc 01       	movw	r26, r24
    6f78:	cb 01       	movw	r24, r22
    6f7a:	89 87       	std	Y+9, r24	; 0x09
    6f7c:	9a 87       	std	Y+10, r25	; 0x0a
    6f7e:	12 c0       	rjmp	.+36     	; 0x6fa4 <Ext2Power+0xf8>
    6f80:	80 e2       	ldi	r24, 0x20	; 32
    6f82:	93 e0       	ldi	r25, 0x03	; 3
    6f84:	8b 87       	std	Y+11, r24	; 0x0b
    6f86:	9c 87       	std	Y+12, r25	; 0x0c
    6f88:	8b 85       	ldd	r24, Y+11	; 0x0b
    6f8a:	9c 85       	ldd	r25, Y+12	; 0x0c
    6f8c:	8c 01       	movw	r16, r24
    6f8e:	c8 01       	movw	r24, r16
    6f90:	01 97       	sbiw	r24, 0x01	; 1
    6f92:	f1 f7       	brne	.-4      	; 0x6f90 <Ext2Power+0xe4>
    6f94:	8c 01       	movw	r16, r24
    6f96:	0b 87       	std	Y+11, r16	; 0x0b
    6f98:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6f9a:	89 85       	ldd	r24, Y+9	; 0x09
    6f9c:	9a 85       	ldd	r25, Y+10	; 0x0a
    6f9e:	01 97       	sbiw	r24, 0x01	; 1
    6fa0:	89 87       	std	Y+9, r24	; 0x09
    6fa2:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6fa4:	89 85       	ldd	r24, Y+9	; 0x09
    6fa6:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fa8:	00 97       	sbiw	r24, 0x00	; 0
    6faa:	51 f7       	brne	.-44     	; 0x6f80 <Ext2Power+0xd4>
    6fac:	22 c0       	rjmp	.+68     	; 0x6ff2 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6fae:	6d 81       	ldd	r22, Y+5	; 0x05
    6fb0:	7e 81       	ldd	r23, Y+6	; 0x06
    6fb2:	8f 81       	ldd	r24, Y+7	; 0x07
    6fb4:	98 85       	ldd	r25, Y+8	; 0x08
    6fb6:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    6fba:	dc 01       	movw	r26, r24
    6fbc:	cb 01       	movw	r24, r22
    6fbe:	89 87       	std	Y+9, r24	; 0x09
    6fc0:	9a 87       	std	Y+10, r25	; 0x0a
    6fc2:	89 85       	ldd	r24, Y+9	; 0x09
    6fc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fc6:	8d 87       	std	Y+13, r24	; 0x0d
    6fc8:	9e 87       	std	Y+14, r25	; 0x0e
    6fca:	8d 85       	ldd	r24, Y+13	; 0x0d
    6fcc:	9e 85       	ldd	r25, Y+14	; 0x0e
    6fce:	8c 01       	movw	r16, r24
    6fd0:	f8 01       	movw	r30, r16
    6fd2:	31 97       	sbiw	r30, 0x01	; 1
    6fd4:	f1 f7       	brne	.-4      	; 0x6fd2 <Ext2Power+0x126>
    6fd6:	8f 01       	movw	r16, r30
    6fd8:	0d 87       	std	Y+13, r16	; 0x0d
    6fda:	1e 87       	std	Y+14, r17	; 0x0e
    6fdc:	0a c0       	rjmp	.+20     	; 0x6ff2 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6fde:	80 ea       	ldi	r24, 0xA0	; 160
    6fe0:	96 e0       	ldi	r25, 0x06	; 6
    6fe2:	20 e4       	ldi	r18, 0x40	; 64
    6fe4:	fc 01       	movw	r30, r24
    6fe6:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6fe8:	80 ea       	ldi	r24, 0xA0	; 160
    6fea:	96 e0       	ldi	r25, 0x06	; 6
    6fec:	20 e4       	ldi	r18, 0x40	; 64
    6fee:	fc 01       	movw	r30, r24
    6ff0:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6ff2:	2f 96       	adiw	r28, 0x0f	; 15
    6ff4:	cd bf       	out	0x3d, r28	; 61
    6ff6:	de bf       	out	0x3e, r29	; 62
    6ff8:	df 91       	pop	r29
    6ffa:	cf 91       	pop	r28
    6ffc:	1f 91       	pop	r17
    6ffe:	0f 91       	pop	r16
    7000:	08 95       	ret

00007002 <HVPower>:

void HVPower(uint8_t on) {
    7002:	0f 93       	push	r16
    7004:	1f 93       	push	r17
    7006:	cf 93       	push	r28
    7008:	df 93       	push	r29
    700a:	cd b7       	in	r28, 0x3d	; 61
    700c:	de b7       	in	r29, 0x3e	; 62
    700e:	a7 97       	sbiw	r28, 0x27	; 39
    7010:	cd bf       	out	0x3d, r28	; 61
    7012:	de bf       	out	0x3e, r29	; 62
    7014:	8f a3       	lds	r24, 0x5f
	if (on) {
    7016:	8f a1       	lds	r24, 0x4f
    7018:	88 23       	and	r24, r24
    701a:	09 f4       	brne	.+2      	; 0x701e <HVPower+0x1c>
    701c:	8b c0       	rjmp	.+278    	; 0x7134 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    701e:	80 ea       	ldi	r24, 0xA0	; 160
    7020:	96 e0       	ldi	r25, 0x06	; 6
    7022:	20 e8       	ldi	r18, 0x80	; 128
    7024:	fc 01       	movw	r30, r24
    7026:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    7028:	80 ea       	ldi	r24, 0xA0	; 160
    702a:	96 e0       	ldi	r25, 0x06	; 6
    702c:	20 e8       	ldi	r18, 0x80	; 128
    702e:	fc 01       	movw	r30, r24
    7030:	25 83       	std	Z+5, r18	; 0x05
    7032:	80 e0       	ldi	r24, 0x00	; 0
    7034:	90 e0       	ldi	r25, 0x00	; 0
    7036:	a8 ec       	ldi	r26, 0xC8	; 200
    7038:	b2 e4       	ldi	r27, 0x42	; 66
    703a:	89 83       	std	Y+1, r24	; 0x01
    703c:	9a 83       	std	Y+2, r25	; 0x02
    703e:	ab 83       	std	Y+3, r26	; 0x03
    7040:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7042:	69 81       	ldd	r22, Y+1	; 0x01
    7044:	7a 81       	ldd	r23, Y+2	; 0x02
    7046:	8b 81       	ldd	r24, Y+3	; 0x03
    7048:	9c 81       	ldd	r25, Y+4	; 0x04
    704a:	20 e0       	ldi	r18, 0x00	; 0
    704c:	30 e0       	ldi	r19, 0x00	; 0
    704e:	4a ef       	ldi	r20, 0xFA	; 250
    7050:	55 e4       	ldi	r21, 0x45	; 69
    7052:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7056:	dc 01       	movw	r26, r24
    7058:	cb 01       	movw	r24, r22
    705a:	8d 83       	std	Y+5, r24	; 0x05
    705c:	9e 83       	std	Y+6, r25	; 0x06
    705e:	af 83       	std	Y+7, r26	; 0x07
    7060:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7062:	11 e0       	ldi	r17, 0x01	; 1
    7064:	6d 81       	ldd	r22, Y+5	; 0x05
    7066:	7e 81       	ldd	r23, Y+6	; 0x06
    7068:	8f 81       	ldd	r24, Y+7	; 0x07
    706a:	98 85       	ldd	r25, Y+8	; 0x08
    706c:	20 e0       	ldi	r18, 0x00	; 0
    706e:	30 e0       	ldi	r19, 0x00	; 0
    7070:	40 e8       	ldi	r20, 0x80	; 128
    7072:	5f e3       	ldi	r21, 0x3F	; 63
    7074:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7078:	88 23       	and	r24, r24
    707a:	0c f0       	brlt	.+2      	; 0x707e <HVPower+0x7c>
    707c:	10 e0       	ldi	r17, 0x00	; 0
    707e:	11 23       	and	r17, r17
    7080:	29 f0       	breq	.+10     	; 0x708c <HVPower+0x8a>
		__ticks = 1;
    7082:	81 e0       	ldi	r24, 0x01	; 1
    7084:	90 e0       	ldi	r25, 0x00	; 0
    7086:	89 87       	std	Y+9, r24	; 0x09
    7088:	9a 87       	std	Y+10, r25	; 0x0a
    708a:	46 c0       	rjmp	.+140    	; 0x7118 <HVPower+0x116>
	else if (__tmp > 65535)
    708c:	11 e0       	ldi	r17, 0x01	; 1
    708e:	6d 81       	ldd	r22, Y+5	; 0x05
    7090:	7e 81       	ldd	r23, Y+6	; 0x06
    7092:	8f 81       	ldd	r24, Y+7	; 0x07
    7094:	98 85       	ldd	r25, Y+8	; 0x08
    7096:	20 e0       	ldi	r18, 0x00	; 0
    7098:	3f ef       	ldi	r19, 0xFF	; 255
    709a:	4f e7       	ldi	r20, 0x7F	; 127
    709c:	57 e4       	ldi	r21, 0x47	; 71
    709e:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    70a2:	18 16       	cp	r1, r24
    70a4:	0c f0       	brlt	.+2      	; 0x70a8 <HVPower+0xa6>
    70a6:	10 e0       	ldi	r17, 0x00	; 0
    70a8:	11 23       	and	r17, r17
    70aa:	61 f1       	breq	.+88     	; 0x7104 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    70ac:	69 81       	ldd	r22, Y+1	; 0x01
    70ae:	7a 81       	ldd	r23, Y+2	; 0x02
    70b0:	8b 81       	ldd	r24, Y+3	; 0x03
    70b2:	9c 81       	ldd	r25, Y+4	; 0x04
    70b4:	20 e0       	ldi	r18, 0x00	; 0
    70b6:	30 e0       	ldi	r19, 0x00	; 0
    70b8:	40 e2       	ldi	r20, 0x20	; 32
    70ba:	51 e4       	ldi	r21, 0x41	; 65
    70bc:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    70c0:	dc 01       	movw	r26, r24
    70c2:	cb 01       	movw	r24, r22
    70c4:	bc 01       	movw	r22, r24
    70c6:	cd 01       	movw	r24, r26
    70c8:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    70cc:	dc 01       	movw	r26, r24
    70ce:	cb 01       	movw	r24, r22
    70d0:	89 87       	std	Y+9, r24	; 0x09
    70d2:	9a 87       	std	Y+10, r25	; 0x0a
    70d4:	12 c0       	rjmp	.+36     	; 0x70fa <HVPower+0xf8>
    70d6:	80 e2       	ldi	r24, 0x20	; 32
    70d8:	93 e0       	ldi	r25, 0x03	; 3
    70da:	8b 87       	std	Y+11, r24	; 0x0b
    70dc:	9c 87       	std	Y+12, r25	; 0x0c
    70de:	8b 85       	ldd	r24, Y+11	; 0x0b
    70e0:	9c 85       	ldd	r25, Y+12	; 0x0c
    70e2:	8c 01       	movw	r16, r24
    70e4:	c8 01       	movw	r24, r16
    70e6:	01 97       	sbiw	r24, 0x01	; 1
    70e8:	f1 f7       	brne	.-4      	; 0x70e6 <HVPower+0xe4>
    70ea:	8c 01       	movw	r16, r24
    70ec:	0b 87       	std	Y+11, r16	; 0x0b
    70ee:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    70f0:	89 85       	ldd	r24, Y+9	; 0x09
    70f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    70f4:	01 97       	sbiw	r24, 0x01	; 1
    70f6:	89 87       	std	Y+9, r24	; 0x09
    70f8:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    70fa:	89 85       	ldd	r24, Y+9	; 0x09
    70fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    70fe:	00 97       	sbiw	r24, 0x00	; 0
    7100:	51 f7       	brne	.-44     	; 0x70d6 <HVPower+0xd4>
    7102:	22 c0       	rjmp	.+68     	; 0x7148 <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7104:	6d 81       	ldd	r22, Y+5	; 0x05
    7106:	7e 81       	ldd	r23, Y+6	; 0x06
    7108:	8f 81       	ldd	r24, Y+7	; 0x07
    710a:	98 85       	ldd	r25, Y+8	; 0x08
    710c:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7110:	dc 01       	movw	r26, r24
    7112:	cb 01       	movw	r24, r22
    7114:	89 87       	std	Y+9, r24	; 0x09
    7116:	9a 87       	std	Y+10, r25	; 0x0a
    7118:	89 85       	ldd	r24, Y+9	; 0x09
    711a:	9a 85       	ldd	r25, Y+10	; 0x0a
    711c:	8d 87       	std	Y+13, r24	; 0x0d
    711e:	9e 87       	std	Y+14, r25	; 0x0e
    7120:	8d 85       	ldd	r24, Y+13	; 0x0d
    7122:	9e 85       	ldd	r25, Y+14	; 0x0e
    7124:	8c 01       	movw	r16, r24
    7126:	f8 01       	movw	r30, r16
    7128:	31 97       	sbiw	r30, 0x01	; 1
    712a:	f1 f7       	brne	.-4      	; 0x7128 <HVPower+0x126>
    712c:	8f 01       	movw	r16, r30
    712e:	0d 87       	std	Y+13, r16	; 0x0d
    7130:	1e 87       	std	Y+14, r17	; 0x0e
    7132:	0a c0       	rjmp	.+20     	; 0x7148 <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    7134:	80 ea       	ldi	r24, 0xA0	; 160
    7136:	96 e0       	ldi	r25, 0x06	; 6
    7138:	20 e8       	ldi	r18, 0x80	; 128
    713a:	fc 01       	movw	r30, r24
    713c:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    713e:	80 ea       	ldi	r24, 0xA0	; 160
    7140:	96 e0       	ldi	r25, 0x06	; 6
    7142:	20 e8       	ldi	r18, 0x80	; 128
    7144:	fc 01       	movw	r30, r24
    7146:	22 83       	std	Z+2, r18	; 0x02
    7148:	80 e0       	ldi	r24, 0x00	; 0
    714a:	90 e0       	ldi	r25, 0x00	; 0
    714c:	aa e7       	ldi	r26, 0x7A	; 122
    714e:	b4 e4       	ldi	r27, 0x44	; 68
    7150:	8f 87       	std	Y+15, r24	; 0x0f
    7152:	98 8b       	std	Y+16, r25	; 0x10
    7154:	a9 8b       	std	Y+17, r26	; 0x11
    7156:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7158:	6f 85       	ldd	r22, Y+15	; 0x0f
    715a:	78 89       	ldd	r23, Y+16	; 0x10
    715c:	89 89       	ldd	r24, Y+17	; 0x11
    715e:	9a 89       	ldd	r25, Y+18	; 0x12
    7160:	2b ea       	ldi	r18, 0xAB	; 171
    7162:	3a ea       	ldi	r19, 0xAA	; 170
    7164:	4a e2       	ldi	r20, 0x2A	; 42
    7166:	51 e4       	ldi	r21, 0x41	; 65
    7168:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    716c:	dc 01       	movw	r26, r24
    716e:	cb 01       	movw	r24, r22
    7170:	8b 8b       	std	Y+19, r24	; 0x13
    7172:	9c 8b       	std	Y+20, r25	; 0x14
    7174:	ad 8b       	std	Y+21, r26	; 0x15
    7176:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7178:	11 e0       	ldi	r17, 0x01	; 1
    717a:	6b 89       	ldd	r22, Y+19	; 0x13
    717c:	7c 89       	ldd	r23, Y+20	; 0x14
    717e:	8d 89       	ldd	r24, Y+21	; 0x15
    7180:	9e 89       	ldd	r25, Y+22	; 0x16
    7182:	20 e0       	ldi	r18, 0x00	; 0
    7184:	30 e0       	ldi	r19, 0x00	; 0
    7186:	40 e8       	ldi	r20, 0x80	; 128
    7188:	5f e3       	ldi	r21, 0x3F	; 63
    718a:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    718e:	88 23       	and	r24, r24
    7190:	0c f0       	brlt	.+2      	; 0x7194 <HVPower+0x192>
    7192:	10 e0       	ldi	r17, 0x00	; 0
    7194:	11 23       	and	r17, r17
    7196:	19 f0       	breq	.+6      	; 0x719e <HVPower+0x19c>
		__ticks = 1;
    7198:	81 e0       	ldi	r24, 0x01	; 1
    719a:	8f 8b       	std	Y+23, r24	; 0x17
    719c:	a3 c0       	rjmp	.+326    	; 0x72e4 <HVPower+0x2e2>
	else if (__tmp > 255)
    719e:	11 e0       	ldi	r17, 0x01	; 1
    71a0:	6b 89       	ldd	r22, Y+19	; 0x13
    71a2:	7c 89       	ldd	r23, Y+20	; 0x14
    71a4:	8d 89       	ldd	r24, Y+21	; 0x15
    71a6:	9e 89       	ldd	r25, Y+22	; 0x16
    71a8:	20 e0       	ldi	r18, 0x00	; 0
    71aa:	30 e0       	ldi	r19, 0x00	; 0
    71ac:	4f e7       	ldi	r20, 0x7F	; 127
    71ae:	53 e4       	ldi	r21, 0x43	; 67
    71b0:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    71b4:	18 16       	cp	r1, r24
    71b6:	0c f0       	brlt	.+2      	; 0x71ba <HVPower+0x1b8>
    71b8:	10 e0       	ldi	r17, 0x00	; 0
    71ba:	11 23       	and	r17, r17
    71bc:	09 f4       	brne	.+2      	; 0x71c0 <HVPower+0x1be>
    71be:	89 c0       	rjmp	.+274    	; 0x72d2 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    71c0:	6f 85       	ldd	r22, Y+15	; 0x0f
    71c2:	78 89       	ldd	r23, Y+16	; 0x10
    71c4:	89 89       	ldd	r24, Y+17	; 0x11
    71c6:	9a 89       	ldd	r25, Y+18	; 0x12
    71c8:	20 e0       	ldi	r18, 0x00	; 0
    71ca:	30 e0       	ldi	r19, 0x00	; 0
    71cc:	4a e7       	ldi	r20, 0x7A	; 122
    71ce:	54 e4       	ldi	r21, 0x44	; 68
    71d0:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    71d4:	dc 01       	movw	r26, r24
    71d6:	cb 01       	movw	r24, r22
    71d8:	88 8f       	std	Y+24, r24	; 0x18
    71da:	99 8f       	std	Y+25, r25	; 0x19
    71dc:	aa 8f       	std	Y+26, r26	; 0x1a
    71de:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    71e0:	68 8d       	ldd	r22, Y+24	; 0x18
    71e2:	79 8d       	ldd	r23, Y+25	; 0x19
    71e4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    71e6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    71e8:	20 e0       	ldi	r18, 0x00	; 0
    71ea:	30 e0       	ldi	r19, 0x00	; 0
    71ec:	4a ef       	ldi	r20, 0xFA	; 250
    71ee:	55 e4       	ldi	r21, 0x45	; 69
    71f0:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    71f4:	dc 01       	movw	r26, r24
    71f6:	cb 01       	movw	r24, r22
    71f8:	8c 8f       	std	Y+28, r24	; 0x1c
    71fa:	9d 8f       	std	Y+29, r25	; 0x1d
    71fc:	ae 8f       	std	Y+30, r26	; 0x1e
    71fe:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    7200:	11 e0       	ldi	r17, 0x01	; 1
    7202:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7204:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7206:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7208:	9f 8d       	ldd	r25, Y+31	; 0x1f
    720a:	20 e0       	ldi	r18, 0x00	; 0
    720c:	30 e0       	ldi	r19, 0x00	; 0
    720e:	40 e8       	ldi	r20, 0x80	; 128
    7210:	5f e3       	ldi	r21, 0x3F	; 63
    7212:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7216:	88 23       	and	r24, r24
    7218:	0c f0       	brlt	.+2      	; 0x721c <HVPower+0x21a>
    721a:	10 e0       	ldi	r17, 0x00	; 0
    721c:	11 23       	and	r17, r17
    721e:	29 f0       	breq	.+10     	; 0x722a <HVPower+0x228>
		__ticks = 1;
    7220:	81 e0       	ldi	r24, 0x01	; 1
    7222:	90 e0       	ldi	r25, 0x00	; 0
    7224:	88 a3       	lds	r24, 0x58
    7226:	99 a3       	lds	r25, 0x59
    7228:	46 c0       	rjmp	.+140    	; 0x72b6 <HVPower+0x2b4>
	else if (__tmp > 65535)
    722a:	11 e0       	ldi	r17, 0x01	; 1
    722c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    722e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7230:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7232:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7234:	20 e0       	ldi	r18, 0x00	; 0
    7236:	3f ef       	ldi	r19, 0xFF	; 255
    7238:	4f e7       	ldi	r20, 0x7F	; 127
    723a:	57 e4       	ldi	r21, 0x47	; 71
    723c:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7240:	18 16       	cp	r1, r24
    7242:	0c f0       	brlt	.+2      	; 0x7246 <HVPower+0x244>
    7244:	10 e0       	ldi	r17, 0x00	; 0
    7246:	11 23       	and	r17, r17
    7248:	61 f1       	breq	.+88     	; 0x72a2 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    724a:	68 8d       	ldd	r22, Y+24	; 0x18
    724c:	79 8d       	ldd	r23, Y+25	; 0x19
    724e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7250:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7252:	20 e0       	ldi	r18, 0x00	; 0
    7254:	30 e0       	ldi	r19, 0x00	; 0
    7256:	40 e2       	ldi	r20, 0x20	; 32
    7258:	51 e4       	ldi	r21, 0x41	; 65
    725a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    725e:	dc 01       	movw	r26, r24
    7260:	cb 01       	movw	r24, r22
    7262:	bc 01       	movw	r22, r24
    7264:	cd 01       	movw	r24, r26
    7266:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    726a:	dc 01       	movw	r26, r24
    726c:	cb 01       	movw	r24, r22
    726e:	88 a3       	lds	r24, 0x58
    7270:	99 a3       	lds	r25, 0x59
    7272:	12 c0       	rjmp	.+36     	; 0x7298 <HVPower+0x296>
    7274:	80 e2       	ldi	r24, 0x20	; 32
    7276:	93 e0       	ldi	r25, 0x03	; 3
    7278:	8a a3       	lds	r24, 0x5a
    727a:	9b a3       	lds	r25, 0x5b
    727c:	8a a1       	lds	r24, 0x4a
    727e:	9b a1       	lds	r25, 0x4b
    7280:	8c 01       	movw	r16, r24
    7282:	c8 01       	movw	r24, r16
    7284:	01 97       	sbiw	r24, 0x01	; 1
    7286:	f1 f7       	brne	.-4      	; 0x7284 <HVPower+0x282>
    7288:	8c 01       	movw	r16, r24
    728a:	0a a3       	lds	r16, 0x5a
    728c:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    728e:	88 a1       	lds	r24, 0x48
    7290:	99 a1       	lds	r25, 0x49
    7292:	01 97       	sbiw	r24, 0x01	; 1
    7294:	88 a3       	lds	r24, 0x58
    7296:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7298:	88 a1       	lds	r24, 0x48
    729a:	99 a1       	lds	r25, 0x49
    729c:	00 97       	sbiw	r24, 0x00	; 0
    729e:	51 f7       	brne	.-44     	; 0x7274 <HVPower+0x272>
    72a0:	28 c0       	rjmp	.+80     	; 0x72f2 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    72a2:	6c 8d       	ldd	r22, Y+28	; 0x1c
    72a4:	7d 8d       	ldd	r23, Y+29	; 0x1d
    72a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    72a8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    72aa:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    72ae:	dc 01       	movw	r26, r24
    72b0:	cb 01       	movw	r24, r22
    72b2:	88 a3       	lds	r24, 0x58
    72b4:	99 a3       	lds	r25, 0x59
    72b6:	88 a1       	lds	r24, 0x48
    72b8:	99 a1       	lds	r25, 0x49
    72ba:	8c a3       	lds	r24, 0x5c
    72bc:	9d a3       	lds	r25, 0x5d
    72be:	8c a1       	lds	r24, 0x4c
    72c0:	9d a1       	lds	r25, 0x4d
    72c2:	8c 01       	movw	r16, r24
    72c4:	f8 01       	movw	r30, r16
    72c6:	31 97       	sbiw	r30, 0x01	; 1
    72c8:	f1 f7       	brne	.-4      	; 0x72c6 <HVPower+0x2c4>
    72ca:	8f 01       	movw	r16, r30
    72cc:	0c a3       	lds	r16, 0x5c
    72ce:	1d a3       	lds	r17, 0x5d
    72d0:	10 c0       	rjmp	.+32     	; 0x72f2 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    72d2:	6b 89       	ldd	r22, Y+19	; 0x13
    72d4:	7c 89       	ldd	r23, Y+20	; 0x14
    72d6:	8d 89       	ldd	r24, Y+21	; 0x15
    72d8:	9e 89       	ldd	r25, Y+22	; 0x16
    72da:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    72de:	dc 01       	movw	r26, r24
    72e0:	cb 01       	movw	r24, r22
    72e2:	8f 8b       	std	Y+23, r24	; 0x17
    72e4:	8f 89       	ldd	r24, Y+23	; 0x17
    72e6:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    72e8:	8e a1       	lds	r24, 0x4e
    72ea:	18 2f       	mov	r17, r24
    72ec:	1a 95       	dec	r17
    72ee:	f1 f7       	brne	.-4      	; 0x72ec <HVPower+0x2ea>
    72f0:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    72f2:	a7 96       	adiw	r28, 0x27	; 39
    72f4:	cd bf       	out	0x3d, r28	; 61
    72f6:	de bf       	out	0x3e, r29	; 62
    72f8:	df 91       	pop	r29
    72fa:	cf 91       	pop	r28
    72fc:	1f 91       	pop	r17
    72fe:	0f 91       	pop	r16
    7300:	08 95       	ret

00007302 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    7302:	cf 93       	push	r28
    7304:	df 93       	push	r29
    7306:	0f 92       	push	r0
    7308:	cd b7       	in	r28, 0x3d	; 61
    730a:	de b7       	in	r29, 0x3e	; 62
    730c:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    730e:	89 81       	ldd	r24, Y+1	; 0x01
    7310:	88 23       	and	r24, r24
    7312:	31 f0       	breq	.+12     	; 0x7320 <lowerMuxCS+0x1e>
    7314:	80 e8       	ldi	r24, 0x80	; 128
    7316:	96 e0       	ldi	r25, 0x06	; 6
    7318:	20 e1       	ldi	r18, 0x10	; 16
    731a:	fc 01       	movw	r30, r24
    731c:	26 83       	std	Z+6, r18	; 0x06
    731e:	05 c0       	rjmp	.+10     	; 0x732a <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    7320:	80 e8       	ldi	r24, 0x80	; 128
    7322:	96 e0       	ldi	r25, 0x06	; 6
    7324:	20 e1       	ldi	r18, 0x10	; 16
    7326:	fc 01       	movw	r30, r24
    7328:	25 83       	std	Z+5, r18	; 0x05
}
    732a:	0f 90       	pop	r0
    732c:	df 91       	pop	r29
    732e:	cf 91       	pop	r28
    7330:	08 95       	ret

00007332 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    7332:	cf 93       	push	r28
    7334:	df 93       	push	r29
    7336:	0f 92       	push	r0
    7338:	cd b7       	in	r28, 0x3d	; 61
    733a:	de b7       	in	r29, 0x3e	; 62
    733c:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    733e:	89 81       	ldd	r24, Y+1	; 0x01
    7340:	88 23       	and	r24, r24
    7342:	31 f0       	breq	.+12     	; 0x7350 <upperMuxCS+0x1e>
    7344:	80 e4       	ldi	r24, 0x40	; 64
    7346:	96 e0       	ldi	r25, 0x06	; 6
    7348:	22 e0       	ldi	r18, 0x02	; 2
    734a:	fc 01       	movw	r30, r24
    734c:	26 83       	std	Z+6, r18	; 0x06
    734e:	05 c0       	rjmp	.+10     	; 0x735a <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    7350:	80 e4       	ldi	r24, 0x40	; 64
    7352:	96 e0       	ldi	r25, 0x06	; 6
    7354:	22 e0       	ldi	r18, 0x02	; 2
    7356:	fc 01       	movw	r30, r24
    7358:	25 83       	std	Z+5, r18	; 0x05
}
    735a:	0f 90       	pop	r0
    735c:	df 91       	pop	r29
    735e:	cf 91       	pop	r28
    7360:	08 95       	ret

00007362 <SPIInit>:

void SPIInit(uint8_t mode) {
    7362:	cf 93       	push	r28
    7364:	df 93       	push	r29
    7366:	0f 92       	push	r0
    7368:	cd b7       	in	r28, 0x3d	; 61
    736a:	de b7       	in	r29, 0x3e	; 62
    736c:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    736e:	80 e4       	ldi	r24, 0x40	; 64
    7370:	96 e0       	ldi	r25, 0x06	; 6
    7372:	20 e1       	ldi	r18, 0x10	; 16
    7374:	fc 01       	movw	r30, r24
    7376:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    7378:	80 e4       	ldi	r24, 0x40	; 64
    737a:	96 e0       	ldi	r25, 0x06	; 6
    737c:	28 e3       	ldi	r18, 0x38	; 56
    737e:	fc 01       	movw	r30, r24
    7380:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    7382:	80 e4       	ldi	r24, 0x40	; 64
    7384:	96 e0       	ldi	r25, 0x06	; 6
    7386:	20 e1       	ldi	r18, 0x10	; 16
    7388:	fc 01       	movw	r30, r24
    738a:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    738c:	80 ec       	ldi	r24, 0xC0	; 192
    738e:	98 e0       	ldi	r25, 0x08	; 8
    7390:	29 81       	ldd	r18, Y+1	; 0x01
    7392:	21 65       	ori	r18, 0x51	; 81
    7394:	fc 01       	movw	r30, r24
    7396:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    7398:	80 ec       	ldi	r24, 0xC0	; 192
    739a:	98 e0       	ldi	r25, 0x08	; 8
    739c:	fc 01       	movw	r30, r24
    739e:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    73a0:	80 e4       	ldi	r24, 0x40	; 64
    73a2:	96 e0       	ldi	r25, 0x06	; 6
    73a4:	20 ea       	ldi	r18, 0xA0	; 160
    73a6:	fc 01       	movw	r30, r24
    73a8:	21 83       	std	Z+1, r18	; 0x01

	
}
    73aa:	0f 90       	pop	r0
    73ac:	df 91       	pop	r29
    73ae:	cf 91       	pop	r28
    73b0:	08 95       	ret

000073b2 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    73b2:	cf 93       	push	r28
    73b4:	df 93       	push	r29
    73b6:	0f 92       	push	r0
    73b8:	0f 92       	push	r0
    73ba:	cd b7       	in	r28, 0x3d	; 61
    73bc:	de b7       	in	r29, 0x3e	; 62
    73be:	89 83       	std	Y+1, r24	; 0x01
    73c0:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    73c2:	80 e4       	ldi	r24, 0x40	; 64
    73c4:	96 e0       	ldi	r25, 0x06	; 6
    73c6:	20 e1       	ldi	r18, 0x10	; 16
    73c8:	fc 01       	movw	r30, r24
    73ca:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    73cc:	80 e4       	ldi	r24, 0x40	; 64
    73ce:	96 e0       	ldi	r25, 0x06	; 6
    73d0:	28 e3       	ldi	r18, 0x38	; 56
    73d2:	fc 01       	movw	r30, r24
    73d4:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    73d6:	80 e4       	ldi	r24, 0x40	; 64
    73d8:	96 e0       	ldi	r25, 0x06	; 6
    73da:	20 e1       	ldi	r18, 0x10	; 16
    73dc:	fc 01       	movw	r30, r24
    73de:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    73e0:	80 ec       	ldi	r24, 0xC0	; 192
    73e2:	98 e0       	ldi	r25, 0x08	; 8
    73e4:	3a 81       	ldd	r19, Y+2	; 0x02
    73e6:	29 81       	ldd	r18, Y+1	; 0x01
    73e8:	23 2b       	or	r18, r19
    73ea:	20 65       	ori	r18, 0x50	; 80
    73ec:	fc 01       	movw	r30, r24
    73ee:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    73f0:	80 ec       	ldi	r24, 0xC0	; 192
    73f2:	98 e0       	ldi	r25, 0x08	; 8
    73f4:	fc 01       	movw	r30, r24
    73f6:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    73f8:	80 e4       	ldi	r24, 0x40	; 64
    73fa:	96 e0       	ldi	r25, 0x06	; 6
    73fc:	20 ea       	ldi	r18, 0xA0	; 160
    73fe:	fc 01       	movw	r30, r24
    7400:	21 83       	std	Z+1, r18	; 0x01
}
    7402:	0f 90       	pop	r0
    7404:	0f 90       	pop	r0
    7406:	df 91       	pop	r29
    7408:	cf 91       	pop	r28
    740a:	08 95       	ret

0000740c <SPICS>:

void SPICS(uint8_t enable) {
    740c:	cf 93       	push	r28
    740e:	df 93       	push	r29
    7410:	0f 92       	push	r0
    7412:	cd b7       	in	r28, 0x3d	; 61
    7414:	de b7       	in	r29, 0x3e	; 62
    7416:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    7418:	89 81       	ldd	r24, Y+1	; 0x01
    741a:	88 23       	and	r24, r24
    741c:	31 f0       	breq	.+12     	; 0x742a <SPICS+0x1e>
    741e:	80 e4       	ldi	r24, 0x40	; 64
    7420:	96 e0       	ldi	r25, 0x06	; 6
    7422:	20 e1       	ldi	r18, 0x10	; 16
    7424:	fc 01       	movw	r30, r24
    7426:	26 83       	std	Z+6, r18	; 0x06
    7428:	05 c0       	rjmp	.+10     	; 0x7434 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    742a:	80 e4       	ldi	r24, 0x40	; 64
    742c:	96 e0       	ldi	r25, 0x06	; 6
    742e:	20 e1       	ldi	r18, 0x10	; 16
    7430:	fc 01       	movw	r30, r24
    7432:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    7434:	0f 90       	pop	r0
    7436:	df 91       	pop	r29
    7438:	cf 91       	pop	r28
    743a:	08 95       	ret

0000743c <SPIDisable>:

void SPIDisable() {
    743c:	cf 93       	push	r28
    743e:	df 93       	push	r29
    7440:	cd b7       	in	r28, 0x3d	; 61
    7442:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    7444:	80 e4       	ldi	r24, 0x40	; 64
    7446:	96 e0       	ldi	r25, 0x06	; 6
    7448:	20 e1       	ldi	r18, 0x10	; 16
    744a:	fc 01       	movw	r30, r24
    744c:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    744e:	80 ec       	ldi	r24, 0xC0	; 192
    7450:	98 e0       	ldi	r25, 0x08	; 8
    7452:	fc 01       	movw	r30, r24
    7454:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    7456:	80 e4       	ldi	r24, 0x40	; 64
    7458:	96 e0       	ldi	r25, 0x06	; 6
    745a:	20 e1       	ldi	r18, 0x10	; 16
    745c:	fc 01       	movw	r30, r24
    745e:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    7460:	80 e4       	ldi	r24, 0x40	; 64
    7462:	96 e0       	ldi	r25, 0x06	; 6
    7464:	20 eb       	ldi	r18, 0xB0	; 176
    7466:	fc 01       	movw	r30, r24
    7468:	22 83       	std	Z+2, r18	; 0x02

}
    746a:	df 91       	pop	r29
    746c:	cf 91       	pop	r28
    746e:	08 95       	ret

00007470 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    7470:	cf 93       	push	r28
    7472:	df 93       	push	r29
    7474:	00 d0       	rcall	.+0      	; 0x7476 <readFRAM+0x6>
    7476:	0f 92       	push	r0
    7478:	cd b7       	in	r28, 0x3d	; 61
    747a:	de b7       	in	r29, 0x3e	; 62
    747c:	8b 83       	std	Y+3, r24	; 0x03
    747e:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    7480:	80 e0       	ldi	r24, 0x00	; 0
    7482:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    7486:	80 ec       	ldi	r24, 0xC0	; 192
    7488:	98 e0       	ldi	r25, 0x08	; 8
    748a:	20 ed       	ldi	r18, 0xD0	; 208
    748c:	fc 01       	movw	r30, r24
    748e:	20 83       	st	Z, r18
	SPICS(TRUE);
    7490:	81 e0       	ldi	r24, 0x01	; 1
    7492:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    7496:	80 e2       	ldi	r24, 0x20	; 32
    7498:	96 e0       	ldi	r25, 0x06	; 6
    749a:	28 e0       	ldi	r18, 0x08	; 8
    749c:	fc 01       	movw	r30, r24
    749e:	26 83       	std	Z+6, r18	; 0x06
	nop();
    74a0:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    74a2:	80 ec       	ldi	r24, 0xC0	; 192
    74a4:	98 e0       	ldi	r25, 0x08	; 8
    74a6:	23 e0       	ldi	r18, 0x03	; 3
    74a8:	fc 01       	movw	r30, r24
    74aa:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74ac:	00 00       	nop
    74ae:	80 ec       	ldi	r24, 0xC0	; 192
    74b0:	98 e0       	ldi	r25, 0x08	; 8
    74b2:	fc 01       	movw	r30, r24
    74b4:	82 81       	ldd	r24, Z+2	; 0x02
    74b6:	88 23       	and	r24, r24
    74b8:	d4 f7       	brge	.-12     	; 0x74ae <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    74ba:	80 ec       	ldi	r24, 0xC0	; 192
    74bc:	98 e0       	ldi	r25, 0x08	; 8
    74be:	fc 01       	movw	r30, r24
    74c0:	83 81       	ldd	r24, Z+3	; 0x03
    74c2:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    74c6:	80 ec       	ldi	r24, 0xC0	; 192
    74c8:	98 e0       	ldi	r25, 0x08	; 8
    74ca:	20 91 59 40 	lds	r18, 0x4059
    74ce:	fc 01       	movw	r30, r24
    74d0:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74d2:	00 00       	nop
    74d4:	80 ec       	ldi	r24, 0xC0	; 192
    74d6:	98 e0       	ldi	r25, 0x08	; 8
    74d8:	fc 01       	movw	r30, r24
    74da:	82 81       	ldd	r24, Z+2	; 0x02
    74dc:	88 23       	and	r24, r24
    74de:	d4 f7       	brge	.-12     	; 0x74d4 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    74e0:	80 ec       	ldi	r24, 0xC0	; 192
    74e2:	98 e0       	ldi	r25, 0x08	; 8
    74e4:	fc 01       	movw	r30, r24
    74e6:	83 81       	ldd	r24, Z+3	; 0x03
    74e8:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    74ec:	80 ec       	ldi	r24, 0xC0	; 192
    74ee:	98 e0       	ldi	r25, 0x08	; 8
    74f0:	28 e5       	ldi	r18, 0x58	; 88
    74f2:	30 e4       	ldi	r19, 0x40	; 64
    74f4:	f9 01       	movw	r30, r18
    74f6:	20 81       	ld	r18, Z
    74f8:	fc 01       	movw	r30, r24
    74fa:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74fc:	00 00       	nop
    74fe:	80 ec       	ldi	r24, 0xC0	; 192
    7500:	98 e0       	ldi	r25, 0x08	; 8
    7502:	fc 01       	movw	r30, r24
    7504:	82 81       	ldd	r24, Z+2	; 0x02
    7506:	88 23       	and	r24, r24
    7508:	d4 f7       	brge	.-12     	; 0x74fe <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    750a:	80 ec       	ldi	r24, 0xC0	; 192
    750c:	98 e0       	ldi	r25, 0x08	; 8
    750e:	fc 01       	movw	r30, r24
    7510:	83 81       	ldd	r24, Z+3	; 0x03
    7512:	80 93 72 50 	sts	0x5072, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7516:	19 82       	std	Y+1, r1	; 0x01
    7518:	1a 82       	std	Y+2, r1	; 0x02
    751a:	1b c0       	rjmp	.+54     	; 0x7552 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    751c:	80 ec       	ldi	r24, 0xC0	; 192
    751e:	98 e0       	ldi	r25, 0x08	; 8
    7520:	2a ea       	ldi	r18, 0xAA	; 170
    7522:	fc 01       	movw	r30, r24
    7524:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    7526:	00 00       	nop
    7528:	80 ec       	ldi	r24, 0xC0	; 192
    752a:	98 e0       	ldi	r25, 0x08	; 8
    752c:	fc 01       	movw	r30, r24
    752e:	82 81       	ldd	r24, Z+2	; 0x02
    7530:	88 23       	and	r24, r24
    7532:	d4 f7       	brge	.-12     	; 0x7528 <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    7534:	80 ec       	ldi	r24, 0xC0	; 192
    7536:	98 e0       	ldi	r25, 0x08	; 8
    7538:	fc 01       	movw	r30, r24
    753a:	23 81       	ldd	r18, Z+3	; 0x03
    753c:	89 81       	ldd	r24, Y+1	; 0x01
    753e:	9a 81       	ldd	r25, Y+2	; 0x02
    7540:	80 52       	subi	r24, 0x20	; 32
    7542:	9c 4d       	sbci	r25, 0xDC	; 220
    7544:	fc 01       	movw	r30, r24
    7546:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7548:	89 81       	ldd	r24, Y+1	; 0x01
    754a:	9a 81       	ldd	r25, Y+2	; 0x02
    754c:	01 96       	adiw	r24, 0x01	; 1
    754e:	89 83       	std	Y+1, r24	; 0x01
    7550:	9a 83       	std	Y+2, r25	; 0x02
    7552:	29 81       	ldd	r18, Y+1	; 0x01
    7554:	3a 81       	ldd	r19, Y+2	; 0x02
    7556:	8b 81       	ldd	r24, Y+3	; 0x03
    7558:	9c 81       	ldd	r25, Y+4	; 0x04
    755a:	28 17       	cp	r18, r24
    755c:	39 07       	cpc	r19, r25
    755e:	f0 f2       	brcs	.-68     	; 0x751c <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7560:	80 e2       	ldi	r24, 0x20	; 32
    7562:	96 e0       	ldi	r25, 0x06	; 6
    7564:	28 e0       	ldi	r18, 0x08	; 8
    7566:	fc 01       	movw	r30, r24
    7568:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    756a:	80 e0       	ldi	r24, 0x00	; 0
    756c:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    7570:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>

}
    7574:	24 96       	adiw	r28, 0x04	; 4
    7576:	cd bf       	out	0x3d, r28	; 61
    7578:	de bf       	out	0x3e, r29	; 62
    757a:	df 91       	pop	r29
    757c:	cf 91       	pop	r28
    757e:	08 95       	ret

00007580 <FRAMTest3Channel>:

void FRAMTest3Channel(void) {
    7580:	8f 92       	push	r8
    7582:	9f 92       	push	r9
    7584:	af 92       	push	r10
    7586:	bf 92       	push	r11
    7588:	cf 92       	push	r12
    758a:	df 92       	push	r13
    758c:	ef 92       	push	r14
    758e:	ff 92       	push	r15
    7590:	0f 93       	push	r16
    7592:	1f 93       	push	r17
    7594:	cf 93       	push	r28
    7596:	df 93       	push	r29
    7598:	cd b7       	in	r28, 0x3d	; 61
    759a:	de b7       	in	r29, 0x3e	; 62
    759c:	6b 97       	sbiw	r28, 0x1b	; 27
    759e:	cd bf       	out	0x3d, r28	; 61
    75a0:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    75a2:	19 8e       	std	Y+25, r1	; 0x19
    75a4:	1a 8e       	std	Y+26, r1	; 0x1a
    75a6:	1b 8e       	std	Y+27, r1	; 0x1b
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
    75a8:	9e 01       	movw	r18, r28
    75aa:	27 5e       	subi	r18, 0xE7	; 231
    75ac:	3f 4f       	sbci	r19, 0xFF	; 255
}

void FRAMTest3Channel(void) {
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    75ae:	8e ec       	ldi	r24, 0xCE	; 206
    75b0:	b9 01       	movw	r22, r18
    75b2:	40 e0       	ldi	r20, 0x00	; 0
    75b4:	25 e1       	ldi	r18, 0x15	; 21
    75b6:	01 e0       	ldi	r16, 0x01	; 1
    75b8:	0f 2e       	mov	r0, r31
    75ba:	fd e0       	ldi	r31, 0x0D	; 13
    75bc:	ef 2e       	mov	r14, r31
    75be:	ff 24       	eor	r15, r15
    75c0:	f0 2d       	mov	r31, r0
    75c2:	0f 2e       	mov	r0, r31
    75c4:	fe e0       	ldi	r31, 0x0E	; 14
    75c6:	cf 2e       	mov	r12, r31
    75c8:	dd 24       	eor	r13, r13
    75ca:	f0 2d       	mov	r31, r0
    75cc:	0f 2e       	mov	r0, r31
    75ce:	ff e0       	ldi	r31, 0x0F	; 15
    75d0:	af 2e       	mov	r10, r31
    75d2:	bb 24       	eor	r11, r11
    75d4:	f0 2d       	mov	r31, r0
    75d6:	88 24       	eor	r8, r8
    75d8:	99 24       	eor	r9, r9
    75da:	68 94       	set
    75dc:	84 f8       	bld	r8, 4
    75de:	0e 94 43 11 	call	0x2286	; 0x2286 <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    75e2:	81 e0       	ldi	r24, 0x01	; 1
    75e4:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
    75e8:	80 e0       	ldi	r24, 0x00	; 0
    75ea:	90 e0       	ldi	r25, 0x00	; 0
    75ec:	aa e7       	ldi	r26, 0x7A	; 122
    75ee:	b3 e4       	ldi	r27, 0x43	; 67
    75f0:	89 83       	std	Y+1, r24	; 0x01
    75f2:	9a 83       	std	Y+2, r25	; 0x02
    75f4:	ab 83       	std	Y+3, r26	; 0x03
    75f6:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    75f8:	69 81       	ldd	r22, Y+1	; 0x01
    75fa:	7a 81       	ldd	r23, Y+2	; 0x02
    75fc:	8b 81       	ldd	r24, Y+3	; 0x03
    75fe:	9c 81       	ldd	r25, Y+4	; 0x04
    7600:	2b ea       	ldi	r18, 0xAB	; 171
    7602:	3a ea       	ldi	r19, 0xAA	; 170
    7604:	4a e2       	ldi	r20, 0x2A	; 42
    7606:	51 e4       	ldi	r21, 0x41	; 65
    7608:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    760c:	dc 01       	movw	r26, r24
    760e:	cb 01       	movw	r24, r22
    7610:	8d 83       	std	Y+5, r24	; 0x05
    7612:	9e 83       	std	Y+6, r25	; 0x06
    7614:	af 83       	std	Y+7, r26	; 0x07
    7616:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7618:	11 e0       	ldi	r17, 0x01	; 1
    761a:	6d 81       	ldd	r22, Y+5	; 0x05
    761c:	7e 81       	ldd	r23, Y+6	; 0x06
    761e:	8f 81       	ldd	r24, Y+7	; 0x07
    7620:	98 85       	ldd	r25, Y+8	; 0x08
    7622:	20 e0       	ldi	r18, 0x00	; 0
    7624:	30 e0       	ldi	r19, 0x00	; 0
    7626:	40 e8       	ldi	r20, 0x80	; 128
    7628:	5f e3       	ldi	r21, 0x3F	; 63
    762a:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    762e:	88 23       	and	r24, r24
    7630:	0c f0       	brlt	.+2      	; 0x7634 <FRAMTest3Channel+0xb4>
    7632:	10 e0       	ldi	r17, 0x00	; 0
    7634:	11 23       	and	r17, r17
    7636:	19 f0       	breq	.+6      	; 0x763e <FRAMTest3Channel+0xbe>
		__ticks = 1;
    7638:	81 e0       	ldi	r24, 0x01	; 1
    763a:	89 87       	std	Y+9, r24	; 0x09
    763c:	a3 c0       	rjmp	.+326    	; 0x7784 <FRAMTest3Channel+0x204>
	else if (__tmp > 255)
    763e:	11 e0       	ldi	r17, 0x01	; 1
    7640:	6d 81       	ldd	r22, Y+5	; 0x05
    7642:	7e 81       	ldd	r23, Y+6	; 0x06
    7644:	8f 81       	ldd	r24, Y+7	; 0x07
    7646:	98 85       	ldd	r25, Y+8	; 0x08
    7648:	20 e0       	ldi	r18, 0x00	; 0
    764a:	30 e0       	ldi	r19, 0x00	; 0
    764c:	4f e7       	ldi	r20, 0x7F	; 127
    764e:	53 e4       	ldi	r21, 0x43	; 67
    7650:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7654:	18 16       	cp	r1, r24
    7656:	0c f0       	brlt	.+2      	; 0x765a <FRAMTest3Channel+0xda>
    7658:	10 e0       	ldi	r17, 0x00	; 0
    765a:	11 23       	and	r17, r17
    765c:	09 f4       	brne	.+2      	; 0x7660 <FRAMTest3Channel+0xe0>
    765e:	89 c0       	rjmp	.+274    	; 0x7772 <FRAMTest3Channel+0x1f2>
	{
		_delay_ms(__us / 1000.0);
    7660:	69 81       	ldd	r22, Y+1	; 0x01
    7662:	7a 81       	ldd	r23, Y+2	; 0x02
    7664:	8b 81       	ldd	r24, Y+3	; 0x03
    7666:	9c 81       	ldd	r25, Y+4	; 0x04
    7668:	20 e0       	ldi	r18, 0x00	; 0
    766a:	30 e0       	ldi	r19, 0x00	; 0
    766c:	4a e7       	ldi	r20, 0x7A	; 122
    766e:	54 e4       	ldi	r21, 0x44	; 68
    7670:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    7674:	dc 01       	movw	r26, r24
    7676:	cb 01       	movw	r24, r22
    7678:	8a 87       	std	Y+10, r24	; 0x0a
    767a:	9b 87       	std	Y+11, r25	; 0x0b
    767c:	ac 87       	std	Y+12, r26	; 0x0c
    767e:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7680:	6a 85       	ldd	r22, Y+10	; 0x0a
    7682:	7b 85       	ldd	r23, Y+11	; 0x0b
    7684:	8c 85       	ldd	r24, Y+12	; 0x0c
    7686:	9d 85       	ldd	r25, Y+13	; 0x0d
    7688:	20 e0       	ldi	r18, 0x00	; 0
    768a:	30 e0       	ldi	r19, 0x00	; 0
    768c:	4a ef       	ldi	r20, 0xFA	; 250
    768e:	55 e4       	ldi	r21, 0x45	; 69
    7690:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7694:	dc 01       	movw	r26, r24
    7696:	cb 01       	movw	r24, r22
    7698:	8e 87       	std	Y+14, r24	; 0x0e
    769a:	9f 87       	std	Y+15, r25	; 0x0f
    769c:	a8 8b       	std	Y+16, r26	; 0x10
    769e:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    76a0:	11 e0       	ldi	r17, 0x01	; 1
    76a2:	6e 85       	ldd	r22, Y+14	; 0x0e
    76a4:	7f 85       	ldd	r23, Y+15	; 0x0f
    76a6:	88 89       	ldd	r24, Y+16	; 0x10
    76a8:	99 89       	ldd	r25, Y+17	; 0x11
    76aa:	20 e0       	ldi	r18, 0x00	; 0
    76ac:	30 e0       	ldi	r19, 0x00	; 0
    76ae:	40 e8       	ldi	r20, 0x80	; 128
    76b0:	5f e3       	ldi	r21, 0x3F	; 63
    76b2:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    76b6:	88 23       	and	r24, r24
    76b8:	0c f0       	brlt	.+2      	; 0x76bc <FRAMTest3Channel+0x13c>
    76ba:	10 e0       	ldi	r17, 0x00	; 0
    76bc:	11 23       	and	r17, r17
    76be:	29 f0       	breq	.+10     	; 0x76ca <FRAMTest3Channel+0x14a>
		__ticks = 1;
    76c0:	81 e0       	ldi	r24, 0x01	; 1
    76c2:	90 e0       	ldi	r25, 0x00	; 0
    76c4:	8a 8b       	std	Y+18, r24	; 0x12
    76c6:	9b 8b       	std	Y+19, r25	; 0x13
    76c8:	46 c0       	rjmp	.+140    	; 0x7756 <FRAMTest3Channel+0x1d6>
	else if (__tmp > 65535)
    76ca:	11 e0       	ldi	r17, 0x01	; 1
    76cc:	6e 85       	ldd	r22, Y+14	; 0x0e
    76ce:	7f 85       	ldd	r23, Y+15	; 0x0f
    76d0:	88 89       	ldd	r24, Y+16	; 0x10
    76d2:	99 89       	ldd	r25, Y+17	; 0x11
    76d4:	20 e0       	ldi	r18, 0x00	; 0
    76d6:	3f ef       	ldi	r19, 0xFF	; 255
    76d8:	4f e7       	ldi	r20, 0x7F	; 127
    76da:	57 e4       	ldi	r21, 0x47	; 71
    76dc:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    76e0:	18 16       	cp	r1, r24
    76e2:	0c f0       	brlt	.+2      	; 0x76e6 <FRAMTest3Channel+0x166>
    76e4:	10 e0       	ldi	r17, 0x00	; 0
    76e6:	11 23       	and	r17, r17
    76e8:	61 f1       	breq	.+88     	; 0x7742 <FRAMTest3Channel+0x1c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    76ea:	6a 85       	ldd	r22, Y+10	; 0x0a
    76ec:	7b 85       	ldd	r23, Y+11	; 0x0b
    76ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    76f0:	9d 85       	ldd	r25, Y+13	; 0x0d
    76f2:	20 e0       	ldi	r18, 0x00	; 0
    76f4:	30 e0       	ldi	r19, 0x00	; 0
    76f6:	40 e2       	ldi	r20, 0x20	; 32
    76f8:	51 e4       	ldi	r21, 0x41	; 65
    76fa:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    76fe:	dc 01       	movw	r26, r24
    7700:	cb 01       	movw	r24, r22
    7702:	bc 01       	movw	r22, r24
    7704:	cd 01       	movw	r24, r26
    7706:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    770a:	dc 01       	movw	r26, r24
    770c:	cb 01       	movw	r24, r22
    770e:	8a 8b       	std	Y+18, r24	; 0x12
    7710:	9b 8b       	std	Y+19, r25	; 0x13
    7712:	12 c0       	rjmp	.+36     	; 0x7738 <FRAMTest3Channel+0x1b8>
    7714:	80 e2       	ldi	r24, 0x20	; 32
    7716:	93 e0       	ldi	r25, 0x03	; 3
    7718:	8c 8b       	std	Y+20, r24	; 0x14
    771a:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    771c:	8c 89       	ldd	r24, Y+20	; 0x14
    771e:	9d 89       	ldd	r25, Y+21	; 0x15
    7720:	8c 01       	movw	r16, r24
    7722:	c8 01       	movw	r24, r16
    7724:	01 97       	sbiw	r24, 0x01	; 1
    7726:	f1 f7       	brne	.-4      	; 0x7724 <FRAMTest3Channel+0x1a4>
    7728:	8c 01       	movw	r16, r24
    772a:	0c 8b       	std	Y+20, r16	; 0x14
    772c:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    772e:	8a 89       	ldd	r24, Y+18	; 0x12
    7730:	9b 89       	ldd	r25, Y+19	; 0x13
    7732:	01 97       	sbiw	r24, 0x01	; 1
    7734:	8a 8b       	std	Y+18, r24	; 0x12
    7736:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7738:	8a 89       	ldd	r24, Y+18	; 0x12
    773a:	9b 89       	ldd	r25, Y+19	; 0x13
    773c:	00 97       	sbiw	r24, 0x00	; 0
    773e:	51 f7       	brne	.-44     	; 0x7714 <FRAMTest3Channel+0x194>
    7740:	28 c0       	rjmp	.+80     	; 0x7792 <FRAMTest3Channel+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7742:	6e 85       	ldd	r22, Y+14	; 0x0e
    7744:	7f 85       	ldd	r23, Y+15	; 0x0f
    7746:	88 89       	ldd	r24, Y+16	; 0x10
    7748:	99 89       	ldd	r25, Y+17	; 0x11
    774a:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    774e:	dc 01       	movw	r26, r24
    7750:	cb 01       	movw	r24, r22
    7752:	8a 8b       	std	Y+18, r24	; 0x12
    7754:	9b 8b       	std	Y+19, r25	; 0x13
    7756:	8a 89       	ldd	r24, Y+18	; 0x12
    7758:	9b 89       	ldd	r25, Y+19	; 0x13
    775a:	8e 8b       	std	Y+22, r24	; 0x16
    775c:	9f 8b       	std	Y+23, r25	; 0x17
    775e:	8e 89       	ldd	r24, Y+22	; 0x16
    7760:	9f 89       	ldd	r25, Y+23	; 0x17
    7762:	8c 01       	movw	r16, r24
    7764:	c8 01       	movw	r24, r16
    7766:	01 97       	sbiw	r24, 0x01	; 1
    7768:	f1 f7       	brne	.-4      	; 0x7766 <FRAMTest3Channel+0x1e6>
    776a:	8c 01       	movw	r16, r24
    776c:	0e 8b       	std	Y+22, r16	; 0x16
    776e:	1f 8b       	std	Y+23, r17	; 0x17
    7770:	10 c0       	rjmp	.+32     	; 0x7792 <FRAMTest3Channel+0x212>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7772:	6d 81       	ldd	r22, Y+5	; 0x05
    7774:	7e 81       	ldd	r23, Y+6	; 0x06
    7776:	8f 81       	ldd	r24, Y+7	; 0x07
    7778:	98 85       	ldd	r25, Y+8	; 0x08
    777a:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    777e:	dc 01       	movw	r26, r24
    7780:	cb 01       	movw	r24, r22
    7782:	89 87       	std	Y+9, r24	; 0x09
    7784:	89 85       	ldd	r24, Y+9	; 0x09
    7786:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7788:	88 8d       	ldd	r24, Y+24	; 0x18
    778a:	18 2f       	mov	r17, r24
    778c:	1a 95       	dec	r17
    778e:	f1 f7       	brne	.-4      	; 0x778c <FRAMTest3Channel+0x20c>
    7790:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7792:	0e 94 47 18 	call	0x308e	; 0x308e <calcChecksumFRAM>

	ADCPower(FALSE);
    7796:	80 e0       	ldi	r24, 0x00	; 0
    7798:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	
}
    779c:	6b 96       	adiw	r28, 0x1b	; 27
    779e:	cd bf       	out	0x3d, r28	; 61
    77a0:	de bf       	out	0x3e, r29	; 62
    77a2:	df 91       	pop	r29
    77a4:	cf 91       	pop	r28
    77a6:	1f 91       	pop	r17
    77a8:	0f 91       	pop	r16
    77aa:	ff 90       	pop	r15
    77ac:	ef 90       	pop	r14
    77ae:	df 90       	pop	r13
    77b0:	cf 90       	pop	r12
    77b2:	bf 90       	pop	r11
    77b4:	af 90       	pop	r10
    77b6:	9f 90       	pop	r9
    77b8:	8f 90       	pop	r8
    77ba:	08 95       	ret

000077bc <FRAMTest1Channel>:

void FRAMTest1Channel(void) {
    77bc:	8f 92       	push	r8
    77be:	9f 92       	push	r9
    77c0:	af 92       	push	r10
    77c2:	bf 92       	push	r11
    77c4:	cf 92       	push	r12
    77c6:	df 92       	push	r13
    77c8:	ef 92       	push	r14
    77ca:	0f 93       	push	r16
    77cc:	1f 93       	push	r17
    77ce:	cf 93       	push	r28
    77d0:	df 93       	push	r29
    77d2:	cd b7       	in	r28, 0x3d	; 61
    77d4:	de b7       	in	r29, 0x3e	; 62
    77d6:	68 97       	sbiw	r28, 0x18	; 24
    77d8:	cd bf       	out	0x3d, r28	; 61
    77da:	de bf       	out	0x3e, r29	; 62

	CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
    77dc:	0f 92       	push	r0
    77de:	0f 92       	push	r0
    77e0:	8d b7       	in	r24, 0x3d	; 61
    77e2:	9e b7       	in	r25, 0x3e	; 62
    77e4:	01 96       	adiw	r24, 0x01	; 1
    77e6:	20 e1       	ldi	r18, 0x10	; 16
    77e8:	30 e0       	ldi	r19, 0x00	; 0
    77ea:	fc 01       	movw	r30, r24
    77ec:	20 83       	st	Z, r18
    77ee:	31 83       	std	Z+1, r19	; 0x01
    77f0:	87 e0       	ldi	r24, 0x07	; 7
    77f2:	68 ec       	ldi	r22, 0xC8	; 200
    77f4:	40 e0       	ldi	r20, 0x00	; 0
    77f6:	20 e0       	ldi	r18, 0x00	; 0
    77f8:	05 e1       	ldi	r16, 0x15	; 21
    77fa:	ee 24       	eor	r14, r14
    77fc:	e3 94       	inc	r14
    77fe:	0f 2e       	mov	r0, r31
    7800:	fd e0       	ldi	r31, 0x0D	; 13
    7802:	cf 2e       	mov	r12, r31
    7804:	dd 24       	eor	r13, r13
    7806:	f0 2d       	mov	r31, r0
    7808:	0f 2e       	mov	r0, r31
    780a:	fe e0       	ldi	r31, 0x0E	; 14
    780c:	af 2e       	mov	r10, r31
    780e:	bb 24       	eor	r11, r11
    7810:	f0 2d       	mov	r31, r0
    7812:	0f 2e       	mov	r0, r31
    7814:	ff e0       	ldi	r31, 0x0F	; 15
    7816:	8f 2e       	mov	r8, r31
    7818:	99 24       	eor	r9, r9
    781a:	f0 2d       	mov	r31, r0
    781c:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <CO_collectSeismic1Channel>
    7820:	0f 90       	pop	r0
    7822:	0f 90       	pop	r0
	GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7824:	81 e0       	ldi	r24, 0x01	; 1
    7826:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
    782a:	80 e0       	ldi	r24, 0x00	; 0
    782c:	90 e0       	ldi	r25, 0x00	; 0
    782e:	aa e7       	ldi	r26, 0x7A	; 122
    7830:	b3 e4       	ldi	r27, 0x43	; 67
    7832:	89 83       	std	Y+1, r24	; 0x01
    7834:	9a 83       	std	Y+2, r25	; 0x02
    7836:	ab 83       	std	Y+3, r26	; 0x03
    7838:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    783a:	69 81       	ldd	r22, Y+1	; 0x01
    783c:	7a 81       	ldd	r23, Y+2	; 0x02
    783e:	8b 81       	ldd	r24, Y+3	; 0x03
    7840:	9c 81       	ldd	r25, Y+4	; 0x04
    7842:	2b ea       	ldi	r18, 0xAB	; 171
    7844:	3a ea       	ldi	r19, 0xAA	; 170
    7846:	4a e2       	ldi	r20, 0x2A	; 42
    7848:	51 e4       	ldi	r21, 0x41	; 65
    784a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    784e:	dc 01       	movw	r26, r24
    7850:	cb 01       	movw	r24, r22
    7852:	8d 83       	std	Y+5, r24	; 0x05
    7854:	9e 83       	std	Y+6, r25	; 0x06
    7856:	af 83       	std	Y+7, r26	; 0x07
    7858:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    785a:	11 e0       	ldi	r17, 0x01	; 1
    785c:	6d 81       	ldd	r22, Y+5	; 0x05
    785e:	7e 81       	ldd	r23, Y+6	; 0x06
    7860:	8f 81       	ldd	r24, Y+7	; 0x07
    7862:	98 85       	ldd	r25, Y+8	; 0x08
    7864:	20 e0       	ldi	r18, 0x00	; 0
    7866:	30 e0       	ldi	r19, 0x00	; 0
    7868:	40 e8       	ldi	r20, 0x80	; 128
    786a:	5f e3       	ldi	r21, 0x3F	; 63
    786c:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7870:	88 23       	and	r24, r24
    7872:	0c f0       	brlt	.+2      	; 0x7876 <FRAMTest1Channel+0xba>
    7874:	10 e0       	ldi	r17, 0x00	; 0
    7876:	11 23       	and	r17, r17
    7878:	19 f0       	breq	.+6      	; 0x7880 <FRAMTest1Channel+0xc4>
		__ticks = 1;
    787a:	81 e0       	ldi	r24, 0x01	; 1
    787c:	89 87       	std	Y+9, r24	; 0x09
    787e:	a3 c0       	rjmp	.+326    	; 0x79c6 <FRAMTest1Channel+0x20a>
	else if (__tmp > 255)
    7880:	11 e0       	ldi	r17, 0x01	; 1
    7882:	6d 81       	ldd	r22, Y+5	; 0x05
    7884:	7e 81       	ldd	r23, Y+6	; 0x06
    7886:	8f 81       	ldd	r24, Y+7	; 0x07
    7888:	98 85       	ldd	r25, Y+8	; 0x08
    788a:	20 e0       	ldi	r18, 0x00	; 0
    788c:	30 e0       	ldi	r19, 0x00	; 0
    788e:	4f e7       	ldi	r20, 0x7F	; 127
    7890:	53 e4       	ldi	r21, 0x43	; 67
    7892:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7896:	18 16       	cp	r1, r24
    7898:	0c f0       	brlt	.+2      	; 0x789c <FRAMTest1Channel+0xe0>
    789a:	10 e0       	ldi	r17, 0x00	; 0
    789c:	11 23       	and	r17, r17
    789e:	09 f4       	brne	.+2      	; 0x78a2 <FRAMTest1Channel+0xe6>
    78a0:	89 c0       	rjmp	.+274    	; 0x79b4 <FRAMTest1Channel+0x1f8>
	{
		_delay_ms(__us / 1000.0);
    78a2:	69 81       	ldd	r22, Y+1	; 0x01
    78a4:	7a 81       	ldd	r23, Y+2	; 0x02
    78a6:	8b 81       	ldd	r24, Y+3	; 0x03
    78a8:	9c 81       	ldd	r25, Y+4	; 0x04
    78aa:	20 e0       	ldi	r18, 0x00	; 0
    78ac:	30 e0       	ldi	r19, 0x00	; 0
    78ae:	4a e7       	ldi	r20, 0x7A	; 122
    78b0:	54 e4       	ldi	r21, 0x44	; 68
    78b2:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    78b6:	dc 01       	movw	r26, r24
    78b8:	cb 01       	movw	r24, r22
    78ba:	8a 87       	std	Y+10, r24	; 0x0a
    78bc:	9b 87       	std	Y+11, r25	; 0x0b
    78be:	ac 87       	std	Y+12, r26	; 0x0c
    78c0:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    78c2:	6a 85       	ldd	r22, Y+10	; 0x0a
    78c4:	7b 85       	ldd	r23, Y+11	; 0x0b
    78c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    78c8:	9d 85       	ldd	r25, Y+13	; 0x0d
    78ca:	20 e0       	ldi	r18, 0x00	; 0
    78cc:	30 e0       	ldi	r19, 0x00	; 0
    78ce:	4a ef       	ldi	r20, 0xFA	; 250
    78d0:	55 e4       	ldi	r21, 0x45	; 69
    78d2:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    78d6:	dc 01       	movw	r26, r24
    78d8:	cb 01       	movw	r24, r22
    78da:	8e 87       	std	Y+14, r24	; 0x0e
    78dc:	9f 87       	std	Y+15, r25	; 0x0f
    78de:	a8 8b       	std	Y+16, r26	; 0x10
    78e0:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    78e2:	11 e0       	ldi	r17, 0x01	; 1
    78e4:	6e 85       	ldd	r22, Y+14	; 0x0e
    78e6:	7f 85       	ldd	r23, Y+15	; 0x0f
    78e8:	88 89       	ldd	r24, Y+16	; 0x10
    78ea:	99 89       	ldd	r25, Y+17	; 0x11
    78ec:	20 e0       	ldi	r18, 0x00	; 0
    78ee:	30 e0       	ldi	r19, 0x00	; 0
    78f0:	40 e8       	ldi	r20, 0x80	; 128
    78f2:	5f e3       	ldi	r21, 0x3F	; 63
    78f4:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    78f8:	88 23       	and	r24, r24
    78fa:	0c f0       	brlt	.+2      	; 0x78fe <FRAMTest1Channel+0x142>
    78fc:	10 e0       	ldi	r17, 0x00	; 0
    78fe:	11 23       	and	r17, r17
    7900:	29 f0       	breq	.+10     	; 0x790c <FRAMTest1Channel+0x150>
		__ticks = 1;
    7902:	81 e0       	ldi	r24, 0x01	; 1
    7904:	90 e0       	ldi	r25, 0x00	; 0
    7906:	8a 8b       	std	Y+18, r24	; 0x12
    7908:	9b 8b       	std	Y+19, r25	; 0x13
    790a:	46 c0       	rjmp	.+140    	; 0x7998 <FRAMTest1Channel+0x1dc>
	else if (__tmp > 65535)
    790c:	11 e0       	ldi	r17, 0x01	; 1
    790e:	6e 85       	ldd	r22, Y+14	; 0x0e
    7910:	7f 85       	ldd	r23, Y+15	; 0x0f
    7912:	88 89       	ldd	r24, Y+16	; 0x10
    7914:	99 89       	ldd	r25, Y+17	; 0x11
    7916:	20 e0       	ldi	r18, 0x00	; 0
    7918:	3f ef       	ldi	r19, 0xFF	; 255
    791a:	4f e7       	ldi	r20, 0x7F	; 127
    791c:	57 e4       	ldi	r21, 0x47	; 71
    791e:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7922:	18 16       	cp	r1, r24
    7924:	0c f0       	brlt	.+2      	; 0x7928 <FRAMTest1Channel+0x16c>
    7926:	10 e0       	ldi	r17, 0x00	; 0
    7928:	11 23       	and	r17, r17
    792a:	61 f1       	breq	.+88     	; 0x7984 <FRAMTest1Channel+0x1c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    792c:	6a 85       	ldd	r22, Y+10	; 0x0a
    792e:	7b 85       	ldd	r23, Y+11	; 0x0b
    7930:	8c 85       	ldd	r24, Y+12	; 0x0c
    7932:	9d 85       	ldd	r25, Y+13	; 0x0d
    7934:	20 e0       	ldi	r18, 0x00	; 0
    7936:	30 e0       	ldi	r19, 0x00	; 0
    7938:	40 e2       	ldi	r20, 0x20	; 32
    793a:	51 e4       	ldi	r21, 0x41	; 65
    793c:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7940:	dc 01       	movw	r26, r24
    7942:	cb 01       	movw	r24, r22
    7944:	bc 01       	movw	r22, r24
    7946:	cd 01       	movw	r24, r26
    7948:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    794c:	dc 01       	movw	r26, r24
    794e:	cb 01       	movw	r24, r22
    7950:	8a 8b       	std	Y+18, r24	; 0x12
    7952:	9b 8b       	std	Y+19, r25	; 0x13
    7954:	12 c0       	rjmp	.+36     	; 0x797a <FRAMTest1Channel+0x1be>
    7956:	80 e2       	ldi	r24, 0x20	; 32
    7958:	93 e0       	ldi	r25, 0x03	; 3
    795a:	8c 8b       	std	Y+20, r24	; 0x14
    795c:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    795e:	8c 89       	ldd	r24, Y+20	; 0x14
    7960:	9d 89       	ldd	r25, Y+21	; 0x15
    7962:	8c 01       	movw	r16, r24
    7964:	c8 01       	movw	r24, r16
    7966:	01 97       	sbiw	r24, 0x01	; 1
    7968:	f1 f7       	brne	.-4      	; 0x7966 <FRAMTest1Channel+0x1aa>
    796a:	8c 01       	movw	r16, r24
    796c:	0c 8b       	std	Y+20, r16	; 0x14
    796e:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7970:	8a 89       	ldd	r24, Y+18	; 0x12
    7972:	9b 89       	ldd	r25, Y+19	; 0x13
    7974:	01 97       	sbiw	r24, 0x01	; 1
    7976:	8a 8b       	std	Y+18, r24	; 0x12
    7978:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    797a:	8a 89       	ldd	r24, Y+18	; 0x12
    797c:	9b 89       	ldd	r25, Y+19	; 0x13
    797e:	00 97       	sbiw	r24, 0x00	; 0
    7980:	51 f7       	brne	.-44     	; 0x7956 <FRAMTest1Channel+0x19a>
    7982:	28 c0       	rjmp	.+80     	; 0x79d4 <FRAMTest1Channel+0x218>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7984:	6e 85       	ldd	r22, Y+14	; 0x0e
    7986:	7f 85       	ldd	r23, Y+15	; 0x0f
    7988:	88 89       	ldd	r24, Y+16	; 0x10
    798a:	99 89       	ldd	r25, Y+17	; 0x11
    798c:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7990:	dc 01       	movw	r26, r24
    7992:	cb 01       	movw	r24, r22
    7994:	8a 8b       	std	Y+18, r24	; 0x12
    7996:	9b 8b       	std	Y+19, r25	; 0x13
    7998:	8a 89       	ldd	r24, Y+18	; 0x12
    799a:	9b 89       	ldd	r25, Y+19	; 0x13
    799c:	8e 8b       	std	Y+22, r24	; 0x16
    799e:	9f 8b       	std	Y+23, r25	; 0x17
    79a0:	8e 89       	ldd	r24, Y+22	; 0x16
    79a2:	9f 89       	ldd	r25, Y+23	; 0x17
    79a4:	8c 01       	movw	r16, r24
    79a6:	f8 01       	movw	r30, r16
    79a8:	31 97       	sbiw	r30, 0x01	; 1
    79aa:	f1 f7       	brne	.-4      	; 0x79a8 <FRAMTest1Channel+0x1ec>
    79ac:	8f 01       	movw	r16, r30
    79ae:	0e 8b       	std	Y+22, r16	; 0x16
    79b0:	1f 8b       	std	Y+23, r17	; 0x17
    79b2:	10 c0       	rjmp	.+32     	; 0x79d4 <FRAMTest1Channel+0x218>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    79b4:	6d 81       	ldd	r22, Y+5	; 0x05
    79b6:	7e 81       	ldd	r23, Y+6	; 0x06
    79b8:	8f 81       	ldd	r24, Y+7	; 0x07
    79ba:	98 85       	ldd	r25, Y+8	; 0x08
    79bc:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    79c0:	dc 01       	movw	r26, r24
    79c2:	cb 01       	movw	r24, r22
    79c4:	89 87       	std	Y+9, r24	; 0x09
    79c6:	89 85       	ldd	r24, Y+9	; 0x09
    79c8:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    79ca:	88 8d       	ldd	r24, Y+24	; 0x18
    79cc:	18 2f       	mov	r17, r24
    79ce:	1a 95       	dec	r17
    79d0:	f1 f7       	brne	.-4      	; 0x79ce <FRAMTest1Channel+0x212>
    79d2:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    79d4:	0e 94 47 18 	call	0x308e	; 0x308e <calcChecksumFRAM>

	ADCPower(FALSE);
    79d8:	80 e0       	ldi	r24, 0x00	; 0
    79da:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>

}
    79de:	68 96       	adiw	r28, 0x18	; 24
    79e0:	cd bf       	out	0x3d, r28	; 61
    79e2:	de bf       	out	0x3e, r29	; 62
    79e4:	df 91       	pop	r29
    79e6:	cf 91       	pop	r28
    79e8:	1f 91       	pop	r17
    79ea:	0f 91       	pop	r16
    79ec:	ef 90       	pop	r14
    79ee:	df 90       	pop	r13
    79f0:	cf 90       	pop	r12
    79f2:	bf 90       	pop	r11
    79f4:	af 90       	pop	r10
    79f6:	9f 90       	pop	r9
    79f8:	8f 90       	pop	r8
    79fa:	08 95       	ret

000079fc <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    79fc:	0f 93       	push	r16
    79fe:	1f 93       	push	r17
    7a00:	cf 93       	push	r28
    7a02:	df 93       	push	r29
    7a04:	cd b7       	in	r28, 0x3d	; 61
    7a06:	de b7       	in	r29, 0x3e	; 62
    7a08:	68 97       	sbiw	r28, 0x18	; 24
    7a0a:	cd bf       	out	0x3d, r28	; 61
    7a0c:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    7a0e:	0e 94 4f 1b 	call	0x369e	; 0x369e <FRAMWriteKnowns>
	ADCPower(TRUE);
    7a12:	81 e0       	ldi	r24, 0x01	; 1
    7a14:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
    7a18:	80 e0       	ldi	r24, 0x00	; 0
    7a1a:	90 e0       	ldi	r25, 0x00	; 0
    7a1c:	aa e7       	ldi	r26, 0x7A	; 122
    7a1e:	b3 e4       	ldi	r27, 0x43	; 67
    7a20:	89 83       	std	Y+1, r24	; 0x01
    7a22:	9a 83       	std	Y+2, r25	; 0x02
    7a24:	ab 83       	std	Y+3, r26	; 0x03
    7a26:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7a28:	69 81       	ldd	r22, Y+1	; 0x01
    7a2a:	7a 81       	ldd	r23, Y+2	; 0x02
    7a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    7a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    7a30:	2b ea       	ldi	r18, 0xAB	; 171
    7a32:	3a ea       	ldi	r19, 0xAA	; 170
    7a34:	4a e2       	ldi	r20, 0x2A	; 42
    7a36:	51 e4       	ldi	r21, 0x41	; 65
    7a38:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7a3c:	dc 01       	movw	r26, r24
    7a3e:	cb 01       	movw	r24, r22
    7a40:	8d 83       	std	Y+5, r24	; 0x05
    7a42:	9e 83       	std	Y+6, r25	; 0x06
    7a44:	af 83       	std	Y+7, r26	; 0x07
    7a46:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7a48:	11 e0       	ldi	r17, 0x01	; 1
    7a4a:	6d 81       	ldd	r22, Y+5	; 0x05
    7a4c:	7e 81       	ldd	r23, Y+6	; 0x06
    7a4e:	8f 81       	ldd	r24, Y+7	; 0x07
    7a50:	98 85       	ldd	r25, Y+8	; 0x08
    7a52:	20 e0       	ldi	r18, 0x00	; 0
    7a54:	30 e0       	ldi	r19, 0x00	; 0
    7a56:	40 e8       	ldi	r20, 0x80	; 128
    7a58:	5f e3       	ldi	r21, 0x3F	; 63
    7a5a:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7a5e:	88 23       	and	r24, r24
    7a60:	0c f0       	brlt	.+2      	; 0x7a64 <FRAMWriteKnownsCheck+0x68>
    7a62:	10 e0       	ldi	r17, 0x00	; 0
    7a64:	11 23       	and	r17, r17
    7a66:	19 f0       	breq	.+6      	; 0x7a6e <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    7a68:	81 e0       	ldi	r24, 0x01	; 1
    7a6a:	89 87       	std	Y+9, r24	; 0x09
    7a6c:	a3 c0       	rjmp	.+326    	; 0x7bb4 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7a6e:	11 e0       	ldi	r17, 0x01	; 1
    7a70:	6d 81       	ldd	r22, Y+5	; 0x05
    7a72:	7e 81       	ldd	r23, Y+6	; 0x06
    7a74:	8f 81       	ldd	r24, Y+7	; 0x07
    7a76:	98 85       	ldd	r25, Y+8	; 0x08
    7a78:	20 e0       	ldi	r18, 0x00	; 0
    7a7a:	30 e0       	ldi	r19, 0x00	; 0
    7a7c:	4f e7       	ldi	r20, 0x7F	; 127
    7a7e:	53 e4       	ldi	r21, 0x43	; 67
    7a80:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7a84:	18 16       	cp	r1, r24
    7a86:	0c f0       	brlt	.+2      	; 0x7a8a <FRAMWriteKnownsCheck+0x8e>
    7a88:	10 e0       	ldi	r17, 0x00	; 0
    7a8a:	11 23       	and	r17, r17
    7a8c:	09 f4       	brne	.+2      	; 0x7a90 <FRAMWriteKnownsCheck+0x94>
    7a8e:	89 c0       	rjmp	.+274    	; 0x7ba2 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7a90:	69 81       	ldd	r22, Y+1	; 0x01
    7a92:	7a 81       	ldd	r23, Y+2	; 0x02
    7a94:	8b 81       	ldd	r24, Y+3	; 0x03
    7a96:	9c 81       	ldd	r25, Y+4	; 0x04
    7a98:	20 e0       	ldi	r18, 0x00	; 0
    7a9a:	30 e0       	ldi	r19, 0x00	; 0
    7a9c:	4a e7       	ldi	r20, 0x7A	; 122
    7a9e:	54 e4       	ldi	r21, 0x44	; 68
    7aa0:	0e 94 02 5d 	call	0xba04	; 0xba04 <__divsf3>
    7aa4:	dc 01       	movw	r26, r24
    7aa6:	cb 01       	movw	r24, r22
    7aa8:	8a 87       	std	Y+10, r24	; 0x0a
    7aaa:	9b 87       	std	Y+11, r25	; 0x0b
    7aac:	ac 87       	std	Y+12, r26	; 0x0c
    7aae:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7ab0:	6a 85       	ldd	r22, Y+10	; 0x0a
    7ab2:	7b 85       	ldd	r23, Y+11	; 0x0b
    7ab4:	8c 85       	ldd	r24, Y+12	; 0x0c
    7ab6:	9d 85       	ldd	r25, Y+13	; 0x0d
    7ab8:	20 e0       	ldi	r18, 0x00	; 0
    7aba:	30 e0       	ldi	r19, 0x00	; 0
    7abc:	4a ef       	ldi	r20, 0xFA	; 250
    7abe:	55 e4       	ldi	r21, 0x45	; 69
    7ac0:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7ac4:	dc 01       	movw	r26, r24
    7ac6:	cb 01       	movw	r24, r22
    7ac8:	8e 87       	std	Y+14, r24	; 0x0e
    7aca:	9f 87       	std	Y+15, r25	; 0x0f
    7acc:	a8 8b       	std	Y+16, r26	; 0x10
    7ace:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7ad0:	11 e0       	ldi	r17, 0x01	; 1
    7ad2:	6e 85       	ldd	r22, Y+14	; 0x0e
    7ad4:	7f 85       	ldd	r23, Y+15	; 0x0f
    7ad6:	88 89       	ldd	r24, Y+16	; 0x10
    7ad8:	99 89       	ldd	r25, Y+17	; 0x11
    7ada:	20 e0       	ldi	r18, 0x00	; 0
    7adc:	30 e0       	ldi	r19, 0x00	; 0
    7ade:	40 e8       	ldi	r20, 0x80	; 128
    7ae0:	5f e3       	ldi	r21, 0x3F	; 63
    7ae2:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7ae6:	88 23       	and	r24, r24
    7ae8:	0c f0       	brlt	.+2      	; 0x7aec <FRAMWriteKnownsCheck+0xf0>
    7aea:	10 e0       	ldi	r17, 0x00	; 0
    7aec:	11 23       	and	r17, r17
    7aee:	29 f0       	breq	.+10     	; 0x7afa <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    7af0:	81 e0       	ldi	r24, 0x01	; 1
    7af2:	90 e0       	ldi	r25, 0x00	; 0
    7af4:	8a 8b       	std	Y+18, r24	; 0x12
    7af6:	9b 8b       	std	Y+19, r25	; 0x13
    7af8:	46 c0       	rjmp	.+140    	; 0x7b86 <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7afa:	11 e0       	ldi	r17, 0x01	; 1
    7afc:	6e 85       	ldd	r22, Y+14	; 0x0e
    7afe:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b00:	88 89       	ldd	r24, Y+16	; 0x10
    7b02:	99 89       	ldd	r25, Y+17	; 0x11
    7b04:	20 e0       	ldi	r18, 0x00	; 0
    7b06:	3f ef       	ldi	r19, 0xFF	; 255
    7b08:	4f e7       	ldi	r20, 0x7F	; 127
    7b0a:	57 e4       	ldi	r21, 0x47	; 71
    7b0c:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7b10:	18 16       	cp	r1, r24
    7b12:	0c f0       	brlt	.+2      	; 0x7b16 <FRAMWriteKnownsCheck+0x11a>
    7b14:	10 e0       	ldi	r17, 0x00	; 0
    7b16:	11 23       	and	r17, r17
    7b18:	61 f1       	breq	.+88     	; 0x7b72 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7b1a:	6a 85       	ldd	r22, Y+10	; 0x0a
    7b1c:	7b 85       	ldd	r23, Y+11	; 0x0b
    7b1e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7b20:	9d 85       	ldd	r25, Y+13	; 0x0d
    7b22:	20 e0       	ldi	r18, 0x00	; 0
    7b24:	30 e0       	ldi	r19, 0x00	; 0
    7b26:	40 e2       	ldi	r20, 0x20	; 32
    7b28:	51 e4       	ldi	r21, 0x41	; 65
    7b2a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7b2e:	dc 01       	movw	r26, r24
    7b30:	cb 01       	movw	r24, r22
    7b32:	bc 01       	movw	r22, r24
    7b34:	cd 01       	movw	r24, r26
    7b36:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7b3a:	dc 01       	movw	r26, r24
    7b3c:	cb 01       	movw	r24, r22
    7b3e:	8a 8b       	std	Y+18, r24	; 0x12
    7b40:	9b 8b       	std	Y+19, r25	; 0x13
    7b42:	12 c0       	rjmp	.+36     	; 0x7b68 <FRAMWriteKnownsCheck+0x16c>
    7b44:	80 e2       	ldi	r24, 0x20	; 32
    7b46:	93 e0       	ldi	r25, 0x03	; 3
    7b48:	8c 8b       	std	Y+20, r24	; 0x14
    7b4a:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b4c:	8c 89       	ldd	r24, Y+20	; 0x14
    7b4e:	9d 89       	ldd	r25, Y+21	; 0x15
    7b50:	8c 01       	movw	r16, r24
    7b52:	c8 01       	movw	r24, r16
    7b54:	01 97       	sbiw	r24, 0x01	; 1
    7b56:	f1 f7       	brne	.-4      	; 0x7b54 <FRAMWriteKnownsCheck+0x158>
    7b58:	8c 01       	movw	r16, r24
    7b5a:	0c 8b       	std	Y+20, r16	; 0x14
    7b5c:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b5e:	8a 89       	ldd	r24, Y+18	; 0x12
    7b60:	9b 89       	ldd	r25, Y+19	; 0x13
    7b62:	01 97       	sbiw	r24, 0x01	; 1
    7b64:	8a 8b       	std	Y+18, r24	; 0x12
    7b66:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b68:	8a 89       	ldd	r24, Y+18	; 0x12
    7b6a:	9b 89       	ldd	r25, Y+19	; 0x13
    7b6c:	00 97       	sbiw	r24, 0x00	; 0
    7b6e:	51 f7       	brne	.-44     	; 0x7b44 <FRAMWriteKnownsCheck+0x148>
    7b70:	28 c0       	rjmp	.+80     	; 0x7bc2 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b72:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b74:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b76:	88 89       	ldd	r24, Y+16	; 0x10
    7b78:	99 89       	ldd	r25, Y+17	; 0x11
    7b7a:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7b7e:	dc 01       	movw	r26, r24
    7b80:	cb 01       	movw	r24, r22
    7b82:	8a 8b       	std	Y+18, r24	; 0x12
    7b84:	9b 8b       	std	Y+19, r25	; 0x13
    7b86:	8a 89       	ldd	r24, Y+18	; 0x12
    7b88:	9b 89       	ldd	r25, Y+19	; 0x13
    7b8a:	8e 8b       	std	Y+22, r24	; 0x16
    7b8c:	9f 8b       	std	Y+23, r25	; 0x17
    7b8e:	8e 89       	ldd	r24, Y+22	; 0x16
    7b90:	9f 89       	ldd	r25, Y+23	; 0x17
    7b92:	8c 01       	movw	r16, r24
    7b94:	c8 01       	movw	r24, r16
    7b96:	01 97       	sbiw	r24, 0x01	; 1
    7b98:	f1 f7       	brne	.-4      	; 0x7b96 <FRAMWriteKnownsCheck+0x19a>
    7b9a:	8c 01       	movw	r16, r24
    7b9c:	0e 8b       	std	Y+22, r16	; 0x16
    7b9e:	1f 8b       	std	Y+23, r17	; 0x17
    7ba0:	10 c0       	rjmp	.+32     	; 0x7bc2 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7ba2:	6d 81       	ldd	r22, Y+5	; 0x05
    7ba4:	7e 81       	ldd	r23, Y+6	; 0x06
    7ba6:	8f 81       	ldd	r24, Y+7	; 0x07
    7ba8:	98 85       	ldd	r25, Y+8	; 0x08
    7baa:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7bae:	dc 01       	movw	r26, r24
    7bb0:	cb 01       	movw	r24, r22
    7bb2:	89 87       	std	Y+9, r24	; 0x09
    7bb4:	89 85       	ldd	r24, Y+9	; 0x09
    7bb6:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7bb8:	88 8d       	ldd	r24, Y+24	; 0x18
    7bba:	18 2f       	mov	r17, r24
    7bbc:	1a 95       	dec	r17
    7bbe:	f1 f7       	brne	.-4      	; 0x7bbc <FRAMWriteKnownsCheck+0x1c0>
    7bc0:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7bc2:	0e 94 47 18 	call	0x308e	; 0x308e <calcChecksumFRAM>

	ADCPower(FALSE);
    7bc6:	80 e0       	ldi	r24, 0x00	; 0
    7bc8:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>

}
    7bcc:	68 96       	adiw	r28, 0x18	; 24
    7bce:	cd bf       	out	0x3d, r28	; 61
    7bd0:	de bf       	out	0x3e, r29	; 62
    7bd2:	df 91       	pop	r29
    7bd4:	cf 91       	pop	r28
    7bd6:	1f 91       	pop	r17
    7bd8:	0f 91       	pop	r16
    7bda:	08 95       	ret

00007bdc <checkMote>:

//random function for testing stuff	
void checkMote(){
    7bdc:	0f 93       	push	r16
    7bde:	1f 93       	push	r17
    7be0:	cf 93       	push	r28
    7be2:	df 93       	push	r29
    7be4:	cd b7       	in	r28, 0x3d	; 61
    7be6:	de b7       	in	r29, 0x3e	; 62
    7be8:	aa 97       	sbiw	r28, 0x2a	; 42
    7bea:	cd bf       	out	0x3d, r28	; 61
    7bec:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    7bee:	81 e0       	ldi	r24, 0x01	; 1
    7bf0:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	Ext1Power(TRUE);
    7bf4:	81 e0       	ldi	r24, 0x01	; 1
    7bf6:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <Ext1Power>
    7bfa:	80 e0       	ldi	r24, 0x00	; 0
    7bfc:	90 e0       	ldi	r25, 0x00	; 0
    7bfe:	a8 ec       	ldi	r26, 0xC8	; 200
    7c00:	b2 e4       	ldi	r27, 0x42	; 66
    7c02:	89 83       	std	Y+1, r24	; 0x01
    7c04:	9a 83       	std	Y+2, r25	; 0x02
    7c06:	ab 83       	std	Y+3, r26	; 0x03
    7c08:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7c0a:	69 81       	ldd	r22, Y+1	; 0x01
    7c0c:	7a 81       	ldd	r23, Y+2	; 0x02
    7c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    7c10:	9c 81       	ldd	r25, Y+4	; 0x04
    7c12:	20 e0       	ldi	r18, 0x00	; 0
    7c14:	30 e0       	ldi	r19, 0x00	; 0
    7c16:	4a ef       	ldi	r20, 0xFA	; 250
    7c18:	55 e4       	ldi	r21, 0x45	; 69
    7c1a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7c1e:	dc 01       	movw	r26, r24
    7c20:	cb 01       	movw	r24, r22
    7c22:	8d 83       	std	Y+5, r24	; 0x05
    7c24:	9e 83       	std	Y+6, r25	; 0x06
    7c26:	af 83       	std	Y+7, r26	; 0x07
    7c28:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7c2a:	11 e0       	ldi	r17, 0x01	; 1
    7c2c:	6d 81       	ldd	r22, Y+5	; 0x05
    7c2e:	7e 81       	ldd	r23, Y+6	; 0x06
    7c30:	8f 81       	ldd	r24, Y+7	; 0x07
    7c32:	98 85       	ldd	r25, Y+8	; 0x08
    7c34:	20 e0       	ldi	r18, 0x00	; 0
    7c36:	30 e0       	ldi	r19, 0x00	; 0
    7c38:	40 e8       	ldi	r20, 0x80	; 128
    7c3a:	5f e3       	ldi	r21, 0x3F	; 63
    7c3c:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7c40:	88 23       	and	r24, r24
    7c42:	0c f0       	brlt	.+2      	; 0x7c46 <checkMote+0x6a>
    7c44:	10 e0       	ldi	r17, 0x00	; 0
    7c46:	11 23       	and	r17, r17
    7c48:	29 f0       	breq	.+10     	; 0x7c54 <checkMote+0x78>
		__ticks = 1;
    7c4a:	81 e0       	ldi	r24, 0x01	; 1
    7c4c:	90 e0       	ldi	r25, 0x00	; 0
    7c4e:	89 87       	std	Y+9, r24	; 0x09
    7c50:	9a 87       	std	Y+10, r25	; 0x0a
    7c52:	46 c0       	rjmp	.+140    	; 0x7ce0 <checkMote+0x104>
	else if (__tmp > 65535)
    7c54:	11 e0       	ldi	r17, 0x01	; 1
    7c56:	6d 81       	ldd	r22, Y+5	; 0x05
    7c58:	7e 81       	ldd	r23, Y+6	; 0x06
    7c5a:	8f 81       	ldd	r24, Y+7	; 0x07
    7c5c:	98 85       	ldd	r25, Y+8	; 0x08
    7c5e:	20 e0       	ldi	r18, 0x00	; 0
    7c60:	3f ef       	ldi	r19, 0xFF	; 255
    7c62:	4f e7       	ldi	r20, 0x7F	; 127
    7c64:	57 e4       	ldi	r21, 0x47	; 71
    7c66:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7c6a:	18 16       	cp	r1, r24
    7c6c:	0c f0       	brlt	.+2      	; 0x7c70 <checkMote+0x94>
    7c6e:	10 e0       	ldi	r17, 0x00	; 0
    7c70:	11 23       	and	r17, r17
    7c72:	61 f1       	breq	.+88     	; 0x7ccc <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7c74:	69 81       	ldd	r22, Y+1	; 0x01
    7c76:	7a 81       	ldd	r23, Y+2	; 0x02
    7c78:	8b 81       	ldd	r24, Y+3	; 0x03
    7c7a:	9c 81       	ldd	r25, Y+4	; 0x04
    7c7c:	20 e0       	ldi	r18, 0x00	; 0
    7c7e:	30 e0       	ldi	r19, 0x00	; 0
    7c80:	40 e2       	ldi	r20, 0x20	; 32
    7c82:	51 e4       	ldi	r21, 0x41	; 65
    7c84:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7c88:	dc 01       	movw	r26, r24
    7c8a:	cb 01       	movw	r24, r22
    7c8c:	bc 01       	movw	r22, r24
    7c8e:	cd 01       	movw	r24, r26
    7c90:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7c94:	dc 01       	movw	r26, r24
    7c96:	cb 01       	movw	r24, r22
    7c98:	89 87       	std	Y+9, r24	; 0x09
    7c9a:	9a 87       	std	Y+10, r25	; 0x0a
    7c9c:	12 c0       	rjmp	.+36     	; 0x7cc2 <checkMote+0xe6>
    7c9e:	80 e2       	ldi	r24, 0x20	; 32
    7ca0:	93 e0       	ldi	r25, 0x03	; 3
    7ca2:	8b 87       	std	Y+11, r24	; 0x0b
    7ca4:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7ca6:	8b 85       	ldd	r24, Y+11	; 0x0b
    7ca8:	9c 85       	ldd	r25, Y+12	; 0x0c
    7caa:	8c 01       	movw	r16, r24
    7cac:	c8 01       	movw	r24, r16
    7cae:	01 97       	sbiw	r24, 0x01	; 1
    7cb0:	f1 f7       	brne	.-4      	; 0x7cae <checkMote+0xd2>
    7cb2:	8c 01       	movw	r16, r24
    7cb4:	0b 87       	std	Y+11, r16	; 0x0b
    7cb6:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7cb8:	89 85       	ldd	r24, Y+9	; 0x09
    7cba:	9a 85       	ldd	r25, Y+10	; 0x0a
    7cbc:	01 97       	sbiw	r24, 0x01	; 1
    7cbe:	89 87       	std	Y+9, r24	; 0x09
    7cc0:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7cc2:	89 85       	ldd	r24, Y+9	; 0x09
    7cc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    7cc6:	00 97       	sbiw	r24, 0x00	; 0
    7cc8:	51 f7       	brne	.-44     	; 0x7c9e <checkMote+0xc2>
    7cca:	17 c0       	rjmp	.+46     	; 0x7cfa <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ccc:	6d 81       	ldd	r22, Y+5	; 0x05
    7cce:	7e 81       	ldd	r23, Y+6	; 0x06
    7cd0:	8f 81       	ldd	r24, Y+7	; 0x07
    7cd2:	98 85       	ldd	r25, Y+8	; 0x08
    7cd4:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7cd8:	dc 01       	movw	r26, r24
    7cda:	cb 01       	movw	r24, r22
    7cdc:	89 87       	std	Y+9, r24	; 0x09
    7cde:	9a 87       	std	Y+10, r25	; 0x0a
    7ce0:	89 85       	ldd	r24, Y+9	; 0x09
    7ce2:	9a 85       	ldd	r25, Y+10	; 0x0a
    7ce4:	8d 87       	std	Y+13, r24	; 0x0d
    7ce6:	9e 87       	std	Y+14, r25	; 0x0e
    7ce8:	8d 85       	ldd	r24, Y+13	; 0x0d
    7cea:	9e 85       	ldd	r25, Y+14	; 0x0e
    7cec:	8c 01       	movw	r16, r24
    7cee:	c8 01       	movw	r24, r16
    7cf0:	01 97       	sbiw	r24, 0x01	; 1
    7cf2:	f1 f7       	brne	.-4      	; 0x7cf0 <checkMote+0x114>
    7cf4:	8c 01       	movw	r16, r24
    7cf6:	0d 87       	std	Y+13, r16	; 0x0d
    7cf8:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7cfa:	88 e0       	ldi	r24, 0x08	; 8
    7cfc:	60 e0       	ldi	r22, 0x00	; 0
    7cfe:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7d02:	88 e0       	ldi	r24, 0x08	; 8
    7d04:	60 e0       	ldi	r22, 0x00	; 0
    7d06:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
    7d0a:	80 e0       	ldi	r24, 0x00	; 0
    7d0c:	90 e4       	ldi	r25, 0x40	; 64
    7d0e:	ac e9       	ldi	r26, 0x9C	; 156
    7d10:	b5 e4       	ldi	r27, 0x45	; 69
    7d12:	8f 87       	std	Y+15, r24	; 0x0f
    7d14:	98 8b       	std	Y+16, r25	; 0x10
    7d16:	a9 8b       	std	Y+17, r26	; 0x11
    7d18:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7d1a:	6f 85       	ldd	r22, Y+15	; 0x0f
    7d1c:	78 89       	ldd	r23, Y+16	; 0x10
    7d1e:	89 89       	ldd	r24, Y+17	; 0x11
    7d20:	9a 89       	ldd	r25, Y+18	; 0x12
    7d22:	20 e0       	ldi	r18, 0x00	; 0
    7d24:	30 e0       	ldi	r19, 0x00	; 0
    7d26:	4a ef       	ldi	r20, 0xFA	; 250
    7d28:	55 e4       	ldi	r21, 0x45	; 69
    7d2a:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7d2e:	dc 01       	movw	r26, r24
    7d30:	cb 01       	movw	r24, r22
    7d32:	8b 8b       	std	Y+19, r24	; 0x13
    7d34:	9c 8b       	std	Y+20, r25	; 0x14
    7d36:	ad 8b       	std	Y+21, r26	; 0x15
    7d38:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7d3a:	11 e0       	ldi	r17, 0x01	; 1
    7d3c:	6b 89       	ldd	r22, Y+19	; 0x13
    7d3e:	7c 89       	ldd	r23, Y+20	; 0x14
    7d40:	8d 89       	ldd	r24, Y+21	; 0x15
    7d42:	9e 89       	ldd	r25, Y+22	; 0x16
    7d44:	20 e0       	ldi	r18, 0x00	; 0
    7d46:	30 e0       	ldi	r19, 0x00	; 0
    7d48:	40 e8       	ldi	r20, 0x80	; 128
    7d4a:	5f e3       	ldi	r21, 0x3F	; 63
    7d4c:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7d50:	88 23       	and	r24, r24
    7d52:	0c f0       	brlt	.+2      	; 0x7d56 <checkMote+0x17a>
    7d54:	10 e0       	ldi	r17, 0x00	; 0
    7d56:	11 23       	and	r17, r17
    7d58:	29 f0       	breq	.+10     	; 0x7d64 <checkMote+0x188>
		__ticks = 1;
    7d5a:	81 e0       	ldi	r24, 0x01	; 1
    7d5c:	90 e0       	ldi	r25, 0x00	; 0
    7d5e:	8f 8b       	std	Y+23, r24	; 0x17
    7d60:	98 8f       	std	Y+24, r25	; 0x18
    7d62:	46 c0       	rjmp	.+140    	; 0x7df0 <checkMote+0x214>
	else if (__tmp > 65535)
    7d64:	11 e0       	ldi	r17, 0x01	; 1
    7d66:	6b 89       	ldd	r22, Y+19	; 0x13
    7d68:	7c 89       	ldd	r23, Y+20	; 0x14
    7d6a:	8d 89       	ldd	r24, Y+21	; 0x15
    7d6c:	9e 89       	ldd	r25, Y+22	; 0x16
    7d6e:	20 e0       	ldi	r18, 0x00	; 0
    7d70:	3f ef       	ldi	r19, 0xFF	; 255
    7d72:	4f e7       	ldi	r20, 0x7F	; 127
    7d74:	57 e4       	ldi	r21, 0x47	; 71
    7d76:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7d7a:	18 16       	cp	r1, r24
    7d7c:	0c f0       	brlt	.+2      	; 0x7d80 <checkMote+0x1a4>
    7d7e:	10 e0       	ldi	r17, 0x00	; 0
    7d80:	11 23       	and	r17, r17
    7d82:	61 f1       	breq	.+88     	; 0x7ddc <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7d84:	6f 85       	ldd	r22, Y+15	; 0x0f
    7d86:	78 89       	ldd	r23, Y+16	; 0x10
    7d88:	89 89       	ldd	r24, Y+17	; 0x11
    7d8a:	9a 89       	ldd	r25, Y+18	; 0x12
    7d8c:	20 e0       	ldi	r18, 0x00	; 0
    7d8e:	30 e0       	ldi	r19, 0x00	; 0
    7d90:	40 e2       	ldi	r20, 0x20	; 32
    7d92:	51 e4       	ldi	r21, 0x41	; 65
    7d94:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7d98:	dc 01       	movw	r26, r24
    7d9a:	cb 01       	movw	r24, r22
    7d9c:	bc 01       	movw	r22, r24
    7d9e:	cd 01       	movw	r24, r26
    7da0:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7da4:	dc 01       	movw	r26, r24
    7da6:	cb 01       	movw	r24, r22
    7da8:	8f 8b       	std	Y+23, r24	; 0x17
    7daa:	98 8f       	std	Y+24, r25	; 0x18
    7dac:	12 c0       	rjmp	.+36     	; 0x7dd2 <checkMote+0x1f6>
    7dae:	80 e2       	ldi	r24, 0x20	; 32
    7db0:	93 e0       	ldi	r25, 0x03	; 3
    7db2:	89 8f       	std	Y+25, r24	; 0x19
    7db4:	9a 8f       	std	Y+26, r25	; 0x1a
    7db6:	89 8d       	ldd	r24, Y+25	; 0x19
    7db8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7dba:	8c 01       	movw	r16, r24
    7dbc:	c8 01       	movw	r24, r16
    7dbe:	01 97       	sbiw	r24, 0x01	; 1
    7dc0:	f1 f7       	brne	.-4      	; 0x7dbe <checkMote+0x1e2>
    7dc2:	8c 01       	movw	r16, r24
    7dc4:	09 8f       	std	Y+25, r16	; 0x19
    7dc6:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7dc8:	8f 89       	ldd	r24, Y+23	; 0x17
    7dca:	98 8d       	ldd	r25, Y+24	; 0x18
    7dcc:	01 97       	sbiw	r24, 0x01	; 1
    7dce:	8f 8b       	std	Y+23, r24	; 0x17
    7dd0:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7dd2:	8f 89       	ldd	r24, Y+23	; 0x17
    7dd4:	98 8d       	ldd	r25, Y+24	; 0x18
    7dd6:	00 97       	sbiw	r24, 0x00	; 0
    7dd8:	51 f7       	brne	.-44     	; 0x7dae <checkMote+0x1d2>
    7dda:	17 c0       	rjmp	.+46     	; 0x7e0a <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ddc:	6b 89       	ldd	r22, Y+19	; 0x13
    7dde:	7c 89       	ldd	r23, Y+20	; 0x14
    7de0:	8d 89       	ldd	r24, Y+21	; 0x15
    7de2:	9e 89       	ldd	r25, Y+22	; 0x16
    7de4:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7de8:	dc 01       	movw	r26, r24
    7dea:	cb 01       	movw	r24, r22
    7dec:	8f 8b       	std	Y+23, r24	; 0x17
    7dee:	98 8f       	std	Y+24, r25	; 0x18
    7df0:	8f 89       	ldd	r24, Y+23	; 0x17
    7df2:	98 8d       	ldd	r25, Y+24	; 0x18
    7df4:	8b 8f       	std	Y+27, r24	; 0x1b
    7df6:	9c 8f       	std	Y+28, r25	; 0x1c
    7df8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7dfa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7dfc:	8c 01       	movw	r16, r24
    7dfe:	c8 01       	movw	r24, r16
    7e00:	01 97       	sbiw	r24, 0x01	; 1
    7e02:	f1 f7       	brne	.-4      	; 0x7e00 <checkMote+0x224>
    7e04:	8c 01       	movw	r16, r24
    7e06:	0b 8f       	std	Y+27, r16	; 0x1b
    7e08:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7e0a:	88 e0       	ldi	r24, 0x08	; 8
    7e0c:	60 e0       	ldi	r22, 0x00	; 0
    7e0e:	0e 94 44 36 	call	0x6c88	; 0x6c88 <PortEx_OUTCLR>
    7e12:	80 e0       	ldi	r24, 0x00	; 0
    7e14:	90 e4       	ldi	r25, 0x40	; 64
    7e16:	ac e9       	ldi	r26, 0x9C	; 156
    7e18:	b5 e4       	ldi	r27, 0x45	; 69
    7e1a:	8d 8f       	std	Y+29, r24	; 0x1d
    7e1c:	9e 8f       	std	Y+30, r25	; 0x1e
    7e1e:	af 8f       	std	Y+31, r26	; 0x1f
    7e20:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7e22:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7e24:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7e26:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7e28:	98 a1       	lds	r25, 0x48
    7e2a:	20 e0       	ldi	r18, 0x00	; 0
    7e2c:	30 e0       	ldi	r19, 0x00	; 0
    7e2e:	4a ef       	ldi	r20, 0xFA	; 250
    7e30:	55 e4       	ldi	r21, 0x45	; 69
    7e32:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7e36:	dc 01       	movw	r26, r24
    7e38:	cb 01       	movw	r24, r22
    7e3a:	89 a3       	lds	r24, 0x59
    7e3c:	9a a3       	lds	r25, 0x5a
    7e3e:	ab a3       	lds	r26, 0x5b
    7e40:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7e42:	11 e0       	ldi	r17, 0x01	; 1
    7e44:	69 a1       	lds	r22, 0x49
    7e46:	7a a1       	lds	r23, 0x4a
    7e48:	8b a1       	lds	r24, 0x4b
    7e4a:	9c a1       	lds	r25, 0x4c
    7e4c:	20 e0       	ldi	r18, 0x00	; 0
    7e4e:	30 e0       	ldi	r19, 0x00	; 0
    7e50:	40 e8       	ldi	r20, 0x80	; 128
    7e52:	5f e3       	ldi	r21, 0x3F	; 63
    7e54:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    7e58:	88 23       	and	r24, r24
    7e5a:	0c f0       	brlt	.+2      	; 0x7e5e <checkMote+0x282>
    7e5c:	10 e0       	ldi	r17, 0x00	; 0
    7e5e:	11 23       	and	r17, r17
    7e60:	29 f0       	breq	.+10     	; 0x7e6c <checkMote+0x290>
		__ticks = 1;
    7e62:	81 e0       	ldi	r24, 0x01	; 1
    7e64:	90 e0       	ldi	r25, 0x00	; 0
    7e66:	8d a3       	lds	r24, 0x5d
    7e68:	9e a3       	lds	r25, 0x5e
    7e6a:	46 c0       	rjmp	.+140    	; 0x7ef8 <checkMote+0x31c>
	else if (__tmp > 65535)
    7e6c:	11 e0       	ldi	r17, 0x01	; 1
    7e6e:	69 a1       	lds	r22, 0x49
    7e70:	7a a1       	lds	r23, 0x4a
    7e72:	8b a1       	lds	r24, 0x4b
    7e74:	9c a1       	lds	r25, 0x4c
    7e76:	20 e0       	ldi	r18, 0x00	; 0
    7e78:	3f ef       	ldi	r19, 0xFF	; 255
    7e7a:	4f e7       	ldi	r20, 0x7F	; 127
    7e7c:	57 e4       	ldi	r21, 0x47	; 71
    7e7e:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    7e82:	18 16       	cp	r1, r24
    7e84:	0c f0       	brlt	.+2      	; 0x7e88 <checkMote+0x2ac>
    7e86:	10 e0       	ldi	r17, 0x00	; 0
    7e88:	11 23       	and	r17, r17
    7e8a:	61 f1       	breq	.+88     	; 0x7ee4 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7e8c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7e8e:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7e90:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7e92:	98 a1       	lds	r25, 0x48
    7e94:	20 e0       	ldi	r18, 0x00	; 0
    7e96:	30 e0       	ldi	r19, 0x00	; 0
    7e98:	40 e2       	ldi	r20, 0x20	; 32
    7e9a:	51 e4       	ldi	r21, 0x41	; 65
    7e9c:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    7ea0:	dc 01       	movw	r26, r24
    7ea2:	cb 01       	movw	r24, r22
    7ea4:	bc 01       	movw	r22, r24
    7ea6:	cd 01       	movw	r24, r26
    7ea8:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7eac:	dc 01       	movw	r26, r24
    7eae:	cb 01       	movw	r24, r22
    7eb0:	8d a3       	lds	r24, 0x5d
    7eb2:	9e a3       	lds	r25, 0x5e
    7eb4:	12 c0       	rjmp	.+36     	; 0x7eda <checkMote+0x2fe>
    7eb6:	80 e2       	ldi	r24, 0x20	; 32
    7eb8:	93 e0       	ldi	r25, 0x03	; 3
    7eba:	8f a3       	lds	r24, 0x5f
    7ebc:	98 a7       	lds	r25, 0x78
    7ebe:	8f a1       	lds	r24, 0x4f
    7ec0:	98 a5       	lds	r25, 0x68
    7ec2:	8c 01       	movw	r16, r24
    7ec4:	c8 01       	movw	r24, r16
    7ec6:	01 97       	sbiw	r24, 0x01	; 1
    7ec8:	f1 f7       	brne	.-4      	; 0x7ec6 <checkMote+0x2ea>
    7eca:	8c 01       	movw	r16, r24
    7ecc:	0f a3       	lds	r16, 0x5f
    7ece:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ed0:	8d a1       	lds	r24, 0x4d
    7ed2:	9e a1       	lds	r25, 0x4e
    7ed4:	01 97       	sbiw	r24, 0x01	; 1
    7ed6:	8d a3       	lds	r24, 0x5d
    7ed8:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7eda:	8d a1       	lds	r24, 0x4d
    7edc:	9e a1       	lds	r25, 0x4e
    7ede:	00 97       	sbiw	r24, 0x00	; 0
    7ee0:	51 f7       	brne	.-44     	; 0x7eb6 <checkMote+0x2da>
    7ee2:	18 c0       	rjmp	.+48     	; 0x7f14 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ee4:	69 a1       	lds	r22, 0x49
    7ee6:	7a a1       	lds	r23, 0x4a
    7ee8:	8b a1       	lds	r24, 0x4b
    7eea:	9c a1       	lds	r25, 0x4c
    7eec:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    7ef0:	dc 01       	movw	r26, r24
    7ef2:	cb 01       	movw	r24, r22
    7ef4:	8d a3       	lds	r24, 0x5d
    7ef6:	9e a3       	lds	r25, 0x5e
    7ef8:	8d a1       	lds	r24, 0x4d
    7efa:	9e a1       	lds	r25, 0x4e
    7efc:	89 a7       	lds	r24, 0x79
    7efe:	9a a7       	lds	r25, 0x7a
    7f00:	89 a5       	lds	r24, 0x69
    7f02:	9a a5       	lds	r25, 0x6a
    7f04:	8c 01       	movw	r16, r24
    7f06:	c8 01       	movw	r24, r16
    7f08:	01 97       	sbiw	r24, 0x01	; 1
    7f0a:	f1 f7       	brne	.-4      	; 0x7f08 <checkMote+0x32c>
    7f0c:	8c 01       	movw	r16, r24
    7f0e:	09 a7       	lds	r16, 0x79
    7f10:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7f12:	f7 ce       	rjmp	.-530    	; 0x7d02 <checkMote+0x126>
    7f14:	f6 ce       	rjmp	.-532    	; 0x7d02 <checkMote+0x126>

00007f16 <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7f16:	cf 93       	push	r28
    7f18:	df 93       	push	r29
    7f1a:	cd b7       	in	r28, 0x3d	; 61
    7f1c:	de b7       	in	r29, 0x3e	; 62
    7f1e:	28 97       	sbiw	r28, 0x08	; 8
    7f20:	cd bf       	out	0x3d, r28	; 61
    7f22:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7f24:	19 82       	std	Y+1, r1	; 0x01
    7f26:	1a 82       	std	Y+2, r1	; 0x02
    7f28:	0c c0       	rjmp	.+24     	; 0x7f42 <SD_write_and_read_knowns+0x2c>
    7f2a:	29 81       	ldd	r18, Y+1	; 0x01
    7f2c:	89 81       	ldd	r24, Y+1	; 0x01
    7f2e:	9a 81       	ldd	r25, Y+2	; 0x02
    7f30:	80 52       	subi	r24, 0x20	; 32
    7f32:	9c 4d       	sbci	r25, 0xDC	; 220
    7f34:	fc 01       	movw	r30, r24
    7f36:	20 83       	st	Z, r18
    7f38:	89 81       	ldd	r24, Y+1	; 0x01
    7f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    7f3c:	01 96       	adiw	r24, 0x01	; 1
    7f3e:	89 83       	std	Y+1, r24	; 0x01
    7f40:	9a 83       	std	Y+2, r25	; 0x02
    7f42:	89 81       	ldd	r24, Y+1	; 0x01
    7f44:	9a 81       	ldd	r25, Y+2	; 0x02
    7f46:	88 31       	cpi	r24, 0x18	; 24
    7f48:	91 05       	cpc	r25, r1
    7f4a:	7c f3       	brlt	.-34     	; 0x7f2a <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7f4c:	20 ee       	ldi	r18, 0xE0	; 224
    7f4e:	33 e2       	ldi	r19, 0x23	; 35
    7f50:	64 e1       	ldi	r22, 0x14	; 20
    7f52:	70 e0       	ldi	r23, 0x00	; 0
    7f54:	80 e0       	ldi	r24, 0x00	; 0
    7f56:	90 e0       	ldi	r25, 0x00	; 0
    7f58:	a9 01       	movw	r20, r18
    7f5a:	28 e1       	ldi	r18, 0x18	; 24
    7f5c:	30 e0       	ldi	r19, 0x00	; 0
    7f5e:	0e 94 23 50 	call	0xa046	; 0xa046 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7f62:	1b 82       	std	Y+3, r1	; 0x03
    7f64:	1c 82       	std	Y+4, r1	; 0x04
    7f66:	0b c0       	rjmp	.+22     	; 0x7f7e <SD_write_and_read_knowns+0x68>
    7f68:	8b 81       	ldd	r24, Y+3	; 0x03
    7f6a:	9c 81       	ldd	r25, Y+4	; 0x04
    7f6c:	80 52       	subi	r24, 0x20	; 32
    7f6e:	9c 4d       	sbci	r25, 0xDC	; 220
    7f70:	fc 01       	movw	r30, r24
    7f72:	10 82       	st	Z, r1
    7f74:	8b 81       	ldd	r24, Y+3	; 0x03
    7f76:	9c 81       	ldd	r25, Y+4	; 0x04
    7f78:	01 96       	adiw	r24, 0x01	; 1
    7f7a:	8b 83       	std	Y+3, r24	; 0x03
    7f7c:	9c 83       	std	Y+4, r25	; 0x04
    7f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    7f80:	9c 81       	ldd	r25, Y+4	; 0x04
    7f82:	88 31       	cpi	r24, 0x18	; 24
    7f84:	91 05       	cpc	r25, r1
    7f86:	84 f3       	brlt	.-32     	; 0x7f68 <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7f88:	20 ee       	ldi	r18, 0xE0	; 224
    7f8a:	33 e2       	ldi	r19, 0x23	; 35
    7f8c:	64 e1       	ldi	r22, 0x14	; 20
    7f8e:	70 e0       	ldi	r23, 0x00	; 0
    7f90:	80 e0       	ldi	r24, 0x00	; 0
    7f92:	90 e0       	ldi	r25, 0x00	; 0
    7f94:	a9 01       	movw	r20, r18
    7f96:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7f9a:	1d 82       	std	Y+5, r1	; 0x05
    7f9c:	1e 82       	std	Y+6, r1	; 0x06
    7f9e:	13 c0       	rjmp	.+38     	; 0x7fc6 <SD_write_and_read_knowns+0xb0>
    7fa0:	8d 81       	ldd	r24, Y+5	; 0x05
    7fa2:	9e 81       	ldd	r25, Y+6	; 0x06
    7fa4:	24 e6       	ldi	r18, 0x64	; 100
    7fa6:	30 e0       	ldi	r19, 0x00	; 0
    7fa8:	b9 01       	movw	r22, r18
    7faa:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    7fae:	28 2f       	mov	r18, r24
    7fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    7fb2:	9e 81       	ldd	r25, Y+6	; 0x06
    7fb4:	80 52       	subi	r24, 0x20	; 32
    7fb6:	9c 4d       	sbci	r25, 0xDC	; 220
    7fb8:	fc 01       	movw	r30, r24
    7fba:	20 83       	st	Z, r18
    7fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    7fbe:	9e 81       	ldd	r25, Y+6	; 0x06
    7fc0:	01 96       	adiw	r24, 0x01	; 1
    7fc2:	8d 83       	std	Y+5, r24	; 0x05
    7fc4:	9e 83       	std	Y+6, r25	; 0x06
    7fc6:	8d 81       	ldd	r24, Y+5	; 0x05
    7fc8:	9e 81       	ldd	r25, Y+6	; 0x06
    7fca:	f4 e0       	ldi	r31, 0x04	; 4
    7fcc:	82 3e       	cpi	r24, 0xE2	; 226
    7fce:	9f 07       	cpc	r25, r31
    7fd0:	3c f3       	brlt	.-50     	; 0x7fa0 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7fd2:	20 ee       	ldi	r18, 0xE0	; 224
    7fd4:	33 e2       	ldi	r19, 0x23	; 35
    7fd6:	60 e5       	ldi	r22, 0x50	; 80
    7fd8:	70 e0       	ldi	r23, 0x00	; 0
    7fda:	80 e0       	ldi	r24, 0x00	; 0
    7fdc:	90 e0       	ldi	r25, 0x00	; 0
    7fde:	a9 01       	movw	r20, r18
    7fe0:	22 ee       	ldi	r18, 0xE2	; 226
    7fe2:	34 e0       	ldi	r19, 0x04	; 4
    7fe4:	0e 94 67 51 	call	0xa2ce	; 0xa2ce <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7fe8:	1f 82       	std	Y+7, r1	; 0x07
    7fea:	18 86       	std	Y+8, r1	; 0x08
    7fec:	0b c0       	rjmp	.+22     	; 0x8004 <SD_write_and_read_knowns+0xee>
    7fee:	8f 81       	ldd	r24, Y+7	; 0x07
    7ff0:	98 85       	ldd	r25, Y+8	; 0x08
    7ff2:	80 52       	subi	r24, 0x20	; 32
    7ff4:	9c 4d       	sbci	r25, 0xDC	; 220
    7ff6:	fc 01       	movw	r30, r24
    7ff8:	10 82       	st	Z, r1
    7ffa:	8f 81       	ldd	r24, Y+7	; 0x07
    7ffc:	98 85       	ldd	r25, Y+8	; 0x08
    7ffe:	01 96       	adiw	r24, 0x01	; 1
    8000:	8f 83       	std	Y+7, r24	; 0x07
    8002:	98 87       	std	Y+8, r25	; 0x08
    8004:	8f 81       	ldd	r24, Y+7	; 0x07
    8006:	98 85       	ldd	r25, Y+8	; 0x08
    8008:	f4 e0       	ldi	r31, 0x04	; 4
    800a:	82 3e       	cpi	r24, 0xE2	; 226
    800c:	9f 07       	cpc	r25, r31
    800e:	7c f3       	brlt	.-34     	; 0x7fee <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    8010:	20 ee       	ldi	r18, 0xE0	; 224
    8012:	33 e2       	ldi	r19, 0x23	; 35
    8014:	60 e5       	ldi	r22, 0x50	; 80
    8016:	70 e0       	ldi	r23, 0x00	; 0
    8018:	80 e0       	ldi	r24, 0x00	; 0
    801a:	90 e0       	ldi	r25, 0x00	; 0
    801c:	a9 01       	movw	r20, r18
    801e:	23 e0       	ldi	r18, 0x03	; 3
    8020:	30 e0       	ldi	r19, 0x00	; 0
    8022:	0e 94 c5 52 	call	0xa58a	; 0xa58a <SD_read_multiple_blocks>
}
    8026:	28 96       	adiw	r28, 0x08	; 8
    8028:	cd bf       	out	0x3d, r28	; 61
    802a:	de bf       	out	0x3e, r29	; 62
    802c:	df 91       	pop	r29
    802e:	cf 91       	pop	r28
    8030:	08 95       	ret

00008032 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    8032:	cf 93       	push	r28
    8034:	df 93       	push	r29
    8036:	00 d0       	rcall	.+0      	; 0x8038 <SD_write_and_read_knowns_FAT+0x6>
    8038:	0f 92       	push	r0
    803a:	cd b7       	in	r28, 0x3d	; 61
    803c:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    803e:	19 82       	std	Y+1, r1	; 0x01
    8040:	1a 82       	std	Y+2, r1	; 0x02
    8042:	0c c0       	rjmp	.+24     	; 0x805c <SD_write_and_read_knowns_FAT+0x2a>
    8044:	29 81       	ldd	r18, Y+1	; 0x01
    8046:	89 81       	ldd	r24, Y+1	; 0x01
    8048:	9a 81       	ldd	r25, Y+2	; 0x02
    804a:	80 52       	subi	r24, 0x20	; 32
    804c:	9c 4d       	sbci	r25, 0xDC	; 220
    804e:	fc 01       	movw	r30, r24
    8050:	20 83       	st	Z, r18
    8052:	89 81       	ldd	r24, Y+1	; 0x01
    8054:	9a 81       	ldd	r25, Y+2	; 0x02
    8056:	01 96       	adiw	r24, 0x01	; 1
    8058:	89 83       	std	Y+1, r24	; 0x01
    805a:	9a 83       	std	Y+2, r25	; 0x02
    805c:	89 81       	ldd	r24, Y+1	; 0x01
    805e:	9a 81       	ldd	r25, Y+2	; 0x02
    8060:	88 31       	cpi	r24, 0x18	; 24
    8062:	91 05       	cpc	r25, r1
    8064:	7c f3       	brlt	.-34     	; 0x8044 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",FRAMReadBuffer,512);
    8066:	8d e1       	ldi	r24, 0x1D	; 29
    8068:	90 e2       	ldi	r25, 0x20	; 32
    806a:	20 ee       	ldi	r18, 0xE0	; 224
    806c:	33 e2       	ldi	r19, 0x23	; 35
    806e:	b9 01       	movw	r22, r18
    8070:	20 e0       	ldi	r18, 0x00	; 0
    8072:	32 e0       	ldi	r19, 0x02	; 2
    8074:	40 e0       	ldi	r20, 0x00	; 0
    8076:	50 e0       	ldi	r21, 0x00	; 0
    8078:	0e 94 11 48 	call	0x9022	; 0x9022 <writeFile>
    807c:	80 93 a0 50 	sts	0x50A0, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    8080:	1b 82       	std	Y+3, r1	; 0x03
    8082:	1c 82       	std	Y+4, r1	; 0x04
    8084:	0b c0       	rjmp	.+22     	; 0x809c <SD_write_and_read_knowns_FAT+0x6a>
    8086:	8b 81       	ldd	r24, Y+3	; 0x03
    8088:	9c 81       	ldd	r25, Y+4	; 0x04
    808a:	80 52       	subi	r24, 0x20	; 32
    808c:	9c 4d       	sbci	r25, 0xDC	; 220
    808e:	fc 01       	movw	r30, r24
    8090:	10 82       	st	Z, r1
    8092:	8b 81       	ldd	r24, Y+3	; 0x03
    8094:	9c 81       	ldd	r25, Y+4	; 0x04
    8096:	01 96       	adiw	r24, 0x01	; 1
    8098:	8b 83       	std	Y+3, r24	; 0x03
    809a:	9c 83       	std	Y+4, r25	; 0x04
    809c:	8b 81       	ldd	r24, Y+3	; 0x03
    809e:	9c 81       	ldd	r25, Y+4	; 0x04
    80a0:	88 31       	cpi	r24, 0x18	; 24
    80a2:	91 05       	cpc	r25, r1
    80a4:	84 f3       	brlt	.-32     	; 0x8086 <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    80a6:	2d e1       	ldi	r18, 0x1D	; 29
    80a8:	30 e2       	ldi	r19, 0x20	; 32
    80aa:	80 e0       	ldi	r24, 0x00	; 0
    80ac:	b9 01       	movw	r22, r18
    80ae:	0e 94 2c 46 	call	0x8c58	; 0x8c58 <readFile>
    80b2:	80 93 a0 50 	sts	0x50A0, r24
}
    80b6:	24 96       	adiw	r28, 0x04	; 4
    80b8:	cd bf       	out	0x3d, r28	; 61
    80ba:	de bf       	out	0x3e, r29	; 62
    80bc:	df 91       	pop	r29
    80be:	cf 91       	pop	r28
    80c0:	08 95       	ret

000080c2 <chibi_test_radio>:
	//WriteRadioRegister(RADIOCTRLRGSTR, RX_ON);
	//sei();
}
*/
//function for testing radio transmission
void chibi_test_radio(){
    80c2:	cf 93       	push	r28
    80c4:	df 93       	push	r29
    80c6:	cd b7       	in	r28, 0x3d	; 61
    80c8:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    80ca:	0e 94 38 20 	call	0x4070	; 0x4070 <chb_init>
	chb_set_short_addr(0x0002);
    80ce:	82 e0       	ldi	r24, 0x02	; 2
    80d0:	90 e0       	ldi	r25, 0x00	; 0
    80d2:	0e 94 cc 2d 	call	0x5b98	; 0x5b98 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    80d6:	00 00       	nop
    80d8:	fe cf       	rjmp	.-4      	; 0x80d6 <chibi_test_radio+0x14>

000080da <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    80da:	cf 93       	push	r28
    80dc:	df 93       	push	r29
    80de:	0f 92       	push	r0
    80e0:	0f 92       	push	r0
    80e2:	cd b7       	in	r28, 0x3d	; 61
    80e4:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    80e6:	0e 94 7c 4d 	call	0x9af8	; 0x9af8 <SD_init>
	getBootSectorData();
    80ea:	0e 94 7c 41 	call	0x82f8	; 0x82f8 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    80ee:	19 82       	std	Y+1, r1	; 0x01
    80f0:	1a 82       	std	Y+2, r1	; 0x02
    80f2:	13 c0       	rjmp	.+38     	; 0x811a <TestCard+0x40>
    80f4:	89 81       	ldd	r24, Y+1	; 0x01
    80f6:	9a 81       	ldd	r25, Y+2	; 0x02
    80f8:	29 e7       	ldi	r18, 0x79	; 121
    80fa:	30 e0       	ldi	r19, 0x00	; 0
    80fc:	b9 01       	movw	r22, r18
    80fe:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    8102:	28 2f       	mov	r18, r24
    8104:	89 81       	ldd	r24, Y+1	; 0x01
    8106:	9a 81       	ldd	r25, Y+2	; 0x02
    8108:	80 52       	subi	r24, 0x20	; 32
    810a:	9c 4d       	sbci	r25, 0xDC	; 220
    810c:	fc 01       	movw	r30, r24
    810e:	20 83       	st	Z, r18
    8110:	89 81       	ldd	r24, Y+1	; 0x01
    8112:	9a 81       	ldd	r25, Y+2	; 0x02
    8114:	01 96       	adiw	r24, 0x01	; 1
    8116:	89 83       	std	Y+1, r24	; 0x01
    8118:	9a 83       	std	Y+2, r25	; 0x02
    811a:	89 81       	ldd	r24, Y+1	; 0x01
    811c:	9a 81       	ldd	r25, Y+2	; 0x02
    811e:	f2 e0       	ldi	r31, 0x02	; 2
    8120:	80 30       	cpi	r24, 0x00	; 0
    8122:	9f 07       	cpc	r25, r31
    8124:	3c f3       	brlt	.-50     	; 0x80f4 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",FRAMReadBuffer,512);//}
    8126:	8d e1       	ldi	r24, 0x1D	; 29
    8128:	90 e2       	ldi	r25, 0x20	; 32
    812a:	20 ee       	ldi	r18, 0xE0	; 224
    812c:	33 e2       	ldi	r19, 0x23	; 35
    812e:	b9 01       	movw	r22, r18
    8130:	20 e0       	ldi	r18, 0x00	; 0
    8132:	32 e0       	ldi	r19, 0x02	; 2
    8134:	40 e0       	ldi	r20, 0x00	; 0
    8136:	50 e0       	ldi	r21, 0x00	; 0
    8138:	0e 94 11 48 	call	0x9022	; 0x9022 <writeFile>
	nop();
    813c:	00 00       	nop
}
    813e:	0f 90       	pop	r0
    8140:	0f 90       	pop	r0
    8142:	df 91       	pop	r29
    8144:	cf 91       	pop	r28
    8146:	08 95       	ret

00008148 <__vector_43>:

//interrupt service routine for handling received data over radio
ISR(PORTE_INT0_vect){
    8148:	1f 92       	push	r1
    814a:	0f 92       	push	r0
    814c:	0f b6       	in	r0, 0x3f	; 63
    814e:	0f 92       	push	r0
    8150:	00 90 3b 00 	lds	r0, 0x003B
    8154:	0f 92       	push	r0
    8156:	11 24       	eor	r1, r1
    8158:	2f 93       	push	r18
    815a:	3f 93       	push	r19
    815c:	4f 93       	push	r20
    815e:	5f 93       	push	r21
    8160:	6f 93       	push	r22
    8162:	7f 93       	push	r23
    8164:	8f 93       	push	r24
    8166:	9f 93       	push	r25
    8168:	af 93       	push	r26
    816a:	bf 93       	push	r27
    816c:	ef 93       	push	r30
    816e:	ff 93       	push	r31
    8170:	cf 93       	push	r28
    8172:	df 93       	push	r29
    8174:	cd b7       	in	r28, 0x3d	; 61
    8176:	de b7       	in	r29, 0x3e	; 62
    8178:	c4 58       	subi	r28, 0x84	; 132
    817a:	d0 40       	sbci	r29, 0x00	; 0
    817c:	cd bf       	out	0x3d, r28	; 61
    817e:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    8180:	80 91 5f 40 	lds	r24, 0x405F
    8184:	88 2f       	mov	r24, r24
    8186:	90 e0       	ldi	r25, 0x00	; 0
    8188:	81 30       	cpi	r24, 0x01	; 1
    818a:	91 05       	cpc	r25, r1
    818c:	29 f0       	breq	.+10     	; 0x8198 <__vector_43+0x50>
    818e:	82 30       	cpi	r24, 0x02	; 2
    8190:	91 05       	cpc	r25, r1
    8192:	09 f4       	brne	.+2      	; 0x8196 <__vector_43+0x4e>
    8194:	73 c0       	rjmp	.+230    	; 0x827c <__vector_43+0x134>
    8196:	91 c0       	rjmp	.+290    	; 0x82ba <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    8198:	ce 01       	movw	r24, r28
    819a:	05 96       	adiw	r24, 0x05	; 5
    819c:	0e 94 84 22 	call	0x4508	; 0x4508 <chb_read>
			if(!strncmp(msg,"reset",5)){
    81a0:	ce 01       	movw	r24, r28
    81a2:	05 96       	adiw	r24, 0x05	; 5
    81a4:	25 e2       	ldi	r18, 0x25	; 37
    81a6:	30 e2       	ldi	r19, 0x20	; 32
    81a8:	b9 01       	movw	r22, r18
    81aa:	45 e0       	ldi	r20, 0x05	; 5
    81ac:	50 e0       	ldi	r21, 0x00	; 0
    81ae:	0e 94 53 5f 	call	0xbea6	; 0xbea6 <strncmp>
    81b2:	00 97       	sbiw	r24, 0x00	; 0
    81b4:	51 f4       	brne	.+20     	; 0x81ca <__vector_43+0x82>
				MotesReadyToSynch++;
    81b6:	80 91 75 50 	lds	r24, 0x5075
    81ba:	90 91 76 50 	lds	r25, 0x5076
    81be:	01 96       	adiw	r24, 0x01	; 1
    81c0:	80 93 75 50 	sts	0x5075, r24
    81c4:	90 93 76 50 	sts	0x5076, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    81c8:	7a c0       	rjmp	.+244    	; 0x82be <__vector_43+0x176>
			if(!strncmp(msg,"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    81ca:	19 82       	std	Y+1, r1	; 0x01
    81cc:	1a 82       	std	Y+2, r1	; 0x02
    81ce:	1b 82       	std	Y+3, r1	; 0x03
    81d0:	1c 82       	std	Y+4, r1	; 0x04
    81d2:	1a c0       	rjmp	.+52     	; 0x8208 <__vector_43+0xc0>
    81d4:	9e 01       	movw	r18, r28
    81d6:	2b 5f       	subi	r18, 0xFB	; 251
    81d8:	3f 4f       	sbci	r19, 0xFF	; 255
    81da:	89 81       	ldd	r24, Y+1	; 0x01
    81dc:	9a 81       	ldd	r25, Y+2	; 0x02
    81de:	82 0f       	add	r24, r18
    81e0:	93 1f       	adc	r25, r19
    81e2:	fc 01       	movw	r30, r24
    81e4:	20 81       	ld	r18, Z
    81e6:	89 81       	ldd	r24, Y+1	; 0x01
    81e8:	9a 81       	ldd	r25, Y+2	; 0x02
    81ea:	80 52       	subi	r24, 0x20	; 32
    81ec:	9c 4d       	sbci	r25, 0xDC	; 220
    81ee:	fc 01       	movw	r30, r24
    81f0:	20 83       	st	Z, r18
    81f2:	89 81       	ldd	r24, Y+1	; 0x01
    81f4:	9a 81       	ldd	r25, Y+2	; 0x02
    81f6:	ab 81       	ldd	r26, Y+3	; 0x03
    81f8:	bc 81       	ldd	r27, Y+4	; 0x04
    81fa:	01 96       	adiw	r24, 0x01	; 1
    81fc:	a1 1d       	adc	r26, r1
    81fe:	b1 1d       	adc	r27, r1
    8200:	89 83       	std	Y+1, r24	; 0x01
    8202:	9a 83       	std	Y+2, r25	; 0x02
    8204:	ab 83       	std	Y+3, r26	; 0x03
    8206:	bc 83       	std	Y+4, r27	; 0x04
    8208:	89 81       	ldd	r24, Y+1	; 0x01
    820a:	9a 81       	ldd	r25, Y+2	; 0x02
    820c:	ab 81       	ldd	r26, Y+3	; 0x03
    820e:	bc 81       	ldd	r27, Y+4	; 0x04
    8210:	80 38       	cpi	r24, 0x80	; 128
    8212:	91 05       	cpc	r25, r1
    8214:	a1 05       	cpc	r26, r1
    8216:	b1 05       	cpc	r27, r1
    8218:	e8 f2       	brcs	.-70     	; 0x81d4 <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    821a:	80 91 c7 50 	lds	r24, 0x50C7
    821e:	90 91 c8 50 	lds	r25, 0x50C8
    8222:	a0 91 c9 50 	lds	r26, 0x50C9
    8226:	b0 91 ca 50 	lds	r27, 0x50CA
    822a:	80 58       	subi	r24, 0x80	; 128
    822c:	9f 4f       	sbci	r25, 0xFF	; 255
    822e:	af 4f       	sbci	r26, 0xFF	; 255
    8230:	bf 4f       	sbci	r27, 0xFF	; 255
    8232:	80 93 c7 50 	sts	0x50C7, r24
    8236:	90 93 c8 50 	sts	0x50C8, r25
    823a:	a0 93 c9 50 	sts	0x50C9, r26
    823e:	b0 93 ca 50 	sts	0x50CA, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    8242:	80 91 c7 50 	lds	r24, 0x50C7
    8246:	90 91 c8 50 	lds	r25, 0x50C8
    824a:	a0 91 c9 50 	lds	r26, 0x50C9
    824e:	b0 91 ca 50 	lds	r27, 0x50CA
    8252:	80 58       	subi	r24, 0x80	; 128
    8254:	9f 4f       	sbci	r25, 0xFF	; 255
    8256:	af 4f       	sbci	r26, 0xFF	; 255
    8258:	bf 4f       	sbci	r27, 0xFF	; 255
    825a:	81 37       	cpi	r24, 0x71	; 113
    825c:	fc e1       	ldi	r31, 0x1C	; 28
    825e:	9f 07       	cpc	r25, r31
    8260:	f0 e0       	ldi	r31, 0x00	; 0
    8262:	af 07       	cpc	r26, r31
    8264:	f0 e0       	ldi	r31, 0x00	; 0
    8266:	bf 07       	cpc	r27, r31
    8268:	50 f1       	brcs	.+84     	; 0x82be <__vector_43+0x176>
    826a:	10 92 c7 50 	sts	0x50C7, r1
    826e:	10 92 c8 50 	sts	0x50C8, r1
    8272:	10 92 c9 50 	sts	0x50C9, r1
    8276:	10 92 ca 50 	sts	0x50CA, r1
			}			
			break;
    827a:	21 c0       	rjmp	.+66     	; 0x82be <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    827c:	ce 01       	movw	r24, r28
    827e:	05 96       	adiw	r24, 0x05	; 5
    8280:	0e 94 84 22 	call	0x4508	; 0x4508 <chb_read>
			if(!strncmp(msg,"start sampling",15)){	//if basestation synch response message received, do the following
    8284:	ce 01       	movw	r24, r28
    8286:	05 96       	adiw	r24, 0x05	; 5
    8288:	2b e2       	ldi	r18, 0x2B	; 43
    828a:	30 e2       	ldi	r19, 0x20	; 32
    828c:	b9 01       	movw	r22, r18
    828e:	4f e0       	ldi	r20, 0x0F	; 15
    8290:	50 e0       	ldi	r21, 0x00	; 0
    8292:	0e 94 53 5f 	call	0xbea6	; 0xbea6 <strncmp>
    8296:	00 97       	sbiw	r24, 0x00	; 0
    8298:	a1 f4       	brne	.+40     	; 0x82c2 <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    829a:	83 e0       	ldi	r24, 0x03	; 3
    829c:	80 93 5f 40 	sts	0x405F, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    82a0:	80 e4       	ldi	r24, 0x40	; 64
    82a2:	99 e0       	ldi	r25, 0x09	; 9
    82a4:	29 e0       	ldi	r18, 0x09	; 9
    82a6:	fc 01       	movw	r30, r24
    82a8:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    82aa:	80 e4       	ldi	r24, 0x40	; 64
    82ac:	98 e0       	ldi	r25, 0x08	; 8
    82ae:	21 e0       	ldi	r18, 0x01	; 1
    82b0:	fc 01       	movw	r30, r24
    82b2:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    82b4:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <ADC_Resume_Sampling>
			}
			break;
    82b8:	04 c0       	rjmp	.+8      	; 0x82c2 <__vector_43+0x17a>
		default:
			break;
    82ba:	00 00       	nop
    82bc:	03 c0       	rjmp	.+6      	; 0x82c4 <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    82be:	00 00       	nop
    82c0:	01 c0       	rjmp	.+2      	; 0x82c4 <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    82c2:	00 00       	nop
		default:
			break;
	}
    82c4:	cc 57       	subi	r28, 0x7C	; 124
    82c6:	df 4f       	sbci	r29, 0xFF	; 255
    82c8:	cd bf       	out	0x3d, r28	; 61
    82ca:	de bf       	out	0x3e, r29	; 62
    82cc:	df 91       	pop	r29
    82ce:	cf 91       	pop	r28
    82d0:	ff 91       	pop	r31
    82d2:	ef 91       	pop	r30
    82d4:	bf 91       	pop	r27
    82d6:	af 91       	pop	r26
    82d8:	9f 91       	pop	r25
    82da:	8f 91       	pop	r24
    82dc:	7f 91       	pop	r23
    82de:	6f 91       	pop	r22
    82e0:	5f 91       	pop	r21
    82e2:	4f 91       	pop	r20
    82e4:	3f 91       	pop	r19
    82e6:	2f 91       	pop	r18
    82e8:	0f 90       	pop	r0
    82ea:	00 92 3b 00 	sts	0x003B, r0
    82ee:	0f 90       	pop	r0
    82f0:	0f be       	out	0x3f, r0	; 63
    82f2:	0f 90       	pop	r0
    82f4:	1f 90       	pop	r1
    82f6:	18 95       	reti

000082f8 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    82f8:	ef 92       	push	r14
    82fa:	ff 92       	push	r15
    82fc:	0f 93       	push	r16
    82fe:	1f 93       	push	r17
    8300:	cf 93       	push	r28
    8302:	df 93       	push	r29
    8304:	cd b7       	in	r28, 0x3d	; 61
    8306:	de b7       	in	r29, 0x3e	; 62
    8308:	2a 97       	sbiw	r28, 0x0a	; 10
    830a:	cd bf       	out	0x3d, r28	; 61
    830c:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    830e:	10 92 7a 50 	sts	0x507A, r1
    8312:	10 92 7b 50 	sts	0x507B, r1
    8316:	10 92 7c 50 	sts	0x507C, r1
    831a:	10 92 7d 50 	sts	0x507D, r1

SD_read_block(0,SDBuffer);
    831e:	27 ed       	ldi	r18, 0xD7	; 215
    8320:	31 e2       	ldi	r19, 0x21	; 33
    8322:	60 e0       	ldi	r22, 0x00	; 0
    8324:	70 e0       	ldi	r23, 0x00	; 0
    8326:	cb 01       	movw	r24, r22
    8328:	a9 01       	movw	r20, r18
    832a:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    832e:	87 ed       	ldi	r24, 0xD7	; 215
    8330:	91 e2       	ldi	r25, 0x21	; 33
    8332:	89 83       	std	Y+1, r24	; 0x01
    8334:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    8336:	89 81       	ldd	r24, Y+1	; 0x01
    8338:	9a 81       	ldd	r25, Y+2	; 0x02
    833a:	fc 01       	movw	r30, r24
    833c:	80 81       	ld	r24, Z
    833e:	89 3e       	cpi	r24, 0xE9	; 233
    8340:	09 f4       	brne	.+2      	; 0x8344 <getBootSectorData+0x4c>
    8342:	4d c0       	rjmp	.+154    	; 0x83de <getBootSectorData+0xe6>
    8344:	89 81       	ldd	r24, Y+1	; 0x01
    8346:	9a 81       	ldd	r25, Y+2	; 0x02
    8348:	fc 01       	movw	r30, r24
    834a:	80 81       	ld	r24, Z
    834c:	8b 3e       	cpi	r24, 0xEB	; 235
    834e:	09 f4       	brne	.+2      	; 0x8352 <getBootSectorData+0x5a>
    8350:	46 c0       	rjmp	.+140    	; 0x83de <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    8352:	87 ed       	ldi	r24, 0xD7	; 215
    8354:	91 e2       	ldi	r25, 0x21	; 33
    8356:	8b 83       	std	Y+3, r24	; 0x03
    8358:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    835a:	8b 81       	ldd	r24, Y+3	; 0x03
    835c:	9c 81       	ldd	r25, Y+4	; 0x04
    835e:	82 50       	subi	r24, 0x02	; 2
    8360:	9e 4f       	sbci	r25, 0xFE	; 254
    8362:	fc 01       	movw	r30, r24
    8364:	80 81       	ld	r24, Z
    8366:	91 81       	ldd	r25, Z+1	; 0x01
    8368:	fa ea       	ldi	r31, 0xAA	; 170
    836a:	85 35       	cpi	r24, 0x55	; 85
    836c:	9f 07       	cpc	r25, r31
    836e:	11 f0       	breq	.+4      	; 0x8374 <getBootSectorData+0x7c>
    8370:	81 e0       	ldi	r24, 0x01	; 1
    8372:	01 c1       	rjmp	.+514    	; 0x8576 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    8374:	8b 81       	ldd	r24, Y+3	; 0x03
    8376:	9c 81       	ldd	r25, Y+4	; 0x04
    8378:	82 54       	subi	r24, 0x42	; 66
    837a:	9e 4f       	sbci	r25, 0xFE	; 254
    837c:	8d 83       	std	Y+5, r24	; 0x05
    837e:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    8380:	8d 81       	ldd	r24, Y+5	; 0x05
    8382:	9e 81       	ldd	r25, Y+6	; 0x06
    8384:	fc 01       	movw	r30, r24
    8386:	80 85       	ldd	r24, Z+8	; 0x08
    8388:	91 85       	ldd	r25, Z+9	; 0x09
    838a:	a2 85       	ldd	r26, Z+10	; 0x0a
    838c:	b3 85       	ldd	r27, Z+11	; 0x0b
    838e:	80 93 7a 50 	sts	0x507A, r24
    8392:	90 93 7b 50 	sts	0x507B, r25
    8396:	a0 93 7c 50 	sts	0x507C, r26
    839a:	b0 93 7d 50 	sts	0x507D, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    839e:	8d 81       	ldd	r24, Y+5	; 0x05
    83a0:	9e 81       	ldd	r25, Y+6	; 0x06
    83a2:	fc 01       	movw	r30, r24
    83a4:	80 85       	ldd	r24, Z+8	; 0x08
    83a6:	91 85       	ldd	r25, Z+9	; 0x09
    83a8:	a2 85       	ldd	r26, Z+10	; 0x0a
    83aa:	b3 85       	ldd	r27, Z+11	; 0x0b
    83ac:	27 ed       	ldi	r18, 0xD7	; 215
    83ae:	31 e2       	ldi	r19, 0x21	; 33
    83b0:	bc 01       	movw	r22, r24
    83b2:	cd 01       	movw	r24, r26
    83b4:	a9 01       	movw	r20, r18
    83b6:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    83ba:	87 ed       	ldi	r24, 0xD7	; 215
    83bc:	91 e2       	ldi	r25, 0x21	; 33
    83be:	89 83       	std	Y+1, r24	; 0x01
    83c0:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    83c2:	89 81       	ldd	r24, Y+1	; 0x01
    83c4:	9a 81       	ldd	r25, Y+2	; 0x02
    83c6:	fc 01       	movw	r30, r24
    83c8:	80 81       	ld	r24, Z
    83ca:	89 3e       	cpi	r24, 0xE9	; 233
    83cc:	41 f0       	breq	.+16     	; 0x83de <getBootSectorData+0xe6>
    83ce:	89 81       	ldd	r24, Y+1	; 0x01
    83d0:	9a 81       	ldd	r25, Y+2	; 0x02
    83d2:	fc 01       	movw	r30, r24
    83d4:	80 81       	ld	r24, Z
    83d6:	8b 3e       	cpi	r24, 0xEB	; 235
    83d8:	11 f0       	breq	.+4      	; 0x83de <getBootSectorData+0xe6>
    83da:	81 e0       	ldi	r24, 0x01	; 1
    83dc:	cc c0       	rjmp	.+408    	; 0x8576 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    83de:	89 81       	ldd	r24, Y+1	; 0x01
    83e0:	9a 81       	ldd	r25, Y+2	; 0x02
    83e2:	fc 01       	movw	r30, r24
    83e4:	83 85       	ldd	r24, Z+11	; 0x0b
    83e6:	94 85       	ldd	r25, Z+12	; 0x0c
    83e8:	80 93 55 40 	sts	0x4055, r24
    83ec:	90 93 56 40 	sts	0x4056, r25
sectorPerCluster = bpb->sectorPerCluster;
    83f0:	89 81       	ldd	r24, Y+1	; 0x01
    83f2:	9a 81       	ldd	r25, Y+2	; 0x02
    83f4:	fc 01       	movw	r30, r24
    83f6:	85 85       	ldd	r24, Z+13	; 0x0d
    83f8:	88 2f       	mov	r24, r24
    83fa:	90 e0       	ldi	r25, 0x00	; 0
    83fc:	80 93 78 50 	sts	0x5078, r24
    8400:	90 93 79 50 	sts	0x5079, r25
reservedSectorCount = bpb->reservedSectorCount;
    8404:	89 81       	ldd	r24, Y+1	; 0x01
    8406:	9a 81       	ldd	r25, Y+2	; 0x02
    8408:	fc 01       	movw	r30, r24
    840a:	86 85       	ldd	r24, Z+14	; 0x0e
    840c:	97 85       	ldd	r25, Z+15	; 0x0f
    840e:	80 93 80 50 	sts	0x5080, r24
    8412:	90 93 81 50 	sts	0x5081, r25
rootCluster = bpb->rootCluster;
    8416:	89 81       	ldd	r24, Y+1	; 0x01
    8418:	9a 81       	ldd	r25, Y+2	; 0x02
    841a:	fc 01       	movw	r30, r24
    841c:	84 a5       	lds	r24, 0x64
    841e:	95 a5       	lds	r25, 0x65
    8420:	a6 a5       	lds	r26, 0x66
    8422:	b7 a5       	lds	r27, 0x67
    8424:	80 93 60 40 	sts	0x4060, r24
    8428:	90 93 61 40 	sts	0x4061, r25
    842c:	a0 93 62 40 	sts	0x4062, r26
    8430:	b0 93 63 40 	sts	0x4063, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    8434:	89 81       	ldd	r24, Y+1	; 0x01
    8436:	9a 81       	ldd	r25, Y+2	; 0x02
    8438:	fc 01       	movw	r30, r24
    843a:	24 8d       	ldd	r18, Z+28	; 0x1c
    843c:	35 8d       	ldd	r19, Z+29	; 0x1d
    843e:	46 8d       	ldd	r20, Z+30	; 0x1e
    8440:	57 8d       	ldd	r21, Z+31	; 0x1f
    8442:	80 91 80 50 	lds	r24, 0x5080
    8446:	90 91 81 50 	lds	r25, 0x5081
    844a:	cc 01       	movw	r24, r24
    844c:	a0 e0       	ldi	r26, 0x00	; 0
    844e:	b0 e0       	ldi	r27, 0x00	; 0
    8450:	79 01       	movw	r14, r18
    8452:	8a 01       	movw	r16, r20
    8454:	e8 0e       	add	r14, r24
    8456:	f9 1e       	adc	r15, r25
    8458:	0a 1f       	adc	r16, r26
    845a:	1b 1f       	adc	r17, r27
    845c:	89 81       	ldd	r24, Y+1	; 0x01
    845e:	9a 81       	ldd	r25, Y+2	; 0x02
    8460:	fc 01       	movw	r30, r24
    8462:	80 89       	ldd	r24, Z+16	; 0x10
    8464:	88 2f       	mov	r24, r24
    8466:	90 e0       	ldi	r25, 0x00	; 0
    8468:	a0 e0       	ldi	r26, 0x00	; 0
    846a:	b0 e0       	ldi	r27, 0x00	; 0
    846c:	29 81       	ldd	r18, Y+1	; 0x01
    846e:	3a 81       	ldd	r19, Y+2	; 0x02
    8470:	f9 01       	movw	r30, r18
    8472:	24 a1       	lds	r18, 0x44
    8474:	35 a1       	lds	r19, 0x45
    8476:	46 a1       	lds	r20, 0x46
    8478:	57 a1       	lds	r21, 0x47
    847a:	bc 01       	movw	r22, r24
    847c:	cd 01       	movw	r24, r26
    847e:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    8482:	dc 01       	movw	r26, r24
    8484:	cb 01       	movw	r24, r22
    8486:	8e 0d       	add	r24, r14
    8488:	9f 1d       	adc	r25, r15
    848a:	a0 1f       	adc	r26, r16
    848c:	b1 1f       	adc	r27, r17
    848e:	80 93 dc 23 	sts	0x23DC, r24
    8492:	90 93 dd 23 	sts	0x23DD, r25
    8496:	a0 93 de 23 	sts	0x23DE, r26
    849a:	b0 93 df 23 	sts	0x23DF, r27

dataSectors = bpb->totalSectors_F32
    849e:	89 81       	ldd	r24, Y+1	; 0x01
    84a0:	9a 81       	ldd	r25, Y+2	; 0x02
    84a2:	fc 01       	movw	r30, r24
    84a4:	20 a1       	lds	r18, 0x40
    84a6:	31 a1       	lds	r19, 0x41
    84a8:	42 a1       	lds	r20, 0x42
    84aa:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    84ac:	89 81       	ldd	r24, Y+1	; 0x01
    84ae:	9a 81       	ldd	r25, Y+2	; 0x02
    84b0:	fc 01       	movw	r30, r24
    84b2:	86 85       	ldd	r24, Z+14	; 0x0e
    84b4:	97 85       	ldd	r25, Z+15	; 0x0f
    84b6:	cc 01       	movw	r24, r24
    84b8:	a0 e0       	ldi	r26, 0x00	; 0
    84ba:	b0 e0       	ldi	r27, 0x00	; 0
    84bc:	79 01       	movw	r14, r18
    84be:	8a 01       	movw	r16, r20
    84c0:	e8 1a       	sub	r14, r24
    84c2:	f9 0a       	sbc	r15, r25
    84c4:	0a 0b       	sbc	r16, r26
    84c6:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    84c8:	89 81       	ldd	r24, Y+1	; 0x01
    84ca:	9a 81       	ldd	r25, Y+2	; 0x02
    84cc:	fc 01       	movw	r30, r24
    84ce:	80 89       	ldd	r24, Z+16	; 0x10
    84d0:	88 2f       	mov	r24, r24
    84d2:	90 e0       	ldi	r25, 0x00	; 0
    84d4:	a0 e0       	ldi	r26, 0x00	; 0
    84d6:	b0 e0       	ldi	r27, 0x00	; 0
    84d8:	29 81       	ldd	r18, Y+1	; 0x01
    84da:	3a 81       	ldd	r19, Y+2	; 0x02
    84dc:	f9 01       	movw	r30, r18
    84de:	24 a1       	lds	r18, 0x44
    84e0:	35 a1       	lds	r19, 0x45
    84e2:	46 a1       	lds	r20, 0x46
    84e4:	57 a1       	lds	r21, 0x47
    84e6:	bc 01       	movw	r22, r24
    84e8:	cd 01       	movw	r24, r26
    84ea:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    84ee:	dc 01       	movw	r26, r24
    84f0:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    84f2:	a8 01       	movw	r20, r16
    84f4:	97 01       	movw	r18, r14
    84f6:	28 1b       	sub	r18, r24
    84f8:	39 0b       	sbc	r19, r25
    84fa:	4a 0b       	sbc	r20, r26
    84fc:	5b 0b       	sbc	r21, r27
    84fe:	da 01       	movw	r26, r20
    8500:	c9 01       	movw	r24, r18
    8502:	8f 83       	std	Y+7, r24	; 0x07
    8504:	98 87       	std	Y+8, r25	; 0x08
    8506:	a9 87       	std	Y+9, r26	; 0x09
    8508:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    850a:	80 91 78 50 	lds	r24, 0x5078
    850e:	90 91 79 50 	lds	r25, 0x5079
    8512:	9c 01       	movw	r18, r24
    8514:	40 e0       	ldi	r20, 0x00	; 0
    8516:	50 e0       	ldi	r21, 0x00	; 0
    8518:	8f 81       	ldd	r24, Y+7	; 0x07
    851a:	98 85       	ldd	r25, Y+8	; 0x08
    851c:	a9 85       	ldd	r26, Y+9	; 0x09
    851e:	ba 85       	ldd	r27, Y+10	; 0x0a
    8520:	bc 01       	movw	r22, r24
    8522:	cd 01       	movw	r24, r26
    8524:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    8528:	da 01       	movw	r26, r20
    852a:	c9 01       	movw	r24, r18
    852c:	80 93 5a 40 	sts	0x405A, r24
    8530:	90 93 5b 40 	sts	0x405B, r25
    8534:	a0 93 5c 40 	sts	0x405C, r26
    8538:	b0 93 5d 40 	sts	0x405D, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    853c:	81 e0       	ldi	r24, 0x01	; 1
    853e:	60 e0       	ldi	r22, 0x00	; 0
    8540:	20 e0       	ldi	r18, 0x00	; 0
    8542:	30 e0       	ldi	r19, 0x00	; 0
    8544:	a9 01       	movw	r20, r18
    8546:	0e 94 a1 43 	call	0x8742	; 0x8742 <getSetFreeCluster>
    854a:	9b 01       	movw	r18, r22
    854c:	ac 01       	movw	r20, r24
    854e:	80 91 5a 40 	lds	r24, 0x405A
    8552:	90 91 5b 40 	lds	r25, 0x405B
    8556:	a0 91 5c 40 	lds	r26, 0x405C
    855a:	b0 91 5d 40 	lds	r27, 0x405D
    855e:	82 17       	cp	r24, r18
    8560:	93 07       	cpc	r25, r19
    8562:	a4 07       	cpc	r26, r20
    8564:	b5 07       	cpc	r27, r21
    8566:	18 f4       	brcc	.+6      	; 0x856e <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    8568:	10 92 cc 50 	sts	0x50CC, r1
    856c:	03 c0       	rjmp	.+6      	; 0x8574 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    856e:	81 e0       	ldi	r24, 0x01	; 1
    8570:	80 93 cc 50 	sts	0x50CC, r24
return 0;
    8574:	80 e0       	ldi	r24, 0x00	; 0
}
    8576:	2a 96       	adiw	r28, 0x0a	; 10
    8578:	cd bf       	out	0x3d, r28	; 61
    857a:	de bf       	out	0x3e, r29	; 62
    857c:	df 91       	pop	r29
    857e:	cf 91       	pop	r28
    8580:	1f 91       	pop	r17
    8582:	0f 91       	pop	r16
    8584:	ff 90       	pop	r15
    8586:	ef 90       	pop	r14
    8588:	08 95       	ret

0000858a <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    858a:	cf 93       	push	r28
    858c:	df 93       	push	r29
    858e:	00 d0       	rcall	.+0      	; 0x8590 <getFirstSector+0x6>
    8590:	0f 92       	push	r0
    8592:	cd b7       	in	r28, 0x3d	; 61
    8594:	de b7       	in	r29, 0x3e	; 62
    8596:	69 83       	std	Y+1, r22	; 0x01
    8598:	7a 83       	std	Y+2, r23	; 0x02
    859a:	8b 83       	std	Y+3, r24	; 0x03
    859c:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    859e:	89 81       	ldd	r24, Y+1	; 0x01
    85a0:	9a 81       	ldd	r25, Y+2	; 0x02
    85a2:	ab 81       	ldd	r26, Y+3	; 0x03
    85a4:	bc 81       	ldd	r27, Y+4	; 0x04
    85a6:	02 97       	sbiw	r24, 0x02	; 2
    85a8:	a1 09       	sbc	r26, r1
    85aa:	b1 09       	sbc	r27, r1
    85ac:	20 91 78 50 	lds	r18, 0x5078
    85b0:	30 91 79 50 	lds	r19, 0x5079
    85b4:	99 01       	movw	r18, r18
    85b6:	40 e0       	ldi	r20, 0x00	; 0
    85b8:	50 e0       	ldi	r21, 0x00	; 0
    85ba:	bc 01       	movw	r22, r24
    85bc:	cd 01       	movw	r24, r26
    85be:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    85c2:	9b 01       	movw	r18, r22
    85c4:	ac 01       	movw	r20, r24
    85c6:	80 91 dc 23 	lds	r24, 0x23DC
    85ca:	90 91 dd 23 	lds	r25, 0x23DD
    85ce:	a0 91 de 23 	lds	r26, 0x23DE
    85d2:	b0 91 df 23 	lds	r27, 0x23DF
    85d6:	82 0f       	add	r24, r18
    85d8:	93 1f       	adc	r25, r19
    85da:	a4 1f       	adc	r26, r20
    85dc:	b5 1f       	adc	r27, r21
}
    85de:	bc 01       	movw	r22, r24
    85e0:	cd 01       	movw	r24, r26
    85e2:	24 96       	adiw	r28, 0x04	; 4
    85e4:	cd bf       	out	0x3d, r28	; 61
    85e6:	de bf       	out	0x3e, r29	; 62
    85e8:	df 91       	pop	r29
    85ea:	cf 91       	pop	r28
    85ec:	08 95       	ret

000085ee <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    85ee:	ef 92       	push	r14
    85f0:	ff 92       	push	r15
    85f2:	0f 93       	push	r16
    85f4:	1f 93       	push	r17
    85f6:	cf 93       	push	r28
    85f8:	df 93       	push	r29
    85fa:	cd b7       	in	r28, 0x3d	; 61
    85fc:	de b7       	in	r29, 0x3e	; 62
    85fe:	62 97       	sbiw	r28, 0x12	; 18
    8600:	cd bf       	out	0x3d, r28	; 61
    8602:	de bf       	out	0x3e, r29	; 62
    8604:	6a 87       	std	Y+10, r22	; 0x0a
    8606:	7b 87       	std	Y+11, r23	; 0x0b
    8608:	8c 87       	std	Y+12, r24	; 0x0c
    860a:	9d 87       	std	Y+13, r25	; 0x0d
    860c:	4e 87       	std	Y+14, r20	; 0x0e
    860e:	0f 87       	std	Y+15, r16	; 0x0f
    8610:	18 8b       	std	Y+16, r17	; 0x10
    8612:	29 8b       	std	Y+17, r18	; 0x11
    8614:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    8616:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    8618:	80 91 80 50 	lds	r24, 0x5080
    861c:	90 91 81 50 	lds	r25, 0x5081
    8620:	9c 01       	movw	r18, r24
    8622:	40 e0       	ldi	r20, 0x00	; 0
    8624:	50 e0       	ldi	r21, 0x00	; 0
    8626:	80 91 7a 50 	lds	r24, 0x507A
    862a:	90 91 7b 50 	lds	r25, 0x507B
    862e:	a0 91 7c 50 	lds	r26, 0x507C
    8632:	b0 91 7d 50 	lds	r27, 0x507D
    8636:	79 01       	movw	r14, r18
    8638:	8a 01       	movw	r16, r20
    863a:	e8 0e       	add	r14, r24
    863c:	f9 1e       	adc	r15, r25
    863e:	0a 1f       	adc	r16, r26
    8640:	1b 1f       	adc	r17, r27
    8642:	8a 85       	ldd	r24, Y+10	; 0x0a
    8644:	9b 85       	ldd	r25, Y+11	; 0x0b
    8646:	ac 85       	ldd	r26, Y+12	; 0x0c
    8648:	bd 85       	ldd	r27, Y+13	; 0x0d
    864a:	88 0f       	add	r24, r24
    864c:	99 1f       	adc	r25, r25
    864e:	aa 1f       	adc	r26, r26
    8650:	bb 1f       	adc	r27, r27
    8652:	88 0f       	add	r24, r24
    8654:	99 1f       	adc	r25, r25
    8656:	aa 1f       	adc	r26, r26
    8658:	bb 1f       	adc	r27, r27
    865a:	20 91 55 40 	lds	r18, 0x4055
    865e:	30 91 56 40 	lds	r19, 0x4056
    8662:	99 01       	movw	r18, r18
    8664:	40 e0       	ldi	r20, 0x00	; 0
    8666:	50 e0       	ldi	r21, 0x00	; 0
    8668:	bc 01       	movw	r22, r24
    866a:	cd 01       	movw	r24, r26
    866c:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    8670:	da 01       	movw	r26, r20
    8672:	c9 01       	movw	r24, r18
    8674:	8e 0d       	add	r24, r14
    8676:	9f 1d       	adc	r25, r15
    8678:	a0 1f       	adc	r26, r16
    867a:	b1 1f       	adc	r27, r17
    867c:	8a 83       	std	Y+2, r24	; 0x02
    867e:	9b 83       	std	Y+3, r25	; 0x03
    8680:	ac 83       	std	Y+4, r26	; 0x04
    8682:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    8684:	8a 85       	ldd	r24, Y+10	; 0x0a
    8686:	9b 85       	ldd	r25, Y+11	; 0x0b
    8688:	ac 85       	ldd	r26, Y+12	; 0x0c
    868a:	bd 85       	ldd	r27, Y+13	; 0x0d
    868c:	88 0f       	add	r24, r24
    868e:	99 1f       	adc	r25, r25
    8690:	aa 1f       	adc	r26, r26
    8692:	bb 1f       	adc	r27, r27
    8694:	88 0f       	add	r24, r24
    8696:	99 1f       	adc	r25, r25
    8698:	aa 1f       	adc	r26, r26
    869a:	bb 1f       	adc	r27, r27
    869c:	20 91 55 40 	lds	r18, 0x4055
    86a0:	30 91 56 40 	lds	r19, 0x4056
    86a4:	99 01       	movw	r18, r18
    86a6:	40 e0       	ldi	r20, 0x00	; 0
    86a8:	50 e0       	ldi	r21, 0x00	; 0
    86aa:	bc 01       	movw	r22, r24
    86ac:	cd 01       	movw	r24, r26
    86ae:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    86b2:	dc 01       	movw	r26, r24
    86b4:	cb 01       	movw	r24, r22
    86b6:	8e 83       	std	Y+6, r24	; 0x06
    86b8:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    86ba:	8a 81       	ldd	r24, Y+2	; 0x02
    86bc:	9b 81       	ldd	r25, Y+3	; 0x03
    86be:	ac 81       	ldd	r26, Y+4	; 0x04
    86c0:	bd 81       	ldd	r27, Y+5	; 0x05
    86c2:	27 ed       	ldi	r18, 0xD7	; 215
    86c4:	31 e2       	ldi	r19, 0x21	; 33
    86c6:	bc 01       	movw	r22, r24
    86c8:	cd 01       	movw	r24, r26
    86ca:	a9 01       	movw	r20, r18
    86cc:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    86d0:	8e 81       	ldd	r24, Y+6	; 0x06
    86d2:	9f 81       	ldd	r25, Y+7	; 0x07
    86d4:	89 52       	subi	r24, 0x29	; 41
    86d6:	9e 4d       	sbci	r25, 0xDE	; 222
    86d8:	88 87       	std	Y+8, r24	; 0x08
    86da:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    86dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    86de:	88 23       	and	r24, r24
    86e0:	49 f4       	brne	.+18     	; 0x86f4 <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    86e2:	88 85       	ldd	r24, Y+8	; 0x08
    86e4:	99 85       	ldd	r25, Y+9	; 0x09
    86e6:	fc 01       	movw	r30, r24
    86e8:	80 81       	ld	r24, Z
    86ea:	91 81       	ldd	r25, Z+1	; 0x01
    86ec:	a2 81       	ldd	r26, Z+2	; 0x02
    86ee:	b3 81       	ldd	r27, Z+3	; 0x03
    86f0:	bf 70       	andi	r27, 0x0F	; 15
    86f2:	1b c0       	rjmp	.+54     	; 0x872a <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    86f4:	28 85       	ldd	r18, Y+8	; 0x08
    86f6:	39 85       	ldd	r19, Y+9	; 0x09
    86f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    86fa:	98 89       	ldd	r25, Y+16	; 0x10
    86fc:	a9 89       	ldd	r26, Y+17	; 0x11
    86fe:	ba 89       	ldd	r27, Y+18	; 0x12
    8700:	f9 01       	movw	r30, r18
    8702:	80 83       	st	Z, r24
    8704:	91 83       	std	Z+1, r25	; 0x01
    8706:	a2 83       	std	Z+2, r26	; 0x02
    8708:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    870a:	8a 81       	ldd	r24, Y+2	; 0x02
    870c:	9b 81       	ldd	r25, Y+3	; 0x03
    870e:	ac 81       	ldd	r26, Y+4	; 0x04
    8710:	bd 81       	ldd	r27, Y+5	; 0x05
    8712:	27 ed       	ldi	r18, 0xD7	; 215
    8714:	31 e2       	ldi	r19, 0x21	; 33
    8716:	bc 01       	movw	r22, r24
    8718:	cd 01       	movw	r24, r26
    871a:	a9 01       	movw	r20, r18
    871c:	20 e0       	ldi	r18, 0x00	; 0
    871e:	32 e0       	ldi	r19, 0x02	; 2
    8720:	0e 94 23 50 	call	0xa046	; 0xa046 <SD_write_block>

return (0);
    8724:	80 e0       	ldi	r24, 0x00	; 0
    8726:	90 e0       	ldi	r25, 0x00	; 0
    8728:	dc 01       	movw	r26, r24
}
    872a:	bc 01       	movw	r22, r24
    872c:	cd 01       	movw	r24, r26
    872e:	62 96       	adiw	r28, 0x12	; 18
    8730:	cd bf       	out	0x3d, r28	; 61
    8732:	de bf       	out	0x3e, r29	; 62
    8734:	df 91       	pop	r29
    8736:	cf 91       	pop	r28
    8738:	1f 91       	pop	r17
    873a:	0f 91       	pop	r16
    873c:	ff 90       	pop	r15
    873e:	ef 90       	pop	r14
    8740:	08 95       	ret

00008742 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    8742:	cf 93       	push	r28
    8744:	df 93       	push	r29
    8746:	cd b7       	in	r28, 0x3d	; 61
    8748:	de b7       	in	r29, 0x3e	; 62
    874a:	28 97       	sbiw	r28, 0x08	; 8
    874c:	cd bf       	out	0x3d, r28	; 61
    874e:	de bf       	out	0x3e, r29	; 62
    8750:	8b 83       	std	Y+3, r24	; 0x03
    8752:	6c 83       	std	Y+4, r22	; 0x04
    8754:	2d 83       	std	Y+5, r18	; 0x05
    8756:	3e 83       	std	Y+6, r19	; 0x06
    8758:	4f 83       	std	Y+7, r20	; 0x07
    875a:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    875c:	87 ed       	ldi	r24, 0xD7	; 215
    875e:	91 e2       	ldi	r25, 0x21	; 33
    8760:	89 83       	std	Y+1, r24	; 0x01
    8762:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    8764:	80 91 7a 50 	lds	r24, 0x507A
    8768:	90 91 7b 50 	lds	r25, 0x507B
    876c:	a0 91 7c 50 	lds	r26, 0x507C
    8770:	b0 91 7d 50 	lds	r27, 0x507D
    8774:	01 96       	adiw	r24, 0x01	; 1
    8776:	a1 1d       	adc	r26, r1
    8778:	b1 1d       	adc	r27, r1
    877a:	27 ed       	ldi	r18, 0xD7	; 215
    877c:	31 e2       	ldi	r19, 0x21	; 33
    877e:	bc 01       	movw	r22, r24
    8780:	cd 01       	movw	r24, r26
    8782:	a9 01       	movw	r20, r18
    8784:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    8788:	89 81       	ldd	r24, Y+1	; 0x01
    878a:	9a 81       	ldd	r25, Y+2	; 0x02
    878c:	fc 01       	movw	r30, r24
    878e:	80 81       	ld	r24, Z
    8790:	91 81       	ldd	r25, Z+1	; 0x01
    8792:	a2 81       	ldd	r26, Z+2	; 0x02
    8794:	b3 81       	ldd	r27, Z+3	; 0x03
    8796:	82 35       	cpi	r24, 0x52	; 82
    8798:	f2 e5       	ldi	r31, 0x52	; 82
    879a:	9f 07       	cpc	r25, r31
    879c:	f1 e6       	ldi	r31, 0x61	; 97
    879e:	af 07       	cpc	r26, r31
    87a0:	f1 e4       	ldi	r31, 0x41	; 65
    87a2:	bf 07       	cpc	r27, r31
    87a4:	11 f5       	brne	.+68     	; 0x87ea <getSetFreeCluster+0xa8>
    87a6:	89 81       	ldd	r24, Y+1	; 0x01
    87a8:	9a 81       	ldd	r25, Y+2	; 0x02
    87aa:	8c 51       	subi	r24, 0x1C	; 28
    87ac:	9e 4f       	sbci	r25, 0xFE	; 254
    87ae:	fc 01       	movw	r30, r24
    87b0:	80 81       	ld	r24, Z
    87b2:	91 81       	ldd	r25, Z+1	; 0x01
    87b4:	a2 81       	ldd	r26, Z+2	; 0x02
    87b6:	b3 81       	ldd	r27, Z+3	; 0x03
    87b8:	82 37       	cpi	r24, 0x72	; 114
    87ba:	f2 e7       	ldi	r31, 0x72	; 114
    87bc:	9f 07       	cpc	r25, r31
    87be:	f1 e4       	ldi	r31, 0x41	; 65
    87c0:	af 07       	cpc	r26, r31
    87c2:	f1 e6       	ldi	r31, 0x61	; 97
    87c4:	bf 07       	cpc	r27, r31
    87c6:	89 f4       	brne	.+34     	; 0x87ea <getSetFreeCluster+0xa8>
    87c8:	89 81       	ldd	r24, Y+1	; 0x01
    87ca:	9a 81       	ldd	r25, Y+2	; 0x02
    87cc:	84 50       	subi	r24, 0x04	; 4
    87ce:	9e 4f       	sbci	r25, 0xFE	; 254
    87d0:	fc 01       	movw	r30, r24
    87d2:	80 81       	ld	r24, Z
    87d4:	91 81       	ldd	r25, Z+1	; 0x01
    87d6:	a2 81       	ldd	r26, Z+2	; 0x02
    87d8:	b3 81       	ldd	r27, Z+3	; 0x03
    87da:	80 30       	cpi	r24, 0x00	; 0
    87dc:	f0 e0       	ldi	r31, 0x00	; 0
    87de:	9f 07       	cpc	r25, r31
    87e0:	f5 e5       	ldi	r31, 0x55	; 85
    87e2:	af 07       	cpc	r26, r31
    87e4:	fa ea       	ldi	r31, 0xAA	; 170
    87e6:	bf 07       	cpc	r27, r31
    87e8:	21 f0       	breq	.+8      	; 0x87f2 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    87ea:	8f ef       	ldi	r24, 0xFF	; 255
    87ec:	9f ef       	ldi	r25, 0xFF	; 255
    87ee:	dc 01       	movw	r26, r24
    87f0:	51 c0       	rjmp	.+162    	; 0x8894 <getSetFreeCluster+0x152>

 if(get_set == GET)
    87f2:	8c 81       	ldd	r24, Y+4	; 0x04
    87f4:	88 23       	and	r24, r24
    87f6:	b9 f4       	brne	.+46     	; 0x8826 <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    87f8:	8b 81       	ldd	r24, Y+3	; 0x03
    87fa:	81 30       	cpi	r24, 0x01	; 1
    87fc:	51 f4       	brne	.+20     	; 0x8812 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    87fe:	89 81       	ldd	r24, Y+1	; 0x01
    8800:	9a 81       	ldd	r25, Y+2	; 0x02
    8802:	88 51       	subi	r24, 0x18	; 24
    8804:	9e 4f       	sbci	r25, 0xFE	; 254
    8806:	fc 01       	movw	r30, r24
    8808:	80 81       	ld	r24, Z
    880a:	91 81       	ldd	r25, Z+1	; 0x01
    880c:	a2 81       	ldd	r26, Z+2	; 0x02
    880e:	b3 81       	ldd	r27, Z+3	; 0x03
    8810:	41 c0       	rjmp	.+130    	; 0x8894 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    8812:	89 81       	ldd	r24, Y+1	; 0x01
    8814:	9a 81       	ldd	r25, Y+2	; 0x02
    8816:	84 51       	subi	r24, 0x14	; 20
    8818:	9e 4f       	sbci	r25, 0xFE	; 254
    881a:	fc 01       	movw	r30, r24
    881c:	80 81       	ld	r24, Z
    881e:	91 81       	ldd	r25, Z+1	; 0x01
    8820:	a2 81       	ldd	r26, Z+2	; 0x02
    8822:	b3 81       	ldd	r27, Z+3	; 0x03
    8824:	37 c0       	rjmp	.+110    	; 0x8894 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    8826:	8b 81       	ldd	r24, Y+3	; 0x03
    8828:	81 30       	cpi	r24, 0x01	; 1
    882a:	79 f4       	brne	.+30     	; 0x884a <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    882c:	89 81       	ldd	r24, Y+1	; 0x01
    882e:	9a 81       	ldd	r25, Y+2	; 0x02
    8830:	9c 01       	movw	r18, r24
    8832:	28 51       	subi	r18, 0x18	; 24
    8834:	3e 4f       	sbci	r19, 0xFE	; 254
    8836:	8d 81       	ldd	r24, Y+5	; 0x05
    8838:	9e 81       	ldd	r25, Y+6	; 0x06
    883a:	af 81       	ldd	r26, Y+7	; 0x07
    883c:	b8 85       	ldd	r27, Y+8	; 0x08
    883e:	f9 01       	movw	r30, r18
    8840:	80 83       	st	Z, r24
    8842:	91 83       	std	Z+1, r25	; 0x01
    8844:	a2 83       	std	Z+2, r26	; 0x02
    8846:	b3 83       	std	Z+3, r27	; 0x03
    8848:	0e c0       	rjmp	.+28     	; 0x8866 <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    884a:	89 81       	ldd	r24, Y+1	; 0x01
    884c:	9a 81       	ldd	r25, Y+2	; 0x02
    884e:	9c 01       	movw	r18, r24
    8850:	24 51       	subi	r18, 0x14	; 20
    8852:	3e 4f       	sbci	r19, 0xFE	; 254
    8854:	8d 81       	ldd	r24, Y+5	; 0x05
    8856:	9e 81       	ldd	r25, Y+6	; 0x06
    8858:	af 81       	ldd	r26, Y+7	; 0x07
    885a:	b8 85       	ldd	r27, Y+8	; 0x08
    885c:	f9 01       	movw	r30, r18
    885e:	80 83       	st	Z, r24
    8860:	91 83       	std	Z+1, r25	; 0x01
    8862:	a2 83       	std	Z+2, r26	; 0x02
    8864:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    8866:	80 91 7a 50 	lds	r24, 0x507A
    886a:	90 91 7b 50 	lds	r25, 0x507B
    886e:	a0 91 7c 50 	lds	r26, 0x507C
    8872:	b0 91 7d 50 	lds	r27, 0x507D
    8876:	01 96       	adiw	r24, 0x01	; 1
    8878:	a1 1d       	adc	r26, r1
    887a:	b1 1d       	adc	r27, r1
    887c:	27 ed       	ldi	r18, 0xD7	; 215
    887e:	31 e2       	ldi	r19, 0x21	; 33
    8880:	bc 01       	movw	r22, r24
    8882:	cd 01       	movw	r24, r26
    8884:	a9 01       	movw	r20, r18
    8886:	20 e0       	ldi	r18, 0x00	; 0
    8888:	32 e0       	ldi	r19, 0x02	; 2
    888a:	0e 94 23 50 	call	0xa046	; 0xa046 <SD_write_block>
 }
 return 0xffffffff;
    888e:	8f ef       	ldi	r24, 0xFF	; 255
    8890:	9f ef       	ldi	r25, 0xFF	; 255
    8892:	dc 01       	movw	r26, r24
}
    8894:	bc 01       	movw	r22, r24
    8896:	cd 01       	movw	r24, r26
    8898:	28 96       	adiw	r28, 0x08	; 8
    889a:	cd bf       	out	0x3d, r28	; 61
    889c:	de bf       	out	0x3e, r29	; 62
    889e:	df 91       	pop	r29
    88a0:	cf 91       	pop	r28
    88a2:	08 95       	ret

000088a4 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    88a4:	0f 93       	push	r16
    88a6:	1f 93       	push	r17
    88a8:	cf 93       	push	r28
    88aa:	df 93       	push	r29
    88ac:	cd b7       	in	r28, 0x3d	; 61
    88ae:	de b7       	in	r29, 0x3e	; 62
    88b0:	6c 97       	sbiw	r28, 0x1c	; 28
    88b2:	cd bf       	out	0x3d, r28	; 61
    88b4:	de bf       	out	0x3e, r29	; 62
    88b6:	8a 8f       	std	Y+26, r24	; 0x1a
    88b8:	6b 8f       	std	Y+27, r22	; 0x1b
    88ba:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    88bc:	80 91 60 40 	lds	r24, 0x4060
    88c0:	90 91 61 40 	lds	r25, 0x4061
    88c4:	a0 91 62 40 	lds	r26, 0x4062
    88c8:	b0 91 63 40 	lds	r27, 0x4063
    88cc:	89 83       	std	Y+1, r24	; 0x01
    88ce:	9a 83       	std	Y+2, r25	; 0x02
    88d0:	ab 83       	std	Y+3, r26	; 0x03
    88d2:	bc 83       	std	Y+4, r27	; 0x04
    88d4:	01 c0       	rjmp	.+2      	; 0x88d8 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    88d6:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    88d8:	89 81       	ldd	r24, Y+1	; 0x01
    88da:	9a 81       	ldd	r25, Y+2	; 0x02
    88dc:	ab 81       	ldd	r26, Y+3	; 0x03
    88de:	bc 81       	ldd	r27, Y+4	; 0x04
    88e0:	bc 01       	movw	r22, r24
    88e2:	cd 01       	movw	r24, r26
    88e4:	0e 94 c5 42 	call	0x858a	; 0x858a <getFirstSector>
    88e8:	dc 01       	movw	r26, r24
    88ea:	cb 01       	movw	r24, r22
    88ec:	88 8b       	std	Y+16, r24	; 0x10
    88ee:	99 8b       	std	Y+17, r25	; 0x11
    88f0:	aa 8b       	std	Y+18, r26	; 0x12
    88f2:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    88f4:	1d 82       	std	Y+5, r1	; 0x05
    88f6:	1e 82       	std	Y+6, r1	; 0x06
    88f8:	1f 82       	std	Y+7, r1	; 0x07
    88fa:	18 86       	std	Y+8, r1	; 0x08
    88fc:	68 c1       	rjmp	.+720    	; 0x8bce <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    88fe:	28 89       	ldd	r18, Y+16	; 0x10
    8900:	39 89       	ldd	r19, Y+17	; 0x11
    8902:	4a 89       	ldd	r20, Y+18	; 0x12
    8904:	5b 89       	ldd	r21, Y+19	; 0x13
    8906:	8d 81       	ldd	r24, Y+5	; 0x05
    8908:	9e 81       	ldd	r25, Y+6	; 0x06
    890a:	af 81       	ldd	r26, Y+7	; 0x07
    890c:	b8 85       	ldd	r27, Y+8	; 0x08
    890e:	82 0f       	add	r24, r18
    8910:	93 1f       	adc	r25, r19
    8912:	a4 1f       	adc	r26, r20
    8914:	b5 1f       	adc	r27, r21
    8916:	27 ed       	ldi	r18, 0xD7	; 215
    8918:	31 e2       	ldi	r19, 0x21	; 33
    891a:	bc 01       	movw	r22, r24
    891c:	cd 01       	movw	r24, r26
    891e:	a9 01       	movw	r20, r18
    8920:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    8924:	1d 86       	std	Y+13, r1	; 0x0d
    8926:	1e 86       	std	Y+14, r1	; 0x0e
    8928:	3d c1       	rjmp	.+634    	; 0x8ba4 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    892a:	8d 85       	ldd	r24, Y+13	; 0x0d
    892c:	9e 85       	ldd	r25, Y+14	; 0x0e
    892e:	89 52       	subi	r24, 0x29	; 41
    8930:	9e 4d       	sbci	r25, 0xDE	; 222
    8932:	8c 8b       	std	Y+20, r24	; 0x14
    8934:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    8936:	8c 89       	ldd	r24, Y+20	; 0x14
    8938:	9d 89       	ldd	r25, Y+21	; 0x15
    893a:	fc 01       	movw	r30, r24
    893c:	80 81       	ld	r24, Z
    893e:	88 23       	and	r24, r24
    8940:	19 f4       	brne	.+6      	; 0x8948 <findFiles+0xa4>
		{
		  return 0;   
    8942:	80 e0       	ldi	r24, 0x00	; 0
    8944:	90 e0       	ldi	r25, 0x00	; 0
    8946:	80 c1       	rjmp	.+768    	; 0x8c48 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    8948:	8c 89       	ldd	r24, Y+20	; 0x14
    894a:	9d 89       	ldd	r25, Y+21	; 0x15
    894c:	fc 01       	movw	r30, r24
    894e:	80 81       	ld	r24, Z
    8950:	85 3e       	cpi	r24, 0xE5	; 229
    8952:	09 f4       	brne	.+2      	; 0x8956 <findFiles+0xb2>
    8954:	22 c1       	rjmp	.+580    	; 0x8b9a <findFiles+0x2f6>
    8956:	8c 89       	ldd	r24, Y+20	; 0x14
    8958:	9d 89       	ldd	r25, Y+21	; 0x15
    895a:	fc 01       	movw	r30, r24
    895c:	83 85       	ldd	r24, Z+11	; 0x0b
    895e:	8f 30       	cpi	r24, 0x0F	; 15
    8960:	09 f4       	brne	.+2      	; 0x8964 <findFiles+0xc0>
    8962:	1b c1       	rjmp	.+566    	; 0x8b9a <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    8964:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8966:	81 30       	cpi	r24, 0x01	; 1
    8968:	21 f0       	breq	.+8      	; 0x8972 <findFiles+0xce>
    896a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    896c:	82 30       	cpi	r24, 0x02	; 2
    896e:	09 f0       	breq	.+2      	; 0x8972 <findFiles+0xce>
    8970:	11 c1       	rjmp	.+546    	; 0x8b94 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8972:	1f 86       	std	Y+15, r1	; 0x0f
    8974:	17 c0       	rjmp	.+46     	; 0x89a4 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    8976:	8f 85       	ldd	r24, Y+15	; 0x0f
    8978:	88 2f       	mov	r24, r24
    897a:	90 e0       	ldi	r25, 0x00	; 0
    897c:	2c 89       	ldd	r18, Y+20	; 0x14
    897e:	3d 89       	ldd	r19, Y+21	; 0x15
    8980:	82 0f       	add	r24, r18
    8982:	93 1f       	adc	r25, r19
    8984:	fc 01       	movw	r30, r24
    8986:	40 81       	ld	r20, Z
    8988:	8f 85       	ldd	r24, Y+15	; 0x0f
    898a:	88 2f       	mov	r24, r24
    898c:	90 e0       	ldi	r25, 0x00	; 0
    898e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    8990:	3c 8d       	ldd	r19, Y+28	; 0x1c
    8992:	82 0f       	add	r24, r18
    8994:	93 1f       	adc	r25, r19
    8996:	fc 01       	movw	r30, r24
    8998:	80 81       	ld	r24, Z
    899a:	48 17       	cp	r20, r24
    899c:	39 f4       	brne	.+14     	; 0x89ac <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    899e:	8f 85       	ldd	r24, Y+15	; 0x0f
    89a0:	8f 5f       	subi	r24, 0xFF	; 255
    89a2:	8f 87       	std	Y+15, r24	; 0x0f
    89a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    89a6:	8b 30       	cpi	r24, 0x0B	; 11
    89a8:	30 f3       	brcs	.-52     	; 0x8976 <findFiles+0xd2>
    89aa:	01 c0       	rjmp	.+2      	; 0x89ae <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    89ac:	00 00       	nop
            if(j == 11)
    89ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    89b0:	8b 30       	cpi	r24, 0x0B	; 11
    89b2:	09 f0       	breq	.+2      	; 0x89b6 <findFiles+0x112>
    89b4:	f2 c0       	rjmp	.+484    	; 0x8b9a <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    89b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    89b8:	81 30       	cpi	r24, 0x01	; 1
    89ba:	09 f0       	breq	.+2      	; 0x89be <findFiles+0x11a>
    89bc:	52 c0       	rjmp	.+164    	; 0x8a62 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    89be:	28 89       	ldd	r18, Y+16	; 0x10
    89c0:	39 89       	ldd	r19, Y+17	; 0x11
    89c2:	4a 89       	ldd	r20, Y+18	; 0x12
    89c4:	5b 89       	ldd	r21, Y+19	; 0x13
    89c6:	8d 81       	ldd	r24, Y+5	; 0x05
    89c8:	9e 81       	ldd	r25, Y+6	; 0x06
    89ca:	af 81       	ldd	r26, Y+7	; 0x07
    89cc:	b8 85       	ldd	r27, Y+8	; 0x08
    89ce:	82 0f       	add	r24, r18
    89d0:	93 1f       	adc	r25, r19
    89d2:	a4 1f       	adc	r26, r20
    89d4:	b5 1f       	adc	r27, r21
    89d6:	80 93 ce 50 	sts	0x50CE, r24
    89da:	90 93 cf 50 	sts	0x50CF, r25
    89de:	a0 93 d0 50 	sts	0x50D0, r26
    89e2:	b0 93 d1 50 	sts	0x50D1, r27
				appendFileLocation = i;
    89e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    89e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    89ea:	cc 01       	movw	r24, r24
    89ec:	a0 e0       	ldi	r26, 0x00	; 0
    89ee:	b0 e0       	ldi	r27, 0x00	; 0
    89f0:	80 93 d8 23 	sts	0x23D8, r24
    89f4:	90 93 d9 23 	sts	0x23D9, r25
    89f8:	a0 93 da 23 	sts	0x23DA, r26
    89fc:	b0 93 db 23 	sts	0x23DB, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a00:	8c 89       	ldd	r24, Y+20	; 0x14
    8a02:	9d 89       	ldd	r25, Y+21	; 0x15
    8a04:	fc 01       	movw	r30, r24
    8a06:	84 89       	ldd	r24, Z+20	; 0x14
    8a08:	95 89       	ldd	r25, Z+21	; 0x15
    8a0a:	cc 01       	movw	r24, r24
    8a0c:	a0 e0       	ldi	r26, 0x00	; 0
    8a0e:	b0 e0       	ldi	r27, 0x00	; 0
    8a10:	ac 01       	movw	r20, r24
    8a12:	33 27       	eor	r19, r19
    8a14:	22 27       	eor	r18, r18
    8a16:	8c 89       	ldd	r24, Y+20	; 0x14
    8a18:	9d 89       	ldd	r25, Y+21	; 0x15
    8a1a:	fc 01       	movw	r30, r24
    8a1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a1e:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a20:	cc 01       	movw	r24, r24
    8a22:	a0 e0       	ldi	r26, 0x00	; 0
    8a24:	b0 e0       	ldi	r27, 0x00	; 0
    8a26:	82 2b       	or	r24, r18
    8a28:	93 2b       	or	r25, r19
    8a2a:	a4 2b       	or	r26, r20
    8a2c:	b5 2b       	or	r27, r21
    8a2e:	80 93 84 50 	sts	0x5084, r24
    8a32:	90 93 85 50 	sts	0x5085, r25
    8a36:	a0 93 86 50 	sts	0x5086, r26
    8a3a:	b0 93 87 50 	sts	0x5087, r27
				fileSize = dir->fileSize;
    8a3e:	8c 89       	ldd	r24, Y+20	; 0x14
    8a40:	9d 89       	ldd	r25, Y+21	; 0x15
    8a42:	fc 01       	movw	r30, r24
    8a44:	84 8d       	ldd	r24, Z+28	; 0x1c
    8a46:	95 8d       	ldd	r25, Z+29	; 0x1d
    8a48:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8a4a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8a4c:	80 93 51 40 	sts	0x4051, r24
    8a50:	90 93 52 40 	sts	0x4052, r25
    8a54:	a0 93 53 40 	sts	0x4053, r26
    8a58:	b0 93 54 40 	sts	0x4054, r27
			    return (dir);
    8a5c:	8c 89       	ldd	r24, Y+20	; 0x14
    8a5e:	9d 89       	ldd	r25, Y+21	; 0x15
    8a60:	f3 c0       	rjmp	.+486    	; 0x8c48 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a62:	8c 89       	ldd	r24, Y+20	; 0x14
    8a64:	9d 89       	ldd	r25, Y+21	; 0x15
    8a66:	fc 01       	movw	r30, r24
    8a68:	84 89       	ldd	r24, Z+20	; 0x14
    8a6a:	95 89       	ldd	r25, Z+21	; 0x15
    8a6c:	cc 01       	movw	r24, r24
    8a6e:	a0 e0       	ldi	r26, 0x00	; 0
    8a70:	b0 e0       	ldi	r27, 0x00	; 0
    8a72:	ac 01       	movw	r20, r24
    8a74:	33 27       	eor	r19, r19
    8a76:	22 27       	eor	r18, r18
    8a78:	8c 89       	ldd	r24, Y+20	; 0x14
    8a7a:	9d 89       	ldd	r25, Y+21	; 0x15
    8a7c:	fc 01       	movw	r30, r24
    8a7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a80:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a82:	cc 01       	movw	r24, r24
    8a84:	a0 e0       	ldi	r26, 0x00	; 0
    8a86:	b0 e0       	ldi	r27, 0x00	; 0
    8a88:	82 2b       	or	r24, r18
    8a8a:	93 2b       	or	r25, r19
    8a8c:	a4 2b       	or	r26, r20
    8a8e:	b5 2b       	or	r27, r21
    8a90:	89 87       	std	Y+9, r24	; 0x09
    8a92:	9a 87       	std	Y+10, r25	; 0x0a
    8a94:	ab 87       	std	Y+11, r26	; 0x0b
    8a96:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8a98:	8c 89       	ldd	r24, Y+20	; 0x14
    8a9a:	9d 89       	ldd	r25, Y+21	; 0x15
    8a9c:	25 ee       	ldi	r18, 0xE5	; 229
    8a9e:	fc 01       	movw	r30, r24
    8aa0:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8aa2:	28 89       	ldd	r18, Y+16	; 0x10
    8aa4:	39 89       	ldd	r19, Y+17	; 0x11
    8aa6:	4a 89       	ldd	r20, Y+18	; 0x12
    8aa8:	5b 89       	ldd	r21, Y+19	; 0x13
    8aaa:	8d 81       	ldd	r24, Y+5	; 0x05
    8aac:	9e 81       	ldd	r25, Y+6	; 0x06
    8aae:	af 81       	ldd	r26, Y+7	; 0x07
    8ab0:	b8 85       	ldd	r27, Y+8	; 0x08
    8ab2:	82 0f       	add	r24, r18
    8ab4:	93 1f       	adc	r25, r19
    8ab6:	a4 1f       	adc	r26, r20
    8ab8:	b5 1f       	adc	r27, r21
    8aba:	27 ed       	ldi	r18, 0xD7	; 215
    8abc:	31 e2       	ldi	r19, 0x21	; 33
    8abe:	bc 01       	movw	r22, r24
    8ac0:	cd 01       	movw	r24, r26
    8ac2:	a9 01       	movw	r20, r18
    8ac4:	20 e0       	ldi	r18, 0x00	; 0
    8ac6:	32 e0       	ldi	r19, 0x02	; 2
    8ac8:	0e 94 23 50 	call	0xa046	; 0xa046 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8acc:	8c 89       	ldd	r24, Y+20	; 0x14
    8ace:	9d 89       	ldd	r25, Y+21	; 0x15
    8ad0:	fc 01       	movw	r30, r24
    8ad2:	24 8d       	ldd	r18, Z+28	; 0x1c
    8ad4:	35 8d       	ldd	r19, Z+29	; 0x1d
    8ad6:	46 8d       	ldd	r20, Z+30	; 0x1e
    8ad8:	57 8d       	ldd	r21, Z+31	; 0x1f
    8ada:	80 e0       	ldi	r24, 0x00	; 0
    8adc:	ba 01       	movw	r22, r20
    8ade:	a9 01       	movw	r20, r18
    8ae0:	0e 94 c0 4c 	call	0x9980	; 0x9980 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8ae4:	82 e0       	ldi	r24, 0x02	; 2
    8ae6:	60 e0       	ldi	r22, 0x00	; 0
    8ae8:	20 e0       	ldi	r18, 0x00	; 0
    8aea:	30 e0       	ldi	r19, 0x00	; 0
    8aec:	a9 01       	movw	r20, r18
    8aee:	0e 94 a1 43 	call	0x8742	; 0x8742 <getSetFreeCluster>
    8af2:	dc 01       	movw	r26, r24
    8af4:	cb 01       	movw	r24, r22
    8af6:	89 83       	std	Y+1, r24	; 0x01
    8af8:	9a 83       	std	Y+2, r25	; 0x02
    8afa:	ab 83       	std	Y+3, r26	; 0x03
    8afc:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8afe:	29 85       	ldd	r18, Y+9	; 0x09
    8b00:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b02:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b04:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b06:	89 81       	ldd	r24, Y+1	; 0x01
    8b08:	9a 81       	ldd	r25, Y+2	; 0x02
    8b0a:	ab 81       	ldd	r26, Y+3	; 0x03
    8b0c:	bc 81       	ldd	r27, Y+4	; 0x04
    8b0e:	28 17       	cp	r18, r24
    8b10:	39 07       	cpc	r19, r25
    8b12:	4a 07       	cpc	r20, r26
    8b14:	5b 07       	cpc	r21, r27
    8b16:	40 f4       	brcc	.+16     	; 0x8b28 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    8b18:	29 85       	ldd	r18, Y+9	; 0x09
    8b1a:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b1c:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b1e:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b20:	82 e0       	ldi	r24, 0x02	; 2
    8b22:	61 e0       	ldi	r22, 0x01	; 1
    8b24:	0e 94 a1 43 	call	0x8742	; 0x8742 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    8b28:	89 85       	ldd	r24, Y+9	; 0x09
    8b2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b2c:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b2e:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b30:	bc 01       	movw	r22, r24
    8b32:	cd 01       	movw	r24, r26
    8b34:	40 e0       	ldi	r20, 0x00	; 0
    8b36:	00 e0       	ldi	r16, 0x00	; 0
    8b38:	10 e0       	ldi	r17, 0x00	; 0
    8b3a:	98 01       	movw	r18, r16
    8b3c:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
    8b40:	dc 01       	movw	r26, r24
    8b42:	cb 01       	movw	r24, r22
    8b44:	8e 8b       	std	Y+22, r24	; 0x16
    8b46:	9f 8b       	std	Y+23, r25	; 0x17
    8b48:	a8 8f       	std	Y+24, r26	; 0x18
    8b4a:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8b4c:	89 85       	ldd	r24, Y+9	; 0x09
    8b4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b50:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b52:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b54:	bc 01       	movw	r22, r24
    8b56:	cd 01       	movw	r24, r26
    8b58:	41 e0       	ldi	r20, 0x01	; 1
    8b5a:	00 e0       	ldi	r16, 0x00	; 0
    8b5c:	10 e0       	ldi	r17, 0x00	; 0
    8b5e:	98 01       	movw	r18, r16
    8b60:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8b64:	8e 89       	ldd	r24, Y+22	; 0x16
    8b66:	9f 89       	ldd	r25, Y+23	; 0x17
    8b68:	a8 8d       	ldd	r26, Y+24	; 0x18
    8b6a:	b9 8d       	ldd	r27, Y+25	; 0x19
    8b6c:	87 3f       	cpi	r24, 0xF7	; 247
    8b6e:	ff ef       	ldi	r31, 0xFF	; 255
    8b70:	9f 07       	cpc	r25, r31
    8b72:	ff ef       	ldi	r31, 0xFF	; 255
    8b74:	af 07       	cpc	r26, r31
    8b76:	ff e0       	ldi	r31, 0x0F	; 15
    8b78:	bf 07       	cpc	r27, r31
    8b7a:	18 f0       	brcs	.+6      	; 0x8b82 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    8b7c:	80 e0       	ldi	r24, 0x00	; 0
    8b7e:	90 e0       	ldi	r25, 0x00	; 0
    8b80:	63 c0       	rjmp	.+198    	; 0x8c48 <findFiles+0x3a4>
					firstCluster = nextCluster;
    8b82:	8e 89       	ldd	r24, Y+22	; 0x16
    8b84:	9f 89       	ldd	r25, Y+23	; 0x17
    8b86:	a8 8d       	ldd	r26, Y+24	; 0x18
    8b88:	b9 8d       	ldd	r27, Y+25	; 0x19
    8b8a:	89 87       	std	Y+9, r24	; 0x09
    8b8c:	9a 87       	std	Y+10, r25	; 0x0a
    8b8e:	ab 87       	std	Y+11, r26	; 0x0b
    8b90:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8b92:	ca cf       	rjmp	.-108    	; 0x8b28 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8b94:	80 e0       	ldi	r24, 0x00	; 0
    8b96:	90 e0       	ldi	r25, 0x00	; 0
    8b98:	57 c0       	rjmp	.+174    	; 0x8c48 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8b9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    8b9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    8b9e:	80 96       	adiw	r24, 0x20	; 32
    8ba0:	8d 87       	std	Y+13, r24	; 0x0d
    8ba2:	9e 87       	std	Y+14, r25	; 0x0e
    8ba4:	80 91 55 40 	lds	r24, 0x4055
    8ba8:	90 91 56 40 	lds	r25, 0x4056
    8bac:	2d 85       	ldd	r18, Y+13	; 0x0d
    8bae:	3e 85       	ldd	r19, Y+14	; 0x0e
    8bb0:	28 17       	cp	r18, r24
    8bb2:	39 07       	cpc	r19, r25
    8bb4:	08 f4       	brcc	.+2      	; 0x8bb8 <findFiles+0x314>
    8bb6:	b9 ce       	rjmp	.-654    	; 0x892a <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8bb8:	8d 81       	ldd	r24, Y+5	; 0x05
    8bba:	9e 81       	ldd	r25, Y+6	; 0x06
    8bbc:	af 81       	ldd	r26, Y+7	; 0x07
    8bbe:	b8 85       	ldd	r27, Y+8	; 0x08
    8bc0:	01 96       	adiw	r24, 0x01	; 1
    8bc2:	a1 1d       	adc	r26, r1
    8bc4:	b1 1d       	adc	r27, r1
    8bc6:	8d 83       	std	Y+5, r24	; 0x05
    8bc8:	9e 83       	std	Y+6, r25	; 0x06
    8bca:	af 83       	std	Y+7, r26	; 0x07
    8bcc:	b8 87       	std	Y+8, r27	; 0x08
    8bce:	80 91 78 50 	lds	r24, 0x5078
    8bd2:	90 91 79 50 	lds	r25, 0x5079
    8bd6:	9c 01       	movw	r18, r24
    8bd8:	40 e0       	ldi	r20, 0x00	; 0
    8bda:	50 e0       	ldi	r21, 0x00	; 0
    8bdc:	8d 81       	ldd	r24, Y+5	; 0x05
    8bde:	9e 81       	ldd	r25, Y+6	; 0x06
    8be0:	af 81       	ldd	r26, Y+7	; 0x07
    8be2:	b8 85       	ldd	r27, Y+8	; 0x08
    8be4:	82 17       	cp	r24, r18
    8be6:	93 07       	cpc	r25, r19
    8be8:	a4 07       	cpc	r26, r20
    8bea:	b5 07       	cpc	r27, r21
    8bec:	08 f4       	brcc	.+2      	; 0x8bf0 <findFiles+0x34c>
    8bee:	87 ce       	rjmp	.-754    	; 0x88fe <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8bf0:	89 81       	ldd	r24, Y+1	; 0x01
    8bf2:	9a 81       	ldd	r25, Y+2	; 0x02
    8bf4:	ab 81       	ldd	r26, Y+3	; 0x03
    8bf6:	bc 81       	ldd	r27, Y+4	; 0x04
    8bf8:	bc 01       	movw	r22, r24
    8bfa:	cd 01       	movw	r24, r26
    8bfc:	40 e0       	ldi	r20, 0x00	; 0
    8bfe:	00 e0       	ldi	r16, 0x00	; 0
    8c00:	10 e0       	ldi	r17, 0x00	; 0
    8c02:	98 01       	movw	r18, r16
    8c04:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
    8c08:	dc 01       	movw	r26, r24
    8c0a:	cb 01       	movw	r24, r22
    8c0c:	89 83       	std	Y+1, r24	; 0x01
    8c0e:	9a 83       	std	Y+2, r25	; 0x02
    8c10:	ab 83       	std	Y+3, r26	; 0x03
    8c12:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8c14:	89 81       	ldd	r24, Y+1	; 0x01
    8c16:	9a 81       	ldd	r25, Y+2	; 0x02
    8c18:	ab 81       	ldd	r26, Y+3	; 0x03
    8c1a:	bc 81       	ldd	r27, Y+4	; 0x04
    8c1c:	87 3f       	cpi	r24, 0xF7	; 247
    8c1e:	2f ef       	ldi	r18, 0xFF	; 255
    8c20:	92 07       	cpc	r25, r18
    8c22:	2f ef       	ldi	r18, 0xFF	; 255
    8c24:	a2 07       	cpc	r26, r18
    8c26:	2f e0       	ldi	r18, 0x0F	; 15
    8c28:	b2 07       	cpc	r27, r18
    8c2a:	18 f0       	brcs	.+6      	; 0x8c32 <findFiles+0x38e>
   	 return 0;
    8c2c:	80 e0       	ldi	r24, 0x00	; 0
    8c2e:	90 e0       	ldi	r25, 0x00	; 0
    8c30:	0b c0       	rjmp	.+22     	; 0x8c48 <findFiles+0x3a4>
   if(cluster == 0) 
    8c32:	89 81       	ldd	r24, Y+1	; 0x01
    8c34:	9a 81       	ldd	r25, Y+2	; 0x02
    8c36:	ab 81       	ldd	r26, Y+3	; 0x03
    8c38:	bc 81       	ldd	r27, Y+4	; 0x04
    8c3a:	00 97       	sbiw	r24, 0x00	; 0
    8c3c:	a1 05       	cpc	r26, r1
    8c3e:	b1 05       	cpc	r27, r1
    8c40:	09 f0       	breq	.+2      	; 0x8c44 <findFiles+0x3a0>
    8c42:	49 ce       	rjmp	.-878    	; 0x88d6 <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8c44:	80 e0       	ldi	r24, 0x00	; 0
    8c46:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    8c48:	6c 96       	adiw	r28, 0x1c	; 28
    8c4a:	cd bf       	out	0x3d, r28	; 61
    8c4c:	de bf       	out	0x3e, r29	; 62
    8c4e:	df 91       	pop	r29
    8c50:	cf 91       	pop	r28
    8c52:	1f 91       	pop	r17
    8c54:	0f 91       	pop	r16
    8c56:	08 95       	ret

00008c58 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    8c58:	0f 93       	push	r16
    8c5a:	1f 93       	push	r17
    8c5c:	cf 93       	push	r28
    8c5e:	df 93       	push	r29
    8c60:	cd b7       	in	r28, 0x3d	; 61
    8c62:	de b7       	in	r29, 0x3e	; 62
    8c64:	67 97       	sbiw	r28, 0x17	; 23
    8c66:	cd bf       	out	0x3d, r28	; 61
    8c68:	de bf       	out	0x3e, r29	; 62
    8c6a:	8d 8b       	std	Y+21, r24	; 0x15
    8c6c:	6e 8b       	std	Y+22, r22	; 0x16
    8c6e:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8c70:	1e 82       	std	Y+6, r1	; 0x06
    8c72:	1f 82       	std	Y+7, r1	; 0x07
    8c74:	18 86       	std	Y+8, r1	; 0x08
    8c76:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8c78:	8e 89       	ldd	r24, Y+22	; 0x16
    8c7a:	9f 89       	ldd	r25, Y+23	; 0x17
    8c7c:	0e 94 db 46 	call	0x8db6	; 0x8db6 <convertFileName>
    8c80:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8c82:	8a 85       	ldd	r24, Y+10	; 0x0a
    8c84:	88 23       	and	r24, r24
    8c86:	11 f0       	breq	.+4      	; 0x8c8c <readFile+0x34>
    8c88:	82 e0       	ldi	r24, 0x02	; 2
    8c8a:	8d c0       	rjmp	.+282    	; 0x8da6 <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    8c8c:	28 eb       	ldi	r18, 0xB8	; 184
    8c8e:	30 e5       	ldi	r19, 0x50	; 80
    8c90:	81 e0       	ldi	r24, 0x01	; 1
    8c92:	b9 01       	movw	r22, r18
    8c94:	0e 94 52 44 	call	0x88a4	; 0x88a4 <findFiles>
    8c98:	8b 87       	std	Y+11, r24	; 0x0b
    8c9a:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    8c9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    8c9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    8ca0:	00 97       	sbiw	r24, 0x00	; 0
    8ca2:	39 f4       	brne	.+14     	; 0x8cb2 <readFile+0x5a>
{
  if(flag == READ) return (1);
    8ca4:	8d 89       	ldd	r24, Y+21	; 0x15
    8ca6:	88 23       	and	r24, r24
    8ca8:	11 f4       	brne	.+4      	; 0x8cae <readFile+0x56>
    8caa:	81 e0       	ldi	r24, 0x01	; 1
    8cac:	7c c0       	rjmp	.+248    	; 0x8da6 <readFile+0x14e>
  else return (0);
    8cae:	80 e0       	ldi	r24, 0x00	; 0
    8cb0:	7a c0       	rjmp	.+244    	; 0x8da6 <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8cb2:	8d 89       	ldd	r24, Y+21	; 0x15
    8cb4:	81 30       	cpi	r24, 0x01	; 1
    8cb6:	11 f4       	brne	.+4      	; 0x8cbc <readFile+0x64>
    8cb8:	81 e0       	ldi	r24, 0x01	; 1
    8cba:	75 c0       	rjmp	.+234    	; 0x8da6 <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8cbc:	8b 85       	ldd	r24, Y+11	; 0x0b
    8cbe:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cc0:	fc 01       	movw	r30, r24
    8cc2:	84 89       	ldd	r24, Z+20	; 0x14
    8cc4:	95 89       	ldd	r25, Z+21	; 0x15
    8cc6:	cc 01       	movw	r24, r24
    8cc8:	a0 e0       	ldi	r26, 0x00	; 0
    8cca:	b0 e0       	ldi	r27, 0x00	; 0
    8ccc:	ac 01       	movw	r20, r24
    8cce:	33 27       	eor	r19, r19
    8cd0:	22 27       	eor	r18, r18
    8cd2:	8b 85       	ldd	r24, Y+11	; 0x0b
    8cd4:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cd6:	fc 01       	movw	r30, r24
    8cd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    8cda:	93 8d       	ldd	r25, Z+27	; 0x1b
    8cdc:	cc 01       	movw	r24, r24
    8cde:	a0 e0       	ldi	r26, 0x00	; 0
    8ce0:	b0 e0       	ldi	r27, 0x00	; 0
    8ce2:	82 2b       	or	r24, r18
    8ce4:	93 2b       	or	r25, r19
    8ce6:	a4 2b       	or	r26, r20
    8ce8:	b5 2b       	or	r27, r21
    8cea:	89 83       	std	Y+1, r24	; 0x01
    8cec:	9a 83       	std	Y+2, r25	; 0x02
    8cee:	ab 83       	std	Y+3, r26	; 0x03
    8cf0:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    8cf2:	8b 85       	ldd	r24, Y+11	; 0x0b
    8cf4:	9c 85       	ldd	r25, Y+12	; 0x0c
    8cf6:	fc 01       	movw	r30, r24
    8cf8:	84 8d       	ldd	r24, Z+28	; 0x1c
    8cfa:	95 8d       	ldd	r25, Z+29	; 0x1d
    8cfc:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8cfe:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8d00:	8d 87       	std	Y+13, r24	; 0x0d
    8d02:	9e 87       	std	Y+14, r25	; 0x0e
    8d04:	af 87       	std	Y+15, r26	; 0x0f
    8d06:	b8 8b       	std	Y+16, r27	; 0x10
    8d08:	01 c0       	rjmp	.+2      	; 0x8d0c <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8d0a:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8d0c:	89 81       	ldd	r24, Y+1	; 0x01
    8d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    8d10:	ab 81       	ldd	r26, Y+3	; 0x03
    8d12:	bc 81       	ldd	r27, Y+4	; 0x04
    8d14:	bc 01       	movw	r22, r24
    8d16:	cd 01       	movw	r24, r26
    8d18:	0e 94 c5 42 	call	0x858a	; 0x858a <getFirstSector>
    8d1c:	dc 01       	movw	r26, r24
    8d1e:	cb 01       	movw	r24, r22
    8d20:	89 8b       	std	Y+17, r24	; 0x11
    8d22:	9a 8b       	std	Y+18, r25	; 0x12
    8d24:	ab 8b       	std	Y+19, r26	; 0x13
    8d26:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    8d28:	1d 82       	std	Y+5, r1	; 0x05
    8d2a:	17 c0       	rjmp	.+46     	; 0x8d5a <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8d2c:	8d 81       	ldd	r24, Y+5	; 0x05
    8d2e:	28 2f       	mov	r18, r24
    8d30:	30 e0       	ldi	r19, 0x00	; 0
    8d32:	40 e0       	ldi	r20, 0x00	; 0
    8d34:	50 e0       	ldi	r21, 0x00	; 0
    8d36:	89 89       	ldd	r24, Y+17	; 0x11
    8d38:	9a 89       	ldd	r25, Y+18	; 0x12
    8d3a:	ab 89       	ldd	r26, Y+19	; 0x13
    8d3c:	bc 89       	ldd	r27, Y+20	; 0x14
    8d3e:	82 0f       	add	r24, r18
    8d40:	93 1f       	adc	r25, r19
    8d42:	a4 1f       	adc	r26, r20
    8d44:	b5 1f       	adc	r27, r21
    8d46:	20 ee       	ldi	r18, 0xE0	; 224
    8d48:	33 e2       	ldi	r19, 0x23	; 35
    8d4a:	bc 01       	movw	r22, r24
    8d4c:	cd 01       	movw	r24, r26
    8d4e:	a9 01       	movw	r20, r18
    8d50:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8d54:	8d 81       	ldd	r24, Y+5	; 0x05
    8d56:	8f 5f       	subi	r24, 0xFF	; 255
    8d58:	8d 83       	std	Y+5, r24	; 0x05
    8d5a:	8d 81       	ldd	r24, Y+5	; 0x05
    8d5c:	28 2f       	mov	r18, r24
    8d5e:	30 e0       	ldi	r19, 0x00	; 0
    8d60:	80 91 78 50 	lds	r24, 0x5078
    8d64:	90 91 79 50 	lds	r25, 0x5079
    8d68:	28 17       	cp	r18, r24
    8d6a:	39 07       	cpc	r19, r25
    8d6c:	f8 f2       	brcs	.-66     	; 0x8d2c <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8d6e:	89 81       	ldd	r24, Y+1	; 0x01
    8d70:	9a 81       	ldd	r25, Y+2	; 0x02
    8d72:	ab 81       	ldd	r26, Y+3	; 0x03
    8d74:	bc 81       	ldd	r27, Y+4	; 0x04
    8d76:	bc 01       	movw	r22, r24
    8d78:	cd 01       	movw	r24, r26
    8d7a:	40 e0       	ldi	r20, 0x00	; 0
    8d7c:	00 e0       	ldi	r16, 0x00	; 0
    8d7e:	10 e0       	ldi	r17, 0x00	; 0
    8d80:	98 01       	movw	r18, r16
    8d82:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
    8d86:	dc 01       	movw	r26, r24
    8d88:	cb 01       	movw	r24, r22
    8d8a:	89 83       	std	Y+1, r24	; 0x01
    8d8c:	9a 83       	std	Y+2, r25	; 0x02
    8d8e:	ab 83       	std	Y+3, r26	; 0x03
    8d90:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8d92:	89 81       	ldd	r24, Y+1	; 0x01
    8d94:	9a 81       	ldd	r25, Y+2	; 0x02
    8d96:	ab 81       	ldd	r26, Y+3	; 0x03
    8d98:	bc 81       	ldd	r27, Y+4	; 0x04
    8d9a:	00 97       	sbiw	r24, 0x00	; 0
    8d9c:	a1 05       	cpc	r26, r1
    8d9e:	b1 05       	cpc	r27, r1
    8da0:	09 f0       	breq	.+2      	; 0x8da4 <readFile+0x14c>
    8da2:	b3 cf       	rjmp	.-154    	; 0x8d0a <readFile+0xb2>
	  return 0;}
    8da4:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8da6:	67 96       	adiw	r28, 0x17	; 23
    8da8:	cd bf       	out	0x3d, r28	; 61
    8daa:	de bf       	out	0x3e, r29	; 62
    8dac:	df 91       	pop	r29
    8dae:	cf 91       	pop	r28
    8db0:	1f 91       	pop	r17
    8db2:	0f 91       	pop	r16
    8db4:	08 95       	ret

00008db6 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8db6:	cf 93       	push	r28
    8db8:	df 93       	push	r29
    8dba:	cd b7       	in	r28, 0x3d	; 61
    8dbc:	de b7       	in	r29, 0x3e	; 62
    8dbe:	62 97       	sbiw	r28, 0x12	; 18
    8dc0:	cd bf       	out	0x3d, r28	; 61
    8dc2:	de bf       	out	0x3e, r29	; 62
    8dc4:	89 8b       	std	Y+17, r24	; 0x11
    8dc6:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8dc8:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    8dca:	89 89       	ldd	r24, Y+17	; 0x11
    8dcc:	9a 89       	ldd	r25, Y+18	; 0x12
    8dce:	9c 01       	movw	r18, r24
    8dd0:	f9 01       	movw	r30, r18
    8dd2:	01 90       	ld	r0, Z+
    8dd4:	00 20       	and	r0, r0
    8dd6:	e9 f7       	brne	.-6      	; 0x8dd2 <convertFileName+0x1c>
    8dd8:	cf 01       	movw	r24, r30
    8dda:	01 97       	sbiw	r24, 0x01	; 1
    8ddc:	82 1b       	sub	r24, r18
    8dde:	93 0b       	sbc	r25, r19
    8de0:	80 31       	cpi	r24, 0x10	; 16
    8de2:	91 05       	cpc	r25, r1
    8de4:	10 f0       	brcs	.+4      	; 0x8dea <convertFileName+0x34>
    8de6:	81 e0       	ldi	r24, 0x01	; 1
    8de8:	16 c1       	rjmp	.+556    	; 0x9016 <convertFileName+0x260>
int i=0;
    8dea:	1c 82       	std	Y+4, r1	; 0x04
    8dec:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    8dee:	13 c0       	rjmp	.+38     	; 0x8e16 <convertFileName+0x60>
	Filename[i] = fileName[i];
    8df0:	8c 81       	ldd	r24, Y+4	; 0x04
    8df2:	9d 81       	ldd	r25, Y+5	; 0x05
    8df4:	29 89       	ldd	r18, Y+17	; 0x11
    8df6:	3a 89       	ldd	r19, Y+18	; 0x12
    8df8:	82 0f       	add	r24, r18
    8dfa:	93 1f       	adc	r25, r19
    8dfc:	fc 01       	movw	r30, r24
    8dfe:	20 81       	ld	r18, Z
    8e00:	8c 81       	ldd	r24, Y+4	; 0x04
    8e02:	9d 81       	ldd	r25, Y+5	; 0x05
    8e04:	88 54       	subi	r24, 0x48	; 72
    8e06:	9f 4a       	sbci	r25, 0xAF	; 175
    8e08:	fc 01       	movw	r30, r24
    8e0a:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    8e0c:	8c 81       	ldd	r24, Y+4	; 0x04
    8e0e:	9d 81       	ldd	r25, Y+5	; 0x05
    8e10:	01 96       	adiw	r24, 0x01	; 1
    8e12:	8c 83       	std	Y+4, r24	; 0x04
    8e14:	9d 83       	std	Y+5, r25	; 0x05
    8e16:	4c 81       	ldd	r20, Y+4	; 0x04
    8e18:	5d 81       	ldd	r21, Y+5	; 0x05
    8e1a:	89 89       	ldd	r24, Y+17	; 0x11
    8e1c:	9a 89       	ldd	r25, Y+18	; 0x12
    8e1e:	9c 01       	movw	r18, r24
    8e20:	f9 01       	movw	r30, r18
    8e22:	01 90       	ld	r0, Z+
    8e24:	00 20       	and	r0, r0
    8e26:	e9 f7       	brne	.-6      	; 0x8e22 <convertFileName+0x6c>
    8e28:	cf 01       	movw	r24, r30
    8e2a:	01 97       	sbiw	r24, 0x01	; 1
    8e2c:	82 1b       	sub	r24, r18
    8e2e:	93 0b       	sbc	r25, r19
    8e30:	48 17       	cp	r20, r24
    8e32:	59 07       	cpc	r21, r25
    8e34:	e8 f2       	brcs	.-70     	; 0x8df0 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8e36:	0c c0       	rjmp	.+24     	; 0x8e50 <convertFileName+0x9a>
    8e38:	8c 81       	ldd	r24, Y+4	; 0x04
    8e3a:	9d 81       	ldd	r25, Y+5	; 0x05
    8e3c:	88 54       	subi	r24, 0x48	; 72
    8e3e:	9f 4a       	sbci	r25, 0xAF	; 175
    8e40:	20 e2       	ldi	r18, 0x20	; 32
    8e42:	fc 01       	movw	r30, r24
    8e44:	20 83       	st	Z, r18
    8e46:	8c 81       	ldd	r24, Y+4	; 0x04
    8e48:	9d 81       	ldd	r25, Y+5	; 0x05
    8e4a:	01 96       	adiw	r24, 0x01	; 1
    8e4c:	8c 83       	std	Y+4, r24	; 0x04
    8e4e:	9d 83       	std	Y+5, r25	; 0x05
    8e50:	8c 81       	ldd	r24, Y+4	; 0x04
    8e52:	9d 81       	ldd	r25, Y+5	; 0x05
    8e54:	8f 30       	cpi	r24, 0x0F	; 15
    8e56:	91 05       	cpc	r25, r1
    8e58:	7c f3       	brlt	.-34     	; 0x8e38 <convertFileName+0x82>


for(j=0; j<12; j++)
    8e5a:	1a 82       	std	Y+2, r1	; 0x02
    8e5c:	0c c0       	rjmp	.+24     	; 0x8e76 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    8e60:	88 2f       	mov	r24, r24
    8e62:	90 e0       	ldi	r25, 0x00	; 0
    8e64:	88 54       	subi	r24, 0x48	; 72
    8e66:	9f 4a       	sbci	r25, 0xAF	; 175
    8e68:	fc 01       	movw	r30, r24
    8e6a:	80 81       	ld	r24, Z
    8e6c:	8e 32       	cpi	r24, 0x2E	; 46
    8e6e:	39 f0       	breq	.+14     	; 0x8e7e <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8e70:	8a 81       	ldd	r24, Y+2	; 0x02
    8e72:	8f 5f       	subi	r24, 0xFF	; 255
    8e74:	8a 83       	std	Y+2, r24	; 0x02
    8e76:	8a 81       	ldd	r24, Y+2	; 0x02
    8e78:	8c 30       	cpi	r24, 0x0C	; 12
    8e7a:	88 f3       	brcs	.-30     	; 0x8e5e <convertFileName+0xa8>
    8e7c:	01 c0       	rjmp	.+2      	; 0x8e80 <convertFileName+0xca>
if(Filename[j] == '.') break;
    8e7e:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8e80:	8a 81       	ldd	r24, Y+2	; 0x02
    8e82:	89 30       	cpi	r24, 0x09	; 9
    8e84:	28 f0       	brcs	.+10     	; 0x8e90 <convertFileName+0xda>
    8e86:	8a 81       	ldd	r24, Y+2	; 0x02
    8e88:	8c 30       	cpi	r24, 0x0C	; 12
    8e8a:	10 f4       	brcc	.+4      	; 0x8e90 <convertFileName+0xda>
	return 1;}
    8e8c:	81 e0       	ldi	r24, 0x01	; 1
    8e8e:	c3 c0       	rjmp	.+390    	; 0x9016 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8e90:	8a 81       	ldd	r24, Y+2	; 0x02
    8e92:	8c 30       	cpi	r24, 0x0C	; 12
    8e94:	11 f4       	brne	.+4      	; 0x8e9a <convertFileName+0xe4>
    8e96:	81 e0       	ldi	r24, 0x01	; 1
    8e98:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8e9a:	1b 82       	std	Y+3, r1	; 0x03
    8e9c:	14 c0       	rjmp	.+40     	; 0x8ec6 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    8ea0:	88 2f       	mov	r24, r24
    8ea2:	90 e0       	ldi	r25, 0x00	; 0
    8ea4:	2b 81       	ldd	r18, Y+3	; 0x03
    8ea6:	22 2f       	mov	r18, r18
    8ea8:	30 e0       	ldi	r19, 0x00	; 0
    8eaa:	28 54       	subi	r18, 0x48	; 72
    8eac:	3f 4a       	sbci	r19, 0xAF	; 175
    8eae:	f9 01       	movw	r30, r18
    8eb0:	40 81       	ld	r20, Z
    8eb2:	9e 01       	movw	r18, r28
    8eb4:	2a 5f       	subi	r18, 0xFA	; 250
    8eb6:	3f 4f       	sbci	r19, 0xFF	; 255
    8eb8:	82 0f       	add	r24, r18
    8eba:	93 1f       	adc	r25, r19
    8ebc:	fc 01       	movw	r30, r24
    8ebe:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    8ec2:	8f 5f       	subi	r24, 0xFF	; 255
    8ec4:	8b 83       	std	Y+3, r24	; 0x03
    8ec6:	9b 81       	ldd	r25, Y+3	; 0x03
    8ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    8eca:	98 17       	cp	r25, r24
    8ecc:	40 f3       	brcs	.-48     	; 0x8e9e <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8ece:	8a 81       	ldd	r24, Y+2	; 0x02
    8ed0:	8b 83       	std	Y+3, r24	; 0x03
    8ed2:	0e c0       	rjmp	.+28     	; 0x8ef0 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    8ed6:	88 2f       	mov	r24, r24
    8ed8:	90 e0       	ldi	r25, 0x00	; 0
    8eda:	9e 01       	movw	r18, r28
    8edc:	2a 5f       	subi	r18, 0xFA	; 250
    8ede:	3f 4f       	sbci	r19, 0xFF	; 255
    8ee0:	82 0f       	add	r24, r18
    8ee2:	93 1f       	adc	r25, r19
    8ee4:	20 e2       	ldi	r18, 0x20	; 32
    8ee6:	fc 01       	movw	r30, r24
    8ee8:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8eea:	8b 81       	ldd	r24, Y+3	; 0x03
    8eec:	8f 5f       	subi	r24, 0xFF	; 255
    8eee:	8b 83       	std	Y+3, r24	; 0x03
    8ef0:	8b 81       	ldd	r24, Y+3	; 0x03
    8ef2:	88 30       	cpi	r24, 0x08	; 8
    8ef4:	78 f3       	brcs	.-34     	; 0x8ed4 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8ef6:	99 81       	ldd	r25, Y+1	; 0x01
    8ef8:	81 e0       	ldi	r24, 0x01	; 1
    8efa:	89 27       	eor	r24, r25
    8efc:	88 23       	and	r24, r24
    8efe:	19 f0       	breq	.+6      	; 0x8f06 <convertFileName+0x150>
    8f00:	8a 81       	ldd	r24, Y+2	; 0x02
    8f02:	8f 5f       	subi	r24, 0xFF	; 255
    8f04:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8f06:	88 e0       	ldi	r24, 0x08	; 8
    8f08:	8b 83       	std	Y+3, r24	; 0x03
    8f0a:	32 c0       	rjmp	.+100    	; 0x8f70 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8f0c:	8a 81       	ldd	r24, Y+2	; 0x02
    8f0e:	88 2f       	mov	r24, r24
    8f10:	90 e0       	ldi	r25, 0x00	; 0
    8f12:	88 54       	subi	r24, 0x48	; 72
    8f14:	9f 4a       	sbci	r25, 0xAF	; 175
    8f16:	fc 01       	movw	r30, r24
    8f18:	80 81       	ld	r24, Z
    8f1a:	88 23       	and	r24, r24
    8f1c:	19 f1       	breq	.+70     	; 0x8f64 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    8f20:	88 2f       	mov	r24, r24
    8f22:	90 e0       	ldi	r25, 0x00	; 0
    8f24:	2a 81       	ldd	r18, Y+2	; 0x02
    8f26:	22 2f       	mov	r18, r18
    8f28:	30 e0       	ldi	r19, 0x00	; 0
    8f2a:	28 54       	subi	r18, 0x48	; 72
    8f2c:	3f 4a       	sbci	r19, 0xAF	; 175
    8f2e:	f9 01       	movw	r30, r18
    8f30:	40 81       	ld	r20, Z
    8f32:	9e 01       	movw	r18, r28
    8f34:	2a 5f       	subi	r18, 0xFA	; 250
    8f36:	3f 4f       	sbci	r19, 0xFF	; 255
    8f38:	82 0f       	add	r24, r18
    8f3a:	93 1f       	adc	r25, r19
    8f3c:	fc 01       	movw	r30, r24
    8f3e:	40 83       	st	Z, r20
    8f40:	8a 81       	ldd	r24, Y+2	; 0x02
    8f42:	8f 5f       	subi	r24, 0xFF	; 255
    8f44:	8a 83       	std	Y+2, r24	; 0x02
    8f46:	11 c0       	rjmp	.+34     	; 0x8f6a <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8f48:	8b 81       	ldd	r24, Y+3	; 0x03
    8f4a:	88 2f       	mov	r24, r24
    8f4c:	90 e0       	ldi	r25, 0x00	; 0
    8f4e:	9e 01       	movw	r18, r28
    8f50:	2a 5f       	subi	r18, 0xFA	; 250
    8f52:	3f 4f       	sbci	r19, 0xFF	; 255
    8f54:	82 0f       	add	r24, r18
    8f56:	93 1f       	adc	r25, r19
    8f58:	20 e2       	ldi	r18, 0x20	; 32
    8f5a:	fc 01       	movw	r30, r24
    8f5c:	20 83       	st	Z, r18
    8f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    8f60:	8f 5f       	subi	r24, 0xFF	; 255
    8f62:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8f64:	8b 81       	ldd	r24, Y+3	; 0x03
    8f66:	8b 30       	cpi	r24, 0x0B	; 11
    8f68:	78 f3       	brcs	.-34     	; 0x8f48 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8f6a:	8b 81       	ldd	r24, Y+3	; 0x03
    8f6c:	8f 5f       	subi	r24, 0xFF	; 255
    8f6e:	8b 83       	std	Y+3, r24	; 0x03
    8f70:	8b 81       	ldd	r24, Y+3	; 0x03
    8f72:	8b 30       	cpi	r24, 0x0B	; 11
    8f74:	58 f2       	brcs	.-106    	; 0x8f0c <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8f76:	1a 82       	std	Y+2, r1	; 0x02
    8f78:	31 c0       	rjmp	.+98     	; 0x8fdc <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8f7a:	8a 81       	ldd	r24, Y+2	; 0x02
    8f7c:	88 2f       	mov	r24, r24
    8f7e:	90 e0       	ldi	r25, 0x00	; 0
    8f80:	9e 01       	movw	r18, r28
    8f82:	2a 5f       	subi	r18, 0xFA	; 250
    8f84:	3f 4f       	sbci	r19, 0xFF	; 255
    8f86:	82 0f       	add	r24, r18
    8f88:	93 1f       	adc	r25, r19
    8f8a:	fc 01       	movw	r30, r24
    8f8c:	80 81       	ld	r24, Z
    8f8e:	81 36       	cpi	r24, 0x61	; 97
    8f90:	10 f1       	brcs	.+68     	; 0x8fd6 <convertFileName+0x220>
    8f92:	8a 81       	ldd	r24, Y+2	; 0x02
    8f94:	88 2f       	mov	r24, r24
    8f96:	90 e0       	ldi	r25, 0x00	; 0
    8f98:	9e 01       	movw	r18, r28
    8f9a:	2a 5f       	subi	r18, 0xFA	; 250
    8f9c:	3f 4f       	sbci	r19, 0xFF	; 255
    8f9e:	82 0f       	add	r24, r18
    8fa0:	93 1f       	adc	r25, r19
    8fa2:	fc 01       	movw	r30, r24
    8fa4:	80 81       	ld	r24, Z
    8fa6:	8b 37       	cpi	r24, 0x7B	; 123
    8fa8:	b0 f4       	brcc	.+44     	; 0x8fd6 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8faa:	8a 81       	ldd	r24, Y+2	; 0x02
    8fac:	88 2f       	mov	r24, r24
    8fae:	90 e0       	ldi	r25, 0x00	; 0
    8fb0:	2a 81       	ldd	r18, Y+2	; 0x02
    8fb2:	22 2f       	mov	r18, r18
    8fb4:	30 e0       	ldi	r19, 0x00	; 0
    8fb6:	ae 01       	movw	r20, r28
    8fb8:	4a 5f       	subi	r20, 0xFA	; 250
    8fba:	5f 4f       	sbci	r21, 0xFF	; 255
    8fbc:	24 0f       	add	r18, r20
    8fbe:	35 1f       	adc	r19, r21
    8fc0:	f9 01       	movw	r30, r18
    8fc2:	20 81       	ld	r18, Z
    8fc4:	42 2f       	mov	r20, r18
    8fc6:	40 52       	subi	r20, 0x20	; 32
    8fc8:	9e 01       	movw	r18, r28
    8fca:	2a 5f       	subi	r18, 0xFA	; 250
    8fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    8fce:	82 0f       	add	r24, r18
    8fd0:	93 1f       	adc	r25, r19
    8fd2:	fc 01       	movw	r30, r24
    8fd4:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8fd6:	8a 81       	ldd	r24, Y+2	; 0x02
    8fd8:	8f 5f       	subi	r24, 0xFF	; 255
    8fda:	8a 83       	std	Y+2, r24	; 0x02
    8fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    8fde:	8b 30       	cpi	r24, 0x0B	; 11
    8fe0:	60 f2       	brcs	.-104    	; 0x8f7a <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8fe2:	1a 82       	std	Y+2, r1	; 0x02
    8fe4:	14 c0       	rjmp	.+40     	; 0x900e <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8fe6:	8a 81       	ldd	r24, Y+2	; 0x02
    8fe8:	88 2f       	mov	r24, r24
    8fea:	90 e0       	ldi	r25, 0x00	; 0
    8fec:	2a 81       	ldd	r18, Y+2	; 0x02
    8fee:	22 2f       	mov	r18, r18
    8ff0:	30 e0       	ldi	r19, 0x00	; 0
    8ff2:	ae 01       	movw	r20, r28
    8ff4:	4a 5f       	subi	r20, 0xFA	; 250
    8ff6:	5f 4f       	sbci	r21, 0xFF	; 255
    8ff8:	24 0f       	add	r18, r20
    8ffa:	35 1f       	adc	r19, r21
    8ffc:	f9 01       	movw	r30, r18
    8ffe:	20 81       	ld	r18, Z
    9000:	88 54       	subi	r24, 0x48	; 72
    9002:	9f 4a       	sbci	r25, 0xAF	; 175
    9004:	fc 01       	movw	r30, r24
    9006:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    9008:	8a 81       	ldd	r24, Y+2	; 0x02
    900a:	8f 5f       	subi	r24, 0xFF	; 255
    900c:	8a 83       	std	Y+2, r24	; 0x02
    900e:	8a 81       	ldd	r24, Y+2	; 0x02
    9010:	8b 30       	cpi	r24, 0x0B	; 11
    9012:	48 f3       	brcs	.-46     	; 0x8fe6 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    9014:	80 e0       	ldi	r24, 0x00	; 0
}
    9016:	62 96       	adiw	r28, 0x12	; 18
    9018:	cd bf       	out	0x3d, r28	; 61
    901a:	de bf       	out	0x3e, r29	; 62
    901c:	df 91       	pop	r29
    901e:	cf 91       	pop	r28
    9020:	08 95       	ret

00009022 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    9022:	ef 92       	push	r14
    9024:	ff 92       	push	r15
    9026:	0f 93       	push	r16
    9028:	1f 93       	push	r17
    902a:	cf 93       	push	r28
    902c:	df 93       	push	r29
    902e:	cd b7       	in	r28, 0x3d	; 61
    9030:	de b7       	in	r29, 0x3e	; 62
    9032:	e7 97       	sbiw	r28, 0x37	; 55
    9034:	cd bf       	out	0x3d, r28	; 61
    9036:	de bf       	out	0x3e, r29	; 62
    9038:	88 ab       	sts	0x58, r24
    903a:	99 ab       	sts	0x59, r25
    903c:	6a ab       	sts	0x5a, r22
    903e:	7b ab       	sts	0x5b, r23
    9040:	2c ab       	sts	0x5c, r18
    9042:	3d ab       	sts	0x5d, r19
    9044:	4e ab       	sts	0x5e, r20
    9046:	5f ab       	sts	0x5f, r21
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    9048:	1a 82       	std	Y+2, r1	; 0x02
    904a:	1b 82       	std	Y+3, r1	; 0x03
    904c:	1c 82       	std	Y+4, r1	; 0x04
    904e:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    9050:	1e 82       	std	Y+6, r1	; 0x06
    9052:	1f 82       	std	Y+7, r1	; 0x07
    9054:	18 86       	std	Y+8, r1	; 0x08
    9056:	19 86       	std	Y+9, r1	; 0x09
    9058:	1a 86       	std	Y+10, r1	; 0x0a
    905a:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    905c:	28 a9       	sts	0x48, r18
    905e:	39 a9       	sts	0x49, r19
    9060:	81 e0       	ldi	r24, 0x01	; 1
    9062:	b9 01       	movw	r22, r18
    9064:	0e 94 2c 46 	call	0x8c58	; 0x8c58 <readFile>
    9068:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    906a:	89 81       	ldd	r24, Y+1	; 0x01
    906c:	81 30       	cpi	r24, 0x01	; 1
    906e:	09 f0       	breq	.+2      	; 0x9072 <writeFile+0x50>
    9070:	84 c0       	rjmp	.+264    	; 0x917a <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    9072:	81 e0       	ldi	r24, 0x01	; 1
    9074:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    9076:	80 91 84 50 	lds	r24, 0x5084
    907a:	90 91 85 50 	lds	r25, 0x5085
    907e:	a0 91 86 50 	lds	r26, 0x5086
    9082:	b0 91 87 50 	lds	r27, 0x5087
    9086:	8c 87       	std	Y+12, r24	; 0x0c
    9088:	9d 87       	std	Y+13, r25	; 0x0d
    908a:	ae 87       	std	Y+14, r26	; 0x0e
    908c:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    908e:	1c 8a       	std	Y+20, r1	; 0x14
    9090:	1d 8a       	std	Y+21, r1	; 0x15
    9092:	1e 8a       	std	Y+22, r1	; 0x16
    9094:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    9096:	8c 85       	ldd	r24, Y+12	; 0x0c
    9098:	9d 85       	ldd	r25, Y+13	; 0x0d
    909a:	ae 85       	ldd	r26, Y+14	; 0x0e
    909c:	bf 85       	ldd	r27, Y+15	; 0x0f
    909e:	bc 01       	movw	r22, r24
    90a0:	cd 01       	movw	r24, r26
    90a2:	40 e0       	ldi	r20, 0x00	; 0
    90a4:	00 e0       	ldi	r16, 0x00	; 0
    90a6:	10 e0       	ldi	r17, 0x00	; 0
    90a8:	98 01       	movw	r18, r16
    90aa:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
    90ae:	dc 01       	movw	r26, r24
    90b0:	cb 01       	movw	r24, r22
    90b2:	8a a3       	lds	r24, 0x5a
    90b4:	9b a3       	lds	r25, 0x5b
    90b6:	ac a3       	lds	r26, 0x5c
    90b8:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    90ba:	8a a1       	lds	r24, 0x4a
    90bc:	9b a1       	lds	r25, 0x4b
    90be:	ac a1       	lds	r26, 0x4c
    90c0:	bd a1       	lds	r27, 0x4d
    90c2:	8f 3f       	cpi	r24, 0xFF	; 255
    90c4:	0f ef       	ldi	r16, 0xFF	; 255
    90c6:	90 07       	cpc	r25, r16
    90c8:	0f ef       	ldi	r16, 0xFF	; 255
    90ca:	a0 07       	cpc	r26, r16
    90cc:	0f e0       	ldi	r16, 0x0F	; 15
    90ce:	b0 07       	cpc	r27, r16
    90d0:	a1 f0       	breq	.+40     	; 0x90fa <writeFile+0xd8>
	cluster = nextCluster;
    90d2:	8a a1       	lds	r24, 0x4a
    90d4:	9b a1       	lds	r25, 0x4b
    90d6:	ac a1       	lds	r26, 0x4c
    90d8:	bd a1       	lds	r27, 0x4d
    90da:	8c 87       	std	Y+12, r24	; 0x0c
    90dc:	9d 87       	std	Y+13, r25	; 0x0d
    90de:	ae 87       	std	Y+14, r26	; 0x0e
    90e0:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    90e2:	8c 89       	ldd	r24, Y+20	; 0x14
    90e4:	9d 89       	ldd	r25, Y+21	; 0x15
    90e6:	ae 89       	ldd	r26, Y+22	; 0x16
    90e8:	bf 89       	ldd	r27, Y+23	; 0x17
    90ea:	01 96       	adiw	r24, 0x01	; 1
    90ec:	a1 1d       	adc	r26, r1
    90ee:	b1 1d       	adc	r27, r1
    90f0:	8c 8b       	std	Y+20, r24	; 0x14
    90f2:	9d 8b       	std	Y+21, r25	; 0x15
    90f4:	ae 8b       	std	Y+22, r26	; 0x16
    90f6:	bf 8b       	std	Y+23, r27	; 0x17
  }
    90f8:	ce cf       	rjmp	.-100    	; 0x9096 <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    90fa:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    90fc:	e0 90 51 40 	lds	r14, 0x4051
    9100:	f0 90 52 40 	lds	r15, 0x4052
    9104:	00 91 53 40 	lds	r16, 0x4053
    9108:	10 91 54 40 	lds	r17, 0x4054
    910c:	80 91 78 50 	lds	r24, 0x5078
    9110:	90 91 79 50 	lds	r25, 0x5079
    9114:	cc 01       	movw	r24, r24
    9116:	a0 e0       	ldi	r26, 0x00	; 0
    9118:	b0 e0       	ldi	r27, 0x00	; 0
    911a:	2c 89       	ldd	r18, Y+20	; 0x14
    911c:	3d 89       	ldd	r19, Y+21	; 0x15
    911e:	4e 89       	ldd	r20, Y+22	; 0x16
    9120:	5f 89       	ldd	r21, Y+23	; 0x17
    9122:	bc 01       	movw	r22, r24
    9124:	cd 01       	movw	r24, r26
    9126:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    912a:	dc 01       	movw	r26, r24
    912c:	cb 01       	movw	r24, r22
    912e:	20 91 55 40 	lds	r18, 0x4055
    9132:	30 91 56 40 	lds	r19, 0x4056
    9136:	99 01       	movw	r18, r18
    9138:	40 e0       	ldi	r20, 0x00	; 0
    913a:	50 e0       	ldi	r21, 0x00	; 0
    913c:	bc 01       	movw	r22, r24
    913e:	cd 01       	movw	r24, r26
    9140:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    9144:	dc 01       	movw	r26, r24
    9146:	cb 01       	movw	r24, r22
    9148:	a8 01       	movw	r20, r16
    914a:	97 01       	movw	r18, r14
    914c:	28 1b       	sub	r18, r24
    914e:	39 0b       	sbc	r19, r25
    9150:	4a 0b       	sbc	r20, r26
    9152:	5b 0b       	sbc	r21, r27
    9154:	da 01       	movw	r26, r20
    9156:	c9 01       	movw	r24, r18
    9158:	20 91 55 40 	lds	r18, 0x4055
    915c:	30 91 56 40 	lds	r19, 0x4056
    9160:	99 01       	movw	r18, r18
    9162:	40 e0       	ldi	r20, 0x00	; 0
    9164:	50 e0       	ldi	r21, 0x00	; 0
    9166:	bc 01       	movw	r22, r24
    9168:	cd 01       	movw	r24, r26
    916a:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    916e:	da 01       	movw	r26, r20
    9170:	c9 01       	movw	r24, r18
    9172:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    9174:	81 e0       	ldi	r24, 0x01	; 1
    9176:	8b 83       	std	Y+3, r24	; 0x03
    9178:	69 c0       	rjmp	.+210    	; 0x924c <writeFile+0x22a>
}
else if(j == 2) 
    917a:	89 81       	ldd	r24, Y+1	; 0x01
    917c:	82 30       	cpi	r24, 0x02	; 2
    917e:	11 f4       	brne	.+4      	; 0x9184 <writeFile+0x162>
   return 1; //invalid file name
    9180:	81 e0       	ldi	r24, 0x01	; 1
    9182:	1b c3       	rjmp	.+1590   	; 0x97ba <writeFile+0x798>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    9184:	82 e0       	ldi	r24, 0x02	; 2
    9186:	60 e0       	ldi	r22, 0x00	; 0
    9188:	20 e0       	ldi	r18, 0x00	; 0
    918a:	30 e0       	ldi	r19, 0x00	; 0
    918c:	a9 01       	movw	r20, r18
    918e:	0e 94 a1 43 	call	0x8742	; 0x8742 <getSetFreeCluster>
    9192:	dc 01       	movw	r26, r24
    9194:	cb 01       	movw	r24, r22
    9196:	8c 87       	std	Y+12, r24	; 0x0c
    9198:	9d 87       	std	Y+13, r25	; 0x0d
    919a:	ae 87       	std	Y+14, r26	; 0x0e
    919c:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    919e:	80 91 5a 40 	lds	r24, 0x405A
    91a2:	90 91 5b 40 	lds	r25, 0x405B
    91a6:	a0 91 5c 40 	lds	r26, 0x405C
    91aa:	b0 91 5d 40 	lds	r27, 0x405D
    91ae:	2c 85       	ldd	r18, Y+12	; 0x0c
    91b0:	3d 85       	ldd	r19, Y+13	; 0x0d
    91b2:	4e 85       	ldd	r20, Y+14	; 0x0e
    91b4:	5f 85       	ldd	r21, Y+15	; 0x0f
    91b6:	82 17       	cp	r24, r18
    91b8:	93 07       	cpc	r25, r19
    91ba:	a4 07       	cpc	r26, r20
    91bc:	b5 07       	cpc	r27, r21
    91be:	60 f4       	brcc	.+24     	; 0x91d8 <writeFile+0x1b6>
     cluster = rootCluster;
    91c0:	80 91 60 40 	lds	r24, 0x4060
    91c4:	90 91 61 40 	lds	r25, 0x4061
    91c8:	a0 91 62 40 	lds	r26, 0x4062
    91cc:	b0 91 63 40 	lds	r27, 0x4063
    91d0:	8c 87       	std	Y+12, r24	; 0x0c
    91d2:	9d 87       	std	Y+13, r25	; 0x0d
    91d4:	ae 87       	std	Y+14, r26	; 0x0e
    91d6:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    91d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    91da:	9d 85       	ldd	r25, Y+13	; 0x0d
    91dc:	ae 85       	ldd	r26, Y+14	; 0x0e
    91de:	bf 85       	ldd	r27, Y+15	; 0x0f
    91e0:	bc 01       	movw	r22, r24
    91e2:	cd 01       	movw	r24, r26
    91e4:	0e 94 e7 4b 	call	0x97ce	; 0x97ce <searchNextFreeCluster>
    91e8:	dc 01       	movw	r26, r24
    91ea:	cb 01       	movw	r24, r22
    91ec:	8c 87       	std	Y+12, r24	; 0x0c
    91ee:	9d 87       	std	Y+13, r25	; 0x0d
    91f0:	ae 87       	std	Y+14, r26	; 0x0e
    91f2:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    91f4:	8c 85       	ldd	r24, Y+12	; 0x0c
    91f6:	9d 85       	ldd	r25, Y+13	; 0x0d
    91f8:	ae 85       	ldd	r26, Y+14	; 0x0e
    91fa:	bf 85       	ldd	r27, Y+15	; 0x0f
    91fc:	00 97       	sbiw	r24, 0x00	; 0
    91fe:	a1 05       	cpc	r26, r1
    9200:	b1 05       	cpc	r27, r1
    9202:	11 f4       	brne	.+4      	; 0x9208 <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    9204:	82 e0       	ldi	r24, 0x02	; 2
    9206:	d9 c2       	rjmp	.+1458   	; 0x97ba <writeFile+0x798>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    9208:	8c 85       	ldd	r24, Y+12	; 0x0c
    920a:	9d 85       	ldd	r25, Y+13	; 0x0d
    920c:	ae 85       	ldd	r26, Y+14	; 0x0e
    920e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9210:	bc 01       	movw	r22, r24
    9212:	cd 01       	movw	r24, r26
    9214:	41 e0       	ldi	r20, 0x01	; 1
    9216:	0f ef       	ldi	r16, 0xFF	; 255
    9218:	1f ef       	ldi	r17, 0xFF	; 255
    921a:	2f ef       	ldi	r18, 0xFF	; 255
    921c:	3f e0       	ldi	r19, 0x0F	; 15
    921e:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    9222:	8c 85       	ldd	r24, Y+12	; 0x0c
    9224:	9d 85       	ldd	r25, Y+13	; 0x0d
    9226:	ae 85       	ldd	r26, Y+14	; 0x0e
    9228:	bf 85       	ldd	r27, Y+15	; 0x0f
    922a:	cd 01       	movw	r24, r26
    922c:	aa 27       	eor	r26, r26
    922e:	bb 27       	eor	r27, r27
    9230:	8e 83       	std	Y+6, r24	; 0x06
    9232:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    9234:	8c 85       	ldd	r24, Y+12	; 0x0c
    9236:	9d 85       	ldd	r25, Y+13	; 0x0d
    9238:	88 87       	std	Y+8, r24	; 0x08
    923a:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    923c:	10 92 51 40 	sts	0x4051, r1
    9240:	10 92 52 40 	sts	0x4052, r1
    9244:	10 92 53 40 	sts	0x4053, r1
    9248:	10 92 54 40 	sts	0x4054, r1
}

//start writing data here

if(start){
    924c:	8b 81       	ldd	r24, Y+3	; 0x03
    924e:	88 23       	and	r24, r24
    9250:	11 f1       	breq	.+68     	; 0x9296 <writeFile+0x274>
  start = 0;
    9252:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    9254:	8c 85       	ldd	r24, Y+12	; 0x0c
    9256:	9d 85       	ldd	r25, Y+13	; 0x0d
    9258:	ae 85       	ldd	r26, Y+14	; 0x0e
    925a:	bf 85       	ldd	r27, Y+15	; 0x0f
    925c:	bc 01       	movw	r22, r24
    925e:	cd 01       	movw	r24, r26
    9260:	0e 94 c5 42 	call	0x858a	; 0x858a <getFirstSector>
    9264:	dc 01       	movw	r26, r24
    9266:	cb 01       	movw	r24, r22
    9268:	9c 01       	movw	r18, r24
    926a:	8d 81       	ldd	r24, Y+5	; 0x05
    926c:	88 2f       	mov	r24, r24
    926e:	90 e0       	ldi	r25, 0x00	; 0
    9270:	82 0f       	add	r24, r18
    9272:	93 1f       	adc	r25, r19
    9274:	8a 87       	std	Y+10, r24	; 0x0a
    9276:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    9278:	8a 85       	ldd	r24, Y+10	; 0x0a
    927a:	9b 85       	ldd	r25, Y+11	; 0x0b
    927c:	cc 01       	movw	r24, r24
    927e:	a0 e0       	ldi	r26, 0x00	; 0
    9280:	b0 e0       	ldi	r27, 0x00	; 0
    9282:	27 ed       	ldi	r18, 0xD7	; 215
    9284:	31 e2       	ldi	r19, 0x21	; 33
    9286:	bc 01       	movw	r22, r24
    9288:	cd 01       	movw	r24, r26
    928a:	a9 01       	movw	r20, r18
    928c:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
  j = sector;
    9290:	8d 81       	ldd	r24, Y+5	; 0x05
    9292:	89 83       	std	Y+1, r24	; 0x01
    9294:	0d c0       	rjmp	.+26     	; 0x92b0 <writeFile+0x28e>
}
else{
  startBlock = getFirstSector (cluster);
    9296:	8c 85       	ldd	r24, Y+12	; 0x0c
    9298:	9d 85       	ldd	r25, Y+13	; 0x0d
    929a:	ae 85       	ldd	r26, Y+14	; 0x0e
    929c:	bf 85       	ldd	r27, Y+15	; 0x0f
    929e:	bc 01       	movw	r22, r24
    92a0:	cd 01       	movw	r24, r26
    92a2:	0e 94 c5 42 	call	0x858a	; 0x858a <getFirstSector>
    92a6:	dc 01       	movw	r26, r24
    92a8:	cb 01       	movw	r24, r22
    92aa:	8a 87       	std	Y+10, r24	; 0x0a
    92ac:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    92ae:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    92b0:	18 8e       	std	Y+24, r1	; 0x18
    92b2:	19 8e       	std	Y+25, r1	; 0x19
    92b4:	1a 8e       	std	Y+26, r1	; 0x1a
    92b6:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    92b8:	1c 8e       	std	Y+28, r1	; 0x1c
    92ba:	1d 8e       	std	Y+29, r1	; 0x1d
    92bc:	1e 8e       	std	Y+30, r1	; 0x1e
    92be:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    92c0:	cd c0       	rjmp	.+410    	; 0x945c <writeFile+0x43a>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    92c2:	8c a9       	sts	0x4c, r24
    92c4:	9d a9       	sts	0x4d, r25
    92c6:	ae a9       	sts	0x4e, r26
    92c8:	bf a9       	sts	0x4f, r27
    92ca:	80 30       	cpi	r24, 0x00	; 0
    92cc:	32 e0       	ldi	r19, 0x02	; 2
    92ce:	93 07       	cpc	r25, r19
    92d0:	30 e0       	ldi	r19, 0x00	; 0
    92d2:	a3 07       	cpc	r26, r19
    92d4:	30 e0       	ldi	r19, 0x00	; 0
    92d6:	b3 07       	cpc	r27, r19
    92d8:	08 f1       	brcs	.+66     	; 0x931c <writeFile+0x2fa>
		 writtenData += 512;
    92da:	88 8d       	ldd	r24, Y+24	; 0x18
    92dc:	99 8d       	ldd	r25, Y+25	; 0x19
    92de:	aa 8d       	ldd	r26, Y+26	; 0x1a
    92e0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    92e2:	80 50       	subi	r24, 0x00	; 0
    92e4:	9e 4f       	sbci	r25, 0xFE	; 254
    92e6:	af 4f       	sbci	r26, 0xFF	; 255
    92e8:	bf 4f       	sbci	r27, 0xFF	; 255
    92ea:	88 8f       	std	Y+24, r24	; 0x18
    92ec:	99 8f       	std	Y+25, r25	; 0x19
    92ee:	aa 8f       	std	Y+26, r26	; 0x1a
    92f0:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    92f2:	80 e0       	ldi	r24, 0x00	; 0
    92f4:	92 e0       	ldi	r25, 0x02	; 2
    92f6:	a0 e0       	ldi	r26, 0x00	; 0
    92f8:	b0 e0       	ldi	r27, 0x00	; 0
    92fa:	8c 8f       	std	Y+28, r24	; 0x1c
    92fc:	9d 8f       	std	Y+29, r25	; 0x1d
    92fe:	ae 8f       	std	Y+30, r26	; 0x1e
    9300:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    9302:	8c a9       	sts	0x4c, r24
    9304:	9d a9       	sts	0x4d, r25
    9306:	ae a9       	sts	0x4e, r26
    9308:	bf a9       	sts	0x4f, r27
    930a:	80 50       	subi	r24, 0x00	; 0
    930c:	92 40       	sbci	r25, 0x02	; 2
    930e:	a0 40       	sbci	r26, 0x00	; 0
    9310:	b0 40       	sbci	r27, 0x00	; 0
    9312:	8c ab       	sts	0x5c, r24
    9314:	9d ab       	sts	0x5d, r25
    9316:	ae ab       	sts	0x5e, r26
    9318:	bf ab       	sts	0x5f, r27
    931a:	1f c0       	rjmp	.+62     	; 0x935a <writeFile+0x338>
	}
	else{
		writtenData += lengthOfData;
    931c:	28 8d       	ldd	r18, Y+24	; 0x18
    931e:	39 8d       	ldd	r19, Y+25	; 0x19
    9320:	4a 8d       	ldd	r20, Y+26	; 0x1a
    9322:	5b 8d       	ldd	r21, Y+27	; 0x1b
    9324:	8c a9       	sts	0x4c, r24
    9326:	9d a9       	sts	0x4d, r25
    9328:	ae a9       	sts	0x4e, r26
    932a:	bf a9       	sts	0x4f, r27
    932c:	82 0f       	add	r24, r18
    932e:	93 1f       	adc	r25, r19
    9330:	a4 1f       	adc	r26, r20
    9332:	b5 1f       	adc	r27, r21
    9334:	88 8f       	std	Y+24, r24	; 0x18
    9336:	99 8f       	std	Y+25, r25	; 0x19
    9338:	aa 8f       	std	Y+26, r26	; 0x1a
    933a:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    933c:	8c a9       	sts	0x4c, r24
    933e:	9d a9       	sts	0x4d, r25
    9340:	ae a9       	sts	0x4e, r26
    9342:	bf a9       	sts	0x4f, r27
    9344:	91 70       	andi	r25, 0x01	; 1
    9346:	a0 70       	andi	r26, 0x00	; 0
    9348:	b0 70       	andi	r27, 0x00	; 0
    934a:	8c 8f       	std	Y+28, r24	; 0x1c
    934c:	9d 8f       	std	Y+29, r25	; 0x1d
    934e:	ae 8f       	std	Y+30, r26	; 0x1e
    9350:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    9352:	1c aa       	sts	0x9c, r17
    9354:	1d aa       	sts	0x9d, r17
    9356:	1e aa       	sts	0x9e, r17
    9358:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    935a:	80 91 51 40 	lds	r24, 0x4051
    935e:	90 91 52 40 	lds	r25, 0x4052
    9362:	a0 91 53 40 	lds	r26, 0x4053
    9366:	b0 91 54 40 	lds	r27, 0x4054
    936a:	80 50       	subi	r24, 0x00	; 0
    936c:	9e 4f       	sbci	r25, 0xFE	; 254
    936e:	af 4f       	sbci	r26, 0xFF	; 255
    9370:	bf 4f       	sbci	r27, 0xFF	; 255
    9372:	80 93 51 40 	sts	0x4051, r24
    9376:	90 93 52 40 	sts	0x4052, r25
    937a:	a0 93 53 40 	sts	0x4053, r26
    937e:	b0 93 54 40 	sts	0x4054, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    9382:	8a 85       	ldd	r24, Y+10	; 0x0a
    9384:	9b 85       	ldd	r25, Y+11	; 0x0b
    9386:	cc 01       	movw	r24, r24
    9388:	a0 e0       	ldi	r26, 0x00	; 0
    938a:	b0 e0       	ldi	r27, 0x00	; 0
    938c:	48 8d       	ldd	r20, Y+24	; 0x18
    938e:	59 8d       	ldd	r21, Y+25	; 0x19
    9390:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9392:	3d 8d       	ldd	r19, Y+29	; 0x1d
    9394:	ba 01       	movw	r22, r20
    9396:	62 1b       	sub	r22, r18
    9398:	73 0b       	sbc	r23, r19
    939a:	9b 01       	movw	r18, r22
    939c:	4a a9       	sts	0x4a, r20
    939e:	5b a9       	sts	0x4b, r21
    93a0:	42 0f       	add	r20, r18
    93a2:	53 1f       	adc	r21, r19
    93a4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    93a6:	3d 8d       	ldd	r19, Y+29	; 0x1d
    93a8:	bc 01       	movw	r22, r24
    93aa:	cd 01       	movw	r24, r26
    93ac:	0e 94 23 50 	call	0xa046	; 0xa046 <SD_write_block>
	j++;
    93b0:	89 81       	ldd	r24, Y+1	; 0x01
    93b2:	8f 5f       	subi	r24, 0xFF	; 255
    93b4:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    93b6:	89 81       	ldd	r24, Y+1	; 0x01
    93b8:	28 2f       	mov	r18, r24
    93ba:	30 e0       	ldi	r19, 0x00	; 0
    93bc:	80 91 78 50 	lds	r24, 0x5078
    93c0:	90 91 79 50 	lds	r25, 0x5079
    93c4:	28 17       	cp	r18, r24
    93c6:	39 07       	cpc	r19, r25
    93c8:	e1 f5       	brne	.+120    	; 0x9442 <writeFile+0x420>
		j = 0; 
    93ca:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    93cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    93ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    93d0:	ae 85       	ldd	r26, Y+14	; 0x0e
    93d2:	bf 85       	ldd	r27, Y+15	; 0x0f
    93d4:	88 8b       	std	Y+16, r24	; 0x10
    93d6:	99 8b       	std	Y+17, r25	; 0x11
    93d8:	aa 8b       	std	Y+18, r26	; 0x12
    93da:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    93dc:	88 89       	ldd	r24, Y+16	; 0x10
    93de:	99 89       	ldd	r25, Y+17	; 0x11
    93e0:	aa 89       	ldd	r26, Y+18	; 0x12
    93e2:	bb 89       	ldd	r27, Y+19	; 0x13
    93e4:	bc 01       	movw	r22, r24
    93e6:	cd 01       	movw	r24, r26
    93e8:	0e 94 e7 4b 	call	0x97ce	; 0x97ce <searchNextFreeCluster>
    93ec:	dc 01       	movw	r26, r24
    93ee:	cb 01       	movw	r24, r22
    93f0:	8c 87       	std	Y+12, r24	; 0x0c
    93f2:	9d 87       	std	Y+13, r25	; 0x0d
    93f4:	ae 87       	std	Y+14, r26	; 0x0e
    93f6:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    93f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    93fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    93fc:	ae 85       	ldd	r26, Y+14	; 0x0e
    93fe:	bf 85       	ldd	r27, Y+15	; 0x0f
    9400:	00 97       	sbiw	r24, 0x00	; 0
    9402:	a1 05       	cpc	r26, r1
    9404:	b1 05       	cpc	r27, r1
    9406:	11 f4       	brne	.+4      	; 0x940c <writeFile+0x3ea>
		  //No free cluster!
		  return 2;
    9408:	82 e0       	ldi	r24, 0x02	; 2
    940a:	d7 c1       	rjmp	.+942    	; 0x97ba <writeFile+0x798>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    940c:	88 89       	ldd	r24, Y+16	; 0x10
    940e:	99 89       	ldd	r25, Y+17	; 0x11
    9410:	aa 89       	ldd	r26, Y+18	; 0x12
    9412:	bb 89       	ldd	r27, Y+19	; 0x13
    9414:	0c 85       	ldd	r16, Y+12	; 0x0c
    9416:	1d 85       	ldd	r17, Y+13	; 0x0d
    9418:	2e 85       	ldd	r18, Y+14	; 0x0e
    941a:	3f 85       	ldd	r19, Y+15	; 0x0f
    941c:	bc 01       	movw	r22, r24
    941e:	cd 01       	movw	r24, r26
    9420:	41 e0       	ldi	r20, 0x01	; 1
    9422:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    9426:	8c 85       	ldd	r24, Y+12	; 0x0c
    9428:	9d 85       	ldd	r25, Y+13	; 0x0d
    942a:	ae 85       	ldd	r26, Y+14	; 0x0e
    942c:	bf 85       	ldd	r27, Y+15	; 0x0f
    942e:	bc 01       	movw	r22, r24
    9430:	cd 01       	movw	r24, r26
    9432:	41 e0       	ldi	r20, 0x01	; 1
    9434:	0f ef       	ldi	r16, 0xFF	; 255
    9436:	1f ef       	ldi	r17, 0xFF	; 255
    9438:	2f ef       	ldi	r18, 0xFF	; 255
    943a:	3f e0       	ldi	r19, 0x0F	; 15
    943c:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
    9440:	05 c0       	rjmp	.+10     	; 0x944c <writeFile+0x42a>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    9442:	8a 85       	ldd	r24, Y+10	; 0x0a
    9444:	9b 85       	ldd	r25, Y+11	; 0x0b
    9446:	01 96       	adiw	r24, 0x01	; 1
    9448:	8a 87       	std	Y+10, r24	; 0x0a
    944a:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    944c:	2c 85       	ldd	r18, Y+12	; 0x0c
    944e:	3d 85       	ldd	r19, Y+13	; 0x0d
    9450:	4e 85       	ldd	r20, Y+14	; 0x0e
    9452:	5f 85       	ldd	r21, Y+15	; 0x0f
    9454:	82 e0       	ldi	r24, 0x02	; 2
    9456:	61 e0       	ldi	r22, 0x01	; 1
    9458:	0e 94 a1 43 	call	0x8742	; 0x8742 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    945c:	8c a9       	sts	0x4c, r24
    945e:	9d a9       	sts	0x4d, r25
    9460:	ae a9       	sts	0x4e, r26
    9462:	bf a9       	sts	0x4f, r27
    9464:	00 97       	sbiw	r24, 0x00	; 0
    9466:	a1 05       	cpc	r26, r1
    9468:	b1 05       	cpc	r27, r1
    946a:	09 f0       	breq	.+2      	; 0x946e <writeFile+0x44c>
    946c:	2a cf       	rjmp	.-428    	; 0x92c2 <writeFile+0x2a0>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    946e:	8c 81       	ldd	r24, Y+4	; 0x04
    9470:	88 23       	and	r24, r24
    9472:	09 f4       	brne	.+2      	; 0x9476 <writeFile+0x454>
    9474:	66 c0       	rjmp	.+204    	; 0x9542 <writeFile+0x520>
{
  SD_read_block (appendFileSector,SDBuffer);    
    9476:	80 91 ce 50 	lds	r24, 0x50CE
    947a:	90 91 cf 50 	lds	r25, 0x50CF
    947e:	a0 91 d0 50 	lds	r26, 0x50D0
    9482:	b0 91 d1 50 	lds	r27, 0x50D1
    9486:	27 ed       	ldi	r18, 0xD7	; 215
    9488:	31 e2       	ldi	r19, 0x21	; 33
    948a:	bc 01       	movw	r22, r24
    948c:	cd 01       	movw	r24, r26
    948e:	a9 01       	movw	r20, r18
    9490:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    9494:	80 91 d8 23 	lds	r24, 0x23D8
    9498:	90 91 d9 23 	lds	r25, 0x23D9
    949c:	a0 91 da 23 	lds	r26, 0x23DA
    94a0:	b0 91 db 23 	lds	r27, 0x23DB
    94a4:	89 52       	subi	r24, 0x29	; 41
    94a6:	9e 4d       	sbci	r25, 0xDE	; 222
    94a8:	8e a3       	lds	r24, 0x5e
    94aa:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    94ac:	8e a1       	lds	r24, 0x4e
    94ae:	9f a1       	lds	r25, 0x4f
    94b0:	fc 01       	movw	r30, r24
    94b2:	12 8a       	std	Z+18, r1	; 0x12
    94b4:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    94b6:	20 91 51 40 	lds	r18, 0x4051
    94ba:	30 91 52 40 	lds	r19, 0x4052
    94be:	40 91 53 40 	lds	r20, 0x4053
    94c2:	50 91 54 40 	lds	r21, 0x4054
    94c6:	8e a1       	lds	r24, 0x4e
    94c8:	9f a1       	lds	r25, 0x4f
    94ca:	fc 01       	movw	r30, r24
    94cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    94ce:	95 8d       	ldd	r25, Z+29	; 0x1d
    94d0:	a6 8d       	ldd	r26, Z+30	; 0x1e
    94d2:	b7 8d       	ldd	r27, Z+31	; 0x1f
    94d4:	79 01       	movw	r14, r18
    94d6:	8a 01       	movw	r16, r20
    94d8:	e8 1a       	sub	r14, r24
    94da:	f9 0a       	sbc	r15, r25
    94dc:	0a 0b       	sbc	r16, r26
    94de:	1b 0b       	sbc	r17, r27
    94e0:	d8 01       	movw	r26, r16
    94e2:	c7 01       	movw	r24, r14
    94e4:	88 a7       	lds	r24, 0x78
    94e6:	99 a7       	lds	r25, 0x79
    94e8:	aa a7       	lds	r26, 0x7a
    94ea:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    94ec:	80 91 51 40 	lds	r24, 0x4051
    94f0:	90 91 52 40 	lds	r25, 0x4052
    94f4:	a0 91 53 40 	lds	r26, 0x4053
    94f8:	b0 91 54 40 	lds	r27, 0x4054
    94fc:	2e a1       	lds	r18, 0x4e
    94fe:	3f a1       	lds	r19, 0x4f
    9500:	f9 01       	movw	r30, r18
    9502:	84 8f       	std	Z+28, r24	; 0x1c
    9504:	95 8f       	std	Z+29, r25	; 0x1d
    9506:	a6 8f       	std	Z+30, r26	; 0x1e
    9508:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    950a:	80 91 ce 50 	lds	r24, 0x50CE
    950e:	90 91 cf 50 	lds	r25, 0x50CF
    9512:	a0 91 d0 50 	lds	r26, 0x50D0
    9516:	b0 91 d1 50 	lds	r27, 0x50D1
    951a:	27 ed       	ldi	r18, 0xD7	; 215
    951c:	31 e2       	ldi	r19, 0x21	; 33
    951e:	bc 01       	movw	r22, r24
    9520:	cd 01       	movw	r24, r26
    9522:	a9 01       	movw	r20, r18
    9524:	20 e0       	ldi	r18, 0x00	; 0
    9526:	32 e0       	ldi	r19, 0x02	; 2
    9528:	0e 94 23 50 	call	0xa046	; 0xa046 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    952c:	28 a5       	lds	r18, 0x68
    952e:	39 a5       	lds	r19, 0x69
    9530:	4a a5       	lds	r20, 0x6a
    9532:	5b a5       	lds	r21, 0x6b
    9534:	81 e0       	ldi	r24, 0x01	; 1
    9536:	ba 01       	movw	r22, r20
    9538:	a9 01       	movw	r20, r18
    953a:	0e 94 c0 4c 	call	0x9980	; 0x9980 <freeMemoryUpdate>

 //File appended!
  return 0;
    953e:	80 e0       	ldi	r24, 0x00	; 0
    9540:	3c c1       	rjmp	.+632    	; 0x97ba <writeFile+0x798>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9542:	80 91 60 40 	lds	r24, 0x4060
    9546:	90 91 61 40 	lds	r25, 0x4061
    954a:	a0 91 62 40 	lds	r26, 0x4062
    954e:	b0 91 63 40 	lds	r27, 0x4063
    9552:	88 8b       	std	Y+16, r24	; 0x10
    9554:	99 8b       	std	Y+17, r25	; 0x11
    9556:	aa 8b       	std	Y+18, r26	; 0x12
    9558:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    955a:	88 89       	ldd	r24, Y+16	; 0x10
    955c:	99 89       	ldd	r25, Y+17	; 0x11
    955e:	aa 89       	ldd	r26, Y+18	; 0x12
    9560:	bb 89       	ldd	r27, Y+19	; 0x13
    9562:	bc 01       	movw	r22, r24
    9564:	cd 01       	movw	r24, r26
    9566:	0e 94 c5 42 	call	0x858a	; 0x858a <getFirstSector>
    956a:	dc 01       	movw	r26, r24
    956c:	cb 01       	movw	r24, r22
    956e:	8c a7       	lds	r24, 0x7c
    9570:	9d a7       	lds	r25, 0x7d
    9572:	ae a7       	lds	r26, 0x7e
    9574:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    9576:	1d 82       	std	Y+5, r1	; 0x05
    9578:	ad c0       	rjmp	.+346    	; 0x96d4 <writeFile+0x6b2>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    957a:	8d 81       	ldd	r24, Y+5	; 0x05
    957c:	28 2f       	mov	r18, r24
    957e:	30 e0       	ldi	r19, 0x00	; 0
    9580:	40 e0       	ldi	r20, 0x00	; 0
    9582:	50 e0       	ldi	r21, 0x00	; 0
    9584:	8c a5       	lds	r24, 0x6c
    9586:	9d a5       	lds	r25, 0x6d
    9588:	ae a5       	lds	r26, 0x6e
    958a:	bf a5       	lds	r27, 0x6f
    958c:	82 0f       	add	r24, r18
    958e:	93 1f       	adc	r25, r19
    9590:	a4 1f       	adc	r26, r20
    9592:	b5 1f       	adc	r27, r21
    9594:	27 ed       	ldi	r18, 0xD7	; 215
    9596:	31 e2       	ldi	r19, 0x21	; 33
    9598:	bc 01       	movw	r22, r24
    959a:	cd 01       	movw	r24, r26
    959c:	a9 01       	movw	r20, r18
    959e:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    95a2:	18 a2       	lds	r17, 0x98
    95a4:	19 a2       	lds	r17, 0x99
    95a6:	89 c0       	rjmp	.+274    	; 0x96ba <writeFile+0x698>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    95a8:	88 a1       	lds	r24, 0x48
    95aa:	99 a1       	lds	r25, 0x49
    95ac:	89 52       	subi	r24, 0x29	; 41
    95ae:	9e 4d       	sbci	r25, 0xDE	; 222
    95b0:	8e a3       	lds	r24, 0x5e
    95b2:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    95b4:	8a 81       	ldd	r24, Y+2	; 0x02
    95b6:	88 23       	and	r24, r24
    95b8:	11 f0       	breq	.+4      	; 0x95be <writeFile+0x59c>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    95ba:	80 e0       	ldi	r24, 0x00	; 0
    95bc:	fe c0       	rjmp	.+508    	; 0x97ba <writeFile+0x798>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    95be:	8e a1       	lds	r24, 0x4e
    95c0:	9f a1       	lds	r25, 0x4f
    95c2:	fc 01       	movw	r30, r24
    95c4:	80 81       	ld	r24, Z
    95c6:	88 23       	and	r24, r24
    95c8:	39 f0       	breq	.+14     	; 0x95d8 <writeFile+0x5b6>
    95ca:	8e a1       	lds	r24, 0x4e
    95cc:	9f a1       	lds	r25, 0x4f
    95ce:	fc 01       	movw	r30, r24
    95d0:	80 81       	ld	r24, Z
    95d2:	85 3e       	cpi	r24, 0xE5	; 229
    95d4:	09 f0       	breq	.+2      	; 0x95d8 <writeFile+0x5b6>
    95d6:	6c c0       	rjmp	.+216    	; 0x96b0 <writeFile+0x68e>
		{
		  for(j=0; j<11; j++)
    95d8:	19 82       	std	Y+1, r1	; 0x01
    95da:	13 c0       	rjmp	.+38     	; 0x9602 <writeFile+0x5e0>
  			dir->name[j] = Filename[j];
    95dc:	89 81       	ldd	r24, Y+1	; 0x01
    95de:	88 2f       	mov	r24, r24
    95e0:	90 e0       	ldi	r25, 0x00	; 0
    95e2:	29 81       	ldd	r18, Y+1	; 0x01
    95e4:	22 2f       	mov	r18, r18
    95e6:	30 e0       	ldi	r19, 0x00	; 0
    95e8:	28 54       	subi	r18, 0x48	; 72
    95ea:	3f 4a       	sbci	r19, 0xAF	; 175
    95ec:	f9 01       	movw	r30, r18
    95ee:	40 81       	ld	r20, Z
    95f0:	2e a1       	lds	r18, 0x4e
    95f2:	3f a1       	lds	r19, 0x4f
    95f4:	82 0f       	add	r24, r18
    95f6:	93 1f       	adc	r25, r19
    95f8:	fc 01       	movw	r30, r24
    95fa:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    95fc:	89 81       	ldd	r24, Y+1	; 0x01
    95fe:	8f 5f       	subi	r24, 0xFF	; 255
    9600:	89 83       	std	Y+1, r24	; 0x01
    9602:	89 81       	ldd	r24, Y+1	; 0x01
    9604:	8b 30       	cpi	r24, 0x0B	; 11
    9606:	50 f3       	brcs	.-44     	; 0x95dc <writeFile+0x5ba>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    9608:	8e a1       	lds	r24, 0x4e
    960a:	9f a1       	lds	r25, 0x4f
    960c:	20 e2       	ldi	r18, 0x20	; 32
    960e:	fc 01       	movw	r30, r24
    9610:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    9612:	8e a1       	lds	r24, 0x4e
    9614:	9f a1       	lds	r25, 0x4f
    9616:	fc 01       	movw	r30, r24
    9618:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    961a:	8e a1       	lds	r24, 0x4e
    961c:	9f a1       	lds	r25, 0x4f
    961e:	fc 01       	movw	r30, r24
    9620:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    9622:	8e a1       	lds	r24, 0x4e
    9624:	9f a1       	lds	r25, 0x4f
    9626:	fc 01       	movw	r30, r24
    9628:	12 8a       	std	Z+18, r1	; 0x12
    962a:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    962c:	8e a1       	lds	r24, 0x4e
    962e:	9f a1       	lds	r25, 0x4f
    9630:	2e 81       	ldd	r18, Y+6	; 0x06
    9632:	3f 81       	ldd	r19, Y+7	; 0x07
    9634:	fc 01       	movw	r30, r24
    9636:	24 8b       	std	Z+20, r18	; 0x14
    9638:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    963a:	8e a1       	lds	r24, 0x4e
    963c:	9f a1       	lds	r25, 0x4f
    963e:	28 85       	ldd	r18, Y+8	; 0x08
    9640:	39 85       	ldd	r19, Y+9	; 0x09
    9642:	fc 01       	movw	r30, r24
    9644:	22 8f       	std	Z+26, r18	; 0x1a
    9646:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    9648:	80 91 51 40 	lds	r24, 0x4051
    964c:	90 91 52 40 	lds	r25, 0x4052
    9650:	a0 91 53 40 	lds	r26, 0x4053
    9654:	b0 91 54 40 	lds	r27, 0x4054
    9658:	2e a1       	lds	r18, 0x4e
    965a:	3f a1       	lds	r19, 0x4f
    965c:	f9 01       	movw	r30, r18
    965e:	84 8f       	std	Z+28, r24	; 0x1c
    9660:	95 8f       	std	Z+29, r25	; 0x1d
    9662:	a6 8f       	std	Z+30, r26	; 0x1e
    9664:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    9666:	8d 81       	ldd	r24, Y+5	; 0x05
    9668:	28 2f       	mov	r18, r24
    966a:	30 e0       	ldi	r19, 0x00	; 0
    966c:	40 e0       	ldi	r20, 0x00	; 0
    966e:	50 e0       	ldi	r21, 0x00	; 0
    9670:	8c a5       	lds	r24, 0x6c
    9672:	9d a5       	lds	r25, 0x6d
    9674:	ae a5       	lds	r26, 0x6e
    9676:	bf a5       	lds	r27, 0x6f
    9678:	82 0f       	add	r24, r18
    967a:	93 1f       	adc	r25, r19
    967c:	a4 1f       	adc	r26, r20
    967e:	b5 1f       	adc	r27, r21
    9680:	27 ed       	ldi	r18, 0xD7	; 215
    9682:	31 e2       	ldi	r19, 0x21	; 33
    9684:	bc 01       	movw	r22, r24
    9686:	cd 01       	movw	r24, r26
    9688:	a9 01       	movw	r20, r18
    968a:	20 e0       	ldi	r18, 0x00	; 0
    968c:	32 e0       	ldi	r19, 0x02	; 2
    968e:	0e 94 23 50 	call	0xa046	; 0xa046 <SD_write_block>
		  fileCreatedFlag = 1;
    9692:	81 e0       	ldi	r24, 0x01	; 1
    9694:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    9696:	20 91 51 40 	lds	r18, 0x4051
    969a:	30 91 52 40 	lds	r19, 0x4052
    969e:	40 91 53 40 	lds	r20, 0x4053
    96a2:	50 91 54 40 	lds	r21, 0x4054
    96a6:	81 e0       	ldi	r24, 0x01	; 1
    96a8:	ba 01       	movw	r22, r20
    96aa:	a9 01       	movw	r20, r18
    96ac:	0e 94 c0 4c 	call	0x9980	; 0x9980 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    96b0:	88 a1       	lds	r24, 0x48
    96b2:	99 a1       	lds	r25, 0x49
    96b4:	80 96       	adiw	r24, 0x20	; 32
    96b6:	88 a3       	lds	r24, 0x58
    96b8:	99 a3       	lds	r25, 0x59
    96ba:	28 a1       	lds	r18, 0x48
    96bc:	39 a1       	lds	r19, 0x49
    96be:	80 91 55 40 	lds	r24, 0x4055
    96c2:	90 91 56 40 	lds	r25, 0x4056
    96c6:	28 17       	cp	r18, r24
    96c8:	39 07       	cpc	r19, r25
    96ca:	08 f4       	brcc	.+2      	; 0x96ce <writeFile+0x6ac>
    96cc:	6d cf       	rjmp	.-294    	; 0x95a8 <writeFile+0x586>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    96ce:	8d 81       	ldd	r24, Y+5	; 0x05
    96d0:	8f 5f       	subi	r24, 0xFF	; 255
    96d2:	8d 83       	std	Y+5, r24	; 0x05
    96d4:	8d 81       	ldd	r24, Y+5	; 0x05
    96d6:	28 2f       	mov	r18, r24
    96d8:	30 e0       	ldi	r19, 0x00	; 0
    96da:	80 91 78 50 	lds	r24, 0x5078
    96de:	90 91 79 50 	lds	r25, 0x5079
    96e2:	28 17       	cp	r18, r24
    96e4:	39 07       	cpc	r19, r25
    96e6:	08 f4       	brcc	.+2      	; 0x96ea <writeFile+0x6c8>
    96e8:	48 cf       	rjmp	.-368    	; 0x957a <writeFile+0x558>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    96ea:	88 89       	ldd	r24, Y+16	; 0x10
    96ec:	99 89       	ldd	r25, Y+17	; 0x11
    96ee:	aa 89       	ldd	r26, Y+18	; 0x12
    96f0:	bb 89       	ldd	r27, Y+19	; 0x13
    96f2:	bc 01       	movw	r22, r24
    96f4:	cd 01       	movw	r24, r26
    96f6:	40 e0       	ldi	r20, 0x00	; 0
    96f8:	00 e0       	ldi	r16, 0x00	; 0
    96fa:	10 e0       	ldi	r17, 0x00	; 0
    96fc:	98 01       	movw	r18, r16
    96fe:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
    9702:	dc 01       	movw	r26, r24
    9704:	cb 01       	movw	r24, r22
    9706:	8c 87       	std	Y+12, r24	; 0x0c
    9708:	9d 87       	std	Y+13, r25	; 0x0d
    970a:	ae 87       	std	Y+14, r26	; 0x0e
    970c:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    970e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9710:	9d 85       	ldd	r25, Y+13	; 0x0d
    9712:	ae 85       	ldd	r26, Y+14	; 0x0e
    9714:	bf 85       	ldd	r27, Y+15	; 0x0f
    9716:	87 3f       	cpi	r24, 0xF7	; 247
    9718:	ff ef       	ldi	r31, 0xFF	; 255
    971a:	9f 07       	cpc	r25, r31
    971c:	ff ef       	ldi	r31, 0xFF	; 255
    971e:	af 07       	cpc	r26, r31
    9720:	ff e0       	ldi	r31, 0x0F	; 15
    9722:	bf 07       	cpc	r27, r31
    9724:	b8 f1       	brcs	.+110    	; 0x9794 <writeFile+0x772>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    9726:	8c 85       	ldd	r24, Y+12	; 0x0c
    9728:	9d 85       	ldd	r25, Y+13	; 0x0d
    972a:	ae 85       	ldd	r26, Y+14	; 0x0e
    972c:	bf 85       	ldd	r27, Y+15	; 0x0f
    972e:	8f 3f       	cpi	r24, 0xFF	; 255
    9730:	0f ef       	ldi	r16, 0xFF	; 255
    9732:	90 07       	cpc	r25, r16
    9734:	0f ef       	ldi	r16, 0xFF	; 255
    9736:	a0 07       	cpc	r26, r16
    9738:	0f e0       	ldi	r16, 0x0F	; 15
    973a:	b0 07       	cpc	r27, r16
    973c:	49 f5       	brne	.+82     	; 0x9790 <writeFile+0x76e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    973e:	88 89       	ldd	r24, Y+16	; 0x10
    9740:	99 89       	ldd	r25, Y+17	; 0x11
    9742:	aa 89       	ldd	r26, Y+18	; 0x12
    9744:	bb 89       	ldd	r27, Y+19	; 0x13
    9746:	bc 01       	movw	r22, r24
    9748:	cd 01       	movw	r24, r26
    974a:	0e 94 e7 4b 	call	0x97ce	; 0x97ce <searchNextFreeCluster>
    974e:	dc 01       	movw	r26, r24
    9750:	cb 01       	movw	r24, r22
    9752:	8c 87       	std	Y+12, r24	; 0x0c
    9754:	9d 87       	std	Y+13, r25	; 0x0d
    9756:	ae 87       	std	Y+14, r26	; 0x0e
    9758:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    975a:	88 89       	ldd	r24, Y+16	; 0x10
    975c:	99 89       	ldd	r25, Y+17	; 0x11
    975e:	aa 89       	ldd	r26, Y+18	; 0x12
    9760:	bb 89       	ldd	r27, Y+19	; 0x13
    9762:	0c 85       	ldd	r16, Y+12	; 0x0c
    9764:	1d 85       	ldd	r17, Y+13	; 0x0d
    9766:	2e 85       	ldd	r18, Y+14	; 0x0e
    9768:	3f 85       	ldd	r19, Y+15	; 0x0f
    976a:	bc 01       	movw	r22, r24
    976c:	cd 01       	movw	r24, r26
    976e:	41 e0       	ldi	r20, 0x01	; 1
    9770:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    9774:	8c 85       	ldd	r24, Y+12	; 0x0c
    9776:	9d 85       	ldd	r25, Y+13	; 0x0d
    9778:	ae 85       	ldd	r26, Y+14	; 0x0e
    977a:	bf 85       	ldd	r27, Y+15	; 0x0f
    977c:	bc 01       	movw	r22, r24
    977e:	cd 01       	movw	r24, r26
    9780:	41 e0       	ldi	r20, 0x01	; 1
    9782:	0f ef       	ldi	r16, 0xFF	; 255
    9784:	1f ef       	ldi	r17, 0xFF	; 255
    9786:	2f ef       	ldi	r18, 0xFF	; 255
    9788:	3f e0       	ldi	r19, 0x0F	; 15
    978a:	0e 94 f7 42 	call	0x85ee	; 0x85ee <getSetNextCluster>
    978e:	02 c0       	rjmp	.+4      	; 0x9794 <writeFile+0x772>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    9790:	83 e0       	ldi	r24, 0x03	; 3
    9792:	13 c0       	rjmp	.+38     	; 0x97ba <writeFile+0x798>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    9794:	8c 85       	ldd	r24, Y+12	; 0x0c
    9796:	9d 85       	ldd	r25, Y+13	; 0x0d
    9798:	ae 85       	ldd	r26, Y+14	; 0x0e
    979a:	bf 85       	ldd	r27, Y+15	; 0x0f
    979c:	00 97       	sbiw	r24, 0x00	; 0
    979e:	a1 05       	cpc	r26, r1
    97a0:	b1 05       	cpc	r27, r1
    97a2:	11 f4       	brne	.+4      	; 0x97a8 <writeFile+0x786>
	   return 4;
    97a4:	84 e0       	ldi	r24, 0x04	; 4
    97a6:	09 c0       	rjmp	.+18     	; 0x97ba <writeFile+0x798>
	}
   
   prevCluster = cluster;
    97a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    97aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    97ac:	ae 85       	ldd	r26, Y+14	; 0x0e
    97ae:	bf 85       	ldd	r27, Y+15	; 0x0f
    97b0:	88 8b       	std	Y+16, r24	; 0x10
    97b2:	99 8b       	std	Y+17, r25	; 0x11
    97b4:	aa 8b       	std	Y+18, r26	; 0x12
    97b6:	bb 8b       	std	Y+19, r27	; 0x13
 }
    97b8:	d0 ce       	rjmp	.-608    	; 0x955a <writeFile+0x538>
 
 return 0;
}
    97ba:	e7 96       	adiw	r28, 0x37	; 55
    97bc:	cd bf       	out	0x3d, r28	; 61
    97be:	de bf       	out	0x3e, r29	; 62
    97c0:	df 91       	pop	r29
    97c2:	cf 91       	pop	r28
    97c4:	1f 91       	pop	r17
    97c6:	0f 91       	pop	r16
    97c8:	ff 90       	pop	r15
    97ca:	ef 90       	pop	r14
    97cc:	08 95       	ret

000097ce <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    97ce:	ef 92       	push	r14
    97d0:	ff 92       	push	r15
    97d2:	0f 93       	push	r16
    97d4:	1f 93       	push	r17
    97d6:	cf 93       	push	r28
    97d8:	df 93       	push	r29
    97da:	cd b7       	in	r28, 0x3d	; 61
    97dc:	de b7       	in	r29, 0x3e	; 62
    97de:	2f 97       	sbiw	r28, 0x0f	; 15
    97e0:	cd bf       	out	0x3d, r28	; 61
    97e2:	de bf       	out	0x3e, r29	; 62
    97e4:	6c 87       	std	Y+12, r22	; 0x0c
    97e6:	7d 87       	std	Y+13, r23	; 0x0d
    97e8:	8e 87       	std	Y+14, r24	; 0x0e
    97ea:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    97ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    97ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    97f0:	ae 85       	ldd	r26, Y+14	; 0x0e
    97f2:	bf 85       	ldd	r27, Y+15	; 0x0f
    97f4:	80 78       	andi	r24, 0x80	; 128
    97f6:	8c 87       	std	Y+12, r24	; 0x0c
    97f8:	9d 87       	std	Y+13, r25	; 0x0d
    97fa:	ae 87       	std	Y+14, r26	; 0x0e
    97fc:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    97fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    9800:	9d 85       	ldd	r25, Y+13	; 0x0d
    9802:	ae 85       	ldd	r26, Y+14	; 0x0e
    9804:	bf 85       	ldd	r27, Y+15	; 0x0f
    9806:	89 83       	std	Y+1, r24	; 0x01
    9808:	9a 83       	std	Y+2, r25	; 0x02
    980a:	ab 83       	std	Y+3, r26	; 0x03
    980c:	bc 83       	std	Y+4, r27	; 0x04
    980e:	7a c0       	rjmp	.+244    	; 0x9904 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9810:	80 91 80 50 	lds	r24, 0x5080
    9814:	90 91 81 50 	lds	r25, 0x5081
    9818:	9c 01       	movw	r18, r24
    981a:	40 e0       	ldi	r20, 0x00	; 0
    981c:	50 e0       	ldi	r21, 0x00	; 0
    981e:	80 91 7a 50 	lds	r24, 0x507A
    9822:	90 91 7b 50 	lds	r25, 0x507B
    9826:	a0 91 7c 50 	lds	r26, 0x507C
    982a:	b0 91 7d 50 	lds	r27, 0x507D
    982e:	79 01       	movw	r14, r18
    9830:	8a 01       	movw	r16, r20
    9832:	e8 0e       	add	r14, r24
    9834:	f9 1e       	adc	r15, r25
    9836:	0a 1f       	adc	r16, r26
    9838:	1b 1f       	adc	r17, r27
    983a:	89 81       	ldd	r24, Y+1	; 0x01
    983c:	9a 81       	ldd	r25, Y+2	; 0x02
    983e:	ab 81       	ldd	r26, Y+3	; 0x03
    9840:	bc 81       	ldd	r27, Y+4	; 0x04
    9842:	88 0f       	add	r24, r24
    9844:	99 1f       	adc	r25, r25
    9846:	aa 1f       	adc	r26, r26
    9848:	bb 1f       	adc	r27, r27
    984a:	88 0f       	add	r24, r24
    984c:	99 1f       	adc	r25, r25
    984e:	aa 1f       	adc	r26, r26
    9850:	bb 1f       	adc	r27, r27
    9852:	20 91 55 40 	lds	r18, 0x4055
    9856:	30 91 56 40 	lds	r19, 0x4056
    985a:	99 01       	movw	r18, r18
    985c:	40 e0       	ldi	r20, 0x00	; 0
    985e:	50 e0       	ldi	r21, 0x00	; 0
    9860:	bc 01       	movw	r22, r24
    9862:	cd 01       	movw	r24, r26
    9864:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    9868:	da 01       	movw	r26, r20
    986a:	c9 01       	movw	r24, r18
    986c:	8e 0d       	add	r24, r14
    986e:	9f 1d       	adc	r25, r15
    9870:	a0 1f       	adc	r26, r16
    9872:	b1 1f       	adc	r27, r17
    9874:	8e 83       	std	Y+6, r24	; 0x06
    9876:	9f 83       	std	Y+7, r25	; 0x07
    9878:	a8 87       	std	Y+8, r26	; 0x08
    987a:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    987c:	8e 81       	ldd	r24, Y+6	; 0x06
    987e:	9f 81       	ldd	r25, Y+7	; 0x07
    9880:	a8 85       	ldd	r26, Y+8	; 0x08
    9882:	b9 85       	ldd	r27, Y+9	; 0x09
    9884:	27 ed       	ldi	r18, 0xD7	; 215
    9886:	31 e2       	ldi	r19, 0x21	; 33
    9888:	bc 01       	movw	r22, r24
    988a:	cd 01       	movw	r24, r26
    988c:	a9 01       	movw	r20, r18
    988e:	0e 94 f1 50 	call	0xa1e2	; 0xa1e2 <SD_read_block>
      for(i=0; i<128; i++)
    9892:	1d 82       	std	Y+5, r1	; 0x05
    9894:	28 c0       	rjmp	.+80     	; 0x98e6 <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    9896:	8d 81       	ldd	r24, Y+5	; 0x05
    9898:	88 2f       	mov	r24, r24
    989a:	90 e0       	ldi	r25, 0x00	; 0
    989c:	88 0f       	add	r24, r24
    989e:	99 1f       	adc	r25, r25
    98a0:	88 0f       	add	r24, r24
    98a2:	99 1f       	adc	r25, r25
    98a4:	89 52       	subi	r24, 0x29	; 41
    98a6:	9e 4d       	sbci	r25, 0xDE	; 222
    98a8:	8a 87       	std	Y+10, r24	; 0x0a
    98aa:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    98ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    98ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    98b0:	fc 01       	movw	r30, r24
    98b2:	80 81       	ld	r24, Z
    98b4:	91 81       	ldd	r25, Z+1	; 0x01
    98b6:	a2 81       	ldd	r26, Z+2	; 0x02
    98b8:	b3 81       	ldd	r27, Z+3	; 0x03
    98ba:	bf 70       	andi	r27, 0x0F	; 15
    98bc:	00 97       	sbiw	r24, 0x00	; 0
    98be:	a1 05       	cpc	r26, r1
    98c0:	b1 05       	cpc	r27, r1
    98c2:	71 f4       	brne	.+28     	; 0x98e0 <searchNextFreeCluster+0x112>
            return(cluster+i);
    98c4:	8d 81       	ldd	r24, Y+5	; 0x05
    98c6:	28 2f       	mov	r18, r24
    98c8:	30 e0       	ldi	r19, 0x00	; 0
    98ca:	40 e0       	ldi	r20, 0x00	; 0
    98cc:	50 e0       	ldi	r21, 0x00	; 0
    98ce:	89 81       	ldd	r24, Y+1	; 0x01
    98d0:	9a 81       	ldd	r25, Y+2	; 0x02
    98d2:	ab 81       	ldd	r26, Y+3	; 0x03
    98d4:	bc 81       	ldd	r27, Y+4	; 0x04
    98d6:	82 0f       	add	r24, r18
    98d8:	93 1f       	adc	r25, r19
    98da:	a4 1f       	adc	r26, r20
    98dc:	b5 1f       	adc	r27, r21
    98de:	27 c0       	rjmp	.+78     	; 0x992e <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    98e0:	8d 81       	ldd	r24, Y+5	; 0x05
    98e2:	8f 5f       	subi	r24, 0xFF	; 255
    98e4:	8d 83       	std	Y+5, r24	; 0x05
    98e6:	8d 81       	ldd	r24, Y+5	; 0x05
    98e8:	88 23       	and	r24, r24
    98ea:	ac f6       	brge	.-86     	; 0x9896 <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    98ec:	89 81       	ldd	r24, Y+1	; 0x01
    98ee:	9a 81       	ldd	r25, Y+2	; 0x02
    98f0:	ab 81       	ldd	r26, Y+3	; 0x03
    98f2:	bc 81       	ldd	r27, Y+4	; 0x04
    98f4:	80 58       	subi	r24, 0x80	; 128
    98f6:	9f 4f       	sbci	r25, 0xFF	; 255
    98f8:	af 4f       	sbci	r26, 0xFF	; 255
    98fa:	bf 4f       	sbci	r27, 0xFF	; 255
    98fc:	89 83       	std	Y+1, r24	; 0x01
    98fe:	9a 83       	std	Y+2, r25	; 0x02
    9900:	ab 83       	std	Y+3, r26	; 0x03
    9902:	bc 83       	std	Y+4, r27	; 0x04
    9904:	80 91 5a 40 	lds	r24, 0x405A
    9908:	90 91 5b 40 	lds	r25, 0x405B
    990c:	a0 91 5c 40 	lds	r26, 0x405C
    9910:	b0 91 5d 40 	lds	r27, 0x405D
    9914:	29 81       	ldd	r18, Y+1	; 0x01
    9916:	3a 81       	ldd	r19, Y+2	; 0x02
    9918:	4b 81       	ldd	r20, Y+3	; 0x03
    991a:	5c 81       	ldd	r21, Y+4	; 0x04
    991c:	28 17       	cp	r18, r24
    991e:	39 07       	cpc	r19, r25
    9920:	4a 07       	cpc	r20, r26
    9922:	5b 07       	cpc	r21, r27
    9924:	08 f4       	brcc	.+2      	; 0x9928 <searchNextFreeCluster+0x15a>
    9926:	74 cf       	rjmp	.-280    	; 0x9810 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    9928:	80 e0       	ldi	r24, 0x00	; 0
    992a:	90 e0       	ldi	r25, 0x00	; 0
    992c:	dc 01       	movw	r26, r24
}
    992e:	bc 01       	movw	r22, r24
    9930:	cd 01       	movw	r24, r26
    9932:	2f 96       	adiw	r28, 0x0f	; 15
    9934:	cd bf       	out	0x3d, r28	; 61
    9936:	de bf       	out	0x3e, r29	; 62
    9938:	df 91       	pop	r29
    993a:	cf 91       	pop	r28
    993c:	1f 91       	pop	r17
    993e:	0f 91       	pop	r16
    9940:	ff 90       	pop	r15
    9942:	ef 90       	pop	r14
    9944:	08 95       	ret

00009946 <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    9946:	cf 93       	push	r28
    9948:	df 93       	push	r29
    994a:	00 d0       	rcall	.+0      	; 0x994c <deleteFile+0x6>
    994c:	cd b7       	in	r28, 0x3d	; 61
    994e:	de b7       	in	r29, 0x3e	; 62
    9950:	8a 83       	std	Y+2, r24	; 0x02
    9952:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9954:	8a 81       	ldd	r24, Y+2	; 0x02
    9956:	9b 81       	ldd	r25, Y+3	; 0x03
    9958:	0e 94 db 46 	call	0x8db6	; 0x8db6 <convertFileName>
    995c:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    995e:	89 81       	ldd	r24, Y+1	; 0x01
    9960:	88 23       	and	r24, r24
    9962:	39 f4       	brne	.+14     	; 0x9972 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9964:	28 eb       	ldi	r18, 0xB8	; 184
    9966:	30 e5       	ldi	r19, 0x50	; 80
    9968:	82 e0       	ldi	r24, 0x02	; 2
    996a:	b9 01       	movw	r22, r18
    996c:	0e 94 52 44 	call	0x88a4	; 0x88a4 <findFiles>
    9970:	01 c0       	rjmp	.+2      	; 0x9974 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9972:	00 00       	nop

  findFiles (DELETE, Filename);
}
    9974:	23 96       	adiw	r28, 0x03	; 3
    9976:	cd bf       	out	0x3d, r28	; 61
    9978:	de bf       	out	0x3e, r29	; 62
    997a:	df 91       	pop	r29
    997c:	cf 91       	pop	r28
    997e:	08 95       	ret

00009980 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9980:	ef 92       	push	r14
    9982:	ff 92       	push	r15
    9984:	0f 93       	push	r16
    9986:	1f 93       	push	r17
    9988:	cf 93       	push	r28
    998a:	df 93       	push	r29
    998c:	cd b7       	in	r28, 0x3d	; 61
    998e:	de b7       	in	r29, 0x3e	; 62
    9990:	29 97       	sbiw	r28, 0x09	; 9
    9992:	cd bf       	out	0x3d, r28	; 61
    9994:	de bf       	out	0x3e, r29	; 62
    9996:	8d 83       	std	Y+5, r24	; 0x05
    9998:	4e 83       	std	Y+6, r20	; 0x06
    999a:	5f 83       	std	Y+7, r21	; 0x07
    999c:	68 87       	std	Y+8, r22	; 0x08
    999e:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    99a0:	8e 81       	ldd	r24, Y+6	; 0x06
    99a2:	9f 81       	ldd	r25, Y+7	; 0x07
    99a4:	a8 85       	ldd	r26, Y+8	; 0x08
    99a6:	b9 85       	ldd	r27, Y+9	; 0x09
    99a8:	91 70       	andi	r25, 0x01	; 1
    99aa:	a0 70       	andi	r26, 0x00	; 0
    99ac:	b0 70       	andi	r27, 0x00	; 0
    99ae:	00 97       	sbiw	r24, 0x00	; 0
    99b0:	a1 05       	cpc	r26, r1
    99b2:	b1 05       	cpc	r27, r1
    99b4:	91 f4       	brne	.+36     	; 0x99da <freeMemoryUpdate+0x5a>
    99b6:	8e 81       	ldd	r24, Y+6	; 0x06
    99b8:	9f 81       	ldd	r25, Y+7	; 0x07
    99ba:	a8 85       	ldd	r26, Y+8	; 0x08
    99bc:	b9 85       	ldd	r27, Y+9	; 0x09
    99be:	07 2e       	mov	r0, r23
    99c0:	79 e0       	ldi	r23, 0x09	; 9
    99c2:	b6 95       	lsr	r27
    99c4:	a7 95       	ror	r26
    99c6:	97 95       	ror	r25
    99c8:	87 95       	ror	r24
    99ca:	7a 95       	dec	r23
    99cc:	d1 f7       	brne	.-12     	; 0x99c2 <freeMemoryUpdate+0x42>
    99ce:	70 2d       	mov	r23, r0
    99d0:	8e 83       	std	Y+6, r24	; 0x06
    99d2:	9f 83       	std	Y+7, r25	; 0x07
    99d4:	a8 87       	std	Y+8, r26	; 0x08
    99d6:	b9 87       	std	Y+9, r27	; 0x09
    99d8:	14 c0       	rjmp	.+40     	; 0x9a02 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    99da:	8e 81       	ldd	r24, Y+6	; 0x06
    99dc:	9f 81       	ldd	r25, Y+7	; 0x07
    99de:	a8 85       	ldd	r26, Y+8	; 0x08
    99e0:	b9 85       	ldd	r27, Y+9	; 0x09
    99e2:	07 2e       	mov	r0, r23
    99e4:	79 e0       	ldi	r23, 0x09	; 9
    99e6:	b6 95       	lsr	r27
    99e8:	a7 95       	ror	r26
    99ea:	97 95       	ror	r25
    99ec:	87 95       	ror	r24
    99ee:	7a 95       	dec	r23
    99f0:	d1 f7       	brne	.-12     	; 0x99e6 <freeMemoryUpdate+0x66>
    99f2:	70 2d       	mov	r23, r0
    99f4:	01 96       	adiw	r24, 0x01	; 1
    99f6:	a1 1d       	adc	r26, r1
    99f8:	b1 1d       	adc	r27, r1
    99fa:	8e 83       	std	Y+6, r24	; 0x06
    99fc:	9f 83       	std	Y+7, r25	; 0x07
    99fe:	a8 87       	std	Y+8, r26	; 0x08
    9a00:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9a02:	8e 81       	ldd	r24, Y+6	; 0x06
    9a04:	9f 81       	ldd	r25, Y+7	; 0x07
    9a06:	a8 85       	ldd	r26, Y+8	; 0x08
    9a08:	b9 85       	ldd	r27, Y+9	; 0x09
    9a0a:	87 70       	andi	r24, 0x07	; 7
    9a0c:	90 70       	andi	r25, 0x00	; 0
    9a0e:	a0 70       	andi	r26, 0x00	; 0
    9a10:	b0 70       	andi	r27, 0x00	; 0
    9a12:	00 97       	sbiw	r24, 0x00	; 0
    9a14:	a1 05       	cpc	r26, r1
    9a16:	b1 05       	cpc	r27, r1
    9a18:	89 f4       	brne	.+34     	; 0x9a3c <freeMemoryUpdate+0xbc>
    9a1a:	8e 81       	ldd	r24, Y+6	; 0x06
    9a1c:	9f 81       	ldd	r25, Y+7	; 0x07
    9a1e:	a8 85       	ldd	r26, Y+8	; 0x08
    9a20:	b9 85       	ldd	r27, Y+9	; 0x09
    9a22:	68 94       	set
    9a24:	12 f8       	bld	r1, 2
    9a26:	b6 95       	lsr	r27
    9a28:	a7 95       	ror	r26
    9a2a:	97 95       	ror	r25
    9a2c:	87 95       	ror	r24
    9a2e:	16 94       	lsr	r1
    9a30:	d1 f7       	brne	.-12     	; 0x9a26 <freeMemoryUpdate+0xa6>
    9a32:	8e 83       	std	Y+6, r24	; 0x06
    9a34:	9f 83       	std	Y+7, r25	; 0x07
    9a36:	a8 87       	std	Y+8, r26	; 0x08
    9a38:	b9 87       	std	Y+9, r27	; 0x09
    9a3a:	13 c0       	rjmp	.+38     	; 0x9a62 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    9a3c:	8e 81       	ldd	r24, Y+6	; 0x06
    9a3e:	9f 81       	ldd	r25, Y+7	; 0x07
    9a40:	a8 85       	ldd	r26, Y+8	; 0x08
    9a42:	b9 85       	ldd	r27, Y+9	; 0x09
    9a44:	68 94       	set
    9a46:	12 f8       	bld	r1, 2
    9a48:	b6 95       	lsr	r27
    9a4a:	a7 95       	ror	r26
    9a4c:	97 95       	ror	r25
    9a4e:	87 95       	ror	r24
    9a50:	16 94       	lsr	r1
    9a52:	d1 f7       	brne	.-12     	; 0x9a48 <freeMemoryUpdate+0xc8>
    9a54:	01 96       	adiw	r24, 0x01	; 1
    9a56:	a1 1d       	adc	r26, r1
    9a58:	b1 1d       	adc	r27, r1
    9a5a:	8e 83       	std	Y+6, r24	; 0x06
    9a5c:	9f 83       	std	Y+7, r25	; 0x07
    9a5e:	a8 87       	std	Y+8, r26	; 0x08
    9a60:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9a62:	80 91 cc 50 	lds	r24, 0x50CC
    9a66:	88 23       	and	r24, r24
    9a68:	e9 f1       	breq	.+122    	; 0x9ae4 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    9a6a:	81 e0       	ldi	r24, 0x01	; 1
    9a6c:	60 e0       	ldi	r22, 0x00	; 0
    9a6e:	20 e0       	ldi	r18, 0x00	; 0
    9a70:	30 e0       	ldi	r19, 0x00	; 0
    9a72:	a9 01       	movw	r20, r18
    9a74:	0e 94 a1 43 	call	0x8742	; 0x8742 <getSetFreeCluster>
    9a78:	dc 01       	movw	r26, r24
    9a7a:	cb 01       	movw	r24, r22
    9a7c:	89 83       	std	Y+1, r24	; 0x01
    9a7e:	9a 83       	std	Y+2, r25	; 0x02
    9a80:	ab 83       	std	Y+3, r26	; 0x03
    9a82:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9a84:	8d 81       	ldd	r24, Y+5	; 0x05
    9a86:	88 23       	and	r24, r24
    9a88:	89 f4       	brne	.+34     	; 0x9aac <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    9a8a:	29 81       	ldd	r18, Y+1	; 0x01
    9a8c:	3a 81       	ldd	r19, Y+2	; 0x02
    9a8e:	4b 81       	ldd	r20, Y+3	; 0x03
    9a90:	5c 81       	ldd	r21, Y+4	; 0x04
    9a92:	8e 81       	ldd	r24, Y+6	; 0x06
    9a94:	9f 81       	ldd	r25, Y+7	; 0x07
    9a96:	a8 85       	ldd	r26, Y+8	; 0x08
    9a98:	b9 85       	ldd	r27, Y+9	; 0x09
    9a9a:	82 0f       	add	r24, r18
    9a9c:	93 1f       	adc	r25, r19
    9a9e:	a4 1f       	adc	r26, r20
    9aa0:	b5 1f       	adc	r27, r21
    9aa2:	89 83       	std	Y+1, r24	; 0x01
    9aa4:	9a 83       	std	Y+2, r25	; 0x02
    9aa6:	ab 83       	std	Y+3, r26	; 0x03
    9aa8:	bc 83       	std	Y+4, r27	; 0x04
    9aaa:	14 c0       	rjmp	.+40     	; 0x9ad4 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    9aac:	29 81       	ldd	r18, Y+1	; 0x01
    9aae:	3a 81       	ldd	r19, Y+2	; 0x02
    9ab0:	4b 81       	ldd	r20, Y+3	; 0x03
    9ab2:	5c 81       	ldd	r21, Y+4	; 0x04
    9ab4:	8e 81       	ldd	r24, Y+6	; 0x06
    9ab6:	9f 81       	ldd	r25, Y+7	; 0x07
    9ab8:	a8 85       	ldd	r26, Y+8	; 0x08
    9aba:	b9 85       	ldd	r27, Y+9	; 0x09
    9abc:	79 01       	movw	r14, r18
    9abe:	8a 01       	movw	r16, r20
    9ac0:	e8 1a       	sub	r14, r24
    9ac2:	f9 0a       	sbc	r15, r25
    9ac4:	0a 0b       	sbc	r16, r26
    9ac6:	1b 0b       	sbc	r17, r27
    9ac8:	d8 01       	movw	r26, r16
    9aca:	c7 01       	movw	r24, r14
    9acc:	89 83       	std	Y+1, r24	; 0x01
    9ace:	9a 83       	std	Y+2, r25	; 0x02
    9ad0:	ab 83       	std	Y+3, r26	; 0x03
    9ad2:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9ad4:	29 81       	ldd	r18, Y+1	; 0x01
    9ad6:	3a 81       	ldd	r19, Y+2	; 0x02
    9ad8:	4b 81       	ldd	r20, Y+3	; 0x03
    9ada:	5c 81       	ldd	r21, Y+4	; 0x04
    9adc:	81 e0       	ldi	r24, 0x01	; 1
    9ade:	61 e0       	ldi	r22, 0x01	; 1
    9ae0:	0e 94 a1 43 	call	0x8742	; 0x8742 <getSetFreeCluster>
  }
}
    9ae4:	29 96       	adiw	r28, 0x09	; 9
    9ae6:	cd bf       	out	0x3d, r28	; 61
    9ae8:	de bf       	out	0x3e, r29	; 62
    9aea:	df 91       	pop	r29
    9aec:	cf 91       	pop	r28
    9aee:	1f 91       	pop	r17
    9af0:	0f 91       	pop	r16
    9af2:	ff 90       	pop	r15
    9af4:	ef 90       	pop	r14
    9af6:	08 95       	ret

00009af8 <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    9af8:	0f 93       	push	r16
    9afa:	1f 93       	push	r17
    9afc:	cf 93       	push	r28
    9afe:	df 93       	push	r29
    9b00:	cd b7       	in	r28, 0x3d	; 61
    9b02:	de b7       	in	r29, 0x3e	; 62
    9b04:	a9 97       	sbiw	r28, 0x29	; 41
    9b06:	cd bf       	out	0x3d, r28	; 61
    9b08:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    9b0a:	81 e0       	ldi	r24, 0x01	; 1
    9b0c:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9b10:	81 e0       	ldi	r24, 0x01	; 1
    9b12:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <Ext1Power>
    9b16:	80 e0       	ldi	r24, 0x00	; 0
    9b18:	90 e0       	ldi	r25, 0x00	; 0
    9b1a:	a8 ec       	ldi	r26, 0xC8	; 200
    9b1c:	b2 e4       	ldi	r27, 0x42	; 66
    9b1e:	8e 87       	std	Y+14, r24	; 0x0e
    9b20:	9f 87       	std	Y+15, r25	; 0x0f
    9b22:	a8 8b       	std	Y+16, r26	; 0x10
    9b24:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9b26:	6e 85       	ldd	r22, Y+14	; 0x0e
    9b28:	7f 85       	ldd	r23, Y+15	; 0x0f
    9b2a:	88 89       	ldd	r24, Y+16	; 0x10
    9b2c:	99 89       	ldd	r25, Y+17	; 0x11
    9b2e:	20 e0       	ldi	r18, 0x00	; 0
    9b30:	30 e0       	ldi	r19, 0x00	; 0
    9b32:	4a ef       	ldi	r20, 0xFA	; 250
    9b34:	55 e4       	ldi	r21, 0x45	; 69
    9b36:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    9b3a:	dc 01       	movw	r26, r24
    9b3c:	cb 01       	movw	r24, r22
    9b3e:	8a 8b       	std	Y+18, r24	; 0x12
    9b40:	9b 8b       	std	Y+19, r25	; 0x13
    9b42:	ac 8b       	std	Y+20, r26	; 0x14
    9b44:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9b46:	11 e0       	ldi	r17, 0x01	; 1
    9b48:	6a 89       	ldd	r22, Y+18	; 0x12
    9b4a:	7b 89       	ldd	r23, Y+19	; 0x13
    9b4c:	8c 89       	ldd	r24, Y+20	; 0x14
    9b4e:	9d 89       	ldd	r25, Y+21	; 0x15
    9b50:	20 e0       	ldi	r18, 0x00	; 0
    9b52:	30 e0       	ldi	r19, 0x00	; 0
    9b54:	40 e8       	ldi	r20, 0x80	; 128
    9b56:	5f e3       	ldi	r21, 0x3F	; 63
    9b58:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    9b5c:	88 23       	and	r24, r24
    9b5e:	0c f0       	brlt	.+2      	; 0x9b62 <SD_init+0x6a>
    9b60:	10 e0       	ldi	r17, 0x00	; 0
    9b62:	11 23       	and	r17, r17
    9b64:	29 f0       	breq	.+10     	; 0x9b70 <SD_init+0x78>
		__ticks = 1;
    9b66:	81 e0       	ldi	r24, 0x01	; 1
    9b68:	90 e0       	ldi	r25, 0x00	; 0
    9b6a:	8e 8b       	std	Y+22, r24	; 0x16
    9b6c:	9f 8b       	std	Y+23, r25	; 0x17
    9b6e:	46 c0       	rjmp	.+140    	; 0x9bfc <SD_init+0x104>
	else if (__tmp > 65535)
    9b70:	11 e0       	ldi	r17, 0x01	; 1
    9b72:	6a 89       	ldd	r22, Y+18	; 0x12
    9b74:	7b 89       	ldd	r23, Y+19	; 0x13
    9b76:	8c 89       	ldd	r24, Y+20	; 0x14
    9b78:	9d 89       	ldd	r25, Y+21	; 0x15
    9b7a:	20 e0       	ldi	r18, 0x00	; 0
    9b7c:	3f ef       	ldi	r19, 0xFF	; 255
    9b7e:	4f e7       	ldi	r20, 0x7F	; 127
    9b80:	57 e4       	ldi	r21, 0x47	; 71
    9b82:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    9b86:	18 16       	cp	r1, r24
    9b88:	0c f0       	brlt	.+2      	; 0x9b8c <SD_init+0x94>
    9b8a:	10 e0       	ldi	r17, 0x00	; 0
    9b8c:	11 23       	and	r17, r17
    9b8e:	61 f1       	breq	.+88     	; 0x9be8 <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9b90:	6e 85       	ldd	r22, Y+14	; 0x0e
    9b92:	7f 85       	ldd	r23, Y+15	; 0x0f
    9b94:	88 89       	ldd	r24, Y+16	; 0x10
    9b96:	99 89       	ldd	r25, Y+17	; 0x11
    9b98:	20 e0       	ldi	r18, 0x00	; 0
    9b9a:	30 e0       	ldi	r19, 0x00	; 0
    9b9c:	40 e2       	ldi	r20, 0x20	; 32
    9b9e:	51 e4       	ldi	r21, 0x41	; 65
    9ba0:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    9ba4:	dc 01       	movw	r26, r24
    9ba6:	cb 01       	movw	r24, r22
    9ba8:	bc 01       	movw	r22, r24
    9baa:	cd 01       	movw	r24, r26
    9bac:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    9bb0:	dc 01       	movw	r26, r24
    9bb2:	cb 01       	movw	r24, r22
    9bb4:	8e 8b       	std	Y+22, r24	; 0x16
    9bb6:	9f 8b       	std	Y+23, r25	; 0x17
    9bb8:	12 c0       	rjmp	.+36     	; 0x9bde <SD_init+0xe6>
    9bba:	80 e2       	ldi	r24, 0x20	; 32
    9bbc:	93 e0       	ldi	r25, 0x03	; 3
    9bbe:	88 8f       	std	Y+24, r24	; 0x18
    9bc0:	99 8f       	std	Y+25, r25	; 0x19
    9bc2:	88 8d       	ldd	r24, Y+24	; 0x18
    9bc4:	99 8d       	ldd	r25, Y+25	; 0x19
    9bc6:	8c 01       	movw	r16, r24
    9bc8:	c8 01       	movw	r24, r16
    9bca:	01 97       	sbiw	r24, 0x01	; 1
    9bcc:	f1 f7       	brne	.-4      	; 0x9bca <SD_init+0xd2>
    9bce:	8c 01       	movw	r16, r24
    9bd0:	08 8f       	std	Y+24, r16	; 0x18
    9bd2:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9bd4:	8e 89       	ldd	r24, Y+22	; 0x16
    9bd6:	9f 89       	ldd	r25, Y+23	; 0x17
    9bd8:	01 97       	sbiw	r24, 0x01	; 1
    9bda:	8e 8b       	std	Y+22, r24	; 0x16
    9bdc:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9bde:	8e 89       	ldd	r24, Y+22	; 0x16
    9be0:	9f 89       	ldd	r25, Y+23	; 0x17
    9be2:	00 97       	sbiw	r24, 0x00	; 0
    9be4:	51 f7       	brne	.-44     	; 0x9bba <SD_init+0xc2>
    9be6:	17 c0       	rjmp	.+46     	; 0x9c16 <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9be8:	6a 89       	ldd	r22, Y+18	; 0x12
    9bea:	7b 89       	ldd	r23, Y+19	; 0x13
    9bec:	8c 89       	ldd	r24, Y+20	; 0x14
    9bee:	9d 89       	ldd	r25, Y+21	; 0x15
    9bf0:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    9bf4:	dc 01       	movw	r26, r24
    9bf6:	cb 01       	movw	r24, r22
    9bf8:	8e 8b       	std	Y+22, r24	; 0x16
    9bfa:	9f 8b       	std	Y+23, r25	; 0x17
    9bfc:	8e 89       	ldd	r24, Y+22	; 0x16
    9bfe:	9f 89       	ldd	r25, Y+23	; 0x17
    9c00:	8a 8f       	std	Y+26, r24	; 0x1a
    9c02:	9b 8f       	std	Y+27, r25	; 0x1b
    9c04:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9c06:	9b 8d       	ldd	r25, Y+27	; 0x1b
    9c08:	8c 01       	movw	r16, r24
    9c0a:	f8 01       	movw	r30, r16
    9c0c:	31 97       	sbiw	r30, 0x01	; 1
    9c0e:	f1 f7       	brne	.-4      	; 0x9c0c <SD_init+0x114>
    9c10:	8f 01       	movw	r16, r30
    9c12:	0a 8f       	std	Y+26, r16	; 0x1a
    9c14:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9c16:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    9c18:	88 e0       	ldi	r24, 0x08	; 8
    9c1a:	60 e0       	ldi	r22, 0x00	; 0
    9c1c:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9c20:	88 e0       	ldi	r24, 0x08	; 8
    9c22:	60 e0       	ldi	r22, 0x00	; 0
    9c24:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9c28:	80 e0       	ldi	r24, 0x00	; 0
    9c2a:	90 e0       	ldi	r25, 0x00	; 0
    9c2c:	63 e0       	ldi	r22, 0x03	; 3
    9c2e:	70 e0       	ldi	r23, 0x00	; 0
    9c30:	0e 94 d9 39 	call	0x73b2	; 0x73b2 <SPIInit2>
	SPICS(TRUE);
    9c34:	81 e0       	ldi	r24, 0x01	; 1
    9c36:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9c3a:	1a 82       	std	Y+2, r1	; 0x02
    9c3c:	1b 82       	std	Y+3, r1	; 0x03
    9c3e:	17 c0       	rjmp	.+46     	; 0x9c6e <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9c40:	80 ec       	ldi	r24, 0xC0	; 192
    9c42:	98 e0       	ldi	r25, 0x08	; 8
    9c44:	2f ef       	ldi	r18, 0xFF	; 255
    9c46:	fc 01       	movw	r30, r24
    9c48:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9c4a:	00 00       	nop
    9c4c:	80 ec       	ldi	r24, 0xC0	; 192
    9c4e:	98 e0       	ldi	r25, 0x08	; 8
    9c50:	fc 01       	movw	r30, r24
    9c52:	82 81       	ldd	r24, Z+2	; 0x02
    9c54:	88 23       	and	r24, r24
    9c56:	d4 f7       	brge	.-12     	; 0x9c4c <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    9c58:	80 ec       	ldi	r24, 0xC0	; 192
    9c5a:	98 e0       	ldi	r25, 0x08	; 8
    9c5c:	fc 01       	movw	r30, r24
    9c5e:	83 81       	ldd	r24, Z+3	; 0x03
    9c60:	80 93 b7 50 	sts	0x50B7, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9c64:	8a 81       	ldd	r24, Y+2	; 0x02
    9c66:	9b 81       	ldd	r25, Y+3	; 0x03
    9c68:	01 96       	adiw	r24, 0x01	; 1
    9c6a:	8a 83       	std	Y+2, r24	; 0x02
    9c6c:	9b 83       	std	Y+3, r25	; 0x03
    9c6e:	8a 81       	ldd	r24, Y+2	; 0x02
    9c70:	9b 81       	ldd	r25, Y+3	; 0x03
    9c72:	8a 30       	cpi	r24, 0x0A	; 10
    9c74:	91 05       	cpc	r25, r1
    9c76:	24 f3       	brlt	.-56     	; 0x9c40 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    9c78:	80 e0       	ldi	r24, 0x00	; 0
    9c7a:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    9c7e:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9c82:	88 e0       	ldi	r24, 0x08	; 8
    9c84:	60 e0       	ldi	r22, 0x00	; 0
    9c86:	0e 94 44 36 	call	0x6c88	; 0x6c88 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9c8a:	80 e0       	ldi	r24, 0x00	; 0
    9c8c:	90 e0       	ldi	r25, 0x00	; 0
    9c8e:	63 e0       	ldi	r22, 0x03	; 3
    9c90:	70 e0       	ldi	r23, 0x00	; 0
    9c92:	0e 94 d9 39 	call	0x73b2	; 0x73b2 <SPIInit2>
	SPICS(TRUE);
    9c96:	81 e0       	ldi	r24, 0x01	; 1
    9c98:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9c9c:	1c 82       	std	Y+4, r1	; 0x04
    9c9e:	1d 82       	std	Y+5, r1	; 0x05
    9ca0:	0d c0       	rjmp	.+26     	; 0x9cbc <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    9ca2:	8c 81       	ldd	r24, Y+4	; 0x04
    9ca4:	9d 81       	ldd	r25, Y+5	; 0x05
    9ca6:	8a 30       	cpi	r24, 0x0A	; 10
    9ca8:	91 05       	cpc	r25, r1
    9caa:	1c f0       	brlt	.+6      	; 0x9cb2 <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    9cac:	81 e0       	ldi	r24, 0x01	; 1
    9cae:	89 83       	std	Y+1, r24	; 0x01
			break;
    9cb0:	10 c0       	rjmp	.+32     	; 0x9cd2 <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9cb2:	8c 81       	ldd	r24, Y+4	; 0x04
    9cb4:	9d 81       	ldd	r25, Y+5	; 0x05
    9cb6:	01 96       	adiw	r24, 0x01	; 1
    9cb8:	8c 83       	std	Y+4, r24	; 0x04
    9cba:	9d 83       	std	Y+5, r25	; 0x05
    9cbc:	80 e0       	ldi	r24, 0x00	; 0
    9cbe:	40 e0       	ldi	r20, 0x00	; 0
    9cc0:	50 e0       	ldi	r21, 0x00	; 0
    9cc2:	ba 01       	movw	r22, r20
    9cc4:	25 e9       	ldi	r18, 0x95	; 149
    9cc6:	08 e0       	ldi	r16, 0x08	; 8
    9cc8:	10 e0       	ldi	r17, 0x00	; 0
    9cca:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
    9cce:	81 30       	cpi	r24, 0x01	; 1
    9cd0:	41 f7       	brne	.-48     	; 0x9ca2 <SD_init+0x1aa>
    9cd2:	80 e0       	ldi	r24, 0x00	; 0
    9cd4:	90 e0       	ldi	r25, 0x00	; 0
    9cd6:	a8 ec       	ldi	r26, 0xC8	; 200
    9cd8:	b2 e4       	ldi	r27, 0x42	; 66
    9cda:	8c 8f       	std	Y+28, r24	; 0x1c
    9cdc:	9d 8f       	std	Y+29, r25	; 0x1d
    9cde:	ae 8f       	std	Y+30, r26	; 0x1e
    9ce0:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9ce2:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9ce4:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9ce6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9ce8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9cea:	20 e0       	ldi	r18, 0x00	; 0
    9cec:	30 e0       	ldi	r19, 0x00	; 0
    9cee:	4a ef       	ldi	r20, 0xFA	; 250
    9cf0:	55 e4       	ldi	r21, 0x45	; 69
    9cf2:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    9cf6:	dc 01       	movw	r26, r24
    9cf8:	cb 01       	movw	r24, r22
    9cfa:	88 a3       	lds	r24, 0x58
    9cfc:	99 a3       	lds	r25, 0x59
    9cfe:	aa a3       	lds	r26, 0x5a
    9d00:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    9d02:	11 e0       	ldi	r17, 0x01	; 1
    9d04:	68 a1       	lds	r22, 0x48
    9d06:	79 a1       	lds	r23, 0x49
    9d08:	8a a1       	lds	r24, 0x4a
    9d0a:	9b a1       	lds	r25, 0x4b
    9d0c:	20 e0       	ldi	r18, 0x00	; 0
    9d0e:	30 e0       	ldi	r19, 0x00	; 0
    9d10:	40 e8       	ldi	r20, 0x80	; 128
    9d12:	5f e3       	ldi	r21, 0x3F	; 63
    9d14:	0e 94 fe 5c 	call	0xb9fc	; 0xb9fc <__cmpsf2>
    9d18:	88 23       	and	r24, r24
    9d1a:	0c f0       	brlt	.+2      	; 0x9d1e <SD_init+0x226>
    9d1c:	10 e0       	ldi	r17, 0x00	; 0
    9d1e:	11 23       	and	r17, r17
    9d20:	29 f0       	breq	.+10     	; 0x9d2c <SD_init+0x234>
		__ticks = 1;
    9d22:	81 e0       	ldi	r24, 0x01	; 1
    9d24:	90 e0       	ldi	r25, 0x00	; 0
    9d26:	8c a3       	lds	r24, 0x5c
    9d28:	9d a3       	lds	r25, 0x5d
    9d2a:	46 c0       	rjmp	.+140    	; 0x9db8 <SD_init+0x2c0>
	else if (__tmp > 65535)
    9d2c:	11 e0       	ldi	r17, 0x01	; 1
    9d2e:	68 a1       	lds	r22, 0x48
    9d30:	79 a1       	lds	r23, 0x49
    9d32:	8a a1       	lds	r24, 0x4a
    9d34:	9b a1       	lds	r25, 0x4b
    9d36:	20 e0       	ldi	r18, 0x00	; 0
    9d38:	3f ef       	ldi	r19, 0xFF	; 255
    9d3a:	4f e7       	ldi	r20, 0x7F	; 127
    9d3c:	57 e4       	ldi	r21, 0x47	; 71
    9d3e:	0e 94 0b 5e 	call	0xbc16	; 0xbc16 <__gesf2>
    9d42:	18 16       	cp	r1, r24
    9d44:	0c f0       	brlt	.+2      	; 0x9d48 <SD_init+0x250>
    9d46:	10 e0       	ldi	r17, 0x00	; 0
    9d48:	11 23       	and	r17, r17
    9d4a:	61 f1       	breq	.+88     	; 0x9da4 <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9d4c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9d4e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9d50:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9d52:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9d54:	20 e0       	ldi	r18, 0x00	; 0
    9d56:	30 e0       	ldi	r19, 0x00	; 0
    9d58:	40 e2       	ldi	r20, 0x20	; 32
    9d5a:	51 e4       	ldi	r21, 0x41	; 65
    9d5c:	0e 94 0f 5e 	call	0xbc1e	; 0xbc1e <__mulsf3>
    9d60:	dc 01       	movw	r26, r24
    9d62:	cb 01       	movw	r24, r22
    9d64:	bc 01       	movw	r22, r24
    9d66:	cd 01       	movw	r24, r26
    9d68:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    9d6c:	dc 01       	movw	r26, r24
    9d6e:	cb 01       	movw	r24, r22
    9d70:	8c a3       	lds	r24, 0x5c
    9d72:	9d a3       	lds	r25, 0x5d
    9d74:	12 c0       	rjmp	.+36     	; 0x9d9a <SD_init+0x2a2>
    9d76:	80 e2       	ldi	r24, 0x20	; 32
    9d78:	93 e0       	ldi	r25, 0x03	; 3
    9d7a:	8e a3       	lds	r24, 0x5e
    9d7c:	9f a3       	lds	r25, 0x5f
    9d7e:	8e a1       	lds	r24, 0x4e
    9d80:	9f a1       	lds	r25, 0x4f
    9d82:	8c 01       	movw	r16, r24
    9d84:	c8 01       	movw	r24, r16
    9d86:	01 97       	sbiw	r24, 0x01	; 1
    9d88:	f1 f7       	brne	.-4      	; 0x9d86 <SD_init+0x28e>
    9d8a:	8c 01       	movw	r16, r24
    9d8c:	0e a3       	lds	r16, 0x5e
    9d8e:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9d90:	8c a1       	lds	r24, 0x4c
    9d92:	9d a1       	lds	r25, 0x4d
    9d94:	01 97       	sbiw	r24, 0x01	; 1
    9d96:	8c a3       	lds	r24, 0x5c
    9d98:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9d9a:	8c a1       	lds	r24, 0x4c
    9d9c:	9d a1       	lds	r25, 0x4d
    9d9e:	00 97       	sbiw	r24, 0x00	; 0
    9da0:	51 f7       	brne	.-44     	; 0x9d76 <SD_init+0x27e>
    9da2:	17 c0       	rjmp	.+46     	; 0x9dd2 <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9da4:	68 a1       	lds	r22, 0x48
    9da6:	79 a1       	lds	r23, 0x49
    9da8:	8a a1       	lds	r24, 0x4a
    9daa:	9b a1       	lds	r25, 0x4b
    9dac:	0e 94 6a 5d 	call	0xbad4	; 0xbad4 <__fixunssfsi>
    9db0:	dc 01       	movw	r26, r24
    9db2:	cb 01       	movw	r24, r22
    9db4:	8c a3       	lds	r24, 0x5c
    9db6:	9d a3       	lds	r25, 0x5d
    9db8:	8c a1       	lds	r24, 0x4c
    9dba:	9d a1       	lds	r25, 0x4d
    9dbc:	88 a7       	lds	r24, 0x78
    9dbe:	99 a7       	lds	r25, 0x79
    9dc0:	88 a5       	lds	r24, 0x68
    9dc2:	99 a5       	lds	r25, 0x69
    9dc4:	8c 01       	movw	r16, r24
    9dc6:	f8 01       	movw	r30, r16
    9dc8:	31 97       	sbiw	r30, 0x01	; 1
    9dca:	f1 f7       	brne	.-4      	; 0x9dc8 <SD_init+0x2d0>
    9dcc:	8f 01       	movw	r16, r30
    9dce:	08 a7       	lds	r16, 0x78
    9dd0:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9dd2:	1e 82       	std	Y+6, r1	; 0x06
    9dd4:	1f 82       	std	Y+7, r1	; 0x07
    9dd6:	0d c0       	rjmp	.+26     	; 0x9df2 <SD_init+0x2fa>
		if (i >= 10) {
    9dd8:	8e 81       	ldd	r24, Y+6	; 0x06
    9dda:	9f 81       	ldd	r25, Y+7	; 0x07
    9ddc:	8a 30       	cpi	r24, 0x0A	; 10
    9dde:	91 05       	cpc	r25, r1
    9de0:	1c f0       	brlt	.+6      	; 0x9de8 <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    9de2:	81 e0       	ldi	r24, 0x01	; 1
    9de4:	89 83       	std	Y+1, r24	; 0x01
			break;
    9de6:	11 c0       	rjmp	.+34     	; 0x9e0a <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9de8:	8e 81       	ldd	r24, Y+6	; 0x06
    9dea:	9f 81       	ldd	r25, Y+7	; 0x07
    9dec:	01 96       	adiw	r24, 0x01	; 1
    9dee:	8e 83       	std	Y+6, r24	; 0x06
    9df0:	9f 83       	std	Y+7, r25	; 0x07
    9df2:	88 e0       	ldi	r24, 0x08	; 8
    9df4:	4a ea       	ldi	r20, 0xAA	; 170
    9df6:	51 e0       	ldi	r21, 0x01	; 1
    9df8:	60 e0       	ldi	r22, 0x00	; 0
    9dfa:	70 e0       	ldi	r23, 0x00	; 0
    9dfc:	27 e8       	ldi	r18, 0x87	; 135
    9dfe:	08 e0       	ldi	r16, 0x08	; 8
    9e00:	10 e0       	ldi	r17, 0x00	; 0
    9e02:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
    9e06:	81 30       	cpi	r24, 0x01	; 1
    9e08:	39 f7       	brne	.-50     	; 0x9dd8 <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9e0a:	18 86       	std	Y+8, r1	; 0x08
    9e0c:	19 86       	std	Y+9, r1	; 0x09
    9e0e:	13 c0       	rjmp	.+38     	; 0x9e36 <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9e10:	88 85       	ldd	r24, Y+8	; 0x08
    9e12:	99 85       	ldd	r25, Y+9	; 0x09
    9e14:	8c 01       	movw	r16, r24
    9e16:	0e 5f       	subi	r16, 0xFE	; 254
    9e18:	1f 4f       	sbci	r17, 0xFF	; 255
    9e1a:	8f ef       	ldi	r24, 0xFF	; 255
    9e1c:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    9e20:	28 2f       	mov	r18, r24
    9e22:	c8 01       	movw	r24, r16
    9e24:	85 55       	subi	r24, 0x55	; 85
    9e26:	9f 4a       	sbci	r25, 0xAF	; 175
    9e28:	fc 01       	movw	r30, r24
    9e2a:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9e2c:	88 85       	ldd	r24, Y+8	; 0x08
    9e2e:	99 85       	ldd	r25, Y+9	; 0x09
    9e30:	01 96       	adiw	r24, 0x01	; 1
    9e32:	88 87       	std	Y+8, r24	; 0x08
    9e34:	99 87       	std	Y+9, r25	; 0x09
    9e36:	88 85       	ldd	r24, Y+8	; 0x08
    9e38:	99 85       	ldd	r25, Y+9	; 0x09
    9e3a:	84 30       	cpi	r24, 0x04	; 4
    9e3c:	91 05       	cpc	r25, r1
    9e3e:	44 f3       	brlt	.-48     	; 0x9e10 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9e40:	80 91 af 50 	lds	r24, 0x50AF
    9e44:	81 30       	cpi	r24, 0x01	; 1
    9e46:	21 f4       	brne	.+8      	; 0x9e50 <SD_init+0x358>
    9e48:	80 91 b0 50 	lds	r24, 0x50B0
    9e4c:	8a 3a       	cpi	r24, 0xAA	; 170
    9e4e:	11 f0       	breq	.+4      	; 0x9e54 <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9e50:	81 e0       	ldi	r24, 0x01	; 1
    9e52:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9e54:	87 e3       	ldi	r24, 0x37	; 55
    9e56:	40 e0       	ldi	r20, 0x00	; 0
    9e58:	50 e0       	ldi	r21, 0x00	; 0
    9e5a:	ba 01       	movw	r22, r20
    9e5c:	2f ef       	ldi	r18, 0xFF	; 255
    9e5e:	08 e0       	ldi	r16, 0x08	; 8
    9e60:	10 e0       	ldi	r17, 0x00	; 0
    9e62:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9e66:	81 e0       	ldi	r24, 0x01	; 1
    9e68:	40 e0       	ldi	r20, 0x00	; 0
    9e6a:	50 e0       	ldi	r21, 0x00	; 0
    9e6c:	60 e0       	ldi	r22, 0x00	; 0
    9e6e:	70 e4       	ldi	r23, 0x40	; 64
    9e70:	2f ef       	ldi	r18, 0xFF	; 255
    9e72:	08 e0       	ldi	r16, 0x08	; 8
    9e74:	10 e0       	ldi	r17, 0x00	; 0
    9e76:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
	} while(Buffer[1]!= 0x00);
    9e7a:	80 91 ac 50 	lds	r24, 0x50AC
    9e7e:	88 23       	and	r24, r24
    9e80:	49 f7       	brne	.-46     	; 0x9e54 <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9e82:	1a 86       	std	Y+10, r1	; 0x0a
    9e84:	1b 86       	std	Y+11, r1	; 0x0b
    9e86:	0d c0       	rjmp	.+26     	; 0x9ea2 <SD_init+0x3aa>
		if (i >= 10) {
    9e88:	8a 85       	ldd	r24, Y+10	; 0x0a
    9e8a:	9b 85       	ldd	r25, Y+11	; 0x0b
    9e8c:	8a 30       	cpi	r24, 0x0A	; 10
    9e8e:	91 05       	cpc	r25, r1
    9e90:	1c f0       	brlt	.+6      	; 0x9e98 <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    9e92:	81 e0       	ldi	r24, 0x01	; 1
    9e94:	89 83       	std	Y+1, r24	; 0x01
			break;
    9e96:	10 c0       	rjmp	.+32     	; 0x9eb8 <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9e98:	8a 85       	ldd	r24, Y+10	; 0x0a
    9e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
    9e9c:	01 96       	adiw	r24, 0x01	; 1
    9e9e:	8a 87       	std	Y+10, r24	; 0x0a
    9ea0:	9b 87       	std	Y+11, r25	; 0x0b
    9ea2:	8a e3       	ldi	r24, 0x3A	; 58
    9ea4:	40 e0       	ldi	r20, 0x00	; 0
    9ea6:	50 e0       	ldi	r21, 0x00	; 0
    9ea8:	ba 01       	movw	r22, r20
    9eaa:	2f ef       	ldi	r18, 0xFF	; 255
    9eac:	08 e0       	ldi	r16, 0x08	; 8
    9eae:	10 e0       	ldi	r17, 0x00	; 0
    9eb0:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
    9eb4:	88 23       	and	r24, r24
    9eb6:	41 f7       	brne	.-48     	; 0x9e88 <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9eb8:	1c 86       	std	Y+12, r1	; 0x0c
    9eba:	1d 86       	std	Y+13, r1	; 0x0d
    9ebc:	0f c0       	rjmp	.+30     	; 0x9edc <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9ebe:	8f ef       	ldi	r24, 0xFF	; 255
    9ec0:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    9ec4:	28 2f       	mov	r18, r24
    9ec6:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ec8:	9d 85       	ldd	r25, Y+13	; 0x0d
    9eca:	85 55       	subi	r24, 0x55	; 85
    9ecc:	9f 4a       	sbci	r25, 0xAF	; 175
    9ece:	fc 01       	movw	r30, r24
    9ed0:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9ed2:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ed4:	9d 85       	ldd	r25, Y+13	; 0x0d
    9ed6:	01 96       	adiw	r24, 0x01	; 1
    9ed8:	8c 87       	std	Y+12, r24	; 0x0c
    9eda:	9d 87       	std	Y+13, r25	; 0x0d
    9edc:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ede:	9d 85       	ldd	r25, Y+13	; 0x0d
    9ee0:	84 30       	cpi	r24, 0x04	; 4
    9ee2:	91 05       	cpc	r25, r1
    9ee4:	64 f3       	brlt	.-40     	; 0x9ebe <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9ee6:	80 91 ab 50 	lds	r24, 0x50AB
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9eea:	80 e0       	ldi	r24, 0x00	; 0
    9eec:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    9ef0:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9ef4:	88 e0       	ldi	r24, 0x08	; 8
    9ef6:	60 e0       	ldi	r22, 0x00	; 0
    9ef8:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
	return errorCode;	
    9efc:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9efe:	a9 96       	adiw	r28, 0x29	; 41
    9f00:	cd bf       	out	0x3d, r28	; 61
    9f02:	de bf       	out	0x3e, r29	; 62
    9f04:	df 91       	pop	r29
    9f06:	cf 91       	pop	r28
    9f08:	1f 91       	pop	r17
    9f0a:	0f 91       	pop	r16
    9f0c:	08 95       	ret

00009f0e <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9f0e:	cf 93       	push	r28
    9f10:	df 93       	push	r29
    9f12:	0f 92       	push	r0
    9f14:	0f 92       	push	r0
    9f16:	cd b7       	in	r28, 0x3d	; 61
    9f18:	de b7       	in	r29, 0x3e	; 62
    9f1a:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9f1c:	80 ec       	ldi	r24, 0xC0	; 192
    9f1e:	98 e0       	ldi	r25, 0x08	; 8
    9f20:	2a 81       	ldd	r18, Y+2	; 0x02
    9f22:	fc 01       	movw	r30, r24
    9f24:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9f26:	00 00       	nop
    9f28:	80 ec       	ldi	r24, 0xC0	; 192
    9f2a:	98 e0       	ldi	r25, 0x08	; 8
    9f2c:	fc 01       	movw	r30, r24
    9f2e:	82 81       	ldd	r24, Z+2	; 0x02
    9f30:	88 23       	and	r24, r24
    9f32:	d4 f7       	brge	.-12     	; 0x9f28 <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9f34:	80 ec       	ldi	r24, 0xC0	; 192
    9f36:	98 e0       	ldi	r25, 0x08	; 8
    9f38:	fc 01       	movw	r30, r24
    9f3a:	83 81       	ldd	r24, Z+3	; 0x03
    9f3c:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9f3e:	89 81       	ldd	r24, Y+1	; 0x01
}
    9f40:	0f 90       	pop	r0
    9f42:	0f 90       	pop	r0
    9f44:	df 91       	pop	r29
    9f46:	cf 91       	pop	r28
    9f48:	08 95       	ret

00009f4a <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9f4a:	0f 93       	push	r16
    9f4c:	1f 93       	push	r17
    9f4e:	cf 93       	push	r28
    9f50:	df 93       	push	r29
    9f52:	cd b7       	in	r28, 0x3d	; 61
    9f54:	de b7       	in	r29, 0x3e	; 62
    9f56:	2a 97       	sbiw	r28, 0x0a	; 10
    9f58:	cd bf       	out	0x3d, r28	; 61
    9f5a:	de bf       	out	0x3e, r29	; 62
    9f5c:	8b 83       	std	Y+3, r24	; 0x03
    9f5e:	4c 83       	std	Y+4, r20	; 0x04
    9f60:	5d 83       	std	Y+5, r21	; 0x05
    9f62:	6e 83       	std	Y+6, r22	; 0x06
    9f64:	7f 83       	std	Y+7, r23	; 0x07
    9f66:	28 87       	std	Y+8, r18	; 0x08
    9f68:	09 87       	std	Y+9, r16	; 0x09
    9f6a:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    9f6e:	80 64       	ori	r24, 0x40	; 64
    9f70:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9f74:	8c 81       	ldd	r24, Y+4	; 0x04
    9f76:	9d 81       	ldd	r25, Y+5	; 0x05
    9f78:	ae 81       	ldd	r26, Y+6	; 0x06
    9f7a:	bf 81       	ldd	r27, Y+7	; 0x07
    9f7c:	8b 2f       	mov	r24, r27
    9f7e:	99 27       	eor	r25, r25
    9f80:	aa 27       	eor	r26, r26
    9f82:	bb 27       	eor	r27, r27
    9f84:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9f88:	8c 81       	ldd	r24, Y+4	; 0x04
    9f8a:	9d 81       	ldd	r25, Y+5	; 0x05
    9f8c:	ae 81       	ldd	r26, Y+6	; 0x06
    9f8e:	bf 81       	ldd	r27, Y+7	; 0x07
    9f90:	cd 01       	movw	r24, r26
    9f92:	aa 27       	eor	r26, r26
    9f94:	bb 27       	eor	r27, r27
    9f96:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9f9a:	8c 81       	ldd	r24, Y+4	; 0x04
    9f9c:	9d 81       	ldd	r25, Y+5	; 0x05
    9f9e:	ae 81       	ldd	r26, Y+6	; 0x06
    9fa0:	bf 81       	ldd	r27, Y+7	; 0x07
    9fa2:	89 2f       	mov	r24, r25
    9fa4:	9a 2f       	mov	r25, r26
    9fa6:	ab 2f       	mov	r26, r27
    9fa8:	bb 27       	eor	r27, r27
    9faa:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9fae:	8c 81       	ldd	r24, Y+4	; 0x04
    9fb0:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
	SPI_write(crc);
    9fb4:	88 85       	ldd	r24, Y+8	; 0x08
    9fb6:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
	
	for(int i=0; i<read; i++){
    9fba:	19 82       	std	Y+1, r1	; 0x01
    9fbc:	1a 82       	std	Y+2, r1	; 0x02
    9fbe:	33 c0       	rjmp	.+102    	; 0xa026 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9fc0:	89 81       	ldd	r24, Y+1	; 0x01
    9fc2:	9a 81       	ldd	r25, Y+2	; 0x02
    9fc4:	2d e0       	ldi	r18, 0x0D	; 13
    9fc6:	30 e0       	ldi	r19, 0x00	; 0
    9fc8:	b9 01       	movw	r22, r18
    9fca:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    9fce:	8c 01       	movw	r16, r24
    9fd0:	8f ef       	ldi	r24, 0xFF	; 255
    9fd2:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    9fd6:	28 2f       	mov	r18, r24
    9fd8:	c8 01       	movw	r24, r16
    9fda:	85 55       	subi	r24, 0x55	; 85
    9fdc:	9f 4a       	sbci	r25, 0xAF	; 175
    9fde:	fc 01       	movw	r30, r24
    9fe0:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9fe2:	89 81       	ldd	r24, Y+1	; 0x01
    9fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    9fe6:	2d e0       	ldi	r18, 0x0D	; 13
    9fe8:	30 e0       	ldi	r19, 0x00	; 0
    9fea:	b9 01       	movw	r22, r18
    9fec:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    9ff0:	85 55       	subi	r24, 0x55	; 85
    9ff2:	9f 4a       	sbci	r25, 0xAF	; 175
    9ff4:	fc 01       	movw	r30, r24
    9ff6:	80 81       	ld	r24, Z
    9ff8:	8f 3f       	cpi	r24, 0xFF	; 255
    9ffa:	81 f0       	breq	.+32     	; 0xa01c <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9ffc:	89 81       	ldd	r24, Y+1	; 0x01
    9ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    a000:	2d e0       	ldi	r18, 0x0D	; 13
    a002:	30 e0       	ldi	r19, 0x00	; 0
    a004:	b9 01       	movw	r22, r18
    a006:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    a00a:	85 55       	subi	r24, 0x55	; 85
    a00c:	9f 4a       	sbci	r25, 0xAF	; 175
    a00e:	fc 01       	movw	r30, r24
    a010:	80 81       	ld	r24, Z
    a012:	80 93 ac 50 	sts	0x50AC, r24
			return Buffer[1];
    a016:	80 91 ac 50 	lds	r24, 0x50AC
    a01a:	0d c0       	rjmp	.+26     	; 0xa036 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    a01c:	89 81       	ldd	r24, Y+1	; 0x01
    a01e:	9a 81       	ldd	r25, Y+2	; 0x02
    a020:	01 96       	adiw	r24, 0x01	; 1
    a022:	89 83       	std	Y+1, r24	; 0x01
    a024:	9a 83       	std	Y+2, r25	; 0x02
    a026:	29 81       	ldd	r18, Y+1	; 0x01
    a028:	3a 81       	ldd	r19, Y+2	; 0x02
    a02a:	89 85       	ldd	r24, Y+9	; 0x09
    a02c:	9a 85       	ldd	r25, Y+10	; 0x0a
    a02e:	28 17       	cp	r18, r24
    a030:	39 07       	cpc	r19, r25
    a032:	34 f2       	brlt	.-116    	; 0x9fc0 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    a034:	8f ef       	ldi	r24, 0xFF	; 255
}
    a036:	2a 96       	adiw	r28, 0x0a	; 10
    a038:	cd bf       	out	0x3d, r28	; 61
    a03a:	de bf       	out	0x3e, r29	; 62
    a03c:	df 91       	pop	r29
    a03e:	cf 91       	pop	r28
    a040:	1f 91       	pop	r17
    a042:	0f 91       	pop	r16
    a044:	08 95       	ret

0000a046 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    a046:	0f 93       	push	r16
    a048:	1f 93       	push	r17
    a04a:	cf 93       	push	r28
    a04c:	df 93       	push	r29
    a04e:	cd b7       	in	r28, 0x3d	; 61
    a050:	de b7       	in	r29, 0x3e	; 62
    a052:	62 97       	sbiw	r28, 0x12	; 18
    a054:	cd bf       	out	0x3d, r28	; 61
    a056:	de bf       	out	0x3e, r29	; 62
    a058:	6b 87       	std	Y+11, r22	; 0x0b
    a05a:	7c 87       	std	Y+12, r23	; 0x0c
    a05c:	8d 87       	std	Y+13, r24	; 0x0d
    a05e:	9e 87       	std	Y+14, r25	; 0x0e
    a060:	4f 87       	std	Y+15, r20	; 0x0f
    a062:	58 8b       	std	Y+16, r21	; 0x10
    a064:	29 8b       	std	Y+17, r18	; 0x11
    a066:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a068:	88 e0       	ldi	r24, 0x08	; 8
    a06a:	60 e0       	ldi	r22, 0x00	; 0
    a06c:	0e 94 44 36 	call	0x6c88	; 0x6c88 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a070:	80 e0       	ldi	r24, 0x00	; 0
    a072:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    a076:	81 e0       	ldi	r24, 0x01	; 1
    a078:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    a07c:	20 e0       	ldi	r18, 0x00	; 0
    a07e:	32 e0       	ldi	r19, 0x02	; 2
    a080:	89 89       	ldd	r24, Y+17	; 0x11
    a082:	9a 89       	ldd	r25, Y+18	; 0x12
    a084:	a9 01       	movw	r20, r18
    a086:	48 1b       	sub	r20, r24
    a088:	59 0b       	sbc	r21, r25
    a08a:	ca 01       	movw	r24, r20
    a08c:	89 83       	std	Y+1, r24	; 0x01
    a08e:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a090:	89 81       	ldd	r24, Y+1	; 0x01
    a092:	9a 81       	ldd	r25, Y+2	; 0x02
    a094:	52 e0       	ldi	r21, 0x02	; 2
    a096:	80 30       	cpi	r24, 0x00	; 0
    a098:	95 07       	cpc	r25, r21
    a09a:	11 f4       	brne	.+4      	; 0xa0a0 <SD_write_block+0x5a>
    a09c:	19 82       	std	Y+1, r1	; 0x01
    a09e:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a0a0:	1b 82       	std	Y+3, r1	; 0x03
    a0a2:	1c 82       	std	Y+4, r1	; 0x04
    a0a4:	0b c0       	rjmp	.+22     	; 0xa0bc <SD_write_block+0x76>
	if (i >= 10) {
    a0a6:	8b 81       	ldd	r24, Y+3	; 0x03
    a0a8:	9c 81       	ldd	r25, Y+4	; 0x04
    a0aa:	8a 30       	cpi	r24, 0x0A	; 10
    a0ac:	91 05       	cpc	r25, r1
    a0ae:	0c f0       	brlt	.+2      	; 0xa0b2 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    a0b0:	ff cf       	rjmp	.-2      	; 0xa0b0 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a0b2:	8b 81       	ldd	r24, Y+3	; 0x03
    a0b4:	9c 81       	ldd	r25, Y+4	; 0x04
    a0b6:	01 96       	adiw	r24, 0x01	; 1
    a0b8:	8b 83       	std	Y+3, r24	; 0x03
    a0ba:	9c 83       	std	Y+4, r25	; 0x04
    a0bc:	2b 85       	ldd	r18, Y+11	; 0x0b
    a0be:	3c 85       	ldd	r19, Y+12	; 0x0c
    a0c0:	4d 85       	ldd	r20, Y+13	; 0x0d
    a0c2:	5e 85       	ldd	r21, Y+14	; 0x0e
    a0c4:	88 e1       	ldi	r24, 0x18	; 24
    a0c6:	ba 01       	movw	r22, r20
    a0c8:	a9 01       	movw	r20, r18
    a0ca:	2f ef       	ldi	r18, 0xFF	; 255
    a0cc:	08 e0       	ldi	r16, 0x08	; 8
    a0ce:	10 e0       	ldi	r17, 0x00	; 0
    a0d0:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
    a0d4:	88 23       	and	r24, r24
    a0d6:	39 f7       	brne	.-50     	; 0xa0a6 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    a0d8:	8f ef       	ldi	r24, 0xFF	; 255
    a0da:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a0de:	80 93 ab 50 	sts	0x50AB, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    a0e2:	8e ef       	ldi	r24, 0xFE	; 254
    a0e4:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a0e8:	1d 82       	std	Y+5, r1	; 0x05
    a0ea:	1e 82       	std	Y+6, r1	; 0x06
    a0ec:	1d c0       	rjmp	.+58     	; 0xa128 <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    a0ee:	8d 81       	ldd	r24, Y+5	; 0x05
    a0f0:	9e 81       	ldd	r25, Y+6	; 0x06
    a0f2:	2d e0       	ldi	r18, 0x0D	; 13
    a0f4:	30 e0       	ldi	r19, 0x00	; 0
    a0f6:	b9 01       	movw	r22, r18
    a0f8:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    a0fc:	8c 01       	movw	r16, r24
    a0fe:	8d 81       	ldd	r24, Y+5	; 0x05
    a100:	9e 81       	ldd	r25, Y+6	; 0x06
    a102:	2f 85       	ldd	r18, Y+15	; 0x0f
    a104:	38 89       	ldd	r19, Y+16	; 0x10
    a106:	82 0f       	add	r24, r18
    a108:	93 1f       	adc	r25, r19
    a10a:	fc 01       	movw	r30, r24
    a10c:	80 81       	ld	r24, Z
    a10e:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a112:	28 2f       	mov	r18, r24
    a114:	c8 01       	movw	r24, r16
    a116:	85 55       	subi	r24, 0x55	; 85
    a118:	9f 4a       	sbci	r25, 0xAF	; 175
    a11a:	fc 01       	movw	r30, r24
    a11c:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a11e:	8d 81       	ldd	r24, Y+5	; 0x05
    a120:	9e 81       	ldd	r25, Y+6	; 0x06
    a122:	01 96       	adiw	r24, 0x01	; 1
    a124:	8d 83       	std	Y+5, r24	; 0x05
    a126:	9e 83       	std	Y+6, r25	; 0x06
    a128:	2d 81       	ldd	r18, Y+5	; 0x05
    a12a:	3e 81       	ldd	r19, Y+6	; 0x06
    a12c:	89 89       	ldd	r24, Y+17	; 0x11
    a12e:	9a 89       	ldd	r25, Y+18	; 0x12
    a130:	28 17       	cp	r18, r24
    a132:	39 07       	cpc	r19, r25
    a134:	e4 f2       	brlt	.-72     	; 0xa0ee <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a136:	1f 82       	std	Y+7, r1	; 0x07
    a138:	18 86       	std	Y+8, r1	; 0x08
    a13a:	16 c0       	rjmp	.+44     	; 0xa168 <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    a13c:	8f 81       	ldd	r24, Y+7	; 0x07
    a13e:	98 85       	ldd	r25, Y+8	; 0x08
    a140:	2d e0       	ldi	r18, 0x0D	; 13
    a142:	30 e0       	ldi	r19, 0x00	; 0
    a144:	b9 01       	movw	r22, r18
    a146:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    a14a:	8c 01       	movw	r16, r24
    a14c:	80 e0       	ldi	r24, 0x00	; 0
    a14e:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a152:	28 2f       	mov	r18, r24
    a154:	c8 01       	movw	r24, r16
    a156:	85 55       	subi	r24, 0x55	; 85
    a158:	9f 4a       	sbci	r25, 0xAF	; 175
    a15a:	fc 01       	movw	r30, r24
    a15c:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a15e:	8f 81       	ldd	r24, Y+7	; 0x07
    a160:	98 85       	ldd	r25, Y+8	; 0x08
    a162:	01 96       	adiw	r24, 0x01	; 1
    a164:	8f 83       	std	Y+7, r24	; 0x07
    a166:	98 87       	std	Y+8, r25	; 0x08
    a168:	2f 81       	ldd	r18, Y+7	; 0x07
    a16a:	38 85       	ldd	r19, Y+8	; 0x08
    a16c:	89 81       	ldd	r24, Y+1	; 0x01
    a16e:	9a 81       	ldd	r25, Y+2	; 0x02
    a170:	28 17       	cp	r18, r24
    a172:	39 07       	cpc	r19, r25
    a174:	1c f3       	brlt	.-58     	; 0xa13c <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    a176:	8f ef       	ldi	r24, 0xFF	; 255
    a178:	80 93 ab 50 	sts	0x50AB, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a17c:	19 86       	std	Y+9, r1	; 0x09
    a17e:	1a 86       	std	Y+10, r1	; 0x0a
    a180:	0a c0       	rjmp	.+20     	; 0xa196 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    a182:	8f ef       	ldi	r24, 0xFF	; 255
    a184:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a188:	80 93 ab 50 	sts	0x50AB, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a18c:	89 85       	ldd	r24, Y+9	; 0x09
    a18e:	9a 85       	ldd	r25, Y+10	; 0x0a
    a190:	01 96       	adiw	r24, 0x01	; 1
    a192:	89 87       	std	Y+9, r24	; 0x09
    a194:	9a 87       	std	Y+10, r25	; 0x0a
    a196:	89 85       	ldd	r24, Y+9	; 0x09
    a198:	9a 85       	ldd	r25, Y+10	; 0x0a
    a19a:	82 30       	cpi	r24, 0x02	; 2
    a19c:	91 05       	cpc	r25, r1
    a19e:	8c f3       	brlt	.-30     	; 0xa182 <SD_write_block+0x13c>
    a1a0:	80 91 ab 50 	lds	r24, 0x50AB
    a1a4:	8f 3f       	cpi	r24, 0xFF	; 255
    a1a6:	69 f3       	breq	.-38     	; 0xa182 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    a1a8:	80 91 ab 50 	lds	r24, 0x50AB
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    a1ac:	05 c0       	rjmp	.+10     	; 0xa1b8 <SD_write_block+0x172>
    a1ae:	8f ef       	ldi	r24, 0xFF	; 255
    a1b0:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a1b4:	80 93 ab 50 	sts	0x50AB, r24
    a1b8:	80 91 ab 50 	lds	r24, 0x50AB
    a1bc:	8f 3f       	cpi	r24, 0xFF	; 255
    a1be:	b9 f7       	brne	.-18     	; 0xa1ae <SD_write_block+0x168>
	SPICS(FALSE);
    a1c0:	80 e0       	ldi	r24, 0x00	; 0
    a1c2:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    a1c6:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    a1ca:	88 e0       	ldi	r24, 0x08	; 8
    a1cc:	60 e0       	ldi	r22, 0x00	; 0
    a1ce:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
}
    a1d2:	62 96       	adiw	r28, 0x12	; 18
    a1d4:	cd bf       	out	0x3d, r28	; 61
    a1d6:	de bf       	out	0x3e, r29	; 62
    a1d8:	df 91       	pop	r29
    a1da:	cf 91       	pop	r28
    a1dc:	1f 91       	pop	r17
    a1de:	0f 91       	pop	r16
    a1e0:	08 95       	ret

0000a1e2 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    a1e2:	0f 93       	push	r16
    a1e4:	1f 93       	push	r17
    a1e6:	cf 93       	push	r28
    a1e8:	df 93       	push	r29
    a1ea:	cd b7       	in	r28, 0x3d	; 61
    a1ec:	de b7       	in	r29, 0x3e	; 62
    a1ee:	2a 97       	sbiw	r28, 0x0a	; 10
    a1f0:	cd bf       	out	0x3d, r28	; 61
    a1f2:	de bf       	out	0x3e, r29	; 62
    a1f4:	6d 83       	std	Y+5, r22	; 0x05
    a1f6:	7e 83       	std	Y+6, r23	; 0x06
    a1f8:	8f 83       	std	Y+7, r24	; 0x07
    a1fa:	98 87       	std	Y+8, r25	; 0x08
    a1fc:	49 87       	std	Y+9, r20	; 0x09
    a1fe:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a200:	88 e0       	ldi	r24, 0x08	; 8
    a202:	60 e0       	ldi	r22, 0x00	; 0
    a204:	0e 94 44 36 	call	0x6c88	; 0x6c88 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a208:	80 e0       	ldi	r24, 0x00	; 0
    a20a:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    a20e:	81 e0       	ldi	r24, 0x01	; 1
    a210:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a214:	19 82       	std	Y+1, r1	; 0x01
    a216:	1a 82       	std	Y+2, r1	; 0x02
    a218:	0b c0       	rjmp	.+22     	; 0xa230 <SD_read_block+0x4e>
		if (i >= 10) {
    a21a:	89 81       	ldd	r24, Y+1	; 0x01
    a21c:	9a 81       	ldd	r25, Y+2	; 0x02
    a21e:	8a 30       	cpi	r24, 0x0A	; 10
    a220:	91 05       	cpc	r25, r1
    a222:	0c f0       	brlt	.+2      	; 0xa226 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    a224:	ff cf       	rjmp	.-2      	; 0xa224 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a226:	89 81       	ldd	r24, Y+1	; 0x01
    a228:	9a 81       	ldd	r25, Y+2	; 0x02
    a22a:	01 96       	adiw	r24, 0x01	; 1
    a22c:	89 83       	std	Y+1, r24	; 0x01
    a22e:	9a 83       	std	Y+2, r25	; 0x02
    a230:	2d 81       	ldd	r18, Y+5	; 0x05
    a232:	3e 81       	ldd	r19, Y+6	; 0x06
    a234:	4f 81       	ldd	r20, Y+7	; 0x07
    a236:	58 85       	ldd	r21, Y+8	; 0x08
    a238:	81 e1       	ldi	r24, 0x11	; 17
    a23a:	ba 01       	movw	r22, r20
    a23c:	a9 01       	movw	r20, r18
    a23e:	2f ef       	ldi	r18, 0xFF	; 255
    a240:	08 e0       	ldi	r16, 0x08	; 8
    a242:	10 e0       	ldi	r17, 0x00	; 0
    a244:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
    a248:	88 23       	and	r24, r24
    a24a:	39 f7       	brne	.-50     	; 0xa21a <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a24c:	05 c0       	rjmp	.+10     	; 0xa258 <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    a24e:	8f ef       	ldi	r24, 0xFF	; 255
    a250:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a254:	80 93 ab 50 	sts	0x50AB, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a258:	80 91 ab 50 	lds	r24, 0x50AB
    a25c:	8e 3f       	cpi	r24, 0xFE	; 254
    a25e:	b9 f7       	brne	.-18     	; 0xa24e <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a260:	1b 82       	std	Y+3, r1	; 0x03
    a262:	1c 82       	std	Y+4, r1	; 0x04
    a264:	11 c0       	rjmp	.+34     	; 0xa288 <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a266:	8b 81       	ldd	r24, Y+3	; 0x03
    a268:	9c 81       	ldd	r25, Y+4	; 0x04
    a26a:	29 85       	ldd	r18, Y+9	; 0x09
    a26c:	3a 85       	ldd	r19, Y+10	; 0x0a
    a26e:	89 01       	movw	r16, r18
    a270:	08 0f       	add	r16, r24
    a272:	19 1f       	adc	r17, r25
    a274:	8f ef       	ldi	r24, 0xFF	; 255
    a276:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a27a:	f8 01       	movw	r30, r16
    a27c:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a27e:	8b 81       	ldd	r24, Y+3	; 0x03
    a280:	9c 81       	ldd	r25, Y+4	; 0x04
    a282:	01 96       	adiw	r24, 0x01	; 1
    a284:	8b 83       	std	Y+3, r24	; 0x03
    a286:	9c 83       	std	Y+4, r25	; 0x04
    a288:	8b 81       	ldd	r24, Y+3	; 0x03
    a28a:	9c 81       	ldd	r25, Y+4	; 0x04
    a28c:	f2 e0       	ldi	r31, 0x02	; 2
    a28e:	80 30       	cpi	r24, 0x00	; 0
    a290:	9f 07       	cpc	r25, r31
    a292:	4c f3       	brlt	.-46     	; 0xa266 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    a294:	10 92 b7 50 	sts	0x50B7, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a298:	05 c0       	rjmp	.+10     	; 0xa2a4 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    a29a:	8f ef       	ldi	r24, 0xFF	; 255
    a29c:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a2a0:	80 93 b7 50 	sts	0x50B7, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a2a4:	80 91 b7 50 	lds	r24, 0x50B7
    a2a8:	8f 3f       	cpi	r24, 0xFF	; 255
    a2aa:	b9 f7       	brne	.-18     	; 0xa29a <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    a2ac:	80 e0       	ldi	r24, 0x00	; 0
    a2ae:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    a2b2:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a2b6:	88 e0       	ldi	r24, 0x08	; 8
    a2b8:	60 e0       	ldi	r22, 0x00	; 0
    a2ba:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
}
    a2be:	2a 96       	adiw	r28, 0x0a	; 10
    a2c0:	cd bf       	out	0x3d, r28	; 61
    a2c2:	de bf       	out	0x3e, r29	; 62
    a2c4:	df 91       	pop	r29
    a2c6:	cf 91       	pop	r28
    a2c8:	1f 91       	pop	r17
    a2ca:	0f 91       	pop	r16
    a2cc:	08 95       	ret

0000a2ce <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    a2ce:	0f 93       	push	r16
    a2d0:	1f 93       	push	r17
    a2d2:	cf 93       	push	r28
    a2d4:	df 93       	push	r29
    a2d6:	cd b7       	in	r28, 0x3d	; 61
    a2d8:	de b7       	in	r29, 0x3e	; 62
    a2da:	6a 97       	sbiw	r28, 0x1a	; 26
    a2dc:	cd bf       	out	0x3d, r28	; 61
    a2de:	de bf       	out	0x3e, r29	; 62
    a2e0:	6b 8b       	std	Y+19, r22	; 0x13
    a2e2:	7c 8b       	std	Y+20, r23	; 0x14
    a2e4:	8d 8b       	std	Y+21, r24	; 0x15
    a2e6:	9e 8b       	std	Y+22, r25	; 0x16
    a2e8:	4f 8b       	std	Y+23, r20	; 0x17
    a2ea:	58 8f       	std	Y+24, r21	; 0x18
    a2ec:	29 8f       	std	Y+25, r18	; 0x19
    a2ee:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a2f0:	88 e0       	ldi	r24, 0x08	; 8
    a2f2:	60 e0       	ldi	r22, 0x00	; 0
    a2f4:	0e 94 44 36 	call	0x6c88	; 0x6c88 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a2f8:	80 e0       	ldi	r24, 0x00	; 0
    a2fa:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    a2fe:	81 e0       	ldi	r24, 0x01	; 1
    a300:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    a304:	89 8d       	ldd	r24, Y+25	; 0x19
    a306:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a308:	99 23       	and	r25, r25
    a30a:	14 f4       	brge	.+4      	; 0xa310 <SD_write_multiple_blocks+0x42>
    a30c:	81 50       	subi	r24, 0x01	; 1
    a30e:	9e 4f       	sbci	r25, 0xFE	; 254
    a310:	89 2f       	mov	r24, r25
    a312:	99 0f       	add	r25, r25
    a314:	99 0b       	sbc	r25, r25
    a316:	85 95       	asr	r24
    a318:	89 83       	std	Y+1, r24	; 0x01
    a31a:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    a31c:	89 8d       	ldd	r24, Y+25	; 0x19
    a31e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a320:	20 e0       	ldi	r18, 0x00	; 0
    a322:	32 e0       	ldi	r19, 0x02	; 2
    a324:	b9 01       	movw	r22, r18
    a326:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    a32a:	20 e0       	ldi	r18, 0x00	; 0
    a32c:	32 e0       	ldi	r19, 0x02	; 2
    a32e:	a9 01       	movw	r20, r18
    a330:	48 1b       	sub	r20, r24
    a332:	59 0b       	sbc	r21, r25
    a334:	ca 01       	movw	r24, r20
    a336:	8b 83       	std	Y+3, r24	; 0x03
    a338:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a33a:	8b 81       	ldd	r24, Y+3	; 0x03
    a33c:	9c 81       	ldd	r25, Y+4	; 0x04
    a33e:	52 e0       	ldi	r21, 0x02	; 2
    a340:	80 30       	cpi	r24, 0x00	; 0
    a342:	95 07       	cpc	r25, r21
    a344:	19 f4       	brne	.+6      	; 0xa34c <SD_write_multiple_blocks+0x7e>
    a346:	1b 82       	std	Y+3, r1	; 0x03
    a348:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a34a:	05 c0       	rjmp	.+10     	; 0xa356 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    a34c:	89 81       	ldd	r24, Y+1	; 0x01
    a34e:	9a 81       	ldd	r25, Y+2	; 0x02
    a350:	01 96       	adiw	r24, 0x01	; 1
    a352:	89 83       	std	Y+1, r24	; 0x01
    a354:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a356:	00 00       	nop
    a358:	2b 89       	ldd	r18, Y+19	; 0x13
    a35a:	3c 89       	ldd	r19, Y+20	; 0x14
    a35c:	4d 89       	ldd	r20, Y+21	; 0x15
    a35e:	5e 89       	ldd	r21, Y+22	; 0x16
    a360:	89 e1       	ldi	r24, 0x19	; 25
    a362:	ba 01       	movw	r22, r20
    a364:	a9 01       	movw	r20, r18
    a366:	2f ef       	ldi	r18, 0xFF	; 255
    a368:	08 e0       	ldi	r16, 0x08	; 8
    a36a:	10 e0       	ldi	r17, 0x00	; 0
    a36c:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
    a370:	88 23       	and	r24, r24
    a372:	91 f7       	brne	.-28     	; 0xa358 <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    a374:	1d 82       	std	Y+5, r1	; 0x05
    a376:	1e 82       	std	Y+6, r1	; 0x06
    a378:	ba c0       	rjmp	.+372    	; 0xa4ee <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    a37a:	8f ef       	ldi	r24, 0xFF	; 255
    a37c:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a380:	80 93 ac 50 	sts	0x50AC, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    a384:	8c ef       	ldi	r24, 0xFC	; 252
    a386:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a38a:	80 93 ac 50 	sts	0x50AC, r24
		if(j == (numSectors-1)){
    a38e:	89 81       	ldd	r24, Y+1	; 0x01
    a390:	9a 81       	ldd	r25, Y+2	; 0x02
    a392:	9c 01       	movw	r18, r24
    a394:	21 50       	subi	r18, 0x01	; 1
    a396:	30 40       	sbci	r19, 0x00	; 0
    a398:	8d 81       	ldd	r24, Y+5	; 0x05
    a39a:	9e 81       	ldd	r25, Y+6	; 0x06
    a39c:	28 17       	cp	r18, r24
    a39e:	39 07       	cpc	r19, r25
    a3a0:	09 f0       	breq	.+2      	; 0xa3a4 <SD_write_multiple_blocks+0xd6>
    a3a2:	54 c0       	rjmp	.+168    	; 0xa44c <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a3a4:	1f 82       	std	Y+7, r1	; 0x07
    a3a6:	18 86       	std	Y+8, r1	; 0x08
    a3a8:	25 c0       	rjmp	.+74     	; 0xa3f4 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a3aa:	8f 81       	ldd	r24, Y+7	; 0x07
    a3ac:	98 85       	ldd	r25, Y+8	; 0x08
    a3ae:	2c e0       	ldi	r18, 0x0C	; 12
    a3b0:	30 e0       	ldi	r19, 0x00	; 0
    a3b2:	b9 01       	movw	r22, r18
    a3b4:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    a3b8:	8c 01       	movw	r16, r24
    a3ba:	8d 81       	ldd	r24, Y+5	; 0x05
    a3bc:	9e 81       	ldd	r25, Y+6	; 0x06
    a3be:	9c 01       	movw	r18, r24
    a3c0:	32 2f       	mov	r19, r18
    a3c2:	22 27       	eor	r18, r18
    a3c4:	33 0f       	add	r19, r19
    a3c6:	8f 81       	ldd	r24, Y+7	; 0x07
    a3c8:	98 85       	ldd	r25, Y+8	; 0x08
    a3ca:	82 0f       	add	r24, r18
    a3cc:	93 1f       	adc	r25, r19
    a3ce:	2f 89       	ldd	r18, Y+23	; 0x17
    a3d0:	38 8d       	ldd	r19, Y+24	; 0x18
    a3d2:	82 0f       	add	r24, r18
    a3d4:	93 1f       	adc	r25, r19
    a3d6:	fc 01       	movw	r30, r24
    a3d8:	80 81       	ld	r24, Z
    a3da:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a3de:	28 2f       	mov	r18, r24
    a3e0:	c8 01       	movw	r24, r16
    a3e2:	85 55       	subi	r24, 0x55	; 85
    a3e4:	9f 4a       	sbci	r25, 0xAF	; 175
    a3e6:	fc 01       	movw	r30, r24
    a3e8:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a3ea:	8f 81       	ldd	r24, Y+7	; 0x07
    a3ec:	98 85       	ldd	r25, Y+8	; 0x08
    a3ee:	01 96       	adiw	r24, 0x01	; 1
    a3f0:	8f 83       	std	Y+7, r24	; 0x07
    a3f2:	98 87       	std	Y+8, r25	; 0x08
    a3f4:	20 e0       	ldi	r18, 0x00	; 0
    a3f6:	32 e0       	ldi	r19, 0x02	; 2
    a3f8:	8b 81       	ldd	r24, Y+3	; 0x03
    a3fa:	9c 81       	ldd	r25, Y+4	; 0x04
    a3fc:	28 1b       	sub	r18, r24
    a3fe:	39 0b       	sbc	r19, r25
    a400:	8f 81       	ldd	r24, Y+7	; 0x07
    a402:	98 85       	ldd	r25, Y+8	; 0x08
    a404:	82 17       	cp	r24, r18
    a406:	93 07       	cpc	r25, r19
    a408:	84 f2       	brlt	.-96     	; 0xa3aa <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a40a:	19 86       	std	Y+9, r1	; 0x09
    a40c:	1a 86       	std	Y+10, r1	; 0x0a
    a40e:	16 c0       	rjmp	.+44     	; 0xa43c <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a410:	89 85       	ldd	r24, Y+9	; 0x09
    a412:	9a 85       	ldd	r25, Y+10	; 0x0a
    a414:	2c e0       	ldi	r18, 0x0C	; 12
    a416:	30 e0       	ldi	r19, 0x00	; 0
    a418:	b9 01       	movw	r22, r18
    a41a:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    a41e:	8c 01       	movw	r16, r24
    a420:	80 e0       	ldi	r24, 0x00	; 0
    a422:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a426:	28 2f       	mov	r18, r24
    a428:	c8 01       	movw	r24, r16
    a42a:	85 55       	subi	r24, 0x55	; 85
    a42c:	9f 4a       	sbci	r25, 0xAF	; 175
    a42e:	fc 01       	movw	r30, r24
    a430:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a432:	89 85       	ldd	r24, Y+9	; 0x09
    a434:	9a 85       	ldd	r25, Y+10	; 0x0a
    a436:	01 96       	adiw	r24, 0x01	; 1
    a438:	89 87       	std	Y+9, r24	; 0x09
    a43a:	9a 87       	std	Y+10, r25	; 0x0a
    a43c:	29 85       	ldd	r18, Y+9	; 0x09
    a43e:	3a 85       	ldd	r19, Y+10	; 0x0a
    a440:	8b 81       	ldd	r24, Y+3	; 0x03
    a442:	9c 81       	ldd	r25, Y+4	; 0x04
    a444:	28 17       	cp	r18, r24
    a446:	39 07       	cpc	r19, r25
    a448:	1c f3       	brlt	.-58     	; 0xa410 <SD_write_multiple_blocks+0x142>
    a44a:	2e c0       	rjmp	.+92     	; 0xa4a8 <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a44c:	1b 86       	std	Y+11, r1	; 0x0b
    a44e:	1c 86       	std	Y+12, r1	; 0x0c
    a450:	25 c0       	rjmp	.+74     	; 0xa49c <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a452:	8b 85       	ldd	r24, Y+11	; 0x0b
    a454:	9c 85       	ldd	r25, Y+12	; 0x0c
    a456:	2c e0       	ldi	r18, 0x0C	; 12
    a458:	30 e0       	ldi	r19, 0x00	; 0
    a45a:	b9 01       	movw	r22, r18
    a45c:	0e 94 a5 5e 	call	0xbd4a	; 0xbd4a <__divmodhi4>
    a460:	8c 01       	movw	r16, r24
    a462:	8d 81       	ldd	r24, Y+5	; 0x05
    a464:	9e 81       	ldd	r25, Y+6	; 0x06
    a466:	9c 01       	movw	r18, r24
    a468:	32 2f       	mov	r19, r18
    a46a:	22 27       	eor	r18, r18
    a46c:	33 0f       	add	r19, r19
    a46e:	8b 85       	ldd	r24, Y+11	; 0x0b
    a470:	9c 85       	ldd	r25, Y+12	; 0x0c
    a472:	82 0f       	add	r24, r18
    a474:	93 1f       	adc	r25, r19
    a476:	2f 89       	ldd	r18, Y+23	; 0x17
    a478:	38 8d       	ldd	r19, Y+24	; 0x18
    a47a:	82 0f       	add	r24, r18
    a47c:	93 1f       	adc	r25, r19
    a47e:	fc 01       	movw	r30, r24
    a480:	80 81       	ld	r24, Z
    a482:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a486:	28 2f       	mov	r18, r24
    a488:	c8 01       	movw	r24, r16
    a48a:	85 55       	subi	r24, 0x55	; 85
    a48c:	9f 4a       	sbci	r25, 0xAF	; 175
    a48e:	fc 01       	movw	r30, r24
    a490:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a492:	8b 85       	ldd	r24, Y+11	; 0x0b
    a494:	9c 85       	ldd	r25, Y+12	; 0x0c
    a496:	01 96       	adiw	r24, 0x01	; 1
    a498:	8b 87       	std	Y+11, r24	; 0x0b
    a49a:	9c 87       	std	Y+12, r25	; 0x0c
    a49c:	8b 85       	ldd	r24, Y+11	; 0x0b
    a49e:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4a0:	f2 e0       	ldi	r31, 0x02	; 2
    a4a2:	80 30       	cpi	r24, 0x00	; 0
    a4a4:	9f 07       	cpc	r25, r31
    a4a6:	ac f2       	brlt	.-86     	; 0xa452 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a4a8:	1d 86       	std	Y+13, r1	; 0x0d
    a4aa:	1e 86       	std	Y+14, r1	; 0x0e
    a4ac:	0a c0       	rjmp	.+20     	; 0xa4c2 <SD_write_multiple_blocks+0x1f4>
    a4ae:	8f ef       	ldi	r24, 0xFF	; 255
    a4b0:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a4b4:	80 93 ac 50 	sts	0x50AC, r24
    a4b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    a4ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    a4bc:	01 96       	adiw	r24, 0x01	; 1
    a4be:	8d 87       	std	Y+13, r24	; 0x0d
    a4c0:	9e 87       	std	Y+14, r25	; 0x0e
    a4c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    a4c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    a4c6:	82 30       	cpi	r24, 0x02	; 2
    a4c8:	91 05       	cpc	r25, r1
    a4ca:	8c f3       	brlt	.-30     	; 0xa4ae <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a4cc:	10 92 ac 50 	sts	0x50AC, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a4d0:	05 c0       	rjmp	.+10     	; 0xa4dc <SD_write_multiple_blocks+0x20e>
    a4d2:	8f ef       	ldi	r24, 0xFF	; 255
    a4d4:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a4d8:	80 93 ac 50 	sts	0x50AC, r24
    a4dc:	80 91 ac 50 	lds	r24, 0x50AC
    a4e0:	8f 3f       	cpi	r24, 0xFF	; 255
    a4e2:	b9 f7       	brne	.-18     	; 0xa4d2 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a4e4:	8d 81       	ldd	r24, Y+5	; 0x05
    a4e6:	9e 81       	ldd	r25, Y+6	; 0x06
    a4e8:	01 96       	adiw	r24, 0x01	; 1
    a4ea:	8d 83       	std	Y+5, r24	; 0x05
    a4ec:	9e 83       	std	Y+6, r25	; 0x06
    a4ee:	2d 81       	ldd	r18, Y+5	; 0x05
    a4f0:	3e 81       	ldd	r19, Y+6	; 0x06
    a4f2:	89 81       	ldd	r24, Y+1	; 0x01
    a4f4:	9a 81       	ldd	r25, Y+2	; 0x02
    a4f6:	28 17       	cp	r18, r24
    a4f8:	39 07       	cpc	r19, r25
    a4fa:	0c f4       	brge	.+2      	; 0xa4fe <SD_write_multiple_blocks+0x230>
    a4fc:	3e cf       	rjmp	.-388    	; 0xa37a <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a4fe:	1f 86       	std	Y+15, r1	; 0x0f
    a500:	18 8a       	std	Y+16, r1	; 0x10
    a502:	0a c0       	rjmp	.+20     	; 0xa518 <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a504:	8f ef       	ldi	r24, 0xFF	; 255
    a506:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a50a:	80 93 ac 50 	sts	0x50AC, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a50e:	8f 85       	ldd	r24, Y+15	; 0x0f
    a510:	98 89       	ldd	r25, Y+16	; 0x10
    a512:	01 96       	adiw	r24, 0x01	; 1
    a514:	8f 87       	std	Y+15, r24	; 0x0f
    a516:	98 8b       	std	Y+16, r25	; 0x10
    a518:	8f 85       	ldd	r24, Y+15	; 0x0f
    a51a:	98 89       	ldd	r25, Y+16	; 0x10
    a51c:	84 30       	cpi	r24, 0x04	; 4
    a51e:	91 05       	cpc	r25, r1
    a520:	8c f3       	brlt	.-30     	; 0xa504 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a522:	8d ef       	ldi	r24, 0xFD	; 253
    a524:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a528:	80 93 ac 50 	sts	0x50AC, r24
	for(int i=0;i<4;i++){
    a52c:	19 8a       	std	Y+17, r1	; 0x11
    a52e:	1a 8a       	std	Y+18, r1	; 0x12
    a530:	0a c0       	rjmp	.+20     	; 0xa546 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a532:	8f ef       	ldi	r24, 0xFF	; 255
    a534:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a538:	80 93 ac 50 	sts	0x50AC, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a53c:	89 89       	ldd	r24, Y+17	; 0x11
    a53e:	9a 89       	ldd	r25, Y+18	; 0x12
    a540:	01 96       	adiw	r24, 0x01	; 1
    a542:	89 8b       	std	Y+17, r24	; 0x11
    a544:	9a 8b       	std	Y+18, r25	; 0x12
    a546:	89 89       	ldd	r24, Y+17	; 0x11
    a548:	9a 89       	ldd	r25, Y+18	; 0x12
    a54a:	84 30       	cpi	r24, 0x04	; 4
    a54c:	91 05       	cpc	r25, r1
    a54e:	8c f3       	brlt	.-30     	; 0xa532 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a550:	10 92 ac 50 	sts	0x50AC, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a554:	05 c0       	rjmp	.+10     	; 0xa560 <SD_write_multiple_blocks+0x292>
    a556:	8f ef       	ldi	r24, 0xFF	; 255
    a558:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a55c:	80 93 ac 50 	sts	0x50AC, r24
    a560:	80 91 ac 50 	lds	r24, 0x50AC
    a564:	8f 3f       	cpi	r24, 0xFF	; 255
    a566:	b9 f7       	brne	.-18     	; 0xa556 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a568:	80 e0       	ldi	r24, 0x00	; 0
    a56a:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    a56e:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a572:	88 e0       	ldi	r24, 0x08	; 8
    a574:	60 e0       	ldi	r22, 0x00	; 0
    a576:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
}
    a57a:	6a 96       	adiw	r28, 0x1a	; 26
    a57c:	cd bf       	out	0x3d, r28	; 61
    a57e:	de bf       	out	0x3e, r29	; 62
    a580:	df 91       	pop	r29
    a582:	cf 91       	pop	r28
    a584:	1f 91       	pop	r17
    a586:	0f 91       	pop	r16
    a588:	08 95       	ret

0000a58a <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a58a:	0f 93       	push	r16
    a58c:	1f 93       	push	r17
    a58e:	cf 93       	push	r28
    a590:	df 93       	push	r29
    a592:	cd b7       	in	r28, 0x3d	; 61
    a594:	de b7       	in	r29, 0x3e	; 62
    a596:	2e 97       	sbiw	r28, 0x0e	; 14
    a598:	cd bf       	out	0x3d, r28	; 61
    a59a:	de bf       	out	0x3e, r29	; 62
    a59c:	6f 83       	std	Y+7, r22	; 0x07
    a59e:	78 87       	std	Y+8, r23	; 0x08
    a5a0:	89 87       	std	Y+9, r24	; 0x09
    a5a2:	9a 87       	std	Y+10, r25	; 0x0a
    a5a4:	4b 87       	std	Y+11, r20	; 0x0b
    a5a6:	5c 87       	std	Y+12, r21	; 0x0c
    a5a8:	2d 87       	std	Y+13, r18	; 0x0d
    a5aa:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a5ac:	88 e0       	ldi	r24, 0x08	; 8
    a5ae:	60 e0       	ldi	r22, 0x00	; 0
    a5b0:	0e 94 44 36 	call	0x6c88	; 0x6c88 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a5b4:	80 e0       	ldi	r24, 0x00	; 0
    a5b6:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    a5ba:	81 e0       	ldi	r24, 0x01	; 1
    a5bc:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a5c0:	00 00       	nop
    a5c2:	2f 81       	ldd	r18, Y+7	; 0x07
    a5c4:	38 85       	ldd	r19, Y+8	; 0x08
    a5c6:	49 85       	ldd	r20, Y+9	; 0x09
    a5c8:	5a 85       	ldd	r21, Y+10	; 0x0a
    a5ca:	82 e1       	ldi	r24, 0x12	; 18
    a5cc:	ba 01       	movw	r22, r20
    a5ce:	a9 01       	movw	r20, r18
    a5d0:	2f ef       	ldi	r18, 0xFF	; 255
    a5d2:	08 e0       	ldi	r16, 0x08	; 8
    a5d4:	10 e0       	ldi	r17, 0x00	; 0
    a5d6:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
    a5da:	88 23       	and	r24, r24
    a5dc:	91 f7       	brne	.-28     	; 0xa5c2 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a5de:	19 82       	std	Y+1, r1	; 0x01
    a5e0:	1a 82       	std	Y+2, r1	; 0x02
    a5e2:	4b c0       	rjmp	.+150    	; 0xa67a <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a5e4:	8f ef       	ldi	r24, 0xFF	; 255
    a5e6:	80 93 ac 50 	sts	0x50AC, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a5ea:	05 c0       	rjmp	.+10     	; 0xa5f6 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a5ec:	8f ef       	ldi	r24, 0xFF	; 255
    a5ee:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a5f2:	80 93 ac 50 	sts	0x50AC, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a5f6:	80 91 ac 50 	lds	r24, 0x50AC
    a5fa:	8e 3f       	cpi	r24, 0xFE	; 254
    a5fc:	b9 f7       	brne	.-18     	; 0xa5ec <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a5fe:	1b 82       	std	Y+3, r1	; 0x03
    a600:	1c 82       	std	Y+4, r1	; 0x04
    a602:	19 c0       	rjmp	.+50     	; 0xa636 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a604:	89 81       	ldd	r24, Y+1	; 0x01
    a606:	9a 81       	ldd	r25, Y+2	; 0x02
    a608:	9c 01       	movw	r18, r24
    a60a:	32 2f       	mov	r19, r18
    a60c:	22 27       	eor	r18, r18
    a60e:	33 0f       	add	r19, r19
    a610:	8b 81       	ldd	r24, Y+3	; 0x03
    a612:	9c 81       	ldd	r25, Y+4	; 0x04
    a614:	82 0f       	add	r24, r18
    a616:	93 1f       	adc	r25, r19
    a618:	2b 85       	ldd	r18, Y+11	; 0x0b
    a61a:	3c 85       	ldd	r19, Y+12	; 0x0c
    a61c:	89 01       	movw	r16, r18
    a61e:	08 0f       	add	r16, r24
    a620:	19 1f       	adc	r17, r25
    a622:	8f ef       	ldi	r24, 0xFF	; 255
    a624:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a628:	f8 01       	movw	r30, r16
    a62a:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a62c:	8b 81       	ldd	r24, Y+3	; 0x03
    a62e:	9c 81       	ldd	r25, Y+4	; 0x04
    a630:	01 96       	adiw	r24, 0x01	; 1
    a632:	8b 83       	std	Y+3, r24	; 0x03
    a634:	9c 83       	std	Y+4, r25	; 0x04
    a636:	8b 81       	ldd	r24, Y+3	; 0x03
    a638:	9c 81       	ldd	r25, Y+4	; 0x04
    a63a:	f2 e0       	ldi	r31, 0x02	; 2
    a63c:	80 30       	cpi	r24, 0x00	; 0
    a63e:	9f 07       	cpc	r25, r31
    a640:	0c f3       	brlt	.-62     	; 0xa604 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a642:	1d 82       	std	Y+5, r1	; 0x05
    a644:	1e 82       	std	Y+6, r1	; 0x06
    a646:	0f c0       	rjmp	.+30     	; 0xa666 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a648:	8f ef       	ldi	r24, 0xFF	; 255
    a64a:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a64e:	28 2f       	mov	r18, r24
    a650:	8d 81       	ldd	r24, Y+5	; 0x05
    a652:	9e 81       	ldd	r25, Y+6	; 0x06
    a654:	85 55       	subi	r24, 0x55	; 85
    a656:	9f 4a       	sbci	r25, 0xAF	; 175
    a658:	fc 01       	movw	r30, r24
    a65a:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a65c:	8d 81       	ldd	r24, Y+5	; 0x05
    a65e:	9e 81       	ldd	r25, Y+6	; 0x06
    a660:	01 96       	adiw	r24, 0x01	; 1
    a662:	8d 83       	std	Y+5, r24	; 0x05
    a664:	9e 83       	std	Y+6, r25	; 0x06
    a666:	8d 81       	ldd	r24, Y+5	; 0x05
    a668:	9e 81       	ldd	r25, Y+6	; 0x06
    a66a:	82 30       	cpi	r24, 0x02	; 2
    a66c:	91 05       	cpc	r25, r1
    a66e:	64 f3       	brlt	.-40     	; 0xa648 <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a670:	89 81       	ldd	r24, Y+1	; 0x01
    a672:	9a 81       	ldd	r25, Y+2	; 0x02
    a674:	01 96       	adiw	r24, 0x01	; 1
    a676:	89 83       	std	Y+1, r24	; 0x01
    a678:	9a 83       	std	Y+2, r25	; 0x02
    a67a:	29 81       	ldd	r18, Y+1	; 0x01
    a67c:	3a 81       	ldd	r19, Y+2	; 0x02
    a67e:	8d 85       	ldd	r24, Y+13	; 0x0d
    a680:	9e 85       	ldd	r25, Y+14	; 0x0e
    a682:	28 17       	cp	r18, r24
    a684:	39 07       	cpc	r19, r25
    a686:	0c f4       	brge	.+2      	; 0xa68a <SD_read_multiple_blocks+0x100>
    a688:	ad cf       	rjmp	.-166    	; 0xa5e4 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a68a:	8c e0       	ldi	r24, 0x0C	; 12
    a68c:	40 e0       	ldi	r20, 0x00	; 0
    a68e:	50 e0       	ldi	r21, 0x00	; 0
    a690:	ba 01       	movw	r22, r20
    a692:	2f ef       	ldi	r18, 0xFF	; 255
    a694:	08 e0       	ldi	r16, 0x08	; 8
    a696:	10 e0       	ldi	r17, 0x00	; 0
    a698:	0e 94 a5 4f 	call	0x9f4a	; 0x9f4a <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a69c:	8f ef       	ldi	r24, 0xFF	; 255
    a69e:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a6a2:	80 93 ab 50 	sts	0x50AB, r24
	Buffer[1] = FILLER_BYTE;
    a6a6:	10 92 ac 50 	sts	0x50AC, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a6aa:	05 c0       	rjmp	.+10     	; 0xa6b6 <SD_read_multiple_blocks+0x12c>
    a6ac:	8f ef       	ldi	r24, 0xFF	; 255
    a6ae:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
    a6b2:	80 93 ac 50 	sts	0x50AC, r24
    a6b6:	80 91 ac 50 	lds	r24, 0x50AC
    a6ba:	8f 3f       	cpi	r24, 0xFF	; 255
    a6bc:	b9 f7       	brne	.-18     	; 0xa6ac <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a6be:	80 e0       	ldi	r24, 0x00	; 0
    a6c0:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    a6c4:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a6c8:	88 e0       	ldi	r24, 0x08	; 8
    a6ca:	60 e0       	ldi	r22, 0x00	; 0
    a6cc:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
}
    a6d0:	2e 96       	adiw	r28, 0x0e	; 14
    a6d2:	cd bf       	out	0x3d, r28	; 61
    a6d4:	de bf       	out	0x3e, r29	; 62
    a6d6:	df 91       	pop	r29
    a6d8:	cf 91       	pop	r28
    a6da:	1f 91       	pop	r17
    a6dc:	0f 91       	pop	r16
    a6de:	08 95       	ret

0000a6e0 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a6e0:	cf 93       	push	r28
    a6e2:	df 93       	push	r29
    a6e4:	cd b7       	in	r28, 0x3d	; 61
    a6e6:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a6e8:	88 e0       	ldi	r24, 0x08	; 8
    a6ea:	60 e0       	ldi	r22, 0x00	; 0
    a6ec:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a6f0:	88 e0       	ldi	r24, 0x08	; 8
    a6f2:	60 e0       	ldi	r22, 0x00	; 0
    a6f4:	0e 94 e1 35 	call	0x6bc2	; 0x6bc2 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a6f8:	80 e0       	ldi	r24, 0x00	; 0
    a6fa:	0e 94 b1 39 	call	0x7362	; 0x7362 <SPIInit>
	SPICS(TRUE);
    a6fe:	81 e0       	ldi	r24, 0x01	; 1
    a700:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a704:	8f ef       	ldi	r24, 0xFF	; 255
    a706:	0e 94 87 4f 	call	0x9f0e	; 0x9f0e <SPI_write>
	SPICS(FALSE);	//stop spi
    a70a:	80 e0       	ldi	r24, 0x00	; 0
    a70c:	0e 94 06 3a 	call	0x740c	; 0x740c <SPICS>
	SPIDisable();
    a710:	0e 94 1e 3a 	call	0x743c	; 0x743c <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a714:	80 e0       	ldi	r24, 0x00	; 0
    a716:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a71a:	80 e0       	ldi	r24, 0x00	; 0
    a71c:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <Ext1Power>
}
    a720:	df 91       	pop	r29
    a722:	cf 91       	pop	r28
    a724:	08 95       	ret

0000a726 <__muldi3>:
    a726:	a0 e3       	ldi	r26, 0x30	; 48
    a728:	b0 e0       	ldi	r27, 0x00	; 0
    a72a:	e9 e9       	ldi	r30, 0x99	; 153
    a72c:	f3 e5       	ldi	r31, 0x53	; 83
    a72e:	0c 94 f7 5e 	jmp	0xbdee	; 0xbdee <__prologue_saves__+0x4>
    a732:	29 8f       	std	Y+25, r18	; 0x19
    a734:	3a 8f       	std	Y+26, r19	; 0x1a
    a736:	4b 8f       	std	Y+27, r20	; 0x1b
    a738:	5c 8f       	std	Y+28, r21	; 0x1c
    a73a:	6d 8f       	std	Y+29, r22	; 0x1d
    a73c:	7e 8f       	std	Y+30, r23	; 0x1e
    a73e:	8f 8f       	std	Y+31, r24	; 0x1f
    a740:	98 a3       	lds	r25, 0x58
    a742:	a9 8a       	std	Y+17, r10	; 0x11
    a744:	ba 8a       	std	Y+18, r11	; 0x12
    a746:	cb 8a       	std	Y+19, r12	; 0x13
    a748:	dc 8a       	std	Y+20, r13	; 0x14
    a74a:	ed 8a       	std	Y+21, r14	; 0x15
    a74c:	fe 8a       	std	Y+22, r15	; 0x16
    a74e:	0f 8b       	std	Y+23, r16	; 0x17
    a750:	18 8f       	std	Y+24, r17	; 0x18
    a752:	09 8d       	ldd	r16, Y+25	; 0x19
    a754:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a756:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a758:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a75a:	09 a3       	lds	r16, 0x59
    a75c:	1a a3       	lds	r17, 0x5a
    a75e:	2b a3       	lds	r18, 0x5b
    a760:	3c a3       	lds	r19, 0x5c
    a762:	68 01       	movw	r12, r16
    a764:	79 01       	movw	r14, r18
    a766:	8f ef       	ldi	r24, 0xFF	; 255
    a768:	9f ef       	ldi	r25, 0xFF	; 255
    a76a:	a0 e0       	ldi	r26, 0x00	; 0
    a76c:	b0 e0       	ldi	r27, 0x00	; 0
    a76e:	c8 22       	and	r12, r24
    a770:	d9 22       	and	r13, r25
    a772:	ea 22       	and	r14, r26
    a774:	fb 22       	and	r15, r27
    a776:	89 01       	movw	r16, r18
    a778:	22 27       	eor	r18, r18
    a77a:	33 27       	eor	r19, r19
    a77c:	09 a7       	lds	r16, 0x79
    a77e:	1a a7       	lds	r17, 0x7a
    a780:	2b a7       	lds	r18, 0x7b
    a782:	3c a7       	lds	r19, 0x7c
    a784:	09 89       	ldd	r16, Y+17	; 0x11
    a786:	1a 89       	ldd	r17, Y+18	; 0x12
    a788:	2b 89       	ldd	r18, Y+19	; 0x13
    a78a:	3c 89       	ldd	r19, Y+20	; 0x14
    a78c:	0d a3       	lds	r16, 0x5d
    a78e:	1e a3       	lds	r17, 0x5e
    a790:	2f a3       	lds	r18, 0x5f
    a792:	38 a7       	lds	r19, 0x78
    a794:	48 01       	movw	r8, r16
    a796:	59 01       	movw	r10, r18
    a798:	88 22       	and	r8, r24
    a79a:	99 22       	and	r9, r25
    a79c:	aa 22       	and	r10, r26
    a79e:	bb 22       	and	r11, r27
    a7a0:	29 01       	movw	r4, r18
    a7a2:	66 24       	eor	r6, r6
    a7a4:	77 24       	eor	r7, r7
    a7a6:	c5 01       	movw	r24, r10
    a7a8:	b4 01       	movw	r22, r8
    a7aa:	a7 01       	movw	r20, r14
    a7ac:	96 01       	movw	r18, r12
    a7ae:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    a7b2:	6d a7       	lds	r22, 0x7d
    a7b4:	7e a7       	lds	r23, 0x7e
    a7b6:	8f a7       	lds	r24, 0x7f
    a7b8:	98 ab       	sts	0x58, r25
    a7ba:	c3 01       	movw	r24, r6
    a7bc:	b2 01       	movw	r22, r4
    a7be:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    a7c2:	6b 01       	movw	r12, r22
    a7c4:	7c 01       	movw	r14, r24
    a7c6:	c5 01       	movw	r24, r10
    a7c8:	b4 01       	movw	r22, r8
    a7ca:	29 a5       	lds	r18, 0x69
    a7cc:	3a a5       	lds	r19, 0x6a
    a7ce:	4b a5       	lds	r20, 0x6b
    a7d0:	5c a5       	lds	r21, 0x6c
    a7d2:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    a7d6:	4b 01       	movw	r8, r22
    a7d8:	5c 01       	movw	r10, r24
    a7da:	c3 01       	movw	r24, r6
    a7dc:	b2 01       	movw	r22, r4
    a7de:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    a7e2:	ab 01       	movw	r20, r22
    a7e4:	bc 01       	movw	r22, r24
    a7e6:	c8 0c       	add	r12, r8
    a7e8:	d9 1c       	adc	r13, r9
    a7ea:	ea 1c       	adc	r14, r10
    a7ec:	fb 1c       	adc	r15, r11
    a7ee:	0d a5       	lds	r16, 0x6d
    a7f0:	1e a5       	lds	r17, 0x6e
    a7f2:	2f a5       	lds	r18, 0x6f
    a7f4:	38 a9       	sts	0x48, r19
    a7f6:	c9 01       	movw	r24, r18
    a7f8:	aa 27       	eor	r26, r26
    a7fa:	bb 27       	eor	r27, r27
    a7fc:	c8 0e       	add	r12, r24
    a7fe:	d9 1e       	adc	r13, r25
    a800:	ea 1e       	adc	r14, r26
    a802:	fb 1e       	adc	r15, r27
    a804:	c8 14       	cp	r12, r8
    a806:	d9 04       	cpc	r13, r9
    a808:	ea 04       	cpc	r14, r10
    a80a:	fb 04       	cpc	r15, r11
    a80c:	20 f4       	brcc	.+8      	; 0xa816 <__muldi3+0xf0>
    a80e:	40 50       	subi	r20, 0x00	; 0
    a810:	50 40       	sbci	r21, 0x00	; 0
    a812:	6f 4f       	sbci	r22, 0xFF	; 255
    a814:	7f 4f       	sbci	r23, 0xFF	; 255
    a816:	c7 01       	movw	r24, r14
    a818:	aa 27       	eor	r26, r26
    a81a:	bb 27       	eor	r27, r27
    a81c:	84 0f       	add	r24, r20
    a81e:	95 1f       	adc	r25, r21
    a820:	a6 1f       	adc	r26, r22
    a822:	b7 1f       	adc	r27, r23
    a824:	8d 83       	std	Y+5, r24	; 0x05
    a826:	9e 83       	std	Y+6, r25	; 0x06
    a828:	af 83       	std	Y+7, r26	; 0x07
    a82a:	b8 87       	std	Y+8, r27	; 0x08
    a82c:	76 01       	movw	r14, r12
    a82e:	dd 24       	eor	r13, r13
    a830:	cc 24       	eor	r12, r12
    a832:	4d a5       	lds	r20, 0x6d
    a834:	5e a5       	lds	r21, 0x6e
    a836:	6f a5       	lds	r22, 0x6f
    a838:	78 a9       	sts	0x48, r23
    a83a:	60 70       	andi	r22, 0x00	; 0
    a83c:	70 70       	andi	r23, 0x00	; 0
    a83e:	c4 0e       	add	r12, r20
    a840:	d5 1e       	adc	r13, r21
    a842:	e6 1e       	adc	r14, r22
    a844:	f7 1e       	adc	r15, r23
    a846:	c9 82       	std	Y+1, r12	; 0x01
    a848:	da 82       	std	Y+2, r13	; 0x02
    a84a:	eb 82       	std	Y+3, r14	; 0x03
    a84c:	fc 82       	std	Y+4, r15	; 0x04
    a84e:	1c 2d       	mov	r17, r12
    a850:	0a 81       	ldd	r16, Y+2	; 0x02
    a852:	8b 80       	ldd	r8, Y+3	; 0x03
    a854:	4c 80       	ldd	r4, Y+4	; 0x04
    a856:	8d 87       	std	Y+13, r24	; 0x0d
    a858:	8e 81       	ldd	r24, Y+6	; 0x06
    a85a:	8e 87       	std	Y+14, r24	; 0x0e
    a85c:	8f 81       	ldd	r24, Y+7	; 0x07
    a85e:	8f 87       	std	Y+15, r24	; 0x0f
    a860:	88 85       	ldd	r24, Y+8	; 0x08
    a862:	88 8b       	std	Y+16, r24	; 0x10
    a864:	2d 89       	ldd	r18, Y+21	; 0x15
    a866:	3e 89       	ldd	r19, Y+22	; 0x16
    a868:	4f 89       	ldd	r20, Y+23	; 0x17
    a86a:	58 8d       	ldd	r21, Y+24	; 0x18
    a86c:	69 a1       	lds	r22, 0x49
    a86e:	7a a1       	lds	r23, 0x4a
    a870:	8b a1       	lds	r24, 0x4b
    a872:	9c a1       	lds	r25, 0x4c
    a874:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    a878:	6b 01       	movw	r12, r22
    a87a:	7c 01       	movw	r14, r24
    a87c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a87e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a880:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a882:	58 a1       	lds	r21, 0x48
    a884:	6d a1       	lds	r22, 0x4d
    a886:	7e a1       	lds	r23, 0x4e
    a888:	8f a1       	lds	r24, 0x4f
    a88a:	98 a5       	lds	r25, 0x68
    a88c:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    a890:	dc 01       	movw	r26, r24
    a892:	cb 01       	movw	r24, r22
    a894:	c8 0e       	add	r12, r24
    a896:	d9 1e       	adc	r13, r25
    a898:	ea 1e       	adc	r14, r26
    a89a:	fb 1e       	adc	r15, r27
    a89c:	8d 85       	ldd	r24, Y+13	; 0x0d
    a89e:	9e 85       	ldd	r25, Y+14	; 0x0e
    a8a0:	af 85       	ldd	r26, Y+15	; 0x0f
    a8a2:	b8 89       	ldd	r27, Y+16	; 0x10
    a8a4:	8c 0d       	add	r24, r12
    a8a6:	9d 1d       	adc	r25, r13
    a8a8:	ae 1d       	adc	r26, r14
    a8aa:	bf 1d       	adc	r27, r15
    a8ac:	8d 87       	std	Y+13, r24	; 0x0d
    a8ae:	9e 87       	std	Y+14, r25	; 0x0e
    a8b0:	af 87       	std	Y+15, r26	; 0x0f
    a8b2:	b8 8b       	std	Y+16, r27	; 0x10
    a8b4:	68 2f       	mov	r22, r24
    a8b6:	7e 85       	ldd	r23, Y+14	; 0x0e
    a8b8:	21 2f       	mov	r18, r17
    a8ba:	30 2f       	mov	r19, r16
    a8bc:	48 2d       	mov	r20, r8
    a8be:	54 2d       	mov	r21, r4
    a8c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    a8c2:	98 89       	ldd	r25, Y+16	; 0x10
    a8c4:	e0 96       	adiw	r28, 0x30	; 48
    a8c6:	e0 e1       	ldi	r30, 0x10	; 16
    a8c8:	0c 94 10 5f 	jmp	0xbe20	; 0xbe20 <__epilogue_restores__+0x4>

0000a8cc <__ashldi3>:
    a8cc:	cf 92       	push	r12
    a8ce:	df 92       	push	r13
    a8d0:	ef 92       	push	r14
    a8d2:	ff 92       	push	r15
    a8d4:	0f 93       	push	r16
    a8d6:	cf 93       	push	r28
    a8d8:	df 93       	push	r29
    a8da:	cd b7       	in	r28, 0x3d	; 61
    a8dc:	de b7       	in	r29, 0x3e	; 62
    a8de:	60 97       	sbiw	r28, 0x10	; 16
    a8e0:	cd bf       	out	0x3d, r28	; 61
    a8e2:	de bf       	out	0x3e, r29	; 62
    a8e4:	00 23       	and	r16, r16
    a8e6:	09 f4       	brne	.+2      	; 0xa8ea <__ashldi3+0x1e>
    a8e8:	5a c0       	rjmp	.+180    	; 0xa99e <__ashldi3+0xd2>
    a8ea:	29 87       	std	Y+9, r18	; 0x09
    a8ec:	3a 87       	std	Y+10, r19	; 0x0a
    a8ee:	4b 87       	std	Y+11, r20	; 0x0b
    a8f0:	5c 87       	std	Y+12, r21	; 0x0c
    a8f2:	6d 87       	std	Y+13, r22	; 0x0d
    a8f4:	7e 87       	std	Y+14, r23	; 0x0e
    a8f6:	8f 87       	std	Y+15, r24	; 0x0f
    a8f8:	98 8b       	std	Y+16, r25	; 0x10
    a8fa:	80 e2       	ldi	r24, 0x20	; 32
    a8fc:	80 1b       	sub	r24, r16
    a8fe:	49 85       	ldd	r20, Y+9	; 0x09
    a900:	5a 85       	ldd	r21, Y+10	; 0x0a
    a902:	6b 85       	ldd	r22, Y+11	; 0x0b
    a904:	7c 85       	ldd	r23, Y+12	; 0x0c
    a906:	18 16       	cp	r1, r24
    a908:	b4 f0       	brlt	.+44     	; 0xa936 <__ashldi3+0x6a>
    a90a:	19 82       	std	Y+1, r1	; 0x01
    a90c:	1a 82       	std	Y+2, r1	; 0x02
    a90e:	1b 82       	std	Y+3, r1	; 0x03
    a910:	1c 82       	std	Y+4, r1	; 0x04
    a912:	99 27       	eor	r25, r25
    a914:	87 fd       	sbrc	r24, 7
    a916:	90 95       	com	r25
    a918:	90 95       	com	r25
    a91a:	81 95       	neg	r24
    a91c:	9f 4f       	sbci	r25, 0xFF	; 255
    a91e:	04 c0       	rjmp	.+8      	; 0xa928 <__ashldi3+0x5c>
    a920:	44 0f       	add	r20, r20
    a922:	55 1f       	adc	r21, r21
    a924:	66 1f       	adc	r22, r22
    a926:	77 1f       	adc	r23, r23
    a928:	8a 95       	dec	r24
    a92a:	d2 f7       	brpl	.-12     	; 0xa920 <__ashldi3+0x54>
    a92c:	4d 83       	std	Y+5, r20	; 0x05
    a92e:	5e 83       	std	Y+6, r21	; 0x06
    a930:	6f 83       	std	Y+7, r22	; 0x07
    a932:	78 87       	std	Y+8, r23	; 0x08
    a934:	2c c0       	rjmp	.+88     	; 0xa98e <__ashldi3+0xc2>
    a936:	6a 01       	movw	r12, r20
    a938:	7b 01       	movw	r14, r22
    a93a:	00 2e       	mov	r0, r16
    a93c:	04 c0       	rjmp	.+8      	; 0xa946 <__ashldi3+0x7a>
    a93e:	cc 0c       	add	r12, r12
    a940:	dd 1c       	adc	r13, r13
    a942:	ee 1c       	adc	r14, r14
    a944:	ff 1c       	adc	r15, r15
    a946:	0a 94       	dec	r0
    a948:	d2 f7       	brpl	.-12     	; 0xa93e <__ashldi3+0x72>
    a94a:	c9 82       	std	Y+1, r12	; 0x01
    a94c:	da 82       	std	Y+2, r13	; 0x02
    a94e:	eb 82       	std	Y+3, r14	; 0x03
    a950:	fc 82       	std	Y+4, r15	; 0x04
    a952:	6a 01       	movw	r12, r20
    a954:	7b 01       	movw	r14, r22
    a956:	04 c0       	rjmp	.+8      	; 0xa960 <__ashldi3+0x94>
    a958:	f6 94       	lsr	r15
    a95a:	e7 94       	ror	r14
    a95c:	d7 94       	ror	r13
    a95e:	c7 94       	ror	r12
    a960:	8a 95       	dec	r24
    a962:	d2 f7       	brpl	.-12     	; 0xa958 <__ashldi3+0x8c>
    a964:	d7 01       	movw	r26, r14
    a966:	c6 01       	movw	r24, r12
    a968:	4d 85       	ldd	r20, Y+13	; 0x0d
    a96a:	5e 85       	ldd	r21, Y+14	; 0x0e
    a96c:	6f 85       	ldd	r22, Y+15	; 0x0f
    a96e:	78 89       	ldd	r23, Y+16	; 0x10
    a970:	04 c0       	rjmp	.+8      	; 0xa97a <__ashldi3+0xae>
    a972:	44 0f       	add	r20, r20
    a974:	55 1f       	adc	r21, r21
    a976:	66 1f       	adc	r22, r22
    a978:	77 1f       	adc	r23, r23
    a97a:	0a 95       	dec	r16
    a97c:	d2 f7       	brpl	.-12     	; 0xa972 <__ashldi3+0xa6>
    a97e:	84 2b       	or	r24, r20
    a980:	95 2b       	or	r25, r21
    a982:	a6 2b       	or	r26, r22
    a984:	b7 2b       	or	r27, r23
    a986:	8d 83       	std	Y+5, r24	; 0x05
    a988:	9e 83       	std	Y+6, r25	; 0x06
    a98a:	af 83       	std	Y+7, r26	; 0x07
    a98c:	b8 87       	std	Y+8, r27	; 0x08
    a98e:	29 81       	ldd	r18, Y+1	; 0x01
    a990:	3a 81       	ldd	r19, Y+2	; 0x02
    a992:	4b 81       	ldd	r20, Y+3	; 0x03
    a994:	5c 81       	ldd	r21, Y+4	; 0x04
    a996:	6d 81       	ldd	r22, Y+5	; 0x05
    a998:	7e 81       	ldd	r23, Y+6	; 0x06
    a99a:	8f 81       	ldd	r24, Y+7	; 0x07
    a99c:	98 85       	ldd	r25, Y+8	; 0x08
    a99e:	60 96       	adiw	r28, 0x10	; 16
    a9a0:	cd bf       	out	0x3d, r28	; 61
    a9a2:	de bf       	out	0x3e, r29	; 62
    a9a4:	df 91       	pop	r29
    a9a6:	cf 91       	pop	r28
    a9a8:	0f 91       	pop	r16
    a9aa:	ff 90       	pop	r15
    a9ac:	ef 90       	pop	r14
    a9ae:	df 90       	pop	r13
    a9b0:	cf 90       	pop	r12
    a9b2:	08 95       	ret

0000a9b4 <__ashrdi3>:
    a9b4:	0f 93       	push	r16
    a9b6:	cf 93       	push	r28
    a9b8:	df 93       	push	r29
    a9ba:	cd b7       	in	r28, 0x3d	; 61
    a9bc:	de b7       	in	r29, 0x3e	; 62
    a9be:	60 97       	sbiw	r28, 0x10	; 16
    a9c0:	cd bf       	out	0x3d, r28	; 61
    a9c2:	de bf       	out	0x3e, r29	; 62
    a9c4:	00 23       	and	r16, r16
    a9c6:	09 f4       	brne	.+2      	; 0xa9ca <__ashrdi3+0x16>
    a9c8:	56 c0       	rjmp	.+172    	; 0xaa76 <__ashrdi3+0xc2>
    a9ca:	29 87       	std	Y+9, r18	; 0x09
    a9cc:	3a 87       	std	Y+10, r19	; 0x0a
    a9ce:	4b 87       	std	Y+11, r20	; 0x0b
    a9d0:	5c 87       	std	Y+12, r21	; 0x0c
    a9d2:	6d 87       	std	Y+13, r22	; 0x0d
    a9d4:	7e 87       	std	Y+14, r23	; 0x0e
    a9d6:	8f 87       	std	Y+15, r24	; 0x0f
    a9d8:	98 8b       	std	Y+16, r25	; 0x10
    a9da:	20 e2       	ldi	r18, 0x20	; 32
    a9dc:	20 1b       	sub	r18, r16
    a9de:	8d 85       	ldd	r24, Y+13	; 0x0d
    a9e0:	9e 85       	ldd	r25, Y+14	; 0x0e
    a9e2:	af 85       	ldd	r26, Y+15	; 0x0f
    a9e4:	b8 89       	ldd	r27, Y+16	; 0x10
    a9e6:	ac 01       	movw	r20, r24
    a9e8:	bd 01       	movw	r22, r26
    a9ea:	12 16       	cp	r1, r18
    a9ec:	b4 f0       	brlt	.+44     	; 0xaa1a <__ashrdi3+0x66>
    a9ee:	77 0f       	add	r23, r23
    a9f0:	44 0b       	sbc	r20, r20
    a9f2:	54 2f       	mov	r21, r20
    a9f4:	ba 01       	movw	r22, r20
    a9f6:	4d 83       	std	Y+5, r20	; 0x05
    a9f8:	5e 83       	std	Y+6, r21	; 0x06
    a9fa:	6f 83       	std	Y+7, r22	; 0x07
    a9fc:	78 87       	std	Y+8, r23	; 0x08
    a9fe:	33 27       	eor	r19, r19
    aa00:	27 fd       	sbrc	r18, 7
    aa02:	30 95       	com	r19
    aa04:	30 95       	com	r19
    aa06:	21 95       	neg	r18
    aa08:	3f 4f       	sbci	r19, 0xFF	; 255
    aa0a:	04 c0       	rjmp	.+8      	; 0xaa14 <__ashrdi3+0x60>
    aa0c:	b5 95       	asr	r27
    aa0e:	a7 95       	ror	r26
    aa10:	97 95       	ror	r25
    aa12:	87 95       	ror	r24
    aa14:	2a 95       	dec	r18
    aa16:	d2 f7       	brpl	.-12     	; 0xaa0c <__ashrdi3+0x58>
    aa18:	22 c0       	rjmp	.+68     	; 0xaa5e <__ashrdi3+0xaa>
    aa1a:	00 2e       	mov	r0, r16
    aa1c:	04 c0       	rjmp	.+8      	; 0xaa26 <__ashrdi3+0x72>
    aa1e:	75 95       	asr	r23
    aa20:	67 95       	ror	r22
    aa22:	57 95       	ror	r21
    aa24:	47 95       	ror	r20
    aa26:	0a 94       	dec	r0
    aa28:	d2 f7       	brpl	.-12     	; 0xaa1e <__ashrdi3+0x6a>
    aa2a:	4d 83       	std	Y+5, r20	; 0x05
    aa2c:	5e 83       	std	Y+6, r21	; 0x06
    aa2e:	6f 83       	std	Y+7, r22	; 0x07
    aa30:	78 87       	std	Y+8, r23	; 0x08
    aa32:	04 c0       	rjmp	.+8      	; 0xaa3c <__ashrdi3+0x88>
    aa34:	88 0f       	add	r24, r24
    aa36:	99 1f       	adc	r25, r25
    aa38:	aa 1f       	adc	r26, r26
    aa3a:	bb 1f       	adc	r27, r27
    aa3c:	2a 95       	dec	r18
    aa3e:	d2 f7       	brpl	.-12     	; 0xaa34 <__ashrdi3+0x80>
    aa40:	49 85       	ldd	r20, Y+9	; 0x09
    aa42:	5a 85       	ldd	r21, Y+10	; 0x0a
    aa44:	6b 85       	ldd	r22, Y+11	; 0x0b
    aa46:	7c 85       	ldd	r23, Y+12	; 0x0c
    aa48:	04 c0       	rjmp	.+8      	; 0xaa52 <__ashrdi3+0x9e>
    aa4a:	76 95       	lsr	r23
    aa4c:	67 95       	ror	r22
    aa4e:	57 95       	ror	r21
    aa50:	47 95       	ror	r20
    aa52:	0a 95       	dec	r16
    aa54:	d2 f7       	brpl	.-12     	; 0xaa4a <__ashrdi3+0x96>
    aa56:	84 2b       	or	r24, r20
    aa58:	95 2b       	or	r25, r21
    aa5a:	a6 2b       	or	r26, r22
    aa5c:	b7 2b       	or	r27, r23
    aa5e:	89 83       	std	Y+1, r24	; 0x01
    aa60:	9a 83       	std	Y+2, r25	; 0x02
    aa62:	ab 83       	std	Y+3, r26	; 0x03
    aa64:	bc 83       	std	Y+4, r27	; 0x04
    aa66:	29 81       	ldd	r18, Y+1	; 0x01
    aa68:	3a 81       	ldd	r19, Y+2	; 0x02
    aa6a:	4b 81       	ldd	r20, Y+3	; 0x03
    aa6c:	5c 81       	ldd	r21, Y+4	; 0x04
    aa6e:	6d 81       	ldd	r22, Y+5	; 0x05
    aa70:	7e 81       	ldd	r23, Y+6	; 0x06
    aa72:	8f 81       	ldd	r24, Y+7	; 0x07
    aa74:	98 85       	ldd	r25, Y+8	; 0x08
    aa76:	60 96       	adiw	r28, 0x10	; 16
    aa78:	cd bf       	out	0x3d, r28	; 61
    aa7a:	de bf       	out	0x3e, r29	; 62
    aa7c:	df 91       	pop	r29
    aa7e:	cf 91       	pop	r28
    aa80:	0f 91       	pop	r16
    aa82:	08 95       	ret

0000aa84 <__divdi3>:
    aa84:	a8 e4       	ldi	r26, 0x48	; 72
    aa86:	b0 e0       	ldi	r27, 0x00	; 0
    aa88:	e8 e4       	ldi	r30, 0x48	; 72
    aa8a:	f5 e5       	ldi	r31, 0x55	; 85
    aa8c:	0c 94 f6 5e 	jmp	0xbdec	; 0xbdec <__prologue_saves__+0x2>
    aa90:	f5 01       	movw	r30, r10
    aa92:	29 a3       	lds	r18, 0x59
    aa94:	3a a3       	lds	r19, 0x5a
    aa96:	4b a3       	lds	r20, 0x5b
    aa98:	5c a3       	lds	r21, 0x5c
    aa9a:	6d a3       	lds	r22, 0x5d
    aa9c:	7e a3       	lds	r23, 0x5e
    aa9e:	8f a3       	lds	r24, 0x5f
    aaa0:	98 a7       	lds	r25, 0x78
    aaa2:	a9 8e       	std	Y+25, r10	; 0x19
    aaa4:	fa 8f       	std	Y+26, r31	; 0x1a
    aaa6:	cb 8e       	std	Y+27, r12	; 0x1b
    aaa8:	dc 8e       	std	Y+28, r13	; 0x1c
    aaaa:	ed 8e       	std	Y+29, r14	; 0x1d
    aaac:	fe 8e       	std	Y+30, r15	; 0x1e
    aaae:	0f 8f       	std	Y+31, r16	; 0x1f
    aab0:	18 a3       	lds	r17, 0x58
    aab2:	8d a0       	lds	r24, 0x8d
    aab4:	9e a0       	lds	r25, 0x8e
    aab6:	af a0       	lds	r26, 0x8f
    aab8:	b8 a4       	lds	r27, 0xa8
    aaba:	b7 fe       	sbrs	r11, 7
    aabc:	67 c0       	rjmp	.+206    	; 0xab8c <__divdi3+0x108>
    aabe:	21 95       	neg	r18
    aac0:	b1 e0       	ldi	r27, 0x01	; 1
    aac2:	12 16       	cp	r1, r18
    aac4:	08 f0       	brcs	.+2      	; 0xaac8 <__divdi3+0x44>
    aac6:	b0 e0       	ldi	r27, 0x00	; 0
    aac8:	31 95       	neg	r19
    aaca:	a1 e0       	ldi	r26, 0x01	; 1
    aacc:	13 16       	cp	r1, r19
    aace:	08 f0       	brcs	.+2      	; 0xaad2 <__divdi3+0x4e>
    aad0:	a0 e0       	ldi	r26, 0x00	; 0
    aad2:	b3 2e       	mov	r11, r19
    aad4:	bb 1a       	sub	r11, r27
    aad6:	bb 2d       	mov	r27, r11
    aad8:	88 24       	eor	r8, r8
    aada:	83 94       	inc	r8
    aadc:	3b 15       	cp	r19, r11
    aade:	08 f0       	brcs	.+2      	; 0xaae2 <__divdi3+0x5e>
    aae0:	88 24       	eor	r8, r8
    aae2:	a8 29       	or	r26, r8
    aae4:	41 95       	neg	r20
    aae6:	31 e0       	ldi	r19, 0x01	; 1
    aae8:	14 16       	cp	r1, r20
    aaea:	08 f0       	brcs	.+2      	; 0xaaee <__divdi3+0x6a>
    aaec:	30 e0       	ldi	r19, 0x00	; 0
    aaee:	b4 2e       	mov	r11, r20
    aaf0:	ba 1a       	sub	r11, r26
    aaf2:	ab 2d       	mov	r26, r11
    aaf4:	88 24       	eor	r8, r8
    aaf6:	83 94       	inc	r8
    aaf8:	4b 15       	cp	r20, r11
    aafa:	08 f0       	brcs	.+2      	; 0xaafe <__divdi3+0x7a>
    aafc:	88 24       	eor	r8, r8
    aafe:	38 29       	or	r19, r8
    ab00:	51 95       	neg	r21
    ab02:	41 e0       	ldi	r20, 0x01	; 1
    ab04:	15 16       	cp	r1, r21
    ab06:	08 f0       	brcs	.+2      	; 0xab0a <__divdi3+0x86>
    ab08:	40 e0       	ldi	r20, 0x00	; 0
    ab0a:	45 2e       	mov	r4, r21
    ab0c:	43 1a       	sub	r4, r19
    ab0e:	31 e0       	ldi	r19, 0x01	; 1
    ab10:	54 15       	cp	r21, r4
    ab12:	08 f0       	brcs	.+2      	; 0xab16 <__divdi3+0x92>
    ab14:	30 e0       	ldi	r19, 0x00	; 0
    ab16:	43 2b       	or	r20, r19
    ab18:	61 95       	neg	r22
    ab1a:	31 e0       	ldi	r19, 0x01	; 1
    ab1c:	16 16       	cp	r1, r22
    ab1e:	08 f0       	brcs	.+2      	; 0xab22 <__divdi3+0x9e>
    ab20:	30 e0       	ldi	r19, 0x00	; 0
    ab22:	86 2e       	mov	r8, r22
    ab24:	84 1a       	sub	r8, r20
    ab26:	41 e0       	ldi	r20, 0x01	; 1
    ab28:	68 15       	cp	r22, r8
    ab2a:	08 f0       	brcs	.+2      	; 0xab2e <__divdi3+0xaa>
    ab2c:	40 e0       	ldi	r20, 0x00	; 0
    ab2e:	34 2b       	or	r19, r20
    ab30:	71 95       	neg	r23
    ab32:	41 e0       	ldi	r20, 0x01	; 1
    ab34:	17 16       	cp	r1, r23
    ab36:	08 f0       	brcs	.+2      	; 0xab3a <__divdi3+0xb6>
    ab38:	40 e0       	ldi	r20, 0x00	; 0
    ab3a:	57 2f       	mov	r21, r23
    ab3c:	53 1b       	sub	r21, r19
    ab3e:	31 e0       	ldi	r19, 0x01	; 1
    ab40:	75 17       	cp	r23, r21
    ab42:	08 f0       	brcs	.+2      	; 0xab46 <__divdi3+0xc2>
    ab44:	30 e0       	ldi	r19, 0x00	; 0
    ab46:	43 2b       	or	r20, r19
    ab48:	81 95       	neg	r24
    ab4a:	31 e0       	ldi	r19, 0x01	; 1
    ab4c:	18 16       	cp	r1, r24
    ab4e:	08 f0       	brcs	.+2      	; 0xab52 <__divdi3+0xce>
    ab50:	30 e0       	ldi	r19, 0x00	; 0
    ab52:	68 2f       	mov	r22, r24
    ab54:	64 1b       	sub	r22, r20
    ab56:	46 2f       	mov	r20, r22
    ab58:	61 e0       	ldi	r22, 0x01	; 1
    ab5a:	84 17       	cp	r24, r20
    ab5c:	08 f0       	brcs	.+2      	; 0xab60 <__divdi3+0xdc>
    ab5e:	60 e0       	ldi	r22, 0x00	; 0
    ab60:	36 2b       	or	r19, r22
    ab62:	91 95       	neg	r25
    ab64:	93 1b       	sub	r25, r19
    ab66:	29 a3       	lds	r18, 0x59
    ab68:	ba a3       	lds	r27, 0x5a
    ab6a:	ab a3       	lds	r26, 0x5b
    ab6c:	4c a2       	lds	r20, 0x9c
    ab6e:	8d a2       	lds	r24, 0x9d
    ab70:	5e a3       	lds	r21, 0x5e
    ab72:	4f a3       	lds	r20, 0x5f
    ab74:	98 a7       	lds	r25, 0x78
    ab76:	8f ef       	ldi	r24, 0xFF	; 255
    ab78:	9f ef       	ldi	r25, 0xFF	; 255
    ab7a:	af ef       	ldi	r26, 0xFF	; 255
    ab7c:	bf ef       	ldi	r27, 0xFF	; 255
    ab7e:	25 96       	adiw	r28, 0x05	; 5
    ab80:	8c af       	sts	0x7c, r24
    ab82:	9d af       	sts	0x7d, r25
    ab84:	ae af       	sts	0x7e, r26
    ab86:	bf af       	sts	0x7f, r27
    ab88:	25 97       	sbiw	r28, 0x05	; 5
    ab8a:	06 c0       	rjmp	.+12     	; 0xab98 <__divdi3+0x114>
    ab8c:	25 96       	adiw	r28, 0x05	; 5
    ab8e:	1c ae       	sts	0xbc, r17
    ab90:	1d ae       	sts	0xbd, r17
    ab92:	1e ae       	sts	0xbe, r17
    ab94:	1f ae       	sts	0xbf, r17
    ab96:	25 97       	sbiw	r28, 0x05	; 5
    ab98:	8d 8d       	ldd	r24, Y+29	; 0x1d
    ab9a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    ab9c:	af 8d       	ldd	r26, Y+31	; 0x1f
    ab9e:	b8 a1       	lds	r27, 0x48
    aba0:	b7 ff       	sbrs	r27, 7
    aba2:	68 c0       	rjmp	.+208    	; 0xac74 <__divdi3+0x1f0>
    aba4:	25 96       	adiw	r28, 0x05	; 5
    aba6:	2c ad       	sts	0x6c, r18
    aba8:	3d ad       	sts	0x6d, r19
    abaa:	4e ad       	sts	0x6e, r20
    abac:	5f ad       	sts	0x6f, r21
    abae:	25 97       	sbiw	r28, 0x05	; 5
    abb0:	20 95       	com	r18
    abb2:	30 95       	com	r19
    abb4:	40 95       	com	r20
    abb6:	50 95       	com	r21
    abb8:	25 96       	adiw	r28, 0x05	; 5
    abba:	2c af       	sts	0x7c, r18
    abbc:	3d af       	sts	0x7d, r19
    abbe:	4e af       	sts	0x7e, r20
    abc0:	5f af       	sts	0x7f, r21
    abc2:	25 97       	sbiw	r28, 0x05	; 5
    abc4:	e1 95       	neg	r30
    abc6:	81 e0       	ldi	r24, 0x01	; 1
    abc8:	1e 16       	cp	r1, r30
    abca:	08 f0       	brcs	.+2      	; 0xabce <__divdi3+0x14a>
    abcc:	80 e0       	ldi	r24, 0x00	; 0
    abce:	f1 95       	neg	r31
    abd0:	91 e0       	ldi	r25, 0x01	; 1
    abd2:	1f 16       	cp	r1, r31
    abd4:	08 f0       	brcs	.+2      	; 0xabd8 <__divdi3+0x154>
    abd6:	90 e0       	ldi	r25, 0x00	; 0
    abd8:	4f 2f       	mov	r20, r31
    abda:	48 1b       	sub	r20, r24
    abdc:	81 e0       	ldi	r24, 0x01	; 1
    abde:	f4 17       	cp	r31, r20
    abe0:	08 f0       	brcs	.+2      	; 0xabe4 <__divdi3+0x160>
    abe2:	80 e0       	ldi	r24, 0x00	; 0
    abe4:	98 2b       	or	r25, r24
    abe6:	c1 94       	neg	r12
    abe8:	81 e0       	ldi	r24, 0x01	; 1
    abea:	1c 14       	cp	r1, r12
    abec:	08 f0       	brcs	.+2      	; 0xabf0 <__divdi3+0x16c>
    abee:	80 e0       	ldi	r24, 0x00	; 0
    abf0:	6c 2d       	mov	r22, r12
    abf2:	69 1b       	sub	r22, r25
    abf4:	91 e0       	ldi	r25, 0x01	; 1
    abf6:	c6 16       	cp	r12, r22
    abf8:	08 f0       	brcs	.+2      	; 0xabfc <__divdi3+0x178>
    abfa:	90 e0       	ldi	r25, 0x00	; 0
    abfc:	89 2b       	or	r24, r25
    abfe:	d1 94       	neg	r13
    ac00:	91 e0       	ldi	r25, 0x01	; 1
    ac02:	1d 14       	cp	r1, r13
    ac04:	08 f0       	brcs	.+2      	; 0xac08 <__divdi3+0x184>
    ac06:	90 e0       	ldi	r25, 0x00	; 0
    ac08:	5d 2d       	mov	r21, r13
    ac0a:	58 1b       	sub	r21, r24
    ac0c:	81 e0       	ldi	r24, 0x01	; 1
    ac0e:	d5 16       	cp	r13, r21
    ac10:	08 f0       	brcs	.+2      	; 0xac14 <__divdi3+0x190>
    ac12:	80 e0       	ldi	r24, 0x00	; 0
    ac14:	98 2b       	or	r25, r24
    ac16:	e1 94       	neg	r14
    ac18:	81 e0       	ldi	r24, 0x01	; 1
    ac1a:	1e 14       	cp	r1, r14
    ac1c:	08 f0       	brcs	.+2      	; 0xac20 <__divdi3+0x19c>
    ac1e:	80 e0       	ldi	r24, 0x00	; 0
    ac20:	3e 2d       	mov	r19, r14
    ac22:	39 1b       	sub	r19, r25
    ac24:	91 e0       	ldi	r25, 0x01	; 1
    ac26:	e3 16       	cp	r14, r19
    ac28:	08 f0       	brcs	.+2      	; 0xac2c <__divdi3+0x1a8>
    ac2a:	90 e0       	ldi	r25, 0x00	; 0
    ac2c:	89 2b       	or	r24, r25
    ac2e:	f1 94       	neg	r15
    ac30:	91 e0       	ldi	r25, 0x01	; 1
    ac32:	1f 14       	cp	r1, r15
    ac34:	08 f0       	brcs	.+2      	; 0xac38 <__divdi3+0x1b4>
    ac36:	90 e0       	ldi	r25, 0x00	; 0
    ac38:	2f 2d       	mov	r18, r15
    ac3a:	28 1b       	sub	r18, r24
    ac3c:	81 e0       	ldi	r24, 0x01	; 1
    ac3e:	f2 16       	cp	r15, r18
    ac40:	08 f0       	brcs	.+2      	; 0xac44 <__divdi3+0x1c0>
    ac42:	80 e0       	ldi	r24, 0x00	; 0
    ac44:	98 2b       	or	r25, r24
    ac46:	01 95       	neg	r16
    ac48:	81 e0       	ldi	r24, 0x01	; 1
    ac4a:	10 16       	cp	r1, r16
    ac4c:	08 f0       	brcs	.+2      	; 0xac50 <__divdi3+0x1cc>
    ac4e:	80 e0       	ldi	r24, 0x00	; 0
    ac50:	70 2f       	mov	r23, r16
    ac52:	79 1b       	sub	r23, r25
    ac54:	97 2f       	mov	r25, r23
    ac56:	71 e0       	ldi	r23, 0x01	; 1
    ac58:	09 17       	cp	r16, r25
    ac5a:	08 f0       	brcs	.+2      	; 0xac5e <__divdi3+0x1da>
    ac5c:	70 e0       	ldi	r23, 0x00	; 0
    ac5e:	87 2b       	or	r24, r23
    ac60:	11 95       	neg	r17
    ac62:	18 1b       	sub	r17, r24
    ac64:	e9 8f       	std	Y+25, r30	; 0x19
    ac66:	4a 8f       	std	Y+26, r20	; 0x1a
    ac68:	6b 8f       	std	Y+27, r22	; 0x1b
    ac6a:	5c 8f       	std	Y+28, r21	; 0x1c
    ac6c:	3d 8f       	std	Y+29, r19	; 0x1d
    ac6e:	2e 8f       	std	Y+30, r18	; 0x1e
    ac70:	9f 8f       	std	Y+31, r25	; 0x1f
    ac72:	18 a3       	lds	r17, 0x58
    ac74:	79 8d       	ldd	r23, Y+25	; 0x19
    ac76:	6a 8d       	ldd	r22, Y+26	; 0x1a
    ac78:	5b 8d       	ldd	r21, Y+27	; 0x1b
    ac7a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    ac7c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    ac7e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    ac80:	9f 8d       	ldd	r25, Y+31	; 0x1f
    ac82:	88 a1       	lds	r24, 0x48
    ac84:	e9 a1       	lds	r30, 0x49
    ac86:	e9 8b       	std	Y+17, r30	; 0x11
    ac88:	ea a1       	lds	r30, 0x4a
    ac8a:	ea 8b       	std	Y+18, r30	; 0x12
    ac8c:	eb a1       	lds	r30, 0x4b
    ac8e:	eb 8b       	std	Y+19, r30	; 0x13
    ac90:	ec a1       	lds	r30, 0x4c
    ac92:	ec 8b       	std	Y+20, r30	; 0x14
    ac94:	ed a1       	lds	r30, 0x4d
    ac96:	ed 8b       	std	Y+21, r30	; 0x15
    ac98:	ee a1       	lds	r30, 0x4e
    ac9a:	ee 8b       	std	Y+22, r30	; 0x16
    ac9c:	ef a1       	lds	r30, 0x4f
    ac9e:	ef 8b       	std	Y+23, r30	; 0x17
    aca0:	e8 a5       	lds	r30, 0x68
    aca2:	e8 8f       	std	Y+24, r30	; 0x18
    aca4:	79 87       	std	Y+9, r23	; 0x09
    aca6:	6a 87       	std	Y+10, r22	; 0x0a
    aca8:	5b 87       	std	Y+11, r21	; 0x0b
    acaa:	4c 87       	std	Y+12, r20	; 0x0c
    acac:	3d 87       	std	Y+13, r19	; 0x0d
    acae:	2e 87       	std	Y+14, r18	; 0x0e
    acb0:	9f 87       	std	Y+15, r25	; 0x0f
    acb2:	88 8b       	std	Y+16, r24	; 0x10
    acb4:	89 84       	ldd	r8, Y+9	; 0x09
    acb6:	9a 84       	ldd	r9, Y+10	; 0x0a
    acb8:	ab 84       	ldd	r10, Y+11	; 0x0b
    acba:	bc 84       	ldd	r11, Y+12	; 0x0c
    acbc:	8d 85       	ldd	r24, Y+13	; 0x0d
    acbe:	9e 85       	ldd	r25, Y+14	; 0x0e
    acc0:	af 85       	ldd	r26, Y+15	; 0x0f
    acc2:	b8 89       	ldd	r27, Y+16	; 0x10
    acc4:	e9 88       	ldd	r14, Y+17	; 0x11
    acc6:	fa 88       	ldd	r15, Y+18	; 0x12
    acc8:	0b 89       	ldd	r16, Y+19	; 0x13
    acca:	1c 89       	ldd	r17, Y+20	; 0x14
    accc:	ed aa       	sts	0x9d, r30
    acce:	fe aa       	sts	0x9e, r31
    acd0:	0f ab       	sts	0x5f, r16
    acd2:	18 af       	sts	0x78, r17
    acd4:	cd 88       	ldd	r12, Y+21	; 0x15
    acd6:	de 88       	ldd	r13, Y+22	; 0x16
    acd8:	ef 88       	ldd	r14, Y+23	; 0x17
    acda:	f8 8c       	ldd	r15, Y+24	; 0x18
    acdc:	00 97       	sbiw	r24, 0x00	; 0
    acde:	a1 05       	cpc	r26, r1
    ace0:	b1 05       	cpc	r27, r1
    ace2:	09 f0       	breq	.+2      	; 0xace6 <__divdi3+0x262>
    ace4:	bd c3       	rjmp	.+1914   	; 0xb460 <__divdi3+0x9dc>
    ace6:	c8 14       	cp	r12, r8
    ace8:	d9 04       	cpc	r13, r9
    acea:	ea 04       	cpc	r14, r10
    acec:	fb 04       	cpc	r15, r11
    acee:	08 f0       	brcs	.+2      	; 0xacf2 <__divdi3+0x26e>
    acf0:	4d c1       	rjmp	.+666    	; 0xaf8c <__divdi3+0x508>
    acf2:	00 e0       	ldi	r16, 0x00	; 0
    acf4:	80 16       	cp	r8, r16
    acf6:	00 e0       	ldi	r16, 0x00	; 0
    acf8:	90 06       	cpc	r9, r16
    acfa:	01 e0       	ldi	r16, 0x01	; 1
    acfc:	a0 06       	cpc	r10, r16
    acfe:	00 e0       	ldi	r16, 0x00	; 0
    ad00:	b0 06       	cpc	r11, r16
    ad02:	58 f4       	brcc	.+22     	; 0xad1a <__divdi3+0x296>
    ad04:	1f ef       	ldi	r17, 0xFF	; 255
    ad06:	81 16       	cp	r8, r17
    ad08:	91 04       	cpc	r9, r1
    ad0a:	a1 04       	cpc	r10, r1
    ad0c:	b1 04       	cpc	r11, r1
    ad0e:	09 f0       	breq	.+2      	; 0xad12 <__divdi3+0x28e>
    ad10:	90 f4       	brcc	.+36     	; 0xad36 <__divdi3+0x2b2>
    ad12:	80 e0       	ldi	r24, 0x00	; 0
    ad14:	90 e0       	ldi	r25, 0x00	; 0
    ad16:	dc 01       	movw	r26, r24
    ad18:	17 c0       	rjmp	.+46     	; 0xad48 <__divdi3+0x2c4>
    ad1a:	20 e0       	ldi	r18, 0x00	; 0
    ad1c:	82 16       	cp	r8, r18
    ad1e:	20 e0       	ldi	r18, 0x00	; 0
    ad20:	92 06       	cpc	r9, r18
    ad22:	20 e0       	ldi	r18, 0x00	; 0
    ad24:	a2 06       	cpc	r10, r18
    ad26:	21 e0       	ldi	r18, 0x01	; 1
    ad28:	b2 06       	cpc	r11, r18
    ad2a:	50 f4       	brcc	.+20     	; 0xad40 <__divdi3+0x2bc>
    ad2c:	80 e1       	ldi	r24, 0x10	; 16
    ad2e:	90 e0       	ldi	r25, 0x00	; 0
    ad30:	a0 e0       	ldi	r26, 0x00	; 0
    ad32:	b0 e0       	ldi	r27, 0x00	; 0
    ad34:	09 c0       	rjmp	.+18     	; 0xad48 <__divdi3+0x2c4>
    ad36:	88 e0       	ldi	r24, 0x08	; 8
    ad38:	90 e0       	ldi	r25, 0x00	; 0
    ad3a:	a0 e0       	ldi	r26, 0x00	; 0
    ad3c:	b0 e0       	ldi	r27, 0x00	; 0
    ad3e:	04 c0       	rjmp	.+8      	; 0xad48 <__divdi3+0x2c4>
    ad40:	88 e1       	ldi	r24, 0x18	; 24
    ad42:	90 e0       	ldi	r25, 0x00	; 0
    ad44:	a0 e0       	ldi	r26, 0x00	; 0
    ad46:	b0 e0       	ldi	r27, 0x00	; 0
    ad48:	b5 01       	movw	r22, r10
    ad4a:	a4 01       	movw	r20, r8
    ad4c:	08 2e       	mov	r0, r24
    ad4e:	04 c0       	rjmp	.+8      	; 0xad58 <__divdi3+0x2d4>
    ad50:	76 95       	lsr	r23
    ad52:	67 95       	ror	r22
    ad54:	57 95       	ror	r21
    ad56:	47 95       	ror	r20
    ad58:	0a 94       	dec	r0
    ad5a:	d2 f7       	brpl	.-12     	; 0xad50 <__divdi3+0x2cc>
    ad5c:	fa 01       	movw	r30, r20
    ad5e:	e6 5c       	subi	r30, 0xC6	; 198
    ad60:	ff 4d       	sbci	r31, 0xDF	; 223
    ad62:	20 81       	ld	r18, Z
    ad64:	40 e2       	ldi	r20, 0x20	; 32
    ad66:	50 e0       	ldi	r21, 0x00	; 0
    ad68:	60 e0       	ldi	r22, 0x00	; 0
    ad6a:	70 e0       	ldi	r23, 0x00	; 0
    ad6c:	48 1b       	sub	r20, r24
    ad6e:	59 0b       	sbc	r21, r25
    ad70:	6a 0b       	sbc	r22, r26
    ad72:	7b 0b       	sbc	r23, r27
    ad74:	42 1b       	sub	r20, r18
    ad76:	51 09       	sbc	r21, r1
    ad78:	61 09       	sbc	r22, r1
    ad7a:	71 09       	sbc	r23, r1
    ad7c:	41 15       	cp	r20, r1
    ad7e:	51 05       	cpc	r21, r1
    ad80:	61 05       	cpc	r22, r1
    ad82:	71 05       	cpc	r23, r1
    ad84:	a1 f1       	breq	.+104    	; 0xadee <__divdi3+0x36a>
    ad86:	04 2e       	mov	r0, r20
    ad88:	04 c0       	rjmp	.+8      	; 0xad92 <__divdi3+0x30e>
    ad8a:	88 0c       	add	r8, r8
    ad8c:	99 1c       	adc	r9, r9
    ad8e:	aa 1c       	adc	r10, r10
    ad90:	bb 1c       	adc	r11, r11
    ad92:	0a 94       	dec	r0
    ad94:	d2 f7       	brpl	.-12     	; 0xad8a <__divdi3+0x306>
    ad96:	97 01       	movw	r18, r14
    ad98:	86 01       	movw	r16, r12
    ad9a:	04 2e       	mov	r0, r20
    ad9c:	04 c0       	rjmp	.+8      	; 0xada6 <__divdi3+0x322>
    ad9e:	00 0f       	add	r16, r16
    ada0:	11 1f       	adc	r17, r17
    ada2:	22 1f       	adc	r18, r18
    ada4:	33 1f       	adc	r19, r19
    ada6:	0a 94       	dec	r0
    ada8:	d2 f7       	brpl	.-12     	; 0xad9e <__divdi3+0x31a>
    adaa:	80 e2       	ldi	r24, 0x20	; 32
    adac:	90 e0       	ldi	r25, 0x00	; 0
    adae:	84 1b       	sub	r24, r20
    adb0:	95 0b       	sbc	r25, r21
    adb2:	cd a8       	sts	0x8d, r28
    adb4:	de a8       	sts	0x8e, r29
    adb6:	ef a8       	sts	0x8f, r30
    adb8:	f8 ac       	sts	0xa8, r31
    adba:	04 c0       	rjmp	.+8      	; 0xadc4 <__divdi3+0x340>
    adbc:	f6 94       	lsr	r15
    adbe:	e7 94       	ror	r14
    adc0:	d7 94       	ror	r13
    adc2:	c7 94       	ror	r12
    adc4:	8a 95       	dec	r24
    adc6:	d2 f7       	brpl	.-12     	; 0xadbc <__divdi3+0x338>
    adc8:	c0 2a       	or	r12, r16
    adca:	d1 2a       	or	r13, r17
    adcc:	e2 2a       	or	r14, r18
    adce:	f3 2a       	or	r15, r19
    add0:	0d a9       	sts	0x4d, r16
    add2:	1e a9       	sts	0x4e, r17
    add4:	2f a9       	sts	0x4f, r18
    add6:	38 ad       	sts	0x68, r19
    add8:	04 c0       	rjmp	.+8      	; 0xade2 <__divdi3+0x35e>
    adda:	00 0f       	add	r16, r16
    addc:	11 1f       	adc	r17, r17
    adde:	22 1f       	adc	r18, r18
    ade0:	33 1f       	adc	r19, r19
    ade2:	4a 95       	dec	r20
    ade4:	d2 f7       	brpl	.-12     	; 0xadda <__divdi3+0x356>
    ade6:	0d ab       	sts	0x5d, r16
    ade8:	1e ab       	sts	0x5e, r17
    adea:	2f ab       	sts	0x5f, r18
    adec:	38 af       	sts	0x78, r19
    adee:	25 01       	movw	r4, r10
    adf0:	66 24       	eor	r6, r6
    adf2:	77 24       	eor	r7, r7
    adf4:	95 01       	movw	r18, r10
    adf6:	84 01       	movw	r16, r8
    adf8:	20 70       	andi	r18, 0x00	; 0
    adfa:	30 70       	andi	r19, 0x00	; 0
    adfc:	09 ab       	sts	0x59, r16
    adfe:	1a ab       	sts	0x5a, r17
    ae00:	2b ab       	sts	0x5b, r18
    ae02:	3c ab       	sts	0x5c, r19
    ae04:	c7 01       	movw	r24, r14
    ae06:	b6 01       	movw	r22, r12
    ae08:	a3 01       	movw	r20, r6
    ae0a:	92 01       	movw	r18, r4
    ae0c:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    ae10:	2d a7       	lds	r18, 0x7d
    ae12:	3e a7       	lds	r19, 0x7e
    ae14:	4f a7       	lds	r20, 0x7f
    ae16:	58 ab       	sts	0x58, r21
    ae18:	69 a7       	lds	r22, 0x79
    ae1a:	7a a7       	lds	r23, 0x7a
    ae1c:	8b a7       	lds	r24, 0x7b
    ae1e:	9c a7       	lds	r25, 0x7c
    ae20:	c7 01       	movw	r24, r14
    ae22:	b6 01       	movw	r22, r12
    ae24:	a3 01       	movw	r20, r6
    ae26:	92 01       	movw	r18, r4
    ae28:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    ae2c:	ca 01       	movw	r24, r20
    ae2e:	b9 01       	movw	r22, r18
    ae30:	29 a9       	sts	0x49, r18
    ae32:	3a a9       	sts	0x4a, r19
    ae34:	4b a9       	sts	0x4b, r20
    ae36:	5c a9       	sts	0x4c, r21
    ae38:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    ae3c:	ab 01       	movw	r20, r22
    ae3e:	bc 01       	movw	r22, r24
    ae40:	09 a5       	lds	r16, 0x69
    ae42:	1a a5       	lds	r17, 0x6a
    ae44:	2b a5       	lds	r18, 0x6b
    ae46:	3c a5       	lds	r19, 0x6c
    ae48:	78 01       	movw	r14, r16
    ae4a:	dd 24       	eor	r13, r13
    ae4c:	cc 24       	eor	r12, r12
    ae4e:	0d a9       	sts	0x4d, r16
    ae50:	1e a9       	sts	0x4e, r17
    ae52:	2f a9       	sts	0x4f, r18
    ae54:	38 ad       	sts	0x68, r19
    ae56:	c9 01       	movw	r24, r18
    ae58:	aa 27       	eor	r26, r26
    ae5a:	bb 27       	eor	r27, r27
    ae5c:	c8 2a       	or	r12, r24
    ae5e:	d9 2a       	or	r13, r25
    ae60:	ea 2a       	or	r14, r26
    ae62:	fb 2a       	or	r15, r27
    ae64:	0d a5       	lds	r16, 0x6d
    ae66:	1e a5       	lds	r17, 0x6e
    ae68:	2f a5       	lds	r18, 0x6f
    ae6a:	38 a9       	sts	0x48, r19
    ae6c:	c4 16       	cp	r12, r20
    ae6e:	d5 06       	cpc	r13, r21
    ae70:	e6 06       	cpc	r14, r22
    ae72:	f7 06       	cpc	r15, r23
    ae74:	38 f5       	brcc	.+78     	; 0xaec4 <__divdi3+0x440>
    ae76:	01 50       	subi	r16, 0x01	; 1
    ae78:	10 40       	sbci	r17, 0x00	; 0
    ae7a:	20 40       	sbci	r18, 0x00	; 0
    ae7c:	30 40       	sbci	r19, 0x00	; 0
    ae7e:	09 a7       	lds	r16, 0x79
    ae80:	1a a7       	lds	r17, 0x7a
    ae82:	2b a7       	lds	r18, 0x7b
    ae84:	3c a7       	lds	r19, 0x7c
    ae86:	c8 0c       	add	r12, r8
    ae88:	d9 1c       	adc	r13, r9
    ae8a:	ea 1c       	adc	r14, r10
    ae8c:	fb 1c       	adc	r15, r11
    ae8e:	c8 14       	cp	r12, r8
    ae90:	d9 04       	cpc	r13, r9
    ae92:	ea 04       	cpc	r14, r10
    ae94:	fb 04       	cpc	r15, r11
    ae96:	d0 f0       	brcs	.+52     	; 0xaecc <__divdi3+0x448>
    ae98:	c4 16       	cp	r12, r20
    ae9a:	d5 06       	cpc	r13, r21
    ae9c:	e6 06       	cpc	r14, r22
    ae9e:	f7 06       	cpc	r15, r23
    aea0:	a8 f4       	brcc	.+42     	; 0xaecc <__divdi3+0x448>
    aea2:	0d a5       	lds	r16, 0x6d
    aea4:	1e a5       	lds	r17, 0x6e
    aea6:	2f a5       	lds	r18, 0x6f
    aea8:	38 a9       	sts	0x48, r19
    aeaa:	02 50       	subi	r16, 0x02	; 2
    aeac:	10 40       	sbci	r17, 0x00	; 0
    aeae:	20 40       	sbci	r18, 0x00	; 0
    aeb0:	30 40       	sbci	r19, 0x00	; 0
    aeb2:	09 a7       	lds	r16, 0x79
    aeb4:	1a a7       	lds	r17, 0x7a
    aeb6:	2b a7       	lds	r18, 0x7b
    aeb8:	3c a7       	lds	r19, 0x7c
    aeba:	c8 0c       	add	r12, r8
    aebc:	d9 1c       	adc	r13, r9
    aebe:	ea 1c       	adc	r14, r10
    aec0:	fb 1c       	adc	r15, r11
    aec2:	04 c0       	rjmp	.+8      	; 0xaecc <__divdi3+0x448>
    aec4:	09 a7       	lds	r16, 0x79
    aec6:	1a a7       	lds	r17, 0x7a
    aec8:	2b a7       	lds	r18, 0x7b
    aeca:	3c a7       	lds	r19, 0x7c
    aecc:	c4 1a       	sub	r12, r20
    aece:	d5 0a       	sbc	r13, r21
    aed0:	e6 0a       	sbc	r14, r22
    aed2:	f7 0a       	sbc	r15, r23
    aed4:	c7 01       	movw	r24, r14
    aed6:	b6 01       	movw	r22, r12
    aed8:	a3 01       	movw	r20, r6
    aeda:	92 01       	movw	r18, r4
    aedc:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    aee0:	2d a7       	lds	r18, 0x7d
    aee2:	3e a7       	lds	r19, 0x7e
    aee4:	4f a7       	lds	r20, 0x7f
    aee6:	58 ab       	sts	0x58, r21
    aee8:	69 af       	sts	0x79, r22
    aeea:	7a af       	sts	0x7a, r23
    aeec:	8b af       	sts	0x7b, r24
    aeee:	9c af       	sts	0x7c, r25
    aef0:	c7 01       	movw	r24, r14
    aef2:	b6 01       	movw	r22, r12
    aef4:	a3 01       	movw	r20, r6
    aef6:	92 01       	movw	r18, r4
    aef8:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    aefc:	ca 01       	movw	r24, r20
    aefe:	b9 01       	movw	r22, r18
    af00:	29 a9       	sts	0x49, r18
    af02:	3a a9       	sts	0x4a, r19
    af04:	4b a9       	sts	0x4b, r20
    af06:	5c a9       	sts	0x4c, r21
    af08:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    af0c:	6b 01       	movw	r12, r22
    af0e:	7c 01       	movw	r14, r24
    af10:	49 ad       	sts	0x69, r20
    af12:	5a ad       	sts	0x6a, r21
    af14:	6b ad       	sts	0x6b, r22
    af16:	7c ad       	sts	0x6c, r23
    af18:	9a 01       	movw	r18, r20
    af1a:	11 27       	eor	r17, r17
    af1c:	00 27       	eor	r16, r16
    af1e:	4d a9       	sts	0x4d, r20
    af20:	5e a9       	sts	0x4e, r21
    af22:	6f a9       	sts	0x4f, r22
    af24:	78 ad       	sts	0x68, r23
    af26:	60 70       	andi	r22, 0x00	; 0
    af28:	70 70       	andi	r23, 0x00	; 0
    af2a:	04 2b       	or	r16, r20
    af2c:	15 2b       	or	r17, r21
    af2e:	26 2b       	or	r18, r22
    af30:	37 2b       	or	r19, r23
    af32:	8d a5       	lds	r24, 0x6d
    af34:	9e a5       	lds	r25, 0x6e
    af36:	af a5       	lds	r26, 0x6f
    af38:	b8 a9       	sts	0x48, r27
    af3a:	0c 15       	cp	r16, r12
    af3c:	1d 05       	cpc	r17, r13
    af3e:	2e 05       	cpc	r18, r14
    af40:	3f 05       	cpc	r19, r15
    af42:	c0 f4       	brcc	.+48     	; 0xaf74 <__divdi3+0x4f0>
    af44:	01 97       	sbiw	r24, 0x01	; 1
    af46:	a1 09       	sbc	r26, r1
    af48:	b1 09       	sbc	r27, r1
    af4a:	08 0d       	add	r16, r8
    af4c:	19 1d       	adc	r17, r9
    af4e:	2a 1d       	adc	r18, r10
    af50:	3b 1d       	adc	r19, r11
    af52:	08 15       	cp	r16, r8
    af54:	19 05       	cpc	r17, r9
    af56:	2a 05       	cpc	r18, r10
    af58:	3b 05       	cpc	r19, r11
    af5a:	60 f0       	brcs	.+24     	; 0xaf74 <__divdi3+0x4f0>
    af5c:	0c 15       	cp	r16, r12
    af5e:	1d 05       	cpc	r17, r13
    af60:	2e 05       	cpc	r18, r14
    af62:	3f 05       	cpc	r19, r15
    af64:	38 f4       	brcc	.+14     	; 0xaf74 <__divdi3+0x4f0>
    af66:	8d a5       	lds	r24, 0x6d
    af68:	9e a5       	lds	r25, 0x6e
    af6a:	af a5       	lds	r26, 0x6f
    af6c:	b8 a9       	sts	0x48, r27
    af6e:	02 97       	sbiw	r24, 0x02	; 2
    af70:	a1 09       	sbc	r26, r1
    af72:	b1 09       	sbc	r27, r1
    af74:	09 a5       	lds	r16, 0x69
    af76:	1a a5       	lds	r17, 0x6a
    af78:	2b a5       	lds	r18, 0x6b
    af7a:	3c a5       	lds	r19, 0x6c
    af7c:	78 01       	movw	r14, r16
    af7e:	dd 24       	eor	r13, r13
    af80:	cc 24       	eor	r12, r12
    af82:	c8 2a       	or	r12, r24
    af84:	d9 2a       	or	r13, r25
    af86:	ea 2a       	or	r14, r26
    af88:	fb 2a       	or	r15, r27
    af8a:	b7 c4       	rjmp	.+2414   	; 0xb8fa <__divdi3+0xe76>
    af8c:	81 14       	cp	r8, r1
    af8e:	91 04       	cpc	r9, r1
    af90:	a1 04       	cpc	r10, r1
    af92:	b1 04       	cpc	r11, r1
    af94:	51 f4       	brne	.+20     	; 0xafaa <__divdi3+0x526>
    af96:	61 e0       	ldi	r22, 0x01	; 1
    af98:	70 e0       	ldi	r23, 0x00	; 0
    af9a:	80 e0       	ldi	r24, 0x00	; 0
    af9c:	90 e0       	ldi	r25, 0x00	; 0
    af9e:	a5 01       	movw	r20, r10
    afa0:	94 01       	movw	r18, r8
    afa2:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    afa6:	49 01       	movw	r8, r18
    afa8:	5a 01       	movw	r10, r20
    afaa:	10 e0       	ldi	r17, 0x00	; 0
    afac:	81 16       	cp	r8, r17
    afae:	10 e0       	ldi	r17, 0x00	; 0
    afb0:	91 06       	cpc	r9, r17
    afb2:	11 e0       	ldi	r17, 0x01	; 1
    afb4:	a1 06       	cpc	r10, r17
    afb6:	10 e0       	ldi	r17, 0x00	; 0
    afb8:	b1 06       	cpc	r11, r17
    afba:	58 f4       	brcc	.+22     	; 0xafd2 <__divdi3+0x54e>
    afbc:	2f ef       	ldi	r18, 0xFF	; 255
    afbe:	82 16       	cp	r8, r18
    afc0:	91 04       	cpc	r9, r1
    afc2:	a1 04       	cpc	r10, r1
    afc4:	b1 04       	cpc	r11, r1
    afc6:	09 f0       	breq	.+2      	; 0xafca <__divdi3+0x546>
    afc8:	90 f4       	brcc	.+36     	; 0xafee <__divdi3+0x56a>
    afca:	80 e0       	ldi	r24, 0x00	; 0
    afcc:	90 e0       	ldi	r25, 0x00	; 0
    afce:	dc 01       	movw	r26, r24
    afd0:	17 c0       	rjmp	.+46     	; 0xb000 <__divdi3+0x57c>
    afd2:	30 e0       	ldi	r19, 0x00	; 0
    afd4:	83 16       	cp	r8, r19
    afd6:	30 e0       	ldi	r19, 0x00	; 0
    afd8:	93 06       	cpc	r9, r19
    afda:	30 e0       	ldi	r19, 0x00	; 0
    afdc:	a3 06       	cpc	r10, r19
    afde:	31 e0       	ldi	r19, 0x01	; 1
    afe0:	b3 06       	cpc	r11, r19
    afe2:	50 f4       	brcc	.+20     	; 0xaff8 <__divdi3+0x574>
    afe4:	80 e1       	ldi	r24, 0x10	; 16
    afe6:	90 e0       	ldi	r25, 0x00	; 0
    afe8:	a0 e0       	ldi	r26, 0x00	; 0
    afea:	b0 e0       	ldi	r27, 0x00	; 0
    afec:	09 c0       	rjmp	.+18     	; 0xb000 <__divdi3+0x57c>
    afee:	88 e0       	ldi	r24, 0x08	; 8
    aff0:	90 e0       	ldi	r25, 0x00	; 0
    aff2:	a0 e0       	ldi	r26, 0x00	; 0
    aff4:	b0 e0       	ldi	r27, 0x00	; 0
    aff6:	04 c0       	rjmp	.+8      	; 0xb000 <__divdi3+0x57c>
    aff8:	88 e1       	ldi	r24, 0x18	; 24
    affa:	90 e0       	ldi	r25, 0x00	; 0
    affc:	a0 e0       	ldi	r26, 0x00	; 0
    affe:	b0 e0       	ldi	r27, 0x00	; 0
    b000:	b5 01       	movw	r22, r10
    b002:	a4 01       	movw	r20, r8
    b004:	08 2e       	mov	r0, r24
    b006:	04 c0       	rjmp	.+8      	; 0xb010 <__divdi3+0x58c>
    b008:	76 95       	lsr	r23
    b00a:	67 95       	ror	r22
    b00c:	57 95       	ror	r21
    b00e:	47 95       	ror	r20
    b010:	0a 94       	dec	r0
    b012:	d2 f7       	brpl	.-12     	; 0xb008 <__divdi3+0x584>
    b014:	fa 01       	movw	r30, r20
    b016:	e6 5c       	subi	r30, 0xC6	; 198
    b018:	ff 4d       	sbci	r31, 0xDF	; 223
    b01a:	20 81       	ld	r18, Z
    b01c:	ac 01       	movw	r20, r24
    b01e:	bd 01       	movw	r22, r26
    b020:	42 0f       	add	r20, r18
    b022:	51 1d       	adc	r21, r1
    b024:	61 1d       	adc	r22, r1
    b026:	71 1d       	adc	r23, r1
    b028:	80 e2       	ldi	r24, 0x20	; 32
    b02a:	90 e0       	ldi	r25, 0x00	; 0
    b02c:	a0 e0       	ldi	r26, 0x00	; 0
    b02e:	b0 e0       	ldi	r27, 0x00	; 0
    b030:	84 1b       	sub	r24, r20
    b032:	95 0b       	sbc	r25, r21
    b034:	a6 0b       	sbc	r26, r22
    b036:	b7 0b       	sbc	r27, r23
    b038:	51 f4       	brne	.+20     	; 0xb04e <__divdi3+0x5ca>
    b03a:	c8 18       	sub	r12, r8
    b03c:	d9 08       	sbc	r13, r9
    b03e:	ea 08       	sbc	r14, r10
    b040:	fb 08       	sbc	r15, r11
    b042:	f1 e0       	ldi	r31, 0x01	; 1
    b044:	4f 2e       	mov	r4, r31
    b046:	51 2c       	mov	r5, r1
    b048:	61 2c       	mov	r6, r1
    b04a:	71 2c       	mov	r7, r1
    b04c:	28 c1       	rjmp	.+592    	; 0xb29e <__divdi3+0x81a>
    b04e:	08 2e       	mov	r0, r24
    b050:	04 c0       	rjmp	.+8      	; 0xb05a <__divdi3+0x5d6>
    b052:	88 0c       	add	r8, r8
    b054:	99 1c       	adc	r9, r9
    b056:	aa 1c       	adc	r10, r10
    b058:	bb 1c       	adc	r11, r11
    b05a:	0a 94       	dec	r0
    b05c:	d2 f7       	brpl	.-12     	; 0xb052 <__divdi3+0x5ce>
    b05e:	97 01       	movw	r18, r14
    b060:	86 01       	movw	r16, r12
    b062:	04 2e       	mov	r0, r20
    b064:	04 c0       	rjmp	.+8      	; 0xb06e <__divdi3+0x5ea>
    b066:	36 95       	lsr	r19
    b068:	27 95       	ror	r18
    b06a:	17 95       	ror	r17
    b06c:	07 95       	ror	r16
    b06e:	0a 94       	dec	r0
    b070:	d2 f7       	brpl	.-12     	; 0xb066 <__divdi3+0x5e2>
    b072:	09 ab       	sts	0x59, r16
    b074:	1a ab       	sts	0x5a, r17
    b076:	2b ab       	sts	0x5b, r18
    b078:	3c ab       	sts	0x5c, r19
    b07a:	97 01       	movw	r18, r14
    b07c:	86 01       	movw	r16, r12
    b07e:	08 2e       	mov	r0, r24
    b080:	04 c0       	rjmp	.+8      	; 0xb08a <__divdi3+0x606>
    b082:	00 0f       	add	r16, r16
    b084:	11 1f       	adc	r17, r17
    b086:	22 1f       	adc	r18, r18
    b088:	33 1f       	adc	r19, r19
    b08a:	0a 94       	dec	r0
    b08c:	d2 f7       	brpl	.-12     	; 0xb082 <__divdi3+0x5fe>
    b08e:	0d a7       	lds	r16, 0x7d
    b090:	1e a7       	lds	r17, 0x7e
    b092:	2f a7       	lds	r18, 0x7f
    b094:	38 ab       	sts	0x58, r19
    b096:	ed a8       	sts	0x8d, r30
    b098:	fe a8       	sts	0x8e, r31
    b09a:	0f a9       	sts	0x4f, r16
    b09c:	18 ad       	sts	0x68, r17
    b09e:	04 c0       	rjmp	.+8      	; 0xb0a8 <__divdi3+0x624>
    b0a0:	16 95       	lsr	r17
    b0a2:	07 95       	ror	r16
    b0a4:	f7 94       	ror	r15
    b0a6:	e7 94       	ror	r14
    b0a8:	4a 95       	dec	r20
    b0aa:	d2 f7       	brpl	.-12     	; 0xb0a0 <__divdi3+0x61c>
    b0ac:	b8 01       	movw	r22, r16
    b0ae:	a7 01       	movw	r20, r14
    b0b0:	0d a5       	lds	r16, 0x6d
    b0b2:	1e a5       	lds	r17, 0x6e
    b0b4:	2f a5       	lds	r18, 0x6f
    b0b6:	38 a9       	sts	0x48, r19
    b0b8:	04 2b       	or	r16, r20
    b0ba:	15 2b       	or	r17, r21
    b0bc:	26 2b       	or	r18, r22
    b0be:	37 2b       	or	r19, r23
    b0c0:	0d a7       	lds	r16, 0x7d
    b0c2:	1e a7       	lds	r17, 0x7e
    b0c4:	2f a7       	lds	r18, 0x7f
    b0c6:	38 ab       	sts	0x58, r19
    b0c8:	ed a8       	sts	0x8d, r30
    b0ca:	fe a8       	sts	0x8e, r31
    b0cc:	0f a9       	sts	0x4f, r16
    b0ce:	18 ad       	sts	0x68, r17
    b0d0:	04 c0       	rjmp	.+8      	; 0xb0da <__divdi3+0x656>
    b0d2:	ee 0c       	add	r14, r14
    b0d4:	ff 1c       	adc	r15, r15
    b0d6:	00 1f       	adc	r16, r16
    b0d8:	11 1f       	adc	r17, r17
    b0da:	8a 95       	dec	r24
    b0dc:	d2 f7       	brpl	.-12     	; 0xb0d2 <__divdi3+0x64e>
    b0de:	ed aa       	sts	0x9d, r30
    b0e0:	fe aa       	sts	0x9e, r31
    b0e2:	0f ab       	sts	0x5f, r16
    b0e4:	18 af       	sts	0x78, r17
    b0e6:	25 01       	movw	r4, r10
    b0e8:	66 24       	eor	r6, r6
    b0ea:	77 24       	eor	r7, r7
    b0ec:	95 01       	movw	r18, r10
    b0ee:	84 01       	movw	r16, r8
    b0f0:	20 70       	andi	r18, 0x00	; 0
    b0f2:	30 70       	andi	r19, 0x00	; 0
    b0f4:	09 af       	sts	0x79, r16
    b0f6:	1a af       	sts	0x7a, r17
    b0f8:	2b af       	sts	0x7b, r18
    b0fa:	3c af       	sts	0x7c, r19
    b0fc:	69 a9       	sts	0x49, r22
    b0fe:	7a a9       	sts	0x4a, r23
    b100:	8b a9       	sts	0x4b, r24
    b102:	9c a9       	sts	0x4c, r25
    b104:	a3 01       	movw	r20, r6
    b106:	92 01       	movw	r18, r4
    b108:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b10c:	29 a7       	lds	r18, 0x79
    b10e:	3a a7       	lds	r19, 0x7a
    b110:	4b a7       	lds	r20, 0x7b
    b112:	5c a7       	lds	r21, 0x7c
    b114:	6b 01       	movw	r12, r22
    b116:	7c 01       	movw	r14, r24
    b118:	69 a9       	sts	0x49, r22
    b11a:	7a a9       	sts	0x4a, r23
    b11c:	8b a9       	sts	0x4b, r24
    b11e:	9c a9       	sts	0x4c, r25
    b120:	a3 01       	movw	r20, r6
    b122:	92 01       	movw	r18, r4
    b124:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b128:	ca 01       	movw	r24, r20
    b12a:	b9 01       	movw	r22, r18
    b12c:	29 ad       	sts	0x69, r18
    b12e:	3a ad       	sts	0x6a, r19
    b130:	4b ad       	sts	0x6b, r20
    b132:	5c ad       	sts	0x6c, r21
    b134:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b138:	ab 01       	movw	r20, r22
    b13a:	bc 01       	movw	r22, r24
    b13c:	76 01       	movw	r14, r12
    b13e:	dd 24       	eor	r13, r13
    b140:	cc 24       	eor	r12, r12
    b142:	0d a5       	lds	r16, 0x6d
    b144:	1e a5       	lds	r17, 0x6e
    b146:	2f a5       	lds	r18, 0x6f
    b148:	38 a9       	sts	0x48, r19
    b14a:	c9 01       	movw	r24, r18
    b14c:	aa 27       	eor	r26, r26
    b14e:	bb 27       	eor	r27, r27
    b150:	c8 2a       	or	r12, r24
    b152:	d9 2a       	or	r13, r25
    b154:	ea 2a       	or	r14, r26
    b156:	fb 2a       	or	r15, r27
    b158:	09 a5       	lds	r16, 0x69
    b15a:	1a a5       	lds	r17, 0x6a
    b15c:	2b a5       	lds	r18, 0x6b
    b15e:	3c a5       	lds	r19, 0x6c
    b160:	c4 16       	cp	r12, r20
    b162:	d5 06       	cpc	r13, r21
    b164:	e6 06       	cpc	r14, r22
    b166:	f7 06       	cpc	r15, r23
    b168:	38 f5       	brcc	.+78     	; 0xb1b8 <__divdi3+0x734>
    b16a:	01 50       	subi	r16, 0x01	; 1
    b16c:	10 40       	sbci	r17, 0x00	; 0
    b16e:	20 40       	sbci	r18, 0x00	; 0
    b170:	30 40       	sbci	r19, 0x00	; 0
    b172:	09 ab       	sts	0x59, r16
    b174:	1a ab       	sts	0x5a, r17
    b176:	2b ab       	sts	0x5b, r18
    b178:	3c ab       	sts	0x5c, r19
    b17a:	c8 0c       	add	r12, r8
    b17c:	d9 1c       	adc	r13, r9
    b17e:	ea 1c       	adc	r14, r10
    b180:	fb 1c       	adc	r15, r11
    b182:	c8 14       	cp	r12, r8
    b184:	d9 04       	cpc	r13, r9
    b186:	ea 04       	cpc	r14, r10
    b188:	fb 04       	cpc	r15, r11
    b18a:	d0 f0       	brcs	.+52     	; 0xb1c0 <__divdi3+0x73c>
    b18c:	c4 16       	cp	r12, r20
    b18e:	d5 06       	cpc	r13, r21
    b190:	e6 06       	cpc	r14, r22
    b192:	f7 06       	cpc	r15, r23
    b194:	a8 f4       	brcc	.+42     	; 0xb1c0 <__divdi3+0x73c>
    b196:	09 a5       	lds	r16, 0x69
    b198:	1a a5       	lds	r17, 0x6a
    b19a:	2b a5       	lds	r18, 0x6b
    b19c:	3c a5       	lds	r19, 0x6c
    b19e:	02 50       	subi	r16, 0x02	; 2
    b1a0:	10 40       	sbci	r17, 0x00	; 0
    b1a2:	20 40       	sbci	r18, 0x00	; 0
    b1a4:	30 40       	sbci	r19, 0x00	; 0
    b1a6:	09 ab       	sts	0x59, r16
    b1a8:	1a ab       	sts	0x5a, r17
    b1aa:	2b ab       	sts	0x5b, r18
    b1ac:	3c ab       	sts	0x5c, r19
    b1ae:	c8 0c       	add	r12, r8
    b1b0:	d9 1c       	adc	r13, r9
    b1b2:	ea 1c       	adc	r14, r10
    b1b4:	fb 1c       	adc	r15, r11
    b1b6:	04 c0       	rjmp	.+8      	; 0xb1c0 <__divdi3+0x73c>
    b1b8:	09 ab       	sts	0x59, r16
    b1ba:	1a ab       	sts	0x5a, r17
    b1bc:	2b ab       	sts	0x5b, r18
    b1be:	3c ab       	sts	0x5c, r19
    b1c0:	c4 1a       	sub	r12, r20
    b1c2:	d5 0a       	sbc	r13, r21
    b1c4:	e6 0a       	sbc	r14, r22
    b1c6:	f7 0a       	sbc	r15, r23
    b1c8:	c7 01       	movw	r24, r14
    b1ca:	b6 01       	movw	r22, r12
    b1cc:	a3 01       	movw	r20, r6
    b1ce:	92 01       	movw	r18, r4
    b1d0:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b1d4:	29 a7       	lds	r18, 0x79
    b1d6:	3a a7       	lds	r19, 0x7a
    b1d8:	4b a7       	lds	r20, 0x7b
    b1da:	5c a7       	lds	r21, 0x7c
    b1dc:	21 96       	adiw	r28, 0x01	; 1
    b1de:	6c af       	sts	0x7c, r22
    b1e0:	7d af       	sts	0x7d, r23
    b1e2:	8e af       	sts	0x7e, r24
    b1e4:	9f af       	sts	0x7f, r25
    b1e6:	21 97       	sbiw	r28, 0x01	; 1
    b1e8:	c7 01       	movw	r24, r14
    b1ea:	b6 01       	movw	r22, r12
    b1ec:	a3 01       	movw	r20, r6
    b1ee:	92 01       	movw	r18, r4
    b1f0:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b1f4:	ca 01       	movw	r24, r20
    b1f6:	b9 01       	movw	r22, r18
    b1f8:	29 ad       	sts	0x69, r18
    b1fa:	3a ad       	sts	0x6a, r19
    b1fc:	4b ad       	sts	0x6b, r20
    b1fe:	5c ad       	sts	0x6c, r21
    b200:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b204:	8b 01       	movw	r16, r22
    b206:	9c 01       	movw	r18, r24
    b208:	21 96       	adiw	r28, 0x01	; 1
    b20a:	4c ad       	sts	0x6c, r20
    b20c:	5d ad       	sts	0x6d, r21
    b20e:	6e ad       	sts	0x6e, r22
    b210:	7f ad       	sts	0x6f, r23
    b212:	21 97       	sbiw	r28, 0x01	; 1
    b214:	da 01       	movw	r26, r20
    b216:	99 27       	eor	r25, r25
    b218:	88 27       	eor	r24, r24
    b21a:	4d a5       	lds	r20, 0x6d
    b21c:	5e a5       	lds	r21, 0x6e
    b21e:	6f a5       	lds	r22, 0x6f
    b220:	78 a9       	sts	0x48, r23
    b222:	60 70       	andi	r22, 0x00	; 0
    b224:	70 70       	andi	r23, 0x00	; 0
    b226:	84 2b       	or	r24, r20
    b228:	95 2b       	or	r25, r21
    b22a:	a6 2b       	or	r26, r22
    b22c:	b7 2b       	or	r27, r23
    b22e:	49 a5       	lds	r20, 0x69
    b230:	5a a5       	lds	r21, 0x6a
    b232:	6b a5       	lds	r22, 0x6b
    b234:	7c a5       	lds	r23, 0x6c
    b236:	80 17       	cp	r24, r16
    b238:	91 07       	cpc	r25, r17
    b23a:	a2 07       	cpc	r26, r18
    b23c:	b3 07       	cpc	r27, r19
    b23e:	f0 f4       	brcc	.+60     	; 0xb27c <__divdi3+0x7f8>
    b240:	41 50       	subi	r20, 0x01	; 1
    b242:	50 40       	sbci	r21, 0x00	; 0
    b244:	60 40       	sbci	r22, 0x00	; 0
    b246:	70 40       	sbci	r23, 0x00	; 0
    b248:	88 0d       	add	r24, r8
    b24a:	99 1d       	adc	r25, r9
    b24c:	aa 1d       	adc	r26, r10
    b24e:	bb 1d       	adc	r27, r11
    b250:	88 15       	cp	r24, r8
    b252:	99 05       	cpc	r25, r9
    b254:	aa 05       	cpc	r26, r10
    b256:	bb 05       	cpc	r27, r11
    b258:	88 f0       	brcs	.+34     	; 0xb27c <__divdi3+0x7f8>
    b25a:	80 17       	cp	r24, r16
    b25c:	91 07       	cpc	r25, r17
    b25e:	a2 07       	cpc	r26, r18
    b260:	b3 07       	cpc	r27, r19
    b262:	60 f4       	brcc	.+24     	; 0xb27c <__divdi3+0x7f8>
    b264:	49 a5       	lds	r20, 0x69
    b266:	5a a5       	lds	r21, 0x6a
    b268:	6b a5       	lds	r22, 0x6b
    b26a:	7c a5       	lds	r23, 0x6c
    b26c:	42 50       	subi	r20, 0x02	; 2
    b26e:	50 40       	sbci	r21, 0x00	; 0
    b270:	60 40       	sbci	r22, 0x00	; 0
    b272:	70 40       	sbci	r23, 0x00	; 0
    b274:	88 0d       	add	r24, r8
    b276:	99 1d       	adc	r25, r9
    b278:	aa 1d       	adc	r26, r10
    b27a:	bb 1d       	adc	r27, r11
    b27c:	6c 01       	movw	r12, r24
    b27e:	7d 01       	movw	r14, r26
    b280:	c0 1a       	sub	r12, r16
    b282:	d1 0a       	sbc	r13, r17
    b284:	e2 0a       	sbc	r14, r18
    b286:	f3 0a       	sbc	r15, r19
    b288:	09 a9       	sts	0x49, r16
    b28a:	1a a9       	sts	0x4a, r17
    b28c:	2b a9       	sts	0x4b, r18
    b28e:	3c a9       	sts	0x4c, r19
    b290:	38 01       	movw	r6, r16
    b292:	55 24       	eor	r5, r5
    b294:	44 24       	eor	r4, r4
    b296:	44 2a       	or	r4, r20
    b298:	55 2a       	or	r5, r21
    b29a:	66 2a       	or	r6, r22
    b29c:	77 2a       	or	r7, r23
    b29e:	85 01       	movw	r16, r10
    b2a0:	22 27       	eor	r18, r18
    b2a2:	33 27       	eor	r19, r19
    b2a4:	0d a7       	lds	r16, 0x7d
    b2a6:	1e a7       	lds	r17, 0x7e
    b2a8:	2f a7       	lds	r18, 0x7f
    b2aa:	38 ab       	sts	0x58, r19
    b2ac:	95 01       	movw	r18, r10
    b2ae:	84 01       	movw	r16, r8
    b2b0:	20 70       	andi	r18, 0x00	; 0
    b2b2:	30 70       	andi	r19, 0x00	; 0
    b2b4:	09 af       	sts	0x79, r16
    b2b6:	1a af       	sts	0x7a, r17
    b2b8:	2b af       	sts	0x7b, r18
    b2ba:	3c af       	sts	0x7c, r19
    b2bc:	c7 01       	movw	r24, r14
    b2be:	b6 01       	movw	r22, r12
    b2c0:	2d a5       	lds	r18, 0x6d
    b2c2:	3e a5       	lds	r19, 0x6e
    b2c4:	4f a5       	lds	r20, 0x6f
    b2c6:	58 a9       	sts	0x48, r21
    b2c8:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b2cc:	29 a7       	lds	r18, 0x79
    b2ce:	3a a7       	lds	r19, 0x7a
    b2d0:	4b a7       	lds	r20, 0x7b
    b2d2:	5c a7       	lds	r21, 0x7c
    b2d4:	69 ab       	sts	0x59, r22
    b2d6:	7a ab       	sts	0x5a, r23
    b2d8:	8b ab       	sts	0x5b, r24
    b2da:	9c ab       	sts	0x5c, r25
    b2dc:	c7 01       	movw	r24, r14
    b2de:	b6 01       	movw	r22, r12
    b2e0:	2d a5       	lds	r18, 0x6d
    b2e2:	3e a5       	lds	r19, 0x6e
    b2e4:	4f a5       	lds	r20, 0x6f
    b2e6:	58 a9       	sts	0x48, r21
    b2e8:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b2ec:	ca 01       	movw	r24, r20
    b2ee:	b9 01       	movw	r22, r18
    b2f0:	29 ad       	sts	0x69, r18
    b2f2:	3a ad       	sts	0x6a, r19
    b2f4:	4b ad       	sts	0x6b, r20
    b2f6:	5c ad       	sts	0x6c, r21
    b2f8:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b2fc:	ab 01       	movw	r20, r22
    b2fe:	bc 01       	movw	r22, r24
    b300:	09 a9       	sts	0x49, r16
    b302:	1a a9       	sts	0x4a, r17
    b304:	2b a9       	sts	0x4b, r18
    b306:	3c a9       	sts	0x4c, r19
    b308:	78 01       	movw	r14, r16
    b30a:	dd 24       	eor	r13, r13
    b30c:	cc 24       	eor	r12, r12
    b30e:	0d a9       	sts	0x4d, r16
    b310:	1e a9       	sts	0x4e, r17
    b312:	2f a9       	sts	0x4f, r18
    b314:	38 ad       	sts	0x68, r19
    b316:	c9 01       	movw	r24, r18
    b318:	aa 27       	eor	r26, r26
    b31a:	bb 27       	eor	r27, r27
    b31c:	c8 2a       	or	r12, r24
    b31e:	d9 2a       	or	r13, r25
    b320:	ea 2a       	or	r14, r26
    b322:	fb 2a       	or	r15, r27
    b324:	09 a5       	lds	r16, 0x69
    b326:	1a a5       	lds	r17, 0x6a
    b328:	2b a5       	lds	r18, 0x6b
    b32a:	3c a5       	lds	r19, 0x6c
    b32c:	c4 16       	cp	r12, r20
    b32e:	d5 06       	cpc	r13, r21
    b330:	e6 06       	cpc	r14, r22
    b332:	f7 06       	cpc	r15, r23
    b334:	38 f5       	brcc	.+78     	; 0xb384 <__divdi3+0x900>
    b336:	01 50       	subi	r16, 0x01	; 1
    b338:	10 40       	sbci	r17, 0x00	; 0
    b33a:	20 40       	sbci	r18, 0x00	; 0
    b33c:	30 40       	sbci	r19, 0x00	; 0
    b33e:	09 ab       	sts	0x59, r16
    b340:	1a ab       	sts	0x5a, r17
    b342:	2b ab       	sts	0x5b, r18
    b344:	3c ab       	sts	0x5c, r19
    b346:	c8 0c       	add	r12, r8
    b348:	d9 1c       	adc	r13, r9
    b34a:	ea 1c       	adc	r14, r10
    b34c:	fb 1c       	adc	r15, r11
    b34e:	c8 14       	cp	r12, r8
    b350:	d9 04       	cpc	r13, r9
    b352:	ea 04       	cpc	r14, r10
    b354:	fb 04       	cpc	r15, r11
    b356:	d0 f0       	brcs	.+52     	; 0xb38c <__divdi3+0x908>
    b358:	c4 16       	cp	r12, r20
    b35a:	d5 06       	cpc	r13, r21
    b35c:	e6 06       	cpc	r14, r22
    b35e:	f7 06       	cpc	r15, r23
    b360:	a8 f4       	brcc	.+42     	; 0xb38c <__divdi3+0x908>
    b362:	09 a5       	lds	r16, 0x69
    b364:	1a a5       	lds	r17, 0x6a
    b366:	2b a5       	lds	r18, 0x6b
    b368:	3c a5       	lds	r19, 0x6c
    b36a:	02 50       	subi	r16, 0x02	; 2
    b36c:	10 40       	sbci	r17, 0x00	; 0
    b36e:	20 40       	sbci	r18, 0x00	; 0
    b370:	30 40       	sbci	r19, 0x00	; 0
    b372:	09 ab       	sts	0x59, r16
    b374:	1a ab       	sts	0x5a, r17
    b376:	2b ab       	sts	0x5b, r18
    b378:	3c ab       	sts	0x5c, r19
    b37a:	c8 0c       	add	r12, r8
    b37c:	d9 1c       	adc	r13, r9
    b37e:	ea 1c       	adc	r14, r10
    b380:	fb 1c       	adc	r15, r11
    b382:	04 c0       	rjmp	.+8      	; 0xb38c <__divdi3+0x908>
    b384:	09 ab       	sts	0x59, r16
    b386:	1a ab       	sts	0x5a, r17
    b388:	2b ab       	sts	0x5b, r18
    b38a:	3c ab       	sts	0x5c, r19
    b38c:	c4 1a       	sub	r12, r20
    b38e:	d5 0a       	sbc	r13, r21
    b390:	e6 0a       	sbc	r14, r22
    b392:	f7 0a       	sbc	r15, r23
    b394:	c7 01       	movw	r24, r14
    b396:	b6 01       	movw	r22, r12
    b398:	2d a5       	lds	r18, 0x6d
    b39a:	3e a5       	lds	r19, 0x6e
    b39c:	4f a5       	lds	r20, 0x6f
    b39e:	58 a9       	sts	0x48, r21
    b3a0:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b3a4:	29 a7       	lds	r18, 0x79
    b3a6:	3a a7       	lds	r19, 0x7a
    b3a8:	4b a7       	lds	r20, 0x7b
    b3aa:	5c a7       	lds	r21, 0x7c
    b3ac:	21 96       	adiw	r28, 0x01	; 1
    b3ae:	6c af       	sts	0x7c, r22
    b3b0:	7d af       	sts	0x7d, r23
    b3b2:	8e af       	sts	0x7e, r24
    b3b4:	9f af       	sts	0x7f, r25
    b3b6:	21 97       	sbiw	r28, 0x01	; 1
    b3b8:	c7 01       	movw	r24, r14
    b3ba:	b6 01       	movw	r22, r12
    b3bc:	2d a5       	lds	r18, 0x6d
    b3be:	3e a5       	lds	r19, 0x6e
    b3c0:	4f a5       	lds	r20, 0x6f
    b3c2:	58 a9       	sts	0x48, r21
    b3c4:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b3c8:	ca 01       	movw	r24, r20
    b3ca:	b9 01       	movw	r22, r18
    b3cc:	29 ad       	sts	0x69, r18
    b3ce:	3a ad       	sts	0x6a, r19
    b3d0:	4b ad       	sts	0x6b, r20
    b3d2:	5c ad       	sts	0x6c, r21
    b3d4:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b3d8:	8b 01       	movw	r16, r22
    b3da:	9c 01       	movw	r18, r24
    b3dc:	21 96       	adiw	r28, 0x01	; 1
    b3de:	4c ad       	sts	0x6c, r20
    b3e0:	5d ad       	sts	0x6d, r21
    b3e2:	6e ad       	sts	0x6e, r22
    b3e4:	7f ad       	sts	0x6f, r23
    b3e6:	21 97       	sbiw	r28, 0x01	; 1
    b3e8:	da 01       	movw	r26, r20
    b3ea:	99 27       	eor	r25, r25
    b3ec:	88 27       	eor	r24, r24
    b3ee:	4d a9       	sts	0x4d, r20
    b3f0:	5e a9       	sts	0x4e, r21
    b3f2:	6f a9       	sts	0x4f, r22
    b3f4:	78 ad       	sts	0x68, r23
    b3f6:	60 70       	andi	r22, 0x00	; 0
    b3f8:	70 70       	andi	r23, 0x00	; 0
    b3fa:	84 2b       	or	r24, r20
    b3fc:	95 2b       	or	r25, r21
    b3fe:	a6 2b       	or	r26, r22
    b400:	b7 2b       	or	r27, r23
    b402:	49 a5       	lds	r20, 0x69
    b404:	5a a5       	lds	r21, 0x6a
    b406:	6b a5       	lds	r22, 0x6b
    b408:	7c a5       	lds	r23, 0x6c
    b40a:	80 17       	cp	r24, r16
    b40c:	91 07       	cpc	r25, r17
    b40e:	a2 07       	cpc	r26, r18
    b410:	b3 07       	cpc	r27, r19
    b412:	d0 f4       	brcc	.+52     	; 0xb448 <__divdi3+0x9c4>
    b414:	41 50       	subi	r20, 0x01	; 1
    b416:	50 40       	sbci	r21, 0x00	; 0
    b418:	60 40       	sbci	r22, 0x00	; 0
    b41a:	70 40       	sbci	r23, 0x00	; 0
    b41c:	88 0d       	add	r24, r8
    b41e:	99 1d       	adc	r25, r9
    b420:	aa 1d       	adc	r26, r10
    b422:	bb 1d       	adc	r27, r11
    b424:	88 15       	cp	r24, r8
    b426:	99 05       	cpc	r25, r9
    b428:	aa 05       	cpc	r26, r10
    b42a:	bb 05       	cpc	r27, r11
    b42c:	68 f0       	brcs	.+26     	; 0xb448 <__divdi3+0x9c4>
    b42e:	80 17       	cp	r24, r16
    b430:	91 07       	cpc	r25, r17
    b432:	a2 07       	cpc	r26, r18
    b434:	b3 07       	cpc	r27, r19
    b436:	40 f4       	brcc	.+16     	; 0xb448 <__divdi3+0x9c4>
    b438:	49 a5       	lds	r20, 0x69
    b43a:	5a a5       	lds	r21, 0x6a
    b43c:	6b a5       	lds	r22, 0x6b
    b43e:	7c a5       	lds	r23, 0x6c
    b440:	42 50       	subi	r20, 0x02	; 2
    b442:	50 40       	sbci	r21, 0x00	; 0
    b444:	60 40       	sbci	r22, 0x00	; 0
    b446:	70 40       	sbci	r23, 0x00	; 0
    b448:	09 a9       	sts	0x49, r16
    b44a:	1a a9       	sts	0x4a, r17
    b44c:	2b a9       	sts	0x4b, r18
    b44e:	3c a9       	sts	0x4c, r19
    b450:	78 01       	movw	r14, r16
    b452:	dd 24       	eor	r13, r13
    b454:	cc 24       	eor	r12, r12
    b456:	c4 2a       	or	r12, r20
    b458:	d5 2a       	or	r13, r21
    b45a:	e6 2a       	or	r14, r22
    b45c:	f7 2a       	or	r15, r23
    b45e:	50 c2       	rjmp	.+1184   	; 0xb900 <__divdi3+0xe7c>
    b460:	c8 16       	cp	r12, r24
    b462:	d9 06       	cpc	r13, r25
    b464:	ea 06       	cpc	r14, r26
    b466:	fb 06       	cpc	r15, r27
    b468:	08 f4       	brcc	.+2      	; 0xb46c <__divdi3+0x9e8>
    b46a:	37 c2       	rjmp	.+1134   	; 0xb8da <__divdi3+0xe56>
    b46c:	80 30       	cpi	r24, 0x00	; 0
    b46e:	10 e0       	ldi	r17, 0x00	; 0
    b470:	91 07       	cpc	r25, r17
    b472:	11 e0       	ldi	r17, 0x01	; 1
    b474:	a1 07       	cpc	r26, r17
    b476:	10 e0       	ldi	r17, 0x00	; 0
    b478:	b1 07       	cpc	r27, r17
    b47a:	50 f4       	brcc	.+20     	; 0xb490 <__divdi3+0xa0c>
    b47c:	8f 3f       	cpi	r24, 0xFF	; 255
    b47e:	91 05       	cpc	r25, r1
    b480:	a1 05       	cpc	r26, r1
    b482:	b1 05       	cpc	r27, r1
    b484:	09 f0       	breq	.+2      	; 0xb488 <__divdi3+0xa04>
    b486:	88 f4       	brcc	.+34     	; 0xb4aa <__divdi3+0xa26>
    b488:	00 e0       	ldi	r16, 0x00	; 0
    b48a:	10 e0       	ldi	r17, 0x00	; 0
    b48c:	98 01       	movw	r18, r16
    b48e:	16 c0       	rjmp	.+44     	; 0xb4bc <__divdi3+0xa38>
    b490:	80 30       	cpi	r24, 0x00	; 0
    b492:	20 e0       	ldi	r18, 0x00	; 0
    b494:	92 07       	cpc	r25, r18
    b496:	20 e0       	ldi	r18, 0x00	; 0
    b498:	a2 07       	cpc	r26, r18
    b49a:	21 e0       	ldi	r18, 0x01	; 1
    b49c:	b2 07       	cpc	r27, r18
    b49e:	50 f4       	brcc	.+20     	; 0xb4b4 <__divdi3+0xa30>
    b4a0:	00 e1       	ldi	r16, 0x10	; 16
    b4a2:	10 e0       	ldi	r17, 0x00	; 0
    b4a4:	20 e0       	ldi	r18, 0x00	; 0
    b4a6:	30 e0       	ldi	r19, 0x00	; 0
    b4a8:	09 c0       	rjmp	.+18     	; 0xb4bc <__divdi3+0xa38>
    b4aa:	08 e0       	ldi	r16, 0x08	; 8
    b4ac:	10 e0       	ldi	r17, 0x00	; 0
    b4ae:	20 e0       	ldi	r18, 0x00	; 0
    b4b0:	30 e0       	ldi	r19, 0x00	; 0
    b4b2:	04 c0       	rjmp	.+8      	; 0xb4bc <__divdi3+0xa38>
    b4b4:	08 e1       	ldi	r16, 0x18	; 24
    b4b6:	10 e0       	ldi	r17, 0x00	; 0
    b4b8:	20 e0       	ldi	r18, 0x00	; 0
    b4ba:	30 e0       	ldi	r19, 0x00	; 0
    b4bc:	ac 01       	movw	r20, r24
    b4be:	bd 01       	movw	r22, r26
    b4c0:	00 2e       	mov	r0, r16
    b4c2:	04 c0       	rjmp	.+8      	; 0xb4cc <__divdi3+0xa48>
    b4c4:	76 95       	lsr	r23
    b4c6:	67 95       	ror	r22
    b4c8:	57 95       	ror	r21
    b4ca:	47 95       	ror	r20
    b4cc:	0a 94       	dec	r0
    b4ce:	d2 f7       	brpl	.-12     	; 0xb4c4 <__divdi3+0xa40>
    b4d0:	fa 01       	movw	r30, r20
    b4d2:	e6 5c       	subi	r30, 0xC6	; 198
    b4d4:	ff 4d       	sbci	r31, 0xDF	; 223
    b4d6:	40 81       	ld	r20, Z
    b4d8:	04 0f       	add	r16, r20
    b4da:	11 1d       	adc	r17, r1
    b4dc:	21 1d       	adc	r18, r1
    b4de:	31 1d       	adc	r19, r1
    b4e0:	40 e2       	ldi	r20, 0x20	; 32
    b4e2:	50 e0       	ldi	r21, 0x00	; 0
    b4e4:	60 e0       	ldi	r22, 0x00	; 0
    b4e6:	70 e0       	ldi	r23, 0x00	; 0
    b4e8:	40 1b       	sub	r20, r16
    b4ea:	51 0b       	sbc	r21, r17
    b4ec:	62 0b       	sbc	r22, r18
    b4ee:	73 0b       	sbc	r23, r19
    b4f0:	a1 f4       	brne	.+40     	; 0xb51a <__divdi3+0xa96>
    b4f2:	8c 15       	cp	r24, r12
    b4f4:	9d 05       	cpc	r25, r13
    b4f6:	ae 05       	cpc	r26, r14
    b4f8:	bf 05       	cpc	r27, r15
    b4fa:	08 f4       	brcc	.+2      	; 0xb4fe <__divdi3+0xa7a>
    b4fc:	f5 c1       	rjmp	.+1002   	; 0xb8e8 <__divdi3+0xe64>
    b4fe:	ed a8       	sts	0x8d, r30
    b500:	fe a8       	sts	0x8e, r31
    b502:	0f a9       	sts	0x4f, r16
    b504:	18 ad       	sts	0x68, r17
    b506:	44 24       	eor	r4, r4
    b508:	55 24       	eor	r5, r5
    b50a:	32 01       	movw	r6, r4
    b50c:	e8 14       	cp	r14, r8
    b50e:	f9 04       	cpc	r15, r9
    b510:	0a 05       	cpc	r16, r10
    b512:	1b 05       	cpc	r17, r11
    b514:	08 f0       	brcs	.+2      	; 0xb518 <__divdi3+0xa94>
    b516:	eb c1       	rjmp	.+982    	; 0xb8ee <__divdi3+0xe6a>
    b518:	e3 c1       	rjmp	.+966    	; 0xb8e0 <__divdi3+0xe5c>
    b51a:	34 2e       	mov	r3, r20
    b51c:	2c 01       	movw	r4, r24
    b51e:	3d 01       	movw	r6, r26
    b520:	04 c0       	rjmp	.+8      	; 0xb52a <__divdi3+0xaa6>
    b522:	44 0c       	add	r4, r4
    b524:	55 1c       	adc	r5, r5
    b526:	66 1c       	adc	r6, r6
    b528:	77 1c       	adc	r7, r7
    b52a:	4a 95       	dec	r20
    b52c:	d2 f7       	brpl	.-12     	; 0xb522 <__divdi3+0xa9e>
    b52e:	d5 01       	movw	r26, r10
    b530:	c4 01       	movw	r24, r8
    b532:	00 2e       	mov	r0, r16
    b534:	04 c0       	rjmp	.+8      	; 0xb53e <__divdi3+0xaba>
    b536:	b6 95       	lsr	r27
    b538:	a7 95       	ror	r26
    b53a:	97 95       	ror	r25
    b53c:	87 95       	ror	r24
    b53e:	0a 94       	dec	r0
    b540:	d2 f7       	brpl	.-12     	; 0xb536 <__divdi3+0xab2>
    b542:	48 2a       	or	r4, r24
    b544:	59 2a       	or	r5, r25
    b546:	6a 2a       	or	r6, r26
    b548:	7b 2a       	or	r7, r27
    b54a:	a5 01       	movw	r20, r10
    b54c:	94 01       	movw	r18, r8
    b54e:	03 2c       	mov	r0, r3
    b550:	04 c0       	rjmp	.+8      	; 0xb55a <__divdi3+0xad6>
    b552:	22 0f       	add	r18, r18
    b554:	33 1f       	adc	r19, r19
    b556:	44 1f       	adc	r20, r20
    b558:	55 1f       	adc	r21, r21
    b55a:	0a 94       	dec	r0
    b55c:	d2 f7       	brpl	.-12     	; 0xb552 <__divdi3+0xace>
    b55e:	29 af       	sts	0x79, r18
    b560:	3a af       	sts	0x7a, r19
    b562:	4b af       	sts	0x7b, r20
    b564:	5c af       	sts	0x7c, r21
    b566:	b7 01       	movw	r22, r14
    b568:	a6 01       	movw	r20, r12
    b56a:	00 2e       	mov	r0, r16
    b56c:	04 c0       	rjmp	.+8      	; 0xb576 <__divdi3+0xaf2>
    b56e:	76 95       	lsr	r23
    b570:	67 95       	ror	r22
    b572:	57 95       	ror	r21
    b574:	47 95       	ror	r20
    b576:	0a 94       	dec	r0
    b578:	d2 f7       	brpl	.-12     	; 0xb56e <__divdi3+0xaea>
    b57a:	49 ab       	sts	0x59, r20
    b57c:	5a ab       	sts	0x5a, r21
    b57e:	6b ab       	sts	0x5b, r22
    b580:	7c ab       	sts	0x5c, r23
    b582:	c7 01       	movw	r24, r14
    b584:	b6 01       	movw	r22, r12
    b586:	03 2c       	mov	r0, r3
    b588:	04 c0       	rjmp	.+8      	; 0xb592 <__divdi3+0xb0e>
    b58a:	66 0f       	add	r22, r22
    b58c:	77 1f       	adc	r23, r23
    b58e:	88 1f       	adc	r24, r24
    b590:	99 1f       	adc	r25, r25
    b592:	0a 94       	dec	r0
    b594:	d2 f7       	brpl	.-12     	; 0xb58a <__divdi3+0xb06>
    b596:	6d a7       	lds	r22, 0x7d
    b598:	7e a7       	lds	r23, 0x7e
    b59a:	8f a7       	lds	r24, 0x7f
    b59c:	98 ab       	sts	0x58, r25
    b59e:	8d a9       	sts	0x4d, r24
    b5a0:	9e a9       	sts	0x4e, r25
    b5a2:	af a9       	sts	0x4f, r26
    b5a4:	b8 ad       	sts	0x68, r27
    b5a6:	04 c0       	rjmp	.+8      	; 0xb5b0 <__divdi3+0xb2c>
    b5a8:	b6 95       	lsr	r27
    b5aa:	a7 95       	ror	r26
    b5ac:	97 95       	ror	r25
    b5ae:	87 95       	ror	r24
    b5b0:	0a 95       	dec	r16
    b5b2:	d2 f7       	brpl	.-12     	; 0xb5a8 <__divdi3+0xb24>
    b5b4:	4d a5       	lds	r20, 0x6d
    b5b6:	5e a5       	lds	r21, 0x6e
    b5b8:	6f a5       	lds	r22, 0x6f
    b5ba:	78 a9       	sts	0x48, r23
    b5bc:	48 2b       	or	r20, r24
    b5be:	59 2b       	or	r21, r25
    b5c0:	6a 2b       	or	r22, r26
    b5c2:	7b 2b       	or	r23, r27
    b5c4:	4d a7       	lds	r20, 0x7d
    b5c6:	5e a7       	lds	r21, 0x7e
    b5c8:	6f a7       	lds	r22, 0x7f
    b5ca:	78 ab       	sts	0x58, r23
    b5cc:	43 01       	movw	r8, r6
    b5ce:	aa 24       	eor	r10, r10
    b5d0:	bb 24       	eor	r11, r11
    b5d2:	93 01       	movw	r18, r6
    b5d4:	82 01       	movw	r16, r4
    b5d6:	20 70       	andi	r18, 0x00	; 0
    b5d8:	30 70       	andi	r19, 0x00	; 0
    b5da:	21 96       	adiw	r28, 0x01	; 1
    b5dc:	0c af       	sts	0x7c, r16
    b5de:	1d af       	sts	0x7d, r17
    b5e0:	2e af       	sts	0x7e, r18
    b5e2:	3f af       	sts	0x7f, r19
    b5e4:	21 97       	sbiw	r28, 0x01	; 1
    b5e6:	69 a9       	sts	0x49, r22
    b5e8:	7a a9       	sts	0x4a, r23
    b5ea:	8b a9       	sts	0x4b, r24
    b5ec:	9c a9       	sts	0x4c, r25
    b5ee:	a5 01       	movw	r20, r10
    b5f0:	94 01       	movw	r18, r8
    b5f2:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b5f6:	29 a7       	lds	r18, 0x79
    b5f8:	3a a7       	lds	r19, 0x7a
    b5fa:	4b a7       	lds	r20, 0x7b
    b5fc:	5c a7       	lds	r21, 0x7c
    b5fe:	6b 01       	movw	r12, r22
    b600:	7c 01       	movw	r14, r24
    b602:	69 a9       	sts	0x49, r22
    b604:	7a a9       	sts	0x4a, r23
    b606:	8b a9       	sts	0x4b, r24
    b608:	9c a9       	sts	0x4c, r25
    b60a:	a5 01       	movw	r20, r10
    b60c:	94 01       	movw	r18, r8
    b60e:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b612:	ca 01       	movw	r24, r20
    b614:	b9 01       	movw	r22, r18
    b616:	21 96       	adiw	r28, 0x01	; 1
    b618:	2c ad       	sts	0x6c, r18
    b61a:	3d ad       	sts	0x6d, r19
    b61c:	4e ad       	sts	0x6e, r20
    b61e:	5f ad       	sts	0x6f, r21
    b620:	21 97       	sbiw	r28, 0x01	; 1
    b622:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b626:	dc 01       	movw	r26, r24
    b628:	cb 01       	movw	r24, r22
    b62a:	76 01       	movw	r14, r12
    b62c:	dd 24       	eor	r13, r13
    b62e:	cc 24       	eor	r12, r12
    b630:	0d a5       	lds	r16, 0x6d
    b632:	1e a5       	lds	r17, 0x6e
    b634:	2f a5       	lds	r18, 0x6f
    b636:	38 a9       	sts	0x48, r19
    b638:	a9 01       	movw	r20, r18
    b63a:	66 27       	eor	r22, r22
    b63c:	77 27       	eor	r23, r23
    b63e:	c4 2a       	or	r12, r20
    b640:	d5 2a       	or	r13, r21
    b642:	e6 2a       	or	r14, r22
    b644:	f7 2a       	or	r15, r23
    b646:	09 a5       	lds	r16, 0x69
    b648:	1a a5       	lds	r17, 0x6a
    b64a:	2b a5       	lds	r18, 0x6b
    b64c:	3c a5       	lds	r19, 0x6c
    b64e:	c8 16       	cp	r12, r24
    b650:	d9 06       	cpc	r13, r25
    b652:	ea 06       	cpc	r14, r26
    b654:	fb 06       	cpc	r15, r27
    b656:	38 f5       	brcc	.+78     	; 0xb6a6 <__divdi3+0xc22>
    b658:	01 50       	subi	r16, 0x01	; 1
    b65a:	10 40       	sbci	r17, 0x00	; 0
    b65c:	20 40       	sbci	r18, 0x00	; 0
    b65e:	30 40       	sbci	r19, 0x00	; 0
    b660:	09 ab       	sts	0x59, r16
    b662:	1a ab       	sts	0x5a, r17
    b664:	2b ab       	sts	0x5b, r18
    b666:	3c ab       	sts	0x5c, r19
    b668:	c4 0c       	add	r12, r4
    b66a:	d5 1c       	adc	r13, r5
    b66c:	e6 1c       	adc	r14, r6
    b66e:	f7 1c       	adc	r15, r7
    b670:	c4 14       	cp	r12, r4
    b672:	d5 04       	cpc	r13, r5
    b674:	e6 04       	cpc	r14, r6
    b676:	f7 04       	cpc	r15, r7
    b678:	d0 f0       	brcs	.+52     	; 0xb6ae <__divdi3+0xc2a>
    b67a:	c8 16       	cp	r12, r24
    b67c:	d9 06       	cpc	r13, r25
    b67e:	ea 06       	cpc	r14, r26
    b680:	fb 06       	cpc	r15, r27
    b682:	a8 f4       	brcc	.+42     	; 0xb6ae <__divdi3+0xc2a>
    b684:	09 a5       	lds	r16, 0x69
    b686:	1a a5       	lds	r17, 0x6a
    b688:	2b a5       	lds	r18, 0x6b
    b68a:	3c a5       	lds	r19, 0x6c
    b68c:	02 50       	subi	r16, 0x02	; 2
    b68e:	10 40       	sbci	r17, 0x00	; 0
    b690:	20 40       	sbci	r18, 0x00	; 0
    b692:	30 40       	sbci	r19, 0x00	; 0
    b694:	09 ab       	sts	0x59, r16
    b696:	1a ab       	sts	0x5a, r17
    b698:	2b ab       	sts	0x5b, r18
    b69a:	3c ab       	sts	0x5c, r19
    b69c:	c4 0c       	add	r12, r4
    b69e:	d5 1c       	adc	r13, r5
    b6a0:	e6 1c       	adc	r14, r6
    b6a2:	f7 1c       	adc	r15, r7
    b6a4:	04 c0       	rjmp	.+8      	; 0xb6ae <__divdi3+0xc2a>
    b6a6:	09 ab       	sts	0x59, r16
    b6a8:	1a ab       	sts	0x5a, r17
    b6aa:	2b ab       	sts	0x5b, r18
    b6ac:	3c ab       	sts	0x5c, r19
    b6ae:	c8 1a       	sub	r12, r24
    b6b0:	d9 0a       	sbc	r13, r25
    b6b2:	ea 0a       	sbc	r14, r26
    b6b4:	fb 0a       	sbc	r15, r27
    b6b6:	c7 01       	movw	r24, r14
    b6b8:	b6 01       	movw	r22, r12
    b6ba:	a5 01       	movw	r20, r10
    b6bc:	94 01       	movw	r18, r8
    b6be:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b6c2:	29 a7       	lds	r18, 0x79
    b6c4:	3a a7       	lds	r19, 0x7a
    b6c6:	4b a7       	lds	r20, 0x7b
    b6c8:	5c a7       	lds	r21, 0x7c
    b6ca:	29 96       	adiw	r28, 0x09	; 9
    b6cc:	6c af       	sts	0x7c, r22
    b6ce:	7d af       	sts	0x7d, r23
    b6d0:	8e af       	sts	0x7e, r24
    b6d2:	9f af       	sts	0x7f, r25
    b6d4:	29 97       	sbiw	r28, 0x09	; 9
    b6d6:	c7 01       	movw	r24, r14
    b6d8:	b6 01       	movw	r22, r12
    b6da:	a5 01       	movw	r20, r10
    b6dc:	94 01       	movw	r18, r8
    b6de:	0e 94 b8 5e 	call	0xbd70	; 0xbd70 <__udivmodsi4>
    b6e2:	ca 01       	movw	r24, r20
    b6e4:	b9 01       	movw	r22, r18
    b6e6:	21 96       	adiw	r28, 0x01	; 1
    b6e8:	2c ad       	sts	0x6c, r18
    b6ea:	3d ad       	sts	0x6d, r19
    b6ec:	4e ad       	sts	0x6e, r20
    b6ee:	5f ad       	sts	0x6f, r21
    b6f0:	21 97       	sbiw	r28, 0x01	; 1
    b6f2:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b6f6:	4b 01       	movw	r8, r22
    b6f8:	5c 01       	movw	r10, r24
    b6fa:	29 96       	adiw	r28, 0x09	; 9
    b6fc:	4c ad       	sts	0x6c, r20
    b6fe:	5d ad       	sts	0x6d, r21
    b700:	6e ad       	sts	0x6e, r22
    b702:	7f ad       	sts	0x6f, r23
    b704:	29 97       	sbiw	r28, 0x09	; 9
    b706:	9a 01       	movw	r18, r20
    b708:	11 27       	eor	r17, r17
    b70a:	00 27       	eor	r16, r16
    b70c:	8d a5       	lds	r24, 0x6d
    b70e:	9e a5       	lds	r25, 0x6e
    b710:	af a5       	lds	r26, 0x6f
    b712:	b8 a9       	sts	0x48, r27
    b714:	a0 70       	andi	r26, 0x00	; 0
    b716:	b0 70       	andi	r27, 0x00	; 0
    b718:	08 2b       	or	r16, r24
    b71a:	19 2b       	or	r17, r25
    b71c:	2a 2b       	or	r18, r26
    b71e:	3b 2b       	or	r19, r27
    b720:	89 a5       	lds	r24, 0x69
    b722:	9a a5       	lds	r25, 0x6a
    b724:	ab a5       	lds	r26, 0x6b
    b726:	bc a5       	lds	r27, 0x6c
    b728:	08 15       	cp	r16, r8
    b72a:	19 05       	cpc	r17, r9
    b72c:	2a 05       	cpc	r18, r10
    b72e:	3b 05       	cpc	r19, r11
    b730:	e0 f4       	brcc	.+56     	; 0xb76a <__divdi3+0xce6>
    b732:	01 97       	sbiw	r24, 0x01	; 1
    b734:	a1 09       	sbc	r26, r1
    b736:	b1 09       	sbc	r27, r1
    b738:	04 0d       	add	r16, r4
    b73a:	15 1d       	adc	r17, r5
    b73c:	26 1d       	adc	r18, r6
    b73e:	37 1d       	adc	r19, r7
    b740:	04 15       	cp	r16, r4
    b742:	15 05       	cpc	r17, r5
    b744:	26 05       	cpc	r18, r6
    b746:	37 05       	cpc	r19, r7
    b748:	80 f0       	brcs	.+32     	; 0xb76a <__divdi3+0xce6>
    b74a:	08 15       	cp	r16, r8
    b74c:	19 05       	cpc	r17, r9
    b74e:	2a 05       	cpc	r18, r10
    b750:	3b 05       	cpc	r19, r11
    b752:	58 f4       	brcc	.+22     	; 0xb76a <__divdi3+0xce6>
    b754:	89 a5       	lds	r24, 0x69
    b756:	9a a5       	lds	r25, 0x6a
    b758:	ab a5       	lds	r26, 0x6b
    b75a:	bc a5       	lds	r27, 0x6c
    b75c:	02 97       	sbiw	r24, 0x02	; 2
    b75e:	a1 09       	sbc	r26, r1
    b760:	b1 09       	sbc	r27, r1
    b762:	04 0d       	add	r16, r4
    b764:	15 1d       	adc	r17, r5
    b766:	26 1d       	adc	r18, r6
    b768:	37 1d       	adc	r19, r7
    b76a:	b9 01       	movw	r22, r18
    b76c:	a8 01       	movw	r20, r16
    b76e:	48 19       	sub	r20, r8
    b770:	59 09       	sbc	r21, r9
    b772:	6a 09       	sbc	r22, r10
    b774:	7b 09       	sbc	r23, r11
    b776:	4d a7       	lds	r20, 0x7d
    b778:	5e a7       	lds	r21, 0x7e
    b77a:	6f a7       	lds	r22, 0x7f
    b77c:	78 ab       	sts	0x58, r23
    b77e:	09 a9       	sts	0x49, r16
    b780:	1a a9       	sts	0x4a, r17
    b782:	2b a9       	sts	0x4b, r18
    b784:	3c a9       	sts	0x4c, r19
    b786:	78 01       	movw	r14, r16
    b788:	dd 24       	eor	r13, r13
    b78a:	cc 24       	eor	r12, r12
    b78c:	c8 2a       	or	r12, r24
    b78e:	d9 2a       	or	r13, r25
    b790:	ea 2a       	or	r14, r26
    b792:	fb 2a       	or	r15, r27
    b794:	ff ef       	ldi	r31, 0xFF	; 255
    b796:	8f 2e       	mov	r8, r31
    b798:	ff ef       	ldi	r31, 0xFF	; 255
    b79a:	9f 2e       	mov	r9, r31
    b79c:	a1 2c       	mov	r10, r1
    b79e:	b1 2c       	mov	r11, r1
    b7a0:	8c 20       	and	r8, r12
    b7a2:	9d 20       	and	r9, r13
    b7a4:	ae 20       	and	r10, r14
    b7a6:	bf 20       	and	r11, r15
    b7a8:	87 01       	movw	r16, r14
    b7aa:	22 27       	eor	r18, r18
    b7ac:	33 27       	eor	r19, r19
    b7ae:	09 a7       	lds	r16, 0x79
    b7b0:	1a a7       	lds	r17, 0x7a
    b7b2:	2b a7       	lds	r18, 0x7b
    b7b4:	3c a7       	lds	r19, 0x7c
    b7b6:	49 ac       	sts	0xa9, r20
    b7b8:	5a ac       	sts	0xaa, r21
    b7ba:	6b ac       	sts	0xab, r22
    b7bc:	7c ac       	sts	0xac, r23
    b7be:	2f ef       	ldi	r18, 0xFF	; 255
    b7c0:	3f ef       	ldi	r19, 0xFF	; 255
    b7c2:	40 e0       	ldi	r20, 0x00	; 0
    b7c4:	50 e0       	ldi	r21, 0x00	; 0
    b7c6:	42 22       	and	r4, r18
    b7c8:	53 22       	and	r5, r19
    b7ca:	64 22       	and	r6, r20
    b7cc:	75 22       	and	r7, r21
    b7ce:	29 ad       	sts	0x69, r18
    b7d0:	3a ad       	sts	0x6a, r19
    b7d2:	4b ad       	sts	0x6b, r20
    b7d4:	5c ad       	sts	0x6c, r21
    b7d6:	8a 01       	movw	r16, r20
    b7d8:	22 27       	eor	r18, r18
    b7da:	33 27       	eor	r19, r19
    b7dc:	09 ab       	sts	0x59, r16
    b7de:	1a ab       	sts	0x5a, r17
    b7e0:	2b ab       	sts	0x5b, r18
    b7e2:	3c ab       	sts	0x5c, r19
    b7e4:	c5 01       	movw	r24, r10
    b7e6:	b4 01       	movw	r22, r8
    b7e8:	a3 01       	movw	r20, r6
    b7ea:	92 01       	movw	r18, r4
    b7ec:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b7f0:	69 af       	sts	0x79, r22
    b7f2:	7a af       	sts	0x7a, r23
    b7f4:	8b af       	sts	0x7b, r24
    b7f6:	9c af       	sts	0x7c, r25
    b7f8:	c5 01       	movw	r24, r10
    b7fa:	b4 01       	movw	r22, r8
    b7fc:	29 a9       	sts	0x49, r18
    b7fe:	3a a9       	sts	0x4a, r19
    b800:	4b a9       	sts	0x4b, r20
    b802:	5c a9       	sts	0x4c, r21
    b804:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b808:	4b 01       	movw	r8, r22
    b80a:	5c 01       	movw	r10, r24
    b80c:	69 a5       	lds	r22, 0x69
    b80e:	7a a5       	lds	r23, 0x6a
    b810:	8b a5       	lds	r24, 0x6b
    b812:	9c a5       	lds	r25, 0x6c
    b814:	a3 01       	movw	r20, r6
    b816:	92 01       	movw	r18, r4
    b818:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b81c:	2b 01       	movw	r4, r22
    b81e:	3c 01       	movw	r6, r24
    b820:	69 a5       	lds	r22, 0x69
    b822:	7a a5       	lds	r23, 0x6a
    b824:	8b a5       	lds	r24, 0x6b
    b826:	9c a5       	lds	r25, 0x6c
    b828:	29 a9       	sts	0x49, r18
    b82a:	3a a9       	sts	0x4a, r19
    b82c:	4b a9       	sts	0x4b, r20
    b82e:	5c a9       	sts	0x4c, r21
    b830:	0e 94 72 5e 	call	0xbce4	; 0xbce4 <__mulsi3>
    b834:	ab 01       	movw	r20, r22
    b836:	bc 01       	movw	r22, r24
    b838:	84 0c       	add	r8, r4
    b83a:	95 1c       	adc	r9, r5
    b83c:	a6 1c       	adc	r10, r6
    b83e:	b7 1c       	adc	r11, r7
    b840:	09 ad       	sts	0x69, r16
    b842:	1a ad       	sts	0x6a, r17
    b844:	2b ad       	sts	0x6b, r18
    b846:	3c ad       	sts	0x6c, r19
    b848:	c9 01       	movw	r24, r18
    b84a:	aa 27       	eor	r26, r26
    b84c:	bb 27       	eor	r27, r27
    b84e:	88 0e       	add	r8, r24
    b850:	99 1e       	adc	r9, r25
    b852:	aa 1e       	adc	r10, r26
    b854:	bb 1e       	adc	r11, r27
    b856:	84 14       	cp	r8, r4
    b858:	95 04       	cpc	r9, r5
    b85a:	a6 04       	cpc	r10, r6
    b85c:	b7 04       	cpc	r11, r7
    b85e:	20 f4       	brcc	.+8      	; 0xb868 <__divdi3+0xde4>
    b860:	40 50       	subi	r20, 0x00	; 0
    b862:	50 40       	sbci	r21, 0x00	; 0
    b864:	6f 4f       	sbci	r22, 0xFF	; 255
    b866:	7f 4f       	sbci	r23, 0xFF	; 255
    b868:	c5 01       	movw	r24, r10
    b86a:	aa 27       	eor	r26, r26
    b86c:	bb 27       	eor	r27, r27
    b86e:	84 0f       	add	r24, r20
    b870:	95 1f       	adc	r25, r21
    b872:	a6 1f       	adc	r26, r22
    b874:	b7 1f       	adc	r27, r23
    b876:	0d a5       	lds	r16, 0x6d
    b878:	1e a5       	lds	r17, 0x6e
    b87a:	2f a5       	lds	r18, 0x6f
    b87c:	38 a9       	sts	0x48, r19
    b87e:	08 17       	cp	r16, r24
    b880:	19 07       	cpc	r17, r25
    b882:	2a 07       	cpc	r18, r26
    b884:	3b 07       	cpc	r19, r27
    b886:	18 f1       	brcs	.+70     	; 0xb8ce <__divdi3+0xe4a>
    b888:	80 17       	cp	r24, r16
    b88a:	91 07       	cpc	r25, r17
    b88c:	a2 07       	cpc	r26, r18
    b88e:	b3 07       	cpc	r27, r19
    b890:	a1 f5       	brne	.+104    	; 0xb8fa <__divdi3+0xe76>
    b892:	54 01       	movw	r10, r8
    b894:	99 24       	eor	r9, r9
    b896:	88 24       	eor	r8, r8
    b898:	89 ad       	sts	0x69, r24
    b89a:	9a ad       	sts	0x6a, r25
    b89c:	ab ad       	sts	0x6b, r26
    b89e:	bc ad       	sts	0x6c, r27
    b8a0:	a0 70       	andi	r26, 0x00	; 0
    b8a2:	b0 70       	andi	r27, 0x00	; 0
    b8a4:	88 0e       	add	r8, r24
    b8a6:	99 1e       	adc	r9, r25
    b8a8:	aa 1e       	adc	r10, r26
    b8aa:	bb 1e       	adc	r11, r27
    b8ac:	4d a9       	sts	0x4d, r20
    b8ae:	5e a9       	sts	0x4e, r21
    b8b0:	6f a9       	sts	0x4f, r22
    b8b2:	78 ad       	sts	0x68, r23
    b8b4:	03 2c       	mov	r0, r3
    b8b6:	04 c0       	rjmp	.+8      	; 0xb8c0 <__divdi3+0xe3c>
    b8b8:	44 0f       	add	r20, r20
    b8ba:	55 1f       	adc	r21, r21
    b8bc:	66 1f       	adc	r22, r22
    b8be:	77 1f       	adc	r23, r23
    b8c0:	0a 94       	dec	r0
    b8c2:	d2 f7       	brpl	.-12     	; 0xb8b8 <__divdi3+0xe34>
    b8c4:	48 15       	cp	r20, r8
    b8c6:	59 05       	cpc	r21, r9
    b8c8:	6a 05       	cpc	r22, r10
    b8ca:	7b 05       	cpc	r23, r11
    b8cc:	b0 f4       	brcc	.+44     	; 0xb8fa <__divdi3+0xe76>
    b8ce:	08 94       	sec
    b8d0:	c1 08       	sbc	r12, r1
    b8d2:	d1 08       	sbc	r13, r1
    b8d4:	e1 08       	sbc	r14, r1
    b8d6:	f1 08       	sbc	r15, r1
    b8d8:	10 c0       	rjmp	.+32     	; 0xb8fa <__divdi3+0xe76>
    b8da:	44 24       	eor	r4, r4
    b8dc:	55 24       	eor	r5, r5
    b8de:	32 01       	movw	r6, r4
    b8e0:	cc 24       	eor	r12, r12
    b8e2:	dd 24       	eor	r13, r13
    b8e4:	76 01       	movw	r14, r12
    b8e6:	0c c0       	rjmp	.+24     	; 0xb900 <__divdi3+0xe7c>
    b8e8:	44 24       	eor	r4, r4
    b8ea:	55 24       	eor	r5, r5
    b8ec:	32 01       	movw	r6, r4
    b8ee:	81 e0       	ldi	r24, 0x01	; 1
    b8f0:	c8 2e       	mov	r12, r24
    b8f2:	d1 2c       	mov	r13, r1
    b8f4:	e1 2c       	mov	r14, r1
    b8f6:	f1 2c       	mov	r15, r1
    b8f8:	03 c0       	rjmp	.+6      	; 0xb900 <__divdi3+0xe7c>
    b8fa:	44 24       	eor	r4, r4
    b8fc:	55 24       	eor	r5, r5
    b8fe:	32 01       	movw	r6, r4
    b900:	fe 01       	movw	r30, r28
    b902:	31 96       	adiw	r30, 0x01	; 1
    b904:	88 e0       	ldi	r24, 0x08	; 8
    b906:	df 01       	movw	r26, r30
    b908:	1d 92       	st	X+, r1
    b90a:	8a 95       	dec	r24
    b90c:	e9 f7       	brne	.-6      	; 0xb908 <__divdi3+0xe84>
    b90e:	c9 82       	std	Y+1, r12	; 0x01
    b910:	da 82       	std	Y+2, r13	; 0x02
    b912:	eb 82       	std	Y+3, r14	; 0x03
    b914:	fc 82       	std	Y+4, r15	; 0x04
    b916:	4d 82       	std	Y+5, r4	; 0x05
    b918:	5e 82       	std	Y+6, r5	; 0x06
    b91a:	6f 82       	std	Y+7, r6	; 0x07
    b91c:	78 86       	std	Y+8, r7	; 0x08
    b91e:	2c 2d       	mov	r18, r12
    b920:	3a 81       	ldd	r19, Y+2	; 0x02
    b922:	4b 81       	ldd	r20, Y+3	; 0x03
    b924:	5c 81       	ldd	r21, Y+4	; 0x04
    b926:	64 2d       	mov	r22, r4
    b928:	7e 81       	ldd	r23, Y+6	; 0x06
    b92a:	8f 81       	ldd	r24, Y+7	; 0x07
    b92c:	98 85       	ldd	r25, Y+8	; 0x08
    b92e:	25 96       	adiw	r28, 0x05	; 5
    b930:	ec ac       	sts	0xac, r30
    b932:	fd ac       	sts	0xad, r31
    b934:	0e ad       	sts	0x6e, r16
    b936:	1f ad       	sts	0x6f, r17
    b938:	25 97       	sbiw	r28, 0x05	; 5
    b93a:	e1 14       	cp	r14, r1
    b93c:	f1 04       	cpc	r15, r1
    b93e:	01 05       	cpc	r16, r1
    b940:	11 05       	cpc	r17, r1
    b942:	09 f4       	brne	.+2      	; 0xb946 <__divdi3+0xec2>
    b944:	56 c0       	rjmp	.+172    	; 0xb9f2 <__divdi3+0xf6e>
    b946:	21 95       	neg	r18
    b948:	e1 e0       	ldi	r30, 0x01	; 1
    b94a:	12 16       	cp	r1, r18
    b94c:	08 f0       	brcs	.+2      	; 0xb950 <__divdi3+0xecc>
    b94e:	e0 e0       	ldi	r30, 0x00	; 0
    b950:	31 95       	neg	r19
    b952:	f1 e0       	ldi	r31, 0x01	; 1
    b954:	13 16       	cp	r1, r19
    b956:	08 f0       	brcs	.+2      	; 0xb95a <__divdi3+0xed6>
    b958:	f0 e0       	ldi	r31, 0x00	; 0
    b95a:	03 2f       	mov	r16, r19
    b95c:	0e 1b       	sub	r16, r30
    b95e:	e1 e0       	ldi	r30, 0x01	; 1
    b960:	30 17       	cp	r19, r16
    b962:	08 f0       	brcs	.+2      	; 0xb966 <__divdi3+0xee2>
    b964:	e0 e0       	ldi	r30, 0x00	; 0
    b966:	fe 2b       	or	r31, r30
    b968:	41 95       	neg	r20
    b96a:	e1 e0       	ldi	r30, 0x01	; 1
    b96c:	14 16       	cp	r1, r20
    b96e:	08 f0       	brcs	.+2      	; 0xb972 <__divdi3+0xeee>
    b970:	e0 e0       	ldi	r30, 0x00	; 0
    b972:	14 2f       	mov	r17, r20
    b974:	1f 1b       	sub	r17, r31
    b976:	31 e0       	ldi	r19, 0x01	; 1
    b978:	41 17       	cp	r20, r17
    b97a:	08 f0       	brcs	.+2      	; 0xb97e <__divdi3+0xefa>
    b97c:	30 e0       	ldi	r19, 0x00	; 0
    b97e:	e3 2b       	or	r30, r19
    b980:	51 95       	neg	r21
    b982:	f1 e0       	ldi	r31, 0x01	; 1
    b984:	15 16       	cp	r1, r21
    b986:	08 f0       	brcs	.+2      	; 0xb98a <__divdi3+0xf06>
    b988:	f0 e0       	ldi	r31, 0x00	; 0
    b98a:	b5 2f       	mov	r27, r21
    b98c:	be 1b       	sub	r27, r30
    b98e:	31 e0       	ldi	r19, 0x01	; 1
    b990:	5b 17       	cp	r21, r27
    b992:	08 f0       	brcs	.+2      	; 0xb996 <__divdi3+0xf12>
    b994:	30 e0       	ldi	r19, 0x00	; 0
    b996:	f3 2b       	or	r31, r19
    b998:	61 95       	neg	r22
    b99a:	e1 e0       	ldi	r30, 0x01	; 1
    b99c:	16 16       	cp	r1, r22
    b99e:	08 f0       	brcs	.+2      	; 0xb9a2 <__divdi3+0xf1e>
    b9a0:	e0 e0       	ldi	r30, 0x00	; 0
    b9a2:	46 2e       	mov	r4, r22
    b9a4:	4f 1a       	sub	r4, r31
    b9a6:	31 e0       	ldi	r19, 0x01	; 1
    b9a8:	64 15       	cp	r22, r4
    b9aa:	08 f0       	brcs	.+2      	; 0xb9ae <__divdi3+0xf2a>
    b9ac:	30 e0       	ldi	r19, 0x00	; 0
    b9ae:	e3 2b       	or	r30, r19
    b9b0:	71 95       	neg	r23
    b9b2:	f1 e0       	ldi	r31, 0x01	; 1
    b9b4:	17 16       	cp	r1, r23
    b9b6:	08 f0       	brcs	.+2      	; 0xb9ba <__divdi3+0xf36>
    b9b8:	f0 e0       	ldi	r31, 0x00	; 0
    b9ba:	a7 2f       	mov	r26, r23
    b9bc:	ae 1b       	sub	r26, r30
    b9be:	31 e0       	ldi	r19, 0x01	; 1
    b9c0:	7a 17       	cp	r23, r26
    b9c2:	08 f0       	brcs	.+2      	; 0xb9c6 <__divdi3+0xf42>
    b9c4:	30 e0       	ldi	r19, 0x00	; 0
    b9c6:	f3 2b       	or	r31, r19
    b9c8:	81 95       	neg	r24
    b9ca:	e1 e0       	ldi	r30, 0x01	; 1
    b9cc:	18 16       	cp	r1, r24
    b9ce:	08 f0       	brcs	.+2      	; 0xb9d2 <__divdi3+0xf4e>
    b9d0:	e0 e0       	ldi	r30, 0x00	; 0
    b9d2:	f8 2e       	mov	r15, r24
    b9d4:	ff 1a       	sub	r15, r31
    b9d6:	ff 2d       	mov	r31, r15
    b9d8:	31 e0       	ldi	r19, 0x01	; 1
    b9da:	8f 15       	cp	r24, r15
    b9dc:	08 f0       	brcs	.+2      	; 0xb9e0 <__divdi3+0xf5c>
    b9de:	30 e0       	ldi	r19, 0x00	; 0
    b9e0:	e3 2b       	or	r30, r19
    b9e2:	91 95       	neg	r25
    b9e4:	30 2f       	mov	r19, r16
    b9e6:	41 2f       	mov	r20, r17
    b9e8:	5b 2f       	mov	r21, r27
    b9ea:	64 2d       	mov	r22, r4
    b9ec:	7a 2f       	mov	r23, r26
    b9ee:	8f 2f       	mov	r24, r31
    b9f0:	9e 1b       	sub	r25, r30
    b9f2:	c8 5b       	subi	r28, 0xB8	; 184
    b9f4:	df 4f       	sbci	r29, 0xFF	; 255
    b9f6:	e1 e1       	ldi	r30, 0x11	; 17
    b9f8:	0c 94 0f 5f 	jmp	0xbe1e	; 0xbe1e <__epilogue_restores__+0x2>

0000b9fc <__cmpsf2>:
    b9fc:	97 d0       	rcall	.+302    	; 0xbb2c <__fp_cmp>
    b9fe:	08 f4       	brcc	.+2      	; 0xba02 <__cmpsf2+0x6>
    ba00:	81 e0       	ldi	r24, 0x01	; 1
    ba02:	08 95       	ret

0000ba04 <__divsf3>:
    ba04:	0c d0       	rcall	.+24     	; 0xba1e <__divsf3x>
    ba06:	cd c0       	rjmp	.+410    	; 0xbba2 <__fp_round>
    ba08:	c5 d0       	rcall	.+394    	; 0xbb94 <__fp_pscB>
    ba0a:	40 f0       	brcs	.+16     	; 0xba1c <__divsf3+0x18>
    ba0c:	bc d0       	rcall	.+376    	; 0xbb86 <__fp_pscA>
    ba0e:	30 f0       	brcs	.+12     	; 0xba1c <__divsf3+0x18>
    ba10:	21 f4       	brne	.+8      	; 0xba1a <__divsf3+0x16>
    ba12:	5f 3f       	cpi	r21, 0xFF	; 255
    ba14:	19 f0       	breq	.+6      	; 0xba1c <__divsf3+0x18>
    ba16:	ae c0       	rjmp	.+348    	; 0xbb74 <__fp_inf>
    ba18:	51 11       	cpse	r21, r1
    ba1a:	f7 c0       	rjmp	.+494    	; 0xbc0a <__fp_szero>
    ba1c:	b1 c0       	rjmp	.+354    	; 0xbb80 <__fp_nan>

0000ba1e <__divsf3x>:
    ba1e:	d2 d0       	rcall	.+420    	; 0xbbc4 <__fp_split3>
    ba20:	98 f3       	brcs	.-26     	; 0xba08 <__divsf3+0x4>

0000ba22 <__divsf3_pse>:
    ba22:	99 23       	and	r25, r25
    ba24:	c9 f3       	breq	.-14     	; 0xba18 <__divsf3+0x14>
    ba26:	55 23       	and	r21, r21
    ba28:	b1 f3       	breq	.-20     	; 0xba16 <__divsf3+0x12>
    ba2a:	95 1b       	sub	r25, r21
    ba2c:	55 0b       	sbc	r21, r21
    ba2e:	bb 27       	eor	r27, r27
    ba30:	aa 27       	eor	r26, r26
    ba32:	62 17       	cp	r22, r18
    ba34:	73 07       	cpc	r23, r19
    ba36:	84 07       	cpc	r24, r20
    ba38:	38 f0       	brcs	.+14     	; 0xba48 <__divsf3_pse+0x26>
    ba3a:	9f 5f       	subi	r25, 0xFF	; 255
    ba3c:	5f 4f       	sbci	r21, 0xFF	; 255
    ba3e:	22 0f       	add	r18, r18
    ba40:	33 1f       	adc	r19, r19
    ba42:	44 1f       	adc	r20, r20
    ba44:	aa 1f       	adc	r26, r26
    ba46:	a9 f3       	breq	.-22     	; 0xba32 <__divsf3_pse+0x10>
    ba48:	33 d0       	rcall	.+102    	; 0xbab0 <__divsf3_pse+0x8e>
    ba4a:	0e 2e       	mov	r0, r30
    ba4c:	3a f0       	brmi	.+14     	; 0xba5c <__divsf3_pse+0x3a>
    ba4e:	e0 e8       	ldi	r30, 0x80	; 128
    ba50:	30 d0       	rcall	.+96     	; 0xbab2 <__divsf3_pse+0x90>
    ba52:	91 50       	subi	r25, 0x01	; 1
    ba54:	50 40       	sbci	r21, 0x00	; 0
    ba56:	e6 95       	lsr	r30
    ba58:	00 1c       	adc	r0, r0
    ba5a:	ca f7       	brpl	.-14     	; 0xba4e <__divsf3_pse+0x2c>
    ba5c:	29 d0       	rcall	.+82     	; 0xbab0 <__divsf3_pse+0x8e>
    ba5e:	fe 2f       	mov	r31, r30
    ba60:	27 d0       	rcall	.+78     	; 0xbab0 <__divsf3_pse+0x8e>
    ba62:	66 0f       	add	r22, r22
    ba64:	77 1f       	adc	r23, r23
    ba66:	88 1f       	adc	r24, r24
    ba68:	bb 1f       	adc	r27, r27
    ba6a:	26 17       	cp	r18, r22
    ba6c:	37 07       	cpc	r19, r23
    ba6e:	48 07       	cpc	r20, r24
    ba70:	ab 07       	cpc	r26, r27
    ba72:	b0 e8       	ldi	r27, 0x80	; 128
    ba74:	09 f0       	breq	.+2      	; 0xba78 <__divsf3_pse+0x56>
    ba76:	bb 0b       	sbc	r27, r27
    ba78:	80 2d       	mov	r24, r0
    ba7a:	bf 01       	movw	r22, r30
    ba7c:	ff 27       	eor	r31, r31
    ba7e:	93 58       	subi	r25, 0x83	; 131
    ba80:	5f 4f       	sbci	r21, 0xFF	; 255
    ba82:	2a f0       	brmi	.+10     	; 0xba8e <__divsf3_pse+0x6c>
    ba84:	9e 3f       	cpi	r25, 0xFE	; 254
    ba86:	51 05       	cpc	r21, r1
    ba88:	68 f0       	brcs	.+26     	; 0xbaa4 <__divsf3_pse+0x82>
    ba8a:	74 c0       	rjmp	.+232    	; 0xbb74 <__fp_inf>
    ba8c:	be c0       	rjmp	.+380    	; 0xbc0a <__fp_szero>
    ba8e:	5f 3f       	cpi	r21, 0xFF	; 255
    ba90:	ec f3       	brlt	.-6      	; 0xba8c <__divsf3_pse+0x6a>
    ba92:	98 3e       	cpi	r25, 0xE8	; 232
    ba94:	dc f3       	brlt	.-10     	; 0xba8c <__divsf3_pse+0x6a>
    ba96:	86 95       	lsr	r24
    ba98:	77 95       	ror	r23
    ba9a:	67 95       	ror	r22
    ba9c:	b7 95       	ror	r27
    ba9e:	f7 95       	ror	r31
    baa0:	9f 5f       	subi	r25, 0xFF	; 255
    baa2:	c9 f7       	brne	.-14     	; 0xba96 <__divsf3_pse+0x74>
    baa4:	88 0f       	add	r24, r24
    baa6:	91 1d       	adc	r25, r1
    baa8:	96 95       	lsr	r25
    baaa:	87 95       	ror	r24
    baac:	97 f9       	bld	r25, 7
    baae:	08 95       	ret
    bab0:	e1 e0       	ldi	r30, 0x01	; 1
    bab2:	66 0f       	add	r22, r22
    bab4:	77 1f       	adc	r23, r23
    bab6:	88 1f       	adc	r24, r24
    bab8:	bb 1f       	adc	r27, r27
    baba:	62 17       	cp	r22, r18
    babc:	73 07       	cpc	r23, r19
    babe:	84 07       	cpc	r24, r20
    bac0:	ba 07       	cpc	r27, r26
    bac2:	20 f0       	brcs	.+8      	; 0xbacc <__divsf3_pse+0xaa>
    bac4:	62 1b       	sub	r22, r18
    bac6:	73 0b       	sbc	r23, r19
    bac8:	84 0b       	sbc	r24, r20
    baca:	ba 0b       	sbc	r27, r26
    bacc:	ee 1f       	adc	r30, r30
    bace:	88 f7       	brcc	.-30     	; 0xbab2 <__divsf3_pse+0x90>
    bad0:	e0 95       	com	r30
    bad2:	08 95       	ret

0000bad4 <__fixunssfsi>:
    bad4:	7f d0       	rcall	.+254    	; 0xbbd4 <__fp_splitA>
    bad6:	88 f0       	brcs	.+34     	; 0xbafa <__fixunssfsi+0x26>
    bad8:	9f 57       	subi	r25, 0x7F	; 127
    bada:	90 f0       	brcs	.+36     	; 0xbb00 <__fixunssfsi+0x2c>
    badc:	b9 2f       	mov	r27, r25
    bade:	99 27       	eor	r25, r25
    bae0:	b7 51       	subi	r27, 0x17	; 23
    bae2:	a0 f0       	brcs	.+40     	; 0xbb0c <__fixunssfsi+0x38>
    bae4:	d1 f0       	breq	.+52     	; 0xbb1a <__fixunssfsi+0x46>
    bae6:	66 0f       	add	r22, r22
    bae8:	77 1f       	adc	r23, r23
    baea:	88 1f       	adc	r24, r24
    baec:	99 1f       	adc	r25, r25
    baee:	1a f0       	brmi	.+6      	; 0xbaf6 <__fixunssfsi+0x22>
    baf0:	ba 95       	dec	r27
    baf2:	c9 f7       	brne	.-14     	; 0xbae6 <__fixunssfsi+0x12>
    baf4:	12 c0       	rjmp	.+36     	; 0xbb1a <__fixunssfsi+0x46>
    baf6:	b1 30       	cpi	r27, 0x01	; 1
    baf8:	81 f0       	breq	.+32     	; 0xbb1a <__fixunssfsi+0x46>
    bafa:	86 d0       	rcall	.+268    	; 0xbc08 <__fp_zero>
    bafc:	b1 e0       	ldi	r27, 0x01	; 1
    bafe:	08 95       	ret
    bb00:	83 c0       	rjmp	.+262    	; 0xbc08 <__fp_zero>
    bb02:	67 2f       	mov	r22, r23
    bb04:	78 2f       	mov	r23, r24
    bb06:	88 27       	eor	r24, r24
    bb08:	b8 5f       	subi	r27, 0xF8	; 248
    bb0a:	39 f0       	breq	.+14     	; 0xbb1a <__fixunssfsi+0x46>
    bb0c:	b9 3f       	cpi	r27, 0xF9	; 249
    bb0e:	cc f3       	brlt	.-14     	; 0xbb02 <__fixunssfsi+0x2e>
    bb10:	86 95       	lsr	r24
    bb12:	77 95       	ror	r23
    bb14:	67 95       	ror	r22
    bb16:	b3 95       	inc	r27
    bb18:	d9 f7       	brne	.-10     	; 0xbb10 <__fixunssfsi+0x3c>
    bb1a:	3e f4       	brtc	.+14     	; 0xbb2a <__fixunssfsi+0x56>
    bb1c:	90 95       	com	r25
    bb1e:	80 95       	com	r24
    bb20:	70 95       	com	r23
    bb22:	61 95       	neg	r22
    bb24:	7f 4f       	sbci	r23, 0xFF	; 255
    bb26:	8f 4f       	sbci	r24, 0xFF	; 255
    bb28:	9f 4f       	sbci	r25, 0xFF	; 255
    bb2a:	08 95       	ret

0000bb2c <__fp_cmp>:
    bb2c:	99 0f       	add	r25, r25
    bb2e:	00 08       	sbc	r0, r0
    bb30:	55 0f       	add	r21, r21
    bb32:	aa 0b       	sbc	r26, r26
    bb34:	e0 e8       	ldi	r30, 0x80	; 128
    bb36:	fe ef       	ldi	r31, 0xFE	; 254
    bb38:	16 16       	cp	r1, r22
    bb3a:	17 06       	cpc	r1, r23
    bb3c:	e8 07       	cpc	r30, r24
    bb3e:	f9 07       	cpc	r31, r25
    bb40:	c0 f0       	brcs	.+48     	; 0xbb72 <__fp_cmp+0x46>
    bb42:	12 16       	cp	r1, r18
    bb44:	13 06       	cpc	r1, r19
    bb46:	e4 07       	cpc	r30, r20
    bb48:	f5 07       	cpc	r31, r21
    bb4a:	98 f0       	brcs	.+38     	; 0xbb72 <__fp_cmp+0x46>
    bb4c:	62 1b       	sub	r22, r18
    bb4e:	73 0b       	sbc	r23, r19
    bb50:	84 0b       	sbc	r24, r20
    bb52:	95 0b       	sbc	r25, r21
    bb54:	39 f4       	brne	.+14     	; 0xbb64 <__fp_cmp+0x38>
    bb56:	0a 26       	eor	r0, r26
    bb58:	61 f0       	breq	.+24     	; 0xbb72 <__fp_cmp+0x46>
    bb5a:	23 2b       	or	r18, r19
    bb5c:	24 2b       	or	r18, r20
    bb5e:	25 2b       	or	r18, r21
    bb60:	21 f4       	brne	.+8      	; 0xbb6a <__fp_cmp+0x3e>
    bb62:	08 95       	ret
    bb64:	0a 26       	eor	r0, r26
    bb66:	09 f4       	brne	.+2      	; 0xbb6a <__fp_cmp+0x3e>
    bb68:	a1 40       	sbci	r26, 0x01	; 1
    bb6a:	a6 95       	lsr	r26
    bb6c:	8f ef       	ldi	r24, 0xFF	; 255
    bb6e:	81 1d       	adc	r24, r1
    bb70:	81 1d       	adc	r24, r1
    bb72:	08 95       	ret

0000bb74 <__fp_inf>:
    bb74:	97 f9       	bld	r25, 7
    bb76:	9f 67       	ori	r25, 0x7F	; 127
    bb78:	80 e8       	ldi	r24, 0x80	; 128
    bb7a:	70 e0       	ldi	r23, 0x00	; 0
    bb7c:	60 e0       	ldi	r22, 0x00	; 0
    bb7e:	08 95       	ret

0000bb80 <__fp_nan>:
    bb80:	9f ef       	ldi	r25, 0xFF	; 255
    bb82:	80 ec       	ldi	r24, 0xC0	; 192
    bb84:	08 95       	ret

0000bb86 <__fp_pscA>:
    bb86:	00 24       	eor	r0, r0
    bb88:	0a 94       	dec	r0
    bb8a:	16 16       	cp	r1, r22
    bb8c:	17 06       	cpc	r1, r23
    bb8e:	18 06       	cpc	r1, r24
    bb90:	09 06       	cpc	r0, r25
    bb92:	08 95       	ret

0000bb94 <__fp_pscB>:
    bb94:	00 24       	eor	r0, r0
    bb96:	0a 94       	dec	r0
    bb98:	12 16       	cp	r1, r18
    bb9a:	13 06       	cpc	r1, r19
    bb9c:	14 06       	cpc	r1, r20
    bb9e:	05 06       	cpc	r0, r21
    bba0:	08 95       	ret

0000bba2 <__fp_round>:
    bba2:	09 2e       	mov	r0, r25
    bba4:	03 94       	inc	r0
    bba6:	00 0c       	add	r0, r0
    bba8:	11 f4       	brne	.+4      	; 0xbbae <__fp_round+0xc>
    bbaa:	88 23       	and	r24, r24
    bbac:	52 f0       	brmi	.+20     	; 0xbbc2 <__fp_round+0x20>
    bbae:	bb 0f       	add	r27, r27
    bbb0:	40 f4       	brcc	.+16     	; 0xbbc2 <__fp_round+0x20>
    bbb2:	bf 2b       	or	r27, r31
    bbb4:	11 f4       	brne	.+4      	; 0xbbba <__fp_round+0x18>
    bbb6:	60 ff       	sbrs	r22, 0
    bbb8:	04 c0       	rjmp	.+8      	; 0xbbc2 <__fp_round+0x20>
    bbba:	6f 5f       	subi	r22, 0xFF	; 255
    bbbc:	7f 4f       	sbci	r23, 0xFF	; 255
    bbbe:	8f 4f       	sbci	r24, 0xFF	; 255
    bbc0:	9f 4f       	sbci	r25, 0xFF	; 255
    bbc2:	08 95       	ret

0000bbc4 <__fp_split3>:
    bbc4:	57 fd       	sbrc	r21, 7
    bbc6:	90 58       	subi	r25, 0x80	; 128
    bbc8:	44 0f       	add	r20, r20
    bbca:	55 1f       	adc	r21, r21
    bbcc:	59 f0       	breq	.+22     	; 0xbbe4 <__fp_splitA+0x10>
    bbce:	5f 3f       	cpi	r21, 0xFF	; 255
    bbd0:	71 f0       	breq	.+28     	; 0xbbee <__fp_splitA+0x1a>
    bbd2:	47 95       	ror	r20

0000bbd4 <__fp_splitA>:
    bbd4:	88 0f       	add	r24, r24
    bbd6:	97 fb       	bst	r25, 7
    bbd8:	99 1f       	adc	r25, r25
    bbda:	61 f0       	breq	.+24     	; 0xbbf4 <__fp_splitA+0x20>
    bbdc:	9f 3f       	cpi	r25, 0xFF	; 255
    bbde:	79 f0       	breq	.+30     	; 0xbbfe <__fp_splitA+0x2a>
    bbe0:	87 95       	ror	r24
    bbe2:	08 95       	ret
    bbe4:	12 16       	cp	r1, r18
    bbe6:	13 06       	cpc	r1, r19
    bbe8:	14 06       	cpc	r1, r20
    bbea:	55 1f       	adc	r21, r21
    bbec:	f2 cf       	rjmp	.-28     	; 0xbbd2 <__fp_split3+0xe>
    bbee:	46 95       	lsr	r20
    bbf0:	f1 df       	rcall	.-30     	; 0xbbd4 <__fp_splitA>
    bbf2:	08 c0       	rjmp	.+16     	; 0xbc04 <__fp_splitA+0x30>
    bbf4:	16 16       	cp	r1, r22
    bbf6:	17 06       	cpc	r1, r23
    bbf8:	18 06       	cpc	r1, r24
    bbfa:	99 1f       	adc	r25, r25
    bbfc:	f1 cf       	rjmp	.-30     	; 0xbbe0 <__fp_splitA+0xc>
    bbfe:	86 95       	lsr	r24
    bc00:	71 05       	cpc	r23, r1
    bc02:	61 05       	cpc	r22, r1
    bc04:	08 94       	sec
    bc06:	08 95       	ret

0000bc08 <__fp_zero>:
    bc08:	e8 94       	clt

0000bc0a <__fp_szero>:
    bc0a:	bb 27       	eor	r27, r27
    bc0c:	66 27       	eor	r22, r22
    bc0e:	77 27       	eor	r23, r23
    bc10:	cb 01       	movw	r24, r22
    bc12:	97 f9       	bld	r25, 7
    bc14:	08 95       	ret

0000bc16 <__gesf2>:
    bc16:	8a df       	rcall	.-236    	; 0xbb2c <__fp_cmp>
    bc18:	08 f4       	brcc	.+2      	; 0xbc1c <__gesf2+0x6>
    bc1a:	8f ef       	ldi	r24, 0xFF	; 255
    bc1c:	08 95       	ret

0000bc1e <__mulsf3>:
    bc1e:	0b d0       	rcall	.+22     	; 0xbc36 <__mulsf3x>
    bc20:	c0 cf       	rjmp	.-128    	; 0xbba2 <__fp_round>
    bc22:	b1 df       	rcall	.-158    	; 0xbb86 <__fp_pscA>
    bc24:	28 f0       	brcs	.+10     	; 0xbc30 <__mulsf3+0x12>
    bc26:	b6 df       	rcall	.-148    	; 0xbb94 <__fp_pscB>
    bc28:	18 f0       	brcs	.+6      	; 0xbc30 <__mulsf3+0x12>
    bc2a:	95 23       	and	r25, r21
    bc2c:	09 f0       	breq	.+2      	; 0xbc30 <__mulsf3+0x12>
    bc2e:	a2 cf       	rjmp	.-188    	; 0xbb74 <__fp_inf>
    bc30:	a7 cf       	rjmp	.-178    	; 0xbb80 <__fp_nan>
    bc32:	11 24       	eor	r1, r1
    bc34:	ea cf       	rjmp	.-44     	; 0xbc0a <__fp_szero>

0000bc36 <__mulsf3x>:
    bc36:	c6 df       	rcall	.-116    	; 0xbbc4 <__fp_split3>
    bc38:	a0 f3       	brcs	.-24     	; 0xbc22 <__mulsf3+0x4>

0000bc3a <__mulsf3_pse>:
    bc3a:	95 9f       	mul	r25, r21
    bc3c:	d1 f3       	breq	.-12     	; 0xbc32 <__mulsf3+0x14>
    bc3e:	95 0f       	add	r25, r21
    bc40:	50 e0       	ldi	r21, 0x00	; 0
    bc42:	55 1f       	adc	r21, r21
    bc44:	62 9f       	mul	r22, r18
    bc46:	f0 01       	movw	r30, r0
    bc48:	72 9f       	mul	r23, r18
    bc4a:	bb 27       	eor	r27, r27
    bc4c:	f0 0d       	add	r31, r0
    bc4e:	b1 1d       	adc	r27, r1
    bc50:	63 9f       	mul	r22, r19
    bc52:	aa 27       	eor	r26, r26
    bc54:	f0 0d       	add	r31, r0
    bc56:	b1 1d       	adc	r27, r1
    bc58:	aa 1f       	adc	r26, r26
    bc5a:	64 9f       	mul	r22, r20
    bc5c:	66 27       	eor	r22, r22
    bc5e:	b0 0d       	add	r27, r0
    bc60:	a1 1d       	adc	r26, r1
    bc62:	66 1f       	adc	r22, r22
    bc64:	82 9f       	mul	r24, r18
    bc66:	22 27       	eor	r18, r18
    bc68:	b0 0d       	add	r27, r0
    bc6a:	a1 1d       	adc	r26, r1
    bc6c:	62 1f       	adc	r22, r18
    bc6e:	73 9f       	mul	r23, r19
    bc70:	b0 0d       	add	r27, r0
    bc72:	a1 1d       	adc	r26, r1
    bc74:	62 1f       	adc	r22, r18
    bc76:	83 9f       	mul	r24, r19
    bc78:	a0 0d       	add	r26, r0
    bc7a:	61 1d       	adc	r22, r1
    bc7c:	22 1f       	adc	r18, r18
    bc7e:	74 9f       	mul	r23, r20
    bc80:	33 27       	eor	r19, r19
    bc82:	a0 0d       	add	r26, r0
    bc84:	61 1d       	adc	r22, r1
    bc86:	23 1f       	adc	r18, r19
    bc88:	84 9f       	mul	r24, r20
    bc8a:	60 0d       	add	r22, r0
    bc8c:	21 1d       	adc	r18, r1
    bc8e:	82 2f       	mov	r24, r18
    bc90:	76 2f       	mov	r23, r22
    bc92:	6a 2f       	mov	r22, r26
    bc94:	11 24       	eor	r1, r1
    bc96:	9f 57       	subi	r25, 0x7F	; 127
    bc98:	50 40       	sbci	r21, 0x00	; 0
    bc9a:	8a f0       	brmi	.+34     	; 0xbcbe <__mulsf3_pse+0x84>
    bc9c:	e1 f0       	breq	.+56     	; 0xbcd6 <__mulsf3_pse+0x9c>
    bc9e:	88 23       	and	r24, r24
    bca0:	4a f0       	brmi	.+18     	; 0xbcb4 <__mulsf3_pse+0x7a>
    bca2:	ee 0f       	add	r30, r30
    bca4:	ff 1f       	adc	r31, r31
    bca6:	bb 1f       	adc	r27, r27
    bca8:	66 1f       	adc	r22, r22
    bcaa:	77 1f       	adc	r23, r23
    bcac:	88 1f       	adc	r24, r24
    bcae:	91 50       	subi	r25, 0x01	; 1
    bcb0:	50 40       	sbci	r21, 0x00	; 0
    bcb2:	a9 f7       	brne	.-22     	; 0xbc9e <__mulsf3_pse+0x64>
    bcb4:	9e 3f       	cpi	r25, 0xFE	; 254
    bcb6:	51 05       	cpc	r21, r1
    bcb8:	70 f0       	brcs	.+28     	; 0xbcd6 <__mulsf3_pse+0x9c>
    bcba:	5c cf       	rjmp	.-328    	; 0xbb74 <__fp_inf>
    bcbc:	a6 cf       	rjmp	.-180    	; 0xbc0a <__fp_szero>
    bcbe:	5f 3f       	cpi	r21, 0xFF	; 255
    bcc0:	ec f3       	brlt	.-6      	; 0xbcbc <__mulsf3_pse+0x82>
    bcc2:	98 3e       	cpi	r25, 0xE8	; 232
    bcc4:	dc f3       	brlt	.-10     	; 0xbcbc <__mulsf3_pse+0x82>
    bcc6:	86 95       	lsr	r24
    bcc8:	77 95       	ror	r23
    bcca:	67 95       	ror	r22
    bccc:	b7 95       	ror	r27
    bcce:	f7 95       	ror	r31
    bcd0:	e7 95       	ror	r30
    bcd2:	9f 5f       	subi	r25, 0xFF	; 255
    bcd4:	c1 f7       	brne	.-16     	; 0xbcc6 <__mulsf3_pse+0x8c>
    bcd6:	fe 2b       	or	r31, r30
    bcd8:	88 0f       	add	r24, r24
    bcda:	91 1d       	adc	r25, r1
    bcdc:	96 95       	lsr	r25
    bcde:	87 95       	ror	r24
    bce0:	97 f9       	bld	r25, 7
    bce2:	08 95       	ret

0000bce4 <__mulsi3>:
    bce4:	62 9f       	mul	r22, r18
    bce6:	d0 01       	movw	r26, r0
    bce8:	73 9f       	mul	r23, r19
    bcea:	f0 01       	movw	r30, r0
    bcec:	82 9f       	mul	r24, r18
    bcee:	e0 0d       	add	r30, r0
    bcf0:	f1 1d       	adc	r31, r1
    bcf2:	64 9f       	mul	r22, r20
    bcf4:	e0 0d       	add	r30, r0
    bcf6:	f1 1d       	adc	r31, r1
    bcf8:	92 9f       	mul	r25, r18
    bcfa:	f0 0d       	add	r31, r0
    bcfc:	83 9f       	mul	r24, r19
    bcfe:	f0 0d       	add	r31, r0
    bd00:	74 9f       	mul	r23, r20
    bd02:	f0 0d       	add	r31, r0
    bd04:	65 9f       	mul	r22, r21
    bd06:	f0 0d       	add	r31, r0
    bd08:	99 27       	eor	r25, r25
    bd0a:	72 9f       	mul	r23, r18
    bd0c:	b0 0d       	add	r27, r0
    bd0e:	e1 1d       	adc	r30, r1
    bd10:	f9 1f       	adc	r31, r25
    bd12:	63 9f       	mul	r22, r19
    bd14:	b0 0d       	add	r27, r0
    bd16:	e1 1d       	adc	r30, r1
    bd18:	f9 1f       	adc	r31, r25
    bd1a:	bd 01       	movw	r22, r26
    bd1c:	cf 01       	movw	r24, r30
    bd1e:	11 24       	eor	r1, r1
    bd20:	08 95       	ret

0000bd22 <__udivmodhi4>:
    bd22:	aa 1b       	sub	r26, r26
    bd24:	bb 1b       	sub	r27, r27
    bd26:	51 e1       	ldi	r21, 0x11	; 17
    bd28:	07 c0       	rjmp	.+14     	; 0xbd38 <__udivmodhi4_ep>

0000bd2a <__udivmodhi4_loop>:
    bd2a:	aa 1f       	adc	r26, r26
    bd2c:	bb 1f       	adc	r27, r27
    bd2e:	a6 17       	cp	r26, r22
    bd30:	b7 07       	cpc	r27, r23
    bd32:	10 f0       	brcs	.+4      	; 0xbd38 <__udivmodhi4_ep>
    bd34:	a6 1b       	sub	r26, r22
    bd36:	b7 0b       	sbc	r27, r23

0000bd38 <__udivmodhi4_ep>:
    bd38:	88 1f       	adc	r24, r24
    bd3a:	99 1f       	adc	r25, r25
    bd3c:	5a 95       	dec	r21
    bd3e:	a9 f7       	brne	.-22     	; 0xbd2a <__udivmodhi4_loop>
    bd40:	80 95       	com	r24
    bd42:	90 95       	com	r25
    bd44:	bc 01       	movw	r22, r24
    bd46:	cd 01       	movw	r24, r26
    bd48:	08 95       	ret

0000bd4a <__divmodhi4>:
    bd4a:	97 fb       	bst	r25, 7
    bd4c:	09 2e       	mov	r0, r25
    bd4e:	07 26       	eor	r0, r23
    bd50:	0a d0       	rcall	.+20     	; 0xbd66 <__divmodhi4_neg1>
    bd52:	77 fd       	sbrc	r23, 7
    bd54:	04 d0       	rcall	.+8      	; 0xbd5e <__divmodhi4_neg2>
    bd56:	e5 df       	rcall	.-54     	; 0xbd22 <__udivmodhi4>
    bd58:	06 d0       	rcall	.+12     	; 0xbd66 <__divmodhi4_neg1>
    bd5a:	00 20       	and	r0, r0
    bd5c:	1a f4       	brpl	.+6      	; 0xbd64 <__divmodhi4_exit>

0000bd5e <__divmodhi4_neg2>:
    bd5e:	70 95       	com	r23
    bd60:	61 95       	neg	r22
    bd62:	7f 4f       	sbci	r23, 0xFF	; 255

0000bd64 <__divmodhi4_exit>:
    bd64:	08 95       	ret

0000bd66 <__divmodhi4_neg1>:
    bd66:	f6 f7       	brtc	.-4      	; 0xbd64 <__divmodhi4_exit>
    bd68:	90 95       	com	r25
    bd6a:	81 95       	neg	r24
    bd6c:	9f 4f       	sbci	r25, 0xFF	; 255
    bd6e:	08 95       	ret

0000bd70 <__udivmodsi4>:
    bd70:	a1 e2       	ldi	r26, 0x21	; 33
    bd72:	1a 2e       	mov	r1, r26
    bd74:	aa 1b       	sub	r26, r26
    bd76:	bb 1b       	sub	r27, r27
    bd78:	fd 01       	movw	r30, r26
    bd7a:	0d c0       	rjmp	.+26     	; 0xbd96 <__udivmodsi4_ep>

0000bd7c <__udivmodsi4_loop>:
    bd7c:	aa 1f       	adc	r26, r26
    bd7e:	bb 1f       	adc	r27, r27
    bd80:	ee 1f       	adc	r30, r30
    bd82:	ff 1f       	adc	r31, r31
    bd84:	a2 17       	cp	r26, r18
    bd86:	b3 07       	cpc	r27, r19
    bd88:	e4 07       	cpc	r30, r20
    bd8a:	f5 07       	cpc	r31, r21
    bd8c:	20 f0       	brcs	.+8      	; 0xbd96 <__udivmodsi4_ep>
    bd8e:	a2 1b       	sub	r26, r18
    bd90:	b3 0b       	sbc	r27, r19
    bd92:	e4 0b       	sbc	r30, r20
    bd94:	f5 0b       	sbc	r31, r21

0000bd96 <__udivmodsi4_ep>:
    bd96:	66 1f       	adc	r22, r22
    bd98:	77 1f       	adc	r23, r23
    bd9a:	88 1f       	adc	r24, r24
    bd9c:	99 1f       	adc	r25, r25
    bd9e:	1a 94       	dec	r1
    bda0:	69 f7       	brne	.-38     	; 0xbd7c <__udivmodsi4_loop>
    bda2:	60 95       	com	r22
    bda4:	70 95       	com	r23
    bda6:	80 95       	com	r24
    bda8:	90 95       	com	r25
    bdaa:	9b 01       	movw	r18, r22
    bdac:	ac 01       	movw	r20, r24
    bdae:	bd 01       	movw	r22, r26
    bdb0:	cf 01       	movw	r24, r30
    bdb2:	08 95       	ret

0000bdb4 <__divmodsi4>:
    bdb4:	97 fb       	bst	r25, 7
    bdb6:	09 2e       	mov	r0, r25
    bdb8:	05 26       	eor	r0, r21
    bdba:	0e d0       	rcall	.+28     	; 0xbdd8 <__divmodsi4_neg1>
    bdbc:	57 fd       	sbrc	r21, 7
    bdbe:	04 d0       	rcall	.+8      	; 0xbdc8 <__divmodsi4_neg2>
    bdc0:	d7 df       	rcall	.-82     	; 0xbd70 <__udivmodsi4>
    bdc2:	0a d0       	rcall	.+20     	; 0xbdd8 <__divmodsi4_neg1>
    bdc4:	00 1c       	adc	r0, r0
    bdc6:	38 f4       	brcc	.+14     	; 0xbdd6 <__divmodsi4_exit>

0000bdc8 <__divmodsi4_neg2>:
    bdc8:	50 95       	com	r21
    bdca:	40 95       	com	r20
    bdcc:	30 95       	com	r19
    bdce:	21 95       	neg	r18
    bdd0:	3f 4f       	sbci	r19, 0xFF	; 255
    bdd2:	4f 4f       	sbci	r20, 0xFF	; 255
    bdd4:	5f 4f       	sbci	r21, 0xFF	; 255

0000bdd6 <__divmodsi4_exit>:
    bdd6:	08 95       	ret

0000bdd8 <__divmodsi4_neg1>:
    bdd8:	f6 f7       	brtc	.-4      	; 0xbdd6 <__divmodsi4_exit>
    bdda:	90 95       	com	r25
    bddc:	80 95       	com	r24
    bdde:	70 95       	com	r23
    bde0:	61 95       	neg	r22
    bde2:	7f 4f       	sbci	r23, 0xFF	; 255
    bde4:	8f 4f       	sbci	r24, 0xFF	; 255
    bde6:	9f 4f       	sbci	r25, 0xFF	; 255
    bde8:	08 95       	ret

0000bdea <__prologue_saves__>:
    bdea:	2f 92       	push	r2
    bdec:	3f 92       	push	r3
    bdee:	4f 92       	push	r4
    bdf0:	5f 92       	push	r5
    bdf2:	6f 92       	push	r6
    bdf4:	7f 92       	push	r7
    bdf6:	8f 92       	push	r8
    bdf8:	9f 92       	push	r9
    bdfa:	af 92       	push	r10
    bdfc:	bf 92       	push	r11
    bdfe:	cf 92       	push	r12
    be00:	df 92       	push	r13
    be02:	ef 92       	push	r14
    be04:	ff 92       	push	r15
    be06:	0f 93       	push	r16
    be08:	1f 93       	push	r17
    be0a:	cf 93       	push	r28
    be0c:	df 93       	push	r29
    be0e:	cd b7       	in	r28, 0x3d	; 61
    be10:	de b7       	in	r29, 0x3e	; 62
    be12:	ca 1b       	sub	r28, r26
    be14:	db 0b       	sbc	r29, r27
    be16:	cd bf       	out	0x3d, r28	; 61
    be18:	de bf       	out	0x3e, r29	; 62
    be1a:	19 94       	eijmp

0000be1c <__epilogue_restores__>:
    be1c:	2a 88       	ldd	r2, Y+18	; 0x12
    be1e:	39 88       	ldd	r3, Y+17	; 0x11
    be20:	48 88       	ldd	r4, Y+16	; 0x10
    be22:	5f 84       	ldd	r5, Y+15	; 0x0f
    be24:	6e 84       	ldd	r6, Y+14	; 0x0e
    be26:	7d 84       	ldd	r7, Y+13	; 0x0d
    be28:	8c 84       	ldd	r8, Y+12	; 0x0c
    be2a:	9b 84       	ldd	r9, Y+11	; 0x0b
    be2c:	aa 84       	ldd	r10, Y+10	; 0x0a
    be2e:	b9 84       	ldd	r11, Y+9	; 0x09
    be30:	c8 84       	ldd	r12, Y+8	; 0x08
    be32:	df 80       	ldd	r13, Y+7	; 0x07
    be34:	ee 80       	ldd	r14, Y+6	; 0x06
    be36:	fd 80       	ldd	r15, Y+5	; 0x05
    be38:	0c 81       	ldd	r16, Y+4	; 0x04
    be3a:	1b 81       	ldd	r17, Y+3	; 0x03
    be3c:	aa 81       	ldd	r26, Y+2	; 0x02
    be3e:	b9 81       	ldd	r27, Y+1	; 0x01
    be40:	ce 0f       	add	r28, r30
    be42:	d1 1d       	adc	r29, r1
    be44:	cd bf       	out	0x3d, r28	; 61
    be46:	de bf       	out	0x3e, r29	; 62
    be48:	ed 01       	movw	r28, r26
    be4a:	08 95       	ret

0000be4c <strcpy_P>:
    be4c:	fb 01       	movw	r30, r22
    be4e:	dc 01       	movw	r26, r24
    be50:	05 90       	lpm	r0, Z+
    be52:	0d 92       	st	X+, r0
    be54:	00 20       	and	r0, r0
    be56:	e1 f7       	brne	.-8      	; 0xbe50 <strcpy_P+0x4>
    be58:	08 95       	ret

0000be5a <memcpy>:
    be5a:	fb 01       	movw	r30, r22
    be5c:	dc 01       	movw	r26, r24
    be5e:	02 c0       	rjmp	.+4      	; 0xbe64 <memcpy+0xa>
    be60:	01 90       	ld	r0, Z+
    be62:	0d 92       	st	X+, r0
    be64:	41 50       	subi	r20, 0x01	; 1
    be66:	50 40       	sbci	r21, 0x00	; 0
    be68:	d8 f7       	brcc	.-10     	; 0xbe60 <memcpy+0x6>
    be6a:	08 95       	ret

0000be6c <memmove>:
    be6c:	68 17       	cp	r22, r24
    be6e:	79 07       	cpc	r23, r25
    be70:	68 f4       	brcc	.+26     	; 0xbe8c <memmove+0x20>
    be72:	fb 01       	movw	r30, r22
    be74:	dc 01       	movw	r26, r24
    be76:	e4 0f       	add	r30, r20
    be78:	f5 1f       	adc	r31, r21
    be7a:	a4 0f       	add	r26, r20
    be7c:	b5 1f       	adc	r27, r21
    be7e:	02 c0       	rjmp	.+4      	; 0xbe84 <memmove+0x18>
    be80:	02 90       	ld	r0, -Z
    be82:	0e 92       	st	-X, r0
    be84:	41 50       	subi	r20, 0x01	; 1
    be86:	50 40       	sbci	r21, 0x00	; 0
    be88:	d8 f7       	brcc	.-10     	; 0xbe80 <memmove+0x14>
    be8a:	08 95       	ret
    be8c:	0c 94 2d 5f 	jmp	0xbe5a	; 0xbe5a <memcpy>

0000be90 <strcat>:
    be90:	fb 01       	movw	r30, r22
    be92:	dc 01       	movw	r26, r24
    be94:	0d 90       	ld	r0, X+
    be96:	00 20       	and	r0, r0
    be98:	e9 f7       	brne	.-6      	; 0xbe94 <strcat+0x4>
    be9a:	11 97       	sbiw	r26, 0x01	; 1
    be9c:	01 90       	ld	r0, Z+
    be9e:	0d 92       	st	X+, r0
    bea0:	00 20       	and	r0, r0
    bea2:	e1 f7       	brne	.-8      	; 0xbe9c <strcat+0xc>
    bea4:	08 95       	ret

0000bea6 <strncmp>:
    bea6:	fb 01       	movw	r30, r22
    bea8:	dc 01       	movw	r26, r24
    beaa:	41 50       	subi	r20, 0x01	; 1
    beac:	50 40       	sbci	r21, 0x00	; 0
    beae:	30 f0       	brcs	.+12     	; 0xbebc <strncmp+0x16>
    beb0:	8d 91       	ld	r24, X+
    beb2:	01 90       	ld	r0, Z+
    beb4:	80 19       	sub	r24, r0
    beb6:	19 f4       	brne	.+6      	; 0xbebe <strncmp+0x18>
    beb8:	00 20       	and	r0, r0
    beba:	b9 f7       	brne	.-18     	; 0xbeaa <strncmp+0x4>
    bebc:	88 1b       	sub	r24, r24
    bebe:	99 0b       	sbc	r25, r25
    bec0:	08 95       	ret

0000bec2 <itoa>:
    bec2:	fb 01       	movw	r30, r22
    bec4:	9f 01       	movw	r18, r30
    bec6:	e8 94       	clt
    bec8:	42 30       	cpi	r20, 0x02	; 2
    beca:	c4 f0       	brlt	.+48     	; 0xbefc <itoa+0x3a>
    becc:	45 32       	cpi	r20, 0x25	; 37
    bece:	b4 f4       	brge	.+44     	; 0xbefc <itoa+0x3a>
    bed0:	4a 30       	cpi	r20, 0x0A	; 10
    bed2:	29 f4       	brne	.+10     	; 0xbede <itoa+0x1c>
    bed4:	97 fb       	bst	r25, 7
    bed6:	1e f4       	brtc	.+6      	; 0xbede <itoa+0x1c>
    bed8:	90 95       	com	r25
    beda:	81 95       	neg	r24
    bedc:	9f 4f       	sbci	r25, 0xFF	; 255
    bede:	64 2f       	mov	r22, r20
    bee0:	77 27       	eor	r23, r23
    bee2:	0e 94 91 5e 	call	0xbd22	; 0xbd22 <__udivmodhi4>
    bee6:	80 5d       	subi	r24, 0xD0	; 208
    bee8:	8a 33       	cpi	r24, 0x3A	; 58
    beea:	0c f0       	brlt	.+2      	; 0xbeee <itoa+0x2c>
    beec:	89 5d       	subi	r24, 0xD9	; 217
    beee:	81 93       	st	Z+, r24
    bef0:	cb 01       	movw	r24, r22
    bef2:	00 97       	sbiw	r24, 0x00	; 0
    bef4:	a1 f7       	brne	.-24     	; 0xbede <itoa+0x1c>
    bef6:	16 f4       	brtc	.+4      	; 0xbefc <itoa+0x3a>
    bef8:	5d e2       	ldi	r21, 0x2D	; 45
    befa:	51 93       	st	Z+, r21
    befc:	10 82       	st	Z, r1
    befe:	c9 01       	movw	r24, r18
    bf00:	0c 94 ab 61 	jmp	0xc356	; 0xc356 <strrev>

0000bf04 <printf>:
    bf04:	cf 93       	push	r28
    bf06:	df 93       	push	r29
    bf08:	cd b7       	in	r28, 0x3d	; 61
    bf0a:	de b7       	in	r29, 0x3e	; 62
    bf0c:	fe 01       	movw	r30, r28
    bf0e:	36 96       	adiw	r30, 0x06	; 6
    bf10:	61 91       	ld	r22, Z+
    bf12:	71 91       	ld	r23, Z+
    bf14:	80 91 dd 50 	lds	r24, 0x50DD
    bf18:	90 91 de 50 	lds	r25, 0x50DE
    bf1c:	af 01       	movw	r20, r30
    bf1e:	0e 94 94 5f 	call	0xbf28	; 0xbf28 <vfprintf>
    bf22:	df 91       	pop	r29
    bf24:	cf 91       	pop	r28
    bf26:	08 95       	ret

0000bf28 <vfprintf>:
    bf28:	2f 92       	push	r2
    bf2a:	3f 92       	push	r3
    bf2c:	4f 92       	push	r4
    bf2e:	5f 92       	push	r5
    bf30:	6f 92       	push	r6
    bf32:	7f 92       	push	r7
    bf34:	8f 92       	push	r8
    bf36:	9f 92       	push	r9
    bf38:	af 92       	push	r10
    bf3a:	bf 92       	push	r11
    bf3c:	cf 92       	push	r12
    bf3e:	df 92       	push	r13
    bf40:	ef 92       	push	r14
    bf42:	ff 92       	push	r15
    bf44:	0f 93       	push	r16
    bf46:	1f 93       	push	r17
    bf48:	cf 93       	push	r28
    bf4a:	df 93       	push	r29
    bf4c:	cd b7       	in	r28, 0x3d	; 61
    bf4e:	de b7       	in	r29, 0x3e	; 62
    bf50:	2d 97       	sbiw	r28, 0x0d	; 13
    bf52:	cd bf       	out	0x3d, r28	; 61
    bf54:	de bf       	out	0x3e, r29	; 62
    bf56:	3c 01       	movw	r6, r24
    bf58:	6c 87       	std	Y+12, r22	; 0x0c
    bf5a:	7d 87       	std	Y+13, r23	; 0x0d
    bf5c:	5a 01       	movw	r10, r20
    bf5e:	fc 01       	movw	r30, r24
    bf60:	16 82       	std	Z+6, r1	; 0x06
    bf62:	17 82       	std	Z+7, r1	; 0x07
    bf64:	83 81       	ldd	r24, Z+3	; 0x03
    bf66:	81 ff       	sbrs	r24, 1
    bf68:	c8 c1       	rjmp	.+912    	; 0xc2fa <vfprintf+0x3d2>
    bf6a:	2e 01       	movw	r4, r28
    bf6c:	08 94       	sec
    bf6e:	41 1c       	adc	r4, r1
    bf70:	51 1c       	adc	r5, r1
    bf72:	f3 01       	movw	r30, r6
    bf74:	93 81       	ldd	r25, Z+3	; 0x03
    bf76:	ec 85       	ldd	r30, Y+12	; 0x0c
    bf78:	fd 85       	ldd	r31, Y+13	; 0x0d
    bf7a:	93 fd       	sbrc	r25, 3
    bf7c:	85 91       	lpm	r24, Z+
    bf7e:	93 ff       	sbrs	r25, 3
    bf80:	81 91       	ld	r24, Z+
    bf82:	ec 87       	std	Y+12, r30	; 0x0c
    bf84:	fd 87       	std	Y+13, r31	; 0x0d
    bf86:	88 23       	and	r24, r24
    bf88:	09 f4       	brne	.+2      	; 0xbf8c <vfprintf+0x64>
    bf8a:	b3 c1       	rjmp	.+870    	; 0xc2f2 <vfprintf+0x3ca>
    bf8c:	85 32       	cpi	r24, 0x25	; 37
    bf8e:	41 f4       	brne	.+16     	; 0xbfa0 <vfprintf+0x78>
    bf90:	93 fd       	sbrc	r25, 3
    bf92:	85 91       	lpm	r24, Z+
    bf94:	93 ff       	sbrs	r25, 3
    bf96:	81 91       	ld	r24, Z+
    bf98:	ec 87       	std	Y+12, r30	; 0x0c
    bf9a:	fd 87       	std	Y+13, r31	; 0x0d
    bf9c:	85 32       	cpi	r24, 0x25	; 37
    bf9e:	29 f4       	brne	.+10     	; 0xbfaa <vfprintf+0x82>
    bfa0:	90 e0       	ldi	r25, 0x00	; 0
    bfa2:	b3 01       	movw	r22, r6
    bfa4:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    bfa8:	e4 cf       	rjmp	.-56     	; 0xbf72 <vfprintf+0x4a>
    bfaa:	ff 24       	eor	r15, r15
    bfac:	ee 24       	eor	r14, r14
    bfae:	10 e0       	ldi	r17, 0x00	; 0
    bfb0:	10 32       	cpi	r17, 0x20	; 32
    bfb2:	b0 f4       	brcc	.+44     	; 0xbfe0 <vfprintf+0xb8>
    bfb4:	8b 32       	cpi	r24, 0x2B	; 43
    bfb6:	69 f0       	breq	.+26     	; 0xbfd2 <vfprintf+0xaa>
    bfb8:	8c 32       	cpi	r24, 0x2C	; 44
    bfba:	28 f4       	brcc	.+10     	; 0xbfc6 <vfprintf+0x9e>
    bfbc:	80 32       	cpi	r24, 0x20	; 32
    bfbe:	51 f0       	breq	.+20     	; 0xbfd4 <vfprintf+0xac>
    bfc0:	83 32       	cpi	r24, 0x23	; 35
    bfc2:	71 f4       	brne	.+28     	; 0xbfe0 <vfprintf+0xb8>
    bfc4:	0b c0       	rjmp	.+22     	; 0xbfdc <vfprintf+0xb4>
    bfc6:	8d 32       	cpi	r24, 0x2D	; 45
    bfc8:	39 f0       	breq	.+14     	; 0xbfd8 <vfprintf+0xb0>
    bfca:	80 33       	cpi	r24, 0x30	; 48
    bfcc:	49 f4       	brne	.+18     	; 0xbfe0 <vfprintf+0xb8>
    bfce:	11 60       	ori	r17, 0x01	; 1
    bfd0:	2c c0       	rjmp	.+88     	; 0xc02a <vfprintf+0x102>
    bfd2:	12 60       	ori	r17, 0x02	; 2
    bfd4:	14 60       	ori	r17, 0x04	; 4
    bfd6:	29 c0       	rjmp	.+82     	; 0xc02a <vfprintf+0x102>
    bfd8:	18 60       	ori	r17, 0x08	; 8
    bfda:	27 c0       	rjmp	.+78     	; 0xc02a <vfprintf+0x102>
    bfdc:	10 61       	ori	r17, 0x10	; 16
    bfde:	25 c0       	rjmp	.+74     	; 0xc02a <vfprintf+0x102>
    bfe0:	17 fd       	sbrc	r17, 7
    bfe2:	2e c0       	rjmp	.+92     	; 0xc040 <vfprintf+0x118>
    bfe4:	28 2f       	mov	r18, r24
    bfe6:	20 53       	subi	r18, 0x30	; 48
    bfe8:	2a 30       	cpi	r18, 0x0A	; 10
    bfea:	98 f4       	brcc	.+38     	; 0xc012 <vfprintf+0xea>
    bfec:	16 ff       	sbrs	r17, 6
    bfee:	08 c0       	rjmp	.+16     	; 0xc000 <vfprintf+0xd8>
    bff0:	8f 2d       	mov	r24, r15
    bff2:	88 0f       	add	r24, r24
    bff4:	f8 2e       	mov	r15, r24
    bff6:	ff 0c       	add	r15, r15
    bff8:	ff 0c       	add	r15, r15
    bffa:	f8 0e       	add	r15, r24
    bffc:	f2 0e       	add	r15, r18
    bffe:	15 c0       	rjmp	.+42     	; 0xc02a <vfprintf+0x102>
    c000:	8e 2d       	mov	r24, r14
    c002:	88 0f       	add	r24, r24
    c004:	e8 2e       	mov	r14, r24
    c006:	ee 0c       	add	r14, r14
    c008:	ee 0c       	add	r14, r14
    c00a:	e8 0e       	add	r14, r24
    c00c:	e2 0e       	add	r14, r18
    c00e:	10 62       	ori	r17, 0x20	; 32
    c010:	0c c0       	rjmp	.+24     	; 0xc02a <vfprintf+0x102>
    c012:	8e 32       	cpi	r24, 0x2E	; 46
    c014:	21 f4       	brne	.+8      	; 0xc01e <vfprintf+0xf6>
    c016:	16 fd       	sbrc	r17, 6
    c018:	6c c1       	rjmp	.+728    	; 0xc2f2 <vfprintf+0x3ca>
    c01a:	10 64       	ori	r17, 0x40	; 64
    c01c:	06 c0       	rjmp	.+12     	; 0xc02a <vfprintf+0x102>
    c01e:	8c 36       	cpi	r24, 0x6C	; 108
    c020:	11 f4       	brne	.+4      	; 0xc026 <vfprintf+0xfe>
    c022:	10 68       	ori	r17, 0x80	; 128
    c024:	02 c0       	rjmp	.+4      	; 0xc02a <vfprintf+0x102>
    c026:	88 36       	cpi	r24, 0x68	; 104
    c028:	59 f4       	brne	.+22     	; 0xc040 <vfprintf+0x118>
    c02a:	ec 85       	ldd	r30, Y+12	; 0x0c
    c02c:	fd 85       	ldd	r31, Y+13	; 0x0d
    c02e:	93 fd       	sbrc	r25, 3
    c030:	85 91       	lpm	r24, Z+
    c032:	93 ff       	sbrs	r25, 3
    c034:	81 91       	ld	r24, Z+
    c036:	ec 87       	std	Y+12, r30	; 0x0c
    c038:	fd 87       	std	Y+13, r31	; 0x0d
    c03a:	88 23       	and	r24, r24
    c03c:	09 f0       	breq	.+2      	; 0xc040 <vfprintf+0x118>
    c03e:	b8 cf       	rjmp	.-144    	; 0xbfb0 <vfprintf+0x88>
    c040:	98 2f       	mov	r25, r24
    c042:	95 54       	subi	r25, 0x45	; 69
    c044:	93 30       	cpi	r25, 0x03	; 3
    c046:	18 f0       	brcs	.+6      	; 0xc04e <vfprintf+0x126>
    c048:	90 52       	subi	r25, 0x20	; 32
    c04a:	93 30       	cpi	r25, 0x03	; 3
    c04c:	38 f4       	brcc	.+14     	; 0xc05c <vfprintf+0x134>
    c04e:	24 e0       	ldi	r18, 0x04	; 4
    c050:	30 e0       	ldi	r19, 0x00	; 0
    c052:	a2 0e       	add	r10, r18
    c054:	b3 1e       	adc	r11, r19
    c056:	3f e3       	ldi	r19, 0x3F	; 63
    c058:	39 83       	std	Y+1, r19	; 0x01
    c05a:	0f c0       	rjmp	.+30     	; 0xc07a <vfprintf+0x152>
    c05c:	83 36       	cpi	r24, 0x63	; 99
    c05e:	31 f0       	breq	.+12     	; 0xc06c <vfprintf+0x144>
    c060:	83 37       	cpi	r24, 0x73	; 115
    c062:	81 f0       	breq	.+32     	; 0xc084 <vfprintf+0x15c>
    c064:	83 35       	cpi	r24, 0x53	; 83
    c066:	09 f0       	breq	.+2      	; 0xc06a <vfprintf+0x142>
    c068:	5a c0       	rjmp	.+180    	; 0xc11e <vfprintf+0x1f6>
    c06a:	22 c0       	rjmp	.+68     	; 0xc0b0 <vfprintf+0x188>
    c06c:	f5 01       	movw	r30, r10
    c06e:	80 81       	ld	r24, Z
    c070:	89 83       	std	Y+1, r24	; 0x01
    c072:	22 e0       	ldi	r18, 0x02	; 2
    c074:	30 e0       	ldi	r19, 0x00	; 0
    c076:	a2 0e       	add	r10, r18
    c078:	b3 1e       	adc	r11, r19
    c07a:	21 e0       	ldi	r18, 0x01	; 1
    c07c:	c2 2e       	mov	r12, r18
    c07e:	d1 2c       	mov	r13, r1
    c080:	42 01       	movw	r8, r4
    c082:	14 c0       	rjmp	.+40     	; 0xc0ac <vfprintf+0x184>
    c084:	92 e0       	ldi	r25, 0x02	; 2
    c086:	29 2e       	mov	r2, r25
    c088:	31 2c       	mov	r3, r1
    c08a:	2a 0c       	add	r2, r10
    c08c:	3b 1c       	adc	r3, r11
    c08e:	f5 01       	movw	r30, r10
    c090:	80 80       	ld	r8, Z
    c092:	91 80       	ldd	r9, Z+1	; 0x01
    c094:	16 ff       	sbrs	r17, 6
    c096:	03 c0       	rjmp	.+6      	; 0xc09e <vfprintf+0x176>
    c098:	6f 2d       	mov	r22, r15
    c09a:	70 e0       	ldi	r23, 0x00	; 0
    c09c:	02 c0       	rjmp	.+4      	; 0xc0a2 <vfprintf+0x17a>
    c09e:	6f ef       	ldi	r22, 0xFF	; 255
    c0a0:	7f ef       	ldi	r23, 0xFF	; 255
    c0a2:	c4 01       	movw	r24, r8
    c0a4:	0e 94 a0 61 	call	0xc340	; 0xc340 <strnlen>
    c0a8:	6c 01       	movw	r12, r24
    c0aa:	51 01       	movw	r10, r2
    c0ac:	1f 77       	andi	r17, 0x7F	; 127
    c0ae:	15 c0       	rjmp	.+42     	; 0xc0da <vfprintf+0x1b2>
    c0b0:	82 e0       	ldi	r24, 0x02	; 2
    c0b2:	28 2e       	mov	r2, r24
    c0b4:	31 2c       	mov	r3, r1
    c0b6:	2a 0c       	add	r2, r10
    c0b8:	3b 1c       	adc	r3, r11
    c0ba:	f5 01       	movw	r30, r10
    c0bc:	80 80       	ld	r8, Z
    c0be:	91 80       	ldd	r9, Z+1	; 0x01
    c0c0:	16 ff       	sbrs	r17, 6
    c0c2:	03 c0       	rjmp	.+6      	; 0xc0ca <vfprintf+0x1a2>
    c0c4:	6f 2d       	mov	r22, r15
    c0c6:	70 e0       	ldi	r23, 0x00	; 0
    c0c8:	02 c0       	rjmp	.+4      	; 0xc0ce <vfprintf+0x1a6>
    c0ca:	6f ef       	ldi	r22, 0xFF	; 255
    c0cc:	7f ef       	ldi	r23, 0xFF	; 255
    c0ce:	c4 01       	movw	r24, r8
    c0d0:	0e 94 95 61 	call	0xc32a	; 0xc32a <strnlen_P>
    c0d4:	6c 01       	movw	r12, r24
    c0d6:	10 68       	ori	r17, 0x80	; 128
    c0d8:	51 01       	movw	r10, r2
    c0da:	13 fd       	sbrc	r17, 3
    c0dc:	1c c0       	rjmp	.+56     	; 0xc116 <vfprintf+0x1ee>
    c0de:	06 c0       	rjmp	.+12     	; 0xc0ec <vfprintf+0x1c4>
    c0e0:	80 e2       	ldi	r24, 0x20	; 32
    c0e2:	90 e0       	ldi	r25, 0x00	; 0
    c0e4:	b3 01       	movw	r22, r6
    c0e6:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c0ea:	ea 94       	dec	r14
    c0ec:	8e 2d       	mov	r24, r14
    c0ee:	90 e0       	ldi	r25, 0x00	; 0
    c0f0:	c8 16       	cp	r12, r24
    c0f2:	d9 06       	cpc	r13, r25
    c0f4:	a8 f3       	brcs	.-22     	; 0xc0e0 <vfprintf+0x1b8>
    c0f6:	0f c0       	rjmp	.+30     	; 0xc116 <vfprintf+0x1ee>
    c0f8:	f4 01       	movw	r30, r8
    c0fa:	17 fd       	sbrc	r17, 7
    c0fc:	85 91       	lpm	r24, Z+
    c0fe:	17 ff       	sbrs	r17, 7
    c100:	81 91       	ld	r24, Z+
    c102:	4f 01       	movw	r8, r30
    c104:	90 e0       	ldi	r25, 0x00	; 0
    c106:	b3 01       	movw	r22, r6
    c108:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c10c:	e1 10       	cpse	r14, r1
    c10e:	ea 94       	dec	r14
    c110:	08 94       	sec
    c112:	c1 08       	sbc	r12, r1
    c114:	d1 08       	sbc	r13, r1
    c116:	c1 14       	cp	r12, r1
    c118:	d1 04       	cpc	r13, r1
    c11a:	71 f7       	brne	.-36     	; 0xc0f8 <vfprintf+0x1d0>
    c11c:	e7 c0       	rjmp	.+462    	; 0xc2ec <vfprintf+0x3c4>
    c11e:	84 36       	cpi	r24, 0x64	; 100
    c120:	11 f0       	breq	.+4      	; 0xc126 <vfprintf+0x1fe>
    c122:	89 36       	cpi	r24, 0x69	; 105
    c124:	51 f5       	brne	.+84     	; 0xc17a <vfprintf+0x252>
    c126:	f5 01       	movw	r30, r10
    c128:	17 ff       	sbrs	r17, 7
    c12a:	07 c0       	rjmp	.+14     	; 0xc13a <vfprintf+0x212>
    c12c:	80 81       	ld	r24, Z
    c12e:	91 81       	ldd	r25, Z+1	; 0x01
    c130:	a2 81       	ldd	r26, Z+2	; 0x02
    c132:	b3 81       	ldd	r27, Z+3	; 0x03
    c134:	24 e0       	ldi	r18, 0x04	; 4
    c136:	30 e0       	ldi	r19, 0x00	; 0
    c138:	08 c0       	rjmp	.+16     	; 0xc14a <vfprintf+0x222>
    c13a:	80 81       	ld	r24, Z
    c13c:	91 81       	ldd	r25, Z+1	; 0x01
    c13e:	aa 27       	eor	r26, r26
    c140:	97 fd       	sbrc	r25, 7
    c142:	a0 95       	com	r26
    c144:	ba 2f       	mov	r27, r26
    c146:	22 e0       	ldi	r18, 0x02	; 2
    c148:	30 e0       	ldi	r19, 0x00	; 0
    c14a:	a2 0e       	add	r10, r18
    c14c:	b3 1e       	adc	r11, r19
    c14e:	01 2f       	mov	r16, r17
    c150:	0f 76       	andi	r16, 0x6F	; 111
    c152:	b7 ff       	sbrs	r27, 7
    c154:	08 c0       	rjmp	.+16     	; 0xc166 <vfprintf+0x23e>
    c156:	b0 95       	com	r27
    c158:	a0 95       	com	r26
    c15a:	90 95       	com	r25
    c15c:	81 95       	neg	r24
    c15e:	9f 4f       	sbci	r25, 0xFF	; 255
    c160:	af 4f       	sbci	r26, 0xFF	; 255
    c162:	bf 4f       	sbci	r27, 0xFF	; 255
    c164:	00 68       	ori	r16, 0x80	; 128
    c166:	bc 01       	movw	r22, r24
    c168:	cd 01       	movw	r24, r26
    c16a:	a2 01       	movw	r20, r4
    c16c:	2a e0       	ldi	r18, 0x0A	; 10
    c16e:	30 e0       	ldi	r19, 0x00	; 0
    c170:	0e 94 e7 61 	call	0xc3ce	; 0xc3ce <__ultoa_invert>
    c174:	d8 2e       	mov	r13, r24
    c176:	d4 18       	sub	r13, r4
    c178:	3f c0       	rjmp	.+126    	; 0xc1f8 <vfprintf+0x2d0>
    c17a:	85 37       	cpi	r24, 0x75	; 117
    c17c:	21 f4       	brne	.+8      	; 0xc186 <vfprintf+0x25e>
    c17e:	1f 7e       	andi	r17, 0xEF	; 239
    c180:	2a e0       	ldi	r18, 0x0A	; 10
    c182:	30 e0       	ldi	r19, 0x00	; 0
    c184:	20 c0       	rjmp	.+64     	; 0xc1c6 <vfprintf+0x29e>
    c186:	19 7f       	andi	r17, 0xF9	; 249
    c188:	8f 36       	cpi	r24, 0x6F	; 111
    c18a:	a9 f0       	breq	.+42     	; 0xc1b6 <vfprintf+0x28e>
    c18c:	80 37       	cpi	r24, 0x70	; 112
    c18e:	20 f4       	brcc	.+8      	; 0xc198 <vfprintf+0x270>
    c190:	88 35       	cpi	r24, 0x58	; 88
    c192:	09 f0       	breq	.+2      	; 0xc196 <vfprintf+0x26e>
    c194:	ae c0       	rjmp	.+348    	; 0xc2f2 <vfprintf+0x3ca>
    c196:	0b c0       	rjmp	.+22     	; 0xc1ae <vfprintf+0x286>
    c198:	80 37       	cpi	r24, 0x70	; 112
    c19a:	21 f0       	breq	.+8      	; 0xc1a4 <vfprintf+0x27c>
    c19c:	88 37       	cpi	r24, 0x78	; 120
    c19e:	09 f0       	breq	.+2      	; 0xc1a2 <vfprintf+0x27a>
    c1a0:	a8 c0       	rjmp	.+336    	; 0xc2f2 <vfprintf+0x3ca>
    c1a2:	01 c0       	rjmp	.+2      	; 0xc1a6 <vfprintf+0x27e>
    c1a4:	10 61       	ori	r17, 0x10	; 16
    c1a6:	14 ff       	sbrs	r17, 4
    c1a8:	09 c0       	rjmp	.+18     	; 0xc1bc <vfprintf+0x294>
    c1aa:	14 60       	ori	r17, 0x04	; 4
    c1ac:	07 c0       	rjmp	.+14     	; 0xc1bc <vfprintf+0x294>
    c1ae:	14 ff       	sbrs	r17, 4
    c1b0:	08 c0       	rjmp	.+16     	; 0xc1c2 <vfprintf+0x29a>
    c1b2:	16 60       	ori	r17, 0x06	; 6
    c1b4:	06 c0       	rjmp	.+12     	; 0xc1c2 <vfprintf+0x29a>
    c1b6:	28 e0       	ldi	r18, 0x08	; 8
    c1b8:	30 e0       	ldi	r19, 0x00	; 0
    c1ba:	05 c0       	rjmp	.+10     	; 0xc1c6 <vfprintf+0x29e>
    c1bc:	20 e1       	ldi	r18, 0x10	; 16
    c1be:	30 e0       	ldi	r19, 0x00	; 0
    c1c0:	02 c0       	rjmp	.+4      	; 0xc1c6 <vfprintf+0x29e>
    c1c2:	20 e1       	ldi	r18, 0x10	; 16
    c1c4:	32 e0       	ldi	r19, 0x02	; 2
    c1c6:	f5 01       	movw	r30, r10
    c1c8:	17 ff       	sbrs	r17, 7
    c1ca:	07 c0       	rjmp	.+14     	; 0xc1da <vfprintf+0x2b2>
    c1cc:	60 81       	ld	r22, Z
    c1ce:	71 81       	ldd	r23, Z+1	; 0x01
    c1d0:	82 81       	ldd	r24, Z+2	; 0x02
    c1d2:	93 81       	ldd	r25, Z+3	; 0x03
    c1d4:	44 e0       	ldi	r20, 0x04	; 4
    c1d6:	50 e0       	ldi	r21, 0x00	; 0
    c1d8:	06 c0       	rjmp	.+12     	; 0xc1e6 <vfprintf+0x2be>
    c1da:	60 81       	ld	r22, Z
    c1dc:	71 81       	ldd	r23, Z+1	; 0x01
    c1de:	80 e0       	ldi	r24, 0x00	; 0
    c1e0:	90 e0       	ldi	r25, 0x00	; 0
    c1e2:	42 e0       	ldi	r20, 0x02	; 2
    c1e4:	50 e0       	ldi	r21, 0x00	; 0
    c1e6:	a4 0e       	add	r10, r20
    c1e8:	b5 1e       	adc	r11, r21
    c1ea:	a2 01       	movw	r20, r4
    c1ec:	0e 94 e7 61 	call	0xc3ce	; 0xc3ce <__ultoa_invert>
    c1f0:	d8 2e       	mov	r13, r24
    c1f2:	d4 18       	sub	r13, r4
    c1f4:	01 2f       	mov	r16, r17
    c1f6:	0f 77       	andi	r16, 0x7F	; 127
    c1f8:	06 ff       	sbrs	r16, 6
    c1fa:	09 c0       	rjmp	.+18     	; 0xc20e <vfprintf+0x2e6>
    c1fc:	0e 7f       	andi	r16, 0xFE	; 254
    c1fe:	df 14       	cp	r13, r15
    c200:	30 f4       	brcc	.+12     	; 0xc20e <vfprintf+0x2e6>
    c202:	04 ff       	sbrs	r16, 4
    c204:	06 c0       	rjmp	.+12     	; 0xc212 <vfprintf+0x2ea>
    c206:	02 fd       	sbrc	r16, 2
    c208:	04 c0       	rjmp	.+8      	; 0xc212 <vfprintf+0x2ea>
    c20a:	0f 7e       	andi	r16, 0xEF	; 239
    c20c:	02 c0       	rjmp	.+4      	; 0xc212 <vfprintf+0x2ea>
    c20e:	1d 2d       	mov	r17, r13
    c210:	01 c0       	rjmp	.+2      	; 0xc214 <vfprintf+0x2ec>
    c212:	1f 2d       	mov	r17, r15
    c214:	80 2f       	mov	r24, r16
    c216:	90 e0       	ldi	r25, 0x00	; 0
    c218:	04 ff       	sbrs	r16, 4
    c21a:	0c c0       	rjmp	.+24     	; 0xc234 <vfprintf+0x30c>
    c21c:	fe 01       	movw	r30, r28
    c21e:	ed 0d       	add	r30, r13
    c220:	f1 1d       	adc	r31, r1
    c222:	20 81       	ld	r18, Z
    c224:	20 33       	cpi	r18, 0x30	; 48
    c226:	11 f4       	brne	.+4      	; 0xc22c <vfprintf+0x304>
    c228:	09 7e       	andi	r16, 0xE9	; 233
    c22a:	09 c0       	rjmp	.+18     	; 0xc23e <vfprintf+0x316>
    c22c:	02 ff       	sbrs	r16, 2
    c22e:	06 c0       	rjmp	.+12     	; 0xc23c <vfprintf+0x314>
    c230:	1e 5f       	subi	r17, 0xFE	; 254
    c232:	05 c0       	rjmp	.+10     	; 0xc23e <vfprintf+0x316>
    c234:	86 78       	andi	r24, 0x86	; 134
    c236:	90 70       	andi	r25, 0x00	; 0
    c238:	00 97       	sbiw	r24, 0x00	; 0
    c23a:	09 f0       	breq	.+2      	; 0xc23e <vfprintf+0x316>
    c23c:	1f 5f       	subi	r17, 0xFF	; 255
    c23e:	80 2e       	mov	r8, r16
    c240:	99 24       	eor	r9, r9
    c242:	03 fd       	sbrc	r16, 3
    c244:	12 c0       	rjmp	.+36     	; 0xc26a <vfprintf+0x342>
    c246:	00 ff       	sbrs	r16, 0
    c248:	0d c0       	rjmp	.+26     	; 0xc264 <vfprintf+0x33c>
    c24a:	fd 2c       	mov	r15, r13
    c24c:	1e 15       	cp	r17, r14
    c24e:	50 f4       	brcc	.+20     	; 0xc264 <vfprintf+0x33c>
    c250:	fe 0c       	add	r15, r14
    c252:	f1 1a       	sub	r15, r17
    c254:	1e 2d       	mov	r17, r14
    c256:	06 c0       	rjmp	.+12     	; 0xc264 <vfprintf+0x33c>
    c258:	80 e2       	ldi	r24, 0x20	; 32
    c25a:	90 e0       	ldi	r25, 0x00	; 0
    c25c:	b3 01       	movw	r22, r6
    c25e:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c262:	1f 5f       	subi	r17, 0xFF	; 255
    c264:	1e 15       	cp	r17, r14
    c266:	c0 f3       	brcs	.-16     	; 0xc258 <vfprintf+0x330>
    c268:	04 c0       	rjmp	.+8      	; 0xc272 <vfprintf+0x34a>
    c26a:	1e 15       	cp	r17, r14
    c26c:	10 f4       	brcc	.+4      	; 0xc272 <vfprintf+0x34a>
    c26e:	e1 1a       	sub	r14, r17
    c270:	01 c0       	rjmp	.+2      	; 0xc274 <vfprintf+0x34c>
    c272:	ee 24       	eor	r14, r14
    c274:	84 fe       	sbrs	r8, 4
    c276:	0f c0       	rjmp	.+30     	; 0xc296 <vfprintf+0x36e>
    c278:	80 e3       	ldi	r24, 0x30	; 48
    c27a:	90 e0       	ldi	r25, 0x00	; 0
    c27c:	b3 01       	movw	r22, r6
    c27e:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c282:	82 fe       	sbrs	r8, 2
    c284:	1f c0       	rjmp	.+62     	; 0xc2c4 <vfprintf+0x39c>
    c286:	81 fe       	sbrs	r8, 1
    c288:	03 c0       	rjmp	.+6      	; 0xc290 <vfprintf+0x368>
    c28a:	88 e5       	ldi	r24, 0x58	; 88
    c28c:	90 e0       	ldi	r25, 0x00	; 0
    c28e:	10 c0       	rjmp	.+32     	; 0xc2b0 <vfprintf+0x388>
    c290:	88 e7       	ldi	r24, 0x78	; 120
    c292:	90 e0       	ldi	r25, 0x00	; 0
    c294:	0d c0       	rjmp	.+26     	; 0xc2b0 <vfprintf+0x388>
    c296:	c4 01       	movw	r24, r8
    c298:	86 78       	andi	r24, 0x86	; 134
    c29a:	90 70       	andi	r25, 0x00	; 0
    c29c:	00 97       	sbiw	r24, 0x00	; 0
    c29e:	91 f0       	breq	.+36     	; 0xc2c4 <vfprintf+0x39c>
    c2a0:	81 fc       	sbrc	r8, 1
    c2a2:	02 c0       	rjmp	.+4      	; 0xc2a8 <vfprintf+0x380>
    c2a4:	80 e2       	ldi	r24, 0x20	; 32
    c2a6:	01 c0       	rjmp	.+2      	; 0xc2aa <vfprintf+0x382>
    c2a8:	8b e2       	ldi	r24, 0x2B	; 43
    c2aa:	07 fd       	sbrc	r16, 7
    c2ac:	8d e2       	ldi	r24, 0x2D	; 45
    c2ae:	90 e0       	ldi	r25, 0x00	; 0
    c2b0:	b3 01       	movw	r22, r6
    c2b2:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c2b6:	06 c0       	rjmp	.+12     	; 0xc2c4 <vfprintf+0x39c>
    c2b8:	80 e3       	ldi	r24, 0x30	; 48
    c2ba:	90 e0       	ldi	r25, 0x00	; 0
    c2bc:	b3 01       	movw	r22, r6
    c2be:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c2c2:	fa 94       	dec	r15
    c2c4:	df 14       	cp	r13, r15
    c2c6:	c0 f3       	brcs	.-16     	; 0xc2b8 <vfprintf+0x390>
    c2c8:	da 94       	dec	r13
    c2ca:	f2 01       	movw	r30, r4
    c2cc:	ed 0d       	add	r30, r13
    c2ce:	f1 1d       	adc	r31, r1
    c2d0:	80 81       	ld	r24, Z
    c2d2:	90 e0       	ldi	r25, 0x00	; 0
    c2d4:	b3 01       	movw	r22, r6
    c2d6:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c2da:	dd 20       	and	r13, r13
    c2dc:	a9 f7       	brne	.-22     	; 0xc2c8 <vfprintf+0x3a0>
    c2de:	06 c0       	rjmp	.+12     	; 0xc2ec <vfprintf+0x3c4>
    c2e0:	80 e2       	ldi	r24, 0x20	; 32
    c2e2:	90 e0       	ldi	r25, 0x00	; 0
    c2e4:	b3 01       	movw	r22, r6
    c2e6:	0e 94 bb 61 	call	0xc376	; 0xc376 <fputc>
    c2ea:	ea 94       	dec	r14
    c2ec:	ee 20       	and	r14, r14
    c2ee:	c1 f7       	brne	.-16     	; 0xc2e0 <vfprintf+0x3b8>
    c2f0:	40 ce       	rjmp	.-896    	; 0xbf72 <vfprintf+0x4a>
    c2f2:	f3 01       	movw	r30, r6
    c2f4:	86 81       	ldd	r24, Z+6	; 0x06
    c2f6:	97 81       	ldd	r25, Z+7	; 0x07
    c2f8:	02 c0       	rjmp	.+4      	; 0xc2fe <vfprintf+0x3d6>
    c2fa:	8f ef       	ldi	r24, 0xFF	; 255
    c2fc:	9f ef       	ldi	r25, 0xFF	; 255
    c2fe:	2d 96       	adiw	r28, 0x0d	; 13
    c300:	cd bf       	out	0x3d, r28	; 61
    c302:	de bf       	out	0x3e, r29	; 62
    c304:	df 91       	pop	r29
    c306:	cf 91       	pop	r28
    c308:	1f 91       	pop	r17
    c30a:	0f 91       	pop	r16
    c30c:	ff 90       	pop	r15
    c30e:	ef 90       	pop	r14
    c310:	df 90       	pop	r13
    c312:	cf 90       	pop	r12
    c314:	bf 90       	pop	r11
    c316:	af 90       	pop	r10
    c318:	9f 90       	pop	r9
    c31a:	8f 90       	pop	r8
    c31c:	7f 90       	pop	r7
    c31e:	6f 90       	pop	r6
    c320:	5f 90       	pop	r5
    c322:	4f 90       	pop	r4
    c324:	3f 90       	pop	r3
    c326:	2f 90       	pop	r2
    c328:	08 95       	ret

0000c32a <strnlen_P>:
    c32a:	fc 01       	movw	r30, r24
    c32c:	05 90       	lpm	r0, Z+
    c32e:	61 50       	subi	r22, 0x01	; 1
    c330:	70 40       	sbci	r23, 0x00	; 0
    c332:	01 10       	cpse	r0, r1
    c334:	d8 f7       	brcc	.-10     	; 0xc32c <strnlen_P+0x2>
    c336:	80 95       	com	r24
    c338:	90 95       	com	r25
    c33a:	8e 0f       	add	r24, r30
    c33c:	9f 1f       	adc	r25, r31
    c33e:	08 95       	ret

0000c340 <strnlen>:
    c340:	fc 01       	movw	r30, r24
    c342:	61 50       	subi	r22, 0x01	; 1
    c344:	70 40       	sbci	r23, 0x00	; 0
    c346:	01 90       	ld	r0, Z+
    c348:	01 10       	cpse	r0, r1
    c34a:	d8 f7       	brcc	.-10     	; 0xc342 <strnlen+0x2>
    c34c:	80 95       	com	r24
    c34e:	90 95       	com	r25
    c350:	8e 0f       	add	r24, r30
    c352:	9f 1f       	adc	r25, r31
    c354:	08 95       	ret

0000c356 <strrev>:
    c356:	dc 01       	movw	r26, r24
    c358:	fc 01       	movw	r30, r24
    c35a:	67 2f       	mov	r22, r23
    c35c:	71 91       	ld	r23, Z+
    c35e:	77 23       	and	r23, r23
    c360:	e1 f7       	brne	.-8      	; 0xc35a <strrev+0x4>
    c362:	32 97       	sbiw	r30, 0x02	; 2
    c364:	04 c0       	rjmp	.+8      	; 0xc36e <strrev+0x18>
    c366:	7c 91       	ld	r23, X
    c368:	6d 93       	st	X+, r22
    c36a:	70 83       	st	Z, r23
    c36c:	62 91       	ld	r22, -Z
    c36e:	ae 17       	cp	r26, r30
    c370:	bf 07       	cpc	r27, r31
    c372:	c8 f3       	brcs	.-14     	; 0xc366 <strrev+0x10>
    c374:	08 95       	ret

0000c376 <fputc>:
    c376:	0f 93       	push	r16
    c378:	1f 93       	push	r17
    c37a:	cf 93       	push	r28
    c37c:	df 93       	push	r29
    c37e:	8c 01       	movw	r16, r24
    c380:	eb 01       	movw	r28, r22
    c382:	8b 81       	ldd	r24, Y+3	; 0x03
    c384:	81 ff       	sbrs	r24, 1
    c386:	1b c0       	rjmp	.+54     	; 0xc3be <fputc+0x48>
    c388:	82 ff       	sbrs	r24, 2
    c38a:	0d c0       	rjmp	.+26     	; 0xc3a6 <fputc+0x30>
    c38c:	2e 81       	ldd	r18, Y+6	; 0x06
    c38e:	3f 81       	ldd	r19, Y+7	; 0x07
    c390:	8c 81       	ldd	r24, Y+4	; 0x04
    c392:	9d 81       	ldd	r25, Y+5	; 0x05
    c394:	28 17       	cp	r18, r24
    c396:	39 07       	cpc	r19, r25
    c398:	64 f4       	brge	.+24     	; 0xc3b2 <fputc+0x3c>
    c39a:	e8 81       	ld	r30, Y
    c39c:	f9 81       	ldd	r31, Y+1	; 0x01
    c39e:	01 93       	st	Z+, r16
    c3a0:	e8 83       	st	Y, r30
    c3a2:	f9 83       	std	Y+1, r31	; 0x01
    c3a4:	06 c0       	rjmp	.+12     	; 0xc3b2 <fputc+0x3c>
    c3a6:	e8 85       	ldd	r30, Y+8	; 0x08
    c3a8:	f9 85       	ldd	r31, Y+9	; 0x09
    c3aa:	80 2f       	mov	r24, r16
    c3ac:	19 95       	eicall
    c3ae:	00 97       	sbiw	r24, 0x00	; 0
    c3b0:	31 f4       	brne	.+12     	; 0xc3be <fputc+0x48>
    c3b2:	8e 81       	ldd	r24, Y+6	; 0x06
    c3b4:	9f 81       	ldd	r25, Y+7	; 0x07
    c3b6:	01 96       	adiw	r24, 0x01	; 1
    c3b8:	8e 83       	std	Y+6, r24	; 0x06
    c3ba:	9f 83       	std	Y+7, r25	; 0x07
    c3bc:	02 c0       	rjmp	.+4      	; 0xc3c2 <fputc+0x4c>
    c3be:	0f ef       	ldi	r16, 0xFF	; 255
    c3c0:	1f ef       	ldi	r17, 0xFF	; 255
    c3c2:	c8 01       	movw	r24, r16
    c3c4:	df 91       	pop	r29
    c3c6:	cf 91       	pop	r28
    c3c8:	1f 91       	pop	r17
    c3ca:	0f 91       	pop	r16
    c3cc:	08 95       	ret

0000c3ce <__ultoa_invert>:
    c3ce:	fa 01       	movw	r30, r20
    c3d0:	aa 27       	eor	r26, r26
    c3d2:	28 30       	cpi	r18, 0x08	; 8
    c3d4:	51 f1       	breq	.+84     	; 0xc42a <__ultoa_invert+0x5c>
    c3d6:	20 31       	cpi	r18, 0x10	; 16
    c3d8:	81 f1       	breq	.+96     	; 0xc43a <__ultoa_invert+0x6c>
    c3da:	e8 94       	clt
    c3dc:	6f 93       	push	r22
    c3de:	6e 7f       	andi	r22, 0xFE	; 254
    c3e0:	6e 5f       	subi	r22, 0xFE	; 254
    c3e2:	7f 4f       	sbci	r23, 0xFF	; 255
    c3e4:	8f 4f       	sbci	r24, 0xFF	; 255
    c3e6:	9f 4f       	sbci	r25, 0xFF	; 255
    c3e8:	af 4f       	sbci	r26, 0xFF	; 255
    c3ea:	b1 e0       	ldi	r27, 0x01	; 1
    c3ec:	3e d0       	rcall	.+124    	; 0xc46a <__ultoa_invert+0x9c>
    c3ee:	b4 e0       	ldi	r27, 0x04	; 4
    c3f0:	3c d0       	rcall	.+120    	; 0xc46a <__ultoa_invert+0x9c>
    c3f2:	67 0f       	add	r22, r23
    c3f4:	78 1f       	adc	r23, r24
    c3f6:	89 1f       	adc	r24, r25
    c3f8:	9a 1f       	adc	r25, r26
    c3fa:	a1 1d       	adc	r26, r1
    c3fc:	68 0f       	add	r22, r24
    c3fe:	79 1f       	adc	r23, r25
    c400:	8a 1f       	adc	r24, r26
    c402:	91 1d       	adc	r25, r1
    c404:	a1 1d       	adc	r26, r1
    c406:	6a 0f       	add	r22, r26
    c408:	71 1d       	adc	r23, r1
    c40a:	81 1d       	adc	r24, r1
    c40c:	91 1d       	adc	r25, r1
    c40e:	a1 1d       	adc	r26, r1
    c410:	20 d0       	rcall	.+64     	; 0xc452 <__ultoa_invert+0x84>
    c412:	09 f4       	brne	.+2      	; 0xc416 <__ultoa_invert+0x48>
    c414:	68 94       	set
    c416:	3f 91       	pop	r19
    c418:	2a e0       	ldi	r18, 0x0A	; 10
    c41a:	26 9f       	mul	r18, r22
    c41c:	11 24       	eor	r1, r1
    c41e:	30 19       	sub	r19, r0
    c420:	30 5d       	subi	r19, 0xD0	; 208
    c422:	31 93       	st	Z+, r19
    c424:	de f6       	brtc	.-74     	; 0xc3dc <__ultoa_invert+0xe>
    c426:	cf 01       	movw	r24, r30
    c428:	08 95       	ret
    c42a:	46 2f       	mov	r20, r22
    c42c:	47 70       	andi	r20, 0x07	; 7
    c42e:	40 5d       	subi	r20, 0xD0	; 208
    c430:	41 93       	st	Z+, r20
    c432:	b3 e0       	ldi	r27, 0x03	; 3
    c434:	0f d0       	rcall	.+30     	; 0xc454 <__ultoa_invert+0x86>
    c436:	c9 f7       	brne	.-14     	; 0xc42a <__ultoa_invert+0x5c>
    c438:	f6 cf       	rjmp	.-20     	; 0xc426 <__ultoa_invert+0x58>
    c43a:	46 2f       	mov	r20, r22
    c43c:	4f 70       	andi	r20, 0x0F	; 15
    c43e:	40 5d       	subi	r20, 0xD0	; 208
    c440:	4a 33       	cpi	r20, 0x3A	; 58
    c442:	18 f0       	brcs	.+6      	; 0xc44a <__ultoa_invert+0x7c>
    c444:	49 5d       	subi	r20, 0xD9	; 217
    c446:	31 fd       	sbrc	r19, 1
    c448:	40 52       	subi	r20, 0x20	; 32
    c44a:	41 93       	st	Z+, r20
    c44c:	02 d0       	rcall	.+4      	; 0xc452 <__ultoa_invert+0x84>
    c44e:	a9 f7       	brne	.-22     	; 0xc43a <__ultoa_invert+0x6c>
    c450:	ea cf       	rjmp	.-44     	; 0xc426 <__ultoa_invert+0x58>
    c452:	b4 e0       	ldi	r27, 0x04	; 4
    c454:	a6 95       	lsr	r26
    c456:	97 95       	ror	r25
    c458:	87 95       	ror	r24
    c45a:	77 95       	ror	r23
    c45c:	67 95       	ror	r22
    c45e:	ba 95       	dec	r27
    c460:	c9 f7       	brne	.-14     	; 0xc454 <__ultoa_invert+0x86>
    c462:	00 97       	sbiw	r24, 0x00	; 0
    c464:	61 05       	cpc	r22, r1
    c466:	71 05       	cpc	r23, r1
    c468:	08 95       	ret
    c46a:	9b 01       	movw	r18, r22
    c46c:	ac 01       	movw	r20, r24
    c46e:	0a 2e       	mov	r0, r26
    c470:	06 94       	lsr	r0
    c472:	57 95       	ror	r21
    c474:	47 95       	ror	r20
    c476:	37 95       	ror	r19
    c478:	27 95       	ror	r18
    c47a:	ba 95       	dec	r27
    c47c:	c9 f7       	brne	.-14     	; 0xc470 <__ultoa_invert+0xa2>
    c47e:	62 0f       	add	r22, r18
    c480:	73 1f       	adc	r23, r19
    c482:	84 1f       	adc	r24, r20
    c484:	95 1f       	adc	r25, r21
    c486:	a0 1d       	adc	r26, r0
    c488:	08 95       	ret

0000c48a <_exit>:
    c48a:	f8 94       	cli

0000c48c <__stop_program>:
    c48c:	ff cf       	rjmp	.-2      	; 0xc48c <__stop_program>
